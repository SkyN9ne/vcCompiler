#define V_COMMIT_HASH "d3489d4"

#ifndef V_COMMIT_HASH
	#define V_COMMIT_HASH "57fa976"
#endif

#ifndef V_CURRENT_COMMIT_HASH
	#define V_CURRENT_COMMIT_HASH "d3489d4"
#endif

// V comptime_definitions:
#define __VTHREADS__ (1)

// V typedefs:
typedef struct IError IError;
typedef struct rand__PRNG rand__PRNG;
typedef struct hash__Hasher hash__Hasher;
typedef struct hash__Hash32er hash__Hash32er;
typedef struct hash__Hash64er hash__Hash64er;
typedef struct v__ast__walker__Visitor v__ast__walker__Visitor;
typedef struct none none;
typedef struct v__ast__TypeDecl v__ast__TypeDecl;
typedef struct v__ast__Expr v__ast__Expr;
typedef struct v__ast__Stmt v__ast__Stmt;
typedef struct v__ast__ScopeObject v__ast__ScopeObject;
typedef struct v__ast__Node v__ast__Node;
typedef struct v__ast__ComptTimeConstValue v__ast__ComptTimeConstValue;
typedef struct v__ast__IdentInfo v__ast__IdentInfo;
typedef struct v__ast__AsmArg v__ast__AsmArg;
typedef struct v__ast__TypeInfo v__ast__TypeInfo;

// BEGIN_multi_return_typedefs
typedef struct multi_return_u32_u32 multi_return_u32_u32;
typedef struct multi_return_u32_u32_u32 multi_return_u32_u32_u32;
typedef struct multi_return_int_strconv__PrepNumber multi_return_int_strconv__PrepNumber;
typedef struct multi_return_u64_int multi_return_u64_int;
typedef struct multi_return_strconv__Dec32_bool multi_return_strconv__Dec32_bool;
typedef struct multi_return_strconv__Dec64_bool multi_return_strconv__Dec64_bool;
typedef struct multi_return_string_int multi_return_string_int;
typedef struct multi_return_int_bool multi_return_int_bool;
typedef struct multi_return_int_int multi_return_int_int;
typedef struct multi_return_ref_v__pref__Preferences_string multi_return_ref_v__pref__Preferences_string;
typedef struct multi_return_string_string multi_return_string_string;
typedef struct multi_return_u64_u64 multi_return_u64_u64;
typedef struct multi_return_f64_int multi_return_f64_int;
typedef struct multi_return_int_int_int multi_return_int_int_int;
typedef struct multi_return_int_int_int_int_i64_bool multi_return_int_int_int_int_i64_bool;
typedef struct multi_return_Array_string_int multi_return_Array_string_int;
typedef struct multi_return_Array_string_v__vmod__ModFileAndFolder multi_return_Array_string_v__vmod__ModFileAndFolder;
typedef struct multi_return_string_bool multi_return_string_bool;
typedef struct multi_return_v__ast__Fn_Array_v__ast__Type multi_return_v__ast__Fn_Array_v__ast__Type;
typedef struct multi_return_v__ast__StructField_Array_v__ast__Type multi_return_v__ast__StructField_Array_v__ast__Type;
typedef struct multi_return_ref_v__ast__TypeSymbol_int multi_return_ref_v__ast__TypeSymbol_int;
typedef struct multi_return_bool_bool_int multi_return_bool_bool_int;
typedef struct multi_return_string_v__token__Position multi_return_string_v__token__Position;
typedef struct multi_return_bool_int_int multi_return_bool_int_int;
typedef struct multi_return_Array_v__ast__Param_bool_bool multi_return_Array_v__ast__Param_bool_bool;
typedef struct multi_return_Array_v__ast__Expr_Array_v__ast__Comment multi_return_Array_v__ast__Expr_Array_v__ast__Comment;
typedef struct multi_return_ref_v__ast__File_Array_v__vet__Error multi_return_ref_v__ast__File_Array_v__vet__Error;
typedef struct multi_return_Array_v__ast__Type_Array_string multi_return_Array_v__ast__Type_Array_string;
typedef struct multi_return_Map_string_v__ast__FnDecl_Map_string_v__ast__ConstField_Map_string_v__ast__GlobalField multi_return_Map_string_v__ast__FnDecl_Map_string_v__ast__ConstField_Map_string_v__ast__GlobalField;
typedef struct multi_return_bool_Array_string multi_return_bool_Array_string;
typedef struct multi_return_Array_string_Array_string_Array_string multi_return_Array_string_Array_string_Array_string;
typedef struct multi_return_string_string_string_string multi_return_string_string_string_string;
typedef struct multi_return_int_string_string_string multi_return_int_string_string_string;
typedef struct multi_return_Array_string_Array_string_Array_bool multi_return_Array_string_Array_string_Array_bool;
typedef struct multi_return_u64_string multi_return_u64_string;
typedef struct multi_return_int_literal_int_literal multi_return_int_literal_int_literal;
// END_multi_return_typedefs

typedef struct strconv__BF_param strconv__BF_param;
typedef struct strconv__PrepNumber strconv__PrepNumber;
typedef struct strconv__Dec32 strconv__Dec32;
typedef struct strconv__Dec64 strconv__Dec64;
typedef struct strconv__Uint128 strconv__Uint128;
typedef union strconv__Uf32 strconv__Uf32;
typedef union strconv__Uf64 strconv__Uf64;
typedef union strconv__Float64u strconv__Float64u;
typedef union strconv__Float32u strconv__Float32u;
typedef struct array array;
typedef struct VCastTypeIndexName VCastTypeIndexName;
typedef struct VAssertMetaInfo VAssertMetaInfo;
typedef struct MethodArgs MethodArgs;
typedef struct FunctionData FunctionData;
typedef struct FieldData FieldData;
typedef struct StructAttribute StructAttribute;
typedef struct SymbolInfo SymbolInfo;
typedef struct SymbolInfoContainer SymbolInfoContainer;
typedef struct Line64 Line64;
typedef struct ExceptionRecord ExceptionRecord;
typedef struct ContextRecord ContextRecord;
typedef struct ExceptionPointers ExceptionPointers;
typedef struct DenseArray DenseArray;
typedef struct map map;
typedef struct Error Error;
typedef struct None__ None__;
typedef struct Option Option;
typedef struct VMemoryBlock VMemoryBlock;
typedef struct SortedMap SortedMap;
typedef struct mapnode mapnode;
typedef struct string string;
typedef struct RepIndex RepIndex;
typedef union StrIntpMem StrIntpMem;
typedef struct StrIntpCgenData StrIntpCgenData;
typedef struct StrIntpData StrIntpData;
typedef struct strings__textscanner__TextScanner strings__textscanner__TextScanner;
typedef struct v__token__KeywordsMatcher v__token__KeywordsMatcher;
typedef struct v__token__WIndex v__token__WIndex;
typedef struct v__token__Position v__token__Position;
typedef struct v__token__Token v__token__Token;
typedef struct time__TimeParseError time__TimeParseError;
typedef struct time__StopWatchOptions time__StopWatchOptions;
typedef struct time__StopWatch time__StopWatch;
typedef struct time__Time time__Time;
typedef struct time__SystemTime time__SystemTime;
typedef struct v__dotgraph__DotGraph v__dotgraph__DotGraph;
typedef struct v__dotgraph__NewNodeConfig v__dotgraph__NewNodeConfig;
typedef struct v__dotgraph__NewEdgeConfig v__dotgraph__NewEdgeConfig;
typedef struct flag__Flag flag__Flag;
typedef struct flag__UnkownFlagError flag__UnkownFlagError;
typedef struct flag__MinimumArgsCountError flag__MinimumArgsCountError;
typedef struct flag__MaximumArgsCountError flag__MaximumArgsCountError;
typedef struct flag__NoArgsExpectedError flag__NoArgsExpectedError;
typedef struct flag__FlagParser flag__FlagParser;
typedef struct semver__RawVersion semver__RawVersion;
typedef struct semver__Comparator semver__Comparator;
typedef struct semver__ComparatorSet semver__ComparatorSet;
typedef struct semver__Range semver__Range;
typedef struct semver__InvalidComparatorCountError semver__InvalidComparatorCountError;
typedef struct semver__InvalidComparatorFormatError semver__InvalidComparatorFormatError;
typedef struct semver__Version semver__Version;
typedef struct semver__EmptyInputError semver__EmptyInputError;
typedef struct semver__InvalidVersionFormatError semver__InvalidVersionFormatError;
typedef struct os__File os__File;
typedef struct os__FileInfo os__FileInfo;
typedef struct os__ErrFileNotOpened os__ErrFileNotOpened;
typedef struct os__ErrSizeOfTypeIs0 os__ErrSizeOfTypeIs0;
typedef struct os__FilePermission os__FilePermission;
typedef struct os__FileMode os__FileMode;
typedef struct os__Result os__Result;
typedef struct os__ErrExecutableNotFound os__ErrExecutableNotFound;
typedef struct os__Uname os__Uname;
typedef struct os__Filetime os__Filetime;
typedef struct os__Win32finddata os__Win32finddata;
typedef struct os__ProcessInformation os__ProcessInformation;
typedef struct os__StartupInfo os__StartupInfo;
typedef struct os__SecurityAttributes os__SecurityAttributes;
typedef struct os__ExceptionRecord os__ExceptionRecord;
typedef struct os__ContextRecord os__ContextRecord;
typedef struct os__ExceptionPointers os__ExceptionPointers;
typedef struct os__Process os__Process;
typedef struct os__WProcess os__WProcess;
typedef struct v__errors__Error v__errors__Error;
typedef struct v__errors__Warning v__errors__Warning;
typedef struct v__errors__Notice v__errors__Notice;
typedef struct v__depgraph__DepGraphNode v__depgraph__DepGraphNode;
typedef struct v__depgraph__DepGraph v__depgraph__DepGraph;
typedef struct v__depgraph__OrderedDepMap v__depgraph__OrderedDepMap;
typedef struct v__depgraph__NodeNames v__depgraph__NodeNames;
typedef struct v__vet__Error v__vet__Error;
typedef struct term__Coord term__Coord;
typedef struct v__vcache__CacheManager v__vcache__CacheManager;
typedef struct v__vmod__Manifest v__vmod__Manifest;
typedef struct v__vmod__Scanner v__vmod__Scanner;
typedef struct v__vmod__Parser v__vmod__Parser;
typedef struct v__vmod__Token v__vmod__Token;
typedef struct v__vmod__ModFileAndFolder v__vmod__ModFileAndFolder;
typedef struct v__vmod__ModFileCacher v__vmod__ModFileCacher;
typedef struct v__cflag__CFlag v__cflag__CFlag;
typedef struct rand__config__PRNGConfigStruct rand__config__PRNGConfigStruct;
typedef struct rand__wyrand__WyRandRNG rand__wyrand__WyRandRNG;
typedef struct v__pkgconfig__Main v__pkgconfig__Main;
typedef struct v__pkgconfig__MainOptions v__pkgconfig__MainOptions;
typedef struct v__pkgconfig__Options v__pkgconfig__Options;
typedef struct v__pkgconfig__PkgConfig v__pkgconfig__PkgConfig;
typedef struct v__pref__Preferences v__pref__Preferences;
typedef struct sync__Subscription sync__Subscription;
typedef struct sync__Channel sync__Channel;
typedef struct sync__ManyTimes sync__ManyTimes;
typedef struct sync__Once sync__Once;
typedef struct sync__Mutex sync__Mutex;
typedef struct sync__RwMutex sync__RwMutex;
typedef struct sync__Semaphore sync__Semaphore;
typedef struct sync__WaitGroup sync__WaitGroup;
typedef struct v__util__EManager v__util__EManager;
typedef struct v__util__LinesCache v__util__LinesCache;
typedef struct v__util__Possibility v__util__Possibility;
typedef struct v__util__Suggestion v__util__Suggestion;
typedef struct v__util__Surrounder v__util__Surrounder;
typedef struct v__util__Timers v__util__Timers;
typedef struct v__util__TimerParams v__util__TimerParams;
typedef struct v__util__SourceCache v__util__SourceCache;
typedef struct sync__pool__PoolProcessor sync__pool__PoolProcessor;
typedef struct sync__pool__PoolProcessorConfig sync__pool__PoolProcessorConfig;
typedef struct v__ast__TypeNode v__ast__TypeNode;
typedef struct v__ast__EmptyExpr v__ast__EmptyExpr;
typedef struct v__ast__EmptyStmt v__ast__EmptyStmt;
typedef struct v__ast__EmptyNode v__ast__EmptyNode;
typedef struct v__ast__Block v__ast__Block;
typedef struct v__ast__ExprStmt v__ast__ExprStmt;
typedef struct v__ast__IntegerLiteral v__ast__IntegerLiteral;
typedef struct v__ast__FloatLiteral v__ast__FloatLiteral;
typedef struct v__ast__StringLiteral v__ast__StringLiteral;
typedef struct v__ast__StringInterLiteral v__ast__StringInterLiteral;
typedef struct v__ast__CharLiteral v__ast__CharLiteral;
typedef struct v__ast__BoolLiteral v__ast__BoolLiteral;
typedef struct v__ast__SelectorExpr v__ast__SelectorExpr;
typedef struct v__ast__Module v__ast__Module;
typedef struct v__ast__StructField v__ast__StructField;
typedef struct v__ast__ConstField v__ast__ConstField;
typedef struct v__ast__ConstDecl v__ast__ConstDecl;
typedef struct v__ast__StructDecl v__ast__StructDecl;
typedef struct v__ast__Embed v__ast__Embed;
typedef struct v__ast__InterfaceEmbedding v__ast__InterfaceEmbedding;
typedef struct v__ast__InterfaceDecl v__ast__InterfaceDecl;
typedef struct v__ast__StructInitField v__ast__StructInitField;
typedef struct v__ast__StructInitEmbed v__ast__StructInitEmbed;
typedef struct v__ast__StructInit v__ast__StructInit;
typedef struct v__ast__Import v__ast__Import;
typedef struct v__ast__ImportSymbol v__ast__ImportSymbol;
typedef struct v__ast__AnonFn v__ast__AnonFn;
typedef struct v__ast__FnDecl v__ast__FnDecl;
typedef struct v__ast__BranchStmt v__ast__BranchStmt;
typedef struct v__ast__CallExpr v__ast__CallExpr;
typedef struct v__ast__CallArg v__ast__CallArg;
typedef struct v__ast__Return v__ast__Return;
typedef struct v__ast__Var v__ast__Var;
typedef struct v__ast__ScopeStructField v__ast__ScopeStructField;
typedef struct v__ast__GlobalField v__ast__GlobalField;
typedef struct v__ast__GlobalDecl v__ast__GlobalDecl;
typedef struct v__ast__EmbeddedFile v__ast__EmbeddedFile;
typedef struct v__ast__File v__ast__File;
typedef struct v__ast__IdentFn v__ast__IdentFn;
typedef struct v__ast__IdentVar v__ast__IdentVar;
typedef struct v__ast__Ident v__ast__Ident;
typedef struct v__ast__InfixExpr v__ast__InfixExpr;
typedef struct v__ast__PostfixExpr v__ast__PostfixExpr;
typedef struct v__ast__PrefixExpr v__ast__PrefixExpr;
typedef struct v__ast__IndexExpr v__ast__IndexExpr;
typedef struct v__ast__IfExpr v__ast__IfExpr;
typedef struct v__ast__IfBranch v__ast__IfBranch;
typedef struct v__ast__UnsafeExpr v__ast__UnsafeExpr;
typedef struct v__ast__LockExpr v__ast__LockExpr;
typedef struct v__ast__MatchExpr v__ast__MatchExpr;
typedef struct v__ast__MatchBranch v__ast__MatchBranch;
typedef struct v__ast__SelectExpr v__ast__SelectExpr;
typedef struct v__ast__SelectBranch v__ast__SelectBranch;
typedef struct v__ast__ComptimeFor v__ast__ComptimeFor;
typedef struct v__ast__ForStmt v__ast__ForStmt;
typedef struct v__ast__ForInStmt v__ast__ForInStmt;
typedef struct v__ast__ForCStmt v__ast__ForCStmt;
typedef struct v__ast__HashStmt v__ast__HashStmt;
typedef struct v__ast__AssignStmt v__ast__AssignStmt;
typedef struct v__ast__AsCast v__ast__AsCast;
typedef struct v__ast__EnumVal v__ast__EnumVal;
typedef struct v__ast__EnumField v__ast__EnumField;
typedef struct v__ast__EnumDecl v__ast__EnumDecl;
typedef struct v__ast__AliasTypeDecl v__ast__AliasTypeDecl;
typedef struct v__ast__SumTypeDecl v__ast__SumTypeDecl;
typedef struct v__ast__FnTypeDecl v__ast__FnTypeDecl;
typedef struct v__ast__DeferStmt v__ast__DeferStmt;
typedef struct v__ast__ParExpr v__ast__ParExpr;
typedef struct v__ast__GoExpr v__ast__GoExpr;
typedef struct v__ast__GotoLabel v__ast__GotoLabel;
typedef struct v__ast__GotoStmt v__ast__GotoStmt;
typedef struct v__ast__ArrayInit v__ast__ArrayInit;
typedef struct v__ast__ArrayDecompose v__ast__ArrayDecompose;
typedef struct v__ast__ChanInit v__ast__ChanInit;
typedef struct v__ast__MapInit v__ast__MapInit;
typedef struct v__ast__RangeExpr v__ast__RangeExpr;
typedef struct v__ast__CastExpr v__ast__CastExpr;
typedef struct v__ast__AsmStmt v__ast__AsmStmt;
typedef struct v__ast__AsmTemplate v__ast__AsmTemplate;
typedef struct v__ast__AsmRegister v__ast__AsmRegister;
typedef struct v__ast__AsmDisp v__ast__AsmDisp;
typedef struct v__ast__AsmAlias v__ast__AsmAlias;
typedef struct v__ast__AsmAddressing v__ast__AsmAddressing;
typedef struct v__ast__AsmClobbered v__ast__AsmClobbered;
typedef struct v__ast__AsmIO v__ast__AsmIO;
typedef struct v__ast__AssertStmt v__ast__AssertStmt;
typedef struct v__ast__IfGuardExpr v__ast__IfGuardExpr;
typedef struct v__ast__OrExpr v__ast__OrExpr;
typedef struct v__ast__Assoc v__ast__Assoc;
typedef struct v__ast__SizeOf v__ast__SizeOf;
typedef struct v__ast__IsRefType v__ast__IsRefType;
typedef struct v__ast__OffsetOf v__ast__OffsetOf;
typedef struct v__ast__Likely v__ast__Likely;
typedef struct v__ast__TypeOf v__ast__TypeOf;
typedef struct v__ast__DumpExpr v__ast__DumpExpr;
typedef struct v__ast__Comment v__ast__Comment;
typedef struct v__ast__ConcatExpr v__ast__ConcatExpr;
typedef struct v__ast__AtExpr v__ast__AtExpr;
typedef struct v__ast__ComptimeSelector v__ast__ComptimeSelector;
typedef struct v__ast__ComptimeCall v__ast__ComptimeCall;
typedef struct v__ast__None v__ast__None;
typedef struct v__ast__SqlStmt v__ast__SqlStmt;
typedef struct v__ast__SqlStmtLine v__ast__SqlStmtLine;
typedef struct v__ast__SqlExpr v__ast__SqlExpr;
typedef struct v__ast__NodeError v__ast__NodeError;
typedef struct v__ast__CTempVar v__ast__CTempVar;
typedef struct v__ast__Attr v__ast__Attr;
typedef struct v__ast__Scope v__ast__Scope;
typedef struct v__ast__Table v__ast__Table;
typedef struct v__ast__Fn v__ast__Fn;
typedef struct v__ast__Param v__ast__Param;
typedef struct v__ast__GetEmbedsOptions v__ast__GetEmbedsOptions;
typedef struct v__ast__TypeSymbol v__ast__TypeSymbol;
typedef struct v__ast__MultiReturn v__ast__MultiReturn;
typedef struct v__ast__FnType v__ast__FnType;
typedef struct v__ast__Struct v__ast__Struct;
typedef struct v__ast__GenericInst v__ast__GenericInst;
typedef struct v__ast__Interface v__ast__Interface;
typedef struct v__ast__Enum v__ast__Enum;
typedef struct v__ast__Alias v__ast__Alias;
typedef struct v__ast__Aggregate v__ast__Aggregate;
typedef struct v__ast__Array v__ast__Array;
typedef struct v__ast__ArrayFixed v__ast__ArrayFixed;
typedef struct v__ast__Chan v__ast__Chan;
typedef struct v__ast__Thread v__ast__Thread;
typedef struct v__ast__Map v__ast__Map;
typedef struct v__ast__SumType v__ast__SumType;
typedef struct v__ast__FnSignatureOpts v__ast__FnSignatureOpts;
typedef struct v__checker__Checker v__checker__Checker;
typedef struct v__transformer__KeyVal v__transformer__KeyVal;
typedef struct v__transformer__IndexState v__transformer__IndexState;
typedef struct v__transformer__Transformer v__transformer__Transformer;
typedef struct v__markused__Walker v__markused__Walker;
typedef struct v__gen__c__UnsupportedAssertCtempTransform v__gen__c__UnsupportedAssertCtempTransform;
typedef struct v__gen__c__StrType v__gen__c__StrType;
typedef struct v__gen__c__Gen v__gen__c__Gen;
typedef struct v__gen__c__SumtypeCastingFn v__gen__c__SumtypeCastingFn;
typedef struct v__gen__c__GenSafeIntegerCfg v__gen__c__GenSafeIntegerCfg;
typedef struct v__gen__c__ProfileCounterMeta v__gen__c__ProfileCounterMeta;
typedef struct v__gen__c__Type v__gen__c__Type;
typedef struct v__scanner__Scanner v__scanner__Scanner;
typedef struct v__ast__walker__Inspector v__ast__walker__Inspector;
typedef struct v__parser__ReceiverParsingInfo v__parser__ReceiverParsingInfo;
typedef struct v__parser__Parser v__parser__Parser;
typedef struct v__parser__EatCommentsConfig v__parser__EatCommentsConfig;
typedef struct v__callgraph__Mapper v__callgraph__Mapper;
typedef struct v__builder__Builder v__builder__Builder;
typedef struct v__builder__FunctionRedefinition v__builder__FunctionRedefinition;
typedef struct v__builder__CcompilerOptions v__builder__CcompilerOptions;
typedef struct v__builder__MsvcResult v__builder__MsvcResult;
typedef struct v__builder__WindowsKit v__builder__WindowsKit;
typedef struct v__builder__VsInstallation v__builder__VsInstallation;
typedef struct v__builder__MsvcStringFlags v__builder__MsvcStringFlags;
typedef struct Option_int Option_int;
typedef struct Option_u64 Option_u64;
typedef struct Option_i64 Option_i64;
typedef struct Option_byte Option_byte;
typedef struct Option_voidptr Option_voidptr;
typedef struct Option_time__Time Option_time__Time;
typedef struct Option_multi_return_int_int_int Option_multi_return_int_int_int;
typedef struct Option_multi_return_int_int_int_int_i64_bool Option_multi_return_int_int_int_int_i64_bool;
typedef struct Option_string Option_string;
typedef struct Option_bool Option_bool;
typedef struct Option_f64 Option_f64;
typedef struct Option_void Option_void;
typedef struct Option_flag__Flag Option_flag__Flag;
typedef struct Option_Array_string Option_Array_string;
typedef struct Option_semver__Range Option_semver__Range;
typedef struct Option_semver__Version Option_semver__Version;
typedef struct Option_semver__ComparatorSet Option_semver__ComparatorSet;
typedef struct Option_semver__Comparator Option_semver__Comparator;
typedef struct Option_os__File Option_os__File;
typedef struct Option_FILE_ptr Option_FILE_ptr;
typedef struct Option_Array_byte Option_Array_byte;
typedef struct Option_os__SignalHandler Option_os__SignalHandler;
typedef struct Option_term__Coord Option_term__Coord;
typedef struct Option_v__vmod__Manifest Option_v__vmod__Manifest;
typedef struct Option_multi_return_Array_string_int Option_multi_return_Array_string_int;
typedef struct Option_v__pkgconfig__PkgConfig_ptr Option_v__pkgconfig__PkgConfig_ptr;
typedef struct Option_v__pkgconfig__Main_ptr Option_v__pkgconfig__Main_ptr;
typedef struct Option_v__pref__OS Option_v__pref__OS;
typedef struct Option_v__pref__Arch Option_v__pref__Arch;
typedef struct Option_v__pref__Backend Option_v__pref__Backend;
typedef struct Option_time__StopWatch Option_time__StopWatch;
typedef struct Option_v__ast__Ident Option_v__ast__Ident;
typedef struct Option_i8 Option_i8;
typedef struct Option_i16 Option_i16;
typedef struct Option_u16 Option_u16;
typedef struct Option_u32 Option_u32;
typedef struct Option_f32 Option_f32;
typedef struct Option_v__ast__ComptTimeConstValue Option_v__ast__ComptTimeConstValue;
typedef struct Option_v__ast__ScopeObject Option_v__ast__ScopeObject;
typedef struct Option_v__ast__ScopeStructField Option_v__ast__ScopeStructField;
typedef struct Option_v__ast__Var_ptr Option_v__ast__Var_ptr;
typedef struct Option_v__ast__GlobalField_ptr Option_v__ast__GlobalField_ptr;
typedef struct Option_v__ast__ConstField_ptr Option_v__ast__ConstField_ptr;
typedef struct Option_v__ast__Fn Option_v__ast__Fn;
typedef struct Option_multi_return_v__ast__Fn_Array_v__ast__Type Option_multi_return_v__ast__Fn_Array_v__ast__Type;
typedef struct Option_v__ast__StructField Option_v__ast__StructField;
typedef struct Option_multi_return_v__ast__StructField_Array_v__ast__Type Option_multi_return_v__ast__StructField_Array_v__ast__Type;
typedef struct Option_v__ast__TypeSymbol_ptr Option_v__ast__TypeSymbol_ptr;
typedef struct Option_Array_Array_v__ast__Type Option_Array_Array_v__ast__Type;
typedef struct Option_v__ast__Type Option_v__ast__Type;
typedef struct Option_v__ast__InterfaceDecl Option_v__ast__InterfaceDecl;
typedef struct Option_v__ast__EnumDecl Option_v__ast__EnumDecl;
typedef struct Option_v__ast__Expr Option_v__ast__Expr;
typedef struct Option_v__ast__Param Option_v__ast__Param;
typedef struct Option_Array_v__ast__Type Option_Array_v__ast__Type;
typedef struct Option_v__ast__ConstField Option_v__ast__ConstField;
typedef struct Option_v__ast__GlobalField Option_v__ast__GlobalField;
typedef struct Option_v__ast__FnDecl Option_v__ast__FnDecl;
typedef struct Option_v__ast__Stmt_ptr Option_v__ast__Stmt_ptr;
typedef struct Option_v__builder__MsvcResult Option_v__builder__MsvcResult;
typedef struct Option_v__builder__WindowsKit Option_v__builder__WindowsKit;
typedef struct Option_v__builder__VsInstallation Option_v__builder__VsInstallation;
typedef struct __shared__Array_string __shared__Array_string;
typedef struct __shared__Map_string_bool __shared__Map_string_bool;

// V cheaders:
// Generated by the V compiler

#if defined(__TINYC__) && defined(__has_include)
// tcc does not support has_include properly yet, turn it off completely
#undef __has_include
#endif

#if defined(__has_include)

#if __has_include(<inttypes.h>)
#include <inttypes.h>
#else
#error VERROR_MESSAGE The C compiler can not find <inttypes.h>. Please install build-essentials
#endif

#else
#include <inttypes.h>
#endif


#if defined(__has_include)

#if __has_include(<stddef.h>)
#include <stddef.h>
#else
#error VERROR_MESSAGE The C compiler can not find <stddef.h>. Please install build-essentials
#endif

#else
#include <stddef.h>
#endif


//================================== builtin types ================================*/
typedef int64_t i64;
typedef int16_t i16;
typedef int8_t i8;
typedef uint64_t u64;
typedef uint32_t u32;
typedef uint8_t u8;
typedef uint16_t u16;
typedef uint8_t byte;
typedef uint32_t rune;
typedef size_t usize;
typedef ptrdiff_t isize;
typedef float f32;
typedef double f64;
typedef int64_t int_literal;
typedef double float_literal;
typedef unsigned char* byteptr;
typedef void* voidptr;
typedef char* charptr;
typedef byte array_fixed_byte_300 [300];

typedef struct sync__Channel* chan;

#ifndef __cplusplus
	#ifndef bool
		#ifdef CUSTOM_DEFINE_4bytebool
			typedef int bool;
		#else
			typedef byte bool;
		#endif
		#define true 1
		#define false 0
	#endif
#endif

typedef u64 (*MapHashFn)(voidptr);
typedef bool (*MapEqFn)(voidptr, voidptr);
typedef void (*MapCloneFn)(voidptr, voidptr);
typedef void (*MapFreeFn)(voidptr);

//============================== HELPER C MACROS =============================*/
// _SLIT0 is used as NULL string for literal arguments
// `"" s` is used to enforce a string literal argument
#define _SLIT0 (string){.str=(byteptr)(""), .len=0, .is_lit=1}
#define _SLIT(s) ((string){.str=(byteptr)("" s), .len=(sizeof(s)-1), .is_lit=1})
#define _SLEN(s, n) ((string){.str=(byteptr)("" s), .len=n, .is_lit=1})

// take the address of an rvalue
#define ADDR(type, expr) (&((type[]){expr}[0]))

// copy something to the heap
#define HEAP(type, expr) ((type*)memdup((void*)&((type[]){expr}[0]), sizeof(type)))
#define HEAP_noscan(type, expr) ((type*)memdup_noscan((void*)&((type[]){expr}[0]), sizeof(type)))

#define _PUSH_MANY(arr, val, tmp, tmp_typ) {tmp_typ tmp = (val); array_push_many(arr, tmp.data, tmp.len);}
#define _PUSH_MANY_noscan(arr, val, tmp, tmp_typ) {tmp_typ tmp = (val); array_push_many_noscan(arr, tmp.data, tmp.len);}

// unsigned/signed comparisons
static inline bool _us32_gt(uint32_t a, int32_t b) { return a > INT32_MAX || (int32_t)a > b; }
static inline bool _us32_ge(uint32_t a, int32_t b) { return a >= INT32_MAX || (int32_t)a >= b; }
static inline bool _us32_eq(uint32_t a, int32_t b) { return a <= INT32_MAX && (int32_t)a == b; }
static inline bool _us32_ne(uint32_t a, int32_t b) { return a > INT32_MAX || (int32_t)a != b; }
static inline bool _us32_le(uint32_t a, int32_t b) { return a <= INT32_MAX && (int32_t)a <= b; }
static inline bool _us32_lt(uint32_t a, int32_t b) { return a < INT32_MAX && (int32_t)a < b; }
static inline bool _us64_gt(uint64_t a, int64_t b) { return a > INT64_MAX || (int64_t)a > b; }
static inline bool _us64_ge(uint64_t a, int64_t b) { return a >= INT64_MAX || (int64_t)a >= b; }
static inline bool _us64_eq(uint64_t a, int64_t b) { return a <= INT64_MAX && (int64_t)a == b; }
static inline bool _us64_ne(uint64_t a, int64_t b) { return a > INT64_MAX || (int64_t)a != b; }
static inline bool _us64_le(uint64_t a, int64_t b) { return a <= INT64_MAX && (int64_t)a <= b; }
static inline bool _us64_lt(uint64_t a, int64_t b) { return a < INT64_MAX && (int64_t)a < b; }

#define EMPTY_VARG_INITIALIZATION 0
#define EMPTY_STRUCT_DECLARATION
#define EMPTY_STRUCT_INITIALIZATION
// Due to a tcc bug, the length of an array needs to be specified, but GCC crashes if it is...
#define EMPTY_ARRAY_OF_ELEMS(x,n) (x[])
#define TCCSKIP(x) x

#define __NOINLINE __attribute__((noinline))
#define __IRQHANDLER __attribute__((interrupt))

#define __V_architecture 0
#if defined(__x86_64__)
	#define __V_amd64  1
	#undef __V_architecture
	#define __V_architecture 1
#endif

#if defined(__aarch64__) || defined(__arm64__)
	#define __V_arm64  1
	#undef __V_architecture
	#define __V_architecture 2
#endif

// Using just __GNUC__ for detecting gcc, is not reliable because other compilers define it too:
#ifdef __GNUC__
	#define __V_GCC__
#endif
#ifdef __TINYC__
	#undef __V_GCC__
#endif
#ifdef __cplusplus
	#undef __V_GCC__
#endif
#ifdef __clang__
	#undef __V_GCC__
#endif
#ifdef _MSC_VER
	#undef __V_GCC__
	#undef EMPTY_STRUCT_INITIALIZATION
	#define EMPTY_STRUCT_INITIALIZATION 0
#endif

#ifdef __TINYC__
	#undef EMPTY_STRUCT_DECLARATION
	#define EMPTY_STRUCT_DECLARATION char _dummy
	#undef EMPTY_ARRAY_OF_ELEMS
	#define EMPTY_ARRAY_OF_ELEMS(x,n) (x[n])
	#undef __NOINLINE
	#undef __IRQHANDLER
	// tcc does not support inlining at all
	#define __NOINLINE
	#define __IRQHANDLER
	#undef TCCSKIP
	#define TCCSKIP(x)
	// #include <byteswap.h>
	#ifndef _WIN32
		#include <execinfo.h>
		int tcc_backtrace(const char *fmt, ...);
	#endif
#endif

// Use __offsetof_ptr instead of __offset_of, when you *do* have a valid pointer, to avoid UB:
#ifndef __offsetof_ptr
	#define __offsetof_ptr(ptr,PTYPE,FIELDNAME) ((size_t)((byte *)&((PTYPE *)ptr)->FIELDNAME - (byte *)ptr))
#endif

// for __offset_of
#ifndef __offsetof
	#define __offsetof(PTYPE,FIELDNAME) ((size_t)((char *)&((PTYPE *)0)->FIELDNAME - (char *)0))
#endif

// returns the number of CPU registers that TYPE takes up
#define _REG_WIDTH(T) (((sizeof(T) + sizeof(void*) - 1) & ~(sizeof(void*) - 1)) / sizeof(void*))

#define OPTION_CAST(x) (x)

#ifndef V64_PRINTFORMAT
	#ifdef PRIx64
		#define V64_PRINTFORMAT "0x%"PRIx64
	#elif defined(__WIN32__)
		#define V64_PRINTFORMAT "0x%I64x"
	#elif defined(__linux__) && defined(__LP64__)
		#define V64_PRINTFORMAT "0x%lx"
	#else
		#define V64_PRINTFORMAT "0x%llx"
	#endif
#endif

#if defined(_WIN32) || defined(__CYGWIN__)
	#define VV_EXPORTED_SYMBOL extern __declspec(dllexport)
	#define VV_LOCAL_SYMBOL static
#else
	// 4 < gcc < 5 is used by some older Ubuntu LTS and Centos versions,
	// and does not support __has_attribute(visibility) ...
	#ifndef __has_attribute
		#define __has_attribute(x) 0  // Compatibility with non-clang compilers.
	#endif
	#if (defined(__GNUC__) && (__GNUC__ >= 4)) || (defined(__clang__) && __has_attribute(visibility))
		#ifdef ARM
			#define VV_EXPORTED_SYMBOL  extern __attribute__((externally_visible,visibility("default")))
		#else
			#define VV_EXPORTED_SYMBOL  extern __attribute__((visibility("default")))
		#endif
		#define VV_LOCAL_SYMBOL  __attribute__ ((visibility ("hidden")))
	#else
		#define VV_EXPORTED_SYMBOL extern
		#define VV_LOCAL_SYMBOL static
	#endif
#endif

#ifdef __cplusplus
	#include <utility>
	#define _MOV std::move
#else
	#define _MOV
#endif

// tcc does not support has_include properly yet, turn it off completely
#if defined(__TINYC__) && defined(__has_include)
#undef __has_include
#endif


#if !defined(VWEAK)
	#define VWEAK __attribute__((weak))
	#ifdef _MSC_VER
		#undef VWEAK
		#define VWEAK
	#endif
#endif

#if !defined(VNORETURN)
	#if defined(__TINYC__)
		#include <stdnoreturn.h>
		#define VNORETURN noreturn
	#endif
	# if !defined(__TINYC__) && defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L
	#  define VNORETURN _Noreturn
	# elif defined(__GNUC__) && __GNUC__ >= 2
	#  define VNORETURN __attribute__((noreturn))
	# endif
	#ifndef VNORETURN
		#define VNORETURN
	#endif
#endif

#if !defined(VUNREACHABLE)
	#if defined(__GNUC__) && !defined(__clang__)
		#define V_GCC_VERSION  (__GNUC__ * 10000L + __GNUC_MINOR__ * 100L + __GNUC_PATCHLEVEL__)
		#if (V_GCC_VERSION >= 40500L)
			#define VUNREACHABLE()  do { __builtin_unreachable(); } while (0)
		#endif
	#endif
	#if defined(__clang__) && defined(__has_builtin)
		#if __has_builtin(__builtin_unreachable)
			#define VUNREACHABLE()  do { __builtin_unreachable(); } while (0)
		#endif
	#endif
	#ifndef VUNREACHABLE
		#define VUNREACHABLE() do { } while (0)
	#endif
	#if defined(__FreeBSD__) && defined(__TINYC__)
		#define VUNREACHABLE() do { } while (0)
	#endif
#endif

//likely and unlikely macros
#if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)
	#define _likely_(x)  __builtin_expect(x,1)
	#define _unlikely_(x)  __builtin_expect(x,0)
#else
	#define _likely_(x) (x)
	#define _unlikely_(x) (x)
#endif


// c_headers
typedef int (*qsort_callback_func)(const void*, const void*);
#include <stdio.h>  // TODO remove all these includes, define all function signatures and types manually
#include <stdlib.h>
#include <string.h>

#if defined(_WIN32) || defined(__CYGWIN__)
	#define VV_EXPORTED_SYMBOL extern __declspec(dllexport)
	#define VV_LOCAL_SYMBOL static
#else
	// 4 < gcc < 5 is used by some older Ubuntu LTS and Centos versions,
	// and does not support __has_attribute(visibility) ...
	#ifndef __has_attribute
		#define __has_attribute(x) 0  // Compatibility with non-clang compilers.
	#endif
	#if (defined(__GNUC__) && (__GNUC__ >= 4)) || (defined(__clang__) && __has_attribute(visibility))
		#ifdef ARM
			#define VV_EXPORTED_SYMBOL  extern __attribute__((externally_visible,visibility("default")))
		#else
			#define VV_EXPORTED_SYMBOL  extern __attribute__((visibility("default")))
		#endif
		#define VV_LOCAL_SYMBOL  __attribute__ ((visibility ("hidden")))
	#else
		#define VV_EXPORTED_SYMBOL extern
		#define VV_LOCAL_SYMBOL static
	#endif
#endif

#if defined(__TINYC__) && defined(__has_include)
// tcc does not support has_include properly yet, turn it off completely
#undef __has_include
#endif

#ifndef _WIN32
	#if defined __has_include
		#if __has_include (<execinfo.h>)
			#include <execinfo.h>
		#else
			// Most probably musl OR __ANDROID__ ...
			int backtrace (void **__array, int __size) { return 0; }
			char **backtrace_symbols (void *const *__array, int __size){ return 0; }
			void backtrace_symbols_fd (void *const *__array, int __size, int __fd){}
		#endif
	#endif
#endif

#include <stdarg.h> // for va_list

//================================== GLOBALS =================================*/
int load_so(byteptr);
void _vinit(int ___argc, voidptr ___argv);
void _vcleanup(void);
#define sigaction_size sizeof(sigaction);
#define _ARR_LEN(a) ( (sizeof(a)) / (sizeof(a[0])) )

void v_free(voidptr ptr);
voidptr memdup(voidptr src, int sz);

#if INTPTR_MAX == INT32_MAX
	#define TARGET_IS_32BIT 1
#elif INTPTR_MAX == INT64_MAX
	#define TARGET_IS_64BIT 1
#else
	#error "The environment is not 32 or 64-bit."
#endif

#if defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__ || defined(__BYTE_ORDER) && __BYTE_ORDER == __BIG_ENDIAN || defined(__BIG_ENDIAN__) || defined(__ARMEB__) || defined(__THUMBEB__) || defined(__AARCH64EB__) || defined(_MIBSEB) || defined(__MIBSEB) || defined(__MIBSEB__)
	#define TARGET_ORDER_IS_BIG 1
#elif defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__ || defined(__BYTE_ORDER) && __BYTE_ORDER == __LITTLE_ENDIAN || defined(__LITTLE_ENDIAN__) || defined(__ARMEL__) || defined(__THUMBEL__) || defined(__AARCH64EL__) || defined(_MIPSEL) || defined(__MIPSEL) || defined(__MIPSEL__) || defined(_M_AMD64) || defined(_M_X64) || defined(_M_IX86)
	#define TARGET_ORDER_IS_LITTLE 1
#else
	#error "Unknown architecture endianness"
#endif

#ifndef _WIN32
	#include <ctype.h>
	#include <locale.h> // tolower
	#include <sys/time.h>
	#include <unistd.h> // sleep
	extern char **environ;
#endif

#if defined(__CYGWIN__) && !defined(_WIN32)
	#error Cygwin is not supported, please use MinGW or Visual Studio.
#endif

#if defined(__linux__) || defined(__FreeBSD__) || defined(__DragonFly__) || defined(__vinix__) || defined(__serenity__) || defined(__sun)
	#include <sys/types.h>
	#include <sys/wait.h> // os__wait uses wait on nix
#endif

#ifdef __OpenBSD__
	#include <sys/types.h>
	#include <sys/resource.h>
	#include <sys/wait.h> // os__wait uses wait on nix
#endif

#ifdef __NetBSD__
	#include <sys/wait.h> // os__wait uses wait on nix
#endif

#ifdef _WIN32
	#define WINVER 0x0600
	#ifdef _WIN32_WINNT
		#undef _WIN32_WINNT
	#endif
	#define _WIN32_WINNT 0x0600
	#ifndef WIN32_FULL
	#define WIN32_LEAN_AND_MEAN
	#endif
	#ifndef _UNICODE
	#define _UNICODE
	#endif
	#ifndef UNICODE
	#define UNICODE
	#endif
	#include <windows.h>

	#include <io.h> // _waccess
	#include <direct.h> // _wgetcwd
	#include <signal.h> // signal and SIGSEGV for segmentation fault handler

	#ifdef _MSC_VER
		// On MSVC these are the same (as long as /volatile:ms is passed)
		#define _Atomic volatile

		// MSVC cannot parse some things properly
		#undef EMPTY_STRUCT_DECLARATION
		#undef OPTION_CAST

		#define EMPTY_STRUCT_DECLARATION char __pad
		#define OPTION_CAST(x)
		#undef __NOINLINE
		#undef __IRQHANDLER
		#define __NOINLINE __declspec(noinline)
		#define __IRQHANDLER __declspec(naked)

		#include <dbghelp.h>
		#pragma comment(lib, "Dbghelp")
	#endif
#else
	#include <pthread.h>
	#ifndef PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP
		// musl does not have that
		#define pthread_rwlockattr_setkind_np(a, b)
	#endif
#endif

// g_live_info is used by live.info()
static void* g_live_info = NULL;

#if defined(__MINGW32__) || defined(__MINGW64__) || (defined(_WIN32) && defined(__TINYC__))
	#undef PRId64
	#undef PRIi64
	#undef PRIo64
	#undef PRIu64
	#undef PRIx64
	#undef PRIX64
	#define PRId64 "lld"
	#define PRIi64 "lli"
	#define PRIo64 "llo"
	#define PRIu64 "llu"
	#define PRIx64 "llx"
	#define PRIX64 "llX"
#endif

#ifdef _VFREESTANDING
#undef _VFREESTANDING
#endif


// ============== wyhash ==============
#ifndef wyhash_final_version_3
#define wyhash_final_version_3

#ifndef WYHASH_CONDOM
// protections that produce different results:
// 1: normal valid behavior
// 2: extra protection against entropy loss (probability=2^-63), aka. "blind multiplication"
#define WYHASH_CONDOM 1
#endif

#ifndef WYHASH_32BIT_MUM
// 0: normal version, slow on 32 bit systems
// 1: faster on 32 bit systems but produces different results, incompatible with wy2u0k function
#define WYHASH_32BIT_MUM 0
#endif

// includes
#include <stdint.h>
#if defined(_MSC_VER) && defined(_M_X64)
	#include <intrin.h>
	#pragma intrinsic(_umul128)
#endif

// 128bit multiply function
static inline uint64_t _wyrot(uint64_t x) { return (x>>32)|(x<<32); }
static inline void _wymum(uint64_t *A, uint64_t *B){
#if(WYHASH_32BIT_MUM)
	uint64_t hh=(*A>>32)*(*B>>32), hl=(*A>>32)*(uint32_t)*B, lh=(uint32_t)*A*(*B>>32), ll=(uint64_t)(uint32_t)*A*(uint32_t)*B;
	#if(WYHASH_CONDOM>1)
	*A^=_wyrot(hl)^hh; *B^=_wyrot(lh)^ll;
	#else
	*A=_wyrot(hl)^hh; *B=_wyrot(lh)^ll;
	#endif
#elif defined(__SIZEOF_INT128__)
	__uint128_t r=*A; r*=*B;
	#if(WYHASH_CONDOM>1)
	*A^=(uint64_t)r; *B^=(uint64_t)(r>>64);
	#else
	*A=(uint64_t)r; *B=(uint64_t)(r>>64);
	#endif
#elif defined(_MSC_VER) && defined(_M_X64)
	#if(WYHASH_CONDOM>1)
	uint64_t  a,  b;
	a=_umul128(*A,*B,&b);
	*A^=a;  *B^=b;
	#else
	*A=_umul128(*A,*B,B);
	#endif
#else
	uint64_t ha=*A>>32, hb=*B>>32, la=(uint32_t)*A, lb=(uint32_t)*B, hi, lo;
	uint64_t rh=ha*hb, rm0=ha*lb, rm1=hb*la, rl=la*lb, t=rl+(rm0<<32), c=t<rl;
	lo=t+(rm1<<32); c+=lo<t; hi=rh+(rm0>>32)+(rm1>>32)+c;
	#if(WYHASH_CONDOM>1)
	*A^=lo;  *B^=hi;
	#else
	*A=lo;  *B=hi;
	#endif
#endif
}

// multiply and xor mix function, aka MUM
static inline uint64_t _wymix(uint64_t A, uint64_t B){ _wymum(&A,&B); return A^B; }

// endian macros
#ifndef WYHASH_LITTLE_ENDIAN
	#ifdef TARGET_ORDER_IS_LITTLE
		#define WYHASH_LITTLE_ENDIAN 1
	#else
		#define WYHASH_LITTLE_ENDIAN 0
	#endif
#endif

// read functions
#if (WYHASH_LITTLE_ENDIAN)
	static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return v;}
	static inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&v, p, 4); return v;}
#elif defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)
	static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return __builtin_bswap64(v);}
	static inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&v, p, 4); return __builtin_bswap32(v);}
#elif defined(_MSC_VER)
	static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return _byteswap_uint64(v);}
	static inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&v, p, 4); return _byteswap_ulong(v);}
#else
	static inline uint64_t _wyr8(const uint8_t *p) {
		uint64_t v; memcpy(&v, p, 8);
		return (((v >> 56) & 0xff)| ((v >> 40) & 0xff00)| ((v >> 24) & 0xff0000)| ((v >>  8) & 0xff000000)| ((v <<  8) & 0xff00000000)| ((v << 24) & 0xff0000000000)| ((v << 40) & 0xff000000000000)| ((v << 56) & 0xff00000000000000));
	}
	static inline uint64_t _wyr4(const uint8_t *p) {
		uint32_t v; memcpy(&v, p, 4);
		return (((v >> 24) & 0xff)| ((v >>  8) & 0xff00)| ((v <<  8) & 0xff0000)| ((v << 24) & 0xff000000));
	}
#endif
static inline uint64_t _wyr3(const uint8_t *p, size_t k) { return (((uint64_t)p[0])<<16)|(((uint64_t)p[k>>1])<<8)|p[k-1];}
// wyhash main function
static inline uint64_t wyhash(const void *key, size_t len, uint64_t seed, const uint64_t *secret){
	const uint8_t *p=(const uint8_t *)key; seed^=*secret;	uint64_t a, b;
	if (_likely_(len<=16)) {
		if (_likely_(len>=4)) { a=(_wyr4(p)<<32)|_wyr4(p+((len>>3)<<2)); b=(_wyr4(p+len-4)<<32)|_wyr4(p+len-4-((len>>3)<<2)); }
		else if (_likely_(len>0)) { a=_wyr3(p,len); b=0; }
		else a=b=0;
	} else {
		size_t i=len;
		if (_unlikely_(i>48)) {
			uint64_t see1=seed, see2=seed;
			do {
				seed=_wymix(_wyr8(p)^secret[1],_wyr8(p+8)^seed);
				see1=_wymix(_wyr8(p+16)^secret[2],_wyr8(p+24)^see1);
				see2=_wymix(_wyr8(p+32)^secret[3],_wyr8(p+40)^see2);
				p+=48; i-=48;
			} while(_likely_(i>48));
			seed^=see1^see2;
		}
		while(_unlikely_(i>16)) { seed=_wymix(_wyr8(p)^secret[1],_wyr8(p+8)^seed);  i-=16; p+=16; }
		a=_wyr8(p+i-16);  b=_wyr8(p+i-8);
	}
	return _wymix(secret[1]^len,_wymix(a^secret[1],b^seed));
}
// the default secret parameters
static const uint64_t _wyp[4] = {0xa0761d6478bd642full, 0xe7037ed1a0b428dbull, 0x8ebc6af09c88c6e3ull, 0x589965cc75374cc3ull};

// a useful 64bit-64bit mix function to produce deterministic pseudo random numbers that can pass BigCrush and PractRand
static inline uint64_t wyhash64(uint64_t A, uint64_t B){ A^=0xa0761d6478bd642full; B^=0xe7037ed1a0b428dbull; _wymum(&A,&B); return _wymix(A^0xa0761d6478bd642full,B^0xe7037ed1a0b428dbull);}

// the wyrand PRNG that pass BigCrush and PractRand
static inline uint64_t wyrand(uint64_t *seed){ *seed+=0xa0761d6478bd642full; return _wymix(*seed,*seed^0xe7037ed1a0b428dbull);}

#ifndef __vinix__
// convert any 64 bit pseudo random numbers to uniform distribution [0,1). It can be combined with wyrand, wyhash64 or wyhash.
static inline double wy2u01(uint64_t r){ const double _wynorm=1.0/(1ull<<52); return (r>>12)*_wynorm;}

// convert any 64 bit pseudo random numbers to APPROXIMATE Gaussian distribution. It can be combined with wyrand, wyhash64 or wyhash.
static inline double wy2gau(uint64_t r){ const double _wynorm=1.0/(1ull<<20); return ((r&0x1fffff)+((r>>21)&0x1fffff)+((r>>42)&0x1fffff))*_wynorm-3.0;}
#endif

#if(!WYHASH_32BIT_MUM)
// fast range integer random number generation on [0,k) credit to Daniel Lemire. May not work when WYHASH_32BIT_MUM=1. It can be combined with wyrand, wyhash64 or wyhash.
static inline uint64_t wy2u0k(uint64_t r, uint64_t k){ _wymum(&r,&k); return k; }
#endif
#endif

#define _IN_MAP(val, m) map_exists(m, val)



// V includes:

#if defined(__TINYC__) && defined(__has_include)
// tcc does not support has_include properly yet, turn it off completely
#undef __has_include
#endif


// added by module `builtin`

#if defined(__has_include)

#if __has_include(<float.h>)
#include <float.h>
#else
#error VERROR_MESSAGE Header file <float.h>, needed for module `builtin` was not found. Please install the corresponding development headers.
#endif

#else
#include <float.h>
#endif





// added by module `time`

#if defined(__has_include)

#if __has_include(<time.h>)
#include <time.h>
#else
#error VERROR_MESSAGE Header file <time.h>, needed for module `time` was not found. Please install the corresponding development headers.
#endif

#else
#include <time.h>
#endif





// added by module `time`

#if defined(__has_include)

#if __has_include(<time.h>)
#include <time.h>
#else
#error VERROR_MESSAGE Header file <time.h>, needed for module `time` was not found. Please install the corresponding development headers.
#endif

#else
#include <time.h>
#endif





// added by module `sync.stdatomic`

#if defined(__has_include)

#if __has_include(<atomic.h>)
#include <atomic.h>
#else
#error VERROR_MESSAGE Header file <atomic.h>, needed for module `sync.stdatomic` was not found. Please install the corresponding development headers.
#endif

#else
#include <atomic.h>
#endif





// added by module `os`

#if defined(__has_include)

#if __has_include(<sys/stat.h>)
#include <sys/stat.h>
#else
#error VERROR_MESSAGE Header file <sys/stat.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <sys/stat.h>
#endif





// added by module `os`
#include <errno.h>




// added by module `os`

#if defined(__has_include)

#if __has_include(<process.h>)
#include <process.h>
#else
#error VERROR_MESSAGE Header file <process.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <process.h>
#endif





// added by module `os`

#if defined(__has_include)

#if __has_include(<sys/utime.h>)
#include <sys/utime.h>
#else
#error VERROR_MESSAGE Header file <sys/utime.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <sys/utime.h>
#endif





// added by module `os`

#if defined(__has_include)

#if __has_include(<signal.h>)
#include <signal.h>
#else
#error VERROR_MESSAGE Header file <signal.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <signal.h>
#endif





// added by module `sync`

#if defined(__has_include)

#if __has_include(<synchapi.h>)
#include <synchapi.h>
#else
#error VERROR_MESSAGE Header file <synchapi.h>, needed for module `sync` was not found. Please install the corresponding development headers.
#endif

#else
#include <synchapi.h>
#endif





// added by module `sync`

#if defined(__has_include)

#if __has_include(<time.h>)
#include <time.h>
#else
#error VERROR_MESSAGE Header file <time.h>, needed for module `sync` was not found. Please install the corresponding development headers.
#endif

#else
#include <time.h>
#endif




// Enum definitions:
typedef enum {
	strconv__Align_text__right = 0, // 0
	strconv__Align_text__left, // 0+1
	strconv__Align_text__center, // 0+2
} strconv__Align_text;

typedef enum {
	strconv__Char_parse_state__start, // 
	strconv__Char_parse_state__norm_char, // +1
	strconv__Char_parse_state__field_char, // +2
	strconv__Char_parse_state__pad_ch, // +3
	strconv__Char_parse_state__len_set_start, // +4
	strconv__Char_parse_state__len_set_in, // +5
	strconv__Char_parse_state__check_type, // +6
	strconv__Char_parse_state__check_float, // +7
	strconv__Char_parse_state__check_float_in, // +8
	strconv__Char_parse_state__reset_params, // +9
} strconv__Char_parse_state;

typedef enum {
	ArrayFlags__noslices = 1, // 1 << 0
} ArrayFlags;

typedef enum {
	AttributeKind__plain, // 
	AttributeKind__string, // +1
	AttributeKind__number, // +2
	AttributeKind__comptime_define, // +3
} AttributeKind;

typedef enum {
	ChanState__success, // 
	ChanState__not_ready, // +1
	ChanState__closed, // +2
} ChanState;

typedef enum {
	StrIntpType__si_no_str = 0, // 0
	StrIntpType__si_c, // 0+1
	StrIntpType__si_u8, // 0+2
	StrIntpType__si_i8, // 0+3
	StrIntpType__si_u16, // 0+4
	StrIntpType__si_i16, // 0+5
	StrIntpType__si_u32, // 0+6
	StrIntpType__si_i32, // 0+7
	StrIntpType__si_u64, // 0+8
	StrIntpType__si_i64, // 0+9
	StrIntpType__si_e32, // 0+10
	StrIntpType__si_e64, // 0+11
	StrIntpType__si_f32, // 0+12
	StrIntpType__si_f64, // 0+13
	StrIntpType__si_g32, // 0+14
	StrIntpType__si_g64, // 0+15
	StrIntpType__si_s, // 0+16
	StrIntpType__si_p, // 0+17
	StrIntpType__si_vp, // 0+18
} StrIntpType;

typedef enum {
	v__token__Kind__unknown, // 
	v__token__Kind__eof, // +1
	v__token__Kind__name, // +2
	v__token__Kind__number, // +3
	v__token__Kind__string, // +4
	v__token__Kind__str_inter, // +5
	v__token__Kind__chartoken, // +6
	v__token__Kind__plus, // +7
	v__token__Kind__minus, // +8
	v__token__Kind__mul, // +9
	v__token__Kind__div, // +10
	v__token__Kind__mod, // +11
	v__token__Kind__xor, // +12
	v__token__Kind__pipe, // +13
	v__token__Kind__inc, // +14
	v__token__Kind__dec, // +15
	v__token__Kind__and, // +16
	v__token__Kind__logical_or, // +17
	v__token__Kind__not, // +18
	v__token__Kind__bit_not, // +19
	v__token__Kind__question, // +20
	v__token__Kind__comma, // +21
	v__token__Kind__semicolon, // +22
	v__token__Kind__colon, // +23
	v__token__Kind__arrow, // +24
	v__token__Kind__amp, // +25
	v__token__Kind__hash, // +26
	v__token__Kind__dollar, // +27
	v__token__Kind__at, // +28
	v__token__Kind__str_dollar, // +29
	v__token__Kind__left_shift, // +30
	v__token__Kind__right_shift, // +31
	v__token__Kind__unsigned_right_shift, // +32
	v__token__Kind__not_in, // +33
	v__token__Kind__not_is, // +34
	v__token__Kind__assign, // +35
	v__token__Kind__decl_assign, // +36
	v__token__Kind__plus_assign, // +37
	v__token__Kind__minus_assign, // +38
	v__token__Kind__div_assign, // +39
	v__token__Kind__mult_assign, // +40
	v__token__Kind__xor_assign, // +41
	v__token__Kind__mod_assign, // +42
	v__token__Kind__or_assign, // +43
	v__token__Kind__and_assign, // +44
	v__token__Kind__right_shift_assign, // +45
	v__token__Kind__left_shift_assign, // +46
	v__token__Kind__unsigned_right_shift_assign, // +47
	v__token__Kind__lcbr, // +48
	v__token__Kind__rcbr, // +49
	v__token__Kind__lpar, // +50
	v__token__Kind__rpar, // +51
	v__token__Kind__lsbr, // +52
	v__token__Kind__nilsbr, // +53
	v__token__Kind__rsbr, // +54
	v__token__Kind__eq, // +55
	v__token__Kind__ne, // +56
	v__token__Kind__gt, // +57
	v__token__Kind__lt, // +58
	v__token__Kind__ge, // +59
	v__token__Kind__le, // +60
	v__token__Kind__comment, // +61
	v__token__Kind__nl, // +62
	v__token__Kind__dot, // +63
	v__token__Kind__dotdot, // +64
	v__token__Kind__ellipsis, // +65
	v__token__Kind__keyword_beg, // +66
	v__token__Kind__key_as, // +67
	v__token__Kind__key_asm, // +68
	v__token__Kind__key_assert, // +69
	v__token__Kind__key_atomic, // +70
	v__token__Kind__key_break, // +71
	v__token__Kind__key_const, // +72
	v__token__Kind__key_continue, // +73
	v__token__Kind__key_defer, // +74
	v__token__Kind__key_else, // +75
	v__token__Kind__key_enum, // +76
	v__token__Kind__key_false, // +77
	v__token__Kind__key_for, // +78
	v__token__Kind__key_fn, // +79
	v__token__Kind__key_global, // +80
	v__token__Kind__key_go, // +81
	v__token__Kind__key_goto, // +82
	v__token__Kind__key_if, // +83
	v__token__Kind__key_import, // +84
	v__token__Kind__key_in, // +85
	v__token__Kind__key_interface, // +86
	v__token__Kind__key_is, // +87
	v__token__Kind__key_match, // +88
	v__token__Kind__key_module, // +89
	v__token__Kind__key_mut, // +90
	v__token__Kind__key_shared, // +91
	v__token__Kind__key_lock, // +92
	v__token__Kind__key_rlock, // +93
	v__token__Kind__key_none, // +94
	v__token__Kind__key_return, // +95
	v__token__Kind__key_select, // +96
	v__token__Kind__key_sizeof, // +97
	v__token__Kind__key_isreftype, // +98
	v__token__Kind__key_likely, // +99
	v__token__Kind__key_unlikely, // +100
	v__token__Kind__key_offsetof, // +101
	v__token__Kind__key_struct, // +102
	v__token__Kind__key_true, // +103
	v__token__Kind__key_type, // +104
	v__token__Kind__key_typeof, // +105
	v__token__Kind__key_dump, // +106
	v__token__Kind__key_orelse, // +107
	v__token__Kind__key_union, // +108
	v__token__Kind__key_pub, // +109
	v__token__Kind__key_static, // +110
	v__token__Kind__key_volatile, // +111
	v__token__Kind__key_unsafe, // +112
	v__token__Kind__keyword_end, // +113
	v__token__Kind___end_, // +114
} v__token__Kind;

typedef enum {
	v__token__AtKind__unknown, // 
	v__token__AtKind__fn_name, // +1
	v__token__AtKind__method_name, // +2
	v__token__AtKind__mod_name, // +3
	v__token__AtKind__struct_name, // +4
	v__token__AtKind__vexe_path, // +5
	v__token__AtKind__file_path, // +6
	v__token__AtKind__line_nr, // +7
	v__token__AtKind__column_nr, // +8
	v__token__AtKind__vhash, // +9
	v__token__AtKind__vmod_file, // +10
	v__token__AtKind__vmodroot_path, // +11
	v__token__AtKind__vroot_path, // +12
	v__token__AtKind__vexeroot_path, // +13
} v__token__AtKind;

typedef enum {
	v__token__Precedence__lowest, // 
	v__token__Precedence__cond, // +1
	v__token__Precedence__in_as, // +2
	v__token__Precedence__assign, // +3
	v__token__Precedence__eq, // +4
	v__token__Precedence__sum, // +5
	v__token__Precedence__product, // +6
	v__token__Precedence__prefix, // +7
	v__token__Precedence__postfix, // +8
	v__token__Precedence__call, // +9
	v__token__Precedence__index, // +10
} v__token__Precedence;

typedef enum {
	time__FormatTime__hhmm12, // 
	time__FormatTime__hhmm24, // +1
	time__FormatTime__hhmmss12, // +2
	time__FormatTime__hhmmss24, // +3
	time__FormatTime__hhmmss24_milli, // +4
	time__FormatTime__hhmmss24_micro, // +5
	time__FormatTime__no_time, // +6
} time__FormatTime;

typedef enum {
	time__FormatDate__ddmmyy, // 
	time__FormatDate__ddmmyyyy, // +1
	time__FormatDate__mmddyy, // +2
	time__FormatDate__mmddyyyy, // +3
	time__FormatDate__mmmd, // +4
	time__FormatDate__mmmdd, // +5
	time__FormatDate__mmmddyy, // +6
	time__FormatDate__mmmddyyyy, // +7
	time__FormatDate__no_date, // +8
	time__FormatDate__yyyymmdd, // +9
	time__FormatDate__yymmdd, // +10
} time__FormatDate;

typedef enum {
	time__FormatDelimiter__dot, // 
	time__FormatDelimiter__hyphen, // +1
	time__FormatDelimiter__slash, // +2
	time__FormatDelimiter__space, // +3
	time__FormatDelimiter__no_delimiter, // +4
} time__FormatDelimiter;

typedef enum {
	semver__Operator__gt, // 
	semver__Operator__lt, // +1
	semver__Operator__ge, // +2
	semver__Operator__le, // +3
	semver__Operator__eq, // +4
} semver__Operator;

typedef enum {
	semver__Increment__major, // 
	semver__Increment__minor, // +1
	semver__Increment__patch, // +2
} semver__Increment;

typedef enum {
	os__SeekMode__start, // 
	os__SeekMode__current, // +1
	os__SeekMode__end, // +2
} os__SeekMode;

typedef enum {
	os__FileType__regular, // 
	os__FileType__directory, // +1
	os__FileType__character_device, // +2
	os__FileType__block_device, // +3
	os__FileType__fifo, // +4
	os__FileType__symbolic_link, // +5
	os__FileType__socket, // +6
} os__FileType;

typedef enum {
	os__ProcessState__not_started, // 
	os__ProcessState__running, // +1
	os__ProcessState__stopped, // +2
	os__ProcessState__exited, // +3
	os__ProcessState__aborted, // +4
	os__ProcessState__closed, // +5
} os__ProcessState;

typedef enum {
	os__Signal__hup = 1, // 1
	os__Signal__int = 2, // 2
	os__Signal__quit = 3, // 3
	os__Signal__ill = 4, // 4
	os__Signal__trap = 5, // 5
	os__Signal__abrt = 6, // 6
	os__Signal__bus = 7, // 7
	os__Signal__fpe = 8, // 8
	os__Signal__kill = 9, // 9
	os__Signal__usr1 = 10, // 10
	os__Signal__segv = 11, // 11
	os__Signal__usr2 = 12, // 12
	os__Signal__pipe = 13, // 13
	os__Signal__alrm = 14, // 14
	os__Signal__term = 15, // 15
	os__Signal__stkflt = 16, // 16
	os__Signal__chld = 17, // 17
	os__Signal__cont = 18, // 18
	os__Signal__stop = 19, // 19
	os__Signal__tstp = 20, // 20
	os__Signal__ttin = 21, // 21
	os__Signal__ttou = 22, // 22
	os__Signal__urg = 23, // 23
	os__Signal__xcpu = 24, // 24
	os__Signal__xfsz = 25, // 25
	os__Signal__vtalrm = 26, // 26
	os__Signal__prof = 27, // 27
	os__Signal__winch = 28, // 28
	os__Signal__poll = 29, // 29
	os__Signal__pwr = 30, // 30
	os__Signal__sys = 31, // 31
} os__Signal;

typedef enum {
	v__errors__Reporter__scanner, // 
	v__errors__Reporter__parser, // +1
	v__errors__Reporter__checker, // +2
	v__errors__Reporter__builder, // +3
	v__errors__Reporter__gen, // +4
} v__errors__Reporter;

typedef enum {
	v__vet__ErrorKind__error, // 
	v__vet__ErrorKind__warning, // +1
} v__vet__ErrorKind;

typedef enum {
	v__vet__FixKind__unknown, // 
	v__vet__FixKind__doc, // +1
	v__vet__FixKind__vfmt, // +2
} v__vet__FixKind;

typedef enum {
	v__vet__ErrorType__default, // 
	v__vet__ErrorType__space_indent, // +1
	v__vet__ErrorType__trailing_space, // +2
} v__vet__ErrorType;

typedef enum {
	v__vmod__TokenKind__module_keyword, // 
	v__vmod__TokenKind__field_key, // +1
	v__vmod__TokenKind__lcbr, // +2
	v__vmod__TokenKind__rcbr, // +3
	v__vmod__TokenKind__labr, // +4
	v__vmod__TokenKind__rabr, // +5
	v__vmod__TokenKind__comma, // +6
	v__vmod__TokenKind__colon, // +7
	v__vmod__TokenKind__eof, // +8
	v__vmod__TokenKind__str, // +9
	v__vmod__TokenKind__ident, // +10
	v__vmod__TokenKind__unknown, // +11
} v__vmod__TokenKind;

typedef enum {
	v__pref__OS___auto, // 
	v__pref__OS__ios, // +1
	v__pref__OS__macos, // +2
	v__pref__OS__linux, // +3
	v__pref__OS__windows, // +4
	v__pref__OS__freebsd, // +5
	v__pref__OS__openbsd, // +6
	v__pref__OS__netbsd, // +7
	v__pref__OS__dragonfly, // +8
	v__pref__OS__js_node, // +9
	v__pref__OS__js_browser, // +10
	v__pref__OS__js_freestanding, // +11
	v__pref__OS__android, // +12
	v__pref__OS__solaris, // +13
	v__pref__OS__serenity, // +14
	v__pref__OS__vinix, // +15
	v__pref__OS__haiku, // +16
	v__pref__OS__raw, // +17
	v__pref__OS__all, // +18
} v__pref__OS;

typedef enum {
	v__pref__BuildMode__default_mode, // 
	v__pref__BuildMode__build_module, // +1
} v__pref__BuildMode;

typedef enum {
	v__pref__AssertFailureMode__default, // 
	v__pref__AssertFailureMode__aborts, // +1
	v__pref__AssertFailureMode__backtraces, // +2
} v__pref__AssertFailureMode;

typedef enum {
	v__pref__GarbageCollectionMode__no_gc, // 
	v__pref__GarbageCollectionMode__boehm_full, // +1
	v__pref__GarbageCollectionMode__boehm_incr, // +2
	v__pref__GarbageCollectionMode__boehm_full_opt, // +3
	v__pref__GarbageCollectionMode__boehm_incr_opt, // +4
	v__pref__GarbageCollectionMode__boehm_leak, // +5
} v__pref__GarbageCollectionMode;

typedef enum {
	v__pref__OutputMode__stdout, // 
	v__pref__OutputMode__silent, // +1
} v__pref__OutputMode;

typedef enum {
	v__pref__ColorOutput__auto, // 
	v__pref__ColorOutput__always, // +1
	v__pref__ColorOutput__never, // +2
} v__pref__ColorOutput;

typedef enum {
	v__pref__Backend__c, // 
	v__pref__Backend__js_node, // +1
	v__pref__Backend__js_browser, // +2
	v__pref__Backend__js_freestanding, // +3
	v__pref__Backend__native, // +4
	v__pref__Backend__interpret, // +5
} v__pref__Backend;

typedef enum {
	v__pref__CompilerType__gcc, // 
	v__pref__CompilerType__tinyc, // +1
	v__pref__CompilerType__clang, // +2
	v__pref__CompilerType__mingw, // +3
	v__pref__CompilerType__msvc, // +4
	v__pref__CompilerType__cplusplus, // +5
} v__pref__CompilerType;

typedef enum {
	v__pref__Arch___auto, // 
	v__pref__Arch__amd64, // +1
	v__pref__Arch__arm64, // +2
	v__pref__Arch__arm32, // +3
	v__pref__Arch__rv64, // +4
	v__pref__Arch__rv32, // +5
	v__pref__Arch__i386, // +6
	v__pref__Arch__js_node, // +7
	v__pref__Arch__js_browser, // +8
	v__pref__Arch__js_freestanding, // +9
	v__pref__Arch___max, // +10
} v__pref__Arch;

typedef enum {
	sync__BufferElemStat__unused = 0, // 0
	sync__BufferElemStat__writing, // 0+1
	sync__BufferElemStat__written, // 0+2
	sync__BufferElemStat__reading, // 0+3
} sync__BufferElemStat;

typedef enum {
	sync__Direction__pop, // 
	sync__Direction__push, // +1
} sync__Direction;

typedef enum {
	v__ast__GenericKindField__unknown, // 
	v__ast__GenericKindField__name, // +1
	v__ast__GenericKindField__typ, // +2
} v__ast__GenericKindField;

typedef enum {
	v__ast__IdentKind__unresolved, // 
	v__ast__IdentKind__blank_ident, // +1
	v__ast__IdentKind__variable, // +2
	v__ast__IdentKind__constant, // +3
	v__ast__IdentKind__global, // +4
	v__ast__IdentKind__function, // +5
} v__ast__IdentKind;

typedef enum {
	v__ast__ComptimeForKind__methods, // 
	v__ast__ComptimeForKind__fields, // +1
	v__ast__ComptimeForKind__attributes, // +2
} v__ast__ComptimeForKind;

typedef enum {
	v__ast__AddressingMode__invalid, // 
	v__ast__AddressingMode__displacement, // +1
	v__ast__AddressingMode__base, // +2
	v__ast__AddressingMode__base_plus_displacement, // +3
	v__ast__AddressingMode__index_times_scale_plus_displacement, // +4
	v__ast__AddressingMode__base_plus_index_plus_displacement, // +5
	v__ast__AddressingMode__base_plus_index_times_scale_plus_displacement, // +6
	v__ast__AddressingMode__rip_plus_displacement, // +7
} v__ast__AddressingMode;

typedef enum {
	v__ast__OrKind__absent, // 
	v__ast__OrKind__block, // +1
	v__ast__OrKind__propagate, // +2
} v__ast__OrKind;

typedef enum {
	v__ast__SqlStmtKind__insert, // 
	v__ast__SqlStmtKind__update, // +1
	v__ast__SqlStmtKind__delete, // +2
	v__ast__SqlStmtKind__create, // +3
	v__ast__SqlStmtKind__drop, // +4
} v__ast__SqlStmtKind;

typedef enum {
	v__ast__AttrKind__plain, // 
	v__ast__AttrKind__string, // +1
	v__ast__AttrKind__number, // +2
	v__ast__AttrKind__bool, // +3
	v__ast__AttrKind__comptime_define, // +4
} v__ast__AttrKind;

typedef enum {
	v__ast__Language__v, // 
	v__ast__Language__c, // +1
	v__ast__Language__js, // +2
	v__ast__Language__amd64, // +3
	v__ast__Language__i386, // +4
	v__ast__Language__arm64, // +5
	v__ast__Language__arm32, // +6
	v__ast__Language__rv64, // +7
	v__ast__Language__rv32, // +8
} v__ast__Language;

typedef enum {
	v__ast__TypeFlag__optional, // 
	v__ast__TypeFlag__variadic, // +1
	v__ast__TypeFlag__generic, // +2
	v__ast__TypeFlag__shared_f, // +3
	v__ast__TypeFlag__atomic_f, // +4
} v__ast__TypeFlag;

typedef enum {
	v__ast__ShareType__mut_t, // 
	v__ast__ShareType__shared_t, // +1
	v__ast__ShareType__atomic_t, // +2
} v__ast__ShareType;

typedef enum {
	v__ast__Kind__placeholder, // 
	v__ast__Kind__void, // +1
	v__ast__Kind__voidptr, // +2
	v__ast__Kind__byteptr, // +3
	v__ast__Kind__charptr, // +4
	v__ast__Kind__i8, // +5
	v__ast__Kind__i16, // +6
	v__ast__Kind__int, // +7
	v__ast__Kind__i64, // +8
	v__ast__Kind__isize, // +9
	v__ast__Kind__byte, // +10
	v__ast__Kind__u8, // +11
	v__ast__Kind__u16, // +12
	v__ast__Kind__u32, // +13
	v__ast__Kind__u64, // +14
	v__ast__Kind__usize, // +15
	v__ast__Kind__f32, // +16
	v__ast__Kind__f64, // +17
	v__ast__Kind__char, // +18
	v__ast__Kind__rune, // +19
	v__ast__Kind__bool, // +20
	v__ast__Kind__none_, // +21
	v__ast__Kind__string, // +22
	v__ast__Kind__array, // +23
	v__ast__Kind__array_fixed, // +24
	v__ast__Kind__map, // +25
	v__ast__Kind__chan, // +26
	v__ast__Kind__any, // +27
	v__ast__Kind__struct_, // +28
	v__ast__Kind__generic_inst, // +29
	v__ast__Kind__multi_return, // +30
	v__ast__Kind__sum_type, // +31
	v__ast__Kind__alias, // +32
	v__ast__Kind__enum_, // +33
	v__ast__Kind__function, // +34
	v__ast__Kind__interface_, // +35
	v__ast__Kind__float_literal, // +36
	v__ast__Kind__int_literal, // +37
	v__ast__Kind__aggregate, // +38
	v__ast__Kind__thread, // +39
} v__ast__Kind;

typedef enum {
	v__gen__c__StrIntpType__si_no_str = 0, // 0
	v__gen__c__StrIntpType__si_c, // 0+1
	v__gen__c__StrIntpType__si_u8, // 0+2
	v__gen__c__StrIntpType__si_i8, // 0+3
	v__gen__c__StrIntpType__si_u16, // 0+4
	v__gen__c__StrIntpType__si_i16, // 0+5
	v__gen__c__StrIntpType__si_u32, // 0+6
	v__gen__c__StrIntpType__si_i32, // 0+7
	v__gen__c__StrIntpType__si_u64, // 0+8
	v__gen__c__StrIntpType__si_i64, // 0+9
	v__gen__c__StrIntpType__si_e32, // 0+10
	v__gen__c__StrIntpType__si_e64, // 0+11
	v__gen__c__StrIntpType__si_f32, // 0+12
	v__gen__c__StrIntpType__si_f64, // 0+13
	v__gen__c__StrIntpType__si_g32, // 0+14
	v__gen__c__StrIntpType__si_g64, // 0+15
	v__gen__c__StrIntpType__si_s, // 0+16
	v__gen__c__StrIntpType__si_p, // 0+17
	v__gen__c__StrIntpType__si_vp, // 0+18
} v__gen__c__StrIntpType;

typedef enum {
	v__gen__c__SqlExprSide__left, // 
	v__gen__c__SqlExprSide__right, // +1
} v__gen__c__SqlExprSide;

typedef enum {
	v__gen__c__SqlType__sqlite3, // 
	v__gen__c__SqlType__mysql, // +1
	v__gen__c__SqlType__psql, // +2
	v__gen__c__SqlType__mssql, // +3
	v__gen__c__SqlType__unknown, // +4
} v__gen__c__SqlType;

typedef enum {
	v__scanner__CommentsMode__skip_comments, // 
	v__scanner__CommentsMode__parse_comments, // +1
	v__scanner__CommentsMode__toplevel_comments, // +2
} v__scanner__CommentsMode;

typedef enum {
	v__parser__State__html, // 
	v__parser__State__css, // +1
	v__parser__State__js, // +2
} v__parser__State;


// V type definitions:
struct IError {
	union {
		void* _object;
		None__* _None__;
		Error* _Error;
		time__TimeParseError* _time__TimeParseError;
		flag__UnkownFlagError* _flag__UnkownFlagError;
		flag__MinimumArgsCountError* _flag__MinimumArgsCountError;
		flag__MaximumArgsCountError* _flag__MaximumArgsCountError;
		flag__NoArgsExpectedError* _flag__NoArgsExpectedError;
		semver__InvalidComparatorFormatError* _semver__InvalidComparatorFormatError;
		semver__EmptyInputError* _semver__EmptyInputError;
		semver__InvalidVersionFormatError* _semver__InvalidVersionFormatError;
		os__ErrFileNotOpened* _os__ErrFileNotOpened;
		os__ErrSizeOfTypeIs0* _os__ErrSizeOfTypeIs0;
		os__ErrExecutableNotFound* _os__ErrExecutableNotFound;
		v__gen__c__UnsupportedAssertCtempTransform* _v__gen__c__UnsupportedAssertCtempTransform;
		semver__InvalidComparatorCountError* _semver__InvalidComparatorCountError;
		voidptr* _voidptr;
	};
	int _typ;
	string* msg;
	int* code;
};

struct string {
	byte* str;
	int len;
	int is_lit;
};



struct array {
	int element_size;
	voidptr data;
	int offset;
	int len;
	int cap;
	ArrayFlags flags;
};



struct DenseArray {
	int key_bytes;
	int value_bytes;
	int cap;
	int len;
	u32 deletes;
	byte* all_deleted;
	byte* values;
	byte* keys;
};



struct map {
	int key_bytes;
	int value_bytes;
	u32 even_index;
	byte cached_hashbits;
	byte shift;
	DenseArray key_values;
	u32* metas;
	u32 extra_metas;
	bool has_string_keys;
	MapHashFn hash_fn;
	MapEqFn key_eq_fn;
	MapCloneFn clone_fn;
	MapFreeFn free_fn;
	int len;
};



struct Error {
	string msg;
	int code;
};



struct Option {
	byte state;
	IError err;
};


typedef array Array_string;
typedef array Array_byte;
typedef array Array_int;
typedef array Array_voidptr;
typedef array Array_VCastTypeIndexName;
typedef array Array_MethodArgs;
typedef u64 Array_fixed_u64_2 [2];
typedef char Array_fixed_char_254 [254];
typedef array Array_byte_ptr;
typedef array Array_rune;
typedef string Array_fixed_string_11 [11];
typedef voidptr Array_fixed_voidptr_11 [11];
typedef array Array_RepIndex;
typedef map Map_string_int;
typedef map Map_string_string;
typedef array Array_char_ptr;
typedef u16 Array_fixed_u16_260 [260];
typedef u16 Array_fixed_u16_14 [14];
typedef int Array_fixed_int_3 [3];
typedef byte Array_fixed_byte_65536 [65536];
typedef char Array_fixed_char_256 [256];
typedef int Array_fixed_int_10 [10];
typedef map Map_string_Array_string;
typedef array Array_v__util__Possibility;
typedef map Map_string_time__StopWatch;
typedef array Array_v__ast__File_ptr;
typedef array Array_v__builder__FunctionRedefinition;
typedef array Array_v__cflag__CFlag;
typedef map Map_string_bool;
typedef array Array_u32;
typedef array Array_v__token__WIndex;
typedef map Map_string_T;
typedef map Map_string_v__token__Kind;
typedef array Array_v__token__Precedence;
typedef array Array_v__vmod__Token;
typedef map Map_string_v__vmod__ModFileAndFolder;
typedef array Array_v__ast__Stmt;
typedef array Array_v__ast__Comment;
typedef array Array_v__ast__Expr;
typedef array Array_bool;
typedef array Array_v__token__Position;
typedef array Array_v__ast__Type;
typedef array Array_v__ast__Attr;
typedef array Array_v__ast__ConstField;
typedef array Array_v__ast__Embed;
typedef array Array_v__ast__StructField;
typedef array Array_v__ast__FnDecl;
typedef array Array_v__ast__InterfaceEmbedding;
typedef array Array_v__ast__StructInitField;
typedef array Array_v__ast__StructInitEmbed;
typedef array Array_v__ast__ImportSymbol;
typedef array Array_v__ast__Param;
typedef array Array_v__ast__DeferStmt;
typedef array Array_v__ast__CallArg;
typedef array Array_v__ast__GlobalField;
typedef array Array_v__ast__Import;
typedef array Array_v__ast__EmbeddedFile;
typedef array Array_v__errors__Error;
typedef array Array_v__errors__Warning;
typedef array Array_v__errors__Notice;
typedef array Array_v__ast__FnDecl_ptr;
typedef array Array_v__ast__IfBranch;
typedef array Array_v__ast__MatchBranch;
typedef array Array_Array_v__ast__Comment;
typedef array Array_v__ast__SelectBranch;
typedef array Array_v__ast__EnumField;
typedef array Array_v__ast__TypeNode;
typedef array Array_v__ast__Ident;
typedef array Array_v__ast__AsmClobbered;
typedef array Array_v__ast__AsmTemplate;
typedef array Array_v__ast__AsmIO;
typedef array Array_v__ast__AsmArg;
typedef array Array_v__ast__SqlStmtLine;
typedef map Map_int_v__ast__SqlStmtLine;
typedef map Map_int_v__ast__SqlExpr;
typedef array Array_v__ast__Node;
typedef map Map_string_v__ast__ScopeObject;
typedef map Map_string_v__ast__ScopeStructField;
typedef array Array_v__ast__Scope_ptr;
typedef array Array_v__ast__TypeSymbol_ptr;
typedef map Map_string_v__ast__Fn;
typedef map Map_string_Array_v__ast__Type;
typedef map Map_int_string;
typedef array Array_Array_v__ast__Type;
typedef map Map_string_Array_Array_v__ast__Type;
typedef map Map_int_v__ast__InterfaceDecl;
typedef map Map_string_v__ast__EnumDecl;
typedef array Array_v__ast__Fn;
typedef map Map_string_v__ast__StructField;
typedef array Array_v__ast__Kind;
typedef map Map_int_Array_v__ast__Type;
typedef array Array_v__ast__File;
typedef map Map_string_v__ast__Type;
typedef map Map_int_v__ast__InterfaceEmbedding;
typedef array Array_i64;
typedef array Array_v__transformer__KeyVal;
typedef array Array_Array_v__transformer__KeyVal;
typedef array Array_v__vet__Error;
typedef map Map_string_v__ast__FnDecl;
typedef map Map_string_v__ast__ConstField;
typedef map Map_string_v__ast__GlobalField;
typedef array Array_v__depgraph__DepGraphNode;
typedef map Map_string_strings__Builder;
typedef map Map_string_v__ast__Stmt_ptr;
typedef array Array_v__gen__c__StrType;
typedef array Array_v__gen__c__SumtypeCastingFn;
typedef map Map_int_bool;
typedef array Array_v__gen__c__ProfileCounterMeta;
typedef array Array_v__ast__InfixExpr;
typedef array Array_v__ast__TypeSymbol;
typedef array Array_v__token__Token;
typedef array Array_sync__Channel_ptr;
typedef array Array_sync__Direction;
typedef array Array_sync__Subscription;
typedef array Array_flag__Flag;
typedef array Array_f64;
typedef array Array_semver__Comparator;
typedef array Array_semver__ComparatorSet;
typedef byte Array_fixed_byte_5 [5];
typedef array Array_u64;
typedef array Array_strconv__Uint128;
typedef byte Array_fixed_byte_32 [32];
typedef byte Array_fixed_byte_26 [26];
typedef u8 Array_fixed_u8_32 [32];
typedef byte Array_fixed_byte_17 [17];
typedef array Array_StrIntpType;
typedef array Array_v__token__Kind;
typedef u16 Array_fixed_u16_32768 [32768];
typedef byte Array_fixed_byte_4096 [4096];
typedef u16 Array_fixed_u16_255 [255];
typedef array Array_os__ProcessState;
typedef byte Array_fixed_byte_50 [50];
typedef array Array_v__vmod__TokenKind;
typedef array Array_v__pref__Backend;
typedef map Map_int_Array_string;
typedef map Map_int_Map_string_int;
typedef array Array_v__ast__CallExpr;
typedef array Array_v__ast__ConstDecl;
typedef array Array_v__ast__IdentKind;
typedef array Array_v__ast__IfExpr;
typedef array Array_v__ast__SelectorExpr;
typedef array Array_v__pref__GarbageCollectionMode;
typedef array Array_v__gen__c__Gen_ptr;
typedef array Array_v__ast__Struct;
typedef array Array_v__pref__Arch;
typedef array Array_v__pref__OS;
typedef int i32;
typedef Array_byte strings__Builder;
typedef voidptr os__HANDLE;
typedef voidptr os__HMODULE;
typedef u32* os__PU32;
typedef voidptr v__builder__RegKey;
typedef i64 time__Duration;
typedef int v__ast__Type;
typedef voidptr sync__MHANDLE;
typedef voidptr sync__SHANDLE;
typedef int (*anon_fn_voidptr_voidptr__int)(voidptr,voidptr);
typedef bool (*anon_fn_voidptr__bool)(voidptr);
typedef voidptr (*anon_fn_voidptr__voidptr)(voidptr);
typedef int (*anon_fn_int_int__int)(int,int);
typedef void (*FnExitCb)();
typedef int (*VectoredExceptionHandler)(ExceptionPointers*);
typedef int (*FnSortCB)(voidptr,voidptr);
typedef void (*os__ShellExecuteWin)(voidptr,u16*,u16*,u16*,u16*,int);
typedef void (*anon_fn_string)(string);
typedef void (*os__FnWalkContextCB)(voidptr,string);
typedef u32 (*os__VectoredExceptionHandler)(ExceptionPointers*);
typedef void (*os__FN_NTSuspendResume)(voidptr);
typedef void (*os__SignalHandler)(os__Signal);
typedef void (*os__FN_SA_Handler)(int);
typedef string (*anon_fn_string__string)(string);
typedef void (*v__builder__FnBackend)(v__builder__Builder*);
typedef void (*v__ast__FnPanicHandler)(v__ast__Table*,string);
typedef string (*v__dotgraph__FnLabel2NodeName)(string,voidptr);
typedef bool (*v__ast__walker__InspectorFn)(v__ast__Node*,voidptr);
typedef void (*anon_fn_)();
typedef voidptr (*sync__pool__ThreadCB)(sync__pool__PoolProcessor*,int,int);
struct rand__PRNG {
	union {
		void* _object;
		rand__wyrand__WyRandRNG* _rand__wyrand__WyRandRNG;
	};
	int _typ;
};
struct hash__Hasher {
	union {
		void* _object;
	};
	int _typ;
};
struct hash__Hash32er {
	union {
		void* _object;
	};
	int _typ;
};
struct hash__Hash64er {
	union {
		void* _object;
	};
	int _typ;
};
struct v__ast__walker__Visitor {
	union {
		void* _object;
		v__ast__walker__Inspector* _v__ast__walker__Inspector;
		v__callgraph__Mapper* _v__callgraph__Mapper;
	};
	int _typ;
};
// builtin types:
//------------------ #endbuiltin
struct none {
	EMPTY_STRUCT_DECLARATION;
};
typedef HANDLE __v_thread;

struct ContextRecord {
	EMPTY_STRUCT_DECLARATION;
};



struct ExceptionPointers {
	ExceptionRecord* exception_record;
	ContextRecord* context_record;
};



struct StrIntpCgenData {
	string str;
	string fmt;
	string d;
};



struct os__Uname {
	string sysname;
	string nodename;
	string release;
	string version;
	string machine;
};



struct os__ContextRecord {
	EMPTY_STRUCT_DECLARATION;
};



struct os__ExceptionPointers {
	ExceptionRecord* exception_record;
	ContextRecord* context_record;
};



struct v__transformer__Transformer {
	v__pref__Preferences* pref;
	v__transformer__IndexState* index;
};



struct v__cflag__CFlag {
	string mod;
	string os;
	string name;
	string value;
	string cached;
};



struct v__builder__WindowsKit {
	string um_lib_path;
	string ucrt_lib_path;
	string um_include_path;
	string ucrt_include_path;
	string shared_include_path;
};



struct v__builder__VsInstallation {
	string include_path;
	string lib_path;
	string exe_path;
};



struct v__vmod__ModFileAndFolder {
	string vmod_file;
	string vmod_folder;
};



// Union sum type v__ast__TypeDecl = 
//          |  274 = v__ast__AliasTypeDecl
//          |  275 = v__ast__FnTypeDecl  
//          |  276 = v__ast__SumTypeDecl 
struct v__ast__TypeDecl {
	union {
		v__ast__AliasTypeDecl* _v__ast__AliasTypeDecl;
		v__ast__FnTypeDecl* _v__ast__FnTypeDecl;
		v__ast__SumTypeDecl* _v__ast__SumTypeDecl;
	};
	int _typ;
	string* name;
	bool* is_pub;
	v__token__Position* pos;
	Array_v__ast__Comment* comments;
};


// Union sum type v__ast__Expr = 
//          |  278 = v__ast__AnonFn      
//          |  279 = v__ast__ArrayDecompose
//          |  280 = v__ast__ArrayInit   
//          |  281 = v__ast__AsCast      
//          |  282 = v__ast__Assoc       
//          |  283 = v__ast__AtExpr      
//          |  284 = v__ast__BoolLiteral 
//          |  285 = v__ast__CTempVar    
//          |  286 = v__ast__CallExpr    
//          |  287 = v__ast__CastExpr    
//          |  288 = v__ast__ChanInit    
//          |  289 = v__ast__CharLiteral 
//          |  290 = v__ast__Comment     
//          |  291 = v__ast__ComptimeCall
//          |  292 = v__ast__ComptimeSelector
//          |  293 = v__ast__ConcatExpr  
//          |  294 = v__ast__DumpExpr    
//          |  295 = v__ast__EmptyExpr   
//          |  296 = v__ast__EnumVal     
//          |  297 = v__ast__FloatLiteral
//          |  298 = v__ast__GoExpr      
//          |  299 = v__ast__Ident       
//          |  300 = v__ast__IfExpr      
//          |  301 = v__ast__IfGuardExpr 
//          |  302 = v__ast__IndexExpr   
//          |  303 = v__ast__InfixExpr   
//          |  304 = v__ast__IntegerLiteral
//          |  305 = v__ast__IsRefType   
//          |  306 = v__ast__Likely      
//          |  307 = v__ast__LockExpr    
//          |  308 = v__ast__MapInit     
//          |  309 = v__ast__MatchExpr   
//          |  310 = v__ast__NodeError   
//          |  311 = v__ast__None        
//          |  312 = v__ast__OffsetOf    
//          |  313 = v__ast__OrExpr      
//          |  314 = v__ast__ParExpr     
//          |  315 = v__ast__PostfixExpr 
//          |  316 = v__ast__PrefixExpr  
//          |  317 = v__ast__RangeExpr   
//          |  318 = v__ast__SelectExpr  
//          |  319 = v__ast__SelectorExpr
//          |  320 = v__ast__SizeOf      
//          |  321 = v__ast__SqlExpr     
//          |  322 = v__ast__StringInterLiteral
//          |  323 = v__ast__StringLiteral
//          |  324 = v__ast__StructInit  
//          |  325 = v__ast__TypeNode    
//          |  326 = v__ast__TypeOf      
//          |  327 = v__ast__UnsafeExpr  
struct v__ast__Expr {
	union {
		v__ast__AnonFn* _v__ast__AnonFn;
		v__ast__ArrayDecompose* _v__ast__ArrayDecompose;
		v__ast__ArrayInit* _v__ast__ArrayInit;
		v__ast__AsCast* _v__ast__AsCast;
		v__ast__Assoc* _v__ast__Assoc;
		v__ast__AtExpr* _v__ast__AtExpr;
		v__ast__BoolLiteral* _v__ast__BoolLiteral;
		v__ast__CTempVar* _v__ast__CTempVar;
		v__ast__CallExpr* _v__ast__CallExpr;
		v__ast__CastExpr* _v__ast__CastExpr;
		v__ast__ChanInit* _v__ast__ChanInit;
		v__ast__CharLiteral* _v__ast__CharLiteral;
		v__ast__Comment* _v__ast__Comment;
		v__ast__ComptimeCall* _v__ast__ComptimeCall;
		v__ast__ComptimeSelector* _v__ast__ComptimeSelector;
		v__ast__ConcatExpr* _v__ast__ConcatExpr;
		v__ast__DumpExpr* _v__ast__DumpExpr;
		v__ast__EmptyExpr* _v__ast__EmptyExpr;
		v__ast__EnumVal* _v__ast__EnumVal;
		v__ast__FloatLiteral* _v__ast__FloatLiteral;
		v__ast__GoExpr* _v__ast__GoExpr;
		v__ast__Ident* _v__ast__Ident;
		v__ast__IfExpr* _v__ast__IfExpr;
		v__ast__IfGuardExpr* _v__ast__IfGuardExpr;
		v__ast__IndexExpr* _v__ast__IndexExpr;
		v__ast__InfixExpr* _v__ast__InfixExpr;
		v__ast__IntegerLiteral* _v__ast__IntegerLiteral;
		v__ast__IsRefType* _v__ast__IsRefType;
		v__ast__Likely* _v__ast__Likely;
		v__ast__LockExpr* _v__ast__LockExpr;
		v__ast__MapInit* _v__ast__MapInit;
		v__ast__MatchExpr* _v__ast__MatchExpr;
		v__ast__NodeError* _v__ast__NodeError;
		v__ast__None* _v__ast__None;
		v__ast__OffsetOf* _v__ast__OffsetOf;
		v__ast__OrExpr* _v__ast__OrExpr;
		v__ast__ParExpr* _v__ast__ParExpr;
		v__ast__PostfixExpr* _v__ast__PostfixExpr;
		v__ast__PrefixExpr* _v__ast__PrefixExpr;
		v__ast__RangeExpr* _v__ast__RangeExpr;
		v__ast__SelectExpr* _v__ast__SelectExpr;
		v__ast__SelectorExpr* _v__ast__SelectorExpr;
		v__ast__SizeOf* _v__ast__SizeOf;
		v__ast__SqlExpr* _v__ast__SqlExpr;
		v__ast__StringInterLiteral* _v__ast__StringInterLiteral;
		v__ast__StringLiteral* _v__ast__StringLiteral;
		v__ast__StructInit* _v__ast__StructInit;
		v__ast__TypeNode* _v__ast__TypeNode;
		v__ast__TypeOf* _v__ast__TypeOf;
		v__ast__UnsafeExpr* _v__ast__UnsafeExpr;
	};
	int _typ;
};


// Union sum type v__ast__Stmt = 
//          |  329 = v__ast__AsmStmt     
//          |  330 = v__ast__AssertStmt  
//          |  331 = v__ast__AssignStmt  
//          |  332 = v__ast__Block       
//          |  333 = v__ast__BranchStmt  
//          |  334 = v__ast__ComptimeFor 
//          |  335 = v__ast__ConstDecl   
//          |  336 = v__ast__DeferStmt   
//          |  337 = v__ast__EmptyStmt   
//          |  338 = v__ast__EnumDecl    
//          |  339 = v__ast__ExprStmt    
//          |  216 = v__ast__FnDecl      
//          |  340 = v__ast__ForCStmt    
//          |  341 = v__ast__ForInStmt   
//          |  342 = v__ast__ForStmt     
//          |  343 = v__ast__GlobalDecl  
//          |  344 = v__ast__GotoLabel   
//          |  345 = v__ast__GotoStmt    
//          |  346 = v__ast__HashStmt    
//          |  347 = v__ast__Import      
//          |  348 = v__ast__InterfaceDecl
//          |  349 = v__ast__Module      
//          |  310 = v__ast__NodeError   
//          |  350 = v__ast__Return      
//          |  351 = v__ast__SqlStmt     
//          |  352 = v__ast__StructDecl  
//          |  277 = v__ast__TypeDecl    
struct v__ast__Stmt {
	union {
		v__ast__AsmStmt* _v__ast__AsmStmt;
		v__ast__AssertStmt* _v__ast__AssertStmt;
		v__ast__AssignStmt* _v__ast__AssignStmt;
		v__ast__Block* _v__ast__Block;
		v__ast__BranchStmt* _v__ast__BranchStmt;
		v__ast__ComptimeFor* _v__ast__ComptimeFor;
		v__ast__ConstDecl* _v__ast__ConstDecl;
		v__ast__DeferStmt* _v__ast__DeferStmt;
		v__ast__EmptyStmt* _v__ast__EmptyStmt;
		v__ast__EnumDecl* _v__ast__EnumDecl;
		v__ast__ExprStmt* _v__ast__ExprStmt;
		v__ast__FnDecl* _v__ast__FnDecl;
		v__ast__ForCStmt* _v__ast__ForCStmt;
		v__ast__ForInStmt* _v__ast__ForInStmt;
		v__ast__ForStmt* _v__ast__ForStmt;
		v__ast__GlobalDecl* _v__ast__GlobalDecl;
		v__ast__GotoLabel* _v__ast__GotoLabel;
		v__ast__GotoStmt* _v__ast__GotoStmt;
		v__ast__HashStmt* _v__ast__HashStmt;
		v__ast__Import* _v__ast__Import;
		v__ast__InterfaceDecl* _v__ast__InterfaceDecl;
		v__ast__Module* _v__ast__Module;
		v__ast__NodeError* _v__ast__NodeError;
		v__ast__Return* _v__ast__Return;
		v__ast__SqlStmt* _v__ast__SqlStmt;
		v__ast__StructDecl* _v__ast__StructDecl;
		v__ast__TypeDecl* _v__ast__TypeDecl;
	};
	int _typ;
	v__token__Position* pos;
};


// Union sum type v__ast__ScopeObject = 
//          |  354 = v__ast__AsmRegister 
//          |  355 = v__ast__ConstField  
//          |  356 = v__ast__GlobalField 
//          |  357 = v__ast__Var         
struct v__ast__ScopeObject {
	union {
		v__ast__AsmRegister* _v__ast__AsmRegister;
		v__ast__ConstField* _v__ast__ConstField;
		v__ast__GlobalField* _v__ast__GlobalField;
		v__ast__Var* _v__ast__Var;
	};
	int _typ;
	string* name;
	v__ast__Type* typ;
};


// Union sum type v__ast__Node = 
//          |  359 = v__ast__CallArg     
//          |  355 = v__ast__ConstField  
//          |  360 = v__ast__EmptyNode   
//          |  361 = v__ast__EnumField   
//          |  328 = v__ast__Expr        
//          |  207 = v__ast__File        
//          |  356 = v__ast__GlobalField 
//          |  362 = v__ast__IfBranch    
//          |  363 = v__ast__MatchBranch 
//          |  310 = v__ast__NodeError   
//          |  364 = v__ast__Param       
//          |  358 = v__ast__ScopeObject 
//          |  365 = v__ast__SelectBranch
//          |  353 = v__ast__Stmt        
//          |  366 = v__ast__StructField 
//          |  367 = v__ast__StructInitField
struct v__ast__Node {
	union {
		v__ast__CallArg* _v__ast__CallArg;
		v__ast__ConstField* _v__ast__ConstField;
		v__ast__EmptyNode* _v__ast__EmptyNode;
		v__ast__EnumField* _v__ast__EnumField;
		v__ast__Expr* _v__ast__Expr;
		v__ast__File* _v__ast__File;
		v__ast__GlobalField* _v__ast__GlobalField;
		v__ast__IfBranch* _v__ast__IfBranch;
		v__ast__MatchBranch* _v__ast__MatchBranch;
		v__ast__NodeError* _v__ast__NodeError;
		v__ast__Param* _v__ast__Param;
		v__ast__ScopeObject* _v__ast__ScopeObject;
		v__ast__SelectBranch* _v__ast__SelectBranch;
		v__ast__Stmt* _v__ast__Stmt;
		v__ast__StructField* _v__ast__StructField;
		v__ast__StructInitField* _v__ast__StructInitField;
	};
	int _typ;
};


// Union sum type v__ast__ComptTimeConstValue = 
//          |  295 = v__ast__EmptyExpr   
//          |   10 = byte                
//          |   15 = f32                 
//          |   16 = f64                 
//          |    6 = i16                 
//          |    8 = i64                 
//          |    5 = i8                  
//          |    7 = int                 
//          |   21 = rune                
//          |   20 = string              
//          |   11 = u16                 
//          |   12 = u32                 
//          |   13 = u64                 
struct v__ast__ComptTimeConstValue {
	union {
		v__ast__EmptyExpr* _v__ast__EmptyExpr;
		byte* _byte;
		f32* _f32;
		f64* _f64;
		i16* _i16;
		i64* _i64;
		i8* _i8;
		int* _int;
		rune* _rune;
		string* _string;
		u16* _u16;
		u32* _u32;
		u64* _u64;
	};
	int _typ;
};


// Union sum type v__ast__IdentInfo = 
//          |  407 = v__ast__IdentFn     
//          |  408 = v__ast__IdentVar    
struct v__ast__IdentInfo {
	union {
		v__ast__IdentFn* _v__ast__IdentFn;
		v__ast__IdentVar* _v__ast__IdentVar;
	};
	int _typ;
};


// Union sum type v__ast__AsmArg = 
//          |  428 = v__ast__AsmAddressing
//          |  429 = v__ast__AsmAlias    
//          |  430 = v__ast__AsmDisp     
//          |  354 = v__ast__AsmRegister 
//          |  284 = v__ast__BoolLiteral 
//          |  289 = v__ast__CharLiteral 
//          |  297 = v__ast__FloatLiteral
//          |  304 = v__ast__IntegerLiteral
//          |   20 = string              
struct v__ast__AsmArg {
	union {
		v__ast__AsmAddressing* _v__ast__AsmAddressing;
		v__ast__AsmAlias* _v__ast__AsmAlias;
		v__ast__AsmDisp* _v__ast__AsmDisp;
		v__ast__AsmRegister* _v__ast__AsmRegister;
		v__ast__BoolLiteral* _v__ast__BoolLiteral;
		v__ast__CharLiteral* _v__ast__CharLiteral;
		v__ast__FloatLiteral* _v__ast__FloatLiteral;
		v__ast__IntegerLiteral* _v__ast__IntegerLiteral;
		string* _string;
	};
	int _typ;
};


// Union sum type v__ast__TypeInfo = 
//          |  458 = v__ast__Aggregate   
//          |  460 = v__ast__Alias       
//          |  441 = v__ast__Array       
//          |  468 = v__ast__ArrayFixed  
//          |  469 = v__ast__Chan        
//          |  474 = v__ast__Enum        
//          |  472 = v__ast__FnType      
//          |  473 = v__ast__GenericInst 
//          |  463 = v__ast__Interface   
//          |  442 = v__ast__Map         
//          |  471 = v__ast__MultiReturn 
//          |  446 = v__ast__Struct      
//          |  464 = v__ast__SumType     
//          |  470 = v__ast__Thread      
struct v__ast__TypeInfo {
	union {
		v__ast__Aggregate* _v__ast__Aggregate;
		v__ast__Alias* _v__ast__Alias;
		v__ast__Array* _v__ast__Array;
		v__ast__ArrayFixed* _v__ast__ArrayFixed;
		v__ast__Chan* _v__ast__Chan;
		v__ast__Enum* _v__ast__Enum;
		v__ast__FnType* _v__ast__FnType;
		v__ast__GenericInst* _v__ast__GenericInst;
		v__ast__Interface* _v__ast__Interface;
		v__ast__Map* _v__ast__Map;
		v__ast__MultiReturn* _v__ast__MultiReturn;
		v__ast__Struct* _v__ast__Struct;
		v__ast__SumType* _v__ast__SumType;
		v__ast__Thread* _v__ast__Thread;
	};
	int _typ;
};


struct v__gen__c__ProfileCounterMeta {
	string fn_name;
	string vpc_name;
	string vpc_calls;
};



struct sync__Subscription {
	sync__Semaphore* sem;
	sync__Subscription** prev;
	sync__Subscription* nxt;
};



struct VCastTypeIndexName {
	int tindex;
	string tname;
};



struct VAssertMetaInfo {
	string fpath;
	int line_nr;
	string fn_name;
	string src;
	string op;
	string llabel;
	string rlabel;
	string lvalue;
	string rvalue;
};



struct MethodArgs {
	int typ;
	string name;
};



struct FunctionData {
	string name;
	Array_string attrs;
	Array_MethodArgs args;
	int return_type;
	int typ;
};



struct FieldData {
	string name;
	Array_string attrs;
	bool is_pub;
	bool is_mut;
	bool is_shared;
	int typ;
};



struct StructAttribute {
	string name;
	bool has_arg;
	string arg;
	AttributeKind kind;
};



struct Line64 {
	u32 f_size_of_struct;
	voidptr f_key;
	u32 f_line_number;
	byte* f_file_name;
	u64 f_address;
};



struct ExceptionRecord {
	u32 code;
	u32 flags;
	ExceptionRecord* record;
	voidptr address;
	u32 param_count;
};



union strconv__Float64u {
	f64 f;
	u64 u;
};



union strconv__Float32u {
	f32 f;
	u32 u;
};



struct None__ {
	string msg;
	int code;
};



struct VMemoryBlock {
	int id;
	int cap;
	byte* start;
	VMemoryBlock* previous;
	int remaining;
	byte* current;
	int mallocs;
};



struct SortedMap {
	int value_bytes;
	mapnode* root;
	int len;
};



struct RepIndex {
	int idx;
	int val_idx;
};



union StrIntpMem {
	u32 d_c;
	byte d_u8;
	i8 d_i8;
	u16 d_u16;
	i16 d_i16;
	u32 d_u32;
	int d_i32;
	u64 d_u64;
	i64 d_i64;
	f32 d_f32;
	f64 d_f64;
	string d_s;
	voidptr d_p;
	voidptr d_vp;
};



struct strconv__BF_param {
	byte pad_ch;
	int len0;
	int len1;
	bool positive;
	bool sign_flag;
	strconv__Align_text allign;
	bool rm_tail_zero;
};



struct strconv__PrepNumber {
	bool negative;
	int exponent;
	u64 mantissa;
};



struct strconv__Dec32 {
	u32 m;
	int e;
};



union strconv__Uf32 {
	f32 f;
	u32 u;
};



struct strconv__Dec64 {
	u64 m;
	int e;
};



union strconv__Uf64 {
	f64 f;
	u64 u;
};



struct strconv__Uint128 {
	u64 lo;
	u64 hi;
};



struct os__File {
	voidptr cfile;
	int fd;
	bool is_opened;
};



struct os__FileInfo {
	string name;
	int size;
};



struct os__ErrFileNotOpened {
	string msg;
	int code;
};



struct os__ErrSizeOfTypeIs0 {
	string msg;
	int code;
};



struct os__FilePermission {
	bool read;
	bool write;
	bool execute;
};



struct os__Result {
	int exit_code;
	string output;
};



struct os__ErrExecutableNotFound {
	string msg;
	int code;
};



struct os__Filetime {
	u32 dw_low_date_time;
	u32 dw_high_date_time;
};



struct os__ProcessInformation {
	voidptr h_process;
	voidptr h_thread;
	u32 dw_process_id;
	u32 dw_thread_id;
};



struct os__StartupInfo {
	u32 cb;
	u16* lp_reserved;
	u16* lp_desktop;
	u16* lp_title;
	u32 dw_x;
	u32 dw_y;
	u32 dw_x_size;
	u32 dw_y_size;
	u32 dw_x_count_chars;
	u32 dw_y_count_chars;
	u32 dw_fill_attributes;
	u32 dw_flags;
	u16 w_show_window;
	u16 cb_reserved2;
	byte* lp_reserved2;
	voidptr h_std_input;
	voidptr h_std_output;
	voidptr h_std_error;
};



struct os__SecurityAttributes {
	u32 n_length;
	voidptr lp_security_descriptor;
	bool b_inherit_handle;
};



struct os__ExceptionRecord {
	u32 code;
	u32 flags;
	ExceptionRecord* record;
	voidptr address;
	u32 param_count;
};



struct term__Coord {
	int x;
	int y;
};



struct v__vcache__CacheManager {
	string basepath;
	string original_vopts;
	string vopts;
	Map_string_string k2cpath;
};



struct v__util__EManager {
	bool support_color;
};



struct v__token__Position {
	int len;
	int line_nr;
	int pos;
	int col;
	int last_line;
};



struct v__util__LinesCache {
	Map_string_Array_string lines;
};



struct v__util__Possibility {
	string value;
	string svalue;
	f32 similarity;
};



struct v__util__Suggestion {
	Array_v__util__Possibility known;
	string wanted;
	string swanted;
};



struct v__util__Surrounder {
	Array_string befores;
	Array_string afters;
};



struct time__StopWatch {
	u64 elapsed;
	u64 start;
	u64 end;
};



struct v__util__Timers {
	string label;
	Map_string_time__StopWatch swatches;
	bool should_print;
	Array_string already_shown;
};



struct v__util__TimerParams {
	bool should_print;
	string label;
};



struct v__util__SourceCache {
	Map_string_string sources;
};



struct v__builder__MsvcResult {
	string full_cl_exe_path;
	string exe_path;
	string um_lib_path;
	string ucrt_lib_path;
	string vs_lib_path;
	string um_include_path;
	string ucrt_include_path;
	string vs_include_path;
	string shared_include_path;
	bool valid;
};



struct v__ast__Table {
	Array_v__ast__TypeSymbol_ptr type_symbols;
	Map_string_int type_idxs;
	Map_string_v__ast__Fn fns;
	Map_string_Array_v__ast__Type iface_types;
	Map_int_string dumps;
	Array_string imports;
	Array_string modules;
	v__ast__Scope* global_scope;
	Array_v__cflag__CFlag cflags;
	Array_string redefined_fns;
	Map_string_Array_Array_v__ast__Type fn_generic_types;
	Map_int_v__ast__InterfaceDecl interfaces;
	string cmod_prefix;
	bool is_fmt;
	Map_string_bool used_fns;
	Map_string_bool used_consts;
	Map_string_bool used_globals;
	Array_v__ast__Type used_vweb_types;
	int used_maps;
	v__ast__FnPanicHandler panic_handler;
	voidptr panic_userdata;
	int panic_npanics;
	v__ast__FnDecl* cur_fn;
	Array_v__ast__Type cur_concrete_types;
	int gostmts;
	Map_string_v__ast__EnumDecl enum_decls;
};



struct v__builder__CcompilerOptions {
	string guessed_compiler;
	string shared_postfix;
	bool debug_mode;
	bool is_cc_tcc;
	bool is_cc_gcc;
	bool is_cc_msvc;
	bool is_cc_clang;
	string env_cflags;
	string env_ldflags;
	Array_string args;
	Array_string wargs;
	Array_string pre_args;
	Array_string o_args;
	Array_string source_args;
	Array_string post_args;
	Array_string linker_flags;
};



struct v__depgraph__DepGraph {
	bool acyclic;
	Array_v__depgraph__DepGraphNode nodes;
};



struct v__builder__MsvcStringFlags {
	Array_string real_libs;
	Array_string inc_paths;
	Array_string lib_paths;
	Array_string defines;
	Array_string other_flags;
};



struct strings__textscanner__TextScanner {
	string input;
	int ilen;
	int pos;
};



struct rand__config__PRNGConfigStruct {
	Array_u32 seed_;
};



struct rand__wyrand__WyRandRNG {
	u64 state;
	bool has_extra;
	u32 extra;
};



struct v__token__WIndex {
	string word;
	int index;
};


typedef Array_v__token__WIndex Array_fixed_Array_v__token__WIndex_20 [20];

struct v__token__Token {
	v__token__Kind kind;
	string lit;
	int line_nr;
	int col;
	int pos;
	int len;
	int tidx;
};



struct time__Time {
	int year;
	int month;
	int day;
	int hour;
	int minute;
	int second;
	int microsecond;
	i64 _v_unix;
};



struct time__TimeParseError {
	string msg;
	int code;
};



struct time__StopWatchOptions {
	bool auto_start;
};



struct time__SystemTime {
	u16 year;
	u16 month;
	u16 day_of_week;
	u16 day;
	u16 hour;
	u16 minute;
	u16 second;
	u16 millisecond;
};



struct v__vmod__Manifest {
	string name;
	string version;
	string description;
	Array_string dependencies;
	string license;
	string repo_url;
	string author;
	Map_string_Array_string unknown;
};



struct v__vmod__Token {
	v__vmod__TokenKind typ;
	string val;
};



struct v__vmod__Scanner {
	int pos;
	string text;
	bool inside_text;
	Array_v__vmod__Token tokens;
};



struct v__vmod__ModFileCacher {
	Map_string_v__vmod__ModFileAndFolder cache;
	Map_string_Array_string folder_files;
};



struct v__ast__CTempVar {
	string name;
	v__ast__Expr orig;
	v__ast__Type typ;
	bool is_ptr;
};



struct v__ast__EmptyExpr {
	int x;
};



struct v__ast__AsmRegister {
	string name;
	v__ast__Type typ;
	int size;
};



struct v__ast__EmptyNode {
	int x;
};



struct v__ast__Scope {
	Map_string_v__ast__ScopeObject objects;
	Map_string_v__ast__ScopeStructField struct_fields;
	v__ast__Scope* parent;
	bool detached_from_parent;
	Array_v__ast__Scope_ptr children;
	int start_pos;
	int end_pos;
};



struct v__ast__EmbeddedFile {
	string rpath;
	string apath;
	string compression_type;
	bool is_compressed;
	Array_byte bytes;
	int len;
};



struct v__ast__IdentFn {
	v__ast__Type typ;
};



struct v__ast__IdentVar {
	v__ast__Type typ;
	bool is_mut;
	bool is_static;
	bool is_volatile;
	bool is_optional;
	v__ast__ShareType share;
};



struct v__ast__Array {
	int nr_dims;
	v__ast__Type elem_type;
};



struct v__ast__Map {
	v__ast__Type key_type;
	v__ast__Type value_type;
};



struct v__ast__Struct {
	Array_v__ast__Attr attrs;
	Array_v__ast__Type embeds;
	Array_v__ast__StructField fields;
	bool is_typedef;
	bool is_union;
	bool is_heap;
	bool is_generic;
	Array_v__ast__Type generic_types;
	Array_v__ast__Type concrete_types;
	v__ast__Type parent_type;
};



struct v__ast__TypeSymbol {
	int parent_idx;
	v__ast__TypeInfo info;
	v__ast__Kind kind;
	string name;
	string cname;
	Array_v__ast__Fn methods;
	string mod;
	bool is_public;
	v__ast__Language language;
	int idx;
};



struct v__ast__Aggregate {
	Array_v__ast__StructField fields;
	Array_v__ast__Type types;
};



struct v__ast__GetEmbedsOptions {
	Array_v__ast__Type preceding;
};



struct v__ast__Alias {
	v__ast__Type parent_type;
	v__ast__Language language;
	bool is_import;
};



struct v__ast__Interface {
	Array_v__ast__Type types;
	Array_v__ast__StructField fields;
	Array_v__ast__Fn methods;
	Array_v__ast__Type ifaces;
	Map_int_Array_v__ast__Type conversions;
	bool is_generic;
	Array_v__ast__Type generic_types;
	Array_v__ast__Type concrete_types;
	v__ast__Type parent_type;
};



struct v__ast__SumType {
	Array_v__ast__Type variants;
	Array_v__ast__StructField fields;
	bool found_fields;
	bool is_anon;
	bool is_generic;
	Array_v__ast__Type generic_types;
	Array_v__ast__Type concrete_types;
	v__ast__Type parent_type;
};



struct v__ast__ArrayFixed {
	int size;
	v__ast__Expr size_expr;
	v__ast__Type elem_type;
};



struct v__ast__Chan {
	v__ast__Type elem_type;
	bool is_mut;
};



struct v__ast__Thread {
	v__ast__Type return_type;
};



struct v__ast__MultiReturn {
	Array_v__ast__Type types;
};



struct v__ast__GenericInst {
	int parent_idx;
	Array_v__ast__Type concrete_types;
};



struct v__ast__Enum {
	Array_string vals;
	bool is_flag;
	bool is_multi_allowed;
};



struct v__ast__FnSignatureOpts {
	bool skip_receiver;
	bool type_only;
};



struct v__transformer__KeyVal {
	string key;
	int value;
};



struct v__transformer__IndexState {
	Map_string_int max_index;
	Array_bool saved_disabled;
	Array_Array_v__transformer__KeyVal saved_key_vals;
	bool disabled;
	int level;
};



struct v__scanner__Scanner {
	string file_path;
	string file_base;
	string text;
	int pos;
	int line_nr;
	int last_nl_pos;
	bool is_crlf;
	bool is_inside_string;
	bool is_inter_start;
	bool is_inter_end;
	bool is_enclosed_inter;
	string line_comment;
	int last_lt;
	bool is_started;
	bool is_print_line_on_error;
	bool is_print_colored_error;
	bool is_print_rel_paths_on_error;
	byte quote;
	byte inter_quote;
	int nr_lines;
	bool is_vh;
	bool is_fmt;
	v__scanner__CommentsMode comments_mode;
	bool is_inside_toplvl_statement;
	Array_v__token__Token all_tokens;
	int tidx;
	int eofs;
	v__pref__Preferences* pref;
	Array_string error_details;
	Array_v__errors__Error errors;
	Array_v__errors__Warning warnings;
	Array_v__errors__Notice notices;
	Array_v__vet__Error vet_errors;
	bool should_abort;
};



struct v__parser__EatCommentsConfig {
	bool same_line;
	bool follow_up;
};



struct v__markused__Walker {
	v__ast__Table* table;
	Map_string_bool used_fns;
	Map_string_bool used_consts;
	Map_string_bool used_globals;
	int n_asserts;
	v__pref__Preferences* pref;
	Array_v__ast__File_ptr files;
	Map_string_v__ast__FnDecl all_fns;
	Map_string_v__ast__ConstField all_consts;
	Map_string_v__ast__GlobalField all_globals;
};



struct v__depgraph__DepGraphNode {
	string name;
	Array_string deps;
};



struct v__depgraph__OrderedDepMap {
	Array_string keys;
	Map_string_Array_string data;
};



struct v__depgraph__NodeNames {
	Map_string_bool is_cycle;
	Map_string_Array_string names;
};



struct v__dotgraph__DotGraph {
	strings__Builder sb;
};



struct v__dotgraph__NewNodeConfig {
	string node_name;
	bool should_highlight;
	string tooltip;
	voidptr ctx;
	v__dotgraph__FnLabel2NodeName name2node_fn;
};



struct v__dotgraph__NewEdgeConfig {
	bool should_highlight;
	voidptr ctx;
	v__dotgraph__FnLabel2NodeName name2node_fn;
};



struct v__gen__c__UnsupportedAssertCtempTransform {
	string msg;
	int code;
};



struct v__gen__c__StrType {
	string styp;
	v__ast__Type typ;
};



struct v__gen__c__SumtypeCastingFn {
	string fn_name;
	v__ast__Type got;
	v__ast__Type exp;
};



struct v__gen__c__GenSafeIntegerCfg {
	v__token__Kind op;
	bool reverse;
	v__ast__Type unsigned_type;
	v__ast__Expr unsigned_expr;
	v__ast__Type signed_type;
	v__ast__Expr signed_expr;
};



struct v__gen__c__Type {
	v__ast__Type typ;
	v__ast__TypeSymbol* sym;
	v__ast__Type unaliased;
	v__ast__TypeSymbol* unaliased_sym;
};



struct v__pkgconfig__MainOptions {
	bool modversion;
	bool description;
	bool help;
	bool debug;
	bool listall;
	bool exists;
	bool variables;
	bool requires;
	string atleast;
	string atleastpc;
	string exactversion;
	bool version;
	bool cflags;
	bool cflags_only_path;
	bool cflags_only_other;
	bool stat1c;
	bool libs;
	bool libs_only_link;
	bool libs_only_path;
	bool libs_only_other;
	Array_string args;
};



struct v__pkgconfig__Main {
	v__pkgconfig__MainOptions* opt;
	string res;
	bool has_actions;
};



struct v__pkgconfig__Options {
	string path;
	bool debug;
	bool norecurse;
	bool only_description;
	bool use_default_paths;
};



struct flag__FlagParser {
	Array_string original_args;
	int idx_dashdash;
	Array_string all_after_dashdash;
	Array_string usage_examples;
	string default_help_label;
	string default_version_label;
	Array_string args;
	int max_free_args;
	Array_flag__Flag flags;
	string application_name;
	string application_version;
	string application_description;
	int min_free_args;
	string args_description;
	bool allow_unknown_args;
	Array_string footers;
};



struct v__ast__walker__Inspector {
	v__ast__walker__InspectorFn inspector_callback;
	voidptr data;
};



struct sync__Semaphore {
	SRWLOCK mtx;
	CONDITION_VARIABLE cond;
	u32 count;
};



struct sync__RwMutex {
	SRWLOCK mx;
};



struct sync__Mutex {
	SRWLOCK mx;
};



struct sync__pool__PoolProcessorConfig {
	int maxjobs;
	sync__pool__ThreadCB callback;
};



struct flag__Flag {
	string name;
	byte abbr;
	string usage;
	string val_desc;
};



struct flag__UnkownFlagError {
	string msg;
	int code;
};



struct flag__MinimumArgsCountError {
	string msg;
	int code;
};



struct flag__MaximumArgsCountError {
	string msg;
	int code;
};



struct flag__NoArgsExpectedError {
	string msg;
	int code;
};



struct semver__Version {
	int major;
	int minor;
	int patch;
	string prerelease;
	string metadata;
};



struct semver__RawVersion {
	string prerelease;
	string metadata;
	Array_string raw_ints;
};



struct semver__ComparatorSet {
	Array_semver__Comparator comparators;
};



struct semver__Range {
	Array_semver__ComparatorSet comparator_sets;
};



struct semver__InvalidComparatorCountError {
	string msg;
	int code;
};



struct semver__InvalidComparatorFormatError {
	string msg;
	int code;
};



struct semver__EmptyInputError {
	string msg;
	int code;
};



struct semver__InvalidVersionFormatError {
	string msg;
	int code;
};



struct SymbolInfo {
	u32 f_size_of_struct;
	u32 f_type_index;
	Array_fixed_u64_2 f_reserved;
	u32 f_index;
	u32 f_size;
	u64 f_mod_base;
	u32 f_flags;
	u64 f_value;
	u64 f_address;
	u32 f_register;
	u32 f_scope;
	u32 f_tag;
	u32 f_name_len;
	u32 f_max_name_len;
	byte f_name;
};



struct mapnode {
	voidptr* children;
	int len;
	Array_fixed_string_11 keys;
	Array_fixed_voidptr_11 values;
};



struct StrIntpData {
	string str;
	u32 fmt;
	StrIntpMem d;
};



struct os__FileMode {
	os__FileType typ;
	os__FilePermission owner;
	os__FilePermission group;
	os__FilePermission others;
};



struct os__Win32finddata {
	u32 dw_file_attributes;
	os__Filetime ft_creation_time;
	os__Filetime ft_last_access_time;
	os__Filetime ft_last_write_time;
	u32 n_file_size_high;
	u32 n_file_size_low;
	u32 dw_reserved0;
	u32 dw_reserved1;
	Array_fixed_u16_260 c_file_name;
	Array_fixed_u16_14 c_alternate_file_name;
	u32 dw_file_type;
	u32 dw_creator_type;
	u16 w_finder_flags;
};



struct os__Process {
	string filename;
	int pid;
	int code;
	os__ProcessState status;
	string err;
	Array_string args;
	bool env_is_custom;
	Array_string env;
	bool use_stdio_ctl;
	bool use_pgroup;
	Array_fixed_int_3 stdio_fd;
	voidptr wdata;
};



struct os__WProcess {
	os__ProcessInformation proc_info;
	Array_fixed_byte_65536 command_line;
	u32* child_stdin;
	u32* child_stdout_read;
	u32* child_stdout_write;
	u32* child_stderr_read;
	u32* child_stderr_write;
};



struct v__pref__Preferences {
	v__pref__OS os;
	v__pref__Backend backend;
	v__pref__BuildMode build_mode;
	v__pref__Arch arch;
	v__pref__OutputMode output_mode;
	bool is_verbose;
	bool is_test;
	bool is_script;
	bool is_vsh;
	bool is_livemain;
	bool is_liveshared;
	bool is_shared;
	bool is_o;
	bool is_prof;
	string test_runner;
	string profile_file;
	bool profile_no_inline;
	bool translated;
	bool is_prod;
	bool obfuscate;
	bool is_repl;
	bool is_run;
	bool is_debug;
	bool is_vlines;
	bool sanitize;
	bool sourcemap;
	bool sourcemap_inline;
	bool sourcemap_src_included;
	bool show_cc;
	bool show_c_output;
	bool show_callgraph;
	bool show_depgraph;
	string dump_c_flags;
	bool use_cache;
	bool retry_compilation;
	bool is_stats;
	string cflags;
	bool m64;
	string ccompiler;
	v__pref__CompilerType ccompiler_type;
	string third_party_option;
	bool building_v;
	bool autofree;
	bool compress;
	bool no_builtin;
	bool enable_globals;
	bool is_fmt;
	bool is_vet;
	bool is_bare;
	string bare_builtin_dir;
	bool no_preludes;
	string custom_prelude;
	Array_string lookup_path;
	bool output_cross_c;
	bool output_es5;
	bool prealloc;
	string vroot;
	string out_name_c;
	string out_name;
	string path;
	Array_string run_only;
	Array_string compile_defines;
	Array_string compile_defines_all;
	Array_string run_args;
	Array_string printfn_list;
	bool print_v_files;
	bool skip_running;
	bool skip_warnings;
	bool warn_impure_v;
	bool warns_are_errors;
	bool fatal_errors;
	bool reuse_tmpc;
	bool no_rsp;
	bool no_std;
	v__pref__ColorOutput use_color;
	bool no_parallel;
	bool is_vweb;
	bool only_check_syntax;
	bool check_only;
	bool experimental;
	bool skip_unused;
	bool show_timings;
	bool is_ios_simulator;
	bool is_apk;
	Array_string cleanup_files;
	Array_string build_options;
	v__vcache__CacheManager cache_manager;
	bool is_help;
	v__pref__GarbageCollectionMode gc_mode;
	bool is_cstrict;
	v__pref__AssertFailureMode assert_failure_mode;
	int message_limit;
	bool nofloat;
	int checker_match_exhaustive_cutoff_limit;
};



struct v__builder__Builder {
	string compiled_dir;
	string module_path;
	v__checker__Checker* checker;
	v__transformer__Transformer* transformer;
	string out_name_c;
	string out_name_js;
	int stats_lines;
	int stats_bytes;
	int nr_errors;
	int nr_warnings;
	int nr_notices;
	v__pref__Preferences* pref;
	Array_string module_search_paths;
	Array_v__ast__File_ptr parsed_files;
	v__builder__MsvcResult cached_msvc;
	v__ast__Table* table;
	v__builder__CcompilerOptions ccoptions;
	Map_string_Array_string mod_invalidates_paths;
	Map_string_Array_string mod_invalidates_mods;
	Map_string_Array_string path_invalidates_mods;
};



struct v__errors__Error {
	string message;
	string details;
	string file_path;
	v__token__Position pos;
	string backtrace;
	v__errors__Reporter reporter;
};



struct v__token__KeywordsMatcher {
	int len_min;
	int len_max;
	Array_fixed_Array_v__token__WIndex_20 words;
};



struct v__vmod__Parser {
	string file_path;
	v__vmod__Scanner scanner;
};



struct v__errors__Warning {
	string message;
	string details;
	string file_path;
	v__token__Position pos;
	v__errors__Reporter reporter;
};



struct v__errors__Notice {
	string message;
	string details;
	string file_path;
	v__token__Position pos;
	v__errors__Reporter reporter;
};



struct v__ast__AliasTypeDecl {
	string name;
	bool is_pub;
	v__ast__Type parent_type;
	v__token__Position pos;
	v__token__Position type_pos;
	Array_v__ast__Comment comments;
};



struct v__ast__FnTypeDecl {
	string name;
	bool is_pub;
	v__ast__Type typ;
	v__token__Position pos;
	v__token__Position type_pos;
	Array_v__ast__Comment comments;
};



struct v__ast__SumTypeDecl {
	string name;
	bool is_pub;
	v__token__Position pos;
	Array_v__ast__Comment comments;
	v__ast__Type typ;
	Array_v__ast__Type generic_types;
	Array_v__ast__TypeNode variants;
};



struct v__ast__ArrayDecompose {
	v__ast__Expr expr;
	v__token__Position pos;
	v__ast__Type expr_type;
	v__ast__Type arg_type;
};



struct v__ast__ArrayInit {
	v__token__Position pos;
	v__token__Position elem_type_pos;
	Array_v__ast__Expr exprs;
	Array_Array_v__ast__Comment ecmnts;
	Array_v__ast__Comment pre_cmnts;
	bool is_fixed;
	bool has_val;
	string mod;
	v__ast__Expr len_expr;
	v__ast__Expr cap_expr;
	v__ast__Expr default_expr;
	bool has_len;
	bool has_cap;
	bool has_default;
	bool has_it;
	Array_v__ast__Type expr_types;
	v__ast__Type elem_type;
	v__ast__Type typ;
};



struct v__ast__AsCast {
	v__ast__Expr expr;
	v__ast__Type typ;
	v__token__Position pos;
	v__ast__Type expr_type;
};



struct v__ast__Assoc {
	string var_name;
	Array_string fields;
	Array_v__ast__Expr exprs;
	v__token__Position pos;
	v__ast__Type typ;
	v__ast__Scope* scope;
};



struct v__ast__AtExpr {
	string name;
	v__token__Position pos;
	v__token__AtKind kind;
	string val;
};



struct v__ast__BoolLiteral {
	bool val;
	v__token__Position pos;
};



struct v__ast__CastExpr {
	v__ast__Expr arg;
	v__ast__Type typ;
	v__ast__Expr expr;
	string typname;
	v__ast__Type expr_type;
	bool has_arg;
	v__token__Position pos;
};



struct v__ast__ChanInit {
	v__token__Position pos;
	v__ast__Expr cap_expr;
	bool has_cap;
	v__ast__Type typ;
	v__ast__Type elem_type;
};



struct v__ast__CharLiteral {
	string val;
	v__token__Position pos;
};



struct v__ast__Comment {
	string text;
	bool is_multi;
	bool is_inline;
	v__token__Position pos;
};



struct v__ast__ComptimeSelector {
	bool has_parens;
	v__ast__Expr left;
	v__ast__Expr field_expr;
	v__token__Position pos;
	v__ast__Type left_type;
	v__ast__Type typ;
};



struct v__ast__ConcatExpr {
	Array_v__ast__Expr vals;
	v__token__Position pos;
	v__ast__Type return_type;
};



struct v__ast__DumpExpr {
	v__ast__Expr expr;
	v__token__Position pos;
	v__ast__Type expr_type;
	string cname;
};



struct v__ast__EnumVal {
	string enum_name;
	string val;
	string mod;
	v__token__Position pos;
	v__ast__Type typ;
};



struct v__ast__FloatLiteral {
	string val;
	v__token__Position pos;
};



struct v__ast__Ident {
	v__ast__Language language;
	v__token__Kind tok_kind;
	v__token__Position pos;
	v__token__Position mut_pos;
	bool comptime;
	v__ast__Scope* scope;
	v__ast__ScopeObject obj;
	string mod;
	string name;
	v__ast__IdentKind kind;
	v__ast__IdentInfo info;
	bool is_mut;
};



struct v__ast__IfExpr {
	bool is_comptime;
	v__token__Kind tok_kind;
	v__ast__Expr left;
	v__token__Position pos;
	Array_v__ast__Comment post_comments;
	Array_v__ast__IfBranch branches;
	bool is_expr;
	v__ast__Type typ;
	bool has_else;
};



struct v__ast__IfGuardExpr {
	string var_name;
	v__token__Position pos;
	v__ast__Expr expr;
	v__ast__Type expr_type;
};



struct v__ast__IntegerLiteral {
	string val;
	v__token__Position pos;
};



struct v__ast__IsRefType {
	bool is_type;
	v__ast__Expr expr;
	v__token__Position pos;
	v__ast__Type typ;
};



struct v__ast__Likely {
	v__ast__Expr expr;
	v__token__Position pos;
	bool is_likely;
};



struct v__ast__LockExpr {
	Array_v__ast__Stmt stmts;
	Array_bool is_rlock;
	v__token__Position pos;
	Array_v__ast__Expr lockeds;
	Array_v__ast__Comment comments;
	bool is_expr;
	v__ast__Type typ;
	v__ast__Scope* scope;
};



struct v__ast__MapInit {
	v__token__Position pos;
	Array_v__ast__Expr keys;
	Array_v__ast__Expr vals;
	Array_Array_v__ast__Comment comments;
	Array_v__ast__Comment pre_cmnts;
	v__ast__Type typ;
	v__ast__Type key_type;
	v__ast__Type value_type;
};



struct v__ast__MatchExpr {
	v__token__Kind tok_kind;
	v__ast__Expr cond;
	Array_v__ast__MatchBranch branches;
	v__token__Position pos;
	Array_v__ast__Comment comments;
	bool is_expr;
	v__ast__Type return_type;
	v__ast__Type cond_type;
	v__ast__Type expected_type;
	bool is_sum_type;
};



struct v__ast__NodeError {
	int idx;
	v__token__Position pos;
};



struct v__ast__None {
	v__token__Position pos;
};



struct v__ast__OffsetOf {
	v__ast__Type struct_type;
	string field;
	v__token__Position pos;
};



struct v__ast__OrExpr {
	Array_v__ast__Stmt stmts;
	v__ast__OrKind kind;
	v__token__Position pos;
};



struct v__ast__ParExpr {
	v__ast__Expr expr;
	v__token__Position pos;
};



struct v__ast__PostfixExpr {
	v__token__Kind op;
	v__ast__Expr expr;
	v__token__Position pos;
	string auto_locked;
};



struct v__ast__RangeExpr {
	v__ast__Expr low;
	v__ast__Expr high;
	bool has_high;
	bool has_low;
	v__token__Position pos;
	bool is_gated;
};



struct v__ast__SelectExpr {
	Array_v__ast__SelectBranch branches;
	v__token__Position pos;
	bool has_exception;
	bool is_expr;
	v__ast__Type expected_type;
};



struct v__ast__SelectorExpr {
	v__token__Position pos;
	string field_name;
	bool is_mut;
	v__token__Position mut_pos;
	v__token__Kind next_token;
	v__ast__Expr expr;
	v__ast__Type expr_type;
	v__ast__Type typ;
	v__ast__Type name_type;
	v__ast__GenericKindField gkind_field;
	v__ast__Scope* scope;
	Array_v__ast__Type from_embed_types;
};



struct v__ast__SizeOf {
	bool is_type;
	v__ast__Expr expr;
	v__token__Position pos;
	v__ast__Type typ;
};



struct v__ast__StringInterLiteral {
	Array_string vals;
	Array_v__ast__Expr exprs;
	Array_int fwidths;
	Array_int precisions;
	Array_bool pluss;
	Array_bool fills;
	Array_v__token__Position fmt_poss;
	v__token__Position pos;
	Array_v__ast__Type expr_types;
	Array_byte fmts;
	Array_bool need_fmts;
};



struct v__ast__StringLiteral {
	string val;
	bool is_raw;
	v__ast__Language language;
	v__token__Position pos;
};



struct v__ast__StructInit {
	v__token__Position pos;
	v__token__Position name_pos;
	bool is_short;
	bool unresolved;
	Array_v__ast__Comment pre_comments;
	v__ast__Type typ;
	v__ast__Expr update_expr;
	v__ast__Type update_expr_type;
	Array_v__ast__Comment update_expr_comments;
	bool has_update_expr;
	Array_v__ast__StructInitField fields;
	Array_v__ast__StructInitEmbed embeds;
};



struct v__ast__TypeNode {
	v__ast__Type typ;
	v__token__Position pos;
};



struct v__ast__TypeOf {
	v__ast__Expr expr;
	v__token__Position pos;
	v__ast__Type expr_type;
};



struct v__ast__UnsafeExpr {
	v__ast__Expr expr;
	v__token__Position pos;
};



struct v__ast__AsmStmt {
	v__pref__Arch arch;
	bool is_basic;
	bool is_volatile;
	bool is_goto;
	Array_v__ast__AsmClobbered clobbered;
	v__token__Position pos;
	Array_v__ast__AsmTemplate templates;
	v__ast__Scope* scope;
	Array_v__ast__AsmIO output;
	Array_v__ast__AsmIO input;
	Array_string global_labels;
	Array_string local_labels;
};



struct v__ast__AssertStmt {
	v__token__Position pos;
	v__ast__Expr expr;
	bool is_used;
};



struct v__ast__AssignStmt {
	v__token__Kind op;
	v__token__Position pos;
	Array_v__ast__Comment comments;
	Array_v__ast__Comment end_comments;
	Array_v__ast__Expr right;
	Array_v__ast__Expr left;
	Array_v__ast__Type left_types;
	Array_v__ast__Type right_types;
	bool is_static;
	bool is_volatile;
	bool is_simple;
	bool has_cross_var;
};



struct v__ast__Block {
	Array_v__ast__Stmt stmts;
	bool is_unsafe;
	v__token__Position pos;
};



struct v__ast__BranchStmt {
	v__token__Kind kind;
	string label;
	v__token__Position pos;
};



struct v__ast__ComptimeFor {
	string val_var;
	Array_v__ast__Stmt stmts;
	v__ast__ComptimeForKind kind;
	v__token__Position pos;
	v__token__Position typ_pos;
	v__ast__Type typ;
};



struct v__ast__ConstDecl {
	bool is_pub;
	v__token__Position pos;
	Array_v__ast__Attr attrs;
	Array_v__ast__ConstField fields;
	Array_v__ast__Comment end_comments;
	bool is_block;
};



struct v__ast__DeferStmt {
	Array_v__ast__Stmt stmts;
	v__token__Position pos;
	Array_v__ast__Ident defer_vars;
	string ifdef;
	int idx_in_fn;
};



struct v__ast__EmptyStmt {
	v__token__Position pos;
};



struct v__ast__EnumDecl {
	string name;
	bool is_pub;
	bool is_flag;
	bool is_multi_allowed;
	Array_v__ast__Comment comments;
	Array_v__ast__EnumField fields;
	Array_v__ast__Attr attrs;
	v__token__Position pos;
};



struct v__ast__ExprStmt {
	v__ast__Expr expr;
	v__token__Position pos;
	Array_v__ast__Comment comments;
	bool is_expr;
	v__ast__Type typ;
};



struct v__ast__ForCStmt {
	v__ast__Stmt init;
	bool has_init;
	v__ast__Expr cond;
	bool has_cond;
	v__ast__Stmt inc;
	bool has_inc;
	bool is_multi;
	Array_v__ast__Stmt stmts;
	v__token__Position pos;
	string label;
	v__ast__Scope* scope;
};



struct v__ast__ForInStmt {
	string key_var;
	string val_var;
	v__ast__Expr cond;
	bool is_range;
	v__ast__Expr high;
	Array_v__ast__Stmt stmts;
	v__token__Position pos;
	bool val_is_mut;
	v__ast__Type key_type;
	v__ast__Type val_type;
	v__ast__Type cond_type;
	v__ast__Type high_type;
	v__ast__Kind kind;
	string label;
	v__ast__Scope* scope;
};



struct v__ast__ForStmt {
	v__ast__Expr cond;
	Array_v__ast__Stmt stmts;
	bool is_inf;
	v__token__Position pos;
	string label;
	v__ast__Scope* scope;
};



struct v__ast__GlobalDecl {
	string mod;
	v__token__Position pos;
	bool is_block;
	Array_v__ast__Attr attrs;
	Array_v__ast__GlobalField fields;
	Array_v__ast__Comment end_comments;
};



struct v__ast__GotoLabel {
	string name;
	v__token__Position pos;
};



struct v__ast__GotoStmt {
	string name;
	v__token__Position pos;
};



struct v__ast__HashStmt {
	string mod;
	v__token__Position pos;
	string source_file;
	string val;
	string kind;
	string main;
	string msg;
	Array_v__ast__Expr ct_conds;
};



struct v__ast__Import {
	string mod;
	string alias;
	v__token__Position pos;
	v__token__Position mod_pos;
	v__token__Position alias_pos;
	v__token__Position syms_pos;
	Array_v__ast__ImportSymbol syms;
	Array_v__ast__Comment comments;
	Array_v__ast__Comment next_comments;
};



struct v__ast__InterfaceDecl {
	string name;
	v__ast__Type typ;
	v__token__Position name_pos;
	v__ast__Language language;
	Array_string field_names;
	bool is_pub;
	int mut_pos;
	v__token__Position pos;
	Array_v__ast__Comment pre_comments;
	Array_v__ast__Type generic_types;
	Array_v__ast__Attr attrs;
	Array_v__ast__FnDecl methods;
	Array_v__ast__StructField fields;
	Array_v__ast__InterfaceEmbedding ifaces;
	bool are_ifaces_expanded;
};



struct v__ast__Module {
	string name;
	string short_name;
	Array_v__ast__Attr attrs;
	v__token__Position pos;
	v__token__Position name_pos;
	bool is_skipped;
};



struct v__ast__Return {
	v__token__Position pos;
	Array_v__ast__Comment comments;
	Array_v__ast__Expr exprs;
	Array_v__ast__Type types;
};



struct v__ast__SqlStmt {
	v__token__Position pos;
	v__ast__Expr db_expr;
	Array_v__ast__SqlStmtLine lines;
};



struct v__ast__StructDecl {
	v__token__Position pos;
	string name;
	Array_v__ast__Type generic_types;
	bool is_pub;
	int mut_pos;
	int pub_pos;
	int pub_mut_pos;
	int global_pos;
	int module_pos;
	v__ast__Language language;
	bool is_union;
	Array_v__ast__Attr attrs;
	Array_v__ast__Comment end_comments;
	Array_v__ast__Embed embeds;
	Array_v__ast__StructField fields;
};



struct v__ast__ConstField {
	string mod;
	string name;
	v__ast__Expr expr;
	bool is_pub;
	bool is_markused;
	v__token__Position pos;
	v__ast__Type typ;
	Array_v__ast__Comment comments;
	v__ast__ComptTimeConstValue comptime_expr_value;
};



struct v__ast__GlobalField {
	string name;
	bool has_expr;
	v__token__Position pos;
	v__token__Position typ_pos;
	bool is_markused;
	v__ast__Expr expr;
	v__ast__Type typ;
	Array_v__ast__Comment comments;
};



struct v__ast__Var {
	string name;
	v__ast__Expr expr;
	v__ast__ShareType share;
	bool is_mut;
	bool is_autofree_tmp;
	bool is_arg;
	bool is_auto_deref;
	bool is_inherited;
	v__ast__Type typ;
	v__ast__Type orig_type;
	Array_v__ast__Type smartcasts;
	v__token__Position pos;
	bool is_used;
	bool is_changed;
	bool is_or;
	bool is_tmp;
	bool is_auto_heap;
	bool is_stack_obj;
};



struct v__ast__CallArg {
	bool is_mut;
	v__ast__ShareType share;
	Array_v__ast__Comment comments;
	v__ast__Expr expr;
	v__ast__Type typ;
	bool is_tmp_autofree;
	v__token__Position pos;
};



struct v__ast__EnumField {
	string name;
	v__token__Position pos;
	Array_v__ast__Comment comments;
	Array_v__ast__Comment next_comments;
	bool has_expr;
	v__ast__Expr expr;
};



struct v__ast__IfBranch {
	v__ast__Expr cond;
	v__token__Position pos;
	v__token__Position body_pos;
	Array_v__ast__Comment comments;
	bool pkg_exist;
	Array_v__ast__Stmt stmts;
	v__ast__Scope* scope;
};



struct v__ast__MatchBranch {
	Array_Array_v__ast__Comment ecmnts;
	v__token__Position pos;
	bool is_else;
	Array_v__ast__Comment post_comments;
	v__token__Position branch_pos;
	Array_v__ast__Stmt stmts;
	Array_v__ast__Expr exprs;
	v__ast__Scope* scope;
};



struct v__ast__Param {
	v__token__Position pos;
	string name;
	bool is_mut;
	bool is_auto_rec;
	v__token__Position type_pos;
	bool is_hidden;
	v__ast__Type typ;
};



struct v__ast__StructField {
	v__token__Position pos;
	v__token__Position type_pos;
	Array_v__ast__Comment comments;
	bool has_default_expr;
	Array_v__ast__Attr attrs;
	bool is_pub;
	string default_val;
	bool is_mut;
	bool is_global;
	bool is_volatile;
	v__ast__Expr default_expr;
	v__ast__Type default_expr_typ;
	string name;
	v__ast__Type typ;
};



struct v__ast__StructInitField {
	v__token__Position pos;
	v__token__Position name_pos;
	Array_v__ast__Comment comments;
	Array_v__ast__Comment next_comments;
	v__ast__Expr expr;
	string name;
	v__ast__Type typ;
	v__ast__Type expected_type;
	v__ast__Type parent_type;
};



struct v__ast__Attr {
	string name;
	bool has_arg;
	string arg;
	v__ast__AttrKind kind;
	v__ast__Expr ct_expr;
	bool ct_opt;
	v__token__Position pos;
	bool ct_evaled;
	bool ct_skip;
};



struct v__ast__Embed {
	v__ast__Type typ;
	v__token__Position pos;
	Array_v__ast__Comment comments;
};



struct v__ast__InterfaceEmbedding {
	string name;
	v__ast__Type typ;
	v__token__Position pos;
	Array_v__ast__Comment comments;
};



struct v__ast__StructInitEmbed {
	v__ast__Expr expr;
	v__token__Position pos;
	Array_v__ast__Comment comments;
	Array_v__ast__Comment next_comments;
	string name;
	v__ast__Type typ;
	v__ast__Type expected_type;
};



struct v__ast__ImportSymbol {
	v__token__Position pos;
	string name;
};



struct v__ast__ScopeStructField {
	v__ast__Type struct_type;
	string name;
	v__token__Position pos;
	v__ast__Type typ;
	Array_v__ast__Type smartcasts;
	v__ast__Type orig_type;
};



struct v__ast__AsmClobbered {
	v__ast__AsmRegister reg;
	Array_v__ast__Comment comments;
};



struct v__ast__AsmTemplate {
	string name;
	bool is_label;
	bool is_directive;
	Array_v__ast__AsmArg args;
	Array_v__ast__Comment comments;
	v__token__Position pos;
};



struct v__ast__AsmIO {
	string alias;
	string constraint;
	v__ast__Expr expr;
	Array_v__ast__Comment comments;
	v__ast__Type typ;
	v__token__Position pos;
};



struct v__ast__AsmAddressing {
	int scale;
	v__ast__AddressingMode mode;
	v__token__Position pos;
	string segment;
	v__ast__AsmArg displacement;
	v__ast__AsmArg base;
	v__ast__AsmArg index;
};



struct v__ast__AsmAlias {
	v__token__Position pos;
	string name;
};



struct v__ast__AsmDisp {
	string val;
	v__token__Position pos;
};



struct v__ast__Fn {
	bool is_variadic;
	v__ast__Language language;
	bool is_pub;
	bool is_ctor_new;
	bool is_deprecated;
	bool is_noreturn;
	bool is_unsafe;
	bool is_placeholder;
	bool is_main;
	bool is_test;
	bool is_keep_alive;
	bool is_method;
	bool no_body;
	string mod;
	string file;
	v__ast__Language file_mode;
	v__token__Position pos;
	v__token__Position return_type_pos;
	v__ast__Type return_type;
	v__ast__Type receiver_type;
	string name;
	Array_v__ast__Param params;
	voidptr source_fn;
	int usages;
	Array_string generic_names;
	Array_v__ast__Attr attrs;
	bool is_conditional;
	int ctdefine_idx;
};



struct v__parser__Parser {
	v__pref__Preferences* pref;
	string file_base;
	string file_name;
	string file_name_dir;
	string unique_prefix;
	v__ast__Language file_backend_mode;
	v__scanner__Scanner* scanner;
	v__scanner__CommentsMode comments_mode;
	v__token__Token tok;
	v__token__Token prev_tok;
	v__token__Token peek_tok;
	v__ast__Table* table;
	v__ast__Language language;
	v__ast__Language fn_language;
	int expr_level;
	bool inside_vlib_file;
	bool inside_test_file;
	bool inside_if;
	bool inside_if_expr;
	bool inside_ct_if_expr;
	bool inside_or_expr;
	bool inside_for;
	bool inside_fn;
	bool inside_unsafe_fn;
	bool inside_str_interp;
	bool inside_array_lit;
	bool inside_in_array;
	bool inside_match;
	bool inside_select;
	bool inside_match_case;
	bool inside_match_body;
	bool inside_unsafe;
	bool inside_sum_type;
	bool inside_asm_template;
	bool inside_asm;
	bool inside_defer;
	bool inside_generic_params;
	bool inside_receiver_param;
	bool or_is_handled;
	bool builtin_mod;
	string mod;
	bool is_manualfree;
	bool has_globals;
	bool is_generated;
	Array_v__ast__Attr attrs;
	string expr_mod;
	v__ast__Scope* scope;
	Map_string_string imports;
	Array_v__ast__Import ast_imports;
	Array_string used_imports;
	Array_string auto_imports;
	Map_string_string imported_symbols;
	bool is_amp;
	bool returns;
	bool is_stmt_ident;
	bool expecting_type;
	Array_v__errors__Error errors;
	Array_v__errors__Warning warnings;
	Array_v__errors__Notice notices;
	Array_v__vet__Error vet_errors;
	string cur_fn_name;
	Array_string label_names;
	bool name_error;
	int n_asm;
	Array_string global_labels;
	bool comptime_if_cond;
	Array_v__ast__Ident defer_vars;
	bool should_abort;
	string codegen_text;
};



struct v__parser__ReceiverParsingInfo {
	string name;
	v__token__Position pos;
	v__ast__Type typ;
	v__token__Position type_pos;
	bool is_mut;
	v__ast__Language language;
};



struct v__vet__Error {
	v__vet__ErrorKind kind;
	string message;
	string details;
	string file_path;
	v__token__Position pos;
	v__vet__FixKind fix;
	v__vet__ErrorType typ;
};



struct v__callgraph__Mapper {
	int pos;
	v__pref__Preferences* pref;
	v__ast__Table* table;
	v__ast__File* file;
	v__ast__Node* node;
	v__ast__FnDecl* fn_decl;
	string caller_name;
	string dot_caller_name;
	bool is_caller_used;
	v__dotgraph__DotGraph dg;
};



struct v__pkgconfig__PkgConfig {
	v__pkgconfig__Options options;
	string name;
	string modname;
	string url;
	string version;
	string description;
	Array_string libs;
	Array_string libs_private;
	Array_string cflags;
	Array_string paths;
	Map_string_string vars;
	Array_string requires;
	Array_string requires_private;
	Array_string conflicts;
};



struct sync__Channel {
	byte* ringbuf;
	byte* statusbuf;
	u32 objsize;
	sync__Semaphore writesem;
	sync__Semaphore readsem;
	sync__Semaphore writesem_im;
	sync__Semaphore readsem_im;
	atomic_uintptr_t write_adr;
	atomic_uintptr_t read_adr;
	atomic_uintptr_t adr_read;
	atomic_uintptr_t adr_written;
	u32 write_free;
	u32 read_avail;
	u32 buf_elem_write_idx;
	u32 buf_elem_read_idx;
	sync__Subscription* write_subscriber;
	sync__Subscription* read_subscriber;
	u16 write_sub_mtx;
	u16 read_sub_mtx;
	u16 closed;
	u32 cap;
};



struct sync__ManyTimes {
	sync__RwMutex m;
	u64 times;
	u64 count;
};



struct sync__Once {
	sync__RwMutex m;
	u64 count;
};



struct sync__WaitGroup {
	u32 task_count;
	u32 wait_count;
	sync__Semaphore sem;
};



struct semver__Comparator {
	semver__Version ver;
	semver__Operator op;
};



struct SymbolInfoContainer {
	SymbolInfo syminfo;
	Array_fixed_char_254 f_name_rest;
};



struct v__ast__File {
	int nr_lines;
	int nr_bytes;
	v__ast__Module mod;
	v__ast__Scope* global_scope;
	bool is_test;
	bool is_generated;
	string path;
	string path_base;
	v__ast__Scope* scope;
	Array_v__ast__Stmt stmts;
	Array_v__ast__Import imports;
	Array_string auto_imports;
	Array_v__ast__EmbeddedFile embedded_files;
	Map_string_string imported_symbols;
	Array_v__errors__Error errors;
	Array_v__errors__Warning warnings;
	Array_v__errors__Notice notices;
	Array_v__ast__FnDecl_ptr generic_fns;
	Array_string global_labels;
};



struct v__ast__FnDecl {
	string name;
	string mod;
	bool is_deprecated;
	bool is_pub;
	bool is_variadic;
	bool is_anon;
	bool is_noreturn;
	bool is_manualfree;
	bool is_main;
	bool is_test;
	bool is_conditional;
	bool is_exported;
	bool is_keep_alive;
	bool is_unsafe;
	bool is_markused;
	v__ast__StructField receiver;
	v__token__Position receiver_pos;
	bool is_method;
	v__token__Position method_type_pos;
	int method_idx;
	bool rec_mut;
	v__ast__ShareType rec_share;
	v__ast__Language language;
	v__ast__Language file_mode;
	bool no_body;
	bool is_builtin;
	v__token__Position body_pos;
	string file;
	Array_string generic_names;
	bool is_direct_arr;
	Array_v__ast__Attr attrs;
	int ctdefine_idx;
	Array_v__ast__Param params;
	Array_v__ast__Stmt stmts;
	Array_v__ast__DeferStmt defer_stmts;
	v__ast__Type return_type;
	v__token__Position return_type_pos;
	bool has_return;
	bool should_be_skipped;
	int ninstances;
	bool has_await;
	Array_v__ast__Comment comments;
	Array_v__ast__Comment next_comments;
	v__ast__File* source_file;
	v__ast__Scope* scope;
	Array_string label_names;
	v__token__Position pos;
};



struct v__ast__CallExpr {
	v__token__Position pos;
	v__token__Position name_pos;
	string mod;
	string name;
	bool is_method;
	bool is_field;
	bool is_keep_alive;
	bool is_noreturn;
	bool is_ctor_new;
	Array_v__ast__CallArg args;
	Array_v__ast__Type expected_arg_types;
	v__ast__Language language;
	v__ast__OrExpr or_block;
	v__ast__Expr left;
	v__ast__Type left_type;
	v__ast__Type receiver_type;
	v__ast__Type return_type;
	bool should_be_skipped;
	Array_v__ast__Type concrete_types;
	v__token__Position concrete_list_pos;
	bool free_receiver;
	v__ast__Scope* scope;
	Array_v__ast__Type from_embed_types;
	Array_v__ast__Comment comments;
};



struct v__ast__IndexExpr {
	v__token__Position pos;
	v__ast__Expr index;
	v__ast__OrExpr or_expr;
	v__ast__Expr left;
	v__ast__Type left_type;
	bool is_setter;
	bool is_map;
	bool is_array;
	bool is_farray;
	bool is_option;
	bool is_direct;
	bool is_gated;
};



struct v__ast__InfixExpr {
	v__token__Kind op;
	v__token__Position pos;
	bool is_stmt;
	v__ast__Expr left;
	v__ast__Expr right;
	v__ast__Type left_type;
	v__ast__Type right_type;
	string auto_locked;
	v__ast__OrExpr or_block;
	bool ct_left_value_evaled;
	v__ast__ComptTimeConstValue ct_left_value;
	bool ct_right_value_evaled;
	v__ast__ComptTimeConstValue ct_right_value;
};



struct v__ast__PrefixExpr {
	v__token__Kind op;
	v__token__Position pos;
	v__ast__Type right_type;
	v__ast__Expr right;
	v__ast__OrExpr or_block;
	bool is_option;
};



struct v__ast__SqlExpr {
	v__ast__Type typ;
	bool is_count;
	v__ast__Expr db_expr;
	bool has_where;
	bool has_offset;
	v__ast__Expr offset_expr;
	bool has_order;
	v__ast__Expr order_expr;
	bool has_desc;
	bool is_array;
	v__token__Position pos;
	bool has_limit;
	v__ast__Expr limit_expr;
	v__ast__Expr where_expr;
	v__ast__TypeNode table_expr;
	Array_v__ast__StructField fields;
	Map_int_v__ast__SqlExpr sub_structs;
};



struct v__ast__SelectBranch {
	v__ast__Stmt stmt;
	Array_v__ast__Stmt stmts;
	v__token__Position pos;
	v__ast__Comment comment;
	bool is_else;
	bool is_timeout;
	Array_v__ast__Comment post_comments;
};



struct v__ast__SqlStmtLine {
	v__ast__SqlStmtKind kind;
	v__token__Position pos;
	v__ast__Expr where_expr;
	Array_v__ast__Expr update_exprs;
	string object_var_name;
	Array_string updated_columns;
	v__ast__TypeNode table_expr;
	Array_v__ast__StructField fields;
	Map_int_v__ast__SqlStmtLine sub_structs;
};



struct v__ast__FnType {
	bool is_anon;
	bool has_decl;
	v__ast__Fn func;
};



struct v__gen__c__Gen {
	v__pref__Preferences* pref;
	v__ast__Type field_data_type;
	string module_built;
	bool timers_should_print;
	v__ast__Table* table;
	strings__Builder out;
	strings__Builder cheaders;
	strings__Builder includes;
	strings__Builder typedefs;
	strings__Builder enum_typedefs;
	strings__Builder definitions;
	strings__Builder type_definitions;
	strings__Builder hotcode_definitions;
	strings__Builder channel_definitions;
	strings__Builder comptime_definitions;
	Map_string_strings__Builder global_inits;
	strings__Builder global_init;
	Map_string_strings__Builder inits;
	strings__Builder init;
	strings__Builder cleanup;
	Map_string_strings__Builder cleanups;
	strings__Builder gowrappers;
	strings__Builder stringliterals;
	strings__Builder auto_str_funcs;
	strings__Builder pcs_declarations;
	strings__Builder embedded_data;
	strings__Builder shared_types;
	strings__Builder shared_functions;
	strings__Builder options;
	strings__Builder json_forward_decls;
	strings__Builder sql_buf;
	v__ast__File* file;
	u64 unique_file_path_hash;
	v__ast__FnDecl* fn_decl;
	string last_fn_c_name;
	int tmp_count;
	int tmp_count_af;
	int tmp_count_declarations;
	int global_tmp_count;
	bool discard_or_result;
	bool is_assign_lhs;
	bool is_void_expr_stmt;
	bool is_arraymap_set;
	bool is_amp;
	bool is_sql;
	bool is_shared;
	bool is_vlines_enabled;
	bool is_autofree;
	bool is_builtin_mod;
	bool is_json_fn;
	bool is_js_call;
	bool is_fn_index_call;
	string vlines_path;
	Map_string_string optionals;
	__shared__Array_string* done_optionals;
	Map_string_string chan_pop_optionals;
	Map_string_string chan_push_optionals;
	string mtxs;
	Map_string_v__ast__Stmt_ptr labeled_loops;
	v__ast__Stmt* inner_loop;
	Map_int_string shareds;
	int inside_ternary;
	bool inside_map_postfix;
	bool inside_map_infix;
	bool inside_map_index;
	bool inside_opt_data;
	bool inside_if_optional;
	bool inside_match_optional;
	bool inside_vweb_tmpl;
	bool inside_return;
	bool inside_or_block;
	bool inside_call;
	bool inside_for_c_stmt;
	int inside_cast_in_heap;
	bool inside_const;
	bool inside_lambda;
	int loop_depth;
	Map_string_string ternary_names;
	Map_string_Array_string ternary_level_names;
	int arraymap_set_pos;
	Array_int stmt_path_pos;
	bool skip_stmt_pos;
	bool right_is_opt;
	int indent;
	bool empty_line;
	v__token__Kind assign_op;
	Array_v__ast__DeferStmt defer_stmts;
	string defer_ifdef;
	string defer_profile_code;
	Array_string defer_vars;
	Array_v__gen__c__StrType str_types;
	Array_v__gen__c__StrType generated_str_fns;
	__shared__Array_string* threaded_fns;
	__shared__Array_string* waiter_fns;
	Array_v__ast__Type needed_equality_fns;
	Array_v__ast__Type generated_eq_fns;
	__shared__Array_string* array_sort_fn;
	Array_v__ast__Type array_contains_types;
	Array_v__ast__Type array_index_types;
	Array_string auto_fn_definitions;
	Array_v__gen__c__SumtypeCastingFn sumtype_casting_fns;
	Array_string anon_fn_definitions;
	Map_int_bool sumtype_definitions;
	Array_v__ast__Type json_types;
	Array_v__gen__c__ProfileCounterMeta pcs;
	Array_string hotcode_fn_names;
	Array_v__ast__EmbeddedFile embedded_files;
	int sql_i;
	string sql_stmt_name;
	string sql_bind_name;
	Array_string sql_idents;
	Array_v__ast__Type sql_idents_types;
	v__ast__Type sql_left_type;
	string sql_table_name;
	string sql_fkey;
	string sql_parent_id;
	v__gen__c__SqlExprSide sql_side;
	Array_string strs_to_free0;
	string comptime_for_method;
	string comptime_for_field_var;
	v__ast__StructField comptime_for_field_value;
	v__ast__Type comptime_for_field_type;
	Map_string_v__ast__Type comptime_var_type_map;
	bool prevent_sum_type_unwrapping_once;
	int aggregate_type_idx;
	int branch_parent_pos;
	string returned_var_name;
	string infix_left_var_name;
	string called_fn_name;
	v__util__Timers* timers;
	bool force_main_console;
	Map_string_string as_cast_type_names;
	Map_string_string obf_table;
	__shared__Map_string_bool* referenced_fns;
	int nr_closures;
	v__ast__Type expected_cast_type;
	bool anon_fn;
	bool tests_inited;
	bool has_main;
	v__ast__Module cur_mod;
	Array_v__ast__Type cur_concrete_types;
	v__ast__FnDecl* cur_fn;
	v__ast__LockExpr cur_lock;
};



struct sync__pool__PoolProcessor {
	voidptr thread_cb;
	int njobs;
	Array_voidptr items;
	Array_voidptr results;
	u32 ntask;
	sync__WaitGroup waitgroup;
	voidptr shared_context;
	Array_voidptr thread_contexts;
};



struct v__checker__Checker {
	v__pref__Preferences* pref;
	v__ast__Table* table;
	v__ast__File* file;
	int nr_errors;
	int nr_warnings;
	int nr_notices;
	Array_v__errors__Error errors;
	Array_v__errors__Warning warnings;
	Array_v__errors__Notice notices;
	Array_int error_lines;
	v__ast__Type expected_type;
	v__ast__Type expected_or_type;
	string mod;
	string const_decl;
	Array_string const_deps;
	Array_string const_names;
	Array_string global_names;
	Array_string locked_names;
	Array_string rlocked_names;
	int in_for_count;
	bool should_abort;
	bool returns;
	bool scope_returns;
	bool is_builtin_mod;
	bool is_generated;
	bool inside_unsafe;
	bool inside_const;
	bool inside_anon_fn;
	bool inside_ref_lit;
	bool inside_defer;
	bool inside_fn_arg;
	bool inside_ct_attr;
	bool skip_flags;
	int fn_level;
	Array_v__ast__Expr ct_cond_stack;
	int stmt_level;
	Array_v__ast__File files;
	int expr_level;
	v__ast__TypeSymbol cur_orm_ts;
	Array_string error_details;
	string vmod_file_content;
	string loop_label;
	Array_v__ast__Type vweb_gen_types;
	v__util__Timers* timers;
	v__ast__Type comptime_fields_default_type;
	Map_string_v__ast__Type comptime_fields_type;
	v__ast__Scope* fn_scope;
	v__ast__FnDecl main_fn_decl_node;
	int match_exhaustive_cutoff_limit;
	bool is_last_stmt;
	bool prevent_sum_type_unwrapping_once;
	bool using_new_err_struct;
	bool need_recheck_generic_fns;
	bool inside_sql;
	bool inside_selector_expr;
	bool inside_println_arg;
	bool inside_decl_rhs;
	bool inside_if_guard;
};



struct v__builder__FunctionRedefinition {
	string fpath;
	int fline;
	string fheader;
	v__ast__FnDecl f;
};



struct v__ast__AnonFn {
	v__ast__FnDecl decl;
	Array_v__ast__Param inherited_vars;
	v__ast__Type typ;
	bool has_gen;
};



struct v__ast__ComptimeCall {
	v__token__Position pos;
	bool has_parens;
	string method_name;
	v__token__Position method_pos;
	v__ast__Scope* scope;
	v__ast__Expr left;
	string args_var;
	bool is_vweb;
	v__ast__File vweb_tmpl;
	bool is_embed;
	bool is_env;
	v__token__Position env_pos;
	bool is_pkgconfig;
	v__ast__Type left_type;
	v__ast__Type result_type;
	string env_value;
	Array_v__ast__CallArg args;
	v__ast__EmbeddedFile embed_file;
};



struct v__ast__GoExpr {
	v__token__Position pos;
	v__ast__CallExpr call_expr;
	bool is_expr;
};



// BEGIN_multi_return_structs
struct multi_return_u32_u32 {
	u32 arg0;
	u32 arg1;
};

struct multi_return_u32_u32_u32 {
	u32 arg0;
	u32 arg1;
	u32 arg2;
};

struct multi_return_int_strconv__PrepNumber {
	int arg0;
	strconv__PrepNumber arg1;
};

struct multi_return_u64_int {
	u64 arg0;
	int arg1;
};

struct multi_return_strconv__Dec32_bool {
	strconv__Dec32 arg0;
	bool arg1;
};

struct multi_return_strconv__Dec64_bool {
	strconv__Dec64 arg0;
	bool arg1;
};

struct multi_return_string_int {
	string arg0;
	int arg1;
};

struct multi_return_int_bool {
	int arg0;
	bool arg1;
};

struct multi_return_int_int {
	int arg0;
	int arg1;
};

struct multi_return_ref_v__pref__Preferences_string {
	v__pref__Preferences* arg0;
	string arg1;
};

struct multi_return_string_string {
	string arg0;
	string arg1;
};

struct multi_return_u64_u64 {
	u64 arg0;
	u64 arg1;
};

struct multi_return_f64_int {
	f64 arg0;
	int arg1;
};

struct multi_return_int_int_int {
	int arg0;
	int arg1;
	int arg2;
};

struct multi_return_int_int_int_int_i64_bool {
	int arg0;
	int arg1;
	int arg2;
	int arg3;
	i64 arg4;
	bool arg5;
};

struct multi_return_Array_string_int {
	Array_string arg0;
	int arg1;
};

struct multi_return_Array_string_v__vmod__ModFileAndFolder {
	Array_string arg0;
	v__vmod__ModFileAndFolder arg1;
};

struct multi_return_string_bool {
	string arg0;
	bool arg1;
};

struct multi_return_v__ast__Fn_Array_v__ast__Type {
	v__ast__Fn arg0;
	Array_v__ast__Type arg1;
};

struct multi_return_v__ast__StructField_Array_v__ast__Type {
	v__ast__StructField arg0;
	Array_v__ast__Type arg1;
};

struct multi_return_ref_v__ast__TypeSymbol_int {
	v__ast__TypeSymbol* arg0;
	int arg1;
};

struct multi_return_bool_bool_int {
	bool arg0;
	bool arg1;
	int arg2;
};

struct multi_return_string_v__token__Position {
	string arg0;
	v__token__Position arg1;
};

struct multi_return_bool_int_int {
	bool arg0;
	int arg1;
	int arg2;
};

struct multi_return_Array_v__ast__Param_bool_bool {
	Array_v__ast__Param arg0;
	bool arg1;
	bool arg2;
};

struct multi_return_Array_v__ast__Expr_Array_v__ast__Comment {
	Array_v__ast__Expr arg0;
	Array_v__ast__Comment arg1;
};

struct multi_return_ref_v__ast__File_Array_v__vet__Error {
	v__ast__File* arg0;
	Array_v__vet__Error arg1;
};

struct multi_return_Array_v__ast__Type_Array_string {
	Array_v__ast__Type arg0;
	Array_string arg1;
};

struct multi_return_Map_string_v__ast__FnDecl_Map_string_v__ast__ConstField_Map_string_v__ast__GlobalField {
	Map_string_v__ast__FnDecl arg0;
	Map_string_v__ast__ConstField arg1;
	Map_string_v__ast__GlobalField arg2;
};

struct multi_return_bool_Array_string {
	bool arg0;
	Array_string arg1;
};

struct multi_return_Array_string_Array_string_Array_string {
	Array_string arg0;
	Array_string arg1;
	Array_string arg2;
};

struct multi_return_string_string_string_string {
	string arg0;
	string arg1;
	string arg2;
	string arg3;
};

struct multi_return_int_string_string_string {
	int arg0;
	string arg1;
	string arg2;
	string arg3;
};

struct multi_return_Array_string_Array_string_Array_bool {
	Array_string arg0;
	Array_string arg1;
	Array_bool arg2;
};

struct multi_return_u64_string {
	u64 arg0;
	string arg1;
};

struct multi_return_int_literal_int_literal {
	int_literal arg0;
	int_literal arg1;
};

// END_multi_return_structs


typedef struct thread_arg_sync__pool__process_in_thread {
	sync__pool__PoolProcessor* arg1;
	int arg2;
} thread_arg_sync__pool__process_in_thread;
u32 sync__pool__process_in_thread_thread_wrapper(thread_arg_sync__pool__process_in_thread *arg);
void v__ast__TypeSymbol_free(v__ast__TypeSymbol* it); // auto
void Array_v__ast__Fn_free(Array_v__ast__Fn* it); // auto
void v__ast__Fn_free(v__ast__Fn* it); // auto
void Array_v__ast__Param_free(Array_v__ast__Param* it); // auto
void v__ast__Param_free(v__ast__Param* it); // auto
void Array_v__ast__Attr_free(Array_v__ast__Attr* it); // auto
void v__ast__Attr_free(v__ast__Attr* it); // auto
static string time__FormatTime_str(time__FormatTime it); // auto
static string time__FormatDate_str(time__FormatDate it); // auto
static string v__pref__Backend_str(v__pref__Backend it); // auto
static string v__ast__AttrKind_str(v__ast__AttrKind it); // auto
static string Array_v__ast__Expr_str(Array_v__ast__Expr a); // auto
static string indent_Array_v__ast__Expr_str(Array_v__ast__Expr a, int indent_count); // auto
static string v__ast__CallExpr_str(v__ast__CallExpr it); // auto
static string indent_v__ast__CallExpr_str(v__ast__CallExpr it, int indent_count); // auto
static string v__ast__TypeInfo_str(v__ast__TypeInfo x); // auto
static string indent_v__ast__TypeInfo_str(v__ast__TypeInfo x, int indent_count); // auto
static string v__ast__Fn_str(v__ast__Fn it); // auto
static string indent_v__ast__Fn_str(v__ast__Fn it, int indent_count); // auto
static string v__ast__Language_str(v__ast__Language it); // auto
static string v__ast__IdentKind_str(v__ast__IdentKind it); // auto
static string Array_v__ast__Attr_str(Array_v__ast__Attr a); // auto
static string indent_Array_v__ast__Attr_str(Array_v__ast__Attr a, int indent_count); // auto
static string v__token__Position_str(v__token__Position it); // auto
static string indent_v__token__Position_str(v__token__Position it, int indent_count); // auto
static string v__pref__Arch_str(v__pref__Arch it); // auto
static string v__gen__c__SqlType_str(v__gen__c__SqlType it); // auto
static string v__errors__Reporter_str(v__errors__Reporter it); // auto
static string Array_v__cflag__CFlag_str(Array_v__cflag__CFlag a); // auto
static string indent_Array_v__cflag__CFlag_str(Array_v__cflag__CFlag a, int indent_count); // auto
static string Array_v__ast__CallArg_str(Array_v__ast__CallArg a); // auto
static string indent_Array_v__ast__CallArg_str(Array_v__ast__CallArg a, int indent_count); // auto
static string Array_v__ast__Type_str(Array_v__ast__Type a); // auto
static string indent_Array_v__ast__Type_str(Array_v__ast__Type a, int indent_count); // auto
static string v__ast__OrExpr_str(v__ast__OrExpr it); // auto
static string indent_v__ast__OrExpr_str(v__ast__OrExpr it, int indent_count); // auto
static string Array_v__ast__Comment_str(Array_v__ast__Comment a); // auto
static string indent_Array_v__ast__Comment_str(Array_v__ast__Comment a, int indent_count); // auto
static string v__ast__Aggregate_str(v__ast__Aggregate it); // auto
static string indent_v__ast__Aggregate_str(v__ast__Aggregate it, int indent_count); // auto
static string v__ast__Alias_str(v__ast__Alias it); // auto
static string indent_v__ast__Alias_str(v__ast__Alias it, int indent_count); // auto
static string v__ast__Array_str(v__ast__Array it); // auto
static string indent_v__ast__Array_str(v__ast__Array it, int indent_count); // auto
static string v__ast__ArrayFixed_str(v__ast__ArrayFixed it); // auto
static string indent_v__ast__ArrayFixed_str(v__ast__ArrayFixed it, int indent_count); // auto
static string v__ast__Chan_str(v__ast__Chan it); // auto
static string indent_v__ast__Chan_str(v__ast__Chan it, int indent_count); // auto
static string v__ast__Enum_str(v__ast__Enum it); // auto
static string indent_v__ast__Enum_str(v__ast__Enum it, int indent_count); // auto
static string v__ast__FnType_str(v__ast__FnType it); // auto
static string indent_v__ast__FnType_str(v__ast__FnType it, int indent_count); // auto
static string v__ast__GenericInst_str(v__ast__GenericInst it); // auto
static string indent_v__ast__GenericInst_str(v__ast__GenericInst it, int indent_count); // auto
static string v__ast__Interface_str(v__ast__Interface it); // auto
static string indent_v__ast__Interface_str(v__ast__Interface it, int indent_count); // auto
static string v__ast__Map_str(v__ast__Map it); // auto
static string indent_v__ast__Map_str(v__ast__Map it, int indent_count); // auto
static string v__ast__MultiReturn_str(v__ast__MultiReturn it); // auto
static string indent_v__ast__MultiReturn_str(v__ast__MultiReturn it, int indent_count); // auto
static string v__ast__Struct_str(v__ast__Struct it); // auto
static string indent_v__ast__Struct_str(v__ast__Struct it, int indent_count); // auto
static string v__ast__SumType_str(v__ast__SumType it); // auto
static string indent_v__ast__SumType_str(v__ast__SumType it, int indent_count); // auto
static string v__ast__Thread_str(v__ast__Thread it); // auto
static string indent_v__ast__Thread_str(v__ast__Thread it, int indent_count); // auto
static string Array_v__ast__Param_str(Array_v__ast__Param a); // auto
static string indent_Array_v__ast__Param_str(Array_v__ast__Param a, int indent_count); // auto
static string Array_v__ast__Stmt_str(Array_v__ast__Stmt a); // auto
static string indent_Array_v__ast__Stmt_str(Array_v__ast__Stmt a, int indent_count); // auto
static string v__ast__OrKind_str(v__ast__OrKind it); // auto
static string v__ast__Comment_str(v__ast__Comment it); // auto
static string indent_v__ast__Comment_str(v__ast__Comment it, int indent_count); // auto
static string Array_v__ast__StructField_str(Array_v__ast__StructField a); // auto
static string indent_Array_v__ast__StructField_str(Array_v__ast__StructField a, int indent_count); // auto
static string Array_v__ast__Fn_str(Array_v__ast__Fn a); // auto
static string indent_Array_v__ast__Fn_str(Array_v__ast__Fn a, int indent_count); // auto
static string Map_int_Array_v__ast__Type_str(Map_int_Array_v__ast__Type m); // auto
static string indent_Map_int_Array_v__ast__Type_str(Map_int_Array_v__ast__Type m, int indent_count); // auto
static string v__ast__Param_str(v__ast__Param it); // auto
static string indent_v__ast__Param_str(v__ast__Param it, int indent_count); // auto
static string v__ast__StructField_str(v__ast__StructField it); // auto
static string indent_v__ast__StructField_str(v__ast__StructField it, int indent_count); // auto
static bool Array_string_contains(Array_string a, string v); // auto
static bool Array_v__token__Kind_contains(Array_v__token__Kind a, v__token__Kind v); // auto
static bool Array_byte_contains(Array_byte a, byte v); // auto
static bool Array_Array_v__ast__Type_contains(Array_Array_v__ast__Type a, Array_v__ast__Type v); // auto
static bool Array_v__ast__Type_contains(Array_v__ast__Type a, v__ast__Type v); // auto
static bool Array_int_contains(Array_int a, int v); // auto
static bool Array_i64_contains(Array_i64 a, i64 v); // auto
static bool Array_v__gen__c__StrType_contains(Array_v__gen__c__StrType a, v__gen__c__StrType v); // auto
static bool Array_v__gen__c__SumtypeCastingFn_contains(Array_v__gen__c__SumtypeCastingFn a, v__gen__c__SumtypeCastingFn v); // auto
static bool Array_v__ast__EmbeddedFile_contains(Array_v__ast__EmbeddedFile a, v__ast__EmbeddedFile v); // auto
static int Array_string_index(Array_string a, string v); // auto
static bool time__Duration_alias_eq(time__Duration a, time__Duration b); // auto
static bool v__ast__Type_alias_eq(v__ast__Type a, v__ast__Type b); // auto
static bool Array_string_arr_eq(Array_string a, Array_string b); // auto
static bool Map_string_string_map_eq(Map_string_string a, Map_string_string b); // auto
static bool Array_v__ast__Type_arr_eq(Array_v__ast__Type a, Array_v__ast__Type b); // auto
static bool v__gen__c__StrType_struct_eq(v__gen__c__StrType a, v__gen__c__StrType b); // auto
static bool v__gen__c__SumtypeCastingFn_struct_eq(v__gen__c__SumtypeCastingFn a, v__gen__c__SumtypeCastingFn b); // auto
static bool v__ast__EmbeddedFile_struct_eq(v__ast__EmbeddedFile a, v__ast__EmbeddedFile b); // auto
static bool Array_byte_arr_eq(Array_byte a, Array_byte b); // auto

// V shared types:
struct __shared__Array_string {
	sync__RwMutex mtx;
	Array_string val;
};
struct __shared__Map_string_bool {
	sync__RwMutex mtx;
	Map_string_bool val;
};

// V Option_xxx definitions:
struct Option_int {
	byte state;
	IError err;
	byte data[sizeof(int)];
};

struct Option_u64 {
	byte state;
	IError err;
	byte data[sizeof(u64)];
};

struct Option_i64 {
	byte state;
	IError err;
	byte data[sizeof(i64)];
};

struct Option_byte {
	byte state;
	IError err;
	byte data[sizeof(byte)];
};

struct Option_voidptr {
	byte state;
	IError err;
	byte data[sizeof(voidptr)];
};

struct Option_time__Time {
	byte state;
	IError err;
	byte data[sizeof(time__Time)];
};

struct Option_multi_return_int_int_int {
	byte state;
	IError err;
	byte data[sizeof(multi_return_int_int_int)];
};

struct Option_multi_return_int_int_int_int_i64_bool {
	byte state;
	IError err;
	byte data[sizeof(multi_return_int_int_int_int_i64_bool)];
};

struct Option_string {
	byte state;
	IError err;
	byte data[sizeof(string)];
};

struct Option_bool {
	byte state;
	IError err;
	byte data[sizeof(bool)];
};

struct Option_f64 {
	byte state;
	IError err;
	byte data[sizeof(f64)];
};

struct Option_void {
	byte state;
	IError err;
	byte data[sizeof(byte)];
};

struct Option_flag__Flag {
	byte state;
	IError err;
	byte data[sizeof(flag__Flag)];
};

struct Option_Array_string {
	byte state;
	IError err;
	byte data[sizeof(Array_string)];
};

struct Option_semver__Range {
	byte state;
	IError err;
	byte data[sizeof(semver__Range)];
};

struct Option_semver__Version {
	byte state;
	IError err;
	byte data[sizeof(semver__Version)];
};

struct Option_semver__ComparatorSet {
	byte state;
	IError err;
	byte data[sizeof(semver__ComparatorSet)];
};

struct Option_semver__Comparator {
	byte state;
	IError err;
	byte data[sizeof(semver__Comparator)];
};

struct Option_os__File {
	byte state;
	IError err;
	byte data[sizeof(os__File)];
};

struct Option_FILE_ptr {
	byte state;
	IError err;
	byte data[sizeof(FILE*)];
};

struct Option_Array_byte {
	byte state;
	IError err;
	byte data[sizeof(Array_byte)];
};

struct Option_os__SignalHandler {
	byte state;
	IError err;
	byte data[sizeof(os__SignalHandler)];
};

struct Option_term__Coord {
	byte state;
	IError err;
	byte data[sizeof(term__Coord)];
};

struct Option_v__vmod__Manifest {
	byte state;
	IError err;
	byte data[sizeof(v__vmod__Manifest)];
};

struct Option_multi_return_Array_string_int {
	byte state;
	IError err;
	byte data[sizeof(multi_return_Array_string_int)];
};

struct Option_v__pkgconfig__PkgConfig_ptr {
	byte state;
	IError err;
	byte data[sizeof(v__pkgconfig__PkgConfig*)];
};

struct Option_v__pkgconfig__Main_ptr {
	byte state;
	IError err;
	byte data[sizeof(v__pkgconfig__Main*)];
};

struct Option_v__pref__OS {
	byte state;
	IError err;
	byte data[sizeof(v__pref__OS)];
};

struct Option_v__pref__Arch {
	byte state;
	IError err;
	byte data[sizeof(v__pref__Arch)];
};

struct Option_v__pref__Backend {
	byte state;
	IError err;
	byte data[sizeof(v__pref__Backend)];
};

struct Option_time__StopWatch {
	byte state;
	IError err;
	byte data[sizeof(time__StopWatch)];
};

struct Option_v__ast__Ident {
	byte state;
	IError err;
	byte data[sizeof(v__ast__Ident)];
};

struct Option_i8 {
	byte state;
	IError err;
	byte data[sizeof(i8)];
};

struct Option_i16 {
	byte state;
	IError err;
	byte data[sizeof(i16)];
};

struct Option_u16 {
	byte state;
	IError err;
	byte data[sizeof(u16)];
};

struct Option_u32 {
	byte state;
	IError err;
	byte data[sizeof(u32)];
};

struct Option_f32 {
	byte state;
	IError err;
	byte data[sizeof(f32)];
};

struct Option_v__ast__ComptTimeConstValue {
	byte state;
	IError err;
	byte data[sizeof(v__ast__ComptTimeConstValue)];
};

struct Option_v__ast__ScopeObject {
	byte state;
	IError err;
	byte data[sizeof(v__ast__ScopeObject)];
};

struct Option_v__ast__ScopeStructField {
	byte state;
	IError err;
	byte data[sizeof(v__ast__ScopeStructField)];
};

struct Option_v__ast__Var_ptr {
	byte state;
	IError err;
	byte data[sizeof(v__ast__Var*)];
};

struct Option_v__ast__GlobalField_ptr {
	byte state;
	IError err;
	byte data[sizeof(v__ast__GlobalField*)];
};

struct Option_v__ast__ConstField_ptr {
	byte state;
	IError err;
	byte data[sizeof(v__ast__ConstField*)];
};

struct Option_v__ast__Fn {
	byte state;
	IError err;
	byte data[sizeof(v__ast__Fn)];
};

struct Option_multi_return_v__ast__Fn_Array_v__ast__Type {
	byte state;
	IError err;
	byte data[sizeof(multi_return_v__ast__Fn_Array_v__ast__Type)];
};

struct Option_v__ast__StructField {
	byte state;
	IError err;
	byte data[sizeof(v__ast__StructField)];
};

struct Option_multi_return_v__ast__StructField_Array_v__ast__Type {
	byte state;
	IError err;
	byte data[sizeof(multi_return_v__ast__StructField_Array_v__ast__Type)];
};

struct Option_v__ast__TypeSymbol_ptr {
	byte state;
	IError err;
	byte data[sizeof(v__ast__TypeSymbol*)];
};

struct Option_Array_Array_v__ast__Type {
	byte state;
	IError err;
	byte data[sizeof(Array_Array_v__ast__Type)];
};

struct Option_v__ast__Type {
	byte state;
	IError err;
	byte data[sizeof(v__ast__Type)];
};

struct Option_v__ast__InterfaceDecl {
	byte state;
	IError err;
	byte data[sizeof(v__ast__InterfaceDecl)];
};

struct Option_v__ast__EnumDecl {
	byte state;
	IError err;
	byte data[sizeof(v__ast__EnumDecl)];
};

struct Option_v__ast__Expr {
	byte state;
	IError err;
	byte data[sizeof(v__ast__Expr)];
};

struct Option_v__ast__Param {
	byte state;
	IError err;
	byte data[sizeof(v__ast__Param)];
};

struct Option_Array_v__ast__Type {
	byte state;
	IError err;
	byte data[sizeof(Array_v__ast__Type)];
};

struct Option_v__ast__ConstField {
	byte state;
	IError err;
	byte data[sizeof(v__ast__ConstField)];
};

struct Option_v__ast__GlobalField {
	byte state;
	IError err;
	byte data[sizeof(v__ast__GlobalField)];
};

struct Option_v__ast__FnDecl {
	byte state;
	IError err;
	byte data[sizeof(v__ast__FnDecl)];
};

struct Option_v__ast__Stmt_ptr {
	byte state;
	IError err;
	byte data[sizeof(v__ast__Stmt*)];
};

struct Option_v__builder__MsvcResult {
	byte state;
	IError err;
	byte data[sizeof(v__builder__MsvcResult)];
};

struct Option_v__builder__WindowsKit {
	byte state;
	IError err;
	byte data[sizeof(v__builder__WindowsKit)];
};

struct Option_v__builder__VsInstallation {
	byte state;
	IError err;
	byte data[sizeof(v__builder__VsInstallation)];
};


// V json forward decls:

// V definitions:
static char * v_typeof_interface_IError(int sidx);
static char * v_typeof_interface_rand__PRNG(int sidx);
static char * v_typeof_interface_hash__Hasher(int sidx);
static char * v_typeof_interface_hash__Hash32er(int sidx);
static char * v_typeof_interface_hash__Hash64er(int sidx);
static char * v_typeof_interface_v__ast__walker__Visitor(int sidx);
// end of definitions #endif
strings__Builder strings__new_builder(int initial_size);
void strings__Builder_write_ptr(strings__Builder* b, byte* ptr, int len);
void strings__Builder_write_rune(strings__Builder* b, rune r);
void strings__Builder_write_runes(strings__Builder* b, Array_rune runes);
void strings__Builder_write_b(strings__Builder* b, byte data);
Option_int strings__Builder_write(strings__Builder* b, Array_byte data);
void strings__Builder_drain_builder(strings__Builder* b, strings__Builder* other, int other_new_cap);
byte strings__Builder_byte_at(strings__Builder* b, int n);
void strings__Builder_write_string(strings__Builder* b, string s);
void strings__Builder_go_back(strings__Builder* b, int n);
string strings__Builder_cut_last(strings__Builder* b, int n);
string strings__Builder_cut_to(strings__Builder* b, int pos);
void strings__Builder_go_back_to(strings__Builder* b, int pos);
void strings__Builder_writeln(strings__Builder* b, string s);
string strings__Builder_last_n(strings__Builder* b, int n);
string strings__Builder_after(strings__Builder* b, int n);
string strings__Builder_str(strings__Builder* b);
void strings__Builder_free(strings__Builder* b);
int strings__levenshtein_distance(string a, string b);
f32 strings__levenshtein_distance_percentage(string a, string b);
f32 strings__dice_coefficient(string s1, string s2);
string strings__repeat(byte c, int n);
string strings__repeat_string(string s, int n);
u32 _const_math__bits__de_bruijn32 = 125613361; // precomputed
Array_byte _const_math__bits__de_bruijn32tab; // inited later
u64 _const_math__bits__de_bruijn64 = 285870213051353865U; // precomputed
Array_byte _const_math__bits__de_bruijn64tab; // inited later
u64 _const_math__bits__m0 = 6148914691236517205U; // precomputed
u64 _const_math__bits__m1 = 3689348814741910323U; // precomputed
u64 _const_math__bits__m2 = 1085102592571150095U; // precomputed
u64 _const_math__bits__m3 = 71777214294589695U; // precomputed
u64 _const_math__bits__m4 = 281470681808895U; // precomputed
u32 _const_math__bits__max_u32 = 4294967295; // precomputed
u64 _const_math__bits__max_u64 = 18446744073709551615U; // precomputed
int math__bits__leading_zeros_8(byte x);
int math__bits__leading_zeros_16(u16 x);
int math__bits__leading_zeros_32(u32 x);
int math__bits__leading_zeros_64(u64 x);
int math__bits__trailing_zeros_8(byte x);
int math__bits__trailing_zeros_16(u16 x);
int math__bits__trailing_zeros_32(u32 x);
int math__bits__trailing_zeros_64(u64 x);
int math__bits__ones_count_8(byte x);
int math__bits__ones_count_16(u16 x);
int math__bits__ones_count_32(u32 x);
int math__bits__ones_count_64(u64 x);
byte math__bits__rotate_left_8(byte x, int k);
u16 math__bits__rotate_left_16(u16 x, int k);
u32 math__bits__rotate_left_32(u32 x, int k);
u64 math__bits__rotate_left_64(u64 x, int k);
byte math__bits__reverse_8(byte x);
u16 math__bits__reverse_16(u16 x);
u32 math__bits__reverse_32(u32 x);
u64 math__bits__reverse_64(u64 x);
u16 math__bits__reverse_bytes_16(u16 x);
u32 math__bits__reverse_bytes_32(u32 x);
u64 math__bits__reverse_bytes_64(u64 x);
int math__bits__len_8(byte x);
int math__bits__len_16(u16 x);
int math__bits__len_32(u32 x);
int math__bits__len_64(u64 x);
multi_return_u32_u32 math__bits__add_32(u32 x, u32 y, u32 carry);
multi_return_u64_u64 math__bits__add_64(u64 x, u64 y, u64 carry);
multi_return_u32_u32 math__bits__sub_32(u32 x, u32 y, u32 borrow);
multi_return_u64_u64 math__bits__sub_64(u64 x, u64 y, u64 borrow);
u64 _const_math__bits__two32 = 4294967296U; // precomputed
u64 _const_math__bits__mask32 = 4294967295U; // precomputed
string _const_math__bits__overflow_error; // a string literal, inited later
string _const_math__bits__divide_error; // a string literal, inited later
multi_return_u32_u32 math__bits__mul_32(u32 x, u32 y);
multi_return_u64_u64 math__bits__mul_64(u64 x, u64 y);
multi_return_u32_u32 math__bits__div_32(u32 hi, u32 lo, u32 y);
multi_return_u64_u64 math__bits__div_64(u64 hi, u64 lo, u64 y1);
u32 math__bits__rem_32(u32 hi, u32 lo, u32 y);
u64 math__bits__rem_64(u64 hi, u64 lo, u64 y);
multi_return_f64_int math__bits__normalize(f64 x);
Array_byte _const_math__bits__ntz_8_tab; // inited later
Array_byte _const_math__bits__pop_8_tab; // inited later
Array_byte _const_math__bits__rev_8_tab; // inited later
Array_byte _const_math__bits__len_8_tab; // inited later
VV_LOCAL_SYMBOL multi_return_u32_u32_u32 strconv__lsr96(u32 s2, u32 s1, u32 s0);
VV_LOCAL_SYMBOL multi_return_u32_u32_u32 strconv__lsl96(u32 s2, u32 s1, u32 s0);
VV_LOCAL_SYMBOL multi_return_u32_u32_u32 strconv__add96(u32 s2, u32 s1, u32 s0, u32 d2, u32 d1, u32 d0);
VV_LOCAL_SYMBOL multi_return_u32_u32_u32 strconv__sub96(u32 s2, u32 s1, u32 s0, u32 d2, u32 d1, u32 d0);
u32 _const_strconv__single_plus_zero = 0; // precomputed
u32 _const_strconv__single_minus_zero = 2147483648; // precomputed
u32 _const_strconv__single_plus_infinity = 2139095040; // precomputed
u32 _const_strconv__single_minus_infinity = 4286578688; // precomputed
#define _const_strconv__digits 18
u64 _const_strconv__double_plus_zero = 0U; // precomputed
u64 _const_strconv__double_minus_zero = 9223372036854775808U; // precomputed
u64 _const_strconv__double_plus_infinity = 9218868437227405312U; // precomputed
u64 _const_strconv__double_minus_infinity = 18442240474082181120U; // precomputed
#define _const_strconv__parser_ok 0
#define _const_strconv__parser_pzero 1
#define _const_strconv__parser_mzero 2
#define _const_strconv__parser_pinf 3
#define _const_strconv__parser_minf 4
rune _const_strconv__c_dpoint = '.'; // precomputed
rune _const_strconv__c_plus = '+'; // precomputed
rune _const_strconv__c_minus = '-'; // precomputed
rune _const_strconv__c_zero = '0'; // precomputed
rune _const_strconv__c_nine = '9'; // precomputed
u32 _const_strconv__c_ten = 10; // precomputed
VV_LOCAL_SYMBOL bool strconv__is_digit(byte x);
VV_LOCAL_SYMBOL bool strconv__is_space(byte x);
VV_LOCAL_SYMBOL bool strconv__is_exp(byte x);
VV_LOCAL_SYMBOL multi_return_int_strconv__PrepNumber strconv__parser(string s);
VV_LOCAL_SYMBOL u64 strconv__converter(strconv__PrepNumber* pn);
f64 strconv__atof64(string s);
f64 strconv__atof_quick(string s);
Array_u64 _const_strconv__pos_exp; // inited later
Array_u64 _const_strconv__neg_exp; // inited later
#define _const_strconv__int_size 32
u64 _const_strconv__max_u64 = 18446744073709551615U; // precomputed
byte strconv__byte_to_lower(byte c);
Option_u64 strconv__common_parse_uint(string s, int _base, int _bit_size, bool error_on_non_digit, bool error_on_high_digit);
multi_return_u64_int strconv__common_parse_uint2(string s, int _base, int _bit_size);
Option_u64 strconv__parse_uint(string s, int _base, int _bit_size);
Option_i64 strconv__common_parse_int(string _s, int base, int _bit_size, bool error_on_non_digit, bool error_on_high_digit);
Option_i64 strconv__parse_int(string _s, int base, int _bit_size);
Option_int strconv__atoi(string s);
VV_LOCAL_SYMBOL bool strconv__underscore_ok(string s);
Array_u32 _const_strconv__ten_pow_table_32; // inited later
u32 _const_strconv__mantbits32 = 23; // precomputed
u32 _const_strconv__expbits32 = 8; // precomputed
#define _const_strconv__bias32 127
#define _const_strconv__maxexp32 255
string strconv__Dec32_get_string_32(strconv__Dec32 d, bool neg, int i_n_digit, int i_pad_digit);
VV_LOCAL_SYMBOL multi_return_strconv__Dec32_bool strconv__f32_to_decimal_exact_int(u32 i_mant, u32 exp);
VV_LOCAL_SYMBOL strconv__Dec32 strconv__f32_to_decimal(u32 mant, u32 exp);
string strconv__f32_to_str(f32 f, int n_digit);
string strconv__f32_to_str_pad(f32 f, int n_digit);
VV_LOCAL_SYMBOL string strconv__Dec64_get_string_64(strconv__Dec64 d, bool neg, int i_n_digit, int i_pad_digit);
VV_LOCAL_SYMBOL multi_return_strconv__Dec64_bool strconv__f64_to_decimal_exact_int(u64 i_mant, u64 exp);
VV_LOCAL_SYMBOL strconv__Dec64 strconv__f64_to_decimal(u64 mant, u64 exp);
string strconv__f64_to_str(f64 f, int n_digit);
string strconv__f64_to_str_pad(f64 f, int n_digit);
Array_u64 _const_strconv__ten_pow_table_64; // inited later
u32 _const_strconv__mantbits64 = 52; // precomputed
u32 _const_strconv__expbits64 = 11; // precomputed
#define _const_strconv__bias64 1023
#define _const_strconv__maxexp64 2047
Array_f64 _const_strconv__dec_round; // inited later
string strconv__format_str(string s, strconv__BF_param p);
void strconv__format_str_sb(string s, strconv__BF_param p, strings__Builder* sb);
#define _const_strconv__max_size_f64_char 32
string _const_strconv__digit_pairs; // a string literal, inited later
void strconv__format_dec_sb(u64 d, strconv__BF_param p, strings__Builder* res);
string strconv__f64_to_str_lnd1(f64 f, int dec_digit);
string strconv__format_fl(f64 f, strconv__BF_param p);
string strconv__format_es(f64 f, strconv__BF_param p);
string strconv__remove_tail_zeros(string s);
string strconv__ftoa_64(f64 f);
string strconv__ftoa_long_64(f64 f);
string strconv__ftoa_32(f32 f);
string strconv__ftoa_long_32(f32 f);
string _const_strconv__base_digits; // a string literal, inited later
string strconv__format_int(i64 n, int radix);
string strconv__format_uint(u64 n, int radix);
#define _const_strconv__pow5_num_bits_32 61
#define _const_strconv__pow5_inv_num_bits_32 59
#define _const_strconv__pow5_num_bits_64 121
#define _const_strconv__pow5_inv_num_bits_64 122
Array_u64 _const_strconv__powers_of_10; // inited later
Array_u64 _const_strconv__pow5_split_32; // inited later
Array_u64 _const_strconv__pow5_inv_split_32; // inited later
Array_strconv__Uint128 _const_strconv__pow5_split_64; // inited later
Array_strconv__Uint128 _const_strconv__pow5_inv_split_64; // inited later
string strconv__f32_to_str_l(f32 f);
string strconv__f32_to_str_l_no_dot(f32 f);
string strconv__f64_to_str_l(f64 f);
string strconv__f64_to_str_l_no_dot(f64 f);
string strconv__fxx_to_str_l_parse(string s);
string strconv__fxx_to_str_l_parse_no_dot(string s);
VV_LOCAL_SYMBOL int strconv__bool_to_int(bool b);
VV_LOCAL_SYMBOL u32 strconv__bool_to_u32(bool b);
VV_LOCAL_SYMBOL u64 strconv__bool_to_u64(bool b);
VV_LOCAL_SYMBOL string strconv__get_string_special(bool neg, bool expZero, bool mantZero);
VV_LOCAL_SYMBOL u32 strconv__mul_shift_32(u32 m, u64 mul, int ishift);
VV_LOCAL_SYMBOL u32 strconv__mul_pow5_invdiv_pow2(u32 m, u32 q, int j);
VV_LOCAL_SYMBOL u32 strconv__mul_pow5_div_pow2(u32 m, u32 i, int j);
VV_LOCAL_SYMBOL u32 strconv__pow5_factor_32(u32 i_v);
VV_LOCAL_SYMBOL bool strconv__multiple_of_power_of_five_32(u32 v, u32 p);
VV_LOCAL_SYMBOL bool strconv__multiple_of_power_of_two_32(u32 v, u32 p);
VV_LOCAL_SYMBOL u32 strconv__log10_pow2(int e);
VV_LOCAL_SYMBOL u32 strconv__log10_pow5(int e);
VV_LOCAL_SYMBOL int strconv__pow5_bits(int e);
VV_LOCAL_SYMBOL u64 strconv__shift_right_128(strconv__Uint128 v, int shift);
VV_LOCAL_SYMBOL u64 strconv__mul_shift_64(u64 m, strconv__Uint128 mul, int shift);
VV_LOCAL_SYMBOL u32 strconv__pow5_factor_64(u64 v_i);
VV_LOCAL_SYMBOL bool strconv__multiple_of_power_of_five_64(u64 v, u32 p);
VV_LOCAL_SYMBOL bool strconv__multiple_of_power_of_two_64(u64 v, u32 p);
int strconv__dec_digits(u64 n);
void strconv__v_printf(string str, Array_voidptr pt);
string strconv__v_sprintf(string str, Array_voidptr pt);
VV_LOCAL_SYMBOL void strconv__v_sprintf_panic(int idx, int len);
VV_LOCAL_SYMBOL f64 strconv__fabs(f64 x);
string strconv__format_fl_old(f64 f, strconv__BF_param p);
string strconv__format_es_old(f64 f, strconv__BF_param p);
string strconv__remove_tail_zeros_old(string s);
string strconv__format_dec_old(u64 d, strconv__BF_param p);
VV_LOCAL_SYMBOL array __new_array(int mylen, int cap, int elm_size);
VV_LOCAL_SYMBOL array __new_array_with_default(int mylen, int cap, int elm_size, voidptr val);
VV_LOCAL_SYMBOL array __new_array_with_array_default(int mylen, int cap, int elm_size, array val);
VV_LOCAL_SYMBOL array __new_array_with_map_default(int mylen, int cap, int elm_size, map val);
VV_LOCAL_SYMBOL array new_array_from_c_array(int len, int cap, int elm_size, voidptr c_array);
VV_LOCAL_SYMBOL array new_array_from_c_array_no_alloc(int len, int cap, int elm_size, voidptr c_array);
VV_LOCAL_SYMBOL void array_ensure_cap(array* a, int required);
array array_repeat(array a, int count);
array array_repeat_to_depth(array a, int count, int depth);
void array_sort_with_compare(array* a, int (*callback)(voidptr , voidptr ));
void array_insert(array* a, int i, voidptr val);
void array_insert_many(array* a, int i, voidptr val, int size);
void array_prepend(array* a, voidptr val);
void array_prepend_many(array* a, voidptr val, int size);
void array_delete(array* a, int i);
void array_delete_many(array* a, int i, int size);
void array_clear(array* a);
void array_trim(array* a, int index);
VV_LOCAL_SYMBOL voidptr array_get_unsafe(array a, int i);
VV_LOCAL_SYMBOL voidptr array_get(array a, int i);
VV_LOCAL_SYMBOL voidptr array_get_with_check(array a, int i);
voidptr array_first(array a);
voidptr array_last(array a);
voidptr array_pop(array* a);
void array_delete_last(array* a);
VV_LOCAL_SYMBOL array array_slice(array a, int start, int _end);
VV_LOCAL_SYMBOL array array_slice_ni(array a, int _start, int _end);
VV_LOCAL_SYMBOL array array_slice2(array a, int start, int _end, bool end_max);
VV_LOCAL_SYMBOL array array_clone_static_to_depth(array a, int depth);
array array_clone(array* a);
array array_clone_to_depth(array* a, int depth);
VV_LOCAL_SYMBOL void array_set_unsafe(array* a, int i, voidptr val);
VV_LOCAL_SYMBOL void array_set(array* a, int i, voidptr val);
VV_LOCAL_SYMBOL void array_push(array* a, voidptr val);
void array_push_many(array* a3, voidptr val, int size);
void array_reverse_in_place(array* a);
array array_reverse(array a);
void array_free(array* a);
array array_filter(array a, bool (*predicate)(voidptr ));
bool array_any(array a, bool (*predicate)(voidptr ));
bool array_all(array a, bool (*predicate)(voidptr ));
array array_map(array a, voidptr (*callback)(voidptr ));
void array_sort(array* a, int (*callback)(voidptr , voidptr ));
bool array_contains(array a, voidptr val);
int array_index(array a, voidptr value);
void Array_string_free(Array_string* a);
string Array_string_str(Array_string a);
string Array_byte_hex(Array_byte b);
int copy(Array_byte dst, Array_byte src);
int Array_int_reduce(Array_int a, int (*iter)(int , int ), int accum_start);
void array_grow_cap(array* a, int amount);
void array_grow_len(array* a, int amount);
Array_voidptr array_pointers(array a);
Array_byte voidptr_vbytes(voidptr data, int len);
Array_byte byte_vbytes(byte* data, int len);
bool ArrayFlags_is_empty(ArrayFlags* e);
bool ArrayFlags_has(ArrayFlags* e, ArrayFlags flag);
bool ArrayFlags_all(ArrayFlags* e, ArrayFlags flag);
void ArrayFlags_set(ArrayFlags* e, ArrayFlags flag);
void ArrayFlags_clear(ArrayFlags* e, ArrayFlags flag);
void ArrayFlags_toggle(ArrayFlags* e, ArrayFlags flag);
VV_LOCAL_SYMBOL array __new_array_noscan(int mylen, int cap, int elm_size);
VV_LOCAL_SYMBOL void vhalt(void);
void _v_exit(int code);
VV_LOCAL_SYMBOL string vcommithash(void);
VV_LOCAL_SYMBOL void panic_debug(int line_no, string file, string mod, string fn_name, string s);
void panic_optional_not_set(string s);
void _v_panic(string s);
string c_error_number_str(int errnum);
void panic_error_number(string basestr, int errnum);
void eprintln(string s);
void eprint(string s);
void flush_stdout(void);
void flush_stderr(void);
void print(string s);
void println(string s);
VV_LOCAL_SYMBOL void _writeln_to_fd(int fd, string s);
VV_LOCAL_SYMBOL void _write_buf_to_fd(int fd, byte* buf, int buf_len);
i64  total_m = ((i64)(0)); // global
byte* _v_malloc(int n);
byte* malloc_noscan(int n);
byte* v_realloc(byte* b, int n);
byte* realloc_data(byte* old_data, int old_size, int new_size);
byte* vcalloc(int n);
byte* vcalloc_noscan(int n);
void _v_free(voidptr ptr);
voidptr memdup(voidptr src, int sz);
voidptr memdup_noscan(voidptr src, int sz);
VV_LOCAL_SYMBOL int v_fixed_index(int i, int len);
void print_backtrace(void);
bool isnil(voidptr v);
Array_VCastTypeIndexName  as_cast_type_indexes; // global
VV_LOCAL_SYMBOL voidptr __as_cast(voidptr obj, int obj_type, int expected_type);
void VAssertMetaInfo_free(VAssertMetaInfo* ami);
VV_LOCAL_SYMBOL void __print_assert_failure(VAssertMetaInfo* i);
VV_LOCAL_SYMBOL void v_segmentation_fault_handler(int signal);
void gc_check_leaks(void);
#define _const_symopt_undname 2
#define _const_symopt_deferred_loads 4
#define _const_symopt_no_cpp 8
#define _const_symopt_load_lines 16
#define _const_symopt_include_32bit_modules 8192
#define _const_symopt_allow_zero_address 16777216
#define _const_symopt_debug 2147483648
u32  g_original_codepage = ((u32)(0U)); // global
VV_LOCAL_SYMBOL void restore_codepage(void);
VV_LOCAL_SYMBOL int is_terminal(int fd);
VV_LOCAL_SYMBOL void builtin_init(void);
VV_LOCAL_SYMBOL bool print_backtrace_skipping_top_frames(int skipframes);
VV_LOCAL_SYMBOL bool print_backtrace_skipping_top_frames_msvc(int skipframes);
VV_LOCAL_SYMBOL bool print_backtrace_skipping_top_frames_mingw(int skipframes);
VV_LOCAL_SYMBOL bool print_backtrace_skipping_top_frames_tcc(int skipframes);
VV_LOCAL_SYMBOL void add_vectored_exception_handler(int (*handler)(ExceptionPointers* ));
VV_LOCAL_SYMBOL int __stdcall unhandled_exception_handler(ExceptionPointers* e);
VV_LOCAL_SYMBOL void add_unhandled_exception_handler(void);
VV_LOCAL_SYMBOL void break_if_debugger_attached(void);
string winapi_lasterr_str(void);
void panic_lasterr(string base);
int proc_pidpath(int , voidptr , int );
int vstrlen(byte* s);
int vstrlen_char(char* s);
voidptr vmemcpy(voidptr dest, const voidptr const_src, int n);
voidptr vmemmove(voidptr dest, const voidptr const_src, int n);
int vmemcmp(const voidptr const_s1, const voidptr const_s2, int n);
voidptr vmemset(voidptr s, int c, int n);
VV_LOCAL_SYMBOL void vqsort(voidptr base, usize nmemb, usize size, int (*sort_cb)(const voidptr const_a, const voidptr const_b));
void chan_close(chan ch);
ChanState chan_try_pop(chan ch, voidptr obj);
ChanState chan_try_push(chan ch, voidptr obj);
string f64_str(f64 x);
string f64_strg(f64 x);
string float_literal_str(float_literal d);
string f64_strsci(f64 x, int digit_num);
string f64_strlong(f64 x);
string f32_str(f32 x);
string f32_strg(f32 x);
string f32_strsci(f32 x, int digit_num);
string f32_strlong(f32 x);
f32 f32_abs(f32 a);
VV_LOCAL_SYMBOL f64 f64_abs(f64 a);
f32 f32_max(f32 a, f32 b);
f32 f32_min(f32 a, f32 b);
f64 f64_max(f64 a, f64 b);
VV_LOCAL_SYMBOL f64 f64_min(f64 a, f64 b);
bool f32_eq_epsilon(f32 a, f32 b);
bool f64_eq_epsilon(f64 a, f64 b);
VV_LOCAL_SYMBOL void float_test(void);
string ptr_str(voidptr ptr);
string isize_str(isize x);
string usize_str(usize x);
string char_str(char* cptr);
string _const_digit_pairs; // a string literal, inited later
VV_LOCAL_SYMBOL string int_str_l(int nn, int max);
string i8_str(i8 n);
string i16_str(i16 n);
string u16_str(u16 n);
string int_str(int n);
string u32_str(u32 nn);
string int_literal_str(int_literal n);
string i64_str(i64 nn);
string u64_str(u64 nn);
string bool_str(bool b);
VV_LOCAL_SYMBOL string u64_to_hex(u64 nn, byte len);
VV_LOCAL_SYMBOL string u64_to_hex_no_leading_zeros(u64 nn, byte len);
string byte_hex(byte nn);
string i8_hex(i8 nn);
string u16_hex(u16 nn);
string i16_hex(i16 nn);
string u32_hex(u32 nn);
string int_hex(int nn);
string int_hex2(int n);
string u64_hex(u64 nn);
string i64_hex(i64 nn);
string int_literal_hex(int_literal nn);
string voidptr_str(voidptr nn);
string byteptr_str(byteptr nn);
string charptr_str(charptr nn);
string byte_hex_full(byte nn);
string i8_hex_full(i8 nn);
string u16_hex_full(u16 nn);
string i16_hex_full(i16 nn);
string u32_hex_full(u32 nn);
string int_hex_full(int nn);
string i64_hex_full(i64 nn);
string voidptr_hex_full(voidptr nn);
string int_literal_hex_full(int_literal nn);
string u64_hex_full(u64 nn);
string byte_str(byte b);
string byte_ascii_str(byte b);
string byte_str_escaped(byte b);
bool byte_is_capital(byte c);
Array_byte Array_byte_clone(Array_byte b);
string Array_byte_bytestr(Array_byte b);
string byte_repeat(byte b, int count);
VV_LOCAL_SYMBOL bool fast_string_eq(string a, string b);
VV_LOCAL_SYMBOL u64 map_hash_string(voidptr pkey);
VV_LOCAL_SYMBOL u64 map_hash_int_1(voidptr pkey);
VV_LOCAL_SYMBOL u64 map_hash_int_2(voidptr pkey);
VV_LOCAL_SYMBOL u64 map_hash_int_4(voidptr pkey);
VV_LOCAL_SYMBOL u64 map_hash_int_8(voidptr pkey);
VV_LOCAL_SYMBOL void DenseArray_zeros_to_end(DenseArray* d);
#define _const_hashbits 24
#define _const_max_cached_hashbits 16
#define _const_init_log_capicity 5
#define _const_init_capicity 32
f64 _const_max_load_factor = 0.8; // precomputed
#define _const_init_even_index 30
#define _const_extra_metas_inc 4
u32 _const_hash_mask = 16777215; // precomputed
u32 _const_probe_inc = 16777216; // precomputed
VV_LOCAL_SYMBOL DenseArray new_dense_array(int key_bytes, int value_bytes);
VV_LOCAL_SYMBOL voidptr DenseArray_key(DenseArray* d, int i);
VV_LOCAL_SYMBOL voidptr DenseArray_value(DenseArray* d, int i);
VV_LOCAL_SYMBOL bool DenseArray_has_index(DenseArray* d, int i);
VV_LOCAL_SYMBOL int DenseArray_expand(DenseArray* d);
VV_LOCAL_SYMBOL bool map_eq_string(voidptr a, voidptr b);
VV_LOCAL_SYMBOL bool map_eq_int_1(voidptr a, voidptr b);
VV_LOCAL_SYMBOL bool map_eq_int_2(voidptr a, voidptr b);
VV_LOCAL_SYMBOL bool map_eq_int_4(voidptr a, voidptr b);
VV_LOCAL_SYMBOL bool map_eq_int_8(voidptr a, voidptr b);
VV_LOCAL_SYMBOL void map_clone_string(voidptr dest, voidptr pkey);
VV_LOCAL_SYMBOL void map_clone_int_1(voidptr dest, voidptr pkey);
VV_LOCAL_SYMBOL void map_clone_int_2(voidptr dest, voidptr pkey);
VV_LOCAL_SYMBOL void map_clone_int_4(voidptr dest, voidptr pkey);
VV_LOCAL_SYMBOL void map_clone_int_8(voidptr dest, voidptr pkey);
VV_LOCAL_SYMBOL void map_free_string(voidptr pkey);
VV_LOCAL_SYMBOL void map_free_nop(voidptr _d1);
VV_LOCAL_SYMBOL map new_map(int key_bytes, int value_bytes, u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr ));
VV_LOCAL_SYMBOL map new_map_init(u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr ), int n, int key_bytes, int value_bytes, voidptr keys, voidptr values);
map map_move(map* m);
VV_LOCAL_SYMBOL multi_return_u32_u32 map_key_to_index(map* m, voidptr pkey);
VV_LOCAL_SYMBOL multi_return_u32_u32 map_meta_less(map* m, u32 _index, u32 _metas);
VV_LOCAL_SYMBOL void map_meta_greater(map* m, u32 _index, u32 _metas, u32 kvi);
VV_LOCAL_SYMBOL void map_ensure_extra_metas(map* m, u32 probe_count);
VV_LOCAL_SYMBOL void map_set(map* m, voidptr key, voidptr value);
VV_LOCAL_SYMBOL void map_expand(map* m);
VV_LOCAL_SYMBOL void map_rehash(map* m);
VV_LOCAL_SYMBOL void map_cached_rehash(map* m, u32 old_cap);
VV_LOCAL_SYMBOL voidptr map_get_and_set(map* m, voidptr key, voidptr zero);
VV_LOCAL_SYMBOL voidptr map_get(map* m, voidptr key, voidptr zero);
VV_LOCAL_SYMBOL voidptr map_get_check(map* m, voidptr key);
VV_LOCAL_SYMBOL bool map_exists(map* m, voidptr key);
VV_LOCAL_SYMBOL void DenseArray_delete(DenseArray* d, int i);
void map_delete(map* m, voidptr key);
array map_keys(map* m);
VV_LOCAL_SYMBOL DenseArray DenseArray_clone(DenseArray* d);
map map_clone(map* m);
void map_free(map* m);
void IError_free(IError* ie);
string IError_str(IError err);
IError _const_none__; // inited later
VV_LOCAL_SYMBOL string None___str(None__ _d1);
IError _v_error(string message);
IError error_with_code(string message, int code);
VV_LOCAL_SYMBOL void opt_ok(voidptr data, Option* option, int size);
void Error_free(Error* e);
void None___free(None__* n);
string none_str(none _d2);
#define _const_prealloc_block_size 16777216
VMemoryBlock*  g_memory_block; // global
VV_LOCAL_SYMBOL VMemoryBlock* vmemory_block_new(VMemoryBlock* prev, int at_least);
VV_LOCAL_SYMBOL byte* vmemory_block_malloc(int n);
VV_LOCAL_SYMBOL void prealloc_vinit(void);
VV_LOCAL_SYMBOL void prealloc_vcleanup(void);
VV_LOCAL_SYMBOL byte* prealloc_malloc(int n);
VV_LOCAL_SYMBOL byte* prealloc_realloc(byte* old_data, int old_size, int new_size);
VV_LOCAL_SYMBOL byte* prealloc_calloc(int n);
string rune_str(rune c);
string Array_rune_string(Array_rune ra);
string rune_repeat(rune c, int count);
int rune_length_in_bytes(rune c);
#define _const_degree 6
#define _const_mid_index 5
#define _const_max_len 11
u32 _const_children_bytes; // inited later
VV_LOCAL_SYMBOL SortedMap new_sorted_map(int n, int value_bytes);
VV_LOCAL_SYMBOL SortedMap new_sorted_map_init(int n, int value_bytes, string* keys, voidptr values);
VV_LOCAL_SYMBOL mapnode* new_node(void);
VV_LOCAL_SYMBOL void SortedMap_set(SortedMap* m, string key, voidptr value);
VV_LOCAL_SYMBOL void mapnode_split_child(mapnode* n, int child_index, mapnode* y);
VV_LOCAL_SYMBOL bool SortedMap_get(SortedMap m, string key, voidptr out);
VV_LOCAL_SYMBOL bool SortedMap_exists(SortedMap m, string key);
VV_LOCAL_SYMBOL int mapnode_find_key(mapnode* n, string k);
VV_LOCAL_SYMBOL bool mapnode_remove_key(mapnode* n, string k);
VV_LOCAL_SYMBOL void mapnode_remove_from_leaf(mapnode* n, int idx);
VV_LOCAL_SYMBOL void mapnode_remove_from_non_leaf(mapnode* n, int idx);
VV_LOCAL_SYMBOL void mapnode_fill(mapnode* n, int idx);
VV_LOCAL_SYMBOL void mapnode_borrow_from_prev(mapnode* n, int idx);
VV_LOCAL_SYMBOL void mapnode_borrow_from_next(mapnode* n, int idx);
VV_LOCAL_SYMBOL void mapnode_merge(mapnode* n, int idx);
void SortedMap_delete(SortedMap* m, string key);
VV_LOCAL_SYMBOL int mapnode_subkeys(mapnode* n, Array_string* keys, int at);
Array_string SortedMap_keys(SortedMap* m);
VV_LOCAL_SYMBOL void mapnode_free(mapnode* n);
void SortedMap_free(SortedMap* m);
void SortedMap_print(SortedMap m);
Array_rune string_runes(string s);
string cstring_to_vstring(char* s);
string tos_clone(byte* s);
string tos(byte* s, int len);
string tos2(byte* s);
string tos3(char* s);
string tos4(byte* s);
string tos5(char* s);
string byte_vstring(byte* bp);
string byte_vstring_with_len(byte* bp, int len);
string char_vstring(char* cp);
string char_vstring_with_len(char* cp, int len);
string byte_vstring_literal(byte* bp);
string byte_vstring_literal_with_len(byte* bp, int len);
string char_vstring_literal(char* cp);
string char_vstring_literal_with_len(char* cp, int len);
VV_LOCAL_SYMBOL string string_clone_static(string a);
string string_clone(string a);
string string_replace_once(string s, string rep, string with);
string string_replace(string s, string rep, string with);
string string_replace_each(string s, Array_string vals);
VV_LOCAL_SYMBOL int compare_2018276881664952276_RepIndex_by_idx(RepIndex* a, RepIndex* b) {
	if (a->idx < b->idx) return -1;
	else return 1;
}

bool string_bool(string s);
int string_int(string s);
i64 string_i64(string s);
i8 string_i8(string s);
i16 string_i16(string s);
f32 string_f32(string s);
f64 string_f64(string s);
u8 string_byte(string s);
u16 string_u16(string s);
u32 string_u32(string s);
u64 string_u64(string s);
VV_LOCAL_SYMBOL bool string__eq(string s, string a);
int string_compare(string s, string a);
VV_LOCAL_SYMBOL bool string__lt(string s, string a);
VV_LOCAL_SYMBOL string string__plus(string s, string a);
Array_string string_split_any(string s, string delim);
Array_string string_split(string s, string delim);
Array_string string_split_nth(string s, string delim, int nth);
Array_string string_split_into_lines(string s);
VV_LOCAL_SYMBOL string string_substr2(string s, int start, int _end, bool end_max);
string string_substr(string s, int start, int end);
string string_substr_ni(string s, int _start, int _end);
VV_LOCAL_SYMBOL int string_index_(string s, string p);
Option_int string_index(string s, string p);
VV_LOCAL_SYMBOL int string_index_kmp(string s, string p);
int string_index_any(string s, string chars);
VV_LOCAL_SYMBOL int string_last_index_(string s, string p);
Option_int string_last_index(string s, string p);
int string_index_after(string s, string p, int start);
int string_index_byte(string s, byte c);
int string_last_index_byte(string s, byte c);
int string_count(string s, string substr);
bool string_contains(string s, string substr);
bool string_contains_any(string s, string chars);
bool string_contains_any_substr(string s, Array_string substrs);
bool string_starts_with(string s, string p);
bool string_ends_with(string s, string p);
string string_to_lower(string s);
bool string_is_lower(string s);
string string_to_upper(string s);
bool string_is_upper(string s);
string string_capitalize(string s);
bool string_is_capital(string s);
bool string_starts_with_capital(string s);
string string_title(string s);
bool string_is_title(string s);
string string_find_between(string s, string start, string end);
string string_trim_space(string s);
string string_trim(string s, string cutset);
string string_trim_left(string s, string cutset);
string string_trim_right(string s, string cutset);
string string_trim_string_left(string s, string str);
string string_trim_string_right(string s, string str);
string string_trim_prefix(string s, string str);
string string_trim_suffix(string s, string str);
int compare_strings(string* a, string* b);
VV_LOCAL_SYMBOL int compare_strings_by_len(string* a, string* b);
VV_LOCAL_SYMBOL int compare_lower_strings(string* a, string* b);
void Array_string_sort_ignore_case(Array_string* s);
void Array_string_sort_by_len(Array_string* s);
string string_str(string s);
VV_LOCAL_SYMBOL byte string_at(string s, int idx);
VV_LOCAL_SYMBOL Option_byte string_at_with_check(string s, int idx);
bool byte_is_space(byte c);
bool byte_is_digit(byte c);
bool byte_is_hex_digit(byte c);
bool byte_is_oct_digit(byte c);
bool byte_is_bin_digit(byte c);
bool byte_is_letter(byte c);
bool byte_is_alnum(byte c);
void string_free(string* s);
string string_before(string s, string sub);
string string_all_before(string s, string sub);
string string_all_before_last(string s, string sub);
string string_all_after(string s, string sub);
string string_all_after_last(string s, string sub);
string string_after(string s, string sub);
string string_after_char(string s, byte sub);
string Array_string_join(Array_string a, string sep);
string Array_string_join_lines(Array_string s);
string string_reverse(string s);
string string_limit(string s, int max);
int string_hash(string s);
Array_byte string_bytes(string s);
string string_repeat(string s, int count);
Array_string string_fields(string s);
string string_strip_margin(string s);
string string_strip_margin_custom(string s, byte del);
bool string_match_glob(string name, string pattern);
Array_byte byteptr_vbytes(byteptr data, int len);
string byteptr_vstring(byteptr bp);
string byteptr_vstring_with_len(byteptr bp, int len);
string charptr_vstring(charptr cp);
string charptr_vstring_with_len(charptr cp, int len);
string byteptr_vstring_literal(byteptr bp);
string byteptr_vstring_literal_with_len(byteptr bp, int len);
string charptr_vstring_literal(charptr cp);
string charptr_vstring_literal_with_len(charptr cp, int len);
string StrIntpType_str(StrIntpType x);
VV_LOCAL_SYMBOL f32 fabs32(f32 x);
VV_LOCAL_SYMBOL f64 fabs64(f64 x);
VV_LOCAL_SYMBOL u64 abs64(i64 x);
u64 get_str_intp_u64_format(StrIntpType fmt_type, int in_width, int in_precision, bool in_tail_zeros, bool in_sign, byte in_pad_ch, int in_base, bool in_upper_case);
u32 get_str_intp_u32_format(StrIntpType fmt_type, int in_width, int in_precision, bool in_tail_zeros, bool in_sign, byte in_pad_ch, int in_base, bool in_upper_case);
VV_LOCAL_SYMBOL void StrIntpData_process_str_intp_data(StrIntpData* data, strings__Builder* sb);
string str_intp(int data_len, voidptr in_data);
string _const_si_s_code; // a string literal, inited later
string _const_si_g32_code; // a string literal, inited later
string _const_si_g64_code; // a string literal, inited later
string str_intp_sq(string in_str);
string str_intp_rune(string in_str);
string str_intp_g32(string in_str);
string str_intp_g64(string in_str);
string str_intp_sub(string base_str, string in_str);
#define _const_cp_utf8 65001
u16* string_to_wide(string _str);
string string_from_wide(u16* _wstr);
string string_from_wide2(u16* _wstr, int len);
int utf8_getchar(void);
int utf8_char_len(byte b);
string utf32_to_str(u32 code);
string utf32_to_str_no_malloc(u32 code, byte* buf);
int string_utf32_code(string _rune);
VV_LOCAL_SYMBOL int utf8_len(byte c);
int utf8_str_len(string s);
int utf8_str_visible_length(string s);
#define _const_dl__version 1
string _const_dl__dl_ext; // inited later
string dl__get_shared_library_extension(void);
string dl__get_libname(string libname);
Option_voidptr dl__open_opt(string filename, int flags);
Option_voidptr dl__sym_opt(voidptr shared_object_handle, string symbol);
#define _const_dl__rtld_now 0
#define _const_dl__rtld_lazy 0
voidptr dl__open(string filename, int flags);
bool dl__close(voidptr handle);
voidptr dl__sym(voidptr handle, string symbol);
string dl__dlerror(void);
strings__textscanner__TextScanner strings__textscanner__new(string input);
void strings__textscanner__TextScanner_free(strings__textscanner__TextScanner* ss);
int strings__textscanner__TextScanner_remaining(strings__textscanner__TextScanner* ss);
int strings__textscanner__TextScanner_next(strings__textscanner__TextScanner* ss);
void strings__textscanner__TextScanner_skip(strings__textscanner__TextScanner* ss);
void strings__textscanner__TextScanner_skip_n(strings__textscanner__TextScanner* ss, int n);
int strings__textscanner__TextScanner_peek(strings__textscanner__TextScanner* ss);
int strings__textscanner__TextScanner_peek_n(strings__textscanner__TextScanner* ss, int n);
void strings__textscanner__TextScanner_back(strings__textscanner__TextScanner* ss);
void strings__textscanner__TextScanner_back_n(strings__textscanner__TextScanner* ss, int n);
int strings__textscanner__TextScanner_peek_back(strings__textscanner__TextScanner* ss);
int strings__textscanner__TextScanner_peek_back_n(strings__textscanner__TextScanner* ss, int n);
int strings__textscanner__TextScanner_current(strings__textscanner__TextScanner* ss);
void strings__textscanner__TextScanner_reset(strings__textscanner__TextScanner* ss);
void strings__textscanner__TextScanner_goto_end(strings__textscanner__TextScanner* ss);
Array_string os__cmdline__options(Array_string args, string param);
string os__cmdline__option(Array_string args, string param, string def);
Array_string os__cmdline__options_before(Array_string args, Array_string what);
Array_string os__cmdline__options_after(Array_string args, Array_string what);
Array_string os__cmdline__only_non_options(Array_string args);
Array_string os__cmdline__only_options(Array_string args);
int math__mathutil__min_T_int(int a, int b);
int math__mathutil__max_T_int(int a, int b);
#define _const_v__token__max_keyword_len 20
v__token__KeywordsMatcher v__token__new_keywords_matcher_T_v__token__Kind(Map_string_v__token__Kind kw_map);
VV_LOCAL_SYMBOL int compare_7621314236064146737_v__token__WIndex_by_word(v__token__WIndex* a, v__token__WIndex* b) {
	if (string__lt(a->word, b->word)) return -1;
	else return 1;
}

v__token__KeywordsMatcher v__token__new_keywords_matcher_T_int(Map_string_int kw_map);
VV_LOCAL_SYMBOL void v__token__KeywordsMatcher_add_word(v__token__KeywordsMatcher* km, string word, int kind);
int v__token__KeywordsMatcher_find(v__token__KeywordsMatcher* km, string word);
void v__token__Position_free(v__token__Position* p);
string v__token__Position_line_str(v__token__Position p);
v__token__Position v__token__Position_extend(v__token__Position pos, v__token__Position end);
v__token__Position v__token__Position_extend_with_last_line(v__token__Position pos, v__token__Position end, int last_line);
void v__token__Position_update_last_line(v__token__Position* pos, int last_line);
v__token__Position v__token__Token_position(v__token__Token* tok);
Array_v__token__Kind _const_v__token__assign_tokens; // inited later
int _const_v__token__nr_tokens; // inited later
Array_string _const_v__token__valid_at_tokens; // inited later
VV_LOCAL_SYMBOL Map_string_v__token__Kind v__token__build_keys(void);
VV_LOCAL_SYMBOL Array_string v__token__build_token_str(void);
Array_string _const_v__token__token_str; // inited later
Map_string_v__token__Kind _const_v__token__keywords; // inited later
v__token__KeywordsMatcher _const_v__token__matcher; // inited later
bool v__token__is_key(string key);
bool v__token__is_decl(v__token__Kind t);
bool v__token__Kind_is_assign(v__token__Kind t);
string v__token__Kind_str(v__token__Kind t);
string v__token__Token_str(v__token__Token t);
Array_v__token__Precedence v__token__build_precedences(void);
Array_v__token__Precedence _const_v__token__precedences; // inited later
int v__token__Token_precedence(v__token__Token tok);
bool v__token__Token_is_scalar(v__token__Token tok);
bool v__token__Token_is_unary(v__token__Token tok);
bool v__token__Kind_is_relational(v__token__Kind tok);
bool v__token__Kind_is_start_of_type(v__token__Kind k);
bool v__token__Kind_is_prefix(v__token__Kind kind);
bool v__token__Kind_is_infix(v__token__Kind kind);
i64 time__portable_timegm(struct tm* t);
int time__days_from_civil(int oy, int m, int d);
string time__Time_format(time__Time t);
string time__Time_format_ss(time__Time t);
string time__Time_format_ss_milli(time__Time t);
string time__Time_format_ss_micro(time__Time t);
string time__Time_hhmm(time__Time t);
string time__Time_hhmmss(time__Time t);
string time__Time_hhmm12(time__Time t);
string time__Time_ymmdd(time__Time t);
string time__Time_ddmmy(time__Time t);
string time__Time_md(time__Time t);
string time__Time_clean(time__Time t);
string time__Time_clean12(time__Time t);
string time__Time_get_fmt_time_str(time__Time t, time__FormatTime fmt_time);
string time__Time_get_fmt_date_str(time__Time t, time__FormatDelimiter fmt_dlmtr, time__FormatDate fmt_date);
string time__Time_get_fmt_str(time__Time t, time__FormatDelimiter fmt_dlmtr, time__FormatTime fmt_time, time__FormatDate fmt_date);
string time__Time_utc_string(time__Time t);
bool time__Time__eq(time__Time t1, time__Time t2);
bool time__Time__lt(time__Time t1, time__Time t2);
time__Duration time__Time__minus(time__Time lhs, time__Time rhs);
Option_time__Time time__parse_rfc3339(string s);
Option_time__Time time__parse(string s);
Option_time__Time time__parse_iso8601(string s);
Option_time__Time time__parse_rfc2822(string s);
VV_LOCAL_SYMBOL Option_multi_return_int_int_int time__parse_iso8601_date(string s);
VV_LOCAL_SYMBOL Option_multi_return_int_int_int_int_i64_bool time__parse_iso8601_time(string s);
VV_LOCAL_SYMBOL IError time__error_invalid_time(int code);
time__StopWatch time__new_stopwatch(time__StopWatchOptions opts);
void time__StopWatch_start(time__StopWatch* t);
void time__StopWatch_restart(time__StopWatch* t);
void time__StopWatch_stop(time__StopWatch* t);
void time__StopWatch_pause(time__StopWatch* t);
time__Duration time__StopWatch_elapsed(time__StopWatch t);
time__Time time__now(void);
time__Time time__utc(void);
time__Time time__new_time(time__Time t);
i64 time__ticks(void);
string time__Time_str(time__Time t);
VV_LOCAL_SYMBOL time__Time time__convert_ctime(struct tm t, int microsecond);
string _const_time__days_string; // a string literal, inited later
Array_int _const_time__month_days; // inited later
string _const_time__months_string; // a string literal, inited later
i64 _const_time__absolute_zero_year; // inited later
#define _const_time__seconds_per_minute 60
#define _const_time__seconds_per_hour 3600
#define _const_time__seconds_per_day 86400
#define _const_time__seconds_per_week 604800
#define _const_time__days_per_400_years 146097
#define _const_time__days_per_100_years 36524
#define _const_time__days_per_4_years 1461
Array_int _const_time__days_before; // inited later
Array_string _const_time__long_days; // inited later
string time__Time_smonth(time__Time t);
i64 time__Time_unix_time(time__Time t);
i64 time__Time_unix_time_milli(time__Time t);
time__Time time__Time_add(time__Time t, time__Duration d);
time__Time time__Time_add_seconds(time__Time t, int seconds);
time__Time time__Time_add_days(time__Time t, int days);
time__Duration time__since(time__Time t);
string time__Time_relative(time__Time t);
string time__Time_relative_short(time__Time t);
int time__day_of_week(int y, int m, int d);
int time__Time_day_of_week(time__Time t);
string time__Time_weekday_str(time__Time t);
string time__Time_long_weekday_str(time__Time t);
bool time__is_leap_year(int year);
Option_int time__days_in_month(int month, int year);
string time__Time_debug(time__Time t);
time__Duration _const_time__nanosecond; // inited later
time__Duration _const_time__microsecond; // inited later
time__Duration _const_time__millisecond; // inited later
time__Duration _const_time__second; // inited later
time__Duration _const_time__minute; // inited later
time__Duration _const_time__hour; // inited later
time__Duration _const_time__infinite; // inited later
i64 time__Duration_nanoseconds(time__Duration d);
i64 time__Duration_microseconds(time__Duration d);
i64 time__Duration_milliseconds(time__Duration d);
f64 time__Duration_seconds(time__Duration d);
f64 time__Duration_minutes(time__Duration d);
f64 time__Duration_hours(time__Duration d);
string time__Duration_str(time__Duration d);
int time__offset(void);
u64 _const_time__start_time; // inited later
u64 _const_time__freq_time; // inited later
i64 _const_time__start_local_time; // inited later
VV_LOCAL_SYMBOL i64 time__make_unix_time(struct tm t);
VV_LOCAL_SYMBOL u64 time__init_win_time_freq(void);
VV_LOCAL_SYMBOL u64 time__init_win_time_start(void);
u64 time__sys_mono_now(void);
VV_LOCAL_SYMBOL u64 time__vpc_now(void);
VV_LOCAL_SYMBOL i64 time__local_as_unix_time(void);
time__Time time__Time_local(time__Time t);
VV_LOCAL_SYMBOL time__Time time__win_now(void);
VV_LOCAL_SYMBOL time__Time time__win_utc(void);
i64 time__SystemTime_unix_time(time__SystemTime st);
time__Time time__darwin_now(void);
time__Time time__linux_now(void);
time__Time time__solaris_now(void);
time__Time time__darwin_utc(void);
time__Time time__linux_utc(void);
time__Time time__solaris_utc(void);
void time__sleep(time__Duration duration);
u32 time__Duration_sys_milliseconds(time__Duration d);
time__Time time__unix(i64 abs);
time__Time time__unix2(i64 abs, int microsecond);
VV_LOCAL_SYMBOL multi_return_int_int_int time__calculate_date_from_offset(i64 day_offset_);
VV_LOCAL_SYMBOL multi_return_int_int_int time__calculate_time_from_offset(i64 second_offset_);
void v__dotgraph__start_digraph(void);
VV_LOCAL_SYMBOL void anon_fn_40181cb3d9c4559e__82(void);
v__dotgraph__DotGraph* v__dotgraph__new(string name, string label, string color);
void v__dotgraph__DotGraph_writeln(v__dotgraph__DotGraph* d, string line);
void v__dotgraph__DotGraph_finish(v__dotgraph__DotGraph* d);
void v__dotgraph__DotGraph_new_node(v__dotgraph__DotGraph* d, string nlabel, v__dotgraph__NewNodeConfig cfg);
void v__dotgraph__DotGraph_new_edge(v__dotgraph__DotGraph* d, string source, string target, v__dotgraph__NewEdgeConfig cfg);
string v__dotgraph__node_name(string name, voidptr context);
u64 hash__wyhash_c(byte* key, u64 len, u64 seed);
u64 hash__wyhash64_c(u64 a, u64 b);
u64 hash__sum64_string(string key, u64 seed);
u64 hash__sum64(Array_byte key, u64 seed);
u64 _const_hash__wyp0 = 11562461410679940143U; // precomputed
u64 _const_hash__wyp1 = 16646288086500911323U; // precomputed
u64 _const_hash__wyp2 = 10285213230658275043U; // precomputed
u64 _const_hash__wyp3 = 6384245875588680899U; // precomputed
u64 _const_hash__wyp4 = 2129725606500045391U; // precomputed
VV_LOCAL_SYMBOL u64 hash__wyrotr(u64 v, u32 k);
u64 hash__wymum(u64 a, u64 b);
VV_LOCAL_SYMBOL u64 hash__wyr3(byte* p, u64 k);
VV_LOCAL_SYMBOL u64 hash__wyr4(byte* p);
VV_LOCAL_SYMBOL u64 hash__wyr8(byte* p);
u64 _const_hash__fnv1a__fnv64_prime = 1099511628211U; // precomputed
u64 _const_hash__fnv1a__fnv64_offset_basis = 14695981039346656037U; // precomputed
u32 _const_hash__fnv1a__fnv32_offset_basis = 2166136261; // precomputed
u32 _const_hash__fnv1a__fnv32_prime = 16777619; // precomputed
u32 hash__fnv1a__sum32_string(string data);
u32 hash__fnv1a__sum32(Array_byte data);
u32 hash__fnv1a__sum32_bytes(byte* data, int data_len);
u64 hash__fnv1a__sum64_string(string data);
u64 hash__fnv1a__sum64(Array_byte data);
u64 hash__fnv1a__sum64_bytes(byte* data, int data_len);
u64 _const_rand__constants__lower_mask = 4294967295U; // precomputed
#define _const_rand__constants__max_u32 4294967295
u64 _const_rand__constants__max_u64 = 18446744073709551615U; // precomputed
f32 _const_rand__constants__max_u32_as_f32; // inited later
f64 _const_rand__constants__max_u64_as_f64; // inited later
u32 _const_rand__constants__u31_mask = 2147483647; // precomputed
u64 _const_rand__constants__u63_mask = 9223372036854775807U; // precomputed
VV_LOCAL_SYMBOL void flag__Flag_free(flag__Flag* f);
string flag__Flag_str(flag__Flag f);
string Array_flag__Flag_str(Array_flag__Flag af);
VV_LOCAL_SYMBOL void flag__FlagParser_free(flag__FlagParser* f);
string _const_flag__space; // a string literal, inited later
string _const_flag__underline; // a string literal, inited later
#define _const_flag__max_args_number 4048
flag__FlagParser* flag__new_flag_parser(Array_string args);
void flag__FlagParser_usage_example(flag__FlagParser* fs, string example);
void flag__FlagParser_footer(flag__FlagParser* fs, string footer);
void flag__FlagParser_application(flag__FlagParser* fs, string name);
void flag__FlagParser_version(flag__FlagParser* fs, string vers);
void flag__FlagParser_description(flag__FlagParser* fs, string desc);
void flag__FlagParser_skip_executable(flag__FlagParser* fs);
void flag__FlagParser_allow_unknown_args(flag__FlagParser* fs);
VV_LOCAL_SYMBOL void flag__FlagParser_add_flag(flag__FlagParser* fs, string name, byte abbr, string usage, string desc);
VV_LOCAL_SYMBOL Array_string flag__FlagParser_parse_value(flag__FlagParser* fs, string longhand, byte shorthand);
VV_LOCAL_SYMBOL Option_string flag__FlagParser_parse_bool_value(flag__FlagParser* fs, string longhand, byte shorthand);
Option_bool flag__FlagParser_bool_opt(flag__FlagParser* fs, string name, byte abbr, string usage);
bool flag__FlagParser_bool(flag__FlagParser* fs, string name, byte abbr, bool bdefault, string usage);
Array_int flag__FlagParser_int_multi(flag__FlagParser* fs, string name, byte abbr, string usage);
Option_int flag__FlagParser_int_opt(flag__FlagParser* fs, string name, byte abbr, string usage);
int flag__FlagParser_int(flag__FlagParser* fs, string name, byte abbr, int idefault, string usage);
Array_f64 flag__FlagParser_float_multi(flag__FlagParser* fs, string name, byte abbr, string usage);
Option_f64 flag__FlagParser_float_opt(flag__FlagParser* fs, string name, byte abbr, string usage);
f64 flag__FlagParser_float(flag__FlagParser* fs, string name, byte abbr, f64 fdefault, string usage);
Array_string flag__FlagParser_string_multi(flag__FlagParser* fs, string name, byte abbr, string usage);
Option_string flag__FlagParser_string_opt(flag__FlagParser* fs, string name, byte abbr, string usage);
string flag__FlagParser_string(flag__FlagParser* fs, string name, byte abbr, string sdefault, string usage);
Option_void flag__FlagParser_limit_free_args_to_at_least(flag__FlagParser* fs, int n);
Option_void flag__FlagParser_limit_free_args_to_exactly(flag__FlagParser* fs, int n);
Option_void flag__FlagParser_limit_free_args(flag__FlagParser* fs, int min, int max);
void flag__FlagParser_arguments_description(flag__FlagParser* fs, string description);
string flag__FlagParser_usage(flag__FlagParser* fs);
VV_LOCAL_SYMBOL Option_flag__Flag flag__FlagParser_find_existing_flag(flag__FlagParser* fs, string fname);
VV_LOCAL_SYMBOL void flag__FlagParser_handle_builtin_options(flag__FlagParser* fs);
Option_Array_string flag__FlagParser_finalize(flag__FlagParser* fs);
Array_string flag__FlagParser_remaining_parameters(flag__FlagParser* fs);
VV_LOCAL_SYMBOL bool semver__version_satisfies(semver__Version ver, string input);
VV_LOCAL_SYMBOL bool semver__compare_eq(semver__Version v1, semver__Version v2);
VV_LOCAL_SYMBOL bool semver__compare_gt(semver__Version v1, semver__Version v2);
VV_LOCAL_SYMBOL bool semver__compare_lt(semver__Version v1, semver__Version v2);
VV_LOCAL_SYMBOL bool semver__compare_ge(semver__Version v1, semver__Version v2);
VV_LOCAL_SYMBOL bool semver__compare_le(semver__Version v1, semver__Version v2);
#define _const_semver__ver_major 0
#define _const_semver__ver_minor 1
#define _const_semver__ver_patch 2
Array_int _const_semver__versions; // inited later
VV_LOCAL_SYMBOL semver__RawVersion semver__parse(string input);
VV_LOCAL_SYMBOL bool semver__RawVersion_is_valid(semver__RawVersion ver);
VV_LOCAL_SYMBOL bool semver__RawVersion_is_missing(semver__RawVersion ver, int typ);
VV_LOCAL_SYMBOL Option_semver__Version semver__RawVersion_coerce(semver__RawVersion raw_ver);
VV_LOCAL_SYMBOL semver__RawVersion semver__RawVersion_complete(semver__RawVersion raw_ver);
VV_LOCAL_SYMBOL Option_semver__Version semver__RawVersion_validate(semver__RawVersion raw_ver);
VV_LOCAL_SYMBOL semver__Version semver__RawVersion_to_version(semver__RawVersion raw_ver);
string _const_semver__comparator_sep; // a string literal, inited later
string _const_semver__comparator_set_sep; // a string literal, inited later
string _const_semver__hyphen_range_sep; // a string literal, inited later
string _const_semver__x_range_symbols; // a string literal, inited later
VV_LOCAL_SYMBOL bool semver__Range_satisfies(semver__Range r, semver__Version ver);
VV_LOCAL_SYMBOL bool semver__ComparatorSet_satisfies(semver__ComparatorSet set, semver__Version ver);
VV_LOCAL_SYMBOL bool semver__Comparator_satisfies(semver__Comparator c, semver__Version ver);
VV_LOCAL_SYMBOL Option_semver__Range semver__parse_range(string input);
VV_LOCAL_SYMBOL Option_semver__ComparatorSet semver__parse_comparator_set(string input);
VV_LOCAL_SYMBOL Option_semver__Comparator semver__parse_comparator(string input);
VV_LOCAL_SYMBOL Option_semver__Version semver__parse_xrange(string input);
VV_LOCAL_SYMBOL bool semver__can_expand(string input);
VV_LOCAL_SYMBOL Option_semver__ComparatorSet semver__expand_comparator_set(string input);
VV_LOCAL_SYMBOL Option_semver__ComparatorSet semver__expand_tilda(string raw_version);
VV_LOCAL_SYMBOL Option_semver__ComparatorSet semver__expand_caret(string raw_version);
VV_LOCAL_SYMBOL Option_semver__ComparatorSet semver__expand_hyphen(string raw_range);
VV_LOCAL_SYMBOL Option_semver__ComparatorSet semver__expand_xrange(string raw_range);
VV_LOCAL_SYMBOL semver__ComparatorSet semver__make_comparator_set_ge_lt(semver__Version min, semver__Version max);
VV_LOCAL_SYMBOL semver__ComparatorSet semver__make_comparator_set_ge_le(semver__Version min, semver__Version max);
Option_semver__Version semver__from(string input);
semver__Version semver__build(int major, int minor, int patch);
semver__Version semver__Version_increment(semver__Version ver, semver__Increment typ);
bool semver__Version_satisfies(semver__Version ver, string input);
bool semver__Version_eq(semver__Version v1, semver__Version v2);
bool semver__Version_gt(semver__Version v1, semver__Version v2);
bool semver__Version_lt(semver__Version v1, semver__Version v2);
bool semver__Version_ge(semver__Version v1, semver__Version v2);
bool semver__Version_le(semver__Version v1, semver__Version v2);
string semver__Version_str(semver__Version ver);
Option_semver__Version semver__coerce(string input);
bool semver__is_valid(string input);
VV_LOCAL_SYMBOL bool semver__is_version_valid(string input);
VV_LOCAL_SYMBOL Option_semver__Version semver__coerce_version(string input);
VV_LOCAL_SYMBOL semver__Version semver__increment_version(semver__Version ver, semver__Increment typ);
VV_LOCAL_SYMBOL bool semver__is_valid_string(string input);
VV_LOCAL_SYMBOL bool semver__is_valid_number(string input);
#define _const_sync__stdatomic__used 1
bool sync__stdatomic__add_u64(u64* ptr, int delta);
bool sync__stdatomic__sub_u64(u64* ptr, int delta);
bool sync__stdatomic__add_i64(i64* ptr, int delta);
bool sync__stdatomic__sub_i64(i64* ptr, int delta);
void sync__stdatomic__store_u64(u64* ptr, u64 val);
u64 sync__stdatomic__load_u64(u64* ptr);
void sync__stdatomic__store_i64(i64* ptr, i64 val);
i64 sync__stdatomic__load_i64(i64* ptr);
Array_string os__args_after(string cut_word);
Array_string os__args_before(string cut_word);
#define _const_os__success 0
#define _const_os__error_insufficient_buffer 130
#define _const_os__handle_generic_read 2147483648
#define _const_os__handle_open_existing 3
#define _const_os__file_share_read 1
#define _const_os__file_share_write 2
#define _const_os__file_share_delete 4
#define _const_os__file_notify_change_file_name 1
#define _const_os__file_notify_change_dir_name 2
#define _const_os__file_notify_change_attributes 4
#define _const_os__file_notify_change_size 8
#define _const_os__file_notify_change_last_write 16
#define _const_os__file_notify_change_last_access 32
#define _const_os__file_notify_change_creation 64
#define _const_os__file_notify_change_security 128
#define _const_os__file_action_added 1
#define _const_os__file_action_removed 2
#define _const_os__file_action_modified 3
#define _const_os__file_action_renamed_old_name 4
#define _const_os__file_action_renamed_new_name 5
#define _const_os__file_attr_readonly 1
#define _const_os__file_attr_hidden 2
#define _const_os__file_attr_system 4
#define _const_os__file_attr_directory 16
#define _const_os__file_attr_archive 32
#define _const_os__file_attr_device 64
#define _const_os__file_attr_normal 128
#define _const_os__file_attr_temporary 256
#define _const_os__file_attr_sparse_file 512
#define _const_os__file_attr_reparse_point 1024
#define _const_os__file_attr_compressed 2048
#define _const_os__file_attr_offline 4096
#define _const_os__file_attr_not_content_indexed 8192
#define _const_os__file_attr_encrypted 16384
#define _const_os__file_attr_integrity_stream 32768
#define _const_os__file_attr_virtual 65536
#define _const_os__file_attr_no_scrub_data 131072
#define _const_os__file_type_unknown 0
#define _const_os__file_type_disk 1
#define _const_os__file_type_char 2
#define _const_os__file_type_pipe 3
#define _const_os__file_invalid_file_id -1
voidptr _const_os__invalid_handle_value; // inited later
#define _const_os__enable_echo_input 4
#define _const_os__enable_extended_flags 128
#define _const_os__enable_insert_mode 32
#define _const_os__enable_line_input 2
#define _const_os__enable_mouse_input 16
#define _const_os__enable_processed_input 1
#define _const_os__enable_quick_edit_mode 64
#define _const_os__enable_window_input 8
#define _const_os__enable_virtual_terminal_input 512
#define _const_os__enable_processed_output 1
#define _const_os__enable_wrap_at_eol_output 2
#define _const_os__enable_virtual_terminal_processing 4
#define _const_os__disable_newline_auto_return 8
#define _const_os__enable_lvb_grid_worldwide 16
#define _const_os__o_rdonly 0
#define _const_os__o_wronly 1
#define _const_os__o_rdwr 2
#define _const_os__o_append 8
#define _const_os__o_create 256
#define _const_os__o_binary 32768
#define _const_os__o_trunc 512
#define _const_os__o_excl 1024
#define _const_os__o_sync 0
#define _const_os__o_noctty 0
#define _const_os__o_nonblock 0
#define _const_os__status_access_violation 3221225477
#define _const_os__status_in_page_error 3221225478
#define _const_os__status_invalid_handle 3221225480
#define _const_os__status_invalid_parameter 3221225485
#define _const_os__status_no_memory 3221225495
#define _const_os__status_illegal_instruction 3221225501
#define _const_os__status_noncontinuable_exception 3221225509
#define _const_os__status_invalid_disposition 3221225510
#define _const_os__status_array_bounds_exceeded 3221225612
#define _const_os__status_float_denormal_operand 3221225613
#define _const_os__status_float_divide_by_zero 3221225614
#define _const_os__status_float_inexact_result 3221225615
#define _const_os__status_float_invalid_operation 3221225616
#define _const_os__status_float_overflow 3221225617
#define _const_os__status_float_stack_check 3221225618
#define _const_os__status_float_underflow 3221225619
#define _const_os__status_integer_divide_by_zero 3221225620
#define _const_os__status_integer_overflow 3221225621
#define _const_os__status_privileged_instruction 3221225622
#define _const_os__status_stack_overflow 3221225725
#define _const_os__status_dll_not_found 3221225781
#define _const_os__status_ordinal_not_found 3221225784
#define _const_os__status_entrypoint_not_found 3221225785
#define _const_os__status_control_c_exit 3221225786
#define _const_os__status_dll_init_failed 3221225794
#define _const_os__status_float_multiple_faults 3221226164
#define _const_os__status_float_multiple_traps 3221226165
#define _const_os__status_reg_nat_consumption 3221226185
#define _const_os__status_heap_corruption 3221226356
#define _const_os__status_stack_buffer_overrun 3221226505
#define _const_os__status_invalid_cruntime_parameter 3221226519
#define _const_os__status_assertion_failure 3221226528
voidptr _const_os__hkey_local_machine; // inited later
voidptr _const_os__hkey_current_user; // inited later
#define _const_os__key_query_value 1
#define _const_os__key_set_value 2
#define _const_os__key_enumerate_sub_keys 8
#define _const_os__key_wow64_32key 512
voidptr _const_os__hwnd_broadcast; // inited later
#define _const_os__wm_settingchange 26
#define _const_os__smto_abortifhung 2
string os__getenv(string key);
Option_string os__getenv_opt(string key);
int os__setenv(string name, string value, bool overwrite);
int os__unsetenv(string name);
VV_LOCAL_SYMBOL char** os__unix_environ(void);
Map_string_string os__environ(void);
int os__fd_close(int fd);
void os__fd_write(int fd, string s);
Array_string os__fd_slurp(int fd);
multi_return_string_int os__fd_read(int fd, int maxbytes);
Option_os__File os__open_file(string path, string mode, Array_int options);
Option_os__File os__open(string path);
Option_os__File os__create(string path);
os__File os__stdin(void);
os__File os__stdout(void);
os__File os__stderr(void);
Option_int os__File_read(os__File* f, Array_byte* buf);
Option_int os__File_write(os__File* f, Array_byte buf);
Option_int os__File_writeln(os__File* f, string s);
Option_int os__File_write_string(os__File* f, string s);
Option_int os__File_write_to(os__File* f, u64 pos, Array_byte buf);
int os__File_write_ptr(os__File* f, voidptr data, int size);
Option_void os__File_write_full_buffer(os__File* f, voidptr buffer, usize buffer_len);
int os__File_write_ptr_at(os__File* f, voidptr data, int size, u64 pos);
VV_LOCAL_SYMBOL Option_int os__fread(voidptr ptr, int item_size, int items, FILE* stream);
Array_byte os__File_read_bytes(os__File* f, int size);
Array_byte os__File_read_bytes_at(os__File* f, int size, u64 pos);
Option_int os__File_read_bytes_into_newline(os__File* f, Array_byte* buf);
Option_int os__File_read_bytes_into(os__File* f, u64 pos, Array_byte* buf);
Option_int os__File_read_from(os__File* f, u64 pos, Array_byte* buf);
Option_int os__File_read_into_ptr(os__File* f, byte* ptr, int max_size);
void os__File_flush(os__File* f);
VV_LOCAL_SYMBOL IError os__error_file_not_opened(void);
VV_LOCAL_SYMBOL IError os__error_size_of_type_0(void);
Option_void os__File_seek(os__File* f, i64 pos, os__SeekMode mode);
Option_i64 os__File_tell(os__File* f);
os__FileMode os__inode(string path);
Option_void os__open_uri(string uri);
Array_string _const_os__args; // inited later
Option_Array_byte os__read_bytes(string path);
Option_string os__read_file(string path);
Option_void os__truncate(string path, u64 len);
VV_LOCAL_SYMBOL void os__eprintln_unknown_file_size(void);
u64 os__file_size(string path);
Option_void os__mv(string src, string dst);
Option_void os__cp(string src, string dst);
Option_FILE_ptr os__vfopen(string path, string mode);
int os__fileno(voidptr cfile);
VV_LOCAL_SYMBOL voidptr os__vpopen(string path);
VV_LOCAL_SYMBOL multi_return_int_bool os__posix_wait4_to_exit_status(int waitret);
string os__posix_get_error_msg(int code);
VV_LOCAL_SYMBOL int os__vpclose(voidptr f);
int os__system(string cmd);
bool os__exists(string path);
bool os__is_executable(string path);
bool os__is_writable(string path);
bool os__is_readable(string path);
Option_void os__rm(string path);
Option_void os__rmdir(string path);
VV_LOCAL_SYMBOL void os__print_c_errno(void);
string os__get_raw_line(void);
Array_byte os__get_raw_stdin(void);
void os__on_segfault(voidptr f);
string os__executable(void);
bool os__is_dir(string path);
bool os__is_link(string path);
Option_void os__chdir(string path);
VV_LOCAL_SYMBOL int os__max_path_bufffer_size(void);
string os__getwd(void);
string os__real_path(string fpath);
VV_LOCAL_SYMBOL void os__normalize_drive_letter(string path);
int os__fork(void);
int os__wait(void);
i64 os__file_last_mod_unix(string path);
void os__flush(void);
Option_void os__chmod(string path, int mode);
Option_void os__chown(string path, int owner, int group);
Option_os__File os__open_append(string path);
Option_void os__execvp(string cmdpath, Array_string cmdargs);
Option_void os__execve(string cmdpath, Array_string cmdargs, Array_string envs);
int os__is_atty(int fd);
Option_void os__write_file_array(string path, array buffer);
Option_Array_string os__glob(Array_string patterns);
VV_LOCAL_SYMBOL int compare_10044130939551424885_string(string* a, string* b) {
	if (string__lt(*a, *b)) return -1;
	else return 1;
}

IError os__last_error(void);
#define _const_os__max_path_len 4096
string _const_os__wd_at_startup; // inited later
#define _const_os__f_ok 0
#define _const_os__x_ok 1
#define _const_os__w_ok 2
#define _const_os__r_ok 4
void os__Result_free(os__Result* result);
Option_void os__cp_all(string src, string dst, bool overwrite);
Option_void os__mv_by_cp(string source, string target);
Option_Array_string os__read_lines(string path);
string os__sigint_to_signal_name(int si);
Option_void os__rmdir_all(string path);
bool os__is_dir_empty(string path);
string os__file_ext(string path);
string os__dir(string opath);
string os__base(string opath);
string os__file_name(string opath);
Option_string os__input_opt(string prompt);
string os__input(string prompt);
string os__get_line(void);
Array_string os__get_lines(void);
string os__get_lines_joined(void);
string os__get_raw_lines_joined(void);
string os__user_os(void);
string os__home_dir(void);
string os__expand_tilde_to_home(string path);
Option_void os__write_file(string path, string text);
VV_LOCAL_SYMBOL string os__executable_fallback(void);
VV_LOCAL_SYMBOL IError os__error_failed_to_find_executable(void);
Option_string os__find_abs_path_of_executable(string exepath);
bool os__exists_in_system_path(string prog);
bool os__is_file(string path);
bool os__is_abs_path(string path);
string os__join_path(string base, Array_string dirs);
string os__join_path_single(string base, string elem);
Array_string os__walk_ext(string path, string ext);
VV_LOCAL_SYMBOL void os__impl_walk_ext(string path, string ext, Array_string* out);
void os__walk(string path, void (*f)(string ));
void os__walk_with_context(string path, voidptr context, void (*fcb)(voidptr , string ));
void os__log(string s);
Option_void os__mkdir_all(string opath);
string os__cache_dir(void);
string os__temp_dir(void);
VV_LOCAL_SYMBOL string os__default_vmodules_path(void);
string os__vmodules_dir(void);
Array_string os__vmodules_paths(void);
string os__resource_abs_path(string path);
os__Result os__execute_or_panic(string cmd);
os__Result os__execute_or_exit(string cmd);
string _const_os__path_separator; // a string literal, inited later
string _const_os__path_delimiter; // a string literal, inited later
VV_LOCAL_SYMBOL Array_string os__init_os_args_wide(int argc, byte** argv);
VV_LOCAL_SYMBOL Option_void os__native_glob_pattern(string pattern, Array_string* matches);
Option_void os__utime(string path, int actime, int modtime);
Option_Array_string os__ls(string path);
Option_bool os__mkdir(string path);
os__HANDLE os__get_file_handle(string path);
Option_string os__get_module_filename(os__HANDLE handle);
#define _const_os__format_message_allocate_buffer 256
#define _const_os__format_message_argument_array 8192
#define _const_os__format_message_from_hmodule 2048
#define _const_os__format_message_from_string 1024
#define _const_os__format_message_from_system 4096
#define _const_os__format_message_ignore_inserts 512
#define _const_os__sublang_neutral 0
#define _const_os__sublang_default 1
#define _const_os__lang_neutral 0
#define _const_os__max_error_code 15841
VV_LOCAL_SYMBOL voidptr os__ptr_win_get_error_msg(u32 code);
string os__get_error_msg(int code);
os__Result os__execute(string cmd);
Option_bool os__symlink(string origin, string target);
Option_bool os__link(string origin, string target);
void os__File_close(os__File* f);
void os__add_vectored_exception_handler(bool first, int (*handler)(ExceptionPointers* ));
bool os__debugger_present(void);
os__Uname os__uname(void);
string os__hostname(void);
string os__loginname(void);
Option_bool os__is_writable_folder(string folder);
int os__getpid(void);
int os__getppid(void);
int os__getuid(void);
int os__geteuid(void);
int os__getgid(void);
int os__getegid(void);
void os__posix_set_permission_bit(string path_s, u32 mode, bool enable);
void os__Process_signal_kill(os__Process* p);
void os__Process_signal_pgkill(os__Process* p);
void os__Process_signal_stop(os__Process* p);
void os__Process_signal_continue(os__Process* p);
void os__Process_wait(os__Process* p);
void os__Process_close(os__Process* p);
void os__Process_free(os__Process* p);
VV_LOCAL_SYMBOL int os__Process__spawn(os__Process* p);
bool os__Process_is_alive(os__Process* p);
void os__Process_set_redirect_stdio(os__Process* p);
void os__Process_stdin_write(os__Process* p, string s);
string os__Process_stdout_slurp(os__Process* p);
string os__Process_stderr_slurp(os__Process* p);
string os__Process_stdout_read(os__Process* p);
string os__Process_stderr_read(os__Process* p);
VV_LOCAL_SYMBOL void os__Process__check_redirection_call(os__Process* p, string fn_name);
VV_LOCAL_SYMBOL void os__Process__signal_stop(os__Process* p);
VV_LOCAL_SYMBOL void os__Process__signal_continue(os__Process* p);
VV_LOCAL_SYMBOL void os__Process__signal_kill(os__Process* p);
VV_LOCAL_SYMBOL void os__Process__signal_pgkill(os__Process* p);
VV_LOCAL_SYMBOL void os__Process__wait(os__Process* p);
VV_LOCAL_SYMBOL bool os__Process__is_alive(os__Process* p);
void os__Process_run(os__Process* p);
os__Process* os__new_process(string filename);
void os__Process_set_args(os__Process* p, Array_string pargs);
void os__Process_set_environment(os__Process* p, Map_string_string envs);
VV_LOCAL_SYMBOL os__FN_NTSuspendResume os__ntdll_fn(char* name);
VV_LOCAL_SYMBOL void os__failed_cfn_report_error(bool ok, string label);
VV_LOCAL_SYMBOL void os__close_valid_handle(voidptr p);
VV_LOCAL_SYMBOL int os__Process_win_spawn_process(os__Process* p);
VV_LOCAL_SYMBOL void os__Process_win_stop_process(os__Process* p);
VV_LOCAL_SYMBOL void os__Process_win_resume_process(os__Process* p);
VV_LOCAL_SYMBOL void os__Process_win_kill_process(os__Process* p);
VV_LOCAL_SYMBOL void os__Process_win_kill_pgroup(os__Process* p);
VV_LOCAL_SYMBOL void os__Process_win_wait(os__Process* p);
VV_LOCAL_SYMBOL bool os__Process_win_is_alive(os__Process* p);
VV_LOCAL_SYMBOL void os__Process_win_write_string(os__Process* p, int idx, string s);
VV_LOCAL_SYMBOL multi_return_string_int os__Process_win_read_string(os__Process* p, int idx, int maxbytes);
VV_LOCAL_SYMBOL string os__Process_win_slurp(os__Process* p, int idx);
VV_LOCAL_SYMBOL int os__Process_unix_spawn_process(os__Process* p);
VV_LOCAL_SYMBOL void os__Process_unix_stop_process(os__Process* p);
VV_LOCAL_SYMBOL void os__Process_unix_resume_process(os__Process* p);
VV_LOCAL_SYMBOL void os__Process_unix_kill_process(os__Process* p);
VV_LOCAL_SYMBOL void os__Process_unix_kill_pgroup(os__Process* p);
VV_LOCAL_SYMBOL void os__Process_unix_wait(os__Process* p);
VV_LOCAL_SYMBOL bool os__Process_unix_is_alive(os__Process* p);
Option_os__SignalHandler os__signal_opt(os__Signal signum, void (*handler)(os__Signal ));
v__depgraph__OrderedDepMap v__depgraph__new_ordered_dependency_map(void);
void v__depgraph__OrderedDepMap_set(v__depgraph__OrderedDepMap* o, string name, Array_string deps);
void v__depgraph__OrderedDepMap_add(v__depgraph__OrderedDepMap* o, string name, Array_string deps);
Array_string v__depgraph__OrderedDepMap_get(v__depgraph__OrderedDepMap* o, string name);
void v__depgraph__OrderedDepMap_delete(v__depgraph__OrderedDepMap* o, string name);
void v__depgraph__OrderedDepMap_apply_diff(v__depgraph__OrderedDepMap* o, string name, Array_string deps);
int v__depgraph__OrderedDepMap_size(v__depgraph__OrderedDepMap* o);
v__depgraph__DepGraph* v__depgraph__new_dep_graph(void);
void v__depgraph__DepGraph_add(v__depgraph__DepGraph* graph, string mod, Array_string deps);
v__depgraph__DepGraph* v__depgraph__DepGraph_resolve(v__depgraph__DepGraph* graph);
v__depgraph__DepGraphNode v__depgraph__DepGraph_last_node(v__depgraph__DepGraph* graph);
string v__depgraph__DepGraph_display(v__depgraph__DepGraph* graph);
string v__depgraph__DepGraph_display_cycles(v__depgraph__DepGraph* graph);
VV_LOCAL_SYMBOL multi_return_bool_Array_string v__depgraph__NodeNames_is_part_of_cycle(v__depgraph__NodeNames* nn, string name, Array_string already_seen);
void v__depgraph__show(v__depgraph__DepGraph* graph, string path);
VV_LOCAL_SYMBOL u32 rand__seed__nr_next(u32 prev);
Array_u32 rand__seed__time_seed_array(int count);
u32 rand__seed__time_seed_32(void);
u64 rand__seed__time_seed_64(void);
string term__format(string msg, string open, string close);
string term__format_rgb(int r, int g, int b, string msg, string open, string close);
string term__rgb(int r, int g, int b, string msg);
string term__bg_rgb(int r, int g, int b, string msg);
string term__hex(int hex, string msg);
string term__bg_hex(int hex, string msg);
string term__reset(string msg);
string term__bold(string msg);
string term__dim(string msg);
string term__italic(string msg);
string term__underline(string msg);
string term__inverse(string msg);
string term__hidden(string msg);
string term__strikethrough(string msg);
string term__black(string msg);
string term__red(string msg);
string term__green(string msg);
string term__yellow(string msg);
string term__blue(string msg);
string term__magenta(string msg);
string term__cyan(string msg);
string term__white(string msg);
string term__bg_black(string msg);
string term__bg_red(string msg);
string term__bg_green(string msg);
string term__bg_yellow(string msg);
string term__bg_blue(string msg);
string term__bg_magenta(string msg);
string term__bg_cyan(string msg);
string term__bg_white(string msg);
string term__gray(string msg);
string term__bright_black(string msg);
string term__bright_red(string msg);
string term__bright_green(string msg);
string term__bright_yellow(string msg);
string term__bright_blue(string msg);
string term__bright_magenta(string msg);
string term__bright_cyan(string msg);
string term__bright_white(string msg);
string term__bright_bg_black(string msg);
string term__bright_bg_red(string msg);
string term__bright_bg_green(string msg);
string term__bright_bg_yellow(string msg);
string term__bright_bg_blue(string msg);
string term__bright_bg_magenta(string msg);
string term__bright_bg_cyan(string msg);
string term__bright_bg_white(string msg);
string term__highlight_command(string command);
void term__set_cursor_position(term__Coord c);
void term__move(int n, string direction);
void term__cursor_up(int n);
void term__cursor_down(int n);
void term__cursor_forward(int n);
void term__cursor_back(int n);
void term__erase_display(string t);
void term__erase_toend(void);
void term__erase_tobeg(void);
void term__erase_clear(void);
void term__erase_del_clear(void);
void term__erase_line(string t);
void term__erase_line_toend(void);
void term__erase_line_tobeg(void);
void term__erase_line_clear(void);
void term__show_cursor(void);
void term__hide_cursor(void);
void term__clear_previous_line(void);
#define _const_term__default_columns_size 80
#define _const_term__default_rows_size 25
bool term__can_show_color_on_stdout(void);
bool term__can_show_color_on_stderr(void);
string term__failed(string s);
string term__ok_message(string s);
string term__fail_message(string s);
string term__warn_message(string s);
string term__colorize(string (*cfn)(string ), string s);
string term__strip_ansi(string text);
string term__h_divider(string divider);
string term__header_left(string text, string divider);
string term__header(string text, string divider);
VV_LOCAL_SYMBOL int term__imax(int x, int y);
VV_LOCAL_SYMBOL bool term__supports_escape_sequences(int fd);
multi_return_int_int term__get_terminal_size(void);
Option_term__Coord term__get_cursor_position(void);
bool term__set_terminal_title(string title);
void term__clear(void);
string _const_v__util__version__v_version; // a string literal, inited later
string v__util__version__vhash(void);
string v__util__version__full_hash(void);
string v__util__version__full_v_version(bool is_verbose);
string v__util__version__githash(bool should_get_from_filesystem);
v__vcache__CacheManager v__vcache__new_cache_manager(Array_string opts);
void v__vcache__CacheManager_set_temporary_options(v__vcache__CacheManager* cm, Array_string new_opts);
string v__vcache__CacheManager_key2cpath(v__vcache__CacheManager* cm, string key);
string v__vcache__CacheManager_postfix_with_key2cpath(v__vcache__CacheManager* cm, string postfix, string key);
Option_string v__vcache__CacheManager_exists(v__vcache__CacheManager* cm, string postfix, string key);
Option_string v__vcache__CacheManager_save(v__vcache__CacheManager* cm, string postfix, string key, string content);
Option_string v__vcache__CacheManager_load(v__vcache__CacheManager* cm, string postfix, string key);
VV_LOCAL_SYMBOL int v__vcache__mypid(void);
Option_string v__util__diff__find_working_diff_command(void);
VV_LOCAL_SYMBOL bool v__util__diff__opendiff_exists(void);
string v__util__diff__color_compare_files(string diff_cmd, string file1, string file2);
string v__util__diff__color_compare_strings(string diff_cmd, string unique_prefix, string expected, string found);
Option_v__vmod__Manifest v__vmod__from_file(string vmod_path);
Option_v__vmod__Manifest v__vmod__decode(string contents);
VV_LOCAL_SYMBOL void v__vmod__Scanner_tokenize(v__vmod__Scanner* s, v__vmod__TokenKind t_type, string val);
VV_LOCAL_SYMBOL void v__vmod__Scanner_skip_whitespace(v__vmod__Scanner* s);
VV_LOCAL_SYMBOL bool v__vmod__is_name_alpha(byte chr);
VV_LOCAL_SYMBOL string v__vmod__Scanner_create_string(v__vmod__Scanner* s, byte q);
VV_LOCAL_SYMBOL string v__vmod__Scanner_create_ident(v__vmod__Scanner* s);
VV_LOCAL_SYMBOL bool v__vmod__Scanner_peek_char(v__vmod__Scanner s, byte c);
VV_LOCAL_SYMBOL void v__vmod__Scanner_scan_all(v__vmod__Scanner* s);
VV_LOCAL_SYMBOL Option_multi_return_Array_string_int v__vmod__get_array_content(Array_v__vmod__Token tokens, int st_idx);
VV_LOCAL_SYMBOL Option_v__vmod__Manifest v__vmod__Parser_parse(v__vmod__Parser* p);
v__vmod__ModFileCacher* v__vmod__new_mod_file_cacher(void);
void v__vmod__ModFileCacher_debug(v__vmod__ModFileCacher* mcache);
v__vmod__ModFileAndFolder v__vmod__ModFileCacher_get_by_file(v__vmod__ModFileCacher* mcache, string vfile);
v__vmod__ModFileAndFolder v__vmod__ModFileCacher_get_by_folder(v__vmod__ModFileCacher* mcache, string vfolder);
VV_LOCAL_SYMBOL void v__vmod__ModFileCacher_add(v__vmod__ModFileCacher* cacher, string path, v__vmod__ModFileAndFolder result);
VV_LOCAL_SYMBOL multi_return_Array_string_v__vmod__ModFileAndFolder v__vmod__ModFileCacher_traverse(v__vmod__ModFileCacher* mcache, string mfolder);
VV_LOCAL_SYMBOL void v__vmod__ModFileCacher_mark_folders_with_vmod(v__vmod__ModFileCacher* mcache, Array_string folders_so_far, v__vmod__ModFileAndFolder vmod);
VV_LOCAL_SYMBOL void v__vmod__ModFileCacher_mark_folders_as_vmod_free(v__vmod__ModFileCacher* mcache, Array_string folders_so_far);
Array_string _const_v__vmod__mod_file_stop_paths; // inited later
VV_LOCAL_SYMBOL bool v__vmod__ModFileCacher_check_for_stop(v__vmod__ModFileCacher* mcache, string cfolder, Array_string files);
VV_LOCAL_SYMBOL Array_string v__vmod__ModFileCacher_get_files(v__vmod__ModFileCacher* mcache, string cfolder);
v__vmod__ModFileCacher* _const_v__vmod__private_file_cacher; // inited later
v__vmod__ModFileCacher* v__vmod__get_cache(void);
string v__util__recompilation__disabling_file(string vroot);
void v__util__recompilation__must_be_enabled(string vroot, string error_message);
string v__cflag__CFlag_str(v__cflag__CFlag* c);
string _const_v__cflag__fexisting_literal; // a string literal, inited later
string v__cflag__CFlag_eval(v__cflag__CFlag* cf);
string v__cflag__CFlag_format(v__cflag__CFlag* cf);
Array_string Array_v__cflag__CFlag_c_options_before_target_msvc(Array_v__cflag__CFlag cflags);
Array_string Array_v__cflag__CFlag_c_options_after_target_msvc(Array_v__cflag__CFlag cflags);
Array_string Array_v__cflag__CFlag_c_options_before_target(Array_v__cflag__CFlag cflags);
Array_string Array_v__cflag__CFlag_c_options_after_target(Array_v__cflag__CFlag cflags);
Array_string Array_v__cflag__CFlag_c_options_without_object_files(Array_v__cflag__CFlag cflags);
Array_string Array_v__cflag__CFlag_c_options_only_object_files(Array_v__cflag__CFlag cflags);
multi_return_Array_string_Array_string_Array_string Array_v__cflag__CFlag_defines_others_libs(Array_v__cflag__CFlag cflags);
u64 _const_rand__wyrand__wyp0 = 11562461410679940143U; // precomputed
u64 _const_rand__wyrand__wyp1 = 16646288086500911323U; // precomputed
void rand__wyrand__WyRandRNG_seed(rand__wyrand__WyRandRNG* rng, Array_u32 seed_data);
u32 rand__wyrand__WyRandRNG_u32(rand__wyrand__WyRandRNG* rng);
u64 rand__wyrand__WyRandRNG_u64(rand__wyrand__WyRandRNG* rng);
u32 rand__wyrand__WyRandRNG_u32n(rand__wyrand__WyRandRNG* rng, u32 max);
u64 rand__wyrand__WyRandRNG_u64n(rand__wyrand__WyRandRNG* rng, u64 max);
u32 rand__wyrand__WyRandRNG_u32_in_range(rand__wyrand__WyRandRNG* rng, u32 min, u32 max);
u64 rand__wyrand__WyRandRNG_u64_in_range(rand__wyrand__WyRandRNG* rng, u64 min, u64 max);
int rand__wyrand__WyRandRNG_int(rand__wyrand__WyRandRNG* rng);
i64 rand__wyrand__WyRandRNG_i64(rand__wyrand__WyRandRNG* rng);
int rand__wyrand__WyRandRNG_int31(rand__wyrand__WyRandRNG* rng);
i64 rand__wyrand__WyRandRNG_int63(rand__wyrand__WyRandRNG* rng);
int rand__wyrand__WyRandRNG_intn(rand__wyrand__WyRandRNG* rng, int max);
i64 rand__wyrand__WyRandRNG_i64n(rand__wyrand__WyRandRNG* rng, i64 max);
int rand__wyrand__WyRandRNG_int_in_range(rand__wyrand__WyRandRNG* rng, int min, int max);
i64 rand__wyrand__WyRandRNG_i64_in_range(rand__wyrand__WyRandRNG* rng, i64 min, i64 max);
f32 rand__wyrand__WyRandRNG_f32(rand__wyrand__WyRandRNG* rng);
f64 rand__wyrand__WyRandRNG_f64(rand__wyrand__WyRandRNG* rng);
f32 rand__wyrand__WyRandRNG_f32n(rand__wyrand__WyRandRNG* rng, f32 max);
f64 rand__wyrand__WyRandRNG_f64n(rand__wyrand__WyRandRNG* rng, f64 max);
f32 rand__wyrand__WyRandRNG_f32_in_range(rand__wyrand__WyRandRNG* rng, f32 min, f32 max);
f64 rand__wyrand__WyRandRNG_f64_in_range(rand__wyrand__WyRandRNG* rng, f64 min, f64 max);
void rand__wyrand__WyRandRNG_free(rand__wyrand__WyRandRNG* rng);
VV_LOCAL_SYMBOL Option_string v__pkgconfig__desc(string mod);
Option_v__pkgconfig__Main_ptr v__pkgconfig__main(Array_string args);
VV_LOCAL_SYMBOL int compare_6984583855671780374_string(string* a, string* b) {
	if (string__lt(*a, *b)) return -1;
	else return 1;
}

Option_string v__pkgconfig__Main_run(v__pkgconfig__Main* m);
VV_LOCAL_SYMBOL string v__pkgconfig__filter(Array_string libs, string prefix, string prefix2);
VV_LOCAL_SYMBOL v__pkgconfig__MainOptions* v__pkgconfig__parse_options(flag__FlagParser* fp);
Array_string _const_v__pkgconfig__default_paths; // inited later
string _const_v__pkgconfig__version; // a string literal, inited later
VV_LOCAL_SYMBOL Array_string v__pkgconfig__PkgConfig_parse_list_no_comma(v__pkgconfig__PkgConfig* pc, string s);
VV_LOCAL_SYMBOL Array_string v__pkgconfig__PkgConfig_parse_list(v__pkgconfig__PkgConfig* pc, string s);
VV_LOCAL_SYMBOL string v__pkgconfig__PkgConfig_parse_line(v__pkgconfig__PkgConfig* pc, string s);
VV_LOCAL_SYMBOL void v__pkgconfig__PkgConfig_setvar(v__pkgconfig__PkgConfig* pc, string line);
VV_LOCAL_SYMBOL bool v__pkgconfig__PkgConfig_parse(v__pkgconfig__PkgConfig* pc, string file);
VV_LOCAL_SYMBOL Option_string v__pkgconfig__PkgConfig_resolve(v__pkgconfig__PkgConfig* pc, string pkgname);
bool v__pkgconfig__atleast(string v);
bool v__pkgconfig__PkgConfig_atleast(v__pkgconfig__PkgConfig* pc, string v);
Option_string v__pkgconfig__PkgConfig_extend(v__pkgconfig__PkgConfig* pc, v__pkgconfig__PkgConfig* pcdep);
VV_LOCAL_SYMBOL Option_void v__pkgconfig__PkgConfig_load_requires(v__pkgconfig__PkgConfig* pc);
VV_LOCAL_SYMBOL Option_void v__pkgconfig__PkgConfig_load_require(v__pkgconfig__PkgConfig* pc, string dep);
VV_LOCAL_SYMBOL void v__pkgconfig__PkgConfig_add_path(v__pkgconfig__PkgConfig* pc, string path);
VV_LOCAL_SYMBOL void v__pkgconfig__PkgConfig_load_paths(v__pkgconfig__PkgConfig* pc);
Option_v__pkgconfig__PkgConfig_ptr v__pkgconfig__load(string pkgname, v__pkgconfig__Options options);
Array_string v__pkgconfig__list(void);
int runtime__nr_jobs(void);
bool runtime__is_32bit(void);
bool runtime__is_64bit(void);
bool runtime__is_little_endian(void);
bool runtime__is_big_endian(void);
int runtime__nr_cpus(void);
string rand__uuid_v4(void);
string _const_rand__ulid_encoding; // a string literal, inited later
string rand__ulid(void);
string rand__ulid_at_millisecond(u64 unix_time_milli);
string rand__string_from_set(string charset, int len);
string rand__string(int len);
string rand__hex(int len);
string rand__ascii(int len);
VV_LOCAL_SYMBOL void rand__deinit(void);
VV_LOCAL_SYMBOL void rand__init(void);
rand__PRNG*  default_rng; // global
rand__PRNG* rand__new_default(rand__config__PRNGConfigStruct config);
rand__PRNG* rand__get_current_rng(void);
void rand__set_rng(rand__PRNG* rng);
void rand__seed(Array_u32 seed);
u32 rand__u32(void);
u64 rand__u64(void);
u32 rand__u32n(u32 max);
u64 rand__u64n(u64 max);
u32 rand__u32_in_range(u32 min, u32 max);
u64 rand__u64_in_range(u64 min, u64 max);
int rand__int(void);
int rand__intn(int max);
byte rand__byte(void);
int rand__int_in_range(int min, int max);
int rand__int31(void);
i64 rand__i64(void);
i64 rand__i64n(i64 max);
i64 rand__i64_in_range(i64 min, i64 max);
i64 rand__int63(void);
f32 rand__f32(void);
f64 rand__f64(void);
f32 rand__f32n(f32 max);
f64 rand__f64n(f64 max);
f32 rand__f32_in_range(f32 min, f32 max);
f64 rand__f64_in_range(f64 min, f64 max);
string _const_rand__english_letters; // a string literal, inited later
string _const_rand__hex_chars; // a string literal, inited later
string _const_rand__ascii_chars; // a string literal, inited later
string _const_v__pref__default_module_path; // inited later
v__pref__Preferences* v__pref__new_preferences(void);
VV_LOCAL_SYMBOL void v__pref__Preferences_expand_lookup_paths(v__pref__Preferences* p);
void v__pref__Preferences_fill_with_defaults(v__pref__Preferences* p);
string _const_v__pref__cc_to_windows; // a string literal, inited later
string _const_v__pref__cc_to_linux; // a string literal, inited later
VV_LOCAL_SYMBOL void v__pref__Preferences_find_cc_if_cross_compiling(v__pref__Preferences* p);
VV_LOCAL_SYMBOL void v__pref__Preferences_try_to_use_tcc_by_default(v__pref__Preferences* p);
string v__pref__default_tcc_compiler(void);
string v__pref__default_c_compiler(void);
string v__pref__vexe_path(void);
string v__pref__vcross_compiler_name(string vccname_default);
Option_v__pref__OS v__pref__os_from_string(string os_str);
string v__pref__OS_str(v__pref__OS o);
v__pref__OS v__pref__get_host_os(void);
bool v__pref__Backend_is_js(v__pref__Backend b);
Array_string _const_v__pref__list_of_flags_with_param; // inited later
multi_return_ref_v__pref__Preferences_string v__pref__parse_args(Array_string known_external_commands, Array_string args);
multi_return_ref_v__pref__Preferences_string v__pref__parse_args_and_show_errors(Array_string known_external_commands, Array_string args, bool show_output);
void v__pref__eprintln_cond(bool condition, string s);
void v__pref__Preferences_vrun_elog(v__pref__Preferences* pref, string s);
bool v__pref__Preferences_should_output_to_stdout(v__pref__Preferences* pref);
Option_v__pref__Arch v__pref__arch_from_string(string arch_str);
VV_LOCAL_SYMBOL void v__pref__must_exist(string path);
VV_LOCAL_SYMBOL bool v__pref__is_source_file(string path);
Option_v__pref__Backend v__pref__backend_from_string(string s);
v__pref__CompilerType v__pref__cc_from_string(string cc_str);
v__pref__Arch v__pref__get_host_arch(void);
VV_LOCAL_SYMBOL void v__pref__Preferences_parse_define(v__pref__Preferences* prefs, string define);
Array_string v__pref__Preferences_should_compile_filtered_files(v__pref__Preferences* prefs, string dir, Array_string files_);
VV_LOCAL_SYMBOL int compare_16890712418519328305_string(string* a, string* b) {
	if (string__lt(*a, *b)) return -1;
	else return 1;
}

VV_LOCAL_SYMBOL string v__pref__fname_without_platform_postfix(string file);
bool v__pref__Preferences_should_compile_native(v__pref__Preferences* prefs, string file);
bool v__pref__Preferences_should_compile_c(v__pref__Preferences* prefs, string file);
bool v__pref__Preferences_should_compile_asm(v__pref__Preferences* prefs, string path);
bool v__pref__Preferences_should_compile_js(v__pref__Preferences* prefs, string file);
#define _const_sync__aops_used 1
#define _const_sync__spinloops 750
#define _const_sync__spinloops_sem 4000
VV_LOCAL_SYMBOL sync__Channel* sync__new_channel_st(u32 n, u32 st);
VV_LOCAL_SYMBOL sync__Channel* sync__new_channel_st_noscan(u32 n, u32 st);
string sync__Channel_auto_str(sync__Channel* ch, string _v_typename);
void sync__Channel_close(sync__Channel* ch);
int sync__Channel_len(sync__Channel* ch);
bool sync__Channel_closed(sync__Channel* ch);
void sync__Channel_push(sync__Channel* ch, voidptr src);
ChanState sync__Channel_try_push(sync__Channel* ch, voidptr src);
VV_LOCAL_SYMBOL ChanState sync__Channel_try_push_priv(sync__Channel* ch, voidptr src, bool no_block);
bool sync__Channel_pop(sync__Channel* ch, voidptr dest);
ChanState sync__Channel_try_pop(sync__Channel* ch, voidptr dest);
VV_LOCAL_SYMBOL ChanState sync__Channel_try_pop_priv(sync__Channel* ch, voidptr dest, bool no_block);
int sync__channel_select(Array_sync__Channel_ptr* channels, Array_sync__Direction dir, Array_voidptr* objrefs, time__Duration timeout);
sync__ManyTimes* sync__new_many_times(u64 times);
void sync__ManyTimes_do(sync__ManyTimes* m, void (*f)());
VV_LOCAL_SYMBOL void sync__ManyTimes_do_slow(sync__ManyTimes* m, void (*f)());
sync__Once* sync__new_once(void);
void sync__Once_do(sync__Once* o, void (*f)());
VV_LOCAL_SYMBOL void sync__Once_do_slow(sync__Once* o, void (*f)());
sync__Mutex* sync__new_mutex(void);
sync__RwMutex* sync__new_rwmutex(void);
void sync__Mutex_init(sync__Mutex* m);
void sync__RwMutex_init(sync__RwMutex* m);
void sync__Mutex_lock(sync__Mutex* m);
void sync__Mutex_unlock(sync__Mutex* m);
void sync__RwMutex_rlock(sync__RwMutex* m);
void sync__RwMutex_lock(sync__RwMutex* m);
void sync__RwMutex_runlock(sync__RwMutex* m);
void sync__RwMutex_unlock(sync__RwMutex* m);
void sync__Mutex_destroy(sync__Mutex* m);
sync__Semaphore* sync__new_semaphore(void);
sync__Semaphore* sync__new_semaphore_init(u32 n);
void sync__Semaphore_init(sync__Semaphore* sem, u32 n);
void sync__Semaphore_post(sync__Semaphore* sem);
void sync__Semaphore_wait(sync__Semaphore* sem);
bool sync__Semaphore_try_wait(sync__Semaphore* sem);
bool sync__Semaphore_timed_wait(sync__Semaphore* sem, time__Duration timeout);
void sync__Semaphore_destroy(sync__Semaphore _v_toheap_s);
sync__WaitGroup* sync__new_waitgroup(void);
void sync__WaitGroup_init(sync__WaitGroup* wg);
void sync__WaitGroup_add(sync__WaitGroup* wg, int delta);
void sync__WaitGroup_done(sync__WaitGroup* wg);
void sync__WaitGroup_wait(sync__WaitGroup* wg);
string _const_help__unknown_topic; // a string literal, inited later
void help__print_and_exit(string topic);
VV_LOCAL_SYMBOL string help__known_topics(string topicdir);
VV_LOCAL_SYMBOL int compare_1650400601261717902_string(string* a, string* b) {
	if (string__lt(*a, *b)) return -1;
	else return 1;
}

Option_string v__util__find_working_diff_command(void);
string v__util__color_compare_files(string diff_cmd, string file1, string file2);
string v__util__color_compare_strings(string diff_cmd, string unique_prefix, string expected, string found);
#define _const_v__util__error_context_before 2
#define _const_v__util__error_context_after 2
v__util__EManager* _const_v__util__emanager; // inited later
v__util__EManager* v__util__new_error_manager(void);
void v__util__EManager_set_support_color(v__util__EManager* e, bool b);
string v__util__bold(string msg);
VV_LOCAL_SYMBOL string v__util__color(string kind, string msg);
string v__util__formatted_error(string kind, string omsg, string filepath, v__token__Position pos);
Array_string v__util__cached_file2sourcelines(string path);
Array_string v__util__source_file_context(string kind, string filepath, v__token__Position pos);
void v__util__verror(string kind, string s);
string v__util__vlines_escape_path(string path, string ccompiler);
string v__util__qualify_import(v__pref__Preferences* pref, string mod, string file_path);
string v__util__qualify_module(v__pref__Preferences* pref, string mod, string file_path);
Option_string v__util__mod_path_to_full_name(v__pref__Preferences* pref, string mod, string path);
Array_byte _const_v__util__invalid_escapes; // inited later
#define _const_v__util__backslash 92
#define _const_v__util__backslash_r 13
#define _const_v__util__backslash_n 10
#define _const_v__util__double_quote 34
string _const_v__util__double_escape; // a string literal, inited later
string v__util__smart_quote(string str, bool raw);
bool v__util__is_name_char(byte c);
bool v__util__is_func_char(byte c);
bool v__util__contains_capital(string s);
bool v__util__good_type_name(string s);
bool v__util__is_generic_type_name(string name);
string v__util__cescaped_path(string s);
v__util__Suggestion v__util__new_suggestion(string wanted, Array_string possibilities);
void v__util__Suggestion_add(v__util__Suggestion* s, string val);
void v__util__Suggestion_add_many(v__util__Suggestion* s, Array_string many);
void v__util__Suggestion_sort(v__util__Suggestion* s);
VV_LOCAL_SYMBOL int compare_6081961377856465380_v__util__Possibility_by_similarity(v__util__Possibility* a, v__util__Possibility* b) {
	if (a->similarity < b->similarity) return -1;
	else return 1;
}

string v__util__Suggestion_say(v__util__Suggestion s, string msg);
VV_LOCAL_SYMBOL int compare_6081961377856465380_string(string* a, string* b) {
	if (string__lt(*a, *b)) return -1;
	else return 1;
}

string v__util__short_module_name(string name);
v__util__Surrounder v__util__new_surrounder(int expected_length);
void v__util__Surrounder_add(v__util__Surrounder* s, string before, string after);
string v__util__Surrounder_before(v__util__Surrounder* s);
string v__util__Surrounder_after(v__util__Surrounder* s);
void v__util__Surrounder_builder_write_befores(v__util__Surrounder* s, strings__Builder* sb);
void v__util__Surrounder_builder_write_afters(v__util__Surrounder* s, strings__Builder* sb);
void v__util__Surrounder_free(v__util__Surrounder* s);
v__util__Timers*  g_timers;
v__util__Timers* v__util__new_timers(v__util__TimerParams params);
v__util__Timers* v__util__get_timers(void);
void v__util__timing_start(string label);
void v__util__timing_measure(string label);
void v__util__timing_measure_cumulative(string label);
void v__util__timing_set_should_print(bool should_print);
void v__util__Timers_start(v__util__Timers* t, string name);
i64 v__util__Timers_measure(v__util__Timers* t, string name);
i64 v__util__Timers_measure_cumulative(v__util__Timers* t, string name);
void v__util__Timers_measure_pause(v__util__Timers* t, string name);
void v__util__Timers_measure_resume(v__util__Timers* t, string name);
string v__util__Timers_message(v__util__Timers* t, string name);
void v__util__Timers_show(v__util__Timers* t, string label);
void v__util__Timers_show_if_exists(v__util__Timers* t, string label);
void v__util__Timers_show_remaining(v__util__Timers* t);
void v__util__Timers_dump_all(v__util__Timers* t);
string v__util__skip_bom(string file_content);
Array_string _const_v__util__builtin_module_parts; // inited later
Array_string _const_v__util__bundle_modules; // inited later
Map_string_Array_string _const_v__util__external_module_dependencies_for_tool; // inited later
Array_string _const_v__util__const_tabs; // inited later
string v__util__tabs(int n);
void v__util__set_vroot_folder(string vroot_path);
Option_string v__util__resolve_vmodroot(string str, string dir);
Option_string v__util__resolve_env_value(string str, bool check_for_presence);
void v__util__launch_tool(bool is_verbose, string tool_name, Array_string args);
bool v__util__should_recompile_tool(string vexe, string tool_source, string tool_name, string tool_exe);
VV_LOCAL_SYMBOL multi_return_string_string v__util__tool_source2name_and_exe(string tool_source);
string v__util__quote_path(string s);
string v__util__args_quote_paths(Array_string args);
string v__util__path_of_executable(string path);
Option_string v__util__cached_read_source_file(string path);
string v__util__replace_op(string s);
Array_string v__util__join_env_vflags_and_os_args(void);
VV_LOCAL_SYMBOL Array_string v__util__non_empty(Array_string arg);
Option_bool v__util__check_module_is_installed(string modulename, bool is_verbose);
void v__util__ensure_modules_for_all_tools_are_installed(bool is_verbose);
string v__util__strip_mod_name(string name);
string v__util__strip_main_name(string name);
string v__util__no_dots(string s);
string _const_v__util__map_prefix; // a string literal, inited later
string v__util__no_cur_mod(string _v_typename, string cur_mod);
void v__util__prepare_tool_when_needed(string source_name);
void v__util__recompile_file(string vexe, string file);
string v__util__get_vtmp_folder(void);
bool v__util__should_bundle_module(string mod);
Option_Array_string v__util__find_all_v_files(Array_string roots);
void v__util__free_caches(void);
Option_string v__util__read_file(string file_path);
voidptr _const_sync__pool__no_result; // inited later
sync__pool__PoolProcessor* sync__pool__new_pool_processor(sync__pool__PoolProcessorConfig context);
void sync__pool__PoolProcessor_set_max_jobs(sync__pool__PoolProcessor* pool, int njobs);
void sync__pool__PoolProcessor_work_on_items_T___ptr__v__ast__File(sync__pool__PoolProcessor* pool, Array_v__ast__File_ptr items);
void sync__pool__PoolProcessor_work_on_pointers(sync__pool__PoolProcessor* pool, Array_voidptr items);
VV_LOCAL_SYMBOL void sync__pool__process_in_thread(sync__pool__PoolProcessor* pool, int task_id);
v__ast__File* sync__pool__PoolProcessor_get_item_T___ptr__v__ast__File(sync__pool__PoolProcessor* pool, int idx);
Array_v__gen__c__Gen_ptr sync__pool__PoolProcessor_get_results_ref_T_v__gen__c__Gen(sync__pool__PoolProcessor* pool);
void sync__pool__PoolProcessor_set_shared_context(sync__pool__PoolProcessor* pool, voidptr context);
voidptr sync__pool__PoolProcessor_get_shared_context(sync__pool__PoolProcessor* pool);
void sync__pool__PoolProcessor_set_thread_context(sync__pool__PoolProcessor* pool, int idx, voidptr context);
voidptr sync__pool__PoolProcessor_get_thread_context(sync__pool__PoolProcessor* pool, int idx);
v__ast__Expr v__ast__empty_expr(void);
v__ast__Stmt v__ast__empty_stmt(void);
v__ast__Node v__ast__empty_node(void);
Option_v__ast__Ident v__ast__SelectorExpr_root_ident(v__ast__SelectorExpr* e);
void v__ast__File_free(v__ast__File* f);
v__ast__IdentVar v__ast__Ident_var_info(v__ast__Ident* i);
Map_int_Array_string _const_v__ast__x86_no_number_register_list; // inited later
Map_int_Map_string_int _const_v__ast__x86_with_number_register_list; // inited later
Array_string _const_v__ast__arm_no_number_register_list; // inited later
Map_string_int _const_v__ast__arm_with_number_register_list; // inited later
Array_string _const_v__ast__riscv_no_number_register_list; // inited later
Map_string_int _const_v__ast__riscv_with_number_register_list; // inited later
bool v__ast__Expr_is_blank_ident(v__ast__Expr expr);
v__token__Position v__ast__Expr_position(v__ast__Expr expr);
bool v__ast__Expr_is_lvalue(v__ast__Expr expr);
bool v__ast__Expr_is_expr(v__ast__Expr expr);
bool v__ast__Expr_is_lit(v__ast__Expr expr);
bool v__ast__Expr_is_auto_deref_var(v__ast__Expr expr);
bool v__ast__Expr_is_lockable(v__ast__Expr* e);
Option_void v__ast__Stmt_check_c_expr(v__ast__Stmt stmt);
v__token__Position v__ast__Node_position(v__ast__Node node);
Array_v__ast__Node v__ast__Node_children(v__ast__Node node);
void v__ast__IndexExpr_recursive_mapset_is_setter(v__ast__IndexExpr* lx, bool val);
Map_string_v__ast__ScopeObject v__ast__all_registers(v__ast__Table* t, v__pref__Arch arch);
VV_LOCAL_SYMBOL Map_string_v__ast__ScopeObject v__ast__gen_all_registers(v__ast__Table* t, Array_string without_numbers, Map_string_int with_numbers, int bit_size);
bool v__ast__Expr_is_literal(v__ast__Expr expr);
bool v__ast__type_can_start_with_token(v__token__Token* tok);
VV_LOCAL_SYMBOL v__token__KeywordsMatcher v__ast__build_builtin_type_names_matcher(void);
string v__ast__Attr_debug(v__ast__Attr* a);
string v__ast__Attr_str(v__ast__Attr* a);
bool Array_v__ast__Attr_contains(Array_v__ast__Attr attrs, string str);
Option_int Array_v__ast__Attr_find_comptime_define(Array_v__ast__Attr attrs);
VV_LOCAL_SYMBOL bool v__ast__Table_has_cflag(v__ast__Table* t, v__cflag__CFlag flag);
Option_bool v__ast__Table_parse_cflag(v__ast__Table* t, string cflg, string mod, Array_string ctimedefines);
v__ast__ComptTimeConstValue v__ast__empty_comptime_const_expr(void);
Option_i8 v__ast__ComptTimeConstValue_i8(v__ast__ComptTimeConstValue val);
Option_i16 v__ast__ComptTimeConstValue_i16(v__ast__ComptTimeConstValue val);
Option_int v__ast__ComptTimeConstValue_int(v__ast__ComptTimeConstValue val);
Option_i64 v__ast__ComptTimeConstValue_i64(v__ast__ComptTimeConstValue val);
Option_byte v__ast__ComptTimeConstValue_byte(v__ast__ComptTimeConstValue val);
Option_u16 v__ast__ComptTimeConstValue_u16(v__ast__ComptTimeConstValue val);
Option_u32 v__ast__ComptTimeConstValue_u32(v__ast__ComptTimeConstValue val);
Option_u64 v__ast__ComptTimeConstValue_u64(v__ast__ComptTimeConstValue val);
Option_f32 v__ast__ComptTimeConstValue_f32(v__ast__ComptTimeConstValue val);
Option_f64 v__ast__ComptTimeConstValue_f64(v__ast__ComptTimeConstValue val);
Option_string v__ast__ComptTimeConstValue_string(v__ast__ComptTimeConstValue val);
Option_v__ast__ComptTimeConstValue v__ast__ConstField_comptime_expr_value(v__ast__ConstField* obj);
bool v__ast__ConstField_is_simple_define_const(v__ast__ConstField* obj);
bool v__ast__ScopeObject_is_simple_define_const(v__ast__ScopeObject obj);
v__ast__Expr v__ast__resolve_init(v__ast__StructInit node, v__ast__Type typ, v__ast__Table* t);
Array_string _const_v__ast__native_builtins; // inited later
void v__ast__Scope_free(v__ast__Scope* s);
VV_LOCAL_SYMBOL bool v__ast__Scope_dont_lookup_parent(v__ast__Scope* s);
Option_v__ast__ScopeObject v__ast__Scope_find(v__ast__Scope* s, string name);
Option_v__ast__ScopeStructField v__ast__Scope_find_struct_field(v__ast__Scope* s, string name, v__ast__Type struct_type, string field_name);
Option_v__ast__Var_ptr v__ast__Scope_find_var(v__ast__Scope* s, string name);
Option_v__ast__GlobalField_ptr v__ast__Scope_find_global(v__ast__Scope* s, string name);
Option_v__ast__ConstField_ptr v__ast__Scope_find_const(v__ast__Scope* s, string name);
bool v__ast__Scope_known_var(v__ast__Scope* s, string name);
bool v__ast__Scope_known_const(v__ast__Scope* s, string name);
void v__ast__Scope_update_var_type(v__ast__Scope* s, string name, v__ast__Type typ);
void v__ast__Scope_register_struct_field(v__ast__Scope* s, string name, v__ast__ScopeStructField field);
void v__ast__Scope_register(v__ast__Scope* s, v__ast__ScopeObject obj);
v__ast__Scope* v__ast__Scope_innermost(v__ast__Scope* s, int pos);
bool v__ast__Scope_contains(v__ast__Scope* s, int pos);
bool v__ast__Scope_has_inherited_vars(v__ast__Scope* s);
string v__ast__Scope_show(v__ast__Scope _v_toheap_sc, int depth, int max_depth);
string v__ast__Scope_str(v__ast__Scope _v_toheap_sc);
string v__ast__FnDecl_modname(v__ast__FnDecl* node);
string v__ast__FnDecl_fkey(v__ast__FnDecl* node);
string v__ast__Fn_fkey(v__ast__Fn* node);
string v__ast__CallExpr_fkey(v__ast__CallExpr* node);
string v__ast__AnonFn_stringify(v__ast__AnonFn* node, v__ast__Table* t, string cur_mod, Map_string_string m2a);
string v__ast__FnDecl_stringify(v__ast__FnDecl* node, v__ast__Table* t, string cur_mod, Map_string_string m2a);
VV_LOCAL_SYMBOL void v__ast__stringify_fn_after_name(v__ast__FnDecl* node, strings__Builder* f, v__ast__Table* t, string cur_mod, Map_string_string m2a);
multi_return_string_bool v__ast__StringInterLiteral_get_fspec_braces(v__ast__StringInterLiteral* lit, int i);
string v__ast__Expr_str(v__ast__Expr x);
string v__ast__CallArg_str(v__ast__CallArg a);
string v__ast__args2str(Array_v__ast__CallArg args);
string v__ast__BranchStmt_str(v__ast__BranchStmt* node);
string v__ast__Stmt_str(v__ast__Stmt node);
VV_LOCAL_SYMBOL string v__ast__field_to_string(v__ast__ConstField f);
string v__ast__ComptimeForKind_str(v__ast__ComptimeForKind e);
void v__ast__Table_free(v__ast__Table* t);
VV_LOCAL_SYMBOL void v__ast__default_table_panic_handler(v__ast__Table* t, string message);
void v__ast__Table_panic(v__ast__Table* t, string message);
VV_LOCAL_SYMBOL bool v__ast__Fn_method_equals(v__ast__Fn* f, v__ast__Fn* o);
v__ast__Fn v__ast__Fn_new_method_with_receiver_type(v__ast__Fn* f, v__ast__Type new_type);
v__ast__FnDecl v__ast__FnDecl_new_method_with_receiver_type(v__ast__FnDecl* f, v__ast__Type new_type);
VV_LOCAL_SYMBOL bool v__ast__Param_equals(v__ast__Param* p, v__ast__Param* o);
VV_LOCAL_SYMBOL bool Array_v__ast__Param_equals(Array_v__ast__Param p, Array_v__ast__Param o);
v__ast__Table* v__ast__new_table(void);
v__ast__Table*  global_table = ((v__ast__Table*)(0)); // global
void v__ast__set_global_table(v__ast__Table* t);
string v__ast__Table_fn_type_signature(v__ast__Table* t, v__ast__Fn* f);
string v__ast__Table_fn_type_source_signature(v__ast__Table* t, v__ast__Fn* f);
string v__ast__Table_is_same_method(v__ast__Table* t, v__ast__Fn* f, v__ast__Fn* func);
Option_v__ast__Fn v__ast__Table_find_fn(v__ast__Table* t, string name);
bool v__ast__Table_known_fn(v__ast__Table* t, string name);
void v__ast__Table_register_fn(v__ast__Table* t, v__ast__Fn new_fn);
void v__ast__Table_register_interface(v__ast__Table* t, v__ast__InterfaceDecl idecl);
int v__ast__TypeSymbol_register_method(v__ast__TypeSymbol* t, v__ast__Fn new_fn);
Option_v__ast__Fn v__ast__Table_register_aggregate_method(v__ast__Table* t, v__ast__TypeSymbol* sym, string name);
bool v__ast__Table_has_method(v__ast__Table* t, v__ast__TypeSymbol* s, string name);
Option_v__ast__Fn v__ast__Table_find_method(v__ast__Table* t, v__ast__TypeSymbol* s, string name);
Array_Array_v__ast__Type v__ast__Table_get_embeds(v__ast__Table* t, v__ast__TypeSymbol* sym, v__ast__GetEmbedsOptions options);
Option_multi_return_v__ast__Fn_Array_v__ast__Type v__ast__Table_find_method_from_embeds(v__ast__Table* t, v__ast__TypeSymbol* sym, string method_name);
Option_v__ast__Fn v__ast__Table_find_method_with_embeds(v__ast__Table* t, v__ast__TypeSymbol* sym, string method_name);
VV_LOCAL_SYMBOL Option_v__ast__StructField v__ast__Table_register_aggregate_field(v__ast__Table* t, v__ast__TypeSymbol* sym, string name);
bool v__ast__Table_struct_has_field(v__ast__Table* t, v__ast__TypeSymbol* struct_, string name);
Array_v__ast__StructField v__ast__Table_struct_fields(v__ast__Table* t, v__ast__TypeSymbol* sym);
Option_v__ast__StructField v__ast__Table_find_field(v__ast__Table* t, v__ast__TypeSymbol* s, string name);
Option_multi_return_v__ast__StructField_Array_v__ast__Type v__ast__Table_find_field_from_embeds(v__ast__Table* t, v__ast__TypeSymbol* sym, string field_name);
Option_v__ast__StructField v__ast__Table_find_field_with_embeds(v__ast__Table* t, v__ast__TypeSymbol* sym, string field_name);
void v__ast__Table_resolve_common_sumtype_fields(v__ast__Table* t, v__ast__TypeSymbol* sym_);
int v__ast__Table_find_type_idx(v__ast__Table* t, string name);
Option_v__ast__TypeSymbol_ptr v__ast__Table_find_sym(v__ast__Table* t, string name);
multi_return_ref_v__ast__TypeSymbol_int v__ast__Table_find_sym_and_type_idx(v__ast__Table* t, string name);
v__ast__TypeSymbol* _const_v__ast__invalid_type_symbol; // inited later
v__ast__TypeSymbol* v__ast__Table_sym_by_idx(v__ast__Table* t, int idx);
v__ast__TypeSymbol* v__ast__Table_sym(v__ast__Table* t, v__ast__Type typ);
v__ast__TypeSymbol* v__ast__Table_final_sym(v__ast__Table* t, v__ast__Type typ);
string v__ast__Table_get_type_name(v__ast__Table* t, v__ast__Type typ);
v__ast__Type v__ast__Table_unalias_num_type(v__ast__Table* t, v__ast__Type typ);
v__ast__Type v__ast__Table_unaliased_type(v__ast__Table* t, v__ast__Type typ);
VV_LOCAL_SYMBOL int v__ast__Table_rewrite_already_registered_symbol(v__ast__Table* t, v__ast__TypeSymbol typ, int existing_idx);
int v__ast__Table_register_type_symbol(v__ast__Table* t, v__ast__TypeSymbol sym);
void v__ast__Table_register_enum_decl(v__ast__Table* t, v__ast__EnumDecl enum_decl);
bool v__ast__Table_known_type(v__ast__Table* t, string name);
bool v__ast__Table_known_type_idx(v__ast__Table* t, v__ast__Type typ);
string v__ast__Table_array_name(v__ast__Table* t, v__ast__Type elem_type);
string v__ast__Table_array_cname(v__ast__Table* t, v__ast__Type elem_type);
string v__ast__Table_array_fixed_name(v__ast__Table* t, v__ast__Type elem_type, int size, v__ast__Expr size_expr);
string v__ast__Table_array_fixed_cname(v__ast__Table* t, v__ast__Type elem_type, int size);
string v__ast__Table_chan_name(v__ast__Table* t, v__ast__Type elem_type, bool is_mut);
string v__ast__Table_chan_cname(v__ast__Table* t, v__ast__Type elem_type, bool is_mut);
string v__ast__Table_promise_name(v__ast__Table* t, v__ast__Type return_type);
string v__ast__Table_promise_cname(v__ast__Table* t, v__ast__Type return_type);
string v__ast__Table_thread_name(v__ast__Table* t, v__ast__Type return_type);
string v__ast__Table_thread_cname(v__ast__Table* t, v__ast__Type return_type);
string v__ast__Table_map_name(v__ast__Table* t, v__ast__Type key_type, v__ast__Type value_type);
string v__ast__Table_map_cname(v__ast__Table* t, v__ast__Type key_type, v__ast__Type value_type);
int v__ast__Table_find_or_register_chan(v__ast__Table* t, v__ast__Type elem_type, bool is_mut);
int v__ast__Table_find_or_register_map(v__ast__Table* t, v__ast__Type key_type, v__ast__Type value_type);
int v__ast__Table_find_or_register_thread(v__ast__Table* t, v__ast__Type return_type);
int v__ast__Table_find_or_register_promise(v__ast__Table* t, v__ast__Type return_type);
int v__ast__Table_find_or_register_array(v__ast__Table* t, v__ast__Type elem_type);
int v__ast__Table_find_or_register_array_with_dims(v__ast__Table* t, v__ast__Type elem_type, int nr_dims);
int v__ast__Table_find_or_register_array_fixed(v__ast__Table* t, v__ast__Type elem_type, int size, v__ast__Expr size_expr);
int v__ast__Table_find_or_register_multi_return(v__ast__Table* t, Array_v__ast__Type mr_typs);
int v__ast__Table_find_or_register_fn_type(v__ast__Table* t, string mod, v__ast__Fn f, bool is_anon, bool has_decl);
int v__ast__Table_add_placeholder_type(v__ast__Table* t, string name, v__ast__Language language);
v__ast__Type v__ast__Table_value_type(v__ast__Table* t, v__ast__Type typ);
void v__ast__Table_register_fn_generic_types(v__ast__Table* t, string fn_name);
bool v__ast__Table_register_fn_concrete_types(v__ast__Table* t, string fn_name, Array_v__ast__Type types);
bool v__ast__Table_sumtype_has_variant(v__ast__Table* t, v__ast__Type parent, v__ast__Type variant, bool is_as);
Array_string v__ast__Table_known_type_names(v__ast__Table* t);
bool v__ast__Table_has_deep_child_no_ref(v__ast__Table* t, v__ast__TypeSymbol* ts, string name);
void v__ast__Table_complete_interface_check(v__ast__Table* t);
v__ast__Type v__ast__Table_bitsize_to_type(v__ast__Table* t, int bit_size);
bool v__ast__Table_does_type_implement_interface(v__ast__Table* t, v__ast__Type typ, v__ast__Type inter_typ);
Option_v__ast__Type v__ast__Table_resolve_generic_to_concrete(v__ast__Table* t, v__ast__Type generic_type, Array_string generic_names, Array_v__ast__Type concrete_types);
v__ast__Type v__ast__Table_unwrap_generic_type(v__ast__Table* t, v__ast__Type typ, Array_string generic_names, Array_v__ast__Type concrete_types);
void v__ast__Table_generic_insts_to_concrete(v__ast__Table* t);
v__ast__Language v__ast__pref_arch_to_table_language(v__pref__Arch pref_arch);
string v__ast__ShareType_str(v__ast__ShareType t);
string v__ast__Type_atomic_typename(v__ast__Type t);
v__ast__ShareType v__ast__sharetype_from_flags(bool is_shared, bool is_atomic);
v__ast__ShareType v__ast__Type_share(v__ast__Type t);
int v__ast__Type_idx(v__ast__Type t);
bool v__ast__Type_is_void(v__ast__Type t);
bool v__ast__Type_is_full(v__ast__Type t);
int v__ast__Type_nr_muls(v__ast__Type t);
bool v__ast__Type_is_ptr(v__ast__Type t);
bool v__ast__Type_is_any_kind_of_pointer(v__ast__Type t);
v__ast__Type v__ast__Type_set_nr_muls(v__ast__Type t, int nr_muls);
v__ast__Type v__ast__Type_ref(v__ast__Type t);
v__ast__Type v__ast__Type_deref(v__ast__Type t);
v__ast__Type v__ast__Type_set_flag(v__ast__Type t, v__ast__TypeFlag flag);
v__ast__Type v__ast__Type_clear_flag(v__ast__Type t, v__ast__TypeFlag flag);
v__ast__Type v__ast__Type_clear_flags(v__ast__Type t);
bool v__ast__Type_has_flag(v__ast__Type t, v__ast__TypeFlag flag);
Array_string v__ast__TypeSymbol_debug(v__ast__TypeSymbol* ts);
Array_string v__ast__TypeSymbol_dbg(v__ast__TypeSymbol* ts);
VV_LOCAL_SYMBOL void v__ast__TypeSymbol_dbg_common(v__ast__TypeSymbol* ts, Array_string* res);
string v__ast__Type_str(v__ast__Type t);
string v__ast__Table_type_str(v__ast__Table* t, v__ast__Type typ);
Array_string v__ast__Type_debug(v__ast__Type t);
v__ast__Type v__ast__Type_derive(v__ast__Type t, v__ast__Type t_from);
v__ast__Type v__ast__Type_derive_add_muls(v__ast__Type t, v__ast__Type t_from);
v__ast__Type v__ast__new_type(int idx);
v__ast__Type v__ast__new_type_ptr(int idx, int nr_muls);
bool v__ast__Type_is_pointer(v__ast__Type typ);
bool v__ast__Type_is_real_pointer(v__ast__Type typ);
bool v__ast__Type_is_float(v__ast__Type typ);
bool v__ast__Type_is_int(v__ast__Type typ);
bool v__ast__Type_is_int_valptr(v__ast__Type typ);
bool v__ast__Type_is_float_valptr(v__ast__Type typ);
bool v__ast__Type_is_pure_int(v__ast__Type typ);
bool v__ast__Type_is_pure_float(v__ast__Type typ);
bool v__ast__Type_is_signed(v__ast__Type typ);
bool v__ast__Type_is_unsigned(v__ast__Type typ);
bool v__ast__Type_is_int_literal(v__ast__Type typ);
bool v__ast__Type_is_number(v__ast__Type typ);
bool v__ast__Type_is_string(v__ast__Type typ);
bool v__ast__Type_is_bool(v__ast__Type typ);
#define _const_v__ast__void_type_idx 1
#define _const_v__ast__voidptr_type_idx 2
#define _const_v__ast__byteptr_type_idx 3
#define _const_v__ast__charptr_type_idx 4
#define _const_v__ast__i8_type_idx 5
#define _const_v__ast__i16_type_idx 6
#define _const_v__ast__int_type_idx 7
#define _const_v__ast__i64_type_idx 8
#define _const_v__ast__isize_type_idx 9
#define _const_v__ast__byte_type_idx 10
#define _const_v__ast__u16_type_idx 11
#define _const_v__ast__u32_type_idx 12
#define _const_v__ast__u64_type_idx 13
#define _const_v__ast__usize_type_idx 14
#define _const_v__ast__f32_type_idx 15
#define _const_v__ast__f64_type_idx 16
#define _const_v__ast__char_type_idx 17
#define _const_v__ast__bool_type_idx 18
#define _const_v__ast__none_type_idx 19
#define _const_v__ast__string_type_idx 20
#define _const_v__ast__rune_type_idx 21
#define _const_v__ast__array_type_idx 22
#define _const_v__ast__map_type_idx 23
#define _const_v__ast__chan_type_idx 24
#define _const_v__ast__any_type_idx 25
#define _const_v__ast__float_literal_type_idx 26
#define _const_v__ast__int_literal_type_idx 27
#define _const_v__ast__thread_type_idx 28
#define _const_v__ast__error_type_idx 29
#define _const_v__ast__u8_type_idx 30
Array_string _const_v__ast__builtin_type_names; // inited later
v__token__KeywordsMatcher _const_v__ast__builtin_type_names_matcher; // inited later
Array_int _const_v__ast__integer_type_idxs; // inited later
Array_int _const_v__ast__signed_integer_type_idxs; // inited later
Array_int _const_v__ast__unsigned_integer_type_idxs; // inited later
Array_int _const_v__ast__float_type_idxs; // inited later
Array_int _const_v__ast__number_type_idxs; // inited later
Array_int _const_v__ast__pointer_type_idxs; // inited later
Array_int _const_v__ast__string_type_idxs; // inited later
v__ast__Type _const_v__ast__void_type; // inited later
v__ast__Type _const_v__ast__ovoid_type; // inited later
v__ast__Type _const_v__ast__voidptr_type; // inited later
v__ast__Type _const_v__ast__byteptr_type; // inited later
v__ast__Type _const_v__ast__charptr_type; // inited later
v__ast__Type _const_v__ast__i8_type; // inited later
v__ast__Type _const_v__ast__int_type; // inited later
v__ast__Type _const_v__ast__i16_type; // inited later
v__ast__Type _const_v__ast__i64_type; // inited later
v__ast__Type _const_v__ast__isize_type; // inited later
v__ast__Type _const_v__ast__byte_type; // inited later
v__ast__Type _const_v__ast__u8_type; // inited later
v__ast__Type _const_v__ast__u16_type; // inited later
v__ast__Type _const_v__ast__u32_type; // inited later
v__ast__Type _const_v__ast__u64_type; // inited later
v__ast__Type _const_v__ast__usize_type; // inited later
v__ast__Type _const_v__ast__f32_type; // inited later
v__ast__Type _const_v__ast__f64_type; // inited later
v__ast__Type _const_v__ast__char_type; // inited later
v__ast__Type _const_v__ast__bool_type; // inited later
v__ast__Type _const_v__ast__none_type; // inited later
v__ast__Type _const_v__ast__string_type; // inited later
v__ast__Type _const_v__ast__rune_type; // inited later
v__ast__Type _const_v__ast__array_type; // inited later
v__ast__Type _const_v__ast__map_type; // inited later
v__ast__Type _const_v__ast__chan_type; // inited later
v__ast__Type _const_v__ast__any_type; // inited later
v__ast__Type _const_v__ast__float_literal_type; // inited later
v__ast__Type _const_v__ast__int_literal_type; // inited later
v__ast__Type _const_v__ast__thread_type; // inited later
v__ast__Type _const_v__ast__error_type; // inited later
Array_v__ast__Type _const_v__ast__charptr_types; // inited later
Array_v__ast__Type _const_v__ast__byteptr_types; // inited later
Array_v__ast__Type _const_v__ast__voidptr_types; // inited later
Array_v__ast__Type _const_v__ast__cptr_types; // inited later
Array_v__ast__Type v__ast__merge_types(Array_Array_v__ast__Type params);
v__ast__Type v__ast__mktyp(v__ast__Type typ);
v__ast__Kind v__ast__Table_type_kind(v__ast__Table* t, v__ast__Type typ);
string v__ast__TypeSymbol_str(v__ast__TypeSymbol* t);
VV_LOCAL_SYMBOL void v__ast__TypeSymbol_no_info_panic(v__ast__TypeSymbol* t, string fname);
v__ast__Enum v__ast__TypeSymbol_enum_info(v__ast__TypeSymbol* t);
v__ast__MultiReturn v__ast__TypeSymbol_mr_info(v__ast__TypeSymbol* t);
v__ast__Array v__ast__TypeSymbol_array_info(v__ast__TypeSymbol* t);
v__ast__ArrayFixed v__ast__TypeSymbol_array_fixed_info(v__ast__TypeSymbol* t);
v__ast__Chan v__ast__TypeSymbol_chan_info(v__ast__TypeSymbol* t);
v__ast__Thread v__ast__TypeSymbol_thread_info(v__ast__TypeSymbol* t);
v__ast__Map v__ast__TypeSymbol_map_info(v__ast__TypeSymbol* t);
v__ast__Struct v__ast__TypeSymbol_struct_info(v__ast__TypeSymbol* t);
v__ast__SumType v__ast__TypeSymbol_sumtype_info(v__ast__TypeSymbol* t);
bool v__ast__TypeSymbol_is_heap(v__ast__TypeSymbol* t);
void v__ast__Table_register_builtin_type_symbols(v__ast__Table* t);
bool v__ast__TypeSymbol_is_pointer(v__ast__TypeSymbol* t);
bool v__ast__TypeSymbol_is_int(v__ast__TypeSymbol* t);
bool v__ast__TypeSymbol_is_float(v__ast__TypeSymbol* t);
bool v__ast__TypeSymbol_is_string(v__ast__TypeSymbol* t);
bool v__ast__TypeSymbol_is_number(v__ast__TypeSymbol* t);
bool v__ast__TypeSymbol_is_primitive(v__ast__TypeSymbol* t);
bool v__ast__TypeSymbol_is_builtin(v__ast__TypeSymbol* t);
string v__ast__Kind_str(v__ast__Kind k);
string Array_v__ast__Kind_str(Array_v__ast__Kind kinds);
bool v__ast__StructField_equals(v__ast__StructField* f, v__ast__StructField* o);
string v__ast__Table_type_to_str(v__ast__Table* t, v__ast__Type typ);
string v__ast__Table_type_to_code(v__ast__Table* mytable, v__ast__Type t);
string v__ast__Table_type_to_str_using_aliases(v__ast__Table* t, v__ast__Type typ, Map_string_string import_aliases);
VV_LOCAL_SYMBOL string v__ast__Table_shorten_user_defined_typenames(v__ast__Table* t, string originalname, Map_string_string import_aliases);
string v__ast__Table_fn_signature(v__ast__Table* t, v__ast__Fn* func, v__ast__FnSignatureOpts opts);
string v__ast__Table_fn_signature_using_aliases(v__ast__Table* t, v__ast__Fn* func, Map_string_string import_aliases, v__ast__FnSignatureOpts opts);
string v__ast__TypeSymbol_embed_name(v__ast__TypeSymbol* t);
bool v__ast__TypeSymbol_has_method(v__ast__TypeSymbol* t, string name);
bool v__ast__TypeSymbol_has_method_with_generic_parent(v__ast__TypeSymbol* t, string name);
Option_v__ast__Fn v__ast__TypeSymbol_find_method(v__ast__TypeSymbol* t, string name);
Option_v__ast__Fn v__ast__TypeSymbol_find_method_with_generic_parent(v__ast__TypeSymbol* t, string name);
bool v__ast__TypeSymbol_is_js_compatible(v__ast__TypeSymbol* t);
multi_return_bool_bool_int v__ast__TypeSymbol_str_method_info(v__ast__TypeSymbol* t);
Option_v__ast__StructField v__ast__TypeSymbol_find_field(v__ast__TypeSymbol* t, string name);
VV_LOCAL_SYMBOL Option_v__ast__StructField v__ast__Aggregate_find_field(v__ast__Aggregate* a, string name);
Option_v__ast__StructField v__ast__Interface_find_field(v__ast__Interface* i, string name);
Option_v__ast__Fn v__ast__Interface_find_method(v__ast__Interface* i, string name);
bool v__ast__Interface_has_method(v__ast__Interface* i, string name);
Option_v__ast__StructField v__ast__Struct_find_field(v__ast__Struct* s, string name);
v__ast__StructField v__ast__Struct_get_field(v__ast__Struct* s, string name);
Option_v__ast__StructField v__ast__SumType_find_field(v__ast__SumType* s, string name);
bool v__ast__Interface_defines_method(v__ast__Interface* i, string name);
void v__checker__Checker_assign_stmt(v__checker__Checker* c, v__ast__AssignStmt* node);
bool v__checker__Checker_check_types(v__checker__Checker* c, v__ast__Type got, v__ast__Type expected);
Option_void v__checker__Checker_check_expected_call_arg(v__checker__Checker* c, v__ast__Type got, v__ast__Type expected_, v__ast__Language language, v__ast__CallArg arg);
bool v__checker__Checker_check_basic(v__checker__Checker* c, v__ast__Type got, v__ast__Type expected);
bool v__checker__Checker_check_matching_function_symbols(v__checker__Checker* c, v__ast__TypeSymbol* got_type_sym, v__ast__TypeSymbol* exp_type_sym);
VV_LOCAL_SYMBOL v__ast__Type v__checker__Checker_check_shift(v__checker__Checker* c, v__ast__InfixExpr* node, v__ast__Type left_type, v__ast__Type right_type);
v__ast__Type v__checker__Checker_promote(v__checker__Checker* c, v__ast__Type left_type, v__ast__Type right_type);
VV_LOCAL_SYMBOL v__ast__Type v__checker__Checker_promote_num(v__checker__Checker* c, v__ast__Type left_type, v__ast__Type right_type);
Option_void v__checker__Checker_check_expected(v__checker__Checker* c, v__ast__Type got, v__ast__Type expected);
VV_LOCAL_SYMBOL string v__checker__Checker_expected_msg(v__checker__Checker* c, v__ast__Type got, v__ast__Type expected);
bool v__checker__Checker_symmetric_check(v__checker__Checker* c, v__ast__Type left, v__ast__Type right);
byte v__checker__Checker_get_default_fmt(v__checker__Checker* c, v__ast__Type ftyp, v__ast__Type typ);
void v__checker__Checker_fail_if_unreadable(v__checker__Checker* c, v__ast__Expr expr, v__ast__Type typ, string what);
v__ast__Type v__checker__Checker_string_inter_lit(v__checker__Checker* c, v__ast__StringInterLiteral* node);
string _const_v__checker__hex_lit_overflow_message; // a string literal, inited later
v__ast__Type v__checker__Checker_string_lit(v__checker__Checker* c, v__ast__StringLiteral* node);
v__ast__Type v__checker__Checker_int_lit(v__checker__Checker* c, v__ast__IntegerLiteral* node);
void v__checker__Checker_infer_fn_generic_types(v__checker__Checker* c, v__ast__Fn func, v__ast__CallExpr* node);
int _const_v__checker__int_min; // inited later
int _const_v__checker__int_max = 2147483647; // precomputed
Array_string _const_v__checker__valid_comptime_if_os; // inited later
Array_string _const_v__checker__valid_comptime_compression_types; // inited later
Array_string _const_v__checker__valid_comptime_if_compilers; // inited later
Array_string _const_v__checker__valid_comptime_if_platforms; // inited later
Array_string _const_v__checker__valid_comptime_if_cpu_features; // inited later
Array_string _const_v__checker__valid_comptime_if_other; // inited later
Array_string _const_v__checker__valid_comptime_not_user_defined; // inited later
Array_string _const_v__checker__array_builtin_methods; // inited later
Array_string _const_v__checker__reserved_type_names; // inited later
string _const_v__checker__vroot_is_deprecated_message; // a string literal, inited later
VV_LOCAL_SYMBOL Array_string v__checker__all_valid_comptime_idents(void);
v__checker__Checker* v__checker__new_checker(v__ast__Table* table, v__pref__Preferences* pref);
VV_LOCAL_SYMBOL void v__checker__Checker_reset_checker_state_at_start_of_new_file(v__checker__Checker* c);
void v__checker__Checker_check(v__checker__Checker* c, v__ast__File* ast_file_);
void v__checker__Checker_check_scope_vars(v__checker__Checker* c, v__ast__Scope* sc);
Array_v__errors__Error v__checker__Checker_check2(v__checker__Checker* c, v__ast__File* ast_file);
void v__checker__Checker_change_current_file(v__checker__Checker* c, v__ast__File* file);
void v__checker__Checker_check_files(v__checker__Checker* c, Array_v__ast__File_ptr ast_files);
VV_LOCAL_SYMBOL bool v__checker__Checker_file_has_main_fn(v__checker__Checker* c, v__ast__File* file);
VV_LOCAL_SYMBOL void v__checker__Checker_check_valid_snake_case(v__checker__Checker* c, string name, string identifier, v__token__Position pos);
VV_LOCAL_SYMBOL string v__checker__stripped_name(string name);
VV_LOCAL_SYMBOL void v__checker__Checker_check_valid_pascal_case(v__checker__Checker* c, string name, string identifier, v__token__Position pos);
void v__checker__Checker_type_decl(v__checker__Checker* c, v__ast__TypeDecl node);
void v__checker__Checker_alias_type_decl(v__checker__Checker* c, v__ast__AliasTypeDecl node);
void v__checker__Checker_fn_type_decl(v__checker__Checker* c, v__ast__FnTypeDecl node);
void v__checker__Checker_sum_type_decl(v__checker__Checker* c, v__ast__SumTypeDecl node);
Array_v__ast__InterfaceEmbedding v__checker__Checker_expand_iface_embeds(v__checker__Checker* c, v__ast__InterfaceDecl* idecl, int level, Array_v__ast__InterfaceEmbedding iface_embeds);
VV_LOCAL_SYMBOL void v__checker__Checker_check_div_mod_by_zero(v__checker__Checker* c, v__ast__Expr expr, v__token__Kind op_kind);
v__ast__Type v__checker__Checker_infix_expr(v__checker__Checker* c, v__ast__InfixExpr* node);
VV_LOCAL_SYMBOL multi_return_string_v__token__Position v__checker__Checker_fail_if_immutable(v__checker__Checker* c, v__ast__Expr expr);
VV_LOCAL_SYMBOL bool v__checker__Checker_type_implements(v__checker__Checker* c, v__ast__Type typ, v__ast__Type interface_type, v__token__Position pos);
v__ast__Type v__checker__Checker_check_expr_opt_call(v__checker__Checker* c, v__ast__Expr expr, v__ast__Type ret_type);
void v__checker__Checker_check_or_expr(v__checker__Checker* c, v__ast__OrExpr node, v__ast__Type ret_type, v__ast__Type expr_return_type);
v__ast__Type v__checker__Checker_selector_expr(v__checker__Checker* c, v__ast__SelectorExpr* node);
void v__checker__Checker_const_decl(v__checker__Checker* c, v__ast__ConstDecl* node);
void v__checker__Checker_enum_decl(v__checker__Checker* c, v__ast__EnumDecl* node);
VV_LOCAL_SYMBOL void v__checker__Checker_check_loop_label(v__checker__Checker* c, string label, v__token__Position pos);
VV_LOCAL_SYMBOL void v__checker__Checker_stmt(v__checker__Checker* c, v__ast__Stmt node);
VV_LOCAL_SYMBOL void v__checker__Checker_assert_stmt(v__checker__Checker* c, v__ast__AssertStmt node);
VV_LOCAL_SYMBOL void v__checker__Checker_block(v__checker__Checker* c, v__ast__Block node);
VV_LOCAL_SYMBOL void v__checker__Checker_branch_stmt(v__checker__Checker* c, v__ast__BranchStmt node);
VV_LOCAL_SYMBOL void v__checker__Checker_global_decl(v__checker__Checker* c, v__ast__GlobalDecl* node);
VV_LOCAL_SYMBOL v__ast__Type v__checker__Checker_go_expr(v__checker__Checker* c, v__ast__GoExpr* node);
VV_LOCAL_SYMBOL void v__checker__Checker_asm_stmt(v__checker__Checker* c, v__ast__AsmStmt* stmt);
VV_LOCAL_SYMBOL void v__checker__Checker_asm_arg(v__checker__Checker* c, v__ast__AsmArg arg, v__ast__AsmStmt stmt, Array_string aliases);
VV_LOCAL_SYMBOL Array_string v__checker__Checker_asm_ios(v__checker__Checker* c, Array_v__ast__AsmIO ios, v__ast__Scope* scope, bool output);
VV_LOCAL_SYMBOL void v__checker__Checker_hash_stmt(v__checker__Checker* c, v__ast__HashStmt* node);
VV_LOCAL_SYMBOL void v__checker__Checker_import_stmt(v__checker__Checker* c, v__ast__Import node);
VV_LOCAL_SYMBOL void v__checker__Checker_stmts(v__checker__Checker* c, Array_v__ast__Stmt stmts);
VV_LOCAL_SYMBOL void v__checker__Checker_stmts_ending_with_expression(v__checker__Checker* c, Array_v__ast__Stmt stmts);
v__ast__Type v__checker__Checker_unwrap_generic(v__checker__Checker* c, v__ast__Type typ);
v__ast__Type v__checker__Checker_expr(v__checker__Checker* c, v__ast__Expr node);
v__ast__Type v__checker__Checker_cast_expr(v__checker__Checker* c, v__ast__CastExpr* node);
VV_LOCAL_SYMBOL v__ast__Type v__checker__Checker_at_expr(v__checker__Checker* c, v__ast__AtExpr* node);
v__ast__Type v__checker__Checker_ident(v__checker__Checker* c, v__ast__Ident* node);
v__ast__Type v__checker__Checker_concat_expr(v__checker__Checker* c, v__ast__ConcatExpr* node);
VV_LOCAL_SYMBOL void v__checker__Checker_smartcast(v__checker__Checker* c, v__ast__Expr expr, v__ast__Type cur_type, v__ast__Type to_type_, v__ast__Scope* scope);
v__ast__Type v__checker__Checker_select_expr(v__checker__Checker* c, v__ast__SelectExpr* node);
v__ast__Type v__checker__Checker_lock_expr(v__checker__Checker* c, v__ast__LockExpr* node);
v__ast__Type v__checker__Checker_unsafe_expr(v__checker__Checker* c, v__ast__UnsafeExpr* node);
VV_LOCAL_SYMBOL Option_v__ast__Expr v__checker__Checker_find_definition(v__checker__Checker* c, v__ast__Ident ident);
VV_LOCAL_SYMBOL Option_v__ast__Expr v__checker__Checker_find_obj_definition(v__checker__Checker* c, v__ast__ScopeObject obj);
VV_LOCAL_SYMBOL Option_bool v__checker__Checker_has_return(v__checker__Checker* c, Array_v__ast__Stmt stmts);
v__ast__Type v__checker__Checker_postfix_expr(v__checker__Checker* c, v__ast__PostfixExpr* node);
void v__checker__Checker_mark_as_referenced(v__checker__Checker* c, v__ast__Expr* node, bool as_interface);
string v__checker__Checker_get_base_name(v__checker__Checker* c, v__ast__Expr* node);
v__ast__Type v__checker__Checker_prefix_expr(v__checker__Checker* c, v__ast__PrefixExpr* node);
VV_LOCAL_SYMBOL void v__checker__Checker_check_index(v__checker__Checker* c, v__ast__TypeSymbol* typ_sym, v__ast__Expr index, v__ast__Type index_type, v__token__Position pos, bool range_index, bool is_gated);
v__ast__Type v__checker__Checker_index_expr(v__checker__Checker* c, v__ast__IndexExpr* node);
v__ast__Type v__checker__Checker_enum_val(v__checker__Checker* c, v__ast__EnumVal* node);
v__ast__Type v__checker__Checker_chan_init(v__checker__Checker* c, v__ast__ChanInit* node);
v__ast__Type v__checker__Checker_offset_of(v__checker__Checker* c, v__ast__OffsetOf node);
void v__checker__Checker_check_dup_keys(v__checker__Checker* c, v__ast__MapInit* node, int i);
void v__checker__Checker_add_error_detail(v__checker__Checker* c, string s);
void v__checker__Checker_warn(v__checker__Checker* c, string s, v__token__Position pos);
void v__checker__Checker_error(v__checker__Checker* c, string message, v__token__Position pos);
VV_LOCAL_SYMBOL bool v__checker__Checker_check_struct_signature(v__checker__Checker* c, v__ast__Struct from, v__ast__Struct to);
void v__checker__Checker_note(v__checker__Checker* c, string message, v__token__Position pos);
VV_LOCAL_SYMBOL void v__checker__Checker_warn_or_error(v__checker__Checker* c, string message, v__token__Position pos, bool warn);
VV_LOCAL_SYMBOL bool v__checker__Checker_fileis(v__checker__Checker* c, string s);
VV_LOCAL_SYMBOL string v__checker__Checker_fetch_field_name(v__checker__Checker* c, v__ast__StructField field);
VV_LOCAL_SYMBOL void v__checker__Checker_trace(v__checker__Checker* c, string fbase, string message);
VV_LOCAL_SYMBOL Option_void v__checker__Checker_ensure_type_exists(v__checker__Checker* c, v__ast__Type typ, v__token__Position pos);
VV_LOCAL_SYMBOL v__ast__Type v__checker__Checker_comptime_call(v__checker__Checker* c, v__ast__ComptimeCall* node);
VV_LOCAL_SYMBOL void v__checker__Checker_comptime_for(v__checker__Checker* c, v__ast__ComptimeFor node);
VV_LOCAL_SYMBOL Option_v__ast__ComptTimeConstValue v__checker__Checker_eval_comptime_const_expr(v__checker__Checker* c, v__ast__Expr expr, int nlevel);
VV_LOCAL_SYMBOL multi_return_bool_int_int v__checker__Checker_verify_vweb_params_for_method(v__checker__Checker* c, v__ast__Fn node);
VV_LOCAL_SYMBOL void v__checker__Checker_verify_all_vweb_routes(v__checker__Checker* c);
VV_LOCAL_SYMBOL bool v__checker__Checker_evaluate_once_comptime_if_attribute(v__checker__Checker* c, v__ast__Attr* node);
VV_LOCAL_SYMBOL bool v__checker__Checker_comptime_if_branch(v__checker__Checker* c, v__ast__Expr cond, v__token__Position pos);
v__ast__Type v__checker__Checker_array_init(v__checker__Checker* c, v__ast__ArrayInit* node);
VV_LOCAL_SYMBOL void v__checker__Checker_check_array_init_para_type(v__checker__Checker* c, string para, v__ast__Expr expr, v__token__Position pos);
void v__checker__Checker_ensure_sumtype_array_has_default_value(v__checker__Checker* c, v__ast__ArrayInit node);
v__ast__Type v__checker__Checker_map_init(v__checker__Checker* c, v__ast__MapInit* node);
VV_LOCAL_SYMBOL void v__checker__Checker_fn_decl(v__checker__Checker* c, v__ast__FnDecl* node);
VV_LOCAL_SYMBOL v__ast__Type v__checker__Checker_anon_fn(v__checker__Checker* c, v__ast__AnonFn* node);
v__ast__Type v__checker__Checker_call_expr(v__checker__Checker* c, v__ast__CallExpr* node);
v__ast__Type v__checker__Checker_fn_call(v__checker__Checker* c, v__ast__CallExpr* node, bool* continue_check);
v__ast__Type v__checker__Checker_method_call(v__checker__Checker* c, v__ast__CallExpr* node);
VV_LOCAL_SYMBOL void v__checker__Checker_deprecate_fnmethod(v__checker__Checker* c, string kind, string name, v__ast__Fn the_fn, v__ast__CallExpr node);
VV_LOCAL_SYMBOL string v__checker__semicolonize(string main, string details);
VV_LOCAL_SYMBOL void v__checker__Checker_post_process_generic_fns(v__checker__Checker* c);
Option_void v__checker__Checker_check_expected_arg_count(v__checker__Checker* c, v__ast__CallExpr* node, v__ast__Fn* f);
VV_LOCAL_SYMBOL void v__checker__Checker_check_map_and_filter(v__checker__Checker* c, bool is_map, v__ast__Type elem_typ, v__ast__CallExpr node);
VV_LOCAL_SYMBOL v__ast__Type v__checker__Checker_map_builtin_method_call(v__checker__Checker* c, v__ast__CallExpr* node, v__ast__Type left_type, v__ast__TypeSymbol left_sym);
VV_LOCAL_SYMBOL v__ast__Type v__checker__Checker_array_builtin_method_call(v__checker__Checker* c, v__ast__CallExpr* node, v__ast__Type left_type, v__ast__TypeSymbol left_sym);
VV_LOCAL_SYMBOL void v__checker__scope_register_it(v__ast__Scope* s, v__token__Position pos, v__ast__Type typ);
VV_LOCAL_SYMBOL void v__checker__scope_register_a_b(v__ast__Scope* s, v__token__Position pos, v__ast__Type typ);
VV_LOCAL_SYMBOL void v__checker__Checker_for_c_stmt(v__checker__Checker* c, v__ast__ForCStmt node);
VV_LOCAL_SYMBOL void v__checker__Checker_for_in_stmt(v__checker__Checker* c, v__ast__ForInStmt* node);
VV_LOCAL_SYMBOL void v__checker__Checker_for_stmt(v__checker__Checker* c, v__ast__ForStmt* node);
v__ast__Type v__checker__Checker_if_expr(v__checker__Checker* c, v__ast__IfExpr* node);
VV_LOCAL_SYMBOL void v__checker__Checker_smartcast_if_conds(v__checker__Checker* c, v__ast__Expr node, v__ast__Scope* scope);
void v__checker__Checker_interface_decl(v__checker__Checker* c, v__ast__InterfaceDecl* node);
VV_LOCAL_SYMBOL v__ast__Type v__checker__Checker_resolve_generic_interface(v__checker__Checker* c, v__ast__Type typ, v__ast__Type interface_type, v__token__Position pos);
v__ast__Type v__checker__Checker_match_expr(v__checker__Checker* c, v__ast__MatchExpr* node);
VV_LOCAL_SYMBOL void v__checker__Checker_match_exprs(v__checker__Checker* c, v__ast__MatchExpr* node, v__ast__TypeSymbol cond_type_sym);
VV_LOCAL_SYMBOL v__ast__Type v__checker__Checker_sql_expr(v__checker__Checker* c, v__ast__SqlExpr* node);
VV_LOCAL_SYMBOL v__ast__Type v__checker__Checker_sql_stmt(v__checker__Checker* c, v__ast__SqlStmt* node);
VV_LOCAL_SYMBOL v__ast__Type v__checker__Checker_sql_stmt_line(v__checker__Checker* c, v__ast__SqlStmtLine* node);
VV_LOCAL_SYMBOL Array_v__ast__StructField v__checker__Checker_fetch_and_verify_orm_fields(v__checker__Checker* c, v__ast__Struct info, v__token__Position pos, string table_name);
void v__checker__Checker_return_stmt(v__checker__Checker* c, v__ast__Return* node);
void v__checker__Checker_find_unreachable_statements_after_noreturn_calls(v__checker__Checker* c, Array_v__ast__Stmt stmts);
VV_LOCAL_SYMBOL bool v__checker__has_top_return(Array_v__ast__Stmt stmts);
VV_LOCAL_SYMBOL void v__checker__Checker_check_noreturn_fn_decl(v__checker__Checker* c, v__ast__FnDecl* node);
VV_LOCAL_SYMBOL bool v__checker__uses_return_stmt(Array_v__ast__Stmt stmts);
VV_LOCAL_SYMBOL bool v__checker__is_noreturn_callexpr(v__ast__Expr expr);
void v__checker__Checker_struct_decl(v__checker__Checker* c, v__ast__StructDecl* node);
v__ast__Type v__checker__Checker_struct_init(v__checker__Checker* c, v__ast__StructInit* node);
VV_LOCAL_SYMBOL bool v__transformer__IndexState_safe_access(v__transformer__IndexState* i, string key, int _v_new);
VV_LOCAL_SYMBOL int v__transformer__IndexState_safe_offset(v__transformer__IndexState* i, string key);
VV_LOCAL_SYMBOL void v__transformer__IndexState_indent(v__transformer__IndexState* i, bool is_function);
VV_LOCAL_SYMBOL void v__transformer__IndexState_unindent(v__transformer__IndexState* i);
v__transformer__Transformer* v__transformer__new_transformer(v__pref__Preferences* pref);
void v__transformer__Transformer_transform_files(v__transformer__Transformer* t, Array_v__ast__File_ptr ast_files);
void v__transformer__Transformer_transform(v__transformer__Transformer* t, v__ast__File* ast_file);
void v__transformer__Transformer_find_new_array_len(v__transformer__Transformer* t, v__ast__AssignStmt node);
void v__transformer__Transformer_find_new_range(v__transformer__Transformer* t, v__ast__AssignStmt node);
void v__transformer__Transformer_find_mut_self_assign(v__transformer__Transformer* t, v__ast__AssignStmt node);
void v__transformer__Transformer_find_assert_len(v__transformer__Transformer* t, v__ast__InfixExpr node);
void v__transformer__Transformer_check_safe_array(v__transformer__Transformer* t, v__ast__IndexExpr* node);
void v__transformer__Transformer_stmt(v__transformer__Transformer* t, v__ast__Stmt* node);
v__ast__Expr v__transformer__Transformer_expr(v__transformer__Transformer* t, v__ast__Expr node);
v__ast__Expr v__transformer__Transformer_if_expr(v__transformer__Transformer* t, v__ast__IfExpr* original);
v__ast__Expr v__transformer__Transformer_match_expr(v__transformer__Transformer* t, v__ast__MatchExpr* original);
v__ast__Expr v__transformer__Transformer_infix_expr(v__transformer__Transformer* t, v__ast__InfixExpr original);
void v__markused__mark_used(v__ast__Table* table, v__pref__Preferences* pref, Array_v__ast__File_ptr ast_files);
VV_LOCAL_SYMBOL multi_return_Map_string_v__ast__FnDecl_Map_string_v__ast__ConstField_Map_string_v__ast__GlobalField v__markused__all_fn_const_and_global(Array_v__ast__File_ptr ast_files);
void v__markused__Walker_mark_fn_as_used(v__markused__Walker* w, string fkey);
void v__markused__Walker_mark_const_as_used(v__markused__Walker* w, string ckey);
void v__markused__Walker_mark_global_as_used(v__markused__Walker* w, string ckey);
void v__markused__Walker_mark_root_fns(v__markused__Walker* w, Array_string all_fn_root_names);
void v__markused__Walker_mark_exported_fns(v__markused__Walker* w);
void v__markused__Walker_mark_markused_fns(v__markused__Walker* w);
void v__markused__Walker_mark_markused_consts(v__markused__Walker* w);
void v__markused__Walker_mark_markused_globals(v__markused__Walker* w);
void v__markused__Walker_stmt(v__markused__Walker* w, v__ast__Stmt node);
VV_LOCAL_SYMBOL void v__markused__Walker_asm_io(v__markused__Walker* w, Array_v__ast__AsmIO ios);
VV_LOCAL_SYMBOL void v__markused__Walker_defer_stmts(v__markused__Walker* w, Array_v__ast__DeferStmt stmts);
VV_LOCAL_SYMBOL void v__markused__Walker_stmts(v__markused__Walker* w, Array_v__ast__Stmt stmts);
VV_LOCAL_SYMBOL void v__markused__Walker_exprs(v__markused__Walker* w, Array_v__ast__Expr exprs);
VV_LOCAL_SYMBOL void v__markused__Walker_expr(v__markused__Walker* w, v__ast__Expr node);
void v__markused__Walker_fn_decl(v__markused__Walker* w, v__ast__FnDecl* node);
void v__markused__Walker_call_expr(v__markused__Walker* w, v__ast__CallExpr* node);
void v__markused__Walker_fn_by_name(v__markused__Walker* w, string fn_name);
void v__markused__Walker_struct_fields(v__markused__Walker* w, Array_v__ast__StructField sfields);
void v__markused__Walker_const_fields(v__markused__Walker* w, Array_v__ast__ConstField cfields);
void v__markused__Walker_or_block(v__markused__Walker* w, v__ast__OrExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_array_init(v__gen__c__Gen* g, v__ast__ArrayInit node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_array_map(v__gen__c__Gen* g, v__ast__CallExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_array_sort(v__gen__c__Gen* g, v__ast__CallExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_array_sort_call(v__gen__c__Gen* g, v__ast__CallExpr node, string compare_fn);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_array_filter(v__gen__c__Gen* g, v__ast__CallExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_array_insert(v__gen__c__Gen* g, v__ast__CallExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_array_prepend(v__gen__c__Gen* g, v__ast__CallExpr node);
VV_LOCAL_SYMBOL string v__gen__c__Gen_get_array_contains_method(v__gen__c__Gen* g, v__ast__Type typ);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_array_contains_methods(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_array_contains(v__gen__c__Gen* g, v__ast__Type typ, v__ast__Expr left, v__ast__Expr right);
VV_LOCAL_SYMBOL string v__gen__c__Gen_get_array_index_method(v__gen__c__Gen* g, v__ast__Type typ);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_array_index_methods(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_array_index(v__gen__c__Gen* g, v__ast__CallExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_array_wait(v__gen__c__Gen* g, v__ast__CallExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_array_any(v__gen__c__Gen* g, v__ast__CallExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_array_all(v__gen__c__Gen* g, v__ast__CallExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_assert_stmt(v__gen__c__Gen* g, v__ast__AssertStmt original_assert_statement);
IError _const_v__gen__c__unsupported_ctemp_assert_transform; // inited later
VV_LOCAL_SYMBOL Option_v__ast__Expr v__gen__c__Gen_assert_subexpression_to_ctemp(v__gen__c__Gen* g, v__ast__Expr expr, v__ast__Type expr_type);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_assert_postfailure_mode(v__gen__c__Gen* g, v__ast__AssertStmt node);
VV_LOCAL_SYMBOL string v__gen__c__Gen_gen_assert_metainfo(v__gen__c__Gen* g, v__ast__AssertStmt node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_assert_single_expr(v__gen__c__Gen* g, v__ast__Expr expr, v__ast__Type typ);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_assign_stmt(v__gen__c__Gen* g, v__ast__AssignStmt node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_multi_return_assign(v__gen__c__Gen* g, v__ast__AssignStmt* node, v__ast__Type return_type);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_assign_vars_autofree(v__gen__c__Gen* g, v__ast__AssignStmt* node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_cross_var_assign(v__gen__c__Gen* g, v__ast__AssignStmt* node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_cross_tmp_variable(v__gen__c__Gen* g, Array_v__ast__Expr left, v__ast__Expr val);
VV_LOCAL_SYMBOL string v__gen__c__Gen_equality_fn(v__gen__c__Gen* g, v__ast__Type typ);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_equality_fns(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL string v__gen__c__Gen_gen_sumtype_equality_fn(v__gen__c__Gen* g, v__ast__Type left_type);
VV_LOCAL_SYMBOL string v__gen__c__Gen_gen_struct_equality_fn(v__gen__c__Gen* g, v__ast__Type left_type);
VV_LOCAL_SYMBOL string v__gen__c__Gen_gen_alias_equality_fn(v__gen__c__Gen* g, v__ast__Type left_type);
VV_LOCAL_SYMBOL string v__gen__c__Gen_gen_array_equality_fn(v__gen__c__Gen* g, v__ast__Type left_type);
VV_LOCAL_SYMBOL string v__gen__c__Gen_gen_fixed_array_equality_fn(v__gen__c__Gen* g, v__ast__Type left_type);
VV_LOCAL_SYMBOL string v__gen__c__Gen_gen_map_equality_fn(v__gen__c__Gen* g, v__ast__Type left_type);
VV_LOCAL_SYMBOL string v__gen__c__Gen_gen_interface_equality_fn(v__gen__c__Gen* g, v__ast__Type left_type);
VV_LOCAL_SYMBOL string v__gen__c__Gen_gen_free_method_for_type(v__gen__c__Gen* g, v__ast__Type typ);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_free_for_struct(v__gen__c__Gen* g, v__ast__Struct info, string styp, string fn_name);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_free_for_array(v__gen__c__Gen* g, v__ast__Array info, string styp, string fn_name);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_free_for_map(v__gen__c__Gen* g, v__ast__Map info, string styp, string fn_name);
VV_LOCAL_SYMBOL string v__gen__c__styp_to_free_fn_name(string styp);
string v__gen__c__type_to_str(StrIntpType x);
string v__gen__c__data_str(StrIntpType x);
string _const_v__gen__c__si_s_code; // a string literal, inited later
VV_LOCAL_SYMBOL bool v__gen__c__should_use_indent_func(v__ast__Kind kind);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_default(v__gen__c__Gen* g, v__ast__TypeSymbol sym, string styp, string str_fn_name);
VV_LOCAL_SYMBOL string v__gen__c__Gen_get_str_fn(v__gen__c__Gen* g, v__ast__Type typ);
VV_LOCAL_SYMBOL void v__gen__c__Gen_final_gen_str(v__gen__c__Gen* g, v__gen__c__StrType typ);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_option(v__gen__c__Gen* g, v__ast__Type typ, string styp, string str_fn_name);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_alias(v__gen__c__Gen* g, v__ast__Alias info, string styp, string str_fn_name);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_multi_return(v__gen__c__Gen* g, v__ast__MultiReturn info, string styp, string str_fn_name);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_enum(v__gen__c__Gen* g, v__ast__Enum info, string styp, string str_fn_name);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_interface(v__gen__c__Gen* g, v__ast__Interface info, string styp, string str_fn_name);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_union_sum_type(v__gen__c__Gen* g, v__ast__SumType info, string styp, string str_fn_name);
VV_LOCAL_SYMBOL string v__gen__c__Gen_fn_decl_str(v__gen__c__Gen* g, v__ast__FnType info);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_fn_type(v__gen__c__Gen* g, v__ast__FnType info, string styp, string str_fn_name);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_chan(v__gen__c__Gen* g, v__ast__Chan info, string styp, string str_fn_name);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_thread(v__gen__c__Gen* g, v__ast__Thread info, string styp, string str_fn_name);
VV_LOCAL_SYMBOL string v__gen__c__styp_to_str_fn_name(string styp);
VV_LOCAL_SYMBOL multi_return_string_string v__gen__c__deref_kind(bool str_method_expects_ptr, bool is_elem_ptr, v__ast__Type typ);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_array(v__gen__c__Gen* g, v__ast__Array info, string styp, string str_fn_name);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_array_fixed(v__gen__c__Gen* g, v__ast__ArrayFixed info, string styp, string str_fn_name);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_map(v__gen__c__Gen* g, v__ast__Map info, string styp, string str_fn_name);
VV_LOCAL_SYMBOL StrIntpType v__gen__c__Gen_type_to_fmt(v__gen__c__Gen* g, v__ast__Type typ);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_struct(v__gen__c__Gen* g, v__ast__Struct info, string styp, string str_fn_name);
VV_LOCAL_SYMBOL multi_return_string_bool v__gen__c__struct_auto_str_func(v__ast__TypeSymbol* sym, v__ast__Type field_type, string fn_name, string field_name, bool has_custom_str, bool expects_ptr);
Array_string _const_v__gen__c__c_reserved; // inited later
Map_string_bool _const_v__gen__c__c_reserved_map; // inited later
Array_string _const_v__gen__c__cmp_str; // inited later
Array_string _const_v__gen__c__cmp_rev; // inited later
VV_LOCAL_SYMBOL Map_string_bool v__gen__c__string_array_to_map(Array_string a);
string v__gen__c__gen(Array_v__ast__File_ptr files, v__ast__Table* table, v__pref__Preferences* pref);
VV_LOCAL_SYMBOL v__gen__c__Gen* v__gen__c__cgen_process_one_file_cb(sync__pool__PoolProcessor* p, int idx, int wid);
void v__gen__c__Gen_free_builders(v__gen__c__Gen* g);
void v__gen__c__Gen_gen_file(v__gen__c__Gen* g);
string v__gen__c__Gen_hashes(v__gen__c__Gen* g);
void v__gen__c__Gen_init(v__gen__c__Gen* g);
void v__gen__c__Gen_finish(v__gen__c__Gen* g);
void v__gen__c__Gen_write_typeof_functions(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL string v__gen__c__Gen_typ(v__gen__c__Gen* g, v__ast__Type t);
VV_LOCAL_SYMBOL string v__gen__c__Gen_base_type(v__gen__c__Gen* g, v__ast__Type _t);
VV_LOCAL_SYMBOL string v__gen__c__Gen_generic_fn_name(v__gen__c__Gen* g, Array_v__ast__Type types, string before, bool is_decl);
VV_LOCAL_SYMBOL string v__gen__c__Gen_expr_string(v__gen__c__Gen* g, v__ast__Expr expr);
VV_LOCAL_SYMBOL string v__gen__c__Gen_expr_string_with_cast(v__gen__c__Gen* g, v__ast__Expr expr, v__ast__Type typ, v__ast__Type exp);
VV_LOCAL_SYMBOL string v__gen__c__Gen_expr_string_surround(v__gen__c__Gen* g, string prepend, v__ast__Expr expr, string append);
VV_LOCAL_SYMBOL multi_return_string_string v__gen__c__Gen_optional_type_name(v__gen__c__Gen* g, v__ast__Type t);
VV_LOCAL_SYMBOL string v__gen__c__Gen_optional_type_text(v__gen__c__Gen* g, string styp, string base);
VV_LOCAL_SYMBOL string v__gen__c__Gen_register_optional(v__gen__c__Gen* g, v__ast__Type t);
VV_LOCAL_SYMBOL void v__gen__c__Gen_write_optionals(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL string v__gen__c__Gen_find_or_register_shared(v__gen__c__Gen* g, v__ast__Type t, string base);
VV_LOCAL_SYMBOL void v__gen__c__Gen_write_shareds(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL void v__gen__c__Gen_register_thread_void_wait_call(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL string v__gen__c__Gen_register_thread_array_wait_call(v__gen__c__Gen* g, string eltyp);
VV_LOCAL_SYMBOL void v__gen__c__Gen_register_chan_pop_optional_call(v__gen__c__Gen* g, string opt_el_type, string styp);
VV_LOCAL_SYMBOL void v__gen__c__Gen_write_chan_pop_optional_fns(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL void v__gen__c__Gen_register_chan_push_optional_fn(v__gen__c__Gen* g, string el_type, string styp);
VV_LOCAL_SYMBOL void v__gen__c__Gen_write_chan_push_optional_fns(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL string v__gen__c__Gen_cc_type(v__gen__c__Gen* g, v__ast__Type typ, bool is_prefix_struct);
VV_LOCAL_SYMBOL string v__gen__c__Gen_type_sidx(v__gen__c__Gen* g, v__ast__Type t);
void v__gen__c__Gen_write_typedef_types(v__gen__c__Gen* g);
void v__gen__c__Gen_write_alias_typesymbol_declaration(v__gen__c__Gen* g, v__ast__TypeSymbol sym);
void v__gen__c__Gen_write_interface_typedef(v__gen__c__Gen* g, v__ast__TypeSymbol sym);
void v__gen__c__Gen_write_interface_typesymbol_declaration(v__gen__c__Gen* g, v__ast__TypeSymbol sym);
void v__gen__c__Gen_write_fn_typesymbol_declaration(v__gen__c__Gen* g, v__ast__TypeSymbol sym);
void v__gen__c__Gen_write_multi_return_types(v__gen__c__Gen* g);
void v__gen__c__Gen_write(v__gen__c__Gen* g, string s);
void v__gen__c__Gen_writeln(v__gen__c__Gen* g, string s);
string v__gen__c__Gen_new_tmp_var(v__gen__c__Gen* g);
string v__gen__c__Gen_new_global_tmp_var(v__gen__c__Gen* g);
string v__gen__c__Gen_new_tmp_declaration_name(v__gen__c__Gen* g);
string v__gen__c__Gen_current_tmp_var(v__gen__c__Gen* g);
void v__gen__c__Gen_reset_tmp_count(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL void v__gen__c__Gen_decrement_inside_ternary(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL void v__gen__c__Gen_stmts(v__gen__c__Gen* g, Array_v__ast__Stmt stmts);
VV_LOCAL_SYMBOL bool v__gen__c__is_noreturn_callexpr(v__ast__Expr expr);
VV_LOCAL_SYMBOL void v__gen__c__Gen_stmts_with_tmp_var(v__gen__c__Gen* g, Array_v__ast__Stmt stmts, string tmp_var);
VV_LOCAL_SYMBOL void v__gen__c__Gen_write_v_source_line_info(v__gen__c__Gen* g, v__token__Position pos);
VV_LOCAL_SYMBOL void v__gen__c__Gen_stmt(v__gen__c__Gen* g, v__ast__Stmt node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_write_defer_stmts(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL void v__gen__c__Gen_for_c_stmt(v__gen__c__Gen* g, v__ast__ForCStmt node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_for_stmt(v__gen__c__Gen* g, v__ast__ForStmt node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_for_in_stmt(v__gen__c__Gen* g, v__ast__ForInStmt node);
VV_LOCAL_SYMBOL string v__gen__c__Gen_get_sumtype_casting_fn(v__gen__c__Gen* g, v__ast__Type got_, v__ast__Type exp_);
VV_LOCAL_SYMBOL void v__gen__c__Gen_write_sumtype_casting_fn(v__gen__c__Gen* g, v__gen__c__SumtypeCastingFn fun);
VV_LOCAL_SYMBOL void v__gen__c__Gen_call_cfn_for_casting_expr(v__gen__c__Gen* g, string fname, v__ast__Expr expr, bool exp_is_ptr, string exp_styp, bool got_is_ptr, string got_styp);
VV_LOCAL_SYMBOL void v__gen__c__Gen_expr_with_cast(v__gen__c__Gen* g, v__ast__Expr expr, v__ast__Type got_type_raw, v__ast__Type expected_type);
VV_LOCAL_SYMBOL string v__gen__c__cestring(string s);
VV_LOCAL_SYMBOL string v__gen__c__ctoslit(string s);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_attrs(v__gen__c__Gen* g, Array_v__ast__Attr attrs);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_asm_stmt(v__gen__c__Gen* g, v__ast__AsmStmt stmt);
VV_LOCAL_SYMBOL void v__gen__c__Gen_asm_arg(v__gen__c__Gen* g, v__ast__AsmArg arg, v__ast__AsmStmt stmt);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_asm_ios(v__gen__c__Gen* g, Array_v__ast__AsmIO ios);
VV_LOCAL_SYMBOL string v__gen__c__cnewlines(string s);
VV_LOCAL_SYMBOL void v__gen__c__Gen_write_fn_ptr_decl(v__gen__c__Gen* g, v__ast__FnType* func, string ptr_name);
VV_LOCAL_SYMBOL void v__gen__c__Gen_register_ternary_name(v__gen__c__Gen* g, string name);
VV_LOCAL_SYMBOL string v__gen__c__Gen_get_ternary_name(v__gen__c__Gen* g, string name);
VV_LOCAL_SYMBOL bool v__gen__c__Gen_gen_clone_assignment(v__gen__c__Gen* g, v__ast__Expr val, v__ast__Type typ, bool add_eq);
VV_LOCAL_SYMBOL void v__gen__c__Gen_autofree_scope_vars(v__gen__c__Gen* g, int pos, int line_nr, bool free_parent_scopes);
VV_LOCAL_SYMBOL void v__gen__c__Gen_autofree_scope_vars_stop(v__gen__c__Gen* g, int pos, int line_nr, bool free_parent_scopes, int stop_pos);
VV_LOCAL_SYMBOL void v__gen__c__Gen_autofree_scope_vars2(v__gen__c__Gen* g, v__ast__Scope* scope, int start_pos, int end_pos, int line_nr, bool free_parent_scopes, int stop_pos);
VV_LOCAL_SYMBOL void v__gen__c__Gen_autofree_variable(v__gen__c__Gen* g, v__ast__Var v);
VV_LOCAL_SYMBOL void v__gen__c__Gen_autofree_var_call(v__gen__c__Gen* g, string free_fn_name, v__ast__Var v);
VV_LOCAL_SYMBOL multi_return_string_string_string_string v__gen__c__Gen_map_fn_ptrs(v__gen__c__Gen* g, v__ast__TypeSymbol key_typ);
VV_LOCAL_SYMBOL void v__gen__c__Gen_expr(v__gen__c__Gen* g, v__ast__Expr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_type_name(v__gen__c__Gen* g, v__ast__Type raw_type);
VV_LOCAL_SYMBOL void v__gen__c__Gen_typeof_expr(v__gen__c__Gen* g, v__ast__TypeOf node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_selector_expr(v__gen__c__Gen* g, v__ast__SelectorExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_enum_expr(v__gen__c__Gen* g, v__ast__Expr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_lock_expr(v__gen__c__Gen* g, v__ast__LockExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_unlock_locks(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL bool v__gen__c__Gen_need_tmp_var_in_match(v__gen__c__Gen* g, v__ast__MatchExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_match_expr(v__gen__c__Gen* g, v__ast__MatchExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_match_expr_sumtype(v__gen__c__Gen* g, v__ast__MatchExpr node, bool is_expr, string cond_var, string tmp_var);
VV_LOCAL_SYMBOL void v__gen__c__Gen_match_expr_switch(v__gen__c__Gen* g, v__ast__MatchExpr node, bool is_expr, string cond_var, string tmp_var, v__ast__TypeSymbol enum_typ);
VV_LOCAL_SYMBOL void v__gen__c__Gen_match_expr_classic(v__gen__c__Gen* g, v__ast__MatchExpr node, bool is_expr, string cond_var, string tmp_var);
VV_LOCAL_SYMBOL void v__gen__c__Gen_map_init(v__gen__c__Gen* g, v__ast__MapInit node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_select_expr(v__gen__c__Gen* g, v__ast__SelectExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_ident(v__gen__c__Gen* g, v__ast__Ident node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_cast_expr(v__gen__c__Gen* g, v__ast__CastExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_concat_expr(v__gen__c__Gen* g, v__ast__ConcatExpr node);
VV_LOCAL_SYMBOL bool v__gen__c__Gen_need_tmp_var_in_if(v__gen__c__Gen* g, v__ast__IfExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_if_expr(v__gen__c__Gen* g, v__ast__IfExpr node);
VV_LOCAL_SYMBOL bool v__gen__c__Gen_expr_is_multi_return_call(v__gen__c__Gen* g, v__ast__Expr expr);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_optional_error(v__gen__c__Gen* g, v__ast__Type target_type, v__ast__Expr expr);
VV_LOCAL_SYMBOL void v__gen__c__Gen_return_stmt(v__gen__c__Gen* g, v__ast__Return node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_const_decl(v__gen__c__Gen* g, v__ast__ConstDecl node);
VV_LOCAL_SYMBOL bool v__gen__c__Gen_const_decl_precomputed(v__gen__c__Gen* g, string mod, string name, v__ast__ComptTimeConstValue ct_value, v__ast__Type typ);
VV_LOCAL_SYMBOL void v__gen__c__Gen_const_decl_write_precomputed(v__gen__c__Gen* g, string styp, string cname, string ct_value);
VV_LOCAL_SYMBOL void v__gen__c__Gen_const_decl_simple_define(v__gen__c__Gen* g, string name, string val);
VV_LOCAL_SYMBOL void v__gen__c__Gen_const_decl_init_later(v__gen__c__Gen* g, string mod, string name, v__ast__Expr expr, v__ast__Type typ, bool unwrap_option);
VV_LOCAL_SYMBOL void v__gen__c__Gen_global_decl(v__gen__c__Gen* g, v__ast__GlobalDecl node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_go_back_out(v__gen__c__Gen* g, int n);
Array_string _const_v__gen__c__skip_struct_init; // inited later
VV_LOCAL_SYMBOL void v__gen__c__Gen_struct_init(v__gen__c__Gen* g, v__ast__StructInit node);
VV_LOCAL_SYMBOL bool v__gen__c__Gen_zero_struct_field(v__gen__c__Gen* g, v__ast__StructField field);
VV_LOCAL_SYMBOL void v__gen__c__Gen_assoc(v__gen__c__Gen* g, v__ast__Assoc node);
VV_LOCAL_SYMBOL void v__gen__c__verror(string s);
VV_LOCAL_SYMBOL void v__gen__c__Gen_error(v__gen__c__Gen* g, string s, v__token__Position pos);
VV_LOCAL_SYMBOL void v__gen__c__Gen_checker_bug(v__gen__c__Gen* g, string s, v__token__Position pos);
VV_LOCAL_SYMBOL void v__gen__c__Gen_write_init_function(v__gen__c__Gen* g);
Array_string _const_v__gen__c__builtins; // inited later
VV_LOCAL_SYMBOL void v__gen__c__Gen_write_builtin_types(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL void v__gen__c__Gen_write_sorted_types(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL void v__gen__c__Gen_write_types(v__gen__c__Gen* g, Array_v__ast__TypeSymbol_ptr symbols);
VV_LOCAL_SYMBOL Array_v__ast__TypeSymbol_ptr v__gen__c__Gen_sort_structs(v__gen__c__Gen* g, Array_v__ast__TypeSymbol_ptr typesa);
VV_LOCAL_SYMBOL int v__gen__c__Gen_nth_stmt_pos(v__gen__c__Gen* g, int n);
VV_LOCAL_SYMBOL void v__gen__c__Gen_set_current_pos_as_last_stmt_pos(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL string v__gen__c__Gen_go_before_stmt(v__gen__c__Gen* g, int n);
VV_LOCAL_SYMBOL string v__gen__c__Gen_go_before_ternary(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL void v__gen__c__Gen_insert_before_stmt(v__gen__c__Gen* g, string s);
VV_LOCAL_SYMBOL void v__gen__c__Gen_insert_at(v__gen__c__Gen* g, int pos, string s);
VV_LOCAL_SYMBOL void v__gen__c__Gen_or_block(v__gen__c__Gen* g, string var_name, v__ast__OrExpr or_block, v__ast__Type return_type);
VV_LOCAL_SYMBOL string v__gen__c__c_name(string name_);
VV_LOCAL_SYMBOL string v__gen__c__Gen_type_default(v__gen__c__Gen* g, v__ast__Type typ_);
VV_LOCAL_SYMBOL Array_string v__gen__c__Gen_get_all_test_function_names(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL void v__gen__c__Gen_size_of(v__gen__c__Gen* g, v__ast__SizeOf node);
VV_LOCAL_SYMBOL bool v__gen__c__Gen_is_importing_os(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL void v__gen__c__Gen_go_expr(v__gen__c__Gen* g, v__ast__GoExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_as_cast(v__gen__c__Gen* g, v__ast__AsCast node);
VV_LOCAL_SYMBOL string v__gen__c__Gen_as_cast_name_table(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL bool v__gen__c__Gen_has_been_referenced(v__gen__c__Gen* g, string fn_name);
VV_LOCAL_SYMBOL string v__gen__c__Gen_interface_table(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL multi_return_int_string_string_string v__gen__c__Gen_panic_debug_info(v__gen__c__Gen* g, v__token__Position pos);
string v__gen__c__get_guarded_include_text(string iname, string imessage);
VV_LOCAL_SYMBOL void v__gen__c__Gen_trace(v__gen__c__Gen* g, string fbase, string message);
int v__gen__c__Gen_get_array_depth(v__gen__c__Gen* g, v__ast__Type el_typ);
bool v__gen__c__Gen_contains_ptr(v__gen__c__Gen* g, v__ast__Type el_typ);
VV_LOCAL_SYMBOL string v__gen__c__Gen_check_noscan(v__gen__c__Gen* g, v__ast__Type elem_typ);
string _const_v__gen__c__c_commit_hash_default; // a string literal, inited later
string _const_v__gen__c__c_current_commit_hash_default; // a string literal, inited later
string _const_v__gen__c__c_concurrency_helpers; // a string literal, inited later
VV_LOCAL_SYMBOL string v__gen__c__arm64_bytes(int nargs);
VV_LOCAL_SYMBOL string v__gen__c__arm32_bytes(int nargs);
VV_LOCAL_SYMBOL string v__gen__c__amd64_bytes(int nargs);
VV_LOCAL_SYMBOL string v__gen__c__c_closure_helpers(v__pref__Preferences* pref);
string _const_v__gen__c__c_common_macros; // a string literal, inited later
string _const_v__gen__c__c_unsigned_comparison_functions; // a string literal, inited later
string _const_v__gen__c__c_helper_macros; // a string literal, inited later
string _const_v__gen__c__c_headers; // inited later
string _const_v__gen__c__c_builtin_types; // a string literal, inited later
string _const_v__gen__c__c_bare_headers; // inited later
string _const_v__gen__c__c_wyhash_headers; // a string literal, inited later
void v__gen__c__Gen_gen_c_main(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_vlines_reset(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_c_main_function_header(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_c_main_header(v__gen__c__Gen* g);
void v__gen__c__Gen_gen_c_main_footer(v__gen__c__Gen* g);
void v__gen__c__Gen_gen_c_android_sokol_main(v__gen__c__Gen* g);
void v__gen__c__Gen_write_tests_definitions(v__gen__c__Gen* g);
void v__gen__c__Gen_gen_failing_error_propagation_for_test_fn(v__gen__c__Gen* g, v__ast__OrExpr or_block, string cvar_name);
void v__gen__c__Gen_gen_failing_return_error_for_test_fn(v__gen__c__Gen* g, v__ast__Return return_stmt, string cvar_name);
void v__gen__c__Gen_gen_c_main_for_tests(v__gen__c__Gen* g);
Array_string v__gen__c__Gen_filter_only_matching_fn_names(v__gen__c__Gen* g, Array_string fnames);
VV_LOCAL_SYMBOL void v__gen__c__Gen_comptime_selector(v__gen__c__Gen* g, v__ast__ComptimeSelector node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_comptime_call(v__gen__c__Gen* g, v__ast__ComptimeCall* node);
VV_LOCAL_SYMBOL Array_string v__gen__c__cgen_attrs(Array_v__ast__Attr attrs);
VV_LOCAL_SYMBOL void v__gen__c__Gen_comptime_at(v__gen__c__Gen* g, v__ast__AtExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_comptime_if(v__gen__c__Gen* g, v__ast__IfExpr node);
VV_LOCAL_SYMBOL bool v__gen__c__Gen_comptime_if_cond(v__gen__c__Gen* g, v__ast__Expr cond, bool pkg_exist);
VV_LOCAL_SYMBOL void v__gen__c__Gen_comptime_for(v__gen__c__Gen* g, v__ast__ComptimeFor node);
VV_LOCAL_SYMBOL Option_string v__gen__c__Gen_comptime_if_to_ifdef(v__gen__c__Gen* g, string name, bool is_comptime_optional);
VV_LOCAL_SYMBOL v__ast__CTempVar v__gen__c__Gen_new_ctemp_var(v__gen__c__Gen* g, v__ast__Expr expr, v__ast__Type expr_type);
VV_LOCAL_SYMBOL v__ast__CTempVar v__gen__c__Gen_new_ctemp_var_then_gen(v__gen__c__Gen* g, v__ast__Expr expr, v__ast__Type expr_type);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_ctemp_var(v__gen__c__Gen* g, v__ast__CTempVar tvar);
VV_LOCAL_SYMBOL void v__gen__c__Gen_dump_expr(v__gen__c__Gen* g, v__ast__DumpExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_dump_expr_definitions(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL bool v__gen__c__Gen_writeln_fn_header(v__gen__c__Gen* g, string s, strings__Builder* sb);
VV_LOCAL_SYMBOL bool v__gen__c__Gen_embed_file_is_prod_mode(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_embed_file_init(v__gen__c__Gen* g, v__ast__ComptimeCall* node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_embedded_data(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL bool v__gen__c__Gen_is_used_by_main(v__gen__c__Gen* g, v__ast__FnDecl node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_fn_decl(v__gen__c__Gen* g, v__ast__FnDecl node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_fn_decl(v__gen__c__Gen* g, v__ast__FnDecl* node, bool skip);
string _const_v__gen__c__closure_ctx; // a string literal, inited later
VV_LOCAL_SYMBOL string v__gen__c__closure_ctx_struct(v__ast__FnDecl node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_anon_fn(v__gen__c__Gen* g, v__ast__AnonFn* node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_anon_fn_decl(v__gen__c__Gen* g, v__ast__AnonFn* node);
VV_LOCAL_SYMBOL string v__gen__c__Gen_defer_flag_var(v__gen__c__Gen* g, v__ast__DeferStmt* stmt);
VV_LOCAL_SYMBOL void v__gen__c__Gen_write_defer_stmts_when_needed(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL multi_return_Array_string_Array_string_Array_bool v__gen__c__Gen_fn_args(v__gen__c__Gen* g, Array_v__ast__Param args, v__ast__Scope* scope);
VV_LOCAL_SYMBOL void v__gen__c__Gen_call_expr(v__gen__c__Gen* g, v__ast__CallExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_conversion_function_call(v__gen__c__Gen* g, string prefix, string postfix, v__ast__CallExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_method_call(v__gen__c__Gen* g, v__ast__CallExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_fn_call(v__gen__c__Gen* g, v__ast__CallExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_autofree_call_pregen(v__gen__c__Gen* g, v__ast__CallExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_autofree_call_postgen(v__gen__c__Gen* g, int node_pos);
VV_LOCAL_SYMBOL void v__gen__c__Gen_call_args(v__gen__c__Gen* g, v__ast__CallExpr node);
VV_LOCAL_SYMBOL int v__gen__c__Gen_keep_alive_call_pregen(v__gen__c__Gen* g, v__ast__CallExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_keep_alive_call_postgen(v__gen__c__Gen* g, v__ast__CallExpr node, int tmp_cnt_save);
VV_LOCAL_SYMBOL void v__gen__c__Gen_ref_or_deref_arg(v__gen__c__Gen* g, v__ast__CallArg arg, v__ast__Type expected_type, v__ast__Language lang);
VV_LOCAL_SYMBOL bool v__gen__c__Gen_is_gui_app(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL bool v__gen__c__Gen_fileis(v__gen__c__Gen* g, string s);
VV_LOCAL_SYMBOL string v__gen__c__Gen_write_fn_attrs(v__gen__c__Gen* g, Array_v__ast__Attr attrs);
VV_LOCAL_SYMBOL void v__gen__c__Gen_index_expr(v__gen__c__Gen* g, v__ast__IndexExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_range_expr(v__gen__c__Gen* g, v__ast__IndexExpr node, v__ast__RangeExpr range);
VV_LOCAL_SYMBOL void v__gen__c__Gen_index_of_array(v__gen__c__Gen* g, v__ast__IndexExpr node, v__ast__TypeSymbol sym);
VV_LOCAL_SYMBOL void v__gen__c__Gen_index_of_fixed_array(v__gen__c__Gen* g, v__ast__IndexExpr node, v__ast__TypeSymbol sym);
VV_LOCAL_SYMBOL void v__gen__c__Gen_index_of_map(v__gen__c__Gen* g, v__ast__IndexExpr node, v__ast__TypeSymbol sym);
VV_LOCAL_SYMBOL void v__gen__c__Gen_infix_expr(v__gen__c__Gen* g, v__ast__InfixExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_infix_expr_arrow_op(v__gen__c__Gen* g, v__ast__InfixExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_infix_expr_eq_op(v__gen__c__Gen* g, v__ast__InfixExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_infix_expr_cmp_op(v__gen__c__Gen* g, v__ast__InfixExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_infix_expr_in_sumtype_interface_array(v__gen__c__Gen* g, Array_v__ast__InfixExpr infix_exprs);
VV_LOCAL_SYMBOL void v__gen__c__Gen_infix_expr_in_op(v__gen__c__Gen* g, v__ast__InfixExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_infix_expr_in_optimization(v__gen__c__Gen* g, v__ast__Expr left, v__ast__ArrayInit right);
VV_LOCAL_SYMBOL void v__gen__c__Gen_infix_expr_is_op(v__gen__c__Gen* g, v__ast__InfixExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_interface_is_op(v__gen__c__Gen* g, v__ast__InfixExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_infix_expr_arithmetic_op(v__gen__c__Gen* g, v__ast__InfixExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_infix_expr_left_shift_op(v__gen__c__Gen* g, v__ast__InfixExpr node);
VV_LOCAL_SYMBOL bool v__gen__c__Gen_need_tmp_var_in_array_call(v__gen__c__Gen* g, v__ast__Expr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_infix_expr_and_or_op(v__gen__c__Gen* g, v__ast__InfixExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_plain_infix_expr(v__gen__c__Gen* g, v__ast__InfixExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_op_arg(v__gen__c__Gen* g, v__ast__Expr expr, v__ast__Type expected, v__ast__Type got);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_safe_integer_infix_expr(v__gen__c__Gen* g, v__gen__c__GenSafeIntegerCfg cfg);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_json_for_type(v__gen__c__Gen* g, v__ast__Type typ);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_jsons(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_sumtype_enc_dec(v__gen__c__Gen* g, v__ast__TypeSymbol sym, strings__Builder* enc, strings__Builder* dec);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_struct_enc_dec(v__gen__c__Gen* g, v__ast__TypeInfo type_info, string styp, strings__Builder* enc, strings__Builder* dec);
VV_LOCAL_SYMBOL void v__gen__c__gen_js_get(string styp, string tmp, string name, strings__Builder* dec, bool is_required);
VV_LOCAL_SYMBOL void v__gen__c__gen_js_get_opt(string dec_name, string field_type, string styp, string tmp, string name, strings__Builder* dec, bool is_required);
VV_LOCAL_SYMBOL string v__gen__c__js_enc_name(string typ);
VV_LOCAL_SYMBOL string v__gen__c__js_dec_name(string typ);
VV_LOCAL_SYMBOL bool v__gen__c__is_js_prim(string typ);
VV_LOCAL_SYMBOL string v__gen__c__Gen_decode_array(v__gen__c__Gen* g, v__ast__Type value_type);
VV_LOCAL_SYMBOL string v__gen__c__Gen_encode_array(v__gen__c__Gen* g, v__ast__Type value_type);
VV_LOCAL_SYMBOL string v__gen__c__Gen_decode_map(v__gen__c__Gen* g, v__ast__Type key_type, v__ast__Type value_type);
VV_LOCAL_SYMBOL string v__gen__c__Gen_encode_map(v__gen__c__Gen* g, v__ast__Type key_type, v__ast__Type value_type);
VV_LOCAL_SYMBOL void v__gen__c__Gen_generate_hotcode_reloading_declarations(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL void v__gen__c__Gen_generate_hotcode_reloader_code(v__gen__c__Gen* g);
string _const_v__gen__c__posix_hotcode_definitions_1; // a string literal, inited later
string _const_v__gen__c__windows_hotcode_definitions_1; // a string literal, inited later
VV_LOCAL_SYMBOL void v__gen__c__Gen_generate_hotcode_reloading_main_caller(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL void v__gen__c__Gen_profile_fn(v__gen__c__Gen* g, v__ast__FnDecl fn_decl);
void v__gen__c__Gen_gen_vprint_profile_stats(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL void v__gen__c__Gen_sql_stmt(v__gen__c__Gen* g, v__ast__SqlStmt node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_sql_stmt_line(v__gen__c__Gen* g, v__ast__SqlStmtLine nd, string expr);
VV_LOCAL_SYMBOL void v__gen__c__Gen_sql_create_table(v__gen__c__Gen* g, v__ast__SqlStmtLine node, string expr, string table_name);
VV_LOCAL_SYMBOL void v__gen__c__Gen_sql_insert(v__gen__c__Gen* g, v__ast__SqlStmtLine node, string expr, string table_name, string last_ids_arr, string res, string pid, bool is_array, string fkey);
VV_LOCAL_SYMBOL void v__gen__c__Gen_sql_update(v__gen__c__Gen* g, v__ast__SqlStmtLine node, string expr, string table_name);
VV_LOCAL_SYMBOL void v__gen__c__Gen_sql_delete(v__gen__c__Gen* g, v__ast__SqlStmtLine node, string expr, string table_name);
VV_LOCAL_SYMBOL void v__gen__c__Gen_sql_expr_to_orm_primitive(v__gen__c__Gen* g, v__ast__Expr expr);
VV_LOCAL_SYMBOL void v__gen__c__Gen_sql_write_orm_primitive(v__gen__c__Gen* g, v__ast__Type t, v__ast__Expr expr);
VV_LOCAL_SYMBOL void v__gen__c__Gen_sql_where_data(v__gen__c__Gen* g, v__ast__Expr expr, Array_string* fields, Array_string* kinds, Array_v__ast__Expr* data, Array_bool* is_and);
VV_LOCAL_SYMBOL void v__gen__c__Gen_sql_gen_where_data(v__gen__c__Gen* g, v__ast__Expr where_expr);
VV_LOCAL_SYMBOL void v__gen__c__Gen_sql_select_expr(v__gen__c__Gen* g, v__ast__SqlExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_sql_select(v__gen__c__Gen* g, v__ast__SqlExpr node, string expr, string left);
VV_LOCAL_SYMBOL v__gen__c__SqlType v__gen__c__Gen_parse_db_type(v__gen__c__Gen* g, v__ast__Expr expr);
VV_LOCAL_SYMBOL v__gen__c__SqlType v__gen__c__Gen_parse_db_from_type_string(v__gen__c__Gen* g, string name);
VV_LOCAL_SYMBOL string v__gen__c__Gen_get_table_name(v__gen__c__Gen* g, v__ast__TypeNode table_expr);
VV_LOCAL_SYMBOL v__ast__StructField v__gen__c__Gen_get_struct_field(v__gen__c__Gen* g, string name);
VV_LOCAL_SYMBOL string v__gen__c__Gen_get_field_name(v__gen__c__Gen* g, v__ast__StructField field);
VV_LOCAL_SYMBOL void v__gen__c__Gen_string_literal(v__gen__c__Gen* g, v__ast__StringLiteral node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_string_inter_literal_sb_optimized(v__gen__c__Gen* g, v__ast__CallExpr call_expr);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_expr_to_string(v__gen__c__Gen* g, v__ast__Expr expr, v__ast__Type etype);
VV_LOCAL_SYMBOL multi_return_u64_string v__gen__c__Gen_str_format(v__gen__c__Gen* g, v__ast__StringInterLiteral node, int i);
VV_LOCAL_SYMBOL void v__gen__c__Gen_str_val(v__gen__c__Gen* g, v__ast__StringInterLiteral node, int i);
VV_LOCAL_SYMBOL void v__gen__c__Gen_string_inter_literal(v__gen__c__Gen* g, v__ast__StringInterLiteral node);
VV_LOCAL_SYMBOL v__ast__Type v__gen__c__Gen_unwrap_generic(v__gen__c__Gen* g, v__ast__Type typ);
VV_LOCAL_SYMBOL v__gen__c__Type v__gen__c__Gen_unwrap(v__gen__c__Gen* g, v__ast__Type typ);
#define _const_v__scanner__single_quote '\''
#define _const_v__scanner__double_quote '"'
rune _const_v__scanner__num_sep = '_'; // precomputed
#define _const_v__scanner__b_lf 10
#define _const_v__scanner__b_cr 13
#define _const_v__scanner__backslash '\\'
v__scanner__Scanner* v__scanner__new_scanner_file(string file_path, v__scanner__CommentsMode comments_mode, v__pref__Preferences* pref);
v__scanner__Scanner* v__scanner__new_scanner(string text, v__scanner__CommentsMode comments_mode, v__pref__Preferences* pref);
VV_LOCAL_SYMBOL void v__scanner__Scanner_init_scanner(v__scanner__Scanner* s);
void v__scanner__Scanner_free(v__scanner__Scanner* s);
VV_LOCAL_SYMBOL bool v__scanner__Scanner_should_parse_comment(v__scanner__Scanner* s);
void v__scanner__Scanner_set_is_inside_toplevel_statement(v__scanner__Scanner* s, bool newstate);
void v__scanner__Scanner_set_current_tidx(v__scanner__Scanner* s, int cidx);
VV_LOCAL_SYMBOL v__token__Token v__scanner__Scanner_new_token(v__scanner__Scanner* s, v__token__Kind tok_kind, string lit, int len);
VV_LOCAL_SYMBOL v__token__Token v__scanner__Scanner_new_eof_token(v__scanner__Scanner* s);
VV_LOCAL_SYMBOL v__token__Token v__scanner__Scanner_new_multiline_token(v__scanner__Scanner* s, v__token__Kind tok_kind, string lit, int len, int start_line);
VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_name(v__scanner__Scanner* s);
VV_LOCAL_SYMBOL string v__scanner__Scanner_num_lit(v__scanner__Scanner* s, int start, int end);
VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_bin_number(v__scanner__Scanner* s);
VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_hex_number(v__scanner__Scanner* s);
VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_oct_number(v__scanner__Scanner* s);
VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_dec_number(v__scanner__Scanner* s);
VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_number(v__scanner__Scanner* s);
VV_LOCAL_SYMBOL void v__scanner__Scanner_skip_whitespace(v__scanner__Scanner* s);
VV_LOCAL_SYMBOL v__token__Token v__scanner__Scanner_end_of_file(v__scanner__Scanner* s);
void v__scanner__Scanner_scan_all_tokens_in_buffer(v__scanner__Scanner* s, v__scanner__CommentsMode mode);
void v__scanner__Scanner_scan_remaining_text(v__scanner__Scanner* s);
v__token__Token v__scanner__Scanner_scan(v__scanner__Scanner* s);
v__token__Token v__scanner__Scanner_buffer_scan(v__scanner__Scanner* s);
v__token__Token v__scanner__Scanner_peek_token(v__scanner__Scanner* s, int n);
VV_LOCAL_SYMBOL byte v__scanner__Scanner_look_ahead(v__scanner__Scanner* s, int n);
VV_LOCAL_SYMBOL v__token__Token v__scanner__Scanner_text_scan(v__scanner__Scanner* s);
VV_LOCAL_SYMBOL void v__scanner__Scanner_invalid_character(v__scanner__Scanner* s);
VV_LOCAL_SYMBOL int v__scanner__Scanner_current_column(v__scanner__Scanner* s);
VV_LOCAL_SYMBOL int v__scanner__Scanner_count_symbol_before(v__scanner__Scanner* s, int p, byte sym);
VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_string(v__scanner__Scanner* s);
VV_LOCAL_SYMBOL string v__scanner__decode_u_escapes(string s, int start, Array_int escapes_pos);
VV_LOCAL_SYMBOL string v__scanner__trim_slash_line_break(string s);
VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_char(v__scanner__Scanner* s);
VV_LOCAL_SYMBOL bool v__scanner__Scanner_expect(v__scanner__Scanner* s, string want, int start_pos);
VV_LOCAL_SYMBOL void v__scanner__Scanner_ignore_line(v__scanner__Scanner* s);
VV_LOCAL_SYMBOL void v__scanner__Scanner_eat_to_end_of_line(v__scanner__Scanner* s);
VV_LOCAL_SYMBOL void v__scanner__Scanner_inc_line_number(v__scanner__Scanner* s);
void v__scanner__Scanner_note(v__scanner__Scanner* s, string msg);
void v__scanner__Scanner_add_error_detail(v__scanner__Scanner* s, string msg);
void v__scanner__Scanner_add_error_detail_with_pos(v__scanner__Scanner* s, string msg, v__token__Position pos);
VV_LOCAL_SYMBOL string v__scanner__Scanner_eat_details(v__scanner__Scanner* s);
void v__scanner__Scanner_warn(v__scanner__Scanner* s, string msg);
void v__scanner__Scanner_error(v__scanner__Scanner* s, string msg);
VV_LOCAL_SYMBOL void v__scanner__Scanner_vet_error(v__scanner__Scanner* s, string msg, v__vet__FixKind fix);
void v__scanner__verror(string s);
VV_LOCAL_SYMBOL void v__scanner__Scanner_trace(v__scanner__Scanner* s, string fbase, string message);
Option_void v__ast__walker__Inspector_visit(v__ast__walker__Inspector* i, v__ast__Node* node);
void v__ast__walker__inspect(v__ast__Node* node, voidptr data, bool (*inspector_callback)(v__ast__Node* node, voidptr data));
void v__ast__walker__walk(v__ast__walker__Visitor* visitor, v__ast__Node* node);
VV_LOCAL_SYMBOL v__ast__Stmt v__parser__Parser_assign_stmt(v__parser__Parser* p);
#define _const_v__parser__max_expr_level 310
VV_LOCAL_SYMBOL Option_void v__parser__Parser_check_undefined_variables(v__parser__Parser* p, Array_v__ast__Expr exprs, v__ast__Expr val);
VV_LOCAL_SYMBOL bool v__parser__Parser_check_cross_variables(v__parser__Parser* p, Array_v__ast__Expr exprs, v__ast__Expr val);
VV_LOCAL_SYMBOL v__ast__Stmt v__parser__Parser_partial_assign_stmt(v__parser__Parser* p, Array_v__ast__Expr left, Array_v__ast__Comment left_comments);
Array_string _const_v__parser__supported_comptime_calls; // inited later
VV_LOCAL_SYMBOL v__ast__HashStmt v__parser__Parser_hash(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__ComptimeCall v__parser__Parser_comptime_call(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__ComptimeFor v__parser__Parser_comptime_for(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__AtExpr v__parser__Parser_at(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__Expr v__parser__Parser_comptime_selector(v__parser__Parser* p, v__ast__Expr left);
VV_LOCAL_SYMBOL v__ast__ArrayInit v__parser__Parser_array_init(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__MapInit v__parser__Parser_map_init(v__parser__Parser* p);
VV_LOCAL_SYMBOL void v__parser__Parser_scope_register_it_as_index(v__parser__Parser* p);
v__ast__Expr v__parser__Parser_expr(v__parser__Parser* p, int precedence);
Option_v__ast__Expr v__parser__Parser_check_expr(v__parser__Parser* p, int precedence);
v__ast__Expr v__parser__Parser_expr_with_left(v__parser__Parser* p, v__ast__Expr left, int precedence, bool is_stmt_ident);
VV_LOCAL_SYMBOL v__ast__Expr v__parser__Parser_infix_expr(v__parser__Parser* p, v__ast__Expr left);
VV_LOCAL_SYMBOL v__ast__GoExpr v__parser__Parser_go_expr(v__parser__Parser* p);
VV_LOCAL_SYMBOL bool v__parser__Parser_fileis(v__parser__Parser* p, string s);
VV_LOCAL_SYMBOL v__ast__Expr v__parser__Parser_prefix_expr(v__parser__Parser* p);
VV_LOCAL_SYMBOL void v__parser__Parser_recast_as_pointer(v__parser__Parser* p, v__ast__CastExpr* cast_expr, v__token__Position pos);
v__ast__CallExpr v__parser__Parser_call_expr(v__parser__Parser* p, v__ast__Language language, string mod);
Array_v__ast__CallArg v__parser__Parser_call_args(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__FnDecl v__parser__Parser_fn_decl(v__parser__Parser* p);
VV_LOCAL_SYMBOL Option_void v__parser__Parser_fn_receiver(v__parser__Parser* p, Array_v__ast__Param* params, v__parser__ReceiverParsingInfo* rec);
VV_LOCAL_SYMBOL v__ast__AnonFn v__parser__Parser_anon_fn(v__parser__Parser* p);
VV_LOCAL_SYMBOL multi_return_Array_v__ast__Param_bool_bool v__parser__Parser_fn_args(v__parser__Parser* p);
VV_LOCAL_SYMBOL Array_v__ast__Param v__parser__Parser_closure_vars(v__parser__Parser* p);
VV_LOCAL_SYMBOL void v__parser__Parser_check_fn_mutable_arguments(v__parser__Parser* p, v__ast__Type typ, v__token__Position pos);
VV_LOCAL_SYMBOL void v__parser__Parser_check_fn_shared_arguments(v__parser__Parser* p, v__ast__Type typ, v__token__Position pos);
VV_LOCAL_SYMBOL void v__parser__Parser_check_fn_atomic_arguments(v__parser__Parser* p, v__ast__Type typ, v__token__Position pos);
VV_LOCAL_SYMBOL bool v__parser__have_fn_main(Array_v__ast__Stmt stmts);
VV_LOCAL_SYMBOL v__ast__Stmt v__parser__Parser_for_stmt(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__IfExpr v__parser__Parser_if_expr(v__parser__Parser* p, bool is_comptime);
VV_LOCAL_SYMBOL v__ast__MatchExpr v__parser__Parser_match_expr(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__SelectExpr v__parser__Parser_select_expr(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__Expr v__parser__Parser_lockable(v__parser__Parser* p);
VV_LOCAL_SYMBOL multi_return_Array_v__ast__Expr_Array_v__ast__Comment v__parser__Parser_lockable_list(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__LockExpr v__parser__Parser_lock_expr(v__parser__Parser* p);
bool v__parser__Parser_known_import(v__parser__Parser* p, string mod);
VV_LOCAL_SYMBOL string v__parser__Parser_prepend_mod(v__parser__Parser* p, string name);
VV_LOCAL_SYMBOL bool v__parser__Parser_is_used_import(v__parser__Parser* p, string alias);
VV_LOCAL_SYMBOL void v__parser__Parser_register_used_import(v__parser__Parser* p, string alias);
VV_LOCAL_SYMBOL void v__parser__Parser_register_auto_import(v__parser__Parser* p, string alias);
VV_LOCAL_SYMBOL void v__parser__Parser_check_unused_imports(v__parser__Parser* p);
#define _const_v__parser__maximum_inline_sum_type_variants 3
v__ast__Type v__parser__Parser_parse_array_type(v__parser__Parser* p, v__token__Kind expecting);
v__ast__Type v__parser__Parser_parse_map_type(v__parser__Parser* p);
v__ast__Type v__parser__Parser_parse_chan_type(v__parser__Parser* p);
v__ast__Type v__parser__Parser_parse_thread_type(v__parser__Parser* p);
v__ast__Type v__parser__Parser_parse_multi_return_type(v__parser__Parser* p);
v__ast__Type v__parser__Parser_parse_fn_type(v__parser__Parser* p, string name);
v__ast__Type v__parser__Parser_parse_type_with_mut(v__parser__Parser* p, bool is_mut);
v__ast__Language v__parser__Parser_parse_language(v__parser__Parser* p);
v__ast__Type v__parser__Parser_parse_inline_sum_type(v__parser__Parser* p);
VV_LOCAL_SYMBOL int compare_1376677008124459278_string(string* a, string* b) {
	if (string__lt(*a, *b)) return -1;
	else return 1;
}

Array_v__ast__TypeNode v__parser__Parser_parse_sum_type_variants(v__parser__Parser* p);
v__ast__Type v__parser__Parser_parse_type(v__parser__Parser* p);
v__ast__Type v__parser__Parser_parse_any_type(v__parser__Parser* p, v__ast__Language language, bool is_ptr, bool check_dot);
v__ast__Type v__parser__Parser_find_type_or_add_placeholder(v__parser__Parser* p, string name, v__ast__Language language);
v__ast__Type v__parser__Parser_parse_generic_type(v__parser__Parser* p, string name);
v__ast__Type v__parser__Parser_parse_generic_inst_type(v__parser__Parser* p, string name);
Array_string _const_v__parser__builtin_functions; // inited later
v__ast__Stmt v__parser__parse_stmt(string text, v__ast__Table* table, v__ast__Scope* scope);
v__ast__File* v__parser__parse_comptime(string text, v__ast__Table* table, v__pref__Preferences* pref, v__ast__Scope* scope);
v__ast__File* v__parser__parse_text(string text, string path, v__ast__Table* table, v__scanner__CommentsMode comments_mode, v__pref__Preferences* pref);
void v__parser__Parser_free(v__parser__Parser* p);
void v__parser__Parser_free_scanner(v__parser__Parser* p);
void v__parser__Parser_set_path(v__parser__Parser* p, string path);
v__ast__File* v__parser__parse_file(string path, v__ast__Table* table, v__scanner__CommentsMode comments_mode, v__pref__Preferences* pref);
multi_return_ref_v__ast__File_Array_v__vet__Error v__parser__parse_vet_file(string path, v__ast__Table* table_, v__pref__Preferences* pref);
v__ast__File* v__parser__Parser_parse(v__parser__Parser* p);
Array_v__ast__File_ptr v__parser__parse_files(Array_string paths, v__ast__Table* table, v__pref__Preferences* pref);
void v__parser__Parser_codegen(v__parser__Parser* p, string code);
void v__parser__Parser_init_parse_fns(v__parser__Parser* p);
void v__parser__Parser_read_first_token(v__parser__Parser* p);
v__token__Token v__parser__Parser_peek_token(v__parser__Parser* p, int n);
void v__parser__Parser_open_scope(v__parser__Parser* p);
void v__parser__Parser_close_scope(v__parser__Parser* p);
Array_v__ast__Stmt v__parser__Parser_parse_block(v__parser__Parser* p);
Array_v__ast__Stmt v__parser__Parser_parse_block_no_scope(v__parser__Parser* p, bool is_top_level);
VV_LOCAL_SYMBOL void v__parser__Parser_next(v__parser__Parser* p);
VV_LOCAL_SYMBOL void v__parser__Parser_check(v__parser__Parser* p, v__token__Kind expected);
VV_LOCAL_SYMBOL string v__parser__Parser_check_js_name(v__parser__Parser* p);
VV_LOCAL_SYMBOL string v__parser__Parser_check_name(v__parser__Parser* p);
v__ast__Stmt v__parser__Parser_top_stmt(v__parser__Parser* p);
v__ast__Comment v__parser__Parser_check_comment(v__parser__Parser* p);
v__ast__Comment v__parser__Parser_comment(v__parser__Parser* p);
v__ast__ExprStmt v__parser__Parser_comment_stmt(v__parser__Parser* p);
Array_v__ast__Comment v__parser__Parser_eat_comments(v__parser__Parser* p, v__parser__EatCommentsConfig cfg);
v__ast__Stmt v__parser__Parser_stmt(v__parser__Parser* p, bool is_top_level);
VV_LOCAL_SYMBOL v__ast__AsmStmt v__parser__Parser_asm_stmt(v__parser__Parser* p, bool is_top_level);
VV_LOCAL_SYMBOL v__ast__AsmArg v__parser__Parser_reg_or_alias(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__AsmAddressing v__parser__Parser_asm_addressing(v__parser__Parser* p);
VV_LOCAL_SYMBOL Array_v__ast__AsmIO v__parser__Parser_asm_ios(v__parser__Parser* p, bool output);
VV_LOCAL_SYMBOL multi_return_Array_v__ast__Expr_Array_v__ast__Comment v__parser__Parser_expr_list(v__parser__Parser* p);
VV_LOCAL_SYMBOL bool v__parser__Parser_is_attributes(v__parser__Parser* p);
VV_LOCAL_SYMBOL void v__parser__Parser_attributes(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__Attr v__parser__Parser_parse_attr(v__parser__Parser* p);
void v__parser__Parser_language_not_allowed_error(v__parser__Parser* p, v__ast__Language language, v__token__Position pos);
void v__parser__Parser_language_not_allowed_warning(v__parser__Parser* p, v__ast__Language language, v__token__Position pos);
void v__parser__Parser_check_for_impure_v(v__parser__Parser* p, v__ast__Language language, v__token__Position pos);
v__ast__NodeError v__parser__Parser_error(v__parser__Parser* p, string s);
void v__parser__Parser_warn(v__parser__Parser* p, string s);
void v__parser__Parser_note(v__parser__Parser* p, string s);
v__ast__NodeError v__parser__Parser_error_with_pos(v__parser__Parser* p, string s, v__token__Position pos);
void v__parser__Parser_error_with_error(v__parser__Parser* p, v__errors__Error _v_error);
void v__parser__Parser_warn_with_pos(v__parser__Parser* p, string s, v__token__Position pos);
void v__parser__Parser_note_with_pos(v__parser__Parser* p, string s, v__token__Position pos);
void v__parser__Parser_vet_error(v__parser__Parser* p, string msg, int line, v__vet__FixKind fix, v__vet__ErrorType typ);
VV_LOCAL_SYMBOL v__ast__Stmt v__parser__Parser_parse_multi_expr(v__parser__Parser* p, bool is_top_level);
v__ast__Ident v__parser__Parser_parse_ident(v__parser__Parser* p, v__ast__Language language);
VV_LOCAL_SYMBOL bool v__parser__Parser_is_typename(v__parser__Parser* p, v__token__Token t);
VV_LOCAL_SYMBOL bool v__parser__Parser_is_generic_call(v__parser__Parser* p);
Array_v__token__Kind _const_v__parser__valid_tokens_inside_types; // inited later
VV_LOCAL_SYMBOL bool v__parser__Parser_is_generic_cast(v__parser__Parser* p);
v__ast__Expr v__parser__Parser_name_expr(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__IndexExpr v__parser__Parser_index_expr(v__parser__Parser* p, v__ast__Expr left, bool is_gated);
VV_LOCAL_SYMBOL void v__parser__Parser_scope_register_it(v__parser__Parser* p);
VV_LOCAL_SYMBOL void v__parser__Parser_scope_register_ab(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__Expr v__parser__Parser_dot_expr(v__parser__Parser* p, v__ast__Expr left);
VV_LOCAL_SYMBOL multi_return_Array_v__ast__Type_Array_string v__parser__Parser_parse_generic_types(v__parser__Parser* p);
VV_LOCAL_SYMBOL Array_v__ast__Type v__parser__Parser_parse_concrete_types(v__parser__Parser* p);
VV_LOCAL_SYMBOL bool v__parser__Parser_is_generic_name(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__EnumVal v__parser__Parser_enum_val(v__parser__Parser* p);
VV_LOCAL_SYMBOL void v__parser__Parser_filter_string_vet_errors(v__parser__Parser* p, v__token__Position pos);
VV_LOCAL_SYMBOL v__ast__Expr v__parser__Parser_string_expr(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__Expr v__parser__Parser_parse_number_literal(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__Module v__parser__Parser_module_decl(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__Import v__parser__Parser_import_stmt(v__parser__Parser* p);
VV_LOCAL_SYMBOL void v__parser__Parser_import_syms(v__parser__Parser* p, v__ast__Import* parent);
VV_LOCAL_SYMBOL v__ast__ConstDecl v__parser__Parser_const_decl(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__Return v__parser__Parser_return_stmt(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__GlobalDecl v__parser__Parser_global_decl(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__EnumDecl v__parser__Parser_enum_decl(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__TypeDecl v__parser__Parser_type_decl(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__Assoc v__parser__Parser_assoc(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__Expr v__parser__Parser_new_true_expr(v__parser__Parser* p);
VV_LOCAL_SYMBOL void v__parser__verror(string s);
VV_LOCAL_SYMBOL void v__parser__Parser_top_level_statement_start(v__parser__Parser* p);
VV_LOCAL_SYMBOL void v__parser__Parser_top_level_statement_end(v__parser__Parser* p);
VV_LOCAL_SYMBOL void v__parser__Parser_rewind_scanner_to_current_token_in_new_mode(v__parser__Parser* p);
bool v__parser__Parser_mark_var_as_used(v__parser__Parser* p, string varname);
VV_LOCAL_SYMBOL v__ast__Stmt v__parser__Parser_unsafe_stmt(v__parser__Parser* p);
VV_LOCAL_SYMBOL void v__parser__Parser_trace(v__parser__Parser* p, string fbase, string message);
VV_LOCAL_SYMBOL v__ast__Expr v__parser__Parser_sql_expr(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__SqlStmt v__parser__Parser_sql_stmt(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__SqlStmtLine v__parser__Parser_parse_sql_stmt_line(v__parser__Parser* p);
VV_LOCAL_SYMBOL Option_bool v__parser__Parser_check_sql_keyword(v__parser__Parser* p, string name);
VV_LOCAL_SYMBOL v__ast__StructDecl v__parser__Parser_struct_decl(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__StructInit v__parser__Parser_struct_init(v__parser__Parser* p, bool short_syntax);
VV_LOCAL_SYMBOL v__ast__InterfaceDecl v__parser__Parser_interface_decl(v__parser__Parser* p);
VV_LOCAL_SYMBOL bool v__parser__is_html_open_tag(string name, string s);
string v__parser__Parser_compile_template_file(v__parser__Parser* p, string template_file, string fn_name);
void v__callgraph__show(v__ast__Table* table, v__pref__Preferences* pref, Array_v__ast__File_ptr ast_files);
VV_LOCAL_SYMBOL string v__callgraph__Mapper_dot_normalise_node_name(v__callgraph__Mapper* m, string name);
VV_LOCAL_SYMBOL string v__callgraph__Mapper_fn_name(v__callgraph__Mapper* m, string fname, v__ast__Type receiver_type, bool is_method);
VV_LOCAL_SYMBOL string v__callgraph__Mapper_dot_fn_name(v__callgraph__Mapper* m, string fname, v__ast__Type recv_type, bool is_method);
VV_LOCAL_SYMBOL Option_void v__callgraph__Mapper_visit(v__callgraph__Mapper* m, v__ast__Node* node);
v__builder__Builder v__builder__new_builder(v__pref__Preferences* pref);
Option_void v__builder__Builder_front_stages(v__builder__Builder* b, Array_string v_files);
Option_void v__builder__Builder_middle_stages(v__builder__Builder* b);
Option_void v__builder__Builder_front_and_middle_stages(v__builder__Builder* b, Array_string v_files);
void v__builder__Builder_parse_imports(v__builder__Builder* b);
void v__builder__Builder_resolve_deps(v__builder__Builder* b);
v__depgraph__DepGraph* v__builder__Builder_import_graph(v__builder__Builder* b);
Array_string v__builder__Builder_v_files_from_dir(v__builder__Builder* b, string dir);
void v__builder__Builder_log(v__builder__Builder* b, string s);
void v__builder__Builder_info(v__builder__Builder* b, string s);
string v__builder__module_path(string mod);
Option_string v__builder__Builder_find_module_path(v__builder__Builder* b, string mod, string fpath);
void v__builder__Builder_show_total_warns_and_errors_stats(v__builder__Builder* b);
void v__builder__Builder_print_warnings_and_errors(v__builder__Builder* b);
v__errors__Error v__builder__Builder_error_with_pos(v__builder__Builder* b, string s, string fpath, v__token__Position pos);
void v__builder__verror(string s);
string _const_v__builder__c_verror_message_marker; // a string literal, inited later
string _const_v__builder__c_error_info; // a string literal, inited later
string _const_v__builder__no_compiler_error; // a string literal, inited later
Option_void v__builder__Builder_find_win_cc(v__builder__Builder* v);
VV_LOCAL_SYMBOL void v__builder__Builder_show_c_compiler_output(v__builder__Builder* v, os__Result res);
VV_LOCAL_SYMBOL void v__builder__Builder_post_process_c_compiler_output(v__builder__Builder* v, os__Result res);
VV_LOCAL_SYMBOL void v__builder__Builder_show_cc(v__builder__Builder* v, string cmd, string response_file, string response_file_content);
VV_LOCAL_SYMBOL void v__builder__Builder_setup_ccompiler_options(v__builder__Builder* v, string ccompiler);
VV_LOCAL_SYMBOL Array_string v__builder__Builder_all_args(v__builder__Builder* v, v__builder__CcompilerOptions ccoptions);
VV_LOCAL_SYMBOL Array_string v__builder__Builder_thirdparty_object_args(v__builder__Builder* v, v__builder__CcompilerOptions ccoptions, Array_string middle);
VV_LOCAL_SYMBOL void v__builder__Builder_setup_output_name(v__builder__Builder* v);
VV_LOCAL_SYMBOL void v__builder__Builder_dump_c_options(v__builder__Builder* v, Array_string all_args);
void v__builder__Builder_cc(v__builder__Builder* v);
VV_LOCAL_SYMBOL void v__builder__Builder_ensure_linuxroot_exists(v__builder__Builder* b, string sysroot);
VV_LOCAL_SYMBOL void v__builder__Builder_cc_linux_cross(v__builder__Builder* b);
VV_LOCAL_SYMBOL void v__builder__Builder_cc_windows_cross(v__builder__Builder* c);
VV_LOCAL_SYMBOL void v__builder__Builder_build_thirdparty_obj_files(v__builder__Builder* b);
VV_LOCAL_SYMBOL void v__builder__Builder_build_thirdparty_obj_file(v__builder__Builder* v, string path, Array_v__cflag__CFlag moduleflags);
VV_LOCAL_SYMBOL string v__builder__missing_compiler_info(void);
VV_LOCAL_SYMBOL Array_string v__builder__error_context_lines(string text, string keyword, int before, int after);
VV_LOCAL_SYMBOL Array_v__cflag__CFlag v__builder__Builder_get_os_cflags(v__builder__Builder* v);
VV_LOCAL_SYMBOL Array_v__cflag__CFlag v__builder__Builder_get_rest_of_module_cflags(v__builder__Builder* v, v__cflag__CFlag* c);
void v__builder__compile(string command, v__pref__Preferences* pref, void (*backend_cb)(v__builder__Builder* b));
string v__builder__Builder_get_vtmp_filename(v__builder__Builder* b, string base_file_name, string postfix);
VV_LOCAL_SYMBOL void v__builder__Builder_myfree(v__builder__Builder* b);
VV_LOCAL_SYMBOL void v__builder__Builder_exit_on_invalid_syntax(v__builder__Builder* b);
VV_LOCAL_SYMBOL void v__builder__Builder_run_compiled_executable_and_exit(v__builder__Builder* b);
VV_LOCAL_SYMBOL void v__builder__eshcb(os__Signal _d1);
VV_LOCAL_SYMBOL void v__builder__serror(string reason, IError e);
VV_LOCAL_SYMBOL void v__builder__Builder_cleanup_run_executable_after_exit(v__builder__Builder* v, string exefile);
void v__builder__Builder_set_module_lookup_paths(v__builder__Builder* v);
Array_string v__builder__Builder_get_builtin_files(v__builder__Builder* v);
Array_string v__builder__Builder_get_user_files(v__builder__Builder* v);
v__builder__RegKey _const_v__builder__hkey_local_machine; // inited later
#define _const_v__builder__key_query_value 1
#define _const_v__builder__key_wow64_32key 512
#define _const_v__builder__key_enumerate_sub_keys 8
VV_LOCAL_SYMBOL Option_string v__builder__find_windows_kit_internal(v__builder__RegKey key, Array_string versions);
VV_LOCAL_SYMBOL Option_v__builder__WindowsKit v__builder__find_windows_kit_root(string target_arch);
VV_LOCAL_SYMBOL Option_v__builder__WindowsKit v__builder__find_windows_kit_root_by_reg(string target_arch);
VV_LOCAL_SYMBOL Option_v__builder__WindowsKit v__builder__new_windows_kit(string kit_root, string target_arch);
VV_LOCAL_SYMBOL Option_v__builder__WindowsKit v__builder__find_windows_kit_root_by_env(string target_arch);
VV_LOCAL_SYMBOL Option_v__builder__VsInstallation v__builder__find_vs(string vswhere_dir, string host_arch, string target_arch);
VV_LOCAL_SYMBOL Option_v__builder__VsInstallation v__builder__find_vs_by_reg(string vswhere_dir, string host_arch, string target_arch);
VV_LOCAL_SYMBOL Option_v__builder__VsInstallation v__builder__find_vs_by_env(string host_arch, string target_arch);
VV_LOCAL_SYMBOL Option_v__builder__MsvcResult v__builder__find_msvc(bool m64_target);
void v__builder__Builder_cc_msvc(v__builder__Builder* v);
VV_LOCAL_SYMBOL void v__builder__Builder_build_thirdparty_obj_file_with_msvc(v__builder__Builder* v, string path, Array_v__cflag__CFlag moduleflags);
v__builder__MsvcStringFlags v__builder__msvc_string_flags(Array_v__cflag__CFlag cflags);
void v__builder__Builder_rebuild_modules(v__builder__Builder* b);
VV_LOCAL_SYMBOL void v__builder__Builder_v_build_module(v__builder__Builder* b, string vexe, string imp_path);
VV_LOCAL_SYMBOL string v__builder__Builder_rebuild_cached_module(v__builder__Builder* b, string vexe, string imp_path);
VV_LOCAL_SYMBOL void v__builder__Builder_handle_usecache(v__builder__Builder* b, string vexe);
void v__builder__cbuilder__start(void);
void v__builder__cbuilder__compile_c(v__builder__Builder* b);
string v__builder__cbuilder__gen_c(v__builder__Builder* b, Array_string v_files);
void v__builder__cbuilder__build_c(v__builder__Builder* b, Array_string v_files, string out_file);
Array_string _const_main__external_tools; // inited later
Array_string _const_main__list_of_flags_that_allow_duplicates; // inited later
VV_LOCAL_SYMBOL void main__main(void);
VV_LOCAL_SYMBOL void main__invoke_help_and_exit(Array_string remaining);


// V interface table:
static IError I_None___to_Interface_IError(None__* x);
const int _IError_None___index = 0;
static IError I_Error_to_Interface_IError(Error* x);
const int _IError_Error_index = 1;
static IError I_time__TimeParseError_to_Interface_IError(time__TimeParseError* x);
const int _IError_time__TimeParseError_index = 2;
static IError I_flag__UnkownFlagError_to_Interface_IError(flag__UnkownFlagError* x);
const int _IError_flag__UnkownFlagError_index = 3;
static IError I_flag__MinimumArgsCountError_to_Interface_IError(flag__MinimumArgsCountError* x);
const int _IError_flag__MinimumArgsCountError_index = 4;
static IError I_flag__MaximumArgsCountError_to_Interface_IError(flag__MaximumArgsCountError* x);
const int _IError_flag__MaximumArgsCountError_index = 5;
static IError I_flag__NoArgsExpectedError_to_Interface_IError(flag__NoArgsExpectedError* x);
const int _IError_flag__NoArgsExpectedError_index = 6;
static IError I_semver__InvalidComparatorFormatError_to_Interface_IError(semver__InvalidComparatorFormatError* x);
const int _IError_semver__InvalidComparatorFormatError_index = 7;
static IError I_semver__EmptyInputError_to_Interface_IError(semver__EmptyInputError* x);
const int _IError_semver__EmptyInputError_index = 8;
static IError I_semver__InvalidVersionFormatError_to_Interface_IError(semver__InvalidVersionFormatError* x);
const int _IError_semver__InvalidVersionFormatError_index = 9;
static IError I_os__ErrFileNotOpened_to_Interface_IError(os__ErrFileNotOpened* x);
const int _IError_os__ErrFileNotOpened_index = 10;
static IError I_os__ErrSizeOfTypeIs0_to_Interface_IError(os__ErrSizeOfTypeIs0* x);
const int _IError_os__ErrSizeOfTypeIs0_index = 11;
static IError I_os__ErrExecutableNotFound_to_Interface_IError(os__ErrExecutableNotFound* x);
const int _IError_os__ErrExecutableNotFound_index = 12;
static IError I_v__gen__c__UnsupportedAssertCtempTransform_to_Interface_IError(v__gen__c__UnsupportedAssertCtempTransform* x);
const int _IError_v__gen__c__UnsupportedAssertCtempTransform_index = 13;
static IError I_semver__InvalidComparatorCountError_to_Interface_IError(semver__InvalidComparatorCountError* x);
const int _IError_semver__InvalidComparatorCountError_index = 14;
static IError I_voidptr_to_Interface_IError(voidptr* x);
const int _IError_voidptr_index = 15;
// ^^^ number of types for interface IError: 16


// Casting functions for converting "None__" to interface "IError"
static inline IError I_None___to_Interface_IError(None__* x) {
	return (IError) {
		._None__ = x,
		._typ = _IError_None___index,
		.msg = (string*)((char*)x + __offsetof_ptr(x, None__, msg)),
		.code = (int*)((char*)x + __offsetof_ptr(x, None__, code)),
	};
}

// Casting functions for converting "Error" to interface "IError"
static inline IError I_Error_to_Interface_IError(Error* x) {
	return (IError) {
		._Error = x,
		._typ = _IError_Error_index,
		.msg = (string*)((char*)x + __offsetof_ptr(x, Error, msg)),
		.code = (int*)((char*)x + __offsetof_ptr(x, Error, code)),
	};
}

// Casting functions for converting "time__TimeParseError" to interface "IError"
static inline IError I_time__TimeParseError_to_Interface_IError(time__TimeParseError* x) {
	return (IError) {
		._time__TimeParseError = x,
		._typ = _IError_time__TimeParseError_index,
		.msg = (string*)((char*)x + __offsetof_ptr(x, time__TimeParseError, msg)),
		.code = (int*)((char*)x + __offsetof_ptr(x, time__TimeParseError, code)),
	};
}

// Casting functions for converting "flag__UnkownFlagError" to interface "IError"
static inline IError I_flag__UnkownFlagError_to_Interface_IError(flag__UnkownFlagError* x) {
	return (IError) {
		._flag__UnkownFlagError = x,
		._typ = _IError_flag__UnkownFlagError_index,
		.msg = (string*)((char*)x + __offsetof_ptr(x, flag__UnkownFlagError, msg)),
		.code = (int*)((char*)x + __offsetof_ptr(x, flag__UnkownFlagError, code)),
	};
}

// Casting functions for converting "flag__MinimumArgsCountError" to interface "IError"
static inline IError I_flag__MinimumArgsCountError_to_Interface_IError(flag__MinimumArgsCountError* x) {
	return (IError) {
		._flag__MinimumArgsCountError = x,
		._typ = _IError_flag__MinimumArgsCountError_index,
		.msg = (string*)((char*)x + __offsetof_ptr(x, flag__MinimumArgsCountError, msg)),
		.code = (int*)((char*)x + __offsetof_ptr(x, flag__MinimumArgsCountError, code)),
	};
}

// Casting functions for converting "flag__MaximumArgsCountError" to interface "IError"
static inline IError I_flag__MaximumArgsCountError_to_Interface_IError(flag__MaximumArgsCountError* x) {
	return (IError) {
		._flag__MaximumArgsCountError = x,
		._typ = _IError_flag__MaximumArgsCountError_index,
		.msg = (string*)((char*)x + __offsetof_ptr(x, flag__MaximumArgsCountError, msg)),
		.code = (int*)((char*)x + __offsetof_ptr(x, flag__MaximumArgsCountError, code)),
	};
}

// Casting functions for converting "flag__NoArgsExpectedError" to interface "IError"
static inline IError I_flag__NoArgsExpectedError_to_Interface_IError(flag__NoArgsExpectedError* x) {
	return (IError) {
		._flag__NoArgsExpectedError = x,
		._typ = _IError_flag__NoArgsExpectedError_index,
		.msg = (string*)((char*)x + __offsetof_ptr(x, flag__NoArgsExpectedError, msg)),
		.code = (int*)((char*)x + __offsetof_ptr(x, flag__NoArgsExpectedError, code)),
	};
}

// Casting functions for converting "semver__InvalidComparatorFormatError" to interface "IError"
static inline IError I_semver__InvalidComparatorFormatError_to_Interface_IError(semver__InvalidComparatorFormatError* x) {
	return (IError) {
		._semver__InvalidComparatorFormatError = x,
		._typ = _IError_semver__InvalidComparatorFormatError_index,
		.msg = (string*)((char*)x + __offsetof_ptr(x, semver__InvalidComparatorFormatError, msg)),
		.code = (int*)((char*)x + __offsetof_ptr(x, semver__InvalidComparatorFormatError, code)),
	};
}

// Casting functions for converting "semver__EmptyInputError" to interface "IError"
static inline IError I_semver__EmptyInputError_to_Interface_IError(semver__EmptyInputError* x) {
	return (IError) {
		._semver__EmptyInputError = x,
		._typ = _IError_semver__EmptyInputError_index,
		.msg = (string*)((char*)x + __offsetof_ptr(x, semver__EmptyInputError, msg)),
		.code = (int*)((char*)x + __offsetof_ptr(x, semver__EmptyInputError, code)),
	};
}

// Casting functions for converting "semver__InvalidVersionFormatError" to interface "IError"
static inline IError I_semver__InvalidVersionFormatError_to_Interface_IError(semver__InvalidVersionFormatError* x) {
	return (IError) {
		._semver__InvalidVersionFormatError = x,
		._typ = _IError_semver__InvalidVersionFormatError_index,
		.msg = (string*)((char*)x + __offsetof_ptr(x, semver__InvalidVersionFormatError, msg)),
		.code = (int*)((char*)x + __offsetof_ptr(x, semver__InvalidVersionFormatError, code)),
	};
}

// Casting functions for converting "os__ErrFileNotOpened" to interface "IError"
static inline IError I_os__ErrFileNotOpened_to_Interface_IError(os__ErrFileNotOpened* x) {
	return (IError) {
		._os__ErrFileNotOpened = x,
		._typ = _IError_os__ErrFileNotOpened_index,
		.msg = (string*)((char*)x + __offsetof_ptr(x, os__ErrFileNotOpened, msg)),
		.code = (int*)((char*)x + __offsetof_ptr(x, os__ErrFileNotOpened, code)),
	};
}

// Casting functions for converting "os__ErrSizeOfTypeIs0" to interface "IError"
static inline IError I_os__ErrSizeOfTypeIs0_to_Interface_IError(os__ErrSizeOfTypeIs0* x) {
	return (IError) {
		._os__ErrSizeOfTypeIs0 = x,
		._typ = _IError_os__ErrSizeOfTypeIs0_index,
		.msg = (string*)((char*)x + __offsetof_ptr(x, os__ErrSizeOfTypeIs0, msg)),
		.code = (int*)((char*)x + __offsetof_ptr(x, os__ErrSizeOfTypeIs0, code)),
	};
}

// Casting functions for converting "os__ErrExecutableNotFound" to interface "IError"
static inline IError I_os__ErrExecutableNotFound_to_Interface_IError(os__ErrExecutableNotFound* x) {
	return (IError) {
		._os__ErrExecutableNotFound = x,
		._typ = _IError_os__ErrExecutableNotFound_index,
		.msg = (string*)((char*)x + __offsetof_ptr(x, os__ErrExecutableNotFound, msg)),
		.code = (int*)((char*)x + __offsetof_ptr(x, os__ErrExecutableNotFound, code)),
	};
}

// Casting functions for converting "v__gen__c__UnsupportedAssertCtempTransform" to interface "IError"
static inline IError I_v__gen__c__UnsupportedAssertCtempTransform_to_Interface_IError(v__gen__c__UnsupportedAssertCtempTransform* x) {
	return (IError) {
		._v__gen__c__UnsupportedAssertCtempTransform = x,
		._typ = _IError_v__gen__c__UnsupportedAssertCtempTransform_index,
		.msg = (string*)((char*)x + __offsetof_ptr(x, v__gen__c__UnsupportedAssertCtempTransform, msg)),
		.code = (int*)((char*)x + __offsetof_ptr(x, v__gen__c__UnsupportedAssertCtempTransform, code)),
	};
}

// Casting functions for converting "semver__InvalidComparatorCountError" to interface "IError"
static inline IError I_semver__InvalidComparatorCountError_to_Interface_IError(semver__InvalidComparatorCountError* x) {
	return (IError) {
		._semver__InvalidComparatorCountError = x,
		._typ = _IError_semver__InvalidComparatorCountError_index,
		.msg = (string*)((char*)x + __offsetof_ptr(x, semver__InvalidComparatorCountError, msg)),
		.code = (int*)((char*)x + __offsetof_ptr(x, semver__InvalidComparatorCountError, code)),
	};
}

// Casting functions for converting "voidptr" to interface "IError"
static inline IError I_voidptr_to_Interface_IError(voidptr* x) {
	return (IError) {
		._voidptr = x,
		._typ = _IError_voidptr_index,
		.msg = (string*)((char*)x/*.... ast.voidptr_type */),
		.code = (int*)((char*)x/*.... ast.voidptr_type */),
	};
}

static rand__PRNG I_rand__wyrand__WyRandRNG_to_Interface_rand__PRNG(rand__wyrand__WyRandRNG* x);
const int _rand__PRNG_rand__wyrand__WyRandRNG_index = 0;
// ^^^ number of types for interface rand__PRNG: 1

// Methods wrapper for interface "rand__PRNG"

struct _rand__PRNG_interface_methods {
	void (*_method_seed)(void* _, Array_u32 seed_data);
	u32 (*_method_u32)(void* _);
	u64 (*_method_u64)(void* _);
	u32 (*_method_u32n)(void* _, u32 max);
	u64 (*_method_u64n)(void* _, u64 max);
	u32 (*_method_u32_in_range)(void* _, u32 min, u32 max);
	u64 (*_method_u64_in_range)(void* _, u64 min, u64 max);
	int (*_method__v_int)(void* _);
	i64 (*_method_i64)(void* _);
	int (*_method_int31)(void* _);
	i64 (*_method_int63)(void* _);
	int (*_method_intn)(void* _, int max);
	i64 (*_method_i64n)(void* _, i64 max);
	int (*_method_int_in_range)(void* _, int min, int max);
	i64 (*_method_i64_in_range)(void* _, i64 min, i64 max);
	f32 (*_method_f32)(void* _);
	f64 (*_method_f64)(void* _);
	f32 (*_method_f32n)(void* _, f32 max);
	f64 (*_method_f64n)(void* _, f64 max);
	f32 (*_method_f32_in_range)(void* _, f32 min, f32 max);
	f64 (*_method_f64_in_range)(void* _, f64 min, f64 max);
	void (*_method__v_free)(void* _);
};

struct _rand__PRNG_interface_methods rand__PRNG_name_table[1] = {
	{
		._method_seed = (void*) rand__wyrand__WyRandRNG_seed,
		._method_u32 = (void*) rand__wyrand__WyRandRNG_u32,
		._method_u64 = (void*) rand__wyrand__WyRandRNG_u64,
		._method_u32n = (void*) rand__wyrand__WyRandRNG_u32n,
		._method_u64n = (void*) rand__wyrand__WyRandRNG_u64n,
		._method_u32_in_range = (void*) rand__wyrand__WyRandRNG_u32_in_range,
		._method_u64_in_range = (void*) rand__wyrand__WyRandRNG_u64_in_range,
		._method__v_int = (void*) rand__wyrand__WyRandRNG_int,
		._method_i64 = (void*) rand__wyrand__WyRandRNG_i64,
		._method_int31 = (void*) rand__wyrand__WyRandRNG_int31,
		._method_int63 = (void*) rand__wyrand__WyRandRNG_int63,
		._method_intn = (void*) rand__wyrand__WyRandRNG_intn,
		._method_i64n = (void*) rand__wyrand__WyRandRNG_i64n,
		._method_int_in_range = (void*) rand__wyrand__WyRandRNG_int_in_range,
		._method_i64_in_range = (void*) rand__wyrand__WyRandRNG_i64_in_range,
		._method_f32 = (void*) rand__wyrand__WyRandRNG_f32,
		._method_f64 = (void*) rand__wyrand__WyRandRNG_f64,
		._method_f32n = (void*) rand__wyrand__WyRandRNG_f32n,
		._method_f64n = (void*) rand__wyrand__WyRandRNG_f64n,
		._method_f32_in_range = (void*) rand__wyrand__WyRandRNG_f32_in_range,
		._method_f64_in_range = (void*) rand__wyrand__WyRandRNG_f64_in_range,
		._method__v_free = (void*) rand__wyrand__WyRandRNG_free,
	},
};


// Casting functions for converting "rand__wyrand__WyRandRNG" to interface "rand__PRNG"
static inline rand__PRNG I_rand__wyrand__WyRandRNG_to_Interface_rand__PRNG(rand__wyrand__WyRandRNG* x) {
	return (rand__PRNG) {
		._rand__wyrand__WyRandRNG = x,
		._typ = _rand__PRNG_rand__wyrand__WyRandRNG_index,
	};
}

// ^^^ number of types for interface hash__Hasher: 0

// Methods wrapper for interface "hash__Hasher"

struct _hash__Hasher_interface_methods {
	Array_byte (*_method_sum)(void* _, Array_byte b);
	int (*_method_size)(void* _);
	int (*_method_block_size)(void* _);
};

struct _hash__Hasher_interface_methods hash__Hasher_name_table[1];



// ^^^ number of types for interface hash__Hash32er: 0

// Methods wrapper for interface "hash__Hash32er"

struct _hash__Hash32er_interface_methods {
	u32 (*_method_sum32)(void* _);
};

struct _hash__Hash32er_interface_methods hash__Hash32er_name_table[1];



// ^^^ number of types for interface hash__Hash64er: 0

// Methods wrapper for interface "hash__Hash64er"

struct _hash__Hash64er_interface_methods {
	u64 (*_method_sum64)(void* _);
};

struct _hash__Hash64er_interface_methods hash__Hash64er_name_table[1];



static v__ast__walker__Visitor I_v__ast__walker__Inspector_to_Interface_v__ast__walker__Visitor(v__ast__walker__Inspector* x);
const int _v__ast__walker__Visitor_v__ast__walker__Inspector_index = 0;
static v__ast__walker__Visitor I_v__callgraph__Mapper_to_Interface_v__ast__walker__Visitor(v__callgraph__Mapper* x);
const int _v__ast__walker__Visitor_v__callgraph__Mapper_index = 1;
// ^^^ number of types for interface v__ast__walker__Visitor: 2

// Methods wrapper for interface "v__ast__walker__Visitor"

struct _v__ast__walker__Visitor_interface_methods {
	Option_void (*_method_visit)(void* _, v__ast__Node* node);
};

struct _v__ast__walker__Visitor_interface_methods v__ast__walker__Visitor_name_table[2] = {
	{
		._method_visit = (void*) v__ast__walker__Inspector_visit,
	},
	{
		._method_visit = (void*) v__callgraph__Mapper_visit,
	},
};


// Casting functions for converting "v__ast__walker__Inspector" to interface "v__ast__walker__Visitor"
static inline v__ast__walker__Visitor I_v__ast__walker__Inspector_to_Interface_v__ast__walker__Visitor(v__ast__walker__Inspector* x) {
	return (v__ast__walker__Visitor) {
		._v__ast__walker__Inspector = x,
		._typ = _v__ast__walker__Visitor_v__ast__walker__Inspector_index,
	};
}

// Casting functions for converting "v__callgraph__Mapper" to interface "v__ast__walker__Visitor"
static inline v__ast__walker__Visitor I_v__callgraph__Mapper_to_Interface_v__ast__walker__Visitor(v__callgraph__Mapper* x) {
	return (v__ast__walker__Visitor) {
		._v__callgraph__Mapper = x,
		._typ = _v__ast__walker__Visitor_v__callgraph__Mapper_index,
	};
}



// V gowrappers:
u32 sync__pool__process_in_thread_thread_wrapper(thread_arg_sync__pool__process_in_thread *arg) {
	sync__pool__process_in_thread(arg->arg1, arg->arg2);
	free(arg);
	return 0;
}

// V shared type functions:
static inline voidptr __dup__shared__Array_string(voidptr src, int sz) {
	__shared__Array_string* dest = memdup(src, sz);
	sync__RwMutex_init(&dest->mtx);
	return dest;
}
static inline voidptr __dup__shared__Map_string_bool(voidptr src, int sz) {
	__shared__Map_string_bool* dest = memdup(src, sz);
	sync__RwMutex_init(&dest->mtx);
	return dest;
}

typedef struct __shared_map __shared_map;
struct __shared_map {
	sync__RwMutex mtx;
	map val;
};
static inline voidptr __dup_shared_map(voidptr src, int sz) {
	__shared_map* dest = memdup(src, sz);
	sync__RwMutex_init(&dest->mtx);
	return dest;
}
typedef struct __shared_array __shared_array;
struct __shared_array {
	sync__RwMutex mtx;
	array val;
};
static inline voidptr __dup_shared_array(voidptr src, int sz) {
	__shared_array* dest = memdup(src, sz);
	sync__RwMutex_init(&dest->mtx);
	return dest;
}
static inline void __sort_ptr(uintptr_t a[], bool b[], int l) {
	for (int i=1; i<l; i++) {
		uintptr_t ins = a[i];
		bool insb = b[i];
		int j = i;
		while(j>0 && a[j-1] > ins) {
			a[j] = a[j-1];
			b[j] = b[j-1];
			j--;
		}
		a[j] = ins;
		b[j] = insb;
	}
}

// V stringliterals:

// >> string literal consts
void vinit_string_literals(void){
	_const_math__bits__overflow_error = _SLIT("Overflow Error");
	_const_math__bits__divide_error = _SLIT("Divide Error");
	_const_strconv__digit_pairs = _SLIT("00102030405060708090011121314151617181910212223242526272829203132333435363738393041424344454647484940515253545556575859506162636465666768696071727374757677787970818283848586878889809192939495969798999");
	_const_strconv__base_digits = _SLIT("0123456789abcdefghijklmnopqrstuvwxyz");
	_const_digit_pairs = _SLIT("00102030405060708090011121314151617181910212223242526272829203132333435363738393041424344454647484940515253545556575859506162636465666768696071727374757677787970818283848586878889809192939495969798999");
	_const_si_s_code = _SLIT("0xfe10");
	_const_si_g32_code = _SLIT("0xfe0e");
	_const_si_g64_code = _SLIT("0xfe0f");
	_const_time__days_string = _SLIT("MonTueWedThuFriSatSun");
	_const_time__months_string = _SLIT("JanFebMarAprMayJunJulAugSepOctNovDec");
	_const_flag__space = _SLIT("                            ");
	_const_flag__underline = _SLIT("-----------------------------------------------");
	_const_semver__comparator_sep = _SLIT(" ");
	_const_semver__comparator_set_sep = _SLIT(" || ");
	_const_semver__hyphen_range_sep = _SLIT(" - ");
	_const_semver__x_range_symbols = _SLIT("Xx*");
	_const_os__path_separator = _SLIT("\\");
	_const_os__path_delimiter = _SLIT(";");
	_const_v__util__version__v_version = _SLIT("0.2.4");
	_const_v__cflag__fexisting_literal = _SLIT("$first_existing");
	_const_v__pkgconfig__version = _SLIT("0.3.2");
	_const_rand__ulid_encoding = _SLIT("0123456789ABCDEFGHJKMNPQRSTVWXYZ");
	_const_rand__english_letters = _SLIT("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
	_const_rand__hex_chars = _SLIT("abcdef0123456789");
	_const_rand__ascii_chars = _SLIT("!\"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ\\^_`abcdefghijklmnopqrstuvwxyz{|}~");
	_const_v__pref__cc_to_windows = _SLIT("x86_64-w64-mingw32-gcc");
	_const_v__pref__cc_to_linux = _SLIT("clang");
	_const_help__unknown_topic = _SLIT("`v help`: unknown help topic provided. Use `v help` for usage information.");
	_const_v__util__double_escape = _SLIT("\\\\");
	_const_v__util__map_prefix = _SLIT("map[string]");
	_const_v__checker__hex_lit_overflow_message = _SLIT("hex character literal overflows string");
	_const_v__checker__vroot_is_deprecated_message = _SLIT("@VROOT is deprecated, use @VMODROOT or @VEXEROOT instead");
	_const_v__gen__c__si_s_code = _SLIT("0xfe10");
	_const_v__gen__c__c_commit_hash_default = _SLIT("\n#ifndef V_COMMIT_HASH\n	#define V_COMMIT_HASH \"@@@\"\n#endif\n");
	_const_v__gen__c__c_current_commit_hash_default = _SLIT("\n#ifndef V_CURRENT_COMMIT_HASH\n	#define V_CURRENT_COMMIT_HASH \"@@@\"\n#endif\n");
	_const_v__gen__c__c_concurrency_helpers = _SLIT("\ntypedef struct __shared_map __shared_map;\nstruct __shared_map {\n	sync__RwMutex mtx;\n	map val;\n};\nstatic inline voidptr __dup_shared_map(voidptr src, int sz) {\n	__shared_map* dest = memdup(src, sz);\n	sync__RwMutex_init(&dest->mtx);\n	return dest;\n}\ntypedef struct __shared_array __shared_array;\nstruct __shared_array {\n	sync__RwMutex mtx;\n	array val;\n};\nstatic inline voidptr __dup_shared_array(voidptr src, int sz) {\n	__shared_array* dest = memdup(src, sz);\n	sync__RwMutex_init(&dest->mtx);\n	return dest;\n}\nstatic inline void __sort_ptr(uintptr_t a[], bool b[], int l) {\n	for (int i=1; i<l; i++) {\n		uintptr_t ins = a[i];\n		bool insb = b[i];\n		int j = i;\n		while(j>0 && a[j-1] > ins) {\n			a[j] = a[j-1];\n			b[j] = b[j-1];\n			j--;\n		}\n		a[j] = ins;\n		b[j] = insb;\n	}\n}\n");
	_const_v__gen__c__c_common_macros = _SLIT("\n#define EMPTY_VARG_INITIALIZATION 0\n#define EMPTY_STRUCT_DECLARATION\n#define EMPTY_STRUCT_INITIALIZATION\n// Due to a tcc bug, the length of an array needs to be specified, but GCC crashes if it is...\n#define EMPTY_ARRAY_OF_ELEMS(x,n) (x[])\n#define TCCSKIP(x) x\n\n#define __NOINLINE __attribute__((noinline))\n#define __IRQHANDLER __attribute__((interrupt))\n\n#define __V_architecture 0\n#if defined(__x86_64__)\n	#define __V_amd64  1\n	#undef __V_architecture\n	#define __V_architecture 1\n#endif\n\n#if defined(__aarch64__) || defined(__arm64__)\n	#define __V_arm64  1\n	#undef __V_architecture\n	#define __V_architecture 2\n#endif\n\n// Using just __GNUC__ for detecting gcc, is not reliable because other compilers define it too:\n#ifdef __GNUC__\n	#define __V_GCC__\n#endif\n#ifdef __TINYC__\n	#undef __V_GCC__\n#endif\n#ifdef __cplusplus\n	#undef __V_GCC__\n#endif\n#ifdef __clang__\n	#undef __V_GCC__\n#endif\n#ifdef _MSC_VER\n	#undef __V_GCC__\n	#undef EMPTY_STRUCT_INITIALIZATION\n	#define EMPTY_STRUCT_INITIALIZATION 0\n#endif\n\n#ifdef __TINYC__\n	#undef EMPTY_STRUCT_DECLARATION\n	#define EMPTY_STRUCT_DECLARATION char _dummy\n	#undef EMPTY_ARRAY_OF_ELEMS\n	#define EMPTY_ARRAY_OF_ELEMS(x,n) (x[n])\n	#undef __NOINLINE\n	#undef __IRQHANDLER\n	// tcc does not support inlining at all\n	#define __NOINLINE\n	#define __IRQHANDLER\n	#undef TCCSKIP\n	#define TCCSKIP(x)\n	// #include <byteswap.h>\n	#ifndef _WIN32\n		#include <execinfo.h>\n		int tcc_backtrace(const char *fmt, ...);\n	#endif\n#endif\n\n// Use __offsetof_ptr instead of __offset_of, when you *do* have a valid pointer, to avoid UB:\n#ifndef __offsetof_ptr\n	#define __offsetof_ptr(ptr,PTYPE,FIELDNAME) ((size_t)((byte *)&((PTYPE *)ptr)->FIELDNAME - (byte *)ptr))\n#endif\n\n// for __offset_of\n#ifndef __offsetof\n	#define __offsetof(PTYPE,FIELDNAME) ((size_t)((char *)&((PTYPE *)0)->FIELDNAME - (char *)0))\n#endif\n\n// returns the number of CPU registers that TYPE takes up\n#define _REG_WIDTH(T) (((sizeof(T) + sizeof(void*) - 1) & ~(sizeof(void*) - 1)) / sizeof(void*))\n\n#define OPTION_CAST(x) (x)\n\n#ifndef V64_PRINTFORMAT\n	#ifdef PRIx64\n		#define V64_PRINTFORMAT \"0x%\"PRIx64\n	#elif defined(__WIN32__)\n		#define V64_PRINTFORMAT \"0x%I64x\"\n	#elif defined(__linux__) && defined(__LP64__)\n		#define V64_PRINTFORMAT \"0x%lx\"\n	#else\n		#define V64_PRINTFORMAT \"0x%llx\"\n	#endif\n#endif\n\n#if defined(_WIN32) || defined(__CYGWIN__)\n	#define VV_EXPORTED_SYMBOL extern __declspec(dllexport)\n	#define VV_LOCAL_SYMBOL static\n#else\n	// 4 < gcc < 5 is used by some older Ubuntu LTS and Centos versions,\n	// and does not support __has_attribute(visibility) ...\n	#ifndef __has_attribute\n		#define __has_attribute(x) 0  // Compatibility with non-clang compilers.\n	#endif\n	#if (defined(__GNUC__) && (__GNUC__ >= 4)) || (defined(__clang__) && __has_attribute(visibility))\n		#ifdef ARM\n			#define VV_EXPORTED_SYMBOL  extern __attribute__((externally_visible,visibility(\"default\")))\n		#else\n			#define VV_EXPORTED_SYMBOL  extern __attribute__((visibility(\"default\")))\n		#endif\n		#define VV_LOCAL_SYMBOL  __attribute__ ((visibility (\"hidden\")))\n	#else\n		#define VV_EXPORTED_SYMBOL extern\n		#define VV_LOCAL_SYMBOL static\n	#endif\n#endif\n\n#ifdef __cplusplus\n	#include <utility>\n	#define _MOV std::move\n#else\n	#define _MOV\n#endif\n\n// tcc does not support has_include properly yet, turn it off completely\n#if defined(__TINYC__) && defined(__has_include)\n#undef __has_include\n#endif\n\n\n#if !defined(VWEAK)\n	#define VWEAK __attribute__((weak))\n	#ifdef _MSC_VER\n		#undef VWEAK\n		#define VWEAK\n	#endif\n#endif\n\n#if !defined(VNORETURN)\n	#if defined(__TINYC__)\n		#include <stdnoreturn.h>\n		#define VNORETURN noreturn\n	#endif\n	# if !defined(__TINYC__) && defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L\n	#  define VNORETURN _Noreturn\n	# elif defined(__GNUC__) && __GNUC__ >= 2\n	#  define VNORETURN __attribute__((noreturn))\n	# endif\n	#ifndef VNORETURN\n		#define VNORETURN\n	#endif\n#endif\n\n#if !defined(VUNREACHABLE)\n	#if defined(__GNUC__) && !defined(__clang__)\n		#define V_GCC_VERSION  (__GNUC__ * 10000L + __GNUC_MINOR__ * 100L + __GNUC_PATCHLEVEL__)\n		#if (V_GCC_VERSION >= 40500L)\n			#define VUNREACHABLE()  do { __builtin_unreachable(); } while (0)\n		#endif\n	#endif\n	#if defined(__clang__) && defined(__has_builtin)\n		#if __has_builtin(__builtin_unreachable)\n			#define VUNREACHABLE()  do { __builtin_unreachable(); } while (0)\n		#endif\n	#endif\n	#ifndef VUNREACHABLE\n		#define VUNREACHABLE() do { } while (0)\n	#endif\n	#if defined(__FreeBSD__) && defined(__TINYC__)\n		#define VUNREACHABLE() do { } while (0)\n	#endif\n#endif\n\n//likely and unlikely macros\n#if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)\n	#define _likely_(x)  __builtin_expect(x,1)\n	#define _unlikely_(x)  __builtin_expect(x,0)\n#else\n	#define _likely_(x) (x)\n	#define _unlikely_(x) (x)\n#endif\n\n");
	_const_v__gen__c__c_unsigned_comparison_functions = _SLIT("\n// unsigned/signed comparisons\nstatic inline bool _us32_gt(uint32_t a, int32_t b) { return a > INT32_MAX || (int32_t)a > b; }\nstatic inline bool _us32_ge(uint32_t a, int32_t b) { return a >= INT32_MAX || (int32_t)a >= b; }\nstatic inline bool _us32_eq(uint32_t a, int32_t b) { return a <= INT32_MAX && (int32_t)a == b; }\nstatic inline bool _us32_ne(uint32_t a, int32_t b) { return a > INT32_MAX || (int32_t)a != b; }\nstatic inline bool _us32_le(uint32_t a, int32_t b) { return a <= INT32_MAX && (int32_t)a <= b; }\nstatic inline bool _us32_lt(uint32_t a, int32_t b) { return a < INT32_MAX && (int32_t)a < b; }\nstatic inline bool _us64_gt(uint64_t a, int64_t b) { return a > INT64_MAX || (int64_t)a > b; }\nstatic inline bool _us64_ge(uint64_t a, int64_t b) { return a >= INT64_MAX || (int64_t)a >= b; }\nstatic inline bool _us64_eq(uint64_t a, int64_t b) { return a <= INT64_MAX && (int64_t)a == b; }\nstatic inline bool _us64_ne(uint64_t a, int64_t b) { return a > INT64_MAX || (int64_t)a != b; }\nstatic inline bool _us64_le(uint64_t a, int64_t b) { return a <= INT64_MAX && (int64_t)a <= b; }\nstatic inline bool _us64_lt(uint64_t a, int64_t b) { return a < INT64_MAX && (int64_t)a < b; }\n");
	_const_v__gen__c__c_helper_macros = _SLIT("//============================== HELPER C MACROS =============================*/\n// _SLIT0 is used as NULL string for literal arguments\n// `\"\" s` is used to enforce a string literal argument\n#define _SLIT0 (string){.str=(byteptr)(\"\"), .len=0, .is_lit=1}\n#define _SLIT(s) ((string){.str=(byteptr)(\"\" s), .len=(sizeof(s)-1), .is_lit=1})\n#define _SLEN(s, n) ((string){.str=(byteptr)(\"\" s), .len=n, .is_lit=1})\n\n// take the address of an rvalue\n#define ADDR(type, expr) (&((type[]){expr}[0]))\n\n// copy something to the heap\n#define HEAP(type, expr) ((type*)memdup((void*)&((type[]){expr}[0]), sizeof(type)))\n#define HEAP_noscan(type, expr) ((type*)memdup_noscan((void*)&((type[]){expr}[0]), sizeof(type)))\n\n#define _PUSH_MANY(arr, val, tmp, tmp_typ) {tmp_typ tmp = (val); array_push_many(arr, tmp.data, tmp.len);}\n#define _PUSH_MANY_noscan(arr, val, tmp, tmp_typ) {tmp_typ tmp = (val); array_push_many_noscan(arr, tmp.data, tmp.len);}\n");
	_const_v__gen__c__c_builtin_types = _SLIT("\n//================================== builtin types ================================*/\ntypedef int64_t i64;\ntypedef int16_t i16;\ntypedef int8_t i8;\ntypedef uint64_t u64;\ntypedef uint32_t u32;\ntypedef uint8_t u8;\ntypedef uint16_t u16;\ntypedef uint8_t byte;\ntypedef uint32_t rune;\ntypedef size_t usize;\ntypedef ptrdiff_t isize;\ntypedef float f32;\ntypedef double f64;\ntypedef int64_t int_literal;\ntypedef double float_literal;\ntypedef unsigned char* byteptr;\ntypedef void* voidptr;\ntypedef char* charptr;\ntypedef byte array_fixed_byte_300 [300];\n\ntypedef struct sync__Channel* chan;\n\n#ifndef __cplusplus\n	#ifndef bool\n		#ifdef CUSTOM_DEFINE_4bytebool\n			typedef int bool;\n		#else\n			typedef byte bool;\n		#endif\n		#define true 1\n		#define false 0\n	#endif\n#endif\n\ntypedef u64 (*MapHashFn)(voidptr);\ntypedef bool (*MapEqFn)(voidptr, voidptr);\ntypedef void (*MapCloneFn)(voidptr, voidptr);\ntypedef void (*MapFreeFn)(voidptr);\n");
	_const_v__gen__c__c_wyhash_headers = _SLIT("\n// ============== wyhash ==============\n#ifndef wyhash_final_version_3\n#define wyhash_final_version_3\n\n#ifndef WYHASH_CONDOM\n// protections that produce different results:\n// 1: normal valid behavior\n// 2: extra protection against entropy loss (probability=2^-63), aka. \"blind multiplication\"\n#define WYHASH_CONDOM 1\n#endif\n\n#ifndef WYHASH_32BIT_MUM\n// 0: normal version, slow on 32 bit systems\n// 1: faster on 32 bit systems but produces different results, incompatible with wy2u0k function\n#define WYHASH_32BIT_MUM 0\n#endif\n\n// includes\n#include <stdint.h>\n#if defined(_MSC_VER) && defined(_M_X64)\n	#include <intrin.h>\n	#pragma intrinsic(_umul128)\n#endif\n\n// 128bit multiply function\nstatic inline uint64_t _wyrot(uint64_t x) { return (x>>32)|(x<<32); }\nstatic inline void _wymum(uint64_t *A, uint64_t *B){\n#if(WYHASH_32BIT_MUM)\n	uint64_t hh=(*A>>32)*(*B>>32), hl=(*A>>32)*(uint32_t)*B, lh=(uint32_t)*A*(*B>>32), ll=(uint64_t)(uint32_t)*A*(uint32_t)*B;\n	#if(WYHASH_CONDOM>1)\n	*A^=_wyrot(hl)^hh; *B^=_wyrot(lh)^ll;\n	#else\n	*A=_wyrot(hl)^hh; *B=_wyrot(lh)^ll;\n	#endif\n#elif defined(__SIZEOF_INT128__)\n	__uint128_t r=*A; r*=*B;\n	#if(WYHASH_CONDOM>1)\n	*A^=(uint64_t)r; *B^=(uint64_t)(r>>64);\n	#else\n	*A=(uint64_t)r; *B=(uint64_t)(r>>64);\n	#endif\n#elif defined(_MSC_VER) && defined(_M_X64)\n	#if(WYHASH_CONDOM>1)\n	uint64_t  a,  b;\n	a=_umul128(*A,*B,&b);\n	*A^=a;  *B^=b;\n	#else\n	*A=_umul128(*A,*B,B);\n	#endif\n#else\n	uint64_t ha=*A>>32, hb=*B>>32, la=(uint32_t)*A, lb=(uint32_t)*B, hi, lo;\n	uint64_t rh=ha*hb, rm0=ha*lb, rm1=hb*la, rl=la*lb, t=rl+(rm0<<32), c=t<rl;\n	lo=t+(rm1<<32); c+=lo<t; hi=rh+(rm0>>32)+(rm1>>32)+c;\n	#if(WYHASH_CONDOM>1)\n	*A^=lo;  *B^=hi;\n	#else\n	*A=lo;  *B=hi;\n	#endif\n#endif\n}\n\n// multiply and xor mix function, aka MUM\nstatic inline uint64_t _wymix(uint64_t A, uint64_t B){ _wymum(&A,&B); return A^B; }\n\n// endian macros\n#ifndef WYHASH_LITTLE_ENDIAN\n	#ifdef TARGET_ORDER_IS_LITTLE\n		#define WYHASH_LITTLE_ENDIAN 1\n	#else\n		#define WYHASH_LITTLE_ENDIAN 0\n	#endif\n#endif\n\n// read functions\n#if (WYHASH_LITTLE_ENDIAN)\n	static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return v;}\n	static inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&v, p, 4); return v;}\n#elif defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)\n	static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return __builtin_bswap64(v);}\n	static inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&v, p, 4); return __builtin_bswap32(v);}\n#elif defined(_MSC_VER)\n	static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return _byteswap_uint64(v);}\n	static inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&v, p, 4); return _byteswap_ulong(v);}\n#else\n	static inline uint64_t _wyr8(const uint8_t *p) {\n		uint64_t v; memcpy(&v, p, 8);\n		return (((v >> 56) & 0xff)| ((v >> 40) & 0xff00)| ((v >> 24) & 0xff0000)| ((v >>  8) & 0xff000000)| ((v <<  8) & 0xff00000000)| ((v << 24) & 0xff0000000000)| ((v << 40) & 0xff000000000000)| ((v << 56) & 0xff00000000000000));\n	}\n	static inline uint64_t _wyr4(const uint8_t *p) {\n		uint32_t v; memcpy(&v, p, 4);\n		return (((v >> 24) & 0xff)| ((v >>  8) & 0xff00)| ((v <<  8) & 0xff0000)| ((v << 24) & 0xff000000));\n	}\n#endif\nstatic inline uint64_t _wyr3(const uint8_t *p, size_t k) { return (((uint64_t)p[0])<<16)|(((uint64_t)p[k>>1])<<8)|p[k-1];}\n// wyhash main function\nstatic inline uint64_t wyhash(const void *key, size_t len, uint64_t seed, const uint64_t *secret){\n	const uint8_t *p=(const uint8_t *)key; seed^=*secret;	uint64_t a, b;\n	if (_likely_(len<=16)) {\n		if (_likely_(len>=4)) { a=(_wyr4(p)<<32)|_wyr4(p+((len>>3)<<2)); b=(_wyr4(p+len-4)<<32)|_wyr4(p+len-4-((len>>3)<<2)); }\n		else if (_likely_(len>0)) { a=_wyr3(p,len); b=0; }\n		else a=b=0;\n	} else {\n		size_t i=len;\n		if (_unlikely_(i>48)) {\n			uint64_t see1=seed, see2=seed;\n			do {\n				seed=_wymix(_wyr8(p)^secret[1],_wyr8(p+8)^seed);\n				see1=_wymix(_wyr8(p+16)^secret[2],_wyr8(p+24)^see1);\n				see2=_wymix(_wyr8(p+32)^secret[3],_wyr8(p+40)^see2);\n				p+=48; i-=48;\n			} while(_likely_(i>48));\n			seed^=see1^see2;\n		}\n		while(_unlikely_(i>16)) { seed=_wymix(_wyr8(p)^secret[1],_wyr8(p+8)^seed);  i-=16; p+=16; }\n		a=_wyr8(p+i-16);  b=_wyr8(p+i-8);\n	}\n	return _wymix(secret[1]^len,_wymix(a^secret[1],b^seed));\n}\n// the default secret parameters\nstatic const uint64_t _wyp[4] = {0xa0761d6478bd642full, 0xe7037ed1a0b428dbull, 0x8ebc6af09c88c6e3ull, 0x589965cc75374cc3ull};\n\n// a useful 64bit-64bit mix function to produce deterministic pseudo random numbers that can pass BigCrush and PractRand\nstatic inline uint64_t wyhash64(uint64_t A, uint64_t B){ A^=0xa0761d6478bd642full; B^=0xe7037ed1a0b428dbull; _wymum(&A,&B); return _wymix(A^0xa0761d6478bd642full,B^0xe7037ed1a0b428dbull);}\n\n// the wyrand PRNG that pass BigCrush and PractRand\nstatic inline uint64_t wyrand(uint64_t *seed){ *seed+=0xa0761d6478bd642full; return _wymix(*seed,*seed^0xe7037ed1a0b428dbull);}\n\n#ifndef __vinix__\n// convert any 64 bit pseudo random numbers to uniform distribution [0,1). It can be combined with wyrand, wyhash64 or wyhash.\nstatic inline double wy2u01(uint64_t r){ const double _wynorm=1.0/(1ull<<52); return (r>>12)*_wynorm;}\n\n// convert any 64 bit pseudo random numbers to APPROXIMATE Gaussian distribution. It can be combined with wyrand, wyhash64 or wyhash.\nstatic inline double wy2gau(uint64_t r){ const double _wynorm=1.0/(1ull<<20); return ((r&0x1fffff)+((r>>21)&0x1fffff)+((r>>42)&0x1fffff))*_wynorm-3.0;}\n#endif\n\n#if(!WYHASH_32BIT_MUM)\n// fast range integer random number generation on [0,k) credit to Daniel Lemire. May not work when WYHASH_32BIT_MUM=1. It can be combined with wyrand, wyhash64 or wyhash.\nstatic inline uint64_t wy2u0k(uint64_t r, uint64_t k){ _wymum(&r,&k); return k; }\n#endif\n#endif\n\n#define _IN_MAP(val, m) map_exists(m, val)\n\n");
	_const_v__gen__c__closure_ctx = _SLIT("_V_closure_ctx");
	_const_v__gen__c__posix_hotcode_definitions_1 = _SLIT("\nvoid v_bind_live_symbols(void* live_lib){\n	@LOAD_FNS@\n}\n");
	_const_v__gen__c__windows_hotcode_definitions_1 = _SLIT("\nvoid v_bind_live_symbols(void* live_lib){\n	@LOAD_FNS@\n}\n");
	_const_v__builder__c_verror_message_marker = _SLIT("VERROR_MESSAGE ");
	_const_v__builder__c_error_info = _SLIT("\n==================\nC error. This should never happen.\n\nThis is a compiler bug, please report it using `v bug file.v`.\n\nhttps://github.com/vlang/v/issues/new/choose\n\nYou can also use #help on Discord: https://discord.gg/vlang\n");
	_const_v__builder__no_compiler_error = _SLIT("\n==================\nError: no C compiler detected.\n\nYou can find instructions on how to install one in the V wiki:\nhttps://github.com/vlang/v/wiki/Installing-a-C-compiler-on-Windows\n\nIf you think you have one installed, make sure it is in your PATH.\nIf you do have one in your PATH, please raise an issue on GitHub:\nhttps://github.com/vlang/v/issues/new/choose\n\nYou can also use `v doctor`, to see what V knows about your current environment.\n\nYou can also seek #help on Discord: https://discord.gg/vlang\n");
}
// << string literal consts


// V auto str functions:
static string time__FormatTime_str(time__FormatTime it) { /* gen_str_for_enum */
	switch(it) {
		case time__FormatTime__hhmm12: return _SLIT("hhmm12");
		case time__FormatTime__hhmm24: return _SLIT("hhmm24");
		case time__FormatTime__hhmmss12: return _SLIT("hhmmss12");
		case time__FormatTime__hhmmss24: return _SLIT("hhmmss24");
		case time__FormatTime__hhmmss24_milli: return _SLIT("hhmmss24_milli");
		case time__FormatTime__hhmmss24_micro: return _SLIT("hhmmss24_micro");
		case time__FormatTime__no_time: return _SLIT("no_time");
		default: return _SLIT("unknown enum value");
	}
}
static string time__FormatDate_str(time__FormatDate it) { /* gen_str_for_enum */
	switch(it) {
		case time__FormatDate__ddmmyy: return _SLIT("ddmmyy");
		case time__FormatDate__ddmmyyyy: return _SLIT("ddmmyyyy");
		case time__FormatDate__mmddyy: return _SLIT("mmddyy");
		case time__FormatDate__mmddyyyy: return _SLIT("mmddyyyy");
		case time__FormatDate__mmmd: return _SLIT("mmmd");
		case time__FormatDate__mmmdd: return _SLIT("mmmdd");
		case time__FormatDate__mmmddyy: return _SLIT("mmmddyy");
		case time__FormatDate__mmmddyyyy: return _SLIT("mmmddyyyy");
		case time__FormatDate__no_date: return _SLIT("no_date");
		case time__FormatDate__yyyymmdd: return _SLIT("yyyymmdd");
		case time__FormatDate__yymmdd: return _SLIT("yymmdd");
		default: return _SLIT("unknown enum value");
	}
}
static string v__pref__Backend_str(v__pref__Backend it) { /* gen_str_for_enum */
	switch(it) {
		case v__pref__Backend__c: return _SLIT("c");
		case v__pref__Backend__js_node: return _SLIT("js_node");
		case v__pref__Backend__js_browser: return _SLIT("js_browser");
		case v__pref__Backend__js_freestanding: return _SLIT("js_freestanding");
		case v__pref__Backend__native: return _SLIT("native");
		case v__pref__Backend__interpret: return _SLIT("interpret");
		default: return _SLIT("unknown enum value");
	}
}
static string v__ast__AttrKind_str(v__ast__AttrKind it) { /* gen_str_for_enum */
	switch(it) {
		case v__ast__AttrKind__plain: return _SLIT("plain");
		case v__ast__AttrKind__string: return _SLIT("string");
		case v__ast__AttrKind__number: return _SLIT("number");
		case v__ast__AttrKind__bool: return _SLIT("bool");
		case v__ast__AttrKind__comptime_define: return _SLIT("comptime_define");
		default: return _SLIT("unknown enum value");
	}
}
static string Array_v__ast__Expr_str(Array_v__ast__Expr a) { return indent_Array_v__ast__Expr_str(a, 0);}
static string indent_Array_v__ast__Expr_str(Array_v__ast__Expr a, int indent_count) {
	strings__Builder sb = strings__new_builder(a.len * 10);
	strings__Builder_write_string(&sb, _SLIT("["));
	for (int i = 0; i < a.len; ++i) {
		v__ast__Expr it = *(v__ast__Expr*)array_get(a, i);
		strings__Builder_write_string(&sb, _SLIT(""));
		string x = v__ast__Expr_str(  it);
		strings__Builder_write_string(&sb, x);
		if (i < a.len-1) {
			strings__Builder_write_string(&sb, _SLIT(", "));
		}
	}
	strings__Builder_write_string(&sb, _SLIT("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
static string v__ast__CallExpr_str(v__ast__CallExpr it) { return indent_v__ast__CallExpr_str(it, 0);}
static string v__ast__TypeInfo_str(v__ast__TypeInfo x) { return indent_v__ast__TypeInfo_str(x, 0); }
static string v__ast__Fn_str(v__ast__Fn it) { return indent_v__ast__Fn_str(it, 0);}
static string v__ast__Language_str(v__ast__Language it) { /* gen_str_for_enum */
	switch(it) {
		case v__ast__Language__v: return _SLIT("v");
		case v__ast__Language__c: return _SLIT("c");
		case v__ast__Language__js: return _SLIT("js");
		case v__ast__Language__amd64: return _SLIT("amd64");
		case v__ast__Language__i386: return _SLIT("i386");
		case v__ast__Language__arm64: return _SLIT("arm64");
		case v__ast__Language__arm32: return _SLIT("arm32");
		case v__ast__Language__rv64: return _SLIT("rv64");
		case v__ast__Language__rv32: return _SLIT("rv32");
		default: return _SLIT("unknown enum value");
	}
}
static string v__ast__IdentKind_str(v__ast__IdentKind it) { /* gen_str_for_enum */
	switch(it) {
		case v__ast__IdentKind__unresolved: return _SLIT("unresolved");
		case v__ast__IdentKind__blank_ident: return _SLIT("blank_ident");
		case v__ast__IdentKind__variable: return _SLIT("variable");
		case v__ast__IdentKind__constant: return _SLIT("constant");
		case v__ast__IdentKind__global: return _SLIT("global");
		case v__ast__IdentKind__function: return _SLIT("function");
		default: return _SLIT("unknown enum value");
	}
}
static string Array_v__ast__Attr_str(Array_v__ast__Attr a) { return indent_Array_v__ast__Attr_str(a, 0);}
static string indent_Array_v__ast__Attr_str(Array_v__ast__Attr a, int indent_count) {
	strings__Builder sb = strings__new_builder(a.len * 10);
	strings__Builder_write_string(&sb, _SLIT("["));
	for (int i = 0; i < a.len; ++i) {
		v__ast__Attr it = *(v__ast__Attr*)array_get(a, i);
		strings__Builder_write_string(&sb, _SLIT(""));
		string x = v__ast__Attr_str( & it);
		strings__Builder_write_string(&sb, x);
		if (i < a.len-1) {
			strings__Builder_write_string(&sb, _SLIT(", "));
		}
	}
	strings__Builder_write_string(&sb, _SLIT("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
static string v__token__Position_str(v__token__Position it) { return indent_v__token__Position_str(it, 0);}
static string v__pref__Arch_str(v__pref__Arch it) { /* gen_str_for_enum */
	switch(it) {
		case v__pref__Arch___auto: return _SLIT("_auto");
		case v__pref__Arch__amd64: return _SLIT("amd64");
		case v__pref__Arch__arm64: return _SLIT("arm64");
		case v__pref__Arch__arm32: return _SLIT("arm32");
		case v__pref__Arch__rv64: return _SLIT("rv64");
		case v__pref__Arch__rv32: return _SLIT("rv32");
		case v__pref__Arch__i386: return _SLIT("i386");
		case v__pref__Arch__js_node: return _SLIT("js_node");
		case v__pref__Arch__js_browser: return _SLIT("js_browser");
		case v__pref__Arch__js_freestanding: return _SLIT("js_freestanding");
		case v__pref__Arch___max: return _SLIT("_max");
		default: return _SLIT("unknown enum value");
	}
}
static string v__gen__c__SqlType_str(v__gen__c__SqlType it) { /* gen_str_for_enum */
	switch(it) {
		case v__gen__c__SqlType__sqlite3: return _SLIT("sqlite3");
		case v__gen__c__SqlType__mysql: return _SLIT("mysql");
		case v__gen__c__SqlType__psql: return _SLIT("psql");
		case v__gen__c__SqlType__mssql: return _SLIT("mssql");
		case v__gen__c__SqlType__unknown: return _SLIT("unknown");
		default: return _SLIT("unknown enum value");
	}
}
static string v__errors__Reporter_str(v__errors__Reporter it) { /* gen_str_for_enum */
	switch(it) {
		case v__errors__Reporter__scanner: return _SLIT("scanner");
		case v__errors__Reporter__parser: return _SLIT("parser");
		case v__errors__Reporter__checker: return _SLIT("checker");
		case v__errors__Reporter__builder: return _SLIT("builder");
		case v__errors__Reporter__gen: return _SLIT("gen");
		default: return _SLIT("unknown enum value");
	}
}
static string Array_v__cflag__CFlag_str(Array_v__cflag__CFlag a) { return indent_Array_v__cflag__CFlag_str(a, 0);}
static string indent_Array_v__cflag__CFlag_str(Array_v__cflag__CFlag a, int indent_count) {
	strings__Builder sb = strings__new_builder(a.len * 10);
	strings__Builder_write_string(&sb, _SLIT("["));
	for (int i = 0; i < a.len; ++i) {
		v__cflag__CFlag it = *(v__cflag__CFlag*)array_get(a, i);
		strings__Builder_write_string(&sb, _SLIT(""));
		string x = v__cflag__CFlag_str( & it);
		strings__Builder_write_string(&sb, x);
		if (i < a.len-1) {
			strings__Builder_write_string(&sb, _SLIT(", "));
		}
	}
	strings__Builder_write_string(&sb, _SLIT("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
static string Array_v__ast__CallArg_str(Array_v__ast__CallArg a) { return indent_Array_v__ast__CallArg_str(a, 0);}
static string indent_Array_v__ast__CallArg_str(Array_v__ast__CallArg a, int indent_count) {
	strings__Builder sb = strings__new_builder(a.len * 10);
	strings__Builder_write_string(&sb, _SLIT("["));
	for (int i = 0; i < a.len; ++i) {
		v__ast__CallArg it = *(v__ast__CallArg*)array_get(a, i);
		strings__Builder_write_string(&sb, _SLIT(""));
		string x = v__ast__CallArg_str(  it);
		strings__Builder_write_string(&sb, x);
		if (i < a.len-1) {
			strings__Builder_write_string(&sb, _SLIT(", "));
		}
	}
	strings__Builder_write_string(&sb, _SLIT("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
static string Array_v__ast__Type_str(Array_v__ast__Type a) { return indent_Array_v__ast__Type_str(a, 0);}
static string indent_Array_v__ast__Type_str(Array_v__ast__Type a, int indent_count) {
	strings__Builder sb = strings__new_builder(a.len * 10);
	strings__Builder_write_string(&sb, _SLIT("["));
	for (int i = 0; i < a.len; ++i) {
		int it = *(int*)array_get(a, i);
		strings__Builder_write_string(&sb, _SLIT(""));
		string x = int_str(  it);
		strings__Builder_write_string(&sb, x);
		if (i < a.len-1) {
			strings__Builder_write_string(&sb, _SLIT(", "));
		}
	}
	strings__Builder_write_string(&sb, _SLIT("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
static string v__ast__OrExpr_str(v__ast__OrExpr it) { return indent_v__ast__OrExpr_str(it, 0);}
static string Array_v__ast__Comment_str(Array_v__ast__Comment a) { return indent_Array_v__ast__Comment_str(a, 0);}
static string indent_Array_v__ast__Comment_str(Array_v__ast__Comment a, int indent_count) {
	strings__Builder sb = strings__new_builder(a.len * 10);
	strings__Builder_write_string(&sb, _SLIT("["));
	for (int i = 0; i < a.len; ++i) {
		v__ast__Comment it = *(v__ast__Comment*)array_get(a, i);
		string x = indent_v__ast__Comment_str(it, indent_count);
		strings__Builder_write_string(&sb, x);
		if (i < a.len-1) {
			strings__Builder_write_string(&sb, _SLIT(", "));
		}
	}
	strings__Builder_write_string(&sb, _SLIT("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
static string v__ast__Aggregate_str(v__ast__Aggregate it) { return indent_v__ast__Aggregate_str(it, 0);}
static string v__ast__Alias_str(v__ast__Alias it) { return indent_v__ast__Alias_str(it, 0);}
static string v__ast__Array_str(v__ast__Array it) { return indent_v__ast__Array_str(it, 0);}
static string v__ast__ArrayFixed_str(v__ast__ArrayFixed it) { return indent_v__ast__ArrayFixed_str(it, 0);}
static string v__ast__Chan_str(v__ast__Chan it) { return indent_v__ast__Chan_str(it, 0);}
static string v__ast__Enum_str(v__ast__Enum it) { return indent_v__ast__Enum_str(it, 0);}
static string v__ast__FnType_str(v__ast__FnType it) { return indent_v__ast__FnType_str(it, 0);}
static string v__ast__GenericInst_str(v__ast__GenericInst it) { return indent_v__ast__GenericInst_str(it, 0);}
static string v__ast__Interface_str(v__ast__Interface it) { return indent_v__ast__Interface_str(it, 0);}
static string v__ast__Map_str(v__ast__Map it) { return indent_v__ast__Map_str(it, 0);}
static string v__ast__MultiReturn_str(v__ast__MultiReturn it) { return indent_v__ast__MultiReturn_str(it, 0);}
static string v__ast__Struct_str(v__ast__Struct it) { return indent_v__ast__Struct_str(it, 0);}
static string v__ast__SumType_str(v__ast__SumType it) { return indent_v__ast__SumType_str(it, 0);}
static string v__ast__Thread_str(v__ast__Thread it) { return indent_v__ast__Thread_str(it, 0);}
static string Array_v__ast__Param_str(Array_v__ast__Param a) { return indent_Array_v__ast__Param_str(a, 0);}
static string indent_Array_v__ast__Param_str(Array_v__ast__Param a, int indent_count) {
	strings__Builder sb = strings__new_builder(a.len * 10);
	strings__Builder_write_string(&sb, _SLIT("["));
	for (int i = 0; i < a.len; ++i) {
		v__ast__Param it = *(v__ast__Param*)array_get(a, i);
		string x = indent_v__ast__Param_str(it, indent_count);
		strings__Builder_write_string(&sb, x);
		if (i < a.len-1) {
			strings__Builder_write_string(&sb, _SLIT(", "));
		}
	}
	strings__Builder_write_string(&sb, _SLIT("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
static string Array_v__ast__Stmt_str(Array_v__ast__Stmt a) { return indent_Array_v__ast__Stmt_str(a, 0);}
static string indent_Array_v__ast__Stmt_str(Array_v__ast__Stmt a, int indent_count) {
	strings__Builder sb = strings__new_builder(a.len * 10);
	strings__Builder_write_string(&sb, _SLIT("["));
	for (int i = 0; i < a.len; ++i) {
		v__ast__Stmt it = *(v__ast__Stmt*)array_get(a, i);
		strings__Builder_write_string(&sb, _SLIT(""));
		string x = v__ast__Stmt_str(  it);
		strings__Builder_write_string(&sb, x);
		if (i < a.len-1) {
			strings__Builder_write_string(&sb, _SLIT(", "));
		}
	}
	strings__Builder_write_string(&sb, _SLIT("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
static string v__ast__OrKind_str(v__ast__OrKind it) { /* gen_str_for_enum */
	switch(it) {
		case v__ast__OrKind__absent: return _SLIT("absent");
		case v__ast__OrKind__block: return _SLIT("block");
		case v__ast__OrKind__propagate: return _SLIT("propagate");
		default: return _SLIT("unknown enum value");
	}
}
static string v__ast__Comment_str(v__ast__Comment it) { return indent_v__ast__Comment_str(it, 0);}
static string Array_v__ast__StructField_str(Array_v__ast__StructField a) { return indent_Array_v__ast__StructField_str(a, 0);}
static string indent_Array_v__ast__StructField_str(Array_v__ast__StructField a, int indent_count) {
	strings__Builder sb = strings__new_builder(a.len * 10);
	strings__Builder_write_string(&sb, _SLIT("["));
	for (int i = 0; i < a.len; ++i) {
		v__ast__StructField it = *(v__ast__StructField*)array_get(a, i);
		string x = indent_v__ast__StructField_str(it, indent_count);
		strings__Builder_write_string(&sb, x);
		if (i < a.len-1) {
			strings__Builder_write_string(&sb, _SLIT(", "));
		}
	}
	strings__Builder_write_string(&sb, _SLIT("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
static string Array_v__ast__Fn_str(Array_v__ast__Fn a) { return indent_Array_v__ast__Fn_str(a, 0);}
static string indent_Array_v__ast__Fn_str(Array_v__ast__Fn a, int indent_count) {
	strings__Builder sb = strings__new_builder(a.len * 10);
	strings__Builder_write_string(&sb, _SLIT("["));
	for (int i = 0; i < a.len; ++i) {
		v__ast__Fn it = *(v__ast__Fn*)array_get(a, i);
		string x = indent_v__ast__Fn_str(it, indent_count);
		strings__Builder_write_string(&sb, x);
		if (i < a.len-1) {
			strings__Builder_write_string(&sb, _SLIT(", "));
		}
	}
	strings__Builder_write_string(&sb, _SLIT("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
static string Map_int_Array_v__ast__Type_str(Map_int_Array_v__ast__Type m) { return indent_Map_int_Array_v__ast__Type_str(m, 0);}
static string indent_Map_int_Array_v__ast__Type_str(Map_int_Array_v__ast__Type m, int indent_count) { /* gen_str_for_map */
	strings__Builder sb = strings__new_builder(m.key_values.len*10);
	strings__Builder_write_string(&sb, _SLIT("{"));
	for (int i = 0; i < m.key_values.len; ++i) {
		if (!DenseArray_has_index(&m.key_values, i)) { continue; }
		int key = *(int*)DenseArray_key(&m.key_values, i);
		strings__Builder_write_string(&sb, int_str(key));
		strings__Builder_write_string(&sb, _SLIT(": "));
		strings__Builder_write_string(&sb, indent_Array_v__ast__Type_str(*(Array_v__ast__Type*)DenseArray_value(&m.key_values, i), indent_count));
		if (i != m.key_values.len-1) {
			strings__Builder_write_string(&sb, _SLIT(", "));
		}
	}
	strings__Builder_write_string(&sb, _SLIT("}"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
static string v__ast__Param_str(v__ast__Param it) { return indent_v__ast__Param_str(it, 0);}
static string v__ast__StructField_str(v__ast__StructField it) { return indent_v__ast__StructField_str(it, 0);}
void v__ast__Param_free(v__ast__Param* it) {
	v__token__Position_free(&(it->pos));
	string_free(&(it->name));
	v__token__Position_free(&(it->type_pos));
}

void Array_v__ast__Param_free(Array_v__ast__Param* it) {
	for (int i = 0; i < it->len; i++) {
		v__ast__Param_free(&(((v__ast__Param*)it->data)[i]));
	}
	array_free(it);
}

void v__ast__Attr_free(v__ast__Attr* it) {
	string_free(&(it->name));
	string_free(&(it->arg));
	v__token__Position_free(&(it->pos));
}

void Array_v__ast__Attr_free(Array_v__ast__Attr* it) {
	for (int i = 0; i < it->len; i++) {
		v__ast__Attr_free(&(((v__ast__Attr*)it->data)[i]));
	}
	array_free(it);
}

void v__ast__Fn_free(v__ast__Fn* it) {
	string_free(&(it->mod));
	string_free(&(it->file));
	v__token__Position_free(&(it->pos));
	v__token__Position_free(&(it->return_type_pos));
	string_free(&(it->name));
	Array_v__ast__Param_free(&(it->params));
	Array_string_free(&(it->generic_names));
	Array_v__ast__Attr_free(&(it->attrs));
}

void Array_v__ast__Fn_free(Array_v__ast__Fn* it) {
	for (int i = 0; i < it->len; i++) {
		v__ast__Fn_free(&(((v__ast__Fn*)it->data)[i]));
	}
	array_free(it);
}

void v__ast__TypeSymbol_free(v__ast__TypeSymbol* it) {
	string_free(&(it->name));
	string_free(&(it->cname));
	Array_v__ast__Fn_free(&(it->methods));
	string_free(&(it->mod));
}

static string indent_v__ast__CallExpr_str(v__ast__CallExpr it, int indent_count) {
	string indents = string_repeat(_SLIT("    "), indent_count);
	string _t1 = indent_v__token__Position_str(it.pos, indent_count + 1);
	string _t2 = indent_v__token__Position_str(it.name_pos, indent_count + 1);
	string _t3 = indent_Array_v__ast__CallArg_str(it.args, indent_count + 1);
	string _t4 = indent_Array_v__ast__Type_str(it.expected_arg_types, indent_count + 1);
	string _t5 = v__ast__Language_str(it.language);
	string _t6 = indent_v__ast__OrExpr_str(it.or_block, indent_count + 1);
	string _t7 = v__ast__Expr_str(it.left);
	string _t8 = v__ast__Type_str(it.left_type);
	string _t9 = v__ast__Type_str(it.receiver_type);
	string _t10 = v__ast__Type_str(it.return_type);
	string _t11 = indent_Array_v__ast__Type_str(it.concrete_types, indent_count + 1);
	string _t12 = indent_v__token__Position_str(it.concrete_list_pos, indent_count + 1);
	string _t13 = isnil(it.scope) ? _SLIT("nil") : (indent_count > 25) ? _SLIT("<probably circular>") : v__ast__Scope_str(*it.scope);
	string _t14 = indent_Array_v__ast__Type_str(it.from_embed_types, indent_count + 1);
	string _t15 = indent_Array_v__ast__Comment_str(it.comments, indent_count + 1);
	string res = str_intp( 99, _MOV((StrIntpData[]){
		{_SLIT("v.ast.CallExpr{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_SLIT("    pos: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t1}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    name_pos: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t2}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    mod: "), 0, {.d_c=0}}, {_SLIT("'"), 16, {.d_s=it.mod}}, {_SLIT("'"), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    name: "), 0, {.d_c=0}}, {_SLIT("'"), 16, {.d_s=it.name}}, {_SLIT("'"), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    is_method: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.is_method ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    is_field: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.is_field ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    is_keep_alive: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.is_keep_alive ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    is_noreturn: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.is_noreturn ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    is_ctor_new: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.is_ctor_new ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    args: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t3}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    expected_arg_types: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t4}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    language: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t5}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    or_block: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t6}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    left: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t7}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    left_type: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t8}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    receiver_type: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t9}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    return_type: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t10}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    should_be_skipped: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.should_be_skipped ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    concrete_types: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t11}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    concrete_list_pos: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t12}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    free_receiver: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.free_receiver ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    scope: &"), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t13}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    from_embed_types: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t14}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    comments: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t15}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("}"), 0, {.d_c=0}},
	}));
	string_free(&_t15);
	string_free(&_t14);
	string_free(&_t13);
	string_free(&_t12);
	string_free(&_t11);
	string_free(&_t10);
	string_free(&_t9);
	string_free(&_t8);
	string_free(&_t7);
	string_free(&_t6);
	string_free(&_t5);
	string_free(&_t4);
	string_free(&_t3);
	string_free(&_t2);
	string_free(&_t1);
	string_free(&indents);
	return res;
}

static string indent_v__ast__TypeInfo_str(v__ast__TypeInfo x, int indent_count) {
	switch(x._typ) {
		case 458: return str_intp(2, _MOV((StrIntpData[]){
				{_SLIT("v.ast.TypeInfo("), 0xfe10, {.d_s = indent_v__ast__Aggregate_str(*(v__ast__Aggregate*)x._v__ast__Aggregate, indent_count)}},
				{_SLIT(")"), 0, {.d_c = 0 }}
			}));		case 460: return str_intp(2, _MOV((StrIntpData[]){
				{_SLIT("v.ast.TypeInfo("), 0xfe10, {.d_s = indent_v__ast__Alias_str(*(v__ast__Alias*)x._v__ast__Alias, indent_count)}},
				{_SLIT(")"), 0, {.d_c = 0 }}
			}));		case 441: return str_intp(2, _MOV((StrIntpData[]){
				{_SLIT("v.ast.TypeInfo("), 0xfe10, {.d_s = indent_v__ast__Array_str(*(v__ast__Array*)x._v__ast__Array, indent_count)}},
				{_SLIT(")"), 0, {.d_c = 0 }}
			}));		case 468: return str_intp(2, _MOV((StrIntpData[]){
				{_SLIT("v.ast.TypeInfo("), 0xfe10, {.d_s = indent_v__ast__ArrayFixed_str(*(v__ast__ArrayFixed*)x._v__ast__ArrayFixed, indent_count)}},
				{_SLIT(")"), 0, {.d_c = 0 }}
			}));		case 469: return str_intp(2, _MOV((StrIntpData[]){
				{_SLIT("v.ast.TypeInfo("), 0xfe10, {.d_s = indent_v__ast__Chan_str(*(v__ast__Chan*)x._v__ast__Chan, indent_count)}},
				{_SLIT(")"), 0, {.d_c = 0 }}
			}));		case 474: return str_intp(2, _MOV((StrIntpData[]){
				{_SLIT("v.ast.TypeInfo("), 0xfe10, {.d_s = indent_v__ast__Enum_str(*(v__ast__Enum*)x._v__ast__Enum, indent_count)}},
				{_SLIT(")"), 0, {.d_c = 0 }}
			}));		case 472: return str_intp(2, _MOV((StrIntpData[]){
				{_SLIT("v.ast.TypeInfo("), 0xfe10, {.d_s = indent_v__ast__FnType_str(*(v__ast__FnType*)x._v__ast__FnType, indent_count)}},
				{_SLIT(")"), 0, {.d_c = 0 }}
			}));		case 473: return str_intp(2, _MOV((StrIntpData[]){
				{_SLIT("v.ast.TypeInfo("), 0xfe10, {.d_s = indent_v__ast__GenericInst_str(*(v__ast__GenericInst*)x._v__ast__GenericInst, indent_count)}},
				{_SLIT(")"), 0, {.d_c = 0 }}
			}));		case 463: return str_intp(2, _MOV((StrIntpData[]){
				{_SLIT("v.ast.TypeInfo("), 0xfe10, {.d_s = indent_v__ast__Interface_str(*(v__ast__Interface*)x._v__ast__Interface, indent_count)}},
				{_SLIT(")"), 0, {.d_c = 0 }}
			}));		case 442: return str_intp(2, _MOV((StrIntpData[]){
				{_SLIT("v.ast.TypeInfo("), 0xfe10, {.d_s = indent_v__ast__Map_str(*(v__ast__Map*)x._v__ast__Map, indent_count)}},
				{_SLIT(")"), 0, {.d_c = 0 }}
			}));		case 471: return str_intp(2, _MOV((StrIntpData[]){
				{_SLIT("v.ast.TypeInfo("), 0xfe10, {.d_s = indent_v__ast__MultiReturn_str(*(v__ast__MultiReturn*)x._v__ast__MultiReturn, indent_count)}},
				{_SLIT(")"), 0, {.d_c = 0 }}
			}));		case 446: return str_intp(2, _MOV((StrIntpData[]){
				{_SLIT("v.ast.TypeInfo("), 0xfe10, {.d_s = indent_v__ast__Struct_str(*(v__ast__Struct*)x._v__ast__Struct, indent_count)}},
				{_SLIT(")"), 0, {.d_c = 0 }}
			}));		case 464: return str_intp(2, _MOV((StrIntpData[]){
				{_SLIT("v.ast.TypeInfo("), 0xfe10, {.d_s = indent_v__ast__SumType_str(*(v__ast__SumType*)x._v__ast__SumType, indent_count)}},
				{_SLIT(")"), 0, {.d_c = 0 }}
			}));		case 470: return str_intp(2, _MOV((StrIntpData[]){
				{_SLIT("v.ast.TypeInfo("), 0xfe10, {.d_s = indent_v__ast__Thread_str(*(v__ast__Thread*)x._v__ast__Thread, indent_count)}},
				{_SLIT(")"), 0, {.d_c = 0 }}
			}));		default: return _SLIT("unknown sum type value");
	}
}

static string indent_v__ast__Fn_str(v__ast__Fn it, int indent_count) {
	string indents = string_repeat(_SLIT("    "), indent_count);
	string _t16 = v__ast__Language_str(it.language);
	string _t17 = v__ast__Language_str(it.file_mode);
	string _t18 = indent_v__token__Position_str(it.pos, indent_count + 1);
	string _t19 = indent_v__token__Position_str(it.return_type_pos, indent_count + 1);
	string _t20 = v__ast__Type_str(it.return_type);
	string _t21 = v__ast__Type_str(it.receiver_type);
	string _t22 = indent_Array_v__ast__Param_str(it.params, indent_count + 1);
	string _t23 = Array_string_str(it.generic_names);
	string _t24 = indent_Array_v__ast__Attr_str(it.attrs, indent_count + 1);
	string res = str_intp( 115, _MOV((StrIntpData[]){
		{_SLIT("v.ast.Fn{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_SLIT("    is_variadic: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.is_variadic ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    language: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t16}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    is_pub: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.is_pub ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    is_ctor_new: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.is_ctor_new ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    is_deprecated: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.is_deprecated ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    is_noreturn: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.is_noreturn ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    is_unsafe: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.is_unsafe ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    is_placeholder: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.is_placeholder ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    is_main: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.is_main ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    is_test: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.is_test ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    is_keep_alive: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.is_keep_alive ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    is_method: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.is_method ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    no_body: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.no_body ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    mod: "), 0, {.d_c=0}}, {_SLIT("'"), 16, {.d_s=it.mod}}, {_SLIT("'"), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    file: "), 0, {.d_c=0}}, {_SLIT("'"), 16, {.d_s=it.file}}, {_SLIT("'"), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    file_mode: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t17}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    pos: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t18}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    return_type_pos: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t19}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    return_type: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t20}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    receiver_type: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t21}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    name: "), 0, {.d_c=0}}, {_SLIT("'"), 16, {.d_s=it.name}}, {_SLIT("'"), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    params: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t22}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    source_fn: "), 0, {.d_c=0}}, {_SLIT(""), 17, {.d_p=(voidptr) it.source_fn}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    usages: "), 0, {.d_c=0}}, {_SLIT(""), 7, {.d_i32=it.usages}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    generic_names: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t23}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    attrs: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t24}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    is_conditional: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.is_conditional ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    ctdefine_idx: "), 0, {.d_c=0}}, {_SLIT(""), 7, {.d_i32=it.ctdefine_idx}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("}"), 0, {.d_c=0}},
	}));
	string_free(&_t24);
	string_free(&_t23);
	string_free(&_t22);
	string_free(&_t21);
	string_free(&_t20);
	string_free(&_t19);
	string_free(&_t18);
	string_free(&_t17);
	string_free(&_t16);
	string_free(&indents);
	return res;
}

static string indent_v__token__Position_str(v__token__Position it, int indent_count) {
	string indents = string_repeat(_SLIT("    "), indent_count);
	string res = str_intp( 23, _MOV((StrIntpData[]){
		{_SLIT("v.token.Position{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_SLIT("    len: "), 0, {.d_c=0}}, {_SLIT(""), 7, {.d_i32=it.len}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    line_nr: "), 0, {.d_c=0}}, {_SLIT(""), 7, {.d_i32=it.line_nr}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    pos: "), 0, {.d_c=0}}, {_SLIT(""), 7, {.d_i32=it.pos}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    col: "), 0, {.d_c=0}}, {_SLIT(""), 7, {.d_i32=it.col}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    last_line: "), 0, {.d_c=0}}, {_SLIT(""), 7, {.d_i32=it.last_line}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("}"), 0, {.d_c=0}},
	}));
	string_free(&indents);
	return res;
}

static string indent_v__ast__OrExpr_str(v__ast__OrExpr it, int indent_count) {
	string indents = string_repeat(_SLIT("    "), indent_count);
	string _t25 = indent_Array_v__ast__Stmt_str(it.stmts, indent_count + 1);
	string _t26 = v__ast__OrKind_str(it.kind);
	string _t27 = indent_v__token__Position_str(it.pos, indent_count + 1);
	string res = str_intp( 15, _MOV((StrIntpData[]){
		{_SLIT("v.ast.OrExpr{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_SLIT("    stmts: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t25}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    kind: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t26}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    pos: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t27}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("}"), 0, {.d_c=0}},
	}));
	string_free(&_t27);
	string_free(&_t26);
	string_free(&_t25);
	string_free(&indents);
	return res;
}

static string indent_v__ast__Aggregate_str(v__ast__Aggregate it, int indent_count) {
	string indents = string_repeat(_SLIT("    "), indent_count);
	string _t28 = indent_Array_v__ast__StructField_str(it.fields, indent_count + 1);
	string _t29 = indent_Array_v__ast__Type_str(it.types, indent_count + 1);
	string res = str_intp( 11, _MOV((StrIntpData[]){
		{_SLIT("v.ast.Aggregate{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_SLIT("    fields: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t28}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    types: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t29}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("}"), 0, {.d_c=0}},
	}));
	string_free(&_t29);
	string_free(&_t28);
	string_free(&indents);
	return res;
}

static string indent_v__ast__Alias_str(v__ast__Alias it, int indent_count) {
	string indents = string_repeat(_SLIT("    "), indent_count);
	string _t30 = v__ast__Type_str(it.parent_type);
	string _t31 = v__ast__Language_str(it.language);
	string res = str_intp( 15, _MOV((StrIntpData[]){
		{_SLIT("v.ast.Alias{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_SLIT("    parent_type: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t30}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    language: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t31}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    is_import: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.is_import ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("}"), 0, {.d_c=0}},
	}));
	string_free(&_t31);
	string_free(&_t30);
	string_free(&indents);
	return res;
}

static string indent_v__ast__Array_str(v__ast__Array it, int indent_count) {
	string indents = string_repeat(_SLIT("    "), indent_count);
	string _t32 = v__ast__Type_str(it.elem_type);
	string res = str_intp( 11, _MOV((StrIntpData[]){
		{_SLIT("v.ast.Array{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_SLIT("    nr_dims: "), 0, {.d_c=0}}, {_SLIT(""), 7, {.d_i32=it.nr_dims}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    elem_type: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t32}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("}"), 0, {.d_c=0}},
	}));
	string_free(&_t32);
	string_free(&indents);
	return res;
}

static string indent_v__ast__ArrayFixed_str(v__ast__ArrayFixed it, int indent_count) {
	string indents = string_repeat(_SLIT("    "), indent_count);
	string _t33 = v__ast__Expr_str(it.size_expr);
	string _t34 = v__ast__Type_str(it.elem_type);
	string res = str_intp( 15, _MOV((StrIntpData[]){
		{_SLIT("v.ast.ArrayFixed{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_SLIT("    size: "), 0, {.d_c=0}}, {_SLIT(""), 7, {.d_i32=it.size}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    size_expr: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t33}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    elem_type: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t34}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("}"), 0, {.d_c=0}},
	}));
	string_free(&_t34);
	string_free(&_t33);
	string_free(&indents);
	return res;
}

static string indent_v__ast__Chan_str(v__ast__Chan it, int indent_count) {
	string indents = string_repeat(_SLIT("    "), indent_count);
	string _t35 = v__ast__Type_str(it.elem_type);
	string res = str_intp( 11, _MOV((StrIntpData[]){
		{_SLIT("v.ast.Chan{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_SLIT("    elem_type: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t35}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    is_mut: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.is_mut ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("}"), 0, {.d_c=0}},
	}));
	string_free(&_t35);
	string_free(&indents);
	return res;
}

static string indent_v__ast__Enum_str(v__ast__Enum it, int indent_count) {
	string indents = string_repeat(_SLIT("    "), indent_count);
	string _t36 = Array_string_str(it.vals);
	string res = str_intp( 15, _MOV((StrIntpData[]){
		{_SLIT("v.ast.Enum{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_SLIT("    vals: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t36}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    is_flag: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.is_flag ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    is_multi_allowed: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.is_multi_allowed ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("}"), 0, {.d_c=0}},
	}));
	string_free(&_t36);
	string_free(&indents);
	return res;
}

static string indent_v__ast__FnType_str(v__ast__FnType it, int indent_count) {
	string indents = string_repeat(_SLIT("    "), indent_count);
	string _t37 = indent_v__ast__Fn_str(it.func, indent_count + 1);
	string res = str_intp( 15, _MOV((StrIntpData[]){
		{_SLIT("v.ast.FnType{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_SLIT("    is_anon: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.is_anon ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    has_decl: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.has_decl ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    func: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t37}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("}"), 0, {.d_c=0}},
	}));
	string_free(&_t37);
	string_free(&indents);
	return res;
}

static string indent_v__ast__GenericInst_str(v__ast__GenericInst it, int indent_count) {
	string indents = string_repeat(_SLIT("    "), indent_count);
	string _t38 = indent_Array_v__ast__Type_str(it.concrete_types, indent_count + 1);
	string res = str_intp( 11, _MOV((StrIntpData[]){
		{_SLIT("v.ast.GenericInst{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_SLIT("    parent_idx: "), 0, {.d_c=0}}, {_SLIT(""), 7, {.d_i32=it.parent_idx}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    concrete_types: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t38}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("}"), 0, {.d_c=0}},
	}));
	string_free(&_t38);
	string_free(&indents);
	return res;
}

static string indent_v__ast__Interface_str(v__ast__Interface it, int indent_count) {
	string indents = string_repeat(_SLIT("    "), indent_count);
	string _t39 = indent_Array_v__ast__Type_str(it.types, indent_count + 1);
	string _t40 = indent_Array_v__ast__StructField_str(it.fields, indent_count + 1);
	string _t41 = indent_Array_v__ast__Fn_str(it.methods, indent_count + 1);
	string _t42 = indent_Array_v__ast__Type_str(it.ifaces, indent_count + 1);
	string _t43 = indent_Map_int_Array_v__ast__Type_str(it.conversions, indent_count + 1);
	string _t44 = indent_Array_v__ast__Type_str(it.generic_types, indent_count + 1);
	string _t45 = indent_Array_v__ast__Type_str(it.concrete_types, indent_count + 1);
	string _t46 = v__ast__Type_str(it.parent_type);
	string res = str_intp( 39, _MOV((StrIntpData[]){
		{_SLIT("v.ast.Interface{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_SLIT("    types: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t39}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    fields: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t40}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    methods: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t41}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    ifaces: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t42}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    conversions: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t43}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    is_generic: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.is_generic ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    generic_types: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t44}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    concrete_types: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t45}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    parent_type: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t46}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("}"), 0, {.d_c=0}},
	}));
	string_free(&_t46);
	string_free(&_t45);
	string_free(&_t44);
	string_free(&_t43);
	string_free(&_t42);
	string_free(&_t41);
	string_free(&_t40);
	string_free(&_t39);
	string_free(&indents);
	return res;
}

static string indent_v__ast__Map_str(v__ast__Map it, int indent_count) {
	string indents = string_repeat(_SLIT("    "), indent_count);
	string _t47 = v__ast__Type_str(it.key_type);
	string _t48 = v__ast__Type_str(it.value_type);
	string res = str_intp( 11, _MOV((StrIntpData[]){
		{_SLIT("v.ast.Map{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_SLIT("    key_type: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t47}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    value_type: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t48}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("}"), 0, {.d_c=0}},
	}));
	string_free(&_t48);
	string_free(&_t47);
	string_free(&indents);
	return res;
}

static string indent_v__ast__MultiReturn_str(v__ast__MultiReturn it, int indent_count) {
	string indents = string_repeat(_SLIT("    "), indent_count);
	string _t49 = indent_Array_v__ast__Type_str(it.types, indent_count + 1);
	string res = str_intp( 7, _MOV((StrIntpData[]){
		{_SLIT("v.ast.MultiReturn{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_SLIT("    types: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t49}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("}"), 0, {.d_c=0}},
	}));
	string_free(&_t49);
	string_free(&indents);
	return res;
}

static string indent_v__ast__Struct_str(v__ast__Struct it, int indent_count) {
	string indents = string_repeat(_SLIT("    "), indent_count);
	string _t50 = indent_Array_v__ast__Attr_str(it.attrs, indent_count + 1);
	string _t51 = indent_Array_v__ast__Type_str(it.embeds, indent_count + 1);
	string _t52 = indent_Array_v__ast__StructField_str(it.fields, indent_count + 1);
	string _t53 = indent_Array_v__ast__Type_str(it.generic_types, indent_count + 1);
	string _t54 = indent_Array_v__ast__Type_str(it.concrete_types, indent_count + 1);
	string _t55 = v__ast__Type_str(it.parent_type);
	string res = str_intp( 43, _MOV((StrIntpData[]){
		{_SLIT("v.ast.Struct{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_SLIT("    attrs: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t50}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    embeds: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t51}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    fields: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t52}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    is_typedef: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.is_typedef ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    is_union: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.is_union ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    is_heap: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.is_heap ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    is_generic: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.is_generic ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    generic_types: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t53}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    concrete_types: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t54}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    parent_type: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t55}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("}"), 0, {.d_c=0}},
	}));
	string_free(&_t55);
	string_free(&_t54);
	string_free(&_t53);
	string_free(&_t52);
	string_free(&_t51);
	string_free(&_t50);
	string_free(&indents);
	return res;
}

static string indent_v__ast__SumType_str(v__ast__SumType it, int indent_count) {
	string indents = string_repeat(_SLIT("    "), indent_count);
	string _t56 = indent_Array_v__ast__Type_str(it.variants, indent_count + 1);
	string _t57 = indent_Array_v__ast__StructField_str(it.fields, indent_count + 1);
	string _t58 = indent_Array_v__ast__Type_str(it.generic_types, indent_count + 1);
	string _t59 = indent_Array_v__ast__Type_str(it.concrete_types, indent_count + 1);
	string _t60 = v__ast__Type_str(it.parent_type);
	string res = str_intp( 35, _MOV((StrIntpData[]){
		{_SLIT("v.ast.SumType{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_SLIT("    variants: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t56}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    fields: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t57}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    found_fields: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.found_fields ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    is_anon: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.is_anon ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    is_generic: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.is_generic ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    generic_types: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t58}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    concrete_types: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t59}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    parent_type: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t60}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("}"), 0, {.d_c=0}},
	}));
	string_free(&_t60);
	string_free(&_t59);
	string_free(&_t58);
	string_free(&_t57);
	string_free(&_t56);
	string_free(&indents);
	return res;
}

static string indent_v__ast__Thread_str(v__ast__Thread it, int indent_count) {
	string indents = string_repeat(_SLIT("    "), indent_count);
	string _t61 = v__ast__Type_str(it.return_type);
	string res = str_intp( 7, _MOV((StrIntpData[]){
		{_SLIT("v.ast.Thread{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_SLIT("    return_type: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t61}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("}"), 0, {.d_c=0}},
	}));
	string_free(&_t61);
	string_free(&indents);
	return res;
}

static string indent_v__ast__Comment_str(v__ast__Comment it, int indent_count) {
	string indents = string_repeat(_SLIT("    "), indent_count);
	string _t62 = indent_v__token__Position_str(it.pos, indent_count + 1);
	string res = str_intp( 19, _MOV((StrIntpData[]){
		{_SLIT("v.ast.Comment{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_SLIT("    text: "), 0, {.d_c=0}}, {_SLIT("'"), 16, {.d_s=it.text}}, {_SLIT("'"), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    is_multi: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.is_multi ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    is_inline: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.is_inline ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    pos: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t62}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("}"), 0, {.d_c=0}},
	}));
	string_free(&_t62);
	string_free(&indents);
	return res;
}

static string indent_v__ast__Param_str(v__ast__Param it, int indent_count) {
	string indents = string_repeat(_SLIT("    "), indent_count);
	string _t63 = indent_v__token__Position_str(it.pos, indent_count + 1);
	string _t64 = indent_v__token__Position_str(it.type_pos, indent_count + 1);
	string _t65 = v__ast__Type_str(it.typ);
	string res = str_intp( 31, _MOV((StrIntpData[]){
		{_SLIT("v.ast.Param{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_SLIT("    pos: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t63}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    name: "), 0, {.d_c=0}}, {_SLIT("'"), 16, {.d_s=it.name}}, {_SLIT("'"), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    is_mut: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.is_mut ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    is_auto_rec: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.is_auto_rec ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    type_pos: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t64}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    is_hidden: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.is_hidden ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    typ: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t65}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("}"), 0, {.d_c=0}},
	}));
	string_free(&_t65);
	string_free(&_t64);
	string_free(&_t63);
	string_free(&indents);
	return res;
}

static string indent_v__ast__StructField_str(v__ast__StructField it, int indent_count) {
	string indents = string_repeat(_SLIT("    "), indent_count);
	string _t66 = indent_v__token__Position_str(it.pos, indent_count + 1);
	string _t67 = indent_v__token__Position_str(it.type_pos, indent_count + 1);
	string _t68 = indent_Array_v__ast__Comment_str(it.comments, indent_count + 1);
	string _t69 = indent_Array_v__ast__Attr_str(it.attrs, indent_count + 1);
	string _t70 = v__ast__Expr_str(it.default_expr);
	string _t71 = v__ast__Type_str(it.default_expr_typ);
	string _t72 = v__ast__Type_str(it.typ);
	string res = str_intp( 59, _MOV((StrIntpData[]){
		{_SLIT("v.ast.StructField{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_SLIT("    pos: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t66}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    type_pos: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t67}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    comments: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t68}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    has_default_expr: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.has_default_expr ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    attrs: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t69}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    is_pub: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.is_pub ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    default_val: "), 0, {.d_c=0}}, {_SLIT("'"), 16, {.d_s=it.default_val}}, {_SLIT("'"), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    is_mut: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.is_mut ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    is_global: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.is_global ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    is_volatile: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.is_volatile ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    default_expr: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t70}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    default_expr_typ: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t71}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    name: "), 0, {.d_c=0}}, {_SLIT("'"), 16, {.d_s=it.name}}, {_SLIT("'"), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    typ: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t72}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("}"), 0, {.d_c=0}},
	}));
	string_free(&_t72);
	string_free(&_t71);
	string_free(&_t70);
	string_free(&_t69);
	string_free(&_t68);
	string_free(&_t67);
	string_free(&_t66);
	string_free(&indents);
	return res;
}

static inline v__ast__Expr v__ast__EmptyExpr_to_sumtype_v__ast__Expr(v__ast__EmptyExpr* x) {
	v__ast__EmptyExpr* ptr = memdup(x, sizeof(v__ast__EmptyExpr));
	return (v__ast__Expr){ ._v__ast__EmptyExpr = ptr, ._typ = 295};
}

static inline v__ast__Stmt v__ast__EmptyStmt_to_sumtype_v__ast__Stmt(v__ast__EmptyStmt* x) {
	v__ast__EmptyStmt* ptr = memdup(x, sizeof(v__ast__EmptyStmt));
	return (v__ast__Stmt){ ._v__ast__EmptyStmt = ptr, ._typ = 337, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__EmptyStmt, pos))};
}

static inline v__ast__Node v__ast__EmptyNode_to_sumtype_v__ast__Node(v__ast__EmptyNode* x) {
	v__ast__EmptyNode* ptr = memdup(x, sizeof(v__ast__EmptyNode));
	return (v__ast__Node){ ._v__ast__EmptyNode = ptr, ._typ = 360};
}

static inline v__ast__Node v__ast__Expr_to_sumtype_v__ast__Node(v__ast__Expr* x) {
	v__ast__Expr* ptr = memdup(x, sizeof(v__ast__Expr));
	return (v__ast__Node){ ._v__ast__Expr = ptr, ._typ = 328};
}

static inline v__ast__Node v__ast__Stmt_to_sumtype_v__ast__Node(v__ast__Stmt* x) {
	v__ast__Stmt* ptr = memdup(x, sizeof(v__ast__Stmt));
	return (v__ast__Node){ ._v__ast__Stmt = ptr, ._typ = 353};
}

static inline v__ast__Node v__ast__StructInitField_to_sumtype_v__ast__Node(v__ast__StructInitField* x) {
	v__ast__StructInitField* ptr = memdup(x, sizeof(v__ast__StructInitField));
	return (v__ast__Node){ ._v__ast__StructInitField = ptr, ._typ = 367};
}

static inline v__ast__Stmt v__ast__FnDecl_to_sumtype_v__ast__Stmt(v__ast__FnDecl* x) {
	v__ast__FnDecl* ptr = memdup(x, sizeof(v__ast__FnDecl));
	return (v__ast__Stmt){ ._v__ast__FnDecl = ptr, ._typ = 216, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__FnDecl, pos))};
}

static inline v__ast__Node v__ast__CallArg_to_sumtype_v__ast__Node(v__ast__CallArg* x) {
	v__ast__CallArg* ptr = memdup(x, sizeof(v__ast__CallArg));
	return (v__ast__Node){ ._v__ast__CallArg = ptr, ._typ = 359};
}

static inline v__ast__Expr v__ast__OrExpr_to_sumtype_v__ast__Expr(v__ast__OrExpr* x) {
	v__ast__OrExpr* ptr = memdup(x, sizeof(v__ast__OrExpr));
	return (v__ast__Expr){ ._v__ast__OrExpr = ptr, ._typ = 313};
}

static inline v__ast__Node v__ast__IfBranch_to_sumtype_v__ast__Node(v__ast__IfBranch* x) {
	v__ast__IfBranch* ptr = memdup(x, sizeof(v__ast__IfBranch));
	return (v__ast__Node){ ._v__ast__IfBranch = ptr, ._typ = 362};
}

static inline v__ast__Node v__ast__MatchBranch_to_sumtype_v__ast__Node(v__ast__MatchBranch* x) {
	v__ast__MatchBranch* ptr = memdup(x, sizeof(v__ast__MatchBranch));
	return (v__ast__Node){ ._v__ast__MatchBranch = ptr, ._typ = 363};
}

static inline v__ast__Node v__ast__SelectBranch_to_sumtype_v__ast__Node(v__ast__SelectBranch* x) {
	v__ast__SelectBranch* ptr = memdup(x, sizeof(v__ast__SelectBranch));
	return (v__ast__Node){ ._v__ast__SelectBranch = ptr, ._typ = 365};
}

static inline v__ast__Node v__ast__StructField_to_sumtype_v__ast__Node(v__ast__StructField* x) {
	v__ast__StructField* ptr = memdup(x, sizeof(v__ast__StructField));
	return (v__ast__Node){ ._v__ast__StructField = ptr, ._typ = 366};
}

static inline v__ast__Node v__ast__GlobalField_to_sumtype_v__ast__Node(v__ast__GlobalField* x) {
	v__ast__GlobalField* ptr = memdup(x, sizeof(v__ast__GlobalField));
	return (v__ast__Node){ ._v__ast__GlobalField = ptr, ._typ = 356};
}

static inline v__ast__Node v__ast__ConstField_to_sumtype_v__ast__Node(v__ast__ConstField* x) {
	v__ast__ConstField* ptr = memdup(x, sizeof(v__ast__ConstField));
	return (v__ast__Node){ ._v__ast__ConstField = ptr, ._typ = 355};
}

static inline v__ast__Node v__ast__EnumField_to_sumtype_v__ast__Node(v__ast__EnumField* x) {
	v__ast__EnumField* ptr = memdup(x, sizeof(v__ast__EnumField));
	return (v__ast__Node){ ._v__ast__EnumField = ptr, ._typ = 361};
}

static inline v__ast__Node v__ast__Param_to_sumtype_v__ast__Node(v__ast__Param* x) {
	v__ast__Param* ptr = memdup(x, sizeof(v__ast__Param));
	return (v__ast__Node){ ._v__ast__Param = ptr, ._typ = 364};
}

static inline v__ast__Expr v__ast__TypeNode_to_sumtype_v__ast__Expr(v__ast__TypeNode* x) {
	v__ast__TypeNode* ptr = memdup(x, sizeof(v__ast__TypeNode));
	return (v__ast__Expr){ ._v__ast__TypeNode = ptr, ._typ = 325};
}

static inline v__ast__ScopeObject v__ast__AsmRegister_to_sumtype_v__ast__ScopeObject(v__ast__AsmRegister* x) {
	v__ast__AsmRegister* ptr = memdup(x, sizeof(v__ast__AsmRegister));
	return (v__ast__ScopeObject){ ._v__ast__AsmRegister = ptr, ._typ = 354, .name = (string*)((char*)ptr + __offsetof_ptr(ptr, v__ast__AsmRegister, name)), .typ = (v__ast__Type*)((char*)ptr + __offsetof_ptr(ptr, v__ast__AsmRegister, typ))};
}

static inline v__ast__ComptTimeConstValue v__ast__EmptyExpr_to_sumtype_v__ast__ComptTimeConstValue(v__ast__EmptyExpr* x) {
	v__ast__EmptyExpr* ptr = memdup(x, sizeof(v__ast__EmptyExpr));
	return (v__ast__ComptTimeConstValue){ ._v__ast__EmptyExpr = ptr, ._typ = 295};
}

static inline v__ast__Expr v__ast__ArrayInit_to_sumtype_v__ast__Expr(v__ast__ArrayInit* x) {
	v__ast__ArrayInit* ptr = memdup(x, sizeof(v__ast__ArrayInit));
	return (v__ast__Expr){ ._v__ast__ArrayInit = ptr, ._typ = 280};
}

static inline v__ast__Expr v__ast__StringLiteral_to_sumtype_v__ast__Expr(v__ast__StringLiteral* x) {
	v__ast__StringLiteral* ptr = memdup(x, sizeof(v__ast__StringLiteral));
	return (v__ast__Expr){ ._v__ast__StringLiteral = ptr, ._typ = 323};
}

static inline v__ast__Expr v__ast__MapInit_to_sumtype_v__ast__Expr(v__ast__MapInit* x) {
	v__ast__MapInit* ptr = memdup(x, sizeof(v__ast__MapInit));
	return (v__ast__Expr){ ._v__ast__MapInit = ptr, ._typ = 308};
}

static inline v__ast__Expr v__ast__StructInit_to_sumtype_v__ast__Expr(v__ast__StructInit* x) {
	v__ast__StructInit* ptr = memdup(x, sizeof(v__ast__StructInit));
	return (v__ast__Expr){ ._v__ast__StructInit = ptr, ._typ = 324};
}

static inline v__ast__TypeInfo v__ast__SumType_to_sumtype_v__ast__TypeInfo(v__ast__SumType* x) {
	v__ast__SumType* ptr = memdup(x, sizeof(v__ast__SumType));
	return (v__ast__TypeInfo){ ._v__ast__SumType = ptr, ._typ = 464};
}

static inline v__ast__TypeInfo v__ast__Chan_to_sumtype_v__ast__TypeInfo(v__ast__Chan* x) {
	v__ast__Chan* ptr = memdup(x, sizeof(v__ast__Chan));
	return (v__ast__TypeInfo){ ._v__ast__Chan = ptr, ._typ = 469};
}

static inline v__ast__TypeInfo v__ast__Map_to_sumtype_v__ast__TypeInfo(v__ast__Map* x) {
	v__ast__Map* ptr = memdup(x, sizeof(v__ast__Map));
	return (v__ast__TypeInfo){ ._v__ast__Map = ptr, ._typ = 442};
}

static inline v__ast__TypeInfo v__ast__Thread_to_sumtype_v__ast__TypeInfo(v__ast__Thread* x) {
	v__ast__Thread* ptr = memdup(x, sizeof(v__ast__Thread));
	return (v__ast__TypeInfo){ ._v__ast__Thread = ptr, ._typ = 470};
}

static inline v__ast__TypeInfo v__ast__Struct_to_sumtype_v__ast__TypeInfo(v__ast__Struct* x) {
	v__ast__Struct* ptr = memdup(x, sizeof(v__ast__Struct));
	return (v__ast__TypeInfo){ ._v__ast__Struct = ptr, ._typ = 446};
}

static inline v__ast__TypeInfo v__ast__Array_to_sumtype_v__ast__TypeInfo(v__ast__Array* x) {
	v__ast__Array* ptr = memdup(x, sizeof(v__ast__Array));
	return (v__ast__TypeInfo){ ._v__ast__Array = ptr, ._typ = 441};
}

static inline v__ast__TypeInfo v__ast__ArrayFixed_to_sumtype_v__ast__TypeInfo(v__ast__ArrayFixed* x) {
	v__ast__ArrayFixed* ptr = memdup(x, sizeof(v__ast__ArrayFixed));
	return (v__ast__TypeInfo){ ._v__ast__ArrayFixed = ptr, ._typ = 468};
}

static inline v__ast__TypeInfo v__ast__MultiReturn_to_sumtype_v__ast__TypeInfo(v__ast__MultiReturn* x) {
	v__ast__MultiReturn* ptr = memdup(x, sizeof(v__ast__MultiReturn));
	return (v__ast__TypeInfo){ ._v__ast__MultiReturn = ptr, ._typ = 471};
}

static inline v__ast__TypeInfo v__ast__FnType_to_sumtype_v__ast__TypeInfo(v__ast__FnType* x) {
	v__ast__FnType* ptr = memdup(x, sizeof(v__ast__FnType));
	return (v__ast__TypeInfo){ ._v__ast__FnType = ptr, ._typ = 472};
}

static inline v__ast__Expr v__ast__None_to_sumtype_v__ast__Expr(v__ast__None* x) {
	v__ast__None* ptr = memdup(x, sizeof(v__ast__None));
	return (v__ast__Expr){ ._v__ast__None = ptr, ._typ = 311};
}

static inline v__ast__TypeInfo v__ast__Interface_to_sumtype_v__ast__TypeInfo(v__ast__Interface* x) {
	v__ast__Interface* ptr = memdup(x, sizeof(v__ast__Interface));
	return (v__ast__TypeInfo){ ._v__ast__Interface = ptr, ._typ = 463};
}

static inline v__ast__IdentInfo v__ast__IdentVar_to_sumtype_v__ast__IdentInfo(v__ast__IdentVar* x) {
	v__ast__IdentVar* ptr = memdup(x, sizeof(v__ast__IdentVar));
	return (v__ast__IdentInfo){ ._v__ast__IdentVar = ptr, ._typ = 408};
}

static inline v__ast__Expr v__ast__InfixExpr_to_sumtype_v__ast__Expr(v__ast__InfixExpr* x) {
	v__ast__InfixExpr* ptr = memdup(x, sizeof(v__ast__InfixExpr));
	return (v__ast__Expr){ ._v__ast__InfixExpr = ptr, ._typ = 303};
}

static inline v__ast__Expr v__ast__CastExpr_to_sumtype_v__ast__Expr(v__ast__CastExpr* x) {
	v__ast__CastExpr* ptr = memdup(x, sizeof(v__ast__CastExpr));
	return (v__ast__Expr){ ._v__ast__CastExpr = ptr, ._typ = 287};
}

static inline v__ast__AsmArg v__ast__AsmRegister_to_sumtype_v__ast__AsmArg(v__ast__AsmRegister* x) {
	v__ast__AsmRegister* ptr = memdup(x, sizeof(v__ast__AsmRegister));
	return (v__ast__AsmArg){ ._v__ast__AsmRegister = ptr, ._typ = 354};
}

static inline v__ast__ScopeObject v__ast__Var_to_sumtype_v__ast__ScopeObject(v__ast__Var* x) {
	v__ast__Var* ptr = memdup(x, sizeof(v__ast__Var));
	return (v__ast__ScopeObject){ ._v__ast__Var = ptr, ._typ = 357, .name = (string*)((char*)ptr + __offsetof_ptr(ptr, v__ast__Var, name)), .typ = (v__ast__Type*)((char*)ptr + __offsetof_ptr(ptr, v__ast__Var, typ))};
}

static inline v__ast__IdentInfo v__ast__IdentFn_to_sumtype_v__ast__IdentInfo(v__ast__IdentFn* x) {
	v__ast__IdentFn* ptr = memdup(x, sizeof(v__ast__IdentFn));
	return (v__ast__IdentInfo){ ._v__ast__IdentFn = ptr, ._typ = 407};
}

static inline v__ast__Expr v__ast__IndexExpr_to_sumtype_v__ast__Expr(v__ast__IndexExpr* x) {
	v__ast__IndexExpr* ptr = memdup(x, sizeof(v__ast__IndexExpr));
	return (v__ast__Expr){ ._v__ast__IndexExpr = ptr, ._typ = 302};
}

static inline v__ast__ComptTimeConstValue int_to_sumtype_v__ast__ComptTimeConstValue(int* x) {
	int* ptr = memdup(x, sizeof(int));
	return (v__ast__ComptTimeConstValue){ ._int = ptr, ._typ = 7};
}

static inline v__ast__ComptTimeConstValue f64_to_sumtype_v__ast__ComptTimeConstValue(f64* x) {
	f64* ptr = memdup(x, sizeof(f64));
	return (v__ast__ComptTimeConstValue){ ._f64 = ptr, ._typ = 16};
}

static inline v__ast__ComptTimeConstValue u64_to_sumtype_v__ast__ComptTimeConstValue(u64* x) {
	u64* ptr = memdup(x, sizeof(u64));
	return (v__ast__ComptTimeConstValue){ ._u64 = ptr, ._typ = 13};
}

static inline v__ast__ComptTimeConstValue i64_to_sumtype_v__ast__ComptTimeConstValue(i64* x) {
	i64* ptr = memdup(x, sizeof(i64));
	return (v__ast__ComptTimeConstValue){ ._i64 = ptr, ._typ = 8};
}

static inline v__ast__ComptTimeConstValue string_to_sumtype_v__ast__ComptTimeConstValue(string* x) {
	string* ptr = memdup(x, sizeof(string));
	return (v__ast__ComptTimeConstValue){ ._string = ptr, ._typ = 20};
}

static inline v__ast__ComptTimeConstValue rune_to_sumtype_v__ast__ComptTimeConstValue(rune* x) {
	rune* ptr = memdup(x, sizeof(rune));
	return (v__ast__ComptTimeConstValue){ ._rune = ptr, ._typ = 21};
}

static inline v__ast__ComptTimeConstValue i8_to_sumtype_v__ast__ComptTimeConstValue(i8* x) {
	i8* ptr = memdup(x, sizeof(i8));
	return (v__ast__ComptTimeConstValue){ ._i8 = ptr, ._typ = 5};
}

static inline v__ast__ComptTimeConstValue i16_to_sumtype_v__ast__ComptTimeConstValue(i16* x) {
	i16* ptr = memdup(x, sizeof(i16));
	return (v__ast__ComptTimeConstValue){ ._i16 = ptr, ._typ = 6};
}

static inline v__ast__ComptTimeConstValue byte_to_sumtype_v__ast__ComptTimeConstValue(byte* x) {
	byte* ptr = memdup(x, sizeof(byte));
	return (v__ast__ComptTimeConstValue){ ._byte = ptr, ._typ = 10};
}

static inline v__ast__ComptTimeConstValue u16_to_sumtype_v__ast__ComptTimeConstValue(u16* x) {
	u16* ptr = memdup(x, sizeof(u16));
	return (v__ast__ComptTimeConstValue){ ._u16 = ptr, ._typ = 11};
}

static inline v__ast__ComptTimeConstValue u32_to_sumtype_v__ast__ComptTimeConstValue(u32* x) {
	u32* ptr = memdup(x, sizeof(u32));
	return (v__ast__ComptTimeConstValue){ ._u32 = ptr, ._typ = 12};
}

static inline v__ast__ComptTimeConstValue f32_to_sumtype_v__ast__ComptTimeConstValue(f32* x) {
	f32* ptr = memdup(x, sizeof(f32));
	return (v__ast__ComptTimeConstValue){ ._f32 = ptr, ._typ = 15};
}

static inline v__ast__Stmt v__ast__Return_to_sumtype_v__ast__Stmt(v__ast__Return* x) {
	v__ast__Return* ptr = memdup(x, sizeof(v__ast__Return));
	return (v__ast__Stmt){ ._v__ast__Return = ptr, ._typ = 350, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__Return, pos))};
}

static inline v__ast__TypeInfo v__ast__Aggregate_to_sumtype_v__ast__TypeInfo(v__ast__Aggregate* x) {
	v__ast__Aggregate* ptr = memdup(x, sizeof(v__ast__Aggregate));
	return (v__ast__TypeInfo){ ._v__ast__Aggregate = ptr, ._typ = 458};
}

static inline v__ast__Expr v__ast__Ident_to_sumtype_v__ast__Expr(v__ast__Ident* x) {
	v__ast__Ident* ptr = memdup(x, sizeof(v__ast__Ident));
	return (v__ast__Expr){ ._v__ast__Ident = ptr, ._typ = 299};
}

static inline v__ast__Stmt v__ast__ExprStmt_to_sumtype_v__ast__Stmt(v__ast__ExprStmt* x) {
	v__ast__ExprStmt* ptr = memdup(x, sizeof(v__ast__ExprStmt));
	return (v__ast__Stmt){ ._v__ast__ExprStmt = ptr, ._typ = 339, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__ExprStmt, pos))};
}

static inline v__ast__Stmt v__ast__ForStmt_to_sumtype_v__ast__Stmt(v__ast__ForStmt* x) {
	v__ast__ForStmt* ptr = memdup(x, sizeof(v__ast__ForStmt));
	return (v__ast__Stmt){ ._v__ast__ForStmt = ptr, ._typ = 342, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__ForStmt, pos))};
}

static inline v__ast__Expr v__ast__MatchExpr_to_sumtype_v__ast__Expr(v__ast__MatchExpr* x) {
	v__ast__MatchExpr* ptr = memdup(x, sizeof(v__ast__MatchExpr));
	return (v__ast__Expr){ ._v__ast__MatchExpr = ptr, ._typ = 309};
}

static inline v__ast__Expr v__ast__IfExpr_to_sumtype_v__ast__Expr(v__ast__IfExpr* x) {
	v__ast__IfExpr* ptr = memdup(x, sizeof(v__ast__IfExpr));
	return (v__ast__Expr){ ._v__ast__IfExpr = ptr, ._typ = 300};
}

static inline v__ast__Expr v__ast__BoolLiteral_to_sumtype_v__ast__Expr(v__ast__BoolLiteral* x) {
	v__ast__BoolLiteral* ptr = memdup(x, sizeof(v__ast__BoolLiteral));
	return (v__ast__Expr){ ._v__ast__BoolLiteral = ptr, ._typ = 284};
}

static inline v__ast__Expr v__ast__IntegerLiteral_to_sumtype_v__ast__Expr(v__ast__IntegerLiteral* x) {
	v__ast__IntegerLiteral* ptr = memdup(x, sizeof(v__ast__IntegerLiteral));
	return (v__ast__Expr){ ._v__ast__IntegerLiteral = ptr, ._typ = 304};
}

static inline v__ast__Expr v__ast__FloatLiteral_to_sumtype_v__ast__Expr(v__ast__FloatLiteral* x) {
	v__ast__FloatLiteral* ptr = memdup(x, sizeof(v__ast__FloatLiteral));
	return (v__ast__Expr){ ._v__ast__FloatLiteral = ptr, ._typ = 297};
}

static inline v__ast__Expr v__ast__CallExpr_to_sumtype_v__ast__Expr(v__ast__CallExpr* x) {
	v__ast__CallExpr* ptr = memdup(x, sizeof(v__ast__CallExpr));
	return (v__ast__Expr){ ._v__ast__CallExpr = ptr, ._typ = 286};
}

static inline v__ast__Expr v__ast__CTempVar_to_sumtype_v__ast__Expr(v__ast__CTempVar* x) {
	v__ast__CTempVar* ptr = memdup(x, sizeof(v__ast__CTempVar));
	return (v__ast__Expr){ ._v__ast__CTempVar = ptr, ._typ = 285};
}

static inline v__ast__Stmt v__ast__ForCStmt_to_sumtype_v__ast__Stmt(v__ast__ForCStmt* x) {
	v__ast__ForCStmt* ptr = memdup(x, sizeof(v__ast__ForCStmt));
	return (v__ast__Stmt){ ._v__ast__ForCStmt = ptr, ._typ = 340, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__ForCStmt, pos))};
}

static inline v__ast__Stmt v__ast__ForInStmt_to_sumtype_v__ast__Stmt(v__ast__ForInStmt* x) {
	v__ast__ForInStmt* ptr = memdup(x, sizeof(v__ast__ForInStmt));
	return (v__ast__Stmt){ ._v__ast__ForInStmt = ptr, ._typ = 341, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__ForInStmt, pos))};
}

static inline v__ast__Expr v__ast__SelectorExpr_to_sumtype_v__ast__Expr(v__ast__SelectorExpr* x) {
	v__ast__SelectorExpr* ptr = memdup(x, sizeof(v__ast__SelectorExpr));
	return (v__ast__Expr){ ._v__ast__SelectorExpr = ptr, ._typ = 319};
}

static inline v__ast__Stmt v__ast__NodeError_to_sumtype_v__ast__Stmt(v__ast__NodeError* x) {
	v__ast__NodeError* ptr = memdup(x, sizeof(v__ast__NodeError));
	return (v__ast__Stmt){ ._v__ast__NodeError = ptr, ._typ = 310, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__NodeError, pos))};
}

static inline v__ast__Stmt v__ast__AssignStmt_to_sumtype_v__ast__Stmt(v__ast__AssignStmt* x) {
	v__ast__AssignStmt* ptr = memdup(x, sizeof(v__ast__AssignStmt));
	return (v__ast__Stmt){ ._v__ast__AssignStmt = ptr, ._typ = 331, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__AssignStmt, pos))};
}

static inline v__ast__Expr v__ast__ComptimeCall_to_sumtype_v__ast__Expr(v__ast__ComptimeCall* x) {
	v__ast__ComptimeCall* ptr = memdup(x, sizeof(v__ast__ComptimeCall));
	return (v__ast__Expr){ ._v__ast__ComptimeCall = ptr, ._typ = 291};
}

static inline v__ast__Expr v__ast__ComptimeSelector_to_sumtype_v__ast__Expr(v__ast__ComptimeSelector* x) {
	v__ast__ComptimeSelector* ptr = memdup(x, sizeof(v__ast__ComptimeSelector));
	return (v__ast__Expr){ ._v__ast__ComptimeSelector = ptr, ._typ = 292};
}

static inline v__ast__Expr v__ast__NodeError_to_sumtype_v__ast__Expr(v__ast__NodeError* x) {
	v__ast__NodeError* ptr = memdup(x, sizeof(v__ast__NodeError));
	return (v__ast__Expr){ ._v__ast__NodeError = ptr, ._typ = 310};
}

static inline v__ast__Expr v__ast__Comment_to_sumtype_v__ast__Expr(v__ast__Comment* x) {
	v__ast__Comment* ptr = memdup(x, sizeof(v__ast__Comment));
	return (v__ast__Expr){ ._v__ast__Comment = ptr, ._typ = 290};
}

static inline v__ast__Expr v__ast__EnumVal_to_sumtype_v__ast__Expr(v__ast__EnumVal* x) {
	v__ast__EnumVal* ptr = memdup(x, sizeof(v__ast__EnumVal));
	return (v__ast__Expr){ ._v__ast__EnumVal = ptr, ._typ = 296};
}

static inline v__ast__Expr v__ast__AtExpr_to_sumtype_v__ast__Expr(v__ast__AtExpr* x) {
	v__ast__AtExpr* ptr = memdup(x, sizeof(v__ast__AtExpr));
	return (v__ast__Expr){ ._v__ast__AtExpr = ptr, ._typ = 283};
}

static inline v__ast__Expr v__ast__CharLiteral_to_sumtype_v__ast__Expr(v__ast__CharLiteral* x) {
	v__ast__CharLiteral* ptr = memdup(x, sizeof(v__ast__CharLiteral));
	return (v__ast__Expr){ ._v__ast__CharLiteral = ptr, ._typ = 289};
}

static inline v__ast__Expr v__ast__GoExpr_to_sumtype_v__ast__Expr(v__ast__GoExpr* x) {
	v__ast__GoExpr* ptr = memdup(x, sizeof(v__ast__GoExpr));
	return (v__ast__Expr){ ._v__ast__GoExpr = ptr, ._typ = 298};
}

static inline v__ast__Expr v__ast__SelectExpr_to_sumtype_v__ast__Expr(v__ast__SelectExpr* x) {
	v__ast__SelectExpr* ptr = memdup(x, sizeof(v__ast__SelectExpr));
	return (v__ast__Expr){ ._v__ast__SelectExpr = ptr, ._typ = 318};
}

static inline v__ast__Expr v__ast__ParExpr_to_sumtype_v__ast__Expr(v__ast__ParExpr* x) {
	v__ast__ParExpr* ptr = memdup(x, sizeof(v__ast__ParExpr));
	return (v__ast__Expr){ ._v__ast__ParExpr = ptr, ._typ = 314};
}

static inline v__ast__Expr v__ast__UnsafeExpr_to_sumtype_v__ast__Expr(v__ast__UnsafeExpr* x) {
	v__ast__UnsafeExpr* ptr = memdup(x, sizeof(v__ast__UnsafeExpr));
	return (v__ast__Expr){ ._v__ast__UnsafeExpr = ptr, ._typ = 327};
}

static inline v__ast__Expr v__ast__LockExpr_to_sumtype_v__ast__Expr(v__ast__LockExpr* x) {
	v__ast__LockExpr* ptr = memdup(x, sizeof(v__ast__LockExpr));
	return (v__ast__Expr){ ._v__ast__LockExpr = ptr, ._typ = 307};
}

static inline v__ast__Expr v__ast__IsRefType_to_sumtype_v__ast__Expr(v__ast__IsRefType* x) {
	v__ast__IsRefType* ptr = memdup(x, sizeof(v__ast__IsRefType));
	return (v__ast__Expr){ ._v__ast__IsRefType = ptr, ._typ = 305};
}

static inline v__ast__Expr v__ast__SizeOf_to_sumtype_v__ast__Expr(v__ast__SizeOf* x) {
	v__ast__SizeOf* ptr = memdup(x, sizeof(v__ast__SizeOf));
	return (v__ast__Expr){ ._v__ast__SizeOf = ptr, ._typ = 320};
}

static inline v__ast__Expr v__ast__TypeOf_to_sumtype_v__ast__Expr(v__ast__TypeOf* x) {
	v__ast__TypeOf* ptr = memdup(x, sizeof(v__ast__TypeOf));
	return (v__ast__Expr){ ._v__ast__TypeOf = ptr, ._typ = 326};
}

static inline v__ast__Expr v__ast__DumpExpr_to_sumtype_v__ast__Expr(v__ast__DumpExpr* x) {
	v__ast__DumpExpr* ptr = memdup(x, sizeof(v__ast__DumpExpr));
	return (v__ast__Expr){ ._v__ast__DumpExpr = ptr, ._typ = 294};
}

static inline v__ast__Expr v__ast__OffsetOf_to_sumtype_v__ast__Expr(v__ast__OffsetOf* x) {
	v__ast__OffsetOf* ptr = memdup(x, sizeof(v__ast__OffsetOf));
	return (v__ast__Expr){ ._v__ast__OffsetOf = ptr, ._typ = 312};
}

static inline v__ast__Expr v__ast__Likely_to_sumtype_v__ast__Expr(v__ast__Likely* x) {
	v__ast__Likely* ptr = memdup(x, sizeof(v__ast__Likely));
	return (v__ast__Expr){ ._v__ast__Likely = ptr, ._typ = 306};
}

static inline v__ast__Expr v__ast__AnonFn_to_sumtype_v__ast__Expr(v__ast__AnonFn* x) {
	v__ast__AnonFn* ptr = memdup(x, sizeof(v__ast__AnonFn));
	return (v__ast__Expr){ ._v__ast__AnonFn = ptr, ._typ = 278};
}

static inline v__ast__Expr v__ast__AsCast_to_sumtype_v__ast__Expr(v__ast__AsCast* x) {
	v__ast__AsCast* ptr = memdup(x, sizeof(v__ast__AsCast));
	return (v__ast__Expr){ ._v__ast__AsCast = ptr, ._typ = 281};
}

static inline v__ast__Expr v__ast__PostfixExpr_to_sumtype_v__ast__Expr(v__ast__PostfixExpr* x) {
	v__ast__PostfixExpr* ptr = memdup(x, sizeof(v__ast__PostfixExpr));
	return (v__ast__Expr){ ._v__ast__PostfixExpr = ptr, ._typ = 315};
}

static inline v__ast__Expr v__ast__PrefixExpr_to_sumtype_v__ast__Expr(v__ast__PrefixExpr* x) {
	v__ast__PrefixExpr* ptr = memdup(x, sizeof(v__ast__PrefixExpr));
	return (v__ast__Expr){ ._v__ast__PrefixExpr = ptr, ._typ = 316};
}

static inline v__ast__Expr v__ast__ArrayDecompose_to_sumtype_v__ast__Expr(v__ast__ArrayDecompose* x) {
	v__ast__ArrayDecompose* ptr = memdup(x, sizeof(v__ast__ArrayDecompose));
	return (v__ast__Expr){ ._v__ast__ArrayDecompose = ptr, ._typ = 279};
}

static inline v__ast__Expr v__ast__IfGuardExpr_to_sumtype_v__ast__Expr(v__ast__IfGuardExpr* x) {
	v__ast__IfGuardExpr* ptr = memdup(x, sizeof(v__ast__IfGuardExpr));
	return (v__ast__Expr){ ._v__ast__IfGuardExpr = ptr, ._typ = 301};
}

static inline v__ast__Expr v__ast__RangeExpr_to_sumtype_v__ast__Expr(v__ast__RangeExpr* x) {
	v__ast__RangeExpr* ptr = memdup(x, sizeof(v__ast__RangeExpr));
	return (v__ast__Expr){ ._v__ast__RangeExpr = ptr, ._typ = 317};
}

static inline v__ast__TypeInfo v__ast__GenericInst_to_sumtype_v__ast__TypeInfo(v__ast__GenericInst* x) {
	v__ast__GenericInst* ptr = memdup(x, sizeof(v__ast__GenericInst));
	return (v__ast__TypeInfo){ ._v__ast__GenericInst = ptr, ._typ = 473};
}

static inline v__ast__Stmt v__ast__Module_to_sumtype_v__ast__Stmt(v__ast__Module* x) {
	v__ast__Module* ptr = memdup(x, sizeof(v__ast__Module));
	return (v__ast__Stmt){ ._v__ast__Module = ptr, ._typ = 349, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__Module, pos))};
}

static inline v__ast__Stmt v__ast__Import_to_sumtype_v__ast__Stmt(v__ast__Import* x) {
	v__ast__Import* ptr = memdup(x, sizeof(v__ast__Import));
	return (v__ast__Stmt){ ._v__ast__Import = ptr, ._typ = 347, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__Import, pos))};
}

static inline v__ast__Stmt v__ast__ConstDecl_to_sumtype_v__ast__Stmt(v__ast__ConstDecl* x) {
	v__ast__ConstDecl* ptr = memdup(x, sizeof(v__ast__ConstDecl));
	return (v__ast__Stmt){ ._v__ast__ConstDecl = ptr, ._typ = 335, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__ConstDecl, pos))};
}

static inline v__ast__Stmt v__ast__StructDecl_to_sumtype_v__ast__Stmt(v__ast__StructDecl* x) {
	v__ast__StructDecl* ptr = memdup(x, sizeof(v__ast__StructDecl));
	return (v__ast__Stmt){ ._v__ast__StructDecl = ptr, ._typ = 352, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__StructDecl, pos))};
}

static inline v__ast__Stmt v__ast__InterfaceDecl_to_sumtype_v__ast__Stmt(v__ast__InterfaceDecl* x) {
	v__ast__InterfaceDecl* ptr = memdup(x, sizeof(v__ast__InterfaceDecl));
	return (v__ast__Stmt){ ._v__ast__InterfaceDecl = ptr, ._typ = 348, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__InterfaceDecl, pos))};
}

static inline v__ast__Stmt v__ast__EnumDecl_to_sumtype_v__ast__Stmt(v__ast__EnumDecl* x) {
	v__ast__EnumDecl* ptr = memdup(x, sizeof(v__ast__EnumDecl));
	return (v__ast__Stmt){ ._v__ast__EnumDecl = ptr, ._typ = 338, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__EnumDecl, pos))};
}

static inline v__ast__Stmt v__ast__TypeDecl_to_sumtype_v__ast__Stmt(v__ast__TypeDecl* x) {
	v__ast__TypeDecl* ptr = memdup(x, sizeof(v__ast__TypeDecl));
	return (v__ast__Stmt){ ._v__ast__TypeDecl = ptr, ._typ = 277, .pos = ptr->pos};
}

static inline v__ast__Stmt v__ast__AsmStmt_to_sumtype_v__ast__Stmt(v__ast__AsmStmt* x) {
	v__ast__AsmStmt* ptr = memdup(x, sizeof(v__ast__AsmStmt));
	return (v__ast__Stmt){ ._v__ast__AsmStmt = ptr, ._typ = 329, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__AsmStmt, pos))};
}

static inline v__ast__Stmt v__ast__GlobalDecl_to_sumtype_v__ast__Stmt(v__ast__GlobalDecl* x) {
	v__ast__GlobalDecl* ptr = memdup(x, sizeof(v__ast__GlobalDecl));
	return (v__ast__Stmt){ ._v__ast__GlobalDecl = ptr, ._typ = 343, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__GlobalDecl, pos))};
}

static inline v__ast__Stmt v__ast__HashStmt_to_sumtype_v__ast__Stmt(v__ast__HashStmt* x) {
	v__ast__HashStmt* ptr = memdup(x, sizeof(v__ast__HashStmt));
	return (v__ast__Stmt){ ._v__ast__HashStmt = ptr, ._typ = 346, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__HashStmt, pos))};
}

static inline v__ast__Stmt v__ast__Block_to_sumtype_v__ast__Stmt(v__ast__Block* x) {
	v__ast__Block* ptr = memdup(x, sizeof(v__ast__Block));
	return (v__ast__Stmt){ ._v__ast__Block = ptr, ._typ = 332, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__Block, pos))};
}

static inline v__ast__Stmt v__ast__AssertStmt_to_sumtype_v__ast__Stmt(v__ast__AssertStmt* x) {
	v__ast__AssertStmt* ptr = memdup(x, sizeof(v__ast__AssertStmt));
	return (v__ast__Stmt){ ._v__ast__AssertStmt = ptr, ._typ = 330, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__AssertStmt, pos))};
}

static inline v__ast__Stmt v__ast__SqlStmt_to_sumtype_v__ast__Stmt(v__ast__SqlStmt* x) {
	v__ast__SqlStmt* ptr = memdup(x, sizeof(v__ast__SqlStmt));
	return (v__ast__Stmt){ ._v__ast__SqlStmt = ptr, ._typ = 351, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__SqlStmt, pos))};
}

static inline v__ast__Stmt v__ast__GotoLabel_to_sumtype_v__ast__Stmt(v__ast__GotoLabel* x) {
	v__ast__GotoLabel* ptr = memdup(x, sizeof(v__ast__GotoLabel));
	return (v__ast__Stmt){ ._v__ast__GotoLabel = ptr, ._typ = 344, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__GotoLabel, pos))};
}

static inline v__ast__Stmt v__ast__ComptimeFor_to_sumtype_v__ast__Stmt(v__ast__ComptimeFor* x) {
	v__ast__ComptimeFor* ptr = memdup(x, sizeof(v__ast__ComptimeFor));
	return (v__ast__Stmt){ ._v__ast__ComptimeFor = ptr, ._typ = 334, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__ComptimeFor, pos))};
}

static inline v__ast__Stmt v__ast__BranchStmt_to_sumtype_v__ast__Stmt(v__ast__BranchStmt* x) {
	v__ast__BranchStmt* ptr = memdup(x, sizeof(v__ast__BranchStmt));
	return (v__ast__Stmt){ ._v__ast__BranchStmt = ptr, ._typ = 333, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__BranchStmt, pos))};
}

static inline v__ast__Stmt v__ast__DeferStmt_to_sumtype_v__ast__Stmt(v__ast__DeferStmt* x) {
	v__ast__DeferStmt* ptr = memdup(x, sizeof(v__ast__DeferStmt));
	return (v__ast__Stmt){ ._v__ast__DeferStmt = ptr, ._typ = 336, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__DeferStmt, pos))};
}

static inline v__ast__Stmt v__ast__GotoStmt_to_sumtype_v__ast__Stmt(v__ast__GotoStmt* x) {
	v__ast__GotoStmt* ptr = memdup(x, sizeof(v__ast__GotoStmt));
	return (v__ast__Stmt){ ._v__ast__GotoStmt = ptr, ._typ = 345, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__GotoStmt, pos))};
}

static inline v__ast__AsmArg v__ast__FloatLiteral_to_sumtype_v__ast__AsmArg(v__ast__FloatLiteral* x) {
	v__ast__FloatLiteral* ptr = memdup(x, sizeof(v__ast__FloatLiteral));
	return (v__ast__AsmArg){ ._v__ast__FloatLiteral = ptr, ._typ = 297};
}

static inline v__ast__AsmArg v__ast__AsmDisp_to_sumtype_v__ast__AsmArg(v__ast__AsmDisp* x) {
	v__ast__AsmDisp* ptr = memdup(x, sizeof(v__ast__AsmDisp));
	return (v__ast__AsmArg){ ._v__ast__AsmDisp = ptr, ._typ = 430};
}

static inline v__ast__AsmArg v__ast__IntegerLiteral_to_sumtype_v__ast__AsmArg(v__ast__IntegerLiteral* x) {
	v__ast__IntegerLiteral* ptr = memdup(x, sizeof(v__ast__IntegerLiteral));
	return (v__ast__AsmArg){ ._v__ast__IntegerLiteral = ptr, ._typ = 304};
}

static inline v__ast__AsmArg v__ast__CharLiteral_to_sumtype_v__ast__AsmArg(v__ast__CharLiteral* x) {
	v__ast__CharLiteral* ptr = memdup(x, sizeof(v__ast__CharLiteral));
	return (v__ast__AsmArg){ ._v__ast__CharLiteral = ptr, ._typ = 289};
}

static inline v__ast__AsmArg v__ast__AsmAddressing_to_sumtype_v__ast__AsmArg(v__ast__AsmAddressing* x) {
	v__ast__AsmAddressing* ptr = memdup(x, sizeof(v__ast__AsmAddressing));
	return (v__ast__AsmArg){ ._v__ast__AsmAddressing = ptr, ._typ = 428};
}

static inline v__ast__AsmArg v__ast__AsmAlias_to_sumtype_v__ast__AsmArg(v__ast__AsmAlias* x) {
	v__ast__AsmAlias* ptr = memdup(x, sizeof(v__ast__AsmAlias));
	return (v__ast__AsmArg){ ._v__ast__AsmAlias = ptr, ._typ = 429};
}

static inline v__ast__Expr v__ast__ConcatExpr_to_sumtype_v__ast__Expr(v__ast__ConcatExpr* x) {
	v__ast__ConcatExpr* ptr = memdup(x, sizeof(v__ast__ConcatExpr));
	return (v__ast__Expr){ ._v__ast__ConcatExpr = ptr, ._typ = 293};
}

static inline v__ast__Expr v__ast__ChanInit_to_sumtype_v__ast__Expr(v__ast__ChanInit* x) {
	v__ast__ChanInit* ptr = memdup(x, sizeof(v__ast__ChanInit));
	return (v__ast__Expr){ ._v__ast__ChanInit = ptr, ._typ = 288};
}

static inline v__ast__Expr v__ast__StringInterLiteral_to_sumtype_v__ast__Expr(v__ast__StringInterLiteral* x) {
	v__ast__StringInterLiteral* ptr = memdup(x, sizeof(v__ast__StringInterLiteral));
	return (v__ast__Expr){ ._v__ast__StringInterLiteral = ptr, ._typ = 322};
}

static inline v__ast__ScopeObject v__ast__ConstField_to_sumtype_v__ast__ScopeObject(v__ast__ConstField* x) {
	v__ast__ConstField* ptr = memdup(x, sizeof(v__ast__ConstField));
	return (v__ast__ScopeObject){ ._v__ast__ConstField = ptr, ._typ = 355, .name = (string*)((char*)ptr + __offsetof_ptr(ptr, v__ast__ConstField, name)), .typ = (v__ast__Type*)((char*)ptr + __offsetof_ptr(ptr, v__ast__ConstField, typ))};
}

static inline v__ast__ScopeObject v__ast__GlobalField_to_sumtype_v__ast__ScopeObject(v__ast__GlobalField* x) {
	v__ast__GlobalField* ptr = memdup(x, sizeof(v__ast__GlobalField));
	return (v__ast__ScopeObject){ ._v__ast__GlobalField = ptr, ._typ = 356, .name = (string*)((char*)ptr + __offsetof_ptr(ptr, v__ast__GlobalField, name)), .typ = (v__ast__Type*)((char*)ptr + __offsetof_ptr(ptr, v__ast__GlobalField, typ))};
}

static inline v__ast__TypeInfo v__ast__Enum_to_sumtype_v__ast__TypeInfo(v__ast__Enum* x) {
	v__ast__Enum* ptr = memdup(x, sizeof(v__ast__Enum));
	return (v__ast__TypeInfo){ ._v__ast__Enum = ptr, ._typ = 474};
}

static inline v__ast__TypeDecl v__ast__FnTypeDecl_to_sumtype_v__ast__TypeDecl(v__ast__FnTypeDecl* x) {
	v__ast__FnTypeDecl* ptr = memdup(x, sizeof(v__ast__FnTypeDecl));
	return (v__ast__TypeDecl){ ._v__ast__FnTypeDecl = ptr, ._typ = 275, .name = (string*)((char*)ptr + __offsetof_ptr(ptr, v__ast__FnTypeDecl, name)), .is_pub = (bool*)((char*)ptr + __offsetof_ptr(ptr, v__ast__FnTypeDecl, is_pub)), .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__FnTypeDecl, pos)), .comments = (Array_v__ast__Comment*)((char*)ptr + __offsetof_ptr(ptr, v__ast__FnTypeDecl, comments))};
}

static inline v__ast__TypeDecl v__ast__AliasTypeDecl_to_sumtype_v__ast__TypeDecl(v__ast__AliasTypeDecl* x) {
	v__ast__AliasTypeDecl* ptr = memdup(x, sizeof(v__ast__AliasTypeDecl));
	return (v__ast__TypeDecl){ ._v__ast__AliasTypeDecl = ptr, ._typ = 274, .name = (string*)((char*)ptr + __offsetof_ptr(ptr, v__ast__AliasTypeDecl, name)), .is_pub = (bool*)((char*)ptr + __offsetof_ptr(ptr, v__ast__AliasTypeDecl, is_pub)), .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__AliasTypeDecl, pos)), .comments = (Array_v__ast__Comment*)((char*)ptr + __offsetof_ptr(ptr, v__ast__AliasTypeDecl, comments))};
}

static inline v__ast__TypeDecl v__ast__SumTypeDecl_to_sumtype_v__ast__TypeDecl(v__ast__SumTypeDecl* x) {
	v__ast__SumTypeDecl* ptr = memdup(x, sizeof(v__ast__SumTypeDecl));
	return (v__ast__TypeDecl){ ._v__ast__SumTypeDecl = ptr, ._typ = 276, .name = (string*)((char*)ptr + __offsetof_ptr(ptr, v__ast__SumTypeDecl, name)), .is_pub = (bool*)((char*)ptr + __offsetof_ptr(ptr, v__ast__SumTypeDecl, is_pub)), .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__SumTypeDecl, pos)), .comments = (Array_v__ast__Comment*)((char*)ptr + __offsetof_ptr(ptr, v__ast__SumTypeDecl, comments))};
}

static inline v__ast__TypeInfo v__ast__Alias_to_sumtype_v__ast__TypeInfo(v__ast__Alias* x) {
	v__ast__Alias* ptr = memdup(x, sizeof(v__ast__Alias));
	return (v__ast__TypeInfo){ ._v__ast__Alias = ptr, ._typ = 460};
}

static inline v__ast__Expr v__ast__SqlExpr_to_sumtype_v__ast__Expr(v__ast__SqlExpr* x) {
	v__ast__SqlExpr* ptr = memdup(x, sizeof(v__ast__SqlExpr));
	return (v__ast__Expr){ ._v__ast__SqlExpr = ptr, ._typ = 321};
}

static inline v__ast__Node v__ast__File_to_sumtype_v__ast__Node(v__ast__File* x) {
	v__ast__File* ptr = memdup(x, sizeof(v__ast__File));
	return (v__ast__Node){ ._v__ast__File = ptr, ._typ = 207};
}

static bool Array_string_contains(Array_string a, string v) {
	for (int i = 0; i < a.len; ++i) {
		if (fast_string_eq(((string*)a.data)[i], v)) {
			return true;
		}
	}
	return false;
}

static bool Array_v__token__Kind_contains(Array_v__token__Kind a, v__token__Kind v) {
	for (int i = 0; i < a.len; ++i) {
		if (((v__token__Kind*)a.data)[i] == v) {
			return true;
		}
	}
	return false;
}

static bool Array_byte_contains(Array_byte a, byte v) {
	for (int i = 0; i < a.len; ++i) {
		if (((byte*)a.data)[i] == v) {
			return true;
		}
	}
	return false;
}

static bool Array_Array_v__ast__Type_contains(Array_Array_v__ast__Type a, Array_v__ast__Type v) {
	for (int i = 0; i < a.len; ++i) {
		if (Array_v__ast__Type_arr_eq(((Array_v__ast__Type*)a.data)[i], v)) {
			return true;
		}
	}
	return false;
}

static bool Array_v__ast__Type_contains(Array_v__ast__Type a, v__ast__Type v) {
	for (int i = 0; i < a.len; ++i) {
		if (((v__ast__Type*)a.data)[i] == v) {
			return true;
		}
	}
	return false;
}

static bool Array_int_contains(Array_int a, int v) {
	for (int i = 0; i < a.len; ++i) {
		if (((int*)a.data)[i] == v) {
			return true;
		}
	}
	return false;
}

static bool Array_i64_contains(Array_i64 a, i64 v) {
	for (int i = 0; i < a.len; ++i) {
		if (((i64*)a.data)[i] == v) {
			return true;
		}
	}
	return false;
}

static bool Array_v__gen__c__StrType_contains(Array_v__gen__c__StrType a, v__gen__c__StrType v) {
	for (int i = 0; i < a.len; ++i) {
		if (v__gen__c__StrType_struct_eq(((v__gen__c__StrType*)a.data)[i], v)) {
			return true;
		}
	}
	return false;
}

static bool Array_v__gen__c__SumtypeCastingFn_contains(Array_v__gen__c__SumtypeCastingFn a, v__gen__c__SumtypeCastingFn v) {
	for (int i = 0; i < a.len; ++i) {
		if (v__gen__c__SumtypeCastingFn_struct_eq(((v__gen__c__SumtypeCastingFn*)a.data)[i], v)) {
			return true;
		}
	}
	return false;
}

static bool Array_v__ast__EmbeddedFile_contains(Array_v__ast__EmbeddedFile a, v__ast__EmbeddedFile v) {
	for (int i = 0; i < a.len; ++i) {
		if (v__ast__EmbeddedFile_struct_eq(((v__ast__EmbeddedFile*)a.data)[i], v)) {
			return true;
		}
	}
	return false;
}

static int Array_string_index(Array_string a, string v) {
	string* pelem = a.data;
	for (int i = 0; i < a.len; ++i, ++pelem) {
		if (fast_string_eq(*pelem, v)) {
			return i;
		}
	}
	return -1;
}

static bool time__Duration_alias_eq(time__Duration a, time__Duration b) {
	return a == b;
}

static bool v__ast__Type_alias_eq(v__ast__Type a, v__ast__Type b) {
	return a == b;
}

static bool Array_string_arr_eq(Array_string a, Array_string b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (!string__eq(*((string*)((byte*)a.data+(i*a.element_size))), *((string*)((byte*)b.data+(i*b.element_size))))) {
			return false;
		}
	}
	return true;
}

static bool Map_string_string_map_eq(Map_string_string a, Map_string_string b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.key_values.len; ++i) {
		if (!DenseArray_has_index(&a.key_values, i)) continue;
		voidptr k = DenseArray_key(&a.key_values, i);
		if (!map_exists(&b, k)) return false;
		string v = *(string*)map_get(&a, k, &(string[]){ 0 });
		if (!fast_string_eq(*(string*)map_get(&b, k, &(string[]){_SLIT("")}), v)) {
			return false;
		}
	}
	return true;
}

static bool Array_v__ast__Type_arr_eq(Array_v__ast__Type a, Array_v__ast__Type b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (!v__ast__Type_alias_eq(((v__ast__Type*)a.data)[i], ((v__ast__Type*)b.data)[i])) {
			return false;
		}
	}
	return true;
}

static bool v__gen__c__StrType_struct_eq(v__gen__c__StrType a, v__gen__c__StrType b) {
	return string__eq(a.styp, b.styp)
		&& v__ast__Type_alias_eq(a.typ, b.typ);
}

static bool v__gen__c__SumtypeCastingFn_struct_eq(v__gen__c__SumtypeCastingFn a, v__gen__c__SumtypeCastingFn b) {
	return string__eq(a.fn_name, b.fn_name)
		&& v__ast__Type_alias_eq(a.got, b.got)
		&& v__ast__Type_alias_eq(a.exp, b.exp);
}

static bool Array_byte_arr_eq(Array_byte a, Array_byte b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (*((byte*)((byte*)a.data+(i*a.element_size))) != *((byte*)((byte*)b.data+(i*b.element_size)))) {
			return false;
		}
	}
	return true;
}

static bool v__ast__EmbeddedFile_struct_eq(v__ast__EmbeddedFile a, v__ast__EmbeddedFile b) {
	return string__eq(a.rpath, b.rpath)
		&& string__eq(a.apath, b.apath)
		&& string__eq(a.compression_type, b.compression_type)
		&& a.is_compressed == b.is_compressed
		&& Array_byte_arr_eq(a.bytes, b.bytes)
		&& a.len == b.len;
}

VV_LOCAL_SYMBOL void anon_fn_40181cb3d9c4559e__82(void) {
		println(_SLIT("}"));
	}
	


// V out

// >> typeof() support for sum types / interfaces
static char * v_typeof_interface_IError(int sidx) { /* IError */ 
	if (sidx == _IError_None___index) return "None__";
	if (sidx == _IError_Error_index) return "Error";
	if (sidx == _IError_time__TimeParseError_index) return "time.TimeParseError";
	if (sidx == _IError_flag__UnkownFlagError_index) return "flag.UnkownFlagError";
	if (sidx == _IError_flag__MinimumArgsCountError_index) return "flag.MinimumArgsCountError";
	if (sidx == _IError_flag__MaximumArgsCountError_index) return "flag.MaximumArgsCountError";
	if (sidx == _IError_flag__NoArgsExpectedError_index) return "flag.NoArgsExpectedError";
	if (sidx == _IError_semver__InvalidComparatorFormatError_index) return "semver.InvalidComparatorFormatError";
	if (sidx == _IError_semver__EmptyInputError_index) return "semver.EmptyInputError";
	if (sidx == _IError_semver__InvalidVersionFormatError_index) return "semver.InvalidVersionFormatError";
	if (sidx == _IError_os__ErrFileNotOpened_index) return "os.ErrFileNotOpened";
	if (sidx == _IError_os__ErrSizeOfTypeIs0_index) return "os.ErrSizeOfTypeIs0";
	if (sidx == _IError_os__ErrExecutableNotFound_index) return "os.ErrExecutableNotFound";
	if (sidx == _IError_v__gen__c__UnsupportedAssertCtempTransform_index) return "v.gen.c.UnsupportedAssertCtempTransform";
	if (sidx == _IError_semver__InvalidComparatorCountError_index) return "semver.InvalidComparatorCountError";
	if (sidx == _IError_voidptr_index) return "voidptr";
	return "unknown IError";
}

static int v_typeof_interface_idx_IError(int sidx) { /* IError */ 
	if (sidx == _IError_None___index) return 65622;
	if (sidx == _IError_Error_index) return 85;
	if (sidx == _IError_time__TimeParseError_index) return 252;
	if (sidx == _IError_flag__UnkownFlagError_index) return 66117;
	if (sidx == _IError_flag__MinimumArgsCountError_index) return 66118;
	if (sidx == _IError_flag__MaximumArgsCountError_index) return 66119;
	if (sidx == _IError_flag__NoArgsExpectedError_index) return 66120;
	if (sidx == _IError_semver__InvalidComparatorFormatError_index) return 66132;
	if (sidx == _IError_semver__EmptyInputError_index) return 66134;
	if (sidx == _IError_semver__InvalidVersionFormatError_index) return 66135;
	if (sidx == _IError_os__ErrFileNotOpened_index) return 65656;
	if (sidx == _IError_os__ErrSizeOfTypeIs0_index) return 65657;
	if (sidx == _IError_os__ErrExecutableNotFound_index) return 65670;
	if (sidx == _IError_v__gen__c__UnsupportedAssertCtempTransform_index) return 526;
	if (sidx == _IError_semver__InvalidComparatorCountError_index) return 595;
	if (sidx == _IError_voidptr_index) return 2;
	return 29;
}
static char * v_typeof_interface_rand__PRNG(int sidx) { /* rand.PRNG */ 
	if (sidx == _rand__PRNG_rand__wyrand__WyRandRNG_index) return "rand.wyrand.WyRandRNG";
	return "unknown rand.PRNG";
}

static int v_typeof_interface_idx_rand__PRNG(int sidx) { /* rand.PRNG */ 
	if (sidx == _rand__PRNG_rand__wyrand__WyRandRNG_index) return 65768;
	return 229;
}
static char * v_typeof_sumtype_v__ast__TypeDecl(int sidx) { /* v.ast.TypeDecl */ 
	switch(sidx) {
		case 277: return "v.ast.TypeDecl";
		case 274: return "v.ast.AliasTypeDecl";
		case 275: return "v.ast.FnTypeDecl";
		case 276: return "v.ast.SumTypeDecl";
		default: return "unknown v.ast.TypeDecl";
	}
}

int v_typeof_sumtype_idx_v__ast__TypeDecl(int sidx) { /* v.ast.TypeDecl */ 
	switch(sidx) {
		case 277: return 277;
		case 274: return 274;
		case 275: return 275;
		case 276: return 276;
		default: return 277;
	}
}
static char * v_typeof_sumtype_v__ast__Expr(int sidx) { /* v.ast.Expr */ 
	switch(sidx) {
		case 328: return "v.ast.Expr";
		case 278: return "v.ast.AnonFn";
		case 279: return "v.ast.ArrayDecompose";
		case 280: return "v.ast.ArrayInit";
		case 281: return "v.ast.AsCast";
		case 282: return "v.ast.Assoc";
		case 283: return "v.ast.AtExpr";
		case 284: return "v.ast.BoolLiteral";
		case 285: return "v.ast.CTempVar";
		case 286: return "v.ast.CallExpr";
		case 287: return "v.ast.CastExpr";
		case 288: return "v.ast.ChanInit";
		case 289: return "v.ast.CharLiteral";
		case 290: return "v.ast.Comment";
		case 291: return "v.ast.ComptimeCall";
		case 292: return "v.ast.ComptimeSelector";
		case 293: return "v.ast.ConcatExpr";
		case 294: return "v.ast.DumpExpr";
		case 295: return "v.ast.EmptyExpr";
		case 296: return "v.ast.EnumVal";
		case 297: return "v.ast.FloatLiteral";
		case 298: return "v.ast.GoExpr";
		case 299: return "v.ast.Ident";
		case 300: return "v.ast.IfExpr";
		case 301: return "v.ast.IfGuardExpr";
		case 302: return "v.ast.IndexExpr";
		case 303: return "v.ast.InfixExpr";
		case 304: return "v.ast.IntegerLiteral";
		case 305: return "v.ast.IsRefType";
		case 306: return "v.ast.Likely";
		case 307: return "v.ast.LockExpr";
		case 308: return "v.ast.MapInit";
		case 309: return "v.ast.MatchExpr";
		case 310: return "v.ast.NodeError";
		case 311: return "v.ast.None";
		case 312: return "v.ast.OffsetOf";
		case 313: return "v.ast.OrExpr";
		case 314: return "v.ast.ParExpr";
		case 315: return "v.ast.PostfixExpr";
		case 316: return "v.ast.PrefixExpr";
		case 317: return "v.ast.RangeExpr";
		case 318: return "v.ast.SelectExpr";
		case 319: return "v.ast.SelectorExpr";
		case 320: return "v.ast.SizeOf";
		case 321: return "v.ast.SqlExpr";
		case 322: return "v.ast.StringInterLiteral";
		case 323: return "v.ast.StringLiteral";
		case 324: return "v.ast.StructInit";
		case 325: return "v.ast.TypeNode";
		case 326: return "v.ast.TypeOf";
		case 327: return "v.ast.UnsafeExpr";
		default: return "unknown v.ast.Expr";
	}
}

int v_typeof_sumtype_idx_v__ast__Expr(int sidx) { /* v.ast.Expr */ 
	switch(sidx) {
		case 328: return 328;
		case 278: return 278;
		case 279: return 279;
		case 280: return 280;
		case 281: return 281;
		case 282: return 282;
		case 283: return 283;
		case 284: return 284;
		case 285: return 285;
		case 286: return 286;
		case 287: return 287;
		case 288: return 288;
		case 289: return 289;
		case 290: return 290;
		case 291: return 291;
		case 292: return 292;
		case 293: return 293;
		case 294: return 294;
		case 295: return 295;
		case 296: return 296;
		case 297: return 297;
		case 298: return 298;
		case 299: return 299;
		case 300: return 300;
		case 301: return 301;
		case 302: return 302;
		case 303: return 303;
		case 304: return 304;
		case 305: return 305;
		case 306: return 306;
		case 307: return 307;
		case 308: return 308;
		case 309: return 309;
		case 310: return 310;
		case 311: return 311;
		case 312: return 312;
		case 313: return 313;
		case 314: return 314;
		case 315: return 315;
		case 316: return 316;
		case 317: return 317;
		case 318: return 318;
		case 319: return 319;
		case 320: return 320;
		case 321: return 321;
		case 322: return 322;
		case 323: return 323;
		case 324: return 324;
		case 325: return 325;
		case 326: return 326;
		case 327: return 327;
		default: return 328;
	}
}
static char * v_typeof_sumtype_v__ast__Stmt(int sidx) { /* v.ast.Stmt */ 
	switch(sidx) {
		case 353: return "v.ast.Stmt";
		case 329: return "v.ast.AsmStmt";
		case 330: return "v.ast.AssertStmt";
		case 331: return "v.ast.AssignStmt";
		case 332: return "v.ast.Block";
		case 333: return "v.ast.BranchStmt";
		case 334: return "v.ast.ComptimeFor";
		case 335: return "v.ast.ConstDecl";
		case 336: return "v.ast.DeferStmt";
		case 337: return "v.ast.EmptyStmt";
		case 338: return "v.ast.EnumDecl";
		case 339: return "v.ast.ExprStmt";
		case 216: return "v.ast.FnDecl";
		case 340: return "v.ast.ForCStmt";
		case 341: return "v.ast.ForInStmt";
		case 342: return "v.ast.ForStmt";
		case 343: return "v.ast.GlobalDecl";
		case 344: return "v.ast.GotoLabel";
		case 345: return "v.ast.GotoStmt";
		case 346: return "v.ast.HashStmt";
		case 347: return "v.ast.Import";
		case 348: return "v.ast.InterfaceDecl";
		case 349: return "v.ast.Module";
		case 310: return "v.ast.NodeError";
		case 350: return "v.ast.Return";
		case 351: return "v.ast.SqlStmt";
		case 352: return "v.ast.StructDecl";
		case 277: return "v.ast.TypeDecl";
		default: return "unknown v.ast.Stmt";
	}
}

int v_typeof_sumtype_idx_v__ast__Stmt(int sidx) { /* v.ast.Stmt */ 
	switch(sidx) {
		case 353: return 353;
		case 329: return 329;
		case 330: return 330;
		case 331: return 331;
		case 332: return 332;
		case 333: return 333;
		case 334: return 334;
		case 335: return 335;
		case 336: return 336;
		case 337: return 337;
		case 338: return 338;
		case 339: return 339;
		case 216: return 216;
		case 340: return 340;
		case 341: return 341;
		case 342: return 342;
		case 343: return 343;
		case 344: return 344;
		case 345: return 345;
		case 346: return 346;
		case 347: return 347;
		case 348: return 348;
		case 349: return 349;
		case 310: return 310;
		case 350: return 350;
		case 351: return 351;
		case 352: return 352;
		case 277: return 277;
		default: return 353;
	}
}
static char * v_typeof_sumtype_v__ast__ScopeObject(int sidx) { /* v.ast.ScopeObject */ 
	switch(sidx) {
		case 358: return "v.ast.ScopeObject";
		case 354: return "v.ast.AsmRegister";
		case 355: return "v.ast.ConstField";
		case 356: return "v.ast.GlobalField";
		case 357: return "v.ast.Var";
		default: return "unknown v.ast.ScopeObject";
	}
}

int v_typeof_sumtype_idx_v__ast__ScopeObject(int sidx) { /* v.ast.ScopeObject */ 
	switch(sidx) {
		case 358: return 358;
		case 354: return 354;
		case 355: return 355;
		case 356: return 356;
		case 357: return 357;
		default: return 358;
	}
}
static char * v_typeof_sumtype_v__ast__Node(int sidx) { /* v.ast.Node */ 
	switch(sidx) {
		case 368: return "v.ast.Node";
		case 359: return "v.ast.CallArg";
		case 355: return "v.ast.ConstField";
		case 360: return "v.ast.EmptyNode";
		case 361: return "v.ast.EnumField";
		case 328: return "v.ast.Expr";
		case 207: return "v.ast.File";
		case 356: return "v.ast.GlobalField";
		case 362: return "v.ast.IfBranch";
		case 363: return "v.ast.MatchBranch";
		case 310: return "v.ast.NodeError";
		case 364: return "v.ast.Param";
		case 358: return "v.ast.ScopeObject";
		case 365: return "v.ast.SelectBranch";
		case 353: return "v.ast.Stmt";
		case 366: return "v.ast.StructField";
		case 367: return "v.ast.StructInitField";
		default: return "unknown v.ast.Node";
	}
}

int v_typeof_sumtype_idx_v__ast__Node(int sidx) { /* v.ast.Node */ 
	switch(sidx) {
		case 368: return 368;
		case 359: return 359;
		case 355: return 355;
		case 360: return 360;
		case 361: return 361;
		case 328: return 328;
		case 207: return 207;
		case 356: return 356;
		case 362: return 362;
		case 363: return 363;
		case 310: return 310;
		case 364: return 364;
		case 358: return 358;
		case 365: return 365;
		case 353: return 353;
		case 366: return 366;
		case 367: return 367;
		default: return 368;
	}
}
static char * v_typeof_sumtype_v__ast__ComptTimeConstValue(int sidx) { /* v.ast.ComptTimeConstValue */ 
	switch(sidx) {
		case 381: return "v.ast.ComptTimeConstValue";
		case 295: return "v.ast.EmptyExpr";
		case 10: return "byte";
		case 15: return "f32";
		case 16: return "f64";
		case 6: return "i16";
		case 8: return "i64";
		case 5: return "i8";
		case 7: return "int";
		case 21: return "rune";
		case 20: return "string";
		case 11: return "u16";
		case 12: return "u32";
		case 13: return "u64";
		default: return "unknown v.ast.ComptTimeConstValue";
	}
}

int v_typeof_sumtype_idx_v__ast__ComptTimeConstValue(int sidx) { /* v.ast.ComptTimeConstValue */ 
	switch(sidx) {
		case 381: return 381;
		case 295: return 295;
		case 10: return 10;
		case 15: return 15;
		case 16: return 16;
		case 6: return 6;
		case 8: return 8;
		case 5: return 5;
		case 7: return 7;
		case 21: return 21;
		case 20: return 20;
		case 11: return 11;
		case 12: return 12;
		case 13: return 13;
		default: return 381;
	}
}
static char * v_typeof_sumtype_v__ast__IdentInfo(int sidx) { /* v.ast.IdentInfo */ 
	switch(sidx) {
		case 409: return "v.ast.IdentInfo";
		case 407: return "v.ast.IdentFn";
		case 408: return "v.ast.IdentVar";
		default: return "unknown v.ast.IdentInfo";
	}
}

int v_typeof_sumtype_idx_v__ast__IdentInfo(int sidx) { /* v.ast.IdentInfo */ 
	switch(sidx) {
		case 409: return 409;
		case 407: return 407;
		case 408: return 408;
		default: return 409;
	}
}
static char * v_typeof_sumtype_v__ast__AsmArg(int sidx) { /* v.ast.AsmArg */ 
	switch(sidx) {
		case 426: return "v.ast.AsmArg";
		case 428: return "v.ast.AsmAddressing";
		case 429: return "v.ast.AsmAlias";
		case 430: return "v.ast.AsmDisp";
		case 354: return "v.ast.AsmRegister";
		case 284: return "v.ast.BoolLiteral";
		case 289: return "v.ast.CharLiteral";
		case 297: return "v.ast.FloatLiteral";
		case 304: return "v.ast.IntegerLiteral";
		case 20: return "string";
		default: return "unknown v.ast.AsmArg";
	}
}

int v_typeof_sumtype_idx_v__ast__AsmArg(int sidx) { /* v.ast.AsmArg */ 
	switch(sidx) {
		case 426: return 426;
		case 428: return 428;
		case 429: return 429;
		case 430: return 430;
		case 354: return 354;
		case 284: return 284;
		case 289: return 289;
		case 297: return 297;
		case 304: return 304;
		case 20: return 20;
		default: return 426;
	}
}
static char * v_typeof_sumtype_v__ast__TypeInfo(int sidx) { /* v.ast.TypeInfo */ 
	switch(sidx) {
		case 475: return "v.ast.TypeInfo";
		case 458: return "v.ast.Aggregate";
		case 460: return "v.ast.Alias";
		case 441: return "v.ast.Array";
		case 468: return "v.ast.ArrayFixed";
		case 469: return "v.ast.Chan";
		case 474: return "v.ast.Enum";
		case 472: return "v.ast.FnType";
		case 473: return "v.ast.GenericInst";
		case 463: return "v.ast.Interface";
		case 442: return "v.ast.Map";
		case 471: return "v.ast.MultiReturn";
		case 446: return "v.ast.Struct";
		case 464: return "v.ast.SumType";
		case 470: return "v.ast.Thread";
		default: return "unknown v.ast.TypeInfo";
	}
}

int v_typeof_sumtype_idx_v__ast__TypeInfo(int sidx) { /* v.ast.TypeInfo */ 
	switch(sidx) {
		case 475: return 475;
		case 458: return 458;
		case 460: return 460;
		case 441: return 441;
		case 468: return 468;
		case 469: return 469;
		case 474: return 474;
		case 472: return 472;
		case 473: return 473;
		case 463: return 463;
		case 442: return 442;
		case 471: return 471;
		case 446: return 446;
		case 464: return 464;
		case 470: return 470;
		default: return 475;
	}
}
static char * v_typeof_interface_hash__Hasher(int sidx) { /* hash.Hasher */ 
	return "unknown hash.Hasher";
}

static int v_typeof_interface_idx_hash__Hasher(int sidx) { /* hash.Hasher */ 
	return 522;
}
static char * v_typeof_interface_hash__Hash32er(int sidx) { /* hash.Hash32er */ 
	return "unknown hash.Hash32er";
}

static int v_typeof_interface_idx_hash__Hash32er(int sidx) { /* hash.Hash32er */ 
	return 523;
}
static char * v_typeof_interface_hash__Hash64er(int sidx) { /* hash.Hash64er */ 
	return "unknown hash.Hash64er";
}

static int v_typeof_interface_idx_hash__Hash64er(int sidx) { /* hash.Hash64er */ 
	return 524;
}
static char * v_typeof_interface_v__ast__walker__Visitor(int sidx) { /* v.ast.walker.Visitor */ 
	if (sidx == _v__ast__walker__Visitor_v__ast__walker__Inspector_index) return "v.ast.walker.Inspector";
	if (sidx == _v__ast__walker__Visitor_v__callgraph__Mapper_index) return "v.callgraph.Mapper";
	return "unknown v.ast.walker.Visitor";
}

static int v_typeof_interface_idx_v__ast__walker__Visitor(int sidx) { /* v.ast.walker.Visitor */ 
	if (sidx == _v__ast__walker__Visitor_v__ast__walker__Inspector_index) return 557;
	if (sidx == _v__ast__walker__Visitor_v__callgraph__Mapper_index) return 66051;
	return 555;
}
// << typeof() support for sum types

	// pointers to common sumtype fields
	// pointers to common sumtype fields
	// pointers to common sumtype fields
// TypeDecl
strings__Builder strings__new_builder(int initial_size) {
	strings__Builder res = ((__new_array_with_default(0, initial_size, sizeof(byte), 0)));
	ArrayFlags_set(&res.flags, ArrayFlags__noslices);
	return res;
}

// Attr: [unsafe]
void strings__Builder_write_ptr(strings__Builder* b, byte* ptr, int len) {
	if (len == 0) {
		return;
	}
	array_push_many(b, ptr, len);
}

// Attr: [manualfree]
void strings__Builder_write_rune(strings__Builder* b, rune r) {
	Array_fixed_byte_5 buffer = {0};
	string res = utf32_to_str_no_malloc(((u32)(r)), &buffer[0]);
	if (res.len == 0) {
		return;
	}
	array_push_many(b, res.str, res.len);
}

void strings__Builder_write_runes(strings__Builder* b, Array_rune runes) {
	Array_fixed_byte_5 buffer = {0};
	for (int _t1 = 0; _t1 < runes.len; ++_t1) {
		rune r = ((rune*)runes.data)[_t1];
		string res = utf32_to_str_no_malloc(((u32)(r)), &buffer[0]);
		if (res.len == 0) {
			continue;
		}
		array_push_many(b, res.str, res.len);
	}
}

void strings__Builder_write_b(strings__Builder* b, byte data) {
	array_push((array*)b, _MOV((byte[]){ data }));
}

Option_int strings__Builder_write(strings__Builder* b, Array_byte data) {
	if (data.len == 0) {
		Option_int _t1;
		opt_ok(&(int[]) { 0 }, (Option*)(&_t1), sizeof(int));
		return _t1;
	}
	_PUSH_MANY(b, (data), _t2, strings__Builder);
	Option_int _t3;
	opt_ok(&(int[]) { data.len }, (Option*)(&_t3), sizeof(int));
	return _t3;
}

// Attr: [manualfree]
void strings__Builder_drain_builder(strings__Builder* b, strings__Builder* other, int other_new_cap) {
	Option_int _t1 = strings__Builder_write(b, *other);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		_v_panic(IError_str(err));
		VUNREACHABLE();
	;
	}
	
  (*(int*)_t1.data);
	strings__Builder_free(other);
	*other = strings__new_builder(other_new_cap);
}

// Attr: [inline]
inline byte strings__Builder_byte_at(strings__Builder* b, int n) {
	return (*(byte*)/*ee elem_typ */array_get(*(((Array_byte*)(b))), n));
}

// Attr: [inline]
inline void strings__Builder_write_string(strings__Builder* b, string s) {
	if (s.len == 0) {
		return;
	}
	array_push_many(b, s.str, s.len);
}

void strings__Builder_go_back(strings__Builder* b, int n) {
	array_trim(b, b->len - n);
}

string strings__Builder_cut_last(strings__Builder* b, int n) {
	int cut_pos = b->len - n;
	Array_byte x = array_slice(*(((Array_byte*)(b))), cut_pos, (*(((Array_byte*)(b)))).len);
	string res = Array_byte_bytestr(x);
	array_trim(b, cut_pos);
	return res;
}

string strings__Builder_cut_to(strings__Builder* b, int pos) {
	if (pos > b->len) {
		return _SLIT("");
	}
	return strings__Builder_cut_last(b, b->len - pos);
}

void strings__Builder_go_back_to(strings__Builder* b, int pos) {
	array_trim(b, pos);
}

// Attr: [inline]
inline void strings__Builder_writeln(strings__Builder* b, string s) {
	if (s.len > 0) {
		array_push_many(b, s.str, s.len);
	}
	array_push((array*)b, _MOV((byte[]){ ((byte)('\n')) }));
}

string strings__Builder_last_n(strings__Builder* b, int n) {
	if (n > b->len) {
		return _SLIT("");
	}
	Array_byte x = array_slice(*(((Array_byte*)(b))), b->len - n, (*(((Array_byte*)(b)))).len);
	return Array_byte_bytestr(x);
}

string strings__Builder_after(strings__Builder* b, int n) {
	if (n >= b->len) {
		return _SLIT("");
	}
	Array_byte x = array_slice(*(((Array_byte*)(b))), n, (*(((Array_byte*)(b)))).len);
	return Array_byte_bytestr(x);
}

string strings__Builder_str(strings__Builder* b) {
	array_push((array*)b, _MOV((byte[]){ ((byte)(0)) }));
	byte* bcopy = ((byte*)(memdup_noscan(b->data, b->len)));
	string s = byte_vstring_with_len(bcopy, b->len - 1);
	array_trim(b, 0);
	return s;
}

// Attr: [unsafe]
void strings__Builder_free(strings__Builder* b) {
	if (b->data != 0) {
		_v_free(b->data);
		{ // Unsafe block
			b->data = ((voidptr)(0));
		}
	}
}

int strings__levenshtein_distance(string a, string b) {
	Array_int f = array_repeat_to_depth(new_array_from_c_array(1, 1, sizeof(int), _MOV((int[1]){0})), b.len + 1, 0);
	for (int j = 0; j < f.len; ++j) {
		array_set(&f, j, &(int[]) { j });
	}
	for (int _t1 = 0; _t1 < a.len; ++_t1) {
		byte ca = a.str[_t1];
		int j = 1;
		int fj1 = (*(int*)/*ee elem_typ */array_get(f, 0));
		(*(int*)/*ee elem_typ */array_get(f, 0))++;
		for (int _t2 = 0; _t2 < b.len; ++_t2) {
			byte cb = b.str[_t2];
			int mn = ((*(int*)/*ee elem_typ */array_get(f, j)) + 1 <= (*(int*)/*ee elem_typ */array_get(f, j - 1)) + 1 ? ((*(int*)/*ee elem_typ */array_get(f, j)) + 1) : ((*(int*)/*ee elem_typ */array_get(f, j - 1)) + 1));
			if (cb != ca) {
				mn = (mn <= fj1 + 1 ? (mn) : (fj1 + 1));
			} else {
				mn = (mn <= fj1 ? (mn) : (fj1));
			}
			fj1 = (*(int*)/*ee elem_typ */array_get(f, j));
			array_set(&f, j, &(int[]) { mn });
			j++;
		}
	}
	return (*(int*)/*ee elem_typ */array_get(f, f.len - 1));
}

f32 strings__levenshtein_distance_percentage(string a, string b) {
	int d = strings__levenshtein_distance(a, b);
	int l = (a.len >= b.len ? (a.len) : (b.len));
	return (1.00 - ((f32)(d)) / ((f32)(l))) * 100.00;
}

f32 strings__dice_coefficient(string s1, string s2) {
	if (s1.len == 0 || s2.len == 0) {
		return 0.0;
	}
	if (string__eq(s1, s2)) {
		return 1.0;
	}
	if (s1.len < 2 || s2.len < 2) {
		return 0.0;
	}
	string a = (s1.len > s2.len ? (s1) : (s2));
	string b = (string__eq(a, s1) ? (s2) : (s1));
	Map_string_int first_bigrams = new_map(sizeof(string), sizeof(int), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
	for (int i = 0; i < a.len - 1; ++i) {
		string bigram = string_substr(a, i, i + 2);
		int q = (_IN_MAP(ADDR(string, bigram), ADDR(map, first_bigrams)) ? ((*(int*)map_get(ADDR(map, first_bigrams), &(string[]){bigram}, &(int[]){ 0 })) + 1) : (1));
		map_set(&first_bigrams, &(string[]){bigram}, &(int[]) { q });
	}
	int intersection_size = 0;
	for (int i = 0; i < b.len - 1; ++i) {
		string bigram = string_substr(b, i, i + 2);
		int count = (_IN_MAP(ADDR(string, bigram), ADDR(map, first_bigrams)) ? ((*(int*)map_get(ADDR(map, first_bigrams), &(string[]){bigram}, &(int[]){ 0 }))) : (0));
		if (count > 0) {
			map_set(&first_bigrams, &(string[]){bigram}, &(int[]) { count - 1 });
			intersection_size++;
		}
	}
	return (2.0 * ((f32)(intersection_size))) / (((f32)(a.len)) + ((f32)(b.len)) - 2);
}

string strings__repeat(byte c, int n) {
	if (n <= 0) {
		return _SLIT("");
	}
	byte* bytes = malloc_noscan(n + 1);
	{ // Unsafe block
		memset(bytes, c, n);
		bytes[n] = '0';
	}
	return byte_vstring_with_len(bytes, n);
}

string strings__repeat_string(string s, int n) {
	if (n <= 0 || s.len == 0) {
		return _SLIT("");
	}
	int slen = s.len;
	int blen = slen * n;
	byte* bytes = malloc_noscan(blen + 1);
	for (int bi = 0; bi < n; ++bi) {
		int bislen = bi * slen;
		for (int si = 0; si < slen; ++si) {
			{ // Unsafe block
				bytes[bislen + si] = string_at(s, si);
			}
		}
	}
	{ // Unsafe block
		bytes[blen] = '0';
	}
	return byte_vstring_with_len(bytes, blen);
}

int math__bits__leading_zeros_8(byte x) {
	int _t1 = 8 - math__bits__len_8(x);
	return _t1;
}

int math__bits__leading_zeros_16(u16 x) {
	int _t1 = 16 - math__bits__len_16(x);
	return _t1;
}

int math__bits__leading_zeros_32(u32 x) {
	int _t1 = 32 - math__bits__len_32(x);
	return _t1;
}

int math__bits__leading_zeros_64(u64 x) {
	int _t1 = 64 - math__bits__len_64(x);
	return _t1;
}

int math__bits__trailing_zeros_8(byte x) {
	int _t1 = ((int)((*(byte*)/*ee elem_typ */array_get(_const_math__bits__ntz_8_tab, x))));
	return _t1;
}

int math__bits__trailing_zeros_16(u16 x) {
	if (x == 0U) {
		int _t1 = 16;
		return _t1;
	}
	int _t2 = ((int)((*(byte*)/*ee elem_typ */array_get(_const_math__bits__de_bruijn32tab, ((u32)((x & -x))) * _const_math__bits__de_bruijn32 >> (32 - 5)))));
	return _t2;
}

int math__bits__trailing_zeros_32(u32 x) {
	if (x == 0U) {
		int _t1 = 32;
		return _t1;
	}
	int _t2 = ((int)((*(byte*)/*ee elem_typ */array_get(_const_math__bits__de_bruijn32tab, ((x & -x)) * _const_math__bits__de_bruijn32 >> (32 - 5)))));
	return _t2;
}

int math__bits__trailing_zeros_64(u64 x) {
	if (x == 0U) {
		int _t1 = 64;
		return _t1;
	}
	int _t2 = ((int)((*(byte*)/*ee elem_typ */array_get(_const_math__bits__de_bruijn64tab, ((x & -x)) * _const_math__bits__de_bruijn64 >> (64 - 6)))));
	return _t2;
}

int math__bits__ones_count_8(byte x) {
	int _t1 = ((int)((*(byte*)/*ee elem_typ */array_get(_const_math__bits__pop_8_tab, x))));
	return _t1;
}

int math__bits__ones_count_16(u16 x) {
	int _t1 = ((int)((*(byte*)/*ee elem_typ */array_get(_const_math__bits__pop_8_tab, x >> 8U)) + (*(byte*)/*ee elem_typ */array_get(_const_math__bits__pop_8_tab, (x & ((u16)(0xffU)))))));
	return _t1;
}

int math__bits__ones_count_32(u32 x) {
	int _t1 = ((int)((*(byte*)/*ee elem_typ */array_get(_const_math__bits__pop_8_tab, x >> 24U)) + (*(byte*)/*ee elem_typ */array_get(_const_math__bits__pop_8_tab, (x >> 16U & 0xffU))) + (*(byte*)/*ee elem_typ */array_get(_const_math__bits__pop_8_tab, (x >> 8U & 0xffU))) + (*(byte*)/*ee elem_typ */array_get(_const_math__bits__pop_8_tab, (x & ((u32)(0xffU)))))));
	return _t1;
}

int math__bits__ones_count_64(u64 x) {
	u64 y = ((x >> ((u64)(1U)) & ((_const_math__bits__m0 & _const_math__bits__max_u64)))) + ((x & ((_const_math__bits__m0 & _const_math__bits__max_u64))));
	y = ((y >> ((u64)(2U)) & ((_const_math__bits__m1 & _const_math__bits__max_u64)))) + ((y & ((_const_math__bits__m1 & _const_math__bits__max_u64))));
	y = (((y >> 4U) + y) & ((_const_math__bits__m2 & _const_math__bits__max_u64)));
	y += y >> 8U;
	y += y >> 16U;
	y += y >> 32U;
	int _t1 = (((int)(y)) & ((1 << 7) - 1));
	return _t1;
}

// Attr: [inline]
inline byte math__bits__rotate_left_8(byte x, int k) {
	byte n = ((byte)(8));
	byte s = (((byte)(k)) & (n - ((byte)(1))));
	byte _t1 = ((x << s) | (x >> (n - s)));
	return _t1;
}

// Attr: [inline]
inline u16 math__bits__rotate_left_16(u16 x, int k) {
	u16 n = ((u16)(16U));
	u16 s = (((u16)(k)) & (n - ((u16)(1U))));
	u16 _t1 = ((x << s) | (x >> (n - s)));
	return _t1;
}

// Attr: [inline]
inline u32 math__bits__rotate_left_32(u32 x, int k) {
	u32 n = ((u32)(32U));
	u32 s = (((u32)(k)) & (n - ((u32)(1U))));
	u32 _t1 = ((x << s) | (x >> (n - s)));
	return _t1;
}

// Attr: [inline]
inline u64 math__bits__rotate_left_64(u64 x, int k) {
	u64 n = ((u64)(64U));
	u64 s = (((u64)(k)) & (n - ((u64)(1U))));
	u64 _t1 = ((x << s) | (x >> (n - s)));
	return _t1;
}

// Attr: [inline]
inline byte math__bits__reverse_8(byte x) {
	byte _t1 = (*(byte*)/*ee elem_typ */array_get(_const_math__bits__rev_8_tab, x));
	return _t1;
}

// Attr: [inline]
inline u16 math__bits__reverse_16(u16 x) {
	u16 _t1 = (((u16)((*(byte*)/*ee elem_typ */array_get(_const_math__bits__rev_8_tab, x >> 8U)))) | (((u16)((*(byte*)/*ee elem_typ */array_get(_const_math__bits__rev_8_tab, (x & ((u16)(0xffU))))))) << 8U));
	return _t1;
}

// Attr: [inline]
inline u32 math__bits__reverse_32(u32 x) {
	u64 y = ((((x >> ((u32)(1U)) & ((_const_math__bits__m0 & _const_math__bits__max_u32)))) | (((x & ((_const_math__bits__m0 & _const_math__bits__max_u32)))) << 1U)));
	y = ((((y >> ((u32)(2U)) & ((_const_math__bits__m1 & _const_math__bits__max_u32)))) | (((y & ((_const_math__bits__m1 & _const_math__bits__max_u32)))) << ((u32)(2U)))));
	y = ((((y >> ((u32)(4U)) & ((_const_math__bits__m2 & _const_math__bits__max_u32)))) | (((y & ((_const_math__bits__m2 & _const_math__bits__max_u32)))) << ((u32)(4U)))));
	u32 _t1 = math__bits__reverse_bytes_32(((u32)(y)));
	return _t1;
}

// Attr: [inline]
inline u64 math__bits__reverse_64(u64 x) {
	u64 y = ((((x >> ((u64)(1U)) & ((_const_math__bits__m0 & _const_math__bits__max_u64)))) | (((x & ((_const_math__bits__m0 & _const_math__bits__max_u64)))) << 1U)));
	y = ((((y >> ((u64)(2U)) & ((_const_math__bits__m1 & _const_math__bits__max_u64)))) | (((y & ((_const_math__bits__m1 & _const_math__bits__max_u64)))) << 2U)));
	y = ((((y >> ((u64)(4U)) & ((_const_math__bits__m2 & _const_math__bits__max_u64)))) | (((y & ((_const_math__bits__m2 & _const_math__bits__max_u64)))) << 4U)));
	u64 _t1 = math__bits__reverse_bytes_64(y);
	return _t1;
}

// Attr: [inline]
inline u16 math__bits__reverse_bytes_16(u16 x) {
	u16 _t1 = ((x >> 8U) | (x << 8U));
	return _t1;
}

// Attr: [inline]
inline u32 math__bits__reverse_bytes_32(u32 x) {
	u64 y = ((((x >> ((u32)(8U)) & ((_const_math__bits__m3 & _const_math__bits__max_u32)))) | (((x & ((_const_math__bits__m3 & _const_math__bits__max_u32)))) << ((u32)(8U)))));
	u32 _t1 = ((u32)(((y >> 16U) | (y << 16U))));
	return _t1;
}

// Attr: [inline]
inline u64 math__bits__reverse_bytes_64(u64 x) {
	u64 y = ((((x >> ((u64)(8U)) & ((_const_math__bits__m3 & _const_math__bits__max_u64)))) | (((x & ((_const_math__bits__m3 & _const_math__bits__max_u64)))) << ((u64)(8U)))));
	y = ((((y >> ((u64)(16U)) & ((_const_math__bits__m4 & _const_math__bits__max_u64)))) | (((y & ((_const_math__bits__m4 & _const_math__bits__max_u64)))) << ((u64)(16U)))));
	u64 _t1 = ((y >> 32U) | (y << 32U));
	return _t1;
}

int math__bits__len_8(byte x) {
	int _t1 = ((int)((*(byte*)/*ee elem_typ */array_get(_const_math__bits__len_8_tab, x))));
	return _t1;
}

int math__bits__len_16(u16 x) {
	u16 y = x;
	int n = 0;
	if (y >= 256U) {
		y >>= 8U;
		n = 8;
	}
	int _t1 = n + ((int)((*(byte*)/*ee elem_typ */array_get(_const_math__bits__len_8_tab, y))));
	return _t1;
}

int math__bits__len_32(u32 x) {
	u32 y = x;
	int n = 0;
	if (y >= (1 << 16)) {
		y >>= 16U;
		n = 16;
	}
	if (y >= (1 << 8)) {
		y >>= 8U;
		n += 8;
	}
	int _t1 = n + ((int)((*(byte*)/*ee elem_typ */array_get(_const_math__bits__len_8_tab, y))));
	return _t1;
}

int math__bits__len_64(u64 x) {
	u64 y = x;
	int n = 0;
	if (y >= ((u64)(1U)) << ((u64)(32U))) {
		y >>= 32U;
		n = 32;
	}
	if (y >= ((u64)(1U)) << ((u64)(16U))) {
		y >>= 16U;
		n += 16;
	}
	if (y >= ((u64)(1U)) << ((u64)(8U))) {
		y >>= 8U;
		n += 8;
	}
	int _t1 = n + ((int)((*(byte*)/*ee elem_typ */array_get(_const_math__bits__len_8_tab, y))));
	return _t1;
}

multi_return_u32_u32 math__bits__add_32(u32 x, u32 y, u32 carry) {
	u64 sum64 = ((u64)(x)) + ((u64)(y)) + ((u64)(carry));
	u32 sum = ((u32)(sum64));
	u32 carry_out = ((u32)(sum64 >> 32U));
	return (multi_return_u32_u32){.arg0=sum, .arg1=carry_out};
}

multi_return_u64_u64 math__bits__add_64(u64 x, u64 y, u64 carry) {
	u64 sum = x + y + carry;
	u64 carry_out = ((((x & y)) | ((((x | y)) & ~sum)))) >> 63U;
	return (multi_return_u64_u64){.arg0=sum, .arg1=carry_out};
}

multi_return_u32_u32 math__bits__sub_32(u32 x, u32 y, u32 borrow) {
	u32 diff = x - y - borrow;
	u32 borrow_out = ((((~x & y)) | ((~((x ^ y)) & diff)))) >> 31U;
	return (multi_return_u32_u32){.arg0=diff, .arg1=borrow_out};
}

multi_return_u64_u64 math__bits__sub_64(u64 x, u64 y, u64 borrow) {
	u64 diff = x - y - borrow;
	u64 borrow_out = ((((~x & y)) | ((~((x ^ y)) & diff)))) >> 63U;
	return (multi_return_u64_u64){.arg0=diff, .arg1=borrow_out};
}

multi_return_u32_u32 math__bits__mul_32(u32 x, u32 y) {
	u64 tmp = ((u64)(x)) * ((u64)(y));
	u32 hi = ((u32)(tmp >> 32U));
	u32 lo = ((u32)(tmp));
	return (multi_return_u32_u32){.arg0=hi, .arg1=lo};
}

multi_return_u64_u64 math__bits__mul_64(u64 x, u64 y) {
	u64 x0 = (x & _const_math__bits__mask32);
	u64 x1 = x >> 32U;
	u64 y0 = (y & _const_math__bits__mask32);
	u64 y1 = y >> 32U;
	u64 w0 = x0 * y0;
	u64 t = x1 * y0 + (w0 >> 32U);
	u64 w1 = (t & _const_math__bits__mask32);
	u64 w2 = t >> 32U;
	w1 += x0 * y1;
	u64 hi = x1 * y1 + w2 + (w1 >> 32U);
	u64 lo = x * y;
	return (multi_return_u64_u64){.arg0=hi, .arg1=lo};
}

multi_return_u32_u32 math__bits__div_32(u32 hi, u32 lo, u32 y) {
	if (y != 0U && y <= hi) {
		_v_panic(_const_math__bits__overflow_error);
		VUNREACHABLE();
	}
	u64 z = ((((u64)(hi)) << 32U) | ((u64)(lo)));
	u32 quo = ((u32)(z / ((u64)(y))));
	u32 rem = ((u32)(z % ((u64)(y))));
	return (multi_return_u32_u32){.arg0=quo, .arg1=rem};
}

multi_return_u64_u64 math__bits__div_64(u64 hi, u64 lo, u64 y1) {
	u64 y = y1;
	if (y == 0U) {
		_v_panic(_const_math__bits__overflow_error);
		VUNREACHABLE();
	}
	if (y <= hi) {
		_v_panic(_const_math__bits__overflow_error);
		VUNREACHABLE();
	}
	u32 s = ((u32)(math__bits__leading_zeros_64(y)));
	y <<= s;
	u64 yn1 = y >> 32U;
	u64 yn0 = (y & _const_math__bits__mask32);
	u64 un32 = ((hi << s) | (lo >> (64 - s)));
	u64 un10 = lo << s;
	u64 un1 = un10 >> 32U;
	u64 un0 = (un10 & _const_math__bits__mask32);
	u64 q1 = un32 / yn1;
	u64 rhat = un32 - q1 * yn1;
	for (;;) {
		if (!(q1 >= _const_math__bits__two32 || q1 * yn0 > _const_math__bits__two32 * rhat + un1)) break;
		q1--;
		rhat += yn1;
		if (rhat >= _const_math__bits__two32) {
			break;
		}
	}
	u64 un21 = un32 * _const_math__bits__two32 + un1 - q1 * y;
	u64 q0 = un21 / yn1;
	rhat = un21 - q0 * yn1;
	for (;;) {
		if (!(q0 >= _const_math__bits__two32 || q0 * yn0 > _const_math__bits__two32 * rhat + un0)) break;
		q0--;
		rhat += yn1;
		if (rhat >= _const_math__bits__two32) {
			break;
		}
	}
	return (multi_return_u64_u64){.arg0=q1 * _const_math__bits__two32 + q0, .arg1=(un21 * _const_math__bits__two32 + un0 - q0 * y) >> s};
}

u32 math__bits__rem_32(u32 hi, u32 lo, u32 y) {
	u32 _t1 = ((u32)((((((u64)(hi)) << 32U) | ((u64)(lo)))) % ((u64)(y))));
	return _t1;
}

u64 math__bits__rem_64(u64 hi, u64 lo, u64 y) {
	multi_return_u64_u64 mr_15611 = math__bits__div_64(hi % y, lo, y);
	u64 rem = mr_15611.arg1;
	u64 _t1 = rem;
	return _t1;
}

multi_return_f64_int math__bits__normalize(f64 x) {
	f64 smallest_normal = 2.2250738585072014e-308;
	if (((x > 0.0 ? (x) : (-x))) < smallest_normal) {
		return (multi_return_f64_int){.arg0=x * (((u64)(1U)) << ((u64)(52U))), .arg1=-52};
	}
	return (multi_return_f64_int){.arg0=x, .arg1=0};
}

VV_LOCAL_SYMBOL multi_return_u32_u32_u32 strconv__lsr96(u32 s2, u32 s1, u32 s0) {
	u32 r0 = ((u32)(0U));
	u32 r1 = ((u32)(0U));
	u32 r2 = ((u32)(0U));
	r0 = ((s0 >> 1U) | (((s1 & ((u32)(1U)))) << 31U));
	r1 = ((s1 >> 1U) | (((s2 & ((u32)(1U)))) << 31U));
	r2 = s2 >> 1U;
	return (multi_return_u32_u32_u32){.arg0=r2, .arg1=r1, .arg2=r0};
}

VV_LOCAL_SYMBOL multi_return_u32_u32_u32 strconv__lsl96(u32 s2, u32 s1, u32 s0) {
	u32 r0 = ((u32)(0U));
	u32 r1 = ((u32)(0U));
	u32 r2 = ((u32)(0U));
	r2 = ((s2 << 1U) | (((s1 & (((u32)(1U)) << 31U))) >> 31U));
	r1 = ((s1 << 1U) | (((s0 & (((u32)(1U)) << 31U))) >> 31U));
	r0 = s0 << 1U;
	return (multi_return_u32_u32_u32){.arg0=r2, .arg1=r1, .arg2=r0};
}

VV_LOCAL_SYMBOL multi_return_u32_u32_u32 strconv__add96(u32 s2, u32 s1, u32 s0, u32 d2, u32 d1, u32 d0) {
	u64 w = ((u64)(0U));
	u32 r0 = ((u32)(0U));
	u32 r1 = ((u32)(0U));
	u32 r2 = ((u32)(0U));
	w = ((u64)(s0)) + ((u64)(d0));
	r0 = ((u32)(w));
	w >>= 32U;
	w += ((u64)(s1)) + ((u64)(d1));
	r1 = ((u32)(w));
	w >>= 32U;
	w += ((u64)(s2)) + ((u64)(d2));
	r2 = ((u32)(w));
	return (multi_return_u32_u32_u32){.arg0=r2, .arg1=r1, .arg2=r0};
}

VV_LOCAL_SYMBOL multi_return_u32_u32_u32 strconv__sub96(u32 s2, u32 s1, u32 s0, u32 d2, u32 d1, u32 d0) {
	u64 w = ((u64)(0U));
	u32 r0 = ((u32)(0U));
	u32 r1 = ((u32)(0U));
	u32 r2 = ((u32)(0U));
	w = ((u64)(s0)) - ((u64)(d0));
	r0 = ((u32)(w));
	w >>= 32U;
	w += ((u64)(s1)) - ((u64)(d1));
	r1 = ((u32)(w));
	w >>= 32U;
	w += ((u64)(s2)) - ((u64)(d2));
	r2 = ((u32)(w));
	return (multi_return_u32_u32_u32){.arg0=r2, .arg1=r1, .arg2=r0};
}

VV_LOCAL_SYMBOL bool strconv__is_digit(byte x) {
	return (x >= _const_strconv__c_zero && x <= _const_strconv__c_nine) == true;
}

VV_LOCAL_SYMBOL bool strconv__is_space(byte x) {
	return x == '\t' || x == '\n' || x == '\v' || x == '\f' || x == '\r' || x == ' ';
}

VV_LOCAL_SYMBOL bool strconv__is_exp(byte x) {
	return (x == 'E' || x == 'e') == true;
}

VV_LOCAL_SYMBOL multi_return_int_strconv__PrepNumber strconv__parser(string s) {
	int digx = 0;
	int result = _const_strconv__parser_ok;
	bool expneg = false;
	int expexp = 0;
	int i = 0;
	strconv__PrepNumber pn = (strconv__PrepNumber){.negative = 0,.exponent = 0,.mantissa = 0,};
	for (;;) {
		if (!(i < s.len && byte_is_space(string_at(s, i)))) break;
		i++;
	}
	if (string_at(s, i) == '-') {
		pn.negative = true;
		i++;
	}
	if (string_at(s, i) == '+') {
		i++;
	}
	for (;;) {
		if (!(i < s.len && byte_is_digit(string_at(s, i)))) break;
		if (digx < _const_strconv__digits) {
			pn.mantissa *= 10U;
			pn.mantissa += ((u64)(string_at(s, i) - _const_strconv__c_zero));
			digx++;
		} else if (pn.exponent < 2147483647) {
			pn.exponent++;
		}
		i++;
	}
	if ((i < s.len) && (string_at(s, i) == '.')) {
		i++;
		for (;;) {
			if (!(i < s.len && byte_is_digit(string_at(s, i)))) break;
			if (digx < _const_strconv__digits) {
				pn.mantissa *= 10U;
				pn.mantissa += ((u64)(string_at(s, i) - _const_strconv__c_zero));
				pn.exponent--;
				digx++;
			}
			i++;
		}
	}
	if ((i < s.len) && ((string_at(s, i) == 'e') || (string_at(s, i) == 'E'))) {
		i++;
		if (i < s.len) {
			if (string_at(s, i) == _const_strconv__c_plus) {
				i++;
			} else if (string_at(s, i) == _const_strconv__c_minus) {
				expneg = true;
				i++;
			}
			for (;;) {
				if (!(i < s.len && byte_is_digit(string_at(s, i)))) break;
				if (expexp < 214748364) {
					expexp *= 10;
					expexp += ((int)(string_at(s, i) - _const_strconv__c_zero));
				}
				i++;
			}
		}
	}
	if (expneg) {
		expexp = -expexp;
	}
	pn.exponent += expexp;
	if (pn.mantissa == 0U) {
		if (pn.negative) {
			result = _const_strconv__parser_mzero;
		} else {
			result = _const_strconv__parser_pzero;
		}
	} else if (pn.exponent > 309) {
		if (pn.negative) {
			result = _const_strconv__parser_minf;
		} else {
			result = _const_strconv__parser_pinf;
		}
	} else if (pn.exponent < -328) {
		if (pn.negative) {
			result = _const_strconv__parser_mzero;
		} else {
			result = _const_strconv__parser_pzero;
		}
	}
	return (multi_return_int_strconv__PrepNumber){.arg0=result, .arg1=pn};
}

VV_LOCAL_SYMBOL u64 strconv__converter(strconv__PrepNumber* pn) {
	int binexp = 92;
	u32 s2 = ((u32)(0U));
	u32 s1 = ((u32)(0U));
	u32 s0 = ((u32)(0U));
	u32 q2 = ((u32)(0U));
	u32 q1 = ((u32)(0U));
	u32 q0 = ((u32)(0U));
	u32 r2 = ((u32)(0U));
	u32 r1 = ((u32)(0U));
	u32 r0 = ((u32)(0U));
	u32 mask28 = ((u32)(((u64)(0xFU)) << 28U));
	u64 result = ((u64)(0U));
	s0 = ((u32)((pn->mantissa & ((u64)(0x00000000FFFFFFFFU)))));
	s1 = ((u32)(pn->mantissa >> 32U));
	s2 = ((u32)(0U));
	for (;;) {
		if (!(pn->exponent > 0)) break;
		multi_return_u32_u32_u32 mr_5642 = strconv__lsl96(s2, s1, s0);
		q2 = mr_5642.arg0;
		q1 = mr_5642.arg1;
		q0 = mr_5642.arg2;
		multi_return_u32_u32_u32 mr_5688 = strconv__lsl96(q2, q1, q0);
		r2 = mr_5688.arg0;
		r1 = mr_5688.arg1;
		r0 = mr_5688.arg2;
		multi_return_u32_u32_u32 mr_5744 = strconv__lsl96(r2, r1, r0);
		s2 = mr_5744.arg0;
		s1 = mr_5744.arg1;
		s0 = mr_5744.arg2;
		multi_return_u32_u32_u32 mr_5800 = strconv__add96(s2, s1, s0, q2, q1, q0);
		s2 = mr_5800.arg0;
		s1 = mr_5800.arg1;
		s0 = mr_5800.arg2;
		pn->exponent--;
		for (;;) {
			if (!(((s2 & mask28)) != 0U)) break;
			multi_return_u32_u32_u32 mr_5923 = strconv__lsr96(s2, s1, s0);
			q2 = mr_5923.arg0;
			q1 = mr_5923.arg1;
			q0 = mr_5923.arg2;
			binexp++;
			s2 = q2;
			s1 = q1;
			s0 = q0;
		}
	}
	for (;;) {
		if (!(pn->exponent < 0)) break;
		for (;;) {
			if (!(!(((s2 & (((u32)(1U)) << 31U))) != 0U))) break;
			multi_return_u32_u32_u32 mr_6070 = strconv__lsl96(s2, s1, s0);
			q2 = mr_6070.arg0;
			q1 = mr_6070.arg1;
			q0 = mr_6070.arg2;
			binexp--;
			s2 = q2;
			s1 = q1;
			s0 = q0;
		}
		q2 = s2 / _const_strconv__c_ten;
		r1 = s2 % _const_strconv__c_ten;
		r2 = ((s1 >> 8U) | (r1 << 24U));
		q1 = r2 / _const_strconv__c_ten;
		r1 = r2 % _const_strconv__c_ten;
		r2 = (((((s1 & ((u32)(0xFFU)))) << 16U) | (s0 >> 16U)) | (r1 << 24U));
		r0 = r2 / _const_strconv__c_ten;
		r1 = r2 % _const_strconv__c_ten;
		q1 = ((q1 << 8U) | (((r0 & ((u32)(0x00FF0000U)))) >> 16U));
		q0 = r0 << 16U;
		r2 = (((s0 & ((u32)(0xFFFFU)))) | (r1 << 16U));
		q0 |= r2 / _const_strconv__c_ten;
		s2 = q2;
		s1 = q1;
		s0 = q0;
		pn->exponent++;
	}
	if (s2 != 0U || s1 != 0U || s0 != 0U) {
		for (;;) {
			if (!(((s2 & mask28)) == 0U)) break;
			multi_return_u32_u32_u32 mr_6805 = strconv__lsl96(s2, s1, s0);
			q2 = mr_6805.arg0;
			q1 = mr_6805.arg1;
			q0 = mr_6805.arg2;
			binexp--;
			s2 = q2;
			s1 = q1;
			s0 = q0;
		}
	}
	int nbit = 7;
	u32 check_round_bit = ((u32)(1U)) << ((u32)(nbit));
	u32 check_round_mask = ((u32)(0xFFFFFFFFU)) << ((u32)(nbit));
	if (((s1 & check_round_bit)) != 0U) {
		if (((s1 & ~check_round_mask)) != 0U) {
			multi_return_u32_u32_u32 mr_7887 = strconv__add96(s2, s1, s0, 0U, check_round_bit, 0U);
			s2 = mr_7887.arg0;
			s1 = mr_7887.arg1;
			s0 = mr_7887.arg2;
		} else {
			if (((s1 & (check_round_bit << ((u32)(1U))))) != 0U) {
				multi_return_u32_u32_u32 mr_8079 = strconv__add96(s2, s1, s0, 0U, check_round_bit, 0U);
				s2 = mr_8079.arg0;
				s1 = mr_8079.arg1;
				s0 = mr_8079.arg2;
			}
		}
		s1 = (s1 & check_round_mask);
		s0 = ((u32)(0U));
		if ((s2 & (mask28 << ((u32)(1U)))) != 0U) {
			multi_return_u32_u32_u32 mr_8283 = strconv__lsr96(s2, s1, s0);
			q2 = mr_8283.arg0;
			q1 = mr_8283.arg1;
			q0 = mr_8283.arg2;
			binexp--;
			s2 = q2;
			s1 = q1;
			s0 = q0;
		}
	}
	binexp += 1023;
	if (binexp > 2046) {
		if (pn->negative) {
			result = _const_strconv__double_minus_infinity;
		} else {
			result = _const_strconv__double_plus_infinity;
		}
	} else if (binexp < 1) {
		if (pn->negative) {
			result = _const_strconv__double_minus_zero;
		} else {
			result = _const_strconv__double_plus_zero;
		}
	} else if (s2 != 0U) {
		u64 q = ((u64)(0U));
		u64 binexs2 = ((u64)(binexp)) << 52U;
		q = (((((u64)((s2 & ~mask28))) << 24U) | ((((u64)(s1)) + ((u64)(128U))) >> 8U)) | binexs2);
		if (pn->negative) {
			q |= (((u64)(1U)) << 63U);
		}
		result = q;
	}
	return result;
}

f64 strconv__atof64(string s) {
	if (s.len == 0) {
		return 0;
	}
	strconv__PrepNumber pn = (strconv__PrepNumber){.negative = 0,.exponent = 0,.mantissa = 0,};
	int res_parsing = 0;
	strconv__Float64u res = (strconv__Float64u){0};
	multi_return_int_strconv__PrepNumber mr_9346 = strconv__parser(s);
	res_parsing = mr_9346.arg0;
	pn = mr_9346.arg1;

	if (res_parsing == (_const_strconv__parser_ok)) {
		res.u = strconv__converter((voidptr)&/*qq*/pn);
	}
	else if (res_parsing == (_const_strconv__parser_pzero)) {
		res.u = _const_strconv__double_plus_zero;
	}
	else if (res_parsing == (_const_strconv__parser_mzero)) {
		res.u = _const_strconv__double_minus_zero;
	}
	else if (res_parsing == (_const_strconv__parser_pinf)) {
		res.u = _const_strconv__double_plus_infinity;
	}
	else if (res_parsing == (_const_strconv__parser_minf)) {
		res.u = _const_strconv__double_minus_infinity;
	}
	else {
	};
	return res.f;
}

f64 strconv__atof_quick(string s) {
	strconv__Float64u f = (strconv__Float64u){0};
	f64 sign = ((f64)(1.0));
	int i = 0;
	for (;;) {
		if (!(i < s.len && string_at(s, i) == ' ')) break;
		i++;
	}
	if (i < s.len) {
		if (string_at(s, i) == '-') {
			sign = -1.0;
			i++;
		} else if (string_at(s, i) == '+') {
			i++;
		}
	}
	if (string_at(s, i) == 'i' && i + 2 < s.len && string_at(s, i + 1) == 'n' && string_at(s, i + 2) == 'f') {
		if (sign > 0.0) {
			f.u = _const_strconv__double_plus_infinity;
		} else {
			f.u = _const_strconv__double_minus_infinity;
		}
		return f.f;
	}
	for (;;) {
		if (!(i < s.len && string_at(s, i) == '0')) break;
		i++;
		if (i >= s.len) {
			if (sign > 0.0) {
				f.u = _const_strconv__double_plus_zero;
			} else {
				f.u = _const_strconv__double_minus_zero;
			}
			return f.f;
		}
	}
	for (;;) {
		if (!(i < s.len && (string_at(s, i) >= '0' && string_at(s, i) <= '9'))) break;
		f.f *= ((f64)(10.0));
		f.f += ((f64)(string_at(s, i) - '0'));
		i++;
	}
	if (i < s.len && string_at(s, i) == '.') {
		i++;
		f64 frac_mul = ((f64)(0.1));
		for (;;) {
			if (!(i < s.len && (string_at(s, i) >= '0' && string_at(s, i) <= '9'))) break;
			f.f += ((f64)(string_at(s, i) - '0')) * frac_mul;
			frac_mul *= ((f64)(0.1));
			i++;
		}
	}
	if (i < s.len && (string_at(s, i) == 'e' || string_at(s, i) == 'E')) {
		i++;
		int exp = 0;
		int exp_sign = 1;
		if (i < s.len) {
			if (string_at(s, i) == '-') {
				exp_sign = -1;
				i++;
			} else if (string_at(s, i) == '+') {
				i++;
			}
		}
		for (;;) {
			if (!(i < s.len && string_at(s, i) == '0')) break;
			i++;
		}
		for (;;) {
			if (!(i < s.len && (string_at(s, i) >= '0' && string_at(s, i) <= '9'))) break;
			exp *= 10;
			exp += ((int)(string_at(s, i) - '0'));
			i++;
		}
		if (exp_sign == 1) {
			if (exp > _const_strconv__pos_exp.len) {
				if (sign > 0) {
					f.u = _const_strconv__double_plus_infinity;
				} else {
					f.u = _const_strconv__double_minus_infinity;
				}
				return f.f;
			}
			strconv__Float64u tmp_mul = (strconv__Float64u){.u = (*(u64*)/*ee elem_typ */array_get(_const_strconv__pos_exp, exp)),};
			f.f = f.f * tmp_mul.f;
		} else {
			if (exp > _const_strconv__neg_exp.len) {
				if (sign > 0) {
					f.u = _const_strconv__double_plus_zero;
				} else {
					f.u = _const_strconv__double_minus_zero;
				}
				return f.f;
			}
			strconv__Float64u tmp_mul = (strconv__Float64u){.u = (*(u64*)/*ee elem_typ */array_get(_const_strconv__neg_exp, exp)),};
			f.f = f.f * tmp_mul.f;
		}
	}
	{ // Unsafe block
		f.f = f.f * sign;
		return f.f;
	}
	return 0;
}

byte strconv__byte_to_lower(byte c) {
	return (c | ('x' - 'X'));
}

Option_u64 strconv__common_parse_uint(string s, int _base, int _bit_size, bool error_on_non_digit, bool error_on_high_digit) {
	multi_return_u64_int mr_824 = strconv__common_parse_uint2(s, _base, _bit_size);
	u64 result = mr_824.arg0;
	int err = mr_824.arg1;
	if (err != 0 && (error_on_non_digit || error_on_high_digit)) {

		if (err == (-1)) {
			return (Option_u64){ .state=2, .err=_v_error( str_intp(3, _MOV((StrIntpData[]){{_SLIT("common_parse_uint: wrong base "), 0xfe07, {.d_i32 = _base}}, {_SLIT(" for "), 0xfe10, {.d_s = s}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		else if (err == (-2)) {
			return (Option_u64){ .state=2, .err=_v_error( str_intp(3, _MOV((StrIntpData[]){{_SLIT("common_parse_uint: wrong bit size "), 0xfe07, {.d_i32 = _bit_size}}, {_SLIT(" for "), 0xfe10, {.d_s = s}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		else if (err == (-3)) {
			return (Option_u64){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("common_parse_uint: integer overflow "), 0xfe10, {.d_s = s}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		else {
			return (Option_u64){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("common_parse_uint: syntax error "), 0xfe10, {.d_s = s}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		};
	}
	Option_u64 _t5;
	opt_ok(&(u64[]) { result }, (Option*)(&_t5), sizeof(u64));
	return _t5;
}

multi_return_u64_int strconv__common_parse_uint2(string s, int _base, int _bit_size) {
	int bit_size = _bit_size;
	int base = _base;
	if (s.len < 1 || !strconv__underscore_ok(s)) {
		return (multi_return_u64_int){.arg0=((u64)(0U)), .arg1=1};
	}
	bool base0 = base == 0;
	int start_index = 0;
	if (2 <= base && base <= 36) {
	} else if (base == 0) {
		base = 10;
		if (string_at(s, 0) == '0') {
			if (s.len >= 3 && strconv__byte_to_lower(string_at(s, 1)) == 'b') {
				base = 2;
				start_index += 2;
			} else if (s.len >= 3 && strconv__byte_to_lower(string_at(s, 1)) == 'o') {
				base = 8;
				start_index += 2;
			} else if (s.len >= 3 && strconv__byte_to_lower(string_at(s, 1)) == 'x') {
				base = 16;
				start_index += 2;
			} else if (s.len >= 2 && (string_at(s, 1) >= '0' && string_at(s, 1) <= '9')) {
				base = 10;
				start_index++;
			} else {
				base = 8;
				start_index++;
			}
		}
	} else {
		return (multi_return_u64_int){.arg0=((u64)(0U)), .arg1=-1};
	}
	if (bit_size == 0) {
		bit_size = _const_strconv__int_size;
	} else if (bit_size < 0 || bit_size > 64) {
		return (multi_return_u64_int){.arg0=((u64)(0U)), .arg1=-2};
	}
	u64 cutoff = _const_strconv__max_u64 / ((u64)(base)) + ((u64)(1U));
	u64 max_val = (bit_size == 64 ? (_const_strconv__max_u64) : ((((u64)(1U)) << ((u64)(bit_size))) - ((u64)(1U))));
	u64 n = ((u64)(0U));
	for (int i = start_index; i < s.len; ++i) {
		byte c = string_at(s, i);
		byte cl = strconv__byte_to_lower(c);
		byte d = ((byte)(0));
		if (c == '_' && base0) {
			continue;
		} else if ('0' <= c && c <= '9') {
			d = c - '0';
		} else if ('a' <= cl && cl <= 'z') {
			d = cl - 'a' + 10;
		} else {
			return (multi_return_u64_int){.arg0=n, .arg1=i + 1};
		}
		if (d >= ((byte)(base))) {
			return (multi_return_u64_int){.arg0=n, .arg1=i + 1};
		}
		if (n >= cutoff) {
			return (multi_return_u64_int){.arg0=max_val, .arg1=-3};
		}
		n *= ((u64)(base));
		u64 n1 = n + ((u64)(d));
		if (n1 < n || n1 > max_val) {
			return (multi_return_u64_int){.arg0=max_val, .arg1=-3};
		}
		n = n1;
	}
	return (multi_return_u64_int){.arg0=n, .arg1=0};
}

Option_u64 strconv__parse_uint(string s, int _base, int _bit_size) {
	return strconv__common_parse_uint(s, _base, _bit_size, true, true);
}

Option_i64 strconv__common_parse_int(string _s, int base, int _bit_size, bool error_on_non_digit, bool error_on_high_digit) {
	string s = _s;
	int bit_size = _bit_size;
	if (s.len < 1) {
		Option_i64 _t1;
		opt_ok(&(i64[]) { ((i64)(0)) }, (Option*)(&_t1), sizeof(i64));
		return _t1;
	}
	bool neg = false;
	if (string_at(s, 0) == '+') {
		s = string_substr(s, 1, s.len);
	} else if (string_at(s, 0) == '-') {
		neg = true;
		s = string_substr(s, 1, s.len);
	}
	Option_u64 _t2 = strconv__common_parse_uint(s, base, bit_size, error_on_non_digit, error_on_high_digit);
	if (_t2.state != 0) { /*or block*/ 
		Option_i64 _t3;
		memcpy(&_t3, &_t2, sizeof(Option));
		return _t3;
	}
	
 	u64 un =  (*(u64*)_t2.data);
	if (un == 0U) {
		Option_i64 _t4;
		opt_ok(&(i64[]) { ((i64)(0)) }, (Option*)(&_t4), sizeof(i64));
		return _t4;
	}
	if (bit_size == 0) {
		bit_size = _const_strconv__int_size;
	}
	u64 cutoff = ((u64)(1U)) << ((u64)(bit_size - 1));
	if (!neg && un >= cutoff) {
		Option_i64 _t5;
		opt_ok(&(i64[]) { ((i64)(cutoff - ((u64)(1U)))) }, (Option*)(&_t5), sizeof(i64));
		return _t5;
	}
	if (neg && un > cutoff) {
		Option_i64 _t6;
		opt_ok(&(i64[]) { -((i64)(cutoff)) }, (Option*)(&_t6), sizeof(i64));
		return _t6;
	}
	Option_i64 _t8; /* if prepend */
	if (neg) {
		opt_ok(&(i64[]) { -((i64)(un)) }, (Option*)(&_t8), sizeof(i64));
	} else {
		opt_ok(&(i64[]) { ((i64)(un)) }, (Option*)(&_t8), sizeof(i64));
	}
	return  _t8;
}

Option_i64 strconv__parse_int(string _s, int base, int _bit_size) {
	return strconv__common_parse_int(_s, base, _bit_size, true, true);
}

Option_int strconv__atoi(string s) {
	if ((s).len == 0) {
		return (Option_int){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("strconv.atoi: parsing \""), 0xfe10, {.d_s = s}}, {_SLIT("\": invalid syntax "), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if ((_const_strconv__int_size == 32 && (0 < s.len && s.len < 10)) || (_const_strconv__int_size == 64 && (0 < s.len && s.len < 19))) {
		int start_idx = 0;
		if (string_at(s, 0) == '-' || string_at(s, 0) == '+') {
			start_idx++;
			if (s.len - start_idx < 1) {
				return (Option_int){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("strconv.atoi: parsing \""), 0xfe10, {.d_s = s}}, {_SLIT("\": invalid syntax "), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
		}
		int n = 0;
		for (int i = start_idx; i < s.len; ++i) {
			rune ch = string_at(s, i) - '0';
			if (ch > 9) {
				return (Option_int){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("strconv.atoi: parsing \""), 0xfe10, {.d_s = s}}, {_SLIT("\": invalid syntax "), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			n = n * 10 + ((int)(ch));
		}
		Option_int _t5; /* if prepend */
		if (string_at(s, 0) == '-') {
			opt_ok(&(int[]) { -n }, (Option*)(&_t5), sizeof(int));
		} else {
			opt_ok(&(int[]) { n }, (Option*)(&_t5), sizeof(int));
		}
		return  _t5;
	}
	Option_i64 _t6 = strconv__parse_int(s, 10, 0);
	if (_t6.state != 0) { /*or block*/ 
		Option_int _t7;
		memcpy(&_t7, &_t6, sizeof(Option));
		return _t7;
	}
	
 	i64 int64 =  (*(i64*)_t6.data);
	Option_int _t8;
	opt_ok(&(int[]) { ((int)(int64)) }, (Option*)(&_t8), sizeof(int));
	return _t8;
}

VV_LOCAL_SYMBOL bool strconv__underscore_ok(string s) {
	rune saw = '^';
	int i = 0;
	if (s.len >= 1 && (string_at(s, 0) == '-' || string_at(s, 0) == '+')) {
		i++;
	}
	bool hex = false;
	if (s.len - i >= 2 && string_at(s, i) == '0' && (strconv__byte_to_lower(string_at(s, i + 1)) == 'b' || strconv__byte_to_lower(string_at(s, i + 1)) == 'o' || strconv__byte_to_lower(string_at(s, i + 1)) == 'x')) {
		saw = '0';
		hex = strconv__byte_to_lower(string_at(s, i + 1)) == 'x';
		i += 2;
	}
	for (; i < s.len; i++) {
		if (('0' <= string_at(s, i) && string_at(s, i) <= '9') || (hex && 'a' <= strconv__byte_to_lower(string_at(s, i)) && strconv__byte_to_lower(string_at(s, i)) <= 'f')) {
			saw = '0';
			continue;
		}
		if (string_at(s, i) == '_') {
			if (saw != '0') {
				return false;
			}
			saw = '_';
			continue;
		}
		if (saw == '_') {
			return false;
		}
		saw = '!';
	}
	return saw != '_';
}

// Attr: [direct_array_access]
string strconv__Dec32_get_string_32(strconv__Dec32 d, bool neg, int i_n_digit, int i_pad_digit) {
	int n_digit = i_n_digit + 1;
	int pad_digit = i_pad_digit + 1;
	u32 out = d.m;
	int out_len = strconv__dec_digits(out);
	int out_len_original = out_len;
	int fw_zeros = 0;
	if (pad_digit > out_len) {
		fw_zeros = pad_digit - out_len;
	}
	Array_byte buf = __new_array_with_default(((int)(out_len + 5 + 1 + 1)), 0, sizeof(byte), 0);
	int i = 0;
	if (neg) {
		if (buf.data != 0) {
			((byte*)buf.data)[i] = '-';
		}
		i++;
	}
	int disp = 0;
	if (out_len <= 1) {
		disp = 1;
	}
	if (n_digit < out_len) {
		out += ((u32*)_const_strconv__ten_pow_table_32.data)[out_len - n_digit - 1] * 5U;
		out /= ((u32*)_const_strconv__ten_pow_table_32.data)[out_len - n_digit];
		out_len = n_digit;
	}
	int y = i + out_len;
	int x = 0;
	for (;;) {
		if (!(x < (out_len - disp - 1))) break;
		((byte*)buf.data)[y - x] = '0' + ((byte)(out % 10U));
		out /= 10U;
		i++;
		x++;
	}
	if (i_n_digit == 0) {
		{ // Unsafe block
			((byte*)buf.data)[i] = 0;
			return tos(((byte*)(&((byte*)buf.data)[0])), i);
		}
	}
	if (out_len >= 1) {
		((byte*)buf.data)[y - x] = '.';
		x++;
		i++;
	}
	if (y - x >= 0) {
		((byte*)buf.data)[y - x] = '0' + ((byte)(out % 10U));
		i++;
	}
	for (;;) {
		if (!(fw_zeros > 0)) break;
		((byte*)buf.data)[i] = '0';
		i++;
		fw_zeros--;
	}
	((byte*)buf.data)[i] = 'e';
	i++;
	int exp = d.e + out_len_original - 1;
	if (exp < 0) {
		((byte*)buf.data)[i] = '-';
		i++;
		exp = -exp;
	} else {
		((byte*)buf.data)[i] = '+';
		i++;
	}
	int d1 = exp % 10;
	int d0 = exp / 10;
	((byte*)buf.data)[i] = '0' + ((byte)(d0));
	i++;
	((byte*)buf.data)[i] = '0' + ((byte)(d1));
	i++;
	((byte*)buf.data)[i] = 0;
	return tos(((byte*)(&((byte*)buf.data)[0])), i);
}

VV_LOCAL_SYMBOL multi_return_strconv__Dec32_bool strconv__f32_to_decimal_exact_int(u32 i_mant, u32 exp) {
	strconv__Dec32 d = (strconv__Dec32){.m = 0,.e = 0,};
	u32 e = exp - _const_strconv__bias32;
	if (e > _const_strconv__mantbits32) {
		return (multi_return_strconv__Dec32_bool){.arg0=d, .arg1=false};
	}
	u32 shift = _const_strconv__mantbits32 - e;
	u32 mant = (i_mant | 0x00800000U);
	d.m = mant >> shift;
	if ((d.m << shift) != mant) {
		return (multi_return_strconv__Dec32_bool){.arg0=d, .arg1=false};
	}
	for (;;) {
		if (!((d.m % 10U) == 0U)) break;
		d.m /= 10U;
		d.e++;
	}
	return (multi_return_strconv__Dec32_bool){.arg0=d, .arg1=true};
}

VV_LOCAL_SYMBOL strconv__Dec32 strconv__f32_to_decimal(u32 mant, u32 exp) {
	int e2 = 0;
	u32 m2 = ((u32)(0U));
	if (exp == 0U) {
		e2 = 1 - _const_strconv__bias32 - ((int)(_const_strconv__mantbits32)) - 2;
		m2 = mant;
	} else {
		e2 = ((int)(exp)) - _const_strconv__bias32 - ((int)(_const_strconv__mantbits32)) - 2;
		m2 = ((((u32)(1U)) << _const_strconv__mantbits32) | mant);
	}
	bool even = ((m2 & 1U)) == 0U;
	bool accept_bounds = even;
	u32 mv = ((u32)(4 * m2));
	u32 mp = ((u32)(4 * m2 + 2U));
	u32 mm_shift = strconv__bool_to_u32(mant != 0U || exp <= 1U);
	u32 mm = ((u32)(4 * m2 - 1U - mm_shift));
	u32 vr = ((u32)(0U));
	u32 vp = ((u32)(0U));
	u32 vm = ((u32)(0U));
	int e10 = 0;
	bool vm_is_trailing_zeros = false;
	bool vr_is_trailing_zeros = false;
	byte last_removed_digit = ((byte)(0));
	if (e2 >= 0) {
		u32 q = strconv__log10_pow2(e2);
		e10 = ((int)(q));
		int k = _const_strconv__pow5_inv_num_bits_32 + strconv__pow5_bits(((int)(q))) - 1;
		int i = -e2 + ((int)(q)) + k;
		vr = strconv__mul_pow5_invdiv_pow2(mv, q, i);
		vp = strconv__mul_pow5_invdiv_pow2(mp, q, i);
		vm = strconv__mul_pow5_invdiv_pow2(mm, q, i);
		if (q != 0U && (vp - 1U) / 10U <= vm / 10U) {
			int l = _const_strconv__pow5_inv_num_bits_32 + strconv__pow5_bits(((int)(q - 1U))) - 1;
			last_removed_digit = ((byte)(strconv__mul_pow5_invdiv_pow2(mv, q - 1U, -e2 + ((int)(q - 1U)) + l) % 10U));
		}
		if (q <= 9U) {
			if (mv % 5U == 0U) {
				vr_is_trailing_zeros = strconv__multiple_of_power_of_five_32(mv, q);
			} else if (accept_bounds) {
				vm_is_trailing_zeros = strconv__multiple_of_power_of_five_32(mm, q);
			} else if (strconv__multiple_of_power_of_five_32(mp, q)) {
				vp--;
			}
		}
	} else {
		u32 q = strconv__log10_pow5(-e2);
		e10 = ((int)(q)) + e2;
		int i = -e2 - ((int)(q));
		int k = strconv__pow5_bits(i) - _const_strconv__pow5_num_bits_32;
		int j = ((int)(q)) - k;
		vr = strconv__mul_pow5_div_pow2(mv, ((u32)(i)), j);
		vp = strconv__mul_pow5_div_pow2(mp, ((u32)(i)), j);
		vm = strconv__mul_pow5_div_pow2(mm, ((u32)(i)), j);
		if (q != 0U && ((vp - 1U) / 10U) <= vm / 10U) {
			j = ((int)(q)) - 1 - (strconv__pow5_bits(i + 1) - _const_strconv__pow5_num_bits_32);
			last_removed_digit = ((byte)(strconv__mul_pow5_div_pow2(mv, ((u32)(i + 1)), j) % 10U));
		}
		if (q <= 1U) {
			vr_is_trailing_zeros = true;
			if (accept_bounds) {
				vm_is_trailing_zeros = mm_shift == 1U;
			} else {
				vp--;
			}
		} else if (q < 31U) {
			vr_is_trailing_zeros = strconv__multiple_of_power_of_two_32(mv, q - 1U);
		}
	}
	int removed = 0;
	u32 out = ((u32)(0U));
	if (vm_is_trailing_zeros || vr_is_trailing_zeros) {
		for (;;) {
			if (!(vp / 10U > vm / 10U)) break;
			vm_is_trailing_zeros = vm_is_trailing_zeros && (vm % 10U) == 0U;
			vr_is_trailing_zeros = vr_is_trailing_zeros && (last_removed_digit == 0);
			last_removed_digit = ((byte)(vr % 10U));
			vr /= 10U;
			vp /= 10U;
			vm /= 10U;
			removed++;
		}
		if (vm_is_trailing_zeros) {
			for (;;) {
				if (!(vm % 10U == 0U)) break;
				vr_is_trailing_zeros = vr_is_trailing_zeros && (last_removed_digit == 0);
				last_removed_digit = ((byte)(vr % 10U));
				vr /= 10U;
				vp /= 10U;
				vm /= 10U;
				removed++;
			}
		}
		if (vr_is_trailing_zeros && (last_removed_digit == 5) && (vr % 2U) == 0U) {
			last_removed_digit = 4;
		}
		out = vr;
		if ((vr == vm && (!accept_bounds || !vm_is_trailing_zeros)) || last_removed_digit >= 5) {
			out++;
		}
	} else {
		for (;;) {
			if (!(vp / 10U > vm / 10U)) break;
			last_removed_digit = ((byte)(vr % 10U));
			vr /= 10U;
			vp /= 10U;
			vm /= 10U;
			removed++;
		}
		out = vr + strconv__bool_to_u32(vr == vm || last_removed_digit >= 5);
	}
	return (strconv__Dec32){.m = out,.e = e10 + removed,};
}

string strconv__f32_to_str(f32 f, int n_digit) {
	strconv__Uf32 u1 = (strconv__Uf32){0};
	u1.f = f;
	u32 u = u1.u;
	bool neg = (u >> (_const_strconv__mantbits32 + _const_strconv__expbits32)) != 0U;
	u32 mant = (u & ((((u32)(1U)) << _const_strconv__mantbits32) - ((u32)(1U))));
	u32 exp = ((u >> _const_strconv__mantbits32) & ((((u32)(1U)) << _const_strconv__expbits32) - ((u32)(1U))));
	if ((exp == _const_strconv__maxexp32) || (exp == 0U && mant == 0U)) {
		return strconv__get_string_special(neg, exp == 0U, mant == 0U);
	}
	multi_return_strconv__Dec32_bool mr_8773 = strconv__f32_to_decimal_exact_int(mant, exp);
	strconv__Dec32 d = mr_8773.arg0;
	bool ok = mr_8773.arg1;
	if (!ok) {
		d = strconv__f32_to_decimal(mant, exp);
	}
	return strconv__Dec32_get_string_32(d, neg, n_digit, 0);
}

string strconv__f32_to_str_pad(f32 f, int n_digit) {
	strconv__Uf32 u1 = (strconv__Uf32){0};
	u1.f = f;
	u32 u = u1.u;
	bool neg = (u >> (_const_strconv__mantbits32 + _const_strconv__expbits32)) != 0U;
	u32 mant = (u & ((((u32)(1U)) << _const_strconv__mantbits32) - ((u32)(1U))));
	u32 exp = ((u >> _const_strconv__mantbits32) & ((((u32)(1U)) << _const_strconv__expbits32) - ((u32)(1U))));
	if ((exp == _const_strconv__maxexp32) || (exp == 0U && mant == 0U)) {
		return strconv__get_string_special(neg, exp == 0U, mant == 0U);
	}
	multi_return_strconv__Dec32_bool mr_9547 = strconv__f32_to_decimal_exact_int(mant, exp);
	strconv__Dec32 d = mr_9547.arg0;
	bool ok = mr_9547.arg1;
	if (!ok) {
		d = strconv__f32_to_decimal(mant, exp);
	}
	return strconv__Dec32_get_string_32(d, neg, n_digit, n_digit);
}

// Attr: [direct_array_access]
VV_LOCAL_SYMBOL string strconv__Dec64_get_string_64(strconv__Dec64 d, bool neg, int i_n_digit, int i_pad_digit) {
	int n_digit = i_n_digit + 1;
	int pad_digit = i_pad_digit + 1;
	u64 out = d.m;
	int d_exp = d.e;
	int out_len = strconv__dec_digits(out);
	int out_len_original = out_len;
	int fw_zeros = 0;
	if (pad_digit > out_len) {
		fw_zeros = pad_digit - out_len;
	}
	Array_byte buf = __new_array_with_default((out_len + 6 + 1 + 1 + fw_zeros), 0, sizeof(byte), 0);
	int i = 0;
	if (neg) {
		((byte*)buf.data)[i] = '-';
		i++;
	}
	int disp = 0;
	if (out_len <= 1) {
		disp = 1;
	}
	if (n_digit < out_len) {
		out += ((u64*)_const_strconv__ten_pow_table_64.data)[out_len - n_digit - 1] * 5U;
		out /= ((u64*)_const_strconv__ten_pow_table_64.data)[out_len - n_digit];
		if (d.m / ((u64*)_const_strconv__ten_pow_table_64.data)[out_len - n_digit] < out) {
			d_exp++;
			n_digit++;
		}
		out_len = n_digit;
	}
	int y = i + out_len;
	int x = 0;
	for (;;) {
		if (!(x < (out_len - disp - 1))) break;
		((byte*)buf.data)[y - x] = '0' + ((byte)(out % 10U));
		out /= 10U;
		i++;
		x++;
	}
	if (i_n_digit == 0) {
		{ // Unsafe block
			((byte*)buf.data)[i] = 0;
			return tos(((byte*)(&((byte*)buf.data)[0])), i);
		}
	}
	if (out_len >= 1) {
		((byte*)buf.data)[y - x] = '.';
		x++;
		i++;
	}
	if (y - x >= 0) {
		((byte*)buf.data)[y - x] = '0' + ((byte)(out % 10U));
		i++;
	}
	for (;;) {
		if (!(fw_zeros > 0)) break;
		((byte*)buf.data)[i] = '0';
		i++;
		fw_zeros--;
	}
	((byte*)buf.data)[i] = 'e';
	i++;
	int exp = d_exp + out_len_original - 1;
	if (exp < 0) {
		((byte*)buf.data)[i] = '-';
		i++;
		exp = -exp;
	} else {
		((byte*)buf.data)[i] = '+';
		i++;
	}
	int d2 = exp % 10;
	exp /= 10;
	int d1 = exp % 10;
	int d0 = exp / 10;
	if (d0 > 0) {
		((byte*)buf.data)[i] = '0' + ((byte)(d0));
		i++;
	}
	((byte*)buf.data)[i] = '0' + ((byte)(d1));
	i++;
	((byte*)buf.data)[i] = '0' + ((byte)(d2));
	i++;
	((byte*)buf.data)[i] = 0;
	return tos(((byte*)(&((byte*)buf.data)[0])), i);
}

VV_LOCAL_SYMBOL multi_return_strconv__Dec64_bool strconv__f64_to_decimal_exact_int(u64 i_mant, u64 exp) {
	strconv__Dec64 d = (strconv__Dec64){.m = 0,.e = 0,};
	u64 e = exp - _const_strconv__bias64;
	if (e > _const_strconv__mantbits64) {
		return (multi_return_strconv__Dec64_bool){.arg0=d, .arg1=false};
	}
	u64 shift = _const_strconv__mantbits64 - e;
	u64 mant = (i_mant | ((u64)(0x0010000000000000U)));
	d.m = mant >> shift;
	if ((d.m << shift) != mant) {
		return (multi_return_strconv__Dec64_bool){.arg0=d, .arg1=false};
	}
	for (;;) {
		if (!((d.m % 10U) == 0U)) break;
		d.m /= 10U;
		d.e++;
	}
	return (multi_return_strconv__Dec64_bool){.arg0=d, .arg1=true};
}

VV_LOCAL_SYMBOL strconv__Dec64 strconv__f64_to_decimal(u64 mant, u64 exp) {
	int e2 = 0;
	u64 m2 = ((u64)(0U));
	if (exp == 0U) {
		e2 = 1 - _const_strconv__bias64 - ((int)(_const_strconv__mantbits64)) - 2;
		m2 = mant;
	} else {
		e2 = ((int)(exp)) - _const_strconv__bias64 - ((int)(_const_strconv__mantbits64)) - 2;
		m2 = ((((u64)(1U)) << _const_strconv__mantbits64) | mant);
	}
	bool even = ((m2 & 1U)) == 0U;
	bool accept_bounds = even;
	u64 mv = ((u64)(4 * m2));
	u64 mm_shift = strconv__bool_to_u64(mant != 0U || exp <= 1U);
	u64 vr = ((u64)(0U));
	u64 vp = ((u64)(0U));
	u64 vm = ((u64)(0U));
	int e10 = 0;
	bool vm_is_trailing_zeros = false;
	bool vr_is_trailing_zeros = false;
	if (e2 >= 0) {
		u32 q = strconv__log10_pow2(e2) - strconv__bool_to_u32(e2 > 3);
		e10 = ((int)(q));
		int k = _const_strconv__pow5_inv_num_bits_64 + strconv__pow5_bits(((int)(q))) - 1;
		int i = -e2 + ((int)(q)) + k;
		strconv__Uint128 mul = (*(strconv__Uint128*)/*ee elem_typ */array_get(_const_strconv__pow5_inv_split_64, q));
		vr = strconv__mul_shift_64(((u64)(4U)) * m2, mul, i);
		vp = strconv__mul_shift_64(((u64)(4U)) * m2 + ((u64)(2U)), mul, i);
		vm = strconv__mul_shift_64(((u64)(4U)) * m2 - ((u64)(1U)) - mm_shift, mul, i);
		if (q <= 21U) {
			if (mv % 5U == 0U) {
				vr_is_trailing_zeros = strconv__multiple_of_power_of_five_64(mv, q);
			} else if (accept_bounds) {
				vm_is_trailing_zeros = strconv__multiple_of_power_of_five_64(mv - 1U - mm_shift, q);
			} else if (strconv__multiple_of_power_of_five_64(mv + 2U, q)) {
				vp--;
			}
		}
	} else {
		u32 q = strconv__log10_pow5(-e2) - strconv__bool_to_u32(-e2 > 1);
		e10 = ((int)(q)) + e2;
		int i = -e2 - ((int)(q));
		int k = strconv__pow5_bits(i) - _const_strconv__pow5_num_bits_64;
		int j = ((int)(q)) - k;
		strconv__Uint128 mul = (*(strconv__Uint128*)/*ee elem_typ */array_get(_const_strconv__pow5_split_64, i));
		vr = strconv__mul_shift_64(((u64)(4U)) * m2, mul, j);
		vp = strconv__mul_shift_64(((u64)(4U)) * m2 + ((u64)(2U)), mul, j);
		vm = strconv__mul_shift_64(((u64)(4U)) * m2 - ((u64)(1U)) - mm_shift, mul, j);
		if (q <= 1U) {
			vr_is_trailing_zeros = true;
			if (accept_bounds) {
				vm_is_trailing_zeros = (mm_shift == 1U);
			} else {
				vp--;
			}
		} else if (q < 63U) {
			vr_is_trailing_zeros = strconv__multiple_of_power_of_two_64(mv, q - 1U);
		}
	}
	int removed = 0;
	byte last_removed_digit = ((byte)(0));
	u64 out = ((u64)(0U));
	if (vm_is_trailing_zeros || vr_is_trailing_zeros) {
		for (;;) {
			u64 vp_div_10 = vp / 10U;
			u64 vm_div_10 = vm / 10U;
			if (vp_div_10 <= vm_div_10) {
				break;
			}
			u64 vm_mod_10 = vm % 10U;
			u64 vr_div_10 = vr / 10U;
			u64 vr_mod_10 = vr % 10U;
			vm_is_trailing_zeros = vm_is_trailing_zeros && vm_mod_10 == 0U;
			vr_is_trailing_zeros = vr_is_trailing_zeros && (last_removed_digit == 0);
			last_removed_digit = ((byte)(vr_mod_10));
			vr = vr_div_10;
			vp = vp_div_10;
			vm = vm_div_10;
			removed++;
		}
		if (vm_is_trailing_zeros) {
			for (;;) {
				u64 vm_div_10 = vm / 10U;
				u64 vm_mod_10 = vm % 10U;
				if (vm_mod_10 != 0U) {
					break;
				}
				u64 vp_div_10 = vp / 10U;
				u64 vr_div_10 = vr / 10U;
				u64 vr_mod_10 = vr % 10U;
				vr_is_trailing_zeros = vr_is_trailing_zeros && (last_removed_digit == 0);
				last_removed_digit = ((byte)(vr_mod_10));
				vr = vr_div_10;
				vp = vp_div_10;
				vm = vm_div_10;
				removed++;
			}
		}
		if (vr_is_trailing_zeros && (last_removed_digit == 5) && (vr % 2U) == 0U) {
			last_removed_digit = 4;
		}
		out = vr;
		if ((vr == vm && (!accept_bounds || !vm_is_trailing_zeros)) || last_removed_digit >= 5) {
			out++;
		}
	} else {
		bool round_up = false;
		for (;;) {
			if (!(vp / 100U > vm / 100U)) break;
			round_up = (vr % 100U) >= 50U;
			vr /= 100U;
			vp /= 100U;
			vm /= 100U;
			removed += 2;
		}
		for (;;) {
			if (!(vp / 10U > vm / 10U)) break;
			round_up = (vr % 10U) >= 5U;
			vr /= 10U;
			vp /= 10U;
			vm /= 10U;
			removed++;
		}
		out = vr + strconv__bool_to_u64(vr == vm || round_up);
	}
	return (strconv__Dec64){.m = out,.e = e10 + removed,};
}

string strconv__f64_to_str(f64 f, int n_digit) {
	strconv__Uf64 u1 = (strconv__Uf64){0};
	u1.f = f;
	u64 u = u1.u;
	bool neg = (u >> (_const_strconv__mantbits64 + _const_strconv__expbits64)) != 0U;
	u64 mant = (u & ((((u64)(1U)) << _const_strconv__mantbits64) - ((u64)(1U))));
	u64 exp = ((u >> _const_strconv__mantbits64) & ((((u64)(1U)) << _const_strconv__expbits64) - ((u64)(1U))));
	if ((exp == _const_strconv__maxexp64) || (exp == 0U && mant == 0U)) {
		return strconv__get_string_special(neg, exp == 0U, mant == 0U);
	}
	multi_return_strconv__Dec64_bool mr_9326 = strconv__f64_to_decimal_exact_int(mant, exp);
	strconv__Dec64 d = mr_9326.arg0;
	bool ok = mr_9326.arg1;
	if (!ok) {
		d = strconv__f64_to_decimal(mant, exp);
	}
	return strconv__Dec64_get_string_64(d, neg, n_digit, 0);
}

string strconv__f64_to_str_pad(f64 f, int n_digit) {
	strconv__Uf64 u1 = (strconv__Uf64){0};
	u1.f = f;
	u64 u = u1.u;
	bool neg = (u >> (_const_strconv__mantbits64 + _const_strconv__expbits64)) != 0U;
	u64 mant = (u & ((((u64)(1U)) << _const_strconv__mantbits64) - ((u64)(1U))));
	u64 exp = ((u >> _const_strconv__mantbits64) & ((((u64)(1U)) << _const_strconv__expbits64) - ((u64)(1U))));
	if ((exp == _const_strconv__maxexp64) || (exp == 0U && mant == 0U)) {
		return strconv__get_string_special(neg, exp == 0U, mant == 0U);
	}
	multi_return_strconv__Dec64_bool mr_10079 = strconv__f64_to_decimal_exact_int(mant, exp);
	strconv__Dec64 d = mr_10079.arg0;
	bool ok = mr_10079.arg1;
	if (!ok) {
		d = strconv__f64_to_decimal(mant, exp);
	}
	return strconv__Dec64_get_string_64(d, neg, n_digit, n_digit);
}

string strconv__format_str(string s, strconv__BF_param p) {
bool strconv__format_str_defer_0 = false;
strings__Builder res;
	if (p.len0 <= 0) {
		return string_clone(s);
	}
	int dif = p.len0 - utf8_str_visible_length(s);
	if (dif <= 0) {
		return string_clone(s);
	}
	res = strings__new_builder(s.len + dif);
	strconv__format_str_defer_0 = true;
	if (p.allign == strconv__Align_text__right) {
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_b(&res, p.pad_ch);
		}
	}
	strings__Builder_write_string(&res, s);
	if (p.allign == strconv__Align_text__left) {
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_b(&res, p.pad_ch);
		}
	}
	string _t3 = strings__Builder_str(&res);
	// Defer begin
	if (strconv__format_str_defer_0) {
		strings__Builder_free(&res);
	}
	// Defer end
	return _t3;
}

void strconv__format_str_sb(string s, strconv__BF_param p, strings__Builder* sb) {
	if (p.len0 <= 0) {
		strings__Builder_write_string(sb, s);
		return;
	}
	int dif = p.len0 - utf8_str_visible_length(s);
	if (dif <= 0) {
		strings__Builder_write_string(sb, s);
		return;
	}
	if (p.allign == strconv__Align_text__right) {
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_b(sb, p.pad_ch);
		}
	}
	strings__Builder_write_string(sb, s);
	if (p.allign == strconv__Align_text__left) {
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_b(sb, p.pad_ch);
		}
	}
}

// Attr: [direct_array_access]
void strconv__format_dec_sb(u64 d, strconv__BF_param p, strings__Builder* res) {
	int n_char = strconv__dec_digits(d);
	int sign_len = (!p.positive || p.sign_flag ? (1) : (0));
	int number_len = sign_len + n_char;
	int dif = p.len0 - number_len;
	bool sign_written = false;
	if (p.allign == strconv__Align_text__right) {
		if (p.pad_ch == '0') {
			if (p.positive) {
				if (p.sign_flag) {
					strings__Builder_write_b(res, '+');
					sign_written = true;
				}
			} else {
				strings__Builder_write_b(res, '-');
				sign_written = true;
			}
		}
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_b(res, p.pad_ch);
		}
	}
	if (!sign_written) {
		if (p.positive) {
			if (p.sign_flag) {
				strings__Builder_write_b(res, '+');
			}
		} else {
			strings__Builder_write_b(res, '-');
		}
	}
	Array_fixed_byte_32 buf = {0};
	int i = 20;
	u64 n = d;
	u64 d_i = ((u64)(0U));
	if (n > 0U) {
		for (;;) {
			if (!(n > 0U)) break;
			u64 n1 = n / 100U;
			d_i = (n - (n1 * 100U)) << 1U;
			n = n1;
			{ // Unsafe block
				buf[i] = _const_strconv__digit_pairs.str[d_i];
			}
			i--;
			d_i++;
			{ // Unsafe block
				buf[i] = _const_strconv__digit_pairs.str[d_i];
			}
			i--;
		}
		i++;
		if (d_i < 20U) {
			i++;
		}
		strings__Builder_write_ptr(res, &buf[i], n_char);
	} else {
		strings__Builder_write_b(res, '0');
	}
	if (p.allign == strconv__Align_text__left) {
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_b(res, p.pad_ch);
		}
	}
	return;
}

// Attr: [direct_array_access]
// Attr: [manualfree]
string strconv__f64_to_str_lnd1(f64 f, int dec_digit) {
	{ // Unsafe block
		string s = strconv__f64_to_str(f + ((f64*)_const_strconv__dec_round.data)[dec_digit], 18);
		if (s.len > 2 && (s.str[ 0] == 'n' || s.str[ 1] == 'i')) {
			return s;
		}
		bool m_sgn_flag = false;
		int sgn = 1;
		Array_fixed_byte_26 b = {0};
		int d_pos = 1;
		int i = 0;
		int i1 = 0;
		int exp = 0;
		int exp_sgn = 1;
		int dot_res_sp = -1;
		for (int _t2 = 0; _t2 < s.len; ++_t2) {
			byte c = s.str[_t2];
			if (c == '-') {
				sgn = -1;
				i++;
			} else if (c == '+') {
				sgn = 1;
				i++;
			} else if (c >= '0' && c <= '9') {
				b[i1] = c;
				i1++;
				i++;
			} else if (c == '.') {
				if (sgn > 0) {
					d_pos = i;
				} else {
					d_pos = i - 1;
				}
				i++;
			} else if (c == 'e') {
				i++;
				break;
			} else {
				string_free(&s);
				return _SLIT("[Float conversion error!!]");
			}
		}
		b[i1] = 0;
		if (s.str[ i] == '-') {
			exp_sgn = -1;
			i++;
		} else if (s.str[ i] == '+') {
			exp_sgn = 1;
			i++;
		}
		int c = i;
		for (;;) {
			if (!(c < s.len)) break;
			exp = exp * 10 + ((int)(s.str[ c] - '0'));
			c++;
		}
		Array_byte res = __new_array_with_default(exp + 32, 0, sizeof(byte), &(byte[]){0});
		int r_i = 0;
		string_free(&s);
		if (sgn == 1) {
			if (m_sgn_flag) {
				((byte*)res.data)[r_i] = '+';
				r_i++;
			}
		} else {
			((byte*)res.data)[r_i] = '-';
			r_i++;
		}
		i = 0;
		if (exp_sgn >= 0) {
			for (;;) {
				if (!(b[i] != 0)) break;
				((byte*)res.data)[r_i] = b[i];
				r_i++;
				i++;
				if (i >= d_pos && exp >= 0) {
					if (exp == 0) {
						dot_res_sp = r_i;
						((byte*)res.data)[r_i] = '.';
						r_i++;
					}
					exp--;
				}
			}
			for (;;) {
				if (!(exp >= 0)) break;
				((byte*)res.data)[r_i] = '0';
				r_i++;
				exp--;
			}
		} else {
			bool dot_p = true;
			for (;;) {
				if (!(exp > 0)) break;
				((byte*)res.data)[r_i] = '0';
				r_i++;
				exp--;
				if (dot_p) {
					dot_res_sp = r_i;
					((byte*)res.data)[r_i] = '.';
					r_i++;
					dot_p = false;
				}
			}
			for (;;) {
				if (!(b[i] != 0)) break;
				((byte*)res.data)[r_i] = b[i];
				r_i++;
				i++;
			}
		}
		if (dec_digit <= 0) {
			string tmp_res = string_clone(tos(res.data, dot_res_sp));
			array_free(&res);
			return tmp_res;
		}
		if (dot_res_sp >= 0) {
			if ((r_i - dot_res_sp) > dec_digit) {
				r_i = dot_res_sp + dec_digit + 1;
			}
			((byte*)res.data)[r_i] = 0;
			string tmp_res = string_clone(tos(res.data, r_i));
			array_free(&res);
			return tmp_res;
		} else {
			if (dec_digit > 0) {
				int c1 = 0;
				((byte*)res.data)[r_i] = '.';
				r_i++;
				for (;;) {
					if (!(c1 < dec_digit)) break;
					((byte*)res.data)[r_i] = '0';
					r_i++;
					c1++;
				}
				((byte*)res.data)[r_i] = 0;
			}
			string tmp_res = string_clone(tos(res.data, r_i));
			array_free(&res);
			return tmp_res;
		}
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [direct_array_access]
// Attr: [manualfree]
string strconv__format_fl(f64 f, strconv__BF_param p) {
	{ // Unsafe block
		string fs = strconv__f64_to_str_lnd1((f >= 0.0 ? (f) : (-f)), p.len1);
		if (fs.str[ 0] == '[') {
			return fs;
		}
		if (p.rm_tail_zero) {
			string tmp = fs;
			fs = strconv__remove_tail_zeros(fs);
			string_free(&tmp);
		}
		Array_fixed_u8_32 buf = {0};
		Array_fixed_u8_32 out = {0};
		int buf_i = 0;
		int out_i = 0;
		int sign_len_diff = 0;
		if (p.pad_ch == '0') {
			if (p.positive) {
				if (p.sign_flag) {
					out[out_i] = '+';
					out_i++;
					sign_len_diff = -1;
				}
			} else {
				out[out_i] = '-';
				out_i++;
				sign_len_diff = -1;
			}
		} else {
			if (p.positive) {
				if (p.sign_flag) {
					buf[buf_i] = '+';
					buf_i++;
				}
			} else {
				buf[buf_i] = '-';
				buf_i++;
			}
		}
		vmemcpy(&buf[buf_i], fs.str, fs.len);
		buf_i += fs.len;
		int dif = p.len0 - buf_i + sign_len_diff;
		if (p.allign == strconv__Align_text__right) {
			for (int i1 = 0; i1 < dif; i1++) {
				out[out_i] = p.pad_ch;
				out_i++;
			}
		}
		vmemcpy(&out[out_i], &buf[0], buf_i);
		out_i += buf_i;
		if (p.allign == strconv__Align_text__left) {
			for (int i1 = 0; i1 < dif; i1++) {
				out[out_i] = p.pad_ch;
				out_i++;
			}
		}
		out[out_i] = 0;
		string tmp = fs;
		fs = tos_clone(&out[0]);
		string_free(&tmp);
		return fs;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [direct_array_access]
// Attr: [manualfree]
string strconv__format_es(f64 f, strconv__BF_param p) {
	{ // Unsafe block
		string fs = strconv__f64_to_str_pad((f > 0 ? (f) : (-f)), p.len1);
		if (p.rm_tail_zero) {
			string tmp = fs;
			fs = strconv__remove_tail_zeros(fs);
			string_free(&tmp);
		}
		Array_fixed_u8_32 buf = {0};
		Array_fixed_u8_32 out = {0};
		int buf_i = 0;
		int out_i = 0;
		int sign_len_diff = 0;
		if (p.pad_ch == '0') {
			if (p.positive) {
				if (p.sign_flag) {
					out[out_i] = '+';
					out_i++;
					sign_len_diff = -1;
				}
			} else {
				out[out_i] = '-';
				out_i++;
				sign_len_diff = -1;
			}
		} else {
			if (p.positive) {
				if (p.sign_flag) {
					buf[buf_i] = '+';
					buf_i++;
				}
			} else {
				buf[buf_i] = '-';
				buf_i++;
			}
		}
		vmemcpy(&buf[buf_i], fs.str, fs.len);
		buf_i += fs.len;
		int dif = p.len0 - buf_i + sign_len_diff;
		if (p.allign == strconv__Align_text__right) {
			for (int i1 = 0; i1 < dif; i1++) {
				out[out_i] = p.pad_ch;
				out_i++;
			}
		}
		vmemcpy(&out[out_i], &buf[0], buf_i);
		out_i += buf_i;
		if (p.allign == strconv__Align_text__left) {
			for (int i1 = 0; i1 < dif; i1++) {
				out[out_i] = p.pad_ch;
				out_i++;
			}
		}
		out[out_i] = 0;
		string tmp = fs;
		fs = tos_clone(&out[0]);
		string_free(&tmp);
		return fs;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [direct_array_access]
string strconv__remove_tail_zeros(string s) {
	{ // Unsafe block
		byte* buf = malloc_noscan(s.len + 1);
		int i_d = 0;
		int i_s = 0;
		for (;;) {
			if (!(i_s < s.len && !(s.str[ i_s] == '-' || s.str[ i_s] == '+') && (s.str[ i_s] > '9' || s.str[ i_s] < '0'))) break;
			buf[i_d] = s.str[ i_s];
			i_s++;
			i_d++;
		}
		if (i_s < s.len && (s.str[ i_s] == '-' || s.str[ i_s] == '+')) {
			buf[i_d] = s.str[ i_s];
			i_s++;
			i_d++;
		}
		for (;;) {
			if (!(i_s < s.len && s.str[ i_s] >= '0' && s.str[ i_s] <= '9')) break;
			buf[i_d] = s.str[ i_s];
			i_s++;
			i_d++;
		}
		if (i_s < s.len && s.str[ i_s] == '.') {
			int i_s1 = i_s + 1;
			int sum = 0;
			for (;;) {
				if (!(i_s1 < s.len && s.str[ i_s1] >= '0' && s.str[ i_s1] <= '9')) break;
				sum += s.str[ i_s1] - ((byte)('0'));
				i_s1++;
			}
			if (sum > 0) {
				for (int c_i = i_s; c_i < i_s1; ++c_i) {
					buf[i_d] = s.str[ c_i];
					i_d++;
				}
			}
			i_s = i_s1;
		}
		if (i_s < s.len && s.str[ i_s] != '.') {
			for (;;) {
				buf[i_d] = s.str[ i_s];
				i_s++;
				i_d++;
				if (i_s >= s.len) {
					break;
				}
			}
		}
		buf[i_d] = 0;
		return tos(buf, i_d);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [inline]
inline string strconv__ftoa_64(f64 f) {
	return strconv__f64_to_str(f, 17);
}

// Attr: [inline]
inline string strconv__ftoa_long_64(f64 f) {
	return strconv__f64_to_str_l(f);
}

// Attr: [inline]
inline string strconv__ftoa_32(f32 f) {
	return strconv__f32_to_str(f, 8);
}

// Attr: [inline]
inline string strconv__ftoa_long_32(f32 f) {
	return strconv__f32_to_str_l(f);
}

// Attr: [direct_array_access]
// Attr: [manualfree]
string strconv__format_int(i64 n, int radix) {
	{ // Unsafe block
		if (radix < 2 || radix > 36) {
			_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("invalid radix: "), 0xfe07, {.d_i32 = radix}}, {_SLIT(" . It should be => 2 and <= 36"), 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		}
		if (n == 0) {
			return _SLIT("0");
		}
		i64 n_copy = n;
		bool have_minus = false;
		if (n < 0) {
			have_minus = true;
			n_copy = -n_copy;
		}
		string res = _SLIT("");
		for (;;) {
			if (!(n_copy != 0)) break;
			string tmp_0 = res;
			int bdx = ((int)(n_copy % radix));
			string tmp_1 = byte_ascii_str(_const_strconv__base_digits.str[ bdx]);
			res = string__plus(tmp_1, res);
			string_free(&tmp_0);
			string_free(&tmp_1);
			n_copy /= radix;
		}
		if (have_minus) {
			string final_res = string__plus(_SLIT("-"), res);
			string_free(&res);
			return final_res;
		}
		return res;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [manualfree]
string strconv__format_uint(u64 n, int radix) {
	{ // Unsafe block
		if (radix < 2 || radix > 36) {
			_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("invalid radix: "), 0xfe07, {.d_i32 = radix}}, {_SLIT(" . It should be => 2 and <= 36"), 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		}
		if (n == 0U) {
			return _SLIT("0");
		}
		u64 n_copy = n;
		string res = _SLIT("");
		u64 uradix = ((u64)(radix));
		for (;;) {
			if (!(n_copy != 0U)) break;
			string tmp_0 = res;
			string tmp_1 = byte_ascii_str(string_at(_const_strconv__base_digits, n_copy % uradix));
			res = string__plus(tmp_1, res);
			string_free(&tmp_0);
			string_free(&tmp_1);
			n_copy /= uradix;
		}
		return res;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [manualfree]
string strconv__f32_to_str_l(f32 f) {
	string s = strconv__f32_to_str(f, 6);
	string res = strconv__fxx_to_str_l_parse(s);
	string_free(&s);
	return res;
}

// Attr: [manualfree]
string strconv__f32_to_str_l_no_dot(f32 f) {
	string s = strconv__f32_to_str(f, 6);
	string res = strconv__fxx_to_str_l_parse_no_dot(s);
	string_free(&s);
	return res;
}

// Attr: [manualfree]
string strconv__f64_to_str_l(f64 f) {
	string s = strconv__f64_to_str(f, 18);
	string res = strconv__fxx_to_str_l_parse(s);
	string_free(&s);
	return res;
}

// Attr: [manualfree]
string strconv__f64_to_str_l_no_dot(f64 f) {
	string s = strconv__f64_to_str(f, 18);
	string res = strconv__fxx_to_str_l_parse_no_dot(s);
	string_free(&s);
	return res;
}

// Attr: [manualfree]
string strconv__fxx_to_str_l_parse(string s) {
	if (s.len > 2 && (string_at(s, 0) == 'n' || string_at(s, 1) == 'i')) {
		return string_clone(s);
	}
	bool m_sgn_flag = false;
	int sgn = 1;
	Array_fixed_byte_26 b = {0};
	int d_pos = 1;
	int i = 0;
	int i1 = 0;
	int exp = 0;
	int exp_sgn = 1;
	for (int _t2 = 0; _t2 < s.len; ++_t2) {
		byte c = s.str[_t2];
		if (c == '-') {
			sgn = -1;
			i++;
		} else if (c == '+') {
			sgn = 1;
			i++;
		} else if (c >= '0' && c <= '9') {
			b[v_fixed_index(i1, 26)] = c;
			i1++;
			i++;
		} else if (c == '.') {
			if (sgn > 0) {
				d_pos = i;
			} else {
				d_pos = i - 1;
			}
			i++;
		} else if (c == 'e') {
			i++;
			break;
		} else {
			return _SLIT("Float conversion error!!");
		}
	}
	b[v_fixed_index(i1, 26)] = 0;
	if (string_at(s, i) == '-') {
		exp_sgn = -1;
		i++;
	} else if (string_at(s, i) == '+') {
		exp_sgn = 1;
		i++;
	}
	int c = i;
	for (;;) {
		if (!(c < s.len)) break;
		exp = exp * 10 + ((int)(string_at(s, c) - '0'));
		c++;
	}
	Array_byte res = __new_array_with_default(exp + 32, 0, sizeof(byte), &(byte[]){0});
	int r_i = 0;
	if (sgn == 1) {
		if (m_sgn_flag) {
			array_set(&res, r_i, &(byte[]) { '+' });
			r_i++;
		}
	} else {
		array_set(&res, r_i, &(byte[]) { '-' });
		r_i++;
	}
	i = 0;
	if (exp_sgn >= 0) {
		for (;;) {
			if (!(b[v_fixed_index(i, 26)] != 0)) break;
			array_set(&res, r_i, &(byte[]) { b[v_fixed_index(i, 26)] });
			r_i++;
			i++;
			if (i >= d_pos && exp >= 0) {
				if (exp == 0) {
					array_set(&res, r_i, &(byte[]) { '.' });
					r_i++;
				}
				exp--;
			}
		}
		for (;;) {
			if (!(exp >= 0)) break;
			array_set(&res, r_i, &(byte[]) { '0' });
			r_i++;
			exp--;
		}
	} else {
		bool dot_p = true;
		for (;;) {
			if (!(exp > 0)) break;
			array_set(&res, r_i, &(byte[]) { '0' });
			r_i++;
			exp--;
			if (dot_p) {
				array_set(&res, r_i, &(byte[]) { '.' });
				r_i++;
				dot_p = false;
			}
		}
		for (;;) {
			if (!(b[v_fixed_index(i, 26)] != 0)) break;
			array_set(&res, r_i, &(byte[]) { b[v_fixed_index(i, 26)] });
			r_i++;
			i++;
		}
	}
	array_set(&res, r_i, &(byte[]) { 0 });
	return tos(res.data, r_i);
}

// Attr: [manualfree]
string strconv__fxx_to_str_l_parse_no_dot(string s) {
	if (s.len > 2 && (string_at(s, 0) == 'n' || string_at(s, 1) == 'i')) {
		return string_clone(s);
	}
	bool m_sgn_flag = false;
	int sgn = 1;
	Array_fixed_byte_26 b = {0};
	int d_pos = 1;
	int i = 0;
	int i1 = 0;
	int exp = 0;
	int exp_sgn = 1;
	for (int _t2 = 0; _t2 < s.len; ++_t2) {
		byte c = s.str[_t2];
		if (c == '-') {
			sgn = -1;
			i++;
		} else if (c == '+') {
			sgn = 1;
			i++;
		} else if (c >= '0' && c <= '9') {
			b[v_fixed_index(i1, 26)] = c;
			i1++;
			i++;
		} else if (c == '.') {
			if (sgn > 0) {
				d_pos = i;
			} else {
				d_pos = i - 1;
			}
			i++;
		} else if (c == 'e') {
			i++;
			break;
		} else {
			return _SLIT("Float conversion error!!");
		}
	}
	b[v_fixed_index(i1, 26)] = 0;
	if (string_at(s, i) == '-') {
		exp_sgn = -1;
		i++;
	} else if (string_at(s, i) == '+') {
		exp_sgn = 1;
		i++;
	}
	int c = i;
	for (;;) {
		if (!(c < s.len)) break;
		exp = exp * 10 + ((int)(string_at(s, c) - '0'));
		c++;
	}
	Array_byte res = __new_array_with_default(exp + 32, 0, sizeof(byte), &(byte[]){0});
	int r_i = 0;
	if (sgn == 1) {
		if (m_sgn_flag) {
			array_set(&res, r_i, &(byte[]) { '+' });
			r_i++;
		}
	} else {
		array_set(&res, r_i, &(byte[]) { '-' });
		r_i++;
	}
	i = 0;
	if (exp_sgn >= 0) {
		for (;;) {
			if (!(b[v_fixed_index(i, 26)] != 0)) break;
			array_set(&res, r_i, &(byte[]) { b[v_fixed_index(i, 26)] });
			r_i++;
			i++;
			if (i >= d_pos && exp >= 0) {
				if (exp == 0) {
					array_set(&res, r_i, &(byte[]) { '.' });
					r_i++;
				}
				exp--;
			}
		}
		for (;;) {
			if (!(exp >= 0)) break;
			array_set(&res, r_i, &(byte[]) { '0' });
			r_i++;
			exp--;
		}
	} else {
		bool dot_p = true;
		for (;;) {
			if (!(exp > 0)) break;
			array_set(&res, r_i, &(byte[]) { '0' });
			r_i++;
			exp--;
			if (dot_p) {
				array_set(&res, r_i, &(byte[]) { '.' });
				r_i++;
				dot_p = false;
			}
		}
		for (;;) {
			if (!(b[v_fixed_index(i, 26)] != 0)) break;
			array_set(&res, r_i, &(byte[]) { b[v_fixed_index(i, 26)] });
			r_i++;
			i++;
		}
	}
	if (r_i > 1 && (*(byte*)/*ee elem_typ */array_get(res, r_i - 1)) == '.') {
		r_i--;
	}
	array_set(&res, r_i, &(byte[]) { 0 });
	return tos(res.data, r_i);
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL int strconv__bool_to_int(bool b) {
	if (b) {
		return 1;
	}
	return 0;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL u32 strconv__bool_to_u32(bool b) {
	if (b) {
		return ((u32)(1U));
	}
	return ((u32)(0U));
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL u64 strconv__bool_to_u64(bool b) {
	if (b) {
		return ((u64)(1U));
	}
	return ((u64)(0U));
}

VV_LOCAL_SYMBOL string strconv__get_string_special(bool neg, bool expZero, bool mantZero) {
	if (!mantZero) {
		return _SLIT("nan");
	}
	if (!expZero) {
		if (neg) {
			return _SLIT("-inf");
		} else {
			return _SLIT("+inf");
		}
	}
	if (neg) {
		return _SLIT("-0e+00");
	}
	return _SLIT("0e+00");
}

VV_LOCAL_SYMBOL u32 strconv__mul_shift_32(u32 m, u64 mul, int ishift) {
	multi_return_u64_u64 mr_746 = math__bits__mul_64(((u64)(m)), mul);
	u64 hi = mr_746.arg0;
	u64 lo = mr_746.arg1;
	u64 shifted_sum = (lo >> ((u64)(ishift))) + (hi << ((u64)(64 - ishift)));
	;
	return ((u32)(shifted_sum));
}

VV_LOCAL_SYMBOL u32 strconv__mul_pow5_invdiv_pow2(u32 m, u32 q, int j) {
	return strconv__mul_shift_32(m, (*(u64*)/*ee elem_typ */array_get(_const_strconv__pow5_inv_split_32, q)), j);
}

VV_LOCAL_SYMBOL u32 strconv__mul_pow5_div_pow2(u32 m, u32 i, int j) {
	return strconv__mul_shift_32(m, (*(u64*)/*ee elem_typ */array_get(_const_strconv__pow5_split_32, i)), j);
}

VV_LOCAL_SYMBOL u32 strconv__pow5_factor_32(u32 i_v) {
	u32 v = i_v;
	for (u32 n = ((u32)(0U)); true; n++) {
		u32 q = v / 5U;
		u32 r = v % 5U;
		if (r != 0U) {
			return n;
		}
		v = q;
	}
	return v;
}

VV_LOCAL_SYMBOL bool strconv__multiple_of_power_of_five_32(u32 v, u32 p) {
	return strconv__pow5_factor_32(v) >= p;
}

VV_LOCAL_SYMBOL bool strconv__multiple_of_power_of_two_32(u32 v, u32 p) {
	return ((u32)(math__bits__trailing_zeros_32(v))) >= p;
}

VV_LOCAL_SYMBOL u32 strconv__log10_pow2(int e) {
	;
	;
	return (((u32)(e)) * 78913U) >> 18U;
}

VV_LOCAL_SYMBOL u32 strconv__log10_pow5(int e) {
	;
	;
	return (((u32)(e)) * 732923U) >> 20U;
}

VV_LOCAL_SYMBOL int strconv__pow5_bits(int e) {
	;
	;
	return ((int)(((((u32)(e)) * 1217359U) >> 19U) + 1U));
}

VV_LOCAL_SYMBOL u64 strconv__shift_right_128(strconv__Uint128 v, int shift) {
	;
	return ((v.hi << ((u64)(64 - shift))) | (v.lo >> ((u32)(shift))));
}

VV_LOCAL_SYMBOL u64 strconv__mul_shift_64(u64 m, strconv__Uint128 mul, int shift) {
	multi_return_u64_u64 mr_3065 = math__bits__mul_64(m, mul.hi);
	u64 hihi = mr_3065.arg0;
	u64 hilo = mr_3065.arg1;
	multi_return_u64_u64 mr_3100 = math__bits__mul_64(m, mul.lo);
	u64 lohi = mr_3100.arg0;
	strconv__Uint128 sum = (strconv__Uint128){.lo = lohi + hilo,.hi = hihi,};
	if (sum.lo < lohi) {
		sum.hi++;
	}
	return strconv__shift_right_128(sum, shift - 64);
}

VV_LOCAL_SYMBOL u32 strconv__pow5_factor_64(u64 v_i) {
	u64 v = v_i;
	for (u32 n = ((u32)(0U)); true; n++) {
		u64 q = v / 5U;
		u64 r = v % 5U;
		if (r != 0U) {
			return n;
		}
		v = q;
	}
	return ((u32)(0U));
}

VV_LOCAL_SYMBOL bool strconv__multiple_of_power_of_five_64(u64 v, u32 p) {
	return strconv__pow5_factor_64(v) >= p;
}

VV_LOCAL_SYMBOL bool strconv__multiple_of_power_of_two_64(u64 v, u32 p) {
	return ((u32)(math__bits__trailing_zeros_64(v))) >= p;
}

int strconv__dec_digits(u64 n) {
	if (n <= 9999999999U) {
		if (n <= 99999U) {
			if (n <= 99U) {
				if (n <= 9U) {
					return 1;
				} else {
					return 2;
				}
			} else {
				if (n <= 999U) {
					return 3;
				} else {
					if (n <= 9999U) {
						return 4;
					} else {
						return 5;
					}
				}
			}
		} else {
			if (n <= 9999999U) {
				if (n <= 999999U) {
					return 6;
				} else {
					return 7;
				}
			} else {
				if (n <= 99999999U) {
					return 8;
				} else {
					if (n <= 999999999U) {
						return 9;
					}
					return 10;
				}
			}
		}
	} else {
		if (n <= 999999999999999U) {
			if (n <= 999999999999U) {
				if (n <= 99999999999U) {
					return 11;
				} else {
					return 12;
				}
			} else {
				if (n <= 9999999999999U) {
					return 13;
				} else {
					if (n <= 99999999999999U) {
						return 14;
					} else {
						return 15;
					}
				}
			}
		} else {
			if (n <= 99999999999999999U) {
				if (n <= 9999999999999999U) {
					return 16;
				} else {
					return 17;
				}
			} else {
				if (n <= 999999999999999999U) {
					return 18;
				} else {
					if (n <= 9999999999999999999U) {
						return 19;
					}
					return 20;
				}
			}
		}
	}
	return 0;
}

void strconv__v_printf(string str, Array_voidptr pt) {
	print(strconv__v_sprintf(str, new_array_from_c_array(1, 1, sizeof(voidptr), _MOV((voidptr[1]){(voidptr)&/*qq*/pt}))));
}

string strconv__v_sprintf(string str, Array_voidptr pt) {
bool strconv__v_sprintf_defer_0 = false;
strings__Builder res;
	res = strings__new_builder(pt.len * 16);
	strconv__v_sprintf_defer_0 = true;
	int i = 0;
	int p_index = 0;
	bool sign = false;
	strconv__Align_text allign = strconv__Align_text__right;
	int len0 = -1;
	int len1 = -1;
	int def_len1 = 6;
	byte pad_ch = ((byte)(' '));
	rune ch1 = '0';
	rune ch2 = '0';
	strconv__Char_parse_state status = strconv__Char_parse_state__norm_char;
	for (;;) {
		if (!(i < str.len)) break;
		if (status == strconv__Char_parse_state__reset_params) {
			sign = false;
			allign = strconv__Align_text__right;
			len0 = -1;
			len1 = -1;
			pad_ch = ' ';
			status = strconv__Char_parse_state__norm_char;
			ch1 = '0';
			ch2 = '0';
			continue;
		}
		byte ch = string_at(str, i);
		if (ch != '%' && status == strconv__Char_parse_state__norm_char) {
			strings__Builder_write_b(&res, ch);
			i++;
			continue;
		}
		if (ch == '%' && status == strconv__Char_parse_state__norm_char) {
			status = strconv__Char_parse_state__field_char;
			i++;
			continue;
		}
		if (ch == 'c' && status == strconv__Char_parse_state__field_char) {
			strconv__v_sprintf_panic(p_index, pt.len);
			byte d1 = *(((byte*)((*(voidptr*)/*ee elem_typ */array_get(pt, p_index)))));
			strings__Builder_write_b(&res, d1);
			status = strconv__Char_parse_state__reset_params;
			p_index++;
			i++;
			continue;
		}
		if (ch == 'p' && status == strconv__Char_parse_state__field_char) {
			strconv__v_sprintf_panic(p_index, pt.len);
			strings__Builder_write_string(&res, _SLIT("0x"));
			strings__Builder_write_string(&res, ptr_str((*(voidptr*)/*ee elem_typ */array_get(pt, p_index))));
			status = strconv__Char_parse_state__reset_params;
			p_index++;
			i++;
			continue;
		}
		if (status == strconv__Char_parse_state__field_char) {
			rune fc_ch1 = '0';
			rune fc_ch2 = '0';
			if ((i + 1) < str.len) {
				fc_ch1 = string_at(str, i + 1);
				if ((i + 2) < str.len) {
					fc_ch2 = string_at(str, i + 2);
				}
			}
			if (ch == '+') {
				sign = true;
				i++;
				continue;
			} else if (ch == '-') {
				allign = strconv__Align_text__left;
				i++;
				continue;
			} else if (ch == '0' || ch == ' ') {
				if (allign == strconv__Align_text__right) {
					pad_ch = ch;
				}
				i++;
				continue;
			} else if (ch == '\'') {
				i++;
				continue;
			} else if (ch == '.' && fc_ch1 >= '1' && fc_ch1 <= '9') {
				status = strconv__Char_parse_state__check_float;
				i++;
				continue;
			} else if (ch == '.' && fc_ch1 == '*' && fc_ch2 == 's') {
				strconv__v_sprintf_panic(p_index, pt.len);
				int len = *(((int*)((*(voidptr*)/*ee elem_typ */array_get(pt, p_index)))));
				p_index++;
				strconv__v_sprintf_panic(p_index, pt.len);
				string s = *(((string*)((*(voidptr*)/*ee elem_typ */array_get(pt, p_index)))));
				s = string_substr(s, 0, len);
				p_index++;
				strings__Builder_write_string(&res, s);
				status = strconv__Char_parse_state__reset_params;
				i += 3;
				continue;
			}
			status = strconv__Char_parse_state__len_set_start;
			continue;
		}
		if (status == strconv__Char_parse_state__len_set_start) {
			if (ch >= '1' && ch <= '9') {
				len0 = ((int)(ch - '0'));
				status = strconv__Char_parse_state__len_set_in;
				i++;
				continue;
			}
			if (ch == '.') {
				status = strconv__Char_parse_state__check_float;
				i++;
				continue;
			}
			status = strconv__Char_parse_state__check_type;
			continue;
		}
		if (status == strconv__Char_parse_state__len_set_in) {
			if (ch >= '0' && ch <= '9') {
				len0 *= 10;
				len0 += ((int)(ch - '0'));
				i++;
				continue;
			}
			if (ch == '.') {
				status = strconv__Char_parse_state__check_float;
				i++;
				continue;
			}
			status = strconv__Char_parse_state__check_type;
			continue;
		}
		if (status == strconv__Char_parse_state__check_float) {
			if (ch >= '0' && ch <= '9') {
				len1 = ((int)(ch - '0'));
				status = strconv__Char_parse_state__check_float_in;
				i++;
				continue;
			}
			status = strconv__Char_parse_state__check_type;
			continue;
		}
		if (status == strconv__Char_parse_state__check_float_in) {
			if (ch >= '0' && ch <= '9') {
				len1 *= 10;
				len1 += ((int)(ch - '0'));
				i++;
				continue;
			}
			status = strconv__Char_parse_state__check_type;
			continue;
		}
		if (status == strconv__Char_parse_state__check_type) {
			if (ch == 'l') {
				if (ch1 == '0') {
					ch1 = 'l';
					i++;
					continue;
				} else {
					ch2 = 'l';
					i++;
					continue;
				}
			} else if (ch == 'h') {
				if (ch1 == '0') {
					ch1 = 'h';
					i++;
					continue;
				} else {
					ch2 = 'h';
					i++;
					continue;
				}
			} else if (ch == 'd' || ch == 'i') {
				u64 d1 = ((u64)(0U));
				bool positive = true;

				if (ch1 == ('h')) {
					if (ch2 == 'h') {
						strconv__v_sprintf_panic(p_index, pt.len);
						i8 x = *(((i8*)((*(voidptr*)/*ee elem_typ */array_get(pt, p_index)))));
						positive = (x >= 0 ? (true) : (false));
						d1 = (positive ? (((u64)(x))) : (((u64)(-x))));
					} else {
						i16 x = *(((i16*)((*(voidptr*)/*ee elem_typ */array_get(pt, p_index)))));
						positive = (x >= 0 ? (true) : (false));
						d1 = (positive ? (((u64)(x))) : (((u64)(-x))));
					}
				}
				else if (ch1 == ('l')) {
					strconv__v_sprintf_panic(p_index, pt.len);
					i64 x = *(((i64*)((*(voidptr*)/*ee elem_typ */array_get(pt, p_index)))));
					positive = (x >= 0 ? (true) : (false));
					d1 = (positive ? (((u64)(x))) : (((u64)(-x))));
				}
				else {
					strconv__v_sprintf_panic(p_index, pt.len);
					int x = *(((int*)((*(voidptr*)/*ee elem_typ */array_get(pt, p_index)))));
					positive = (x >= 0 ? (true) : (false));
					d1 = (positive ? (((u64)(x))) : (((u64)(-x))));
				};
				strings__Builder_write_string(&res, strconv__format_dec_old(d1, (strconv__BF_param){
					.pad_ch = pad_ch,
					.len0 = len0,
					.len1 = 0,
					.positive = positive,
					.sign_flag = sign,
					.allign = allign,
					.rm_tail_zero = 0,
				}));
				status = strconv__Char_parse_state__reset_params;
				p_index++;
				i++;
				ch1 = '0';
				ch2 = '0';
				continue;
			} else if (ch == 'u') {
				u64 d1 = ((u64)(0U));
				bool positive = true;
				strconv__v_sprintf_panic(p_index, pt.len);

				if (ch1 == ('h')) {
					if (ch2 == 'h') {
						d1 = ((u64)(*(((byte*)((*(voidptr*)/*ee elem_typ */array_get(pt, p_index)))))));
					} else {
						d1 = ((u64)(*(((u16*)((*(voidptr*)/*ee elem_typ */array_get(pt, p_index)))))));
					}
				}
				else if (ch1 == ('l')) {
					d1 = ((u64)(*(((u64*)((*(voidptr*)/*ee elem_typ */array_get(pt, p_index)))))));
				}
				else {
					d1 = ((u64)(*(((u32*)((*(voidptr*)/*ee elem_typ */array_get(pt, p_index)))))));
				};
				strings__Builder_write_string(&res, strconv__format_dec_old(d1, (strconv__BF_param){
					.pad_ch = pad_ch,
					.len0 = len0,
					.len1 = 0,
					.positive = positive,
					.sign_flag = sign,
					.allign = allign,
					.rm_tail_zero = 0,
				}));
				status = strconv__Char_parse_state__reset_params;
				p_index++;
				i++;
				continue;
			} else if (ch == 'x' || ch == 'X') {
				strconv__v_sprintf_panic(p_index, pt.len);
				string s = _SLIT("");

				if (ch1 == ('h')) {
					if (ch2 == 'h') {
						i8 x = *(((i8*)((*(voidptr*)/*ee elem_typ */array_get(pt, p_index)))));
						s = i8_hex(x);
					} else {
						i16 x = *(((i16*)((*(voidptr*)/*ee elem_typ */array_get(pt, p_index)))));
						s = i16_hex(x);
					}
				}
				else if (ch1 == ('l')) {
					i64 x = *(((i64*)((*(voidptr*)/*ee elem_typ */array_get(pt, p_index)))));
					s = i64_hex(x);
				}
				else {
					int x = *(((int*)((*(voidptr*)/*ee elem_typ */array_get(pt, p_index)))));
					s = int_hex(x);
				};
				if (ch == 'X') {
					s = string_to_upper(s);
				}
				strings__Builder_write_string(&res, strconv__format_str(s, (strconv__BF_param){
					.pad_ch = pad_ch,
					.len0 = len0,
					.len1 = 0,
					.positive = true,
					.sign_flag = false,
					.allign = allign,
					.rm_tail_zero = 0,
				}));
				status = strconv__Char_parse_state__reset_params;
				p_index++;
				i++;
				continue;
			}
			if (ch == 'f' || ch == 'F') {
				#if !defined(CUSTOM_DEFINE_nofloat)
				{
					strconv__v_sprintf_panic(p_index, pt.len);
					f64 x = *(((f64*)((*(voidptr*)/*ee elem_typ */array_get(pt, p_index)))));
					bool positive = x >= ((f64)(0.0));
					len1 = (len1 >= 0 ? (len1) : (def_len1));
					string s = strconv__format_fl_old(((f64)(x)), (strconv__BF_param){
						.pad_ch = pad_ch,
						.len0 = len0,
						.len1 = len1,
						.positive = positive,
						.sign_flag = sign,
						.allign = allign,
						.rm_tail_zero = 0,
					});
					strings__Builder_write_string(&res, (ch == 'F' ? (string_to_upper(s)) : (s)));
				}
				#endif
				status = strconv__Char_parse_state__reset_params;
				p_index++;
				i++;
				continue;
			} else if (ch == 'e' || ch == 'E') {
				#if !defined(CUSTOM_DEFINE_nofloat)
				{
					strconv__v_sprintf_panic(p_index, pt.len);
					f64 x = *(((f64*)((*(voidptr*)/*ee elem_typ */array_get(pt, p_index)))));
					bool positive = x >= ((f64)(0.0));
					len1 = (len1 >= 0 ? (len1) : (def_len1));
					string s = strconv__format_es_old(((f64)(x)), (strconv__BF_param){
						.pad_ch = pad_ch,
						.len0 = len0,
						.len1 = len1,
						.positive = positive,
						.sign_flag = sign,
						.allign = allign,
						.rm_tail_zero = 0,
					});
					strings__Builder_write_string(&res, (ch == 'E' ? (string_to_upper(s)) : (s)));
				}
				#endif
				status = strconv__Char_parse_state__reset_params;
				p_index++;
				i++;
				continue;
			} else if (ch == 'g' || ch == 'G') {
				#if !defined(CUSTOM_DEFINE_nofloat)
				{
					strconv__v_sprintf_panic(p_index, pt.len);
					f64 x = *(((f64*)((*(voidptr*)/*ee elem_typ */array_get(pt, p_index)))));
					bool positive = x >= ((f64)(0.0));
					string s = _SLIT("");
					f64 tx = strconv__fabs(x);
					if (tx < 999999.0 && tx >= 0.00001) {
						len1 = (len1 >= 0 ? (len1 + 1) : (def_len1));
						s = strconv__format_fl_old(x, (strconv__BF_param){
							.pad_ch = pad_ch,
							.len0 = len0,
							.len1 = len1,
							.positive = positive,
							.sign_flag = sign,
							.allign = allign,
							.rm_tail_zero = true,
						});
					} else {
						len1 = (len1 >= 0 ? (len1 + 1) : (def_len1));
						s = strconv__format_es_old(x, (strconv__BF_param){
							.pad_ch = pad_ch,
							.len0 = len0,
							.len1 = len1,
							.positive = positive,
							.sign_flag = sign,
							.allign = allign,
							.rm_tail_zero = true,
						});
					}
					strings__Builder_write_string(&res, (ch == 'G' ? (string_to_upper(s)) : (s)));
				}
				#endif
				status = strconv__Char_parse_state__reset_params;
				p_index++;
				i++;
				continue;
			} else if (ch == 's') {
				strconv__v_sprintf_panic(p_index, pt.len);
				string s1 = *(((string*)((*(voidptr*)/*ee elem_typ */array_get(pt, p_index)))));
				pad_ch = ' ';
				strings__Builder_write_string(&res, strconv__format_str(s1, (strconv__BF_param){
					.pad_ch = pad_ch,
					.len0 = len0,
					.len1 = 0,
					.positive = true,
					.sign_flag = false,
					.allign = allign,
					.rm_tail_zero = 0,
				}));
				status = strconv__Char_parse_state__reset_params;
				p_index++;
				i++;
				continue;
			}
		}
		status = strconv__Char_parse_state__reset_params;
		p_index++;
		i++;
	}
	if (p_index != pt.len) {
		_v_panic( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = p_index}}, {_SLIT(" % conversion specifiers, but given "), 0xfe07, {.d_i32 = pt.len}}, {_SLIT(" args"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	string _t1 = strings__Builder_str(&res);
	// Defer begin
	if (strconv__v_sprintf_defer_0) {
		strings__Builder_free(&res);
	}
	// Defer end
	return _t1;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL void strconv__v_sprintf_panic(int idx, int len) {
	if (idx >= len) {
		_v_panic( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = idx + 1}}, {_SLIT(" % conversion specifiers, but given only "), 0xfe07, {.d_i32 = len}}, {_SLIT(" args"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
}

VV_LOCAL_SYMBOL f64 strconv__fabs(f64 x) {
	if (x < 0.0) {
		return -x;
	}
	return x;
}

// Attr: [manualfree]
string strconv__format_fl_old(f64 f, strconv__BF_param p) {
bool strconv__format_fl_old_defer_0 = false;
strings__Builder res;
	{ // Unsafe block
		string s = _SLIT("");
		string fs = strconv__f64_to_str_lnd1((f >= 0.0 ? (f) : (-f)), p.len1);
		if (string_at(fs, 0) == '[') {
			string_free(&s);
			return fs;
		}
		if (p.rm_tail_zero) {
			string tmp = fs;
			fs = strconv__remove_tail_zeros_old(fs);
			string_free(&tmp);
		}
		res = strings__new_builder((p.len0 > fs.len ? (p.len0) : (fs.len)));
		strconv__format_fl_old_defer_0 = true;
		int sign_len_diff = 0;
		if (p.pad_ch == '0') {
			if (p.positive) {
				if (p.sign_flag) {
					strings__Builder_write_b(&res, '+');
					sign_len_diff = -1;
				}
			} else {
				strings__Builder_write_b(&res, '-');
				sign_len_diff = -1;
			}
			string tmp = s;
			s = string_clone(fs);
			string_free(&tmp);
		} else {
			if (p.positive) {
				if (p.sign_flag) {
					string tmp = s;
					s = string__plus(_SLIT("+"), fs);
					string_free(&tmp);
				} else {
					string tmp = s;
					s = string_clone(fs);
					string_free(&tmp);
				}
			} else {
				string tmp = s;
				s = string__plus(_SLIT("-"), fs);
				string_free(&tmp);
			}
		}
		int dif = p.len0 - s.len + sign_len_diff;
		if (p.allign == strconv__Align_text__right) {
			for (int i1 = 0; i1 < dif; i1++) {
				strings__Builder_write_b(&res, p.pad_ch);
			}
		}
		strings__Builder_write_string(&res, s);
		if (p.allign == strconv__Align_text__left) {
			for (int i1 = 0; i1 < dif; i1++) {
				strings__Builder_write_b(&res, p.pad_ch);
			}
		}
		string_free(&s);
		string_free(&fs);
		string _t2 = strings__Builder_str(&res);
		// Defer begin
		if (strconv__format_fl_old_defer_0) {
			strings__Builder_free(&res);
		}
		// Defer end
		return _t2;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [manualfree]
string strconv__format_es_old(f64 f, strconv__BF_param p) {
bool strconv__format_es_old_defer_0 = false;
strings__Builder res;
	{ // Unsafe block
		string s = _SLIT("");
		string fs = strconv__f64_to_str_pad((f > 0 ? (f) : (-f)), p.len1);
		if (p.rm_tail_zero) {
			fs = strconv__remove_tail_zeros_old(fs);
		}
		res = strings__new_builder((p.len0 > fs.len ? (p.len0) : (fs.len)));
		strconv__format_es_old_defer_0 = true;
		int sign_len_diff = 0;
		if (p.pad_ch == '0') {
			if (p.positive) {
				if (p.sign_flag) {
					strings__Builder_write_b(&res, '+');
					sign_len_diff = -1;
				}
			} else {
				strings__Builder_write_b(&res, '-');
				sign_len_diff = -1;
			}
			string tmp = s;
			s = string_clone(fs);
			string_free(&tmp);
		} else {
			if (p.positive) {
				if (p.sign_flag) {
					string tmp = s;
					s = string__plus(_SLIT("+"), fs);
					string_free(&tmp);
				} else {
					string tmp = s;
					s = string_clone(fs);
					string_free(&tmp);
				}
			} else {
				string tmp = s;
				s = string__plus(_SLIT("-"), fs);
				string_free(&tmp);
			}
		}
		int dif = p.len0 - s.len + sign_len_diff;
		if (p.allign == strconv__Align_text__right) {
			for (int i1 = 0; i1 < dif; i1++) {
				strings__Builder_write_b(&res, p.pad_ch);
			}
		}
		strings__Builder_write_string(&res, s);
		if (p.allign == strconv__Align_text__left) {
			for (int i1 = 0; i1 < dif; i1++) {
				strings__Builder_write_b(&res, p.pad_ch);
			}
		}
		string_free(&s);
		string_free(&fs);
		string _t1 = strings__Builder_str(&res);
		// Defer begin
		if (strconv__format_es_old_defer_0) {
			strings__Builder_free(&res);
		}
		// Defer end
		return _t1;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

string strconv__remove_tail_zeros_old(string s) {
	int i = 0;
	int last_zero_start = -1;
	int dot_pos = -1;
	bool in_decimal = false;
	byte prev_ch = ((byte)(0));
	for (;;) {
		if (!(i < s.len)) break;
		byte ch = s.str[i];
		if (ch == '.') {
			in_decimal = true;
			dot_pos = i;
		} else if (in_decimal) {
			if (ch == '0' && prev_ch != '0') {
				last_zero_start = i;
			} else if (ch >= '1' && ch <= '9') {
				last_zero_start = -1;
			} else if (ch == 'e') {
				break;
			}
		}
		prev_ch = ch;
		i++;
	}
	string tmp = _SLIT("");
	if (last_zero_start > 0) {
		if (last_zero_start == dot_pos + 1) {
			tmp = string__plus(string_substr(s, 0, dot_pos), string_substr(s, i, s.len));
		} else {
			tmp = string__plus(string_substr(s, 0, last_zero_start), string_substr(s, i, s.len));
		}
	} else {
		tmp = s;
	}
	if (tmp.str[tmp.len - 1] == '.') {
		return string_substr(tmp, 0, tmp.len - 1);
	}
	return tmp;
}

string strconv__format_dec_old(u64 d, strconv__BF_param p) {
bool strconv__format_dec_old_defer_0 = false;
strings__Builder res;
	string s = _SLIT("");
	res = strings__new_builder(20);
	strconv__format_dec_old_defer_0 = true;
	int sign_len_diff = 0;
	if (p.pad_ch == '0') {
		if (p.positive) {
			if (p.sign_flag) {
				strings__Builder_write_b(&res, '+');
				sign_len_diff = -1;
			}
		} else {
			strings__Builder_write_b(&res, '-');
			sign_len_diff = -1;
		}
		s = u64_str(d);
	} else {
		if (p.positive) {
			if (p.sign_flag) {
				s = string__plus(_SLIT("+"), u64_str(d));
			} else {
				s = u64_str(d);
			}
		} else {
			s = string__plus(_SLIT("-"), u64_str(d));
		}
	}
	int dif = p.len0 - s.len + sign_len_diff;
	if (p.allign == strconv__Align_text__right) {
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_b(&res, p.pad_ch);
		}
	}
	strings__Builder_write_string(&res, s);
	if (p.allign == strconv__Align_text__left) {
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_b(&res, p.pad_ch);
		}
	}
	string _t1 = strings__Builder_str(&res);
	// Defer begin
	if (strconv__format_dec_old_defer_0) {
		strings__Builder_free(&res);
	}
	// Defer end
	return _t1;
}

VV_LOCAL_SYMBOL array __new_array(int mylen, int cap, int elm_size) {
	int cap_ = (cap < mylen ? (mylen) : (cap));
	array arr = (array){.element_size = elm_size,.data = vcalloc(cap_ * elm_size),.offset = 0,.len = mylen,.cap = cap_,.flags = 0,};
	return arr;
}

VV_LOCAL_SYMBOL array __new_array_with_default(int mylen, int cap, int elm_size, voidptr val) {
	int cap_ = (cap < mylen ? (mylen) : (cap));
	array arr = (array){.element_size = elm_size,.data = 0,.offset = 0,.len = mylen,.cap = cap_,.flags = 0,};
	if (cap_ > 0 && mylen == 0) {
		arr.data = _v_malloc(cap_ * elm_size);
	} else {
		arr.data = vcalloc(cap_ * elm_size);
	}
	if (val != 0) {
		for (int i = 0; i < arr.len; ++i) {
			array_set_unsafe(&arr, i, val);
		}
	}
	return arr;
}

VV_LOCAL_SYMBOL array __new_array_with_array_default(int mylen, int cap, int elm_size, array val) {
	int cap_ = (cap < mylen ? (mylen) : (cap));
	array arr = (array){.element_size = elm_size,.data = _v_malloc(cap_ * elm_size),.offset = 0,.len = mylen,.cap = cap_,.flags = 0,};
	for (int i = 0; i < arr.len; ++i) {
		array val_clone = array_clone_to_depth(&val, 1);
		array_set_unsafe(&arr, i, &val_clone);
	}
	return arr;
}

VV_LOCAL_SYMBOL array __new_array_with_map_default(int mylen, int cap, int elm_size, map val) {
	int cap_ = (cap < mylen ? (mylen) : (cap));
	array arr = (array){.element_size = elm_size,.data = _v_malloc(cap_ * elm_size),.offset = 0,.len = mylen,.cap = cap_,.flags = 0,};
	for (int i = 0; i < arr.len; ++i) {
		map val_clone = map_clone(&val);
		array_set_unsafe(&arr, i, &val_clone);
	}
	return arr;
}

VV_LOCAL_SYMBOL array new_array_from_c_array(int len, int cap, int elm_size, voidptr c_array) {
	int cap_ = (cap < len ? (len) : (cap));
	array arr = (array){.element_size = elm_size,.data = vcalloc(cap_ * elm_size),.offset = 0,.len = len,.cap = cap_,.flags = 0,};
	vmemcpy(arr.data, c_array, len * elm_size);
	return arr;
}

VV_LOCAL_SYMBOL array new_array_from_c_array_no_alloc(int len, int cap, int elm_size, voidptr c_array) {
	array arr = (array){.element_size = elm_size,.data = c_array,.offset = 0,.len = len,.cap = cap,.flags = 0,};
	return arr;
}

VV_LOCAL_SYMBOL void array_ensure_cap(array* a, int required) {
	if (required <= a->cap) {
		return;
	}
	int cap = (a->cap > 0 ? (a->cap) : (2));
	for (;;) {
		if (!(required > cap)) break;
		cap *= 2;
	}
	int new_size = cap * a->element_size;
	byte* new_data = vcalloc(new_size);
	if (a->data != ((voidptr)(0))) {
		vmemcpy(new_data, a->data, a->len * a->element_size);
		if (ArrayFlags_has(&a->flags, ArrayFlags__noslices)) {
			_v_free(a->data);
		}
	}
	a->data = new_data;
	a->offset = 0;
	a->cap = cap;
}

array array_repeat(array a, int count) {
	return array_repeat_to_depth(a, count, 0);
}

// Attr: [unsafe]
array array_repeat_to_depth(array a, int count, int depth) {
	if (count < 0) {
		_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("array.repeat: count is negative: "), 0xfe07, {.d_i32 = count}}, {_SLIT0, 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	int size = count * a.len * a.element_size;
	if (size == 0) {
		size = a.element_size;
	}
	array arr = (array){.element_size = a.element_size,.data = vcalloc(size),.offset = 0,.len = count * a.len,.cap = count * a.len,.flags = 0,};
	if (a.len > 0) {
		for (int i = 0; i < count; ++i) {
			if (depth > 0) {
				array ary_clone = array_clone_to_depth(&a, depth);
				vmemcpy(array_get_unsafe(arr, i * a.len), ((byte*)(ary_clone.data)), a.len * a.element_size);
			} else {
				vmemcpy(array_get_unsafe(arr, i * a.len), ((byte*)(a.data)), a.len * a.element_size);
			}
		}
	}
	return arr;
}

void array_sort_with_compare(array* a, int (*callback)(voidptr , voidptr )) {
	#if defined(_VFREESTANDING)
	{
	}
	#else
	{
		vqsort(a->data, ((usize)(a->len)), ((usize)(a->element_size)), (voidptr)callback);
	}
	#endif
}

void array_insert(array* a, int i, voidptr val) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (i < 0 || i > a->len) {
			_v_panic( str_intp(3, _MOV((StrIntpData[]){{_SLIT("array.insert: index out of range (i == "), 0xfe07, {.d_i32 = i}}, {_SLIT(", a.len == "), 0xfe07, {.d_i32 = a->len}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		}
	}
	#endif
	array_ensure_cap(a, a->len + 1);
	{ // Unsafe block
		vmemmove(array_get_unsafe(/*rec*/*a, i + 1), array_get_unsafe(/*rec*/*a, i), (a->len - i) * a->element_size);
		array_set_unsafe(a, i, val);
	}
	a->len++;
}

// Attr: [unsafe]
void array_insert_many(array* a, int i, voidptr val, int size) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (i < 0 || i > a->len) {
			_v_panic( str_intp(3, _MOV((StrIntpData[]){{_SLIT("array.insert_many: index out of range (i == "), 0xfe07, {.d_i32 = i}}, {_SLIT(", a.len == "), 0xfe07, {.d_i32 = a->len}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		}
	}
	#endif
	array_ensure_cap(a, a->len + size);
	int elem_size = a->element_size;
	{ // Unsafe block
		voidptr iptr = array_get_unsafe(/*rec*/*a, i);
		vmemmove(array_get_unsafe(/*rec*/*a, i + size), iptr, (a->len - i) * elem_size);
		vmemcpy(iptr, val, size * elem_size);
	}
	a->len += size;
}

void array_prepend(array* a, voidptr val) {
	array_insert(a, 0, val);
}

// Attr: [unsafe]
void array_prepend_many(array* a, voidptr val, int size) {
	array_insert_many(a, 0, val, size);
}

void array_delete(array* a, int i) {
	array_delete_many(a, i, 1);
}

void array_delete_many(array* a, int i, int size) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (i < 0 || i + size > a->len) {
			string endidx = (size > 1 ? ( str_intp(2, _MOV((StrIntpData[]){{_SLIT(".."), 0xfe07, {.d_i32 = i + size}}, {_SLIT0, 0, { .d_c = 0 }}}))) : (_SLIT("")));
			_v_panic( str_intp(4, _MOV((StrIntpData[]){{_SLIT("array.delete: index out of range (i == "), 0xfe07, {.d_i32 = i}}, {_SLIT0, 0xfe10, {.d_s = endidx}}, {_SLIT(", a.len == "), 0xfe07, {.d_i32 = a->len}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		}
	}
	#endif
	voidptr old_data = a->data;
	int new_size = a->len - size;
	int new_cap = (new_size == 0 ? (1) : (new_size));
	a->data = vcalloc(new_cap * a->element_size);
	vmemcpy(a->data, old_data, i * a->element_size);
	vmemcpy(((byte*)(a->data)) + i * a->element_size, ((byte*)(old_data)) + (i + size) * a->element_size, (a->len - i - size) * a->element_size);
	if (ArrayFlags_has(&a->flags, ArrayFlags__noslices)) {
		_v_free(old_data);
	}
	a->len = new_size;
	a->cap = new_cap;
}

void array_clear(array* a) {
	a->len = 0;
}

void array_trim(array* a, int index) {
	if (index < a->len) {
		a->len = index;
	}
}

// Attr: [inline]
// Attr: [unsafe]
inline VV_LOCAL_SYMBOL voidptr array_get_unsafe(array a, int i) {
	{ // Unsafe block
		return ((byte*)(a.data)) + i * a.element_size;
	}
	return 0;
}

VV_LOCAL_SYMBOL voidptr array_get(array a, int i) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (i < 0 || i >= a.len) {
			_v_panic( str_intp(3, _MOV((StrIntpData[]){{_SLIT("array.get: index out of range (i == "), 0xfe07, {.d_i32 = i}}, {_SLIT(", a.len == "), 0xfe07, {.d_i32 = a.len}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		}
	}
	#endif
	{ // Unsafe block
		return ((byte*)(a.data)) + i * a.element_size;
	}
	return 0;
}

VV_LOCAL_SYMBOL voidptr array_get_with_check(array a, int i) {
	if (i < 0 || i >= a.len) {
		return 0;
	}
	{ // Unsafe block
		return ((byte*)(a.data)) + i * a.element_size;
	}
	return 0;
}

voidptr array_first(array a) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (a.len == 0) {
			_v_panic(_SLIT("array.first: array is empty"));
			VUNREACHABLE();
		}
	}
	#endif
	return a.data;
}

voidptr array_last(array a) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (a.len == 0) {
			_v_panic(_SLIT("array.last: array is empty"));
			VUNREACHABLE();
		}
	}
	#endif
	{ // Unsafe block
		return ((byte*)(a.data)) + (a.len - 1) * a.element_size;
	}
	return 0;
}

voidptr array_pop(array* a) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (a->len == 0) {
			_v_panic(_SLIT("array.pop: array is empty"));
			VUNREACHABLE();
		}
	}
	#endif
	int new_len = a->len - 1;
	byte* last_elem = ((byte*)(a->data)) + new_len * a->element_size;
	a->len = new_len;
	return memdup(last_elem, a->element_size);
}

void array_delete_last(array* a) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (a->len == 0) {
			_v_panic(_SLIT("array.pop: array is empty"));
			VUNREACHABLE();
		}
	}
	#endif
	a->len--;
}

VV_LOCAL_SYMBOL array array_slice(array a, int start, int _end) {
	int end = _end;
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (start > end) {
			_v_panic( str_intp(3, _MOV((StrIntpData[]){{_SLIT("array.slice: invalid slice index ("), 0xfe07, {.d_i32 = start}}, {_SLIT(" > "), 0xfe07, {.d_i32 = end}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		}
		if (end > a.len) {
			_v_panic( str_intp(3, _MOV((StrIntpData[]){{_SLIT("array.slice: slice bounds out of range ("), 0xfe07, {.d_i32 = end}}, {_SLIT(" >= "), 0xfe07, {.d_i32 = a.len}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		}
		if (start < 0) {
			_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("array.slice: slice bounds out of range ("), 0xfe07, {.d_i32 = start}}, {_SLIT(" < 0)"), 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		}
	}
	#endif
	int offset = start * a.element_size;
	byte* data = ((byte*)(a.data)) + offset;
	int l = end - start;
	array res = (array){.element_size = a.element_size,.data = data,.offset = a.offset + offset,.len = l,.cap = l,.flags = 0,};
	return res;
}

VV_LOCAL_SYMBOL array array_slice_ni(array a, int _start, int _end) {
	int end = _end;
	int start = _start;
	if (start < 0) {
		start = a.len + start;
		if (start < 0) {
			start = 0;
		}
	}
	if (end < 0) {
		end = a.len + end;
		if (end < 0) {
			end = 0;
		}
	}
	if (end >= a.len) {
		end = a.len;
	}
	if (start >= a.len || start > end) {
		array res = (array){.element_size = a.element_size,.data = a.data,.offset = 0,.len = 0,.cap = 0,.flags = 0,};
		return res;
	}
	int offset = start * a.element_size;
	byte* data = ((byte*)(a.data)) + offset;
	int l = end - start;
	array res = (array){.element_size = a.element_size,.data = data,.offset = a.offset + offset,.len = l,.cap = l,.flags = 0,};
	return res;
}

VV_LOCAL_SYMBOL array array_slice2(array a, int start, int _end, bool end_max) {
	int end = (end_max ? (a.len) : (_end));
	return array_slice(a, start, end);
}

VV_LOCAL_SYMBOL array array_clone_static_to_depth(array a, int depth) {
	return array_clone_to_depth(&a, depth);
}

array array_clone(array* a) {
	return array_clone_to_depth(a, 0);
}

// Attr: [unsafe]
array array_clone_to_depth(array* a, int depth) {
	int size = a->cap * a->element_size;
	if (size == 0) {
		size++;
	}
	array arr = (array){.element_size = a->element_size,.data = vcalloc(size),.offset = 0,.len = a->len,.cap = a->cap,.flags = 0,};
	if (depth > 0 && _us32_eq(sizeof(array),a->element_size) && a->len >= 0 && a->cap >= a->len) {
		for (int i = 0; i < a->len; ++i) {
			array ar = (array){.element_size = 0,.data = 0,.offset = 0,.len = 0,.cap = 0,.flags = 0,};
			vmemcpy(&ar, array_get_unsafe(/*rec*/*a, i), ((int)(sizeof(array))));
			array ar_clone = array_clone_to_depth(&ar, depth - 1);
			array_set_unsafe(&arr, i, &ar_clone);
		}
		return arr;
	} else {
		if (!isnil(a->data)) {
			vmemcpy(((byte*)(arr.data)), a->data, a->cap * a->element_size);
		}
		return arr;
	}
	return (array){.element_size = 0,.data = 0,.offset = 0,.len = 0,.cap = 0,};
}

// Attr: [inline]
// Attr: [unsafe]
inline VV_LOCAL_SYMBOL void array_set_unsafe(array* a, int i, voidptr val) {
	vmemcpy(((byte*)(a->data)) + a->element_size * i, val, a->element_size);
}

VV_LOCAL_SYMBOL void array_set(array* a, int i, voidptr val) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (i < 0 || i >= a->len) {
			_v_panic( str_intp(3, _MOV((StrIntpData[]){{_SLIT("array.set: index out of range (i == "), 0xfe07, {.d_i32 = i}}, {_SLIT(", a.len == "), 0xfe07, {.d_i32 = a->len}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		}
	}
	#endif
	vmemcpy(((byte*)(a->data)) + a->element_size * i, val, a->element_size);
}

VV_LOCAL_SYMBOL void array_push(array* a, voidptr val) {
	array_ensure_cap(a, a->len + 1);
	vmemmove(((byte*)(a->data)) + a->element_size * a->len, val, a->element_size);
	a->len++;
}

// Attr: [unsafe]
void array_push_many(array* a3, voidptr val, int size) {
	if (a3->data == val && !isnil(a3->data)) {
		array copy = array_clone(a3);
		array_ensure_cap(a3, a3->len + size);
		vmemcpy(array_get_unsafe(/*rec*/*a3, a3->len), copy.data, a3->element_size * size);
	} else {
		array_ensure_cap(a3, a3->len + size);
		if (!isnil(a3->data) && !isnil(val)) {
			vmemcpy(array_get_unsafe(/*rec*/*a3, a3->len), val, a3->element_size * size);
		}
	}
	a3->len += size;
}

void array_reverse_in_place(array* a) {
	if (a->len < 2) {
		return;
	}
	{ // Unsafe block
		byte* tmp_value = _v_malloc(a->element_size);
		for (int i = 0; i < a->len / 2; ++i) {
			vmemcpy(tmp_value, ((byte*)(a->data)) + i * a->element_size, a->element_size);
			vmemcpy(((byte*)(a->data)) + i * a->element_size, ((byte*)(a->data)) + (a->len - 1 - i) * a->element_size, a->element_size);
			vmemcpy(((byte*)(a->data)) + (a->len - 1 - i) * a->element_size, tmp_value, a->element_size);
		}
		_v_free(tmp_value);
	}
}

array array_reverse(array a) {
	if (a.len < 2) {
		return a;
	}
	array arr = (array){.element_size = a.element_size,.data = vcalloc(a.cap * a.element_size),.offset = 0,.len = a.len,.cap = a.cap,.flags = 0,};
	for (int i = 0; i < a.len; ++i) {
		array_set_unsafe(&arr, i, array_get_unsafe(a, a.len - 1 - i));
	}
	return arr;
}

// Attr: [unsafe]
void array_free(array* a) {
	byte* mblock_ptr = ((byte*)(((u64)(a->data)) - ((u64)(a->offset))));
	_v_free(mblock_ptr);
}

array array_filter(array a, bool (*predicate)(voidptr ));

bool array_any(array a, bool (*predicate)(voidptr ));

bool array_all(array a, bool (*predicate)(voidptr ));

array array_map(array a, voidptr (*callback)(voidptr ));

void array_sort(array* a, int (*callback)(voidptr , voidptr ));

bool array_contains(array a, voidptr val);

int array_index(array a, voidptr value);

// Attr: [unsafe]
void Array_string_free(Array_string* a) {
	for (int _t1 = 0; _t1 < a->len; ++_t1) {
		string s = ((string*)a->data)[_t1];
		string_free(&s);
	}
	array_free((((array*)(a))));
}

// Attr: [manualfree]
string Array_string_str(Array_string a) {
	int sb_len = 4;
	if (a.len > 0) {
		sb_len += (*(string*)/*ee elem_typ */array_get(a, 0)).len;
		sb_len *= a.len;
	}
	sb_len += 2;
	strings__Builder sb = strings__new_builder(sb_len);
	strings__Builder_write_b(&sb, '[');
	for (int i = 0; i < a.len; ++i) {
		string val = (*(string*)/*ee elem_typ */array_get(a, i));
		strings__Builder_write_b(&sb, '\'');
		strings__Builder_write_string(&sb, val);
		strings__Builder_write_b(&sb, '\'');
		if (i < a.len - 1) {
			strings__Builder_write_string(&sb, _SLIT(", "));
		}
	}
	strings__Builder_write_b(&sb, ']');
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}

string Array_byte_hex(Array_byte b) {
	byte* hex = _v_malloc(b.len * 2 + 1);
	int dst_i = 0;
	for (int _t1 = 0; _t1 < b.len; ++_t1) {
		byte i = ((byte*)b.data)[_t1];
		byte n0 = i >> 4;
		{ // Unsafe block
			hex[dst_i] = (n0 < 10 ? (n0 + '0') : (n0 + ((byte)(87))));
			dst_i++;
		}
		byte n1 = (i & 0xF);
		{ // Unsafe block
			hex[dst_i] = (n1 < 10 ? (n1 + '0') : (n1 + ((byte)(87))));
			dst_i++;
		}
	}
	{ // Unsafe block
		hex[dst_i] = 0;
		return tos(hex, dst_i);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

int copy(Array_byte dst, Array_byte src) {
	int min = (dst.len < src.len ? (dst.len) : (src.len));
	if (min > 0) {
		vmemcpy(((byte*)(dst.data)), src.data, min);
	}
	return min;
}

int Array_int_reduce(Array_int a, int (*iter)(int , int ), int accum_start) {
	int accum_ = accum_start;
	for (int _t1 = 0; _t1 < a.len; ++_t1) {
		int i = ((int*)a.data)[_t1];
		accum_ = iter(accum_, i);
	}
	return accum_;
}

void array_grow_cap(array* a, int amount) {
	array_ensure_cap(a, a->cap + amount);
}

// Attr: [unsafe]
void array_grow_len(array* a, int amount) {
	array_ensure_cap(a, a->len + amount);
	a->len += amount;
}

// Attr: [unsafe]
Array_voidptr array_pointers(array a) {
	Array_voidptr res = __new_array_with_default(0, 0, sizeof(voidptr), 0);
	for (int i = 0; i < a.len; ++i) {
		array_push((array*)&res, _MOV((voidptr[]){ array_get_unsafe(a, i) }));
	}
	return res;
}

// Attr: [unsafe]
Array_byte voidptr_vbytes(voidptr data, int len) {
	array res = (array){.element_size = 1,.data = data,.offset = 0,.len = len,.cap = len,.flags = 0,};
	return res;
}

// Attr: [unsafe]
Array_byte byte_vbytes(byte* data, int len) {
	return voidptr_vbytes(((voidptr)(data)), len);
}

// Attr: [inline]
inline bool ArrayFlags_is_empty(ArrayFlags* e) {
	return ((int)(*e)) == 0;
}

// Attr: [inline]
inline bool ArrayFlags_has(ArrayFlags* e, ArrayFlags flag) {
	return ((((int)(*e)) & (((int)(flag))))) != 0;
}

// Attr: [inline]
inline bool ArrayFlags_all(ArrayFlags* e, ArrayFlags flag) {
	return ((((int)(*e)) & (((int)(flag))))) == ((int)(flag));
}

// Attr: [inline]
inline void ArrayFlags_set(ArrayFlags* e, ArrayFlags flag) {
	{ // Unsafe block
		*e = ((ArrayFlags)((((int)(*e)) | (((int)(flag))))));
	}
}

// Attr: [inline]
inline void ArrayFlags_clear(ArrayFlags* e, ArrayFlags flag) {
	{ // Unsafe block
		*e = ((ArrayFlags)((((int)(*e)) & ~(((int)(flag))))));
	}
}

// Attr: [inline]
inline void ArrayFlags_toggle(ArrayFlags* e, ArrayFlags flag) {
	{ // Unsafe block
		*e = ((ArrayFlags)((((int)(*e)) ^ (((int)(flag))))));
	}
}

VV_LOCAL_SYMBOL array __new_array_noscan(int mylen, int cap, int elm_size) {
	return (array){.element_size = 0,.data = 0,.offset = 0,.len = 0,.cap = 0,.flags = 0,};
}

// TypeDecl
// Attr: [noreturn]
VNORETURN VV_LOCAL_SYMBOL void vhalt(void) {
	for (;;) {
	}
	while(1);
}

// Attr: [noreturn]
VNORETURN void _v_exit(int code) {
	exit(code);
	VUNREACHABLE();
	while(1);
}

VV_LOCAL_SYMBOL string vcommithash(void) {
	return tos5(((char*)(V_CURRENT_COMMIT_HASH)));
}

// Attr: [noreturn]
VNORETURN VV_LOCAL_SYMBOL void panic_debug(int line_no, string file, string mod, string fn_name, string s) {
	#if defined(_VFREESTANDING)
	{
	}
	#else
	{
		eprintln(_SLIT("================ V panic ================"));
		eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("   module: "), 0xfe10, {.d_s = mod}}, {_SLIT0, 0, { .d_c = 0 }}})));
		eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT(" function: "), 0xfe10, {.d_s = fn_name}}, {_SLIT("()"), 0, { .d_c = 0 }}})));
		eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("  message: "), 0xfe10, {.d_s = s}}, {_SLIT0, 0, { .d_c = 0 }}})));
		eprintln( str_intp(3, _MOV((StrIntpData[]){{_SLIT("     file: "), 0xfe10, {.d_s = file}}, {_SLIT(":"), 0xfe07, {.d_i32 = line_no}}, {_SLIT0, 0, { .d_c = 0 }}})));
		eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("   v hash: "), 0xfe10, {.d_s = vcommithash()}}, {_SLIT0, 0, { .d_c = 0 }}})));
		eprintln(_SLIT("========================================="));
		#if defined(CUSTOM_DEFINE_exit_after_panic_message)
		{
		}
		#elif defined(CUSTOM_DEFINE_no_backtrace)
		{
		}
		#else
		{
			print_backtrace_skipping_top_frames(1);
			exit(1);
			VUNREACHABLE();
		}
		#endif
	}
	#endif
	vhalt();
	VUNREACHABLE();
	while(1);
}

// Attr: [noreturn]
VNORETURN void panic_optional_not_set(string s) {
	_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("optional not set ("), 0xfe10, {.d_s = s}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
	VUNREACHABLE();
	while(1);
}

// Attr: [noreturn]
VNORETURN void _v_panic(string s) {
	#if defined(_VFREESTANDING)
	{
	}
	#else
	{
		eprint(_SLIT("V panic: "));
		eprintln(s);
		eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("v hash: "), 0xfe10, {.d_s = vcommithash()}}, {_SLIT0, 0, { .d_c = 0 }}})));
		#if defined(CUSTOM_DEFINE_exit_after_panic_message)
		{
		}
		#elif defined(CUSTOM_DEFINE_no_backtrace)
		{
		}
		#else
		{
			print_backtrace_skipping_top_frames(1);
			exit(1);
			VUNREACHABLE();
		}
		#endif
	}
	#endif
	vhalt();
	VUNREACHABLE();
	while(1);
}

string c_error_number_str(int errnum) {
	string err_msg = _SLIT("");
	#if defined(_VFREESTANDING)
	{
	}
	#else
	{
		#if !defined(__vinix__)
		{
			char* c_msg = strerror(errnum);
			err_msg = (string){.str = ((byte*)(c_msg)), .len = strlen(c_msg), .is_lit = 1};
		}
		#endif
	}
	#endif
	return err_msg;
}

// Attr: [noreturn]
VNORETURN void panic_error_number(string basestr, int errnum) {
	_v_panic(string__plus(basestr, c_error_number_str(errnum)));
	VUNREACHABLE();
	while(1);
}

void eprintln(string s) {
	if (s.str == 0) {
		eprintln(_SLIT("eprintln(NIL)"));
		return;
	}
	#if defined(_VFREESTANDING)
	{
	}
	#elif defined(__TARGET_IOS__)
	{
	}
	#else
	{
		fflush(stdout);
		fflush(stderr);
		_writeln_to_fd(2, s);
		fflush(stderr);
	}
	#endif
}

void eprint(string s) {
	if (s.str == 0) {
		eprint(_SLIT("eprint(NIL)"));
		return;
	}
	#if defined(_VFREESTANDING)
	{
	}
	#elif defined(__TARGET_IOS__)
	{
	}
	#else
	{
		fflush(stdout);
		fflush(stderr);
		_write_buf_to_fd(2, s.str, s.len);
		fflush(stderr);
	}
	#endif
}

void flush_stdout(void) {
	#if defined(_VFREESTANDING)
	{
	}
	#else
	{
		fflush(stdout);
	}
	#endif
}

void flush_stderr(void) {
	#if defined(_VFREESTANDING)
	{
	}
	#else
	{
		fflush(stderr);
	}
	#endif
}

// Attr: [manualfree]
void print(string s) {
	#if defined(__TARGET_IOS__)
	{
	}
	#elif defined(_VFREESTANDING)
	{
	}
	#else
	{
		_write_buf_to_fd(1, s.str, s.len);
	}
	#endif
}

// Attr: [manualfree]
void println(string s) {
	if (s.str == 0) {
		println(_SLIT("println(NIL)"));
		return;
	}
	#if defined(__TARGET_IOS__)
	{
	}
	#elif defined(_VFREESTANDING)
	{
	}
	#else
	{
		_writeln_to_fd(1, s);
	}
	#endif
}

// Attr: [manualfree]
VV_LOCAL_SYMBOL void _writeln_to_fd(int fd, string s) {
bool _writeln_to_fd_defer_0 = false;
byte* buf;
	{ // Unsafe block
		int buf_len = s.len + 1;
		buf = _v_malloc(buf_len);
		_writeln_to_fd_defer_0 = true;
		memcpy(buf, s.str, s.len);
		buf[s.len] = '\n';
		_write_buf_to_fd(fd, buf, buf_len);
	}
// Defer begin
if (_writeln_to_fd_defer_0) {
	_v_free(buf);
}
// Defer end
}

// Attr: [manualfree]
VV_LOCAL_SYMBOL void _write_buf_to_fd(int fd, byte* buf, int buf_len) {
	if (buf_len <= 0) {
		return;
	}
	{ // Unsafe block
		byte* ptr = buf;
		int remaining_bytes = buf_len;
		for (;;) {
			if (!(remaining_bytes > 0)) break;
			int x = write(fd, ptr, remaining_bytes);
			ptr += x;
			remaining_bytes -= x;
		}
	}
}

// Attr: [unsafe]
byte* _v_malloc(int n) {
	if (n <= 0) {
		_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("malloc("), 0xfe07, {.d_i32 = n}}, {_SLIT(" <= 0)"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	byte* res = ((byte*)(0));
	#if defined(_VPREALLOC)
	{
	}
	#elif defined(_VGCBOEHM)
	{
	}
	#elif defined(_VFREESTANDING)
	{
	}
	#else
	{
		res = malloc(n);
	}
	#endif
	if (res == 0) {
		_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("malloc("), 0xfe07, {.d_i32 = n}}, {_SLIT(") failed"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	return res;
}

// Attr: [unsafe]
byte* malloc_noscan(int n) {
	if (n <= 0) {
		_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("malloc_noscan("), 0xfe07, {.d_i32 = n}}, {_SLIT(" <= 0)"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	byte* res = ((byte*)(0));
	#if defined(_VPREALLOC)
	{
	}
	#elif defined(_VGCBOEHM)
	{
	}
	#elif defined(_VFREESTANDING)
	{
	}
	#else
	{
		res = malloc(n);
	}
	#endif
	if (res == 0) {
		_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("malloc_noscan("), 0xfe07, {.d_i32 = n}}, {_SLIT(") failed"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	return res;
}

// Attr: [unsafe]
byte* v_realloc(byte* b, int n) {
	byte* new_ptr = ((byte*)(0));
	#if defined(_VPREALLOC)
	{
	}
	#elif defined(_VGCBOEHM)
	{
	}
	#else
	{
		new_ptr = realloc(b, n);
	}
	#endif
	if (new_ptr == 0) {
		_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("realloc("), 0xfe07, {.d_i32 = n}}, {_SLIT(") failed"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	return new_ptr;
}

// Attr: [unsafe]
byte* realloc_data(byte* old_data, int old_size, int new_size) {
	byte* nptr = ((byte*)(0));
	#if defined(_VGCBOEHM)
	{
	}
	#else
	{
		nptr = realloc(old_data, new_size);
	}
	#endif
	if (nptr == 0) {
		_v_panic( str_intp(4, _MOV((StrIntpData[]){{_SLIT("realloc_data("), 0xfe11, {.d_p = (void*)(old_data)}}, {_SLIT(", "), 0xfe07, {.d_i32 = old_size}}, {_SLIT(", "), 0xfe07, {.d_i32 = new_size}}, {_SLIT(") failed"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	return nptr;
}

byte* vcalloc(int n) {
	if (n < 0) {
		_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("calloc("), 0xfe07, {.d_i32 = n}}, {_SLIT(" < 0)"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	} else if (n == 0) {
		return ((byte*)(0));
	}
	#if defined(_VPREALLOC)
	{
	}
	#elif defined(_VGCBOEHM)
	{
	}
	#else
	{
		return calloc(1, n);
	}
	#endif
	return 0;
}

byte* vcalloc_noscan(int n) {
	#if defined(_VPREALLOC)
	{
	}
	#elif defined(_VGCBOEHM)
	{
	}
	#else
	{
		return vcalloc(n);
	}
	#endif
	return 0;
}

// Attr: [unsafe]
void _v_free(voidptr ptr) {
	#if defined(_VPREALLOC)
	{
	}
	#elif defined(_VGCBOEHM)
	{
	}
	#else
	{
		free(ptr);
	}
	#endif
}

// Attr: [unsafe]
voidptr memdup(voidptr src, int sz) {
	if (sz == 0) {
		return vcalloc(1);
	}
	{ // Unsafe block
		byte* mem = _v_malloc(sz);
		return memcpy(mem, src, sz);
	}
	return 0;
}

// Attr: [unsafe]
voidptr memdup_noscan(voidptr src, int sz) {
	if (sz == 0) {
		return vcalloc_noscan(1);
	}
	{ // Unsafe block
		byte* mem = malloc_noscan(sz);
		return memcpy(mem, src, sz);
	}
	return 0;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL int v_fixed_index(int i, int len) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (i < 0 || i >= len) {
			string s =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("fixed array index out of range (index: "), 0xfe07, {.d_i32 = i}}, {_SLIT(", len: "), 0xfe07, {.d_i32 = len}}, {_SLIT(")"), 0, { .d_c = 0 }}}));
			_v_panic(s);
			VUNREACHABLE();
		}
	}
	#endif
	return i;
}

void print_backtrace(void) {
	#if !defined(CUSTOM_DEFINE_no_backtrace)
	{
		#if defined(_VFREESTANDING)
		{
		}
		#else
		{
			#if defined(__TINYC__)
			{
			}
			#else
			{
				print_backtrace_skipping_top_frames(2);
			}
			#endif
		}
		#endif
	}
	#endif
}

// Attr: [inline]
inline bool isnil(voidptr v) {
	return v == 0;
}

VV_LOCAL_SYMBOL voidptr __as_cast(voidptr obj, int obj_type, int expected_type) {
	if (obj_type != expected_type) {
		string obj_name = string_clone((*(VCastTypeIndexName*)/*ee elem_typ */array_get(as_cast_type_indexes, 0)).tname);
		string expected_name = string_clone((*(VCastTypeIndexName*)/*ee elem_typ */array_get(as_cast_type_indexes, 0)).tname);
		for (int _t1 = 0; _t1 < as_cast_type_indexes.len; ++_t1) {
			VCastTypeIndexName x = ((VCastTypeIndexName*)as_cast_type_indexes.data)[_t1];
			if (x.tindex == obj_type) {
				obj_name = string_clone(x.tname);
			}
			if (x.tindex == expected_type) {
				expected_name = string_clone(x.tname);
			}
		}
		_v_panic( str_intp(3, _MOV((StrIntpData[]){{_SLIT("as cast: cannot cast `"), 0xfe10, {.d_s = obj_name}}, {_SLIT("` to `"), 0xfe10, {.d_s = expected_name}}, {_SLIT("`"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	return obj;
}

// Attr: [manualfree]
// Attr: [unsafe]
void VAssertMetaInfo_free(VAssertMetaInfo* ami) {
	{ // Unsafe block
		string_free(&ami->fpath);
		string_free(&ami->fn_name);
		string_free(&ami->src);
		string_free(&ami->op);
		string_free(&ami->llabel);
		string_free(&ami->rlabel);
		string_free(&ami->lvalue);
		string_free(&ami->rvalue);
	}
}

VV_LOCAL_SYMBOL void __print_assert_failure(VAssertMetaInfo* i) {
	eprintln( str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = i->fpath}}, {_SLIT(":"), 0xfe07, {.d_i32 = i->line_nr + 1}}, {_SLIT(": FAIL: fn "), 0xfe10, {.d_s = i->fn_name}}, {_SLIT(": assert "), 0xfe10, {.d_s = i->src}}, {_SLIT0, 0, { .d_c = 0 }}})));
	if (i->op.len > 0 && !string__eq(i->op, _SLIT("call"))) {
		eprintln( str_intp(3, _MOV((StrIntpData[]){{_SLIT("   left value: "), 0xfe10, {.d_s = i->llabel}}, {_SLIT(" = "), 0xfe10, {.d_s = i->lvalue}}, {_SLIT0, 0, { .d_c = 0 }}})));
		if (string__eq(i->rlabel, i->rvalue)) {
			eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("  right value: "), 0xfe10, {.d_s = i->rlabel}}, {_SLIT0, 0, { .d_c = 0 }}})));
		} else {
			eprintln( str_intp(3, _MOV((StrIntpData[]){{_SLIT("  right value: "), 0xfe10, {.d_s = i->rlabel}}, {_SLIT(" = "), 0xfe10, {.d_s = i->rvalue}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
	}
}

// Attr: [markused]
VV_LOCAL_SYMBOL void v_segmentation_fault_handler(int signal) {
	eprintln(_SLIT("signal 11: segmentation fault"));
	print_backtrace();
	_v_exit(128 + 11);
	VUNREACHABLE();
}

void gc_check_leaks(void) {
}

VV_LOCAL_SYMBOL void restore_codepage(void) {
	SetConsoleOutputCP(g_original_codepage);
}

VV_LOCAL_SYMBOL int is_terminal(int fd) {
	u32 mode = ((u32)(0U));
	voidptr osfh = ((voidptr)(_get_osfhandle(fd)));
	GetConsoleMode(osfh, ((voidptr)(&mode)));
	return ((int)(mode));
}

VV_LOCAL_SYMBOL void builtin_init(void) {
	g_original_codepage = GetConsoleOutputCP();
	SetConsoleOutputCP(CP_UTF8);
	atexit((voidptr)restore_codepage);
	if (is_terminal(1) > 0) {
		SetConsoleMode(GetStdHandle(STD_OUTPUT_HANDLE), ((ENABLE_PROCESSED_OUTPUT | ENABLE_WRAP_AT_EOL_OUTPUT) | 0x0004));
		SetConsoleMode(GetStdHandle(STD_ERROR_HANDLE), ((ENABLE_PROCESSED_OUTPUT | ENABLE_WRAP_AT_EOL_OUTPUT) | 0x0004));
		{ // Unsafe block
			setbuf(stdout, 0);
			setbuf(stderr, 0);
		}
	}
	#if !defined(CUSTOM_DEFINE_no_backtrace)
	{
		add_unhandled_exception_handler();
	}
	#endif
}

VV_LOCAL_SYMBOL bool print_backtrace_skipping_top_frames(int skipframes) {
	#if defined(__MINGW32__)
	{
		return print_backtrace_skipping_top_frames_mingw(skipframes);
	}
	#endif
	eprintln(_SLIT("print_backtrace_skipping_top_frames is not implemented"));
	return false;
}

VV_LOCAL_SYMBOL bool print_backtrace_skipping_top_frames_msvc(int skipframes) {
	#if defined(_MSC_VER)
	{
	}
	#else
	{
		eprintln(_SLIT("print_backtrace_skipping_top_frames_msvc must be called only when the compiler is msvc"));
		return false;
	}
	#endif
	return 0;
}

VV_LOCAL_SYMBOL bool print_backtrace_skipping_top_frames_mingw(int skipframes) {
	eprintln(_SLIT("print_backtrace_skipping_top_frames_mingw is not implemented"));
	return false;
}

VV_LOCAL_SYMBOL bool print_backtrace_skipping_top_frames_tcc(int skipframes) {
	#if defined(__TINYC__)
	{
	}
	#else
	{
		eprintln(_SLIT("print_backtrace_skipping_top_frames_tcc must be called only when the compiler is tcc"));
		return false;
	}
	#endif
	return false;
}

// TypeDecl
VV_LOCAL_SYMBOL void add_vectored_exception_handler(int (*handler)(ExceptionPointers* )) {
	AddVectoredExceptionHandler(1, ((PVECTORED_EXCEPTION_HANDLER)(handler)));
}

// Attr: [windows_stdcall]
VV_LOCAL_SYMBOL int __stdcall unhandled_exception_handler(ExceptionPointers* e) {

	if (e->exception_record->code == (0x4001000A) || e->exception_record->code == (0x40010006)) {
		return 0;
	}
	else {
		println( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Unhandled Exception 0x"), 0x7000fe86, {.d_u32 = e->exception_record->code}}, {_SLIT0, 0, { .d_c = 0 }}})));
		print_backtrace_skipping_top_frames(5);
	};
	return 0;
}

VV_LOCAL_SYMBOL void add_unhandled_exception_handler(void) {
	add_vectored_exception_handler((voidptr)((VectoredExceptionHandler)(((voidptr)(unhandled_exception_handler)))));
}

VV_LOCAL_SYMBOL void break_if_debugger_attached(void) {
	#if defined(__TINYC__)
	{
	}
	#else
	{
		if (IsDebuggerPresent()) {
			__debugbreak();
		}
	}
	#endif
}

string winapi_lasterr_str(void) {
	u32 err_msg_id = GetLastError();
	if (err_msg_id == 8U) {
		return _SLIT("insufficient memory");
	}
	u16* msgbuf = ((u16*)(0));
	voidptr res = FormatMessage(((FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM) | FORMAT_MESSAGE_IGNORE_INSERTS), NULL, err_msg_id, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), &msgbuf, 0, NULL);
	string err_msg = (res == 0 ? ( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Win-API error "), 0xfe06, {.d_u32 = err_msg_id}}, {_SLIT0, 0, { .d_c = 0 }}}))) : (string_from_wide(msgbuf)));
	return err_msg;
}

// Attr: [noreturn]
VNORETURN void panic_lasterr(string base) {
	_v_panic(string__plus(base, winapi_lasterr_str()));
	VUNREACHABLE();
	while(1);
}

// Attr: [trusted]
// Attr: [noreturn]
// Attr: [trusted]
// Attr: [trusted]
int proc_pidpath(int , voidptr , int );

// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [inline]
// Attr: [unsafe]
inline int vstrlen(byte* s) {
	return strlen(((char*)(s)));
}

// Attr: [inline]
// Attr: [unsafe]
inline int vstrlen_char(char* s) {
	return strlen(s);
}

// Attr: [inline]
// Attr: [unsafe]
inline voidptr vmemcpy(voidptr dest, const voidptr const_src, int n) {
	{ // Unsafe block
		return memcpy(dest, const_src, n);
	}
	return 0;
}

// Attr: [inline]
// Attr: [unsafe]
inline voidptr vmemmove(voidptr dest, const voidptr const_src, int n) {
	{ // Unsafe block
		return memmove(dest, const_src, n);
	}
	return 0;
}

// Attr: [inline]
// Attr: [unsafe]
inline int vmemcmp(const voidptr const_s1, const voidptr const_s2, int n) {
	{ // Unsafe block
		return memcmp(const_s1, const_s2, n);
	}
	return 0;
}

// Attr: [inline]
// Attr: [unsafe]
inline voidptr vmemset(voidptr s, int c, int n) {
	{ // Unsafe block
		return memset(s, c, n);
	}
	return 0;
}

// TypeDecl
// Attr: [inline]
// Attr: [unsafe]
inline VV_LOCAL_SYMBOL void vqsort(voidptr base, usize nmemb, usize size, int (*sort_cb)(const voidptr const_a, const voidptr const_b)) {
	qsort(base, nmemb, size, ((voidptr)(sort_cb)));
}

void chan_close(chan ch) {
}

ChanState chan_try_pop(chan ch, voidptr obj) {
	return ChanState__success;
}

ChanState chan_try_push(chan ch, voidptr obj) {
	return ChanState__success;
}

// Attr: [inline]
inline string f64_str(f64 x) {
	{ // Unsafe block
		strconv__Float64u f = (strconv__Float64u){.f = x,};
		if (f.u == _const_strconv__double_minus_zero) {
			return _SLIT("-0");
		}
		if (f.u == _const_strconv__double_plus_zero) {
			return _SLIT("0");
		}
	}
	f64 abs_x = f64_abs(x);
	if (abs_x >= 0.0001 && abs_x < 1.0e6) {
		return strconv__f64_to_str_l(x);
	} else {
		return strconv__ftoa_64(x);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [inline]
inline string f64_strg(f64 x) {
	if (x == 0) {
		return _SLIT("0");
	}
	f64 abs_x = f64_abs(x);
	if (abs_x >= 0.0001 && abs_x < 1.0e6) {
		return strconv__f64_to_str_l_no_dot(x);
	} else {
		return strconv__ftoa_64(x);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [inline]
inline string float_literal_str(float_literal d) {
	return f64_str(((f64)(d)));
}

// Attr: [inline]
inline string f64_strsci(f64 x, int digit_num) {
	int n_digit = digit_num;
	if (n_digit < 1) {
		n_digit = 1;
	} else if (n_digit > 17) {
		n_digit = 17;
	}
	return strconv__f64_to_str(x, n_digit);
}

// Attr: [inline]
inline string f64_strlong(f64 x) {
	return strconv__f64_to_str_l(x);
}

// Attr: [inline]
inline string f32_str(f32 x) {
	{ // Unsafe block
		strconv__Float32u f = (strconv__Float32u){.f = x,};
		if (f.u == _const_strconv__single_minus_zero) {
			return _SLIT("-0");
		}
		if (f.u == _const_strconv__single_plus_zero) {
			return _SLIT("0");
		}
	}
	f32 abs_x = f32_abs(x);
	if (abs_x >= 0.0001 && abs_x < 1.0e6) {
		return strconv__f32_to_str_l(x);
	} else {
		return strconv__ftoa_32(x);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [inline]
inline string f32_strg(f32 x) {
	if (x == 0) {
		return _SLIT("0");
	}
	f32 abs_x = f32_abs(x);
	if (abs_x >= 0.0001 && abs_x < 1.0e6) {
		return strconv__f32_to_str_l_no_dot(x);
	} else {
		return strconv__ftoa_32(x);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [inline]
inline string f32_strsci(f32 x, int digit_num) {
	int n_digit = digit_num;
	if (n_digit < 1) {
		n_digit = 1;
	} else if (n_digit > 8) {
		n_digit = 8;
	}
	return strconv__f32_to_str(x, n_digit);
}

// Attr: [inline]
inline string f32_strlong(f32 x) {
	return strconv__f32_to_str_l(x);
}

// Attr: [inline]
inline f32 f32_abs(f32 a) {
	return (a < 0 ? (-a) : (a));
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL f64 f64_abs(f64 a) {
	return (a < 0 ? (-a) : (a));
}

// Attr: [inline]
inline f32 f32_max(f32 a, f32 b) {
	return (a > b ? (a) : (b));
}

// Attr: [inline]
inline f32 f32_min(f32 a, f32 b) {
	return (a < b ? (a) : (b));
}

// Attr: [inline]
inline f64 f64_max(f64 a, f64 b) {
	return (a > b ? (a) : (b));
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL f64 f64_min(f64 a, f64 b) {
	return (a < b ? (a) : (b));
}

// Attr: [inline]
inline bool f32_eq_epsilon(f32 a, f32 b) {
	f32 hi = f32_max(f32_abs(a), f32_abs(b));
	f32 delta = f32_abs(a - b);
	if (hi > ((f32)(1.0))) {
		return delta <= hi * (4 * ((f32)(FLT_EPSILON)));
	} else {
		return (1 / (4 * ((f32)(FLT_EPSILON)))) * delta <= hi;
	}
	return 0;
}

// Attr: [inline]
inline bool f64_eq_epsilon(f64 a, f64 b) {
	f64 hi = f64_max(f64_abs(a), f64_abs(b));
	f64 delta = f64_abs(a - b);
	if (hi > 1.0) {
		return delta <= hi * (4 * ((f64)(DBL_EPSILON)));
	} else {
		return (1 / (4 * ((f64)(DBL_EPSILON)))) * delta <= hi;
	}
	return 0;
}

VV_LOCAL_SYMBOL void float_test(void) {
}

// TypeDecl
// TypeDecl
string ptr_str(voidptr ptr) {
	string buf1 = u64_hex(((u64)(ptr)));
	return buf1;
}

string isize_str(isize x) {
	return i64_str(((i64)(x)));
}

string usize_str(usize x) {
	return u64_str(((u64)(x)));
}

string char_str(char* cptr) {
	return u64_hex(((u64)(cptr)));
}

// Attr: [direct_array_access]
// Attr: [inline]
inline VV_LOCAL_SYMBOL string int_str_l(int nn, int max) {
	{ // Unsafe block
		i64 n = ((i64)(nn));
		int d = 0;
		if (n == 0) {
			return _SLIT("0");
		}
		bool is_neg = false;
		if (n < 0) {
			n = -n;
			is_neg = true;
		}
		int index = max;
		byte* buf = malloc_noscan(max + 1);
		buf[index] = 0;
		index--;
		for (;;) {
			if (!(n > 0)) break;
			int n1 = ((int)(n / 100));
			d = ((int)(((u32)(((int)(n)) - (n1 * 100))) << 1U));
			n = n1;
			buf[index] = _const_digit_pairs.str[d];
			index--;
			d++;
			buf[index] = _const_digit_pairs.str[d];
			index--;
		}
		index++;
		if (d < 20) {
			index++;
		}
		if (is_neg) {
			index--;
			buf[index] = '-';
		}
		int diff = max - index;
		vmemmove(buf, buf + index, diff + 1);
		return tos(buf, diff);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

string i8_str(i8 n) {
	return int_str_l(((int)(n)), 5);
}

string i16_str(i16 n) {
	return int_str_l(((int)(n)), 7);
}

string u16_str(u16 n) {
	return int_str_l(((int)(n)), 7);
}

string int_str(int n) {
	return int_str_l(n, 12);
}

// Attr: [direct_array_access]
// Attr: [inline]
inline string u32_str(u32 nn) {
	{ // Unsafe block
		u32 n = nn;
		u32 d = ((u32)(0U));
		if (n == 0U) {
			return _SLIT("0");
		}
		int max = 12;
		byte* buf = malloc_noscan(max + 1);
		int index = max;
		buf[index] = 0;
		index--;
		for (;;) {
			if (!(n > 0U)) break;
			u32 n1 = n / ((u32)(100U));
			d = ((n - (n1 * ((u32)(100U)))) << ((u32)(1U)));
			n = n1;
			buf[index] = _const_digit_pairs.str[ d];
			index--;
			d++;
			buf[index] = _const_digit_pairs.str[ d];
			index--;
		}
		index++;
		if (d < ((u32)(20U))) {
			index++;
		}
		int diff = max - index;
		vmemmove(buf, buf + index, diff + 1);
		return tos(buf, diff);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [inline]
inline string int_literal_str(int_literal n) {
	return i64_str(((i64)(n)));
}

// Attr: [direct_array_access]
// Attr: [inline]
inline string i64_str(i64 nn) {
	{ // Unsafe block
		i64 n = nn;
		i64 d = ((i64)(0));
		if (n == 0) {
			return _SLIT("0");
		}
		int max = 20;
		byte* buf = malloc_noscan(max + 1);
		bool is_neg = false;
		if (n < 0) {
			n = -n;
			is_neg = true;
		}
		int index = max;
		buf[index] = 0;
		index--;
		for (;;) {
			if (!(n > 0)) break;
			i64 n1 = n / ((i64)(100));
			d = (((u32)(n - (n1 * ((i64)(100))))) << ((i64)(1)));
			n = n1;
			buf[index] = _const_digit_pairs.str[ d];
			index--;
			d++;
			buf[index] = _const_digit_pairs.str[ d];
			index--;
		}
		index++;
		if (d < ((i64)(20))) {
			index++;
		}
		if (is_neg) {
			index--;
			buf[index] = '-';
		}
		int diff = max - index;
		vmemmove(buf, buf + index, diff + 1);
		return tos(buf, diff);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [direct_array_access]
// Attr: [inline]
inline string u64_str(u64 nn) {
	{ // Unsafe block
		u64 n = nn;
		u64 d = ((u64)(0U));
		if (n == 0U) {
			return _SLIT("0");
		}
		int max = 20;
		byte* buf = malloc_noscan(max + 1);
		int index = max;
		buf[index] = 0;
		index--;
		for (;;) {
			if (!(n > 0U)) break;
			u64 n1 = n / 100U;
			d = ((n - (n1 * 100U)) << 1U);
			n = n1;
			buf[index] = _const_digit_pairs.str[ d];
			index--;
			d++;
			buf[index] = _const_digit_pairs.str[ d];
			index--;
		}
		index++;
		if (d < 20U) {
			index++;
		}
		int diff = max - index;
		vmemmove(buf, buf + index, diff + 1);
		return tos(buf, diff);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

string bool_str(bool b) {
	if (b) {
		return _SLIT("true");
	}
	return _SLIT("false");
}

// Attr: [direct_array_access]
// Attr: [inline]
inline VV_LOCAL_SYMBOL string u64_to_hex(u64 nn, byte len) {
	u64 n = nn;
	Array_fixed_byte_17 buf = {0};
	buf[len] = 0;
	int i = 0;
	for (i = len - 1; i >= 0; i--) {
		byte d = ((byte)((n & 0xFU)));
		buf[i] = (d < 10 ? (d + '0') : (d + 87));
		n = n >> 4U;
	}
	return tos(memdup(&buf[0], len + 1), len);
}

// Attr: [direct_array_access]
// Attr: [inline]
inline VV_LOCAL_SYMBOL string u64_to_hex_no_leading_zeros(u64 nn, byte len) {
	u64 n = nn;
	Array_fixed_byte_17 buf = {0};
	buf[len] = 0;
	int i = 0;
	for (i = len - 1; i >= 0; i--) {
		byte d = ((byte)((n & 0xFU)));
		buf[i] = (d < 10 ? (d + '0') : (d + 87));
		n = n >> 4U;
		if (n == 0U) {
			break;
		}
	}
	int res_len = len - i;
	return tos(memdup(&buf[i], res_len + 1), res_len);
}

string byte_hex(byte nn) {
	if (nn == 0) {
		return _SLIT("00");
	}
	return u64_to_hex(nn, 2);
}

string i8_hex(i8 nn) {
	if (nn == 0) {
		return _SLIT("00");
	}
	return u64_to_hex(((u64)(nn)), 2);
}

string u16_hex(u16 nn) {
	if (nn == 0U) {
		return _SLIT("0");
	}
	return u64_to_hex_no_leading_zeros(nn, 4);
}

string i16_hex(i16 nn) {
	return u16_hex(((u16)(nn)));
}

string u32_hex(u32 nn) {
	if (nn == 0U) {
		return _SLIT("0");
	}
	return u64_to_hex_no_leading_zeros(nn, 8);
}

string int_hex(int nn) {
	return u32_hex(((u32)(nn)));
}

string int_hex2(int n) {
	return string__plus(_SLIT("0x"), int_hex(n));
}

string u64_hex(u64 nn) {
	if (nn == 0U) {
		return _SLIT("0");
	}
	return u64_to_hex_no_leading_zeros(nn, 16);
}

string i64_hex(i64 nn) {
	return u64_hex(((u64)(nn)));
}

string int_literal_hex(int_literal nn) {
	return u64_hex(((u64)(nn)));
}

string voidptr_str(voidptr nn) {
	return string__plus(_SLIT("0x"), u64_hex(((u64)(nn))));
}

string byteptr_str(byteptr nn) {
	return string__plus(_SLIT("0x"), u64_hex(((u64)(nn))));
}

string charptr_str(charptr nn) {
	return string__plus(_SLIT("0x"), u64_hex(((u64)(nn))));
}

string byte_hex_full(byte nn) {
	return u64_to_hex(((u64)(nn)), 2);
}

string i8_hex_full(i8 nn) {
	return u64_to_hex(((u64)(nn)), 2);
}

string u16_hex_full(u16 nn) {
	return u64_to_hex(((u64)(nn)), 4);
}

string i16_hex_full(i16 nn) {
	return u64_to_hex(((u64)(nn)), 4);
}

string u32_hex_full(u32 nn) {
	return u64_to_hex(((u64)(nn)), 8);
}

string int_hex_full(int nn) {
	return u64_to_hex(((u64)(nn)), 8);
}

string i64_hex_full(i64 nn) {
	return u64_to_hex(((u64)(nn)), 16);
}

string voidptr_hex_full(voidptr nn) {
	return u64_to_hex(((u64)(nn)), 16);
}

string int_literal_hex_full(int_literal nn) {
	return u64_to_hex(((u64)(nn)), 16);
}

string u64_hex_full(u64 nn) {
	return u64_to_hex(nn, 16);
}

string byte_str(byte b) {
	return int_str_l(((int)(b)), 7);
}

string byte_ascii_str(byte b) {
	string str = (string){.str = malloc_noscan(2), .len = 1};
	{ // Unsafe block
		str.str[0] = b;
		str.str[1] = 0;
	}
	return str;
}

string byte_str_escaped(byte b) {
	string _t1 = (string){.str=(byteptr)"", .is_lit=1};
	
	if (b == (0)) {
		_t1 = _SLIT("`\\0`");
	}
	else if (b == (7)) {
		_t1 = _SLIT("`\\a`");
	}
	else if (b == (8)) {
		_t1 = _SLIT("`\\b`");
	}
	else if (b == (9)) {
		_t1 = _SLIT("`\\t`");
	}
	else if (b == (10)) {
		_t1 = _SLIT("`\\n`");
	}
	else if (b == (11)) {
		_t1 = _SLIT("`\\v`");
	}
	else if (b == (12)) {
		_t1 = _SLIT("`\\f`");
	}
	else if (b == (13)) {
		_t1 = _SLIT("`\\r`");
	}
	else if (b == (27)) {
		_t1 = _SLIT("`\\e`");
	}
	else if ((b >= 32 && b <= 126)) {
		_t1 = byte_ascii_str(b);
	}
	else {
		_t1 = string__plus(_SLIT("0x"), byte_hex(b));
	}string str = _t1;
	return str;
}

// Attr: [inline]
inline bool byte_is_capital(byte c) {
	return c >= 'A' && c <= 'Z';
}

Array_byte Array_byte_clone(Array_byte b) {
	Array_byte res = __new_array_with_default(b.len, 0, sizeof(byte), 0);
	for (int i = 0; i < b.len; ++i) {
		array_set(&res, i, &(byte[]) { (*(byte*)/*ee elem_typ */array_get(b, i)) });
	}
	return res;
}

string Array_byte_bytestr(Array_byte b) {
	{ // Unsafe block
		byte* buf = malloc_noscan(b.len + 1);
		vmemcpy(buf, b.data, b.len);
		buf[b.len] = 0;
		return tos(buf, b.len);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

string byte_repeat(byte b, int count) {
	if (count < 0) {
		_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("byte.repeat: count is negative: "), 0xfe07, {.d_i32 = count}}, {_SLIT0, 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	} else if (count == 0) {
		return _SLIT("");
	} else if (count == 1) {
		return byte_ascii_str(b);
	}
	byte* ret = malloc_noscan(count + 1);
	for (int i = 0; i < count; ++i) {
		{ // Unsafe block
			ret[i] = b;
		}
	}
	int new_len = count;
	{ // Unsafe block
		ret[new_len] = 0;
	}
	return byte_vstring_with_len(ret, new_len);
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL bool fast_string_eq(string a, string b) {
	if (a.len != b.len) {
		return false;
	}
	{ // Unsafe block
		return memcmp(a.str, b.str, b.len) == 0;
	}
	return 0;
}

VV_LOCAL_SYMBOL u64 map_hash_string(voidptr pkey) {
	string key = *((string*)(pkey));
	return wyhash(key.str, ((u64)(key.len)), 0U, ((u64*)(_wyp)));
}

VV_LOCAL_SYMBOL u64 map_hash_int_1(voidptr pkey) {
	return wyhash64(*((byte*)(pkey)), 0U);
}

VV_LOCAL_SYMBOL u64 map_hash_int_2(voidptr pkey) {
	return wyhash64(*((u16*)(pkey)), 0U);
}

VV_LOCAL_SYMBOL u64 map_hash_int_4(voidptr pkey) {
	return wyhash64(*((u32*)(pkey)), 0U);
}

VV_LOCAL_SYMBOL u64 map_hash_int_8(voidptr pkey) {
	return wyhash64(*((u64*)(pkey)), 0U);
}

VV_LOCAL_SYMBOL void DenseArray_zeros_to_end(DenseArray* d) {
	byte* tmp_value = _v_malloc(d->value_bytes);
	byte* tmp_key = _v_malloc(d->key_bytes);
	int count = 0;
	for (int i = 0; i < d->len; ++i) {
		if (DenseArray_has_index(d, i)) {
			{ // Unsafe block
				if (count != i) {
					memcpy(tmp_key, DenseArray_key(d, count), d->key_bytes);
					memcpy(DenseArray_key(d, count), DenseArray_key(d, i), d->key_bytes);
					memcpy(DenseArray_key(d, i), tmp_key, d->key_bytes);
					memcpy(tmp_value, DenseArray_value(d, count), d->value_bytes);
					memcpy(DenseArray_value(d, count), DenseArray_value(d, i), d->value_bytes);
					memcpy(DenseArray_value(d, i), tmp_value, d->value_bytes);
				}
			}
			count++;
		}
	}
	{ // Unsafe block
		_v_free(tmp_value);
		_v_free(tmp_key);
		d->deletes = 0U;
		_v_free(d->all_deleted);
	}
	d->len = count;
	int old_cap = d->cap;
	d->cap = (count < 8 ? (8) : (count));
	{ // Unsafe block
		d->values = realloc_data(d->values, d->value_bytes * old_cap, d->value_bytes * d->cap);
		d->keys = realloc_data(d->keys, d->key_bytes * old_cap, d->key_bytes * d->cap);
	}
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL DenseArray new_dense_array(int key_bytes, int value_bytes) {
	int cap = 8;
	return (DenseArray){
		.key_bytes = key_bytes,
		.value_bytes = value_bytes,
		.cap = cap,
		.len = 0,
		.deletes = 0U,
		.all_deleted = 0,
		.values = _v_malloc(cap * value_bytes),
		.keys = _v_malloc(cap * key_bytes),
	};
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL voidptr DenseArray_key(DenseArray* d, int i) {
	return d->keys + i * d->key_bytes;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL voidptr DenseArray_value(DenseArray* d, int i) {
	return d->values + i * d->value_bytes;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL bool DenseArray_has_index(DenseArray* d, int i) {
	return d->deletes == 0U || d->all_deleted[i] == 0;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL int DenseArray_expand(DenseArray* d) {
	int old_cap = d->cap;
	int old_value_size = d->value_bytes * old_cap;
	int old_key_size = d->key_bytes * old_cap;
	if (d->cap == d->len) {
		d->cap += d->cap >> 3;
		{ // Unsafe block
			d->keys = realloc_data(d->keys, old_key_size, d->key_bytes * d->cap);
			d->values = realloc_data(d->values, old_value_size, d->value_bytes * d->cap);
			if (d->deletes != 0U) {
				d->all_deleted = realloc_data(d->all_deleted, old_cap, d->cap);
				vmemset(d->all_deleted + d->len, 0, d->cap - d->len);
			}
		}
	}
	int push_index = d->len;
	{ // Unsafe block
		if (d->deletes != 0U) {
			d->all_deleted[push_index] = 0;
		}
	}
	d->len++;
	return push_index;
}

// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
VV_LOCAL_SYMBOL bool map_eq_string(voidptr a, voidptr b) {
	return fast_string_eq(*((string*)(a)), *((string*)(b)));
}

VV_LOCAL_SYMBOL bool map_eq_int_1(voidptr a, voidptr b) {
	return *((byte*)(a)) == *((byte*)(b));
}

VV_LOCAL_SYMBOL bool map_eq_int_2(voidptr a, voidptr b) {
	return *((u16*)(a)) == *((u16*)(b));
}

VV_LOCAL_SYMBOL bool map_eq_int_4(voidptr a, voidptr b) {
	return *((u32*)(a)) == *((u32*)(b));
}

VV_LOCAL_SYMBOL bool map_eq_int_8(voidptr a, voidptr b) {
	return *((u64*)(a)) == *((u64*)(b));
}

VV_LOCAL_SYMBOL void map_clone_string(voidptr dest, voidptr pkey) {
	{ // Unsafe block
		string s = *((string*)(pkey));
		(*((string*)(dest))) = string_clone(s);
	}
}

VV_LOCAL_SYMBOL void map_clone_int_1(voidptr dest, voidptr pkey) {
	{ // Unsafe block
		*((byte*)(dest)) = *((byte*)(pkey));
	}
}

VV_LOCAL_SYMBOL void map_clone_int_2(voidptr dest, voidptr pkey) {
	{ // Unsafe block
		*((u16*)(dest)) = *((u16*)(pkey));
	}
}

VV_LOCAL_SYMBOL void map_clone_int_4(voidptr dest, voidptr pkey) {
	{ // Unsafe block
		*((u32*)(dest)) = *((u32*)(pkey));
	}
}

VV_LOCAL_SYMBOL void map_clone_int_8(voidptr dest, voidptr pkey) {
	{ // Unsafe block
		*((u64*)(dest)) = *((u64*)(pkey));
	}
}

VV_LOCAL_SYMBOL void map_free_string(voidptr pkey) {
	string_free(ADDR(string, (*((string*)(pkey)))));
}

VV_LOCAL_SYMBOL void map_free_nop(voidptr _d1) {
}

VV_LOCAL_SYMBOL map new_map(int key_bytes, int value_bytes, u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr )) {
	int metasize = ((int)(sizeof(u32) * (_const_init_capicity + _const_extra_metas_inc)));
	bool has_string_keys = _us32_lt(sizeof(voidptr),key_bytes);
	return (map){
		.key_bytes = key_bytes,
		.value_bytes = value_bytes,
		.even_index = _const_init_even_index,
		.cached_hashbits = _const_max_cached_hashbits,
		.shift = _const_init_log_capicity,
		.key_values = new_dense_array(key_bytes, value_bytes),
		.metas = ((u32*)(vcalloc_noscan(metasize))),
		.extra_metas = _const_extra_metas_inc,
		.has_string_keys = has_string_keys,
		.hash_fn = (voidptr)hash_fn,
		.key_eq_fn = (voidptr)key_eq_fn,
		.clone_fn = (voidptr)clone_fn,
		.free_fn = (voidptr)free_fn,
		.len = 0,
	};
}

VV_LOCAL_SYMBOL map new_map_init(u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr ), int n, int key_bytes, int value_bytes, voidptr keys, voidptr values) {
	map out = new_map(key_bytes, value_bytes, (voidptr)hash_fn, (voidptr)key_eq_fn, (voidptr)clone_fn, (voidptr)free_fn);
	byte* pkey = ((byte*)(keys));
	byte* pval = ((byte*)(values));
	for (int _t1 = 0; _t1 < n; ++_t1) {
		{ // Unsafe block
			map_set(&out, pkey, pval);
			pkey = pkey + key_bytes;
			pval = pval + value_bytes;
		}
	}
	return out;
}

map map_move(map* m) {
	map r = *m;
	vmemset(m, 0, ((int)(sizeof(map))));
	return r;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL multi_return_u32_u32 map_key_to_index(map* m, voidptr pkey) {
	u64 hash = m->hash_fn(pkey);
	u64 index = (hash & m->even_index);
	u64 meta = ((((hash >> m->shift) & _const_hash_mask)) | _const_probe_inc);
	return (multi_return_u32_u32){.arg0=((u32)(index)), .arg1=((u32)(meta))};
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL multi_return_u32_u32 map_meta_less(map* m, u32 _index, u32 _metas) {
	u32 index = _index;
	u32 meta = _metas;
	for (;;) {
		if (!(meta < m->metas[index])) break;
		index += 2U;
		meta += _const_probe_inc;
	}
	return (multi_return_u32_u32){.arg0=index, .arg1=meta};
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL void map_meta_greater(map* m, u32 _index, u32 _metas, u32 kvi) {
	u32 meta = _metas;
	u32 index = _index;
	u32 kv_index = kvi;
	for (;;) {
		if (!(m->metas[index] != 0U)) break;
		if (meta > m->metas[index]) {
			{ // Unsafe block
				u32 tmp_meta = m->metas[index];
				m->metas[index] = meta;
				meta = tmp_meta;
				u32 tmp_index = m->metas[index + 1U];
				m->metas[index + 1U] = kv_index;
				kv_index = tmp_index;
			}
		}
		index += 2U;
		meta += _const_probe_inc;
	}
	{ // Unsafe block
		m->metas[index] = meta;
		m->metas[index + 1U] = kv_index;
	}
	u32 probe_count = (meta >> _const_hashbits) - 1U;
	map_ensure_extra_metas(m, probe_count);
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL void map_ensure_extra_metas(map* m, u32 probe_count) {
	if ((probe_count << 1U) == m->extra_metas) {
		u32 size_of_u32 = sizeof(u32);
		u32 old_mem_size = (m->even_index + 2U + m->extra_metas);
		m->extra_metas += _const_extra_metas_inc;
		u32 mem_size = (m->even_index + 2U + m->extra_metas);
		{ // Unsafe block
			byte* x = realloc_data(((byte*)(m->metas)), ((int)(size_of_u32 * old_mem_size)), ((int)(size_of_u32 * mem_size)));
			m->metas = ((u32*)(x));
			vmemset(m->metas + mem_size - _const_extra_metas_inc, 0, ((int)(sizeof(u32) * _const_extra_metas_inc)));
		}
		if (probe_count == 252U) {
			_v_panic(_SLIT("Probe overflow"));
			VUNREACHABLE();
		}
	}
}

VV_LOCAL_SYMBOL void map_set(map* m, voidptr key, voidptr value) {
	f32 load_factor = ((f32)(((u32)(m->len)) << 1U)) / ((f32)(m->even_index));
	if (load_factor > _const_max_load_factor) {
		map_expand(m);
	}
	multi_return_u32_u32 mr_10842 = map_key_to_index(m, key);
	u32 index = mr_10842.arg0;
	u32 meta = mr_10842.arg1;
	multi_return_u32_u32 mr_10878 = map_meta_less(m, index, meta);
	index = mr_10878.arg0;
	meta = mr_10878.arg1;
	for (;;) {
		if (!(meta == m->metas[index])) break;
		int kv_index = ((int)(m->metas[index + 1U]));
		voidptr pkey = DenseArray_key(&m->key_values, kv_index);
		if (m->key_eq_fn(key, pkey)) {
			{ // Unsafe block
				voidptr pval = DenseArray_value(&m->key_values, kv_index);
				vmemcpy(pval, value, m->value_bytes);
			}
			return;
		}
		index += 2U;
		meta += _const_probe_inc;
	}
	int kv_index = DenseArray_expand(&m->key_values);
	{ // Unsafe block
		voidptr pkey = DenseArray_key(&m->key_values, kv_index);
		voidptr pvalue = DenseArray_value(&m->key_values, kv_index);
		m->clone_fn(pkey, key);
		vmemcpy(((byte*)(pvalue)), value, m->value_bytes);
	}
	map_meta_greater(m, index, meta, ((u32)(kv_index)));
	m->len++;
}

VV_LOCAL_SYMBOL void map_expand(map* m) {
	u32 old_cap = m->even_index;
	m->even_index = ((m->even_index + 2U) << 1U) - 2U;
	if (m->cached_hashbits == 0) {
		m->shift += _const_max_cached_hashbits;
		m->cached_hashbits = _const_max_cached_hashbits;
		map_rehash(m);
	} else {
		map_cached_rehash(m, old_cap);
		m->cached_hashbits--;
	}
}

VV_LOCAL_SYMBOL void map_rehash(map* m) {
	u32 meta_bytes = sizeof(u32) * (m->even_index + 2U + m->extra_metas);
	{ // Unsafe block
		byte* x = v_realloc(((byte*)(m->metas)), ((int)(meta_bytes)));
		m->metas = ((u32*)(x));
		vmemset(m->metas, 0, ((int)(meta_bytes)));
	}
	for (int i = 0; i < m->key_values.len; i++) {
		if (!DenseArray_has_index(&m->key_values, i)) {
			continue;
		}
		voidptr pkey = DenseArray_key(&m->key_values, i);
		multi_return_u32_u32 mr_12545 = map_key_to_index(m, pkey);
		u32 index = mr_12545.arg0;
		u32 meta = mr_12545.arg1;
		multi_return_u32_u32 mr_12583 = map_meta_less(m, index, meta);
		index = mr_12583.arg0;
		meta = mr_12583.arg1;
		map_meta_greater(m, index, meta, ((u32)(i)));
	}
}

VV_LOCAL_SYMBOL void map_cached_rehash(map* m, u32 old_cap) {
	u32* old_metas = m->metas;
	int metasize = ((int)(sizeof(u32) * (m->even_index + 2U + m->extra_metas)));
	m->metas = ((u32*)(vcalloc(metasize)));
	u32 old_extra_metas = m->extra_metas;
	for (u32 i = ((u32)(0U)); i <= old_cap + old_extra_metas; i += 2U) {
		if (old_metas[i] == 0U) {
			continue;
		}
		u32 old_meta = old_metas[i];
		u32 old_probe_count = ((old_meta >> _const_hashbits) - 1U) << 1U;
		u32 old_index = ((i - old_probe_count) & (m->even_index >> 1U));
		u32 index = (((old_index | (old_meta << m->shift))) & m->even_index);
		u32 meta = (((old_meta & _const_hash_mask)) | _const_probe_inc);
		multi_return_u32_u32 mr_13382 = map_meta_less(m, index, meta);
		index = mr_13382.arg0;
		meta = mr_13382.arg1;
		u32 kv_index = old_metas[i + 1U];
		map_meta_greater(m, index, meta, kv_index);
	}
	_v_free(old_metas);
}

VV_LOCAL_SYMBOL voidptr map_get_and_set(map* m, voidptr key, voidptr zero) {
	for (;;) {
		multi_return_u32_u32 mr_13830 = map_key_to_index(m, key);
		u32 index = mr_13830.arg0;
		u32 meta = mr_13830.arg1;
		for (;;) {
			if (meta == m->metas[index]) {
				int kv_index = ((int)(m->metas[index + 1U]));
				voidptr pkey = DenseArray_key(&m->key_values, kv_index);
				if (m->key_eq_fn(key, pkey)) {
					voidptr pval = DenseArray_value(&m->key_values, kv_index);
					return ((byte*)(pval));
				}
			}
			index += 2U;
			meta += _const_probe_inc;
			if (meta > m->metas[index]) {
				break;
			}
		}
		map_set(m, key, zero);
	}
	return ((voidptr)(0));
}

VV_LOCAL_SYMBOL voidptr map_get(map* m, voidptr key, voidptr zero) {
	multi_return_u32_u32 mr_14555 = map_key_to_index(m, key);
	u32 index = mr_14555.arg0;
	u32 meta = mr_14555.arg1;
	for (;;) {
		if (meta == m->metas[index]) {
			int kv_index = ((int)(m->metas[index + 1U]));
			voidptr pkey = DenseArray_key(&m->key_values, kv_index);
			if (m->key_eq_fn(key, pkey)) {
				voidptr pval = DenseArray_value(&m->key_values, kv_index);
				return ((byte*)(pval));
			}
		}
		index += 2U;
		meta += _const_probe_inc;
		if (meta > m->metas[index]) {
			break;
		}
	}
	return zero;
}

VV_LOCAL_SYMBOL voidptr map_get_check(map* m, voidptr key) {
	multi_return_u32_u32 mr_15222 = map_key_to_index(m, key);
	u32 index = mr_15222.arg0;
	u32 meta = mr_15222.arg1;
	for (;;) {
		if (meta == m->metas[index]) {
			int kv_index = ((int)(m->metas[index + 1U]));
			voidptr pkey = DenseArray_key(&m->key_values, kv_index);
			if (m->key_eq_fn(key, pkey)) {
				voidptr pval = DenseArray_value(&m->key_values, kv_index);
				return ((byte*)(pval));
			}
		}
		index += 2U;
		meta += _const_probe_inc;
		if (meta > m->metas[index]) {
			break;
		}
	}
	return 0;
}

VV_LOCAL_SYMBOL bool map_exists(map* m, voidptr key) {
	multi_return_u32_u32 mr_15734 = map_key_to_index(m, key);
	u32 index = mr_15734.arg0;
	u32 meta = mr_15734.arg1;
	for (;;) {
		if (meta == m->metas[index]) {
			int kv_index = ((int)(m->metas[index + 1U]));
			voidptr pkey = DenseArray_key(&m->key_values, kv_index);
			if (m->key_eq_fn(key, pkey)) {
				return true;
			}
		}
		index += 2U;
		meta += _const_probe_inc;
		if (meta > m->metas[index]) {
			break;
		}
	}
	return false;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL void DenseArray_delete(DenseArray* d, int i) {
	if (d->deletes == 0U) {
		d->all_deleted = vcalloc(d->cap);
	}
	d->deletes++;
	{ // Unsafe block
		d->all_deleted[i] = 1;
	}
}

// Attr: [unsafe]
void map_delete(map* m, voidptr key) {
	multi_return_u32_u32 mr_16363 = map_key_to_index(m, key);
	u32 index = mr_16363.arg0;
	u32 meta = mr_16363.arg1;
	multi_return_u32_u32 mr_16399 = map_meta_less(m, index, meta);
	index = mr_16399.arg0;
	meta = mr_16399.arg1;
	for (;;) {
		if (!(meta == m->metas[index])) break;
		int kv_index = ((int)(m->metas[index + 1U]));
		voidptr pkey = DenseArray_key(&m->key_values, kv_index);
		if (m->key_eq_fn(key, pkey)) {
			for (;;) {
				if (!((m->metas[index + 2U] >> _const_hashbits) > 1U)) break;
				{ // Unsafe block
					m->metas[index] = m->metas[index + 2U] - _const_probe_inc;
					m->metas[index + 1U] = m->metas[index + 3U];
				}
				index += 2U;
			}
			m->len--;
			DenseArray_delete(&m->key_values, kv_index);
			{ // Unsafe block
				m->metas[index] = 0U;
				m->free_fn(pkey);
				vmemset(pkey, 0, m->key_bytes);
			}
			if (m->key_values.len <= 32) {
				return;
			}
			if (_us32_ge(m->key_values.deletes,(m->key_values.len >> 1))) {
				DenseArray_zeros_to_end(&m->key_values);
				map_rehash(m);
			}
			return;
		}
		index += 2U;
		meta += _const_probe_inc;
	}
}

array map_keys(map* m) {
	array keys = __new_array(m->len, 0, m->key_bytes);
	byte* item = ((byte*)(keys.data));
	if (m->key_values.deletes == 0U) {
		for (int i = 0; i < m->key_values.len; i++) {
			{ // Unsafe block
				voidptr pkey = DenseArray_key(&m->key_values, i);
				m->clone_fn(item, pkey);
				item = item + m->key_bytes;
			}
		}
		return keys;
	}
	for (int i = 0; i < m->key_values.len; i++) {
		if (!DenseArray_has_index(&m->key_values, i)) {
			continue;
		}
		{ // Unsafe block
			voidptr pkey = DenseArray_key(&m->key_values, i);
			m->clone_fn(item, pkey);
			item = item + m->key_bytes;
		}
	}
	return keys;
}

// Attr: [unsafe]
VV_LOCAL_SYMBOL DenseArray DenseArray_clone(DenseArray* d) {
	DenseArray res = (DenseArray){
		.key_bytes = d->key_bytes,
		.value_bytes = d->value_bytes,
		.cap = d->cap,
		.len = d->len,
		.deletes = d->deletes,
		.all_deleted = 0,
		.values = 0,
		.keys = 0,
	};
	{ // Unsafe block
		if (d->deletes != 0U) {
			res.all_deleted = memdup(d->all_deleted, d->cap);
		}
		res.keys = memdup(d->keys, d->cap * d->key_bytes);
		res.values = memdup(d->values, d->cap * d->value_bytes);
	}
	return res;
}

// Attr: [unsafe]
map map_clone(map* m) {
	int metasize = ((int)(sizeof(u32) * (m->even_index + 2U + m->extra_metas)));
	map res = (map){
		.key_bytes = m->key_bytes,
		.value_bytes = m->value_bytes,
		.even_index = m->even_index,
		.cached_hashbits = m->cached_hashbits,
		.shift = m->shift,
		.key_values = DenseArray_clone(&m->key_values),
		.metas = ((u32*)(_v_malloc(metasize))),
		.extra_metas = m->extra_metas,
		.has_string_keys = m->has_string_keys,
		.hash_fn = (voidptr)m->hash_fn,
		.key_eq_fn = (voidptr)m->key_eq_fn,
		.clone_fn = (voidptr)m->clone_fn,
		.free_fn = (voidptr)m->free_fn,
		.len = m->len,
	};
	vmemcpy(res.metas, m->metas, metasize);
	if (!m->has_string_keys) {
		return res;
	}
	for (int i = 0; i < m->key_values.len; ++i) {
		if (!DenseArray_has_index(&m->key_values, i)) {
			continue;
		}
		m->clone_fn(DenseArray_key(&res.key_values, i), DenseArray_key(&m->key_values, i));
	}
	return res;
}

// Attr: [unsafe]
void map_free(map* m) {
	_v_free(m->metas);
	if (m->key_values.deletes == 0U) {
		for (int i = 0; i < m->key_values.len; i++) {
			{ // Unsafe block
				voidptr pkey = DenseArray_key(&m->key_values, i);
				m->free_fn(pkey);
			}
		}
	} else {
		for (int i = 0; i < m->key_values.len; i++) {
			if (!DenseArray_has_index(&m->key_values, i)) {
				continue;
			}
			{ // Unsafe block
				voidptr pkey = DenseArray_key(&m->key_values, i);
				m->free_fn(pkey);
			}
		}
		_v_free(m->key_values.all_deleted);
	}
	{ // Unsafe block
		_v_free(m->key_values.keys);
		_v_free(m->key_values.values);
	}
}

// Attr: [unsafe]
void IError_free(IError* ie) {
	{ // Unsafe block
		string_free(&(*(ie->msg)));
		IError* cie = ((IError*)(ie));
		_v_free(cie->_object);
	}
}

string IError_str(IError err) {
	return ((err._typ == _IError_None___index) ? (_SLIT("none")) : (err._typ == _IError_Error_index) ? ((err._Error)->msg) : ( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = charptr_vstring_literal( /* IError */ v_typeof_interface_IError( (err)._typ ))}}, {_SLIT(": "), 0xfe10, {.d_s = (*(err.msg))}}, {_SLIT0, 0, { .d_c = 0 }}}))));
}

VV_LOCAL_SYMBOL string None___str(None__ _d1) {
	return _SLIT("none");
}

// Attr: [inline]
inline IError _v_error(string message) {
	;
	return /*&IError*/I_Error_to_Interface_IError((Error*)memdup(&(Error){.msg = message,.code = 0,}, sizeof(Error)));
}

// Attr: [inline]
inline IError error_with_code(string message, int code) {
	;
	return /*&IError*/I_Error_to_Interface_IError((Error*)memdup(&(Error){.msg = message,.code = code,}, sizeof(Error)));
}

VV_LOCAL_SYMBOL void opt_ok(voidptr data, Option* option, int size) {
	{ // Unsafe block
		*option = (Option){.state = 0,.err = _const_none__,};
		vmemcpy(((byte*)(&option->err)) + sizeof(IError), data, size);
	}
}

// Attr: [unsafe]
void Error_free(Error* e) {
	string_free(&e->msg);
}

// Attr: [unsafe]
void None___free(None__* n) {
	string_free(&n->msg);
}

string none_str(none _d2) {
	return _SLIT("none");
}

// Attr: [unsafe]
VV_LOCAL_SYMBOL VMemoryBlock* vmemory_block_new(VMemoryBlock* prev, int at_least) {
	VMemoryBlock* v = ((VMemoryBlock*)(calloc(1, sizeof(VMemoryBlock))));
	if (prev != 0) {
		v->id = prev->id + 1;
	}
	v->previous = prev;
	int block_size = (at_least < _const_prealloc_block_size ? (_const_prealloc_block_size) : (at_least));
	v->start = malloc(block_size);
	v->cap = block_size;
	v->remaining = block_size;
	v->current = v->start;
	return v;
}

// Attr: [unsafe]
VV_LOCAL_SYMBOL byte* vmemory_block_malloc(int n) {
	{ // Unsafe block
		if (g_memory_block->remaining < n) {
			g_memory_block = vmemory_block_new(g_memory_block, n);
		}
		byte* res = ((byte*)(0));
		res = g_memory_block->current;
		g_memory_block->remaining -= n;
		g_memory_block->mallocs++;
		g_memory_block->current += n;
		return res;
	}
	return 0;
}

// Attr: [unsafe]
VV_LOCAL_SYMBOL void prealloc_vinit(void) {
	{ // Unsafe block
		g_memory_block = vmemory_block_new(((voidptr)(0)), _const_prealloc_block_size);
		#if !defined(_VFREESTANDING)
		{
			atexit((voidptr)prealloc_vcleanup);
		}
		#endif
	}
}

// Attr: [unsafe]
VV_LOCAL_SYMBOL void prealloc_vcleanup(void) {
	{ // Unsafe block
		for (;;) {
			if (!(g_memory_block != 0)) break;
			free(g_memory_block->start);
			g_memory_block = g_memory_block->previous;
		}
	}
}

// Attr: [unsafe]
VV_LOCAL_SYMBOL byte* prealloc_malloc(int n) {
	return vmemory_block_malloc(n);
}

// Attr: [unsafe]
VV_LOCAL_SYMBOL byte* prealloc_realloc(byte* old_data, int old_size, int new_size) {
	byte* new_ptr = vmemory_block_malloc(new_size);
	int min_size = (old_size < new_size ? (old_size) : (new_size));
	memcpy(new_ptr, old_data, min_size);
	return new_ptr;
}

// Attr: [unsafe]
VV_LOCAL_SYMBOL byte* prealloc_calloc(int n) {
	byte* new_ptr = vmemory_block_malloc(n);
	memset(new_ptr, 0, n);
	return new_ptr;
}

string rune_str(rune c) {
	return utf32_to_str(((u32)(c)));
}

// Attr: [manualfree]
string Array_rune_string(Array_rune ra) {
	strings__Builder sb = strings__new_builder(ra.len);
	strings__Builder_write_runes(&sb, ra);
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}

string rune_repeat(rune c, int count) {
	if (count < 0) {
		_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("rune.repeat: count is negative: "), 0xfe07, {.d_i32 = count}}, {_SLIT0, 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	} else if (count == 0) {
		return _SLIT("");
	} else if (count == 1) {
		return rune_str(c);
	}
	Array_fixed_byte_5 buffer = {0};
	string res = utf32_to_str_no_malloc(((u32)(c)), &buffer[0]);
	return string_repeat(res, count);
}

int rune_length_in_bytes(rune c) {
	u32 code = ((u32)(c));
	if (code <= 0x7FU) {
		return 1;
	} else if (code <= 0x7FFU) {
		return 2;
	} else if (0xD800 <= code && code <= 0xDFFFU) {
		return -1;
	} else if (code <= 0xFFFFU) {
		return 3;
	} else if (code <= 0x10FFFFU) {
		return 4;
	}
	return -1;
}

VV_LOCAL_SYMBOL SortedMap new_sorted_map(int n, int value_bytes) {
	return (SortedMap){.value_bytes = value_bytes,.root = new_node(),.len = 0,};
}

VV_LOCAL_SYMBOL SortedMap new_sorted_map_init(int n, int value_bytes, string* keys, voidptr values) {
	SortedMap out = new_sorted_map(n, value_bytes);
	for (int i = 0; i < n; ++i) {
		SortedMap_set(&out, keys[i], ((byte*)(values)) + i * value_bytes);
	}
	return out;
}

VV_LOCAL_SYMBOL mapnode* new_node(void) {
	return (mapnode*)memdup(&(mapnode){.children = 0,.len = 0,.keys = {0},.values = {0},}, sizeof(mapnode));
}

VV_LOCAL_SYMBOL void SortedMap_set(SortedMap* m, string key, voidptr value) {
	mapnode* node = m->root;
	int child_index = 0;
	mapnode* parent = ((mapnode*)(0));
	for (;;) {
		if (node->len == _const_max_len) {
			if (isnil(parent)) {
				parent = new_node();
				m->root = parent;
			}
			mapnode_split_child(parent, child_index, node);
			if (string__eq(key, parent->keys[v_fixed_index(child_index, 11)])) {
				vmemcpy(parent->values[v_fixed_index(child_index, 11)], value, m->value_bytes);
				return;
			}
			if (string__lt(key, parent->keys[v_fixed_index(child_index, 11)])) {
				node = ((mapnode*)(parent->children[child_index]));
			} else {
				node = ((mapnode*)(parent->children[child_index + 1]));
			}
		}
		int i = 0;
		for (;;) {
			if (!(i < node->len && string__lt(node->keys[v_fixed_index(i, 11)], key))) break;
			i++;
		}
		if (i != node->len && string__eq(key, node->keys[v_fixed_index(i, 11)])) {
			vmemcpy(node->values[v_fixed_index(i, 11)], value, m->value_bytes);
			return;
		}
		if (isnil(node->children)) {
			int j = node->len - 1;
			for (;;) {
				if (!(j >= 0 && string__lt(key, node->keys[v_fixed_index(j, 11)]))) break;
				node->keys[v_fixed_index(j + 1, 11)] = node->keys[v_fixed_index(j, 11)];
				node->values[v_fixed_index(j + 1, 11)] = node->values[v_fixed_index(j, 11)];
				j--;
			}
			node->keys[v_fixed_index(j + 1, 11)] = key;
			{ // Unsafe block
				node->values[v_fixed_index(j + 1, 11)] = _v_malloc(m->value_bytes);
				vmemcpy(node->values[v_fixed_index(j + 1, 11)], value, m->value_bytes);
			}
			node->len++;
			m->len++;
			return;
		}
		parent = node;
		child_index = i;
		node = ((mapnode*)(node->children[child_index]));
	}
}

VV_LOCAL_SYMBOL void mapnode_split_child(mapnode* n, int child_index, mapnode* y) {
	mapnode* z = new_node();
	z->len = _const_mid_index;
	y->len = _const_mid_index;
	for (int j = _const_mid_index - 1; j >= 0; j--) {
		z->keys[v_fixed_index(j, 11)] = y->keys[v_fixed_index(j + _const_degree, 11)];
		z->values[v_fixed_index(j, 11)] = y->values[v_fixed_index(j + _const_degree, 11)];
	}
	if (!isnil(y->children)) {
		z->children = ((voidptr*)(_v_malloc(((int)(_const_children_bytes)))));
		for (int jj = _const_degree - 1; jj >= 0; jj--) {
			{ // Unsafe block
				z->children[jj] = y->children[jj + _const_degree];
			}
		}
	}
	{ // Unsafe block
		if (isnil(n->children)) {
			n->children = ((voidptr*)(_v_malloc(((int)(_const_children_bytes)))));
		}
		n->children[n->len + 1] = n->children[n->len];
	}
	for (int j = n->len; j > child_index; j--) {
		n->keys[v_fixed_index(j, 11)] = n->keys[v_fixed_index(j - 1, 11)];
		n->values[v_fixed_index(j, 11)] = n->values[v_fixed_index(j - 1, 11)];
		{ // Unsafe block
			n->children[j] = n->children[j - 1];
		}
	}
	n->keys[v_fixed_index(child_index, 11)] = y->keys[v_fixed_index(_const_mid_index, 11)];
	n->values[v_fixed_index(child_index, 11)] = y->values[v_fixed_index(_const_mid_index, 11)];
	{ // Unsafe block
		n->children[child_index] = ((voidptr)(y));
		n->children[child_index + 1] = ((voidptr)(z));
	}
	n->len++;
}

VV_LOCAL_SYMBOL bool SortedMap_get(SortedMap m, string key, voidptr out) {
	mapnode* node = m.root;
	for (;;) {
		int i = node->len - 1;
		for (;;) {
			if (!(i >= 0 && string__lt(key, node->keys[v_fixed_index(i, 11)]))) break;
			i--;
		}
		if (i != -1 && string__eq(key, node->keys[v_fixed_index(i, 11)])) {
			vmemcpy(out, node->values[v_fixed_index(i, 11)], m.value_bytes);
			return true;
		}
		if (isnil(node->children)) {
			break;
		}
		node = ((mapnode*)(node->children[i + 1]));
	}
	return false;
}

VV_LOCAL_SYMBOL bool SortedMap_exists(SortedMap m, string key) {
	if (isnil(m.root)) {
		return false;
	}
	mapnode* node = m.root;
	for (;;) {
		int i = node->len - 1;
		for (;;) {
			if (!(i >= 0 && string__lt(key, node->keys[v_fixed_index(i, 11)]))) break;
			i--;
		}
		if (i != -1 && string__eq(key, node->keys[v_fixed_index(i, 11)])) {
			return true;
		}
		if (isnil(node->children)) {
			break;
		}
		node = ((mapnode*)(node->children[i + 1]));
	}
	return false;
}

VV_LOCAL_SYMBOL int mapnode_find_key(mapnode* n, string k) {
	int idx = 0;
	for (;;) {
		if (!(idx < n->len && string__lt(n->keys[v_fixed_index(idx, 11)], k))) break;
		idx++;
	}
	return idx;
}

VV_LOCAL_SYMBOL bool mapnode_remove_key(mapnode* n, string k) {
	int idx = mapnode_find_key(n, k);
	if (idx < n->len && string__eq(n->keys[v_fixed_index(idx, 11)], k)) {
		if (isnil(n->children)) {
			mapnode_remove_from_leaf(n, idx);
		} else {
			mapnode_remove_from_non_leaf(n, idx);
		}
		return true;
	} else {
		if (isnil(n->children)) {
			return false;
		}
		bool flag = (idx == n->len ? (true) : (false));
		if (((mapnode*)(n->children[idx]))->len < _const_degree) {
			mapnode_fill(n, idx);
		}
		mapnode* node = ((mapnode*)(0));
		if (flag && idx > n->len) {
			node = ((mapnode*)(n->children[idx - 1]));
		} else {
			node = ((mapnode*)(n->children[idx]));
		}
		return mapnode_remove_key(node, k);
	}
	return 0;
}

VV_LOCAL_SYMBOL void mapnode_remove_from_leaf(mapnode* n, int idx) {
	for (int i = idx + 1; i < n->len; i++) {
		n->keys[v_fixed_index(i - 1, 11)] = n->keys[v_fixed_index(i, 11)];
		n->values[v_fixed_index(i - 1, 11)] = n->values[v_fixed_index(i, 11)];
	}
	n->len--;
}

VV_LOCAL_SYMBOL void mapnode_remove_from_non_leaf(mapnode* n, int idx) {
	string k = n->keys[v_fixed_index(idx, 11)];
	if (((mapnode*)(n->children[idx]))->len >= _const_degree) {
		mapnode* current = ((mapnode*)(n->children[idx]));
		for (;;) {
			if (!(!isnil(current->children))) break;
			current = ((mapnode*)(current->children[current->len]));
		}
		string predecessor = current->keys[v_fixed_index(current->len - 1, 11)];
		n->keys[v_fixed_index(idx, 11)] = predecessor;
		n->values[v_fixed_index(idx, 11)] = current->values[v_fixed_index(current->len - 1, 11)];
		mapnode* node = ((mapnode*)(n->children[idx]));
		mapnode_remove_key(node, predecessor);
	} else if (((mapnode*)(n->children[idx + 1]))->len >= _const_degree) {
		mapnode* current = ((mapnode*)(n->children[idx + 1]));
		for (;;) {
			if (!(!isnil(current->children))) break;
			current = ((mapnode*)(current->children[0]));
		}
		string successor = current->keys[0];
		n->keys[v_fixed_index(idx, 11)] = successor;
		n->values[v_fixed_index(idx, 11)] = current->values[0];
		mapnode* node = ((mapnode*)(n->children[idx + 1]));
		mapnode_remove_key(node, successor);
	} else {
		mapnode_merge(n, idx);
		mapnode* node = ((mapnode*)(n->children[idx]));
		mapnode_remove_key(node, k);
	}
}

VV_LOCAL_SYMBOL void mapnode_fill(mapnode* n, int idx) {
	if (idx != 0 && ((mapnode*)(n->children[idx - 1]))->len >= _const_degree) {
		mapnode_borrow_from_prev(n, idx);
	} else if (idx != n->len && ((mapnode*)(n->children[idx + 1]))->len >= _const_degree) {
		mapnode_borrow_from_next(n, idx);
	} else if (idx != n->len) {
		mapnode_merge(n, idx);
	} else {
		mapnode_merge(n, idx - 1);
	}
}

VV_LOCAL_SYMBOL void mapnode_borrow_from_prev(mapnode* n, int idx) {
	mapnode* child = ((mapnode*)(n->children[idx]));
	mapnode* sibling = ((mapnode*)(n->children[idx - 1]));
	for (int i = child->len - 1; i >= 0; i--) {
		child->keys[v_fixed_index(i + 1, 11)] = child->keys[v_fixed_index(i, 11)];
		child->values[v_fixed_index(i + 1, 11)] = child->values[v_fixed_index(i, 11)];
	}
	if (!isnil(child->children)) {
		for (int i = child->len; i >= 0; i--) {
			{ // Unsafe block
				child->children[i + 1] = child->children[i];
			}
		}
	}
	child->keys[0] = n->keys[v_fixed_index(idx - 1, 11)];
	child->values[0] = n->values[v_fixed_index(idx - 1, 11)];
	if (!isnil(child->children)) {
		{ // Unsafe block
			child->children[0] = sibling->children[sibling->len];
		}
	}
	n->keys[v_fixed_index(idx - 1, 11)] = sibling->keys[v_fixed_index(sibling->len - 1, 11)];
	n->values[v_fixed_index(idx - 1, 11)] = sibling->values[v_fixed_index(sibling->len - 1, 11)];
	child->len++;
	sibling->len--;
}

VV_LOCAL_SYMBOL void mapnode_borrow_from_next(mapnode* n, int idx) {
	mapnode* child = ((mapnode*)(n->children[idx]));
	mapnode* sibling = ((mapnode*)(n->children[idx + 1]));
	child->keys[v_fixed_index(child->len, 11)] = n->keys[v_fixed_index(idx, 11)];
	child->values[v_fixed_index(child->len, 11)] = n->values[v_fixed_index(idx, 11)];
	if (!isnil(child->children)) {
		{ // Unsafe block
			child->children[child->len + 1] = sibling->children[0];
		}
	}
	n->keys[v_fixed_index(idx, 11)] = sibling->keys[0];
	n->values[v_fixed_index(idx, 11)] = sibling->values[0];
	for (int i = 1; i < sibling->len; i++) {
		sibling->keys[v_fixed_index(i - 1, 11)] = sibling->keys[v_fixed_index(i, 11)];
		sibling->values[v_fixed_index(i - 1, 11)] = sibling->values[v_fixed_index(i, 11)];
	}
	if (!isnil(sibling->children)) {
		for (int i = 1; i <= sibling->len; i++) {
			{ // Unsafe block
				sibling->children[i - 1] = sibling->children[i];
			}
		}
	}
	child->len++;
	sibling->len--;
}

VV_LOCAL_SYMBOL void mapnode_merge(mapnode* n, int idx) {
	mapnode* child = ((mapnode*)(n->children[idx]));
	mapnode* sibling = ((mapnode*)(n->children[idx + 1]));
	child->keys[v_fixed_index(_const_mid_index, 11)] = n->keys[v_fixed_index(idx, 11)];
	child->values[v_fixed_index(_const_mid_index, 11)] = n->values[v_fixed_index(idx, 11)];
	for (int i = 0; i < sibling->len; ++i) {
		child->keys[v_fixed_index(i + _const_degree, 11)] = sibling->keys[v_fixed_index(i, 11)];
		child->values[v_fixed_index(i + _const_degree, 11)] = sibling->values[v_fixed_index(i, 11)];
	}
	if (!isnil(child->children)) {
		for (int i = 0; i <= sibling->len; i++) {
			{ // Unsafe block
				child->children[i + _const_degree] = sibling->children[i];
			}
		}
	}
	for (int i = idx + 1; i < n->len; i++) {
		n->keys[v_fixed_index(i - 1, 11)] = n->keys[v_fixed_index(i, 11)];
		n->values[v_fixed_index(i - 1, 11)] = n->values[v_fixed_index(i, 11)];
	}
	for (int i = idx + 2; i <= n->len; i++) {
		{ // Unsafe block
			n->children[i - 1] = n->children[i];
		}
	}
	child->len += sibling->len + 1;
	n->len--;
}

void SortedMap_delete(SortedMap* m, string key) {
	if (m->root->len == 0) {
		return;
	}
	bool removed = mapnode_remove_key(m->root, key);
	if (removed) {
		m->len--;
	}
	if (m->root->len == 0) {
		if (isnil(m->root->children)) {
			return;
		} else {
			m->root = ((mapnode*)(m->root->children[0]));
		}
	}
}

VV_LOCAL_SYMBOL int mapnode_subkeys(mapnode* n, Array_string* keys, int at) {
	int position = at;
	if (!isnil(n->children)) {
		for (int i = 0; i < n->len; ++i) {
			mapnode* child = ((mapnode*)(n->children[i]));
			position += mapnode_subkeys(child, keys, position);
			array_set(keys, position, &(string[]) { n->keys[v_fixed_index(i, 11)] });
			position++;
		}
		mapnode* child = ((mapnode*)(n->children[n->len]));
		position += mapnode_subkeys(child, keys, position);
	} else {
		for (int i = 0; i < n->len; ++i) {
			array_set(keys, position + i, &(string[]) { n->keys[v_fixed_index(i, 11)] });
		}
		position += n->len;
	}
	return position - at;
}

Array_string SortedMap_keys(SortedMap* m) {
	Array_string keys = __new_array_with_default(m->len, 0, sizeof(string), &(string[]){_SLIT("")});
	if (isnil(m->root) || m->root->len == 0) {
		return keys;
	}
	mapnode_subkeys(m->root, &/*arr*/keys, 0);
	return keys;
}

VV_LOCAL_SYMBOL void mapnode_free(mapnode* n) {
	println(_SLIT("TODO"));
}

void SortedMap_free(SortedMap* m) {
	if (isnil(m->root)) {
		return;
	}
	mapnode_free(m->root);
}

void SortedMap_print(SortedMap m) {
	println(_SLIT("TODO"));
}

// Attr: [direct_array_access]
Array_rune string_runes(string s) {
	Array_rune runes = __new_array_with_default(0, s.len, sizeof(rune), 0);
	for (int i = 0; i < s.len; i++) {
		int char_len = utf8_char_len(s.str[i]);
		if (char_len > 1) {
			int end = (s.len - 1 >= i + char_len ? (i + char_len) : (s.len));
			string r = string_substr(s, i, end);
			array_push((array*)&runes, _MOV((rune[]){ string_utf32_code(r) }));
			i += char_len - 1;
		} else {
			array_push((array*)&runes, _MOV((rune[]){ s.str[i] }));
		}
	}
	return runes;
}

// Attr: [unsafe]
string cstring_to_vstring(char* s) {
	return string_clone(tos2(((byte*)(s))));
}

// Attr: [unsafe]
string tos_clone(byte* s) {
	return string_clone(tos2(s));
}

// Attr: [unsafe]
string tos(byte* s, int len) {
	if (s == 0) {
		_v_panic(_SLIT("tos(): nil string"));
		VUNREACHABLE();
	}
	return (string){.str = s, .len = len};
}

// Attr: [unsafe]
string tos2(byte* s) {
	if (s == 0) {
		_v_panic(_SLIT("tos2: nil string"));
		VUNREACHABLE();
	}
	return (string){.str = s, .len = vstrlen(s)};
}

// Attr: [unsafe]
string tos3(char* s) {
	if (s == 0) {
		_v_panic(_SLIT("tos3: nil string"));
		VUNREACHABLE();
	}
	return (string){.str = ((byte*)(s)), .len = vstrlen_char(s)};
}

// Attr: [unsafe]
string tos4(byte* s) {
	if (s == 0) {
		return _SLIT("");
	}
	return (string){.str = s, .len = vstrlen(s)};
}

// Attr: [unsafe]
string tos5(char* s) {
	if (s == 0) {
		return _SLIT("");
	}
	return (string){.str = ((byte*)(s)), .len = vstrlen_char(s)};
}

// Attr: [unsafe]
string byte_vstring(byte* bp) {
	return (string){.str = bp, .len = vstrlen(bp)};
}

// Attr: [unsafe]
string byte_vstring_with_len(byte* bp, int len) {
	return (string){.str = bp, .len = len, .is_lit = 0};
}

// Attr: [unsafe]
string char_vstring(char* cp) {
	return (string){.str = ((byte*)(cp)), .len = vstrlen_char(cp), .is_lit = 0};
}

// Attr: [unsafe]
string char_vstring_with_len(char* cp, int len) {
	return (string){.str = ((byte*)(cp)), .len = len, .is_lit = 0};
}

// Attr: [unsafe]
string byte_vstring_literal(byte* bp) {
	return (string){.str = bp, .len = vstrlen(bp), .is_lit = 1};
}

// Attr: [unsafe]
string byte_vstring_literal_with_len(byte* bp, int len) {
	return (string){.str = bp, .len = len, .is_lit = 1};
}

// Attr: [unsafe]
string char_vstring_literal(char* cp) {
	return (string){.str = ((byte*)(cp)), .len = vstrlen_char(cp), .is_lit = 1};
}

// Attr: [unsafe]
string char_vstring_literal_with_len(char* cp, int len) {
	return (string){.str = ((byte*)(cp)), .len = len, .is_lit = 1};
}

VV_LOCAL_SYMBOL string string_clone_static(string a) {
	return string_clone(a);
}

string string_clone(string a) {
	if (a.len == 0) {
		return _SLIT("");
	}
	string b = (string){.str = malloc_noscan(a.len + 1), .len = a.len};
	{ // Unsafe block
		vmemcpy(b.str, a.str, a.len);
		b.str[a.len] = 0;
	}
	return b;
}

string string_replace_once(string s, string rep, string with) {
	int idx = string_index_(s, rep);
	if (idx == -1) {
		return string_clone(s);
	}
	return string__plus(string__plus(string_substr(s, 0, idx), with), string_substr(s, idx + rep.len, s.len));
}

// Attr: [direct_array_access]
string string_replace(string s, string rep, string with) {
bool string_replace_defer_0 = false;
Array_int idxs;
	if (s.len == 0 || rep.len == 0 || rep.len > s.len) {
		return string_clone(s);
	}
	if (!string_contains(s, rep)) {
		return string_clone(s);
	}
	idxs = __new_array_with_default(0, s.len / rep.len, sizeof(int), 0);
	string_replace_defer_0 = true;
	int idx = 0;
	for (;;) {
		idx = string_index_after(s, rep, idx);
		if (idx == -1) {
			break;
		}
		array_push((array*)&idxs, _MOV((int[]){ idx }));
		idx += rep.len;
	}
	if (idxs.len == 0) {
		string _t4 = string_clone(s);
		// Defer begin
		if (string_replace_defer_0) {
			array_free(&idxs);
		}
		// Defer end
		return _t4;
	}
	int new_len = s.len + idxs.len * (with.len - rep.len);
	byte* b = malloc_noscan(new_len + 1);
	int b_i = 0;
	int s_idx = 0;
	for (int _t5 = 0; _t5 < idxs.len; ++_t5) {
		int rep_pos = ((int*)idxs.data)[_t5];
		for (int i = s_idx; i < rep_pos; ++i) {
			{ // Unsafe block
				b[b_i] = s.str[ i];
			}
			b_i++;
		}
		s_idx = rep_pos + rep.len;
		for (int i = 0; i < with.len; ++i) {
			{ // Unsafe block
				b[b_i] = with.str[ i];
			}
			b_i++;
		}
	}
	if (s_idx < s.len) {
		for (int i = s_idx; i < s.len; ++i) {
			{ // Unsafe block
				b[b_i] = s.str[ i];
			}
			b_i++;
		}
	}
	{ // Unsafe block
		b[new_len] = 0;
		string _t6 = tos(b, new_len);
		// Defer begin
		if (string_replace_defer_0) {
			array_free(&idxs);
		}
		// Defer end
		return _t6;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [direct_array_access]
string string_replace_each(string s, Array_string vals) {
	if (s.len == 0 || vals.len == 0) {
		return string_clone(s);
	}
	if (vals.len % 2 != 0) {
		eprintln(_SLIT("string.replace_each(): odd number of strings"));
		return string_clone(s);
	}
	int new_len = s.len;
	Array_RepIndex idxs = __new_array_with_default(0, 6, sizeof(RepIndex), 0);
	int idx = 0;
	string s_ = string_clone(s);
	for (int rep_i = 0; rep_i < vals.len; rep_i += 2) {
		string rep = ((string*)vals.data)[rep_i];
		string with = ((string*)vals.data)[rep_i + 1];
		for (;;) {
			idx = string_index_after(s_, rep, idx);
			if (idx == -1) {
				break;
			}
			for (int i = 0; i < rep.len; ++i) {
				{ // Unsafe block
					s_.str[idx + i] = 127;
				}
			}
			array_push((array*)&idxs, _MOV((RepIndex[]){ (RepIndex){.idx = idx,.val_idx = rep_i,} }));
			idx += rep.len;
			new_len += with.len - rep.len;
		}
	}
	if (idxs.len == 0) {
		return string_clone(s);
	}
	qsort(idxs.data, idxs.len, idxs.element_size, (int (*)(const void *, const void *))&compare_2018276881664952276_RepIndex_by_idx);
	byte* b = malloc_noscan(new_len + 1);
	int idx_pos = 0;
	RepIndex cur_idx = ((RepIndex*)idxs.data)[idx_pos];
	int b_i = 0;
	for (int i = 0; i < s.len; i++) {
		if (i == cur_idx.idx) {
			string rep = ((string*)vals.data)[cur_idx.val_idx];
			string with = ((string*)vals.data)[cur_idx.val_idx + 1];
			for (int j = 0; j < with.len; ++j) {
				{ // Unsafe block
					b[b_i] = with.str[ j];
				}
				b_i++;
			}
			i += rep.len - 1;
			idx_pos++;
			if (idx_pos < idxs.len) {
				cur_idx = ((RepIndex*)idxs.data)[idx_pos];
			}
		} else {
			{ // Unsafe block
				b[b_i] = s.str[i];
			}
			b_i++;
		}
	}
	{ // Unsafe block
		b[new_len] = 0;
		return tos(b, new_len);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

bool string_bool(string s) {
	return string__eq(s, _SLIT("true")) || string__eq(s, _SLIT("t"));
}

int string_int(string s) {
	Option_i64 _t2 = strconv__common_parse_int(s, 0, 32, false, false);
	if (_t2.state != 0) { /*or block*/ 
		IError err = _t2.err;
		*(i64*) _t2.data = 0;
	}
	
 	return ((int)( (*(i64*)_t2.data)));
}

i64 string_i64(string s) {
	Option_i64 _t2 = strconv__common_parse_int(s, 0, 64, false, false);
	if (_t2.state != 0) { /*or block*/ 
		IError err = _t2.err;
		*(i64*) _t2.data = 0;
	}
	
 	return  (*(i64*)_t2.data);
}

i8 string_i8(string s) {
	Option_i64 _t2 = strconv__common_parse_int(s, 0, 8, false, false);
	if (_t2.state != 0) { /*or block*/ 
		IError err = _t2.err;
		*(i64*) _t2.data = 0;
	}
	
 	return ((i8)( (*(i64*)_t2.data)));
}

i16 string_i16(string s) {
	Option_i64 _t2 = strconv__common_parse_int(s, 0, 16, false, false);
	if (_t2.state != 0) { /*or block*/ 
		IError err = _t2.err;
		*(i64*) _t2.data = 0;
	}
	
 	return ((i16)( (*(i64*)_t2.data)));
}

f32 string_f32(string s) {
	return ((f32)(strconv__atof64(s)));
}

f64 string_f64(string s) {
	return strconv__atof64(s);
}

u8 string_byte(string s) {
	Option_u64 _t2 = strconv__common_parse_uint(s, 0, 8, false, false);
	if (_t2.state != 0) { /*or block*/ 
		IError err = _t2.err;
		*(u64*) _t2.data = 0U;
	}
	
 	return ((byte)( (*(u64*)_t2.data)));
}

u16 string_u16(string s) {
	Option_u64 _t2 = strconv__common_parse_uint(s, 0, 16, false, false);
	if (_t2.state != 0) { /*or block*/ 
		IError err = _t2.err;
		*(u64*) _t2.data = 0U;
	}
	
 	return ((u16)( (*(u64*)_t2.data)));
}

u32 string_u32(string s) {
	Option_u64 _t2 = strconv__common_parse_uint(s, 0, 32, false, false);
	if (_t2.state != 0) { /*or block*/ 
		IError err = _t2.err;
		*(u64*) _t2.data = 0U;
	}
	
 	return ((u32)( (*(u64*)_t2.data)));
}

u64 string_u64(string s) {
	Option_u64 _t2 = strconv__common_parse_uint(s, 0, 64, false, false);
	if (_t2.state != 0) { /*or block*/ 
		IError err = _t2.err;
		*(u64*) _t2.data = 0U;
	}
	
 	return  (*(u64*)_t2.data);
}

// Attr: [direct_array_access]
VV_LOCAL_SYMBOL bool string__eq(string s, string a) {
	if (s.str == 0) {
		_v_panic(_SLIT("string.eq(): nil string"));
		VUNREACHABLE();
	}
	if (s.len != a.len) {
		return false;
	}
	if (s.len > 0) {
		int last_idx = s.len - 1;
		if (s.str[ last_idx] != a.str[ last_idx]) {
			return false;
		}
	}
	{ // Unsafe block
		return vmemcmp(s.str, a.str, a.len) == 0;
	}
	return 0;
}

// Attr: [direct_array_access]
int string_compare(string s, string a) {
	int min_len = (s.len < a.len ? (s.len) : (a.len));
	for (int i = 0; i < min_len; ++i) {
		if (s.str[ i] < a.str[ i]) {
			return -1;
		}
		if (s.str[ i] > a.str[ i]) {
			return 1;
		}
	}
	if (s.len < a.len) {
		return -1;
	}
	if (s.len > a.len) {
		return 1;
	}
	return 0;
}

// Attr: [direct_array_access]
VV_LOCAL_SYMBOL bool string__lt(string s, string a) {
	for (int i = 0; i < s.len; ++i) {
		if (i >= a.len || s.str[ i] > a.str[ i]) {
			return false;
		} else if (s.str[ i] < a.str[ i]) {
			return true;
		}
	}
	if (s.len < a.len) {
		return true;
	}
	return false;
}

// Attr: [direct_array_access]
VV_LOCAL_SYMBOL string string__plus(string s, string a) {
	int new_len = a.len + s.len;
	string res = (string){.str = malloc_noscan(new_len + 1), .len = new_len};
	for (int j = 0; j < s.len; ++j) {
		{ // Unsafe block
			res.str[j] = s.str[j];
		}
	}
	for (int j = 0; j < a.len; ++j) {
		{ // Unsafe block
			res.str[s.len + j] = a.str[j];
		}
	}
	{ // Unsafe block
		res.str[new_len] = 0;
	}
	return res;
}

// Attr: [direct_array_access]
Array_string string_split_any(string s, string delim) {
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	int i = 0;
	if (s.len > 0) {
		if (delim.len <= 0) {
			return string_split(s, _SLIT(""));
		}
		for (int index = 0; index < s.len; ++index) {
			byte ch = s.str[index];
			for (int _t2 = 0; _t2 < delim.len; ++_t2) {
				byte delim_ch = delim.str[_t2];
				if (ch == delim_ch) {
					array_push((array*)&res, _MOV((string[]){ string_substr(s, i, index) }));
					i = index + 1;
					break;
				}
			}
		}
		if (i < s.len) {
			array_push((array*)&res, _MOV((string[]){ string_substr(s, i, s.len) }));
		}
	}
	return res;
}

Array_string string_split(string s, string delim) {
	return string_split_nth(s, delim, 0);
}

// Attr: [direct_array_access]
Array_string string_split_nth(string s, string delim, int nth) {
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	int i = 0;

	if (delim.len == (0)) {
		i = 1;
		for (int _t1 = 0; _t1 < s.len; ++_t1) {
			byte ch = s.str[_t1];
			if (nth > 0 && i >= nth) {
				array_push((array*)&res, _MOV((string[]){ string_substr(s, i, s.len) }));
				break;
			}
			array_push((array*)&res, _MOV((string[]){ byte_ascii_str(ch) }));
			i++;
		}
		return res;
	}
	else if (delim.len == (1)) {
		int start = 0;
		byte delim_byte = delim.str[ 0];
		for (;;) {
			if (!(i < s.len)) break;
			if (s.str[ i] == delim_byte) {
				bool was_last = nth > 0 && res.len == nth - 1;
				if (was_last) {
					break;
				}
				string val = string_substr(s, start, i);
				array_push((array*)&res, _MOV((string[]){ val }));
				start = i + delim.len;
				i = start;
			} else {
				i++;
			}
		}
		if (nth < 1 || res.len < nth) {
			array_push((array*)&res, _MOV((string[]){ string_substr(s, start, s.len) }));
		}
		return res;
	}
	else {
		int start = 0;
		for (;;) {
			if (!(i <= s.len)) break;
			bool is_delim = i + delim.len <= s.len && string__eq(string_substr(s, i, i + delim.len), delim);
			if (is_delim) {
				bool was_last = nth > 0 && res.len == nth - 1;
				if (was_last) {
					break;
				}
				string val = string_substr(s, start, i);
				array_push((array*)&res, _MOV((string[]){ val }));
				start = i + delim.len;
				i = start;
			} else {
				i++;
			}
		}
		if (nth < 1 || res.len < nth) {
			array_push((array*)&res, _MOV((string[]){ string_substr(s, start, s.len) }));
		}
		return res;
	};
	return __new_array(0, 0, sizeof(string));
}

// Attr: [direct_array_access]
Array_string string_split_into_lines(string s) {
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	if (s.len == 0) {
		return res;
	}
	int start = 0;
	int end = 0;
	for (int i = 0; i < s.len; i++) {
		if (s.str[ i] == 10) {
			end = (i > 0 && s.str[ i - 1] == 13 ? (i - 1) : (i));
			array_push((array*)&res, _MOV((string[]){ (start == end ? (_SLIT("")) : (string_substr(s, start, end))) }));
			start = i + 1;
		}
	}
	if (start < s.len) {
		array_push((array*)&res, _MOV((string[]){ string_substr(s, start, s.len) }));
	}
	return res;
}

VV_LOCAL_SYMBOL string string_substr2(string s, int start, int _end, bool end_max) {
	int end = (end_max ? (s.len) : (_end));
	return string_substr(s, start, end);
}

// Attr: [direct_array_access]
string string_substr(string s, int start, int end) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (start > end || start > s.len || end > s.len || start < 0 || end < 0) {
			_v_panic( str_intp(4, _MOV((StrIntpData[]){{_SLIT("substr("), 0xfe07, {.d_i32 = start}}, {_SLIT(", "), 0xfe07, {.d_i32 = end}}, {_SLIT(") out of bounds (len="), 0xfe07, {.d_i32 = s.len}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		}
	}
	#endif
	int len = end - start;
	if (len == s.len) {
		return string_clone(s);
	}
	string res = (string){.str = malloc_noscan(len + 1), .len = len};
	for (int i = 0; i < len; ++i) {
		{ // Unsafe block
			res.str[i] = s.str[start + i];
		}
	}
	{ // Unsafe block
		res.str[len] = 0;
	}
	return res;
}

// Attr: [direct_array_access]
string string_substr_ni(string s, int _start, int _end) {
	int start = _start;
	int end = _end;
	if (start < 0) {
		start = s.len + start;
		if (start < 0) {
			start = 0;
		}
	}
	if (end < 0) {
		end = s.len + end;
		if (end < 0) {
			end = 0;
		}
	}
	if (end >= s.len) {
		end = s.len;
	}
	if (start > s.len || end < start) {
		string res = (string){.str = malloc_noscan(1), .len = 0};
		{ // Unsafe block
			res.str[0] = 0;
		}
		return res;
	}
	int len = end - start;
	string res = (string){.str = malloc_noscan(len + 1), .len = len};
	for (int i = 0; i < len; ++i) {
		{ // Unsafe block
			res.str[i] = s.str[start + i];
		}
	}
	{ // Unsafe block
		res.str[len] = 0;
	}
	return res;
}

// Attr: [direct_array_access]
VV_LOCAL_SYMBOL int string_index_(string s, string p) {
	if (p.len > s.len || p.len == 0) {
		return -1;
	}
	if (p.len > 2) {
		return string_index_kmp(s, p);
	}
	int i = 0;
	for (;;) {
		if (!(i < s.len)) break;
		int j = 0;
		for (;;) {
			if (!(j < p.len && s.str[i + j] == p.str[j])) break;
			j++;
		}
		if (j == p.len) {
			return i;
		}
		i++;
	}
	return -1;
}

Option_int string_index(string s, string p) {
	int idx = string_index_(s, p);
	if (idx == -1) {
		return (Option_int){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Option_int _t2;
	opt_ok(&(int[]) { idx }, (Option*)(&_t2), sizeof(int));
	return _t2;
}

// Attr: [direct_array_access]
// Attr: [manualfree]
VV_LOCAL_SYMBOL int string_index_kmp(string s, string p) {
bool string_index_kmp_defer_0 = false;
Array_int prefix;
	if (p.len > s.len) {
		return -1;
	}
	prefix = __new_array_with_default(p.len, 0, sizeof(int), 0);
	string_index_kmp_defer_0 = true;
	int j = 0;
	for (int i = 1; i < p.len; i++) {
		for (;;) {
			if (!(p.str[j] != p.str[i] && j > 0)) break;
			j = ((int*)prefix.data)[j - 1];
		}
		if (p.str[j] == p.str[i]) {
			j++;
		}
		((int*)prefix.data)[i] = j;
	}
	j = 0;
	for (int i = 0; i < s.len; ++i) {
		for (;;) {
			if (!(p.str[j] != s.str[i] && j > 0)) break;
			j = ((int*)prefix.data)[j - 1];
		}
		if (p.str[j] == s.str[i]) {
			j++;
		}
		if (j == p.len) {
			int _t2 = i - p.len + 1;
			// Defer begin
			if (string_index_kmp_defer_0) {
				array_free(&prefix);
			}
			// Defer end
			return _t2;
		}
	}
	int _t3 = -1;
	// Defer begin
	if (string_index_kmp_defer_0) {
		array_free(&prefix);
	}
	// Defer end
	return _t3;
}

int string_index_any(string s, string chars) {
	for (int i = 0; i < s.len; ++i) {
		byte ss = s.str[i];
		for (int _t1 = 0; _t1 < chars.len; ++_t1) {
			byte c = chars.str[_t1];
			if (c == ss) {
				return i;
			}
		}
	}
	return -1;
}

// Attr: [direct_array_access]
VV_LOCAL_SYMBOL int string_last_index_(string s, string p) {
	if (p.len > s.len || p.len == 0) {
		return -1;
	}
	int i = s.len - p.len;
	for (;;) {
		if (!(i >= 0)) break;
		int j = 0;
		for (;;) {
			if (!(j < p.len && s.str[i + j] == p.str[j])) break;
			j++;
		}
		if (j == p.len) {
			return i;
		}
		i--;
	}
	return -1;
}

Option_int string_last_index(string s, string p) {
	int idx = string_last_index_(s, p);
	if (idx == -1) {
		return (Option_int){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Option_int _t2;
	opt_ok(&(int[]) { idx }, (Option*)(&_t2), sizeof(int));
	return _t2;
}

// Attr: [direct_array_access]
int string_index_after(string s, string p, int start) {
	if (p.len > s.len) {
		return -1;
	}
	int strt = start;
	if (start < 0) {
		strt = 0;
	}
	if (start >= s.len) {
		return -1;
	}
	int i = strt;
	for (;;) {
		if (!(i < s.len)) break;
		int j = 0;
		int ii = i;
		for (;;) {
			if (!(j < p.len && s.str[ii] == p.str[j])) break;
			j++;
			ii++;
		}
		if (j == p.len) {
			return i;
		}
		i++;
	}
	return -1;
}

// Attr: [direct_array_access]
int string_index_byte(string s, byte c) {
	for (int i = 0; i < s.len; ++i) {
		if (s.str[i] == c) {
			return i;
		}
	}
	return -1;
}

// Attr: [direct_array_access]
int string_last_index_byte(string s, byte c) {
	for (int i = s.len - 1; i >= 0; i--) {
		if (s.str[i] == c) {
			return i;
		}
	}
	return -1;
}

// Attr: [direct_array_access]
int string_count(string s, string substr) {
	if (s.len == 0 || substr.len == 0) {
		return 0;
	}
	if (substr.len > s.len) {
		return 0;
	}
	int n = 0;
	if (substr.len == 1) {
		byte target = substr.str[ 0];
		for (int _t3 = 0; _t3 < s.len; ++_t3) {
			byte letter = s.str[_t3];
			if (letter == target) {
				n++;
			}
		}
		return n;
	}
	int i = 0;
	for (;;) {
		i = string_index_after(s, substr, i);
		if (i == -1) {
			return n;
		}
		i += substr.len;
		n++;
	}
	return 0;
}

bool string_contains(string s, string substr) {
	if (substr.len == 0) {
		return true;
	}
	if (string_index_(s, substr) == -1) {
		return false;
	}
	return true;
}

bool string_contains_any(string s, string chars) {
	for (int _t1 = 0; _t1 < chars.len; ++_t1) {
		byte c = chars.str[_t1];
		if (string_contains(s, byte_ascii_str(c))) {
			return true;
		}
	}
	return false;
}

bool string_contains_any_substr(string s, Array_string substrs) {
	if (substrs.len == 0) {
		return true;
	}
	for (int _t2 = 0; _t2 < substrs.len; ++_t2) {
		string sub = ((string*)substrs.data)[_t2];
		if (string_contains(s, sub)) {
			return true;
		}
	}
	return false;
}

// Attr: [direct_array_access]
bool string_starts_with(string s, string p) {
	if (p.len > s.len) {
		return false;
	}
	for (int i = 0; i < p.len; ++i) {
		if (s.str[i] != p.str[i]) {
			return false;
		}
	}
	return true;
}

// Attr: [direct_array_access]
bool string_ends_with(string s, string p) {
	if (p.len > s.len) {
		return false;
	}
	for (int i = 0; i < p.len; ++i) {
		if (p.str[i] != s.str[s.len - p.len + i]) {
			return false;
		}
	}
	return true;
}

// Attr: [direct_array_access]
string string_to_lower(string s) {
	{ // Unsafe block
		byte* b = malloc_noscan(s.len + 1);
		for (int i = 0; i < s.len; ++i) {
			if (s.str[i] >= 'A' && s.str[i] <= 'Z') {
				b[i] = s.str[i] + 32;
			} else {
				b[i] = s.str[i];
			}
		}
		b[s.len] = 0;
		return tos(b, s.len);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [direct_array_access]
bool string_is_lower(string s) {
	for (int i = 0; i < s.len; ++i) {
		if (s.str[ i] >= 'A' && s.str[ i] <= 'Z') {
			return false;
		}
	}
	return true;
}

// Attr: [direct_array_access]
string string_to_upper(string s) {
	{ // Unsafe block
		byte* b = malloc_noscan(s.len + 1);
		for (int i = 0; i < s.len; ++i) {
			if (s.str[i] >= 'a' && s.str[i] <= 'z') {
				b[i] = s.str[i] - 32;
			} else {
				b[i] = s.str[i];
			}
		}
		b[s.len] = 0;
		return tos(b, s.len);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [direct_array_access]
bool string_is_upper(string s) {
	for (int i = 0; i < s.len; ++i) {
		if (s.str[ i] >= 'a' && s.str[ i] <= 'z') {
			return false;
		}
	}
	return true;
}

// Attr: [direct_array_access]
string string_capitalize(string s) {
	if (s.len == 0) {
		return _SLIT("");
	}
	byte s0 = s.str[ 0];
	string letter = byte_ascii_str(s0);
	string uletter = string_to_upper(letter);
	if (s.len == 1) {
		return uletter;
	}
	string srest = string_substr(s, 1, s.len);
	string res = string__plus(uletter, srest);
	return res;
}

// Attr: [direct_array_access]
bool string_is_capital(string s) {
	if (s.len == 0 || !(s.str[ 0] >= 'A' && s.str[ 0] <= 'Z')) {
		return false;
	}
	for (int i = 1; i < s.len; ++i) {
		if (s.str[ i] >= 'A' && s.str[ i] <= 'Z') {
			return false;
		}
	}
	return true;
}

// Attr: [direct_array_access]
bool string_starts_with_capital(string s) {
	if (s.len == 0 || !(s.str[ 0] >= 'A' && s.str[ 0] <= 'Z')) {
		return false;
	}
	return true;
}

string string_title(string s) {
	Array_string words = string_split(s, _SLIT(" "));
	Array_string tit = __new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t1 = 0; _t1 < words.len; ++_t1) {
		string word = ((string*)words.data)[_t1];
		array_push((array*)&tit, _MOV((string[]){ string_capitalize(word) }));
	}
	string title = Array_string_join(tit, _SLIT(" "));
	return title;
}

bool string_is_title(string s) {
	Array_string words = string_split(s, _SLIT(" "));
	for (int _t1 = 0; _t1 < words.len; ++_t1) {
		string word = ((string*)words.data)[_t1];
		if (!string_is_capital(word)) {
			return false;
		}
	}
	return true;
}

string string_find_between(string s, string start, string end) {
	int start_pos = string_index_(s, start);
	if (start_pos == -1) {
		return _SLIT("");
	}
	string val = string_substr(s, start_pos + start.len, s.len);
	int end_pos = string_index_(val, end);
	if (end_pos == -1) {
		return val;
	}
	return string_substr(val, 0, end_pos);
}

string string_trim_space(string s) {
	return string_trim(s, _SLIT(" \n\t\v\f\r"));
}

// Attr: [direct_array_access]
string string_trim(string s, string cutset) {
	if (s.len < 1 || cutset.len < 1) {
		return string_clone(s);
	}
	int pos_left = 0;
	int pos_right = s.len - 1;
	bool cs_match = true;
	for (;;) {
		if (!(pos_left <= s.len && pos_right >= -1 && cs_match)) break;
		cs_match = false;
		for (int _t2 = 0; _t2 < cutset.len; ++_t2) {
			byte cs = cutset.str[_t2];
			if (s.str[ pos_left] == cs) {
				pos_left++;
				cs_match = true;
				break;
			}
		}
		for (int _t3 = 0; _t3 < cutset.len; ++_t3) {
			byte cs = cutset.str[_t3];
			if (s.str[ pos_right] == cs) {
				pos_right--;
				cs_match = true;
				break;
			}
		}
		if (pos_left > pos_right) {
			return _SLIT("");
		}
	}
	return string_substr(s, pos_left, pos_right + 1);
}

// Attr: [direct_array_access]
string string_trim_left(string s, string cutset) {
	if (s.len < 1 || cutset.len < 1) {
		return string_clone(s);
	}
	int pos = 0;
	for (;;) {
		if (!(pos < s.len)) break;
		bool found = false;
		for (int _t2 = 0; _t2 < cutset.len; ++_t2) {
			byte cs = cutset.str[_t2];
			if (s.str[ pos] == cs) {
				found = true;
				break;
			}
		}
		if (!found) {
			break;
		}
		pos++;
	}
	return string_substr(s, pos, s.len);
}

// Attr: [direct_array_access]
string string_trim_right(string s, string cutset) {
	if (s.len < 1 || cutset.len < 1) {
		return string_clone(s);
	}
	int pos = s.len - 1;
	for (;;) {
		if (!(pos >= 0)) break;
		bool found = false;
		for (int _t2 = 0; _t2 < cutset.len; ++_t2) {
			byte cs = cutset.str[_t2];
			if (s.str[ pos] == cs) {
				found = true;
			}
		}
		if (!found) {
			break;
		}
		pos--;
	}
	if (pos < 0) {
		return _SLIT("");
	}
	return string_substr(s, 0, pos + 1);
}

string string_trim_string_left(string s, string str) {
	if (string_starts_with(s, str)) {
		return string_substr(s, str.len, s.len);
	}
	return string_clone(s);
}

string string_trim_string_right(string s, string str) {
	if (string_ends_with(s, str)) {
		return string_substr(s, 0, s.len - str.len);
	}
	return string_clone(s);
}

// Attr: [deprecated]
// Attr: [deprecated_after]
string string_trim_prefix(string s, string str) {
	return string_trim_string_left(s, str);
}

// Attr: [deprecated]
// Attr: [deprecated_after]
string string_trim_suffix(string s, string str) {
	return string_trim_string_right(s, str);
}

int compare_strings(string* a, string* b) {
	if (string__lt(*a, *b)) {
		return -1;
	}
	if (string__lt(*b, *a)) {
		return 1;
	}
	return 0;
}

VV_LOCAL_SYMBOL int compare_strings_by_len(string* a, string* b) {
	if (a->len < b->len) {
		return -1;
	}
	if (a->len > b->len) {
		return 1;
	}
	return 0;
}

VV_LOCAL_SYMBOL int compare_lower_strings(string* a, string* b) {
	string aa = string_to_lower(/*rec*/*a);
	string bb = string_to_lower(/*rec*/*b);
	return compare_strings(&aa, &bb);
}

void Array_string_sort_ignore_case(Array_string* s) {
	array_sort_with_compare(s, (voidptr)compare_lower_strings);
}

void Array_string_sort_by_len(Array_string* s) {
	array_sort_with_compare(s, (voidptr)compare_strings_by_len);
}

string string_str(string s) {
	return string_clone(s);
}

VV_LOCAL_SYMBOL byte string_at(string s, int idx) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (idx < 0 || idx >= s.len) {
			_v_panic( str_intp(3, _MOV((StrIntpData[]){{_SLIT("string index out of range: "), 0xfe07, {.d_i32 = idx}}, {_SLIT(" / "), 0xfe07, {.d_i32 = s.len}}, {_SLIT0, 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		}
	}
	#endif
	{ // Unsafe block
		return s.str[idx];
	}
	return 0;
}

VV_LOCAL_SYMBOL Option_byte string_at_with_check(string s, int idx) {
	if (idx < 0 || idx >= s.len) {
		return (Option_byte){ .state=2, .err=_v_error(_SLIT("string index out of range")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	{ // Unsafe block
		Option_byte _t2;
		opt_ok(&(byte[]) { s.str[idx] }, (Option*)(&_t2), sizeof(byte));
		return _t2;
	}
	return (Option_byte){0};
}

// Attr: [inline]
inline bool byte_is_space(byte c) {
	return c == 32 || (c > 8 && c < 14) || (c == 0x85) || (c == 0xa0);
}

// Attr: [inline]
inline bool byte_is_digit(byte c) {
	return c >= '0' && c <= '9';
}

// Attr: [inline]
inline bool byte_is_hex_digit(byte c) {
	return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
}

// Attr: [inline]
inline bool byte_is_oct_digit(byte c) {
	return c >= '0' && c <= '7';
}

// Attr: [inline]
inline bool byte_is_bin_digit(byte c) {
	return c == '0' || c == '1';
}

// Attr: [inline]
inline bool byte_is_letter(byte c) {
	return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
}

// Attr: [inline]
inline bool byte_is_alnum(byte c) {
	return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9');
}

// Attr: [manualfree]
// Attr: [unsafe]
void string_free(string* s) {
	if (s->is_lit == -98761234) {
		byte* double_free_msg = ((byte*)("double string.free() detected\n"));
		int double_free_msg_len = vstrlen(double_free_msg);
		#if defined(_VFREESTANDING)
		{
		}
		#else
		{
			_write_buf_to_fd(1, double_free_msg, double_free_msg_len);
		}
		#endif
		return;
	}
	if (s->is_lit == 1 || s->str == 0) {
		return;
	}
	_v_free(s->str);
	s->is_lit = -98761234;
}

string string_before(string s, string sub) {
	int pos = string_index_(s, sub);
	if (pos == -1) {
		return string_clone(s);
	}
	return string_substr(s, 0, pos);
}

string string_all_before(string s, string sub) {
	int pos = string_index_(s, sub);
	if (pos == -1) {
		return string_clone(s);
	}
	return string_substr(s, 0, pos);
}

string string_all_before_last(string s, string sub) {
	int pos = string_last_index_(s, sub);
	if (pos == -1) {
		return string_clone(s);
	}
	return string_substr(s, 0, pos);
}

string string_all_after(string s, string sub) {
	int pos = string_index_(s, sub);
	if (pos == -1) {
		return string_clone(s);
	}
	return string_substr(s, pos + sub.len, s.len);
}

string string_all_after_last(string s, string sub) {
	int pos = string_last_index_(s, sub);
	if (pos == -1) {
		return string_clone(s);
	}
	return string_substr(s, pos + sub.len, s.len);
}

string string_after(string s, string sub) {
	return string_all_after_last(s, sub);
}

string string_after_char(string s, byte sub) {
	int pos = -1;
	for (int i = 0; i < s.len; ++i) {
		byte c = s.str[i];
		if (c == sub) {
			pos = i;
			break;
		}
	}
	if (pos == -1) {
		return string_clone(s);
	}
	return string_substr(s, pos + 1, s.len);
}

string Array_string_join(Array_string a, string sep) {
	if (a.len == 0) {
		return _SLIT("");
	}
	int len = 0;
	for (int _t2 = 0; _t2 < a.len; ++_t2) {
		string val = ((string*)a.data)[_t2];
		len += val.len + sep.len;
	}
	len -= sep.len;
	string res = (string){.str = malloc_noscan(len + 1), .len = len};
	int idx = 0;
	for (int i = 0; i < a.len; ++i) {
		string val = ((string*)a.data)[i];
		{ // Unsafe block
			vmemcpy(res.str + idx, val.str, val.len);
			idx += val.len;
		}
		if (i != a.len - 1) {
			{ // Unsafe block
				vmemcpy(res.str + idx, sep.str, sep.len);
				idx += sep.len;
			}
		}
	}
	{ // Unsafe block
		res.str[res.len] = 0;
	}
	return res;
}

string Array_string_join_lines(Array_string s) {
	return Array_string_join(s, _SLIT("\n"));
}

string string_reverse(string s) {
	if (s.len == 0 || s.len == 1) {
		return string_clone(s);
	}
	string res = (string){.str = malloc_noscan(s.len + 1), .len = s.len};
	for (int i = s.len - 1; i >= 0; i--) {
		{ // Unsafe block
			res.str[s.len - i - 1] = string_at(s, i);
		}
	}
	{ // Unsafe block
		res.str[res.len] = 0;
	}
	return res;
}

string string_limit(string s, int max) {
	Array_rune u = string_runes(s);
	if (u.len <= max) {
		return string_clone(s);
	}
	return Array_rune_string(array_slice(u, 0, max));
}

int string_hash(string s) {
	u32 h = ((u32)(0U));
	if (h == 0U && s.len > 0) {
		for (int _t1 = 0; _t1 < s.len; ++_t1) {
			byte c = s.str[_t1];
			h = h * 31U + ((u32)(c));
		}
	}
	return ((int)(h));
}

Array_byte string_bytes(string s) {
	if (s.len == 0) {
		return __new_array_with_default(0, 0, sizeof(byte), 0);
	}
	Array_byte buf = __new_array_with_default(s.len, 0, sizeof(byte), 0);
	vmemcpy(buf.data, s.str, s.len);
	return buf;
}

string string_repeat(string s, int count) {
	if (count < 0) {
		_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("string.repeat: count is negative: "), 0xfe07, {.d_i32 = count}}, {_SLIT0, 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	} else if (count == 0) {
		return _SLIT("");
	} else if (count == 1) {
		return string_clone(s);
	}
	byte* ret = malloc_noscan(s.len * count + 1);
	for (int i = 0; i < count; ++i) {
		for (int j = 0; j < s.len; ++j) {
			{ // Unsafe block
				ret[i * s.len + j] = string_at(s, j);
			}
		}
	}
	int new_len = s.len * count;
	{ // Unsafe block
		ret[new_len] = 0;
	}
	return byte_vstring_with_len(ret, new_len);
}

Array_string string_fields(string s) {
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	int word_start = 0;
	int word_len = 0;
	bool is_in_word = false;
	bool is_space = false;
	for (int i = 0; i < s.len; ++i) {
		byte c = s.str[i];
		is_space = (c == 32 || c == 9 || c == 10);
		if (!is_space) {
			word_len++;
		}
		if (!is_in_word && !is_space) {
			word_start = i;
			is_in_word = true;
			continue;
		}
		if (is_space && is_in_word) {
			array_push((array*)&res, _MOV((string[]){ string_substr(s, word_start, word_start + word_len) }));
			is_in_word = false;
			word_len = 0;
			word_start = 0;
			continue;
		}
	}
	if (is_in_word && word_len > 0) {
		array_push((array*)&res, _MOV((string[]){ string_substr(s, word_start, s.len) }));
	}
	return res;
}

string string_strip_margin(string s) {
	return string_strip_margin_custom(s, '|');
}

// Attr: [direct_array_access]
string string_strip_margin_custom(string s, byte del) {
	byte sep = del;
	if (byte_is_space(sep)) {
		println(_SLIT("Warning: `strip_margin` cannot use white-space as a delimiter"));
		println(_SLIT("    Defaulting to `|`"));
		sep = '|';
	}
	byte* ret = malloc_noscan(s.len + 1);
	int count = 0;
	for (int i = 0; i < s.len; i++) {
		if (s.str[ i] == 10 || s.str[ i] == 13) {
			{ // Unsafe block
				ret[count] = s.str[ i];
			}
			count++;
			if (s.str[ i] == 13 && i < s.len - 1 && s.str[ i + 1] == 10) {
				{ // Unsafe block
					ret[count] = s.str[ i + 1];
				}
				count++;
				i++;
			}
			for (;;) {
				if (!(s.str[ i] != sep)) break;
				i++;
				if (i >= s.len) {
					break;
				}
			}
		} else {
			{ // Unsafe block
				ret[count] = s.str[ i];
			}
			count++;
		}
	}
	{ // Unsafe block
		ret[count] = 0;
		return byte_vstring_with_len(ret, count);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [direct_array_access]
bool string_match_glob(string name, string pattern) {
	int px = 0;
	int nx = 0;
	int next_px = 0;
	int next_nx = 0;
	int plen = pattern.len;
	int nlen = name.len;
	for (;;) {
		if (!(px < plen || nx < nlen)) break;
		if (px < plen) {
			byte c = pattern.str[ px];

			if (c == ('?')) {
				if (nx < nlen) {
					px++;
					nx++;
					continue;
				}
			}
			else if (c == ('*')) {
				next_px = px;
				next_nx = nx + 1;
				px++;
				continue;
			}
			else if (c == ('[')) {
				if (nx < nlen) {
					byte wanted_c = name.str[ nx];
					int bstart = px;
					bool is_inverted = false;
					bool inner_match = false;
					int inner_idx = bstart + 1;
					int inner_c = 0;
					if (inner_idx < plen) {
						inner_c = pattern.str[ inner_idx];
						if (inner_c == '^') {
							is_inverted = true;
							inner_idx++;
						}
					}
					for (; inner_idx < plen; inner_idx++) {
						inner_c = pattern.str[ inner_idx];
						if (inner_c == ']') {
							break;
						}
						if (inner_c == wanted_c) {
							inner_match = true;
							for (;;) {
								if (!(px < plen && pattern.str[ px] != ']')) break;
								px++;
							}
							break;
						}
					}
					if (is_inverted) {
						if (inner_match) {
							return false;
						} else {
							px = inner_idx;
						}
					}
				}
				px++;
				nx++;
				continue;
			}
			else {
				if (nx < nlen && name.str[ nx] == c) {
					px++;
					nx++;
					continue;
				}
			};
		}
		if (0 < next_nx && next_nx <= nlen) {
			px = next_px;
			nx = next_nx;
			continue;
		}
		return false;
	}
	return true;
}

// Attr: [unsafe]
Array_byte byteptr_vbytes(byteptr data, int len) {
	return voidptr_vbytes(((voidptr)(data)), len);
}

// Attr: [unsafe]
string byteptr_vstring(byteptr bp) {
	return (string){.str = bp, .len = vstrlen(bp)};
}

// Attr: [unsafe]
string byteptr_vstring_with_len(byteptr bp, int len) {
	return (string){.str = bp, .len = len, .is_lit = 0};
}

// Attr: [unsafe]
string charptr_vstring(charptr cp) {
	return (string){.str = ((byteptr)(cp)), .len = vstrlen_char(cp), .is_lit = 0};
}

// Attr: [unsafe]
string charptr_vstring_with_len(charptr cp, int len) {
	return (string){.str = ((byteptr)(cp)), .len = len, .is_lit = 0};
}

// Attr: [unsafe]
string byteptr_vstring_literal(byteptr bp) {
	return (string){.str = bp, .len = vstrlen(bp), .is_lit = 1};
}

// Attr: [unsafe]
string byteptr_vstring_literal_with_len(byteptr bp, int len) {
	return (string){.str = bp, .len = len, .is_lit = 1};
}

// Attr: [unsafe]
string charptr_vstring_literal(charptr cp) {
	return (string){.str = ((byteptr)(cp)), .len = vstrlen_char(cp), .is_lit = 1};
}

// Attr: [unsafe]
string charptr_vstring_literal_with_len(charptr cp, int len) {
	return (string){.str = ((byteptr)(cp)), .len = len, .is_lit = 1};
}

string StrIntpType_str(StrIntpType x) {
	switch (x) {
		case StrIntpType__si_no_str: 
			{
				return _SLIT("no_str");
			} break;
		case StrIntpType__si_c: 
			{
				return _SLIT("c");
			} break;
		case StrIntpType__si_u8: 
			{
				return _SLIT("u8");
			} break;
		case StrIntpType__si_i8: 
			{
				return _SLIT("i8");
			} break;
		case StrIntpType__si_u16: 
			{
				return _SLIT("u16");
			} break;
		case StrIntpType__si_i16: 
			{
				return _SLIT("i16");
			} break;
		case StrIntpType__si_u32: 
			{
				return _SLIT("u32");
			} break;
		case StrIntpType__si_i32: 
			{
				return _SLIT("i32");
			} break;
		case StrIntpType__si_u64: 
			{
				return _SLIT("u64");
			} break;
		case StrIntpType__si_i64: 
			{
				return _SLIT("i64");
			} break;
		case StrIntpType__si_f32: 
			{
				return _SLIT("f32");
			} break;
		case StrIntpType__si_f64: 
			{
				return _SLIT("f64");
			} break;
		case StrIntpType__si_g32: 
			{
				return _SLIT("f32");
			} break;
		case StrIntpType__si_g64: 
			{
				return _SLIT("f64");
			} break;
		case StrIntpType__si_e32: 
			{
				return _SLIT("f32");
			} break;
		case StrIntpType__si_e64: 
			{
				return _SLIT("f64");
			} break;
		case StrIntpType__si_s: 
			{
				return _SLIT("s");
			} break;
		case StrIntpType__si_p: 
			{
				return _SLIT("p");
			} break;
		case StrIntpType__si_vp: 
			{
				return _SLIT("vp");
			} break;
	}
	;
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL f32 fabs32(f32 x) {
	return (x < 0 ? (-x) : (x));
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL f64 fabs64(f64 x) {
	return (x < 0 ? (-x) : (x));
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL u64 abs64(i64 x) {
	return (x < 0 ? (((u64)(-x))) : (((u64)(x))));
}

u64 get_str_intp_u64_format(StrIntpType fmt_type, int in_width, int in_precision, bool in_tail_zeros, bool in_sign, byte in_pad_ch, int in_base, bool in_upper_case) {
	u64 width = (in_width != 0 ? (abs64(in_width)) : (((u64)(0U))));
	u64 allign = (in_width > 0 ? (((u64)(1 << 5))) : (((u64)(0U))));
	u64 upper_case = (in_upper_case ? (((u64)(1 << 7))) : (((u64)(0U))));
	u64 sign = (in_sign ? (((u64)(1 << 8))) : (((u64)(0U))));
	u64 precision = (in_precision != 987698 ? ((((u64)((in_precision & 0x7F))) << 9U)) : (((u64)(0x7FU)) << 9U));
	u32 tail_zeros = (in_tail_zeros ? (((u32)(1U)) << 16U) : (((u32)(0U))));
	u64 base = ((u64)(((u32)((in_base & 0xf))) << 27U));
	u64 res = ((u64)(((((((((((((u64)(fmt_type)) & 0x1FU)) | allign) | upper_case) | sign) | precision) | tail_zeros) | (((u64)((width & 0x3FFU))) << 17U)) | base) | (((u64)(in_pad_ch)) << 31U))));
	return res;
}

u32 get_str_intp_u32_format(StrIntpType fmt_type, int in_width, int in_precision, bool in_tail_zeros, bool in_sign, byte in_pad_ch, int in_base, bool in_upper_case) {
	u64 width = (in_width != 0 ? (abs64(in_width)) : (((u32)(0U))));
	u32 allign = (in_width > 0 ? (((u32)(1 << 5))) : (((u32)(0U))));
	u32 upper_case = (in_upper_case ? (((u32)(1 << 7))) : (((u32)(0U))));
	u32 sign = (in_sign ? (((u32)(1 << 8))) : (((u32)(0U))));
	u32 precision = (in_precision != 987698 ? ((((u32)((in_precision & 0x7F))) << 9U)) : (((u32)(0x7FU)) << 9U));
	u32 tail_zeros = (in_tail_zeros ? (((u32)(1U)) << 16U) : (((u32)(0U))));
	u32 base = ((u32)(((u32)((in_base & 0xf))) << 27U));
	u32 res = ((u32)(((((((((((((u32)(fmt_type)) & 0x1FU)) | allign) | upper_case) | sign) | precision) | tail_zeros) | (((u32)((width & 0x3FFU))) << 17U)) | base) | (((u32)((in_pad_ch & 1))) << 31U))));
	return res;
}

// Attr: [manualfree]
VV_LOCAL_SYMBOL void StrIntpData_process_str_intp_data(StrIntpData* data, strings__Builder* sb) {
	u32 x = data->fmt;
	StrIntpType typ = ((StrIntpType)((x & 0x1FU)));
	int allign = ((int)(((x >> 5U) & 0x01U)));
	bool upper_case = (((x >> 7U) & 0x01U)) > 0U;
	int sign = ((int)(((x >> 8U) & 0x01U)));
	int precision = ((int)(((x >> 9U) & 0x7FU)));
	bool tail_zeros = (((x >> 16U) & 0x01U)) > 0U;
	int width = ((int)(((i16)(((x >> 17U) & 0x3FFU)))));
	int base = (((int)(x >> 27U)) & 0xF);
	byte fmt_pad_ch = ((byte)(((x >> 31U) & 0xFFU)));
	if (typ == StrIntpType__si_no_str) {
		return;
	}
	if (base > 0) {
		base += 2;
	}
	byte pad_ch = ((byte)(' '));
	if (fmt_pad_ch > 0) {
		pad_ch = '0';
	}
	int len0_set = (width > 0 ? (width) : (-1));
	int len1_set = (precision == 0x7F ? (-1) : (precision));
	bool sign_set = sign == 1;
	strconv__BF_param bf = (strconv__BF_param){
		.pad_ch = pad_ch,
		.len0 = len0_set,
		.len1 = len1_set,
		.positive = true,
		.sign_flag = sign_set,
		.allign = strconv__Align_text__left,
		.rm_tail_zero = tail_zeros,
	};
	if (fmt_pad_ch == 0) {

		if (allign == (0)) {
			bf.allign = strconv__Align_text__left;
		}
		else if (allign == (1)) {
			bf.allign = strconv__Align_text__right;
		}
		else {
			bf.allign = strconv__Align_text__left;
		};
	} else {
		bf.allign = strconv__Align_text__right;
	}
	{ // Unsafe block
		if (typ == StrIntpType__si_s) {
			string s = _SLIT("");
			if (upper_case) {
				s = string_to_upper(data->d.d_s);
			} else {
				s = string_clone(data->d.d_s);
			}
			if (width == 0) {
				strings__Builder_write_string(sb, s);
			} else {
				strconv__format_str_sb(s, bf, sb);
			}
			string_free(&s);
			return;
		}
		if (typ == StrIntpType__si_i8 || typ == StrIntpType__si_i16 || typ == StrIntpType__si_i32 || typ == StrIntpType__si_i64) {
			i64 d = data->d.d_i64;
			if (typ == StrIntpType__si_i8) {
				d = ((i64)(data->d.d_i8));
			} else if (typ == StrIntpType__si_i16) {
				d = ((i64)(data->d.d_i16));
			} else if (typ == StrIntpType__si_i32) {
				d = ((i64)(data->d.d_i32));
			}
			if (base == 0) {
				if (width == 0) {
					string d_str = i64_str(d);
					strings__Builder_write_string(sb, d_str);
					string_free(&d_str);
					return;
				}
				if (d < 0) {
					bf.positive = false;
				}
				strconv__format_dec_sb(abs64(d), bf, sb);
			} else {
				if (base == 3) {
					base = 2;
				}
				i64 absd = d;
				bool write_minus = false;
				if (d < 0 && pad_ch != ' ') {
					absd = -d;
					write_minus = true;
				}
				string hx = strconv__format_int(absd, base);
				if (upper_case) {
					string tmp = hx;
					hx = string_to_upper(hx);
					string_free(&tmp);
				}
				if (write_minus) {
					strings__Builder_write_b(sb, '-');
					bf.len0--;
				}
				if (width == 0) {
					strings__Builder_write_string(sb, hx);
				} else {
					strconv__format_str_sb(hx, bf, sb);
				}
				string_free(&hx);
			}
			return;
		}
		if (typ == StrIntpType__si_u8 || typ == StrIntpType__si_u16 || typ == StrIntpType__si_u32 || typ == StrIntpType__si_u64) {
			u64 d = data->d.d_u64;
			if (typ == StrIntpType__si_u8) {
				d = ((u64)(data->d.d_u8));
			} else if (typ == StrIntpType__si_u16) {
				d = ((u64)(data->d.d_u16));
			} else if (typ == StrIntpType__si_u32) {
				d = ((u64)(data->d.d_u32));
			}
			if (base == 0) {
				if (width == 0) {
					string d_str = u64_str(d);
					strings__Builder_write_string(sb, d_str);
					string_free(&d_str);
					return;
				}
				strconv__format_dec_sb(d, bf, sb);
			} else {
				if (base == 3) {
					base = 2;
				}
				string hx = strconv__format_uint(d, base);
				if (upper_case) {
					string tmp = hx;
					hx = string_to_upper(hx);
					string_free(&tmp);
				}
				if (width == 0) {
					strings__Builder_write_string(sb, hx);
				} else {
					strconv__format_str_sb(hx, bf, sb);
				}
				string_free(&hx);
			}
			return;
		}
		if (typ == StrIntpType__si_p) {
			u64 d = data->d.d_u64;
			base = 16;
			if (base == 0) {
				if (width == 0) {
					string d_str = u64_str(d);
					strings__Builder_write_string(sb, d_str);
					string_free(&d_str);
					return;
				}
				strconv__format_dec_sb(d, bf, sb);
			} else {
				string hx = strconv__format_uint(d, base);
				if (upper_case) {
					string tmp = hx;
					hx = string_to_upper(hx);
					string_free(&tmp);
				}
				if (width == 0) {
					strings__Builder_write_string(sb, hx);
				} else {
					strconv__format_str_sb(hx, bf, sb);
				}
				string_free(&hx);
			}
			return;
		}
		bool use_default_str = false;
		if (width == 0 && precision == 0x7F) {
			bf.len1 = 3;
			use_default_str = true;
		}
		if (bf.len1 < 0) {
			bf.len1 = 3;
		}
		switch (typ) {
			case StrIntpType__si_f32: 
				{
					#if !defined(CUSTOM_DEFINE_nofloat)
					{
						if (use_default_str) {
							string f = f32_str(data->d.d_f32);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
						} else {
							if (data->d.d_f32 < 0) {
								bf.positive = false;
							}
							string f = strconv__format_fl(data->d.d_f32, bf);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
						}
					}
					#endif
				} break;
			case StrIntpType__si_f64: 
				{
					#if !defined(CUSTOM_DEFINE_nofloat)
					{
						if (use_default_str) {
							string f = f64_str(data->d.d_f64);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
						} else {
							if (data->d.d_f64 < 0) {
								bf.positive = false;
							}
							strconv__Float64u f_union = (strconv__Float64u){.f = data->d.d_f64,};
							if (f_union.u == _const_strconv__double_minus_zero) {
								bf.positive = false;
							}
							string f = strconv__format_fl(data->d.d_f64, bf);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
						}
					}
					#endif
				} break;
			case StrIntpType__si_g32: 
				{
					if (use_default_str) {
						#if !defined(CUSTOM_DEFINE_nofloat)
						{
							string f = f32_strg(data->d.d_f32);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
						}
						#endif
					} else {
						if (data->d.d_f32 == _const_strconv__single_plus_zero) {
							string tmp_str = _SLIT("0");
							strconv__format_str_sb(tmp_str, bf, sb);
							string_free(&tmp_str);
							return;
						}
						if (data->d.d_f32 == _const_strconv__single_minus_zero) {
							string tmp_str = _SLIT("-0");
							strconv__format_str_sb(tmp_str, bf, sb);
							string_free(&tmp_str);
							return;
						}
						if (data->d.d_f32 == _const_strconv__single_plus_infinity) {
							string tmp_str = _SLIT("+inf");
							if (upper_case) {
								tmp_str = _SLIT("+INF");
							}
							strconv__format_str_sb(tmp_str, bf, sb);
							string_free(&tmp_str);
						}
						if (data->d.d_f32 == _const_strconv__single_minus_infinity) {
							string tmp_str = _SLIT("-inf");
							if (upper_case) {
								tmp_str = _SLIT("-INF");
							}
							strconv__format_str_sb(tmp_str, bf, sb);
							string_free(&tmp_str);
						}
						if (data->d.d_f32 < 0) {
							bf.positive = false;
						}
						f32 d = fabs32(data->d.d_f32);
						if (d < 999999.0 && d >= 0.00001) {
							string f = strconv__format_fl(data->d.d_f32, bf);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
							return;
						}
						string f = strconv__format_es(data->d.d_f32, bf);
						if (upper_case) {
							string tmp = f;
							f = string_to_upper(f);
							string_free(&tmp);
						}
						strings__Builder_write_string(sb, f);
						string_free(&f);
					}
				} break;
			case StrIntpType__si_g64: 
				{
					if (use_default_str) {
						#if !defined(CUSTOM_DEFINE_nofloat)
						{
							string f = f64_strg(data->d.d_f64);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
						}
						#endif
					} else {
						if (data->d.d_f64 == _const_strconv__double_plus_zero) {
							string tmp_str = _SLIT("0");
							strconv__format_str_sb(tmp_str, bf, sb);
							string_free(&tmp_str);
							return;
						}
						if (data->d.d_f64 == _const_strconv__double_minus_zero) {
							string tmp_str = _SLIT("-0");
							strconv__format_str_sb(tmp_str, bf, sb);
							string_free(&tmp_str);
							return;
						}
						if (data->d.d_f64 == _const_strconv__double_plus_infinity) {
							string tmp_str = _SLIT("+inf");
							if (upper_case) {
								tmp_str = _SLIT("+INF");
							}
							strconv__format_str_sb(tmp_str, bf, sb);
							string_free(&tmp_str);
						}
						if (data->d.d_f64 == _const_strconv__double_minus_infinity) {
							string tmp_str = _SLIT("-inf");
							if (upper_case) {
								tmp_str = _SLIT("-INF");
							}
							strconv__format_str_sb(tmp_str, bf, sb);
							string_free(&tmp_str);
						}
						if (data->d.d_f64 < 0) {
							bf.positive = false;
						}
						f64 d = fabs64(data->d.d_f64);
						if (d < 999999.0 && d >= 0.00001) {
							string f = strconv__format_fl(data->d.d_f64, bf);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
							return;
						}
						string f = strconv__format_es(data->d.d_f64, bf);
						if (upper_case) {
							string tmp = f;
							f = string_to_upper(f);
							string_free(&tmp);
						}
						strings__Builder_write_string(sb, f);
						string_free(&f);
					}
				} break;
			case StrIntpType__si_e32: 
				{
					#if !defined(CUSTOM_DEFINE_nofloat)
					{
						bf.len1 = 6;
						if (use_default_str) {
							string f = f32_str(data->d.d_f32);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
						} else {
							if (data->d.d_f32 < 0) {
								bf.positive = false;
							}
							string f = strconv__format_es(data->d.d_f32, bf);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
						}
					}
					#endif
				} break;
			case StrIntpType__si_e64: 
				{
					#if !defined(CUSTOM_DEFINE_nofloat)
					{
						bf.len1 = 6;
						if (use_default_str) {
							string f = f64_str(data->d.d_f64);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
						} else {
							if (data->d.d_f64 < 0) {
								bf.positive = false;
							}
							string f = strconv__format_es(data->d.d_f64, bf);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
						}
					}
					#endif
				} break;
			case StrIntpType__si_c: 
				{
					string ss = utf32_to_str(data->d.d_c);
					strings__Builder_write_string(sb, ss);
					string_free(&ss);
				} break;
			case StrIntpType__si_vp: 
				{
					string ss = u64_hex(((u64)(data->d.d_vp)));
					strings__Builder_write_string(sb, ss);
					string_free(&ss);
				} break;
			case StrIntpType__si_no_str:
			case StrIntpType__si_u8:
			case StrIntpType__si_i8:
			case StrIntpType__si_u16:
			case StrIntpType__si_i16:
			case StrIntpType__si_u32:
			case StrIntpType__si_i32:
			case StrIntpType__si_u64:
			case StrIntpType__si_i64:
			case StrIntpType__si_s:
			case StrIntpType__si_p:
			default:
				{
					strings__Builder_write_string(sb, _SLIT("***ERROR!***"));
				} break;
		}
		;
	}
}

// Attr: [direct_array_access]
// Attr: [manualfree]
string str_intp(int data_len, voidptr in_data) {
	strings__Builder res = strings__new_builder(256);
	StrIntpData* input_base = ((StrIntpData*)(in_data));
	for (int i = 0; i < data_len; i++) {
		StrIntpData* data = &(input_base[i]);
		if (data->str.len != 0) {
			strings__Builder_write_string(&res, data->str);
		}
		if (data->fmt != 0U) {
			StrIntpData_process_str_intp_data(data, (voidptr)&/*qq*/res);
		}
	}
	string ret = strings__Builder_str(&res);
	strings__Builder_free(&res);
	return ret;
}

// Attr: [inline]
inline string str_intp_sq(string in_str) {
	return  str_intp(3, _MOV((StrIntpData[]){{_SLIT("str_intp(2, _MOV((StrIntpData[]){{_SLIT(\"\'\"), "), 0xfe10, {.d_s = _const_si_s_code}}, {_SLIT(", {.d_s = "), 0xfe10, {.d_s = in_str}}, {_SLIT("}},{_SLIT(\"\'\"), 0, {.d_c = 0 }}}))"), 0, { .d_c = 0 }}}));
}

// Attr: [inline]
inline string str_intp_rune(string in_str) {
	return  str_intp(3, _MOV((StrIntpData[]){{_SLIT("str_intp(2, _MOV((StrIntpData[]){{_SLIT(\"`\"), "), 0xfe10, {.d_s = _const_si_s_code}}, {_SLIT(", {.d_s = "), 0xfe10, {.d_s = in_str}}, {_SLIT("}},{_SLIT(\"`\"), 0, {.d_c = 0 }}}))"), 0, { .d_c = 0 }}}));
}

// Attr: [inline]
inline string str_intp_g32(string in_str) {
	return  str_intp(3, _MOV((StrIntpData[]){{_SLIT("str_intp(1, _MOV((StrIntpData[]){{_SLIT0, "), 0xfe10, {.d_s = _const_si_g32_code}}, {_SLIT(", {.d_f32 = "), 0xfe10, {.d_s = in_str}}, {_SLIT(" }}}))"), 0, { .d_c = 0 }}}));
}

// Attr: [inline]
inline string str_intp_g64(string in_str) {
	return  str_intp(3, _MOV((StrIntpData[]){{_SLIT("str_intp(1, _MOV((StrIntpData[]){{_SLIT0, "), 0xfe10, {.d_s = _const_si_g64_code}}, {_SLIT(", {.d_f64 = "), 0xfe10, {.d_s = in_str}}, {_SLIT(" }}}))"), 0, { .d_c = 0 }}}));
}

// Attr: [manualfree]
string str_intp_sub(string base_str, string in_str) {
	Option_int _t1 = string_index(base_str, _SLIT("%%"));
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		eprintln(_SLIT("No strin interpolation %% parameteres"));
		_v_exit(1);
		VUNREACHABLE();
	;
	}
	
 	int index =  (*(int*)_t1.data);
	{ // Unsafe block
		string st_str = string_substr(base_str, 0, index);
		if (index + 2 < base_str.len) {
			string en_str = string_substr(base_str, index + 2, base_str.len);
			string res_str =  str_intp(5, _MOV((StrIntpData[]){{_SLIT("str_intp(2, _MOV((StrIntpData[]){{_SLIT(\""), 0xfe10, {.d_s = st_str}}, {_SLIT("\"), "), 0xfe10, {.d_s = _const_si_s_code}}, {_SLIT(", {.d_s = "), 0xfe10, {.d_s = in_str}}, {_SLIT(" }},{_SLIT(\""), 0xfe10, {.d_s = en_str}}, {_SLIT("\"), 0, {.d_c = 0}}}))"), 0, { .d_c = 0 }}}));
			string_free(&st_str);
			string_free(&en_str);
			return res_str;
		}
		string res2_str =  str_intp(4, _MOV((StrIntpData[]){{_SLIT("str_intp(1, _MOV((StrIntpData[]){{_SLIT(\""), 0xfe10, {.d_s = st_str}}, {_SLIT("\"), "), 0xfe10, {.d_s = _const_si_s_code}}, {_SLIT(", {.d_s = "), 0xfe10, {.d_s = in_str}}, {_SLIT(" }}}))"), 0, { .d_c = 0 }}}));
		string_free(&st_str);
		return res2_str;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

u16* string_to_wide(string _str) {
	#if defined(_WIN32)
	{
		{ // Unsafe block
			int num_chars = (MultiByteToWideChar(_const_cp_utf8, 0U, ((char*)(_str.str)), _str.len, 0, 0));
			u16* wstr = ((u16*)(malloc_noscan((num_chars + 1) * 2)));
			if (wstr != 0) {
				MultiByteToWideChar(_const_cp_utf8, 0U, ((char*)(_str.str)), _str.len, wstr, num_chars);
				memset(((byte*)(wstr)) + num_chars * 2, 0, 2);
			}
			return wstr;
		}
	}
	#else
	{
	}
	#endif
	return 0;
}

// Attr: [unsafe]
string string_from_wide(u16* _wstr) {
	#if defined(_WIN32)
	{
		{ // Unsafe block
			int wstr_len = wcslen(_wstr);
			return string_from_wide2(_wstr, wstr_len);
		}
	}
	#else
	{
	}
	#endif
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [unsafe]
string string_from_wide2(u16* _wstr, int len) {
	#if defined(_WIN32)
	{
		{ // Unsafe block
			int num_chars = WideCharToMultiByte(_const_cp_utf8, 0U, _wstr, len, 0, 0, 0, 0);
			byte* str_to = malloc_noscan(num_chars + 1);
			if (str_to != 0) {
				WideCharToMultiByte(_const_cp_utf8, 0U, _wstr, len, ((char*)(str_to)), num_chars, 0, 0);
				memset(str_to + num_chars, 0, 1);
			}
			return tos2(str_to);
		}
	}
	#else
	{
	}
	#endif
	return (string){.str=(byteptr)"", .is_lit=1};
}

int utf8_getchar(void) {
	int c = getchar();
	int len = utf8_len(((byte)(~c)));
	if (c < 0) {
		return 0;
	} else if (len == 0) {
		return c;
	} else if (len == 1) {
		return -1;
	} else {
		int uc = (c & ((1 << (7 - len)) - 1));
		for (int i = 0; i + 1 < len; i++) {
			int c2 = getchar();
			if (c2 != -1 && (c2 >> 6) == 2) {
				uc <<= 6;
				uc |= ((c2 & 63));
			} else if (c2 == -1) {
				return 0;
			} else {
				return -1;
			}
		}
		return uc;
	}
	return 0;
}

int utf8_char_len(byte b) {
	return (((0xe5000000 >> (((b >> 3) & 0x1e))) & 3)) + 1;
}

string utf32_to_str(u32 code) {
	{ // Unsafe block
		byte* buffer = malloc_noscan(5);
		string res = utf32_to_str_no_malloc(code, buffer);
		if (res.len == 0) {
			_v_free(buffer);
		}
		return res;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [manualfree]
// Attr: [unsafe]
string utf32_to_str_no_malloc(u32 code, byte* buf) {
	{ // Unsafe block
		int icode = ((int)(code));
		byte* buffer = ((byte*)(buf));
		if (icode <= 127) {
			buffer[0] = ((byte)(icode));
			buffer[1] = 0;
			return tos(buffer, 1);
		} else if (icode <= 2047) {
			buffer[0] = (192 | ((byte)(icode >> 6)));
			buffer[1] = (128 | ((byte)((icode & 63))));
			buffer[2] = 0;
			return tos(buffer, 2);
		} else if (icode <= 65535) {
			buffer[0] = (224 | ((byte)(icode >> 12)));
			buffer[1] = (128 | ((((byte)(icode >> 6)) & 63)));
			buffer[2] = (128 | ((byte)((icode & 63))));
			buffer[3] = 0;
			return tos(buffer, 3);
		} else if (icode <= 1114111) {
			buffer[0] = (240 | ((byte)(icode >> 18)));
			buffer[1] = (128 | ((((byte)(icode >> 12)) & 63)));
			buffer[2] = (128 | ((((byte)(icode >> 6)) & 63)));
			buffer[3] = (128 | ((byte)((icode & 63))));
			buffer[4] = 0;
			return tos(buffer, 4);
		}
	}
	return _SLIT("");
}

int string_utf32_code(string _rune) {
	if (_rune.len == 0) {
		return 0;
	}
	if (_rune.len == 1) {
		return ((int)(string_at(_rune, 0)));
	}
	byte b = ((byte)(((int)(string_at(_rune, 0)))));
	b = b << _rune.len;
	u32 res = ((u32)(b));
	int shift = 6 - _rune.len;
	for (int i = 1; i < _rune.len; i++) {
		u32 c = ((u32)(string_at(_rune, i)));
		res = ((u32)(res)) << shift;
		res |= (c & 63U);
		shift = 6;
	}
	return ((int)(res));
}

VV_LOCAL_SYMBOL int utf8_len(byte c) {
	int b = 0;
	byte x = c;
	if (((x & 240)) != 0) {
		x >>= 4;
	} else {
		b += 4;
	}
	if (((x & 12)) != 0) {
		x >>= 2;
	} else {
		b += 2;
	}
	if (((x & 2)) == 0) {
		b++;
	}
	return b;
}

int utf8_str_len(string s) {
	int l = 0;
	int i = 0;
	for (;;) {
		if (!(i < s.len)) break;
		l++;
		i += (((0xe5000000 >> (((s.str[i] >> 3) & 0x1e))) & 3)) + 1;
	}
	return l;
}

int utf8_str_visible_length(string s) {
	int l = 0;
	int ul = 1;
	for (int i = 0; i < s.len; i += ul) {
		byte c = s.str[i];
		ul = (((0xe5000000 >> (((s.str[i] >> 3) & 0x1e))) & 3)) + 1;
		if (i + ul > s.len) {
			return l;
		}
		l++;
		if (ul == 1) {
			continue;
		}

		if (ul == (2)) {
			u64 r = ((u64)(((((u16)(c)) << 8U) | s.str[i + 1])));
			if (r >= 0xcc80U && r < 0xcdb0U) {
				l--;
			}
		}
		else if (ul == (3)) {
			u64 r = ((u64)(((((u32)(c)) << 16U) | ((((u32)(s.str[i + 1])) << 8U) | s.str[i + 2]))));
			if ((r >= 0xe1aab0U && r <= 0xe1ac7fU) || (r >= 0xe1b780U && r <= 0xe1b87fU) || (r >= 0xe28390U && r <= 0xe2847fU) || (r >= 0xefb8a0U && r <= 0xefb8afU)) {
				l--;
			} else if ((r >= 0xe18480U && r <= 0xe1859fU) || (r >= 0xe2ba80U && r <= 0xe2bf95U) || (r >= 0xe38080U && r <= 0xe4b77fU) || (r >= 0xe4b880U && r <= 0xea807fU) || (r >= 0xeaa5a0U && r <= 0xeaa79fU) || (r >= 0xeab080U && r <= 0xed9eafU) || (r >= 0xefa480U && r <= 0xefac7fU) || (r >= 0xefb8b8U && r <= 0xefb9afU)) {
				l++;
			}
		}
		else if (ul == (4)) {
			u64 r = ((u64)(((((u32)(c)) << 24U) | (((((u32)(s.str[i + 1])) << 16U) | (((u32)(s.str[i + 2])) << 8U)) | s.str[i + 3]))));
			if ((r >= 0x0f9f8880U && r <= 0xf09f8a8fU) || (r >= 0xf09f8c80U && r <= 0xf09f9c90U) || (r >= 0xf09fa490U && r <= 0xf09fa7afU) || (r >= 0xf0a08080U && r <= 0xf180807fU)) {
				l++;
			}
		}
		else {
		};
	}
	return l;
}

// Attr: [inline]
inline string dl__get_shared_library_extension(void) {
	#if defined(_WIN32)
	string _t1 = _SLIT(".dll");
	#elif defined(__APPLE__)
	#else
	#endif
	;
	return _t1;
}

// Attr: [inline]
inline string dl__get_libname(string libname) {
	string _t1 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = libname}}, {_SLIT0, 0xfe10, {.d_s = _const_dl__dl_ext}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t1;
}

Option_voidptr dl__open_opt(string filename, int flags) {
	voidptr shared_object_handle = dl__open(filename, flags);
	if (shared_object_handle == 0) {
		string e = dl__dlerror();
		return (Option_voidptr){ .state=2, .err=_v_error(e), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Option_voidptr _t2;
	opt_ok(&(voidptr[]) { shared_object_handle }, (Option*)(&_t2), sizeof(voidptr));
	return _t2;
}

Option_voidptr dl__sym_opt(voidptr shared_object_handle, string symbol) {
	voidptr sym_handle = dl__sym(shared_object_handle, symbol);
	if (sym_handle == 0) {
		string e = dl__dlerror();
		return (Option_voidptr){ .state=2, .err=_v_error(e), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Option_voidptr _t2;
	opt_ok(&(voidptr[]) { sym_handle }, (Option*)(&_t2), sizeof(voidptr));
	return _t2;
}

voidptr dl__open(string filename, int flags) {
	voidptr res = LoadLibrary(string_to_wide(filename));
	voidptr _t1 = res;
	return _t1;
}

bool dl__close(voidptr handle) {
	bool _t1 = FreeLibrary(handle);
	return _t1;
}

voidptr dl__sym(voidptr handle, string symbol) {
	voidptr _t1 = GetProcAddress(handle, symbol.str);
	return _t1;
}

string dl__dlerror(void) {
	int cerr = ((int)(GetLastError()));
	string _t1 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("error code "), 0xfe07, {.d_i32 = cerr}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t1;
}

strings__textscanner__TextScanner strings__textscanner__new(string input) {
	strings__textscanner__TextScanner _t1 = (strings__textscanner__TextScanner){.input = input,.ilen = input.len,.pos = 0,};
	return _t1;
}

// Attr: [unsafe]
void strings__textscanner__TextScanner_free(strings__textscanner__TextScanner* ss) {
	string_free(&ss->input);
}

// Attr: [inline]
inline int strings__textscanner__TextScanner_remaining(strings__textscanner__TextScanner* ss) {
	int _t1 = ss->ilen - ss->pos;
	return _t1;
}

// Attr: [direct_array_access]
// Attr: [inline]
inline int strings__textscanner__TextScanner_next(strings__textscanner__TextScanner* ss) {
	if (ss->pos < ss->ilen) {
		int opos = ss->pos;
		ss->pos++;
		int _t1 = ss->input.str[ opos];
		return _t1;
	}
	int _t2 = -1;
	return _t2;
}

// Attr: [inline]
inline void strings__textscanner__TextScanner_skip(strings__textscanner__TextScanner* ss) {
	if (ss->pos + 1 < ss->ilen) {
		ss->pos++;
	}
}

// Attr: [inline]
inline void strings__textscanner__TextScanner_skip_n(strings__textscanner__TextScanner* ss, int n) {
	ss->pos += n;
	if (ss->pos > ss->ilen) {
		ss->pos = ss->ilen;
	}
}

// Attr: [direct_array_access]
// Attr: [inline]
inline int strings__textscanner__TextScanner_peek(strings__textscanner__TextScanner* ss) {
	if (ss->pos < ss->ilen) {
		int _t1 = ss->input.str[ ss->pos];
		return _t1;
	}
	int _t2 = -1;
	return _t2;
}

// Attr: [direct_array_access]
// Attr: [inline]
inline int strings__textscanner__TextScanner_peek_n(strings__textscanner__TextScanner* ss, int n) {
	if (ss->pos + n < ss->ilen) {
		int _t1 = ss->input.str[ ss->pos + n];
		return _t1;
	}
	int _t2 = -1;
	return _t2;
}

// Attr: [inline]
inline void strings__textscanner__TextScanner_back(strings__textscanner__TextScanner* ss) {
	if (ss->pos > 0) {
		ss->pos--;
	}
}

void strings__textscanner__TextScanner_back_n(strings__textscanner__TextScanner* ss, int n) {
	ss->pos -= n;
	if (ss->pos < 0) {
		ss->pos = 0;
	}
	if (ss->pos > ss->ilen) {
		ss->pos = ss->ilen;
	}
}

// Attr: [direct_array_access]
// Attr: [inline]
inline int strings__textscanner__TextScanner_peek_back(strings__textscanner__TextScanner* ss) {
	int _t1 = strings__textscanner__TextScanner_peek_back_n(ss, 1);
	return _t1;
}

// Attr: [direct_array_access]
// Attr: [inline]
inline int strings__textscanner__TextScanner_peek_back_n(strings__textscanner__TextScanner* ss, int n) {
	int offset = n + 1;
	if (ss->pos >= offset) {
		int _t1 = ss->input.str[ ss->pos - offset];
		return _t1;
	}
	int _t2 = -1;
	return _t2;
}

// Attr: [direct_array_access]
// Attr: [inline]
inline int strings__textscanner__TextScanner_current(strings__textscanner__TextScanner* ss) {
	if (ss->pos > 0) {
		int _t1 = ss->input.str[ ss->pos - 1];
		return _t1;
	}
	int _t2 = -1;
	return _t2;
}

void strings__textscanner__TextScanner_reset(strings__textscanner__TextScanner* ss) {
	ss->pos = 0;
}

void strings__textscanner__TextScanner_goto_end(strings__textscanner__TextScanner* ss) {
	ss->pos = ss->ilen;
}

Array_string os__cmdline__options(Array_string args, string param) {
	Array_string flags = __new_array_with_default(0, 0, sizeof(string), 0);
	for (int i = 0; i < args.len; ++i) {
		string v = ((string*)args.data)[i];
		if (string__eq(v, param)) {
			if (i + 1 < args.len) {
				array_push((array*)&flags, _MOV((string[]){ string_clone((*(string*)/*ee elem_typ */array_get(args, i + 1))) }));
			}
		}
	}
	Array_string _t2 = flags;
	return _t2;
}

string os__cmdline__option(Array_string args, string param, string def) {
	bool found = false;
	for (int _t1 = 0; _t1 < args.len; ++_t1) {
		string arg = ((string*)args.data)[_t1];
		if (found) {
			string _t2 = arg;
			return _t2;
		} else if (string__eq(param, arg)) {
			found = true;
		}
	}
	string _t3 = def;
	return _t3;
}

Array_string os__cmdline__options_before(Array_string args, Array_string what) {
	Array_string args_before = __new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t1 = 0; _t1 < args.len; ++_t1) {
		string a = ((string*)args.data)[_t1];
		if (Array_string_contains(what, a)) {
			break;
		}
		array_push((array*)&args_before, _MOV((string[]){ string_clone(a) }));
	}
	Array_string _t3 = args_before;
	return _t3;
}

Array_string os__cmdline__options_after(Array_string args, Array_string what) {
	bool found = false;
	Array_string args_after = __new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t1 = 0; _t1 < args.len; ++_t1) {
		string a = ((string*)args.data)[_t1];
		if (Array_string_contains(what, a)) {
			found = true;
			continue;
		}
		if (found) {
			array_push((array*)&args_after, _MOV((string[]){ string_clone(a) }));
		}
	}
	Array_string _t3 = args_after;
	return _t3;
}

Array_string os__cmdline__only_non_options(Array_string args) {
	Array_string _t2 = __new_array(0, 0, sizeof(string));
	Array_string _t2_orig = args;
	int _t2_len = _t2_orig.len;
	_t2 = __new_array(0, _t2_len, sizeof(string));

	for (int _t3 = 0; _t3 < _t2_len; ++_t3) {
		string it = ((string*) _t2_orig.data)[_t3];
		if (!string_starts_with(it, _SLIT("-"))) {
			array_push((array*)&_t2, &it);
		}
	}
	Array_string _t1 =_t2;
	return _t1;
}

Array_string os__cmdline__only_options(Array_string args) {
	Array_string _t2 = __new_array(0, 0, sizeof(string));
	Array_string _t2_orig = args;
	int _t2_len = _t2_orig.len;
	_t2 = __new_array(0, _t2_len, sizeof(string));

	for (int _t3 = 0; _t3 < _t2_len; ++_t3) {
		string it = ((string*) _t2_orig.data)[_t3];
		if (string_starts_with(it, _SLIT("-"))) {
			array_push((array*)&_t2, &it);
		}
	}
	Array_string _t1 =_t2;
	return _t1;
}

// Attr: [inline]
inline int math__mathutil__min_T_int(int a, int b) {
	int _t1 = (a < b ? (a) : (b));
	return _t1;
}

// Attr: [inline]
inline int math__mathutil__max_T_int(int a, int b) {
	int _t1 = (a > b ? (a) : (b));
	return _t1;
}

v__token__KeywordsMatcher v__token__new_keywords_matcher_T_v__token__Kind(Map_string_v__token__Kind kw_map) {
	v__token__KeywordsMatcher km = (v__token__KeywordsMatcher){.len_min = 9999,.len_max = -1,.words = {0},};
	for (int i = 0; i < _const_v__token__max_keyword_len; ++i) {
		km.words[v_fixed_index(i, 20)] = __new_array_with_default(0, 0, sizeof(v__token__WIndex), 0);
	}
	int _t2 = kw_map.key_values.len;
	for (int _t1 = 0; _t1 < _t2; ++_t1 ) {
		int _t3 = kw_map.key_values.len - _t2;
		_t2 = kw_map.key_values.len;
		if (_t3 < 0) {
			_t1 = -1;
			continue;
		}
		if (!DenseArray_has_index(&kw_map.key_values, _t1)) {continue;}
		string k = /*key*/ *(string*)DenseArray_key(&kw_map.key_values, _t1);
		k = string_clone(k);
		v__token__Kind v = (*(v__token__Kind*)DenseArray_value(&kw_map.key_values, _t1));
		v__token__KeywordsMatcher_add_word(&km, k, ((int)(v)));
	}
	for (int i = 0; i < _const_v__token__max_keyword_len; ++i) {
		if (km.words[v_fixed_index(i, 20)].len > 0) {
			qsort(km.words[v_fixed_index(i, 20)].data, km.words[v_fixed_index(i, 20)].len, km.words[v_fixed_index(i, 20)].element_size, (int (*)(const void *, const void *))&compare_7621314236064146737_v__token__WIndex_by_word);
		}
	}
	v__token__KeywordsMatcher _t4 = km;
	return _t4;
}
v__token__KeywordsMatcher v__token__new_keywords_matcher_T_int(Map_string_int kw_map) {
	v__token__KeywordsMatcher km = (v__token__KeywordsMatcher){.len_min = 9999,.len_max = -1,.words = {0},};
	for (int i = 0; i < _const_v__token__max_keyword_len; ++i) {
		km.words[v_fixed_index(i, 20)] = __new_array_with_default(0, 0, sizeof(v__token__WIndex), 0);
	}
	int _t2 = kw_map.key_values.len;
	for (int _t1 = 0; _t1 < _t2; ++_t1 ) {
		int _t3 = kw_map.key_values.len - _t2;
		_t2 = kw_map.key_values.len;
		if (_t3 < 0) {
			_t1 = -1;
			continue;
		}
		if (!DenseArray_has_index(&kw_map.key_values, _t1)) {continue;}
		string k = /*key*/ *(string*)DenseArray_key(&kw_map.key_values, _t1);
		k = string_clone(k);
		int v = (*(int*)DenseArray_value(&kw_map.key_values, _t1));
		v__token__KeywordsMatcher_add_word(&km, k, ((int)(v)));
	}
	for (int i = 0; i < _const_v__token__max_keyword_len; ++i) {
		if (km.words[v_fixed_index(i, 20)].len > 0) {
			qsort(km.words[v_fixed_index(i, 20)].data, km.words[v_fixed_index(i, 20)].len, km.words[v_fixed_index(i, 20)].element_size, (int (*)(const void *, const void *))&compare_7621314236064146737_v__token__WIndex_by_word);
		}
	}
	v__token__KeywordsMatcher _t4 = km;
	return _t4;
}

VV_LOCAL_SYMBOL void v__token__KeywordsMatcher_add_word(v__token__KeywordsMatcher* km, string word, int kind) {
	if (word.len >= _const_v__token__max_keyword_len) {
		_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("increase max_keyword_len to > "), 0xfe07, {.d_i32 = word.len}}, {_SLIT0, 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	if (km->len_max < word.len) {
		km->len_max = word.len;
	}
	if (word.len < km->len_min) {
		km->len_min = word.len;
	}
	array_push((array*)&km->words[v_fixed_index(word.len, 20)], _MOV((v__token__WIndex[]){ (v__token__WIndex){.word = word,.index = kind,} }));
}

// Attr: [direct_array_access]
int v__token__KeywordsMatcher_find(v__token__KeywordsMatcher* km, string word) {
	int wlen = word.len;
	if (wlen < km->len_min || wlen > km->len_max) {
		int _t1 = -1;
		return _t1;
	}
	int list_len = km->words[wlen].len;
	if (list_len == 0) {
		int _t2 = -1;
		return _t2;
	}
	int lo = 0;
	int hi = list_len - 1;
	for (;;) {
		if (!(lo <= hi)) break;
		int mid = lo + (hi - lo) / 2;
		int cmp = string_compare(((v__token__WIndex*)km->words[wlen].data)[mid].word, word);

		if (cmp == (0)) {
			int _t3 = ((v__token__WIndex*)km->words[wlen].data)[mid].index;
			return _t3;
		}
		else if (cmp == (-1)) {
			lo = mid + 1;
		}
		else if (cmp == (1)) {
			hi = mid - 1;
		}
		else {
		};
	}
	int _t4 = -1;
	return _t4;
}

// Attr: [unsafe]
void v__token__Position_free(v__token__Position* p) {
}

string v__token__Position_line_str(v__token__Position p) {
	string _t1 =  str_intp(5, _MOV((StrIntpData[]){{_SLIT("{l: "), 0xafe27, {.d_i32 = p.line_nr + 1}}, {_SLIT(", c: "), 0x6fe27, {.d_i32 = p.col}}, {_SLIT(", p: "), 0xafe27, {.d_i32 = p.pos}}, {_SLIT(", ll: "), 0xafe27, {.d_i32 = p.last_line + 1}}, {_SLIT("}"), 0, { .d_c = 0 }}}));
	return _t1;
}

v__token__Position v__token__Position_extend(v__token__Position pos, v__token__Position end) {
	v__token__Position _t1 = (v__token__Position){.len = end.pos - pos.pos + end.len,pos.line_nr,pos.pos,pos.col,.last_line = end.last_line,};
	return _t1;
}

v__token__Position v__token__Position_extend_with_last_line(v__token__Position pos, v__token__Position end, int last_line) {
	v__token__Position _t1 = (v__token__Position){.len = end.pos - pos.pos + end.len,.line_nr = pos.line_nr,.pos = pos.pos,.col = pos.col,.last_line = last_line - 1,};
	return _t1;
}

void v__token__Position_update_last_line(v__token__Position* pos, int last_line) {
	pos->last_line = last_line - 1;
}

// Attr: [inline]
inline v__token__Position v__token__Token_position(v__token__Token* tok) {
	v__token__Position _t1 = (v__token__Position){.len = tok->len,.line_nr = tok->line_nr - 1,.pos = tok->pos,.col = tok->col - 1,.last_line = tok->line_nr - 1,};
	return _t1;
}

VV_LOCAL_SYMBOL Map_string_v__token__Kind v__token__build_keys(void) {
	Map_string_v__token__Kind res = new_map(sizeof(string), sizeof(v__token__Kind), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
	for (int t = ((int)(v__token__Kind__keyword_beg)) + 1; t < ((int)(v__token__Kind__keyword_end)); ++t) {
		string key = (*(string*)/*ee elem_typ */array_get(_const_v__token__token_str, t));
		map_set(&res, &(string[]){key}, &(v__token__Kind[]) { ((v__token__Kind)(t)) });
	}
	Map_string_v__token__Kind _t1 = res;
	return _t1;
}

VV_LOCAL_SYMBOL Array_string v__token__build_token_str(void) {
	Array_string s = __new_array_with_default(_const_v__token__nr_tokens, 0, sizeof(string), &(string[]){_SLIT("")});
	array_set(&s, v__token__Kind__unknown, &(string[]) { _SLIT("unknown") });
	array_set(&s, v__token__Kind__eof, &(string[]) { _SLIT("eof") });
	array_set(&s, v__token__Kind__name, &(string[]) { _SLIT("name") });
	array_set(&s, v__token__Kind__number, &(string[]) { _SLIT("number") });
	array_set(&s, v__token__Kind__string, &(string[]) { _SLIT("string") });
	array_set(&s, v__token__Kind__chartoken, &(string[]) { _SLIT("char") });
	array_set(&s, v__token__Kind__plus, &(string[]) { _SLIT("+") });
	array_set(&s, v__token__Kind__minus, &(string[]) { _SLIT("-") });
	array_set(&s, v__token__Kind__mul, &(string[]) { _SLIT("*") });
	array_set(&s, v__token__Kind__div, &(string[]) { _SLIT("/") });
	array_set(&s, v__token__Kind__mod, &(string[]) { _SLIT("%") });
	array_set(&s, v__token__Kind__xor, &(string[]) { _SLIT("^") });
	array_set(&s, v__token__Kind__bit_not, &(string[]) { _SLIT("~") });
	array_set(&s, v__token__Kind__pipe, &(string[]) { _SLIT("|") });
	array_set(&s, v__token__Kind__hash, &(string[]) { _SLIT("#") });
	array_set(&s, v__token__Kind__amp, &(string[]) { _SLIT("&") });
	array_set(&s, v__token__Kind__inc, &(string[]) { _SLIT("++") });
	array_set(&s, v__token__Kind__dec, &(string[]) { _SLIT("--") });
	array_set(&s, v__token__Kind__and, &(string[]) { _SLIT("&&") });
	array_set(&s, v__token__Kind__logical_or, &(string[]) { _SLIT("||") });
	array_set(&s, v__token__Kind__not, &(string[]) { _SLIT("!") });
	array_set(&s, v__token__Kind__dot, &(string[]) { _SLIT(".") });
	array_set(&s, v__token__Kind__dotdot, &(string[]) { _SLIT("..") });
	array_set(&s, v__token__Kind__ellipsis, &(string[]) { _SLIT("...") });
	array_set(&s, v__token__Kind__comma, &(string[]) { _SLIT(",") });
	array_set(&s, v__token__Kind__not_in, &(string[]) { _SLIT("!in") });
	array_set(&s, v__token__Kind__not_is, &(string[]) { _SLIT("!is") });
	array_set(&s, v__token__Kind__semicolon, &(string[]) { _SLIT(";") });
	array_set(&s, v__token__Kind__colon, &(string[]) { _SLIT(":") });
	array_set(&s, v__token__Kind__arrow, &(string[]) { _SLIT("<-") });
	array_set(&s, v__token__Kind__assign, &(string[]) { _SLIT("=") });
	array_set(&s, v__token__Kind__decl_assign, &(string[]) { _SLIT(":=") });
	array_set(&s, v__token__Kind__plus_assign, &(string[]) { _SLIT("+=") });
	array_set(&s, v__token__Kind__minus_assign, &(string[]) { _SLIT("-=") });
	array_set(&s, v__token__Kind__mult_assign, &(string[]) { _SLIT("*=") });
	array_set(&s, v__token__Kind__div_assign, &(string[]) { _SLIT("/=") });
	array_set(&s, v__token__Kind__xor_assign, &(string[]) { _SLIT("^=") });
	array_set(&s, v__token__Kind__mod_assign, &(string[]) { _SLIT("%=") });
	array_set(&s, v__token__Kind__or_assign, &(string[]) { _SLIT("|=") });
	array_set(&s, v__token__Kind__and_assign, &(string[]) { _SLIT("&=") });
	array_set(&s, v__token__Kind__right_shift_assign, &(string[]) { _SLIT(">>=") });
	array_set(&s, v__token__Kind__unsigned_right_shift_assign, &(string[]) { _SLIT(">>>=") });
	array_set(&s, v__token__Kind__left_shift_assign, &(string[]) { _SLIT("<<=") });
	array_set(&s, v__token__Kind__lcbr, &(string[]) { _SLIT("{") });
	array_set(&s, v__token__Kind__rcbr, &(string[]) { _SLIT("}") });
	array_set(&s, v__token__Kind__lpar, &(string[]) { _SLIT("(") });
	array_set(&s, v__token__Kind__rpar, &(string[]) { _SLIT(")") });
	array_set(&s, v__token__Kind__lsbr, &(string[]) { _SLIT("[") });
	array_set(&s, v__token__Kind__nilsbr, &(string[]) { _SLIT("#[") });
	array_set(&s, v__token__Kind__rsbr, &(string[]) { _SLIT("]") });
	array_set(&s, v__token__Kind__eq, &(string[]) { _SLIT("==") });
	array_set(&s, v__token__Kind__ne, &(string[]) { _SLIT("!=") });
	array_set(&s, v__token__Kind__gt, &(string[]) { _SLIT(">") });
	array_set(&s, v__token__Kind__lt, &(string[]) { _SLIT("<") });
	array_set(&s, v__token__Kind__ge, &(string[]) { _SLIT(">=") });
	array_set(&s, v__token__Kind__le, &(string[]) { _SLIT("<=") });
	array_set(&s, v__token__Kind__question, &(string[]) { _SLIT("?") });
	array_set(&s, v__token__Kind__left_shift, &(string[]) { _SLIT("<<") });
	array_set(&s, v__token__Kind__right_shift, &(string[]) { _SLIT(">>") });
	array_set(&s, v__token__Kind__unsigned_right_shift, &(string[]) { _SLIT(">>>") });
	array_set(&s, v__token__Kind__comment, &(string[]) { _SLIT("comment") });
	array_set(&s, v__token__Kind__nl, &(string[]) { _SLIT("NLL") });
	array_set(&s, v__token__Kind__dollar, &(string[]) { _SLIT("$") });
	array_set(&s, v__token__Kind__at, &(string[]) { _SLIT("@") });
	array_set(&s, v__token__Kind__str_dollar, &(string[]) { _SLIT("$2") });
	array_set(&s, v__token__Kind__key_assert, &(string[]) { _SLIT("assert") });
	array_set(&s, v__token__Kind__key_struct, &(string[]) { _SLIT("struct") });
	array_set(&s, v__token__Kind__key_if, &(string[]) { _SLIT("if") });
	array_set(&s, v__token__Kind__key_else, &(string[]) { _SLIT("else") });
	array_set(&s, v__token__Kind__key_asm, &(string[]) { _SLIT("asm") });
	array_set(&s, v__token__Kind__key_return, &(string[]) { _SLIT("return") });
	array_set(&s, v__token__Kind__key_module, &(string[]) { _SLIT("module") });
	array_set(&s, v__token__Kind__key_sizeof, &(string[]) { _SLIT("sizeof") });
	array_set(&s, v__token__Kind__key_isreftype, &(string[]) { _SLIT("isreftype") });
	array_set(&s, v__token__Kind__key_likely, &(string[]) { _SLIT("_likely_") });
	array_set(&s, v__token__Kind__key_unlikely, &(string[]) { _SLIT("_unlikely_") });
	array_set(&s, v__token__Kind__key_go, &(string[]) { _SLIT("go") });
	array_set(&s, v__token__Kind__key_goto, &(string[]) { _SLIT("goto") });
	array_set(&s, v__token__Kind__key_const, &(string[]) { _SLIT("const") });
	array_set(&s, v__token__Kind__key_mut, &(string[]) { _SLIT("mut") });
	array_set(&s, v__token__Kind__key_shared, &(string[]) { _SLIT("shared") });
	array_set(&s, v__token__Kind__key_lock, &(string[]) { _SLIT("lock") });
	array_set(&s, v__token__Kind__key_rlock, &(string[]) { _SLIT("rlock") });
	array_set(&s, v__token__Kind__key_type, &(string[]) { _SLIT("type") });
	array_set(&s, v__token__Kind__key_for, &(string[]) { _SLIT("for") });
	array_set(&s, v__token__Kind__key_fn, &(string[]) { _SLIT("fn") });
	array_set(&s, v__token__Kind__key_true, &(string[]) { _SLIT("true") });
	array_set(&s, v__token__Kind__key_false, &(string[]) { _SLIT("false") });
	array_set(&s, v__token__Kind__key_continue, &(string[]) { _SLIT("continue") });
	array_set(&s, v__token__Kind__key_break, &(string[]) { _SLIT("break") });
	array_set(&s, v__token__Kind__key_import, &(string[]) { _SLIT("import") });
	array_set(&s, v__token__Kind__key_unsafe, &(string[]) { _SLIT("unsafe") });
	array_set(&s, v__token__Kind__key_typeof, &(string[]) { _SLIT("typeof") });
	array_set(&s, v__token__Kind__key_dump, &(string[]) { _SLIT("dump") });
	array_set(&s, v__token__Kind__key_enum, &(string[]) { _SLIT("enum") });
	array_set(&s, v__token__Kind__key_interface, &(string[]) { _SLIT("interface") });
	array_set(&s, v__token__Kind__key_pub, &(string[]) { _SLIT("pub") });
	array_set(&s, v__token__Kind__key_in, &(string[]) { _SLIT("in") });
	array_set(&s, v__token__Kind__key_atomic, &(string[]) { _SLIT("atomic") });
	array_set(&s, v__token__Kind__key_orelse, &(string[]) { _SLIT("or") });
	array_set(&s, v__token__Kind__key_global, &(string[]) { _SLIT("__global") });
	array_set(&s, v__token__Kind__key_union, &(string[]) { _SLIT("union") });
	array_set(&s, v__token__Kind__key_static, &(string[]) { _SLIT("static") });
	array_set(&s, v__token__Kind__key_volatile, &(string[]) { _SLIT("volatile") });
	array_set(&s, v__token__Kind__key_as, &(string[]) { _SLIT("as") });
	array_set(&s, v__token__Kind__key_defer, &(string[]) { _SLIT("defer") });
	array_set(&s, v__token__Kind__key_match, &(string[]) { _SLIT("match") });
	array_set(&s, v__token__Kind__key_select, &(string[]) { _SLIT("select") });
	array_set(&s, v__token__Kind__key_none, &(string[]) { _SLIT("none") });
	array_set(&s, v__token__Kind__key_offsetof, &(string[]) { _SLIT("__offsetof") });
	array_set(&s, v__token__Kind__key_is, &(string[]) { _SLIT("is") });
	Array_string _t1 = s;
	return _t1;
}

// Attr: [inline]
inline bool v__token__is_key(string key) {
	bool _t1 = ((int)((*(v__token__Kind*)map_get(ADDR(map, _const_v__token__keywords), &(string[]){key}, &(v__token__Kind[]){ 0 })))) > 0;
	return _t1;
}

// Attr: [inline]
inline bool v__token__is_decl(v__token__Kind t) {
	bool _t1 = (t == v__token__Kind__key_enum || t == v__token__Kind__key_interface || t == v__token__Kind__key_fn || t == v__token__Kind__key_struct || t == v__token__Kind__key_type || t == v__token__Kind__key_const || t == v__token__Kind__key_pub || t == v__token__Kind__eof);
	return _t1;
}

// Attr: [inline]
inline bool v__token__Kind_is_assign(v__token__Kind t) {
	bool _t1 = Array_v__token__Kind_contains(_const_v__token__assign_tokens, t);
	return _t1;
}

// Attr: [inline]
inline string v__token__Kind_str(v__token__Kind t) {
	string _t1 = (*(string*)/*ee elem_typ */array_get(_const_v__token__token_str, ((int)(t))));
	return _t1;
}

string v__token__Token_str(v__token__Token t) {
	string s = v__token__Kind_str(t.kind);
	if (s.len == 0) {
		eprintln(_SLIT("missing token kind string"));
	} else if (!byte_is_letter(string_at(s, 0))) {
		string _t1 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("token `"), 0xfe10, {.d_s = s}}, {_SLIT("`"), 0, { .d_c = 0 }}}));
		return _t1;
	}
	if (v__token__is_key(t.lit)) {
		s = _SLIT("keyword");
	}
	if ((t.lit).len != 0) {
		s = /*f*/string__plus(s,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(" `"), 0xfe10, {.d_s = t.lit}}, {_SLIT("`"), 0, { .d_c = 0 }}})));
	}
	string _t2 = s;
	return _t2;
}

Array_v__token__Precedence v__token__build_precedences(void) {
	Array_v__token__Precedence p = __new_array_with_default(((int)(v__token__Kind___end_)), 0, sizeof(v__token__Precedence), 0);
	array_set(&p, v__token__Kind__lsbr, &(v__token__Precedence[]) { v__token__Precedence__index });
	array_set(&p, v__token__Kind__nilsbr, &(v__token__Precedence[]) { v__token__Precedence__index });
	array_set(&p, v__token__Kind__dot, &(v__token__Precedence[]) { v__token__Precedence__call });
	array_set(&p, v__token__Kind__inc, &(v__token__Precedence[]) { v__token__Precedence__postfix });
	array_set(&p, v__token__Kind__dec, &(v__token__Precedence[]) { v__token__Precedence__postfix });
	array_set(&p, v__token__Kind__question, &(v__token__Precedence[]) { v__token__Precedence__postfix });
	array_set(&p, v__token__Kind__mul, &(v__token__Precedence[]) { v__token__Precedence__product });
	array_set(&p, v__token__Kind__div, &(v__token__Precedence[]) { v__token__Precedence__product });
	array_set(&p, v__token__Kind__mod, &(v__token__Precedence[]) { v__token__Precedence__product });
	array_set(&p, v__token__Kind__left_shift, &(v__token__Precedence[]) { v__token__Precedence__product });
	array_set(&p, v__token__Kind__right_shift, &(v__token__Precedence[]) { v__token__Precedence__product });
	array_set(&p, v__token__Kind__unsigned_right_shift, &(v__token__Precedence[]) { v__token__Precedence__product });
	array_set(&p, v__token__Kind__amp, &(v__token__Precedence[]) { v__token__Precedence__product });
	array_set(&p, v__token__Kind__arrow, &(v__token__Precedence[]) { v__token__Precedence__product });
	array_set(&p, v__token__Kind__plus, &(v__token__Precedence[]) { v__token__Precedence__sum });
	array_set(&p, v__token__Kind__minus, &(v__token__Precedence[]) { v__token__Precedence__sum });
	array_set(&p, v__token__Kind__pipe, &(v__token__Precedence[]) { v__token__Precedence__sum });
	array_set(&p, v__token__Kind__xor, &(v__token__Precedence[]) { v__token__Precedence__sum });
	array_set(&p, v__token__Kind__eq, &(v__token__Precedence[]) { v__token__Precedence__eq });
	array_set(&p, v__token__Kind__ne, &(v__token__Precedence[]) { v__token__Precedence__eq });
	array_set(&p, v__token__Kind__lt, &(v__token__Precedence[]) { v__token__Precedence__eq });
	array_set(&p, v__token__Kind__le, &(v__token__Precedence[]) { v__token__Precedence__eq });
	array_set(&p, v__token__Kind__gt, &(v__token__Precedence[]) { v__token__Precedence__eq });
	array_set(&p, v__token__Kind__ge, &(v__token__Precedence[]) { v__token__Precedence__eq });
	array_set(&p, v__token__Kind__assign, &(v__token__Precedence[]) { v__token__Precedence__assign });
	array_set(&p, v__token__Kind__plus_assign, &(v__token__Precedence[]) { v__token__Precedence__assign });
	array_set(&p, v__token__Kind__minus_assign, &(v__token__Precedence[]) { v__token__Precedence__assign });
	array_set(&p, v__token__Kind__div_assign, &(v__token__Precedence[]) { v__token__Precedence__assign });
	array_set(&p, v__token__Kind__mod_assign, &(v__token__Precedence[]) { v__token__Precedence__assign });
	array_set(&p, v__token__Kind__or_assign, &(v__token__Precedence[]) { v__token__Precedence__assign });
	array_set(&p, v__token__Kind__and_assign, &(v__token__Precedence[]) { v__token__Precedence__assign });
	array_set(&p, v__token__Kind__left_shift_assign, &(v__token__Precedence[]) { v__token__Precedence__assign });
	array_set(&p, v__token__Kind__right_shift_assign, &(v__token__Precedence[]) { v__token__Precedence__assign });
	array_set(&p, v__token__Kind__unsigned_right_shift_assign, &(v__token__Precedence[]) { v__token__Precedence__assign });
	array_set(&p, v__token__Kind__mult_assign, &(v__token__Precedence[]) { v__token__Precedence__assign });
	array_set(&p, v__token__Kind__xor_assign, &(v__token__Precedence[]) { v__token__Precedence__assign });
	array_set(&p, v__token__Kind__key_in, &(v__token__Precedence[]) { v__token__Precedence__in_as });
	array_set(&p, v__token__Kind__not_in, &(v__token__Precedence[]) { v__token__Precedence__in_as });
	array_set(&p, v__token__Kind__key_as, &(v__token__Precedence[]) { v__token__Precedence__in_as });
	array_set(&p, v__token__Kind__key_is, &(v__token__Precedence[]) { v__token__Precedence__in_as });
	array_set(&p, v__token__Kind__not_is, &(v__token__Precedence[]) { v__token__Precedence__in_as });
	array_set(&p, v__token__Kind__logical_or, &(v__token__Precedence[]) { v__token__Precedence__cond });
	array_set(&p, v__token__Kind__and, &(v__token__Precedence[]) { v__token__Precedence__cond });
	Array_v__token__Precedence _t1 = p;
	return _t1;
}

// Attr: [inline]
inline int v__token__Token_precedence(v__token__Token tok) {
	int _t1 = ((int)((*(v__token__Precedence*)/*ee elem_typ */array_get(_const_v__token__precedences, tok.kind))));
	return _t1;
}

// Attr: [inline]
inline bool v__token__Token_is_scalar(v__token__Token tok) {
	bool _t1 = (tok.kind == v__token__Kind__number || tok.kind == v__token__Kind__string);
	return _t1;
}

// Attr: [inline]
inline bool v__token__Token_is_unary(v__token__Token tok) {
	bool _t1 = (tok.kind == v__token__Kind__plus || tok.kind == v__token__Kind__minus || tok.kind == v__token__Kind__not || tok.kind == v__token__Kind__bit_not || tok.kind == v__token__Kind__mul || tok.kind == v__token__Kind__amp || tok.kind == v__token__Kind__arrow);
	return _t1;
}

// Attr: [inline]
inline bool v__token__Kind_is_relational(v__token__Kind tok) {
	bool _t1 = (tok == v__token__Kind__lt || tok == v__token__Kind__le || tok == v__token__Kind__gt || tok == v__token__Kind__ge || tok == v__token__Kind__eq || tok == v__token__Kind__ne);
	return _t1;
}

// Attr: [inline]
inline bool v__token__Kind_is_start_of_type(v__token__Kind k) {
	bool _t1 = (k == v__token__Kind__name || k == v__token__Kind__lpar || k == v__token__Kind__amp || k == v__token__Kind__lsbr || k == v__token__Kind__question || k == v__token__Kind__key_shared);
	return _t1;
}

// Attr: [inline]
inline bool v__token__Kind_is_prefix(v__token__Kind kind) {
	bool _t1 = (kind == v__token__Kind__minus || kind == v__token__Kind__amp || kind == v__token__Kind__mul || kind == v__token__Kind__not || kind == v__token__Kind__bit_not);
	return _t1;
}

// Attr: [inline]
inline bool v__token__Kind_is_infix(v__token__Kind kind) {
	bool _t1 = (kind == v__token__Kind__plus || kind == v__token__Kind__minus || kind == v__token__Kind__mod || kind == v__token__Kind__mul || kind == v__token__Kind__div || kind == v__token__Kind__eq || kind == v__token__Kind__ne || kind == v__token__Kind__gt || kind == v__token__Kind__lt || kind == v__token__Kind__key_in || kind == v__token__Kind__key_as || kind == v__token__Kind__ge || kind == v__token__Kind__le || kind == v__token__Kind__logical_or || kind == v__token__Kind__xor || kind == v__token__Kind__not_in || kind == v__token__Kind__key_is || kind == v__token__Kind__not_is || kind == v__token__Kind__and || kind == v__token__Kind__dot || kind == v__token__Kind__pipe || kind == v__token__Kind__amp || kind == v__token__Kind__left_shift || kind == v__token__Kind__right_shift || kind == v__token__Kind__unsigned_right_shift || kind == v__token__Kind__arrow);
	return _t1;
}

i64 time__portable_timegm(struct tm* t) {
	int year = t->tm_year + 1900;
	int month = t->tm_mon;
	if (month > 11) {
		year += month / 12;
		month %= 12;
	} else if (month < 0) {
		int years_diff = (11 - month) / 12;
		year -= years_diff;
		month += 12 * years_diff;
	}
	i64 days_since_1970 = ((i64)(time__days_from_civil(year, month + 1, t->tm_mday)));
	i64 _t1 = 60 * (60 * (24 * days_since_1970 + t->tm_hour) + t->tm_min) + t->tm_sec;
	return _t1;
}

int time__days_from_civil(int oy, int m, int d) {
	int y = (m <= 2 ? (oy - 1) : (oy));
	int era = y / 400;
	int yoe = y - era * 400;
	int doy = (153 * (m + ((m > 2 ? (-3) : (9)))) + 2) / 5 + d - 1;
	int doe = yoe * 365 + yoe / 4 - yoe / 100 + doy;
	int _t1 = era * 146097 + doe - 719468;
	return _t1;
}

string time__Time_format(time__Time t) {
	string _t1 = time__Time_get_fmt_str(t, time__FormatDelimiter__hyphen, time__FormatTime__hhmm24, time__FormatDate__yyyymmdd);
	return _t1;
}

string time__Time_format_ss(time__Time t) {
	string _t1 = time__Time_get_fmt_str(t, time__FormatDelimiter__hyphen, time__FormatTime__hhmmss24, time__FormatDate__yyyymmdd);
	return _t1;
}

string time__Time_format_ss_milli(time__Time t) {
	string _t1 = time__Time_get_fmt_str(t, time__FormatDelimiter__hyphen, time__FormatTime__hhmmss24_milli, time__FormatDate__yyyymmdd);
	return _t1;
}

string time__Time_format_ss_micro(time__Time t) {
	string _t1 = time__Time_get_fmt_str(t, time__FormatDelimiter__hyphen, time__FormatTime__hhmmss24_micro, time__FormatDate__yyyymmdd);
	return _t1;
}

string time__Time_hhmm(time__Time t) {
	string _t1 = time__Time_get_fmt_time_str(t, time__FormatTime__hhmm24);
	return _t1;
}

string time__Time_hhmmss(time__Time t) {
	string _t1 = time__Time_get_fmt_time_str(t, time__FormatTime__hhmmss24);
	return _t1;
}

string time__Time_hhmm12(time__Time t) {
	string _t1 = time__Time_get_fmt_time_str(t, time__FormatTime__hhmm12);
	return _t1;
}

string time__Time_ymmdd(time__Time t) {
	string _t1 = time__Time_get_fmt_date_str(t, time__FormatDelimiter__hyphen, time__FormatDate__yyyymmdd);
	return _t1;
}

string time__Time_ddmmy(time__Time t) {
	string _t1 = time__Time_get_fmt_date_str(t, time__FormatDelimiter__dot, time__FormatDate__ddmmyyyy);
	return _t1;
}

string time__Time_md(time__Time t) {
	string _t1 = time__Time_get_fmt_date_str(t, time__FormatDelimiter__space, time__FormatDate__mmmd);
	return _t1;
}

string time__Time_clean(time__Time t) {
	time__Time znow = time__now();
	if (t.month == znow.month && t.year == znow.year && t.day == znow.day) {
		string _t1 = time__Time_get_fmt_time_str(t, time__FormatTime__hhmm24);
		return _t1;
	}
	if (t.year == znow.year) {
		string _t2 = time__Time_get_fmt_str(t, time__FormatDelimiter__space, time__FormatTime__hhmm24, time__FormatDate__mmmd);
		return _t2;
	}
	string _t3 = time__Time_format(t);
	return _t3;
}

string time__Time_clean12(time__Time t) {
	time__Time znow = time__now();
	if (t.month == znow.month && t.year == znow.year && t.day == znow.day) {
		string _t1 = time__Time_get_fmt_time_str(t, time__FormatTime__hhmm12);
		return _t1;
	}
	if (t.year == znow.year) {
		string _t2 = time__Time_get_fmt_str(t, time__FormatDelimiter__space, time__FormatTime__hhmm12, time__FormatDate__mmmd);
		return _t2;
	}
	string _t3 = time__Time_format(t);
	return _t3;
}

string time__Time_get_fmt_time_str(time__Time t, time__FormatTime fmt_time) {
	if (fmt_time == time__FormatTime__no_time) {
		string _t1 = _SLIT("");
		return _t1;
	}
	string tp = (t.hour > 11 ? (_SLIT("p.m.")) : (_SLIT("a.m.")));
	int hour_ = (t.hour > 12 ? (t.hour - 12) : t.hour == 0 ? (12) : (t.hour));
	string _t3 = (string){.str=(byteptr)"", .is_lit=1};
	switch (fmt_time) {
		case time__FormatTime__hhmm12: 
			{
				_t3 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = hour_}}, {_SLIT(":"), 0x8004fe27, {.d_i32 = t.minute}}, {_SLIT(" "), 0xfe10, {.d_s = tp}}, {_SLIT0, 0, { .d_c = 0 }}}));
			} break;
		case time__FormatTime__hhmm24: 
			{
				_t3 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0x8004fe27, {.d_i32 = t.hour}}, {_SLIT(":"), 0x8004fe27, {.d_i32 = t.minute}}, {_SLIT0, 0, { .d_c = 0 }}}));
			} break;
		case time__FormatTime__hhmmss12: 
			{
				_t3 =  str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = hour_}}, {_SLIT(":"), 0x8004fe27, {.d_i32 = t.minute}}, {_SLIT(":"), 0x8004fe27, {.d_i32 = t.second}}, {_SLIT(" "), 0xfe10, {.d_s = tp}}, {_SLIT0, 0, { .d_c = 0 }}}));
			} break;
		case time__FormatTime__hhmmss24: 
			{
				_t3 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0x8004fe27, {.d_i32 = t.hour}}, {_SLIT(":"), 0x8004fe27, {.d_i32 = t.minute}}, {_SLIT(":"), 0x8004fe27, {.d_i32 = t.second}}, {_SLIT0, 0, { .d_c = 0 }}}));
			} break;
		case time__FormatTime__hhmmss24_milli: 
			{
				_t3 =  str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0x8004fe27, {.d_i32 = t.hour}}, {_SLIT(":"), 0x8004fe27, {.d_i32 = t.minute}}, {_SLIT(":"), 0x8004fe27, {.d_i32 = t.second}}, {_SLIT("."), 0x8006fe27, {.d_i32 = (t.microsecond / 1000)}}, {_SLIT0, 0, { .d_c = 0 }}}));
			} break;
		case time__FormatTime__hhmmss24_micro: 
			{
				_t3 =  str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0x8004fe27, {.d_i32 = t.hour}}, {_SLIT(":"), 0x8004fe27, {.d_i32 = t.minute}}, {_SLIT(":"), 0x8004fe27, {.d_i32 = t.second}}, {_SLIT("."), 0x800cfe27, {.d_i32 = t.microsecond}}, {_SLIT0, 0, { .d_c = 0 }}}));
			} break;
		case time__FormatTime__no_time:
		default:
			{
				_t3 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unknown enumeration "), 0xfe10, {.d_s = time__FormatTime_str(fmt_time)}}, {_SLIT0, 0, { .d_c = 0 }}}));
			} break;
	}
	string _t2 = _t3;
	return _t2;
}

string time__Time_get_fmt_date_str(time__Time t, time__FormatDelimiter fmt_dlmtr, time__FormatDate fmt_date) {
	if (fmt_date == time__FormatDate__no_date) {
		string _t1 = _SLIT("");
		return _t1;
	}
	string month = time__Time_smonth(t);
	string year =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0x8004fe27, {.d_i32 = (t.year % 100)}}, {_SLIT0, 0, { .d_c = 0 }}}));
	string _t2 = (string){.str=(byteptr)"", .is_lit=1};
	switch (fmt_date) {
		case time__FormatDate__ddmmyy: 
			{
				_t2 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0x8004fe27, {.d_i32 = t.day}}, {_SLIT("|"), 0x8004fe27, {.d_i32 = t.month}}, {_SLIT("|"), 0xfe10, {.d_s = year}}, {_SLIT0, 0, { .d_c = 0 }}}));
			} break;
		case time__FormatDate__ddmmyyyy: 
			{
				_t2 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0x8004fe27, {.d_i32 = t.day}}, {_SLIT("|"), 0x8004fe27, {.d_i32 = t.month}}, {_SLIT("|"), 0x8008fe27, {.d_i32 = t.year}}, {_SLIT0, 0, { .d_c = 0 }}}));
			} break;
		case time__FormatDate__mmddyy: 
			{
				_t2 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0x8004fe27, {.d_i32 = t.month}}, {_SLIT("|"), 0x8004fe27, {.d_i32 = t.day}}, {_SLIT("|"), 0xfe10, {.d_s = year}}, {_SLIT0, 0, { .d_c = 0 }}}));
			} break;
		case time__FormatDate__mmddyyyy: 
			{
				_t2 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0x8004fe27, {.d_i32 = t.month}}, {_SLIT("|"), 0x8004fe27, {.d_i32 = t.day}}, {_SLIT("|"), 0x8008fe27, {.d_i32 = t.year}}, {_SLIT0, 0, { .d_c = 0 }}}));
			} break;
		case time__FormatDate__mmmd: 
			{
				_t2 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = month}}, {_SLIT("|"), 0xfe07, {.d_i32 = t.day}}, {_SLIT0, 0, { .d_c = 0 }}}));
			} break;
		case time__FormatDate__mmmdd: 
			{
				_t2 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = month}}, {_SLIT("|"), 0x8004fe27, {.d_i32 = t.day}}, {_SLIT0, 0, { .d_c = 0 }}}));
			} break;
		case time__FormatDate__mmmddyy: 
			{
				_t2 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = month}}, {_SLIT("|"), 0x8004fe27, {.d_i32 = t.day}}, {_SLIT("|"), 0xfe10, {.d_s = year}}, {_SLIT0, 0, { .d_c = 0 }}}));
			} break;
		case time__FormatDate__mmmddyyyy: 
			{
				_t2 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = month}}, {_SLIT("|"), 0x8004fe27, {.d_i32 = t.day}}, {_SLIT("|"), 0x8008fe27, {.d_i32 = t.year}}, {_SLIT0, 0, { .d_c = 0 }}}));
			} break;
		case time__FormatDate__yyyymmdd: 
			{
				_t2 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0x8008fe27, {.d_i32 = t.year}}, {_SLIT("|"), 0x8004fe27, {.d_i32 = t.month}}, {_SLIT("|"), 0x8004fe27, {.d_i32 = t.day}}, {_SLIT0, 0, { .d_c = 0 }}}));
			} break;
		case time__FormatDate__yymmdd: 
			{
				_t2 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = year}}, {_SLIT("|"), 0x8004fe27, {.d_i32 = t.month}}, {_SLIT("|"), 0x8004fe27, {.d_i32 = t.day}}, {_SLIT0, 0, { .d_c = 0 }}}));
			} break;
		case time__FormatDate__no_date:
		default:
			{
				_t2 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unknown enumeration "), 0xfe10, {.d_s = time__FormatDate_str(fmt_date)}}, {_SLIT0, 0, { .d_c = 0 }}}));
			} break;
	}
	string res = _t2;
	string del = ((fmt_dlmtr == (time__FormatDelimiter__dot)) ? (_SLIT(".")) : (fmt_dlmtr == (time__FormatDelimiter__hyphen)) ? (_SLIT("-")) : (fmt_dlmtr == (time__FormatDelimiter__slash)) ? (_SLIT("/")) : (fmt_dlmtr == (time__FormatDelimiter__space)) ? (_SLIT(" ")) : (_SLIT("")));
	res = string_replace(res, _SLIT("|"), del);
	string _t3 = res;
	return _t3;
}

string time__Time_get_fmt_str(time__Time t, time__FormatDelimiter fmt_dlmtr, time__FormatTime fmt_time, time__FormatDate fmt_date) {
	if (fmt_date == time__FormatDate__no_date) {
		if (fmt_time == time__FormatTime__no_time) {
			string _t1 = _SLIT("");
			return _t1;
		} else {
			string _t2 = time__Time_get_fmt_time_str(t, fmt_time);
			return _t2;
		}
	} else {
		if (fmt_time != time__FormatTime__no_time) {
			string dstr = time__Time_get_fmt_date_str(t, fmt_dlmtr, fmt_date);
			string tstr = time__Time_get_fmt_time_str(t, fmt_time);
			string _t3 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = dstr}}, {_SLIT(" "), 0xfe10, {.d_s = tstr}}, {_SLIT0, 0, { .d_c = 0 }}}));
			return _t3;
		} else {
			string _t4 = time__Time_get_fmt_date_str(t, fmt_dlmtr, fmt_date);
			return _t4;
		}
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

string time__Time_utc_string(time__Time t) {
	string day_str = time__Time_weekday_str(t);
	string month_str = time__Time_smonth(t);
	string utc_string =  str_intp(8, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = day_str}}, {_SLIT(", "), 0xfe07, {.d_i32 = t.day}}, {_SLIT(" "), 0xfe10, {.d_s = month_str}}, {_SLIT(" "), 0xfe07, {.d_i32 = t.year}}, {_SLIT(" "), 0x8004fe27, {.d_i32 = t.hour}}, {_SLIT(":"), 0x8004fe27, {.d_i32 = t.minute}}, {_SLIT(":"), 0x8004fe27, {.d_i32 = t.second}}, {_SLIT(" UTC"), 0, { .d_c = 0 }}}));
	string _t1 = utc_string;
	return _t1;
}

// Attr: [inline]
inline bool time__Time__eq(time__Time t1, time__Time t2) {
	bool _t1 = t1._v_unix == t2._v_unix && t1.microsecond == t2.microsecond;
	return _t1;
}

// Attr: [inline]
inline bool time__Time__lt(time__Time t1, time__Time t2) {
	bool _t1 = t1._v_unix < t2._v_unix || (t1._v_unix == t2._v_unix && t1.microsecond < t2.microsecond);
	return _t1;
}

// Attr: [inline]
inline time__Duration time__Time__minus(time__Time lhs, time__Time rhs) {
	i64 lhs_micro = lhs._v_unix * 1000000 + lhs.microsecond;
	i64 rhs_micro = rhs._v_unix * 1000000 + rhs.microsecond;
	time__Duration _t1 = (lhs_micro - rhs_micro) * _const_time__microsecond;
	return _t1;
}

Option_time__Time time__parse_rfc3339(string s) {
	if ((s).len == 0) {
		return (Option_time__Time){ .state=2, .err=time__error_invalid_time(0), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	string sn = string_replace_each(s, new_array_from_c_array(4, 4, sizeof(string), _MOV((string[4]){_SLIT("t"), _SLIT("T"), _SLIT("z"), _SLIT("Z")})));
	Option_time__Time _t2 = time__parse_iso8601(sn);
	if (_t2.state != 0) { /*or block*/ 
		IError err = _t2.err;
		*(time__Time*) _t2.data = (time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.microsecond = 0,._v_unix = 0,};
	}
	
 	time__Time t =  (*(time__Time*)_t2.data);
	if (!time__Time__eq(t, (time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.microsecond = 0,._v_unix = 0,})) {
		Option_time__Time _t3;
		opt_ok(&(time__Time[]) { t }, (Option*)(&_t3), sizeof(time__Time));
		return _t3;
	}
	Option_int _t4 = string_index(sn, _SLIT("T"));
	if (_t4.state != 0) { /*or block*/ 
		IError err = _t4.err;
		*(int*) _t4.data = -1;
	}
	
 	int t_i =  (*(int*)_t4.data);
	Array_string parts = (t_i != -1 ? (new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){string_clone(string_substr(sn, 0, t_i)), string_clone(string_substr(sn, t_i + 1, sn.len))}))) : (string_split(sn, _SLIT(" "))));
	if (!string_contains_any((*(string*)/*ee elem_typ */array_get(parts, 0)), _SLIT(" Z")) && string_contains((*(string*)/*ee elem_typ */array_get(parts, 0)), _SLIT("-"))) {
		Option_multi_return_int_int_int _t5 = time__parse_iso8601_date(sn);
		if (_t5.state != 0) { /*or block*/ 
			Option_time__Time _t6;
			memcpy(&_t6, &_t5, sizeof(Option));
			return _t6;
		}
		
 		Option_multi_return_int_int_int mr_1001 =  _t5 /*U*/;
		int year = (*(multi_return_int_int_int*)mr_1001.data).arg0;
		int month = (*(multi_return_int_int_int*)mr_1001.data).arg1;
		int day = (*(multi_return_int_int_int*)mr_1001.data).arg2;
		t = time__new_time((time__Time){.year = year,.month = month,.day = day,.hour = 0,.minute = 0,.second = 0,.microsecond = 0,._v_unix = 0,});
		Option_time__Time _t7;
		opt_ok(&(time__Time[]) { t }, (Option*)(&_t7), sizeof(time__Time));
		return _t7;
	}
	if (!string_contains((*(string*)/*ee elem_typ */array_get(parts, 0)), _SLIT("-")) && string_contains((*(string*)/*ee elem_typ */array_get(parts, 0)), _SLIT(":"))) {
		int hour_ = 0;
		int minute_ = 0;
		int second_ = 0;
		int microsecond_ = 0;
		i64 unix_offset = ((i64)(0));
		bool is_local_time = true;
		Option_multi_return_int_int_int_int_i64_bool _t8 = time__parse_iso8601_time((*(string*)/*ee elem_typ */array_get(parts, 0)));
		if (_t8.state != 0) { /*or block*/ 
			Option_time__Time _t9;
			memcpy(&_t9, &_t8, sizeof(Option));
			return _t9;
		}
		
 		Option_multi_return_int_int_int_int_i64_bool mr_1384 =  _t8 /*U*/;
		hour_ = (*(multi_return_int_int_int_int_i64_bool*)mr_1384.data).arg0;
		minute_ = (*(multi_return_int_int_int_int_i64_bool*)mr_1384.data).arg1;
		second_ = (*(multi_return_int_int_int_int_i64_bool*)mr_1384.data).arg2;
		microsecond_ = (*(multi_return_int_int_int_int_i64_bool*)mr_1384.data).arg3;
		unix_offset = (*(multi_return_int_int_int_int_i64_bool*)mr_1384.data).arg4;
		is_local_time = (*(multi_return_int_int_int_int_i64_bool*)mr_1384.data).arg5;
		t = time__new_time((time__Time){.year = 0,.month = 0,.day = 0,.hour = hour_,.minute = minute_,.second = second_,.microsecond = microsecond_,._v_unix = 0,});
		if (is_local_time) {
			Option_time__Time _t10;
			opt_ok(&(time__Time[]) { t }, (Option*)(&_t10), sizeof(time__Time));
			return _t10;
		}
		i64 unix_time = t._v_unix;
		if (unix_offset < 0) {
			unix_time -= (-unix_offset);
		} else if (unix_offset > 0) {
			unix_time += unix_offset;
		}
		t = time__unix2(((i64)(unix_time)), t.microsecond);
		Option_time__Time _t11;
		opt_ok(&(time__Time[]) { t }, (Option*)(&_t11), sizeof(time__Time));
		return _t11;
	}
	return (Option_time__Time){ .state=2, .err=time__error_invalid_time(9), .data={EMPTY_STRUCT_INITIALIZATION} };
}

Option_time__Time time__parse(string s) {
	if ((s).len == 0) {
		return (Option_time__Time){ .state=2, .err=time__error_invalid_time(0), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Option_int _t2 = string_index(s, _SLIT(" "));
	if (_t2.state != 0) { /*or block*/ 
		IError err = _t2.err;
		return (Option_time__Time){ .state=2, .err=time__error_invalid_time(1), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	int pos =  (*(int*)_t2.data);
	string symd = string_substr(s, 0, pos);
	Array_string ymd = string_split(symd, _SLIT("-"));
	if (ymd.len != 3) {
		return (Option_time__Time){ .state=2, .err=time__error_invalid_time(2), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	string shms = string_substr(s, pos, s.len);
	Array_string hms = string_split(shms, _SLIT(":"));
	string hour_ = string_substr((*(string*)/*ee elem_typ */array_get(hms, 0)), 1, (*(string*)/*ee elem_typ */array_get(hms, 0)).len);
	string minute_ = (*(string*)/*ee elem_typ */array_get(hms, 1));
	string second_ = (*(string*)/*ee elem_typ */array_get(hms, 2));
	int iyear = string_int((*(string*)/*ee elem_typ */array_get(ymd, 0)));
	int imonth = string_int((*(string*)/*ee elem_typ */array_get(ymd, 1)));
	int iday = string_int((*(string*)/*ee elem_typ */array_get(ymd, 2)));
	int ihour = string_int(hour_);
	int iminute = string_int(minute_);
	int isecond = string_int(second_);
	if (iyear > 9999 || iyear < -9999) {
		return (Option_time__Time){ .state=2, .err=time__error_invalid_time(3), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (imonth > 12 || imonth < 1) {
		return (Option_time__Time){ .state=2, .err=time__error_invalid_time(4), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (iday > 31 || iday < 1) {
		return (Option_time__Time){ .state=2, .err=time__error_invalid_time(5), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (ihour > 23 || ihour < 0) {
		return (Option_time__Time){ .state=2, .err=time__error_invalid_time(6), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (iminute > 59 || iminute < 0) {
		return (Option_time__Time){ .state=2, .err=time__error_invalid_time(7), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (isecond > 59 || isecond < 0) {
		return (Option_time__Time){ .state=2, .err=time__error_invalid_time(8), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	time__Time res = time__new_time((time__Time){
		.year = iyear,
		.month = imonth,
		.day = iday,
		.hour = ihour,
		.minute = iminute,
		.second = isecond,
		.microsecond = 0,
		._v_unix = 0,
	});
	Option_time__Time _t11;
	opt_ok(&(time__Time[]) { res }, (Option*)(&_t11), sizeof(time__Time));
	return _t11;
}

Option_time__Time time__parse_iso8601(string s) {
	if ((s).len == 0) {
		return (Option_time__Time){ .state=2, .err=time__error_invalid_time(0), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Option_int _t2 = string_index(s, _SLIT("T"));
	if (_t2.state != 0) { /*or block*/ 
		IError err = _t2.err;
		*(int*) _t2.data = -1;
	}
	
 	int t_i =  (*(int*)_t2.data);
	Array_string parts = (t_i != -1 ? (new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){string_clone(string_substr(s, 0, t_i)), string_clone(string_substr(s, t_i + 1, s.len))}))) : (string_split(s, _SLIT(" "))));
	if (!(parts.len == 1 || parts.len == 2)) {
		return (Option_time__Time){ .state=2, .err=time__error_invalid_time(12), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Option_multi_return_int_int_int _t4 = time__parse_iso8601_date((*(string*)/*ee elem_typ */array_get(parts, 0)));
	if (_t4.state != 0) { /*or block*/ 
		Option_time__Time _t5;
		memcpy(&_t5, &_t4, sizeof(Option));
		return _t5;
	}
	
 	Option_multi_return_int_int_int mr_3646 =  _t4 /*U*/;
	int year = (*(multi_return_int_int_int*)mr_3646.data).arg0;
	int month = (*(multi_return_int_int_int*)mr_3646.data).arg1;
	int day = (*(multi_return_int_int_int*)mr_3646.data).arg2;
	int hour_ = 0;
	int minute_ = 0;
	int second_ = 0;
	int microsecond_ = 0;
	i64 unix_offset = ((i64)(0));
	bool is_local_time = true;
	if (parts.len == 2) {
		Option_multi_return_int_int_int_int_i64_bool _t6 = time__parse_iso8601_time((*(string*)/*ee elem_typ */array_get(parts, 1)));
		if (_t6.state != 0) { /*or block*/ 
			Option_time__Time _t7;
			memcpy(&_t7, &_t6, sizeof(Option));
			return _t7;
		}
		
 		Option_multi_return_int_int_int_int_i64_bool mr_3888 =  _t6 /*U*/;
		hour_ = (*(multi_return_int_int_int_int_i64_bool*)mr_3888.data).arg0;
		minute_ = (*(multi_return_int_int_int_int_i64_bool*)mr_3888.data).arg1;
		second_ = (*(multi_return_int_int_int_int_i64_bool*)mr_3888.data).arg2;
		microsecond_ = (*(multi_return_int_int_int_int_i64_bool*)mr_3888.data).arg3;
		unix_offset = (*(multi_return_int_int_int_int_i64_bool*)mr_3888.data).arg4;
		is_local_time = (*(multi_return_int_int_int_int_i64_bool*)mr_3888.data).arg5;
	}
	time__Time t = time__new_time((time__Time){
		.year = year,
		.month = month,
		.day = day,
		.hour = hour_,
		.minute = minute_,
		.second = second_,
		.microsecond = microsecond_,
		._v_unix = 0,
	});
	if (is_local_time) {
		Option_time__Time _t8;
		opt_ok(&(time__Time[]) { t }, (Option*)(&_t8), sizeof(time__Time));
		return _t8;
	}
	i64 unix_time = t._v_unix;
	if (unix_offset < 0) {
		unix_time -= (-unix_offset);
	} else if (unix_offset > 0) {
		unix_time += unix_offset;
	}
	t = time__unix2(((i64)(unix_time)), t.microsecond);
	Option_time__Time _t9;
	opt_ok(&(time__Time[]) { t }, (Option*)(&_t9), sizeof(time__Time));
	return _t9;
}

Option_time__Time time__parse_rfc2822(string s) {
	if ((s).len == 0) {
		return (Option_time__Time){ .state=2, .err=time__error_invalid_time(0), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Array_string fields = string_split(s, _SLIT(" "));
	if (fields.len < 5) {
		return (Option_time__Time){ .state=2, .err=time__error_invalid_time(1), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Option_int _t3 = string_index(_const_time__months_string, (*(string*)/*ee elem_typ */array_get(fields, 2)));
	if (_t3.state != 0) { /*or block*/ 
		IError err = _t3.err;
		return (Option_time__Time){ .state=2, .err=time__error_invalid_time(2), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	int pos =  (*(int*)_t3.data);
	int mm = pos / 3 + 1;
	{ // Unsafe block
		byte* tmstr = malloc_noscan(s.len * 2);
		int count = snprintf(((char*)(tmstr)), (s.len * 2), "%s-%02d-%s %s", (*(string*)/*ee elem_typ */array_get(fields, 3)).str, mm, (*(string*)/*ee elem_typ */array_get(fields, 1)).str, (*(string*)/*ee elem_typ */array_get(fields, 4)).str);
		Option_time__Time _t5 = time__parse(tos(tmstr, count));
		return _t5;
	}
	return (Option_time__Time){0};
}

VV_LOCAL_SYMBOL Option_multi_return_int_int_int time__parse_iso8601_date(string s) {
	int year = 0;
	int month = 0;
	int day = 0;
	byte dummy = ((byte)(0));
	int count = sscanf(((char*)(s.str)), "%4d-%2d-%2d%c", &year, &month, &day, &dummy);
	if (count != 3) {
		return (Option_multi_return_int_int_int){ .state=2, .err=time__error_invalid_time(10), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (year > 9999) {
		return (Option_multi_return_int_int_int){ .state=2, .err=time__error_invalid_time(13), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (month > 12) {
		return (Option_multi_return_int_int_int){ .state=2, .err=time__error_invalid_time(14), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (day > 31) {
		return (Option_multi_return_int_int_int){ .state=2, .err=time__error_invalid_time(15), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Option_multi_return_int_int_int _t5;
	opt_ok(&(multi_return_int_int_int/*X*/[]) { (multi_return_int_int_int){.arg0=year, .arg1=month, .arg2=day} }, (Option*)(&_t5), sizeof(multi_return_int_int_int));
	return _t5;
}

VV_LOCAL_SYMBOL Option_multi_return_int_int_int_int_i64_bool time__parse_iso8601_time(string s) {
	int hour_ = 0;
	int minute_ = 0;
	int second_ = 0;
	int microsecond_ = 0;
	rune plus_min_z = 'a';
	int offset_hour = 0;
	int offset_minute = 0;
	int count = sscanf(((char*)(s.str)), "%2d:%2d:%2d.%6d%c%2d:%2d", &hour_, &minute_, &second_, &microsecond_, ((char*)(&plus_min_z)), &offset_hour, &offset_minute);
	if (count < 4) {
		count = sscanf(((char*)(s.str)), "%2d:%2d:%2d%c%2d:%2d", &hour_, &minute_, &second_, ((char*)(&plus_min_z)), &offset_hour, &offset_minute);
		count++;
	}
	if (count < 4) {
		return (Option_multi_return_int_int_int_int_i64_bool){ .state=2, .err=time__error_invalid_time(10), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	bool is_local_time = plus_min_z == 'a' && count == 4;
	bool is_utc = plus_min_z == 'Z' && count == 5;
	if (!(count == 7 || is_local_time || is_utc)) {
		return (Option_multi_return_int_int_int_int_i64_bool){ .state=2, .err=time__error_invalid_time(11), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (plus_min_z != '+' && plus_min_z != '-' && !is_utc && !is_local_time) {
		return (Option_multi_return_int_int_int_int_i64_bool){ .state=2, .err=time__error_invalid_time(12), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	int unix_offset = 0;
	if (offset_hour > 0) {
		unix_offset += 3600 * offset_hour;
	}
	if (offset_minute > 0) {
		unix_offset += 60 * offset_minute;
	}
	if (plus_min_z == '+') {
		unix_offset *= -1;
	}
	Option_multi_return_int_int_int_int_i64_bool _t4;
	opt_ok(&(multi_return_int_int_int_int_i64_bool/*X*/[]) { (multi_return_int_int_int_int_i64_bool){.arg0=hour_, .arg1=minute_, .arg2=second_, .arg3=microsecond_, .arg4=unix_offset, .arg5=is_local_time} }, (Option*)(&_t4), sizeof(multi_return_int_int_int_int_i64_bool));
	return _t4;
}

VV_LOCAL_SYMBOL IError time__error_invalid_time(int code) {
	IError _t1 = I_time__TimeParseError_to_Interface_IError((time__TimeParseError*)memdup(&(time__TimeParseError){.msg =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("Invalid time format code: "), 0xfe07, {.d_i32 = code}}, {_SLIT0, 0, { .d_c = 0 }}})),.code = code,}, sizeof(time__TimeParseError)));
	return _t1;
}

time__StopWatch time__new_stopwatch(time__StopWatchOptions opts) {
	u64 initial = ((u64)(0U));
	if (opts.auto_start) {
		initial = time__sys_mono_now();
	}
	time__StopWatch _t1 = (time__StopWatch){.elapsed = 0U,.start = initial,.end = 0U,};
	return _t1;
}

void time__StopWatch_start(time__StopWatch* t) {
	t->start = time__sys_mono_now();
	t->end = 0U;
}

void time__StopWatch_restart(time__StopWatch* t) {
	t->start = time__sys_mono_now();
	t->end = 0U;
	t->elapsed = 0U;
}

void time__StopWatch_stop(time__StopWatch* t) {
	t->end = time__sys_mono_now();
}

void time__StopWatch_pause(time__StopWatch* t) {
	if (t->start > 0U) {
		if (t->end == 0U) {
			t->elapsed += time__sys_mono_now() - t->start;
		} else {
			t->elapsed += t->end - t->start;
		}
	}
	t->start = 0U;
}

time__Duration time__StopWatch_elapsed(time__StopWatch t) {
	if (t.start > 0U) {
		if (t.end == 0U) {
			time__Duration _t1 = ((((i64)(time__sys_mono_now() - t.start + t.elapsed))));
			return _t1;
		} else {
			time__Duration _t2 = ((((i64)(t.end - t.start + t.elapsed))));
			return _t2;
		}
	}
	time__Duration _t3 = ((((i64)(t.elapsed))));
	return _t3;
}

time__Time time__now(void) {
	time__Time _t1 = time__win_now();
	return _t1;
	time_t t = time(0);
	struct tm* now = localtime(&t);
	time__Time _t2 = time__convert_ctime(*now, 0);
	return _t2;
}

time__Time time__utc(void) {
	time__Time _t1 = time__win_utc();
	return _t1;
	time_t t = time(0);
	time(&t);
	time__Time _t2 = time__unix2(((i64)(t)), 0);
	return _t2;
}

time__Time time__new_time(time__Time t) {
	if (t._v_unix != 0) {
		time__Time _t1 = t;
		return _t1;
	}
	struct tm tt = (struct tm){
		.tm_year = t.year - 1900,
		.tm_mon = t.month - 1,
		.tm_mday = t.day,
		.tm_hour = t.hour,
		.tm_min = t.minute,
		.tm_sec = t.second,
	};
	i64 utime = time__make_unix_time(tt);
	time__Time _t2 = (time__Time){t.year,t.month,t.day,t.hour,t.minute,t.second,t.microsecond,._v_unix = utime,};
	return _t2;
}

i64 time__ticks(void) {
	#if defined(_WIN32)
	{
		i64 _t1 = GetTickCount();
		return _t1;
	}
	#else
	{
	}
	#endif
	return 0;
}

string time__Time_str(time__Time t) {
	string _t1 = time__Time_format_ss(t);
	return _t1;
}

VV_LOCAL_SYMBOL time__Time time__convert_ctime(struct tm t, int microsecond) {
	time__Time _t1 = (time__Time){
		.year = t.tm_year + 1900,
		.month = t.tm_mon + 1,
		.day = t.tm_mday,
		.hour = t.tm_hour,
		.minute = t.tm_min,
		.second = t.tm_sec,
		.microsecond = microsecond,
		._v_unix = time__make_unix_time(t),
	};
	return _t1;
}

string time__Time_smonth(time__Time t) {
	if (t.month <= 0 || t.month > 12) {
		string _t1 = _SLIT("---");
		return _t1;
	}
	int i = t.month - 1;
	string _t2 = string_substr(_const_time__months_string, i * 3, (i + 1) * 3);
	return _t2;
}

// Attr: [inline]
inline i64 time__Time_unix_time(time__Time t) {
	i64 _t1 = t._v_unix;
	return _t1;
}

// Attr: [inline]
inline i64 time__Time_unix_time_milli(time__Time t) {
	i64 _t1 = t._v_unix * 1000 + (t.microsecond / 1000);
	return _t1;
}

time__Time time__Time_add(time__Time t, time__Duration d) {
	i64 microseconds = ((i64)(t._v_unix)) * 1000000 + t.microsecond + time__Duration_microseconds(d);
	i64 _v_unix = microseconds / 1000000;
	i64 micro = microseconds % 1000000;
	time__Time _t1 = time__unix2(_v_unix, ((int)(micro)));
	return _t1;
}

time__Time time__Time_add_seconds(time__Time t, int seconds) {
	time__Time _t1 = time__Time_add(t, seconds * _const_time__second);
	return _t1;
}

time__Time time__Time_add_days(time__Time t, int days) {
	time__Time _t1 = time__Time_add(t, days * 24 * _const_time__hour);
	return _t1;
}

time__Duration time__since(time__Time t) {
	time__Duration _t1 = time__Time__minus(time__now(), t);
	return _t1;
}

string time__Time_relative(time__Time t) {
	time__Time znow = time__now();
	i64 secs = znow._v_unix - t._v_unix;
	if (secs <= 30) {
		string _t1 = _SLIT("now");
		return _t1;
	}
	if (secs < 60) {
		string _t2 = _SLIT("1m");
		return _t2;
	}
	if (secs < 3600) {
		i64 m = secs / 60;
		if (m == 1) {
			string _t3 = _SLIT("1 minute ago");
			return _t3;
		}
		string _t4 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe09, {.d_i64 = m}}, {_SLIT(" minutes ago"), 0, { .d_c = 0 }}}));
		return _t4;
	}
	if (secs < 86400) {
		i64 h = secs / 3600;
		if (h == 1) {
			string _t5 = _SLIT("1 hour ago");
			return _t5;
		}
		string _t6 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe09, {.d_i64 = h}}, {_SLIT(" hours ago"), 0, { .d_c = 0 }}}));
		return _t6;
	}
	if (secs < 432000) {
		i64 d = secs / 3600 / 24;
		if (d == 1) {
			string _t7 = _SLIT("1 day ago");
			return _t7;
		}
		string _t8 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe09, {.d_i64 = d}}, {_SLIT(" days ago"), 0, { .d_c = 0 }}}));
		return _t8;
	}
	if (secs > 864000000) {
		string _t9 = _SLIT("");
		return _t9;
	}
	string _t10 = time__Time_md(t);
	return _t10;
}

string time__Time_relative_short(time__Time t) {
	time__Time znow = time__now();
	i64 secs = znow._v_unix - t._v_unix;
	if (secs <= 30) {
		string _t1 = _SLIT("now");
		return _t1;
	}
	if (secs < 60) {
		string _t2 = _SLIT("1m");
		return _t2;
	}
	if (secs < 3600) {
		string _t3 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe09, {.d_i64 = secs / 60}}, {_SLIT("m"), 0, { .d_c = 0 }}}));
		return _t3;
	}
	if (secs < 86400) {
		string _t4 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe09, {.d_i64 = secs / 3600}}, {_SLIT("h"), 0, { .d_c = 0 }}}));
		return _t4;
	}
	if (secs < 432000) {
		string _t5 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe09, {.d_i64 = secs / 3600 / 24}}, {_SLIT("d"), 0, { .d_c = 0 }}}));
		return _t5;
	}
	if (secs > 864000000) {
		string _t6 = _SLIT("");
		return _t6;
	}
	string _t7 = time__Time_md(t);
	return _t7;
}

int time__day_of_week(int y, int m, int d) {
	Array_int t = new_array_from_c_array(12, 12, sizeof(int), _MOV((int[12]){
			0, 3, 2, 5, 0, 3, 5, 1, 4,
			6, 2, 4}));
	int sy = y;
	if (m < 3) {
		sy = sy - 1;
	}
	int _t1 = (sy + sy / 4 - sy / 100 + sy / 400 + (*(int*)/*ee elem_typ */array_get(t, m - 1)) + d - 1) % 7 + 1;
	return _t1;
}

int time__Time_day_of_week(time__Time t) {
	int _t1 = time__day_of_week(t.year, t.month, t.day);
	return _t1;
}

string time__Time_weekday_str(time__Time t) {
	int i = time__Time_day_of_week(t) - 1;
	string _t1 = string_substr(_const_time__days_string, i * 3, (i + 1) * 3);
	return _t1;
}

string time__Time_long_weekday_str(time__Time t) {
	int i = time__Time_day_of_week(t) - 1;
	string _t1 = (*(string*)/*ee elem_typ */array_get(_const_time__long_days, i));
	return _t1;
}

bool time__is_leap_year(int year) {
	bool _t1 = (year % 4 == 0) && (year % 100 != 0 || year % 400 == 0);
	return _t1;
}

Option_int time__days_in_month(int month, int year) {
	if (month > 12 || month < 1) {
		return (Option_int){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Invalid month: "), 0xfe07, {.d_i32 = month}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	int extra = (month == 2 && time__is_leap_year(year) ? (1) : (0));
	int res = (*(int*)/*ee elem_typ */array_get(_const_time__month_days, month - 1)) + extra;
	Option_int _t2;
	opt_ok(&(int[]) { res }, (Option*)(&_t2), sizeof(int));
	return _t2;
}

string time__Time_debug(time__Time t) {
	string _t1 =  str_intp(9, _MOV((StrIntpData[]){{_SLIT("Time{ year: "), 0x8008fe27, {.d_i32 = t.year}}, {_SLIT(" month: "), 0x8004fe27, {.d_i32 = t.month}}, {_SLIT(" day: "), 0x8004fe27, {.d_i32 = t.day}}, {_SLIT(" hour: "), 0x8004fe27, {.d_i32 = t.hour}}, {_SLIT(" minute: "), 0x8004fe27, {.d_i32 = t.minute}}, {_SLIT(" second: "), 0x8004fe27, {.d_i32 = t.second}}, {_SLIT(" microsecond: "), 0x800cfe27, {.d_i32 = t.microsecond}}, {_SLIT(" unix: "), 0x800efe29, {.d_i64 = t._v_unix}}, {_SLIT(" }"), 0, { .d_c = 0 }}}));
	return _t1;
}

// TypeDecl
i64 time__Duration_nanoseconds(time__Duration d) {
	i64 _t1 = ((i64)(d));
	return _t1;
}

i64 time__Duration_microseconds(time__Duration d) {
	i64 _t1 = ((i64)(d)) / 1000;
	return _t1;
}

i64 time__Duration_milliseconds(time__Duration d) {
	i64 _t1 = ((i64)(d)) / 1000000;
	return _t1;
}

f64 time__Duration_seconds(time__Duration d) {
	i64 sec = d / _const_time__second;
	i64 nsec = d % _const_time__second;
	f64 _t1 = ((f64)(sec)) + ((f64)(nsec)) / 1e9;
	return _t1;
}

f64 time__Duration_minutes(time__Duration d) {
	i64 min = d / _const_time__minute;
	i64 nsec = d % _const_time__minute;
	f64 _t1 = ((f64)(min)) + ((f64)(nsec)) / (60 * 1e9);
	return _t1;
}

f64 time__Duration_hours(time__Duration d) {
	i64 hr = d / _const_time__hour;
	i64 nsec = d % _const_time__hour;
	f64 _t1 = ((f64)(hr)) + ((f64)(nsec)) / (60 * 60 * 1e9);
	return _t1;
}

string time__Duration_str(time__Duration d) {
	if (time__Duration_alias_eq(d, _const_time__infinite)) {
		string _t1 = _SLIT("inf");
		return _t1;
	}
	i64 t = ((i64)(d));
	i64 hr = t / _const_time__hour;
	t -= hr * _const_time__hour;
	i64 min = t / _const_time__minute;
	t -= min * _const_time__minute;
	i64 sec = t / _const_time__second;
	t -= sec * _const_time__second;
	i64 ms = t / _const_time__millisecond;
	t -= ms * _const_time__millisecond;
	i64 us = t / _const_time__microsecond;
	t -= us * _const_time__microsecond;
	i64 ns = t;
	if (hr > 0) {
		string _t2 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe09, {.d_i64 = hr}}, {_SLIT(":"), 0x8004fe29, {.d_i64 = min}}, {_SLIT(":"), 0x8004fe29, {.d_i64 = sec}}, {_SLIT0, 0, { .d_c = 0 }}}));
		return _t2;
	}
	if (min > 0) {
		string _t3 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe09, {.d_i64 = min}}, {_SLIT(":"), 0x8004fe29, {.d_i64 = sec}}, {_SLIT("."), 0x8006fe29, {.d_i64 = ms}}, {_SLIT0, 0, { .d_c = 0 }}}));
		return _t3;
	}
	if (sec > 0) {
		string _t4 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe09, {.d_i64 = sec}}, {_SLIT("."), 0x8006fe29, {.d_i64 = ms}}, {_SLIT("s"), 0, { .d_c = 0 }}}));
		return _t4;
	}
	if (ms > 0) {
		string _t5 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe09, {.d_i64 = ms}}, {_SLIT("."), 0x8006fe29, {.d_i64 = us}}, {_SLIT("ms"), 0, { .d_c = 0 }}}));
		return _t5;
	}
	if (us > 0) {
		string _t6 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe09, {.d_i64 = us}}, {_SLIT("."), 0x8006fe29, {.d_i64 = ns}}, {_SLIT("us"), 0, { .d_c = 0 }}}));
		return _t6;
	}
	string _t7 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe09, {.d_i64 = ns}}, {_SLIT("ns"), 0, { .d_c = 0 }}}));
	return _t7;
}

int time__offset(void) {
	time__Time t = time__now();
	time__Time local = time__Time_local(t);
	int _t1 = ((int)(local._v_unix - t._v_unix));
	return _t1;
}

VV_LOCAL_SYMBOL i64 time__make_unix_time(struct tm t) {
	i64 _t1 = time__portable_timegm(&t);
	return _t1;
}

VV_LOCAL_SYMBOL u64 time__init_win_time_freq(void) {
	u64 f = ((u64)(0U));
	QueryPerformanceFrequency(&f);
	u64 _t1 = f;
	return _t1;
}

VV_LOCAL_SYMBOL u64 time__init_win_time_start(void) {
	u64 s = ((u64)(0U));
	QueryPerformanceCounter(&s);
	u64 _t1 = s;
	return _t1;
}

u64 time__sys_mono_now(void) {
	u64 tm = ((u64)(0U));
	QueryPerformanceCounter(&tm);
	u64 _t1 = (tm - _const_time__start_time) * 1000000000U / _const_time__freq_time;
	return _t1;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL u64 time__vpc_now(void) {
	u64 tm = ((u64)(0U));
	QueryPerformanceCounter(&tm);
	u64 _t1 = tm;
	return _t1;
}

VV_LOCAL_SYMBOL i64 time__local_as_unix_time(void) {
	time_t t = time(0);
	struct tm* tm = localtime(&t);
	i64 _t1 = time__make_unix_time(*tm);
	return _t1;
}

time__Time time__Time_local(time__Time t) {
	time__SystemTime st_utc = (time__SystemTime){
		.year = ((u16)(t.year)),
		.month = ((u16)(t.month)),
		.day_of_week = 0,
		.day = ((u16)(t.day)),
		.hour = ((u16)(t.hour)),
		.minute = ((u16)(t.minute)),
		.second = ((u16)(t.second)),
		.millisecond = 0,
	};
	time__SystemTime st_local = (time__SystemTime){.year = 0,.month = 0,.day_of_week = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.millisecond = 0,};
	SystemTimeToTzSpecificLocalTime(((voidptr)(0)), &st_utc, &st_local);
	time__Time t_local = (time__Time){
		.year = st_local.year,
		.month = st_local.month,
		.day = st_local.day,
		.hour = st_local.hour,
		.minute = st_local.minute,
		.second = st_local.second,
		.microsecond = st_local.millisecond * 1000U,
		._v_unix = time__SystemTime_unix_time(st_local),
	};
	time__Time _t1 = t_local;
	return _t1;
}

VV_LOCAL_SYMBOL time__Time time__win_now(void) {
	struct _FILETIME ft_utc = (struct _FILETIME){.dwLowDateTime = 0,.dwHighDateTime = 0,};
	GetSystemTimeAsFileTime(&ft_utc);
	time__SystemTime st_utc = (time__SystemTime){.year = 0,.month = 0,.day_of_week = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.millisecond = 0,};
	FileTimeToSystemTime(&ft_utc, &st_utc);
	time__SystemTime st_local = (time__SystemTime){.year = 0,.month = 0,.day_of_week = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.millisecond = 0,};
	SystemTimeToTzSpecificLocalTime(((voidptr)(0)), &st_utc, &st_local);
	time__Time t = (time__Time){
		.year = st_local.year,
		.month = st_local.month,
		.day = st_local.day,
		.hour = st_local.hour,
		.minute = st_local.minute,
		.second = st_local.second,
		.microsecond = st_local.millisecond * 1000U,
		._v_unix = time__SystemTime_unix_time(st_local),
	};
	time__Time _t1 = t;
	return _t1;
}

VV_LOCAL_SYMBOL time__Time time__win_utc(void) {
	struct _FILETIME ft_utc = (struct _FILETIME){.dwLowDateTime = 0,.dwHighDateTime = 0,};
	GetSystemTimeAsFileTime(&ft_utc);
	time__SystemTime st_utc = (time__SystemTime){.year = 0,.month = 0,.day_of_week = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.millisecond = 0,};
	FileTimeToSystemTime(&ft_utc, &st_utc);
	time__Time t = (time__Time){
		.year = st_utc.year,
		.month = st_utc.month,
		.day = st_utc.day,
		.hour = st_utc.hour,
		.minute = st_utc.minute,
		.second = st_utc.second,
		.microsecond = st_utc.millisecond * 1000U,
		._v_unix = time__SystemTime_unix_time(st_utc),
	};
	time__Time _t1 = t;
	return _t1;
}

i64 time__SystemTime_unix_time(time__SystemTime st) {
	struct tm tt = (struct tm){
		.tm_year = st.year - 1900U,
		.tm_mon = st.month - 1U,
		.tm_mday = st.day,
		.tm_hour = st.hour,
		.tm_min = st.minute,
		.tm_sec = st.second,
	};
	i64 _t1 = time__make_unix_time(tt);
	return _t1;
}

time__Time time__darwin_now(void) {
	time__Time _t1 = (time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.microsecond = 0,._v_unix = 0,};
	return _t1;
}

time__Time time__linux_now(void) {
	time__Time _t1 = (time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.microsecond = 0,._v_unix = 0,};
	return _t1;
}

time__Time time__solaris_now(void) {
	time__Time _t1 = (time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.microsecond = 0,._v_unix = 0,};
	return _t1;
}

time__Time time__darwin_utc(void) {
	time__Time _t1 = (time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.microsecond = 0,._v_unix = 0,};
	return _t1;
}

time__Time time__linux_utc(void) {
	time__Time _t1 = (time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.microsecond = 0,._v_unix = 0,};
	return _t1;
}

time__Time time__solaris_utc(void) {
	time__Time _t1 = (time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.microsecond = 0,._v_unix = 0,};
	return _t1;
}

void time__sleep(time__Duration duration) {
	Sleep(((int)(duration / _const_time__millisecond)));
}

u32 time__Duration_sys_milliseconds(time__Duration d) {
	if (d >= ((u32)(-1)) * _const_time__millisecond) {
		u32 _t1 = ((u32)(-1));
		return _t1;
	} else if (d <= 0) {
		u32 _t2 = 0U;
		return _t2;
	} else {
		u32 _t3 = ((u32)(d / _const_time__millisecond));
		return _t3;
	}
	return 0;
}

time__Time time__unix(i64 abs) {
	i64 day_offset = abs / _const_time__seconds_per_day;
	if (abs % _const_time__seconds_per_day < 0) {
		day_offset--;
	}
	multi_return_int_int_int mr_472 = time__calculate_date_from_offset(day_offset);
	int year = mr_472.arg0;
	int month = mr_472.arg1;
	int day = mr_472.arg2;
	multi_return_int_int_int mr_528 = time__calculate_time_from_offset(abs % _const_time__seconds_per_day);
	int hr = mr_528.arg0;
	int min = mr_528.arg1;
	int sec = mr_528.arg2;
	time__Time _t1 = (time__Time){
		.year = year,
		.month = month,
		.day = day,
		.hour = hr,
		.minute = min,
		.second = sec,
		.microsecond = 0,
		._v_unix = abs,
	};
	return _t1;
}

time__Time time__unix2(i64 abs, int microsecond) {
	i64 day_offset = abs / _const_time__seconds_per_day;
	if (abs % _const_time__seconds_per_day < 0) {
		day_offset--;
	}
	multi_return_int_int_int mr_1020 = time__calculate_date_from_offset(day_offset);
	int year = mr_1020.arg0;
	int month = mr_1020.arg1;
	int day = mr_1020.arg2;
	multi_return_int_int_int mr_1076 = time__calculate_time_from_offset(abs % _const_time__seconds_per_day);
	int hr = mr_1076.arg0;
	int min = mr_1076.arg1;
	int sec = mr_1076.arg2;
	time__Time _t1 = (time__Time){
		.year = year,
		.month = month,
		.day = day,
		.hour = hr,
		.minute = min,
		.second = sec,
		.microsecond = microsecond,
		._v_unix = abs,
	};
	return _t1;
}

VV_LOCAL_SYMBOL multi_return_int_int_int time__calculate_date_from_offset(i64 day_offset_) {
	i64 day_offset = day_offset_;
	int year = 2001;
	day_offset -= 11323;
	year += ((int)(day_offset / _const_time__days_per_400_years)) * 400;
	day_offset %= _const_time__days_per_400_years;
	if (day_offset == _const_time__days_per_100_years * 4) {
		year += 300;
		day_offset -= _const_time__days_per_100_years * 3;
	} else {
		year += ((int)(day_offset / _const_time__days_per_100_years)) * 100;
		day_offset %= _const_time__days_per_100_years;
	}
	if (day_offset == _const_time__days_per_4_years * 25) {
		year += 96;
		day_offset -= _const_time__days_per_4_years * 24;
	} else {
		year += ((int)(day_offset / _const_time__days_per_4_years)) * 4;
		day_offset %= _const_time__days_per_4_years;
	}
	if (day_offset == 1460) {
		year += 3;
		day_offset -= 1095;
	} else {
		year += ((int)(day_offset / 365));
		day_offset %= 365;
	}
	if (day_offset < 0) {
		year--;
		if (time__is_leap_year(year)) {
			day_offset += 366;
		} else {
			day_offset += 365;
		}
	}
	if (time__is_leap_year(year)) {
		if (day_offset > 59) {
			day_offset--;
		} else if (day_offset == 59) {
			return (multi_return_int_int_int){.arg0=year, .arg1=2, .arg2=29};
		}
	}
	i64 estimated_month = day_offset / 31;
	for (;;) {
		if (!(day_offset >= (*(int*)/*ee elem_typ */array_get(_const_time__days_before, estimated_month + 1)))) break;
		estimated_month++;
	}
	for (;;) {
		if (!(day_offset < (*(int*)/*ee elem_typ */array_get(_const_time__days_before, estimated_month)))) break;
		if (estimated_month == 0) {
			break;
		}
		estimated_month--;
	}
	day_offset -= (*(int*)/*ee elem_typ */array_get(_const_time__days_before, estimated_month));
	return (multi_return_int_int_int){.arg0=year, .arg1=((int)(estimated_month + 1)), .arg2=((int)(day_offset + 1))};
}

VV_LOCAL_SYMBOL multi_return_int_int_int time__calculate_time_from_offset(i64 second_offset_) {
	i64 second_offset = second_offset_;
	if (second_offset < 0) {
		second_offset += _const_time__seconds_per_day;
	}
	i64 hour_ = second_offset / _const_time__seconds_per_hour;
	second_offset %= _const_time__seconds_per_hour;
	i64 min = second_offset / _const_time__seconds_per_minute;
	second_offset %= _const_time__seconds_per_minute;
	return (multi_return_int_int_int){.arg0=((int)(hour_)), .arg1=((int)(min)), .arg2=((int)(second_offset))};
}

void v__dotgraph__start_digraph(void) {
	println(_SLIT("digraph G {"));
	atexit((voidptr)	anon_fn_40181cb3d9c4559e__82);
}

v__dotgraph__DotGraph* v__dotgraph__new(string name, string label, string color) {
	v__dotgraph__DotGraph* res = (v__dotgraph__DotGraph*)memdup(&(v__dotgraph__DotGraph){.sb = strings__new_builder(1024),}, sizeof(v__dotgraph__DotGraph));
	v__dotgraph__DotGraph_writeln(res,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("  subgraph cluster_"), 0xfe10, {.d_s = name}}, {_SLIT(" {"), 0, { .d_c = 0 }}})));
	v__dotgraph__DotGraph_writeln(res, _SLIT("\tedge [fontname=\"Helvetica\",fontsize=\"10\",labelfontname=\"Helvetica\",labelfontsize=\"10\",style=\"solid\",color=\"black\"];"));
	v__dotgraph__DotGraph_writeln(res, _SLIT("\tnode [fontname=\"Helvetica\",fontsize=\"10\",style=\"filled\",fontcolor=\"black\",fillcolor=\"white\",color=\"black\",shape=\"box\"];"));
	v__dotgraph__DotGraph_writeln(res, _SLIT("\trankdir=\"LR\";"));
	v__dotgraph__DotGraph_writeln(res,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\tcolor=\""), 0xfe10, {.d_s = color}}, {_SLIT("\";"), 0, { .d_c = 0 }}})));
	v__dotgraph__DotGraph_writeln(res,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\tlabel=\""), 0xfe10, {.d_s = label}}, {_SLIT("\";"), 0, { .d_c = 0 }}})));
	v__dotgraph__DotGraph* _t1 = res;
	return _t1;
}

void v__dotgraph__DotGraph_writeln(v__dotgraph__DotGraph* d, string line) {
	strings__Builder_writeln(&d->sb, line);
}

void v__dotgraph__DotGraph_finish(v__dotgraph__DotGraph* d) {
	strings__Builder_writeln(&d->sb, _SLIT("  }"));
	println(strings__Builder_str(&d->sb));
}

void v__dotgraph__DotGraph_new_node(v__dotgraph__DotGraph* d, string nlabel, v__dotgraph__NewNodeConfig cfg) {
	string nname = cfg.name2node_fn(nlabel, cfg.ctx);
	if ((cfg.node_name).len != 0) {
		nname = cfg.node_name;
	}
	if (cfg.should_highlight) {
		v__dotgraph__DotGraph_writeln(d,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = nname}}, {_SLIT(" [label=\""), 0xfe10, {.d_s = nlabel}}, {_SLIT("\",color=\"blue\",height=0.2,width=0.4,fillcolor=\"#00FF00\",tooltip=\""), 0xfe10, {.d_s = cfg.tooltip}}, {_SLIT("\",shape=oval];"), 0, { .d_c = 0 }}})));
	} else {
		v__dotgraph__DotGraph_writeln(d,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = nname}}, {_SLIT(" [shape=\"box\",label=\""), 0xfe10, {.d_s = nlabel}}, {_SLIT("\"];"), 0, { .d_c = 0 }}})));
	}
}

void v__dotgraph__DotGraph_new_edge(v__dotgraph__DotGraph* d, string source, string target, v__dotgraph__NewEdgeConfig cfg) {
	string nsource = cfg.name2node_fn(source, cfg.ctx);
	string ntarget = cfg.name2node_fn(target, cfg.ctx);
	if (cfg.should_highlight) {
		v__dotgraph__DotGraph_writeln(d,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = nsource}}, {_SLIT(" -> "), 0xfe10, {.d_s = ntarget}}, {_SLIT(" [color=\"blue\"];"), 0, { .d_c = 0 }}})));
	} else {
		v__dotgraph__DotGraph_writeln(d,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = nsource}}, {_SLIT(" -> "), 0xfe10, {.d_s = ntarget}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
	}
}

// TypeDecl
string v__dotgraph__node_name(string name, voidptr context) {
	string _t1 = string_replace(name, _SLIT("."), _SLIT("_"));
	return _t1;
}

// Attr: [inline]
inline u64 hash__wyhash_c(byte* key, u64 len, u64 seed) {
	u64 _t1 = wyhash(key, len, seed, ((u64*)(_wyp)));
	return _t1;
}

// Attr: [inline]
inline u64 hash__wyhash64_c(u64 a, u64 b) {
	u64 _t1 = wyhash64(a, b);
	return _t1;
}

// Attr: [inline]
inline u64 hash__sum64_string(string key, u64 seed) {
	u64 _t1 = hash__wyhash_c(key.str, ((u64)(key.len)), seed);
	return _t1;
}

// Attr: [inline]
inline u64 hash__sum64(Array_byte key, u64 seed) {
	u64 _t1 = hash__wyhash_c(((byte*)(key.data)), ((u64)(key.len)), seed);
	return _t1;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL u64 hash__wyrotr(u64 v, u32 k) {
	u64 _t1 = ((v >> k) | (v << (64 - k)));
	return _t1;
}

// Attr: [inline]
inline u64 hash__wymum(u64 a, u64 b) {
	u32 mask32 = ((u32)(4294967295U));
	u64 x0 = (a & mask32);
	u64 x1 = a >> 32U;
	u64 y0 = (b & mask32);
	u64 y1 = b >> 32U;
	u64 w0 = x0 * y0;
	u64 t = x1 * y0 + (w0 >> 32U);
	u64 w1 = (t & mask32);
	u64 w2 = t >> 32U;
	w1 += x0 * y1;
	u64 hi = x1 * y1 + w2 + (w1 >> 32U);
	u64 lo = a * b;
	u64 _t1 = (hi ^ lo);
	return _t1;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL u64 hash__wyr3(byte* p, u64 k) {
	{ // Unsafe block
		u64 _t1 = (((((u64)(p[0])) << 16U) | (((u64)(p[k >> 1U])) << 8U)) | ((u64)(p[k - 1U])));
		return _t1;
	}
	return 0;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL u64 hash__wyr4(byte* p) {
	{ // Unsafe block
		u64 _t1 = (((((u32)(p[0])) | (((u32)(p[1])) << ((u32)(8U)))) | (((u32)(p[2])) << ((u32)(16U)))) | (((u32)(p[3])) << ((u32)(24U))));
		return _t1;
	}
	return 0;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL u64 hash__wyr8(byte* p) {
	{ // Unsafe block
		u64 _t1 = (((((((((u64)(p[0])) | (((u64)(p[1])) << 8U)) | (((u64)(p[2])) << 16U)) | (((u64)(p[3])) << 24U)) | (((u64)(p[4])) << 32U)) | (((u64)(p[5])) << 40U)) | (((u64)(p[6])) << 48U)) | (((u64)(p[7])) << 56U));
		return _t1;
	}
	return 0;
}

// Attr: [direct_array_access]
// Attr: [inline]
inline u32 hash__fnv1a__sum32_string(string data) {
	u32 hash = _const_hash__fnv1a__fnv32_offset_basis;
	for (int i = 0; i < data.len; ++i) {
		hash = ((hash ^ ((u32)(data.str[ i])))) * _const_hash__fnv1a__fnv32_prime;
	}
	u32 _t1 = hash;
	return _t1;
}

// Attr: [direct_array_access]
// Attr: [inline]
inline u32 hash__fnv1a__sum32(Array_byte data) {
	u32 hash = _const_hash__fnv1a__fnv32_offset_basis;
	for (int i = 0; i < data.len; ++i) {
		hash = ((hash ^ ((u32)(((byte*)data.data)[i])))) * _const_hash__fnv1a__fnv32_prime;
	}
	u32 _t1 = hash;
	return _t1;
}

// Attr: [direct_array_access]
// Attr: [inline]
// Attr: [unsafe]
inline u32 hash__fnv1a__sum32_bytes(byte* data, int data_len) {
	u32 hash = _const_hash__fnv1a__fnv32_offset_basis;
	for (int i = 0; i < data_len; ++i) {
		hash = ((hash ^ ((u32)(data[i])))) * _const_hash__fnv1a__fnv32_prime;
	}
	u32 _t1 = hash;
	return _t1;
}

// Attr: [direct_array_access]
// Attr: [inline]
inline u64 hash__fnv1a__sum64_string(string data) {
	u64 hash = _const_hash__fnv1a__fnv64_offset_basis;
	for (int i = 0; i < data.len; ++i) {
		hash = ((hash ^ ((u64)(data.str[ i])))) * _const_hash__fnv1a__fnv64_prime;
	}
	u64 _t1 = hash;
	return _t1;
}

// Attr: [direct_array_access]
// Attr: [inline]
inline u64 hash__fnv1a__sum64(Array_byte data) {
	u64 hash = _const_hash__fnv1a__fnv64_offset_basis;
	for (int i = 0; i < data.len; ++i) {
		hash = ((hash ^ ((u64)(((byte*)data.data)[i])))) * _const_hash__fnv1a__fnv64_prime;
	}
	u64 _t1 = hash;
	return _t1;
}

// Attr: [direct_array_access]
// Attr: [inline]
// Attr: [unsafe]
inline u64 hash__fnv1a__sum64_bytes(byte* data, int data_len) {
	u64 hash = _const_hash__fnv1a__fnv64_offset_basis;
	for (int i = 0; i < data_len; ++i) {
		hash = ((hash ^ ((u64)(data[i])))) * _const_hash__fnv1a__fnv64_prime;
	}
	u64 _t1 = hash;
	return _t1;
}

// Attr: [unsafe]
VV_LOCAL_SYMBOL void flag__Flag_free(flag__Flag* f) {
	{ // Unsafe block
		string_free(&f->name);
		string_free(&f->usage);
		string_free(&f->val_desc);
	}
}

string flag__Flag_str(flag__Flag f) {
	string _t1 = string__plus(string__plus(string__plus(string__plus(_SLIT("    flag:\n"),  str_intp(2, _MOV((StrIntpData[]){{_SLIT("            name: "), 0xfe10, {.d_s = f.name}}, {_SLIT("\n"), 0, { .d_c = 0 }}}))),  str_intp(2, _MOV((StrIntpData[]){{_SLIT("            abbr: `"), 0xfe10, {.d_s = byte_ascii_str(f.abbr)}}, {_SLIT("`\n"), 0, { .d_c = 0 }}}))),  str_intp(2, _MOV((StrIntpData[]){{_SLIT("            usag: "), 0xfe10, {.d_s = f.usage}}, {_SLIT("\n"), 0, { .d_c = 0 }}}))),  str_intp(2, _MOV((StrIntpData[]){{_SLIT("            desc: "), 0xfe10, {.d_s = f.val_desc}}, {_SLIT0, 0, { .d_c = 0 }}})));
	return _t1;
}

string Array_flag__Flag_str(Array_flag__Flag af) {
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	array_push((array*)&res, _MOV((string[]){ string_clone(_SLIT("\n  []Flag = [")) }));
	for (int _t2 = 0; _t2 < af.len; ++_t2) {
		flag__Flag f = ((flag__Flag*)af.data)[_t2];
		array_push((array*)&res, _MOV((string[]){ string_clone(flag__Flag_str(f)) }));
	}
	array_push((array*)&res, _MOV((string[]){ string_clone(_SLIT("  ]")) }));
	string _t5 = Array_string_join(res, _SLIT("\n"));
	return _t5;
}

// Attr: [unsafe]
VV_LOCAL_SYMBOL void flag__FlagParser_free(flag__FlagParser* f) {
	{ // Unsafe block
		for (int _t1 = 0; _t1 < f->args.len; ++_t1) {
			string a = ((string*)f->args.data)[_t1];
			string_free(&a);
		}
		array_free(&f->args);
		for (int _t2 = 0; _t2 < f->flags.len; ++_t2) {
			flag__Flag flag = ((flag__Flag*)f->flags.data)[_t2];
			flag__Flag_free(&flag);
		}
		array_free(&f->flags);
		string_free(&f->application_name);
		string_free(&f->application_version);
		string_free(&f->application_description);
		string_free(&f->args_description);
	}
}

flag__FlagParser* flag__new_flag_parser(Array_string args) {
	Array_string original_args = array_clone_to_depth(&args, 0);
	int idx_dashdash = Array_string_index(args, _SLIT("--"));
	Array_string all_before_dashdash = array_clone_to_depth(&args, 0);
	Array_string all_after_dashdash = __new_array_with_default(0, 0, sizeof(string), 0);
	if (idx_dashdash >= 0) {
		array_trim(&all_before_dashdash, idx_dashdash);
		if (idx_dashdash < original_args.len) {
			all_after_dashdash = array_slice(original_args, idx_dashdash + 1, original_args.len);
		}
	}
	flag__FlagParser* _t1 = (flag__FlagParser*)memdup(&(flag__FlagParser){.original_args = original_args,.idx_dashdash = idx_dashdash,.all_after_dashdash = all_after_dashdash,.usage_examples = __new_array(0, 0, sizeof(string)),.default_help_label = _SLIT("display this help and exit"),.default_version_label = _SLIT("output version information and exit"),.args = all_before_dashdash,.max_free_args = _const_flag__max_args_number,.flags = __new_array(0, 0, sizeof(flag__Flag)),.application_name = (string){.str=(byteptr)"", .is_lit=1},.application_version = (string){.str=(byteptr)"", .is_lit=1},.application_description = (string){.str=(byteptr)"", .is_lit=1},.min_free_args = 0,.args_description = (string){.str=(byteptr)"", .is_lit=1},.allow_unknown_args = 0,.footers = __new_array(0, 0, sizeof(string)),}, sizeof(flag__FlagParser));
	return _t1;
}

void flag__FlagParser_usage_example(flag__FlagParser* fs, string example) {
	array_push((array*)&fs->usage_examples, _MOV((string[]){ string_clone(example) }));
}

void flag__FlagParser_footer(flag__FlagParser* fs, string footer) {
	array_push((array*)&fs->footers, _MOV((string[]){ string_clone(footer) }));
}

void flag__FlagParser_application(flag__FlagParser* fs, string name) {
	fs->application_name = name;
}

void flag__FlagParser_version(flag__FlagParser* fs, string vers) {
	fs->application_version = vers;
}

void flag__FlagParser_description(flag__FlagParser* fs, string desc) {
	if (fs->application_description.len == 0) {
		fs->application_description = desc;
	} else {
		fs->application_description = /*f*/string__plus(fs->application_description,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\n"), 0xfe10, {.d_s = desc}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
}

void flag__FlagParser_skip_executable(flag__FlagParser* fs) {
	array_delete(&fs->args, 0);
}

void flag__FlagParser_allow_unknown_args(flag__FlagParser* fs) {
	fs->allow_unknown_args = true;
}

VV_LOCAL_SYMBOL void flag__FlagParser_add_flag(flag__FlagParser* fs, string name, byte abbr, string usage, string desc) {
	array_push((array*)&fs->flags, _MOV((flag__Flag[]){ (flag__Flag){.name = name,.abbr = abbr,.usage = usage,.val_desc = desc,} }));
}

// Attr: [manualfree]
VV_LOCAL_SYMBOL Array_string flag__FlagParser_parse_value(flag__FlagParser* fs, string longhand, byte shorthand) {
bool flag__FlagParser_parse_value_defer_0 = false;
string full;
bool flag__FlagParser_parse_value_defer_1 = false;
Array_int to_delete;
	full =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("--"), 0xfe10, {.d_s = longhand}}, {_SLIT0, 0, { .d_c = 0 }}}));
	flag__FlagParser_parse_value_defer_0 = true;
	Array_string found_entries = __new_array_with_default(0, 0, sizeof(string), 0);
	to_delete = __new_array_with_default(0, 0, sizeof(int), 0);
	flag__FlagParser_parse_value_defer_1 = true;
	bool should_skip_one = false;
	for (int i = 0; i < fs->args.len; ++i) {
		string arg = ((string*)fs->args.data)[i];
		if (should_skip_one) {
			should_skip_one = false;
			continue;
		}
		if (arg.len == 0 || string_at(arg, 0) != '-') {
			continue;
		}
		if ((arg.len == 2 && string_at(arg, 0) == '-' && string_at(arg, 1) == shorthand) || string__eq(arg, full)) {
			if (i + 1 >= fs->args.len) {
				Array_string _t1 = __new_array_with_default(0, 0, sizeof(string), 0);
				// Defer begin
				if (flag__FlagParser_parse_value_defer_1) {
					array_free(&to_delete);
				}
				// Defer end
				// Defer begin
				if (flag__FlagParser_parse_value_defer_0) {
					string_free(&full);
				}
				// Defer end
				return _t1;
			}
			string nextarg = (*(string*)/*ee elem_typ */array_get(fs->args, i + 1));
			if (nextarg.len > 2) {
				string nextarg_rest = string_substr(nextarg, 0, 2);
				if (string__eq(nextarg_rest, _SLIT("--"))) {
					string_free(&nextarg_rest);
					Array_string _t2 = __new_array_with_default(0, 0, sizeof(string), 0);
					// Defer begin
					if (flag__FlagParser_parse_value_defer_1) {
						array_free(&to_delete);
					}
					// Defer end
					// Defer begin
					if (flag__FlagParser_parse_value_defer_0) {
						string_free(&full);
					}
					// Defer end
					return _t2;
				}
				string_free(&nextarg_rest);
			}
			array_push((array*)&found_entries, _MOV((string[]){ string_clone((*(string*)/*ee elem_typ */array_get(fs->args, i + 1))) }));
			array_push((array*)&to_delete, _MOV((int[]){ i }));
			array_push((array*)&to_delete, _MOV((int[]){ i + 1 }));
			should_skip_one = true;
			continue;
		}
		if (arg.len > full.len + 1 && string__eq(string_substr(arg, 0, full.len + 1),  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = full}}, {_SLIT("="), 0, { .d_c = 0 }}})))) {
			array_push((array*)&found_entries, _MOV((string[]){ string_clone(string_substr(arg, full.len + 1, arg.len)) }));
			array_push((array*)&to_delete, _MOV((int[]){ i }));
			continue;
		}
	}
	for (int i = 0; i < to_delete.len; ++i) {
		int del = ((int*)to_delete.data)[i];
		array_delete(&fs->args, del - i);
	}
	Array_string _t8 = found_entries;
	// Defer begin
	if (flag__FlagParser_parse_value_defer_1) {
		array_free(&to_delete);
	}
	// Defer end
	// Defer begin
	if (flag__FlagParser_parse_value_defer_0) {
		string_free(&full);
	}
	// Defer end
	return _t8;
}

VV_LOCAL_SYMBOL Option_string flag__FlagParser_parse_bool_value(flag__FlagParser* fs, string longhand, byte shorthand) {
	{
		string full =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("--"), 0xfe10, {.d_s = longhand}}, {_SLIT0, 0, { .d_c = 0 }}}));
		for (int i = 0; i < fs->args.len; ++i) {
			string arg = ((string*)fs->args.data)[i];
			if (arg.len == 0) {
				continue;
			}
			if (string_at(arg, 0) != '-') {
				continue;
			}
			if ((arg.len == 2 && string_at(arg, 0) == '-' && string_at(arg, 1) == shorthand) || string__eq(arg, full)) {
				if (fs->args.len > i + 1 && ((string__eq((*(string*)/*ee elem_typ */array_get(fs->args, i + 1)), _SLIT("true")) || string__eq((*(string*)/*ee elem_typ */array_get(fs->args, i + 1)), _SLIT("false"))))) {
					string val = (*(string*)/*ee elem_typ */array_get(fs->args, i + 1));
					array_delete(&fs->args, i + 1);
					array_delete(&fs->args, i);
					Option_string _t1;
					opt_ok(&(string[]) { val }, (Option*)(&_t1), sizeof(string));
					return _t1;
				} else {
					array_delete(&fs->args, i);
					Option_string _t2;
					opt_ok(&(string[]) { _SLIT("true") }, (Option*)(&_t2), sizeof(string));
					return _t2;
				}
			}
			if (arg.len > full.len + 1 && string__eq(string_substr(arg, 0, full.len + 1),  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = full}}, {_SLIT("="), 0, { .d_c = 0 }}})))) {
				string val = string_substr(arg, full.len + 1, arg.len);
				array_delete(&fs->args, i);
				Option_string _t3;
				opt_ok(&(string[]) { val }, (Option*)(&_t3), sizeof(string));
				return _t3;
			}
			if (arg.len > 1 && string_at(arg, 0) == '-' && string_at(arg, 1) != '-' && string_index_byte(arg, shorthand) != -1) {
				Option_string _t4;
				opt_ok(&(string[]) { _SLIT("true") }, (Option*)(&_t4), sizeof(string));
				return _t4;
			}
		}
	}
	return (Option_string){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("parameter '"), 0xfe10, {.d_s = longhand}}, {_SLIT("' not found"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
}

Option_bool flag__FlagParser_bool_opt(flag__FlagParser* fs, string name, byte abbr, string usage) {
	bool res = false;
	{
		flag__FlagParser_add_flag(fs, name, abbr, usage, _SLIT("<bool>"));
		Option_string _t1 = flag__FlagParser_parse_bool_value(fs, name, abbr);
		if (_t1.state != 0) { /*or block*/ 
			IError err = _t1.err;
			return (Option_bool){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("parameter '"), 0xfe10, {.d_s = name}}, {_SLIT("' not provided"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		
 		string parsed =  (*(string*)_t1.data);
		res = string__eq(parsed, _SLIT("true"));
	}
	Option_bool _t3;
	opt_ok(&(bool[]) { res }, (Option*)(&_t3), sizeof(bool));
	return _t3;
}

bool flag__FlagParser_bool(flag__FlagParser* fs, string name, byte abbr, bool bdefault, string usage) {
	Option_bool _t1 = flag__FlagParser_bool_opt(fs, name, abbr, usage);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		bool _t2 = bdefault;
		return _t2;
	}
	
 	bool value =  (*(bool*)_t1.data);
	bool _t3 = value;
	return _t3;
}

Array_int flag__FlagParser_int_multi(flag__FlagParser* fs, string name, byte abbr, string usage) {
	flag__FlagParser_add_flag(fs, name, abbr, usage, _SLIT("<multiple ints>"));
	Array_string parsed = flag__FlagParser_parse_value(fs, name, abbr);
	Array_int value = __new_array_with_default(0, 0, sizeof(int), 0);
	for (int _t1 = 0; _t1 < parsed.len; ++_t1) {
		string val = ((string*)parsed.data)[_t1];
		array_push((array*)&value, _MOV((int[]){ string_int(val) }));
	}
	Array_int _t3 = value;
	return _t3;
}

Option_int flag__FlagParser_int_opt(flag__FlagParser* fs, string name, byte abbr, string usage) {
	int res = 0;
	{
		flag__FlagParser_add_flag(fs, name, abbr, usage, _SLIT("<int>"));
		Array_string parsed = flag__FlagParser_parse_value(fs, name, abbr);
		if (parsed.len == 0) {
			return (Option_int){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("parameter '"), 0xfe10, {.d_s = name}}, {_SLIT("' not provided"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		string parsed0 = (*(string*)/*ee elem_typ */array_get(parsed, 0));
		res = string_int(parsed0);
	}
	Option_int _t2;
	opt_ok(&(int[]) { res }, (Option*)(&_t2), sizeof(int));
	return _t2;
}

int flag__FlagParser_int(flag__FlagParser* fs, string name, byte abbr, int idefault, string usage) {
	Option_int _t1 = flag__FlagParser_int_opt(fs, name, abbr, usage);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		int _t2 = idefault;
		return _t2;
	}
	
 	int value =  (*(int*)_t1.data);
	int _t3 = value;
	return _t3;
}

Array_f64 flag__FlagParser_float_multi(flag__FlagParser* fs, string name, byte abbr, string usage) {
	flag__FlagParser_add_flag(fs, name, abbr, usage, _SLIT("<multiple floats>"));
	Array_string parsed = flag__FlagParser_parse_value(fs, name, abbr);
	Array_f64 value = __new_array_with_default(0, 0, sizeof(f64), 0);
	for (int _t1 = 0; _t1 < parsed.len; ++_t1) {
		string val = ((string*)parsed.data)[_t1];
		array_push((array*)&value, _MOV((f64[]){ string_f64(val) }));
	}
	Array_f64 _t3 = value;
	return _t3;
}

Option_f64 flag__FlagParser_float_opt(flag__FlagParser* fs, string name, byte abbr, string usage) {
	f64 res = 0.0;
	{
		flag__FlagParser_add_flag(fs, name, abbr, usage, _SLIT("<float>"));
		Array_string parsed = flag__FlagParser_parse_value(fs, name, abbr);
		if (parsed.len == 0) {
			return (Option_f64){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("parameter '"), 0xfe10, {.d_s = name}}, {_SLIT("' not provided"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		res = string_f64((*(string*)/*ee elem_typ */array_get(parsed, 0)));
	}
	Option_f64 _t2;
	opt_ok(&(f64[]) { res }, (Option*)(&_t2), sizeof(f64));
	return _t2;
}

f64 flag__FlagParser_float(flag__FlagParser* fs, string name, byte abbr, f64 fdefault, string usage) {
	Option_f64 _t1 = flag__FlagParser_float_opt(fs, name, abbr, usage);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		f64 _t2 = fdefault;
		return _t2;
	}
	
 	f64 value =  (*(f64*)_t1.data);
	f64 _t3 = value;
	return _t3;
}

Array_string flag__FlagParser_string_multi(flag__FlagParser* fs, string name, byte abbr, string usage) {
	flag__FlagParser_add_flag(fs, name, abbr, usage, _SLIT("<multiple strings>"));
	Array_string _t1 = flag__FlagParser_parse_value(fs, name, abbr);
	return _t1;
}

Option_string flag__FlagParser_string_opt(flag__FlagParser* fs, string name, byte abbr, string usage) {
	string res = _SLIT("");
	{
		flag__FlagParser_add_flag(fs, name, abbr, usage, _SLIT("<string>"));
		Array_string parsed = flag__FlagParser_parse_value(fs, name, abbr);
		if (parsed.len == 0) {
			return (Option_string){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("parameter '"), 0xfe10, {.d_s = name}}, {_SLIT("' not provided"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		res = (*(string*)/*ee elem_typ */array_get(parsed, 0));
	}
	Option_string _t2;
	opt_ok(&(string[]) { res }, (Option*)(&_t2), sizeof(string));
	return _t2;
}

string flag__FlagParser_string(flag__FlagParser* fs, string name, byte abbr, string sdefault, string usage) {
	Option_string _t1 = flag__FlagParser_string_opt(fs, name, abbr, usage);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		string _t2 = sdefault;
		return _t2;
	}
	
 	string value =  (*(string*)_t1.data);
	string _t3 = value;
	return _t3;
}

Option_void flag__FlagParser_limit_free_args_to_at_least(flag__FlagParser* fs, int n) {
	if (n > _const_flag__max_args_number) {
		return (Option_void){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("flag.limit_free_args_to_at_least expect n to be smaller than "), 0xfe07, {.d_i32 = _const_flag__max_args_number}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (n <= 0) {
		return (Option_void){ .state=2, .err=_v_error(_SLIT("flag.limit_free_args_to_at_least expect n to be a positive number")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	fs->min_free_args = n;
	return (Option_void){0};
}

Option_void flag__FlagParser_limit_free_args_to_exactly(flag__FlagParser* fs, int n) {
	if (n > _const_flag__max_args_number) {
		return (Option_void){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("flag.limit_free_args_to_exactly expect n to be smaller than "), 0xfe07, {.d_i32 = _const_flag__max_args_number}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (n < 0) {
		return (Option_void){ .state=2, .err=_v_error(_SLIT("flag.limit_free_args_to_exactly expect n to be a non negative number")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	fs->min_free_args = n;
	fs->max_free_args = n;
	return (Option_void){0};
}

Option_void flag__FlagParser_limit_free_args(flag__FlagParser* fs, int min, int max) {
	if (min > max) {
		return (Option_void){ .state=2, .err=_v_error( str_intp(3, _MOV((StrIntpData[]){{_SLIT("flag.limit_free_args expect min < max, got "), 0xfe07, {.d_i32 = min}}, {_SLIT(" >= "), 0xfe07, {.d_i32 = max}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	fs->min_free_args = min;
	fs->max_free_args = max;
	return (Option_void){0};
}

void flag__FlagParser_arguments_description(flag__FlagParser* fs, string description) {
	fs->args_description = description;
}

string flag__FlagParser_usage(flag__FlagParser* fs) {
	bool positive_min_arg = (fs->min_free_args > 0);
	bool positive_max_arg = (fs->max_free_args > 0 && fs->max_free_args != _const_flag__max_args_number);
	bool no_arguments = (fs->min_free_args == 0 && fs->max_free_args == 0);
	string adesc = (fs->args_description.len > 0 ? (fs->args_description) : (_SLIT("[ARGS]")));
	if (no_arguments) {
		adesc = _SLIT("");
	}
	Array_string use = __new_array_with_default(0, 0, sizeof(string), 0);
	if ((fs->application_version).len != 0) {
		array_push((array*)&use, _MOV((string[]){ string_clone( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = fs->application_name}}, {_SLIT(" "), 0xfe10, {.d_s = fs->application_version}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
		array_push((array*)&use, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = _const_flag__underline}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
	}
	if (fs->usage_examples.len == 0) {
		array_push((array*)&use, _MOV((string[]){ string_clone( str_intp(3, _MOV((StrIntpData[]){{_SLIT("Usage: "), 0xfe10, {.d_s = fs->application_name}}, {_SLIT(" [options] "), 0xfe10, {.d_s = adesc}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
	} else {
		for (int i = 0; i < fs->usage_examples.len; ++i) {
			string example = ((string*)fs->usage_examples.data)[i];
			if (i == 0) {
				array_push((array*)&use, _MOV((string[]){ string_clone( str_intp(3, _MOV((StrIntpData[]){{_SLIT("Usage: "), 0xfe10, {.d_s = fs->application_name}}, {_SLIT(" "), 0xfe10, {.d_s = example}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
			} else {
				array_push((array*)&use, _MOV((string[]){ string_clone( str_intp(3, _MOV((StrIntpData[]){{_SLIT("   or: "), 0xfe10, {.d_s = fs->application_name}}, {_SLIT(" "), 0xfe10, {.d_s = example}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
			}
		}
	}
	array_push((array*)&use, _MOV((string[]){ string_clone(_SLIT("")) }));
	if ((fs->application_description).len != 0) {
		array_push((array*)&use, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Description: "), 0xfe10, {.d_s = fs->application_description}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
		array_push((array*)&use, _MOV((string[]){ string_clone(_SLIT("")) }));
	}
	if (positive_min_arg || positive_max_arg || no_arguments) {
		if (no_arguments) {
			array_push((array*)&use, _MOV((string[]){ string_clone(_SLIT("This application does not expect any arguments")) }));
			array_push((array*)&use, _MOV((string[]){ string_clone(_SLIT("")) }));
		} else {
			Array_string s = __new_array_with_default(0, 0, sizeof(string), 0);
			if (positive_min_arg) {
				array_push((array*)&s, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("at least "), 0xfe07, {.d_i32 = fs->min_free_args}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
			}
			if (positive_max_arg) {
				array_push((array*)&s, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("at most "), 0xfe07, {.d_i32 = fs->max_free_args}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
			}
			if (positive_min_arg && positive_max_arg && fs->min_free_args == fs->max_free_args) {
				s = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){ str_intp(2, _MOV((StrIntpData[]){{_SLIT("exactly "), 0xfe07, {.d_i32 = fs->min_free_args}}, {_SLIT0, 0, { .d_c = 0 }}}))}));
			}
			string sargs = Array_string_join(s, _SLIT(" and "));
			array_push((array*)&use, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("The arguments should be "), 0xfe10, {.d_s = sargs}}, {_SLIT(" in number."), 0, { .d_c = 0 }}}))) }));
			array_push((array*)&use, _MOV((string[]){ string_clone(_SLIT("")) }));
		}
	}
	if (fs->flags.len > 0) {
		array_push((array*)&use, _MOV((string[]){ string_clone(_SLIT("Options:")) }));
		for (int _t16 = 0; _t16 < fs->flags.len; ++_t16) {
			flag__Flag f = ((flag__Flag*)fs->flags.data)[_t16];
			Array_string onames = __new_array_with_default(0, 0, sizeof(string), 0);
			if (f.abbr != 0) {
				array_push((array*)&onames, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("-"), 0xfe10, {.d_s = byte_ascii_str(f.abbr)}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
			}
			if ((f.name).len != 0) {
				if (!string_contains(f.val_desc, _SLIT("<bool>"))) {
					array_push((array*)&onames, _MOV((string[]){ string_clone( str_intp(3, _MOV((StrIntpData[]){{_SLIT("--"), 0xfe10, {.d_s = f.name}}, {_SLIT(" "), 0xfe10, {.d_s = f.val_desc}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
				} else {
					array_push((array*)&onames, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("--"), 0xfe10, {.d_s = f.name}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
				}
			}
			string option_names = string__plus(_SLIT("  "), Array_string_join(onames, _SLIT(", ")));
			string xspace = _SLIT("");
			if (option_names.len > _const_flag__space.len - 2) {
				xspace =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\n"), 0xfe10, {.d_s = _const_flag__space}}, {_SLIT0, 0, { .d_c = 0 }}}));
			} else {
				xspace = string_substr(_const_flag__space, option_names.len, _const_flag__space.len);
			}
			string fdesc =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = option_names}}, {_SLIT0, 0xfe10, {.d_s = xspace}}, {_SLIT0, 0xfe10, {.d_s = f.usage}}, {_SLIT0, 0, { .d_c = 0 }}}));
			array_push((array*)&use, _MOV((string[]){ string_clone(fdesc) }));
		}
	}
	for (int _t21 = 0; _t21 < fs->footers.len; ++_t21) {
		string footer = ((string*)fs->footers.data)[_t21];
		array_push((array*)&use, _MOV((string[]){ string_clone(footer) }));
	}
	string _t23 = string_replace(Array_string_join(use, _SLIT("\n")), _SLIT("- ,"), _SLIT("   "));
	return _t23;
}

VV_LOCAL_SYMBOL Option_flag__Flag flag__FlagParser_find_existing_flag(flag__FlagParser* fs, string fname) {
	for (int _t1 = 0; _t1 < fs->flags.len; ++_t1) {
		flag__Flag f = ((flag__Flag*)fs->flags.data)[_t1];
		if (string__eq(f.name, fname)) {
			Option_flag__Flag _t2;
			opt_ok(&(flag__Flag[]) { f }, (Option*)(&_t2), sizeof(flag__Flag));
			return _t2;
		}
	}
	return (Option_flag__Flag){ .state=2, .err=_v_error(_SLIT("no such flag")), .data={EMPTY_STRUCT_INITIALIZATION} };
}

VV_LOCAL_SYMBOL void flag__FlagParser_handle_builtin_options(flag__FlagParser* fs) {
	bool show_version = false;
	bool show_help = false;
	Option_flag__Flag _t1 = flag__FlagParser_find_existing_flag(fs, _SLIT("help"));
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		show_help = flag__FlagParser_bool(fs, _SLIT("help"), 'h', false, fs->default_help_label);
	}
	
  (*(flag__Flag*)_t1.data);
	Option_flag__Flag _t2 = flag__FlagParser_find_existing_flag(fs, _SLIT("version"));
	if (_t2.state != 0) { /*or block*/ 
		IError err = _t2.err;
		show_version = flag__FlagParser_bool(fs, _SLIT("version"), 0, false, fs->default_version_label);
	}
	
  (*(flag__Flag*)_t2.data);
	if (show_help) {
		println(flag__FlagParser_usage(fs));
		_v_exit(0);
		VUNREACHABLE();
	}
	if (show_version) {
		println( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = fs->application_name}}, {_SLIT(" "), 0xfe10, {.d_s = fs->application_version}}, {_SLIT0, 0, { .d_c = 0 }}})));
		_v_exit(0);
		VUNREACHABLE();
	}
}

Option_Array_string flag__FlagParser_finalize(flag__FlagParser* fs) {
	flag__FlagParser_handle_builtin_options(fs);
	Array_string remaining = array_clone_to_depth(&fs->args, 0);
	if (!fs->allow_unknown_args) {
		for (int _t1 = 0; _t1 < remaining.len; ++_t1) {
			string a = ((string*)remaining.data)[_t1];
			if ((a.len >= 2 && string__eq(string_substr(a, 0, 2), _SLIT("--"))) || (a.len == 2 && string_at(a, 0) == '-')) {
				return (Option_Array_string){ .state=2, .err=/*&IError*/I_flag__UnkownFlagError_to_Interface_IError((flag__UnkownFlagError*)memdup(&(flag__UnkownFlagError){.msg =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("Unknown flag `"), 0xfe10, {.d_s = a}}, {_SLIT("`"), 0, { .d_c = 0 }}})),.code = 0,}, sizeof(flag__UnkownFlagError))), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
		}
	}
	if (remaining.len < fs->min_free_args && fs->min_free_args > 0) {
		return (Option_Array_string){ .state=2, .err=/*&IError*/I_flag__MinimumArgsCountError_to_Interface_IError((flag__MinimumArgsCountError*)memdup(&(flag__MinimumArgsCountError){.msg =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("Expected at least "), 0xfe07, {.d_i32 = fs->min_free_args}}, {_SLIT(" arguments, but given "), 0xfe07, {.d_i32 = remaining.len}}, {_SLIT0, 0, { .d_c = 0 }}})),.code = 0,}, sizeof(flag__MinimumArgsCountError))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (remaining.len > fs->max_free_args && fs->max_free_args > 0) {
		return (Option_Array_string){ .state=2, .err=/*&IError*/I_flag__MaximumArgsCountError_to_Interface_IError((flag__MaximumArgsCountError*)memdup(&(flag__MaximumArgsCountError){.msg =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("Expected at most "), 0xfe07, {.d_i32 = fs->max_free_args}}, {_SLIT(" arguments, but given "), 0xfe07, {.d_i32 = remaining.len}}, {_SLIT0, 0, { .d_c = 0 }}})),.code = 0,}, sizeof(flag__MaximumArgsCountError))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (remaining.len > 0 && fs->max_free_args == 0 && fs->min_free_args == 0) {
		return (Option_Array_string){ .state=2, .err=/*&IError*/I_flag__NoArgsExpectedError_to_Interface_IError((flag__NoArgsExpectedError*)memdup(&(flag__NoArgsExpectedError){.msg =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("Expected no arguments, but given "), 0xfe07, {.d_i32 = remaining.len}}, {_SLIT0, 0, { .d_c = 0 }}})),.code = 0,}, sizeof(flag__NoArgsExpectedError))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_PUSH_MANY(&remaining, (fs->all_after_dashdash), _t6, Array_string);
	Option_Array_string _t7;
	opt_ok(&(Array_string[]) { remaining }, (Option*)(&_t7), sizeof(Array_string));
	return _t7;
}

Array_string flag__FlagParser_remaining_parameters(flag__FlagParser* fs) {
	Option_Array_string _t2 = flag__FlagParser_finalize(fs);
	if (_t2.state != 0) { /*or block*/ 
		IError err = _t2.err;
		eprintln((*(err.msg)));
		println(flag__FlagParser_usage(fs));
		_v_exit(1);
		VUNREACHABLE();
	;
	}
	
 	Array_string _t1 =  (*(Array_string*)_t2.data);
	return _t1;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL bool semver__version_satisfies(semver__Version ver, string input) {
	Option_semver__Range _t1 = semver__parse_range(input);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		bool _t2 = false;
		return _t2;
	}
	
 	semver__Range range =  (*(semver__Range*)_t1.data);
	bool _t3 = semver__Range_satisfies(range, ver);
	return _t3;
}

VV_LOCAL_SYMBOL bool semver__compare_eq(semver__Version v1, semver__Version v2) {
	bool _t1 = v1.major == v2.major && v1.minor == v2.minor && v1.patch == v2.patch && string__eq(v1.prerelease, v2.prerelease);
	return _t1;
}

VV_LOCAL_SYMBOL bool semver__compare_gt(semver__Version v1, semver__Version v2) {
	if (v1.major < v2.major) {
		bool _t1 = false;
		return _t1;
	}
	if (v1.major > v2.major) {
		bool _t2 = true;
		return _t2;
	}
	if (v1.minor < v2.minor) {
		bool _t3 = false;
		return _t3;
	}
	if (v1.minor > v2.minor) {
		bool _t4 = true;
		return _t4;
	}
	bool _t5 = v1.patch > v2.patch;
	return _t5;
}

VV_LOCAL_SYMBOL bool semver__compare_lt(semver__Version v1, semver__Version v2) {
	if (v1.major > v2.major) {
		bool _t1 = false;
		return _t1;
	}
	if (v1.major < v2.major) {
		bool _t2 = true;
		return _t2;
	}
	if (v1.minor > v2.minor) {
		bool _t3 = false;
		return _t3;
	}
	if (v1.minor < v2.minor) {
		bool _t4 = true;
		return _t4;
	}
	bool _t5 = v1.patch < v2.patch;
	return _t5;
}

VV_LOCAL_SYMBOL bool semver__compare_ge(semver__Version v1, semver__Version v2) {
	if (semver__compare_eq(v1, v2)) {
		bool _t1 = true;
		return _t1;
	}
	bool _t2 = semver__compare_gt(v1, v2);
	return _t2;
}

VV_LOCAL_SYMBOL bool semver__compare_le(semver__Version v1, semver__Version v2) {
	if (semver__compare_eq(v1, v2)) {
		bool _t1 = true;
		return _t1;
	}
	bool _t2 = semver__compare_lt(v1, v2);
	return _t2;
}

VV_LOCAL_SYMBOL semver__RawVersion semver__parse(string input) {
	string raw_version = input;
	string prerelease = _SLIT("");
	string metadata = _SLIT("");
	Option_int _t1 = string_last_index(raw_version, _SLIT("+"));
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		*(int*) _t1.data = -1;
	}
	
 	int plus_idx =  (*(int*)_t1.data);
	if (plus_idx > 0) {
		metadata = string_substr(raw_version, (plus_idx + 1), raw_version.len);
		raw_version = string_substr(raw_version, 0, plus_idx);
	}
	Option_int _t2 = string_index(raw_version, _SLIT("-"));
	if (_t2.state != 0) { /*or block*/ 
		IError err = _t2.err;
		*(int*) _t2.data = -1;
	}
	
 	int hyphen_idx =  (*(int*)_t2.data);
	if (hyphen_idx > 0) {
		prerelease = string_substr(raw_version, (hyphen_idx + 1), raw_version.len);
		raw_version = string_substr(raw_version, 0, hyphen_idx);
	}
	Array_string raw_ints = string_split(raw_version, _SLIT("."));
	semver__RawVersion _t3 = (semver__RawVersion){.prerelease = prerelease,.metadata = metadata,.raw_ints = raw_ints,};
	return _t3;
}

VV_LOCAL_SYMBOL bool semver__RawVersion_is_valid(semver__RawVersion ver) {
	if (ver.raw_ints.len != 3) {
		bool _t1 = false;
		return _t1;
	}
	bool _t2 = semver__is_valid_number((*(string*)/*ee elem_typ */array_get(ver.raw_ints, _const_semver__ver_major))) && semver__is_valid_number((*(string*)/*ee elem_typ */array_get(ver.raw_ints, _const_semver__ver_minor))) && semver__is_valid_number((*(string*)/*ee elem_typ */array_get(ver.raw_ints, _const_semver__ver_patch))) && semver__is_valid_string(ver.prerelease) && semver__is_valid_string(ver.metadata);
	return _t2;
}

VV_LOCAL_SYMBOL bool semver__RawVersion_is_missing(semver__RawVersion ver, int typ) {
	bool _t1 = typ >= ver.raw_ints.len - 1;
	return _t1;
}

VV_LOCAL_SYMBOL Option_semver__Version semver__RawVersion_coerce(semver__RawVersion raw_ver) {
	semver__RawVersion ver = semver__RawVersion_complete(raw_ver);
	if (!semver__is_valid_number((*(string*)/*ee elem_typ */array_get(ver.raw_ints, _const_semver__ver_major)))) {
		return (Option_semver__Version){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Invalid major version: "), 0xfe10, {.d_s = Array_string_str(ver.raw_ints)}}, {_SLIT("[ver_major]"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Option_semver__Version _t2;
	opt_ok(&(semver__Version[]) { semver__RawVersion_to_version(ver) }, (Option*)(&_t2), sizeof(semver__Version));
	return _t2;
}

VV_LOCAL_SYMBOL semver__RawVersion semver__RawVersion_complete(semver__RawVersion raw_ver) {
	Array_string raw_ints = raw_ver.raw_ints;
	for (;;) {
		if (!(raw_ints.len < 3)) break;
		array_push((array*)&raw_ints, _MOV((string[]){ string_clone(_SLIT("0")) }));
	}
	semver__RawVersion _t2 = (semver__RawVersion){.prerelease = raw_ver.prerelease,.metadata = raw_ver.metadata,.raw_ints = raw_ints,};
	return _t2;
}

VV_LOCAL_SYMBOL Option_semver__Version semver__RawVersion_validate(semver__RawVersion raw_ver) {
	if (!semver__RawVersion_is_valid(raw_ver)) {
		return (Option_semver__Version){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Option_semver__Version _t2;
	opt_ok(&(semver__Version[]) { semver__RawVersion_to_version(raw_ver) }, (Option*)(&_t2), sizeof(semver__Version));
	return _t2;
}

VV_LOCAL_SYMBOL semver__Version semver__RawVersion_to_version(semver__RawVersion raw_ver) {
	semver__Version _t1 = (semver__Version){.major = string_int((*(string*)/*ee elem_typ */array_get(raw_ver.raw_ints, _const_semver__ver_major))),.minor = string_int((*(string*)/*ee elem_typ */array_get(raw_ver.raw_ints, _const_semver__ver_minor))),.patch = string_int((*(string*)/*ee elem_typ */array_get(raw_ver.raw_ints, _const_semver__ver_patch))),.prerelease = raw_ver.prerelease,.metadata = raw_ver.metadata,};
	return _t1;
}

VV_LOCAL_SYMBOL bool semver__Range_satisfies(semver__Range r, semver__Version ver) {
	bool final_result = false;
	for (int _t1 = 0; _t1 < r.comparator_sets.len; ++_t1) {
		semver__ComparatorSet set = ((semver__ComparatorSet*)r.comparator_sets.data)[_t1];
		final_result = final_result || semver__ComparatorSet_satisfies(set, ver);
	}
	bool _t2 = final_result;
	return _t2;
}

VV_LOCAL_SYMBOL bool semver__ComparatorSet_satisfies(semver__ComparatorSet set, semver__Version ver) {
	for (int _t1 = 0; _t1 < set.comparators.len; ++_t1) {
		semver__Comparator comp = ((semver__Comparator*)set.comparators.data)[_t1];
		if (!semver__Comparator_satisfies(comp, ver)) {
			bool _t2 = false;
			return _t2;
		}
	}
	bool _t3 = true;
	return _t3;
}

VV_LOCAL_SYMBOL bool semver__Comparator_satisfies(semver__Comparator c, semver__Version ver) {
	if (c.op == semver__Operator__gt) {
		bool _t1 = semver__Version_gt(ver, c.ver);
		return _t1;
	}
	if (c.op == semver__Operator__lt) {
		bool _t2 = semver__Version_lt(ver, c.ver);
		return _t2;
	}
	if (c.op == semver__Operator__ge) {
		bool _t3 = semver__Version_ge(ver, c.ver);
		return _t3;
	}
	if (c.op == semver__Operator__le) {
		bool _t4 = semver__Version_le(ver, c.ver);
		return _t4;
	}
	if (c.op == semver__Operator__eq) {
		bool _t5 = semver__Version_eq(ver, c.ver);
		return _t5;
	}
	bool _t6 = false;
	return _t6;
}

VV_LOCAL_SYMBOL Option_semver__Range semver__parse_range(string input) {
	Array_string raw_comparator_sets = string_split(input, _const_semver__comparator_set_sep);
	Array_semver__ComparatorSet comparator_sets = __new_array_with_default(0, 0, sizeof(semver__ComparatorSet), 0);
	for (int _t1 = 0; _t1 < raw_comparator_sets.len; ++_t1) {
		string raw_comp_set = ((string*)raw_comparator_sets.data)[_t1];
		if (semver__can_expand(raw_comp_set)) {
			Option_semver__ComparatorSet _t2 = semver__expand_comparator_set(raw_comp_set);
			if (_t2.state != 0) { /*or block*/ 
				IError err = _t2.err;
				return (Option_semver__Range){ .state=2, .err=err, .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			
 			semver__ComparatorSet s =  (*(semver__ComparatorSet*)_t2.data);
			array_push((array*)&comparator_sets, _MOV((semver__ComparatorSet[]){ s }));
		} else {
			Option_semver__ComparatorSet _t5 = semver__parse_comparator_set(raw_comp_set);
			if (_t5.state != 0) { /*or block*/ 
				IError err = _t5.err;
				return (Option_semver__Range){ .state=2, .err=err, .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			
 			semver__ComparatorSet s =  (*(semver__ComparatorSet*)_t5.data);
			array_push((array*)&comparator_sets, _MOV((semver__ComparatorSet[]){ s }));
		}
	}
	Option_semver__Range _t8;
	opt_ok(&(semver__Range[]) { (semver__Range){.comparator_sets = comparator_sets,} }, (Option*)(&_t8), sizeof(semver__Range));
	return _t8;
}

VV_LOCAL_SYMBOL Option_semver__ComparatorSet semver__parse_comparator_set(string input) {
	Array_string raw_comparators = string_split(input, _const_semver__comparator_sep);
	if (raw_comparators.len > 2) {
		return (Option_semver__ComparatorSet){ .state=2, .err=/*&IError*/I_semver__InvalidComparatorFormatError_to_Interface_IError((semver__InvalidComparatorFormatError*)memdup(&(semver__InvalidComparatorFormatError){.msg =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("Invalid format of comparator set for input \""), 0xfe10, {.d_s = input}}, {_SLIT("\""), 0, { .d_c = 0 }}})),.code = 0,}, sizeof(semver__InvalidComparatorFormatError))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Array_semver__Comparator comparators = __new_array_with_default(0, 0, sizeof(semver__Comparator), 0);
	for (int _t2 = 0; _t2 < raw_comparators.len; ++_t2) {
		string raw_comp = ((string*)raw_comparators.data)[_t2];
		Option_semver__Comparator _t3 = semver__parse_comparator(raw_comp);
		if (_t3.state != 0) { /*or block*/ 
			IError err = _t3.err;
			return (Option_semver__ComparatorSet){ .state=2, .err=/*&IError*/I_semver__InvalidComparatorFormatError_to_Interface_IError((semver__InvalidComparatorFormatError*)memdup(&(semver__InvalidComparatorFormatError){.msg =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("Invalid comparator \""), 0xfe10, {.d_s = raw_comp}}, {_SLIT("\" in input \""), 0xfe10, {.d_s = input}}, {_SLIT("\""), 0, { .d_c = 0 }}})),.code = 0,}, sizeof(semver__InvalidComparatorFormatError))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		
 		semver__Comparator c =  (*(semver__Comparator*)_t3.data);
		array_push((array*)&comparators, _MOV((semver__Comparator[]){ c }));
	}
	Option_semver__ComparatorSet _t6;
	opt_ok(&(semver__ComparatorSet[]) { (semver__ComparatorSet){.comparators = comparators,} }, (Option*)(&_t6), sizeof(semver__ComparatorSet));
	return _t6;
}

VV_LOCAL_SYMBOL Option_semver__Comparator semver__parse_comparator(string input) {
	semver__Operator op = semver__Operator__eq;
	string raw_version = _SLIT("");
	if (string_starts_with(input, _SLIT(">="))) {
		op = semver__Operator__ge;
		raw_version = string_substr(input, 2, input.len);
	} else if (string_starts_with(input, _SLIT("<="))) {
		op = semver__Operator__le;
		raw_version = string_substr(input, 2, input.len);
	} else if (string_starts_with(input, _SLIT(">"))) {
		op = semver__Operator__gt;
		raw_version = string_substr(input, 1, input.len);
	} else if (string_starts_with(input, _SLIT("<"))) {
		op = semver__Operator__lt;
		raw_version = string_substr(input, 1, input.len);
	} else if (string_starts_with(input, _SLIT("="))) {
		raw_version = string_substr(input, 1, input.len);
	} else {
		raw_version = input;
	}
	Option_semver__Version _t1 = semver__coerce_version(raw_version);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		return (Option_semver__Comparator){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	semver__Version version =  (*(semver__Version*)_t1.data);
	Option_semver__Comparator _t3;
	opt_ok(&(semver__Comparator[]) { (semver__Comparator){.ver = version,.op = op,} }, (Option*)(&_t3), sizeof(semver__Comparator));
	return _t3;
}

VV_LOCAL_SYMBOL Option_semver__Version semver__parse_xrange(string input) {
	semver__RawVersion raw_ver = semver__RawVersion_complete(semver__parse(input));
	for (int _t1 = 0; _t1 < _const_semver__versions.len; ++_t1) {
		int typ = ((int*)_const_semver__versions.data)[_t1];
		if (string_index_any((*(string*)/*ee elem_typ */array_get(raw_ver.raw_ints, typ)), _const_semver__x_range_symbols) == -1) {
			continue;
		}

		if (typ == (_const_semver__ver_major)) {
			(*(string*)/*ee elem_typ */array_get(raw_ver.raw_ints, _const_semver__ver_major)) = _SLIT("0");
			(*(string*)/*ee elem_typ */array_get(raw_ver.raw_ints, _const_semver__ver_minor)) = _SLIT("0");
			(*(string*)/*ee elem_typ */array_get(raw_ver.raw_ints, _const_semver__ver_patch)) = _SLIT("0");
		}
		else if (typ == (_const_semver__ver_minor)) {
			(*(string*)/*ee elem_typ */array_get(raw_ver.raw_ints, _const_semver__ver_minor)) = _SLIT("0");
			(*(string*)/*ee elem_typ */array_get(raw_ver.raw_ints, _const_semver__ver_patch)) = _SLIT("0");
		}
		else if (typ == (_const_semver__ver_patch)) {
			(*(string*)/*ee elem_typ */array_get(raw_ver.raw_ints, _const_semver__ver_patch)) = _SLIT("0");
		}
		else {
		};
	}
	if (!semver__RawVersion_is_valid(raw_ver)) {
		return (Option_semver__Version){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Option_semver__Version _t3;
	opt_ok(&(semver__Version[]) { semver__RawVersion_to_version(raw_ver) }, (Option*)(&_t3), sizeof(semver__Version));
	return _t3;
}

VV_LOCAL_SYMBOL bool semver__can_expand(string input) {
	bool _t1 = string_at(input, 0) == '~' || string_at(input, 0) == '^' || string_contains(input, _const_semver__hyphen_range_sep) || string_index_any(input, _const_semver__x_range_symbols) > -1;
	return _t1;
}

VV_LOCAL_SYMBOL Option_semver__ComparatorSet semver__expand_comparator_set(string input) {
	byte _t1 = string_at(input, 0);
	
	if (_t1 == ('~')) {
		Option_semver__ComparatorSet _t2 = semver__expand_tilda(string_substr(input, 1, input.len));
		return _t2;
	}
	else if (_t1 == ('^')) {
		Option_semver__ComparatorSet _t3 = semver__expand_caret(string_substr(input, 1, input.len));
		return _t3;
	}
	else {
	};
	if (string_contains(input, _const_semver__hyphen_range_sep)) {
		Option_semver__ComparatorSet _t4 = semver__expand_hyphen(input);
		return _t4;
	}
	Option_semver__ComparatorSet _t5 = semver__expand_xrange(input);
	return _t5;
}

VV_LOCAL_SYMBOL Option_semver__ComparatorSet semver__expand_tilda(string raw_version) {
	Option_semver__Version _t1 = semver__coerce_version(raw_version);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		return (Option_semver__ComparatorSet){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	semver__Version min_ver =  (*(semver__Version*)_t1.data);
	semver__Version max_ver = min_ver;
	if (min_ver.minor == 0 && min_ver.patch == 0) {
		max_ver = semver__Version_increment(min_ver, semver__Increment__major);
	} else {
		max_ver = semver__Version_increment(min_ver, semver__Increment__minor);
	}
	Option_semver__ComparatorSet _t3;
	opt_ok(&(semver__ComparatorSet[]) { semver__make_comparator_set_ge_lt(min_ver, max_ver) }, (Option*)(&_t3), sizeof(semver__ComparatorSet));
	return _t3;
}

VV_LOCAL_SYMBOL Option_semver__ComparatorSet semver__expand_caret(string raw_version) {
	Option_semver__Version _t1 = semver__coerce_version(raw_version);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		return (Option_semver__ComparatorSet){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	semver__Version min_ver =  (*(semver__Version*)_t1.data);
	semver__Version max_ver = min_ver;
	if (min_ver.major == 0) {
		max_ver = semver__Version_increment(min_ver, semver__Increment__minor);
	} else {
		max_ver = semver__Version_increment(min_ver, semver__Increment__major);
	}
	Option_semver__ComparatorSet _t3;
	opt_ok(&(semver__ComparatorSet[]) { semver__make_comparator_set_ge_lt(min_ver, max_ver) }, (Option*)(&_t3), sizeof(semver__ComparatorSet));
	return _t3;
}

VV_LOCAL_SYMBOL Option_semver__ComparatorSet semver__expand_hyphen(string raw_range) {
	Array_string raw_versions = string_split(raw_range, _const_semver__hyphen_range_sep);
	if (raw_versions.len != 2) {
		return (Option_semver__ComparatorSet){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Option_semver__Version _t2 = semver__coerce_version((*(string*)/*ee elem_typ */array_get(raw_versions, 0)));
	if (_t2.state != 0) { /*or block*/ 
		IError err = _t2.err;
		return (Option_semver__ComparatorSet){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	semver__Version min_ver =  (*(semver__Version*)_t2.data);
	semver__RawVersion raw_max_ver = semver__parse((*(string*)/*ee elem_typ */array_get(raw_versions, 1)));
	if (semver__RawVersion_is_missing(raw_max_ver, _const_semver__ver_major)) {
		return (Option_semver__ComparatorSet){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Option_semver__Version _t5 = semver__RawVersion_coerce(raw_max_ver);
	if (_t5.state != 0) { /*or block*/ 
		IError err = _t5.err;
		return (Option_semver__ComparatorSet){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	semver__Version max_ver =  (*(semver__Version*)_t5.data);
	if (semver__RawVersion_is_missing(raw_max_ver, _const_semver__ver_minor)) {
		max_ver = semver__Version_increment(max_ver, semver__Increment__minor);
		Option_semver__ComparatorSet _t7;
		opt_ok(&(semver__ComparatorSet[]) { semver__make_comparator_set_ge_lt(min_ver, max_ver) }, (Option*)(&_t7), sizeof(semver__ComparatorSet));
		return _t7;
	}
	Option_semver__ComparatorSet _t8;
	opt_ok(&(semver__ComparatorSet[]) { semver__make_comparator_set_ge_le(min_ver, max_ver) }, (Option*)(&_t8), sizeof(semver__ComparatorSet));
	return _t8;
}

VV_LOCAL_SYMBOL Option_semver__ComparatorSet semver__expand_xrange(string raw_range) {
	Option_semver__Version _t1 = semver__parse_xrange(raw_range);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		return (Option_semver__ComparatorSet){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	semver__Version min_ver =  (*(semver__Version*)_t1.data);
	if (min_ver.major == 0) {
		Array_semver__Comparator comparators = new_array_from_c_array(1, 1, sizeof(semver__Comparator), _MOV((semver__Comparator[1]){(semver__Comparator){.ver = min_ver,.op = semver__Operator__ge,}}));
		Option_semver__ComparatorSet _t3;
		opt_ok(&(semver__ComparatorSet[]) { (semver__ComparatorSet){.comparators = comparators,} }, (Option*)(&_t3), sizeof(semver__ComparatorSet));
		return _t3;
	}
	semver__Version max_ver = min_ver;
	if (min_ver.minor == 0) {
		max_ver = semver__Version_increment(min_ver, semver__Increment__major);
	} else {
		max_ver = semver__Version_increment(min_ver, semver__Increment__minor);
	}
	Option_semver__ComparatorSet _t4;
	opt_ok(&(semver__ComparatorSet[]) { semver__make_comparator_set_ge_lt(min_ver, max_ver) }, (Option*)(&_t4), sizeof(semver__ComparatorSet));
	return _t4;
}

VV_LOCAL_SYMBOL semver__ComparatorSet semver__make_comparator_set_ge_lt(semver__Version min, semver__Version max) {
	Array_semver__Comparator comparators = new_array_from_c_array(2, 2, sizeof(semver__Comparator), _MOV((semver__Comparator[2]){(semver__Comparator){.ver = min,.op = semver__Operator__ge,}, (semver__Comparator){.ver = max,.op = semver__Operator__lt,}}));
	semver__ComparatorSet _t1 = (semver__ComparatorSet){.comparators = comparators,};
	return _t1;
}

VV_LOCAL_SYMBOL semver__ComparatorSet semver__make_comparator_set_ge_le(semver__Version min, semver__Version max) {
	Array_semver__Comparator comparators = new_array_from_c_array(2, 2, sizeof(semver__Comparator), _MOV((semver__Comparator[2]){(semver__Comparator){.ver = min,.op = semver__Operator__ge,}, (semver__Comparator){.ver = max,.op = semver__Operator__le,}}));
	semver__ComparatorSet _t1 = (semver__ComparatorSet){.comparators = comparators,};
	return _t1;
}

Option_semver__Version semver__from(string input) {
	if (input.len == 0) {
		return (Option_semver__Version){ .state=2, .err=/*&IError*/I_semver__EmptyInputError_to_Interface_IError((semver__EmptyInputError*)memdup(&(semver__EmptyInputError){.msg = _SLIT("Empty input"),.code = 0,}, sizeof(semver__EmptyInputError))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	semver__RawVersion raw_version = semver__parse(input);
	Option_semver__Version _t2 = semver__RawVersion_validate(raw_version);
	if (_t2.state != 0) { /*or block*/ 
		IError err = _t2.err;
		return (Option_semver__Version){ .state=2, .err=/*&IError*/I_semver__InvalidVersionFormatError_to_Interface_IError((semver__InvalidVersionFormatError*)memdup(&(semver__InvalidVersionFormatError){.msg =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("Invalid version format for input \""), 0xfe10, {.d_s = input}}, {_SLIT("\""), 0, { .d_c = 0 }}})),.code = 0,}, sizeof(semver__InvalidVersionFormatError))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	semver__Version version =  (*(semver__Version*)_t2.data);
	Option_semver__Version _t4;
	opt_ok(&(semver__Version[]) { version }, (Option*)(&_t4), sizeof(semver__Version));
	return _t4;
}

semver__Version semver__build(int major, int minor, int patch) {
	semver__Version _t1 = (semver__Version){.major = major,.minor = minor,.patch = patch,.prerelease = _SLIT(""),.metadata = _SLIT(""),};
	return _t1;
}

semver__Version semver__Version_increment(semver__Version ver, semver__Increment typ) {
	semver__Version _t1 = semver__increment_version(ver, typ);
	return _t1;
}

bool semver__Version_satisfies(semver__Version ver, string input) {
	bool _t1 = semver__version_satisfies(ver, input);
	return _t1;
}

bool semver__Version_eq(semver__Version v1, semver__Version v2) {
	bool _t1 = semver__compare_eq(v1, v2);
	return _t1;
}

bool semver__Version_gt(semver__Version v1, semver__Version v2) {
	bool _t1 = semver__compare_gt(v1, v2);
	return _t1;
}

bool semver__Version_lt(semver__Version v1, semver__Version v2) {
	bool _t1 = semver__compare_lt(v1, v2);
	return _t1;
}

bool semver__Version_ge(semver__Version v1, semver__Version v2) {
	bool _t1 = semver__compare_ge(v1, v2);
	return _t1;
}

bool semver__Version_le(semver__Version v1, semver__Version v2) {
	bool _t1 = semver__compare_le(v1, v2);
	return _t1;
}

string semver__Version_str(semver__Version ver) {
	string common_string =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = ver.major}}, {_SLIT("."), 0xfe07, {.d_i32 = ver.minor}}, {_SLIT("."), 0xfe07, {.d_i32 = ver.patch}}, {_SLIT0, 0, { .d_c = 0 }}}));
	string prerelease_string = (ver.prerelease.len > 0 ? ( str_intp(2, _MOV((StrIntpData[]){{_SLIT("-"), 0xfe10, {.d_s = ver.prerelease}}, {_SLIT0, 0, { .d_c = 0 }}}))) : (_SLIT("")));
	string metadata_string = (ver.metadata.len > 0 ? ( str_intp(2, _MOV((StrIntpData[]){{_SLIT("+"), 0xfe10, {.d_s = ver.metadata}}, {_SLIT0, 0, { .d_c = 0 }}}))) : (_SLIT("")));
	string _t1 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = common_string}}, {_SLIT0, 0xfe10, {.d_s = prerelease_string}}, {_SLIT0, 0xfe10, {.d_s = metadata_string}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t1;
}

Option_semver__Version semver__coerce(string input) {
	Option_semver__Version _t1 = semver__coerce_version(input);
	return _t1;
}

bool semver__is_valid(string input) {
	bool _t1 = semver__is_version_valid(input);
	return _t1;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL bool semver__is_version_valid(string input) {
	semver__RawVersion raw_ver = semver__parse(input);
	bool _t1 = semver__RawVersion_is_valid(raw_ver);
	return _t1;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL Option_semver__Version semver__coerce_version(string input) {
	semver__RawVersion raw_ver = semver__parse(input);
	Option_semver__Version _t1 = semver__RawVersion_coerce(raw_ver);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		return (Option_semver__Version){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Invalid version for input \""), 0xfe10, {.d_s = input}}, {_SLIT("\""), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	semver__Version ver =  (*(semver__Version*)_t1.data);
	Option_semver__Version _t3;
	opt_ok(&(semver__Version[]) { ver }, (Option*)(&_t3), sizeof(semver__Version));
	return _t3;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL semver__Version semver__increment_version(semver__Version ver, semver__Increment typ) {
	int major = ver.major;
	int minor = ver.minor;
	int patch = ver.patch;

	if (typ == (semver__Increment__major)) {
		major++;
		minor = 0;
		patch = 0;
	}
	else if (typ == (semver__Increment__minor)) {
		minor++;
		patch = 0;
	}
	else if (typ == (semver__Increment__patch)) {
		patch++;
	};
	semver__Version _t1 = (semver__Version){.major = major,.minor = minor,.patch = patch,.prerelease = ver.prerelease,.metadata = ver.metadata,};
	return _t1;
}

VV_LOCAL_SYMBOL bool semver__is_valid_string(string input) {
	for (int _t1 = 0; _t1 < input.len; ++_t1) {
		byte c = input.str[_t1];
		if (!(byte_is_letter(c) || byte_is_digit(c) || c == '.' || c == '-')) {
			bool _t2 = false;
			return _t2;
		}
	}
	bool _t3 = true;
	return _t3;
}

VV_LOCAL_SYMBOL bool semver__is_valid_number(string input) {
	for (int _t1 = 0; _t1 < input.len; ++_t1) {
		byte c = input.str[_t1];
		if (!byte_is_digit(c)) {
			bool _t2 = false;
			return _t2;
		}
	}
	bool _t3 = true;
	return _t3;
}

#if defined(_WIN32)
#else
#endif
bool sync__stdatomic__add_u64(u64* ptr, int delta) {
	u64 res = atomic_fetch_add_u64(((voidptr)(ptr)), delta);
	bool _t1 = res == 0U;
	return _t1;
}

bool sync__stdatomic__sub_u64(u64* ptr, int delta) {
	u64 res = atomic_fetch_sub_u64(((voidptr)(ptr)), delta);
	bool _t1 = res == 0U;
	return _t1;
}

bool sync__stdatomic__add_i64(i64* ptr, int delta) {
	u64 res = atomic_fetch_add_u64(((voidptr)(ptr)), delta);
	bool _t1 = res == 0U;
	return _t1;
}

bool sync__stdatomic__sub_i64(i64* ptr, int delta) {
	u64 res = atomic_fetch_sub_u64(((voidptr)(ptr)), delta);
	bool _t1 = res == 0U;
	return _t1;
}

void sync__stdatomic__store_u64(u64* ptr, u64 val) {
	atomic_store_u64(((voidptr)(ptr)), val);
}

u64 sync__stdatomic__load_u64(u64* ptr) {
	u64 _t1 = atomic_load_u64(((voidptr)(ptr)));
	return _t1;
}

void sync__stdatomic__store_i64(i64* ptr, i64 val) {
	atomic_store_u64(((voidptr)(ptr)), val);
}

i64 sync__stdatomic__load_i64(i64* ptr) {
	i64 _t1 = ((i64)(atomic_load_u64(((voidptr)(ptr)))));
	return _t1;
}

Array_string os__args_after(string cut_word) {
	if (_const_os__args.len == 0) {
		Array_string _t1 = __new_array_with_default(0, 0, sizeof(string), 0);
		return _t1;
	}
	Array_string cargs = __new_array_with_default(0, 0, sizeof(string), 0);
	if (!Array_string_contains(_const_os__args, cut_word)) {
		cargs = array_clone_to_depth(&_const_os__args, 0);
	} else {
		bool found = false;
		array_push((array*)&cargs, _MOV((string[]){ string_clone((*(string*)/*ee elem_typ */array_get(_const_os__args, 0))) }));
		Array_string _t3 = array_slice(_const_os__args, 1, _const_os__args.len);
		for (int _t4 = 0; _t4 < _t3.len; ++_t4) {
			string a = ((string*)_t3.data)[_t4];
			if (string__eq(a, cut_word)) {
				found = true;
				continue;
			}
			if (!found) {
				continue;
			}
			array_push((array*)&cargs, _MOV((string[]){ string_clone(a) }));
		}
	}
	Array_string _t6 = cargs;
	return _t6;
}

Array_string os__args_before(string cut_word) {
	if (_const_os__args.len == 0) {
		Array_string _t1 = __new_array_with_default(0, 0, sizeof(string), 0);
		return _t1;
	}
	Array_string cargs = __new_array_with_default(0, 0, sizeof(string), 0);
	if (!Array_string_contains(_const_os__args, cut_word)) {
		cargs = array_clone_to_depth(&_const_os__args, 0);
	} else {
		array_push((array*)&cargs, _MOV((string[]){ string_clone((*(string*)/*ee elem_typ */array_get(_const_os__args, 0))) }));
		Array_string _t3 = array_slice(_const_os__args, 1, _const_os__args.len);
		for (int _t4 = 0; _t4 < _t3.len; ++_t4) {
			string a = ((string*)_t3.data)[_t4];
			if (string__eq(a, cut_word)) {
				break;
			}
			array_push((array*)&cargs, _MOV((string[]){ string_clone(a) }));
		}
	}
	Array_string _t6 = cargs;
	return _t6;
}

string os__getenv(string key) {
	Option_string _t2 = os__getenv_opt(key);
	if (_t2.state != 0) { /*or block*/ 
		IError err = _t2.err;
		*(string*) _t2.data = _SLIT("");
	}
	
 	string _t1 =  (*(string*)_t2.data);
	return _t1;
}

// Attr: [manualfree]
Option_string os__getenv_opt(string key) {
bool os__getenv_opt_defer_0 = false;
u16* kw;
	{ // Unsafe block
		#if defined(_WIN32)
		{
			kw = string_to_wide(key);
			os__getenv_opt_defer_0 = true;
			voidptr s = _wgetenv(kw);
			if (s == 0) {
				Option_string _t1 = (Option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
				// Defer begin
				if (os__getenv_opt_defer_0) {
					#if defined(_WIN32)
						_v_free(((voidptr)(kw)));
					
					#endif
				}
				// Defer end
				return _t1;
			}
			Option_string _t2;
			opt_ok(&(string[]) { string_from_wide(s) }, (Option*)(&_t2), sizeof(string));
			// Defer begin
			if (os__getenv_opt_defer_0) {
				#if defined(_WIN32)
					_v_free(((voidptr)(kw)));
				
				#endif
			}
			// Defer end
			return _t2;
		}
		#else
		{
		}
		#endif
	}
	return (Option_string){0};
}

int os__setenv(string name, string value, bool overwrite) {
	#if defined(_WIN32)
	{
		string format =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = name}}, {_SLIT("="), 0xfe10, {.d_s = value}}, {_SLIT0, 0, { .d_c = 0 }}}));
		if (overwrite) {
			{ // Unsafe block
				int _t1 = _putenv(((char*)(format.str)));
				return _t1;
			}
		} else {
			if (os__getenv(name).len == 0) {
				{ // Unsafe block
					int _t2 = _putenv(((char*)(format.str)));
					return _t2;
				}
			}
		}
		int _t3 = -1;
		return _t3;
	}
	#else
	{
	}
	#endif
	return 0;
}

int os__unsetenv(string name) {
	#if defined(_WIN32)
	{
		string format =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = name}}, {_SLIT("="), 0, { .d_c = 0 }}}));
		int _t1 = _putenv(((char*)(format.str)));
		return _t1;
	}
	#else
	{
	}
	#endif
	return 0;
}

VV_LOCAL_SYMBOL char** os__unix_environ(void) {
	char** _t1 = ((voidptr)(environ));
	return _t1;
}

Map_string_string os__environ(void) {
	Map_string_string res = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
	#if defined(_WIN32)
	{
		u16* estrings = GetEnvironmentStringsW();
		string eline = _SLIT("");
		for (u16* c = estrings; *c != 0U; ) {
			eline = string_from_wide(c);
			int eq_index = string_index_byte(eline, '=');
			if (eq_index > 0) {
				map_set(&res, &(string[]){string_substr(eline, 0, eq_index)}, &(string[]) { string_substr(eline, eq_index + 1, eline.len) });
			}
			{ // Unsafe block
				c = c + eline.len + 1;
			}
		}
		FreeEnvironmentStringsW(estrings);
	}
	#else
	{
	}
	#endif
	Map_string_string _t1 = res;
	return _t1;
}

int os__fd_close(int fd) {
	if (fd == -1) {
		int _t1 = 0;
		return _t1;
	}
	int _t2 = close(fd);
	return _t2;
}

void os__fd_write(int fd, string s) {
	if (fd == -1) {
		return;
	}
	byte* sp = s.str;
	int remaining = s.len;
	for (;;) {
		if (!(remaining > 0)) break;
		int written = write(fd, sp, remaining);
		if (written < 0) {
			return;
		}
		remaining = remaining - written;
		sp = sp + written;
	}
}

Array_string os__fd_slurp(int fd) {
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	if (fd == -1) {
		Array_string _t1 = res;
		return _t1;
	}
	for (;;) {
		multi_return_string_int mr_573 = os__fd_read(fd, 4096);
		string s = mr_573.arg0;
		int b = mr_573.arg1;
		if (b <= 0) {
			break;
		}
		array_push((array*)&res, _MOV((string[]){ string_clone(s) }));
	}
	Array_string _t3 = res;
	return _t3;
}

multi_return_string_int os__fd_read(int fd, int maxbytes) {
	if (fd == -1) {
		return (multi_return_string_int){.arg0=_SLIT(""), .arg1=0};
	}
	{ // Unsafe block
		byte* buf = malloc_noscan(maxbytes + 1);
		int nbytes = read(fd, buf, maxbytes);
		if (nbytes < 0) {
			_v_free(buf);
			return (multi_return_string_int){.arg0=_SLIT(""), .arg1=nbytes};
		}
		buf[nbytes] = 0;
		return (multi_return_string_int){.arg0=tos(buf, nbytes), .arg1=nbytes};
	}
	return (multi_return_string_int){0};
}

Option_os__File os__open_file(string path, string mode, Array_int options) {
	int flags = 0;
	for (int _t1 = 0; _t1 < mode.len; ++_t1) {
		byte m = mode.str[_t1];

		if (m == ('w')) {
			flags |= (_const_os__o_create | _const_os__o_trunc);
		}
		else if (m == ('a')) {
			flags |= (_const_os__o_create | _const_os__o_append);
		}
		else if (m == ('r')) {
			flags |= _const_os__o_rdonly;
		}
		else if (m == ('b')) {
			flags |= _const_os__o_binary;
		}
		else if (m == ('s')) {
			flags |= _const_os__o_sync;
		}
		else if (m == ('n')) {
			flags |= _const_os__o_nonblock;
		}
		else if (m == ('c')) {
			flags |= _const_os__o_noctty;
		}
		else if (m == ('+')) {
			flags |= _const_os__o_rdwr;
		}
		else {
		};
	}
	if (string__eq(mode, _SLIT("r+"))) {
		flags = _const_os__o_rdwr;
	}
	if (string__eq(mode, _SLIT("w"))) {
		flags = ((_const_os__o_wronly | _const_os__o_create) | _const_os__o_trunc);
	}
	if (string__eq(mode, _SLIT("a"))) {
		flags = ((_const_os__o_wronly | _const_os__o_create) | _const_os__o_append);
	}
	int permission = 0666;
	if (options.len > 0) {
		permission = (*(int*)/*ee elem_typ */array_get(options, 0));
	}
	if (permission < 0600) {
		permission = 0x0100;
	} else {
		permission = (0x0100 | 0x0080);
	}
	string p = path;
	p = string_replace(path, _SLIT("/"), _SLIT("\\"));
	int fd = open(((char*)(p.str)), flags, permission);
	if (fd == -1) {
		return (Option_os__File){ .state=2, .err=_v_error(os__posix_get_error_msg(errno)), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	FILE* cfile = fdopen(fd, ((char*)(mode.str)));
	if (isnil(cfile)) {
		return (Option_os__File){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Failed to open or create file \""), 0xfe10, {.d_s = path}}, {_SLIT("\""), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Option_os__File _t4;
	opt_ok(&(os__File[]) { (os__File){.cfile = cfile,.fd = fd,.is_opened = true,} }, (Option*)(&_t4), sizeof(os__File));
	return _t4;
}

Option_os__File os__open(string path) {
	Option_FILE_ptr _t1 = os__vfopen(path, _SLIT("rb"));
	if (_t1.state != 0) { /*or block*/ 
		Option_os__File _t2;
		memcpy(&_t2, &_t1, sizeof(Option));
		return _t2;
	}
	
 	FILE* cfile =  (*(FILE**)_t1.data);
	int fd = os__fileno(cfile);
	Option_os__File _t3;
	opt_ok(&(os__File[]) { (os__File){.cfile = cfile,.fd = fd,.is_opened = true,} }, (Option*)(&_t3), sizeof(os__File));
	return _t3;
}

Option_os__File os__create(string path) {
	Option_FILE_ptr _t1 = os__vfopen(path, _SLIT("wb"));
	if (_t1.state != 0) { /*or block*/ 
		Option_os__File _t2;
		memcpy(&_t2, &_t1, sizeof(Option));
		return _t2;
	}
	
 	FILE* cfile =  (*(FILE**)_t1.data);
	int fd = os__fileno(cfile);
	Option_os__File _t3;
	opt_ok(&(os__File[]) { (os__File){.cfile = cfile,.fd = fd,.is_opened = true,} }, (Option*)(&_t3), sizeof(os__File));
	return _t3;
}

os__File os__stdin(void) {
	os__File _t1 = (os__File){.cfile = stdin,.fd = 0,.is_opened = true,};
	return _t1;
}

os__File os__stdout(void) {
	os__File _t1 = (os__File){.cfile = stdout,.fd = 1,.is_opened = true,};
	return _t1;
}

os__File os__stderr(void) {
	os__File _t1 = (os__File){.cfile = stderr,.fd = 2,.is_opened = true,};
	return _t1;
}

Option_int os__File_read(os__File* f, Array_byte* buf) {
	if (buf->len == 0) {
		Option_int _t1;
		opt_ok(&(int[]) { 0 }, (Option*)(&_t1), sizeof(int));
		return _t1;
	}
	Option_int _t2 = os__fread(buf->data, 1, buf->len, f->cfile);
	if (_t2.state != 0) { /*or block*/ 
		Option_int _t3;
		memcpy(&_t3, &_t2, sizeof(Option));
		return _t3;
	}
	
 	int nbytes =  (*(int*)_t2.data);
	Option_int _t4;
	opt_ok(&(int[]) { nbytes }, (Option*)(&_t4), sizeof(int));
	return _t4;
}

Option_int os__File_write(os__File* f, Array_byte buf) {
	if (!f->is_opened) {
		return (Option_int){ .state=2, .err=os__error_file_not_opened(), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	int written = ((int)(fwrite(buf.data, 1, buf.len, f->cfile)));
	if (written == 0 && buf.len != 0) {
		return (Option_int){ .state=2, .err=_v_error(_SLIT("0 bytes written")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Option_int _t3;
	opt_ok(&(int[]) { written }, (Option*)(&_t3), sizeof(int));
	return _t3;
}

Option_int os__File_writeln(os__File* f, string s) {
	if (!f->is_opened) {
		return (Option_int){ .state=2, .err=os__error_file_not_opened(), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	int written = ((int)(fwrite(s.str, 1, s.len, f->cfile)));
	if (written == 0 && s.len != 0) {
		return (Option_int){ .state=2, .err=_v_error(_SLIT("0 bytes written")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	int x = fputs("\n", f->cfile);
	if (x < 0) {
		return (Option_int){ .state=2, .err=_v_error(_SLIT("could not add newline")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Option_int _t4;
	opt_ok(&(int[]) { written + 1 }, (Option*)(&_t4), sizeof(int));
	return _t4;
}

Option_int os__File_write_string(os__File* f, string s) {
		Option_void _t1 = os__File_write_full_buffer(f, s.str, ((usize)(s.len)));
	if (_t1.state != 0 && _t1.err._typ != _IError_None___index) {
		Option_int _t2;
		memcpy(&_t2, &_t1, sizeof(Option));
		return _t2;
	}
	
 ;
	Option_int _t3;
	opt_ok(&(int[]) { s.len }, (Option*)(&_t3), sizeof(int));
	return _t3;
}

Option_int os__File_write_to(os__File* f, u64 pos, Array_byte buf) {
	if (!f->is_opened) {
		return (Option_int){ .state=2, .err=os__error_file_not_opened(), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	#if defined(TARGET_IS_64BIT)
	{
		#if defined(_WIN32)
		{
			_fseeki64(f->cfile, pos, SEEK_SET);
			int res = ((int)(fwrite(buf.data, 1, buf.len, f->cfile)));
			if (res == 0 && buf.len != 0) {
				return (Option_int){ .state=2, .err=_v_error(_SLIT("0 bytes written")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			_fseeki64(f->cfile, 0U, SEEK_END);
			Option_int _t3;
			opt_ok(&(int[]) { res }, (Option*)(&_t3), sizeof(int));
			return _t3;
		}
		#else
		{
		}
		#endif
	}
	#endif
	#if defined(TARGET_IS_32BIT)
	{
		fseek(f->cfile, pos, SEEK_SET);
		int res = ((int)(fwrite(buf.data, 1, buf.len, f->cfile)));
		if (res == 0 && buf.len != 0) {
			return (Option_int){ .state=2, .err=_v_error(_SLIT("0 bytes written")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		fseek(f->cfile, 0, SEEK_END);
		Option_int _t5;
		opt_ok(&(int[]) { res }, (Option*)(&_t5), sizeof(int));
		return _t5;
	}
	#endif
	return (Option_int){ .state=2, .err=_v_error(_SLIT("Could not write to file")), .data={EMPTY_STRUCT_INITIALIZATION} };
}

// Attr: [unsafe]
int os__File_write_ptr(os__File* f, voidptr data, int size) {
	int _t1 = ((int)(fwrite(data, 1, size, f->cfile)));
	return _t1;
}

// Attr: [unsafe]
Option_void os__File_write_full_buffer(os__File* f, voidptr buffer, usize buffer_len) {
	if (buffer_len <= ((usize)(0))) {
		return (Option_void){0};
	}
	if (!f->is_opened) {
		return (Option_void){ .state=2, .err=os__error_file_not_opened(), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	byte* ptr = ((byte*)(buffer));
	i64 remaining_bytes = ((i64)(buffer_len));
	for (;;) {
		if (!(remaining_bytes > 0)) break;
		{ // Unsafe block
			i64 x = ((i64)(fwrite(ptr, 1, remaining_bytes, f->cfile)));
			ptr += x;
			remaining_bytes -= x;
			if (x <= 0) {
				return (Option_void){ .state=2, .err=_v_error(_SLIT("C.fwrite returned 0")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
		}
	}
	return (Option_void){0};
}

// Attr: [unsafe]
int os__File_write_ptr_at(os__File* f, voidptr data, int size, u64 pos) {
	#if defined(TARGET_IS_64BIT)
	{
		#if defined(_WIN32)
		{
			_fseeki64(f->cfile, pos, SEEK_SET);
			int res = ((int)(fwrite(data, 1, size, f->cfile)));
			_fseeki64(f->cfile, 0U, SEEK_END);
			int _t1 = res;
			return _t1;
		}
		#else
		{
		}
		#endif
	}
	#endif
	#if defined(TARGET_IS_32BIT)
	{
		fseek(f->cfile, pos, SEEK_SET);
		int res = ((int)(fwrite(data, 1, size, f->cfile)));
		fseek(f->cfile, 0, SEEK_END);
		int _t2 = res;
		return _t2;
	}
	#endif
	int _t3 = 0;
	return _t3;
}

VV_LOCAL_SYMBOL Option_int os__fread(voidptr ptr, int item_size, int items, FILE* stream) {
	int nbytes = ((int)(fread(ptr, item_size, items, stream)));
	if (nbytes <= 0) {
		if (feof(stream) != 0) {
			return (Option_int){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		if (ferror(stream) != 0) {
			return (Option_int){ .state=2, .err=_v_error(_SLIT("file read error")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	Option_int _t3;
	opt_ok(&(int[]) { nbytes }, (Option*)(&_t3), sizeof(int));
	return _t3;
}

Array_byte os__File_read_bytes(os__File* f, int size) {
	Array_byte _t1 = os__File_read_bytes_at(f, size, 0U);
	return _t1;
}

Array_byte os__File_read_bytes_at(os__File* f, int size, u64 pos) {
	Array_byte arr = __new_array_with_default(size, 0, sizeof(byte), 0);
	Option_int _t1 = os__File_read_bytes_into(f, pos, &/*arr*/arr);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		Array_byte _t2 = __new_array_with_default(0, 0, sizeof(byte), 0);
		return _t2;
	}
	
 	int nreadbytes =  (*(int*)_t1.data);
	Array_byte _t3 = array_slice(arr, 0, nreadbytes);
	return _t3;
}

Option_int os__File_read_bytes_into_newline(os__File* f, Array_byte* buf) {
	if (buf->len == 0) {
		return (Option_int){ .state=2, .err=_v_error(string__plus(_SLIT("read_bytes_into_newline"), _SLIT(": `buf.len` == 0"))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	int newline = 10;
	int c = 0;
	int buf_ptr = 0;
	int nbytes = 0;
	FILE* stream = ((FILE*)(f->cfile));
	for (;;) {
		if (!((buf_ptr < buf->len))) break;
		c = getc(stream);

		if (c == (EOF)) {
			if (feof(stream) != 0) {
				Option_int _t2;
				opt_ok(&(int[]) { nbytes }, (Option*)(&_t2), sizeof(int));
				return _t2;
			}
			if (ferror(stream) != 0) {
				return (Option_int){ .state=2, .err=_v_error(_SLIT("file read error")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
		}
		else if (c == (newline)) {
			array_set(buf, buf_ptr, &(byte[]) { ((byte)(c)) });
			nbytes++;
			Option_int _t4;
			opt_ok(&(int[]) { nbytes }, (Option*)(&_t4), sizeof(int));
			return _t4;
		}
		else {
			array_set(buf, buf_ptr, &(byte[]) { ((byte)(c)) });
			buf_ptr++;
			nbytes++;
		};
	}
	Option_int _t5;
	opt_ok(&(int[]) { nbytes }, (Option*)(&_t5), sizeof(int));
	return _t5;
}

Option_int os__File_read_bytes_into(os__File* f, u64 pos, Array_byte* buf) {
	if (buf->len == 0) {
		return (Option_int){ .state=2, .err=_v_error(string__plus(_SLIT("read_bytes_into"), _SLIT(": `buf.len` == 0"))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	#if defined(TARGET_IS_64BIT)
	{
		#if defined(_WIN32)
		{
			_fseeki64(f->cfile, pos, SEEK_SET);
			Option_int _t2 = os__fread(buf->data, 1, buf->len, f->cfile);
			if (_t2.state != 0) { /*or block*/ 
				Option_int _t3;
				memcpy(&_t3, &_t2, sizeof(Option));
				return _t3;
			}
			
 			int nbytes =  (*(int*)_t2.data);
			Option_int _t4;
			opt_ok(&(int[]) { nbytes }, (Option*)(&_t4), sizeof(int));
			return _t4;
		}
		#else
		{
		}
		#endif
	}
	#endif
	#if defined(TARGET_IS_32BIT)
	{
		fseek(f->cfile, pos, SEEK_SET);
		Option_int _t5 = os__fread(buf->data, 1, buf->len, f->cfile);
		if (_t5.state != 0) { /*or block*/ 
			Option_int _t6;
			memcpy(&_t6, &_t5, sizeof(Option));
			return _t6;
		}
		
 		int nbytes =  (*(int*)_t5.data);
		Option_int _t7;
		opt_ok(&(int[]) { nbytes }, (Option*)(&_t7), sizeof(int));
		return _t7;
	}
	#endif
	return (Option_int){ .state=2, .err=_v_error(_SLIT("Could not read file")), .data={EMPTY_STRUCT_INITIALIZATION} };
}

Option_int os__File_read_from(os__File* f, u64 pos, Array_byte* buf) {
	if (buf->len == 0) {
		Option_int _t1;
		opt_ok(&(int[]) { 0 }, (Option*)(&_t1), sizeof(int));
		return _t1;
	}
	#if defined(TARGET_IS_64BIT)
	{
		#if defined(_WIN32)
		{
			_fseeki64(f->cfile, pos, SEEK_SET);
		}
		#else
		{
		}
		#endif
		Option_int _t2 = os__fread(buf->data, 1, buf->len, f->cfile);
		if (_t2.state != 0) { /*or block*/ 
			Option_int _t3;
			memcpy(&_t3, &_t2, sizeof(Option));
			return _t3;
		}
		
 		int nbytes =  (*(int*)_t2.data);
		Option_int _t4;
		opt_ok(&(int[]) { nbytes }, (Option*)(&_t4), sizeof(int));
		return _t4;
	}
	#endif
	#if defined(TARGET_IS_32BIT)
	{
		fseek(f->cfile, pos, SEEK_SET);
		Option_int _t5 = os__fread(buf->data, 1, buf->len, f->cfile);
		if (_t5.state != 0) { /*or block*/ 
			Option_int _t6;
			memcpy(&_t6, &_t5, sizeof(Option));
			return _t6;
		}
		
 		int nbytes =  (*(int*)_t5.data);
		Option_int _t7;
		opt_ok(&(int[]) { nbytes }, (Option*)(&_t7), sizeof(int));
		return _t7;
	}
	#endif
	return (Option_int){ .state=2, .err=_v_error(_SLIT("Could not read file")), .data={EMPTY_STRUCT_INITIALIZATION} };
}

Option_int os__File_read_into_ptr(os__File* f, byte* ptr, int max_size) {
	Option_int _t1 = os__fread(ptr, 1, max_size, f->cfile);
	return _t1;
}

void os__File_flush(os__File* f) {
	if (!f->is_opened) {
		return;
	}
	fflush(f->cfile);
}

VV_LOCAL_SYMBOL IError os__error_file_not_opened(void) {
	IError _t1 = /*&IError*/I_os__ErrFileNotOpened_to_Interface_IError((os__ErrFileNotOpened*)memdup(&(os__ErrFileNotOpened){.msg = _SLIT("os: file not opened"),.code = 0,}, sizeof(os__ErrFileNotOpened)));
	return _t1;
}

VV_LOCAL_SYMBOL IError os__error_size_of_type_0(void) {
	IError _t1 = /*&IError*/I_os__ErrSizeOfTypeIs0_to_Interface_IError((os__ErrSizeOfTypeIs0*)memdup(&(os__ErrSizeOfTypeIs0){.msg = _SLIT("os: size of type is 0"),.code = 0,}, sizeof(os__ErrSizeOfTypeIs0)));
	return _t1;
}

Option_void os__File_seek(os__File* f, i64 pos, os__SeekMode mode) {
	if (!f->is_opened) {
		return (Option_void){ .state=2, .err=os__error_file_not_opened(), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	int whence = ((int)(mode));
	int res = 0;
	#if defined(TARGET_IS_64BIT)
	{
		#if defined(_WIN32)
		{
			res = _fseeki64(f->cfile, pos, whence);
		}
		#else
		{
		}
		#endif
	}
	#endif
	#if defined(TARGET_IS_32BIT)
	{
		res = fseek(f->cfile, pos, whence);
	}
	#endif
	if (res == -1) {
		return (Option_void){ .state=2, .err=_v_error(os__posix_get_error_msg(errno)), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (Option_void){0};
}

Option_i64 os__File_tell(os__File* f) {
	if (!f->is_opened) {
		return (Option_i64){ .state=2, .err=os__error_file_not_opened(), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	i64 pos = ftell(f->cfile);
	if (pos == -1) {
		return (Option_i64){ .state=2, .err=_v_error(os__posix_get_error_msg(errno)), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Option_i64 _t3;
	opt_ok(&(i64[]) { pos }, (Option*)(&_t3), sizeof(i64));
	return _t3;
}

os__FileMode os__inode(string path) {
	struct stat attr;
	stat(((char*)(path.str)), &attr);
	os__FileType typ = os__FileType__regular;
	if ((attr.st_mode & ((u32)(S_IFMT))) == ((u32)(S_IFDIR))) {
		typ = os__FileType__directory;
	}
	#if defined(_WIN32)
	{
		os__FileMode _t1 = (os__FileMode){.typ = typ,.owner = (os__FilePermission){.read = ((attr.st_mode & ((u32)(S_IREAD)))) != 0U,.write = ((attr.st_mode & ((u32)(S_IWRITE)))) != 0U,.execute = ((attr.st_mode & ((u32)(S_IEXEC)))) != 0U,},.group = (os__FilePermission){.read = ((attr.st_mode & ((u32)(S_IREAD)))) != 0U,.write = ((attr.st_mode & ((u32)(S_IWRITE)))) != 0U,.execute = ((attr.st_mode & ((u32)(S_IEXEC)))) != 0U,},.others = (os__FilePermission){.read = ((attr.st_mode & ((u32)(S_IREAD)))) != 0U,.write = ((attr.st_mode & ((u32)(S_IWRITE)))) != 0U,.execute = ((attr.st_mode & ((u32)(S_IEXEC)))) != 0U,},};
		return _t1;
	}
	#else
	{
	}
	#endif
	return (os__FileMode){.owner = (os__FilePermission){.read = 0,.write = 0,.execute = 0,},.group = (os__FilePermission){.read = 0,.write = 0,.execute = 0,},.others = (os__FilePermission){.read = 0,.write = 0,.execute = 0,},};
}

// TypeDecl
Option_void os__open_uri(string uri) {
	string vopen_uri_cmd = os__getenv(_SLIT("VOPEN_URI_CMD"));
	if ((vopen_uri_cmd).len != 0) {
		os__Result result = os__execute( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = vopen_uri_cmd}}, {_SLIT(" \""), 0xfe10, {.d_s = uri}}, {_SLIT("\""), 0, { .d_c = 0 }}})));
		if (result.exit_code != 0) {
			return (Option_void){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("unable to open url: "), 0xfe10, {.d_s = result.output}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		return (Option_void){0};
	}
	Option_voidptr _t2 = dl__open_opt(_SLIT("shell32"), _const_dl__rtld_now);
	if (_t2.state != 0) { /*or block*/ 
		Option_void _t3;
		memcpy(&_t3, &_t2, sizeof(Option));
		return _t3;
	}
	
 	voidptr handle =  (*(voidptr*)_t2.data);
	Option_voidptr _t4 = dl__sym_opt(handle, _SLIT("ShellExecuteW"));
	if (_t4.state != 0) { /*or block*/ 
		Option_void _t5;
		memcpy(&_t5, &_t4, sizeof(Option));
		return _t5;
	}
	
 	void (*func) (voidptr , u16* , u16* , u16* , u16* , int ) = ((os__ShellExecuteWin)( (*(voidptr*)_t4.data)));
	func(NULL, string_to_wide(_SLIT("open")), string_to_wide(uri), NULL, NULL, SW_SHOWNORMAL);
	dl__close(handle);
	return (Option_void){0};
}

// Attr: [manualfree]
Option_Array_byte os__read_bytes(string path) {
bool os__read_bytes_defer_0 = false;
FILE* fp;
	Option_FILE_ptr _t1 = os__vfopen(path, _SLIT("rb"));
	if (_t1.state != 0) { /*or block*/ 
		Option_Array_byte _t2;
		memcpy(&_t2, &_t1, sizeof(Option));
		return _t2;
	}
	
 	fp =  (*(FILE**)_t1.data);
	os__read_bytes_defer_0 = true;
	int cseek = fseek(fp, 0, SEEK_END);
	if (cseek != 0) {
		Option_Array_byte _t3 = (Option_Array_byte){ .state=2, .err=_v_error(_SLIT("fseek failed")), .data={EMPTY_STRUCT_INITIALIZATION} };
		// Defer begin
		if (os__read_bytes_defer_0) {
			fclose(fp);
		}
		// Defer end
		return _t3;
	}
	i64 fsize = ftell(fp);
	if (fsize < 0) {
		Option_Array_byte _t4 = (Option_Array_byte){ .state=2, .err=_v_error(_SLIT("ftell failed")), .data={EMPTY_STRUCT_INITIALIZATION} };
		// Defer begin
		if (os__read_bytes_defer_0) {
			fclose(fp);
		}
		// Defer end
		return _t4;
	}
	int len = ((int)(fsize));
	if (((i64)(len)) < fsize) {
		Option_Array_byte _t5 = (Option_Array_byte){ .state=2, .err=_v_error( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe09, {.d_i64 = fsize}}, {_SLIT(" cast to int results in "), 0xfe07, {.d_i32 = ((int)(fsize))}}, {_SLIT(")"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		// Defer begin
		if (os__read_bytes_defer_0) {
			fclose(fp);
		}
		// Defer end
		return _t5;
	}
	rewind(fp);
	Array_byte res = __new_array_with_default(len, 0, sizeof(byte), 0);
	int nr_read_elements = ((int)(fread(res.data, len, 1, fp)));
	if (nr_read_elements == 0 && fsize > 0) {
		Option_Array_byte _t6 = (Option_Array_byte){ .state=2, .err=_v_error(_SLIT("fread failed")), .data={EMPTY_STRUCT_INITIALIZATION} };
		// Defer begin
		if (os__read_bytes_defer_0) {
			fclose(fp);
		}
		// Defer end
		return _t6;
	}
	array_trim(&res, nr_read_elements * len);
	Option_Array_byte _t7;
	opt_ok(&(Array_byte[]) { res }, (Option*)(&_t7), sizeof(Array_byte));
	// Defer begin
	if (os__read_bytes_defer_0) {
		fclose(fp);
	}
	// Defer end
	return _t7;
}

Option_string os__read_file(string path) {
bool os__read_file_defer_0 = false;
FILE* fp;
	string mode = _SLIT("rb");
	Option_FILE_ptr _t1 = os__vfopen(path, mode);
	if (_t1.state != 0) { /*or block*/ 
		Option_string _t2;
		memcpy(&_t2, &_t1, sizeof(Option));
		return _t2;
	}
	
 	fp =  (*(FILE**)_t1.data);
	os__read_file_defer_0 = true;
	int cseek = fseek(fp, 0, SEEK_END);
	if (cseek != 0) {
		Option_string _t3 = (Option_string){ .state=2, .err=_v_error(_SLIT("fseek failed")), .data={EMPTY_STRUCT_INITIALIZATION} };
		// Defer begin
		if (os__read_file_defer_0) {
			fclose(fp);
		}
		// Defer end
		return _t3;
	}
	i64 fsize = ftell(fp);
	if (fsize < 0) {
		Option_string _t4 = (Option_string){ .state=2, .err=_v_error(_SLIT("ftell failed")), .data={EMPTY_STRUCT_INITIALIZATION} };
		// Defer begin
		if (os__read_file_defer_0) {
			fclose(fp);
		}
		// Defer end
		return _t4;
	}
	rewind(fp);
	int allocate = ((int)(fsize));
	if (((i64)(allocate)) < fsize) {
		Option_string _t5 = (Option_string){ .state=2, .err=_v_error( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe09, {.d_i64 = fsize}}, {_SLIT(" cast to int results in "), 0xfe07, {.d_i32 = ((int)(fsize))}}, {_SLIT(")"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		// Defer begin
		if (os__read_file_defer_0) {
			fclose(fp);
		}
		// Defer end
		return _t5;
	}
	{ // Unsafe block
		byte* str = malloc_noscan(allocate + 1);
		int nelements = ((int)(fread(str, 1, allocate, fp)));
		int is_eof = ((int)(feof(fp)));
		int is_error = ((int)(ferror(fp)));
		if (is_eof == 0 && is_error != 0) {
			_v_free(str);
			Option_string _t6 = (Option_string){ .state=2, .err=_v_error(_SLIT("fread failed")), .data={EMPTY_STRUCT_INITIALIZATION} };
			// Defer begin
			if (os__read_file_defer_0) {
				fclose(fp);
			}
			// Defer end
			return _t6;
		}
		str[nelements] = 0;
		if (nelements == 0) {
			Option_string _t7;
			opt_ok(&(string[]) { byte_vstring(str) }, (Option*)(&_t7), sizeof(string));
			// Defer begin
			if (os__read_file_defer_0) {
				fclose(fp);
			}
			// Defer end
			return _t7;
		}
		Option_string _t8;
		opt_ok(&(string[]) { byte_vstring_with_len(str, nelements) }, (Option*)(&_t8), sizeof(string));
		// Defer begin
		if (os__read_file_defer_0) {
			fclose(fp);
		}
		// Defer end
		return _t8;
	}
	return (Option_string){0};
}

Option_void os__truncate(string path, u64 len) {
bool os__truncate_defer_0 = false;
int fp;
	fp = open(((char*)(path.str)), (_const_os__o_wronly | _const_os__o_trunc), 0);
	os__truncate_defer_0 = true;
	if (fp < 0) {
		Option_void _t1 = (Option_void){ .state=2, .err=error_with_code(os__posix_get_error_msg(errno), errno), .data={EMPTY_STRUCT_INITIALIZATION} };
		// Defer begin
		if (os__truncate_defer_0) {
			close(fp);
		}
		// Defer end
		return _t1;
	}
	#if defined(_WIN32)
	{
		if (_chsize_s(fp, len) != 0) {
			Option_void _t2 = (Option_void){ .state=2, .err=error_with_code(os__posix_get_error_msg(errno), errno), .data={EMPTY_STRUCT_INITIALIZATION} };
			// Defer begin
			if (os__truncate_defer_0) {
				close(fp);
			}
			// Defer end
			return _t2;
		}
	}
	#else
	{
	}
	#endif
	// Defer begin
	if (os__truncate_defer_0) {
		close(fp);
	}
	// Defer end
	return (Option_void){0};
}

VV_LOCAL_SYMBOL void os__eprintln_unknown_file_size(void) {
	eprintln(string__plus(_SLIT("os.file_size() Cannot determine file-size: "), os__posix_get_error_msg(errno)));
}

u64 os__file_size(string path) {
	struct stat s;
	{ // Unsafe block
		#if defined(TARGET_IS_64BIT)
		{
			#if defined(_WIN32)
			{
				struct __stat64 swin = (struct __stat64){.st_size = 0,.st_mode = 0,.st_mtime = 0,};
				if (_wstat64(string_to_wide(path), ((voidptr)(&swin))) != 0U) {
					os__eprintln_unknown_file_size();
					u64 _t1 = 0U;
					return _t1;
				}
				u64 _t2 = swin.st_size;
				return _t2;
			}
			#else
			{
			}
			#endif
		}
		#endif
		#if defined(TARGET_IS_32BIT)
		{
			#if defined(_WIN32)
			{
				if (_wstat(string_to_wide(path), ((voidptr)(&s))) != 0) {
					os__eprintln_unknown_file_size();
					u64 _t3 = 0U;
					return _t3;
				}
				u64 _t4 = ((u64)(s.st_size));
				return _t4;
			}
			#else
			{
			}
			#endif
		}
		#endif
	}
	u64 _t5 = 0U;
	return _t5;
}

Option_void os__mv(string src, string dst) {
	string rdst = dst;
	if (os__is_dir(rdst)) {
		rdst = os__join_path_single(string_trim_right(rdst, _const_os__path_separator), os__file_name(string_trim_right(src, _const_os__path_separator)));
	}
	#if defined(_WIN32)
	{
		string w_src = string_replace(src, _SLIT("/"), _SLIT("\\"));
		string w_dst = string_replace(rdst, _SLIT("/"), _SLIT("\\"));
		int ret = _wrename(string_to_wide(w_src), string_to_wide(w_dst));
		if (ret != 0) {
			return (Option_void){ .state=2, .err=error_with_code( str_intp(3, _MOV((StrIntpData[]){{_SLIT("failed to rename "), 0xfe10, {.d_s = src}}, {_SLIT(" to "), 0xfe10, {.d_s = dst}}, {_SLIT0, 0, { .d_c = 0 }}})), ((int)(ret))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	#else
	{
	}
	#endif
	return (Option_void){0};
}

Option_void os__cp(string src, string dst) {
	#if defined(_WIN32)
	{
		string w_src = string_replace(src, _SLIT("/"), _SLIT("\\"));
		string w_dst = string_replace(dst, _SLIT("/"), _SLIT("\\"));
		if (CopyFile(string_to_wide(w_src), string_to_wide(w_dst), false) == 0) {
			u32 result = GetLastError();
			return (Option_void){ .state=2, .err=error_with_code( str_intp(3, _MOV((StrIntpData[]){{_SLIT("failed to copy "), 0xfe10, {.d_s = src}}, {_SLIT(" to "), 0xfe10, {.d_s = dst}}, {_SLIT0, 0, { .d_c = 0 }}})), ((int)(result))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	#else
	{
	}
	#endif
	return (Option_void){0};
}

Option_FILE_ptr os__vfopen(string path, string mode) {
	if (path.len == 0) {
		return (Option_FILE_ptr){ .state=2, .err=_v_error(_SLIT("vfopen called with \"\"")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	voidptr fp = ((voidptr)(0));
	#if defined(_WIN32)
	{
		fp = _wfopen(string_to_wide(path), string_to_wide(mode));
	}
	#else
	{
	}
	#endif
	if (isnil(fp)) {
		return (Option_FILE_ptr){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("failed to open file \""), 0xfe10, {.d_s = path}}, {_SLIT("\""), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	} else {
		Option_FILE_ptr _t3;
		opt_ok(&(FILE*[]) { fp }, (Option*)(&_t3), sizeof(FILE*));
		return _t3;
	}
	return (Option_FILE_ptr){0};
}

int os__fileno(voidptr cfile) {
	#if defined(_WIN32)
	{
		int _t1 = _fileno(cfile);
		return _t1;
	}
	#else
	{
	}
	#endif
	return 0;
}

VV_LOCAL_SYMBOL voidptr os__vpopen(string path) {
	#if defined(_WIN32)
	{
		string mode = _SLIT("rb");
		u16* wpath = string_to_wide(path);
		voidptr _t1 = _wpopen(wpath, string_to_wide(mode));
		return _t1;
	}
	#else
	{
	}
	#endif
	return 0;
}

VV_LOCAL_SYMBOL multi_return_int_bool os__posix_wait4_to_exit_status(int waitret) {
	#if defined(_WIN32)
	{
		return (multi_return_int_bool){.arg0=waitret, .arg1=false};
	}
	#else
	{
	}
	#endif
	return (multi_return_int_bool){0};
}

string os__posix_get_error_msg(int code) {
	char* ptr_text = strerror(code);
	if (ptr_text == 0) {
		string _t1 = _SLIT("");
		return _t1;
	}
	string _t2 = tos3(ptr_text);
	return _t2;
}

VV_LOCAL_SYMBOL int os__vpclose(voidptr f) {
	#if defined(_WIN32)
	{
		int _t1 = _pclose(f);
		return _t1;
	}
	#else
	{
	}
	#endif
	return 0;
}

int os__system(string cmd) {
	int ret = 0;
	#if defined(_WIN32)
	{
		string wcmd = (cmd.len > 1 && string_at(cmd, 0) == '"' && string_at(cmd, 1) != '"' ? ( str_intp(2, _MOV((StrIntpData[]){{_SLIT("\""), 0xfe10, {.d_s = cmd}}, {_SLIT("\""), 0, { .d_c = 0 }}}))) : (cmd));
		{ // Unsafe block
			ret = _wsystem(string_to_wide(wcmd));
		}
	}
	#else
	{
	}
	#endif
	if (ret == -1) {
		os__print_c_errno();
	}
	int _t1 = ret;
	return _t1;
}

bool os__exists(string path) {
	#if defined(_WIN32)
	{
		string p = string_replace(path, _SLIT("/"), _SLIT("\\"));
		bool _t1 = _waccess(string_to_wide(p), _const_os__f_ok) != -1;
		return _t1;
	}
	#else
	{
	}
	#endif
	return 0;
}

bool os__is_executable(string path) {
	string p = os__real_path(path);
	bool _t1 = os__exists(p) && string_ends_with(p, _SLIT(".exe"));
	return _t1;
	bool _t2 = access(((char*)(path.str)), _const_os__x_ok) != -1;
	return _t2;
}

// Attr: [manualfree]
bool os__is_writable(string path) {
	#if defined(_WIN32)
	{
		string p = string_replace(path, _SLIT("/"), _SLIT("\\"));
		u16* wp = string_to_wide(p);
		bool res = _waccess(wp, _const_os__w_ok) != -1;
		_v_free(wp);
		string_free(&p);
		bool _t1 = res;
		return _t1;
	}
	#else
	{
	}
	#endif
	return 0;
}

// Attr: [manualfree]
bool os__is_readable(string path) {
	#if defined(_WIN32)
	{
		string p = string_replace(path, _SLIT("/"), _SLIT("\\"));
		u16* wp = string_to_wide(p);
		bool res = _waccess(wp, _const_os__r_ok) != -1;
		_v_free(wp);
		string_free(&p);
		bool _t1 = res;
		return _t1;
	}
	#else
	{
	}
	#endif
	return 0;
}

Option_void os__rm(string path) {
	int rc = 0;
	#if defined(_WIN32)
	{
		rc = _wremove(string_to_wide(path));
	}
	#else
	{
	}
	#endif
	if (rc == -1) {
		return (Option_void){ .state=2, .err=_v_error(string__plus( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Failed to remove \""), 0xfe10, {.d_s = path}}, {_SLIT("\": "), 0, { .d_c = 0 }}})), os__posix_get_error_msg(errno))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (Option_void){0};
}

Option_void os__rmdir(string path) {
	#if defined(_WIN32)
	{
		int rc = RemoveDirectory(string_to_wide(path));
		if (rc == 0) {
			return (Option_void){ .state=2, .err=_v_error(string__plus( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Failed to remove \""), 0xfe10, {.d_s = path}}, {_SLIT("\": "), 0, { .d_c = 0 }}})), os__posix_get_error_msg(errno))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	#else
	{
	}
	#endif
	return (Option_void){0};
}

VV_LOCAL_SYMBOL void os__print_c_errno(void) {
	int e = errno;
	string se = tos_clone(((byte*)(strerror(e))));
	println( str_intp(3, _MOV((StrIntpData[]){{_SLIT("errno="), 0xfe07, {.d_i32 = e}}, {_SLIT(" err="), 0xfe10, {.d_s = se}}, {_SLIT0, 0, { .d_c = 0 }}})));
}

string os__get_raw_line(void) {
	#if defined(_WIN32)
	{
		{ // Unsafe block
			int max_line_chars = 256;
			byte* buf = malloc_noscan(max_line_chars * 2);
			voidptr h_input = GetStdHandle(STD_INPUT_HANDLE);
			u32 bytes_read = ((u32)(0U));
			if (os__is_atty(0) > 0) {
				bool x = ReadConsole(h_input, buf, max_line_chars * 2, &bytes_read, 0);
				if (!x) {
					string _t1 = tos(buf, 0);
					return _t1;
				}
				string _t2 = string_from_wide2(((u16*)(buf)), ((int)(bytes_read)));
				return _t2;
			}
			int offset = 0;
			for (;;) {
				byte* pos = buf + offset;
				bool res = ReadFile(h_input, pos, 1U, ((LPDWORD)(&bytes_read)), 0);
				if (!res && offset == 0) {
					string _t3 = tos(buf, 0);
					return _t3;
				}
				if (!res || bytes_read == 0U) {
					break;
				}
				if (*pos == '\n' || *pos == '\r') {
					offset++;
					break;
				}
				offset++;
			}
			string _t4 = byte_vstring_with_len(buf, offset);
			return _t4;
		}
	}
	#else
	{
	}
	#endif
	return (string){.str=(byteptr)"", .is_lit=1};
}

Array_byte os__get_raw_stdin(void) {
	#if defined(_WIN32)
	{
		{ // Unsafe block
			int block_bytes = 512;
			int old_size = block_bytes;
			byte* buf = malloc_noscan(block_bytes);
			voidptr h_input = GetStdHandle(STD_INPUT_HANDLE);
			int bytes_read = 0;
			int offset = 0;
			for (;;) {
				byte* pos = buf + offset;
				bool res = ReadFile(h_input, pos, block_bytes, ((LPDWORD)(&bytes_read)), 0);
				offset += bytes_read;
				if (!res) {
					break;
				}
				int new_size = offset + block_bytes + (block_bytes - bytes_read);
				buf = realloc_data(buf, old_size, new_size);
				old_size = new_size;
			}
			Array_byte _t1 = (array){.element_size = 1,.data = ((voidptr)(buf)),.offset = 0,.len = offset,.cap = offset,.flags = 0,};
			return _t1;
		}
	}
	#else
	{
	}
	#endif
	return __new_array(0, 0, sizeof(byte));
}

void os__on_segfault(voidptr f) {
	return;
}

// Attr: [manualfree]
string os__executable(void) {
bool os__executable_defer_0 = false;
byte* result;
bool os__executable_defer_1 = false;
voidptr file;
bool os__executable_defer_2 = false;
byte* final_path;
bool os__executable_defer_3 = false;
string sret;
	int size = os__max_path_bufffer_size();
	result = vcalloc_noscan(size);
	os__executable_defer_0 = true;
	u16* pu16_result = ((u16*)(result));
	int len = GetModuleFileName(0, pu16_result, 512U);
	u32 attrs = GetFileAttributesW(pu16_result);
	u32 is_set = (attrs & 0x400U);
	if (is_set != 0U) {
		file = CreateFile(pu16_result, 0x80000000U, 1U, 0, 3U, 0x80U, 0);
		if (file != ((voidptr)(-1))) {
			os__executable_defer_1 = true;
			final_path = vcalloc_noscan(size);
			os__executable_defer_2 = true;
			int final_len = GetFinalPathNameByHandleW(file, ((u16*)(final_path)), size, 0U);
			if (final_len < size) {
				sret = string_from_wide2(((u16*)(final_path)), final_len);
				os__executable_defer_3 = true;
				string sret_slice = string_substr(sret, 4, sret.len);
				string res = string_clone(sret_slice);
				string _t1 = res;
				// Defer begin
				if (os__executable_defer_3) {
					string_free(&sret);
				}
				// Defer end
				// Defer begin
				if (os__executable_defer_2) {
					_v_free(final_path);
				}
				// Defer end
				// Defer begin
				if (os__executable_defer_1) {
					CloseHandle(file);
				}
				// Defer end
				// Defer begin
				if (os__executable_defer_0) {
					_v_free(result);
				}
				// Defer end
				return _t1;
			} else {
				eprintln(_SLIT("os.executable() saw that the executable file path was too long"));
			}
		}
	}
	string res = string_from_wide2(pu16_result, len);
	string _t2 = res;
	// Defer begin
	if (os__executable_defer_3) {
		string_free(&sret);
	}
	// Defer end
	// Defer begin
	if (os__executable_defer_2) {
		_v_free(final_path);
	}
	// Defer end
	// Defer begin
	if (os__executable_defer_1) {
		CloseHandle(file);
	}
	// Defer end
	// Defer begin
	if (os__executable_defer_0) {
		_v_free(result);
	}
	// Defer end
	return _t2;
	string _t3 = os__executable_fallback();
	// Defer begin
	if (os__executable_defer_3) {
		string_free(&sret);
	}
	// Defer end
	// Defer begin
	if (os__executable_defer_2) {
		_v_free(final_path);
	}
	// Defer end
	// Defer begin
	if (os__executable_defer_1) {
		CloseHandle(file);
	}
	// Defer end
	// Defer begin
	if (os__executable_defer_0) {
		_v_free(result);
	}
	// Defer end
	return _t3;
}

bool os__is_dir(string path) {
	#if defined(_WIN32)
	{
		string w_path = string_replace(path, _SLIT("/"), _SLIT("\\"));
		u32 attr = GetFileAttributesW(string_to_wide(w_path));
		if (attr == ((u32)(INVALID_FILE_ATTRIBUTES))) {
			bool _t1 = false;
			return _t1;
		}
		if ((((int)(attr)) & FILE_ATTRIBUTE_DIRECTORY) != 0) {
			bool _t2 = true;
			return _t2;
		}
		bool _t3 = false;
		return _t3;
	}
	#else
	{
	}
	#endif
	return 0;
}

bool os__is_link(string path) {
	#if defined(_WIN32)
	{
		string path_ = string_replace(path, _SLIT("/"), _SLIT("\\"));
		u32 attr = GetFileAttributesW(string_to_wide(path_));
		bool _t1 = ((int)(attr)) != ((int)(INVALID_FILE_ATTRIBUTES)) && ((attr & 0x400U)) != 0U;
		return _t1;
	}
	#else
	{
	}
	#endif
	return 0;
}

Option_void os__chdir(string path) {
	#if defined(_WIN32)
	int ret = _wchdir(string_to_wide(path));
	#else
	#endif
	;
	if (ret == -1) {
		return (Option_void){ .state=2, .err=error_with_code(os__posix_get_error_msg(errno), errno), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (Option_void){0};
}

VV_LOCAL_SYMBOL int os__max_path_bufffer_size(void) {
	int size = _const_os__max_path_len;
	size *= 2;
	int _t1 = size;
	return _t1;
}

// Attr: [manualfree]
string os__getwd(void) {
bool os__getwd_defer_0 = false;
byte* buf;
	{ // Unsafe block
		buf = vcalloc_noscan(os__max_path_bufffer_size());
		os__getwd_defer_0 = true;
		#if defined(_WIN32)
		{
			if (_wgetcwd(((u16*)(buf)), _const_os__max_path_len) == 0) {
				string _t1 = _SLIT("");
				// Defer begin
				if (os__getwd_defer_0) {
					_v_free(buf);
				}
				// Defer end
				return _t1;
			}
			string res = string_from_wide(((u16*)(buf)));
			string _t2 = res;
			// Defer begin
			if (os__getwd_defer_0) {
				_v_free(buf);
			}
			// Defer end
			return _t2;
		}
		#else
		{
		}
		#endif
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [manualfree]
string os__real_path(string fpath) {
bool os__real_path_defer_0 = false;
byte* fullpath;
bool os__real_path_defer_1 = false;
u16* fpath_wide;
bool os__real_path_defer_2 = false;
voidptr file;
	int size = os__max_path_bufffer_size();
	fullpath = vcalloc_noscan(size);
	os__real_path_defer_0 = true;
	string res = _SLIT("");
	#if defined(_WIN32)
	{
		u16* pu16_fullpath = ((u16*)(fullpath));
		fpath_wide = string_to_wide(fpath);
		os__real_path_defer_1 = true;
		file = CreateFile(fpath_wide, 0x80000000U, 1U, 0, 3U, 0x80U, 0);
		if (file != ((voidptr)(-1))) {
			os__real_path_defer_2 = true;
			int final_len = GetFinalPathNameByHandleW(file, pu16_fullpath, size, 0U);
			if (final_len < size) {
				string rt = string_from_wide2(pu16_fullpath, final_len);
				string srt = string_substr(rt, 4, rt.len);
				string_free(&res);
				res = string_clone(srt);
			} else {
				eprintln(_SLIT("os.real_path() saw that the file path was too long"));
				string_free(&res);
				string _t1 = string_clone(fpath);
				// Defer begin
				if (os__real_path_defer_2) {
					#if defined(_WIN32)
						CloseHandle(file);
					
					#endif
				}
				// Defer end
				// Defer begin
				if (os__real_path_defer_1) {
					#if defined(_WIN32)
						_v_free(((voidptr)(fpath_wide)));
					
					#endif
				}
				// Defer end
				// Defer begin
				if (os__real_path_defer_0) {
					_v_free(fullpath);
				}
				// Defer end
				return _t1;
			}
		} else {
			u32 ret = GetFullPathName(fpath_wide, _const_os__max_path_len, pu16_fullpath, 0);
			if (ret == 0U) {
				string_free(&res);
				string _t2 = string_clone(fpath);
				// Defer begin
				if (os__real_path_defer_2) {
					#if defined(_WIN32)
						CloseHandle(file);
					
					#endif
				}
				// Defer end
				// Defer begin
				if (os__real_path_defer_1) {
					#if defined(_WIN32)
						_v_free(((voidptr)(fpath_wide)));
					
					#endif
				}
				// Defer end
				// Defer begin
				if (os__real_path_defer_0) {
					_v_free(fullpath);
				}
				// Defer end
				return _t2;
			}
			string_free(&res);
			res = string_from_wide(pu16_fullpath);
		}
	}
	#else
	{
	}
	#endif
	os__normalize_drive_letter(res);
	string _t3 = res;
	// Defer begin
	if (os__real_path_defer_2) {
		#if defined(_WIN32)
			CloseHandle(file);
		
		#endif
	}
	// Defer end
	// Defer begin
	if (os__real_path_defer_1) {
		#if defined(_WIN32)
			_v_free(((voidptr)(fpath_wide)));
		
		#endif
	}
	// Defer end
	// Defer begin
	if (os__real_path_defer_0) {
		_v_free(fullpath);
	}
	// Defer end
	return _t3;
}

// Attr: [direct_array_access]
// Attr: [manualfree]
// Attr: [unsafe]
VV_LOCAL_SYMBOL void os__normalize_drive_letter(string path) {
	if (path.len > 2 && path.str[ 0] >= 'a' && path.str[ 0] <= 'z' && path.str[ 1] == ':' && path.str[ 2] == _const_os__path_separator.str[ 0]) {
		{ // Unsafe block
			byte* x = &path.str[0];
			(*x) = *x - 32;
		}
	}
}

int os__fork(void) {
	int pid = -1;
	_v_panic(_SLIT("os.fork not supported in windows"));
	VUNREACHABLE();
	int _t1 = pid;
	return _t1;
}

int os__wait(void) {
	int pid = -1;
	_v_panic(_SLIT("os.wait not supported in windows"));
	VUNREACHABLE();
	int _t1 = pid;
	return _t1;
}

i64 os__file_last_mod_unix(string path) {
	struct stat attr;
	stat(((char*)(path.str)), &attr);
	i64 _t1 = ((i64)(attr.st_mtime));
	return _t1;
}

void os__flush(void) {
	fflush(stdout);
}

Option_void os__chmod(string path, int mode) {
	if (chmod(((char*)(path.str)), mode) != 0) {
		return (Option_void){ .state=2, .err=error_with_code(string__plus(_SLIT("chmod failed: "), os__posix_get_error_msg(errno)), errno), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (Option_void){0};
}

Option_void os__chown(string path, int owner, int group) {
	#if defined(_WIN32)
	{
		return (Option_void){ .state=2, .err=_v_error(_SLIT("os.chown() not implemented for Windows")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	#else
	{
	}
	#endif
	return (Option_void){0};
}

Option_os__File os__open_append(string path) {
	os__File file = (os__File){.cfile = 0,.fd = 0,.is_opened = 0,};
	#if defined(_WIN32)
	{
		u16* wpath = string_to_wide(string_replace(path, _SLIT("/"), _SLIT("\\")));
		string mode = _SLIT("ab");
		file = (os__File){.cfile = _wfopen(wpath, string_to_wide(mode)),.fd = 0,.is_opened = 0,};
	}
	#else
	{
	}
	#endif
	if (isnil(file.cfile)) {
		return (Option_os__File){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("failed to create(append) file \""), 0xfe10, {.d_s = path}}, {_SLIT("\""), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	file.is_opened = true;
	Option_os__File _t2;
	opt_ok(&(os__File[]) { file }, (Option*)(&_t2), sizeof(os__File));
	return _t2;
}

Option_void os__execvp(string cmdpath, Array_string cmdargs) {
	Array_char_ptr cargs = __new_array_with_default(0, 0, sizeof(char*), 0);
	array_push((array*)&cargs, _MOV((char*[]){ ((char*)(cmdpath.str)) }));
	for (int i = 0; i < cmdargs.len; ++i) {
		array_push((array*)&cargs, _MOV((char*[]){ ((char*)((*(string*)/*ee elem_typ */array_get(cmdargs, i)).str)) }));
	}
	array_push((array*)&cargs, _MOV((char*[]){ ((char*)(0)) }));
	int res = ((int)(0));
	#if defined(_WIN32)
	{
		res = _execvp(((char*)(cmdpath.str)), cargs.data);
	}
	#else
	{
	}
	#endif
	if (res == -1) {
		return (Option_void){ .state=2, .err=error_with_code(os__posix_get_error_msg(errno), errno), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_v_exit(res);
	VUNREACHABLE();
	return (Option_void){0};
}

Option_void os__execve(string cmdpath, Array_string cmdargs, Array_string envs) {
	Array_char_ptr cargv = __new_array_with_default(0, 0, sizeof(char*), 0);
	Array_char_ptr cenvs = __new_array_with_default(0, 0, sizeof(char*), 0);
	array_push((array*)&cargv, _MOV((char*[]){ ((char*)(cmdpath.str)) }));
	for (int i = 0; i < cmdargs.len; ++i) {
		array_push((array*)&cargv, _MOV((char*[]){ ((char*)((*(string*)/*ee elem_typ */array_get(cmdargs, i)).str)) }));
	}
	for (int i = 0; i < envs.len; ++i) {
		array_push((array*)&cenvs, _MOV((char*[]){ ((char*)((*(string*)/*ee elem_typ */array_get(envs, i)).str)) }));
	}
	array_push((array*)&cargv, _MOV((char*[]){ ((char*)(0)) }));
	array_push((array*)&cenvs, _MOV((char*[]){ ((char*)(0)) }));
	int res = ((int)(0));
	#if defined(_WIN32)
	{
		res = _execve(((char*)(cmdpath.str)), cargv.data, cenvs.data);
	}
	#else
	{
	}
	#endif
	if (res == -1) {
		return (Option_void){ .state=2, .err=error_with_code(os__posix_get_error_msg(errno), errno), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (Option_void){0};
}

int os__is_atty(int fd) {
	#if defined(_WIN32)
	{
		u32 mode = ((u32)(0U));
		voidptr osfh = ((voidptr)(_get_osfhandle(fd)));
		GetConsoleMode(osfh, ((voidptr)(&mode)));
		int _t1 = ((int)(mode));
		return _t1;
	}
	#else
	{
	}
	#endif
	return 0;
}

Option_void os__write_file_array(string path, array buffer) {
	Option_os__File _t1 = os__create(path);
	if (_t1.state != 0) { /*or block*/ 
		Option_void _t2;
		memcpy(&_t2, &_t1, sizeof(Option));
		return _t2;
	}
	
 	os__File f =  (*(os__File*)_t1.data);
		Option_void _t3 = os__File_write_full_buffer(&f, buffer.data, ((usize)(buffer.len * buffer.element_size)));
	if (_t3.state != 0 && _t3.err._typ != _IError_None___index) {
		Option_void _t4;
		memcpy(&_t4, &_t3, sizeof(Option));
		return _t4;
	}
	
 ;
	os__File_close(&f);
	return (Option_void){0};
}

Option_Array_string os__glob(Array_string patterns) {
	Array_string matches = __new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t1 = 0; _t1 < patterns.len; ++_t1) {
		string pattern = ((string*)patterns.data)[_t1];
		Option_void _t2 = os__native_glob_pattern(pattern, &/*arr*/matches);
		if (_t2.state != 0 && _t2.err._typ != _IError_None___index) {
			Option_Array_string _t3;
			memcpy(&_t3, &_t2, sizeof(Option));
			return _t3;
		}
		
 ;
	}
	qsort(matches.data, matches.len, matches.element_size, (int (*)(const void *, const void *))&compare_10044130939551424885_string);
	Option_Array_string _t4;
	opt_ok(&(Array_string[]) { matches }, (Option*)(&_t4), sizeof(Array_string));
	return _t4;
}

IError os__last_error(void) {
	#if defined(_WIN32)
	{
		int code = ((int)(GetLastError()));
		string msg = os__get_error_msg(code);
		IError _t1 = error_with_code(msg, code);
		return _t1;
	}
	#else
	{
	}
	#endif
	return (IError){0};
}

// Attr: [unsafe]
void os__Result_free(os__Result* result) {
	string_free(&result->output);
}

Option_void os__cp_all(string src, string dst, bool overwrite) {
	string source_path = os__real_path(src);
	string dest_path = os__real_path(dst);
	if (!os__exists(source_path)) {
		return (Option_void){ .state=2, .err=_v_error(_SLIT("Source path doesn't exist")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (!os__is_dir(source_path)) {
		string fname = os__file_name(source_path);
		string adjusted_path = (os__is_dir(dest_path) ? (os__join_path_single(dest_path, fname)) : (dest_path));
		if (os__exists(adjusted_path)) {
			if (overwrite) {
				Option_void _t2 = os__rm(adjusted_path);
				if (_t2.state != 0 && _t2.err._typ != _IError_None___index) {
					Option_void _t3;
					memcpy(&_t3, &_t2, sizeof(Option));
					return _t3;
				}
				
 ;
			} else {
				return (Option_void){ .state=2, .err=_v_error(_SLIT("Destination file path already exist")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
		}
		Option_void _t5 = os__cp(source_path, adjusted_path);
		if (_t5.state != 0 && _t5.err._typ != _IError_None___index) {
			Option_void _t6;
			memcpy(&_t6, &_t5, sizeof(Option));
			return _t6;
		}
		
 ;
		return (Option_void){0};
	}
	if (!os__exists(dest_path)) {
		Option_bool _t7 = os__mkdir(dest_path);
		if (_t7.state != 0) { /*or block*/ 
			Option_void _t8;
			memcpy(&_t8, &_t7, sizeof(Option));
			return _t8;
		}
		
  (*(bool*)_t7.data);
	}
	if (!os__is_dir(dest_path)) {
		return (Option_void){ .state=2, .err=_v_error(_SLIT("Destination path is not a valid directory")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Option_Array_string _t10 = os__ls(source_path);
	if (_t10.state != 0) { /*or block*/ 
		Option_void _t11;
		memcpy(&_t11, &_t10, sizeof(Option));
		return _t11;
	}
	
 	Array_string files =  (*(Array_string*)_t10.data);
	for (int _t12 = 0; _t12 < files.len; ++_t12) {
		string file = ((string*)files.data)[_t12];
		string sp = os__join_path_single(source_path, file);
		string dp = os__join_path_single(dest_path, file);
		if (os__is_dir(sp)) {
			if (!os__exists(dp)) {
				Option_bool _t13 = os__mkdir(dp);
				if (_t13.state != 0) { /*or block*/ 
					Option_void _t14;
					memcpy(&_t14, &_t13, sizeof(Option));
					return _t14;
				}
				
  (*(bool*)_t13.data);
			}
		}
		Option_void _t15 = os__cp_all(sp, dp, overwrite);
		if (_t15.state != 0 && _t15.err._typ != _IError_None___index) {
			IError err = _t15.err;
			Option_void _t16 = os__rmdir(dp);
			if (_t16.state != 0 && _t16.err._typ != _IError_None___index) {
				err = _t16.err;
				return (Option_void){ .state=2, .err=err, .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			
 ;
			return (Option_void){ .state=2, .err=err, .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		
 ;
	}
	return (Option_void){0};
}

Option_void os__mv_by_cp(string source, string target) {
	Option_void _t1 = os__cp(source, target);
	if (_t1.state != 0 && _t1.err._typ != _IError_None___index) {
		Option_void _t2;
		memcpy(&_t2, &_t1, sizeof(Option));
		return _t2;
	}
	
 ;
	Option_void _t3 = os__rm(source);
	if (_t3.state != 0 && _t3.err._typ != _IError_None___index) {
		Option_void _t4;
		memcpy(&_t4, &_t3, sizeof(Option));
		return _t4;
	}
	
 ;
	return (Option_void){0};
}

// Attr: [manualfree]
Option_Array_string os__read_lines(string path) {
	Option_string _t1 = os__read_file(path);
	if (_t1.state != 0) { /*or block*/ 
		Option_Array_string _t2;
		memcpy(&_t2, &_t1, sizeof(Option));
		return _t2;
	}
	
 	string buf =  (*(string*)_t1.data);
	Array_string res = string_split_into_lines(buf);
	string_free(&buf);
	Option_Array_string _t3;
	opt_ok(&(Array_string[]) { res }, (Option*)(&_t3), sizeof(Array_string));
	return _t3;
}

string os__sigint_to_signal_name(int si) {

	if (si == (1)) {
		string _t1 = _SLIT("SIGHUP");
		return _t1;
	}
	else if (si == (2)) {
		string _t2 = _SLIT("SIGINT");
		return _t2;
	}
	else if (si == (3)) {
		string _t3 = _SLIT("SIGQUIT");
		return _t3;
	}
	else if (si == (4)) {
		string _t4 = _SLIT("SIGILL");
		return _t4;
	}
	else if (si == (6)) {
		string _t5 = _SLIT("SIGABRT");
		return _t5;
	}
	else if (si == (8)) {
		string _t6 = _SLIT("SIGFPE");
		return _t6;
	}
	else if (si == (9)) {
		string _t7 = _SLIT("SIGKILL");
		return _t7;
	}
	else if (si == (11)) {
		string _t8 = _SLIT("SIGSEGV");
		return _t8;
	}
	else if (si == (13)) {
		string _t9 = _SLIT("SIGPIPE");
		return _t9;
	}
	else if (si == (14)) {
		string _t10 = _SLIT("SIGALRM");
		return _t10;
	}
	else if (si == (15)) {
		string _t11 = _SLIT("SIGTERM");
		return _t11;
	}
	else {
	};
	string _t12 = _SLIT("unknown");
	return _t12;
}

Option_void os__rmdir_all(string path) {
	string ret_err = _SLIT("");
	Option_Array_string _t1 = os__ls(path);
	if (_t1.state != 0) { /*or block*/ 
		Option_void _t2;
		memcpy(&_t2, &_t1, sizeof(Option));
		return _t2;
	}
	
 	Array_string items =  (*(Array_string*)_t1.data);
	for (int _t3 = 0; _t3 < items.len; ++_t3) {
		string item = ((string*)items.data)[_t3];
		string fullpath = os__join_path_single(path, item);
		if (os__is_dir(fullpath) && !os__is_link(fullpath)) {
			Option_void _t4 = os__rmdir_all(fullpath);
			if (_t4.state != 0 && _t4.err._typ != _IError_None___index) {
				IError err = _t4.err;
				ret_err = (*(err.msg));
			}
			
 ;
		} else {
			Option_void _t5 = os__rm(fullpath);
			if (_t5.state != 0 && _t5.err._typ != _IError_None___index) {
				IError err = _t5.err;
				ret_err = (*(err.msg));
			}
			
 ;
		}
	}
	Option_void _t6 = os__rmdir(path);
	if (_t6.state != 0 && _t6.err._typ != _IError_None___index) {
		IError err = _t6.err;
		ret_err = (*(err.msg));
	}
	
 ;
	if (ret_err.len > 0) {
		return (Option_void){ .state=2, .err=_v_error(ret_err), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (Option_void){0};
}

// Attr: [manualfree]
bool os__is_dir_empty(string path) {
	Option_Array_string _t1 = os__ls(path);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		bool _t2 = true;
		return _t2;
	}
	
 	Array_string items =  (*(Array_string*)_t1.data);
	bool res = items.len == 0;
	array_free(&items);
	bool _t3 = res;
	return _t3;
}

string os__file_ext(string path) {
	Option_int _t1 = string_last_index(path, _SLIT("."));
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		string _t2 = _SLIT("");
		return _t2;
	}
	
 	int pos =  (*(int*)_t1.data);
	string _t3 = string_substr(path, pos, path.len);
	return _t3;
}

string os__dir(string opath) {
	if ((opath).len == 0) {
		string _t1 = _SLIT(".");
		return _t1;
	}
	string path = string_replace_each(opath, new_array_from_c_array(4, 4, sizeof(string), _MOV((string[4]){_SLIT("/"), string_clone(_const_os__path_separator), _SLIT("\\"), string_clone(_const_os__path_separator)})));
	Option_int _t2 = string_last_index(path, _const_os__path_separator);
	if (_t2.state != 0) { /*or block*/ 
		IError err = _t2.err;
		string _t3 = _SLIT(".");
		return _t3;
	}
	
 	int pos =  (*(int*)_t2.data);
	if (pos == 0 && string__eq(_const_os__path_separator, _SLIT("/"))) {
		string _t4 = _SLIT("/");
		return _t4;
	}
	string _t5 = string_substr(path, 0, pos);
	return _t5;
}

string os__base(string opath) {
	if ((opath).len == 0) {
		string _t1 = _SLIT(".");
		return _t1;
	}
	string path = string_replace_each(opath, new_array_from_c_array(4, 4, sizeof(string), _MOV((string[4]){_SLIT("/"), string_clone(_const_os__path_separator), _SLIT("\\"), string_clone(_const_os__path_separator)})));
	if (string__eq(path, _const_os__path_separator)) {
		string _t2 = _const_os__path_separator;
		return _t2;
	}
	if (string_ends_with(path, _const_os__path_separator)) {
		string path2 = string_substr(path, 0, path.len - 1);
		Option_int _t3 = string_last_index(path2, _const_os__path_separator);
		if (_t3.state != 0) { /*or block*/ 
			IError err = _t3.err;
			string _t4 = string_clone(path2);
			return _t4;
		}
		
 		int pos =  (*(int*)_t3.data);
		string _t5 = string_substr(path2, pos + 1, path2.len);
		return _t5;
	}
	Option_int _t6 = string_last_index(path, _const_os__path_separator);
	if (_t6.state != 0) { /*or block*/ 
		IError err = _t6.err;
		string _t7 = string_clone(path);
		return _t7;
	}
	
 	int pos =  (*(int*)_t6.data);
	string _t8 = string_substr(path, pos + 1, path.len);
	return _t8;
}

string os__file_name(string opath) {
	string path = string_replace_each(opath, new_array_from_c_array(4, 4, sizeof(string), _MOV((string[4]){_SLIT("/"), string_clone(_const_os__path_separator), _SLIT("\\"), string_clone(_const_os__path_separator)})));
	string _t1 = string_all_after_last(path, _const_os__path_separator);
	return _t1;
}

Option_string os__input_opt(string prompt) {
	print(prompt);
	os__flush();
	string res = os__get_raw_line();
	if (res.len > 0) {
		Option_string _t1;
		opt_ok(&(string[]) { string_trim_right(res, _SLIT("\r\n")) }, (Option*)(&_t1), sizeof(string));
		return _t1;
	}
	return (Option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
}

string os__input(string prompt) {
	Option_string _t1 = os__input_opt(prompt);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		string _t2 = _SLIT("<EOF>");
		return _t2;
	}
	
 	string res =  (*(string*)_t1.data);
	string _t3 = res;
	return _t3;
}

string os__get_line(void) {
	string str = os__get_raw_line();
	string _t1 = string_trim_right(str, _SLIT("\r\n"));
	return _t1;
	string _t2 = string_trim_right(str, _SLIT("\n"));
	return _t2;
}

Array_string os__get_lines(void) {
	string line = _SLIT("");
	Array_string inputstr = __new_array_with_default(0, 0, sizeof(string), 0);
	for (;;) {
		line = os__get_line();
		if (line.len <= 0) {
			break;
		}
		line = string_trim_space(line);
		array_push((array*)&inputstr, _MOV((string[]){ string_clone(line) }));
	}
	Array_string _t2 = inputstr;
	return _t2;
}

string os__get_lines_joined(void) {
	string line = _SLIT("");
	string inputstr = _SLIT("");
	for (;;) {
		line = os__get_line();
		if (line.len <= 0) {
			break;
		}
		line = string_trim_space(line);
		inputstr = /*f*/string__plus(inputstr, line);
	}
	string _t1 = inputstr;
	return _t1;
}

string os__get_raw_lines_joined(void) {
	string line = _SLIT("");
	Array_string lines = __new_array_with_default(0, 0, sizeof(string), 0);
	for (;;) {
		line = os__get_raw_line();
		if (line.len <= 0) {
			break;
		}
		array_push((array*)&lines, _MOV((string[]){ string_clone(line) }));
	}
	string res = Array_string_join(lines, _SLIT(""));
	string _t2 = res;
	return _t2;
}

string os__user_os(void) {
	string _t1 = _SLIT("windows");
	return _t1;
	string _t2 = _SLIT("unknown");
	return _t2;
}

string os__home_dir(void) {
	#if defined(_WIN32)
	{
		string _t1 = os__getenv(_SLIT("USERPROFILE"));
		return _t1;
	}
	#else
	{
	}
	#endif
	return (string){.str=(byteptr)"", .is_lit=1};
}

string os__expand_tilde_to_home(string path) {
	if (string__eq(path, _SLIT("~"))) {
		string _t1 = string_trim_right(os__home_dir(), _const_os__path_separator);
		return _t1;
	}
	if (string_starts_with(path, string__plus(_SLIT("~"), _const_os__path_separator))) {
		string _t2 = string_replace_once(path, string__plus(_SLIT("~"), _const_os__path_separator), string__plus(string_trim_right(os__home_dir(), _const_os__path_separator), _const_os__path_separator));
		return _t2;
	}
	string _t3 = path;
	return _t3;
}

Option_void os__write_file(string path, string text) {
	Option_os__File _t1 = os__create(path);
	if (_t1.state != 0) { /*or block*/ 
		Option_void _t2;
		memcpy(&_t2, &_t1, sizeof(Option));
		return _t2;
	}
	
 	os__File f =  (*(os__File*)_t1.data);
		Option_void _t3 = os__File_write_full_buffer(&f, text.str, ((usize)(text.len)));
	if (_t3.state != 0 && _t3.err._typ != _IError_None___index) {
		Option_void _t4;
		memcpy(&_t4, &_t3, sizeof(Option));
		return _t4;
	}
	
 ;
	os__File_close(&f);
	return (Option_void){0};
}

VV_LOCAL_SYMBOL string os__executable_fallback(void) {
	if (_const_os__args.len == 0) {
		string _t1 = _SLIT("");
		return _t1;
	}
	string exepath = (*(string*)/*ee elem_typ */array_get(_const_os__args, 0));
	if (!string_contains(exepath, _SLIT(".exe"))) {
		exepath = /*f*/string__plus(exepath, _SLIT(".exe"));
	}
	if (!os__is_abs_path(exepath)) {
		string rexepath = string_replace_each(exepath, new_array_from_c_array(4, 4, sizeof(string), _MOV((string[4]){_SLIT("/"), string_clone(_const_os__path_separator), _SLIT("\\"), string_clone(_const_os__path_separator)})));
		if (string_contains(rexepath, _const_os__path_separator)) {
			exepath = os__join_path_single(_const_os__wd_at_startup, exepath);
		} else {
			Option_string _t2 = os__find_abs_path_of_executable(exepath);
			if (_t2.state != 0) { /*or block*/ 
				IError err = _t2.err;
				*(string*) _t2.data = _SLIT("");
			}
			
 			string foundpath =  (*(string*)_t2.data);
			if (foundpath.len > 0) {
				exepath = foundpath;
			}
		}
	}
	exepath = os__real_path(exepath);
	string _t3 = exepath;
	return _t3;
}

VV_LOCAL_SYMBOL IError os__error_failed_to_find_executable(void) {
	IError _t1 = /*&IError*/I_os__ErrExecutableNotFound_to_Interface_IError((os__ErrExecutableNotFound*)memdup(&(os__ErrExecutableNotFound){.msg = _SLIT("os: failed to find executable"),.code = 0,}, sizeof(os__ErrExecutableNotFound)));
	return _t1;
}

Option_string os__find_abs_path_of_executable(string exepath) {
	if ((exepath).len == 0) {
		return (Option_string){ .state=2, .err=_v_error(_SLIT("expected non empty `exepath`")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (os__is_abs_path(exepath)) {
		Option_string _t2;
		opt_ok(&(string[]) { os__real_path(exepath) }, (Option*)(&_t2), sizeof(string));
		return _t2;
	}
	string res = _SLIT("");
	string path = os__getenv(_SLIT("PATH"));
	Array_string paths = string_split(path, _const_os__path_delimiter);
	for (int _t3 = 0; _t3 < paths.len; ++_t3) {
		string p = ((string*)paths.data)[_t3];
		string found_abs_path = os__join_path_single(p, exepath);
		if (os__exists(found_abs_path) && os__is_executable(found_abs_path)) {
			res = found_abs_path;
			break;
		}
	}
	if (res.len > 0) {
		Option_string _t4;
		opt_ok(&(string[]) { os__real_path(res) }, (Option*)(&_t4), sizeof(string));
		return _t4;
	}
	return (Option_string){ .state=2, .err=os__error_failed_to_find_executable(), .data={EMPTY_STRUCT_INITIALIZATION} };
}

bool os__exists_in_system_path(string prog) {
	Option_string _t1 = os__find_abs_path_of_executable(prog);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		bool _t2 = false;
		return _t2;
	}
	
  (*(string*)_t1.data);
	bool _t3 = true;
	return _t3;
}

bool os__is_file(string path) {
	bool _t1 = os__exists(path) && !os__is_dir(path);
	return _t1;
}

bool os__is_abs_path(string path) {
	if (path.len == 0) {
		bool _t1 = false;
		return _t1;
	}
	bool _t2 = string_at(path, 0) == '/' || (byte_is_letter(string_at(path, 0)) && path.len > 1 && string_at(path, 1) == ':');
	return _t2;
	bool _t3 = string_at(path, 0) == '/';
	return _t3;
}

// Attr: [manualfree]
string os__join_path(string base, Array_string dirs) {
bool os__join_path_defer_0 = false;
strings__Builder sb;
bool os__join_path_defer_1 = false;
string sbase;
	sb = strings__new_builder(base.len + dirs.len * 50);
	os__join_path_defer_0 = true;
	sbase = string_trim_right(base, _SLIT("\\/"));
	os__join_path_defer_1 = true;
	strings__Builder_write_string(&sb, sbase);
	for (int _t1 = 0; _t1 < dirs.len; ++_t1) {
		string d = ((string*)dirs.data)[_t1];
		strings__Builder_write_string(&sb, _const_os__path_separator);
		strings__Builder_write_string(&sb, d);
	}
	string _t2 = strings__Builder_str(&sb);
	// Defer begin
	if (os__join_path_defer_1) {
		string_free(&sbase);
	}
	// Defer end
	// Defer begin
	if (os__join_path_defer_0) {
		strings__Builder_free(&sb);
	}
	// Defer end
	return _t2;
}

// Attr: [manualfree]
string os__join_path_single(string base, string elem) {
bool os__join_path_single_defer_0 = false;
strings__Builder sb;
bool os__join_path_single_defer_1 = false;
string sbase;
	sb = strings__new_builder(base.len + elem.len + 1);
	os__join_path_single_defer_0 = true;
	sbase = string_trim_right(base, _SLIT("\\/"));
	os__join_path_single_defer_1 = true;
	strings__Builder_write_string(&sb, sbase);
	strings__Builder_write_string(&sb, _const_os__path_separator);
	strings__Builder_write_string(&sb, elem);
	string _t1 = strings__Builder_str(&sb);
	// Defer begin
	if (os__join_path_single_defer_1) {
		string_free(&sbase);
	}
	// Defer end
	// Defer begin
	if (os__join_path_single_defer_0) {
		strings__Builder_free(&sb);
	}
	// Defer end
	return _t1;
}

Array_string os__walk_ext(string path, string ext) {
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	os__impl_walk_ext(path, ext, &/*arr*/res);
	Array_string _t1 = res;
	return _t1;
}

VV_LOCAL_SYMBOL void os__impl_walk_ext(string path, string ext, Array_string* out) {
	if (!os__is_dir(path)) {
		return;
	}
	Option_Array_string _t1 = os__ls(path);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		return;
	}
	
 	Array_string files =  (*(Array_string*)_t1.data);
	string separator = (string_ends_with(path, _const_os__path_separator) ? (_SLIT("")) : (_const_os__path_separator));
	for (int _t2 = 0; _t2 < files.len; ++_t2) {
		string file = ((string*)files.data)[_t2];
		if (string_starts_with(file, _SLIT("."))) {
			continue;
		}
		string p = string__plus(string__plus(path, separator), file);
		if (os__is_dir(p) && !os__is_link(p)) {
			os__impl_walk_ext(p, ext, out);
		} else if (string_ends_with(file, ext)) {
			array_push((array*)out, _MOV((string[]){ string_clone(p) }));
		}
	}
}

void os__walk(string path, void (*f)(string )) {
	if (path.len == 0) {
		return;
	}
	if (!os__is_dir(path)) {
		return;
	}
	Option_Array_string _t1 = os__ls(path);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		return;
	}
	
 	Array_string files =  (*(Array_string*)_t1.data);
	string local_path_separator = _const_os__path_separator;
	if (string_ends_with(path, _const_os__path_separator)) {
		local_path_separator = _SLIT("");
	}
	for (int _t2 = 0; _t2 < files.len; ++_t2) {
		string file = ((string*)files.data)[_t2];
		string p = string__plus(string__plus(path, local_path_separator), file);
		if (os__is_dir(p) && !os__is_link(p)) {
			os__walk(p, (voidptr)f);
		} else if (os__exists(p)) {
			f(p);
		}
	}
	return;
}

// TypeDecl
void os__walk_with_context(string path, voidptr context, void (*fcb)(voidptr , string )) {
	if (path.len == 0) {
		return;
	}
	if (!os__is_dir(path)) {
		return;
	}
	Option_Array_string _t1 = os__ls(path);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		return;
	}
	
 	Array_string files =  (*(Array_string*)_t1.data);
	string local_path_separator = _const_os__path_separator;
	if (string_ends_with(path, _const_os__path_separator)) {
		local_path_separator = _SLIT("");
	}
	for (int _t2 = 0; _t2 < files.len; ++_t2) {
		string file = ((string*)files.data)[_t2];
		string p = string__plus(string__plus(path, local_path_separator), file);
		if (os__is_dir(p) && !os__is_link(p)) {
			os__walk_with_context(p, context, (voidptr)fcb);
		} else {
			fcb(context, p);
		}
	}
	return;
}

void os__log(string s) {
	println(string__plus(_SLIT("os.log: "), s));
}

Option_void os__mkdir_all(string opath) {
	string path = string_replace(opath, _SLIT("/"), _const_os__path_separator);
	string p = (string_starts_with(path, _const_os__path_separator) ? (_const_os__path_separator) : (_SLIT("")));
	Array_string path_parts = string_split(string_trim_left(path, _const_os__path_separator), _const_os__path_separator);
	for (int _t1 = 0; _t1 < path_parts.len; ++_t1) {
		string subdir = ((string*)path_parts.data)[_t1];
		p = /*f*/string__plus(p, string__plus(subdir, _const_os__path_separator));
		if (os__exists(p) && os__is_dir(p)) {
			continue;
		}
		Option_bool _t2 = os__mkdir(p);
		if (_t2.state != 0) { /*or block*/ 
			IError err = _t2.err;
			return (Option_void){ .state=2, .err=_v_error( str_intp(3, _MOV((StrIntpData[]){{_SLIT("folder: "), 0xfe10, {.d_s = p}}, {_SLIT(", error: "), 0xfe10, {.d_s = IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		
  (*(bool*)_t2.data);
	}
	return (Option_void){0};
}

string os__cache_dir(void) {
	string cdir = os__join_path_single(os__home_dir(), _SLIT(".cache"));
	if (!os__is_dir(cdir) && !os__is_link(cdir)) {
		Option_bool _t1 = os__mkdir(cdir);
		if (_t1.state != 0) { /*or block*/ 
			IError err = _t1.err;
			_v_panic(IError_str(err));
			VUNREACHABLE();
		;
		}
		
  (*(bool*)_t1.data);
	}
	string _t2 = cdir;
	return _t2;
}

string os__temp_dir(void) {
	string path = os__getenv(_SLIT("TMPDIR"));
	if ((path).len == 0) {
		path = os__getenv(_SLIT("TEMP"));
		if ((path).len == 0) {
			path = os__getenv(_SLIT("TMP"));
		}
		if ((path).len == 0) {
			path = _SLIT("C:/tmp");
		}
	}
	if ((path).len == 0) {
		path = _SLIT("/tmp");
	}
	string _t1 = path;
	return _t1;
}

VV_LOCAL_SYMBOL string os__default_vmodules_path(void) {
	string hdir = os__home_dir();
	string res = os__join_path_single(hdir, _SLIT(".vmodules"));
	string _t1 = res;
	return _t1;
}

string os__vmodules_dir(void) {
	Array_string paths = os__vmodules_paths();
	if (paths.len > 0) {
		string _t1 = (*(string*)/*ee elem_typ */array_get(paths, 0));
		return _t1;
	}
	string _t2 = os__default_vmodules_path();
	return _t2;
}

Array_string os__vmodules_paths(void) {
bool os__vmodules_paths_defer_0 = false;
bool os__vmodules_paths_defer_1 = false;
	string path = os__getenv(_SLIT("VMODULES"));
	if ((path).len == 0) {
		path = os__default_vmodules_path();
	}
	os__vmodules_paths_defer_0 = true;
	Array_string splitted = string_split(path, _const_os__path_delimiter);
	os__vmodules_paths_defer_1 = true;
	Array_string list = __new_array_with_default(0, splitted.len, sizeof(string), 0);
	for (int i = 0; i < splitted.len; ++i) {
		string si = (*(string*)/*ee elem_typ */array_get(splitted, i));
		string trimmed = string_trim_right(si, _const_os__path_separator);
		array_push((array*)&list, _MOV((string[]){ string_clone(trimmed) }));
	}
	Array_string _t2 = list;
	// Defer begin
	if (os__vmodules_paths_defer_1) {
	}
	// Defer end
	// Defer begin
	if (os__vmodules_paths_defer_0) {
	}
	// Defer end
	return _t2;
}

// Attr: [manualfree]
string os__resource_abs_path(string path) {
	string exe = os__executable();
	string dexe = os__dir(exe);
	string base_path = os__real_path(dexe);
	string vresource = os__getenv(_SLIT("V_RESOURCE_PATH"));
	if (vresource.len != 0) {
		string_free(&base_path);
		base_path = vresource;
	}
	string fp = os__join_path_single(base_path, path);
	string res = os__real_path(fp);
	{ // Unsafe block
		string_free(&fp);
		string_free(&vresource);
		string_free(&base_path);
		string_free(&dexe);
		string_free(&exe);
	}
	string _t1 = res;
	return _t1;
}

os__Result os__execute_or_panic(string cmd) {
	os__Result res = os__execute(cmd);
	if (res.exit_code != 0) {
		eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("failed    cmd: "), 0xfe10, {.d_s = cmd}}, {_SLIT0, 0, { .d_c = 0 }}})));
		eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("failed   code: "), 0xfe07, {.d_i32 = res.exit_code}}, {_SLIT0, 0, { .d_c = 0 }}})));
		_v_panic(res.output);
		VUNREACHABLE();
	}
	os__Result _t1 = res;
	return _t1;
}

os__Result os__execute_or_exit(string cmd) {
	os__Result res = os__execute(cmd);
	if (res.exit_code != 0) {
		eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("failed    cmd: "), 0xfe10, {.d_s = cmd}}, {_SLIT0, 0, { .d_c = 0 }}})));
		eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("failed   code: "), 0xfe07, {.d_i32 = res.exit_code}}, {_SLIT0, 0, { .d_c = 0 }}})));
		eprintln(res.output);
		_v_exit(1);
		VUNREACHABLE();
	}
	os__Result _t1 = res;
	return _t1;
}

// TypeDecl
// TypeDecl
VV_LOCAL_SYMBOL Array_string os__init_os_args_wide(int argc, byte** argv) {
	Array_string args_ = __new_array_with_default(argc, 0, sizeof(string), &(string[]){_SLIT("")});
	for (int i = 0; i < argc; ++i) {
		array_set(&args_, i, &(string[]) { string_from_wide(((u16*)(argv[i]))) });
	}
	Array_string _t1 = args_;
	return _t1;
}

VV_LOCAL_SYMBOL Option_void os__native_glob_pattern(string pattern, Array_string* matches) {
bool os__native_glob_pattern_defer_0 = false;
voidptr h_find_files;
	os__Win32finddata find_file_data = (os__Win32finddata){.dw_file_attributes = 0,.ft_creation_time = (os__Filetime){.dw_low_date_time = 0,.dw_high_date_time = 0,},.ft_last_access_time = (os__Filetime){.dw_low_date_time = 0,.dw_high_date_time = 0,},.ft_last_write_time = (os__Filetime){.dw_low_date_time = 0,.dw_high_date_time = 0,},.n_file_size_high = 0,.n_file_size_low = 0,.dw_reserved0 = 0,.dw_reserved1 = 0,.c_file_name = {0},.c_alternate_file_name = {0},.dw_file_type = 0,.dw_creator_type = 0,.w_finder_flags = 0,};
	u16* wpattern = string_to_wide(string_replace(pattern, _SLIT("/"), _SLIT("\\")));
	h_find_files = FindFirstFile(wpattern, ((voidptr)(&find_file_data)));
	os__native_glob_pattern_defer_0 = true;
	if (h_find_files == INVALID_HANDLE_VALUE) {
		Option_void _t1 = (Option_void){ .state=2, .err=_v_error(string__plus(_SLIT("os.glob(): Could not get a file handle: "), os__get_error_msg(((int)(GetLastError()))))), .data={EMPTY_STRUCT_INITIALIZATION} };
		// Defer begin
		if (os__native_glob_pattern_defer_0) {
			FindClose(h_find_files);
		}
		// Defer end
		return _t1;
	}
	string fname = string_from_wide(&find_file_data.c_file_name[0]);
	if (!(string__eq(fname, _SLIT(".")) || string__eq(fname, _SLIT("..")))) {
		string fp = string_replace(fname, _SLIT("\\"), _SLIT("/"));
		if ((find_file_data.dw_file_attributes & ((u32)(FILE_ATTRIBUTE_DIRECTORY))) > 0U) {
			fp = /*f*/string__plus(fp, _SLIT("/"));
		}
		array_push((array*)matches, _MOV((string[]){ string_clone(fp) }));
	}
	for (int i = 0; FindNextFile(h_find_files, ((voidptr)(&find_file_data))) > 0; i++) {
		string filename = string_from_wide(&find_file_data.c_file_name[0]);
		if (string__eq(filename, _SLIT(".")) || string__eq(filename, _SLIT(".."))) {
			continue;
		}
		string fpath = string_replace(filename, _SLIT("\\"), _SLIT("/"));
		if ((find_file_data.dw_file_attributes & ((u32)(FILE_ATTRIBUTE_DIRECTORY))) > 0U) {
			fpath = /*f*/string__plus(fpath, _SLIT("/"));
		}
		array_push((array*)matches, _MOV((string[]){ string_clone(fpath) }));
	}
	// Defer begin
	if (os__native_glob_pattern_defer_0) {
		FindClose(h_find_files);
	}
	// Defer end
	return (Option_void){0};
}

Option_void os__utime(string path, int actime, int modtime) {
	struct _utimbuf u = (struct _utimbuf){.actime = actime,.modtime = modtime,};
	if (_utime(((char*)(path.str)), ((voidptr)(&u))) != 0) {
		return (Option_void){ .state=2, .err=error_with_code(os__posix_get_error_msg(errno), errno), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (Option_void){0};
}

Option_Array_string os__ls(string path) {
	if (path.len == 0) {
		return (Option_Array_string){ .state=2, .err=_v_error(_SLIT("ls() expects a folder, not an empty string")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	os__Win32finddata find_file_data = (os__Win32finddata){.dw_file_attributes = 0,.ft_creation_time = (os__Filetime){.dw_low_date_time = 0,.dw_high_date_time = 0,},.ft_last_access_time = (os__Filetime){.dw_low_date_time = 0,.dw_high_date_time = 0,},.ft_last_write_time = (os__Filetime){.dw_low_date_time = 0,.dw_high_date_time = 0,},.n_file_size_high = 0,.n_file_size_low = 0,.dw_reserved0 = 0,.dw_reserved1 = 0,.c_file_name = {0},.c_alternate_file_name = {0},.dw_file_type = 0,.dw_creator_type = 0,.w_finder_flags = 0,};
	Array_string dir_files = __new_array_with_default(0, 0, sizeof(string), 0);
	if (!os__is_dir(path)) {
		return (Option_Array_string){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("ls() couldnt open dir \""), 0xfe10, {.d_s = path}}, {_SLIT("\": directory does not exist"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	string path_files =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = path}}, {_SLIT("\\*"), 0, { .d_c = 0 }}}));
	voidptr h_find_files = FindFirstFile(string_to_wide(path_files), ((voidptr)(&find_file_data)));
	string first_filename = string_from_wide(&find_file_data.c_file_name[0]);
	if (!string__eq(first_filename, _SLIT(".")) && !string__eq(first_filename, _SLIT(".."))) {
		array_push((array*)&dir_files, _MOV((string[]){ string_clone(first_filename) }));
	}
	for (;;) {
		if (!(FindNextFile(h_find_files, ((voidptr)(&find_file_data))) > 0)) break;
		string filename = string_from_wide(&find_file_data.c_file_name[0]);
		if (!string__eq(filename, _SLIT(".")) && !string__eq(filename, _SLIT(".."))) {
			array_push((array*)&dir_files, _MOV((string[]){ string_clone(string_clone(filename)) }));
		}
	}
	FindClose(h_find_files);
	Option_Array_string _t5;
	opt_ok(&(Array_string[]) { dir_files }, (Option*)(&_t5), sizeof(Array_string));
	return _t5;
}

Option_bool os__mkdir(string path) {
	if (string__eq(path, _SLIT("."))) {
		Option_bool _t1;
		opt_ok(&(bool[]) { true }, (Option*)(&_t1), sizeof(bool));
		return _t1;
	}
	string apath = os__real_path(path);
	if (!CreateDirectory(string_to_wide(apath), 0)) {
		return (Option_bool){ .state=2, .err=_v_error(string__plus( str_intp(2, _MOV((StrIntpData[]){{_SLIT("mkdir failed for \""), 0xfe10, {.d_s = apath}}, {_SLIT("\", because CreateDirectory returned: "), 0, { .d_c = 0 }}})), os__get_error_msg(((int)(GetLastError()))))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Option_bool _t3;
	opt_ok(&(bool[]) { true }, (Option*)(&_t3), sizeof(bool));
	return _t3;
}

os__HANDLE os__get_file_handle(string path) {
	Option_FILE_ptr _t1 = os__vfopen(path, _SLIT("rb"));
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		os__HANDLE _t2 = ((_const_os__invalid_handle_value));
		return _t2;
	}
	
 	FILE* cfile =  (*(FILE**)_t1.data);
	os__HANDLE handle = ((os__HANDLE)(_get_osfhandle(os__fileno(cfile))));
	os__HANDLE _t3 = handle;
	return _t3;
}

Option_string os__get_module_filename(os__HANDLE handle) {
	{ // Unsafe block
		int sz = 4096;
		u16* buf = ((u16*)(malloc_noscan(4096)));
		for (;;) {
			int status = ((int)(GetModuleFileNameW(handle, ((voidptr)(&buf)), sz)));

			if (status == (_const_os__success)) {
				Option_string _t1;
				opt_ok(&(string[]) { string_from_wide2(buf, sz) }, (Option*)(&_t1), sizeof(string));
				return _t1;
			}
			else {
				return (Option_string){ .state=2, .err=_v_error(_SLIT("Cannot get file name from handle")), .data={EMPTY_STRUCT_INITIALIZATION} };
			};
		}
	}
	_v_panic(_SLIT("this should be unreachable"));
	VUNREACHABLE();
	return (Option_string){0};
}

VV_LOCAL_SYMBOL voidptr os__ptr_win_get_error_msg(u32 code) {
	voidptr buf = ((voidptr)(0));
	if (code > ((u32)(_const_os__max_error_code))) {
		voidptr _t1 = buf;
		return _t1;
	}
	FormatMessage(((_const_os__format_message_allocate_buffer | _const_os__format_message_from_system) | _const_os__format_message_ignore_inserts), 0, code, MAKELANGID(_const_os__lang_neutral, _const_os__sublang_default), ((voidptr)(&buf)), 0, 0);
	voidptr _t2 = buf;
	return _t2;
}

string os__get_error_msg(int code) {
	if (code < 0) {
		string _t1 = _SLIT("");
		return _t1;
	}
	voidptr ptr_text = os__ptr_win_get_error_msg(((u32)(code)));
	if (ptr_text == 0) {
		string _t2 = _SLIT("");
		return _t2;
	}
	string _t3 = string_from_wide(ptr_text);
	return _t3;
}

os__Result os__execute(string cmd) {
	if (string_contains(cmd, _SLIT(";")) || string_contains(cmd, _SLIT("&&")) || string_contains(cmd, _SLIT("||")) || string_contains(cmd, _SLIT("\n"))) {
		os__Result _t1 = (os__Result){.exit_code = -1,.output = _SLIT(";, &&, || and \\n are not allowed in shell commands"),};
		return _t1;
	}
	u32* child_stdin = ((u32*)(0));
	u32* child_stdout_read = ((u32*)(0));
	u32* child_stdout_write = ((u32*)(0));
	os__SecurityAttributes sa = (os__SecurityAttributes){.n_length = 0,.lp_security_descriptor = 0,.b_inherit_handle = 0,};
	sa.n_length = sizeof(SECURITY_ATTRIBUTES);
	sa.b_inherit_handle = true;
	bool create_pipe_ok = CreatePipe(((voidptr)(&child_stdout_read)), ((voidptr)(&child_stdout_write)), ((voidptr)(&sa)), 0U);
	if (!create_pipe_ok) {
		int error_num = ((int)(GetLastError()));
		string error_msg = os__get_error_msg(error_num);
		os__Result _t2 = (os__Result){.exit_code = error_num,.output =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("exec failed (CreatePipe): "), 0xfe10, {.d_s = error_msg}}, {_SLIT0, 0, { .d_c = 0 }}})),};
		return _t2;
	}
	bool set_handle_info_ok = SetHandleInformation(child_stdout_read, HANDLE_FLAG_INHERIT, 0U);
	if (!set_handle_info_ok) {
		int error_num = ((int)(GetLastError()));
		string error_msg = os__get_error_msg(error_num);
		os__Result _t3 = (os__Result){.exit_code = error_num,.output =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("exec failed (SetHandleInformation): "), 0xfe10, {.d_s = error_msg}}, {_SLIT0, 0, { .d_c = 0 }}})),};
		return _t3;
	}
	os__ProcessInformation proc_info = (os__ProcessInformation){.h_process = 0,.h_thread = 0,.dw_process_id = 0,.dw_thread_id = 0,};
	os__StartupInfo start_info = (os__StartupInfo){
		.cb = sizeof(PROCESS_INFORMATION),
		.lp_reserved = 0,
		.lp_desktop = 0,
		.lp_title = 0,
		.dw_x = 0,
		.dw_y = 0,
		.dw_x_size = 0,
		.dw_y_size = 0,
		.dw_x_count_chars = 0,
		.dw_y_count_chars = 0,
		.dw_fill_attributes = 0,
		.dw_flags = ((u32)(STARTF_USESTDHANDLES)),
		.w_show_window = 0,
		.cb_reserved2 = 0,
		.lp_reserved2 = 0,
		.h_std_input = child_stdin,
		.h_std_output = child_stdout_write,
		.h_std_error = child_stdout_write,
	};
	Array_fixed_u16_32768 command_line = {0};
	ExpandEnvironmentStringsW(string_to_wide(cmd), ((voidptr)(&command_line)), 32768U);
	bool create_process_ok = CreateProcessW(0, &command_line[0], 0, 0, TRUE, 0U, 0, 0, ((voidptr)(&start_info)), ((voidptr)(&proc_info)));
	if (!create_process_ok) {
		int error_num = ((int)(GetLastError()));
		string error_msg = os__get_error_msg(error_num);
		os__Result _t4 = (os__Result){.exit_code = error_num,.output =  str_intp(4, _MOV((StrIntpData[]){{_SLIT("exec failed (CreateProcess) with code "), 0xfe07, {.d_i32 = error_num}}, {_SLIT(": "), 0xfe10, {.d_s = error_msg}}, {_SLIT(" cmd: "), 0xfe10, {.d_s = cmd}}, {_SLIT0, 0, { .d_c = 0 }}})),};
		return _t4;
	}
	CloseHandle(child_stdin);
	CloseHandle(child_stdout_write);
	Array_fixed_byte_4096 buf = {0};
	u32 bytes_read = ((u32)(0U));
	strings__Builder read_data = strings__new_builder(1024);
	for (;;) {
		bool result = false;
		{ // Unsafe block
			result = ReadFile(child_stdout_read, &buf[0], 1000U, ((voidptr)(&bytes_read)), 0);
			strings__Builder_write_ptr(&read_data, &buf[0], ((int)(bytes_read)));
		}
		if (result == false || ((int)(bytes_read)) == 0) {
			break;
		}
	}
	string soutput = string_trim_space(strings__Builder_str(&read_data));
	strings__Builder_free(&read_data);
	u32 exit_code = ((u32)(0U));
	WaitForSingleObject(proc_info.h_process, INFINITE);
	GetExitCodeProcess(proc_info.h_process, ((voidptr)(&exit_code)));
	CloseHandle(proc_info.h_process);
	CloseHandle(proc_info.h_thread);
	os__Result _t5 = (os__Result){.exit_code = ((int)(exit_code)),.output = soutput,};
	return _t5;
}

Option_bool os__symlink(string origin, string target) {
	#if defined(TARGET_IS_64BIT) || defined(TARGET_IS_32BIT)
	{
		int flags = 0;
		if (os__is_dir(origin)) {
			flags ^= 1;
		}
		flags ^= 2;
		int res = CreateSymbolicLinkW(string_to_wide(target), string_to_wide(origin), flags);
		if (res != 1) {
			return (Option_bool){ .state=2, .err=_v_error(os__get_error_msg(((int)(GetLastError())))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		if (!os__exists(target)) {
			return (Option_bool){ .state=2, .err=_v_error(_SLIT("C.CreateSymbolicLinkW reported success, but symlink still does not exist")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		Option_bool _t3;
		opt_ok(&(bool[]) { true }, (Option*)(&_t3), sizeof(bool));
		return _t3;
	}
	#endif
	Option_bool _t4;
	opt_ok(&(bool[]) { false }, (Option*)(&_t4), sizeof(bool));
	return _t4;
}

Option_bool os__link(string origin, string target) {
	int res = CreateHardLinkW(string_to_wide(target), string_to_wide(origin), NULL);
	if (res != 1) {
		return (Option_bool){ .state=2, .err=_v_error(os__get_error_msg(((int)(GetLastError())))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (!os__exists(target)) {
		return (Option_bool){ .state=2, .err=_v_error(_SLIT("C.CreateHardLinkW reported success, but link still does not exist")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Option_bool _t3;
	opt_ok(&(bool[]) { true }, (Option*)(&_t3), sizeof(bool));
	return _t3;
}

void os__File_close(os__File* f) {
	if (!f->is_opened) {
		return;
	}
	f->is_opened = false;
	fflush(f->cfile);
	fclose(f->cfile);
}

// TypeDecl
void os__add_vectored_exception_handler(bool first, int (*handler)(ExceptionPointers* )) {
	AddVectoredExceptionHandler(((u32)(first)), ((PVECTORED_EXCEPTION_HANDLER)(handler)));
}

bool os__debugger_present(void) {
	bool _t1 = IsDebuggerPresent();
	return _t1;
}

os__Uname os__uname(void) {
	Array_string sys_and_ver = string_split(os__execute(_SLIT("cmd /c ver")).output, _SLIT("["));
	string nodename = os__hostname();
	string machine = os__getenv(_SLIT("PROCESSOR_ARCHITECTURE"));
	os__Uname _t1 = (os__Uname){.sysname = string_trim_space((*(string*)/*ee elem_typ */array_get(sys_and_ver, 0))),.nodename = nodename,.release = string_replace((*(string*)/*ee elem_typ */array_get(sys_and_ver, 1)), _SLIT("]"), _SLIT("")),.version = string__plus(string__plus((*(string*)/*ee elem_typ */array_get(sys_and_ver, 0)), _SLIT("[")), (*(string*)/*ee elem_typ */array_get(sys_and_ver, 1))),.machine = machine,};
	return _t1;
}

string os__hostname(void) {
	Array_fixed_u16_255 hostname = {0};
	u32 size = ((u32)(255U));
	bool res = GetComputerNameW(&hostname[0], &size);
	if (!res) {
		string _t1 = os__get_error_msg(((int)(GetLastError())));
		return _t1;
	}
	string _t2 = string_from_wide(&hostname[0]);
	return _t2;
}

string os__loginname(void) {
	Array_fixed_u16_255 loginname = {0};
	u32 size = ((u32)(255U));
	bool res = GetUserNameW(&loginname[0], &size);
	if (!res) {
		string _t1 = os__get_error_msg(((int)(GetLastError())));
		return _t1;
	}
	string _t2 = string_from_wide(&loginname[0]);
	return _t2;
}

Option_bool os__is_writable_folder(string folder) {
	if (!os__exists(folder)) {
		return (Option_bool){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = folder}}, {_SLIT("` does not exist"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (!os__is_dir(folder)) {
		return (Option_bool){ .state=2, .err=_v_error(_SLIT("`folder` is not a folder")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	string tmp_folder_name = string__plus(_SLIT("tmp_perm_check_pid_"), int_str(os__getpid()));
	string tmp_perm_check = os__join_path_single(folder, tmp_folder_name);
	Option_os__File _t3 = os__open_file(tmp_perm_check, _SLIT("w+"), new_array_from_c_array(1, 1, sizeof(int), _MOV((int[1]){0700})));
	if (_t3.state != 0) { /*or block*/ 
		IError err = _t3.err;
		return (Option_bool){ .state=2, .err=_v_error( str_intp(3, _MOV((StrIntpData[]){{_SLIT("cannot write to folder "), 0xfe10, {.d_s = folder}}, {_SLIT(": "), 0xfe10, {.d_s = IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	os__File f =  (*(os__File*)_t3.data);
	os__File_close(&f);
	Option_void _t5 = os__rm(tmp_perm_check);
	if (_t5.state != 0 && _t5.err._typ != _IError_None___index) {
		Option_bool _t6;
		memcpy(&_t6, &_t5, sizeof(Option));
		return _t6;
	}
	
 ;
	Option_bool _t7;
	opt_ok(&(bool[]) { true }, (Option*)(&_t7), sizeof(bool));
	return _t7;
}

// Attr: [inline]
inline int os__getpid(void) {
	int _t1 = _getpid();
	return _t1;
}

// Attr: [inline]
inline int os__getppid(void) {
	int _t1 = 0;
	return _t1;
}

// Attr: [inline]
inline int os__getuid(void) {
	int _t1 = 0;
	return _t1;
}

// Attr: [inline]
inline int os__geteuid(void) {
	int _t1 = 0;
	return _t1;
}

// Attr: [inline]
inline int os__getgid(void) {
	int _t1 = 0;
	return _t1;
}

// Attr: [inline]
inline int os__getegid(void) {
	int _t1 = 0;
	return _t1;
}

void os__posix_set_permission_bit(string path_s, u32 mode, bool enable) {
}

void os__Process_signal_kill(os__Process* p) {
	if (!(p->status == os__ProcessState__running || p->status == os__ProcessState__stopped)) {
		return;
	}
	os__Process__signal_kill(p);
	p->status = os__ProcessState__aborted;
	return;
}

void os__Process_signal_pgkill(os__Process* p) {
	if (!(p->status == os__ProcessState__running || p->status == os__ProcessState__stopped)) {
		return;
	}
	os__Process__signal_pgkill(p);
	return;
}

void os__Process_signal_stop(os__Process* p) {
	if (p->status != os__ProcessState__running) {
		return;
	}
	os__Process__signal_stop(p);
	p->status = os__ProcessState__stopped;
	return;
}

void os__Process_signal_continue(os__Process* p) {
	if (p->status != os__ProcessState__stopped) {
		return;
	}
	os__Process__signal_continue(p);
	p->status = os__ProcessState__running;
	return;
}

void os__Process_wait(os__Process* p) {
	if (p->status == os__ProcessState__not_started) {
		os__Process__spawn(p);
	}
	if (!(p->status == os__ProcessState__running || p->status == os__ProcessState__stopped)) {
		return;
	}
	os__Process__wait(p);
	return;
}

void os__Process_close(os__Process* p) {
	if (p->status == os__ProcessState__not_started || p->status == os__ProcessState__closed) {
		return;
	}
	p->status = os__ProcessState__closed;
}

// Attr: [unsafe]
void os__Process_free(os__Process* p) {
	os__Process_close(p);
	{ // Unsafe block
		string_free(&p->filename);
		string_free(&p->err);
		array_free(&p->args);
		array_free(&p->env);
	}
}

VV_LOCAL_SYMBOL int os__Process__spawn(os__Process* p) {
	if (!p->env_is_custom) {
		p->env = __new_array_with_default(0, 0, sizeof(string), 0);
		Map_string_string current_environment = os__environ();
		int _t2 = current_environment.key_values.len;
		for (int _t1 = 0; _t1 < _t2; ++_t1 ) {
			int _t3 = current_environment.key_values.len - _t2;
			_t2 = current_environment.key_values.len;
			if (_t3 < 0) {
				_t1 = -1;
				continue;
			}
			if (!DenseArray_has_index(&current_environment.key_values, _t1)) {continue;}
			string k = /*key*/ *(string*)DenseArray_key(&current_environment.key_values, _t1);
			k = string_clone(k);
			string v = (*(string*)DenseArray_value(&current_environment.key_values, _t1));
			array_push((array*)&p->env, _MOV((string[]){ string_clone( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = k}}, {_SLIT("="), 0xfe10, {.d_s = v}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
		}
	}
	int pid = 0;
	#if defined(_WIN32)
	{
		pid = os__Process_win_spawn_process(p);
	}
	#else
	{
	}
	#endif
	p->pid = pid;
	p->status = os__ProcessState__running;
	int _t5 = 0;
	return _t5;
}

bool os__Process_is_alive(os__Process* p) {
	if (p->status == os__ProcessState__running || p->status == os__ProcessState__stopped) {
		bool _t1 = os__Process__is_alive(p);
		return _t1;
	}
	bool _t2 = false;
	return _t2;
}

void os__Process_set_redirect_stdio(os__Process* p) {
	p->use_stdio_ctl = true;
	return;
}

void os__Process_stdin_write(os__Process* p, string s) {
	os__Process__check_redirection_call(p, _SLIT("stdin_write"));
	#if defined(_WIN32)
	{
		os__Process_win_write_string(p, 0, s);
	}
	#else
	{
	}
	#endif
}

string os__Process_stdout_slurp(os__Process* p) {
	os__Process__check_redirection_call(p, _SLIT("stdout_slurp"));
	#if defined(_WIN32)
	{
		string _t1 = os__Process_win_slurp(p, 1);
		return _t1;
	}
	#else
	{
	}
	#endif
	return (string){.str=(byteptr)"", .is_lit=1};
}

string os__Process_stderr_slurp(os__Process* p) {
	os__Process__check_redirection_call(p, _SLIT("stderr_slurp"));
	#if defined(_WIN32)
	{
		string _t1 = os__Process_win_slurp(p, 2);
		return _t1;
	}
	#else
	{
	}
	#endif
	return (string){.str=(byteptr)"", .is_lit=1};
}

string os__Process_stdout_read(os__Process* p) {
	os__Process__check_redirection_call(p, _SLIT("stdout_read"));
	#if defined(_WIN32)
	{
		multi_return_string_int mr_3471 = os__Process_win_read_string(p, 1, 4096);
		string s = mr_3471.arg0;
		string _t1 = s;
		return _t1;
	}
	#else
	{
	}
	#endif
	return (string){.str=(byteptr)"", .is_lit=1};
}

string os__Process_stderr_read(os__Process* p) {
	os__Process__check_redirection_call(p, _SLIT("stderr_read"));
	#if defined(_WIN32)
	{
		multi_return_string_int mr_3689 = os__Process_win_read_string(p, 2, 4096);
		string s = mr_3689.arg0;
		string _t1 = s;
		return _t1;
	}
	#else
	{
	}
	#endif
	return (string){.str=(byteptr)"", .is_lit=1};
}

VV_LOCAL_SYMBOL void os__Process__check_redirection_call(os__Process* p, string fn_name) {
	if (!p->use_stdio_ctl) {
		_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Call p.set_redirect_stdio() before calling p."), 0xfe10, {.d_s = fn_name}}, {_SLIT0, 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	if (p->status == os__ProcessState__not_started) {
		_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Call p."), 0xfe10, {.d_s = fn_name}}, {_SLIT("() after you have called p.run()"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
}

VV_LOCAL_SYMBOL void os__Process__signal_stop(os__Process* p) {
	#if defined(_WIN32)
	{
		os__Process_win_stop_process(p);
	}
	#else
	{
	}
	#endif
}

VV_LOCAL_SYMBOL void os__Process__signal_continue(os__Process* p) {
	#if defined(_WIN32)
	{
		os__Process_win_resume_process(p);
	}
	#else
	{
	}
	#endif
}

VV_LOCAL_SYMBOL void os__Process__signal_kill(os__Process* p) {
	#if defined(_WIN32)
	{
		os__Process_win_kill_process(p);
	}
	#else
	{
	}
	#endif
}

VV_LOCAL_SYMBOL void os__Process__signal_pgkill(os__Process* p) {
	#if defined(_WIN32)
	{
		os__Process_win_kill_pgroup(p);
	}
	#else
	{
	}
	#endif
}

VV_LOCAL_SYMBOL void os__Process__wait(os__Process* p) {
	#if defined(_WIN32)
	{
		os__Process_win_wait(p);
	}
	#else
	{
	}
	#endif
}

VV_LOCAL_SYMBOL bool os__Process__is_alive(os__Process* p) {
	#if defined(_WIN32)
	{
		bool _t1 = os__Process_win_is_alive(p);
		return _t1;
	}
	#else
	{
	}
	#endif
	return 0;
}

void os__Process_run(os__Process* p) {
	if (p->status != os__ProcessState__not_started) {
		return;
	}
	os__Process__spawn(p);
	return;
}

os__Process* os__new_process(string filename) {
	os__Process* _t1 = (os__Process*)memdup(&(os__Process){.filename = filename,.pid = 0,.code = -1,.status = os__ProcessState__not_started,.err = (string){.str=(byteptr)"", .is_lit=1},.args = __new_array(0, 0, sizeof(string)),.env_is_custom = 0,.env = __new_array(0, 0, sizeof(string)),.use_stdio_ctl = 0,.use_pgroup = 0,.stdio_fd = {-1, -1, -1},.wdata = 0,}, sizeof(os__Process));
	return _t1;
}

void os__Process_set_args(os__Process* p, Array_string pargs) {
	if (p->status != os__ProcessState__not_started) {
		return;
	}
	p->args = pargs;
	return;
}

void os__Process_set_environment(os__Process* p, Map_string_string envs) {
	if (p->status != os__ProcessState__not_started) {
		return;
	}
	p->env_is_custom = true;
	p->env = __new_array_with_default(0, 0, sizeof(string), 0);
	int _t2 = envs.key_values.len;
	for (int _t1 = 0; _t1 < _t2; ++_t1 ) {
		int _t3 = envs.key_values.len - _t2;
		_t2 = envs.key_values.len;
		if (_t3 < 0) {
			_t1 = -1;
			continue;
		}
		if (!DenseArray_has_index(&envs.key_values, _t1)) {continue;}
		string k = /*key*/ *(string*)DenseArray_key(&envs.key_values, _t1);
		k = string_clone(k);
		string v = (*(string*)DenseArray_value(&envs.key_values, _t1));
		array_push((array*)&p->env, _MOV((string[]){ string_clone( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = k}}, {_SLIT("="), 0xfe10, {.d_s = v}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
	}
	return;
}

// TypeDecl
VV_LOCAL_SYMBOL os__FN_NTSuspendResume os__ntdll_fn(char* name) {
	os__HMODULE ntdll = GetModuleHandleA("NTDLL");
	if (ntdll == 0) {
		os__FN_NTSuspendResume _t1 = (voidptr)((os__FN_NTSuspendResume)(0));
		return _t1;
	}
	void (*the_fn) (voidptr ) = ((os__FN_NTSuspendResume)(GetProcAddress(ntdll, name)));
	os__FN_NTSuspendResume _t2 = (voidptr)the_fn;
	return _t2;
}

VV_LOCAL_SYMBOL void os__failed_cfn_report_error(bool ok, string label) {
	if (ok) {
		return;
	}
	int error_num = ((int)(GetLastError()));
	string error_msg = os__get_error_msg(error_num);
	eprintln( str_intp(3, _MOV((StrIntpData[]){{_SLIT("failed "), 0xfe10, {.d_s = label}}, {_SLIT(": "), 0xfe10, {.d_s = error_msg}}, {_SLIT0, 0, { .d_c = 0 }}})));
	_v_exit(1);
	VUNREACHABLE();
}

// TypeDecl
VV_LOCAL_SYMBOL void os__close_valid_handle(voidptr p) {
	os__PU32* h = ((os__PU32*)(p));
	if (*h != ((u32*)(0))) {
		CloseHandle(*h);
		{ // Unsafe block
			*h = ((u32*)(0));
		}
	}
}

VV_LOCAL_SYMBOL int os__Process_win_spawn_process(os__Process* p) {
	os__WProcess* wdata = (os__WProcess*)memdup(&(os__WProcess){.proc_info = (os__ProcessInformation){.h_process = 0,.h_thread = 0,.dw_process_id = 0,.dw_thread_id = 0,},.command_line = {0},.child_stdin = 0,.child_stdout_read = 0,.child_stdout_write = 0,.child_stderr_read = 0,.child_stderr_write = 0,}, sizeof(os__WProcess));
	p->wdata = ((voidptr)(wdata));
	os__StartupInfo start_info = (os__StartupInfo){.cb = sizeof(PROCESS_INFORMATION),.lp_reserved = 0,.lp_desktop = 0,.lp_title = 0,.dw_x = 0,.dw_y = 0,.dw_x_size = 0,.dw_y_size = 0,.dw_x_count_chars = 0,.dw_y_count_chars = 0,.dw_fill_attributes = 0,.dw_flags = 0,.w_show_window = 0,.cb_reserved2 = 0,.lp_reserved2 = 0,.h_std_input = 0,.h_std_output = 0,.h_std_error = 0,};
	if (p->use_stdio_ctl) {
		os__SecurityAttributes sa = (os__SecurityAttributes){.n_length = 0,.lp_security_descriptor = 0,.b_inherit_handle = 0,};
		sa.n_length = sizeof(SECURITY_ATTRIBUTES);
		sa.b_inherit_handle = true;
		bool create_pipe_ok1 = CreatePipe(((voidptr)(&wdata->child_stdout_read)), ((voidptr)(&wdata->child_stdout_write)), ((voidptr)(&sa)), 0U);
		os__failed_cfn_report_error(create_pipe_ok1, _SLIT("CreatePipe stdout"));
		bool set_handle_info_ok1 = SetHandleInformation(wdata->child_stdout_read, HANDLE_FLAG_INHERIT, 0U);
		os__failed_cfn_report_error(set_handle_info_ok1, _SLIT("SetHandleInformation"));
		bool create_pipe_ok2 = CreatePipe(((voidptr)(&wdata->child_stderr_read)), ((voidptr)(&wdata->child_stderr_write)), ((voidptr)(&sa)), 0U);
		os__failed_cfn_report_error(create_pipe_ok2, _SLIT("CreatePipe stderr"));
		bool set_handle_info_ok2 = SetHandleInformation(wdata->child_stderr_read, HANDLE_FLAG_INHERIT, 0U);
		os__failed_cfn_report_error(set_handle_info_ok2, _SLIT("SetHandleInformation stderr"));
		start_info.h_std_input = wdata->child_stdin;
		start_info.h_std_output = wdata->child_stdout_write;
		start_info.h_std_error = wdata->child_stderr_write;
		start_info.dw_flags = ((u32)(STARTF_USESTDHANDLES));
	}
	string cmd = string__plus( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = p->filename}}, {_SLIT(" "), 0, { .d_c = 0 }}})), Array_string_join(p->args, _SLIT(" ")));
	ExpandEnvironmentStringsW(string_to_wide(cmd), ((voidptr)(&wdata->command_line[0])), 32768U);
	int creation_flags = ((int)(NORMAL_PRIORITY_CLASS));
	if (p->use_pgroup) {
		creation_flags |= CREATE_NEW_PROCESS_GROUP;
	}
	bool create_process_ok = CreateProcessW(0, &wdata->command_line[0], 0, 0, TRUE, creation_flags, 0, 0, ((voidptr)(&start_info)), ((voidptr)(&wdata->proc_info)));
	os__failed_cfn_report_error(create_process_ok, _SLIT("CreateProcess"));
	if (p->use_stdio_ctl) {
		os__close_valid_handle(&wdata->child_stdout_write);
		os__close_valid_handle(&wdata->child_stderr_write);
	}
	p->pid = ((int)(wdata->proc_info.dw_process_id));
	int _t1 = p->pid;
	return _t1;
}

VV_LOCAL_SYMBOL void os__Process_win_stop_process(os__Process* p) {
	void (*the_fn) (voidptr ) = os__ntdll_fn("NtSuspendProcess");
	if (((voidptr)(the_fn)) == 0) {
		return;
	}
	os__WProcess* wdata = ((os__WProcess*)(p->wdata));
	the_fn(wdata->proc_info.h_process);
}

VV_LOCAL_SYMBOL void os__Process_win_resume_process(os__Process* p) {
	void (*the_fn) (voidptr ) = os__ntdll_fn("NtResumeProcess");
	if (((voidptr)(the_fn)) == 0) {
		return;
	}
	os__WProcess* wdata = ((os__WProcess*)(p->wdata));
	the_fn(wdata->proc_info.h_process);
}

VV_LOCAL_SYMBOL void os__Process_win_kill_process(os__Process* p) {
	os__WProcess* wdata = ((os__WProcess*)(p->wdata));
	TerminateProcess(wdata->proc_info.h_process, 3U);
}

VV_LOCAL_SYMBOL void os__Process_win_kill_pgroup(os__Process* p) {
	os__WProcess* wdata = ((os__WProcess*)(p->wdata));
	GenerateConsoleCtrlEvent(CTRL_BREAK_EVENT, wdata->proc_info.dw_process_id);
	Sleep(20U);
	TerminateProcess(wdata->proc_info.h_process, 3U);
}

VV_LOCAL_SYMBOL void os__Process_win_wait(os__Process* p) {
	u32 exit_code = ((u32)(1U));
	os__WProcess* wdata = ((os__WProcess*)(p->wdata));
	if (p->wdata != 0) {
		WaitForSingleObject(wdata->proc_info.h_process, INFINITE);
		GetExitCodeProcess(wdata->proc_info.h_process, ((voidptr)(&exit_code)));
		os__close_valid_handle(&wdata->child_stdin);
		os__close_valid_handle(&wdata->child_stdout_write);
		os__close_valid_handle(&wdata->child_stderr_write);
		os__close_valid_handle(&wdata->proc_info.h_process);
		os__close_valid_handle(&wdata->proc_info.h_thread);
	}
	p->status = os__ProcessState__exited;
	p->code = ((int)(exit_code));
}

VV_LOCAL_SYMBOL bool os__Process_win_is_alive(os__Process* p) {
	u32 exit_code = ((u32)(0U));
	os__WProcess* wdata = ((os__WProcess*)(p->wdata));
	GetExitCodeProcess(wdata->proc_info.h_process, ((voidptr)(&exit_code)));
	if (_us32_eq(exit_code,STILL_ACTIVE)) {
		bool _t1 = true;
		return _t1;
	}
	bool _t2 = false;
	return _t2;
}

VV_LOCAL_SYMBOL void os__Process_win_write_string(os__Process* p, int idx, string s) {
	_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Process.write_string "), 0xfe07, {.d_i32 = idx}}, {_SLIT(" is not implemented yet"), 0, { .d_c = 0 }}})));
	VUNREACHABLE();
}

VV_LOCAL_SYMBOL multi_return_string_int os__Process_win_read_string(os__Process* p, int idx, int maxbytes) {
	_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("WProcess.read_string "), 0xfe07, {.d_i32 = idx}}, {_SLIT(" is not implemented yet"), 0, { .d_c = 0 }}})));
	VUNREACHABLE();
	return (multi_return_string_int){.arg0=_SLIT(""), .arg1=0};
}

VV_LOCAL_SYMBOL string os__Process_win_slurp(os__Process* p, int idx) {
	os__WProcess* wdata = ((os__WProcess*)(p->wdata));
	if (wdata == 0) {
		string _t1 = _SLIT("");
		return _t1;
	}
	u32* rhandle = ((u32*)(0));
	if (idx == 1) {
		rhandle = wdata->child_stdout_read;
	}
	if (idx == 2) {
		rhandle = wdata->child_stderr_read;
	}
	if (rhandle == 0) {
		string _t2 = _SLIT("");
		return _t2;
	}
	u32 bytes_read = ((u32)(0U));
	Array_fixed_byte_4096 buf = {0};
	strings__Builder read_data = strings__new_builder(1024);
	for (;;) {
		bool result = false;
		{ // Unsafe block
			result = ReadFile(rhandle, &buf[0], 1000U, ((voidptr)(&bytes_read)), 0);
			strings__Builder_write_ptr(&read_data, &buf[0], ((int)(bytes_read)));
		}
		if (result == false || ((int)(bytes_read)) == 0) {
			break;
		}
	}
	string soutput = strings__Builder_str(&read_data);
	strings__Builder_free(&read_data);
	if (idx == 1) {
		os__close_valid_handle(&wdata->child_stdout_read);
	}
	if (idx == 2) {
		os__close_valid_handle(&wdata->child_stderr_read);
	}
	string _t3 = soutput;
	return _t3;
}

VV_LOCAL_SYMBOL int os__Process_unix_spawn_process(os__Process* p) {
	int _t1 = 0;
	return _t1;
}

VV_LOCAL_SYMBOL void os__Process_unix_stop_process(os__Process* p) {
}

VV_LOCAL_SYMBOL void os__Process_unix_resume_process(os__Process* p) {
}

VV_LOCAL_SYMBOL void os__Process_unix_kill_process(os__Process* p) {
}

VV_LOCAL_SYMBOL void os__Process_unix_kill_pgroup(os__Process* p) {
}

VV_LOCAL_SYMBOL void os__Process_unix_wait(os__Process* p) {
}

VV_LOCAL_SYMBOL bool os__Process_unix_is_alive(os__Process* p) {
	bool _t1 = false;
	return _t1;
}

Option_os__SignalHandler os__signal_opt(os__Signal signum, void (*handler)(os__Signal )) {
	errno = 0;
	voidptr prev_handler = signal(((int)(signum)), (voidptr)handler);
	if (prev_handler == SIG_ERR) {
		return (Option_os__SignalHandler){ .state=2, .err=error_with_code(os__posix_get_error_msg(EINVAL), EINVAL), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Option_os__SignalHandler _t2;
	opt_ok(&(os__SignalHandler[]) { (voidptr)((os__SignalHandler)(prev_handler)) }, (Option*)(&_t2), sizeof(os__SignalHandler));
	return _t2;
}

// TypeDecl
// TypeDecl
v__depgraph__OrderedDepMap v__depgraph__new_ordered_dependency_map(void) {
	v__depgraph__OrderedDepMap res = (v__depgraph__OrderedDepMap){.keys = __new_array(0, 0, sizeof(string)),.data = new_map(sizeof(string), sizeof(Array_string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),};
	ArrayFlags_set(&res.keys.flags, ArrayFlags__noslices);
	v__depgraph__OrderedDepMap _t1 = res;
	return _t1;
}

void v__depgraph__OrderedDepMap_set(v__depgraph__OrderedDepMap* o, string name, Array_string deps) {
	if (!_IN_MAP(ADDR(string, name), ADDR(map, o->data))) {
		array_push((array*)&o->keys, _MOV((string[]){ string_clone(name) }));
	}
	map_set(&o->data, &(string[]){name}, &(Array_string[]) { deps });
}

void v__depgraph__OrderedDepMap_add(v__depgraph__OrderedDepMap* o, string name, Array_string deps) {
	Array_string d = v__depgraph__OrderedDepMap_get(o, name);
	for (int _t1 = 0; _t1 < deps.len; ++_t1) {
		string dep = ((string*)deps.data)[_t1];
		if (!Array_string_contains(d, dep)) {
			array_push((array*)&d, _MOV((string[]){ string_clone(dep) }));
		} else {
		}
	}
	v__depgraph__OrderedDepMap_set(o, name, d);
}

Array_string v__depgraph__OrderedDepMap_get(v__depgraph__OrderedDepMap* o, string name) {
	Array_string* _t2 = (Array_string*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, o->data), &(string[]){name}));
	Option_Array_string _t1 = {0};
	if (_t2) {
		*((Array_string*)&_t1.data) = *((Array_string*)_t2);
	} else {
		_t1.state = 2; _t1.err = _v_error(_SLIT("array index out of range"));
	}
	;
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		*(Array_string*) _t1.data = __new_array_with_default(0, 0, sizeof(string), 0);
	}
	
	Array_string res = *(Array_string*)_t1.data;
	Array_string _t3 = res;
	return _t3;
}

void v__depgraph__OrderedDepMap_delete(v__depgraph__OrderedDepMap* o, string name) {
	if (!_IN_MAP(ADDR(string, name), ADDR(map, o->data))) {
		_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("delete: no such key: "), 0xfe10, {.d_s = name}}, {_SLIT0, 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	for (int i = 0; i < o->keys.len; ++i) {
		if (string__eq((*(string*)/*ee elem_typ */array_get(o->keys, i)), name)) {
			array_delete(&o->keys, i);
			break;
		}
	}
	map_delete(&o->data, &(string[]){name});
}

void v__depgraph__OrderedDepMap_apply_diff(v__depgraph__OrderedDepMap* o, string name, Array_string deps) {
	Array_string diff = __new_array_with_default(0, 0, sizeof(string), 0);
	Array_string deps_of_name = v__depgraph__OrderedDepMap_get(o, name);
	for (int _t1 = 0; _t1 < deps_of_name.len; ++_t1) {
		string dep = ((string*)deps_of_name.data)[_t1];
		if (!Array_string_contains(deps, dep)) {
			array_push((array*)&diff, _MOV((string[]){ string_clone(dep) }));
		}
	}
	v__depgraph__OrderedDepMap_set(o, name, diff);
}

int v__depgraph__OrderedDepMap_size(v__depgraph__OrderedDepMap* o) {
	int _t1 = o->data.len;
	return _t1;
}

v__depgraph__DepGraph* v__depgraph__new_dep_graph(void) {
	v__depgraph__DepGraph* _t1 = (v__depgraph__DepGraph*)memdup(&(v__depgraph__DepGraph){.acyclic = true,.nodes = __new_array_with_default(0, 1024, sizeof(v__depgraph__DepGraphNode), 0),}, sizeof(v__depgraph__DepGraph));
	return _t1;
}

void v__depgraph__DepGraph_add(v__depgraph__DepGraph* graph, string mod, Array_string deps) {
	v__depgraph__DepGraphNode new_node = (v__depgraph__DepGraphNode){.name = mod,.deps = array_clone_to_depth(&deps, 0),};
	array_push((array*)&graph->nodes, _MOV((v__depgraph__DepGraphNode[]){ new_node }));
}

v__depgraph__DepGraph* v__depgraph__DepGraph_resolve(v__depgraph__DepGraph* graph) {
	v__depgraph__OrderedDepMap node_names = v__depgraph__new_ordered_dependency_map();
	v__depgraph__OrderedDepMap node_deps = v__depgraph__new_ordered_dependency_map();
	for (int _t1 = 0; _t1 < graph->nodes.len; ++_t1) {
		v__depgraph__DepGraphNode node = ((v__depgraph__DepGraphNode*)graph->nodes.data)[_t1];
		v__depgraph__OrderedDepMap_add(&node_names, node.name, node.deps);
		v__depgraph__OrderedDepMap_add(&node_deps, node.name, node.deps);
	}
	int iterations = 0;
	v__depgraph__DepGraph* resolved = v__depgraph__new_dep_graph();
	for (;;) {
		if (!(v__depgraph__OrderedDepMap_size(&node_deps) != 0)) break;
		iterations++;
		Array_string ready_set = __new_array_with_default(0, 0, sizeof(string), 0);
		for (int _t2 = 0; _t2 < node_deps.keys.len; ++_t2) {
			string name = ((string*)node_deps.keys.data)[_t2];
			Array_string deps = v__depgraph__OrderedDepMap_get(&node_deps, name);
			if (deps.len == 0) {
				array_push((array*)&ready_set, _MOV((string[]){ string_clone(name) }));
			}
		}
		if (ready_set.len == 0) {
			v__depgraph__DepGraph* g = v__depgraph__new_dep_graph();
			g->acyclic = false;
			for (int _t4 = 0; _t4 < node_deps.keys.len; ++_t4) {
				string name = ((string*)node_deps.keys.data)[_t4];
				v__depgraph__DepGraph_add(g, name, v__depgraph__OrderedDepMap_get(&node_names, name));
			}
			v__depgraph__DepGraph* _t5 = g;
			return _t5;
		}
		for (int _t6 = 0; _t6 < ready_set.len; ++_t6) {
			string name = ((string*)ready_set.data)[_t6];
			v__depgraph__OrderedDepMap_delete(&node_deps, name);
			Array_string resolved_deps = v__depgraph__OrderedDepMap_get(&node_names, name);
			v__depgraph__DepGraph_add(resolved, name, resolved_deps);
		}
		for (int _t7 = 0; _t7 < node_deps.keys.len; ++_t7) {
			string name = ((string*)node_deps.keys.data)[_t7];
			v__depgraph__OrderedDepMap_apply_diff(&node_deps, name, ready_set);
		}
	}
	v__depgraph__DepGraph* _t8 = resolved;
	return _t8;
}

v__depgraph__DepGraphNode v__depgraph__DepGraph_last_node(v__depgraph__DepGraph* graph) {
	v__depgraph__DepGraphNode _t1 = (*(v__depgraph__DepGraphNode*)/*ee elem_typ */array_get(graph->nodes, graph->nodes.len - 1));
	return _t1;
}

string v__depgraph__DepGraph_display(v__depgraph__DepGraph* graph) {
	Array_string out = __new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t1 = 0; _t1 < graph->nodes.len; ++_t1) {
		v__depgraph__DepGraphNode node = ((v__depgraph__DepGraphNode*)graph->nodes.data)[_t1];
		for (int _t2 = 0; _t2 < node.deps.len; ++_t2) {
			string dep = ((string*)node.deps.data)[_t2];
			array_push((array*)&out, _MOV((string[]){ string_clone( str_intp(3, _MOV((StrIntpData[]){{_SLIT(" * "), 0xfe10, {.d_s = node.name}}, {_SLIT(" -> "), 0xfe10, {.d_s = dep}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
		}
	}
	string _t4 = Array_string_join(out, _SLIT("\n"));
	return _t4;
}

string v__depgraph__DepGraph_display_cycles(v__depgraph__DepGraph* graph) {
	bool seen = false;
	Array_string out = __new_array_with_default(0, 0, sizeof(string), 0);
	v__depgraph__NodeNames nn = (v__depgraph__NodeNames){.is_cycle = new_map(sizeof(string), sizeof(bool), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.names = new_map(sizeof(string), sizeof(Array_string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),};
	for (int _t1 = 0; _t1 < graph->nodes.len; ++_t1) {
		v__depgraph__DepGraphNode node = ((v__depgraph__DepGraphNode*)graph->nodes.data)[_t1];
		map_set(&nn.names, &(string[]){node.name}, &(Array_string[]) { node.deps });
	}
	Map_string_Array_string _t2 = nn.names;
	int _t4 = _t2.key_values.len;
	for (int _t3 = 0; _t3 < _t4; ++_t3 ) {
		int _t5 = _t2.key_values.len - _t4;
		_t4 = _t2.key_values.len;
		if (_t5 < 0) {
			_t3 = -1;
			continue;
		}
		if (!DenseArray_has_index(&_t2.key_values, _t3)) {continue;}
		string k = /*key*/ *(string*)DenseArray_key(&_t2.key_values, _t3);
		k = string_clone(k);
		Array_string cycle_names = __new_array_with_default(0, 0, sizeof(string), 0);
		if (_IN_MAP(ADDR(string, k), ADDR(map, nn.is_cycle))) {
			continue;
		}
		multi_return_bool_Array_string mr_3360 = v__depgraph__NodeNames_is_part_of_cycle(&nn, k, cycle_names);
		seen = mr_3360.arg0;
		cycle_names = mr_3360.arg1;
		if (seen) {
			array_push((array*)&out, _MOV((string[]){ string_clone(string__plus(_SLIT(" * "), Array_string_join(cycle_names, _SLIT(" -> ")))) }));
			nn.is_cycle = new_map(sizeof(string), sizeof(bool), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
		}
	}
	string _t7 = Array_string_join(out, _SLIT("\n"));
	return _t7;
}

VV_LOCAL_SYMBOL multi_return_bool_Array_string v__depgraph__NodeNames_is_part_of_cycle(v__depgraph__NodeNames* nn, string name, Array_string already_seen) {
	bool seen = false;
	Array_string new_already_seen = array_clone_to_depth(&already_seen, 0);
	if (_IN_MAP(ADDR(string, name), ADDR(map, nn->is_cycle))) {
		return (multi_return_bool_Array_string){.arg0=(*(bool*)map_get(ADDR(map, nn->is_cycle), &(string[]){name}, &(bool[]){ 0 })), .arg1=new_already_seen};
	}
	if (Array_string_contains(already_seen, name)) {
		array_push((array*)&new_already_seen, _MOV((string[]){ string_clone(name) }));
		map_set(&nn->is_cycle, &(string[]){name}, &(bool[]) { true });
		return (multi_return_bool_Array_string){.arg0=true, .arg1=new_already_seen};
	}
	array_push((array*)&new_already_seen, _MOV((string[]){ string_clone(name) }));
	Array_string deps = (*(Array_string*)map_get(ADDR(map, nn->names), &(string[]){name}, &(Array_string[]){ __new_array(0, 0, sizeof(string)) }));
	if (deps.len == 0) {
		map_set(&nn->is_cycle, &(string[]){name}, &(bool[]) { false });
		return (multi_return_bool_Array_string){.arg0=false, .arg1=new_already_seen};
	}
	for (int _t6 = 0; _t6 < deps.len; ++_t6) {
		string d = ((string*)deps.data)[_t6];
		Array_string d_already_seen = array_clone_to_depth(&new_already_seen, 0);
		multi_return_bool_Array_string mr_4093 = v__depgraph__NodeNames_is_part_of_cycle(nn, d, d_already_seen);
		seen = mr_4093.arg0;
		d_already_seen = mr_4093.arg1;
		if (seen) {
			new_already_seen = array_clone_to_depth(&d_already_seen, 0);
			map_set(&nn->is_cycle, &(string[]){name}, &(bool[]) { true });
			return (multi_return_bool_Array_string){.arg0=true, .arg1=new_already_seen};
		}
	}
	map_set(&nn->is_cycle, &(string[]){name}, &(bool[]) { false });
	return (multi_return_bool_Array_string){.arg0=false, .arg1=new_already_seen};
}

void v__depgraph__show(v__depgraph__DepGraph* graph, string path) {
	v__dotgraph__DotGraph* dg = v__dotgraph__new(_SLIT("ModGraph"),  str_intp(2, _MOV((StrIntpData[]){{_SLIT("ModGraph for "), 0xfe10, {.d_s = path}}, {_SLIT0, 0, { .d_c = 0 }}})), _SLIT("blue"));
	string mbuiltin = _SLIT("builtin");
	for (int _t1 = 0; _t1 < graph->nodes.len; ++_t1) {
		v__depgraph__DepGraphNode node = ((v__depgraph__DepGraphNode*)graph->nodes.data)[_t1];
		bool is_main = string__eq(node.name, _SLIT("main"));
		v__dotgraph__DotGraph_new_node(dg, node.name, (v__dotgraph__NewNodeConfig){.node_name = (string){.str=(byteptr)"", .is_lit=1},.should_highlight = is_main,.tooltip = (string){.str=(byteptr)"", .is_lit=1},.ctx = ((voidptr)(0)),.name2node_fn = v__dotgraph__node_name,});
		Array_string deps = array_clone_to_depth(&node.deps, 0);
		if (!string__eq(node.name, mbuiltin) && !Array_string_contains(deps, mbuiltin)) {
			array_push((array*)&deps, _MOV((string[]){ string_clone(mbuiltin) }));
		}
		for (int _t3 = 0; _t3 < deps.len; ++_t3) {
			string dep = ((string*)deps.data)[_t3];
			v__dotgraph__DotGraph_new_edge(dg, node.name, dep, (v__dotgraph__NewEdgeConfig){.should_highlight = is_main,.ctx = ((voidptr)(0)),.name2node_fn = v__dotgraph__node_name,});
		}
	}
	v__dotgraph__DotGraph_finish(dg);
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL u32 rand__seed__nr_next(u32 prev) {
	u32 _t1 = prev * 1664525U + 1013904223U;
	return _t1;
}

Array_u32 rand__seed__time_seed_array(int count) {
	u64 ctime = time__sys_mono_now();
	u32 seed = ((u32)((ctime >> 32U ^ ((ctime & 0x00000000FFFFFFFFU)))));
	Array_u32 seed_data = __new_array_with_default(0, count, sizeof(u32), 0);
	for (int _t1 = 0; _t1 < count; ++_t1) {
		seed = rand__seed__nr_next(seed);
		array_push((array*)&seed_data, _MOV((u32[]){ rand__seed__nr_next(seed) }));
	}
	Array_u32 _t3 = seed_data;
	return _t3;
}

// Attr: [manualfree]
u32 rand__seed__time_seed_32(void) {
	Array_u32 sa = rand__seed__time_seed_array(1);
	u32 res = (*(u32*)/*ee elem_typ */array_get(sa, 0));
	array_free(&sa);
	u32 _t1 = res;
	return _t1;
}

// Attr: [manualfree]
u64 rand__seed__time_seed_64(void) {
	Array_u32 seed_data = rand__seed__time_seed_array(2);
	u64 lower = ((u64)((*(u32*)/*ee elem_typ */array_get(seed_data, 0))));
	u64 upper = ((u64)((*(u32*)/*ee elem_typ */array_get(seed_data, 1))));
	array_free(&seed_data);
	u64 res = (lower | (upper << 32U));
	u64 _t1 = res;
	return _t1;
}

string term__format(string msg, string open, string close) {
	string _t1 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\x1b["), 0xfe10, {.d_s = open}}, {_SLIT("m"), 0xfe10, {.d_s = msg}}, {_SLIT("\x1b["), 0xfe10, {.d_s = close}}, {_SLIT("m"), 0, { .d_c = 0 }}}));
	return _t1;
}

string term__format_rgb(int r, int g, int b, string msg, string open, string close) {
	string _t1 =  str_intp(7, _MOV((StrIntpData[]){{_SLIT("\x1b["), 0xfe10, {.d_s = open}}, {_SLIT(";2;"), 0xfe07, {.d_i32 = r}}, {_SLIT(";"), 0xfe07, {.d_i32 = g}}, {_SLIT(";"), 0xfe07, {.d_i32 = b}}, {_SLIT("m"), 0xfe10, {.d_s = msg}}, {_SLIT("\x1b["), 0xfe10, {.d_s = close}}, {_SLIT("m"), 0, { .d_c = 0 }}}));
	return _t1;
}

string term__rgb(int r, int g, int b, string msg) {
	string _t1 = term__format_rgb(r, g, b, msg, _SLIT("38"), _SLIT("39"));
	return _t1;
}

string term__bg_rgb(int r, int g, int b, string msg) {
	string _t1 = term__format_rgb(r, g, b, msg, _SLIT("48"), _SLIT("49"));
	return _t1;
}

string term__hex(int hex, string msg) {
	string _t1 = term__format_rgb(hex >> 16, (hex >> 8 & 0xFF), (hex & 0xFF), msg, _SLIT("38"), _SLIT("39"));
	return _t1;
}

string term__bg_hex(int hex, string msg) {
	string _t1 = term__format_rgb(hex >> 16, (hex >> 8 & 0xFF), (hex & 0xFF), msg, _SLIT("48"), _SLIT("49"));
	return _t1;
}

string term__reset(string msg) {
	string _t1 = term__format(msg, _SLIT("0"), _SLIT("0"));
	return _t1;
}

string term__bold(string msg) {
	string _t1 = term__format(msg, _SLIT("1"), _SLIT("22"));
	return _t1;
}

string term__dim(string msg) {
	string _t1 = term__format(msg, _SLIT("2"), _SLIT("22"));
	return _t1;
}

string term__italic(string msg) {
	string _t1 = term__format(msg, _SLIT("3"), _SLIT("23"));
	return _t1;
}

string term__underline(string msg) {
	string _t1 = term__format(msg, _SLIT("4"), _SLIT("24"));
	return _t1;
}

string term__inverse(string msg) {
	string _t1 = term__format(msg, _SLIT("7"), _SLIT("27"));
	return _t1;
}

string term__hidden(string msg) {
	string _t1 = term__format(msg, _SLIT("8"), _SLIT("28"));
	return _t1;
}

string term__strikethrough(string msg) {
	string _t1 = term__format(msg, _SLIT("9"), _SLIT("29"));
	return _t1;
}

string term__black(string msg) {
	string _t1 = term__format(msg, _SLIT("30"), _SLIT("39"));
	return _t1;
}

string term__red(string msg) {
	string _t1 = term__format(msg, _SLIT("31"), _SLIT("39"));
	return _t1;
}

string term__green(string msg) {
	string _t1 = term__format(msg, _SLIT("32"), _SLIT("39"));
	return _t1;
}

string term__yellow(string msg) {
	string _t1 = term__format(msg, _SLIT("33"), _SLIT("39"));
	return _t1;
}

string term__blue(string msg) {
	string _t1 = term__format(msg, _SLIT("34"), _SLIT("39"));
	return _t1;
}

string term__magenta(string msg) {
	string _t1 = term__format(msg, _SLIT("35"), _SLIT("39"));
	return _t1;
}

string term__cyan(string msg) {
	string _t1 = term__format(msg, _SLIT("36"), _SLIT("39"));
	return _t1;
}

string term__white(string msg) {
	string _t1 = term__format(msg, _SLIT("37"), _SLIT("39"));
	return _t1;
}

string term__bg_black(string msg) {
	string _t1 = term__format(msg, _SLIT("40"), _SLIT("49"));
	return _t1;
}

string term__bg_red(string msg) {
	string _t1 = term__format(msg, _SLIT("41"), _SLIT("49"));
	return _t1;
}

string term__bg_green(string msg) {
	string _t1 = term__format(msg, _SLIT("42"), _SLIT("49"));
	return _t1;
}

string term__bg_yellow(string msg) {
	string _t1 = term__format(msg, _SLIT("43"), _SLIT("49"));
	return _t1;
}

string term__bg_blue(string msg) {
	string _t1 = term__format(msg, _SLIT("44"), _SLIT("49"));
	return _t1;
}

string term__bg_magenta(string msg) {
	string _t1 = term__format(msg, _SLIT("45"), _SLIT("49"));
	return _t1;
}

string term__bg_cyan(string msg) {
	string _t1 = term__format(msg, _SLIT("46"), _SLIT("49"));
	return _t1;
}

string term__bg_white(string msg) {
	string _t1 = term__format(msg, _SLIT("47"), _SLIT("49"));
	return _t1;
}

string term__gray(string msg) {
	string _t1 = term__bright_black(msg);
	return _t1;
}

string term__bright_black(string msg) {
	string _t1 = term__format(msg, _SLIT("90"), _SLIT("39"));
	return _t1;
}

string term__bright_red(string msg) {
	string _t1 = term__format(msg, _SLIT("91"), _SLIT("39"));
	return _t1;
}

string term__bright_green(string msg) {
	string _t1 = term__format(msg, _SLIT("92"), _SLIT("39"));
	return _t1;
}

string term__bright_yellow(string msg) {
	string _t1 = term__format(msg, _SLIT("93"), _SLIT("39"));
	return _t1;
}

string term__bright_blue(string msg) {
	string _t1 = term__format(msg, _SLIT("94"), _SLIT("39"));
	return _t1;
}

string term__bright_magenta(string msg) {
	string _t1 = term__format(msg, _SLIT("95"), _SLIT("39"));
	return _t1;
}

string term__bright_cyan(string msg) {
	string _t1 = term__format(msg, _SLIT("96"), _SLIT("39"));
	return _t1;
}

string term__bright_white(string msg) {
	string _t1 = term__format(msg, _SLIT("97"), _SLIT("39"));
	return _t1;
}

string term__bright_bg_black(string msg) {
	string _t1 = term__format(msg, _SLIT("100"), _SLIT("49"));
	return _t1;
}

string term__bright_bg_red(string msg) {
	string _t1 = term__format(msg, _SLIT("101"), _SLIT("49"));
	return _t1;
}

string term__bright_bg_green(string msg) {
	string _t1 = term__format(msg, _SLIT("102"), _SLIT("49"));
	return _t1;
}

string term__bright_bg_yellow(string msg) {
	string _t1 = term__format(msg, _SLIT("103"), _SLIT("49"));
	return _t1;
}

string term__bright_bg_blue(string msg) {
	string _t1 = term__format(msg, _SLIT("104"), _SLIT("49"));
	return _t1;
}

string term__bright_bg_magenta(string msg) {
	string _t1 = term__format(msg, _SLIT("105"), _SLIT("49"));
	return _t1;
}

string term__bright_bg_cyan(string msg) {
	string _t1 = term__format(msg, _SLIT("106"), _SLIT("49"));
	return _t1;
}

string term__bright_bg_white(string msg) {
	string _t1 = term__format(msg, _SLIT("107"), _SLIT("49"));
	return _t1;
}

string term__highlight_command(string command) {
	string _t1 = term__bright_white(term__bg_cyan( str_intp(2, _MOV((StrIntpData[]){{_SLIT(" "), 0xfe10, {.d_s = command}}, {_SLIT(" "), 0, { .d_c = 0 }}}))));
	return _t1;
}

void term__set_cursor_position(term__Coord c) {
	print(string__plus( str_intp(3, _MOV((StrIntpData[]){{_SLIT("\x1b["), 0xfe07, {.d_i32 = c.y}}, {_SLIT(";"), 0xfe07, {.d_i32 = c.x}}, {_SLIT0, 0, { .d_c = 0 }}})), _SLIT("H")));
}

void term__move(int n, string direction) {
	print( str_intp(3, _MOV((StrIntpData[]){{_SLIT("\x1b["), 0xfe07, {.d_i32 = n}}, {_SLIT0, 0xfe10, {.d_s = direction}}, {_SLIT0, 0, { .d_c = 0 }}})));
}

void term__cursor_up(int n) {
	term__move(n, _SLIT("A"));
}

void term__cursor_down(int n) {
	term__move(n, _SLIT("B"));
}

void term__cursor_forward(int n) {
	term__move(n, _SLIT("C"));
}

void term__cursor_back(int n) {
	term__move(n, _SLIT("D"));
}

void term__erase_display(string t) {
	print(string__plus(string__plus(_SLIT("\x1b["), t), _SLIT("J")));
}

void term__erase_toend(void) {
	term__erase_display(_SLIT("0"));
}

void term__erase_tobeg(void) {
	term__erase_display(_SLIT("1"));
}

void term__erase_clear(void) {
	print(_SLIT("\033[H\033[J"));
}

void term__erase_del_clear(void) {
	term__erase_display(_SLIT("3"));
}

void term__erase_line(string t) {
	print(string__plus(string__plus(_SLIT("\x1b["), t), _SLIT("K")));
}

void term__erase_line_toend(void) {
	term__erase_line(_SLIT("0"));
}

void term__erase_line_tobeg(void) {
	term__erase_line(_SLIT("1"));
}

void term__erase_line_clear(void) {
	term__erase_line(_SLIT("2"));
}

void term__show_cursor(void) {
	print(_SLIT("\x1b[?25h"));
}

void term__hide_cursor(void) {
	print(_SLIT("\x1b[?25l"));
}

void term__clear_previous_line(void) {
	print(_SLIT("\r\x1b[1A\x1b[2K"));
}

bool term__can_show_color_on_stdout(void) {
	bool _t1 = term__supports_escape_sequences(1);
	return _t1;
}

bool term__can_show_color_on_stderr(void) {
	bool _t1 = term__supports_escape_sequences(2);
	return _t1;
}

string term__failed(string s) {
	if (term__can_show_color_on_stdout()) {
		string _t1 = term__bg_red(term__bold(term__white(s)));
		return _t1;
	}
	string _t2 = s;
	return _t2;
}

string term__ok_message(string s) {
	if (term__can_show_color_on_stdout()) {
		string _t1 = term__green( str_intp(2, _MOV((StrIntpData[]){{_SLIT(" "), 0xfe10, {.d_s = s}}, {_SLIT(" "), 0, { .d_c = 0 }}})));
		return _t1;
	}
	string _t2 = s;
	return _t2;
}

string term__fail_message(string s) {
	string _t1 = term__failed( str_intp(2, _MOV((StrIntpData[]){{_SLIT(" "), 0xfe10, {.d_s = s}}, {_SLIT(" "), 0, { .d_c = 0 }}})));
	return _t1;
}

string term__warn_message(string s) {
	if (term__can_show_color_on_stdout()) {
		string _t1 = term__bright_yellow( str_intp(2, _MOV((StrIntpData[]){{_SLIT(" "), 0xfe10, {.d_s = s}}, {_SLIT(" "), 0, { .d_c = 0 }}})));
		return _t1;
	}
	string _t2 = s;
	return _t2;
}

string term__colorize(string (*cfn)(string ), string s) {
	if (term__can_show_color_on_stdout()) {
		string _t1 = cfn(s);
		return _t1;
	}
	string _t2 = s;
	return _t2;
}

string term__strip_ansi(string text) {
	strings__textscanner__TextScanner input = strings__textscanner__new(text);
	Array_byte output = __new_array_with_default(0, text.len, sizeof(byte), 0);
	int ch = 0;
	for (;;) {
		if (!(ch != -1)) break;
		ch = strings__textscanner__TextScanner_next(&input);
		if (ch == 27) {
			ch = strings__textscanner__TextScanner_next(&input);
			if (ch == '[') {
				for (;;) {
					ch = strings__textscanner__TextScanner_next(&input);
					if ((ch == ';' || ch == '?') || (ch >= '0' && ch <= '9')) {
						continue;
					}
					break;
				}
			} else if (ch == ']') {
				ch = strings__textscanner__TextScanner_next(&input);
				if (ch >= '0' && ch <= '9') {
					for (;;) {
						ch = strings__textscanner__TextScanner_next(&input);
						if (ch == -1 || ch == 7) {
							break;
						}
						if (ch == 27) {
							ch = strings__textscanner__TextScanner_next(&input);
							break;
						}
					}
				}
			} else if (ch == '%') {
				ch = strings__textscanner__TextScanner_next(&input);
			}
		} else if (ch != -1) {
			array_push((array*)&output, _MOV((byte[]){ ((byte)(ch)) }));
		}
	}
	string _t2 = Array_byte_bytestr(output);
	return _t2;
}

string term__h_divider(string divider) {
	multi_return_int_int mr_2941 = term__get_terminal_size();
	int cols = mr_2941.arg0;
	string result = _SLIT("");
	if (divider.len > 0) {
		result = string_repeat(divider, 1 + (cols / divider.len));
	} else {
		result = string_repeat(_SLIT(" "), 1 + cols);
	}
	string _t1 = string_substr(result, 0, cols);
	return _t1;
}

string term__header_left(string text, string divider) {
	string plain_text = term__strip_ansi(text);
	multi_return_int_int mr_3386 = term__get_terminal_size();
	int xcols = mr_3386.arg0;
	int cols = term__imax(1, xcols);
	string relement = (divider.len > 0 ? (divider) : (_SLIT(" ")));
	string hstart = string_substr(string_repeat(relement, 4), 0, 4);
	int remaining_cols = (cols - (hstart.len + 1 + plain_text.len + 1));
	string hend = string_substr(string_repeat(relement, (remaining_cols + 1) / relement.len), 0, remaining_cols);
	string _t1 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = hstart}}, {_SLIT(" "), 0xfe10, {.d_s = text}}, {_SLIT(" "), 0xfe10, {.d_s = hend}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t1;
}

string term__header(string text, string divider) {
	if (text.len == 0) {
		string _t1 = term__h_divider(divider);
		return _t1;
	}
	multi_return_int_int mr_3972 = term__get_terminal_size();
	int xcols = mr_3972.arg0;
	int cols = term__imax(1, xcols);
	int tlimit = term__imax(1, (cols > text.len + 2 + 2 * divider.len ? (text.len) : (cols - 3 - 2 * divider.len)));
	int tlimit_alligned = ((tlimit % 2) != (cols % 2) ? (tlimit + 1) : (tlimit));
	int tstart = term__imax(0, (cols - tlimit_alligned) / 2);
	string ln = _SLIT("");
	if (divider.len > 0) {
		ln = string_substr(string_repeat(divider, 1 + cols / divider.len), 0, cols);
	} else {
		ln = string_repeat(_SLIT(" "), 1 + cols);
	}
	if (ln.len == 1) {
		string _t2 = string__plus(string__plus(string__plus(string__plus(ln, _SLIT(" ")), string_substr(text, 0, tlimit)), _SLIT(" ")), ln);
		return _t2;
	}
	string _t3 = string__plus(string__plus(string__plus(string__plus(string_substr(ln, 0, tstart), _SLIT(" ")), string_substr(text, 0, tlimit)), _SLIT(" ")), string_substr(ln, tstart + tlimit + 2, cols));
	return _t3;
}

VV_LOCAL_SYMBOL int term__imax(int x, int y) {
	int _t1 = (x > y ? (x) : (y));
	return _t1;
}

// Attr: [manualfree]
VV_LOCAL_SYMBOL bool term__supports_escape_sequences(int fd) {
bool term__supports_escape_sequences_defer_0 = false;
string vcolors_override;
bool term__supports_escape_sequences_defer_1 = false;
string env_term;
bool term__supports_escape_sequences_defer_2 = false;
string env_conemu;
	vcolors_override = os__getenv(_SLIT("VCOLORS"));
	term__supports_escape_sequences_defer_0 = true;
	if (string__eq(vcolors_override, _SLIT("always"))) {
		bool _t1 = true;
		// Defer begin
		if (term__supports_escape_sequences_defer_0) {
			string_free(&vcolors_override);
		}
		// Defer end
		return _t1;
	}
	if (string__eq(vcolors_override, _SLIT("never"))) {
		bool _t2 = false;
		// Defer begin
		if (term__supports_escape_sequences_defer_0) {
			string_free(&vcolors_override);
		}
		// Defer end
		return _t2;
	}
	env_term = os__getenv(_SLIT("TERM"));
	term__supports_escape_sequences_defer_1 = true;
	if (string__eq(env_term, _SLIT("dumb"))) {
		bool _t3 = false;
		// Defer begin
		if (term__supports_escape_sequences_defer_1) {
			string_free(&env_term);
		}
		// Defer end
		// Defer begin
		if (term__supports_escape_sequences_defer_0) {
			string_free(&vcolors_override);
		}
		// Defer end
		return _t3;
	}
	#if defined(_WIN32)
	{
		env_conemu = os__getenv(_SLIT("ConEmuANSI"));
		term__supports_escape_sequences_defer_2 = true;
		if (string__eq(env_conemu, _SLIT("ON"))) {
			bool _t4 = true;
			// Defer begin
			if (term__supports_escape_sequences_defer_2) {
				#if defined(_WIN32)
					string_free(&env_conemu);
				
				#endif
			}
			// Defer end
			// Defer begin
			if (term__supports_escape_sequences_defer_1) {
				string_free(&env_term);
			}
			// Defer end
			// Defer begin
			if (term__supports_escape_sequences_defer_0) {
				string_free(&vcolors_override);
			}
			// Defer end
			return _t4;
		}
		bool _t5 = ((os__is_atty(fd) & 0x0004)) > 0;
		// Defer begin
		if (term__supports_escape_sequences_defer_2) {
			#if defined(_WIN32)
				string_free(&env_conemu);
			
			#endif
		}
		// Defer end
		// Defer begin
		if (term__supports_escape_sequences_defer_1) {
			string_free(&env_term);
		}
		// Defer end
		// Defer begin
		if (term__supports_escape_sequences_defer_0) {
			string_free(&vcolors_override);
		}
		// Defer end
		return _t5;
	}
	#else
	{
	}
	#endif
	return 0;
}

multi_return_int_int term__get_terminal_size(void) {
	if (os__is_atty(1) > 0 && !string__eq(os__getenv(_SLIT("TERM")), _SLIT("dumb"))) {
		CONSOLE_SCREEN_BUFFER_INFO info = (CONSOLE_SCREEN_BUFFER_INFO){.dwSize = {0},.dwCursorPosition = {0},.wAttributes = 0,.srWindow = {0},.dwMaximumWindowSize = {0},};
		if (GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &info)) {
			int columns = ((int)(info.srWindow.Right - info.srWindow.Left + 1U));
			int rows = ((int)(info.srWindow.Bottom - info.srWindow.Top + 1U));
			return (multi_return_int_int){.arg0=columns, .arg1=rows};
		}
	}
	return (multi_return_int_int){.arg0=_const_term__default_columns_size, .arg1=_const_term__default_rows_size};
}

Option_term__Coord term__get_cursor_position(void) {
	term__Coord res = (term__Coord){.x = 0,.y = 0,};
	if (os__is_atty(1) > 0 && !string__eq(os__getenv(_SLIT("TERM")), _SLIT("dumb"))) {
		CONSOLE_SCREEN_BUFFER_INFO info = (CONSOLE_SCREEN_BUFFER_INFO){.dwSize = {0},.dwCursorPosition = {0},.wAttributes = 0,.srWindow = {0},.dwMaximumWindowSize = {0},};
		if (GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &info)) {
			res.x = info.dwCursorPosition.X;
			res.y = info.dwCursorPosition.Y;
		} else {
			return (Option_term__Coord){ .state=2, .err=os__last_error(), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	Option_term__Coord _t2;
	opt_ok(&(term__Coord[]) { res }, (Option*)(&_t2), sizeof(term__Coord));
	return _t2;
}

bool term__set_terminal_title(string title) {
	bool title_change = SetConsoleTitle(string_to_wide(title));
	bool _t1 = title_change;
	return _t1;
}

void term__clear(void) {
	voidptr hconsole = GetStdHandle(STD_OUTPUT_HANDLE);
	CONSOLE_SCREEN_BUFFER_INFO csbi = (CONSOLE_SCREEN_BUFFER_INFO){.dwSize = {0},.dwCursorPosition = {0},.wAttributes = 0,.srWindow = {0},.dwMaximumWindowSize = {0},};
	SMALL_RECT scrollrect = (SMALL_RECT){.Left = 0,.Top = 0,.Right = 0,.Bottom = 0,};
	COORD scrolltarget = (COORD){.X = 0,.Y = 0,};
	CHAR_INFO fill = (CHAR_INFO){.Char = {0},.Attributes = 0,};
	if (!GetConsoleScreenBufferInfo(hconsole, &csbi)) {
		return;
	}
	scrollrect.Left = 0U;
	scrollrect.Top = 0U;
	scrollrect.Right = ((u16)(csbi.dwSize.X));
	scrollrect.Bottom = ((u16)(csbi.dwSize.Y));
	scrolltarget.X = 0;
	scrolltarget.Y = (0 - csbi.dwSize.Y);
	fill.Char.UnicodeChar = ((rune)(' '));
	fill.Attributes = csbi.wAttributes;
	ScrollConsoleScreenBuffer(hconsole, &scrollrect, NULL, scrolltarget, &fill);
	csbi.dwCursorPosition.X = 0;
	csbi.dwCursorPosition.Y = 0;
	SetConsoleCursorPosition(hconsole, csbi.dwCursorPosition);
}

string v__util__version__vhash(void) {
	Array_fixed_byte_50 buf = {0};
	buf[0] = 0;
	{ // Unsafe block
		byte* bp = &buf[0];
		snprintf(((char*)(bp)), 50, "%s", V_COMMIT_HASH);
		string _t1 = tos_clone(bp);
		return _t1;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

string v__util__version__full_hash(void) {
	string build_hash = v__util__version__vhash();
	string current_hash = v__util__version__githash(false);
	if (string__eq(build_hash, current_hash)) {
		string _t1 = build_hash;
		return _t1;
	}
	string _t2 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = build_hash}}, {_SLIT("."), 0xfe10, {.d_s = current_hash}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t2;
}

string v__util__version__full_v_version(bool is_verbose) {
	if (is_verbose) {
		string _t1 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("V "), 0xfe10, {.d_s = _const_v__util__version__v_version}}, {_SLIT(" "), 0xfe10, {.d_s = v__util__version__full_hash()}}, {_SLIT0, 0, { .d_c = 0 }}}));
		return _t1;
	}
	string hash = v__util__version__githash(false);
	string _t2 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("V "), 0xfe10, {.d_s = _const_v__util__version__v_version}}, {_SLIT(" "), 0xfe10, {.d_s = hash}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t2;
}

string v__util__version__githash(bool should_get_from_filesystem) {
	for (;;) {
		if (should_get_from_filesystem) {
			string vexe = os__getenv(_SLIT("VEXE"));
			string vroot = os__dir(vexe);
			string git_head_file = os__join_path(vroot, new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT(".git"), _SLIT("HEAD")})));
			if (!os__exists(git_head_file)) {
				break;
			}
			Option_string _t1 = os__read_file(git_head_file);
			if (_t1.state != 0) { /*or block*/ 
				IError err = _t1.err;
				break;
			}
			
 			string head_content =  (*(string*)_t1.data);
			string current_branch_hash = head_content;
			if (string_starts_with(head_content, _SLIT("ref: "))) {
				string gcbranch_rel_path = string_trim_space(string_replace(head_content, _SLIT("ref: "), _SLIT("")));
				string gcbranch_file = os__join_path(vroot, new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT(".git"), gcbranch_rel_path})));
				if (!os__exists(gcbranch_file)) {
					break;
				}
				Option_string _t2 = os__read_file(gcbranch_file);
				if (_t2.state != 0) { /*or block*/ 
					IError err = _t2.err;
					break;
				}
				
 				string branch_hash =  (*(string*)_t2.data);
				current_branch_hash = branch_hash;
			}
			int desired_hash_length = 7;
			if (current_branch_hash.len > desired_hash_length) {
				string _t3 = string_substr(current_branch_hash, 0, desired_hash_length);
				return _t3;
			}
		}
		break;
	}
	Array_fixed_byte_50 buf = {0};
	buf[0] = 0;
	{ // Unsafe block
		byte* bp = &buf[0];
		snprintf(((char*)(bp)), 50, "%s", V_CURRENT_COMMIT_HASH);
		string _t4 = tos_clone(bp);
		return _t4;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

v__vcache__CacheManager v__vcache__new_cache_manager(Array_string opts) {
	string vcache_basepath = os__getenv(_SLIT("VCACHE"));
	if ((vcache_basepath).len == 0) {
		vcache_basepath = os__join_path(os__vmodules_dir(), new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("cache")})));
	}
	;
	if (!os__is_dir(vcache_basepath)) {
		Option_void _t1 = os__mkdir_all(vcache_basepath);
		if (_t1.state != 0 && _t1.err._typ != _IError_None___index) {
			IError err = _t1.err;
			_v_panic(IError_str(err));
			VUNREACHABLE();
		;
		}
		
 ;
		;
	}
	string readme_file = os__join_path(vcache_basepath, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("README.md")})));
	if (!os__is_file(readme_file)) {
		string readme_content = string_strip_margin(_SLIT("This folder contains cached build artifacts from the V build system.\n		|You can safely delete it, if it is getting too large.\n		|It will be recreated the next time you compile something with V.\n		|You can change its location with the VCACHE environment variable.\n		"));
		Option_void _t2 = os__write_file(readme_file, readme_content);
		if (_t2.state != 0 && _t2.err._typ != _IError_None___index) {
			IError err = _t2.err;
			_v_panic(IError_str(err));
			VUNREACHABLE();
		;
		}
		
 ;
		;
	}
	string original_vopts = Array_string_join(opts, _SLIT("|"));
	v__vcache__CacheManager _t3 = (v__vcache__CacheManager){.basepath = vcache_basepath,.original_vopts = original_vopts,.vopts = original_vopts,.k2cpath = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),};
	return _t3;
}

void v__vcache__CacheManager_set_temporary_options(v__vcache__CacheManager* cm, Array_string new_opts) {
	cm->vopts = string__plus(string__plus(cm->original_vopts, _SLIT("#")), Array_string_join(new_opts, _SLIT("|")));
	;
}

string v__vcache__CacheManager_key2cpath(v__vcache__CacheManager* cm, string key) {
	string* _t2 = (string*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, cm->k2cpath), &(string[]){key}));
	Option_string _t1 = {0};
	if (_t2) {
		*((string*)&_t1.data) = *((string*)_t2);
	} else {
		_t1.state = 2; _t1.err = _v_error(_SLIT("array index out of range"));
	}
	;
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		*(string*) _t1.data = _SLIT("");
	}
	
	string cpath = *(string*)_t1.data;
	if ((cpath).len == 0) {
		string hk = string__plus(cm->vopts, key);
		string a = u64_hex_full(hash__sum64_string(hk, 5U));
		string b = u64_hex_full(hash__sum64_string(hk, 7U));
		string khash = string__plus(a, b);
		string prefix = string_substr(khash, 0, 2);
		string cprefix_folder = os__join_path(cm->basepath, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){prefix})));
		cpath = os__join_path(cprefix_folder, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){khash})));
		if (!os__is_dir(cprefix_folder)) {
			Option_void _t3 = os__mkdir_all(cprefix_folder);
			if (_t3.state != 0 && _t3.err._typ != _IError_None___index) {
				IError err = _t3.err;
				_v_panic(IError_str(err));
				VUNREACHABLE();
			;
			}
			
 ;
			Option_void _t4 = os__chmod(cprefix_folder, 0777);
			if (_t4.state != 0 && _t4.err._typ != _IError_None___index) {
				IError err = _t4.err;
				_v_panic(IError_str(err));
				VUNREACHABLE();
			;
			}
			
 ;
		}
		;
		;
		;
		;
		map_set(&cm->k2cpath, &(string[]){key}, &(string[]) { cpath });
	}
	;
	string _t5 = cpath;
	return _t5;
}

string v__vcache__CacheManager_postfix_with_key2cpath(v__vcache__CacheManager* cm, string postfix, string key) {
	string prefix = v__vcache__CacheManager_key2cpath(cm, key);
	string res = string__plus(prefix, postfix);
	string _t1 = res;
	return _t1;
}

Option_string v__vcache__CacheManager_exists(v__vcache__CacheManager* cm, string postfix, string key) {
	string fpath = v__vcache__CacheManager_postfix_with_key2cpath(cm, postfix, key);
	;
	if (!os__exists(fpath)) {
		return (Option_string){ .state=2, .err=_v_error(_SLIT("does not exist yet")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Option_string _t2;
	opt_ok(&(string[]) { fpath }, (Option*)(&_t2), sizeof(string));
	return _t2;
}

Option_string v__vcache__CacheManager_save(v__vcache__CacheManager* cm, string postfix, string key, string content) {
	string fpath = v__vcache__CacheManager_postfix_with_key2cpath(cm, postfix, key);
	Option_void _t1 = os__write_file(fpath, content);
	if (_t1.state != 0 && _t1.err._typ != _IError_None___index) {
		Option_string _t2;
		memcpy(&_t2, &_t1, sizeof(Option));
		return _t2;
	}
	
 ;
	;
	Option_string _t3;
	opt_ok(&(string[]) { fpath }, (Option*)(&_t3), sizeof(string));
	return _t3;
}

Option_string v__vcache__CacheManager_load(v__vcache__CacheManager* cm, string postfix, string key) {
	Option_string _t1 = v__vcache__CacheManager_exists(cm, postfix, key);
	if (_t1.state != 0) { /*or block*/ 
		Option_string _t2;
		memcpy(&_t2, &_t1, sizeof(Option));
		return _t2;
	}
	
 	string fpath =  (*(string*)_t1.data);
	Option_string _t3 = os__read_file(fpath);
	if (_t3.state != 0) { /*or block*/ 
		Option_string _t4;
		memcpy(&_t4, &_t3, sizeof(Option));
		return _t4;
	}
	
 	string content =  (*(string*)_t3.data);
	;
	Option_string _t5;
	opt_ok(&(string[]) { content }, (Option*)(&_t5), sizeof(string));
	return _t5;
}

// Attr: [unsafe]
VV_LOCAL_SYMBOL int v__vcache__mypid(void) {
	static int pid = 0;
	if (pid == 0) {
		pid = os__getpid();
	}
	int _t1 = pid;
	return _t1;
}

Option_string v__util__diff__find_working_diff_command(void) {
	string env_difftool = os__getenv(_SLIT("VDIFF_TOOL"));
	string env_diffopts = os__getenv(_SLIT("VDIFF_OPTIONS"));
	if ((env_difftool).len != 0) {
		Option_string _t1;
		opt_ok(&(string[]) {  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = env_difftool}}, {_SLIT(" "), 0xfe10, {.d_s = env_diffopts}}, {_SLIT0, 0, { .d_c = 0 }}})) }, (Option*)(&_t1), sizeof(string));
		return _t1;
	}
	Array_string known_diff_tools = __new_array_with_default(0, 0, sizeof(string), 0);
	if (env_difftool.len > 0) {
		array_push((array*)&known_diff_tools, _MOV((string[]){ string_clone(env_difftool) }));
	}
	_PUSH_MANY(&known_diff_tools, (new_array_from_c_array(8, 8, sizeof(string), _MOV((string[8]){_SLIT("colordiff"), _SLIT("gdiff"), _SLIT("diff"), _SLIT("colordiff.exe"), _SLIT("diff.exe"), _SLIT("opendiff"), _SLIT("code"), _SLIT("code.cmd")}))), _t3, Array_string);
	for (int _t4 = 0; _t4 < known_diff_tools.len; ++_t4) {
		string diffcmd = ((string*)known_diff_tools.data)[_t4];
		if (string__eq(diffcmd, _SLIT("opendiff"))) {
			if (v__util__diff__opendiff_exists()) {
				Option_string _t5;
				opt_ok(&(string[]) { diffcmd }, (Option*)(&_t5), sizeof(string));
				return _t5;
			}
			continue;
		}
		os__Result p = os__execute( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = diffcmd}}, {_SLIT(" --version"), 0, { .d_c = 0 }}})));
		if (p.exit_code < 0) {
			continue;
		}
		if (p.exit_code == 127 && string__eq(diffcmd, env_difftool)) {
			return (Option_string){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("could not find specified VDIFF_TOOL "), 0xfe10, {.d_s = diffcmd}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		if (p.exit_code == 0) {
			if (string__eq(diffcmd, _SLIT("code")) || string__eq(diffcmd, _SLIT("code.cmd"))) {
				Option_string _t7;
				opt_ok(&(string[]) {  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = diffcmd}}, {_SLIT(" "), 0xfe10, {.d_s = env_diffopts}}, {_SLIT(" -d"), 0, { .d_c = 0 }}})) }, (Option*)(&_t7), sizeof(string));
				return _t7;
			}
			Option_string _t8;
			opt_ok(&(string[]) {  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = diffcmd}}, {_SLIT(" "), 0xfe10, {.d_s = env_diffopts}}, {_SLIT0, 0, { .d_c = 0 }}})) }, (Option*)(&_t8), sizeof(string));
			return _t8;
		}
	}
	return (Option_string){ .state=2, .err=_v_error(_SLIT("No working \"diff\" command found")), .data={EMPTY_STRUCT_INITIALIZATION} };
}

VV_LOCAL_SYMBOL bool v__util__diff__opendiff_exists(void) {
	os__Result o = os__execute(_SLIT("opendiff"));
	if (o.exit_code < 0) {
		bool _t1 = false;
		return _t1;
	}
	if (o.exit_code == 1) {
		if (string_contains(o.output, _SLIT("too few arguments"))) {
			bool _t2 = true;
			return _t2;
		}
	}
	bool _t3 = false;
	return _t3;
}

string v__util__diff__color_compare_files(string diff_cmd, string file1, string file2) {
	if ((diff_cmd).len != 0) {
		string full_cmd =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = diff_cmd}}, {_SLIT(" --minimal --text --unified=2  --show-function-line=\"fn \" \""), 0xfe10, {.d_s = file1}}, {_SLIT("\" \""), 0xfe10, {.d_s = file2}}, {_SLIT("\" "), 0, { .d_c = 0 }}}));
		os__Result x = os__execute(full_cmd);
		if (x.exit_code < 0) {
			string _t1 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("comparison command: `"), 0xfe10, {.d_s = full_cmd}}, {_SLIT("` not found"), 0, { .d_c = 0 }}}));
			return _t1;
		}
		string _t2 = string_trim_right(x.output, _SLIT("\r\n"));
		return _t2;
	}
	string _t3 = _SLIT("");
	return _t3;
}

string v__util__diff__color_compare_strings(string diff_cmd, string unique_prefix, string expected, string found) {
	string cdir = os__join_path_single(os__cache_dir(), unique_prefix);
	Option_bool _t1 = os__mkdir(cdir);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
	}
	
  (*(bool*)_t1.data);
	u64 ctime = time__sys_mono_now();
	string e_file = os__join_path_single(cdir,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe08, {.d_u64 = ctime}}, {_SLIT(".expected.txt"), 0, { .d_c = 0 }}})));
	string f_file = os__join_path_single(cdir,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe08, {.d_u64 = ctime}}, {_SLIT(".found.txt"), 0, { .d_c = 0 }}})));
	Option_void _t2 = os__write_file(e_file, expected);
	if (_t2.state != 0 && _t2.err._typ != _IError_None___index) {
		IError err = _t2.err;
		_v_panic(IError_str(err));
		VUNREACHABLE();
	;
	}
	
 ;
	Option_void _t3 = os__write_file(f_file, found);
	if (_t3.state != 0 && _t3.err._typ != _IError_None___index) {
		IError err = _t3.err;
		_v_panic(IError_str(err));
		VUNREACHABLE();
	;
	}
	
 ;
	string res = v__util__diff__color_compare_files(diff_cmd, e_file, f_file);
	Option_void _t4 = os__rmdir_all(cdir);
	if (_t4.state != 0 && _t4.err._typ != _IError_None___index) {
		IError err = _t4.err;
	}
	
 ;
	string _t5 = res;
	return _t5;
}

Option_v__vmod__Manifest v__vmod__from_file(string vmod_path) {
	if (!os__exists(vmod_path)) {
		return (Option_v__vmod__Manifest){ .state=2, .err=_v_error(_SLIT("v.mod: v.mod file not found.")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Option_string _t2 = os__read_file(vmod_path);
	if (_t2.state != 0) { /*or block*/ 
		IError err = _t2.err;
		*(string*) _t2.data = _SLIT("");
	}
	
 	string contents =  (*(string*)_t2.data);
	Option_v__vmod__Manifest _t3 = v__vmod__decode(contents);
	return _t3;
}

Option_v__vmod__Manifest v__vmod__decode(string contents) {
	v__vmod__Parser parser = (v__vmod__Parser){.file_path = (string){.str=(byteptr)"", .is_lit=1},.scanner = (v__vmod__Scanner){.pos = 0,.text = contents,.inside_text = 0,.tokens = __new_array(0, 0, sizeof(v__vmod__Token)),},};
	Option_v__vmod__Manifest _t1 = v__vmod__Parser_parse(&parser);
	return _t1;
}

VV_LOCAL_SYMBOL void v__vmod__Scanner_tokenize(v__vmod__Scanner* s, v__vmod__TokenKind t_type, string val) {
	array_push((array*)&s->tokens, _MOV((v__vmod__Token[]){ (v__vmod__Token){.typ = t_type,.val = val,} }));
}

VV_LOCAL_SYMBOL void v__vmod__Scanner_skip_whitespace(v__vmod__Scanner* s) {
	for (;;) {
		if (!(s->pos < s->text.len && byte_is_space(string_at(s->text, s->pos)))) break;
		s->pos++;
	}
}

VV_LOCAL_SYMBOL bool v__vmod__is_name_alpha(byte chr) {
	bool _t1 = byte_is_letter(chr) || chr == '_';
	return _t1;
}

VV_LOCAL_SYMBOL string v__vmod__Scanner_create_string(v__vmod__Scanner* s, byte q) {
	string str = _SLIT("");
	for (;;) {
		if (!(string_at(s->text, s->pos) != q)) break;
		if (string_at(s->text, s->pos) == '\\' && string_at(s->text, s->pos + 1) == q) {
			str = /*f*/string__plus(str, string_substr(s->text, s->pos, s->pos + 1));
			s->pos += 2;
		} else {
			str = /*f*/string__plus(str, byte_ascii_str(string_at(s->text, s->pos)));
			s->pos++;
		}
	}
	string _t1 = str;
	return _t1;
}

VV_LOCAL_SYMBOL string v__vmod__Scanner_create_ident(v__vmod__Scanner* s) {
	string text = _SLIT("");
	for (;;) {
		if (!(v__vmod__is_name_alpha(string_at(s->text, s->pos)))) break;
		text = /*f*/string__plus(text, byte_ascii_str(string_at(s->text, s->pos)));
		s->pos++;
	}
	string _t1 = text;
	return _t1;
}

VV_LOCAL_SYMBOL bool v__vmod__Scanner_peek_char(v__vmod__Scanner s, byte c) {
	bool _t1 = s.pos - 1 < s.text.len && string_at(s.text, s.pos - 1) == c;
	return _t1;
}

VV_LOCAL_SYMBOL void v__vmod__Scanner_scan_all(v__vmod__Scanner* s) {
	for (;;) {
		if (!(s->pos < s->text.len)) break;
		byte c = string_at(s->text, s->pos);
		if (byte_is_space(c) || c == '\\') {
			s->pos++;
			continue;
		}
		if (v__vmod__is_name_alpha(c)) {
			string name = v__vmod__Scanner_create_ident(s);
			if (string__eq(name, _SLIT("Module"))) {
				v__vmod__Scanner_tokenize(s, v__vmod__TokenKind__module_keyword, name);
				s->pos++;
				continue;
			} else if (string_at(s->text, s->pos) == ':') {
				v__vmod__Scanner_tokenize(s, v__vmod__TokenKind__field_key, string__plus(name, _SLIT(":")));
				s->pos += 2;
				continue;
			} else {
				v__vmod__Scanner_tokenize(s, v__vmod__TokenKind__ident, name);
				s->pos++;
				continue;
			}
		}
		if ((c == '\'' || c == '\"') && !v__vmod__Scanner_peek_char(/*rec*/*s, '\\')) {
			s->pos++;
			string str = v__vmod__Scanner_create_string(s, c);
			v__vmod__Scanner_tokenize(s, v__vmod__TokenKind__str, str);
			s->pos++;
			continue;
		}

		if (c == ('{')) {
			v__vmod__Scanner_tokenize(s, v__vmod__TokenKind__lcbr, byte_ascii_str(c));
		}
		else if (c == ('}')) {
			v__vmod__Scanner_tokenize(s, v__vmod__TokenKind__rcbr, byte_ascii_str(c));
		}
		else if (c == ('[')) {
			v__vmod__Scanner_tokenize(s, v__vmod__TokenKind__labr, byte_ascii_str(c));
		}
		else if (c == (']')) {
			v__vmod__Scanner_tokenize(s, v__vmod__TokenKind__rabr, byte_ascii_str(c));
		}
		else if (c == (':')) {
			v__vmod__Scanner_tokenize(s, v__vmod__TokenKind__colon, byte_ascii_str(c));
		}
		else if (c == (',')) {
			v__vmod__Scanner_tokenize(s, v__vmod__TokenKind__comma, byte_ascii_str(c));
		}
		else {
			v__vmod__Scanner_tokenize(s, v__vmod__TokenKind__unknown, byte_ascii_str(c));
		};
		s->pos++;
	}
	v__vmod__Scanner_tokenize(s, v__vmod__TokenKind__eof, _SLIT("eof"));
}

VV_LOCAL_SYMBOL Option_multi_return_Array_string_int v__vmod__get_array_content(Array_v__vmod__Token tokens, int st_idx) {
	Array_string vals = __new_array_with_default(0, 0, sizeof(string), 0);
	int idx = st_idx;
	if ((*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, idx)).typ != v__vmod__TokenKind__labr) {
		return (Option_multi_return_Array_string_int){ .state=2, .err=_v_error(_SLIT("vmod: not a valid array")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	idx++;
	for (;;) {
		v__vmod__Token tok = (*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, idx));

		if (tok.typ == (v__vmod__TokenKind__str)) {
			array_push((array*)&vals, _MOV((string[]){ string_clone(tok.val) }));
			if (!((*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, idx + 1)).typ == v__vmod__TokenKind__comma || (*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, idx + 1)).typ == v__vmod__TokenKind__rabr)) {
				return (Option_multi_return_Array_string_int){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("vmod: invalid separator \""), 0xfe10, {.d_s = (*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, idx + 1)).val}}, {_SLIT("\""), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			idx += ((*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, idx + 1)).typ == v__vmod__TokenKind__comma ? (2) : (1));
		}
		else if (tok.typ == (v__vmod__TokenKind__rabr)) {
			idx++;
			break;
		}
		else {
			return (Option_multi_return_Array_string_int){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("vmod: invalid token \""), 0xfe10, {.d_s = tok.val}}, {_SLIT("\""), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		};
	}
	Option_multi_return_Array_string_int _t5;
	opt_ok(&(multi_return_Array_string_int/*X*/[]) { (multi_return_Array_string_int){.arg0=vals, .arg1=idx} }, (Option*)(&_t5), sizeof(multi_return_Array_string_int));
	return _t5;
}

VV_LOCAL_SYMBOL Option_v__vmod__Manifest v__vmod__Parser_parse(v__vmod__Parser* p) {
	string err_label = _SLIT("vmod:");
	if (p->scanner.text.len == 0) {
		return (Option_v__vmod__Manifest){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = err_label}}, {_SLIT(" no content."), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	v__vmod__Scanner_scan_all(&p->scanner);
	Array_v__vmod__Token tokens = p->scanner.tokens;
	v__vmod__Manifest mn = (v__vmod__Manifest){.name = (string){.str=(byteptr)"", .is_lit=1},.version = (string){.str=(byteptr)"", .is_lit=1},.description = (string){.str=(byteptr)"", .is_lit=1},.dependencies = __new_array(0, 0, sizeof(string)),.license = (string){.str=(byteptr)"", .is_lit=1},.repo_url = (string){.str=(byteptr)"", .is_lit=1},.author = (string){.str=(byteptr)"", .is_lit=1},.unknown = new_map(sizeof(string), sizeof(Array_string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),};
	if ((*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, 0)).typ != v__vmod__TokenKind__module_keyword) {
		return (Option_v__vmod__Manifest){ .state=2, .err=_v_error(_SLIT("vmod: v.mod files should start with Module")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	int i = 1;
	for (;;) {
		if (!(i < tokens.len)) break;
		v__vmod__Token tok = (*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, i));

		if (tok.typ == (v__vmod__TokenKind__lcbr)) {
			if (!((*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, i + 1)).typ == v__vmod__TokenKind__field_key || (*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, i + 1)).typ == v__vmod__TokenKind__rcbr)) {
				return (Option_v__vmod__Manifest){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = err_label}}, {_SLIT(" invalid content after opening brace"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			i++;
			continue;
		}
		else if (tok.typ == (v__vmod__TokenKind__rcbr)) {
			break;
		}
		else if (tok.typ == (v__vmod__TokenKind__field_key)) {
			string field_name = string_trim_right(tok.val, _SLIT(":"));
			if (!((*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, i + 1)).typ == v__vmod__TokenKind__str || (*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, i + 1)).typ == v__vmod__TokenKind__labr)) {
				return (Option_v__vmod__Manifest){ .state=2, .err=_v_error( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = err_label}}, {_SLIT(" value of field \""), 0xfe10, {.d_s = field_name}}, {_SLIT("\" must be either string or an array of strings"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			string field_value = (*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, i + 1)).val;

			if (string__eq(field_name, _SLIT("name"))) {
				mn.name = field_value;
			}
			else if (string__eq(field_name, _SLIT("version"))) {
				mn.version = field_value;
			}
			else if (string__eq(field_name, _SLIT("license"))) {
				mn.license = field_value;
			}
			else if (string__eq(field_name, _SLIT("repo_url"))) {
				mn.repo_url = field_value;
			}
			else if (string__eq(field_name, _SLIT("description"))) {
				mn.description = field_value;
			}
			else if (string__eq(field_name, _SLIT("author"))) {
				mn.author = field_value;
			}
			else if (string__eq(field_name, _SLIT("dependencies"))) {
				Option_multi_return_Array_string_int _t5 = v__vmod__get_array_content(tokens, i + 1);
				if (_t5.state != 0) { /*or block*/ 
					Option_v__vmod__Manifest _t6;
					memcpy(&_t6, &_t5, sizeof(Option));
					return _t6;
				}
				
 				Option_multi_return_Array_string_int mr_4490 =  _t5 /*U*/;
				Array_string deps = (*(multi_return_Array_string_int*)mr_4490.data).arg0;
				int idx = (*(multi_return_Array_string_int*)mr_4490.data).arg1;
				mn.dependencies = deps;
				i = idx;
				continue;
			}
			else {
				if ((*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, i + 1)).typ == v__vmod__TokenKind__labr) {
					Option_multi_return_Array_string_int _t7 = v__vmod__get_array_content(tokens, i + 1);
					if (_t7.state != 0) { /*or block*/ 
						Option_v__vmod__Manifest _t8;
						memcpy(&_t8, &_t7, sizeof(Option));
						return _t8;
					}
					
 					Option_multi_return_Array_string_int mr_4660 =  _t7 /*U*/;
					Array_string vals = (*(multi_return_Array_string_int*)mr_4660.data).arg0;
					int idx = (*(multi_return_Array_string_int*)mr_4660.data).arg1;
					map_set(&mn.unknown, &(string[]){field_name}, &(Array_string[]) { vals });
					i = idx;
					continue;
				}
				map_set(&mn.unknown, &(string[]){field_name}, &(Array_string[]) { new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){string_clone(field_value)})) });
			};
			i += 2;
			continue;
		}
		else if (tok.typ == (v__vmod__TokenKind__comma)) {
			if (!((*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, i - 1)).typ == v__vmod__TokenKind__str || (*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, i - 1)).typ == v__vmod__TokenKind__rabr) || (*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, i + 1)).typ != v__vmod__TokenKind__field_key) {
				return (Option_v__vmod__Manifest){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = err_label}}, {_SLIT(" invalid comma placement"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			i++;
			continue;
		}
		else {
			return (Option_v__vmod__Manifest){ .state=2, .err=_v_error( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = err_label}}, {_SLIT(" invalid token \""), 0xfe10, {.d_s = tok.val}}, {_SLIT("\""), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		};
	}
	Option_v__vmod__Manifest _t11;
	opt_ok(&(v__vmod__Manifest[]) { mn }, (Option*)(&_t11), sizeof(v__vmod__Manifest));
	return _t11;
}

v__vmod__ModFileCacher* v__vmod__new_mod_file_cacher(void) {
	v__vmod__ModFileCacher* _t1 = (v__vmod__ModFileCacher*)memdup(&(v__vmod__ModFileCacher){.cache = new_map(sizeof(string), sizeof(v__vmod__ModFileAndFolder), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.folder_files = new_map(sizeof(string), sizeof(Array_string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),}, sizeof(v__vmod__ModFileCacher));
	return _t1;
}

void v__vmod__ModFileCacher_debug(v__vmod__ModFileCacher* mcache) {
}

v__vmod__ModFileAndFolder v__vmod__ModFileCacher_get_by_file(v__vmod__ModFileCacher* mcache, string vfile) {
	v__vmod__ModFileAndFolder _t1 = v__vmod__ModFileCacher_get_by_folder(mcache, os__dir(vfile));
	return _t1;
}

v__vmod__ModFileAndFolder v__vmod__ModFileCacher_get_by_folder(v__vmod__ModFileCacher* mcache, string vfolder) {
	string mfolder = os__real_path(vfolder);
	if (_IN_MAP(ADDR(string, mfolder), ADDR(map, mcache->cache))) {
		v__vmod__ModFileAndFolder _t1 = (*(v__vmod__ModFileAndFolder*)map_get(ADDR(map, mcache->cache), &(string[]){mfolder}, &(v__vmod__ModFileAndFolder[]){ (v__vmod__ModFileAndFolder){.vmod_file = (string){.str=(byteptr)"", .is_lit=1},.vmod_folder = (string){.str=(byteptr)"", .is_lit=1},} }));
		return _t1;
	}
	multi_return_Array_string_v__vmod__ModFileAndFolder mr_2127 = v__vmod__ModFileCacher_traverse(mcache, mfolder);
	Array_string traversed_folders = mr_2127.arg0;
	v__vmod__ModFileAndFolder res = mr_2127.arg1;
	for (int _t2 = 0; _t2 < traversed_folders.len; ++_t2) {
		string tfolder = ((string*)traversed_folders.data)[_t2];
		v__vmod__ModFileCacher_add(mcache, tfolder, res);
	}
	v__vmod__ModFileAndFolder _t3 = res;
	return _t3;
}

VV_LOCAL_SYMBOL void v__vmod__ModFileCacher_add(v__vmod__ModFileCacher* cacher, string path, v__vmod__ModFileAndFolder result) {
	(*(v__vmod__ModFileAndFolder*)map_get_and_set((map*)&cacher->cache, &(string[]){path}, &(v__vmod__ModFileAndFolder[]){ (v__vmod__ModFileAndFolder){.vmod_file = (string){.str=(byteptr)"", .is_lit=1},.vmod_folder = (string){.str=(byteptr)"", .is_lit=1},} })) = result;
}

VV_LOCAL_SYMBOL multi_return_Array_string_v__vmod__ModFileAndFolder v__vmod__ModFileCacher_traverse(v__vmod__ModFileCacher* mcache, string mfolder) {
	string cfolder = mfolder;
	Array_string folders_so_far = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){string_clone(cfolder)}));
	int levels = 0;
	for (;;) {
		if (levels > 255) {
			break;
		}
		if (string__eq(cfolder, _SLIT("/")) || (cfolder).len == 0) {
			break;
		}
		if (_IN_MAP(ADDR(string, cfolder), ADDR(map, mcache->cache))) {
			v__vmod__ModFileAndFolder res = (*(v__vmod__ModFileAndFolder*)map_get(ADDR(map, mcache->cache), &(string[]){cfolder}, &(v__vmod__ModFileAndFolder[]){ (v__vmod__ModFileAndFolder){.vmod_file = (string){.str=(byteptr)"", .is_lit=1},.vmod_folder = (string){.str=(byteptr)"", .is_lit=1},} }));
			if (res.vmod_file.len == 0) {
				v__vmod__ModFileCacher_mark_folders_as_vmod_free(mcache, folders_so_far);
			} else {
				v__vmod__ModFileCacher_mark_folders_with_vmod(mcache, folders_so_far, res);
			}
			return (multi_return_Array_string_v__vmod__ModFileAndFolder){.arg0=__new_array_with_default(0, 0, sizeof(string), 0), .arg1=res};
		}
		Array_string files = v__vmod__ModFileCacher_get_files(mcache, cfolder);
		if (Array_string_contains(files, _SLIT("v.mod"))) {
			v__vmod__ModFileAndFolder res = (v__vmod__ModFileAndFolder){.vmod_file = os__join_path(cfolder, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("v.mod")}))),.vmod_folder = cfolder,};
			return (multi_return_Array_string_v__vmod__ModFileAndFolder){.arg0=folders_so_far, .arg1=res};
		}
		if (v__vmod__ModFileCacher_check_for_stop(mcache, cfolder, files)) {
			break;
		}
		cfolder = os__dir(cfolder);
		array_push((array*)&folders_so_far, _MOV((string[]){ string_clone(cfolder) }));
		levels++;
	}
	v__vmod__ModFileCacher_mark_folders_as_vmod_free(mcache, folders_so_far);
	return (multi_return_Array_string_v__vmod__ModFileAndFolder){.arg0=new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){string_clone(mfolder)})), .arg1=(v__vmod__ModFileAndFolder){.vmod_file = _SLIT(""),.vmod_folder = mfolder,}};
}

VV_LOCAL_SYMBOL void v__vmod__ModFileCacher_mark_folders_with_vmod(v__vmod__ModFileCacher* mcache, Array_string folders_so_far, v__vmod__ModFileAndFolder vmod) {
	for (int _t1 = 0; _t1 < folders_so_far.len; ++_t1) {
		string f = ((string*)folders_so_far.data)[_t1];
		v__vmod__ModFileCacher_add(mcache, f, vmod);
	}
}

VV_LOCAL_SYMBOL void v__vmod__ModFileCacher_mark_folders_as_vmod_free(v__vmod__ModFileCacher* mcache, Array_string folders_so_far) {
	for (int _t1 = 0; _t1 < folders_so_far.len; ++_t1) {
		string f = ((string*)folders_so_far.data)[_t1];
		v__vmod__ModFileCacher_add(mcache, f, (v__vmod__ModFileAndFolder){.vmod_file = _SLIT(""),.vmod_folder = f,});
	}
}

VV_LOCAL_SYMBOL bool v__vmod__ModFileCacher_check_for_stop(v__vmod__ModFileCacher* mcache, string cfolder, Array_string files) {
	for (int _t1 = 0; _t1 < _const_v__vmod__mod_file_stop_paths.len; ++_t1) {
		string i = ((string*)_const_v__vmod__mod_file_stop_paths.data)[_t1];
		if (Array_string_contains(files, i)) {
			bool _t2 = true;
			return _t2;
		}
	}
	bool _t3 = false;
	return _t3;
}

VV_LOCAL_SYMBOL Array_string v__vmod__ModFileCacher_get_files(v__vmod__ModFileCacher* mcache, string cfolder) {
	if (_IN_MAP(ADDR(string, cfolder), ADDR(map, mcache->folder_files))) {
		Array_string _t1 = (*(Array_string*)map_get(ADDR(map, mcache->folder_files), &(string[]){cfolder}, &(Array_string[]){ __new_array(0, 0, sizeof(string)) }));
		return _t1;
	}
	Array_string files = __new_array_with_default(0, 0, sizeof(string), 0);
	if (os__exists(cfolder) && os__is_dir(cfolder)) {
		Option_Array_string _t2;
		if (_t2 = os__ls(cfolder), _t2.state == 0) {
			Array_string listing = *(Array_string*)_t2.data;
			files = array_clone_to_depth(&listing, 0);
		}
	}
	map_set(&mcache->folder_files, &(string[]){cfolder}, &(Array_string[]) { files });
	Array_string _t3 = files;
	return _t3;
}

v__vmod__ModFileCacher* v__vmod__get_cache(void) {
	v__vmod__ModFileCacher* _t1 = _const_v__vmod__private_file_cacher;
	return _t1;
}

string v__util__recompilation__disabling_file(string vroot) {
	string tools_folder = os__join_path(vroot, new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT("cmd"), _SLIT("tools")})));
	string res = os__join_path_single(tools_folder, _SLIT(".disable_autorecompilation"));
	string _t1 = res;
	return _t1;
}

void v__util__recompilation__must_be_enabled(string vroot, string error_message) {
	string file = v__util__recompilation__disabling_file(vroot);
	bool is_recompilation_disabled = os__exists(file);
	if (is_recompilation_disabled) {
		eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Recompilation is disabled, since there is a \""), 0xfe10, {.d_s = file}}, {_SLIT("\" file present."), 0, { .d_c = 0 }}})));
		eprintln(error_message);
		_v_exit(1);
		VUNREACHABLE();
	}
}

string v__cflag__CFlag_str(v__cflag__CFlag* c) {
	string _t1 =  str_intp(6, _MOV((StrIntpData[]){{_SLIT("CFlag{ name: \""), 0xfe10, {.d_s = c->name}}, {_SLIT("\" value: \""), 0xfe10, {.d_s = c->value}}, {_SLIT("\" mod: \""), 0xfe10, {.d_s = c->mod}}, {_SLIT("\" os: \""), 0xfe10, {.d_s = c->os}}, {_SLIT("\" cached: \""), 0xfe10, {.d_s = c->cached}}, {_SLIT("\" }"), 0, { .d_c = 0 }}}));
	return _t1;
}

string v__cflag__CFlag_eval(v__cflag__CFlag* cf) {
	string value = _SLIT("");
	cflag_eval_outer_loop:
	for (int i = 0; i < cf->value.len; i++) {
		byte x = string_at(cf->value, i);
		if (x == '$') {
			string remainder = string_substr(cf->value, i, cf->value.len);
			if (string_starts_with(remainder, _const_v__cflag__fexisting_literal)) {
				string sparams = string_all_before(string_substr(remainder, _const_v__cflag__fexisting_literal.len + 1, remainder.len), _SLIT(")"));
				i += sparams.len + _const_v__cflag__fexisting_literal.len + 1;
				Array_string _t1 = __new_array(0, 0, sizeof(string));
				Array_string _t1_orig = string_split_into_lines(string_replace(sparams, _SLIT(","), _SLIT("\n")));
				int _t1_len = _t1_orig.len;
				_t1 = __new_array(0, _t1_len, sizeof(string));

				for (int _t2 = 0; _t2 < _t1_len; ++_t2) {
					string it = ((string*) _t1_orig.data)[_t2];
					string ti = string_trim(it, _SLIT(" \'\""));
					array_push((array*)&_t1, &ti);
				}
				Array_string svalues =_t1;
				for (int _t3 = 0; _t3 < svalues.len; ++_t3) {
					string spath = ((string*)svalues.data)[_t3];
					if (os__exists(spath)) {
						value = /*f*/string__plus(value, spath);
						goto cflag_eval_outer_loop__continue;
					}
				}
				_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT(">> error: none of the paths "), 0xfe10, {.d_s = Array_string_str(svalues)}}, {_SLIT(" exist"), 0, { .d_c = 0 }}})));
				VUNREACHABLE();
				continue;
			}
		}
		value = /*f*/string__plus(value, byte_ascii_str(x));
	cflag_eval_outer_loop__continue: {}
	}
	cflag_eval_outer_loop__break: {}
	string _t4 = value;
	return _t4;
}

string v__cflag__CFlag_format(v__cflag__CFlag* cf) {
	string value = _SLIT("");
	if ((cf->cached).len != 0) {
		value = cf->cached;
	} else {
		value = v__cflag__CFlag_eval(cf);
	}
	if ((string__eq(cf->name, _SLIT("-l")) || string__eq(cf->name, _SLIT("-Wa")) || string__eq(cf->name, _SLIT("-Wl")) || string__eq(cf->name, _SLIT("-Wp"))) && value.len > 0) {
		string _t1 = string_trim_space( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = cf->name}}, {_SLIT0, 0xfe10, {.d_s = value}}, {_SLIT0, 0, { .d_c = 0 }}})));
		return _t1;
	}
	if (string__eq(cf->name, _SLIT("-I")) || string__eq(cf->name, _SLIT("-L")) || string_ends_with(value, _SLIT(".o"))) {
		value = string__plus(string__plus(_SLIT("\""), os__real_path(value)), _SLIT("\""));
	}
	string _t2 = string_trim_space( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = cf->name}}, {_SLIT(" "), 0xfe10, {.d_s = value}}, {_SLIT0, 0, { .d_c = 0 }}})));
	return _t2;
}

Array_string Array_v__cflag__CFlag_c_options_before_target_msvc(Array_v__cflag__CFlag cflags) {
	Array_string _t1 = __new_array_with_default(0, 0, sizeof(string), 0);
	return _t1;
}

Array_string Array_v__cflag__CFlag_c_options_after_target_msvc(Array_v__cflag__CFlag cflags) {
	Array_string _t1 = __new_array_with_default(0, 0, sizeof(string), 0);
	return _t1;
}

Array_string Array_v__cflag__CFlag_c_options_before_target(Array_v__cflag__CFlag cflags) {
	multi_return_Array_string_Array_string_Array_string mr_2208 = Array_v__cflag__CFlag_defines_others_libs(cflags);
	Array_string defines = mr_2208.arg0;
	Array_string others = mr_2208.arg1;
	Array_string args = __new_array_with_default(0, 0, sizeof(string), 0);
	_PUSH_MANY(&args, (defines), _t1, Array_string);
	_PUSH_MANY(&args, (others), _t2, Array_string);
	Array_string _t3 = args;
	return _t3;
}

Array_string Array_v__cflag__CFlag_c_options_after_target(Array_v__cflag__CFlag cflags) {
	multi_return_Array_string_Array_string_Array_string mr_2385 = Array_v__cflag__CFlag_defines_others_libs(cflags);
	Array_string libs = mr_2385.arg2;
	Array_string _t1 = libs;
	return _t1;
}

Array_string Array_v__cflag__CFlag_c_options_without_object_files(Array_v__cflag__CFlag cflags) {
	Array_string args = __new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t1 = 0; _t1 < cflags.len; ++_t1) {
		v__cflag__CFlag flag = ((v__cflag__CFlag*)cflags.data)[_t1];
		if (string_ends_with(flag.value, _SLIT(".o")) || string_ends_with(flag.value, _SLIT(".obj"))) {
			continue;
		}
		array_push((array*)&args, _MOV((string[]){ string_clone(v__cflag__CFlag_format(&flag)) }));
	}
	Array_string _t3 = args;
	return _t3;
}

Array_string Array_v__cflag__CFlag_c_options_only_object_files(Array_v__cflag__CFlag cflags) {
	Array_string args = __new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t1 = 0; _t1 < cflags.len; ++_t1) {
		v__cflag__CFlag flag = ((v__cflag__CFlag*)cflags.data)[_t1];
		if (string_ends_with(flag.value, _SLIT(".o")) || string_ends_with(flag.value, _SLIT(".obj"))) {
			array_push((array*)&args, _MOV((string[]){ string_clone(v__cflag__CFlag_format(&flag)) }));
		}
	}
	Array_string _t3 = args;
	return _t3;
}

multi_return_Array_string_Array_string_Array_string Array_v__cflag__CFlag_defines_others_libs(Array_v__cflag__CFlag cflags) {
	Array_string copts_without_obj_files = Array_v__cflag__CFlag_c_options_without_object_files(cflags);
	Array_string defines = __new_array_with_default(0, 0, sizeof(string), 0);
	Array_string others = __new_array_with_default(0, 0, sizeof(string), 0);
	Array_string libs = __new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t1 = 0; _t1 < copts_without_obj_files.len; ++_t1) {
		string copt = ((string*)copts_without_obj_files.data)[_t1];
		if (string_starts_with(copt, _SLIT("-l"))) {
			array_push((array*)&libs, _MOV((string[]){ string_clone(copt) }));
			continue;
		}
		if (string_starts_with(copt, _SLIT("-D"))) {
			array_push((array*)&defines, _MOV((string[]){ string_clone(copt) }));
			continue;
		}
		array_push((array*)&others, _MOV((string[]){ string_clone(copt) }));
	}
	return (multi_return_Array_string_Array_string_Array_string){.arg0=defines, .arg1=others, .arg2=libs};
}

void rand__wyrand__WyRandRNG_seed(rand__wyrand__WyRandRNG* rng, Array_u32 seed_data) {
	if (seed_data.len != 2) {
		eprintln(_SLIT("WyRandRNG needs 2 32-bit unsigned integers as the seed."));
		_v_exit(1);
		VUNREACHABLE();
	}
	rng->state = ((*(u32*)/*ee elem_typ */array_get(seed_data, 0)) | (((u64)((*(u32*)/*ee elem_typ */array_get(seed_data, 1)))) << 32U));
	rng->has_extra = false;
}

// Attr: [inline]
inline u32 rand__wyrand__WyRandRNG_u32(rand__wyrand__WyRandRNG* rng) {
	if (rng->has_extra) {
		rng->has_extra = false;
		u32 _t1 = rng->extra;
		return _t1;
	}
	u64 full_value = rand__wyrand__WyRandRNG_u64(rng);
	u32 lower = ((u32)((full_value & _const_rand__constants__lower_mask)));
	u32 upper = ((u32)(full_value >> 32U));
	rng->extra = upper;
	rng->has_extra = true;
	u32 _t2 = lower;
	return _t2;
}

// Attr: [inline]
inline u64 rand__wyrand__WyRandRNG_u64(rand__wyrand__WyRandRNG* rng) {
	{ // Unsafe block
		u64 seed1 = rng->state;
		seed1 += _const_rand__wyrand__wyp0;
		rng->state = seed1;
		u64 _t1 = hash__wymum((seed1 ^ _const_rand__wyrand__wyp1), seed1);
		return _t1;
	}
	u64 _t2 = 0U;
	return _t2;
}

// Attr: [inline]
inline u32 rand__wyrand__WyRandRNG_u32n(rand__wyrand__WyRandRNG* rng, u32 max) {
	if (max == 0U) {
		eprintln(_SLIT("max must be positive integer"));
		_v_exit(1);
		VUNREACHABLE();
	}
	int bit_len = math__bits__len_32(max);
	if (bit_len == 32) {
		for (;;) {
			u32 value = rand__wyrand__WyRandRNG_u32(rng);
			if (value < max) {
				u32 _t1 = value;
				return _t1;
			}
		}
	} else {
		u32 mask = (((u32)(1U)) << (bit_len + 1)) - 1U;
		for (;;) {
			u32 value = (rand__wyrand__WyRandRNG_u32(rng) & mask);
			if (value < max) {
				u32 _t2 = value;
				return _t2;
			}
		}
	}
	u32 _t3 = ((u32)(0U));
	return _t3;
}

// Attr: [inline]
inline u64 rand__wyrand__WyRandRNG_u64n(rand__wyrand__WyRandRNG* rng, u64 max) {
	if (max == 0U) {
		eprintln(_SLIT("max must be positive integer"));
		_v_exit(1);
		VUNREACHABLE();
	}
	int bit_len = math__bits__len_64(max);
	if (bit_len == 64) {
		for (;;) {
			u64 value = rand__wyrand__WyRandRNG_u64(rng);
			if (value < max) {
				u64 _t1 = value;
				return _t1;
			}
		}
	} else {
		u64 mask = (((u64)(1U)) << (bit_len + 1)) - 1U;
		for (;;) {
			u64 value = (rand__wyrand__WyRandRNG_u64(rng) & mask);
			if (value < max) {
				u64 _t2 = value;
				return _t2;
			}
		}
	}
	u64 _t3 = ((u64)(0U));
	return _t3;
}

// Attr: [inline]
inline u32 rand__wyrand__WyRandRNG_u32_in_range(rand__wyrand__WyRandRNG* rng, u32 min, u32 max) {
	if (max <= min) {
		eprintln(_SLIT("max must be greater than min"));
		_v_exit(1);
		VUNREACHABLE();
	}
	u32 _t1 = min + rand__wyrand__WyRandRNG_u32n(rng, max - min);
	return _t1;
}

// Attr: [inline]
inline u64 rand__wyrand__WyRandRNG_u64_in_range(rand__wyrand__WyRandRNG* rng, u64 min, u64 max) {
	if (max <= min) {
		eprintln(_SLIT("max must be greater than min"));
		_v_exit(1);
		VUNREACHABLE();
	}
	u64 _t1 = min + rand__wyrand__WyRandRNG_u64n(rng, max - min);
	return _t1;
}

// Attr: [inline]
inline int rand__wyrand__WyRandRNG_int(rand__wyrand__WyRandRNG* rng) {
	int _t1 = ((int)(rand__wyrand__WyRandRNG_u32(rng)));
	return _t1;
}

// Attr: [inline]
inline i64 rand__wyrand__WyRandRNG_i64(rand__wyrand__WyRandRNG* rng) {
	i64 _t1 = ((i64)(rand__wyrand__WyRandRNG_u64(rng)));
	return _t1;
}

// Attr: [inline]
inline int rand__wyrand__WyRandRNG_int31(rand__wyrand__WyRandRNG* rng) {
	int _t1 = ((int)((rand__wyrand__WyRandRNG_u32(rng) & _const_rand__constants__u31_mask)));
	return _t1;
}

// Attr: [inline]
inline i64 rand__wyrand__WyRandRNG_int63(rand__wyrand__WyRandRNG* rng) {
	i64 _t1 = ((i64)((rand__wyrand__WyRandRNG_u64(rng) & _const_rand__constants__u63_mask)));
	return _t1;
}

// Attr: [inline]
inline int rand__wyrand__WyRandRNG_intn(rand__wyrand__WyRandRNG* rng, int max) {
	if (max <= 0) {
		eprintln(_SLIT("max has to be positive."));
		_v_exit(1);
		VUNREACHABLE();
	}
	int _t1 = ((int)(rand__wyrand__WyRandRNG_u32n(rng, ((u32)(max)))));
	return _t1;
}

// Attr: [inline]
inline i64 rand__wyrand__WyRandRNG_i64n(rand__wyrand__WyRandRNG* rng, i64 max) {
	if (max <= 0) {
		eprintln(_SLIT("max has to be positive."));
		_v_exit(1);
		VUNREACHABLE();
	}
	i64 _t1 = ((i64)(rand__wyrand__WyRandRNG_u64n(rng, ((u64)(max)))));
	return _t1;
}

// Attr: [inline]
inline int rand__wyrand__WyRandRNG_int_in_range(rand__wyrand__WyRandRNG* rng, int min, int max) {
	if (max <= min) {
		eprintln(_SLIT("max must be greater than min"));
		_v_exit(1);
		VUNREACHABLE();
	}
	int _t1 = min + rand__wyrand__WyRandRNG_intn(rng, max - min);
	return _t1;
}

// Attr: [inline]
inline i64 rand__wyrand__WyRandRNG_i64_in_range(rand__wyrand__WyRandRNG* rng, i64 min, i64 max) {
	if (max <= min) {
		eprintln(_SLIT("max must be greater than min"));
		_v_exit(1);
		VUNREACHABLE();
	}
	i64 _t1 = min + rand__wyrand__WyRandRNG_i64n(rng, max - min);
	return _t1;
}

// Attr: [inline]
inline f32 rand__wyrand__WyRandRNG_f32(rand__wyrand__WyRandRNG* rng) {
	f32 _t1 = ((f32)(rand__wyrand__WyRandRNG_u32(rng))) / _const_rand__constants__max_u32_as_f32;
	return _t1;
}

// Attr: [inline]
inline f64 rand__wyrand__WyRandRNG_f64(rand__wyrand__WyRandRNG* rng) {
	f64 _t1 = ((f64)(rand__wyrand__WyRandRNG_u64(rng))) / _const_rand__constants__max_u64_as_f64;
	return _t1;
}

// Attr: [inline]
inline f32 rand__wyrand__WyRandRNG_f32n(rand__wyrand__WyRandRNG* rng, f32 max) {
	if (max <= 0) {
		eprintln(_SLIT("max has to be positive."));
		_v_exit(1);
		VUNREACHABLE();
	}
	f32 _t1 = rand__wyrand__WyRandRNG_f32(rng) * max;
	return _t1;
}

// Attr: [inline]
inline f64 rand__wyrand__WyRandRNG_f64n(rand__wyrand__WyRandRNG* rng, f64 max) {
	if (max <= 0) {
		eprintln(_SLIT("max has to be positive."));
		_v_exit(1);
		VUNREACHABLE();
	}
	f64 _t1 = rand__wyrand__WyRandRNG_f64(rng) * max;
	return _t1;
}

// Attr: [inline]
inline f32 rand__wyrand__WyRandRNG_f32_in_range(rand__wyrand__WyRandRNG* rng, f32 min, f32 max) {
	if (max <= min) {
		eprintln(_SLIT("max must be greater than min"));
		_v_exit(1);
		VUNREACHABLE();
	}
	f32 _t1 = min + rand__wyrand__WyRandRNG_f32n(rng, max - min);
	return _t1;
}

// Attr: [inline]
inline f64 rand__wyrand__WyRandRNG_f64_in_range(rand__wyrand__WyRandRNG* rng, f64 min, f64 max) {
	if (max <= min) {
		eprintln(_SLIT("max must be greater than min"));
		_v_exit(1);
		VUNREACHABLE();
	}
	f64 _t1 = min + rand__wyrand__WyRandRNG_f64n(rng, max - min);
	return _t1;
}

// Attr: [unsafe]
void rand__wyrand__WyRandRNG_free(rand__wyrand__WyRandRNG* rng) {
	_v_free(rng);
}

VV_LOCAL_SYMBOL Option_string v__pkgconfig__desc(string mod) {
	v__pkgconfig__Options options = (v__pkgconfig__Options){.path = (string){.str=(byteptr)"", .is_lit=1},.debug = 0,.norecurse = 0,.only_description = true,.use_default_paths = true,};
	Option_v__pkgconfig__PkgConfig_ptr _t1 = v__pkgconfig__load(mod, options);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		return (Option_string){ .state=2, .err=_v_error(_SLIT("cannot parse")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	v__pkgconfig__PkgConfig* pc =  (*(v__pkgconfig__PkgConfig**)_t1.data);
	Option_string _t3;
	opt_ok(&(string[]) { pc->description }, (Option*)(&_t3), sizeof(string));
	return _t3;
}

Option_v__pkgconfig__Main_ptr v__pkgconfig__main(Array_string args) {
	flag__FlagParser* fp = flag__new_flag_parser(args);
	flag__FlagParser_application(fp, _SLIT("pkgconfig"));
	flag__FlagParser_version(fp, _const_v__pkgconfig__version);
	v__pkgconfig__Main* m = (v__pkgconfig__Main*)memdup(&(v__pkgconfig__Main){.opt = v__pkgconfig__parse_options(fp),.res = (string){.str=(byteptr)"", .is_lit=1},.has_actions = 0,}, sizeof(v__pkgconfig__Main));
	v__pkgconfig__MainOptions* opt = m->opt;
	if (opt->help) {
		m->res = flag__FlagParser_usage(fp);
	} else if (opt->version) {
		m->res = _const_v__pkgconfig__version;
	} else if (opt->listall) {
		Array_string modules = v__pkgconfig__list();
		qsort(modules.data, modules.len, modules.element_size, (int (*)(const void *, const void *))&compare_6984583855671780374_string);
		if (opt->description) {
			for (int _t1 = 0; _t1 < modules.len; ++_t1) {
				string mod = ((string*)modules.data)[_t1];
				Option_string _t2 = v__pkgconfig__desc(mod);
				if (_t2.state != 0) { /*or block*/ 
					IError err = _t2.err;
					continue;
				}
				
 				string d =  (*(string*)_t2.data);
				string pad = strings__repeat(' ', 20 - mod.len);
				m->res = /*f*/string__plus(m->res,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = mod}}, {_SLIT(" "), 0xfe10, {.d_s = pad}}, {_SLIT(" "), 0xfe10, {.d_s = d}}, {_SLIT("\n"), 0, { .d_c = 0 }}})));
			}
		} else {
			m->res = Array_string_join(modules, _SLIT("\n"));
		}
	} else if (opt->args.len == 0) {
		return (Option_v__pkgconfig__Main_ptr){ .state=2, .err=_v_error(_SLIT("No packages given")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Option_v__pkgconfig__Main_ptr _t4;
	opt_ok(&(v__pkgconfig__Main*[]) { m }, (Option*)(&_t4), sizeof(v__pkgconfig__Main*));
	return _t4;
}

Option_string v__pkgconfig__Main_run(v__pkgconfig__Main* m) {
	v__pkgconfig__Options options = (v__pkgconfig__Options){.path = (string){.str=(byteptr)"", .is_lit=1},.debug = m->opt->debug,.norecurse = 0,.only_description = 0,.use_default_paths = true,};
	v__pkgconfig__MainOptions* opt = m->opt;
	v__pkgconfig__PkgConfig* pc = ((v__pkgconfig__PkgConfig*)(0));
	string res = m->res;
	for (int _t1 = 0; _t1 < opt->args.len; ++_t1) {
		string arg = ((string*)opt->args.data)[_t1];
		Option_v__pkgconfig__PkgConfig_ptr _t2 = v__pkgconfig__load(arg, options);
		if (_t2.state != 0) { /*or block*/ 
			IError err = _t2.err;
			if (!opt->exists) {
				return (Option_string){ .state=2, .err=err, .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			continue;
		}
		
 		v__pkgconfig__PkgConfig* pcdep =  (*(v__pkgconfig__PkgConfig**)_t2.data);
		if (opt->description) {
			if ((res).len != 0) {
				res = /*f*/string__plus(res, _SLIT("\n"));
			}
			res = /*f*/string__plus(res, pcdep->description);
		}
		if (pc != 0) {
			Option_string _t4 = v__pkgconfig__PkgConfig_extend(pc, pcdep);
			if (_t4.state != 0) { /*or block*/ 
				Option_string _t5;
				memcpy(&_t5, &_t4, sizeof(Option));
				return _t5;
			}
			
  (*(string*)_t4.data);
		} else {
			pc = pcdep;
		}
	}
	if (opt->exists) {
		Option_string _t6;
		opt_ok(&(string[]) { res }, (Option*)(&_t6), sizeof(string));
		return _t6;
	}
	if ((opt->exactversion).len != 0) {
		if (!string__eq(pc->version, opt->exactversion)) {
			return (Option_string){ .state=2, .err=_v_error(_SLIT("version mismatch")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		Option_string _t8;
		opt_ok(&(string[]) { res }, (Option*)(&_t8), sizeof(string));
		return _t8;
	}
	if ((opt->atleast).len != 0) {
		if (v__pkgconfig__PkgConfig_atleast(pc, opt->atleast)) {
			return (Option_string){ .state=2, .err=_v_error(_SLIT("version mismatch")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		Option_string _t10;
		opt_ok(&(string[]) { res }, (Option*)(&_t10), sizeof(string));
		return _t10;
	}
	if ((opt->atleastpc).len != 0) {
		if (v__pkgconfig__atleast(opt->atleastpc)) {
			return (Option_string){ .state=2, .err=_v_error(_SLIT("version mismatch")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		Option_string _t12;
		opt_ok(&(string[]) { res }, (Option*)(&_t12), sizeof(string));
		return _t12;
	}
	if (opt->variables) {
		res = Array_string_join(map_keys(&pc->vars), _SLIT("\n"));
	}
	if (opt->requires) {
		res = /*f*/string__plus(res, Array_string_join(pc->requires, _SLIT("\n")));
	}
	Array_string r = __new_array_with_default(0, 0, sizeof(string), 0);
	if (opt->cflags_only_path) {
		array_push((array*)&r, _MOV((string[]){ string_clone(v__pkgconfig__filter(pc->cflags, _SLIT("-I"), _SLIT(""))) }));
	}
	if (opt->cflags_only_other) {
		array_push((array*)&r, _MOV((string[]){ string_clone(v__pkgconfig__filter(pc->cflags, _SLIT("-I"), _SLIT("-I"))) }));
	}
	if (opt->cflags) {
		array_push((array*)&r, _MOV((string[]){ string_clone(Array_string_join(pc->cflags, _SLIT(" "))) }));
	}
	if (opt->libs_only_link) {
		array_push((array*)&r, _MOV((string[]){ string_clone(v__pkgconfig__filter(pc->libs, _SLIT("-l"), _SLIT(""))) }));
	}
	if (opt->libs_only_path) {
		array_push((array*)&r, _MOV((string[]){ string_clone(v__pkgconfig__filter(pc->libs, _SLIT("-L"), _SLIT(""))) }));
	}
	if (opt->libs_only_other) {
		array_push((array*)&r, _MOV((string[]){ string_clone(v__pkgconfig__filter(pc->libs, _SLIT("-l"), _SLIT("-L"))) }));
	}
	if (opt->libs) {
		if (opt->stat1c) {
			array_push((array*)&r, _MOV((string[]){ string_clone(Array_string_join(pc->libs_private, _SLIT(" "))) }));
		} else {
			array_push((array*)&r, _MOV((string[]){ string_clone(Array_string_join(pc->libs, _SLIT(" "))) }));
		}
	}
	if (opt->modversion) {
		array_push((array*)&r, _MOV((string[]){ string_clone(pc->version) }));
	}
	Option_string _t22;
	opt_ok(&(string[]) { string__plus(res, Array_string_join(r, _SLIT(" "))) }, (Option*)(&_t22), sizeof(string));
	return _t22;
}

VV_LOCAL_SYMBOL string v__pkgconfig__filter(Array_string libs, string prefix, string prefix2) {
	string res = _SLIT("");
	if ((prefix2).len != 0) {
		for (int _t1 = 0; _t1 < libs.len; ++_t1) {
			string lib = ((string*)libs.data)[_t1];
			if (!string_starts_with(lib, prefix) && !string_starts_with(lib, prefix2)) {
				res = /*f*/string__plus(res,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(" "), 0xfe10, {.d_s = lib}}, {_SLIT0, 0, { .d_c = 0 }}})));
			}
		}
	} else {
		for (int _t2 = 0; _t2 < libs.len; ++_t2) {
			string lib = ((string*)libs.data)[_t2];
			if (string_starts_with(lib, prefix)) {
				res = /*f*/string__plus(res,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(" "), 0xfe10, {.d_s = lib}}, {_SLIT0, 0, { .d_c = 0 }}})));
			}
		}
	}
	string _t3 = res;
	return _t3;
}

VV_LOCAL_SYMBOL v__pkgconfig__MainOptions* v__pkgconfig__parse_options(flag__FlagParser* fp) {
	v__pkgconfig__MainOptions* _t1 = (v__pkgconfig__MainOptions*)memdup(&(v__pkgconfig__MainOptions){.modversion = flag__FlagParser_bool(fp, _SLIT("modversion"), 'V', false, _SLIT("show version of module")),
		.description = flag__FlagParser_bool(fp, _SLIT("description"), 'd', false, _SLIT("show pkg module description")),
		.help = flag__FlagParser_bool(fp, _SLIT("help"), 'h', false, _SLIT("show this help message")),
		.debug = flag__FlagParser_bool(fp, _SLIT("debug"), 'D', false, _SLIT("show debug information")),
		.listall = flag__FlagParser_bool(fp, _SLIT("list-all"), 'l', false, _SLIT("list all pkgmodules")),
		.exists = flag__FlagParser_bool(fp, _SLIT("exists"), 'e', false, _SLIT("return 0 if pkg exists")),
		.variables = flag__FlagParser_bool(fp, _SLIT("print-variables"), 'V', false, _SLIT("display variable names")),
		.requires = flag__FlagParser_bool(fp, _SLIT("print-requires"), 'r', false, _SLIT("display requires of the module")),
		.atleast = flag__FlagParser_string(fp, _SLIT("atleast-version"), 'a', _SLIT(""), _SLIT("return 0 if pkg version is at least the given one")),
		.atleastpc = flag__FlagParser_string(fp, _SLIT("atleast-pkgconfig-version"), 'A', _SLIT(""), _SLIT("return 0 if pkgconfig version is at least the given one")),
		.exactversion = flag__FlagParser_string(fp, _SLIT("exact-version"), ' ', _SLIT(""), _SLIT("return 0 if pkg version is at least the given one")),
		.version = flag__FlagParser_bool(fp, _SLIT("version"), 'v', false, _SLIT("show version of this tool")),
		.cflags = flag__FlagParser_bool(fp, _SLIT("cflags"), 'c', false, _SLIT("output all pre-processor and compiler flags")),
		.cflags_only_path = flag__FlagParser_bool(fp, _SLIT("cflags-only-I"), 'I', false, _SLIT("show only -I flags from CFLAGS")),
		.cflags_only_other = flag__FlagParser_bool(fp, _SLIT("cflags-only-other"), ' ', false, _SLIT("show cflags without -I")),
		.stat1c = flag__FlagParser_bool(fp, _SLIT("static"), 's', false, _SLIT("show --libs for static linking")),
		.libs = flag__FlagParser_bool(fp, _SLIT("libs"), 'l', false, _SLIT("output all linker flags")),
		.libs_only_link = flag__FlagParser_bool(fp, _SLIT("libs-only-l"), ' ', false, _SLIT("show only -l from ldflags")),
		.libs_only_path = flag__FlagParser_bool(fp, _SLIT("libs-only-L"), 'L', false, _SLIT("show only -L from ldflags")),
		.libs_only_other = flag__FlagParser_bool(fp, _SLIT("libs-only-other"), ' ', false, _SLIT("show flags not containing -l or -L")),
		.args = fp->args,
	}, sizeof(v__pkgconfig__MainOptions));
	return _t1;
}

VV_LOCAL_SYMBOL Array_string v__pkgconfig__PkgConfig_parse_list_no_comma(v__pkgconfig__PkgConfig* pc, string s) {
	Array_string _t1 = v__pkgconfig__PkgConfig_parse_list(pc, string_replace(s, _SLIT(","), _SLIT(" ")));
	return _t1;
}

VV_LOCAL_SYMBOL Array_string v__pkgconfig__PkgConfig_parse_list(v__pkgconfig__PkgConfig* pc, string s) {
	Array_string operators = new_array_from_c_array(5, 5, sizeof(string), _MOV((string[5]){_SLIT("="), _SLIT("<"), _SLIT(">"), _SLIT(">="), _SLIT("<=")}));
	Array_string r = string_split(v__pkgconfig__PkgConfig_parse_line(pc, string_replace(string_replace(s, _SLIT("  "), _SLIT(" ")), _SLIT(", "), _SLIT(" "))), _SLIT(" "));
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	bool skip = false;
	for (int _t1 = 0; _t1 < r.len; ++_t1) {
		string a = ((string*)r.data)[_t1];
		string b = string_trim_space(a);
		if (skip) {
			skip = false;
		} else if (Array_string_contains(operators, b)) {
			skip = true;
		} else if ((b).len != 0) {
			array_push((array*)&res, _MOV((string[]){ string_clone(b) }));
		}
	}
	Array_string _t3 = res;
	return _t3;
}

VV_LOCAL_SYMBOL string v__pkgconfig__PkgConfig_parse_line(v__pkgconfig__PkgConfig* pc, string s) {
	string r = string_trim_space(s);
	for (;;) {
		if (!(string_contains(r, _SLIT("${")))) break;
		Option_int _t1 = string_index(r, _SLIT("${"));
		if (_t1.state != 0) { /*or block*/ 
			IError err = _t1.err;
			break;
		}
		
 		int tok0 =  (*(int*)_t1.data);
		Option_int _t2 = string_index(string_substr(r, tok0, r.len), _SLIT("}"));
		if (_t2.state != 0) { /*or block*/ 
			IError err = _t2.err;
			break;
		}
		
 		int tok1 =  (*(int*)_t2.data);
		tok1 += tok0;
		string v = string_substr(r, tok0 + 2, tok1);
		r = string_replace(r,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("${"), 0xfe10, {.d_s = v}}, {_SLIT("}"), 0, { .d_c = 0 }}})), (*(string*)map_get(ADDR(map, pc->vars), &(string[]){v}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })));
	}
	string _t3 = string_trim_space(r);
	return _t3;
}

VV_LOCAL_SYMBOL void v__pkgconfig__PkgConfig_setvar(v__pkgconfig__PkgConfig* pc, string line) {
	Array_string kv = string_split(string_trim_space(line), _SLIT("="));
	if (kv.len == 2) {
		string k = (*(string*)/*ee elem_typ */array_get(kv, 0));
		string v = v__pkgconfig__PkgConfig_parse_line(pc, (*(string*)/*ee elem_typ */array_get(kv, 1)));
		map_set(&pc->vars, &(string[]){k}, &(string[]) { v__pkgconfig__PkgConfig_parse_line(pc, v) });
	}
}

VV_LOCAL_SYMBOL bool v__pkgconfig__PkgConfig_parse(v__pkgconfig__PkgConfig* pc, string file) {
	Option_string _t1 = os__read_file(file);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		bool _t2 = false;
		return _t2;
	}
	
 	string data =  (*(string*)_t1.data);
	if (pc->options.debug) {
		eprintln(data);
	}
	Array_string lines = string_split(data, _SLIT("\n"));
	if (pc->options.only_description) {
		for (int _t3 = 0; _t3 < lines.len; ++_t3) {
			string line = ((string*)lines.data)[_t3];
			if (string_starts_with(line, _SLIT("Description: "))) {
				pc->description = v__pkgconfig__PkgConfig_parse_line(pc, string_substr(line, 13, line.len));
			}
		}
	} else {
		for (int _t4 = 0; _t4 < lines.len; ++_t4) {
			string line = ((string*)lines.data)[_t4];
			if (string_starts_with(line, _SLIT("#"))) {
				continue;
			}
			if (string_contains(line, _SLIT("=")) && !string_contains(line, _SLIT(" "))) {
				v__pkgconfig__PkgConfig_setvar(pc, line);
				continue;
			}
			if (string_starts_with(line, _SLIT("Name:"))) {
				pc->name = v__pkgconfig__PkgConfig_parse_line(pc, string_substr(line, 5, line.len));
			} else if (string_starts_with(line, _SLIT("Description:"))) {
				pc->description = v__pkgconfig__PkgConfig_parse_line(pc, string_substr(line, 12, line.len));
			} else if (string_starts_with(line, _SLIT("Version:"))) {
				pc->version = v__pkgconfig__PkgConfig_parse_line(pc, string_substr(line, 8, line.len));
			} else if (string_starts_with(line, _SLIT("Requires:"))) {
				pc->requires = v__pkgconfig__PkgConfig_parse_list_no_comma(pc, string_substr(line, 9, line.len));
			} else if (string_starts_with(line, _SLIT("Requires.private:"))) {
				pc->requires_private = v__pkgconfig__PkgConfig_parse_list_no_comma(pc, string_substr(line, 17, line.len));
			} else if (string_starts_with(line, _SLIT("Conflicts:"))) {
				pc->conflicts = v__pkgconfig__PkgConfig_parse_list_no_comma(pc, string_substr(line, 10, line.len));
			} else if (string_starts_with(line, _SLIT("Cflags:"))) {
				pc->cflags = v__pkgconfig__PkgConfig_parse_list(pc, string_substr(line, 7, line.len));
			} else if (string_starts_with(line, _SLIT("Libs:"))) {
				pc->libs = v__pkgconfig__PkgConfig_parse_list(pc, string_substr(line, 5, line.len));
			} else if (string_starts_with(line, _SLIT("Libs.private:"))) {
				pc->libs_private = v__pkgconfig__PkgConfig_parse_list(pc, string_substr(line, 13, line.len));
			} else if (string_starts_with(line, _SLIT("URL:"))) {
				pc->url = v__pkgconfig__PkgConfig_parse_line(pc, string_substr(line, 4, line.len));
			}
		}
	}
	bool _t5 = true;
	return _t5;
}

VV_LOCAL_SYMBOL Option_string v__pkgconfig__PkgConfig_resolve(v__pkgconfig__PkgConfig* pc, string pkgname) {
	if (string_ends_with(pkgname, _SLIT(".pc"))) {
		if (os__exists(pkgname)) {
			Option_string _t1;
			opt_ok(&(string[]) { pkgname }, (Option*)(&_t1), sizeof(string));
			return _t1;
		}
	} else {
		if (pc->paths.len == 0) {
			array_push((array*)&pc->paths, _MOV((string[]){ string_clone(_SLIT(".")) }));
		}
		for (int _t3 = 0; _t3 < pc->paths.len; ++_t3) {
			string path = ((string*)pc->paths.data)[_t3];
			string file =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = path}}, {_SLIT("/"), 0xfe10, {.d_s = pkgname}}, {_SLIT(".pc"), 0, { .d_c = 0 }}}));
			if (os__exists(file)) {
				Option_string _t4;
				opt_ok(&(string[]) { file }, (Option*)(&_t4), sizeof(string));
				return _t4;
			}
		}
	}
	return (Option_string){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Cannot find \""), 0xfe10, {.d_s = pkgname}}, {_SLIT("\" pkgconfig file"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
}

bool v__pkgconfig__atleast(string v) {
	Option_semver__Version _t1 = semver__from(_const_v__pkgconfig__version);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		bool _t2 = false;
		return _t2;
	}
	
 	semver__Version v0 =  (*(semver__Version*)_t1.data);
	Option_semver__Version _t3 = semver__from(v);
	if (_t3.state != 0) { /*or block*/ 
		IError err = _t3.err;
		bool _t4 = false;
		return _t4;
	}
	
 	semver__Version v1 =  (*(semver__Version*)_t3.data);
	bool _t5 = semver__Version_gt(v0, v1);
	return _t5;
}

bool v__pkgconfig__PkgConfig_atleast(v__pkgconfig__PkgConfig* pc, string v) {
	Option_semver__Version _t1 = semver__from(pc->version);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		bool _t2 = false;
		return _t2;
	}
	
 	semver__Version v0 =  (*(semver__Version*)_t1.data);
	Option_semver__Version _t3 = semver__from(v);
	if (_t3.state != 0) { /*or block*/ 
		IError err = _t3.err;
		bool _t4 = false;
		return _t4;
	}
	
 	semver__Version v1 =  (*(semver__Version*)_t3.data);
	bool _t5 = semver__Version_gt(v0, v1);
	return _t5;
}

Option_string v__pkgconfig__PkgConfig_extend(v__pkgconfig__PkgConfig* pc, v__pkgconfig__PkgConfig* pcdep) {
	for (int _t1 = 0; _t1 < pcdep->cflags.len; ++_t1) {
		string flag = ((string*)pcdep->cflags.data)[_t1];
		if (Array_string_index(pc->cflags, flag) == -1) {
			array_push((array*)&pc->cflags, _MOV((string[]){ string_clone(flag) }));
		}
	}
	for (int _t3 = 0; _t3 < pcdep->libs.len; ++_t3) {
		string lib = ((string*)pcdep->libs.data)[_t3];
		if (Array_string_index(pc->libs, lib) == -1) {
			array_push((array*)&pc->libs, _MOV((string[]){ string_clone(lib) }));
		}
	}
	for (int _t5 = 0; _t5 < pcdep->libs_private.len; ++_t5) {
		string lib = ((string*)pcdep->libs_private.data)[_t5];
		if (Array_string_index(pc->libs_private, lib) == -1) {
			array_push((array*)&pc->libs_private, _MOV((string[]){ string_clone(lib) }));
		}
	}
	return (Option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
}

VV_LOCAL_SYMBOL Option_void v__pkgconfig__PkgConfig_load_requires(v__pkgconfig__PkgConfig* pc) {
	for (int _t1 = 0; _t1 < pc->requires.len; ++_t1) {
		string dep = ((string*)pc->requires.data)[_t1];
		Option_void _t2 = v__pkgconfig__PkgConfig_load_require(pc, dep);
		if (_t2.state != 0 && _t2.err._typ != _IError_None___index) {
			Option_void _t3;
			memcpy(&_t3, &_t2, sizeof(Option));
			return _t3;
		}
		
 ;
	}
	for (int _t4 = 0; _t4 < pc->requires_private.len; ++_t4) {
		string dep = ((string*)pc->requires_private.data)[_t4];
		Option_void _t5 = v__pkgconfig__PkgConfig_load_require(pc, dep);
		if (_t5.state != 0 && _t5.err._typ != _IError_None___index) {
			Option_void _t6;
			memcpy(&_t6, &_t5, sizeof(Option));
			return _t6;
		}
		
 ;
	}
	return (Option_void){0};
}

VV_LOCAL_SYMBOL Option_void v__pkgconfig__PkgConfig_load_require(v__pkgconfig__PkgConfig* pc, string dep) {
	v__pkgconfig__PkgConfig pcdep = (v__pkgconfig__PkgConfig){.options = (v__pkgconfig__Options){.path = (string){.str=(byteptr)"", .is_lit=1},.debug = 0,.norecurse = 0,.only_description = 0,.use_default_paths = true,},.name = (string){.str=(byteptr)"", .is_lit=1},.modname = (string){.str=(byteptr)"", .is_lit=1},.url = (string){.str=(byteptr)"", .is_lit=1},.version = (string){.str=(byteptr)"", .is_lit=1},.description = (string){.str=(byteptr)"", .is_lit=1},.libs = __new_array(0, 0, sizeof(string)),.libs_private = __new_array(0, 0, sizeof(string)),.cflags = __new_array(0, 0, sizeof(string)),.paths = pc->paths,.vars = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.requires = __new_array(0, 0, sizeof(string)),.requires_private = __new_array(0, 0, sizeof(string)),.conflicts = __new_array(0, 0, sizeof(string)),};
	Option_string _t1 = v__pkgconfig__PkgConfig_resolve(&pcdep, dep);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		if (pc->options.debug) {
			eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot resolve "), 0xfe10, {.d_s = dep}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		return (Option_void){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("could not resolve dependency "), 0xfe10, {.d_s = dep}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	string depfile =  (*(string*)_t1.data);
	if (!v__pkgconfig__PkgConfig_parse(&pcdep, depfile)) {
		return (Option_void){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("required file \""), 0xfe10, {.d_s = depfile}}, {_SLIT("\" could not be parsed"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Option_void _t4 = v__pkgconfig__PkgConfig_load_requires(&pcdep);
	if (_t4.state != 0 && _t4.err._typ != _IError_None___index) {
		Option_void _t5;
		memcpy(&_t5, &_t4, sizeof(Option));
		return _t5;
	}
	
 ;
	Option_string _t6 = v__pkgconfig__PkgConfig_extend(pc, (voidptr)&/*qq*/pcdep);
	if (_t6.state != 0) { /*or block*/ 
		Option_void _t7;
		memcpy(&_t7, &_t6, sizeof(Option));
		return _t7;
	}
	
  (*(string*)_t6.data);
	return (Option_void){0};
}

VV_LOCAL_SYMBOL void v__pkgconfig__PkgConfig_add_path(v__pkgconfig__PkgConfig* pc, string path) {
	string p = (string_ends_with(path, _SLIT("/")) ? (string_substr(path, 0, path.len - 1)) : (path));
	if (!os__exists(p)) {
		return;
	}
	if (Array_string_index(pc->paths, p) == -1) {
		array_push((array*)&pc->paths, _MOV((string[]){ string_clone(p) }));
	}
}

VV_LOCAL_SYMBOL void v__pkgconfig__PkgConfig_load_paths(v__pkgconfig__PkgConfig* pc) {
	if (pc->options.use_default_paths) {
		for (int _t1 = 0; _t1 < _const_v__pkgconfig__default_paths.len; ++_t1) {
			string path = ((string*)_const_v__pkgconfig__default_paths.data)[_t1];
			v__pkgconfig__PkgConfig_add_path(pc, path);
		}
	}
	Array_string _t2 = string_split(pc->options.path, _SLIT(":"));
	for (int _t3 = 0; _t3 < _t2.len; ++_t3) {
		string path = ((string*)_t2.data)[_t3];
		v__pkgconfig__PkgConfig_add_path(pc, path);
	}
	string env_var = os__getenv(_SLIT("PKG_CONFIG_PATH"));
	if ((env_var).len != 0) {
		Array_string env_paths = string_split(string_trim_space(env_var), _SLIT(":"));
		for (int _t4 = 0; _t4 < env_paths.len; ++_t4) {
			string path = ((string*)env_paths.data)[_t4];
			v__pkgconfig__PkgConfig_add_path(pc, path);
		}
	}
}

Option_v__pkgconfig__PkgConfig_ptr v__pkgconfig__load(string pkgname, v__pkgconfig__Options options) {
	v__pkgconfig__PkgConfig* pc = (v__pkgconfig__PkgConfig*)memdup(&(v__pkgconfig__PkgConfig){.options = options,.name = (string){.str=(byteptr)"", .is_lit=1},.modname = pkgname,.url = (string){.str=(byteptr)"", .is_lit=1},.version = (string){.str=(byteptr)"", .is_lit=1},.description = (string){.str=(byteptr)"", .is_lit=1},.libs = __new_array(0, 0, sizeof(string)),.libs_private = __new_array(0, 0, sizeof(string)),.cflags = __new_array(0, 0, sizeof(string)),.paths = __new_array(0, 0, sizeof(string)),.vars = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.requires = __new_array(0, 0, sizeof(string)),.requires_private = __new_array(0, 0, sizeof(string)),.conflicts = __new_array(0, 0, sizeof(string)),}, sizeof(v__pkgconfig__PkgConfig));
	v__pkgconfig__PkgConfig_load_paths(pc);
	Option_string _t1 = v__pkgconfig__PkgConfig_resolve(pc, pkgname);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		return (Option_v__pkgconfig__PkgConfig_ptr){ .state=2, .err=err, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	string file =  (*(string*)_t1.data);
	if (!v__pkgconfig__PkgConfig_parse(pc, file)) {
		return (Option_v__pkgconfig__PkgConfig_ptr){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("file \""), 0xfe10, {.d_s = file}}, {_SLIT("\" could not be parsed"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (!options.norecurse) {
		Option_void _t4 = v__pkgconfig__PkgConfig_load_requires(pc);
		if (_t4.state != 0 && _t4.err._typ != _IError_None___index) {
			Option_v__pkgconfig__PkgConfig_ptr _t5;
			memcpy(&_t5, &_t4, sizeof(Option));
			return _t5;
		}
		
 ;
	}
	Option_v__pkgconfig__PkgConfig_ptr _t6;
	opt_ok(&(v__pkgconfig__PkgConfig*[]) { pc }, (Option*)(&_t6), sizeof(v__pkgconfig__PkgConfig*));
	return _t6;
}

Array_string v__pkgconfig__list(void) {
	v__pkgconfig__PkgConfig* pc = (v__pkgconfig__PkgConfig*)memdup(&(v__pkgconfig__PkgConfig){.options = (v__pkgconfig__Options){.path = (string){.str=(byteptr)"", .is_lit=1},.debug = 0,.norecurse = 0,.only_description = 0,.use_default_paths = true,},.name = (string){.str=(byteptr)"", .is_lit=1},.modname = (string){.str=(byteptr)"", .is_lit=1},.url = (string){.str=(byteptr)"", .is_lit=1},.version = (string){.str=(byteptr)"", .is_lit=1},.description = (string){.str=(byteptr)"", .is_lit=1},.libs = __new_array(0, 0, sizeof(string)),.libs_private = __new_array(0, 0, sizeof(string)),.cflags = __new_array(0, 0, sizeof(string)),.paths = __new_array(0, 0, sizeof(string)),.vars = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.requires = __new_array(0, 0, sizeof(string)),.requires_private = __new_array(0, 0, sizeof(string)),.conflicts = __new_array(0, 0, sizeof(string)),}, sizeof(v__pkgconfig__PkgConfig));
	v__pkgconfig__PkgConfig_load_paths(pc);
	Array_string modules = __new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t1 = 0; _t1 < pc->paths.len; ++_t1) {
		string path = ((string*)pc->paths.data)[_t1];
		Option_Array_string _t2 = os__ls(path);
		if (_t2.state != 0) { /*or block*/ 
			IError err = _t2.err;
			continue;
		}
		
 		Array_string files =  (*(Array_string*)_t2.data);
		for (int _t3 = 0; _t3 < files.len; ++_t3) {
			string file = ((string*)files.data)[_t3];
			if (string_ends_with(file, _SLIT(".pc"))) {
				string name = string_replace(file, _SLIT(".pc"), _SLIT(""));
				if (Array_string_index(modules, name) == -1) {
					array_push((array*)&modules, _MOV((string[]){ string_clone(name) }));
				}
			}
		}
	}
	Array_string _t5 = modules;
	return _t5;
}

int runtime__nr_jobs(void) {
	int cpus = runtime__nr_cpus() - 1;
	int vjobs = string_int(os__getenv(_SLIT("VJOBS")));
	if (vjobs > 0) {
		cpus = vjobs;
	}
	if (cpus == 0) {
		int _t1 = 1;
		return _t1;
	}
	int _t2 = cpus;
	return _t2;
}

bool runtime__is_32bit(void) {
	#if defined(TARGET_IS_32BIT)
	{
		bool _t1 = true;
		return _t1;
	}
	#endif
	bool _t2 = false;
	return _t2;
}

bool runtime__is_64bit(void) {
	#if defined(TARGET_IS_64BIT)
	{
		bool _t1 = true;
		return _t1;
	}
	#endif
	bool _t2 = false;
	return _t2;
}

bool runtime__is_little_endian(void) {
	#if defined(TARGET_ORDER_IS_LITTLE)
	{
		bool _t1 = true;
		return _t1;
	}
	#endif
	bool _t2 = false;
	return _t2;
}

bool runtime__is_big_endian(void) {
	#if defined(TARGET_ORDER_IS_BIG)
	{
		bool _t1 = true;
		return _t1;
	}
	#endif
	bool _t2 = false;
	return _t2;
}

int runtime__nr_cpus(void) {
	SYSTEM_INFO sinfo = (SYSTEM_INFO){.dwNumberOfProcessors = 0,};
	GetSystemInfo(&sinfo);
	int nr = ((int)(sinfo.dwNumberOfProcessors));
	if (nr == 0) {
		nr = string_int(os__getenv(_SLIT("NUMBER_OF_PROCESSORS")));
	}
	int _t1 = nr;
	return _t1;
}

string rand__uuid_v4(void) {
	int buflen = 36;
	byte* buf = malloc_noscan(37);
	int i_buf = 0;
	u64 x = ((u64)(0U));
	byte d = ((byte)(0));
	for (;;) {
		if (!(i_buf < buflen)) break;
		int c = 0;
		x = rand__PRNG_name_table[default_rng->_typ]._method_u64(default_rng->_object);
		x &= 0x0F0F0F0F0F0F0F0FU;
		x += 0x3030303030303030U;
		for (;;) {
			if (!(c < 8 && i_buf < buflen)) break;
			d = ((byte)(x));
			{ // Unsafe block
				buf[i_buf] = (d > 0x39 ? (d + 0x27) : (d));
			}
			i_buf++;
			c++;
			x = x >> 8U;
		}
	}
	x = x >> 8U;
	d = ((byte)(x));
	{ // Unsafe block
		buf[19] = (d > 0x39 ? (d + 0x27) : (d));
		buf[8] = '-';
		buf[13] = '-';
		buf[18] = '-';
		buf[23] = '-';
		buf[14] = '4';
		buf[buflen] = 0;
		string _t1 = byte_vstring_with_len(buf, buflen);
		return _t1;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

string rand__ulid(void) {
	string _t1 = rand__ulid_at_millisecond(((u64)(time__Time_unix_time_milli(time__utc()))));
	return _t1;
}

string rand__ulid_at_millisecond(u64 unix_time_milli) {
	int buflen = 26;
	byte* buf = malloc_noscan(27);
	u64 t = unix_time_milli;
	int i = 9;
	for (;;) {
		if (!(i >= 0)) break;
		{ // Unsafe block
			buf[i] = string_at(_const_rand__ulid_encoding, (t & 0x1FU));
		}
		t = t >> 5U;
		i--;
	}
	u64 x = rand__PRNG_name_table[default_rng->_typ]._method_u64(default_rng->_object);
	i = 10;
	for (;;) {
		if (!(i < 19)) break;
		{ // Unsafe block
			buf[i] = string_at(_const_rand__ulid_encoding, (x & 0x1FU));
		}
		x = x >> 5U;
		i++;
	}
	x = rand__PRNG_name_table[default_rng->_typ]._method_u64(default_rng->_object);
	for (;;) {
		if (!(i < 26)) break;
		{ // Unsafe block
			buf[i] = string_at(_const_rand__ulid_encoding, (x & 0x1FU));
		}
		x = x >> 5U;
		i++;
	}
	{ // Unsafe block
		buf[26] = 0;
		string _t1 = byte_vstring_with_len(buf, buflen);
		return _t1;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

string rand__string_from_set(string charset, int len) {
	if (len == 0) {
		string _t1 = _SLIT("");
		return _t1;
	}
	byte* buf = malloc_noscan(len + 1);
	for (int i = 0; i < len; ++i) {
		{ // Unsafe block
			buf[i] = string_at(charset, rand__intn(charset.len));
		}
	}
	{ // Unsafe block
		buf[len] = 0;
	}
	string _t2 = byte_vstring_with_len(buf, len);
	return _t2;
}

string rand__string(int len) {
	string _t1 = rand__string_from_set(_const_rand__english_letters, len);
	return _t1;
}

string rand__hex(int len) {
	string _t1 = rand__string_from_set(_const_rand__hex_chars, len);
	return _t1;
}

string rand__ascii(int len) {
	string _t1 = rand__string_from_set(_const_rand__ascii_chars, len);
	return _t1;
}

VV_LOCAL_SYMBOL void rand__deinit(void) {
	{ // Unsafe block
		rand__PRNG_name_table[default_rng->_typ]._method__v_free(default_rng->_object);
		_v_free(default_rng);
	}
}

VV_LOCAL_SYMBOL void rand__init(void) {
	default_rng = rand__new_default((rand__config__PRNGConfigStruct){.seed_ = rand__seed__time_seed_array(2),});
	atexit((voidptr)rand__deinit);
}

// Attr: [manualfree]
rand__PRNG* rand__new_default(rand__config__PRNGConfigStruct config) {
	rand__wyrand__WyRandRNG* rng = (rand__wyrand__WyRandRNG*)memdup(&(rand__wyrand__WyRandRNG){.state = rand__seed__time_seed_64(),.has_extra = 0,.extra = 0,}, sizeof(rand__wyrand__WyRandRNG));
	rand__wyrand__WyRandRNG_seed(rng, config.seed_);
	array_free(&config.seed_);
	rand__PRNG* _t1 = HEAP(rand__PRNG, /*&rand.PRNG*/I_rand__wyrand__WyRandRNG_to_Interface_rand__PRNG(rng));
	return _t1;
}

rand__PRNG* rand__get_current_rng(void) {
	rand__PRNG* _t1 = default_rng;
	return _t1;
}

void rand__set_rng(rand__PRNG* rng) {
	default_rng = rng;
}

void rand__seed(Array_u32 seed) {
	rand__PRNG_name_table[default_rng->_typ]._method_seed(default_rng->_object, seed);
}

u32 rand__u32(void) {
	u32 _t1 = rand__PRNG_name_table[default_rng->_typ]._method_u32(default_rng->_object);
	return _t1;
}

u64 rand__u64(void) {
	u64 _t1 = rand__PRNG_name_table[default_rng->_typ]._method_u64(default_rng->_object);
	return _t1;
}

u32 rand__u32n(u32 max) {
	u32 _t1 = rand__PRNG_name_table[default_rng->_typ]._method_u32n(default_rng->_object, max);
	return _t1;
}

u64 rand__u64n(u64 max) {
	u64 _t1 = rand__PRNG_name_table[default_rng->_typ]._method_u64n(default_rng->_object, max);
	return _t1;
}

u32 rand__u32_in_range(u32 min, u32 max) {
	u32 _t1 = rand__PRNG_name_table[default_rng->_typ]._method_u32_in_range(default_rng->_object, min, max);
	return _t1;
}

u64 rand__u64_in_range(u64 min, u64 max) {
	u64 _t1 = rand__PRNG_name_table[default_rng->_typ]._method_u64_in_range(default_rng->_object, min, max);
	return _t1;
}

int rand__int(void) {
	int _t1 = rand__PRNG_name_table[default_rng->_typ]._method__v_int(default_rng->_object);
	return _t1;
}

int rand__intn(int max) {
	int _t1 = rand__PRNG_name_table[default_rng->_typ]._method_intn(default_rng->_object, max);
	return _t1;
}

byte rand__byte(void) {
	byte _t1 = ((byte)((rand__PRNG_name_table[default_rng->_typ]._method_u32(default_rng->_object) & 0xffU)));
	return _t1;
}

int rand__int_in_range(int min, int max) {
	int _t1 = rand__PRNG_name_table[default_rng->_typ]._method_int_in_range(default_rng->_object, min, max);
	return _t1;
}

int rand__int31(void) {
	int _t1 = rand__PRNG_name_table[default_rng->_typ]._method_int31(default_rng->_object);
	return _t1;
}

i64 rand__i64(void) {
	i64 _t1 = rand__PRNG_name_table[default_rng->_typ]._method_i64(default_rng->_object);
	return _t1;
}

i64 rand__i64n(i64 max) {
	i64 _t1 = rand__PRNG_name_table[default_rng->_typ]._method_i64n(default_rng->_object, max);
	return _t1;
}

i64 rand__i64_in_range(i64 min, i64 max) {
	i64 _t1 = rand__PRNG_name_table[default_rng->_typ]._method_i64_in_range(default_rng->_object, min, max);
	return _t1;
}

i64 rand__int63(void) {
	i64 _t1 = rand__PRNG_name_table[default_rng->_typ]._method_int63(default_rng->_object);
	return _t1;
}

f32 rand__f32(void) {
	f32 _t1 = rand__PRNG_name_table[default_rng->_typ]._method_f32(default_rng->_object);
	return _t1;
}

f64 rand__f64(void) {
	f64 _t1 = rand__PRNG_name_table[default_rng->_typ]._method_f64(default_rng->_object);
	return _t1;
}

f32 rand__f32n(f32 max) {
	f32 _t1 = rand__PRNG_name_table[default_rng->_typ]._method_f32n(default_rng->_object, max);
	return _t1;
}

f64 rand__f64n(f64 max) {
	f64 _t1 = rand__PRNG_name_table[default_rng->_typ]._method_f64n(default_rng->_object, max);
	return _t1;
}

f32 rand__f32_in_range(f32 min, f32 max) {
	f32 _t1 = rand__PRNG_name_table[default_rng->_typ]._method_f32_in_range(default_rng->_object, min, max);
	return _t1;
}

f64 rand__f64_in_range(f64 min, f64 max) {
	f64 _t1 = rand__PRNG_name_table[default_rng->_typ]._method_f64_in_range(default_rng->_object, min, max);
	return _t1;
}

v__pref__Preferences* v__pref__new_preferences(void) {
	v__pref__Preferences* p = (v__pref__Preferences*)memdup(&(v__pref__Preferences){.os = 0,.backend = 0,.build_mode = 0,.arch = 0,.output_mode = v__pref__OutputMode__stdout,.is_verbose = 0,.is_test = 0,.is_script = 0,.is_vsh = 0,.is_livemain = 0,.is_liveshared = 0,.is_shared = 0,.is_o = 0,.is_prof = 0,.test_runner = (string){.str=(byteptr)"", .is_lit=1},.profile_file = (string){.str=(byteptr)"", .is_lit=1},.profile_no_inline = 0,.translated = 0,.is_prod = 0,.obfuscate = 0,.is_repl = 0,.is_run = 0,.is_debug = 0,.is_vlines = 0,.sanitize = 0,.sourcemap = 0,.sourcemap_inline = true,.sourcemap_src_included = 0,.show_cc = 0,.show_c_output = 0,.show_callgraph = 0,.show_depgraph = 0,.dump_c_flags = (string){.str=(byteptr)"", .is_lit=1},.use_cache = 0,.retry_compilation = true,.is_stats = 0,.cflags = (string){.str=(byteptr)"", .is_lit=1},.m64 = 0,.ccompiler = (string){.str=(byteptr)"", .is_lit=1},.ccompiler_type = 0,.third_party_option = (string){.str=(byteptr)"", .is_lit=1},.building_v = 0,.autofree = 0,.compress = 0,.no_builtin = 0,.enable_globals = 0,.is_fmt = 0,.is_vet = 0,.is_bare = 0,.bare_builtin_dir = (string){.str=(byteptr)"", .is_lit=1},.no_preludes = 0,.custom_prelude = (string){.str=(byteptr)"", .is_lit=1},.lookup_path = __new_array(0, 0, sizeof(string)),.output_cross_c = 0,.output_es5 = 0,.prealloc = 0,.vroot = (string){.str=(byteptr)"", .is_lit=1},.out_name_c = (string){.str=(byteptr)"", .is_lit=1},.out_name = (string){.str=(byteptr)"", .is_lit=1},.path = (string){.str=(byteptr)"", .is_lit=1},.run_only = __new_array(0, 0, sizeof(string)),.compile_defines = __new_array(0, 0, sizeof(string)),.compile_defines_all = __new_array(0, 0, sizeof(string)),.run_args = __new_array(0, 0, sizeof(string)),.printfn_list = __new_array(0, 0, sizeof(string)),.print_v_files = 0,.skip_running = 0,.skip_warnings = 0,.warn_impure_v = 0,.warns_are_errors = 0,.fatal_errors = 0,.reuse_tmpc = 0,.no_rsp = 0,.no_std = 0,.use_color = 0,.no_parallel = 0,.is_vweb = 0,.only_check_syntax = 0,.check_only = 0,.experimental = 0,.skip_unused = 0,.show_timings = 0,.is_ios_simulator = 0,.is_apk = 0,.cleanup_files = __new_array(0, 0, sizeof(string)),.build_options = __new_array(0, 0, sizeof(string)),.cache_manager = (v__vcache__CacheManager){.basepath = (string){.str=(byteptr)"", .is_lit=1},.original_vopts = (string){.str=(byteptr)"", .is_lit=1},.vopts = (string){.str=(byteptr)"", .is_lit=1},.k2cpath = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),},.is_help = 0,.gc_mode = v__pref__GarbageCollectionMode__no_gc,.is_cstrict = 0,.assert_failure_mode = 0,.message_limit = 100,.nofloat = 0,.checker_match_exhaustive_cutoff_limit = 12,}, sizeof(v__pref__Preferences));
	v__pref__Preferences_fill_with_defaults(p);
	v__pref__Preferences* _t1 = p;
	return _t1;
}

VV_LOCAL_SYMBOL void v__pref__Preferences_expand_lookup_paths(v__pref__Preferences* p) {
	if ((p->vroot).len == 0) {
		p->vroot = os__dir(v__pref__vexe_path());
	}
	string vlib_path = os__join_path(p->vroot, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("vlib")})));
	if (p->lookup_path.len == 0) {
		p->lookup_path = new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT("@vlib"), _SLIT("@vmodules")}));
	}
	Array_string expanded_paths = __new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t1 = 0; _t1 < p->lookup_path.len; ++_t1) {
		string path = ((string*)p->lookup_path.data)[_t1];

		if (string__eq(path, _SLIT("@vlib"))) {
			array_push((array*)&expanded_paths, _MOV((string[]){ string_clone(vlib_path) }));
		}
		else if (string__eq(path, _SLIT("@vmodules"))) {
			_PUSH_MANY(&expanded_paths, (os__vmodules_paths()), _t3, Array_string);
		}
		else {
			array_push((array*)&expanded_paths, _MOV((string[]){ string_clone(path) }));
		};
	}
	p->lookup_path = expanded_paths;
}

void v__pref__Preferences_fill_with_defaults(v__pref__Preferences* p) {
	if (p->arch == v__pref__Arch___auto) {
		p->arch = v__pref__get_host_arch();
	}
	v__pref__Preferences_expand_lookup_paths(p);
	string rpath = os__real_path(p->path);
	if ((p->out_name).len == 0) {
		string filename = string_trim_space(os__file_name(rpath));
		string base = string_all_before_last(filename, _SLIT("."));
		if ((base).len == 0) {
			base = filename;
		}
		string target_dir = (os__is_dir(rpath) ? (rpath) : (os__dir(rpath)));
		p->out_name = os__join_path(target_dir, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){base})));
		if (string__eq(rpath,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = p->vroot}}, {_SLIT("/cmd/v"), 0, { .d_c = 0 }}}))) && os__is_dir(_SLIT("vlib/compiler"))) {
			println(_SLIT("Saving the resulting V executable in `./v2`"));
			println(string__plus(_SLIT("Use `v -o v cmd/v` if you want to replace current "), _SLIT("V executable.")));
			p->out_name = _SLIT("v2");
		}
	}
	string rpath_name = os__file_name(rpath);
	p->building_v = !p->is_repl && (string__eq(rpath_name, _SLIT("v")) || string__eq(rpath_name, _SLIT("vfmt.v")));
	if (p->os == v__pref__OS___auto) {
		p->os = v__pref__get_host_os();
	}
	v__pref__Preferences_try_to_use_tcc_by_default(p);
	if ((p->ccompiler).len == 0) {
		p->ccompiler = v__pref__default_c_compiler();
	}
	v__pref__Preferences_find_cc_if_cross_compiling(p);
	p->ccompiler_type = v__pref__cc_from_string(p->ccompiler);
	p->is_test = string_ends_with(p->path, _SLIT("_test.v")) || string_ends_with(p->path, _SLIT("_test.vv")) || string_ends_with(string_all_before_last(string_all_before_last(p->path, _SLIT(".v")), _SLIT(".")), _SLIT("_test"));
	p->is_vsh = string_ends_with(p->path, _SLIT(".vsh"));
	p->is_script = p->is_vsh || string_ends_with(p->path, _SLIT(".v")) || string_ends_with(p->path, _SLIT(".vv"));
	if ((p->third_party_option).len == 0) {
		p->third_party_option = p->cflags;
	}
	string vhash = _SLIT("57fa976");
	p->cache_manager = v__vcache__new_cache_manager(new_array_from_c_array(7, 7, sizeof(string), _MOV((string[7]){string_clone(vhash),  str_intp(6, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__pref__Backend_str(p->backend)}}, {_SLIT(" | "), 0xfe10, {.d_s = v__pref__OS_str(p->os)}}, {_SLIT(" | "), 0xfe10, {.d_s = p->ccompiler}}, {_SLIT(" | "), 0xfe10, {.d_s = p->is_prod ? _SLIT("true") : _SLIT("false")}}, {_SLIT(" | "), 0xfe10, {.d_s = p->sanitize ? _SLIT("true") : _SLIT("false")}}, {_SLIT0, 0, { .d_c = 0 }}})), string_clone(string_trim_space(p->cflags)), string_clone(string_trim_space(p->third_party_option)), string_clone(Array_string_str(p->compile_defines_all)), string_clone(Array_string_str(p->compile_defines)), string_clone(Array_string_str(p->lookup_path))})));
	if (string__eq(os__user_os(), _SLIT("windows"))) {
		p->use_cache = false;
	}
	if (p->build_mode == v__pref__BuildMode__build_module) {
		p->use_cache = false;
	}
	if (p->is_shared) {
		p->use_cache = false;
	}
	if ((p->bare_builtin_dir).len == 0) {
		p->bare_builtin_dir = os__join_path(p->vroot, new_array_from_c_array(3, 3, sizeof(string), _MOV((string[3]){_SLIT("vlib"), _SLIT("builtin"), _SLIT("linux_bare")})));
	}
}

VV_LOCAL_SYMBOL void v__pref__Preferences_find_cc_if_cross_compiling(v__pref__Preferences* p) {
	if (p->os == v__pref__OS__windows) {
	}
	if (p->os == v__pref__OS__linux) {
		#if !defined(__linux__)
		{
			p->ccompiler = v__pref__vcross_compiler_name(_const_v__pref__cc_to_linux);
		}
		#endif
	}
}

VV_LOCAL_SYMBOL void v__pref__Preferences_try_to_use_tcc_by_default(v__pref__Preferences* p) {
	if (string__eq(p->ccompiler, _SLIT("tcc"))) {
		p->ccompiler = v__pref__default_tcc_compiler();
		return;
	}
	if ((p->ccompiler).len == 0) {
		if (p->is_prod) {
			return;
		}
		p->ccompiler = v__pref__default_tcc_compiler();
		return;
	}
}

string v__pref__default_tcc_compiler(void) {
	string vexe = v__pref__vexe_path();
	string vroot = os__dir(vexe);
	string vtccexe = os__join_path(vroot, new_array_from_c_array(3, 3, sizeof(string), _MOV((string[3]){_SLIT("thirdparty"), _SLIT("tcc"), _SLIT("tcc.exe")})));
	if (os__exists(vtccexe)) {
		string _t1 = vtccexe;
		return _t1;
	}
	string _t2 = _SLIT("");
	return _t2;
}

string v__pref__default_c_compiler(void) {
	string _t1 = _SLIT("gcc");
	return _t1;
	string _t2 = _SLIT("cc");
	return _t2;
}

string v__pref__vexe_path(void) {
	string vexe = os__getenv(_SLIT("VEXE"));
	if ((vexe).len != 0) {
		string _t1 = vexe;
		return _t1;
	}
	string myexe = os__executable();
	string real_vexe_path = myexe;
	for (;;) {
		real_vexe_path = os__real_path(real_vexe_path);
		break;
	}
	os__setenv(_SLIT("VEXE"), real_vexe_path, true);
	string _t2 = real_vexe_path;
	return _t2;
}

string v__pref__vcross_compiler_name(string vccname_default) {
	string vccname = os__getenv(_SLIT("VCROSS_COMPILER_NAME"));
	if ((vccname).len != 0) {
		string _t1 = vccname;
		return _t1;
	}
	string _t2 = vccname_default;
	return _t2;
}

Option_v__pref__OS v__pref__os_from_string(string os_str) {

	if (string__eq(os_str, _SLIT("linux"))) {
		Option_v__pref__OS _t1;
		opt_ok(&(v__pref__OS[]) { v__pref__OS__linux }, (Option*)(&_t1), sizeof(v__pref__OS));
		return _t1;
	}
	else if (string__eq(os_str, _SLIT("windows"))) {
		Option_v__pref__OS _t2;
		opt_ok(&(v__pref__OS[]) { v__pref__OS__windows }, (Option*)(&_t2), sizeof(v__pref__OS));
		return _t2;
	}
	else if (string__eq(os_str, _SLIT("ios"))) {
		Option_v__pref__OS _t3;
		opt_ok(&(v__pref__OS[]) { v__pref__OS__ios }, (Option*)(&_t3), sizeof(v__pref__OS));
		return _t3;
	}
	else if (string__eq(os_str, _SLIT("macos"))) {
		Option_v__pref__OS _t4;
		opt_ok(&(v__pref__OS[]) { v__pref__OS__macos }, (Option*)(&_t4), sizeof(v__pref__OS));
		return _t4;
	}
	else if (string__eq(os_str, _SLIT("freebsd"))) {
		Option_v__pref__OS _t5;
		opt_ok(&(v__pref__OS[]) { v__pref__OS__freebsd }, (Option*)(&_t5), sizeof(v__pref__OS));
		return _t5;
	}
	else if (string__eq(os_str, _SLIT("openbsd"))) {
		Option_v__pref__OS _t6;
		opt_ok(&(v__pref__OS[]) { v__pref__OS__openbsd }, (Option*)(&_t6), sizeof(v__pref__OS));
		return _t6;
	}
	else if (string__eq(os_str, _SLIT("netbsd"))) {
		Option_v__pref__OS _t7;
		opt_ok(&(v__pref__OS[]) { v__pref__OS__netbsd }, (Option*)(&_t7), sizeof(v__pref__OS));
		return _t7;
	}
	else if (string__eq(os_str, _SLIT("dragonfly"))) {
		Option_v__pref__OS _t8;
		opt_ok(&(v__pref__OS[]) { v__pref__OS__dragonfly }, (Option*)(&_t8), sizeof(v__pref__OS));
		return _t8;
	}
	else if (string__eq(os_str, _SLIT("js")) || string__eq(os_str, _SLIT("js_node"))) {
		Option_v__pref__OS _t9;
		opt_ok(&(v__pref__OS[]) { v__pref__OS__js_node }, (Option*)(&_t9), sizeof(v__pref__OS));
		return _t9;
	}
	else if (string__eq(os_str, _SLIT("js_freestanding"))) {
		Option_v__pref__OS _t10;
		opt_ok(&(v__pref__OS[]) { v__pref__OS__js_freestanding }, (Option*)(&_t10), sizeof(v__pref__OS));
		return _t10;
	}
	else if (string__eq(os_str, _SLIT("js_browser"))) {
		Option_v__pref__OS _t11;
		opt_ok(&(v__pref__OS[]) { v__pref__OS__js_browser }, (Option*)(&_t11), sizeof(v__pref__OS));
		return _t11;
	}
	else if (string__eq(os_str, _SLIT("solaris"))) {
		Option_v__pref__OS _t12;
		opt_ok(&(v__pref__OS[]) { v__pref__OS__solaris }, (Option*)(&_t12), sizeof(v__pref__OS));
		return _t12;
	}
	else if (string__eq(os_str, _SLIT("serenity"))) {
		Option_v__pref__OS _t13;
		opt_ok(&(v__pref__OS[]) { v__pref__OS__serenity }, (Option*)(&_t13), sizeof(v__pref__OS));
		return _t13;
	}
	else if (string__eq(os_str, _SLIT("vinix"))) {
		Option_v__pref__OS _t14;
		opt_ok(&(v__pref__OS[]) { v__pref__OS__vinix }, (Option*)(&_t14), sizeof(v__pref__OS));
		return _t14;
	}
	else if (string__eq(os_str, _SLIT("android"))) {
		Option_v__pref__OS _t15;
		opt_ok(&(v__pref__OS[]) { v__pref__OS__android }, (Option*)(&_t15), sizeof(v__pref__OS));
		return _t15;
	}
	else if (string__eq(os_str, _SLIT("haiku"))) {
		Option_v__pref__OS _t16;
		opt_ok(&(v__pref__OS[]) { v__pref__OS__haiku }, (Option*)(&_t16), sizeof(v__pref__OS));
		return _t16;
	}
	else if (string__eq(os_str, _SLIT("raw"))) {
		Option_v__pref__OS _t17;
		opt_ok(&(v__pref__OS[]) { v__pref__OS__raw }, (Option*)(&_t17), sizeof(v__pref__OS));
		return _t17;
	}
	else if (string__eq(os_str, _SLIT("nix"))) {
		Option_v__pref__OS _t18;
		opt_ok(&(v__pref__OS[]) { v__pref__OS__linux }, (Option*)(&_t18), sizeof(v__pref__OS));
		return _t18;
	}
	else if (string__eq(os_str, _SLIT(""))) {
		Option_v__pref__OS _t19;
		opt_ok(&(v__pref__OS[]) { v__pref__OS___auto }, (Option*)(&_t19), sizeof(v__pref__OS));
		return _t19;
	}
	else {
		return (Option_v__pref__OS){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("bad OS "), 0xfe10, {.d_s = os_str}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	};
	return (Option_v__pref__OS){0};
}

string v__pref__OS_str(v__pref__OS o) {
	switch (o) {
		case v__pref__OS___auto: 
			{
				string _t1 = _SLIT("RESERVED: AUTO");
				return _t1;
			} break;
		case v__pref__OS__ios: 
			{
				string _t2 = _SLIT("iOS");
				return _t2;
			} break;
		case v__pref__OS__macos: 
			{
				string _t3 = _SLIT("MacOS");
				return _t3;
			} break;
		case v__pref__OS__linux: 
			{
				string _t4 = _SLIT("Linux");
				return _t4;
			} break;
		case v__pref__OS__windows: 
			{
				string _t5 = _SLIT("Windows");
				return _t5;
			} break;
		case v__pref__OS__freebsd: 
			{
				string _t6 = _SLIT("FreeBSD");
				return _t6;
			} break;
		case v__pref__OS__openbsd: 
			{
				string _t7 = _SLIT("OpenBSD");
				return _t7;
			} break;
		case v__pref__OS__netbsd: 
			{
				string _t8 = _SLIT("NetBSD");
				return _t8;
			} break;
		case v__pref__OS__dragonfly: 
			{
				string _t9 = _SLIT("Dragonfly");
				return _t9;
			} break;
		case v__pref__OS__js_node: 
			{
				string _t10 = _SLIT("NodeJS");
				return _t10;
			} break;
		case v__pref__OS__js_freestanding: 
			{
				string _t11 = _SLIT("JavaScript");
				return _t11;
			} break;
		case v__pref__OS__js_browser: 
			{
				string _t12 = _SLIT("JavaScript(Browser)");
				return _t12;
			} break;
		case v__pref__OS__android: 
			{
				string _t13 = _SLIT("Android");
				return _t13;
			} break;
		case v__pref__OS__solaris: 
			{
				string _t14 = _SLIT("Solaris");
				return _t14;
			} break;
		case v__pref__OS__serenity: 
			{
				string _t15 = _SLIT("SerenityOS");
				return _t15;
			} break;
		case v__pref__OS__vinix: 
			{
				string _t16 = _SLIT("Vinix");
				return _t16;
			} break;
		case v__pref__OS__haiku: 
			{
				string _t17 = _SLIT("Haiku");
				return _t17;
			} break;
		case v__pref__OS__raw: 
			{
				string _t18 = _SLIT("Raw");
				return _t18;
			} break;
		case v__pref__OS__all: 
			{
				string _t19 = _SLIT("all");
				return _t19;
			} break;
	}
	;
	return (string){.str=(byteptr)"", .is_lit=1};
}

v__pref__OS v__pref__get_host_os(void) {
	v__pref__OS _t1 = v__pref__OS__windows;
	return _t1;
	#if defined(true)
	{
		v__pref__OS _t2 = v__pref__OS__js_node;
		return _t2;
	}
	#endif
	#if defined(true)
	{
		v__pref__OS _t3 = v__pref__OS__js_freestanding;
		return _t3;
	}
	#endif
	#if defined(true)
	{
		v__pref__OS _t4 = v__pref__OS__js_browser;
		return _t4;
	}
	#endif
	_v_panic(_SLIT("unknown host OS"));
	VUNREACHABLE();
	v__pref__OS _t5 = v__pref__OS___auto;
	return _t5;
}

bool v__pref__Backend_is_js(v__pref__Backend b) {
	bool _t1 = (b == v__pref__Backend__js_node || b == v__pref__Backend__js_browser || b == v__pref__Backend__js_freestanding);
	return _t1;
}

multi_return_ref_v__pref__Preferences_string v__pref__parse_args(Array_string known_external_commands, Array_string args) {
	multi_return_ref_v__pref__Preferences_string _t1 = v__pref__parse_args_and_show_errors(known_external_commands, args, false);
	return _t1;
}

multi_return_ref_v__pref__Preferences_string v__pref__parse_args_and_show_errors(Array_string known_external_commands, Array_string args, bool show_output) {
	v__pref__Preferences* res = (v__pref__Preferences*)memdup(&(v__pref__Preferences){.os = 0,.backend = 0,.build_mode = 0,.arch = 0,.output_mode = v__pref__OutputMode__stdout,.is_verbose = 0,.is_test = 0,.is_script = 0,.is_vsh = 0,.is_livemain = 0,.is_liveshared = 0,.is_shared = 0,.is_o = 0,.is_prof = 0,.test_runner = (string){.str=(byteptr)"", .is_lit=1},.profile_file = (string){.str=(byteptr)"", .is_lit=1},.profile_no_inline = 0,.translated = 0,.is_prod = 0,.obfuscate = 0,.is_repl = 0,.is_run = 0,.is_debug = 0,.is_vlines = 0,.sanitize = 0,.sourcemap = 0,.sourcemap_inline = true,.sourcemap_src_included = 0,.show_cc = 0,.show_c_output = 0,.show_callgraph = 0,.show_depgraph = 0,.dump_c_flags = (string){.str=(byteptr)"", .is_lit=1},.use_cache = 0,.retry_compilation = true,.is_stats = 0,.cflags = (string){.str=(byteptr)"", .is_lit=1},.m64 = 0,.ccompiler = (string){.str=(byteptr)"", .is_lit=1},.ccompiler_type = 0,.third_party_option = (string){.str=(byteptr)"", .is_lit=1},.building_v = 0,.autofree = 0,.compress = 0,.no_builtin = 0,.enable_globals = 0,.is_fmt = 0,.is_vet = 0,.is_bare = 0,.bare_builtin_dir = (string){.str=(byteptr)"", .is_lit=1},.no_preludes = 0,.custom_prelude = (string){.str=(byteptr)"", .is_lit=1},.lookup_path = __new_array(0, 0, sizeof(string)),.output_cross_c = 0,.output_es5 = 0,.prealloc = 0,.vroot = (string){.str=(byteptr)"", .is_lit=1},.out_name_c = (string){.str=(byteptr)"", .is_lit=1},.out_name = (string){.str=(byteptr)"", .is_lit=1},.path = (string){.str=(byteptr)"", .is_lit=1},.run_only = __new_array(0, 0, sizeof(string)),.compile_defines = __new_array(0, 0, sizeof(string)),.compile_defines_all = __new_array(0, 0, sizeof(string)),.run_args = __new_array(0, 0, sizeof(string)),.printfn_list = __new_array(0, 0, sizeof(string)),.print_v_files = 0,.skip_running = 0,.skip_warnings = 0,.warn_impure_v = 0,.warns_are_errors = 0,.fatal_errors = 0,.reuse_tmpc = 0,.no_rsp = 0,.no_std = 0,.use_color = 0,.no_parallel = 0,.is_vweb = 0,.only_check_syntax = 0,.check_only = 0,.experimental = 0,.skip_unused = 0,.show_timings = 0,.is_ios_simulator = 0,.is_apk = 0,.cleanup_files = __new_array(0, 0, sizeof(string)),.build_options = __new_array(0, 0, sizeof(string)),.cache_manager = (v__vcache__CacheManager){.basepath = (string){.str=(byteptr)"", .is_lit=1},.original_vopts = (string){.str=(byteptr)"", .is_lit=1},.vopts = (string){.str=(byteptr)"", .is_lit=1},.k2cpath = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),},.is_help = 0,.gc_mode = v__pref__GarbageCollectionMode__no_gc,.is_cstrict = 0,.assert_failure_mode = 0,.message_limit = 100,.nofloat = 0,.checker_match_exhaustive_cutoff_limit = 12,}, sizeof(v__pref__Preferences));
	#if defined(TARGET_IS_64BIT)
	{
		res->m64 = true;
	}
	#endif
	res->run_only = string_split_any(os__getenv(_SLIT("VTEST_ONLY_FN")), _SLIT(","));
	string command = _SLIT("");
	int command_pos = 0;
	for (int i = 0; i < args.len; i++) {
		string arg = (*(string*)/*ee elem_typ */array_get(args, i));
		Array_string current_args = array_clone_static_to_depth(array_slice(args, i, args.len), 0);

		if (string__eq(arg, _SLIT("-apk"))) {
			res->is_apk = true;
			array_push((array*)&res->build_options, _MOV((string[]){ string_clone(arg) }));
		}
		else if (string__eq(arg, _SLIT("-arch"))) {
			string target_arch = os__cmdline__option(current_args, _SLIT("-arch"), _SLIT(""));
			i++;
			Option_v__pref__Arch _t2 = v__pref__arch_from_string(target_arch);
			if (_t2.state != 0) { /*or block*/ 
				IError err = _t2.err;
				eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("unknown architecture target `"), 0xfe10, {.d_s = target_arch}}, {_SLIT("`"), 0, { .d_c = 0 }}})));
				_v_exit(1);
				VUNREACHABLE();
			;
			}
			
 			v__pref__Arch target_arch_kind =  (*(v__pref__Arch*)_t2.data);
			res->arch = target_arch_kind;
			array_push((array*)&res->build_options, _MOV((string[]){ string_clone( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = arg}}, {_SLIT(" "), 0xfe10, {.d_s = target_arch}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
		}
		else if (string__eq(arg, _SLIT("-assert"))) {
			string assert_mode = os__cmdline__option(current_args, _SLIT("-assert"), _SLIT(""));

			if (string__eq(assert_mode, _SLIT("aborts"))) {
				res->assert_failure_mode = v__pref__AssertFailureMode__aborts;
			}
			else if (string__eq(assert_mode, _SLIT("backtraces"))) {
				res->assert_failure_mode = v__pref__AssertFailureMode__backtraces;
			}
			else {
				eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("unknown assert mode `-gc "), 0xfe10, {.d_s = assert_mode}}, {_SLIT("`, supported modes are:`"), 0, { .d_c = 0 }}})));
				eprintln(_SLIT("  `-assert aborts`     .... calls abort() after assertion failure"));
				eprintln(_SLIT("  `-assert backtraces` .... calls print_backtrace() after assertion failure"));
				_v_exit(1);
				VUNREACHABLE();
			};
			i++;
		}
		else if (string__eq(arg, _SLIT("-show-timings"))) {
			res->show_timings = true;
		}
		else if (string__eq(arg, _SLIT("-check-syntax"))) {
			res->only_check_syntax = true;
		}
		else if (string__eq(arg, _SLIT("-check"))) {
			res->check_only = true;
		}
		else if (string__eq(arg, _SLIT("-h")) || string__eq(arg, _SLIT("-help")) || string__eq(arg, _SLIT("--help"))) {
			res->is_help = true;
		}
		else if (string__eq(arg, _SLIT("-v"))) {
			if (args.len > 1) {
				res->is_verbose = true;
			} else {
				command = _SLIT("version");
				command_pos = i;
			}
		}
		else if (string__eq(arg, _SLIT("-progress"))) {
		}
		else if (string__eq(arg, _SLIT("-Wimpure-v"))) {
			res->warn_impure_v = true;
		}
		else if (string__eq(arg, _SLIT("-Wfatal-errors"))) {
			res->fatal_errors = true;
		}
		else if (string__eq(arg, _SLIT("-silent"))) {
			res->output_mode = v__pref__OutputMode__silent;
		}
		else if (string__eq(arg, _SLIT("-cstrict"))) {
			res->is_cstrict = true;
		}
		else if (string__eq(arg, _SLIT("-nofloat"))) {
			res->nofloat = true;
			array_push((array*)&res->compile_defines_all, _MOV((string[]){ string_clone(_SLIT("nofloat")) }));
		}
		else if (string__eq(arg, _SLIT("-gc"))) {
			string gc_mode = os__cmdline__option(current_args, _SLIT("-gc"), _SLIT(""));

			if (string__eq(gc_mode, _SLIT("")) || string__eq(gc_mode, _SLIT("none"))) {
				res->gc_mode = v__pref__GarbageCollectionMode__no_gc;
			}
			else if (string__eq(gc_mode, _SLIT("boehm_full"))) {
				res->gc_mode = v__pref__GarbageCollectionMode__boehm_full;
				v__pref__Preferences_parse_define(res, _SLIT("gcboehm"));
				v__pref__Preferences_parse_define(res, _SLIT("gcboehm_full"));
			}
			else if (string__eq(gc_mode, _SLIT("boehm_incr"))) {
				res->gc_mode = v__pref__GarbageCollectionMode__boehm_incr;
				v__pref__Preferences_parse_define(res, _SLIT("gcboehm"));
				v__pref__Preferences_parse_define(res, _SLIT("gcboehm_incr"));
			}
			else if (string__eq(gc_mode, _SLIT("boehm_full_opt"))) {
				res->gc_mode = v__pref__GarbageCollectionMode__boehm_full_opt;
				v__pref__Preferences_parse_define(res, _SLIT("gcboehm"));
				v__pref__Preferences_parse_define(res, _SLIT("gcboehm_full"));
				v__pref__Preferences_parse_define(res, _SLIT("gcboehm_opt"));
			}
			else if (string__eq(gc_mode, _SLIT("boehm_incr_opt"))) {
				res->gc_mode = v__pref__GarbageCollectionMode__boehm_incr_opt;
				v__pref__Preferences_parse_define(res, _SLIT("gcboehm"));
				v__pref__Preferences_parse_define(res, _SLIT("gcboehm_incr"));
				v__pref__Preferences_parse_define(res, _SLIT("gcboehm_opt"));
			}
			else if (string__eq(gc_mode, _SLIT("boehm"))) {
				res->gc_mode = v__pref__GarbageCollectionMode__boehm_full_opt;
				v__pref__Preferences_parse_define(res, _SLIT("gcboehm"));
				v__pref__Preferences_parse_define(res, _SLIT("gcboehm_full"));
				v__pref__Preferences_parse_define(res, _SLIT("gcboehm_opt"));
			}
			else if (string__eq(gc_mode, _SLIT("boehm_leak"))) {
				res->gc_mode = v__pref__GarbageCollectionMode__boehm_leak;
				v__pref__Preferences_parse_define(res, _SLIT("gcboehm"));
				v__pref__Preferences_parse_define(res, _SLIT("gcboehm_leak"));
			}
			else {
				eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("unknown garbage collection mode `-gc "), 0xfe10, {.d_s = gc_mode}}, {_SLIT("`, supported modes are:`"), 0, { .d_c = 0 }}})));
				eprintln(_SLIT("  `-gc boehm` ............ default GC-mode (currently `boehm_full_opt`)"));
				eprintln(_SLIT("  `-gc boehm_full` ....... classic full collection"));
				eprintln(_SLIT("  `-gc boehm_incr` ....... incremental collection"));
				eprintln(_SLIT("  `-gc boehm_full_opt` ... optimized classic full collection"));
				eprintln(_SLIT("  `-gc boehm_incr_opt` ... optimized incremental collection"));
				eprintln(_SLIT("  `-gc boehm_leak` ....... leak detection (for debugging)"));
				eprintln(_SLIT("  `-gc none` ............. no garbage collection"));
				_v_exit(1);
				VUNREACHABLE();
			};
			i++;
		}
		else if (string__eq(arg, _SLIT("-g"))) {
			res->is_debug = true;
			res->is_vlines = true;
			array_push((array*)&res->build_options, _MOV((string[]){ string_clone(arg) }));
		}
		else if (string__eq(arg, _SLIT("-cg"))) {
			res->is_debug = true;
			res->is_vlines = false;
			array_push((array*)&res->build_options, _MOV((string[]){ string_clone(arg) }));
		}
		else if (string__eq(arg, _SLIT("-debug-tcc"))) {
			res->ccompiler = _SLIT("tcc");
			array_push((array*)&res->build_options, _MOV((string[]){ string_clone( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = arg}}, {_SLIT(" \""), 0xfe10, {.d_s = res->ccompiler}}, {_SLIT("\""), 0, { .d_c = 0 }}}))) }));
			res->retry_compilation = false;
			res->show_cc = true;
			res->show_c_output = true;
		}
		else if (string__eq(arg, _SLIT("-sourcemap"))) {
			res->sourcemap = true;
		}
		else if (string__eq(arg, _SLIT("-sourcemap-src-included"))) {
			res->sourcemap_src_included = true;
		}
		else if (string__eq(arg, _SLIT("-sourcemap-inline"))) {
			res->sourcemap_inline = true;
		}
		else if (string__eq(arg, _SLIT("-repl"))) {
			res->is_repl = true;
		}
		else if (string__eq(arg, _SLIT("-live"))) {
			res->is_livemain = true;
		}
		else if (string__eq(arg, _SLIT("-sharedlive"))) {
			res->is_liveshared = true;
			res->is_shared = true;
		}
		else if (string__eq(arg, _SLIT("-shared"))) {
			res->is_shared = true;
		}
		else if (string__eq(arg, _SLIT("--enable-globals"))) {
			v__pref__eprintln_cond(show_output, _SLIT("`--enable-globals` flag is deprecated, please use `-enable-globals` instead"));
			res->enable_globals = true;
		}
		else if (string__eq(arg, _SLIT("-enable-globals"))) {
			res->enable_globals = true;
		}
		else if (string__eq(arg, _SLIT("-autofree"))) {
			res->autofree = true;
			array_push((array*)&res->build_options, _MOV((string[]){ string_clone(arg) }));
		}
		else if (string__eq(arg, _SLIT("-manualfree"))) {
			res->autofree = false;
			array_push((array*)&res->build_options, _MOV((string[]){ string_clone(arg) }));
		}
		else if (string__eq(arg, _SLIT("-skip-unused"))) {
			res->skip_unused = true;
		}
		else if (string__eq(arg, _SLIT("-compress"))) {
			res->compress = true;
		}
		else if (string__eq(arg, _SLIT("-freestanding"))) {
			res->is_bare = true;
			array_push((array*)&res->build_options, _MOV((string[]){ string_clone(arg) }));
		}
		else if (string__eq(arg, _SLIT("-no-retry-compilation"))) {
			res->retry_compilation = false;
		}
		else if (string__eq(arg, _SLIT("-no-builtin"))) {
			res->no_builtin = true;
			array_push((array*)&res->build_options, _MOV((string[]){ string_clone(arg) }));
		}
		else if (string__eq(arg, _SLIT("-no-preludes"))) {
			res->no_preludes = true;
			array_push((array*)&res->build_options, _MOV((string[]){ string_clone(arg) }));
		}
		else if (string__eq(arg, _SLIT("-prof")) || string__eq(arg, _SLIT("-profile"))) {
			res->profile_file = os__cmdline__option(current_args, arg, _SLIT("-"));
			res->is_prof = true;
			array_push((array*)&res->build_options, _MOV((string[]){ string_clone( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = arg}}, {_SLIT(" "), 0xfe10, {.d_s = res->profile_file}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
			i++;
		}
		else if (string__eq(arg, _SLIT("-profile-no-inline"))) {
			res->profile_no_inline = true;
		}
		else if (string__eq(arg, _SLIT("-prod"))) {
			res->is_prod = true;
			array_push((array*)&res->build_options, _MOV((string[]){ string_clone(arg) }));
		}
		else if (string__eq(arg, _SLIT("-sanitize"))) {
			res->sanitize = true;
			array_push((array*)&res->build_options, _MOV((string[]){ string_clone(arg) }));
		}
		else if (string__eq(arg, _SLIT("-simulator"))) {
			res->is_ios_simulator = true;
		}
		else if (string__eq(arg, _SLIT("-stats"))) {
			res->is_stats = true;
		}
		else if (string__eq(arg, _SLIT("-obf")) || string__eq(arg, _SLIT("-obfuscate"))) {
			res->obfuscate = true;
		}
		else if (string__eq(arg, _SLIT("-translated"))) {
			res->translated = true;
		}
		else if (string__eq(arg, _SLIT("-m32")) || string__eq(arg, _SLIT("-m64"))) {
			res->m64 = string_at(arg, 2) == '6';
			res->cflags = /*f*/string__plus(res->cflags,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(" "), 0xfe10, {.d_s = arg}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		else if (string__eq(arg, _SLIT("-color"))) {
			res->use_color = v__pref__ColorOutput__always;
		}
		else if (string__eq(arg, _SLIT("-nocolor"))) {
			res->use_color = v__pref__ColorOutput__never;
		}
		else if (string__eq(arg, _SLIT("-showcc"))) {
			res->show_cc = true;
		}
		else if (string__eq(arg, _SLIT("-show-c-output"))) {
			res->show_c_output = true;
		}
		else if (string__eq(arg, _SLIT("-show-callgraph"))) {
			res->show_callgraph = true;
		}
		else if (string__eq(arg, _SLIT("-show-depgraph"))) {
			res->show_depgraph = true;
		}
		else if (string__eq(arg, _SLIT("-run-only"))) {
			res->run_only = string_split_any(os__cmdline__option(current_args, arg, os__getenv(_SLIT("VTEST_ONLY_FN"))), _SLIT(","));
			i++;
		}
		else if (string__eq(arg, _SLIT("-test-runner"))) {
			res->test_runner = os__cmdline__option(current_args, arg, res->test_runner);
			i++;
		}
		else if (string__eq(arg, _SLIT("-dump-c-flags"))) {
			res->dump_c_flags = os__cmdline__option(current_args, arg, _SLIT("-"));
			i++;
		}
		else if (string__eq(arg, _SLIT("-experimental"))) {
			res->experimental = true;
		}
		else if (string__eq(arg, _SLIT("-usecache"))) {
			res->use_cache = true;
		}
		else if (string__eq(arg, _SLIT("-nocache"))) {
			res->use_cache = false;
		}
		else if (string__eq(arg, _SLIT("-prealloc"))) {
			res->prealloc = true;
			array_push((array*)&res->build_options, _MOV((string[]){ string_clone(arg) }));
		}
		else if (string__eq(arg, _SLIT("-no-parallel"))) {
			res->no_parallel = true;
		}
		else if (string__eq(arg, _SLIT("-native"))) {
			res->backend = v__pref__Backend__native;
			array_push((array*)&res->build_options, _MOV((string[]){ string_clone(arg) }));
		}
		else if (string__eq(arg, _SLIT("-interpret"))) {
			res->backend = v__pref__Backend__interpret;
		}
		else if (string__eq(arg, _SLIT("-W"))) {
			res->warns_are_errors = true;
		}
		else if (string__eq(arg, _SLIT("-no-rsp"))) {
			res->no_rsp = true;
		}
		else if (string__eq(arg, _SLIT("-no-std"))) {
			res->no_std = true;
		}
		else if (string__eq(arg, _SLIT("-keepc"))) {
			res->reuse_tmpc = true;
		}
		else if (string__eq(arg, _SLIT("-w"))) {
			res->skip_warnings = true;
		}
		else if (string__eq(arg, _SLIT("-watch"))) {
			eprintln(_SLIT("The -watch option is deprecated. Please use the watch command `v watch file.v` instead."));
			_v_exit(1);
			VUNREACHABLE();
		}
		else if (string__eq(arg, _SLIT("-print-v-files"))) {
			res->print_v_files = true;
		}
		else if (string__eq(arg, _SLIT("-os"))) {
			string target_os = os__cmdline__option(current_args, _SLIT("-os"), _SLIT(""));
			i++;
			Option_v__pref__OS _t18 = v__pref__os_from_string(target_os);
			if (_t18.state != 0) { /*or block*/ 
				IError err = _t18.err;
				if (string__eq(target_os, _SLIT("cross"))) {
					res->output_cross_c = true;
					continue;
				}
				eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("unknown operating system target `"), 0xfe10, {.d_s = target_os}}, {_SLIT("`"), 0, { .d_c = 0 }}})));
				_v_exit(1);
				VUNREACHABLE();
			;
			}
			
 			v__pref__OS target_os_kind =  (*(v__pref__OS*)_t18.data);
			res->os = target_os_kind;
			array_push((array*)&res->build_options, _MOV((string[]){ string_clone( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = arg}}, {_SLIT(" "), 0xfe10, {.d_s = target_os}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
		}
		else if (string__eq(arg, _SLIT("-printfn"))) {
			_PUSH_MANY(&res->printfn_list, (string_split(os__cmdline__option(current_args, _SLIT("-printfn"), _SLIT("")), _SLIT(","))), _t20, Array_string);
			i++;
		}
		else if (string__eq(arg, _SLIT("-cflags"))) {
			res->cflags = /*f*/string__plus(res->cflags, string__plus(_SLIT(" "), os__cmdline__option(current_args, _SLIT("-cflags"), _SLIT(""))));
			array_push((array*)&res->build_options, _MOV((string[]){ string_clone( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = arg}}, {_SLIT(" \""), 0xfe10, {.d_s = string_trim_space(res->cflags)}}, {_SLIT("\""), 0, { .d_c = 0 }}}))) }));
			i++;
		}
		else if (string__eq(arg, _SLIT("-d")) || string__eq(arg, _SLIT("-define"))) {
			if (current_args.len > 1) {
				string define = (*(string*)/*ee elem_typ */array_get(current_args, 1));
				v__pref__Preferences_parse_define(res, define);
			}
			i++;
		}
		else if (string__eq(arg, _SLIT("-error-limit")) || string__eq(arg, _SLIT("-message-limit"))) {
			res->message_limit = string_int(os__cmdline__option(current_args, arg, _SLIT("5")));
			i++;
		}
		else if (string__eq(arg, _SLIT("-cc"))) {
			res->ccompiler = os__cmdline__option(current_args, _SLIT("-cc"), _SLIT("cc"));
			array_push((array*)&res->build_options, _MOV((string[]){ string_clone( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = arg}}, {_SLIT(" \""), 0xfe10, {.d_s = res->ccompiler}}, {_SLIT("\""), 0, { .d_c = 0 }}}))) }));
			i++;
		}
		else if (string__eq(arg, _SLIT("-checker-match-exhaustive-cutoff-limit"))) {
			res->checker_match_exhaustive_cutoff_limit = string_int(os__cmdline__option(current_args, arg, _SLIT("10")));
			i++;
		}
		else if (string__eq(arg, _SLIT("-o")) || string__eq(arg, _SLIT("-output"))) {
			res->out_name = os__cmdline__option(current_args, arg, _SLIT(""));
			if (string_ends_with(res->out_name, _SLIT(".js"))) {
				res->backend = v__pref__Backend__js_node;
				res->output_cross_c = true;
			} else if (string_ends_with(res->out_name, _SLIT(".o"))) {
				res->is_o = true;
			}
			if (!os__is_abs_path(res->out_name)) {
				res->out_name = os__join_path(os__getwd(), new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){res->out_name})));
			}
			i++;
		}
		else if (string__eq(arg, _SLIT("-b")) || string__eq(arg, _SLIT("-backend"))) {
			string sbackend = os__cmdline__option(current_args, arg, _SLIT("c"));
			array_push((array*)&res->build_options, _MOV((string[]){ string_clone( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = arg}}, {_SLIT(" "), 0xfe10, {.d_s = sbackend}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
			Option_v__pref__Backend _t24 = v__pref__backend_from_string(sbackend);
			if (_t24.state != 0) { /*or block*/ 
				IError err = _t24.err;
				continue;
			}
			
 			v__pref__Backend b =  (*(v__pref__Backend*)_t24.data);
			if (v__pref__Backend_is_js(b)) {
				res->output_cross_c = true;
			}
			res->backend = b;
			i++;
		}
		else if (string__eq(arg, _SLIT("-es5"))) {
			res->output_es5 = true;
		}
		else if (string__eq(arg, _SLIT("-path"))) {
			string path = os__cmdline__option(current_args, _SLIT("-path"), _SLIT(""));
			array_push((array*)&res->build_options, _MOV((string[]){ string_clone( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = arg}}, {_SLIT(" \""), 0xfe10, {.d_s = path}}, {_SLIT("\""), 0, { .d_c = 0 }}}))) }));
			res->lookup_path = string_split(string_replace(path, _SLIT("|"), _const_os__path_delimiter), _const_os__path_delimiter);
			i++;
		}
		else if (string__eq(arg, _SLIT("-bare-builtin-dir"))) {
			string bare_builtin_dir = os__cmdline__option(current_args, arg, _SLIT(""));
			array_push((array*)&res->build_options, _MOV((string[]){ string_clone( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = arg}}, {_SLIT(" \""), 0xfe10, {.d_s = bare_builtin_dir}}, {_SLIT("\""), 0, { .d_c = 0 }}}))) }));
			res->bare_builtin_dir = bare_builtin_dir;
			i++;
		}
		else if (string__eq(arg, _SLIT("-custom-prelude"))) {
			string path = os__cmdline__option(current_args, _SLIT("-custom-prelude"), _SLIT(""));
			array_push((array*)&res->build_options, _MOV((string[]){ string_clone( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = arg}}, {_SLIT(" "), 0xfe10, {.d_s = path}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
			Option_string _t28 = os__read_file(path);
			if (_t28.state != 0) { /*or block*/ 
				IError err = _t28.err;
				eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot open custom prelude file: "), 0xfe10, {.d_s = IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}})));
				_v_exit(1);
				VUNREACHABLE();
			;
			}
			
 			string prelude =  (*(string*)_t28.data);
			res->custom_prelude = prelude;
			i++;
		}
		else {
			if (string__eq(command, _SLIT("build")) && v__pref__is_source_file(arg)) {
				eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Use `v "), 0xfe10, {.d_s = arg}}, {_SLIT("` instead."), 0, { .d_c = 0 }}})));
				_v_exit(1);
				VUNREACHABLE();
			}
			if (string_at(arg, 0) == '-') {
				if (Array_string_contains(_const_v__pref__list_of_flags_with_param, string_substr(arg, 1, arg.len))) {
					i++;
					continue;
				}
			} else {
				if ((command).len == 0) {
					command = arg;
					command_pos = i;
					if (string__eq(command, _SLIT("run"))) {
						break;
					}
				} else if (v__pref__is_source_file(command) && v__pref__is_source_file(arg) && !Array_string_contains(known_external_commands, command)) {
					eprintln(_SLIT("Too many targets. Specify just one target: <target.v|target_directory>."));
					_v_exit(1);
					VUNREACHABLE();
				}
				continue;
			}
			if (string__eq(arg, _SLIT("-V")) || string__eq(arg, _SLIT("-version")) || string__eq(arg, _SLIT("--version"))) {
				command = _SLIT("version");
				command_pos = i;
				continue;
			}
			if ((command).len != 0 && !string__eq(command, _SLIT("build-module"))) {
				continue;
			}
			string extension = (command.len == 0 ? (_SLIT("")) : ( str_intp(2, _MOV((StrIntpData[]){{_SLIT(" for command `"), 0xfe10, {.d_s = command}}, {_SLIT("`"), 0, { .d_c = 0 }}}))));
			eprintln( str_intp(3, _MOV((StrIntpData[]){{_SLIT("Unknown argument `"), 0xfe10, {.d_s = arg}}, {_SLIT("`"), 0xfe10, {.d_s = extension}}, {_SLIT0, 0, { .d_c = 0 }}})));
			_v_exit(1);
			VUNREACHABLE();
		};
	}
	if (res->is_debug) {
		v__pref__Preferences_parse_define(res, _SLIT("debug"));
	}
	if (string__eq(command, _SLIT("run")) && res->is_prod && os__is_atty(1) > 0) {
		v__pref__eprintln_cond(show_output, _SLIT("NB: building an optimized binary takes much longer. It shouldn't be used with `v run`."));
		v__pref__eprintln_cond(show_output, _SLIT("Use `v run` without optimization, or build an optimized binary with -prod first, then run it separately."));
	}
	if (!string__eq(command, _SLIT("doc")) && string_ends_with(res->out_name, _SLIT(".v"))) {
		eprintln(_SLIT("Cannot save output binary in a .v file."));
		_v_exit(1);
		VUNREACHABLE();
	}
	if (string__eq(command, _SLIT("run"))) {
		res->is_run = true;
		if (command_pos + 2 > args.len) {
			eprintln(_SLIT("v run: no v files listed"));
			_v_exit(1);
			VUNREACHABLE();
		}
		res->path = (*(string*)/*ee elem_typ */array_get(args, command_pos + 1));
		res->run_args = array_slice(args, command_pos + 2, args.len);
		if (string__eq(res->path, _SLIT("-"))) {
			string tmp_file_path = rand__ulid();
			string tmp_exe_file_path = res->out_name;
			string output_option = _SLIT("");
			if ((tmp_exe_file_path).len == 0) {
				tmp_exe_file_path =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = tmp_file_path}}, {_SLIT(".exe"), 0, { .d_c = 0 }}}));
				output_option =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("-o \""), 0xfe10, {.d_s = tmp_exe_file_path}}, {_SLIT("\""), 0, { .d_c = 0 }}}));
			}
			string tmp_v_file_path =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = tmp_file_path}}, {_SLIT(".v"), 0, { .d_c = 0 }}}));
			string contents = os__get_raw_lines_joined();
			Option_void _t29 = os__write_file(tmp_v_file_path, contents);
			if (_t29.state != 0 && _t29.err._typ != _IError_None___index) {
				IError err = _t29.err;
				_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Failed to create temporary file "), 0xfe10, {.d_s = tmp_v_file_path}}, {_SLIT0, 0, { .d_c = 0 }}})));
				VUNREACHABLE();
			;
			}
			
 ;
			string run_options = Array_string_join(os__cmdline__options_before(args, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("run")}))), _SLIT(" "));
			string command_options = Array_string_join(array_slice(os__cmdline__options_after(args, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("run")}))), 1, os__cmdline__options_after(args, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("run")}))).len), _SLIT(" "));
			string vexe = v__pref__vexe_path();
			string tmp_cmd =  str_intp(6, _MOV((StrIntpData[]){{_SLIT("\""), 0xfe10, {.d_s = vexe}}, {_SLIT("\" "), 0xfe10, {.d_s = output_option}}, {_SLIT(" "), 0xfe10, {.d_s = run_options}}, {_SLIT(" run \""), 0xfe10, {.d_s = tmp_v_file_path}}, {_SLIT("\" "), 0xfe10, {.d_s = command_options}}, {_SLIT0, 0, { .d_c = 0 }}}));
			v__pref__Preferences_vrun_elog(res,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("tmp_cmd: "), 0xfe10, {.d_s = tmp_cmd}}, {_SLIT0, 0, { .d_c = 0 }}})));
			int tmp_result = os__system(tmp_cmd);
			v__pref__Preferences_vrun_elog(res,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("exit code: "), 0xfe07, {.d_i32 = tmp_result}}, {_SLIT0, 0, { .d_c = 0 }}})));
			if (output_option.len != 0) {
				v__pref__Preferences_vrun_elog(res,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("remove tmp exe file: "), 0xfe10, {.d_s = tmp_exe_file_path}}, {_SLIT0, 0, { .d_c = 0 }}})));
				Option_void _t30 = os__rm(tmp_exe_file_path);
				if (_t30.state != 0 && _t30.err._typ != _IError_None___index) {
					IError err = _t30.err;
				}
				
 ;
			}
			v__pref__Preferences_vrun_elog(res,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("remove tmp v file: "), 0xfe10, {.d_s = tmp_v_file_path}}, {_SLIT0, 0, { .d_c = 0 }}})));
			Option_void _t31 = os__rm(tmp_v_file_path);
			if (_t31.state != 0 && _t31.err._typ != _IError_None___index) {
				IError err = _t31.err;
			}
			
 ;
			_v_exit(tmp_result);
			VUNREACHABLE();
		}
		v__pref__must_exist(res->path);
		if (!string_ends_with(res->path, _SLIT(".v")) && os__is_executable(res->path) && os__is_file(res->path) && os__is_file(string__plus(res->path, _SLIT(".v")))) {
			v__pref__eprintln_cond(show_output,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("It looks like you wanted to run \""), 0xfe10, {.d_s = res->path}}, {_SLIT(".v\", so we went ahead and did that since \""), 0xfe10, {.d_s = res->path}}, {_SLIT("\" is an executable."), 0, { .d_c = 0 }}})));
			res->path = /*f*/string__plus(res->path, _SLIT(".v"));
		}
	} else if (v__pref__is_source_file(command)) {
		res->path = command;
	}
	if (!res->is_bare && (res->bare_builtin_dir).len != 0) {
		v__pref__eprintln_cond(show_output, _SLIT("`-bare-builtin-dir` must be used with `-freestanding`"));
	}
	if (string_ends_with(command, _SLIT(".vsh"))) {
		res->is_run = true;
		res->path = command;
		res->run_args = array_slice(args, command_pos + 1, args.len);
	} else if (string__eq(command, _SLIT("interpret"))) {
		res->backend = v__pref__Backend__interpret;
		if (command_pos + 2 > args.len) {
			eprintln(_SLIT("v interpret: no v files listed"));
			_v_exit(1);
			VUNREACHABLE();
		}
		res->path = (*(string*)/*ee elem_typ */array_get(args, command_pos + 1));
		res->run_args = array_slice(args, command_pos + 2, args.len);
		v__pref__must_exist(res->path);
		if (!string_ends_with(res->path, _SLIT(".v")) && os__is_executable(res->path) && os__is_file(res->path) && os__is_file(string__plus(res->path, _SLIT(".v")))) {
			eprintln( str_intp(3, _MOV((StrIntpData[]){{_SLIT("It looks like you wanted to run \""), 0xfe10, {.d_s = res->path}}, {_SLIT(".v\", so we went ahead and did that since \""), 0xfe10, {.d_s = res->path}}, {_SLIT("\" is an executable."), 0, { .d_c = 0 }}})));
			res->path = /*f*/string__plus(res->path, _SLIT(".v"));
		}
	}
	if (string__eq(command, _SLIT("build-module"))) {
		res->build_mode = v__pref__BuildMode__build_module;
		if (command_pos + 1 >= args.len) {
			eprintln(_SLIT("v build-module: no module specified"));
			_v_exit(1);
			VUNREACHABLE();
		}
		res->path = (*(string*)/*ee elem_typ */array_get(args, command_pos + 1));
	}
	Map_string_string m = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
	for (int _t32 = 0; _t32 < res->build_options.len; ++_t32) {
		string x = ((string*)res->build_options.data)[_t32];
		map_set(&m, &(string[]){x}, &(string[]) { _SLIT("") });
	}
	res->build_options = map_keys(&m);
	v__pref__Preferences_fill_with_defaults(res);
	return (multi_return_ref_v__pref__Preferences_string){.arg0=res, .arg1=command};
}

void v__pref__eprintln_cond(bool condition, string s) {
	if (!condition) {
		return;
	}
	eprintln(s);
}

void v__pref__Preferences_vrun_elog(v__pref__Preferences* pref, string s) {
	if (pref->is_verbose) {
		eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("> v run -, "), 0xfe10, {.d_s = s}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
}

bool v__pref__Preferences_should_output_to_stdout(v__pref__Preferences* pref) {
	bool _t1 = string_ends_with(pref->out_name, _SLIT("/-")) || string_ends_with(pref->out_name, _SLIT("\\-"));
	return _t1;
}

Option_v__pref__Arch v__pref__arch_from_string(string arch_str) {

	if (string__eq(arch_str, _SLIT("amd64")) || string__eq(arch_str, _SLIT("x86_64")) || string__eq(arch_str, _SLIT("x64")) || string__eq(arch_str, _SLIT("x86"))) {
		Option_v__pref__Arch _t1;
		opt_ok(&(v__pref__Arch[]) { v__pref__Arch__amd64 }, (Option*)(&_t1), sizeof(v__pref__Arch));
		return _t1;
	}
	else if (string__eq(arch_str, _SLIT("aarch64")) || string__eq(arch_str, _SLIT("arm64"))) {
		Option_v__pref__Arch _t2;
		opt_ok(&(v__pref__Arch[]) { v__pref__Arch__arm64 }, (Option*)(&_t2), sizeof(v__pref__Arch));
		return _t2;
	}
	else if (string__eq(arch_str, _SLIT("aarch32")) || string__eq(arch_str, _SLIT("arm32")) || string__eq(arch_str, _SLIT("arm"))) {
		Option_v__pref__Arch _t3;
		opt_ok(&(v__pref__Arch[]) { v__pref__Arch__arm32 }, (Option*)(&_t3), sizeof(v__pref__Arch));
		return _t3;
	}
	else if (string__eq(arch_str, _SLIT("rv64")) || string__eq(arch_str, _SLIT("riscv64")) || string__eq(arch_str, _SLIT("risc-v64")) || string__eq(arch_str, _SLIT("riscv")) || string__eq(arch_str, _SLIT("risc-v"))) {
		Option_v__pref__Arch _t4;
		opt_ok(&(v__pref__Arch[]) { v__pref__Arch__rv64 }, (Option*)(&_t4), sizeof(v__pref__Arch));
		return _t4;
	}
	else if (string__eq(arch_str, _SLIT("rv32")) || string__eq(arch_str, _SLIT("riscv32"))) {
		Option_v__pref__Arch _t5;
		opt_ok(&(v__pref__Arch[]) { v__pref__Arch__rv32 }, (Option*)(&_t5), sizeof(v__pref__Arch));
		return _t5;
	}
	else if (string__eq(arch_str, _SLIT("x86_32")) || string__eq(arch_str, _SLIT("x32")) || string__eq(arch_str, _SLIT("i386")) || string__eq(arch_str, _SLIT("IA-32")) || string__eq(arch_str, _SLIT("ia-32")) || string__eq(arch_str, _SLIT("ia32"))) {
		Option_v__pref__Arch _t6;
		opt_ok(&(v__pref__Arch[]) { v__pref__Arch__i386 }, (Option*)(&_t6), sizeof(v__pref__Arch));
		return _t6;
	}
	else if (string__eq(arch_str, _SLIT("js")) || string__eq(arch_str, _SLIT("js_node"))) {
		Option_v__pref__Arch _t7;
		opt_ok(&(v__pref__Arch[]) { v__pref__Arch__js_node }, (Option*)(&_t7), sizeof(v__pref__Arch));
		return _t7;
	}
	else if (string__eq(arch_str, _SLIT("js_browser"))) {
		Option_v__pref__Arch _t8;
		opt_ok(&(v__pref__Arch[]) { v__pref__Arch__js_browser }, (Option*)(&_t8), sizeof(v__pref__Arch));
		return _t8;
	}
	else if (string__eq(arch_str, _SLIT("js_freestanding"))) {
		Option_v__pref__Arch _t9;
		opt_ok(&(v__pref__Arch[]) { v__pref__Arch__js_freestanding }, (Option*)(&_t9), sizeof(v__pref__Arch));
		return _t9;
	}
	else if (string__eq(arch_str, _SLIT(""))) {
		Option_v__pref__Arch _t10;
		opt_ok(&(v__pref__Arch[]) { v__pref__Arch___auto }, (Option*)(&_t10), sizeof(v__pref__Arch));
		return _t10;
	}
	else {
		return (Option_v__pref__Arch){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("invalid arch: "), 0xfe10, {.d_s = arch_str}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	};
	return (Option_v__pref__Arch){0};
}

VV_LOCAL_SYMBOL void v__pref__must_exist(string path) {
	if (!os__exists(path)) {
		eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("v expects that `"), 0xfe10, {.d_s = path}}, {_SLIT("` exists, but it does not"), 0, { .d_c = 0 }}})));
		_v_exit(1);
		VUNREACHABLE();
	}
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL bool v__pref__is_source_file(string path) {
	bool _t1 = string_ends_with(path, _SLIT(".v")) || os__exists(path);
	return _t1;
}

Option_v__pref__Backend v__pref__backend_from_string(string s) {

	if (string__eq(s, _SLIT("c"))) {
		Option_v__pref__Backend _t1;
		opt_ok(&(v__pref__Backend[]) { v__pref__Backend__c }, (Option*)(&_t1), sizeof(v__pref__Backend));
		return _t1;
	}
	else if (string__eq(s, _SLIT("js"))) {
		Option_v__pref__Backend _t2;
		opt_ok(&(v__pref__Backend[]) { v__pref__Backend__js_node }, (Option*)(&_t2), sizeof(v__pref__Backend));
		return _t2;
	}
	else if (string__eq(s, _SLIT("js_node"))) {
		Option_v__pref__Backend _t3;
		opt_ok(&(v__pref__Backend[]) { v__pref__Backend__js_node }, (Option*)(&_t3), sizeof(v__pref__Backend));
		return _t3;
	}
	else if (string__eq(s, _SLIT("js_browser"))) {
		Option_v__pref__Backend _t4;
		opt_ok(&(v__pref__Backend[]) { v__pref__Backend__js_browser }, (Option*)(&_t4), sizeof(v__pref__Backend));
		return _t4;
	}
	else if (string__eq(s, _SLIT("js_freestanding"))) {
		Option_v__pref__Backend _t5;
		opt_ok(&(v__pref__Backend[]) { v__pref__Backend__js_freestanding }, (Option*)(&_t5), sizeof(v__pref__Backend));
		return _t5;
	}
	else if (string__eq(s, _SLIT("native"))) {
		Option_v__pref__Backend _t6;
		opt_ok(&(v__pref__Backend[]) { v__pref__Backend__native }, (Option*)(&_t6), sizeof(v__pref__Backend));
		return _t6;
	}
	else if (string__eq(s, _SLIT("interpret"))) {
		Option_v__pref__Backend _t7;
		opt_ok(&(v__pref__Backend[]) { v__pref__Backend__interpret }, (Option*)(&_t7), sizeof(v__pref__Backend));
		return _t7;
	}
	else {
		return (Option_v__pref__Backend){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Unknown backend type "), 0xfe10, {.d_s = s}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	};
	return (Option_v__pref__Backend){0};
}

v__pref__CompilerType v__pref__cc_from_string(string cc_str) {
	if (cc_str.len == 0) {
		v__pref__CompilerType _t1 = v__pref__CompilerType__gcc;
		return _t1;
	}
	string normalized_cc = string_replace(cc_str, _SLIT("\\"), _SLIT("/"));
	Array_string normalized_cc_array = string_split(normalized_cc, _SLIT("/"));
	string last_elem = (*(string*)array_last(normalized_cc_array));
	string cc = string_all_before(last_elem, _SLIT("."));
	if (string_contains(cc, _SLIT("++"))) {
		v__pref__CompilerType _t2 = v__pref__CompilerType__cplusplus;
		return _t2;
	}
	if (string_contains(cc, _SLIT("tcc")) || string_contains(cc, _SLIT("tinyc"))) {
		v__pref__CompilerType _t3 = v__pref__CompilerType__tinyc;
		return _t3;
	}
	if (string_contains(cc, _SLIT("clang"))) {
		v__pref__CompilerType _t4 = v__pref__CompilerType__clang;
		return _t4;
	}
	if (string_contains(cc, _SLIT("mingw"))) {
		v__pref__CompilerType _t5 = v__pref__CompilerType__mingw;
		return _t5;
	}
	if (string_contains(cc, _SLIT("msvc"))) {
		v__pref__CompilerType _t6 = v__pref__CompilerType__msvc;
		return _t6;
	}
	v__pref__CompilerType _t7 = v__pref__CompilerType__gcc;
	return _t7;
}

v__pref__Arch v__pref__get_host_arch(void) {
	if (__V_architecture <= ((int)(v__pref__Arch___auto)) || __V_architecture >= ((int)(v__pref__Arch___max))) {
		v__pref__Arch _t1 = v__pref__Arch__amd64;
		return _t1;
	}
	v__pref__Arch _t2 = ((v__pref__Arch)(__V_architecture));
	return _t2;
}

VV_LOCAL_SYMBOL void v__pref__Preferences_parse_define(v__pref__Preferences* prefs, string define) {
	Array_string define_parts = string_split(define, _SLIT("="));
	if (!(prefs->is_debug && string__eq(define, _SLIT("debug")))) {
		array_push((array*)&prefs->build_options, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("-d "), 0xfe10, {.d_s = define}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
	}
	if (define_parts.len == 1) {
		array_push((array*)&prefs->compile_defines, _MOV((string[]){ string_clone(define) }));
		array_push((array*)&prefs->compile_defines_all, _MOV((string[]){ string_clone(define) }));
		return;
	}
	if (define_parts.len == 2) {
		array_push((array*)&prefs->compile_defines_all, _MOV((string[]){ string_clone((*(string*)/*ee elem_typ */array_get(define_parts, 0))) }));
		string _t5 = (*(string*)/*ee elem_typ */array_get(define_parts, 1));
		
		if (string__eq(_t5, _SLIT("0"))) {
		}
		else if (string__eq(_t5, _SLIT("1"))) {
			array_push((array*)&prefs->compile_defines, _MOV((string[]){ string_clone((*(string*)/*ee elem_typ */array_get(define_parts, 0))) }));
		}
		else {
			println(string__plus( str_intp(3, _MOV((StrIntpData[]){{_SLIT("V error: Unknown define argument value `"), 0xfe10, {.d_s = (*(string*)/*ee elem_typ */array_get(define_parts, 1))}}, {_SLIT("` for "), 0xfe10, {.d_s = (*(string*)/*ee elem_typ */array_get(define_parts, 0))}}, {_SLIT("."), 0, { .d_c = 0 }}})), _SLIT(" Expected `0` or `1`.")));
			_v_exit(1);
			VUNREACHABLE();
		};
		return;
	}
	println( str_intp(2, _MOV((StrIntpData[]){{_SLIT("V error: Unknown define argument: "), 0xfe10, {.d_s = define}}, {_SLIT(". Expected at most one `=`."), 0, { .d_c = 0 }}})));
	_v_exit(1);
	VUNREACHABLE();
}

Array_string v__pref__Preferences_should_compile_filtered_files(v__pref__Preferences* prefs, string dir, Array_string files_) {
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	Array_string files = array_clone_to_depth(&files_, 0);
	qsort(files.data, files.len, files.element_size, (int (*)(const void *, const void *))&compare_16890712418519328305_string);
	Array_string all_v_files = __new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t1 = 0; _t1 < files.len; ++_t1) {
		string file = ((string*)files.data)[_t1];
		if (!string_ends_with(file, _SLIT(".v")) && !string_ends_with(file, _SLIT(".vh"))) {
			continue;
		}
		if (string_ends_with(file, _SLIT("_test.v")) || string_ends_with(string_all_before_last(string_all_before_last(file, _SLIT(".v")), _SLIT(".")), _SLIT("_test"))) {
			continue;
		}
		if ((prefs->backend == v__pref__Backend__c || prefs->backend == v__pref__Backend__interpret) && !v__pref__Preferences_should_compile_c(prefs, file)) {
			continue;
		}
		if (v__pref__Backend_is_js(prefs->backend) && !v__pref__Preferences_should_compile_js(prefs, file)) {
			continue;
		}
		if (prefs->backend == v__pref__Backend__native && !v__pref__Preferences_should_compile_native(prefs, file)) {
			continue;
		}
		if (!v__pref__Backend_is_js(prefs->backend) && !v__pref__Preferences_should_compile_asm(prefs, file)) {
			continue;
		}
		if (string_starts_with(file, _SLIT(".#"))) {
			continue;
		}
		if (prefs->nofloat && string_ends_with(file, _SLIT("float.c.v"))) {
			continue;
		}
		if (string_contains(file, _SLIT("_d_"))) {
			if (prefs->compile_defines_all.len == 0) {
				continue;
			}
			bool allowed = false;
			for (int _t2 = 0; _t2 < prefs->compile_defines.len; ++_t2) {
				string cdefine = ((string*)prefs->compile_defines.data)[_t2];
				Array_string file_postfixes = new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){ str_intp(2, _MOV((StrIntpData[]){{_SLIT("_d_"), 0xfe10, {.d_s = cdefine}}, {_SLIT(".v"), 0, { .d_c = 0 }}})),  str_intp(2, _MOV((StrIntpData[]){{_SLIT("_d_"), 0xfe10, {.d_s = cdefine}}, {_SLIT(".c.v"), 0, { .d_c = 0 }}}))}));
				for (int _t3 = 0; _t3 < file_postfixes.len; ++_t3) {
					string file_postfix = ((string*)file_postfixes.data)[_t3];
					if (string_ends_with(file, file_postfix)) {
						allowed = true;
						break;
					}
				}
				if (allowed) {
					break;
				}
			}
			if (!allowed) {
				continue;
			}
		}
		if (string_contains(file, _SLIT("_notd_"))) {
			bool allowed = true;
			for (int _t4 = 0; _t4 < prefs->compile_defines.len; ++_t4) {
				string cdefine = ((string*)prefs->compile_defines.data)[_t4];
				Array_string file_postfixes = new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){ str_intp(2, _MOV((StrIntpData[]){{_SLIT("_notd_"), 0xfe10, {.d_s = cdefine}}, {_SLIT(".v"), 0, { .d_c = 0 }}})),  str_intp(2, _MOV((StrIntpData[]){{_SLIT("_notd_"), 0xfe10, {.d_s = cdefine}}, {_SLIT(".c.v"), 0, { .d_c = 0 }}}))}));
				for (int _t5 = 0; _t5 < file_postfixes.len; ++_t5) {
					string file_postfix = ((string*)file_postfixes.data)[_t5];
					if (string_ends_with(file, file_postfix)) {
						allowed = false;
						break;
					}
				}
				if (!allowed) {
					break;
				}
			}
			if (!allowed) {
				continue;
			}
		}
		array_push((array*)&all_v_files, _MOV((string[]){ string_clone(os__join_path(dir, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){file})))) }));
	}
	Array_string defaults = __new_array_with_default(0, 0, sizeof(string), 0);
	Map_string_Array_string fnames_no_postfixes = new_map(sizeof(string), sizeof(Array_string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
	for (int _t7 = 0; _t7 < all_v_files.len; ++_t7) {
		string file = ((string*)all_v_files.data)[_t7];
		if (string_contains(file, _SLIT("default.c.v"))) {
			array_push((array*)&defaults, _MOV((string[]){ string_clone(file) }));
		} else {
			array_push((array*)&res, _MOV((string[]){ string_clone(file) }));
			string no_postfix_key = v__pref__fname_without_platform_postfix(file);
			Array_string candidates = (*(Array_string*)map_get(ADDR(map, fnames_no_postfixes), &(string[]){no_postfix_key}, &(Array_string[]){ __new_array(0, 0, sizeof(string)) }));
			array_push((array*)&candidates, _MOV((string[]){ string_clone(file) }));
			map_set(&fnames_no_postfixes, &(string[]){no_postfix_key}, &(Array_string[]) { candidates });
		}
	}
	for (int _t11 = 0; _t11 < defaults.len; ++_t11) {
		string file = ((string*)defaults.data)[_t11];
		string no_postfix_key = v__pref__fname_without_platform_postfix(file);
		if (_IN_MAP(ADDR(string, no_postfix_key), ADDR(map, fnames_no_postfixes))) {
			if (prefs->is_verbose) {
				println( str_intp(3, _MOV((StrIntpData[]){{_SLIT(">>> should_compile_filtered_files: skipping _default.c.v file "), 0xfe10, {.d_s = file}}, {_SLIT(" ; the specialized versions are: "), 0xfe10, {.d_s = Array_string_str((*(Array_string*)map_get(ADDR(map, fnames_no_postfixes), &(string[]){no_postfix_key}, &(Array_string[]){ __new_array(0, 0, sizeof(string)) })))}}, {_SLIT0, 0, { .d_c = 0 }}})));
			}
			continue;
		}
		array_push((array*)&res, _MOV((string[]){ string_clone(file) }));
	}
	if (prefs->is_verbose) {
		println( str_intp(2, _MOV((StrIntpData[]){{_SLIT(">>> should_compile_filtered_files: res: "), 0xfe10, {.d_s = Array_string_str(res)}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
	Array_string _t13 = res;
	return _t13;
}

VV_LOCAL_SYMBOL string v__pref__fname_without_platform_postfix(string file) {
	string res = string_replace_each(file, new_array_from_c_array(24, 24, sizeof(string), _MOV((string[24]){
			_SLIT("default.c.v"), _SLIT("_"), _SLIT("nix.c.v"), _SLIT("_"), _SLIT("windows.c.v"), _SLIT("_"), _SLIT("linux.c.v"), _SLIT("_"), _SLIT("darwin.c.v"),
			_SLIT("_"), _SLIT("macos.c.v"), _SLIT("_"), _SLIT("android.c.v"), _SLIT("_"), _SLIT("freebsd.c.v"), _SLIT("_"), _SLIT("netbsd.c.v"),
			_SLIT("_"), _SLIT("dragonfly.c.v"), _SLIT("_"), _SLIT("solaris.c.v"), _SLIT("_"), _SLIT("native.v"), _SLIT("_")})));
	string _t1 = res;
	return _t1;
}

bool v__pref__Preferences_should_compile_native(v__pref__Preferences* prefs, string file) {
	bool _t1 = v__pref__Preferences_should_compile_c(prefs, file);
	return _t1;
}

bool v__pref__Preferences_should_compile_c(v__pref__Preferences* prefs, string file) {
	if (string_ends_with(file, _SLIT(".js.v"))) {
		bool _t1 = false;
		return _t1;
	}
	if (prefs->is_bare && string_ends_with(file, _SLIT(".freestanding.v"))) {
		bool _t2 = true;
		return _t2;
	}
	if (prefs->os == v__pref__OS__all) {
		bool _t3 = true;
		return _t3;
	}
	if (prefs->backend != v__pref__Backend__native && string_ends_with(file, _SLIT("_native.v"))) {
		bool _t4 = false;
		return _t4;
	}
	if (prefs->os == v__pref__OS__windows && (string_ends_with(file, _SLIT("_nix.c.v")) || string_ends_with(file, _SLIT("_nix.v")))) {
		bool _t5 = false;
		return _t5;
	}
	if (prefs->os != v__pref__OS__windows && (string_ends_with(file, _SLIT("_windows.c.v")) || string_ends_with(file, _SLIT("_windows.v")))) {
		bool _t6 = false;
		return _t6;
	}
	if (prefs->os != v__pref__OS__linux && (string_ends_with(file, _SLIT("_linux.c.v")) || string_ends_with(file, _SLIT("_linux.v")))) {
		bool _t7 = false;
		return _t7;
	}
	if (prefs->os != v__pref__OS__macos && (string_ends_with(file, _SLIT("_darwin.c.v")) || string_ends_with(file, _SLIT("_darwin.v")))) {
		bool _t8 = false;
		return _t8;
	}
	if (prefs->os != v__pref__OS__macos && (string_ends_with(file, _SLIT("_macos.c.v")) || string_ends_with(file, _SLIT("_macos.v")))) {
		bool _t9 = false;
		return _t9;
	}
	if (prefs->os != v__pref__OS__ios && (string_ends_with(file, _SLIT("_ios.c.v")) || string_ends_with(file, _SLIT("_ios.v")))) {
		bool _t10 = false;
		return _t10;
	}
	if (prefs->os != v__pref__OS__android && string_ends_with(file, _SLIT("_android.c.v"))) {
		bool _t11 = false;
		return _t11;
	}
	if (prefs->os != v__pref__OS__freebsd && string_ends_with(file, _SLIT("_freebsd.c.v"))) {
		bool _t12 = false;
		return _t12;
	}
	if (prefs->os != v__pref__OS__openbsd && string_ends_with(file, _SLIT("_openbsd.c.v"))) {
		bool _t13 = false;
		return _t13;
	}
	if (prefs->os != v__pref__OS__netbsd && string_ends_with(file, _SLIT("_netbsd.c.v"))) {
		bool _t14 = false;
		return _t14;
	}
	if (prefs->os != v__pref__OS__dragonfly && string_ends_with(file, _SLIT("_dragonfly.c.v"))) {
		bool _t15 = false;
		return _t15;
	}
	if (prefs->os != v__pref__OS__solaris && string_ends_with(file, _SLIT("_solaris.c.v"))) {
		bool _t16 = false;
		return _t16;
	}
	if (prefs->os != v__pref__OS__serenity && string_ends_with(file, _SLIT("_serenity.c.v"))) {
		bool _t17 = false;
		return _t17;
	}
	if (prefs->os != v__pref__OS__vinix && string_ends_with(file, _SLIT("_vinix.c.v"))) {
		bool _t18 = false;
		return _t18;
	}
	bool _t19 = true;
	return _t19;
}

bool v__pref__Preferences_should_compile_asm(v__pref__Preferences* prefs, string path) {
	if (string_count(path, _SLIT(".")) != 2 || string_ends_with(path, _SLIT("c.v")) || string_ends_with(path, _SLIT("js.v"))) {
		bool _t1 = true;
		return _t1;
	}
	string file = string_all_before_last(path, _SLIT(".v"));
	Option_v__pref__Arch _t2 = v__pref__arch_from_string(string_all_after_last(file, _SLIT(".")));
	if (_t2.state != 0) { /*or block*/ 
		IError err = _t2.err;
		*(v__pref__Arch*) _t2.data = v__pref__Arch___auto;
	}
	
 	v__pref__Arch arch =  (*(v__pref__Arch*)_t2.data);
	if (arch != prefs->arch && prefs->arch != v__pref__Arch___auto && arch != v__pref__Arch___auto) {
		bool _t3 = false;
		return _t3;
	}
	Option_v__pref__OS _t4 = v__pref__os_from_string(string_all_before(string_all_after_last(file, _SLIT("_")), _SLIT(".")));
	if (_t4.state != 0) { /*or block*/ 
		IError err = _t4.err;
		*(v__pref__OS*) _t4.data = v__pref__OS___auto;
	}
	
 	v__pref__OS os =  (*(v__pref__OS*)_t4.data);
	if (os != prefs->os && prefs->os != v__pref__OS___auto && os != v__pref__OS___auto) {
		bool _t5 = false;
		return _t5;
	}
	bool _t6 = true;
	return _t6;
}

bool v__pref__Preferences_should_compile_js(v__pref__Preferences* prefs, string file) {
	if (!string_ends_with(file, _SLIT(".js.v")) && string_split(file, _SLIT(".")).len > 2) {
		bool _t1 = false;
		return _t1;
	}
	bool _t2 = true;
	return _t2;
}

VV_LOCAL_SYMBOL sync__Channel* sync__new_channel_st(u32 n, u32 st) {
	u32 wsem = (n > 0U ? (n) : (1));
	u32 rsem = (n > 0U ? (((u32)(0U))) : (1));
	byte* rbuf = (n > 0U ? (_v_malloc(((int)(n * st)))) : (((byte*)(0))));
	byte* sbuf = (n > 0U ? (vcalloc_noscan(((int)(n * 2U)))) : (((byte*)(0))));
	sync__Channel *ch = HEAP(sync__Channel, ((sync__Channel){
		.ringbuf = rbuf,
		.statusbuf = sbuf,
		.objsize = st,
		.writesem = (sync__Semaphore){.count = 0,},
		.readsem = (sync__Semaphore){.count = 0,},
		.writesem_im = (sync__Semaphore){.count = 0,},
		.readsem_im = (sync__Semaphore){.count = 0,},
		.write_adr = 0,
		.read_adr = 0,
		.adr_read = 0,
		.adr_written = 0,
		.write_free = n,
		.read_avail = 0U,
		.buf_elem_write_idx = 0,
		.buf_elem_read_idx = 0,
		.write_subscriber = 0,
		.read_subscriber = 0,
		.write_sub_mtx = 0,
		.read_sub_mtx = 0,
		.closed = 0,
		.cap = n,
	}));
	sync__Semaphore_init(&(*(ch)).writesem, wsem);
	sync__Semaphore_init(&(*(ch)).readsem, rsem);
	sync__Semaphore_init(&(*(ch)).writesem_im, 0U);
	sync__Semaphore_init(&(*(ch)).readsem_im, 0U);
	sync__Channel* _t1 = &(*(ch));
	return _t1;
}

VV_LOCAL_SYMBOL sync__Channel* sync__new_channel_st_noscan(u32 n, u32 st) {
	#if defined(CUSTOM_DEFINE_gcboehm_opt)
	{
	}
	#else
	{
		sync__Channel* _t1 = sync__new_channel_st(n, st);
		return _t1;
	}
	#endif
	return 0;
}

string sync__Channel_auto_str(sync__Channel* ch, string _v_typename) {
	string _t1 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT("chan "), 0xfe10, {.d_s = _v_typename}}, {_SLIT("{cap: "), 0xfe06, {.d_u32 = ch->cap}}, {_SLIT(", closed: "), 0xfe04, {.d_u16 = ch->closed}}, {_SLIT("}"), 0, { .d_c = 0 }}}));
	return _t1;
}

void sync__Channel_close(sync__Channel* ch) {
	u16 open_val = ((u16)(0U));
	if (!atomic_compare_exchange_strong_u16(&ch->closed, &open_val, 1U)) {
		return;
	}
	voidptr nulladr = ((voidptr)(0));
	for (;;) {
		if (!(!atomic_compare_exchange_weak_ptr(((voidptr*)(&ch->adr_written)), &nulladr, ((voidptr)(-1))))) break;
		nulladr = ((voidptr)(0));
	}
	sync__Semaphore_post(&ch->readsem_im);
	sync__Semaphore_post(&ch->readsem);
	u16 null16 = ((u16)(0U));
	for (;;) {
		if (!(!atomic_compare_exchange_weak_u16(&ch->read_sub_mtx, &null16, ((u16)(1U))))) break;
		null16 = ((u16)(0U));
	}
	if (ch->read_subscriber != ((voidptr)(0))) {
		sync__Semaphore_post(ch->read_subscriber->sem);
	}
	atomic_store_u16(&ch->read_sub_mtx, ((u16)(0U)));
	null16 = ((u16)(0U));
	for (;;) {
		if (!(!atomic_compare_exchange_weak_u16(&ch->write_sub_mtx, &null16, ((u16)(1U))))) break;
		null16 = ((u16)(0U));
	}
	if (ch->write_subscriber != ((voidptr)(0))) {
		sync__Semaphore_post(ch->write_subscriber->sem);
	}
	atomic_store_u16(&ch->write_sub_mtx, ((u16)(0U)));
	sync__Semaphore_post(&ch->writesem);
	if (ch->cap == 0U) {
		atomic_store_ptr(((voidptr*)(&ch->read_adr)), ((voidptr)(0)));
	}
	sync__Semaphore_post(&ch->writesem_im);
}

// Attr: [inline]
inline int sync__Channel_len(sync__Channel* ch) {
	int _t1 = ((int)(atomic_load_u32(&ch->read_avail)));
	return _t1;
}

// Attr: [inline]
inline bool sync__Channel_closed(sync__Channel* ch) {
	bool _t1 = atomic_load_u16(&ch->closed) != 0U;
	return _t1;
}

// Attr: [inline]
inline void sync__Channel_push(sync__Channel* ch, voidptr src) {
	if (sync__Channel_try_push_priv(ch, src, false) == ChanState__closed) {
		_v_panic(_SLIT("push on closed channel"));
		VUNREACHABLE();
	}
}

// Attr: [inline]
inline ChanState sync__Channel_try_push(sync__Channel* ch, voidptr src) {
	ChanState _t1 = sync__Channel_try_push_priv(ch, src, true);
	return _t1;
}

VV_LOCAL_SYMBOL ChanState sync__Channel_try_push_priv(sync__Channel* ch, voidptr src, bool no_block) {
	if (atomic_load_u16(&ch->closed) != 0U) {
		ChanState _t1 = ChanState__closed;
		return _t1;
	}
	multi_return_int_literal_int_literal mr_4432 = (no_block ? ((multi_return_int_literal_int_literal){.arg0=1,.arg1=1}) : ((multi_return_int_literal_int_literal){.arg0=_const_sync__spinloops,.arg1=_const_sync__spinloops_sem}));
	int spinloops_sem_ = mr_4432.arg0;
	int spinloops_ = mr_4432.arg1;
	bool have_swapped = false;
	for (;;) {
		bool got_sem = false;
		voidptr wradr = atomic_load_ptr(((voidptr*)(&ch->write_adr)));
		for (;;) {
			if (!(wradr != NULL)) break;
			if (atomic_compare_exchange_strong_ptr(((voidptr*)(&ch->write_adr)), &wradr, ((voidptr)(0)))) {
				memcpy(wradr, src, ch->objsize);
				voidptr nulladr = ((voidptr)(0));
				for (;;) {
					if (!(!atomic_compare_exchange_weak_ptr(((voidptr*)(&ch->adr_written)), &nulladr, wradr))) break;
					nulladr = ((voidptr)(0));
				}
				sync__Semaphore_post(&ch->readsem_im);
				ChanState _t2 = ChanState__success;
				return _t2;
			}
		}
		if (no_block && ch->cap == 0U) {
			ChanState _t3 = ChanState__not_ready;
			return _t3;
		}
		for (int _t4 = 0; _t4 < spinloops_sem_; ++_t4) {
			if (got_sem) {
				break;
			}
			got_sem = sync__Semaphore_try_wait(&ch->writesem);
		}
		if (!got_sem) {
			if (no_block) {
				ChanState _t5 = ChanState__not_ready;
				return _t5;
			}
			sync__Semaphore_wait(&ch->writesem);
		}
		if (atomic_load_u16(&ch->closed) != 0U) {
			sync__Semaphore_post(&ch->writesem);
			ChanState _t6 = ChanState__closed;
			return _t6;
		}
		if (ch->cap == 0U) {
			bool read_in_progress = false;
			atomic_store_ptr(((voidptr*)(&ch->read_adr)), src);
			wradr = atomic_load_ptr(((voidptr*)(&ch->write_adr)));
			if (wradr != NULL) {
				voidptr src2 = src;
				if (atomic_compare_exchange_strong_ptr(((voidptr*)(&ch->read_adr)), &src2, ((voidptr)(0)))) {
					sync__Semaphore_post(&ch->writesem);
					continue;
				} else {
					read_in_progress = true;
				}
			}
			if (!read_in_progress) {
				u16 null16 = ((u16)(0U));
				for (;;) {
					if (!(!atomic_compare_exchange_weak_u16(((voidptr)(&ch->read_sub_mtx)), &null16, ((u16)(1U))))) break;
					null16 = ((u16)(0U));
				}
				if (ch->read_subscriber != ((voidptr)(0))) {
					sync__Semaphore_post(ch->read_subscriber->sem);
				}
				atomic_store_u16(&ch->read_sub_mtx, ((u16)(0U)));
			}
			voidptr src2 = src;
			for (u32 sp = ((u32)(0U)); _us32_lt(sp,spinloops_) || read_in_progress; sp++) {
				if (atomic_compare_exchange_strong_ptr(((voidptr*)(&ch->adr_read)), &src2, ((voidptr)(0)))) {
					have_swapped = true;
					read_in_progress = true;
					break;
				}
				src2 = src;
			}
			bool got_im_sem = false;
			for (u32 sp = ((u32)(0U)); _us32_lt(sp,spinloops_sem_) || read_in_progress; sp++) {
				got_im_sem = sync__Semaphore_try_wait(&ch->writesem_im);
				if (got_im_sem) {
					break;
				}
			}
			for (;;) {
				if (got_im_sem) {
					got_im_sem = false;
				} else {
					sync__Semaphore_wait(&ch->writesem_im);
				}
				if (atomic_load_u16(&ch->closed) != 0U) {
					if (have_swapped || atomic_compare_exchange_strong_ptr(((voidptr*)(&ch->adr_read)), &src2, ((voidptr)(0)))) {
						sync__Semaphore_post(&ch->writesem);
						ChanState _t7 = ChanState__success;
						return _t7;
					} else {
						ChanState _t8 = ChanState__closed;
						return _t8;
					}
				}
				if (have_swapped || atomic_compare_exchange_strong_ptr(((voidptr*)(&ch->adr_read)), &src2, ((voidptr)(0)))) {
					sync__Semaphore_post(&ch->writesem);
					break;
				} else {
					sync__Semaphore_post(&ch->writesem_im);
					if (src2 == ((voidptr)(-1))) {
						sync__Semaphore_post(&ch->readsem);
						ChanState _t9 = ChanState__closed;
						return _t9;
					}
					src2 = src;
				}
			}
			ChanState _t10 = ChanState__success;
			return _t10;
		} else {
			bool space_in_queue = false;
			u32 wr_free = atomic_load_u32(&ch->write_free);
			for (;;) {
				if (!(wr_free > 0U)) break;
				space_in_queue = atomic_compare_exchange_weak_u32(&ch->write_free, &wr_free, wr_free - 1U);
				if (space_in_queue) {
					break;
				}
			}
			if (space_in_queue) {
				u32 wr_idx = atomic_load_u32(&ch->buf_elem_write_idx);
				for (;;) {
					u32 new_wr_idx = wr_idx + 1U;
					for (;;) {
						if (!(new_wr_idx >= ch->cap)) break;
						new_wr_idx -= ch->cap;
					}
					if (atomic_compare_exchange_strong_u32(&ch->buf_elem_write_idx, &wr_idx, new_wr_idx)) {
						break;
					}
				}
				byte* wr_ptr = ch->ringbuf;
				byte* status_adr = ch->statusbuf;
				{ // Unsafe block
					wr_ptr += wr_idx * ch->objsize;
					status_adr += wr_idx * sizeof(u16);
				}
				u16 expected_status = ((u16)(sync__BufferElemStat__unused));
				for (;;) {
					if (!(!atomic_compare_exchange_weak_u16(status_adr, &expected_status, ((u16)(sync__BufferElemStat__writing))))) break;
					expected_status = ((u16)(sync__BufferElemStat__unused));
				}
				memcpy(wr_ptr, src, ch->objsize);
				atomic_store_u16(((u16*)(status_adr)), ((u16)(sync__BufferElemStat__written)));
				atomic_fetch_add_u32(&ch->read_avail, 1U);
				sync__Semaphore_post(&ch->readsem);
				u16 null16 = ((u16)(0U));
				for (;;) {
					if (!(!atomic_compare_exchange_weak_u16(&ch->read_sub_mtx, &null16, ((u16)(1U))))) break;
					null16 = ((u16)(0U));
				}
				if (ch->read_subscriber != ((voidptr)(0))) {
					sync__Semaphore_post(ch->read_subscriber->sem);
				}
				atomic_store_u16(&ch->read_sub_mtx, ((u16)(0U)));
				ChanState _t11 = ChanState__success;
				return _t11;
			} else {
				if (no_block) {
					ChanState _t12 = ChanState__not_ready;
					return _t12;
				}
				sync__Semaphore_post(&ch->writesem);
			}
		}
	}
	_v_panic(_SLIT("unknown `try_push_priv` state"));
	VUNREACHABLE();
	return 0;
}

// Attr: [inline]
inline bool sync__Channel_pop(sync__Channel* ch, voidptr dest) {
	bool _t1 = sync__Channel_try_pop_priv(ch, dest, false) == ChanState__success;
	return _t1;
}

// Attr: [inline]
inline ChanState sync__Channel_try_pop(sync__Channel* ch, voidptr dest) {
	ChanState _t1 = sync__Channel_try_pop_priv(ch, dest, true);
	return _t1;
}

VV_LOCAL_SYMBOL ChanState sync__Channel_try_pop_priv(sync__Channel* ch, voidptr dest, bool no_block) {
	multi_return_int_literal_int_literal mr_9415 = (no_block ? ((multi_return_int_literal_int_literal){.arg0=1,.arg1=1}) : ((multi_return_int_literal_int_literal){.arg0=_const_sync__spinloops,.arg1=_const_sync__spinloops_sem}));
	int spinloops_sem_ = mr_9415.arg0;
	int spinloops_ = mr_9415.arg1;
	bool have_swapped = false;
	bool write_in_progress = false;
	for (;;) {
		bool got_sem = false;
		if (ch->cap == 0U) {
			voidptr rdadr = atomic_load_ptr(((voidptr*)(&ch->read_adr)));
			for (;;) {
				if (!(rdadr != NULL)) break;
				if (atomic_compare_exchange_strong_ptr(((voidptr*)(&ch->read_adr)), &rdadr, ((voidptr)(0)))) {
					memcpy(dest, rdadr, ch->objsize);
					voidptr nulladr = ((voidptr)(0));
					for (;;) {
						if (!(!atomic_compare_exchange_weak_ptr(((voidptr*)(&ch->adr_read)), &nulladr, rdadr))) break;
						nulladr = ((voidptr)(0));
					}
					sync__Semaphore_post(&ch->writesem_im);
					ChanState _t1 = ChanState__success;
					return _t1;
				}
			}
			if (no_block) {
				if (atomic_load_u16(&ch->closed) == 0U) {
					ChanState _t2 = ChanState__not_ready;
					return _t2;
				} else {
					ChanState _t3 = ChanState__closed;
					return _t3;
				}
			}
		}
		for (int _t4 = 0; _t4 < spinloops_sem_; ++_t4) {
			if (got_sem) {
				break;
			}
			got_sem = sync__Semaphore_try_wait(&ch->readsem);
		}
		if (!got_sem) {
			if (no_block) {
				if (atomic_load_u16(&ch->closed) == 0U) {
					ChanState _t5 = ChanState__not_ready;
					return _t5;
				} else {
					ChanState _t6 = ChanState__closed;
					return _t6;
				}
			}
			sync__Semaphore_wait(&ch->readsem);
		}
		if (ch->cap > 0U) {
			bool obj_in_queue = false;
			u32 rd_avail = atomic_load_u32(&ch->read_avail);
			for (;;) {
				if (!(rd_avail > 0U)) break;
				obj_in_queue = atomic_compare_exchange_weak_u32(&ch->read_avail, &rd_avail, rd_avail - 1U);
				if (obj_in_queue) {
					break;
				}
			}
			if (obj_in_queue) {
				u32 rd_idx = atomic_load_u32(&ch->buf_elem_read_idx);
				for (;;) {
					u32 new_rd_idx = rd_idx + 1U;
					for (;;) {
						if (!(new_rd_idx >= ch->cap)) break;
						new_rd_idx -= ch->cap;
					}
					if (atomic_compare_exchange_weak_u32(&ch->buf_elem_read_idx, &rd_idx, new_rd_idx)) {
						break;
					}
				}
				byte* rd_ptr = ch->ringbuf;
				byte* status_adr = ch->statusbuf;
				{ // Unsafe block
					rd_ptr += rd_idx * ch->objsize;
					status_adr += rd_idx * sizeof(u16);
				}
				u16 expected_status = ((u16)(sync__BufferElemStat__written));
				for (;;) {
					if (!(!atomic_compare_exchange_weak_u16(status_adr, &expected_status, ((u16)(sync__BufferElemStat__reading))))) break;
					expected_status = ((u16)(sync__BufferElemStat__written));
				}
				memcpy(dest, rd_ptr, ch->objsize);
				atomic_store_u16(((u16*)(status_adr)), ((u16)(sync__BufferElemStat__unused)));
				atomic_fetch_add_u32(&ch->write_free, 1U);
				sync__Semaphore_post(&ch->writesem);
				u16 null16 = ((u16)(0U));
				for (;;) {
					if (!(!atomic_compare_exchange_weak_u16(&ch->write_sub_mtx, &null16, ((u16)(1U))))) break;
					null16 = ((u16)(0U));
				}
				if (ch->write_subscriber != ((voidptr)(0))) {
					sync__Semaphore_post(ch->write_subscriber->sem);
				}
				atomic_store_u16(&ch->write_sub_mtx, ((u16)(0U)));
				ChanState _t7 = ChanState__success;
				return _t7;
			}
		}
		atomic_store_ptr(((voidptr*)(&ch->write_adr)), dest);
		if (ch->cap == 0U) {
			voidptr rdadr = atomic_load_ptr(((voidptr*)(&ch->read_adr)));
			if (rdadr != NULL) {
				voidptr dest2 = dest;
				if (atomic_compare_exchange_strong_ptr(((voidptr*)(&ch->write_adr)), &dest2, ((voidptr)(0)))) {
					sync__Semaphore_post(&ch->readsem);
					continue;
				} else {
					write_in_progress = true;
				}
			}
		}
		if (ch->cap == 0U && !write_in_progress) {
			u16 null16 = ((u16)(0U));
			for (;;) {
				if (!(!atomic_compare_exchange_weak_u16(&ch->write_sub_mtx, &null16, ((u16)(1U))))) break;
				null16 = ((u16)(0U));
			}
			if (ch->write_subscriber != ((voidptr)(0))) {
				sync__Semaphore_post(ch->write_subscriber->sem);
			}
			atomic_store_u16(&ch->write_sub_mtx, ((u16)(0U)));
		}
		voidptr dest2 = dest;
		for (u32 sp = ((u32)(0U)); _us32_lt(sp,spinloops_) || write_in_progress; sp++) {
			if (atomic_compare_exchange_strong_ptr(((voidptr*)(&ch->adr_written)), &dest2, ((voidptr)(0)))) {
				have_swapped = true;
				break;
			} else if (dest2 == ((voidptr)(-1))) {
				sync__Semaphore_post(&ch->readsem);
				ChanState _t8 = ChanState__closed;
				return _t8;
			}
			dest2 = dest;
		}
		bool got_im_sem = false;
		for (u32 sp = ((u32)(0U)); _us32_lt(sp,spinloops_sem_) || write_in_progress; sp++) {
			got_im_sem = sync__Semaphore_try_wait(&ch->readsem_im);
			if (got_im_sem) {
				break;
			}
		}
		for (;;) {
			if (got_im_sem) {
				got_im_sem = false;
			} else {
				sync__Semaphore_wait(&ch->readsem_im);
			}
			if (have_swapped || atomic_compare_exchange_strong_ptr(((voidptr*)(&ch->adr_written)), &dest2, ((voidptr)(0)))) {
				sync__Semaphore_post(&ch->readsem);
				break;
			} else {
				sync__Semaphore_post(&ch->readsem_im);
				if (dest2 == ((voidptr)(-1))) {
					sync__Semaphore_post(&ch->readsem);
					ChanState _t9 = ChanState__closed;
					return _t9;
				}
				dest2 = dest;
			}
		}
		break;
	}
	ChanState _t10 = ChanState__success;
	return _t10;
}

int sync__channel_select(Array_sync__Channel_ptr* channels, Array_sync__Direction dir, Array_voidptr* objrefs, time__Duration timeout) {
	// assert
	if (!(channels->len == dir.len)) {
		VAssertMetaInfo v_assert_meta_info__t1 = {0};
		v_assert_meta_info__t1.fpath = _SLIT("/home/runner/work/v/v/vlib/sync/channels.c.v");
		v_assert_meta_info__t1.line_nr = 549;
		v_assert_meta_info__t1.fn_name = _SLIT("sync.channel_select");
		v_assert_meta_info__t1.src = _SLIT("channels.len == dir.len");
		v_assert_meta_info__t1.op = _SLIT("==");
		v_assert_meta_info__t1.llabel = _SLIT("channels.len");
		v_assert_meta_info__t1.rlabel = _SLIT("dir.len");
		v_assert_meta_info__t1.lvalue = string_clone(int_str(channels->len)) /* typeof: v.ast.SelectorExpr type: ast.Type(0x7 = 7) */ ;
		v_assert_meta_info__t1.rvalue = string_clone(int_str(dir.len)) /* typeof: v.ast.SelectorExpr type: ast.Type(0x7 = 7) */ ;
		__print_assert_failure(&v_assert_meta_info__t1);
		_v_panic(_SLIT("Assertion failed..."));
	}
	// assert
	if (!(dir.len == objrefs->len)) {
		VAssertMetaInfo v_assert_meta_info__t2 = {0};
		v_assert_meta_info__t2.fpath = _SLIT("/home/runner/work/v/v/vlib/sync/channels.c.v");
		v_assert_meta_info__t2.line_nr = 550;
		v_assert_meta_info__t2.fn_name = _SLIT("sync.channel_select");
		v_assert_meta_info__t2.src = _SLIT("dir.len == objrefs.len");
		v_assert_meta_info__t2.op = _SLIT("==");
		v_assert_meta_info__t2.llabel = _SLIT("dir.len");
		v_assert_meta_info__t2.rlabel = _SLIT("objrefs.len");
		v_assert_meta_info__t2.lvalue = string_clone(int_str(dir.len)) /* typeof: v.ast.SelectorExpr type: ast.Type(0x7 = 7) */ ;
		v_assert_meta_info__t2.rvalue = string_clone(int_str(objrefs->len)) /* typeof: v.ast.SelectorExpr type: ast.Type(0x7 = 7) */ ;
		__print_assert_failure(&v_assert_meta_info__t2);
		_v_panic(_SLIT("Assertion failed..."));
	}
	Array_sync__Subscription subscr = __new_array_with_default(channels->len, 0, sizeof(sync__Subscription), 0);
	sync__Semaphore *sem = HEAP(sync__Semaphore, ((sync__Semaphore){.mtx = 0,.cond = 0,.count = 0,}));
	sync__Semaphore_init(&(*(sem)), 0U);
	for (int i = 0; i < channels->len; ++i) {
		sync__Channel* ch = ((sync__Channel**)channels->data)[i];
		(*(sync__Subscription*)/*ee elem_typ */array_get(subscr, i)).sem = &(*(sem));
		if ((*(sync__Direction*)/*ee elem_typ */array_get(dir, i)) == sync__Direction__push) {
			u16 null16 = ((u16)(0U));
			for (;;) {
				if (!(!atomic_compare_exchange_weak_u16(&ch->write_sub_mtx, &null16, ((u16)(1U))))) break;
				null16 = ((u16)(0U));
			}
			(*(sync__Subscription*)/*ee elem_typ */array_get(subscr, i)).prev = &ch->write_subscriber;
			{ // Unsafe block
				(*(sync__Subscription*)/*ee elem_typ */array_get(subscr, i)).nxt = ((sync__Subscription*)(atomic_exchange_ptr(((voidptr*)(&ch->write_subscriber)), &(*(sync__Subscription*)/*ee elem_typ */array_get(subscr, i)))));
			}
			if (((voidptr)((*(sync__Subscription*)/*ee elem_typ */array_get(subscr, i)).nxt)) != ((voidptr)(0))) {
				(*(sync__Subscription*)/*ee elem_typ */array_get(subscr, i)).nxt->prev = &(*(sync__Subscription*)/*ee elem_typ */array_get(subscr, i)).nxt;
			}
			atomic_store_u16(&ch->write_sub_mtx, ((u16)(0U)));
		} else {
			u16 null16 = ((u16)(0U));
			for (;;) {
				if (!(!atomic_compare_exchange_weak_u16(&ch->read_sub_mtx, &null16, ((u16)(1U))))) break;
				null16 = ((u16)(0U));
			}
			(*(sync__Subscription*)/*ee elem_typ */array_get(subscr, i)).prev = &ch->read_subscriber;
			{ // Unsafe block
				(*(sync__Subscription*)/*ee elem_typ */array_get(subscr, i)).nxt = ((sync__Subscription*)(atomic_exchange_ptr(((voidptr*)(&ch->read_subscriber)), &(*(sync__Subscription*)/*ee elem_typ */array_get(subscr, i)))));
			}
			if (((voidptr)((*(sync__Subscription*)/*ee elem_typ */array_get(subscr, i)).nxt)) != ((voidptr)(0))) {
				(*(sync__Subscription*)/*ee elem_typ */array_get(subscr, i)).nxt->prev = &(*(sync__Subscription*)/*ee elem_typ */array_get(subscr, i)).nxt;
			}
			atomic_store_u16(&ch->read_sub_mtx, ((u16)(0U)));
		}
	}
	time__StopWatch stopwatch = (time__Duration_alias_eq(timeout, _const_time__infinite) || timeout <= 0 ? ((time__StopWatch){.elapsed = 0,.start = 0,.end = 0,}) : (time__new_stopwatch((time__StopWatchOptions){.auto_start = true,})));
	int event_idx = -1;
	outer:
	for (;;) {
		u32 rnd = rand__u32_in_range(0U, ((u32)(channels->len)));
		int num_closed = 0;
		for (int j = 0; j < channels->len; ++j) {
			int i = j + ((int)(rnd));
			if (i >= channels->len) {
				i -= channels->len;
			}
			if ((*(sync__Direction*)/*ee elem_typ */array_get(dir, i)) == sync__Direction__push) {
				ChanState stat = sync__Channel_try_push_priv((*(sync__Channel**)/*ee elem_typ */array_get(*channels, i)), (*(voidptr*)/*ee elem_typ */array_get(*objrefs, i)), true);
				if (stat == ChanState__success) {
					event_idx = i;
					goto outer__break;
				} else if (stat == ChanState__closed) {
					num_closed++;
				}
			} else {
				ChanState stat = sync__Channel_try_pop_priv((*(sync__Channel**)/*ee elem_typ */array_get(*channels, i)), (*(voidptr*)/*ee elem_typ */array_get(*objrefs, i)), true);
				if (stat == ChanState__success) {
					event_idx = i;
					goto outer__break;
				} else if (stat == ChanState__closed) {
					num_closed++;
				}
			}
		}
		if (num_closed == channels->len) {
			event_idx = -2;
			goto outer__break;
		}
		if (timeout <= 0) {
			goto outer__break;
		}
		if (!time__Duration_alias_eq(timeout, _const_time__infinite)) {
			i64 remaining = timeout - time__StopWatch_elapsed(stopwatch);
			if (!sync__Semaphore_timed_wait(&(*(sem)), remaining)) {
				goto outer__break;
			}
		} else {
			sync__Semaphore_wait(&(*(sem)));
		}
		outer__continue: {}
	}
	outer__break: {}
	for (int i = 0; i < channels->len; ++i) {
		sync__Channel* ch = ((sync__Channel**)channels->data)[i];
		if ((*(sync__Direction*)/*ee elem_typ */array_get(dir, i)) == sync__Direction__push) {
			u16 null16 = ((u16)(0U));
			for (;;) {
				if (!(!atomic_compare_exchange_weak_u16(&ch->write_sub_mtx, &null16, ((u16)(1U))))) break;
				null16 = ((u16)(0U));
			}
			{ // Unsafe block
				*(*(sync__Subscription*)/*ee elem_typ */array_get(subscr, i)).prev = (*(sync__Subscription*)/*ee elem_typ */array_get(subscr, i)).nxt;
			}
			if ((*(sync__Subscription*)/*ee elem_typ */array_get(subscr, i)).nxt != 0) {
				(*(sync__Subscription*)/*ee elem_typ */array_get(subscr, i)).nxt->prev = (*(sync__Subscription*)/*ee elem_typ */array_get(subscr, i)).prev;
				sync__Semaphore_post((*(sync__Subscription*)/*ee elem_typ */array_get(subscr, i)).nxt->sem);
			}
			atomic_store_u16(&ch->write_sub_mtx, ((u16)(0U)));
		} else {
			u16 null16 = ((u16)(0U));
			for (;;) {
				if (!(!atomic_compare_exchange_weak_u16(&ch->read_sub_mtx, &null16, ((u16)(1U))))) break;
				null16 = ((u16)(0U));
			}
			{ // Unsafe block
				*(*(sync__Subscription*)/*ee elem_typ */array_get(subscr, i)).prev = (*(sync__Subscription*)/*ee elem_typ */array_get(subscr, i)).nxt;
			}
			if ((*(sync__Subscription*)/*ee elem_typ */array_get(subscr, i)).nxt != 0) {
				(*(sync__Subscription*)/*ee elem_typ */array_get(subscr, i)).nxt->prev = (*(sync__Subscription*)/*ee elem_typ */array_get(subscr, i)).prev;
				sync__Semaphore_post((*(sync__Subscription*)/*ee elem_typ */array_get(subscr, i)).nxt->sem);
			}
			atomic_store_u16(&ch->read_sub_mtx, ((u16)(0U)));
		}
	}
	sync__Semaphore_destroy((*(sem)));
	int _t3 = event_idx;
	return _t3;
}

sync__ManyTimes* sync__new_many_times(u64 times) {
	sync__ManyTimes* many_times = (sync__ManyTimes*)memdup(&(sync__ManyTimes){.m = {0},.times = times,.count = 0,}, sizeof(sync__ManyTimes));
	sync__RwMutex_init(&many_times->m);
	sync__ManyTimes* _t1 = many_times;
	return _t1;
}

void sync__ManyTimes_do(sync__ManyTimes* m, void (*f)(void)) {
	if (sync__stdatomic__load_u64(&m->count) < m->times) {
		sync__ManyTimes_do_slow(m, (voidptr)f);
	}
}

VV_LOCAL_SYMBOL void sync__ManyTimes_do_slow(sync__ManyTimes* m, void (*f)(void)) {
	sync__RwMutex_lock(&m->m);
	if (m->count < m->times) {
		sync__stdatomic__store_u64(&m->count, m->count + 1U);
		f();
	}
	sync__RwMutex_unlock(&m->m);
}

sync__Once* sync__new_once(void) {
	sync__Once* once = (sync__Once*)memdup(&(sync__Once){.m = {0},.count = 0,}, sizeof(sync__Once));
	sync__RwMutex_init(&once->m);
	sync__Once* _t1 = once;
	return _t1;
}

void sync__Once_do(sync__Once* o, void (*f)(void)) {
	if (sync__stdatomic__load_u64(&o->count) < 1U) {
		sync__Once_do_slow(o, (voidptr)f);
	}
}

VV_LOCAL_SYMBOL void sync__Once_do_slow(sync__Once* o, void (*f)(void)) {
	sync__RwMutex_lock(&o->m);
	if (o->count < 1U) {
		sync__stdatomic__store_u64(&o->count, 1U);
		f();
	}
	sync__RwMutex_unlock(&o->m);
}

// TypeDecl
// TypeDecl
sync__Mutex* sync__new_mutex(void) {
	sync__Mutex* m = (sync__Mutex*)memdup(&(sync__Mutex){.mx = 0,}, sizeof(sync__Mutex));
	sync__Mutex_init(m);
	sync__Mutex* _t1 = m;
	return _t1;
}

sync__RwMutex* sync__new_rwmutex(void) {
	sync__RwMutex* m = (sync__RwMutex*)memdup(&(sync__RwMutex){.mx = 0,}, sizeof(sync__RwMutex));
	sync__RwMutex_init(m);
	sync__RwMutex* _t1 = m;
	return _t1;
}

void sync__Mutex_init(sync__Mutex* m) {
	InitializeSRWLock(&m->mx);
}

void sync__RwMutex_init(sync__RwMutex* m) {
	InitializeSRWLock(&m->mx);
}

void sync__Mutex_lock(sync__Mutex* m) {
	AcquireSRWLockExclusive(&m->mx);
}

void sync__Mutex_unlock(sync__Mutex* m) {
	ReleaseSRWLockExclusive(&m->mx);
}

void sync__RwMutex_rlock(sync__RwMutex* m) {
	AcquireSRWLockShared(&m->mx);
}

void sync__RwMutex_lock(sync__RwMutex* m) {
	AcquireSRWLockExclusive(&m->mx);
}

void sync__RwMutex_runlock(sync__RwMutex* m) {
	ReleaseSRWLockShared(&m->mx);
}

void sync__RwMutex_unlock(sync__RwMutex* m) {
	ReleaseSRWLockExclusive(&m->mx);
}

void sync__Mutex_destroy(sync__Mutex* m) {
}

// Attr: [inline]
inline sync__Semaphore* sync__new_semaphore(void) {
	sync__Semaphore* _t1 = sync__new_semaphore_init(0U);
	return _t1;
}

sync__Semaphore* sync__new_semaphore_init(u32 n) {
	sync__Semaphore* sem = (sync__Semaphore*)memdup(&(sync__Semaphore){.mtx = 0,.cond = 0,.count = 0,}, sizeof(sync__Semaphore));
	sync__Semaphore_init(sem, n);
	sync__Semaphore* _t1 = sem;
	return _t1;
}

void sync__Semaphore_init(sync__Semaphore* sem, u32 n) {
	atomic_store_u32(&sem->count, n);
	InitializeSRWLock(&sem->mtx);
	InitializeConditionVariable(&sem->cond);
}

void sync__Semaphore_post(sync__Semaphore* sem) {
	u32 c = atomic_load_u32(&sem->count);
	for (;;) {
		if (!(c > 1U)) break;
		if (atomic_compare_exchange_weak_u32(&sem->count, &c, c + 1U)) {
			return;
		}
	}
	AcquireSRWLockExclusive(&sem->mtx);
	c = atomic_fetch_add_u32(&sem->count, 1U);
	if (c == 0U) {
		WakeConditionVariable(&sem->cond);
	}
	ReleaseSRWLockExclusive(&sem->mtx);
}

void sync__Semaphore_wait(sync__Semaphore* sem) {
	u32 c = atomic_load_u32(&sem->count);
	for (;;) {
		if (!(c > 0U)) break;
		if (atomic_compare_exchange_weak_u32(&sem->count, &c, c - 1U)) {
			return;
		}
	}
	AcquireSRWLockExclusive(&sem->mtx);
	c = atomic_load_u32(&sem->count);
	outer:
	for (;;) {
		if (c == 0U) {
			SleepConditionVariableSRW(&sem->cond, &sem->mtx, INFINITE, 0U);
			c = atomic_load_u32(&sem->count);
		}
		for (;;) {
			if (!(c > 0U)) break;
			if (atomic_compare_exchange_weak_u32(&sem->count, &c, c - 1U)) {
				if (c > 1U) {
					WakeConditionVariable(&sem->cond);
				}
				goto outer__break;
			}
		}
		outer__continue: {}
	}
	outer__break: {}
	ReleaseSRWLockExclusive(&sem->mtx);
}

bool sync__Semaphore_try_wait(sync__Semaphore* sem) {
	u32 c = atomic_load_u32(&sem->count);
	for (;;) {
		if (!(c > 0U)) break;
		if (atomic_compare_exchange_weak_u32(&sem->count, &c, c - 1U)) {
			bool _t1 = true;
			return _t1;
		}
	}
	bool _t2 = false;
	return _t2;
}

bool sync__Semaphore_timed_wait(sync__Semaphore* sem, time__Duration timeout) {
	u32 c = atomic_load_u32(&sem->count);
	for (;;) {
		if (!(c > 0U)) break;
		if (atomic_compare_exchange_weak_u32(&sem->count, &c, c - 1U)) {
			bool _t1 = true;
			return _t1;
		}
	}
	struct _FILETIME ft_start = (struct _FILETIME){.dwLowDateTime = 0,.dwHighDateTime = 0,};
	GetSystemTimeAsFileTime(&ft_start);
	u64 time_end = (((((u64)(ft_start.dwHighDateTime)) << 32U) | ft_start.dwLowDateTime)) + ((u64)(timeout / (100 * _const_time__nanosecond)));
	u32 t_ms = time__Duration_sys_milliseconds(timeout);
	AcquireSRWLockExclusive(&sem->mtx);
	int res = 0;
	c = atomic_load_u32(&sem->count);
	outer:
	for (;;) {
		if (c == 0U) {
			res = SleepConditionVariableSRW(&sem->cond, &sem->mtx, t_ms, 0U);
			if (res == 0) {
				goto outer__break;
			}
			c = atomic_load_u32(&sem->count);
		}
		for (;;) {
			if (!(c > 0U)) break;
			if (atomic_compare_exchange_weak_u32(&sem->count, &c, c - 1U)) {
				if (c > 1U) {
					WakeConditionVariable(&sem->cond);
				}
				goto outer__break;
			}
		}
		GetSystemTimeAsFileTime(&ft_start);
		u64 time_now = (((((u64)(ft_start.dwHighDateTime)) << 32U) | ft_start.dwLowDateTime));
		if (time_now > time_end) {
			goto outer__break;
		}
		t_ms = ((u32)((time_end - time_now) / 10000U));
		outer__continue: {}
	}
	outer__break: {}
	ReleaseSRWLockExclusive(&sem->mtx);
	bool _t2 = res != 0;
	return _t2;
}

void sync__Semaphore_destroy(sync__Semaphore _v_toheap_s) {
sync__Semaphore* s = HEAP(sync__Semaphore, _v_toheap_s);
}

// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
sync__WaitGroup* sync__new_waitgroup(void) {
	sync__WaitGroup *wg = HEAP(sync__WaitGroup, ((sync__WaitGroup){.task_count = 0,.wait_count = 0,.sem = (sync__Semaphore){.count = 0,},}));
	sync__WaitGroup_init(&(*(wg)));
	sync__WaitGroup* _t1 = &(*(wg));
	return _t1;
}

void sync__WaitGroup_init(sync__WaitGroup* wg) {
	sync__Semaphore_init(&wg->sem, 0U);
}

void sync__WaitGroup_add(sync__WaitGroup* wg, int delta) {
	int old_nrjobs = ((int)(atomic_fetch_add_u32(&wg->task_count, ((u32)(delta)))));
	int new_nrjobs = old_nrjobs + delta;
	u32 num_waiters = atomic_load_u32(&wg->wait_count);
	if (new_nrjobs < 0) {
		_v_panic(_SLIT("Negative number of jobs in waitgroup"));
		VUNREACHABLE();
	}
	if (new_nrjobs == 0 && num_waiters > 0U) {
		for (;;) {
			if (!(!atomic_compare_exchange_weak_u32(&wg->wait_count, &num_waiters, 0U))) break;
			if (num_waiters == 0U) {
				return;
			}
		}
		for (;;) {
			if (!((num_waiters > 0U))) break;
			sync__Semaphore_post(&wg->sem);
			num_waiters--;
		}
	}
}

void sync__WaitGroup_done(sync__WaitGroup* wg) {
	sync__WaitGroup_add(wg, -1);
}

void sync__WaitGroup_wait(sync__WaitGroup* wg) {
	int nrjobs = ((int)(atomic_load_u32(&wg->task_count)));
	if (nrjobs == 0) {
		return;
	}
	atomic_fetch_add_u32(&wg->wait_count, 1U);
	sync__Semaphore_wait(&wg->sem);
}

void help__print_and_exit(string topic) {
	string vexe = v__pref__vexe_path();
	string vroot = os__dir(vexe);
	string topicdir = os__join_path(vroot, new_array_from_c_array(3, 3, sizeof(string), _MOV((string[3]){_SLIT("cmd"), _SLIT("v"), _SLIT("help")})));
	for (int _t1 = 0; _t1 < topic.len; ++_t1) {
		byte b = topic.str[_t1];
		if ((b >= 'a' && b <= 'z') || b == '-' || (b >= '0' && b <= '9')) {
			continue;
		}
		eprintln(_const_help__unknown_topic);
		_v_exit(1);
		VUNREACHABLE();
	}
	string name = (string__eq(topic, _SLIT("init")) ? (_SLIT("new")) : (topic));
	if (string__eq(topic, _SLIT("topics"))) {
		println(help__known_topics(topicdir));
		_v_exit(0);
		VUNREACHABLE();
	}
	string target_topic = os__join_path(topicdir, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){ str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = name}}, {_SLIT(".txt"), 0, { .d_c = 0 }}}))})));
	Option_string _t2 = os__read_file(target_topic);
	if (_t2.state != 0) { /*or block*/ 
		IError err = _t2.err;
		eprintln(_const_help__unknown_topic);
		eprintln(help__known_topics(topicdir));
		_v_exit(1);
		VUNREACHABLE();
	;
	}
	
 	string content =  (*(string*)_t2.data);
	println(content);
	_v_exit(0);
	VUNREACHABLE();
}

VV_LOCAL_SYMBOL string help__known_topics(string topicdir) {
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	array_push((array*)&res, _MOV((string[]){ string_clone(_SLIT("Known help topics:")) }));
	Option_Array_string _t2 = os__glob(new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){os__join_path(topicdir, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("*.txt")})))})));
	if (_t2.state != 0) { /*or block*/ 
		IError err = _t2.err;
		*(Array_string*) _t2.data = __new_array_with_default(0, 0, sizeof(string), 0);
	}
	
 	Array_string topic_files =  (*(Array_string*)_t2.data);
	Array_string _t3 = __new_array(0, 0, sizeof(string));
	Array_string _t3_orig = topic_files;
	int _t3_len = _t3_orig.len;
	_t3 = __new_array(0, _t3_len, sizeof(string));

	for (int _t4 = 0; _t4 < _t3_len; ++_t4) {
		string it = ((string*) _t3_orig.data)[_t4];
		string ti = string_replace(os__file_name(it), _SLIT(".txt"), _SLIT(""));
		array_push((array*)&_t3, &ti);
	}
	Array_string topics =_t3;
	qsort(topics.data, topics.len, topics.element_size, (int (*)(const void *, const void *))&compare_1650400601261717902_string);
	array_push((array*)&res, _MOV((string[]){ string_clone(Array_string_join(topics, _SLIT(", "))) }));
	string _t6 = Array_string_join(res, _SLIT(""));
	return _t6;
}

Option_string v__util__find_working_diff_command(void) {
	Option_string _t1 = v__util__diff__find_working_diff_command();
	return _t1;
}

string v__util__color_compare_files(string diff_cmd, string file1, string file2) {
	string _t1 = v__util__diff__color_compare_files(diff_cmd, file1, file2);
	return _t1;
}

string v__util__color_compare_strings(string diff_cmd, string unique_prefix, string expected, string found) {
	string _t1 = v__util__diff__color_compare_strings(diff_cmd, unique_prefix, expected, found);
	return _t1;
}

v__util__EManager* v__util__new_error_manager(void) {
	v__util__EManager* _t1 = (v__util__EManager*)memdup(&(v__util__EManager){.support_color = term__can_show_color_on_stderr() && term__can_show_color_on_stdout(),}, sizeof(v__util__EManager));
	return _t1;
}

void v__util__EManager_set_support_color(v__util__EManager* e, bool b) {
	{ // Unsafe block
		v__util__EManager* me = e;
		me->support_color = b;
	}
}

string v__util__bold(string msg) {
	if (!_const_v__util__emanager->support_color) {
		string _t1 = msg;
		return _t1;
	}
	string _t2 = term__bold(msg);
	return _t2;
}

VV_LOCAL_SYMBOL string v__util__color(string kind, string msg) {
	if (!_const_v__util__emanager->support_color) {
		string _t1 = msg;
		return _t1;
	}
	if (string_contains(kind, _SLIT("error"))) {
		string _t2 = term__red(msg);
		return _t2;
	}
	if (string_contains(kind, _SLIT("notice"))) {
		string _t3 = term__yellow(msg);
		return _t3;
	}
	string _t4 = term__magenta(msg);
	return _t4;
}

string v__util__formatted_error(string kind, string omsg, string filepath, v__token__Position pos) {
	string emsg = string_replace(omsg, _SLIT("main."), _SLIT(""));
	string path = filepath;
	string verror_paths_override = os__getenv(_SLIT("VERROR_PATHS"));
	if (string__eq(verror_paths_override, _SLIT("absolute"))) {
		path = os__real_path(path);
	} else {
		string workdir = string__plus(os__getwd(), _const_os__path_separator);
		if (string_starts_with(path, workdir)) {
			path = string_replace(path, workdir, _SLIT(""));
		}
	}
	string position =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = path}}, {_SLIT(":"), 0xfe07, {.d_i32 = pos.line_nr + 1}}, {_SLIT(":"), 0xfe07, {.d_i32 = math__mathutil__max_T_int(1, pos.col + 1)}}, {_SLIT(":"), 0, { .d_c = 0 }}}));
	string scontext = Array_string_join(v__util__source_file_context(kind, filepath, pos), _SLIT("\n"));
	string final_position = v__util__bold(position);
	string final_kind = v__util__bold(v__util__color(kind, kind));
	string final_msg = emsg;
	string final_context = (scontext.len > 0 ? ( str_intp(2, _MOV((StrIntpData[]){{_SLIT("\n"), 0xfe10, {.d_s = scontext}}, {_SLIT0, 0, { .d_c = 0 }}}))) : (_SLIT("")));
	string _t1 = string_trim_space( str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = final_position}}, {_SLIT(" "), 0xfe10, {.d_s = final_kind}}, {_SLIT(" "), 0xfe10, {.d_s = final_msg}}, {_SLIT0, 0xfe10, {.d_s = final_context}}, {_SLIT0, 0, { .d_c = 0 }}})));
	return _t1;
}

// Attr: [unsafe]
Array_string v__util__cached_file2sourcelines(string path) {
	static v__util__LinesCache* cache = ((v__util__LinesCache*)(0));
	if (isnil(cache)) {
		cache = (v__util__LinesCache*)memdup(&(v__util__LinesCache){.lines = new_map(sizeof(string), sizeof(Array_string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),}, sizeof(v__util__LinesCache));
	}
	if (path.len == 0) {
		map_free(&cache->lines);
		_v_free(cache);
		cache = ((v__util__LinesCache*)(0));
		Array_string _t1 = __new_array_with_default(0, 0, sizeof(string), 0);
		return _t1;
	}
	Array_string* _t3 = (Array_string*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, cache->lines), &(string[]){path}));
	Option_Array_string _t2 = {0};
	if (_t3) {
		*((Array_string*)&_t2.data) = *((Array_string*)_t3);
	} else {
		_t2.state = 2; _t2.err = _v_error(_SLIT("array index out of range"));
	}
	
	if (_t2.state == 0) {
		Array_string res = *(Array_string*)_t2.data;
		Array_string _t4 = res;
		return _t4;
	}
	Option_string _t5 = v__util__read_file(path);
	if (_t5.state != 0) { /*or block*/ 
		IError err = _t5.err;
		*(string*) _t5.data = _SLIT("");
	}
	
 	string source =  (*(string*)_t5.data);
	Array_string res = string_split_into_lines(source);
	map_set(&cache->lines, &(string[]){path}, &(Array_string[]) { res });
	Array_string _t6 = res;
	return _t6;
}

Array_string v__util__source_file_context(string kind, string filepath, v__token__Position pos) {
	Array_string clines = __new_array_with_default(0, 0, sizeof(string), 0);
	Array_string source_lines = v__util__cached_file2sourcelines(filepath);
	if (source_lines.len == 0) {
		Array_string _t1 = clines;
		return _t1;
	}
	int bline = math__mathutil__max_T_int(0, pos.line_nr - _const_v__util__error_context_before);
	int aline = math__mathutil__max_T_int(0, math__mathutil__min_T_int(source_lines.len - 1, pos.line_nr + _const_v__util__error_context_after));
	string tab_spaces = _SLIT("    ");
	for (int iline = bline; iline <= aline; iline++) {
		string sline = (*(string*)/*ee elem_typ */array_get(source_lines, iline));
		int start_column = math__mathutil__max_T_int(0, math__mathutil__min_T_int(pos.col, sline.len));
		int end_column = math__mathutil__max_T_int(0, math__mathutil__min_T_int(pos.col + math__mathutil__max_T_int(0, pos.len), sline.len));
		string cline = (iline == pos.line_nr ? (string__plus(string__plus(string_substr(sline, 0, start_column), v__util__color(kind, string_substr(sline, start_column, end_column))), string_substr(sline, end_column, sline.len))) : (sline));
		array_push((array*)&clines, _MOV((string[]){ string_clone(string__plus( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xafe27, {.d_i32 = iline + 1}}, {_SLIT(" | "), 0, { .d_c = 0 }}})), string_replace(cline, _SLIT("\t"), tab_spaces))) }));
		if (iline == pos.line_nr) {
			strings__Builder pointerline_builder = strings__new_builder(sline.len);
			for (int i = 0; i < start_column; ) {
				if (byte_is_space(string_at(sline, i))) {
					strings__Builder_write_b(&pointerline_builder, string_at(sline, i));
					i++;
				} else {
					int char_len = utf8_char_len(string_at(sline, i));
					string spaces = string_repeat(_SLIT(" "), utf8_str_visible_length(string_substr(sline, i, i + char_len)));
					strings__Builder_write_string(&pointerline_builder, spaces);
					i += char_len;
				}
			}
			int underline_len = utf8_str_visible_length(string_substr(sline, start_column, end_column));
			string underline = (underline_len > 1 ? (string_repeat(_SLIT("~"), underline_len)) : (_SLIT("^")));
			strings__Builder_write_string(&pointerline_builder, v__util__bold(v__util__color(kind, underline)));
			array_push((array*)&clines, _MOV((string[]){ string_clone(string__plus(_SLIT("      | "), string_replace(strings__Builder_str(&pointerline_builder), _SLIT("\t"), tab_spaces))) }));
		}
	}
	Array_string _t4 = clines;
	return _t4;
}

// Attr: [noreturn]
VNORETURN void v__util__verror(string kind, string s) {
	string final_kind = v__util__bold(v__util__color(kind, kind));
	eprintln( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = final_kind}}, {_SLIT(": "), 0xfe10, {.d_s = s}}, {_SLIT0, 0, { .d_c = 0 }}})));
	_v_exit(1);
	VUNREACHABLE();
	while(1);
}

string v__util__vlines_escape_path(string path, string ccompiler) {
	bool is_cc_tcc = string_contains(ccompiler, _SLIT("tcc"));
	if (is_cc_tcc) {
		string _t1 = string__plus(_SLIT("../../../../../.."), v__util__cescaped_path(os__real_path(path)));
		return _t1;
	}
	string _t2 = v__util__cescaped_path(os__real_path(path));
	return _t2;
}

string v__util__qualify_import(v__pref__Preferences* pref, string mod, string file_path) {
	Array_string mod_paths = array_clone_to_depth(&pref->lookup_path, 0);
	_PUSH_MANY(&mod_paths, (os__vmodules_paths()), _t1, Array_string);
	string mod_path = string_replace(mod, _SLIT("."), _const_os__path_separator);
	for (int _t2 = 0; _t2 < mod_paths.len; ++_t2) {
		string search_path = ((string*)mod_paths.data)[_t2];
		string try_path = os__join_path_single(search_path, mod_path);
		if (os__is_dir(try_path)) {
			Option_string _t3;
			if (_t3 = v__util__mod_path_to_full_name(pref, mod, try_path), _t3.state == 0) {
				string m1 = *(string*)_t3.data;
				;
				string _t4 = m1;
				return _t4;
			}
		}
	}
	Option_string _t5;
	if (_t5 = v__util__mod_path_to_full_name(pref, mod, file_path), _t5.state == 0) {
		string m1 = *(string*)_t5.data;
		;
		string _t6 = m1;
		return _t6;
	}
	string _t7 = mod;
	return _t7;
}

string v__util__qualify_module(v__pref__Preferences* pref, string mod, string file_path) {
	if (string__eq(mod, _SLIT("main"))) {
		string _t1 = mod;
		return _t1;
	}
	string clean_file_path = string_all_before_last(file_path, _const_os__path_separator);
	if (string__eq(string_replace(clean_file_path, string__plus(os__getwd(), _const_os__path_separator), _SLIT("")), mod)) {
		string _t2 = mod;
		return _t2;
	}
	Option_string _t3;
	if (_t3 = v__util__mod_path_to_full_name(pref, mod, clean_file_path), _t3.state == 0) {
		string m1 = *(string*)_t3.data;
		;
		string _t4 = m1;
		return _t4;
	}
	string _t5 = mod;
	return _t5;
}

Option_string v__util__mod_path_to_full_name(v__pref__Preferences* pref, string mod, string path) {
	Array_string vmod_folders = new_array_from_c_array(3, 3, sizeof(string), _MOV((string[3]){_SLIT("vlib"), _SLIT(".vmodules"), _SLIT("modules")}));
	Array_string _t2 = __new_array(0, 0, sizeof(string));
	Array_string _t2_orig = pref->lookup_path;
	int _t2_len = _t2_orig.len;
	_t2 = __new_array(0, _t2_len, sizeof(string));

	for (int _t3 = 0; _t3 < _t2_len; ++_t3) {
		string it = ((string*) _t2_orig.data)[_t3];
		string ti = os__base(it);
		array_push((array*)&_t2, &ti);
	}
	Array_string _t1 =_t2;
	for (int _t4 = 0; _t4 < _t1.len; ++_t4) {
		string base = ((string*)_t1.data)[_t4];
		if (!Array_string_contains(vmod_folders, base)) {
			array_push((array*)&vmod_folders, _MOV((string[]){ string_clone(base) }));
		}
	}
	bool in_vmod_path = false;
	for (int _t6 = 0; _t6 < vmod_folders.len; ++_t6) {
		string vmod_folder = ((string*)vmod_folders.data)[_t6];
		if (string_contains(path, string__plus(vmod_folder, _const_os__path_separator))) {
			in_vmod_path = true;
			break;
		}
	}
	Array_string path_parts = string_split(path, _const_os__path_separator);
	string mod_path = string_replace(mod, _SLIT("."), _const_os__path_separator);
	for (int i = path_parts.len - 1; i > 0; i--) {
		string try_path = os__join_path_single(Array_string_join(array_slice(path_parts, 0, i), _const_os__path_separator), mod_path);
		if (os__is_dir(try_path)) {
			if (in_vmod_path) {
				for (int j = i; j >= 0; j--) {
					string path_part = (*(string*)/*ee elem_typ */array_get(path_parts, j));
					if (Array_string_contains(vmod_folders, path_part)) {
						string mod_full_name = Array_string_join(array_slice(string_split(try_path, _const_os__path_separator), j + 1, string_split(try_path, _const_os__path_separator).len), _SLIT("."));
						Option_string _t7;
						opt_ok(&(string[]) { mod_full_name }, (Option*)(&_t7), sizeof(string));
						return _t7;
					}
				}
			} else {
				Array_string try_path_parts = string_split(try_path, _const_os__path_separator);
				int last_v_mod = -1;
				for (int j = try_path_parts.len; j > 0; j--) {
					string parent = Array_string_join(array_slice(try_path_parts, 0, j), _const_os__path_separator);
					Option_Array_string _t8;
					if (_t8 = os__ls(parent), _t8.state == 0) {
						Array_string ls = *(Array_string*)_t8.data;
						if (Array_string_contains(ls, _SLIT("v.mod")) && (try_path_parts.len > i && !string__eq((*(string*)/*ee elem_typ */array_get(try_path_parts, i)), _SLIT("v")) && !Array_string_contains(ls, _SLIT("vlib")))) {
							last_v_mod = j;
						}
						continue;
					}
					break;
				}
				if (last_v_mod > -1) {
					string mod_full_name = Array_string_join(array_slice(try_path_parts, last_v_mod, try_path_parts.len), _SLIT("."));
					Option_string _t9;
					opt_ok(&(string[]) { mod_full_name }, (Option*)(&_t9), sizeof(string));
					return _t9;
				}
			}
		}
	}
	if (os__is_abs_path(pref->path) && os__is_abs_path(path) && os__is_dir(path)) {
		string rel_mod_path = string_replace(path, string__plus(string_all_before_last(pref->path, _const_os__path_separator), _const_os__path_separator), _SLIT(""));
		if (!string__eq(rel_mod_path, path)) {
			string full_mod_name = string_replace(rel_mod_path, _const_os__path_separator, _SLIT("."));
			Option_string _t10;
			opt_ok(&(string[]) { full_mod_name }, (Option*)(&_t10), sizeof(string));
			return _t10;
		}
	}
	return (Option_string){ .state=2, .err=_v_error(_SLIT("module not found")), .data={EMPTY_STRUCT_INITIALIZATION} };
}

// Attr: [direct_array_access]
string v__util__smart_quote(string str, bool raw) {
	int len = str.len;
	if (len == 0) {
		string _t1 = _SLIT("");
		return _t1;
	}
	if (len < 256) {
		bool is_pure = true;
		for (int i = 0; i < len; i++) {
			byte ch = ((byte)(str.str[ i]));
			if ((ch >= 37 && ch <= 90) || (ch >= 95 && ch <= 126) || ((ch == ' ' || ch == '!' || ch == '#' || ch == '[' || ch == ']'))) {
				continue;
			}
			is_pure = false;
			break;
		}
		if (is_pure) {
			string _t2 = str;
			return _t2;
		}
	}
	strings__Builder result = strings__new_builder(len + 10);
	int pos = -1;
	byte last = ((byte)(0));
	byte current = ((byte)(0));
	byte next = ((byte)(0));
	bool skip_next = false;
	for (;;) {
		pos++;
		if (skip_next) {
			skip_next = false;
			pos++;
		}
		if (pos >= len) {
			break;
		}
		last = current;
		current = str.str[ pos];
		if (pos + 1 < len) {
			next = str.str[ pos + 1];
		} else {
			next = 0;
		}
		if (current == _const_v__util__double_quote) {
			current = 0;
			strings__Builder_write_b(&result, _const_v__util__backslash);
			strings__Builder_write_b(&result, _const_v__util__double_quote);
			continue;
		}
		if (current == _const_v__util__backslash) {
			if (raw) {
				strings__Builder_write_string(&result, _const_v__util__double_escape);
				continue;
			}
			if (next == _const_v__util__backslash) {
				skip_next = true;
				strings__Builder_write_string(&result, _const_v__util__double_escape);
				continue;
			}
			if (next != 0) {
				if (raw) {
					skip_next = true;
					strings__Builder_write_string(&result, _const_v__util__double_escape);
					continue;
				}
				if (Array_byte_contains(_const_v__util__invalid_escapes, next)) {
					skip_next = true;
					strings__Builder_write_b(&result, next);
					continue;
				}
				skip_next = true;
				strings__Builder_write_b(&result, current);
				strings__Builder_write_b(&result, next);
				continue;
			}
		}
		if (current == _const_v__util__backslash_n) {
			current = 0;
			strings__Builder_write_b(&result, _const_v__util__backslash);
			strings__Builder_write_b(&result, 'n');
			continue;
		}
		if (current == _const_v__util__backslash_r && next == _const_v__util__backslash_n) {
			strings__Builder_write_b(&result, current);
			strings__Builder_write_b(&result, next);
			current = 0;
			skip_next = true;
			continue;
		}
		if (!raw) {
			if (current == '$') {
				if (last == _const_v__util__backslash) {
					strings__Builder_write_b(&result, last);
					strings__Builder_write_b(&result, current);
					continue;
				}
			}
			if (current == _const_v__util__backslash_r && next == _const_v__util__backslash_n) {
				skip_next = true;
				strings__Builder_write_b(&result, _const_v__util__backslash);
				strings__Builder_write_b(&result, 'n');
				continue;
			}
		}
		strings__Builder_write_b(&result, current);
	}
	string _t3 = strings__Builder_str(&result);
	return _t3;
}

// Attr: [inline]
inline bool v__util__is_name_char(byte c) {
	bool _t1 = (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_';
	return _t1;
}

// Attr: [inline]
inline bool v__util__is_func_char(byte c) {
	bool _t1 = (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_' || (c >= '0' && c <= '9');
	return _t1;
}

bool v__util__contains_capital(string s) {
	for (int _t1 = 0; _t1 < s.len; ++_t1) {
		byte c = s.str[_t1];
		if (c >= 'A' && c <= 'Z') {
			bool _t2 = true;
			return _t2;
		}
	}
	bool _t3 = false;
	return _t3;
}

// Attr: [direct_array_access]
bool v__util__good_type_name(string s) {
	if (s.len < 4) {
		bool _t1 = true;
		return _t1;
	}
	for (int i = 2; i < s.len; ++i) {
		if (byte_is_capital(s.str[ i]) && byte_is_capital(s.str[ i - 1]) && byte_is_capital(s.str[ i - 2])) {
			bool _t2 = false;
			return _t2;
		}
	}
	bool _t3 = true;
	return _t3;
}

// Attr: [direct_array_access]
// Attr: [inline]
inline bool v__util__is_generic_type_name(string name) {
	bool _t1 = name.len == 1 && name.str[ 0] != 'C' && (name.str[ 0] >= 'A' && name.str[ 0] <= 'Z');
	return _t1;
}

string v__util__cescaped_path(string s) {
	string _t1 = string_replace(s, _SLIT("\\"), _SLIT("\\\\"));
	return _t1;
}

v__util__Suggestion v__util__new_suggestion(string wanted, Array_string possibilities) {
	v__util__Suggestion s = (v__util__Suggestion){.known = __new_array(0, 0, sizeof(v__util__Possibility)),.wanted = wanted,.swanted = v__util__short_module_name(wanted),};
	v__util__Suggestion_add_many(&s, possibilities);
	v__util__Suggestion_sort(&s);
	v__util__Suggestion _t1 = s;
	return _t1;
}

void v__util__Suggestion_add(v__util__Suggestion* s, string val) {
	if (string__eq(val, s->wanted) || string__eq(val, s->swanted)) {
		return;
	}
	string sval = v__util__short_module_name(val);
	if (string__eq(sval, s->wanted) || string__eq(sval, s->swanted)) {
		return;
	}
	f32 similarity = ((f32)(((int)(strings__dice_coefficient(s->swanted, sval) * 1000)))) / 1000;
	array_push((array*)&s->known, _MOV((v__util__Possibility[]){ (v__util__Possibility){.value = val,.svalue = sval,.similarity = similarity,} }));
}

void v__util__Suggestion_add_many(v__util__Suggestion* s, Array_string many) {
	for (int _t1 = 0; _t1 < many.len; ++_t1) {
		string x = ((string*)many.data)[_t1];
		v__util__Suggestion_add(s, x);
	}
}

void v__util__Suggestion_sort(v__util__Suggestion* s) {
	qsort(s->known.data, s->known.len, s->known.element_size, (int (*)(const void *, const void *))&compare_6081961377856465380_v__util__Possibility_by_similarity);
}

string v__util__Suggestion_say(v__util__Suggestion s, string msg) {
	string res = msg;
	bool found = false;
	if (s.known.len > 0) {
		v__util__Possibility top_posibility = (*(v__util__Possibility*)array_last(s.known));
		if (top_posibility.similarity > 0.5) {
			string val = top_posibility.value;
			if (!string_starts_with(val, _SLIT("[]"))) {
				res = /*f*/string__plus(res,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(".\nDid you mean `"), 0xfe10, {.d_s = val}}, {_SLIT("`?"), 0, { .d_c = 0 }}})));
				found = true;
			}
		}
	}
	if (!found) {
		if (s.known.len > 0) {
			Array_string _t1 = __new_array(0, 0, sizeof(string));
			Array_v__util__Possibility _t1_orig = s.known;
			int _t1_len = _t1_orig.len;
			_t1 = __new_array(0, _t1_len, sizeof(string));

			for (int _t2 = 0; _t2 < _t1_len; ++_t2) {
				v__util__Possibility it = ((v__util__Possibility*) _t1_orig.data)[_t2];
				string ti =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = it.svalue}}, {_SLIT("`"), 0, { .d_c = 0 }}}));
				array_push((array*)&_t1, &ti);
			}
			Array_string values =_t1;
			qsort(values.data, values.len, values.element_size, (int (*)(const void *, const void *))&compare_6081961377856465380_string);
			if (values.len == 1) {
				res = /*f*/string__plus(res,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(".\n1 possibility: "), 0xfe10, {.d_s = (*(string*)/*ee elem_typ */array_get(values, 0))}}, {_SLIT("."), 0, { .d_c = 0 }}})));
			} else if (values.len < 25) {
				res = /*f*/string__plus(res, string__plus(string__plus( str_intp(2, _MOV((StrIntpData[]){{_SLIT(".\n"), 0xfe07, {.d_i32 = values.len}}, {_SLIT(" possibilities: "), 0, { .d_c = 0 }}})), Array_string_join(values, _SLIT(", "))), _SLIT(".")));
			}
		}
	}
	string _t3 = res;
	return _t3;
}

string v__util__short_module_name(string name) {
	if (!string_contains(name, _SLIT("."))) {
		string _t1 = name;
		return _t1;
	}
	Array_string vals = string_split(name, _SLIT("."));
	if (vals.len < 2) {
		string _t2 = name;
		return _t2;
	}
	string mname = (*(string*)/*ee elem_typ */array_get(vals, vals.len - 2));
	string symname = (*(string*)/*ee elem_typ */array_get(vals, vals.len - 1));
	string _t3 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = mname}}, {_SLIT("."), 0xfe10, {.d_s = symname}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t3;
}

v__util__Surrounder v__util__new_surrounder(int expected_length) {
	v__util__Surrounder _t1 = (v__util__Surrounder){.befores = __new_array_with_default(0, expected_length, sizeof(string), 0),.afters = __new_array_with_default(0, expected_length, sizeof(string), 0),};
	return _t1;
}

void v__util__Surrounder_add(v__util__Surrounder* s, string before, string after) {
	array_push((array*)&s->befores, _MOV((string[]){ string_clone(before) }));
	array_push((array*)&s->afters, _MOV((string[]){ string_clone(after) }));
}

// Attr: [manualfree]
string v__util__Surrounder_before(v__util__Surrounder* s) {
bool v__util__Surrounder_before_defer_0 = false;
strings__Builder res;
	int len = s->befores.len;
	if (len > 0) {
		res = strings__new_builder(len * 100);
		v__util__Surrounder_before_defer_0 = true;
		for (int i = 0; i < len; i++) {
			string x = (*(string*)/*ee elem_typ */array_get(s->befores, i));
			if (x.len > 0) {
				strings__Builder_writeln(&res, x);
			}
		}
		string ret = strings__Builder_str(&res);
		string _t1 = ret;
		// Defer begin
		if (v__util__Surrounder_before_defer_0) {
			strings__Builder_free(&res);
		}
		// Defer end
		return _t1;
	}
	string _t2 = _SLIT("");
	// Defer begin
	if (v__util__Surrounder_before_defer_0) {
		strings__Builder_free(&res);
	}
	// Defer end
	return _t2;
}

// Attr: [manualfree]
string v__util__Surrounder_after(v__util__Surrounder* s) {
bool v__util__Surrounder_after_defer_0 = false;
strings__Builder res;
	int len = s->afters.len;
	if (len > 0) {
		res = strings__new_builder(len * 100);
		v__util__Surrounder_after_defer_0 = true;
		for (int i = len - 1; i >= 0; i--) {
			string x = (*(string*)/*ee elem_typ */array_get(s->afters, i));
			if (x.len > 0) {
				strings__Builder_writeln(&res, x);
			}
		}
		string ret = strings__Builder_str(&res);
		string _t1 = ret;
		// Defer begin
		if (v__util__Surrounder_after_defer_0) {
			strings__Builder_free(&res);
		}
		// Defer end
		return _t1;
	}
	string _t2 = _SLIT("");
	// Defer begin
	if (v__util__Surrounder_after_defer_0) {
		strings__Builder_free(&res);
	}
	// Defer end
	return _t2;
}

void v__util__Surrounder_builder_write_befores(v__util__Surrounder* s, strings__Builder* sb) {
	int len = s->befores.len;
	if (len > 0) {
		for (int i = 0; i < len; i++) {
			string x = (*(string*)/*ee elem_typ */array_get(s->befores, i));
			if (x.len > 0) {
				strings__Builder_writeln(sb, x);
			}
		}
	}
}

void v__util__Surrounder_builder_write_afters(v__util__Surrounder* s, strings__Builder* sb) {
	int len = s->afters.len;
	if (len > 0) {
		for (int i = len - 1; i >= 0; i--) {
			string x = (*(string*)/*ee elem_typ */array_get(s->afters, i));
			if (x.len > 0) {
				strings__Builder_writeln(sb, x);
			}
		}
	}
}

// Attr: [unsafe]
void v__util__Surrounder_free(v__util__Surrounder* s) {
	{ // Unsafe block
		array_free(&s->befores);
		array_free(&s->afters);
	}
}

v__util__Timers* v__util__new_timers(v__util__TimerParams params) {
	v__util__Timers* _t1 = (v__util__Timers*)memdup(&(v__util__Timers){.label = params.label,.swatches = new_map(sizeof(string), sizeof(time__StopWatch), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.should_print = params.should_print,.already_shown = __new_array_with_default(0, 100, sizeof(string), 0),}, sizeof(v__util__Timers));
	return _t1;
}

v__util__Timers* v__util__get_timers(void) {
	v__util__Timers* _t1 = g_timers;
	return _t1;
}

void v__util__timing_start(string label) {
	v__util__Timers* t = v__util__get_timers();
	v__util__Timers_start(t, label);
}

void v__util__timing_measure(string label) {
	v__util__Timers_show(g_timers, label);
}

void v__util__timing_measure_cumulative(string label) {
	v__util__Timers_measure_cumulative(g_timers, label);
}

void v__util__timing_set_should_print(bool should_print) {
	g_timers->should_print = should_print;
}

void v__util__Timers_start(v__util__Timers* t, string name) {
	time__StopWatch* _t2 = (time__StopWatch*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, t->swatches), &(string[]){name}));
	Option_time__StopWatch _t1 = {0};
	if (_t2) {
		*((time__StopWatch*)&_t1.data) = *((time__StopWatch*)_t2);
	} else {
		_t1.state = 2; _t1.err = _v_error(_SLIT("array index out of range"));
	}
	;
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		*(time__StopWatch*) _t1.data = time__new_stopwatch((time__StopWatchOptions){.auto_start = true,});
	}
	
	time__StopWatch sw = *(time__StopWatch*)_t1.data;
	time__StopWatch_start(&sw);
	(*(time__StopWatch*)map_get_and_set((map*)&t->swatches, &(string[]){name}, &(time__StopWatch[]){ (time__StopWatch){.elapsed = 0,.start = 0,.end = 0,} })) = sw;
}

i64 v__util__Timers_measure(v__util__Timers* t, string name) {
	if (!_IN_MAP(ADDR(string, name), ADDR(map, t->swatches))) {
		Array_string timer_keys = map_keys(&t->swatches);
		eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("> Timer `"), 0xfe10, {.d_s = name}}, {_SLIT("` was NOT started."), 0, { .d_c = 0 }}})));
		eprintln(_SLIT(">   Available timers:"));
		eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT(">   "), 0xfe10, {.d_s = Array_string_str(timer_keys)}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
	i64 ms = time__Duration_microseconds(time__StopWatch_elapsed((*(time__StopWatch*)map_get(ADDR(map, t->swatches), &(string[]){name}, &(time__StopWatch[]){ (time__StopWatch){.elapsed = 0,.start = 0,.end = 0,} }))));
	i64 _t1 = ms;
	return _t1;
}

i64 v__util__Timers_measure_cumulative(v__util__Timers* t, string name) {
	i64 ms = v__util__Timers_measure(t, name);
	if (!_IN_MAP(ADDR(string, name), ADDR(map, t->swatches))) {
		i64 _t1 = ms;
		return _t1;
	}
	time__StopWatch sw = (*(time__StopWatch*)map_get(ADDR(map, t->swatches), &(string[]){name}, &(time__StopWatch[]){ (time__StopWatch){.elapsed = 0,.start = 0,.end = 0,} }));
	time__StopWatch_pause(&sw);
	(*(time__StopWatch*)map_get_and_set((map*)&t->swatches, &(string[]){name}, &(time__StopWatch[]){ (time__StopWatch){.elapsed = 0,.start = 0,.end = 0,} })) = sw;
	i64 _t2 = ms;
	return _t2;
}

void v__util__Timers_measure_pause(v__util__Timers* t, string name) {
	if (!_IN_MAP(ADDR(string, name), ADDR(map, t->swatches))) {
		return;
	}
	time__StopWatch sw = (*(time__StopWatch*)map_get(ADDR(map, t->swatches), &(string[]){name}, &(time__StopWatch[]){ (time__StopWatch){.elapsed = 0,.start = 0,.end = 0,} }));
	time__StopWatch_pause(&sw);
	(*(time__StopWatch*)map_get_and_set((map*)&t->swatches, &(string[]){name}, &(time__StopWatch[]){ (time__StopWatch){.elapsed = 0,.start = 0,.end = 0,} })) = sw;
}

void v__util__Timers_measure_resume(v__util__Timers* t, string name) {
	if (!_IN_MAP(ADDR(string, name), ADDR(map, t->swatches))) {
		return;
	}
	time__StopWatch sw = (*(time__StopWatch*)map_get(ADDR(map, t->swatches), &(string[]){name}, &(time__StopWatch[]){ (time__StopWatch){.elapsed = 0,.start = 0,.end = 0,} }));
	time__StopWatch_start(&sw);
	(*(time__StopWatch*)map_get_and_set((map*)&t->swatches, &(string[]){name}, &(time__StopWatch[]){ (time__StopWatch){.elapsed = 0,.start = 0,.end = 0,} })) = sw;
}

string v__util__Timers_message(v__util__Timers* t, string name) {
	f64 ms = ((f64)(v__util__Timers_measure(t, name))) / 1000.0;
	string value = v__util__bold( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0x10060d, {.d_f64 = ms}}, {_SLIT0, 0, { .d_c = 0 }}})));
	string formatted_message =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = value}}, {_SLIT(" ms "), 0xfe10, {.d_s = name}}, {_SLIT0, 0, { .d_c = 0 }}}));
	string _t1 = formatted_message;
	return _t1;
}

void v__util__Timers_show(v__util__Timers* t, string label) {
	string formatted_message = v__util__Timers_message(t, label);
	if (t->should_print) {
		println(formatted_message);
	}
	array_push((array*)&t->already_shown, _MOV((string[]){ string_clone(label) }));
}

void v__util__Timers_show_if_exists(v__util__Timers* t, string label) {
	if (!_IN_MAP(ADDR(string, label), ADDR(map, t->swatches))) {
		return;
	}
	v__util__Timers_show(t, label);
	array_push((array*)&t->already_shown, _MOV((string[]){ string_clone(label) }));
}

void v__util__Timers_show_remaining(v__util__Timers* t) {
	Map_string_time__StopWatch _t1 = t->swatches;
	int _t3 = _t1.key_values.len;
	for (int _t2 = 0; _t2 < _t3; ++_t2 ) {
		int _t4 = _t1.key_values.len - _t3;
		_t3 = _t1.key_values.len;
		if (_t4 < 0) {
			_t2 = -1;
			continue;
		}
		if (!DenseArray_has_index(&_t1.key_values, _t2)) {continue;}
		string k = /*key*/ *(string*)DenseArray_key(&_t1.key_values, _t2);
		k = string_clone(k);
		if (Array_string_contains(t->already_shown, k)) {
			continue;
		}
		v__util__Timers_show(t, k);
	}
}

void v__util__Timers_dump_all(v__util__Timers* t) {
	Map_string_time__StopWatch _t1 = t->swatches;
	int _t3 = _t1.key_values.len;
	for (int _t2 = 0; _t2 < _t3; ++_t2 ) {
		int _t4 = _t1.key_values.len - _t3;
		_t3 = _t1.key_values.len;
		if (_t4 < 0) {
			_t2 = -1;
			continue;
		}
		if (!DenseArray_has_index(&_t1.key_values, _t2)) {continue;}
		string k = /*key*/ *(string*)DenseArray_key(&_t1.key_values, _t2);
		k = string_clone(k);
		string elapsed = v__util__Timers_message(t, k);
		println(elapsed);
	}
}

string v__util__skip_bom(string file_content) {
	string raw_text = file_content;
	if (raw_text.len >= 3) {
		{ // Unsafe block
			byte* c_text = raw_text.str;
			if (c_text[0] == 0xEF && c_text[1] == 0xBB && c_text[2] == 0xBF) {
				int offset_from_begin = 3;
				raw_text = tos((voidptr)&/*qq*/c_text[offset_from_begin], vstrlen(c_text) - offset_from_begin);
			}
		}
	}
	string _t1 = raw_text;
	return _t1;
}

string v__util__tabs(int n) {
	string _t1 = (n < _const_v__util__const_tabs.len ? ((*(string*)/*ee elem_typ */array_get(_const_v__util__const_tabs, n))) : (string_repeat(_SLIT("\t"), n)));
	return _t1;
}

void v__util__set_vroot_folder(string vroot_path) {
	string vname = (string__eq(os__user_os(), _SLIT("windows")) ? (_SLIT("v.exe")) : (_SLIT("v")));
	os__setenv(_SLIT("VEXE"), os__real_path(os__join_path_single(vroot_path, vname)), true);
	os__setenv(_SLIT("VCHILD"), _SLIT("true"), true);
}

Option_string v__util__resolve_vmodroot(string str, string dir) {
	v__vmod__ModFileCacher* mcache = v__vmod__get_cache();
	v__vmod__ModFileAndFolder vmod_file_location = v__vmod__ModFileCacher_get_by_folder(mcache, dir);
	if (vmod_file_location.vmod_file.len == 0) {
		return (Option_string){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("To use @VMODROOT, you need to have a \"v.mod\" file in "), 0xfe10, {.d_s = dir}}, {_SLIT(", or in one of its parent folders."), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	string vmod_path = vmod_file_location.vmod_folder;
	Option_string _t2;
	opt_ok(&(string[]) { string_replace(str, _SLIT("@VMODROOT"), os__real_path(vmod_path)) }, (Option*)(&_t2), sizeof(string));
	return _t2;
}

Option_string v__util__resolve_env_value(string str, bool check_for_presence) {
	string env_ident = _SLIT("$env('");
	Option_int _t1 = string_index(str, env_ident);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		return (Option_string){ .state=2, .err=_v_error(string__plus( str_intp(2, _MOV((StrIntpData[]){{_SLIT("no \""), 0xfe10, {.d_s = env_ident}}, {_SLIT0, 0, { .d_c = 0 }}})),  str_intp(2, _MOV((StrIntpData[]){{_SLIT("...\')\" could be found in \""), 0xfe10, {.d_s = str}}, {_SLIT("\"."), 0, { .d_c = 0 }}})))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	int at =  (*(int*)_t1.data);
	byte ch = ((byte)('.'));
	string env_lit = _SLIT("");
	for (int i = at + env_ident.len; i < str.len && ch != ')'; i++) {
		ch = ((byte)(string_at(str, i)));
		if (byte_is_letter(ch) || byte_is_digit(ch) || ch == '_') {
			env_lit = /*f*/string__plus(env_lit, byte_ascii_str(ch));
		} else {
			if (!(ch == '\'' || ch == ')')) {
				if (ch == '$') {
					return (Option_string){ .state=2, .err=_v_error(_SLIT("cannot use string interpolation in compile time $env() expression")), .data={EMPTY_STRUCT_INITIALIZATION} };
				}
				return (Option_string){ .state=2, .err=_v_error( str_intp(3, _MOV((StrIntpData[]){{_SLIT("invalid environment variable name in \""), 0xfe10, {.d_s = str}}, {_SLIT("\", invalid character \""), 0xfe10, {.d_s = byte_ascii_str(ch)}}, {_SLIT("\""), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
		}
	}
	if ((env_lit).len == 0) {
		return (Option_string){ .state=2, .err=_v_error(_SLIT("supply an env variable name like HOME, PATH or USER")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	string env_value = _SLIT("");
	if (check_for_presence) {
		string* _t7 = (string*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, os__environ()), &(string[]){env_lit}));
		Option_string _t6 = {0};
		if (_t7) {
			*((string*)&_t6.data) = *((string*)_t7);
		} else {
			_t6.state = 2; _t6.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t6.state != 0) { /*or block*/ 
			IError err = _t6.err;
			return (Option_string){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("the environment variable \""), 0xfe10, {.d_s = env_lit}}, {_SLIT("\" does not exist."), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		
		env_value = *(string*)_t6.data;
		if ((env_value).len == 0) {
			return (Option_string){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("the environment variable \""), 0xfe10, {.d_s = env_lit}}, {_SLIT("\" is empty."), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	} else {
		env_value = os__getenv(env_lit);
	}
	string rep = string_replace_once(str, string__plus(string__plus(string__plus(env_ident, env_lit), _SLIT("'")), _SLIT(")")), env_value);
	if (string_contains(rep, env_ident)) {
		Option_string _t10 = v__util__resolve_env_value(rep, check_for_presence);
		return _t10;
	}
	Option_string _t11;
	opt_ok(&(string[]) { rep }, (Option*)(&_t11), sizeof(string));
	return _t11;
}

// Attr: [noreturn]
VNORETURN void v__util__launch_tool(bool is_verbose, string tool_name, Array_string args) {
	string vexe = v__pref__vexe_path();
	string vroot = os__dir(vexe);
	v__util__set_vroot_folder(vroot);
	string tool_args = v__util__args_quote_paths(args);
	string tools_folder = os__join_path(vroot, new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT("cmd"), _SLIT("tools")})));
	string tool_basename = os__real_path(os__join_path_single(tools_folder, tool_name));
	string tool_exe = _SLIT("");
	string tool_source = _SLIT("");
	if (os__is_dir(tool_basename)) {
		tool_exe = v__util__path_of_executable(os__join_path_single(tool_basename, os__file_name(tool_name)));
		tool_source = tool_basename;
	} else {
		tool_exe = v__util__path_of_executable(tool_basename);
		tool_source = string__plus(tool_basename, _SLIT(".v"));
	}
	if (is_verbose) {
		println( str_intp(2, _MOV((StrIntpData[]){{_SLIT("launch_tool vexe        : "), 0xfe10, {.d_s = vroot}}, {_SLIT0, 0, { .d_c = 0 }}})));
		println( str_intp(2, _MOV((StrIntpData[]){{_SLIT("launch_tool vroot       : "), 0xfe10, {.d_s = vroot}}, {_SLIT0, 0, { .d_c = 0 }}})));
		println( str_intp(2, _MOV((StrIntpData[]){{_SLIT("launch_tool tool_source : "), 0xfe10, {.d_s = tool_source}}, {_SLIT0, 0, { .d_c = 0 }}})));
		println( str_intp(2, _MOV((StrIntpData[]){{_SLIT("launch_tool tool_exe    : "), 0xfe10, {.d_s = tool_exe}}, {_SLIT0, 0, { .d_c = 0 }}})));
		println( str_intp(2, _MOV((StrIntpData[]){{_SLIT("launch_tool tool_args   : "), 0xfe10, {.d_s = tool_args}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
	string disabling_file = v__util__recompilation__disabling_file(vroot);
	bool is_recompilation_disabled = os__exists(disabling_file);
	bool should_compile = !is_recompilation_disabled && v__util__should_recompile_tool(vexe, tool_source, tool_name, tool_exe);
	if (is_verbose) {
		println( str_intp(2, _MOV((StrIntpData[]){{_SLIT("launch_tool should_compile: "), 0xfe10, {.d_s = should_compile ? _SLIT("true") : _SLIT("false")}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
	if (should_compile) {
		Array_string emodules = (*(Array_string*)map_get(ADDR(map, _const_v__util__external_module_dependencies_for_tool), &(string[]){tool_name}, &(Array_string[]){ __new_array(0, 0, sizeof(string)) }));
		for (int _t1 = 0; _t1 < emodules.len; ++_t1) {
			string emodule = ((string*)emodules.data)[_t1];
			Option_bool _t2 = v__util__check_module_is_installed(emodule, is_verbose);
			if (_t2.state != 0) { /*or block*/ 
				IError err = _t2.err;
				_v_panic(IError_str(err));
				VUNREACHABLE();
			;
			}
			
  (*(bool*)_t2.data);
		}
		string compilation_command =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\""), 0xfe10, {.d_s = vexe}}, {_SLIT("\" -skip-unused "), 0, { .d_c = 0 }}}));
		if (string__eq(tool_name, _SLIT("vself")) || string__eq(tool_name, _SLIT("vup")) || string__eq(tool_name, _SLIT("vdoctor")) || string__eq(tool_name, _SLIT("vsymlink"))) {
			compilation_command = /*f*/string__plus(compilation_command, _SLIT(" -g "));
		}
		compilation_command = /*f*/string__plus(compilation_command,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\""), 0xfe10, {.d_s = tool_source}}, {_SLIT("\""), 0, { .d_c = 0 }}})));
		if (is_verbose) {
			println( str_intp(3, _MOV((StrIntpData[]){{_SLIT("Compiling "), 0xfe10, {.d_s = tool_name}}, {_SLIT(" with: \""), 0xfe10, {.d_s = compilation_command}}, {_SLIT("\""), 0, { .d_c = 0 }}})));
		}
		os__Result tool_compilation = os__execute_or_exit(compilation_command);
		if (tool_compilation.exit_code != 0) {
			eprintln( str_intp(3, _MOV((StrIntpData[]){{_SLIT("cannot compile `"), 0xfe10, {.d_s = tool_source}}, {_SLIT("`: \n"), 0xfe10, {.d_s = tool_compilation.output}}, {_SLIT0, 0, { .d_c = 0 }}})));
			_v_exit(1);
			VUNREACHABLE();
		}
	}
	#if defined(_WIN32)
	{
		_v_exit(os__system( str_intp(3, _MOV((StrIntpData[]){{_SLIT("\""), 0xfe10, {.d_s = tool_exe}}, {_SLIT("\" "), 0xfe10, {.d_s = tool_args}}, {_SLIT0, 0, { .d_c = 0 }}}))));
		VUNREACHABLE();
	}
	#elif defined(_VJS)
	{
	}
	#else
	{
	}
	#endif
	_v_exit(2);
	VUNREACHABLE();
	while(1);
}

bool v__util__should_recompile_tool(string vexe, string tool_source, string tool_name, string tool_exe) {
	if (os__is_dir(tool_source)) {
		Array_string source_files = os__walk_ext(tool_source, _SLIT(".v"));
		string newest_sfile = _SLIT("");
		i64 newest_sfile_mtime = ((i64)(0));
		for (int _t1 = 0; _t1 < source_files.len; ++_t1) {
			string sfile = ((string*)source_files.data)[_t1];
			i64 mtime = os__file_last_mod_unix(sfile);
			if (mtime > newest_sfile_mtime) {
				newest_sfile_mtime = mtime;
				newest_sfile = sfile;
			}
		}
		bool single_file_recompile = v__util__should_recompile_tool(vexe, newest_sfile, tool_name, tool_exe);
		bool _t2 = single_file_recompile;
		return _t2;
	}
	bool should_compile = false;
	if (!os__exists(tool_exe)) {
		should_compile = true;
	} else {
		i64 mtime_vexe = os__file_last_mod_unix(vexe);
		i64 mtime_tool_exe = os__file_last_mod_unix(tool_exe);
		i64 mtime_tool_source = os__file_last_mod_unix(tool_source);
		if (mtime_tool_exe <= mtime_vexe) {
			should_compile = true;
			if (string__eq(tool_name, _SLIT("vself")) || string__eq(tool_name, _SLIT("vup"))) {
				should_compile = false;
			}
		}
		if (mtime_tool_exe <= mtime_tool_source) {
			should_compile = true;
		}
		if (mtime_vexe < 1024 && mtime_tool_exe < 1024) {
			should_compile = false;
		}
	}
	bool _t3 = should_compile;
	return _t3;
}

VV_LOCAL_SYMBOL multi_return_string_string v__util__tool_source2name_and_exe(string tool_source) {
	string sfolder = os__dir(tool_source);
	string tool_name = string_replace(os__base(tool_source), _SLIT(".v"), _SLIT(""));
	string tool_exe = os__join_path_single(sfolder, v__util__path_of_executable(tool_name));
	return (multi_return_string_string){.arg0=tool_name, .arg1=tool_exe};
}

string v__util__quote_path(string s) {
	string qs = s;
	if (string_contains(qs, _SLIT("&"))) {
		qs = string_replace(qs, _SLIT("&"), _SLIT("\\&"));
	}
	if (string_contains(qs, _SLIT(" "))) {
		string _t1 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\""), 0xfe10, {.d_s = qs}}, {_SLIT("\""), 0, { .d_c = 0 }}}));
		return _t1;
	}
	string _t2 = qs;
	return _t2;
}

string v__util__args_quote_paths(Array_string args) {
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t1 = 0; _t1 < args.len; ++_t1) {
		string a = ((string*)args.data)[_t1];
		array_push((array*)&res, _MOV((string[]){ string_clone(v__util__quote_path(a)) }));
	}
	string _t3 = Array_string_join(res, _SLIT(" "));
	return _t3;
}

string v__util__path_of_executable(string path) {
	string _t1 = string__plus(path, _SLIT(".exe"));
	return _t1;
	string _t2 = path;
	return _t2;
}

// Attr: [unsafe]
Option_string v__util__cached_read_source_file(string path) {
	static v__util__SourceCache* cache = ((v__util__SourceCache*)(0));
	if (isnil(cache)) {
		cache = (v__util__SourceCache*)memdup(&(v__util__SourceCache){.sources = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),}, sizeof(v__util__SourceCache));
	}
	if (path.len == 0) {
		map_free(&cache->sources);
		_v_free(cache);
		cache = ((v__util__SourceCache*)(0));
		return (Option_string){ .state=2, .err=_v_error(_SLIT("memory source file cache cleared")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	string* _t3 = (string*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, cache->sources), &(string[]){path}));
	Option_string _t2 = {0};
	if (_t3) {
		*((string*)&_t2.data) = *((string*)_t3);
	} else {
		_t2.state = 2; _t2.err = _v_error(_SLIT("array index out of range"));
	}
	
	if (_t2.state == 0) {
		string res = *(string*)_t2.data;
		Option_string _t4;
		opt_ok(&(string[]) { res }, (Option*)(&_t4), sizeof(string));
		return _t4;
	}
	Option_string _t5 = os__read_file(path);
	if (_t5.state != 0) { /*or block*/ 
		IError err = _t5.err;
		return (Option_string){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("failed to open "), 0xfe10, {.d_s = path}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	string raw_text =  (*(string*)_t5.data);
	string res = v__util__skip_bom(raw_text);
	map_set(&cache->sources, &(string[]){path}, &(string[]) { res });
	Option_string _t7;
	opt_ok(&(string[]) { res }, (Option*)(&_t7), sizeof(string));
	return _t7;
}

string v__util__replace_op(string s) {
	string _t1 = ((string__eq(s, _SLIT("+"))) ? (_SLIT("_plus")) : (string__eq(s, _SLIT("-"))) ? (_SLIT("_minus")) : (string__eq(s, _SLIT("*"))) ? (_SLIT("_mult")) : (string__eq(s, _SLIT("/"))) ? (_SLIT("_div")) : (string__eq(s, _SLIT("%"))) ? (_SLIT("_mod")) : (string__eq(s, _SLIT("<"))) ? (_SLIT("_lt")) : (string__eq(s, _SLIT(">"))) ? (_SLIT("_gt")) : (string__eq(s, _SLIT("=="))) ? (_SLIT("_eq")) : (_SLIT("")));
	return _t1;
}

Array_string v__util__join_env_vflags_and_os_args(void) {
	string vosargs = os__getenv(_SLIT("VOSARGS"));
	if ((vosargs).len != 0) {
		Array_string _t1 = v__util__non_empty(string_split(vosargs, _SLIT(" ")));
		return _t1;
	}
	Array_string args = __new_array_with_default(0, 0, sizeof(string), 0);
	string vflags = os__getenv(_SLIT("VFLAGS"));
	if ((vflags).len != 0) {
		array_push((array*)&args, _MOV((string[]){ string_clone((*(string*)/*ee elem_typ */array_get(_const_os__args, 0))) }));
		_PUSH_MANY(&args, (string_split(vflags, _SLIT(" "))), _t3, Array_string);
		if (_const_os__args.len > 1) {
			_PUSH_MANY(&args, (array_slice(_const_os__args, 1, _const_os__args.len)), _t4, Array_string);
		}
		Array_string _t5 = v__util__non_empty(args);
		return _t5;
	}
	Array_string _t6 = _const_os__args;
	return _t6;
}

VV_LOCAL_SYMBOL Array_string v__util__non_empty(Array_string arg) {
	Array_string _t2 = __new_array(0, 0, sizeof(string));
	Array_string _t2_orig = arg;
	int _t2_len = _t2_orig.len;
	_t2 = __new_array(0, _t2_len, sizeof(string));

	for (int _t3 = 0; _t3 < _t2_len; ++_t3) {
		string it = ((string*) _t2_orig.data)[_t3];
		if ((it).len != 0) {
			array_push((array*)&_t2, &it);
		}
	}
	Array_string _t1 =_t2;
	return _t1;
}

Option_bool v__util__check_module_is_installed(string modulename, bool is_verbose) {
	string mpath = os__join_path_single(os__vmodules_dir(), modulename);
	string mod_v_file = os__join_path_single(mpath, _SLIT("v.mod"));
	string murl =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("https://github.com/vlang/"), 0xfe10, {.d_s = modulename}}, {_SLIT0, 0, { .d_c = 0 }}}));
	if (is_verbose) {
		eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("check_module_is_installed: mpath: "), 0xfe10, {.d_s = mpath}}, {_SLIT0, 0, { .d_c = 0 }}})));
		eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("check_module_is_installed: mod_v_file: "), 0xfe10, {.d_s = mod_v_file}}, {_SLIT0, 0, { .d_c = 0 }}})));
		eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("check_module_is_installed: murl: "), 0xfe10, {.d_s = murl}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
	if (os__exists(mod_v_file)) {
		string vexe = v__pref__vexe_path();
		string update_cmd =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\""), 0xfe10, {.d_s = vexe}}, {_SLIT("\" update \""), 0xfe10, {.d_s = modulename}}, {_SLIT("\""), 0, { .d_c = 0 }}}));
		if (is_verbose) {
			eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("check_module_is_installed: updating with "), 0xfe10, {.d_s = update_cmd}}, {_SLIT(" ..."), 0, { .d_c = 0 }}})));
		}
		os__Result update_res = os__execute(update_cmd);
		if (update_res.exit_code < 0) {
			return (Option_bool){ .state=2, .err=_v_error( str_intp(3, _MOV((StrIntpData[]){{_SLIT("can not start "), 0xfe10, {.d_s = update_cmd}}, {_SLIT(", error: "), 0xfe10, {.d_s = update_res.output}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		if (update_res.exit_code != 0) {
			eprintln( str_intp(3, _MOV((StrIntpData[]){{_SLIT("Warning: `"), 0xfe10, {.d_s = modulename}}, {_SLIT("` exists, but is not updated.\nV will continue, since updates can fail due to temporary network problems,\nand the existing module `"), 0xfe10, {.d_s = modulename}}, {_SLIT("` may still work."), 0, { .d_c = 0 }}})));
			if (is_verbose) {
				eprintln(_SLIT("Details:"));
				eprintln(update_res.output);
			}
			eprintln(string_repeat(_SLIT("-"), 50));
		}
		Option_bool _t2;
		opt_ok(&(bool[]) { true }, (Option*)(&_t2), sizeof(bool));
		return _t2;
	}
	if (is_verbose) {
		eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("check_module_is_installed: cloning from "), 0xfe10, {.d_s = murl}}, {_SLIT(" ..."), 0, { .d_c = 0 }}})));
	}
	os__Result cloning_res = os__execute( str_intp(3, _MOV((StrIntpData[]){{_SLIT("git clone "), 0xfe10, {.d_s = murl}}, {_SLIT(" "), 0xfe10, {.d_s = mpath}}, {_SLIT0, 0, { .d_c = 0 }}})));
	if (cloning_res.exit_code < 0) {
		return (Option_bool){ .state=2, .err=error_with_code( str_intp(2, _MOV((StrIntpData[]){{_SLIT("git is not installed, error: "), 0xfe10, {.d_s = cloning_res.output}}, {_SLIT0, 0, { .d_c = 0 }}})), cloning_res.exit_code), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (cloning_res.exit_code != 0) {
		return (Option_bool){ .state=2, .err=error_with_code( str_intp(2, _MOV((StrIntpData[]){{_SLIT("cloning failed, details: "), 0xfe10, {.d_s = cloning_res.output}}, {_SLIT0, 0, { .d_c = 0 }}})), cloning_res.exit_code), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (!os__exists(mod_v_file)) {
		return (Option_bool){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("even after cloning, "), 0xfe10, {.d_s = mod_v_file}}, {_SLIT(" is still missing"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (is_verbose) {
		eprintln(_SLIT("check_module_is_installed: done"));
	}
	Option_bool _t6;
	opt_ok(&(bool[]) { true }, (Option*)(&_t6), sizeof(bool));
	return _t6;
}

void v__util__ensure_modules_for_all_tools_are_installed(bool is_verbose) {
	int _t2 = _const_v__util__external_module_dependencies_for_tool.key_values.len;
	for (int _t1 = 0; _t1 < _t2; ++_t1 ) {
		int _t3 = _const_v__util__external_module_dependencies_for_tool.key_values.len - _t2;
		_t2 = _const_v__util__external_module_dependencies_for_tool.key_values.len;
		if (_t3 < 0) {
			_t1 = -1;
			continue;
		}
		if (!DenseArray_has_index(&_const_v__util__external_module_dependencies_for_tool.key_values, _t1)) {continue;}
		string tool_name = /*key*/ *(string*)DenseArray_key(&_const_v__util__external_module_dependencies_for_tool.key_values, _t1);
		tool_name = string_clone(tool_name);
		Array_string tool_modules = (*(Array_string*)DenseArray_value(&_const_v__util__external_module_dependencies_for_tool.key_values, _t1));
		if (is_verbose) {
			eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Installing modules for tool: "), 0xfe10, {.d_s = tool_name}}, {_SLIT(" ..."), 0, { .d_c = 0 }}})));
		}
		for (int _t4 = 0; _t4 < tool_modules.len; ++_t4) {
			string emodule = ((string*)tool_modules.data)[_t4];
			Option_bool _t5 = v__util__check_module_is_installed(emodule, is_verbose);
			if (_t5.state != 0) { /*or block*/ 
				IError err = _t5.err;
				_v_panic(IError_str(err));
				VUNREACHABLE();
			;
			}
			
  (*(bool*)_t5.data);
		}
	}
}

string v__util__strip_mod_name(string name) {
	string _t1 = string_all_after_last(name, _SLIT("."));
	return _t1;
}

string v__util__strip_main_name(string name) {
	string _t1 = string_replace(name, _SLIT("main."), _SLIT(""));
	return _t1;
}

string v__util__no_dots(string s) {
	string _t1 = string_replace(s, _SLIT("."), _SLIT("__"));
	return _t1;
}

string v__util__no_cur_mod(string _v_typename, string cur_mod) {
	string res = _v_typename;
	string mod_prefix = string__plus(cur_mod, _SLIT("."));
	bool has_map_prefix = string_starts_with(res, _const_v__util__map_prefix);
	if (has_map_prefix) {
		res = string_replace_once(res, _const_v__util__map_prefix, _SLIT(""));
	}
	string no_symbols = string_trim_left(res, _SLIT("&[]"));
	bool should_shorten = string_starts_with(no_symbols, mod_prefix);
	if (should_shorten) {
		res = string_replace_once(res, mod_prefix, _SLIT(""));
	}
	if (has_map_prefix) {
		res = string__plus(_const_v__util__map_prefix, res);
	}
	string _t1 = res;
	return _t1;
}

void v__util__prepare_tool_when_needed(string source_name) {
	string vexe = os__getenv(_SLIT("VEXE"));
	string vroot = os__dir(vexe);
	string stool = os__join_path(vroot, new_array_from_c_array(3, 3, sizeof(string), _MOV((string[3]){_SLIT("cmd"), _SLIT("tools"), source_name})));
	multi_return_string_string mr_14102 = v__util__tool_source2name_and_exe(stool);
	string tool_name = mr_14102.arg0;
	string tool_exe = mr_14102.arg1;
	if (v__util__should_recompile_tool(vexe, stool, tool_name, tool_exe)) {
		time__sleep(1001 * _const_time__millisecond);
		v__util__recompile_file(vexe, stool);
	}
}

void v__util__recompile_file(string vexe, string file) {
	string cmd =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = vexe}}, {_SLIT(" "), 0xfe10, {.d_s = file}}, {_SLIT0, 0, { .d_c = 0 }}}));
	int recompile_result = os__system(cmd);
	if (recompile_result != 0) {
		eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("could not recompile "), 0xfe10, {.d_s = file}}, {_SLIT0, 0, { .d_c = 0 }}})));
		_v_exit(2);
		VUNREACHABLE();
	}
}

string v__util__get_vtmp_folder(void) {
	string vtmp = os__getenv(_SLIT("VTMP"));
	if (vtmp.len > 0) {
		string _t1 = vtmp;
		return _t1;
	}
	int uid = os__getuid();
	vtmp = os__join_path_single(os__temp_dir(),  str_intp(2, _MOV((StrIntpData[]){{_SLIT("v_"), 0xfe07, {.d_i32 = uid}}, {_SLIT0, 0, { .d_c = 0 }}})));
	if (!os__exists(vtmp) || !os__is_dir(vtmp)) {
		Option_void _t2 = os__mkdir_all(vtmp);
		if (_t2.state != 0 && _t2.err._typ != _IError_None___index) {
			IError err = _t2.err;
			_v_panic(IError_str(err));
			VUNREACHABLE();
		;
		}
		
 ;
	}
	os__setenv(_SLIT("VTMP"), vtmp, true);
	string _t3 = vtmp;
	return _t3;
}

bool v__util__should_bundle_module(string mod) {
	bool _t1 = Array_string_contains(_const_v__util__bundle_modules, mod) || (string_contains(mod, _SLIT(".")) && Array_string_contains(_const_v__util__bundle_modules, string_all_before(mod, _SLIT("."))));
	return _t1;
}

Option_Array_string v__util__find_all_v_files(Array_string roots) {
	Array_string files = __new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t1 = 0; _t1 < roots.len; ++_t1) {
		string file = ((string*)roots.data)[_t1];
		if (os__is_dir(file)) {
			_PUSH_MANY(&files, (os__walk_ext(file, _SLIT(".v"))), _t2, Array_string);
			_PUSH_MANY(&files, (os__walk_ext(file, _SLIT(".vsh"))), _t3, Array_string);
			continue;
		}
		if (!string_ends_with(file, _SLIT(".v")) && !string_ends_with(file, _SLIT(".vv")) && !string_ends_with(file, _SLIT(".vsh"))) {
			return (Option_Array_string){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("v fmt can only be used on .v files.\nOffending file: \""), 0xfe10, {.d_s = file}}, {_SLIT("\""), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		if (!os__exists(file)) {
			return (Option_Array_string){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("\""), 0xfe10, {.d_s = file}}, {_SLIT("\" does not exist"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		array_push((array*)&files, _MOV((string[]){ string_clone(file) }));
	}
	Option_Array_string _t7;
	opt_ok(&(Array_string[]) { files }, (Option*)(&_t7), sizeof(Array_string));
	return _t7;
}

void v__util__free_caches(void) {
	{ // Unsafe block
		v__util__cached_file2sourcelines(_SLIT(""));
		Option_string _t1 = v__util__cached_read_source_file(_SLIT(""));
		if (_t1.state != 0) { /*or block*/ 
			IError err = _t1.err;
			*(string*) _t1.data = _SLIT("");
		}
		
  (*(string*)_t1.data);
	}
}

Option_string v__util__read_file(string file_path) {
	Option_string _t1 = v__util__cached_read_source_file(file_path);
	return _t1;
}

// Attr: [trusted]
// TypeDecl
sync__pool__PoolProcessor* sync__pool__new_pool_processor(sync__pool__PoolProcessorConfig context) {
	if (isnil(context.callback)) {
		_v_panic(_SLIT("You need to pass a valid callback to new_pool_processor."));
		VUNREACHABLE();
	}
	sync__pool__PoolProcessor *pool = HEAP(sync__pool__PoolProcessor, ((sync__pool__PoolProcessor){
		.thread_cb = ((voidptr)(context.callback)),
		.njobs = context.maxjobs,
		.items = __new_array_with_default(0, 0, sizeof(voidptr), 0),
		.results = __new_array_with_default(0, 0, sizeof(voidptr), 0),
		.ntask = 0U,
		.waitgroup = (sync__WaitGroup){.task_count = 0,.wait_count = 0,.sem = (sync__Semaphore){.count = 0,},},
		.shared_context = ((voidptr)(0)),
		.thread_contexts = __new_array_with_default(0, 0, sizeof(voidptr), 0),
	}));
	sync__WaitGroup_init(&(*(pool)).waitgroup);
	sync__pool__PoolProcessor* _t1 = &(*(pool));
	return _t1;
}

void sync__pool__PoolProcessor_set_max_jobs(sync__pool__PoolProcessor* pool, int njobs) {
	pool->njobs = njobs;
}

void sync__pool__PoolProcessor_work_on_items_T___ptr__v__ast__File(sync__pool__PoolProcessor* pool, Array_v__ast__File_ptr items) {
	sync__pool__PoolProcessor_work_on_pointers(pool, array_pointers(items));
}

void sync__pool__PoolProcessor_work_on_pointers(sync__pool__PoolProcessor* pool, Array_voidptr items) {
	int njobs = runtime__nr_jobs();
	if (pool->njobs > 0) {
		njobs = pool->njobs;
	}
	pool->thread_contexts = __new_array_with_default(items.len, 0, sizeof(voidptr), 0);
	pool->results = __new_array_with_default(items.len, 0, sizeof(voidptr), 0);
	pool->items = __new_array_with_default(0, items.len, sizeof(voidptr), 0);
	_PUSH_MANY(&pool->items, (items), _t1, Array_voidptr);
	sync__WaitGroup_add(&pool->waitgroup, njobs);
	for (int i = 0; i < njobs; i++) {
		if (njobs > 1) {
			// go
			thread_arg_sync__pool__process_in_thread *arg__t2 = malloc(sizeof(thread_arg_sync__pool__process_in_thread));
			arg__t2->arg1 = pool;
			arg__t2->arg2 = i;
			HANDLE thread__t2 = CreateThread(0,0, (LPTHREAD_START_ROUTINE)sync__pool__process_in_thread_thread_wrapper, arg__t2, 0,0);
			if (!thread__t2) panic_lasterr(tos3("`go sync__pool__process_in_thread()`: "));
			CloseHandle(thread__t2);
			// endgo

			;
		} else {
			sync__pool__process_in_thread(pool, i);
		}
	}
	sync__WaitGroup_wait(&pool->waitgroup);
}

VV_LOCAL_SYMBOL void sync__pool__process_in_thread(sync__pool__PoolProcessor* pool, int task_id) {
	voidptr (*cb) (sync__pool__PoolProcessor* p, int idx, int task_id) = ((sync__pool__ThreadCB)(pool->thread_cb));
	int ilen = pool->items.len;
	for (;;) {
		int idx = ((int)(atomic_fetch_add_u32(&pool->ntask, 1U)));
		if (idx >= ilen) {
			break;
		}
		(*(voidptr*)/*ee elem_typ */array_get(pool->results, idx)) = cb(pool, idx, task_id);
	}
	sync__WaitGroup_done(&pool->waitgroup);
}

v__ast__File* sync__pool__PoolProcessor_get_item_T___ptr__v__ast__File(sync__pool__PoolProcessor* pool, int idx) {
	v__ast__File* _t1 = *(((v__ast__File**)((*(voidptr*)/*ee elem_typ */array_get(pool->items, idx)))));
	return _t1;
}

Array_v__gen__c__Gen_ptr sync__pool__PoolProcessor_get_results_ref_T_v__gen__c__Gen(sync__pool__PoolProcessor* pool) {
	Array_v__gen__c__Gen_ptr res = __new_array_with_default(0, pool->results.len, sizeof(v__gen__c__Gen*), 0);
	for (int i = 0; i < pool->results.len; ++i) {
		array_push((array*)&res, _MOV((v__gen__c__Gen*[]){ ((v__gen__c__Gen*)((*(voidptr*)/*ee elem_typ */array_get(pool->results, i)))) }));
	}
	Array_v__gen__c__Gen_ptr _t2 = res;
	return _t2;
}

void sync__pool__PoolProcessor_set_shared_context(sync__pool__PoolProcessor* pool, voidptr context) {
	pool->shared_context = context;
}

voidptr sync__pool__PoolProcessor_get_shared_context(sync__pool__PoolProcessor* pool) {
	voidptr _t1 = pool->shared_context;
	return _t1;
}

void sync__pool__PoolProcessor_set_thread_context(sync__pool__PoolProcessor* pool, int idx, voidptr context) {
	(*(voidptr*)/*ee elem_typ */array_get(pool->thread_contexts, idx)) = context;
}

voidptr sync__pool__PoolProcessor_get_thread_context(sync__pool__PoolProcessor* pool, int idx) {
	voidptr _t1 = (*(voidptr*)/*ee elem_typ */array_get(pool->thread_contexts, idx));
	return _t1;
}

// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
v__ast__Expr v__ast__empty_expr(void) {
	v__ast__Expr _t1 = v__ast__EmptyExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__EmptyExpr, ((v__ast__EmptyExpr){.x = 0,})));
	return _t1;
}

v__ast__Stmt v__ast__empty_stmt(void) {
	v__ast__Stmt _t1 = v__ast__EmptyStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__EmptyStmt, ((v__ast__EmptyStmt){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},})));
	return _t1;
}

v__ast__Node v__ast__empty_node(void) {
	v__ast__Node _t1 = v__ast__EmptyNode_to_sumtype_v__ast__Node(ADDR(v__ast__EmptyNode, ((v__ast__EmptyNode){.x = 0,})));
	return _t1;
}

Option_v__ast__Ident v__ast__SelectorExpr_root_ident(v__ast__SelectorExpr* e) {
	v__ast__Expr root = e->expr;
	for (;;) {
		if (!((root)._typ == 319 /* v.ast.SelectorExpr */)) break;
		root = (*root._v__ast__SelectorExpr).expr;
	}
	if ((root)._typ == 299 /* v.ast.Ident */) {
		Option_v__ast__Ident _t1;
		opt_ok(&(v__ast__Ident[]) { /* as */ *(v__ast__Ident*)__as_cast((root)._v__ast__Ident,(root)._typ, 299) /*expected idx: 299, name: v.ast.Ident */  }, (Option*)(&_t1), sizeof(v__ast__Ident));
		return _t1;
	}
	return (Option_v__ast__Ident){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
}

// Attr: [unsafe]
void v__ast__File_free(v__ast__File* f) {
	{ // Unsafe block
		string_free(&f->path);
		string_free(&f->path_base);
		v__ast__Scope_free(f->scope);
		array_free(&f->stmts);
		array_free(&f->imports);
		array_free(&f->auto_imports);
		array_free(&f->embedded_files);
		map_free(&f->imported_symbols);
		array_free(&f->errors);
		array_free(&f->warnings);
		array_free(&f->notices);
		array_free(&f->global_labels);
	}
}

// TypeDecl
v__ast__IdentVar v__ast__Ident_var_info(v__ast__Ident* i) {
	if (i->info._typ == 408 /* v.ast.IdentVar */) {
		v__ast__IdentVar _t1 = (*i->info._v__ast__IdentVar);
		return _t1;
	}
	
	else {
		_v_panic(_SLIT("Ident.var_info(): info is not IdentVar variant"));
		VUNREACHABLE();
	}
	;
	return (v__ast__IdentVar){.typ = 0,.is_mut = 0,.is_static = 0,.is_volatile = 0,.is_optional = 0,};
}

// TypeDecl
// Attr: [inline]
inline bool v__ast__Expr_is_blank_ident(v__ast__Expr expr) {
	if (expr._typ == 299 /* v.ast.Ident */) {
		bool _t1 = (*expr._v__ast__Ident).kind == v__ast__IdentKind__blank_ident;
		return _t1;
	}
	
	else {
		bool _t2 = false;
		return _t2;
	}
	;
	return 0;
}

v__token__Position v__ast__Expr_position(v__ast__Expr expr) {
	if (expr._typ == 278 /* v.ast.AnonFn */) {
		v__token__Position _t1 = (*expr._v__ast__AnonFn).decl.pos;
		return _t1;
	}
	else if (expr._typ == 285 /* v.ast.CTempVar */) {
		v__token__Position _t2 = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,};
		return _t2;
	}
	else if (expr._typ == 295 /* v.ast.EmptyExpr */) {
		v__token__Position _t3 = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,};
		return _t3;
	}
	else if (expr._typ == 310 /* v.ast.NodeError */) {
		v__token__Position _t4 = (*expr._v__ast__NodeError).pos;
		return _t4;
	}
	else if (expr._typ == 279 /* v.ast.ArrayDecompose */) {
		v__token__Position _t5 = (*expr._v__ast__ArrayDecompose).pos;
		return _t5;
	}
	else if (expr._typ == 280 /* v.ast.ArrayInit */) {
		v__token__Position _t6 = (*expr._v__ast__ArrayInit).pos;
		return _t6;
	}
	else if (expr._typ == 281 /* v.ast.AsCast */) {
		v__token__Position _t7 = (*expr._v__ast__AsCast).pos;
		return _t7;
	}
	else if (expr._typ == 282 /* v.ast.Assoc */) {
		v__token__Position _t8 = (*expr._v__ast__Assoc).pos;
		return _t8;
	}
	else if (expr._typ == 283 /* v.ast.AtExpr */) {
		v__token__Position _t9 = (*expr._v__ast__AtExpr).pos;
		return _t9;
	}
	else if (expr._typ == 284 /* v.ast.BoolLiteral */) {
		v__token__Position _t10 = (*expr._v__ast__BoolLiteral).pos;
		return _t10;
	}
	else if (expr._typ == 286 /* v.ast.CallExpr */) {
		v__token__Position _t11 = (*expr._v__ast__CallExpr).pos;
		return _t11;
	}
	else if (expr._typ == 287 /* v.ast.CastExpr */) {
		v__token__Position _t12 = (*expr._v__ast__CastExpr).pos;
		return _t12;
	}
	else if (expr._typ == 288 /* v.ast.ChanInit */) {
		v__token__Position _t13 = (*expr._v__ast__ChanInit).pos;
		return _t13;
	}
	else if (expr._typ == 289 /* v.ast.CharLiteral */) {
		v__token__Position _t14 = (*expr._v__ast__CharLiteral).pos;
		return _t14;
	}
	else if (expr._typ == 293 /* v.ast.ConcatExpr */) {
		v__token__Position _t15 = (*expr._v__ast__ConcatExpr).pos;
		return _t15;
	}
	else if (expr._typ == 290 /* v.ast.Comment */) {
		v__token__Position _t16 = (*expr._v__ast__Comment).pos;
		return _t16;
	}
	else if (expr._typ == 291 /* v.ast.ComptimeCall */) {
		v__token__Position _t17 = (*expr._v__ast__ComptimeCall).pos;
		return _t17;
	}
	else if (expr._typ == 292 /* v.ast.ComptimeSelector */) {
		v__token__Position _t18 = (*expr._v__ast__ComptimeSelector).pos;
		return _t18;
	}
	else if (expr._typ == 296 /* v.ast.EnumVal */) {
		v__token__Position _t19 = (*expr._v__ast__EnumVal).pos;
		return _t19;
	}
	else if (expr._typ == 294 /* v.ast.DumpExpr */) {
		v__token__Position _t20 = (*expr._v__ast__DumpExpr).pos;
		return _t20;
	}
	else if (expr._typ == 297 /* v.ast.FloatLiteral */) {
		v__token__Position _t21 = (*expr._v__ast__FloatLiteral).pos;
		return _t21;
	}
	else if (expr._typ == 298 /* v.ast.GoExpr */) {
		v__token__Position _t22 = (*expr._v__ast__GoExpr).pos;
		return _t22;
	}
	else if (expr._typ == 299 /* v.ast.Ident */) {
		v__token__Position _t23 = (*expr._v__ast__Ident).pos;
		return _t23;
	}
	else if (expr._typ == 300 /* v.ast.IfExpr */) {
		v__token__Position _t24 = (*expr._v__ast__IfExpr).pos;
		return _t24;
	}
	else if (expr._typ == 304 /* v.ast.IntegerLiteral */) {
		v__token__Position _t25 = (*expr._v__ast__IntegerLiteral).pos;
		return _t25;
	}
	else if (expr._typ == 305 /* v.ast.IsRefType */) {
		v__token__Position _t26 = (*expr._v__ast__IsRefType).pos;
		return _t26;
	}
	else if (expr._typ == 306 /* v.ast.Likely */) {
		v__token__Position _t27 = (*expr._v__ast__Likely).pos;
		return _t27;
	}
	else if (expr._typ == 307 /* v.ast.LockExpr */) {
		v__token__Position _t28 = (*expr._v__ast__LockExpr).pos;
		return _t28;
	}
	else if (expr._typ == 308 /* v.ast.MapInit */) {
		v__token__Position _t29 = (*expr._v__ast__MapInit).pos;
		return _t29;
	}
	else if (expr._typ == 309 /* v.ast.MatchExpr */) {
		v__token__Position _t30 = (*expr._v__ast__MatchExpr).pos;
		return _t30;
	}
	else if (expr._typ == 311 /* v.ast.None */) {
		v__token__Position _t31 = (*expr._v__ast__None).pos;
		return _t31;
	}
	else if (expr._typ == 312 /* v.ast.OffsetOf */) {
		v__token__Position _t32 = (*expr._v__ast__OffsetOf).pos;
		return _t32;
	}
	else if (expr._typ == 313 /* v.ast.OrExpr */) {
		v__token__Position _t33 = (*expr._v__ast__OrExpr).pos;
		return _t33;
	}
	else if (expr._typ == 314 /* v.ast.ParExpr */) {
		v__token__Position _t34 = (*expr._v__ast__ParExpr).pos;
		return _t34;
	}
	else if (expr._typ == 315 /* v.ast.PostfixExpr */) {
		v__token__Position _t35 = (*expr._v__ast__PostfixExpr).pos;
		return _t35;
	}
	else if (expr._typ == 316 /* v.ast.PrefixExpr */) {
		v__token__Position _t36 = (*expr._v__ast__PrefixExpr).pos;
		return _t36;
	}
	else if (expr._typ == 317 /* v.ast.RangeExpr */) {
		v__token__Position _t37 = (*expr._v__ast__RangeExpr).pos;
		return _t37;
	}
	else if (expr._typ == 318 /* v.ast.SelectExpr */) {
		v__token__Position _t38 = (*expr._v__ast__SelectExpr).pos;
		return _t38;
	}
	else if (expr._typ == 319 /* v.ast.SelectorExpr */) {
		v__token__Position _t39 = (*expr._v__ast__SelectorExpr).pos;
		return _t39;
	}
	else if (expr._typ == 320 /* v.ast.SizeOf */) {
		v__token__Position _t40 = (*expr._v__ast__SizeOf).pos;
		return _t40;
	}
	else if (expr._typ == 321 /* v.ast.SqlExpr */) {
		v__token__Position _t41 = (*expr._v__ast__SqlExpr).pos;
		return _t41;
	}
	else if (expr._typ == 322 /* v.ast.StringInterLiteral */) {
		v__token__Position _t42 = (*expr._v__ast__StringInterLiteral).pos;
		return _t42;
	}
	else if (expr._typ == 323 /* v.ast.StringLiteral */) {
		v__token__Position _t43 = (*expr._v__ast__StringLiteral).pos;
		return _t43;
	}
	else if (expr._typ == 324 /* v.ast.StructInit */) {
		v__token__Position _t44 = (*expr._v__ast__StructInit).pos;
		return _t44;
	}
	else if (expr._typ == 325 /* v.ast.TypeNode */) {
		v__token__Position _t45 = (*expr._v__ast__TypeNode).pos;
		return _t45;
	}
	else if (expr._typ == 326 /* v.ast.TypeOf */) {
		v__token__Position _t46 = (*expr._v__ast__TypeOf).pos;
		return _t46;
	}
	else if (expr._typ == 327 /* v.ast.UnsafeExpr */) {
		v__token__Position _t47 = (*expr._v__ast__UnsafeExpr).pos;
		return _t47;
	}
	else if (expr._typ == 302 /* v.ast.IndexExpr */) {
		if ((*expr._v__ast__IndexExpr).or_expr.kind != v__ast__OrKind__absent) {
			v__token__Position _t48 = (*expr._v__ast__IndexExpr).or_expr.pos;
			return _t48;
		}
		v__token__Position _t49 = (*expr._v__ast__IndexExpr).pos;
		return _t49;
	}
	else if (expr._typ == 301 /* v.ast.IfGuardExpr */) {
		v__token__Position _t50 = v__ast__Expr_position((*expr._v__ast__IfGuardExpr).expr);
		return _t50;
	}
	else if (expr._typ == 303 /* v.ast.InfixExpr */) {
		v__token__Position left_pos = v__ast__Expr_position((*expr._v__ast__InfixExpr).left);
		v__token__Position right_pos = v__ast__Expr_position((*expr._v__ast__InfixExpr).right);
		v__token__Position _t51 = (v__token__Position){.len = right_pos.pos - left_pos.pos + right_pos.len,.line_nr = (*expr._v__ast__InfixExpr).pos.line_nr,.pos = left_pos.pos,.col = left_pos.col,.last_line = right_pos.last_line,};
		return _t51;
	}
	;
	return (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,};
}

bool v__ast__Expr_is_lvalue(v__ast__Expr expr) {
	if (expr._typ == 299 /* v.ast.Ident */) {
		bool _t1 = true;
		return _t1;
	}
	else if (expr._typ == 285 /* v.ast.CTempVar */) {
		bool _t2 = true;
		return _t2;
	}
	else if (expr._typ == 302 /* v.ast.IndexExpr */) {
		bool _t3 = v__ast__Expr_is_lvalue((*expr._v__ast__IndexExpr).left);
		return _t3;
	}
	else if (expr._typ == 319 /* v.ast.SelectorExpr */) {
		bool _t4 = v__ast__Expr_is_lvalue((*expr._v__ast__SelectorExpr).expr);
		return _t4;
	}
	else if (expr._typ == 314 /* v.ast.ParExpr */) {
		bool _t5 = v__ast__Expr_is_lvalue((*expr._v__ast__ParExpr).expr);
		return _t5;
	}
	else if (expr._typ == 316 /* v.ast.PrefixExpr */) {
		bool _t6 = v__ast__Expr_is_lvalue((*expr._v__ast__PrefixExpr).right);
		return _t6;
	}
	
	else {
	}
	;
	bool _t7 = false;
	return _t7;
}

bool v__ast__Expr_is_expr(v__ast__Expr expr) {
	if (expr._typ == 300 /* v.ast.IfExpr */) {
		bool _t1 = (*expr._v__ast__IfExpr).is_expr;
		return _t1;
	}
	else if (expr._typ == 307 /* v.ast.LockExpr */) {
		bool _t2 = (*expr._v__ast__LockExpr).is_expr;
		return _t2;
	}
	else if (expr._typ == 309 /* v.ast.MatchExpr */) {
		bool _t3 = (*expr._v__ast__MatchExpr).is_expr;
		return _t3;
	}
	else if (expr._typ == 318 /* v.ast.SelectExpr */) {
		bool _t4 = (*expr._v__ast__SelectExpr).is_expr;
		return _t4;
	}
	
	else {
	}
	;
	bool _t5 = true;
	return _t5;
}

bool v__ast__Expr_is_lit(v__ast__Expr expr) {
	bool _t1 = ((expr._typ == 284 /* v.ast.BoolLiteral */) ? (true) : (expr._typ == 289 /* v.ast.CharLiteral */) ? (true) : (expr._typ == 323 /* v.ast.StringLiteral */) ? (true) : (expr._typ == 304 /* v.ast.IntegerLiteral */) ? (true) : (false));
	return _t1;
}

bool v__ast__Expr_is_auto_deref_var(v__ast__Expr expr) {
	if (expr._typ == 299 /* v.ast.Ident */) {
		if (((*expr._v__ast__Ident).obj)._typ == 357 /* v.ast.Var */) {
			if ((*(*expr._v__ast__Ident).obj._v__ast__Var).is_auto_deref) {
				bool _t1 = true;
				return _t1;
			}
		}
	}
	else if (expr._typ == 316 /* v.ast.PrefixExpr */) {
		if ((*expr._v__ast__PrefixExpr).op == v__token__Kind__amp && v__ast__Expr_is_auto_deref_var((*expr._v__ast__PrefixExpr).right)) {
			bool _t2 = true;
			return _t2;
		}
	}
	
	else {
	}
	;
	bool _t3 = false;
	return _t3;
}

bool v__ast__Expr_is_lockable(v__ast__Expr* e) {
	if (e->_typ == 299 /* v.ast.Ident */) {
		bool _t1 = true;
		return _t1;
	}
	else if (e->_typ == 319 /* v.ast.SelectorExpr */) {
		bool _t2 = v__ast__Expr_is_lockable(&(*e->_v__ast__SelectorExpr).expr);
		return _t2;
	}
	
	else {
		bool _t3 = false;
		return _t3;
	}
	;
	return 0;
}

Option_void v__ast__Stmt_check_c_expr(v__ast__Stmt stmt) {
	if (stmt._typ == 331 /* v.ast.AssignStmt */) {
		return (Option_void){0};
	}
	else if (stmt._typ == 339 /* v.ast.ExprStmt */) {
		if (v__ast__Expr_is_expr((*stmt._v__ast__ExprStmt).expr)) {
			return (Option_void){0};
		}
		return (Option_void){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("unsupported statement (`"), 0xfe10, {.d_s = charptr_vstring_literal( /* v.ast.Expr */ v_typeof_sumtype_v__ast__Expr( ((*stmt._v__ast__ExprStmt).expr)._typ ))}}, {_SLIT("`)"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
	else {
	}
	;
	return (Option_void){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("unsupported statement (`"), 0xfe10, {.d_s = charptr_vstring_literal( /* v.ast.Stmt */ v_typeof_sumtype_v__ast__Stmt( (stmt)._typ ))}}, {_SLIT("`)"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
}

v__token__Position v__ast__Node_position(v__ast__Node node) {
	if (node._typ == 310 /* v.ast.NodeError */) {
		v__token__Position _t1 = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,};
		return _t1;
	}
	else if (node._typ == 360 /* v.ast.EmptyNode */) {
		v__token__Position _t2 = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,};
		return _t2;
	}
	else if (node._typ == 353 /* v.ast.Stmt */) {
		v__token__Position pos = (*((*node._v__ast__Stmt).pos));
		if (((*node._v__ast__Stmt))._typ == 347 /* v.ast.Import */) {
			for (int _t3 = 0; _t3 < (*(*node._v__ast__Stmt)._v__ast__Import).syms.len; ++_t3) {
				v__ast__ImportSymbol sym = ((v__ast__ImportSymbol*)(*(*node._v__ast__Stmt)._v__ast__Import).syms.data)[_t3];
				pos = v__token__Position_extend(pos, sym.pos);
			}
		} else if (((*node._v__ast__Stmt))._typ == 277 /* v.ast.TypeDecl */) {
			if ((*(*node._v__ast__Stmt)._v__ast__TypeDecl)._typ == 275 /* v.ast.FnTypeDecl */) {
				pos = v__token__Position_extend(pos, (*(*(*node._v__ast__Stmt)._v__ast__TypeDecl)._v__ast__FnTypeDecl).type_pos);
			}
			else if ((*(*node._v__ast__Stmt)._v__ast__TypeDecl)._typ == 274 /* v.ast.AliasTypeDecl */) {
				pos = v__token__Position_extend(pos, (*(*(*node._v__ast__Stmt)._v__ast__TypeDecl)._v__ast__AliasTypeDecl).type_pos);
			}
			else if ((*(*node._v__ast__Stmt)._v__ast__TypeDecl)._typ == 276 /* v.ast.SumTypeDecl */) {
				for (int _t4 = 0; _t4 < (*(*(*node._v__ast__Stmt)._v__ast__TypeDecl)._v__ast__SumTypeDecl).variants.len; ++_t4) {
					v__ast__TypeNode variant = ((v__ast__TypeNode*)(*(*(*node._v__ast__Stmt)._v__ast__TypeDecl)._v__ast__SumTypeDecl).variants.data)[_t4];
					pos = v__token__Position_extend(pos, variant.pos);
				}
			}
			;
		}
		if (((*node._v__ast__Stmt))._typ == 331 /* v.ast.AssignStmt */) {
			v__token__Position _t5 = v__token__Position_extend(pos, v__ast__Expr_position((*(v__ast__Expr*)array_last((*(*node._v__ast__Stmt)._v__ast__AssignStmt).right))));
			return _t5;
		}
		if (((*node._v__ast__Stmt))._typ == 330 /* v.ast.AssertStmt */) {
			v__token__Position _t6 = v__token__Position_extend(pos, v__ast__Expr_position((*(*node._v__ast__Stmt)._v__ast__AssertStmt).expr));
			return _t6;
		}
		v__token__Position _t7 = pos;
		return _t7;
	}
	else if (node._typ == 328 /* v.ast.Expr */) {
		v__token__Position _t8 = v__ast__Expr_position((*node._v__ast__Expr));
		return _t8;
	}
	else if (node._typ == 366 /* v.ast.StructField */) {
		v__token__Position _t9 = v__token__Position_extend((*node._v__ast__StructField).pos, (*node._v__ast__StructField).type_pos);
		return _t9;
	}
	else if (node._typ == 363 /* v.ast.MatchBranch */) {
		v__token__Position _t10 = (*node._v__ast__MatchBranch).pos;
		return _t10;
	}
	else if (node._typ == 365 /* v.ast.SelectBranch */) {
		v__token__Position _t11 = (*node._v__ast__SelectBranch).pos;
		return _t11;
	}
	else if (node._typ == 361 /* v.ast.EnumField */) {
		v__token__Position _t12 = (*node._v__ast__EnumField).pos;
		return _t12;
	}
	else if (node._typ == 355 /* v.ast.ConstField */) {
		v__token__Position _t13 = (*node._v__ast__ConstField).pos;
		return _t13;
	}
	else if (node._typ == 367 /* v.ast.StructInitField */) {
		v__token__Position _t14 = (*node._v__ast__StructInitField).pos;
		return _t14;
	}
	else if (node._typ == 356 /* v.ast.GlobalField */) {
		v__token__Position _t15 = (*node._v__ast__GlobalField).pos;
		return _t15;
	}
	else if (node._typ == 359 /* v.ast.CallArg */) {
		v__token__Position _t16 = (*node._v__ast__CallArg).pos;
		return _t16;
	}
	else if (node._typ == 364 /* v.ast.Param */) {
		v__token__Position _t17 = v__token__Position_extend((*node._v__ast__Param).pos, (*node._v__ast__Param).type_pos);
		return _t17;
	}
	else if (node._typ == 362 /* v.ast.IfBranch */) {
		v__token__Position _t18 = v__token__Position_extend((*node._v__ast__IfBranch).pos, (*node._v__ast__IfBranch).body_pos);
		return _t18;
	}
	else if (node._typ == 358 /* v.ast.ScopeObject */) {
		if ((*node._v__ast__ScopeObject)._typ == 355 /* v.ast.ConstField */) {
			v__token__Position _t19 = (*(*node._v__ast__ScopeObject)._v__ast__ConstField).pos;
			return _t19;
		}
		else if ((*node._v__ast__ScopeObject)._typ == 356 /* v.ast.GlobalField */) {
			v__token__Position _t20 = (*(*node._v__ast__ScopeObject)._v__ast__GlobalField).pos;
			return _t20;
		}
		else if ((*node._v__ast__ScopeObject)._typ == 357 /* v.ast.Var */) {
			v__token__Position _t21 = (*(*node._v__ast__ScopeObject)._v__ast__Var).pos;
			return _t21;
		}
		else if ((*node._v__ast__ScopeObject)._typ == 354 /* v.ast.AsmRegister */) {
			v__token__Position _t22 = (v__token__Position){.len = -1,.line_nr = -1,.pos = -1,.col = -1,.last_line = -1,};
			return _t22;
		}
		;
	}
	else if (node._typ == 207 /* v.ast.File */) {
		v__token__Position pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,};
		if ((*node._v__ast__File).stmts.len > 0) {
			v__token__Position first_pos = (*((*(v__ast__Stmt*)array_first((*node._v__ast__File).stmts)).pos));
			v__token__Position last_pos = (*((*(v__ast__Stmt*)array_last((*node._v__ast__File).stmts)).pos));
			pos = v__token__Position_extend_with_last_line(first_pos, last_pos, last_pos.line_nr);
		}
		v__token__Position _t23 = pos;
		return _t23;
	}
	;
	return (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,};
}

Array_v__ast__Node v__ast__Node_children(v__ast__Node node) {
	Array_v__ast__Node children = __new_array_with_default(0, 0, sizeof(v__ast__Node), 0);
	if ((node)._typ == 328 /* v.ast.Expr */) {
		if ((*node._v__ast__Expr)._typ == 322 /* v.ast.StringInterLiteral */) {
			Array_v__ast__Node _t2 = __new_array(0, 0, sizeof(v__ast__Node));
			Array_v__ast__Expr _t2_orig = (*(*node._v__ast__Expr)._v__ast__StringInterLiteral).exprs;
			int _t2_len = _t2_orig.len;
			_t2 = __new_array(0, _t2_len, sizeof(v__ast__Node));

			for (int _t3 = 0; _t3 < _t2_len; ++_t3) {
				v__ast__Expr it = ((v__ast__Expr*) _t2_orig.data)[_t3];
				v__ast__Node ti = v__ast__Expr_to_sumtype_v__ast__Node(&it);
				array_push((array*)&_t2, &ti);
			}
			Array_v__ast__Node _t1 =_t2;
			return _t1;
		}
		else if ((*node._v__ast__Expr)._typ == 282 /* v.ast.Assoc */) {
			Array_v__ast__Node _t5 = __new_array(0, 0, sizeof(v__ast__Node));
			Array_v__ast__Expr _t5_orig = (*(*node._v__ast__Expr)._v__ast__Assoc).exprs;
			int _t5_len = _t5_orig.len;
			_t5 = __new_array(0, _t5_len, sizeof(v__ast__Node));

			for (int _t6 = 0; _t6 < _t5_len; ++_t6) {
				v__ast__Expr it = ((v__ast__Expr*) _t5_orig.data)[_t6];
				v__ast__Node ti = v__ast__Expr_to_sumtype_v__ast__Node(&it);
				array_push((array*)&_t5, &ti);
			}
			Array_v__ast__Node _t4 =_t5;
			return _t4;
		}
		else if ((*node._v__ast__Expr)._typ == 280 /* v.ast.ArrayInit */) {
			Array_v__ast__Node _t8 = __new_array(0, 0, sizeof(v__ast__Node));
			Array_v__ast__Expr _t8_orig = (*(*node._v__ast__Expr)._v__ast__ArrayInit).exprs;
			int _t8_len = _t8_orig.len;
			_t8 = __new_array(0, _t8_len, sizeof(v__ast__Node));

			for (int _t9 = 0; _t9 < _t8_len; ++_t9) {
				v__ast__Expr it = ((v__ast__Expr*) _t8_orig.data)[_t9];
				v__ast__Node ti = v__ast__Expr_to_sumtype_v__ast__Node(&it);
				array_push((array*)&_t8, &ti);
			}
			Array_v__ast__Node _t7 =_t8;
			return _t7;
		}
		else if ((*node._v__ast__Expr)._typ == 319 /* v.ast.SelectorExpr */) {
			array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__SelectorExpr).expr) }));
		}
		else if ((*node._v__ast__Expr)._typ == 315 /* v.ast.PostfixExpr */) {
			array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__PostfixExpr).expr) }));
		}
		else if ((*node._v__ast__Expr)._typ == 327 /* v.ast.UnsafeExpr */) {
			array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__UnsafeExpr).expr) }));
		}
		else if ((*node._v__ast__Expr)._typ == 281 /* v.ast.AsCast */) {
			array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__AsCast).expr) }));
		}
		else if ((*node._v__ast__Expr)._typ == 314 /* v.ast.ParExpr */) {
			array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__ParExpr).expr) }));
		}
		else if ((*node._v__ast__Expr)._typ == 301 /* v.ast.IfGuardExpr */) {
			array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__IfGuardExpr).expr) }));
		}
		else if ((*node._v__ast__Expr)._typ == 320 /* v.ast.SizeOf */) {
			array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__SizeOf).expr) }));
		}
		else if ((*node._v__ast__Expr)._typ == 306 /* v.ast.Likely */) {
			array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__Likely).expr) }));
		}
		else if ((*node._v__ast__Expr)._typ == 326 /* v.ast.TypeOf */) {
			array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__TypeOf).expr) }));
		}
		else if ((*node._v__ast__Expr)._typ == 279 /* v.ast.ArrayDecompose */) {
			array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__ArrayDecompose).expr) }));
		}
		else if ((*node._v__ast__Expr)._typ == 307 /* v.ast.LockExpr */) {
			Array_v__ast__Node _t21 = __new_array(0, 0, sizeof(v__ast__Node));
			Array_v__ast__Stmt _t21_orig = (*(*node._v__ast__Expr)._v__ast__LockExpr).stmts;
			int _t21_len = _t21_orig.len;
			_t21 = __new_array(0, _t21_len, sizeof(v__ast__Node));

			for (int _t22 = 0; _t22 < _t21_len; ++_t22) {
				v__ast__Stmt it = ((v__ast__Stmt*) _t21_orig.data)[_t22];
				v__ast__Node ti = v__ast__Stmt_to_sumtype_v__ast__Node(&it);
				array_push((array*)&_t21, &ti);
			}
			Array_v__ast__Node _t20 =_t21;
			return _t20;
		}
		else if ((*node._v__ast__Expr)._typ == 313 /* v.ast.OrExpr */) {
			Array_v__ast__Node _t24 = __new_array(0, 0, sizeof(v__ast__Node));
			Array_v__ast__Stmt _t24_orig = (*(*node._v__ast__Expr)._v__ast__OrExpr).stmts;
			int _t24_len = _t24_orig.len;
			_t24 = __new_array(0, _t24_len, sizeof(v__ast__Node));

			for (int _t25 = 0; _t25 < _t24_len; ++_t25) {
				v__ast__Stmt it = ((v__ast__Stmt*) _t24_orig.data)[_t25];
				v__ast__Node ti = v__ast__Stmt_to_sumtype_v__ast__Node(&it);
				array_push((array*)&_t24, &ti);
			}
			Array_v__ast__Node _t23 =_t24;
			return _t23;
		}
		else if ((*node._v__ast__Expr)._typ == 324 /* v.ast.StructInit */) {
			Array_v__ast__Node _t27 = __new_array(0, 0, sizeof(v__ast__Node));
			Array_v__ast__StructInitField _t27_orig = (*(*node._v__ast__Expr)._v__ast__StructInit).fields;
			int _t27_len = _t27_orig.len;
			_t27 = __new_array(0, _t27_len, sizeof(v__ast__Node));

			for (int _t28 = 0; _t28 < _t27_len; ++_t28) {
				v__ast__StructInitField it = ((v__ast__StructInitField*) _t27_orig.data)[_t28];
				v__ast__Node ti = v__ast__StructInitField_to_sumtype_v__ast__Node(&it);
				array_push((array*)&_t27, &ti);
			}
			Array_v__ast__Node _t26 =_t27;
			return _t26;
		}
		else if ((*node._v__ast__Expr)._typ == 278 /* v.ast.AnonFn */) {
			array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Stmt_to_sumtype_v__ast__Node(ADDR(v__ast__Stmt, (v__ast__FnDecl_to_sumtype_v__ast__Stmt(&(*(*node._v__ast__Expr)._v__ast__AnonFn).decl)))) }));
		}
		else if ((*node._v__ast__Expr)._typ == 286 /* v.ast.CallExpr */) {
			array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__CallExpr).left) }));
			Array_v__ast__Node _t32 = __new_array(0, 0, sizeof(v__ast__Node));
			Array_v__ast__CallArg _t32_orig = (*(*node._v__ast__Expr)._v__ast__CallExpr).args;
			int _t32_len = _t32_orig.len;
			_t32 = __new_array(0, _t32_len, sizeof(v__ast__Node));

			for (int _t33 = 0; _t33 < _t32_len; ++_t33) {
				v__ast__CallArg it = ((v__ast__CallArg*) _t32_orig.data)[_t33];
				v__ast__Node ti = v__ast__CallArg_to_sumtype_v__ast__Node(&it);
				array_push((array*)&_t32, &ti);
			}
			_PUSH_MANY(&children, (_t32), _t31, Array_v__ast__Node);
			array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, (v__ast__OrExpr_to_sumtype_v__ast__Expr(&(*(*node._v__ast__Expr)._v__ast__CallExpr).or_block)))) }));
		}
		else if ((*node._v__ast__Expr)._typ == 303 /* v.ast.InfixExpr */) {
			array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__InfixExpr).left) }));
			array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__InfixExpr).right) }));
		}
		else if ((*node._v__ast__Expr)._typ == 316 /* v.ast.PrefixExpr */) {
			array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__PrefixExpr).right) }));
		}
		else if ((*node._v__ast__Expr)._typ == 302 /* v.ast.IndexExpr */) {
			array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__IndexExpr).left) }));
			array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__IndexExpr).index) }));
		}
		else if ((*node._v__ast__Expr)._typ == 300 /* v.ast.IfExpr */) {
			array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__IfExpr).left) }));
			Array_v__ast__Node _t42 = __new_array(0, 0, sizeof(v__ast__Node));
			Array_v__ast__IfBranch _t42_orig = (*(*node._v__ast__Expr)._v__ast__IfExpr).branches;
			int _t42_len = _t42_orig.len;
			_t42 = __new_array(0, _t42_len, sizeof(v__ast__Node));

			for (int _t43 = 0; _t43 < _t42_len; ++_t43) {
				v__ast__IfBranch it = ((v__ast__IfBranch*) _t42_orig.data)[_t43];
				v__ast__Node ti = v__ast__IfBranch_to_sumtype_v__ast__Node(&it);
				array_push((array*)&_t42, &ti);
			}
			_PUSH_MANY(&children, (_t42), _t41, Array_v__ast__Node);
		}
		else if ((*node._v__ast__Expr)._typ == 309 /* v.ast.MatchExpr */) {
			array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__MatchExpr).cond) }));
			Array_v__ast__Node _t46 = __new_array(0, 0, sizeof(v__ast__Node));
			Array_v__ast__MatchBranch _t46_orig = (*(*node._v__ast__Expr)._v__ast__MatchExpr).branches;
			int _t46_len = _t46_orig.len;
			_t46 = __new_array(0, _t46_len, sizeof(v__ast__Node));

			for (int _t47 = 0; _t47 < _t46_len; ++_t47) {
				v__ast__MatchBranch it = ((v__ast__MatchBranch*) _t46_orig.data)[_t47];
				v__ast__Node ti = v__ast__MatchBranch_to_sumtype_v__ast__Node(&it);
				array_push((array*)&_t46, &ti);
			}
			_PUSH_MANY(&children, (_t46), _t45, Array_v__ast__Node);
		}
		else if ((*node._v__ast__Expr)._typ == 318 /* v.ast.SelectExpr */) {
			Array_v__ast__Node _t49 = __new_array(0, 0, sizeof(v__ast__Node));
			Array_v__ast__SelectBranch _t49_orig = (*(*node._v__ast__Expr)._v__ast__SelectExpr).branches;
			int _t49_len = _t49_orig.len;
			_t49 = __new_array(0, _t49_len, sizeof(v__ast__Node));

			for (int _t50 = 0; _t50 < _t49_len; ++_t50) {
				v__ast__SelectBranch it = ((v__ast__SelectBranch*) _t49_orig.data)[_t50];
				v__ast__Node ti = v__ast__SelectBranch_to_sumtype_v__ast__Node(&it);
				array_push((array*)&_t49, &ti);
			}
			Array_v__ast__Node _t48 =_t49;
			return _t48;
		}
		else if ((*node._v__ast__Expr)._typ == 288 /* v.ast.ChanInit */) {
			array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__ChanInit).cap_expr) }));
		}
		else if ((*node._v__ast__Expr)._typ == 308 /* v.ast.MapInit */) {
			Array_v__ast__Node _t53 = __new_array(0, 0, sizeof(v__ast__Node));
			Array_v__ast__Expr _t53_orig = (*(*node._v__ast__Expr)._v__ast__MapInit).keys;
			int _t53_len = _t53_orig.len;
			_t53 = __new_array(0, _t53_len, sizeof(v__ast__Node));

			for (int _t54 = 0; _t54 < _t53_len; ++_t54) {
				v__ast__Expr it = ((v__ast__Expr*) _t53_orig.data)[_t54];
				v__ast__Node ti = v__ast__Expr_to_sumtype_v__ast__Node(&it);
				array_push((array*)&_t53, &ti);
			}
			_PUSH_MANY(&children, (_t53), _t52, Array_v__ast__Node);
			Array_v__ast__Node _t56 = __new_array(0, 0, sizeof(v__ast__Node));
			Array_v__ast__Expr _t56_orig = (*(*node._v__ast__Expr)._v__ast__MapInit).vals;
			int _t56_len = _t56_orig.len;
			_t56 = __new_array(0, _t56_len, sizeof(v__ast__Node));

			for (int _t57 = 0; _t57 < _t56_len; ++_t57) {
				v__ast__Expr it = ((v__ast__Expr*) _t56_orig.data)[_t57];
				v__ast__Node ti = v__ast__Expr_to_sumtype_v__ast__Node(&it);
				array_push((array*)&_t56, &ti);
			}
			_PUSH_MANY(&children, (_t56), _t55, Array_v__ast__Node);
		}
		else if ((*node._v__ast__Expr)._typ == 317 /* v.ast.RangeExpr */) {
			array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__RangeExpr).low) }));
			array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__RangeExpr).high) }));
		}
		else if ((*node._v__ast__Expr)._typ == 287 /* v.ast.CastExpr */) {
			array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__CastExpr).expr) }));
			array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__CastExpr).arg) }));
		}
		else if ((*node._v__ast__Expr)._typ == 293 /* v.ast.ConcatExpr */) {
			Array_v__ast__Node _t63 = __new_array(0, 0, sizeof(v__ast__Node));
			Array_v__ast__Expr _t63_orig = (*(*node._v__ast__Expr)._v__ast__ConcatExpr).vals;
			int _t63_len = _t63_orig.len;
			_t63 = __new_array(0, _t63_len, sizeof(v__ast__Node));

			for (int _t64 = 0; _t64 < _t63_len; ++_t64) {
				v__ast__Expr it = ((v__ast__Expr*) _t63_orig.data)[_t64];
				v__ast__Node ti = v__ast__Expr_to_sumtype_v__ast__Node(&it);
				array_push((array*)&_t63, &ti);
			}
			Array_v__ast__Node _t62 =_t63;
			return _t62;
		}
		else if ((*node._v__ast__Expr)._typ == 291 /* v.ast.ComptimeCall */) {
			array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__ComptimeCall).left) }));
		}
		else if ((*node._v__ast__Expr)._typ == 292 /* v.ast.ComptimeSelector */) {
			array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__ComptimeSelector).left) }));
		}
		
		else {
		}
		;
	} else if ((node)._typ == 353 /* v.ast.Stmt */) {
		if ((*node._v__ast__Stmt)._typ == 332 /* v.ast.Block */) {
			Array_v__ast__Node _t68 = __new_array(0, 0, sizeof(v__ast__Node));
			Array_v__ast__Stmt _t68_orig = (*(*node._v__ast__Stmt)._v__ast__Block).stmts;
			int _t68_len = _t68_orig.len;
			_t68 = __new_array(0, _t68_len, sizeof(v__ast__Node));

			for (int _t69 = 0; _t69 < _t68_len; ++_t69) {
				v__ast__Stmt it = ((v__ast__Stmt*) _t68_orig.data)[_t69];
				v__ast__Node ti = v__ast__Stmt_to_sumtype_v__ast__Node(&it);
				array_push((array*)&_t68, &ti);
			}
			Array_v__ast__Node _t67 =_t68;
			return _t67;
		}
		else if ((*node._v__ast__Stmt)._typ == 336 /* v.ast.DeferStmt */) {
			Array_v__ast__Node _t71 = __new_array(0, 0, sizeof(v__ast__Node));
			Array_v__ast__Stmt _t71_orig = (*(*node._v__ast__Stmt)._v__ast__DeferStmt).stmts;
			int _t71_len = _t71_orig.len;
			_t71 = __new_array(0, _t71_len, sizeof(v__ast__Node));

			for (int _t72 = 0; _t72 < _t71_len; ++_t72) {
				v__ast__Stmt it = ((v__ast__Stmt*) _t71_orig.data)[_t72];
				v__ast__Node ti = v__ast__Stmt_to_sumtype_v__ast__Node(&it);
				array_push((array*)&_t71, &ti);
			}
			Array_v__ast__Node _t70 =_t71;
			return _t70;
		}
		else if ((*node._v__ast__Stmt)._typ == 340 /* v.ast.ForCStmt */) {
			Array_v__ast__Node _t74 = __new_array(0, 0, sizeof(v__ast__Node));
			Array_v__ast__Stmt _t74_orig = (*(*node._v__ast__Stmt)._v__ast__ForCStmt).stmts;
			int _t74_len = _t74_orig.len;
			_t74 = __new_array(0, _t74_len, sizeof(v__ast__Node));

			for (int _t75 = 0; _t75 < _t74_len; ++_t75) {
				v__ast__Stmt it = ((v__ast__Stmt*) _t74_orig.data)[_t75];
				v__ast__Node ti = v__ast__Stmt_to_sumtype_v__ast__Node(&it);
				array_push((array*)&_t74, &ti);
			}
			Array_v__ast__Node _t73 =_t74;
			return _t73;
		}
		else if ((*node._v__ast__Stmt)._typ == 341 /* v.ast.ForInStmt */) {
			Array_v__ast__Node _t77 = __new_array(0, 0, sizeof(v__ast__Node));
			Array_v__ast__Stmt _t77_orig = (*(*node._v__ast__Stmt)._v__ast__ForInStmt).stmts;
			int _t77_len = _t77_orig.len;
			_t77 = __new_array(0, _t77_len, sizeof(v__ast__Node));

			for (int _t78 = 0; _t78 < _t77_len; ++_t78) {
				v__ast__Stmt it = ((v__ast__Stmt*) _t77_orig.data)[_t78];
				v__ast__Node ti = v__ast__Stmt_to_sumtype_v__ast__Node(&it);
				array_push((array*)&_t77, &ti);
			}
			Array_v__ast__Node _t76 =_t77;
			return _t76;
		}
		else if ((*node._v__ast__Stmt)._typ == 342 /* v.ast.ForStmt */) {
			Array_v__ast__Node _t80 = __new_array(0, 0, sizeof(v__ast__Node));
			Array_v__ast__Stmt _t80_orig = (*(*node._v__ast__Stmt)._v__ast__ForStmt).stmts;
			int _t80_len = _t80_orig.len;
			_t80 = __new_array(0, _t80_len, sizeof(v__ast__Node));

			for (int _t81 = 0; _t81 < _t80_len; ++_t81) {
				v__ast__Stmt it = ((v__ast__Stmt*) _t80_orig.data)[_t81];
				v__ast__Node ti = v__ast__Stmt_to_sumtype_v__ast__Node(&it);
				array_push((array*)&_t80, &ti);
			}
			Array_v__ast__Node _t79 =_t80;
			return _t79;
		}
		else if ((*node._v__ast__Stmt)._typ == 334 /* v.ast.ComptimeFor */) {
			Array_v__ast__Node _t83 = __new_array(0, 0, sizeof(v__ast__Node));
			Array_v__ast__Stmt _t83_orig = (*(*node._v__ast__Stmt)._v__ast__ComptimeFor).stmts;
			int _t83_len = _t83_orig.len;
			_t83 = __new_array(0, _t83_len, sizeof(v__ast__Node));

			for (int _t84 = 0; _t84 < _t83_len; ++_t84) {
				v__ast__Stmt it = ((v__ast__Stmt*) _t83_orig.data)[_t84];
				v__ast__Node ti = v__ast__Stmt_to_sumtype_v__ast__Node(&it);
				array_push((array*)&_t83, &ti);
			}
			Array_v__ast__Node _t82 =_t83;
			return _t82;
		}
		else if ((*node._v__ast__Stmt)._typ == 339 /* v.ast.ExprStmt */) {
			array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Stmt)._v__ast__ExprStmt).expr) }));
		}
		else if ((*node._v__ast__Stmt)._typ == 330 /* v.ast.AssertStmt */) {
			array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Stmt)._v__ast__AssertStmt).expr) }));
		}
		else if ((*node._v__ast__Stmt)._typ == 348 /* v.ast.InterfaceDecl */) {
			Array_v__ast__Node _t88 = __new_array(0, 0, sizeof(v__ast__Node));
			Array_v__ast__FnDecl _t88_orig = (*(*node._v__ast__Stmt)._v__ast__InterfaceDecl).methods;
			int _t88_len = _t88_orig.len;
			_t88 = __new_array(0, _t88_len, sizeof(v__ast__Node));

			for (int _t89 = 0; _t89 < _t88_len; ++_t89) {
				v__ast__FnDecl it = ((v__ast__FnDecl*) _t88_orig.data)[_t89];
				v__ast__Node ti = v__ast__Stmt_to_sumtype_v__ast__Node(ADDR(v__ast__Stmt, (v__ast__FnDecl_to_sumtype_v__ast__Stmt(&it))));
				array_push((array*)&_t88, &ti);
			}
			_PUSH_MANY(&children, (_t88), _t87, Array_v__ast__Node);
			Array_v__ast__Node _t91 = __new_array(0, 0, sizeof(v__ast__Node));
			Array_v__ast__StructField _t91_orig = (*(*node._v__ast__Stmt)._v__ast__InterfaceDecl).fields;
			int _t91_len = _t91_orig.len;
			_t91 = __new_array(0, _t91_len, sizeof(v__ast__Node));

			for (int _t92 = 0; _t92 < _t91_len; ++_t92) {
				v__ast__StructField it = ((v__ast__StructField*) _t91_orig.data)[_t92];
				v__ast__Node ti = v__ast__StructField_to_sumtype_v__ast__Node(&it);
				array_push((array*)&_t91, &ti);
			}
			_PUSH_MANY(&children, (_t91), _t90, Array_v__ast__Node);
		}
		else if ((*node._v__ast__Stmt)._typ == 331 /* v.ast.AssignStmt */) {
			Array_v__ast__Node _t94 = __new_array(0, 0, sizeof(v__ast__Node));
			Array_v__ast__Expr _t94_orig = (*(*node._v__ast__Stmt)._v__ast__AssignStmt).left;
			int _t94_len = _t94_orig.len;
			_t94 = __new_array(0, _t94_len, sizeof(v__ast__Node));

			for (int _t95 = 0; _t95 < _t94_len; ++_t95) {
				v__ast__Expr it = ((v__ast__Expr*) _t94_orig.data)[_t95];
				v__ast__Node ti = v__ast__Expr_to_sumtype_v__ast__Node(&it);
				array_push((array*)&_t94, &ti);
			}
			_PUSH_MANY(&children, (_t94), _t93, Array_v__ast__Node);
			Array_v__ast__Node _t97 = __new_array(0, 0, sizeof(v__ast__Node));
			Array_v__ast__Expr _t97_orig = (*(*node._v__ast__Stmt)._v__ast__AssignStmt).right;
			int _t97_len = _t97_orig.len;
			_t97 = __new_array(0, _t97_len, sizeof(v__ast__Node));

			for (int _t98 = 0; _t98 < _t97_len; ++_t98) {
				v__ast__Expr it = ((v__ast__Expr*) _t97_orig.data)[_t98];
				v__ast__Node ti = v__ast__Expr_to_sumtype_v__ast__Node(&it);
				array_push((array*)&_t97, &ti);
			}
			_PUSH_MANY(&children, (_t97), _t96, Array_v__ast__Node);
		}
		else if ((*node._v__ast__Stmt)._typ == 350 /* v.ast.Return */) {
			Array_v__ast__Node _t100 = __new_array(0, 0, sizeof(v__ast__Node));
			Array_v__ast__Expr _t100_orig = (*(*node._v__ast__Stmt)._v__ast__Return).exprs;
			int _t100_len = _t100_orig.len;
			_t100 = __new_array(0, _t100_len, sizeof(v__ast__Node));

			for (int _t101 = 0; _t101 < _t100_len; ++_t101) {
				v__ast__Expr it = ((v__ast__Expr*) _t100_orig.data)[_t101];
				v__ast__Node ti = v__ast__Expr_to_sumtype_v__ast__Node(&it);
				array_push((array*)&_t100, &ti);
			}
			Array_v__ast__Node _t99 =_t100;
			return _t99;
		}
		else if ((*node._v__ast__Stmt)._typ == 352 /* v.ast.StructDecl */) {
			Array_v__ast__Node _t103 = __new_array(0, 0, sizeof(v__ast__Node));
			Array_v__ast__StructField _t103_orig = (*(*node._v__ast__Stmt)._v__ast__StructDecl).fields;
			int _t103_len = _t103_orig.len;
			_t103 = __new_array(0, _t103_len, sizeof(v__ast__Node));

			for (int _t104 = 0; _t104 < _t103_len; ++_t104) {
				v__ast__StructField it = ((v__ast__StructField*) _t103_orig.data)[_t104];
				v__ast__Node ti = v__ast__StructField_to_sumtype_v__ast__Node(&it);
				array_push((array*)&_t103, &ti);
			}
			Array_v__ast__Node _t102 =_t103;
			return _t102;
		}
		else if ((*node._v__ast__Stmt)._typ == 343 /* v.ast.GlobalDecl */) {
			Array_v__ast__Node _t106 = __new_array(0, 0, sizeof(v__ast__Node));
			Array_v__ast__GlobalField _t106_orig = (*(*node._v__ast__Stmt)._v__ast__GlobalDecl).fields;
			int _t106_len = _t106_orig.len;
			_t106 = __new_array(0, _t106_len, sizeof(v__ast__Node));

			for (int _t107 = 0; _t107 < _t106_len; ++_t107) {
				v__ast__GlobalField it = ((v__ast__GlobalField*) _t106_orig.data)[_t107];
				v__ast__Node ti = v__ast__GlobalField_to_sumtype_v__ast__Node(&it);
				array_push((array*)&_t106, &ti);
			}
			Array_v__ast__Node _t105 =_t106;
			return _t105;
		}
		else if ((*node._v__ast__Stmt)._typ == 335 /* v.ast.ConstDecl */) {
			Array_v__ast__Node _t109 = __new_array(0, 0, sizeof(v__ast__Node));
			Array_v__ast__ConstField _t109_orig = (*(*node._v__ast__Stmt)._v__ast__ConstDecl).fields;
			int _t109_len = _t109_orig.len;
			_t109 = __new_array(0, _t109_len, sizeof(v__ast__Node));

			for (int _t110 = 0; _t110 < _t109_len; ++_t110) {
				v__ast__ConstField it = ((v__ast__ConstField*) _t109_orig.data)[_t110];
				v__ast__Node ti = v__ast__ConstField_to_sumtype_v__ast__Node(&it);
				array_push((array*)&_t109, &ti);
			}
			Array_v__ast__Node _t108 =_t109;
			return _t108;
		}
		else if ((*node._v__ast__Stmt)._typ == 338 /* v.ast.EnumDecl */) {
			Array_v__ast__Node _t112 = __new_array(0, 0, sizeof(v__ast__Node));
			Array_v__ast__EnumField _t112_orig = (*(*node._v__ast__Stmt)._v__ast__EnumDecl).fields;
			int _t112_len = _t112_orig.len;
			_t112 = __new_array(0, _t112_len, sizeof(v__ast__Node));

			for (int _t113 = 0; _t113 < _t112_len; ++_t113) {
				v__ast__EnumField it = ((v__ast__EnumField*) _t112_orig.data)[_t113];
				v__ast__Node ti = v__ast__EnumField_to_sumtype_v__ast__Node(&it);
				array_push((array*)&_t112, &ti);
			}
			Array_v__ast__Node _t111 =_t112;
			return _t111;
		}
		else if ((*node._v__ast__Stmt)._typ == 216 /* v.ast.FnDecl */) {
			if ((*(*node._v__ast__Stmt)._v__ast__FnDecl).is_method) {
				array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__StructField_to_sumtype_v__ast__Node(&(*(*node._v__ast__Stmt)._v__ast__FnDecl).receiver) }));
			}
			Array_v__ast__Node _t116 = __new_array(0, 0, sizeof(v__ast__Node));
			Array_v__ast__Param _t116_orig = (*(*node._v__ast__Stmt)._v__ast__FnDecl).params;
			int _t116_len = _t116_orig.len;
			_t116 = __new_array(0, _t116_len, sizeof(v__ast__Node));

			for (int _t117 = 0; _t117 < _t116_len; ++_t117) {
				v__ast__Param it = ((v__ast__Param*) _t116_orig.data)[_t117];
				v__ast__Node ti = v__ast__Param_to_sumtype_v__ast__Node(&it);
				array_push((array*)&_t116, &ti);
			}
			_PUSH_MANY(&children, (_t116), _t115, Array_v__ast__Node);
			Array_v__ast__Node _t119 = __new_array(0, 0, sizeof(v__ast__Node));
			Array_v__ast__Stmt _t119_orig = (*(*node._v__ast__Stmt)._v__ast__FnDecl).stmts;
			int _t119_len = _t119_orig.len;
			_t119 = __new_array(0, _t119_len, sizeof(v__ast__Node));

			for (int _t120 = 0; _t120 < _t119_len; ++_t120) {
				v__ast__Stmt it = ((v__ast__Stmt*) _t119_orig.data)[_t120];
				v__ast__Node ti = v__ast__Stmt_to_sumtype_v__ast__Node(&it);
				array_push((array*)&_t119, &ti);
			}
			_PUSH_MANY(&children, (_t119), _t118, Array_v__ast__Node);
		}
		else if ((*node._v__ast__Stmt)._typ == 277 /* v.ast.TypeDecl */) {
			if (((*(*node._v__ast__Stmt)._v__ast__TypeDecl))._typ == 276 /* v.ast.SumTypeDecl */) {
				Array_v__ast__Node _t122 = __new_array(0, 0, sizeof(v__ast__Node));
				Array_v__ast__TypeNode _t122_orig = (*(*(*node._v__ast__Stmt)._v__ast__TypeDecl)._v__ast__SumTypeDecl).variants;
				int _t122_len = _t122_orig.len;
				_t122 = __new_array(0, _t122_len, sizeof(v__ast__Node));

				for (int _t123 = 0; _t123 < _t122_len; ++_t123) {
					v__ast__TypeNode it = ((v__ast__TypeNode*) _t122_orig.data)[_t123];
					v__ast__Node ti = v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, (v__ast__TypeNode_to_sumtype_v__ast__Expr(&it))));
					array_push((array*)&_t122, &ti);
				}
				_PUSH_MANY(&children, (_t122), _t121, Array_v__ast__Node);
			}
		}
		
		else {
		}
		;
	} else if ((node)._typ == 358 /* v.ast.ScopeObject */) {
		if ((*node._v__ast__ScopeObject)._typ == 356 /* v.ast.GlobalField */) {
			array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__ScopeObject)._v__ast__GlobalField).expr) }));
		}
		else if ((*node._v__ast__ScopeObject)._typ == 355 /* v.ast.ConstField */) {
			array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__ScopeObject)._v__ast__ConstField).expr) }));
		}
		else if ((*node._v__ast__ScopeObject)._typ == 357 /* v.ast.Var */) {
			array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__ScopeObject)._v__ast__Var).expr) }));
		}
		else if ((*node._v__ast__ScopeObject)._typ == 354 /* v.ast.AsmRegister */) {
		}
		;
	} else {
		if (node._typ == 356 /* v.ast.GlobalField */) {
			array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*node._v__ast__GlobalField).expr) }));
		}
		else if (node._typ == 355 /* v.ast.ConstField */) {
			array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*node._v__ast__ConstField).expr) }));
		}
		else if (node._typ == 361 /* v.ast.EnumField */) {
			array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*node._v__ast__EnumField).expr) }));
		}
		else if (node._typ == 367 /* v.ast.StructInitField */) {
			array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*node._v__ast__StructInitField).expr) }));
		}
		else if (node._typ == 359 /* v.ast.CallArg */) {
			array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*node._v__ast__CallArg).expr) }));
		}
		else if (node._typ == 365 /* v.ast.SelectBranch */) {
			array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Stmt_to_sumtype_v__ast__Node(&(*node._v__ast__SelectBranch).stmt) }));
			Array_v__ast__Node _t134 = __new_array(0, 0, sizeof(v__ast__Node));
			Array_v__ast__Stmt _t134_orig = (*node._v__ast__SelectBranch).stmts;
			int _t134_len = _t134_orig.len;
			_t134 = __new_array(0, _t134_len, sizeof(v__ast__Node));

			for (int _t135 = 0; _t135 < _t134_len; ++_t135) {
				v__ast__Stmt it = ((v__ast__Stmt*) _t134_orig.data)[_t135];
				v__ast__Node ti = v__ast__Stmt_to_sumtype_v__ast__Node(&it);
				array_push((array*)&_t134, &ti);
			}
			_PUSH_MANY(&children, (_t134), _t133, Array_v__ast__Node);
		}
		else if (node._typ == 362 /* v.ast.IfBranch */) {
			Array_v__ast__Node _t137 = __new_array(0, 0, sizeof(v__ast__Node));
			Array_v__ast__Stmt _t137_orig = (*node._v__ast__IfBranch).stmts;
			int _t137_len = _t137_orig.len;
			_t137 = __new_array(0, _t137_len, sizeof(v__ast__Node));

			for (int _t138 = 0; _t138 < _t137_len; ++_t138) {
				v__ast__Stmt it = ((v__ast__Stmt*) _t137_orig.data)[_t138];
				v__ast__Node ti = v__ast__Stmt_to_sumtype_v__ast__Node(&it);
				array_push((array*)&_t137, &ti);
			}
			Array_v__ast__Node _t136 =_t137;
			return _t136;
		}
		else if (node._typ == 207 /* v.ast.File */) {
			Array_v__ast__Node _t140 = __new_array(0, 0, sizeof(v__ast__Node));
			Array_v__ast__Stmt _t140_orig = (*node._v__ast__File).stmts;
			int _t140_len = _t140_orig.len;
			_t140 = __new_array(0, _t140_len, sizeof(v__ast__Node));

			for (int _t141 = 0; _t141 < _t140_len; ++_t141) {
				v__ast__Stmt it = ((v__ast__Stmt*) _t140_orig.data)[_t141];
				v__ast__Node ti = v__ast__Stmt_to_sumtype_v__ast__Node(&it);
				array_push((array*)&_t140, &ti);
			}
			Array_v__ast__Node _t139 =_t140;
			return _t139;
		}
		else if (node._typ == 363 /* v.ast.MatchBranch */) {
			Array_v__ast__Node _t143 = __new_array(0, 0, sizeof(v__ast__Node));
			Array_v__ast__Stmt _t143_orig = (*node._v__ast__MatchBranch).stmts;
			int _t143_len = _t143_orig.len;
			_t143 = __new_array(0, _t143_len, sizeof(v__ast__Node));

			for (int _t144 = 0; _t144 < _t143_len; ++_t144) {
				v__ast__Stmt it = ((v__ast__Stmt*) _t143_orig.data)[_t144];
				v__ast__Node ti = v__ast__Stmt_to_sumtype_v__ast__Node(&it);
				array_push((array*)&_t143, &ti);
			}
			_PUSH_MANY(&children, (_t143), _t142, Array_v__ast__Node);
			Array_v__ast__Node _t146 = __new_array(0, 0, sizeof(v__ast__Node));
			Array_v__ast__Expr _t146_orig = (*node._v__ast__MatchBranch).exprs;
			int _t146_len = _t146_orig.len;
			_t146 = __new_array(0, _t146_len, sizeof(v__ast__Node));

			for (int _t147 = 0; _t147 < _t146_len; ++_t147) {
				v__ast__Expr it = ((v__ast__Expr*) _t146_orig.data)[_t147];
				v__ast__Node ti = v__ast__Expr_to_sumtype_v__ast__Node(&it);
				array_push((array*)&_t146, &ti);
			}
			_PUSH_MANY(&children, (_t146), _t145, Array_v__ast__Node);
		}
		
		else {
		}
		;
	}
	Array_v__ast__Node _t148 = children;
	return _t148;
}

void v__ast__IndexExpr_recursive_mapset_is_setter(v__ast__IndexExpr* lx, bool val) {
	lx->is_setter = val;
	if ((lx->left)._typ == 302 /* v.ast.IndexExpr */) {
		if ((*lx->left._v__ast__IndexExpr).is_map) {
			v__ast__IndexExpr_recursive_mapset_is_setter(&(*lx->left._v__ast__IndexExpr), val);
		}
	}
}

Map_string_v__ast__ScopeObject v__ast__all_registers(v__ast__Table* t, v__pref__Arch arch) {
	Map_string_v__ast__ScopeObject res = new_map(sizeof(string), sizeof(v__ast__ScopeObject), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
	switch (arch) {
		case v__pref__Arch__amd64: 
		case v__pref__Arch__i386: 
			{
				int _t2 = _const_v__ast__x86_no_number_register_list.key_values.len;
				for (int _t1 = 0; _t1 < _t2; ++_t1 ) {
					int _t3 = _const_v__ast__x86_no_number_register_list.key_values.len - _t2;
					_t2 = _const_v__ast__x86_no_number_register_list.key_values.len;
					if (_t3 < 0) {
						_t1 = -1;
						continue;
					}
					if (!DenseArray_has_index(&_const_v__ast__x86_no_number_register_list.key_values, _t1)) {continue;}
					int bit_size = /*key*/ *(int*)DenseArray_key(&_const_v__ast__x86_no_number_register_list.key_values, _t1);
					Array_string _v_array = (*(Array_string*)DenseArray_value(&_const_v__ast__x86_no_number_register_list.key_values, _t1));
					for (int _t4 = 0; _t4 < _v_array.len; ++_t4) {
						string name = ((string*)_v_array.data)[_t4];
						map_set(&res, &(string[]){name}, &(v__ast__ScopeObject[]) { v__ast__AsmRegister_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__AsmRegister, ((v__ast__AsmRegister){.name = name,.typ = v__ast__Table_bitsize_to_type(t, bit_size),.size = bit_size,}))) });
					}
				}
				int _t6 = _const_v__ast__x86_with_number_register_list.key_values.len;
				for (int _t5 = 0; _t5 < _t6; ++_t5 ) {
					int _t7 = _const_v__ast__x86_with_number_register_list.key_values.len - _t6;
					_t6 = _const_v__ast__x86_with_number_register_list.key_values.len;
					if (_t7 < 0) {
						_t5 = -1;
						continue;
					}
					if (!DenseArray_has_index(&_const_v__ast__x86_with_number_register_list.key_values, _t5)) {continue;}
					int bit_size = /*key*/ *(int*)DenseArray_key(&_const_v__ast__x86_with_number_register_list.key_values, _t5);
					Map_string_int _v_array = (*(Map_string_int*)DenseArray_value(&_const_v__ast__x86_with_number_register_list.key_values, _t5));
					int _t9 = _v_array.key_values.len;
					for (int _t8 = 0; _t8 < _t9; ++_t8 ) {
						int _t10 = _v_array.key_values.len - _t9;
						_t9 = _v_array.key_values.len;
						if (_t10 < 0) {
							_t8 = -1;
							continue;
						}
						if (!DenseArray_has_index(&_v_array.key_values, _t8)) {continue;}
						string name = /*key*/ *(string*)DenseArray_key(&_v_array.key_values, _t8);
						name = string_clone(name);
						int max_num = (*(int*)DenseArray_value(&_v_array.key_values, _t8));
						for (int i = 0; i < max_num; ++i) {
							Option_int _t11 = string_index(name, _SLIT("#"));
							if (_t11.state != 0) { /*or block*/ 
								IError err = _t11.err;
								_v_panic(_SLIT("all_registers: no hashtag found"));
								VUNREACHABLE();
							;
							}
							
 							int hash_index =  (*(int*)_t11.data);
							string assembled_name =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = string_substr(name, 0, hash_index)}}, {_SLIT0, 0xfe07, {.d_i32 = i}}, {_SLIT0, 0xfe10, {.d_s = string_substr(name, hash_index + 1, name.len)}}, {_SLIT0, 0, { .d_c = 0 }}}));
							map_set(&res, &(string[]){assembled_name}, &(v__ast__ScopeObject[]) { v__ast__AsmRegister_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__AsmRegister, ((v__ast__AsmRegister){.name = assembled_name,.typ = v__ast__Table_bitsize_to_type(t, bit_size),.size = bit_size,}))) });
						}
					}
				}
			} break;
		case v__pref__Arch__arm32: 
			{
				Map_string_v__ast__ScopeObject arm32 = v__ast__gen_all_registers(t, _const_v__ast__arm_no_number_register_list, _const_v__ast__arm_with_number_register_list, 32);
				int _t13 = arm32.key_values.len;
				for (int _t12 = 0; _t12 < _t13; ++_t12 ) {
					int _t14 = arm32.key_values.len - _t13;
					_t13 = arm32.key_values.len;
					if (_t14 < 0) {
						_t12 = -1;
						continue;
					}
					if (!DenseArray_has_index(&arm32.key_values, _t12)) {continue;}
					string k = /*key*/ *(string*)DenseArray_key(&arm32.key_values, _t12);
					k = string_clone(k);
					v__ast__ScopeObject v = (*(v__ast__ScopeObject*)DenseArray_value(&arm32.key_values, _t12));
					map_set(&res, &(string[]){k}, &(v__ast__ScopeObject[]) { v });
				}
			} break;
		case v__pref__Arch__arm64: 
			{
				Map_string_v__ast__ScopeObject arm64 = v__ast__gen_all_registers(t, _const_v__ast__arm_no_number_register_list, _const_v__ast__arm_with_number_register_list, 64);
				int _t16 = arm64.key_values.len;
				for (int _t15 = 0; _t15 < _t16; ++_t15 ) {
					int _t17 = arm64.key_values.len - _t16;
					_t16 = arm64.key_values.len;
					if (_t17 < 0) {
						_t15 = -1;
						continue;
					}
					if (!DenseArray_has_index(&arm64.key_values, _t15)) {continue;}
					string k = /*key*/ *(string*)DenseArray_key(&arm64.key_values, _t15);
					k = string_clone(k);
					v__ast__ScopeObject v = (*(v__ast__ScopeObject*)DenseArray_value(&arm64.key_values, _t15));
					map_set(&res, &(string[]){k}, &(v__ast__ScopeObject[]) { v });
				}
			} break;
		case v__pref__Arch__rv32: 
			{
				Map_string_v__ast__ScopeObject rv32 = v__ast__gen_all_registers(t, _const_v__ast__riscv_no_number_register_list, _const_v__ast__riscv_with_number_register_list, 32);
				int _t19 = rv32.key_values.len;
				for (int _t18 = 0; _t18 < _t19; ++_t18 ) {
					int _t20 = rv32.key_values.len - _t19;
					_t19 = rv32.key_values.len;
					if (_t20 < 0) {
						_t18 = -1;
						continue;
					}
					if (!DenseArray_has_index(&rv32.key_values, _t18)) {continue;}
					string k = /*key*/ *(string*)DenseArray_key(&rv32.key_values, _t18);
					k = string_clone(k);
					v__ast__ScopeObject v = (*(v__ast__ScopeObject*)DenseArray_value(&rv32.key_values, _t18));
					map_set(&res, &(string[]){k}, &(v__ast__ScopeObject[]) { v });
				}
			} break;
		case v__pref__Arch__rv64: 
			{
				Map_string_v__ast__ScopeObject rv64 = v__ast__gen_all_registers(t, _const_v__ast__riscv_no_number_register_list, _const_v__ast__riscv_with_number_register_list, 64);
				int _t22 = rv64.key_values.len;
				for (int _t21 = 0; _t21 < _t22; ++_t21 ) {
					int _t23 = rv64.key_values.len - _t22;
					_t22 = rv64.key_values.len;
					if (_t23 < 0) {
						_t21 = -1;
						continue;
					}
					if (!DenseArray_has_index(&rv64.key_values, _t21)) {continue;}
					string k = /*key*/ *(string*)DenseArray_key(&rv64.key_values, _t21);
					k = string_clone(k);
					v__ast__ScopeObject v = (*(v__ast__ScopeObject*)DenseArray_value(&rv64.key_values, _t21));
					map_set(&res, &(string[]){k}, &(v__ast__ScopeObject[]) { v });
				}
			} break;
		case v__pref__Arch___auto:
		case v__pref__Arch__js_node:
		case v__pref__Arch__js_browser:
		case v__pref__Arch__js_freestanding:
		case v__pref__Arch___max:
		default:
			{
				_v_panic(_SLIT("all_registers: unhandled arch"));
				VUNREACHABLE();
			} break;
	}
	;
	Map_string_v__ast__ScopeObject _t24 = res;
	return _t24;
}

VV_LOCAL_SYMBOL Map_string_v__ast__ScopeObject v__ast__gen_all_registers(v__ast__Table* t, Array_string without_numbers, Map_string_int with_numbers, int bit_size) {
	Map_string_v__ast__ScopeObject res = new_map(sizeof(string), sizeof(v__ast__ScopeObject), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
	for (int _t1 = 0; _t1 < without_numbers.len; ++_t1) {
		string name = ((string*)without_numbers.data)[_t1];
		map_set(&res, &(string[]){name}, &(v__ast__ScopeObject[]) { v__ast__AsmRegister_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__AsmRegister, ((v__ast__AsmRegister){.name = name,.typ = v__ast__Table_bitsize_to_type(t, bit_size),.size = bit_size,}))) });
	}
	int _t3 = with_numbers.key_values.len;
	for (int _t2 = 0; _t2 < _t3; ++_t2 ) {
		int _t4 = with_numbers.key_values.len - _t3;
		_t3 = with_numbers.key_values.len;
		if (_t4 < 0) {
			_t2 = -1;
			continue;
		}
		if (!DenseArray_has_index(&with_numbers.key_values, _t2)) {continue;}
		string name = /*key*/ *(string*)DenseArray_key(&with_numbers.key_values, _t2);
		name = string_clone(name);
		int max_num = (*(int*)DenseArray_value(&with_numbers.key_values, _t2));
		for (int i = 0; i < max_num; ++i) {
			Option_int _t5 = string_index(name, _SLIT("#"));
			if (_t5.state != 0) { /*or block*/ 
				IError err = _t5.err;
				_v_panic(_SLIT("all_registers: no hashtag found"));
				VUNREACHABLE();
			;
			}
			
 			int hash_index =  (*(int*)_t5.data);
			string assembled_name =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = string_substr(name, 0, hash_index)}}, {_SLIT0, 0xfe07, {.d_i32 = i}}, {_SLIT0, 0xfe10, {.d_s = string_substr(name, hash_index + 1, name.len)}}, {_SLIT0, 0, { .d_c = 0 }}}));
			map_set(&res, &(string[]){assembled_name}, &(v__ast__ScopeObject[]) { v__ast__AsmRegister_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__AsmRegister, ((v__ast__AsmRegister){.name = assembled_name,.typ = v__ast__Table_bitsize_to_type(t, bit_size),.size = bit_size,}))) });
		}
	}
	Map_string_v__ast__ScopeObject _t6 = res;
	return _t6;
}

bool v__ast__Expr_is_literal(v__ast__Expr expr) {
	if (expr._typ == 284 /* v.ast.BoolLiteral */) {
		bool _t1 = true;
		return _t1;
	}
	else if (expr._typ == 289 /* v.ast.CharLiteral */) {
		bool _t2 = true;
		return _t2;
	}
	else if (expr._typ == 297 /* v.ast.FloatLiteral */) {
		bool _t3 = true;
		return _t3;
	}
	else if (expr._typ == 304 /* v.ast.IntegerLiteral */) {
		bool _t4 = true;
		return _t4;
	}
	else if (expr._typ == 316 /* v.ast.PrefixExpr */) {
		bool _t5 = v__ast__Expr_is_literal((*expr._v__ast__PrefixExpr).right);
		return _t5;
	}
	else if (expr._typ == 303 /* v.ast.InfixExpr */) {
		bool _t6 = v__ast__Expr_is_literal((*expr._v__ast__InfixExpr).left) && v__ast__Expr_is_literal((*expr._v__ast__InfixExpr).right);
		return _t6;
	}
	else if (expr._typ == 314 /* v.ast.ParExpr */) {
		bool _t7 = v__ast__Expr_is_literal((*expr._v__ast__ParExpr).expr);
		return _t7;
	}
	else if (expr._typ == 287 /* v.ast.CastExpr */) {
		bool _t8 = !(*expr._v__ast__CastExpr).has_arg && v__ast__Expr_is_literal((*expr._v__ast__CastExpr).expr) && (v__ast__Type_is_ptr((*expr._v__ast__CastExpr).typ) || v__ast__Type_is_pointer((*expr._v__ast__CastExpr).typ) || ((*expr._v__ast__CastExpr).typ == _const_v__ast__i8_type || (*expr._v__ast__CastExpr).typ == _const_v__ast__i16_type || (*expr._v__ast__CastExpr).typ == _const_v__ast__int_type || (*expr._v__ast__CastExpr).typ == _const_v__ast__i64_type || (*expr._v__ast__CastExpr).typ == _const_v__ast__byte_type || (*expr._v__ast__CastExpr).typ == _const_v__ast__u8_type || (*expr._v__ast__CastExpr).typ == _const_v__ast__u16_type || (*expr._v__ast__CastExpr).typ == _const_v__ast__u32_type || (*expr._v__ast__CastExpr).typ == _const_v__ast__u64_type || (*expr._v__ast__CastExpr).typ == _const_v__ast__f32_type || (*expr._v__ast__CastExpr).typ == _const_v__ast__f64_type || (*expr._v__ast__CastExpr).typ == _const_v__ast__char_type || (*expr._v__ast__CastExpr).typ == _const_v__ast__bool_type || (*expr._v__ast__CastExpr).typ == _const_v__ast__rune_type));
		return _t8;
	}
	else if (expr._typ == 320 /* v.ast.SizeOf */) {
		bool _t9 = (*expr._v__ast__SizeOf).is_type || v__ast__Expr_is_literal((*expr._v__ast__SizeOf).expr);
		return _t9;
	}
	else if (expr._typ == 305 /* v.ast.IsRefType */) {
		bool _t10 = (*expr._v__ast__IsRefType).is_type || v__ast__Expr_is_literal((*expr._v__ast__IsRefType).expr);
		return _t10;
	}
	
	else {
		bool _t11 = false;
		return _t11;
	}
	;
	return 0;
}

bool v__ast__type_can_start_with_token(v__token__Token* tok) {

	if (tok->kind == (v__token__Kind__name)) {
		bool _t1 = (tok->lit.len > 0 && byte_is_capital(string_at(tok->lit, 0))) || v__token__KeywordsMatcher_find(&_const_v__ast__builtin_type_names_matcher, tok->lit) > 0;
		return _t1;
	}
	else if (tok->kind == (v__token__Kind__amp) || tok->kind == (v__token__Kind__key_fn) || tok->kind == (v__token__Kind__lsbr) || tok->kind == (v__token__Kind__question)) {
		bool _t2 = true;
		return _t2;
	}
	else {
	};
	bool _t3 = false;
	return _t3;
}

VV_LOCAL_SYMBOL v__token__KeywordsMatcher v__ast__build_builtin_type_names_matcher(void) {
	Map_string_int m = new_map(sizeof(string), sizeof(int), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
	for (int i = 0; i < _const_v__ast__builtin_type_names.len; ++i) {
		string name = ((string*)_const_v__ast__builtin_type_names.data)[i];
		map_set(&m, &(string[]){name}, &(int[]) { i });
	}
	v__token__KeywordsMatcher _t1 = v__token__new_keywords_matcher_T_int(m);
	return _t1;
}

string v__ast__Attr_debug(v__ast__Attr* a) {
	string _t1 =  str_intp(8, _MOV((StrIntpData[]){{_SLIT("Attr{ name: \""), 0xfe10, {.d_s = a->name}}, {_SLIT("\", has_arg: "), 0xfe10, {.d_s = a->has_arg ? _SLIT("true") : _SLIT("false")}}, {_SLIT(", arg: \""), 0xfe10, {.d_s = a->arg}}, {_SLIT("\", kind: "), 0xfe10, {.d_s = v__ast__AttrKind_str(a->kind)}}, {_SLIT(", ct_expr: "), 0xfe10, {.d_s = v__ast__Expr_str(a->ct_expr)}}, {_SLIT(", ct_opt: "), 0xfe10, {.d_s = a->ct_opt ? _SLIT("true") : _SLIT("false")}}, {_SLIT(", ct_skip: "), 0xfe10, {.d_s = a->ct_skip ? _SLIT("true") : _SLIT("false")}}, {_SLIT("}"), 0, { .d_c = 0 }}}));
	return _t1;
}

string v__ast__Attr_str(v__ast__Attr* a) {
	string s = _SLIT("");
	string _t1; /* if prepend */
	if (a->has_arg) {
		s = /*f*/string__plus(s,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = a->name}}, {_SLIT(": "), 0, { .d_c = 0 }}})));
		_t1 = a->arg;
	} else {
		_t1 = a->name;
	}
	string arg =  _t1;
	s = /*f*/string__plus(s, ((a->kind == (v__ast__AttrKind__plain) || a->kind == (v__ast__AttrKind__number) || a->kind == (v__ast__AttrKind__bool)) ? (arg) : (a->kind == (v__ast__AttrKind__string)) ? ( str_intp(2, _MOV((StrIntpData[]){{_SLIT("'"), 0xfe10, {.d_s = arg}}, {_SLIT("'"), 0, { .d_c = 0 }}}))) : ( str_intp(2, _MOV((StrIntpData[]){{_SLIT("if "), 0xfe10, {.d_s = arg}}, {_SLIT0, 0, { .d_c = 0 }}})))));
	string _t2 = s;
	return _t2;
}

bool Array_v__ast__Attr_contains(Array_v__ast__Attr attrs, string str) {
	bool _t2 = false;
	Array_v__ast__Attr _t2_orig = attrs;
	int _t2_len = _t2_orig.len;
	for (int _t3 = 0; _t3 < _t2_len; ++_t3) {
		v__ast__Attr it = ((v__ast__Attr*) _t2_orig.data)[_t3];
		if (string__eq(it.name, str)) {
			_t2 = true;
			break;
		}
	}
	bool _t1 =_t2;
	return _t1;
}

Option_int Array_v__ast__Attr_find_comptime_define(Array_v__ast__Attr attrs) {
	for (int idx = 0; idx < attrs.len; ++idx) {
		if ((*(v__ast__Attr*)/*ee elem_typ */array_get(attrs, idx)).kind == v__ast__AttrKind__comptime_define) {
			Option_int _t1;
			opt_ok(&(int[]) { idx }, (Option*)(&_t1), sizeof(int));
			return _t1;
		}
	}
	return (Option_int){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
}

VV_LOCAL_SYMBOL bool v__ast__Table_has_cflag(v__ast__Table* t, v__cflag__CFlag flag) {
	for (int _t1 = 0; _t1 < t->cflags.len; ++_t1) {
		v__cflag__CFlag cf = ((v__cflag__CFlag*)t->cflags.data)[_t1];
		if (string__eq(cf.os, flag.os) && string__eq(cf.name, flag.name) && string__eq(cf.value, flag.value)) {
			bool _t2 = true;
			return _t2;
		}
	}
	bool _t3 = false;
	return _t3;
}

Option_bool v__ast__Table_parse_cflag(v__ast__Table* t, string cflg, string mod, Array_string ctimedefines) {
	Array_string allowed_flags = new_array_from_c_array(9, 9, sizeof(string), _MOV((string[9]){
			_SLIT("framework"), _SLIT("library"), _SLIT("Wa"), _SLIT("Wl"), _SLIT("Wp"), _SLIT("I"), _SLIT("l"), _SLIT("L"), _SLIT("D")}));
	string flag_orig = string_trim_space(cflg);
	string flag = flag_orig;
	if ((flag).len == 0) {
		return (Option_bool){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	string fos = _SLIT("");
	Array_string allowed_os_overrides = new_array_from_c_array(6, 6, sizeof(string), _MOV((string[6]){_SLIT("linux"), _SLIT("darwin"), _SLIT("freebsd"), _SLIT("windows"), _SLIT("mingw"), _SLIT("solaris")}));
	_PUSH_MANY(&allowed_os_overrides, (ctimedefines), _t2, Array_string);
	for (int _t3 = 0; _t3 < allowed_os_overrides.len; ++_t3) {
		string os_override = ((string*)allowed_os_overrides.data)[_t3];
		if (!string_starts_with(flag, os_override)) {
			continue;
		}
		Option_int _t4 = string_index(flag, _SLIT(" "));
		if (_t4.state != 0) { /*or block*/ 
			IError err = _t4.err;
			return (Option_bool){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		
 		int pos =  (*(int*)_t4.data);
		fos = string_trim_space(string_substr(flag, 0, pos));
		flag = string_trim_space(string_substr(flag, pos, flag.len));
	}
	for (;;) {
		string name = _SLIT("");
		string value = _SLIT("");
		if (string_at(flag, 0) == '-') {
			for (int _t6 = 0; _t6 < allowed_flags.len; ++_t6) {
				string f = ((string*)allowed_flags.data)[_t6];
				int i = 1 + f.len;
				if (i <= flag.len && string__eq(f, string_substr(flag, 1, i))) {
					name = string_trim_space(string_substr(flag, 0, i));
					flag = string_trim_space(string_substr(flag, i, flag.len));
					break;
				}
			}
		}
		Option_int _t7 = string_index(flag, _SLIT(" -"));
		if (_t7.state != 0) { /*or block*/ 
			IError err = _t7.err;
			*(int*) _t7.data = -1;
		}
		
 		int index =  (*(int*)_t7.data);
		for (;;) {
			if (!(index > -1)) break;
			bool has_next = false;
			for (int _t8 = 0; _t8 < allowed_flags.len; ++_t8) {
				string f = ((string*)allowed_flags.data)[_t8];
				int i = index + 2 + f.len;
				if (i <= flag.len && string__eq(f, string_substr(flag, index + 2, i))) {
					value = string_trim_space(string_substr(flag, 0, index + 1));
					flag = string_trim_space(string_substr(flag, index + 1, flag.len));
					has_next = true;
					break;
				}
			}
			if (has_next) {
				break;
			}
			index = string_index_after(flag, _SLIT(" -"), index + 1);
		}
		if (index == -1) {
			value = string_trim_space(flag);
		}
		if (((string__eq(name, _SLIT("-I")) || string__eq(name, _SLIT("-l")) || string__eq(name, _SLIT("-L")))) && (value).len == 0) {
			string hint = (string__eq(name, _SLIT("-l")) ? (_SLIT("library name")) : (_SLIT("path")));
			return (Option_bool){ .state=2, .err=_v_error( str_intp(4, _MOV((StrIntpData[]){{_SLIT("bad #flag `"), 0xfe10, {.d_s = flag_orig}}, {_SLIT("`: missing "), 0xfe10, {.d_s = hint}}, {_SLIT(" after `"), 0xfe10, {.d_s = name}}, {_SLIT("`"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		v__cflag__CFlag cf = (v__cflag__CFlag){.mod = mod,.os = fos,.name = name,.value = value,.cached = (string){.str=(byteptr)"", .is_lit=1},};
		if (!v__ast__Table_has_cflag(t, cf)) {
			array_push((array*)&t->cflags, _MOV((v__cflag__CFlag[]){ cf }));
		}
		if (index == -1) {
			break;
		}
	}
	Option_bool _t11;
	opt_ok(&(bool[]) { true }, (Option*)(&_t11), sizeof(bool));
	return _t11;
}

// TypeDecl
v__ast__ComptTimeConstValue v__ast__empty_comptime_const_expr(void) {
	v__ast__ComptTimeConstValue _t1 = v__ast__EmptyExpr_to_sumtype_v__ast__ComptTimeConstValue(ADDR(v__ast__EmptyExpr, ((v__ast__EmptyExpr){.x = 0,})));
	return _t1;
}

Option_i8 v__ast__ComptTimeConstValue_i8(v__ast__ComptTimeConstValue val) {
	Option_i64 _t1 = v__ast__ComptTimeConstValue_i64(val);
	if (_t1.state != 0) { /*or block*/ 
		Option_i8 _t2;
		memcpy(&_t2, &_t1, sizeof(Option));
		return _t2;
	}
	
 	i64 x =  (*(i64*)_t1.data);
	if (x > -129 && x < 128) {
		Option_i8 _t3;
		opt_ok(&(i8[]) { ((i8)(x)) }, (Option*)(&_t3), sizeof(i8));
		return _t3;
	}
	return (Option_i8){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
}

Option_i16 v__ast__ComptTimeConstValue_i16(v__ast__ComptTimeConstValue val) {
	Option_i64 _t1 = v__ast__ComptTimeConstValue_i64(val);
	if (_t1.state != 0) { /*or block*/ 
		Option_i16 _t2;
		memcpy(&_t2, &_t1, sizeof(Option));
		return _t2;
	}
	
 	i64 x =  (*(i64*)_t1.data);
	if (x > -32769 && x < 32768) {
		Option_i16 _t3;
		opt_ok(&(i16[]) { ((i16)(x)) }, (Option*)(&_t3), sizeof(i16));
		return _t3;
	}
	return (Option_i16){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
}

Option_int v__ast__ComptTimeConstValue_int(v__ast__ComptTimeConstValue val) {
	Option_i64 _t1 = v__ast__ComptTimeConstValue_i64(val);
	if (_t1.state != 0) { /*or block*/ 
		Option_int _t2;
		memcpy(&_t2, &_t1, sizeof(Option));
		return _t2;
	}
	
 	i64 x =  (*(i64*)_t1.data);
	if (x > -2147483649 && x < 2147483648) {
		Option_int _t3;
		opt_ok(&(int[]) { ((int)(x)) }, (Option*)(&_t3), sizeof(int));
		return _t3;
	}
	return (Option_int){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
}

Option_i64 v__ast__ComptTimeConstValue_i64(v__ast__ComptTimeConstValue val) {
	if (val._typ == 5 /* i8 */) {
		Option_i64 _t1;
		opt_ok(&(i64[]) { ((i64)((*val._i8))) }, (Option*)(&_t1), sizeof(i64));
		return _t1;
	}
	else if (val._typ == 6 /* i16 */) {
		Option_i64 _t2;
		opt_ok(&(i64[]) { ((i64)((*val._i16))) }, (Option*)(&_t2), sizeof(i64));
		return _t2;
	}
	else if (val._typ == 7 /* int */) {
		Option_i64 _t3;
		opt_ok(&(i64[]) { ((i64)((*val._int))) }, (Option*)(&_t3), sizeof(i64));
		return _t3;
	}
	else if (val._typ == 8 /* i64 */) {
		Option_i64 _t4;
		opt_ok(&(i64[]) { ((i64)((*val._i64))) }, (Option*)(&_t4), sizeof(i64));
		return _t4;
	}
	else if (val._typ == 10 /* byte */) {
		Option_i64 _t5;
		opt_ok(&(i64[]) { ((i64)((*val._byte))) }, (Option*)(&_t5), sizeof(i64));
		return _t5;
	}
	else if (val._typ == 11 /* u16 */) {
		Option_i64 _t6;
		opt_ok(&(i64[]) { ((i64)((*val._u16))) }, (Option*)(&_t6), sizeof(i64));
		return _t6;
	}
	else if (val._typ == 12 /* u32 */) {
		Option_i64 _t7;
		opt_ok(&(i64[]) { ((i64)((*val._u32))) }, (Option*)(&_t7), sizeof(i64));
		return _t7;
	}
	else if (val._typ == 13 /* u64 */) {
		if ((*val._u64) <= 9223372036854775807U) {
			Option_i64 _t8;
			opt_ok(&(i64[]) { ((i64)((*val._u64))) }, (Option*)(&_t8), sizeof(i64));
			return _t8;
		}
	}
	else if (val._typ == 15 /* f32 */) {
		if (-9223372036854775808.0 <= (*val._f32) && (*val._f32) <= 9223372036854775807.0) {
			Option_i64 _t9;
			opt_ok(&(i64[]) { ((i64)((*val._f32))) }, (Option*)(&_t9), sizeof(i64));
			return _t9;
		}
	}
	else if (val._typ == 16 /* f64 */) {
		if (-9223372036854775808.0 <= (*val._f64) && (*val._f64) <= 9223372036854775807.0) {
			Option_i64 _t10;
			opt_ok(&(i64[]) { ((i64)((*val._f64))) }, (Option*)(&_t10), sizeof(i64));
			return _t10;
		}
	}
	else if (val._typ == 20 /* string */) {
		Option_i64 _t11;
		opt_ok(&(i64[]) { string_i64((*val._string)) }, (Option*)(&_t11), sizeof(i64));
		return _t11;
	}
	else if (val._typ == 21 /* rune */) {
		Option_i64 _t12;
		opt_ok(&(i64[]) { ((int)((*val._rune))) }, (Option*)(&_t12), sizeof(i64));
		return _t12;
	}
	else if (val._typ == 295 /* v.ast.EmptyExpr */) {
	}
	;
	return (Option_i64){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
}

Option_byte v__ast__ComptTimeConstValue_byte(v__ast__ComptTimeConstValue val) {
	Option_u64 _t1 = v__ast__ComptTimeConstValue_u64(val);
	if (_t1.state != 0) { /*or block*/ 
		Option_byte _t2;
		memcpy(&_t2, &_t1, sizeof(Option));
		return _t2;
	}
	
 	u64 x =  (*(u64*)_t1.data);
	if (x < 256U) {
		Option_byte _t3;
		opt_ok(&(byte[]) { ((byte)(x)) }, (Option*)(&_t3), sizeof(byte));
		return _t3;
	}
	return (Option_byte){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
}

Option_u16 v__ast__ComptTimeConstValue_u16(v__ast__ComptTimeConstValue val) {
	Option_u64 _t1 = v__ast__ComptTimeConstValue_u64(val);
	if (_t1.state != 0) { /*or block*/ 
		Option_u16 _t2;
		memcpy(&_t2, &_t1, sizeof(Option));
		return _t2;
	}
	
 	u64 x =  (*(u64*)_t1.data);
	if (x < 65536U) {
		Option_u16 _t3;
		opt_ok(&(u16[]) { ((u16)(x)) }, (Option*)(&_t3), sizeof(u16));
		return _t3;
	}
	return (Option_u16){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
}

Option_u32 v__ast__ComptTimeConstValue_u32(v__ast__ComptTimeConstValue val) {
	Option_u64 _t1 = v__ast__ComptTimeConstValue_u64(val);
	if (_t1.state != 0) { /*or block*/ 
		Option_u32 _t2;
		memcpy(&_t2, &_t1, sizeof(Option));
		return _t2;
	}
	
 	u64 x =  (*(u64*)_t1.data);
	if (x < 4294967296U) {
		Option_u32 _t3;
		opt_ok(&(u32[]) { ((u32)(x)) }, (Option*)(&_t3), sizeof(u32));
		return _t3;
	}
	return (Option_u32){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
}

Option_u64 v__ast__ComptTimeConstValue_u64(v__ast__ComptTimeConstValue val) {
	if (val._typ == 5 /* i8 */) {
		if ((*val._i8) >= 0) {
			Option_u64 _t1;
			opt_ok(&(u64[]) { ((u64)((*val._i8))) }, (Option*)(&_t1), sizeof(u64));
			return _t1;
		}
	}
	else if (val._typ == 6 /* i16 */) {
		if ((*val._i16) >= 0) {
			Option_u64 _t2;
			opt_ok(&(u64[]) { ((u64)((*val._i16))) }, (Option*)(&_t2), sizeof(u64));
			return _t2;
		}
	}
	else if (val._typ == 7 /* int */) {
		if ((*val._int) >= 0) {
			Option_u64 _t3;
			opt_ok(&(u64[]) { ((u64)((*val._int))) }, (Option*)(&_t3), sizeof(u64));
			return _t3;
		}
	}
	else if (val._typ == 8 /* i64 */) {
		if ((*val._i64) >= 0) {
			Option_u64 _t4;
			opt_ok(&(u64[]) { ((u64)((*val._i64))) }, (Option*)(&_t4), sizeof(u64));
			return _t4;
		}
	}
	else if (val._typ == 10 /* byte */) {
		Option_u64 _t5;
		opt_ok(&(u64[]) { ((u64)((*val._byte))) }, (Option*)(&_t5), sizeof(u64));
		return _t5;
	}
	else if (val._typ == 11 /* u16 */) {
		Option_u64 _t6;
		opt_ok(&(u64[]) { ((u64)((*val._u16))) }, (Option*)(&_t6), sizeof(u64));
		return _t6;
	}
	else if (val._typ == 12 /* u32 */) {
		Option_u64 _t7;
		opt_ok(&(u64[]) { ((u64)((*val._u32))) }, (Option*)(&_t7), sizeof(u64));
		return _t7;
	}
	else if (val._typ == 13 /* u64 */) {
		Option_u64 _t8;
		opt_ok(&(u64[]) { (*val._u64) }, (Option*)(&_t8), sizeof(u64));
		return _t8;
	}
	else if (val._typ == 15 /* f32 */) {
		if ((*val._f32) <= 18446744073709551615.0) {
			Option_u64 _t9;
			opt_ok(&(u64[]) { ((u64)((*val._f32))) }, (Option*)(&_t9), sizeof(u64));
			return _t9;
		}
	}
	else if (val._typ == 16 /* f64 */) {
		if ((*val._f64) <= 18446744073709551615.0) {
			Option_u64 _t10;
			opt_ok(&(u64[]) { ((u64)((*val._f64))) }, (Option*)(&_t10), sizeof(u64));
			return _t10;
		}
	}
	else if (val._typ == 20 /* string */) {
		Option_u64 _t11;
		opt_ok(&(u64[]) { string_u64((*val._string)) }, (Option*)(&_t11), sizeof(u64));
		return _t11;
	}
	else if (val._typ == 21 /* rune */) {
	}
	else if (val._typ == 295 /* v.ast.EmptyExpr */) {
	}
	;
	return (Option_u64){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
}

Option_f32 v__ast__ComptTimeConstValue_f32(v__ast__ComptTimeConstValue val) {
	Option_f64 _t1 = v__ast__ComptTimeConstValue_f64(val);
	if (_t1.state != 0) { /*or block*/ 
		Option_f32 _t2;
		memcpy(&_t2, &_t1, sizeof(Option));
		return _t2;
	}
	
 	f64 x =  (*(f64*)_t1.data);
	Option_f32 _t3;
	opt_ok(&(f32[]) { ((f32)(x)) }, (Option*)(&_t3), sizeof(f32));
	return _t3;
}

Option_f64 v__ast__ComptTimeConstValue_f64(v__ast__ComptTimeConstValue val) {
	if (val._typ == 5 /* i8 */) {
		Option_f64 _t1;
		opt_ok(&(f64[]) { ((f64)((*val._i8))) }, (Option*)(&_t1), sizeof(f64));
		return _t1;
	}
	else if (val._typ == 6 /* i16 */) {
		Option_f64 _t2;
		opt_ok(&(f64[]) { ((f64)((*val._i16))) }, (Option*)(&_t2), sizeof(f64));
		return _t2;
	}
	else if (val._typ == 7 /* int */) {
		Option_f64 _t3;
		opt_ok(&(f64[]) { ((f64)((*val._int))) }, (Option*)(&_t3), sizeof(f64));
		return _t3;
	}
	else if (val._typ == 8 /* i64 */) {
		Option_f64 _t4;
		opt_ok(&(f64[]) { ((f64)((*val._i64))) }, (Option*)(&_t4), sizeof(f64));
		return _t4;
	}
	else if (val._typ == 10 /* byte */) {
		Option_f64 _t5;
		opt_ok(&(f64[]) { ((f64)((*val._byte))) }, (Option*)(&_t5), sizeof(f64));
		return _t5;
	}
	else if (val._typ == 11 /* u16 */) {
		Option_f64 _t6;
		opt_ok(&(f64[]) { ((f64)((*val._u16))) }, (Option*)(&_t6), sizeof(f64));
		return _t6;
	}
	else if (val._typ == 12 /* u32 */) {
		Option_f64 _t7;
		opt_ok(&(f64[]) { ((f64)((*val._u32))) }, (Option*)(&_t7), sizeof(f64));
		return _t7;
	}
	else if (val._typ == 13 /* u64 */) {
		Option_f64 _t8;
		opt_ok(&(f64[]) { ((f64)((*val._u64))) }, (Option*)(&_t8), sizeof(f64));
		return _t8;
	}
	else if (val._typ == 15 /* f32 */) {
		Option_f64 _t9;
		opt_ok(&(f64[]) { ((f64)((*val._f32))) }, (Option*)(&_t9), sizeof(f64));
		return _t9;
	}
	else if (val._typ == 16 /* f64 */) {
		Option_f64 _t10;
		opt_ok(&(f64[]) { (*val._f64) }, (Option*)(&_t10), sizeof(f64));
		return _t10;
	}
	else if (val._typ == 20 /* string */) {
		Option_f64 _t11;
		opt_ok(&(f64[]) { string_f64((*val._string)) }, (Option*)(&_t11), sizeof(f64));
		return _t11;
	}
	else if (val._typ == 21 /* rune */) {
	}
	else if (val._typ == 295 /* v.ast.EmptyExpr */) {
	}
	;
	return (Option_f64){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
}

Option_string v__ast__ComptTimeConstValue_string(v__ast__ComptTimeConstValue val) {
	if (val._typ == 5 /* i8 */) {
		Option_string _t1;
		opt_ok(&(string[]) { i8_str((*val._i8)) }, (Option*)(&_t1), sizeof(string));
		return _t1;
	}
	else if (val._typ == 6 /* i16 */) {
		Option_string _t2;
		opt_ok(&(string[]) { i16_str((*val._i16)) }, (Option*)(&_t2), sizeof(string));
		return _t2;
	}
	else if (val._typ == 7 /* int */) {
		Option_string _t3;
		opt_ok(&(string[]) { int_str((*val._int)) }, (Option*)(&_t3), sizeof(string));
		return _t3;
	}
	else if (val._typ == 8 /* i64 */) {
		Option_string _t4;
		opt_ok(&(string[]) { i64_str((*val._i64)) }, (Option*)(&_t4), sizeof(string));
		return _t4;
	}
	else if (val._typ == 10 /* byte */) {
		Option_string _t5;
		opt_ok(&(string[]) { byte_str((*val._byte)) }, (Option*)(&_t5), sizeof(string));
		return _t5;
	}
	else if (val._typ == 11 /* u16 */) {
		Option_string _t6;
		opt_ok(&(string[]) { u16_str((*val._u16)) }, (Option*)(&_t6), sizeof(string));
		return _t6;
	}
	else if (val._typ == 12 /* u32 */) {
		Option_string _t7;
		opt_ok(&(string[]) { u32_str((*val._u32)) }, (Option*)(&_t7), sizeof(string));
		return _t7;
	}
	else if (val._typ == 13 /* u64 */) {
		Option_string _t8;
		opt_ok(&(string[]) { u64_str((*val._u64)) }, (Option*)(&_t8), sizeof(string));
		return _t8;
	}
	else if (val._typ == 15 /* f32 */) {
		Option_string _t9;
		opt_ok(&(string[]) { f32_str((*val._f32)) }, (Option*)(&_t9), sizeof(string));
		return _t9;
	}
	else if (val._typ == 16 /* f64 */) {
		Option_string _t10;
		opt_ok(&(string[]) { f64_str((*val._f64)) }, (Option*)(&_t10), sizeof(string));
		return _t10;
	}
	else if (val._typ == 21 /* rune */) {
		Option_string _t11;
		opt_ok(&(string[]) { rune_str((*val._rune)) }, (Option*)(&_t11), sizeof(string));
		return _t11;
	}
	else if (val._typ == 20 /* string */) {
		Option_string _t12;
		opt_ok(&(string[]) { (*val._string) }, (Option*)(&_t12), sizeof(string));
		return _t12;
	}
	else if (val._typ == 295 /* v.ast.EmptyExpr */) {
	}
	;
	return (Option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
}

Option_v__ast__ComptTimeConstValue v__ast__ConstField_comptime_expr_value(v__ast__ConstField* obj) {
	if ((obj->comptime_expr_value)._typ != 295 /* v.ast.EmptyExpr */) {
		Option_v__ast__ComptTimeConstValue _t1;
		opt_ok(&(v__ast__ComptTimeConstValue[]) { obj->comptime_expr_value }, (Option*)(&_t1), sizeof(v__ast__ComptTimeConstValue));
		return _t1;
	}
	return (Option_v__ast__ComptTimeConstValue){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
}

bool v__ast__ConstField_is_simple_define_const(v__ast__ConstField* obj) {
	bool _t1 = ((obj->expr._typ == 289 /* v.ast.CharLiteral */) ? (true) : (obj->expr._typ == 297 /* v.ast.FloatLiteral */) ? (true) : (obj->expr._typ == 304 /* v.ast.IntegerLiteral */) ? (true) : (false));
	return _t1;
}

bool v__ast__ScopeObject_is_simple_define_const(v__ast__ScopeObject obj) {
	if ((obj)._typ == 355 /* v.ast.ConstField */) {
		bool _t1 = v__ast__ConstField_is_simple_define_const(&(*obj._v__ast__ConstField));
		return _t1;
	}
	bool _t2 = false;
	return _t2;
}

v__ast__Expr v__ast__resolve_init(v__ast__StructInit node, v__ast__Type typ, v__ast__Table* t) {
	v__ast__TypeSymbol* type_sym = v__ast__Table_sym(t, typ);
	if (type_sym->kind == v__ast__Kind__array) {
		v__ast__Array array_info = /* as */ *(v__ast__Array*)__as_cast((type_sym->info)._v__ast__Array,(type_sym->info)._typ, 441) /*expected idx: 441, name: v.ast.Array */ ;
		bool has_len = false;
		bool has_cap = false;
		bool has_default = false;
		v__ast__Expr len_expr = v__ast__empty_expr();
		v__ast__Expr cap_expr = v__ast__empty_expr();
		v__ast__Expr default_expr = v__ast__empty_expr();
		Array_v__ast__Expr exprs = __new_array_with_default(0, 0, sizeof(v__ast__Expr), 0);
		for (int _t1 = 0; _t1 < node.fields.len; ++_t1) {
			v__ast__StructInitField field = ((v__ast__StructInitField*)node.fields.data)[_t1];

			if (string__eq(field.name, _SLIT("len"))) {
				has_len = true;
				len_expr = field.expr;
			}
			else if (string__eq(field.name, _SLIT("cap"))) {
				has_cap = true;
				len_expr = field.expr;
			}
			else if (string__eq(field.name, _SLIT("default"))) {
				has_default = true;
				len_expr = field.expr;
			}
			else {
				array_push((array*)&exprs, _MOV((v__ast__Expr[]){ field.expr }));
			};
		}
		v__ast__Expr _t3 = v__ast__ArrayInit_to_sumtype_v__ast__Expr(ADDR(v__ast__ArrayInit, ((v__ast__ArrayInit){
			.pos = node.pos,
			.elem_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},
			.exprs = exprs,
			.ecmnts = __new_array(0, 0, sizeof(Array_v__ast__Comment)),
			.pre_cmnts = __new_array(0, 0, sizeof(v__ast__Comment)),
			.is_fixed = 0,
			.has_val = 0,
			.mod = (string){.str=(byteptr)"", .is_lit=1},
			.len_expr = len_expr,
			.cap_expr = cap_expr,
			.default_expr = default_expr,
			.has_len = has_len,
			.has_cap = has_cap,
			.has_default = has_default,
			.has_it = 0,
			.expr_types = __new_array(0, 0, sizeof(v__ast__Type)),
			.elem_type = array_info.elem_type,
			.typ = typ,
		})));
		return _t3;
	} else if (type_sym->kind == v__ast__Kind__map) {
		v__ast__Map map_info = /* as */ *(v__ast__Map*)__as_cast((type_sym->info)._v__ast__Map,(type_sym->info)._typ, 442) /*expected idx: 442, name: v.ast.Map */ ;
		Array_v__ast__Expr keys = __new_array_with_default(0, 0, sizeof(v__ast__Expr), 0);
		Array_v__ast__Expr vals = __new_array_with_default(0, 0, sizeof(v__ast__Expr), 0);
		for (int _t4 = 0; _t4 < node.fields.len; ++_t4) {
			v__ast__StructInitField field = ((v__ast__StructInitField*)node.fields.data)[_t4];
			array_push((array*)&keys, _MOV((v__ast__Expr[]){ v__ast__StringLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__StringLiteral, ((v__ast__StringLiteral){.val = field.name,.is_raw = 0,.language = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},}))) }));
			array_push((array*)&vals, _MOV((v__ast__Expr[]){ field.expr }));
		}
		v__ast__Expr _t7 = v__ast__MapInit_to_sumtype_v__ast__Expr(ADDR(v__ast__MapInit, ((v__ast__MapInit){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.keys = keys,.vals = vals,.comments = __new_array(0, 0, sizeof(Array_v__ast__Comment)),.pre_cmnts = __new_array(0, 0, sizeof(v__ast__Comment)),.typ = typ,.key_type = map_info.key_type,.value_type = map_info.value_type,})));
		return _t7;
	}
	v__ast__Expr _t8 = v__ast__StructInit_to_sumtype_v__ast__Expr(ADDR(v__ast__StructInit, ((v__ast__StructInit){node.pos,node.name_pos,node.is_short,.unresolved = false,node.pre_comments,node.typ,node.update_expr,node.update_expr_type,node.update_expr_comments,node.has_update_expr,node.fields,node.embeds,})));
	return _t8;
}

// Attr: [unsafe]
void v__ast__Scope_free(v__ast__Scope* s) {
	{ // Unsafe block
		map_free(&s->objects);
		map_free(&s->struct_fields);
		for (int _t1 = 0; _t1 < s->children.len; ++_t1) {
			v__ast__Scope* child = ((v__ast__Scope**)s->children.data)[_t1];
			v__ast__Scope_free(child);
		}
		array_free(&s->children);
	}
}

VV_LOCAL_SYMBOL bool v__ast__Scope_dont_lookup_parent(v__ast__Scope* s) {
	bool _t1 = isnil(s->parent) || s->detached_from_parent;
	return _t1;
}

Option_v__ast__ScopeObject v__ast__Scope_find(v__ast__Scope* s, string name) {
	for (v__ast__Scope* sc = s; true; sc = sc->parent) {
		if (_IN_MAP(ADDR(string, name), ADDR(map, sc->objects))) {
			Option_v__ast__ScopeObject _t1;
			opt_ok(&(v__ast__ScopeObject[]) { (*(v__ast__ScopeObject*)map_get(ADDR(map, sc->objects), &(string[]){name}, &(v__ast__ScopeObject[]){ {0} })) }, (Option*)(&_t1), sizeof(v__ast__ScopeObject));
			return _t1;
		}
		if (v__ast__Scope_dont_lookup_parent(sc)) {
			break;
		}
	}
	return (Option_v__ast__ScopeObject){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
}

Option_v__ast__ScopeStructField v__ast__Scope_find_struct_field(v__ast__Scope* s, string name, v__ast__Type struct_type, string field_name) {
	for (v__ast__Scope* sc = s; true; sc = sc->parent) {
		v__ast__ScopeStructField* _t2 = (v__ast__ScopeStructField*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, sc->struct_fields), &(string[]){name}));
		Option_v__ast__ScopeStructField _t1 = {0};
		if (_t2) {
			*((v__ast__ScopeStructField*)&_t1.data) = *((v__ast__ScopeStructField*)_t2);
		} else {
			_t1.state = 2; _t1.err = _v_error(_SLIT("array index out of range"));
		}
		
		if (_t1.state == 0) {
			v__ast__ScopeStructField field = *(v__ast__ScopeStructField*)_t1.data;
			if (v__ast__Type_alias_eq(field.struct_type, struct_type) && string__eq(field.name, field_name)) {
				Option_v__ast__ScopeStructField _t3;
				opt_ok(&(v__ast__ScopeStructField[]) { field }, (Option*)(&_t3), sizeof(v__ast__ScopeStructField));
				return _t3;
			}
		}
		if (v__ast__Scope_dont_lookup_parent(sc)) {
			break;
		}
	}
	return (Option_v__ast__ScopeStructField){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
}

Option_v__ast__Var_ptr v__ast__Scope_find_var(v__ast__Scope* s, string name) {
	Option_v__ast__ScopeObject _t1;
	if (_t1 = v__ast__Scope_find(s, name), _t1.state == 0) {
		v__ast__ScopeObject* obj = HEAP(v__ast__ScopeObject, *(v__ast__ScopeObject*)_t1.data);
		if ((*(obj))._typ == 357 /* v.ast.Var */) {
			Option_v__ast__Var_ptr _t2;
			opt_ok(&(v__ast__Var*[]) { &(*((obj->_v__ast__Var))) }, (Option*)(&_t2), sizeof(v__ast__Var*));
			return _t2;
		}
		
		else {
		}
		;
	}
	return (Option_v__ast__Var_ptr){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
}

Option_v__ast__GlobalField_ptr v__ast__Scope_find_global(v__ast__Scope* s, string name) {
	Option_v__ast__ScopeObject _t1;
	if (_t1 = v__ast__Scope_find(s, name), _t1.state == 0) {
		v__ast__ScopeObject* obj = HEAP(v__ast__ScopeObject, *(v__ast__ScopeObject*)_t1.data);
		if ((*(obj))._typ == 356 /* v.ast.GlobalField */) {
			Option_v__ast__GlobalField_ptr _t2;
			opt_ok(&(v__ast__GlobalField*[]) { &(*((obj->_v__ast__GlobalField))) }, (Option*)(&_t2), sizeof(v__ast__GlobalField*));
			return _t2;
		}
		
		else {
		}
		;
	}
	return (Option_v__ast__GlobalField_ptr){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
}

Option_v__ast__ConstField_ptr v__ast__Scope_find_const(v__ast__Scope* s, string name) {
	Option_v__ast__ScopeObject _t1;
	if (_t1 = v__ast__Scope_find(s, name), _t1.state == 0) {
		v__ast__ScopeObject* obj = HEAP(v__ast__ScopeObject, *(v__ast__ScopeObject*)_t1.data);
		if ((*(obj))._typ == 355 /* v.ast.ConstField */) {
			Option_v__ast__ConstField_ptr _t2;
			opt_ok(&(v__ast__ConstField*[]) { &(*((obj->_v__ast__ConstField))) }, (Option*)(&_t2), sizeof(v__ast__ConstField*));
			return _t2;
		}
		
		else {
		}
		;
	}
	return (Option_v__ast__ConstField_ptr){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
}

bool v__ast__Scope_known_var(v__ast__Scope* s, string name) {
	Option_v__ast__Var_ptr _t1 = v__ast__Scope_find_var(s, name);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		bool _t2 = false;
		return _t2;
	}
	
  (*(v__ast__Var**)_t1.data);
	bool _t3 = true;
	return _t3;
}

bool v__ast__Scope_known_const(v__ast__Scope* s, string name) {
	Option_v__ast__ConstField_ptr _t1 = v__ast__Scope_find_const(s, name);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		bool _t2 = false;
		return _t2;
	}
	
  (*(v__ast__ConstField**)_t1.data);
	bool _t3 = true;
	return _t3;
}

void v__ast__Scope_update_var_type(v__ast__Scope* s, string name, v__ast__Type typ) {
	v__ast__ScopeObject obj = (*(v__ast__ScopeObject*)map_get(ADDR(map, s->objects), &(string[]){name}, &(v__ast__ScopeObject[]){ {0} }));
	if ((obj)._typ == 357 /* v.ast.Var */) {
		if (!v__ast__Type_alias_eq((*obj._v__ast__Var).typ, typ)) {
			(*obj._v__ast__Var).typ = typ;
		}
	}
}

void v__ast__Scope_register_struct_field(v__ast__Scope* s, string name, v__ast__ScopeStructField field) {
	v__ast__ScopeStructField* _t2 = (v__ast__ScopeStructField*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, s->struct_fields), &(string[]){name}));
	Option_v__ast__ScopeStructField _t1 = {0};
	if (_t2) {
		*((v__ast__ScopeStructField*)&_t1.data) = *((v__ast__ScopeStructField*)_t2);
	} else {
		_t1.state = 2; _t1.err = _v_error(_SLIT("array index out of range"));
	}
	
	if (_t1.state == 0) {
		v__ast__ScopeStructField f = *(v__ast__ScopeStructField*)_t1.data;
		if (v__ast__Type_alias_eq(f.struct_type, field.struct_type) && string__eq(f.name, field.name)) {
			return;
		}
	}
	(*(v__ast__ScopeStructField*)map_get_and_set((map*)&s->struct_fields, &(string[]){name}, &(v__ast__ScopeStructField[]){ (v__ast__ScopeStructField){.struct_type = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.typ = 0,.smartcasts = __new_array(0, 0, sizeof(v__ast__Type)),.orig_type = 0,} })) = field;
}

void v__ast__Scope_register(v__ast__Scope* s, v__ast__ScopeObject obj) {
	if (string__eq((*(obj.name)), _SLIT("_")) || _IN_MAP(ADDR(string, (*(obj.name))), ADDR(map, s->objects))) {
		return;
	}
	map_set(&s->objects, &(string[]){(*(obj.name))}, &(v__ast__ScopeObject[]) { obj });
}

v__ast__Scope* v__ast__Scope_innermost(v__ast__Scope* s, int pos) {
	if (v__ast__Scope_contains(s, pos)) {
		int first = 0;
		int last = s->children.len - 1;
		int middle = last / 2;
		for (;;) {
			if (!(first <= last)) break;
			v__ast__Scope* s1 = (*(v__ast__Scope**)/*ee elem_typ */array_get(s->children, middle));
			if (s1->end_pos < pos) {
				first = middle + 1;
			} else if (v__ast__Scope_contains(s1, pos)) {
				v__ast__Scope* _t1 = v__ast__Scope_innermost(s1, pos);
				return _t1;
			} else {
				last = middle - 1;
			}
			middle = (first + last) / 2;
			if (first > last) {
				break;
			}
		}
		v__ast__Scope* _t2 = s;
		return _t2;
	}
	v__ast__Scope* _t3 = s;
	return _t3;
}

// Attr: [inline]
inline bool v__ast__Scope_contains(v__ast__Scope* s, int pos) {
	bool _t1 = pos >= s->start_pos && pos <= s->end_pos;
	return _t1;
}

bool v__ast__Scope_has_inherited_vars(v__ast__Scope* s) {
	Map_string_v__ast__ScopeObject _t1 = s->objects;
	int _t3 = _t1.key_values.len;
	for (int _t2 = 0; _t2 < _t3; ++_t2 ) {
		int _t4 = _t1.key_values.len - _t3;
		_t3 = _t1.key_values.len;
		if (_t4 < 0) {
			_t2 = -1;
			continue;
		}
		if (!DenseArray_has_index(&_t1.key_values, _t2)) {continue;}
		v__ast__ScopeObject obj = (*(v__ast__ScopeObject*)DenseArray_value(&_t1.key_values, _t2));
		if ((obj)._typ == 357 /* v.ast.Var */) {
			if ((*obj._v__ast__Var).is_inherited) {
				bool _t5 = true;
				return _t5;
			}
		}
	}
	bool _t6 = false;
	return _t6;
}

string v__ast__Scope_show(v__ast__Scope _v_toheap_sc, int depth, int max_depth) {
v__ast__Scope* sc = HEAP(v__ast__Scope, _v_toheap_sc);
	string out = _SLIT("");
	string indent = _SLIT("");
	for (int _t1 = 0; _t1 < depth * 4; ++_t1) {
		indent = /*f*/string__plus(indent, _SLIT(" "));
	}
	out = /*f*/string__plus(out,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = indent}}, {_SLIT("# "), 0xfe07, {.d_i32 = (*(sc)).start_pos}}, {_SLIT(" - "), 0xfe07, {.d_i32 = (*(sc)).end_pos}}, {_SLIT("\n"), 0, { .d_c = 0 }}})));
	Map_string_v__ast__ScopeObject _t2 = (*(sc)).objects;
	int _t4 = _t2.key_values.len;
	for (int _t3 = 0; _t3 < _t4; ++_t3 ) {
		int _t5 = _t2.key_values.len - _t4;
		_t4 = _t2.key_values.len;
		if (_t5 < 0) {
			_t3 = -1;
			continue;
		}
		if (!DenseArray_has_index(&_t2.key_values, _t3)) {continue;}
		v__ast__ScopeObject obj = (*(v__ast__ScopeObject*)DenseArray_value(&_t2.key_values, _t3));
		if (obj._typ == 355 /* v.ast.ConstField */) {
			out = /*f*/string__plus(out,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = indent}}, {_SLIT("  * const: "), 0xfe10, {.d_s = (*obj._v__ast__ConstField).name}}, {_SLIT(" - "), 0xfe07, {.d_i32 = (*obj._v__ast__ConstField).typ}}, {_SLIT("\n"), 0, { .d_c = 0 }}})));
		}
		else if (obj._typ == 357 /* v.ast.Var */) {
			out = /*f*/string__plus(out,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = indent}}, {_SLIT("  * var: "), 0xfe10, {.d_s = (*obj._v__ast__Var).name}}, {_SLIT(" - "), 0xfe07, {.d_i32 = (*obj._v__ast__Var).typ}}, {_SLIT("\n"), 0, { .d_c = 0 }}})));
		}
		
		else {
		}
		;
	}
	Map_string_v__ast__ScopeStructField _t6 = (*(sc)).struct_fields;
	int _t8 = _t6.key_values.len;
	for (int _t7 = 0; _t7 < _t8; ++_t7 ) {
		int _t9 = _t6.key_values.len - _t8;
		_t8 = _t6.key_values.len;
		if (_t9 < 0) {
			_t7 = -1;
			continue;
		}
		if (!DenseArray_has_index(&_t6.key_values, _t7)) {continue;}
		v__ast__ScopeStructField field = (*(v__ast__ScopeStructField*)DenseArray_value(&_t6.key_values, _t7));
		out = /*f*/string__plus(out,  str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = indent}}, {_SLIT("  * struct_field: "), 0xfe07, {.d_i32 = field.struct_type}}, {_SLIT(" "), 0xfe10, {.d_s = field.name}}, {_SLIT(" - "), 0xfe07, {.d_i32 = field.typ}}, {_SLIT("\n"), 0, { .d_c = 0 }}})));
	}
	if (max_depth == 0 || depth < max_depth - 1) {
		for (int i = 0; i < (*(sc)).children.len; ++i) {
			out = /*f*/string__plus(out, v__ast__Scope_show(/*rec*/*(*(v__ast__Scope**)/*ee elem_typ */array_get((*(sc)).children, i)), depth + 1, max_depth));
		}
	}
	string _t10 = out;
	return _t10;
}

string v__ast__Scope_str(v__ast__Scope _v_toheap_sc) {
v__ast__Scope* sc = HEAP(v__ast__Scope, _v_toheap_sc);
	string _t1 = v__ast__Scope_show((*(sc)), 0, 0);
	return _t1;
}

string v__ast__FnDecl_modname(v__ast__FnDecl* node) {
	if ((node->mod).len != 0) {
		string _t1 = node->mod;
		return _t1;
	}
	string pamod = string_all_before_last(node->name, _SLIT("."));
	if (string__eq(pamod, string_after(node->name, _SLIT(".")))) {
		pamod = (node->is_builtin ? (_SLIT("builtin")) : (_SLIT("main")));
	}
	string _t2 = pamod;
	return _t2;
}

string v__ast__FnDecl_fkey(v__ast__FnDecl* node) {
	if (node->is_method) {
		string _t1 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = ((int)(node->receiver.typ))}}, {_SLIT("."), 0xfe10, {.d_s = node->name}}, {_SLIT0, 0, { .d_c = 0 }}}));
		return _t1;
	}
	string _t2 = node->name;
	return _t2;
}

string v__ast__Fn_fkey(v__ast__Fn* node) {
	if (node->is_method) {
		string _t1 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = ((int)(node->receiver_type))}}, {_SLIT("."), 0xfe10, {.d_s = node->name}}, {_SLIT0, 0, { .d_c = 0 }}}));
		return _t1;
	}
	string _t2 = node->name;
	return _t2;
}

string v__ast__CallExpr_fkey(v__ast__CallExpr* node) {
	if (node->is_method) {
		string _t1 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = ((int)(node->receiver_type))}}, {_SLIT("."), 0xfe10, {.d_s = node->name}}, {_SLIT0, 0, { .d_c = 0 }}}));
		return _t1;
	}
	string _t2 = node->name;
	return _t2;
}

string v__ast__AnonFn_stringify(v__ast__AnonFn* node, v__ast__Table* t, string cur_mod, Map_string_string m2a) {
	strings__Builder f = strings__new_builder(30);
	strings__Builder_write_string(&f, _SLIT("fn "));
	if (node->inherited_vars.len > 0) {
		strings__Builder_write_string(&f, _SLIT("["));
		for (int i = 0; i < node->inherited_vars.len; ++i) {
			v__ast__Param var = ((v__ast__Param*)node->inherited_vars.data)[i];
			if (i > 0) {
				strings__Builder_write_string(&f, _SLIT(", "));
			}
			if (var.is_mut) {
				strings__Builder_write_string(&f, _SLIT("mut "));
			}
			strings__Builder_write_string(&f, var.name);
		}
		strings__Builder_write_string(&f, _SLIT("] "));
	}
	v__ast__stringify_fn_after_name((voidptr)&/*qq*/node->decl, (voidptr)&/*qq*/f, t, cur_mod, m2a);
	string _t1 = strings__Builder_str(&f);
	return _t1;
}

string v__ast__FnDecl_stringify(v__ast__FnDecl* node, v__ast__Table* t, string cur_mod, Map_string_string m2a) {
	strings__Builder f = strings__new_builder(30);
	if (node->is_pub) {
		strings__Builder_write_string(&f, _SLIT("pub "));
	}
	strings__Builder_write_string(&f, _SLIT("fn "));
	if (node->is_method) {
		strings__Builder_write_string(&f, _SLIT("("));
		string styp = v__util__no_cur_mod(v__ast__Table_type_to_code(t, v__ast__Type_clear_flag(node->receiver.typ, v__ast__TypeFlag__shared_f)), cur_mod);
		if (node->rec_mut) {
			strings__Builder_write_string(&f, string__plus(v__ast__ShareType_str(v__ast__Type_share(node->receiver.typ)), _SLIT(" ")));
			styp = string_substr(styp, 1, styp.len);
		}
		strings__Builder_write_string(&f, string__plus(node->receiver.name, _SLIT(" ")));
		styp = v__util__no_cur_mod(styp, cur_mod);
		if ((*(v__ast__Param*)/*ee elem_typ */array_get(node->params, 0)).is_auto_rec) {
			styp = string_trim(styp, _SLIT("&"));
		}
		strings__Builder_write_string(&f, string__plus(styp, _SLIT(") ")));
	}
	string name = (!node->is_method && node->language == v__ast__Language__v ? (string_all_after_last(node->name, _SLIT("."))) : (node->name));
	strings__Builder_write_string(&f, name);
	if (string__eq(name, _SLIT("+")) || string__eq(name, _SLIT("-")) || string__eq(name, _SLIT("*")) || string__eq(name, _SLIT("/")) || string__eq(name, _SLIT("%")) || string__eq(name, _SLIT("<")) || string__eq(name, _SLIT(">")) || string__eq(name, _SLIT("==")) || string__eq(name, _SLIT("!=")) || string__eq(name, _SLIT(">=")) || string__eq(name, _SLIT("<="))) {
		strings__Builder_write_string(&f, _SLIT(" "));
	}
	v__ast__stringify_fn_after_name(node, (voidptr)&/*qq*/f, t, cur_mod, m2a);
	string _t1 = strings__Builder_str(&f);
	return _t1;
}

VV_LOCAL_SYMBOL void v__ast__stringify_fn_after_name(v__ast__FnDecl* node, strings__Builder* f, v__ast__Table* t, string cur_mod, Map_string_string m2a) {
	bool add_para_types = true;
	if (node->generic_names.len > 0) {
		if (node->is_method) {
			v__ast__TypeSymbol* sym = v__ast__Table_sym(t, (*(v__ast__Param*)/*ee elem_typ */array_get(node->params, 0)).typ);
			if ((sym->info)._typ == 446 /* v.ast.Struct */) {
				Array_string _t1 = __new_array(0, 0, sizeof(string));
				Array_v__ast__Type _t1_orig = (*sym->info._v__ast__Struct).generic_types;
				int _t1_len = _t1_orig.len;
				_t1 = __new_array(0, _t1_len, sizeof(string));

				for (int _t2 = 0; _t2 < _t1_len; ++_t2) {
					v__ast__Type it = ((v__ast__Type*) _t1_orig.data)[_t2];
					string ti = v__ast__Table_sym(t, it)->name;
					array_push((array*)&_t1, &ti);
				}
				Array_string generic_names =_t1;
				if (Array_string_arr_eq(generic_names, node->generic_names)) {
					add_para_types = false;
				}
			}
		}
		if (add_para_types) {
			strings__Builder_write_string(f, _SLIT("<"));
			for (int i = 0; i < node->generic_names.len; ++i) {
				string gname = ((string*)node->generic_names.data)[i];
				bool is_last = i == node->generic_names.len - 1;
				strings__Builder_write_string(f, gname);
				if (!is_last) {
					strings__Builder_write_string(f, _SLIT(", "));
				}
			}
			strings__Builder_write_string(f, _SLIT(">"));
		}
	}
	strings__Builder_write_string(f, _SLIT("("));
	for (int i = 0; i < node->params.len; ++i) {
		v__ast__Param arg = ((v__ast__Param*)node->params.data)[i];
		if (node->is_method && i == 0) {
			continue;
		}
		if (arg.is_hidden) {
			continue;
		}
		bool is_last_arg = i == node->params.len - 1;
		bool is_type_only = (arg.name).len == 0;
		bool should_add_type = true;
		if (arg.is_mut) {
			strings__Builder_write_string(f, string__plus(v__ast__ShareType_str(v__ast__Type_share(arg.typ)), _SLIT(" ")));
		}
		strings__Builder_write_string(f, arg.name);
		string s = v__ast__Table_type_to_str(t, v__ast__Type_clear_flag(arg.typ, v__ast__TypeFlag__shared_f));
		if (arg.is_mut) {
			v__ast__TypeSymbol* arg_sym = v__ast__Table_sym(t, arg.typ);
			if (string_starts_with(s, _SLIT("&")) && ((!v__ast__TypeSymbol_is_number(arg_sym) && arg_sym->kind != v__ast__Kind__bool) || node->language != v__ast__Language__v)) {
				s = string_substr(s, 1, s.len);
			}
		}
		s = v__util__no_cur_mod(s, cur_mod);
		int _t4 = m2a.key_values.len;
		for (int _t3 = 0; _t3 < _t4; ++_t3 ) {
			int _t5 = m2a.key_values.len - _t4;
			_t4 = m2a.key_values.len;
			if (_t5 < 0) {
				_t3 = -1;
				continue;
			}
			if (!DenseArray_has_index(&m2a.key_values, _t3)) {continue;}
			string mod = /*key*/ *(string*)DenseArray_key(&m2a.key_values, _t3);
			mod = string_clone(mod);
			string alias = (*(string*)DenseArray_value(&m2a.key_values, _t3));
			s = string_replace(s, mod, alias);
		}
		if (should_add_type) {
			if (!is_type_only) {
				strings__Builder_write_string(f, _SLIT(" "));
			}
			if (node->is_variadic && is_last_arg) {
				strings__Builder_write_string(f, _SLIT("..."));
			}
			strings__Builder_write_string(f, s);
		}
		if (!is_last_arg) {
			strings__Builder_write_string(f, _SLIT(", "));
		}
	}
	strings__Builder_write_string(f, _SLIT(")"));
	if (!v__ast__Type_alias_eq(node->return_type, _const_v__ast__void_type)) {
		string rs = v__util__no_cur_mod(v__ast__Table_type_to_str(t, node->return_type), cur_mod);
		int _t7 = m2a.key_values.len;
		for (int _t6 = 0; _t6 < _t7; ++_t6 ) {
			int _t8 = m2a.key_values.len - _t7;
			_t7 = m2a.key_values.len;
			if (_t8 < 0) {
				_t6 = -1;
				continue;
			}
			if (!DenseArray_has_index(&m2a.key_values, _t6)) {continue;}
			string mod = /*key*/ *(string*)DenseArray_key(&m2a.key_values, _t6);
			mod = string_clone(mod);
			string alias = (*(string*)DenseArray_value(&m2a.key_values, _t6));
			rs = string_replace(rs, mod, alias);
		}
		strings__Builder_write_string(f, string__plus(_SLIT(" "), rs));
	}
}

multi_return_string_bool v__ast__StringInterLiteral_get_fspec_braces(v__ast__StringInterLiteral* lit, int i) {
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	bool needs_fspec = (*(bool*)/*ee elem_typ */array_get(lit->need_fmts, i)) || (*(bool*)/*ee elem_typ */array_get(lit->pluss, i)) || ((*(bool*)/*ee elem_typ */array_get(lit->fills, i)) && (*(int*)/*ee elem_typ */array_get(lit->fwidths, i)) >= 0) || (*(int*)/*ee elem_typ */array_get(lit->fwidths, i)) != 0 || (*(int*)/*ee elem_typ */array_get(lit->precisions, i)) != 987698;
	bool needs_braces = needs_fspec;
	string sx = v__ast__Expr_str((*(v__ast__Expr*)/*ee elem_typ */array_get(lit->exprs, i)));
	if (string_contains(sx, _SLIT("\"")) || string_contains(sx, _SLIT("'"))) {
		needs_braces = true;
	}
	if (!needs_braces) {
		if (i + 1 < lit->vals.len && (*(string*)/*ee elem_typ */array_get(lit->vals, i + 1)).len > 0) {
			byte next_char = string_at((*(string*)/*ee elem_typ */array_get(lit->vals, i + 1)), 0);
			if (v__util__is_func_char(next_char) || next_char == '.' || next_char == '(') {
				needs_braces = true;
			}
		}
	}
	if (!needs_braces) {
		v__ast__Expr sub_expr = (*(v__ast__Expr*)/*ee elem_typ */array_get(lit->exprs, i));
		for (;;) {
			if (sub_expr._typ == 299 /* v.ast.Ident */) {
				if (string_at((*sub_expr._v__ast__Ident).name, 0) == '@') {
					needs_braces = true;
				}
				break;
			}
			else if (sub_expr._typ == 286 /* v.ast.CallExpr */) {
				if ((*sub_expr._v__ast__CallExpr).args.len != 0 || (*sub_expr._v__ast__CallExpr).concrete_types.len != 0) {
					needs_braces = true;
				} else if (((*sub_expr._v__ast__CallExpr).left)._typ == 286 /* v.ast.CallExpr */) {
					sub_expr = (*sub_expr._v__ast__CallExpr).left;
					continue;
				} else if (((*sub_expr._v__ast__CallExpr).left)._typ == 287 /* v.ast.CastExpr */ || ((*sub_expr._v__ast__CallExpr).left)._typ == 302 /* v.ast.IndexExpr */) {
					needs_braces = true;
				}
				break;
			}
			else if (sub_expr._typ == 319 /* v.ast.SelectorExpr */) {
				if (string_at((*sub_expr._v__ast__SelectorExpr).field_name, 0) == '@') {
					needs_braces = true;
					break;
				}
				sub_expr = (*sub_expr._v__ast__SelectorExpr).expr;
				continue;
			}
			
			else {
				needs_braces = true;
				break;
			}
			;
		}
	}
	if (needs_fspec) {
		array_push((array*)&res, _MOV((string[]){ string_clone(_SLIT(":")) }));
		if ((*(bool*)/*ee elem_typ */array_get(lit->pluss, i))) {
			array_push((array*)&res, _MOV((string[]){ string_clone(_SLIT("+")) }));
		}
		if ((*(bool*)/*ee elem_typ */array_get(lit->fills, i)) && (*(int*)/*ee elem_typ */array_get(lit->fwidths, i)) >= 0) {
			array_push((array*)&res, _MOV((string[]){ string_clone(_SLIT("0")) }));
		}
		if ((*(int*)/*ee elem_typ */array_get(lit->fwidths, i)) != 0) {
			array_push((array*)&res, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = (*(int*)/*ee elem_typ */array_get(lit->fwidths, i))}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
		}
		if ((*(int*)/*ee elem_typ */array_get(lit->precisions, i)) != 987698) {
			array_push((array*)&res, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("."), 0xfe07, {.d_i32 = (*(int*)/*ee elem_typ */array_get(lit->precisions, i))}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
		}
		if ((*(bool*)/*ee elem_typ */array_get(lit->need_fmts, i))) {
			array_push((array*)&res, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe01, {.d_c = (*(byte*)/*ee elem_typ */array_get(lit->fmts, i))}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
		}
	}
	return (multi_return_string_bool){.arg0=Array_string_join(res, _SLIT("")), .arg1=needs_braces};
}

string v__ast__Expr_str(v__ast__Expr x) {
	if (x._typ == 278 /* v.ast.AnonFn */) {
		string _t1 = _SLIT("anon_fn");
		return _t1;
	}
	else if (x._typ == 294 /* v.ast.DumpExpr */) {
		string _t2 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("dump("), 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__DumpExpr).expr)}}, {_SLIT(")"), 0, { .d_c = 0 }}}));
		return _t2;
	}
	else if (x._typ == 280 /* v.ast.ArrayInit */) {
		Array_string fields = __new_array_with_default(0, 0, sizeof(string), 0);
		if ((*x._v__ast__ArrayInit).has_len) {
			array_push((array*)&fields, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("len: "), 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__ArrayInit).len_expr)}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
		}
		if ((*x._v__ast__ArrayInit).has_cap) {
			array_push((array*)&fields, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("cap: "), 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__ArrayInit).cap_expr)}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
		}
		if ((*x._v__ast__ArrayInit).has_default) {
			array_push((array*)&fields, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("init: "), 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__ArrayInit).default_expr)}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
		}
		if (fields.len > 0) {
			string _t6 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("[]T{"), 0xfe10, {.d_s = Array_string_join(fields, _SLIT(", "))}}, {_SLIT("}"), 0, { .d_c = 0 }}}));
			return _t6;
		} else {
			string _t7 = Array_v__ast__Expr_str((*x._v__ast__ArrayInit).exprs);
			return _t7;
		}
	}
	else if (x._typ == 281 /* v.ast.AsCast */) {
		string _t8 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__AsCast).expr)}}, {_SLIT(" as "), 0xfe10, {.d_s = v__ast__Table_type_to_str(global_table, (*x._v__ast__AsCast).typ)}}, {_SLIT0, 0, { .d_c = 0 }}}));
		return _t8;
	}
	else if (x._typ == 283 /* v.ast.AtExpr */) {
		string _t9 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = (*x._v__ast__AtExpr).val}}, {_SLIT0, 0, { .d_c = 0 }}}));
		return _t9;
	}
	else if (x._typ == 285 /* v.ast.CTempVar */) {
		string _t10 = v__ast__Expr_str((*x._v__ast__CTempVar).orig);
		return _t10;
	}
	else if (x._typ == 284 /* v.ast.BoolLiteral */) {
		string _t11 = bool_str((*x._v__ast__BoolLiteral).val);
		return _t11;
	}
	else if (x._typ == 287 /* v.ast.CastExpr */) {
		string _t12 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = (*x._v__ast__CastExpr).typname}}, {_SLIT("("), 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__CastExpr).expr)}}, {_SLIT(")"), 0, { .d_c = 0 }}}));
		return _t12;
	}
	else if (x._typ == 286 /* v.ast.CallExpr */) {
		string sargs = v__ast__args2str((*x._v__ast__CallExpr).args);
		string propagate_suffix = ((*x._v__ast__CallExpr).or_block.kind == v__ast__OrKind__propagate ? (_SLIT(" ?")) : (_SLIT("")));
		if ((*x._v__ast__CallExpr).is_method) {
			string _t13 =  str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__CallExpr).left)}}, {_SLIT("."), 0xfe10, {.d_s = (*x._v__ast__CallExpr).name}}, {_SLIT("("), 0xfe10, {.d_s = sargs}}, {_SLIT(")"), 0xfe10, {.d_s = propagate_suffix}}, {_SLIT0, 0, { .d_c = 0 }}}));
			return _t13;
		}
		if (string_starts_with((*x._v__ast__CallExpr).name,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = (*x._v__ast__CallExpr).mod}}, {_SLIT("."), 0, { .d_c = 0 }}})))) {
			string _t14 = v__util__strip_main_name( str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = (*x._v__ast__CallExpr).name}}, {_SLIT("("), 0xfe10, {.d_s = sargs}}, {_SLIT(")"), 0xfe10, {.d_s = propagate_suffix}}, {_SLIT0, 0, { .d_c = 0 }}})));
			return _t14;
		}
		if (((*x._v__ast__CallExpr).mod).len == 0 && ((*x._v__ast__CallExpr).name).len == 0) {
			string _t15 = string__plus(v__ast__Expr_str((*x._v__ast__CallExpr).left),  str_intp(3, _MOV((StrIntpData[]){{_SLIT("("), 0xfe10, {.d_s = sargs}}, {_SLIT(")"), 0xfe10, {.d_s = propagate_suffix}}, {_SLIT0, 0, { .d_c = 0 }}})));
			return _t15;
		}
		string _t16 =  str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = (*x._v__ast__CallExpr).mod}}, {_SLIT("."), 0xfe10, {.d_s = (*x._v__ast__CallExpr).name}}, {_SLIT("("), 0xfe10, {.d_s = sargs}}, {_SLIT(")"), 0xfe10, {.d_s = propagate_suffix}}, {_SLIT0, 0, { .d_c = 0 }}}));
		return _t16;
	}
	else if (x._typ == 289 /* v.ast.CharLiteral */) {
		string _t17 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = (*x._v__ast__CharLiteral).val}}, {_SLIT("`"), 0, { .d_c = 0 }}}));
		return _t17;
	}
	else if (x._typ == 290 /* v.ast.Comment */) {
		if ((*x._v__ast__Comment).is_multi) {
			Array_string lines = string_split_into_lines((*x._v__ast__Comment).text);
			string _t18 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("/* "), 0xfe07, {.d_i32 = lines.len}}, {_SLIT(" lines comment */"), 0, { .d_c = 0 }}}));
			return _t18;
		} else {
			string text = string_trim_space(string_trim((*x._v__ast__Comment).text, _SLIT("\x01")));
			string _t19 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("´// "), 0xfe10, {.d_s = text}}, {_SLIT("´"), 0, { .d_c = 0 }}}));
			return _t19;
		}
	}
	else if (x._typ == 292 /* v.ast.ComptimeSelector */) {
		string _t20 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__ComptimeSelector).left)}}, {_SLIT(".$"), 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__ComptimeSelector).field_expr)}}, {_SLIT0, 0, { .d_c = 0 }}}));
		return _t20;
	}
	else if (x._typ == 293 /* v.ast.ConcatExpr */) {
		Array_string _t22 = __new_array(0, 0, sizeof(string));
		Array_v__ast__Expr _t22_orig = (*x._v__ast__ConcatExpr).vals;
		int _t22_len = _t22_orig.len;
		_t22 = __new_array(0, _t22_len, sizeof(string));

		for (int _t23 = 0; _t23 < _t22_len; ++_t23) {
			v__ast__Expr it = ((v__ast__Expr*) _t22_orig.data)[_t23];
			string ti = v__ast__Expr_str(it);
			array_push((array*)&_t22, &ti);
		}
		string _t21 = Array_string_join(_t22, _SLIT(","));
		return _t21;
	}
	else if (x._typ == 296 /* v.ast.EnumVal */) {
		string _t24 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("."), 0xfe10, {.d_s = (*x._v__ast__EnumVal).val}}, {_SLIT0, 0, { .d_c = 0 }}}));
		return _t24;
	}
	else if (x._typ == 297 /* v.ast.FloatLiteral */) {
		string _t25 = (*x._v__ast__FloatLiteral).val;
		return _t25;
	}
	else if (x._typ == 304 /* v.ast.IntegerLiteral */) {
		string _t26 = (*x._v__ast__IntegerLiteral).val;
		return _t26;
	}
	else if (x._typ == 298 /* v.ast.GoExpr */) {
		string _t27 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("go "), 0xfe10, {.d_s = v__ast__CallExpr_str((*x._v__ast__GoExpr).call_expr)}}, {_SLIT0, 0, { .d_c = 0 }}}));
		return _t27;
	}
	else if (x._typ == 299 /* v.ast.Ident */) {
		string _t28 = (*x._v__ast__Ident).name;
		return _t28;
	}
	else if (x._typ == 300 /* v.ast.IfExpr */) {
		Array_string parts = __new_array_with_default(0, 0, sizeof(string), 0);
		string dollar = ((*x._v__ast__IfExpr).is_comptime ? (_SLIT("$")) : (_SLIT("")));
		for (int i = 0; i < (*x._v__ast__IfExpr).branches.len; ++i) {
			v__ast__IfBranch branch = ((v__ast__IfBranch*)(*x._v__ast__IfExpr).branches.data)[i];
			if (i != 0) {
				array_push((array*)&parts, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT(" } "), 0xfe10, {.d_s = dollar}}, {_SLIT("else "), 0, { .d_c = 0 }}}))) }));
			}
			if (i < (*x._v__ast__IfExpr).branches.len - 1 || !(*x._v__ast__IfExpr).has_else) {
				array_push((array*)&parts, _MOV((string[]){ string_clone(string__plus(string__plus( str_intp(2, _MOV((StrIntpData[]){{_SLIT(" "), 0xfe10, {.d_s = dollar}}, {_SLIT("if "), 0, { .d_c = 0 }}})), v__ast__Expr_str(branch.cond)), _SLIT(" { "))) }));
			}
			for (int _t31 = 0; _t31 < branch.stmts.len; ++_t31) {
				v__ast__Stmt stmt = ((v__ast__Stmt*)branch.stmts.data)[_t31];
				array_push((array*)&parts, _MOV((string[]){ string_clone(v__ast__Stmt_str(stmt)) }));
			}
		}
		array_push((array*)&parts, _MOV((string[]){ string_clone(_SLIT(" }")) }));
		string _t34 = Array_string_join(parts, _SLIT(""));
		return _t34;
	}
	else if (x._typ == 302 /* v.ast.IndexExpr */) {
		string _t35 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__IndexExpr).left)}}, {_SLIT("["), 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__IndexExpr).index)}}, {_SLIT("]"), 0, { .d_c = 0 }}}));
		return _t35;
	}
	else if (x._typ == 303 /* v.ast.InfixExpr */) {
		string _t36 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__InfixExpr).left)}}, {_SLIT(" "), 0xfe10, {.d_s = v__token__Kind_str((*x._v__ast__InfixExpr).op)}}, {_SLIT(" "), 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__InfixExpr).right)}}, {_SLIT0, 0, { .d_c = 0 }}}));
		return _t36;
	}
	else if (x._typ == 308 /* v.ast.MapInit */) {
		Array_string pairs = __new_array_with_default(0, 0, sizeof(string), 0);
		for (int ik = 0; ik < (*x._v__ast__MapInit).keys.len; ++ik) {
			v__ast__Expr kv = ((v__ast__Expr*)(*x._v__ast__MapInit).keys.data)[ik];
			string mv = v__ast__Expr_str((*(v__ast__Expr*)/*ee elem_typ */array_get((*x._v__ast__MapInit).vals, ik)));
			array_push((array*)&pairs, _MOV((string[]){ string_clone( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__ast__Expr_str(kv)}}, {_SLIT(": "), 0xfe10, {.d_s = mv}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
		}
		string _t38 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("map{ "), 0xfe10, {.d_s = Array_string_join(pairs, _SLIT(" "))}}, {_SLIT(" }"), 0, { .d_c = 0 }}}));
		return _t38;
	}
	else if (x._typ == 314 /* v.ast.ParExpr */) {
		string _t39 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("("), 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__ParExpr).expr)}}, {_SLIT(")"), 0, { .d_c = 0 }}}));
		return _t39;
	}
	else if (x._typ == 315 /* v.ast.PostfixExpr */) {
		if ((*x._v__ast__PostfixExpr).op == v__token__Kind__question) {
			string _t40 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__PostfixExpr).expr)}}, {_SLIT(" ?"), 0, { .d_c = 0 }}}));
			return _t40;
		}
		string _t41 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__PostfixExpr).expr)}}, {_SLIT0, 0xfe10, {.d_s = v__token__Kind_str((*x._v__ast__PostfixExpr).op)}}, {_SLIT0, 0, { .d_c = 0 }}}));
		return _t41;
	}
	else if (x._typ == 316 /* v.ast.PrefixExpr */) {
		string _t42 = string__plus(v__token__Kind_str((*x._v__ast__PrefixExpr).op), v__ast__Expr_str((*x._v__ast__PrefixExpr).right));
		return _t42;
	}
	else if (x._typ == 317 /* v.ast.RangeExpr */) {
		string s = _SLIT("..");
		if ((*x._v__ast__RangeExpr).has_low) {
			s = string__plus( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__RangeExpr).low)}}, {_SLIT(" "), 0, { .d_c = 0 }}})), s);
		}
		if ((*x._v__ast__RangeExpr).has_high) {
			s = string__plus(s,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(" "), 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__RangeExpr).high)}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		string _t43 = s;
		return _t43;
	}
	else if (x._typ == 318 /* v.ast.SelectExpr */) {
		string _t44 = _SLIT("ast.SelectExpr");
		return _t44;
	}
	else if (x._typ == 319 /* v.ast.SelectorExpr */) {
		string _t45 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__SelectorExpr).expr)}}, {_SLIT("."), 0xfe10, {.d_s = (*x._v__ast__SelectorExpr).field_name}}, {_SLIT0, 0, { .d_c = 0 }}}));
		return _t45;
	}
	else if (x._typ == 320 /* v.ast.SizeOf */) {
		if ((*x._v__ast__SizeOf).is_type) {
			string _t46 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("sizeof("), 0xfe10, {.d_s = v__ast__Table_type_to_str(global_table, (*x._v__ast__SizeOf).typ)}}, {_SLIT(")"), 0, { .d_c = 0 }}}));
			return _t46;
		}
		string _t47 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("sizeof("), 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__SizeOf).expr)}}, {_SLIT(")"), 0, { .d_c = 0 }}}));
		return _t47;
	}
	else if (x._typ == 312 /* v.ast.OffsetOf */) {
		string _t48 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("__offsetof("), 0xfe10, {.d_s = v__ast__Table_type_to_str(global_table, (*x._v__ast__OffsetOf).struct_type)}}, {_SLIT(", "), 0xfe10, {.d_s = (*x._v__ast__OffsetOf).field}}, {_SLIT(")"), 0, { .d_c = 0 }}}));
		return _t48;
	}
	else if (x._typ == 322 /* v.ast.StringInterLiteral */) {
		strings__Builder res = strings__new_builder(50);
		strings__Builder_write_string(&res, _SLIT("'"));
		for (int i = 0; i < (*x._v__ast__StringInterLiteral).vals.len; ++i) {
			string val = ((string*)(*x._v__ast__StringInterLiteral).vals.data)[i];
			strings__Builder_write_string(&res, val);
			if (i >= (*x._v__ast__StringInterLiteral).exprs.len) {
				break;
			}
			strings__Builder_write_string(&res, _SLIT("$"));
			multi_return_string_bool mr_9917 = v__ast__StringInterLiteral_get_fspec_braces(&(*x._v__ast__StringInterLiteral), i);
			string fspec_str = mr_9917.arg0;
			bool needs_braces = mr_9917.arg1;
			if (needs_braces) {
				strings__Builder_write_string(&res, _SLIT("{"));
				strings__Builder_write_string(&res, v__ast__Expr_str((*(v__ast__Expr*)/*ee elem_typ */array_get((*x._v__ast__StringInterLiteral).exprs, i))));
				strings__Builder_write_string(&res, fspec_str);
				strings__Builder_write_string(&res, _SLIT("}"));
			} else {
				strings__Builder_write_string(&res, v__ast__Expr_str((*(v__ast__Expr*)/*ee elem_typ */array_get((*x._v__ast__StringInterLiteral).exprs, i))));
			}
		}
		strings__Builder_write_string(&res, _SLIT("'"));
		string _t49 = strings__Builder_str(&res);
		return _t49;
	}
	else if (x._typ == 323 /* v.ast.StringLiteral */) {
		string _t50 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("'"), 0xfe10, {.d_s = (*x._v__ast__StringLiteral).val}}, {_SLIT("'"), 0, { .d_c = 0 }}}));
		return _t50;
	}
	else if (x._typ == 325 /* v.ast.TypeNode */) {
		string _t51 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("TypeNode("), 0xfe07, {.d_i32 = (*x._v__ast__TypeNode).typ}}, {_SLIT(")"), 0, { .d_c = 0 }}}));
		return _t51;
	}
	else if (x._typ == 326 /* v.ast.TypeOf */) {
		string _t52 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("typeof("), 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__TypeOf).expr)}}, {_SLIT(")"), 0, { .d_c = 0 }}}));
		return _t52;
	}
	else if (x._typ == 306 /* v.ast.Likely */) {
		string _t53 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("_likely_("), 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__Likely).expr)}}, {_SLIT(")"), 0, { .d_c = 0 }}}));
		return _t53;
	}
	else if (x._typ == 327 /* v.ast.UnsafeExpr */) {
		string _t54 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unsafe { "), 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__UnsafeExpr).expr)}}, {_SLIT(" }"), 0, { .d_c = 0 }}}));
		return _t54;
	}
	else if (x._typ == 311 /* v.ast.None */) {
		string _t55 = _SLIT("none");
		return _t55;
	}
	else if (x._typ == 305 /* v.ast.IsRefType */) {
		string _t56 = string__plus(string__plus(_SLIT("isreftype("), ((*x._v__ast__IsRefType).is_type ? (v__ast__Table_type_to_str(global_table, (*x._v__ast__IsRefType).typ)) : (v__ast__Expr_str((*x._v__ast__IsRefType).expr)))), _SLIT(")"));
		return _t56;
	}
	else if (x._typ == 301 /* v.ast.IfGuardExpr */) {
		string _t57 = string__plus(string__plus((*x._v__ast__IfGuardExpr).var_name, _SLIT(" := ")), v__ast__Expr_str((*x._v__ast__IfGuardExpr).expr));
		return _t57;
	}
	else if (x._typ == 324 /* v.ast.StructInit */) {
		string sname = v__ast__Table_sym(global_table, (*x._v__ast__StructInit).typ)->name;
		string _t58 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = sname}}, {_SLIT("{....}"), 0, { .d_c = 0 }}}));
		return _t58;
	}
	else if (x._typ == 279 /* v.ast.ArrayDecompose */) {
		string _t59 = _SLIT("ast.ArrayDecompose");
		return _t59;
	}
	else if (x._typ == 282 /* v.ast.Assoc */) {
		string _t60 = _SLIT("ast.Assoc");
		return _t60;
	}
	else if (x._typ == 288 /* v.ast.ChanInit */) {
		string _t61 = _SLIT("ast.ChanInit");
		return _t61;
	}
	else if (x._typ == 291 /* v.ast.ComptimeCall */) {
		string _t62 = _SLIT("ast.ComptimeCall");
		return _t62;
	}
	else if (x._typ == 295 /* v.ast.EmptyExpr */) {
		string _t63 = _SLIT("ast.EmptyExpr");
		return _t63;
	}
	else if (x._typ == 307 /* v.ast.LockExpr */) {
		string _t64 = _SLIT("ast.LockExpr");
		return _t64;
	}
	else if (x._typ == 309 /* v.ast.MatchExpr */) {
		string _t65 = _SLIT("ast.MatchExpr");
		return _t65;
	}
	else if (x._typ == 310 /* v.ast.NodeError */) {
		string _t66 = _SLIT("ast.NodeError");
		return _t66;
	}
	else if (x._typ == 313 /* v.ast.OrExpr */) {
		string _t67 = _SLIT("ast.OrExpr");
		return _t67;
	}
	else if (x._typ == 321 /* v.ast.SqlExpr */) {
		string _t68 = _SLIT("ast.SqlExpr");
		return _t68;
	}
	;
	string _t69 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("[unhandled expr type "), 0xfe10, {.d_s = charptr_vstring_literal( /* v.ast.Expr */ v_typeof_sumtype_v__ast__Expr( (x)._typ ))}}, {_SLIT("]"), 0, { .d_c = 0 }}}));
	return _t69;
}

string v__ast__CallArg_str(v__ast__CallArg a) {
	if (a.is_mut) {
		string _t1 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("mut "), 0xfe10, {.d_s = v__ast__Expr_str(a.expr)}}, {_SLIT0, 0, { .d_c = 0 }}}));
		return _t1;
	}
	string _t2 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__ast__Expr_str(a.expr)}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t2;
}

string v__ast__args2str(Array_v__ast__CallArg args) {
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t1 = 0; _t1 < args.len; ++_t1) {
		v__ast__CallArg a = ((v__ast__CallArg*)args.data)[_t1];
		array_push((array*)&res, _MOV((string[]){ string_clone(v__ast__CallArg_str(a)) }));
	}
	string _t3 = Array_string_join(res, _SLIT(", "));
	return _t3;
}

string v__ast__BranchStmt_str(v__ast__BranchStmt* node) {
	string s =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__token__Kind_str(node->kind)}}, {_SLIT0, 0, { .d_c = 0 }}}));
	if (node->label.len > 0) {
		s = /*f*/string__plus(s,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(" "), 0xfe10, {.d_s = node->label}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
	string _t1 = s;
	return _t1;
}

string v__ast__Stmt_str(v__ast__Stmt node) {
	if (node._typ == 330 /* v.ast.AssertStmt */) {
		string _t1 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("assert "), 0xfe10, {.d_s = v__ast__Expr_str((*node._v__ast__AssertStmt).expr)}}, {_SLIT0, 0, { .d_c = 0 }}}));
		return _t1;
	}
	else if (node._typ == 331 /* v.ast.AssignStmt */) {
		string out = _SLIT("");
		for (int i = 0; i < (*node._v__ast__AssignStmt).left.len; ++i) {
			v__ast__Expr left = ((v__ast__Expr*)(*node._v__ast__AssignStmt).left.data)[i];
			if ((left)._typ == 299 /* v.ast.Ident */) {
				v__ast__IdentVar var_info = v__ast__Ident_var_info(&(*left._v__ast__Ident));
				if (var_info.is_mut) {
					out = /*f*/string__plus(out, _SLIT("mut "));
				}
			}
			out = /*f*/string__plus(out, v__ast__Expr_str(left));
			if (i < (*node._v__ast__AssignStmt).left.len - 1) {
				out = /*f*/string__plus(out, _SLIT(","));
			}
		}
		out = /*f*/string__plus(out,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(" "), 0xfe10, {.d_s = v__token__Kind_str((*node._v__ast__AssignStmt).op)}}, {_SLIT(" "), 0, { .d_c = 0 }}})));
		for (int i = 0; i < (*node._v__ast__AssignStmt).right.len; ++i) {
			v__ast__Expr val = ((v__ast__Expr*)(*node._v__ast__AssignStmt).right.data)[i];
			out = /*f*/string__plus(out, v__ast__Expr_str(val));
			if (i < (*node._v__ast__AssignStmt).right.len - 1) {
				out = /*f*/string__plus(out, _SLIT(","));
			}
		}
		string _t2 = out;
		return _t2;
	}
	else if (node._typ == 333 /* v.ast.BranchStmt */) {
		string _t3 = v__ast__BranchStmt_str(&(*node._v__ast__BranchStmt));
		return _t3;
	}
	else if (node._typ == 335 /* v.ast.ConstDecl */) {
		Array_string _t4 = __new_array(0, 0, sizeof(string));
		Array_v__ast__ConstField _t4_orig = (*node._v__ast__ConstDecl).fields;
		int _t4_len = _t4_orig.len;
		_t4 = __new_array(0, _t4_len, sizeof(string));

		for (int _t5 = 0; _t5 < _t4_len; ++_t5) {
			v__ast__ConstField it = ((v__ast__ConstField*) _t4_orig.data)[_t5];
			string ti = v__ast__field_to_string(it);
			array_push((array*)&_t4, &ti);
		}
		Array_string fields =_t4;
		string _t6 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("const ("), 0xfe10, {.d_s = Array_string_join(fields, _SLIT(" "))}}, {_SLIT(")"), 0, { .d_c = 0 }}}));
		return _t6;
	}
	else if (node._typ == 339 /* v.ast.ExprStmt */) {
		string _t7 = v__ast__Expr_str((*node._v__ast__ExprStmt).expr);
		return _t7;
	}
	else if (node._typ == 216 /* v.ast.FnDecl */) {
		string _t8 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT("fn "), 0xfe10, {.d_s = (*node._v__ast__FnDecl).name}}, {_SLIT("( "), 0xfe07, {.d_i32 = (*node._v__ast__FnDecl).params.len}}, {_SLIT(" params ) { "), 0xfe07, {.d_i32 = (*node._v__ast__FnDecl).stmts.len}}, {_SLIT(" stmts }"), 0, { .d_c = 0 }}}));
		return _t8;
	}
	else if (node._typ == 338 /* v.ast.EnumDecl */) {
		string _t9 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("enum "), 0xfe10, {.d_s = (*node._v__ast__EnumDecl).name}}, {_SLIT(" { "), 0xfe07, {.d_i32 = (*node._v__ast__EnumDecl).fields.len}}, {_SLIT(" fields }"), 0, { .d_c = 0 }}}));
		return _t9;
	}
	else if (node._typ == 349 /* v.ast.Module */) {
		string _t10 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("module "), 0xfe10, {.d_s = (*node._v__ast__Module).name}}, {_SLIT0, 0, { .d_c = 0 }}}));
		return _t10;
	}
	else if (node._typ == 347 /* v.ast.Import */) {
		string out =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("import "), 0xfe10, {.d_s = (*node._v__ast__Import).mod}}, {_SLIT0, 0, { .d_c = 0 }}}));
		if ((*node._v__ast__Import).alias.len > 0) {
			out = /*f*/string__plus(out,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(" as "), 0xfe10, {.d_s = (*node._v__ast__Import).alias}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		string _t11 = out;
		return _t11;
	}
	else if (node._typ == 352 /* v.ast.StructDecl */) {
		string _t12 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("struct "), 0xfe10, {.d_s = (*node._v__ast__StructDecl).name}}, {_SLIT(" { "), 0xfe07, {.d_i32 = (*node._v__ast__StructDecl).fields.len}}, {_SLIT(" fields }"), 0, { .d_c = 0 }}}));
		return _t12;
	}
	
	else {
		string _t13 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("[unhandled stmt str type: "), 0xfe10, {.d_s = charptr_vstring_literal( /* v.ast.Stmt */ v_typeof_sumtype_v__ast__Stmt( (node)._typ ))}}, {_SLIT(" ]"), 0, { .d_c = 0 }}}));
		return _t13;
	}
	;
	return (string){.str=(byteptr)"", .is_lit=1};
}

VV_LOCAL_SYMBOL string v__ast__field_to_string(v__ast__ConstField f) {
	string x = string_trim_string_left(f.name, string__plus(f.mod, _SLIT(".")));
	string _t1 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = x}}, {_SLIT(" = "), 0xfe10, {.d_s = v__ast__Expr_str(f.expr)}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t1;
}

string v__ast__ComptimeForKind_str(v__ast__ComptimeForKind e) {

	if (e == (v__ast__ComptimeForKind__methods)) {
		string _t1 = _SLIT("methods");
		return _t1;
	}
	else if (e == (v__ast__ComptimeForKind__fields)) {
		string _t2 = _SLIT("fields");
		return _t2;
	}
	else if (e == (v__ast__ComptimeForKind__attributes)) {
		string _t3 = _SLIT("attributes");
		return _t3;
	};
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [unsafe]
void v__ast__Table_free(v__ast__Table* t) {
	{ // Unsafe block
		for (int _t1 = 0; _t1 < t->type_symbols.len; ++_t1) {
			v__ast__TypeSymbol* s = ((v__ast__TypeSymbol**)t->type_symbols.data)[_t1];
			v__ast__TypeSymbol_free(s);
		}
		array_free(&t->type_symbols);
		map_free(&t->type_idxs);
		map_free(&t->fns);
		map_free(&t->dumps);
		array_free(&t->imports);
		array_free(&t->modules);
		array_free(&t->cflags);
		array_free(&t->redefined_fns);
		map_free(&t->fn_generic_types);
		string_free(&t->cmod_prefix);
		map_free(&t->used_fns);
		map_free(&t->used_consts);
		map_free(&t->used_globals);
		array_free(&t->used_vweb_types);
	}
}

// TypeDecl
VV_LOCAL_SYMBOL void v__ast__default_table_panic_handler(v__ast__Table* t, string message) {
	_v_panic(message);
	VUNREACHABLE();
}

void v__ast__Table_panic(v__ast__Table* t, string message) {
	v__ast__Table* mt = ((v__ast__Table*)(t));
	mt->panic_npanics++;
	t->panic_handler(t, message);
}

VV_LOCAL_SYMBOL bool v__ast__Fn_method_equals(v__ast__Fn* f, v__ast__Fn* o) {
	bool _t1 = Array_v__ast__Param_equals(array_slice(f->params, 1, f->params.len), array_slice(o->params, 1, o->params.len)) && v__ast__Type_alias_eq(f->return_type, o->return_type) && f->is_variadic == o->is_variadic && f->language == o->language && Array_string_arr_eq(f->generic_names, o->generic_names) && f->is_pub == o->is_pub && string__eq(f->mod, o->mod) && string__eq(f->name, o->name);
	return _t1;
}

v__ast__Fn v__ast__Fn_new_method_with_receiver_type(v__ast__Fn* f, v__ast__Type new_type) {
	{ // Unsafe block
		v__ast__Fn* new_method = f;
		new_method->params = array_clone_to_depth(&f->params, 0);
		for (int i = 1; i < new_method->params.len; ++i) {
			if (v__ast__Type_alias_eq((*(v__ast__Param*)/*ee elem_typ */array_get(new_method->params, i)).typ, (*(v__ast__Param*)/*ee elem_typ */array_get(new_method->params, 0)).typ)) {
				(*(v__ast__Param*)/*ee elem_typ */array_get(new_method->params, i)).typ = new_type;
			}
		}
		(*(v__ast__Param*)/*ee elem_typ */array_get(new_method->params, 0)).typ = new_type;
		v__ast__Fn _t1 = *new_method;
		return _t1;
	}
	return (v__ast__Fn){.is_variadic = 0,.is_pub = 0,.is_ctor_new = 0,.is_deprecated = 0,.is_noreturn = 0,.is_unsafe = 0,.is_placeholder = 0,.is_main = 0,.is_test = 0,.is_keep_alive = 0,.is_method = 0,.no_body = 0,.mod = (string){.str=(byteptr)"", .is_lit=1},.file = (string){.str=(byteptr)"", .is_lit=1},.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.return_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.return_type = 0,.receiver_type = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.params = __new_array(0, 0, sizeof(v__ast__Param)),.source_fn = 0,.usages = 0,.generic_names = __new_array(0, 0, sizeof(string)),.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_conditional = 0,.ctdefine_idx = 0,};
}

v__ast__FnDecl v__ast__FnDecl_new_method_with_receiver_type(v__ast__FnDecl* f, v__ast__Type new_type) {
	{ // Unsafe block
		v__ast__FnDecl* new_method = f;
		new_method->params = array_clone_to_depth(&f->params, 0);
		for (int i = 1; i < new_method->params.len; ++i) {
			if (v__ast__Type_alias_eq((*(v__ast__Param*)/*ee elem_typ */array_get(new_method->params, i)).typ, (*(v__ast__Param*)/*ee elem_typ */array_get(new_method->params, 0)).typ)) {
				(*(v__ast__Param*)/*ee elem_typ */array_get(new_method->params, i)).typ = new_type;
			}
		}
		(*(v__ast__Param*)/*ee elem_typ */array_get(new_method->params, 0)).typ = new_type;
		v__ast__FnDecl _t1 = *new_method;
		return _t1;
	}
	return (v__ast__FnDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.is_deprecated = 0,.is_pub = 0,.is_variadic = 0,.is_anon = 0,.is_noreturn = 0,.is_manualfree = 0,.is_main = 0,.is_test = 0,.is_conditional = 0,.is_exported = 0,.is_keep_alive = 0,.is_unsafe = 0,.is_markused = 0,.receiver = (v__ast__StructField){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.has_default_expr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_pub = 0,.default_val = (string){.str=(byteptr)"", .is_lit=1},.is_mut = 0,.is_global = 0,.is_volatile = 0,.default_expr_typ = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,},.receiver_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.is_method = 0,.method_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.method_idx = 0,.rec_mut = 0,.no_body = 0,.is_builtin = 0,.body_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.file = (string){.str=(byteptr)"", .is_lit=1},.generic_names = __new_array(0, 0, sizeof(string)),.is_direct_arr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.ctdefine_idx = -1,.params = __new_array(0, 0, sizeof(v__ast__Param)),.stmts = __new_array(0, 0, sizeof(v__ast__Stmt)),.defer_stmts = __new_array(0, 0, sizeof(v__ast__DeferStmt)),.return_type = 0,.return_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.has_return = 0,.should_be_skipped = 0,.ninstances = 0,.has_await = 0,.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.next_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.source_file = 0,.scope = 0,.label_names = __new_array(0, 0, sizeof(string)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},};
}

VV_LOCAL_SYMBOL bool v__ast__Param_equals(v__ast__Param* p, v__ast__Param* o) {
	bool _t1 = string__eq(p->name, o->name) && p->is_mut == o->is_mut && v__ast__Type_alias_eq(p->typ, o->typ) && p->is_hidden == o->is_hidden;
	return _t1;
}

VV_LOCAL_SYMBOL bool Array_v__ast__Param_equals(Array_v__ast__Param p, Array_v__ast__Param o) {
	if (p.len != o.len) {
		bool _t1 = false;
		return _t1;
	}
	for (int i = 0; i < p.len; ++i) {
		if (!v__ast__Param_equals(&(*(v__ast__Param*)/*ee elem_typ */array_get(p, i)), (voidptr)&/*qq*/(*(v__ast__Param*)/*ee elem_typ */array_get(o, i)))) {
			bool _t2 = false;
			return _t2;
		}
	}
	bool _t3 = true;
	return _t3;
}

v__ast__Table* v__ast__new_table(void) {
	v__ast__Table* t = (v__ast__Table*)memdup(&(v__ast__Table){.type_symbols = __new_array(0, 0, sizeof(v__ast__TypeSymbol*)),.type_idxs = new_map(sizeof(string), sizeof(int), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.fns = new_map(sizeof(string), sizeof(v__ast__Fn), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.iface_types = new_map(sizeof(string), sizeof(Array_v__ast__Type), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.dumps = new_map(sizeof(int), sizeof(string), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),.imports = __new_array(0, 0, sizeof(string)),.modules = __new_array(0, 0, sizeof(string)),.global_scope = (v__ast__Scope*)memdup(&(v__ast__Scope){.objects = new_map(sizeof(string), sizeof(v__ast__ScopeObject), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.struct_fields = new_map(sizeof(string), sizeof(v__ast__ScopeStructField), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.parent = 0,.detached_from_parent = 0,.children = __new_array(0, 0, sizeof(v__ast__Scope*)),.start_pos = 0,.end_pos = 0,}, sizeof(v__ast__Scope)),.cflags = __new_array(0, 0, sizeof(v__cflag__CFlag)),.redefined_fns = __new_array(0, 0, sizeof(string)),.fn_generic_types = new_map(sizeof(string), sizeof(Array_Array_v__ast__Type), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.interfaces = new_map(sizeof(int), sizeof(v__ast__InterfaceDecl), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),.cmod_prefix = (string){.str=(byteptr)"", .is_lit=1},.is_fmt = 0,.used_fns = new_map(sizeof(string), sizeof(bool), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.used_consts = new_map(sizeof(string), sizeof(bool), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.used_globals = new_map(sizeof(string), sizeof(bool), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.used_vweb_types = __new_array(0, 0, sizeof(v__ast__Type)),.used_maps = 0,.panic_handler = v__ast__default_table_panic_handler,.panic_userdata = ((voidptr)(0)),.panic_npanics = 0,.cur_fn = 0,.cur_concrete_types = __new_array(0, 0, sizeof(v__ast__Type)),.gostmts = 0,.enum_decls = new_map(sizeof(string), sizeof(v__ast__EnumDecl), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),}, sizeof(v__ast__Table));
	v__ast__Table_register_builtin_type_symbols(t);
	t->is_fmt = true;
	v__ast__set_global_table(t);
	v__ast__Table* _t1 = t;
	return _t1;
}

void v__ast__set_global_table(v__ast__Table* t) {
	global_table = t;
}

string v__ast__Table_fn_type_signature(v__ast__Table* t, v__ast__Fn* f) {
	string sig = _SLIT("");
	for (int i = 0; i < f->params.len; ++i) {
		v__ast__Param arg = ((v__ast__Param*)f->params.data)[i];
		v__ast__Type typ = v__ast__Type_set_nr_muls(arg.typ, 0);
		v__ast__TypeSymbol* arg_type_sym = v__ast__Table_sym(t, typ);
		if (arg_type_sym->kind == v__ast__Kind__alias) {
			sig = /*f*/string__plus(sig, arg_type_sym->cname);
		} else {
			sig = /*f*/string__plus(sig, string_replace_each(string_to_lower(v__ast__TypeSymbol_str(arg_type_sym)), new_array_from_c_array(20, 20, sizeof(string), _MOV((string[20]){
					_SLIT("."), _SLIT("__"), _SLIT("&"), _SLIT(""), _SLIT("["), _SLIT("arr_"), _SLIT("chan "), _SLIT("chan_"), _SLIT("map["),
					_SLIT("map_of_"), _SLIT("]"), _SLIT("_to_"), _SLIT("<"), _SLIT("_T_"), _SLIT(","), _SLIT("_"), _SLIT(" "),
					_SLIT(""), _SLIT(">"), _SLIT("")}))));
		}
		if (i < f->params.len - 1) {
			sig = /*f*/string__plus(sig, _SLIT("_"));
		}
	}
	if (f->return_type != 0 && !v__ast__Type_alias_eq(f->return_type, _const_v__ast__void_type)) {
		v__ast__TypeSymbol* sym = v__ast__Table_sym(t, f->return_type);
		string opt = (v__ast__Type_has_flag(f->return_type, v__ast__TypeFlag__optional) ? (_SLIT("option_")) : (_SLIT("")));
		if (sym->kind == v__ast__Kind__alias) {
			sig = /*f*/string__plus(sig,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("__"), 0xfe10, {.d_s = opt}}, {_SLIT0, 0xfe10, {.d_s = sym->cname}}, {_SLIT0, 0, { .d_c = 0 }}})));
		} else {
			sig = /*f*/string__plus(sig,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("__"), 0xfe10, {.d_s = opt}}, {_SLIT0, 0xfe10, {.d_s = v__ast__Kind_str(sym->kind)}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
	}
	string _t1 = sig;
	return _t1;
}

string v__ast__Table_fn_type_source_signature(v__ast__Table* t, v__ast__Fn* f) {
	string sig = _SLIT("(");
	for (int i = 0; i < f->params.len; ++i) {
		v__ast__Param arg = ((v__ast__Param*)f->params.data)[i];
		if (arg.is_mut) {
			sig = /*f*/string__plus(sig, _SLIT("mut "));
		}
		if (t->is_fmt && arg.name.len > 0) {
			sig = /*f*/string__plus(sig,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = arg.name}}, {_SLIT(" "), 0, { .d_c = 0 }}})));
		}
		v__ast__TypeSymbol* arg_type_sym = v__ast__Table_sym(t, arg.typ);
		sig = /*f*/string__plus(sig, arg_type_sym->name);
		if (i < f->params.len - 1) {
			sig = /*f*/string__plus(sig, _SLIT(", "));
		}
	}
	sig = /*f*/string__plus(sig, _SLIT(")"));
	if (v__ast__Type_alias_eq(f->return_type, _const_v__ast__ovoid_type)) {
		sig = /*f*/string__plus(sig, _SLIT(" ?"));
	} else if (!v__ast__Type_alias_eq(f->return_type, _const_v__ast__void_type)) {
		v__ast__TypeSymbol* return_type_sym = v__ast__Table_sym(t, f->return_type);
		if (v__ast__Type_has_flag(f->return_type, v__ast__TypeFlag__optional)) {
			sig = /*f*/string__plus(sig,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(" ?"), 0xfe10, {.d_s = return_type_sym->name}}, {_SLIT0, 0, { .d_c = 0 }}})));
		} else {
			sig = /*f*/string__plus(sig,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(" "), 0xfe10, {.d_s = return_type_sym->name}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
	}
	string _t1 = sig;
	return _t1;
}

string v__ast__Table_is_same_method(v__ast__Table* t, v__ast__Fn* f, v__ast__Fn* func) {
	if (!v__ast__Type_alias_eq(f->return_type, func->return_type)) {
		string s = v__ast__Table_type_to_str(t, f->return_type);
		string _t1 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("expected return type `"), 0xfe10, {.d_s = s}}, {_SLIT("`"), 0, { .d_c = 0 }}}));
		return _t1;
	}
	if (f->params.len != func->params.len) {
		string _t2 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("expected "), 0xfe07, {.d_i32 = f->params.len}}, {_SLIT(" parameter(s), not "), 0xfe07, {.d_i32 = func->params.len}}, {_SLIT0, 0, { .d_c = 0 }}}));
		return _t2;
	}
	for (int i = 0; i < f->params.len; ++i) {
		bool has_unexpected_type = i > 0 && !v__ast__Type_alias_eq((*(v__ast__Param*)/*ee elem_typ */array_get(f->params, i)).typ, (*(v__ast__Param*)/*ee elem_typ */array_get(func->params, i)).typ);
		v__ast__TypeSymbol* lsym = v__ast__Table_sym(t, (*(v__ast__Param*)/*ee elem_typ */array_get(f->params, i)).typ);
		v__ast__TypeSymbol* rsym = v__ast__Table_sym(t, (*(v__ast__Param*)/*ee elem_typ */array_get(func->params, i)).typ);
		if (lsym->language == v__ast__Language__js && rsym->language == v__ast__Language__js) {
			string _t3 = _SLIT("");
			return _t3;
		}
		bool has_unexpected_mutability = !(*(v__ast__Param*)/*ee elem_typ */array_get(f->params, i)).is_mut && (*(v__ast__Param*)/*ee elem_typ */array_get(func->params, i)).is_mut;
		if (has_unexpected_type || has_unexpected_mutability) {
			string exps = v__ast__Table_type_to_str(t, (*(v__ast__Param*)/*ee elem_typ */array_get(f->params, i)).typ);
			string gots = v__ast__Table_type_to_str(t, (*(v__ast__Param*)/*ee elem_typ */array_get(func->params, i)).typ);
			if (has_unexpected_type) {
				string _t4 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT("expected `"), 0xfe10, {.d_s = exps}}, {_SLIT("`, not `"), 0xfe10, {.d_s = gots}}, {_SLIT("` for parameter "), 0xfe07, {.d_i32 = i}}, {_SLIT0, 0, { .d_c = 0 }}}));
				return _t4;
			} else {
				string _t5 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("expected `"), 0xfe10, {.d_s = exps}}, {_SLIT("` which is immutable, not `mut "), 0xfe10, {.d_s = gots}}, {_SLIT("`"), 0, { .d_c = 0 }}}));
				return _t5;
			}
		}
	}
	string _t6 = _SLIT("");
	return _t6;
}

Option_v__ast__Fn v__ast__Table_find_fn(v__ast__Table* t, string name) {
	v__ast__Fn* _t2 = (v__ast__Fn*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, t->fns), &(string[]){name}));
	Option_v__ast__Fn _t1 = {0};
	if (_t2) {
		*((v__ast__Fn*)&_t1.data) = *((v__ast__Fn*)_t2);
	} else {
		_t1.state = 2; _t1.err = _v_error(_SLIT("array index out of range"));
	}
	
	if (_t1.state == 0) {
		v__ast__Fn f = *(v__ast__Fn*)_t1.data;
		Option_v__ast__Fn _t3;
		opt_ok(&(v__ast__Fn[]) { f }, (Option*)(&_t3), sizeof(v__ast__Fn));
		return _t3;
	}
	return (Option_v__ast__Fn){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
}

bool v__ast__Table_known_fn(v__ast__Table* t, string name) {
	Option_v__ast__Fn _t1 = v__ast__Table_find_fn(t, name);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		bool _t2 = false;
		return _t2;
	}
	
  (*(v__ast__Fn*)_t1.data);
	bool _t3 = true;
	return _t3;
}

void v__ast__Table_register_fn(v__ast__Table* t, v__ast__Fn new_fn) {
	(*(v__ast__Fn*)map_get_and_set((map*)&t->fns, &(string[]){new_fn.name}, &(v__ast__Fn[]){ (v__ast__Fn){.is_variadic = 0,.is_pub = 0,.is_ctor_new = 0,.is_deprecated = 0,.is_noreturn = 0,.is_unsafe = 0,.is_placeholder = 0,.is_main = 0,.is_test = 0,.is_keep_alive = 0,.is_method = 0,.no_body = 0,.mod = (string){.str=(byteptr)"", .is_lit=1},.file = (string){.str=(byteptr)"", .is_lit=1},.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.return_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.return_type = 0,.receiver_type = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.params = __new_array(0, 0, sizeof(v__ast__Param)),.source_fn = 0,.usages = 0,.generic_names = __new_array(0, 0, sizeof(string)),.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_conditional = 0,.ctdefine_idx = 0,} })) = new_fn;
}

void v__ast__Table_register_interface(v__ast__Table* t, v__ast__InterfaceDecl idecl) {
	(*(v__ast__InterfaceDecl*)map_get_and_set((map*)&t->interfaces, &(int[]){idecl.typ}, &(v__ast__InterfaceDecl[]){ (v__ast__InterfaceDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,.name_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.field_names = __new_array(0, 0, sizeof(string)),.is_pub = 0,.mut_pos = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.pre_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = __new_array(0, 0, sizeof(v__ast__Type)),.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.methods = __new_array(0, 0, sizeof(v__ast__FnDecl)),.fields = __new_array(0, 0, sizeof(v__ast__StructField)),.ifaces = __new_array(0, 0, sizeof(v__ast__InterfaceEmbedding)),.are_ifaces_expanded = 0,} })) = idecl;
}

int v__ast__TypeSymbol_register_method(v__ast__TypeSymbol* t, v__ast__Fn new_fn) {
	array_push((array*)&t->methods, _MOV((v__ast__Fn[]){ new_fn }));
	int _t2 = t->methods.len - 1;
	return _t2;
}

Option_v__ast__Fn v__ast__Table_register_aggregate_method(v__ast__Table* t, v__ast__TypeSymbol* sym, string name) {
	if (sym->kind != v__ast__Kind__aggregate) {
		v__ast__Table_panic(t,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("Unexpected type symbol: "), 0xfe10, {.d_s = v__ast__Kind_str(sym->kind)}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
	v__ast__Aggregate agg_info = /* as */ *(v__ast__Aggregate*)__as_cast((sym->info)._v__ast__Aggregate,(sym->info)._typ, 458) /*expected idx: 458, name: v.ast.Aggregate */ ;
	bool found_once = false;
	v__ast__Fn new_fn = (v__ast__Fn){.is_variadic = 0,.language = 0,.is_pub = 0,.is_ctor_new = 0,.is_deprecated = 0,.is_noreturn = 0,.is_unsafe = 0,.is_placeholder = 0,.is_main = 0,.is_test = 0,.is_keep_alive = 0,.is_method = 0,.no_body = 0,.mod = (string){.str=(byteptr)"", .is_lit=1},.file = (string){.str=(byteptr)"", .is_lit=1},.file_mode = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.return_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.return_type = 0,.receiver_type = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.params = __new_array(0, 0, sizeof(v__ast__Param)),.source_fn = 0,.usages = 0,.generic_names = __new_array(0, 0, sizeof(string)),.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_conditional = 0,.ctdefine_idx = 0,};
	for (int _t1 = 0; _t1 < agg_info.types.len; ++_t1) {
		v__ast__Type typ = ((v__ast__Type*)agg_info.types.data)[_t1];
		v__ast__TypeSymbol* ts = v__ast__Table_sym(t, typ);
		Option_v__ast__Fn _t2;
		if (_t2 = v__ast__TypeSymbol_find_method(ts, name), _t2.state == 0) {
			v__ast__Fn type_method = *(v__ast__Fn*)_t2.data;
			if (!found_once) {
				found_once = true;
				new_fn = type_method;
			} else if (!v__ast__Fn_method_equals(&new_fn, (voidptr)&/*qq*/type_method)) {
				return (Option_v__ast__Fn){ .state=2, .err=_v_error( str_intp(3, _MOV((StrIntpData[]){{_SLIT("method `"), 0xfe10, {.d_s = v__ast__Table_type_to_str(t, typ)}}, {_SLIT("."), 0xfe10, {.d_s = name}}, {_SLIT("` signature is different"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
		} else {
			IError err = _t2.err;
			return (Option_v__ast__Fn){ .state=2, .err=_v_error( str_intp(3, _MOV((StrIntpData[]){{_SLIT("unknown method: `"), 0xfe10, {.d_s = v__ast__Table_type_to_str(t, typ)}}, {_SLIT("."), 0xfe10, {.d_s = name}}, {_SLIT("`"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	v__ast__TypeSymbol_register_method(sym, new_fn);
	Option_v__ast__Fn _t5;
	opt_ok(&(v__ast__Fn[]) { new_fn }, (Option*)(&_t5), sizeof(v__ast__Fn));
	return _t5;
}

bool v__ast__Table_has_method(v__ast__Table* t, v__ast__TypeSymbol* s, string name) {
	Option_v__ast__Fn _t1 = v__ast__Table_find_method(t, s, name);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		bool _t2 = false;
		return _t2;
	}
	
  (*(v__ast__Fn*)_t1.data);
	bool _t3 = true;
	return _t3;
}

Option_v__ast__Fn v__ast__Table_find_method(v__ast__Table* t, v__ast__TypeSymbol* s, string name) {
	v__ast__TypeSymbol* ts = s;
	for (;;) {
		Option_v__ast__Fn _t1;
		if (_t1 = v__ast__TypeSymbol_find_method(ts, name), _t1.state == 0) {
			v__ast__Fn method = *(v__ast__Fn*)_t1.data;
			Option_v__ast__Fn _t2;
			opt_ok(&(v__ast__Fn[]) { method }, (Option*)(&_t2), sizeof(v__ast__Fn));
			return _t2;
		}
		if (ts->kind == v__ast__Kind__aggregate) {
			Option_v__ast__Fn _t3 = v__ast__Table_register_aggregate_method(t, ts, name);
			return _t3;
		}
		if (ts->parent_idx == 0) {
			break;
		}
		ts = (*(v__ast__TypeSymbol**)/*ee elem_typ */array_get(t->type_symbols, ts->parent_idx));
	}
	return (Option_v__ast__Fn){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
}

Array_Array_v__ast__Type v__ast__Table_get_embeds(v__ast__Table* t, v__ast__TypeSymbol* sym, v__ast__GetEmbedsOptions options) {
	Array_Array_v__ast__Type embeds = __new_array_with_default(0, 0, sizeof(Array_v__ast__Type), 0);
	v__ast__TypeSymbol* unalias_sym = ((sym->info)._typ == 460 /* v.ast.Alias */ ? (v__ast__Table_sym(t, (*sym->info._v__ast__Alias).parent_type)) : (sym));
	if ((unalias_sym->info)._typ == 446 /* v.ast.Struct */) {
		for (int _t1 = 0; _t1 < (*unalias_sym->info._v__ast__Struct).embeds.len; ++_t1) {
			v__ast__Type embed = ((v__ast__Type*)(*unalias_sym->info._v__ast__Struct).embeds.data)[_t1];
			v__ast__TypeSymbol* embed_sym = v__ast__Table_sym(t, embed);
			Array_v__ast__Type preceding = options.preceding;
			array_push((array*)&preceding, _MOV((v__ast__Type[]){ embed }));
			_PUSH_MANY(&embeds, (v__ast__Table_get_embeds(t, embed_sym, (v__ast__GetEmbedsOptions){.preceding = preceding,})), _t3, Array_Array_v__ast__Type);
		}
		if ((*unalias_sym->info._v__ast__Struct).embeds.len == 0 && options.preceding.len > 0) {
			array_push((array*)&embeds, _MOV((Array_v__ast__Type[]){ options.preceding }));
		}
	}
	Array_Array_v__ast__Type _t5 = embeds;
	return _t5;
}

Option_multi_return_v__ast__Fn_Array_v__ast__Type v__ast__Table_find_method_from_embeds(v__ast__Table* t, v__ast__TypeSymbol* sym, string method_name) {
	if ((sym->info)._typ == 446 /* v.ast.Struct */) {
		Array_v__ast__Fn found_methods = __new_array_with_default(0, 0, sizeof(v__ast__Fn), 0);
		Array_v__ast__Type embed_of_found_methods = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
		for (int _t1 = 0; _t1 < (*sym->info._v__ast__Struct).embeds.len; ++_t1) {
			v__ast__Type embed = ((v__ast__Type*)(*sym->info._v__ast__Struct).embeds.data)[_t1];
			v__ast__TypeSymbol* embed_sym = v__ast__Table_sym(t, embed);
			Option_v__ast__Fn _t2;
			if (_t2 = v__ast__Table_find_method(t, embed_sym, method_name), _t2.state == 0) {
				v__ast__Fn m = *(v__ast__Fn*)_t2.data;
				array_push((array*)&found_methods, _MOV((v__ast__Fn[]){ m }));
				array_push((array*)&embed_of_found_methods, _MOV((v__ast__Type[]){ embed }));
			} else {
				IError err = _t2.err;
				Option_multi_return_v__ast__Fn_Array_v__ast__Type _t5 = v__ast__Table_find_method_from_embeds(t, embed_sym, method_name);
				if (_t5.state != 0) { /*or block*/ 
					IError err = _t5.err;
					continue;
				}
				
 				Option_multi_return_v__ast__Fn_Array_v__ast__Type mr_11571 =  _t5 /*U*/;
				v__ast__Fn method = (*(multi_return_v__ast__Fn_Array_v__ast__Type*)mr_11571.data).arg0;
				Array_v__ast__Type types = (*(multi_return_v__ast__Fn_Array_v__ast__Type*)mr_11571.data).arg1;
				array_push((array*)&found_methods, _MOV((v__ast__Fn[]){ method }));
				array_push((array*)&embed_of_found_methods, _MOV((v__ast__Type[]){ embed }));
				_PUSH_MANY(&embed_of_found_methods, (types), _t8, Array_v__ast__Type);
			}
		}
		if (found_methods.len == 1) {
			Option_multi_return_v__ast__Fn_Array_v__ast__Type _t9;
			opt_ok(&(multi_return_v__ast__Fn_Array_v__ast__Type/*X*/[]) { (multi_return_v__ast__Fn_Array_v__ast__Type){.arg0=(*(v__ast__Fn*)/*ee elem_typ */array_get(found_methods, 0)), .arg1=embed_of_found_methods} }, (Option*)(&_t9), sizeof(multi_return_v__ast__Fn_Array_v__ast__Type));
			return _t9;
		} else if (found_methods.len > 1) {
			return (Option_multi_return_v__ast__Fn_Array_v__ast__Type){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("ambiguous method `"), 0xfe10, {.d_s = method_name}}, {_SLIT("`"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	} else if ((sym->info)._typ == 458 /* v.ast.Aggregate */) {
		for (int _t11 = 0; _t11 < (*sym->info._v__ast__Aggregate).types.len; ++_t11) {
			v__ast__Type typ = ((v__ast__Type*)(*sym->info._v__ast__Aggregate).types.data)[_t11];
			v__ast__TypeSymbol* agg_sym = v__ast__Table_sym(t, typ);
			Option_multi_return_v__ast__Fn_Array_v__ast__Type _t12 = v__ast__Table_find_method_from_embeds(t, agg_sym, method_name);
			if (_t12.state != 0) { /*or block*/ 
				IError err = _t12.err;
				continue;
			}
			
 			Option_multi_return_v__ast__Fn_Array_v__ast__Type mr_12034 =  _t12 /*U*/;
			v__ast__Fn method = (*(multi_return_v__ast__Fn_Array_v__ast__Type*)mr_12034.data).arg0;
			Array_v__ast__Type embed_types = (*(multi_return_v__ast__Fn_Array_v__ast__Type*)mr_12034.data).arg1;
			if (embed_types.len != 0) {
				Option_multi_return_v__ast__Fn_Array_v__ast__Type _t13;
				opt_ok(&(multi_return_v__ast__Fn_Array_v__ast__Type/*X*/[]) { (multi_return_v__ast__Fn_Array_v__ast__Type){.arg0=method, .arg1=embed_types} }, (Option*)(&_t13), sizeof(multi_return_v__ast__Fn_Array_v__ast__Type));
				return _t13;
			}
		}
	}
	return (Option_multi_return_v__ast__Fn_Array_v__ast__Type){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
}

Option_v__ast__Fn v__ast__Table_find_method_with_embeds(v__ast__Table* t, v__ast__TypeSymbol* sym, string method_name) {
	Option_v__ast__Fn _t1;
	if (_t1 = v__ast__Table_find_method(t, sym, method_name), _t1.state == 0) {
		v__ast__Fn func = *(v__ast__Fn*)_t1.data;
		Option_v__ast__Fn _t2;
		opt_ok(&(v__ast__Fn[]) { func }, (Option*)(&_t2), sizeof(v__ast__Fn));
		return _t2;
	} else {
		IError err = _t1.err;
		IError first_err = err;
		Option_multi_return_v__ast__Fn_Array_v__ast__Type _t3 = v__ast__Table_find_method_from_embeds(t, sym, method_name);
		if (_t3.state != 0) { /*or block*/ 
			IError err = _t3.err;
			return (Option_v__ast__Fn){ .state=2, .err=first_err, .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		
 		Option_multi_return_v__ast__Fn_Array_v__ast__Type mr_12495 =  _t3 /*U*/;
		v__ast__Fn func = (*(multi_return_v__ast__Fn_Array_v__ast__Type*)mr_12495.data).arg0;
		Option_v__ast__Fn _t5;
		opt_ok(&(v__ast__Fn[]) { func }, (Option*)(&_t5), sizeof(v__ast__Fn));
		return _t5;
	}
	return (Option_v__ast__Fn){0};
}

VV_LOCAL_SYMBOL Option_v__ast__StructField v__ast__Table_register_aggregate_field(v__ast__Table* t, v__ast__TypeSymbol* sym, string name) {
	if (sym->kind != v__ast__Kind__aggregate) {
		v__ast__Table_panic(t,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("Unexpected type symbol: "), 0xfe10, {.d_s = v__ast__Kind_str(sym->kind)}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
	v__ast__Aggregate agg_info = /* as */ *(v__ast__Aggregate*)__as_cast((sym->info)._v__ast__Aggregate,(sym->info)._typ, 458) /*expected idx: 458, name: v.ast.Aggregate */ ;
	bool found_once = false;
	v__ast__StructField new_field = (v__ast__StructField){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.has_default_expr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_pub = 0,.default_val = (string){.str=(byteptr)"", .is_lit=1},.is_mut = 0,.is_global = 0,.is_volatile = 0,.default_expr = {0},.default_expr_typ = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,};
	for (int _t1 = 0; _t1 < agg_info.types.len; ++_t1) {
		v__ast__Type typ = ((v__ast__Type*)agg_info.types.data)[_t1];
		v__ast__TypeSymbol* ts = v__ast__Table_sym(t, typ);
		Option_v__ast__StructField _t2;
		if (_t2 = v__ast__Table_find_field(t, ts, name), _t2.state == 0) {
			v__ast__StructField type_field = *(v__ast__StructField*)_t2.data;
			if (!found_once) {
				found_once = true;
				new_field = type_field;
			} else if (!v__ast__Type_alias_eq(new_field.typ, type_field.typ)) {
				return (Option_v__ast__StructField){ .state=2, .err=_v_error( str_intp(3, _MOV((StrIntpData[]){{_SLIT("field `"), 0xfe10, {.d_s = v__ast__Table_type_to_str(t, typ)}}, {_SLIT("."), 0xfe10, {.d_s = name}}, {_SLIT("` type is different"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			new_field = (v__ast__StructField){new_field.pos,new_field.type_pos,new_field.comments,new_field.has_default_expr,new_field.attrs,.is_pub = new_field.is_pub && type_field.is_pub,new_field.default_val,.is_mut = new_field.is_mut && type_field.is_mut,new_field.is_global,new_field.is_volatile,new_field.default_expr,new_field.default_expr_typ,new_field.name,new_field.typ,};
		} else {
			IError err = _t2.err;
			return (Option_v__ast__StructField){ .state=2, .err=_v_error( str_intp(3, _MOV((StrIntpData[]){{_SLIT("type `"), 0xfe10, {.d_s = v__ast__Table_type_to_str(t, typ)}}, {_SLIT("` has no field or method `"), 0xfe10, {.d_s = name}}, {_SLIT("`"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	array_push((array*)&agg_info.fields, _MOV((v__ast__StructField[]){ new_field }));
	Option_v__ast__StructField _t6;
	opt_ok(&(v__ast__StructField[]) { new_field }, (Option*)(&_t6), sizeof(v__ast__StructField));
	return _t6;
}

bool v__ast__Table_struct_has_field(v__ast__Table* t, v__ast__TypeSymbol* struct_, string name) {
	Option_v__ast__StructField _t1 = v__ast__Table_find_field(t, struct_, name);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		bool _t2 = false;
		return _t2;
	}
	
  (*(v__ast__StructField*)_t1.data);
	bool _t3 = true;
	return _t3;
}

Array_v__ast__StructField v__ast__Table_struct_fields(v__ast__Table* t, v__ast__TypeSymbol* sym) {
	Array_v__ast__StructField fields = __new_array_with_default(0, 0, sizeof(v__ast__StructField), 0);
	if ((sym->info)._typ == 446 /* v.ast.Struct */) {
		_PUSH_MANY(&fields, ((*sym->info._v__ast__Struct).fields), _t1, Array_v__ast__StructField);
		for (int _t2 = 0; _t2 < (*sym->info._v__ast__Struct).embeds.len; ++_t2) {
			v__ast__Type embed = ((v__ast__Type*)(*sym->info._v__ast__Struct).embeds.data)[_t2];
			v__ast__TypeSymbol* embed_sym = v__ast__Table_sym(t, embed);
			_PUSH_MANY(&fields, (v__ast__Table_struct_fields(t, embed_sym)), _t3, Array_v__ast__StructField);
		}
	}
	Array_v__ast__StructField _t4 = fields;
	return _t4;
}

Option_v__ast__StructField v__ast__Table_find_field(v__ast__Table* t, v__ast__TypeSymbol* s, string name) {
	v__ast__TypeSymbol* ts = s;
	for (;;) {
		if (ts->info._typ == 446 /* v.ast.Struct */) {
			Option_v__ast__StructField _t1;
			if (_t1 = v__ast__Struct_find_field(&(*ts->info._v__ast__Struct), name), _t1.state == 0) {
				v__ast__StructField field = *(v__ast__StructField*)_t1.data;
				Option_v__ast__StructField _t2;
				opt_ok(&(v__ast__StructField[]) { field }, (Option*)(&_t2), sizeof(v__ast__StructField));
				return _t2;
			}
		}
		else if (ts->info._typ == 458 /* v.ast.Aggregate */) {
			Option_v__ast__StructField _t3;
			if (_t3 = v__ast__Aggregate_find_field(&(*ts->info._v__ast__Aggregate), name), _t3.state == 0) {
				v__ast__StructField field = *(v__ast__StructField*)_t3.data;
				Option_v__ast__StructField _t4;
				opt_ok(&(v__ast__StructField[]) { field }, (Option*)(&_t4), sizeof(v__ast__StructField));
				return _t4;
			}
			Option_v__ast__StructField _t5 = v__ast__Table_register_aggregate_field(t, ts, name);
			if (_t5.state != 0) { /*or block*/ 
				IError err = _t5.err;
				return (Option_v__ast__StructField){ .state=2, .err=err, .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			
 			v__ast__StructField field =  (*(v__ast__StructField*)_t5.data);
			Option_v__ast__StructField _t7;
			opt_ok(&(v__ast__StructField[]) { field }, (Option*)(&_t7), sizeof(v__ast__StructField));
			return _t7;
		}
		else if (ts->info._typ == 463 /* v.ast.Interface */) {
			Option_v__ast__StructField _t8;
			if (_t8 = v__ast__Interface_find_field(&(*ts->info._v__ast__Interface), name), _t8.state == 0) {
				v__ast__StructField field = *(v__ast__StructField*)_t8.data;
				Option_v__ast__StructField _t9;
				opt_ok(&(v__ast__StructField[]) { field }, (Option*)(&_t9), sizeof(v__ast__StructField));
				return _t9;
			}
		}
		else if (ts->info._typ == 464 /* v.ast.SumType */) {
			v__ast__Table_resolve_common_sumtype_fields(t, ts);
			Option_v__ast__StructField _t10;
			if (_t10 = v__ast__SumType_find_field(&(*ts->info._v__ast__SumType), name), _t10.state == 0) {
				v__ast__StructField field = *(v__ast__StructField*)_t10.data;
				Option_v__ast__StructField _t11;
				opt_ok(&(v__ast__StructField[]) { field }, (Option*)(&_t11), sizeof(v__ast__StructField));
				return _t11;
			}
			return (Option_v__ast__StructField){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("field `"), 0xfe10, {.d_s = name}}, {_SLIT("` does not exist or have the same type in all sumtype variants"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		
		else {
		}
		;
		if (ts->parent_idx == 0) {
			break;
		}
		ts = (*(v__ast__TypeSymbol**)/*ee elem_typ */array_get(t->type_symbols, ts->parent_idx));
	}
	return (Option_v__ast__StructField){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
}

Option_multi_return_v__ast__StructField_Array_v__ast__Type v__ast__Table_find_field_from_embeds(v__ast__Table* t, v__ast__TypeSymbol* sym, string field_name) {
	if ((sym->info)._typ == 446 /* v.ast.Struct */) {
		Array_v__ast__StructField found_fields = __new_array_with_default(0, 0, sizeof(v__ast__StructField), 0);
		Array_v__ast__Type embeds_of_found_fields = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
		for (int _t1 = 0; _t1 < (*sym->info._v__ast__Struct).embeds.len; ++_t1) {
			v__ast__Type embed = ((v__ast__Type*)(*sym->info._v__ast__Struct).embeds.data)[_t1];
			v__ast__TypeSymbol* embed_sym = v__ast__Table_sym(t, embed);
			Option_v__ast__StructField _t2;
			if (_t2 = v__ast__Table_find_field(t, embed_sym, field_name), _t2.state == 0) {
				v__ast__StructField field = *(v__ast__StructField*)_t2.data;
				array_push((array*)&found_fields, _MOV((v__ast__StructField[]){ field }));
				array_push((array*)&embeds_of_found_fields, _MOV((v__ast__Type[]){ embed }));
			} else {
				IError err = _t2.err;
				Option_multi_return_v__ast__StructField_Array_v__ast__Type _t5 = v__ast__Table_find_field_from_embeds(t, embed_sym, field_name);
				if (_t5.state != 0) { /*or block*/ 
					IError err = _t5.err;
					continue;
				}
				
 				Option_multi_return_v__ast__StructField_Array_v__ast__Type mr_15469 =  _t5 /*U*/;
				v__ast__StructField field = (*(multi_return_v__ast__StructField_Array_v__ast__Type*)mr_15469.data).arg0;
				Array_v__ast__Type types = (*(multi_return_v__ast__StructField_Array_v__ast__Type*)mr_15469.data).arg1;
				array_push((array*)&found_fields, _MOV((v__ast__StructField[]){ field }));
				array_push((array*)&embeds_of_found_fields, _MOV((v__ast__Type[]){ embed }));
				_PUSH_MANY(&embeds_of_found_fields, (types), _t8, Array_v__ast__Type);
			}
		}
		if (found_fields.len == 1) {
			Option_multi_return_v__ast__StructField_Array_v__ast__Type _t9;
			opt_ok(&(multi_return_v__ast__StructField_Array_v__ast__Type/*X*/[]) { (multi_return_v__ast__StructField_Array_v__ast__Type){.arg0=(*(v__ast__StructField*)/*ee elem_typ */array_get(found_fields, 0)), .arg1=embeds_of_found_fields} }, (Option*)(&_t9), sizeof(multi_return_v__ast__StructField_Array_v__ast__Type));
			return _t9;
		} else if (found_fields.len > 1) {
			return (Option_multi_return_v__ast__StructField_Array_v__ast__Type){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("ambiguous field `"), 0xfe10, {.d_s = field_name}}, {_SLIT("`"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	} else if ((sym->info)._typ == 458 /* v.ast.Aggregate */) {
		for (int _t11 = 0; _t11 < (*sym->info._v__ast__Aggregate).types.len; ++_t11) {
			v__ast__Type typ = ((v__ast__Type*)(*sym->info._v__ast__Aggregate).types.data)[_t11];
			v__ast__TypeSymbol* agg_sym = v__ast__Table_sym(t, typ);
			Option_multi_return_v__ast__StructField_Array_v__ast__Type _t12 = v__ast__Table_find_field_from_embeds(t, agg_sym, field_name);
			if (_t12.state != 0) { /*or block*/ 
				IError err = _t12.err;
				continue;
			}
			
 			Option_multi_return_v__ast__StructField_Array_v__ast__Type mr_15922 =  _t12 /*U*/;
			v__ast__StructField field = (*(multi_return_v__ast__StructField_Array_v__ast__Type*)mr_15922.data).arg0;
			Array_v__ast__Type embed_types = (*(multi_return_v__ast__StructField_Array_v__ast__Type*)mr_15922.data).arg1;
			if (embed_types.len > 0) {
				Option_multi_return_v__ast__StructField_Array_v__ast__Type _t13;
				opt_ok(&(multi_return_v__ast__StructField_Array_v__ast__Type/*X*/[]) { (multi_return_v__ast__StructField_Array_v__ast__Type){.arg0=field, .arg1=embed_types} }, (Option*)(&_t13), sizeof(multi_return_v__ast__StructField_Array_v__ast__Type));
				return _t13;
			}
		}
	} else if ((sym->info)._typ == 460 /* v.ast.Alias */) {
		v__ast__TypeSymbol* unalias_sym = v__ast__Table_sym(t, (*sym->info._v__ast__Alias).parent_type);
		Option_multi_return_v__ast__StructField_Array_v__ast__Type _t14 = v__ast__Table_find_field_from_embeds(t, unalias_sym, field_name);
		return _t14;
	}
	return (Option_multi_return_v__ast__StructField_Array_v__ast__Type){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
}

Option_v__ast__StructField v__ast__Table_find_field_with_embeds(v__ast__Table* t, v__ast__TypeSymbol* sym, string field_name) {
	Option_v__ast__StructField _t1;
	if (_t1 = v__ast__Table_find_field(t, sym, field_name), _t1.state == 0) {
		v__ast__StructField field = *(v__ast__StructField*)_t1.data;
		Option_v__ast__StructField _t2;
		opt_ok(&(v__ast__StructField[]) { field }, (Option*)(&_t2), sizeof(v__ast__StructField));
		return _t2;
	} else {
		IError err = _t1.err;
		IError first_err = err;
		Option_multi_return_v__ast__StructField_Array_v__ast__Type _t3 = v__ast__Table_find_field_from_embeds(t, sym, field_name);
		if (_t3.state != 0) { /*or block*/ 
			IError err = _t3.err;
			return (Option_v__ast__StructField){ .state=2, .err=first_err, .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		
 		Option_multi_return_v__ast__StructField_Array_v__ast__Type mr_16520 =  _t3 /*U*/;
		v__ast__StructField field = (*(multi_return_v__ast__StructField_Array_v__ast__Type*)mr_16520.data).arg0;
		Option_v__ast__StructField _t5;
		opt_ok(&(v__ast__StructField[]) { field }, (Option*)(&_t5), sizeof(v__ast__StructField));
		return _t5;
	}
	return (Option_v__ast__StructField){0};
}

void v__ast__Table_resolve_common_sumtype_fields(v__ast__Table* t, v__ast__TypeSymbol* sym_) {
	v__ast__TypeSymbol* sym = sym_;
	v__ast__SumType info = /* as */ *(v__ast__SumType*)__as_cast((sym->info)._v__ast__SumType,(sym->info)._typ, 464) /*expected idx: 464, name: v.ast.SumType */ ;
	if (info.found_fields) {
		return;
	}
	Map_string_v__ast__StructField field_map = new_map(sizeof(string), sizeof(v__ast__StructField), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
	Map_string_int field_usages = new_map(sizeof(string), sizeof(int), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
	for (int _t1 = 0; _t1 < info.variants.len; ++_t1) {
		v__ast__Type variant = ((v__ast__Type*)info.variants.data)[_t1];
		v__ast__TypeSymbol* v_sym = v__ast__Table_final_sym(t, variant);
		Array_v__ast__StructField _t2 = __new_array(0, 0, sizeof(v__ast__StructField));
		if (v_sym->info._typ == 446 /* v.ast.Struct */) {
			_t2 = v__ast__Table_struct_fields(t, v_sym);
		}
		else if (v_sym->info._typ == 464 /* v.ast.SumType */) {
			v__ast__Table_resolve_common_sumtype_fields(t, v_sym);
			_t2 = (*v_sym->info._v__ast__SumType).fields;
		}
		
		else {
			_t2 = __new_array_with_default(0, 0, sizeof(v__ast__StructField), 0);
		}
		Array_v__ast__StructField fields = _t2;
		for (int _t3 = 0; _t3 < fields.len; ++_t3) {
			v__ast__StructField field = ((v__ast__StructField*)fields.data)[_t3];
			if (!_IN_MAP(ADDR(string, field.name), ADDR(map, field_map))) {
				(*(v__ast__StructField*)map_get_and_set((map*)&field_map, &(string[]){field.name}, &(v__ast__StructField[]){ (v__ast__StructField){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.has_default_expr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_pub = 0,.default_val = (string){.str=(byteptr)"", .is_lit=1},.is_mut = 0,.is_global = 0,.is_volatile = 0,.default_expr_typ = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,} })) = field;
				(*(int*)map_get_and_set((map*)&field_usages, &(string[]){field.name}, &(int[]){ 0 }))++;
			} else if (v__ast__StructField_equals(&field, (voidptr)&/*qq*/(*(v__ast__StructField*)map_get(ADDR(map, field_map), &(string[]){field.name}, &(v__ast__StructField[]){ (v__ast__StructField){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.has_default_expr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_pub = 0,.default_val = (string){.str=(byteptr)"", .is_lit=1},.is_mut = 0,.is_global = 0,.is_volatile = 0,.default_expr_typ = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,} })))) {
				(*(int*)map_get_and_set((map*)&field_usages, &(string[]){field.name}, &(int[]){ 0 }))++;
			}
		}
	}
	int _t5 = field_usages.key_values.len;
	for (int _t4 = 0; _t4 < _t5; ++_t4 ) {
		int _t6 = field_usages.key_values.len - _t5;
		_t5 = field_usages.key_values.len;
		if (_t6 < 0) {
			_t4 = -1;
			continue;
		}
		if (!DenseArray_has_index(&field_usages.key_values, _t4)) {continue;}
		string field = /*key*/ *(string*)DenseArray_key(&field_usages.key_values, _t4);
		field = string_clone(field);
		int nr_definitions = (*(int*)DenseArray_value(&field_usages.key_values, _t4));
		if (nr_definitions == info.variants.len) {
			array_push((array*)&info.fields, _MOV((v__ast__StructField[]){ (*(v__ast__StructField*)map_get((map*)&field_map, &(string[]){field}, &(v__ast__StructField[]){ (v__ast__StructField){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.has_default_expr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_pub = 0,.default_val = (string){.str=(byteptr)"", .is_lit=1},.is_mut = 0,.is_global = 0,.is_volatile = 0,.default_expr_typ = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,} })) }));
		}
	}
	info.found_fields = true;
	sym->info = v__ast__SumType_to_sumtype_v__ast__TypeInfo(&info);
}

// Attr: [inline]
inline int v__ast__Table_find_type_idx(v__ast__Table* t, string name) {
	int _t1 = (*(int*)map_get(ADDR(map, t->type_idxs), &(string[]){name}, &(int[]){ 0 }));
	return _t1;
}

// Attr: [inline]
inline Option_v__ast__TypeSymbol_ptr v__ast__Table_find_sym(v__ast__Table* t, string name) {
	int idx = (*(int*)map_get(ADDR(map, t->type_idxs), &(string[]){name}, &(int[]){ 0 }));
	if (idx > 0) {
		Option_v__ast__TypeSymbol_ptr _t1;
		opt_ok(&(v__ast__TypeSymbol*[]) { (*(v__ast__TypeSymbol**)/*ee elem_typ */array_get(t->type_symbols, idx)) }, (Option*)(&_t1), sizeof(v__ast__TypeSymbol*));
		return _t1;
	}
	return (Option_v__ast__TypeSymbol_ptr){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
}

// Attr: [inline]
inline multi_return_ref_v__ast__TypeSymbol_int v__ast__Table_find_sym_and_type_idx(v__ast__Table* t, string name) {
	int idx = (*(int*)map_get(ADDR(map, t->type_idxs), &(string[]){name}, &(int[]){ 0 }));
	if (idx > 0) {
		return (multi_return_ref_v__ast__TypeSymbol_int){.arg0=(*(v__ast__TypeSymbol**)/*ee elem_typ */array_get(t->type_symbols, idx)), .arg1=idx};
	}
	return (multi_return_ref_v__ast__TypeSymbol_int){.arg0=_const_v__ast__invalid_type_symbol, .arg1=idx};
}

// Attr: [inline]
inline v__ast__TypeSymbol* v__ast__Table_sym_by_idx(v__ast__Table* t, int idx) {
	v__ast__TypeSymbol* _t1 = (*(v__ast__TypeSymbol**)/*ee elem_typ */array_get(t->type_symbols, idx));
	return _t1;
}

v__ast__TypeSymbol* v__ast__Table_sym(v__ast__Table* t, v__ast__Type typ) {
	int idx = v__ast__Type_idx(typ);
	if (idx > 0) {
		v__ast__TypeSymbol* _t1 = (*(v__ast__TypeSymbol**)/*ee elem_typ */array_get(t->type_symbols, idx));
		return _t1;
	}
	v__ast__Table_panic(t,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("sym: invalid type (typ="), 0xfe07, {.d_i32 = typ}}, {_SLIT(" idx="), 0xfe07, {.d_i32 = idx}}, {_SLIT("). Compiler bug. This should never happen. Please report the bug using `v bug file.v`.\n"), 0, { .d_c = 0 }}})));
	v__ast__TypeSymbol* _t2 = _const_v__ast__invalid_type_symbol;
	return _t2;
}

// Attr: [inline]
inline v__ast__TypeSymbol* v__ast__Table_final_sym(v__ast__Table* t, v__ast__Type typ) {
	int idx = v__ast__Type_idx(typ);
	if (idx > 0) {
		v__ast__TypeSymbol* current_symbol = (*(v__ast__TypeSymbol**)/*ee elem_typ */array_get(t->type_symbols, idx));
		if (current_symbol->kind == v__ast__Kind__alias) {
			idx = v__ast__Type_idx((/* as */ *(v__ast__Alias*)__as_cast((current_symbol->info)._v__ast__Alias,(current_symbol->info)._typ, 460) /*expected idx: 460, name: v.ast.Alias */ ).parent_type);
		}
		v__ast__TypeSymbol* _t1 = (*(v__ast__TypeSymbol**)/*ee elem_typ */array_get(t->type_symbols, idx));
		return _t1;
	}
	v__ast__Table_panic(t,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("final_sym: invalid type (typ="), 0xfe07, {.d_i32 = typ}}, {_SLIT(" idx="), 0xfe07, {.d_i32 = idx}}, {_SLIT("). Compiler bug. This should never happen. Please report the bug using `v bug file.v`."), 0, { .d_c = 0 }}})));
	v__ast__TypeSymbol* _t2 = _const_v__ast__invalid_type_symbol;
	return _t2;
}

// Attr: [inline]
inline string v__ast__Table_get_type_name(v__ast__Table* t, v__ast__Type typ) {
	v__ast__TypeSymbol* sym = v__ast__Table_sym(t, typ);
	string _t1 = sym->name;
	return _t1;
}

// Attr: [inline]
inline v__ast__Type v__ast__Table_unalias_num_type(v__ast__Table* t, v__ast__Type typ) {
	v__ast__TypeSymbol* sym = v__ast__Table_sym(t, typ);
	if (sym->kind == v__ast__Kind__alias) {
		v__ast__Type pt = (/* as */ *(v__ast__Alias*)__as_cast((sym->info)._v__ast__Alias,(sym->info)._typ, 460) /*expected idx: 460, name: v.ast.Alias */ ).parent_type;
		if (pt <= _const_v__ast__char_type && pt >= _const_v__ast__void_type) {
			v__ast__Type _t1 = pt;
			return _t1;
		}
	}
	v__ast__Type _t2 = typ;
	return _t2;
}

// Attr: [inline]
inline v__ast__Type v__ast__Table_unaliased_type(v__ast__Table* t, v__ast__Type typ) {
	v__ast__TypeSymbol* sym = v__ast__Table_sym(t, typ);
	if (sym->kind == v__ast__Kind__alias) {
		v__ast__Type pt = (/* as */ *(v__ast__Alias*)__as_cast((sym->info)._v__ast__Alias,(sym->info)._typ, 460) /*expected idx: 460, name: v.ast.Alias */ ).parent_type;
		v__ast__Type _t1 = pt;
		return _t1;
	}
	v__ast__Type _t2 = typ;
	return _t2;
}

VV_LOCAL_SYMBOL int v__ast__Table_rewrite_already_registered_symbol(v__ast__Table* t, v__ast__TypeSymbol typ, int existing_idx) {
	v__ast__TypeSymbol* existing_symbol = (*(v__ast__TypeSymbol**)/*ee elem_typ */array_get(t->type_symbols, existing_idx));
	if (existing_symbol->kind == v__ast__Kind__placeholder) {
		(*(v__ast__TypeSymbol**)/*ee elem_typ */array_get(t->type_symbols, existing_idx)) = (v__ast__TypeSymbol*)memdup(&(v__ast__TypeSymbol){typ.parent_idx,typ.info,typ.kind,typ.name,typ.cname,.methods = existing_symbol->methods,typ.mod,typ.is_public,typ.language,typ.idx,}, sizeof(v__ast__TypeSymbol));
		int _t1 = existing_idx;
		return _t1;
	}
	if ((existing_idx >= _const_v__ast__string_type_idx && existing_idx <= _const_v__ast__map_type_idx) || existing_idx == _const_v__ast__error_type_idx) {
		if (existing_idx == _const_v__ast__string_type_idx) {
			{ // Unsafe block
				*existing_symbol = *(v__ast__TypeSymbol*)memdup(&(v__ast__TypeSymbol){typ.parent_idx,typ.info,.kind = existing_symbol->kind,typ.name,typ.cname,typ.methods,typ.mod,typ.is_public,typ.language,typ.idx,}, sizeof(v__ast__TypeSymbol));
			}
		} else {
			(*(v__ast__TypeSymbol**)/*ee elem_typ */array_get(t->type_symbols, existing_idx)) = (v__ast__TypeSymbol*)memdup(&(v__ast__TypeSymbol){typ.parent_idx,typ.info,typ.kind,typ.name,typ.cname,typ.methods,typ.mod,typ.is_public,typ.language,typ.idx,}, sizeof(v__ast__TypeSymbol));
		}
		int _t2 = existing_idx;
		return _t2;
	}
	int _t3 = -1;
	return _t3;
}

// Attr: [inline]
inline int v__ast__Table_register_type_symbol(v__ast__Table* t, v__ast__TypeSymbol sym) {
	int idx = -2;
	int existing_idx = (*(int*)map_get(ADDR(map, t->type_idxs), &(string[]){sym.name}, &(int[]){ 0 }));
	if (existing_idx > 0) {
		idx = v__ast__Table_rewrite_already_registered_symbol(t, sym, existing_idx);
		if (idx != -2) {
			int _t1 = idx;
			return _t1;
		}
	}
	if (string__eq(sym.mod, _SLIT("main"))) {
		existing_idx = (*(int*)map_get(ADDR(map, t->type_idxs), &(string[]){string_trim_string_left(sym.name, _SLIT("main."))}, &(int[]){ 0 }));
		if (existing_idx > 0) {
			idx = v__ast__Table_rewrite_already_registered_symbol(t, sym, existing_idx);
			if (idx != -2) {
				int _t2 = idx;
				return _t2;
			}
		}
	}
	idx = t->type_symbols.len;
	array_push((array*)&t->type_symbols, _MOV((v__ast__TypeSymbol*[]){ (v__ast__TypeSymbol*)memdup(&(v__ast__TypeSymbol){sym.parent_idx,sym.info,sym.kind,sym.name,sym.cname,sym.methods,sym.mod,sym.is_public,sym.language,sym.idx,}, sizeof(v__ast__TypeSymbol)) }));
	(*(v__ast__TypeSymbol**)/*ee elem_typ */array_get(t->type_symbols, idx))->idx = idx;
	map_set(&t->type_idxs, &(string[]){sym.name}, &(int[]) { idx });
	int _t4 = idx;
	return _t4;
}

// Attr: [inline]
inline void v__ast__Table_register_enum_decl(v__ast__Table* t, v__ast__EnumDecl enum_decl) {
	(*(v__ast__EnumDecl*)map_get_and_set((map*)&t->enum_decls, &(string[]){enum_decl.name}, &(v__ast__EnumDecl[]){ (v__ast__EnumDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.is_pub = 0,.is_flag = 0,.is_multi_allowed = 0,.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.fields = __new_array(0, 0, sizeof(v__ast__EnumField)),.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},} })) = enum_decl;
}

bool v__ast__Table_known_type(v__ast__Table* t, string name) {
	bool _t1 = v__ast__Table_find_type_idx(t, name) != 0;
	return _t1;
}

bool v__ast__Table_known_type_idx(v__ast__Table* t, v__ast__Type typ) {
	if (typ == 0) {
		bool _t1 = false;
		return _t1;
	}
	v__ast__TypeSymbol* sym = v__ast__Table_sym(t, typ);

	if (sym->kind == (v__ast__Kind__placeholder)) {
		bool _t2 = sym->language != v__ast__Language__v || string_starts_with(sym->name, _SLIT("C."));
		return _t2;
	}
	else if (sym->kind == (v__ast__Kind__array)) {
		bool _t3 = v__ast__Table_known_type_idx(t, (/* as */ *(v__ast__Array*)__as_cast((sym->info)._v__ast__Array,(sym->info)._typ, 441) /*expected idx: 441, name: v.ast.Array */ ).elem_type);
		return _t3;
	}
	else if (sym->kind == (v__ast__Kind__array_fixed)) {
		bool _t4 = v__ast__Table_known_type_idx(t, (/* as */ *(v__ast__ArrayFixed*)__as_cast((sym->info)._v__ast__ArrayFixed,(sym->info)._typ, 468) /*expected idx: 468, name: v.ast.ArrayFixed */ ).elem_type);
		return _t4;
	}
	else if (sym->kind == (v__ast__Kind__map)) {
		v__ast__Map info = /* as */ *(v__ast__Map*)__as_cast((sym->info)._v__ast__Map,(sym->info)._typ, 442) /*expected idx: 442, name: v.ast.Map */ ;
		bool _t5 = v__ast__Table_known_type_idx(t, info.key_type) && v__ast__Table_known_type_idx(t, info.value_type);
		return _t5;
	}
	else {
	};
	bool _t6 = true;
	return _t6;
}

// Attr: [inline]
inline string v__ast__Table_array_name(v__ast__Table* t, v__ast__Type elem_type) {
	v__ast__TypeSymbol* elem_type_sym = v__ast__Table_sym(t, elem_type);
	string ptr = (v__ast__Type_is_ptr(elem_type) ? (string_repeat(_SLIT("&"), v__ast__Type_nr_muls(elem_type))) : (_SLIT("")));
	string _t1 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("[]"), 0xfe10, {.d_s = ptr}}, {_SLIT0, 0xfe10, {.d_s = elem_type_sym->name}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t1;
}

// Attr: [inline]
inline string v__ast__Table_array_cname(v__ast__Table* t, v__ast__Type elem_type) {
	v__ast__TypeSymbol* elem_type_sym = v__ast__Table_sym(t, elem_type);
	string res = _SLIT("");
	if (v__ast__Type_is_ptr(elem_type)) {
		res = string_repeat(_SLIT("_ptr"), v__ast__Type_nr_muls(elem_type));
	}
	if (string_contains(elem_type_sym->cname, _SLIT("<"))) {
		string type_name = string_replace_each(elem_type_sym->cname, new_array_from_c_array(6, 6, sizeof(string), _MOV((string[6]){_SLIT("<"), _SLIT("_T_"), _SLIT(", "), _SLIT("_"), _SLIT(">"), _SLIT("")})));
		string _t1 = string__plus( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Array_"), 0xfe10, {.d_s = type_name}}, {_SLIT0, 0, { .d_c = 0 }}})), res);
		return _t1;
	} else {
		string _t2 = string__plus( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Array_"), 0xfe10, {.d_s = elem_type_sym->cname}}, {_SLIT0, 0, { .d_c = 0 }}})), res);
		return _t2;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [inline]
inline string v__ast__Table_array_fixed_name(v__ast__Table* t, v__ast__Type elem_type, int size, v__ast__Expr size_expr) {
	v__ast__TypeSymbol* elem_type_sym = v__ast__Table_sym(t, elem_type);
	string ptr = (v__ast__Type_is_ptr(elem_type) ? (string_repeat(_SLIT("&"), v__ast__Type_nr_muls(elem_type))) : (_SLIT("")));
	string size_str = ((size_expr)._typ == 295 /* v.ast.EmptyExpr */ || size != 987654321 ? (int_str(size)) : (v__ast__Expr_str(size_expr)));
	string _t1 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT("["), 0xfe10, {.d_s = size_str}}, {_SLIT("]"), 0xfe10, {.d_s = ptr}}, {_SLIT0, 0xfe10, {.d_s = elem_type_sym->name}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t1;
}

// Attr: [inline]
inline string v__ast__Table_array_fixed_cname(v__ast__Table* t, v__ast__Type elem_type, int size) {
	v__ast__TypeSymbol* elem_type_sym = v__ast__Table_sym(t, elem_type);
	string res = _SLIT("");
	if (v__ast__Type_is_ptr(elem_type)) {
		res =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("_ptr"), 0xfe07, {.d_i32 = v__ast__Type_nr_muls(elem_type)}}, {_SLIT0, 0, { .d_c = 0 }}}));
	}
	string _t1 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT("Array_fixed_"), 0xfe10, {.d_s = elem_type_sym->cname}}, {_SLIT0, 0xfe10, {.d_s = res}}, {_SLIT("_"), 0xfe07, {.d_i32 = size}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t1;
}

// Attr: [inline]
inline string v__ast__Table_chan_name(v__ast__Table* t, v__ast__Type elem_type, bool is_mut) {
	v__ast__TypeSymbol* elem_type_sym = v__ast__Table_sym(t, elem_type);
	string ptr = _SLIT("");
	if (is_mut) {
		ptr = _SLIT("mut ");
	} else if (v__ast__Type_is_ptr(elem_type)) {
		ptr = _SLIT("&");
	}
	string _t1 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("chan "), 0xfe10, {.d_s = ptr}}, {_SLIT0, 0xfe10, {.d_s = elem_type_sym->name}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t1;
}

// Attr: [inline]
inline string v__ast__Table_chan_cname(v__ast__Table* t, v__ast__Type elem_type, bool is_mut) {
	v__ast__TypeSymbol* elem_type_sym = v__ast__Table_sym(t, elem_type);
	string suffix = _SLIT("");
	if (is_mut) {
		suffix = _SLIT("_mut");
	} else if (v__ast__Type_is_ptr(elem_type)) {
		suffix = _SLIT("_ptr");
	}
	string _t1 = string__plus( str_intp(2, _MOV((StrIntpData[]){{_SLIT("chan_"), 0xfe10, {.d_s = elem_type_sym->cname}}, {_SLIT0, 0, { .d_c = 0 }}})), suffix);
	return _t1;
}

// Attr: [inline]
inline string v__ast__Table_promise_name(v__ast__Table* t, v__ast__Type return_type) {
	if (v__ast__Type_idx(return_type) == _const_v__ast__void_type_idx) {
		string _t1 = _SLIT("Promise<JS.Any,JS.Any>");
		return _t1;
	}
	v__ast__TypeSymbol* return_type_sym = v__ast__Table_sym(t, return_type);
	string _t2 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("Promise<"), 0xfe10, {.d_s = return_type_sym->name}}, {_SLIT(", JS.Any>"), 0, { .d_c = 0 }}}));
	return _t2;
}

// Attr: [inline]
inline string v__ast__Table_promise_cname(v__ast__Table* t, v__ast__Type return_type) {
	if (v__ast__Type_alias_eq(return_type, _const_v__ast__void_type)) {
		string _t1 = _SLIT("Promise_Any_Any");
		return _t1;
	}
	v__ast__TypeSymbol* return_type_sym = v__ast__Table_sym(t, return_type);
	string _t2 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("Promise_"), 0xfe10, {.d_s = return_type_sym->name}}, {_SLIT("_Any"), 0, { .d_c = 0 }}}));
	return _t2;
}

// Attr: [inline]
inline string v__ast__Table_thread_name(v__ast__Table* t, v__ast__Type return_type) {
	if (v__ast__Type_idx(return_type) == _const_v__ast__void_type_idx) {
		if (v__ast__Type_has_flag(return_type, v__ast__TypeFlag__optional)) {
			string _t1 = _SLIT("thread ?");
			return _t1;
		} else {
			string _t2 = _SLIT("thread");
			return _t2;
		}
	}
	v__ast__TypeSymbol* return_type_sym = v__ast__Table_sym(t, return_type);
	string ptr = (v__ast__Type_is_ptr(return_type) ? (_SLIT("&")) : (_SLIT("")));
	string opt = (v__ast__Type_has_flag(return_type, v__ast__TypeFlag__optional) ? (_SLIT("?")) : (_SLIT("")));
	string _t3 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT("thread "), 0xfe10, {.d_s = opt}}, {_SLIT0, 0xfe10, {.d_s = ptr}}, {_SLIT0, 0xfe10, {.d_s = return_type_sym->name}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t3;
}

// Attr: [inline]
inline string v__ast__Table_thread_cname(v__ast__Table* t, v__ast__Type return_type) {
	if (v__ast__Type_alias_eq(return_type, _const_v__ast__void_type)) {
		if (v__ast__Type_has_flag(return_type, v__ast__TypeFlag__optional)) {
			string _t1 = _SLIT("__v_thread_Option_void");
			return _t1;
		} else {
			string _t2 = _SLIT("__v_thread");
			return _t2;
		}
	}
	v__ast__TypeSymbol* return_type_sym = v__ast__Table_sym(t, return_type);
	string suffix = (v__ast__Type_is_ptr(return_type) ? (_SLIT("_ptr")) : (_SLIT("")));
	string prefix = (v__ast__Type_has_flag(return_type, v__ast__TypeFlag__optional) ? (_SLIT("Option_")) : (_SLIT("")));
	string _t3 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT("__v_thread_"), 0xfe10, {.d_s = prefix}}, {_SLIT0, 0xfe10, {.d_s = return_type_sym->cname}}, {_SLIT0, 0xfe10, {.d_s = suffix}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t3;
}

// Attr: [inline]
inline string v__ast__Table_map_name(v__ast__Table* t, v__ast__Type key_type, v__ast__Type value_type) {
	v__ast__TypeSymbol* key_type_sym = v__ast__Table_sym(t, key_type);
	v__ast__TypeSymbol* value_type_sym = v__ast__Table_sym(t, value_type);
	string ptr = (v__ast__Type_is_ptr(value_type) ? (_SLIT("&")) : (_SLIT("")));
	string _t1 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT("map["), 0xfe10, {.d_s = key_type_sym->name}}, {_SLIT("]"), 0xfe10, {.d_s = ptr}}, {_SLIT0, 0xfe10, {.d_s = value_type_sym->name}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t1;
}

// Attr: [inline]
inline string v__ast__Table_map_cname(v__ast__Table* t, v__ast__Type key_type, v__ast__Type value_type) {
	v__ast__TypeSymbol* key_type_sym = v__ast__Table_sym(t, key_type);
	v__ast__TypeSymbol* value_type_sym = v__ast__Table_sym(t, value_type);
	string suffix = (v__ast__Type_is_ptr(value_type) ? (_SLIT("_ptr")) : (_SLIT("")));
	string _t1 = string__plus( str_intp(3, _MOV((StrIntpData[]){{_SLIT("Map_"), 0xfe10, {.d_s = key_type_sym->cname}}, {_SLIT("_"), 0xfe10, {.d_s = value_type_sym->cname}}, {_SLIT0, 0, { .d_c = 0 }}})), suffix);
	return _t1;
}

int v__ast__Table_find_or_register_chan(v__ast__Table* t, v__ast__Type elem_type, bool is_mut) {
	string name = v__ast__Table_chan_name(t, elem_type, is_mut);
	string cname = v__ast__Table_chan_cname(t, elem_type, is_mut);
	int existing_idx = (*(int*)map_get(ADDR(map, t->type_idxs), &(string[]){name}, &(int[]){ 0 }));
	if (existing_idx > 0) {
		int _t1 = existing_idx;
		return _t1;
	}
	v__ast__TypeSymbol chan_typ = (v__ast__TypeSymbol){.parent_idx = _const_v__ast__chan_type_idx,.info = v__ast__Chan_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__Chan, ((v__ast__Chan){.elem_type = elem_type,.is_mut = is_mut,}))),.kind = v__ast__Kind__chan,.name = name,.cname = cname,.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = (string){.str=(byteptr)"", .is_lit=1},.is_public = 0,.language = 0,.idx = 0,};
	int _t2 = v__ast__Table_register_type_symbol(t, chan_typ);
	return _t2;
}

int v__ast__Table_find_or_register_map(v__ast__Table* t, v__ast__Type key_type, v__ast__Type value_type) {
	string name = v__ast__Table_map_name(t, key_type, value_type);
	string cname = v__ast__Table_map_cname(t, key_type, value_type);
	int existing_idx = (*(int*)map_get(ADDR(map, t->type_idxs), &(string[]){name}, &(int[]){ 0 }));
	if (existing_idx > 0) {
		int _t1 = existing_idx;
		return _t1;
	}
	v__ast__TypeSymbol map_typ = (v__ast__TypeSymbol){.parent_idx = _const_v__ast__map_type_idx,.info = v__ast__Map_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__Map, ((v__ast__Map){.key_type = key_type,.value_type = value_type,}))),.kind = v__ast__Kind__map,.name = name,.cname = cname,.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = (string){.str=(byteptr)"", .is_lit=1},.is_public = 0,.language = 0,.idx = 0,};
	int _t2 = v__ast__Table_register_type_symbol(t, map_typ);
	return _t2;
}

int v__ast__Table_find_or_register_thread(v__ast__Table* t, v__ast__Type return_type) {
	string name = v__ast__Table_thread_name(t, return_type);
	string cname = v__ast__Table_thread_cname(t, return_type);
	int existing_idx = (*(int*)map_get(ADDR(map, t->type_idxs), &(string[]){name}, &(int[]){ 0 }));
	if (existing_idx > 0) {
		int _t1 = existing_idx;
		return _t1;
	}
	v__ast__TypeSymbol thread_typ = (v__ast__TypeSymbol){.parent_idx = _const_v__ast__thread_type_idx,.info = v__ast__Thread_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__Thread, ((v__ast__Thread){.return_type = return_type,}))),.kind = v__ast__Kind__thread,.name = name,.cname = cname,.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = (string){.str=(byteptr)"", .is_lit=1},.is_public = 0,.language = 0,.idx = 0,};
	int _t2 = v__ast__Table_register_type_symbol(t, thread_typ);
	return _t2;
}

int v__ast__Table_find_or_register_promise(v__ast__Table* t, v__ast__Type return_type) {
	string name = v__ast__Table_promise_name(t, return_type);
	string cname = v__ast__Table_promise_cname(t, return_type);
	int existing_idx = (*(int*)map_get(ADDR(map, t->type_idxs), &(string[]){name}, &(int[]){ 0 }));
	if (existing_idx > 0) {
		int _t1 = existing_idx;
		return _t1;
	}
	v__ast__TypeSymbol promise_type = (v__ast__TypeSymbol){.parent_idx = (*(int*)map_get(ADDR(map, t->type_idxs), &(string[]){_SLIT("Promise")}, &(int[]){ 0 })),.info = v__ast__Struct_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__Struct, ((v__ast__Struct){.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.embeds = __new_array(0, 0, sizeof(v__ast__Type)),.fields = __new_array(0, 0, sizeof(v__ast__StructField)),.is_typedef = 0,.is_union = 0,.is_heap = 0,.is_generic = 0,.generic_types = __new_array(0, 0, sizeof(v__ast__Type)),.concrete_types = new_array_from_c_array(2, 2, sizeof(v__ast__Type), _MOV((v__ast__Type[2]){return_type, (*(int*)map_get(ADDR(map, t->type_idxs), &(string[]){_SLIT("JS.Any")}, &(int[]){ 0 }))})),.parent_type = 0,}))),.kind = v__ast__Kind__struct_,.name = name,.cname = cname,.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = (string){.str=(byteptr)"", .is_lit=1},.is_public = 0,.language = 0,.idx = 0,};
	int _t2 = v__ast__Table_register_type_symbol(t, promise_type);
	return _t2;
}

int v__ast__Table_find_or_register_array(v__ast__Table* t, v__ast__Type elem_type) {
	string name = v__ast__Table_array_name(t, elem_type);
	int existing_idx = (*(int*)map_get(ADDR(map, t->type_idxs), &(string[]){name}, &(int[]){ 0 }));
	if (existing_idx > 0) {
		int _t1 = existing_idx;
		return _t1;
	}
	string cname = v__ast__Table_array_cname(t, elem_type);
	v__ast__TypeSymbol array_type_ = (v__ast__TypeSymbol){.parent_idx = _const_v__ast__array_type_idx,.info = v__ast__Array_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__Array, ((v__ast__Array){.nr_dims = 1,.elem_type = elem_type,}))),.kind = v__ast__Kind__array,.name = name,.cname = cname,.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = (string){.str=(byteptr)"", .is_lit=1},.is_public = 0,.language = 0,.idx = 0,};
	int _t2 = v__ast__Table_register_type_symbol(t, array_type_);
	return _t2;
}

int v__ast__Table_find_or_register_array_with_dims(v__ast__Table* t, v__ast__Type elem_type, int nr_dims) {
	if (nr_dims == 1) {
		int _t1 = v__ast__Table_find_or_register_array(t, elem_type);
		return _t1;
	}
	int _t2 = v__ast__Table_find_or_register_array(t, v__ast__Table_find_or_register_array_with_dims(t, elem_type, nr_dims - 1));
	return _t2;
}

int v__ast__Table_find_or_register_array_fixed(v__ast__Table* t, v__ast__Type elem_type, int size, v__ast__Expr size_expr) {
	string name = v__ast__Table_array_fixed_name(t, elem_type, size, size_expr);
	int existing_idx = (*(int*)map_get(ADDR(map, t->type_idxs), &(string[]){name}, &(int[]){ 0 }));
	if (existing_idx > 0) {
		int _t1 = existing_idx;
		return _t1;
	}
	string cname = v__ast__Table_array_fixed_cname(t, elem_type, size);
	v__ast__TypeSymbol array_fixed_type = (v__ast__TypeSymbol){.parent_idx = 0,.info = v__ast__ArrayFixed_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__ArrayFixed, ((v__ast__ArrayFixed){.size = size,.size_expr = size_expr,.elem_type = elem_type,}))),.kind = v__ast__Kind__array_fixed,.name = name,.cname = cname,.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = (string){.str=(byteptr)"", .is_lit=1},.is_public = 0,.language = 0,.idx = 0,};
	int _t2 = v__ast__Table_register_type_symbol(t, array_fixed_type);
	return _t2;
}

int v__ast__Table_find_or_register_multi_return(v__ast__Table* t, Array_v__ast__Type mr_typs) {
	string name = _SLIT("(");
	string cname = _SLIT("multi_return");
	for (int i = 0; i < mr_typs.len; ++i) {
		v__ast__Type mr_typ = ((v__ast__Type*)mr_typs.data)[i];
		v__ast__TypeSymbol* mr_type_sym = v__ast__Table_sym(t, mr_typ);
		multi_return_string_string mr_28916 = (v__ast__Type_is_ptr(mr_typ) ? ((multi_return_string_string){.arg0=_SLIT("&"),.arg1=_SLIT("ref_")}) : ((multi_return_string_string){.arg0=_SLIT(""),.arg1=_SLIT("")}));
		string ref = mr_28916.arg0;
		string cref = mr_28916.arg1;
		name = /*f*/string__plus(name,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ref}}, {_SLIT0, 0xfe10, {.d_s = mr_type_sym->name}}, {_SLIT0, 0, { .d_c = 0 }}})));
		cname = /*f*/string__plus(cname,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("_"), 0xfe10, {.d_s = cref}}, {_SLIT0, 0xfe10, {.d_s = mr_type_sym->cname}}, {_SLIT0, 0, { .d_c = 0 }}})));
		if (i < mr_typs.len - 1) {
			name = /*f*/string__plus(name, _SLIT(", "));
		}
	}
	name = /*f*/string__plus(name, _SLIT(")"));
	int existing_idx = (*(int*)map_get(ADDR(map, t->type_idxs), &(string[]){name}, &(int[]){ 0 }));
	if (existing_idx > 0) {
		int _t1 = existing_idx;
		return _t1;
	}
	v__ast__TypeSymbol mr_type = (v__ast__TypeSymbol){.parent_idx = 0,.info = v__ast__MultiReturn_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__MultiReturn, ((v__ast__MultiReturn){.types = mr_typs,}))),.kind = v__ast__Kind__multi_return,.name = name,.cname = cname,.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = (string){.str=(byteptr)"", .is_lit=1},.is_public = 0,.language = 0,.idx = 0,};
	int _t2 = v__ast__Table_register_type_symbol(t, mr_type);
	return _t2;
}

int v__ast__Table_find_or_register_fn_type(v__ast__Table* t, string mod, v__ast__Fn f, bool is_anon, bool has_decl) {
	string name = (f.name.len == 0 ? ( str_intp(2, _MOV((StrIntpData[]){{_SLIT("fn "), 0xfe10, {.d_s = v__ast__Table_fn_type_source_signature(t, (voidptr)&/*qq*/f)}}, {_SLIT0, 0, { .d_c = 0 }}}))) : (string_clone(f.name)));
	string cname = (f.name.len == 0 ? ( str_intp(2, _MOV((StrIntpData[]){{_SLIT("anon_fn_"), 0xfe10, {.d_s = v__ast__Table_fn_type_signature(t, (voidptr)&/*qq*/f)}}, {_SLIT0, 0, { .d_c = 0 }}}))) : (v__util__no_dots(string_clone(f.name))));
	bool anon = f.name.len == 0 || is_anon;
	int existing_idx = (*(int*)map_get(ADDR(map, t->type_idxs), &(string[]){name}, &(int[]){ 0 }));
	if (existing_idx > 0 && (*(v__ast__TypeSymbol**)/*ee elem_typ */array_get(t->type_symbols, existing_idx))->kind != v__ast__Kind__placeholder) {
		int _t1 = existing_idx;
		return _t1;
	}
	int _t2 = v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = v__ast__FnType_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__FnType, ((v__ast__FnType){.is_anon = anon,.has_decl = has_decl,.func = f,}))),.kind = v__ast__Kind__function,.name = name,.cname = cname,.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = mod,.is_public = 0,.language = 0,.idx = 0,});
	return _t2;
}

int v__ast__Table_add_placeholder_type(v__ast__Table* t, string name, v__ast__Language language) {
	string modname = _SLIT("");
	if (string_contains(name, _SLIT("."))) {
		modname = string_all_before_last(name, _SLIT("."));
	}
	v__ast__TypeSymbol ph_type = (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind__placeholder,.name = name,.cname = v__util__no_dots(name),.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = modname,.is_public = 0,.language = language,.idx = 0,};
	int _t1 = v__ast__Table_register_type_symbol(t, ph_type);
	return _t1;
}

// Attr: [inline]
inline v__ast__Type v__ast__Table_value_type(v__ast__Table* t, v__ast__Type typ) {
	v__ast__TypeSymbol* sym = v__ast__Table_final_sym(t, typ);
	if (v__ast__Type_has_flag(typ, v__ast__TypeFlag__variadic)) {
		v__ast__Array array_info = /* as */ *(v__ast__Array*)__as_cast((sym->info)._v__ast__Array,(sym->info)._typ, 441) /*expected idx: 441, name: v.ast.Array */ ;
		v__ast__Type _t1 = array_info.elem_type;
		return _t1;
	}
	if (sym->kind == v__ast__Kind__array) {
		v__ast__Array info = /* as */ *(v__ast__Array*)__as_cast((sym->info)._v__ast__Array,(sym->info)._typ, 441) /*expected idx: 441, name: v.ast.Array */ ;
		v__ast__Type _t2 = info.elem_type;
		return _t2;
	}
	if (sym->kind == v__ast__Kind__array_fixed) {
		v__ast__ArrayFixed info = /* as */ *(v__ast__ArrayFixed*)__as_cast((sym->info)._v__ast__ArrayFixed,(sym->info)._typ, 468) /*expected idx: 468, name: v.ast.ArrayFixed */ ;
		v__ast__Type _t3 = info.elem_type;
		return _t3;
	}
	if (sym->kind == v__ast__Kind__map) {
		v__ast__Map info = /* as */ *(v__ast__Map*)__as_cast((sym->info)._v__ast__Map,(sym->info)._typ, 442) /*expected idx: 442, name: v.ast.Map */ ;
		v__ast__Type _t4 = info.value_type;
		return _t4;
	}
	if (sym->kind == v__ast__Kind__string && v__ast__Type_is_ptr(typ)) {
		v__ast__Type _t5 = _const_v__ast__string_type;
		return _t5;
	}
	if (sym->kind == v__ast__Kind__byteptr || sym->kind == v__ast__Kind__string) {
		v__ast__Type _t6 = _const_v__ast__byte_type;
		return _t6;
	}
	if (v__ast__Type_is_ptr(typ)) {
		v__ast__Type _t7 = v__ast__Type_deref(typ);
		return _t7;
	}
	v__ast__Type _t8 = _const_v__ast__void_type;
	return _t8;
}

void v__ast__Table_register_fn_generic_types(v__ast__Table* t, string fn_name) {
	map_set(&t->fn_generic_types, &(string[]){fn_name}, &(Array_Array_v__ast__Type[]) { __new_array_with_default(0, 0, sizeof(Array_v__ast__Type), 0) });
}

bool v__ast__Table_register_fn_concrete_types(v__ast__Table* t, string fn_name, Array_v__ast__Type types) {
	Array_Array_v__ast__Type* _t2 = (Array_Array_v__ast__Type*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, t->fn_generic_types), &(string[]){fn_name}));
	Option_Array_Array_v__ast__Type _t1 = {0};
	if (_t2) {
		*((Array_Array_v__ast__Type*)&_t1.data) = *((Array_Array_v__ast__Type*)_t2);
	} else {
		_t1.state = 2; _t1.err = _v_error(_SLIT("array index out of range"));
	}
	;
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		bool _t3 = false;
		return _t3;
	}
	
	Array_Array_v__ast__Type a = *(Array_Array_v__ast__Type*)_t1.data;
	if (Array_Array_v__ast__Type_contains(a, types)) {
		bool _t4 = false;
		return _t4;
	}
	array_push((array*)&a, _MOV((Array_v__ast__Type[]){ types }));
	map_set(&t->fn_generic_types, &(string[]){fn_name}, &(Array_Array_v__ast__Type[]) { a });
	bool _t6 = true;
	return _t6;
}

bool v__ast__Table_sumtype_has_variant(v__ast__Table* t, v__ast__Type parent, v__ast__Type variant, bool is_as) {
	v__ast__TypeSymbol* parent_sym = v__ast__Table_sym(t, parent);
	if (parent_sym->kind == v__ast__Kind__sum_type) {
		v__ast__SumType parent_info = /* as */ *(v__ast__SumType*)__as_cast((parent_sym->info)._v__ast__SumType,(parent_sym->info)._typ, 464) /*expected idx: 464, name: v.ast.SumType */ ;
		v__ast__TypeSymbol* var_sym = v__ast__Table_sym(t, variant);
		if (var_sym->kind == v__ast__Kind__aggregate) {
			v__ast__Aggregate var_info = /* as */ *(v__ast__Aggregate*)__as_cast((var_sym->info)._v__ast__Aggregate,(var_sym->info)._typ, 458) /*expected idx: 458, name: v.ast.Aggregate */ ;
			for (int _t1 = 0; _t1 < var_info.types.len; ++_t1) {
				v__ast__Type var_type = ((v__ast__Type*)var_info.types.data)[_t1];
				if (!v__ast__Table_sumtype_has_variant(t, parent, var_type, is_as)) {
					bool _t2 = false;
					return _t2;
				}
			}
			bool _t3 = true;
			return _t3;
		} else {
			for (int _t4 = 0; _t4 < parent_info.variants.len; ++_t4) {
				v__ast__Type v = ((v__ast__Type*)parent_info.variants.data)[_t4];
				if (v__ast__Type_idx(v) == v__ast__Type_idx(variant) && (!is_as || v__ast__Type_nr_muls(v) == v__ast__Type_nr_muls(variant))) {
					bool _t5 = true;
					return _t5;
				}
			}
		}
	}
	bool _t6 = false;
	return _t6;
}

Array_string v__ast__Table_known_type_names(v__ast__Table* t) {
	Array_string res = __new_array_with_default(0, t->type_idxs.len, sizeof(string), 0);
	Map_string_int _t1 = t->type_idxs;
	int _t3 = _t1.key_values.len;
	for (int _t2 = 0; _t2 < _t3; ++_t2 ) {
		int _t4 = _t1.key_values.len - _t3;
		_t3 = _t1.key_values.len;
		if (_t4 < 0) {
			_t2 = -1;
			continue;
		}
		if (!DenseArray_has_index(&_t1.key_values, _t2)) {continue;}
		int idx = (*(int*)DenseArray_value(&_t1.key_values, _t2));
		if (!(idx == 0 || idx == _const_v__ast__int_literal_type_idx || idx == _const_v__ast__float_literal_type_idx) && v__ast__Table_known_type_idx(t, idx) && v__ast__Table_sym(t, idx)->kind != v__ast__Kind__function) {
			array_push((array*)&res, _MOV((string[]){ string_clone(v__ast__Table_type_to_str(t, idx)) }));
		}
	}
	Array_string _t6 = res;
	return _t6;
}

bool v__ast__Table_has_deep_child_no_ref(v__ast__Table* t, v__ast__TypeSymbol* ts, string name) {
	if ((ts->info)._typ == 446 /* v.ast.Struct */) {
		for (int _t1 = 0; _t1 < (*ts->info._v__ast__Struct).fields.len; ++_t1) {
			v__ast__StructField field = ((v__ast__StructField*)(*ts->info._v__ast__Struct).fields.data)[_t1];
			v__ast__TypeSymbol* sym = v__ast__Table_sym(t, field.typ);
			if (!v__ast__Type_is_ptr(field.typ) && (string__eq(sym->name, name) || v__ast__Table_has_deep_child_no_ref(t, sym, name))) {
				bool _t2 = true;
				return _t2;
			}
		}
	}
	bool _t3 = false;
	return _t3;
}

void v__ast__Table_complete_interface_check(v__ast__Table* t) {
bool v__ast__Table_complete_interface_check_defer_0 = false;
	v__util__timing_start(_SLIT("Table.complete_interface_check"));
	v__ast__Table_complete_interface_check_defer_0 = true;
	for (int tk = 0; tk < t->type_symbols.len; ++tk) {
		v__ast__TypeSymbol** tsym = ((v__ast__TypeSymbol**)t->type_symbols.data) + tk;
		if ((*tsym)->kind != v__ast__Kind__struct_) {
			continue;
		}
		v__ast__Struct info = /* as */ *(v__ast__Struct*)__as_cast(((*tsym)->info)._v__ast__Struct,((*tsym)->info)._typ, 446) /*expected idx: 446, name: v.ast.Struct */ ;
		Map_int_v__ast__InterfaceDecl _t1 = t->interfaces;
		int _t3 = _t1.key_values.len;
		for (int _t2 = 0; _t2 < _t3; ++_t2 ) {
			int _t4 = _t1.key_values.len - _t3;
			_t3 = _t1.key_values.len;
			if (_t4 < 0) {
				_t2 = -1;
				continue;
			}
			if (!DenseArray_has_index(&_t1.key_values, _t2)) {continue;}
			v__ast__InterfaceDecl* idecl = &(*(v__ast__InterfaceDecl*)DenseArray_value(&_t1.key_values, _t2));
			if (idecl->methods.len > (*tsym)->methods.len) {
				continue;
			}
			if (idecl->fields.len > info.fields.len) {
				continue;
			}
			if (idecl->typ == 0) {
				continue;
			}
			if (idecl->methods.len == 0 && idecl->fields.len == 0 && !string__eq((*tsym)->mod, v__ast__Table_sym(t, idecl->typ)->mod)) {
				continue;
			}
			if (v__ast__Table_does_type_implement_interface(t, tk, idecl->typ)) {
				array_push((array*)&(*(Array_v__ast__Type*)map_get_and_set((map*)&t->iface_types, &(string[]){idecl->name}, &(Array_v__ast__Type[]){ __new_array(0, 0, sizeof(v__ast__Type)) })), _MOV((v__ast__Type[]){ tk }));
			}
		}
	}
// Defer begin
if (v__ast__Table_complete_interface_check_defer_0) {
	v__util__timing_measure(_SLIT("Table.complete_interface_check"));
}
// Defer end
}

v__ast__Type v__ast__Table_bitsize_to_type(v__ast__Table* t, int bit_size) {

	if (bit_size == (8)) {
		v__ast__Type _t1 = _const_v__ast__i8_type;
		return _t1;
	}
	else if (bit_size == (16)) {
		v__ast__Type _t2 = _const_v__ast__i16_type;
		return _t2;
	}
	else if (bit_size == (32)) {
		v__ast__Type _t3 = _const_v__ast__int_type;
		return _t3;
	}
	else if (bit_size == (64)) {
		v__ast__Type _t4 = _const_v__ast__i64_type;
		return _t4;
	}
	else {
		if (bit_size % 8 != 0) {
			v__ast__Table_panic(t, _SLIT("compiler bug: bitsizes must be multiples of 8"));
		}
		v__ast__Type _t5 = v__ast__new_type(v__ast__Table_find_or_register_array_fixed(t, _const_v__ast__byte_type, bit_size / 8, v__ast__empty_expr()));
		return _t5;
	};
	return 0;
}

bool v__ast__Table_does_type_implement_interface(v__ast__Table* t, v__ast__Type typ, v__ast__Type inter_typ) {
	if (v__ast__Type_idx(typ) == v__ast__Type_idx(inter_typ)) {
		bool _t1 = true;
		return _t1;
	}
	if (v__ast__Type_idx(inter_typ) == _const_v__ast__error_type_idx && v__ast__Type_idx(typ) == _const_v__ast__none_type_idx) {
		bool _t2 = true;
		return _t2;
	}
	v__ast__TypeSymbol* sym = v__ast__Table_sym(t, typ);
	if (sym->language != v__ast__Language__v) {
		bool _t3 = false;
		return _t3;
	}
	if ((sym->info)._typ == 446 /* v.ast.Struct */) {
		if ((*sym->info._v__ast__Struct).is_generic) {
			bool _t4 = false;
			return _t4;
		}
	}
	v__ast__TypeSymbol* inter_sym = v__ast__Table_sym(t, inter_typ);
	if (sym->kind == v__ast__Kind__interface_ && inter_sym->kind == v__ast__Kind__interface_) {
		bool _t5 = false;
		return _t5;
	}
	if ((inter_sym->info)._typ == 463 /* v.ast.Interface */) {
		Array_v__ast__Attr attrs = (*(v__ast__InterfaceDecl*)map_get(ADDR(map, t->interfaces), &(int[]){inter_typ}, &(v__ast__InterfaceDecl[]){ (v__ast__InterfaceDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,.name_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.field_names = __new_array(0, 0, sizeof(string)),.is_pub = 0,.mut_pos = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.pre_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = __new_array(0, 0, sizeof(v__ast__Type)),.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.methods = __new_array(0, 0, sizeof(v__ast__FnDecl)),.fields = __new_array(0, 0, sizeof(v__ast__StructField)),.ifaces = __new_array(0, 0, sizeof(v__ast__InterfaceEmbedding)),.are_ifaces_expanded = 0,} })).attrs;
		for (int _t6 = 0; _t6 < attrs.len; ++_t6) {
			v__ast__Attr attr = ((v__ast__Attr*)attrs.data)[_t6];
			if (string__eq(attr.name, _SLIT("single_impl"))) {
				bool _t7 = false;
				return _t7;
			}
		}
		for (int _t8 = 0; _t8 < (*inter_sym->info._v__ast__Interface).types.len; ++_t8) {
			v__ast__Type tt = ((v__ast__Type*)(*inter_sym->info._v__ast__Interface).types.data)[_t8];
			if (v__ast__Type_idx(tt) == v__ast__Type_idx(typ)) {
				bool _t9 = true;
				return _t9;
			}
		}
		for (int _t10 = 0; _t10 < (*inter_sym->info._v__ast__Interface).methods.len; ++_t10) {
			v__ast__Fn imethod = ((v__ast__Fn*)(*inter_sym->info._v__ast__Interface).methods.data)[_t10];
			Option_v__ast__Fn _t11;
			if (_t11 = v__ast__TypeSymbol_find_method(sym, imethod.name), _t11.state == 0) {
				v__ast__Fn method = *(v__ast__Fn*)_t11.data;
				string msg = v__ast__Table_is_same_method(t, (voidptr)&/*qq*/imethod, (voidptr)&/*qq*/method);
				if (msg.len > 0) {
					bool _t12 = false;
					return _t12;
				}
				continue;
			}
			bool _t13 = false;
			return _t13;
		}
		for (int _t14 = 0; _t14 < (*inter_sym->info._v__ast__Interface).fields.len; ++_t14) {
			v__ast__StructField ifield = ((v__ast__StructField*)(*inter_sym->info._v__ast__Interface).fields.data)[_t14];
			if (v__ast__Type_alias_eq(ifield.typ, _const_v__ast__voidptr_type)) {
				if (v__ast__Table_struct_has_field(t, sym, ifield.name)) {
					continue;
				} else {
					bool _t15 = false;
					return _t15;
				}
			}
			Option_v__ast__StructField _t16;
			if (_t16 = v__ast__Table_find_field_with_embeds(t, sym, ifield.name), _t16.state == 0) {
				v__ast__StructField field = *(v__ast__StructField*)_t16.data;
				if (!v__ast__Type_alias_eq(ifield.typ, field.typ)) {
					bool _t17 = false;
					return _t17;
				} else if (ifield.is_mut && !(field.is_mut || field.is_global)) {
					bool _t18 = false;
					return _t18;
				}
				continue;
			}
			bool _t19 = false;
			return _t19;
		}
		array_push((array*)&(*inter_sym->info._v__ast__Interface).types, _MOV((v__ast__Type[]){ typ }));
		if (!Array_v__ast__Type_contains((*inter_sym->info._v__ast__Interface).types, _const_v__ast__voidptr_type)) {
			array_push((array*)&(*inter_sym->info._v__ast__Interface).types, _MOV((v__ast__Type[]){ _const_v__ast__voidptr_type }));
		}
		bool _t22 = true;
		return _t22;
	}
	bool _t23 = false;
	return _t23;
}

Option_v__ast__Type v__ast__Table_resolve_generic_to_concrete(v__ast__Table* t, v__ast__Type generic_type, Array_string generic_names, Array_v__ast__Type concrete_types) {
	v__ast__TypeSymbol* sym = v__ast__Table_sym(t, generic_type);
	if (Array_string_contains(generic_names, sym->name)) {
		int index = Array_string_index(generic_names, sym->name);
		if (index >= concrete_types.len) {
			return (Option_v__ast__Type){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		v__ast__Type typ = (*(v__ast__Type*)/*ee elem_typ */array_get(concrete_types, index));
		if (typ == 0) {
			return (Option_v__ast__Type){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		Option_v__ast__Type _t3;
		opt_ok(&(v__ast__Type[]) { v__ast__Type_clear_flag(v__ast__Type_derive_add_muls(typ, generic_type), v__ast__TypeFlag__generic) }, (Option*)(&_t3), sizeof(v__ast__Type));
		return _t3;
	}
	if (sym->info._typ == 441 /* v.ast.Array */) {
		v__ast__Type elem_type = (*sym->info._v__ast__Array).elem_type;
		v__ast__TypeSymbol* elem_sym = v__ast__Table_sym(t, elem_type);
		int dims = 1;
		for (;;) {
			if (!((elem_sym->info)._typ == 441 /* v.ast.Array */)) break;
			v__ast__Array info = /* as */ *(v__ast__Array*)__as_cast((elem_sym->info)._v__ast__Array,(elem_sym->info)._typ, 441) /*expected idx: 441, name: v.ast.Array */ ;
			elem_type = info.elem_type;
			elem_sym = v__ast__Table_sym(t, elem_type);
			dims++;
		}
		Option_v__ast__Type _t4;
		if (_t4 = v__ast__Table_resolve_generic_to_concrete(t, elem_type, generic_names, concrete_types), _t4.state == 0) {
			v__ast__Type typ = *(v__ast__Type*)_t4.data;
			int idx = v__ast__Table_find_or_register_array_with_dims(t, typ, dims);
			Option_v__ast__Type _t5;
			opt_ok(&(v__ast__Type[]) { v__ast__Type_clear_flag(v__ast__Type_derive_add_muls(v__ast__new_type(idx), generic_type), v__ast__TypeFlag__generic) }, (Option*)(&_t5), sizeof(v__ast__Type));
			return _t5;
		}
	}
	else if (sym->info._typ == 468 /* v.ast.ArrayFixed */) {
		Option_v__ast__Type _t6;
		if (_t6 = v__ast__Table_resolve_generic_to_concrete(t, (*sym->info._v__ast__ArrayFixed).elem_type, generic_names, concrete_types), _t6.state == 0) {
			v__ast__Type typ = *(v__ast__Type*)_t6.data;
			int idx = v__ast__Table_find_or_register_array_fixed(t, typ, (*sym->info._v__ast__ArrayFixed).size, v__ast__None_to_sumtype_v__ast__Expr(ADDR(v__ast__None, ((v__ast__None){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},}))));
			Option_v__ast__Type _t7;
			opt_ok(&(v__ast__Type[]) { v__ast__Type_clear_flag(v__ast__Type_derive_add_muls(v__ast__new_type(idx), generic_type), v__ast__TypeFlag__generic) }, (Option*)(&_t7), sizeof(v__ast__Type));
			return _t7;
		}
	}
	else if (sym->info._typ == 469 /* v.ast.Chan */) {
		Option_v__ast__Type _t8;
		if (_t8 = v__ast__Table_resolve_generic_to_concrete(t, (*sym->info._v__ast__Chan).elem_type, generic_names, concrete_types), _t8.state == 0) {
			v__ast__Type typ = *(v__ast__Type*)_t8.data;
			int idx = v__ast__Table_find_or_register_chan(t, typ, v__ast__Type_nr_muls(typ) > 0);
			Option_v__ast__Type _t9;
			opt_ok(&(v__ast__Type[]) { v__ast__Type_clear_flag(v__ast__Type_derive_add_muls(v__ast__new_type(idx), generic_type), v__ast__TypeFlag__generic) }, (Option*)(&_t9), sizeof(v__ast__Type));
			return _t9;
		}
	}
	else if (sym->info._typ == 472 /* v.ast.FnType */) {
		v__ast__Fn func = (*sym->info._v__ast__FnType).func;
		if (v__ast__Type_has_flag(func.return_type, v__ast__TypeFlag__generic)) {
			Option_v__ast__Type _t10;
			if (_t10 = v__ast__Table_resolve_generic_to_concrete(t, func.return_type, generic_names, concrete_types), _t10.state == 0) {
				v__ast__Type typ = *(v__ast__Type*)_t10.data;
				func.return_type = typ;
			}
		}
		func.params = array_clone_to_depth(&func.params, 0);
		for (int _t11 = 0; _t11 < func.params.len; ++_t11) {
			v__ast__Param* param = ((v__ast__Param*)func.params.data) + _t11;
			if (v__ast__Type_has_flag(param->typ, v__ast__TypeFlag__generic)) {
				Option_v__ast__Type _t12;
				if (_t12 = v__ast__Table_resolve_generic_to_concrete(t, param->typ, generic_names, concrete_types), _t12.state == 0) {
					v__ast__Type typ = *(v__ast__Type*)_t12.data;
					param->typ = typ;
				}
			}
		}
		func.name = _SLIT("");
		int idx = v__ast__Table_find_or_register_fn_type(t, _SLIT(""), func, true, false);
		Option_v__ast__Type _t13;
		opt_ok(&(v__ast__Type[]) { v__ast__Type_clear_flag(v__ast__Type_derive_add_muls(v__ast__new_type(idx), generic_type), v__ast__TypeFlag__generic) }, (Option*)(&_t13), sizeof(v__ast__Type));
		return _t13;
	}
	else if (sym->info._typ == 471 /* v.ast.MultiReturn */) {
		Array_v__ast__Type types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
		bool type_changed = false;
		for (int _t14 = 0; _t14 < (*sym->info._v__ast__MultiReturn).types.len; ++_t14) {
			v__ast__Type ret_type = ((v__ast__Type*)(*sym->info._v__ast__MultiReturn).types.data)[_t14];
			Option_v__ast__Type _t15;
			if (_t15 = v__ast__Table_resolve_generic_to_concrete(t, ret_type, generic_names, concrete_types), _t15.state == 0) {
				v__ast__Type typ = *(v__ast__Type*)_t15.data;
				array_push((array*)&types, _MOV((v__ast__Type[]){ typ }));
				type_changed = true;
			} else {
				IError err = _t15.err;
				array_push((array*)&types, _MOV((v__ast__Type[]){ ret_type }));
			}
		}
		if (type_changed) {
			int idx = v__ast__Table_find_or_register_multi_return(t, types);
			Option_v__ast__Type _t18;
			opt_ok(&(v__ast__Type[]) { v__ast__Type_clear_flag(v__ast__Type_derive_add_muls(v__ast__new_type(idx), generic_type), v__ast__TypeFlag__generic) }, (Option*)(&_t18), sizeof(v__ast__Type));
			return _t18;
		}
	}
	else if (sym->info._typ == 442 /* v.ast.Map */) {
		bool type_changed = false;
		v__ast__Type unwrapped_key_type = (*sym->info._v__ast__Map).key_type;
		v__ast__Type unwrapped_value_type = (*sym->info._v__ast__Map).value_type;
		Option_v__ast__Type _t19;
		if (_t19 = v__ast__Table_resolve_generic_to_concrete(t, (*sym->info._v__ast__Map).key_type, generic_names, concrete_types), _t19.state == 0) {
			v__ast__Type typ = *(v__ast__Type*)_t19.data;
			unwrapped_key_type = typ;
			type_changed = true;
		}
		Option_v__ast__Type _t20;
		if (_t20 = v__ast__Table_resolve_generic_to_concrete(t, (*sym->info._v__ast__Map).value_type, generic_names, concrete_types), _t20.state == 0) {
			v__ast__Type typ = *(v__ast__Type*)_t20.data;
			unwrapped_value_type = typ;
			type_changed = true;
		}
		if (type_changed) {
			int idx = v__ast__Table_find_or_register_map(t, unwrapped_key_type, unwrapped_value_type);
			Option_v__ast__Type _t21;
			opt_ok(&(v__ast__Type[]) { v__ast__Type_clear_flag(v__ast__Type_derive_add_muls(v__ast__new_type(idx), generic_type), v__ast__TypeFlag__generic) }, (Option*)(&_t21), sizeof(v__ast__Type));
			return _t21;
		}
	}
	else if (sym->info._typ == 446 /* v.ast.Struct */) {
		if ((*sym->info._v__ast__Struct).is_generic) {
			string nrt =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = sym->name}}, {_SLIT("<"), 0, { .d_c = 0 }}}));
			for (int i = 0; i < (*sym->info._v__ast__Struct).generic_types.len; ++i) {
				Option_v__ast__Type _t22;
				if (_t22 = v__ast__Table_resolve_generic_to_concrete(t, (*(v__ast__Type*)/*ee elem_typ */array_get((*sym->info._v__ast__Struct).generic_types, i)), generic_names, concrete_types), _t22.state == 0) {
					v__ast__Type ct = *(v__ast__Type*)_t22.data;
					v__ast__TypeSymbol* gts = v__ast__Table_sym(t, ct);
					nrt = /*f*/string__plus(nrt, gts->name);
					if (i != (*sym->info._v__ast__Struct).generic_types.len - 1) {
						nrt = /*f*/string__plus(nrt, _SLIT(", "));
					}
				}
			}
			nrt = /*f*/string__plus(nrt, _SLIT(">"));
			int idx = (*(int*)map_get(ADDR(map, t->type_idxs), &(string[]){nrt}, &(int[]){ 0 }));
			if (idx == 0) {
				idx = v__ast__Table_add_placeholder_type(t, nrt, v__ast__Language__v);
			}
			Option_v__ast__Type _t23;
			opt_ok(&(v__ast__Type[]) { v__ast__Type_clear_flag(v__ast__Type_derive_add_muls(v__ast__new_type(idx), generic_type), v__ast__TypeFlag__generic) }, (Option*)(&_t23), sizeof(v__ast__Type));
			return _t23;
		}
	}
	else if (sym->info._typ == 463 /* v.ast.Interface */) {
		if ((*sym->info._v__ast__Interface).is_generic) {
			string nrt =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = sym->name}}, {_SLIT("<"), 0, { .d_c = 0 }}}));
			for (int i = 0; i < (*sym->info._v__ast__Interface).generic_types.len; ++i) {
				Option_v__ast__Type _t24;
				if (_t24 = v__ast__Table_resolve_generic_to_concrete(t, (*(v__ast__Type*)/*ee elem_typ */array_get((*sym->info._v__ast__Interface).generic_types, i)), generic_names, concrete_types), _t24.state == 0) {
					v__ast__Type ct = *(v__ast__Type*)_t24.data;
					v__ast__TypeSymbol* gts = v__ast__Table_sym(t, ct);
					nrt = /*f*/string__plus(nrt, gts->name);
					if (i != (*sym->info._v__ast__Interface).generic_types.len - 1) {
						nrt = /*f*/string__plus(nrt, _SLIT(", "));
					}
				}
			}
			nrt = /*f*/string__plus(nrt, _SLIT(">"));
			int idx = (*(int*)map_get(ADDR(map, t->type_idxs), &(string[]){nrt}, &(int[]){ 0 }));
			if (idx == 0) {
				idx = v__ast__Table_add_placeholder_type(t, nrt, v__ast__Language__v);
			}
			Option_v__ast__Type _t25;
			opt_ok(&(v__ast__Type[]) { v__ast__Type_clear_flag(v__ast__Type_derive_add_muls(v__ast__new_type(idx), generic_type), v__ast__TypeFlag__generic) }, (Option*)(&_t25), sizeof(v__ast__Type));
			return _t25;
		}
	}
	else if (sym->info._typ == 464 /* v.ast.SumType */) {
		if ((*sym->info._v__ast__SumType).is_generic) {
			string nrt =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = sym->name}}, {_SLIT("<"), 0, { .d_c = 0 }}}));
			for (int i = 0; i < (*sym->info._v__ast__SumType).generic_types.len; ++i) {
				Option_v__ast__Type _t26;
				if (_t26 = v__ast__Table_resolve_generic_to_concrete(t, (*(v__ast__Type*)/*ee elem_typ */array_get((*sym->info._v__ast__SumType).generic_types, i)), generic_names, concrete_types), _t26.state == 0) {
					v__ast__Type ct = *(v__ast__Type*)_t26.data;
					v__ast__TypeSymbol* gts = v__ast__Table_sym(t, ct);
					nrt = /*f*/string__plus(nrt, gts->name);
					if (i != (*sym->info._v__ast__SumType).generic_types.len - 1) {
						nrt = /*f*/string__plus(nrt, _SLIT(", "));
					}
				}
			}
			nrt = /*f*/string__plus(nrt, _SLIT(">"));
			int idx = (*(int*)map_get(ADDR(map, t->type_idxs), &(string[]){nrt}, &(int[]){ 0 }));
			if (idx == 0) {
				idx = v__ast__Table_add_placeholder_type(t, nrt, v__ast__Language__v);
			}
			Option_v__ast__Type _t27;
			opt_ok(&(v__ast__Type[]) { v__ast__Type_clear_flag(v__ast__Type_derive_add_muls(v__ast__new_type(idx), generic_type), v__ast__TypeFlag__generic) }, (Option*)(&_t27), sizeof(v__ast__Type));
			return _t27;
		}
	}
	
	else {
	}
	;
	return (Option_v__ast__Type){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
}

v__ast__Type v__ast__Table_unwrap_generic_type(v__ast__Table* t, v__ast__Type typ, Array_string generic_names, Array_v__ast__Type concrete_types) {
	Array_v__ast__Type final_concrete_types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
	Array_v__ast__StructField fields = __new_array_with_default(0, 0, sizeof(v__ast__StructField), 0);
	string nrt = _SLIT("");
	string c_nrt = _SLIT("");
	v__ast__TypeSymbol* ts = v__ast__Table_sym(t, typ);
	if (ts->info._typ == 441 /* v.ast.Array */) {
		v__ast__Type elem_type = (*ts->info._v__ast__Array).elem_type;
		v__ast__TypeSymbol* elem_sym = v__ast__Table_sym(t, elem_type);
		int dims = 1;
		for (;;) {
			if (!((elem_sym->info)._typ == 441 /* v.ast.Array */)) break;
			v__ast__Array info = /* as */ *(v__ast__Array*)__as_cast((elem_sym->info)._v__ast__Array,(elem_sym->info)._typ, 441) /*expected idx: 441, name: v.ast.Array */ ;
			elem_type = info.elem_type;
			elem_sym = v__ast__Table_sym(t, elem_type);
			dims++;
		}
		v__ast__Type unwrap_typ = v__ast__Table_unwrap_generic_type(t, elem_type, generic_names, concrete_types);
		int idx = v__ast__Table_find_or_register_array_with_dims(t, unwrap_typ, dims);
		v__ast__Type _t1 = v__ast__Type_clear_flag(v__ast__Type_derive_add_muls(v__ast__new_type(idx), typ), v__ast__TypeFlag__generic);
		return _t1;
	}
	else if (ts->info._typ == 468 /* v.ast.ArrayFixed */) {
		v__ast__Type unwrap_typ = v__ast__Table_unwrap_generic_type(t, (*ts->info._v__ast__ArrayFixed).elem_type, generic_names, concrete_types);
		int idx = v__ast__Table_find_or_register_array_fixed(t, unwrap_typ, (*ts->info._v__ast__ArrayFixed).size, v__ast__None_to_sumtype_v__ast__Expr(ADDR(v__ast__None, ((v__ast__None){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},}))));
		v__ast__Type _t2 = v__ast__Type_clear_flag(v__ast__Type_derive_add_muls(v__ast__new_type(idx), typ), v__ast__TypeFlag__generic);
		return _t2;
	}
	else if (ts->info._typ == 469 /* v.ast.Chan */) {
		v__ast__Type unwrap_typ = v__ast__Table_unwrap_generic_type(t, (*ts->info._v__ast__Chan).elem_type, generic_names, concrete_types);
		int idx = v__ast__Table_find_or_register_chan(t, unwrap_typ, v__ast__Type_nr_muls(unwrap_typ) > 0);
		v__ast__Type _t3 = v__ast__Type_clear_flag(v__ast__Type_derive_add_muls(v__ast__new_type(idx), typ), v__ast__TypeFlag__generic);
		return _t3;
	}
	else if (ts->info._typ == 442 /* v.ast.Map */) {
		v__ast__Type unwrap_key_type = v__ast__Table_unwrap_generic_type(t, (*ts->info._v__ast__Map).key_type, generic_names, concrete_types);
		v__ast__Type unwrap_value_type = v__ast__Table_unwrap_generic_type(t, (*ts->info._v__ast__Map).value_type, generic_names, concrete_types);
		int idx = v__ast__Table_find_or_register_map(t, unwrap_key_type, unwrap_value_type);
		v__ast__Type _t4 = v__ast__Type_clear_flag(v__ast__Type_derive_add_muls(v__ast__new_type(idx), typ), v__ast__TypeFlag__generic);
		return _t4;
	}
	else if (ts->info._typ == 446 /* v.ast.Struct */) {
		if (!(*ts->info._v__ast__Struct).is_generic) {
			v__ast__Type _t5 = typ;
			return _t5;
		}
		nrt =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ts->name}}, {_SLIT("<"), 0, { .d_c = 0 }}}));
		c_nrt =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ts->cname}}, {_SLIT("_T_"), 0, { .d_c = 0 }}}));
		for (int i = 0; i < (*ts->info._v__ast__Struct).generic_types.len; ++i) {
			Option_v__ast__Type _t6;
			if (_t6 = v__ast__Table_resolve_generic_to_concrete(t, (*(v__ast__Type*)/*ee elem_typ */array_get((*ts->info._v__ast__Struct).generic_types, i)), generic_names, concrete_types), _t6.state == 0) {
				v__ast__Type ct = *(v__ast__Type*)_t6.data;
				v__ast__TypeSymbol* gts = v__ast__Table_sym(t, ct);
				nrt = /*f*/string__plus(nrt, gts->name);
				c_nrt = /*f*/string__plus(c_nrt, gts->cname);
				if (i != (*ts->info._v__ast__Struct).generic_types.len - 1) {
					nrt = /*f*/string__plus(nrt, _SLIT(", "));
					c_nrt = /*f*/string__plus(c_nrt, _SLIT("_"));
				}
			}
		}
		nrt = /*f*/string__plus(nrt, _SLIT(">"));
		int idx = (*(int*)map_get(ADDR(map, t->type_idxs), &(string[]){nrt}, &(int[]){ 0 }));
		if (idx != 0 && (*(v__ast__TypeSymbol**)/*ee elem_typ */array_get(t->type_symbols, idx))->kind != v__ast__Kind__placeholder) {
			v__ast__Type _t7 = v__ast__Type_clear_flag(v__ast__Type_derive(v__ast__new_type(idx), typ), v__ast__TypeFlag__generic);
			return _t7;
		} else {
			fields = array_clone_to_depth(&(*ts->info._v__ast__Struct).fields, 0);
			for (int i = 0; i < fields.len; ++i) {
				if (v__ast__Type_has_flag((*(v__ast__StructField*)/*ee elem_typ */array_get(fields, i)).typ, v__ast__TypeFlag__generic)) {
					v__ast__TypeSymbol* sym = v__ast__Table_sym(t, (*(v__ast__StructField*)/*ee elem_typ */array_get(fields, i)).typ);
					if (sym->kind == v__ast__Kind__struct_ && v__ast__Type_idx((*(v__ast__StructField*)/*ee elem_typ */array_get(fields, i)).typ) != v__ast__Type_idx(typ)) {
						(*(v__ast__StructField*)/*ee elem_typ */array_get(fields, i)).typ = v__ast__Table_unwrap_generic_type(t, (*(v__ast__StructField*)/*ee elem_typ */array_get(fields, i)).typ, generic_names, concrete_types);
					} else {
						Option_v__ast__Type _t8;
						if (_t8 = v__ast__Table_resolve_generic_to_concrete(t, (*(v__ast__StructField*)/*ee elem_typ */array_get(fields, i)).typ, generic_names, concrete_types), _t8.state == 0) {
							v__ast__Type t_typ = *(v__ast__Type*)_t8.data;
							(*(v__ast__StructField*)/*ee elem_typ */array_get(fields, i)).typ = t_typ;
						}
					}
				}
			}
			for (int i = 0; i < (*ts->info._v__ast__Struct).generic_types.len; ++i) {
				Option_v__ast__Type _t9;
				if (_t9 = v__ast__Table_resolve_generic_to_concrete(t, (*(v__ast__Type*)/*ee elem_typ */array_get((*ts->info._v__ast__Struct).generic_types, i)), generic_names, concrete_types), _t9.state == 0) {
					v__ast__Type t_typ = *(v__ast__Type*)_t9.data;
					array_push((array*)&final_concrete_types, _MOV((v__ast__Type[]){ t_typ }));
				}
			}
			if (final_concrete_types.len > 0) {
				for (int _t11 = 0; _t11 < ts->methods.len; ++_t11) {
					v__ast__Fn method = ((v__ast__Fn*)ts->methods.data)[_t11];
					v__ast__Table_register_fn_concrete_types(t, v__ast__Fn_fkey(&method), final_concrete_types);
				}
			}
		}
	}
	else if (ts->info._typ == 463 /* v.ast.Interface */) {
		if (!(*ts->info._v__ast__Interface).is_generic) {
			v__ast__Type _t12 = typ;
			return _t12;
		}
		nrt =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ts->name}}, {_SLIT("<"), 0, { .d_c = 0 }}}));
		c_nrt =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ts->cname}}, {_SLIT("_T_"), 0, { .d_c = 0 }}}));
		for (int i = 0; i < (*ts->info._v__ast__Interface).generic_types.len; ++i) {
			Option_v__ast__Type _t13;
			if (_t13 = v__ast__Table_resolve_generic_to_concrete(t, (*(v__ast__Type*)/*ee elem_typ */array_get((*ts->info._v__ast__Interface).generic_types, i)), generic_names, concrete_types), _t13.state == 0) {
				v__ast__Type ct = *(v__ast__Type*)_t13.data;
				v__ast__TypeSymbol* gts = v__ast__Table_sym(t, ct);
				nrt = /*f*/string__plus(nrt, gts->name);
				c_nrt = /*f*/string__plus(c_nrt, gts->cname);
				if (i != (*ts->info._v__ast__Interface).generic_types.len - 1) {
					nrt = /*f*/string__plus(nrt, _SLIT(", "));
					c_nrt = /*f*/string__plus(c_nrt, _SLIT("_"));
				}
			}
		}
		nrt = /*f*/string__plus(nrt, _SLIT(">"));
		int idx = (*(int*)map_get(ADDR(map, t->type_idxs), &(string[]){nrt}, &(int[]){ 0 }));
		if (idx != 0 && (*(v__ast__TypeSymbol**)/*ee elem_typ */array_get(t->type_symbols, idx))->kind != v__ast__Kind__placeholder) {
			v__ast__Type _t14 = v__ast__Type_clear_flag(v__ast__Type_derive(v__ast__new_type(idx), typ), v__ast__TypeFlag__generic);
			return _t14;
		} else {
			fields = array_clone_to_depth(&(*ts->info._v__ast__Interface).fields, 0);
			for (int i = 0; i < fields.len; ++i) {
				if (v__ast__Type_has_flag((*(v__ast__StructField*)/*ee elem_typ */array_get(fields, i)).typ, v__ast__TypeFlag__generic)) {
					v__ast__TypeSymbol* sym = v__ast__Table_sym(t, (*(v__ast__StructField*)/*ee elem_typ */array_get(fields, i)).typ);
					if (sym->kind == v__ast__Kind__struct_ && v__ast__Type_idx((*(v__ast__StructField*)/*ee elem_typ */array_get(fields, i)).typ) != v__ast__Type_idx(typ)) {
						(*(v__ast__StructField*)/*ee elem_typ */array_get(fields, i)).typ = v__ast__Table_unwrap_generic_type(t, (*(v__ast__StructField*)/*ee elem_typ */array_get(fields, i)).typ, generic_names, concrete_types);
					} else {
						Option_v__ast__Type _t15;
						if (_t15 = v__ast__Table_resolve_generic_to_concrete(t, (*(v__ast__StructField*)/*ee elem_typ */array_get(fields, i)).typ, generic_names, concrete_types), _t15.state == 0) {
							v__ast__Type t_typ = *(v__ast__Type*)_t15.data;
							(*(v__ast__StructField*)/*ee elem_typ */array_get(fields, i)).typ = t_typ;
						}
					}
				}
			}
			for (int i = 0; i < (*ts->info._v__ast__Interface).generic_types.len; ++i) {
				Option_v__ast__Type _t16;
				if (_t16 = v__ast__Table_resolve_generic_to_concrete(t, (*(v__ast__Type*)/*ee elem_typ */array_get((*ts->info._v__ast__Interface).generic_types, i)), generic_names, concrete_types), _t16.state == 0) {
					v__ast__Type t_typ = *(v__ast__Type*)_t16.data;
					array_push((array*)&final_concrete_types, _MOV((v__ast__Type[]){ t_typ }));
				}
			}
			if (final_concrete_types.len > 0) {
				for (int _t18 = 0; _t18 < ts->methods.len; ++_t18) {
					v__ast__Fn method = ((v__ast__Fn*)ts->methods.data)[_t18];
					v__ast__Table_register_fn_concrete_types(t, v__ast__Fn_fkey(&method), final_concrete_types);
				}
			}
		}
	}
	else if (ts->info._typ == 464 /* v.ast.SumType */) {
		if (!(*ts->info._v__ast__SumType).is_generic) {
			v__ast__Type _t19 = typ;
			return _t19;
		}
		nrt =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ts->name}}, {_SLIT("<"), 0, { .d_c = 0 }}}));
		c_nrt =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ts->cname}}, {_SLIT("_T_"), 0, { .d_c = 0 }}}));
		for (int i = 0; i < (*ts->info._v__ast__SumType).generic_types.len; ++i) {
			Option_v__ast__Type _t20;
			if (_t20 = v__ast__Table_resolve_generic_to_concrete(t, (*(v__ast__Type*)/*ee elem_typ */array_get((*ts->info._v__ast__SumType).generic_types, i)), generic_names, concrete_types), _t20.state == 0) {
				v__ast__Type ct = *(v__ast__Type*)_t20.data;
				v__ast__TypeSymbol* gts = v__ast__Table_sym(t, ct);
				nrt = /*f*/string__plus(nrt, gts->name);
				c_nrt = /*f*/string__plus(c_nrt, gts->cname);
				if (i != (*ts->info._v__ast__SumType).generic_types.len - 1) {
					nrt = /*f*/string__plus(nrt, _SLIT(", "));
					c_nrt = /*f*/string__plus(c_nrt, _SLIT("_"));
				}
			}
		}
		nrt = /*f*/string__plus(nrt, _SLIT(">"));
		int idx = (*(int*)map_get(ADDR(map, t->type_idxs), &(string[]){nrt}, &(int[]){ 0 }));
		if (idx != 0 && (*(v__ast__TypeSymbol**)/*ee elem_typ */array_get(t->type_symbols, idx))->kind != v__ast__Kind__placeholder) {
			v__ast__Type _t21 = v__ast__Type_clear_flag(v__ast__Type_derive(v__ast__new_type(idx), typ), v__ast__TypeFlag__generic);
			return _t21;
		} else {
			fields = array_clone_to_depth(&(*ts->info._v__ast__SumType).fields, 0);
			for (int i = 0; i < fields.len; ++i) {
				if (v__ast__Type_has_flag((*(v__ast__StructField*)/*ee elem_typ */array_get(fields, i)).typ, v__ast__TypeFlag__generic)) {
					v__ast__TypeSymbol* sym = v__ast__Table_sym(t, (*(v__ast__StructField*)/*ee elem_typ */array_get(fields, i)).typ);
					if (sym->kind == v__ast__Kind__struct_ && v__ast__Type_idx((*(v__ast__StructField*)/*ee elem_typ */array_get(fields, i)).typ) != v__ast__Type_idx(typ)) {
						(*(v__ast__StructField*)/*ee elem_typ */array_get(fields, i)).typ = v__ast__Table_unwrap_generic_type(t, (*(v__ast__StructField*)/*ee elem_typ */array_get(fields, i)).typ, generic_names, concrete_types);
					} else {
						Option_v__ast__Type _t22;
						if (_t22 = v__ast__Table_resolve_generic_to_concrete(t, (*(v__ast__StructField*)/*ee elem_typ */array_get(fields, i)).typ, generic_names, concrete_types), _t22.state == 0) {
							v__ast__Type t_typ = *(v__ast__Type*)_t22.data;
							(*(v__ast__StructField*)/*ee elem_typ */array_get(fields, i)).typ = t_typ;
						}
					}
				}
			}
			for (int i = 0; i < (*ts->info._v__ast__SumType).generic_types.len; ++i) {
				Option_v__ast__Type _t23;
				if (_t23 = v__ast__Table_resolve_generic_to_concrete(t, (*(v__ast__Type*)/*ee elem_typ */array_get((*ts->info._v__ast__SumType).generic_types, i)), generic_names, concrete_types), _t23.state == 0) {
					v__ast__Type t_typ = *(v__ast__Type*)_t23.data;
					array_push((array*)&final_concrete_types, _MOV((v__ast__Type[]){ t_typ }));
				}
			}
			if (final_concrete_types.len > 0) {
				for (int _t25 = 0; _t25 < ts->methods.len; ++_t25) {
					v__ast__Fn method = ((v__ast__Fn*)ts->methods.data)[_t25];
					v__ast__Table_register_fn_concrete_types(t, v__ast__Fn_fkey(&method), final_concrete_types);
				}
			}
		}
	}
	
	else {
	}
	;
	if (ts->info._typ == 446 /* v.ast.Struct */) {
		v__ast__Struct info = (*ts->info._v__ast__Struct);
		info.is_generic = false;
		info.concrete_types = final_concrete_types;
		info.parent_type = typ;
		info.fields = fields;
		int new_idx = v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = v__ast__Struct_to_sumtype_v__ast__TypeInfo(&info),.kind = v__ast__Kind__struct_,.name = nrt,.cname = v__util__no_dots(c_nrt),.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = ts->mod,.is_public = 0,.language = 0,.idx = 0,});
		v__ast__Type _t26 = v__ast__Type_clear_flag(v__ast__Type_derive(v__ast__new_type(new_idx), typ), v__ast__TypeFlag__generic);
		return _t26;
	}
	else if (ts->info._typ == 463 /* v.ast.Interface */) {
		Array_v__ast__Fn imethods = array_clone_to_depth(&(*ts->info._v__ast__Interface).methods, 0);
		for (int _t27 = 0; _t27 < imethods.len; ++_t27) {
			v__ast__Fn* method = ((v__ast__Fn*)imethods.data) + _t27;
			Option_v__ast__Type _t28;
			if (_t28 = v__ast__Table_resolve_generic_to_concrete(t, method->return_type, generic_names, concrete_types), _t28.state == 0) {
				v__ast__Type unwrap_typ = *(v__ast__Type*)_t28.data;
				method->return_type = unwrap_typ;
			}
			for (int _t29 = 0; _t29 < method->params.len; ++_t29) {
				v__ast__Param* param = ((v__ast__Param*)method->params.data) + _t29;
				Option_v__ast__Type _t30;
				if (_t30 = v__ast__Table_resolve_generic_to_concrete(t, param->typ, generic_names, concrete_types), _t30.state == 0) {
					v__ast__Type unwrap_typ = *(v__ast__Type*)_t30.data;
					param->typ = unwrap_typ;
				}
			}
		}
		Array_v__ast__Fn all_methods = ts->methods;
		for (int _t31 = 0; _t31 < imethods.len; ++_t31) {
			v__ast__Fn imethod = ((v__ast__Fn*)imethods.data)[_t31];
			for (int _t32 = 0; _t32 < all_methods.len; ++_t32) {
				v__ast__Fn* method = ((v__ast__Fn*)all_methods.data) + _t32;
				if (string__eq(imethod.name, method->name)) {
					*method = imethod;
				}
			}
		}
		v__ast__Interface info = (*ts->info._v__ast__Interface);
		info.is_generic = false;
		info.concrete_types = final_concrete_types;
		info.parent_type = typ;
		info.fields = fields;
		info.methods = imethods;
		int new_idx = v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = v__ast__Interface_to_sumtype_v__ast__TypeInfo(&info),.kind = v__ast__Kind__interface_,.name = nrt,.cname = v__util__no_dots(c_nrt),.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = ts->mod,.is_public = 0,.language = 0,.idx = 0,});
		v__ast__TypeSymbol* ts_copy = v__ast__Table_sym(t, new_idx);
		for (int _t33 = 0; _t33 < all_methods.len; ++_t33) {
			v__ast__Fn method = ((v__ast__Fn*)all_methods.data)[_t33];
			v__ast__TypeSymbol_register_method(ts_copy, method);
		}
		v__ast__Type _t34 = v__ast__Type_clear_flag(v__ast__Type_derive(v__ast__new_type(new_idx), typ), v__ast__TypeFlag__generic);
		return _t34;
	}
	
	else {
	}
	;
	v__ast__Type _t35 = typ;
	return _t35;
}

void v__ast__Table_generic_insts_to_concrete(v__ast__Table* t) {
	for (int _t1 = 0; _t1 < t->type_symbols.len; ++_t1) {
		v__ast__TypeSymbol** typ = ((v__ast__TypeSymbol**)t->type_symbols.data) + _t1;
		if ((*typ)->kind == v__ast__Kind__generic_inst) {
			v__ast__GenericInst info = /* as */ *(v__ast__GenericInst*)__as_cast(((*typ)->info)._v__ast__GenericInst,((*typ)->info)._typ, 473) /*expected idx: 473, name: v.ast.GenericInst */ ;
			v__ast__TypeSymbol* parent = (*(v__ast__TypeSymbol**)/*ee elem_typ */array_get(t->type_symbols, info.parent_idx));
			if (parent->kind == v__ast__Kind__placeholder) {
				(*typ)->kind = v__ast__Kind__placeholder;
				continue;
			}
			if (parent->info._typ == 446 /* v.ast.Struct */) {
				v__ast__Struct parent_info = (*parent->info._v__ast__Struct);
				if (!parent_info.is_generic) {
					v__util__verror(_SLIT("generic error"),  str_intp(2, _MOV((StrIntpData[]){{_SLIT("struct `"), 0xfe10, {.d_s = parent->name}}, {_SLIT("` is not a generic struct, cannot instantiate to the concrete types"), 0, { .d_c = 0 }}})));
					VUNREACHABLE();
					continue;
				}
				Array_v__ast__StructField fields = array_clone_to_depth(&parent_info.fields, 0);
				if (parent_info.generic_types.len == info.concrete_types.len) {
					Array_string _t2 = __new_array(0, 0, sizeof(string));
					Array_v__ast__Type _t2_orig = parent_info.generic_types;
					int _t2_len = _t2_orig.len;
					_t2 = __new_array(0, _t2_len, sizeof(string));

					for (int _t3 = 0; _t3 < _t2_len; ++_t3) {
						v__ast__Type it = ((v__ast__Type*) _t2_orig.data)[_t3];
						string ti = v__ast__Table_sym(t, it)->name;
						array_push((array*)&_t2, &ti);
					}
					Array_string generic_names =_t2;
					for (int i = 0; i < fields.len; ++i) {
						if (v__ast__Type_has_flag((*(v__ast__StructField*)/*ee elem_typ */array_get(fields, i)).typ, v__ast__TypeFlag__generic)) {
							if (v__ast__Type_idx((*(v__ast__StructField*)/*ee elem_typ */array_get(fields, i)).typ) != info.parent_idx) {
								(*(v__ast__StructField*)/*ee elem_typ */array_get(fields, i)).typ = v__ast__Table_unwrap_generic_type(t, (*(v__ast__StructField*)/*ee elem_typ */array_get(fields, i)).typ, generic_names, info.concrete_types);
							}
							Option_v__ast__Type _t4;
							if (_t4 = v__ast__Table_resolve_generic_to_concrete(t, (*(v__ast__StructField*)/*ee elem_typ */array_get(fields, i)).typ, generic_names, info.concrete_types), _t4.state == 0) {
								v__ast__Type t_typ = *(v__ast__Type*)_t4.data;
								(*(v__ast__StructField*)/*ee elem_typ */array_get(fields, i)).typ = t_typ;
							}
						}
					}
					parent_info.is_generic = false;
					parent_info.concrete_types = array_clone_to_depth(&info.concrete_types, 0);
					parent_info.fields = fields;
					parent_info.parent_type = v__ast__Type_set_flag(v__ast__new_type(info.parent_idx), v__ast__TypeFlag__generic);
					(*typ)->info = v__ast__Struct_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__Struct, ((v__ast__Struct){parent_info.attrs,parent_info.embeds,.fields = fields,parent_info.is_typedef,parent_info.is_union,parent_info.is_heap,.is_generic = false,parent_info.generic_types,.concrete_types = array_clone_to_depth(&info.concrete_types, 0),.parent_type = v__ast__Type_set_flag(v__ast__new_type(info.parent_idx), v__ast__TypeFlag__generic),})));
					(*typ)->is_public = true;
					(*typ)->kind = parent->kind;
					v__ast__TypeSymbol* parent_sym = v__ast__Table_sym(t, parent_info.parent_type);
					for (int _t5 = 0; _t5 < parent_sym->methods.len; ++_t5) {
						v__ast__Fn method = ((v__ast__Fn*)parent_sym->methods.data)[_t5];
						if (method.generic_names.len == info.concrete_types.len) {
							v__ast__Table_register_fn_concrete_types(t, v__ast__Fn_fkey(&method), info.concrete_types);
						}
					}
				} else {
					v__util__verror(_SLIT("generic error"),  str_intp(2, _MOV((StrIntpData[]){{_SLIT("the number of generic types of struct `"), 0xfe10, {.d_s = parent->name}}, {_SLIT("` is inconsistent with the concrete types"), 0, { .d_c = 0 }}})));
					VUNREACHABLE();
				}
			}
			else if (parent->info._typ == 463 /* v.ast.Interface */) {
				v__ast__Interface parent_info = (*parent->info._v__ast__Interface);
				if (!parent_info.is_generic) {
					v__util__verror(_SLIT("generic error"),  str_intp(2, _MOV((StrIntpData[]){{_SLIT("interface `"), 0xfe10, {.d_s = parent->name}}, {_SLIT("` is not a generic interface, cannot instantiate to the concrete types"), 0, { .d_c = 0 }}})));
					VUNREACHABLE();
					continue;
				}
				if (parent_info.generic_types.len == info.concrete_types.len) {
					Array_v__ast__StructField fields = array_clone_to_depth(&parent_info.fields, 0);
					Array_string _t6 = __new_array(0, 0, sizeof(string));
					Array_v__ast__Type _t6_orig = parent_info.generic_types;
					int _t6_len = _t6_orig.len;
					_t6 = __new_array(0, _t6_len, sizeof(string));

					for (int _t7 = 0; _t7 < _t6_len; ++_t7) {
						v__ast__Type it = ((v__ast__Type*) _t6_orig.data)[_t7];
						string ti = v__ast__Table_sym(t, it)->name;
						array_push((array*)&_t6, &ti);
					}
					Array_string generic_names =_t6;
					for (int i = 0; i < fields.len; ++i) {
						Option_v__ast__Type _t8;
						if (_t8 = v__ast__Table_resolve_generic_to_concrete(t, (*(v__ast__StructField*)/*ee elem_typ */array_get(fields, i)).typ, generic_names, info.concrete_types), _t8.state == 0) {
							v__ast__Type t_typ = *(v__ast__Type*)_t8.data;
							(*(v__ast__StructField*)/*ee elem_typ */array_get(fields, i)).typ = t_typ;
						}
					}
					Array_v__ast__Fn imethods = array_clone_to_depth(&parent_info.methods, 0);
					for (int _t9 = 0; _t9 < imethods.len; ++_t9) {
						v__ast__Fn* method = ((v__ast__Fn*)imethods.data) + _t9;
						array_clear(&method->generic_names);
						Option_v__ast__Type _t10;
						if (_t10 = v__ast__Table_resolve_generic_to_concrete(t, method->return_type, generic_names, info.concrete_types), _t10.state == 0) {
							v__ast__Type pt = *(v__ast__Type*)_t10.data;
							method->return_type = pt;
						}
						method->params = array_clone_to_depth(&method->params, 0);
						for (int _t11 = 0; _t11 < method->params.len; ++_t11) {
							v__ast__Param* param = ((v__ast__Param*)method->params.data) + _t11;
							Option_v__ast__Type _t12;
							if (_t12 = v__ast__Table_resolve_generic_to_concrete(t, param->typ, generic_names, info.concrete_types), _t12.state == 0) {
								v__ast__Type pt = *(v__ast__Type*)_t12.data;
								param->typ = pt;
							}
						}
						v__ast__TypeSymbol_register_method(/*diff=1*/*typ, *method);
					}
					Array_v__ast__Fn all_methods = parent->methods;
					for (int _t13 = 0; _t13 < imethods.len; ++_t13) {
						v__ast__Fn imethod = ((v__ast__Fn*)imethods.data)[_t13];
						for (int _t14 = 0; _t14 < all_methods.len; ++_t14) {
							v__ast__Fn* method = ((v__ast__Fn*)all_methods.data) + _t14;
							if (string__eq(imethod.name, method->name)) {
								*method = imethod;
							}
						}
					}
					(*typ)->info = v__ast__Interface_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__Interface, ((v__ast__Interface){parent_info.types,.fields = fields,.methods = imethods,parent_info.ifaces,parent_info.conversions,.is_generic = false,parent_info.generic_types,.concrete_types = array_clone_to_depth(&info.concrete_types, 0),.parent_type = v__ast__Type_set_flag(v__ast__new_type(info.parent_idx), v__ast__TypeFlag__generic),})));
					(*typ)->is_public = true;
					(*typ)->kind = parent->kind;
					(*typ)->methods = all_methods;
				} else {
					v__util__verror(_SLIT("generic error"),  str_intp(2, _MOV((StrIntpData[]){{_SLIT("the number of generic types of interface `"), 0xfe10, {.d_s = parent->name}}, {_SLIT("` is inconsistent with the concrete types"), 0, { .d_c = 0 }}})));
					VUNREACHABLE();
				}
			}
			else if (parent->info._typ == 464 /* v.ast.SumType */) {
				v__ast__SumType parent_info = (*parent->info._v__ast__SumType);
				if (!parent_info.is_generic) {
					v__util__verror(_SLIT("generic error"),  str_intp(2, _MOV((StrIntpData[]){{_SLIT("sumtype `"), 0xfe10, {.d_s = parent->name}}, {_SLIT("` is not a generic sumtype, cannot instantiate to the concrete types"), 0, { .d_c = 0 }}})));
					VUNREACHABLE();
					continue;
				}
				if (parent_info.generic_types.len == info.concrete_types.len) {
					Array_v__ast__StructField fields = array_clone_to_depth(&parent_info.fields, 0);
					Array_v__ast__Type variants = array_clone_to_depth(&parent_info.variants, 0);
					Array_string _t15 = __new_array(0, 0, sizeof(string));
					Array_v__ast__Type _t15_orig = parent_info.generic_types;
					int _t15_len = _t15_orig.len;
					_t15 = __new_array(0, _t15_len, sizeof(string));

					for (int _t16 = 0; _t16 < _t15_len; ++_t16) {
						v__ast__Type it = ((v__ast__Type*) _t15_orig.data)[_t16];
						string ti = v__ast__Table_sym(t, it)->name;
						array_push((array*)&_t15, &ti);
					}
					Array_string generic_names =_t15;
					for (int i = 0; i < fields.len; ++i) {
						Option_v__ast__Type _t17;
						if (_t17 = v__ast__Table_resolve_generic_to_concrete(t, (*(v__ast__StructField*)/*ee elem_typ */array_get(fields, i)).typ, generic_names, info.concrete_types), _t17.state == 0) {
							v__ast__Type t_typ = *(v__ast__Type*)_t17.data;
							(*(v__ast__StructField*)/*ee elem_typ */array_get(fields, i)).typ = t_typ;
						}
					}
					for (int i = 0; i < variants.len; ++i) {
						if (v__ast__Type_has_flag((*(v__ast__Type*)/*ee elem_typ */array_get(variants, i)), v__ast__TypeFlag__generic)) {
							v__ast__TypeSymbol* sym = v__ast__Table_sym(t, (*(v__ast__Type*)/*ee elem_typ */array_get(variants, i)));
							if (sym->kind == v__ast__Kind__struct_ && v__ast__Type_idx((*(v__ast__Type*)/*ee elem_typ */array_get(variants, i))) != info.parent_idx) {
								array_set(&variants, i, &(v__ast__Type[]) { v__ast__Table_unwrap_generic_type(t, (*(v__ast__Type*)/*ee elem_typ */array_get(variants, i)), generic_names, info.concrete_types) });
							} else {
								Option_v__ast__Type _t18;
								if (_t18 = v__ast__Table_resolve_generic_to_concrete(t, (*(v__ast__Type*)/*ee elem_typ */array_get(variants, i)), generic_names, info.concrete_types), _t18.state == 0) {
									v__ast__Type t_typ = *(v__ast__Type*)_t18.data;
									array_set(&variants, i, &(v__ast__Type[]) { t_typ });
								}
							}
						}
					}
					(*typ)->info = v__ast__SumType_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__SumType, ((v__ast__SumType){.variants = variants,.fields = fields,parent_info.found_fields,parent_info.is_anon,.is_generic = false,parent_info.generic_types,.concrete_types = array_clone_to_depth(&info.concrete_types, 0),.parent_type = v__ast__Type_set_flag(v__ast__new_type(info.parent_idx), v__ast__TypeFlag__generic),})));
					(*typ)->is_public = true;
					(*typ)->kind = parent->kind;
				} else {
					v__util__verror(_SLIT("generic error"),  str_intp(2, _MOV((StrIntpData[]){{_SLIT("the number of generic types of sumtype `"), 0xfe10, {.d_s = parent->name}}, {_SLIT("` is inconsistent with the concrete types"), 0, { .d_c = 0 }}})));
					VUNREACHABLE();
				}
			}
			
			else {
			}
			;
		}
	}
}

// TypeDecl
// TypeDecl
v__ast__Language v__ast__pref_arch_to_table_language(v__pref__Arch pref_arch) {
	v__ast__Language _t2 = 0;
	switch (pref_arch) {
		case v__pref__Arch__amd64: 
			{
				_t2 = v__ast__Language__amd64;
			} break;
		case v__pref__Arch__arm64: 
			{
				_t2 = v__ast__Language__arm64;
			} break;
		case v__pref__Arch__arm32: 
			{
				_t2 = v__ast__Language__arm32;
			} break;
		case v__pref__Arch__rv64: 
			{
				_t2 = v__ast__Language__rv64;
			} break;
		case v__pref__Arch__rv32: 
			{
				_t2 = v__ast__Language__rv32;
			} break;
		case v__pref__Arch__i386: 
			{
				_t2 = v__ast__Language__i386;
			} break;
		case v__pref__Arch__js_node: 
		case v__pref__Arch__js_browser: 
		case v__pref__Arch__js_freestanding: 
			{
				_t2 = v__ast__Language__js;
			} break;
		case v__pref__Arch___auto: 
		case v__pref__Arch___max: 
			{
				_t2 = v__ast__Language__v;
			} break;
	}
	v__ast__Language _t1 = _t2;
	return _t1;
}

string v__ast__ShareType_str(v__ast__ShareType t) {

	if (t == (v__ast__ShareType__mut_t)) {
		string _t1 = _SLIT("mut");
		return _t1;
	}
	else if (t == (v__ast__ShareType__shared_t)) {
		string _t2 = _SLIT("shared");
		return _t2;
	}
	else if (t == (v__ast__ShareType__atomic_t)) {
		string _t3 = _SLIT("atomic");
		return _t3;
	};
	return (string){.str=(byteptr)"", .is_lit=1};
}

string v__ast__Type_atomic_typename(v__ast__Type t) {
	int idx = v__ast__Type_idx(t);

	if (idx == (_const_v__ast__u32_type_idx)) {
		string _t1 = _SLIT("atomic_uint");
		return _t1;
	}
	else if (idx == (_const_v__ast__int_type_idx)) {
		string _t2 = _SLIT("atomic_int");
		return _t2;
	}
	else if (idx == (_const_v__ast__u64_type_idx)) {
		string _t3 = _SLIT("atomic_ullong");
		return _t3;
	}
	else if (idx == (_const_v__ast__i64_type_idx)) {
		string _t4 = _SLIT("atomic_llong");
		return _t4;
	}
	else {
		string _t5 = _SLIT("unknown_atomic");
		return _t5;
	};
	return (string){.str=(byteptr)"", .is_lit=1};
}

v__ast__ShareType v__ast__sharetype_from_flags(bool is_shared, bool is_atomic) {
	v__ast__ShareType _t1 = ((v__ast__ShareType)((((int)(((u32)(is_atomic)) << 1U)) | ((int)(is_shared)))));
	return _t1;
}

v__ast__ShareType v__ast__Type_share(v__ast__Type t) {
	v__ast__ShareType _t1 = v__ast__sharetype_from_flags(v__ast__Type_has_flag(t, v__ast__TypeFlag__shared_f), v__ast__Type_has_flag(t, v__ast__TypeFlag__atomic_f));
	return _t1;
}

// Attr: [inline]
inline int v__ast__Type_idx(v__ast__Type t) {
	int _t1 = (((u16)(t)) & 0xffffU);
	return _t1;
}

// Attr: [inline]
inline bool v__ast__Type_is_void(v__ast__Type t) {
	bool _t1 = v__ast__Type_alias_eq(t, _const_v__ast__void_type);
	return _t1;
}

// Attr: [inline]
inline bool v__ast__Type_is_full(v__ast__Type t) {
	bool _t1 = t != 0 && !v__ast__Type_alias_eq(t, _const_v__ast__void_type);
	return _t1;
}

// Attr: [inline]
inline int v__ast__Type_nr_muls(v__ast__Type t) {
	int _t1 = ((((int)(t)) >> 16) & 0xff);
	return _t1;
}

// Attr: [inline]
inline bool v__ast__Type_is_ptr(v__ast__Type t) {
	bool _t1 = ((((int)(t)) >> 16) & 0xff) > 0;
	return _t1;
}

// Attr: [inline]
inline bool v__ast__Type_is_any_kind_of_pointer(v__ast__Type t) {
	bool _t1 = ((((int)(t)) >> 16) & 0xff) > 0 || Array_int_contains(_const_v__ast__pointer_type_idxs, ((((u16)(t)) & 0xffffU)));
	return _t1;
}

// Attr: [inline]
inline v__ast__Type v__ast__Type_set_nr_muls(v__ast__Type t, int nr_muls) {
	if (nr_muls < 0 || nr_muls > 255) {
		_v_panic(_SLIT("set_nr_muls: nr_muls must be between 0 & 255"));
		VUNREACHABLE();
	}
	v__ast__Type _t1 = ((((int)(t)) & 0xff00ffff) | ((int)(((u32)(nr_muls)) << 16U)));
	return _t1;
}

// Attr: [inline]
inline v__ast__Type v__ast__Type_ref(v__ast__Type t) {
	int nr_muls = ((((int)(t)) >> 16) & 0xff);
	if (nr_muls == 255) {
		_v_panic(_SLIT("ref: nr_muls is already at max of 255"));
		VUNREACHABLE();
	}
	v__ast__Type _t1 = ((((int)(t)) & 0xff00ffff) | ((int)(((u32)(nr_muls + 1)) << 16U)));
	return _t1;
}

// Attr: [inline]
inline v__ast__Type v__ast__Type_deref(v__ast__Type t) {
	int nr_muls = ((((int)(t)) >> 16) & 0xff);
	if (nr_muls == 0) {
		_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("deref: type `"), 0xfe07, {.d_i32 = t}}, {_SLIT("` is not a pointer"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	v__ast__Type _t1 = ((((int)(t)) & 0xff00ffff) | ((int)(((u32)(nr_muls - 1)) << 16U)));
	return _t1;
}

// Attr: [inline]
inline v__ast__Type v__ast__Type_set_flag(v__ast__Type t, v__ast__TypeFlag flag) {
	v__ast__Type _t1 = (((int)(t)) | (1 << (((int)(flag)) + 24)));
	return _t1;
}

// Attr: [inline]
inline v__ast__Type v__ast__Type_clear_flag(v__ast__Type t, v__ast__TypeFlag flag) {
	v__ast__Type _t1 = (((int)(t)) & ~(1 << (((int)(flag)) + 24)));
	return _t1;
}

// Attr: [inline]
inline v__ast__Type v__ast__Type_clear_flags(v__ast__Type t) {
	v__ast__Type _t1 = (((int)(t)) & 0xffffff);
	return _t1;
}

// Attr: [inline]
inline bool v__ast__Type_has_flag(v__ast__Type t, v__ast__TypeFlag flag) {
	bool _t1 = (((int)(t)) & (1 << (((int)(flag)) + 24))) > 0;
	return _t1;
}

Array_string v__ast__TypeSymbol_debug(v__ast__TypeSymbol* ts) {
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	v__ast__TypeSymbol_dbg_common(ts, &/*arr*/res);
	array_push((array*)&res, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("info: "), 0xfe10, {.d_s = v__ast__TypeInfo_str(ts->info)}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
	Array_string _t3 = __new_array(0, 0, sizeof(string));
	Array_v__ast__Fn _t3_orig = ts->methods;
	int _t3_len = _t3_orig.len;
	_t3 = __new_array(0, _t3_len, sizeof(string));

	for (int _t4 = 0; _t4 < _t3_len; ++_t4) {
		v__ast__Fn it = ((v__ast__Fn*) _t3_orig.data)[_t4];
		string ti = v__ast__Fn_str(it);
		array_push((array*)&_t3, &ti);
	}
	array_push((array*)&res, _MOV((string[]){ string_clone(string__plus( str_intp(2, _MOV((StrIntpData[]){{_SLIT("methods ("), 0xfe07, {.d_i32 = ts->methods.len}}, {_SLIT("): "), 0, { .d_c = 0 }}})), Array_string_join(_t3, _SLIT(", ")))) }));
	Array_string _t5 = res;
	return _t5;
}

Array_string v__ast__TypeSymbol_dbg(v__ast__TypeSymbol* ts) {
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	v__ast__TypeSymbol_dbg_common(ts, &/*arr*/res);
	Array_string _t1 = res;
	return _t1;
}

VV_LOCAL_SYMBOL void v__ast__TypeSymbol_dbg_common(v__ast__TypeSymbol* ts, Array_string* res) {
	array_push((array*)res, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("idx: 0x"), 0xfe10, {.d_s = int_hex(ts->idx)}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
	array_push((array*)res, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("parent_idx: 0x"), 0xfe10, {.d_s = int_hex(ts->parent_idx)}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
	array_push((array*)res, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("mod: "), 0xfe10, {.d_s = ts->mod}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
	array_push((array*)res, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("name: "), 0xfe10, {.d_s = ts->name}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
	array_push((array*)res, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("cname: "), 0xfe10, {.d_s = ts->cname}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
	array_push((array*)res, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("kind: "), 0xfe10, {.d_s = v__ast__Kind_str(ts->kind)}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
	array_push((array*)res, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("is_public: "), 0xfe10, {.d_s = ts->is_public ? _SLIT("true") : _SLIT("false")}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
	array_push((array*)res, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("language: "), 0xfe10, {.d_s = v__ast__Language_str(ts->language)}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
}

string v__ast__Type_str(v__ast__Type t) {
	string _t1 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("ast.Type(0x"), 0xfe10, {.d_s = int_hex(t)}}, {_SLIT(" = "), 0xfe06, {.d_u32 = ((u32)(t))}}, {_SLIT(")"), 0, { .d_c = 0 }}}));
	return _t1;
}

string v__ast__Table_type_str(v__ast__Table* t, v__ast__Type typ) {
	v__ast__TypeSymbol* sym = v__ast__Table_sym(t, typ);
	string _t1 = sym->name;
	return _t1;
}

Array_string v__ast__Type_debug(v__ast__Type t) {
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	array_push((array*)&res, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("idx: 0x"), 0x10fe10, {.d_s = int_hex(v__ast__Type_idx(t))}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
	array_push((array*)&res, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("type: 0x"), 0x10fe10, {.d_s = int_hex(t)}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
	array_push((array*)&res, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("nr_muls: "), 0xfe07, {.d_i32 = v__ast__Type_nr_muls(t)}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
	if (v__ast__Type_has_flag(t, v__ast__TypeFlag__optional)) {
		array_push((array*)&res, _MOV((string[]){ string_clone(_SLIT("optional")) }));
	}
	if (v__ast__Type_has_flag(t, v__ast__TypeFlag__variadic)) {
		array_push((array*)&res, _MOV((string[]){ string_clone(_SLIT("variadic")) }));
	}
	if (v__ast__Type_has_flag(t, v__ast__TypeFlag__generic)) {
		array_push((array*)&res, _MOV((string[]){ string_clone(_SLIT("generic")) }));
	}
	if (v__ast__Type_has_flag(t, v__ast__TypeFlag__shared_f)) {
		array_push((array*)&res, _MOV((string[]){ string_clone(_SLIT("shared_f")) }));
	}
	if (v__ast__Type_has_flag(t, v__ast__TypeFlag__atomic_f)) {
		array_push((array*)&res, _MOV((string[]){ string_clone(_SLIT("atomic_f")) }));
	}
	Array_string _t9 = res;
	return _t9;
}

// Attr: [inline]
inline v__ast__Type v__ast__Type_derive(v__ast__Type t, v__ast__Type t_from) {
	v__ast__Type _t1 = (((0xffff0000 & t_from)) | ((u16)(t)));
	return _t1;
}

// Attr: [inline]
inline v__ast__Type v__ast__Type_derive_add_muls(v__ast__Type t, v__ast__Type t_from) {
	v__ast__Type _t1 = v__ast__Type_set_nr_muls((((((0xff000000 & t_from)) | ((u16)(t))))), v__ast__Type_nr_muls(t) + v__ast__Type_nr_muls(t_from));
	return _t1;
}

// Attr: [inline]
inline v__ast__Type v__ast__new_type(int idx) {
	if (idx < 1 || idx > 65535) {
		_v_panic(_SLIT("new_type: idx must be between 1 & 65535"));
		VUNREACHABLE();
	}
	v__ast__Type _t1 = idx;
	return _t1;
}

// Attr: [inline]
inline v__ast__Type v__ast__new_type_ptr(int idx, int nr_muls) {
	if (idx < 1 || idx > 65535) {
		_v_panic(_SLIT("new_type_ptr: idx must be between 1 & 65535"));
		VUNREACHABLE();
	}
	if (nr_muls < 0 || nr_muls > 255) {
		_v_panic(_SLIT("new_type_ptr: nr_muls must be between 0 & 255"));
		VUNREACHABLE();
	}
	v__ast__Type _t1 = ((((u32)(nr_muls)) << 16U) | ((u16)(idx)));
	return _t1;
}

// Attr: [inline]
inline bool v__ast__Type_is_pointer(v__ast__Type typ) {
	bool _t1 = Array_int_contains(_const_v__ast__pointer_type_idxs, v__ast__Type_idx(typ));
	return _t1;
}

// Attr: [inline]
inline bool v__ast__Type_is_real_pointer(v__ast__Type typ) {
	bool _t1 = v__ast__Type_is_ptr(typ) || v__ast__Type_is_pointer(typ);
	return _t1;
}

// Attr: [inline]
inline bool v__ast__Type_is_float(v__ast__Type typ) {
	bool _t1 = Array_int_contains(_const_v__ast__float_type_idxs, v__ast__Type_clear_flags(typ));
	return _t1;
}

// Attr: [inline]
inline bool v__ast__Type_is_int(v__ast__Type typ) {
	bool _t1 = Array_int_contains(_const_v__ast__integer_type_idxs, v__ast__Type_clear_flags(typ));
	return _t1;
}

// Attr: [inline]
inline bool v__ast__Type_is_int_valptr(v__ast__Type typ) {
	bool _t1 = Array_int_contains(_const_v__ast__integer_type_idxs, v__ast__Type_idx(typ));
	return _t1;
}

// Attr: [inline]
inline bool v__ast__Type_is_float_valptr(v__ast__Type typ) {
	bool _t1 = Array_int_contains(_const_v__ast__float_type_idxs, v__ast__Type_idx(typ));
	return _t1;
}

// Attr: [inline]
inline bool v__ast__Type_is_pure_int(v__ast__Type typ) {
	bool _t1 = Array_int_contains(_const_v__ast__integer_type_idxs, ((int)(typ)));
	return _t1;
}

// Attr: [inline]
inline bool v__ast__Type_is_pure_float(v__ast__Type typ) {
	bool _t1 = Array_int_contains(_const_v__ast__float_type_idxs, ((int)(typ)));
	return _t1;
}

// Attr: [inline]
inline bool v__ast__Type_is_signed(v__ast__Type typ) {
	bool _t1 = Array_int_contains(_const_v__ast__signed_integer_type_idxs, v__ast__Type_idx(typ));
	return _t1;
}

// Attr: [inline]
inline bool v__ast__Type_is_unsigned(v__ast__Type typ) {
	bool _t1 = Array_int_contains(_const_v__ast__unsigned_integer_type_idxs, v__ast__Type_idx(typ));
	return _t1;
}

// Attr: [inline]
inline bool v__ast__Type_is_int_literal(v__ast__Type typ) {
	bool _t1 = ((int)(typ)) == _const_v__ast__int_literal_type_idx;
	return _t1;
}

// Attr: [inline]
inline bool v__ast__Type_is_number(v__ast__Type typ) {
	bool _t1 = Array_int_contains(_const_v__ast__number_type_idxs, v__ast__Type_clear_flags(typ));
	return _t1;
}

// Attr: [inline]
inline bool v__ast__Type_is_string(v__ast__Type typ) {
	bool _t1 = Array_int_contains(_const_v__ast__string_type_idxs, v__ast__Type_idx(typ));
	return _t1;
}

// Attr: [inline]
inline bool v__ast__Type_is_bool(v__ast__Type typ) {
	bool _t1 = v__ast__Type_idx(typ) == _const_v__ast__bool_type_idx;
	return _t1;
}

Array_v__ast__Type v__ast__merge_types(Array_Array_v__ast__Type params) {
	Array_v__ast__Type res = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
	for (int _t1 = 0; _t1 < params.len; ++_t1) {
		Array_v__ast__Type types = ((Array_v__ast__Type*)params.data)[_t1];
		_PUSH_MANY(&res, (types), _t2, Array_v__ast__Type);
	}
	Array_v__ast__Type _t3 = res;
	return _t3;
}

v__ast__Type v__ast__mktyp(v__ast__Type typ) {

	if (typ == (_const_v__ast__float_literal_type)) {
		v__ast__Type _t1 = _const_v__ast__f64_type;
		return _t1;
	}
	else if (typ == (_const_v__ast__int_literal_type)) {
		v__ast__Type _t2 = _const_v__ast__int_type;
		return _t2;
	}
	else {
		v__ast__Type _t3 = typ;
		return _t3;
	};
	return 0;
}

v__ast__Kind v__ast__Table_type_kind(v__ast__Table* t, v__ast__Type typ) {
	if (v__ast__Type_nr_muls(typ) > 0 || v__ast__Type_has_flag(typ, v__ast__TypeFlag__optional)) {
		v__ast__Kind _t1 = v__ast__Kind__placeholder;
		return _t1;
	}
	v__ast__Kind _t2 = v__ast__Table_sym(t, typ)->kind;
	return _t2;
}

string v__ast__TypeSymbol_str(v__ast__TypeSymbol* t) {
	string _t1 = t->name;
	return _t1;
}

// Attr: [noreturn]
VNORETURN VV_LOCAL_SYMBOL void v__ast__TypeSymbol_no_info_panic(v__ast__TypeSymbol* t, string fname) {
	_v_panic( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = fname}}, {_SLIT(": no info for type: "), 0xfe10, {.d_s = t->name}}, {_SLIT0, 0, { .d_c = 0 }}})));
	VUNREACHABLE();
	while(1);
}

// Attr: [inline]
inline v__ast__Enum v__ast__TypeSymbol_enum_info(v__ast__TypeSymbol* t) {
	if ((t->info)._typ == 474 /* v.ast.Enum */) {
		v__ast__Enum _t1 = (*t->info._v__ast__Enum);
		return _t1;
	}
	if ((t->info)._typ == 460 /* v.ast.Alias */) {
		v__ast__TypeSymbol* fsym = v__ast__Table_final_sym(global_table, (*t->info._v__ast__Alias).parent_type);
		if ((fsym->info)._typ == 474 /* v.ast.Enum */) {
			v__ast__Enum _t2 = (*fsym->info._v__ast__Enum);
			return _t2;
		}
	}
	v__ast__TypeSymbol_no_info_panic(t, _SLIT("TypeSymbol.enum_info"));
	VUNREACHABLE();
	return (v__ast__Enum){.vals = __new_array(0, 0, sizeof(string)),.is_flag = 0,.is_multi_allowed = 0,};
}

// Attr: [inline]
inline v__ast__MultiReturn v__ast__TypeSymbol_mr_info(v__ast__TypeSymbol* t) {
	if ((t->info)._typ == 471 /* v.ast.MultiReturn */) {
		v__ast__MultiReturn _t1 = (*t->info._v__ast__MultiReturn);
		return _t1;
	}
	if ((t->info)._typ == 460 /* v.ast.Alias */) {
		v__ast__TypeSymbol* fsym = v__ast__Table_final_sym(global_table, (*t->info._v__ast__Alias).parent_type);
		if ((fsym->info)._typ == 471 /* v.ast.MultiReturn */) {
			v__ast__MultiReturn _t2 = (*fsym->info._v__ast__MultiReturn);
			return _t2;
		}
	}
	v__ast__TypeSymbol_no_info_panic(t, _SLIT("TypeSymbol.mr_info"));
	VUNREACHABLE();
	return (v__ast__MultiReturn){.types = __new_array(0, 0, sizeof(v__ast__Type)),};
}

// Attr: [inline]
inline v__ast__Array v__ast__TypeSymbol_array_info(v__ast__TypeSymbol* t) {
	if ((t->info)._typ == 441 /* v.ast.Array */) {
		v__ast__Array _t1 = (*t->info._v__ast__Array);
		return _t1;
	}
	if ((t->info)._typ == 460 /* v.ast.Alias */) {
		v__ast__TypeSymbol* fsym = v__ast__Table_final_sym(global_table, (*t->info._v__ast__Alias).parent_type);
		if ((fsym->info)._typ == 441 /* v.ast.Array */) {
			v__ast__Array _t2 = (*fsym->info._v__ast__Array);
			return _t2;
		}
	}
	v__ast__TypeSymbol_no_info_panic(t, _SLIT("TypeSymbol.array_info"));
	VUNREACHABLE();
	return (v__ast__Array){.nr_dims = 0,.elem_type = 0,};
}

// Attr: [inline]
inline v__ast__ArrayFixed v__ast__TypeSymbol_array_fixed_info(v__ast__TypeSymbol* t) {
	if ((t->info)._typ == 468 /* v.ast.ArrayFixed */) {
		v__ast__ArrayFixed _t1 = (*t->info._v__ast__ArrayFixed);
		return _t1;
	}
	if ((t->info)._typ == 460 /* v.ast.Alias */) {
		v__ast__TypeSymbol* fsym = v__ast__Table_final_sym(global_table, (*t->info._v__ast__Alias).parent_type);
		if ((fsym->info)._typ == 468 /* v.ast.ArrayFixed */) {
			v__ast__ArrayFixed _t2 = (*fsym->info._v__ast__ArrayFixed);
			return _t2;
		}
	}
	v__ast__TypeSymbol_no_info_panic(t, _SLIT("TypeSymbol.array_fixed_info"));
	VUNREACHABLE();
	return (v__ast__ArrayFixed){.size = 0,.elem_type = 0,};
}

// Attr: [inline]
inline v__ast__Chan v__ast__TypeSymbol_chan_info(v__ast__TypeSymbol* t) {
	if ((t->info)._typ == 469 /* v.ast.Chan */) {
		v__ast__Chan _t1 = (*t->info._v__ast__Chan);
		return _t1;
	}
	if ((t->info)._typ == 460 /* v.ast.Alias */) {
		v__ast__TypeSymbol* fsym = v__ast__Table_final_sym(global_table, (*t->info._v__ast__Alias).parent_type);
		if ((fsym->info)._typ == 469 /* v.ast.Chan */) {
			v__ast__Chan _t2 = (*fsym->info._v__ast__Chan);
			return _t2;
		}
	}
	v__ast__TypeSymbol_no_info_panic(t, _SLIT("TypeSymbol.chan_info"));
	VUNREACHABLE();
	return (v__ast__Chan){.elem_type = 0,.is_mut = 0,};
}

// Attr: [inline]
inline v__ast__Thread v__ast__TypeSymbol_thread_info(v__ast__TypeSymbol* t) {
	if ((t->info)._typ == 470 /* v.ast.Thread */) {
		v__ast__Thread _t1 = (*t->info._v__ast__Thread);
		return _t1;
	}
	if ((t->info)._typ == 460 /* v.ast.Alias */) {
		v__ast__TypeSymbol* fsym = v__ast__Table_final_sym(global_table, (*t->info._v__ast__Alias).parent_type);
		if ((fsym->info)._typ == 470 /* v.ast.Thread */) {
			v__ast__Thread _t2 = (*fsym->info._v__ast__Thread);
			return _t2;
		}
	}
	v__ast__TypeSymbol_no_info_panic(t, _SLIT("TypeSymbol.thread_info"));
	VUNREACHABLE();
	return (v__ast__Thread){.return_type = 0,};
}

// Attr: [inline]
inline v__ast__Map v__ast__TypeSymbol_map_info(v__ast__TypeSymbol* t) {
	if ((t->info)._typ == 442 /* v.ast.Map */) {
		v__ast__Map _t1 = (*t->info._v__ast__Map);
		return _t1;
	}
	if ((t->info)._typ == 460 /* v.ast.Alias */) {
		v__ast__TypeSymbol* fsym = v__ast__Table_final_sym(global_table, (*t->info._v__ast__Alias).parent_type);
		if ((fsym->info)._typ == 442 /* v.ast.Map */) {
			v__ast__Map _t2 = (*fsym->info._v__ast__Map);
			return _t2;
		}
	}
	v__ast__TypeSymbol_no_info_panic(t, _SLIT("TypeSymbol.map_info"));
	VUNREACHABLE();
	return (v__ast__Map){.key_type = 0,.value_type = 0,};
}

// Attr: [inline]
inline v__ast__Struct v__ast__TypeSymbol_struct_info(v__ast__TypeSymbol* t) {
	if ((t->info)._typ == 446 /* v.ast.Struct */) {
		v__ast__Struct _t1 = (*t->info._v__ast__Struct);
		return _t1;
	}
	if ((t->info)._typ == 460 /* v.ast.Alias */) {
		v__ast__TypeSymbol* fsym = v__ast__Table_final_sym(global_table, (*t->info._v__ast__Alias).parent_type);
		if ((fsym->info)._typ == 446 /* v.ast.Struct */) {
			v__ast__Struct _t2 = (*fsym->info._v__ast__Struct);
			return _t2;
		}
	}
	v__ast__TypeSymbol_no_info_panic(t, _SLIT("TypeSymbol.struct_info"));
	VUNREACHABLE();
	return (v__ast__Struct){.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.embeds = __new_array(0, 0, sizeof(v__ast__Type)),.fields = __new_array(0, 0, sizeof(v__ast__StructField)),.is_typedef = 0,.is_union = 0,.is_heap = 0,.is_generic = 0,.generic_types = __new_array(0, 0, sizeof(v__ast__Type)),.concrete_types = __new_array(0, 0, sizeof(v__ast__Type)),.parent_type = 0,};
}

// Attr: [inline]
inline v__ast__SumType v__ast__TypeSymbol_sumtype_info(v__ast__TypeSymbol* t) {
	if ((t->info)._typ == 464 /* v.ast.SumType */) {
		v__ast__SumType _t1 = (*t->info._v__ast__SumType);
		return _t1;
	}
	if ((t->info)._typ == 464 /* v.ast.SumType */) {
		v__ast__TypeSymbol* fsym = v__ast__Table_final_sym(global_table, (*t->info._v__ast__SumType).parent_type);
		if ((fsym->info)._typ == 464 /* v.ast.SumType */) {
			v__ast__SumType _t2 = (*fsym->info._v__ast__SumType);
			return _t2;
		}
	}
	v__ast__TypeSymbol_no_info_panic(t, _SLIT("TypeSymbol.sumtype_info"));
	VUNREACHABLE();
	return (v__ast__SumType){.variants = __new_array(0, 0, sizeof(v__ast__Type)),.fields = __new_array(0, 0, sizeof(v__ast__StructField)),.found_fields = 0,.is_anon = 0,.is_generic = 0,.generic_types = __new_array(0, 0, sizeof(v__ast__Type)),.concrete_types = __new_array(0, 0, sizeof(v__ast__Type)),.parent_type = 0,};
}

bool v__ast__TypeSymbol_is_heap(v__ast__TypeSymbol* t) {
	if (t->kind == v__ast__Kind__struct_) {
		v__ast__Struct info = /* as */ *(v__ast__Struct*)__as_cast((t->info)._v__ast__Struct,(t->info)._typ, 446) /*expected idx: 446, name: v.ast.Struct */ ;
		bool _t1 = info.is_heap;
		return _t1;
	} else {
		bool _t2 = false;
		return _t2;
	}
	return 0;
}

void v__ast__Table_register_builtin_type_symbols(v__ast__Table* t) {
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind__placeholder,.name = _SLIT("reserved_0"),.cname = (string){.str=(byteptr)"", .is_lit=1},.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = (string){.str=(byteptr)"", .is_lit=1},.is_public = 0,.language = 0,.idx = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind__void,.name = _SLIT("void"),.cname = _SLIT("void"),.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,.idx = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind__voidptr,.name = _SLIT("voidptr"),.cname = _SLIT("voidptr"),.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,.idx = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind__byteptr,.name = _SLIT("byteptr"),.cname = _SLIT("byteptr"),.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,.idx = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind__charptr,.name = _SLIT("charptr"),.cname = _SLIT("charptr"),.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,.idx = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind__i8,.name = _SLIT("i8"),.cname = _SLIT("i8"),.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,.idx = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind__i16,.name = _SLIT("i16"),.cname = _SLIT("i16"),.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,.idx = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind__int,.name = _SLIT("int"),.cname = _SLIT("int"),.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,.idx = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind__i64,.name = _SLIT("i64"),.cname = _SLIT("i64"),.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,.idx = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind__isize,.name = _SLIT("isize"),.cname = _SLIT("isize"),.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,.idx = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind__byte,.name = _SLIT("byte"),.cname = _SLIT("byte"),.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,.idx = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind__u16,.name = _SLIT("u16"),.cname = _SLIT("u16"),.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,.idx = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind__u32,.name = _SLIT("u32"),.cname = _SLIT("u32"),.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,.idx = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind__u64,.name = _SLIT("u64"),.cname = _SLIT("u64"),.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,.idx = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind__usize,.name = _SLIT("usize"),.cname = _SLIT("usize"),.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,.idx = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind__f32,.name = _SLIT("f32"),.cname = _SLIT("f32"),.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,.idx = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind__f64,.name = _SLIT("f64"),.cname = _SLIT("f64"),.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,.idx = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind__char,.name = _SLIT("char"),.cname = _SLIT("char"),.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,.idx = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind__bool,.name = _SLIT("bool"),.cname = _SLIT("bool"),.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,.idx = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind__none_,.name = _SLIT("none"),.cname = _SLIT("none"),.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,.idx = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind__string,.name = _SLIT("string"),.cname = _SLIT("string"),.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,.idx = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind__rune,.name = _SLIT("rune"),.cname = _SLIT("rune"),.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,.idx = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind__array,.name = _SLIT("array"),.cname = _SLIT("array"),.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,.idx = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind__map,.name = _SLIT("map"),.cname = _SLIT("map"),.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,.idx = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind__chan,.name = _SLIT("chan"),.cname = _SLIT("chan"),.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,.idx = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind__any,.name = _SLIT("any"),.cname = _SLIT("any"),.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,.idx = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind__float_literal,.name = _SLIT("float literal"),.cname = _SLIT("float_literal"),.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,.idx = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind__int_literal,.name = _SLIT("int literal"),.cname = _SLIT("int_literal"),.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,.idx = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = v__ast__Thread_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__Thread, ((v__ast__Thread){.return_type = _const_v__ast__void_type,}))),.kind = v__ast__Kind__thread,.name = _SLIT("thread"),.cname = _SLIT("__v_thread"),.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,.idx = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind__interface_,.name = _SLIT("IError"),.cname = _SLIT("IError"),.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,.idx = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind__u8,.name = _SLIT("zu8"),.cname = _SLIT("zu8"),.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,.idx = 0,});
}

// Attr: [inline]
inline bool v__ast__TypeSymbol_is_pointer(v__ast__TypeSymbol* t) {
	bool _t1 = (t->kind == v__ast__Kind__byteptr || t->kind == v__ast__Kind__charptr || t->kind == v__ast__Kind__voidptr);
	return _t1;
}

// Attr: [inline]
inline bool v__ast__TypeSymbol_is_int(v__ast__TypeSymbol* t) {
	bool res = (t->kind == v__ast__Kind__i8 || t->kind == v__ast__Kind__i16 || t->kind == v__ast__Kind__int || t->kind == v__ast__Kind__i64 || t->kind == v__ast__Kind__isize || t->kind == v__ast__Kind__byte || t->kind == v__ast__Kind__u16 || t->kind == v__ast__Kind__u32 || t->kind == v__ast__Kind__u64 || t->kind == v__ast__Kind__usize || t->kind == v__ast__Kind__int_literal || t->kind == v__ast__Kind__rune);
	if (!res && t->kind == v__ast__Kind__alias) {
		bool _t1 = v__ast__Type_is_number((/* as */ *(v__ast__Alias*)__as_cast((t->info)._v__ast__Alias,(t->info)._typ, 460) /*expected idx: 460, name: v.ast.Alias */ ).parent_type);
		return _t1;
	}
	bool _t2 = res;
	return _t2;
}

// Attr: [inline]
inline bool v__ast__TypeSymbol_is_float(v__ast__TypeSymbol* t) {
	bool _t1 = (t->kind == v__ast__Kind__f32 || t->kind == v__ast__Kind__f64 || t->kind == v__ast__Kind__float_literal);
	return _t1;
}

// Attr: [inline]
inline bool v__ast__TypeSymbol_is_string(v__ast__TypeSymbol* t) {
	bool _t1 = t->kind == v__ast__Kind__string;
	return _t1;
}

// Attr: [inline]
inline bool v__ast__TypeSymbol_is_number(v__ast__TypeSymbol* t) {
	bool _t1 = v__ast__TypeSymbol_is_int(t) || v__ast__TypeSymbol_is_float(t);
	return _t1;
}

// Attr: [inline]
inline bool v__ast__TypeSymbol_is_primitive(v__ast__TypeSymbol* t) {
	bool _t1 = v__ast__TypeSymbol_is_number(t) || v__ast__TypeSymbol_is_pointer(t) || v__ast__TypeSymbol_is_string(t);
	return _t1;
}

// Attr: [inline]
inline bool v__ast__TypeSymbol_is_builtin(v__ast__TypeSymbol* t) {
	bool _t1 = string__eq(t->mod, _SLIT("builtin"));
	return _t1;
}

string v__ast__Kind_str(v__ast__Kind k) {
	string _t1 = (string){.str=(byteptr)"", .is_lit=1};
	switch (k) {
		case v__ast__Kind__placeholder: 
			{
				_t1 = _SLIT("placeholder");
			} break;
		case v__ast__Kind__void: 
			{
				_t1 = _SLIT("void");
			} break;
		case v__ast__Kind__voidptr: 
			{
				_t1 = _SLIT("voidptr");
			} break;
		case v__ast__Kind__charptr: 
			{
				_t1 = _SLIT("charptr");
			} break;
		case v__ast__Kind__byteptr: 
			{
				_t1 = _SLIT("byteptr");
			} break;
		case v__ast__Kind__struct_: 
			{
				_t1 = _SLIT("struct");
			} break;
		case v__ast__Kind__int: 
			{
				_t1 = _SLIT("int");
			} break;
		case v__ast__Kind__i8: 
			{
				_t1 = _SLIT("i8");
			} break;
		case v__ast__Kind__i16: 
			{
				_t1 = _SLIT("i16");
			} break;
		case v__ast__Kind__i64: 
			{
				_t1 = _SLIT("i64");
			} break;
		case v__ast__Kind__isize: 
			{
				_t1 = _SLIT("isize");
			} break;
		case v__ast__Kind__byte: 
			{
				_t1 = _SLIT("byte");
			} break;
		case v__ast__Kind__u8: 
			{
				_t1 = _SLIT("u8");
			} break;
		case v__ast__Kind__u16: 
			{
				_t1 = _SLIT("u16");
			} break;
		case v__ast__Kind__u32: 
			{
				_t1 = _SLIT("u32");
			} break;
		case v__ast__Kind__u64: 
			{
				_t1 = _SLIT("u64");
			} break;
		case v__ast__Kind__usize: 
			{
				_t1 = _SLIT("usize");
			} break;
		case v__ast__Kind__int_literal: 
			{
				_t1 = _SLIT("int_literal");
			} break;
		case v__ast__Kind__f32: 
			{
				_t1 = _SLIT("f32");
			} break;
		case v__ast__Kind__f64: 
			{
				_t1 = _SLIT("f64");
			} break;
		case v__ast__Kind__float_literal: 
			{
				_t1 = _SLIT("float_literal");
			} break;
		case v__ast__Kind__string: 
			{
				_t1 = _SLIT("string");
			} break;
		case v__ast__Kind__char: 
			{
				_t1 = _SLIT("char");
			} break;
		case v__ast__Kind__bool: 
			{
				_t1 = _SLIT("bool");
			} break;
		case v__ast__Kind__none_: 
			{
				_t1 = _SLIT("none");
			} break;
		case v__ast__Kind__array: 
			{
				_t1 = _SLIT("array");
			} break;
		case v__ast__Kind__array_fixed: 
			{
				_t1 = _SLIT("array_fixed");
			} break;
		case v__ast__Kind__map: 
			{
				_t1 = _SLIT("map");
			} break;
		case v__ast__Kind__chan: 
			{
				_t1 = _SLIT("chan");
			} break;
		case v__ast__Kind__multi_return: 
			{
				_t1 = _SLIT("multi_return");
			} break;
		case v__ast__Kind__sum_type: 
			{
				_t1 = _SLIT("sum_type");
			} break;
		case v__ast__Kind__alias: 
			{
				_t1 = _SLIT("alias");
			} break;
		case v__ast__Kind__enum_: 
			{
				_t1 = _SLIT("enum");
			} break;
		case v__ast__Kind__any: 
			{
				_t1 = _SLIT("any");
			} break;
		case v__ast__Kind__function: 
			{
				_t1 = _SLIT("function");
			} break;
		case v__ast__Kind__interface_: 
			{
				_t1 = _SLIT("interface");
			} break;
		case v__ast__Kind__generic_inst: 
			{
				_t1 = _SLIT("generic_inst");
			} break;
		case v__ast__Kind__rune: 
			{
				_t1 = _SLIT("rune");
			} break;
		case v__ast__Kind__aggregate: 
			{
				_t1 = _SLIT("aggregate");
			} break;
		case v__ast__Kind__thread: 
			{
				_t1 = _SLIT("thread");
			} break;
	}
	string k_str = _t1;
	string _t2 = k_str;
	return _t2;
}

string Array_v__ast__Kind_str(Array_v__ast__Kind kinds) {
	string kinds_str = _SLIT("");
	for (int i = 0; i < kinds.len; ++i) {
		v__ast__Kind k = ((v__ast__Kind*)kinds.data)[i];
		kinds_str = /*f*/string__plus(kinds_str, v__ast__Kind_str(k));
		if (i < kinds.len - 1) {
			kinds_str = /*f*/string__plus(kinds_str, _SLIT("_"));
		}
	}
	string _t1 = kinds_str;
	return _t1;
}

bool v__ast__StructField_equals(v__ast__StructField* f, v__ast__StructField* o) {
	bool _t1 = string__eq(f->name, o->name) && v__ast__Type_alias_eq(f->typ, o->typ) && f->is_pub == o->is_pub && f->is_global == o->is_global;
	return _t1;
}

string v__ast__Table_type_to_str(v__ast__Table* t, v__ast__Type typ) {
	string _t1 = v__ast__Table_type_to_str_using_aliases(t, typ, new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string));
	return _t1;
}

string v__ast__Table_type_to_code(v__ast__Table* mytable, v__ast__Type t) {

	if (t == (_const_v__ast__int_literal_type) || t == (_const_v__ast__float_literal_type)) {
		string _t1 = v__ast__Kind_str(v__ast__Table_sym(mytable, t)->kind);
		return _t1;
	}
	else {
		string _t2 = v__ast__Table_type_to_str_using_aliases(mytable, t, new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string));
		return _t2;
	};
	return (string){.str=(byteptr)"", .is_lit=1};
}

string v__ast__Table_type_to_str_using_aliases(v__ast__Table* t, v__ast__Type typ, Map_string_string import_aliases) {
	v__ast__TypeSymbol* sym = v__ast__Table_sym(t, typ);
	string res = sym->name;
	switch (sym->kind) {
		case v__ast__Kind__int_literal: 
		case v__ast__Kind__float_literal: 
			{
			} break;
		case v__ast__Kind__i8: 
		case v__ast__Kind__i16: 
		case v__ast__Kind__int: 
		case v__ast__Kind__i64: 
		case v__ast__Kind__isize: 
		case v__ast__Kind__byte: 
		case v__ast__Kind__u8: 
		case v__ast__Kind__u16: 
		case v__ast__Kind__u32: 
		case v__ast__Kind__u64: 
		case v__ast__Kind__usize: 
		case v__ast__Kind__f32: 
		case v__ast__Kind__f64: 
		case v__ast__Kind__char: 
		case v__ast__Kind__rune: 
		case v__ast__Kind__string: 
		case v__ast__Kind__bool: 
		case v__ast__Kind__none_: 
		case v__ast__Kind__voidptr: 
		case v__ast__Kind__byteptr: 
		case v__ast__Kind__charptr: 
			{
				res = v__ast__Kind_str(sym->kind);
			} break;
		case v__ast__Kind__array: 
			{
				if (v__ast__Type_alias_eq(typ, _const_v__ast__array_type)) {
					string _t1 = _SLIT("array");
					return _t1;
				}
				if (v__ast__Type_has_flag(typ, v__ast__TypeFlag__variadic)) {
					res = v__ast__Table_type_to_str_using_aliases(t, v__ast__Table_value_type(t, typ), import_aliases);
				} else {
					if ((sym->info)._typ == 441 /* v.ast.Array */) {
						string elem_str = v__ast__Table_type_to_str_using_aliases(t, (*sym->info._v__ast__Array).elem_type, import_aliases);
						res =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("[]"), 0xfe10, {.d_s = elem_str}}, {_SLIT0, 0, { .d_c = 0 }}}));
					} else {
						res = _SLIT("array");
					}
				}
			} break;
		case v__ast__Kind__array_fixed: 
			{
				v__ast__ArrayFixed info = /* as */ *(v__ast__ArrayFixed*)__as_cast((sym->info)._v__ast__ArrayFixed,(sym->info)._typ, 468) /*expected idx: 468, name: v.ast.ArrayFixed */ ;
				string elem_str = v__ast__Table_type_to_str_using_aliases(t, info.elem_type, import_aliases);
				if ((info.size_expr)._typ == 295 /* v.ast.EmptyExpr */) {
					res =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("["), 0xfe07, {.d_i32 = info.size}}, {_SLIT("]"), 0xfe10, {.d_s = elem_str}}, {_SLIT0, 0, { .d_c = 0 }}}));
				} else {
					res =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("["), 0xfe10, {.d_s = v__ast__Expr_str(info.size_expr)}}, {_SLIT("]"), 0xfe10, {.d_s = elem_str}}, {_SLIT0, 0, { .d_c = 0 }}}));
				}
			} break;
		case v__ast__Kind__chan: 
			{
				if (!string__eq(sym->mod, _SLIT("builtin")) && !string__eq(sym->name, _SLIT("chan"))) {
					v__ast__Chan info = /* as */ *(v__ast__Chan*)__as_cast((sym->info)._v__ast__Chan,(sym->info)._typ, 469) /*expected idx: 469, name: v.ast.Chan */ ;
					v__ast__Type elem_type = info.elem_type;
					string mut_str = _SLIT("");
					if (info.is_mut) {
						mut_str = _SLIT("mut ");
						elem_type = v__ast__Type_set_nr_muls(elem_type, v__ast__Type_nr_muls(elem_type) - 1);
					}
					string elem_str = v__ast__Table_type_to_str_using_aliases(t, elem_type, import_aliases);
					res =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("chan "), 0xfe10, {.d_s = mut_str}}, {_SLIT0, 0xfe10, {.d_s = elem_str}}, {_SLIT0, 0, { .d_c = 0 }}}));
				}
			} break;
		case v__ast__Kind__function: 
			{
				v__ast__FnType info = /* as */ *(v__ast__FnType*)__as_cast((sym->info)._v__ast__FnType,(sym->info)._typ, 472) /*expected idx: 472, name: v.ast.FnType */ ;
				if (!t->is_fmt) {
					res = v__ast__Table_fn_signature(t, (voidptr)&/*qq*/info.func, (v__ast__FnSignatureOpts){.skip_receiver = 0,.type_only = true,});
				} else {
					if (string_starts_with(res, _SLIT("fn ("))) {
						bool _t2 = false;
						Array_v__ast__Param _t2_orig = info.func.params;
						int _t2_len = _t2_orig.len;
						for (int _t3 = 0; _t3 < _t2_len; ++_t3) {
							v__ast__Param it = ((v__ast__Param*) _t2_orig.data)[_t3];
							if (it.name.len > 0) {
								_t2 = true;
								break;
							}
						}
						bool has_names =_t2;
						res = v__ast__Table_fn_signature_using_aliases(t, (voidptr)&/*qq*/info.func, import_aliases, (v__ast__FnSignatureOpts){.skip_receiver = 0,.type_only = !has_names,});
					} else {
						res = v__ast__Table_shorten_user_defined_typenames(t, res, import_aliases);
					}
				}
			} break;
		case v__ast__Kind__map: 
			{
				if (((int)(typ)) == _const_v__ast__map_type_idx) {
					string _t4 = _SLIT("map");
					return _t4;
				}
				v__ast__Map info = /* as */ *(v__ast__Map*)__as_cast((sym->info)._v__ast__Map,(sym->info)._typ, 442) /*expected idx: 442, name: v.ast.Map */ ;
				string key_str = v__ast__Table_type_to_str_using_aliases(t, info.key_type, import_aliases);
				string val_str = v__ast__Table_type_to_str_using_aliases(t, info.value_type, import_aliases);
				res =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("map["), 0xfe10, {.d_s = key_str}}, {_SLIT("]"), 0xfe10, {.d_s = val_str}}, {_SLIT0, 0, { .d_c = 0 }}}));
			} break;
		case v__ast__Kind__multi_return: 
			{
				res = _SLIT("(");
				v__ast__MultiReturn info = /* as */ *(v__ast__MultiReturn*)__as_cast((sym->info)._v__ast__MultiReturn,(sym->info)._typ, 471) /*expected idx: 471, name: v.ast.MultiReturn */ ;
				for (int i = 0; i < info.types.len; ++i) {
					v__ast__Type typ2 = ((v__ast__Type*)info.types.data)[i];
					if (i > 0) {
						res = /*f*/string__plus(res, _SLIT(", "));
					}
					res = /*f*/string__plus(res, v__ast__Table_type_to_str_using_aliases(t, typ2, import_aliases));
				}
				res = /*f*/string__plus(res, _SLIT(")"));
			} break;
		case v__ast__Kind__struct_: 
		case v__ast__Kind__interface_: 
		case v__ast__Kind__sum_type: 
			{
				if (v__ast__Type_has_flag(typ, v__ast__TypeFlag__generic)) {
					if (sym->info._typ == 446 /* v.ast.Struct */) {
						res = /*f*/string__plus(res, _SLIT("<"));
						for (int i = 0; i < (*sym->info._v__ast__Struct).generic_types.len; ++i) {
							v__ast__Type gtyp = ((v__ast__Type*)(*sym->info._v__ast__Struct).generic_types.data)[i];
							res = /*f*/string__plus(res, v__ast__Table_sym(t, gtyp)->name);
							if (i != (*sym->info._v__ast__Struct).generic_types.len - 1) {
								res = /*f*/string__plus(res, _SLIT(", "));
							}
						}
						res = /*f*/string__plus(res, _SLIT(">"));
					}
					else if (sym->info._typ == 463 /* v.ast.Interface */) {
						res = /*f*/string__plus(res, _SLIT("<"));
						for (int i = 0; i < (*sym->info._v__ast__Interface).generic_types.len; ++i) {
							v__ast__Type gtyp = ((v__ast__Type*)(*sym->info._v__ast__Interface).generic_types.data)[i];
							res = /*f*/string__plus(res, v__ast__Table_sym(t, gtyp)->name);
							if (i != (*sym->info._v__ast__Interface).generic_types.len - 1) {
								res = /*f*/string__plus(res, _SLIT(", "));
							}
						}
						res = /*f*/string__plus(res, _SLIT(">"));
					}
					else if (sym->info._typ == 464 /* v.ast.SumType */) {
						res = /*f*/string__plus(res, _SLIT("<"));
						for (int i = 0; i < (*sym->info._v__ast__SumType).generic_types.len; ++i) {
							v__ast__Type gtyp = ((v__ast__Type*)(*sym->info._v__ast__SumType).generic_types.data)[i];
							res = /*f*/string__plus(res, v__ast__Table_sym(t, gtyp)->name);
							if (i != (*sym->info._v__ast__SumType).generic_types.len - 1) {
								res = /*f*/string__plus(res, _SLIT(", "));
							}
						}
						res = /*f*/string__plus(res, _SLIT(">"));
					}
					
					else {
					}
					;
				} else if ((sym->info)._typ == 464 /* v.ast.SumType */ && (/* as */ *(v__ast__SumType*)__as_cast((sym->info)._v__ast__SumType,(sym->info)._typ, 464) /*expected idx: 464, name: v.ast.SumType */ ).is_anon) {
					Array_string _t5 = __new_array(0, 0, sizeof(string));
					Array_v__ast__Type _t5_orig = (*sym->info._v__ast__SumType).variants;
					int _t5_len = _t5_orig.len;
					_t5 = __new_array(0, _t5_len, sizeof(string));

					for (int _t6 = 0; _t6 < _t5_len; ++_t6) {
						v__ast__Type it = ((v__ast__Type*) _t5_orig.data)[_t6];
						string ti = v__ast__Table_shorten_user_defined_typenames(t, v__ast__Table_sym(t, it)->name, import_aliases);
						array_push((array*)&_t5, &ti);
					}
					Array_string variant_names =_t5;
					res =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = Array_string_join(variant_names, _SLIT(" | "))}}, {_SLIT0, 0, { .d_c = 0 }}}));
				} else {
					res = v__ast__Table_shorten_user_defined_typenames(t, res, import_aliases);
				}
			} break;
		case v__ast__Kind__generic_inst: 
			{
				v__ast__GenericInst info = /* as */ *(v__ast__GenericInst*)__as_cast((sym->info)._v__ast__GenericInst,(sym->info)._typ, 473) /*expected idx: 473, name: v.ast.GenericInst */ ;
				res = v__ast__Table_shorten_user_defined_typenames(t, string_all_before(sym->name, _SLIT("<")), import_aliases);
				res = /*f*/string__plus(res, _SLIT("<"));
				for (int i = 0; i < info.concrete_types.len; ++i) {
					v__ast__Type ctyp = ((v__ast__Type*)info.concrete_types.data)[i];
					res = /*f*/string__plus(res, v__ast__Table_type_to_str_using_aliases(t, ctyp, import_aliases));
					if (i != info.concrete_types.len - 1) {
						res = /*f*/string__plus(res, _SLIT(", "));
					}
				}
				res = /*f*/string__plus(res, _SLIT(">"));
			} break;
		case v__ast__Kind__void: 
			{
				if (v__ast__Type_has_flag(typ, v__ast__TypeFlag__optional)) {
					string _t7 = _SLIT("?");
					return _t7;
				}
				string _t8 = _SLIT("void");
				return _t8;
			} break;
		case v__ast__Kind__thread: 
			{
				v__ast__Type rtype = v__ast__TypeSymbol_thread_info(sym).return_type;
				if (rtype != 1) {
					res = string__plus(_SLIT("thread "), v__ast__Table_type_to_str_using_aliases(t, rtype, import_aliases));
				}
			} break;
		case v__ast__Kind__alias: 
		case v__ast__Kind__any: 
		case v__ast__Kind__aggregate: 
		case v__ast__Kind__placeholder: 
		case v__ast__Kind__enum_: 
			{
				res = v__ast__Table_shorten_user_defined_typenames(t, res, import_aliases);
			} break;
	}
	;
	int nr_muls = v__ast__Type_nr_muls(typ);
	if (v__ast__Type_has_flag(typ, v__ast__TypeFlag__shared_f)) {
		nr_muls--;
		res = string__plus(_SLIT("shared "), res);
	}
	if (nr_muls > 0 && !v__ast__Type_has_flag(typ, v__ast__TypeFlag__variadic)) {
		res = string__plus(strings__repeat('&', nr_muls), res);
	}
	if (v__ast__Type_has_flag(typ, v__ast__TypeFlag__optional)) {
		res =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("?"), 0xfe10, {.d_s = res}}, {_SLIT0, 0, { .d_c = 0 }}}));
	}
	string _t9 = res;
	return _t9;
}

VV_LOCAL_SYMBOL string v__ast__Table_shorten_user_defined_typenames(v__ast__Table* t, string originalname, Map_string_string import_aliases) {
	string res = originalname;
	if (t->cmod_prefix.len > 0 && string_starts_with(res, t->cmod_prefix)) {
		res = string_replace_once(res, t->cmod_prefix, _SLIT(""));
	} else if (_IN_MAP(ADDR(string, res), ADDR(map, import_aliases))) {
		res = (*(string*)map_get(ADDR(map, import_aliases), &(string[]){res}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} }));
	} else {
		Array_string parts = string_split(res, _SLIT("."));
		if (parts.len > 1) {
			int ind = parts.len - 2;
			if (t->is_fmt) {
				array_set(&parts, ind, &(string[]) { Array_string_join(array_slice(parts, 0, ind + 1), _SLIT(".")) });
			}
			if (_IN_MAP(ADDR(string, (*(string*)/*ee elem_typ */array_get(parts, ind))), ADDR(map, import_aliases))) {
				array_set(&parts, ind, &(string[]) { (*(string*)map_get(ADDR(map, import_aliases), &(string[]){(*(string*)/*ee elem_typ */array_get(parts, ind))}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })) });
			}
			res = Array_string_join(array_slice(parts, ind, parts.len), _SLIT("."));
		} else {
			res = (*(string*)/*ee elem_typ */array_get(parts, 0));
		}
	}
	string _t1 = res;
	return _t1;
}

string v__ast__Table_fn_signature(v__ast__Table* t, v__ast__Fn* func, v__ast__FnSignatureOpts opts) {
	string _t1 = v__ast__Table_fn_signature_using_aliases(t, func, new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string), opts);
	return _t1;
}

string v__ast__Table_fn_signature_using_aliases(v__ast__Table* t, v__ast__Fn* func, Map_string_string import_aliases, v__ast__FnSignatureOpts opts) {
	strings__Builder sb = strings__new_builder(20);
	if (!opts.skip_receiver) {
		strings__Builder_write_string(&sb, _SLIT("fn "));
	}
	if (!opts.type_only) {
		strings__Builder_write_string(&sb,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = func->name}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
	strings__Builder_write_string(&sb, _SLIT("("));
	int start = ((int)(opts.skip_receiver));
	for (int i = start; i < func->params.len; ++i) {
		if (i != start) {
			strings__Builder_write_string(&sb, _SLIT(", "));
		}
		v__ast__Param param = (*(v__ast__Param*)/*ee elem_typ */array_get(func->params, i));
		v__ast__Type typ = param.typ;
		if (param.is_mut) {
			if (v__ast__Type_is_ptr(param.typ)) {
				typ = v__ast__Type_deref(typ);
			}
			strings__Builder_write_string(&sb, _SLIT("mut "));
		}
		if (!opts.type_only) {
			strings__Builder_write_string(&sb,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = param.name}}, {_SLIT(" "), 0, { .d_c = 0 }}})));
		}
		string styp = v__ast__Table_type_to_str_using_aliases(t, typ, import_aliases);
		if (i == func->params.len - 1 && func->is_variadic) {
			strings__Builder_write_string(&sb,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("..."), 0xfe10, {.d_s = styp}}, {_SLIT0, 0, { .d_c = 0 }}})));
		} else {
			strings__Builder_write_string(&sb,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = styp}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
	}
	strings__Builder_write_string(&sb, _SLIT(")"));
	if (!v__ast__Type_alias_eq(func->return_type, _const_v__ast__void_type)) {
		strings__Builder_write_string(&sb,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(" "), 0xfe10, {.d_s = v__ast__Table_type_to_str_using_aliases(t, func->return_type, import_aliases)}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
	string _t1 = strings__Builder_str(&sb);
	return _t1;
}

string v__ast__TypeSymbol_embed_name(v__ast__TypeSymbol* t) {
	string embed_name = (*(string*)array_last(string_split(t->name, _SLIT("."))));
	if (string_contains(embed_name, _SLIT("<"))) {
		embed_name = (*(string*)/*ee elem_typ */array_get(string_split(embed_name, _SLIT("<")), 0));
	}
	string _t1 = embed_name;
	return _t1;
}

bool v__ast__TypeSymbol_has_method(v__ast__TypeSymbol* t, string name) {
	Array_v__ast__Fn _t1 = t->methods;
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		v__ast__Fn* method = ((v__ast__Fn*)_t1.data) + _t2;
		if (string__eq(method->name, name)) {
			bool _t3 = true;
			return _t3;
		}
	}
	bool _t4 = false;
	return _t4;
}

bool v__ast__TypeSymbol_has_method_with_generic_parent(v__ast__TypeSymbol* t, string name) {
	Option_v__ast__Fn _t1 = v__ast__TypeSymbol_find_method_with_generic_parent(t, name);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		bool _t2 = false;
		return _t2;
	}
	
  (*(v__ast__Fn*)_t1.data);
	bool _t3 = true;
	return _t3;
}

Option_v__ast__Fn v__ast__TypeSymbol_find_method(v__ast__TypeSymbol* t, string name) {
	Array_v__ast__Fn _t1 = t->methods;
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		v__ast__Fn* method = ((v__ast__Fn*)_t1.data) + _t2;
		if (string__eq(method->name, name)) {
			Option_v__ast__Fn _t3;
			opt_ok(&(v__ast__Fn[]) { *method }, (Option*)(&_t3), sizeof(v__ast__Fn));
			return _t3;
		}
	}
	return (Option_v__ast__Fn){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
}

Option_v__ast__Fn v__ast__TypeSymbol_find_method_with_generic_parent(v__ast__TypeSymbol* t, string name) {
	Option_v__ast__Fn _t1;
	if (_t1 = v__ast__TypeSymbol_find_method(t, name), _t1.state == 0) {
		v__ast__Fn m = *(v__ast__Fn*)_t1.data;
		Option_v__ast__Fn _t2;
		opt_ok(&(v__ast__Fn[]) { m }, (Option*)(&_t2), sizeof(v__ast__Fn));
		return _t2;
	}
	v__ast__Table* table = global_table;
	if (t->info._typ == 446 /* v.ast.Struct */) {
		if (v__ast__Type_has_flag((*t->info._v__ast__Struct).parent_type, v__ast__TypeFlag__generic)) {
			v__ast__TypeSymbol* parent_sym = v__ast__Table_sym(table, (*t->info._v__ast__Struct).parent_type);
			Option_v__ast__Fn _t3;
			if (_t3 = v__ast__TypeSymbol_find_method(parent_sym, name), _t3.state == 0) {
				v__ast__Fn x = *(v__ast__Fn*)_t3.data;
				if (parent_sym->info._typ == 446 /* v.ast.Struct */) {
					v__ast__Fn method = x;
					Array_string _t4 = __new_array(0, 0, sizeof(string));
					Array_v__ast__Type _t4_orig = (*parent_sym->info._v__ast__Struct).generic_types;
					int _t4_len = _t4_orig.len;
					_t4 = __new_array(0, _t4_len, sizeof(string));

					for (int _t5 = 0; _t5 < _t4_len; ++_t5) {
						v__ast__Type it = ((v__ast__Type*) _t4_orig.data)[_t5];
						string ti = v__ast__Table_sym(table, it)->name;
						array_push((array*)&_t4, &ti);
					}
					Array_string generic_names =_t4;
					Option_v__ast__Type _t6;
					if (_t6 = v__ast__Table_resolve_generic_to_concrete(table, method.return_type, generic_names, (*t->info._v__ast__Struct).concrete_types), _t6.state == 0) {
						v__ast__Type rt = *(v__ast__Type*)_t6.data;
						method.return_type = rt;
					}
					method.params = array_clone_to_depth(&method.params, 0);
					for (int _t7 = 0; _t7 < method.params.len; ++_t7) {
						v__ast__Param* param = ((v__ast__Param*)method.params.data) + _t7;
						Option_v__ast__Type _t8;
						if (_t8 = v__ast__Table_resolve_generic_to_concrete(table, param->typ, generic_names, (*t->info._v__ast__Struct).concrete_types), _t8.state == 0) {
							v__ast__Type pt = *(v__ast__Type*)_t8.data;
							param->typ = pt;
						}
					}
					array_clear(&method.generic_names);
					Option_v__ast__Fn _t9;
					opt_ok(&(v__ast__Fn[]) { method }, (Option*)(&_t9), sizeof(v__ast__Fn));
					return _t9;
				}
				else if (parent_sym->info._typ == 463 /* v.ast.Interface */) {
					v__ast__Fn method = x;
					Array_string _t10 = __new_array(0, 0, sizeof(string));
					Array_v__ast__Type _t10_orig = (*parent_sym->info._v__ast__Interface).generic_types;
					int _t10_len = _t10_orig.len;
					_t10 = __new_array(0, _t10_len, sizeof(string));

					for (int _t11 = 0; _t11 < _t10_len; ++_t11) {
						v__ast__Type it = ((v__ast__Type*) _t10_orig.data)[_t11];
						string ti = v__ast__Table_sym(table, it)->name;
						array_push((array*)&_t10, &ti);
					}
					Array_string generic_names =_t10;
					Option_v__ast__Type _t12;
					if (_t12 = v__ast__Table_resolve_generic_to_concrete(table, method.return_type, generic_names, (*t->info._v__ast__Interface).concrete_types), _t12.state == 0) {
						v__ast__Type rt = *(v__ast__Type*)_t12.data;
						method.return_type = rt;
					}
					method.params = array_clone_to_depth(&method.params, 0);
					for (int _t13 = 0; _t13 < method.params.len; ++_t13) {
						v__ast__Param* param = ((v__ast__Param*)method.params.data) + _t13;
						Option_v__ast__Type _t14;
						if (_t14 = v__ast__Table_resolve_generic_to_concrete(table, param->typ, generic_names, (*t->info._v__ast__Interface).concrete_types), _t14.state == 0) {
							v__ast__Type pt = *(v__ast__Type*)_t14.data;
							param->typ = pt;
						}
					}
					array_clear(&method.generic_names);
					Option_v__ast__Fn _t15;
					opt_ok(&(v__ast__Fn[]) { method }, (Option*)(&_t15), sizeof(v__ast__Fn));
					return _t15;
				}
				else if (parent_sym->info._typ == 464 /* v.ast.SumType */) {
					v__ast__Fn method = x;
					Array_string _t16 = __new_array(0, 0, sizeof(string));
					Array_v__ast__Type _t16_orig = (*parent_sym->info._v__ast__SumType).generic_types;
					int _t16_len = _t16_orig.len;
					_t16 = __new_array(0, _t16_len, sizeof(string));

					for (int _t17 = 0; _t17 < _t16_len; ++_t17) {
						v__ast__Type it = ((v__ast__Type*) _t16_orig.data)[_t17];
						string ti = v__ast__Table_sym(table, it)->name;
						array_push((array*)&_t16, &ti);
					}
					Array_string generic_names =_t16;
					Option_v__ast__Type _t18;
					if (_t18 = v__ast__Table_resolve_generic_to_concrete(table, method.return_type, generic_names, (*t->info._v__ast__SumType).concrete_types), _t18.state == 0) {
						v__ast__Type rt = *(v__ast__Type*)_t18.data;
						method.return_type = rt;
					}
					method.params = array_clone_to_depth(&method.params, 0);
					for (int _t19 = 0; _t19 < method.params.len; ++_t19) {
						v__ast__Param* param = ((v__ast__Param*)method.params.data) + _t19;
						Option_v__ast__Type _t20;
						if (_t20 = v__ast__Table_resolve_generic_to_concrete(table, param->typ, generic_names, (*t->info._v__ast__SumType).concrete_types), _t20.state == 0) {
							v__ast__Type pt = *(v__ast__Type*)_t20.data;
							param->typ = pt;
						}
					}
					array_clear(&method.generic_names);
					Option_v__ast__Fn _t21;
					opt_ok(&(v__ast__Fn[]) { method }, (Option*)(&_t21), sizeof(v__ast__Fn));
					return _t21;
				}
				
				else {
				}
				;
			} else {
				IError err = _t3.err;
			}
		}
	}
	else if (t->info._typ == 463 /* v.ast.Interface */) {
		if (v__ast__Type_has_flag((*t->info._v__ast__Interface).parent_type, v__ast__TypeFlag__generic)) {
			v__ast__TypeSymbol* parent_sym = v__ast__Table_sym(table, (*t->info._v__ast__Interface).parent_type);
			Option_v__ast__Fn _t22;
			if (_t22 = v__ast__TypeSymbol_find_method(parent_sym, name), _t22.state == 0) {
				v__ast__Fn x = *(v__ast__Fn*)_t22.data;
				if (parent_sym->info._typ == 446 /* v.ast.Struct */) {
					v__ast__Fn method = x;
					Array_string _t23 = __new_array(0, 0, sizeof(string));
					Array_v__ast__Type _t23_orig = (*parent_sym->info._v__ast__Struct).generic_types;
					int _t23_len = _t23_orig.len;
					_t23 = __new_array(0, _t23_len, sizeof(string));

					for (int _t24 = 0; _t24 < _t23_len; ++_t24) {
						v__ast__Type it = ((v__ast__Type*) _t23_orig.data)[_t24];
						string ti = v__ast__Table_sym(table, it)->name;
						array_push((array*)&_t23, &ti);
					}
					Array_string generic_names =_t23;
					Option_v__ast__Type _t25;
					if (_t25 = v__ast__Table_resolve_generic_to_concrete(table, method.return_type, generic_names, (*t->info._v__ast__Struct).concrete_types), _t25.state == 0) {
						v__ast__Type rt = *(v__ast__Type*)_t25.data;
						method.return_type = rt;
					}
					method.params = array_clone_to_depth(&method.params, 0);
					for (int _t26 = 0; _t26 < method.params.len; ++_t26) {
						v__ast__Param* param = ((v__ast__Param*)method.params.data) + _t26;
						Option_v__ast__Type _t27;
						if (_t27 = v__ast__Table_resolve_generic_to_concrete(table, param->typ, generic_names, (*t->info._v__ast__Struct).concrete_types), _t27.state == 0) {
							v__ast__Type pt = *(v__ast__Type*)_t27.data;
							param->typ = pt;
						}
					}
					array_clear(&method.generic_names);
					Option_v__ast__Fn _t28;
					opt_ok(&(v__ast__Fn[]) { method }, (Option*)(&_t28), sizeof(v__ast__Fn));
					return _t28;
				}
				else if (parent_sym->info._typ == 463 /* v.ast.Interface */) {
					v__ast__Fn method = x;
					Array_string _t29 = __new_array(0, 0, sizeof(string));
					Array_v__ast__Type _t29_orig = (*parent_sym->info._v__ast__Interface).generic_types;
					int _t29_len = _t29_orig.len;
					_t29 = __new_array(0, _t29_len, sizeof(string));

					for (int _t30 = 0; _t30 < _t29_len; ++_t30) {
						v__ast__Type it = ((v__ast__Type*) _t29_orig.data)[_t30];
						string ti = v__ast__Table_sym(table, it)->name;
						array_push((array*)&_t29, &ti);
					}
					Array_string generic_names =_t29;
					Option_v__ast__Type _t31;
					if (_t31 = v__ast__Table_resolve_generic_to_concrete(table, method.return_type, generic_names, (*t->info._v__ast__Interface).concrete_types), _t31.state == 0) {
						v__ast__Type rt = *(v__ast__Type*)_t31.data;
						method.return_type = rt;
					}
					method.params = array_clone_to_depth(&method.params, 0);
					for (int _t32 = 0; _t32 < method.params.len; ++_t32) {
						v__ast__Param* param = ((v__ast__Param*)method.params.data) + _t32;
						Option_v__ast__Type _t33;
						if (_t33 = v__ast__Table_resolve_generic_to_concrete(table, param->typ, generic_names, (*t->info._v__ast__Interface).concrete_types), _t33.state == 0) {
							v__ast__Type pt = *(v__ast__Type*)_t33.data;
							param->typ = pt;
						}
					}
					array_clear(&method.generic_names);
					Option_v__ast__Fn _t34;
					opt_ok(&(v__ast__Fn[]) { method }, (Option*)(&_t34), sizeof(v__ast__Fn));
					return _t34;
				}
				else if (parent_sym->info._typ == 464 /* v.ast.SumType */) {
					v__ast__Fn method = x;
					Array_string _t35 = __new_array(0, 0, sizeof(string));
					Array_v__ast__Type _t35_orig = (*parent_sym->info._v__ast__SumType).generic_types;
					int _t35_len = _t35_orig.len;
					_t35 = __new_array(0, _t35_len, sizeof(string));

					for (int _t36 = 0; _t36 < _t35_len; ++_t36) {
						v__ast__Type it = ((v__ast__Type*) _t35_orig.data)[_t36];
						string ti = v__ast__Table_sym(table, it)->name;
						array_push((array*)&_t35, &ti);
					}
					Array_string generic_names =_t35;
					Option_v__ast__Type _t37;
					if (_t37 = v__ast__Table_resolve_generic_to_concrete(table, method.return_type, generic_names, (*t->info._v__ast__SumType).concrete_types), _t37.state == 0) {
						v__ast__Type rt = *(v__ast__Type*)_t37.data;
						method.return_type = rt;
					}
					method.params = array_clone_to_depth(&method.params, 0);
					for (int _t38 = 0; _t38 < method.params.len; ++_t38) {
						v__ast__Param* param = ((v__ast__Param*)method.params.data) + _t38;
						Option_v__ast__Type _t39;
						if (_t39 = v__ast__Table_resolve_generic_to_concrete(table, param->typ, generic_names, (*t->info._v__ast__SumType).concrete_types), _t39.state == 0) {
							v__ast__Type pt = *(v__ast__Type*)_t39.data;
							param->typ = pt;
						}
					}
					array_clear(&method.generic_names);
					Option_v__ast__Fn _t40;
					opt_ok(&(v__ast__Fn[]) { method }, (Option*)(&_t40), sizeof(v__ast__Fn));
					return _t40;
				}
				
				else {
				}
				;
			} else {
				IError err = _t22.err;
			}
		}
	}
	else if (t->info._typ == 464 /* v.ast.SumType */) {
		if (v__ast__Type_has_flag((*t->info._v__ast__SumType).parent_type, v__ast__TypeFlag__generic)) {
			v__ast__TypeSymbol* parent_sym = v__ast__Table_sym(table, (*t->info._v__ast__SumType).parent_type);
			Option_v__ast__Fn _t41;
			if (_t41 = v__ast__TypeSymbol_find_method(parent_sym, name), _t41.state == 0) {
				v__ast__Fn x = *(v__ast__Fn*)_t41.data;
				if (parent_sym->info._typ == 446 /* v.ast.Struct */) {
					v__ast__Fn method = x;
					Array_string _t42 = __new_array(0, 0, sizeof(string));
					Array_v__ast__Type _t42_orig = (*parent_sym->info._v__ast__Struct).generic_types;
					int _t42_len = _t42_orig.len;
					_t42 = __new_array(0, _t42_len, sizeof(string));

					for (int _t43 = 0; _t43 < _t42_len; ++_t43) {
						v__ast__Type it = ((v__ast__Type*) _t42_orig.data)[_t43];
						string ti = v__ast__Table_sym(table, it)->name;
						array_push((array*)&_t42, &ti);
					}
					Array_string generic_names =_t42;
					Option_v__ast__Type _t44;
					if (_t44 = v__ast__Table_resolve_generic_to_concrete(table, method.return_type, generic_names, (*t->info._v__ast__Struct).concrete_types), _t44.state == 0) {
						v__ast__Type rt = *(v__ast__Type*)_t44.data;
						method.return_type = rt;
					}
					method.params = array_clone_to_depth(&method.params, 0);
					for (int _t45 = 0; _t45 < method.params.len; ++_t45) {
						v__ast__Param* param = ((v__ast__Param*)method.params.data) + _t45;
						Option_v__ast__Type _t46;
						if (_t46 = v__ast__Table_resolve_generic_to_concrete(table, param->typ, generic_names, (*t->info._v__ast__Struct).concrete_types), _t46.state == 0) {
							v__ast__Type pt = *(v__ast__Type*)_t46.data;
							param->typ = pt;
						}
					}
					array_clear(&method.generic_names);
					Option_v__ast__Fn _t47;
					opt_ok(&(v__ast__Fn[]) { method }, (Option*)(&_t47), sizeof(v__ast__Fn));
					return _t47;
				}
				else if (parent_sym->info._typ == 463 /* v.ast.Interface */) {
					v__ast__Fn method = x;
					Array_string _t48 = __new_array(0, 0, sizeof(string));
					Array_v__ast__Type _t48_orig = (*parent_sym->info._v__ast__Interface).generic_types;
					int _t48_len = _t48_orig.len;
					_t48 = __new_array(0, _t48_len, sizeof(string));

					for (int _t49 = 0; _t49 < _t48_len; ++_t49) {
						v__ast__Type it = ((v__ast__Type*) _t48_orig.data)[_t49];
						string ti = v__ast__Table_sym(table, it)->name;
						array_push((array*)&_t48, &ti);
					}
					Array_string generic_names =_t48;
					Option_v__ast__Type _t50;
					if (_t50 = v__ast__Table_resolve_generic_to_concrete(table, method.return_type, generic_names, (*t->info._v__ast__Interface).concrete_types), _t50.state == 0) {
						v__ast__Type rt = *(v__ast__Type*)_t50.data;
						method.return_type = rt;
					}
					method.params = array_clone_to_depth(&method.params, 0);
					for (int _t51 = 0; _t51 < method.params.len; ++_t51) {
						v__ast__Param* param = ((v__ast__Param*)method.params.data) + _t51;
						Option_v__ast__Type _t52;
						if (_t52 = v__ast__Table_resolve_generic_to_concrete(table, param->typ, generic_names, (*t->info._v__ast__Interface).concrete_types), _t52.state == 0) {
							v__ast__Type pt = *(v__ast__Type*)_t52.data;
							param->typ = pt;
						}
					}
					array_clear(&method.generic_names);
					Option_v__ast__Fn _t53;
					opt_ok(&(v__ast__Fn[]) { method }, (Option*)(&_t53), sizeof(v__ast__Fn));
					return _t53;
				}
				else if (parent_sym->info._typ == 464 /* v.ast.SumType */) {
					v__ast__Fn method = x;
					Array_string _t54 = __new_array(0, 0, sizeof(string));
					Array_v__ast__Type _t54_orig = (*parent_sym->info._v__ast__SumType).generic_types;
					int _t54_len = _t54_orig.len;
					_t54 = __new_array(0, _t54_len, sizeof(string));

					for (int _t55 = 0; _t55 < _t54_len; ++_t55) {
						v__ast__Type it = ((v__ast__Type*) _t54_orig.data)[_t55];
						string ti = v__ast__Table_sym(table, it)->name;
						array_push((array*)&_t54, &ti);
					}
					Array_string generic_names =_t54;
					Option_v__ast__Type _t56;
					if (_t56 = v__ast__Table_resolve_generic_to_concrete(table, method.return_type, generic_names, (*t->info._v__ast__SumType).concrete_types), _t56.state == 0) {
						v__ast__Type rt = *(v__ast__Type*)_t56.data;
						method.return_type = rt;
					}
					method.params = array_clone_to_depth(&method.params, 0);
					for (int _t57 = 0; _t57 < method.params.len; ++_t57) {
						v__ast__Param* param = ((v__ast__Param*)method.params.data) + _t57;
						Option_v__ast__Type _t58;
						if (_t58 = v__ast__Table_resolve_generic_to_concrete(table, param->typ, generic_names, (*t->info._v__ast__SumType).concrete_types), _t58.state == 0) {
							v__ast__Type pt = *(v__ast__Type*)_t58.data;
							param->typ = pt;
						}
					}
					array_clear(&method.generic_names);
					Option_v__ast__Fn _t59;
					opt_ok(&(v__ast__Fn[]) { method }, (Option*)(&_t59), sizeof(v__ast__Fn));
					return _t59;
				}
				
				else {
				}
				;
			} else {
				IError err = _t41.err;
			}
		}
	}
	
	else {
	}
	;
	return (Option_v__ast__Fn){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
}

bool v__ast__TypeSymbol_is_js_compatible(v__ast__TypeSymbol* t) {
	v__ast__Table* table = global_table;
	if (t->kind == v__ast__Kind__void) {
		bool _t1 = true;
		return _t1;
	}
	if (t->kind == v__ast__Kind__function) {
		bool _t2 = true;
		return _t2;
	}
	if (t->language == v__ast__Language__js || string_starts_with(t->name, _SLIT("JS."))) {
		bool _t3 = true;
		return _t3;
	}
	if (t->info._typ == 464 /* v.ast.SumType */) {
		for (int _t4 = 0; _t4 < (*t->info._v__ast__SumType).variants.len; ++_t4) {
			v__ast__Type variant = ((v__ast__Type*)(*t->info._v__ast__SumType).variants.data)[_t4];
			v__ast__TypeSymbol* sym = v__ast__Table_final_sym(table, variant);
			if (!v__ast__TypeSymbol_is_js_compatible(sym)) {
				bool _t5 = false;
				return _t5;
			}
		}
		bool _t6 = true;
		return _t6;
	}
	
	else {
		bool _t7 = true;
		return _t7;
	}
	;
	return 0;
}

multi_return_bool_bool_int v__ast__TypeSymbol_str_method_info(v__ast__TypeSymbol* t) {
	bool has_str_method = false;
	bool expects_ptr = false;
	int nr_args = 0;
	Option_v__ast__Fn _t1;
	if (_t1 = v__ast__TypeSymbol_find_method_with_generic_parent(t, _SLIT("str")), _t1.state == 0) {
		v__ast__Fn sym_str_method = *(v__ast__Fn*)_t1.data;
		has_str_method = true;
		nr_args = sym_str_method.params.len;
		if (nr_args > 0) {
			expects_ptr = v__ast__Type_is_ptr((*(v__ast__Param*)/*ee elem_typ */array_get(sym_str_method.params, 0)).typ);
		}
	}
	return (multi_return_bool_bool_int){.arg0=has_str_method, .arg1=expects_ptr, .arg2=nr_args};
}

Option_v__ast__StructField v__ast__TypeSymbol_find_field(v__ast__TypeSymbol* t, string name) {
	if (t->info._typ == 458 /* v.ast.Aggregate */) {
		Option_v__ast__StructField _t1 = v__ast__Aggregate_find_field(&(*t->info._v__ast__Aggregate), name);
		return _t1;
	}
	else if (t->info._typ == 446 /* v.ast.Struct */) {
		Option_v__ast__StructField _t2 = v__ast__Struct_find_field(&(*t->info._v__ast__Struct), name);
		return _t2;
	}
	else if (t->info._typ == 463 /* v.ast.Interface */) {
		Option_v__ast__StructField _t3 = v__ast__Interface_find_field(&(*t->info._v__ast__Interface), name);
		return _t3;
	}
	else if (t->info._typ == 464 /* v.ast.SumType */) {
		Option_v__ast__StructField _t4 = v__ast__SumType_find_field(&(*t->info._v__ast__SumType), name);
		return _t4;
	}
	
	else {
		return (Option_v__ast__StructField){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	;
	return (Option_v__ast__StructField){0};
}

VV_LOCAL_SYMBOL Option_v__ast__StructField v__ast__Aggregate_find_field(v__ast__Aggregate* a, string name) {
	Array_v__ast__StructField _t1 = a->fields;
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		v__ast__StructField* field = ((v__ast__StructField*)_t1.data) + _t2;
		if (string__eq(field->name, name)) {
			Option_v__ast__StructField _t3;
			opt_ok(&(v__ast__StructField[]) { *field }, (Option*)(&_t3), sizeof(v__ast__StructField));
			return _t3;
		}
	}
	return (Option_v__ast__StructField){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
}

Option_v__ast__StructField v__ast__Interface_find_field(v__ast__Interface* i, string name) {
	Array_v__ast__StructField _t1 = i->fields;
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		v__ast__StructField* field = ((v__ast__StructField*)_t1.data) + _t2;
		if (string__eq(field->name, name)) {
			Option_v__ast__StructField _t3;
			opt_ok(&(v__ast__StructField[]) { *field }, (Option*)(&_t3), sizeof(v__ast__StructField));
			return _t3;
		}
	}
	return (Option_v__ast__StructField){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
}

Option_v__ast__Fn v__ast__Interface_find_method(v__ast__Interface* i, string name) {
	Array_v__ast__Fn _t1 = i->methods;
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		v__ast__Fn* method = ((v__ast__Fn*)_t1.data) + _t2;
		if (string__eq(method->name, name)) {
			Option_v__ast__Fn _t3;
			opt_ok(&(v__ast__Fn[]) { *method }, (Option*)(&_t3), sizeof(v__ast__Fn));
			return _t3;
		}
	}
	return (Option_v__ast__Fn){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
}

bool v__ast__Interface_has_method(v__ast__Interface* i, string name) {
	Array_v__ast__Fn _t1 = i->methods;
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		v__ast__Fn* method = ((v__ast__Fn*)_t1.data) + _t2;
		if (string__eq(method->name, name)) {
			bool _t3 = true;
			return _t3;
		}
	}
	bool _t4 = false;
	return _t4;
}

Option_v__ast__StructField v__ast__Struct_find_field(v__ast__Struct* s, string name) {
	Array_v__ast__StructField _t1 = s->fields;
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		v__ast__StructField* field = ((v__ast__StructField*)_t1.data) + _t2;
		if (string__eq(field->name, name)) {
			Option_v__ast__StructField _t3;
			opt_ok(&(v__ast__StructField[]) { *field }, (Option*)(&_t3), sizeof(v__ast__StructField));
			return _t3;
		}
	}
	return (Option_v__ast__StructField){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
}

v__ast__StructField v__ast__Struct_get_field(v__ast__Struct* s, string name) {
	Option_v__ast__StructField _t1;
	if (_t1 = v__ast__Struct_find_field(s, name), _t1.state == 0) {
		v__ast__StructField field = *(v__ast__StructField*)_t1.data;
		v__ast__StructField _t2 = field;
		return _t2;
	}
	_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("unknown field `"), 0xfe10, {.d_s = name}}, {_SLIT("`"), 0, { .d_c = 0 }}})));
	VUNREACHABLE();
	return (v__ast__StructField){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.has_default_expr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_pub = 0,.default_val = (string){.str=(byteptr)"", .is_lit=1},.is_mut = 0,.is_global = 0,.is_volatile = 0,.default_expr_typ = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,};
}

Option_v__ast__StructField v__ast__SumType_find_field(v__ast__SumType* s, string name) {
	Array_v__ast__StructField _t1 = s->fields;
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		v__ast__StructField* field = ((v__ast__StructField*)_t1.data) + _t2;
		if (string__eq(field->name, name)) {
			Option_v__ast__StructField _t3;
			opt_ok(&(v__ast__StructField[]) { *field }, (Option*)(&_t3), sizeof(v__ast__StructField));
			return _t3;
		}
	}
	return (Option_v__ast__StructField){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
}

bool v__ast__Interface_defines_method(v__ast__Interface* i, string name) {
	Array_v__ast__Fn _t1 = i->methods;
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		v__ast__Fn* method = ((v__ast__Fn*)_t1.data) + _t2;
		if (string__eq(method->name, name)) {
			bool _t3 = true;
			return _t3;
		}
	}
	bool _t4 = false;
	return _t4;
}

void v__checker__Checker_assign_stmt(v__checker__Checker* c, v__ast__AssignStmt* node) {
bool v__checker__Checker_assign_stmt_defer_0 = false;
	c->expected_type = _const_v__ast__none_type;
	v__checker__Checker_assign_stmt_defer_0 = true;
	v__ast__Expr right_first = (*(v__ast__Expr*)/*ee elem_typ */array_get(node->right, 0));
	node->left_types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
	int right_len = node->right.len;
	v__ast__Type right_type0 = _const_v__ast__void_type;
	for (int i = 0; i < node->right.len; ++i) {
		v__ast__Expr right = ((v__ast__Expr*)node->right.data)[i];
		if ((right)._typ == 286 /* v.ast.CallExpr */ || (right)._typ == 300 /* v.ast.IfExpr */ || (right)._typ == 307 /* v.ast.LockExpr */ || (right)._typ == 309 /* v.ast.MatchExpr */) {
			v__ast__Type right_type = v__checker__Checker_expr(c, right);
			if (i == 0) {
				right_type0 = right_type;
				node->right_types = new_array_from_c_array(1, 1, sizeof(v__ast__Type), _MOV((v__ast__Type[1]){v__checker__Checker_check_expr_opt_call(c, right, right_type0)}));
			}
			v__ast__TypeSymbol* right_type_sym = v__ast__Table_sym(c->table, right_type);
			if (right_type_sym->kind == v__ast__Kind__multi_return) {
				if (node->right.len > 1) {
					v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot use multi-value "), 0xfe10, {.d_s = right_type_sym->name}}, {_SLIT(" in single-value context"), 0, { .d_c = 0 }}})), v__ast__Expr_position(right));
				}
				node->right_types = v__ast__TypeSymbol_mr_info(right_type_sym).types;
				right_len = node->right_types.len;
			} else if (v__ast__Type_alias_eq(right_type, _const_v__ast__void_type)) {
				right_len = 0;
			}
		}
		if ((right)._typ == 303 /* v.ast.InfixExpr */) {
			if ((*right._v__ast__InfixExpr).op == v__token__Kind__arrow) {
				v__checker__Checker_error(c, _SLIT("cannot use `<-` on the right-hand side of an assignment, as it does not return any values"), (*right._v__ast__InfixExpr).pos);
			}
		}
		if ((right)._typ == 299 /* v.ast.Ident */) {
			if ((*right._v__ast__Ident).is_mut) {
				v__checker__Checker_error(c, _SLIT("unexpected `mut` on right-hand side of assignment"), (*right._v__ast__Ident).mut_pos);
			}
		}
	}
	if (node->left.len != right_len) {
		if ((right_first)._typ == 286 /* v.ast.CallExpr */) {
			if (node->left_types.len > 0 && v__ast__Type_alias_eq((*(v__ast__Type*)/*ee elem_typ */array_get(node->left_types, 0)), _const_v__ast__void_type)) {
				// Defer begin
				if (v__checker__Checker_assign_stmt_defer_0) {
					c->expected_type = _const_v__ast__void_type;
				}
				// Defer end
				return;
			}
			v__checker__Checker_error(c,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("assignment mismatch: "), 0xfe07, {.d_i32 = node->left.len}}, {_SLIT(" variable(s) but `"), 0xfe10, {.d_s = (*right_first._v__ast__CallExpr).name}}, {_SLIT("()` returns "), 0xfe07, {.d_i32 = right_len}}, {_SLIT(" value(s)"), 0, { .d_c = 0 }}})), node->pos);
		} else {
			v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("assignment mismatch: "), 0xfe07, {.d_i32 = node->left.len}}, {_SLIT(" variable(s) "), 0xfe07, {.d_i32 = right_len}}, {_SLIT(" value(s)"), 0, { .d_c = 0 }}})), node->pos);
		}
		// Defer begin
		if (v__checker__Checker_assign_stmt_defer_0) {
			c->expected_type = _const_v__ast__void_type;
		}
		// Defer end
		return;
	}
	bool is_decl = node->op == v__token__Kind__decl_assign;
	for (int i = 0; i < node->left.len; ++i) {
		v__ast__Expr left = ((v__ast__Expr*)node->left.data)[i];
		if ((left)._typ == 286 /* v.ast.CallExpr */) {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot call function `"), 0xfe10, {.d_s = (*left._v__ast__CallExpr).name}}, {_SLIT("()` on the left side of an assignment"), 0, { .d_c = 0 }}})), (*left._v__ast__CallExpr).pos);
		} else if ((left)._typ == 316 /* v.ast.PrefixExpr */) {
			if (((*left._v__ast__PrefixExpr).right)._typ == 286 /* v.ast.CallExpr */ && (*left._v__ast__PrefixExpr).op == v__token__Kind__mul) {
				v__checker__Checker_error(c, _SLIT("cannot dereference a function call on the left side of an assignment, use a temporary variable"), (*left._v__ast__PrefixExpr).pos);
			}
		} else if ((left)._typ == 302 /* v.ast.IndexExpr */) {
			if (((*left._v__ast__IndexExpr).index)._typ == 317 /* v.ast.RangeExpr */) {
				v__checker__Checker_error(c, _SLIT("cannot reassign using range expression on the left side of an assignment"), (*left._v__ast__IndexExpr).pos);
			}
		}
		bool is_blank_ident = v__ast__Expr_is_blank_ident(left);
		v__ast__Type left_type = _const_v__ast__void_type;
		if (!is_decl && !is_blank_ident) {
			if ((left)._typ == 299 /* v.ast.Ident */ || (left)._typ == 319 /* v.ast.SelectorExpr */) {
				c->prevent_sum_type_unwrapping_once = true;
			}
			left_type = v__checker__Checker_expr(c, left);
			c->expected_type = v__checker__Checker_unwrap_generic(c, left_type);
			if (left_type != 0) {
				v__ast__TypeSymbol* sym = v__ast__Table_sym(c->table, left_type);
				if (sym->kind == v__ast__Kind__map) {
					if (node->right.len <= i) {
					} else {
						if (((*(v__ast__Expr*)/*ee elem_typ */array_get(node->right, i)))._typ == 324 /* v.ast.StructInit */) {
							v__checker__Checker_warn(c, _SLIT("assigning a struct literal to a map is deprecated - use `map{}` instead"), v__ast__Expr_position((*(v__ast__Expr*)/*ee elem_typ */array_get(node->right, i))));
							(*(v__ast__Expr*)/*ee elem_typ */array_get(node->right, i)) = v__ast__MapInit_to_sumtype_v__ast__Expr(ADDR(v__ast__MapInit, ((v__ast__MapInit){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.keys = __new_array(0, 0, sizeof(v__ast__Expr)),.vals = __new_array(0, 0, sizeof(v__ast__Expr)),.comments = __new_array(0, 0, sizeof(Array_v__ast__Comment)),.pre_cmnts = __new_array(0, 0, sizeof(v__ast__Comment)),.typ = 0,.key_type = 0,.value_type = 0,})));
						}
					}
				}
			}
		}
		if (node->right_types.len < node->left.len) {
			bool old_inside_ref_lit = c->inside_ref_lit;
			if ((left)._typ == 299 /* v.ast.Ident */) {
				if (((*left._v__ast__Ident).info)._typ == 408 /* v.ast.IdentVar */) {
					c->inside_ref_lit = c->inside_ref_lit || (*(*left._v__ast__Ident).info._v__ast__IdentVar).share == v__ast__ShareType__shared_t;
				}
			}
			c->inside_decl_rhs = is_decl;
			v__ast__Type right_type = v__checker__Checker_expr(c, (*(v__ast__Expr*)/*ee elem_typ */array_get(node->right, i)));
			c->inside_decl_rhs = false;
			c->inside_ref_lit = old_inside_ref_lit;
			if (node->right_types.len == i) {
				array_push((array*)&node->right_types, _MOV((v__ast__Type[]){ v__checker__Checker_check_expr_opt_call(c, (*(v__ast__Expr*)/*ee elem_typ */array_get(node->right, i)), right_type) }));
			}
		}
		v__ast__Expr right = (i < node->right.len ? ((*(v__ast__Expr*)/*ee elem_typ */array_get(node->right, i))) : ((*(v__ast__Expr*)/*ee elem_typ */array_get(node->right, 0))));
		v__ast__Type right_type = (*(v__ast__Type*)/*ee elem_typ */array_get(node->right_types, i));
		if ((right)._typ == 299 /* v.ast.Ident */) {
			v__ast__TypeSymbol* right_sym = v__ast__Table_sym(c->table, right_type);
			if ((right_sym->info)._typ == 446 /* v.ast.Struct */) {
				if ((*right_sym->info._v__ast__Struct).generic_types.len > 0) {
					Option_v__ast__ScopeObject _t2;
					if (_t2 = v__ast__Scope_find((*right._v__ast__Ident).scope, (*right._v__ast__Ident).name), _t2.state == 0) {
						v__ast__ScopeObject obj = *(v__ast__ScopeObject*)_t2.data;
						right_type = (*(obj.typ));
					}
				}
			}
		}
		if (is_decl) {
			if ((right)._typ == 324 /* v.ast.StructInit */) {
				if (v__ast__Type_has_flag((*right._v__ast__StructInit).typ, v__ast__TypeFlag__generic)) {
					v__checker__Checker_expr(c, right);
					right_type = (*right._v__ast__StructInit).typ;
				}
			} else if ((right)._typ == 316 /* v.ast.PrefixExpr */) {
				if ((*right._v__ast__PrefixExpr).op == v__token__Kind__amp && ((*right._v__ast__PrefixExpr).right)._typ == 324 /* v.ast.StructInit */) {
					right_type = v__checker__Checker_expr(c, right);
				}
			}
			if (v__ast__Expr_is_auto_deref_var(right)) {
				left_type = v__ast__mktyp(v__ast__Type_deref(right_type));
			} else {
				left_type = v__ast__mktyp(right_type);
			}
			if (v__ast__Type_alias_eq(left_type, _const_v__ast__int_type)) {
				if ((right)._typ == 304 /* v.ast.IntegerLiteral */) {
					bool is_large = (*right._v__ast__IntegerLiteral).val.len > 13;
					if (!is_large && (*right._v__ast__IntegerLiteral).val.len > 8) {
						i64 val = string_i64((*right._v__ast__IntegerLiteral).val);
						is_large = val > _const_v__checker__int_max || val < _const_v__checker__int_min;
					}
					if (is_large) {
						v__checker__Checker_error(c, _SLIT("overflow in implicit type `int`, use explicit type casting instead"), (*right._v__ast__IntegerLiteral).pos);
					}
				}
			}
		} else {
			v__checker__Checker_fail_if_immutable(c, left);
		}
		if (v__ast__Type_is_ptr(right_type) && v__ast__Type_is_ptr(left_type)) {
			if ((right)._typ == 299 /* v.ast.Ident */) {
				if (((*right._v__ast__Ident).obj)._typ == 357 /* v.ast.Var */) {
					v__ast__Var* obj = &(*(*right._v__ast__Ident).obj._v__ast__Var);
					if (c->fn_scope != ((voidptr)(0))) {
						Option_v__ast__Var_ptr _t3 = v__ast__Scope_find_var(c->fn_scope, (*(*right._v__ast__Ident).obj._v__ast__Var).name);
						if (_t3.state != 0) { /*or block*/ 
							IError err = _t3.err;
							*(v__ast__Var**) _t3.data = obj;
						}
						
 						obj =  (*(v__ast__Var**)_t3.data);
					}
					if (obj->is_stack_obj && !c->inside_unsafe) {
						v__ast__TypeSymbol* type_sym = v__ast__Table_sym(c->table, v__ast__Type_set_nr_muls(obj->typ, 0));
						if (!v__ast__TypeSymbol_is_heap(type_sym) && !c->pref->translated) {
							string suggestion = (type_sym->kind == v__ast__Kind__struct_ ? ( str_intp(2, _MOV((StrIntpData[]){{_SLIT("declaring `"), 0xfe10, {.d_s = type_sym->name}}, {_SLIT("` as `[heap]`"), 0, { .d_c = 0 }}}))) : ( str_intp(2, _MOV((StrIntpData[]){{_SLIT("wrapping the `"), 0xfe10, {.d_s = type_sym->name}}, {_SLIT("` object in a `struct` declared as `[heap]`"), 0, { .d_c = 0 }}}))));
							v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = (*right._v__ast__Ident).name}}, {_SLIT("` cannot be assigned outside `unsafe` blocks as it might refer to an object stored on stack. Consider "), 0xfe10, {.d_s = suggestion}}, {_SLIT("."), 0, { .d_c = 0 }}})), (*right._v__ast__Ident).pos);
						}
					}
				}
			}
		}
		if (!is_decl && (left)._typ == 299 /* v.ast.Ident */ && !is_blank_ident && !v__ast__Type_is_real_pointer(left_type) && v__ast__Type_is_real_pointer(right_type)) {
			v__ast__TypeSymbol* left_sym = v__ast__Table_sym(c->table, left_type);
			if (left_sym->kind != v__ast__Kind__function) {
				v__checker__Checker_warn(c, string__plus( str_intp(3, _MOV((StrIntpData[]){{_SLIT("cannot assign a reference to a value (this will be an error soon) left="), 0xfe10, {.d_s = v__ast__Table_type_str(c->table, left_type)}}, {_SLIT(" "), 0xfe10, {.d_s = v__ast__Type_is_ptr(left_type) ? _SLIT("true") : _SLIT("false")}}, {_SLIT(" "), 0, { .d_c = 0 }}})),  str_intp(4, _MOV((StrIntpData[]){{_SLIT("right="), 0xfe10, {.d_s = v__ast__Table_type_str(c->table, right_type)}}, {_SLIT(" "), 0xfe10, {.d_s = v__ast__Type_is_real_pointer(right_type) ? _SLIT("true") : _SLIT("false")}}, {_SLIT(" ptr="), 0xfe10, {.d_s = v__ast__Type_is_ptr(right_type) ? _SLIT("true") : _SLIT("false")}}, {_SLIT0, 0, { .d_c = 0 }}}))), node->pos);
			}
		}
		array_push((array*)&node->left_types, _MOV((v__ast__Type[]){ left_type }));
		if (left._typ == 299 /* v.ast.Ident */) {
			if ((*left._v__ast__Ident).kind == v__ast__IdentKind__blank_ident) {
				left_type = right_type;
				(*(v__ast__Type*)/*ee elem_typ */array_get(node->left_types, i)) = right_type;
				if (!(node->op == v__token__Kind__assign || node->op == v__token__Kind__decl_assign)) {
					v__checker__Checker_error(c, _SLIT("cannot modify blank `_` identifier"), (*left._v__ast__Ident).pos);
				}
			} else if (((*left._v__ast__Ident).info)._typ != 408 /* v.ast.IdentVar */) {
				v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("cannot assign to "), 0xfe10, {.d_s = v__ast__IdentKind_str((*left._v__ast__Ident).kind)}}, {_SLIT(" `"), 0xfe10, {.d_s = (*left._v__ast__Ident).name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), (*left._v__ast__Ident).pos);
			} else {
				if (is_decl) {
					v__checker__Checker_check_valid_snake_case(c, (*left._v__ast__Ident).name, _SLIT("variable name"), (*left._v__ast__Ident).pos);
					if (Array_string_contains(_const_v__checker__reserved_type_names, (*left._v__ast__Ident).name)) {
						v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("invalid use of reserved type `"), 0xfe10, {.d_s = (*left._v__ast__Ident).name}}, {_SLIT("` as a variable name"), 0, { .d_c = 0 }}})), (*left._v__ast__Ident).pos);
					}
				}
				v__ast__IdentVar ident_var_info = /* as */ *(v__ast__IdentVar*)__as_cast(((*left._v__ast__Ident).info)._v__ast__IdentVar,((*left._v__ast__Ident).info)._typ, 408) /*expected idx: 408, name: v.ast.IdentVar */ ;
				if (ident_var_info.share == v__ast__ShareType__shared_t) {
					left_type = v__ast__Type_set_flag(left_type, v__ast__TypeFlag__shared_f);
					if (is_decl) {
						if (v__ast__Type_nr_muls(left_type) > 1) {
							v__checker__Checker_error(c, _SLIT("shared cannot be multi level reference"), (*left._v__ast__Ident).pos);
						}
						left_type = v__ast__Type_set_nr_muls(left_type, 1);
					}
				} else if (v__ast__Type_has_flag(left_type, v__ast__TypeFlag__shared_f)) {
					left_type = v__ast__Type_clear_flag(left_type, v__ast__TypeFlag__shared_f);
				}
				if (ident_var_info.share == v__ast__ShareType__atomic_t) {
					left_type = v__ast__Type_set_flag(left_type, v__ast__TypeFlag__atomic_f);
				}
				(*(v__ast__Type*)/*ee elem_typ */array_get(node->left_types, i)) = left_type;
				ident_var_info.typ = left_type;
				(*left._v__ast__Ident).info = v__ast__IdentVar_to_sumtype_v__ast__IdentInfo(&ident_var_info);
				if (left_type != 0) {
					if ((*left._v__ast__Ident).obj._typ == 357 /* v.ast.Var */) {
						(*(*left._v__ast__Ident).obj._v__ast__Var).typ = left_type;
						if ((*(*left._v__ast__Ident).obj._v__ast__Var).is_auto_deref) {
							(*(*left._v__ast__Ident).obj._v__ast__Var).is_used = true;
						}
						if (!v__ast__Type_is_ptr(left_type)) {
							if (v__ast__TypeSymbol_is_heap(v__ast__Table_sym(c->table, left_type))) {
								(*(*left._v__ast__Ident).obj._v__ast__Var).is_auto_heap = true;
							}
						}
						if (Array_int_contains(_const_v__ast__unsigned_integer_type_idxs, left_type)) {
							if ((right)._typ == 304 /* v.ast.IntegerLiteral */) {
								if (string_at((*right._v__ast__IntegerLiteral).val, 0) == '-') {
									v__checker__Checker_error(c, _SLIT("Cannot assign negative value to unsigned integer type"), (*right._v__ast__IntegerLiteral).pos);
								}
							}
						}
					}
					else if ((*left._v__ast__Ident).obj._typ == 356 /* v.ast.GlobalField */) {
						(*(*left._v__ast__Ident).obj._v__ast__GlobalField).typ = left_type;
					}
					
					else {
					}
					;
				}
				if (is_decl) {
					string full_name =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = (*left._v__ast__Ident).mod}}, {_SLIT("."), 0xfe10, {.d_s = (*left._v__ast__Ident).name}}, {_SLIT0, 0, { .d_c = 0 }}}));
					Option_v__ast__ScopeObject _t5;
					if (_t5 = v__ast__Scope_find(c->file->global_scope, full_name), _t5.state == 0) {
						v__ast__ScopeObject obj = *(v__ast__ScopeObject*)_t5.data;
						if ((obj)._typ == 355 /* v.ast.ConstField */) {
							v__checker__Checker_warn(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("duplicate of a const name `"), 0xfe10, {.d_s = full_name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), (*left._v__ast__Ident).pos);
						}
					}
				}
			}
		}
		else if (left._typ == 316 /* v.ast.PrefixExpr */) {
			if ((*left._v__ast__PrefixExpr).op == v__token__Kind__mul) {
				if (!c->inside_unsafe && !c->pref->translated) {
					v__checker__Checker_error(c, _SLIT("modifying variables via dereferencing can only be done in `unsafe` blocks"), node->pos);
				} else {
					if ((*left._v__ast__PrefixExpr).right._typ == 299 /* v.ast.Ident */) {
						if ((*(*left._v__ast__PrefixExpr).right._v__ast__Ident).obj._typ == 357 /* v.ast.Var */) {
							(*(*(*left._v__ast__PrefixExpr).right._v__ast__Ident).obj._v__ast__Var).is_used = true;
						}
						
						else {
						}
						;
					}
					
					else {
					}
					;
				}
			}
			if (is_decl) {
				v__checker__Checker_error(c, _SLIT("non-name on the left side of `:=`"), (*left._v__ast__PrefixExpr).pos);
			}
		}
		else if (left._typ == 319 /* v.ast.SelectorExpr */) {
			if (((*left._v__ast__SelectorExpr).expr)._typ == 302 /* v.ast.IndexExpr */) {
				if ((*(*left._v__ast__SelectorExpr).expr._v__ast__IndexExpr).is_map) {
					(*(*left._v__ast__SelectorExpr).expr._v__ast__IndexExpr).is_setter = true;
				}
			}
		}
		
		else {
			if ((left)._typ == 302 /* v.ast.IndexExpr */) {
				if ((*left._v__ast__IndexExpr).is_map && (*left._v__ast__IndexExpr).is_setter) {
					v__ast__IndexExpr_recursive_mapset_is_setter(&(*left._v__ast__IndexExpr), true);
				}
			}
			if (is_decl) {
				v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("non-name `"), 0xfe10, {.d_s = v__ast__Expr_str(left)}}, {_SLIT("` on left side of `:=`"), 0, { .d_c = 0 }}})), v__ast__Expr_position(left));
			}
		}
		;
		v__ast__Type left_type_unwrapped = v__checker__Checker_unwrap_generic(c, left_type);
		v__ast__Type right_type_unwrapped = v__checker__Checker_unwrap_generic(c, right_type);
		if (right_type_unwrapped == 0) {
			continue;
		}
		if (c->pref->translated) {
			continue;
		}
		if (left_type_unwrapped == 0) {
			continue;
		}
		v__ast__TypeSymbol* left_sym = v__ast__Table_sym(c->table, left_type_unwrapped);
		v__ast__TypeSymbol* right_sym = v__ast__Table_sym(c->table, right_type_unwrapped);
		if (left_sym->kind == v__ast__Kind__array && !c->inside_unsafe && (node->op == v__token__Kind__assign || node->op == v__token__Kind__decl_assign) && right_sym->kind == v__ast__Kind__array && ((left)._typ == 299 /* v.ast.Ident */ && !v__ast__Expr_is_blank_ident(left)) && (right)._typ == 299 /* v.ast.Ident */) {
			v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("use `array2 "), 0xfe10, {.d_s = v__token__Kind_str(node->op)}}, {_SLIT(" array1.clone()` instead of `array2 "), 0xfe10, {.d_s = v__token__Kind_str(node->op)}}, {_SLIT(" array1` (or use `unsafe`)"), 0, { .d_c = 0 }}})), node->pos);
		}
		if (left_sym->kind == v__ast__Kind__array_fixed && !c->inside_unsafe && (node->op == v__token__Kind__assign || node->op == v__token__Kind__decl_assign) && right_sym->kind == v__ast__Kind__array_fixed && ((left)._typ == 299 /* v.ast.Ident */ && !v__ast__Expr_is_blank_ident(left)) && (right)._typ == 299 /* v.ast.Ident */) {
			if ((right_sym->info)._typ == 468 /* v.ast.ArrayFixed */) {
				if (v__ast__Type_is_ptr((*right_sym->info._v__ast__ArrayFixed).elem_type)) {
					v__checker__Checker_error(c, _SLIT("assignment from one fixed array to another with a pointer element type is prohibited outside of `unsafe`"), node->pos);
				}
			}
		}
		if (left_sym->kind == v__ast__Kind__map && (node->op == v__token__Kind__assign || node->op == v__token__Kind__decl_assign) && right_sym->kind == v__ast__Kind__map && (((right)._typ == 299 /* v.ast.Ident */ && v__ast__Expr_is_auto_deref_var(right)) || !v__ast__Type_is_ptr(right_type)) && !v__ast__Expr_is_blank_ident(left) && v__ast__Expr_is_lvalue(right)) {
			v__checker__Checker_error(c, _SLIT("cannot copy map: call `move` or `clone` method (or use a reference)"), v__ast__Expr_position(right));
		}
		bool left_is_ptr = v__ast__Type_is_ptr(left_type) || v__ast__TypeSymbol_is_pointer(left_sym);
		if (left_is_ptr && !v__ast__Expr_is_auto_deref_var(left)) {
			if (!c->inside_unsafe && !(node->op == v__token__Kind__assign || node->op == v__token__Kind__decl_assign)) {
				v__checker__Checker_warn(c, _SLIT("pointer arithmetic is only allowed in `unsafe` blocks"), node->pos);
			}
			bool right_is_ptr = v__ast__Type_is_ptr(right_type) || v__ast__TypeSymbol_is_pointer(right_sym);
			if (!right_is_ptr && node->op == v__token__Kind__assign && v__ast__Type_is_number(right_type_unwrapped)) {
				v__checker__Checker_error(c, string__plus( str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot assign to `"), 0xfe10, {.d_s = v__ast__Expr_str(left)}}, {_SLIT("`: "), 0, { .d_c = 0 }}})), v__checker__Checker_expected_msg(c, right_type_unwrapped, left_type_unwrapped)), v__ast__Expr_position(right));
			}
			if (((right)._typ == 324 /* v.ast.StructInit */ || !right_is_ptr) && !(v__ast__TypeSymbol_is_number(right_sym) || v__ast__Type_has_flag(left_type, v__ast__TypeFlag__shared_f))) {
				string left_name = v__ast__Table_type_to_str(c->table, left_type_unwrapped);
				v__ast__Type rtype = right_type_unwrapped;
				if (v__ast__Type_is_ptr(rtype)) {
					rtype = v__ast__Type_deref(rtype);
				}
				string right_name = v__ast__Table_type_to_str(c->table, rtype);
				v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("mismatched types `"), 0xfe10, {.d_s = left_name}}, {_SLIT("` and `"), 0xfe10, {.d_s = right_name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node->pos);
			}
		}

		if (node->op == (v__token__Kind__assign)) {
		}
		else if (node->op == (v__token__Kind__plus_assign) || node->op == (v__token__Kind__minus_assign)) {
			if (v__ast__Type_alias_eq(left_type, _const_v__ast__string_type)) {
				if (node->op != v__token__Kind__plus_assign) {
					v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("operator `"), 0xfe10, {.d_s = v__token__Kind_str(node->op)}}, {_SLIT("` not defined on left operand type `"), 0xfe10, {.d_s = left_sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), v__ast__Expr_position(left));
				}
				if (!v__ast__Type_alias_eq(right_type, _const_v__ast__string_type)) {
					v__checker__Checker_error(c,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("invalid right operand: "), 0xfe10, {.d_s = left_sym->name}}, {_SLIT(" "), 0xfe10, {.d_s = v__token__Kind_str(node->op)}}, {_SLIT(" "), 0xfe10, {.d_s = right_sym->name}}, {_SLIT0, 0, { .d_c = 0 }}})), v__ast__Expr_position(right));
				}
			} else if (!v__ast__TypeSymbol_is_number(left_sym) && !(left_sym->kind == v__ast__Kind__byteptr || left_sym->kind == v__ast__Kind__charptr || left_sym->kind == v__ast__Kind__struct_ || left_sym->kind == v__ast__Kind__alias)) {
				v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("operator `"), 0xfe10, {.d_s = v__token__Kind_str(node->op)}}, {_SLIT("` not defined on left operand type `"), 0xfe10, {.d_s = left_sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), v__ast__Expr_position(left));
			} else if (!v__ast__TypeSymbol_is_number(right_sym) && !(left_sym->kind == v__ast__Kind__byteptr || left_sym->kind == v__ast__Kind__charptr || left_sym->kind == v__ast__Kind__struct_ || left_sym->kind == v__ast__Kind__alias)) {
				v__checker__Checker_error(c,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("invalid right operand: "), 0xfe10, {.d_s = left_sym->name}}, {_SLIT(" "), 0xfe10, {.d_s = v__token__Kind_str(node->op)}}, {_SLIT(" "), 0xfe10, {.d_s = right_sym->name}}, {_SLIT0, 0, { .d_c = 0 }}})), v__ast__Expr_position(right));
			}
		}
		else if (node->op == (v__token__Kind__mult_assign) || node->op == (v__token__Kind__div_assign)) {
			if (!v__ast__TypeSymbol_is_number(left_sym) && !v__ast__TypeSymbol_is_int(v__ast__Table_final_sym(c->table, left_type_unwrapped)) && !(left_sym->kind == v__ast__Kind__struct_ || left_sym->kind == v__ast__Kind__alias)) {
				v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("operator "), 0xfe10, {.d_s = v__token__Kind_str(node->op)}}, {_SLIT(" not defined on left operand type `"), 0xfe10, {.d_s = left_sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), v__ast__Expr_position(left));
			} else if (!v__ast__TypeSymbol_is_number(right_sym) && !v__ast__TypeSymbol_is_int(v__ast__Table_final_sym(c->table, left_type_unwrapped)) && !(left_sym->kind == v__ast__Kind__struct_ || left_sym->kind == v__ast__Kind__alias)) {
				v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("operator "), 0xfe10, {.d_s = v__token__Kind_str(node->op)}}, {_SLIT(" not defined on right operand type `"), 0xfe10, {.d_s = right_sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), v__ast__Expr_position(right));
			}
		}
		else if (node->op == (v__token__Kind__and_assign) || node->op == (v__token__Kind__or_assign) || node->op == (v__token__Kind__xor_assign) || node->op == (v__token__Kind__mod_assign) || node->op == (v__token__Kind__left_shift_assign) || node->op == (v__token__Kind__right_shift_assign)) {
			if (!v__ast__TypeSymbol_is_int(left_sym) && !v__ast__TypeSymbol_is_int(v__ast__Table_final_sym(c->table, left_type_unwrapped))) {
				v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("operator "), 0xfe10, {.d_s = v__token__Kind_str(node->op)}}, {_SLIT(" not defined on left operand type `"), 0xfe10, {.d_s = left_sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), v__ast__Expr_position(left));
			} else if (!v__ast__TypeSymbol_is_int(right_sym) && !v__ast__TypeSymbol_is_int(v__ast__Table_final_sym(c->table, right_type_unwrapped))) {
				v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("operator "), 0xfe10, {.d_s = v__token__Kind_str(node->op)}}, {_SLIT(" not defined on right operand type `"), 0xfe10, {.d_s = right_sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), v__ast__Expr_position(right));
			}
		}
		else if (node->op == (v__token__Kind__unsigned_right_shift_assign)) {
			if (node->left.len != 1 || node->right.len != 1) {
				v__checker__Checker_error(c, _SLIT("unsupported operation: unable to lower expression for unsigned shift assignment."), node->pos);
			}
			int _t6; /* if prepend */
			if (!v__ast__Type_is_int(left_type)) {
				v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("invalid operation: shift on type `"), 0xfe10, {.d_s = v__ast__Table_sym(c->table, left_type)->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node->pos);
				_t6 = _const_v__ast__void_type_idx;
			} else if (v__ast__Type_is_int_literal(left_type)) {
				_t6 = _const_v__ast__u32_type_idx;
			} else if (v__ast__Type_is_unsigned(left_type)) {
				_t6 = left_type;
			} else {
				_t6 = v__ast__Type_idx(left_type) + _const_v__ast__u32_type_idx - _const_v__ast__int_type_idx;
			}
			int modified_left_type =  _t6;
			*node = (v__ast__AssignStmt){
				.op = v__token__Kind__assign,
				.pos = node->pos,
				.comments = node->comments,
				.end_comments = node->end_comments,
				.right = new_array_from_c_array(1, 1, sizeof(v__ast__Expr), _MOV((v__ast__Expr[1]){v__ast__InfixExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__InfixExpr, ((v__ast__InfixExpr){
					.op = v__token__Kind__right_shift,
					.pos = node->pos,
					.is_stmt = 0,
					.left = v__ast__CastExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__CastExpr, ((v__ast__CastExpr){.arg = {0},.typ = modified_left_type,.expr = (*(v__ast__Expr*)/*ee elem_typ */array_get(node->left, 0)),.typname = v__ast__Table_type_str(c->table, modified_left_type),.expr_type = 0,.has_arg = 0,.pos = node->pos,}))),
					.right = (*(v__ast__Expr*)/*ee elem_typ */array_get(node->right, 0)),
					.left_type = modified_left_type,
					.right_type = right_type,
					.auto_locked = (string){.str=(byteptr)"", .is_lit=1},
					.or_block = (v__ast__OrExpr){.stmts = __new_array(0, 0, sizeof(v__ast__Stmt)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},},
					.ct_left_value_evaled = 0,
					.ct_left_value = v__ast__empty_comptime_const_expr(),
					.ct_right_value_evaled = 0,
					.ct_right_value = v__ast__empty_comptime_const_expr(),
				})))})),
				.left = node->left,
				.left_types = node->left_types,
				.right_types = node->right_types,
				.is_static = node->is_static,
				.is_volatile = 0,
				.is_simple = node->is_simple,
				.has_cross_var = node->has_cross_var,
			};
		}
		else {
		};
		if ((node->op == v__token__Kind__plus_assign || node->op == v__token__Kind__minus_assign || node->op == v__token__Kind__mod_assign || node->op == v__token__Kind__mult_assign || node->op == v__token__Kind__div_assign) && ((left_sym->kind == v__ast__Kind__struct_ && right_sym->kind == v__ast__Kind__struct_) || left_sym->kind == v__ast__Kind__alias)) {
			string left_name = v__ast__Table_type_to_str(c->table, left_type_unwrapped);
			string right_name = v__ast__Table_type_to_str(c->table, right_type_unwrapped);
			v__ast__TypeSymbol* parent_sym = v__ast__Table_final_sym(c->table, left_type_unwrapped);
			if (left_sym->kind == v__ast__Kind__alias && right_sym->kind != v__ast__Kind__alias) {
				v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("mismatched types `"), 0xfe10, {.d_s = left_name}}, {_SLIT("` and `"), 0xfe10, {.d_s = right_name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node->pos);
			}
			string _t7 = (string){.str=(byteptr)"", .is_lit=1};
			
			if (node->op == (v__token__Kind__plus_assign)) {
				_t7 = _SLIT("+");
			}
			else if (node->op == (v__token__Kind__minus_assign)) {
				_t7 = _SLIT("-");
			}
			else if (node->op == (v__token__Kind__div_assign)) {
				_t7 = _SLIT("/");
			}
			else if (node->op == (v__token__Kind__mod_assign)) {
				_t7 = _SLIT("%");
			}
			else if (node->op == (v__token__Kind__mult_assign)) {
				_t7 = _SLIT("*");
			}
			else {
				_t7 = _SLIT("unknown op");
			}string extracted_op = _t7;
			if (left_sym->kind == v__ast__Kind__struct_ && (/* as */ *(v__ast__Struct*)__as_cast((left_sym->info)._v__ast__Struct,(left_sym->info)._typ, 446) /*expected idx: 446, name: v.ast.Struct */ ).generic_types.len > 0) {
				continue;
			}
			Option_v__ast__Fn _t8;
			if (_t8 = v__ast__TypeSymbol_find_method(left_sym, extracted_op), _t8.state == 0) {
				v__ast__Fn method = *(v__ast__Fn*)_t8.data;
				if (!v__ast__Type_alias_eq(method.return_type, left_type_unwrapped)) {
					v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("operator `"), 0xfe10, {.d_s = extracted_op}}, {_SLIT("` must return `"), 0xfe10, {.d_s = left_name}}, {_SLIT("` to be used as an assignment operator"), 0, { .d_c = 0 }}})), node->pos);
				}
			} else {
				IError err = _t8.err;
				if (v__ast__TypeSymbol_is_primitive(parent_sym)) {
					v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot use operator methods on type alias for `"), 0xfe10, {.d_s = parent_sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node->pos);
				}
				if (string__eq(left_name, right_name)) {
					v__checker__Checker_error(c,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("undefined operation `"), 0xfe10, {.d_s = left_name}}, {_SLIT("` "), 0xfe10, {.d_s = extracted_op}}, {_SLIT(" `"), 0xfe10, {.d_s = right_name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node->pos);
				} else {
					v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("mismatched types `"), 0xfe10, {.d_s = left_name}}, {_SLIT("` and `"), 0xfe10, {.d_s = right_name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node->pos);
				}
			}
		}
		if (!is_blank_ident && !v__ast__Expr_is_auto_deref_var(left) && !v__ast__Expr_is_auto_deref_var(right) && right_sym->kind != v__ast__Kind__placeholder && left_sym->kind != v__ast__Kind__interface_ && !v__ast__Type_has_flag(right_type, v__ast__TypeFlag__generic) && !v__ast__Type_has_flag(left_type, v__ast__TypeFlag__generic)) {
			Option_void _t9 = v__checker__Checker_check_expected(c, right_type_unwrapped, left_type_unwrapped);
			if (_t9.state != 0 && _t9.err._typ != _IError_None___index) {
				IError err = _t9.err;
				if (v__ast__Type_is_ptr(left_type_unwrapped) && v__ast__Type_is_int(right_type_unwrapped) && (node->op == v__token__Kind__plus_assign || node->op == v__token__Kind__minus_assign)) {
					if (!c->inside_unsafe) {
						v__checker__Checker_warn(c, _SLIT("pointer arithmetic is only allowed in `unsafe` blocks"), node->pos);
					}
				} else {
					v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("cannot assign to `"), 0xfe10, {.d_s = v__ast__Expr_str(left)}}, {_SLIT("`: "), 0xfe10, {.d_s = (*(err.msg))}}, {_SLIT0, 0, { .d_c = 0 }}})), v__ast__Expr_position(right));
				}
			;
			}
			
 ;
		}
		if (left_sym->kind == v__ast__Kind__interface_) {
			if (v__checker__Checker_type_implements(c, right_type, left_type, v__ast__Expr_position(right))) {
				if (!v__ast__Type_is_ptr(right_type) && !v__ast__Type_is_pointer(right_type) && right_sym->kind != v__ast__Kind__interface_ && !c->inside_unsafe) {
					v__checker__Checker_mark_as_referenced(c, &(*(v__ast__Expr*)/*ee elem_typ */array_get(node->right, i)), true);
				}
			}
		}
	}
	if ((right_first)._typ == 316 /* v.ast.PrefixExpr */) {
		v__ast__PrefixExpr right_node = (*right_first._v__ast__PrefixExpr);
		v__ast__Expr left_first = (*(v__ast__Expr*)/*ee elem_typ */array_get(node->left, 0));
		if ((left_first)._typ == 299 /* v.ast.Ident */) {
			v__ast__Ident assigned_var = (*left_first._v__ast__Ident);
			bool is_shared = false;
			if (((*left_first._v__ast__Ident).info)._typ == 408 /* v.ast.IdentVar */) {
				is_shared = (*(*left_first._v__ast__Ident).info._v__ast__IdentVar).share == v__ast__ShareType__shared_t;
			}
			bool old_inside_ref_lit = c->inside_ref_lit;
			c->inside_ref_lit = (c->inside_ref_lit || right_node.op == v__token__Kind__amp || is_shared);
			v__checker__Checker_expr(c, right_node.right);
			c->inside_ref_lit = old_inside_ref_lit;
			if (right_node.op == v__token__Kind__amp) {
				if ((right_node.right)._typ == 299 /* v.ast.Ident */) {
					if (((*right_node.right._v__ast__Ident).obj)._typ == 357 /* v.ast.Var */) {
						v__ast__Var v = (*(*right_node.right._v__ast__Ident).obj._v__ast__Var);
						right_type0 = v.typ;
						if (!v.is_mut && assigned_var.is_mut && !c->inside_unsafe) {
							v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = (*right_node.right._v__ast__Ident).name}}, {_SLIT("` is immutable, cannot have a mutable reference to it"), 0, { .d_c = 0 }}})), right_node.pos);
						}
					} else if (((*right_node.right._v__ast__Ident).obj)._typ == 355 /* v.ast.ConstField */) {
						if (assigned_var.is_mut && !c->inside_unsafe) {
							v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = (*right_node.right._v__ast__Ident).name}}, {_SLIT("` is immutable, cannot have a mutable reference to it"), 0, { .d_c = 0 }}})), right_node.pos);
						}
					}
				}
			}
			if (right_node.op == v__token__Kind__arrow) {
				if (assigned_var.is_mut) {
					v__ast__TypeSymbol* right_sym = v__ast__Table_sym(c->table, right_type0);
					if (right_sym->kind == v__ast__Kind__chan) {
						v__ast__Chan chan_info = v__ast__TypeSymbol_chan_info(right_sym);
						if (v__ast__Type_is_ptr(chan_info.elem_type) && !chan_info.is_mut) {
							v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot have a mutable reference to object from `"), 0xfe10, {.d_s = right_sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), right_node.pos);
						}
					}
				}
			}
		}
	}
	if (node->left_types.len != node->left.len) {
		v__checker__Checker_error(c, _SLIT("assign statement left type number mismatch"), node->pos);
	}
// Defer begin
if (v__checker__Checker_assign_stmt_defer_0) {
	c->expected_type = _const_v__ast__void_type;
}
// Defer end
}

bool v__checker__Checker_check_types(v__checker__Checker* c, v__ast__Type got, v__ast__Type expected) {
	if (v__ast__Type_alias_eq(got, expected)) {
		bool _t1 = true;
		return _t1;
	}
	if (c->pref->translated) {
		if (v__ast__Type_alias_eq(expected, _const_v__ast__byteptr_type)) {
			bool _t2 = true;
			return _t2;
		}
		if (v__ast__Type_alias_eq(expected, _const_v__ast__voidptr_type)) {
			bool _t3 = true;
			return _t3;
		}
		if (v__ast__Type_is_any_kind_of_pointer(expected)) {
			v__ast__Type deref = v__ast__Type_deref(expected);
			v__ast__TypeSymbol* got_sym = v__ast__Table_sym(c->table, got);
			if (v__ast__Type_is_number(deref) && (v__ast__TypeSymbol_is_number(got_sym) || got_sym->kind == v__ast__Kind__enum_)) {
				bool _t4 = true;
				return _t4;
			}
		}
		v__ast__TypeSymbol* got_sym = v__ast__Table_sym(c->table, got);
		v__ast__TypeSymbol* expected_sym = v__ast__Table_sym(c->table, expected);
		if (got_sym->kind == v__ast__Kind__enum_) {
			if (v__ast__TypeSymbol_is_number(expected_sym)) {
				bool _t5 = true;
				return _t5;
			}
		} else if (got_sym->kind == v__ast__Kind__array_fixed) {
			if (v__ast__TypeSymbol_is_number(expected_sym)) {
				bool _t6 = true;
				return _t6;
			}
		}
	}
	bool got_is_ptr = v__ast__Type_is_ptr(got);
	bool exp_is_ptr = v__ast__Type_is_ptr(expected);
	if (got_is_ptr && exp_is_ptr) {
		if (v__ast__Type_nr_muls(got) != v__ast__Type_nr_muls(expected)) {
			bool _t7 = false;
			return _t7;
		}
	}
	int exp_idx = v__ast__Type_idx(expected);
	int got_idx = v__ast__Type_idx(got);
	if (exp_idx == got_idx) {
		bool _t8 = true;
		return _t8;
	}
	if (exp_idx == _const_v__ast__voidptr_type_idx || exp_idx == _const_v__ast__byteptr_type_idx || (v__ast__Type_is_ptr(expected) && v__ast__Type_idx(v__ast__Type_deref(expected)) == _const_v__ast__byte_type_idx)) {
		if (v__ast__Type_is_ptr(got) || v__ast__Type_is_pointer(got)) {
			bool _t9 = true;
			return _t9;
		}
	}
	if (v__ast__Type_is_real_pointer(expected)) {
		if (v__ast__Type_alias_eq(got, _const_v__ast__int_literal_type)) {
			bool _t10 = true;
			return _t10;
		}
	}
	if (got_idx == _const_v__ast__voidptr_type_idx || got_idx == _const_v__ast__byteptr_type_idx || (got_idx == _const_v__ast__byte_type_idx && v__ast__Type_is_ptr(got))) {
		if (v__ast__Type_is_ptr(expected) || v__ast__Type_is_pointer(expected)) {
			bool _t11 = true;
			return _t11;
		}
	}
	if (v__ast__Type_alias_eq(expected, _const_v__ast__charptr_type) && v__ast__Type_alias_eq(got, v__ast__Type_ref(_const_v__ast__char_type))) {
		bool _t12 = true;
		return _t12;
	}
	if (v__ast__Type_has_flag(expected, v__ast__TypeFlag__optional)) {
		v__ast__TypeSymbol* sym = v__ast__Table_sym(c->table, got);
		if ((sym->kind == v__ast__Kind__interface_ && string__eq(sym->name, _SLIT("IError"))) || (got == _const_v__ast__none_type || got == _const_v__ast__error_type)) {
			bool _t13 = true;
			return _t13;
		} else if (!v__checker__Checker_check_basic(c, got, v__ast__Type_clear_flag(expected, v__ast__TypeFlag__optional))) {
			bool _t14 = false;
			return _t14;
		}
	}
	if (!v__checker__Checker_check_basic(c, got, expected)) {
		bool _t15 = false;
		return _t15;
	}
	if (v__ast__Type_is_number(got) && v__ast__Type_is_number(expected)) {
		if (v__ast__Type_alias_eq(got, _const_v__ast__rune_type) && v__ast__Type_alias_eq(expected, _const_v__ast__byte_type)) {
			bool _t16 = true;
			return _t16;
		} else if (v__ast__Type_alias_eq(expected, _const_v__ast__rune_type) && v__ast__Type_alias_eq(got, _const_v__ast__byte_type)) {
			bool _t17 = true;
			return _t17;
		}
		if (!v__ast__Type_alias_eq(v__checker__Checker_promote_num(c, expected, got), expected)) {
			bool _t18 = false;
			return _t18;
		}
	}
	if (v__ast__Type_has_flag(expected, v__ast__TypeFlag__generic)) {
		bool _t19 = false;
		return _t19;
	}
	bool _t20 = true;
	return _t20;
}

Option_void v__checker__Checker_check_expected_call_arg(v__checker__Checker* c, v__ast__Type got, v__ast__Type expected_, v__ast__Language language, v__ast__CallArg arg) {
	if (got == 0) {
		return (Option_void){ .state=2, .err=_v_error(_SLIT("unexpected 0 type")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	v__ast__Type expected = expected_;
	if (v__ast__Type_has_flag(expected, v__ast__TypeFlag__variadic)) {
		v__ast__TypeSymbol* exp_type_sym = v__ast__Table_sym(c->table, expected_);
		v__ast__Array exp_info = /* as */ *(v__ast__Array*)__as_cast((exp_type_sym->info)._v__ast__Array,(exp_type_sym->info)._typ, 441) /*expected idx: 441, name: v.ast.Array */ ;
		expected = exp_info.elem_type;
	}
	if (language == v__ast__Language__c) {
		if (v__ast__Type_is_number(got) && v__ast__Type_is_number(expected)) {
			return (Option_void){0};
		}
		if ((v__ast__Type_idx(got) == _const_v__ast__bool_type_idx && (v__ast__Type_idx(expected) == _const_v__ast__int_type_idx || v__ast__Type_idx(expected) == _const_v__ast__int_literal_type_idx)) || (v__ast__Type_idx(expected) == _const_v__ast__bool_type_idx && (v__ast__Type_idx(got) == _const_v__ast__int_type_idx || v__ast__Type_idx(got) == _const_v__ast__int_literal_type_idx))) {
			return (Option_void){0};
		}
		v__ast__TypeSymbol* exp_sym = v__ast__Table_sym(c->table, expected);
		if (v__ast__Type_is_ptr(expected) && exp_sym->language == v__ast__Language__c && (exp_sym->kind == v__ast__Kind__placeholder || exp_sym->kind == v__ast__Kind__struct_) && got == _const_v__ast__int_type_idx) {
			return (Option_void){0};
		}
	}
	int idx_got = v__ast__Type_idx(got);
	int idx_expected = v__ast__Type_idx(expected);
	if ((idx_got == _const_v__ast__byteptr_type_idx || idx_got == _const_v__ast__charptr_type_idx) || (idx_expected == _const_v__ast__byteptr_type_idx || idx_expected == _const_v__ast__charptr_type_idx)) {
		int igot = ((int)(got));
		int iexpected = ((int)(expected));
		if ((igot == _const_v__ast__byteptr_type_idx && iexpected == 65545) || (iexpected == _const_v__ast__byteptr_type_idx && igot == 65545)) {
			return (Option_void){0};
		}
		if ((igot == _const_v__ast__charptr_type_idx && iexpected == 65551) || (iexpected == _const_v__ast__charptr_type_idx && igot == 65551)) {
			return (Option_void){0};
		}
		int muls_got = v__ast__Type_nr_muls(got);
		int muls_expected = v__ast__Type_nr_muls(expected);
		if (idx_got == _const_v__ast__byteptr_type_idx && idx_expected == _const_v__ast__byte_type_idx && muls_got + 1 == muls_expected) {
			return (Option_void){0};
		}
		if (idx_expected == _const_v__ast__byteptr_type_idx && idx_got == _const_v__ast__byte_type_idx && muls_expected + 1 == muls_got) {
			return (Option_void){0};
		}
		if (idx_got == _const_v__ast__charptr_type_idx && idx_expected == _const_v__ast__char_type_idx && muls_got + 1 == muls_expected) {
			return (Option_void){0};
		}
		if (idx_expected == _const_v__ast__charptr_type_idx && idx_got == _const_v__ast__char_type_idx && muls_expected + 1 == muls_got) {
			return (Option_void){0};
		}
	}
	if (v__checker__Checker_check_types(c, got, expected)) {
		if (language != v__ast__Language__v || v__ast__Type_is_ptr(expected) == v__ast__Type_is_ptr(got) || arg.is_mut || v__ast__Expr_is_auto_deref_var(arg.expr) || v__ast__Type_has_flag(got, v__ast__TypeFlag__shared_f) || !(v__ast__Table_sym(c->table, expected_)->kind == v__ast__Kind__array || v__ast__Table_sym(c->table, expected_)->kind == v__ast__Kind__map)) {
			return (Option_void){0};
		}
	}
	return (Option_void){ .state=2, .err=_v_error( str_intp(3, _MOV((StrIntpData[]){{_SLIT("cannot use `"), 0xfe10, {.d_s = v__ast__Table_type_to_str(c->table, v__ast__Type_clear_flag(got, v__ast__TypeFlag__variadic))}}, {_SLIT("` as `"), 0xfe10, {.d_s = v__ast__Table_type_to_str(c->table, v__ast__Type_clear_flag(expected, v__ast__TypeFlag__variadic))}}, {_SLIT("`"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
}

bool v__checker__Checker_check_basic(v__checker__Checker* c, v__ast__Type got, v__ast__Type expected) {
	v__ast__Type unalias_got = v__ast__Table_unalias_num_type(c->table, got);
	v__ast__Type unalias_expected = v__ast__Table_unalias_num_type(c->table, expected);
	if (v__ast__Type_idx(unalias_got) == v__ast__Type_idx(unalias_expected)) {
		bool _t1 = true;
		return _t1;
	}
	if ((v__ast__Type_is_pointer(unalias_expected) || v__ast__Type_is_number(unalias_expected)) && (v__ast__Type_is_pointer(unalias_got) || v__ast__Type_is_number(unalias_got))) {
		bool _t2 = true;
		return _t2;
	}
	if (v__ast__Type_is_ptr(expected) && v__ast__Type_alias_eq(unalias_got, _const_v__ast__int_literal_type)) {
		bool _t3 = true;
		return _t3;
	}
	if (v__ast__Type_idx(expected) == _const_v__ast__array_type_idx || v__ast__Type_idx(got) == _const_v__ast__array_type_idx) {
		bool _t4 = true;
		return _t4;
	}
	v__ast__TypeSymbol* got_sym = v__ast__Table_sym(c->table, got);
	v__ast__TypeSymbol* exp_sym = v__ast__Table_sym(c->table, expected);
	if ((got_sym->kind == v__ast__Kind__array || got_sym->kind == v__ast__Kind__map || got_sym->kind == v__ast__Kind__array_fixed) && exp_sym->kind == got_sym->kind) {
		if (string__eq(v__ast__Table_type_to_str(c->table, got), string_trim(v__ast__Table_type_to_str(c->table, expected), _SLIT("&")))) {
			bool _t5 = true;
			return _t5;
		}
	}
	if (!v__ast__Type_is_ptr(unalias_got) && got_sym->kind == v__ast__Kind__array_fixed && (v__ast__Type_is_pointer(unalias_expected) || v__ast__Type_is_ptr(unalias_expected))) {
		bool _t6 = false;
		return _t6;
	}
	if ((exp_sym->kind == v__ast__Kind__voidptr || exp_sym->kind == v__ast__Kind__any) || (got_sym->kind == v__ast__Kind__voidptr || got_sym->kind == v__ast__Kind__any)) {
		bool _t7 = true;
		return _t7;
	}
	if (v__ast__Table_sumtype_has_variant(c->table, expected, v__ast__mktyp(got), false)) {
		bool _t8 = true;
		return _t8;
	}
	if ((got_sym->kind == v__ast__Kind__alias && got_sym->parent_idx == v__ast__Type_idx(expected)) || (exp_sym->kind == v__ast__Kind__alias && exp_sym->parent_idx == v__ast__Type_idx(got))) {
		bool _t9 = true;
		return _t9;
	}
	if (got_sym->kind == v__ast__Kind__function && exp_sym->kind == v__ast__Kind__function) {
		bool _t10 = v__checker__Checker_check_matching_function_symbols(c, got_sym, exp_sym);
		return _t10;
	}
	v__ast__Type expected_nonflagged = v__ast__Type_clear_flags(expected);
	if (v__ast__Type_alias_eq(got, _const_v__ast__int_literal_type) && v__ast__Type_is_int(expected_nonflagged)) {
		bool _t11 = true;
		return _t11;
	}
	if (v__ast__Type_alias_eq(got, _const_v__ast__float_literal_type) && v__ast__Type_is_float(expected_nonflagged)) {
		bool _t12 = true;
		return _t12;
	}
	bool _t13 = false;
	return _t13;
}

bool v__checker__Checker_check_matching_function_symbols(v__checker__Checker* c, v__ast__TypeSymbol* got_type_sym, v__ast__TypeSymbol* exp_type_sym) {
	v__ast__FnType got_info = /* as */ *(v__ast__FnType*)__as_cast((got_type_sym->info)._v__ast__FnType,(got_type_sym->info)._typ, 472) /*expected idx: 472, name: v.ast.FnType */ ;
	v__ast__FnType exp_info = /* as */ *(v__ast__FnType*)__as_cast((exp_type_sym->info)._v__ast__FnType,(exp_type_sym->info)._typ, 472) /*expected idx: 472, name: v.ast.FnType */ ;
	v__ast__Fn got_fn = got_info.func;
	v__ast__Fn exp_fn = exp_info.func;
	if (got_fn.params.len != exp_fn.params.len) {
		bool _t1 = false;
		return _t1;
	}
	if (v__ast__Type_has_flag(got_fn.return_type, v__ast__TypeFlag__optional) != v__ast__Type_has_flag(exp_fn.return_type, v__ast__TypeFlag__optional)) {
		bool _t2 = false;
		return _t2;
	}
	if (!v__checker__Checker_check_basic(c, got_fn.return_type, exp_fn.return_type)) {
		bool _t3 = false;
		return _t3;
	}
	for (int i = 0; i < got_fn.params.len; ++i) {
		v__ast__Param got_arg = ((v__ast__Param*)got_fn.params.data)[i];
		v__ast__Param exp_arg = (*(v__ast__Param*)/*ee elem_typ */array_get(exp_fn.params, i));
		bool exp_arg_is_ptr = v__ast__Type_is_ptr(exp_arg.typ) || v__ast__Type_is_pointer(exp_arg.typ);
		bool got_arg_is_ptr = v__ast__Type_is_ptr(got_arg.typ) || v__ast__Type_is_pointer(got_arg.typ);
		if (exp_arg_is_ptr != got_arg_is_ptr) {
			string exp_arg_pointedness = (exp_arg_is_ptr ? (_SLIT("a pointer")) : (_SLIT("NOT a pointer")));
			string got_arg_pointedness = (got_arg_is_ptr ? (_SLIT("a pointer")) : (_SLIT("NOT a pointer")));
			v__checker__Checker_add_error_detail(c,  str_intp(6, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = exp_fn.name}}, {_SLIT("`\'s expected fn argument: `"), 0xfe10, {.d_s = exp_arg.name}}, {_SLIT("` is "), 0xfe10, {.d_s = exp_arg_pointedness}}, {_SLIT(", but the passed fn argument: `"), 0xfe10, {.d_s = got_arg.name}}, {_SLIT("` is "), 0xfe10, {.d_s = got_arg_pointedness}}, {_SLIT0, 0, { .d_c = 0 }}})));
			bool _t4 = false;
			return _t4;
		} else if (exp_arg_is_ptr && got_arg_is_ptr) {
			continue;
		}
		if (!v__ast__Type_alias_eq(got_arg.typ, exp_arg.typ)) {
			bool _t5 = false;
			return _t5;
		}
	}
	bool _t6 = true;
	return _t6;
}

VV_LOCAL_SYMBOL v__ast__Type v__checker__Checker_check_shift(v__checker__Checker* c, v__ast__InfixExpr* node, v__ast__Type left_type, v__ast__Type right_type) {
	if (!v__ast__Type_is_int(left_type)) {
		v__ast__TypeSymbol* left_sym = v__ast__Table_sym(c->table, left_type);
		if (left_sym->kind == v__ast__Kind__alias && v__ast__Type_is_int((/* as */ *(v__ast__Alias*)__as_cast((left_sym->info)._v__ast__Alias,(left_sym->info)._typ, 460) /*expected idx: 460, name: v.ast.Alias */ ).parent_type)) {
			v__ast__Type _t1 = left_type;
			return _t1;
		}
		if (c->pref->translated && v__ast__Type_alias_eq(left_type, _const_v__ast__bool_type)) {
			v__ast__Type _t2 = _const_v__ast__int_type;
			return _t2;
		}
		v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("invalid operation: shift on type `"), 0xfe10, {.d_s = left_sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), v__ast__Expr_position(node->left));
		v__ast__Type _t3 = _const_v__ast__void_type;
		return _t3;
	}
	if (!v__ast__Type_is_int(right_type) && !c->pref->translated) {
		v__ast__TypeSymbol* left_sym = v__ast__Table_sym(c->table, left_type);
		v__ast__TypeSymbol* right_sym = v__ast__Table_sym(c->table, right_type);
		v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("cannot shift non-integer type `"), 0xfe10, {.d_s = right_sym->name}}, {_SLIT("` into type `"), 0xfe10, {.d_s = left_sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), v__ast__Expr_position(node->right));
		v__ast__Type _t4 = _const_v__ast__void_type;
		return _t4;
	}
	if (!node->ct_left_value_evaled) {
		Option_v__ast__ComptTimeConstValue _t5;
		if (_t5 = v__checker__Checker_eval_comptime_const_expr(c, node->left, 0), _t5.state == 0) {
			v__ast__ComptTimeConstValue lval = *(v__ast__ComptTimeConstValue*)_t5.data;
			node->ct_left_value_evaled = true;
			node->ct_left_value = lval;
		}
	}
	if (!node->ct_right_value_evaled) {
		Option_v__ast__ComptTimeConstValue _t6;
		if (_t6 = v__checker__Checker_eval_comptime_const_expr(c, node->right, 0), _t6.state == 0) {
			v__ast__ComptTimeConstValue rval = *(v__ast__ComptTimeConstValue*)_t6.data;
			node->ct_right_value_evaled = true;
			node->ct_right_value = rval;
		}
	}

	if (node->op == (v__token__Kind__left_shift) || node->op == (v__token__Kind__right_shift) || node->op == (v__token__Kind__unsigned_right_shift)) {
		v__ast__TypeSymbol* left_sym_final = v__ast__Table_final_sym(c->table, left_type);
		v__ast__Type left_type_final = ((left_sym_final->idx));
		if (node->op == v__token__Kind__left_shift && v__ast__Type_is_signed(left_type_final) && !(c->inside_unsafe && c->is_generated)) {
			v__checker__Checker_note(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("shifting a value from a signed type `"), 0xfe10, {.d_s = left_sym_final->name}}, {_SLIT("` can change the sign"), 0, { .d_c = 0 }}})), v__ast__Expr_position(node->left));
		}
		if (node->ct_right_value_evaled) {
			if ((node->ct_right_value)._typ != 295 /* v.ast.EmptyExpr */) {
				Option_i64 _t7 = v__ast__ComptTimeConstValue_i64(node->ct_right_value);
				if (_t7.state != 0) { /*or block*/ 
					IError err = _t7.err;
					*(i64*) _t7.data = -999;
				}
				
 				i64 ival =  (*(i64*)_t7.data);
				if (ival < 0) {
					v__checker__Checker_error(c, _SLIT("invalid negative shift count"), v__ast__Expr_position(node->right));
					v__ast__Type _t8 = left_type;
					return _t8;
				}
				int moffset = ((left_type_final == (_const_v__ast__char_type)) ? (7) : (left_type_final == (_const_v__ast__i8_type)) ? (7) : (left_type_final == (_const_v__ast__i16_type)) ? (15) : (left_type_final == (_const_v__ast__int_type)) ? (31) : (left_type_final == (_const_v__ast__i64_type)) ? (63) : (left_type_final == (_const_v__ast__byte_type)) ? (7) : (left_type_final == (_const_v__ast__u8_type)) ? (7) : (left_type_final == (_const_v__ast__u16_type)) ? (15) : (left_type_final == (_const_v__ast__u32_type)) ? (31) : (left_type_final == (_const_v__ast__u64_type)) ? (63) : (64));
				if (ival > moffset && !c->pref->translated) {
					v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("shift count for type `"), 0xfe10, {.d_s = left_sym_final->name}}, {_SLIT("` too large (maximum: "), 0xfe07, {.d_i32 = moffset}}, {_SLIT(" bits)"), 0, { .d_c = 0 }}})), v__ast__Expr_position(node->right));
					v__ast__Type _t9 = left_type;
					return _t9;
				}
				if (node->ct_left_value_evaled) {
					Option_i64 _t10;
					if (_t10 = v__ast__ComptTimeConstValue_i64(node->ct_left_value), _t10.state == 0) {
						i64 lval = *(i64*)_t10.data;
						if (lval < 0) {
							v__checker__Checker_error(c, _SLIT("invalid bitshift of a negative number"), v__ast__Expr_position(node->left));
							v__ast__Type _t11 = left_type;
							return _t11;
						}
					}
				}
			} else {
				v__ast__Type _t12 = left_type;
				return _t12;
			}
		}
	}
	else {
		v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unknown shift operator: "), 0xfe10, {.d_s = v__token__Kind_str(node->op)}}, {_SLIT0, 0, { .d_c = 0 }}})), node->pos);
		v__ast__Type _t13 = left_type;
		return _t13;
	};
	v__ast__Type _t14 = left_type;
	return _t14;
}

v__ast__Type v__checker__Checker_promote(v__checker__Checker* c, v__ast__Type left_type, v__ast__Type right_type) {
	if (v__ast__Type_is_any_kind_of_pointer(left_type)) {
		if (v__ast__Type_is_int(right_type)) {
			v__ast__Type _t1 = left_type;
			return _t1;
		} else {
			v__ast__Type _t2 = _const_v__ast__void_type;
			return _t2;
		}
	} else if (v__ast__Type_is_any_kind_of_pointer(right_type)) {
		if (v__ast__Type_is_int(left_type)) {
			v__ast__Type _t3 = right_type;
			return _t3;
		} else {
			v__ast__Type _t4 = _const_v__ast__void_type;
			return _t4;
		}
	}
	if (v__ast__Type_alias_eq(left_type, right_type)) {
		v__ast__Type _t5 = left_type;
		return _t5;
	}
	if (v__ast__Type_is_number(right_type) && v__ast__Type_is_number(left_type)) {
		v__ast__Type _t6 = v__checker__Checker_promote_num(c, left_type, right_type);
		return _t6;
	} else if (v__ast__Type_has_flag(left_type, v__ast__TypeFlag__optional) != v__ast__Type_has_flag(right_type, v__ast__TypeFlag__optional)) {
		v__ast__Type _t7 = _const_v__ast__void_type;
		return _t7;
	} else {
		v__ast__Type _t8 = left_type;
		return _t8;
	}
	return 0;
}

VV_LOCAL_SYMBOL v__ast__Type v__checker__Checker_promote_num(v__checker__Checker* c, v__ast__Type left_type, v__ast__Type right_type) {
	v__ast__Type type_hi = left_type;
	v__ast__Type type_lo = right_type;
	if (v__ast__Type_idx(type_hi) < v__ast__Type_idx(type_lo)) {
		v__ast__Type _var_14473 = type_hi;
		v__ast__Type _var_14482 = type_lo;
		type_hi = _var_14482;
		type_lo = _var_14473;
	}
	int idx_hi = v__ast__Type_idx(type_hi);
	int idx_lo = v__ast__Type_idx(type_lo);
	if (idx_hi == _const_v__ast__int_literal_type_idx) {
		v__ast__Type _t1 = type_lo;
		return _t1;
	} else if (idx_hi == _const_v__ast__float_literal_type_idx) {
		if (Array_int_contains(_const_v__ast__float_type_idxs, idx_lo)) {
			v__ast__Type _t2 = type_lo;
			return _t2;
		} else {
			v__ast__Type _t3 = _const_v__ast__void_type;
			return _t3;
		}
	} else if (v__ast__Type_is_float(type_hi)) {
		if (idx_hi == _const_v__ast__f32_type_idx) {
			if (idx_lo == _const_v__ast__i64_type_idx || idx_lo == _const_v__ast__u64_type_idx) {
				v__ast__Type _t4 = _const_v__ast__void_type;
				return _t4;
			} else {
				v__ast__Type _t5 = type_hi;
				return _t5;
			}
		} else {
			v__ast__Type _t6 = type_hi;
			return _t6;
		}
	} else if (idx_lo >= _const_v__ast__byte_type_idx) {
		v__ast__Type _t7 = type_hi;
		return _t7;
	} else if (idx_lo >= _const_v__ast__i8_type_idx && (idx_hi <= _const_v__ast__isize_type_idx || idx_hi == _const_v__ast__rune_type_idx)) {
		v__ast__Type _t8 = (idx_lo == _const_v__ast__i64_type_idx ? (type_lo) : (type_hi));
		return _t8;
	} else if (idx_hi - idx_lo < (_const_v__ast__byte_type_idx - _const_v__ast__i8_type_idx)) {
		v__ast__Type _t9 = type_lo;
		return _t9;
	} else {
		v__ast__Type _t10 = _const_v__ast__void_type;
		return _t10;
	}
	return 0;
}

Option_void v__checker__Checker_check_expected(v__checker__Checker* c, v__ast__Type got, v__ast__Type expected) {
	if (!v__checker__Checker_check_types(c, got, expected)) {
		return (Option_void){ .state=2, .err=_v_error(v__checker__Checker_expected_msg(c, got, expected)), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (Option_void){0};
}

VV_LOCAL_SYMBOL string v__checker__Checker_expected_msg(v__checker__Checker* c, v__ast__Type got, v__ast__Type expected) {
	string exps = v__ast__Table_type_to_str(c->table, expected);
	string gots = v__ast__Table_type_to_str(c->table, got);
	string _t1 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("expected `"), 0xfe10, {.d_s = exps}}, {_SLIT("`, not `"), 0xfe10, {.d_s = gots}}, {_SLIT("`"), 0, { .d_c = 0 }}}));
	return _t1;
}

bool v__checker__Checker_symmetric_check(v__checker__Checker* c, v__ast__Type left, v__ast__Type right) {
	if (v__ast__Type_is_ptr(right) || v__ast__Type_is_pointer(right)) {
		if (v__ast__Type_alias_eq(left, _const_v__ast__int_literal_type)) {
			bool _t1 = true;
			return _t1;
		}
	}
	if (v__ast__Type_is_ptr(left) || v__ast__Type_is_pointer(left)) {
		if (v__ast__Type_alias_eq(right, _const_v__ast__int_literal_type)) {
			bool _t2 = true;
			return _t2;
		}
	}
	bool _t3 = v__checker__Checker_check_basic(c, left, right);
	return _t3;
}

byte v__checker__Checker_get_default_fmt(v__checker__Checker* c, v__ast__Type ftyp, v__ast__Type typ) {
	if (v__ast__Type_has_flag(ftyp, v__ast__TypeFlag__optional)) {
		byte _t1 = 's';
		return _t1;
	} else if (v__ast__Type_is_float(typ)) {
		byte _t2 = 'g';
		return _t2;
	} else if (v__ast__Type_is_signed(typ) || v__ast__Type_is_int_literal(typ)) {
		byte _t3 = 'd';
		return _t3;
	} else if (v__ast__Type_is_unsigned(typ)) {
		byte _t4 = 'u';
		return _t4;
	} else if (v__ast__Type_is_pointer(typ)) {
		byte _t5 = 'p';
		return _t5;
	} else {
		v__ast__TypeSymbol* sym = v__ast__Table_sym(c->table, v__checker__Checker_unwrap_generic(c, ftyp));
		if (sym->kind == v__ast__Kind__alias) {
			v__ast__Alias info = /* as */ *(v__ast__Alias*)__as_cast((sym->info)._v__ast__Alias,(sym->info)._typ, 460) /*expected idx: 460, name: v.ast.Alias */ ;
			sym = v__ast__Table_sym(c->table, info.parent_type);
			if (v__ast__Type_alias_eq(info.parent_type, _const_v__ast__string_type)) {
				byte _t6 = 's';
				return _t6;
			}
		}
		if (sym->kind == v__ast__Kind__function) {
			byte _t7 = 's';
			return _t7;
		}
		if ((ftyp == _const_v__ast__string_type || ftyp == _const_v__ast__bool_type) || (sym->kind == v__ast__Kind__enum_ || sym->kind == v__ast__Kind__array || sym->kind == v__ast__Kind__array_fixed || sym->kind == v__ast__Kind__struct_ || sym->kind == v__ast__Kind__map || sym->kind == v__ast__Kind__multi_return || sym->kind == v__ast__Kind__sum_type || sym->kind == v__ast__Kind__interface_ || sym->kind == v__ast__Kind__none_) || v__ast__Type_has_flag(ftyp, v__ast__TypeFlag__optional) || v__ast__TypeSymbol_has_method(sym, _SLIT("str"))) {
			byte _t8 = 's';
			return _t8;
		} else {
			byte _t9 = '_';
			return _t9;
		}
	}
	return 0;
}

void v__checker__Checker_fail_if_unreadable(v__checker__Checker* c, v__ast__Expr expr, v__ast__Type typ, string what) {
	v__token__Position pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,};
	if (expr._typ == 299 /* v.ast.Ident */) {
		if (v__ast__Type_has_flag(typ, v__ast__TypeFlag__shared_f)) {
			if (!Array_string_contains(c->rlocked_names, (*expr._v__ast__Ident).name) && !Array_string_contains(c->locked_names, (*expr._v__ast__Ident).name)) {
				string action = (string__eq(what, _SLIT("argument")) ? (_SLIT("passed")) : (_SLIT("used")));
				v__checker__Checker_error(c,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = (*expr._v__ast__Ident).name}}, {_SLIT("` is `shared` and must be `rlock`ed or `lock`ed to be "), 0xfe10, {.d_s = action}}, {_SLIT(" as non-mut "), 0xfe10, {.d_s = what}}, {_SLIT0, 0, { .d_c = 0 }}})), (*expr._v__ast__Ident).pos);
			}
		}
		return;
	}
	else if (expr._typ == 319 /* v.ast.SelectorExpr */) {
		pos = (*expr._v__ast__SelectorExpr).pos;
		if (v__ast__Type_has_flag(typ, v__ast__TypeFlag__shared_f)) {
			string expr_name =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__ast__Expr_str((*expr._v__ast__SelectorExpr).expr)}}, {_SLIT("."), 0xfe10, {.d_s = (*expr._v__ast__SelectorExpr).field_name}}, {_SLIT0, 0, { .d_c = 0 }}}));
			if (!Array_string_contains(c->rlocked_names, expr_name) && !Array_string_contains(c->locked_names, expr_name)) {
				string action = (string__eq(what, _SLIT("argument")) ? (_SLIT("passed")) : (_SLIT("used")));
				v__checker__Checker_error(c,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = expr_name}}, {_SLIT("` is `shared` and must be `rlock`ed or `lock`ed to be "), 0xfe10, {.d_s = action}}, {_SLIT(" as non-mut "), 0xfe10, {.d_s = what}}, {_SLIT0, 0, { .d_c = 0 }}})), (*expr._v__ast__SelectorExpr).pos);
			}
			return;
		} else {
			v__checker__Checker_fail_if_unreadable(c, (*expr._v__ast__SelectorExpr).expr, (*expr._v__ast__SelectorExpr).expr_type, what);
		}
	}
	else if (expr._typ == 302 /* v.ast.IndexExpr */) {
		pos = v__token__Position_extend(v__ast__Expr_position((*expr._v__ast__IndexExpr).left), (*expr._v__ast__IndexExpr).pos);
		v__checker__Checker_fail_if_unreadable(c, (*expr._v__ast__IndexExpr).left, (*expr._v__ast__IndexExpr).left_type, what);
	}
	
	else {
		pos = v__ast__Expr_position(expr);
	}
	;
	if (v__ast__Type_has_flag(typ, v__ast__TypeFlag__shared_f)) {
		v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("you have to create a handle and `rlock` it to use a `shared` element as non-mut "), 0xfe10, {.d_s = what}}, {_SLIT0, 0, { .d_c = 0 }}})), pos);
	}
}

v__ast__Type v__checker__Checker_string_inter_lit(v__checker__Checker* c, v__ast__StringInterLiteral* node) {
	bool inside_println_arg_save = c->inside_println_arg;
	c->inside_println_arg = true;
	for (int i = 0; i < node->exprs.len; ++i) {
		v__ast__Expr expr = ((v__ast__Expr*)node->exprs.data)[i];
		v__ast__Type ftyp = v__checker__Checker_expr(c, expr);
		if (v__ast__Type_alias_eq(ftyp, _const_v__ast__void_type)) {
			v__checker__Checker_error(c, _SLIT("expression does not return a value"), v__ast__Expr_position(expr));
		} else if (v__ast__Type_alias_eq(ftyp, _const_v__ast__char_type) && v__ast__Type_nr_muls(ftyp) == 0) {
			v__checker__Checker_error(c, _SLIT("expression returning type `char` cannot be used in string interpolation directly, print its address or cast it to an integer instead"), v__ast__Expr_position(expr));
		}
		v__checker__Checker_fail_if_unreadable(c, expr, ftyp, _SLIT("interpolation object"));
		array_push((array*)&node->expr_types, _MOV((v__ast__Type[]){ ftyp }));
		v__ast__Type typ = v__ast__Table_unalias_num_type(c->table, ftyp);
		byte fmt = (*(byte*)/*ee elem_typ */array_get(node->fmts, i));
		if (!(fmt == 'E' || fmt == 'F' || fmt == 'G' || fmt == 'e' || fmt == 'f' || fmt == 'g' || fmt == 'd' || fmt == 'u' || fmt == 'x' || fmt == 'X' || fmt == 'o' || fmt == 'c' || fmt == 's' || fmt == 'S' || fmt == 'p' || fmt == 'b' || fmt == '_')) {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unknown format specifier `"), 0xfe01, {.d_c = fmt}}, {_SLIT("`"), 0, { .d_c = 0 }}})), (*(v__token__Position*)/*ee elem_typ */array_get(node->fmt_poss, i)));
		}
		if (fmt == '_') {
			fmt = v__checker__Checker_get_default_fmt(c, ftyp, typ);
			if (fmt == '_') {
				if (!v__ast__Type_alias_eq(typ, _const_v__ast__void_type)) {
					v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("no known default format for type `"), 0xfe10, {.d_s = v__ast__Table_get_type_name(c->table, ftyp)}}, {_SLIT("`"), 0, { .d_c = 0 }}})), (*(v__token__Position*)/*ee elem_typ */array_get(node->fmt_poss, i)));
				}
			} else {
				(*(byte*)/*ee elem_typ */array_get(node->fmts, i)) = fmt;
				(*(bool*)/*ee elem_typ */array_get(node->need_fmts, i)) = false;
			}
		} else {
			if ((*(int*)/*ee elem_typ */array_get(node->precisions, i)) != 987698 && !v__ast__Type_is_float(typ)) {
				v__checker__Checker_error(c, _SLIT("precision specification only valid for float types"), (*(v__token__Position*)/*ee elem_typ */array_get(node->fmt_poss, i)));
			}
			if ((*(bool*)/*ee elem_typ */array_get(node->pluss, i)) && !v__ast__Type_is_number(typ)) {
				v__checker__Checker_error(c, _SLIT("plus prefix only allowed for numbers"), (*(v__token__Position*)/*ee elem_typ */array_get(node->fmt_poss, i)));
			}
			if ((v__ast__Type_is_unsigned(typ) && !(fmt == 'u' || fmt == 'x' || fmt == 'X' || fmt == 'o' || fmt == 'c' || fmt == 'b')) || (v__ast__Type_is_signed(typ) && !(fmt == 'd' || fmt == 'x' || fmt == 'X' || fmt == 'o' || fmt == 'c' || fmt == 'b')) || (v__ast__Type_is_int_literal(typ) && !(fmt == 'd' || fmt == 'c' || fmt == 'x' || fmt == 'X' || fmt == 'o' || fmt == 'u' || fmt == 'x' || fmt == 'X' || fmt == 'o' || fmt == 'b')) || (v__ast__Type_is_float(typ) && !(fmt == 'E' || fmt == 'F' || fmt == 'G' || fmt == 'e' || fmt == 'f' || fmt == 'g')) || (v__ast__Type_is_pointer(typ) && !(fmt == 'p' || fmt == 'x' || fmt == 'X')) || (v__ast__Type_is_string(typ) && !(fmt == 's' || fmt == 'S')) || ((v__ast__Type_idx(typ) == _const_v__ast__i64_type_idx || v__ast__Type_idx(typ) == _const_v__ast__f64_type_idx) && fmt == 'c')) {
				v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("illegal format specifier `"), 0xfe01, {.d_c = fmt}}, {_SLIT("` for type `"), 0xfe10, {.d_s = v__ast__Table_get_type_name(c->table, ftyp)}}, {_SLIT("`"), 0, { .d_c = 0 }}})), (*(v__token__Position*)/*ee elem_typ */array_get(node->fmt_poss, i)));
			}
			(*(bool*)/*ee elem_typ */array_get(node->need_fmts, i)) = fmt != v__checker__Checker_get_default_fmt(c, ftyp, typ);
		}
		if (c->table->cur_fn->is_method && string__eq(c->table->cur_fn->name, _SLIT("str")) && string__eq(c->table->cur_fn->receiver.name, v__ast__Expr_str(expr))) {
			v__checker__Checker_error(c, _SLIT("cannot call `str()` method recursively"), v__ast__Expr_position(expr));
		}
	}
	c->inside_println_arg = inside_println_arg_save;
	v__ast__Type _t2 = _const_v__ast__string_type;
	return _t2;
}

v__ast__Type v__checker__Checker_string_lit(v__checker__Checker* c, v__ast__StringLiteral* node) {
	int idx = 0;
	for (;;) {
		if (!(idx < node->val.len)) break;
		byte _t1 = string_at(node->val, idx);
		
		if (_t1 == ('\\')) {
			v__token__Position start_pos = (v__token__Position){node->pos.len,node->pos.line_nr,node->pos.pos,.col = node->pos.col + 1 + idx,node->pos.last_line,};
			int start_idx = idx;
			idx++;
			Option_byte _t2 = string_at_with_check(node->val, idx);
			;
			if (_t2.state != 0) { /*or block*/ 
				IError err = _t2.err;
				v__ast__Type _t3 = _const_v__ast__string_type;
				return _t3;
			}
			
			byte next_ch = *(byte*)&_t2.data;
			if (next_ch == 'x') {
				idx++;
				Option_byte _t4 = string_at_with_check(node->val, idx);
				;
				if (_t4.state != 0) { /*or block*/ 
					IError err = _t4.err;
					v__ast__Type _t5 = _const_v__ast__string_type;
					return _t5;
				}
				
				byte ch = *(byte*)&_t4.data;
				int hex_char_count = 0;
				for (;;) {
					if (!(byte_is_hex_digit(ch))) break;
					hex_char_count++;
					v__token__Position end_pos = (v__token__Position){.len = idx + 1 - start_idx,start_pos.line_nr,start_pos.pos,start_pos.col,start_pos.last_line,};

					if ((hex_char_count >= 1 && hex_char_count <= 5)) {
					}
					else if (hex_char_count == (6)) {
						byte first_digit = string_at(node->val, idx - 5) - 48;
						byte second_digit = string_at(node->val, idx - 4) - 48;
						if (first_digit > 1) {
							v__checker__Checker_error(c, _const_v__checker__hex_lit_overflow_message, end_pos);
						} else if (first_digit == 1 && second_digit > 0) {
							v__checker__Checker_error(c, _const_v__checker__hex_lit_overflow_message, end_pos);
						}
					}
					else {
						v__checker__Checker_error(c, _const_v__checker__hex_lit_overflow_message, end_pos);
					};
					idx++;
					Option_byte _t6 = string_at_with_check(node->val, idx);
					;
					if (_t6.state != 0) { /*or block*/ 
						IError err = _t6.err;
						v__ast__Type _t7 = _const_v__ast__string_type;
						return _t7;
					}
					
					ch = *(byte*)&_t6.data;
				}
			}
		}
		else {
			idx++;
		};
	}
	v__ast__Type _t8 = _const_v__ast__string_type;
	return _t8;
}

v__ast__Type v__checker__Checker_int_lit(v__checker__Checker* c, v__ast__IntegerLiteral* node) {
	if (node->val.len < 17) {
		v__ast__Type _t1 = _const_v__ast__int_literal_type;
		return _t1;
	}
	string lit = string_all_after(string_replace(node->val, _SLIT("_"), _SLIT("")), _SLIT("-"));
	bool is_neg = string_starts_with(node->val, _SLIT("-"));
	string limit = (is_neg ? (_SLIT("9223372036854775808")) : (_SLIT("18446744073709551615")));
	string message =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("integer literal "), 0xfe10, {.d_s = node->val}}, {_SLIT(" overflows int"), 0, { .d_c = 0 }}}));
	if (lit.len > limit.len) {
		v__checker__Checker_error(c, message, node->pos);
	} else if (lit.len == limit.len) {
		for (int i = 0; i < lit.len; ++i) {
			byte digit = lit.str[i];
			if (digit > string_at(limit, i)) {
				v__checker__Checker_error(c, message, node->pos);
			} else if (digit < string_at(limit, i)) {
				break;
			}
		}
	}
	v__ast__Type _t2 = _const_v__ast__int_literal_type;
	return _t2;
}

void v__checker__Checker_infer_fn_generic_types(v__checker__Checker* c, v__ast__Fn func, v__ast__CallExpr* node) {
	Array_v__ast__Type inferred_types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
	for (int gi = 0; gi < func.generic_names.len; ++gi) {
		string gt_name = ((string*)func.generic_names.data)[gi];
		if (gi < node->concrete_types.len) {
			array_push((array*)&inferred_types, _MOV((v__ast__Type[]){ (*(v__ast__Type*)/*ee elem_typ */array_get(node->concrete_types, gi)) }));
			continue;
		}
		v__ast__Type typ = _const_v__ast__void_type;
		for (int i = 0; i < func.params.len; ++i) {
			v__ast__Param param = ((v__ast__Param*)func.params.data)[i];
			v__ast__Type to_set = _const_v__ast__void_type;
			if (i == 0 && node->is_method && v__ast__Type_has_flag(param.typ, v__ast__TypeFlag__generic)) {
				v__ast__TypeSymbol* sym = v__ast__Table_sym(c->table, node->receiver_type);
				if (sym->info._typ == 446 /* v.ast.Struct */) {
					if (c->table->cur_fn->generic_names.len > 0) {
						if (Array_string_contains(c->table->cur_fn->generic_names, gt_name) && c->table->cur_fn->generic_names.len == c->table->cur_concrete_types.len) {
							int idx = Array_string_index(c->table->cur_fn->generic_names, gt_name);
							typ = (*(v__ast__Type*)/*ee elem_typ */array_get(c->table->cur_concrete_types, idx));
						}
					} else {
						Array_string _t2 = __new_array(0, 0, sizeof(string));
						Array_v__ast__Type _t2_orig = (*sym->info._v__ast__Struct).generic_types;
						int _t2_len = _t2_orig.len;
						_t2 = __new_array(0, _t2_len, sizeof(string));

						for (int _t3 = 0; _t3 < _t2_len; ++_t3) {
							v__ast__Type it = ((v__ast__Type*) _t2_orig.data)[_t3];
							string ti = v__ast__Table_sym(c->table, it)->name;
							array_push((array*)&_t2, &ti);
						}
						Array_string receiver_generic_names =_t2;
						if (Array_string_contains(receiver_generic_names, gt_name) && (*sym->info._v__ast__Struct).generic_types.len == (*sym->info._v__ast__Struct).concrete_types.len) {
							int idx = Array_string_index(receiver_generic_names, gt_name);
							typ = (*(v__ast__Type*)/*ee elem_typ */array_get((*sym->info._v__ast__Struct).concrete_types, idx));
						}
					}
				}
				else if (sym->info._typ == 463 /* v.ast.Interface */) {
					if (c->table->cur_fn->generic_names.len > 0) {
						if (Array_string_contains(c->table->cur_fn->generic_names, gt_name) && c->table->cur_fn->generic_names.len == c->table->cur_concrete_types.len) {
							int idx = Array_string_index(c->table->cur_fn->generic_names, gt_name);
							typ = (*(v__ast__Type*)/*ee elem_typ */array_get(c->table->cur_concrete_types, idx));
						}
					} else {
						Array_string _t4 = __new_array(0, 0, sizeof(string));
						Array_v__ast__Type _t4_orig = (*sym->info._v__ast__Interface).generic_types;
						int _t4_len = _t4_orig.len;
						_t4 = __new_array(0, _t4_len, sizeof(string));

						for (int _t5 = 0; _t5 < _t4_len; ++_t5) {
							v__ast__Type it = ((v__ast__Type*) _t4_orig.data)[_t5];
							string ti = v__ast__Table_sym(c->table, it)->name;
							array_push((array*)&_t4, &ti);
						}
						Array_string receiver_generic_names =_t4;
						if (Array_string_contains(receiver_generic_names, gt_name) && (*sym->info._v__ast__Interface).generic_types.len == (*sym->info._v__ast__Interface).concrete_types.len) {
							int idx = Array_string_index(receiver_generic_names, gt_name);
							typ = (*(v__ast__Type*)/*ee elem_typ */array_get((*sym->info._v__ast__Interface).concrete_types, idx));
						}
					}
				}
				else if (sym->info._typ == 464 /* v.ast.SumType */) {
					if (c->table->cur_fn->generic_names.len > 0) {
						if (Array_string_contains(c->table->cur_fn->generic_names, gt_name) && c->table->cur_fn->generic_names.len == c->table->cur_concrete_types.len) {
							int idx = Array_string_index(c->table->cur_fn->generic_names, gt_name);
							typ = (*(v__ast__Type*)/*ee elem_typ */array_get(c->table->cur_concrete_types, idx));
						}
					} else {
						Array_string _t6 = __new_array(0, 0, sizeof(string));
						Array_v__ast__Type _t6_orig = (*sym->info._v__ast__SumType).generic_types;
						int _t6_len = _t6_orig.len;
						_t6 = __new_array(0, _t6_len, sizeof(string));

						for (int _t7 = 0; _t7 < _t6_len; ++_t7) {
							v__ast__Type it = ((v__ast__Type*) _t6_orig.data)[_t7];
							string ti = v__ast__Table_sym(c->table, it)->name;
							array_push((array*)&_t6, &ti);
						}
						Array_string receiver_generic_names =_t6;
						if (Array_string_contains(receiver_generic_names, gt_name) && (*sym->info._v__ast__SumType).generic_types.len == (*sym->info._v__ast__SumType).concrete_types.len) {
							int idx = Array_string_index(receiver_generic_names, gt_name);
							typ = (*(v__ast__Type*)/*ee elem_typ */array_get((*sym->info._v__ast__SumType).concrete_types, idx));
						}
					}
				}
				
				else {
				}
				;
			}
			int arg_i = (i != 0 && node->is_method ? (i - 1) : (i));
			if (node->args.len <= arg_i) {
				break;
			}
			v__ast__CallArg arg = (*(v__ast__CallArg*)/*ee elem_typ */array_get(node->args, arg_i));
			arg.typ = v__checker__Checker_unwrap_generic(c, arg.typ);
			v__ast__TypeSymbol* param_type_sym = v__ast__Table_sym(c->table, param.typ);
			if (v__ast__Type_has_flag(param.typ, v__ast__TypeFlag__generic) && string__eq(param_type_sym->name, gt_name)) {
				to_set = v__ast__mktyp(arg.typ);
				v__ast__TypeSymbol* sym = v__ast__Table_sym(c->table, arg.typ);
				if ((sym->info)._typ == 472 /* v.ast.FnType */) {
					v__ast__Fn func_ = (*sym->info._v__ast__FnType).func;
					func_.name = _SLIT("");
					int idx = v__ast__Table_find_or_register_fn_type(c->table, c->mod, func_, true, false);
					to_set = v__ast__Type_derive(v__ast__new_type(idx), arg.typ);
				}
				if (v__ast__Expr_is_auto_deref_var(arg.expr)) {
					to_set = v__ast__Type_deref(to_set);
				}
				if (v__ast__Type_nr_muls(param.typ) > 0 && v__ast__Type_nr_muls(to_set) > 0) {
					to_set = v__ast__Type_set_nr_muls(to_set, 0);
				}
				if (v__ast__Type_has_flag(to_set, v__ast__TypeFlag__generic)) {
					to_set = v__checker__Checker_unwrap_generic(c, to_set);
				}
			} else if (v__ast__Type_has_flag(param.typ, v__ast__TypeFlag__generic)) {
				v__ast__TypeSymbol* arg_sym = v__ast__Table_sym(c->table, arg.typ);
				if (v__ast__Type_has_flag(param.typ, v__ast__TypeFlag__variadic)) {
					to_set = v__ast__mktyp(arg.typ);
				} else if (arg_sym->kind == v__ast__Kind__array && param_type_sym->kind == v__ast__Kind__array) {
					v__ast__Array arg_elem_info = /* as */ *(v__ast__Array*)__as_cast((arg_sym->info)._v__ast__Array,(arg_sym->info)._typ, 441) /*expected idx: 441, name: v.ast.Array */ ;
					v__ast__Array param_elem_info = /* as */ *(v__ast__Array*)__as_cast((param_type_sym->info)._v__ast__Array,(param_type_sym->info)._typ, 441) /*expected idx: 441, name: v.ast.Array */ ;
					v__ast__TypeSymbol* arg_elem_sym = v__ast__Table_sym(c->table, arg_elem_info.elem_type);
					v__ast__TypeSymbol* param_elem_sym = v__ast__Table_sym(c->table, param_elem_info.elem_type);
					for (;;) {
						if (arg_elem_sym->kind == v__ast__Kind__array && param_elem_sym->kind == v__ast__Kind__array && !Array_string_contains(c->table->cur_fn->generic_names, param_elem_sym->name)) {
							arg_elem_info = /* as */ *(v__ast__Array*)__as_cast((arg_elem_sym->info)._v__ast__Array,(arg_elem_sym->info)._typ, 441) /*expected idx: 441, name: v.ast.Array */ ;
							arg_elem_sym = v__ast__Table_sym(c->table, arg_elem_info.elem_type);
							param_elem_info = /* as */ *(v__ast__Array*)__as_cast((param_elem_sym->info)._v__ast__Array,(param_elem_sym->info)._typ, 441) /*expected idx: 441, name: v.ast.Array */ ;
							param_elem_sym = v__ast__Table_sym(c->table, param_elem_info.elem_type);
						} else {
							to_set = arg_elem_info.elem_type;
							break;
						}
					}
				} else if (arg_sym->kind == v__ast__Kind__array_fixed && param_type_sym->kind == v__ast__Kind__array_fixed) {
					v__ast__ArrayFixed arg_elem_info = /* as */ *(v__ast__ArrayFixed*)__as_cast((arg_sym->info)._v__ast__ArrayFixed,(arg_sym->info)._typ, 468) /*expected idx: 468, name: v.ast.ArrayFixed */ ;
					v__ast__ArrayFixed param_elem_info = /* as */ *(v__ast__ArrayFixed*)__as_cast((param_type_sym->info)._v__ast__ArrayFixed,(param_type_sym->info)._typ, 468) /*expected idx: 468, name: v.ast.ArrayFixed */ ;
					v__ast__TypeSymbol* arg_elem_sym = v__ast__Table_sym(c->table, arg_elem_info.elem_type);
					v__ast__TypeSymbol* param_elem_sym = v__ast__Table_sym(c->table, param_elem_info.elem_type);
					for (;;) {
						if (arg_elem_sym->kind == v__ast__Kind__array_fixed && param_elem_sym->kind == v__ast__Kind__array_fixed && !Array_string_contains(c->table->cur_fn->generic_names, param_elem_sym->name)) {
							arg_elem_info = /* as */ *(v__ast__ArrayFixed*)__as_cast((arg_elem_sym->info)._v__ast__ArrayFixed,(arg_elem_sym->info)._typ, 468) /*expected idx: 468, name: v.ast.ArrayFixed */ ;
							arg_elem_sym = v__ast__Table_sym(c->table, arg_elem_info.elem_type);
							param_elem_info = /* as */ *(v__ast__ArrayFixed*)__as_cast((param_elem_sym->info)._v__ast__ArrayFixed,(param_elem_sym->info)._typ, 468) /*expected idx: 468, name: v.ast.ArrayFixed */ ;
							param_elem_sym = v__ast__Table_sym(c->table, param_elem_info.elem_type);
						} else {
							to_set = arg_elem_info.elem_type;
							break;
						}
					}
				} else if (arg_sym->kind == v__ast__Kind__map && param_type_sym->kind == v__ast__Kind__map) {
					v__ast__Map arg_map_info = /* as */ *(v__ast__Map*)__as_cast((arg_sym->info)._v__ast__Map,(arg_sym->info)._typ, 442) /*expected idx: 442, name: v.ast.Map */ ;
					v__ast__Map param_map_info = /* as */ *(v__ast__Map*)__as_cast((param_type_sym->info)._v__ast__Map,(param_type_sym->info)._typ, 442) /*expected idx: 442, name: v.ast.Map */ ;
					if (v__ast__Type_has_flag(param_map_info.key_type, v__ast__TypeFlag__generic) && string__eq(v__ast__Table_sym(c->table, param_map_info.key_type)->name, gt_name)) {
						typ = arg_map_info.key_type;
					}
					if (v__ast__Type_has_flag(param_map_info.value_type, v__ast__TypeFlag__generic) && string__eq(v__ast__Table_sym(c->table, param_map_info.value_type)->name, gt_name)) {
						typ = arg_map_info.value_type;
					}
				} else if (arg_sym->kind == v__ast__Kind__struct_ || arg_sym->kind == v__ast__Kind__interface_ || arg_sym->kind == v__ast__Kind__sum_type) {
					Array_v__ast__Type generic_types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
					Array_v__ast__Type concrete_types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
					if (arg_sym->info._typ == 446 /* v.ast.Struct */) {
						generic_types = (*arg_sym->info._v__ast__Struct).generic_types;
						concrete_types = (*arg_sym->info._v__ast__Struct).concrete_types;
					}
					else if (arg_sym->info._typ == 463 /* v.ast.Interface */) {
						generic_types = (*arg_sym->info._v__ast__Interface).generic_types;
						concrete_types = (*arg_sym->info._v__ast__Interface).concrete_types;
					}
					else if (arg_sym->info._typ == 464 /* v.ast.SumType */) {
						generic_types = (*arg_sym->info._v__ast__SumType).generic_types;
						concrete_types = (*arg_sym->info._v__ast__SumType).concrete_types;
					}
					
					else {
					}
					;
					Array_string _t8 = __new_array(0, 0, sizeof(string));
					Array_v__ast__Type _t8_orig = generic_types;
					int _t8_len = _t8_orig.len;
					_t8 = __new_array(0, _t8_len, sizeof(string));

					for (int _t9 = 0; _t9 < _t8_len; ++_t9) {
						v__ast__Type it = ((v__ast__Type*) _t8_orig.data)[_t9];
						string ti = v__ast__Table_sym(c->table, it)->name;
						array_push((array*)&_t8, &ti);
					}
					Array_string generic_names =_t8;
					if (Array_string_contains(generic_names, gt_name) && generic_types.len == concrete_types.len) {
						int idx = Array_string_index(generic_names, gt_name);
						typ = (*(v__ast__Type*)/*ee elem_typ */array_get(concrete_types, idx));
					}
				}
			}
			if (!v__ast__Type_alias_eq(to_set, _const_v__ast__void_type)) {
				if (!v__ast__Type_alias_eq(typ, _const_v__ast__void_type)) {
					if (v__ast__Type_is_number(typ) && v__ast__Type_is_number(to_set)) {
						v__ast__Type promoted = v__checker__Checker_promote_num(c, typ, to_set);
						if (!v__ast__Type_alias_eq(promoted, _const_v__ast__void_type)) {
							to_set = promoted;
						}
					}
					if (!v__checker__Checker_check_types(c, typ, to_set)) {
						v__checker__Checker_error(c,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("inferred generic type `"), 0xfe10, {.d_s = gt_name}}, {_SLIT("` is ambiguous: got `"), 0xfe10, {.d_s = v__ast__Table_sym(c->table, to_set)->name}}, {_SLIT("`, expected `"), 0xfe10, {.d_s = v__ast__Table_sym(c->table, typ)->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), arg.pos);
					}
				}
				typ = to_set;
			}
		}
		if (v__ast__Type_alias_eq(typ, _const_v__ast__void_type)) {
			v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("could not infer generic type `"), 0xfe10, {.d_s = gt_name}}, {_SLIT("` in call to `"), 0xfe10, {.d_s = func.name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node->pos);
			return;
		}
		if (c->pref->is_verbose) {
			string s = v__ast__Table_type_to_str(c->table, typ);
			println( str_intp(3, _MOV((StrIntpData[]){{_SLIT("inferred `"), 0xfe10, {.d_s = func.name}}, {_SLIT("<"), 0xfe10, {.d_s = s}}, {_SLIT(">`"), 0, { .d_c = 0 }}})));
		}
		array_push((array*)&inferred_types, _MOV((v__ast__Type[]){ typ }));
		array_push((array*)&node->concrete_types, _MOV((v__ast__Type[]){ typ }));
	}
	if (v__ast__Table_register_fn_concrete_types(c->table, v__ast__Fn_fkey(&func), inferred_types)) {
		c->need_recheck_generic_fns = true;
	}
}

VV_LOCAL_SYMBOL Array_string v__checker__all_valid_comptime_idents(void) {
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	_PUSH_MANY(&res, (_const_v__checker__valid_comptime_if_os), _t1, Array_string);
	_PUSH_MANY(&res, (_const_v__checker__valid_comptime_if_compilers), _t2, Array_string);
	_PUSH_MANY(&res, (_const_v__checker__valid_comptime_if_platforms), _t3, Array_string);
	_PUSH_MANY(&res, (_const_v__checker__valid_comptime_if_cpu_features), _t4, Array_string);
	_PUSH_MANY(&res, (_const_v__checker__valid_comptime_if_other), _t5, Array_string);
	Array_string _t6 = res;
	return _t6;
}

v__checker__Checker* v__checker__new_checker(v__ast__Table* table, v__pref__Preferences* pref) {
	bool timers_should_print = false;
	v__checker__Checker* _t1 = (v__checker__Checker*)memdup(&(v__checker__Checker){.pref = pref,.table = table,.file = 0,.nr_errors = 0,.nr_warnings = 0,.nr_notices = 0,.errors = __new_array(0, 0, sizeof(v__errors__Error)),.warnings = __new_array(0, 0, sizeof(v__errors__Warning)),.notices = __new_array(0, 0, sizeof(v__errors__Notice)),.error_lines = __new_array(0, 0, sizeof(int)),.expected_type = 0,.expected_or_type = 0,.mod = (string){.str=(byteptr)"", .is_lit=1},.const_decl = (string){.str=(byteptr)"", .is_lit=1},.const_deps = __new_array(0, 0, sizeof(string)),.const_names = __new_array(0, 0, sizeof(string)),.global_names = __new_array(0, 0, sizeof(string)),.locked_names = __new_array(0, 0, sizeof(string)),.rlocked_names = __new_array(0, 0, sizeof(string)),.in_for_count = 0,.should_abort = 0,.returns = 0,.scope_returns = 0,.is_builtin_mod = 0,.is_generated = 0,.inside_unsafe = 0,.inside_const = 0,.inside_anon_fn = 0,.inside_ref_lit = 0,.inside_defer = 0,.inside_fn_arg = 0,.inside_ct_attr = 0,.skip_flags = 0,.fn_level = 0,.ct_cond_stack = __new_array(0, 0, sizeof(v__ast__Expr)),.stmt_level = 0,.files = __new_array(0, 0, sizeof(v__ast__File)),.expr_level = 0,.cur_orm_ts = (v__ast__TypeSymbol){.parent_idx = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.cname = (string){.str=(byteptr)"", .is_lit=1},.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = (string){.str=(byteptr)"", .is_lit=1},.is_public = 0,.idx = 0,},.error_details = __new_array(0, 0, sizeof(string)),.vmod_file_content = (string){.str=(byteptr)"", .is_lit=1},.loop_label = (string){.str=(byteptr)"", .is_lit=1},.vweb_gen_types = __new_array(0, 0, sizeof(v__ast__Type)),.timers = v__util__new_timers((v__util__TimerParams){.should_print = timers_should_print,.label = _SLIT("checker"),}),.comptime_fields_default_type = 0,.comptime_fields_type = new_map(sizeof(string), sizeof(v__ast__Type), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.fn_scope = ((voidptr)(0)),.main_fn_decl_node = (v__ast__FnDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.is_deprecated = 0,.is_pub = 0,.is_variadic = 0,.is_anon = 0,.is_noreturn = 0,.is_manualfree = 0,.is_main = 0,.is_test = 0,.is_conditional = 0,.is_exported = 0,.is_keep_alive = 0,.is_unsafe = 0,.is_markused = 0,.receiver = (v__ast__StructField){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.has_default_expr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_pub = 0,.default_val = (string){.str=(byteptr)"", .is_lit=1},.is_mut = 0,.is_global = 0,.is_volatile = 0,.default_expr_typ = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,},.receiver_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.is_method = 0,.method_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.method_idx = 0,.rec_mut = 0,.no_body = 0,.is_builtin = 0,.body_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.file = (string){.str=(byteptr)"", .is_lit=1},.generic_names = __new_array(0, 0, sizeof(string)),.is_direct_arr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.ctdefine_idx = -1,.params = __new_array(0, 0, sizeof(v__ast__Param)),.stmts = __new_array(0, 0, sizeof(v__ast__Stmt)),.defer_stmts = __new_array(0, 0, sizeof(v__ast__DeferStmt)),.return_type = 0,.return_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.has_return = 0,.should_be_skipped = 0,.ninstances = 0,.has_await = 0,.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.next_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.source_file = 0,.scope = 0,.label_names = __new_array(0, 0, sizeof(string)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},},.match_exhaustive_cutoff_limit = pref->checker_match_exhaustive_cutoff_limit,.is_last_stmt = 0,.prevent_sum_type_unwrapping_once = 0,.using_new_err_struct = 0,.need_recheck_generic_fns = 0,.inside_sql = 0,.inside_selector_expr = 0,.inside_println_arg = 0,.inside_decl_rhs = 0,.inside_if_guard = 0,}, sizeof(v__checker__Checker));
	return _t1;
}

VV_LOCAL_SYMBOL void v__checker__Checker_reset_checker_state_at_start_of_new_file(v__checker__Checker* c) {
	c->expected_type = _const_v__ast__void_type;
	c->expected_or_type = _const_v__ast__void_type;
	c->const_decl = _SLIT("");
	c->in_for_count = 0;
	c->returns = false;
	c->scope_returns = false;
	c->mod = _SLIT("");
	c->is_builtin_mod = false;
	c->inside_unsafe = false;
	c->inside_const = false;
	c->inside_anon_fn = false;
	c->inside_ref_lit = false;
	c->inside_defer = false;
	c->inside_fn_arg = false;
	c->inside_ct_attr = false;
	c->skip_flags = false;
	c->fn_level = 0;
	c->expr_level = 0;
	c->stmt_level = 0;
	c->inside_sql = false;
	c->cur_orm_ts = (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.cname = (string){.str=(byteptr)"", .is_lit=1},.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = (string){.str=(byteptr)"", .is_lit=1},.is_public = 0,.language = 0,.idx = 0,};
	c->prevent_sum_type_unwrapping_once = false;
	c->loop_label = _SLIT("");
	c->using_new_err_struct = false;
	c->inside_selector_expr = false;
	c->inside_println_arg = false;
	c->inside_decl_rhs = false;
	c->inside_if_guard = false;
}

void v__checker__Checker_check(v__checker__Checker* c, v__ast__File* ast_file_) {
	v__ast__File* ast_file = ast_file_;
	v__checker__Checker_reset_checker_state_at_start_of_new_file(c);
	v__checker__Checker_change_current_file(c, ast_file);
	for (int i = 0; i < ast_file->imports.len; ++i) {
		v__ast__Import ast_import = ((v__ast__Import*)ast_file->imports.data)[i];
		for (int _t1 = 0; _t1 < ast_import.syms.len; ++_t1) {
			v__ast__ImportSymbol sym = ((v__ast__ImportSymbol*)ast_import.syms.data)[_t1];
			string full_name = string__plus(string__plus(ast_import.mod, _SLIT(".")), sym.name);
			if (Array_string_contains(c->const_names, full_name)) {
				v__checker__Checker_error(c,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("cannot selectively import constant `"), 0xfe10, {.d_s = sym.name}}, {_SLIT("` from `"), 0xfe10, {.d_s = ast_import.mod}}, {_SLIT("`, import `"), 0xfe10, {.d_s = ast_import.mod}}, {_SLIT("` and use `"), 0xfe10, {.d_s = full_name}}, {_SLIT("` instead"), 0, { .d_c = 0 }}})), sym.pos);
			}
		}
		for (int j = 0; j < i; ++j) {
			if (string__eq(ast_import.mod, (*(v__ast__Import*)/*ee elem_typ */array_get(ast_file->imports, j)).mod)) {
				v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = ast_import.mod}}, {_SLIT("` was already imported on line "), 0xfe07, {.d_i32 = (*(v__ast__Import*)/*ee elem_typ */array_get(ast_file->imports, j)).mod_pos.line_nr + 1}}, {_SLIT0, 0, { .d_c = 0 }}})), ast_import.mod_pos);
			}
		}
	}
	c->stmt_level = 0;
	for (int _t2 = 0; _t2 < ast_file->stmts.len; ++_t2) {
		v__ast__Stmt* stmt = ((v__ast__Stmt*)ast_file->stmts.data) + _t2;
		if ((stmt)->_typ == 335 /* v.ast.ConstDecl */ || (stmt)->_typ == 339 /* v.ast.ExprStmt */) {
			c->expr_level = 0;
			v__checker__Checker_stmt(c, *stmt);
		}
		if (c->should_abort) {
			return;
		}
	}
	c->stmt_level = 0;
	for (int _t3 = 0; _t3 < ast_file->stmts.len; ++_t3) {
		v__ast__Stmt* stmt = ((v__ast__Stmt*)ast_file->stmts.data) + _t3;
		if ((stmt)->_typ == 343 /* v.ast.GlobalDecl */) {
			c->expr_level = 0;
			v__checker__Checker_stmt(c, *stmt);
		}
		if (c->should_abort) {
			return;
		}
	}
	c->stmt_level = 0;
	for (int _t4 = 0; _t4 < ast_file->stmts.len; ++_t4) {
		v__ast__Stmt* stmt = ((v__ast__Stmt*)ast_file->stmts.data) + _t4;
		if ((stmt)->_typ != 335 /* v.ast.ConstDecl */ && (stmt)->_typ != 343 /* v.ast.GlobalDecl */ && (stmt)->_typ != 339 /* v.ast.ExprStmt */) {
			c->expr_level = 0;
			v__checker__Checker_stmt(c, *stmt);
		}
		if (c->should_abort) {
			return;
		}
	}
	v__checker__Checker_check_scope_vars(c, c->file->scope);
}

void v__checker__Checker_check_scope_vars(v__checker__Checker* c, v__ast__Scope* sc) {
	if (!c->pref->is_repl && !c->file->is_test) {
		Map_string_v__ast__ScopeObject _t1 = sc->objects;
		int _t3 = _t1.key_values.len;
		for (int _t2 = 0; _t2 < _t3; ++_t2 ) {
			int _t4 = _t1.key_values.len - _t3;
			_t3 = _t1.key_values.len;
			if (_t4 < 0) {
				_t2 = -1;
				continue;
			}
			if (!DenseArray_has_index(&_t1.key_values, _t2)) {continue;}
			v__ast__ScopeObject obj = (*(v__ast__ScopeObject*)DenseArray_value(&_t1.key_values, _t2));
			if (obj._typ == 357 /* v.ast.Var */) {
				if (!(*obj._v__ast__Var).is_used && string_at((*obj._v__ast__Var).name, 0) != '_') {
					v__checker__Checker_warn(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unused variable: `"), 0xfe10, {.d_s = (*obj._v__ast__Var).name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), (*obj._v__ast__Var).pos);
				}
				if ((*obj._v__ast__Var).is_mut && !(*obj._v__ast__Var).is_changed && !c->is_builtin_mod && !string__eq((*obj._v__ast__Var).name, _SLIT("it"))) {
				}
			}
			
			else {
			}
			;
		}
	}
	for (int _t5 = 0; _t5 < sc->children.len; ++_t5) {
		v__ast__Scope* child = ((v__ast__Scope**)sc->children.data)[_t5];
		v__checker__Checker_check_scope_vars(c, child);
	}
}

Array_v__errors__Error v__checker__Checker_check2(v__checker__Checker* c, v__ast__File* ast_file) {
	v__checker__Checker_change_current_file(c, ast_file);
	for (int _t1 = 0; _t1 < ast_file->stmts.len; ++_t1) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)ast_file->stmts.data)[_t1];
		v__checker__Checker_stmt(c, stmt);
	}
	Array_v__errors__Error _t2 = c->errors;
	return _t2;
}

void v__checker__Checker_change_current_file(v__checker__Checker* c, v__ast__File* file) {
	c->file = file;
	c->vmod_file_content = _SLIT("");
	c->mod = file->mod.name;
	c->is_generated = file->is_generated;
}

void v__checker__Checker_check_files(v__checker__Checker* c, Array_v__ast__File_ptr ast_files) {
	bool has_main_mod_file = false;
	bool has_main_fn = false;
	Array_v__ast__File_ptr files_from_main_module = __new_array_with_default(0, 0, sizeof(v__ast__File*), 0);
	for (int i = 0; i < ast_files.len; ++i) {
		v__ast__File* file = (*(v__ast__File**)/*ee elem_typ */array_get(ast_files, i));
		v__util__Timers_start(c->timers,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("checker_check "), 0xfe10, {.d_s = file->path}}, {_SLIT0, 0, { .d_c = 0 }}})));
		v__checker__Checker_check(c, file);
		if (string__eq(file->mod.name, _SLIT("main"))) {
			array_push((array*)&files_from_main_module, _MOV((v__ast__File*[]){ file }));
			has_main_mod_file = true;
			if (v__checker__Checker_file_has_main_fn(c, file)) {
				has_main_fn = true;
			}
		}
		v__util__Timers_show(c->timers,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("checker_check "), 0xfe10, {.d_s = file->path}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
	if (has_main_mod_file && !has_main_fn && files_from_main_module.len > 0) {
		if (c->pref->is_script && !c->pref->is_test) {
			v__ast__File* the_main_file = (*(v__ast__File**)array_last(files_from_main_module));
			array_push((array*)&the_main_file->stmts, _MOV((v__ast__Stmt[]){ v__ast__FnDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__FnDecl, ((v__ast__FnDecl){
				.name = _SLIT("main.main"),
				.mod = _SLIT("main"),
				.is_deprecated = 0,
				.is_pub = 0,
				.is_variadic = 0,
				.is_anon = 0,
				.is_noreturn = 0,
				.is_manualfree = 0,
				.is_main = true,
				.is_test = 0,
				.is_conditional = 0,
				.is_exported = 0,
				.is_keep_alive = 0,
				.is_unsafe = 0,
				.is_markused = 0,
				.receiver = (v__ast__StructField){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.has_default_expr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_pub = 0,.default_val = (string){.str=(byteptr)"", .is_lit=1},.is_mut = 0,.is_global = 0,.is_volatile = 0,.default_expr_typ = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,},
				.receiver_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},
				.is_method = 0,
				.method_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},
				.method_idx = 0,
				.rec_mut = 0,
				.rec_share = 0,
				.language = 0,
				.file_mode = 0,
				.no_body = 0,
				.is_builtin = 0,
				.body_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},
				.file = the_main_file->path,
				.generic_names = __new_array(0, 0, sizeof(string)),
				.is_direct_arr = 0,
				.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),
				.ctdefine_idx = -1,
				.params = __new_array(0, 0, sizeof(v__ast__Param)),
				.stmts = __new_array(0, 0, sizeof(v__ast__Stmt)),
				.defer_stmts = __new_array(0, 0, sizeof(v__ast__DeferStmt)),
				.return_type = _const_v__ast__void_type,
				.return_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},
				.has_return = 0,
				.should_be_skipped = 0,
				.ninstances = 0,
				.has_await = 0,
				.comments = __new_array(0, 0, sizeof(v__ast__Comment)),
				.next_comments = __new_array(0, 0, sizeof(v__ast__Comment)),
				.source_file = 0,
				.scope = (v__ast__Scope*)memdup(&(v__ast__Scope){.objects = new_map(sizeof(string), sizeof(v__ast__ScopeObject), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.struct_fields = new_map(sizeof(string), sizeof(v__ast__ScopeStructField), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.parent = 0,.detached_from_parent = 0,.children = __new_array(0, 0, sizeof(v__ast__Scope*)),.start_pos = 0,.end_pos = 0,}, sizeof(v__ast__Scope)),
				.label_names = __new_array(0, 0, sizeof(string)),
				.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},
			}))) }));
			has_main_fn = true;
		}
	}
	v__util__Timers_start(c->timers, _SLIT("checker_post_process_generic_fns"));
	v__ast__File* last_file = c->file;
	int post_process_generic_fns_iterations = 0;
	for (;;) {
		for (int _t3 = 0; _t3 < ast_files.len; ++_t3) {
			v__ast__File* file = ((v__ast__File**)ast_files.data)[_t3];
			if (file->generic_fns.len > 0) {
				v__checker__Checker_change_current_file(c, file);
				v__checker__Checker_post_process_generic_fns(c);
			}
		}
		if (!c->need_recheck_generic_fns) {
			break;
		}
		c->need_recheck_generic_fns = false;
		post_process_generic_fns_iterations++;
	}
	v__checker__Checker_change_current_file(c, last_file);
	v__util__Timers_show(c->timers, _SLIT("checker_post_process_generic_fns"));
	v__util__Timers_start(c->timers, _SLIT("checker_verify_all_vweb_routes"));
	v__checker__Checker_verify_all_vweb_routes(c);
	v__util__Timers_show(c->timers, _SLIT("checker_verify_all_vweb_routes"));
	if (c->pref->is_test) {
		int n_test_fns = 0;
		Map_string_v__ast__Fn _t4 = c->table->fns;
		int _t6 = _t4.key_values.len;
		for (int _t5 = 0; _t5 < _t6; ++_t5 ) {
			int _t7 = _t4.key_values.len - _t6;
			_t6 = _t4.key_values.len;
			if (_t7 < 0) {
				_t5 = -1;
				continue;
			}
			if (!DenseArray_has_index(&_t4.key_values, _t5)) {continue;}
			v__ast__Fn f = (*(v__ast__Fn*)DenseArray_value(&_t4.key_values, _t5));
			if (f.is_test) {
				n_test_fns++;
			}
		}
		if (n_test_fns == 0) {
			v__checker__Checker_add_error_detail(c, _SLIT("The name of a test function in V, should start with `test_`."));
			v__checker__Checker_add_error_detail(c, _SLIT("The test function should take 0 parameters, and no return type. Example:"));
			v__checker__Checker_add_error_detail(c, _SLIT("fn test_xyz(){ assert 2 + 2 == 4 }"));
			v__checker__Checker_error(c, _SLIT("a _test.v file should have *at least* one `test_` function"), (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,});
		}
	}
	if (c->pref->build_mode == v__pref__BuildMode__build_module || c->pref->is_test) {
		return;
	}
	if (c->pref->is_shared) {
		return;
	}
	if (c->pref->no_builtin) {
		return;
	}
	if (!has_main_mod_file) {
		v__checker__Checker_error(c, _SLIT("project must include a `main` module or be a shared library (compile with `v -shared`)"), (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,});
	} else if (!has_main_fn) {
		v__checker__Checker_error(c, _SLIT("function `main` must be declared in the main module"), (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,});
	}
}

VV_LOCAL_SYMBOL bool v__checker__Checker_file_has_main_fn(v__checker__Checker* c, v__ast__File* file) {
	bool has_main_fn = false;
	for (int _t1 = 0; _t1 < file->stmts.len; ++_t1) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)file->stmts.data)[_t1];
		if ((stmt)._typ == 216 /* v.ast.FnDecl */) {
			if (string__eq((*stmt._v__ast__FnDecl).name, _SLIT("main.main"))) {
				if (has_main_fn) {
					v__checker__Checker_error(c, _SLIT("function `main` is already defined"), (*stmt._v__ast__FnDecl).pos);
				}
				has_main_fn = true;
				if ((*stmt._v__ast__FnDecl).params.len > 0) {
					v__checker__Checker_error(c, _SLIT("function `main` cannot have arguments"), (*stmt._v__ast__FnDecl).pos);
				}
				if (!v__ast__Type_alias_eq((*stmt._v__ast__FnDecl).return_type, _const_v__ast__void_type)) {
					v__checker__Checker_error(c, _SLIT("function `main` cannot return values"), (*stmt._v__ast__FnDecl).pos);
				}
				if ((*stmt._v__ast__FnDecl).no_body) {
					v__checker__Checker_error(c, _SLIT("function `main` must declare a body"), (*stmt._v__ast__FnDecl).pos);
				}
			} else if (Array_v__ast__Attr_contains((*stmt._v__ast__FnDecl).attrs, _SLIT("console"))) {
				v__checker__Checker_error(c, _SLIT("only `main` can have the `[console]` attribute"), (*stmt._v__ast__FnDecl).pos);
			}
		}
	}
	bool _t2 = has_main_fn;
	return _t2;
}

VV_LOCAL_SYMBOL void v__checker__Checker_check_valid_snake_case(v__checker__Checker* c, string name, string identifier, v__token__Position pos) {
	if (!c->pref->is_vweb && !c->pref->translated && name.len > 0 && (string_at(name, 0) == '_' || string_contains(name, _SLIT("._")))) {
		v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = identifier}}, {_SLIT(" `"), 0xfe10, {.d_s = name}}, {_SLIT("` cannot start with `_`"), 0, { .d_c = 0 }}})), pos);
	}
	if (!c->pref->experimental && !c->pref->translated && v__util__contains_capital(name)) {
		v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = identifier}}, {_SLIT(" `"), 0xfe10, {.d_s = name}}, {_SLIT("` cannot contain uppercase letters, use snake_case instead"), 0, { .d_c = 0 }}})), pos);
	}
}

VV_LOCAL_SYMBOL string v__checker__stripped_name(string name) {
	Option_int _t1 = string_last_index(name, _SLIT("."));
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		*(int*) _t1.data = -1;
	}
	
 	int idx =  (*(int*)_t1.data);
	string _t2 = string_substr(name, (idx + 1), name.len);
	return _t2;
}

VV_LOCAL_SYMBOL void v__checker__Checker_check_valid_pascal_case(v__checker__Checker* c, string name, string identifier, v__token__Position pos) {
	string sname = v__checker__stripped_name(name);
	if (sname.len > 0 && !byte_is_capital(string_at(sname, 0)) && !c->pref->translated) {
		v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = identifier}}, {_SLIT(" `"), 0xfe10, {.d_s = name}}, {_SLIT("` must begin with capital letter"), 0, { .d_c = 0 }}})), pos);
	}
}

void v__checker__Checker_type_decl(v__checker__Checker* c, v__ast__TypeDecl node) {
	if (node._typ == 274 /* v.ast.AliasTypeDecl */) {
		v__checker__Checker_alias_type_decl(c, (*node._v__ast__AliasTypeDecl));
	}
	else if (node._typ == 275 /* v.ast.FnTypeDecl */) {
		v__checker__Checker_fn_type_decl(c, (*node._v__ast__FnTypeDecl));
	}
	else if (node._typ == 276 /* v.ast.SumTypeDecl */) {
		v__checker__Checker_sum_type_decl(c, (*node._v__ast__SumTypeDecl));
	}
	;
}

void v__checker__Checker_alias_type_decl(v__checker__Checker* c, v__ast__AliasTypeDecl node) {
	if (!string__eq(c->file->mod.name, _SLIT("builtin"))) {
		v__checker__Checker_check_valid_pascal_case(c, node.name, _SLIT("type alias"), node.pos);
	}
	Option_void _t1 = v__checker__Checker_ensure_type_exists(c, node.parent_type, node.type_pos);
	if (_t1.state != 0 && _t1.err._typ != _IError_None___index) {
		IError err = _t1.err;
		return;
	}
	
 ;
	v__ast__TypeSymbol* typ_sym = v__ast__Table_sym(c->table, node.parent_type);
	if (typ_sym->kind == v__ast__Kind__placeholder || typ_sym->kind == v__ast__Kind__int_literal || typ_sym->kind == v__ast__Kind__float_literal) {
		v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unknown type `"), 0xfe10, {.d_s = typ_sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node.type_pos);
	} else if (typ_sym->kind == v__ast__Kind__alias) {
		v__ast__TypeSymbol* orig_sym = v__ast__Table_sym(c->table, (/* as */ *(v__ast__Alias*)__as_cast((typ_sym->info)._v__ast__Alias,(typ_sym->info)._typ, 460) /*expected idx: 460, name: v.ast.Alias */ ).parent_type);
		v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("type `"), 0xfe10, {.d_s = v__ast__TypeSymbol_str(typ_sym)}}, {_SLIT("` is an alias, use the original alias type `"), 0xfe10, {.d_s = orig_sym->name}}, {_SLIT("` instead"), 0, { .d_c = 0 }}})), node.type_pos);
	} else if (typ_sym->kind == v__ast__Kind__chan) {
		v__checker__Checker_error(c, _SLIT("aliases of `chan` types are not allowed."), node.type_pos);
	}
}

void v__checker__Checker_fn_type_decl(v__checker__Checker* c, v__ast__FnTypeDecl node) {
	v__checker__Checker_check_valid_pascal_case(c, node.name, _SLIT("fn type"), node.pos);
	v__ast__TypeSymbol* typ_sym = v__ast__Table_sym(c->table, node.typ);
	v__ast__FnType fn_typ_info = /* as */ *(v__ast__FnType*)__as_cast((typ_sym->info)._v__ast__FnType,(typ_sym->info)._typ, 472) /*expected idx: 472, name: v.ast.FnType */ ;
	v__ast__Fn fn_info = fn_typ_info.func;
	Option_void _t1 = v__checker__Checker_ensure_type_exists(c, fn_info.return_type, fn_info.return_type_pos);
	if (_t1.state != 0 && _t1.err._typ != _IError_None___index) {
		IError err = _t1.err;
	}
	
 ;
	v__ast__TypeSymbol* ret_sym = v__ast__Table_sym(c->table, fn_info.return_type);
	if (ret_sym->kind == v__ast__Kind__placeholder) {
		v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unknown type `"), 0xfe10, {.d_s = ret_sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), fn_info.return_type_pos);
	}
	for (int _t2 = 0; _t2 < fn_info.params.len; ++_t2) {
		v__ast__Param arg = ((v__ast__Param*)fn_info.params.data)[_t2];
		Option_void _t3 = v__checker__Checker_ensure_type_exists(c, arg.typ, arg.type_pos);
		if (_t3.state != 0 && _t3.err._typ != _IError_None___index) {
			IError err = _t3.err;
			return;
		}
		
 ;
		v__ast__TypeSymbol* arg_sym = v__ast__Table_sym(c->table, arg.typ);
		if (arg_sym->kind == v__ast__Kind__placeholder) {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unknown type `"), 0xfe10, {.d_s = arg_sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), arg.type_pos);
		}
	}
}

void v__checker__Checker_sum_type_decl(v__checker__Checker* c, v__ast__SumTypeDecl node) {
	v__checker__Checker_check_valid_pascal_case(c, node.name, _SLIT("sum type"), node.pos);
	Array_string names_used = __new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t1 = 0; _t1 < node.variants.len; ++_t1) {
		v__ast__TypeNode variant = ((v__ast__TypeNode*)node.variants.data)[_t1];
		if (v__ast__Type_is_ptr(variant.typ)) {
			v__checker__Checker_error(c, _SLIT("sum type cannot hold a reference type"), variant.pos);
		}
		Option_void _t2 = v__checker__Checker_ensure_type_exists(c, variant.typ, variant.pos);
		if (_t2.state != 0 && _t2.err._typ != _IError_None___index) {
			IError err = _t2.err;
		}
		
 ;
		v__ast__TypeSymbol* sym = v__ast__Table_sym(c->table, variant.typ);
		if (Array_string_contains(names_used, sym->name)) {
			v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("sum type "), 0xfe10, {.d_s = node.name}}, {_SLIT(" cannot hold the type `"), 0xfe10, {.d_s = sym->name}}, {_SLIT("` more than once"), 0, { .d_c = 0 }}})), variant.pos);
		} else if (sym->kind == v__ast__Kind__placeholder || sym->kind == v__ast__Kind__int_literal || sym->kind == v__ast__Kind__float_literal) {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unknown type `"), 0xfe10, {.d_s = sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), variant.pos);
		} else if (sym->kind == v__ast__Kind__interface_ && sym->language != v__ast__Language__js) {
			v__checker__Checker_error(c, _SLIT("sum type cannot hold an interface"), variant.pos);
		} else if (sym->kind == v__ast__Kind__struct_ && sym->language == v__ast__Language__js) {
			v__checker__Checker_error(c, _SLIT("sum type cannot hold an JS struct"), variant.pos);
		}
		if (string__eq(string_trim_string_left(sym->name, string__plus(sym->mod, _SLIT("."))), node.name)) {
			v__checker__Checker_error(c, _SLIT("sum type cannot hold itself"), variant.pos);
		}
		array_push((array*)&names_used, _MOV((string[]){ string_clone(sym->name) }));
	}
}

Array_v__ast__InterfaceEmbedding v__checker__Checker_expand_iface_embeds(v__checker__Checker* c, v__ast__InterfaceDecl* idecl, int level, Array_v__ast__InterfaceEmbedding iface_embeds) {
	if (level > 100) {
		v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("too many interface embedding levels: "), 0xfe07, {.d_i32 = level}}, {_SLIT(", for interface `"), 0xfe10, {.d_s = idecl->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), idecl->pos);
		Array_v__ast__InterfaceEmbedding _t1 = __new_array_with_default(0, 0, sizeof(v__ast__InterfaceEmbedding), 0);
		return _t1;
	}
	if (iface_embeds.len == 0) {
		Array_v__ast__InterfaceEmbedding _t2 = __new_array_with_default(0, 0, sizeof(v__ast__InterfaceEmbedding), 0);
		return _t2;
	}
	Map_int_v__ast__InterfaceEmbedding res = new_map(sizeof(int), sizeof(v__ast__InterfaceEmbedding), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop);
	Array_v__ast__InterfaceEmbedding ares = __new_array_with_default(0, 0, sizeof(v__ast__InterfaceEmbedding), 0);
	for (int _t3 = 0; _t3 < iface_embeds.len; ++_t3) {
		v__ast__InterfaceEmbedding ie = ((v__ast__InterfaceEmbedding*)iface_embeds.data)[_t3];
		v__ast__InterfaceDecl* _t5 = (v__ast__InterfaceDecl*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, c->table->interfaces), &(int[]){ie.typ}));
		Option_v__ast__InterfaceDecl _t4 = {0};
		if (_t5) {
			*((v__ast__InterfaceDecl*)&_t4.data) = *((v__ast__InterfaceDecl*)_t5);
		} else {
			_t4.state = 2; _t4.err = _v_error(_SLIT("array index out of range"));
		}
		
		if (_t4.state == 0) {
			v__ast__InterfaceDecl iface_decl = *(v__ast__InterfaceDecl*)_t4.data;
			Array_v__ast__InterfaceEmbedding list = iface_decl.ifaces;
			if (!iface_decl.are_ifaces_expanded) {
				list = v__checker__Checker_expand_iface_embeds(c, idecl, level + 1, iface_decl.ifaces);
				(*(v__ast__InterfaceDecl*)map_get_and_set((map*)&c->table->interfaces, &(int[]){ie.typ}, &(v__ast__InterfaceDecl[]){ (v__ast__InterfaceDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,.name_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.field_names = __new_array(0, 0, sizeof(string)),.is_pub = 0,.mut_pos = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.pre_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = __new_array(0, 0, sizeof(v__ast__Type)),.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.methods = __new_array(0, 0, sizeof(v__ast__FnDecl)),.fields = __new_array(0, 0, sizeof(v__ast__StructField)),.ifaces = __new_array(0, 0, sizeof(v__ast__InterfaceEmbedding)),.are_ifaces_expanded = 0,} })).ifaces = list;
				(*(v__ast__InterfaceDecl*)map_get_and_set((map*)&c->table->interfaces, &(int[]){ie.typ}, &(v__ast__InterfaceDecl[]){ (v__ast__InterfaceDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,.name_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.field_names = __new_array(0, 0, sizeof(string)),.is_pub = 0,.mut_pos = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.pre_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = __new_array(0, 0, sizeof(v__ast__Type)),.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.methods = __new_array(0, 0, sizeof(v__ast__FnDecl)),.fields = __new_array(0, 0, sizeof(v__ast__StructField)),.ifaces = __new_array(0, 0, sizeof(v__ast__InterfaceEmbedding)),.are_ifaces_expanded = 0,} })).are_ifaces_expanded = true;
			}
			for (int _t6 = 0; _t6 < list.len; ++_t6) {
				v__ast__InterfaceEmbedding partial = ((v__ast__InterfaceEmbedding*)list.data)[_t6];
				(*(v__ast__InterfaceEmbedding*)map_get_and_set((map*)&res, &(int[]){partial.typ}, &(v__ast__InterfaceEmbedding[]){ (v__ast__InterfaceEmbedding){.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comments = __new_array(0, 0, sizeof(v__ast__Comment)),} })) = partial;
			}
		}
		(*(v__ast__InterfaceEmbedding*)map_get_and_set((map*)&res, &(int[]){ie.typ}, &(v__ast__InterfaceEmbedding[]){ (v__ast__InterfaceEmbedding){.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comments = __new_array(0, 0, sizeof(v__ast__Comment)),} })) = ie;
	}
	int _t8 = res.key_values.len;
	for (int _t7 = 0; _t7 < _t8; ++_t7 ) {
		int _t9 = res.key_values.len - _t8;
		_t8 = res.key_values.len;
		if (_t9 < 0) {
			_t7 = -1;
			continue;
		}
		if (!DenseArray_has_index(&res.key_values, _t7)) {continue;}
		v__ast__InterfaceEmbedding v = (*(v__ast__InterfaceEmbedding*)DenseArray_value(&res.key_values, _t7));
		array_push((array*)&ares, _MOV((v__ast__InterfaceEmbedding[]){ v }));
	}
	Array_v__ast__InterfaceEmbedding _t11 = ares;
	return _t11;
}

VV_LOCAL_SYMBOL void v__checker__Checker_check_div_mod_by_zero(v__checker__Checker* c, v__ast__Expr expr, v__token__Kind op_kind) {
	if (expr._typ == 297 /* v.ast.FloatLiteral */) {
		if (string_f64((*expr._v__ast__FloatLiteral).val) == 0.0) {
			string oper = (op_kind == v__token__Kind__div ? (_SLIT("division")) : (_SLIT("modulo")));
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = oper}}, {_SLIT(" by zero"), 0, { .d_c = 0 }}})), (*expr._v__ast__FloatLiteral).pos);
		}
	}
	else if (expr._typ == 304 /* v.ast.IntegerLiteral */) {
		if (string_int((*expr._v__ast__IntegerLiteral).val) == 0) {
			string oper = (op_kind == v__token__Kind__div ? (_SLIT("division")) : (_SLIT("modulo")));
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = oper}}, {_SLIT(" by zero"), 0, { .d_c = 0 }}})), (*expr._v__ast__IntegerLiteral).pos);
		}
	}
	else if (expr._typ == 287 /* v.ast.CastExpr */) {
		v__checker__Checker_check_div_mod_by_zero(c, (*expr._v__ast__CastExpr).expr, op_kind);
	}
	
	else {
	}
	;
}

v__ast__Type v__checker__Checker_infix_expr(v__checker__Checker* c, v__ast__InfixExpr* node) {
bool v__checker__Checker_infix_expr_defer_0 = false;
v__ast__Type former_expected_type;
	former_expected_type = c->expected_type;
	v__checker__Checker_infix_expr_defer_0 = true;
	v__ast__Type left_type = v__checker__Checker_expr(c, node->left);
	node->left_type = left_type;
	c->expected_type = left_type;
	v__ast__Type right_type = v__checker__Checker_expr(c, node->right);
	node->right_type = right_type;
	if (v__ast__Type_is_number(left_type) && !v__ast__Type_is_ptr(left_type) && (right_type == _const_v__ast__int_literal_type || right_type == _const_v__ast__float_literal_type)) {
		node->right_type = left_type;
	}
	if (v__ast__Type_is_number(right_type) && !v__ast__Type_is_ptr(right_type) && (left_type == _const_v__ast__int_literal_type || left_type == _const_v__ast__float_literal_type)) {
		node->left_type = right_type;
	}
	v__ast__TypeSymbol* right_sym = v__ast__Table_sym(c->table, right_type);
	v__ast__TypeSymbol* right_final = v__ast__Table_final_sym(c->table, right_type);
	v__ast__TypeSymbol* left_sym = v__ast__Table_sym(c->table, left_type);
	v__ast__TypeSymbol* left_final = v__ast__Table_final_sym(c->table, left_type);
	v__token__Position left_pos = v__ast__Expr_position(node->left);
	v__token__Position right_pos = v__ast__Expr_position(node->right);
	v__token__Position left_right_pos = v__token__Position_extend(left_pos, right_pos);
	if (v__ast__Type_is_any_kind_of_pointer(left_type) && (node->op == v__token__Kind__plus || node->op == v__token__Kind__minus || node->op == v__token__Kind__mul || node->op == v__token__Kind__div || node->op == v__token__Kind__mod || node->op == v__token__Kind__xor || node->op == v__token__Kind__amp || node->op == v__token__Kind__pipe)) {
		if ((v__ast__Type_is_any_kind_of_pointer(right_type) && node->op != v__token__Kind__minus) || (!v__ast__Type_is_any_kind_of_pointer(right_type) && !(node->op == v__token__Kind__plus || node->op == v__token__Kind__minus))) {
			string left_name = v__ast__Table_type_to_str(c->table, left_type);
			string right_name = v__ast__Table_type_to_str(c->table, right_type);
			v__checker__Checker_error(c,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("invalid operator `"), 0xfe10, {.d_s = v__token__Kind_str(node->op)}}, {_SLIT("` to `"), 0xfe10, {.d_s = left_name}}, {_SLIT("` and `"), 0xfe10, {.d_s = right_name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), left_right_pos);
		} else if (node->op == v__token__Kind__plus || node->op == v__token__Kind__minus) {
			if (!c->inside_unsafe && !v__ast__Expr_is_auto_deref_var(node->left) && !v__ast__Expr_is_auto_deref_var(node->right)) {
				v__checker__Checker_warn(c, _SLIT("pointer arithmetic is only allowed in `unsafe` blocks"), left_right_pos);
			}
			if (v__ast__Type_alias_eq(left_type, _const_v__ast__voidptr_type)) {
				v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = v__token__Kind_str(node->op)}}, {_SLIT("` cannot be used with `voidptr`"), 0, { .d_c = 0 }}})), left_pos);
			}
		}
	}
	v__ast__Type return_type = left_type;
	if (node->op != v__token__Kind__key_is) {
		if (node->left._typ == 299 /* v.ast.Ident */) {
			if ((*node->left._v__ast__Ident).is_mut) {
				v__checker__Checker_error(c, _SLIT("remove unnecessary `mut`"), (*node->left._v__ast__Ident).mut_pos);
			}
		}
		else if (node->left._typ == 319 /* v.ast.SelectorExpr */) {
			if ((*node->left._v__ast__SelectorExpr).is_mut) {
				v__checker__Checker_error(c, _SLIT("remove unnecessary `mut`"), (*node->left._v__ast__SelectorExpr).mut_pos);
			}
		}
		
		else {
		}
		;
	}
	bool eq_ne = (node->op == v__token__Kind__eq || node->op == v__token__Kind__ne);
	switch (node->op) {
		case v__token__Kind__eq: 
		case v__token__Kind__ne: 
			{
				bool is_mismatch = (left_sym->kind == v__ast__Kind__alias && (right_sym->kind == v__ast__Kind__struct_ || right_sym->kind == v__ast__Kind__array || right_sym->kind == v__ast__Kind__sum_type)) || (right_sym->kind == v__ast__Kind__alias && (left_sym->kind == v__ast__Kind__struct_ || left_sym->kind == v__ast__Kind__array || left_sym->kind == v__ast__Kind__sum_type));
				if (is_mismatch) {
					v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("possible type mismatch of compared values of `"), 0xfe10, {.d_s = v__token__Kind_str(node->op)}}, {_SLIT("` operation"), 0, { .d_c = 0 }}})), left_right_pos);
				}
			} break;
		case v__token__Kind__key_in: 
		case v__token__Kind__not_in: 
			{

				if (right_final->kind == (v__ast__Kind__array)) {
					if (!(left_sym->kind == v__ast__Kind__sum_type || left_sym->kind == v__ast__Kind__interface_)) {
						v__ast__Type elem_type = v__ast__TypeSymbol_array_info(right_final).elem_type;
						Option_void _t1 = v__checker__Checker_check_expected(c, left_type, elem_type);
						if (_t1.state != 0 && _t1.err._typ != _IError_None___index) {
							IError err = _t1.err;
							v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("left operand to `"), 0xfe10, {.d_s = v__token__Kind_str(node->op)}}, {_SLIT("` does not match the array element type: "), 0xfe10, {.d_s = (*(err.msg))}}, {_SLIT0, 0, { .d_c = 0 }}})), left_right_pos);
						;
						}
						
 ;
					}
				}
				else if (right_final->kind == (v__ast__Kind__map)) {
					v__ast__Map map_info = v__ast__TypeSymbol_map_info(right_final);
					Option_void _t2 = v__checker__Checker_check_expected(c, left_type, map_info.key_type);
					if (_t2.state != 0 && _t2.err._typ != _IError_None___index) {
						IError err = _t2.err;
						v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("left operand to `"), 0xfe10, {.d_s = v__token__Kind_str(node->op)}}, {_SLIT("` does not match the map key type: "), 0xfe10, {.d_s = (*(err.msg))}}, {_SLIT0, 0, { .d_c = 0 }}})), left_right_pos);
					;
					}
					
 ;
					node->left_type = map_info.key_type;
				}
				else {
					v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = v__token__Kind_str(node->op)}}, {_SLIT("` can only be used with arrays and maps"), 0, { .d_c = 0 }}})), node->pos);
				};
				v__ast__Type _t3 = _const_v__ast__bool_type;
				// Defer begin
				if (v__checker__Checker_infix_expr_defer_0) {
					c->expected_type = former_expected_type;
				}
				// Defer end
				return _t3;
			} break;
		case v__token__Kind__plus: 
		case v__token__Kind__minus: 
		case v__token__Kind__mul: 
		case v__token__Kind__div: 
		case v__token__Kind__mod: 
		case v__token__Kind__xor: 
		case v__token__Kind__amp: 
		case v__token__Kind__pipe: 
			{
				if ((right_sym->info)._typ == 460 /* v.ast.Alias */ && (/* as */ *(v__ast__Alias*)__as_cast((right_sym->info)._v__ast__Alias,(right_sym->info)._typ, 460) /*expected idx: 460, name: v.ast.Alias */ ).language != v__ast__Language__c && string__eq(c->mod, (*(string*)/*ee elem_typ */array_get(string_split(v__ast__Table_type_to_str(c->table, right_type), _SLIT(".")), 0))) && v__ast__TypeSymbol_is_primitive(v__ast__Table_sym(c->table, (/* as */ *(v__ast__Alias*)__as_cast((right_sym->info)._v__ast__Alias,(right_sym->info)._typ, 460) /*expected idx: 460, name: v.ast.Alias */ ).parent_type))) {
					right_sym = v__ast__Table_sym(c->table, (/* as */ *(v__ast__Alias*)__as_cast((right_sym->info)._v__ast__Alias,(right_sym->info)._typ, 460) /*expected idx: 460, name: v.ast.Alias */ ).parent_type);
				}
				if ((left_sym->info)._typ == 460 /* v.ast.Alias */ && (/* as */ *(v__ast__Alias*)__as_cast((left_sym->info)._v__ast__Alias,(left_sym->info)._typ, 460) /*expected idx: 460, name: v.ast.Alias */ ).language != v__ast__Language__c && string__eq(c->mod, (*(string*)/*ee elem_typ */array_get(string_split(v__ast__Table_type_to_str(c->table, left_type), _SLIT(".")), 0))) && v__ast__TypeSymbol_is_primitive(v__ast__Table_sym(c->table, (/* as */ *(v__ast__Alias*)__as_cast((left_sym->info)._v__ast__Alias,(left_sym->info)._typ, 460) /*expected idx: 460, name: v.ast.Alias */ ).parent_type))) {
					left_sym = v__ast__Table_sym(c->table, (/* as */ *(v__ast__Alias*)__as_cast((left_sym->info)._v__ast__Alias,(left_sym->info)._typ, 460) /*expected idx: 460, name: v.ast.Alias */ ).parent_type);
				}
				if (left_sym->kind == v__ast__Kind__alias && (left_sym->info)._typ == 460 /* v.ast.Alias */ && !(v__ast__TypeSymbol_is_primitive(v__ast__Table_sym(c->table, (/* as */ *(v__ast__Alias*)__as_cast((left_sym->info)._v__ast__Alias,(left_sym->info)._typ, 460) /*expected idx: 460, name: v.ast.Alias */ ).parent_type)))) {
					if (v__ast__TypeSymbol_has_method(left_sym, v__token__Kind_str(node->op))) {
						Option_v__ast__Fn _t4;
						if (_t4 = v__ast__TypeSymbol_find_method(left_sym, v__token__Kind_str(node->op)), _t4.state == 0) {
							v__ast__Fn method = *(v__ast__Fn*)_t4.data;
							return_type = method.return_type;
						} else {
							IError err = _t4.err;
							return_type = left_type;
						}
					} else {
						string left_name = v__ast__Table_type_to_str(c->table, left_type);
						string right_name = v__ast__Table_type_to_str(c->table, right_type);
						if (string__eq(left_name, right_name)) {
							v__checker__Checker_error(c,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("undefined operation `"), 0xfe10, {.d_s = left_name}}, {_SLIT("` "), 0xfe10, {.d_s = v__token__Kind_str(node->op)}}, {_SLIT(" `"), 0xfe10, {.d_s = right_name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), left_right_pos);
						} else {
							v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("mismatched types `"), 0xfe10, {.d_s = left_name}}, {_SLIT("` and `"), 0xfe10, {.d_s = right_name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), left_right_pos);
						}
					}
				} else if (right_sym->kind == v__ast__Kind__alias && (right_sym->info)._typ == 460 /* v.ast.Alias */ && !(v__ast__TypeSymbol_is_primitive(v__ast__Table_sym(c->table, (/* as */ *(v__ast__Alias*)__as_cast((right_sym->info)._v__ast__Alias,(right_sym->info)._typ, 460) /*expected idx: 460, name: v.ast.Alias */ ).parent_type)))) {
					if (v__ast__TypeSymbol_has_method(right_sym, v__token__Kind_str(node->op))) {
						Option_v__ast__Fn _t5;
						if (_t5 = v__ast__TypeSymbol_find_method(right_sym, v__token__Kind_str(node->op)), _t5.state == 0) {
							v__ast__Fn method = *(v__ast__Fn*)_t5.data;
							return_type = method.return_type;
						} else {
							IError err = _t5.err;
							return_type = right_type;
						}
					} else {
						string left_name = v__ast__Table_type_to_str(c->table, left_type);
						string right_name = v__ast__Table_type_to_str(c->table, right_type);
						if (string__eq(left_name, right_name)) {
							v__checker__Checker_error(c,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("undefined operation `"), 0xfe10, {.d_s = left_name}}, {_SLIT("` "), 0xfe10, {.d_s = v__token__Kind_str(node->op)}}, {_SLIT(" `"), 0xfe10, {.d_s = right_name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), left_right_pos);
						} else {
							v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("mismatched types `"), 0xfe10, {.d_s = left_name}}, {_SLIT("` and `"), 0xfe10, {.d_s = right_name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), left_right_pos);
						}
					}
				}
				if (left_sym->kind == v__ast__Kind__array || left_sym->kind == v__ast__Kind__array_fixed || left_sym->kind == v__ast__Kind__map || left_sym->kind == v__ast__Kind__struct_) {
					if (v__ast__TypeSymbol_has_method(left_sym, v__token__Kind_str(node->op))) {
						Option_v__ast__Fn _t6;
						if (_t6 = v__ast__TypeSymbol_find_method(left_sym, v__token__Kind_str(node->op)), _t6.state == 0) {
							v__ast__Fn method = *(v__ast__Fn*)_t6.data;
							return_type = method.return_type;
						} else {
							IError err = _t6.err;
							return_type = left_type;
						}
					} else {
						if (left_sym->kind == v__ast__Kind__struct_ && (/* as */ *(v__ast__Struct*)__as_cast((left_sym->info)._v__ast__Struct,(left_sym->info)._typ, 446) /*expected idx: 446, name: v.ast.Struct */ ).generic_types.len > 0) {
							return_type = left_type;
						} else {
							string left_name = v__ast__Table_type_to_str(c->table, left_type);
							string right_name = v__ast__Table_type_to_str(c->table, right_type);
							if (string__eq(left_name, right_name)) {
								v__checker__Checker_error(c,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("undefined operation `"), 0xfe10, {.d_s = left_name}}, {_SLIT("` "), 0xfe10, {.d_s = v__token__Kind_str(node->op)}}, {_SLIT(" `"), 0xfe10, {.d_s = right_name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), left_right_pos);
							} else {
								v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("mismatched types `"), 0xfe10, {.d_s = left_name}}, {_SLIT("` and `"), 0xfe10, {.d_s = right_name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), left_right_pos);
							}
						}
					}
				} else if (right_sym->kind == v__ast__Kind__array || right_sym->kind == v__ast__Kind__array_fixed || right_sym->kind == v__ast__Kind__map || right_sym->kind == v__ast__Kind__struct_) {
					if (v__ast__TypeSymbol_has_method(right_sym, v__token__Kind_str(node->op))) {
						Option_v__ast__Fn _t7;
						if (_t7 = v__ast__TypeSymbol_find_method(right_sym, v__token__Kind_str(node->op)), _t7.state == 0) {
							v__ast__Fn method = *(v__ast__Fn*)_t7.data;
							return_type = method.return_type;
						} else {
							IError err = _t7.err;
							return_type = right_type;
						}
					} else {
						string left_name = v__ast__Table_type_to_str(c->table, left_type);
						string right_name = v__ast__Table_type_to_str(c->table, right_type);
						if (string__eq(left_name, right_name)) {
							v__checker__Checker_error(c,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("undefined operation `"), 0xfe10, {.d_s = left_name}}, {_SLIT("` "), 0xfe10, {.d_s = v__token__Kind_str(node->op)}}, {_SLIT(" `"), 0xfe10, {.d_s = right_name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), left_right_pos);
						} else {
							v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("mismatched types `"), 0xfe10, {.d_s = left_name}}, {_SLIT("` and `"), 0xfe10, {.d_s = right_name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), left_right_pos);
						}
					}
				} else if (v__ast__Expr_is_auto_deref_var(node->left) || v__ast__Expr_is_auto_deref_var(node->right)) {
					v__ast__Type deref_left_type = (v__ast__Expr_is_auto_deref_var(node->left) ? (v__ast__Type_deref(left_type)) : (left_type));
					v__ast__Type deref_right_type = (v__ast__Expr_is_auto_deref_var(node->right) ? (v__ast__Type_deref(right_type)) : (right_type));
					string left_name = v__ast__Table_type_to_str(c->table, v__ast__mktyp(deref_left_type));
					string right_name = v__ast__Table_type_to_str(c->table, v__ast__mktyp(deref_right_type));
					if (!string__eq(left_name, right_name)) {
						v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("mismatched types `"), 0xfe10, {.d_s = left_name}}, {_SLIT("` and `"), 0xfe10, {.d_s = right_name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), left_right_pos);
					}
				} else {
					v__ast__Type unaliased_left_type = v__ast__Table_unalias_num_type(c->table, left_type);
					v__ast__Type unalias_right_type = v__ast__Table_unalias_num_type(c->table, right_type);
					v__ast__Type promoted_type = v__checker__Checker_promote(c, unaliased_left_type, unalias_right_type);
					bool is_allowed_pointer_arithmetic = v__ast__Type_is_any_kind_of_pointer(left_type) && v__ast__Type_is_any_kind_of_pointer(right_type) && node->op == v__token__Kind__minus;
					if (is_allowed_pointer_arithmetic) {
						promoted_type = _const_v__ast__int_type;
					}
					if (v__ast__Type_idx(promoted_type) == _const_v__ast__void_type_idx) {
						string left_name = v__ast__Table_type_to_str(c->table, left_type);
						string right_name = v__ast__Table_type_to_str(c->table, right_type);
						v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("mismatched types `"), 0xfe10, {.d_s = left_name}}, {_SLIT("` and `"), 0xfe10, {.d_s = right_name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), left_right_pos);
					} else if (v__ast__Type_has_flag(promoted_type, v__ast__TypeFlag__optional)) {
						string s = v__ast__Table_type_to_str(c->table, promoted_type);
						v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = v__token__Kind_str(node->op)}}, {_SLIT("` cannot be used with `"), 0xfe10, {.d_s = s}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node->pos);
					} else if (v__ast__Type_is_float(promoted_type)) {
						if (node->op == v__token__Kind__mod || node->op == v__token__Kind__xor || node->op == v__token__Kind__amp || node->op == v__token__Kind__pipe) {
							string side = (v__ast__Type_alias_eq(left_type, promoted_type) ? (_SLIT("left")) : (_SLIT("right")));
							v__token__Position pos = (v__ast__Type_alias_eq(left_type, promoted_type) ? (left_pos) : (right_pos));
							string name = (v__ast__Type_alias_eq(left_type, promoted_type) ? (left_sym->name) : (right_sym->name));
							if (node->op == v__token__Kind__mod) {
								v__checker__Checker_error(c, _SLIT("float modulo not allowed, use math.fmod() instead"), pos);
							} else {
								v__checker__Checker_error(c,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = side}}, {_SLIT(" type of `"), 0xfe10, {.d_s = v__token__Kind_str(node->op)}}, {_SLIT("` cannot be non-integer type `"), 0xfe10, {.d_s = name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), pos);
							}
						}
					}
					if (node->op == v__token__Kind__div || node->op == v__token__Kind__mod) {
						v__checker__Checker_check_div_mod_by_zero(c, node->right, node->op);
					}
					return_type = promoted_type;
				}
			} break;
		case v__token__Kind__gt: 
		case v__token__Kind__lt: 
		case v__token__Kind__ge: 
		case v__token__Kind__le: 
			{
				if ((left_sym->kind == v__ast__Kind__array || left_sym->kind == v__ast__Kind__array_fixed) && (right_sym->kind == v__ast__Kind__array || right_sym->kind == v__ast__Kind__array_fixed)) {
					v__checker__Checker_error(c, _SLIT("only `==` and `!=` are defined on arrays"), node->pos);
				} else if (left_sym->kind == v__ast__Kind__struct_ && (/* as */ *(v__ast__Struct*)__as_cast((left_sym->info)._v__ast__Struct,(left_sym->info)._typ, 446) /*expected idx: 446, name: v.ast.Struct */ ).generic_types.len > 0) {
					v__ast__Type _t8 = _const_v__ast__bool_type;
					// Defer begin
					if (v__checker__Checker_infix_expr_defer_0) {
						c->expected_type = former_expected_type;
					}
					// Defer end
					return _t8;
				} else if (left_sym->kind == v__ast__Kind__struct_ && right_sym->kind == v__ast__Kind__struct_ && (node->op == v__token__Kind__eq || node->op == v__token__Kind__lt)) {
					if (!(v__ast__TypeSymbol_has_method(left_sym, v__token__Kind_str(node->op)) && v__ast__TypeSymbol_has_method(right_sym, v__token__Kind_str(node->op)))) {
						string left_name = v__ast__Table_type_to_str(c->table, left_type);
						string right_name = v__ast__Table_type_to_str(c->table, right_type);
						if (string__eq(left_name, right_name)) {
							v__checker__Checker_error(c,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("undefined operation `"), 0xfe10, {.d_s = left_name}}, {_SLIT("` "), 0xfe10, {.d_s = v__token__Kind_str(node->op)}}, {_SLIT(" `"), 0xfe10, {.d_s = right_name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), left_right_pos);
						} else {
							v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("mismatched types `"), 0xfe10, {.d_s = left_name}}, {_SLIT("` and `"), 0xfe10, {.d_s = right_name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), left_right_pos);
						}
					}
				}
				if (left_sym->kind == v__ast__Kind__struct_ && right_sym->kind == v__ast__Kind__struct_) {
					if (!v__ast__TypeSymbol_has_method(left_sym, _SLIT("<")) && (node->op == v__token__Kind__ge || node->op == v__token__Kind__le)) {
						v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot use `"), 0xfe10, {.d_s = v__token__Kind_str(node->op)}}, {_SLIT("` as `<` operator method is not defined"), 0, { .d_c = 0 }}})), left_right_pos);
					} else if (!v__ast__TypeSymbol_has_method(left_sym, _SLIT("<")) && node->op == v__token__Kind__gt) {
						v__checker__Checker_error(c, _SLIT("cannot use `>` as `<=` operator method is not defined"), left_right_pos);
					}
				}
			} break;
		case v__token__Kind__left_shift: 
			{
				if (left_final->kind == v__ast__Kind__array) {
					if (!node->is_stmt) {
						v__checker__Checker_error(c, _SLIT("array append cannot be used in an expression"), node->pos);
					}
					v__checker__Checker_check_expr_opt_call(c, node->right, right_type);
					multi_return_string_v__token__Position mr_29089 = v__checker__Checker_fail_if_immutable(c, node->left);
					node->auto_locked = mr_29089.arg0;
					v__ast__Type left_value_type = v__ast__Table_value_type(c->table, v__checker__Checker_unwrap_generic(c, left_type));
					v__ast__TypeSymbol* left_value_sym = v__ast__Table_sym(c->table, v__checker__Checker_unwrap_generic(c, left_value_type));
					if (left_value_sym->kind == v__ast__Kind__interface_) {
						if (right_final->kind != v__ast__Kind__array) {
							if (v__checker__Checker_type_implements(c, right_type, left_value_type, right_pos)) {
								if (!v__ast__Type_is_ptr(right_type) && !v__ast__Type_is_pointer(right_type) && !c->inside_unsafe && right_sym->kind != v__ast__Kind__interface_) {
									v__checker__Checker_mark_as_referenced(c, &node->right, true);
								}
							}
						} else {
							v__checker__Checker_type_implements(c, v__ast__Table_value_type(c->table, right_type), left_value_type, right_pos);
						}
						v__ast__Type _t9 = _const_v__ast__void_type;
						// Defer begin
						if (v__checker__Checker_infix_expr_defer_0) {
							c->expected_type = former_expected_type;
						}
						// Defer end
						return _t9;
					}
					v__ast__Type unwrapped_right_type = v__checker__Checker_unwrap_generic(c, right_type);
					if (v__checker__Checker_check_types(c, unwrapped_right_type, left_value_type)) {
						if (!(!v__ast__Type_is_ptr(unwrapped_right_type) && v__ast__Type_is_ptr(left_value_type) && v__ast__Type_share(left_value_type) == v__ast__ShareType__mut_t)) {
							v__ast__Type _t10 = _const_v__ast__void_type;
							// Defer begin
							if (v__checker__Checker_infix_expr_defer_0) {
								c->expected_type = former_expected_type;
							}
							// Defer end
							return _t10;
						}
					} else if (v__checker__Checker_check_types(c, unwrapped_right_type, v__checker__Checker_unwrap_generic(c, left_type))) {
						v__ast__Type _t11 = _const_v__ast__void_type;
						// Defer begin
						if (v__checker__Checker_infix_expr_defer_0) {
							c->expected_type = former_expected_type;
						}
						// Defer end
						return _t11;
					}
					v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("cannot append `"), 0xfe10, {.d_s = right_sym->name}}, {_SLIT("` to `"), 0xfe10, {.d_s = left_sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), right_pos);
					v__ast__Type _t12 = _const_v__ast__void_type;
					// Defer begin
					if (v__checker__Checker_infix_expr_defer_0) {
						c->expected_type = former_expected_type;
					}
					// Defer end
					return _t12;
				} else {
					v__ast__Type _t13 = v__checker__Checker_check_shift(c, node, left_type, right_type);
					// Defer begin
					if (v__checker__Checker_infix_expr_defer_0) {
						c->expected_type = former_expected_type;
					}
					// Defer end
					return _t13;
				}
			} break;
		case v__token__Kind__right_shift: 
			{
				v__ast__Type _t14 = v__checker__Checker_check_shift(c, node, left_type, right_type);
				// Defer begin
				if (v__checker__Checker_infix_expr_defer_0) {
					c->expected_type = former_expected_type;
				}
				// Defer end
				return _t14;
			} break;
		case v__token__Kind__unsigned_right_shift: 
			{
				int _t15; /* if prepend */
				if (!v__ast__Type_is_int(left_type)) {
					v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("invalid operation: shift on type `"), 0xfe10, {.d_s = v__ast__Table_sym(c->table, left_type)->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), left_pos);
					_t15 = _const_v__ast__void_type_idx;
				} else if (v__ast__Type_is_int_literal(left_type)) {
					_t15 = _const_v__ast__u32_type_idx;
				} else if (v__ast__Type_is_unsigned(left_type)) {
					_t15 = left_type;
				} else {
					_t15 = v__ast__Type_idx(left_type) + _const_v__ast__u32_type_idx - _const_v__ast__int_type_idx;
				}
				int modified_left_type =  _t15;
				if (modified_left_type == 0) {
					v__ast__Type _t16 = _const_v__ast__void_type;
					// Defer begin
					if (v__checker__Checker_infix_expr_defer_0) {
						c->expected_type = former_expected_type;
					}
					// Defer end
					return _t16;
				}
				*node = (v__ast__InfixExpr){
					.op = v__token__Kind__right_shift,
					.pos = node->pos,
					.is_stmt = false,
					.left = v__ast__CastExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__CastExpr, ((v__ast__CastExpr){.arg = {0},.typ = modified_left_type,.expr = node->left,.typname = v__ast__Table_type_str(c->table, modified_left_type),.expr_type = 0,.has_arg = 0,.pos = node->pos,}))),
					.right = node->right,
					.left_type = left_type,
					.right_type = right_type,
					.auto_locked = node->auto_locked,
					.or_block = node->or_block,
					.ct_left_value_evaled = 0,
					.ct_left_value = v__ast__empty_comptime_const_expr(),
					.ct_right_value_evaled = 0,
					.ct_right_value = v__ast__empty_comptime_const_expr(),
				};
				v__ast__Type _t17 = v__checker__Checker_check_shift(c, node, left_type, right_type);
				// Defer begin
				if (v__checker__Checker_infix_expr_defer_0) {
					c->expected_type = former_expected_type;
				}
				// Defer end
				return _t17;
			} break;
		case v__token__Kind__key_is: 
		case v__token__Kind__not_is: 
			{
				v__ast__Expr right_expr = node->right;
				v__ast__Type _t18 = 0;
				if (right_expr._typ == 325 /* v.ast.TypeNode */) {
					_t18 = (*right_expr._v__ast__TypeNode).typ;
				}
				else if (right_expr._typ == 311 /* v.ast.None */) {
					_t18 = _const_v__ast__none_type_idx;
				}
				
				else {
					v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("invalid type `"), 0xfe10, {.d_s = v__ast__Expr_str(right_expr)}}, {_SLIT("`"), 0, { .d_c = 0 }}})), v__ast__Expr_position(right_expr));
					_t18 = ((v__ast__Type)(0));
				}
				v__ast__Type typ = _t18;
				if (!v__ast__Type_alias_eq(typ, ((v__ast__Type)(0)))) {
					v__ast__TypeSymbol* typ_sym = v__ast__Table_sym(c->table, typ);
					string op = v__token__Kind_str(node->op);
					if (typ_sym->kind == v__ast__Kind__placeholder) {
						v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = op}}, {_SLIT(": type `"), 0xfe10, {.d_s = typ_sym->name}}, {_SLIT("` does not exist"), 0, { .d_c = 0 }}})), v__ast__Expr_position(right_expr));
					}
					if (!(left_sym->kind == v__ast__Kind__interface_ || left_sym->kind == v__ast__Kind__sum_type)) {
						v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = op}}, {_SLIT("` can only be used with interfaces and sum types"), 0, { .d_c = 0 }}})), node->pos);
					} else if ((left_sym->info)._typ == 464 /* v.ast.SumType */) {
						if (!Array_v__ast__Type_contains((*left_sym->info._v__ast__SumType).variants, typ)) {
							v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = left_sym->name}}, {_SLIT("` has no variant `"), 0xfe10, {.d_s = right_sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node->pos);
						}
					}
				}
				v__ast__Type _t19 = _const_v__ast__bool_type;
				// Defer begin
				if (v__checker__Checker_infix_expr_defer_0) {
					c->expected_type = former_expected_type;
				}
				// Defer end
				return _t19;
			} break;
		case v__token__Kind__arrow: 
			{
				if (left_sym->kind == v__ast__Kind__chan) {
					v__ast__Chan chan_info = v__ast__TypeSymbol_chan_info(left_sym);
					v__ast__Type elem_type = chan_info.elem_type;
					if (!v__checker__Checker_check_types(c, right_type, elem_type)) {
						v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("cannot push `"), 0xfe10, {.d_s = right_sym->name}}, {_SLIT("` on `"), 0xfe10, {.d_s = left_sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), right_pos);
					}
					if (chan_info.is_mut) {
						v__checker__Checker_fail_if_immutable(c, node->right);
					}
					if (v__ast__Type_is_ptr(elem_type) && !v__ast__Type_is_ptr(right_type)) {
						v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("cannot push non-reference `"), 0xfe10, {.d_s = right_sym->name}}, {_SLIT("` on `"), 0xfe10, {.d_s = left_sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), right_pos);
					}
					v__checker__Checker_stmts_ending_with_expression(c, node->or_block.stmts);
				} else {
					v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot push on non-channel `"), 0xfe10, {.d_s = left_sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), left_pos);
				}
				v__ast__Type _t20 = _const_v__ast__void_type;
				// Defer begin
				if (v__checker__Checker_infix_expr_defer_0) {
					c->expected_type = former_expected_type;
				}
				// Defer end
				return _t20;
			} break;
		case v__token__Kind__and: 
		case v__token__Kind__logical_or: 
			{
				if (!c->pref->translated) {
					if (node->left_type != _const_v__ast__bool_type_idx) {
						v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("left operand for `"), 0xfe10, {.d_s = v__token__Kind_str(node->op)}}, {_SLIT("` is not a boolean"), 0, { .d_c = 0 }}})), v__ast__Expr_position(node->left));
					}
					if (node->right_type != _const_v__ast__bool_type_idx) {
						v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("right operand for `"), 0xfe10, {.d_s = v__token__Kind_str(node->op)}}, {_SLIT("` is not a boolean"), 0, { .d_c = 0 }}})), v__ast__Expr_position(node->right));
					}
				}
				if ((node->left)._typ == 303 /* v.ast.InfixExpr */) {
					if ((*node->left._v__ast__InfixExpr).op != node->op && ((*node->left._v__ast__InfixExpr).op == v__token__Kind__logical_or || (*node->left._v__ast__InfixExpr).op == v__token__Kind__and)) {
						v__checker__Checker_error(c, _SLIT("ambiguous boolean expression. use `()` to ensure correct order of operations"), node->pos);
					}
				}
			} break;
		case v__token__Kind__unknown:
		case v__token__Kind__eof:
		case v__token__Kind__name:
		case v__token__Kind__number:
		case v__token__Kind__string:
		case v__token__Kind__str_inter:
		case v__token__Kind__chartoken:
		case v__token__Kind__inc:
		case v__token__Kind__dec:
		case v__token__Kind__not:
		case v__token__Kind__bit_not:
		case v__token__Kind__question:
		case v__token__Kind__comma:
		case v__token__Kind__semicolon:
		case v__token__Kind__colon:
		case v__token__Kind__hash:
		case v__token__Kind__dollar:
		case v__token__Kind__at:
		case v__token__Kind__str_dollar:
		case v__token__Kind__assign:
		case v__token__Kind__decl_assign:
		case v__token__Kind__plus_assign:
		case v__token__Kind__minus_assign:
		case v__token__Kind__div_assign:
		case v__token__Kind__mult_assign:
		case v__token__Kind__xor_assign:
		case v__token__Kind__mod_assign:
		case v__token__Kind__or_assign:
		case v__token__Kind__and_assign:
		case v__token__Kind__right_shift_assign:
		case v__token__Kind__left_shift_assign:
		case v__token__Kind__unsigned_right_shift_assign:
		case v__token__Kind__lcbr:
		case v__token__Kind__rcbr:
		case v__token__Kind__lpar:
		case v__token__Kind__rpar:
		case v__token__Kind__lsbr:
		case v__token__Kind__nilsbr:
		case v__token__Kind__rsbr:
		case v__token__Kind__comment:
		case v__token__Kind__nl:
		case v__token__Kind__dot:
		case v__token__Kind__dotdot:
		case v__token__Kind__ellipsis:
		case v__token__Kind__keyword_beg:
		case v__token__Kind__key_as:
		case v__token__Kind__key_asm:
		case v__token__Kind__key_assert:
		case v__token__Kind__key_atomic:
		case v__token__Kind__key_break:
		case v__token__Kind__key_const:
		case v__token__Kind__key_continue:
		case v__token__Kind__key_defer:
		case v__token__Kind__key_else:
		case v__token__Kind__key_enum:
		case v__token__Kind__key_false:
		case v__token__Kind__key_for:
		case v__token__Kind__key_fn:
		case v__token__Kind__key_global:
		case v__token__Kind__key_go:
		case v__token__Kind__key_goto:
		case v__token__Kind__key_if:
		case v__token__Kind__key_import:
		case v__token__Kind__key_interface:
		case v__token__Kind__key_match:
		case v__token__Kind__key_module:
		case v__token__Kind__key_mut:
		case v__token__Kind__key_shared:
		case v__token__Kind__key_lock:
		case v__token__Kind__key_rlock:
		case v__token__Kind__key_none:
		case v__token__Kind__key_return:
		case v__token__Kind__key_select:
		case v__token__Kind__key_sizeof:
		case v__token__Kind__key_isreftype:
		case v__token__Kind__key_likely:
		case v__token__Kind__key_unlikely:
		case v__token__Kind__key_offsetof:
		case v__token__Kind__key_struct:
		case v__token__Kind__key_true:
		case v__token__Kind__key_type:
		case v__token__Kind__key_typeof:
		case v__token__Kind__key_dump:
		case v__token__Kind__key_orelse:
		case v__token__Kind__key_union:
		case v__token__Kind__key_pub:
		case v__token__Kind__key_static:
		case v__token__Kind__key_volatile:
		case v__token__Kind__key_unsafe:
		case v__token__Kind__keyword_end:
		case v__token__Kind___end_:
		default:
			{
			} break;
	}
	;
	if (v__ast__Type_alias_eq(left_type, _const_v__ast__bool_type) && !(node->op == v__token__Kind__eq || node->op == v__token__Kind__ne || node->op == v__token__Kind__logical_or || node->op == v__token__Kind__and)) {
		v__checker__Checker_error(c, _SLIT("bool types only have the following operators defined: `==`, `!=`, `||`, and `&&`"), node->pos);
	} else if (v__ast__Type_alias_eq(left_type, _const_v__ast__string_type) && !(node->op == v__token__Kind__plus || node->op == v__token__Kind__eq || node->op == v__token__Kind__ne || node->op == v__token__Kind__lt || node->op == v__token__Kind__gt || node->op == v__token__Kind__le || node->op == v__token__Kind__ge)) {
		v__checker__Checker_error(c, _SLIT("string types only have the following operators defined: `==`, `!=`, `<`, `>`, `<=`, `>=`, and `+`"), node->pos);
	} else if (left_sym->kind == v__ast__Kind__enum_ && right_sym->kind == v__ast__Kind__enum_ && !eq_ne) {
		v__ast__Enum left_enum = /* as */ *(v__ast__Enum*)__as_cast((left_sym->info)._v__ast__Enum,(left_sym->info)._typ, 474) /*expected idx: 474, name: v.ast.Enum */ ;
		v__ast__Enum right_enum = /* as */ *(v__ast__Enum*)__as_cast((right_sym->info)._v__ast__Enum,(right_sym->info)._typ, 474) /*expected idx: 474, name: v.ast.Enum */ ;
		if (left_enum.is_flag && right_enum.is_flag) {
			if (!(node->op == v__token__Kind__pipe || node->op == v__token__Kind__amp)) {
				v__checker__Checker_error(c, _SLIT("only `==`, `!=`, `|` and `&` are defined on `[flag]` tagged `enum`, use an explicit cast to `int` if needed"), node->pos);
			}
		} else if (!c->pref->translated) {
			v__checker__Checker_error(c, _SLIT("only `==` and `!=` are defined on `enum`, use an explicit cast to `int` if needed"), node->pos);
		}
	}
	if (v__ast__Table_type_kind(c->table, left_type) == v__ast__Kind__sum_type && !eq_ne) {
		v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("cannot use operator `"), 0xfe10, {.d_s = v__token__Kind_str(node->op)}}, {_SLIT("` with `"), 0xfe10, {.d_s = left_sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node->pos);
	} else if (v__ast__Table_type_kind(c->table, right_type) == v__ast__Kind__sum_type && !eq_ne) {
		v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("cannot use operator `"), 0xfe10, {.d_s = v__token__Kind_str(node->op)}}, {_SLIT("` with `"), 0xfe10, {.d_s = right_sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node->pos);
	}
	bool left_is_optional = v__ast__Type_has_flag(left_type, v__ast__TypeFlag__optional);
	bool right_is_optional = v__ast__Type_has_flag(right_type, v__ast__TypeFlag__optional);
	if ((left_is_optional && !right_is_optional) || (!left_is_optional && right_is_optional)) {
		v__checker__Checker_error(c, _SLIT("unwrapped optional cannot be used in an infix expression"), left_right_pos);
	}
	if (!(v__checker__Checker_symmetric_check(c, left_type, right_type) && v__checker__Checker_symmetric_check(c, right_type, left_type)) && !c->pref->translated && !v__ast__Expr_is_auto_deref_var(node->left) && !v__ast__Expr_is_auto_deref_var(node->right)) {
		if (v__ast__Type_alias_eq(left_type, _const_v__ast__void_type) || v__ast__Type_alias_eq(right_type, _const_v__ast__void_type)) {
			v__ast__Type _t21 = _const_v__ast__void_type;
			// Defer begin
			if (v__checker__Checker_infix_expr_defer_0) {
				c->expected_type = former_expected_type;
			}
			// Defer end
			return _t21;
		}
		if (v__ast__Type_nr_muls(left_type) > 0 && v__ast__Type_is_int(right_type)) {
			v__ast__Type _t22 = return_type;
			// Defer begin
			if (v__checker__Checker_infix_expr_defer_0) {
				c->expected_type = former_expected_type;
			}
			// Defer end
			return _t22;
		}
		v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("infix expr: cannot use `"), 0xfe10, {.d_s = right_sym->name}}, {_SLIT("` (right expression) as `"), 0xfe10, {.d_s = left_sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), left_right_pos);
	}
	v__ast__Type _t23 = (v__token__Kind_is_relational(node->op) ? (_const_v__ast__bool_type) : (return_type));
	// Defer begin
	if (v__checker__Checker_infix_expr_defer_0) {
		c->expected_type = former_expected_type;
	}
	// Defer end
	return _t23;
}

VV_LOCAL_SYMBOL multi_return_string_v__token__Position v__checker__Checker_fail_if_immutable(v__checker__Checker* c, v__ast__Expr expr) {
	string to_lock = _SLIT("");
	v__token__Position pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,};
	bool explicit_lock_needed = false;
	if (expr._typ == 287 /* v.ast.CastExpr */) {
		return (multi_return_string_v__token__Position){.arg0=_SLIT(""), .arg1=pos};
	}
	else if (expr._typ == 292 /* v.ast.ComptimeSelector */) {
		return (multi_return_string_v__token__Position){.arg0=_SLIT(""), .arg1=pos};
	}
	else if (expr._typ == 299 /* v.ast.Ident */) {
		if (((*expr._v__ast__Ident).obj)._typ == 357 /* v.ast.Var */) {
			v__ast__Var v = /* as */ *(v__ast__Var*)__as_cast(((*expr._v__ast__Ident).obj)._v__ast__Var,((*expr._v__ast__Ident).obj)._typ, 357) /*expected idx: 357, name: v.ast.Var */ ;
			if (!v.is_mut && !c->pref->translated && !c->inside_unsafe) {
				v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = (*expr._v__ast__Ident).name}}, {_SLIT("` is immutable, declare it with `mut` to make it mutable"), 0, { .d_c = 0 }}})), (*expr._v__ast__Ident).pos);
			}
			v.is_changed = true;
			if (v__ast__Type_share(v.typ) == v__ast__ShareType__shared_t) {
				if (!Array_string_contains(c->locked_names, (*expr._v__ast__Ident).name)) {
					if (c->locked_names.len > 0 || c->rlocked_names.len > 0) {
						if (Array_string_contains(c->rlocked_names, (*expr._v__ast__Ident).name)) {
							v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = (*expr._v__ast__Ident).name}}, {_SLIT(" has an `rlock` but needs a `lock`"), 0, { .d_c = 0 }}})), (*expr._v__ast__Ident).pos);
						} else {
							v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = (*expr._v__ast__Ident).name}}, {_SLIT(" must be added to the `lock` list above"), 0, { .d_c = 0 }}})), (*expr._v__ast__Ident).pos);
						}
					}
					to_lock = (*expr._v__ast__Ident).name;
					pos = (*expr._v__ast__Ident).pos;
				}
			}
		} else if (((*expr._v__ast__Ident).obj)._typ == 355 /* v.ast.ConstField */ && Array_string_contains(c->const_names, (*expr._v__ast__Ident).name)) {
			if (!c->inside_unsafe) {
				v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot modify constant `"), 0xfe10, {.d_s = (*expr._v__ast__Ident).name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), (*expr._v__ast__Ident).pos);
			}
		}
	}
	else if (expr._typ == 302 /* v.ast.IndexExpr */) {
		v__ast__TypeSymbol* left_sym = v__ast__Table_sym(c->table, (*expr._v__ast__IndexExpr).left_type);
		v__ast__Type elem_type = ((v__ast__Type)(0));
		string kind = _SLIT("");
		if (left_sym->info._typ == 441 /* v.ast.Array */) {
			elem_type = (*left_sym->info._v__ast__Array).elem_type;
			kind = _SLIT("array");
		}
		else if (left_sym->info._typ == 468 /* v.ast.ArrayFixed */) {
			elem_type = (*left_sym->info._v__ast__ArrayFixed).elem_type;
			kind = _SLIT("fixed array");
		}
		else if (left_sym->info._typ == 442 /* v.ast.Map */) {
			elem_type = (*left_sym->info._v__ast__Map).value_type;
			kind = _SLIT("map");
		}
		
		else {
		}
		;
		if (v__ast__Type_has_flag(elem_type, v__ast__TypeFlag__shared_f)) {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("you have to create a handle and `lock` it to modify `shared` "), 0xfe10, {.d_s = kind}}, {_SLIT(" element"), 0, { .d_c = 0 }}})), v__token__Position_extend(v__ast__Expr_position((*expr._v__ast__IndexExpr).left), (*expr._v__ast__IndexExpr).pos));
		}
		multi_return_string_v__token__Position mr_38676 = v__checker__Checker_fail_if_immutable(c, (*expr._v__ast__IndexExpr).left);
		to_lock = mr_38676.arg0;
		pos = mr_38676.arg1;
	}
	else if (expr._typ == 314 /* v.ast.ParExpr */) {
		multi_return_string_v__token__Position mr_38745 = v__checker__Checker_fail_if_immutable(c, (*expr._v__ast__ParExpr).expr);
		to_lock = mr_38745.arg0;
		pos = mr_38745.arg1;
	}
	else if (expr._typ == 316 /* v.ast.PrefixExpr */) {
		multi_return_string_v__token__Position mr_38817 = v__checker__Checker_fail_if_immutable(c, (*expr._v__ast__PrefixExpr).right);
		to_lock = mr_38817.arg0;
		pos = mr_38817.arg1;
	}
	else if (expr._typ == 319 /* v.ast.SelectorExpr */) {
		if ((*expr._v__ast__SelectorExpr).expr_type == 0) {
			return (multi_return_string_v__token__Position){.arg0=_SLIT(""), .arg1=pos};
		}
		Option_void _t4 = v__checker__Checker_ensure_type_exists(c, (*expr._v__ast__SelectorExpr).expr_type, (*expr._v__ast__SelectorExpr).pos);
		if (_t4.state != 0 && _t4.err._typ != _IError_None___index) {
			IError err = _t4.err;
			return (multi_return_string_v__token__Position){.arg0=_SLIT(""), .arg1=pos};
		}
		
 ;
		v__ast__TypeSymbol* typ_sym = v__ast__Table_final_sym(c->table, v__checker__Checker_unwrap_generic(c, (*expr._v__ast__SelectorExpr).expr_type));
		switch (typ_sym->kind) {
			case v__ast__Kind__struct_: 
				{
					bool has_field = true;
					Option_v__ast__StructField _t6 = v__ast__Table_find_field_with_embeds(c->table, typ_sym, (*expr._v__ast__SelectorExpr).field_name);
					if (_t6.state != 0) { /*or block*/ 
						IError err = _t6.err;
						has_field = false;
						*(v__ast__StructField*) _t6.data = (v__ast__StructField){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.has_default_expr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_pub = 0,.default_val = (string){.str=(byteptr)"", .is_lit=1},.is_mut = 0,.is_global = 0,.is_volatile = 0,.default_expr = {0},.default_expr_typ = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,};
					}
					
 					v__ast__StructField field_info =  (*(v__ast__StructField*)_t6.data);
					if (!has_field) {
						string type_str = v__ast__Table_type_to_str(c->table, (*expr._v__ast__SelectorExpr).expr_type);
						v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("unknown field `"), 0xfe10, {.d_s = type_str}}, {_SLIT("."), 0xfe10, {.d_s = (*expr._v__ast__SelectorExpr).field_name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), (*expr._v__ast__SelectorExpr).pos);
						return (multi_return_string_v__token__Position){.arg0=_SLIT(""), .arg1=pos};
					}
					if (v__ast__Type_has_flag(field_info.typ, v__ast__TypeFlag__shared_f)) {
						string expr_name =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__ast__Expr_str((*expr._v__ast__SelectorExpr).expr)}}, {_SLIT("."), 0xfe10, {.d_s = (*expr._v__ast__SelectorExpr).field_name}}, {_SLIT0, 0, { .d_c = 0 }}}));
						if (!Array_string_contains(c->locked_names, expr_name)) {
							if (c->locked_names.len > 0 || c->rlocked_names.len > 0) {
								if (Array_string_contains(c->rlocked_names, expr_name)) {
									v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = expr_name}}, {_SLIT(" has an `rlock` but needs a `lock`"), 0, { .d_c = 0 }}})), (*expr._v__ast__SelectorExpr).pos);
								} else {
									v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = expr_name}}, {_SLIT(" must be added to the `lock` list above"), 0, { .d_c = 0 }}})), (*expr._v__ast__SelectorExpr).pos);
								}
								return (multi_return_string_v__token__Position){.arg0=_SLIT(""), .arg1=(*expr._v__ast__SelectorExpr).pos};
							}
							to_lock = expr_name;
							pos = (*expr._v__ast__SelectorExpr).pos;
						}
					} else {
						if (!field_info.is_mut && !c->pref->translated) {
							string type_str = v__ast__Table_type_to_str(c->table, (*expr._v__ast__SelectorExpr).expr_type);
							v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("field `"), 0xfe10, {.d_s = (*expr._v__ast__SelectorExpr).field_name}}, {_SLIT("` of struct `"), 0xfe10, {.d_s = type_str}}, {_SLIT("` is immutable"), 0, { .d_c = 0 }}})), (*expr._v__ast__SelectorExpr).pos);
						}
						multi_return_string_v__token__Position mr_40256 = v__checker__Checker_fail_if_immutable(c, (*expr._v__ast__SelectorExpr).expr);
						to_lock = mr_40256.arg0;
						pos = mr_40256.arg1;
					}
					if ((to_lock).len != 0) {
						explicit_lock_needed = true;
					}
				} break;
			case v__ast__Kind__interface_: 
				{
					v__ast__Interface interface_info = /* as */ *(v__ast__Interface*)__as_cast((typ_sym->info)._v__ast__Interface,(typ_sym->info)._typ, 463) /*expected idx: 463, name: v.ast.Interface */ ;
					Option_v__ast__StructField _t9 = v__ast__Interface_find_field(&interface_info, (*expr._v__ast__SelectorExpr).field_name);
					if (_t9.state != 0) { /*or block*/ 
						IError err = _t9.err;
						string type_str = v__ast__Table_type_to_str(c->table, (*expr._v__ast__SelectorExpr).expr_type);
						v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("unknown field `"), 0xfe10, {.d_s = type_str}}, {_SLIT("."), 0xfe10, {.d_s = (*expr._v__ast__SelectorExpr).field_name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), (*expr._v__ast__SelectorExpr).pos);
						return (multi_return_string_v__token__Position){.arg0=_SLIT(""), .arg1=pos};
					}
					
 					v__ast__StructField field_info =  (*(v__ast__StructField*)_t9.data);
					if (!field_info.is_mut) {
						string type_str = v__ast__Table_type_to_str(c->table, (*expr._v__ast__SelectorExpr).expr_type);
						v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("field `"), 0xfe10, {.d_s = (*expr._v__ast__SelectorExpr).field_name}}, {_SLIT("` of interface `"), 0xfe10, {.d_s = type_str}}, {_SLIT("` is immutable"), 0, { .d_c = 0 }}})), (*expr._v__ast__SelectorExpr).pos);
						return (multi_return_string_v__token__Position){.arg0=_SLIT(""), .arg1=(*expr._v__ast__SelectorExpr).pos};
					}
					v__checker__Checker_fail_if_immutable(c, (*expr._v__ast__SelectorExpr).expr);
				} break;
			case v__ast__Kind__sum_type: 
				{
					v__ast__SumType sumtype_info = /* as */ *(v__ast__SumType*)__as_cast((typ_sym->info)._v__ast__SumType,(typ_sym->info)._typ, 464) /*expected idx: 464, name: v.ast.SumType */ ;
					Option_v__ast__StructField _t12 = v__ast__SumType_find_field(&sumtype_info, (*expr._v__ast__SelectorExpr).field_name);
					if (_t12.state != 0) { /*or block*/ 
						IError err = _t12.err;
						string type_str = v__ast__Table_type_to_str(c->table, (*expr._v__ast__SelectorExpr).expr_type);
						v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("unknown field `"), 0xfe10, {.d_s = type_str}}, {_SLIT("."), 0xfe10, {.d_s = (*expr._v__ast__SelectorExpr).field_name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), (*expr._v__ast__SelectorExpr).pos);
						return (multi_return_string_v__token__Position){.arg0=_SLIT(""), .arg1=pos};
					}
					
 					v__ast__StructField field_info =  (*(v__ast__StructField*)_t12.data);
					if (!field_info.is_mut) {
						string type_str = v__ast__Table_type_to_str(c->table, (*expr._v__ast__SelectorExpr).expr_type);
						v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("field `"), 0xfe10, {.d_s = (*expr._v__ast__SelectorExpr).field_name}}, {_SLIT("` of sumtype `"), 0xfe10, {.d_s = type_str}}, {_SLIT("` is immutable"), 0, { .d_c = 0 }}})), (*expr._v__ast__SelectorExpr).pos);
						return (multi_return_string_v__token__Position){.arg0=_SLIT(""), .arg1=(*expr._v__ast__SelectorExpr).pos};
					}
					v__checker__Checker_fail_if_immutable(c, (*expr._v__ast__SelectorExpr).expr);
				} break;
			case v__ast__Kind__array: 
			case v__ast__Kind__string: 
				{
					bool inside_builtin = string__eq(c->file->mod.name, _SLIT("builtin"));
					if (!inside_builtin && !c->inside_unsafe) {
						v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = v__ast__Kind_str(typ_sym->kind)}}, {_SLIT("` can not be modified"), 0, { .d_c = 0 }}})), (*expr._v__ast__SelectorExpr).pos);
						return (multi_return_string_v__token__Position){.arg0=_SLIT(""), .arg1=(*expr._v__ast__SelectorExpr).pos};
					}
				} break;
			case v__ast__Kind__aggregate: 
			case v__ast__Kind__placeholder: 
				{
					v__checker__Checker_fail_if_immutable(c, (*expr._v__ast__SelectorExpr).expr);
				} break;
			case v__ast__Kind__void:
			case v__ast__Kind__voidptr:
			case v__ast__Kind__byteptr:
			case v__ast__Kind__charptr:
			case v__ast__Kind__i8:
			case v__ast__Kind__i16:
			case v__ast__Kind__int:
			case v__ast__Kind__i64:
			case v__ast__Kind__isize:
			case v__ast__Kind__byte:
			case v__ast__Kind__u8:
			case v__ast__Kind__u16:
			case v__ast__Kind__u32:
			case v__ast__Kind__u64:
			case v__ast__Kind__usize:
			case v__ast__Kind__f32:
			case v__ast__Kind__f64:
			case v__ast__Kind__char:
			case v__ast__Kind__rune:
			case v__ast__Kind__bool:
			case v__ast__Kind__none_:
			case v__ast__Kind__array_fixed:
			case v__ast__Kind__map:
			case v__ast__Kind__chan:
			case v__ast__Kind__any:
			case v__ast__Kind__generic_inst:
			case v__ast__Kind__multi_return:
			case v__ast__Kind__alias:
			case v__ast__Kind__enum_:
			case v__ast__Kind__function:
			case v__ast__Kind__float_literal:
			case v__ast__Kind__int_literal:
			case v__ast__Kind__thread:
			default:
				{
					v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unexpected symbol `"), 0xfe10, {.d_s = v__ast__Kind_str(typ_sym->kind)}}, {_SLIT("`"), 0, { .d_c = 0 }}})), (*expr._v__ast__SelectorExpr).pos);
					return (multi_return_string_v__token__Position){.arg0=_SLIT(""), .arg1=(*expr._v__ast__SelectorExpr).pos};
				} break;
		}
		;
	}
	else if (expr._typ == 286 /* v.ast.CallExpr */) {
		if (string__eq((*expr._v__ast__CallExpr).name, _SLIT("slice"))) {
			multi_return_string_v__token__Position mr_42079 = v__checker__Checker_fail_if_immutable(c, (*expr._v__ast__CallExpr).left);
			to_lock = mr_42079.arg0;
			pos = mr_42079.arg1;
			if ((to_lock).len != 0) {
				explicit_lock_needed = true;
			}
		}
	}
	else if (expr._typ == 280 /* v.ast.ArrayInit */) {
		v__checker__Checker_error(c, _SLIT("array literal can not be modified"), (*expr._v__ast__ArrayInit).pos);
		return (multi_return_string_v__token__Position){.arg0=_SLIT(""), .arg1=pos};
	}
	else if (expr._typ == 324 /* v.ast.StructInit */) {
		return (multi_return_string_v__token__Position){.arg0=_SLIT(""), .arg1=pos};
	}
	else if (expr._typ == 303 /* v.ast.InfixExpr */) {
		return (multi_return_string_v__token__Position){.arg0=_SLIT(""), .arg1=pos};
	}
	
	else {
		if (!v__ast__Expr_is_lit(expr)) {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unexpected expression `"), 0xfe10, {.d_s = charptr_vstring_literal( /* v.ast.Expr */ v_typeof_sumtype_v__ast__Expr( (expr)._typ ))}}, {_SLIT("`"), 0, { .d_c = 0 }}})), v__ast__Expr_position(expr));
			return (multi_return_string_v__token__Position){.arg0=_SLIT(""), .arg1=pos};
		}
	}
	;
	if (explicit_lock_needed) {
		v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = to_lock}}, {_SLIT("` is `shared` and needs explicit lock for `"), 0xfe10, {.d_s = charptr_vstring_literal( /* v.ast.Expr */ v_typeof_sumtype_v__ast__Expr( (expr)._typ ))}}, {_SLIT("`"), 0, { .d_c = 0 }}})), pos);
		to_lock = _SLIT("");
	}
	return (multi_return_string_v__token__Position){.arg0=to_lock, .arg1=pos};
}

VV_LOCAL_SYMBOL bool v__checker__Checker_type_implements(v__checker__Checker* c, v__ast__Type typ, v__ast__Type interface_type, v__token__Position pos) {
	if (v__ast__Type_alias_eq(typ, interface_type)) {
		bool _t1 = true;
		return _t1;
	}
	v__ast__Type utyp = v__checker__Checker_unwrap_generic(c, typ);
	v__ast__TypeSymbol* typ_sym = v__ast__Table_sym(c->table, utyp);
	v__ast__TypeSymbol* inter_sym = v__ast__Table_sym(c->table, interface_type);
	if (string__eq(typ_sym->name, _SLIT("JS.Any"))) {
		bool _t2 = true;
		return _t2;
	}
	if ((inter_sym->info)._typ == 463 /* v.ast.Interface */) {
		v__ast__Type generic_type = interface_type;
		v__ast__Interface generic_info = (*inter_sym->info._v__ast__Interface);
		if (v__ast__Type_has_flag((*inter_sym->info._v__ast__Interface).parent_type, v__ast__TypeFlag__generic)) {
			v__ast__TypeSymbol* parent_sym = v__ast__Table_sym(c->table, (*inter_sym->info._v__ast__Interface).parent_type);
			if ((parent_sym->info)._typ == 463 /* v.ast.Interface */) {
				generic_type = (*inter_sym->info._v__ast__Interface).parent_type;
				generic_info = (*parent_sym->info._v__ast__Interface);
			}
		}
		v__ast__Type inferred_type = interface_type;
		if (generic_info.is_generic) {
			inferred_type = v__checker__Checker_resolve_generic_interface(c, typ, generic_type, pos);
			if (inferred_type == 0) {
				bool _t3 = false;
				return _t3;
			}
		}
		if ((*inter_sym->info._v__ast__Interface).is_generic) {
			if (v__ast__Type_alias_eq(inferred_type, interface_type)) {
				bool _t4 = false;
				return _t4;
			}
			bool _t5 = v__checker__Checker_type_implements(c, typ, inferred_type, pos);
			return _t5;
		}
	}
	if ((inter_sym->info)._typ == 463 /* v.ast.Interface */) {
		for (int _t6 = 0; _t6 < (*inter_sym->info._v__ast__Interface).types.len; ++_t6) {
			v__ast__Type t = ((v__ast__Type*)(*inter_sym->info._v__ast__Interface).types.data)[_t6];
			if (v__ast__Type_idx(t) == v__ast__Type_idx(utyp)) {
				bool _t7 = true;
				return _t7;
			}
		}
	}
	string styp = v__ast__Table_type_to_str(c->table, utyp);
	if (v__ast__Type_idx(utyp) == v__ast__Type_idx(interface_type)) {
		bool _t8 = true;
		return _t8;
	}
	if (v__ast__Type_idx(interface_type) == _const_v__ast__error_type_idx && v__ast__Type_idx(utyp) == _const_v__ast__none_type_idx) {
		bool _t9 = true;
		return _t9;
	}
	if (typ_sym->kind == v__ast__Kind__interface_ && inter_sym->kind == v__ast__Kind__interface_ && !string_starts_with(styp, _SLIT("JS.")) && !string_starts_with(inter_sym->name, _SLIT("JS."))) {
		v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("cannot implement interface `"), 0xfe10, {.d_s = inter_sym->name}}, {_SLIT("` with a different interface `"), 0xfe10, {.d_s = styp}}, {_SLIT("`"), 0, { .d_c = 0 }}})), pos);
	}
	Array_v__ast__Fn imethods = (inter_sym->kind == v__ast__Kind__interface_ ? ((/* as */ *(v__ast__Interface*)__as_cast((inter_sym->info)._v__ast__Interface,(inter_sym->info)._typ, 463) /*expected idx: 463, name: v.ast.Interface */ ).methods) : (inter_sym->methods));
	if (!v__ast__Type_alias_eq(utyp, _const_v__ast__voidptr_type)) {
		for (int _t10 = 0; _t10 < imethods.len; ++_t10) {
			v__ast__Fn imethod = ((v__ast__Fn*)imethods.data)[_t10];
			Option_v__ast__Fn _t11 = v__ast__Table_find_method_with_embeds(c->table, typ_sym, imethod.name);
			if (_t11.state != 0) { /*or block*/ 
				IError err = _t11.err;
				Option_v__ast__Fn _t12 = v__ast__TypeSymbol_find_method_with_generic_parent(typ_sym, imethod.name);
				if (_t12.state != 0) { /*or block*/ 
					err = _t12.err;
					v__checker__Checker_error(c,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = styp}}, {_SLIT("` doesn't implement method `"), 0xfe10, {.d_s = imethod.name}}, {_SLIT("` of interface `"), 0xfe10, {.d_s = inter_sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), pos);
					continue;
				}
				
 				*(v__ast__Fn*) _t11.data =  (*(v__ast__Fn*)_t12.data);
			}
			
 			v__ast__Fn method =  (*(v__ast__Fn*)_t11.data);
			string msg = v__ast__Table_is_same_method(c->table, (voidptr)&/*qq*/imethod, (voidptr)&/*qq*/method);
			if (msg.len > 0) {
				string sig = v__ast__Table_fn_signature(c->table, (voidptr)&/*qq*/imethod, (v__ast__FnSignatureOpts){.skip_receiver = false,.type_only = 0,});
				string typ_sig = v__ast__Table_fn_signature(c->table, (voidptr)&/*qq*/method, (v__ast__FnSignatureOpts){.skip_receiver = false,.type_only = 0,});
				v__checker__Checker_add_error_detail(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = inter_sym->name}}, {_SLIT(" has `"), 0xfe10, {.d_s = sig}}, {_SLIT("`"), 0, { .d_c = 0 }}})));
				v__checker__Checker_add_error_detail(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("         "), 0xfe10, {.d_s = typ_sym->name}}, {_SLIT(" has `"), 0xfe10, {.d_s = typ_sig}}, {_SLIT("`"), 0, { .d_c = 0 }}})));
				v__checker__Checker_error(c,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = styp}}, {_SLIT("` incorrectly implements method `"), 0xfe10, {.d_s = imethod.name}}, {_SLIT("` of interface `"), 0xfe10, {.d_s = inter_sym->name}}, {_SLIT("`: "), 0xfe10, {.d_s = msg}}, {_SLIT0, 0, { .d_c = 0 }}})), pos);
				bool _t13 = false;
				return _t13;
			}
		}
	}
	if ((inter_sym->info)._typ == 463 /* v.ast.Interface */) {
		for (int _t14 = 0; _t14 < (*inter_sym->info._v__ast__Interface).fields.len; ++_t14) {
			v__ast__StructField ifield = ((v__ast__StructField*)(*inter_sym->info._v__ast__Interface).fields.data)[_t14];
			Option_v__ast__StructField _t15;
			if (_t15 = v__ast__Table_find_field_with_embeds(c->table, typ_sym, ifield.name), _t15.state == 0) {
				v__ast__StructField field = *(v__ast__StructField*)_t15.data;
				if (!v__ast__Type_alias_eq(ifield.typ, field.typ)) {
					string exp = v__ast__Table_type_to_str(c->table, ifield.typ);
					string got = v__ast__Table_type_to_str(c->table, field.typ);
					v__checker__Checker_error(c,  str_intp(6, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = styp}}, {_SLIT("` incorrectly implements field `"), 0xfe10, {.d_s = ifield.name}}, {_SLIT("` of interface `"), 0xfe10, {.d_s = inter_sym->name}}, {_SLIT("`, expected `"), 0xfe10, {.d_s = exp}}, {_SLIT("`, got `"), 0xfe10, {.d_s = got}}, {_SLIT("`"), 0, { .d_c = 0 }}})), pos);
					bool _t16 = false;
					return _t16;
				} else if (ifield.is_mut && !(field.is_mut || field.is_global)) {
					v__checker__Checker_error(c,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = styp}}, {_SLIT("` incorrectly implements interface `"), 0xfe10, {.d_s = inter_sym->name}}, {_SLIT("`, field `"), 0xfe10, {.d_s = ifield.name}}, {_SLIT("` must be mutable"), 0, { .d_c = 0 }}})), pos);
					bool _t17 = false;
					return _t17;
				}
				continue;
			}
			if (!v__ast__Type_alias_eq(utyp, _const_v__ast__voidptr_type)) {
				v__checker__Checker_error(c,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = styp}}, {_SLIT("` doesn't implement field `"), 0xfe10, {.d_s = ifield.name}}, {_SLIT("` of interface `"), 0xfe10, {.d_s = inter_sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), pos);
			}
		}
		array_push((array*)&(*inter_sym->info._v__ast__Interface).types, _MOV((v__ast__Type[]){ utyp }));
	}
	bool _t19 = true;
	return _t19;
}

v__ast__Type v__checker__Checker_check_expr_opt_call(v__checker__Checker* c, v__ast__Expr expr, v__ast__Type ret_type) {
	if ((expr)._typ == 286 /* v.ast.CallExpr */) {
		if (v__ast__Type_has_flag((*expr._v__ast__CallExpr).return_type, v__ast__TypeFlag__optional)) {
			if ((*expr._v__ast__CallExpr).or_block.kind == v__ast__OrKind__absent) {
				if (c->inside_defer) {
					v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = (*expr._v__ast__CallExpr).name}}, {_SLIT("() returns an option, so it should have an `or {}` block at the end"), 0, { .d_c = 0 }}})), (*expr._v__ast__CallExpr).pos);
				} else {
					v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = (*expr._v__ast__CallExpr).name}}, {_SLIT("() returns an option, so it should have either an `or {}` block, or `?` at the end"), 0, { .d_c = 0 }}})), (*expr._v__ast__CallExpr).pos);
				}
			} else {
				v__checker__Checker_check_or_expr(c, (*expr._v__ast__CallExpr).or_block, ret_type, v__ast__Type_clear_flag((*expr._v__ast__CallExpr).return_type, v__ast__TypeFlag__optional));
			}
			v__ast__Type _t1 = v__ast__Type_clear_flag(ret_type, v__ast__TypeFlag__optional);
			return _t1;
		} else if ((*expr._v__ast__CallExpr).or_block.kind == v__ast__OrKind__block) {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unexpected `or` block, the function `"), 0xfe10, {.d_s = (*expr._v__ast__CallExpr).name}}, {_SLIT("` does not return an optional"), 0, { .d_c = 0 }}})), (*expr._v__ast__CallExpr).or_block.pos);
		} else if ((*expr._v__ast__CallExpr).or_block.kind == v__ast__OrKind__propagate) {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unexpected `?`, the function `"), 0xfe10, {.d_s = (*expr._v__ast__CallExpr).name}}, {_SLIT("` does not return an optional"), 0, { .d_c = 0 }}})), (*expr._v__ast__CallExpr).or_block.pos);
		}
	} else if ((expr)._typ == 302 /* v.ast.IndexExpr */) {
		if ((*expr._v__ast__IndexExpr).or_expr.kind != v__ast__OrKind__absent) {
			v__checker__Checker_check_or_expr(c, (*expr._v__ast__IndexExpr).or_expr, ret_type, ret_type);
		}
	}
	v__ast__Type _t2 = ret_type;
	return _t2;
}

void v__checker__Checker_check_or_expr(v__checker__Checker* c, v__ast__OrExpr node, v__ast__Type ret_type, v__ast__Type expr_return_type) {
	if (node.kind == v__ast__OrKind__propagate) {
		if (!v__ast__Type_has_flag(c->table->cur_fn->return_type, v__ast__TypeFlag__optional) && !string__eq(c->table->cur_fn->name, _SLIT("main.main")) && !c->inside_const) {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("to propagate the optional call, `"), 0xfe10, {.d_s = c->table->cur_fn->name}}, {_SLIT("` must return an optional"), 0, { .d_c = 0 }}})), node.pos);
		}
		return;
	}
	int stmts_len = node.stmts.len;
	if (stmts_len == 0) {
		if (!v__ast__Type_alias_eq(ret_type, _const_v__ast__void_type)) {
			v__checker__Checker_error(c, _SLIT("assignment requires a non empty `or {}` block"), node.pos);
		}
		return;
	}
	v__ast__Stmt last_stmt = (*(v__ast__Stmt*)/*ee elem_typ */array_get(node.stmts, stmts_len - 1));
	if (!v__ast__Type_alias_eq(ret_type, _const_v__ast__void_type)) {
		if (last_stmt._typ == 339 /* v.ast.ExprStmt */) {
			c->expected_type = ret_type;
			c->expected_or_type = v__ast__Type_clear_flag(ret_type, v__ast__TypeFlag__optional);
			v__ast__Type last_stmt_typ = v__checker__Checker_expr(c, (*last_stmt._v__ast__ExprStmt).expr);
			c->expected_or_type = _const_v__ast__void_type;
			bool type_fits = v__checker__Checker_check_types(c, last_stmt_typ, ret_type) && v__ast__Type_nr_muls(last_stmt_typ) == v__ast__Type_nr_muls(ret_type);
			bool is_noreturn = v__checker__is_noreturn_callexpr((*last_stmt._v__ast__ExprStmt).expr);
			if (type_fits || is_noreturn) {
				return;
			}
			string expected_type_name = v__ast__Table_type_to_str(c->table, v__ast__Type_clear_flag(ret_type, v__ast__TypeFlag__optional));
			if (v__ast__Type_alias_eq((*last_stmt._v__ast__ExprStmt).typ, _const_v__ast__void_type)) {
				v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("`or` block must provide a default value of type `"), 0xfe10, {.d_s = expected_type_name}}, {_SLIT("`, or return/continue/break or call a [noreturn] function like panic(err) or exit(1)"), 0, { .d_c = 0 }}})), (*last_stmt._v__ast__ExprStmt).pos);
			} else {
				string type_name = v__ast__Table_type_to_str(c->table, last_stmt_typ);
				v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("wrong return type `"), 0xfe10, {.d_s = type_name}}, {_SLIT("` in the `or {}` block, expected `"), 0xfe10, {.d_s = expected_type_name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), (*last_stmt._v__ast__ExprStmt).pos);
			}
			return;
		}
		else if (last_stmt._typ == 333 /* v.ast.BranchStmt */) {
			if (!((*last_stmt._v__ast__BranchStmt).kind == v__token__Kind__key_continue || (*last_stmt._v__ast__BranchStmt).kind == v__token__Kind__key_break)) {
				v__checker__Checker_error(c, _SLIT("only break/continue is allowed as a branch statement in the end of an `or {}` block"), (*last_stmt._v__ast__BranchStmt).pos);
				return;
			}
		}
		else if (last_stmt._typ == 350 /* v.ast.Return */) {
		}
		
		else {
			string expected_type_name = v__ast__Table_type_to_str(c->table, v__ast__Type_clear_flag(ret_type, v__ast__TypeFlag__optional));
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("last statement in the `or {}` block should be an expression of type `"), 0xfe10, {.d_s = expected_type_name}}, {_SLIT("` or exit parent scope"), 0, { .d_c = 0 }}})), node.pos);
			return;
		}
		;
	} else {
		if (last_stmt._typ == 339 /* v.ast.ExprStmt */) {
			if (v__ast__Type_alias_eq((*last_stmt._v__ast__ExprStmt).typ, _const_v__ast__void_type)) {
				return;
			}
			if (v__checker__is_noreturn_callexpr((*last_stmt._v__ast__ExprStmt).expr)) {
				return;
			}
			if (v__checker__Checker_check_types(c, (*last_stmt._v__ast__ExprStmt).typ, expr_return_type)) {
				return;
			}
			string type_name = v__ast__Table_type_to_str(c->table, (*last_stmt._v__ast__ExprStmt).typ);
			string expr_return_type_name = v__ast__Table_type_to_str(c->table, expr_return_type);
			v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("the default expression type in the `or` block should be `"), 0xfe10, {.d_s = expr_return_type_name}}, {_SLIT("`, instead you gave a value of type `"), 0xfe10, {.d_s = type_name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), v__ast__Expr_position((*last_stmt._v__ast__ExprStmt).expr));
		}
		
		else {
		}
		;
	}
}

v__ast__Type v__checker__Checker_selector_expr(v__checker__Checker* c, v__ast__SelectorExpr* node) {
	bool prevent_sum_type_unwrapping_once = c->prevent_sum_type_unwrapping_once;
	c->prevent_sum_type_unwrapping_once = false;
	bool using_new_err_struct_save = c->using_new_err_struct;
	if (string__eq( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__ast__Expr_str(node->expr)}}, {_SLIT0, 0, { .d_c = 0 }}})), _SLIT("err"))) {
		c->using_new_err_struct = true;
	}
	int name_type = 0;
	if (node->expr._typ == 299 /* v.ast.Ident */) {
		string name = (*node->expr._v__ast__Ident).name;
		bool valid_generic = v__util__is_generic_type_name(name) && Array_string_contains(c->table->cur_fn->generic_names, name);
		if (valid_generic) {
			name_type = v__ast__Type_set_flag(((v__ast__Table_find_type_idx(c->table, name))), v__ast__TypeFlag__generic);
		}
	}
	else if (node->expr._typ == 326 /* v.ast.TypeOf */) {
		name_type = v__checker__Checker_expr(c, (*node->expr._v__ast__TypeOf).expr);
	}
	
	else {
	}
	;
	if (name_type > 0) {
		node->name_type = name_type;

		if (node->gkind_field == (v__ast__GenericKindField__name)) {
			v__ast__Type _t1 = _const_v__ast__string_type;
			return _t1;
		}
		else if (node->gkind_field == (v__ast__GenericKindField__typ)) {
			v__ast__Type _t2 = _const_v__ast__int_type;
			return _t2;
		}
		else {
			if (string__eq(node->field_name, _SLIT("name"))) {
				v__ast__Type _t3 = _const_v__ast__string_type;
				return _t3;
			} else if (string__eq(node->field_name, _SLIT("idx"))) {
				v__ast__Type _t4 = _const_v__ast__int_type;
				return _t4;
			}
			v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("invalid field `."), 0xfe10, {.d_s = node->field_name}}, {_SLIT("` for type `"), 0xfe10, {.d_s = v__ast__Expr_str(node->expr)}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node->pos);
			v__ast__Type _t5 = _const_v__ast__string_type;
			return _t5;
		};
	}
	bool old_selector_expr = c->inside_selector_expr;
	c->inside_selector_expr = true;
	v__ast__Type typ = v__checker__Checker_expr(c, node->expr);
	if (v__ast__Expr_is_auto_deref_var(node->expr)) {
		if ((node->expr)._typ == 299 /* v.ast.Ident */) {
			if (((*node->expr._v__ast__Ident).obj)._typ == 357 /* v.ast.Var */) {
				typ = (*(*node->expr._v__ast__Ident).obj._v__ast__Var).typ;
			}
		}
	}
	c->inside_selector_expr = old_selector_expr;
	c->using_new_err_struct = using_new_err_struct_save;
	if (typ == _const_v__ast__void_type_idx) {
		v__checker__Checker_error(c, _SLIT("`void` type has no fields"), node->pos);
		v__ast__Type _t6 = _const_v__ast__void_type;
		return _t6;
	}
	node->expr_type = typ;
	if (v__ast__Type_has_flag(node->expr_type, v__ast__TypeFlag__optional) && !((node->expr)._typ == 299 /* v.ast.Ident */ && (/* as */ *(v__ast__Ident*)__as_cast((node->expr)._v__ast__Ident,(node->expr)._typ, 299) /*expected idx: 299, name: v.ast.Ident */ ).kind == v__ast__IdentKind__constant)) {
		v__checker__Checker_error(c, _SLIT("cannot access fields of an optional, handle the error with `or {...}` or propagate it with `?`"), node->pos);
	}
	string field_name = node->field_name;
	v__ast__TypeSymbol* sym = v__ast__Table_sym(c->table, typ);
	if ((v__ast__Type_has_flag(typ, v__ast__TypeFlag__variadic) || sym->kind == v__ast__Kind__array_fixed) && string__eq(field_name, _SLIT("len"))) {
		node->typ = _const_v__ast__int_type;
		v__ast__Type _t7 = _const_v__ast__int_type;
		return _t7;
	}
	if (sym->kind == v__ast__Kind__chan) {
		if (string__eq(field_name, _SLIT("closed"))) {
			node->typ = _const_v__ast__bool_type;
			v__ast__Type _t8 = _const_v__ast__bool_type;
			return _t8;
		} else if (string__eq(field_name, _SLIT("len")) || string__eq(field_name, _SLIT("cap"))) {
			node->typ = _const_v__ast__u32_type;
			v__ast__Type _t9 = _const_v__ast__u32_type;
			return _t9;
		}
	}
	string unknown_field_msg =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("type `"), 0xfe10, {.d_s = sym->name}}, {_SLIT("` has no field named `"), 0xfe10, {.d_s = field_name}}, {_SLIT("`"), 0, { .d_c = 0 }}}));
	bool has_field = false;
	v__ast__StructField field = (v__ast__StructField){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.has_default_expr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_pub = 0,.default_val = (string){.str=(byteptr)"", .is_lit=1},.is_mut = 0,.is_global = 0,.is_volatile = 0,.default_expr = {0},.default_expr_typ = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,};
	if (field_name.len > 0 && byte_is_capital(string_at(field_name, 0)) && (sym->info)._typ == 446 /* v.ast.Struct */ && sym->language == v__ast__Language__v) {
		for (int _t10 = 0; _t10 < (*sym->info._v__ast__Struct).embeds.len; ++_t10) {
			v__ast__Type embed = ((v__ast__Type*)(*sym->info._v__ast__Struct).embeds.data)[_t10];
			v__ast__TypeSymbol* embed_sym = v__ast__Table_sym(c->table, embed);
			if (string__eq(v__ast__TypeSymbol_embed_name(embed_sym), field_name)) {
				node->typ = embed;
				v__ast__Type _t11 = embed;
				return _t11;
			}
		}
	} else {
		Option_v__ast__StructField _t12;
		if (_t12 = v__ast__Table_find_field(c->table, sym, field_name), _t12.state == 0) {
			v__ast__StructField f = *(v__ast__StructField*)_t12.data;
			has_field = true;
			field = f;
		} else {
			IError err = _t12.err;
			has_field = true;
			Array_v__ast__Type embed_types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
			Option_multi_return_v__ast__StructField_Array_v__ast__Type _t13 = v__ast__Table_find_field_from_embeds(c->table, sym, field_name);
			if (_t13.state != 0) { /*or block*/ 
				IError err = _t13.err;
				if (((*(err.msg))).len != 0) {
					v__checker__Checker_error(c, (*(err.msg)), node->pos);
				}
				has_field = false;
				*(multi_return_v__ast__StructField_Array_v__ast__Type*) _t13.data = (multi_return_v__ast__StructField_Array_v__ast__Type){.arg0=(v__ast__StructField){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.has_default_expr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_pub = 0,.default_val = (string){.str=(byteptr)"", .is_lit=1},.is_mut = 0,.is_global = 0,.is_volatile = 0,.default_expr = {0},.default_expr_typ = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,},.arg1=__new_array_with_default(0, 0, sizeof(v__ast__Type), 0)};
			}
			
 			Option_multi_return_v__ast__StructField_Array_v__ast__Type mr_53687 =  _t13 /*U*/;
			field = (*(multi_return_v__ast__StructField_Array_v__ast__Type*)mr_53687.data).arg0;
			embed_types = (*(multi_return_v__ast__StructField_Array_v__ast__Type*)mr_53687.data).arg1;
			node->from_embed_types = embed_types;
			if (sym->kind == v__ast__Kind__aggregate || sym->kind == v__ast__Kind__sum_type) {
				unknown_field_msg = (*(err.msg));
			}
		}
		if (!c->inside_unsafe) {
			if ((sym->info)._typ == 446 /* v.ast.Struct */) {
				if ((*sym->info._v__ast__Struct).is_union && !Array_v__token__Kind_contains(_const_v__token__assign_tokens, node->next_token)) {
					v__checker__Checker_warn(c, _SLIT("reading a union field (or its address) requires `unsafe`"), node->pos);
				}
			}
		}
		if (v__ast__Type_has_flag(typ, v__ast__TypeFlag__generic) && !has_field) {
			v__ast__TypeSymbol* gs = v__ast__Table_sym(c->table, v__checker__Checker_unwrap_generic(c, typ));
			Option_v__ast__StructField _t14;
			if (_t14 = v__ast__Table_find_field(c->table, gs, field_name), _t14.state == 0) {
				v__ast__StructField f = *(v__ast__StructField*)_t14.data;
				has_field = true;
				field = f;
			} else {
				IError err = _t14.err;
				has_field = true;
				Array_v__ast__Type embed_types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
				Option_multi_return_v__ast__StructField_Array_v__ast__Type _t15 = v__ast__Table_find_field_from_embeds(c->table, gs, field_name);
				if (_t15.state != 0) { /*or block*/ 
					IError err = _t15.err;
					if (((*(err.msg))).len != 0) {
						v__checker__Checker_error(c, (*(err.msg)), node->pos);
					}
					has_field = false;
					*(multi_return_v__ast__StructField_Array_v__ast__Type*) _t15.data = (multi_return_v__ast__StructField_Array_v__ast__Type){.arg0=(v__ast__StructField){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.has_default_expr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_pub = 0,.default_val = (string){.str=(byteptr)"", .is_lit=1},.is_mut = 0,.is_global = 0,.is_volatile = 0,.default_expr = {0},.default_expr_typ = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,},.arg1=__new_array_with_default(0, 0, sizeof(v__ast__Type), 0)};
				}
				
 				Option_multi_return_v__ast__StructField_Array_v__ast__Type mr_54512 =  _t15 /*U*/;
				field = (*(multi_return_v__ast__StructField_Array_v__ast__Type*)mr_54512.data).arg0;
				embed_types = (*(multi_return_v__ast__StructField_Array_v__ast__Type*)mr_54512.data).arg1;
				node->from_embed_types = embed_types;
			}
		}
	}
	if (has_field) {
		if (!string__eq(sym->mod, c->mod) && !field.is_pub && sym->language != v__ast__Language__c) {
			v__ast__TypeSymbol* unwrapped_sym = v__ast__Table_sym(c->table, v__checker__Checker_unwrap_generic(c, typ));
			v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("field `"), 0xfe10, {.d_s = unwrapped_sym->name}}, {_SLIT("."), 0xfe10, {.d_s = field_name}}, {_SLIT("` is not public"), 0, { .d_c = 0 }}})), node->pos);
		}
		v__ast__TypeSymbol* field_sym = v__ast__Table_sym(c->table, field.typ);
		if (field_sym->kind == v__ast__Kind__sum_type || field_sym->kind == v__ast__Kind__interface_) {
			if (!prevent_sum_type_unwrapping_once) {
				Option_v__ast__ScopeStructField _t16;
				if (_t16 = v__ast__Scope_find_struct_field(node->scope, v__ast__Expr_str(node->expr), typ, field_name), _t16.state == 0) {
					v__ast__ScopeStructField scope_field = *(v__ast__ScopeStructField*)_t16.data;
					v__ast__Type _t17 = (*(v__ast__Type*)array_last(scope_field.smartcasts));
					return _t17;
				}
			}
		}
		node->typ = field.typ;
		v__ast__Type _t18 = field.typ;
		return _t18;
	}
	if (!(sym->kind == v__ast__Kind__struct_ || sym->kind == v__ast__Kind__aggregate || sym->kind == v__ast__Kind__interface_ || sym->kind == v__ast__Kind__sum_type)) {
		if (sym->kind != v__ast__Kind__placeholder) {
			v__ast__TypeSymbol* unwrapped_sym = v__ast__Table_sym(c->table, v__checker__Checker_unwrap_generic(c, typ));
			v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = unwrapped_sym->name}}, {_SLIT("` has no property `"), 0xfe10, {.d_s = node->field_name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node->pos);
		}
	} else {
		if ((sym->info)._typ == 446 /* v.ast.Struct */) {
			Array_string _t19 = __new_array(0, 0, sizeof(string));
			Array_v__ast__StructField _t19_orig = (*sym->info._v__ast__Struct).fields;
			int _t19_len = _t19_orig.len;
			_t19 = __new_array(0, _t19_len, sizeof(string));

			for (int _t20 = 0; _t20 < _t19_len; ++_t20) {
				v__ast__StructField it = ((v__ast__StructField*) _t19_orig.data)[_t20];
				string ti = it.name;
				array_push((array*)&_t19, &ti);
			}
			v__util__Suggestion suggestion = v__util__new_suggestion(field_name,_t19);
			v__checker__Checker_error(c, v__util__Suggestion_say(suggestion, unknown_field_msg), node->pos);
		}
		v__checker__Checker_error(c, unknown_field_msg, node->pos);
	}
	v__ast__Type _t21 = _const_v__ast__void_type;
	return _t21;
}

void v__checker__Checker_const_decl(v__checker__Checker* c, v__ast__ConstDecl* node) {
	if (node->fields.len == 0) {
		v__checker__Checker_warn(c, _SLIT("const block must have at least 1 declaration"), node->pos);
	}
	for (int _t1 = 0; _t1 < node->fields.len; ++_t1) {
		v__ast__ConstField field = ((v__ast__ConstField*)node->fields.data)[_t1];
		if (Array_string_contains(c->const_names, field.name)) {
			v__token__Position name_pos = (v__token__Position){.len = v__util__no_cur_mod(field.name, c->mod).len,field.pos.line_nr,field.pos.pos,field.pos.col,field.pos.last_line,};
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("duplicate const `"), 0xfe10, {.d_s = field.name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), name_pos);
		}
		array_push((array*)&c->const_names, _MOV((string[]){ string_clone(field.name) }));
	}
	for (int i = 0; i < node->fields.len; ++i) {
		v__ast__ConstField* field = ((v__ast__ConstField*)node->fields.data) + i;
		c->const_decl = field->name;
		array_push((array*)&c->const_deps, _MOV((string[]){ string_clone(field->name) }));
		v__ast__Type typ = v__checker__Checker_check_expr_opt_call(c, field->expr, v__checker__Checker_expr(c, field->expr));
		Option_v__ast__ComptTimeConstValue _t4;
		if (_t4 = v__checker__Checker_eval_comptime_const_expr(c, field->expr, 0), _t4.state == 0) {
			v__ast__ComptTimeConstValue ct_value = *(v__ast__ComptTimeConstValue*)_t4.data;
			field->comptime_expr_value = ct_value;
			if ((ct_value)._typ == 13 /* u64 */) {
				typ = _const_v__ast__u64_type;
			}
		}
		(*(v__ast__ConstField*)/*ee elem_typ */array_get(node->fields, i)).typ = v__ast__mktyp(typ);
		c->const_deps = __new_array_with_default(0, 0, sizeof(string), 0);
	}
}

void v__checker__Checker_enum_decl(v__checker__Checker* c, v__ast__EnumDecl* node) {
	v__checker__Checker_check_valid_pascal_case(c, node->name, _SLIT("enum name"), node->pos);
	Array_i64 seen = __new_array_with_default(0, node->fields.len, sizeof(i64), 0);
	if (node->fields.len == 0) {
		v__checker__Checker_error(c, _SLIT("enum cannot be empty"), node->pos);
	}
	for (int i = 0; i < node->fields.len; ++i) {
		v__ast__EnumField* field = ((v__ast__EnumField*)node->fields.data) + i;
		if (!c->pref->experimental && v__util__contains_capital(field->name)) {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("field name `"), 0xfe10, {.d_s = field->name}}, {_SLIT("` cannot contain uppercase letters, use snake_case instead"), 0, { .d_c = 0 }}})), field->pos);
		}
		for (int j = 0; j < i; ++j) {
			if (string__eq(field->name, (*(v__ast__EnumField*)/*ee elem_typ */array_get(node->fields, j)).name)) {
				v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("field name `"), 0xfe10, {.d_s = field->name}}, {_SLIT("` duplicate"), 0, { .d_c = 0 }}})), field->pos);
			}
		}
		if (field->has_expr) {
			if (field->expr._typ == 304 /* v.ast.IntegerLiteral */) {
				i64 val = string_i64((*field->expr._v__ast__IntegerLiteral).val);
				if (val < _const_v__checker__int_min || val > _const_v__checker__int_max) {
					v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("enum value `"), 0xfe09, {.d_i64 = val}}, {_SLIT("` overflows int"), 0, { .d_c = 0 }}})), (*field->expr._v__ast__IntegerLiteral).pos);
				} else if (!c->pref->translated && !node->is_multi_allowed && Array_i64_contains(seen, ((i64)(val)))) {
					v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("enum value `"), 0xfe09, {.d_i64 = val}}, {_SLIT("` already exists"), 0, { .d_c = 0 }}})), (*field->expr._v__ast__IntegerLiteral).pos);
				}
				array_push((array*)&seen, _MOV((i64[]){ ((i64)(val)) }));
			}
			else if (field->expr._typ == 316 /* v.ast.PrefixExpr */) {
			}
			else if (field->expr._typ == 303 /* v.ast.InfixExpr */) {
				v__checker__Checker_infix_expr(c, (voidptr)&/*qq*/(*field->expr._v__ast__InfixExpr));
			}
			
			else {
				if ((field->expr)._typ == 299 /* v.ast.Ident */) {
					v__ast__Ident x = /* as */ *(v__ast__Ident*)__as_cast((field->expr)._v__ast__Ident,(field->expr)._typ, 299) /*expected idx: 299, name: v.ast.Ident */ ;
					if (x.language == v__ast__Language__c) {
						continue;
					}
				}
				v__token__Position pos = v__ast__Expr_position(field->expr);
				if (pos.pos == 0) {
					pos = field->pos;
				}
				v__checker__Checker_error(c, _SLIT("default value for enum has to be an integer"), pos);
			}
			;
		} else {
			if (seen.len > 0) {
				i64 last = (*(i64*)/*ee elem_typ */array_get(seen, seen.len - 1));
				if (last == _const_v__checker__int_max) {
					v__checker__Checker_error(c, _SLIT("enum value overflows"), field->pos);
				} else if (!c->pref->translated && !node->is_multi_allowed && Array_i64_contains(seen, last + 1)) {
					v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("enum value `"), 0xfe09, {.d_i64 = last + 1}}, {_SLIT("` already exists"), 0, { .d_c = 0 }}})), field->pos);
				}
				array_push((array*)&seen, _MOV((i64[]){ last + 1 }));
			} else {
				array_push((array*)&seen, _MOV((i64[]){ 0 }));
			}
		}
	}
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL void v__checker__Checker_check_loop_label(v__checker__Checker* c, string label, v__token__Position pos) {
	if (label.len == 0) {
		return;
	}
	if (c->loop_label.len != 0) {
		v__checker__Checker_error(c, _SLIT("nesting of labelled `for` loops is not supported"), pos);
		return;
	}
	c->loop_label = label;
}

VV_LOCAL_SYMBOL void v__checker__Checker_stmt(v__checker__Checker* c, v__ast__Stmt node) {
	c->expected_type = _const_v__ast__void_type;
	if (node._typ == 337 /* v.ast.EmptyStmt */) {
		if (c->pref->is_verbose) {
			eprintln(_SLIT("Checker.stmt() EmptyStmt"));
			print_backtrace();
		}
	}
	else if (node._typ == 310 /* v.ast.NodeError */) {
	}
	else if (node._typ == 329 /* v.ast.AsmStmt */) {
		v__checker__Checker_asm_stmt(c, (voidptr)&/*qq*/(*node._v__ast__AsmStmt));
	}
	else if (node._typ == 330 /* v.ast.AssertStmt */) {
		v__checker__Checker_assert_stmt(c, (*node._v__ast__AssertStmt));
	}
	else if (node._typ == 331 /* v.ast.AssignStmt */) {
		v__checker__Checker_assign_stmt(c, (voidptr)&/*qq*/(*node._v__ast__AssignStmt));
	}
	else if (node._typ == 332 /* v.ast.Block */) {
		v__checker__Checker_block(c, (*node._v__ast__Block));
	}
	else if (node._typ == 333 /* v.ast.BranchStmt */) {
		v__checker__Checker_branch_stmt(c, (*node._v__ast__BranchStmt));
	}
	else if (node._typ == 334 /* v.ast.ComptimeFor */) {
		v__checker__Checker_comptime_for(c, (*node._v__ast__ComptimeFor));
	}
	else if (node._typ == 335 /* v.ast.ConstDecl */) {
		c->inside_const = true;
		v__checker__Checker_const_decl(c, (voidptr)&/*qq*/(*node._v__ast__ConstDecl));
		c->inside_const = false;
	}
	else if (node._typ == 336 /* v.ast.DeferStmt */) {
		if ((*node._v__ast__DeferStmt).idx_in_fn < 0) {
			(*node._v__ast__DeferStmt).idx_in_fn = c->table->cur_fn->defer_stmts.len;
			array_push((array*)&c->table->cur_fn->defer_stmts, _MOV((v__ast__DeferStmt[]){ *&(*node._v__ast__DeferStmt) }));
		}
		if (c->locked_names.len != 0 || c->rlocked_names.len != 0) {
			v__checker__Checker_error(c, _SLIT("defers are not allowed in lock statements"), (*node._v__ast__DeferStmt).pos);
		}
		for (int i = 0; i < (*node._v__ast__DeferStmt).defer_vars.len; ++i) {
			v__ast__Ident ident = ((v__ast__Ident*)(*node._v__ast__DeferStmt).defer_vars.data)[i];
			v__ast__Ident id = ident;
			if ((id.info)._typ == 408 /* v.ast.IdentVar */) {
				if (id.comptime && Array_string_contains(_const_v__checker__valid_comptime_not_user_defined, id.name)) {
					(*(v__ast__Ident*)/*ee elem_typ */array_get((*node._v__ast__DeferStmt).defer_vars, i)) = (v__ast__Ident){.language = 0,.tok_kind = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.mut_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comptime = 0,.scope = 0,.obj = {0},.mod = (string){.str=(byteptr)"", .is_lit=1},.name = _SLIT(""),.kind = 0,.info = {0},.is_mut = 0,};
					continue;
				}
				v__ast__IdentVar info = /* as */ *(v__ast__IdentVar*)__as_cast((id.info)._v__ast__IdentVar,(id.info)._typ, 408) /*expected idx: 408, name: v.ast.IdentVar */ ;
				v__ast__Type typ = v__checker__Checker_ident(c, (voidptr)&/*qq*/id);
				if (typ == _const_v__ast__error_type_idx) {
					continue;
				}
				info.typ = typ;
				id.info = v__ast__IdentVar_to_sumtype_v__ast__IdentInfo(&info);
				(*(v__ast__Ident*)/*ee elem_typ */array_get((*node._v__ast__DeferStmt).defer_vars, i)) = id;
			}
		}
		c->inside_defer = true;
		v__checker__Checker_stmts(c, (*node._v__ast__DeferStmt).stmts);
		c->inside_defer = false;
	}
	else if (node._typ == 338 /* v.ast.EnumDecl */) {
		v__checker__Checker_enum_decl(c, (voidptr)&/*qq*/(*node._v__ast__EnumDecl));
	}
	else if (node._typ == 339 /* v.ast.ExprStmt */) {
		(*node._v__ast__ExprStmt).typ = v__checker__Checker_expr(c, (*node._v__ast__ExprStmt).expr);
		c->expected_type = _const_v__ast__void_type;
		v__ast__Type or_typ = _const_v__ast__void_type;
		if ((*node._v__ast__ExprStmt).expr._typ == 302 /* v.ast.IndexExpr */) {
			if ((*(*node._v__ast__ExprStmt).expr._v__ast__IndexExpr).or_expr.kind != v__ast__OrKind__absent) {
				(*node._v__ast__ExprStmt).is_expr = true;
				or_typ = (*node._v__ast__ExprStmt).typ;
			}
		}
		else if ((*node._v__ast__ExprStmt).expr._typ == 316 /* v.ast.PrefixExpr */) {
			if ((*(*node._v__ast__ExprStmt).expr._v__ast__PrefixExpr).or_block.kind != v__ast__OrKind__absent) {
				(*node._v__ast__ExprStmt).is_expr = true;
				or_typ = (*node._v__ast__ExprStmt).typ;
			}
		}
		
		else {
		}
		;
		if (!c->pref->is_repl && (c->stmt_level == 1 || (c->stmt_level > 1 && !c->is_last_stmt))) {
			if (((*node._v__ast__ExprStmt).expr)._typ == 303 /* v.ast.InfixExpr */) {
				if ((*(*node._v__ast__ExprStmt).expr._v__ast__InfixExpr).op == v__token__Kind__left_shift) {
					v__ast__TypeSymbol* left_sym = v__ast__Table_final_sym(c->table, (*(*node._v__ast__ExprStmt).expr._v__ast__InfixExpr).left_type);
					if (left_sym->kind != v__ast__Kind__array) {
						v__checker__Checker_error(c, _SLIT("unused expression"), (*node._v__ast__ExprStmt).pos);
					}
				}
			}
		}
		v__checker__Checker_check_expr_opt_call(c, (*node._v__ast__ExprStmt).expr, or_typ);
	}
	else if (node._typ == 216 /* v.ast.FnDecl */) {
		v__checker__Checker_fn_decl(c, (voidptr)&/*qq*/(*node._v__ast__FnDecl));
	}
	else if (node._typ == 340 /* v.ast.ForCStmt */) {
		v__checker__Checker_for_c_stmt(c, (*node._v__ast__ForCStmt));
	}
	else if (node._typ == 341 /* v.ast.ForInStmt */) {
		v__checker__Checker_for_in_stmt(c, (voidptr)&/*qq*/(*node._v__ast__ForInStmt));
	}
	else if (node._typ == 342 /* v.ast.ForStmt */) {
		v__checker__Checker_for_stmt(c, (voidptr)&/*qq*/(*node._v__ast__ForStmt));
	}
	else if (node._typ == 343 /* v.ast.GlobalDecl */) {
		v__checker__Checker_global_decl(c, (voidptr)&/*qq*/(*node._v__ast__GlobalDecl));
	}
	else if (node._typ == 344 /* v.ast.GotoLabel */) {
	}
	else if (node._typ == 345 /* v.ast.GotoStmt */) {
		if (c->inside_defer) {
			v__checker__Checker_error(c, _SLIT("goto is not allowed in defer statements"), (*node._v__ast__GotoStmt).pos);
		}
		if (!c->inside_unsafe) {
			v__checker__Checker_warn(c, _SLIT("`goto` requires `unsafe` (consider using labelled break/continue)"), (*node._v__ast__GotoStmt).pos);
		}
		if (!Array_string_contains(c->table->cur_fn->label_names, (*node._v__ast__GotoStmt).name)) {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unknown label `"), 0xfe10, {.d_s = (*node._v__ast__GotoStmt).name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), (*node._v__ast__GotoStmt).pos);
		}
	}
	else if (node._typ == 346 /* v.ast.HashStmt */) {
		v__checker__Checker_hash_stmt(c, (voidptr)&/*qq*/(*node._v__ast__HashStmt));
	}
	else if (node._typ == 347 /* v.ast.Import */) {
		v__checker__Checker_import_stmt(c, (*node._v__ast__Import));
	}
	else if (node._typ == 348 /* v.ast.InterfaceDecl */) {
		v__checker__Checker_interface_decl(c, (voidptr)&/*qq*/(*node._v__ast__InterfaceDecl));
	}
	else if (node._typ == 349 /* v.ast.Module */) {
		c->mod = (*node._v__ast__Module).name;
		c->is_builtin_mod = (string__eq((*node._v__ast__Module).name, _SLIT("builtin")) || string__eq((*node._v__ast__Module).name, _SLIT("os")) || string__eq((*node._v__ast__Module).name, _SLIT("strconv")));
		v__checker__Checker_check_valid_snake_case(c, (*node._v__ast__Module).name, _SLIT("module name"), (*node._v__ast__Module).pos);
	}
	else if (node._typ == 350 /* v.ast.Return */) {
		v__checker__Checker_return_stmt(c, (voidptr)&/*qq*/(*node._v__ast__Return));
		c->scope_returns = true;
	}
	else if (node._typ == 351 /* v.ast.SqlStmt */) {
		v__checker__Checker_sql_stmt(c, (voidptr)&/*qq*/(*node._v__ast__SqlStmt));
	}
	else if (node._typ == 352 /* v.ast.StructDecl */) {
		v__checker__Checker_struct_decl(c, (voidptr)&/*qq*/(*node._v__ast__StructDecl));
	}
	else if (node._typ == 277 /* v.ast.TypeDecl */) {
		v__checker__Checker_type_decl(c, (*node._v__ast__TypeDecl));
	}
	;
}

VV_LOCAL_SYMBOL void v__checker__Checker_assert_stmt(v__checker__Checker* c, v__ast__AssertStmt node) {
	v__ast__Type cur_exp_typ = c->expected_type;
	v__ast__Type assert_type = v__checker__Checker_check_expr_opt_call(c, node.expr, v__checker__Checker_expr(c, node.expr));
	if (assert_type != _const_v__ast__bool_type_idx) {
		string atype_name = v__ast__Table_sym(c->table, assert_type)->name;
		v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("assert can be used only with `bool` expressions, but found `"), 0xfe10, {.d_s = atype_name}}, {_SLIT("` instead"), 0, { .d_c = 0 }}})), node.pos);
	}
	c->expected_type = cur_exp_typ;
}

VV_LOCAL_SYMBOL void v__checker__Checker_block(v__checker__Checker* c, v__ast__Block node) {
	if (node.is_unsafe) {
		c->inside_unsafe = true;
		v__checker__Checker_stmts(c, node.stmts);
		c->inside_unsafe = false;
	} else {
		v__checker__Checker_stmts(c, node.stmts);
	}
}

VV_LOCAL_SYMBOL void v__checker__Checker_branch_stmt(v__checker__Checker* c, v__ast__BranchStmt node) {
	if (c->inside_defer) {
		v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = v__token__Kind_str(node.kind)}}, {_SLIT("` is not allowed in defer statements"), 0, { .d_c = 0 }}})), node.pos);
	}
	if (c->in_for_count == 0) {
		v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__token__Kind_str(node.kind)}}, {_SLIT(" statement not within a loop"), 0, { .d_c = 0 }}})), node.pos);
	}
	if (node.label.len > 0) {
		if (!string__eq(node.label, c->loop_label)) {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("invalid label name `"), 0xfe10, {.d_s = node.label}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node.pos);
		}
	}
}

VV_LOCAL_SYMBOL void v__checker__Checker_global_decl(v__checker__Checker* c, v__ast__GlobalDecl* node) {
	for (int _t1 = 0; _t1 < node->fields.len; ++_t1) {
		v__ast__GlobalField* field = ((v__ast__GlobalField*)node->fields.data) + _t1;
		v__checker__Checker_check_valid_snake_case(c, field->name, _SLIT("global name"), field->pos);
		if (Array_string_contains(c->global_names, field->name)) {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("duplicate global `"), 0xfe10, {.d_s = field->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), field->pos);
		}
		v__ast__TypeSymbol* sym = v__ast__Table_sym(c->table, field->typ);
		if (sym->kind == v__ast__Kind__placeholder) {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unknown type `"), 0xfe10, {.d_s = sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), field->typ_pos);
		}
		if (field->has_expr) {
			field->typ = v__checker__Checker_expr(c, field->expr);
			Option_v__ast__GlobalField_ptr _t2 = v__ast__Scope_find_global(c->file->global_scope, field->name);
			if (_t2.state != 0) { /*or block*/ 
				IError err = _t2.err;
				_v_panic(_SLIT("internal compiler error - could not find global in scope"));
				VUNREACHABLE();
			;
			}
			
 			v__ast__GlobalField* v =  (*(v__ast__GlobalField**)_t2.data);
			v->typ = v__ast__mktyp(field->typ);
		}
		array_push((array*)&c->global_names, _MOV((string[]){ string_clone(field->name) }));
	}
}

VV_LOCAL_SYMBOL v__ast__Type v__checker__Checker_go_expr(v__checker__Checker* c, v__ast__GoExpr* node) {
	v__ast__Type ret_type = v__checker__Checker_call_expr(c, (voidptr)&/*qq*/node->call_expr);
	if (node->call_expr.or_block.kind != v__ast__OrKind__absent) {
		v__checker__Checker_error(c, _SLIT("optional handling cannot be done in `go` call. Do it when calling `.wait()`"), node->call_expr.or_block.pos);
	}
	for (int _t1 = 0; _t1 < node->call_expr.args.len; ++_t1) {
		v__ast__CallArg arg = ((v__ast__CallArg*)node->call_expr.args.data)[_t1];
		if (arg.is_mut && !v__ast__Type_is_ptr(arg.typ)) {
			v__checker__Checker_error(c, _SLIT("function in `go` statement cannot contain mutable non-reference arguments"), v__ast__Expr_position(arg.expr));
		}
	}
	if (node->call_expr.is_method && v__ast__Type_is_ptr(node->call_expr.receiver_type) && !v__ast__Type_is_ptr(node->call_expr.left_type)) {
		v__checker__Checker_error(c, _SLIT("method in `go` statement cannot have non-reference mutable receiver"), v__ast__Expr_position(node->call_expr.left));
	}
	if (v__pref__Backend_is_js(c->pref->backend)) {
		v__ast__Type _t2 = v__ast__Table_find_or_register_promise(c->table, ret_type);
		return _t2;
	} else {
		v__ast__Type _t3 = v__ast__Table_find_or_register_thread(c->table, ret_type);
		return _t3;
	}
	return 0;
}

VV_LOCAL_SYMBOL void v__checker__Checker_asm_stmt(v__checker__Checker* c, v__ast__AsmStmt* stmt) {
	if (stmt->is_goto) {
		v__checker__Checker_warn(c, _SLIT("inline assembly goto is not supported, it will most likely not work"), stmt->pos);
	}
	if (v__pref__Backend_is_js(c->pref->backend)) {
		v__checker__Checker_error(c, _SLIT("inline assembly is not supported in the js backend"), stmt->pos);
	}
	if (c->pref->backend == v__pref__Backend__c && c->pref->ccompiler_type == v__pref__CompilerType__msvc) {
		v__checker__Checker_error(c, _SLIT("msvc compiler does not support inline assembly"), stmt->pos);
	}
	Array_string aliases = v__checker__Checker_asm_ios(c, stmt->output, stmt->scope, true);
	Array_string aliases2 = v__checker__Checker_asm_ios(c, stmt->input, stmt->scope, false);
	_PUSH_MANY(&aliases, (aliases2), _t1, Array_string);
	for (int _t2 = 0; _t2 < stmt->templates.len; ++_t2) {
		v__ast__AsmTemplate* _v_template = ((v__ast__AsmTemplate*)stmt->templates.data) + _t2;
		if (_v_template->is_directive) {
			if (!(string__eq(_v_template->name, _SLIT("skip")) || string__eq(_v_template->name, _SLIT("space")) || string__eq(_v_template->name, _SLIT("byte")) || string__eq(_v_template->name, _SLIT("word")) || string__eq(_v_template->name, _SLIT("short")) || string__eq(_v_template->name, _SLIT("int")) || string__eq(_v_template->name, _SLIT("long")) || string__eq(_v_template->name, _SLIT("quad")) || string__eq(_v_template->name, _SLIT("globl")) || string__eq(_v_template->name, _SLIT("global")) || string__eq(_v_template->name, _SLIT("section")) || string__eq(_v_template->name, _SLIT("text")) || string__eq(_v_template->name, _SLIT("data")) || string__eq(_v_template->name, _SLIT("bss")) || string__eq(_v_template->name, _SLIT("fill")) || string__eq(_v_template->name, _SLIT("org")) || string__eq(_v_template->name, _SLIT("previous")) || string__eq(_v_template->name, _SLIT("string")) || string__eq(_v_template->name, _SLIT("asciz")) || string__eq(_v_template->name, _SLIT("ascii")))) {
				v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unknown assembler directive: `"), 0xfe10, {.d_s = _v_template->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), _v_template->pos);
			}
		}
		for (int _t3 = 0; _t3 < _v_template->args.len; ++_t3) {
			v__ast__AsmArg* arg = ((v__ast__AsmArg*)_v_template->args.data) + _t3;
			v__checker__Checker_asm_arg(c, *arg, *stmt, aliases);
		}
	}
	for (int _t4 = 0; _t4 < stmt->clobbered.len; ++_t4) {
		v__ast__AsmClobbered* clob = ((v__ast__AsmClobbered*)stmt->clobbered.data) + _t4;
		v__checker__Checker_asm_arg(c, v__ast__AsmRegister_to_sumtype_v__ast__AsmArg(&clob->reg), *stmt, aliases);
	}
}

VV_LOCAL_SYMBOL void v__checker__Checker_asm_arg(v__checker__Checker* c, v__ast__AsmArg arg, v__ast__AsmStmt stmt, Array_string aliases) {
	if (arg._typ == 429 /* v.ast.AsmAlias */) {
	}
	else if (arg._typ == 428 /* v.ast.AsmAddressing */) {
		if (!((*arg._v__ast__AsmAddressing).scale == -1 || (*arg._v__ast__AsmAddressing).scale == 1 || (*arg._v__ast__AsmAddressing).scale == 2 || (*arg._v__ast__AsmAddressing).scale == 4 || (*arg._v__ast__AsmAddressing).scale == 8)) {
			v__checker__Checker_error(c, _SLIT("scale must be one of 1, 2, 4, or 8"), (*arg._v__ast__AsmAddressing).pos);
		}
		v__checker__Checker_asm_arg(c, (*arg._v__ast__AsmAddressing).displacement, stmt, aliases);
		v__checker__Checker_asm_arg(c, (*arg._v__ast__AsmAddressing).base, stmt, aliases);
		v__checker__Checker_asm_arg(c, (*arg._v__ast__AsmAddressing).index, stmt, aliases);
	}
	else if (arg._typ == 284 /* v.ast.BoolLiteral */) {
	}
	else if (arg._typ == 297 /* v.ast.FloatLiteral */) {
	}
	else if (arg._typ == 289 /* v.ast.CharLiteral */) {
	}
	else if (arg._typ == 304 /* v.ast.IntegerLiteral */) {
	}
	else if (arg._typ == 354 /* v.ast.AsmRegister */) {
	}
	else if (arg._typ == 430 /* v.ast.AsmDisp */) {
	}
	else if (arg._typ == 20 /* string */) {
	}
	;
}

VV_LOCAL_SYMBOL Array_string v__checker__Checker_asm_ios(v__checker__Checker* c, Array_v__ast__AsmIO ios, v__ast__Scope* scope, bool output) {
	Array_string aliases = __new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t1 = 0; _t1 < ios.len; ++_t1) {
		v__ast__AsmIO io = ((v__ast__AsmIO*)ios.data)[_t1];
		v__ast__Type typ = v__checker__Checker_expr(c, io.expr);
		if (output) {
			v__checker__Checker_fail_if_immutable(c, io.expr);
		}
		if ((io.alias).len != 0) {
			array_push((array*)&aliases, _MOV((string[]){ string_clone(io.alias) }));
			if (_IN_MAP(ADDR(string, io.alias), ADDR(map, scope->objects))) {
				map_set(&scope->objects, &(string[]){io.alias}, &(v__ast__ScopeObject[]) { v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){
					.name = io.alias,
					.expr = io.expr,
					.share = 0,
					.is_mut = 0,
					.is_autofree_tmp = 0,
					.is_arg = true,
					.is_auto_deref = 0,
					.is_inherited = 0,
					.typ = typ,
					.orig_type = typ,
					.smartcasts = __new_array(0, 0, sizeof(v__ast__Type)),
					.pos = io.pos,
					.is_used = 0,
					.is_changed = 0,
					.is_or = 0,
					.is_tmp = 0,
					.is_auto_heap = 0,
					.is_stack_obj = 0,
				}))) });
			}
		}
	}
	Array_string _t3 = aliases;
	return _t3;
}

VV_LOCAL_SYMBOL void v__checker__Checker_hash_stmt(v__checker__Checker* c, v__ast__HashStmt* node) {
	if (c->skip_flags) {
		return;
	}
	if (c->ct_cond_stack.len > 0) {
		node->ct_conds = array_clone_to_depth(&c->ct_cond_stack, 0);
	}
	if (v__pref__Backend_is_js(c->pref->backend)) {
		if (!string_ends_with(c->file->path, _SLIT(".js.v"))) {
			v__checker__Checker_error(c, _SLIT("hash statements are only allowed in backend specific files such \"x.js.v\""), node->pos);
		}
		if (string__eq(c->mod, _SLIT("main"))) {
			v__checker__Checker_error(c, _SLIT("hash statements are not allowed in the main module. Place them in a separate module."), node->pos);
		}
		return;
	}

	if (string__eq(node->kind, _SLIT("include"))) {
		string flag = node->main;
		if (string_contains(flag, _SLIT("@VROOT"))) {
			Option_string _t1 = v__util__resolve_vmodroot(string_replace(flag, _SLIT("@VROOT"), _SLIT("@VMODROOT")), c->file->path);
			if (_t1.state != 0) { /*or block*/ 
				IError err = _t1.err;
				v__checker__Checker_error(c, (*(err.msg)), node->pos);
				return;
			}
			
 			string vroot =  (*(string*)_t1.data);
			node->val =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("include "), 0xfe10, {.d_s = vroot}}, {_SLIT0, 0, { .d_c = 0 }}}));
			node->main = vroot;
			flag = vroot;
		}
		if (string_contains(flag, _SLIT("@VEXEROOT"))) {
			string vroot = string_replace(flag, _SLIT("@VEXEROOT"), os__dir(v__pref__vexe_path()));
			node->val =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("include "), 0xfe10, {.d_s = vroot}}, {_SLIT0, 0, { .d_c = 0 }}}));
			node->main = vroot;
			flag = vroot;
		}
		if (string_contains(flag, _SLIT("@VMODROOT"))) {
			Option_string _t2 = v__util__resolve_vmodroot(flag, c->file->path);
			if (_t2.state != 0) { /*or block*/ 
				IError err = _t2.err;
				v__checker__Checker_error(c, (*(err.msg)), node->pos);
				return;
			}
			
 			string vroot =  (*(string*)_t2.data);
			node->val =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("include "), 0xfe10, {.d_s = vroot}}, {_SLIT0, 0, { .d_c = 0 }}}));
			node->main = vroot;
			flag = vroot;
		}
		if (string_contains(flag, _SLIT("$env("))) {
			Option_string _t3 = v__util__resolve_env_value(flag, true);
			if (_t3.state != 0) { /*or block*/ 
				IError err = _t3.err;
				v__checker__Checker_error(c, (*(err.msg)), node->pos);
				return;
			}
			
 			string env =  (*(string*)_t3.data);
			node->main = env;
		}
		string flag_no_comment = string_trim_space(string_all_before(flag, _SLIT("//")));
		if (!((string_starts_with(flag_no_comment, _SLIT("\"")) && string_ends_with(flag_no_comment, _SLIT("\""))) || (string_starts_with(flag_no_comment, _SLIT("<")) && string_ends_with(flag_no_comment, _SLIT(">"))))) {
			v__checker__Checker_error(c, _SLIT("including C files should use either `\"header_file.h\"` or `<header_file.h>` quoting"), node->pos);
		}
	}
	else if (string__eq(node->kind, _SLIT("pkgconfig"))) {
		Array_string args = (string_contains(node->main, _SLIT("--")) ? (string_split(node->main, _SLIT(" "))) : (string_split( str_intp(2, _MOV((StrIntpData[]){{_SLIT("--cflags --libs "), 0xfe10, {.d_s = node->main}}, {_SLIT0, 0, { .d_c = 0 }}})), _SLIT(" "))));
		Option_v__pkgconfig__Main_ptr _t4 = v__pkgconfig__main(args);
		if (_t4.state != 0) { /*or block*/ 
			IError err = _t4.err;
			v__checker__Checker_error(c, (*(err.msg)), node->pos);
			return;
		}
		
 		v__pkgconfig__Main* m =  (*(v__pkgconfig__Main**)_t4.data);
		Option_string _t5 = v__pkgconfig__Main_run(m);
		if (_t5.state != 0) { /*or block*/ 
			IError err = _t5.err;
			v__checker__Checker_error(c, (*(err.msg)), node->pos);
			return;
		}
		
 		string cflags =  (*(string*)_t5.data);
		Option_bool _t6 = v__ast__Table_parse_cflag(c->table, cflags, c->mod, c->pref->compile_defines_all);
		if (_t6.state != 0) { /*or block*/ 
			IError err = _t6.err;
			v__checker__Checker_error(c, (*(err.msg)), node->pos);
			return;
		}
		
  (*(bool*)_t6.data);
	}
	else if (string__eq(node->kind, _SLIT("flag"))) {
		string flag = node->main;
		if (string_contains(flag, _SLIT("@VROOT"))) {
			Option_string _t7 = v__util__resolve_vmodroot(string_replace(flag, _SLIT("@VROOT"), _SLIT("@VMODROOT")), c->file->path);
			if (_t7.state != 0) { /*or block*/ 
				IError err = _t7.err;
				v__checker__Checker_error(c, (*(err.msg)), node->pos);
				return;
			}
			
 			flag =  (*(string*)_t7.data);
		}
		if (string_contains(flag, _SLIT("@VEXEROOT"))) {
			flag = string_replace(flag, _SLIT("@VEXEROOT"), os__dir(v__pref__vexe_path()));
		}
		if (string_contains(flag, _SLIT("@VMODROOT"))) {
			Option_string _t8 = v__util__resolve_vmodroot(flag, c->file->path);
			if (_t8.state != 0) { /*or block*/ 
				IError err = _t8.err;
				v__checker__Checker_error(c, (*(err.msg)), node->pos);
				return;
			}
			
 			flag =  (*(string*)_t8.data);
		}
		if (string_contains(flag, _SLIT("$env("))) {
			Option_string _t9 = v__util__resolve_env_value(flag, true);
			if (_t9.state != 0) { /*or block*/ 
				IError err = _t9.err;
				v__checker__Checker_error(c, (*(err.msg)), node->pos);
				return;
			}
			
 			flag =  (*(string*)_t9.data);
		}
		Array_string _t10 = new_array_from_c_array(4, 4, sizeof(string), _MOV((string[4]){_SLIT("@VMOD"), _SLIT("@VMODULE"), _SLIT("@VPATH"), _SLIT("@VLIB_PATH")}));
		for (int _t11 = 0; _t11 < _t10.len; ++_t11) {
			string deprecated = ((string*)_t10.data)[_t11];
			if (string_contains(flag, deprecated)) {
				if (!string_contains(flag, _SLIT("@VMODROOT"))) {
					v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = deprecated}}, {_SLIT(" had been deprecated, use @VMODROOT instead."), 0, { .d_c = 0 }}})), node->pos);
				}
			}
		}
		Option_bool _t12 = v__ast__Table_parse_cflag(c->table, flag, c->mod, c->pref->compile_defines_all);
		if (_t12.state != 0) { /*or block*/ 
			IError err = _t12.err;
			v__checker__Checker_error(c, (*(err.msg)), node->pos);
		;
		}
		
  (*(bool*)_t12.data);
	}
	else {
		if (!string__eq(node->kind, _SLIT("define"))) {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("expected `#define`, `#flag`, `#include` or `#pkgconfig` not "), 0xfe10, {.d_s = node->val}}, {_SLIT0, 0, { .d_c = 0 }}})), node->pos);
		}
	};
}

VV_LOCAL_SYMBOL void v__checker__Checker_import_stmt(v__checker__Checker* c, v__ast__Import node) {
	v__checker__Checker_check_valid_snake_case(c, node.alias, _SLIT("module alias"), node.pos);
	for (int _t1 = 0; _t1 < node.syms.len; ++_t1) {
		v__ast__ImportSymbol sym = ((v__ast__ImportSymbol*)node.syms.data)[_t1];
		string name =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = node.mod}}, {_SLIT("."), 0xfe10, {.d_s = sym.name}}, {_SLIT0, 0, { .d_c = 0 }}}));
		if (byte_is_capital(string_at(sym.name, 0))) {
			Option_v__ast__TypeSymbol_ptr _t2;
			if (_t2 = v__ast__Table_find_sym(c->table, name), _t2.state == 0) {
				v__ast__TypeSymbol* type_sym = *(v__ast__TypeSymbol**)_t2.data;
				if (type_sym->kind != v__ast__Kind__placeholder) {
					if (!type_sym->is_public) {
						v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("module `"), 0xfe10, {.d_s = node.mod}}, {_SLIT("` type `"), 0xfe10, {.d_s = sym.name}}, {_SLIT("` is private"), 0, { .d_c = 0 }}})), sym.pos);
					}
					continue;
				}
			}
			v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("module `"), 0xfe10, {.d_s = node.mod}}, {_SLIT("` has no type `"), 0xfe10, {.d_s = sym.name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), sym.pos);
			continue;
		}
		Option_v__ast__Fn _t3;
		if (_t3 = v__ast__Table_find_fn(c->table, name), _t3.state == 0) {
			v__ast__Fn func = *(v__ast__Fn*)_t3.data;
			if (!func.is_pub) {
				v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("module `"), 0xfe10, {.d_s = node.mod}}, {_SLIT("` function `"), 0xfe10, {.d_s = sym.name}}, {_SLIT("()` is private"), 0, { .d_c = 0 }}})), sym.pos);
			}
			continue;
		}
		Option_v__ast__ConstField_ptr _t4;
		if (_t4 = v__ast__Scope_find_const(c->file->global_scope, name), _t4.state == 0) {
			continue;
		}
		v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("module `"), 0xfe10, {.d_s = node.mod}}, {_SLIT("` has no constant or function `"), 0xfe10, {.d_s = sym.name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), sym.pos);
	}
}

VV_LOCAL_SYMBOL void v__checker__Checker_stmts(v__checker__Checker* c, Array_v__ast__Stmt stmts) {
	int old_stmt_level = c->stmt_level;
	c->stmt_level = 0;
	v__checker__Checker_stmts_ending_with_expression(c, stmts);
	c->stmt_level = old_stmt_level;
}

VV_LOCAL_SYMBOL void v__checker__Checker_stmts_ending_with_expression(v__checker__Checker* c, Array_v__ast__Stmt stmts) {
	v__token__Position unreachable = (v__token__Position){.len = 0,.line_nr = -1,.pos = 0,.col = 0,.last_line = 0,};
	c->expected_type = _const_v__ast__void_type;
	c->stmt_level++;
	for (int i = 0; i < stmts.len; ++i) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)stmts.data)[i];
		c->is_last_stmt = i == stmts.len - 1;
		if (c->scope_returns) {
			if (unreachable.line_nr == -1) {
				unreachable = (*(stmt.pos));
			}
		}
		v__checker__Checker_stmt(c, stmt);
		if ((stmt)._typ == 344 /* v.ast.GotoLabel */) {
			unreachable = (v__token__Position){.len = 0,.line_nr = -1,.pos = 0,.col = 0,.last_line = 0,};
			c->scope_returns = false;
		}
		if (c->should_abort) {
			return;
		}
	}
	c->stmt_level--;
	if (unreachable.line_nr >= 0) {
		v__checker__Checker_error(c, _SLIT("unreachable code"), unreachable);
	}
	v__checker__Checker_find_unreachable_statements_after_noreturn_calls(c, stmts);
	c->scope_returns = false;
	c->expected_type = _const_v__ast__void_type;
}

v__ast__Type v__checker__Checker_unwrap_generic(v__checker__Checker* c, v__ast__Type typ) {
	if (v__ast__Type_has_flag(typ, v__ast__TypeFlag__generic)) {
		Option_v__ast__Type _t1;
		if (_t1 = v__ast__Table_resolve_generic_to_concrete(c->table, typ, c->table->cur_fn->generic_names, c->table->cur_concrete_types), _t1.state == 0) {
			v__ast__Type t_typ = *(v__ast__Type*)_t1.data;
			v__ast__Type _t2 = t_typ;
			return _t2;
		}
	}
	v__ast__Type _t3 = typ;
	return _t3;
}

v__ast__Type v__checker__Checker_expr(v__checker__Checker* c, v__ast__Expr node) {
bool v__checker__Checker_expr_defer_0 = false;
	c->expr_level++;
	v__checker__Checker_expr_defer_0 = true;
	if (c->expr_level > 150) {
		v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("checker: too many expr levels: "), 0xfe07, {.d_i32 = c->expr_level}}, {_SLIT(" "), 0, { .d_c = 0 }}})), v__ast__Expr_position(node));
		v__ast__Type _t1 = _const_v__ast__void_type;
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t1;
	}
	if (node._typ == 310 /* v.ast.NodeError */) {
	}
	else if (node._typ == 295 /* v.ast.EmptyExpr */) {
		v__checker__Checker_error(c, _SLIT("checker.expr(): unhandled EmptyExpr"), (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,});
	}
	else if (node._typ == 285 /* v.ast.CTempVar */) {
		v__ast__Type _t2 = (*node._v__ast__CTempVar).typ;
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t2;
	}
	else if (node._typ == 278 /* v.ast.AnonFn */) {
		v__ast__Type _t3 = v__checker__Checker_anon_fn(c, (voidptr)&/*qq*/(*node._v__ast__AnonFn));
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t3;
	}
	else if (node._typ == 279 /* v.ast.ArrayDecompose */) {
		v__ast__Type typ = v__checker__Checker_expr(c, (*node._v__ast__ArrayDecompose).expr);
		v__ast__TypeSymbol* type_sym = v__ast__Table_sym(c->table, typ);
		if (type_sym->kind != v__ast__Kind__array) {
			v__checker__Checker_error(c, _SLIT("decomposition can only be used on arrays"), v__ast__Expr_position((*node._v__ast__ArrayDecompose).expr));
			v__ast__Type _t4 = _const_v__ast__void_type;
			// Defer begin
			if (v__checker__Checker_expr_defer_0) {
				c->expr_level--;
			}
			// Defer end
			return _t4;
		}
		v__ast__Array array_info = /* as */ *(v__ast__Array*)__as_cast((type_sym->info)._v__ast__Array,(type_sym->info)._typ, 441) /*expected idx: 441, name: v.ast.Array */ ;
		v__ast__Type elem_type = v__ast__Type_set_flag(array_info.elem_type, v__ast__TypeFlag__variadic);
		(*node._v__ast__ArrayDecompose).expr_type = typ;
		(*node._v__ast__ArrayDecompose).arg_type = elem_type;
		v__ast__Type _t5 = elem_type;
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t5;
	}
	else if (node._typ == 280 /* v.ast.ArrayInit */) {
		v__ast__Type _t6 = v__checker__Checker_array_init(c, (voidptr)&/*qq*/(*node._v__ast__ArrayInit));
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t6;
	}
	else if (node._typ == 281 /* v.ast.AsCast */) {
		(*node._v__ast__AsCast).expr_type = v__checker__Checker_expr(c, (*node._v__ast__AsCast).expr);
		v__ast__TypeSymbol* expr_type_sym = v__ast__Table_sym(c->table, (*node._v__ast__AsCast).expr_type);
		v__ast__TypeSymbol* type_sym = v__ast__Table_sym(c->table, (*node._v__ast__AsCast).typ);
		if (expr_type_sym->kind == v__ast__Kind__sum_type) {
			Option_void _t7 = v__checker__Checker_ensure_type_exists(c, (*node._v__ast__AsCast).typ, (*node._v__ast__AsCast).pos);
			if (_t7.state != 0 && _t7.err._typ != _IError_None___index) {
				IError err = _t7.err;
			}
			
 ;
			if (!v__ast__Table_sumtype_has_variant(c->table, (*node._v__ast__AsCast).expr_type, (*node._v__ast__AsCast).typ, true)) {
				string addr = string_repeat(_SLIT("&"), v__ast__Type_nr_muls((*node._v__ast__AsCast).typ));
				v__checker__Checker_error(c,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("cannot cast `"), 0xfe10, {.d_s = expr_type_sym->name}}, {_SLIT("` to `"), 0xfe10, {.d_s = addr}}, {_SLIT0, 0xfe10, {.d_s = type_sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), (*node._v__ast__AsCast).pos);
			}
		} else if (expr_type_sym->kind == v__ast__Kind__interface_ && type_sym->kind == v__ast__Kind__interface_) {
			Option_void _t8 = v__checker__Checker_ensure_type_exists(c, (*node._v__ast__AsCast).typ, (*node._v__ast__AsCast).pos);
			if (_t8.state != 0 && _t8.err._typ != _IError_None___index) {
				IError err = _t8.err;
			}
			
 ;
		} else if (!v__ast__Type_alias_eq((*node._v__ast__AsCast).expr_type, (*node._v__ast__AsCast).typ)) {
			string s =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot cast non-sum type `"), 0xfe10, {.d_s = expr_type_sym->name}}, {_SLIT("` using `as`"), 0, { .d_c = 0 }}}));
			if (type_sym->kind == v__ast__Kind__sum_type) {
				s = /*f*/string__plus(s,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(" - use e.g. `"), 0xfe10, {.d_s = type_sym->name}}, {_SLIT("(some_expr)` instead."), 0, { .d_c = 0 }}})));
			}
			v__checker__Checker_error(c, s, (*node._v__ast__AsCast).pos);
		}
		v__ast__Type _t9 = (*node._v__ast__AsCast).typ;
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t9;
	}
	else if (node._typ == 282 /* v.ast.Assoc */) {
		Option_v__ast__Var_ptr _t10 = v__ast__Scope_find_var((*node._v__ast__Assoc).scope, (*node._v__ast__Assoc).var_name);
		if (_t10.state != 0) { /*or block*/ 
			IError err = _t10.err;
			_v_panic(IError_str(err));
			VUNREACHABLE();
		;
		}
		
 		v__ast__Var* v =  (*(v__ast__Var**)_t10.data);
		for (int i = 0; i < (*node._v__ast__Assoc).fields.len; ++i) {
			v__checker__Checker_expr(c, (*(v__ast__Expr*)/*ee elem_typ */array_get((*node._v__ast__Assoc).exprs, i)));
		}
		(*node._v__ast__Assoc).typ = v->typ;
		v__ast__Type _t11 = v->typ;
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t11;
	}
	else if (node._typ == 284 /* v.ast.BoolLiteral */) {
		v__ast__Type _t12 = _const_v__ast__bool_type;
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t12;
	}
	else if (node._typ == 287 /* v.ast.CastExpr */) {
		v__ast__Type _t13 = v__checker__Checker_cast_expr(c, (voidptr)&/*qq*/(*node._v__ast__CastExpr));
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t13;
	}
	else if (node._typ == 286 /* v.ast.CallExpr */) {
		v__ast__Type ret_type = v__checker__Checker_call_expr(c, (voidptr)&/*qq*/(*node._v__ast__CallExpr));
		if (!v__ast__Type_has_flag(ret_type, v__ast__TypeFlag__optional)) {
			if ((*node._v__ast__CallExpr).or_block.kind == v__ast__OrKind__block) {
				v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unexpected `or` block, the function `"), 0xfe10, {.d_s = (*node._v__ast__CallExpr).name}}, {_SLIT("` does not return an optional"), 0, { .d_c = 0 }}})), (*node._v__ast__CallExpr).or_block.pos);
			} else if ((*node._v__ast__CallExpr).or_block.kind == v__ast__OrKind__propagate) {
				v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unexpected `?`, the function `"), 0xfe10, {.d_s = (*node._v__ast__CallExpr).name}}, {_SLIT("` does not return an optional"), 0, { .d_c = 0 }}})), (*node._v__ast__CallExpr).or_block.pos);
			}
		}
		if (v__ast__Type_has_flag(ret_type, v__ast__TypeFlag__optional) && (*node._v__ast__CallExpr).or_block.kind != v__ast__OrKind__absent) {
			ret_type = v__ast__Type_clear_flag(ret_type, v__ast__TypeFlag__optional);
		}
		v__ast__Type _t14 = ret_type;
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t14;
	}
	else if (node._typ == 288 /* v.ast.ChanInit */) {
		v__ast__Type _t15 = v__checker__Checker_chan_init(c, (voidptr)&/*qq*/(*node._v__ast__ChanInit));
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t15;
	}
	else if (node._typ == 289 /* v.ast.CharLiteral */) {
		v__ast__Type _t16 = _const_v__ast__rune_type;
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t16;
	}
	else if (node._typ == 290 /* v.ast.Comment */) {
		v__ast__Type _t17 = _const_v__ast__void_type;
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t17;
	}
	else if (node._typ == 283 /* v.ast.AtExpr */) {
		v__ast__Type _t18 = v__checker__Checker_at_expr(c, (voidptr)&/*qq*/(*node._v__ast__AtExpr));
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t18;
	}
	else if (node._typ == 291 /* v.ast.ComptimeCall */) {
		v__ast__Type _t19 = v__checker__Checker_comptime_call(c, (voidptr)&/*qq*/(*node._v__ast__ComptimeCall));
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t19;
	}
	else if (node._typ == 292 /* v.ast.ComptimeSelector */) {
		(*node._v__ast__ComptimeSelector).left_type = v__checker__Checker_unwrap_generic(c, v__checker__Checker_expr(c, (*node._v__ast__ComptimeSelector).left));
		v__ast__Type expr_type = v__checker__Checker_unwrap_generic(c, v__checker__Checker_expr(c, (*node._v__ast__ComptimeSelector).field_expr));
		v__ast__TypeSymbol* expr_sym = v__ast__Table_sym(c->table, expr_type);
		if (!v__ast__Type_alias_eq(expr_type, _const_v__ast__string_type)) {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("expected `string` instead of `"), 0xfe10, {.d_s = expr_sym->name}}, {_SLIT("` (e.g. `field.name`)"), 0, { .d_c = 0 }}})), v__ast__Expr_position((*node._v__ast__ComptimeSelector).field_expr));
		}
		if (((*node._v__ast__ComptimeSelector).field_expr)._typ == 319 /* v.ast.SelectorExpr */) {
			v__token__Position left_pos = v__ast__Expr_position((*(*node._v__ast__ComptimeSelector).field_expr._v__ast__SelectorExpr).expr);
			if (c->comptime_fields_type.len == 0) {
				v__checker__Checker_error(c, _SLIT("compile time field access can only be used when iterating over `T.fields`"), left_pos);
			}
			string expr_name = v__ast__Expr_str((*(*node._v__ast__ComptimeSelector).field_expr._v__ast__SelectorExpr).expr);
			if (_IN_MAP(ADDR(string, expr_name), ADDR(map, c->comptime_fields_type))) {
				v__ast__Type _t20 = (*(v__ast__Type*)map_get(ADDR(map, c->comptime_fields_type), &(string[]){expr_name}, &(v__ast__Type[]){ 0 }));
				// Defer begin
				if (v__checker__Checker_expr_defer_0) {
					c->expr_level--;
				}
				// Defer end
				return _t20;
			}
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unknown `$for` variable `"), 0xfe10, {.d_s = expr_name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), left_pos);
		} else {
			v__checker__Checker_error(c, _SLIT("expected selector expression e.g. `$(field.name)`"), v__ast__Expr_position((*node._v__ast__ComptimeSelector).field_expr));
		}
		v__ast__Type _t21 = _const_v__ast__void_type;
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t21;
	}
	else if (node._typ == 293 /* v.ast.ConcatExpr */) {
		v__ast__Type _t22 = v__checker__Checker_concat_expr(c, (voidptr)&/*qq*/(*node._v__ast__ConcatExpr));
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t22;
	}
	else if (node._typ == 294 /* v.ast.DumpExpr */) {
		(*node._v__ast__DumpExpr).expr_type = v__checker__Checker_expr(c, (*node._v__ast__DumpExpr).expr);
		if (v__ast__Type_idx((*node._v__ast__DumpExpr).expr_type) == _const_v__ast__void_type_idx) {
			v__checker__Checker_error(c, _SLIT("dump expression can not be void"), v__ast__Expr_position((*node._v__ast__DumpExpr).expr));
			v__ast__Type _t23 = _const_v__ast__void_type;
			// Defer begin
			if (v__checker__Checker_expr_defer_0) {
				c->expr_level--;
			}
			// Defer end
			return _t23;
		}
		v__ast__TypeSymbol* tsym = v__ast__Table_sym(c->table, (*node._v__ast__DumpExpr).expr_type);
		map_set(&c->table->dumps, &(int[]){((int)((*node._v__ast__DumpExpr).expr_type))}, &(string[]) { tsym->cname });
		(*node._v__ast__DumpExpr).cname = tsym->cname;
		v__ast__Type _t24 = (*node._v__ast__DumpExpr).expr_type;
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t24;
	}
	else if (node._typ == 296 /* v.ast.EnumVal */) {
		v__ast__Type _t25 = v__checker__Checker_enum_val(c, (voidptr)&/*qq*/(*node._v__ast__EnumVal));
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t25;
	}
	else if (node._typ == 297 /* v.ast.FloatLiteral */) {
		v__ast__Type _t26 = _const_v__ast__float_literal_type;
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t26;
	}
	else if (node._typ == 298 /* v.ast.GoExpr */) {
		v__ast__Type _t27 = v__checker__Checker_go_expr(c, (voidptr)&/*qq*/(*node._v__ast__GoExpr));
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t27;
	}
	else if (node._typ == 299 /* v.ast.Ident */) {
		v__ast__Type res = v__checker__Checker_ident(c, (voidptr)&/*qq*/(*node._v__ast__Ident));
		v__ast__Type _t28 = res;
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t28;
	}
	else if (node._typ == 300 /* v.ast.IfExpr */) {
		v__ast__Type _t29 = v__checker__Checker_if_expr(c, (voidptr)&/*qq*/(*node._v__ast__IfExpr));
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t29;
	}
	else if (node._typ == 301 /* v.ast.IfGuardExpr */) {
		bool old_inside_if_guard = c->inside_if_guard;
		c->inside_if_guard = true;
		(*node._v__ast__IfGuardExpr).expr_type = v__checker__Checker_expr(c, (*node._v__ast__IfGuardExpr).expr);
		c->inside_if_guard = old_inside_if_guard;
		if (!v__ast__Type_has_flag((*node._v__ast__IfGuardExpr).expr_type, v__ast__TypeFlag__optional)) {
			bool no_opt = true;
			if ((*node._v__ast__IfGuardExpr).expr._typ == 302 /* v.ast.IndexExpr */) {
				no_opt = false;
				(*node._v__ast__IfGuardExpr).expr_type = v__ast__Type_set_flag((*node._v__ast__IfGuardExpr).expr_type, v__ast__TypeFlag__optional);
				(*(*node._v__ast__IfGuardExpr).expr._v__ast__IndexExpr).is_option = true;
			}
			else if ((*node._v__ast__IfGuardExpr).expr._typ == 316 /* v.ast.PrefixExpr */) {
				if ((*(*node._v__ast__IfGuardExpr).expr._v__ast__PrefixExpr).op == v__token__Kind__arrow) {
					no_opt = false;
					(*node._v__ast__IfGuardExpr).expr_type = v__ast__Type_set_flag((*node._v__ast__IfGuardExpr).expr_type, v__ast__TypeFlag__optional);
					(*(*node._v__ast__IfGuardExpr).expr._v__ast__PrefixExpr).is_option = true;
				}
			}
			
			else {
			}
			;
			if (no_opt) {
				v__checker__Checker_error(c, _SLIT("expression should return an option"), v__ast__Expr_position((*node._v__ast__IfGuardExpr).expr));
			}
		}
		v__ast__Type _t30 = _const_v__ast__bool_type;
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t30;
	}
	else if (node._typ == 302 /* v.ast.IndexExpr */) {
		v__ast__Type _t31 = v__checker__Checker_index_expr(c, (voidptr)&/*qq*/(*node._v__ast__IndexExpr));
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t31;
	}
	else if (node._typ == 303 /* v.ast.InfixExpr */) {
		v__ast__Type _t32 = v__checker__Checker_infix_expr(c, (voidptr)&/*qq*/(*node._v__ast__InfixExpr));
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t32;
	}
	else if (node._typ == 304 /* v.ast.IntegerLiteral */) {
		v__ast__Type _t33 = v__checker__Checker_int_lit(c, (voidptr)&/*qq*/(*node._v__ast__IntegerLiteral));
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t33;
	}
	else if (node._typ == 307 /* v.ast.LockExpr */) {
		v__ast__Type _t34 = v__checker__Checker_lock_expr(c, (voidptr)&/*qq*/(*node._v__ast__LockExpr));
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t34;
	}
	else if (node._typ == 308 /* v.ast.MapInit */) {
		v__ast__Type _t35 = v__checker__Checker_map_init(c, (voidptr)&/*qq*/(*node._v__ast__MapInit));
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t35;
	}
	else if (node._typ == 309 /* v.ast.MatchExpr */) {
		v__ast__Type _t36 = v__checker__Checker_match_expr(c, (voidptr)&/*qq*/(*node._v__ast__MatchExpr));
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t36;
	}
	else if (node._typ == 315 /* v.ast.PostfixExpr */) {
		v__ast__Type _t37 = v__checker__Checker_postfix_expr(c, (voidptr)&/*qq*/(*node._v__ast__PostfixExpr));
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t37;
	}
	else if (node._typ == 316 /* v.ast.PrefixExpr */) {
		v__ast__Type _t38 = v__checker__Checker_prefix_expr(c, (voidptr)&/*qq*/(*node._v__ast__PrefixExpr));
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t38;
	}
	else if (node._typ == 311 /* v.ast.None */) {
		v__ast__Type _t39 = _const_v__ast__none_type;
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t39;
	}
	else if (node._typ == 313 /* v.ast.OrExpr */) {
		v__ast__Type _t40 = _const_v__ast__void_type;
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t40;
	}
	else if (node._typ == 314 /* v.ast.ParExpr */) {
		if (((*node._v__ast__ParExpr).expr)._typ == 314 /* v.ast.ParExpr */) {
			v__checker__Checker_warn(c, _SLIT("redundant parentheses are used"), (*node._v__ast__ParExpr).pos);
		}
		v__ast__Type _t41 = v__checker__Checker_expr(c, (*node._v__ast__ParExpr).expr);
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t41;
	}
	else if (node._typ == 317 /* v.ast.RangeExpr */) {
		v__ast__Type _t42 = _const_v__ast__void_type;
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t42;
	}
	else if (node._typ == 318 /* v.ast.SelectExpr */) {
		v__ast__Type _t43 = v__checker__Checker_select_expr(c, (voidptr)&/*qq*/(*node._v__ast__SelectExpr));
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t43;
	}
	else if (node._typ == 319 /* v.ast.SelectorExpr */) {
		v__ast__Type _t44 = v__checker__Checker_selector_expr(c, (voidptr)&/*qq*/(*node._v__ast__SelectorExpr));
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t44;
	}
	else if (node._typ == 320 /* v.ast.SizeOf */) {
		if (!(*node._v__ast__SizeOf).is_type) {
			(*node._v__ast__SizeOf).typ = v__checker__Checker_expr(c, (*node._v__ast__SizeOf).expr);
		}
		v__ast__Type _t45 = _const_v__ast__u32_type;
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t45;
	}
	else if (node._typ == 305 /* v.ast.IsRefType */) {
		if (!(*node._v__ast__IsRefType).is_type) {
			(*node._v__ast__IsRefType).typ = v__checker__Checker_expr(c, (*node._v__ast__IsRefType).expr);
		}
		v__ast__Type _t46 = _const_v__ast__bool_type;
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t46;
	}
	else if (node._typ == 312 /* v.ast.OffsetOf */) {
		v__ast__Type _t47 = v__checker__Checker_offset_of(c, (*node._v__ast__OffsetOf));
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t47;
	}
	else if (node._typ == 321 /* v.ast.SqlExpr */) {
		v__ast__Type _t48 = v__checker__Checker_sql_expr(c, (voidptr)&/*qq*/(*node._v__ast__SqlExpr));
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t48;
	}
	else if (node._typ == 323 /* v.ast.StringLiteral */) {
		if ((*node._v__ast__StringLiteral).language == v__ast__Language__c) {
			v__ast__Type _t49 = v__ast__Type_set_nr_muls(_const_v__ast__byte_type, 1);
			// Defer begin
			if (v__checker__Checker_expr_defer_0) {
				c->expr_level--;
			}
			// Defer end
			return _t49;
		}
		v__ast__Type _t50 = v__checker__Checker_string_lit(c, (voidptr)&/*qq*/(*node._v__ast__StringLiteral));
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t50;
	}
	else if (node._typ == 322 /* v.ast.StringInterLiteral */) {
		v__ast__Type _t51 = v__checker__Checker_string_inter_lit(c, (voidptr)&/*qq*/(*node._v__ast__StringInterLiteral));
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t51;
	}
	else if (node._typ == 324 /* v.ast.StructInit */) {
		if ((*node._v__ast__StructInit).unresolved) {
			v__ast__Type _t52 = v__checker__Checker_expr(c, v__ast__resolve_init((*node._v__ast__StructInit), v__checker__Checker_unwrap_generic(c, (*node._v__ast__StructInit).typ), c->table));
			// Defer begin
			if (v__checker__Checker_expr_defer_0) {
				c->expr_level--;
			}
			// Defer end
			return _t52;
		}
		v__ast__Type _t53 = v__checker__Checker_struct_init(c, (voidptr)&/*qq*/(*node._v__ast__StructInit));
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t53;
	}
	else if (node._typ == 325 /* v.ast.TypeNode */) {
		v__ast__Type _t54 = (*node._v__ast__TypeNode).typ;
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t54;
	}
	else if (node._typ == 326 /* v.ast.TypeOf */) {
		(*node._v__ast__TypeOf).expr_type = v__checker__Checker_expr(c, (*node._v__ast__TypeOf).expr);
		v__ast__Type _t55 = _const_v__ast__string_type;
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t55;
	}
	else if (node._typ == 327 /* v.ast.UnsafeExpr */) {
		v__ast__Type _t56 = v__checker__Checker_unsafe_expr(c, (voidptr)&/*qq*/(*node._v__ast__UnsafeExpr));
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t56;
	}
	else if (node._typ == 306 /* v.ast.Likely */) {
		v__ast__Type ltype = v__checker__Checker_expr(c, (*node._v__ast__Likely).expr);
		if (!v__checker__Checker_check_types(c, ltype, _const_v__ast__bool_type)) {
			v__ast__TypeSymbol* ltype_sym = v__ast__Table_sym(c->table, ltype);
			string lname = ((*node._v__ast__Likely).is_likely ? (_SLIT("_likely_")) : (_SLIT("_unlikely_")));
			v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = lname}}, {_SLIT("()` expects a boolean expression, instead it got `"), 0xfe10, {.d_s = ltype_sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), (*node._v__ast__Likely).pos);
		}
		v__ast__Type _t57 = _const_v__ast__bool_type;
		// Defer begin
		if (v__checker__Checker_expr_defer_0) {
			c->expr_level--;
		}
		// Defer end
		return _t57;
	}
	;
	v__ast__Type _t58 = _const_v__ast__void_type;
	// Defer begin
	if (v__checker__Checker_expr_defer_0) {
		c->expr_level--;
	}
	// Defer end
	return _t58;
}

v__ast__Type v__checker__Checker_cast_expr(v__checker__Checker* c, v__ast__CastExpr* node) {
	node->expr_type = v__checker__Checker_expr(c, node->expr);
	v__ast__Type from_type = v__checker__Checker_unwrap_generic(c, node->expr_type);
	v__ast__TypeSymbol* from_sym = v__ast__Table_sym(c->table, from_type);
	v__ast__TypeSymbol* final_from_sym = v__ast__Table_final_sym(c->table, from_type);
	v__ast__Type to_type = node->typ;
	v__ast__TypeSymbol* to_sym = v__ast__Table_sym(c->table, to_type);
	v__ast__TypeSymbol* final_to_sym = v__ast__Table_final_sym(c->table, to_type);
	if ((v__ast__TypeSymbol_is_number(to_sym) && string__eq(from_sym->name, _SLIT("JS.Number"))) || (v__ast__TypeSymbol_is_number(to_sym) && string__eq(from_sym->name, _SLIT("JS.BigInt"))) || (v__ast__TypeSymbol_is_string(to_sym) && string__eq(from_sym->name, _SLIT("JS.String"))) || (v__ast__Type_is_bool(to_type) && string__eq(from_sym->name, _SLIT("JS.Boolean"))) || (v__ast__Type_is_bool(from_type) && string__eq(to_sym->name, _SLIT("JS.Boolean"))) || (v__ast__TypeSymbol_is_number(from_sym) && string__eq(to_sym->name, _SLIT("JS.Number"))) || (v__ast__TypeSymbol_is_number(from_sym) && string__eq(to_sym->name, _SLIT("JS.BigInt"))) || (v__ast__TypeSymbol_is_string(from_sym) && string__eq(to_sym->name, _SLIT("JS.String")))) {
		v__ast__Type _t1 = to_type;
		return _t1;
	}
	if (to_sym->language != v__ast__Language__c) {
		Option_void _t2 = v__checker__Checker_ensure_type_exists(c, to_type, node->pos);
		if (_t2.state != 0 && _t2.err._typ != _IError_None___index) {
			IError err = _t2.err;
		}
		
 ;
	}
	if (from_sym->kind == v__ast__Kind__byte && v__ast__Type_is_ptr(from_type) && to_sym->kind == v__ast__Kind__string && !v__ast__Type_is_ptr(to_type)) {
		v__checker__Checker_error(c, _SLIT("to convert a C string buffer pointer to a V string, use x.vstring() instead of string(x)"), node->pos);
	}
	if (v__ast__Type_alias_eq(from_type, _const_v__ast__void_type)) {
		v__checker__Checker_error(c, _SLIT("expression does not return a value so it cannot be cast"), v__ast__Expr_position(node->expr));
	}
	if (to_sym->kind == v__ast__Kind__sum_type) {
		if (from_type == _const_v__ast__int_literal_type || from_type == _const_v__ast__float_literal_type) {
			v__ast__Type xx = (v__ast__Type_alias_eq(from_type, _const_v__ast__int_literal_type) ? (_const_v__ast__int_type) : (_const_v__ast__f64_type));
			node->expr_type = v__checker__Checker_promote_num(c, node->expr_type, xx);
			from_type = node->expr_type;
		}
		if (!v__ast__Table_sumtype_has_variant(c->table, to_type, from_type, false) && !v__ast__Type_has_flag(to_type, v__ast__TypeFlag__optional)) {
			v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("cannot cast `"), 0xfe10, {.d_s = from_sym->name}}, {_SLIT("` to `"), 0xfe10, {.d_s = to_sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node->pos);
		}
	} else if ((to_sym->info)._typ == 460 /* v.ast.Alias */) {
		if (!v__checker__Checker_check_types(c, from_type, (*to_sym->info._v__ast__Alias).parent_type) && !(v__ast__TypeSymbol_is_int(final_to_sym) && final_from_sym->kind == v__ast__Kind__enum_)) {
			v__checker__Checker_error(c,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("cannot convert type `"), 0xfe10, {.d_s = from_sym->name}}, {_SLIT("` to `"), 0xfe10, {.d_s = to_sym->name}}, {_SLIT("` (alias to `"), 0xfe10, {.d_s = final_to_sym->name}}, {_SLIT("`)"), 0, { .d_c = 0 }}})), node->pos);
		}
	} else if (to_sym->kind == v__ast__Kind__struct_ && !v__ast__Type_is_ptr(to_type) && !(/* as */ *(v__ast__Struct*)__as_cast((to_sym->info)._v__ast__Struct,(to_sym->info)._typ, 446) /*expected idx: 446, name: v.ast.Struct */ ).is_typedef) {
		if (from_sym->kind == v__ast__Kind__struct_ && !v__ast__Type_is_ptr(from_type)) {
			v__checker__Checker_warn(c, _SLIT("casting to struct is deprecated, use e.g. `Struct{...expr}` instead"), node->pos);
			v__ast__Struct from_type_info = /* as */ *(v__ast__Struct*)__as_cast((from_sym->info)._v__ast__Struct,(from_sym->info)._typ, 446) /*expected idx: 446, name: v.ast.Struct */ ;
			v__ast__Struct to_type_info = /* as */ *(v__ast__Struct*)__as_cast((to_sym->info)._v__ast__Struct,(to_sym->info)._typ, 446) /*expected idx: 446, name: v.ast.Struct */ ;
			if (!v__checker__Checker_check_struct_signature(c, from_type_info, to_type_info)) {
				v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("cannot convert struct `"), 0xfe10, {.d_s = from_sym->name}}, {_SLIT("` to struct `"), 0xfe10, {.d_s = to_sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node->pos);
			}
		} else {
			string type_name = v__ast__Table_type_to_str(c->table, from_type);
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot cast `"), 0xfe10, {.d_s = type_name}}, {_SLIT("` to struct"), 0, { .d_c = 0 }}})), node->pos);
		}
	} else if (to_sym->kind == v__ast__Kind__interface_) {
		if (v__checker__Checker_type_implements(c, from_type, to_type, node->pos)) {
			if (!v__ast__Type_is_ptr(from_type) && !v__ast__Type_is_pointer(from_type) && from_sym->kind != v__ast__Kind__interface_ && !c->inside_unsafe) {
				v__checker__Checker_mark_as_referenced(c, &node->expr, true);
			}
			if ((/* as */ *(v__ast__Interface*)__as_cast((to_sym->info)._v__ast__Interface,(to_sym->info)._typ, 463) /*expected idx: 463, name: v.ast.Interface */ ).is_generic) {
				v__ast__Type inferred_type = v__checker__Checker_resolve_generic_interface(c, from_type, to_type, node->pos);
				if (inferred_type != 0) {
					to_type = inferred_type;
					to_sym = v__ast__Table_sym(c->table, to_type);
					final_to_sym = v__ast__Table_final_sym(c->table, to_type);
				}
			}
		}
	} else if (v__ast__Type_alias_eq(to_type, _const_v__ast__bool_type) && !v__ast__Type_alias_eq(from_type, _const_v__ast__bool_type) && !c->inside_unsafe) {
		v__checker__Checker_error(c, _SLIT("cannot cast to bool - use e.g. `some_int != 0` instead"), node->pos);
	} else if (v__ast__Type_alias_eq(from_type, _const_v__ast__none_type) && !v__ast__Type_has_flag(to_type, v__ast__TypeFlag__optional)) {
		string type_name = v__ast__Table_type_to_str(c->table, to_type);
		v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot cast `none` to `"), 0xfe10, {.d_s = type_name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node->pos);
	} else if (from_sym->kind == v__ast__Kind__struct_ && !v__ast__Type_is_ptr(from_type)) {
		if ((v__ast__Type_is_ptr(to_type) || !(to_sym->kind == v__ast__Kind__sum_type || to_sym->kind == v__ast__Kind__interface_)) && !c->is_builtin_mod) {
			string from_type_name = v__ast__Table_type_to_str(c->table, from_type);
			string type_name = v__ast__Table_type_to_str(c->table, to_type);
			v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("cannot cast struct `"), 0xfe10, {.d_s = from_type_name}}, {_SLIT("` to `"), 0xfe10, {.d_s = type_name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node->pos);
		}
	} else if (to_sym->kind == v__ast__Kind__byte && !v__ast__TypeSymbol_is_number(final_from_sym) && !v__ast__TypeSymbol_is_pointer(final_from_sym) && !v__ast__Type_is_ptr(from_type) && !(final_from_sym->kind == v__ast__Kind__char || final_from_sym->kind == v__ast__Kind__enum_ || final_from_sym->kind == v__ast__Kind__bool)) {
		string type_name = v__ast__Table_type_to_str(c->table, from_type);
		v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot cast type `"), 0xfe10, {.d_s = type_name}}, {_SLIT("` to `byte`"), 0, { .d_c = 0 }}})), node->pos);
	} else if (v__ast__Type_has_flag(from_type, v__ast__TypeFlag__optional) || v__ast__Type_has_flag(from_type, v__ast__TypeFlag__variadic)) {
		string msg = (v__ast__Type_has_flag(from_type, v__ast__TypeFlag__optional) ? (_SLIT("an optional")) : (_SLIT("a variadic")));
		v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot type cast "), 0xfe10, {.d_s = msg}}, {_SLIT0, 0, { .d_c = 0 }}})), node->pos);
	} else if (!c->inside_unsafe && v__ast__Type_is_ptr(to_type) && v__ast__Type_is_ptr(from_type) && !v__ast__Type_alias_eq(v__ast__Type_deref(to_type), _const_v__ast__char_type) && !v__ast__Type_alias_eq(v__ast__Type_deref(from_type), _const_v__ast__char_type)) {
		string ft = v__ast__Table_type_to_str(c->table, from_type);
		string tt = v__ast__Table_type_to_str(c->table, to_type);
		v__checker__Checker_warn(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("casting `"), 0xfe10, {.d_s = ft}}, {_SLIT("` to `"), 0xfe10, {.d_s = tt}}, {_SLIT("` is only allowed in `unsafe` code"), 0, { .d_c = 0 }}})), node->pos);
	} else if (from_sym->kind == v__ast__Kind__array_fixed && !v__ast__Type_is_ptr(from_type)) {
		v__checker__Checker_warn(c, _SLIT("cannot cast a fixed array (use e.g. `&arr[0]` instead)"), node->pos);
	} else if (final_from_sym->kind == v__ast__Kind__string && v__ast__TypeSymbol_is_number(final_to_sym) && final_to_sym->kind != v__ast__Kind__rune) {
		string snexpr = v__ast__Expr_str(node->expr);
		v__checker__Checker_error(c,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("cannot cast string to `"), 0xfe10, {.d_s = to_sym->name}}, {_SLIT("`, use `"), 0xfe10, {.d_s = snexpr}}, {_SLIT("."), 0xfe10, {.d_s = final_to_sym->name}}, {_SLIT("()` instead."), 0, { .d_c = 0 }}})), node->pos);
	}
	if (v__ast__Type_alias_eq(to_type, _const_v__ast__string_type)) {
		if (from_type == _const_v__ast__byte_type || from_type == _const_v__ast__bool_type) {
			string snexpr = v__ast__Expr_str(node->expr);
			v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("cannot cast type `"), 0xfe10, {.d_s = from_sym->name}}, {_SLIT("` to string, use `"), 0xfe10, {.d_s = snexpr}}, {_SLIT(".str()` instead."), 0, { .d_c = 0 }}})), node->pos);
		} else if (v__ast__Type_is_real_pointer(from_type)) {
			string snexpr = v__ast__Expr_str(node->expr);
			v__checker__Checker_error(c,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("cannot cast pointer type `"), 0xfe10, {.d_s = from_sym->name}}, {_SLIT("` to string, use `&byte("), 0xfe10, {.d_s = snexpr}}, {_SLIT(").vstring()` or `cstring_to_vstring("), 0xfe10, {.d_s = snexpr}}, {_SLIT(")` instead."), 0, { .d_c = 0 }}})), node->pos);
		} else if (v__ast__Type_is_number(from_type)) {
			string snexpr = v__ast__Expr_str(node->expr);
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot cast number to string, use `"), 0xfe10, {.d_s = snexpr}}, {_SLIT(".str()` instead."), 0, { .d_c = 0 }}})), node->pos);
		} else if (from_sym->kind == v__ast__Kind__alias && !string__eq(final_from_sym->name, _SLIT("string"))) {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot cast type `"), 0xfe10, {.d_s = from_sym->name}}, {_SLIT("` to string, use `x.str()` instead."), 0, { .d_c = 0 }}})), node->pos);
		} else if (final_from_sym->kind == v__ast__Kind__array) {
			string snexpr = v__ast__Expr_str(node->expr);
			if (string__eq(final_from_sym->name, _SLIT("[]byte"))) {
				v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("cannot cast []byte to string, use `"), 0xfe10, {.d_s = snexpr}}, {_SLIT(".bytestr()` or `"), 0xfe10, {.d_s = snexpr}}, {_SLIT(".str()` instead."), 0, { .d_c = 0 }}})), node->pos);
			} else {
				string first_elem_idx = _SLIT("[0]");
				v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("cannot cast array to string, use `"), 0xfe10, {.d_s = snexpr}}, {_SLIT0, 0xfe10, {.d_s = first_elem_idx}}, {_SLIT(".str()` instead."), 0, { .d_c = 0 }}})), node->pos);
			}
		} else if (final_from_sym->kind == v__ast__Kind__enum_) {
			string snexpr = v__ast__Expr_str(node->expr);
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot cast enum to string, use "), 0xfe10, {.d_s = snexpr}}, {_SLIT(".str() instead."), 0, { .d_c = 0 }}})), node->pos);
		} else if (final_from_sym->kind == v__ast__Kind__map) {
			v__checker__Checker_error(c, _SLIT("cannot cast map to string."), node->pos);
		} else if (final_from_sym->kind == v__ast__Kind__sum_type) {
			string snexpr = v__ast__Expr_str(node->expr);
			v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("cannot cast sumtype `"), 0xfe10, {.d_s = from_sym->name}}, {_SLIT("` to string, use `"), 0xfe10, {.d_s = snexpr}}, {_SLIT(".str()` instead."), 0, { .d_c = 0 }}})), node->pos);
		} else if (!v__ast__Type_alias_eq(to_type, _const_v__ast__string_type) && v__ast__Type_alias_eq(from_type, _const_v__ast__string_type) && (!(to_sym->kind == v__ast__Kind__alias && string__eq(final_to_sym->name, _SLIT("string"))))) {
			string error_msg =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot cast a string to a type `"), 0xfe10, {.d_s = final_to_sym->name}}, {_SLIT("`, that is not an alias of string"), 0, { .d_c = 0 }}}));
			if ((node->expr)._typ == 323 /* v.ast.StringLiteral */) {
				if ((*node->expr._v__ast__StringLiteral).val.len == 1) {
					error_msg = /*f*/string__plus(error_msg,  str_intp(3, _MOV((StrIntpData[]){{_SLIT(", for denoting characters use `"), 0xfe10, {.d_s = (*node->expr._v__ast__StringLiteral).val}}, {_SLIT("` instead of '"), 0xfe10, {.d_s = (*node->expr._v__ast__StringLiteral).val}}, {_SLIT("'"), 0, { .d_c = 0 }}})));
				}
			}
			v__checker__Checker_error(c, error_msg, node->pos);
		}
	}
	if (node->has_arg) {
		v__checker__Checker_expr(c, node->arg);
	}
	if (to_sym->kind == v__ast__Kind__enum_) {
		if ((node->expr)._typ == 304 /* v.ast.IntegerLiteral */) {
			string enum_typ_name = v__ast__Table_get_type_name(c->table, to_type);
			int node_val = string_int((/* as */ *(v__ast__IntegerLiteral*)__as_cast((node->expr)._v__ast__IntegerLiteral,(node->expr)._typ, 304) /*expected idx: 304, name: v.ast.IntegerLiteral */ ).val);
			v__ast__EnumDecl* _t4 = (v__ast__EnumDecl*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, c->table->enum_decls), &(string[]){to_sym->name}));
			Option_v__ast__EnumDecl _t3 = {0};
			if (_t4) {
				*((v__ast__EnumDecl*)&_t3.data) = *((v__ast__EnumDecl*)_t4);
			} else {
				_t3.state = 2; _t3.err = _v_error(_SLIT("array index out of range"));
			}
			
			if (_t3.state == 0) {
				v__ast__EnumDecl enum_decl = *(v__ast__EnumDecl*)_t3.data;
				bool in_range = false;
				if (enum_decl.is_flag) {
					int max_val = (1 << enum_decl.fields.len) - 1;
					in_range = node_val >= 0 && node_val <= max_val;
				} else {
					int enum_val = 0;
					for (int _t5 = 0; _t5 < enum_decl.fields.len; ++_t5) {
						v__ast__EnumField enum_field = ((v__ast__EnumField*)enum_decl.fields.data)[_t5];
						if ((enum_field.expr)._typ == 304 /* v.ast.IntegerLiteral */) {
							enum_val = string_int((*enum_field.expr._v__ast__IntegerLiteral).val);
						}
						if (node_val == enum_val) {
							in_range = true;
							break;
						}
						enum_val += 1;
					}
				}
				if (!in_range) {
					v__checker__Checker_warn(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = node_val}}, {_SLIT(" does not represent a value of enum "), 0xfe10, {.d_s = enum_typ_name}}, {_SLIT0, 0, { .d_c = 0 }}})), node->pos);
				}
			}
		}
	}
	node->typname = v__ast__Table_sym(c->table, to_type)->name;
	v__ast__Type _t6 = to_type;
	return _t6;
}

VV_LOCAL_SYMBOL v__ast__Type v__checker__Checker_at_expr(v__checker__Checker* c, v__ast__AtExpr* node) {
	switch (node->kind) {
		case v__token__AtKind__fn_name: 
			{
				node->val = string_all_after_last(c->table->cur_fn->name, _SLIT("."));
			} break;
		case v__token__AtKind__method_name: 
			{
				string fname = string_all_after_last(c->table->cur_fn->name, _SLIT("."));
				if (c->table->cur_fn->is_method) {
					node->val = string__plus(string__plus(string_all_after_last(v__ast__Table_type_to_str(c->table, c->table->cur_fn->receiver.typ), _SLIT(".")), _SLIT(".")), fname);
				} else {
					node->val = fname;
				}
			} break;
		case v__token__AtKind__mod_name: 
			{
				node->val = c->table->cur_fn->mod;
			} break;
		case v__token__AtKind__struct_name: 
			{
				if (c->table->cur_fn->is_method) {
					node->val = string_all_after_last(v__ast__Table_type_to_str(c->table, c->table->cur_fn->receiver.typ), _SLIT("."));
				} else {
					node->val = _SLIT("");
				}
			} break;
		case v__token__AtKind__vexe_path: 
			{
				node->val = v__pref__vexe_path();
			} break;
		case v__token__AtKind__file_path: 
			{
				node->val = os__real_path(c->file->path);
			} break;
		case v__token__AtKind__line_nr: 
			{
				node->val = int_str((node->pos.line_nr + 1));
			} break;
		case v__token__AtKind__column_nr: 
			{
				node->val = int_str((node->pos.col + 1));
			} break;
		case v__token__AtKind__vhash: 
			{
				node->val = v__util__version__vhash();
			} break;
		case v__token__AtKind__vmod_file: 
			{
				if (c->vmod_file_content.len == 0) {
					v__vmod__ModFileCacher* mcache = v__vmod__get_cache();
					v__vmod__ModFileAndFolder vmod_file_location = v__vmod__ModFileCacher_get_by_file(mcache, c->file->path);
					if (vmod_file_location.vmod_file.len == 0) {
						v__checker__Checker_error(c, _SLIT("@VMOD_FILE can be used only in projects, that have v.mod file"), node->pos);
					}
					Option_string _t1 = os__read_file(vmod_file_location.vmod_file);
					if (_t1.state != 0) { /*or block*/ 
						IError err = _t1.err;
						*(string*) _t1.data = _SLIT("");
					}
					
 					string vmod_content =  (*(string*)_t1.data);
					c->vmod_file_content = string_replace(vmod_content, _SLIT("\r\n"), _SLIT("\n"));
				}
				node->val = c->vmod_file_content;
			} break;
		case v__token__AtKind__vroot_path: 
			{
				node->val = os__dir(v__pref__vexe_path());
			} break;
		case v__token__AtKind__vexeroot_path: 
			{
				node->val = os__dir(v__pref__vexe_path());
			} break;
		case v__token__AtKind__vmodroot_path: 
			{
				v__vmod__ModFileCacher* mcache = v__vmod__get_cache();
				v__vmod__ModFileAndFolder vmod_file_location = v__vmod__ModFileCacher_get_by_file(mcache, c->file->path);
				node->val = os__dir(vmod_file_location.vmod_file);
			} break;
		case v__token__AtKind__unknown: 
			{
				v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("unknown @ identifier: "), 0xfe10, {.d_s = node->name}}, {_SLIT(". Available identifiers: "), 0xfe10, {.d_s = Array_string_str(_const_v__token__valid_at_tokens)}}, {_SLIT0, 0, { .d_c = 0 }}})), node->pos);
			} break;
	}
	;
	v__ast__Type _t2 = _const_v__ast__string_type;
	return _t2;
}

v__ast__Type v__checker__Checker_ident(v__checker__Checker* c, v__ast__Ident* node) {
	if (c->const_deps.len > 0) {
		string name = node->name;
		if (!string_contains(name, _SLIT(".")) && !string__eq(node->mod, _SLIT("builtin"))) {
			name =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = node->mod}}, {_SLIT("."), 0xfe10, {.d_s = node->name}}, {_SLIT0, 0, { .d_c = 0 }}}));
		}
		if (string__eq(name, c->const_decl)) {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cycle in constant `"), 0xfe10, {.d_s = c->const_decl}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node->pos);
			v__ast__Type _t1 = _const_v__ast__void_type;
			return _t1;
		}
		array_push((array*)&c->const_deps, _MOV((string[]){ string_clone(name) }));
	}
	if (node->kind == v__ast__IdentKind__blank_ident) {
		if (!(node->tok_kind == v__token__Kind__assign || node->tok_kind == v__token__Kind__decl_assign)) {
			v__checker__Checker_error(c, _SLIT("undefined ident: `_` (may only be used in assignments)"), node->pos);
		}
		v__ast__Type _t3 = _const_v__ast__void_type;
		return _t3;
	}
	if (node->kind == v__ast__IdentKind__constant || node->kind == v__ast__IdentKind__global || node->kind == v__ast__IdentKind__variable) {
		v__ast__IdentVar info = /* as */ *(v__ast__IdentVar*)__as_cast((node->info)._v__ast__IdentVar,(node->info)._typ, 408) /*expected idx: 408, name: v.ast.IdentVar */ ;
		v__ast__Type _t4 = info.typ;
		return _t4;
	} else if (node->kind == v__ast__IdentKind__function) {
		v__ast__IdentFn info = /* as */ *(v__ast__IdentFn*)__as_cast((node->info)._v__ast__IdentFn,(node->info)._typ, 407) /*expected idx: 407, name: v.ast.IdentFn */ ;
		v__ast__Type _t5 = info.typ;
		return _t5;
	} else if (node->kind == v__ast__IdentKind__unresolved) {
		if (node->tok_kind == v__token__Kind__assign && node->is_mut) {
			v__checker__Checker_error(c, _SLIT("`mut` not allowed with `=` (use `:=` to declare a variable)"), node->pos);
		}
		Option_v__ast__ScopeObject _t6;
		if (_t6 = v__ast__Scope_find(node->scope, node->name), _t6.state == 0) {
			v__ast__ScopeObject obj = *(v__ast__ScopeObject*)_t6.data;
			if (obj._typ == 356 /* v.ast.GlobalField */) {
				node->kind = v__ast__IdentKind__global;
				node->info = v__ast__IdentVar_to_sumtype_v__ast__IdentInfo(ADDR(v__ast__IdentVar, ((v__ast__IdentVar){.typ = (*obj._v__ast__GlobalField).typ,.is_mut = 0,.is_static = 0,.is_volatile = 0,.is_optional = 0,.share = 0,})));
				node->obj = obj;
				v__ast__Type _t7 = (*obj._v__ast__GlobalField).typ;
				return _t7;
			}
			else if (obj._typ == 357 /* v.ast.Var */) {
				if (node->pos.pos < (*obj._v__ast__Var).pos.pos) {
					v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("undefined variable `"), 0xfe10, {.d_s = node->name}}, {_SLIT("` (used before declaration)"), 0, { .d_c = 0 }}})), node->pos);
				}
				bool is_sum_type_cast = (*obj._v__ast__Var).smartcasts.len != 0 && !c->prevent_sum_type_unwrapping_once;
				c->prevent_sum_type_unwrapping_once = false;
				v__ast__Type _t8; /* if prepend */
				if (is_sum_type_cast) {
					_t8 = (*(v__ast__Type*)array_last((*obj._v__ast__Var).smartcasts));
				} else {
					_t8 = (*obj._v__ast__Var).typ;
				}
				v__ast__Type typ =  _t8;
				if (typ == 0) {
					if (((*obj._v__ast__Var).expr)._typ == 299 /* v.ast.Ident */) {
						if ((*(*obj._v__ast__Var).expr._v__ast__Ident).kind == v__ast__IdentKind__unresolved) {
							v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unresolved variable: `"), 0xfe10, {.d_s = node->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node->pos);
							v__ast__Type _t9 = _const_v__ast__void_type;
							return _t9;
						}
					}
					if (((*obj._v__ast__Var).expr)._typ == 301 /* v.ast.IfGuardExpr */) {
						typ = v__ast__Type_clear_flag((*(*obj._v__ast__Var).expr._v__ast__IfGuardExpr).expr_type, v__ast__TypeFlag__optional);
					} else {
						typ = v__checker__Checker_expr(c, (*obj._v__ast__Var).expr);
					}
				}
				bool is_optional = v__ast__Type_has_flag(typ, v__ast__TypeFlag__optional);
				node->kind = v__ast__IdentKind__variable;
				node->info = v__ast__IdentVar_to_sumtype_v__ast__IdentInfo(ADDR(v__ast__IdentVar, ((v__ast__IdentVar){.typ = typ,.is_mut = 0,.is_static = 0,.is_volatile = 0,.is_optional = is_optional,.share = 0,})));
				if (v__ast__Type_alias_eq(typ, _const_v__ast__error_type) && v__ast__Type_alias_eq(c->expected_type, _const_v__ast__string_type) && !c->using_new_err_struct && !c->inside_selector_expr && !c->inside_println_arg && !string_contains(c->file->mod.name, _SLIT("v.")) && !c->is_builtin_mod) {
					v__checker__Checker_warn(c, _SLIT("string errors are deprecated; use `err.msg` instead"), node->pos);
				}
				if (!is_sum_type_cast) {
					(*obj._v__ast__Var).typ = typ;
				}
				node->obj = obj;
				if (is_optional) {
					v__ast__Type _t10 = v__ast__Type_clear_flag(typ, v__ast__TypeFlag__optional);
					return _t10;
				}
				v__ast__Type _t11 = typ;
				return _t11;
			}
			
			else {
			}
			;
		}
		string name = node->name;
		if (_IN_MAP(ADDR(string, name), ADDR(map, c->file->imported_symbols))) {
			name = (*(string*)map_get(ADDR(map, c->file->imported_symbols), &(string[]){name}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} }));
		} else if (!string_contains(name, _SLIT(".")) && !string__eq(node->mod, _SLIT("builtin"))) {
			name =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = node->mod}}, {_SLIT("."), 0xfe10, {.d_s = node->name}}, {_SLIT0, 0, { .d_c = 0 }}}));
		}
		Option_v__ast__ScopeObject _t12;
		if (_t12 = v__ast__Scope_find(c->file->global_scope, name), _t12.state == 0) {
			v__ast__ScopeObject obj = *(v__ast__ScopeObject*)_t12.data;
			if (obj._typ == 355 /* v.ast.ConstField */) {
				if (!((*obj._v__ast__ConstField).is_pub || string__eq((*obj._v__ast__ConstField).mod, c->mod) || c->pref->is_test)) {
					v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("constant `"), 0xfe10, {.d_s = (*obj._v__ast__ConstField).name}}, {_SLIT("` is private"), 0, { .d_c = 0 }}})), node->pos);
				}
				v__ast__Type typ = (*obj._v__ast__ConstField).typ;
				if (typ == 0) {
					string old_c_mod = c->mod;
					c->mod = (*obj._v__ast__ConstField).mod;
					c->inside_const = true;
					typ = v__checker__Checker_expr(c, (*obj._v__ast__ConstField).expr);
					c->inside_const = false;
					c->mod = old_c_mod;
					if (((*obj._v__ast__ConstField).expr)._typ == 286 /* v.ast.CallExpr */) {
						if ((*(*obj._v__ast__ConstField).expr._v__ast__CallExpr).or_block.kind != v__ast__OrKind__absent) {
							typ = v__ast__Type_clear_flag(typ, v__ast__TypeFlag__optional);
						}
					}
				}
				node->name = name;
				node->kind = v__ast__IdentKind__constant;
				node->info = v__ast__IdentVar_to_sumtype_v__ast__IdentInfo(ADDR(v__ast__IdentVar, ((v__ast__IdentVar){.typ = typ,.is_mut = 0,.is_static = 0,.is_volatile = 0,.is_optional = 0,.share = 0,})));
				(*obj._v__ast__ConstField).typ = typ;
				node->obj = obj;
				v__ast__Type _t13 = typ;
				return _t13;
			}
			
			else {
			}
			;
		}
		Option_v__ast__Fn _t14;
		if (_t14 = v__ast__Table_find_fn(c->table, name), _t14.state == 0) {
			v__ast__Fn func = *(v__ast__Fn*)_t14.data;
			v__ast__Type fn_type = v__ast__new_type(v__ast__Table_find_or_register_fn_type(c->table, node->mod, func, false, true));
			node->name = name;
			node->kind = v__ast__IdentKind__function;
			node->info = v__ast__IdentFn_to_sumtype_v__ast__IdentInfo(ADDR(v__ast__IdentFn, ((v__ast__IdentFn){.typ = fn_type,})));
			v__ast__Type _t15 = fn_type;
			return _t15;
		}
	}
	if (node->language == v__ast__Language__c) {
		if (string__eq(node->name, _SLIT("C.NULL"))) {
			v__ast__Type _t16 = _const_v__ast__voidptr_type;
			return _t16;
		}
		v__ast__Type _t17 = _const_v__ast__int_type;
		return _t17;
	}
	if (c->inside_sql) {
		Option_v__ast__StructField _t18;
		if (_t18 = v__ast__Table_find_field(c->table, (voidptr)&/*qq*/c->cur_orm_ts, node->name), _t18.state == 0) {
			v__ast__StructField field = *(v__ast__StructField*)_t18.data;
			v__ast__Type _t19 = field.typ;
			return _t19;
		}
	}
	if (node->kind == v__ast__IdentKind__unresolved && !string__eq(node->mod, _SLIT("builtin"))) {
		string saved_mod = node->mod;
		node->mod = _SLIT("builtin");
		v__ast__Type builtin_type = v__checker__Checker_ident(c, node);
		if (!v__ast__Type_alias_eq(builtin_type, _const_v__ast__void_type)) {
			v__ast__Type _t20 = builtin_type;
			return _t20;
		}
		node->mod = saved_mod;
	}
	if (node->tok_kind == v__token__Kind__assign) {
		v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("undefined ident: `"), 0xfe10, {.d_s = node->name}}, {_SLIT("` (use `:=` to declare a variable)"), 0, { .d_c = 0 }}})), node->pos);
	} else if (string__eq(node->name, _SLIT("errcode"))) {
		v__checker__Checker_error(c, _SLIT("undefined ident: `errcode`; did you mean `err.code`?"), node->pos);
	} else {
		if (c->inside_ct_attr) {
			v__checker__Checker_note(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("`[if "), 0xfe10, {.d_s = node->name}}, {_SLIT("]` is deprecated. Use `[if "), 0xfe10, {.d_s = node->name}}, {_SLIT("?]` instead"), 0, { .d_c = 0 }}})), node->pos);
		} else {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("undefined ident: `"), 0xfe10, {.d_s = node->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node->pos);
		}
	}
	if (v__ast__Table_known_type(c->table, node->name)) {
		v__ast__Type _t21 = _const_v__ast__void_type;
		return _t21;
	}
	v__ast__Type _t22 = _const_v__ast__void_type;
	return _t22;
}

v__ast__Type v__checker__Checker_concat_expr(v__checker__Checker* c, v__ast__ConcatExpr* node) {
	Array_v__ast__Type mr_types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
	for (int _t1 = 0; _t1 < node->vals.len; ++_t1) {
		v__ast__Expr expr = ((v__ast__Expr*)node->vals.data)[_t1];
		array_push((array*)&mr_types, _MOV((v__ast__Type[]){ v__checker__Checker_expr(c, expr) }));
	}
	if (node->vals.len == 1) {
		v__ast__Type typ = (*(v__ast__Type*)/*ee elem_typ */array_get(mr_types, 0));
		node->return_type = typ;
		v__ast__Type _t3 = typ;
		return _t3;
	} else {
		int typ = v__ast__Table_find_or_register_multi_return(c->table, mr_types);
		v__ast__new_type(typ);
		node->return_type = typ;
		v__ast__Type _t4 = typ;
		return _t4;
	}
	return 0;
}

VV_LOCAL_SYMBOL void v__checker__Checker_smartcast(v__checker__Checker* c, v__ast__Expr expr, v__ast__Type cur_type, v__ast__Type to_type_, v__ast__Scope* scope) {
	v__ast__TypeSymbol* sym = v__ast__Table_sym(c->table, cur_type);
	v__ast__Type to_type = (sym->kind == v__ast__Kind__interface_ ? (v__ast__Type_ref(to_type_)) : (to_type_));
	if (expr._typ == 319 /* v.ast.SelectorExpr */) {
		bool is_mut = false;
		Array_v__ast__Type smartcasts = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
		v__ast__TypeSymbol* expr_sym = v__ast__Table_sym(c->table, (*expr._v__ast__SelectorExpr).expr_type);
		int orig_type = 0;
		Option_v__ast__StructField _t1;
		if (_t1 = v__ast__Table_find_field(c->table, expr_sym, (*expr._v__ast__SelectorExpr).field_name), _t1.state == 0) {
			v__ast__StructField field = *(v__ast__StructField*)_t1.data;
			if (field.is_mut) {
				Option_v__ast__Ident _t2;
				if (_t2 = v__ast__SelectorExpr_root_ident(&(*expr._v__ast__SelectorExpr)), _t2.state == 0) {
					v__ast__Ident root_ident = *(v__ast__Ident*)_t2.data;
					Option_v__ast__Var_ptr _t3;
					if (_t3 = v__ast__Scope_find_var(scope, root_ident.name), _t3.state == 0) {
						v__ast__Var* v = *(v__ast__Var**)_t3.data;
						is_mut = v->is_mut;
					}
				}
			}
			if (orig_type == 0) {
				orig_type = field.typ;
			}
		}
		Option_v__ast__ScopeStructField _t4;
		if (_t4 = v__ast__Scope_find_struct_field(scope, v__ast__Expr_str((*expr._v__ast__SelectorExpr).expr), (*expr._v__ast__SelectorExpr).expr_type, (*expr._v__ast__SelectorExpr).field_name), _t4.state == 0) {
			v__ast__ScopeStructField field = *(v__ast__ScopeStructField*)_t4.data;
			_PUSH_MANY(&smartcasts, (field.smartcasts), _t5, Array_v__ast__Type);
		}
		if (!is_mut || (*expr._v__ast__SelectorExpr).is_mut) {
			array_push((array*)&smartcasts, _MOV((v__ast__Type[]){ to_type }));
			v__ast__Scope_register_struct_field(scope, v__ast__Expr_str((*expr._v__ast__SelectorExpr).expr), (v__ast__ScopeStructField){
				.struct_type = (*expr._v__ast__SelectorExpr).expr_type,
				.name = (*expr._v__ast__SelectorExpr).field_name,
				.pos = (*expr._v__ast__SelectorExpr).pos,
				.typ = cur_type,
				.smartcasts = smartcasts,
				.orig_type = orig_type,
			});
		}
	}
	else if (expr._typ == 299 /* v.ast.Ident */) {
		bool is_mut = false;
		Array_v__ast__Type smartcasts = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
		bool is_already_casted = false;
		int orig_type = 0;
		if (((*expr._v__ast__Ident).obj)._typ == 357 /* v.ast.Var */) {
			is_mut = (*(*expr._v__ast__Ident).obj._v__ast__Var).is_mut;
			_PUSH_MANY(&smartcasts, ((*(*expr._v__ast__Ident).obj._v__ast__Var).smartcasts), _t7, Array_v__ast__Type);
			is_already_casted = (*(*expr._v__ast__Ident).obj._v__ast__Var).pos.pos == (*expr._v__ast__Ident).pos.pos;
			if (orig_type == 0) {
				orig_type = (*(*expr._v__ast__Ident).obj._v__ast__Var).typ;
			}
		}
		if ((!is_mut || (*expr._v__ast__Ident).is_mut) && !is_already_casted) {
			array_push((array*)&smartcasts, _MOV((v__ast__Type[]){ to_type }));
			v__ast__Scope_register(scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){
				.name = (*expr._v__ast__Ident).name,
				.expr = {0},
				.share = 0,
				.is_mut = (*expr._v__ast__Ident).is_mut,
				.is_autofree_tmp = 0,
				.is_arg = 0,
				.is_auto_deref = 0,
				.is_inherited = 0,
				.typ = cur_type,
				.orig_type = orig_type,
				.smartcasts = smartcasts,
				.pos = (*expr._v__ast__Ident).pos,
				.is_used = true,
				.is_changed = 0,
				.is_or = 0,
				.is_tmp = 0,
				.is_auto_heap = 0,
				.is_stack_obj = 0,
			}))));
		}
	}
	
	else {
	}
	;
}

v__ast__Type v__checker__Checker_select_expr(v__checker__Checker* c, v__ast__SelectExpr* node) {
	node->is_expr = !v__ast__Type_alias_eq(c->expected_type, _const_v__ast__void_type);
	node->expected_type = c->expected_type;
	for (int _t1 = 0; _t1 < node->branches.len; ++_t1) {
		v__ast__SelectBranch branch = ((v__ast__SelectBranch*)node->branches.data)[_t1];
		v__checker__Checker_stmt(c, branch.stmt);
		if (branch.stmt._typ == 339 /* v.ast.ExprStmt */) {
			if (branch.is_timeout) {
				if (!v__ast__Type_is_int((*branch.stmt._v__ast__ExprStmt).typ)) {
					v__ast__TypeSymbol* tsym = v__ast__Table_sym(c->table, (*branch.stmt._v__ast__ExprStmt).typ);
					v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("invalid type `"), 0xfe10, {.d_s = tsym->name}}, {_SLIT("` for timeout - expected integer number of nanoseconds aka `time.Duration`"), 0, { .d_c = 0 }}})), (*branch.stmt._v__ast__ExprStmt).pos);
				}
			} else {
				if (((*branch.stmt._v__ast__ExprStmt).expr)._typ == 303 /* v.ast.InfixExpr */) {
					if (((*(*branch.stmt._v__ast__ExprStmt).expr._v__ast__InfixExpr).left)._typ != 299 /* v.ast.Ident */ && ((*(*branch.stmt._v__ast__ExprStmt).expr._v__ast__InfixExpr).left)._typ != 319 /* v.ast.SelectorExpr */ && ((*(*branch.stmt._v__ast__ExprStmt).expr._v__ast__InfixExpr).left)._typ != 302 /* v.ast.IndexExpr */) {
						v__checker__Checker_error(c, _SLIT("channel in `select` key must be predefined"), v__ast__Expr_position((*(*branch.stmt._v__ast__ExprStmt).expr._v__ast__InfixExpr).left));
					}
				} else {
					v__checker__Checker_error(c, _SLIT("invalid expression for `select` key"), v__ast__Expr_position((*branch.stmt._v__ast__ExprStmt).expr));
				}
			}
		}
		else if (branch.stmt._typ == 331 /* v.ast.AssignStmt */) {
			v__ast__Expr expr = (*(v__ast__Expr*)/*ee elem_typ */array_get((*branch.stmt._v__ast__AssignStmt).right, 0));
			if (expr._typ == 316 /* v.ast.PrefixExpr */) {
				if (((*expr._v__ast__PrefixExpr).right)._typ != 299 /* v.ast.Ident */ && ((*expr._v__ast__PrefixExpr).right)._typ != 319 /* v.ast.SelectorExpr */ && ((*expr._v__ast__PrefixExpr).right)._typ != 302 /* v.ast.IndexExpr */) {
					v__checker__Checker_error(c, _SLIT("channel in `select` key must be predefined"), v__ast__Expr_position((*expr._v__ast__PrefixExpr).right));
				}
				if ((*expr._v__ast__PrefixExpr).or_block.kind != v__ast__OrKind__absent) {
					string err_prefix = ((*expr._v__ast__PrefixExpr).or_block.kind == v__ast__OrKind__block ? (_SLIT("or block")) : (_SLIT("error propagation")));
					v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = err_prefix}}, {_SLIT(" not allowed in `select` key"), 0, { .d_c = 0 }}})), (*expr._v__ast__PrefixExpr).or_block.pos);
				}
			}
			
			else {
				v__checker__Checker_error(c, _SLIT("`<-` receive expression expected"), v__ast__Expr_position((*(v__ast__Expr*)/*ee elem_typ */array_get((*branch.stmt._v__ast__AssignStmt).right, 0))));
			}
			;
		}
		
		else {
			if (!branch.is_else) {
				v__checker__Checker_error(c, _SLIT("receive or send statement expected as `select` key"), (*(branch.stmt.pos)));
			}
		}
		;
		v__checker__Checker_stmts(c, branch.stmts);
	}
	v__ast__Type _t2 = _const_v__ast__bool_type;
	return _t2;
}

v__ast__Type v__checker__Checker_lock_expr(v__checker__Checker* c, v__ast__LockExpr* node) {
	if (c->rlocked_names.len > 0 || c->locked_names.len > 0) {
		v__checker__Checker_error(c, _SLIT("nested `lock`/`rlock` not allowed"), node->pos);
	}
	for (int i = 0; i < node->lockeds.len; ++i) {
		v__ast__Type e_typ = v__checker__Checker_expr(c, (*(v__ast__Expr*)/*ee elem_typ */array_get(node->lockeds, i)));
		string id_name = v__ast__Expr_str((*(v__ast__Expr*)/*ee elem_typ */array_get(node->lockeds, i)));
		if (!v__ast__Type_has_flag(e_typ, v__ast__TypeFlag__shared_f)) {
			string obj_type = (((*(v__ast__Expr*)/*ee elem_typ */array_get(node->lockeds, i)))._typ == 299 /* v.ast.Ident */ ? (_SLIT("variable")) : (_SLIT("struct element")));
			v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = id_name}}, {_SLIT("` must be declared as `shared` "), 0xfe10, {.d_s = obj_type}}, {_SLIT(" to be locked"), 0, { .d_c = 0 }}})), v__ast__Expr_position((*(v__ast__Expr*)/*ee elem_typ */array_get(node->lockeds, i))));
		}
		if (Array_string_contains(c->locked_names, id_name)) {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = id_name}}, {_SLIT("` is already locked"), 0, { .d_c = 0 }}})), v__ast__Expr_position((*(v__ast__Expr*)/*ee elem_typ */array_get(node->lockeds, i))));
		} else if (Array_string_contains(c->rlocked_names, id_name)) {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = id_name}}, {_SLIT("` is already read-locked"), 0, { .d_c = 0 }}})), v__ast__Expr_position((*(v__ast__Expr*)/*ee elem_typ */array_get(node->lockeds, i))));
		}
		if ((*(bool*)/*ee elem_typ */array_get(node->is_rlock, i))) {
			array_push((array*)&c->rlocked_names, _MOV((string[]){ string_clone(id_name) }));
		} else {
			array_push((array*)&c->locked_names, _MOV((string[]){ string_clone(id_name) }));
		}
	}
	v__checker__Checker_stmts(c, node->stmts);
	c->rlocked_names = __new_array_with_default(0, 0, sizeof(string), 0);
	c->locked_names = __new_array_with_default(0, 0, sizeof(string), 0);
	v__ast__Type ret_type = _const_v__ast__void_type;
	if (node->stmts.len > 0) {
		v__ast__Stmt last_stmt = (*(v__ast__Stmt*)/*ee elem_typ */array_get(node->stmts, node->stmts.len - 1));
		if ((last_stmt)._typ == 339 /* v.ast.ExprStmt */) {
			ret_type = (*last_stmt._v__ast__ExprStmt).typ;
		}
	}
	if (!v__ast__Type_alias_eq(ret_type, _const_v__ast__void_type)) {
		node->is_expr = true;
	}
	node->typ = ret_type;
	v__ast__Type _t3 = ret_type;
	return _t3;
}

v__ast__Type v__checker__Checker_unsafe_expr(v__checker__Checker* c, v__ast__UnsafeExpr* node) {
	c->inside_unsafe = true;
	v__ast__Type t = v__checker__Checker_expr(c, node->expr);
	c->inside_unsafe = false;
	v__ast__Type _t1 = t;
	return _t1;
}

VV_LOCAL_SYMBOL Option_v__ast__Expr v__checker__Checker_find_definition(v__checker__Checker* c, v__ast__Ident ident) {

	if (ident.kind == (v__ast__IdentKind__unresolved) || ident.kind == (v__ast__IdentKind__blank_ident)) {
		return (Option_v__ast__Expr){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	else if (ident.kind == (v__ast__IdentKind__variable) || ident.kind == (v__ast__IdentKind__constant)) {
		Option_v__ast__Expr _t2 = v__checker__Checker_find_obj_definition(c, ident.obj);
		return _t2;
	}
	else if (ident.kind == (v__ast__IdentKind__global)) {
		return (Option_v__ast__Expr){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ident.name}}, {_SLIT(" is a global variable"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	else if (ident.kind == (v__ast__IdentKind__function)) {
		return (Option_v__ast__Expr){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ident.name}}, {_SLIT(" is a function"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	};
	return (Option_v__ast__Expr){0};
}

VV_LOCAL_SYMBOL Option_v__ast__Expr v__checker__Checker_find_obj_definition(v__checker__Checker* c, v__ast__ScopeObject obj) {
	string name = _SLIT("");
	if (obj._typ == 357 /* v.ast.Var */) {
		name = (*obj._v__ast__Var).name;
	}
	else if (obj._typ == 355 /* v.ast.ConstField */) {
		name = (*obj._v__ast__ConstField).name;
	}
	else if (obj._typ == 356 /* v.ast.GlobalField */) {
		name = (*obj._v__ast__GlobalField).name;
	}
	else if (obj._typ == 354 /* v.ast.AsmRegister */) {
		name = (*obj._v__ast__AsmRegister).name;
	}
	;
	v__ast__Expr expr = v__ast__empty_expr();
	if ((obj)._typ == 357 /* v.ast.Var */) {
		if ((*obj._v__ast__Var).is_mut) {
			return (Option_v__ast__Expr){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = name}}, {_SLIT("` is mut and may have changed since its definition"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		expr = (*obj._v__ast__Var).expr;
	} else if ((obj)._typ == 355 /* v.ast.ConstField */) {
		expr = (*obj._v__ast__ConstField).expr;
	} else {
		return (Option_v__ast__Expr){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = name}}, {_SLIT("` is a global variable and is unknown at compile time"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if ((expr)._typ == 299 /* v.ast.Ident */) {
		Option_v__ast__Expr _t3 = v__checker__Checker_find_definition(c, /* as */ *(v__ast__Ident*)__as_cast((expr)._v__ast__Ident,(expr)._typ, 299) /*expected idx: 299, name: v.ast.Ident */ );
		return _t3;
	}
	if (!v__ast__Expr_is_lit(expr)) {
		return (Option_v__ast__Expr){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("definition of `"), 0xfe10, {.d_s = name}}, {_SLIT("` is unknown at compile time"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Option_v__ast__Expr _t5;
	opt_ok(&(v__ast__Expr[]) { expr }, (Option*)(&_t5), sizeof(v__ast__Expr));
	return _t5;
}

VV_LOCAL_SYMBOL Option_bool v__checker__Checker_has_return(v__checker__Checker* c, Array_v__ast__Stmt stmts) {
	bool has_complexity = false;
	for (int _t1 = 0; _t1 < stmts.len; ++_t1) {
		v__ast__Stmt s = ((v__ast__Stmt*)stmts.data)[_t1];
		if ((s)._typ == 339 /* v.ast.ExprStmt */) {
			if (((*s._v__ast__ExprStmt).expr)._typ == 300 /* v.ast.IfExpr */ || ((*s._v__ast__ExprStmt).expr)._typ == 309 /* v.ast.MatchExpr */) {
				has_complexity = true;
				break;
			}
		}
	}
	if (!has_complexity || !c->returns) {
		Option_bool _t2;
		opt_ok(&(bool[]) { v__checker__has_top_return(stmts) }, (Option*)(&_t2), sizeof(bool));
		return _t2;
	}
	return (Option_bool){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
}

v__ast__Type v__checker__Checker_postfix_expr(v__checker__Checker* c, v__ast__PostfixExpr* node) {
	v__ast__Type typ = v__checker__Checker_unwrap_generic(c, v__checker__Checker_expr(c, node->expr));
	v__ast__TypeSymbol* typ_sym = v__ast__Table_sym(c->table, typ);
	bool is_non_void_pointer = (v__ast__Type_is_ptr(typ) || v__ast__Type_is_pointer(typ)) && typ_sym->kind != v__ast__Kind__voidptr;
	if (!c->inside_unsafe && is_non_void_pointer && !v__ast__Expr_is_auto_deref_var(node->expr)) {
		v__checker__Checker_warn(c, _SLIT("pointer arithmetic is only allowed in `unsafe` blocks"), node->pos);
	}
	if (!(v__ast__TypeSymbol_is_number(typ_sym) || (c->inside_unsafe && is_non_void_pointer))) {
		v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("invalid operation: "), 0xfe10, {.d_s = v__token__Kind_str(node->op)}}, {_SLIT(" (non-numeric type `"), 0xfe10, {.d_s = typ_sym->name}}, {_SLIT("`)"), 0, { .d_c = 0 }}})), node->pos);
	} else {
		multi_return_string_v__token__Position mr_105702 = v__checker__Checker_fail_if_immutable(c, node->expr);
		node->auto_locked = mr_105702.arg0;
	}
	v__ast__Type _t1 = typ;
	return _t1;
}

void v__checker__Checker_mark_as_referenced(v__checker__Checker* c, v__ast__Expr* node, bool as_interface) {
	if (node->_typ == 299 /* v.ast.Ident */) {
		if (((*node->_v__ast__Ident).obj)._typ == 357 /* v.ast.Var */) {
			v__ast__Var* obj = &(*(*node->_v__ast__Ident).obj._v__ast__Var);
			if (c->fn_scope != ((voidptr)(0))) {
				Option_v__ast__Var_ptr _t1 = v__ast__Scope_find_var(c->fn_scope, (*(*node->_v__ast__Ident).obj._v__ast__Var).name);
				if (_t1.state != 0) { /*or block*/ 
					IError err = _t1.err;
					*(v__ast__Var**) _t1.data = obj;
				}
				
 				obj =  (*(v__ast__Var**)_t1.data);
			}
			v__ast__TypeSymbol* type_sym = v__ast__Table_sym(c->table, v__ast__Type_set_nr_muls(obj->typ, 0));
			if (obj->is_stack_obj && !v__ast__TypeSymbol_is_heap(type_sym) && !c->pref->translated) {
				string suggestion = (type_sym->kind == v__ast__Kind__struct_ ? ( str_intp(2, _MOV((StrIntpData[]){{_SLIT("declaring `"), 0xfe10, {.d_s = type_sym->name}}, {_SLIT("` as `[heap]`"), 0, { .d_c = 0 }}}))) : ( str_intp(2, _MOV((StrIntpData[]){{_SLIT("wrapping the `"), 0xfe10, {.d_s = type_sym->name}}, {_SLIT("` object in a `struct` declared as `[heap]`"), 0, { .d_c = 0 }}}))));
				if (!c->pref->translated) {
					string mischief = (as_interface ? (_SLIT("used as interface object")) : (_SLIT("referenced")));
					v__checker__Checker_error(c,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = (*node->_v__ast__Ident).name}}, {_SLIT("` cannot be "), 0xfe10, {.d_s = mischief}}, {_SLIT(" outside `unsafe` blocks as it might be stored on stack. Consider "), 0xfe10, {.d_s = suggestion}}, {_SLIT("."), 0, { .d_c = 0 }}})), (*node->_v__ast__Ident).pos);
				}
			} else if (type_sym->kind == v__ast__Kind__array_fixed) {
				v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot reference fixed array `"), 0xfe10, {.d_s = (*node->_v__ast__Ident).name}}, {_SLIT("` outside `unsafe` blocks as it is supposed to be stored on stack"), 0, { .d_c = 0 }}})), (*node->_v__ast__Ident).pos);
			} else {

				if (type_sym->kind == (v__ast__Kind__struct_)) {
					v__ast__Struct info = /* as */ *(v__ast__Struct*)__as_cast((type_sym->info)._v__ast__Struct,(type_sym->info)._typ, 446) /*expected idx: 446, name: v.ast.Struct */ ;
					if (!info.is_heap) {
						(*(*node->_v__ast__Ident).obj._v__ast__Var).is_auto_heap = true;
					}
				}
				else {
					(*(*node->_v__ast__Ident).obj._v__ast__Var).is_auto_heap = true;
				};
			}
		}
	}
	else if (node->_typ == 319 /* v.ast.SelectorExpr */) {
		if (!v__ast__Type_is_ptr((*node->_v__ast__SelectorExpr).expr_type)) {
			v__checker__Checker_mark_as_referenced(c, &(*node->_v__ast__SelectorExpr).expr, as_interface);
		}
	}
	else if (node->_typ == 302 /* v.ast.IndexExpr */) {
		v__checker__Checker_mark_as_referenced(c, &(*node->_v__ast__IndexExpr).left, as_interface);
	}
	
	else {
	}
	;
}

string v__checker__Checker_get_base_name(v__checker__Checker* c, v__ast__Expr* node) {
	if (node->_typ == 299 /* v.ast.Ident */) {
		string _t1 = (*node->_v__ast__Ident).name;
		return _t1;
	}
	else if (node->_typ == 319 /* v.ast.SelectorExpr */) {
		string _t2 = v__checker__Checker_get_base_name(c, &(*node->_v__ast__SelectorExpr).expr);
		return _t2;
	}
	else if (node->_typ == 302 /* v.ast.IndexExpr */) {
		string _t3 = v__checker__Checker_get_base_name(c, &(*node->_v__ast__IndexExpr).left);
		return _t3;
	}
	
	else {
		string _t4 = _SLIT("");
		return _t4;
	}
	;
	return (string){.str=(byteptr)"", .is_lit=1};
}

v__ast__Type v__checker__Checker_prefix_expr(v__checker__Checker* c, v__ast__PrefixExpr* node) {
	bool old_inside_ref_lit = c->inside_ref_lit;
	c->inside_ref_lit = c->inside_ref_lit || node->op == v__token__Kind__amp;
	v__ast__Type right_type = v__checker__Checker_expr(c, node->right);
	c->inside_ref_lit = old_inside_ref_lit;
	node->right_type = right_type;
	if (node->op == v__token__Kind__amp) {
		if ((node->right)._typ == 316 /* v.ast.PrefixExpr */) {
			if ((*node->right._v__ast__PrefixExpr).op == v__token__Kind__amp) {
				v__checker__Checker_error(c, _SLIT("unexpected `&`, expecting expression"), (*node->right._v__ast__PrefixExpr).pos);
			}
		}
	}
	if (node->op == v__token__Kind__amp && !v__ast__Type_is_ptr(right_type)) {
		v__ast__Expr expr = node->right;
		for (;;) {
			if (!((expr)._typ == 314 /* v.ast.ParExpr */)) break;
			expr = (*expr._v__ast__ParExpr).expr;
		}
		if (expr._typ == 284 /* v.ast.BoolLiteral */) {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot take the address of "), 0xfe10, {.d_s = v__ast__Expr_str(expr)}}, {_SLIT0, 0, { .d_c = 0 }}})), node->pos);
		}
		else if (expr._typ == 286 /* v.ast.CallExpr */) {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot take the address of "), 0xfe10, {.d_s = v__ast__Expr_str(expr)}}, {_SLIT0, 0, { .d_c = 0 }}})), node->pos);
		}
		else if (expr._typ == 289 /* v.ast.CharLiteral */) {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot take the address of "), 0xfe10, {.d_s = v__ast__Expr_str(expr)}}, {_SLIT0, 0, { .d_c = 0 }}})), node->pos);
		}
		else if (expr._typ == 297 /* v.ast.FloatLiteral */) {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot take the address of "), 0xfe10, {.d_s = v__ast__Expr_str(expr)}}, {_SLIT0, 0, { .d_c = 0 }}})), node->pos);
		}
		else if (expr._typ == 304 /* v.ast.IntegerLiteral */) {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot take the address of "), 0xfe10, {.d_s = v__ast__Expr_str(expr)}}, {_SLIT0, 0, { .d_c = 0 }}})), node->pos);
		}
		else if (expr._typ == 303 /* v.ast.InfixExpr */) {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot take the address of "), 0xfe10, {.d_s = v__ast__Expr_str(expr)}}, {_SLIT0, 0, { .d_c = 0 }}})), node->pos);
		}
		else if (expr._typ == 323 /* v.ast.StringLiteral */) {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot take the address of "), 0xfe10, {.d_s = v__ast__Expr_str(expr)}}, {_SLIT0, 0, { .d_c = 0 }}})), node->pos);
		}
		else if (expr._typ == 322 /* v.ast.StringInterLiteral */) {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot take the address of "), 0xfe10, {.d_s = v__ast__Expr_str(expr)}}, {_SLIT0, 0, { .d_c = 0 }}})), node->pos);
		}
		
		else {
		}
		;
		if ((node->right)._typ == 302 /* v.ast.IndexExpr */) {
			v__ast__TypeSymbol* typ_sym = v__ast__Table_sym(c->table, (*node->right._v__ast__IndexExpr).left_type);
			bool is_mut = false;
			if (((*node->right._v__ast__IndexExpr).left)._typ == 299 /* v.ast.Ident */) {
				v__ast__Ident ident = (*(*node->right._v__ast__IndexExpr).left._v__ast__Ident);
				v__ast__ScopeObject ident_obj = ident.obj;
				if ((ident_obj)._typ == 357 /* v.ast.Var */) {
					is_mut = (*ident_obj._v__ast__Var).is_mut;
				}
			}
			if (typ_sym->kind == v__ast__Kind__map) {
				v__checker__Checker_error(c, _SLIT("cannot take the address of map values"), (*node->right._v__ast__IndexExpr).pos);
			}
			if (!c->inside_unsafe) {
				if (typ_sym->kind == v__ast__Kind__array && is_mut) {
					v__checker__Checker_error(c, _SLIT("cannot take the address of mutable array elements outside unsafe blocks"), (*node->right._v__ast__IndexExpr).pos);
				}
			}
		}
		if (!c->inside_fn_arg && !c->inside_unsafe) {
			v__checker__Checker_mark_as_referenced(c, &node->right, false);
		}
		v__ast__Type _t1 = v__ast__Type_ref(right_type);
		return _t1;
	} else if (node->op == v__token__Kind__amp && (node->right)._typ != 287 /* v.ast.CastExpr */) {
		if (!c->inside_fn_arg && !c->inside_unsafe) {
			v__checker__Checker_mark_as_referenced(c, &node->right, false);
		}
		if (v__ast__Expr_is_auto_deref_var(node->right)) {
			v__ast__Type _t2 = right_type;
			return _t2;
		} else {
			v__ast__Type _t3 = v__ast__Type_ref(right_type);
			return _t3;
		}
	}
	if (node->op == v__token__Kind__mul) {
		if (v__ast__Type_is_ptr(right_type)) {
			v__ast__Type _t4 = v__ast__Type_deref(right_type);
			return _t4;
		}
		if (!v__ast__Type_is_pointer(right_type) && !c->pref->translated) {
			string s = v__ast__Table_type_to_str(c->table, right_type);
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("invalid indirect of `"), 0xfe10, {.d_s = s}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node->pos);
		}
	}
	if (node->op == v__token__Kind__bit_not && !v__ast__Type_is_int(right_type) && !c->pref->translated) {
		v__checker__Checker_error(c, _SLIT("operator ~ only defined on int types"), node->pos);
	}
	if (node->op == v__token__Kind__not && right_type != _const_v__ast__bool_type_idx && !c->pref->translated) {
		v__checker__Checker_error(c, _SLIT("! operator can only be used with bool types"), node->pos);
	}
	v__ast__TypeSymbol* right_sym = v__ast__Table_final_sym(c->table, v__checker__Checker_unwrap_generic(c, right_type));
	if (node->op == v__token__Kind__minus && !v__ast__TypeSymbol_is_number(right_sym)) {
		v__checker__Checker_error(c, _SLIT("- operator can only be used with numeric types"), node->pos);
	}
	if (node->op == v__token__Kind__arrow) {
		if (right_sym->kind == v__ast__Kind__chan) {
			v__checker__Checker_stmts_ending_with_expression(c, node->or_block.stmts);
			v__ast__Type _t5 = v__ast__TypeSymbol_chan_info(right_sym).elem_type;
			return _t5;
		}
		v__checker__Checker_error(c, _SLIT("<- operator can only be used with `chan` types"), node->pos);
	}
	v__ast__Type _t6 = right_type;
	return _t6;
}

VV_LOCAL_SYMBOL void v__checker__Checker_check_index(v__checker__Checker* c, v__ast__TypeSymbol* typ_sym, v__ast__Expr index, v__ast__Type index_type, v__token__Position pos, bool range_index, bool is_gated) {
	v__ast__TypeSymbol* index_type_sym = v__ast__Table_sym(c->table, index_type);
	if (typ_sym->kind == v__ast__Kind__array || typ_sym->kind == v__ast__Kind__array_fixed || typ_sym->kind == v__ast__Kind__string) {
		if (!(v__ast__Type_is_int(index_type) || index_type_sym->kind == v__ast__Kind__enum_)) {
			string type_str = (typ_sym->kind == v__ast__Kind__string ? ( str_intp(2, _MOV((StrIntpData[]){{_SLIT("non-integer string index `"), 0xfe10, {.d_s = index_type_sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}}))) : ( str_intp(3, _MOV((StrIntpData[]){{_SLIT("non-integer index `"), 0xfe10, {.d_s = index_type_sym->name}}, {_SLIT("` (array type `"), 0xfe10, {.d_s = typ_sym->name}}, {_SLIT("`)"), 0, { .d_c = 0 }}}))));
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = type_str}}, {_SLIT0, 0, { .d_c = 0 }}})), pos);
		}
		if ((index)._typ == 304 /* v.ast.IntegerLiteral */ && !is_gated) {
			if (string_at((*index._v__ast__IntegerLiteral).val, 0) == '-') {
				v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("negative index `"), 0xfe10, {.d_s = (*index._v__ast__IntegerLiteral).val}}, {_SLIT("`"), 0, { .d_c = 0 }}})), (*index._v__ast__IntegerLiteral).pos);
			} else if (typ_sym->kind == v__ast__Kind__array_fixed) {
				int i = string_int((*index._v__ast__IntegerLiteral).val);
				v__ast__ArrayFixed info = /* as */ *(v__ast__ArrayFixed*)__as_cast((typ_sym->info)._v__ast__ArrayFixed,(typ_sym->info)._typ, 468) /*expected idx: 468, name: v.ast.ArrayFixed */ ;
				if ((!range_index && i >= info.size) || (range_index && i > info.size)) {
					v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("index out of range (index: "), 0xfe07, {.d_i32 = i}}, {_SLIT(", len: "), 0xfe07, {.d_i32 = info.size}}, {_SLIT(")"), 0, { .d_c = 0 }}})), (*index._v__ast__IntegerLiteral).pos);
				}
			}
		}
		if (v__ast__Type_has_flag(index_type, v__ast__TypeFlag__optional)) {
			string type_str = (typ_sym->kind == v__ast__Kind__string ? ( str_intp(2, _MOV((StrIntpData[]){{_SLIT("(type `"), 0xfe10, {.d_s = typ_sym->name}}, {_SLIT("`)"), 0, { .d_c = 0 }}}))) : ( str_intp(2, _MOV((StrIntpData[]){{_SLIT("(array type `"), 0xfe10, {.d_s = typ_sym->name}}, {_SLIT("`)"), 0, { .d_c = 0 }}}))));
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot use optional as index "), 0xfe10, {.d_s = type_str}}, {_SLIT0, 0, { .d_c = 0 }}})), pos);
		}
	}
}

v__ast__Type v__checker__Checker_index_expr(v__checker__Checker* c, v__ast__IndexExpr* node) {
	v__ast__Type typ = v__checker__Checker_expr(c, node->left);
	v__ast__TypeSymbol* typ_sym = v__ast__Table_final_sym(c->table, typ);
	node->left_type = typ;
	for (;;) {

		if (typ_sym->kind == (v__ast__Kind__map)) {
			node->is_map = true;
			break;
		}
		else if (typ_sym->kind == (v__ast__Kind__array)) {
			node->is_array = true;
			break;
		}
		else if (typ_sym->kind == (v__ast__Kind__array_fixed)) {
			node->is_farray = true;
			break;
		}
		else if (typ_sym->kind == (v__ast__Kind__any)) {
			string gname = typ_sym->name;
			typ = v__checker__Checker_unwrap_generic(c, typ);
			node->left_type = typ;
			typ_sym = v__ast__Table_final_sym(c->table, typ);
			if (v__ast__Type_is_ptr(typ)) {
				continue;
			} else {
				v__checker__Checker_error(c,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("generic type "), 0xfe10, {.d_s = gname}}, {_SLIT(" does not support indexing, pass an array, or a reference instead, e.g. []"), 0xfe10, {.d_s = gname}}, {_SLIT(" or &"), 0xfe10, {.d_s = gname}}, {_SLIT0, 0, { .d_c = 0 }}})), node->pos);
			}
		}
		else {
			break;
		};
	}
	if (!(typ_sym->kind == v__ast__Kind__array || typ_sym->kind == v__ast__Kind__array_fixed || typ_sym->kind == v__ast__Kind__string || typ_sym->kind == v__ast__Kind__map) && !v__ast__Type_is_ptr(typ) && !(typ == _const_v__ast__byteptr_type || typ == _const_v__ast__charptr_type) && !v__ast__Type_has_flag(typ, v__ast__TypeFlag__variadic)) {
		v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("type `"), 0xfe10, {.d_s = typ_sym->name}}, {_SLIT("` does not support indexing"), 0, { .d_c = 0 }}})), node->pos);
	}
	if (typ_sym->kind == v__ast__Kind__string && !v__ast__Type_is_ptr(typ) && node->is_setter) {
		v__checker__Checker_error(c, string__plus(_SLIT("cannot assign to s[i] since V strings are immutable\n"), _SLIT("(note, that variables may be mutable but string values are always immutable, like in Go and Java)")), node->pos);
	}
	if (!c->inside_unsafe && ((v__ast__Type_is_ptr(typ) && !v__ast__Type_has_flag(typ, v__ast__TypeFlag__shared_f) && !v__ast__Expr_is_auto_deref_var(node->left)) || v__ast__Type_is_pointer(typ))) {
		bool is_ok = false;
		if ((node->left)._typ == 299 /* v.ast.Ident */) {
			if (((*node->left._v__ast__Ident).obj)._typ == 357 /* v.ast.Var */) {
				v__ast__Var v = /* as */ *(v__ast__Var*)__as_cast(((*node->left._v__ast__Ident).obj)._v__ast__Var,((*node->left._v__ast__Ident).obj)._typ, 357) /*expected idx: 357, name: v.ast.Var */ ;
				is_ok = v.is_mut && v.is_arg && !v__ast__Type_is_ptr(v__ast__Type_deref(typ));
			}
		}
		if (!is_ok && !c->pref->translated) {
			v__checker__Checker_warn(c, _SLIT("pointer indexing is only allowed in `unsafe` blocks"), node->pos);
		}
	}
	if ((node->index)._typ == 317 /* v.ast.RangeExpr */) {
		if ((*node->index._v__ast__RangeExpr).has_low) {
			v__ast__Type index_type = v__checker__Checker_expr(c, (*node->index._v__ast__RangeExpr).low);
			v__checker__Checker_check_index(c, typ_sym, (*node->index._v__ast__RangeExpr).low, index_type, node->pos, true, node->is_gated);
		}
		if ((*node->index._v__ast__RangeExpr).has_high) {
			v__ast__Type index_type = v__checker__Checker_expr(c, (*node->index._v__ast__RangeExpr).high);
			v__checker__Checker_check_index(c, typ_sym, (*node->index._v__ast__RangeExpr).high, index_type, node->pos, true, node->is_gated);
		}
		if (typ_sym->kind == v__ast__Kind__array_fixed) {
			v__ast__Type elem_type = v__ast__Table_value_type(c->table, typ);
			int idx = v__ast__Table_find_or_register_array(c->table, elem_type);
			typ = v__ast__new_type(idx);
		} else {
			typ = v__ast__Type_set_nr_muls(typ, 0);
		}
	} else {
		if (typ_sym->kind == v__ast__Kind__map) {
			v__ast__Map info = /* as */ *(v__ast__Map*)__as_cast((typ_sym->info)._v__ast__Map,(typ_sym->info)._typ, 442) /*expected idx: 442, name: v.ast.Map */ ;
			c->expected_type = info.key_type;
			v__ast__Type index_type = v__checker__Checker_expr(c, node->index);
			if (!v__checker__Checker_check_types(c, index_type, info.key_type)) {
				string err = v__checker__Checker_expected_msg(c, index_type, info.key_type);
				v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("invalid key: "), 0xfe10, {.d_s = err}}, {_SLIT0, 0, { .d_c = 0 }}})), node->pos);
			}
			v__ast__TypeSymbol* value_sym = v__ast__Table_sym(c->table, info.value_type);
			if (!node->is_setter && value_sym->kind == v__ast__Kind__sum_type && node->or_expr.kind == v__ast__OrKind__absent && !c->inside_unsafe && !c->inside_if_guard) {
				v__checker__Checker_warn(c, _SLIT("`or {}` block required when indexing a map with sum type value"), node->pos);
			}
		} else {
			v__ast__Type index_type = v__checker__Checker_expr(c, node->index);
			if (node->is_gated == true) {
				v__checker__Checker_error(c, _SLIT("`#[]` allowed only for ranges"), node->pos);
			}
			v__checker__Checker_check_index(c, typ_sym, node->index, index_type, node->pos, false, false);
		}
		v__ast__Type value_type = v__ast__Table_value_type(c->table, typ);
		if (!v__ast__Type_alias_eq(value_type, _const_v__ast__void_type)) {
			typ = value_type;
		}
	}
	v__checker__Checker_stmts_ending_with_expression(c, node->or_expr.stmts);
	v__checker__Checker_check_expr_opt_call(c, v__ast__IndexExpr_to_sumtype_v__ast__Expr(node), typ);
	v__ast__Type _t1 = typ;
	return _t1;
}

v__ast__Type v__checker__Checker_enum_val(v__checker__Checker* c, v__ast__EnumVal* node) {
	int typ_idx = ((node->enum_name).len == 0 ? (v__ast__Type_idx(c->expected_type)) : (v__ast__Table_find_type_idx(c->table, node->enum_name)));
	if (typ_idx == 0) {
		if (string_starts_with(node->enum_name,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = c->mod}}, {_SLIT("."), 0, { .d_c = 0 }}})))) {
			typ_idx = v__ast__Table_find_type_idx(c->table, string_substr(node->enum_name,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = c->mod}}, {_SLIT("."), 0, { .d_c = 0 }}})).len, node->enum_name.len));
			if (typ_idx == 0) {
				v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unknown enum `"), 0xfe10, {.d_s = node->enum_name}}, {_SLIT("` (type_idx=0)"), 0, { .d_c = 0 }}})), node->pos);
				v__ast__Type _t1 = _const_v__ast__void_type;
				return _t1;
			}
		}
	}
	v__ast__Type typ = v__ast__new_type(typ_idx);
	if (c->pref->translated) {
		node->typ = typ;
		v__ast__Type _t2 = typ;
		return _t2;
	}
	if (v__ast__Type_alias_eq(typ, _const_v__ast__void_type)) {
		v__checker__Checker_error(c, _SLIT("not an enum"), node->pos);
		v__ast__Type _t3 = _const_v__ast__void_type;
		return _t3;
	}
	v__ast__TypeSymbol* typ_sym = v__ast__Table_sym(c->table, typ);
	if (typ_sym->kind == v__ast__Kind__array && node->enum_name.len == 0) {
		v__ast__Array array_info = /* as */ *(v__ast__Array*)__as_cast((typ_sym->info)._v__ast__Array,(typ_sym->info)._typ, 441) /*expected idx: 441, name: v.ast.Array */ ;
		typ = array_info.elem_type;
		typ_sym = v__ast__Table_sym(c->table, typ);
	}
	v__ast__TypeSymbol* fsym = v__ast__Table_final_sym(c->table, typ);
	if (fsym->kind != v__ast__Kind__enum_ && !c->pref->translated) {
		v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("expected type is not an enum (`"), 0xfe10, {.d_s = typ_sym->name}}, {_SLIT("`)"), 0, { .d_c = 0 }}})), node->pos);
		v__ast__Type _t4 = _const_v__ast__void_type;
		return _t4;
	}
	if ((fsym->info)._typ != 474 /* v.ast.Enum */) {
		v__checker__Checker_error(c, _SLIT("not an enum"), node->pos);
		v__ast__Type _t5 = _const_v__ast__void_type;
		return _t5;
	}
	if (!(typ_sym->is_public || string__eq(typ_sym->mod, c->mod))) {
		v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("enum `"), 0xfe10, {.d_s = typ_sym->name}}, {_SLIT("` is private"), 0, { .d_c = 0 }}})), node->pos);
	}
	v__ast__Enum info = v__ast__TypeSymbol_enum_info(typ_sym);
	if (!Array_string_contains(info.vals, node->val)) {
		v__util__Suggestion suggestion = v__util__new_suggestion(node->val, info.vals);
		v__checker__Checker_error(c, v__util__Suggestion_say(suggestion,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("enum `"), 0xfe10, {.d_s = typ_sym->name}}, {_SLIT("` does not have a value `"), 0xfe10, {.d_s = node->val}}, {_SLIT("`"), 0, { .d_c = 0 }}}))), node->pos);
	}
	node->typ = typ;
	v__ast__Type _t6 = typ;
	return _t6;
}

v__ast__Type v__checker__Checker_chan_init(v__checker__Checker* c, v__ast__ChanInit* node) {
	if (node->typ != 0) {
		v__ast__Chan info = v__ast__TypeSymbol_chan_info(v__ast__Table_sym(c->table, node->typ));
		node->elem_type = info.elem_type;
		if (node->has_cap) {
			v__checker__Checker_check_array_init_para_type(c, _SLIT("cap"), node->cap_expr, node->pos);
		}
		v__ast__Type _t1 = node->typ;
		return _t1;
	} else {
		v__checker__Checker_error(c, _SLIT("`chan` of unknown type"), node->pos);
		v__ast__Type _t2 = node->typ;
		return _t2;
	}
	return 0;
}

v__ast__Type v__checker__Checker_offset_of(v__checker__Checker* c, v__ast__OffsetOf node) {
	v__ast__TypeSymbol* sym = v__ast__Table_final_sym(c->table, node.struct_type);
	if (sym->kind != v__ast__Kind__struct_) {
		v__checker__Checker_error(c, _SLIT("first argument of __offsetof must be struct"), node.pos);
		v__ast__Type _t1 = _const_v__ast__u32_type;
		return _t1;
	}
	if (!v__ast__Table_struct_has_field(c->table, sym, node.field)) {
		v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("struct `"), 0xfe10, {.d_s = sym->name}}, {_SLIT("` has no field called `"), 0xfe10, {.d_s = node.field}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node.pos);
	}
	v__ast__Type _t2 = _const_v__ast__u32_type;
	return _t2;
}

void v__checker__Checker_check_dup_keys(v__checker__Checker* c, v__ast__MapInit* node, int i) {
	v__ast__Expr key_i = (*(v__ast__Expr*)/*ee elem_typ */array_get(node->keys, i));
	if ((key_i)._typ == 323 /* v.ast.StringLiteral */) {
		for (int j = 0; j < i; ++j) {
			v__ast__Expr key_j = (*(v__ast__Expr*)/*ee elem_typ */array_get(node->keys, j));
			if ((key_j)._typ == 323 /* v.ast.StringLiteral */) {
				if (string__eq((*key_i._v__ast__StringLiteral).val, (*key_j._v__ast__StringLiteral).val)) {
					v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("duplicate key \""), 0xfe10, {.d_s = (*key_i._v__ast__StringLiteral).val}}, {_SLIT("\" in map literal"), 0, { .d_c = 0 }}})), (*key_i._v__ast__StringLiteral).pos);
				}
			}
		}
	} else if ((key_i)._typ == 304 /* v.ast.IntegerLiteral */) {
		for (int j = 0; j < i; ++j) {
			v__ast__Expr key_j = (*(v__ast__Expr*)/*ee elem_typ */array_get(node->keys, j));
			if ((key_j)._typ == 304 /* v.ast.IntegerLiteral */) {
				if (string__eq((*key_i._v__ast__IntegerLiteral).val, (*key_j._v__ast__IntegerLiteral).val)) {
					v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("duplicate key \""), 0xfe10, {.d_s = (*key_i._v__ast__IntegerLiteral).val}}, {_SLIT("\" in map literal"), 0, { .d_c = 0 }}})), (*key_i._v__ast__IntegerLiteral).pos);
				}
			}
		}
	}
}

void v__checker__Checker_add_error_detail(v__checker__Checker* c, string s) {
	array_push((array*)&c->error_details, _MOV((string[]){ string_clone(s) }));
}

void v__checker__Checker_warn(v__checker__Checker* c, string s, v__token__Position pos) {
	bool allow_warnings = !(c->pref->is_prod || c->pref->warns_are_errors);
	v__checker__Checker_warn_or_error(c, s, pos, allow_warnings);
}

void v__checker__Checker_error(v__checker__Checker* c, string message, v__token__Position pos) {
	if (c->pref->translated && string_starts_with(message, _SLIT("mismatched types"))) {
		return;
	}
	if (c->pref->is_verbose) {
		print_backtrace();
	}
	string msg = string_replace(message, _SLIT("`Array_"), _SLIT("`[]"));
	v__checker__Checker_warn_or_error(c, msg, pos, false);
}

VV_LOCAL_SYMBOL bool v__checker__Checker_check_struct_signature(v__checker__Checker* c, v__ast__Struct from, v__ast__Struct to) {
	if (from.fields.len == 0) {
		bool _t1 = false;
		return _t1;
	}
	for (int _t2 = 0; _t2 < from.fields.len; ++_t2) {
		v__ast__StructField field = ((v__ast__StructField*)from.fields.data)[_t2];
		Array_v__ast__StructField _t3 = __new_array(0, 0, sizeof(v__ast__StructField));
		Array_v__ast__StructField _t3_orig = to.fields;
		int _t3_len = _t3_orig.len;
		_t3 = __new_array(0, _t3_len, sizeof(v__ast__StructField));

		for (int _t4 = 0; _t4 < _t3_len; ++_t4) {
			v__ast__StructField it = ((v__ast__StructField*) _t3_orig.data)[_t4];
			if (string__eq(it.name, field.name)) {
				array_push((array*)&_t3, &it);
			}
		}
		Array_v__ast__StructField filtered =_t3;
		if (filtered.len != 1) {
			bool _t5 = false;
			return _t5;
		}
		v__ast__StructField counterpart = (*(v__ast__StructField*)/*ee elem_typ */array_get(filtered, 0));
		if (!v__ast__Type_alias_eq(field.typ, counterpart.typ)) {
			bool _t6 = false;
			return _t6;
		}
		if (field.is_pub != counterpart.is_pub) {
			bool _t7 = false;
			return _t7;
		}
		if (field.is_mut != counterpart.is_mut) {
			bool _t8 = false;
			return _t8;
		}
	}
	bool _t9 = true;
	return _t9;
}

void v__checker__Checker_note(v__checker__Checker* c, string message, v__token__Position pos) {
	if (c->pref->message_limit >= 0 && c->nr_notices >= c->pref->message_limit) {
		c->should_abort = true;
		return;
	}
	if (c->is_generated) {
		return;
	}
	string details = _SLIT("");
	if (c->error_details.len > 0) {
		details = Array_string_join(c->error_details, _SLIT("\n"));
		c->error_details = __new_array_with_default(0, 0, sizeof(string), 0);
	}
	v__errors__Notice wrn = (v__errors__Notice){.message = message,.details = details,.file_path = c->file->path,.pos = pos,.reporter = v__errors__Reporter__checker,};
	array_push((array*)&c->file->notices, _MOV((v__errors__Notice[]){ wrn }));
	array_push((array*)&c->notices, _MOV((v__errors__Notice[]){ wrn }));
	c->nr_notices++;
}

VV_LOCAL_SYMBOL void v__checker__Checker_warn_or_error(v__checker__Checker* c, string message, v__token__Position pos, bool warn) {
	string details = _SLIT("");
	if (c->error_details.len > 0) {
		details = Array_string_join(c->error_details, _SLIT("\n"));
		c->error_details = __new_array_with_default(0, 0, sizeof(string), 0);
	}
	if (warn && !c->pref->skip_warnings) {
		c->nr_warnings++;
		if (c->pref->message_limit >= 0 && c->nr_warnings >= c->pref->message_limit) {
			c->should_abort = true;
			return;
		}
		v__errors__Warning wrn = (v__errors__Warning){.message = message,.details = details,.file_path = c->file->path,.pos = pos,.reporter = v__errors__Reporter__checker,};
		array_push((array*)&c->file->warnings, _MOV((v__errors__Warning[]){ wrn }));
		array_push((array*)&c->warnings, _MOV((v__errors__Warning[]){ wrn }));
		return;
	}
	if (!warn) {
		if (c->pref->fatal_errors) {
			_v_exit(1);
			VUNREACHABLE();
		}
		c->nr_errors++;
		if (c->pref->message_limit >= 0 && c->errors.len >= c->pref->message_limit) {
			c->should_abort = true;
			return;
		}
		if (!Array_int_contains(c->error_lines, pos.line_nr)) {
			v__errors__Error err = (v__errors__Error){.message = message,.details = details,.file_path = c->file->path,.pos = pos,.backtrace = (string){.str=(byteptr)"", .is_lit=1},.reporter = v__errors__Reporter__checker,};
			array_push((array*)&c->file->errors, _MOV((v__errors__Error[]){ err }));
			array_push((array*)&c->errors, _MOV((v__errors__Error[]){ err }));
			array_push((array*)&c->error_lines, _MOV((int[]){ pos.line_nr }));
		}
	}
}

VV_LOCAL_SYMBOL bool v__checker__Checker_fileis(v__checker__Checker* c, string s) {
	bool _t1 = string_contains(c->file->path, s);
	return _t1;
}

VV_LOCAL_SYMBOL string v__checker__Checker_fetch_field_name(v__checker__Checker* c, v__ast__StructField field) {
	string name = field.name;
	for (int _t1 = 0; _t1 < field.attrs.len; ++_t1) {
		v__ast__Attr attr = ((v__ast__Attr*)field.attrs.data)[_t1];
		if (attr.kind == v__ast__AttrKind__string && string__eq(attr.name, _SLIT("sql")) && (attr.arg).len != 0) {
			name = attr.arg;
			break;
		}
	}
	v__ast__TypeSymbol* sym = v__ast__Table_sym(c->table, field.typ);
	if (sym->kind == v__ast__Kind__struct_ && !string__eq(sym->name, _SLIT("time.Time"))) {
		name =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = name}}, {_SLIT("_id"), 0, { .d_c = 0 }}}));
	}
	string _t2 = name;
	return _t2;
}

VV_LOCAL_SYMBOL void v__checker__Checker_trace(v__checker__Checker* c, string fbase, string message) {
	if (string__eq(c->file->path_base, fbase)) {
		println( str_intp(3, _MOV((StrIntpData[]){{_SLIT("> c.trace | "), 0x14fe10, {.d_s = fbase}}, {_SLIT(" | "), 0xfe10, {.d_s = message}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
}

VV_LOCAL_SYMBOL Option_void v__checker__Checker_ensure_type_exists(v__checker__Checker* c, v__ast__Type typ, v__token__Position pos) {
	if (typ == 0) {
		v__checker__Checker_error(c, _SLIT("unknown type"), pos);
		return (Option_void){0};
	}
	v__ast__TypeSymbol* sym = v__ast__Table_sym(c->table, typ);
	switch (sym->kind) {
		case v__ast__Kind__placeholder: 
			{
				if (sym->language == v__ast__Language__v && !string_starts_with(sym->name, _SLIT("C."))) {
					v__checker__Checker_error(c, v__util__Suggestion_say(v__util__new_suggestion(sym->name, v__ast__Table_known_type_names(c->table)),  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unknown type `"), 0xfe10, {.d_s = sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}}))), pos);
					return (Option_void){0};
				}
			} break;
		case v__ast__Kind__int_literal: 
		case v__ast__Kind__float_literal: 
			{
				if (!c->is_builtin_mod) {
					string msg = (sym->kind == v__ast__Kind__int_literal ? ( str_intp(2, _MOV((StrIntpData[]){{_SLIT("unknown type `"), 0xfe10, {.d_s = sym->name}}, {_SLIT("`.\nDid you mean `int`?"), 0, { .d_c = 0 }}}))) : ( str_intp(2, _MOV((StrIntpData[]){{_SLIT("unknown type `"), 0xfe10, {.d_s = sym->name}}, {_SLIT("`.\nDid you mean `f64`?"), 0, { .d_c = 0 }}}))));
					v__checker__Checker_error(c, msg, pos);
					return (Option_void){0};
				}
			} break;
		case v__ast__Kind__array: 
			{
				Option_void _t1 = v__checker__Checker_ensure_type_exists(c, (/* as */ *(v__ast__Array*)__as_cast((sym->info)._v__ast__Array,(sym->info)._typ, 441) /*expected idx: 441, name: v.ast.Array */ ).elem_type, pos);
				if (_t1.state != 0 && _t1.err._typ != _IError_None___index) {
					Option_void _t2;
					memcpy(&_t2, &_t1, sizeof(Option));
					return _t2;
				}
				
 ;
			} break;
		case v__ast__Kind__array_fixed: 
			{
				Option_void _t3 = v__checker__Checker_ensure_type_exists(c, (/* as */ *(v__ast__ArrayFixed*)__as_cast((sym->info)._v__ast__ArrayFixed,(sym->info)._typ, 468) /*expected idx: 468, name: v.ast.ArrayFixed */ ).elem_type, pos);
				if (_t3.state != 0 && _t3.err._typ != _IError_None___index) {
					Option_void _t4;
					memcpy(&_t4, &_t3, sizeof(Option));
					return _t4;
				}
				
 ;
			} break;
		case v__ast__Kind__map: 
			{
				v__ast__Map info = /* as */ *(v__ast__Map*)__as_cast((sym->info)._v__ast__Map,(sym->info)._typ, 442) /*expected idx: 442, name: v.ast.Map */ ;
				Option_void _t5 = v__checker__Checker_ensure_type_exists(c, info.key_type, pos);
				if (_t5.state != 0 && _t5.err._typ != _IError_None___index) {
					Option_void _t6;
					memcpy(&_t6, &_t5, sizeof(Option));
					return _t6;
				}
				
 ;
				Option_void _t7 = v__checker__Checker_ensure_type_exists(c, info.value_type, pos);
				if (_t7.state != 0 && _t7.err._typ != _IError_None___index) {
					Option_void _t8;
					memcpy(&_t8, &_t7, sizeof(Option));
					return _t8;
				}
				
 ;
			} break;
		case v__ast__Kind__void:
		case v__ast__Kind__voidptr:
		case v__ast__Kind__byteptr:
		case v__ast__Kind__charptr:
		case v__ast__Kind__i8:
		case v__ast__Kind__i16:
		case v__ast__Kind__int:
		case v__ast__Kind__i64:
		case v__ast__Kind__isize:
		case v__ast__Kind__byte:
		case v__ast__Kind__u8:
		case v__ast__Kind__u16:
		case v__ast__Kind__u32:
		case v__ast__Kind__u64:
		case v__ast__Kind__usize:
		case v__ast__Kind__f32:
		case v__ast__Kind__f64:
		case v__ast__Kind__char:
		case v__ast__Kind__rune:
		case v__ast__Kind__bool:
		case v__ast__Kind__none_:
		case v__ast__Kind__string:
		case v__ast__Kind__chan:
		case v__ast__Kind__any:
		case v__ast__Kind__struct_:
		case v__ast__Kind__generic_inst:
		case v__ast__Kind__multi_return:
		case v__ast__Kind__sum_type:
		case v__ast__Kind__alias:
		case v__ast__Kind__enum_:
		case v__ast__Kind__function:
		case v__ast__Kind__interface_:
		case v__ast__Kind__aggregate:
		case v__ast__Kind__thread:
		default:
			{
			} break;
	}
	;
	return (Option_void){0};
}

VV_LOCAL_SYMBOL v__ast__Type v__checker__Checker_comptime_call(v__checker__Checker* c, v__ast__ComptimeCall* node) {
	node->left_type = v__checker__Checker_expr(c, node->left);
	if (node->is_env) {
		Option_string _t1 = v__util__resolve_env_value( str_intp(2, _MOV((StrIntpData[]){{_SLIT("$env('"), 0xfe10, {.d_s = node->args_var}}, {_SLIT("')"), 0, { .d_c = 0 }}})), false);
		if (_t1.state != 0) { /*or block*/ 
			IError err = _t1.err;
			v__checker__Checker_error(c, (*(err.msg)), node->env_pos);
			v__ast__Type _t2 = _const_v__ast__string_type;
			return _t2;
		}
		
 		string env_value =  (*(string*)_t1.data);
		node->env_value = env_value;
		v__ast__Type _t3 = _const_v__ast__string_type;
		return _t3;
	}
	if (node->is_embed) {
		if (!Array_string_contains(_const_v__checker__valid_comptime_compression_types, node->embed_file.compression_type)) {
			Array_string _t4 = __new_array(0, 0, sizeof(string));
			Array_string _t4_orig = _const_v__checker__valid_comptime_compression_types;
			int _t4_len = _t4_orig.len;
			_t4 = __new_array(0, _t4_len, sizeof(string));

			for (int _t5 = 0; _t5 < _t4_len; ++_t5) {
				string it = ((string*) _t4_orig.data)[_t5];
				string ti =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("."), 0xfe10, {.d_s = it}}, {_SLIT0, 0, { .d_c = 0 }}}));
				array_push((array*)&_t4, &ti);
			}
			string supported = Array_string_join(_t4, _SLIT(", "));
			v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("not supported compression type: ."), 0xfe10, {.d_s = node->embed_file.compression_type}}, {_SLIT(". supported: "), 0xfe10, {.d_s = supported}}, {_SLIT0, 0, { .d_c = 0 }}})), node->pos);
		}
		v__ast__Type _t6 = v__ast__Table_find_type_idx(c->table, _SLIT("v.embed_file.EmbedFileData"));
		return _t6;
	}
	if (node->is_vweb) {
		v__ast__FnDecl* save_cur_fn = c->table->cur_fn;
		v__pref__Preferences *pref_ = HEAP(v__pref__Preferences, (*c->pref));
		v__pref__Preferences* pref2 = (v__pref__Preferences*)memdup(&(v__pref__Preferences){(*(pref_)).os,(*(pref_)).backend,(*(pref_)).build_mode,(*(pref_)).arch,(*(pref_)).output_mode,(*(pref_)).is_verbose,(*(pref_)).is_test,(*(pref_)).is_script,(*(pref_)).is_vsh,(*(pref_)).is_livemain,(*(pref_)).is_liveshared,(*(pref_)).is_shared,(*(pref_)).is_o,(*(pref_)).is_prof,(*(pref_)).test_runner,(*(pref_)).profile_file,(*(pref_)).profile_no_inline,(*(pref_)).translated,(*(pref_)).is_prod,(*(pref_)).obfuscate,(*(pref_)).is_repl,(*(pref_)).is_run,(*(pref_)).is_debug,(*(pref_)).is_vlines,(*(pref_)).sanitize,(*(pref_)).sourcemap,(*(pref_)).sourcemap_inline,(*(pref_)).sourcemap_src_included,(*(pref_)).show_cc,(*(pref_)).show_c_output,(*(pref_)).show_callgraph,(*(pref_)).show_depgraph,(*(pref_)).dump_c_flags,(*(pref_)).use_cache,(*(pref_)).retry_compilation,(*(pref_)).is_stats,(*(pref_)).cflags,(*(pref_)).m64,(*(pref_)).ccompiler,(*(pref_)).ccompiler_type,(*(pref_)).third_party_option,(*(pref_)).building_v,(*(pref_)).autofree,(*(pref_)).compress,(*(pref_)).no_builtin,(*(pref_)).enable_globals,(*(pref_)).is_fmt,(*(pref_)).is_vet,(*(pref_)).is_bare,(*(pref_)).bare_builtin_dir,(*(pref_)).no_preludes,(*(pref_)).custom_prelude,(*(pref_)).lookup_path,(*(pref_)).output_cross_c,(*(pref_)).output_es5,(*(pref_)).prealloc,(*(pref_)).vroot,(*(pref_)).out_name_c,(*(pref_)).out_name,(*(pref_)).path,(*(pref_)).run_only,(*(pref_)).compile_defines,(*(pref_)).compile_defines_all,(*(pref_)).run_args,(*(pref_)).printfn_list,(*(pref_)).print_v_files,(*(pref_)).skip_running,(*(pref_)).skip_warnings,(*(pref_)).warn_impure_v,(*(pref_)).warns_are_errors,(*(pref_)).fatal_errors,(*(pref_)).reuse_tmpc,(*(pref_)).no_rsp,(*(pref_)).no_std,(*(pref_)).use_color,(*(pref_)).no_parallel,.is_vweb = true,(*(pref_)).only_check_syntax,(*(pref_)).check_only,(*(pref_)).experimental,(*(pref_)).skip_unused,(*(pref_)).show_timings,(*(pref_)).is_ios_simulator,(*(pref_)).is_apk,(*(pref_)).cleanup_files,(*(pref_)).build_options,(*(pref_)).cache_manager,(*(pref_)).is_help,(*(pref_)).gc_mode,(*(pref_)).is_cstrict,(*(pref_)).assert_failure_mode,(*(pref_)).message_limit,(*(pref_)).nofloat,(*(pref_)).checker_match_exhaustive_cutoff_limit,}, sizeof(v__pref__Preferences));
		v__checker__Checker* c2 = v__checker__new_checker(c->table, pref2);
		v__checker__Checker_check(c2, (voidptr)&/*qq*/node->vweb_tmpl);
		int i = 0;
		Map_string_v__ast__ScopeObject _t7 = (*(v__ast__Scope**)/*ee elem_typ */array_get(c2->file->scope->children, 0))->objects;
		int _t9 = _t7.key_values.len;
		for (int _t8 = 0; _t8 < _t9; ++_t8 ) {
			int _t10 = _t7.key_values.len - _t9;
			_t9 = _t7.key_values.len;
			if (_t10 < 0) {
				_t8 = -1;
				continue;
			}
			if (!DenseArray_has_index(&_t7.key_values, _t8)) {continue;}
			string k = /*key*/ *(string*)DenseArray_key(&_t7.key_values, _t8);
			k = string_clone(k);
			if (i < 2) {
				i++;
				continue;
			}
			if (_IN_MAP(ADDR(string, k), ADDR(map, c->fn_scope->objects)) && ((*(v__ast__ScopeObject*)map_get(ADDR(map, c->fn_scope->objects), &(string[]){k}, &(v__ast__ScopeObject[]){ {0} })))._typ == 357 /* v.ast.Var */) {
				v__ast__Var vsc = /* as */ *(v__ast__Var*)__as_cast(((*(v__ast__ScopeObject*)map_get(ADDR(map, c->fn_scope->objects), &(string[]){k}, &(v__ast__ScopeObject[]){ {0} })))._v__ast__Var,((*(v__ast__ScopeObject*)map_get(ADDR(map, c->fn_scope->objects), &(string[]){k}, &(v__ast__ScopeObject[]){ {0} })))._typ, 357) /*expected idx: 357, name: v.ast.Var */ ;
				vsc.is_used = true;
				map_set(&c->fn_scope->objects, &(string[]){k}, &(v__ast__ScopeObject[]) { v__ast__Var_to_sumtype_v__ast__ScopeObject(&vsc) });
			}
		}
		_PUSH_MANY(&c->warnings, (c2->warnings), _t11, Array_v__errors__Warning);
		_PUSH_MANY(&c->errors, (c2->errors), _t12, Array_v__errors__Error);
		_PUSH_MANY(&c->notices, (c2->notices), _t13, Array_v__errors__Notice);
		c->nr_warnings += c2->nr_warnings;
		c->nr_errors += c2->nr_errors;
		c->nr_notices += c2->nr_notices;
		c->table->cur_fn = save_cur_fn;
	}
	if (string__eq(node->method_name, _SLIT("html"))) {
		int rtyp = v__ast__Table_find_type_idx(c->table, _SLIT("vweb.Result"));
		node->result_type = rtyp;
		v__ast__Type _t14 = rtyp;
		return _t14;
	}
	if (string__eq(node->method_name, _SLIT("method"))) {
		for (int i = 0; i < node->args.len; ++i) {
			v__ast__CallArg arg = ((v__ast__CallArg*)node->args.data)[i];
			(*(v__ast__CallArg*)/*ee elem_typ */array_get(node->args, i)).typ = v__checker__Checker_expr(c, arg.expr);
		}
		v__ast__Type _t15 = _const_v__ast__string_type;
		return _t15;
	}
	if (node->is_vweb) {
		v__ast__Type _t16 = _const_v__ast__string_type;
		return _t16;
	}
	Option_v__ast__Var_ptr _t17 = v__ast__Scope_find_var(node->scope, node->method_name);
	if (_t17.state != 0) { /*or block*/ 
		IError err = _t17.err;
		v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unknown identifier `"), 0xfe10, {.d_s = node->method_name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node->method_pos);
		v__ast__Type _t18 = _const_v__ast__void_type;
		return _t18;
	}
	
 	v__ast__Var* v =  (*(v__ast__Var**)_t17.data);
	if (!v__ast__Type_alias_eq(v->typ, _const_v__ast__string_type)) {
		string s = v__checker__Checker_expected_msg(c, v->typ, _const_v__ast__string_type);
		v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("invalid string method call: "), 0xfe10, {.d_s = s}}, {_SLIT0, 0, { .d_c = 0 }}})), node->method_pos);
		v__ast__Type _t19 = _const_v__ast__void_type;
		return _t19;
	}
	string method_name = _SLIT("");
	if ((v->expr)._typ == 323 /* v.ast.StringLiteral */) {
		method_name = (*v->expr._v__ast__StringLiteral).val;
	} else {
		v__checker__Checker_error(c, _SLIT("todo: not a string literal"), node->method_pos);
	}
	v__ast__TypeSymbol* left_sym = v__ast__Table_sym(c->table, v__checker__Checker_unwrap_generic(c, node->left_type));
	Option_v__ast__Fn _t20 = v__ast__TypeSymbol_find_method(left_sym, method_name);
	if (_t20.state != 0) { /*or block*/ 
		IError err = _t20.err;
		v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("could not find method `"), 0xfe10, {.d_s = method_name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node->method_pos);
		v__ast__Type _t21 = _const_v__ast__void_type;
		return _t21;
	}
	
 	v__ast__Fn f =  (*(v__ast__Fn*)_t20.data);
	node->result_type = f.return_type;
	v__ast__Type _t22 = f.return_type;
	return _t22;
}

VV_LOCAL_SYMBOL void v__checker__Checker_comptime_for(v__checker__Checker* c, v__ast__ComptimeFor node) {
	v__ast__Type typ = v__checker__Checker_unwrap_generic(c, node.typ);
	v__ast__TypeSymbol* sym = v__ast__Table_sym(c->table, typ);
	if (sym->kind == v__ast__Kind__placeholder || v__ast__Type_has_flag(typ, v__ast__TypeFlag__generic)) {
		v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unknown type `"), 0xfe10, {.d_s = sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node.typ_pos);
	}
	if (node.kind == v__ast__ComptimeForKind__fields) {
		map_set(&c->comptime_fields_type, &(string[]){node.val_var}, &(v__ast__Type[]) { node.typ });
		c->comptime_fields_default_type = node.typ;
	}
	v__checker__Checker_stmts(c, node.stmts);
}

VV_LOCAL_SYMBOL Option_v__ast__ComptTimeConstValue v__checker__Checker_eval_comptime_const_expr(v__checker__Checker* c, v__ast__Expr expr, int nlevel) {
	if (nlevel > 100) {
		return (Option_v__ast__ComptTimeConstValue){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (expr._typ == 314 /* v.ast.ParExpr */) {
		Option_v__ast__ComptTimeConstValue _t2 = v__checker__Checker_eval_comptime_const_expr(c, (*expr._v__ast__ParExpr).expr, nlevel + 1);
		return _t2;
	}
	else if (expr._typ == 320 /* v.ast.SizeOf */) {
		v__ast__Type xtype = (*expr._v__ast__SizeOf).typ;
		if (v__ast__Type_is_real_pointer(xtype)) {
			if (c->pref->m64) {
				Option_v__ast__ComptTimeConstValue _t3;
				opt_ok(&(v__ast__ComptTimeConstValue[]) { int_to_sumtype_v__ast__ComptTimeConstValue(ADDR(int, (8))) }, (Option*)(&_t3), sizeof(v__ast__ComptTimeConstValue));
				return _t3;
			}
			Option_v__ast__ComptTimeConstValue _t4;
			opt_ok(&(v__ast__ComptTimeConstValue[]) { int_to_sumtype_v__ast__ComptTimeConstValue(ADDR(int, (4))) }, (Option*)(&_t4), sizeof(v__ast__ComptTimeConstValue));
			return _t4;
		}
		if (((int)(xtype)) == v__ast__Type_idx(xtype)) {

			if (xtype == (_const_v__ast__char_type)) {
				Option_v__ast__ComptTimeConstValue _t5;
				opt_ok(&(v__ast__ComptTimeConstValue[]) { int_to_sumtype_v__ast__ComptTimeConstValue(ADDR(int, (1))) }, (Option*)(&_t5), sizeof(v__ast__ComptTimeConstValue));
				return _t5;
			}
			else if (xtype == (_const_v__ast__i8_type)) {
				Option_v__ast__ComptTimeConstValue _t6;
				opt_ok(&(v__ast__ComptTimeConstValue[]) { int_to_sumtype_v__ast__ComptTimeConstValue(ADDR(int, (1))) }, (Option*)(&_t6), sizeof(v__ast__ComptTimeConstValue));
				return _t6;
			}
			else if (xtype == (_const_v__ast__i16_type)) {
				Option_v__ast__ComptTimeConstValue _t7;
				opt_ok(&(v__ast__ComptTimeConstValue[]) { int_to_sumtype_v__ast__ComptTimeConstValue(ADDR(int, (2))) }, (Option*)(&_t7), sizeof(v__ast__ComptTimeConstValue));
				return _t7;
			}
			else if (xtype == (_const_v__ast__int_type)) {
				Option_v__ast__ComptTimeConstValue _t8;
				opt_ok(&(v__ast__ComptTimeConstValue[]) { int_to_sumtype_v__ast__ComptTimeConstValue(ADDR(int, (4))) }, (Option*)(&_t8), sizeof(v__ast__ComptTimeConstValue));
				return _t8;
			}
			else if (xtype == (_const_v__ast__i64_type)) {
				Option_v__ast__ComptTimeConstValue _t9;
				opt_ok(&(v__ast__ComptTimeConstValue[]) { int_to_sumtype_v__ast__ComptTimeConstValue(ADDR(int, (8))) }, (Option*)(&_t9), sizeof(v__ast__ComptTimeConstValue));
				return _t9;
			}
			else if (xtype == (_const_v__ast__byte_type)) {
				Option_v__ast__ComptTimeConstValue _t10;
				opt_ok(&(v__ast__ComptTimeConstValue[]) { int_to_sumtype_v__ast__ComptTimeConstValue(ADDR(int, (1))) }, (Option*)(&_t10), sizeof(v__ast__ComptTimeConstValue));
				return _t10;
			}
			else if (xtype == (_const_v__ast__u8_type)) {
				Option_v__ast__ComptTimeConstValue _t11;
				opt_ok(&(v__ast__ComptTimeConstValue[]) { int_to_sumtype_v__ast__ComptTimeConstValue(ADDR(int, (1))) }, (Option*)(&_t11), sizeof(v__ast__ComptTimeConstValue));
				return _t11;
			}
			else if (xtype == (_const_v__ast__u16_type)) {
				Option_v__ast__ComptTimeConstValue _t12;
				opt_ok(&(v__ast__ComptTimeConstValue[]) { int_to_sumtype_v__ast__ComptTimeConstValue(ADDR(int, (2))) }, (Option*)(&_t12), sizeof(v__ast__ComptTimeConstValue));
				return _t12;
			}
			else if (xtype == (_const_v__ast__u32_type)) {
				Option_v__ast__ComptTimeConstValue _t13;
				opt_ok(&(v__ast__ComptTimeConstValue[]) { int_to_sumtype_v__ast__ComptTimeConstValue(ADDR(int, (4))) }, (Option*)(&_t13), sizeof(v__ast__ComptTimeConstValue));
				return _t13;
			}
			else if (xtype == (_const_v__ast__u64_type)) {
				Option_v__ast__ComptTimeConstValue _t14;
				opt_ok(&(v__ast__ComptTimeConstValue[]) { int_to_sumtype_v__ast__ComptTimeConstValue(ADDR(int, (8))) }, (Option*)(&_t14), sizeof(v__ast__ComptTimeConstValue));
				return _t14;
			}
			else {
			};
		}
		return (Option_v__ast__ComptTimeConstValue){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	else if (expr._typ == 297 /* v.ast.FloatLiteral */) {
		f64 x = string_f64((*expr._v__ast__FloatLiteral).val);
		Option_v__ast__ComptTimeConstValue _t16;
		opt_ok(&(v__ast__ComptTimeConstValue[]) { f64_to_sumtype_v__ast__ComptTimeConstValue(&x) }, (Option*)(&_t16), sizeof(v__ast__ComptTimeConstValue));
		return _t16;
	}
	else if (expr._typ == 304 /* v.ast.IntegerLiteral */) {
		u64 x = string_u64((*expr._v__ast__IntegerLiteral).val);
		if (x > 9223372036854775807U) {
			Option_v__ast__ComptTimeConstValue _t17;
			opt_ok(&(v__ast__ComptTimeConstValue[]) { u64_to_sumtype_v__ast__ComptTimeConstValue(&x) }, (Option*)(&_t17), sizeof(v__ast__ComptTimeConstValue));
			return _t17;
		}
		Option_v__ast__ComptTimeConstValue _t18;
		opt_ok(&(v__ast__ComptTimeConstValue[]) { i64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(i64, (string_i64((*expr._v__ast__IntegerLiteral).val)))) }, (Option*)(&_t18), sizeof(v__ast__ComptTimeConstValue));
		return _t18;
	}
	else if (expr._typ == 323 /* v.ast.StringLiteral */) {
		Option_v__ast__ComptTimeConstValue _t19;
		opt_ok(&(v__ast__ComptTimeConstValue[]) { string_to_sumtype_v__ast__ComptTimeConstValue(ADDR(string, (v__util__smart_quote((*expr._v__ast__StringLiteral).val, (*expr._v__ast__StringLiteral).is_raw)))) }, (Option*)(&_t19), sizeof(v__ast__ComptTimeConstValue));
		return _t19;
	}
	else if (expr._typ == 289 /* v.ast.CharLiteral */) {
		Array_rune runes = string_runes((*expr._v__ast__CharLiteral).val);
		if (runes.len > 0) {
			Option_v__ast__ComptTimeConstValue _t20;
			opt_ok(&(v__ast__ComptTimeConstValue[]) { rune_to_sumtype_v__ast__ComptTimeConstValue(&(*(rune*)/*ee elem_typ */array_get(runes, 0))) }, (Option*)(&_t20), sizeof(v__ast__ComptTimeConstValue));
			return _t20;
		}
		return (Option_v__ast__ComptTimeConstValue){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	else if (expr._typ == 299 /* v.ast.Ident */) {
		if (((*expr._v__ast__Ident).obj)._typ == 355 /* v.ast.ConstField */) {
			Option_v__ast__ComptTimeConstValue _t22 = v__checker__Checker_eval_comptime_const_expr(c, (*(*expr._v__ast__Ident).obj._v__ast__ConstField).expr, nlevel + 1);
			return _t22;
		}
	}
	else if (expr._typ == 287 /* v.ast.CastExpr */) {
		Option_v__ast__ComptTimeConstValue _t23 = v__checker__Checker_eval_comptime_const_expr(c, (*expr._v__ast__CastExpr).expr, nlevel + 1);
		if (_t23.state != 0) { /*or block*/ 
			IError err = _t23.err;
			return (Option_v__ast__ComptTimeConstValue){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		
 		v__ast__ComptTimeConstValue cast_expr_value =  (*(v__ast__ComptTimeConstValue*)_t23.data);
		if (v__ast__Type_alias_eq((*expr._v__ast__CastExpr).typ, _const_v__ast__i8_type)) {
			Option_i8 _t26 = v__ast__ComptTimeConstValue_i8(cast_expr_value);
			if (_t26.state != 0) { /*or block*/ 
				IError err = _t26.err;
				return (Option_v__ast__ComptTimeConstValue){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			
 			Option_v__ast__ComptTimeConstValue _t25;
			opt_ok(&(v__ast__ComptTimeConstValue[]) { i8_to_sumtype_v__ast__ComptTimeConstValue(ADDR(i8, ( (*(i8*)_t26.data)))) }, (Option*)(&_t25), sizeof(v__ast__ComptTimeConstValue));
			return _t25;
		}
		if (v__ast__Type_alias_eq((*expr._v__ast__CastExpr).typ, _const_v__ast__i16_type)) {
			Option_i16 _t29 = v__ast__ComptTimeConstValue_i16(cast_expr_value);
			if (_t29.state != 0) { /*or block*/ 
				IError err = _t29.err;
				return (Option_v__ast__ComptTimeConstValue){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			
 			Option_v__ast__ComptTimeConstValue _t28;
			opt_ok(&(v__ast__ComptTimeConstValue[]) { i16_to_sumtype_v__ast__ComptTimeConstValue(ADDR(i16, ( (*(i16*)_t29.data)))) }, (Option*)(&_t28), sizeof(v__ast__ComptTimeConstValue));
			return _t28;
		}
		if (v__ast__Type_alias_eq((*expr._v__ast__CastExpr).typ, _const_v__ast__int_type)) {
			Option_int _t32 = v__ast__ComptTimeConstValue_int(cast_expr_value);
			if (_t32.state != 0) { /*or block*/ 
				IError err = _t32.err;
				return (Option_v__ast__ComptTimeConstValue){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			
 			Option_v__ast__ComptTimeConstValue _t31;
			opt_ok(&(v__ast__ComptTimeConstValue[]) { int_to_sumtype_v__ast__ComptTimeConstValue(ADDR(int, ( (*(int*)_t32.data)))) }, (Option*)(&_t31), sizeof(v__ast__ComptTimeConstValue));
			return _t31;
		}
		if (v__ast__Type_alias_eq((*expr._v__ast__CastExpr).typ, _const_v__ast__i64_type)) {
			Option_i64 _t35 = v__ast__ComptTimeConstValue_i64(cast_expr_value);
			if (_t35.state != 0) { /*or block*/ 
				IError err = _t35.err;
				return (Option_v__ast__ComptTimeConstValue){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			
 			Option_v__ast__ComptTimeConstValue _t34;
			opt_ok(&(v__ast__ComptTimeConstValue[]) { i64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(i64, ( (*(i64*)_t35.data)))) }, (Option*)(&_t34), sizeof(v__ast__ComptTimeConstValue));
			return _t34;
		}
		if (v__ast__Type_alias_eq((*expr._v__ast__CastExpr).typ, _const_v__ast__byte_type)) {
			Option_byte _t38 = v__ast__ComptTimeConstValue_byte(cast_expr_value);
			if (_t38.state != 0) { /*or block*/ 
				IError err = _t38.err;
				return (Option_v__ast__ComptTimeConstValue){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			
 			Option_v__ast__ComptTimeConstValue _t37;
			opt_ok(&(v__ast__ComptTimeConstValue[]) { byte_to_sumtype_v__ast__ComptTimeConstValue(ADDR(byte, ( (*(byte*)_t38.data)))) }, (Option*)(&_t37), sizeof(v__ast__ComptTimeConstValue));
			return _t37;
		}
		if (v__ast__Type_alias_eq((*expr._v__ast__CastExpr).typ, _const_v__ast__u16_type)) {
			Option_u16 _t41 = v__ast__ComptTimeConstValue_u16(cast_expr_value);
			if (_t41.state != 0) { /*or block*/ 
				IError err = _t41.err;
				return (Option_v__ast__ComptTimeConstValue){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			
 			Option_v__ast__ComptTimeConstValue _t40;
			opt_ok(&(v__ast__ComptTimeConstValue[]) { u16_to_sumtype_v__ast__ComptTimeConstValue(ADDR(u16, ( (*(u16*)_t41.data)))) }, (Option*)(&_t40), sizeof(v__ast__ComptTimeConstValue));
			return _t40;
		}
		if (v__ast__Type_alias_eq((*expr._v__ast__CastExpr).typ, _const_v__ast__u32_type)) {
			Option_u32 _t44 = v__ast__ComptTimeConstValue_u32(cast_expr_value);
			if (_t44.state != 0) { /*or block*/ 
				IError err = _t44.err;
				return (Option_v__ast__ComptTimeConstValue){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			
 			Option_v__ast__ComptTimeConstValue _t43;
			opt_ok(&(v__ast__ComptTimeConstValue[]) { u32_to_sumtype_v__ast__ComptTimeConstValue(ADDR(u32, ( (*(u32*)_t44.data)))) }, (Option*)(&_t43), sizeof(v__ast__ComptTimeConstValue));
			return _t43;
		}
		if (v__ast__Type_alias_eq((*expr._v__ast__CastExpr).typ, _const_v__ast__u64_type)) {
			Option_u64 _t47 = v__ast__ComptTimeConstValue_u64(cast_expr_value);
			if (_t47.state != 0) { /*or block*/ 
				IError err = _t47.err;
				return (Option_v__ast__ComptTimeConstValue){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			
 			Option_v__ast__ComptTimeConstValue _t46;
			opt_ok(&(v__ast__ComptTimeConstValue[]) { u64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(u64, ( (*(u64*)_t47.data)))) }, (Option*)(&_t46), sizeof(v__ast__ComptTimeConstValue));
			return _t46;
		}
		if (v__ast__Type_alias_eq((*expr._v__ast__CastExpr).typ, _const_v__ast__f32_type)) {
			Option_f32 _t50 = v__ast__ComptTimeConstValue_f32(cast_expr_value);
			if (_t50.state != 0) { /*or block*/ 
				IError err = _t50.err;
				return (Option_v__ast__ComptTimeConstValue){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			
 			Option_v__ast__ComptTimeConstValue _t49;
			opt_ok(&(v__ast__ComptTimeConstValue[]) { f32_to_sumtype_v__ast__ComptTimeConstValue(ADDR(f32, ( (*(f32*)_t50.data)))) }, (Option*)(&_t49), sizeof(v__ast__ComptTimeConstValue));
			return _t49;
		}
		if (v__ast__Type_alias_eq((*expr._v__ast__CastExpr).typ, _const_v__ast__f64_type)) {
			Option_f64 _t53 = v__ast__ComptTimeConstValue_f64(cast_expr_value);
			if (_t53.state != 0) { /*or block*/ 
				IError err = _t53.err;
				return (Option_v__ast__ComptTimeConstValue){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			
 			Option_v__ast__ComptTimeConstValue _t52;
			opt_ok(&(v__ast__ComptTimeConstValue[]) { f64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(f64, ( (*(f64*)_t53.data)))) }, (Option*)(&_t52), sizeof(v__ast__ComptTimeConstValue));
			return _t52;
		}
	}
	else if (expr._typ == 303 /* v.ast.InfixExpr */) {
		Option_v__ast__ComptTimeConstValue _t55 = v__checker__Checker_eval_comptime_const_expr(c, (*expr._v__ast__InfixExpr).left, nlevel + 1);
		if (_t55.state != 0) { /*or block*/ 
			Option_v__ast__ComptTimeConstValue _t56;
			memcpy(&_t56, &_t55, sizeof(Option));
			return _t56;
		}
		
 		v__ast__ComptTimeConstValue left =  (*(v__ast__ComptTimeConstValue*)_t55.data);
		Option_v__ast__ComptTimeConstValue _t57 = v__checker__Checker_eval_comptime_const_expr(c, (*expr._v__ast__InfixExpr).right, nlevel + 1);
		if (_t57.state != 0) { /*or block*/ 
			Option_v__ast__ComptTimeConstValue _t58;
			memcpy(&_t58, &_t57, sizeof(Option));
			return _t58;
		}
		
 		v__ast__ComptTimeConstValue right =  (*(v__ast__ComptTimeConstValue*)_t57.data);
		if ((left)._typ == 20 /* string */ && (right)._typ == 20 /* string */) {

			if ((*expr._v__ast__InfixExpr).op == (v__token__Kind__plus)) {
				Option_v__ast__ComptTimeConstValue _t59;
				opt_ok(&(v__ast__ComptTimeConstValue[]) { string_to_sumtype_v__ast__ComptTimeConstValue(ADDR(string, (string__plus((*left._string), (*right._string))))) }, (Option*)(&_t59), sizeof(v__ast__ComptTimeConstValue));
				return _t59;
			}
			else {
				return (Option_v__ast__ComptTimeConstValue){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
			};
		} else if ((left)._typ == 13 /* u64 */ && (right)._typ == 8 /* i64 */) {
			switch ((*expr._v__ast__InfixExpr).op) {
				case v__token__Kind__plus: 
					{
						Option_v__ast__ComptTimeConstValue _t61;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { i64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(i64, (((i64)((*left._u64))) + ((i64)((*right._i64)))))) }, (Option*)(&_t61), sizeof(v__ast__ComptTimeConstValue));
						return _t61;
					} break;
				case v__token__Kind__minus: 
					{
						Option_v__ast__ComptTimeConstValue _t62;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { i64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(i64, (((i64)((*left._u64))) - ((i64)((*right._i64)))))) }, (Option*)(&_t62), sizeof(v__ast__ComptTimeConstValue));
						return _t62;
					} break;
				case v__token__Kind__mul: 
					{
						Option_v__ast__ComptTimeConstValue _t63;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { i64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(i64, (((i64)((*left._u64))) * ((i64)((*right._i64)))))) }, (Option*)(&_t63), sizeof(v__ast__ComptTimeConstValue));
						return _t63;
					} break;
				case v__token__Kind__div: 
					{
						Option_v__ast__ComptTimeConstValue _t64;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { i64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(i64, (((i64)((*left._u64))) / ((i64)((*right._i64)))))) }, (Option*)(&_t64), sizeof(v__ast__ComptTimeConstValue));
						return _t64;
					} break;
				case v__token__Kind__mod: 
					{
						Option_v__ast__ComptTimeConstValue _t65;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { i64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(i64, (((i64)((*left._u64))) % ((i64)((*right._i64)))))) }, (Option*)(&_t65), sizeof(v__ast__ComptTimeConstValue));
						return _t65;
					} break;
				case v__token__Kind__xor: 
					{
						Option_v__ast__ComptTimeConstValue _t66;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { i64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(i64, ((((i64)((*left._u64))) ^ ((i64)((*right._i64))))))) }, (Option*)(&_t66), sizeof(v__ast__ComptTimeConstValue));
						return _t66;
					} break;
				case v__token__Kind__pipe: 
					{
						Option_v__ast__ComptTimeConstValue _t67;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { i64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(i64, ((((i64)((*left._u64))) | ((i64)((*right._i64))))))) }, (Option*)(&_t67), sizeof(v__ast__ComptTimeConstValue));
						return _t67;
					} break;
				case v__token__Kind__amp: 
					{
						Option_v__ast__ComptTimeConstValue _t68;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { i64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(i64, ((((i64)((*left._u64))) & ((i64)((*right._i64))))))) }, (Option*)(&_t68), sizeof(v__ast__ComptTimeConstValue));
						return _t68;
					} break;
				case v__token__Kind__left_shift: 
					{
						Option_v__ast__ComptTimeConstValue _t69;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { i64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(i64, (((i64)(((u64)((*left._u64))) << ((i64)((*right._i64)))))))) }, (Option*)(&_t69), sizeof(v__ast__ComptTimeConstValue));
						return _t69;
					} break;
				case v__token__Kind__right_shift: 
					{
						Option_v__ast__ComptTimeConstValue _t70;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { i64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(i64, (((i64)(((u64)((*left._u64))) >> ((i64)((*right._i64)))))))) }, (Option*)(&_t70), sizeof(v__ast__ComptTimeConstValue));
						return _t70;
					} break;
				case v__token__Kind__unsigned_right_shift: 
					{
						Option_v__ast__ComptTimeConstValue _t71;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { i64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(i64, (((i64)(((u64)(((u64)((*left._u64))))) >> ((i64)((*right._i64)))))))) }, (Option*)(&_t71), sizeof(v__ast__ComptTimeConstValue));
						return _t71;
					} break;
				case v__token__Kind__unknown:
				case v__token__Kind__eof:
				case v__token__Kind__name:
				case v__token__Kind__number:
				case v__token__Kind__string:
				case v__token__Kind__str_inter:
				case v__token__Kind__chartoken:
				case v__token__Kind__inc:
				case v__token__Kind__dec:
				case v__token__Kind__and:
				case v__token__Kind__logical_or:
				case v__token__Kind__not:
				case v__token__Kind__bit_not:
				case v__token__Kind__question:
				case v__token__Kind__comma:
				case v__token__Kind__semicolon:
				case v__token__Kind__colon:
				case v__token__Kind__arrow:
				case v__token__Kind__hash:
				case v__token__Kind__dollar:
				case v__token__Kind__at:
				case v__token__Kind__str_dollar:
				case v__token__Kind__not_in:
				case v__token__Kind__not_is:
				case v__token__Kind__assign:
				case v__token__Kind__decl_assign:
				case v__token__Kind__plus_assign:
				case v__token__Kind__minus_assign:
				case v__token__Kind__div_assign:
				case v__token__Kind__mult_assign:
				case v__token__Kind__xor_assign:
				case v__token__Kind__mod_assign:
				case v__token__Kind__or_assign:
				case v__token__Kind__and_assign:
				case v__token__Kind__right_shift_assign:
				case v__token__Kind__left_shift_assign:
				case v__token__Kind__unsigned_right_shift_assign:
				case v__token__Kind__lcbr:
				case v__token__Kind__rcbr:
				case v__token__Kind__lpar:
				case v__token__Kind__rpar:
				case v__token__Kind__lsbr:
				case v__token__Kind__nilsbr:
				case v__token__Kind__rsbr:
				case v__token__Kind__eq:
				case v__token__Kind__ne:
				case v__token__Kind__gt:
				case v__token__Kind__lt:
				case v__token__Kind__ge:
				case v__token__Kind__le:
				case v__token__Kind__comment:
				case v__token__Kind__nl:
				case v__token__Kind__dot:
				case v__token__Kind__dotdot:
				case v__token__Kind__ellipsis:
				case v__token__Kind__keyword_beg:
				case v__token__Kind__key_as:
				case v__token__Kind__key_asm:
				case v__token__Kind__key_assert:
				case v__token__Kind__key_atomic:
				case v__token__Kind__key_break:
				case v__token__Kind__key_const:
				case v__token__Kind__key_continue:
				case v__token__Kind__key_defer:
				case v__token__Kind__key_else:
				case v__token__Kind__key_enum:
				case v__token__Kind__key_false:
				case v__token__Kind__key_for:
				case v__token__Kind__key_fn:
				case v__token__Kind__key_global:
				case v__token__Kind__key_go:
				case v__token__Kind__key_goto:
				case v__token__Kind__key_if:
				case v__token__Kind__key_import:
				case v__token__Kind__key_in:
				case v__token__Kind__key_interface:
				case v__token__Kind__key_is:
				case v__token__Kind__key_match:
				case v__token__Kind__key_module:
				case v__token__Kind__key_mut:
				case v__token__Kind__key_shared:
				case v__token__Kind__key_lock:
				case v__token__Kind__key_rlock:
				case v__token__Kind__key_none:
				case v__token__Kind__key_return:
				case v__token__Kind__key_select:
				case v__token__Kind__key_sizeof:
				case v__token__Kind__key_isreftype:
				case v__token__Kind__key_likely:
				case v__token__Kind__key_unlikely:
				case v__token__Kind__key_offsetof:
				case v__token__Kind__key_struct:
				case v__token__Kind__key_true:
				case v__token__Kind__key_type:
				case v__token__Kind__key_typeof:
				case v__token__Kind__key_dump:
				case v__token__Kind__key_orelse:
				case v__token__Kind__key_union:
				case v__token__Kind__key_pub:
				case v__token__Kind__key_static:
				case v__token__Kind__key_volatile:
				case v__token__Kind__key_unsafe:
				case v__token__Kind__keyword_end:
				case v__token__Kind___end_:
				default:
					{
						return (Option_v__ast__ComptTimeConstValue){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
					} break;
			}
			;
		} else if ((left)._typ == 8 /* i64 */ && (right)._typ == 13 /* u64 */) {
			switch ((*expr._v__ast__InfixExpr).op) {
				case v__token__Kind__plus: 
					{
						Option_v__ast__ComptTimeConstValue _t73;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { i64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(i64, (((i64)((*left._i64))) + ((i64)((*right._u64)))))) }, (Option*)(&_t73), sizeof(v__ast__ComptTimeConstValue));
						return _t73;
					} break;
				case v__token__Kind__minus: 
					{
						Option_v__ast__ComptTimeConstValue _t74;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { i64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(i64, (((i64)((*left._i64))) - ((i64)((*right._u64)))))) }, (Option*)(&_t74), sizeof(v__ast__ComptTimeConstValue));
						return _t74;
					} break;
				case v__token__Kind__mul: 
					{
						Option_v__ast__ComptTimeConstValue _t75;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { i64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(i64, (((i64)((*left._i64))) * ((i64)((*right._u64)))))) }, (Option*)(&_t75), sizeof(v__ast__ComptTimeConstValue));
						return _t75;
					} break;
				case v__token__Kind__div: 
					{
						Option_v__ast__ComptTimeConstValue _t76;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { i64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(i64, (((i64)((*left._i64))) / ((i64)((*right._u64)))))) }, (Option*)(&_t76), sizeof(v__ast__ComptTimeConstValue));
						return _t76;
					} break;
				case v__token__Kind__mod: 
					{
						Option_v__ast__ComptTimeConstValue _t77;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { i64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(i64, (((i64)((*left._i64))) % ((i64)((*right._u64)))))) }, (Option*)(&_t77), sizeof(v__ast__ComptTimeConstValue));
						return _t77;
					} break;
				case v__token__Kind__xor: 
					{
						Option_v__ast__ComptTimeConstValue _t78;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { i64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(i64, ((((i64)((*left._i64))) ^ ((i64)((*right._u64))))))) }, (Option*)(&_t78), sizeof(v__ast__ComptTimeConstValue));
						return _t78;
					} break;
				case v__token__Kind__pipe: 
					{
						Option_v__ast__ComptTimeConstValue _t79;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { i64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(i64, ((((i64)((*left._i64))) | ((i64)((*right._u64))))))) }, (Option*)(&_t79), sizeof(v__ast__ComptTimeConstValue));
						return _t79;
					} break;
				case v__token__Kind__amp: 
					{
						Option_v__ast__ComptTimeConstValue _t80;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { i64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(i64, ((((i64)((*left._i64))) & ((i64)((*right._u64))))))) }, (Option*)(&_t80), sizeof(v__ast__ComptTimeConstValue));
						return _t80;
					} break;
				case v__token__Kind__left_shift: 
					{
						Option_v__ast__ComptTimeConstValue _t81;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { i64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(i64, (((i64)(((u64)((*left._i64))) << ((i64)((*right._u64)))))))) }, (Option*)(&_t81), sizeof(v__ast__ComptTimeConstValue));
						return _t81;
					} break;
				case v__token__Kind__right_shift: 
					{
						Option_v__ast__ComptTimeConstValue _t82;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { i64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(i64, (((i64)(((u64)((*left._i64))) >> ((i64)((*right._u64)))))))) }, (Option*)(&_t82), sizeof(v__ast__ComptTimeConstValue));
						return _t82;
					} break;
				case v__token__Kind__unsigned_right_shift: 
					{
						Option_v__ast__ComptTimeConstValue _t83;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { i64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(i64, (((i64)(((u64)(((u64)((*left._i64))))) >> ((i64)((*right._u64)))))))) }, (Option*)(&_t83), sizeof(v__ast__ComptTimeConstValue));
						return _t83;
					} break;
				case v__token__Kind__unknown:
				case v__token__Kind__eof:
				case v__token__Kind__name:
				case v__token__Kind__number:
				case v__token__Kind__string:
				case v__token__Kind__str_inter:
				case v__token__Kind__chartoken:
				case v__token__Kind__inc:
				case v__token__Kind__dec:
				case v__token__Kind__and:
				case v__token__Kind__logical_or:
				case v__token__Kind__not:
				case v__token__Kind__bit_not:
				case v__token__Kind__question:
				case v__token__Kind__comma:
				case v__token__Kind__semicolon:
				case v__token__Kind__colon:
				case v__token__Kind__arrow:
				case v__token__Kind__hash:
				case v__token__Kind__dollar:
				case v__token__Kind__at:
				case v__token__Kind__str_dollar:
				case v__token__Kind__not_in:
				case v__token__Kind__not_is:
				case v__token__Kind__assign:
				case v__token__Kind__decl_assign:
				case v__token__Kind__plus_assign:
				case v__token__Kind__minus_assign:
				case v__token__Kind__div_assign:
				case v__token__Kind__mult_assign:
				case v__token__Kind__xor_assign:
				case v__token__Kind__mod_assign:
				case v__token__Kind__or_assign:
				case v__token__Kind__and_assign:
				case v__token__Kind__right_shift_assign:
				case v__token__Kind__left_shift_assign:
				case v__token__Kind__unsigned_right_shift_assign:
				case v__token__Kind__lcbr:
				case v__token__Kind__rcbr:
				case v__token__Kind__lpar:
				case v__token__Kind__rpar:
				case v__token__Kind__lsbr:
				case v__token__Kind__nilsbr:
				case v__token__Kind__rsbr:
				case v__token__Kind__eq:
				case v__token__Kind__ne:
				case v__token__Kind__gt:
				case v__token__Kind__lt:
				case v__token__Kind__ge:
				case v__token__Kind__le:
				case v__token__Kind__comment:
				case v__token__Kind__nl:
				case v__token__Kind__dot:
				case v__token__Kind__dotdot:
				case v__token__Kind__ellipsis:
				case v__token__Kind__keyword_beg:
				case v__token__Kind__key_as:
				case v__token__Kind__key_asm:
				case v__token__Kind__key_assert:
				case v__token__Kind__key_atomic:
				case v__token__Kind__key_break:
				case v__token__Kind__key_const:
				case v__token__Kind__key_continue:
				case v__token__Kind__key_defer:
				case v__token__Kind__key_else:
				case v__token__Kind__key_enum:
				case v__token__Kind__key_false:
				case v__token__Kind__key_for:
				case v__token__Kind__key_fn:
				case v__token__Kind__key_global:
				case v__token__Kind__key_go:
				case v__token__Kind__key_goto:
				case v__token__Kind__key_if:
				case v__token__Kind__key_import:
				case v__token__Kind__key_in:
				case v__token__Kind__key_interface:
				case v__token__Kind__key_is:
				case v__token__Kind__key_match:
				case v__token__Kind__key_module:
				case v__token__Kind__key_mut:
				case v__token__Kind__key_shared:
				case v__token__Kind__key_lock:
				case v__token__Kind__key_rlock:
				case v__token__Kind__key_none:
				case v__token__Kind__key_return:
				case v__token__Kind__key_select:
				case v__token__Kind__key_sizeof:
				case v__token__Kind__key_isreftype:
				case v__token__Kind__key_likely:
				case v__token__Kind__key_unlikely:
				case v__token__Kind__key_offsetof:
				case v__token__Kind__key_struct:
				case v__token__Kind__key_true:
				case v__token__Kind__key_type:
				case v__token__Kind__key_typeof:
				case v__token__Kind__key_dump:
				case v__token__Kind__key_orelse:
				case v__token__Kind__key_union:
				case v__token__Kind__key_pub:
				case v__token__Kind__key_static:
				case v__token__Kind__key_volatile:
				case v__token__Kind__key_unsafe:
				case v__token__Kind__keyword_end:
				case v__token__Kind___end_:
				default:
					{
						return (Option_v__ast__ComptTimeConstValue){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
					} break;
			}
			;
		} else if ((left)._typ == 13 /* u64 */ && (right)._typ == 13 /* u64 */) {
			switch ((*expr._v__ast__InfixExpr).op) {
				case v__token__Kind__plus: 
					{
						Option_v__ast__ComptTimeConstValue _t85;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { u64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(u64, ((*left._u64) + (*right._u64)))) }, (Option*)(&_t85), sizeof(v__ast__ComptTimeConstValue));
						return _t85;
					} break;
				case v__token__Kind__minus: 
					{
						Option_v__ast__ComptTimeConstValue _t86;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { u64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(u64, ((*left._u64) - (*right._u64)))) }, (Option*)(&_t86), sizeof(v__ast__ComptTimeConstValue));
						return _t86;
					} break;
				case v__token__Kind__mul: 
					{
						Option_v__ast__ComptTimeConstValue _t87;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { u64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(u64, ((*left._u64) * (*right._u64)))) }, (Option*)(&_t87), sizeof(v__ast__ComptTimeConstValue));
						return _t87;
					} break;
				case v__token__Kind__div: 
					{
						Option_v__ast__ComptTimeConstValue _t88;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { u64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(u64, ((*left._u64) / (*right._u64)))) }, (Option*)(&_t88), sizeof(v__ast__ComptTimeConstValue));
						return _t88;
					} break;
				case v__token__Kind__mod: 
					{
						Option_v__ast__ComptTimeConstValue _t89;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { u64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(u64, ((*left._u64) % (*right._u64)))) }, (Option*)(&_t89), sizeof(v__ast__ComptTimeConstValue));
						return _t89;
					} break;
				case v__token__Kind__xor: 
					{
						Option_v__ast__ComptTimeConstValue _t90;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { u64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(u64, (((*left._u64) ^ (*right._u64))))) }, (Option*)(&_t90), sizeof(v__ast__ComptTimeConstValue));
						return _t90;
					} break;
				case v__token__Kind__pipe: 
					{
						Option_v__ast__ComptTimeConstValue _t91;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { u64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(u64, (((*left._u64) | (*right._u64))))) }, (Option*)(&_t91), sizeof(v__ast__ComptTimeConstValue));
						return _t91;
					} break;
				case v__token__Kind__amp: 
					{
						Option_v__ast__ComptTimeConstValue _t92;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { u64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(u64, (((*left._u64) & (*right._u64))))) }, (Option*)(&_t92), sizeof(v__ast__ComptTimeConstValue));
						return _t92;
					} break;
				case v__token__Kind__left_shift: 
					{
						Option_v__ast__ComptTimeConstValue _t93;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { u64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(u64, ((*left._u64) << (*right._u64)))) }, (Option*)(&_t93), sizeof(v__ast__ComptTimeConstValue));
						return _t93;
					} break;
				case v__token__Kind__right_shift: 
					{
						Option_v__ast__ComptTimeConstValue _t94;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { u64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(u64, ((*left._u64) >> (*right._u64)))) }, (Option*)(&_t94), sizeof(v__ast__ComptTimeConstValue));
						return _t94;
					} break;
				case v__token__Kind__unsigned_right_shift: 
					{
						Option_v__ast__ComptTimeConstValue _t95;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { u64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(u64, (((u64)((*left._u64))) >> (*right._u64)))) }, (Option*)(&_t95), sizeof(v__ast__ComptTimeConstValue));
						return _t95;
					} break;
				case v__token__Kind__unknown:
				case v__token__Kind__eof:
				case v__token__Kind__name:
				case v__token__Kind__number:
				case v__token__Kind__string:
				case v__token__Kind__str_inter:
				case v__token__Kind__chartoken:
				case v__token__Kind__inc:
				case v__token__Kind__dec:
				case v__token__Kind__and:
				case v__token__Kind__logical_or:
				case v__token__Kind__not:
				case v__token__Kind__bit_not:
				case v__token__Kind__question:
				case v__token__Kind__comma:
				case v__token__Kind__semicolon:
				case v__token__Kind__colon:
				case v__token__Kind__arrow:
				case v__token__Kind__hash:
				case v__token__Kind__dollar:
				case v__token__Kind__at:
				case v__token__Kind__str_dollar:
				case v__token__Kind__not_in:
				case v__token__Kind__not_is:
				case v__token__Kind__assign:
				case v__token__Kind__decl_assign:
				case v__token__Kind__plus_assign:
				case v__token__Kind__minus_assign:
				case v__token__Kind__div_assign:
				case v__token__Kind__mult_assign:
				case v__token__Kind__xor_assign:
				case v__token__Kind__mod_assign:
				case v__token__Kind__or_assign:
				case v__token__Kind__and_assign:
				case v__token__Kind__right_shift_assign:
				case v__token__Kind__left_shift_assign:
				case v__token__Kind__unsigned_right_shift_assign:
				case v__token__Kind__lcbr:
				case v__token__Kind__rcbr:
				case v__token__Kind__lpar:
				case v__token__Kind__rpar:
				case v__token__Kind__lsbr:
				case v__token__Kind__nilsbr:
				case v__token__Kind__rsbr:
				case v__token__Kind__eq:
				case v__token__Kind__ne:
				case v__token__Kind__gt:
				case v__token__Kind__lt:
				case v__token__Kind__ge:
				case v__token__Kind__le:
				case v__token__Kind__comment:
				case v__token__Kind__nl:
				case v__token__Kind__dot:
				case v__token__Kind__dotdot:
				case v__token__Kind__ellipsis:
				case v__token__Kind__keyword_beg:
				case v__token__Kind__key_as:
				case v__token__Kind__key_asm:
				case v__token__Kind__key_assert:
				case v__token__Kind__key_atomic:
				case v__token__Kind__key_break:
				case v__token__Kind__key_const:
				case v__token__Kind__key_continue:
				case v__token__Kind__key_defer:
				case v__token__Kind__key_else:
				case v__token__Kind__key_enum:
				case v__token__Kind__key_false:
				case v__token__Kind__key_for:
				case v__token__Kind__key_fn:
				case v__token__Kind__key_global:
				case v__token__Kind__key_go:
				case v__token__Kind__key_goto:
				case v__token__Kind__key_if:
				case v__token__Kind__key_import:
				case v__token__Kind__key_in:
				case v__token__Kind__key_interface:
				case v__token__Kind__key_is:
				case v__token__Kind__key_match:
				case v__token__Kind__key_module:
				case v__token__Kind__key_mut:
				case v__token__Kind__key_shared:
				case v__token__Kind__key_lock:
				case v__token__Kind__key_rlock:
				case v__token__Kind__key_none:
				case v__token__Kind__key_return:
				case v__token__Kind__key_select:
				case v__token__Kind__key_sizeof:
				case v__token__Kind__key_isreftype:
				case v__token__Kind__key_likely:
				case v__token__Kind__key_unlikely:
				case v__token__Kind__key_offsetof:
				case v__token__Kind__key_struct:
				case v__token__Kind__key_true:
				case v__token__Kind__key_type:
				case v__token__Kind__key_typeof:
				case v__token__Kind__key_dump:
				case v__token__Kind__key_orelse:
				case v__token__Kind__key_union:
				case v__token__Kind__key_pub:
				case v__token__Kind__key_static:
				case v__token__Kind__key_volatile:
				case v__token__Kind__key_unsafe:
				case v__token__Kind__keyword_end:
				case v__token__Kind___end_:
				default:
					{
						return (Option_v__ast__ComptTimeConstValue){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
					} break;
			}
			;
		} else if ((left)._typ == 8 /* i64 */ && (right)._typ == 8 /* i64 */) {
			switch ((*expr._v__ast__InfixExpr).op) {
				case v__token__Kind__plus: 
					{
						Option_v__ast__ComptTimeConstValue _t97;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { i64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(i64, ((*left._i64) + (*right._i64)))) }, (Option*)(&_t97), sizeof(v__ast__ComptTimeConstValue));
						return _t97;
					} break;
				case v__token__Kind__minus: 
					{
						Option_v__ast__ComptTimeConstValue _t98;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { i64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(i64, ((*left._i64) - (*right._i64)))) }, (Option*)(&_t98), sizeof(v__ast__ComptTimeConstValue));
						return _t98;
					} break;
				case v__token__Kind__mul: 
					{
						Option_v__ast__ComptTimeConstValue _t99;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { i64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(i64, ((*left._i64) * (*right._i64)))) }, (Option*)(&_t99), sizeof(v__ast__ComptTimeConstValue));
						return _t99;
					} break;
				case v__token__Kind__div: 
					{
						Option_v__ast__ComptTimeConstValue _t100;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { i64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(i64, ((*left._i64) / (*right._i64)))) }, (Option*)(&_t100), sizeof(v__ast__ComptTimeConstValue));
						return _t100;
					} break;
				case v__token__Kind__mod: 
					{
						Option_v__ast__ComptTimeConstValue _t101;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { i64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(i64, ((*left._i64) % (*right._i64)))) }, (Option*)(&_t101), sizeof(v__ast__ComptTimeConstValue));
						return _t101;
					} break;
				case v__token__Kind__xor: 
					{
						Option_v__ast__ComptTimeConstValue _t102;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { i64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(i64, (((*left._i64) ^ (*right._i64))))) }, (Option*)(&_t102), sizeof(v__ast__ComptTimeConstValue));
						return _t102;
					} break;
				case v__token__Kind__pipe: 
					{
						Option_v__ast__ComptTimeConstValue _t103;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { i64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(i64, (((*left._i64) | (*right._i64))))) }, (Option*)(&_t103), sizeof(v__ast__ComptTimeConstValue));
						return _t103;
					} break;
				case v__token__Kind__amp: 
					{
						Option_v__ast__ComptTimeConstValue _t104;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { i64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(i64, (((*left._i64) & (*right._i64))))) }, (Option*)(&_t104), sizeof(v__ast__ComptTimeConstValue));
						return _t104;
					} break;
				case v__token__Kind__left_shift: 
					{
						Option_v__ast__ComptTimeConstValue _t105;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { i64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(i64, (((i64)(((u64)((*left._i64))) << (*right._i64)))))) }, (Option*)(&_t105), sizeof(v__ast__ComptTimeConstValue));
						return _t105;
					} break;
				case v__token__Kind__right_shift: 
					{
						Option_v__ast__ComptTimeConstValue _t106;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { i64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(i64, (((i64)(((u64)((*left._i64))) >> (*right._i64)))))) }, (Option*)(&_t106), sizeof(v__ast__ComptTimeConstValue));
						return _t106;
					} break;
				case v__token__Kind__unsigned_right_shift: 
					{
						Option_v__ast__ComptTimeConstValue _t107;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { i64_to_sumtype_v__ast__ComptTimeConstValue(ADDR(i64, (((i64)(((u64)(((u64)((*left._i64))))) >> (*right._i64)))))) }, (Option*)(&_t107), sizeof(v__ast__ComptTimeConstValue));
						return _t107;
					} break;
				case v__token__Kind__unknown:
				case v__token__Kind__eof:
				case v__token__Kind__name:
				case v__token__Kind__number:
				case v__token__Kind__string:
				case v__token__Kind__str_inter:
				case v__token__Kind__chartoken:
				case v__token__Kind__inc:
				case v__token__Kind__dec:
				case v__token__Kind__and:
				case v__token__Kind__logical_or:
				case v__token__Kind__not:
				case v__token__Kind__bit_not:
				case v__token__Kind__question:
				case v__token__Kind__comma:
				case v__token__Kind__semicolon:
				case v__token__Kind__colon:
				case v__token__Kind__arrow:
				case v__token__Kind__hash:
				case v__token__Kind__dollar:
				case v__token__Kind__at:
				case v__token__Kind__str_dollar:
				case v__token__Kind__not_in:
				case v__token__Kind__not_is:
				case v__token__Kind__assign:
				case v__token__Kind__decl_assign:
				case v__token__Kind__plus_assign:
				case v__token__Kind__minus_assign:
				case v__token__Kind__div_assign:
				case v__token__Kind__mult_assign:
				case v__token__Kind__xor_assign:
				case v__token__Kind__mod_assign:
				case v__token__Kind__or_assign:
				case v__token__Kind__and_assign:
				case v__token__Kind__right_shift_assign:
				case v__token__Kind__left_shift_assign:
				case v__token__Kind__unsigned_right_shift_assign:
				case v__token__Kind__lcbr:
				case v__token__Kind__rcbr:
				case v__token__Kind__lpar:
				case v__token__Kind__rpar:
				case v__token__Kind__lsbr:
				case v__token__Kind__nilsbr:
				case v__token__Kind__rsbr:
				case v__token__Kind__eq:
				case v__token__Kind__ne:
				case v__token__Kind__gt:
				case v__token__Kind__lt:
				case v__token__Kind__ge:
				case v__token__Kind__le:
				case v__token__Kind__comment:
				case v__token__Kind__nl:
				case v__token__Kind__dot:
				case v__token__Kind__dotdot:
				case v__token__Kind__ellipsis:
				case v__token__Kind__keyword_beg:
				case v__token__Kind__key_as:
				case v__token__Kind__key_asm:
				case v__token__Kind__key_assert:
				case v__token__Kind__key_atomic:
				case v__token__Kind__key_break:
				case v__token__Kind__key_const:
				case v__token__Kind__key_continue:
				case v__token__Kind__key_defer:
				case v__token__Kind__key_else:
				case v__token__Kind__key_enum:
				case v__token__Kind__key_false:
				case v__token__Kind__key_for:
				case v__token__Kind__key_fn:
				case v__token__Kind__key_global:
				case v__token__Kind__key_go:
				case v__token__Kind__key_goto:
				case v__token__Kind__key_if:
				case v__token__Kind__key_import:
				case v__token__Kind__key_in:
				case v__token__Kind__key_interface:
				case v__token__Kind__key_is:
				case v__token__Kind__key_match:
				case v__token__Kind__key_module:
				case v__token__Kind__key_mut:
				case v__token__Kind__key_shared:
				case v__token__Kind__key_lock:
				case v__token__Kind__key_rlock:
				case v__token__Kind__key_none:
				case v__token__Kind__key_return:
				case v__token__Kind__key_select:
				case v__token__Kind__key_sizeof:
				case v__token__Kind__key_isreftype:
				case v__token__Kind__key_likely:
				case v__token__Kind__key_unlikely:
				case v__token__Kind__key_offsetof:
				case v__token__Kind__key_struct:
				case v__token__Kind__key_true:
				case v__token__Kind__key_type:
				case v__token__Kind__key_typeof:
				case v__token__Kind__key_dump:
				case v__token__Kind__key_orelse:
				case v__token__Kind__key_union:
				case v__token__Kind__key_pub:
				case v__token__Kind__key_static:
				case v__token__Kind__key_volatile:
				case v__token__Kind__key_unsafe:
				case v__token__Kind__keyword_end:
				case v__token__Kind___end_:
				default:
					{
						return (Option_v__ast__ComptTimeConstValue){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
					} break;
			}
			;
		} else if ((left)._typ == 10 /* byte */ && (right)._typ == 10 /* byte */) {
			switch ((*expr._v__ast__InfixExpr).op) {
				case v__token__Kind__plus: 
					{
						Option_v__ast__ComptTimeConstValue _t109;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { byte_to_sumtype_v__ast__ComptTimeConstValue(ADDR(byte, ((*left._byte) + (*right._byte)))) }, (Option*)(&_t109), sizeof(v__ast__ComptTimeConstValue));
						return _t109;
					} break;
				case v__token__Kind__minus: 
					{
						Option_v__ast__ComptTimeConstValue _t110;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { byte_to_sumtype_v__ast__ComptTimeConstValue(ADDR(byte, ((*left._byte) - (*right._byte)))) }, (Option*)(&_t110), sizeof(v__ast__ComptTimeConstValue));
						return _t110;
					} break;
				case v__token__Kind__mul: 
					{
						Option_v__ast__ComptTimeConstValue _t111;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { byte_to_sumtype_v__ast__ComptTimeConstValue(ADDR(byte, ((*left._byte) * (*right._byte)))) }, (Option*)(&_t111), sizeof(v__ast__ComptTimeConstValue));
						return _t111;
					} break;
				case v__token__Kind__div: 
					{
						Option_v__ast__ComptTimeConstValue _t112;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { byte_to_sumtype_v__ast__ComptTimeConstValue(ADDR(byte, ((*left._byte) / (*right._byte)))) }, (Option*)(&_t112), sizeof(v__ast__ComptTimeConstValue));
						return _t112;
					} break;
				case v__token__Kind__mod: 
					{
						Option_v__ast__ComptTimeConstValue _t113;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { byte_to_sumtype_v__ast__ComptTimeConstValue(ADDR(byte, ((*left._byte) % (*right._byte)))) }, (Option*)(&_t113), sizeof(v__ast__ComptTimeConstValue));
						return _t113;
					} break;
				case v__token__Kind__xor: 
					{
						Option_v__ast__ComptTimeConstValue _t114;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { byte_to_sumtype_v__ast__ComptTimeConstValue(ADDR(byte, (((*left._byte) ^ (*right._byte))))) }, (Option*)(&_t114), sizeof(v__ast__ComptTimeConstValue));
						return _t114;
					} break;
				case v__token__Kind__pipe: 
					{
						Option_v__ast__ComptTimeConstValue _t115;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { byte_to_sumtype_v__ast__ComptTimeConstValue(ADDR(byte, (((*left._byte) | (*right._byte))))) }, (Option*)(&_t115), sizeof(v__ast__ComptTimeConstValue));
						return _t115;
					} break;
				case v__token__Kind__amp: 
					{
						Option_v__ast__ComptTimeConstValue _t116;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { byte_to_sumtype_v__ast__ComptTimeConstValue(ADDR(byte, (((*left._byte) & (*right._byte))))) }, (Option*)(&_t116), sizeof(v__ast__ComptTimeConstValue));
						return _t116;
					} break;
				case v__token__Kind__left_shift: 
					{
						Option_v__ast__ComptTimeConstValue _t117;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { byte_to_sumtype_v__ast__ComptTimeConstValue(ADDR(byte, ((*left._byte) << (*right._byte)))) }, (Option*)(&_t117), sizeof(v__ast__ComptTimeConstValue));
						return _t117;
					} break;
				case v__token__Kind__right_shift: 
					{
						Option_v__ast__ComptTimeConstValue _t118;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { byte_to_sumtype_v__ast__ComptTimeConstValue(ADDR(byte, ((*left._byte) >> (*right._byte)))) }, (Option*)(&_t118), sizeof(v__ast__ComptTimeConstValue));
						return _t118;
					} break;
				case v__token__Kind__unsigned_right_shift: 
					{
						Option_v__ast__ComptTimeConstValue _t119;
						opt_ok(&(v__ast__ComptTimeConstValue[]) { byte_to_sumtype_v__ast__ComptTimeConstValue(ADDR(byte, (((byte)((*left._byte))) >> (*right._byte)))) }, (Option*)(&_t119), sizeof(v__ast__ComptTimeConstValue));
						return _t119;
					} break;
				case v__token__Kind__unknown:
				case v__token__Kind__eof:
				case v__token__Kind__name:
				case v__token__Kind__number:
				case v__token__Kind__string:
				case v__token__Kind__str_inter:
				case v__token__Kind__chartoken:
				case v__token__Kind__inc:
				case v__token__Kind__dec:
				case v__token__Kind__and:
				case v__token__Kind__logical_or:
				case v__token__Kind__not:
				case v__token__Kind__bit_not:
				case v__token__Kind__question:
				case v__token__Kind__comma:
				case v__token__Kind__semicolon:
				case v__token__Kind__colon:
				case v__token__Kind__arrow:
				case v__token__Kind__hash:
				case v__token__Kind__dollar:
				case v__token__Kind__at:
				case v__token__Kind__str_dollar:
				case v__token__Kind__not_in:
				case v__token__Kind__not_is:
				case v__token__Kind__assign:
				case v__token__Kind__decl_assign:
				case v__token__Kind__plus_assign:
				case v__token__Kind__minus_assign:
				case v__token__Kind__div_assign:
				case v__token__Kind__mult_assign:
				case v__token__Kind__xor_assign:
				case v__token__Kind__mod_assign:
				case v__token__Kind__or_assign:
				case v__token__Kind__and_assign:
				case v__token__Kind__right_shift_assign:
				case v__token__Kind__left_shift_assign:
				case v__token__Kind__unsigned_right_shift_assign:
				case v__token__Kind__lcbr:
				case v__token__Kind__rcbr:
				case v__token__Kind__lpar:
				case v__token__Kind__rpar:
				case v__token__Kind__lsbr:
				case v__token__Kind__nilsbr:
				case v__token__Kind__rsbr:
				case v__token__Kind__eq:
				case v__token__Kind__ne:
				case v__token__Kind__gt:
				case v__token__Kind__lt:
				case v__token__Kind__ge:
				case v__token__Kind__le:
				case v__token__Kind__comment:
				case v__token__Kind__nl:
				case v__token__Kind__dot:
				case v__token__Kind__dotdot:
				case v__token__Kind__ellipsis:
				case v__token__Kind__keyword_beg:
				case v__token__Kind__key_as:
				case v__token__Kind__key_asm:
				case v__token__Kind__key_assert:
				case v__token__Kind__key_atomic:
				case v__token__Kind__key_break:
				case v__token__Kind__key_const:
				case v__token__Kind__key_continue:
				case v__token__Kind__key_defer:
				case v__token__Kind__key_else:
				case v__token__Kind__key_enum:
				case v__token__Kind__key_false:
				case v__token__Kind__key_for:
				case v__token__Kind__key_fn:
				case v__token__Kind__key_global:
				case v__token__Kind__key_go:
				case v__token__Kind__key_goto:
				case v__token__Kind__key_if:
				case v__token__Kind__key_import:
				case v__token__Kind__key_in:
				case v__token__Kind__key_interface:
				case v__token__Kind__key_is:
				case v__token__Kind__key_match:
				case v__token__Kind__key_module:
				case v__token__Kind__key_mut:
				case v__token__Kind__key_shared:
				case v__token__Kind__key_lock:
				case v__token__Kind__key_rlock:
				case v__token__Kind__key_none:
				case v__token__Kind__key_return:
				case v__token__Kind__key_select:
				case v__token__Kind__key_sizeof:
				case v__token__Kind__key_isreftype:
				case v__token__Kind__key_likely:
				case v__token__Kind__key_unlikely:
				case v__token__Kind__key_offsetof:
				case v__token__Kind__key_struct:
				case v__token__Kind__key_true:
				case v__token__Kind__key_type:
				case v__token__Kind__key_typeof:
				case v__token__Kind__key_dump:
				case v__token__Kind__key_orelse:
				case v__token__Kind__key_union:
				case v__token__Kind__key_pub:
				case v__token__Kind__key_static:
				case v__token__Kind__key_volatile:
				case v__token__Kind__key_unsafe:
				case v__token__Kind__keyword_end:
				case v__token__Kind___end_:
				default:
					{
						return (Option_v__ast__ComptTimeConstValue){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
					} break;
			}
			;
		}
	}
	
	else {
		return (Option_v__ast__ComptTimeConstValue){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	;
	return (Option_v__ast__ComptTimeConstValue){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
}

VV_LOCAL_SYMBOL multi_return_bool_int_int v__checker__Checker_verify_vweb_params_for_method(v__checker__Checker* c, v__ast__Fn node) {
	int margs = node.params.len - 1;
	if (node.attrs.len == 0) {
		return (multi_return_bool_int_int){.arg0=true, .arg1=-1, .arg2=margs};
	}
	if (node.params.len > 1) {
		Array_v__ast__Param _t2 = array_slice(node.params, 1, node.params.len);
		for (int _t3 = 0; _t3 < _t2.len; ++_t3) {
			v__ast__Param param = ((v__ast__Param*)_t2.data)[_t3];
			v__ast__TypeSymbol* param_sym = v__ast__Table_final_sym(c->table, param.typ);
			if (!(v__ast__TypeSymbol_is_string(param_sym) || v__ast__TypeSymbol_is_number(param_sym) || v__ast__TypeSymbol_is_float(param_sym) || param_sym->kind == v__ast__Kind__bool)) {
				v__checker__Checker_error(c,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("invalid type `"), 0xfe10, {.d_s = param_sym->name}}, {_SLIT("` for parameter `"), 0xfe10, {.d_s = param.name}}, {_SLIT("` in vweb app method `"), 0xfe10, {.d_s = node.name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), param.pos);
			}
		}
	}
	int route_attributes = 0;
	for (int _t4 = 0; _t4 < node.attrs.len; ++_t4) {
		v__ast__Attr a = ((v__ast__Attr*)node.attrs.data)[_t4];
		if (string_starts_with(a.name, _SLIT("/"))) {
			route_attributes += string_count(a.name, _SLIT(":"));
		}
	}
	return (multi_return_bool_int_int){.arg0=route_attributes == margs, .arg1=route_attributes, .arg2=margs};
}

VV_LOCAL_SYMBOL void v__checker__Checker_verify_all_vweb_routes(v__checker__Checker* c) {
	if (c->vweb_gen_types.len == 0) {
		return;
	}
	c->table->used_vweb_types = c->vweb_gen_types;
	int typ_vweb_result = v__ast__Table_find_type_idx(c->table, _SLIT("vweb.Result"));
	v__ast__File* old_file = c->file;
	for (int _t1 = 0; _t1 < c->vweb_gen_types.len; ++_t1) {
		v__ast__Type vgt = ((v__ast__Type*)c->vweb_gen_types.data)[_t1];
		v__ast__TypeSymbol* sym_app = v__ast__Table_sym(c->table, vgt);
		for (int _t2 = 0; _t2 < sym_app->methods.len; ++_t2) {
			v__ast__Fn m = ((v__ast__Fn*)sym_app->methods.data)[_t2];
			if (m.return_type == typ_vweb_result) {
				multi_return_bool_int_int mr_10513 = v__checker__Checker_verify_vweb_params_for_method(c, m);
				bool is_ok = mr_10513.arg0;
				int nroute_attributes = mr_10513.arg1;
				int nargs = mr_10513.arg2;
				if (!is_ok) {
					v__ast__FnDecl* f = ((v__ast__FnDecl*)(m.source_fn));
					if (isnil(f)) {
						continue;
					}
					if (f->return_type == typ_vweb_result && v__ast__Type_alias_eq(f->receiver.typ, (*(v__ast__Param*)/*ee elem_typ */array_get(m.params, 0)).typ) && string__eq(f->name, m.name) && !Array_v__ast__Attr_contains(f->attrs, _SLIT("post"))) {
						v__checker__Checker_change_current_file(c, f->source_file);
						v__checker__Checker_warn(c,  str_intp(6, _MOV((StrIntpData[]){{_SLIT("mismatched parameters count between vweb method `"), 0xfe10, {.d_s = sym_app->name}}, {_SLIT("."), 0xfe10, {.d_s = m.name}}, {_SLIT("` ("), 0xfe07, {.d_i32 = nargs}}, {_SLIT(") and route attribute "), 0xfe10, {.d_s = Array_v__ast__Attr_str(m.attrs)}}, {_SLIT(" ("), 0xfe07, {.d_i32 = nroute_attributes}}, {_SLIT(")"), 0, { .d_c = 0 }}})), f->pos);
					}
				}
			}
		}
	}
	v__checker__Checker_change_current_file(c, old_file);
}

VV_LOCAL_SYMBOL bool v__checker__Checker_evaluate_once_comptime_if_attribute(v__checker__Checker* c, v__ast__Attr* node) {
	if (node->ct_evaled) {
		bool _t1 = node->ct_skip;
		return _t1;
	}
	if ((node->ct_expr)._typ == 299 /* v.ast.Ident */) {
		if (node->ct_opt) {
			if (Array_string_contains(_const_v__checker__valid_comptime_not_user_defined, (*node->ct_expr._v__ast__Ident).name)) {
				v__checker__Checker_error(c, _SLIT("optional `[if expression ?]` tags, can be used only for user defined identifiers"), node->pos);
				node->ct_skip = true;
			} else {
				node->ct_skip = !Array_string_contains(c->pref->compile_defines, (*node->ct_expr._v__ast__Ident).name);
			}
			node->ct_evaled = true;
			bool _t2 = node->ct_skip;
			return _t2;
		} else {
			if (!Array_string_contains(_const_v__checker__valid_comptime_not_user_defined, (*node->ct_expr._v__ast__Ident).name)) {
				v__checker__Checker_note(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("`[if "), 0xfe10, {.d_s = (*node->ct_expr._v__ast__Ident).name}}, {_SLIT("]` is deprecated. Use `[if "), 0xfe10, {.d_s = (*node->ct_expr._v__ast__Ident).name}}, {_SLIT(" ?]` instead"), 0, { .d_c = 0 }}})), node->pos);
				node->ct_skip = !Array_string_contains(c->pref->compile_defines, (*node->ct_expr._v__ast__Ident).name);
				node->ct_evaled = true;
				bool _t3 = node->ct_skip;
				return _t3;
			} else {
				if (Array_string_contains(c->pref->compile_defines, (*node->ct_expr._v__ast__Ident).name)) {
					node->ct_skip = false;
					node->ct_evaled = true;
					bool _t4 = node->ct_skip;
					return _t4;
				}
			}
		}
	}
	c->inside_ct_attr = true;
	node->ct_skip = v__checker__Checker_comptime_if_branch(c, node->ct_expr, node->pos);
	c->inside_ct_attr = false;
	node->ct_evaled = true;
	bool _t5 = node->ct_skip;
	return _t5;
}

VV_LOCAL_SYMBOL bool v__checker__Checker_comptime_if_branch(v__checker__Checker* c, v__ast__Expr cond, v__token__Position pos) {
	if (cond._typ == 284 /* v.ast.BoolLiteral */) {
		bool _t1 = !(*cond._v__ast__BoolLiteral).val;
		return _t1;
	}
	else if (cond._typ == 314 /* v.ast.ParExpr */) {
		bool _t2 = v__checker__Checker_comptime_if_branch(c, (*cond._v__ast__ParExpr).expr, pos);
		return _t2;
	}
	else if (cond._typ == 316 /* v.ast.PrefixExpr */) {
		if ((*cond._v__ast__PrefixExpr).op != v__token__Kind__not) {
			v__checker__Checker_error(c, _SLIT("invalid `$if` condition"), (*cond._v__ast__PrefixExpr).pos);
		}
		bool _t3 = !v__checker__Checker_comptime_if_branch(c, (*cond._v__ast__PrefixExpr).right, (*cond._v__ast__PrefixExpr).pos);
		return _t3;
	}
	else if (cond._typ == 315 /* v.ast.PostfixExpr */) {
		if ((*cond._v__ast__PostfixExpr).op != v__token__Kind__question) {
			v__checker__Checker_error(c, _SLIT("invalid $if postfix operator"), (*cond._v__ast__PostfixExpr).pos);
		} else if (((*cond._v__ast__PostfixExpr).expr)._typ == 299 /* v.ast.Ident */) {
			bool _t4 = !Array_string_contains(c->pref->compile_defines_all, (*(*cond._v__ast__PostfixExpr).expr._v__ast__Ident).name);
			return _t4;
		} else {
			v__checker__Checker_error(c, _SLIT("invalid `$if` condition"), (*cond._v__ast__PostfixExpr).pos);
		}
	}
	else if (cond._typ == 303 /* v.ast.InfixExpr */) {

		if ((*cond._v__ast__InfixExpr).op == (v__token__Kind__and)) {
			bool l = v__checker__Checker_comptime_if_branch(c, (*cond._v__ast__InfixExpr).left, (*cond._v__ast__InfixExpr).pos);
			bool r = v__checker__Checker_comptime_if_branch(c, (*cond._v__ast__InfixExpr).right, (*cond._v__ast__InfixExpr).pos);
			bool _t5 = l || r;
			return _t5;
		}
		else if ((*cond._v__ast__InfixExpr).op == (v__token__Kind__logical_or)) {
			bool l = v__checker__Checker_comptime_if_branch(c, (*cond._v__ast__InfixExpr).left, (*cond._v__ast__InfixExpr).pos);
			bool r = v__checker__Checker_comptime_if_branch(c, (*cond._v__ast__InfixExpr).right, (*cond._v__ast__InfixExpr).pos);
			bool _t6 = l && r;
			return _t6;
		}
		else if ((*cond._v__ast__InfixExpr).op == (v__token__Kind__key_is) || (*cond._v__ast__InfixExpr).op == (v__token__Kind__not_is)) {
			if (((*cond._v__ast__InfixExpr).left)._typ == 325 /* v.ast.TypeNode */ && ((*cond._v__ast__InfixExpr).right)._typ == 325 /* v.ast.TypeNode */) {
				v__ast__TypeSymbol* sym = v__ast__Table_sym(c->table, (*(*cond._v__ast__InfixExpr).right._v__ast__TypeNode).typ);
				if (sym->kind != v__ast__Kind__interface_) {
					v__checker__Checker_expr(c, (*cond._v__ast__InfixExpr).left);
				}
				bool _t7 = false;
				return _t7;
			} else if (((*cond._v__ast__InfixExpr).left)._typ == 319 /* v.ast.SelectorExpr */ || ((*cond._v__ast__InfixExpr).left)._typ == 325 /* v.ast.TypeNode */) {
				v__checker__Checker_expr(c, (*cond._v__ast__InfixExpr).left);
				bool _t8 = false;
				return _t8;
			} else {
				v__checker__Checker_error(c, _SLIT("invalid `$if` condition: expected a type or a selector expression or an interface check"), v__ast__Expr_position((*cond._v__ast__InfixExpr).left));
			}
		}
		else if ((*cond._v__ast__InfixExpr).op == (v__token__Kind__eq) || (*cond._v__ast__InfixExpr).op == (v__token__Kind__ne)) {
			if (((*cond._v__ast__InfixExpr).left)._typ == 319 /* v.ast.SelectorExpr */ && ((*cond._v__ast__InfixExpr).right)._typ == 304 /* v.ast.IntegerLiteral */) {
			} else if (((*cond._v__ast__InfixExpr).left)._typ == 299 /* v.ast.Ident */) {
				v__ast__Type left_type = v__checker__Checker_expr(c, (*cond._v__ast__InfixExpr).left);
				v__ast__Type right_type = v__checker__Checker_expr(c, (*cond._v__ast__InfixExpr).right);
				Option_v__ast__Expr _t9 = v__checker__Checker_find_definition(c, (*(*cond._v__ast__InfixExpr).left._v__ast__Ident));
				if (_t9.state != 0) { /*or block*/ 
					IError err = _t9.err;
					v__checker__Checker_error(c, (*(err.msg)), (*(*cond._v__ast__InfixExpr).left._v__ast__Ident).pos);
					bool _t10 = false;
					return _t10;
				}
				
 				v__ast__Expr expr =  (*(v__ast__Expr*)_t9.data);
				if (!v__checker__Checker_check_types(c, right_type, left_type)) {
					string left_name = v__ast__Table_type_to_str(c->table, left_type);
					string right_name = v__ast__Table_type_to_str(c->table, right_type);
					v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("mismatched types `"), 0xfe10, {.d_s = left_name}}, {_SLIT("` and `"), 0xfe10, {.d_s = right_name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), (*cond._v__ast__InfixExpr).pos);
				}
				bool different = !string__eq(v__ast__Expr_str(expr), v__ast__Expr_str((*cond._v__ast__InfixExpr).right));
				bool _t11 = ((*cond._v__ast__InfixExpr).op == v__token__Kind__eq ? (different) : (!different));
				return _t11;
			} else {
				v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("invalid `$if` condition: "), 0xfe10, {.d_s = charptr_vstring_literal( /* v.ast.Expr */ v_typeof_sumtype_v__ast__Expr( ((*cond._v__ast__InfixExpr).left)._typ ))}}, {_SLIT("1"), 0, { .d_c = 0 }}})), (*cond._v__ast__InfixExpr).pos);
			}
		}
		else {
			v__checker__Checker_error(c, _SLIT("invalid `$if` condition"), (*cond._v__ast__InfixExpr).pos);
		};
	}
	else if (cond._typ == 299 /* v.ast.Ident */) {
		string cname = (*cond._v__ast__Ident).name;
		if (Array_string_contains(_const_v__checker__valid_comptime_if_os, cname)) {
			bool is_os_target_different = false;
			if (!c->pref->output_cross_c) {
				string target_os = string_to_lower(v__pref__OS_str(c->pref->os));
				is_os_target_different = !string__eq(cname, target_os);
			}
			bool _t12 = is_os_target_different;
			return _t12;
		} else if (Array_string_contains(_const_v__checker__valid_comptime_if_compilers, cname)) {
			bool _t13 = v__pref__cc_from_string(cname) != c->pref->ccompiler_type;
			return _t13;
		} else if (Array_string_contains(_const_v__checker__valid_comptime_if_platforms, cname)) {
			if (string__eq(cname, _SLIT("aarch64"))) {
				v__checker__Checker_note(c, _SLIT("use `arm64` instead of `aarch64`"), pos);
			}

			if (string__eq(cname, _SLIT("amd64"))) {
				bool _t14 = c->pref->arch != v__pref__Arch__amd64;
				return _t14;
			}
			else if (string__eq(cname, _SLIT("i386"))) {
				bool _t15 = c->pref->arch != v__pref__Arch__i386;
				return _t15;
			}
			else if (string__eq(cname, _SLIT("aarch64"))) {
				bool _t16 = c->pref->arch != v__pref__Arch__arm64;
				return _t16;
			}
			else if (string__eq(cname, _SLIT("arm64"))) {
				bool _t17 = c->pref->arch != v__pref__Arch__arm64;
				return _t17;
			}
			else if (string__eq(cname, _SLIT("arm32"))) {
				bool _t18 = c->pref->arch != v__pref__Arch__arm32;
				return _t18;
			}
			else if (string__eq(cname, _SLIT("rv64"))) {
				bool _t19 = c->pref->arch != v__pref__Arch__rv64;
				return _t19;
			}
			else if (string__eq(cname, _SLIT("rv32"))) {
				bool _t20 = c->pref->arch != v__pref__Arch__rv32;
				return _t20;
			}
			else {
				bool _t21 = false;
				return _t21;
			};
		} else if (Array_string_contains(_const_v__checker__valid_comptime_if_cpu_features, cname)) {
			bool _t22 = false;
			return _t22;
		} else if (Array_string_contains(_const_v__checker__valid_comptime_if_other, cname)) {

			if (string__eq(cname, _SLIT("js"))) {
				bool _t23 = !v__pref__Backend_is_js(c->pref->backend);
				return _t23;
			}
			else if (string__eq(cname, _SLIT("debug"))) {
				bool _t24 = !c->pref->is_debug;
				return _t24;
			}
			else if (string__eq(cname, _SLIT("prod"))) {
				bool _t25 = !c->pref->is_prod;
				return _t25;
			}
			else if (string__eq(cname, _SLIT("test"))) {
				bool _t26 = !c->pref->is_test;
				return _t26;
			}
			else if (string__eq(cname, _SLIT("glibc"))) {
				bool _t27 = false;
				return _t27;
			}
			else if (string__eq(cname, _SLIT("threads"))) {
				bool _t28 = c->table->gostmts == 0;
				return _t28;
			}
			else if (string__eq(cname, _SLIT("prealloc"))) {
				bool _t29 = !c->pref->prealloc;
				return _t29;
			}
			else if (string__eq(cname, _SLIT("no_bounds_checking"))) {
				bool _t30 = !Array_string_contains(c->pref->compile_defines_all, cname);
				return _t30;
			}
			else if (string__eq(cname, _SLIT("freestanding"))) {
				bool _t31 = !c->pref->is_bare || c->pref->output_cross_c;
				return _t31;
			}
			else if (string__eq(cname, _SLIT("interpreter"))) {
				c->pref->backend != v__pref__Backend__interpret;
			}
			else {
				bool _t32 = false;
				return _t32;
			};
		} else if (!Array_string_contains(c->pref->compile_defines_all, cname)) {
			if (string__eq(cname, _SLIT("linux_or_macos"))) {
				v__checker__Checker_error(c, _SLIT("linux_or_macos is deprecated, use `$if linux || macos {` instead"), (*cond._v__ast__Ident).pos);
				bool _t33 = false;
				return _t33;
			}
			v__ast__Type typ = v__checker__Checker_unwrap_generic(c, v__checker__Checker_expr(c, cond));
			if (((*cond._v__ast__Ident).obj)._typ != 357 /* v.ast.Var */ && ((*cond._v__ast__Ident).obj)._typ != 355 /* v.ast.ConstField */ && ((*cond._v__ast__Ident).obj)._typ != 356 /* v.ast.GlobalField */) {
				if (!c->inside_ct_attr) {
					v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unknown var: `"), 0xfe10, {.d_s = cname}}, {_SLIT("`"), 0, { .d_c = 0 }}})), pos);
				}
				bool _t34 = false;
				return _t34;
			}
			Option_v__ast__Expr _t35 = v__checker__Checker_find_obj_definition(c, (*cond._v__ast__Ident).obj);
			if (_t35.state != 0) { /*or block*/ 
				IError err = _t35.err;
				v__checker__Checker_error(c, (*(err.msg)), (*cond._v__ast__Ident).pos);
				bool _t36 = false;
				return _t36;
			}
			
 			v__ast__Expr expr =  (*(v__ast__Expr*)_t35.data);
			if (!v__checker__Checker_check_types(c, typ, _const_v__ast__bool_type)) {
				string type_name = v__ast__Table_type_to_str(c->table, typ);
				v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("non-bool type `"), 0xfe10, {.d_s = type_name}}, {_SLIT("` used as $if condition"), 0, { .d_c = 0 }}})), (*cond._v__ast__Ident).pos);
			}
			bool _t37 = !(/* as */ *(v__ast__BoolLiteral*)__as_cast((expr)._v__ast__BoolLiteral,(expr)._typ, 284) /*expected idx: 284, name: v.ast.BoolLiteral */ ).val;
			return _t37;
		}
	}
	else if (cond._typ == 291 /* v.ast.ComptimeCall */) {
		if ((*cond._v__ast__ComptimeCall).is_pkgconfig) {
			Option_v__pkgconfig__Main_ptr _t38 = v__pkgconfig__main(new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){string_clone((*cond._v__ast__ComptimeCall).args_var)})));
			if (_t38.state != 0) { /*or block*/ 
				IError err = _t38.err;
				v__checker__Checker_error(c, (*(err.msg)), (*cond._v__ast__ComptimeCall).pos);
				bool _t39 = true;
				return _t39;
			}
			
 			v__pkgconfig__Main* m =  (*(v__pkgconfig__Main**)_t38.data);
			Option_string _t40 = v__pkgconfig__Main_run(m);
			if (_t40.state != 0) { /*or block*/ 
				IError err = _t40.err;
				bool _t41 = true;
				return _t41;
			}
			
  (*(string*)_t40.data);
		}
	}
	
	else {
		v__checker__Checker_error(c, _SLIT("invalid `$if` condition"), pos);
	}
	;
	bool _t42 = false;
	return _t42;
}

v__ast__Type v__checker__Checker_array_init(v__checker__Checker* c, v__ast__ArrayInit* node) {
	v__ast__Type elem_type = _const_v__ast__void_type;
	if (!v__ast__Type_alias_eq(node->typ, _const_v__ast__void_type)) {
		if (node->exprs.len == 0) {
			if (node->has_cap) {
				v__checker__Checker_check_array_init_para_type(c, _SLIT("cap"), node->cap_expr, node->pos);
			}
			if (node->has_len) {
				v__checker__Checker_check_array_init_para_type(c, _SLIT("len"), node->len_expr, node->pos);
			}
		}
		if (node->has_default) {
			v__ast__Expr default_expr = node->default_expr;
			v__ast__Type default_typ = v__checker__Checker_check_expr_opt_call(c, default_expr, v__checker__Checker_expr(c, default_expr));
			Option_void _t1 = v__checker__Checker_check_expected(c, default_typ, node->elem_type);
			if (_t1.state != 0 && _t1.err._typ != _IError_None___index) {
				IError err = _t1.err;
				v__checker__Checker_error(c, (*(err.msg)), v__ast__Expr_position(default_expr));
			;
			}
			
 ;
		}
		if (node->has_len) {
			if (node->has_len && !node->has_default) {
				v__ast__TypeSymbol* elem_type_sym = v__ast__Table_sym(c->table, node->elem_type);
				if (elem_type_sym->kind == v__ast__Kind__interface_) {
					v__checker__Checker_error(c, _SLIT("cannot instantiate an array of interfaces without also giving a default `init:` value"), v__ast__Expr_position(node->len_expr));
				}
			}
			v__checker__Checker_ensure_sumtype_array_has_default_value(c, *node);
		}
		Option_void _t2 = v__checker__Checker_ensure_type_exists(c, node->elem_type, node->elem_type_pos);
		if (_t2.state != 0 && _t2.err._typ != _IError_None___index) {
			IError err = _t2.err;
		}
		
 ;
		if (v__ast__Type_has_flag(node->typ, v__ast__TypeFlag__generic) && c->table->cur_fn->generic_names.len == 0) {
			v__checker__Checker_error(c, _SLIT("generic struct cannot use in non-generic function"), node->pos);
		}
		v__ast__Type _t3 = node->typ;
		return _t3;
	}
	if (node->is_fixed) {
		v__checker__Checker_ensure_sumtype_array_has_default_value(c, *node);
		Option_void _t4 = v__checker__Checker_ensure_type_exists(c, node->elem_type, node->elem_type_pos);
		if (_t4.state != 0 && _t4.err._typ != _IError_None___index) {
			IError err = _t4.err;
		}
		
 ;
	}
	if (node->exprs.len == 0) {
		if (v__ast__Type_alias_eq(c->expected_type, _const_v__ast__void_type) && !v__ast__Type_alias_eq(c->expected_or_type, _const_v__ast__void_type)) {
			c->expected_type = c->expected_or_type;
		}
		v__ast__TypeSymbol* type_sym = v__ast__Table_sym(c->table, c->expected_type);
		if (type_sym->kind != v__ast__Kind__array || v__ast__Type_alias_eq(v__ast__TypeSymbol_array_info(type_sym).elem_type, _const_v__ast__void_type)) {
			v__checker__Checker_error(c, _SLIT("array_init: no type specified (maybe: `[]Type{}` instead of `[]`)"), node->pos);
			v__ast__Type _t5 = _const_v__ast__void_type;
			return _t5;
		}
		v__ast__Array array_info = v__ast__TypeSymbol_array_info(type_sym);
		node->elem_type = array_info.elem_type;
		v__ast__Type _t6 = v__ast__Type_clear_flag(c->expected_type, v__ast__TypeFlag__optional);
		return _t6;
	}
	if (node->exprs.len > 0 && v__ast__Type_alias_eq(node->elem_type, _const_v__ast__void_type)) {
		v__ast__Type expected_value_type = _const_v__ast__void_type;
		bool expecting_interface_array = false;
		if (c->expected_type != 0) {
			expected_value_type = v__ast__Table_value_type(c->table, c->expected_type);
			if (v__ast__Table_sym(c->table, expected_value_type)->kind == v__ast__Kind__interface_) {
				expecting_interface_array = true;
			}
		}
		for (int i = 0; i < node->exprs.len; ++i) {
			v__ast__Expr* expr = ((v__ast__Expr*)node->exprs.data) + i;
			v__ast__Type typ = v__checker__Checker_check_expr_opt_call(c, *expr, v__checker__Checker_expr(c, *expr));
			array_push((array*)&node->expr_types, _MOV((v__ast__Type[]){ typ }));
			if (expecting_interface_array) {
				if (i == 0) {
					elem_type = expected_value_type;
					c->expected_type = elem_type;
					v__checker__Checker_type_implements(c, typ, elem_type, v__ast__Expr_position(/*rec*/*expr));
				}
				if (!v__ast__Type_is_ptr(typ) && !v__ast__Type_is_pointer(typ) && !c->inside_unsafe) {
					v__ast__TypeSymbol* typ_sym = v__ast__Table_sym(c->table, typ);
					if (typ_sym->kind != v__ast__Kind__interface_) {
						v__checker__Checker_mark_as_referenced(c, expr, true);
					}
				}
				continue;
			}
			if (i == 0) {
				if (v__ast__Expr_is_auto_deref_var(/*rec*/*expr)) {
					elem_type = v__ast__mktyp(v__ast__Type_deref(typ));
				} else {
					elem_type = v__ast__mktyp(typ);
				}
				c->expected_type = elem_type;
				continue;
			}
			if ((expr)->_typ != 325 /* v.ast.TypeNode */) {
				Option_void _t8 = v__checker__Checker_check_expected(c, typ, elem_type);
				if (_t8.state != 0 && _t8.err._typ != _IError_None___index) {
					IError err = _t8.err;
					v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("invalid array element: "), 0xfe10, {.d_s = (*(err.msg))}}, {_SLIT0, 0, { .d_c = 0 }}})), v__ast__Expr_position(/*rec*/*expr));
				;
				}
				
 ;
			}
		}
		if (node->is_fixed) {
			int idx = v__ast__Table_find_or_register_array_fixed(c->table, elem_type, node->exprs.len, v__ast__empty_expr());
			if (v__ast__Type_has_flag(elem_type, v__ast__TypeFlag__generic)) {
				node->typ = v__ast__Type_set_flag(v__ast__new_type(idx), v__ast__TypeFlag__generic);
			} else {
				node->typ = v__ast__new_type(idx);
			}
		} else {
			int idx = v__ast__Table_find_or_register_array(c->table, elem_type);
			if (v__ast__Type_has_flag(elem_type, v__ast__TypeFlag__generic)) {
				node->typ = v__ast__Type_set_flag(v__ast__new_type(idx), v__ast__TypeFlag__generic);
			} else {
				node->typ = v__ast__new_type(idx);
			}
		}
		node->elem_type = elem_type;
	} else if (node->is_fixed && node->exprs.len == 1 && !v__ast__Type_alias_eq(node->elem_type, _const_v__ast__void_type)) {
		i64 fixed_size = ((i64)(0));
		v__ast__Expr init_expr = (*(v__ast__Expr*)/*ee elem_typ */array_get(node->exprs, 0));
		v__checker__Checker_expr(c, init_expr);
		if (init_expr._typ == 304 /* v.ast.IntegerLiteral */) {
			fixed_size = string_int((*init_expr._v__ast__IntegerLiteral).val);
		}
		else if (init_expr._typ == 299 /* v.ast.Ident */) {
			if (((*init_expr._v__ast__Ident).obj)._typ == 355 /* v.ast.ConstField */) {
				Option_v__ast__ComptTimeConstValue _t9;
				if (_t9 = v__checker__Checker_eval_comptime_const_expr(c, (*(*init_expr._v__ast__Ident).obj._v__ast__ConstField).expr, 0), _t9.state == 0) {
					v__ast__ComptTimeConstValue comptime_value = *(v__ast__ComptTimeConstValue*)_t9.data;
					Option_i64 _t10 = v__ast__ComptTimeConstValue_i64(comptime_value);
					if (_t10.state != 0) { /*or block*/ 
						IError err = _t10.err;
						*(i64*) _t10.data = fixed_size;
					}
					
 					fixed_size =  (*(i64*)_t10.data);
				}
			} else {
				v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("non-constant array bound `"), 0xfe10, {.d_s = (*init_expr._v__ast__Ident).name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), (*init_expr._v__ast__Ident).pos);
			}
		}
		else if (init_expr._typ == 303 /* v.ast.InfixExpr */) {
			Option_v__ast__ComptTimeConstValue _t11;
			if (_t11 = v__checker__Checker_eval_comptime_const_expr(c, init_expr, 0), _t11.state == 0) {
				v__ast__ComptTimeConstValue comptime_value = *(v__ast__ComptTimeConstValue*)_t11.data;
				Option_i64 _t12 = v__ast__ComptTimeConstValue_i64(comptime_value);
				if (_t12.state != 0) { /*or block*/ 
					IError err = _t12.err;
					*(i64*) _t12.data = fixed_size;
				}
				
 				fixed_size =  (*(i64*)_t12.data);
			}
		}
		
		else {
			v__checker__Checker_error(c, _SLIT("expecting `int` for fixed size"), node->pos);
		}
		;
		if (fixed_size <= 0) {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("fixed size cannot be zero or negative (fixed_size: "), 0xfe09, {.d_i64 = fixed_size}}, {_SLIT(")"), 0, { .d_c = 0 }}})), v__ast__Expr_position(init_expr));
		}
		int idx = v__ast__Table_find_or_register_array_fixed(c->table, node->elem_type, ((int)(fixed_size)), init_expr);
		if (v__ast__Type_has_flag(node->elem_type, v__ast__TypeFlag__generic)) {
			node->typ = v__ast__Type_set_flag(v__ast__new_type(idx), v__ast__TypeFlag__generic);
		} else {
			node->typ = v__ast__new_type(idx);
		}
		if (node->has_default) {
			v__checker__Checker_expr(c, node->default_expr);
		}
	}
	v__ast__Type _t13 = node->typ;
	return _t13;
}

VV_LOCAL_SYMBOL void v__checker__Checker_check_array_init_para_type(v__checker__Checker* c, string para, v__ast__Expr expr, v__token__Position pos) {
	v__ast__TypeSymbol* sym = v__ast__Table_sym(c->table, v__checker__Checker_expr(c, expr));
	if (!(sym->kind == v__ast__Kind__int || sym->kind == v__ast__Kind__int_literal)) {
		v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("array "), 0xfe10, {.d_s = para}}, {_SLIT(" needs to be an int"), 0, { .d_c = 0 }}})), pos);
	}
}

void v__checker__Checker_ensure_sumtype_array_has_default_value(v__checker__Checker* c, v__ast__ArrayInit node) {
	v__ast__TypeSymbol* sym = v__ast__Table_sym(c->table, node.elem_type);
	if (sym->kind == v__ast__Kind__sum_type && !node.has_default) {
		v__checker__Checker_error(c, _SLIT("cannot initialize sum type array without default value"), node.pos);
	}
}

v__ast__Type v__checker__Checker_map_init(v__checker__Checker* c, v__ast__MapInit* node) {
	if (node->keys.len == 0 && node->vals.len == 0 && node->typ == 0) {
		v__ast__TypeSymbol* sym = v__ast__Table_sym(c->table, c->expected_type);
		if (sym->kind == v__ast__Kind__map) {
			v__ast__Map info = v__ast__TypeSymbol_map_info(sym);
			node->typ = c->expected_type;
			node->key_type = info.key_type;
			node->value_type = info.value_type;
			v__ast__Type _t1 = node->typ;
			return _t1;
		} else {
			if (sym->kind == v__ast__Kind__struct_) {
				v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("`{}` can not be used for initialising empty structs any more. Use `"), 0xfe10, {.d_s = v__ast__Table_type_to_str(c->table, c->expected_type)}}, {_SLIT("{}` instead."), 0, { .d_c = 0 }}})), node->pos);
			} else {
				v__checker__Checker_error(c, _SLIT("invalid empty map initialisation syntax, use e.g. map[string]int{} instead"), node->pos);
			}
			v__ast__Type _t2 = _const_v__ast__void_type;
			return _t2;
		}
	}
	if (node->typ != 0) {
		v__ast__Map info = v__ast__TypeSymbol_map_info(v__ast__Table_sym(c->table, node->typ));
		Option_void _t3 = v__checker__Checker_ensure_type_exists(c, info.key_type, node->pos);
		if (_t3.state != 0 && _t3.err._typ != _IError_None___index) {
			IError err = _t3.err;
		}
		
 ;
		Option_void _t4 = v__checker__Checker_ensure_type_exists(c, info.value_type, node->pos);
		if (_t4.state != 0 && _t4.err._typ != _IError_None___index) {
			IError err = _t4.err;
		}
		
 ;
		node->key_type = info.key_type;
		node->value_type = info.value_type;
		v__ast__Type _t5 = node->typ;
		return _t5;
	}
	if (node->keys.len > 0 && node->vals.len > 0) {
		v__ast__Type key0_type = _const_v__ast__void_type;
		v__ast__Type val0_type = _const_v__ast__void_type;
		bool use_expected_type = !v__ast__Type_alias_eq(c->expected_type, _const_v__ast__void_type) && !c->inside_const && v__ast__Table_sym(c->table, c->expected_type)->kind == v__ast__Kind__map;
		if (use_expected_type) {
			v__ast__TypeSymbol* sym = v__ast__Table_sym(c->table, c->expected_type);
			v__ast__Map info = v__ast__TypeSymbol_map_info(sym);
			key0_type = v__checker__Checker_unwrap_generic(c, info.key_type);
			val0_type = v__checker__Checker_unwrap_generic(c, info.value_type);
		} else {
			key0_type = v__ast__mktyp(v__checker__Checker_expr(c, (*(v__ast__Expr*)/*ee elem_typ */array_get(node->keys, 0))));
			if (v__ast__Expr_is_auto_deref_var((*(v__ast__Expr*)/*ee elem_typ */array_get(node->keys, 0)))) {
				key0_type = v__ast__Type_deref(key0_type);
			}
			val0_type = v__ast__mktyp(v__checker__Checker_expr(c, (*(v__ast__Expr*)/*ee elem_typ */array_get(node->vals, 0))));
			if (v__ast__Expr_is_auto_deref_var((*(v__ast__Expr*)/*ee elem_typ */array_get(node->vals, 0)))) {
				val0_type = v__ast__Type_deref(val0_type);
			}
		}
		bool same_key_type = true;
		for (int i = 0; i < node->keys.len; ++i) {
			v__ast__Expr key = ((v__ast__Expr*)node->keys.data)[i];
			if (i == 0 && !use_expected_type) {
				continue;
			}
			v__ast__Expr val = (*(v__ast__Expr*)/*ee elem_typ */array_get(node->vals, i));
			c->expected_type = key0_type;
			v__ast__Type key_type = v__checker__Checker_expr(c, key);
			c->expected_type = val0_type;
			v__ast__Type val_type = v__checker__Checker_expr(c, val);
			if (!v__checker__Checker_check_types(c, key_type, key0_type) || (i == 0 && v__ast__Type_is_number(key_type) && v__ast__Type_is_number(key0_type) && !v__ast__Type_alias_eq(key0_type, v__ast__mktyp(key_type)))) {
				string msg = v__checker__Checker_expected_msg(c, key_type, key0_type);
				v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("invalid map key: "), 0xfe10, {.d_s = msg}}, {_SLIT0, 0, { .d_c = 0 }}})), v__ast__Expr_position(key));
				same_key_type = false;
			}
			if (!v__checker__Checker_check_types(c, val_type, val0_type) || (i == 0 && v__ast__Type_is_number(val_type) && v__ast__Type_is_number(val0_type) && !v__ast__Type_alias_eq(val0_type, v__ast__mktyp(val_type)))) {
				string msg = v__checker__Checker_expected_msg(c, val_type, val0_type);
				v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("invalid map value: "), 0xfe10, {.d_s = msg}}, {_SLIT0, 0, { .d_c = 0 }}})), v__ast__Expr_position(val));
			}
		}
		if (same_key_type) {
			for (int i = 1; i < node->keys.len; ++i) {
				v__checker__Checker_check_dup_keys(c, node, i);
			}
		}
		key0_type = v__checker__Checker_unwrap_generic(c, key0_type);
		val0_type = v__checker__Checker_unwrap_generic(c, val0_type);
		v__ast__Type map_type = v__ast__new_type(v__ast__Table_find_or_register_map(c->table, key0_type, val0_type));
		node->typ = map_type;
		node->key_type = key0_type;
		node->value_type = val0_type;
		v__ast__Type _t6 = map_type;
		return _t6;
	}
	v__ast__Type _t7 = node->typ;
	return _t7;
}

VV_LOCAL_SYMBOL void v__checker__Checker_fn_decl(v__checker__Checker* c, v__ast__FnDecl* node) {
bool v__checker__Checker_fn_decl_defer_0 = false;
int prev_stmt_level;
bool prev_returns;
bool prev_inside_anon_fn;
bool prev_inside_unsafe;
bool prev_inside_defer;
int prev_in_for_count;
v__ast__Scope* prev_fn_scope;
	if (node->generic_names.len > 0 && c->table->cur_concrete_types.len == 0) {
		array_push((array*)&c->file->generic_fns, _MOV((v__ast__FnDecl*[]){ node }));
		c->need_recheck_generic_fns = true;
		return;
	}
	node->ninstances++;
	prev_fn_scope = c->fn_scope;
	prev_in_for_count = c->in_for_count;
	prev_inside_defer = c->inside_defer;
	prev_inside_unsafe = c->inside_unsafe;
	prev_inside_anon_fn = c->inside_anon_fn;
	prev_returns = c->returns;
	prev_stmt_level = c->stmt_level;
	c->fn_level++;
	c->in_for_count = 0;
	c->inside_defer = false;
	c->inside_unsafe = false;
	c->returns = false;
	v__checker__Checker_fn_decl_defer_0 = true;
	bool need_generic_names = false;
	if (node->generic_names.len == 0) {
		if (v__ast__Type_has_flag(node->return_type, v__ast__TypeFlag__generic)) {
			need_generic_names = true;
		} else {
			for (int _t2 = 0; _t2 < node->params.len; ++_t2) {
				v__ast__Param param = ((v__ast__Param*)node->params.data)[_t2];
				if (v__ast__Type_has_flag(param.typ, v__ast__TypeFlag__generic)) {
					need_generic_names = true;
					break;
				}
			}
		}
		if (need_generic_names) {
			v__checker__Checker_error(c, _SLIT("generic function declaration must specify generic type names, e.g. foo<T>"), node->pos);
		}
	}
	if (node->language == v__ast__Language__v && !c->is_builtin_mod && !node->is_anon) {
		v__checker__Checker_check_valid_snake_case(c, node->name, _SLIT("function name"), node->pos);
	}
	if (string__eq(node->name, _SLIT("main.main"))) {
		c->main_fn_decl_node = *node;
	}
	if (!v__ast__Type_alias_eq(node->return_type, _const_v__ast__void_type)) {
		Option_int _t3;
		if (_t3 = Array_v__ast__Attr_find_comptime_define(node->attrs), _t3.state == 0) {
			int ct_attr_idx = *(int*)_t3.data;
			string sexpr = v__ast__Expr_str((*(v__ast__Attr*)/*ee elem_typ */array_get(node->attrs, ct_attr_idx)).ct_expr);
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("only functions that do NOT return values can have `[if "), 0xfe10, {.d_s = sexpr}}, {_SLIT("]` tags"), 0, { .d_c = 0 }}})), node->pos);
		}
		if (node->generic_names.len > 0) {
			v__ast__TypeSymbol* gs = v__ast__Table_sym(c->table, node->return_type);
			if ((gs->info)._typ == 446 /* v.ast.Struct */) {
				if ((*gs->info._v__ast__Struct).is_generic && !v__ast__Type_has_flag(node->return_type, v__ast__TypeFlag__generic)) {
					v__checker__Checker_error(c, _SLIT("return generic struct in fn declaration must specify the generic type names, e.g. Foo<T>"), node->return_type_pos);
				}
			}
		}
		v__ast__TypeSymbol* return_sym = v__ast__Table_sym(c->table, node->return_type);
		if ((return_sym->info)._typ == 471 /* v.ast.MultiReturn */) {
			for (int _t4 = 0; _t4 < (*return_sym->info._v__ast__MultiReturn).types.len; ++_t4) {
				v__ast__Type multi_type = ((v__ast__Type*)(*return_sym->info._v__ast__MultiReturn).types.data)[_t4];
				v__ast__TypeSymbol* multi_sym = v__ast__Table_sym(c->table, multi_type);
				if (v__ast__Type_alias_eq(multi_type, _const_v__ast__error_type)) {
					v__checker__Checker_error(c, _SLIT("type `IError` cannot be used in multi-return, return an option instead"), node->return_type_pos);
				} else if (v__ast__Type_has_flag(multi_type, v__ast__TypeFlag__optional)) {
					v__checker__Checker_error(c, _SLIT("option cannot be used in multi-return, return an option instead"), node->return_type_pos);
				} else if (multi_sym->kind == v__ast__Kind__array_fixed) {
					v__checker__Checker_error(c, _SLIT("fixed array cannot be used in multi-return"), node->return_type_pos);
				}
			}
		} else if (return_sym->kind == v__ast__Kind__array_fixed) {
			v__checker__Checker_error(c, _SLIT("fixed array cannot be returned by function"), node->return_type_pos);
		}
	} else {
		for (int _t5 = 0; _t5 < node->attrs.len; ++_t5) {
			v__ast__Attr* a = ((v__ast__Attr*)node->attrs.data) + _t5;
			if (a->kind == v__ast__AttrKind__comptime_define) {
				node->should_be_skipped = v__checker__Checker_evaluate_once_comptime_if_attribute(c, a);
			}
		}
	}
	if (node->is_method) {
		v__ast__TypeSymbol* sym = v__ast__Table_sym(c->table, node->receiver.typ);
		if (sym->kind == v__ast__Kind__array && !c->is_builtin_mod && string__eq(node->name, _SLIT("map"))) {
			v__checker__Checker_error(c, _SLIT("method overrides built-in array method"), node->pos);
		} else if (sym->kind == v__ast__Kind__sum_type && string__eq(node->name, _SLIT("type_name"))) {
			v__checker__Checker_error(c, _SLIT("method overrides built-in sum type method"), node->pos);
		} else if (sym->kind == v__ast__Kind__sum_type && string__eq(node->name, _SLIT("type_idx"))) {
			v__checker__Checker_error(c, _SLIT("method overrides built-in sum type method"), node->pos);
		} else if (sym->kind == v__ast__Kind__multi_return) {
			v__checker__Checker_error(c, _SLIT("cannot define method on multi-value"), node->method_type_pos);
		}
		if (sym->name.len == 1) {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unknown type `"), 0xfe10, {.d_s = sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node->receiver_pos);
			// Defer begin
			if (v__checker__Checker_fn_decl_defer_0) {
				c->stmt_level = prev_stmt_level;
				c->fn_level--;
				c->returns = prev_returns;
				c->inside_anon_fn = prev_inside_anon_fn;
				c->inside_unsafe = prev_inside_unsafe;
				c->inside_defer = prev_inside_defer;
				c->in_for_count = prev_in_for_count;
				c->fn_scope = prev_fn_scope;
			}
			// Defer end
			return;
		}
		if (sym->kind == v__ast__Kind__interface_ && v__ast__TypeSymbol_has_method(sym, node->name)) {
			if ((sym->info)._typ == 463 /* v.ast.Interface */) {
				if (v__ast__Interface_has_method(&(*sym->info._v__ast__Interface), node->name)) {
					v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("interface `"), 0xfe10, {.d_s = sym->name}}, {_SLIT("` cannot implement its own interface method `"), 0xfe10, {.d_s = node->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node->pos);
				}
			}
		}
		if ((sym->info)._typ == 446 /* v.ast.Struct */) {
			Option_v__ast__StructField _t6;
			if (_t6 = v__ast__Table_find_field(c->table, sym, node->name), _t6.state == 0) {
				v__ast__StructField field = *(v__ast__StructField*)_t6.data;
				v__ast__TypeSymbol* field_sym = v__ast__Table_sym(c->table, field.typ);
				if (field_sym->kind == v__ast__Kind__function) {
					v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("type `"), 0xfe10, {.d_s = sym->name}}, {_SLIT("` has both field and method named `"), 0xfe10, {.d_s = node->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node->pos);
				}
			}
			if (string__eq(node->name, _SLIT("free"))) {
				if (!v__ast__Type_alias_eq(node->return_type, _const_v__ast__void_type)) {
					v__checker__Checker_error(c, _SLIT("`.free()` methods should not have a return type"), node->return_type_pos);
				}
				if (!v__ast__Type_is_ptr(node->receiver.typ)) {
					string tname = string_after_char(sym->name, '.');
					v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("`.free()` methods should be defined on either a `(mut x &"), 0xfe10, {.d_s = tname}}, {_SLIT(")`, or a `(x &"), 0xfe10, {.d_s = tname}}, {_SLIT(")` receiver"), 0, { .d_c = 0 }}})), node->receiver_pos);
				}
				if (node->params.len != 1) {
					v__checker__Checker_error(c, _SLIT("`.free()` methods should have 0 arguments"), node->pos);
				}
			}
		}
		if (node->method_idx < sym->methods.len) {
			(*(v__ast__Fn*)/*ee elem_typ */array_get(sym->methods, node->method_idx)).source_fn = ((voidptr)(node));
		} else {
			v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("method index: "), 0xfe07, {.d_i32 = node->method_idx}}, {_SLIT(" >= sym.methods.len: "), 0xfe07, {.d_i32 = sym->methods.len}}, {_SLIT0, 0, { .d_c = 0 }}})), node->pos);
		}
	}
	if (node->language == v__ast__Language__v) {
		for (int _t7 = 0; _t7 < node->params.len; ++_t7) {
			v__ast__Param* param = ((v__ast__Param*)node->params.data) + _t7;
			Option_void _t8 = v__checker__Checker_ensure_type_exists(c, param->typ, param->type_pos);
			if (_t8.state != 0 && _t8.err._typ != _IError_None___index) {
				IError err = _t8.err;
				// Defer begin
				if (v__checker__Checker_fn_decl_defer_0) {
					c->stmt_level = prev_stmt_level;
					c->fn_level--;
					c->returns = prev_returns;
					c->inside_anon_fn = prev_inside_anon_fn;
					c->inside_unsafe = prev_inside_unsafe;
					c->inside_defer = prev_inside_defer;
					c->in_for_count = prev_in_for_count;
					c->fn_scope = prev_fn_scope;
				}
				// Defer end
				return;
			}
			
 ;
			if (Array_string_contains(_const_v__checker__reserved_type_names, param->name)) {
				v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("invalid use of reserved type `"), 0xfe10, {.d_s = param->name}}, {_SLIT("` as a parameter name"), 0, { .d_c = 0 }}})), param->pos);
			}
			if (!v__ast__Type_is_ptr(param->typ)) {
				v__ast__TypeSymbol* arg_typ_sym = v__ast__Table_sym(c->table, param->typ);
				if (arg_typ_sym->kind == v__ast__Kind__struct_) {
					v__ast__Struct info = /* as */ *(v__ast__Struct*)__as_cast((arg_typ_sym->info)._v__ast__Struct,(arg_typ_sym->info)._typ, 446) /*expected idx: 446, name: v.ast.Struct */ ;
					if (info.is_heap) {
						Option_v__ast__Var_ptr _t9 = v__ast__Scope_find_var(node->scope, param->name);
						if (_t9.state != 0) { /*or block*/ 
							IError err = _t9.err;
							continue;
						}
						
 						v__ast__Var* v =  (*(v__ast__Var**)_t9.data);
						v->is_auto_heap = true;
					}
					if (info.generic_types.len > 0 && !v__ast__Type_has_flag(param->typ, v__ast__TypeFlag__generic) && info.concrete_types.len == 0) {
						v__checker__Checker_error(c, _SLIT("generic struct in fn declaration must specify the generic type names, e.g. Foo<T>"), param->type_pos);
					}
				} else if (arg_typ_sym->kind == v__ast__Kind__interface_) {
					v__ast__Interface info = /* as */ *(v__ast__Interface*)__as_cast((arg_typ_sym->info)._v__ast__Interface,(arg_typ_sym->info)._typ, 463) /*expected idx: 463, name: v.ast.Interface */ ;
					if (info.generic_types.len > 0 && !v__ast__Type_has_flag(param->typ, v__ast__TypeFlag__generic) && info.concrete_types.len == 0) {
						v__checker__Checker_error(c, _SLIT("generic interface in fn declaration must specify the generic type names, e.g. Foo<T>"), param->type_pos);
					}
				} else if (arg_typ_sym->kind == v__ast__Kind__sum_type) {
					v__ast__SumType info = /* as */ *(v__ast__SumType*)__as_cast((arg_typ_sym->info)._v__ast__SumType,(arg_typ_sym->info)._typ, 464) /*expected idx: 464, name: v.ast.SumType */ ;
					if (info.generic_types.len > 0 && !v__ast__Type_has_flag(param->typ, v__ast__TypeFlag__generic) && info.concrete_types.len == 0) {
						v__checker__Checker_error(c, _SLIT("generic sumtype in fn declaration must specify the generic type names, e.g. Foo<T>"), param->type_pos);
					}
				}
			}
			if (c->pref->translated && node->is_variadic && node->params.len == 1 && v__ast__Type_is_ptr(param->typ)) {
				param->typ = v__ast__Type_ref(_const_v__ast__int_type);
			}
		}
	}
	if (node->language == v__ast__Language__v && string__eq(string_after_char(node->name, '.'), _SLIT("init")) && !node->is_method && node->params.len == 0) {
		if (node->is_pub) {
			v__checker__Checker_error(c, _SLIT("fn `init` must not be public"), node->pos);
		}
		if (!v__ast__Type_alias_eq(node->return_type, _const_v__ast__void_type)) {
			v__checker__Checker_error(c, _SLIT("fn `init` cannot have a return type"), node->pos);
		}
	}
	if (!v__ast__Type_alias_eq(node->return_type, ((v__ast__Type)(0)))) {
		Option_void _t10 = v__checker__Checker_ensure_type_exists(c, node->return_type, node->return_type_pos);
		if (_t10.state != 0 && _t10.err._typ != _IError_None___index) {
			IError err = _t10.err;
			// Defer begin
			if (v__checker__Checker_fn_decl_defer_0) {
				c->stmt_level = prev_stmt_level;
				c->fn_level--;
				c->returns = prev_returns;
				c->inside_anon_fn = prev_inside_anon_fn;
				c->inside_unsafe = prev_inside_unsafe;
				c->inside_defer = prev_inside_defer;
				c->in_for_count = prev_in_for_count;
				c->fn_scope = prev_fn_scope;
			}
			// Defer end
			return;
		}
		
 ;
		if (node->language == v__ast__Language__v && node->is_method && string__eq(node->name, _SLIT("str"))) {
			if (!v__ast__Type_alias_eq(node->return_type, _const_v__ast__string_type)) {
				v__checker__Checker_error(c, _SLIT(".str() methods should return `string`"), node->pos);
			}
			if (node->params.len != 1) {
				v__checker__Checker_error(c, _SLIT(".str() methods should have 0 arguments"), node->pos);
			}
		}
		if (node->language == v__ast__Language__v && node->is_method && (string__eq(node->name, _SLIT("+")) || string__eq(node->name, _SLIT("-")) || string__eq(node->name, _SLIT("*")) || string__eq(node->name, _SLIT("%")) || string__eq(node->name, _SLIT("/")) || string__eq(node->name, _SLIT("<")) || string__eq(node->name, _SLIT("==")))) {
			if (node->params.len != 2) {
				v__checker__Checker_error(c, _SLIT("operator methods should have exactly 1 argument"), node->pos);
			} else {
				v__ast__TypeSymbol* receiver_sym = v__ast__Table_sym(c->table, node->receiver.typ);
				v__ast__TypeSymbol* param_sym = v__ast__Table_sym(c->table, (*(v__ast__Param*)/*ee elem_typ */array_get(node->params, 1)).typ);
				if (param_sym->kind == v__ast__Kind__string && receiver_sym->kind == v__ast__Kind__string) {
				} else if (!(param_sym->kind == v__ast__Kind__struct_ || param_sym->kind == v__ast__Kind__alias) || !(receiver_sym->kind == v__ast__Kind__struct_ || receiver_sym->kind == v__ast__Kind__alias)) {
					v__checker__Checker_error(c, _SLIT("operator methods are only allowed for struct and type alias"), node->pos);
				} else {
					v__ast__TypeSymbol* parent_sym = v__ast__Table_final_sym(c->table, node->receiver.typ);
					if (node->rec_mut) {
						v__checker__Checker_error(c, _SLIT("receiver cannot be `mut` for operator overloading"), node->receiver_pos);
					} else if ((*(v__ast__Param*)/*ee elem_typ */array_get(node->params, 1)).is_mut) {
						v__checker__Checker_error(c, _SLIT("argument cannot be `mut` for operator overloading"), node->pos);
					} else if (!v__ast__Type_alias_eq(node->receiver.typ, (*(v__ast__Param*)/*ee elem_typ */array_get(node->params, 1)).typ)) {
						v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("expected `"), 0xfe10, {.d_s = receiver_sym->name}}, {_SLIT("` not `"), 0xfe10, {.d_s = param_sym->name}}, {_SLIT("` - both operands must be the same type for operator overloading"), 0, { .d_c = 0 }}})), (*(v__ast__Param*)/*ee elem_typ */array_get(node->params, 1)).type_pos);
					} else if ((string__eq(node->name, _SLIT("<")) || string__eq(node->name, _SLIT("=="))) && !v__ast__Type_alias_eq(node->return_type, _const_v__ast__bool_type)) {
						v__checker__Checker_error(c, _SLIT("operator comparison methods should return `bool`"), node->pos);
					} else if (v__ast__TypeSymbol_is_primitive(parent_sym)) {
						v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot define operator methods on type alias for `"), 0xfe10, {.d_s = parent_sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node->pos);
					}
				}
			}
		}
	}
	if (node->language == v__ast__Language__v && !node->is_method && node->is_test) {
		if (!c->pref->is_test) {
			for (int _t11 = 0; _t11 < node->stmts.len; ++_t11) {
				v__ast__Stmt st = ((v__ast__Stmt*)node->stmts.data)[_t11];
				if ((st)._typ == 330 /* v.ast.AssertStmt */) {
					v__checker__Checker_warn(c, _SLIT("tests will not be run, because filename does not end with `_test.v`"), node->pos);
					break;
				}
			}
		}
		if (node->params.len != 0) {
			v__checker__Checker_error(c, _SLIT("test functions should take 0 parameters"), node->pos);
		}
		if (node->return_type != _const_v__ast__void_type_idx && v__ast__Type_clear_flag(node->return_type, v__ast__TypeFlag__optional) != _const_v__ast__void_type_idx) {
			v__checker__Checker_error(c, _SLIT("test functions should either return nothing at all, or be marked to return `?`"), node->pos);
		}
	}
	c->expected_type = _const_v__ast__void_type;
	c->table->cur_fn = node;
	if (!v__ast__Type_alias_eq(node->return_type, _const_v__ast__void_type) && v__ast__Type_has_flag(node->return_type, v__ast__TypeFlag__optional) && (node->stmts.len == 0 || ((*(v__ast__Stmt*)/*ee elem_typ */array_get(node->stmts, node->stmts.len - 1)))._typ != 350 /* v.ast.Return */)) {
		v__ast__TypeSymbol* sym = v__ast__Table_sym(c->table, node->return_type);
		if (sym->kind == v__ast__Kind__void) {
			array_push((array*)&node->stmts, _MOV((v__ast__Stmt[]){ v__ast__Return_to_sumtype_v__ast__Stmt(ADDR(v__ast__Return, ((v__ast__Return){.pos = node->pos,.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.exprs = __new_array(0, 0, sizeof(v__ast__Expr)),.types = __new_array(0, 0, sizeof(v__ast__Type)),}))) }));
		}
	}
	c->fn_scope = node->scope;
	v__checker__Checker_stmts(c, node->stmts);
	bool node_has_top_return = v__checker__has_top_return(node->stmts);
	node->has_return = c->returns || node_has_top_return;
	v__checker__Checker_check_noreturn_fn_decl(c, node);
	if (node->language == v__ast__Language__v && !node->no_body && !v__ast__Type_alias_eq(node->return_type, _const_v__ast__void_type) && !node->has_return && !node->is_noreturn) {
		if (c->inside_anon_fn) {
			v__checker__Checker_error(c, _SLIT("missing return at the end of an anonymous function"), node->pos);
		} else if (!Array_v__ast__Attr_contains(node->attrs, _SLIT("_naked"))) {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("missing return at end of function `"), 0xfe10, {.d_s = node->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node->pos);
		}
	}
	node->source_file = c->file;
// Defer begin
if (v__checker__Checker_fn_decl_defer_0) {
	c->stmt_level = prev_stmt_level;
	c->fn_level--;
	c->returns = prev_returns;
	c->inside_anon_fn = prev_inside_anon_fn;
	c->inside_unsafe = prev_inside_unsafe;
	c->inside_defer = prev_inside_defer;
	c->in_for_count = prev_in_for_count;
	c->fn_scope = prev_fn_scope;
}
// Defer end
}

VV_LOCAL_SYMBOL v__ast__Type v__checker__Checker_anon_fn(v__checker__Checker* c, v__ast__AnonFn* node) {
bool v__checker__Checker_anon_fn_defer_0 = false;
v__ast__FnDecl* keep_fn;
bool keep_inside_anon;
	keep_fn = c->table->cur_fn;
	keep_inside_anon = c->inside_anon_fn;
	v__checker__Checker_anon_fn_defer_0 = true;
	c->table->cur_fn = &node->decl;
	c->inside_anon_fn = true;
	for (int _t1 = 0; _t1 < node->inherited_vars.len; ++_t1) {
		v__ast__Param* var = ((v__ast__Param*)node->inherited_vars.data) + _t1;
		Option_v__ast__Var_ptr _t2 = v__ast__Scope_find_var(node->decl.scope->parent, var->name);
		if (_t2.state != 0) { /*or block*/ 
			IError err = _t2.err;
			_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("unexpected checker error: cannot find parent of inherited variable `"), 0xfe10, {.d_s = var->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		;
		}
		
 		v__ast__Var* parent_var =  (*(v__ast__Var**)_t2.data);
		if (var->is_mut && !parent_var->is_mut) {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("original `"), 0xfe10, {.d_s = parent_var->name}}, {_SLIT("` is immutable, declare it with `mut` to make it mutable"), 0, { .d_c = 0 }}})), var->pos);
		}
		var->typ = parent_var->typ;
	}
	v__checker__Checker_stmts(c, node->decl.stmts);
	v__checker__Checker_fn_decl(c, (voidptr)&/*qq*/node->decl);
	v__ast__Type _t3 = node->typ;
	// Defer begin
	if (v__checker__Checker_anon_fn_defer_0) {
		c->table->cur_fn = keep_fn;
		c->inside_anon_fn = keep_inside_anon;
	}
	// Defer end
	return _t3;
}

v__ast__Type v__checker__Checker_call_expr(v__checker__Checker* c, v__ast__CallExpr* node) {
	bool old_inside_fn_arg = c->inside_fn_arg;
	c->inside_fn_arg = true;
	bool continue_check = true;
	v__ast__Type typ = (node->is_method ? (v__checker__Checker_method_call(c, node)) : (v__checker__Checker_fn_call(c, node, (voidptr)&/*qq*/continue_check)));
	if (!continue_check) {
		v__ast__Type _t1 = _const_v__ast__void_type;
		return _t1;
	}
	c->inside_fn_arg = old_inside_fn_arg;
	bool free_tmp_arg_vars = c->pref->autofree && !c->is_builtin_mod && node->args.len > 0 && !v__ast__Type_has_flag((*(v__ast__CallArg*)/*ee elem_typ */array_get(node->args, 0)).typ, v__ast__TypeFlag__optional);
	if (free_tmp_arg_vars && !c->inside_const) {
		for (int i = 0; i < node->args.len; ++i) {
			v__ast__CallArg arg = ((v__ast__CallArg*)node->args.data)[i];
			if (!v__ast__Type_alias_eq(arg.typ, _const_v__ast__string_type)) {
				continue;
			}
			if ((arg.expr)._typ == 299 /* v.ast.Ident */ || (arg.expr)._typ == 323 /* v.ast.StringLiteral */ || (arg.expr)._typ == 319 /* v.ast.SelectorExpr */) {
				continue;
			}
			(*(v__ast__CallArg*)/*ee elem_typ */array_get(node->args, i)).is_tmp_autofree = true;
		}
		if (v__ast__Type_alias_eq(node->receiver_type, _const_v__ast__string_type) && !((node->left)._typ == 299 /* v.ast.Ident */ || (node->left)._typ == 323 /* v.ast.StringLiteral */ || (node->left)._typ == 319 /* v.ast.SelectorExpr */)) {
			node->free_receiver = true;
		}
	}
	c->expected_or_type = v__ast__Type_clear_flag(node->return_type, v__ast__TypeFlag__optional);
	v__checker__Checker_stmts_ending_with_expression(c, node->or_block.stmts);
	c->expected_or_type = _const_v__ast__void_type;
	if (node->or_block.kind == v__ast__OrKind__propagate && !v__ast__Type_has_flag(c->table->cur_fn->return_type, v__ast__TypeFlag__optional) && !c->inside_const) {
		if (!c->table->cur_fn->is_main) {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("to propagate the optional call, `"), 0xfe10, {.d_s = c->table->cur_fn->name}}, {_SLIT("` must return an optional"), 0, { .d_c = 0 }}})), node->or_block.pos);
		}
	}
	v__ast__Type _t2 = typ;
	return _t2;
}

v__ast__Type v__checker__Checker_fn_call(v__checker__Checker* c, v__ast__CallExpr* node, bool* continue_check) {
	string fn_name = node->name;
	if (string__eq(fn_name, _SLIT("main"))) {
		v__checker__Checker_error(c, _SLIT("the `main` function cannot be called in the program"), node->pos);
	}
	bool has_generic = false;
	Array_v__ast__Type concrete_types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
	for (int _t1 = 0; _t1 < node->concrete_types.len; ++_t1) {
		v__ast__Type concrete_type = ((v__ast__Type*)node->concrete_types.data)[_t1];
		if (v__ast__Type_has_flag(concrete_type, v__ast__TypeFlag__generic)) {
			has_generic = true;
			array_push((array*)&concrete_types, _MOV((v__ast__Type[]){ v__checker__Checker_unwrap_generic(c, concrete_type) }));
		} else {
			array_push((array*)&concrete_types, _MOV((v__ast__Type[]){ concrete_type }));
		}
	}
	if (!isnil(c->table->cur_fn) && c->table->cur_concrete_types.len == 0 && has_generic) {
		v__checker__Checker_error(c, _SLIT("generic fn using generic types cannot be called outside of generic fn"), node->pos);
	}
	if (concrete_types.len > 0) {
		bool no_exists = true;
		if (string_contains(fn_name, _SLIT("."))) {
			no_exists = v__ast__Table_register_fn_concrete_types(c->table, v__ast__CallExpr_fkey(node), concrete_types);
		} else {
			no_exists = v__ast__Table_register_fn_concrete_types(c->table, string__plus(string__plus(c->mod, _SLIT(".")), v__ast__CallExpr_fkey(node)), concrete_types);
			if (!no_exists) {
				no_exists = v__ast__Table_register_fn_concrete_types(c->table, v__ast__CallExpr_fkey(node), concrete_types);
			}
		}
		if (no_exists) {
			c->need_recheck_generic_fns = true;
		}
	}
	if (string__eq(fn_name, _SLIT("JS.await"))) {
		if (node->args.len > 1) {
			v__checker__Checker_error(c, _SLIT("JS.await expects 1 argument, a promise value (e.g `JS.await(fs.read())`"), node->pos);
			v__ast__Type _t4 = _const_v__ast__void_type;
			return _t4;
		}
		v__ast__Type typ = v__checker__Checker_expr(c, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node->args, 0)).expr);
		v__ast__TypeSymbol* tsym = v__ast__Table_sym(c->table, typ);
		if (!string_starts_with(tsym->name, _SLIT("Promise<"))) {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("JS.await: first argument must be a promise, got `"), 0xfe10, {.d_s = tsym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node->pos);
			v__ast__Type _t5 = _const_v__ast__void_type;
			return _t5;
		}
		c->table->cur_fn->has_await = true;
		if (tsym->info._typ == 446 /* v.ast.Struct */) {
			v__ast__Type ret_type = (*(v__ast__Type*)/*ee elem_typ */array_get((*tsym->info._v__ast__Struct).concrete_types, 0));
			ret_type = v__ast__Type_set_flag(ret_type, v__ast__TypeFlag__optional);
			node->return_type = ret_type;
			v__ast__Type _t6 = ret_type;
			return _t6;
		}
		
		else {
			v__checker__Checker_error(c, _SLIT("JS.await: Promise must be a struct type"), node->pos);
			v__ast__Type _t7 = _const_v__ast__void_type;
			return _t7;
		}
		;
		_v_panic(_SLIT("unreachable"));
		VUNREACHABLE();
	}
	if (string__eq(fn_name, _SLIT("json.encode"))) {
	} else if (string__eq(fn_name, _SLIT("json.decode")) && node->args.len > 0) {
		if (node->args.len != 2) {
			v__checker__Checker_error(c, _SLIT("json.decode expects 2 arguments, a type and a string (e.g `json.decode(T, '')`)"), node->pos);
			v__ast__Type _t8 = _const_v__ast__void_type;
			return _t8;
		}
		v__ast__Expr expr = (*(v__ast__CallArg*)/*ee elem_typ */array_get(node->args, 0)).expr;
		if ((expr)._typ == 325 /* v.ast.TypeNode */) {
			v__ast__TypeSymbol* sym = v__ast__Table_sym(c->table, (*expr._v__ast__TypeNode).typ);
			if (!v__ast__Table_known_type(c->table, sym->name)) {
				v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("json.decode: unknown type `"), 0xfe10, {.d_s = sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node->pos);
			}
		} else {
			string typ = charptr_vstring_literal( /* v.ast.Expr */ v_typeof_sumtype_v__ast__Expr( (expr)._typ ));
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("json.decode: first argument needs to be a type, got `"), 0xfe10, {.d_s = typ}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node->pos);
			v__ast__Type _t9 = _const_v__ast__void_type;
			return _t9;
		}
		c->expected_type = _const_v__ast__string_type;
		(*(v__ast__CallArg*)/*ee elem_typ */array_get(node->args, 1)).typ = v__checker__Checker_expr(c, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node->args, 1)).expr);
		if (!v__ast__Type_alias_eq((*(v__ast__CallArg*)/*ee elem_typ */array_get(node->args, 1)).typ, _const_v__ast__string_type)) {
			v__checker__Checker_error(c, _SLIT("json.decode: second argument needs to be a string"), node->pos);
		}
		v__ast__TypeNode typ = /* as */ *(v__ast__TypeNode*)__as_cast((expr)._v__ast__TypeNode,(expr)._typ, 325) /*expected idx: 325, name: v.ast.TypeNode */ ;
		v__ast__Type ret_type = v__ast__Type_set_flag(typ.typ, v__ast__TypeFlag__optional);
		node->return_type = ret_type;
		v__ast__Type _t10 = ret_type;
		return _t10;
	}
	v__ast__Fn func = (v__ast__Fn){.is_variadic = 0,.language = 0,.is_pub = 0,.is_ctor_new = 0,.is_deprecated = 0,.is_noreturn = 0,.is_unsafe = 0,.is_placeholder = 0,.is_main = 0,.is_test = 0,.is_keep_alive = 0,.is_method = 0,.no_body = 0,.mod = (string){.str=(byteptr)"", .is_lit=1},.file = (string){.str=(byteptr)"", .is_lit=1},.file_mode = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.return_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.return_type = 0,.receiver_type = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.params = __new_array(0, 0, sizeof(v__ast__Param)),.source_fn = 0,.usages = 0,.generic_names = __new_array(0, 0, sizeof(string)),.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_conditional = 0,.ctdefine_idx = 0,};
	bool found = false;
	bool found_in_args = false;
	if ((node->left)._typ == 278 /* v.ast.AnonFn */) {
		node->name = _SLIT("");
		v__checker__Checker_expr(c, node->left);
		if (!v__ast__Type_alias_eq((*node->left._v__ast__AnonFn).typ, ((v__ast__Type)(0)))) {
			v__ast__TypeSymbol* anon_fn_sym = v__ast__Table_sym(c->table, (*node->left._v__ast__AnonFn).typ);
			func = (/* as */ *(v__ast__FnType*)__as_cast((anon_fn_sym->info)._v__ast__FnType,(anon_fn_sym->info)._typ, 472) /*expected idx: 472, name: v.ast.FnType */ ).func;
			found = true;
		}
	}
	if (!found && !string_contains(fn_name, _SLIT(".")) && !string__eq(node->mod, _SLIT("builtin"))) {
		string name_prefixed =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = node->mod}}, {_SLIT("."), 0xfe10, {.d_s = fn_name}}, {_SLIT0, 0, { .d_c = 0 }}}));
		Option_v__ast__Fn _t11;
		if (_t11 = v__ast__Table_find_fn(c->table, name_prefixed), _t11.state == 0) {
			v__ast__Fn f = *(v__ast__Fn*)_t11.data;
			node->name = name_prefixed;
			found = true;
			func = f;
			(*(v__ast__Fn*)map_get((map*)&c->table->fns, &(string[]){name_prefixed}, &(v__ast__Fn[]){ (v__ast__Fn){.is_variadic = 0,.is_pub = 0,.is_ctor_new = 0,.is_deprecated = 0,.is_noreturn = 0,.is_unsafe = 0,.is_placeholder = 0,.is_main = 0,.is_test = 0,.is_keep_alive = 0,.is_method = 0,.no_body = 0,.mod = (string){.str=(byteptr)"", .is_lit=1},.file = (string){.str=(byteptr)"", .is_lit=1},.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.return_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.return_type = 0,.receiver_type = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.params = __new_array(0, 0, sizeof(v__ast__Param)),.source_fn = 0,.usages = 0,.generic_names = __new_array(0, 0, sizeof(string)),.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_conditional = 0,.ctdefine_idx = 0,} })).usages++;
		}
	}
	if (!found && (node->left)._typ == 302 /* v.ast.IndexExpr */) {
		v__checker__Checker_expr(c, node->left);
		v__ast__IndexExpr expr = /* as */ *(v__ast__IndexExpr*)__as_cast((node->left)._v__ast__IndexExpr,(node->left)._typ, 302) /*expected idx: 302, name: v.ast.IndexExpr */ ;
		v__ast__TypeSymbol* sym = v__ast__Table_sym(c->table, expr.left_type);
		if (sym->kind == v__ast__Kind__array) {
			v__ast__Array info = /* as */ *(v__ast__Array*)__as_cast((sym->info)._v__ast__Array,(sym->info)._typ, 441) /*expected idx: 441, name: v.ast.Array */ ;
			v__ast__TypeSymbol* elem_typ = v__ast__Table_sym(c->table, info.elem_type);
			if ((elem_typ->info)._typ == 472 /* v.ast.FnType */) {
				v__ast__Type _t12 = (*elem_typ->info._v__ast__FnType).func.return_type;
				return _t12;
			} else {
				v__checker__Checker_error(c, _SLIT("cannot call the element of the array, it is not a function"), node->pos);
			}
		} else if (sym->kind == v__ast__Kind__map) {
			v__ast__Map info = /* as */ *(v__ast__Map*)__as_cast((sym->info)._v__ast__Map,(sym->info)._typ, 442) /*expected idx: 442, name: v.ast.Map */ ;
			v__ast__TypeSymbol* value_typ = v__ast__Table_sym(c->table, info.value_type);
			if ((value_typ->info)._typ == 472 /* v.ast.FnType */) {
				v__ast__Type _t13 = (*value_typ->info._v__ast__FnType).func.return_type;
				return _t13;
			} else {
				v__checker__Checker_error(c, _SLIT("cannot call the value of the map, it is not a function"), node->pos);
			}
		} else if (sym->kind == v__ast__Kind__array_fixed) {
			v__ast__ArrayFixed info = /* as */ *(v__ast__ArrayFixed*)__as_cast((sym->info)._v__ast__ArrayFixed,(sym->info)._typ, 468) /*expected idx: 468, name: v.ast.ArrayFixed */ ;
			v__ast__TypeSymbol* elem_typ = v__ast__Table_sym(c->table, info.elem_type);
			if ((elem_typ->info)._typ == 472 /* v.ast.FnType */) {
				v__ast__Type _t14 = (*elem_typ->info._v__ast__FnType).func.return_type;
				return _t14;
			} else {
				v__checker__Checker_error(c, _SLIT("cannot call the element of the array, it is not a function"), node->pos);
			}
		} else {
		}
		found = true;
		v__ast__Type _t15 = _const_v__ast__string_type;
		return _t15;
	}
	if (!found) {
		Option_v__ast__Fn _t16;
		if (_t16 = v__ast__Table_find_fn(c->table, fn_name), _t16.state == 0) {
			v__ast__Fn f = *(v__ast__Fn*)_t16.data;
			found = true;
			func = f;
			(*(v__ast__Fn*)map_get((map*)&c->table->fns, &(string[]){fn_name}, &(v__ast__Fn[]){ (v__ast__Fn){.is_variadic = 0,.is_pub = 0,.is_ctor_new = 0,.is_deprecated = 0,.is_noreturn = 0,.is_unsafe = 0,.is_placeholder = 0,.is_main = 0,.is_test = 0,.is_keep_alive = 0,.is_method = 0,.no_body = 0,.mod = (string){.str=(byteptr)"", .is_lit=1},.file = (string){.str=(byteptr)"", .is_lit=1},.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.return_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.return_type = 0,.receiver_type = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.params = __new_array(0, 0, sizeof(v__ast__Param)),.source_fn = 0,.usages = 0,.generic_names = __new_array(0, 0, sizeof(string)),.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_conditional = 0,.ctdefine_idx = 0,} })).usages++;
		}
	}
	bool is_native_builtin = false;
	if (!found && c->pref->backend == v__pref__Backend__native) {
		if (Array_string_contains(_const_v__ast__native_builtins, fn_name)) {
			(*(v__ast__Fn*)map_get((map*)&c->table->fns, &(string[]){fn_name}, &(v__ast__Fn[]){ (v__ast__Fn){.is_variadic = 0,.is_pub = 0,.is_ctor_new = 0,.is_deprecated = 0,.is_noreturn = 0,.is_unsafe = 0,.is_placeholder = 0,.is_main = 0,.is_test = 0,.is_keep_alive = 0,.is_method = 0,.no_body = 0,.mod = (string){.str=(byteptr)"", .is_lit=1},.file = (string){.str=(byteptr)"", .is_lit=1},.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.return_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.return_type = 0,.receiver_type = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.params = __new_array(0, 0, sizeof(v__ast__Param)),.source_fn = 0,.usages = 0,.generic_names = __new_array(0, 0, sizeof(string)),.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_conditional = 0,.ctdefine_idx = 0,} })).usages++;
			found = true;
			func = (*(v__ast__Fn*)map_get(ADDR(map, c->table->fns), &(string[]){fn_name}, &(v__ast__Fn[]){ (v__ast__Fn){.is_variadic = 0,.is_pub = 0,.is_ctor_new = 0,.is_deprecated = 0,.is_noreturn = 0,.is_unsafe = 0,.is_placeholder = 0,.is_main = 0,.is_test = 0,.is_keep_alive = 0,.is_method = 0,.no_body = 0,.mod = (string){.str=(byteptr)"", .is_lit=1},.file = (string){.str=(byteptr)"", .is_lit=1},.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.return_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.return_type = 0,.receiver_type = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.params = __new_array(0, 0, sizeof(v__ast__Param)),.source_fn = 0,.usages = 0,.generic_names = __new_array(0, 0, sizeof(string)),.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_conditional = 0,.ctdefine_idx = 0,} }));
			is_native_builtin = true;
		}
	}
	if (!found && c->pref->is_vsh) {
		string os_name =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("os."), 0xfe10, {.d_s = fn_name}}, {_SLIT0, 0, { .d_c = 0 }}}));
		Option_v__ast__Fn _t17;
		if (_t17 = v__ast__Table_find_fn(c->table, os_name), _t17.state == 0) {
			v__ast__Fn f = *(v__ast__Fn*)_t17.data;
			if (f.generic_names.len == node->concrete_types.len) {
				string node_alias_name = v__ast__CallExpr_fkey(node);
				map_set(&c->table->fn_generic_types, &(string[]){os_name}, &(Array_Array_v__ast__Type[]) { (*(Array_Array_v__ast__Type*)map_get(ADDR(map, c->table->fn_generic_types), &(string[]){node_alias_name}, &(Array_Array_v__ast__Type[]){ __new_array(0, 0, sizeof(Array_v__ast__Type)) })) });
			}
			node->name = os_name;
			found = true;
			func = f;
			(*(v__ast__Fn*)map_get((map*)&c->table->fns, &(string[]){os_name}, &(v__ast__Fn[]){ (v__ast__Fn){.is_variadic = 0,.is_pub = 0,.is_ctor_new = 0,.is_deprecated = 0,.is_noreturn = 0,.is_unsafe = 0,.is_placeholder = 0,.is_main = 0,.is_test = 0,.is_keep_alive = 0,.is_method = 0,.no_body = 0,.mod = (string){.str=(byteptr)"", .is_lit=1},.file = (string){.str=(byteptr)"", .is_lit=1},.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.return_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.return_type = 0,.receiver_type = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.params = __new_array(0, 0, sizeof(v__ast__Param)),.source_fn = 0,.usages = 0,.generic_names = __new_array(0, 0, sizeof(string)),.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_conditional = 0,.ctdefine_idx = 0,} })).usages++;
		}
	}
	if (is_native_builtin) {
		v__ast__Type _t18 = _const_v__ast__void_type;
		return _t18;
	}
	if (!found) {
		int typ = 0;
		Option_v__ast__ScopeObject _t19;
		if (_t19 = v__ast__Scope_find(node->scope, node->name), _t19.state == 0) {
			v__ast__ScopeObject obj = *(v__ast__ScopeObject*)_t19.data;
			if (obj._typ == 356 /* v.ast.GlobalField */) {
				typ = (*obj._v__ast__GlobalField).typ;
			}
			else if (obj._typ == 357 /* v.ast.Var */) {
				v__ast__Type _t20; /* if prepend */
				if ((*obj._v__ast__Var).smartcasts.len != 0) {
					_t20 = (*(v__ast__Type*)array_last((*obj._v__ast__Var).smartcasts));
				} else {
					_t20 = (*obj._v__ast__Var).typ;
				}
				typ =  _t20;
			}
			
			else {
			}
			;
		}
		if (typ != 0) {
			v__ast__TypeSymbol* generic_vts = v__ast__Table_final_sym(c->table, typ);
			if (generic_vts->kind == v__ast__Kind__function) {
				v__ast__FnType info = /* as */ *(v__ast__FnType*)__as_cast((generic_vts->info)._v__ast__FnType,(generic_vts->info)._typ, 472) /*expected idx: 472, name: v.ast.FnType */ ;
				func = info.func;
				found = true;
				found_in_args = true;
			} else {
				v__ast__TypeSymbol* vts = v__ast__Table_sym(c->table, v__checker__Checker_unwrap_generic(c, typ));
				if (vts->kind == v__ast__Kind__function) {
					v__ast__FnType info = /* as */ *(v__ast__FnType*)__as_cast((vts->info)._v__ast__FnType,(vts->info)._typ, 472) /*expected idx: 472, name: v.ast.FnType */ ;
					func = info.func;
					found = true;
					found_in_args = true;
				}
			}
		}
	}
	if (!found) {
		Option_v__ast__ScopeObject _t21;
		if (_t21 = v__ast__Scope_find(c->file->global_scope, fn_name), _t21.state == 0) {
			v__ast__ScopeObject obj = *(v__ast__ScopeObject*)_t21.data;
			if ((*(obj.typ)) != 0) {
				v__ast__TypeSymbol* sym = v__ast__Table_sym(c->table, (*(obj.typ)));
				if (sym->kind == v__ast__Kind__function) {
					found = true;
					func = (/* as */ *(v__ast__FnType*)__as_cast((sym->info)._v__ast__FnType,(sym->info)._typ, 472) /*expected idx: 472, name: v.ast.FnType */ ).func;
				}
			}
		}
	}
	if (!found) {
		*continue_check = false;
		v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unknown function: "), 0xfe10, {.d_s = fn_name}}, {_SLIT0, 0, { .d_c = 0 }}})), node->pos);
		v__ast__Type _t22 = _const_v__ast__void_type;
		return _t22;
	}
	node->is_noreturn = func.is_noreturn;
	node->is_ctor_new = func.is_ctor_new;
	if (!found_in_args) {
		if (v__ast__Scope_known_var(node->scope, fn_name)) {
			v__checker__Checker_error(c,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("ambiguous call to: `"), 0xfe10, {.d_s = fn_name}}, {_SLIT("`, may refer to fn `"), 0xfe10, {.d_s = fn_name}}, {_SLIT("` or variable `"), 0xfe10, {.d_s = fn_name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node->pos);
		}
	}
	if (!func.is_pub && func.language == v__ast__Language__v && func.name.len > 0 && func.mod.len > 0 && !string__eq(func.mod, c->mod)) {
		v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("function `"), 0xfe10, {.d_s = func.name}}, {_SLIT("` is private"), 0, { .d_c = 0 }}})), node->pos);
	}
	if (!isnil(c->table->cur_fn) && !c->table->cur_fn->is_deprecated && func.is_deprecated) {
		v__checker__Checker_deprecate_fnmethod(c, _SLIT("function"), func.name, func, *node);
	}
	if (func.is_unsafe && !c->inside_unsafe && (func.language != v__ast__Language__c || ((string_at(func.name, 2) == 'm' || string_at(func.name, 2) == 's') && string__eq(func.mod, _SLIT("builtin"))))) {
		v__checker__Checker_warn(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("function `"), 0xfe10, {.d_s = func.name}}, {_SLIT("` must be called from an `unsafe` block"), 0, { .d_c = 0 }}})), node->pos);
	}
	node->is_keep_alive = func.is_keep_alive;
	if (!string__eq(func.mod, _SLIT("builtin")) && func.language == v__ast__Language__v && func.no_body && !c->pref->translated && !func.is_unsafe) {
		v__checker__Checker_error(c, _SLIT("cannot call a function that does not have a body"), node->pos);
	}
	for (int _t23 = 0; _t23 < node->concrete_types.len; ++_t23) {
		v__ast__Type concrete_type = ((v__ast__Type*)node->concrete_types.data)[_t23];
		Option_void _t24 = v__checker__Checker_ensure_type_exists(c, concrete_type, node->concrete_list_pos);
		if (_t24.state != 0 && _t24.err._typ != _IError_None___index) {
			IError err = _t24.err;
		}
		
 ;
	}
	if (func.generic_names.len > 0 && node->args.len == 0 && node->concrete_types.len == 0) {
		v__checker__Checker_error(c, _SLIT("no argument generic function must add concrete types, e.g. foo<int>()"), node->pos);
		v__ast__Type _t25 = func.return_type;
		return _t25;
	}
	if (v__ast__Type_alias_eq(func.return_type, _const_v__ast__void_type) && func.is_conditional && func.ctdefine_idx != -1) {
		node->should_be_skipped = v__checker__Checker_evaluate_once_comptime_if_attribute(c, (voidptr)&/*qq*/(*(v__ast__Attr*)/*ee elem_typ */array_get(func.attrs, func.ctdefine_idx)));
	}
	if (node->language != v__ast__Language__js) {
		Option_void _t26 = v__checker__Checker_check_expected_arg_count(c, node, (voidptr)&/*qq*/func);
		if (_t26.state != 0 && _t26.err._typ != _IError_None___index) {
			IError err = _t26.err;
			v__ast__Type _t27 = func.return_type;
			return _t27;
		}
		
 ;
	}
	if ((string__eq(fn_name, _SLIT("println")) || string__eq(fn_name, _SLIT("print")) || string__eq(fn_name, _SLIT("eprintln")) || string__eq(fn_name, _SLIT("eprint")) || string__eq(fn_name, _SLIT("panic"))) && node->args.len > 0) {
		c->inside_println_arg = true;
		c->expected_type = _const_v__ast__string_type;
		(*(v__ast__CallArg*)/*ee elem_typ */array_get(node->args, 0)).typ = v__checker__Checker_expr(c, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node->args, 0)).expr);
		v__ast__CallArg arg = (*(v__ast__CallArg*)/*ee elem_typ */array_get(node->args, 0));
		v__checker__Checker_check_expr_opt_call(c, arg.expr, arg.typ);
		if (v__ast__Type_is_void(arg.typ)) {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = fn_name}}, {_SLIT("` can not print void expressions"), 0, { .d_c = 0 }}})), node->pos);
		} else if (v__ast__Type_alias_eq(arg.typ, _const_v__ast__char_type) && v__ast__Type_nr_muls(arg.typ) == 0) {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = fn_name}}, {_SLIT("` cannot print type `char` directly, print its address or cast it to an integer instead"), 0, { .d_c = 0 }}})), node->pos);
		}
		v__checker__Checker_fail_if_unreadable(c, arg.expr, arg.typ, _SLIT("argument to print"));
		c->inside_println_arg = false;
		node->return_type = _const_v__ast__void_type;
		v__ast__Type _t28 = func.return_type;
		return _t28;
	}
	if (string__eq(fn_name, _SLIT("error")) && node->args.len == 1) {
		v__ast__CallArg arg = (*(v__ast__CallArg*)/*ee elem_typ */array_get(node->args, 0));
		(*(v__ast__CallArg*)/*ee elem_typ */array_get(node->args, 0)).typ = v__checker__Checker_expr(c, arg.expr);
		if (v__ast__Type_alias_eq((*(v__ast__CallArg*)/*ee elem_typ */array_get(node->args, 0)).typ, _const_v__ast__error_type)) {
			v__checker__Checker_warn(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("`error("), 0xfe10, {.d_s = v__ast__CallArg_str(arg)}}, {_SLIT(")` can be shortened to just `"), 0xfe10, {.d_s = v__ast__CallArg_str(arg)}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node->pos);
		}
	}
	if (node->expected_arg_types.len == 0) {
		for (int _t29 = 0; _t29 < func.params.len; ++_t29) {
			v__ast__Param param = ((v__ast__Param*)func.params.data)[_t29];
			array_push((array*)&node->expected_arg_types, _MOV((v__ast__Type[]){ param.typ }));
		}
	}
	if (!v__pref__Backend_is_js(c->pref->backend) && node->args.len > 0 && func.params.len == 0) {
		v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("too many arguments in call to `"), 0xfe10, {.d_s = func.name}}, {_SLIT("` (non-js backend: "), 0xfe10, {.d_s = v__pref__Backend_str(c->pref->backend)}}, {_SLIT(")"), 0, { .d_c = 0 }}})), node->pos);
	}
	for (int i = 0; i < node->args.len; ++i) {
		v__ast__CallArg* call_arg = ((v__ast__CallArg*)node->args.data) + i;
		if (func.params.len == 0) {
			continue;
		}
		v__ast__Param param = (func.is_variadic && i >= func.params.len - 1 ? ((*(v__ast__Param*)/*ee elem_typ */array_get(func.params, func.params.len - 1))) : ((*(v__ast__Param*)/*ee elem_typ */array_get(func.params, i))));
		if (func.is_variadic && (call_arg->expr)._typ == 279 /* v.ast.ArrayDecompose */) {
			if (i > func.params.len - 1) {
				v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("too many arguments in call to `"), 0xfe10, {.d_s = func.name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node->pos);
			}
		}
		c->expected_type = param.typ;
		v__ast__TypeSymbol* e_sym = v__ast__Table_sym(c->table, c->expected_type);
		if ((call_arg->expr)._typ == 308 /* v.ast.MapInit */ && e_sym->kind == v__ast__Kind__struct_) {
			v__checker__Checker_error(c, _SLIT("cannot initialize a struct with a map"), call_arg->pos);
			continue;
		} else if ((call_arg->expr)._typ == 324 /* v.ast.StructInit */ && e_sym->kind == v__ast__Kind__map) {
			v__checker__Checker_error(c, _SLIT("cannot initialize a map with a struct"), call_arg->pos);
			continue;
		}
		v__ast__Type typ = v__checker__Checker_check_expr_opt_call(c, call_arg->expr, v__checker__Checker_expr(c, call_arg->expr));
		(*(v__ast__CallArg*)/*ee elem_typ */array_get(node->args, i)).typ = typ;
		v__ast__TypeSymbol* typ_sym = v__ast__Table_sym(c->table, typ);
		v__ast__TypeSymbol* param_typ_sym = v__ast__Table_sym(c->table, param.typ);
		if (func.is_variadic && v__ast__Type_has_flag(typ, v__ast__TypeFlag__variadic) && node->args.len - 1 > i) {
			v__checker__Checker_error(c, _SLIT("when forwarding a variadic variable, it must be the final argument"), call_arg->pos);
		}
		v__ast__ShareType arg_share = v__ast__Type_share(param.typ);
		if (arg_share == v__ast__ShareType__shared_t && (c->locked_names.len > 0 || c->rlocked_names.len > 0)) {
			v__checker__Checker_error(c, _SLIT("function with `shared` arguments cannot be called inside `lock`/`rlock` block"), call_arg->pos);
		}
		if (call_arg->is_mut) {
			multi_return_string_v__token__Position mr_26725 = v__checker__Checker_fail_if_immutable(c, call_arg->expr);
			string to_lock = mr_26725.arg0;
			v__token__Position pos = mr_26725.arg1;
			if (!v__ast__Expr_is_lvalue(call_arg->expr)) {
				v__checker__Checker_error(c, _SLIT("cannot pass expression as `mut`"), v__ast__Expr_position(call_arg->expr));
			}
			if (!param.is_mut) {
				string tok = v__ast__ShareType_str(call_arg->share);
				v__checker__Checker_error(c,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = node->name}}, {_SLIT("` parameter `"), 0xfe10, {.d_s = param.name}}, {_SLIT("` is not `"), 0xfe10, {.d_s = tok}}, {_SLIT("`, `"), 0xfe10, {.d_s = tok}}, {_SLIT("` is not needed`"), 0, { .d_c = 0 }}})), v__ast__Expr_position(call_arg->expr));
			} else {
				if (v__ast__Type_share(param.typ) != call_arg->share) {
					v__checker__Checker_error(c, _SLIT("wrong shared type"), v__ast__Expr_position(call_arg->expr));
				}
				if ((to_lock).len != 0 && !v__ast__Type_has_flag(param.typ, v__ast__TypeFlag__shared_f)) {
					v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = to_lock}}, {_SLIT(" is `shared` and must be `lock`ed to be passed as `mut`"), 0, { .d_c = 0 }}})), pos);
				}
			}
		} else {
			if (param.is_mut) {
				string tok = v__ast__ShareType_str(call_arg->share);
				v__checker__Checker_error(c,  str_intp(7, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = node->name}}, {_SLIT("` parameter `"), 0xfe10, {.d_s = param.name}}, {_SLIT("` is `"), 0xfe10, {.d_s = tok}}, {_SLIT("`, you need to provide `"), 0xfe10, {.d_s = tok}}, {_SLIT("` e.g. `"), 0xfe10, {.d_s = tok}}, {_SLIT(" arg"), 0xfe07, {.d_i32 = i + 1}}, {_SLIT("`"), 0, { .d_c = 0 }}})), v__ast__Expr_position(call_arg->expr));
			} else {
				v__checker__Checker_fail_if_unreadable(c, call_arg->expr, typ, _SLIT("argument"));
			}
		}
		v__ast__TypeSymbol* final_param_sym = param_typ_sym;
		v__ast__Type final_param_typ = param.typ;
		if (func.is_variadic && (param_typ_sym->info)._typ == 441 /* v.ast.Array */) {
			final_param_typ = v__ast__TypeSymbol_array_info(param_typ_sym).elem_type;
			final_param_sym = v__ast__Table_sym(c->table, final_param_typ);
		}
		if (!v__ast__Type_alias_eq(call_arg->typ, param.typ) && (v__ast__Type_alias_eq(param.typ, _const_v__ast__voidptr_type) || final_param_sym->idx == _const_v__ast__voidptr_type_idx) && !v__ast__Type_is_any_kind_of_pointer(call_arg->typ) && func.language == v__ast__Language__v && !v__ast__Expr_is_lvalue(call_arg->expr) && !string__eq(func.name, _SLIT("json.encode")) && !c->pref->translated) {
			v__checker__Checker_error(c, _SLIT("expression cannot be passed as `voidptr`"), v__ast__Expr_position(call_arg->expr));
		}
		if (final_param_sym->kind == v__ast__Kind__interface_) {
			if (v__checker__Checker_type_implements(c, typ, final_param_typ, v__ast__Expr_position(call_arg->expr))) {
				if (!v__ast__Type_is_ptr(typ) && !v__ast__Type_is_pointer(typ) && !c->inside_unsafe && typ_sym->kind != v__ast__Kind__interface_) {
					v__checker__Checker_mark_as_referenced(c, &call_arg->expr, true);
				}
			}
			continue;
		}
		Option_void _t31 = v__checker__Checker_check_expected_call_arg(c, typ, v__checker__Checker_unwrap_generic(c, param.typ), node->language, *call_arg);
		if (_t31.state != 0 && _t31.err._typ != _IError_None___index) {
			IError err = _t31.err;
			if (typ_sym->kind == v__ast__Kind__void && param_typ_sym->kind == v__ast__Kind__string) {
				continue;
			}
			if (v__ast__Type_has_flag(param.typ, v__ast__TypeFlag__generic)) {
				continue;
			}
			if (c->pref->translated) {
				if (v__ast__Type_alias_eq(param.typ, _const_v__ast__int_type) && typ_sym->kind == v__ast__Kind__enum_) {
					continue;
				}
				if (v__ast__Type_alias_eq(typ, _const_v__ast__int_type) && param_typ_sym->kind == v__ast__Kind__enum_) {
					continue;
				}
				bool param_is_number = v__ast__Type_is_number(param.typ);
				if (v__ast__Type_is_ptr(param.typ)) {
					param_is_number = v__ast__Type_is_number(v__ast__Type_deref(param.typ));
				}
				bool typ_is_number = v__ast__Type_is_number(typ);
				if (v__ast__Type_is_ptr(typ)) {
					typ_is_number = v__ast__Type_is_number(v__ast__Type_deref(typ));
				}
				if (param_is_number && typ_is_number) {
					continue;
				}
				if (param.typ == _const_v__ast__voidptr_type_idx || typ == _const_v__ast__voidptr_type_idx) {
					continue;
				}
				if ((typ_sym->kind == v__ast__Kind__array_fixed && param_is_number) || (param_typ_sym->kind == v__ast__Kind__array_fixed && typ_is_number)) {
					continue;
				}
				if (v__ast__Type_is_any_kind_of_pointer(param.typ) && typ_is_number) {
					continue;
				}
			}
			v__checker__Checker_error(c,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = (*(err.msg))}}, {_SLIT(" in argument "), 0xfe07, {.d_i32 = i + 1}}, {_SLIT(" to `"), 0xfe10, {.d_s = fn_name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), call_arg->pos);
		;
		}
		
 ;
		if (func.language != v__ast__Language__c && !c->inside_unsafe && v__ast__Type_nr_muls(typ) != v__ast__Type_nr_muls(param.typ) && !(call_arg->is_mut && param.is_mut) && !(!call_arg->is_mut && !param.is_mut) && !(param.typ == _const_v__ast__byteptr_type || param.typ == _const_v__ast__charptr_type || param.typ == _const_v__ast__voidptr_type)) {
			v__checker__Checker_warn(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("automatic referencing/dereferencing is deprecated and will be removed soon (got: "), 0xfe07, {.d_i32 = v__ast__Type_nr_muls(typ)}}, {_SLIT(" references, expected: "), 0xfe07, {.d_i32 = v__ast__Type_nr_muls(param.typ)}}, {_SLIT(" references)"), 0, { .d_c = 0 }}})), call_arg->pos);
		}
	}
	if (func.generic_names.len != node->concrete_types.len) {
		v__checker__Checker_infer_fn_generic_types(c, func, node);
		concrete_types = node->concrete_types;
	}
	if (func.generic_names.len > 0) {
		for (int i = 0; i < node->args.len; ++i) {
			v__ast__CallArg* call_arg = ((v__ast__CallArg*)node->args.data) + i;
			v__ast__Param param = (func.is_variadic && i >= func.params.len - 1 ? ((*(v__ast__Param*)/*ee elem_typ */array_get(func.params, func.params.len - 1))) : ((*(v__ast__Param*)/*ee elem_typ */array_get(func.params, i))));
			c->expected_type = param.typ;
			v__ast__Type typ = v__checker__Checker_check_expr_opt_call(c, call_arg->expr, v__checker__Checker_expr(c, call_arg->expr));
			if (v__ast__Type_has_flag(param.typ, v__ast__TypeFlag__generic) && func.generic_names.len == node->concrete_types.len) {
				Option_v__ast__Type _t32;
				if (_t32 = v__ast__Table_resolve_generic_to_concrete(c->table, param.typ, func.generic_names, concrete_types), _t32.state == 0) {
					v__ast__Type unwrap_typ = *(v__ast__Type*)_t32.data;
					v__ast__Type utyp = v__checker__Checker_unwrap_generic(c, typ);
					v__ast__TypeSymbol* unwrap_sym = v__ast__Table_sym(c->table, unwrap_typ);
					if (unwrap_sym->kind == v__ast__Kind__interface_) {
						if (v__checker__Checker_type_implements(c, utyp, unwrap_typ, v__ast__Expr_position(call_arg->expr))) {
							if (!v__ast__Type_is_ptr(utyp) && !v__ast__Type_is_pointer(utyp) && !c->inside_unsafe && v__ast__Table_sym(c->table, utyp)->kind != v__ast__Kind__interface_) {
								v__checker__Checker_mark_as_referenced(c, &call_arg->expr, true);
							}
						}
						continue;
					}
					Option_void _t33 = v__checker__Checker_check_expected_call_arg(c, utyp, unwrap_typ, node->language, *call_arg);
					if (_t33.state != 0 && _t33.err._typ != _IError_None___index) {
						IError err = _t33.err;
						v__checker__Checker_error(c,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = (*(err.msg))}}, {_SLIT(" in argument "), 0xfe07, {.d_i32 = i + 1}}, {_SLIT(" to `"), 0xfe10, {.d_s = fn_name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), call_arg->pos);
					;
					}
					
 ;
				}
			}
		}
	}
	if (func.generic_names.len > 0 && v__ast__Type_has_flag(func.return_type, v__ast__TypeFlag__generic) && c->table->cur_fn->generic_names.len == 0) {
		node->return_type = v__ast__Table_unwrap_generic_type(c->table, func.return_type, func.generic_names, concrete_types);
	} else {
		node->return_type = func.return_type;
	}
	if (node->concrete_types.len > 0 && func.return_type != 0 && c->table->cur_fn->generic_names.len == 0) {
		Option_v__ast__Type _t34;
		if (_t34 = v__ast__Table_resolve_generic_to_concrete(c->table, func.return_type, func.generic_names, concrete_types), _t34.state == 0) {
			v__ast__Type typ = *(v__ast__Type*)_t34.data;
			node->return_type = typ;
			v__ast__Type _t35 = typ;
			return _t35;
		}
	}
	if (node->concrete_types.len > 0 && func.generic_names.len == 0) {
		v__checker__Checker_error(c, _SLIT("a non generic function called like a generic one"), node->concrete_list_pos);
	}
	if (node->concrete_types.len > func.generic_names.len) {
		v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("too many generic parameters got "), 0xfe07, {.d_i32 = node->concrete_types.len}}, {_SLIT(", expected "), 0xfe07, {.d_i32 = func.generic_names.len}}, {_SLIT0, 0, { .d_c = 0 }}})), node->concrete_list_pos);
	}
	if (func.generic_names.len > 0) {
		v__ast__Type _t36 = node->return_type;
		return _t36;
	}
	v__ast__Type _t37 = func.return_type;
	return _t37;
}

v__ast__Type v__checker__Checker_method_call(v__checker__Checker* c, v__ast__CallExpr* node) {
	v__ast__Type left_type = v__checker__Checker_expr(c, node->left);
	c->expected_type = left_type;
	bool is_generic = v__ast__Type_has_flag(left_type, v__ast__TypeFlag__generic);
	if (is_generic && node->concrete_types.len == 0) {
		v__ast__TypeSymbol* rec_sym = v__ast__Table_sym(c->table, left_type);
		if ((rec_sym->info)._typ == 446 /* v.ast.Struct */) {
			node->concrete_types = (*rec_sym->info._v__ast__Struct).generic_types;
		}
	}
	node->left_type = left_type;
	node->return_type = left_type;
	node->receiver_type = left_type;
	if (c->table->cur_fn->generic_names.len > 0) {
		v__ast__Table_unwrap_generic_type(c->table, left_type, c->table->cur_fn->generic_names, c->table->cur_concrete_types);
	}
	v__ast__Type unwrapped_left_type = v__checker__Checker_unwrap_generic(c, left_type);
	v__ast__TypeSymbol* left_sym = v__ast__Table_sym(c->table, unwrapped_left_type);
	v__ast__TypeSymbol* final_left_sym = v__ast__Table_final_sym(c->table, unwrapped_left_type);
	string method_name = node->name;
	string _t1; /* if prepend */
	Option_v__ast__StructField _t2;
	if (_t2 = v__ast__Table_find_field(c->table, left_sym, method_name), _t2.state == 0) {
		v__ast__StructField field = *(v__ast__StructField*)_t2.data;
		_t1 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unknown method `"), 0xfe10, {.d_s = field.name}}, {_SLIT("` did you mean to access the field with the same name instead?"), 0, { .d_c = 0 }}}));
	} else {
		IError err = _t2.err;
		_t1 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("unknown method or field: `"), 0xfe10, {.d_s = left_sym->name}}, {_SLIT("."), 0xfe10, {.d_s = method_name}}, {_SLIT("`"), 0, { .d_c = 0 }}}));
	}
	string unknown_method_msg =  _t1;
	if (v__ast__Type_has_flag(left_type, v__ast__TypeFlag__optional)) {
		v__checker__Checker_error(c, _SLIT("optional type cannot be called directly"), v__ast__Expr_position(node->left));
		v__ast__Type _t3 = _const_v__ast__void_type;
		return _t3;
	}
	if (left_sym->kind == v__ast__Kind__sum_type || left_sym->kind == v__ast__Kind__interface_) {
		if (string__eq(method_name, _SLIT("type_name"))) {
			v__ast__Type _t4 = _const_v__ast__string_type;
			return _t4;
		}
		if (string__eq(method_name, _SLIT("type_idx"))) {
			v__ast__Type _t5 = _const_v__ast__int_type;
			return _t5;
		}
	}
	if (v__ast__Type_alias_eq(left_type, _const_v__ast__void_type)) {
		v__ast__Type _t6 = _const_v__ast__void_type;
		return _t6;
	}
	Array_v__ast__Type concrete_types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
	for (int _t7 = 0; _t7 < node->concrete_types.len; ++_t7) {
		v__ast__Type concrete_type = ((v__ast__Type*)node->concrete_types.data)[_t7];
		if (v__ast__Type_has_flag(concrete_type, v__ast__TypeFlag__generic)) {
			array_push((array*)&concrete_types, _MOV((v__ast__Type[]){ v__checker__Checker_unwrap_generic(c, concrete_type) }));
		} else {
			array_push((array*)&concrete_types, _MOV((v__ast__Type[]){ concrete_type }));
		}
	}
	if (concrete_types.len > 0) {
		if (v__ast__Table_register_fn_concrete_types(c->table, v__ast__CallExpr_fkey(node), concrete_types)) {
			c->need_recheck_generic_fns = true;
		}
	}
	if (left_sym->kind == v__ast__Kind__array && Array_string_contains(_const_v__checker__array_builtin_methods, method_name)) {
		v__ast__Type _t10 = v__checker__Checker_array_builtin_method_call(c, node, left_type, *v__ast__Table_sym(c->table, left_type));
		return _t10;
	} else if ((left_sym->kind == v__ast__Kind__map || final_left_sym->kind == v__ast__Kind__map) && (string__eq(method_name, _SLIT("clone")) || string__eq(method_name, _SLIT("keys")) || string__eq(method_name, _SLIT("move")) || string__eq(method_name, _SLIT("delete")))) {
		if (left_sym->kind == v__ast__Kind__map) {
			v__ast__Type _t11 = v__checker__Checker_map_builtin_method_call(c, node, left_type, *left_sym);
			return _t11;
		} else {
			v__ast__Type parent_type = (/* as */ *(v__ast__Alias*)__as_cast((left_sym->info)._v__ast__Alias,(left_sym->info)._typ, 460) /*expected idx: 460, name: v.ast.Alias */ ).parent_type;
			v__ast__Type _t12 = v__checker__Checker_map_builtin_method_call(c, node, parent_type, *final_left_sym);
			return _t12;
		}
	} else if (left_sym->kind == v__ast__Kind__array && (string__eq(method_name, _SLIT("insert")) || string__eq(method_name, _SLIT("prepend")))) {
		if (string__eq(method_name, _SLIT("insert"))) {
			if (node->args.len != 2) {
				v__checker__Checker_error(c, _SLIT("`array.insert()` should have 2 arguments, e.g. `insert(1, val)`"), node->pos);
				v__ast__Type _t13 = _const_v__ast__void_type;
				return _t13;
			} else {
				v__ast__Type arg_type = v__checker__Checker_expr(c, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node->args, 0)).expr);
				if (!(arg_type == _const_v__ast__int_type || arg_type == _const_v__ast__int_literal_type)) {
					v__checker__Checker_error(c, _SLIT("the first argument of `array.insert()` should be integer"), v__ast__Expr_position((*(v__ast__CallArg*)/*ee elem_typ */array_get(node->args, 0)).expr));
					v__ast__Type _t14 = _const_v__ast__void_type;
					return _t14;
				}
			}
		} else {
			if (node->args.len != 1) {
				v__checker__Checker_error(c, _SLIT("`array.prepend()` should have 1 argument, e.g. `prepend(val)`"), node->pos);
				v__ast__Type _t15 = _const_v__ast__void_type;
				return _t15;
			}
		}
		v__ast__Array info = /* as */ *(v__ast__Array*)__as_cast((left_sym->info)._v__ast__Array,(left_sym->info)._typ, 441) /*expected idx: 441, name: v.ast.Array */ ;
		v__ast__Expr arg_expr = (string__eq(method_name, _SLIT("insert")) ? ((*(v__ast__CallArg*)/*ee elem_typ */array_get(node->args, 1)).expr) : ((*(v__ast__CallArg*)/*ee elem_typ */array_get(node->args, 0)).expr));
		v__ast__Type arg_type = v__checker__Checker_expr(c, arg_expr);
		v__ast__TypeSymbol* arg_sym = v__ast__Table_sym(c->table, arg_type);
		if (!v__checker__Checker_check_types(c, arg_type, info.elem_type) && !v__checker__Checker_check_types(c, left_type, arg_type)) {
			v__checker__Checker_error(c,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("cannot "), 0xfe10, {.d_s = method_name}}, {_SLIT(" `"), 0xfe10, {.d_s = arg_sym->name}}, {_SLIT("` to `"), 0xfe10, {.d_s = left_sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), v__ast__Expr_position(arg_expr));
		}
	} else if (final_left_sym->kind == v__ast__Kind__array && (string__eq(method_name, _SLIT("first")) || string__eq(method_name, _SLIT("last")) || string__eq(method_name, _SLIT("pop")))) {
		if ((final_left_sym->info)._typ == 441 /* v.ast.Array */) {
			node->return_type = (*final_left_sym->info._v__ast__Array).elem_type;
			v__ast__Type _t16 = node->return_type;
			return _t16;
		}
	} else if (v__pref__Backend_is_js(c->pref->backend) && string_starts_with(left_sym->name, _SLIT("Promise<")) && string__eq(method_name, _SLIT("wait"))) {
		v__ast__Struct info = /* as */ *(v__ast__Struct*)__as_cast((left_sym->info)._v__ast__Struct,(left_sym->info)._typ, 446) /*expected idx: 446, name: v.ast.Struct */ ;
		if (node->args.len > 0) {
			v__checker__Checker_error(c, _SLIT("wait() does not have any arguments"), (*(v__ast__CallArg*)/*ee elem_typ */array_get(node->args, 0)).pos);
		}
		c->table->cur_fn->has_await = true;
		node->return_type = (*(v__ast__Type*)/*ee elem_typ */array_get(info.concrete_types, 0));
		v__ast__Type_set_flag(node->return_type, v__ast__TypeFlag__optional);
		v__ast__Type _t17 = node->return_type;
		return _t17;
	} else if (left_sym->kind == v__ast__Kind__thread && string__eq(method_name, _SLIT("wait"))) {
		v__ast__Thread info = /* as */ *(v__ast__Thread*)__as_cast((left_sym->info)._v__ast__Thread,(left_sym->info)._typ, 470) /*expected idx: 470, name: v.ast.Thread */ ;
		if (node->args.len > 0) {
			v__checker__Checker_error(c, _SLIT("wait() does not have any arguments"), (*(v__ast__CallArg*)/*ee elem_typ */array_get(node->args, 0)).pos);
		}
		node->return_type = info.return_type;
		v__ast__Type _t18 = info.return_type;
		return _t18;
	} else if (left_sym->kind == v__ast__Kind__char && v__ast__Type_nr_muls(left_type) == 0 && string__eq(method_name, _SLIT("str"))) {
		v__checker__Checker_error(c, _SLIT("calling `.str()` on type `char` is not allowed, use its address or cast it to an integer instead"), v__token__Position_extend(v__ast__Expr_position(node->left), node->pos));
		v__ast__Type _t19 = _const_v__ast__void_type;
		return _t19;
	}
	v__ast__Fn method = (v__ast__Fn){.is_variadic = 0,.language = 0,.is_pub = 0,.is_ctor_new = 0,.is_deprecated = 0,.is_noreturn = 0,.is_unsafe = 0,.is_placeholder = 0,.is_main = 0,.is_test = 0,.is_keep_alive = 0,.is_method = 0,.no_body = 0,.mod = (string){.str=(byteptr)"", .is_lit=1},.file = (string){.str=(byteptr)"", .is_lit=1},.file_mode = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.return_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.return_type = 0,.receiver_type = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.params = __new_array(0, 0, sizeof(v__ast__Param)),.source_fn = 0,.usages = 0,.generic_names = __new_array(0, 0, sizeof(string)),.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_conditional = 0,.ctdefine_idx = 0,};
	bool has_method = false;
	bool is_method_from_embed = false;
	Option_v__ast__Fn _t20;
	if (_t20 = v__ast__Table_find_method(c->table, left_sym, method_name), _t20.state == 0) {
		v__ast__Fn m = *(v__ast__Fn*)_t20.data;
		method = m;
		has_method = true;
	} else {
		IError err = _t20.err;
		if (left_sym->kind == v__ast__Kind__struct_ || left_sym->kind == v__ast__Kind__sum_type || left_sym->kind == v__ast__Kind__interface_) {
			v__ast__Type parent_type = _const_v__ast__void_type;
			if ((left_sym->info)._typ == 446 /* v.ast.Struct */) {
				parent_type = (*left_sym->info._v__ast__Struct).parent_type;
			} else if ((left_sym->info)._typ == 464 /* v.ast.SumType */) {
				parent_type = (*left_sym->info._v__ast__SumType).parent_type;
			} else if ((left_sym->info)._typ == 463 /* v.ast.Interface */) {
				parent_type = (*left_sym->info._v__ast__Interface).parent_type;
			}
			if (parent_type != 0) {
				v__ast__TypeSymbol* type_sym = v__ast__Table_sym(c->table, parent_type);
				Option_v__ast__Fn _t21;
				if (_t21 = v__ast__Table_find_method(c->table, type_sym, method_name), _t21.state == 0) {
					v__ast__Fn m = *(v__ast__Fn*)_t21.data;
					method = m;
					has_method = true;
					is_generic = true;
				}
			}
		}
		if (!has_method) {
			has_method = true;
			Array_v__ast__Type embed_types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
			Option_multi_return_v__ast__Fn_Array_v__ast__Type _t22 = v__ast__Table_find_method_from_embeds(c->table, left_sym, method_name);
			if (_t22.state != 0) { /*or block*/ 
				IError err = _t22.err;
				if (((*(err.msg))).len != 0) {
					v__checker__Checker_error(c, (*(err.msg)), node->pos);
				}
				has_method = false;
				*(multi_return_v__ast__Fn_Array_v__ast__Type*) _t22.data = (multi_return_v__ast__Fn_Array_v__ast__Type){.arg0=(v__ast__Fn){.is_variadic = 0,.language = 0,.is_pub = 0,.is_ctor_new = 0,.is_deprecated = 0,.is_noreturn = 0,.is_unsafe = 0,.is_placeholder = 0,.is_main = 0,.is_test = 0,.is_keep_alive = 0,.is_method = 0,.no_body = 0,.mod = (string){.str=(byteptr)"", .is_lit=1},.file = (string){.str=(byteptr)"", .is_lit=1},.file_mode = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.return_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.return_type = 0,.receiver_type = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.params = __new_array(0, 0, sizeof(v__ast__Param)),.source_fn = 0,.usages = 0,.generic_names = __new_array(0, 0, sizeof(string)),.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_conditional = 0,.ctdefine_idx = 0,},.arg1=__new_array_with_default(0, 0, sizeof(v__ast__Type), 0)};
			}
			
 			Option_multi_return_v__ast__Fn_Array_v__ast__Type mr_39463 =  _t22 /*U*/;
			method = (*(multi_return_v__ast__Fn_Array_v__ast__Type*)mr_39463.data).arg0;
			embed_types = (*(multi_return_v__ast__Fn_Array_v__ast__Type*)mr_39463.data).arg1;
			if (embed_types.len != 0) {
				is_method_from_embed = true;
				node->from_embed_types = embed_types;
			}
		}
		if (left_sym->kind == v__ast__Kind__aggregate) {
			unknown_method_msg = (*(err.msg));
		}
	}
	if (has_method) {
		node->is_noreturn = method.is_noreturn;
		node->is_ctor_new = method.is_ctor_new;
		if (!method.is_pub && !c->pref->is_test && !string__eq(method.mod, c->mod)) {
			v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("method `"), 0xfe10, {.d_s = left_sym->name}}, {_SLIT("."), 0xfe10, {.d_s = method_name}}, {_SLIT("` is private"), 0, { .d_c = 0 }}})), node->pos);
		}
		v__ast__ShareType rec_share = v__ast__Type_share((*(v__ast__Param*)/*ee elem_typ */array_get(method.params, 0)).typ);
		if (rec_share == v__ast__ShareType__shared_t && (c->locked_names.len > 0 || c->rlocked_names.len > 0)) {
			v__checker__Checker_error(c, _SLIT("method with `shared` receiver cannot be called inside `lock`/`rlock` block"), node->pos);
		}
		if ((*(v__ast__Param*)/*ee elem_typ */array_get(method.params, 0)).is_mut) {
			multi_return_string_v__token__Position mr_40588 = v__checker__Checker_fail_if_immutable(c, node->left);
			string to_lock = mr_40588.arg0;
			v__token__Position pos = mr_40588.arg1;
			if (!v__ast__Expr_is_lvalue(node->left)) {
				v__checker__Checker_error(c, _SLIT("cannot pass expression as `mut`"), v__ast__Expr_position(node->left));
			}
			if ((to_lock).len != 0 && rec_share != v__ast__ShareType__shared_t) {
				v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = to_lock}}, {_SLIT(" is `shared` and must be `lock`ed to be passed as `mut`"), 0, { .d_c = 0 }}})), pos);
			}
		} else {
			v__checker__Checker_fail_if_unreadable(c, node->left, left_type, _SLIT("receiver"));
		}
		if (left_sym->language != v__ast__Language__js && (!v__ast__TypeSymbol_is_builtin(left_sym) && !string__eq(method.mod, _SLIT("builtin"))) && method.language == v__ast__Language__v && method.no_body) {
			v__checker__Checker_error(c, _SLIT("cannot call a method that does not have a body"), node->pos);
		}
		if (v__ast__Type_alias_eq(method.return_type, _const_v__ast__void_type) && method.is_conditional && method.ctdefine_idx != -1) {
			node->should_be_skipped = v__checker__Checker_evaluate_once_comptime_if_attribute(c, (voidptr)&/*qq*/(*(v__ast__Attr*)/*ee elem_typ */array_get(method.attrs, method.ctdefine_idx)));
		}
		Option_void _t23 = v__checker__Checker_check_expected_arg_count(c, node, (voidptr)&/*qq*/method);
		if (_t23.state != 0 && _t23.err._typ != _IError_None___index) {
			IError err = _t23.err;
			v__ast__Type _t24 = method.return_type;
			return _t24;
		}
		
 ;
		v__ast__Type exp_arg_typ = ((v__ast__Type)(0));
		bool param_is_mut = false;
		bool no_type_promotion = false;
		if (left_sym->kind == v__ast__Kind__chan) {
			v__ast__Type elem_typ = (/* as */ *(v__ast__Chan*)__as_cast((left_sym->info)._v__ast__Chan,(left_sym->info)._typ, 469) /*expected idx: 469, name: v.ast.Chan */ ).elem_type;
			if (string__eq(method_name, _SLIT("try_push"))) {
				exp_arg_typ = v__ast__Type_ref(elem_typ);
			} else if (string__eq(method_name, _SLIT("try_pop"))) {
				exp_arg_typ = elem_typ;
				param_is_mut = true;
				no_type_promotion = true;
			}
		}
		for (int i = 0; i < node->args.len; ++i) {
			v__ast__CallArg* arg = ((v__ast__CallArg*)node->args.data) + i;
			if (i > 0 || v__ast__Type_alias_eq(exp_arg_typ, ((v__ast__Type)(0)))) {
				exp_arg_typ = (method.is_variadic && i >= method.params.len - 1 ? ((*(v__ast__Param*)/*ee elem_typ */array_get(method.params, method.params.len - 1)).typ) : ((*(v__ast__Param*)/*ee elem_typ */array_get(method.params, i + 1)).typ));
				param_is_mut = false;
				no_type_promotion = false;
			}
			v__ast__TypeSymbol* exp_arg_sym = v__ast__Table_sym(c->table, exp_arg_typ);
			c->expected_type = exp_arg_typ;
			v__ast__Type got_arg_typ = v__checker__Checker_check_expr_opt_call(c, arg->expr, v__checker__Checker_expr(c, arg->expr));
			(*(v__ast__CallArg*)/*ee elem_typ */array_get(node->args, i)).typ = got_arg_typ;
			if (no_type_promotion) {
				if (!v__ast__Type_alias_eq(got_arg_typ, exp_arg_typ)) {
					v__checker__Checker_error(c,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("cannot use `"), 0xfe10, {.d_s = v__ast__Table_sym(c->table, got_arg_typ)->name}}, {_SLIT("` as argument for `"), 0xfe10, {.d_s = method.name}}, {_SLIT("` (`"), 0xfe10, {.d_s = exp_arg_sym->name}}, {_SLIT("` expected)"), 0, { .d_c = 0 }}})), arg->pos);
				}
			}
			if (method.is_variadic && v__ast__Type_has_flag(got_arg_typ, v__ast__TypeFlag__variadic) && node->args.len - 1 > i) {
				v__checker__Checker_error(c, _SLIT("when forwarding a variadic variable, it must be the final argument"), arg->pos);
			}
			v__ast__TypeSymbol* final_arg_sym = exp_arg_sym;
			v__ast__Type final_arg_typ = exp_arg_typ;
			if (method.is_variadic && (exp_arg_sym->info)._typ == 441 /* v.ast.Array */) {
				final_arg_typ = v__ast__TypeSymbol_array_info(exp_arg_sym).elem_type;
				final_arg_sym = v__ast__Table_sym(c->table, final_arg_typ);
			}
			if (final_arg_sym->kind == v__ast__Kind__interface_) {
				if (v__checker__Checker_type_implements(c, got_arg_typ, final_arg_typ, v__ast__Expr_position(arg->expr))) {
					if (!v__ast__Type_is_ptr(got_arg_typ) && !v__ast__Type_is_pointer(got_arg_typ) && !c->inside_unsafe) {
						v__ast__TypeSymbol* got_arg_typ_sym = v__ast__Table_sym(c->table, got_arg_typ);
						if (got_arg_typ_sym->kind != v__ast__Kind__interface_) {
							v__checker__Checker_mark_as_referenced(c, &arg->expr, true);
						}
					}
				}
				continue;
			}
			if (v__ast__Type_has_flag(exp_arg_typ, v__ast__TypeFlag__generic)) {
				continue;
			}
			Option_void _t25 = v__checker__Checker_check_expected_call_arg(c, got_arg_typ, v__checker__Checker_unwrap_generic(c, exp_arg_typ), node->language, *arg);
			if (_t25.state != 0 && _t25.err._typ != _IError_None___index) {
				IError err = _t25.err;
				if (!v__ast__Type_alias_eq(got_arg_typ, _const_v__ast__void_type)) {
					v__checker__Checker_error(c,  str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = (*(err.msg))}}, {_SLIT(" in argument "), 0xfe07, {.d_i32 = i + 1}}, {_SLIT(" to `"), 0xfe10, {.d_s = left_sym->name}}, {_SLIT("."), 0xfe10, {.d_s = method_name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), arg->pos);
				}
			;
			}
			
 ;
			v__ast__Param param = (method.is_variadic && i >= method.params.len - 1 ? ((*(v__ast__Param*)/*ee elem_typ */array_get(method.params, method.params.len - 1))) : ((*(v__ast__Param*)/*ee elem_typ */array_get(method.params, i + 1))));
			param_is_mut = param_is_mut || param.is_mut;
			v__ast__ShareType param_share = v__ast__Type_share(param.typ);
			if (param_share == v__ast__ShareType__shared_t && (c->locked_names.len > 0 || c->rlocked_names.len > 0)) {
				v__checker__Checker_error(c, _SLIT("method with `shared` arguments cannot be called inside `lock`/`rlock` block"), arg->pos);
			}
			if (arg->is_mut) {
				multi_return_string_v__token__Position mr_44648 = v__checker__Checker_fail_if_immutable(c, arg->expr);
				string to_lock = mr_44648.arg0;
				v__token__Position pos = mr_44648.arg1;
				if (!param_is_mut) {
					string tok = v__ast__ShareType_str(arg->share);
					v__checker__Checker_error(c,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = node->name}}, {_SLIT("` parameter `"), 0xfe10, {.d_s = param.name}}, {_SLIT("` is not `"), 0xfe10, {.d_s = tok}}, {_SLIT("`, `"), 0xfe10, {.d_s = tok}}, {_SLIT("` is not needed`"), 0, { .d_c = 0 }}})), v__ast__Expr_position(arg->expr));
				} else {
					if (param_share != arg->share) {
						v__checker__Checker_error(c, _SLIT("wrong shared type"), v__ast__Expr_position(arg->expr));
					}
					if ((to_lock).len != 0 && param_share != v__ast__ShareType__shared_t) {
						v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = to_lock}}, {_SLIT(" is `shared` and must be `lock`ed to be passed as `mut`"), 0, { .d_c = 0 }}})), pos);
					}
				}
			} else {
				if (param_is_mut) {
					string tok = v__ast__ShareType_str(arg->share);
					v__checker__Checker_error(c,  str_intp(7, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = node->name}}, {_SLIT("` parameter `"), 0xfe10, {.d_s = param.name}}, {_SLIT("` is `"), 0xfe10, {.d_s = tok}}, {_SLIT("`, you need to provide `"), 0xfe10, {.d_s = tok}}, {_SLIT("` e.g. `"), 0xfe10, {.d_s = tok}}, {_SLIT(" arg"), 0xfe07, {.d_i32 = i + 1}}, {_SLIT("`"), 0, { .d_c = 0 }}})), v__ast__Expr_position(arg->expr));
				} else {
					v__checker__Checker_fail_if_unreadable(c, arg->expr, got_arg_typ, _SLIT("argument"));
				}
			}
		}
		if (method.is_unsafe && !c->inside_unsafe) {
			v__checker__Checker_warn(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("method `"), 0xfe10, {.d_s = left_sym->name}}, {_SLIT("."), 0xfe10, {.d_s = method_name}}, {_SLIT("` must be called from an `unsafe` block"), 0, { .d_c = 0 }}})), node->pos);
		}
		if (!c->table->cur_fn->is_deprecated && method.is_deprecated) {
			v__checker__Checker_deprecate_fnmethod(c, _SLIT("method"),  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = left_sym->name}}, {_SLIT("."), 0xfe10, {.d_s = method.name}}, {_SLIT0, 0, { .d_c = 0 }}})), method, *node);
		}
		if (node->expected_arg_types.len == 0) {
			for (int i = 1; i < method.params.len; ++i) {
				array_push((array*)&node->expected_arg_types, _MOV((v__ast__Type[]){ (*(v__ast__Param*)/*ee elem_typ */array_get(method.params, i)).typ }));
			}
		}
		if (is_method_from_embed) {
			node->receiver_type = v__ast__Type_derive((*(v__ast__Type*)array_last(node->from_embed_types)), (*(v__ast__Param*)/*ee elem_typ */array_get(method.params, 0)).typ);
		} else if (is_generic) {
			node->receiver_type = v__ast__Type_set_flag(v__ast__Type_derive(left_type, (*(v__ast__Param*)/*ee elem_typ */array_get(method.params, 0)).typ), v__ast__TypeFlag__generic);
		} else {
			node->receiver_type = (*(v__ast__Param*)/*ee elem_typ */array_get(method.params, 0)).typ;
		}
		if (method.generic_names.len != node->concrete_types.len) {
			v__checker__Checker_infer_fn_generic_types(c, method, node);
			concrete_types = node->concrete_types;
		} else {
			if (node->concrete_types.len > 0 && !v__ast__Type_has_flag((*(v__ast__Type*)/*ee elem_typ */array_get(node->concrete_types, 0)), v__ast__TypeFlag__generic)) {
				v__ast__Table_register_fn_concrete_types(c->table, v__ast__Fn_fkey(&method), node->concrete_types);
			}
		}
		if (method.generic_names.len > 0 && v__ast__Type_has_flag(method.return_type, v__ast__TypeFlag__generic) && c->table->cur_fn->generic_names.len == 0) {
			node->return_type = v__ast__Table_unwrap_generic_type(c->table, method.return_type, method.generic_names, concrete_types);
		} else {
			node->return_type = method.return_type;
		}
		if (node->concrete_types.len > 0 && method.return_type != 0 && c->table->cur_fn->generic_names.len == 0) {
			Option_v__ast__Type _t27;
			if (_t27 = v__ast__Table_resolve_generic_to_concrete(c->table, method.return_type, method.generic_names, concrete_types), _t27.state == 0) {
				v__ast__Type typ = *(v__ast__Type*)_t27.data;
				node->return_type = typ;
				v__ast__Type _t28 = typ;
				return _t28;
			}
		}
		if (node->concrete_types.len > 0 && method.generic_names.len == 0) {
			v__checker__Checker_error(c, _SLIT("a non generic function called like a generic one"), node->concrete_list_pos);
		}
		if (node->concrete_types.len > method.generic_names.len) {
			v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("too many generic parameters got "), 0xfe07, {.d_i32 = node->concrete_types.len}}, {_SLIT(", expected "), 0xfe07, {.d_i32 = method.generic_names.len}}, {_SLIT0, 0, { .d_c = 0 }}})), node->concrete_list_pos);
		}
		if (method.generic_names.len > 0) {
			v__ast__Type _t29 = node->return_type;
			return _t29;
		}
		v__ast__Type _t30 = method.return_type;
		return _t30;
	}
	if (string__eq(method_name, _SLIT("str"))) {
		if (left_sym->kind == v__ast__Kind__interface_) {
			string iname = left_sym->name;
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("interface `"), 0xfe10, {.d_s = iname}}, {_SLIT("` does not have a .str() method. Use typeof() instead"), 0, { .d_c = 0 }}})), node->pos);
		}
		node->receiver_type = left_type;
		node->return_type = _const_v__ast__string_type;
		if (node->args.len > 0) {
			v__checker__Checker_error(c, _SLIT(".str() method calls should have no arguments"), node->pos);
		}
		v__checker__Checker_fail_if_unreadable(c, node->left, left_type, _SLIT("receiver"));
		v__ast__Type _t31 = _const_v__ast__string_type;
		return _t31;
	} else if (string__eq(method_name, _SLIT("free"))) {
		v__ast__Type _t32 = _const_v__ast__void_type;
		return _t32;
	}
	Option_v__ast__StructField _t33;
	if (_t33 = v__ast__Table_find_field(c->table, left_sym, method_name), _t33.state == 0) {
		v__ast__StructField field = *(v__ast__StructField*)_t33.data;
		v__ast__TypeSymbol* field_sym = v__ast__Table_sym(c->table, v__checker__Checker_unwrap_generic(c, field.typ));
		if (field_sym->kind == v__ast__Kind__function) {
			node->is_method = false;
			node->is_field = true;
			v__ast__FnType info = /* as */ *(v__ast__FnType*)__as_cast((field_sym->info)._v__ast__FnType,(field_sym->info)._typ, 472) /*expected idx: 472, name: v.ast.FnType */ ;
			Option_void _t34 = v__checker__Checker_check_expected_arg_count(c, node, (voidptr)&/*qq*/info.func);
			if (_t34.state != 0 && _t34.err._typ != _IError_None___index) {
				IError err = _t34.err;
				v__ast__Type _t35 = info.func.return_type;
				return _t35;
			}
			
 ;
			node->return_type = info.func.return_type;
			Array_v__ast__Type earg_types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
			for (int i = 0; i < node->args.len; ++i) {
				v__ast__CallArg* arg = ((v__ast__CallArg*)node->args.data) + i;
				v__ast__Type targ = v__checker__Checker_check_expr_opt_call(c, arg->expr, v__checker__Checker_expr(c, arg->expr));
				arg->typ = targ;
				array_push((array*)&earg_types, _MOV((v__ast__Type[]){ targ }));
				if (i < info.func.params.len) {
					v__ast__Type exp_arg_typ = (*(v__ast__Param*)/*ee elem_typ */array_get(info.func.params, i)).typ;
					Option_void _t37 = v__checker__Checker_check_expected_call_arg(c, targ, v__checker__Checker_unwrap_generic(c, exp_arg_typ), node->language, *arg);
					if (_t37.state != 0 && _t37.err._typ != _IError_None___index) {
						IError err = _t37.err;
						if (!v__ast__Type_alias_eq(targ, _const_v__ast__void_type)) {
							v__checker__Checker_error(c,  str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = (*(err.msg))}}, {_SLIT(" in argument "), 0xfe07, {.d_i32 = i + 1}}, {_SLIT(" to `"), 0xfe10, {.d_s = left_sym->name}}, {_SLIT("."), 0xfe10, {.d_s = method_name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), arg->pos);
						}
					;
					}
					
 ;
				}
			}
			node->expected_arg_types = earg_types;
			node->is_method = true;
			v__ast__Type _t38 = info.func.return_type;
			return _t38;
		}
	}
	if (!v__ast__Type_alias_eq(left_type, _const_v__ast__void_type)) {
		Array_string _t39 = __new_array(0, 0, sizeof(string));
		Array_v__ast__Fn _t39_orig = left_sym->methods;
		int _t39_len = _t39_orig.len;
		_t39 = __new_array(0, _t39_len, sizeof(string));

		for (int _t40 = 0; _t40 < _t39_len; ++_t40) {
			v__ast__Fn it = ((v__ast__Fn*) _t39_orig.data)[_t40];
			string ti = it.name;
			array_push((array*)&_t39, &ti);
		}
		v__util__Suggestion suggestion = v__util__new_suggestion(method_name,_t39);
		v__checker__Checker_error(c, v__util__Suggestion_say(suggestion, unknown_method_msg), node->pos);
	}
	v__ast__Type _t41 = _const_v__ast__void_type;
	return _t41;
}

VV_LOCAL_SYMBOL void v__checker__Checker_deprecate_fnmethod(v__checker__Checker* c, string kind, string name, v__ast__Fn the_fn, v__ast__CallExpr node) {
	string start_message =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = kind}}, {_SLIT(" `"), 0xfe10, {.d_s = name}}, {_SLIT("`"), 0, { .d_c = 0 }}}));
	string deprecation_message = _SLIT("");
	time__Time now = time__now();
	time__Time after_time = now;
	for (int _t1 = 0; _t1 < the_fn.attrs.len; ++_t1) {
		v__ast__Attr attr = ((v__ast__Attr*)the_fn.attrs.data)[_t1];
		if (string__eq(attr.name, _SLIT("deprecated")) && (attr.arg).len != 0) {
			deprecation_message = attr.arg;
		}
		if (string__eq(attr.name, _SLIT("deprecated_after")) && (attr.arg).len != 0) {
			Option_time__Time _t2 = time__parse_iso8601(attr.arg);
			if (_t2.state != 0) { /*or block*/ 
				IError err = _t2.err;
				v__checker__Checker_error(c, _SLIT("invalid time format"), attr.pos);
				*(time__Time*) _t2.data = time__now();
			}
			
 			after_time =  (*(time__Time*)_t2.data);
		}
	}
	time__Time error_time = time__Time_add_days(after_time, 180);
	if (time__Time__lt(error_time, now)) {
		v__checker__Checker_error(c, v__checker__semicolonize( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = start_message}}, {_SLIT(" has been deprecated since "), 0xfe10, {.d_s = time__Time_ymmdd(after_time)}}, {_SLIT0, 0, { .d_c = 0 }}})), deprecation_message), node.pos);
	} else if (time__Time__lt(after_time, now)) {
		v__checker__Checker_warn(c, v__checker__semicolonize( str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = start_message}}, {_SLIT(" has been deprecated since "), 0xfe10, {.d_s = time__Time_ymmdd(after_time)}}, {_SLIT(", it will be an error after "), 0xfe10, {.d_s = time__Time_ymmdd(error_time)}}, {_SLIT0, 0, { .d_c = 0 }}})), deprecation_message), node.pos);
	} else if (time__Time__eq(after_time, now)) {
		v__checker__Checker_warn(c, v__checker__semicolonize( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = start_message}}, {_SLIT(" has been deprecated"), 0, { .d_c = 0 }}})), deprecation_message), node.pos);
	} else {
		v__checker__Checker_note(c, v__checker__semicolonize( str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = start_message}}, {_SLIT(" will be deprecated after "), 0xfe10, {.d_s = time__Time_ymmdd(after_time)}}, {_SLIT(", and will become an error after "), 0xfe10, {.d_s = time__Time_ymmdd(error_time)}}, {_SLIT0, 0, { .d_c = 0 }}})), deprecation_message), node.pos);
	}
}

VV_LOCAL_SYMBOL string v__checker__semicolonize(string main, string details) {
	if ((details).len == 0) {
		string _t1 = main;
		return _t1;
	}
	string _t2 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = main}}, {_SLIT("; "), 0xfe10, {.d_s = details}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t2;
}

VV_LOCAL_SYMBOL void v__checker__Checker_post_process_generic_fns(v__checker__Checker* c) {
	for (int i = 0; i < c->file->generic_fns.len; ++i) {
		v__ast__FnDecl* node = (*(v__ast__FnDecl**)/*ee elem_typ */array_get(c->file->generic_fns, i));
		c->mod = node->mod;
		string fkey = v__ast__FnDecl_fkey(node);
		Array_Array_v__ast__Type gtypes = (*(Array_Array_v__ast__Type*)map_get(ADDR(map, c->table->fn_generic_types), &(string[]){fkey}, &(Array_Array_v__ast__Type[]){ __new_array(0, 0, sizeof(Array_v__ast__Type)) }));
		for (int _t1 = 0; _t1 < gtypes.len; ++_t1) {
			Array_v__ast__Type concrete_types = ((Array_v__ast__Type*)gtypes.data)[_t1];
			c->table->cur_concrete_types = concrete_types;
			v__checker__Checker_fn_decl(c, node);
			if (string__eq(node->name, _SLIT("vweb.run"))) {
				for (int _t2 = 0; _t2 < concrete_types.len; ++_t2) {
					v__ast__Type ct = ((v__ast__Type*)concrete_types.data)[_t2];
					if (!Array_v__ast__Type_contains(c->vweb_gen_types, ct)) {
						array_push((array*)&c->vweb_gen_types, _MOV((v__ast__Type[]){ ct }));
					}
				}
			}
		}
		c->table->cur_concrete_types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
	}
}

Option_void v__checker__Checker_check_expected_arg_count(v__checker__Checker* c, v__ast__CallExpr* node, v__ast__Fn* f) {
	int nr_args = node->args.len;
	int nr_params = (node->is_method && f->params.len > 0 ? (f->params.len - 1) : (f->params.len));
	int min_required_params = f->params.len;
	if (node->is_method) {
		min_required_params--;
	}
	if (f->is_variadic) {
		min_required_params--;
	}
	if (min_required_params < 0) {
		min_required_params = 0;
	}
	if (nr_args < min_required_params) {
		if (min_required_params == nr_args + 1) {
			v__ast__Type last_typ = (*(v__ast__Param*)array_last(f->params)).typ;
			v__ast__TypeSymbol* last_sym = v__ast__Table_sym(c->table, last_typ);
			if ((last_sym->info)._typ == 446 /* v.ast.Struct */) {
				Array_v__ast__Attr _t1 = __new_array(0, 0, sizeof(v__ast__Attr));
				Array_v__ast__Attr _t1_orig = (*last_sym->info._v__ast__Struct).attrs;
				int _t1_len = _t1_orig.len;
				_t1 = __new_array(0, _t1_len, sizeof(v__ast__Attr));

				for (int _t2 = 0; _t2 < _t1_len; ++_t2) {
					v__ast__Attr it = ((v__ast__Attr*) _t1_orig.data)[_t2];
					if (string__eq(it.name, _SLIT("params")) && !it.has_arg) {
						array_push((array*)&_t1, &it);
					}
				}
				bool is_params =_t1.len > 0;
				if (is_params) {
					array_push((array*)&node->args, _MOV((v__ast__CallArg[]){ (v__ast__CallArg){.is_mut = 0,.share = 0,.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.expr = v__ast__StructInit_to_sumtype_v__ast__Expr(ADDR(v__ast__StructInit, ((v__ast__StructInit){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.name_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.is_short = 0,.unresolved = 0,.pre_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.typ = last_typ,.update_expr = {0},.update_expr_type = 0,.update_expr_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.has_update_expr = 0,.fields = __new_array(0, 0, sizeof(v__ast__StructInitField)),.embeds = __new_array(0, 0, sizeof(v__ast__StructInitEmbed)),}))),.typ = 0,.is_tmp_autofree = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},} }));
					return (Option_void){0};
				}
			}
		}
		v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("expected "), 0xfe07, {.d_i32 = min_required_params}}, {_SLIT(" arguments, but got "), 0xfe07, {.d_i32 = nr_args}}, {_SLIT0, 0, { .d_c = 0 }}})), node->pos);
		return (Option_void){ .state=2, .err=_v_error(_SLIT("")), .data={EMPTY_STRUCT_INITIALIZATION} };
	} else if (!f->is_variadic && nr_args > nr_params) {
		v__token__Position unexpected_args_pos = v__token__Position_extend((*(v__ast__CallArg*)/*ee elem_typ */array_get(node->args, min_required_params)).pos, (*(v__ast__CallArg*)array_last(node->args)).pos);
		v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("expected "), 0xfe07, {.d_i32 = min_required_params}}, {_SLIT(" arguments, but got "), 0xfe07, {.d_i32 = nr_args}}, {_SLIT0, 0, { .d_c = 0 }}})), unexpected_args_pos);
		return (Option_void){ .state=2, .err=_v_error(_SLIT("")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (Option_void){0};
}

VV_LOCAL_SYMBOL void v__checker__Checker_check_map_and_filter(v__checker__Checker* c, bool is_map, v__ast__Type elem_typ, v__ast__CallExpr node) {
	if (node.args.len != 1) {
		v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("expected 1 argument, but got "), 0xfe07, {.d_i32 = node.args.len}}, {_SLIT0, 0, { .d_c = 0 }}})), node.pos);
		return;
	}
	v__ast__TypeSymbol* elem_sym = v__ast__Table_sym(c->table, elem_typ);
	v__ast__Expr arg_expr = (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr;
	if (arg_expr._typ == 278 /* v.ast.AnonFn */) {
		if ((*arg_expr._v__ast__AnonFn).decl.params.len > 1) {
			v__checker__Checker_error(c, _SLIT("function needs exactly 1 argument"), (*arg_expr._v__ast__AnonFn).decl.pos);
		} else if (is_map && (v__ast__Type_alias_eq((*arg_expr._v__ast__AnonFn).decl.return_type, _const_v__ast__void_type) || !v__ast__Type_alias_eq((*(v__ast__Param*)/*ee elem_typ */array_get((*arg_expr._v__ast__AnonFn).decl.params, 0)).typ, elem_typ))) {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("type mismatch, should use `fn(a "), 0xfe10, {.d_s = elem_sym->name}}, {_SLIT(") T {...}`"), 0, { .d_c = 0 }}})), (*arg_expr._v__ast__AnonFn).decl.pos);
		} else if (!is_map && (!v__ast__Type_alias_eq((*arg_expr._v__ast__AnonFn).decl.return_type, _const_v__ast__bool_type) || !v__ast__Type_alias_eq((*(v__ast__Param*)/*ee elem_typ */array_get((*arg_expr._v__ast__AnonFn).decl.params, 0)).typ, elem_typ))) {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("type mismatch, should use `fn(a "), 0xfe10, {.d_s = elem_sym->name}}, {_SLIT(") bool {...}`"), 0, { .d_c = 0 }}})), (*arg_expr._v__ast__AnonFn).decl.pos);
		}
	}
	else if (arg_expr._typ == 299 /* v.ast.Ident */) {
		if ((*arg_expr._v__ast__Ident).kind == v__ast__IdentKind__function) {
			Option_v__ast__Fn _t1 = v__ast__Table_find_fn(c->table, (*arg_expr._v__ast__Ident).name);
			if (_t1.state != 0) { /*or block*/ 
				IError err = _t1.err;
				v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = (*arg_expr._v__ast__Ident).name}}, {_SLIT(" does not exist"), 0, { .d_c = 0 }}})), (*arg_expr._v__ast__Ident).pos);
				return;
			}
			
 			v__ast__Fn func =  (*(v__ast__Fn*)_t1.data);
			if (func.params.len > 1) {
				v__checker__Checker_error(c, _SLIT("function needs exactly 1 argument"), node.pos);
			} else if (is_map && (v__ast__Type_alias_eq(func.return_type, _const_v__ast__void_type) || !v__ast__Type_alias_eq((*(v__ast__Param*)/*ee elem_typ */array_get(func.params, 0)).typ, elem_typ))) {
				v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("type mismatch, should use `fn(a "), 0xfe10, {.d_s = elem_sym->name}}, {_SLIT(") T {...}`"), 0, { .d_c = 0 }}})), (*arg_expr._v__ast__Ident).pos);
			} else if (!is_map && (!v__ast__Type_alias_eq(func.return_type, _const_v__ast__bool_type) || !v__ast__Type_alias_eq((*(v__ast__Param*)/*ee elem_typ */array_get(func.params, 0)).typ, elem_typ))) {
				v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("type mismatch, should use `fn(a "), 0xfe10, {.d_s = elem_sym->name}}, {_SLIT(") bool {...}`"), 0, { .d_c = 0 }}})), (*arg_expr._v__ast__Ident).pos);
			}
		} else if ((*arg_expr._v__ast__Ident).kind == v__ast__IdentKind__variable) {
			if (((*arg_expr._v__ast__Ident).obj)._typ == 357 /* v.ast.Var */) {
				v__ast__Expr expr = (*(*arg_expr._v__ast__Ident).obj._v__ast__Var).expr;
				if ((expr)._typ == 278 /* v.ast.AnonFn */) {
					if ((*expr._v__ast__AnonFn).decl.params.len > 1) {
						v__checker__Checker_error(c, _SLIT("function needs exactly 1 argument"), (*expr._v__ast__AnonFn).decl.pos);
					} else if (is_map && (v__ast__Type_alias_eq((*expr._v__ast__AnonFn).decl.return_type, _const_v__ast__void_type) || !v__ast__Type_alias_eq((*(v__ast__Param*)/*ee elem_typ */array_get((*expr._v__ast__AnonFn).decl.params, 0)).typ, elem_typ))) {
						v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("type mismatch, should use `fn(a "), 0xfe10, {.d_s = elem_sym->name}}, {_SLIT(") T {...}`"), 0, { .d_c = 0 }}})), (*expr._v__ast__AnonFn).decl.pos);
					} else if (!is_map && (!v__ast__Type_alias_eq((*expr._v__ast__AnonFn).decl.return_type, _const_v__ast__bool_type) || !v__ast__Type_alias_eq((*(v__ast__Param*)/*ee elem_typ */array_get((*expr._v__ast__AnonFn).decl.params, 0)).typ, elem_typ))) {
						v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("type mismatch, should use `fn(a "), 0xfe10, {.d_s = elem_sym->name}}, {_SLIT(") bool {...}`"), 0, { .d_c = 0 }}})), (*expr._v__ast__AnonFn).decl.pos);
					}
					return;
				}
			}
			if (!is_map && !v__ast__Type_alias_eq(v__ast__Ident_var_info(&(*arg_expr._v__ast__Ident)).typ, _const_v__ast__bool_type)) {
				v__checker__Checker_error(c, _SLIT("type mismatch, should be bool"), (*arg_expr._v__ast__Ident).pos);
			}
		}
	}
	else if (arg_expr._typ == 286 /* v.ast.CallExpr */) {
		if (is_map && ((*arg_expr._v__ast__CallExpr).return_type == _const_v__ast__void_type || (*arg_expr._v__ast__CallExpr).return_type == 0)) {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("type mismatch, `"), 0xfe10, {.d_s = (*arg_expr._v__ast__CallExpr).name}}, {_SLIT("` does not return anything"), 0, { .d_c = 0 }}})), (*arg_expr._v__ast__CallExpr).pos);
		} else if (!is_map && !v__ast__Type_alias_eq((*arg_expr._v__ast__CallExpr).return_type, _const_v__ast__bool_type)) {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("type mismatch, `"), 0xfe10, {.d_s = (*arg_expr._v__ast__CallExpr).name}}, {_SLIT("` must return a bool"), 0, { .d_c = 0 }}})), (*arg_expr._v__ast__CallExpr).pos);
		}
	}
	
	else {
	}
	;
}

VV_LOCAL_SYMBOL v__ast__Type v__checker__Checker_map_builtin_method_call(v__checker__Checker* c, v__ast__CallExpr* node, v__ast__Type left_type, v__ast__TypeSymbol left_sym) {
	string method_name = node->name;
	v__ast__Type ret_type = _const_v__ast__void_type;

	if (string__eq(method_name, _SLIT("clone")) || string__eq(method_name, _SLIT("move"))) {
		if (string_at(method_name, 0) == 'm') {
			v__checker__Checker_fail_if_immutable(c, node->left);
		}
		if (v__ast__Expr_is_auto_deref_var(node->left)) {
			ret_type = v__ast__Type_deref(left_type);
		} else {
			ret_type = left_type;
		}
	}
	else if (string__eq(method_name, _SLIT("keys"))) {
		v__ast__Map info = /* as */ *(v__ast__Map*)__as_cast((left_sym.info)._v__ast__Map,(left_sym.info)._typ, 442) /*expected idx: 442, name: v.ast.Map */ ;
		int typ = v__ast__Table_find_or_register_array(c->table, info.key_type);
		ret_type = ((typ));
	}
	else if (string__eq(method_name, _SLIT("delete"))) {
		v__checker__Checker_fail_if_immutable(c, node->left);
		if (node->args.len != 1) {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("expected 1 argument, but got "), 0xfe07, {.d_i32 = node->args.len}}, {_SLIT0, 0, { .d_c = 0 }}})), node->pos);
		}
		v__ast__Map info = /* as */ *(v__ast__Map*)__as_cast((left_sym.info)._v__ast__Map,(left_sym.info)._typ, 442) /*expected idx: 442, name: v.ast.Map */ ;
		v__ast__Type arg_type = v__checker__Checker_expr(c, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node->args, 0)).expr);
		Option_void _t1 = v__checker__Checker_check_expected_call_arg(c, arg_type, info.key_type, node->language, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node->args, 0)));
		if (_t1.state != 0 && _t1.err._typ != _IError_None___index) {
			IError err = _t1.err;
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = (*(err.msg))}}, {_SLIT(" in argument 1 to `Map.delete`"), 0, { .d_c = 0 }}})), (*(v__ast__CallArg*)/*ee elem_typ */array_get(node->args, 0)).pos);
		;
		}
		
 ;
	}
	else {
	};
	node->receiver_type = v__ast__Type_ref(left_type);
	node->return_type = ret_type;
	v__ast__Type _t2 = node->return_type;
	return _t2;
}

VV_LOCAL_SYMBOL v__ast__Type v__checker__Checker_array_builtin_method_call(v__checker__Checker* c, v__ast__CallExpr* node, v__ast__Type left_type, v__ast__TypeSymbol left_sym) {
	string method_name = node->name;
	v__ast__Type elem_typ = _const_v__ast__void_type;
	if (string__eq(method_name, _SLIT("slice")) && !c->is_builtin_mod) {
		v__checker__Checker_error(c, _SLIT(".slice() is a private method, use `x[start..end]` instead"), node->pos);
	}
	v__ast__Array array_info = /* as */ *(v__ast__Array*)__as_cast((left_sym.info)._v__ast__Array,(left_sym.info)._typ, 441) /*expected idx: 441, name: v.ast.Array */ ;
	elem_typ = array_info.elem_type;
	if (string__eq(method_name, _SLIT("filter")) || string__eq(method_name, _SLIT("map")) || string__eq(method_name, _SLIT("any")) || string__eq(method_name, _SLIT("all"))) {
		v__checker__scope_register_it(node->scope, node->pos, elem_typ);
	} else if (string__eq(method_name, _SLIT("sort"))) {
		if ((node->left)._typ == 286 /* v.ast.CallExpr */) {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("the `sort()` method can be called only on mutable receivers, but `"), 0xfe10, {.d_s = v__ast__Expr_str(node->left)}}, {_SLIT("` is a call expression"), 0, { .d_c = 0 }}})), node->pos);
		}
		v__checker__Checker_fail_if_immutable(c, node->left);
		v__checker__scope_register_a_b(node->scope, node->pos, elem_typ);
		if (node->args.len > 1) {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("expected 0 or 1 argument, but got "), 0xfe07, {.d_i32 = node->args.len}}, {_SLIT0, 0, { .d_c = 0 }}})), node->pos);
		} else if (node->args.len == 1) {
			if (((*(v__ast__CallArg*)/*ee elem_typ */array_get(node->args, 0)).expr)._typ == 303 /* v.ast.InfixExpr */) {
				if (!((*(*(v__ast__CallArg*)/*ee elem_typ */array_get(node->args, 0)).expr._v__ast__InfixExpr).op == v__token__Kind__gt || (*(*(v__ast__CallArg*)/*ee elem_typ */array_get(node->args, 0)).expr._v__ast__InfixExpr).op == v__token__Kind__lt)) {
					v__checker__Checker_error(c, _SLIT("`.sort()` can only use `<` or `>` comparison"), node->pos);
				}
				byte left_name = string_at( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__ast__Expr_str((*(*(v__ast__CallArg*)/*ee elem_typ */array_get(node->args, 0)).expr._v__ast__InfixExpr).left)}}, {_SLIT0, 0, { .d_c = 0 }}})), 0);
				byte right_name = string_at( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__ast__Expr_str((*(*(v__ast__CallArg*)/*ee elem_typ */array_get(node->args, 0)).expr._v__ast__InfixExpr).right)}}, {_SLIT0, 0, { .d_c = 0 }}})), 0);
				if (!(left_name == 'a' || left_name == 'b') || !(right_name == 'a' || right_name == 'b')) {
					v__checker__Checker_error(c, _SLIT("`.sort()` can only use `a` or `b` as argument, e.g. `arr.sort(a < b)`"), node->pos);
				} else if (left_name == right_name) {
					v__checker__Checker_error(c, _SLIT("`.sort()` cannot use same argument"), node->pos);
				}
				if ((((*(*(v__ast__CallArg*)/*ee elem_typ */array_get(node->args, 0)).expr._v__ast__InfixExpr).left)._typ != 299 /* v.ast.Ident */ && ((*(*(v__ast__CallArg*)/*ee elem_typ */array_get(node->args, 0)).expr._v__ast__InfixExpr).left)._typ != 319 /* v.ast.SelectorExpr */ && ((*(*(v__ast__CallArg*)/*ee elem_typ */array_get(node->args, 0)).expr._v__ast__InfixExpr).left)._typ != 302 /* v.ast.IndexExpr */) || (((*(*(v__ast__CallArg*)/*ee elem_typ */array_get(node->args, 0)).expr._v__ast__InfixExpr).right)._typ != 299 /* v.ast.Ident */ && ((*(*(v__ast__CallArg*)/*ee elem_typ */array_get(node->args, 0)).expr._v__ast__InfixExpr).right)._typ != 319 /* v.ast.SelectorExpr */ && ((*(*(v__ast__CallArg*)/*ee elem_typ */array_get(node->args, 0)).expr._v__ast__InfixExpr).right)._typ != 302 /* v.ast.IndexExpr */)) {
					v__checker__Checker_error(c, _SLIT("`.sort()` can only use ident, index or selector as argument, \ne.g. `arr.sort(a < b)`, `arr.sort(a.id < b.id)`, `arr.sort(a[0] < b[0])`"), node->pos);
				}
			} else {
				v__checker__Checker_error(c, string__plus(_SLIT("`.sort()` requires a `<` or `>` comparison as the first and only argument"), _SLIT("\ne.g. `users.sort(a.id < b.id)`")), node->pos);
			}
		} else if (!(v__ast__TypeSymbol_has_method(v__ast__Table_sym(c->table, elem_typ), _SLIT("<")) || (v__ast__Table_unalias_num_type(c->table, elem_typ) == _const_v__ast__int_type || v__ast__Table_unalias_num_type(c->table, elem_typ) == v__ast__Type_ref(_const_v__ast__int_type) || v__ast__Table_unalias_num_type(c->table, elem_typ) == _const_v__ast__string_type || v__ast__Table_unalias_num_type(c->table, elem_typ) == v__ast__Type_ref(_const_v__ast__string_type) || v__ast__Table_unalias_num_type(c->table, elem_typ) == _const_v__ast__i8_type || v__ast__Table_unalias_num_type(c->table, elem_typ) == _const_v__ast__i16_type || v__ast__Table_unalias_num_type(c->table, elem_typ) == _const_v__ast__i64_type || v__ast__Table_unalias_num_type(c->table, elem_typ) == _const_v__ast__byte_type || v__ast__Table_unalias_num_type(c->table, elem_typ) == _const_v__ast__rune_type || v__ast__Table_unalias_num_type(c->table, elem_typ) == _const_v__ast__u16_type || v__ast__Table_unalias_num_type(c->table, elem_typ) == _const_v__ast__u32_type || v__ast__Table_unalias_num_type(c->table, elem_typ) == _const_v__ast__u64_type || v__ast__Table_unalias_num_type(c->table, elem_typ) == _const_v__ast__f32_type || v__ast__Table_unalias_num_type(c->table, elem_typ) == _const_v__ast__f64_type || v__ast__Table_unalias_num_type(c->table, elem_typ) == _const_v__ast__char_type || v__ast__Table_unalias_num_type(c->table, elem_typ) == _const_v__ast__bool_type || v__ast__Table_unalias_num_type(c->table, elem_typ) == _const_v__ast__float_literal_type || v__ast__Table_unalias_num_type(c->table, elem_typ) == _const_v__ast__int_literal_type))) {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("custom sorting condition must be supplied for type `"), 0xfe10, {.d_s = v__ast__Table_type_to_str(c->table, elem_typ)}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node->pos);
		}
	} else if (string__eq(method_name, _SLIT("wait"))) {
		v__ast__TypeSymbol* elem_sym = v__ast__Table_sym(c->table, elem_typ);
		if (elem_sym->kind == v__ast__Kind__thread) {
			if (node->args.len != 0) {
				v__checker__Checker_error(c, _SLIT("`.wait()` does not have any arguments"), (*(v__ast__CallArg*)/*ee elem_typ */array_get(node->args, 0)).pos);
			}
			v__ast__Type thread_ret_type = v__ast__TypeSymbol_thread_info(elem_sym).return_type;
			if (v__ast__Type_has_flag(thread_ret_type, v__ast__TypeFlag__optional)) {
				v__checker__Checker_error(c, _SLIT("`.wait()` cannot be called for an array when thread functions return optionals. Iterate over the arrays elements instead and handle each returned optional with `or`."), node->pos);
			}
			node->return_type = v__ast__Table_find_or_register_array(c->table, thread_ret_type);
		} else {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = left_sym.name}}, {_SLIT("` has no method `wait()` (only thread handles and arrays of them have)"), 0, { .d_c = 0 }}})), v__ast__Expr_position(node->left));
		}
	}
	v__ast__Type arg_type = left_type;
	for (int _t1 = 0; _t1 < node->args.len; ++_t1) {
		v__ast__CallArg arg = ((v__ast__CallArg*)node->args.data)[_t1];
		arg_type = v__checker__Checker_check_expr_opt_call(c, arg.expr, v__checker__Checker_expr(c, arg.expr));
	}
	if (string__eq(method_name, _SLIT("map"))) {
		v__checker__Checker_check_map_and_filter(c, true, elem_typ, *node);
		v__ast__TypeSymbol* arg_sym = v__ast__Table_sym(c->table, arg_type);
		v__ast__Type ret_type = ((arg_sym->info._typ == 472 /* v.ast.FnType */) ? ((*arg_sym->info._v__ast__FnType).func.return_type) : (arg_type));
		node->return_type = v__ast__Table_find_or_register_array(c->table, v__checker__Checker_unwrap_generic(c, ret_type));
		v__ast__TypeSymbol* ret_sym = v__ast__Table_sym(c->table, ret_type);
		if (ret_sym->kind == v__ast__Kind__multi_return) {
			v__checker__Checker_error(c, _SLIT("returning multiple values is not supported in .map() calls"), node->pos);
		}
	} else if (string__eq(method_name, _SLIT("filter"))) {
		v__checker__Checker_check_map_and_filter(c, false, elem_typ, *node);
	} else if (string__eq(method_name, _SLIT("any")) || string__eq(method_name, _SLIT("all"))) {
		v__checker__Checker_check_map_and_filter(c, false, elem_typ, *node);
		node->return_type = _const_v__ast__bool_type;
	} else if (string__eq(method_name, _SLIT("clone"))) {
		node->receiver_type = v__ast__Type_ref(left_type);
		if (v__ast__Expr_is_auto_deref_var(node->left)) {
			node->return_type = v__ast__Type_deref(left_type);
		} else {
			node->return_type = v__ast__Type_set_nr_muls(node->receiver_type, 0);
		}
	} else if (string__eq(method_name, _SLIT("sort"))) {
		node->return_type = _const_v__ast__void_type;
	} else if (string__eq(method_name, _SLIT("contains"))) {
		node->return_type = _const_v__ast__bool_type;
	} else if (string__eq(method_name, _SLIT("index"))) {
		node->return_type = _const_v__ast__int_type;
	} else if (string__eq(method_name, _SLIT("first")) || string__eq(method_name, _SLIT("last")) || string__eq(method_name, _SLIT("pop"))) {
		node->return_type = array_info.elem_type;
		if (string__eq(method_name, _SLIT("pop"))) {
			v__checker__Checker_fail_if_immutable(c, node->left);
			node->receiver_type = v__ast__Type_ref(left_type);
		} else {
			node->receiver_type = left_type;
		}
	}
	v__ast__Type _t2 = node->return_type;
	return _t2;
}

VV_LOCAL_SYMBOL void v__checker__scope_register_it(v__ast__Scope* s, v__token__Position pos, v__ast__Type typ) {
	v__ast__Scope_register(s, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){.name = _SLIT("it"),.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.is_auto_deref = 0,.is_inherited = 0,.typ = typ,.orig_type = 0,.smartcasts = __new_array(0, 0, sizeof(v__ast__Type)),.pos = pos,.is_used = true,.is_changed = 0,.is_or = 0,.is_tmp = 0,.is_auto_heap = 0,.is_stack_obj = 0,}))));
}

VV_LOCAL_SYMBOL void v__checker__scope_register_a_b(v__ast__Scope* s, v__token__Position pos, v__ast__Type typ) {
	v__ast__Scope_register(s, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){.name = _SLIT("a"),.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.is_auto_deref = 0,.is_inherited = 0,.typ = v__ast__Type_ref(typ),.orig_type = 0,.smartcasts = __new_array(0, 0, sizeof(v__ast__Type)),.pos = pos,.is_used = true,.is_changed = 0,.is_or = 0,.is_tmp = 0,.is_auto_heap = 0,.is_stack_obj = 0,}))));
	v__ast__Scope_register(s, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){.name = _SLIT("b"),.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.is_auto_deref = 0,.is_inherited = 0,.typ = v__ast__Type_ref(typ),.orig_type = 0,.smartcasts = __new_array(0, 0, sizeof(v__ast__Type)),.pos = pos,.is_used = true,.is_changed = 0,.is_or = 0,.is_tmp = 0,.is_auto_heap = 0,.is_stack_obj = 0,}))));
}

VV_LOCAL_SYMBOL void v__checker__Checker_for_c_stmt(v__checker__Checker* c, v__ast__ForCStmt node) {
	c->in_for_count++;
	string prev_loop_label = c->loop_label;
	if (node.has_init) {
		v__checker__Checker_stmt(c, node.init);
	}
	v__checker__Checker_expr(c, node.cond);
	if (node.has_inc) {
		v__checker__Checker_stmt(c, node.inc);
	}
	v__checker__Checker_check_loop_label(c, node.label, node.pos);
	v__checker__Checker_stmts(c, node.stmts);
	c->loop_label = prev_loop_label;
	c->in_for_count--;
}

VV_LOCAL_SYMBOL void v__checker__Checker_for_in_stmt(v__checker__Checker* c, v__ast__ForInStmt* node) {
	c->in_for_count++;
	string prev_loop_label = c->loop_label;
	v__ast__Type typ = v__checker__Checker_expr(c, node->cond);
	int typ_idx = v__ast__Type_idx(typ);
	if (node->key_var.len > 0 && !string__eq(node->key_var, _SLIT("_"))) {
		v__checker__Checker_check_valid_snake_case(c, node->key_var, _SLIT("variable name"), node->pos);
	}
	if (node->val_var.len > 0 && !string__eq(node->val_var, _SLIT("_"))) {
		v__checker__Checker_check_valid_snake_case(c, node->val_var, _SLIT("variable name"), node->pos);
	}
	if (node->is_range) {
		v__ast__Type high_type = v__checker__Checker_expr(c, node->high);
		int high_type_idx = v__ast__Type_idx(high_type);
		if (Array_int_contains(_const_v__ast__integer_type_idxs, typ_idx) && !Array_int_contains(_const_v__ast__integer_type_idxs, high_type_idx)) {
			v__checker__Checker_error(c, _SLIT("range types do not match"), v__ast__Expr_position(node->cond));
		} else if (Array_int_contains(_const_v__ast__float_type_idxs, typ_idx) || Array_int_contains(_const_v__ast__float_type_idxs, high_type_idx)) {
			v__checker__Checker_error(c, _SLIT("range type can not be float"), v__ast__Expr_position(node->cond));
		} else if (typ_idx == _const_v__ast__bool_type_idx || high_type_idx == _const_v__ast__bool_type_idx) {
			v__checker__Checker_error(c, _SLIT("range type can not be bool"), v__ast__Expr_position(node->cond));
		} else if (typ_idx == _const_v__ast__string_type_idx || high_type_idx == _const_v__ast__string_type_idx) {
			v__checker__Checker_error(c, _SLIT("range type can not be string"), v__ast__Expr_position(node->cond));
		}
		if (high_type == _const_v__ast__int_type || high_type == _const_v__ast__int_literal_type) {
			node->val_type = typ;
		} else {
			node->val_type = high_type;
		}
		node->high_type = high_type;
		v__ast__Scope_update_var_type(node->scope, node->val_var, node->val_type);
	} else {
		v__ast__TypeSymbol* sym = v__ast__Table_final_sym(c->table, typ);
		if (sym->kind == v__ast__Kind__struct_) {
			Option_v__ast__Fn _t1 = v__ast__TypeSymbol_find_method_with_generic_parent(sym, _SLIT("next"));
			if (_t1.state != 0) { /*or block*/ 
				IError err = _t1.err;
				v__checker__Checker_error(c, _SLIT("a struct must have a `next()` method to be an iterator"), v__ast__Expr_position(node->cond));
				return;
			}
			
 			v__ast__Fn next_fn =  (*(v__ast__Fn*)_t1.data);
			if (!v__ast__Type_has_flag(next_fn.return_type, v__ast__TypeFlag__optional)) {
				v__checker__Checker_error(c, _SLIT("iterator method `next()` must return an optional"), v__ast__Expr_position(node->cond));
			}
			v__ast__TypeSymbol* return_sym = v__ast__Table_sym(c->table, next_fn.return_type);
			if (return_sym->kind == v__ast__Kind__multi_return) {
				v__checker__Checker_error(c, _SLIT("iterator method `next()` must not return multiple values"), v__ast__Expr_position(node->cond));
			}
			if (next_fn.params.len != 1) {
				v__checker__Checker_error(c, _SLIT("iterator method `next()` must have 0 parameters"), v__ast__Expr_position(node->cond));
			}
			v__ast__Type val_type = v__ast__Type_clear_flag(next_fn.return_type, v__ast__TypeFlag__optional);
			if (node->val_is_mut) {
				val_type = v__ast__Type_ref(val_type);
			}
			node->cond_type = typ;
			node->kind = sym->kind;
			node->val_type = val_type;
			v__ast__Scope_update_var_type(node->scope, node->val_var, val_type);
		} else if (sym->kind == v__ast__Kind__string && node->val_is_mut) {
			v__checker__Checker_error(c, _SLIT("string type is immutable, it cannot be changed"), node->pos);
		} else {
			if (sym->kind == v__ast__Kind__map && !(node->key_var.len > 0 && node->val_var.len > 0)) {
				v__checker__Checker_error(c, string__plus(_SLIT("declare a key and a value variable when ranging a map: `for key, val in map {`\n"), _SLIT("use `_` if you do not need the variable")), node->pos);
			}
			if (node->key_var.len > 0) {
				v__ast__Type key_type = ((sym->kind == (v__ast__Kind__map)) ? (v__ast__TypeSymbol_map_info(sym).key_type) : (_const_v__ast__int_type));
				node->key_type = key_type;
				v__ast__Scope_update_var_type(node->scope, node->key_var, key_type);
			}
			v__ast__Type value_type = v__ast__Table_value_type(c->table, typ);
			if (v__ast__Type_alias_eq(value_type, _const_v__ast__void_type) || v__ast__Type_has_flag(typ, v__ast__TypeFlag__optional)) {
				if (!v__ast__Type_alias_eq(typ, _const_v__ast__void_type)) {
					v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("for in: cannot index `"), 0xfe10, {.d_s = v__ast__Table_type_to_str(c->table, typ)}}, {_SLIT("`"), 0, { .d_c = 0 }}})), v__ast__Expr_position(node->cond));
				}
			}
			if (node->val_is_mut) {
				value_type = v__ast__Type_ref(value_type);
				if (node->cond._typ == 299 /* v.ast.Ident */) {
					if (((*node->cond._v__ast__Ident).obj)._typ == 357 /* v.ast.Var */) {
						v__ast__Var obj = /* as */ *(v__ast__Var*)__as_cast(((*node->cond._v__ast__Ident).obj)._v__ast__Var,((*node->cond._v__ast__Ident).obj)._typ, 357) /*expected idx: 357, name: v.ast.Var */ ;
						if (!obj.is_mut) {
							v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = obj.name}}, {_SLIT("` is immutable, it cannot be changed"), 0, { .d_c = 0 }}})), (*node->cond._v__ast__Ident).pos);
						}
					}
				}
				else if (node->cond._typ == 280 /* v.ast.ArrayInit */) {
					v__checker__Checker_error(c, _SLIT("array literal is immutable, it cannot be changed"), (*node->cond._v__ast__ArrayInit).pos);
				}
				else if (node->cond._typ == 308 /* v.ast.MapInit */) {
					v__checker__Checker_error(c, _SLIT("map literal is immutable, it cannot be changed"), (*node->cond._v__ast__MapInit).pos);
				}
				else if (node->cond._typ == 319 /* v.ast.SelectorExpr */) {
					Option_v__ast__Ident _t2 = v__ast__SelectorExpr_root_ident(&(*node->cond._v__ast__SelectorExpr));
					if (_t2.state != 0) { /*or block*/ 
						IError err = _t2.err;
						*(v__ast__Ident*) _t2.data = /* as */ *(v__ast__Ident*)__as_cast(((*node->cond._v__ast__SelectorExpr).expr)._v__ast__Ident,((*node->cond._v__ast__SelectorExpr).expr)._typ, 299) /*expected idx: 299, name: v.ast.Ident */ ;
					}
					
 					v__ast__Ident root_ident =  (*(v__ast__Ident*)_t2.data);
					if (!(/* as */ *(v__ast__Var*)__as_cast((root_ident.obj)._v__ast__Var,(root_ident.obj)._typ, 357) /*expected idx: 357, name: v.ast.Var */ ).is_mut) {
						v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("field `"), 0xfe10, {.d_s = (*node->cond._v__ast__SelectorExpr).field_name}}, {_SLIT("` is immutable, it cannot be changed"), 0, { .d_c = 0 }}})), (*node->cond._v__ast__SelectorExpr).pos);
					}
				}
				
				else {
				}
				;
			}
			node->cond_type = typ;
			node->kind = sym->kind;
			node->val_type = value_type;
			v__ast__Scope_update_var_type(node->scope, node->val_var, value_type);
		}
	}
	v__checker__Checker_check_loop_label(c, node->label, node->pos);
	v__checker__Checker_stmts(c, node->stmts);
	c->loop_label = prev_loop_label;
	c->in_for_count--;
}

VV_LOCAL_SYMBOL void v__checker__Checker_for_stmt(v__checker__Checker* c, v__ast__ForStmt* node) {
	c->in_for_count++;
	string prev_loop_label = c->loop_label;
	c->expected_type = _const_v__ast__bool_type;
	v__ast__Type typ = v__checker__Checker_expr(c, node->cond);
	if (!node->is_inf && v__ast__Type_idx(typ) != _const_v__ast__bool_type_idx && !c->pref->translated) {
		v__checker__Checker_error(c, _SLIT("non-bool used as for condition"), node->pos);
	}
	if ((node->cond)._typ == 303 /* v.ast.InfixExpr */) {
		v__ast__InfixExpr infix = (*node->cond._v__ast__InfixExpr);
		if (infix.op == v__token__Kind__key_is) {
			if (((infix.left)._typ == 299 /* v.ast.Ident */ || (infix.left)._typ == 319 /* v.ast.SelectorExpr */) && (infix.right)._typ == 325 /* v.ast.TypeNode */) {
				bool is_variable = ((infix.left)._typ == 299 /* v.ast.Ident */ ? ((*infix.left._v__ast__Ident).kind == v__ast__IdentKind__variable) : (true));
				v__ast__Type left_type = v__checker__Checker_expr(c, infix.left);
				v__ast__TypeSymbol* left_sym = v__ast__Table_sym(c->table, left_type);
				if (is_variable) {
					if (left_sym->kind == v__ast__Kind__sum_type || left_sym->kind == v__ast__Kind__interface_) {
						v__checker__Checker_smartcast(c, infix.left, infix.left_type, (*infix.right._v__ast__TypeNode).typ, node->scope);
					}
				}
			}
		}
	}
	v__checker__Checker_check_loop_label(c, node->label, node->pos);
	v__checker__Checker_stmts(c, node->stmts);
	c->loop_label = prev_loop_label;
	c->in_for_count--;
}

v__ast__Type v__checker__Checker_if_expr(v__checker__Checker* c, v__ast__IfExpr* node) {
	string if_kind = (node->is_comptime ? (_SLIT("$if")) : (_SLIT("if")));
	bool node_is_expr = false;
	if (node->branches.len > 0 && node->has_else) {
		Array_v__ast__Stmt stmts = (*(v__ast__IfBranch*)/*ee elem_typ */array_get(node->branches, 0)).stmts;
		if (stmts.len > 0 && ((*(v__ast__Stmt*)/*ee elem_typ */array_get(stmts, stmts.len - 1)))._typ == 339 /* v.ast.ExprStmt */ && !v__ast__Type_alias_eq((/* as */ *(v__ast__ExprStmt*)__as_cast(((*(v__ast__Stmt*)/*ee elem_typ */array_get(stmts, stmts.len - 1)))._v__ast__ExprStmt,((*(v__ast__Stmt*)/*ee elem_typ */array_get(stmts, stmts.len - 1)))._typ, 339) /*expected idx: 339, name: v.ast.ExprStmt */ ).typ, _const_v__ast__void_type)) {
			node_is_expr = true;
		}
	}
	if (v__ast__Type_alias_eq(c->expected_type, _const_v__ast__void_type) && node_is_expr) {
		c->expected_type = c->expected_or_type;
	}
	bool expr_required = !v__ast__Type_alias_eq(c->expected_type, _const_v__ast__void_type);
	v__ast__Type former_expected_type = c->expected_type;
	node->typ = _const_v__ast__void_type;
	int nbranches_with_return = 0;
	int nbranches_without_return = 0;
	bool should_skip = false;
	bool found_branch = false;
	bool is_comptime_type_is_expr = false;
	for (int i = 0; i < node->branches.len; ++i) {
		v__ast__IfBranch branch = (*(v__ast__IfBranch*)/*ee elem_typ */array_get(node->branches, i));
		if ((branch.cond)._typ == 314 /* v.ast.ParExpr */) {
			v__checker__Checker_error(c,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("unnecessary `()` in `"), 0xfe10, {.d_s = if_kind}}, {_SLIT("` condition, use `"), 0xfe10, {.d_s = if_kind}}, {_SLIT(" expr {` instead of `"), 0xfe10, {.d_s = if_kind}}, {_SLIT(" (expr) {`."), 0, { .d_c = 0 }}})), branch.pos);
		}
		if (!node->has_else || i < node->branches.len - 1) {
			if (node->is_comptime) {
				should_skip = v__checker__Checker_comptime_if_branch(c, branch.cond, branch.pos);
				(*(v__ast__IfBranch*)/*ee elem_typ */array_get(node->branches, i)).pkg_exist = !should_skip;
			} else {
				c->expected_type = _const_v__ast__bool_type;
				v__ast__Type cond_typ = v__checker__Checker_unwrap_generic(c, v__checker__Checker_expr(c, branch.cond));
				if ((v__ast__Type_idx(cond_typ) != _const_v__ast__bool_type_idx || v__ast__Type_has_flag(cond_typ, v__ast__TypeFlag__optional)) && !c->pref->translated) {
					v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("non-bool type `"), 0xfe10, {.d_s = v__ast__Table_type_to_str(c->table, cond_typ)}}, {_SLIT("` used as if condition"), 0, { .d_c = 0 }}})), v__ast__Expr_position(branch.cond));
				}
			}
		}
		if (node->is_comptime) {
			string comptime_field_name = _SLIT("");
			if ((branch.cond)._typ == 303 /* v.ast.InfixExpr */) {
				if ((*branch.cond._v__ast__InfixExpr).op == v__token__Kind__key_is) {
					if (((*branch.cond._v__ast__InfixExpr).right)._typ != 325 /* v.ast.TypeNode */) {
						v__checker__Checker_error(c, _SLIT("invalid `$if` condition: expected a type"), v__ast__Expr_position((*branch.cond._v__ast__InfixExpr).right));
						v__ast__Type _t1 = 0;
						return _t1;
					}
					v__ast__Type got_type = v__checker__Checker_unwrap_generic(c, (/* as */ *(v__ast__TypeNode*)__as_cast(((*branch.cond._v__ast__InfixExpr).right)._v__ast__TypeNode,((*branch.cond._v__ast__InfixExpr).right)._typ, 325) /*expected idx: 325, name: v.ast.TypeNode */ ).typ);
					v__ast__TypeSymbol* sym = v__ast__Table_sym(c->table, got_type);
					if (sym->kind == v__ast__Kind__placeholder || v__ast__Type_has_flag(got_type, v__ast__TypeFlag__generic)) {
						v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unknown type `"), 0xfe10, {.d_s = sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), v__ast__Expr_position((*branch.cond._v__ast__InfixExpr).right));
					}
					v__ast__Expr left = (*branch.cond._v__ast__InfixExpr).left;
					if ((left)._typ == 319 /* v.ast.SelectorExpr */) {
						comptime_field_name = v__ast__Expr_str((*left._v__ast__SelectorExpr).expr);
						map_set(&c->comptime_fields_type, &(string[]){comptime_field_name}, &(v__ast__Type[]) { got_type });
						is_comptime_type_is_expr = true;
					} else if (((*branch.cond._v__ast__InfixExpr).right)._typ == 325 /* v.ast.TypeNode */ && (left)._typ == 325 /* v.ast.TypeNode */ && sym->kind == v__ast__Kind__interface_) {
						is_comptime_type_is_expr = true;
						v__ast__Type checked_type = v__checker__Checker_unwrap_generic(c, (*left._v__ast__TypeNode).typ);
						should_skip = !v__ast__Table_does_type_implement_interface(c->table, checked_type, got_type);
					} else if ((left)._typ == 325 /* v.ast.TypeNode */) {
						is_comptime_type_is_expr = true;
						v__ast__Type left_type = v__checker__Checker_unwrap_generic(c, (*left._v__ast__TypeNode).typ);
						if (!v__ast__Type_alias_eq(left_type, got_type)) {
							should_skip = true;
						}
					}
				}
			}
			bool cur_skip_flags = c->skip_flags;
			if (found_branch) {
				c->skip_flags = true;
			} else if (should_skip) {
				c->skip_flags = true;
				should_skip = false;
			} else if (!is_comptime_type_is_expr) {
				found_branch = true;
			}
			if (c->fn_level == 0 && c->pref->output_cross_c) {
				found_branch = false;
				c->skip_flags = false;
				array_push((array*)&c->ct_cond_stack, _MOV((v__ast__Expr[]){ branch.cond }));
			}
			if (!c->skip_flags) {
				if (node_is_expr) {
					v__checker__Checker_stmts_ending_with_expression(c, branch.stmts);
				} else {
					v__checker__Checker_stmts(c, branch.stmts);
				}
			} else if (c->pref->output_cross_c) {
				bool is_freestanding_block = false;
				if ((branch.cond)._typ == 299 /* v.ast.Ident */) {
					if (string__eq((*branch.cond._v__ast__Ident).name, _SLIT("freestanding"))) {
						is_freestanding_block = true;
					}
				}
				if (is_freestanding_block) {
					branch.stmts = __new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
					(*(v__ast__IfBranch*)/*ee elem_typ */array_get(node->branches, i)).stmts = __new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
				}
				if (node_is_expr) {
					v__checker__Checker_stmts_ending_with_expression(c, branch.stmts);
				} else {
					v__checker__Checker_stmts(c, branch.stmts);
				}
			} else if (!is_comptime_type_is_expr) {
				(*(v__ast__IfBranch*)/*ee elem_typ */array_get(node->branches, i)).stmts = __new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
			}
			if (comptime_field_name.len > 0) {
				map_set(&c->comptime_fields_type, &(string[]){comptime_field_name}, &(v__ast__Type[]) { c->comptime_fields_default_type });
			}
			c->skip_flags = cur_skip_flags;
			if (c->fn_level == 0 && c->pref->output_cross_c && c->ct_cond_stack.len > 0) {
				array_delete_last(&c->ct_cond_stack);
			}
		} else {
			v__checker__Checker_smartcast_if_conds(c, branch.cond, branch.scope);
			if (node_is_expr) {
				v__checker__Checker_stmts_ending_with_expression(c, branch.stmts);
			} else {
				v__checker__Checker_stmts(c, branch.stmts);
			}
		}
		if (expr_required) {
			if (branch.stmts.len > 0 && ((*(v__ast__Stmt*)/*ee elem_typ */array_get(branch.stmts, branch.stmts.len - 1)))._typ == 339 /* v.ast.ExprStmt */) {
				v__ast__ExprStmt last_expr = /* as */ *(v__ast__ExprStmt*)__as_cast(((*(v__ast__Stmt*)/*ee elem_typ */array_get(branch.stmts, branch.stmts.len - 1)))._v__ast__ExprStmt,((*(v__ast__Stmt*)/*ee elem_typ */array_get(branch.stmts, branch.stmts.len - 1)))._typ, 339) /*expected idx: 339, name: v.ast.ExprStmt */ ;
				c->expected_type = former_expected_type;
				if (v__ast__Type_has_flag(c->expected_type, v__ast__TypeFlag__optional)) {
					if (v__ast__Type_alias_eq(node->typ, _const_v__ast__void_type)) {
						node->is_expr = true;
						node->typ = c->expected_type;
					}
				}
				if (v__ast__Type_has_flag(c->expected_type, v__ast__TypeFlag__generic)) {
					if (v__ast__Type_alias_eq(node->typ, _const_v__ast__void_type)) {
						node->is_expr = true;
						node->typ = v__checker__Checker_unwrap_generic(c, c->expected_type);
					}
					continue;
				}
				last_expr.typ = v__checker__Checker_expr(c, last_expr.expr);
				if (!v__checker__Checker_check_types(c, last_expr.typ, node->typ)) {
					if (v__ast__Type_alias_eq(node->typ, _const_v__ast__void_type)) {
						node->is_expr = true;
						node->typ = last_expr.typ;
						continue;
					} else if (node->typ == _const_v__ast__float_literal_type || node->typ == _const_v__ast__int_literal_type) {
						if (v__ast__Type_alias_eq(node->typ, _const_v__ast__int_literal_type)) {
							if (v__ast__Type_is_int(last_expr.typ) || v__ast__Type_is_float(last_expr.typ)) {
								node->typ = last_expr.typ;
								continue;
							}
						} else {
							if (v__ast__Type_is_float(last_expr.typ)) {
								node->typ = last_expr.typ;
								continue;
							}
						}
					}
					if (last_expr.typ == _const_v__ast__float_literal_type || last_expr.typ == _const_v__ast__int_literal_type) {
						if (v__ast__Type_alias_eq(last_expr.typ, _const_v__ast__int_literal_type)) {
							if (v__ast__Type_is_int(node->typ) || v__ast__Type_is_float(node->typ)) {
								continue;
							}
						} else {
							if (v__ast__Type_is_float(node->typ)) {
								continue;
							}
						}
					}
					if (node->is_expr && v__ast__Table_sym(c->table, former_expected_type)->kind == v__ast__Kind__sum_type) {
						continue;
					}
					if (v__checker__is_noreturn_callexpr(last_expr.expr)) {
						continue;
					}
					v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("mismatched types `"), 0xfe10, {.d_s = v__ast__Table_type_to_str(c->table, node->typ)}}, {_SLIT("` and `"), 0xfe10, {.d_s = v__ast__Table_type_to_str(c->table, last_expr.typ)}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node->pos);
				}
			} else {
				v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = if_kind}}, {_SLIT("` expression requires an expression as the last statement of every branch"), 0, { .d_c = 0 }}})), branch.pos);
			}
			for (int _t3 = 0; _t3 < branch.stmts.len; ++_t3) {
				v__ast__Stmt st = ((v__ast__Stmt*)branch.stmts.data)[_t3];
				Option_void _t4 = v__ast__Stmt_check_c_expr(st);
				if (_t4.state != 0 && _t4.err._typ != _IError_None___index) {
					IError err = _t4.err;
					v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("`if` expression branch has "), 0xfe10, {.d_s = (*(err.msg))}}, {_SLIT0, 0, { .d_c = 0 }}})), (*(st.pos)));
				;
				}
				
 ;
			}
		}
		Option_bool _t5;
		if (_t5 = v__checker__Checker_has_return(c, branch.stmts), _t5.state == 0) {
			bool has_return = *(bool*)_t5.data;
			if (has_return) {
				nbranches_with_return++;
			} else {
				nbranches_without_return++;
			}
		}
	}
	if (nbranches_with_return > 0) {
		if (nbranches_with_return == node->branches.len) {
			c->returns = true;
		}
		if (!node->has_else) {
			c->returns = false;
		}
		if (nbranches_without_return > 0) {
			c->returns = false;
		}
	}
	if (v__ast__Type_alias_eq(node->typ, _const_v__ast__int_literal_type)) {
		node->typ = _const_v__ast__int_type;
	} else if (v__ast__Type_alias_eq(node->typ, _const_v__ast__float_literal_type)) {
		node->typ = _const_v__ast__f64_type;
	}
	if (expr_required && !node->has_else) {
		string d = (node->is_comptime ? (_SLIT("$")) : (_SLIT("")));
		v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = if_kind}}, {_SLIT("` expression needs `"), 0xfe10, {.d_s = d}}, {_SLIT("else` clause"), 0, { .d_c = 0 }}})), node->pos);
	}
	v__ast__Type _t6 = node->typ;
	return _t6;
}

VV_LOCAL_SYMBOL void v__checker__Checker_smartcast_if_conds(v__checker__Checker* c, v__ast__Expr node, v__ast__Scope* scope) {
	if ((node)._typ == 303 /* v.ast.InfixExpr */) {
		if ((*node._v__ast__InfixExpr).op == v__token__Kind__and) {
			v__checker__Checker_smartcast_if_conds(c, (*node._v__ast__InfixExpr).left, scope);
			v__checker__Checker_smartcast_if_conds(c, (*node._v__ast__InfixExpr).right, scope);
		} else if ((*node._v__ast__InfixExpr).op == v__token__Kind__key_is) {
			v__ast__Expr right_expr = (*node._v__ast__InfixExpr).right;
			v__ast__Type _t1 = 0;
			if (right_expr._typ == 325 /* v.ast.TypeNode */) {
				_t1 = (*right_expr._v__ast__TypeNode).typ;
			}
			else if (right_expr._typ == 311 /* v.ast.None */) {
				_t1 = _const_v__ast__none_type_idx;
			}
			
			else {
				v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("invalid type `"), 0xfe10, {.d_s = v__ast__Expr_str(right_expr)}}, {_SLIT("`"), 0, { .d_c = 0 }}})), v__ast__Expr_position(right_expr));
				_t1 = ((v__ast__Type)(0));
			}
			v__ast__Type right_type = _t1;
			right_type = v__checker__Checker_unwrap_generic(c, right_type);
			if (!v__ast__Type_alias_eq(right_type, ((v__ast__Type)(0)))) {
				v__ast__TypeSymbol* left_sym = v__ast__Table_sym(c->table, (*node._v__ast__InfixExpr).left_type);
				v__ast__TypeSymbol* right_sym = v__ast__Table_sym(c->table, right_type);
				v__ast__Type expr_type = v__checker__Checker_unwrap_generic(c, v__checker__Checker_expr(c, (*node._v__ast__InfixExpr).left));
				if (left_sym->kind == v__ast__Kind__interface_) {
					if (right_sym->kind != v__ast__Kind__interface_) {
						v__checker__Checker_type_implements(c, right_type, expr_type, (*node._v__ast__InfixExpr).pos);
					} else {
						return;
					}
				} else if (!v__checker__Checker_check_types(c, right_type, expr_type)) {
					string expect_str = v__ast__Table_type_to_str(c->table, right_type);
					string expr_str = v__ast__Table_type_to_str(c->table, expr_type);
					v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("cannot use type `"), 0xfe10, {.d_s = expect_str}}, {_SLIT("` as type `"), 0xfe10, {.d_s = expr_str}}, {_SLIT("`"), 0, { .d_c = 0 }}})), (*node._v__ast__InfixExpr).pos);
				}
				if ((((*node._v__ast__InfixExpr).left)._typ == 299 /* v.ast.Ident */ || ((*node._v__ast__InfixExpr).left)._typ == 319 /* v.ast.SelectorExpr */) && ((*node._v__ast__InfixExpr).right)._typ == 325 /* v.ast.TypeNode */) {
					bool is_variable = (((*node._v__ast__InfixExpr).left)._typ == 299 /* v.ast.Ident */ ? ((*(*node._v__ast__InfixExpr).left._v__ast__Ident).kind == v__ast__IdentKind__variable) : (true));
					if (is_variable) {
						if (left_sym->kind == v__ast__Kind__interface_ || left_sym->kind == v__ast__Kind__sum_type) {
							v__checker__Checker_smartcast(c, (*node._v__ast__InfixExpr).left, (*node._v__ast__InfixExpr).left_type, right_type, scope);
						}
					}
				}
			}
		}
	} else if ((node)._typ == 306 /* v.ast.Likely */) {
		v__checker__Checker_smartcast_if_conds(c, (*node._v__ast__Likely).expr, scope);
	}
}

void v__checker__Checker_interface_decl(v__checker__Checker* c, v__ast__InterfaceDecl* node) {
	v__checker__Checker_check_valid_pascal_case(c, node->name, _SLIT("interface name"), node->pos);
	v__ast__TypeSymbol* decl_sym = v__ast__Table_sym(c->table, node->typ);
	bool is_js = node->language == v__ast__Language__js;
	if ((decl_sym->info)._typ == 463 /* v.ast.Interface */) {
		if (node->ifaces.len > 0) {
			Array_v__ast__InterfaceEmbedding all_ifaces = v__checker__Checker_expand_iface_embeds(c, node, 0, node->ifaces);
			node->ifaces = all_ifaces;
			Map_string_int emnames = new_map(sizeof(string), sizeof(int), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
			Map_string_bool emnames_ds = new_map(sizeof(string), sizeof(bool), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
			Map_string_bool emnames_ds_info = new_map(sizeof(string), sizeof(bool), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
			Map_string_int efnames = new_map(sizeof(string), sizeof(int), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
			Map_string_bool efnames_ds_info = new_map(sizeof(string), sizeof(bool), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
			for (int i = 0; i < node->methods.len; ++i) {
				v__ast__FnDecl m = ((v__ast__FnDecl*)node->methods.data)[i];
				map_set(&emnames, &(string[]){m.name}, &(int[]) { i });
				map_set(&emnames_ds, &(string[]){m.name}, &(bool[]) { true });
				map_set(&emnames_ds_info, &(string[]){m.name}, &(bool[]) { true });
			}
			for (int i = 0; i < node->fields.len; ++i) {
				v__ast__StructField f = ((v__ast__StructField*)node->fields.data)[i];
				map_set(&efnames, &(string[]){f.name}, &(int[]) { i });
				map_set(&efnames_ds_info, &(string[]){f.name}, &(bool[]) { true });
			}
			for (int _t1 = 0; _t1 < all_ifaces.len; ++_t1) {
				v__ast__InterfaceEmbedding iface = ((v__ast__InterfaceEmbedding*)all_ifaces.data)[_t1];
				v__ast__TypeSymbol* isym = v__ast__Table_sym(c->table, iface.typ);
				if (isym->kind != v__ast__Kind__interface_) {
					v__checker__Checker_error(c,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("interface `"), 0xfe10, {.d_s = node->name}}, {_SLIT("` tries to embed `"), 0xfe10, {.d_s = isym->name}}, {_SLIT("`, but `"), 0xfe10, {.d_s = isym->name}}, {_SLIT("` is not an interface, but `"), 0xfe10, {.d_s = v__ast__Kind_str(isym->kind)}}, {_SLIT("`"), 0, { .d_c = 0 }}})), iface.pos);
					continue;
				}
				v__ast__Interface isym_info = /* as */ *(v__ast__Interface*)__as_cast((isym->info)._v__ast__Interface,(isym->info)._typ, 463) /*expected idx: 463, name: v.ast.Interface */ ;
				for (int _t2 = 0; _t2 < isym_info.fields.len; ++_t2) {
					v__ast__StructField f = ((v__ast__StructField*)isym_info.fields.data)[_t2];
					if (!(*(bool*)map_get(ADDR(map, efnames_ds_info), &(string[]){f.name}, &(bool[]){ 0 }))) {
						map_set(&efnames_ds_info, &(string[]){f.name}, &(bool[]) { true });
						array_push((array*)&(*decl_sym->info._v__ast__Interface).fields, _MOV((v__ast__StructField[]){ f }));
					}
				}
				for (int _t4 = 0; _t4 < isym_info.methods.len; ++_t4) {
					v__ast__Fn m = ((v__ast__Fn*)isym_info.methods.data)[_t4];
					if (!(*(bool*)map_get(ADDR(map, emnames_ds_info), &(string[]){m.name}, &(bool[]){ 0 }))) {
						map_set(&emnames_ds_info, &(string[]){m.name}, &(bool[]) { true });
						array_push((array*)&(*decl_sym->info._v__ast__Interface).methods, _MOV((v__ast__Fn[]){ v__ast__Fn_new_method_with_receiver_type(&m, node->typ) }));
					}
				}
				for (int _t6 = 0; _t6 < isym->methods.len; ++_t6) {
					v__ast__Fn m = ((v__ast__Fn*)isym->methods.data)[_t6];
					if (!(*(bool*)map_get(ADDR(map, emnames_ds), &(string[]){m.name}, &(bool[]){ 0 }))) {
						map_set(&emnames_ds, &(string[]){m.name}, &(bool[]) { true });
						array_push((array*)&decl_sym->methods, _MOV((v__ast__Fn[]){ v__ast__Fn_new_method_with_receiver_type(&m, node->typ) }));
					}
				}
				v__ast__InterfaceDecl* _t9 = (v__ast__InterfaceDecl*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, c->table->interfaces), &(int[]){iface.typ}));
				Option_v__ast__InterfaceDecl _t8 = {0};
				if (_t9) {
					*((v__ast__InterfaceDecl*)&_t8.data) = *((v__ast__InterfaceDecl*)_t9);
				} else {
					_t8.state = 2; _t8.err = _v_error(_SLIT("array index out of range"));
				}
				
				if (_t8.state == 0) {
					v__ast__InterfaceDecl iface_decl = *(v__ast__InterfaceDecl*)_t8.data;
					for (int _t10 = 0; _t10 < iface_decl.fields.len; ++_t10) {
						v__ast__StructField f = ((v__ast__StructField*)iface_decl.fields.data)[_t10];
						if (_IN_MAP(ADDR(string, f.name), ADDR(map, efnames))) {
							v__ast__StructField ifield = (*(v__ast__StructField*)/*ee elem_typ */array_get(node->fields, (*(int*)map_get(ADDR(map, efnames), &(string[]){f.name}, &(int[]){ 0 }))));
							Option_v__ast__StructField _t11;
							if (_t11 = v__ast__Table_find_field_with_embeds(c->table, isym, f.name), _t11.state == 0) {
								v__ast__StructField field = *(v__ast__StructField*)_t11.data;
								if (!v__ast__Type_alias_eq(ifield.typ, field.typ)) {
									string exp = v__ast__Table_type_to_str(c->table, ifield.typ);
									string got = v__ast__Table_type_to_str(c->table, field.typ);
									v__checker__Checker_error(c,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("embedded interface `"), 0xfe10, {.d_s = iface_decl.name}}, {_SLIT("` conflicts existing field: `"), 0xfe10, {.d_s = ifield.name}}, {_SLIT("`, expecting type: `"), 0xfe10, {.d_s = exp}}, {_SLIT("`, got type: `"), 0xfe10, {.d_s = got}}, {_SLIT("`"), 0, { .d_c = 0 }}})), ifield.pos);
								}
							}
						} else {
							map_set(&efnames, &(string[]){f.name}, &(int[]) { node->fields.len });
							array_push((array*)&node->fields, _MOV((v__ast__StructField[]){ f }));
						}
					}
					for (int _t13 = 0; _t13 < iface_decl.methods.len; ++_t13) {
						v__ast__FnDecl m = ((v__ast__FnDecl*)iface_decl.methods.data)[_t13];
						if (_IN_MAP(ADDR(string, m.name), ADDR(map, emnames))) {
							v__ast__FnDecl imethod = (*(v__ast__FnDecl*)/*ee elem_typ */array_get(node->methods, (*(int*)map_get(ADDR(map, emnames), &(string[]){m.name}, &(int[]){ 0 }))));
							Option_v__ast__Fn _t14;
							if (_t14 = v__ast__TypeSymbol_find_method(decl_sym, imethod.name), _t14.state == 0) {
								v__ast__Fn em_fn = *(v__ast__Fn*)_t14.data;
								Option_v__ast__Fn _t15;
								if (_t15 = v__ast__TypeSymbol_find_method(isym, m.name), _t15.state == 0) {
									v__ast__Fn m_fn = *(v__ast__Fn*)_t15.data;
									string msg = v__ast__Table_is_same_method(c->table, (voidptr)&/*qq*/m_fn, (voidptr)&/*qq*/em_fn);
									if (msg.len > 0) {
										string em_sig = v__ast__Table_fn_signature(c->table, (voidptr)&/*qq*/em_fn, (v__ast__FnSignatureOpts){.skip_receiver = true,.type_only = 0,});
										string m_sig = v__ast__Table_fn_signature(c->table, (voidptr)&/*qq*/m_fn, (v__ast__FnSignatureOpts){.skip_receiver = true,.type_only = 0,});
										v__checker__Checker_error(c,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("embedded interface `"), 0xfe10, {.d_s = iface_decl.name}}, {_SLIT("` causes conflict: "), 0xfe10, {.d_s = msg}}, {_SLIT(", for interface method `"), 0xfe10, {.d_s = em_sig}}, {_SLIT("` vs `"), 0xfe10, {.d_s = m_sig}}, {_SLIT("`"), 0, { .d_c = 0 }}})), imethod.pos);
									}
								}
							}
						} else {
							map_set(&emnames, &(string[]){m.name}, &(int[]) { node->methods.len });
							v__ast__FnDecl new_method = v__ast__FnDecl_new_method_with_receiver_type(&m, node->typ);
							new_method.pos = iface.pos;
							array_push((array*)&node->methods, _MOV((v__ast__FnDecl[]){ new_method }));
						}
					}
				}
			}
		}
		for (int i = 0; i < node->methods.len; ++i) {
			v__ast__FnDecl method = ((v__ast__FnDecl*)node->methods.data)[i];
			if (node->language == v__ast__Language__v) {
				v__checker__Checker_check_valid_snake_case(c, method.name, _SLIT("method name"), method.pos);
			}
			Option_void _t17 = v__checker__Checker_ensure_type_exists(c, method.return_type, method.return_type_pos);
			if (_t17.state != 0 && _t17.err._typ != _IError_None___index) {
				IError err = _t17.err;
				return;
			}
			
 ;
			if (is_js) {
				v__ast__TypeSymbol* mtyp = v__ast__Table_sym(c->table, method.return_type);
				if (!v__ast__TypeSymbol_is_js_compatible(mtyp)) {
					v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("method "), 0xfe10, {.d_s = method.name}}, {_SLIT(" returns non JS type"), 0, { .d_c = 0 }}})), method.pos);
				}
			}
			for (int j = 0; j < method.params.len; ++j) {
				v__ast__Param param = ((v__ast__Param*)method.params.data)[j];
				if (j == 0 && is_js) {
					continue;
				}
				Option_void _t18 = v__checker__Checker_ensure_type_exists(c, param.typ, param.pos);
				if (_t18.state != 0 && _t18.err._typ != _IError_None___index) {
					IError err = _t18.err;
					return;
				}
				
 ;
				if (Array_string_contains(_const_v__checker__reserved_type_names, param.name)) {
					v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("invalid use of reserved type `"), 0xfe10, {.d_s = param.name}}, {_SLIT("` as a parameter name"), 0, { .d_c = 0 }}})), param.pos);
				}
				if (is_js) {
					v__ast__TypeSymbol* ptyp = v__ast__Table_sym(c->table, param.typ);
					if (!v__ast__TypeSymbol_is_js_compatible(ptyp) && !(j == method.params.len - 1 && method.is_variadic)) {
						v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("method `"), 0xfe10, {.d_s = method.name}}, {_SLIT("` accepts non JS type as parameter"), 0, { .d_c = 0 }}})), method.pos);
					}
				}
			}
			for (int _t19 = 0; _t19 < node->fields.len; ++_t19) {
				v__ast__StructField field = ((v__ast__StructField*)node->fields.data)[_t19];
				v__ast__TypeSymbol* field_sym = v__ast__Table_sym(c->table, field.typ);
				if (string__eq(field.name, method.name) && field_sym->kind == v__ast__Kind__function) {
					v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("type `"), 0xfe10, {.d_s = decl_sym->name}}, {_SLIT("` has both field and method named `"), 0xfe10, {.d_s = method.name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), method.pos);
				}
			}
			for (int j = 0; j < i; ++j) {
				if (string__eq(method.name, (*(v__ast__FnDecl*)/*ee elem_typ */array_get(node->methods, j)).name)) {
					v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("duplicate method name `"), 0xfe10, {.d_s = method.name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), method.pos);
				}
			}
		}
		for (int i = 0; i < node->fields.len; ++i) {
			v__ast__StructField field = ((v__ast__StructField*)node->fields.data)[i];
			if (node->language == v__ast__Language__v) {
				v__checker__Checker_check_valid_snake_case(c, field.name, _SLIT("field name"), field.pos);
			}
			Option_void _t20 = v__checker__Checker_ensure_type_exists(c, field.typ, field.pos);
			if (_t20.state != 0 && _t20.err._typ != _IError_None___index) {
				IError err = _t20.err;
				return;
			}
			
 ;
			if (is_js) {
				v__ast__TypeSymbol* tsym = v__ast__Table_sym(c->table, field.typ);
				if (!v__ast__TypeSymbol_is_js_compatible(tsym)) {
					v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("field `"), 0xfe10, {.d_s = field.name}}, {_SLIT("` uses non JS type"), 0, { .d_c = 0 }}})), field.pos);
				}
			}
			if (v__ast__Type_alias_eq(field.typ, node->typ) && node->language != v__ast__Language__js) {
				v__checker__Checker_error(c, _SLIT("recursive interface fields are not allowed because they cannot be initialised"), field.type_pos);
			}
			for (int j = 0; j < i; ++j) {
				if (string__eq(field.name, (*(v__ast__StructField*)/*ee elem_typ */array_get(node->fields, j)).name)) {
					v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("field name `"), 0xfe10, {.d_s = field.name}}, {_SLIT("` duplicate"), 0, { .d_c = 0 }}})), field.pos);
				}
			}
		}
	}
}

VV_LOCAL_SYMBOL v__ast__Type v__checker__Checker_resolve_generic_interface(v__checker__Checker* c, v__ast__Type typ, v__ast__Type interface_type, v__token__Position pos) {
	v__ast__Type utyp = v__checker__Checker_unwrap_generic(c, typ);
	v__ast__TypeSymbol* typ_sym = v__ast__Table_sym(c->table, utyp);
	v__ast__TypeSymbol* inter_sym = v__ast__Table_sym(c->table, interface_type);
	if ((inter_sym->info)._typ == 463 /* v.ast.Interface */) {
		if ((*inter_sym->info._v__ast__Interface).is_generic) {
			Array_v__ast__Type inferred_types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
			Array_string _t1 = __new_array(0, 0, sizeof(string));
			Array_v__ast__Type _t1_orig = (*inter_sym->info._v__ast__Interface).generic_types;
			int _t1_len = _t1_orig.len;
			_t1 = __new_array(0, _t1_len, sizeof(string));

			for (int _t2 = 0; _t2 < _t1_len; ++_t2) {
				v__ast__Type it = ((v__ast__Type*) _t1_orig.data)[_t2];
				string ti = v__ast__Table_get_type_name(c->table, it);
				array_push((array*)&_t1, &ti);
			}
			Array_string generic_names =_t1;
			for (int _t3 = 0; _t3 < generic_names.len; ++_t3) {
				string gt_name = ((string*)generic_names.data)[_t3];
				v__ast__Type inferred_type = _const_v__ast__void_type;
				for (int _t4 = 0; _t4 < (*inter_sym->info._v__ast__Interface).fields.len; ++_t4) {
					v__ast__StructField ifield = ((v__ast__StructField*)(*inter_sym->info._v__ast__Interface).fields.data)[_t4];
					if (v__ast__Type_has_flag(ifield.typ, v__ast__TypeFlag__generic) && string__eq(v__ast__Table_get_type_name(c->table, ifield.typ), gt_name)) {
						Option_v__ast__StructField _t5;
						if (_t5 = v__ast__Table_find_field_with_embeds(c->table, typ_sym, ifield.name), _t5.state == 0) {
							v__ast__StructField field = *(v__ast__StructField*)_t5.data;
							inferred_type = field.typ;
						}
					}
				}
				for (int _t6 = 0; _t6 < (*inter_sym->info._v__ast__Interface).methods.len; ++_t6) {
					v__ast__Fn imethod = ((v__ast__Fn*)(*inter_sym->info._v__ast__Interface).methods.data)[_t6];
					Option_v__ast__Fn _t7 = v__ast__TypeSymbol_find_method(typ_sym, imethod.name);
					if (_t7.state != 0) { /*or block*/ 
						IError err = _t7.err;
						Option_v__ast__Fn _t8 = v__ast__TypeSymbol_find_method_with_generic_parent(typ_sym, imethod.name);
						if (_t8.state != 0) { /*or block*/ 
							err = _t8.err;
							v__checker__Checker_error(c,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("can not find method `"), 0xfe10, {.d_s = imethod.name}}, {_SLIT("` on `"), 0xfe10, {.d_s = typ_sym->name}}, {_SLIT("`, needed for interface: `"), 0xfe10, {.d_s = inter_sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), pos);
							v__ast__Type _t9 = 0;
							return _t9;
						}
						
 						*(v__ast__Fn*) _t7.data =  (*(v__ast__Fn*)_t8.data);
					}
					
 					v__ast__Fn method =  (*(v__ast__Fn*)_t7.data);
					if (v__ast__Type_has_flag(imethod.return_type, v__ast__TypeFlag__generic)) {
						v__ast__TypeSymbol* imret_sym = v__ast__Table_sym(c->table, imethod.return_type);
						v__ast__TypeSymbol* mret_sym = v__ast__Table_sym(c->table, method.return_type);
						if (v__ast__Type_alias_eq(method.return_type, _const_v__ast__void_type) && !v__ast__Type_alias_eq(imethod.return_type, method.return_type)) {
							v__checker__Checker_error(c,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("interface method `"), 0xfe10, {.d_s = imethod.name}}, {_SLIT("` returns `"), 0xfe10, {.d_s = imret_sym->name}}, {_SLIT("`, but implementation method `"), 0xfe10, {.d_s = method.name}}, {_SLIT("` returns no value"), 0, { .d_c = 0 }}})), pos);
							v__ast__Type _t10 = 0;
							return _t10;
						}
						if (v__ast__Type_alias_eq(imethod.return_type, _const_v__ast__void_type) && !v__ast__Type_alias_eq(imethod.return_type, method.return_type)) {
							v__checker__Checker_error(c,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("interface method `"), 0xfe10, {.d_s = imethod.name}}, {_SLIT("` returns no value, but implementation method `"), 0xfe10, {.d_s = method.name}}, {_SLIT("` returns `"), 0xfe10, {.d_s = mret_sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), pos);
							v__ast__Type _t11 = 0;
							return _t11;
						}
						if ((imret_sym->info)._typ == 471 /* v.ast.MultiReturn */ && (mret_sym->info)._typ == 471 /* v.ast.MultiReturn */) {
							for (int i = 0; i < (*imret_sym->info._v__ast__MultiReturn).types.len; ++i) {
								v__ast__Type mr_typ = ((v__ast__Type*)(*imret_sym->info._v__ast__MultiReturn).types.data)[i];
								if (v__ast__Type_has_flag(mr_typ, v__ast__TypeFlag__generic) && string__eq(v__ast__Table_get_type_name(c->table, mr_typ), gt_name)) {
									inferred_type = (*(v__ast__Type*)/*ee elem_typ */array_get((*mret_sym->info._v__ast__MultiReturn).types, i));
								}
							}
						} else if (string__eq(v__ast__Table_get_type_name(c->table, imethod.return_type), gt_name)) {
							v__ast__Type ret_typ = method.return_type;
							if (v__ast__Type_has_flag(imethod.return_type, v__ast__TypeFlag__optional)) {
								ret_typ = v__ast__Type_clear_flag(ret_typ, v__ast__TypeFlag__optional);
							}
							inferred_type = ret_typ;
						}
					}
					for (int i = 0; i < imethod.params.len; ++i) {
						v__ast__Param iparam = ((v__ast__Param*)imethod.params.data)[i];
						v__ast__Param* _t13 = (v__ast__Param*)/*ee elem_ptr_typ */(array_get_with_check(method.params, i));
						Option_v__ast__Param _t12 = {0};
						if (_t13) {
							*((v__ast__Param*)&_t12.data) = *((v__ast__Param*)_t13);
						} else {
							_t12.state = 2; _t12.err = _v_error(_SLIT("array index out of range"));
						}
						;
						if (_t12.state != 0) { /*or block*/ 
							IError err = _t12.err;
							*(v__ast__Param*) _t12.data = (v__ast__Param){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.name = (string){.str=(byteptr)"", .is_lit=1},.is_mut = 0,.is_auto_rec = 0,.type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.is_hidden = 0,.typ = 0,};
						}
						
						v__ast__Param param = *(v__ast__Param*)_t12.data;
						if (v__ast__Type_has_flag(iparam.typ, v__ast__TypeFlag__generic) && string__eq(v__ast__Table_get_type_name(c->table, iparam.typ), gt_name)) {
							inferred_type = param.typ;
						}
					}
				}
				if (v__ast__Type_alias_eq(inferred_type, _const_v__ast__void_type)) {
					v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("could not infer generic type `"), 0xfe10, {.d_s = gt_name}}, {_SLIT("` in interface `"), 0xfe10, {.d_s = inter_sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), pos);
					v__ast__Type _t14 = interface_type;
					return _t14;
				}
				array_push((array*)&inferred_types, _MOV((v__ast__Type[]){ inferred_type }));
			}
			for (int _t16 = 0; _t16 < (*inter_sym->info._v__ast__Interface).methods.len; ++_t16) {
				v__ast__Fn imethod = ((v__ast__Fn*)(*inter_sym->info._v__ast__Interface).methods.data)[_t16];
				string im_fkey = v__ast__Fn_fkey(&imethod);
				if (!Array_Array_v__ast__Type_contains((*(Array_Array_v__ast__Type*)map_get(ADDR(map, c->table->fn_generic_types), &(string[]){im_fkey}, &(Array_Array_v__ast__Type[]){ __new_array(0, 0, sizeof(Array_v__ast__Type)) })), inferred_types)) {
					array_push((array*)&(*(Array_Array_v__ast__Type*)map_get_and_set((map*)&c->table->fn_generic_types, &(string[]){im_fkey}, &(Array_Array_v__ast__Type[]){ __new_array(0, 0, sizeof(Array_v__ast__Type)) })), _MOV((Array_v__ast__Type[]){ inferred_types }));
				}
			}
			(*inter_sym->info._v__ast__Interface).concrete_types = inferred_types;
			v__ast__Type _t18 = v__ast__Table_unwrap_generic_type(c->table, interface_type, generic_names, (*inter_sym->info._v__ast__Interface).concrete_types);
			return _t18;
		}
	}
	v__ast__Type _t19 = interface_type;
	return _t19;
}

v__ast__Type v__checker__Checker_match_expr(v__checker__Checker* c, v__ast__MatchExpr* node) {
	node->is_expr = !v__ast__Type_alias_eq(c->expected_type, _const_v__ast__void_type);
	node->expected_type = c->expected_type;
	v__ast__Type cond_type = v__checker__Checker_expr(c, node->cond);
	node->cond_type = v__ast__mktyp(cond_type);
	Option_void _t1 = v__checker__Checker_ensure_type_exists(c, node->cond_type, node->pos);
	if (_t1.state != 0 && _t1.err._typ != _IError_None___index) {
		IError err = _t1.err;
		v__ast__Type _t2 = _const_v__ast__void_type;
		return _t2;
	}
	
 ;
	v__checker__Checker_check_expr_opt_call(c, node->cond, cond_type);
	v__ast__TypeSymbol* cond_type_sym = v__ast__Table_sym(c->table, cond_type);
	node->is_sum_type = (cond_type_sym->kind == v__ast__Kind__interface_ || cond_type_sym->kind == v__ast__Kind__sum_type);
	v__checker__Checker_match_exprs(c, node, *cond_type_sym);
	c->expected_type = cond_type;
	bool first_iteration = true;
	v__ast__Type ret_type = _const_v__ast__void_type;
	int nbranches_with_return = 0;
	int nbranches_without_return = 0;
	for (int _t3 = 0; _t3 < node->branches.len; ++_t3) {
		v__ast__MatchBranch branch = ((v__ast__MatchBranch*)node->branches.data)[_t3];
		if (node->is_expr) {
			v__checker__Checker_stmts_ending_with_expression(c, branch.stmts);
		} else {
			v__checker__Checker_stmts(c, branch.stmts);
		}
		if (node->is_expr) {
			if (branch.stmts.len > 0) {
				Array_v__ast__Stmt _t4 = array_slice(branch.stmts, 0, branch.stmts.len - 1);
				for (int _t5 = 0; _t5 < _t4.len; ++_t5) {
					v__ast__Stmt st = ((v__ast__Stmt*)_t4.data)[_t5];
					Option_void _t6 = v__ast__Stmt_check_c_expr(st);
					if (_t6.state != 0 && _t6.err._typ != _IError_None___index) {
						IError err = _t6.err;
						v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("`match` expression branch has "), 0xfe10, {.d_s = (*(err.msg))}}, {_SLIT0, 0, { .d_c = 0 }}})), (*(st.pos)));
					;
					}
					
 ;
				}
			} else if (!v__ast__Type_alias_eq(ret_type, _const_v__ast__void_type)) {
				v__checker__Checker_error(c, _SLIT("`match` expression requires an expression as the last statement of every branch"), branch.branch_pos);
			}
		}
		if (branch.stmts.len > 0) {
			v__ast__Stmt stmt = (*(v__ast__Stmt*)/*ee elem_typ */array_get(branch.stmts, branch.stmts.len - 1));
			if (stmt._typ == 339 /* v.ast.ExprStmt */) {
				if (node->is_expr) {
					c->expected_type = node->expected_type;
				}
				v__ast__Type expr_type = v__checker__Checker_expr(c, (*stmt._v__ast__ExprStmt).expr);
				if (first_iteration) {
					if (node->is_expr && (v__ast__Type_has_flag(node->expected_type, v__ast__TypeFlag__optional) || v__ast__Table_type_kind(c->table, node->expected_type) == v__ast__Kind__sum_type)) {
						ret_type = node->expected_type;
					} else {
						ret_type = expr_type;
					}
					(*stmt._v__ast__ExprStmt).typ = expr_type;
				} else if (node->is_expr && v__ast__Type_idx(ret_type) != v__ast__Type_idx(expr_type)) {
					if (!v__checker__Checker_check_types(c, ret_type, expr_type) && !v__checker__Checker_check_types(c, expr_type, ret_type)) {
						v__ast__TypeSymbol* ret_sym = v__ast__Table_sym(c->table, ret_type);
						bool is_noreturn = v__checker__is_noreturn_callexpr((*stmt._v__ast__ExprStmt).expr);
						if (!(node->is_expr && ret_sym->kind == v__ast__Kind__sum_type) && !is_noreturn) {
							v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("return type mismatch, it should be `"), 0xfe10, {.d_s = ret_sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), v__ast__Expr_position((*stmt._v__ast__ExprStmt).expr));
						}
					}
				}
			}
			
			else {
				if (node->is_expr && !v__ast__Type_alias_eq(ret_type, _const_v__ast__void_type)) {
					v__checker__Checker_error(c, _SLIT("`match` expression requires an expression as the last statement of every branch"), (*(stmt.pos)));
				}
			}
			;
		}
		first_iteration = false;
		Option_bool _t7;
		if (_t7 = v__checker__Checker_has_return(c, branch.stmts), _t7.state == 0) {
			bool has_return = *(bool*)_t7.data;
			if (has_return) {
				nbranches_with_return++;
			} else {
				nbranches_without_return++;
			}
		}
	}
	if (nbranches_with_return > 0) {
		if (nbranches_with_return == node->branches.len) {
			c->returns = true;
		}
		if (nbranches_without_return > 0) {
			c->returns = false;
		}
	}
	node->return_type = ret_type;
	string cond_var = v__checker__Checker_get_base_name(c, &node->cond);
	if ((cond_var).len != 0) {
		bool cond_is_auto_heap = false;
		for (int _t8 = 0; _t8 < node->branches.len; ++_t8) {
			v__ast__MatchBranch branch = ((v__ast__MatchBranch*)node->branches.data)[_t8];
			Option_v__ast__Var_ptr _t9;
			if (_t9 = v__ast__Scope_find_var(branch.scope, cond_var), _t9.state == 0) {
				v__ast__Var* v = *(v__ast__Var**)_t9.data;
				if (v->is_auto_heap) {
					cond_is_auto_heap = true;
					break;
				}
			}
		}
		if (cond_is_auto_heap) {
			for (int _t10 = 0; _t10 < node->branches.len; ++_t10) {
				v__ast__MatchBranch branch = ((v__ast__MatchBranch*)node->branches.data)[_t10];
				Option_v__ast__Var_ptr _t11 = v__ast__Scope_find_var(branch.scope, cond_var);
				if (_t11.state != 0) { /*or block*/ 
					IError err = _t11.err;
					continue;
				}
				
 				v__ast__Var* v =  (*(v__ast__Var**)_t11.data);
				v->is_auto_heap = true;
			}
		}
	}
	v__ast__Type _t12 = ret_type;
	return _t12;
}

VV_LOCAL_SYMBOL void v__checker__Checker_match_exprs(v__checker__Checker* c, v__ast__MatchExpr* node, v__ast__TypeSymbol cond_type_sym) {
	Map_string_int branch_exprs = new_map(sizeof(string), sizeof(int), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
	for (int branch_i = 0; branch_i < node->branches.len; ++branch_i) {
		v__ast__MatchBranch branch = (*(v__ast__MatchBranch*)/*ee elem_typ */array_get(node->branches, branch_i));
		Array_v__ast__TypeNode expr_types = __new_array_with_default(0, 0, sizeof(v__ast__TypeNode), 0);
		for (int k = 0; k < branch.exprs.len; ++k) {
			v__ast__Expr expr = ((v__ast__Expr*)branch.exprs.data)[k];
			string key = _SLIT("");
			if ((expr)._typ == 317 /* v.ast.RangeExpr */) {
				i64 low = ((i64)(0));
				i64 high = ((i64)(0));
				c->expected_type = node->expected_type;
				v__ast__Expr low_expr = (*expr._v__ast__RangeExpr).low;
				v__ast__Expr high_expr = (*expr._v__ast__RangeExpr).high;
				if ((low_expr)._typ == 304 /* v.ast.IntegerLiteral */) {
					if ((high_expr)._typ == 304 /* v.ast.IntegerLiteral */ && (v__ast__TypeSymbol_is_int(&cond_type_sym) || (cond_type_sym.info)._typ == 474 /* v.ast.Enum */)) {
						low = string_i64((*low_expr._v__ast__IntegerLiteral).val);
						high = string_i64((*high_expr._v__ast__IntegerLiteral).val);
						if (low > high) {
							v__checker__Checker_error(c, _SLIT("start value is higher than end value"), branch.pos);
						}
					} else {
						v__checker__Checker_error(c, _SLIT("mismatched range types"), (*low_expr._v__ast__IntegerLiteral).pos);
					}
				} else if ((low_expr)._typ == 289 /* v.ast.CharLiteral */) {
					if ((high_expr)._typ == 289 /* v.ast.CharLiteral */ && (cond_type_sym.kind == v__ast__Kind__byte || cond_type_sym.kind == v__ast__Kind__char || cond_type_sym.kind == v__ast__Kind__rune)) {
						low = string_at((*low_expr._v__ast__CharLiteral).val, 0);
						high = string_at((*high_expr._v__ast__CharLiteral).val, 0);
						if (low > high) {
							v__checker__Checker_error(c, _SLIT("start value is higher than end value"), branch.pos);
						}
					} else {
						v__checker__Checker_error(c, _SLIT("mismatched range types"), (*low_expr._v__ast__CharLiteral).pos);
					}
				} else {
					string typ = v__ast__Table_type_to_str(c->table, v__checker__Checker_expr(c, (*expr._v__ast__RangeExpr).low));
					v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot use type `"), 0xfe10, {.d_s = typ}}, {_SLIT("` in match range"), 0, { .d_c = 0 }}})), branch.pos);
				}
				int high_low_cutoff = 1000;
				if (high - low > high_low_cutoff) {
					v__checker__Checker_warn(c,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("more than "), 0xfe07, {.d_i32 = high_low_cutoff}}, {_SLIT(" possibilities ("), 0xfe09, {.d_i64 = low}}, {_SLIT(" ... "), 0xfe09, {.d_i64 = high}}, {_SLIT(") in match range"), 0, { .d_c = 0 }}})), branch.pos);
				}
				for (i64 i = low; i < high + 1; ++i) {
					key = i64_str(i);
					int val = (_IN_MAP(ADDR(string, key), ADDR(map, branch_exprs)) ? ((*(int*)map_get(ADDR(map, branch_exprs), &(string[]){key}, &(int[]){ 0 }))) : (0));
					if (val == 1) {
						v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("match case `"), 0xfe10, {.d_s = key}}, {_SLIT("` is handled more than once"), 0, { .d_c = 0 }}})), branch.pos);
					}
					map_set(&branch_exprs, &(string[]){key}, &(int[]) { val + 1 });
				}
				continue;
			}
			if (expr._typ == 325 /* v.ast.TypeNode */) {
				key = v__ast__Table_type_to_str(c->table, (*expr._v__ast__TypeNode).typ);
				array_push((array*)&expr_types, _MOV((v__ast__TypeNode[]){ (*expr._v__ast__TypeNode) }));
			}
			else if (expr._typ == 296 /* v.ast.EnumVal */) {
				key = (*expr._v__ast__EnumVal).val;
			}
			
			else {
				key = v__ast__Expr_str(expr);
			}
			;
			int val = (_IN_MAP(ADDR(string, key), ADDR(map, branch_exprs)) ? ((*(int*)map_get(ADDR(map, branch_exprs), &(string[]){key}, &(int[]){ 0 }))) : (0));
			if (val == 1) {
				v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("match case `"), 0xfe10, {.d_s = key}}, {_SLIT("` is handled more than once"), 0, { .d_c = 0 }}})), branch.pos);
			}
			c->expected_type = node->cond_type;
			v__ast__Type expr_type = v__checker__Checker_expr(c, expr);
			if (v__ast__Type_idx(expr_type) == 0) {
				return;
			}
			v__ast__TypeSymbol* expr_type_sym = v__ast__Table_sym(c->table, expr_type);
			if (cond_type_sym.kind == v__ast__Kind__interface_) {
				v__token__Position expr_pos = v__ast__Expr_position(expr);
				if (v__checker__Checker_type_implements(c, expr_type, c->expected_type, expr_pos)) {
					if (!v__ast__Type_is_ptr(expr_type) && !v__ast__Type_is_pointer(expr_type) && !c->inside_unsafe) {
						if (expr_type_sym->kind != v__ast__Kind__interface_) {
							v__checker__Checker_mark_as_referenced(c, &(*(v__ast__Expr*)/*ee elem_typ */array_get(branch.exprs, k)), true);
						}
					}
				}
			} else if ((cond_type_sym.info)._typ == 464 /* v.ast.SumType */) {
				if (!Array_v__ast__Type_contains((*cond_type_sym.info._v__ast__SumType).variants, expr_type)) {
					string expr_str = v__ast__Table_type_to_str(c->table, expr_type);
					string expect_str = v__ast__Table_type_to_str(c->table, node->cond_type);
					v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = expect_str}}, {_SLIT("` has no variant `"), 0xfe10, {.d_s = expr_str}}, {_SLIT("`"), 0, { .d_c = 0 }}})), v__ast__Expr_position(expr));
				}
			} else if ((cond_type_sym.info)._typ == 460 /* v.ast.Alias */ && (expr_type_sym->info)._typ == 446 /* v.ast.Struct */) {
				string expr_str = v__ast__Table_type_to_str(c->table, expr_type);
				string expect_str = v__ast__Table_type_to_str(c->table, node->cond_type);
				v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("cannot match alias type `"), 0xfe10, {.d_s = expect_str}}, {_SLIT("` with `"), 0xfe10, {.d_s = expr_str}}, {_SLIT("`"), 0, { .d_c = 0 }}})), v__ast__Expr_position(expr));
			} else if (!v__checker__Checker_check_types(c, expr_type, node->cond_type)) {
				string expr_str = v__ast__Table_type_to_str(c->table, expr_type);
				string expect_str = v__ast__Table_type_to_str(c->table, node->cond_type);
				v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("cannot match `"), 0xfe10, {.d_s = expect_str}}, {_SLIT("` with `"), 0xfe10, {.d_s = expr_str}}, {_SLIT("`"), 0, { .d_c = 0 }}})), v__ast__Expr_position(expr));
			}
			map_set(&branch_exprs, &(string[]){key}, &(int[]) { val + 1 });
		}
		if (expr_types.len > 0) {
			if (cond_type_sym.kind == v__ast__Kind__sum_type || cond_type_sym.kind == v__ast__Kind__interface_) {
				v__ast__Type expr_type = ((v__ast__Type)(0));
				if (expr_types.len > 1) {
					strings__Builder agg_name = strings__new_builder(20);
					strings__Builder agg_cname = strings__new_builder(20);
					strings__Builder_write_string(&agg_name, _SLIT("("));
					for (int i = 0; i < expr_types.len; ++i) {
						v__ast__TypeNode expr = ((v__ast__TypeNode*)expr_types.data)[i];
						if (i > 0) {
							strings__Builder_write_string(&agg_name, _SLIT(" | "));
							strings__Builder_write_string(&agg_cname, _SLIT("___"));
						}
						string type_str = v__ast__Table_type_to_str(c->table, expr.typ);
						string name = (c->is_builtin_mod ? (type_str) : ( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = c->mod}}, {_SLIT("."), 0xfe10, {.d_s = type_str}}, {_SLIT0, 0, { .d_c = 0 }}}))));
						strings__Builder_write_string(&agg_name, name);
						strings__Builder_write_string(&agg_cname, v__util__no_dots(name));
					}
					strings__Builder_write_string(&agg_name, _SLIT(")"));
					string name = strings__Builder_str(&agg_name);
					int existing_idx = (*(int*)map_get(ADDR(map, c->table->type_idxs), &(string[]){name}, &(int[]){ 0 }));
					if (existing_idx > 0) {
						expr_type = existing_idx;
					} else {
						Array_v__ast__Type _t2 = __new_array(0, 0, sizeof(v__ast__Type));
						Array_v__ast__TypeNode _t2_orig = expr_types;
						int _t2_len = _t2_orig.len;
						_t2 = __new_array(0, _t2_len, sizeof(v__ast__Type));

						for (int _t3 = 0; _t3 < _t2_len; ++_t3) {
							v__ast__TypeNode it = ((v__ast__TypeNode*) _t2_orig.data)[_t3];
							v__ast__Type ti = it.typ;
							array_push((array*)&_t2, &ti);
						}
						expr_type = v__ast__Table_register_type_symbol(c->table, (v__ast__TypeSymbol){.parent_idx = 0,.info = v__ast__Aggregate_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__Aggregate, ((v__ast__Aggregate){.fields = __new_array(0, 0, sizeof(v__ast__StructField)),.types =_t2,}))),.kind = v__ast__Kind__aggregate,.name = name,.cname = strings__Builder_str(&agg_cname),.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = c->mod,.is_public = 0,.language = 0,.idx = 0,});
					}
				} else {
					expr_type = (*(v__ast__TypeNode*)/*ee elem_typ */array_get(expr_types, 0)).typ;
				}
				v__checker__Checker_smartcast(c, node->cond, node->cond_type, expr_type, branch.scope);
			}
		}
	}
	bool is_exhaustive = true;
	Array_string unhandled = __new_array_with_default(0, 0, sizeof(string), 0);
	if (v__ast__Type_alias_eq(node->cond_type, _const_v__ast__bool_type)) {
		Array_string variants = new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT("true"), _SLIT("false")}));
		for (int _t4 = 0; _t4 < variants.len; ++_t4) {
			string v = ((string*)variants.data)[_t4];
			if (!_IN_MAP(ADDR(string, v), ADDR(map, branch_exprs))) {
				is_exhaustive = false;
				array_push((array*)&unhandled, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = v}}, {_SLIT("`"), 0, { .d_c = 0 }}}))) }));
			}
		}
	} else {
		if (cond_type_sym.info._typ == 464 /* v.ast.SumType */) {
			for (int _t6 = 0; _t6 < (*cond_type_sym.info._v__ast__SumType).variants.len; ++_t6) {
				v__ast__Type v = ((v__ast__Type*)(*cond_type_sym.info._v__ast__SumType).variants.data)[_t6];
				string v_str = v__ast__Table_type_to_str(c->table, v);
				if (!_IN_MAP(ADDR(string, v_str), ADDR(map, branch_exprs))) {
					is_exhaustive = false;
					array_push((array*)&unhandled, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = v_str}}, {_SLIT("`"), 0, { .d_c = 0 }}}))) }));
				}
			}
		}
		else if (cond_type_sym.info._typ == 474 /* v.ast.Enum */) {
			for (int _t8 = 0; _t8 < (*cond_type_sym.info._v__ast__Enum).vals.len; ++_t8) {
				string v = ((string*)(*cond_type_sym.info._v__ast__Enum).vals.data)[_t8];
				if (!_IN_MAP(ADDR(string, v), ADDR(map, branch_exprs))) {
					is_exhaustive = false;
					array_push((array*)&unhandled, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("`."), 0xfe10, {.d_s = v}}, {_SLIT("`"), 0, { .d_c = 0 }}}))) }));
				}
			}
		}
		
		else {
			is_exhaustive = false;
		}
		;
	}
	v__ast__MatchBranch else_branch = (*(v__ast__MatchBranch*)/*ee elem_typ */array_get(node->branches, node->branches.len - 1));
	bool has_else = else_branch.is_else;
	if (!has_else) {
		for (int i = 0; i < node->branches.len; ++i) {
			v__ast__MatchBranch branch = ((v__ast__MatchBranch*)node->branches.data)[i];
			if (branch.is_else && i != node->branches.len - 1) {
				v__checker__Checker_error(c, _SLIT("`else` must be the last branch of `match`"), branch.pos);
				else_branch = branch;
				has_else = true;
			}
		}
	}
	if (is_exhaustive) {
		if (has_else && !c->pref->translated) {
			v__checker__Checker_error(c, _SLIT("match expression is exhaustive, `else` is unnecessary"), else_branch.pos);
		}
		return;
	}
	if (has_else) {
		return;
	}
	string err_details = _SLIT("match must be exhaustive");
	if (unhandled.len > 0) {
		err_details = /*f*/string__plus(err_details, _SLIT(" (add match branches for: "));
		if (unhandled.len < c->match_exhaustive_cutoff_limit) {
			err_details = /*f*/string__plus(err_details, Array_string_join(unhandled, _SLIT(", ")));
		} else {
			int remaining = unhandled.len - c->match_exhaustive_cutoff_limit;
			err_details = /*f*/string__plus(err_details, Array_string_join(array_slice(unhandled, 0, c->match_exhaustive_cutoff_limit), _SLIT(", ")));
			if (remaining > 0) {
				err_details = /*f*/string__plus(err_details,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(", and "), 0xfe07, {.d_i32 = remaining}}, {_SLIT(" others ..."), 0, { .d_c = 0 }}})));
			}
		}
		err_details = /*f*/string__plus(err_details, _SLIT(" or `else {}` at the end)"));
	} else {
		err_details = /*f*/string__plus(err_details, _SLIT(" (add `else {}` at the end)"));
	}
	v__checker__Checker_error(c, err_details, node->pos);
}

VV_LOCAL_SYMBOL v__ast__Type v__checker__Checker_sql_expr(v__checker__Checker* c, v__ast__SqlExpr* node) {
bool v__checker__Checker_sql_expr_defer_0 = false;
	c->inside_sql = true;
	v__checker__Checker_sql_expr_defer_0 = true;
	v__ast__TypeSymbol* sym = v__ast__Table_sym(c->table, node->table_expr.typ);
	Option_void _t1 = v__checker__Checker_ensure_type_exists(c, node->table_expr.typ, node->pos);
	if (_t1.state != 0 && _t1.err._typ != _IError_None___index) {
		IError err = _t1.err;
		v__ast__Type _t2 = _const_v__ast__void_type;
		// Defer begin
		if (v__checker__Checker_sql_expr_defer_0) {
			c->inside_sql = false;
		}
		// Defer end
		return _t2;
	}
	
 ;
	c->cur_orm_ts = *sym;
	if ((sym->info)._typ != 446 /* v.ast.Struct */) {
		v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("The table symbol `"), 0xfe10, {.d_s = sym->name}}, {_SLIT("` has to be a struct"), 0, { .d_c = 0 }}})), node->table_expr.pos);
		v__ast__Type _t3 = _const_v__ast__void_type;
		// Defer begin
		if (v__checker__Checker_sql_expr_defer_0) {
			c->inside_sql = false;
		}
		// Defer end
		return _t3;
	}
	v__ast__Struct info = /* as */ *(v__ast__Struct*)__as_cast((sym->info)._v__ast__Struct,(sym->info)._typ, 446) /*expected idx: 446, name: v.ast.Struct */ ;
	Array_v__ast__StructField fields = v__checker__Checker_fetch_and_verify_orm_fields(c, info, node->table_expr.pos, sym->name);
	Map_int_v__ast__SqlExpr sub_structs = new_map(sizeof(int), sizeof(v__ast__SqlExpr), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop);
	Array_v__ast__StructField _t5 = __new_array(0, 0, sizeof(v__ast__StructField));
	Array_v__ast__StructField _t5_orig = fields;
	int _t5_len = _t5_orig.len;
	_t5 = __new_array(0, _t5_len, sizeof(v__ast__StructField));

	for (int _t6 = 0; _t6 < _t5_len; ++_t6) {
		v__ast__StructField it = ((v__ast__StructField*) _t5_orig.data)[_t6];
		if (((*(v__ast__TypeSymbol**)/*ee elem_typ */array_get(c->table->type_symbols, ((int)(it.typ))))->kind == v__ast__Kind__struct_ || (v__ast__Table_sym(c->table, it.typ)->kind == v__ast__Kind__array && v__ast__Table_sym(c->table, v__ast__TypeSymbol_array_info(v__ast__Table_sym(c->table, it.typ)).elem_type)->kind == v__ast__Kind__struct_)) && !string__eq(v__ast__Table_get_type_name(c->table, it.typ), _SLIT("time.Time"))) {
			array_push((array*)&_t5, &it);
		}
	}
	Array_v__ast__StructField _t4 =_t5;
	for (int _t7 = 0; _t7 < _t4.len; ++_t7) {
		v__ast__StructField f = ((v__ast__StructField*)_t4.data)[_t7];
		v__ast__Type typ = (v__ast__Table_sym(c->table, f.typ)->kind == v__ast__Kind__struct_ ? (f.typ) : v__ast__Table_sym(c->table, f.typ)->kind == v__ast__Kind__array ? (v__ast__TypeSymbol_array_info(v__ast__Table_sym(c->table, f.typ)).elem_type) : (((v__ast__Type)(0))));
		v__ast__SqlExpr n = (v__ast__SqlExpr){.typ = typ,.is_count = 0,.db_expr = node->db_expr,.has_where = true,.has_offset = 0,.offset_expr = {0},.has_order = 0,.order_expr = {0},.has_desc = 0,.is_array = 0,.pos = node->pos,.has_limit = 0,.limit_expr = {0},.where_expr = {0},.table_expr = (v__ast__TypeNode){.typ = typ,.pos = node->table_expr.pos,},.fields = __new_array(0, 0, sizeof(v__ast__StructField)),.sub_structs = new_map(sizeof(int), sizeof(v__ast__SqlExpr), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),};
		bool tmp_inside_sql = c->inside_sql;
		v__checker__Checker_sql_expr(c, (voidptr)&/*qq*/n);
		c->inside_sql = tmp_inside_sql;
		n.where_expr = v__ast__InfixExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__InfixExpr, ((v__ast__InfixExpr){
			.op = v__token__Kind__eq,
			.pos = n.pos,
			.is_stmt = 0,
			.left = v__ast__Ident_to_sumtype_v__ast__Expr(ADDR(v__ast__Ident, ((v__ast__Ident){
				.language = v__ast__Language__v,
				.tok_kind = v__token__Kind__eq,
				.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},
				.mut_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},
				.comptime = 0,
				.scope = c->fn_scope,
				.obj = v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){.name = (string){.str=(byteptr)"", .is_lit=1},.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.is_auto_deref = 0,.is_inherited = 0,.typ = 0,.orig_type = 0,.smartcasts = __new_array(0, 0, sizeof(v__ast__Type)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.is_used = 0,.is_changed = 0,.is_or = 0,.is_tmp = 0,.is_auto_heap = 0,.is_stack_obj = 0,}))),
				.mod = _SLIT("main"),
				.name = _SLIT("id"),
				.kind = v__ast__IdentKind__unresolved,
				.info = v__ast__IdentVar_to_sumtype_v__ast__IdentInfo(ADDR(v__ast__IdentVar, ((v__ast__IdentVar){.typ = 0,.is_mut = 0,.is_static = 0,.is_volatile = 0,.is_optional = 0,.share = 0,}))),
				.is_mut = false,
			}))),
			.right = v__ast__Ident_to_sumtype_v__ast__Expr(ADDR(v__ast__Ident, ((v__ast__Ident){
				.language = v__ast__Language__c,
				.tok_kind = v__token__Kind__eq,
				.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},
				.mut_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},
				.comptime = 0,
				.scope = c->fn_scope,
				.obj = v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){.name = (string){.str=(byteptr)"", .is_lit=1},.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.is_auto_deref = 0,.is_inherited = 0,.typ = 0,.orig_type = 0,.smartcasts = __new_array(0, 0, sizeof(v__ast__Type)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.is_used = 0,.is_changed = 0,.is_or = 0,.is_tmp = 0,.is_auto_heap = 0,.is_stack_obj = 0,}))),
				.mod = _SLIT("main"),
				.name = (string){.str=(byteptr)"", .is_lit=1},
				.kind = 0,
				.info = v__ast__IdentVar_to_sumtype_v__ast__IdentInfo(ADDR(v__ast__IdentVar, ((v__ast__IdentVar){.typ = _const_v__ast__int_type,.is_mut = 0,.is_static = 0,.is_volatile = 0,.is_optional = 0,.share = 0,}))),
				.is_mut = false,
			}))),
			.left_type = _const_v__ast__int_type,
			.right_type = _const_v__ast__int_type,
			.auto_locked = _SLIT(""),
			.or_block = (v__ast__OrExpr){.stmts = __new_array(0, 0, sizeof(v__ast__Stmt)),.kind = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},},
			.ct_left_value_evaled = 0,
			.ct_left_value = v__ast__empty_comptime_const_expr(),
			.ct_right_value_evaled = 0,
			.ct_right_value = v__ast__empty_comptime_const_expr(),
		})));
		(*(v__ast__SqlExpr*)map_get_and_set((map*)&sub_structs, &(int[]){((int)(typ))}, &(v__ast__SqlExpr[]){ (v__ast__SqlExpr){.typ = 0,.is_count = 0,.has_where = 0,.has_offset = 0,.has_order = 0,.has_desc = 0,.is_array = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.has_limit = 0,.table_expr = (v__ast__TypeNode){.typ = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},},.fields = __new_array(0, 0, sizeof(v__ast__StructField)),.sub_structs = new_map(sizeof(int), sizeof(v__ast__SqlExpr), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),} })) = n;
	}
	node->fields = fields;
	node->sub_structs = map_move(&sub_structs);
	if (node->has_where) {
		v__checker__Checker_expr(c, node->where_expr);
	}
	if (node->has_offset) {
		v__checker__Checker_expr(c, node->offset_expr);
	}
	if (node->has_limit) {
		v__checker__Checker_expr(c, node->limit_expr);
	}
	if (node->has_order) {
		v__checker__Checker_expr(c, node->order_expr);
	}
	v__checker__Checker_expr(c, node->db_expr);
	v__ast__Type _t8 = node->typ;
	// Defer begin
	if (v__checker__Checker_sql_expr_defer_0) {
		c->inside_sql = false;
	}
	// Defer end
	return _t8;
}

VV_LOCAL_SYMBOL v__ast__Type v__checker__Checker_sql_stmt(v__checker__Checker* c, v__ast__SqlStmt* node) {
	v__checker__Checker_expr(c, node->db_expr);
	v__ast__Type typ = _const_v__ast__void_type;
	for (int _t1 = 0; _t1 < node->lines.len; ++_t1) {
		v__ast__SqlStmtLine* line = ((v__ast__SqlStmtLine*)node->lines.data) + _t1;
		v__ast__Type a = v__checker__Checker_sql_stmt_line(c, line);
		if (!v__ast__Type_alias_eq(a, _const_v__ast__void_type)) {
			typ = a;
		}
	}
	v__ast__Type _t2 = typ;
	return _t2;
}

VV_LOCAL_SYMBOL v__ast__Type v__checker__Checker_sql_stmt_line(v__checker__Checker* c, v__ast__SqlStmtLine* node) {
bool v__checker__Checker_sql_stmt_line_defer_0 = false;
	c->inside_sql = true;
	v__checker__Checker_sql_stmt_line_defer_0 = true;
	Option_void _t1 = v__checker__Checker_ensure_type_exists(c, node->table_expr.typ, node->pos);
	if (_t1.state != 0 && _t1.err._typ != _IError_None___index) {
		IError err = _t1.err;
		v__ast__Type _t2 = _const_v__ast__void_type;
		// Defer begin
		if (v__checker__Checker_sql_stmt_line_defer_0) {
			c->inside_sql = false;
		}
		// Defer end
		return _t2;
	}
	
 ;
	v__ast__TypeSymbol* table_sym = v__ast__Table_sym(c->table, node->table_expr.typ);
	c->cur_orm_ts = *table_sym;
	if ((table_sym->info)._typ != 446 /* v.ast.Struct */) {
		v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unknown type `"), 0xfe10, {.d_s = table_sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node->pos);
		v__ast__Type _t3 = _const_v__ast__void_type;
		// Defer begin
		if (v__checker__Checker_sql_stmt_line_defer_0) {
			c->inside_sql = false;
		}
		// Defer end
		return _t3;
	}
	v__ast__Struct info = /* as */ *(v__ast__Struct*)__as_cast((table_sym->info)._v__ast__Struct,(table_sym->info)._typ, 446) /*expected idx: 446, name: v.ast.Struct */ ;
	Array_v__ast__StructField fields = v__checker__Checker_fetch_and_verify_orm_fields(c, info, node->table_expr.pos, table_sym->name);
	Map_int_v__ast__SqlStmtLine sub_structs = new_map(sizeof(int), sizeof(v__ast__SqlStmtLine), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop);
	Array_v__ast__StructField _t5 = __new_array(0, 0, sizeof(v__ast__StructField));
	Array_v__ast__StructField _t5_orig = fields;
	int _t5_len = _t5_orig.len;
	_t5 = __new_array(0, _t5_len, sizeof(v__ast__StructField));

	for (int _t6 = 0; _t6 < _t5_len; ++_t6) {
		v__ast__StructField it = ((v__ast__StructField*) _t5_orig.data)[_t6];
		if ((((*(v__ast__TypeSymbol**)/*ee elem_typ */array_get(c->table->type_symbols, ((int)(it.typ))))->kind == v__ast__Kind__struct_) || (v__ast__Table_sym(c->table, it.typ)->kind == v__ast__Kind__array && v__ast__Table_sym(c->table, v__ast__TypeSymbol_array_info(v__ast__Table_sym(c->table, it.typ)).elem_type)->kind == v__ast__Kind__struct_)) && !string__eq(v__ast__Table_get_type_name(c->table, it.typ), _SLIT("time.Time"))) {
			array_push((array*)&_t5, &it);
		}
	}
	Array_v__ast__StructField _t4 =_t5;
	for (int _t7 = 0; _t7 < _t4.len; ++_t7) {
		v__ast__StructField f = ((v__ast__StructField*)_t4.data)[_t7];
		v__ast__Type typ = (v__ast__Table_sym(c->table, f.typ)->kind == v__ast__Kind__struct_ ? (f.typ) : v__ast__Table_sym(c->table, f.typ)->kind == v__ast__Kind__array ? (v__ast__TypeSymbol_array_info(v__ast__Table_sym(c->table, f.typ)).elem_type) : (((v__ast__Type)(0))));
		string object_var_name =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = node->object_var_name}}, {_SLIT("."), 0xfe10, {.d_s = f.name}}, {_SLIT0, 0, { .d_c = 0 }}}));
		if (!v__ast__Type_alias_eq(typ, f.typ)) {
			object_var_name = node->object_var_name;
		}
		v__ast__SqlStmtLine n = (v__ast__SqlStmtLine){.kind = node->kind,.pos = node->pos,.where_expr = {0},.update_exprs = __new_array(0, 0, sizeof(v__ast__Expr)),.object_var_name = object_var_name,.updated_columns = __new_array(0, 0, sizeof(string)),.table_expr = (v__ast__TypeNode){.typ = typ,.pos = node->table_expr.pos,},.fields = __new_array(0, 0, sizeof(v__ast__StructField)),.sub_structs = new_map(sizeof(int), sizeof(v__ast__SqlStmtLine), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),};
		bool tmp_inside_sql = c->inside_sql;
		v__checker__Checker_sql_stmt_line(c, (voidptr)&/*qq*/n);
		c->inside_sql = tmp_inside_sql;
		(*(v__ast__SqlStmtLine*)map_get_and_set((map*)&sub_structs, &(int[]){typ}, &(v__ast__SqlStmtLine[]){ (v__ast__SqlStmtLine){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.update_exprs = __new_array(0, 0, sizeof(v__ast__Expr)),.object_var_name = (string){.str=(byteptr)"", .is_lit=1},.updated_columns = __new_array(0, 0, sizeof(string)),.table_expr = (v__ast__TypeNode){.typ = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},},.fields = __new_array(0, 0, sizeof(v__ast__StructField)),.sub_structs = new_map(sizeof(int), sizeof(v__ast__SqlStmtLine), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),} })) = n;
	}
	node->fields = fields;
	node->sub_structs = map_move(&sub_structs);
	for (int i = 0; i < node->updated_columns.len; ++i) {
		string column = ((string*)node->updated_columns.data)[i];
		Array_v__ast__StructField _t8 = __new_array(0, 0, sizeof(v__ast__StructField));
		Array_v__ast__StructField _t8_orig = node->fields;
		int _t8_len = _t8_orig.len;
		_t8 = __new_array(0, _t8_len, sizeof(v__ast__StructField));

		for (int _t9 = 0; _t9 < _t8_len; ++_t9) {
			v__ast__StructField it = ((v__ast__StructField*) _t8_orig.data)[_t9];
			if (string__eq(it.name, column)) {
				array_push((array*)&_t8, &it);
			}
		}
		Array_v__ast__StructField x =_t8;
		if (x.len == 0) {
			v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("type `"), 0xfe10, {.d_s = table_sym->name}}, {_SLIT("` has no field named `"), 0xfe10, {.d_s = column}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node->pos);
			continue;
		}
		v__ast__StructField field = (*(v__ast__StructField*)/*ee elem_typ */array_get(x, 0));
		(*(string*)/*ee elem_typ */array_get(node->updated_columns, i)) = v__checker__Checker_fetch_field_name(c, field);
	}
	if (node->kind == v__ast__SqlStmtKind__update) {
		for (int _t10 = 0; _t10 < node->update_exprs.len; ++_t10) {
			v__ast__Expr expr = ((v__ast__Expr*)node->update_exprs.data)[_t10];
			v__checker__Checker_expr(c, expr);
		}
	}
	if ((node->where_expr)._typ != 295 /* v.ast.EmptyExpr */) {
		v__checker__Checker_expr(c, node->where_expr);
	}
	v__ast__Type _t11 = _const_v__ast__void_type;
	// Defer begin
	if (v__checker__Checker_sql_stmt_line_defer_0) {
		c->inside_sql = false;
	}
	// Defer end
	return _t11;
}

VV_LOCAL_SYMBOL Array_v__ast__StructField v__checker__Checker_fetch_and_verify_orm_fields(v__checker__Checker* c, v__ast__Struct info, v__token__Position pos, string table_name) {
	Array_v__ast__StructField _t1 = __new_array(0, 0, sizeof(v__ast__StructField));
	Array_v__ast__StructField _t1_orig = info.fields;
	int _t1_len = _t1_orig.len;
	_t1 = __new_array(0, _t1_len, sizeof(v__ast__StructField));

	for (int _t2 = 0; _t2 < _t1_len; ++_t2) {
		v__ast__StructField it = ((v__ast__StructField*) _t1_orig.data)[_t2];
		if (((it.typ == _const_v__ast__string_type || it.typ == _const_v__ast__bool_type) || Array_int_contains(_const_v__ast__number_type_idxs, ((int)(it.typ))) || (*(v__ast__TypeSymbol**)/*ee elem_typ */array_get(c->table->type_symbols, ((int)(it.typ))))->kind == v__ast__Kind__struct_ || (v__ast__Table_sym(c->table, it.typ)->kind == v__ast__Kind__array && v__ast__Table_sym(c->table, v__ast__TypeSymbol_array_info(v__ast__Table_sym(c->table, it.typ)).elem_type)->kind == v__ast__Kind__struct_)) && !Array_v__ast__Attr_contains(it.attrs, _SLIT("skip"))) {
			array_push((array*)&_t1, &it);
		}
	}
	Array_v__ast__StructField fields =_t1;
	if (fields.len == 0) {
		v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("V orm: select: empty fields in `"), 0xfe10, {.d_s = table_name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), pos);
		Array_v__ast__StructField _t3 = __new_array_with_default(0, 0, sizeof(v__ast__StructField), 0);
		return _t3;
	}
	if (!string__eq((*(v__ast__StructField*)/*ee elem_typ */array_get(fields, 0)).name, _SLIT("id"))) {
		v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("V orm: `id int` must be the first field in `"), 0xfe10, {.d_s = table_name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), pos);
	}
	Array_v__ast__StructField _t4 = fields;
	return _t4;
}

void v__checker__Checker_return_stmt(v__checker__Checker* c, v__ast__Return* node) {
	c->expected_type = c->table->cur_fn->return_type;
	v__ast__Type expected_type = v__checker__Checker_unwrap_generic(c, c->expected_type);
	v__ast__TypeSymbol* expected_type_sym = v__ast__Table_sym(c->table, expected_type);
	if (node->exprs.len > 0 && v__ast__Type_alias_eq(c->table->cur_fn->return_type, _const_v__ast__void_type)) {
		v__checker__Checker_error(c, _SLIT("unexpected argument, current function does not return anything"), v__ast__Expr_position((*(v__ast__Expr*)/*ee elem_typ */array_get(node->exprs, 0))));
		return;
	} else if (node->exprs.len == 0 && !(v__ast__Type_alias_eq(c->expected_type, _const_v__ast__void_type) || expected_type_sym->kind == v__ast__Kind__void)) {
		string stype = v__ast__Table_type_to_str(c->table, expected_type);
		string arg = (expected_type_sym->kind == v__ast__Kind__multi_return ? (_SLIT("arguments")) : (_SLIT("argument")));
		v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("expected `"), 0xfe10, {.d_s = stype}}, {_SLIT("` "), 0xfe10, {.d_s = arg}}, {_SLIT0, 0, { .d_c = 0 }}})), node->pos);
		return;
	}
	if (node->exprs.len == 0) {
		return;
	}
	bool exp_is_optional = v__ast__Type_has_flag(expected_type, v__ast__TypeFlag__optional);
	Array_v__ast__Type expected_types = new_array_from_c_array(1, 1, sizeof(v__ast__Type), _MOV((v__ast__Type[1]){expected_type}));
	if ((expected_type_sym->info)._typ == 471 /* v.ast.MultiReturn */) {
		expected_types = (*expected_type_sym->info._v__ast__MultiReturn).types;
		if (c->table->cur_concrete_types.len > 0) {
			Array_v__ast__Type _t1 = __new_array(0, 0, sizeof(v__ast__Type));
			Array_v__ast__Type _t1_orig = expected_types;
			int _t1_len = _t1_orig.len;
			_t1 = __new_array(0, _t1_len, sizeof(v__ast__Type));

			for (int _t2 = 0; _t2 < _t1_len; ++_t2) {
				v__ast__Type it = ((v__ast__Type*) _t1_orig.data)[_t2];
				v__ast__Type ti = v__checker__Checker_unwrap_generic(c, it);
				array_push((array*)&_t1, &ti);
			}
			expected_types =_t1;
		}
	}
	Array_v__ast__Type got_types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
	for (int _t3 = 0; _t3 < node->exprs.len; ++_t3) {
		v__ast__Expr expr = ((v__ast__Expr*)node->exprs.data)[_t3];
		v__ast__Type typ = v__checker__Checker_expr(c, expr);
		if (v__ast__Type_alias_eq(typ, _const_v__ast__void_type)) {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = v__ast__Expr_str(expr)}}, {_SLIT("` used as value"), 0, { .d_c = 0 }}})), node->pos);
		}
		v__ast__TypeSymbol* sym = v__ast__Table_sym(c->table, typ);
		if (sym->kind == v__ast__Kind__multi_return) {
			for (int _t4 = 0; _t4 < v__ast__TypeSymbol_mr_info(sym).types.len; ++_t4) {
				v__ast__Type t = ((v__ast__Type*)v__ast__TypeSymbol_mr_info(sym).types.data)[_t4];
				array_push((array*)&got_types, _MOV((v__ast__Type[]){ t }));
			}
		} else {
			array_push((array*)&got_types, _MOV((v__ast__Type[]){ typ }));
		}
	}
	node->types = got_types;
	int option_type_idx = (*(int*)map_get(ADDR(map, c->table->type_idxs), &(string[]){_SLIT("Option")}, &(int[]){ 0 }));
	int got_types_0_idx = v__ast__Type_idx((*(v__ast__Type*)/*ee elem_typ */array_get(got_types, 0)));
	if (exp_is_optional && (got_types_0_idx == _const_v__ast__none_type_idx || got_types_0_idx == _const_v__ast__error_type_idx || got_types_0_idx == option_type_idx)) {
		if (got_types_0_idx == _const_v__ast__none_type_idx && v__ast__Type_alias_eq(expected_type, _const_v__ast__ovoid_type)) {
			v__checker__Checker_error(c, _SLIT("returning `none` in functions, that have a `?` result type is not allowed anymore, either `return error(message)` or just `return` instead"), node->pos);
		}
		return;
	}
	if (expected_types.len > 0 && expected_types.len != got_types.len) {
		string arg = (expected_types.len == 1 ? (_SLIT("argument")) : (_SLIT("arguments")));
		v__checker__Checker_error(c,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("expected "), 0xfe07, {.d_i32 = expected_types.len}}, {_SLIT(" "), 0xfe10, {.d_s = arg}}, {_SLIT(", but got "), 0xfe07, {.d_i32 = got_types.len}}, {_SLIT0, 0, { .d_c = 0 }}})), node->pos);
		return;
	}
	for (int i = 0; i < expected_types.len; ++i) {
		v__ast__Type exp_type = ((v__ast__Type*)expected_types.data)[i];
		v__ast__Type got_typ = v__checker__Checker_unwrap_generic(c, (*(v__ast__Type*)/*ee elem_typ */array_get(got_types, i)));
		if (v__ast__Type_has_flag(got_typ, v__ast__TypeFlag__optional) && (!v__ast__Type_has_flag(exp_type, v__ast__TypeFlag__optional) || !string__eq(v__ast__Table_type_to_str(c->table, got_typ), v__ast__Table_type_to_str(c->table, exp_type)))) {
			v__token__Position pos = v__ast__Expr_position((*(v__ast__Expr*)/*ee elem_typ */array_get(node->exprs, i)));
			v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("cannot use `"), 0xfe10, {.d_s = v__ast__Table_type_to_str(c->table, got_typ)}}, {_SLIT("` as type `"), 0xfe10, {.d_s = v__ast__Table_type_to_str(c->table, exp_type)}}, {_SLIT("` in return argument"), 0, { .d_c = 0 }}})), pos);
		}
		if (!v__checker__Checker_check_types(c, got_typ, exp_type)) {
			v__ast__TypeSymbol* got_typ_sym = v__ast__Table_sym(c->table, got_typ);
			v__ast__TypeSymbol* exp_typ_sym = v__ast__Table_sym(c->table, exp_type);
			if (exp_typ_sym->kind == v__ast__Kind__interface_) {
				if (v__checker__Checker_type_implements(c, got_typ, exp_type, node->pos)) {
					if (!v__ast__Type_is_ptr(got_typ) && !v__ast__Type_is_pointer(got_typ) && got_typ_sym->kind != v__ast__Kind__interface_ && !c->inside_unsafe) {
						v__checker__Checker_mark_as_referenced(c, &(*(v__ast__Expr*)/*ee elem_typ */array_get(node->exprs, i)), true);
					}
				}
				continue;
			}
			v__token__Position pos = v__ast__Expr_position((*(v__ast__Expr*)/*ee elem_typ */array_get(node->exprs, i)));
			v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("cannot use `"), 0xfe10, {.d_s = got_typ_sym->name}}, {_SLIT("` as type `"), 0xfe10, {.d_s = v__ast__Table_type_to_str(c->table, exp_type)}}, {_SLIT("` in return argument"), 0, { .d_c = 0 }}})), pos);
		}
		if ((v__ast__Type_is_ptr(got_typ) || v__ast__Type_is_pointer(got_typ)) && (!v__ast__Type_is_ptr(exp_type) && !v__ast__Type_is_pointer(exp_type))) {
			v__token__Position pos = v__ast__Expr_position((*(v__ast__Expr*)/*ee elem_typ */array_get(node->exprs, i)));
			if (v__ast__Expr_is_auto_deref_var((*(v__ast__Expr*)/*ee elem_typ */array_get(node->exprs, i)))) {
				continue;
			}
			v__checker__Checker_error(c,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("fn `"), 0xfe10, {.d_s = c->table->cur_fn->name}}, {_SLIT("` expects you to return a non reference type `"), 0xfe10, {.d_s = v__ast__Table_type_to_str(c->table, exp_type)}}, {_SLIT("`, but you are returning `"), 0xfe10, {.d_s = v__ast__Table_type_to_str(c->table, got_typ)}}, {_SLIT("` instead"), 0, { .d_c = 0 }}})), pos);
		}
		if ((v__ast__Type_is_ptr(exp_type) || v__ast__Type_is_pointer(exp_type)) && (!v__ast__Type_is_ptr(got_typ) && !v__ast__Type_is_pointer(got_typ)) && !v__ast__Type_alias_eq(got_typ, _const_v__ast__int_literal_type) && !c->pref->translated) {
			v__token__Position pos = v__ast__Expr_position((*(v__ast__Expr*)/*ee elem_typ */array_get(node->exprs, i)));
			if (v__ast__Expr_is_auto_deref_var((*(v__ast__Expr*)/*ee elem_typ */array_get(node->exprs, i)))) {
				continue;
			}
			v__checker__Checker_error(c,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("fn `"), 0xfe10, {.d_s = c->table->cur_fn->name}}, {_SLIT("` expects you to return a reference type `"), 0xfe10, {.d_s = v__ast__Table_type_to_str(c->table, exp_type)}}, {_SLIT("`, but you are returning `"), 0xfe10, {.d_s = v__ast__Table_type_to_str(c->table, got_typ)}}, {_SLIT("` instead"), 0, { .d_c = 0 }}})), pos);
		}
		if (v__ast__Type_is_ptr(exp_type) && v__ast__Type_is_ptr(got_typ)) {
			v__ast__Expr* r_expr = &(*(v__ast__Expr*)/*ee elem_typ */array_get(node->exprs, i));
			if ((r_expr)->_typ == 299 /* v.ast.Ident */) {
				if (((*r_expr->_v__ast__Ident).obj)._typ == 357 /* v.ast.Var */) {
					v__ast__Var* obj = &(*(*r_expr->_v__ast__Ident).obj._v__ast__Var);
					if (c->fn_scope != ((voidptr)(0))) {
						Option_v__ast__Var_ptr _t7 = v__ast__Scope_find_var(c->fn_scope, (*(*r_expr->_v__ast__Ident).obj._v__ast__Var).name);
						if (_t7.state != 0) { /*or block*/ 
							IError err = _t7.err;
							*(v__ast__Var**) _t7.data = obj;
						}
						
 						obj =  (*(v__ast__Var**)_t7.data);
					}
					if (obj->is_stack_obj && !c->inside_unsafe) {
						v__ast__TypeSymbol* type_sym = v__ast__Table_sym(c->table, v__ast__Type_set_nr_muls(obj->typ, 0));
						if (!v__ast__TypeSymbol_is_heap(type_sym) && !c->pref->translated) {
							string suggestion = (type_sym->kind == v__ast__Kind__struct_ ? ( str_intp(2, _MOV((StrIntpData[]){{_SLIT("declaring `"), 0xfe10, {.d_s = type_sym->name}}, {_SLIT("` as `[heap]`"), 0, { .d_c = 0 }}}))) : ( str_intp(2, _MOV((StrIntpData[]){{_SLIT("wrapping the `"), 0xfe10, {.d_s = type_sym->name}}, {_SLIT("` object in a `struct` declared as `[heap]`"), 0, { .d_c = 0 }}}))));
							v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = (*r_expr->_v__ast__Ident).name}}, {_SLIT("` cannot be returned outside `unsafe` blocks as it might refer to an object stored on stack. Consider "), 0xfe10, {.d_s = suggestion}}, {_SLIT("."), 0, { .d_c = 0 }}})), (*r_expr->_v__ast__Ident).pos);
						}
					}
				}
			}
		}
	}
	if (exp_is_optional && node->exprs.len > 0) {
		v__ast__Expr expr0 = (*(v__ast__Expr*)/*ee elem_typ */array_get(node->exprs, 0));
		if ((expr0)._typ == 286 /* v.ast.CallExpr */) {
			if ((*expr0._v__ast__CallExpr).or_block.kind == v__ast__OrKind__propagate) {
				v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("`?` is not needed, use `return "), 0xfe10, {.d_s = (*expr0._v__ast__CallExpr).name}}, {_SLIT("()`"), 0, { .d_c = 0 }}})), (*expr0._v__ast__CallExpr).pos);
			}
		}
	}
}

void v__checker__Checker_find_unreachable_statements_after_noreturn_calls(v__checker__Checker* c, Array_v__ast__Stmt stmts) {
	bool prev_stmt_was_noreturn_call = false;
	for (int _t1 = 0; _t1 < stmts.len; ++_t1) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)stmts.data)[_t1];
		if (stmt._typ == 339 /* v.ast.ExprStmt */) {
			if (((*stmt._v__ast__ExprStmt).expr)._typ == 286 /* v.ast.CallExpr */) {
				if (prev_stmt_was_noreturn_call) {
					v__checker__Checker_error(c, _SLIT("unreachable code after a [noreturn] call"), (*stmt._v__ast__ExprStmt).pos);
					return;
				}
				prev_stmt_was_noreturn_call = (*(*stmt._v__ast__ExprStmt).expr._v__ast__CallExpr).is_noreturn;
			}
		}
		
		else {
			prev_stmt_was_noreturn_call = false;
		}
		;
	}
}

VV_LOCAL_SYMBOL bool v__checker__has_top_return(Array_v__ast__Stmt stmts) {
	for (int _t1 = 0; _t1 < stmts.len; ++_t1) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)stmts.data)[_t1];
		if (stmt._typ == 350 /* v.ast.Return */) {
			bool _t2 = true;
			return _t2;
		}
		else if (stmt._typ == 332 /* v.ast.Block */) {
			if (v__checker__has_top_return((*stmt._v__ast__Block).stmts)) {
				bool _t3 = true;
				return _t3;
			}
		}
		else if (stmt._typ == 339 /* v.ast.ExprStmt */) {
			if (((*stmt._v__ast__ExprStmt).expr)._typ == 286 /* v.ast.CallExpr */) {
				if ((*(*stmt._v__ast__ExprStmt).expr._v__ast__CallExpr).is_noreturn) {
					bool _t4 = true;
					return _t4;
				}
			}
		}
		
		else {
		}
		;
	}
	bool _t5 = false;
	return _t5;
}

VV_LOCAL_SYMBOL void v__checker__Checker_check_noreturn_fn_decl(v__checker__Checker* c, v__ast__FnDecl* node) {
	if (!node->is_noreturn) {
		return;
	}
	if (node->no_body) {
		return;
	}
	if (!v__ast__Type_alias_eq(node->return_type, _const_v__ast__void_type)) {
		v__checker__Checker_error(c, _SLIT("[noreturn] functions cannot have return types"), node->pos);
	}
	if (v__checker__uses_return_stmt(node->stmts)) {
		v__checker__Checker_error(c, _SLIT("[noreturn] functions cannot use return statements"), node->pos);
	}
	if (node->stmts.len != 0) {
		bool is_valid_end_of_noreturn_fn = false;
		v__ast__Stmt last_stmt = (*(v__ast__Stmt*)array_last(node->stmts));
		if (last_stmt._typ == 339 /* v.ast.ExprStmt */) {
			if (((*last_stmt._v__ast__ExprStmt).expr)._typ == 286 /* v.ast.CallExpr */) {
				if ((*(*last_stmt._v__ast__ExprStmt).expr._v__ast__CallExpr).should_be_skipped) {
					v__checker__Checker_error(c, _SLIT("[noreturn] functions cannot end with a skippable `[if ..]` call"), (*last_stmt._v__ast__ExprStmt).pos);
					return;
				}
				if ((*(*last_stmt._v__ast__ExprStmt).expr._v__ast__CallExpr).is_noreturn) {
					is_valid_end_of_noreturn_fn = true;
				}
			}
		}
		else if (last_stmt._typ == 342 /* v.ast.ForStmt */) {
			if ((*last_stmt._v__ast__ForStmt).is_inf && (*last_stmt._v__ast__ForStmt).stmts.len == 0) {
				is_valid_end_of_noreturn_fn = true;
			}
		}
		
		else {
		}
		;
		if (!is_valid_end_of_noreturn_fn) {
			v__checker__Checker_error(c, _SLIT("[noreturn] functions should end with a call to another [noreturn] function, or with an infinite `for {}` loop"), (*(last_stmt.pos)));
			return;
		}
	}
}

VV_LOCAL_SYMBOL bool v__checker__uses_return_stmt(Array_v__ast__Stmt stmts) {
	if (stmts.len == 0) {
		bool _t1 = false;
		return _t1;
	}
	for (int _t2 = 0; _t2 < stmts.len; ++_t2) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)stmts.data)[_t2];
		if (stmt._typ == 350 /* v.ast.Return */) {
			bool _t3 = true;
			return _t3;
		}
		else if (stmt._typ == 332 /* v.ast.Block */) {
			if (v__checker__uses_return_stmt((*stmt._v__ast__Block).stmts)) {
				bool _t4 = true;
				return _t4;
			}
		}
		else if (stmt._typ == 339 /* v.ast.ExprStmt */) {
			if ((*stmt._v__ast__ExprStmt).expr._typ == 286 /* v.ast.CallExpr */) {
				if (v__checker__uses_return_stmt((*(*stmt._v__ast__ExprStmt).expr._v__ast__CallExpr).or_block.stmts)) {
					bool _t5 = true;
					return _t5;
				}
			}
			else if ((*stmt._v__ast__ExprStmt).expr._typ == 309 /* v.ast.MatchExpr */) {
				for (int _t6 = 0; _t6 < (*(*stmt._v__ast__ExprStmt).expr._v__ast__MatchExpr).branches.len; ++_t6) {
					v__ast__MatchBranch b = ((v__ast__MatchBranch*)(*(*stmt._v__ast__ExprStmt).expr._v__ast__MatchExpr).branches.data)[_t6];
					if (v__checker__uses_return_stmt(b.stmts)) {
						bool _t7 = true;
						return _t7;
					}
				}
			}
			else if ((*stmt._v__ast__ExprStmt).expr._typ == 318 /* v.ast.SelectExpr */) {
				for (int _t8 = 0; _t8 < (*(*stmt._v__ast__ExprStmt).expr._v__ast__SelectExpr).branches.len; ++_t8) {
					v__ast__SelectBranch b = ((v__ast__SelectBranch*)(*(*stmt._v__ast__ExprStmt).expr._v__ast__SelectExpr).branches.data)[_t8];
					if (v__checker__uses_return_stmt(b.stmts)) {
						bool _t9 = true;
						return _t9;
					}
				}
			}
			else if ((*stmt._v__ast__ExprStmt).expr._typ == 300 /* v.ast.IfExpr */) {
				for (int _t10 = 0; _t10 < (*(*stmt._v__ast__ExprStmt).expr._v__ast__IfExpr).branches.len; ++_t10) {
					v__ast__IfBranch b = ((v__ast__IfBranch*)(*(*stmt._v__ast__ExprStmt).expr._v__ast__IfExpr).branches.data)[_t10];
					if (v__checker__uses_return_stmt(b.stmts)) {
						bool _t11 = true;
						return _t11;
					}
				}
			}
			
			else {
			}
			;
		}
		else if (stmt._typ == 342 /* v.ast.ForStmt */) {
			if (v__checker__uses_return_stmt((*stmt._v__ast__ForStmt).stmts)) {
				bool _t12 = true;
				return _t12;
			}
		}
		else if (stmt._typ == 340 /* v.ast.ForCStmt */) {
			if (v__checker__uses_return_stmt((*stmt._v__ast__ForCStmt).stmts)) {
				bool _t13 = true;
				return _t13;
			}
		}
		else if (stmt._typ == 341 /* v.ast.ForInStmt */) {
			if (v__checker__uses_return_stmt((*stmt._v__ast__ForInStmt).stmts)) {
				bool _t14 = true;
				return _t14;
			}
		}
		
		else {
		}
		;
	}
	bool _t15 = false;
	return _t15;
}

VV_LOCAL_SYMBOL bool v__checker__is_noreturn_callexpr(v__ast__Expr expr) {
	if ((expr)._typ == 286 /* v.ast.CallExpr */) {
		bool _t1 = (*expr._v__ast__CallExpr).is_noreturn;
		return _t1;
	}
	bool _t2 = false;
	return _t2;
}

void v__checker__Checker_struct_decl(v__checker__Checker* c, v__ast__StructDecl* node) {
	if (node->language == v__ast__Language__v && !c->is_builtin_mod) {
		v__checker__Checker_check_valid_pascal_case(c, node->name, _SLIT("struct name"), node->pos);
	}
	multi_return_ref_v__ast__TypeSymbol_int mr_405 = v__ast__Table_find_sym_and_type_idx(c->table, node->name);
	v__ast__TypeSymbol* struct_sym = mr_405.arg0;
	int struct_typ_idx = mr_405.arg1;
	bool has_generic_types = false;
	if ((struct_sym->info)._typ == 446 /* v.ast.Struct */) {
		for (int _t1 = 0; _t1 < node->embeds.len; ++_t1) {
			v__ast__Embed embed = ((v__ast__Embed*)node->embeds.data)[_t1];
			if (v__ast__Type_has_flag(embed.typ, v__ast__TypeFlag__generic)) {
				has_generic_types = true;
			}
			v__ast__TypeSymbol* embed_sym = v__ast__Table_sym(c->table, embed.typ);
			if (embed_sym->kind != v__ast__Kind__struct_) {
				v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = embed_sym->name}}, {_SLIT("` is not a struct"), 0, { .d_c = 0 }}})), embed.pos);
			} else {
				v__ast__Struct info = /* as */ *(v__ast__Struct*)__as_cast((embed_sym->info)._v__ast__Struct,(embed_sym->info)._typ, 446) /*expected idx: 446, name: v.ast.Struct */ ;
				if (info.is_heap && !v__ast__Type_is_ptr(embed.typ)) {
					(*struct_sym->info._v__ast__Struct).is_heap = true;
				}
			}
		}
		for (int _t2 = 0; _t2 < node->attrs.len; ++_t2) {
			v__ast__Attr attr = ((v__ast__Attr*)node->attrs.data)[_t2];
			if (string__eq(attr.name, _SLIT("typedef")) && node->language != v__ast__Language__c) {
				v__checker__Checker_error(c, _SLIT("`typedef` attribute can only be used with C structs"), node->pos);
			}
		}
		for (int i = 0; i < node->fields.len; ++i) {
			v__ast__StructField field = ((v__ast__StructField*)node->fields.data)[i];
			if (v__ast__Type_alias_eq(field.typ, _const_v__ast__any_type)) {
				v__checker__Checker_error(c, _SLIT("struct field cannot be the `any` type, use generics instead"), field.type_pos);
			}
			Option_void _t3 = v__checker__Checker_ensure_type_exists(c, field.typ, field.type_pos);
			if (_t3.state != 0 && _t3.err._typ != _IError_None___index) {
				IError err = _t3.err;
				return;
			}
			
 ;
			if (v__ast__Type_has_flag(field.typ, v__ast__TypeFlag__generic)) {
				has_generic_types = true;
			}
			if (node->language == v__ast__Language__v) {
				v__checker__Checker_check_valid_snake_case(c, field.name, _SLIT("field name"), field.pos);
			}
			v__ast__TypeSymbol* sym = v__ast__Table_sym(c->table, field.typ);
			for (int j = 0; j < i; ++j) {
				if (string__eq(field.name, (*(v__ast__StructField*)/*ee elem_typ */array_get(node->fields, j)).name)) {
					v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("field name `"), 0xfe10, {.d_s = field.name}}, {_SLIT("` duplicate"), 0, { .d_c = 0 }}})), field.pos);
				}
			}
			if (field.typ != 0) {
				if (!v__ast__Type_is_ptr(field.typ)) {
					if (v__ast__Table_unaliased_type(c->table, field.typ) == struct_typ_idx) {
						v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("Field `"), 0xfe10, {.d_s = field.name}}, {_SLIT("` is part of `"), 0xfe10, {.d_s = node->name}}, {_SLIT("`, they can not both have the same type"), 0, { .d_c = 0 }}})), field.type_pos);
					}
				}
			}
			if (sym->kind == v__ast__Kind__struct_) {
				v__ast__Struct info = /* as */ *(v__ast__Struct*)__as_cast((sym->info)._v__ast__Struct,(sym->info)._typ, 446) /*expected idx: 446, name: v.ast.Struct */ ;
				if (info.is_heap && !v__ast__Type_is_ptr(field.typ)) {
					(*struct_sym->info._v__ast__Struct).is_heap = true;
				}
			}
			if (field.has_default_expr) {
				c->expected_type = field.typ;
				v__ast__Type field_expr_type = v__checker__Checker_expr(c, field.default_expr);
				if (!v__ast__Type_has_flag(field.typ, v__ast__TypeFlag__optional)) {
					v__checker__Checker_check_expr_opt_call(c, field.default_expr, field_expr_type);
				}
				(*(v__ast__StructField*)/*ee elem_typ */array_get((*struct_sym->info._v__ast__Struct).fields, i)).default_expr_typ = field_expr_type;
				Option_void _t4 = v__checker__Checker_check_expected(c, field_expr_type, field.typ);
				if (_t4.state != 0 && _t4.err._typ != _IError_None___index) {
					IError err = _t4.err;
					if (sym->kind == v__ast__Kind__interface_ && v__checker__Checker_type_implements(c, field_expr_type, field.typ, field.pos)) {
						if (!v__ast__Type_is_ptr(field_expr_type) && !v__ast__Type_is_pointer(field_expr_type) && !c->inside_unsafe) {
							v__ast__TypeSymbol* field_expr_type_sym = v__ast__Table_sym(c->table, field_expr_type);
							if (field_expr_type_sym->kind != v__ast__Kind__interface_) {
								v__checker__Checker_mark_as_referenced(c, &(*(v__ast__StructField*)/*ee elem_typ */array_get(node->fields, i)).default_expr, true);
							}
						}
					} else {
						v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("incompatible initializer for field `"), 0xfe10, {.d_s = field.name}}, {_SLIT("`: "), 0xfe10, {.d_s = (*(err.msg))}}, {_SLIT0, 0, { .d_c = 0 }}})), v__ast__Expr_position(field.default_expr));
					}
				;
				}
				
 ;
				if (v__ast__Type_is_ptr(field.typ)) {
					continue;
				}
				if ((field.default_expr)._typ == 304 /* v.ast.IntegerLiteral */) {
					if (string__eq((*field.default_expr._v__ast__IntegerLiteral).val, _SLIT("0"))) {
						v__checker__Checker_warn(c, _SLIT("unnecessary default value of `0`: struct fields are zeroed by default"), (*field.default_expr._v__ast__IntegerLiteral).pos);
					}
				} else if ((field.default_expr)._typ == 323 /* v.ast.StringLiteral */) {
					if (((*field.default_expr._v__ast__StringLiteral).val).len == 0) {
						v__checker__Checker_warn(c, _SLIT("unnecessary default value of '': struct fields are zeroed by default"), (*field.default_expr._v__ast__StringLiteral).pos);
					}
				} else if ((field.default_expr)._typ == 284 /* v.ast.BoolLiteral */) {
					if ((*field.default_expr._v__ast__BoolLiteral).val == false) {
						v__checker__Checker_warn(c, _SLIT("unnecessary default value `false`: struct fields are zeroed by default"), (*field.default_expr._v__ast__BoolLiteral).pos);
					}
				}
			}
		}
		if (node->generic_types.len == 0 && has_generic_types) {
			v__checker__Checker_error(c, _SLIT("generic struct declaration must specify the generic type names, e.g. Foo<T>"), node->pos);
		}
	}
}

v__ast__Type v__checker__Checker_struct_init(v__checker__Checker* c, v__ast__StructInit* node) {
	if (v__ast__Type_alias_eq(node->typ, _const_v__ast__void_type)) {
		if (v__ast__Type_alias_eq(c->expected_type, _const_v__ast__void_type)) {
			v__checker__Checker_error(c, _SLIT("unexpected short struct syntax"), node->pos);
			v__ast__Type _t1 = _const_v__ast__void_type;
			return _t1;
		}
		v__ast__TypeSymbol* sym = v__ast__Table_sym(c->table, c->expected_type);
		if (sym->kind == v__ast__Kind__array) {
			node->typ = v__ast__Table_value_type(c->table, c->expected_type);
		} else {
			node->typ = c->expected_type;
		}
	}
	v__ast__TypeSymbol* struct_sym = v__ast__Table_sym(c->table, node->typ);
	if ((struct_sym->info)._typ == 446 /* v.ast.Struct */) {
		if ((*struct_sym->info._v__ast__Struct).generic_types.len > 0 && (*struct_sym->info._v__ast__Struct).concrete_types.len == 0 && c->table->cur_concrete_types.len == 0) {
			v__checker__Checker_error(c, _SLIT("generic struct init must specify type parameter, e.g. Foo<int>"), node->pos);
		}
	} else if ((struct_sym->info)._typ == 460 /* v.ast.Alias */) {
		v__ast__TypeSymbol* parent_sym = v__ast__Table_sym(c->table, (*struct_sym->info._v__ast__Alias).parent_type);
		if (parent_sym->kind == v__ast__Kind__map) {
			string alias_str = v__ast__Table_type_to_str(c->table, node->typ);
			string map_str = v__ast__Table_type_to_str(c->table, (*struct_sym->info._v__ast__Alias).parent_type);
			v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("direct map alias init is not possible, use `"), 0xfe10, {.d_s = alias_str}}, {_SLIT("("), 0xfe10, {.d_s = map_str}}, {_SLIT("{})` instead"), 0, { .d_c = 0 }}})), node->pos);
			v__ast__Type _t2 = _const_v__ast__void_type;
			return _t2;
		}
	}
	if (c->table->cur_fn->generic_names.len > 0) {
		v__ast__Table_unwrap_generic_type(c->table, node->typ, c->table->cur_fn->generic_names, c->table->cur_concrete_types);
	}
	Option_void _t3 = v__checker__Checker_ensure_type_exists(c, node->typ, node->pos);
	if (_t3.state != 0 && _t3.err._typ != _IError_None___index) {
		IError err = _t3.err;
	}
	
 ;
	v__ast__TypeSymbol* type_sym = v__ast__Table_sym(c->table, node->typ);
	if (!c->inside_unsafe && type_sym->kind == v__ast__Kind__sum_type) {
		v__checker__Checker_note(c, _SLIT("direct sum type init (`x := SumType{}`) will be removed soon"), node->pos);
	}
	if (!c->is_builtin_mod && !c->inside_unsafe && type_sym->language == v__ast__Language__v && c->table->cur_concrete_types.len == 0) {
		Option_int _t4 = string_last_index(type_sym->name, _SLIT("."));
		if (_t4.state != 0) { /*or block*/ 
			IError err = _t4.err;
			*(int*) _t4.data = -1;
		}
		
 		int pos =  (*(int*)_t4.data);
		byte first_letter = string_at(type_sym->name, pos + 1);
		if (!byte_is_capital(first_letter)) {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot initialize builtin type `"), 0xfe10, {.d_s = type_sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node->pos);
		}
	}
	if (type_sym->kind == v__ast__Kind__sum_type && node->fields.len == 1) {
		string sexpr = v__ast__Expr_str((*(v__ast__StructInitField*)/*ee elem_typ */array_get(node->fields, 0)).expr);
		v__checker__Checker_error(c,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("cast to sum type using `"), 0xfe10, {.d_s = type_sym->name}}, {_SLIT("("), 0xfe10, {.d_s = sexpr}}, {_SLIT(")` not `"), 0xfe10, {.d_s = type_sym->name}}, {_SLIT("{"), 0xfe10, {.d_s = sexpr}}, {_SLIT("}`"), 0, { .d_c = 0 }}})), node->pos);
	}
	if (type_sym->kind == v__ast__Kind__interface_ && type_sym->language != v__ast__Language__js) {
		v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot instantiate interface `"), 0xfe10, {.d_s = type_sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node->pos);
	}
	if ((type_sym->info)._typ == 460 /* v.ast.Alias */) {
		if (v__ast__Type_is_number((*type_sym->info._v__ast__Alias).parent_type)) {
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot instantiate number type alias `"), 0xfe10, {.d_s = type_sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node->pos);
			v__ast__Type _t5 = _const_v__ast__void_type;
			return _t5;
		}
	}
	if (!type_sym->is_public && type_sym->kind != v__ast__Kind__placeholder && type_sym->language != v__ast__Language__c && (!string__eq(type_sym->mod, c->mod) && !(v__ast__Type_has_flag(node->typ, v__ast__TypeFlag__generic) && !string__eq(type_sym->mod, _SLIT("builtin"))))) {
		v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("type `"), 0xfe10, {.d_s = type_sym->name}}, {_SLIT("` is private"), 0, { .d_c = 0 }}})), node->pos);
	}
	if (type_sym->kind == v__ast__Kind__struct_) {
		v__ast__Struct info = /* as */ *(v__ast__Struct*)__as_cast((type_sym->info)._v__ast__Struct,(type_sym->info)._typ, 446) /*expected idx: 446, name: v.ast.Struct */ ;
		if (info.attrs.len > 0 && string__eq((*(v__ast__Attr*)/*ee elem_typ */array_get(info.attrs, 0)).name, _SLIT("noinit")) && !string__eq(type_sym->mod, c->mod)) {
			v__checker__Checker_error(c, string__plus( str_intp(2, _MOV((StrIntpData[]){{_SLIT("struct `"), 0xfe10, {.d_s = type_sym->name}}, {_SLIT("` is declared with a `[noinit]` attribute, so "), 0, { .d_c = 0 }}})),  str_intp(2, _MOV((StrIntpData[]){{_SLIT("it cannot be initialized with `"), 0xfe10, {.d_s = type_sym->name}}, {_SLIT("{}`"), 0, { .d_c = 0 }}}))), node->pos);
		}
	}
	if (type_sym->name.len == 1 && c->table->cur_fn->generic_names.len == 0) {
		v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unknown struct `"), 0xfe10, {.d_s = type_sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node->pos);
		v__ast__Type _t6 = 0;
		return _t6;
	}

	if (type_sym->kind == (v__ast__Kind__placeholder)) {
		v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unknown struct: "), 0xfe10, {.d_s = type_sym->name}}, {_SLIT0, 0, { .d_c = 0 }}})), node->pos);
		v__ast__Type _t7 = _const_v__ast__void_type;
		return _t7;
	}
	else if (type_sym->kind == (v__ast__Kind__struct_) || type_sym->kind == (v__ast__Kind__string) || type_sym->kind == (v__ast__Kind__array) || type_sym->kind == (v__ast__Kind__alias)) {
		v__ast__Struct info = (v__ast__Struct){.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.embeds = __new_array(0, 0, sizeof(v__ast__Type)),.fields = __new_array(0, 0, sizeof(v__ast__StructField)),.is_typedef = 0,.is_union = 0,.is_heap = 0,.is_generic = 0,.generic_types = __new_array(0, 0, sizeof(v__ast__Type)),.concrete_types = __new_array(0, 0, sizeof(v__ast__Type)),.parent_type = 0,};
		if (type_sym->kind == v__ast__Kind__alias) {
			v__ast__Alias info_t = /* as */ *(v__ast__Alias*)__as_cast((type_sym->info)._v__ast__Alias,(type_sym->info)._typ, 460) /*expected idx: 460, name: v.ast.Alias */ ;
			v__ast__TypeSymbol* sym = v__ast__Table_sym(c->table, info_t.parent_type);
			if (sym->kind == v__ast__Kind__placeholder) {
				v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unknown struct: "), 0xfe10, {.d_s = type_sym->name}}, {_SLIT0, 0, { .d_c = 0 }}})), node->pos);
				v__ast__Type _t8 = _const_v__ast__void_type;
				return _t8;
			}
			if (sym->kind == v__ast__Kind__struct_) {
				info = /* as */ *(v__ast__Struct*)__as_cast((sym->info)._v__ast__Struct,(sym->info)._typ, 446) /*expected idx: 446, name: v.ast.Struct */ ;
			} else {
				v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("alias type name: "), 0xfe10, {.d_s = sym->name}}, {_SLIT(" is not struct type"), 0, { .d_c = 0 }}})), node->pos);
			}
		} else {
			info = /* as */ *(v__ast__Struct*)__as_cast((type_sym->info)._v__ast__Struct,(type_sym->info)._typ, 446) /*expected idx: 446, name: v.ast.Struct */ ;
		}
		if (node->is_short) {
			int exp_len = info.fields.len;
			int got_len = node->fields.len;
			if (exp_len != got_len) {
				string amount = (exp_len < got_len ? (_SLIT("many")) : (_SLIT("few")));
				v__checker__Checker_error(c,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("too "), 0xfe10, {.d_s = amount}}, {_SLIT(" fields in `"), 0xfe10, {.d_s = type_sym->name}}, {_SLIT("` literal (expecting "), 0xfe07, {.d_i32 = exp_len}}, {_SLIT(", got "), 0xfe07, {.d_i32 = got_len}}, {_SLIT(")"), 0, { .d_c = 0 }}})), node->pos);
			}
		}
		Array_string inited_fields = __new_array_with_default(0, 0, sizeof(string), 0);
		for (int i = 0; i < node->fields.len; ++i) {
			v__ast__StructInitField* field = ((v__ast__StructInitField*)node->fields.data) + i;
			v__ast__StructField field_info = (v__ast__StructField){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.has_default_expr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_pub = 0,.default_val = (string){.str=(byteptr)"", .is_lit=1},.is_mut = 0,.is_global = 0,.is_volatile = 0,.default_expr = {0},.default_expr_typ = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,};
			string field_name = _SLIT("");
			if (node->is_short) {
				if (i >= info.fields.len) {
					break;
				}
				field_info = (*(v__ast__StructField*)/*ee elem_typ */array_get(info.fields, i));
				field_name = field_info.name;
				(*(v__ast__StructInitField*)/*ee elem_typ */array_get(node->fields, i)).name = field_name;
			} else {
				field_name = field->name;
				bool exists = true;
				Option_v__ast__StructField _t9 = v__ast__Table_find_field_with_embeds(c->table, type_sym, field_name);
				if (_t9.state != 0) { /*or block*/ 
					IError err = _t9.err;
					exists = false;
					*(v__ast__StructField*) _t9.data = (v__ast__StructField){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.has_default_expr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_pub = 0,.default_val = (string){.str=(byteptr)"", .is_lit=1},.is_mut = 0,.is_global = 0,.is_volatile = 0,.default_expr = {0},.default_expr_typ = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,};
				}
				
 				field_info =  (*(v__ast__StructField*)_t9.data);
				if (!exists) {
					v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("unknown field `"), 0xfe10, {.d_s = field->name}}, {_SLIT("` in struct literal of type `"), 0xfe10, {.d_s = type_sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), field->pos);
					continue;
				}
				if (Array_string_contains(inited_fields, field_name)) {
					v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("duplicate field name in struct literal: `"), 0xfe10, {.d_s = field_name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), field->pos);
					continue;
				}
			}
			v__ast__Type expr_type = ((v__ast__Type)(0));
			v__ast__Type expected_type = ((v__ast__Type)(0));
			array_push((array*)&inited_fields, _MOV((string[]){ string_clone(field_name) }));
			v__ast__TypeSymbol* field_type_sym = v__ast__Table_sym(c->table, field_info.typ);
			expected_type = field_info.typ;
			c->expected_type = expected_type;
			expr_type = v__checker__Checker_expr(c, field->expr);
			if (!v__ast__Type_has_flag(field_info.typ, v__ast__TypeFlag__optional)) {
				expr_type = v__checker__Checker_check_expr_opt_call(c, field->expr, expr_type);
			}
			v__ast__TypeSymbol* expr_type_sym = v__ast__Table_sym(c->table, expr_type);
			if (field_type_sym->kind == v__ast__Kind__interface_) {
				if (v__checker__Checker_type_implements(c, expr_type, field_info.typ, field->pos)) {
					if (!v__ast__Type_is_ptr(expr_type) && !v__ast__Type_is_pointer(expr_type) && expr_type_sym->kind != v__ast__Kind__interface_ && !c->inside_unsafe) {
						v__checker__Checker_mark_as_referenced(c, &field->expr, true);
					}
				}
			} else if (!v__ast__Type_alias_eq(expr_type, _const_v__ast__void_type) && expr_type_sym->kind != v__ast__Kind__placeholder) {
				Option_void _t11 = v__checker__Checker_check_expected(c, v__checker__Checker_unwrap_generic(c, expr_type), v__checker__Checker_unwrap_generic(c, field_info.typ));
				if (_t11.state != 0 && _t11.err._typ != _IError_None___index) {
					IError err = _t11.err;
					v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("cannot assign to field `"), 0xfe10, {.d_s = field_info.name}}, {_SLIT("`: "), 0xfe10, {.d_s = (*(err.msg))}}, {_SLIT0, 0, { .d_c = 0 }}})), field->pos);
				;
				}
				
 ;
			}
			if (v__ast__Type_has_flag(field_info.typ, v__ast__TypeFlag__shared_f)) {
				if (!v__ast__Type_has_flag(expr_type, v__ast__TypeFlag__shared_f) && v__ast__Type_is_ptr(expr_type)) {
					v__checker__Checker_error(c, _SLIT("`shared` field must be initialized with `shared` or value"), field->pos);
				}
			} else {
				if (v__ast__Type_is_ptr(field_info.typ) && !v__ast__Type_is_ptr(expr_type) && !v__ast__Type_is_pointer(expr_type) && !v__ast__Type_is_number(expr_type)) {
					v__checker__Checker_error(c, _SLIT("reference field must be initialized with reference"), field->pos);
				}
			}
			(*(v__ast__StructInitField*)/*ee elem_typ */array_get(node->fields, i)).typ = expr_type;
			(*(v__ast__StructInitField*)/*ee elem_typ */array_get(node->fields, i)).expected_type = field_info.typ;
			if (v__ast__Type_has_flag(field_info.typ, v__ast__TypeFlag__optional)) {
				v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("field `"), 0xfe10, {.d_s = field_info.name}}, {_SLIT("` is optional, but initialization of optional fields currently unsupported"), 0, { .d_c = 0 }}})), field->pos);
			}
			if (v__ast__Type_is_ptr(expr_type) && v__ast__Type_is_ptr(expected_type)) {
				if ((field->expr)._typ == 299 /* v.ast.Ident */) {
					if (((*field->expr._v__ast__Ident).obj)._typ == 357 /* v.ast.Var */) {
						v__ast__Var* obj = &(*(*field->expr._v__ast__Ident).obj._v__ast__Var);
						if (c->fn_scope != ((voidptr)(0))) {
							Option_v__ast__Var_ptr _t12 = v__ast__Scope_find_var(c->fn_scope, obj->name);
							if (_t12.state != 0) { /*or block*/ 
								IError err = _t12.err;
								*(v__ast__Var**) _t12.data = obj;
							}
							
 							obj =  (*(v__ast__Var**)_t12.data);
						}
						if (obj->is_stack_obj && !c->inside_unsafe) {
							v__ast__TypeSymbol* sym = v__ast__Table_sym(c->table, v__ast__Type_set_nr_muls(obj->typ, 0));
							if (!v__ast__TypeSymbol_is_heap(sym) && !c->pref->translated) {
								string suggestion = (sym->kind == v__ast__Kind__struct_ ? ( str_intp(2, _MOV((StrIntpData[]){{_SLIT("declaring `"), 0xfe10, {.d_s = sym->name}}, {_SLIT("` as `[heap]`"), 0, { .d_c = 0 }}}))) : ( str_intp(2, _MOV((StrIntpData[]){{_SLIT("wrapping the `"), 0xfe10, {.d_s = sym->name}}, {_SLIT("` object in a `struct` declared as `[heap]`"), 0, { .d_c = 0 }}}))));
								v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = (*field->expr._v__ast__Ident).name}}, {_SLIT("` cannot be assigned outside `unsafe` blocks as it might refer to an object stored on stack. Consider "), 0xfe10, {.d_s = suggestion}}, {_SLIT("."), 0, { .d_c = 0 }}})), (*field->expr._v__ast__Ident).pos);
							}
						}
					}
				}
			}
		}
		for (int _t13 = 0; _t13 < info.fields.len; ++_t13) {
			v__ast__StructField field = ((v__ast__StructField*)info.fields.data)[_t13];
			if (field.has_default_expr || Array_string_contains(inited_fields, field.name)) {
				continue;
			}
			if (v__ast__Type_is_ptr(field.typ) && !v__ast__Type_has_flag(field.typ, v__ast__TypeFlag__shared_f) && !node->has_update_expr && !c->pref->translated) {
				v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("reference field `"), 0xfe10, {.d_s = type_sym->name}}, {_SLIT("."), 0xfe10, {.d_s = field.name}}, {_SLIT("` must be initialized"), 0, { .d_c = 0 }}})), node->pos);
			}
			v__ast__TypeSymbol* sym = v__ast__Table_sym(c->table, field.typ);
			bool has_noinit = false;
			for (int _t14 = 0; _t14 < field.attrs.len; ++_t14) {
				v__ast__Attr attr = ((v__ast__Attr*)field.attrs.data)[_t14];
				if (string__eq(attr.name, _SLIT("noinit"))) {
					has_noinit = true;
					break;
				}
			}
			if (sym->kind == v__ast__Kind__interface_ && (!has_noinit && sym->language != v__ast__Language__js)) {
				v__checker__Checker_note(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("interface field `"), 0xfe10, {.d_s = type_sym->name}}, {_SLIT("."), 0xfe10, {.d_s = field.name}}, {_SLIT("` must be initialized"), 0, { .d_c = 0 }}})), node->pos);
			}
			if (Array_v__ast__Attr_contains(field.attrs, _SLIT("required")) && !node->is_short && !node->has_update_expr) {
				bool found = false;
				for (int _t15 = 0; _t15 < node->fields.len; ++_t15) {
					v__ast__StructInitField init_field = ((v__ast__StructInitField*)node->fields.data)[_t15];
					if (string__eq(field.name, init_field.name)) {
						found = true;
						break;
					}
				}
				if (!found) {
					v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("field `"), 0xfe10, {.d_s = type_sym->name}}, {_SLIT("."), 0xfe10, {.d_s = field.name}}, {_SLIT("` must be initialized"), 0, { .d_c = 0 }}})), node->pos);
				}
			}
		}
	}
	else {
	};
	if (node->has_update_expr) {
		v__ast__Type update_type = v__checker__Checker_expr(c, node->update_expr);
		node->update_expr_type = update_type;
		if (v__ast__Table_type_kind(c->table, update_type) != v__ast__Kind__struct_) {
			string s = v__ast__Table_type_to_str(c->table, update_type);
			v__checker__Checker_error(c,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("expected struct, found `"), 0xfe10, {.d_s = s}}, {_SLIT("`"), 0, { .d_c = 0 }}})), v__ast__Expr_position(node->update_expr));
		} else if (!v__ast__Type_alias_eq(update_type, node->typ)) {
			v__ast__TypeSymbol* from_sym = v__ast__Table_sym(c->table, update_type);
			v__ast__TypeSymbol* to_sym = v__ast__Table_sym(c->table, node->typ);
			v__ast__Struct from_info = /* as */ *(v__ast__Struct*)__as_cast((from_sym->info)._v__ast__Struct,(from_sym->info)._typ, 446) /*expected idx: 446, name: v.ast.Struct */ ;
			v__ast__Struct to_info = /* as */ *(v__ast__Struct*)__as_cast((to_sym->info)._v__ast__Struct,(to_sym->info)._typ, 446) /*expected idx: 446, name: v.ast.Struct */ ;
			if (!v__checker__Checker_check_struct_signature(c, from_info, to_info)) {
				v__checker__Checker_error(c,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("struct `"), 0xfe10, {.d_s = from_sym->name}}, {_SLIT("` is not compatible with struct `"), 0xfe10, {.d_s = to_sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), v__ast__Expr_position(node->update_expr));
			}
		}
		if (!v__ast__Expr_is_lvalue(node->update_expr)) {
			v__checker__Checker_error(c, _SLIT("expression is not an lvalue"), v__ast__Expr_position(node->update_expr));
		}
	}
	v__ast__Type _t16 = node->typ;
	return _t16;
}

VV_LOCAL_SYMBOL bool v__transformer__IndexState_safe_access(v__transformer__IndexState* i, string key, int _v_new) {
	if (i->disabled) {
		bool _t1 = false;
		return _t1;
	}
	int* _t3 = (int*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, i->max_index), &(string[]){key}));
	Option_int _t2 = {0};
	if (_t3) {
		*((int*)&_t2.data) = *((int*)_t3);
	} else {
		_t2.state = 2; _t2.err = _v_error(_SLIT("array index out of range"));
	}
	;
	if (_t2.state != 0) { /*or block*/ 
		IError err = _t2.err;
		;
		map_set(&i->max_index, &(string[]){key}, &(int[]) { _v_new });
		bool _t4 = false;
		return _t4;
	}
	
	int old = *(int*)_t2.data;
	if (_v_new > old) {
		if (old < -1) {
			;
			bool _t5 = false;
			return _t5;
		}
		;
		map_set(&i->max_index, &(string[]){key}, &(int[]) { _v_new });
		bool _t6 = false;
		return _t6;
	}
	;
	bool _t7 = true;
	return _t7;
}

VV_LOCAL_SYMBOL int v__transformer__IndexState_safe_offset(v__transformer__IndexState* i, string key) {
	if (i->disabled) {
		int _t1 = -2;
		return _t1;
	}
	int* _t4 = (int*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, i->max_index), &(string[]){key}));
	Option_int _t3 = {0};
	if (_t4) {
		*((int*)&_t3.data) = *((int*)_t4);
	} else {
		_t3.state = 2; _t3.err = _v_error(_SLIT("array index out of range"));
	}
	;
	if (_t3.state != 0) { /*or block*/ 
		IError err = _t3.err;
		*(int*) _t3.data = -1;
	}
	
	int _t2 = *(int*)_t3.data;
	return _t2;
}

// Attr: [!no_bounds_checking]
VV_LOCAL_SYMBOL void v__transformer__IndexState_indent(v__transformer__IndexState* i, bool is_function) {
	Array_v__transformer__KeyVal kvs = __new_array_with_default(0, i->max_index.len, sizeof(v__transformer__KeyVal), 0);
	Map_string_int _t1 = i->max_index;
	int _t3 = _t1.key_values.len;
	for (int _t2 = 0; _t2 < _t3; ++_t2 ) {
		int _t4 = _t1.key_values.len - _t3;
		_t3 = _t1.key_values.len;
		if (_t4 < 0) {
			_t2 = -1;
			continue;
		}
		if (!DenseArray_has_index(&_t1.key_values, _t2)) {continue;}
		string k = /*key*/ *(string*)DenseArray_key(&_t1.key_values, _t2);
		k = string_clone(k);
		int v = (*(int*)DenseArray_value(&_t1.key_values, _t2));
		array_push((array*)&kvs, _MOV((v__transformer__KeyVal[]){ (v__transformer__KeyVal){.key = k,.value = v,} }));
	}
	array_push((array*)&i->saved_disabled, _MOV((bool[]){ i->disabled }));
	array_push((array*)&i->saved_key_vals, _MOV((Array_v__transformer__KeyVal[]){ kvs }));
	if (is_function) {
		i->disabled = false;
	}
	i->level += 1;
}

// Attr: [!no_bounds_checking]
VV_LOCAL_SYMBOL void v__transformer__IndexState_unindent(v__transformer__IndexState* i) {
	i->level -= 1;
	Array_string keys = __new_array_with_default(0, i->max_index.len, sizeof(string), 0);
	Map_string_int _t1 = i->max_index;
	int _t3 = _t1.key_values.len;
	for (int _t2 = 0; _t2 < _t3; ++_t2 ) {
		int _t4 = _t1.key_values.len - _t3;
		_t3 = _t1.key_values.len;
		if (_t4 < 0) {
			_t2 = -1;
			continue;
		}
		if (!DenseArray_has_index(&_t1.key_values, _t2)) {continue;}
		string k = /*key*/ *(string*)DenseArray_key(&_t1.key_values, _t2);
		k = string_clone(k);
		array_push((array*)&keys, _MOV((string[]){ string_clone(k) }));
	}
	for (int _t6 = 0; _t6 < keys.len; ++_t6) {
		string k = ((string*)keys.data)[_t6];
		map_delete(&i->max_index, &(string[]){k});
	}
	Array_v__transformer__KeyVal _t7 = (*(Array_v__transformer__KeyVal*)array_pop(&i->saved_key_vals));
	for (int _t8 = 0; _t8 < _t7.len; ++_t8) {
		v__transformer__KeyVal saved = ((v__transformer__KeyVal*)_t7.data)[_t8];
		map_set(&i->max_index, &(string[]){saved.key}, &(int[]) { saved.value });
	}
	i->disabled = (*(bool*)array_pop(&i->saved_disabled));
}

v__transformer__Transformer* v__transformer__new_transformer(v__pref__Preferences* pref) {
	v__transformer__Transformer* _t1 = (v__transformer__Transformer*)memdup(&(v__transformer__Transformer){.pref = pref,.index = (v__transformer__IndexState*)memdup(&(v__transformer__IndexState){.max_index = new_map(sizeof(string), sizeof(int), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.saved_disabled = __new_array_with_default(0, 1000, sizeof(bool), 0),.saved_key_vals = __new_array_with_default(0, 1000, sizeof(Array_v__transformer__KeyVal), 0),.disabled = 0,.level = 0,}, sizeof(v__transformer__IndexState)),}, sizeof(v__transformer__Transformer));
	return _t1;
}

void v__transformer__Transformer_transform_files(v__transformer__Transformer* t, Array_v__ast__File_ptr ast_files) {
	for (int i = 0; i < ast_files.len; ++i) {
		v__ast__File* file = (*(v__ast__File**)/*ee elem_typ */array_get(ast_files, i));
		v__transformer__Transformer_transform(t, file);
	}
}

void v__transformer__Transformer_transform(v__transformer__Transformer* t, v__ast__File* ast_file) {
	for (int _t1 = 0; _t1 < ast_file->stmts.len; ++_t1) {
		v__ast__Stmt* stmt = ((v__ast__Stmt*)ast_file->stmts.data) + _t1;
		v__transformer__Transformer_stmt(t, stmt);
	}
}

void v__transformer__Transformer_find_new_array_len(v__transformer__Transformer* t, v__ast__AssignStmt node) {
	if (!t->pref->is_prod) {
		return;
	}
	v__ast__Expr right = (*(v__ast__Expr*)/*ee elem_typ */array_get(node.right, 0));
	if ((right)._typ == 280 /* v.ast.ArrayInit */) {
		v__ast__Expr left = (*(v__ast__Expr*)/*ee elem_typ */array_get(node.left, 0));
		if ((left)._typ == 299 /* v.ast.Ident */) {
			if ((*left._v__ast__Ident).is_mut) {
				v__transformer__IndexState_safe_access(t->index, (*left._v__ast__Ident).name, -2);
				return;
			}
			if (!(*right._v__ast__ArrayInit).has_len) {
				v__transformer__IndexState_safe_access(t->index, (*left._v__ast__Ident).name, -1);
				return;
			}
			int len = ((int)(0));
			v__ast__Expr value = (*right._v__ast__ArrayInit).len_expr;
			if ((value)._typ == 304 /* v.ast.IntegerLiteral */) {
				len = string_int((*value._v__ast__IntegerLiteral).val) + 1;
			}
			v__transformer__IndexState_safe_access(t->index, (*left._v__ast__Ident).name, len);
		}
	}
}

void v__transformer__Transformer_find_new_range(v__transformer__Transformer* t, v__ast__AssignStmt node) {
	if (!t->pref->is_prod) {
		return;
	}
	v__ast__Expr right = (*(v__ast__Expr*)/*ee elem_typ */array_get(node.right, 0));
	if ((right)._typ == 302 /* v.ast.IndexExpr */) {
		v__ast__Expr left = (*(v__ast__Expr*)/*ee elem_typ */array_get(node.left, 0));
		if ((left)._typ == 299 /* v.ast.Ident */) {
			if ((*left._v__ast__Ident).is_mut) {
				v__transformer__IndexState_safe_access(t->index, (*left._v__ast__Ident).name, -2);
				return;
			}
			v__ast__Expr index = (*right._v__ast__IndexExpr).index;
			if ((index)._typ == 317 /* v.ast.RangeExpr */) {
				v__ast__Expr range_low = (*index._v__ast__RangeExpr).low;
				if ((range_low)._typ == 304 /* v.ast.IntegerLiteral */) {
					v__ast__Expr sub_left = (*right._v__ast__IndexExpr).left;
					if ((sub_left)._typ == 299 /* v.ast.Ident */) {
						int safe = v__transformer__IndexState_safe_offset(t->index, (*sub_left._v__ast__Ident).name);
						int low = string_int((*range_low._v__ast__IntegerLiteral).val);
						if (safe >= low) {
							v__transformer__IndexState_safe_access(t->index, (*left._v__ast__Ident).name, safe - low);
						}
					}
				}
			}
		}
	}
}

void v__transformer__Transformer_find_mut_self_assign(v__transformer__Transformer* t, v__ast__AssignStmt node) {
	if (!t->pref->is_prod) {
		return;
	}
}

void v__transformer__Transformer_find_assert_len(v__transformer__Transformer* t, v__ast__InfixExpr node) {
	if (!t->pref->is_prod) {
		return;
	}
	v__ast__Expr right = node.right;
	if (right._typ == 304 /* v.ast.IntegerLiteral */) {
		v__ast__Expr left = node.left;
		if ((left)._typ == 319 /* v.ast.SelectorExpr */) {
			int len = string_int((*right._v__ast__IntegerLiteral).val);
			if (string__eq((*left._v__ast__SelectorExpr).field_name, _SLIT("len"))) {

				if (node.op == (v__token__Kind__eq)) {
					v__transformer__IndexState_safe_access(t->index, v__ast__Expr_str((*left._v__ast__SelectorExpr).expr), len - 1);
				}
				else if (node.op == (v__token__Kind__ge)) {
					v__transformer__IndexState_safe_access(t->index, v__ast__Expr_str((*left._v__ast__SelectorExpr).expr), len - 1);
				}
				else if (node.op == (v__token__Kind__gt)) {
					v__transformer__IndexState_safe_access(t->index, v__ast__Expr_str((*left._v__ast__SelectorExpr).expr), len);
				}
				else {
				};
			}
		}
	}
	else if (right._typ == 319 /* v.ast.SelectorExpr */) {
		v__ast__Expr left = node.left;
		if ((left)._typ == 304 /* v.ast.IntegerLiteral */) {
			int len = string_int((*left._v__ast__IntegerLiteral).val);
			if (string__eq((*right._v__ast__SelectorExpr).field_name, _SLIT("len"))) {

				if (node.op == (v__token__Kind__eq)) {
					v__transformer__IndexState_safe_access(t->index, v__ast__Expr_str((*right._v__ast__SelectorExpr).expr), len - 1);
				}
				else if (node.op == (v__token__Kind__le)) {
					v__transformer__IndexState_safe_access(t->index, v__ast__Expr_str((*right._v__ast__SelectorExpr).expr), len - 1);
				}
				else if (node.op == (v__token__Kind__lt)) {
					v__transformer__IndexState_safe_access(t->index, v__ast__Expr_str((*right._v__ast__SelectorExpr).expr), len);
				}
				else {
				};
			}
		}
	}
	
	else {
	}
	;
}

void v__transformer__Transformer_check_safe_array(v__transformer__Transformer* t, v__ast__IndexExpr* node) {
	if (!t->pref->is_prod) {
		return;
	}
	if (!node->is_array) {
		return;
	}
	v__ast__Expr index = node->index;
	v__ast__Expr name = node->left;
	if (index._typ == 304 /* v.ast.IntegerLiteral */) {
		bool is_direct = v__transformer__IndexState_safe_access(t->index, v__ast__Expr_str(name), string_int((*index._v__ast__IntegerLiteral).val));
		node->is_direct = is_direct;
	}
	else if (index._typ == 317 /* v.ast.RangeExpr */) {
		if ((*index._v__ast__RangeExpr).has_high) {
			v__ast__Expr high = (*index._v__ast__RangeExpr).high;
			if ((high)._typ == 304 /* v.ast.IntegerLiteral */) {
				v__transformer__IndexState_safe_access(t->index, v__ast__Expr_str(name), string_int((*high._v__ast__IntegerLiteral).val));
				return;
			}
		}
		if ((*index._v__ast__RangeExpr).has_low) {
			v__ast__Expr low = (*index._v__ast__RangeExpr).low;
			if ((low)._typ == 304 /* v.ast.IntegerLiteral */) {
				v__transformer__IndexState_safe_access(t->index, v__ast__Expr_str(name), string_int((*low._v__ast__IntegerLiteral).val));
				return;
			}
		}
	}
	else if (index._typ == 287 /* v.ast.CastExpr */) {
		if (!string__eq((*index._v__ast__CastExpr).typname, _SLIT("int"))) {
			return;
		}
		v__ast__Expr index_expr = (*index._v__ast__CastExpr).expr;
		if ((index_expr)._typ == 304 /* v.ast.IntegerLiteral */) {
			string val = (*index_expr._v__ast__IntegerLiteral).val;
			node->is_direct = v__transformer__IndexState_safe_access(t->index, v__ast__Expr_str(name), string_int(val));
		}
	}
	else if (index._typ == 296 /* v.ast.EnumVal */) {
		;
	}
	else if (index._typ == 299 /* v.ast.Ident */) {
	}
	
	else {
	}
	;
}

void v__transformer__Transformer_stmt(v__transformer__Transformer* t, v__ast__Stmt* node) {
	if (node->_typ == 337 /* v.ast.EmptyStmt */) {
	}
	else if (node->_typ == 310 /* v.ast.NodeError */) {
	}
	else if (node->_typ == 329 /* v.ast.AsmStmt */) {
	}
	else if (node->_typ == 330 /* v.ast.AssertStmt */) {
		v__ast__Expr expr = (*node->_v__ast__AssertStmt).expr;
		if (expr._typ == 303 /* v.ast.InfixExpr */) {
			v__transformer__Transformer_find_assert_len(t, (*expr._v__ast__InfixExpr));
		}
		
		else {
			v__transformer__Transformer_expr(t, expr);
		}
		;
	}
	else if (node->_typ == 331 /* v.ast.AssignStmt */) {
		v__transformer__Transformer_find_new_array_len(t, (*node->_v__ast__AssignStmt));
		v__transformer__Transformer_find_new_range(t, (*node->_v__ast__AssignStmt));
		v__transformer__Transformer_find_mut_self_assign(t, (*node->_v__ast__AssignStmt));
		for (int _t1 = 0; _t1 < (*node->_v__ast__AssignStmt).right.len; ++_t1) {
			v__ast__Expr* right = ((v__ast__Expr*)(*node->_v__ast__AssignStmt).right.data) + _t1;
			*right = v__transformer__Transformer_expr(t, *right);
		}
		for (int _t2 = 0; _t2 < (*node->_v__ast__AssignStmt).left.len; ++_t2) {
			v__ast__Expr left = ((v__ast__Expr*)(*node->_v__ast__AssignStmt).left.data)[_t2];
			v__transformer__Transformer_expr(t, left);
		}
	}
	else if (node->_typ == 332 /* v.ast.Block */) {
		v__transformer__IndexState_indent(t->index, false);
		for (int _t3 = 0; _t3 < (*node->_v__ast__Block).stmts.len; ++_t3) {
			v__ast__Stmt* stmt = ((v__ast__Stmt*)(*node->_v__ast__Block).stmts.data) + _t3;
			v__transformer__Transformer_stmt(t, stmt);
		}
		v__transformer__IndexState_unindent(t->index);
	}
	else if (node->_typ == 333 /* v.ast.BranchStmt */) {
		t->index->disabled = true;
	}
	else if (node->_typ == 334 /* v.ast.ComptimeFor */) {
	}
	else if (node->_typ == 335 /* v.ast.ConstDecl */) {
		for (int _t4 = 0; _t4 < (*node->_v__ast__ConstDecl).fields.len; ++_t4) {
			v__ast__ConstField* field = ((v__ast__ConstField*)(*node->_v__ast__ConstDecl).fields.data) + _t4;
			v__ast__Expr expr = v__transformer__Transformer_expr(t, field->expr);
			*field = (v__ast__ConstField){(*field).mod,(*field).name,.expr = expr,(*field).is_pub,(*field).is_markused,(*field).pos,(*field).typ,(*field).comments,(*field).comptime_expr_value,};
		}
	}
	else if (node->_typ == 336 /* v.ast.DeferStmt */) {
	}
	else if (node->_typ == 338 /* v.ast.EnumDecl */) {
	}
	else if (node->_typ == 339 /* v.ast.ExprStmt */) {
		v__ast__Expr expr = (*node->_v__ast__ExprStmt).expr;
		v__ast__Expr _t5 = {0};
		if (expr._typ == 300 /* v.ast.IfExpr */) {
			_t5 = v__transformer__Transformer_if_expr(t, (voidptr)&/*qq*/(*expr._v__ast__IfExpr));
		}
		else if (expr._typ == 309 /* v.ast.MatchExpr */) {
			_t5 = v__transformer__Transformer_match_expr(t, (voidptr)&/*qq*/(*expr._v__ast__MatchExpr));
		}
		
		else {
			_t5 = v__transformer__Transformer_expr(t, expr);
		}
		node = HEAP(v__ast__Stmt, v__ast__ExprStmt_to_sumtype_v__ast__Stmt((v__ast__ExprStmt*)memdup(&(v__ast__ExprStmt){.expr = _t5,(*node->_v__ast__ExprStmt).pos,(*node->_v__ast__ExprStmt).comments,(*node->_v__ast__ExprStmt).is_expr,(*node->_v__ast__ExprStmt).typ,}, sizeof(v__ast__ExprStmt))));
	}
	else if (node->_typ == 216 /* v.ast.FnDecl */) {
		v__transformer__IndexState_indent(t->index, true);
		for (int _t6 = 0; _t6 < (*node->_v__ast__FnDecl).stmts.len; ++_t6) {
			v__ast__Stmt* stmt = ((v__ast__Stmt*)(*node->_v__ast__FnDecl).stmts.data) + _t6;
			v__transformer__Transformer_stmt(t, stmt);
		}
		v__transformer__IndexState_unindent(t->index);
	}
	else if (node->_typ == 340 /* v.ast.ForCStmt */) {
		if ((*node->_v__ast__ForCStmt).has_cond) {
			v__transformer__Transformer_expr(t, (*node->_v__ast__ForCStmt).cond);
		}
		v__transformer__IndexState_indent(t->index, false);
		for (int _t7 = 0; _t7 < (*node->_v__ast__ForCStmt).stmts.len; ++_t7) {
			v__ast__Stmt* stmt = ((v__ast__Stmt*)(*node->_v__ast__ForCStmt).stmts.data) + _t7;
			v__transformer__Transformer_stmt(t, stmt);
		}
		v__transformer__IndexState_unindent(t->index);
	}
	else if (node->_typ == 341 /* v.ast.ForInStmt */) {
		v__transformer__IndexState_indent(t->index, false);
		for (int _t8 = 0; _t8 < (*node->_v__ast__ForInStmt).stmts.len; ++_t8) {
			v__ast__Stmt* stmt = ((v__ast__Stmt*)(*node->_v__ast__ForInStmt).stmts.data) + _t8;
			v__transformer__Transformer_stmt(t, stmt);
		}
		v__transformer__IndexState_unindent(t->index);
	}
	else if (node->_typ == 342 /* v.ast.ForStmt */) {
		v__ast__Expr cond_expr = v__transformer__Transformer_expr(t, (*node->_v__ast__ForStmt).cond);
		node = HEAP(v__ast__Stmt, v__ast__ForStmt_to_sumtype_v__ast__Stmt((v__ast__ForStmt*)memdup(&(v__ast__ForStmt){.cond = cond_expr,(*node->_v__ast__ForStmt).stmts,(*node->_v__ast__ForStmt).is_inf,(*node->_v__ast__ForStmt).pos,(*node->_v__ast__ForStmt).label,(*node->_v__ast__ForStmt).scope,}, sizeof(v__ast__ForStmt))));
		if ((*node->_v__ast__ForStmt).cond._typ == 284 /* v.ast.BoolLiteral */) {
			if (!((*(*node->_v__ast__ForStmt).cond._v__ast__BoolLiteral)).val) {
				node = HEAP(v__ast__Stmt, v__ast__EmptyStmt_to_sumtype_v__ast__Stmt((v__ast__EmptyStmt*)memdup(&(v__ast__EmptyStmt){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},}, sizeof(v__ast__EmptyStmt))));
			}
		}
		
		else {
			if (!(*node->_v__ast__ForStmt).is_inf) {
				v__transformer__IndexState_indent(t->index, false);
				for (int _t9 = 0; _t9 < (*node->_v__ast__ForStmt).stmts.len; ++_t9) {
					v__ast__Stmt* stmt = ((v__ast__Stmt*)(*node->_v__ast__ForStmt).stmts.data) + _t9;
					v__transformer__Transformer_stmt(t, stmt);
				}
				v__transformer__IndexState_unindent(t->index);
			}
		}
		;
	}
	else if (node->_typ == 343 /* v.ast.GlobalDecl */) {
	}
	else if (node->_typ == 344 /* v.ast.GotoLabel */) {
	}
	else if (node->_typ == 345 /* v.ast.GotoStmt */) {
		t->index->disabled = true;
	}
	else if (node->_typ == 346 /* v.ast.HashStmt */) {
	}
	else if (node->_typ == 347 /* v.ast.Import */) {
	}
	else if (node->_typ == 348 /* v.ast.InterfaceDecl */) {
	}
	else if (node->_typ == 349 /* v.ast.Module */) {
	}
	else if (node->_typ == 350 /* v.ast.Return */) {
		for (int _t10 = 0; _t10 < (*node->_v__ast__Return).exprs.len; ++_t10) {
			v__ast__Expr* expr = ((v__ast__Expr*)(*node->_v__ast__Return).exprs.data) + _t10;
			*expr = v__transformer__Transformer_expr(t, *expr);
		}
	}
	else if (node->_typ == 351 /* v.ast.SqlStmt */) {
	}
	else if (node->_typ == 352 /* v.ast.StructDecl */) {
	}
	else if (node->_typ == 277 /* v.ast.TypeDecl */) {
	}
	;
}

v__ast__Expr v__transformer__Transformer_expr(v__transformer__Transformer* t, v__ast__Expr node) {
	if (node._typ == 286 /* v.ast.CallExpr */) {
		for (int _t1 = 0; _t1 < (*node._v__ast__CallExpr).args.len; ++_t1) {
			v__ast__CallArg arg = ((v__ast__CallArg*)(*node._v__ast__CallExpr).args.data)[_t1];
			v__transformer__Transformer_expr(t, arg.expr);
		}
		v__ast__Expr _t2 = node;
		return _t2;
	}
	else if (node._typ == 303 /* v.ast.InfixExpr */) {
		v__ast__Expr _t3 = v__transformer__Transformer_infix_expr(t, (*node._v__ast__InfixExpr));
		return _t3;
	}
	else if (node._typ == 313 /* v.ast.OrExpr */) {
		for (int _t4 = 0; _t4 < (*node._v__ast__OrExpr).stmts.len; ++_t4) {
			v__ast__Stmt* stmt = ((v__ast__Stmt*)(*node._v__ast__OrExpr).stmts.data) + _t4;
			v__transformer__Transformer_stmt(t, stmt);
		}
		v__ast__Expr _t5 = node;
		return _t5;
	}
	else if (node._typ == 302 /* v.ast.IndexExpr */) {
		v__transformer__Transformer_check_safe_array(t, (voidptr)&/*qq*/(*node._v__ast__IndexExpr));
		v__ast__IndexExpr index = (v__ast__IndexExpr){(*node._v__ast__IndexExpr).pos,.index = v__transformer__Transformer_expr(t, (*node._v__ast__IndexExpr).index),(*node._v__ast__IndexExpr).or_expr,(*node._v__ast__IndexExpr).left,(*node._v__ast__IndexExpr).left_type,(*node._v__ast__IndexExpr).is_setter,(*node._v__ast__IndexExpr).is_map,(*node._v__ast__IndexExpr).is_array,(*node._v__ast__IndexExpr).is_farray,(*node._v__ast__IndexExpr).is_option,(*node._v__ast__IndexExpr).is_direct,(*node._v__ast__IndexExpr).is_gated,};
		v__ast__Expr _t6 = v__ast__IndexExpr_to_sumtype_v__ast__Expr(&index);
		return _t6;
	}
	else if (node._typ == 300 /* v.ast.IfExpr */) {
		for (int _t7 = 0; _t7 < (*node._v__ast__IfExpr).branches.len; ++_t7) {
			v__ast__IfBranch* branch = ((v__ast__IfBranch*)(*node._v__ast__IfExpr).branches.data) + _t7;
			*branch = (v__ast__IfBranch){.cond = v__transformer__Transformer_expr(t, branch->cond),(*branch).pos,(*branch).body_pos,(*branch).comments,(*branch).pkg_exist,(*branch).stmts,(*branch).scope,};
			v__transformer__IndexState_indent(t->index, false);
			for (int i = 0; i < branch->stmts.len; ++i) {
				v__ast__Stmt* stmt = ((v__ast__Stmt*)branch->stmts.data) + i;
				v__transformer__Transformer_stmt(t, stmt);
				if (i == branch->stmts.len - 1) {
					if ((stmt)->_typ == 339 /* v.ast.ExprStmt */) {
						v__ast__Expr expr = (/* as */ *(v__ast__ExprStmt*)__as_cast((stmt)->_v__ast__ExprStmt,(stmt)->_typ, 339) /*expected idx: 339, name: v.ast.ExprStmt */ ).expr;
						if (expr._typ == 300 /* v.ast.IfExpr */) {
							if ((*expr._v__ast__IfExpr).branches.len == 1) {
								(*(v__ast__Stmt*)array_pop(&branch->stmts));
								_PUSH_MANY(&branch->stmts, ((*(v__ast__IfBranch*)/*ee elem_typ */array_get((*expr._v__ast__IfExpr).branches, 0)).stmts), _t8, Array_v__ast__Stmt);
								break;
							}
						}
						else if (expr._typ == 309 /* v.ast.MatchExpr */) {
							if ((*expr._v__ast__MatchExpr).branches.len == 1) {
								(*(v__ast__Stmt*)array_pop(&branch->stmts));
								_PUSH_MANY(&branch->stmts, ((*(v__ast__MatchBranch*)/*ee elem_typ */array_get((*expr._v__ast__MatchExpr).branches, 0)).stmts), _t9, Array_v__ast__Stmt);
								break;
							}
						}
						
						else {
						}
						;
					}
				}
			}
			v__transformer__IndexState_unindent(t->index);
		}
		v__transformer__Transformer_expr(t, (*node._v__ast__IfExpr).left);
		v__ast__Expr _t10 = node;
		return _t10;
	}
	else if (node._typ == 309 /* v.ast.MatchExpr */) {
		node = v__ast__MatchExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__MatchExpr, ((v__ast__MatchExpr){(*node._v__ast__MatchExpr).tok_kind,.cond = v__transformer__Transformer_expr(t, (*node._v__ast__MatchExpr).cond),(*node._v__ast__MatchExpr).branches,(*node._v__ast__MatchExpr).pos,(*node._v__ast__MatchExpr).comments,(*node._v__ast__MatchExpr).is_expr,(*node._v__ast__MatchExpr).return_type,(*node._v__ast__MatchExpr).cond_type,(*node._v__ast__MatchExpr).expected_type,(*node._v__ast__MatchExpr).is_sum_type,})));
		for (int _t11 = 0; _t11 < (*node._v__ast__MatchExpr).branches.len; ++_t11) {
			v__ast__MatchBranch* branch = ((v__ast__MatchBranch*)(*node._v__ast__MatchExpr).branches.data) + _t11;
			for (int _t12 = 0; _t12 < branch->exprs.len; ++_t12) {
				v__ast__Expr* expr = ((v__ast__Expr*)branch->exprs.data) + _t12;
				*expr = v__transformer__Transformer_expr(t, *expr);
			}
			v__transformer__IndexState_indent(t->index, false);
			for (int i = 0; i < branch->stmts.len; ++i) {
				v__ast__Stmt* stmt = ((v__ast__Stmt*)branch->stmts.data) + i;
				v__transformer__Transformer_stmt(t, stmt);
				if (i == branch->stmts.len - 1) {
					if ((stmt)->_typ == 339 /* v.ast.ExprStmt */) {
						v__ast__Expr expr = (/* as */ *(v__ast__ExprStmt*)__as_cast((stmt)->_v__ast__ExprStmt,(stmt)->_typ, 339) /*expected idx: 339, name: v.ast.ExprStmt */ ).expr;
						if (expr._typ == 300 /* v.ast.IfExpr */) {
							if ((*expr._v__ast__IfExpr).branches.len == 1) {
								(*(v__ast__Stmt*)array_pop(&branch->stmts));
								_PUSH_MANY(&branch->stmts, ((*(v__ast__IfBranch*)/*ee elem_typ */array_get((*expr._v__ast__IfExpr).branches, 0)).stmts), _t13, Array_v__ast__Stmt);
								break;
							}
						}
						else if (expr._typ == 309 /* v.ast.MatchExpr */) {
							if ((*expr._v__ast__MatchExpr).branches.len == 1) {
								(*(v__ast__Stmt*)array_pop(&branch->stmts));
								_PUSH_MANY(&branch->stmts, ((*(v__ast__MatchBranch*)/*ee elem_typ */array_get((*expr._v__ast__MatchExpr).branches, 0)).stmts), _t14, Array_v__ast__Stmt);
								break;
							}
						}
						
						else {
						}
						;
					}
				}
			}
			v__transformer__IndexState_unindent(t->index);
		}
		v__ast__Expr _t15 = node;
		return _t15;
	}
	else if (node._typ == 278 /* v.ast.AnonFn */) {
		v__ast__Expr _t16 = node;
		return _t16;
	}
	else if (node._typ == 315 /* v.ast.PostfixExpr */) {
		v__ast__Expr _t17 = node;
		return _t17;
	}
	else if (node._typ == 316 /* v.ast.PrefixExpr */) {
		v__ast__Expr _t18 = node;
		return _t18;
	}
	else if (node._typ == 306 /* v.ast.Likely */) {
		v__ast__Expr _t19 = node;
		return _t19;
	}
	
	else {
		v__ast__Expr _t20 = node;
		return _t20;
	}
	;
	return (v__ast__Expr){0};
}

v__ast__Expr v__transformer__Transformer_if_expr(v__transformer__Transformer* t, v__ast__IfExpr* original) {
	int stop_index = -1;
	Array_int unreachable_branches = __new_array_with_default(0, original->branches.len, sizeof(int), 0);
	if (original->is_comptime) {
		v__ast__Expr _t1 = v__ast__IfExpr_to_sumtype_v__ast__Expr(&*original);
		return _t1;
	}
	for (int i = 0; i < original->branches.len; ++i) {
		v__ast__IfBranch* branch = ((v__ast__IfBranch*)original->branches.data) + i;
		v__ast__Expr cond = v__transformer__Transformer_expr(t, branch->cond);
		*branch = (v__ast__IfBranch){.cond = cond,(*branch).pos,(*branch).body_pos,(*branch).comments,(*branch).pkg_exist,(*branch).stmts,(*branch).scope,};
		if ((cond)._typ == 284 /* v.ast.BoolLiteral */) {
			if ((*cond._v__ast__BoolLiteral).val) {
				stop_index = i;
				break;
			} else {
				array_push((array*)&unreachable_branches, _MOV((int[]){ i }));
			}
		}
		v__transformer__IndexState_indent(t->index, false);
		for (int _t3 = 0; _t3 < branch->stmts.len; ++_t3) {
			v__ast__Stmt* stmt = ((v__ast__Stmt*)branch->stmts.data) + _t3;
			v__transformer__Transformer_stmt(t, stmt);
		}
		v__transformer__IndexState_unindent(t->index);
	}
	if (stop_index != -1) {
		Array_int _t4 = __new_array(0, 0, sizeof(int));
		Array_int _t4_orig = unreachable_branches;
		int _t4_len = _t4_orig.len;
		_t4 = __new_array(0, _t4_len, sizeof(int));

		for (int _t5 = 0; _t5 < _t4_len; ++_t5) {
			int it = ((int*) _t4_orig.data)[_t5];
			if (it < stop_index) {
				array_push((array*)&_t4, &it);
			}
		}
		unreachable_branches =_t4;
		original->branches = array_slice(original->branches, 0, stop_index + 1);
	}
	for (;;) {
		if (!(unreachable_branches.len != 0)) break;
		array_delete(&original->branches, (*(int*)array_pop(&unreachable_branches)));
	}
	if (original->branches.len == 0) {
		v__ast__Expr _t6 = v__ast__EmptyExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__EmptyExpr, ((v__ast__EmptyExpr){.x = 0,})));
		return _t6;
	}
	if (original->branches.len == 1 && string__eq(charptr_vstring_literal( /* v.ast.Expr */ v_typeof_sumtype_v__ast__Expr( ((*(v__ast__IfBranch*)/*ee elem_typ */array_get(original->branches, 0)).cond)._typ )), _SLIT("unknown v.ast.Expr"))) {
		(*(v__ast__IfBranch*)/*ee elem_typ */array_get(original->branches, 0)) = *(v__ast__IfBranch*)memdup(&(v__ast__IfBranch){.cond = v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, ((v__ast__BoolLiteral){.val = true,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},}))),(*(v__ast__IfBranch*)/*ee elem_typ */array_get(original->branches, 0)).pos,(*(v__ast__IfBranch*)/*ee elem_typ */array_get(original->branches, 0)).body_pos,(*(v__ast__IfBranch*)/*ee elem_typ */array_get(original->branches, 0)).comments,(*(v__ast__IfBranch*)/*ee elem_typ */array_get(original->branches, 0)).pkg_exist,(*(v__ast__IfBranch*)/*ee elem_typ */array_get(original->branches, 0)).stmts,(*(v__ast__IfBranch*)/*ee elem_typ */array_get(original->branches, 0)).scope,}, sizeof(v__ast__IfBranch));
	}
	v__ast__Expr _t7 = v__ast__IfExpr_to_sumtype_v__ast__Expr(&*original);
	return _t7;
}

v__ast__Expr v__transformer__Transformer_match_expr(v__transformer__Transformer* t, v__ast__MatchExpr* original) {
	v__ast__Expr cond = v__transformer__Transformer_expr(t, original->cond);
	bool terminate = false;
	*original = (v__ast__MatchExpr){(*original).tok_kind,.cond = cond,(*original).branches,(*original).pos,(*original).comments,(*original).is_expr,(*original).return_type,(*original).cond_type,(*original).expected_type,(*original).is_sum_type,};
	for (int _t1 = 0; _t1 < original->branches.len; ++_t1) {
		v__ast__MatchBranch* branch = ((v__ast__MatchBranch*)original->branches.data) + _t1;
		if (branch->is_else) {
			v__transformer__IndexState_indent(t->index, false);
			for (int _t2 = 0; _t2 < branch->stmts.len; ++_t2) {
				v__ast__Stmt* stmt = ((v__ast__Stmt*)branch->stmts.data) + _t2;
				v__transformer__Transformer_stmt(t, stmt);
			}
			v__transformer__IndexState_unindent(t->index);
			continue;
		}
		for (int _t3 = 0; _t3 < branch->exprs.len; ++_t3) {
			v__ast__Expr* expr = ((v__ast__Expr*)branch->exprs.data) + _t3;
			*expr = v__transformer__Transformer_expr(t, *expr);
			if (cond._typ == 284 /* v.ast.BoolLiteral */) {
				if ((expr)->_typ == 284 /* v.ast.BoolLiteral */) {
					if ((*cond._v__ast__BoolLiteral).val == (/* as */ *(v__ast__BoolLiteral*)__as_cast((expr)->_v__ast__BoolLiteral,(expr)->_typ, 284) /*expected idx: 284, name: v.ast.BoolLiteral */ ).val) {
						branch->exprs = new_array_from_c_array(1, 1, sizeof(v__ast__Expr), _MOV((v__ast__Expr[1]){*expr}));
						*original = (v__ast__MatchExpr){(*original).tok_kind,(*original).cond,.branches = new_array_from_c_array(1, 1, sizeof(v__ast__MatchBranch), _MOV((v__ast__MatchBranch[1]){*branch})),(*original).pos,(*original).comments,(*original).is_expr,(*original).return_type,(*original).cond_type,(*original).expected_type,(*original).is_sum_type,};
						terminate = true;
					}
				}
			}
			else if (cond._typ == 304 /* v.ast.IntegerLiteral */) {
				if ((expr)->_typ == 304 /* v.ast.IntegerLiteral */) {
					if (string_int((*cond._v__ast__IntegerLiteral).val) == string_int((/* as */ *(v__ast__IntegerLiteral*)__as_cast((expr)->_v__ast__IntegerLiteral,(expr)->_typ, 304) /*expected idx: 304, name: v.ast.IntegerLiteral */ ).val)) {
						branch->exprs = new_array_from_c_array(1, 1, sizeof(v__ast__Expr), _MOV((v__ast__Expr[1]){*expr}));
						*original = (v__ast__MatchExpr){(*original).tok_kind,(*original).cond,.branches = new_array_from_c_array(1, 1, sizeof(v__ast__MatchBranch), _MOV((v__ast__MatchBranch[1]){*branch})),(*original).pos,(*original).comments,(*original).is_expr,(*original).return_type,(*original).cond_type,(*original).expected_type,(*original).is_sum_type,};
						terminate = true;
					}
				}
			}
			else if (cond._typ == 297 /* v.ast.FloatLiteral */) {
				if ((expr)->_typ == 297 /* v.ast.FloatLiteral */) {
					if (string_f32((*cond._v__ast__FloatLiteral).val) == string_f32((/* as */ *(v__ast__FloatLiteral*)__as_cast((expr)->_v__ast__FloatLiteral,(expr)->_typ, 297) /*expected idx: 297, name: v.ast.FloatLiteral */ ).val)) {
						branch->exprs = new_array_from_c_array(1, 1, sizeof(v__ast__Expr), _MOV((v__ast__Expr[1]){*expr}));
						*original = (v__ast__MatchExpr){(*original).tok_kind,(*original).cond,.branches = new_array_from_c_array(1, 1, sizeof(v__ast__MatchBranch), _MOV((v__ast__MatchBranch[1]){*branch})),(*original).pos,(*original).comments,(*original).is_expr,(*original).return_type,(*original).cond_type,(*original).expected_type,(*original).is_sum_type,};
						terminate = true;
					}
				}
			}
			else if (cond._typ == 323 /* v.ast.StringLiteral */) {
				if ((expr)->_typ == 323 /* v.ast.StringLiteral */) {
					if (string__eq((*cond._v__ast__StringLiteral).val, (/* as */ *(v__ast__StringLiteral*)__as_cast((expr)->_v__ast__StringLiteral,(expr)->_typ, 323) /*expected idx: 323, name: v.ast.StringLiteral */ ).val)) {
						branch->exprs = new_array_from_c_array(1, 1, sizeof(v__ast__Expr), _MOV((v__ast__Expr[1]){*expr}));
						*original = (v__ast__MatchExpr){(*original).tok_kind,(*original).cond,.branches = new_array_from_c_array(1, 1, sizeof(v__ast__MatchBranch), _MOV((v__ast__MatchBranch[1]){*branch})),(*original).pos,(*original).comments,(*original).is_expr,(*original).return_type,(*original).cond_type,(*original).expected_type,(*original).is_sum_type,};
						terminate = true;
					}
				}
			}
			
			else {
			}
			;
		}
		v__transformer__IndexState_indent(t->index, false);
		for (int _t4 = 0; _t4 < branch->stmts.len; ++_t4) {
			v__ast__Stmt* stmt = ((v__ast__Stmt*)branch->stmts.data) + _t4;
			v__transformer__Transformer_stmt(t, stmt);
		}
		v__transformer__IndexState_unindent(t->index);
		if (terminate) {
			break;
		}
	}
	v__ast__Expr _t5 = v__ast__MatchExpr_to_sumtype_v__ast__Expr(&*original);
	return _t5;
}

v__ast__Expr v__transformer__Transformer_infix_expr(v__transformer__Transformer* t, v__ast__InfixExpr original) {
	v__ast__InfixExpr node = original;
	node.left = v__transformer__Transformer_expr(t, node.left);
	node.right = v__transformer__Transformer_expr(t, node.right);
	v__token__Position pos = v__ast__Expr_position(node.left);
	v__token__Position_extend(pos, node.pos);
	v__token__Position_extend(pos, v__ast__Expr_position(node.right));
	v__ast__Expr left_node = node.left;
	v__ast__Expr right_node = node.right;
	if (left_node._typ == 284 /* v.ast.BoolLiteral */) {
		if (right_node._typ == 284 /* v.ast.BoolLiteral */) {

			if (node.op == (v__token__Kind__eq)) {
				v__ast__Expr _t1 = v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, ((v__ast__BoolLiteral){.val = (*left_node._v__ast__BoolLiteral).val == (*right_node._v__ast__BoolLiteral).val,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},})));
				return _t1;
			}
			else if (node.op == (v__token__Kind__ne)) {
				v__ast__Expr _t2 = v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, ((v__ast__BoolLiteral){.val = (*left_node._v__ast__BoolLiteral).val != (*right_node._v__ast__BoolLiteral).val,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},})));
				return _t2;
			}
			else if (node.op == (v__token__Kind__and)) {
				v__ast__Expr _t3 = v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, ((v__ast__BoolLiteral){.val = (*left_node._v__ast__BoolLiteral).val && (*right_node._v__ast__BoolLiteral).val,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},})));
				return _t3;
			}
			else if (node.op == (v__token__Kind__logical_or)) {
				v__ast__Expr _t4 = v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, ((v__ast__BoolLiteral){.val = (*left_node._v__ast__BoolLiteral).val || (*right_node._v__ast__BoolLiteral).val,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},})));
				return _t4;
			}
			else {
				v__ast__Expr _t5 = v__ast__InfixExpr_to_sumtype_v__ast__Expr(&node);
				return _t5;
			};
		}
		
		else {
			v__ast__Expr _t6 = v__ast__InfixExpr_to_sumtype_v__ast__Expr(&node);
			return _t6;
		}
		;
	}
	else if (left_node._typ == 323 /* v.ast.StringLiteral */) {
		if (right_node._typ == 323 /* v.ast.StringLiteral */) {

			if (node.op == (v__token__Kind__eq)) {
				v__ast__Expr _t7 = v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, ((v__ast__BoolLiteral){.val = string__eq((*left_node._v__ast__StringLiteral).val, (*right_node._v__ast__StringLiteral).val),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},})));
				return _t7;
			}
			else if (node.op == (v__token__Kind__ne)) {
				v__ast__Expr _t8 = v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, ((v__ast__BoolLiteral){.val = !string__eq((*left_node._v__ast__StringLiteral).val, (*right_node._v__ast__StringLiteral).val),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},})));
				return _t8;
			}
			else if (node.op == (v__token__Kind__plus)) {
				v__ast__Expr _t9 = (t->pref->backend == v__pref__Backend__c ? (v__ast__StringLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__StringLiteral, ((v__ast__StringLiteral){.val = string__plus(v__util__smart_quote((*left_node._v__ast__StringLiteral).val, (*left_node._v__ast__StringLiteral).is_raw), v__util__smart_quote((*right_node._v__ast__StringLiteral).val, (*right_node._v__ast__StringLiteral).is_raw)),.is_raw = 0,.language = 0,.pos = pos,})))) : (v__ast__InfixExpr_to_sumtype_v__ast__Expr(&node)));
				return _t9;
			}
			else {
				v__ast__Expr _t10 = v__ast__InfixExpr_to_sumtype_v__ast__Expr(&node);
				return _t10;
			};
		}
		
		else {
			v__ast__Expr _t11 = v__ast__InfixExpr_to_sumtype_v__ast__Expr(&node);
			return _t11;
		}
		;
	}
	else if (left_node._typ == 304 /* v.ast.IntegerLiteral */) {
		if (right_node._typ == 304 /* v.ast.IntegerLiteral */) {
			int left_val = string_int((*left_node._v__ast__IntegerLiteral).val);
			int right_val = string_int((*right_node._v__ast__IntegerLiteral).val);
			switch (node.op) {
				case v__token__Kind__eq: 
					{
						v__ast__Expr _t12 = v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, ((v__ast__BoolLiteral){.val = string__eq((*left_node._v__ast__IntegerLiteral).val, (*right_node._v__ast__IntegerLiteral).val),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},})));
						return _t12;
					} break;
				case v__token__Kind__ne: 
					{
						v__ast__Expr _t13 = v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, ((v__ast__BoolLiteral){.val = !string__eq((*left_node._v__ast__IntegerLiteral).val, (*right_node._v__ast__IntegerLiteral).val),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},})));
						return _t13;
					} break;
				case v__token__Kind__gt: 
					{
						v__ast__Expr _t14 = v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, ((v__ast__BoolLiteral){.val = string__lt((*right_node._v__ast__IntegerLiteral).val, (*left_node._v__ast__IntegerLiteral).val),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},})));
						return _t14;
					} break;
				case v__token__Kind__ge: 
					{
						v__ast__Expr _t15 = v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, ((v__ast__BoolLiteral){.val = !string__lt((*left_node._v__ast__IntegerLiteral).val, (*right_node._v__ast__IntegerLiteral).val),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},})));
						return _t15;
					} break;
				case v__token__Kind__lt: 
					{
						v__ast__Expr _t16 = v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, ((v__ast__BoolLiteral){.val = string__lt((*left_node._v__ast__IntegerLiteral).val, (*right_node._v__ast__IntegerLiteral).val),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},})));
						return _t16;
					} break;
				case v__token__Kind__le: 
					{
						v__ast__Expr _t17 = v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, ((v__ast__BoolLiteral){.val = !string__lt((*right_node._v__ast__IntegerLiteral).val, (*left_node._v__ast__IntegerLiteral).val),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},})));
						return _t17;
					} break;
				case v__token__Kind__plus: 
					{
						v__ast__Expr _t18 = v__ast__IntegerLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__IntegerLiteral, ((v__ast__IntegerLiteral){.val = int_str((left_val + right_val)),.pos = pos,})));
						return _t18;
					} break;
				case v__token__Kind__mul: 
					{
						v__ast__Expr _t19 = v__ast__IntegerLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__IntegerLiteral, ((v__ast__IntegerLiteral){.val = int_str((left_val * right_val)),.pos = pos,})));
						return _t19;
					} break;
				case v__token__Kind__minus: 
					{
						v__ast__Expr _t20 = v__ast__IntegerLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__IntegerLiteral, ((v__ast__IntegerLiteral){.val = int_str((left_val - right_val)),.pos = pos,})));
						return _t20;
					} break;
				case v__token__Kind__div: 
					{
						v__ast__Expr _t21 = v__ast__IntegerLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__IntegerLiteral, ((v__ast__IntegerLiteral){.val = int_str((left_val / right_val)),.pos = pos,})));
						return _t21;
					} break;
				case v__token__Kind__mod: 
					{
						v__ast__Expr _t22 = v__ast__IntegerLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__IntegerLiteral, ((v__ast__IntegerLiteral){.val = int_str((left_val % right_val)),.pos = pos,})));
						return _t22;
					} break;
				case v__token__Kind__xor: 
					{
						v__ast__Expr _t23 = v__ast__IntegerLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__IntegerLiteral, ((v__ast__IntegerLiteral){.val = int_str(((left_val ^ right_val))),.pos = pos,})));
						return _t23;
					} break;
				case v__token__Kind__pipe: 
					{
						v__ast__Expr _t24 = v__ast__IntegerLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__IntegerLiteral, ((v__ast__IntegerLiteral){.val = int_str(((left_val | right_val))),.pos = pos,})));
						return _t24;
					} break;
				case v__token__Kind__amp: 
					{
						v__ast__Expr _t25 = v__ast__IntegerLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__IntegerLiteral, ((v__ast__IntegerLiteral){.val = int_str(((left_val & right_val))),.pos = pos,})));
						return _t25;
					} break;
				case v__token__Kind__left_shift: 
					{
						v__ast__Expr _t26 = v__ast__IntegerLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__IntegerLiteral, ((v__ast__IntegerLiteral){.val = u32_str((((u32)(left_val)) << right_val)),.pos = pos,})));
						return _t26;
					} break;
				case v__token__Kind__right_shift: 
					{
						v__ast__Expr _t27 = v__ast__IntegerLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__IntegerLiteral, ((v__ast__IntegerLiteral){.val = int_str((left_val >> right_val)),.pos = pos,})));
						return _t27;
					} break;
				case v__token__Kind__unsigned_right_shift: 
					{
						v__ast__Expr _t28 = v__ast__IntegerLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__IntegerLiteral, ((v__ast__IntegerLiteral){.val = u32_str((((u32)(left_val)) >> right_val)),.pos = pos,})));
						return _t28;
					} break;
				case v__token__Kind__unknown:
				case v__token__Kind__eof:
				case v__token__Kind__name:
				case v__token__Kind__number:
				case v__token__Kind__string:
				case v__token__Kind__str_inter:
				case v__token__Kind__chartoken:
				case v__token__Kind__inc:
				case v__token__Kind__dec:
				case v__token__Kind__and:
				case v__token__Kind__logical_or:
				case v__token__Kind__not:
				case v__token__Kind__bit_not:
				case v__token__Kind__question:
				case v__token__Kind__comma:
				case v__token__Kind__semicolon:
				case v__token__Kind__colon:
				case v__token__Kind__arrow:
				case v__token__Kind__hash:
				case v__token__Kind__dollar:
				case v__token__Kind__at:
				case v__token__Kind__str_dollar:
				case v__token__Kind__not_in:
				case v__token__Kind__not_is:
				case v__token__Kind__assign:
				case v__token__Kind__decl_assign:
				case v__token__Kind__plus_assign:
				case v__token__Kind__minus_assign:
				case v__token__Kind__div_assign:
				case v__token__Kind__mult_assign:
				case v__token__Kind__xor_assign:
				case v__token__Kind__mod_assign:
				case v__token__Kind__or_assign:
				case v__token__Kind__and_assign:
				case v__token__Kind__right_shift_assign:
				case v__token__Kind__left_shift_assign:
				case v__token__Kind__unsigned_right_shift_assign:
				case v__token__Kind__lcbr:
				case v__token__Kind__rcbr:
				case v__token__Kind__lpar:
				case v__token__Kind__rpar:
				case v__token__Kind__lsbr:
				case v__token__Kind__nilsbr:
				case v__token__Kind__rsbr:
				case v__token__Kind__comment:
				case v__token__Kind__nl:
				case v__token__Kind__dot:
				case v__token__Kind__dotdot:
				case v__token__Kind__ellipsis:
				case v__token__Kind__keyword_beg:
				case v__token__Kind__key_as:
				case v__token__Kind__key_asm:
				case v__token__Kind__key_assert:
				case v__token__Kind__key_atomic:
				case v__token__Kind__key_break:
				case v__token__Kind__key_const:
				case v__token__Kind__key_continue:
				case v__token__Kind__key_defer:
				case v__token__Kind__key_else:
				case v__token__Kind__key_enum:
				case v__token__Kind__key_false:
				case v__token__Kind__key_for:
				case v__token__Kind__key_fn:
				case v__token__Kind__key_global:
				case v__token__Kind__key_go:
				case v__token__Kind__key_goto:
				case v__token__Kind__key_if:
				case v__token__Kind__key_import:
				case v__token__Kind__key_in:
				case v__token__Kind__key_interface:
				case v__token__Kind__key_is:
				case v__token__Kind__key_match:
				case v__token__Kind__key_module:
				case v__token__Kind__key_mut:
				case v__token__Kind__key_shared:
				case v__token__Kind__key_lock:
				case v__token__Kind__key_rlock:
				case v__token__Kind__key_none:
				case v__token__Kind__key_return:
				case v__token__Kind__key_select:
				case v__token__Kind__key_sizeof:
				case v__token__Kind__key_isreftype:
				case v__token__Kind__key_likely:
				case v__token__Kind__key_unlikely:
				case v__token__Kind__key_offsetof:
				case v__token__Kind__key_struct:
				case v__token__Kind__key_true:
				case v__token__Kind__key_type:
				case v__token__Kind__key_typeof:
				case v__token__Kind__key_dump:
				case v__token__Kind__key_orelse:
				case v__token__Kind__key_union:
				case v__token__Kind__key_pub:
				case v__token__Kind__key_static:
				case v__token__Kind__key_volatile:
				case v__token__Kind__key_unsafe:
				case v__token__Kind__keyword_end:
				case v__token__Kind___end_:
				default:
					{
						v__ast__Expr _t29 = v__ast__InfixExpr_to_sumtype_v__ast__Expr(&node);
						return _t29;
					} break;
			}
			;
		}
		
		else {
			v__ast__Expr _t30 = v__ast__InfixExpr_to_sumtype_v__ast__Expr(&node);
			return _t30;
		}
		;
	}
	else if (left_node._typ == 297 /* v.ast.FloatLiteral */) {
		if (right_node._typ == 297 /* v.ast.FloatLiteral */) {
			f32 left_val = string_f32((*left_node._v__ast__FloatLiteral).val);
			f32 right_val = string_f32((*right_node._v__ast__FloatLiteral).val);
			switch (node.op) {
				case v__token__Kind__eq: 
					{
						v__ast__Expr _t31 = v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, ((v__ast__BoolLiteral){.val = string__eq((*left_node._v__ast__FloatLiteral).val, (*right_node._v__ast__FloatLiteral).val),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},})));
						return _t31;
					} break;
				case v__token__Kind__ne: 
					{
						v__ast__Expr _t32 = v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, ((v__ast__BoolLiteral){.val = !string__eq((*left_node._v__ast__FloatLiteral).val, (*right_node._v__ast__FloatLiteral).val),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},})));
						return _t32;
					} break;
				case v__token__Kind__gt: 
					{
						v__ast__Expr _t33 = v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, ((v__ast__BoolLiteral){.val = string__lt((*right_node._v__ast__FloatLiteral).val, (*left_node._v__ast__FloatLiteral).val),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},})));
						return _t33;
					} break;
				case v__token__Kind__ge: 
					{
						v__ast__Expr _t34 = v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, ((v__ast__BoolLiteral){.val = !string__lt((*left_node._v__ast__FloatLiteral).val, (*right_node._v__ast__FloatLiteral).val),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},})));
						return _t34;
					} break;
				case v__token__Kind__lt: 
					{
						v__ast__Expr _t35 = v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, ((v__ast__BoolLiteral){.val = string__lt((*left_node._v__ast__FloatLiteral).val, (*right_node._v__ast__FloatLiteral).val),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},})));
						return _t35;
					} break;
				case v__token__Kind__le: 
					{
						v__ast__Expr _t36 = v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, ((v__ast__BoolLiteral){.val = !string__lt((*right_node._v__ast__FloatLiteral).val, (*left_node._v__ast__FloatLiteral).val),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},})));
						return _t36;
					} break;
				case v__token__Kind__plus: 
					{
						v__ast__Expr _t37 = v__ast__FloatLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__FloatLiteral, ((v__ast__FloatLiteral){.val = f32_str((left_val + right_val)),.pos = pos,})));
						return _t37;
					} break;
				case v__token__Kind__mul: 
					{
						v__ast__Expr _t38 = v__ast__FloatLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__FloatLiteral, ((v__ast__FloatLiteral){.val = f32_str((left_val * right_val)),.pos = pos,})));
						return _t38;
					} break;
				case v__token__Kind__minus: 
					{
						v__ast__Expr _t39 = v__ast__FloatLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__FloatLiteral, ((v__ast__FloatLiteral){.val = f32_str((left_val - right_val)),.pos = pos,})));
						return _t39;
					} break;
				case v__token__Kind__div: 
					{
						v__ast__Expr _t40 = v__ast__FloatLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__FloatLiteral, ((v__ast__FloatLiteral){.val = f32_str((left_val / right_val)),.pos = pos,})));
						return _t40;
					} break;
				case v__token__Kind__unknown:
				case v__token__Kind__eof:
				case v__token__Kind__name:
				case v__token__Kind__number:
				case v__token__Kind__string:
				case v__token__Kind__str_inter:
				case v__token__Kind__chartoken:
				case v__token__Kind__mod:
				case v__token__Kind__xor:
				case v__token__Kind__pipe:
				case v__token__Kind__inc:
				case v__token__Kind__dec:
				case v__token__Kind__and:
				case v__token__Kind__logical_or:
				case v__token__Kind__not:
				case v__token__Kind__bit_not:
				case v__token__Kind__question:
				case v__token__Kind__comma:
				case v__token__Kind__semicolon:
				case v__token__Kind__colon:
				case v__token__Kind__arrow:
				case v__token__Kind__amp:
				case v__token__Kind__hash:
				case v__token__Kind__dollar:
				case v__token__Kind__at:
				case v__token__Kind__str_dollar:
				case v__token__Kind__left_shift:
				case v__token__Kind__right_shift:
				case v__token__Kind__unsigned_right_shift:
				case v__token__Kind__not_in:
				case v__token__Kind__not_is:
				case v__token__Kind__assign:
				case v__token__Kind__decl_assign:
				case v__token__Kind__plus_assign:
				case v__token__Kind__minus_assign:
				case v__token__Kind__div_assign:
				case v__token__Kind__mult_assign:
				case v__token__Kind__xor_assign:
				case v__token__Kind__mod_assign:
				case v__token__Kind__or_assign:
				case v__token__Kind__and_assign:
				case v__token__Kind__right_shift_assign:
				case v__token__Kind__left_shift_assign:
				case v__token__Kind__unsigned_right_shift_assign:
				case v__token__Kind__lcbr:
				case v__token__Kind__rcbr:
				case v__token__Kind__lpar:
				case v__token__Kind__rpar:
				case v__token__Kind__lsbr:
				case v__token__Kind__nilsbr:
				case v__token__Kind__rsbr:
				case v__token__Kind__comment:
				case v__token__Kind__nl:
				case v__token__Kind__dot:
				case v__token__Kind__dotdot:
				case v__token__Kind__ellipsis:
				case v__token__Kind__keyword_beg:
				case v__token__Kind__key_as:
				case v__token__Kind__key_asm:
				case v__token__Kind__key_assert:
				case v__token__Kind__key_atomic:
				case v__token__Kind__key_break:
				case v__token__Kind__key_const:
				case v__token__Kind__key_continue:
				case v__token__Kind__key_defer:
				case v__token__Kind__key_else:
				case v__token__Kind__key_enum:
				case v__token__Kind__key_false:
				case v__token__Kind__key_for:
				case v__token__Kind__key_fn:
				case v__token__Kind__key_global:
				case v__token__Kind__key_go:
				case v__token__Kind__key_goto:
				case v__token__Kind__key_if:
				case v__token__Kind__key_import:
				case v__token__Kind__key_in:
				case v__token__Kind__key_interface:
				case v__token__Kind__key_is:
				case v__token__Kind__key_match:
				case v__token__Kind__key_module:
				case v__token__Kind__key_mut:
				case v__token__Kind__key_shared:
				case v__token__Kind__key_lock:
				case v__token__Kind__key_rlock:
				case v__token__Kind__key_none:
				case v__token__Kind__key_return:
				case v__token__Kind__key_select:
				case v__token__Kind__key_sizeof:
				case v__token__Kind__key_isreftype:
				case v__token__Kind__key_likely:
				case v__token__Kind__key_unlikely:
				case v__token__Kind__key_offsetof:
				case v__token__Kind__key_struct:
				case v__token__Kind__key_true:
				case v__token__Kind__key_type:
				case v__token__Kind__key_typeof:
				case v__token__Kind__key_dump:
				case v__token__Kind__key_orelse:
				case v__token__Kind__key_union:
				case v__token__Kind__key_pub:
				case v__token__Kind__key_static:
				case v__token__Kind__key_volatile:
				case v__token__Kind__key_unsafe:
				case v__token__Kind__keyword_end:
				case v__token__Kind___end_:
				default:
					{
						v__ast__Expr _t41 = v__ast__InfixExpr_to_sumtype_v__ast__Expr(&node);
						return _t41;
					} break;
			}
			;
		}
		
		else {
			v__ast__Expr _t42 = v__ast__InfixExpr_to_sumtype_v__ast__Expr(&node);
			return _t42;
		}
		;
	}
	
	else {
		v__ast__Expr _t43 = v__ast__InfixExpr_to_sumtype_v__ast__Expr(&node);
		return _t43;
	}
	;
	return (v__ast__Expr){0};
}

void v__markused__mark_used(v__ast__Table* table, v__pref__Preferences* pref, Array_v__ast__File_ptr ast_files) {
bool v__markused__mark_used_defer_0 = false;
	multi_return_Map_string_v__ast__FnDecl_Map_string_v__ast__ConstField_Map_string_v__ast__GlobalField mr_434 = v__markused__all_fn_const_and_global(ast_files);
	Map_string_v__ast__FnDecl all_fns = mr_434.arg0;
	Map_string_v__ast__ConstField all_consts = mr_434.arg1;
	Map_string_v__ast__GlobalField all_globals = mr_434.arg2;
	v__util__timing_start(_SLIT("mark_used"));
	v__markused__mark_used_defer_0 = true;
	Array_string all_fn_root_names = new_array_from_c_array(97, 97, sizeof(string), _MOV((string[97]){
			_SLIT("main.main"), _SLIT("__new_array"), _SLIT("str_intp"), _SLIT("format_sb"), _SLIT("__new_array_with_default"), _SLIT("__new_array_with_array_default"), _SLIT("v_realloc"), _SLIT("malloc"), _SLIT("malloc_noscan"),
			_SLIT("vcalloc"), _SLIT("vcalloc_noscan"), _SLIT("new_array_from_c_array"), _SLIT("v_fixed_index"), _SLIT("memdup"), _SLIT("vstrlen"), _SLIT("__as_cast"), _SLIT("tos"),
			_SLIT("tos2"), _SLIT("tos3"), _SLIT("isnil"), _SLIT("opt_ok"), _SLIT("error"), _SLIT("utf8_str_visible_length"), _SLIT("compare_ints"), _SLIT("compare_u64s"),
			_SLIT("compare_strings"), _SLIT("compare_ints_reverse"), _SLIT("compare_u64s_reverse"), _SLIT("compare_strings_reverse"), _SLIT("builtin_init"), _SLIT("3.vstring"), _SLIT("3.vstring_with_len"), _SLIT("3.vstring_literal"),
			_SLIT("4.vstring"), _SLIT("4.vstring_with_len"), _SLIT("4.vstring_literal"), _SLIT("10.str_escaped"), _SLIT("20.add"), _SLIT("20.trim_space"), _SLIT("20.repeat"), _SLIT("20.replace"),
			_SLIT("20.clone"), _SLIT("20.clone_static"), _SLIT("20.trim"), _SLIT("20.substr"), _SLIT("20.at"), _SLIT("20.at_with_check"), _SLIT("20.index_kmp"), _SLIT("20.eq"),
			_SLIT("20.ne"), _SLIT("20.lt"), _SLIT("20.gt"), _SLIT("20.le"), _SLIT("20.ge"), _SLIT("fast_string_eq"), _SLIT("22.get"), _SLIT("22.set"),
			_SLIT("22.get_unsafe"), _SLIT("22.set_unsafe"), _SLIT("22.get_with_check"), _SLIT("22.clone_static_to_depth"), _SLIT("22.clone_to_depth"), _SLIT("22.first"), _SLIT("22.last"), _SLIT("22.pointers"),
			_SLIT("22.reverse"), _SLIT("22.repeat_to_depth"), _SLIT("22.slice"), _SLIT("22.slice2"), _SLIT("61.get"), _SLIT("61.set"), _SLIT("65558.last"), _SLIT("65558.pop"),
			_SLIT("65558.push"), _SLIT("65558.insert_many"), _SLIT("65558.prepend_many"), _SLIT("65558.reverse"), _SLIT("65558.set"), _SLIT("65558.set_unsafe"), _SLIT("json.decode_string"), _SLIT("json.decode_int"),
			_SLIT("json.decode_bool"), _SLIT("json.decode_u64"), _SLIT("json.encode_int"), _SLIT("json.encode_string"), _SLIT("json.encode_bool"), _SLIT("json.encode_u64"), _SLIT("json.json_print"), _SLIT("json.json_parse"),
			_SLIT("main.nasserts"), _SLIT("main.vtest_init"), _SLIT("main.vtest_new_metainfo"), _SLIT("main.vtest_new_filemetainfo"), _SLIT("os.getwd"), _SLIT("os.init_os_args"), _SLIT("os.init_os_args_wide"), _SLIT("v.embed_file.find_index_entry_by_path")}));
	if (pref->is_bare) {
		_PUSH_MANY(&all_fn_root_names, (new_array_from_c_array(6, 6, sizeof(string), _MOV((string[6]){_SLIT("strlen"), _SLIT("memcmp"), _SLIT("memcpy"), _SLIT("realloc"), _SLIT("vsnprintf"), _SLIT("vsprintf")}))), _t1, Array_string);
	}
	if (pref->gc_mode == v__pref__GarbageCollectionMode__boehm_full_opt || pref->gc_mode == v__pref__GarbageCollectionMode__boehm_incr_opt) {
		_PUSH_MANY(&all_fn_root_names, (new_array_from_c_array(19, 19, sizeof(string), _MOV((string[19]){
				_SLIT("memdup_noscan"), _SLIT("__new_array_noscan"), _SLIT("__new_array_with_default_noscan"), _SLIT("__new_array_with_array_default_noscan"), _SLIT("new_array_from_c_array_noscan"), _SLIT("22.clone_static_to_depth_noscan"), _SLIT("22.clone_to_depth_noscan"), _SLIT("22.reverse_noscan"), _SLIT("22.repeat_to_depth_noscan"),
				_SLIT("65558.pop_noscan"), _SLIT("65558.push_noscan"), _SLIT("65558.push_many_noscan"), _SLIT("65558.insert_noscan"), _SLIT("65558.insert_many_noscan"), _SLIT("65558.prepend_noscan"), _SLIT("65558.prepend_many_noscan"), _SLIT("65558.reverse_noscan"),
				_SLIT("65558.grow_cap_noscan"), _SLIT("65558.grow_len_noscan")}))), _t2, Array_string);
	}
	int _t4 = all_fns.key_values.len;
	for (int _t3 = 0; _t3 < _t4; ++_t3 ) {
		int _t5 = all_fns.key_values.len - _t4;
		_t4 = all_fns.key_values.len;
		if (_t5 < 0) {
			_t3 = -1;
			continue;
		}
		if (!DenseArray_has_index(&all_fns.key_values, _t3)) {continue;}
		string k = /*key*/ *(string*)DenseArray_key(&all_fns.key_values, _t3);
		k = string_clone(k);
		v__ast__FnDecl* mfn = &(*(v__ast__FnDecl*)DenseArray_value(&all_fns.key_values, _t3));
		string method_receiver_typename = _SLIT("");
		if (mfn->is_method) {
			method_receiver_typename = v__ast__Table_type_to_str(table, mfn->receiver.typ);
		}
		if (string__eq(method_receiver_typename, _SLIT("&wyrand.WyRandRNG"))) {
			array_push((array*)&all_fn_root_names, _MOV((string[]){ string_clone(k) }));
			continue;
		}
		if (string__eq(method_receiver_typename, _SLIT("&strings.Builder"))) {
			array_push((array*)&all_fn_root_names, _MOV((string[]){ string_clone(k) }));
			continue;
		}
		if (string_ends_with(k, _SLIT(".str")) || string_ends_with(k, _SLIT(".auto_str"))) {
			array_push((array*)&all_fn_root_names, _MOV((string[]){ string_clone(k) }));
			continue;
		}
		if (string_ends_with(k, _SLIT(".init"))) {
			array_push((array*)&all_fn_root_names, _MOV((string[]){ string_clone(k) }));
			continue;
		}
		if (string_ends_with(k, _SLIT(".free"))) {
			array_push((array*)&all_fn_root_names, _MOV((string[]){ string_clone(k) }));
			continue;
		}
		if (string__eq(k, _SLIT("sync.new_channel_st"))) {
			array_push((array*)&all_fn_root_names, _MOV((string[]){ string_clone(k) }));
			continue;
		}
		if (string__eq(k, _SLIT("sync.channel_select"))) {
			array_push((array*)&all_fn_root_names, _MOV((string[]){ string_clone(k) }));
			continue;
		}
		if (string__eq(method_receiver_typename, _SLIT("&sync.Channel"))) {
			array_push((array*)&all_fn_root_names, _MOV((string[]){ string_clone(k) }));
			continue;
		}
		if (string_ends_with(k, _SLIT(".lock")) || string_ends_with(k, _SLIT(".unlock")) || string_ends_with(k, _SLIT(".rlock")) || string_ends_with(k, _SLIT(".runlock"))) {
			array_push((array*)&all_fn_root_names, _MOV((string[]){ string_clone(k) }));
			continue;
		}
		if (!v__ast__Type_alias_eq(mfn->receiver.typ, _const_v__ast__void_type) && v__ast__Type_has_flag(mfn->receiver.typ, v__ast__TypeFlag__generic)) {
			array_push((array*)&all_fn_root_names, _MOV((string[]){ string_clone(k) }));
			continue;
		}
		if (pref->is_test) {
			if (string_starts_with(k, _SLIT("test_")) || string_contains(k, _SLIT(".test_"))) {
				array_push((array*)&all_fn_root_names, _MOV((string[]){ string_clone(k) }));
				continue;
			}
			if (string_starts_with(k, _SLIT("testsuite_")) || string_contains(k, _SLIT(".testsuite_"))) {
				array_push((array*)&all_fn_root_names, _MOV((string[]){ string_clone(k) }));
				continue;
			}
		}
		if (mfn->is_pub && pref->is_shared) {
			array_push((array*)&all_fn_root_names, _MOV((string[]){ string_clone(k) }));
			continue;
		}
		if (string__eq(mfn->name, _SLIT("+")) || string__eq(mfn->name, _SLIT("-")) || string__eq(mfn->name, _SLIT("*")) || string__eq(mfn->name, _SLIT("%")) || string__eq(mfn->name, _SLIT("/")) || string__eq(mfn->name, _SLIT("<")) || string__eq(mfn->name, _SLIT("=="))) {
			array_push((array*)&all_fn_root_names, _MOV((string[]){ string_clone(k) }));
			continue;
		}
		if (pref->prealloc && string_starts_with(k, _SLIT("prealloc_"))) {
			array_push((array*)&all_fn_root_names, _MOV((string[]){ string_clone(k) }));
			continue;
		}
	}
	if (pref->is_debug) {
		array_push((array*)&all_fn_root_names, _MOV((string[]){ string_clone(_SLIT("panic_debug")) }));
	}
	array_push((array*)&all_fn_root_names, _MOV((string[]){ string_clone(_SLIT("panic_optional_not_set")) }));
	if (pref->is_test) {
		array_push((array*)&all_fn_root_names, _MOV((string[]){ string_clone(_SLIT("main.cb_assertion_ok")) }));
		array_push((array*)&all_fn_root_names, _MOV((string[]){ string_clone(_SLIT("main.cb_assertion_failed")) }));
		Option_v__ast__TypeSymbol_ptr _t25;
		if (_t25 = v__ast__Table_find_sym(table, _SLIT("main.BenchedTests")), _t25.state == 0) {
			v__ast__TypeSymbol* benched_tests_sym = *(v__ast__TypeSymbol**)_t25.data;
			v__ast__Type bts_type = (*(v__ast__Param*)/*ee elem_typ */array_get((*(v__ast__Fn*)/*ee elem_typ */array_get(benched_tests_sym->methods, 0)).params, 0)).typ;
			array_push((array*)&all_fn_root_names, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = bts_type}}, {_SLIT(".testing_step_start"), 0, { .d_c = 0 }}}))) }));
			array_push((array*)&all_fn_root_names, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = bts_type}}, {_SLIT(".testing_step_end"), 0, { .d_c = 0 }}}))) }));
			array_push((array*)&all_fn_root_names, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = bts_type}}, {_SLIT(".end_testing"), 0, { .d_c = 0 }}}))) }));
			array_push((array*)&all_fn_root_names, _MOV((string[]){ string_clone(_SLIT("main.start_testing")) }));
		}
	}
	for (int _t30 = 0; _t30 < table->type_symbols.len; ++_t30) {
		v__ast__TypeSymbol* isym = ((v__ast__TypeSymbol**)table->type_symbols.data)[_t30];
		if (isym->kind != v__ast__Kind__interface_) {
			continue;
		}
		if ((isym->info)._typ != 463 /* v.ast.Interface */) {
			continue;
		}
		v__ast__Interface interface_info = /* as */ *(v__ast__Interface*)__as_cast((isym->info)._v__ast__Interface,(isym->info)._typ, 463) /*expected idx: 463, name: v.ast.Interface */ ;
		if (interface_info.methods.len == 0) {
			continue;
		}
		for (int _t31 = 0; _t31 < interface_info.types.len; ++_t31) {
			v__ast__Type itype = ((v__ast__Type*)interface_info.types.data)[_t31];
			v__ast__Type ptype = v__ast__Type_set_nr_muls(itype, 1);
			v__ast__Type ntype = v__ast__Type_set_nr_muls(itype, 0);
			Array_v__ast__Type interface_types = new_array_from_c_array(2, 2, sizeof(v__ast__Type), _MOV((v__ast__Type[2]){ptype, ntype}));
			for (int _t32 = 0; _t32 < interface_info.methods.len; ++_t32) {
				v__ast__Fn method = ((v__ast__Fn*)interface_info.methods.data)[_t32];
				for (int _t33 = 0; _t33 < interface_types.len; ++_t33) {
					v__ast__Type typ = ((v__ast__Type*)interface_types.data)[_t33];
					string interface_implementation_method_name =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = ((int)(typ))}}, {_SLIT("."), 0xfe10, {.d_s = method.name}}, {_SLIT0, 0, { .d_c = 0 }}}));
					array_push((array*)&all_fn_root_names, _MOV((string[]){ string_clone(interface_implementation_method_name) }));
				}
			}
		}
	}
	int typ_vweb_result = v__ast__Table_find_type_idx(table, _SLIT("vweb.Result"));
	if (typ_vweb_result != 0) {
		array_push((array*)&all_fn_root_names, _MOV((string[]){ string_clone(_SLIT("vweb.filter")) }));
		v__ast__Type typ_vweb_context = v__ast__Type_set_nr_muls(((v__ast__Table_find_type_idx(table, _SLIT("vweb.Context")))), 1);
		array_push((array*)&all_fn_root_names, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = ((int)(typ_vweb_context))}}, {_SLIT(".html"), 0, { .d_c = 0 }}}))) }));
		for (int _t37 = 0; _t37 < table->used_vweb_types.len; ++_t37) {
			v__ast__Type vgt = ((v__ast__Type*)table->used_vweb_types.data)[_t37];
			v__ast__TypeSymbol* sym_app = v__ast__Table_sym(table, vgt);
			for (int _t38 = 0; _t38 < sym_app->methods.len; ++_t38) {
				v__ast__Fn m = ((v__ast__Fn*)sym_app->methods.data)[_t38];
				if (m.return_type == typ_vweb_result) {
					v__ast__Type pvgt = v__ast__Type_set_nr_muls(vgt, 1);
					array_push((array*)&all_fn_root_names, _MOV((string[]){ string_clone( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = ((int)(pvgt))}}, {_SLIT("."), 0xfe10, {.d_s = m.name}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
				}
			}
		}
	}
	Array_v__ast__Type* _t41 = (Array_v__ast__Type*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, table->iface_types), &(string[]){_SLIT("orm.Connection")}));
	Option_Array_v__ast__Type _t40 = {0};
	if (_t41) {
		*((Array_v__ast__Type*)&_t40.data) = *((Array_v__ast__Type*)_t41);
	} else {
		_t40.state = 2; _t40.err = _v_error(_SLIT("array index out of range"));
	}
	;
	if (_t40.state != 0) { /*or block*/ 
		IError err = _t40.err;
		*(Array_v__ast__Type*) _t40.data = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
	}
	
	Array_v__ast__Type orm_connection_implementations = *(Array_v__ast__Type*)_t40.data;
	if (orm_connection_implementations.len > 0) {
		int _t43 = all_fns.key_values.len;
		for (int _t42 = 0; _t42 < _t43; ++_t42 ) {
			int _t44 = all_fns.key_values.len - _t43;
			_t43 = all_fns.key_values.len;
			if (_t44 < 0) {
				_t42 = -1;
				continue;
			}
			if (!DenseArray_has_index(&all_fns.key_values, _t42)) {continue;}
			string k = /*key*/ *(string*)DenseArray_key(&all_fns.key_values, _t42);
			k = string_clone(k);
			if (string_starts_with(k, _SLIT("orm."))) {
				array_push((array*)&all_fn_root_names, _MOV((string[]){ string_clone(k) }));
			}
		}
		for (int _t46 = 0; _t46 < orm_connection_implementations.len; ++_t46) {
			v__ast__Type orm_type = ((v__ast__Type*)orm_connection_implementations.data)[_t46];
			array_push((array*)&all_fn_root_names, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = ((int)(orm_type))}}, {_SLIT(".select"), 0, { .d_c = 0 }}}))) }));
			array_push((array*)&all_fn_root_names, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = ((int)(orm_type))}}, {_SLIT(".insert"), 0, { .d_c = 0 }}}))) }));
			array_push((array*)&all_fn_root_names, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = ((int)(orm_type))}}, {_SLIT(".update"), 0, { .d_c = 0 }}}))) }));
			array_push((array*)&all_fn_root_names, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = ((int)(orm_type))}}, {_SLIT(".delete"), 0, { .d_c = 0 }}}))) }));
			array_push((array*)&all_fn_root_names, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = ((int)(orm_type))}}, {_SLIT(".create"), 0, { .d_c = 0 }}}))) }));
			array_push((array*)&all_fn_root_names, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = ((int)(orm_type))}}, {_SLIT(".drop"), 0, { .d_c = 0 }}}))) }));
			array_push((array*)&all_fn_root_names, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = ((int)(orm_type))}}, {_SLIT(".last_id"), 0, { .d_c = 0 }}}))) }));
		}
	}
	if (pref->is_livemain) {
		array_push((array*)&all_fn_root_names, _MOV((string[]){ string_clone(_SLIT("v.live.executable.start_reloader")) }));
		array_push((array*)&all_fn_root_names, _MOV((string[]){ string_clone(_SLIT("v.live.executable.new_live_reload_info")) }));
	}
	v__markused__Walker walker = (v__markused__Walker){
		.table = table,
		.used_fns = new_map(sizeof(string), sizeof(bool), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.used_consts = new_map(sizeof(string), sizeof(bool), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.used_globals = new_map(sizeof(string), sizeof(bool), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.n_asserts = 0,
		.pref = pref,
		.files = ast_files,
		.all_fns = all_fns,
		.all_consts = all_consts,
		.all_globals = all_globals,
	};
	v__markused__Walker_mark_markused_fns(&walker);
	v__markused__Walker_mark_markused_consts(&walker);
	v__markused__Walker_mark_markused_globals(&walker);
	v__markused__Walker_mark_exported_fns(&walker);
	v__markused__Walker_mark_root_fns(&walker, all_fn_root_names);
	if (walker.n_asserts > 0) {
		v__markused__Walker_fn_decl(&walker, (voidptr)&/*qq*/(*(v__ast__FnDecl*)map_get(ADDR(map, all_fns), &(string[]){_SLIT("__print_assert_failure")}, &(v__ast__FnDecl[]){ (v__ast__FnDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.is_deprecated = 0,.is_pub = 0,.is_variadic = 0,.is_anon = 0,.is_noreturn = 0,.is_manualfree = 0,.is_main = 0,.is_test = 0,.is_conditional = 0,.is_exported = 0,.is_keep_alive = 0,.is_unsafe = 0,.is_markused = 0,.receiver = (v__ast__StructField){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.has_default_expr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_pub = 0,.default_val = (string){.str=(byteptr)"", .is_lit=1},.is_mut = 0,.is_global = 0,.is_volatile = 0,.default_expr_typ = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,},.receiver_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.is_method = 0,.method_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.method_idx = 0,.rec_mut = 0,.no_body = 0,.is_builtin = 0,.body_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.file = (string){.str=(byteptr)"", .is_lit=1},.generic_names = __new_array(0, 0, sizeof(string)),.is_direct_arr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.ctdefine_idx = -1,.params = __new_array(0, 0, sizeof(v__ast__Param)),.stmts = __new_array(0, 0, sizeof(v__ast__Stmt)),.defer_stmts = __new_array(0, 0, sizeof(v__ast__DeferStmt)),.return_type = 0,.return_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.has_return = 0,.should_be_skipped = 0,.ninstances = 0,.has_await = 0,.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.next_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.source_file = 0,.scope = 0,.label_names = __new_array(0, 0, sizeof(string)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},} })));
	}
	if (table->used_maps > 0) {
		int _t57 = all_fns.key_values.len;
		for (int _t56 = 0; _t56 < _t57; ++_t56 ) {
			int _t58 = all_fns.key_values.len - _t57;
			_t57 = all_fns.key_values.len;
			if (_t58 < 0) {
				_t56 = -1;
				continue;
			}
			if (!DenseArray_has_index(&all_fns.key_values, _t56)) {continue;}
			string k = /*key*/ *(string*)DenseArray_key(&all_fns.key_values, _t56);
			k = string_clone(k);
			v__ast__FnDecl* mfn = &(*(v__ast__FnDecl*)DenseArray_value(&all_fns.key_values, _t56));
			string method_receiver_typename = _SLIT("");
			if (mfn->is_method) {
				method_receiver_typename = v__ast__Table_type_to_str(table, mfn->receiver.typ);
			}
			if ((string__eq(k, _SLIT("new_map")) || string__eq(k, _SLIT("new_map_init")) || string__eq(k, _SLIT("map_hash_string"))) || string__eq(method_receiver_typename, _SLIT("&map")) || string__eq(method_receiver_typename, _SLIT("&DenseArray")) || string_starts_with(k, _SLIT("map_"))) {
				v__markused__Walker_fn_decl(&walker, mfn);
			}
			if (pref->gc_mode == v__pref__GarbageCollectionMode__boehm_full_opt || pref->gc_mode == v__pref__GarbageCollectionMode__boehm_incr_opt) {
				if (string__eq(k, _SLIT("new_map_noscan_key")) || string__eq(k, _SLIT("new_map_noscan_value")) || string__eq(k, _SLIT("new_map_noscan_key_value")) || string__eq(k, _SLIT("new_map_init_noscan_key")) || string__eq(k, _SLIT("new_map_init_noscan_value")) || string__eq(k, _SLIT("new_map_init_noscan_key_value"))) {
					v__markused__Walker_fn_decl(&walker, mfn);
				}
			}
		}
	} else {
		Array_string _t59 = new_array_from_c_array(4, 4, sizeof(string), _MOV((string[4]){_SLIT("new_map"), _SLIT("new_map_init"), _SLIT("map_hash_string"), _SLIT("new_dense_array")}));
		for (int _t60 = 0; _t60 < _t59.len; ++_t60) {
			string map_fn_name = ((string*)_t59.data)[_t60];
			map_delete(&walker.used_fns, &(string[]){map_fn_name});
		}
		int _t62 = all_fns.key_values.len;
		for (int _t61 = 0; _t61 < _t62; ++_t61 ) {
			int _t63 = all_fns.key_values.len - _t62;
			_t62 = all_fns.key_values.len;
			if (_t63 < 0) {
				_t61 = -1;
				continue;
			}
			if (!DenseArray_has_index(&all_fns.key_values, _t61)) {continue;}
			string k = /*key*/ *(string*)DenseArray_key(&all_fns.key_values, _t61);
			k = string_clone(k);
			v__ast__FnDecl* mfn = &(*(v__ast__FnDecl*)DenseArray_value(&all_fns.key_values, _t61));
			if (!mfn->is_method) {
				continue;
			}
			string method_receiver_typename = v__ast__Table_type_to_str(table, mfn->receiver.typ);
			if (string__eq(method_receiver_typename, _SLIT("&map")) || string__eq(method_receiver_typename, _SLIT("&mapnode")) || string__eq(method_receiver_typename, _SLIT("&SortedMap")) || string__eq(method_receiver_typename, _SLIT("&DenseArray"))) {
				map_delete(&walker.used_fns, &(string[]){k});
			}
		}
	}
	int _t65 = all_consts.key_values.len;
	for (int _t64 = 0; _t64 < _t65; ++_t64 ) {
		int _t66 = all_consts.key_values.len - _t65;
		_t65 = all_consts.key_values.len;
		if (_t66 < 0) {
			_t64 = -1;
			continue;
		}
		if (!DenseArray_has_index(&all_consts.key_values, _t64)) {continue;}
		string kcon = /*key*/ *(string*)DenseArray_key(&all_consts.key_values, _t64);
		kcon = string_clone(kcon);
		v__ast__ConstField con = (*(v__ast__ConstField*)DenseArray_value(&all_consts.key_values, _t64));
		if (pref->is_shared && con.is_pub) {
			v__markused__Walker_mark_const_as_used(&walker, kcon);
		}
		if (!pref->is_shared && con.is_pub && string_starts_with(con.name, _SLIT("main."))) {
			v__markused__Walker_mark_const_as_used(&walker, kcon);
		}
	}
	table->used_fns = map_move(&walker.used_fns);
	table->used_consts = map_move(&walker.used_consts);
	table->used_globals = map_move(&walker.used_globals);
// Defer begin
if (v__markused__mark_used_defer_0) {
	v__util__timing_measure(_SLIT("mark_used"));
}
// Defer end
}

VV_LOCAL_SYMBOL multi_return_Map_string_v__ast__FnDecl_Map_string_v__ast__ConstField_Map_string_v__ast__GlobalField v__markused__all_fn_const_and_global(Array_v__ast__File_ptr ast_files) {
bool v__markused__all_fn_const_and_global_defer_0 = false;
	v__util__timing_start(_SLIT("all_fn_const_and_global"));
	v__markused__all_fn_const_and_global_defer_0 = true;
	Map_string_v__ast__FnDecl all_fns = new_map(sizeof(string), sizeof(v__ast__FnDecl), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
	Map_string_v__ast__ConstField all_consts = new_map(sizeof(string), sizeof(v__ast__ConstField), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
	Map_string_v__ast__GlobalField all_globals = new_map(sizeof(string), sizeof(v__ast__GlobalField), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
	for (int i = 0; i < ast_files.len; ++i) {
		v__ast__File* file = (*(v__ast__File**)/*ee elem_typ */array_get(ast_files, i));
		for (int _t1 = 0; _t1 < file->stmts.len; ++_t1) {
			v__ast__Stmt node = ((v__ast__Stmt*)file->stmts.data)[_t1];
			if (node._typ == 216 /* v.ast.FnDecl */) {
				string fkey = v__ast__FnDecl_fkey(&(*node._v__ast__FnDecl));
(*(v__ast__FnDecl*)map_get_and_set((map*)&all_fns, &(string[]){fkey}, &(v__ast__FnDecl[]){ (v__ast__FnDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.is_deprecated = 0,.is_pub = 0,.is_variadic = 0,.is_anon = 0,.is_noreturn = 0,.is_manualfree = 0,.is_main = 0,.is_test = 0,.is_conditional = 0,.is_exported = 0,.is_keep_alive = 0,.is_unsafe = 0,.is_markused = 0,.receiver = (v__ast__StructField){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.has_default_expr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_pub = 0,.default_val = (string){.str=(byteptr)"", .is_lit=1},.is_mut = 0,.is_global = 0,.is_volatile = 0,.default_expr_typ = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,},.receiver_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.is_method = 0,.method_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.method_idx = 0,.rec_mut = 0,.no_body = 0,.is_builtin = 0,.body_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.file = (string){.str=(byteptr)"", .is_lit=1},.generic_names = __new_array(0, 0, sizeof(string)),.is_direct_arr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.ctdefine_idx = -1,.params = __new_array(0, 0, sizeof(v__ast__Param)),.stmts = __new_array(0, 0, sizeof(v__ast__Stmt)),.defer_stmts = __new_array(0, 0, sizeof(v__ast__DeferStmt)),.return_type = 0,.return_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.has_return = 0,.should_be_skipped = 0,.ninstances = 0,.has_await = 0,.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.next_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.source_file = 0,.scope = 0,.label_names = __new_array(0, 0, sizeof(string)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},} })) = (*node._v__ast__FnDecl);
			}
			else if (node._typ == 335 /* v.ast.ConstDecl */) {
				for (int _t2 = 0; _t2 < (*node._v__ast__ConstDecl).fields.len; ++_t2) {
					v__ast__ConstField cfield = ((v__ast__ConstField*)(*node._v__ast__ConstDecl).fields.data)[_t2];
					string ckey = cfield.name;
(*(v__ast__ConstField*)map_get_and_set((map*)&all_consts, &(string[]){ckey}, &(v__ast__ConstField[]){ (v__ast__ConstField){.mod = (string){.str=(byteptr)"", .is_lit=1},.name = (string){.str=(byteptr)"", .is_lit=1},.is_pub = 0,.is_markused = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.typ = 0,.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.comptime_expr_value = v__ast__empty_comptime_const_expr(),} })) = cfield;
				}
			}
			else if (node._typ == 343 /* v.ast.GlobalDecl */) {
				for (int _t3 = 0; _t3 < (*node._v__ast__GlobalDecl).fields.len; ++_t3) {
					v__ast__GlobalField gfield = ((v__ast__GlobalField*)(*node._v__ast__GlobalDecl).fields.data)[_t3];
					string gkey = gfield.name;
					(*(v__ast__GlobalField*)map_get_and_set((map*)&all_globals, &(string[]){gkey}, &(v__ast__GlobalField[]){ (v__ast__GlobalField){.name = (string){.str=(byteptr)"", .is_lit=1},.has_expr = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.typ_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.is_markused = 0,.typ = 0,.comments = __new_array(0, 0, sizeof(v__ast__Comment)),} })) = gfield;
				}
			}
			
			else {
			}
			;
		}
	}
	multi_return_Map_string_v__ast__FnDecl_Map_string_v__ast__ConstField_Map_string_v__ast__GlobalField _t4 = (multi_return_Map_string_v__ast__FnDecl_Map_string_v__ast__ConstField_Map_string_v__ast__GlobalField){.arg0=all_fns, .arg1=all_consts, .arg2=all_globals};
	// Defer begin
	if (v__markused__all_fn_const_and_global_defer_0) {
		v__util__timing_measure(_SLIT("all_fn_const_and_global"));
	}
	// Defer end
	return _t4;
}

void v__markused__Walker_mark_fn_as_used(v__markused__Walker* w, string fkey) {
	map_set(&w->used_fns, &(string[]){fkey}, &(bool[]) { true });
}

void v__markused__Walker_mark_const_as_used(v__markused__Walker* w, string ckey) {
	if ((*(bool*)map_get(ADDR(map, w->used_consts), &(string[]){ckey}, &(bool[]){ 0 }))) {
		return;
	}
	map_set(&w->used_consts, &(string[]){ckey}, &(bool[]) { true });
	v__ast__ConstField* _t2 = (v__ast__ConstField*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, w->all_consts), &(string[]){ckey}));
	Option_v__ast__ConstField _t1 = {0};
	if (_t2) {
		*((v__ast__ConstField*)&_t1.data) = *((v__ast__ConstField*)_t2);
	} else {
		_t1.state = 2; _t1.err = _v_error(_SLIT("array index out of range"));
	}
	;
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		return;
	}
	
	v__ast__ConstField cfield = *(v__ast__ConstField*)_t1.data;
	v__markused__Walker_expr(w, cfield.expr);
}

void v__markused__Walker_mark_global_as_used(v__markused__Walker* w, string ckey) {
	if ((*(bool*)map_get(ADDR(map, w->used_globals), &(string[]){ckey}, &(bool[]){ 0 }))) {
		return;
	}
	map_set(&w->used_globals, &(string[]){ckey}, &(bool[]) { true });
	v__ast__GlobalField* _t2 = (v__ast__GlobalField*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, w->all_globals), &(string[]){ckey}));
	Option_v__ast__GlobalField _t1 = {0};
	if (_t2) {
		*((v__ast__GlobalField*)&_t1.data) = *((v__ast__GlobalField*)_t2);
	} else {
		_t1.state = 2; _t1.err = _v_error(_SLIT("array index out of range"));
	}
	;
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		return;
	}
	
	v__ast__GlobalField gfield = *(v__ast__GlobalField*)_t1.data;
	v__markused__Walker_expr(w, gfield.expr);
}

void v__markused__Walker_mark_root_fns(v__markused__Walker* w, Array_string all_fn_root_names) {
	for (int _t1 = 0; _t1 < all_fn_root_names.len; ++_t1) {
		string fn_name = ((string*)all_fn_root_names.data)[_t1];
		if (!_IN_MAP(ADDR(string, fn_name), ADDR(map, w->used_fns))) {
			v__markused__Walker_fn_decl(w, (voidptr)&/*qq*/(*(v__ast__FnDecl*)map_get(ADDR(map, w->all_fns), &(string[]){fn_name}, &(v__ast__FnDecl[]){ (v__ast__FnDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.is_deprecated = 0,.is_pub = 0,.is_variadic = 0,.is_anon = 0,.is_noreturn = 0,.is_manualfree = 0,.is_main = 0,.is_test = 0,.is_conditional = 0,.is_exported = 0,.is_keep_alive = 0,.is_unsafe = 0,.is_markused = 0,.receiver = (v__ast__StructField){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.has_default_expr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_pub = 0,.default_val = (string){.str=(byteptr)"", .is_lit=1},.is_mut = 0,.is_global = 0,.is_volatile = 0,.default_expr_typ = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,},.receiver_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.is_method = 0,.method_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.method_idx = 0,.rec_mut = 0,.no_body = 0,.is_builtin = 0,.body_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.file = (string){.str=(byteptr)"", .is_lit=1},.generic_names = __new_array(0, 0, sizeof(string)),.is_direct_arr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.ctdefine_idx = -1,.params = __new_array(0, 0, sizeof(v__ast__Param)),.stmts = __new_array(0, 0, sizeof(v__ast__Stmt)),.defer_stmts = __new_array(0, 0, sizeof(v__ast__DeferStmt)),.return_type = 0,.return_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.has_return = 0,.should_be_skipped = 0,.ninstances = 0,.has_await = 0,.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.next_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.source_file = 0,.scope = 0,.label_names = __new_array(0, 0, sizeof(string)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},} })));
		}
	}
}

void v__markused__Walker_mark_exported_fns(v__markused__Walker* w) {
	Map_string_v__ast__FnDecl _t1 = w->all_fns;
	int _t3 = _t1.key_values.len;
	for (int _t2 = 0; _t2 < _t3; ++_t2 ) {
		int _t4 = _t1.key_values.len - _t3;
		_t3 = _t1.key_values.len;
		if (_t4 < 0) {
			_t2 = -1;
			continue;
		}
		if (!DenseArray_has_index(&_t1.key_values, _t2)) {continue;}
		v__ast__FnDecl* func = &(*(v__ast__FnDecl*)DenseArray_value(&_t1.key_values, _t2));
		if (func->is_exported) {
			v__markused__Walker_fn_decl(w, func);
		}
	}
}

void v__markused__Walker_mark_markused_fns(v__markused__Walker* w) {
	Map_string_v__ast__FnDecl _t1 = w->all_fns;
	int _t3 = _t1.key_values.len;
	for (int _t2 = 0; _t2 < _t3; ++_t2 ) {
		int _t4 = _t1.key_values.len - _t3;
		_t3 = _t1.key_values.len;
		if (_t4 < 0) {
			_t2 = -1;
			continue;
		}
		if (!DenseArray_has_index(&_t1.key_values, _t2)) {continue;}
		v__ast__FnDecl* func = &(*(v__ast__FnDecl*)DenseArray_value(&_t1.key_values, _t2));
		if (func->is_markused) {
			v__markused__Walker_fn_decl(w, func);
		}
	}
}

void v__markused__Walker_mark_markused_consts(v__markused__Walker* w) {
	Map_string_v__ast__ConstField _t1 = w->all_consts;
	int _t3 = _t1.key_values.len;
	for (int _t2 = 0; _t2 < _t3; ++_t2 ) {
		int _t4 = _t1.key_values.len - _t3;
		_t3 = _t1.key_values.len;
		if (_t4 < 0) {
			_t2 = -1;
			continue;
		}
		if (!DenseArray_has_index(&_t1.key_values, _t2)) {continue;}
		string ckey = /*key*/ *(string*)DenseArray_key(&_t1.key_values, _t2);
		ckey = string_clone(ckey);
		v__ast__ConstField* constfield = &(*(v__ast__ConstField*)DenseArray_value(&_t1.key_values, _t2));
		if (constfield->is_markused) {
			v__markused__Walker_mark_const_as_used(w, ckey);
		}
	}
}

void v__markused__Walker_mark_markused_globals(v__markused__Walker* w) {
	Map_string_v__ast__GlobalField _t1 = w->all_globals;
	int _t3 = _t1.key_values.len;
	for (int _t2 = 0; _t2 < _t3; ++_t2 ) {
		int _t4 = _t1.key_values.len - _t3;
		_t3 = _t1.key_values.len;
		if (_t4 < 0) {
			_t2 = -1;
			continue;
		}
		if (!DenseArray_has_index(&_t1.key_values, _t2)) {continue;}
		string gkey = /*key*/ *(string*)DenseArray_key(&_t1.key_values, _t2);
		gkey = string_clone(gkey);
		v__ast__GlobalField* globalfield = &(*(v__ast__GlobalField*)DenseArray_value(&_t1.key_values, _t2));
		if (globalfield->is_markused) {
			v__markused__Walker_mark_global_as_used(w, gkey);
		}
	}
}

void v__markused__Walker_stmt(v__markused__Walker* w, v__ast__Stmt node) {
	if (node._typ == 337 /* v.ast.EmptyStmt */) {
	}
	else if (node._typ == 329 /* v.ast.AsmStmt */) {
		v__markused__Walker_asm_io(w, (*node._v__ast__AsmStmt).output);
		v__markused__Walker_asm_io(w, (*node._v__ast__AsmStmt).input);
	}
	else if (node._typ == 330 /* v.ast.AssertStmt */) {
		if ((*node._v__ast__AssertStmt).is_used) {
			v__markused__Walker_expr(w, (*node._v__ast__AssertStmt).expr);
			w->n_asserts++;
		}
	}
	else if (node._typ == 331 /* v.ast.AssignStmt */) {
		v__markused__Walker_exprs(w, (*node._v__ast__AssignStmt).left);
		v__markused__Walker_exprs(w, (*node._v__ast__AssignStmt).right);
	}
	else if (node._typ == 332 /* v.ast.Block */) {
		v__markused__Walker_stmts(w, (*node._v__ast__Block).stmts);
	}
	else if (node._typ == 334 /* v.ast.ComptimeFor */) {
		v__markused__Walker_stmts(w, (*node._v__ast__ComptimeFor).stmts);
	}
	else if (node._typ == 335 /* v.ast.ConstDecl */) {
		v__markused__Walker_const_fields(w, (*node._v__ast__ConstDecl).fields);
	}
	else if (node._typ == 339 /* v.ast.ExprStmt */) {
		v__markused__Walker_expr(w, (*node._v__ast__ExprStmt).expr);
	}
	else if (node._typ == 216 /* v.ast.FnDecl */) {
		v__markused__Walker_fn_decl(w, (voidptr)&/*qq*/(*node._v__ast__FnDecl));
	}
	else if (node._typ == 340 /* v.ast.ForCStmt */) {
		v__markused__Walker_expr(w, (*node._v__ast__ForCStmt).cond);
		v__markused__Walker_stmt(w, (*node._v__ast__ForCStmt).inc);
		v__markused__Walker_stmts(w, (*node._v__ast__ForCStmt).stmts);
	}
	else if (node._typ == 341 /* v.ast.ForInStmt */) {
		v__markused__Walker_expr(w, (*node._v__ast__ForInStmt).cond);
		v__markused__Walker_expr(w, (*node._v__ast__ForInStmt).high);
		v__markused__Walker_stmts(w, (*node._v__ast__ForInStmt).stmts);
		if ((*node._v__ast__ForInStmt).kind == v__ast__Kind__map) {
			w->table->used_maps++;
		}
		if ((*node._v__ast__ForInStmt).kind == v__ast__Kind__struct_) {
			if ((*node._v__ast__ForInStmt).cond_type == 0) {
				return;
			}
			v__ast__TypeSymbol* cond_type_sym = v__ast__Table_sym(w->table, (*node._v__ast__ForInStmt).cond_type);
			Option_v__ast__Fn _t1;
			if (_t1 = v__ast__TypeSymbol_find_method(cond_type_sym, _SLIT("next")), _t1.state == 0) {
				v__ast__Fn next_fn = *(v__ast__Fn*)_t1.data;
				v__markused__Walker_fn_decl(w, ((v__ast__FnDecl*)(next_fn.source_fn)));
			}
		}
	}
	else if (node._typ == 342 /* v.ast.ForStmt */) {
		v__markused__Walker_expr(w, (*node._v__ast__ForStmt).cond);
		v__markused__Walker_stmts(w, (*node._v__ast__ForStmt).stmts);
	}
	else if (node._typ == 350 /* v.ast.Return */) {
		v__markused__Walker_exprs(w, (*node._v__ast__Return).exprs);
	}
	else if (node._typ == 351 /* v.ast.SqlStmt */) {
		v__markused__Walker_expr(w, (*node._v__ast__SqlStmt).db_expr);
		for (int _t2 = 0; _t2 < (*node._v__ast__SqlStmt).lines.len; ++_t2) {
			v__ast__SqlStmtLine line = ((v__ast__SqlStmtLine*)(*node._v__ast__SqlStmt).lines.data)[_t2];
			v__markused__Walker_expr(w, line.where_expr);
			v__markused__Walker_exprs(w, line.update_exprs);
		}
	}
	else if (node._typ == 352 /* v.ast.StructDecl */) {
		v__markused__Walker_struct_fields(w, (*node._v__ast__StructDecl).fields);
	}
	else if (node._typ == 336 /* v.ast.DeferStmt */) {
		v__markused__Walker_stmts(w, (*node._v__ast__DeferStmt).stmts);
	}
	else if (node._typ == 343 /* v.ast.GlobalDecl */) {
		for (int _t3 = 0; _t3 < (*node._v__ast__GlobalDecl).fields.len; ++_t3) {
			v__ast__GlobalField gf = ((v__ast__GlobalField*)(*node._v__ast__GlobalDecl).fields.data)[_t3];
			if (gf.has_expr) {
				v__markused__Walker_expr(w, gf.expr);
			}
		}
	}
	else if (node._typ == 333 /* v.ast.BranchStmt */) {
	}
	else if (node._typ == 338 /* v.ast.EnumDecl */) {
	}
	else if (node._typ == 344 /* v.ast.GotoLabel */) {
	}
	else if (node._typ == 345 /* v.ast.GotoStmt */) {
	}
	else if (node._typ == 346 /* v.ast.HashStmt */) {
	}
	else if (node._typ == 347 /* v.ast.Import */) {
	}
	else if (node._typ == 348 /* v.ast.InterfaceDecl */) {
	}
	else if (node._typ == 349 /* v.ast.Module */) {
	}
	else if (node._typ == 277 /* v.ast.TypeDecl */) {
	}
	else if (node._typ == 310 /* v.ast.NodeError */) {
	}
	;
}

VV_LOCAL_SYMBOL void v__markused__Walker_asm_io(v__markused__Walker* w, Array_v__ast__AsmIO ios) {
	for (int _t1 = 0; _t1 < ios.len; ++_t1) {
		v__ast__AsmIO io = ((v__ast__AsmIO*)ios.data)[_t1];
		v__markused__Walker_expr(w, io.expr);
	}
}

VV_LOCAL_SYMBOL void v__markused__Walker_defer_stmts(v__markused__Walker* w, Array_v__ast__DeferStmt stmts) {
	for (int _t1 = 0; _t1 < stmts.len; ++_t1) {
		v__ast__DeferStmt stmt = ((v__ast__DeferStmt*)stmts.data)[_t1];
		v__markused__Walker_stmts(w, stmt.stmts);
	}
}

VV_LOCAL_SYMBOL void v__markused__Walker_stmts(v__markused__Walker* w, Array_v__ast__Stmt stmts) {
	for (int _t1 = 0; _t1 < stmts.len; ++_t1) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)stmts.data)[_t1];
		v__markused__Walker_stmt(w, stmt);
	}
}

VV_LOCAL_SYMBOL void v__markused__Walker_exprs(v__markused__Walker* w, Array_v__ast__Expr exprs) {
	for (int _t1 = 0; _t1 < exprs.len; ++_t1) {
		v__ast__Expr expr = ((v__ast__Expr*)exprs.data)[_t1];
		v__markused__Walker_expr(w, expr);
	}
}

VV_LOCAL_SYMBOL void v__markused__Walker_expr(v__markused__Walker* w, v__ast__Expr node) {
	if (node._typ == 295 /* v.ast.EmptyExpr */) {
	}
	else if (node._typ == 278 /* v.ast.AnonFn */) {
		v__markused__Walker_fn_decl(w, (voidptr)&/*qq*/(*node._v__ast__AnonFn).decl);
	}
	else if (node._typ == 280 /* v.ast.ArrayInit */) {
		v__markused__Walker_expr(w, (*node._v__ast__ArrayInit).len_expr);
		v__markused__Walker_expr(w, (*node._v__ast__ArrayInit).cap_expr);
		v__markused__Walker_expr(w, (*node._v__ast__ArrayInit).default_expr);
		v__markused__Walker_exprs(w, (*node._v__ast__ArrayInit).exprs);
	}
	else if (node._typ == 282 /* v.ast.Assoc */) {
		v__markused__Walker_exprs(w, (*node._v__ast__Assoc).exprs);
	}
	else if (node._typ == 279 /* v.ast.ArrayDecompose */) {
		v__markused__Walker_expr(w, (*node._v__ast__ArrayDecompose).expr);
	}
	else if (node._typ == 286 /* v.ast.CallExpr */) {
		v__markused__Walker_call_expr(w, (voidptr)&/*qq*/(*node._v__ast__CallExpr));
	}
	else if (node._typ == 287 /* v.ast.CastExpr */) {
		v__markused__Walker_expr(w, (*node._v__ast__CastExpr).expr);
		v__markused__Walker_expr(w, (*node._v__ast__CastExpr).arg);
	}
	else if (node._typ == 288 /* v.ast.ChanInit */) {
		v__markused__Walker_expr(w, (*node._v__ast__ChanInit).cap_expr);
	}
	else if (node._typ == 293 /* v.ast.ConcatExpr */) {
		v__markused__Walker_exprs(w, (*node._v__ast__ConcatExpr).vals);
	}
	else if (node._typ == 292 /* v.ast.ComptimeSelector */) {
		v__markused__Walker_expr(w, (*node._v__ast__ComptimeSelector).left);
		v__markused__Walker_expr(w, (*node._v__ast__ComptimeSelector).field_expr);
	}
	else if (node._typ == 291 /* v.ast.ComptimeCall */) {
		v__markused__Walker_expr(w, (*node._v__ast__ComptimeCall).left);
		if ((*node._v__ast__ComptimeCall).is_vweb) {
			v__markused__Walker_stmts(w, (*node._v__ast__ComptimeCall).vweb_tmpl.stmts);
		}
	}
	else if (node._typ == 294 /* v.ast.DumpExpr */) {
		v__markused__Walker_expr(w, (*node._v__ast__DumpExpr).expr);
		v__markused__Walker_fn_by_name(w, _SLIT("eprint"));
		v__markused__Walker_fn_by_name(w, _SLIT("eprintln"));
	}
	else if (node._typ == 298 /* v.ast.GoExpr */) {
		v__markused__Walker_expr(w, v__ast__CallExpr_to_sumtype_v__ast__Expr(&(*node._v__ast__GoExpr).call_expr));
		if (w->pref->os == v__pref__OS__windows) {
			v__markused__Walker_fn_by_name(w, _SLIT("panic_lasterr"));
			v__markused__Walker_fn_by_name(w, _SLIT("winapi_lasterr_str"));
		} else {
			v__markused__Walker_fn_by_name(w, _SLIT("c_error_number_str"));
			v__markused__Walker_fn_by_name(w, _SLIT("panic_error_number"));
		}
	}
	else if (node._typ == 302 /* v.ast.IndexExpr */) {
		v__markused__Walker_expr(w, (*node._v__ast__IndexExpr).left);
		v__markused__Walker_expr(w, (*node._v__ast__IndexExpr).index);
		v__markused__Walker_or_block(w, (*node._v__ast__IndexExpr).or_expr);
		if ((*node._v__ast__IndexExpr).left_type == 0) {
			return;
		}
		v__ast__TypeSymbol* sym = v__ast__Table_final_sym(w->table, (*node._v__ast__IndexExpr).left_type);
		if (sym->kind == v__ast__Kind__map) {
			w->table->used_maps++;
		}
	}
	else if (node._typ == 303 /* v.ast.InfixExpr */) {
		v__markused__Walker_expr(w, (*node._v__ast__InfixExpr).left);
		v__markused__Walker_expr(w, (*node._v__ast__InfixExpr).right);
		v__markused__Walker_or_block(w, (*node._v__ast__InfixExpr).or_block);
		if ((*node._v__ast__InfixExpr).left_type == 0) {
			return;
		}
		v__ast__TypeSymbol* sym = v__ast__Table_sym(w->table, (*node._v__ast__InfixExpr).left_type);
		if (sym->kind == v__ast__Kind__struct_) {
			Option_v__ast__Fn _t1;
			if (_t1 = v__ast__TypeSymbol_find_method(sym, v__token__Kind_str((*node._v__ast__InfixExpr).op)), _t1.state == 0) {
				v__ast__Fn opmethod = *(v__ast__Fn*)_t1.data;
				v__markused__Walker_fn_decl(w, ((v__ast__FnDecl*)(opmethod.source_fn)));
			}
		}
		if ((*node._v__ast__InfixExpr).right_type == 0) {
			return;
		}
		v__ast__TypeSymbol* right_sym = v__ast__Table_sym(w->table, (*node._v__ast__InfixExpr).right_type);
		if (((*node._v__ast__InfixExpr).op == v__token__Kind__not_in || (*node._v__ast__InfixExpr).op == v__token__Kind__key_in) && right_sym->kind == v__ast__Kind__map) {
			w->table->used_maps++;
		}
	}
	else if (node._typ == 301 /* v.ast.IfGuardExpr */) {
		v__markused__Walker_expr(w, (*node._v__ast__IfGuardExpr).expr);
	}
	else if (node._typ == 300 /* v.ast.IfExpr */) {
		v__markused__Walker_expr(w, (*node._v__ast__IfExpr).left);
		for (int _t2 = 0; _t2 < (*node._v__ast__IfExpr).branches.len; ++_t2) {
			v__ast__IfBranch b = ((v__ast__IfBranch*)(*node._v__ast__IfExpr).branches.data)[_t2];
			v__markused__Walker_expr(w, b.cond);
			v__markused__Walker_stmts(w, b.stmts);
		}
	}
	else if (node._typ == 299 /* v.ast.Ident */) {

		if ((*node._v__ast__Ident).kind == (v__ast__IdentKind__constant)) {
			v__markused__Walker_mark_const_as_used(w, (*node._v__ast__Ident).name);
		}
		else if ((*node._v__ast__Ident).kind == (v__ast__IdentKind__function)) {
			v__markused__Walker_fn_by_name(w, (*node._v__ast__Ident).name);
		}
		else if ((*node._v__ast__Ident).kind == (v__ast__IdentKind__global)) {
			v__markused__Walker_mark_global_as_used(w, (*node._v__ast__Ident).name);
		}
		else {
		};
	}
	else if (node._typ == 306 /* v.ast.Likely */) {
		v__markused__Walker_expr(w, (*node._v__ast__Likely).expr);
	}
	else if (node._typ == 308 /* v.ast.MapInit */) {
		v__markused__Walker_exprs(w, (*node._v__ast__MapInit).keys);
		v__markused__Walker_exprs(w, (*node._v__ast__MapInit).vals);
		w->table->used_maps++;
	}
	else if (node._typ == 309 /* v.ast.MatchExpr */) {
		v__markused__Walker_expr(w, (*node._v__ast__MatchExpr).cond);
		for (int _t3 = 0; _t3 < (*node._v__ast__MatchExpr).branches.len; ++_t3) {
			v__ast__MatchBranch b = ((v__ast__MatchBranch*)(*node._v__ast__MatchExpr).branches.data)[_t3];
			v__markused__Walker_exprs(w, b.exprs);
			v__markused__Walker_stmts(w, b.stmts);
		}
	}
	else if (node._typ == 311 /* v.ast.None */) {
	}
	else if (node._typ == 314 /* v.ast.ParExpr */) {
		v__markused__Walker_expr(w, (*node._v__ast__ParExpr).expr);
	}
	else if (node._typ == 316 /* v.ast.PrefixExpr */) {
		v__markused__Walker_expr(w, (*node._v__ast__PrefixExpr).right);
	}
	else if (node._typ == 315 /* v.ast.PostfixExpr */) {
		v__markused__Walker_expr(w, (*node._v__ast__PostfixExpr).expr);
	}
	else if (node._typ == 317 /* v.ast.RangeExpr */) {
		if ((*node._v__ast__RangeExpr).has_low) {
			v__markused__Walker_expr(w, (*node._v__ast__RangeExpr).low);
		}
		if ((*node._v__ast__RangeExpr).has_high) {
			v__markused__Walker_expr(w, (*node._v__ast__RangeExpr).high);
		}
	}
	else if (node._typ == 320 /* v.ast.SizeOf */) {
		v__markused__Walker_expr(w, (*node._v__ast__SizeOf).expr);
	}
	else if (node._typ == 305 /* v.ast.IsRefType */) {
		v__markused__Walker_expr(w, (*node._v__ast__IsRefType).expr);
	}
	else if (node._typ == 322 /* v.ast.StringInterLiteral */) {
		v__markused__Walker_exprs(w, (*node._v__ast__StringInterLiteral).exprs);
	}
	else if (node._typ == 319 /* v.ast.SelectorExpr */) {
		v__markused__Walker_expr(w, (*node._v__ast__SelectorExpr).expr);
	}
	else if (node._typ == 321 /* v.ast.SqlExpr */) {
		v__markused__Walker_expr(w, (*node._v__ast__SqlExpr).db_expr);
		v__markused__Walker_expr(w, (*node._v__ast__SqlExpr).offset_expr);
		v__markused__Walker_expr(w, (*node._v__ast__SqlExpr).order_expr);
		v__markused__Walker_expr(w, (*node._v__ast__SqlExpr).limit_expr);
		v__markused__Walker_expr(w, (*node._v__ast__SqlExpr).where_expr);
	}
	else if (node._typ == 324 /* v.ast.StructInit */) {
		if ((*node._v__ast__StructInit).typ == 0) {
			return;
		}
		v__ast__TypeSymbol* sym = v__ast__Table_sym(w->table, (*node._v__ast__StructInit).typ);
		if (sym->kind == v__ast__Kind__struct_) {
			v__ast__Struct info = /* as */ *(v__ast__Struct*)__as_cast((sym->info)._v__ast__Struct,(sym->info)._typ, 446) /*expected idx: 446, name: v.ast.Struct */ ;
			for (int _t4 = 0; _t4 < info.fields.len; ++_t4) {
				v__ast__StructField ifield = ((v__ast__StructField*)info.fields.data)[_t4];
				if (ifield.has_default_expr) {
					v__markused__Walker_expr(w, ifield.default_expr);
				}
				if (ifield.typ != 0) {
					v__ast__TypeSymbol* fsym = v__ast__Table_sym(w->table, ifield.typ);
					if (fsym->kind == v__ast__Kind__map) {
						w->table->used_maps++;
					}
				}
			}
		}
		if ((*node._v__ast__StructInit).has_update_expr) {
			v__markused__Walker_expr(w, (*node._v__ast__StructInit).update_expr);
		}
		for (int _t5 = 0; _t5 < (*node._v__ast__StructInit).fields.len; ++_t5) {
			v__ast__StructInitField sif = ((v__ast__StructInitField*)(*node._v__ast__StructInit).fields.data)[_t5];
			v__markused__Walker_expr(w, sif.expr);
		}
		for (int _t6 = 0; _t6 < (*node._v__ast__StructInit).embeds.len; ++_t6) {
			v__ast__StructInitEmbed sie = ((v__ast__StructInitEmbed*)(*node._v__ast__StructInit).embeds.data)[_t6];
			v__markused__Walker_expr(w, sie.expr);
		}
	}
	else if (node._typ == 326 /* v.ast.TypeOf */) {
		v__markused__Walker_expr(w, (*node._v__ast__TypeOf).expr);
	}
	else if (node._typ == 281 /* v.ast.AsCast */) {
		v__markused__Walker_expr(w, (*node._v__ast__AsCast).expr);
	}
	else if (node._typ == 283 /* v.ast.AtExpr */) {
	}
	else if (node._typ == 284 /* v.ast.BoolLiteral */) {
	}
	else if (node._typ == 297 /* v.ast.FloatLiteral */) {
	}
	else if (node._typ == 289 /* v.ast.CharLiteral */) {
	}
	else if (node._typ == 304 /* v.ast.IntegerLiteral */) {
	}
	else if (node._typ == 323 /* v.ast.StringLiteral */) {
	}
	else if (node._typ == 285 /* v.ast.CTempVar */) {
		v__markused__Walker_expr(w, (*node._v__ast__CTempVar).orig);
	}
	else if (node._typ == 290 /* v.ast.Comment */) {
	}
	else if (node._typ == 296 /* v.ast.EnumVal */) {
	}
	else if (node._typ == 307 /* v.ast.LockExpr */) {
		v__markused__Walker_stmts(w, (*node._v__ast__LockExpr).stmts);
	}
	else if (node._typ == 312 /* v.ast.OffsetOf */) {
	}
	else if (node._typ == 313 /* v.ast.OrExpr */) {
		v__markused__Walker_or_block(w, (*node._v__ast__OrExpr));
	}
	else if (node._typ == 318 /* v.ast.SelectExpr */) {
		for (int _t7 = 0; _t7 < (*node._v__ast__SelectExpr).branches.len; ++_t7) {
			v__ast__SelectBranch branch = ((v__ast__SelectBranch*)(*node._v__ast__SelectExpr).branches.data)[_t7];
			v__markused__Walker_stmt(w, branch.stmt);
			v__markused__Walker_stmts(w, branch.stmts);
		}
	}
	else if (node._typ == 325 /* v.ast.TypeNode */) {
	}
	else if (node._typ == 327 /* v.ast.UnsafeExpr */) {
		v__markused__Walker_expr(w, (*node._v__ast__UnsafeExpr).expr);
	}
	else if (node._typ == 310 /* v.ast.NodeError */) {
	}
	;
}

void v__markused__Walker_fn_decl(v__markused__Walker* w, v__ast__FnDecl* node) {
	if (node->language == v__ast__Language__c) {
		return;
	}
	string fkey = v__ast__FnDecl_fkey(node);
	if ((*(bool*)map_get(ADDR(map, w->used_fns), &(string[]){fkey}, &(bool[]){ 0 }))) {
		return;
	}
	v__markused__Walker_mark_fn_as_used(w, fkey);
	v__markused__Walker_stmts(w, node->stmts);
	v__markused__Walker_defer_stmts(w, node->defer_stmts);
}

void v__markused__Walker_call_expr(v__markused__Walker* w, v__ast__CallExpr* node) {
	for (int _t1 = 0; _t1 < node->args.len; ++_t1) {
		v__ast__CallArg arg = ((v__ast__CallArg*)node->args.data)[_t1];
		v__markused__Walker_expr(w, arg.expr);
	}
	if (node->language == v__ast__Language__c) {
		if (string__eq(node->name, _SLIT("C.wyhash")) || string__eq(node->name, _SLIT("C.wyhash64"))) {
			w->table->used_maps++;
		}
		return;
	}
	v__markused__Walker_expr(w, node->left);
	v__markused__Walker_or_block(w, node->or_block);
	string fn_name = v__ast__CallExpr_fkey(node);
	if ((*(bool*)map_get(ADDR(map, w->used_fns), &(string[]){fn_name}, &(bool[]){ 0 }))) {
		return;
	}
	v__markused__Walker_mark_fn_as_used(w, fn_name);
	v__ast__FnDecl* _t3 = (v__ast__FnDecl*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, w->all_fns), &(string[]){fn_name}));
	Option_v__ast__FnDecl _t2 = {0};
	if (_t3) {
		*((v__ast__FnDecl*)&_t2.data) = *((v__ast__FnDecl*)_t3);
	} else {
		_t2.state = 2; _t2.err = _v_error(_SLIT("array index out of range"));
	}
	;
	if (_t2.state != 0) { /*or block*/ 
		IError err = _t2.err;
		return;
	}
	
	v__ast__FnDecl stmt = *(v__ast__FnDecl*)_t2.data;
	if (string__eq(stmt.name, node->name)) {
		if (!node->is_method || (v__ast__Type_alias_eq(node->receiver_type, stmt.receiver.typ))) {
			v__markused__Walker_stmts(w, stmt.stmts);
		}
	}
}

void v__markused__Walker_fn_by_name(v__markused__Walker* w, string fn_name) {
	if ((*(bool*)map_get(ADDR(map, w->used_fns), &(string[]){fn_name}, &(bool[]){ 0 }))) {
		return;
	}
	v__ast__FnDecl* _t2 = (v__ast__FnDecl*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, w->all_fns), &(string[]){fn_name}));
	Option_v__ast__FnDecl _t1 = {0};
	if (_t2) {
		*((v__ast__FnDecl*)&_t1.data) = *((v__ast__FnDecl*)_t2);
	} else {
		_t1.state = 2; _t1.err = _v_error(_SLIT("array index out of range"));
	}
	;
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		return;
	}
	
	v__ast__FnDecl stmt = *(v__ast__FnDecl*)_t1.data;
	v__markused__Walker_mark_fn_as_used(w, fn_name);
	v__markused__Walker_stmts(w, stmt.stmts);
}

void v__markused__Walker_struct_fields(v__markused__Walker* w, Array_v__ast__StructField sfields) {
	for (int _t1 = 0; _t1 < sfields.len; ++_t1) {
		v__ast__StructField sf = ((v__ast__StructField*)sfields.data)[_t1];
		if (sf.has_default_expr) {
			v__markused__Walker_expr(w, sf.default_expr);
		}
	}
}

void v__markused__Walker_const_fields(v__markused__Walker* w, Array_v__ast__ConstField cfields) {
	for (int _t1 = 0; _t1 < cfields.len; ++_t1) {
		v__ast__ConstField cf = ((v__ast__ConstField*)cfields.data)[_t1];
		v__markused__Walker_expr(w, cf.expr);
	}
}

void v__markused__Walker_or_block(v__markused__Walker* w, v__ast__OrExpr node) {
	if (node.kind == v__ast__OrKind__block) {
		v__markused__Walker_stmts(w, node.stmts);
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_array_init(v__gen__c__Gen* g, v__ast__ArrayInit node) {
	v__gen__c__Type array_type = v__gen__c__Gen_unwrap(g, node.typ);
	string array_styp = _SLIT("");
	v__gen__c__Type elem_type = v__gen__c__Gen_unwrap(g, node.elem_type);
	string shared_styp = _SLIT("");
	bool is_amp = g->is_amp;
	g->is_amp = false;
	if (is_amp) {
		strings__Builder_go_back(&g->out, 1);
	}
	if (g->is_shared) {
		shared_styp = v__gen__c__Gen_typ(g, v__ast__Type_set_flag(array_type.typ, v__ast__TypeFlag__shared_f));
		v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("("), 0xfe10, {.d_s = shared_styp}}, {_SLIT("*)__dup_shared_array(&("), 0xfe10, {.d_s = shared_styp}}, {_SLIT("){.mtx = {0}, .val ="), 0, { .d_c = 0 }}})));
	} else if (is_amp) {
		array_styp = v__gen__c__Gen_typ(g, array_type.typ);
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("HEAP("), 0xfe10, {.d_s = array_styp}}, {_SLIT(", "), 0, { .d_c = 0 }}})));
	}
	if (array_type.unaliased_sym->kind == v__ast__Kind__array_fixed) {
		if (node.has_it) {
			g->inside_lambda = true;
			string tmp = v__gen__c__Gen_new_tmp_var(g);
			string s = v__gen__c__Gen_go_before_stmt(g, 0);
			bool s_ends_with_ln = string_ends_with(s, _SLIT("\n"));
			s = string_trim_space(s);
			string ret_typ = v__gen__c__Gen_typ(g, node.typ);
			string elem_typ = v__gen__c__Gen_typ(g, node.elem_type);
			g->empty_line = true;
			v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ret_typ}}, {_SLIT(" "), 0xfe10, {.d_s = tmp}}, {_SLIT(" ="), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_write(g, _SLIT("{"));
			if (node.has_val) {
				for (int i = 0; i < node.exprs.len; ++i) {
					v__ast__Expr expr = ((v__ast__Expr*)node.exprs.data)[i];
					if (v__ast__Expr_is_auto_deref_var(expr)) {
						v__gen__c__Gen_write(g, _SLIT("*"));
					}
					v__gen__c__Gen_write(g, _SLIT("0"));
					if (i != node.exprs.len - 1) {
						v__gen__c__Gen_write(g, _SLIT(", "));
					}
				}
			} else if (node.has_default) {
				v__gen__c__Gen_write(g, _SLIT("0"));
				v__ast__ArrayFixed info = /* as */ *(v__ast__ArrayFixed*)__as_cast((array_type.unaliased_sym->info)._v__ast__ArrayFixed,(array_type.unaliased_sym->info)._typ, 468) /*expected idx: 468, name: v.ast.ArrayFixed */ ;
				for (int _t1 = 1; _t1 < info.size; ++_t1) {
					v__gen__c__Gen_write(g, _SLIT(", "));
					v__gen__c__Gen_write(g, _SLIT("0"));
				}
			} else {
				v__gen__c__Gen_write(g, _SLIT("0"));
			}
			v__gen__c__Gen_write(g, _SLIT("}"));
			v__gen__c__Gen_writeln(g, _SLIT(";"));
			v__gen__c__Gen_writeln(g, _SLIT("{"));
			g->indent++;
			v__gen__c__Gen_writeln(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = elem_typ}}, {_SLIT("* pelem = ("), 0xfe10, {.d_s = elem_typ}}, {_SLIT("*)"), 0xfe10, {.d_s = tmp}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("int _len = (int)sizeof("), 0xfe10, {.d_s = tmp}}, {_SLIT(") / sizeof("), 0xfe10, {.d_s = elem_typ}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_writeln(g, _SLIT("for(int it=0; it<_len; it++, pelem++) {"));
			g->indent++;
			v__gen__c__Gen_write(g, _SLIT("*pelem = "));
			v__gen__c__Gen_expr(g, node.default_expr);
			v__gen__c__Gen_writeln(g, _SLIT(";"));
			g->indent--;
			v__gen__c__Gen_writeln(g, _SLIT("}"));
			g->indent--;
			v__gen__c__Gen_writeln(g, _SLIT("}"));
			if (s_ends_with_ln) {
				v__gen__c__Gen_writeln(g, s);
			} else {
				v__gen__c__Gen_write(g, s);
			}
			v__gen__c__Gen_write(g, tmp);
			g->inside_lambda = false;
			return;
		}
		v__gen__c__Gen_write(g, _SLIT("{"));
		if (node.has_val) {
			for (int i = 0; i < node.exprs.len; ++i) {
				v__ast__Expr expr = ((v__ast__Expr*)node.exprs.data)[i];
				if (v__ast__Expr_is_auto_deref_var(expr)) {
					v__gen__c__Gen_write(g, _SLIT("*"));
				}
				v__gen__c__Gen_expr(g, expr);
				if (i != node.exprs.len - 1) {
					v__gen__c__Gen_write(g, _SLIT(", "));
				}
			}
		} else if (node.has_default) {
			v__gen__c__Gen_expr(g, node.default_expr);
			v__ast__ArrayFixed info = /* as */ *(v__ast__ArrayFixed*)__as_cast((array_type.unaliased_sym->info)._v__ast__ArrayFixed,(array_type.unaliased_sym->info)._typ, 468) /*expected idx: 468, name: v.ast.ArrayFixed */ ;
			for (int _t2 = 1; _t2 < info.size; ++_t2) {
				v__gen__c__Gen_write(g, _SLIT(", "));
				v__gen__c__Gen_expr(g, node.default_expr);
			}
		} else {
			v__gen__c__Gen_write(g, _SLIT("0"));
		}
		v__gen__c__Gen_write(g, _SLIT("}"));
		return;
	}
	string elem_styp = v__gen__c__Gen_typ(g, elem_type.typ);
	string noscan = v__gen__c__Gen_check_noscan(g, elem_type.typ);
	if (node.exprs.len == 0) {
		bool is_default_array = elem_type.unaliased_sym->kind == v__ast__Kind__array && node.has_default;
		bool is_default_map = elem_type.unaliased_sym->kind == v__ast__Kind__map && node.has_default;
		if (node.has_it) {
			g->inside_lambda = true;
			string tmp = v__gen__c__Gen_new_tmp_var(g);
			string s = v__gen__c__Gen_go_before_stmt(g, 0);
			bool s_ends_with_ln = string_ends_with(s, _SLIT("\n"));
			s = string_trim_space(s);
			string ret_typ = v__gen__c__Gen_typ(g, node.typ);
			string elem_typ = v__gen__c__Gen_typ(g, node.elem_type);
			g->empty_line = true;
			v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ret_typ}}, {_SLIT(" "), 0xfe10, {.d_s = tmp}}, {_SLIT(" ="), 0, { .d_c = 0 }}})));
			if (is_default_array) {
				v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("__new_array_with_array_default"), 0xfe10, {.d_s = noscan}}, {_SLIT("("), 0, { .d_c = 0 }}})));
			} else if (is_default_map) {
				v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("__new_array_with_map_default"), 0xfe10, {.d_s = noscan}}, {_SLIT("("), 0, { .d_c = 0 }}})));
			} else {
				v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("__new_array_with_default"), 0xfe10, {.d_s = noscan}}, {_SLIT("("), 0, { .d_c = 0 }}})));
			}
			if (node.has_len) {
				v__gen__c__Gen_expr(g, node.len_expr);
				v__gen__c__Gen_write(g, _SLIT(", "));
			} else {
				v__gen__c__Gen_write(g, _SLIT("0, "));
			}
			if (node.has_cap) {
				v__gen__c__Gen_expr(g, node.cap_expr);
				v__gen__c__Gen_write(g, _SLIT(", "));
			} else {
				v__gen__c__Gen_write(g, _SLIT("0, "));
			}
			if (elem_type.unaliased_sym->kind == v__ast__Kind__function) {
				v__gen__c__Gen_write(g, _SLIT("sizeof(voidptr), "));
			} else {
				v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("sizeof("), 0xfe10, {.d_s = elem_styp}}, {_SLIT("), "), 0, { .d_c = 0 }}})));
			}
			if (is_default_array) {
				v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("("), 0xfe10, {.d_s = elem_styp}}, {_SLIT("[]){"), 0, { .d_c = 0 }}})));
				v__gen__c__Gen_expr(g, node.default_expr);
				v__gen__c__Gen_write(g, _SLIT("}[0])"));
			} else if (node.has_len && v__ast__Type_alias_eq(node.elem_type, _const_v__ast__string_type)) {
				v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("&("), 0xfe10, {.d_s = elem_styp}}, {_SLIT("[]){"), 0, { .d_c = 0 }}})));
				v__gen__c__Gen_write(g, _SLIT("_SLIT(\"\")"));
				v__gen__c__Gen_write(g, _SLIT("})"));
			} else if (node.has_len && (elem_type.unaliased_sym->kind == v__ast__Kind__array || elem_type.unaliased_sym->kind == v__ast__Kind__map)) {
				v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("(voidptr)&("), 0xfe10, {.d_s = elem_styp}}, {_SLIT("[]){"), 0, { .d_c = 0 }}})));
				v__gen__c__Gen_write(g, v__gen__c__Gen_type_default(g, node.elem_type));
				v__gen__c__Gen_write(g, _SLIT("}[0])"));
			} else {
				v__gen__c__Gen_write(g, _SLIT("0)"));
			}
			if (g->is_shared) {
				v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("}, sizeof("), 0xfe10, {.d_s = shared_styp}}, {_SLIT("))"), 0, { .d_c = 0 }}})));
			} else if (is_amp) {
				v__gen__c__Gen_write(g, _SLIT(")"));
			}
			v__gen__c__Gen_writeln(g, _SLIT(";"));
			v__gen__c__Gen_writeln(g, _SLIT("{"));
			g->indent++;
			v__gen__c__Gen_writeln(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = elem_typ}}, {_SLIT("* pelem = ("), 0xfe10, {.d_s = elem_typ}}, {_SLIT("*)"), 0xfe10, {.d_s = tmp}}, {_SLIT(".data;"), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("for(int it=0; it<"), 0xfe10, {.d_s = tmp}}, {_SLIT(".len; it++, pelem++) {"), 0, { .d_c = 0 }}})));
			g->indent++;
			v__gen__c__Gen_write(g, _SLIT("*pelem = "));
			v__gen__c__Gen_expr(g, node.default_expr);
			v__gen__c__Gen_writeln(g, _SLIT(";"));
			g->indent--;
			v__gen__c__Gen_writeln(g, _SLIT("}"));
			g->indent--;
			v__gen__c__Gen_writeln(g, _SLIT("}"));
			if (s_ends_with_ln) {
				v__gen__c__Gen_writeln(g, s);
			} else {
				v__gen__c__Gen_write(g, s);
			}
			v__gen__c__Gen_write(g, tmp);
			g->inside_lambda = false;
			return;
		}
		if (is_default_array) {
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("__new_array_with_array_default"), 0xfe10, {.d_s = noscan}}, {_SLIT("("), 0, { .d_c = 0 }}})));
		} else if (is_default_map) {
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("__new_array_with_map_default"), 0xfe10, {.d_s = noscan}}, {_SLIT("("), 0, { .d_c = 0 }}})));
		} else {
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("__new_array_with_default"), 0xfe10, {.d_s = noscan}}, {_SLIT("("), 0, { .d_c = 0 }}})));
		}
		if (node.has_len) {
			v__gen__c__Gen_expr(g, node.len_expr);
			v__gen__c__Gen_write(g, _SLIT(", "));
		} else {
			v__gen__c__Gen_write(g, _SLIT("0, "));
		}
		if (node.has_cap) {
			v__gen__c__Gen_expr(g, node.cap_expr);
			v__gen__c__Gen_write(g, _SLIT(", "));
		} else {
			v__gen__c__Gen_write(g, _SLIT("0, "));
		}
		if (elem_type.unaliased_sym->kind == v__ast__Kind__function) {
			v__gen__c__Gen_write(g, _SLIT("sizeof(voidptr), "));
		} else {
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("sizeof("), 0xfe10, {.d_s = elem_styp}}, {_SLIT("), "), 0, { .d_c = 0 }}})));
		}
		if (is_default_array || is_default_map) {
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("("), 0xfe10, {.d_s = elem_styp}}, {_SLIT("[]){"), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_expr(g, node.default_expr);
			v__gen__c__Gen_write(g, _SLIT("}[0])"));
		} else if (node.has_default) {
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("&("), 0xfe10, {.d_s = elem_styp}}, {_SLIT("[]){"), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_expr(g, node.default_expr);
			v__gen__c__Gen_write(g, _SLIT("})"));
		} else if (node.has_len && v__ast__Type_alias_eq(node.elem_type, _const_v__ast__string_type)) {
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("&("), 0xfe10, {.d_s = elem_styp}}, {_SLIT("[]){"), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_write(g, _SLIT("_SLIT(\"\")"));
			v__gen__c__Gen_write(g, _SLIT("})"));
		} else if (node.has_len && (elem_type.unaliased_sym->kind == v__ast__Kind__array || elem_type.unaliased_sym->kind == v__ast__Kind__map)) {
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("(voidptr)&("), 0xfe10, {.d_s = elem_styp}}, {_SLIT("[]){"), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_write(g, v__gen__c__Gen_type_default(g, node.elem_type));
			v__gen__c__Gen_write(g, _SLIT("}[0])"));
		} else {
			v__gen__c__Gen_write(g, _SLIT("0)"));
		}
		if (g->is_shared) {
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("}, sizeof("), 0xfe10, {.d_s = shared_styp}}, {_SLIT("))"), 0, { .d_c = 0 }}})));
		} else if (is_amp) {
			v__gen__c__Gen_write(g, _SLIT(")"));
		}
		return;
	}
	int len = node.exprs.len;
	if (elem_type.unaliased_sym->kind == v__ast__Kind__function) {
		v__gen__c__Gen_write(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("new_array_from_c_array("), 0xfe07, {.d_i32 = len}}, {_SLIT(", "), 0xfe07, {.d_i32 = len}}, {_SLIT(", sizeof(voidptr), _MOV((voidptr["), 0xfe07, {.d_i32 = len}}, {_SLIT("]){"), 0, { .d_c = 0 }}})));
	} else {
		v__gen__c__Gen_write(g,  str_intp(7, _MOV((StrIntpData[]){{_SLIT("new_array_from_c_array"), 0xfe10, {.d_s = noscan}}, {_SLIT("("), 0xfe07, {.d_i32 = len}}, {_SLIT(", "), 0xfe07, {.d_i32 = len}}, {_SLIT(", sizeof("), 0xfe10, {.d_s = elem_styp}}, {_SLIT("), _MOV(("), 0xfe10, {.d_s = elem_styp}}, {_SLIT("["), 0xfe07, {.d_i32 = len}}, {_SLIT("]){"), 0, { .d_c = 0 }}})));
	}
	if (len > 8) {
		v__gen__c__Gen_writeln(g, _SLIT(""));
		v__gen__c__Gen_write(g, _SLIT("\t\t"));
	}
	for (int i = 0; i < node.exprs.len; ++i) {
		v__ast__Expr expr = ((v__ast__Expr*)node.exprs.data)[i];
		if (v__ast__Type_alias_eq((*(v__ast__Type*)/*ee elem_typ */array_get(node.expr_types, i)), _const_v__ast__string_type) && (expr)._typ != 323 /* v.ast.StringLiteral */ && (expr)._typ != 322 /* v.ast.StringInterLiteral */) {
			v__gen__c__Gen_write(g, _SLIT("string_clone("));
			v__gen__c__Gen_expr(g, expr);
			v__gen__c__Gen_write(g, _SLIT(")"));
		} else {
			v__gen__c__Gen_expr_with_cast(g, expr, (*(v__ast__Type*)/*ee elem_typ */array_get(node.expr_types, i)), node.elem_type);
		}
		if (i != len - 1) {
			if (i > 0 && (i & 7) == 0) {
				v__gen__c__Gen_writeln(g, _SLIT(","));
				v__gen__c__Gen_write(g, _SLIT("\t\t"));
			} else {
				v__gen__c__Gen_write(g, _SLIT(", "));
			}
		}
	}
	v__gen__c__Gen_write(g, _SLIT("}))"));
	if (g->is_shared) {
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("}, sizeof("), 0xfe10, {.d_s = shared_styp}}, {_SLIT("))"), 0, { .d_c = 0 }}})));
	} else if (is_amp) {
		v__gen__c__Gen_write(g, _SLIT(")"));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_array_map(v__gen__c__Gen* g, v__ast__CallExpr node) {
	g->inside_lambda = true;
	string tmp = v__gen__c__Gen_new_tmp_var(g);
	string s = v__gen__c__Gen_go_before_stmt(g, 0);
	bool s_ends_with_ln = string_ends_with(s, _SLIT("\n"));
	s = string_trim_space(s);
	string ret_typ = v__gen__c__Gen_typ(g, node.return_type);
	v__ast__TypeSymbol* ret_sym = v__ast__Table_sym(g->table, node.return_type);
	v__ast__TypeSymbol* inp_sym = v__ast__Table_sym(g->table, node.receiver_type);
	v__ast__Array ret_info = /* as */ *(v__ast__Array*)__as_cast((ret_sym->info)._v__ast__Array,(ret_sym->info)._typ, 441) /*expected idx: 441, name: v.ast.Array */ ;
	string ret_elem_type = v__gen__c__Gen_typ(g, ret_info.elem_type);
	v__ast__Array inp_info = /* as */ *(v__ast__Array*)__as_cast((inp_sym->info)._v__ast__Array,(inp_sym->info)._typ, 441) /*expected idx: 441, name: v.ast.Array */ ;
	string inp_elem_type = v__gen__c__Gen_typ(g, inp_info.elem_type);
	if (inp_sym->kind != v__ast__Kind__array) {
		v__gen__c__verror(_SLIT("map() requires an array"));
		VUNREACHABLE();
	}
	g->empty_line = true;
	string noscan = v__gen__c__Gen_check_noscan(g, ret_info.elem_type);
	v__gen__c__Gen_writeln(g,  str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ret_typ}}, {_SLIT(" "), 0xfe10, {.d_s = tmp}}, {_SLIT(" = __new_array"), 0xfe10, {.d_s = noscan}}, {_SLIT("(0, 0, sizeof("), 0xfe10, {.d_s = ret_elem_type}}, {_SLIT("));"), 0, { .d_c = 0 }}})));
	bool has_infix_left_var_name = g->infix_left_var_name.len > 0;
	if (has_infix_left_var_name) {
		v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("if ("), 0xfe10, {.d_s = g->infix_left_var_name}}, {_SLIT(") {"), 0, { .d_c = 0 }}})));
		g->infix_left_var_name = _SLIT("");
		g->indent++;
	}
	v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__gen__c__Gen_typ(g, node.left_type)}}, {_SLIT(" "), 0xfe10, {.d_s = tmp}}, {_SLIT("_orig = "), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_expr(g, node.left);
	v__gen__c__Gen_writeln(g, _SLIT(";"));
	v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("int "), 0xfe10, {.d_s = tmp}}, {_SLIT("_len = "), 0xfe10, {.d_s = tmp}}, {_SLIT("_orig.len;"), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_writeln(g,  str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = tmp}}, {_SLIT(" = __new_array"), 0xfe10, {.d_s = noscan}}, {_SLIT("(0, "), 0xfe10, {.d_s = tmp}}, {_SLIT("_len, sizeof("), 0xfe10, {.d_s = ret_elem_type}}, {_SLIT("));\n"), 0, { .d_c = 0 }}})));
	string i = v__gen__c__Gen_new_tmp_var(g);
	v__gen__c__Gen_writeln(g,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("for (int "), 0xfe10, {.d_s = i}}, {_SLIT(" = 0; "), 0xfe10, {.d_s = i}}, {_SLIT(" < "), 0xfe10, {.d_s = tmp}}, {_SLIT("_len; ++"), 0xfe10, {.d_s = i}}, {_SLIT(") {"), 0, { .d_c = 0 }}})));
	g->indent++;
	v__gen__c__Gen_writeln(g,  str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = inp_elem_type}}, {_SLIT(" it = (("), 0xfe10, {.d_s = inp_elem_type}}, {_SLIT("*) "), 0xfe10, {.d_s = tmp}}, {_SLIT("_orig.data)["), 0xfe10, {.d_s = i}}, {_SLIT("];"), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_set_current_pos_as_last_stmt_pos(g);
	bool is_embed_map_filter = false;
	v__ast__Expr expr = (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr;
	if (expr._typ == 278 /* v.ast.AnonFn */) {
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ret_elem_type}}, {_SLIT(" ti = "), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_gen_anon_fn_decl(g, (voidptr)&/*qq*/(*expr._v__ast__AnonFn));
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = (*expr._v__ast__AnonFn).decl.name}}, {_SLIT("(it)"), 0, { .d_c = 0 }}})));
	}
	else if (expr._typ == 299 /* v.ast.Ident */) {
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ret_elem_type}}, {_SLIT(" ti = "), 0, { .d_c = 0 }}})));
		if ((*expr._v__ast__Ident).kind == v__ast__IdentKind__function) {
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__gen__c__c_name((*expr._v__ast__Ident).name)}}, {_SLIT("(it)"), 0, { .d_c = 0 }}})));
		} else if ((*expr._v__ast__Ident).kind == v__ast__IdentKind__variable) {
			v__ast__IdentVar var_info = v__ast__Ident_var_info(&(*expr._v__ast__Ident));
			v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, var_info.typ);
			if (sym->kind == v__ast__Kind__function) {
				v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__gen__c__c_name((*expr._v__ast__Ident).name)}}, {_SLIT("(it)"), 0, { .d_c = 0 }}})));
			} else {
				v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
			}
		} else {
			v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
		}
	}
	else if (expr._typ == 286 /* v.ast.CallExpr */) {
		if (string__eq((*expr._v__ast__CallExpr).name, _SLIT("map")) || string__eq((*expr._v__ast__CallExpr).name, _SLIT("filter")) || string__eq((*expr._v__ast__CallExpr).name, _SLIT("all")) || string__eq((*expr._v__ast__CallExpr).name, _SLIT("any"))) {
			is_embed_map_filter = true;
			v__gen__c__Gen_set_current_pos_as_last_stmt_pos(g);
		}
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ret_elem_type}}, {_SLIT(" ti = "), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
	}
	
	else {
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ret_elem_type}}, {_SLIT(" ti = "), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
	}
	;
	v__gen__c__Gen_writeln(g, _SLIT(";"));
	v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("array_push"), 0xfe10, {.d_s = noscan}}, {_SLIT("((array*)&"), 0xfe10, {.d_s = tmp}}, {_SLIT(", &ti);"), 0, { .d_c = 0 }}})));
	g->indent--;
	v__gen__c__Gen_writeln(g, _SLIT("}"));
	if (!is_embed_map_filter) {
		v__gen__c__Gen_set_current_pos_as_last_stmt_pos(g);
	}
	if (has_infix_left_var_name) {
		g->indent--;
		v__gen__c__Gen_writeln(g, _SLIT("}"));
	}
	if (s_ends_with_ln) {
		v__gen__c__Gen_writeln(g, s);
	} else {
		v__gen__c__Gen_write(g, s);
	}
	v__gen__c__Gen_write(g, tmp);
	g->inside_lambda = false;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_array_sort(v__gen__c__Gen* g, v__ast__CallExpr node) {
	v__ast__TypeSymbol* rec_sym = v__ast__Table_sym(g->table, node.receiver_type);
	if (rec_sym->kind != v__ast__Kind__array) {
		println(node.name);
		println(v__gen__c__Gen_typ(g, node.receiver_type));
		v__gen__c__verror(_SLIT(".sort() is an array method"));
		VUNREACHABLE();
	}
	if (g->pref->is_bare) {
		v__gen__c__Gen_writeln(g, _SLIT("bare_panic(_SLIT(\"sort does not work with -freestanding\"))"));
		return;
	}
	v__ast__Array info = /* as */ *(v__ast__Array*)__as_cast((rec_sym->info)._v__ast__Array,(rec_sym->info)._typ, 441) /*expected idx: 441, name: v.ast.Array */ ;
	string elem_stype = v__gen__c__Gen_typ(g, info.elem_type);
	string compare_fn =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("compare_"), 0xfe08, {.d_u64 = g->unique_file_path_hash}}, {_SLIT("_"), 0xfe10, {.d_s = string_replace(elem_stype, _SLIT("*"), _SLIT("_ptr"))}}, {_SLIT0, 0, { .d_c = 0 }}}));
	v__gen__c__Type comparison_type = v__gen__c__Gen_unwrap(g, _const_v__ast__void_type);
	string left_expr = _SLIT("");
	string right_expr = _SLIT("");
	if (node.args.len == 0) {
		comparison_type = v__gen__c__Gen_unwrap(g, v__ast__Type_set_nr_muls(info.elem_type, 0));
		__shared__Array_string* a = g->array_sort_fn;
		Array_string array_sort_fn = array_clone_to_depth(&a->val, 0);
		if (Array_string_contains(array_sort_fn, compare_fn)) {
			v__gen__c__Gen_gen_array_sort_call(g, node, compare_fn);
			return;
		}
		left_expr = _SLIT("*a");
		right_expr = _SLIT("*b");
	} else {
		v__ast__InfixExpr infix_expr = /* as */ *(v__ast__InfixExpr*)__as_cast(((*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr)._v__ast__InfixExpr,((*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr)._typ, 303) /*expected idx: 303, name: v.ast.InfixExpr */ ;
		comparison_type = v__gen__c__Gen_unwrap(g, v__ast__Type_set_nr_muls(infix_expr.left_type, 0));
		string left_name = v__ast__Expr_str(infix_expr.left);
		if (left_name.len > 1) {
			compare_fn = /*f*/string__plus(compare_fn, string__plus(_SLIT("_by"), string_replace_each(string_substr(left_name, 1, left_name.len), new_array_from_c_array(6, 6, sizeof(string), _MOV((string[6]){_SLIT("."), _SLIT("_"), _SLIT("["), _SLIT("_"), _SLIT("]"), _SLIT("_")})))));
		}
		bool is_reverse = (string_starts_with(left_name, _SLIT("a")) && infix_expr.op == v__token__Kind__gt) || (string_starts_with(left_name, _SLIT("b")) && infix_expr.op == v__token__Kind__lt);
		if (is_reverse) {
			compare_fn = /*f*/string__plus(compare_fn, _SLIT("_reverse"));
		}
		__shared__Array_string* a = g->array_sort_fn;
		Array_string array_sort_fn = array_clone_to_depth(&a->val, 0);
		if (Array_string_contains(array_sort_fn, compare_fn)) {
			v__gen__c__Gen_gen_array_sort_call(g, node, compare_fn);
			return;
		}
		if (string_starts_with(left_name, _SLIT("a")) != is_reverse) {
			left_expr = v__gen__c__Gen_expr_string(g, infix_expr.left);
			right_expr = v__gen__c__Gen_expr_string(g, infix_expr.right);
			if ((infix_expr.left)._typ == 299 /* v.ast.Ident */) {
				left_expr = string__plus(_SLIT("*"), left_expr);
			}
			if ((infix_expr.right)._typ == 299 /* v.ast.Ident */) {
				right_expr = string__plus(_SLIT("*"), right_expr);
			}
		} else {
			left_expr = v__gen__c__Gen_expr_string(g, infix_expr.right);
			right_expr = v__gen__c__Gen_expr_string(g, infix_expr.left);
			if ((infix_expr.left)._typ == 299 /* v.ast.Ident */) {
				right_expr = string__plus(_SLIT("*"), right_expr);
			}
			if ((infix_expr.right)._typ == 299 /* v.ast.Ident */) {
				left_expr = string__plus(_SLIT("*"), left_expr);
			}
		}
	}
	sync__RwMutex_lock(&g->array_sort_fn->mtx);
	/*lock*/ {
		array_push((array*)&g->array_sort_fn->val, _MOV((string[]){ string_clone(compare_fn) }));
	}
	sync__RwMutex_unlock(&g->array_sort_fn->mtx);;
	string stype_arg = v__gen__c__Gen_typ(g, info.elem_type);
	strings__Builder_writeln(&g->definitions,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("VV_LOCAL_SYMBOL int "), 0xfe10, {.d_s = compare_fn}}, {_SLIT("("), 0xfe10, {.d_s = stype_arg}}, {_SLIT("* a, "), 0xfe10, {.d_s = stype_arg}}, {_SLIT("* b) {"), 0, { .d_c = 0 }}})));
	string c_condition = (v__ast__TypeSymbol_has_method(comparison_type.sym, _SLIT("<")) ? ( str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__gen__c__Gen_typ(g, comparison_type.typ)}}, {_SLIT("__lt("), 0xfe10, {.d_s = left_expr}}, {_SLIT(", "), 0xfe10, {.d_s = right_expr}}, {_SLIT(")"), 0, { .d_c = 0 }}}))) : v__ast__TypeSymbol_has_method(comparison_type.unaliased_sym, _SLIT("<")) ? ( str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__gen__c__Gen_typ(g, comparison_type.unaliased)}}, {_SLIT("__lt("), 0xfe10, {.d_s = left_expr}}, {_SLIT(", "), 0xfe10, {.d_s = right_expr}}, {_SLIT(")"), 0, { .d_c = 0 }}}))) : ( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = left_expr}}, {_SLIT(" < "), 0xfe10, {.d_s = right_expr}}, {_SLIT0, 0, { .d_c = 0 }}}))));
	strings__Builder_writeln(&g->definitions,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\tif ("), 0xfe10, {.d_s = c_condition}}, {_SLIT(") return -1;"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&g->definitions, _SLIT("\telse return 1;"));
	strings__Builder_writeln(&g->definitions, _SLIT("}\n"));
	v__gen__c__Gen_gen_array_sort_call(g, node, compare_fn);
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_array_sort_call(v__gen__c__Gen* g, v__ast__CallExpr node, string compare_fn) {
	string deref_field = (v__ast__Type_is_ptr(node.left_type) || v__ast__Type_is_pointer(node.left_type) ? (_SLIT("->")) : (_SLIT(".")));
	g->empty_line = true;
	v__gen__c__Gen_write(g, _SLIT("qsort("));
	v__gen__c__Gen_expr(g, node.left);
	v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = deref_field}}, {_SLIT("data, "), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_expr(g, node.left);
	v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = deref_field}}, {_SLIT("len, "), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_expr(g, node.left);
	v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = deref_field}}, {_SLIT("element_size, (int (*)(const void *, const void *))&"), 0xfe10, {.d_s = compare_fn}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_array_filter(v__gen__c__Gen* g, v__ast__CallExpr node) {
	string tmp = v__gen__c__Gen_new_tmp_var(g);
	string s = v__gen__c__Gen_go_before_stmt(g, 0);
	bool s_ends_with_ln = string_ends_with(s, _SLIT("\n"));
	s = string_trim_space(s);
	v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, node.return_type);
	if (sym->kind != v__ast__Kind__array) {
		v__gen__c__verror(_SLIT("filter() requires an array"));
		VUNREACHABLE();
	}
	v__ast__Array info = /* as */ *(v__ast__Array*)__as_cast((sym->info)._v__ast__Array,(sym->info)._typ, 441) /*expected idx: 441, name: v.ast.Array */ ;
	string styp = v__gen__c__Gen_typ(g, node.return_type);
	string elem_type_str = v__gen__c__Gen_typ(g, info.elem_type);
	g->empty_line = true;
	string noscan = v__gen__c__Gen_check_noscan(g, info.elem_type);
	v__gen__c__Gen_writeln(g,  str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = styp}}, {_SLIT(" "), 0xfe10, {.d_s = tmp}}, {_SLIT(" = __new_array"), 0xfe10, {.d_s = noscan}}, {_SLIT("(0, 0, sizeof("), 0xfe10, {.d_s = elem_type_str}}, {_SLIT("));"), 0, { .d_c = 0 }}})));
	bool has_infix_left_var_name = g->infix_left_var_name.len > 0;
	if (has_infix_left_var_name) {
		v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("if ("), 0xfe10, {.d_s = g->infix_left_var_name}}, {_SLIT(") {"), 0, { .d_c = 0 }}})));
		g->infix_left_var_name = _SLIT("");
		g->indent++;
	}
	v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__gen__c__Gen_typ(g, node.left_type)}}, {_SLIT(" "), 0xfe10, {.d_s = tmp}}, {_SLIT("_orig = "), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_expr(g, node.left);
	v__gen__c__Gen_writeln(g, _SLIT(";"));
	v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("int "), 0xfe10, {.d_s = tmp}}, {_SLIT("_len = "), 0xfe10, {.d_s = tmp}}, {_SLIT("_orig.len;"), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_writeln(g,  str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = tmp}}, {_SLIT(" = __new_array"), 0xfe10, {.d_s = noscan}}, {_SLIT("(0, "), 0xfe10, {.d_s = tmp}}, {_SLIT("_len, sizeof("), 0xfe10, {.d_s = elem_type_str}}, {_SLIT("));\n"), 0, { .d_c = 0 }}})));
	string i = v__gen__c__Gen_new_tmp_var(g);
	v__gen__c__Gen_writeln(g,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("for (int "), 0xfe10, {.d_s = i}}, {_SLIT(" = 0; "), 0xfe10, {.d_s = i}}, {_SLIT(" < "), 0xfe10, {.d_s = tmp}}, {_SLIT("_len; ++"), 0xfe10, {.d_s = i}}, {_SLIT(") {"), 0, { .d_c = 0 }}})));
	g->indent++;
	v__gen__c__Gen_writeln(g,  str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = elem_type_str}}, {_SLIT(" it = (("), 0xfe10, {.d_s = elem_type_str}}, {_SLIT("*) "), 0xfe10, {.d_s = tmp}}, {_SLIT("_orig.data)["), 0xfe10, {.d_s = i}}, {_SLIT("];"), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_set_current_pos_as_last_stmt_pos(g);
	bool is_embed_map_filter = false;
	v__ast__Expr expr = (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr;
	if (expr._typ == 278 /* v.ast.AnonFn */) {
		v__gen__c__Gen_write(g, _SLIT("if ("));
		v__gen__c__Gen_gen_anon_fn_decl(g, (voidptr)&/*qq*/(*expr._v__ast__AnonFn));
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = (*expr._v__ast__AnonFn).decl.name}}, {_SLIT("(it)"), 0, { .d_c = 0 }}})));
	}
	else if (expr._typ == 299 /* v.ast.Ident */) {
		v__gen__c__Gen_write(g, _SLIT("if ("));
		if ((*expr._v__ast__Ident).kind == v__ast__IdentKind__function) {
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__gen__c__c_name((*expr._v__ast__Ident).name)}}, {_SLIT("(it)"), 0, { .d_c = 0 }}})));
		} else if ((*expr._v__ast__Ident).kind == v__ast__IdentKind__variable) {
			v__ast__IdentVar var_info = v__ast__Ident_var_info(&(*expr._v__ast__Ident));
			v__ast__TypeSymbol* sym_t = v__ast__Table_sym(g->table, var_info.typ);
			if (sym_t->kind == v__ast__Kind__function) {
				v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__gen__c__c_name((*expr._v__ast__Ident).name)}}, {_SLIT("(it)"), 0, { .d_c = 0 }}})));
			} else {
				v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
			}
		} else {
			v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
		}
	}
	else if (expr._typ == 286 /* v.ast.CallExpr */) {
		if (string__eq((*expr._v__ast__CallExpr).name, _SLIT("map")) || string__eq((*expr._v__ast__CallExpr).name, _SLIT("filter")) || string__eq((*expr._v__ast__CallExpr).name, _SLIT("all")) || string__eq((*expr._v__ast__CallExpr).name, _SLIT("any"))) {
			is_embed_map_filter = true;
			v__gen__c__Gen_set_current_pos_as_last_stmt_pos(g);
		}
		v__gen__c__Gen_write(g, _SLIT("if ("));
		v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
	}
	
	else {
		v__gen__c__Gen_write(g, _SLIT("if ("));
		v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
	}
	;
	v__gen__c__Gen_writeln(g, _SLIT(") {"));
	v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\tarray_push"), 0xfe10, {.d_s = noscan}}, {_SLIT("((array*)&"), 0xfe10, {.d_s = tmp}}, {_SLIT(", &it);"), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_writeln(g, _SLIT("}"));
	g->indent--;
	v__gen__c__Gen_writeln(g, _SLIT("}"));
	if (!is_embed_map_filter) {
		v__gen__c__Gen_set_current_pos_as_last_stmt_pos(g);
	}
	if (has_infix_left_var_name) {
		g->indent--;
		v__gen__c__Gen_writeln(g, _SLIT("}"));
	}
	if (s_ends_with_ln) {
		v__gen__c__Gen_writeln(g, s);
	} else {
		v__gen__c__Gen_write(g, s);
	}
	v__gen__c__Gen_write(g, tmp);
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_array_insert(v__gen__c__Gen* g, v__ast__CallExpr node) {
	v__ast__TypeSymbol* left_sym = v__ast__Table_sym(g->table, node.left_type);
	v__ast__Array left_info = /* as */ *(v__ast__Array*)__as_cast((left_sym->info)._v__ast__Array,(left_sym->info)._typ, 441) /*expected idx: 441, name: v.ast.Array */ ;
	string elem_type_str = v__gen__c__Gen_typ(g, left_info.elem_type);
	v__ast__TypeSymbol* arg2_sym = v__ast__Table_sym(g->table, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 1)).typ);
	bool is_arg2_array = arg2_sym->kind == v__ast__Kind__array && v__ast__Type_alias_eq((*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 1)).typ, node.left_type);
	string noscan = v__gen__c__Gen_check_noscan(g, left_info.elem_type);
	if (is_arg2_array) {
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("array_insert_many"), 0xfe10, {.d_s = noscan}}, {_SLIT("(&"), 0, { .d_c = 0 }}})));
	} else {
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("array_insert"), 0xfe10, {.d_s = noscan}}, {_SLIT("(&"), 0, { .d_c = 0 }}})));
	}
	v__gen__c__Gen_expr(g, node.left);
	v__gen__c__Gen_write(g, _SLIT(", "));
	v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
	if (is_arg2_array) {
		v__gen__c__Gen_write(g, _SLIT(", "));
		v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 1)).expr);
		v__gen__c__Gen_write(g, _SLIT(".data, "));
		v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 1)).expr);
		v__gen__c__Gen_write(g, _SLIT(".len)"));
	} else {
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(", &("), 0xfe10, {.d_s = elem_type_str}}, {_SLIT("[]){"), 0, { .d_c = 0 }}})));
		if (v__ast__Type_alias_eq(left_info.elem_type, _const_v__ast__string_type)) {
			v__gen__c__Gen_write(g, _SLIT("string_clone("));
		}
		v__gen__c__Gen_expr_with_cast(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 1)).expr, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 1)).typ, left_info.elem_type);
		if (v__ast__Type_alias_eq(left_info.elem_type, _const_v__ast__string_type)) {
			v__gen__c__Gen_write(g, _SLIT(")"));
		}
		v__gen__c__Gen_write(g, _SLIT("})"));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_array_prepend(v__gen__c__Gen* g, v__ast__CallExpr node) {
	v__ast__TypeSymbol* left_sym = v__ast__Table_sym(g->table, node.left_type);
	v__ast__Array left_info = /* as */ *(v__ast__Array*)__as_cast((left_sym->info)._v__ast__Array,(left_sym->info)._typ, 441) /*expected idx: 441, name: v.ast.Array */ ;
	string elem_type_str = v__gen__c__Gen_typ(g, left_info.elem_type);
	v__ast__TypeSymbol* arg_sym = v__ast__Table_sym(g->table, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).typ);
	bool is_arg_array = arg_sym->kind == v__ast__Kind__array && v__ast__Type_alias_eq((*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).typ, node.left_type);
	string noscan = v__gen__c__Gen_check_noscan(g, left_info.elem_type);
	if (is_arg_array) {
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("array_prepend_many"), 0xfe10, {.d_s = noscan}}, {_SLIT("(&"), 0, { .d_c = 0 }}})));
	} else {
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("array_prepend"), 0xfe10, {.d_s = noscan}}, {_SLIT("(&"), 0, { .d_c = 0 }}})));
	}
	v__gen__c__Gen_expr(g, node.left);
	if (is_arg_array) {
		v__gen__c__Gen_write(g, _SLIT(", "));
		v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
		v__gen__c__Gen_write(g, _SLIT(".data, "));
		v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
		v__gen__c__Gen_write(g, _SLIT(".len)"));
	} else {
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(", &("), 0xfe10, {.d_s = elem_type_str}}, {_SLIT("[]){"), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_expr_with_cast(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).typ, left_info.elem_type);
		v__gen__c__Gen_write(g, _SLIT("})"));
	}
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_get_array_contains_method(v__gen__c__Gen* g, v__ast__Type typ) {
	int t = v__ast__Table_final_sym(g->table, v__ast__Type_set_nr_muls(v__gen__c__Gen_unwrap_generic(g, typ), 0))->idx;
	array_push((array*)&g->array_contains_types, _MOV((v__ast__Type[]){ t }));
	string _t2 = string__plus(v__gen__c__Gen_typ(g, t), _SLIT("_contains"));
	return _t2;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_array_contains_methods(v__gen__c__Gen* g) {
	Array_v__ast__Type done = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
	for (int _t1 = 0; _t1 < g->array_contains_types.len; ++_t1) {
		v__ast__Type t = ((v__ast__Type*)g->array_contains_types.data)[_t1];
		v__ast__TypeSymbol* left_final_sym = v__ast__Table_final_sym(g->table, t);
		if (Array_v__ast__Type_contains(done, left_final_sym->idx) || v__ast__TypeSymbol_has_method(v__ast__Table_sym(g->table, t), _SLIT("contains"))) {
			continue;
		}
		array_push((array*)&done, _MOV((v__ast__Type[]){ t }));
		string left_type_str = v__gen__c__Gen_typ(g, t);
		string fn_name =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = left_type_str}}, {_SLIT("_contains"), 0, { .d_c = 0 }}}));
		v__ast__Array left_info = /* as */ *(v__ast__Array*)__as_cast((left_final_sym->info)._v__ast__Array,(left_final_sym->info)._typ, 441) /*expected idx: 441, name: v.ast.Array */ ;
		string elem_type_str = v__gen__c__Gen_typ(g, left_info.elem_type);
		v__ast__TypeSymbol* elem_sym = v__ast__Table_sym(g->table, left_info.elem_type);
		if (elem_sym->kind == v__ast__Kind__function) {
			left_type_str = _SLIT("Array_voidptr");
			elem_type_str = _SLIT("voidptr");
		}
		strings__Builder_writeln(&g->type_definitions,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("static bool "), 0xfe10, {.d_s = fn_name}}, {_SLIT("("), 0xfe10, {.d_s = left_type_str}}, {_SLIT(" a, "), 0xfe10, {.d_s = elem_type_str}}, {_SLIT(" v); // auto"), 0, { .d_c = 0 }}})));
		strings__Builder fn_builder = strings__new_builder(512);
		strings__Builder_writeln(&fn_builder,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("static bool "), 0xfe10, {.d_s = fn_name}}, {_SLIT("("), 0xfe10, {.d_s = left_type_str}}, {_SLIT(" a, "), 0xfe10, {.d_s = elem_type_str}}, {_SLIT(" v) {"), 0, { .d_c = 0 }}})));
		strings__Builder_writeln(&fn_builder, _SLIT("\tfor (int i = 0; i < a.len; ++i) {"));
		if (elem_sym->kind == v__ast__Kind__string) {
			strings__Builder_writeln(&fn_builder, _SLIT("\t\tif (fast_string_eq(((string*)a.data)[i], v)) {"));
		} else if (elem_sym->kind == v__ast__Kind__array && v__ast__Type_nr_muls(left_info.elem_type) == 0) {
			string ptr_typ = v__gen__c__Gen_equality_fn(g, left_info.elem_type);
			strings__Builder_writeln(&fn_builder,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\tif ("), 0xfe10, {.d_s = ptr_typ}}, {_SLIT("_arr_eq((("), 0xfe10, {.d_s = elem_type_str}}, {_SLIT("*)a.data)[i], v)) {"), 0, { .d_c = 0 }}})));
		} else if (elem_sym->kind == v__ast__Kind__function) {
			strings__Builder_writeln(&fn_builder, _SLIT("\t\tif (((voidptr*)a.data)[i] == v) {"));
		} else if (elem_sym->kind == v__ast__Kind__map && v__ast__Type_nr_muls(left_info.elem_type) == 0) {
			string ptr_typ = v__gen__c__Gen_equality_fn(g, left_info.elem_type);
			strings__Builder_writeln(&fn_builder,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\tif ("), 0xfe10, {.d_s = ptr_typ}}, {_SLIT("_map_eq((("), 0xfe10, {.d_s = elem_type_str}}, {_SLIT("*)a.data)[i], v)) {"), 0, { .d_c = 0 }}})));
		} else if (elem_sym->kind == v__ast__Kind__struct_ && v__ast__Type_nr_muls(left_info.elem_type) == 0) {
			string ptr_typ = v__gen__c__Gen_equality_fn(g, left_info.elem_type);
			strings__Builder_writeln(&fn_builder,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\tif ("), 0xfe10, {.d_s = ptr_typ}}, {_SLIT("_struct_eq((("), 0xfe10, {.d_s = elem_type_str}}, {_SLIT("*)a.data)[i], v)) {"), 0, { .d_c = 0 }}})));
		} else if (elem_sym->kind == v__ast__Kind__interface_ && v__ast__Type_nr_muls(left_info.elem_type) == 0) {
			string ptr_typ = v__gen__c__Gen_equality_fn(g, left_info.elem_type);
			strings__Builder_writeln(&fn_builder,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\tif ("), 0xfe10, {.d_s = ptr_typ}}, {_SLIT("_interface_eq((("), 0xfe10, {.d_s = elem_type_str}}, {_SLIT("*)a.data)[i], v)) {"), 0, { .d_c = 0 }}})));
		} else if (elem_sym->kind == v__ast__Kind__sum_type && v__ast__Type_nr_muls(left_info.elem_type) == 0) {
			string ptr_typ = v__gen__c__Gen_equality_fn(g, left_info.elem_type);
			strings__Builder_writeln(&fn_builder,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\tif ("), 0xfe10, {.d_s = ptr_typ}}, {_SLIT("_sumtype_eq((("), 0xfe10, {.d_s = elem_type_str}}, {_SLIT("*)a.data)[i], v)) {"), 0, { .d_c = 0 }}})));
		} else {
			strings__Builder_writeln(&fn_builder,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\tif ((("), 0xfe10, {.d_s = elem_type_str}}, {_SLIT("*)a.data)[i] == v) {"), 0, { .d_c = 0 }}})));
		}
		strings__Builder_writeln(&fn_builder, _SLIT("\t\t\treturn true;"));
		strings__Builder_writeln(&fn_builder, _SLIT("\t\t}"));
		strings__Builder_writeln(&fn_builder, _SLIT("\t}"));
		strings__Builder_writeln(&fn_builder, _SLIT("\treturn false;"));
		strings__Builder_writeln(&fn_builder, _SLIT("}"));
		array_push((array*)&g->auto_fn_definitions, _MOV((string[]){ string_clone(strings__Builder_str(&fn_builder)) }));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_array_contains(v__gen__c__Gen* g, v__ast__Type typ, v__ast__Expr left, v__ast__Expr right) {
	string fn_name = v__gen__c__Gen_get_array_contains_method(g, typ);
	v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = fn_name}}, {_SLIT("("), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_write(g, strings__repeat('*', v__ast__Type_nr_muls(typ)));
	if (v__ast__Type_share(typ) == v__ast__ShareType__shared_t) {
		strings__Builder_go_back(&g->out, 1);
	}
	v__gen__c__Gen_expr(g, left);
	if (v__ast__Type_share(typ) == v__ast__ShareType__shared_t) {
		v__gen__c__Gen_write(g, _SLIT("->val"));
	}
	v__gen__c__Gen_write(g, _SLIT(", "));
	v__gen__c__Gen_expr(g, right);
	v__gen__c__Gen_write(g, _SLIT(")"));
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_get_array_index_method(v__gen__c__Gen* g, v__ast__Type typ) {
	v__ast__Type t = v__ast__Type_set_nr_muls(v__gen__c__Gen_unwrap_generic(g, typ), 0);
	array_push((array*)&g->array_index_types, _MOV((v__ast__Type[]){ t }));
	string _t2 = string__plus(v__gen__c__Gen_typ(g, t), _SLIT("_index"));
	return _t2;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_array_index_methods(v__gen__c__Gen* g) {
	Array_v__ast__Type done = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
	for (int _t1 = 0; _t1 < g->array_index_types.len; ++_t1) {
		v__ast__Type t = ((v__ast__Type*)g->array_index_types.data)[_t1];
		if (Array_v__ast__Type_contains(done, t) || v__ast__TypeSymbol_has_method(v__ast__Table_sym(g->table, t), _SLIT("index"))) {
			continue;
		}
		array_push((array*)&done, _MOV((v__ast__Type[]){ t }));
		v__ast__TypeSymbol* final_left_sym = v__ast__Table_final_sym(g->table, t);
		string left_type_str = v__gen__c__Gen_typ(g, t);
		string fn_name =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = left_type_str}}, {_SLIT("_index"), 0, { .d_c = 0 }}}));
		v__ast__Array info = /* as */ *(v__ast__Array*)__as_cast((final_left_sym->info)._v__ast__Array,(final_left_sym->info)._typ, 441) /*expected idx: 441, name: v.ast.Array */ ;
		string elem_type_str = v__gen__c__Gen_typ(g, info.elem_type);
		v__ast__TypeSymbol* elem_sym = v__ast__Table_sym(g->table, info.elem_type);
		if (elem_sym->kind == v__ast__Kind__function) {
			left_type_str = _SLIT("Array_voidptr");
			elem_type_str = _SLIT("voidptr");
		}
		strings__Builder_writeln(&g->type_definitions,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("static int "), 0xfe10, {.d_s = fn_name}}, {_SLIT("("), 0xfe10, {.d_s = left_type_str}}, {_SLIT(" a, "), 0xfe10, {.d_s = elem_type_str}}, {_SLIT(" v); // auto"), 0, { .d_c = 0 }}})));
		strings__Builder fn_builder = strings__new_builder(512);
		strings__Builder_writeln(&fn_builder,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("static int "), 0xfe10, {.d_s = fn_name}}, {_SLIT("("), 0xfe10, {.d_s = left_type_str}}, {_SLIT(" a, "), 0xfe10, {.d_s = elem_type_str}}, {_SLIT(" v) {"), 0, { .d_c = 0 }}})));
		strings__Builder_writeln(&fn_builder,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = elem_type_str}}, {_SLIT("* pelem = a.data;"), 0, { .d_c = 0 }}})));
		strings__Builder_writeln(&fn_builder, _SLIT("\tfor (int i = 0; i < a.len; ++i, ++pelem) {"));
		if (elem_sym->kind == v__ast__Kind__string) {
			strings__Builder_writeln(&fn_builder, _SLIT("\t\tif (fast_string_eq(*pelem, v)) {"));
		} else if (elem_sym->kind == v__ast__Kind__array && !v__ast__Type_is_ptr(info.elem_type)) {
			string ptr_typ = v__gen__c__Gen_equality_fn(g, info.elem_type);
			strings__Builder_writeln(&fn_builder,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\tif ("), 0xfe10, {.d_s = ptr_typ}}, {_SLIT("_arr_eq(*pelem, v)) {"), 0, { .d_c = 0 }}})));
		} else if (elem_sym->kind == v__ast__Kind__function && !v__ast__Type_is_ptr(info.elem_type)) {
			strings__Builder_writeln(&fn_builder, _SLIT("\t\tif ( pelem == v) {"));
		} else if (elem_sym->kind == v__ast__Kind__map && !v__ast__Type_is_ptr(info.elem_type)) {
			string ptr_typ = v__gen__c__Gen_equality_fn(g, info.elem_type);
			strings__Builder_writeln(&fn_builder,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\tif ("), 0xfe10, {.d_s = ptr_typ}}, {_SLIT("_map_eq((*pelem, v))) {"), 0, { .d_c = 0 }}})));
		} else if (elem_sym->kind == v__ast__Kind__struct_ && !v__ast__Type_is_ptr(info.elem_type)) {
			string ptr_typ = v__gen__c__Gen_equality_fn(g, info.elem_type);
			strings__Builder_writeln(&fn_builder,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\tif ("), 0xfe10, {.d_s = ptr_typ}}, {_SLIT("_struct_eq(*pelem, v)) {"), 0, { .d_c = 0 }}})));
		} else if (elem_sym->kind == v__ast__Kind__interface_) {
			string ptr_typ = v__gen__c__Gen_equality_fn(g, info.elem_type);
			strings__Builder_writeln(&fn_builder,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\tif ("), 0xfe10, {.d_s = ptr_typ}}, {_SLIT("_interface_eq(*pelem, v)) {"), 0, { .d_c = 0 }}})));
		} else if (elem_sym->kind == v__ast__Kind__sum_type) {
			string ptr_typ = v__gen__c__Gen_equality_fn(g, info.elem_type);
			strings__Builder_writeln(&fn_builder,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\tif ("), 0xfe10, {.d_s = ptr_typ}}, {_SLIT("_sumtype_eq(*pelem, v)) {"), 0, { .d_c = 0 }}})));
		} else {
			strings__Builder_writeln(&fn_builder, _SLIT("\t\tif (*pelem == v) {"));
		}
		strings__Builder_writeln(&fn_builder, _SLIT("\t\t\treturn i;"));
		strings__Builder_writeln(&fn_builder, _SLIT("\t\t}"));
		strings__Builder_writeln(&fn_builder, _SLIT("\t}"));
		strings__Builder_writeln(&fn_builder, _SLIT("\treturn -1;"));
		strings__Builder_writeln(&fn_builder, _SLIT("}"));
		array_push((array*)&g->auto_fn_definitions, _MOV((string[]){ string_clone(strings__Builder_str(&fn_builder)) }));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_array_index(v__gen__c__Gen* g, v__ast__CallExpr node) {
	string fn_name = v__gen__c__Gen_get_array_index_method(g, node.left_type);
	v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = fn_name}}, {_SLIT("("), 0, { .d_c = 0 }}})));
	if (v__ast__Type_is_ptr(node.left_type)) {
		v__gen__c__Gen_write(g, _SLIT("*"));
	}
	v__gen__c__Gen_expr(g, node.left);
	v__gen__c__Gen_write(g, _SLIT(", "));
	if (v__ast__Expr_is_auto_deref_var((*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr)) {
		v__gen__c__Gen_write(g, _SLIT("*"));
	}
	v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
	v__gen__c__Gen_write(g, _SLIT(")"));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_array_wait(v__gen__c__Gen* g, v__ast__CallExpr node) {
	v__ast__TypeSymbol* arr = v__ast__Table_sym(g->table, node.receiver_type);
	v__ast__Type thread_type = v__ast__TypeSymbol_array_info(arr).elem_type;
	v__ast__TypeSymbol* thread_sym = v__ast__Table_sym(g->table, thread_type);
	v__ast__Type thread_ret_type = v__ast__TypeSymbol_thread_info(thread_sym).return_type;
	string eltyp = v__ast__Table_sym(g->table, thread_ret_type)->cname;
	string fn_name = v__gen__c__Gen_register_thread_array_wait_call(g, eltyp);
	v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = fn_name}}, {_SLIT("("), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_expr(g, node.left);
	v__gen__c__Gen_write(g, _SLIT(")"));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_array_any(v__gen__c__Gen* g, v__ast__CallExpr node) {
	string tmp = v__gen__c__Gen_new_tmp_var(g);
	string s = v__gen__c__Gen_go_before_stmt(g, 0);
	bool s_ends_with_ln = string_ends_with(s, _SLIT("\n"));
	s = string_trim_space(s);
	v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, node.left_type);
	v__ast__Array info = /* as */ *(v__ast__Array*)__as_cast((sym->info)._v__ast__Array,(sym->info)._typ, 441) /*expected idx: 441, name: v.ast.Array */ ;
	string elem_type_str = v__gen__c__Gen_typ(g, info.elem_type);
	g->empty_line = true;
	v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("bool "), 0xfe10, {.d_s = tmp}}, {_SLIT(" = false;"), 0, { .d_c = 0 }}})));
	bool has_infix_left_var_name = g->infix_left_var_name.len > 0;
	if (has_infix_left_var_name) {
		v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("if ("), 0xfe10, {.d_s = g->infix_left_var_name}}, {_SLIT(") {"), 0, { .d_c = 0 }}})));
		g->infix_left_var_name = _SLIT("");
		g->indent++;
	}
	v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__gen__c__Gen_typ(g, node.left_type)}}, {_SLIT(" "), 0xfe10, {.d_s = tmp}}, {_SLIT("_orig = "), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_expr(g, node.left);
	v__gen__c__Gen_writeln(g, _SLIT(";"));
	v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("int "), 0xfe10, {.d_s = tmp}}, {_SLIT("_len = "), 0xfe10, {.d_s = tmp}}, {_SLIT("_orig.len;"), 0, { .d_c = 0 }}})));
	string i = v__gen__c__Gen_new_tmp_var(g);
	v__gen__c__Gen_writeln(g,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("for (int "), 0xfe10, {.d_s = i}}, {_SLIT(" = 0; "), 0xfe10, {.d_s = i}}, {_SLIT(" < "), 0xfe10, {.d_s = tmp}}, {_SLIT("_len; ++"), 0xfe10, {.d_s = i}}, {_SLIT(") {"), 0, { .d_c = 0 }}})));
	g->indent++;
	v__gen__c__Gen_writeln(g,  str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = elem_type_str}}, {_SLIT(" it = (("), 0xfe10, {.d_s = elem_type_str}}, {_SLIT("*) "), 0xfe10, {.d_s = tmp}}, {_SLIT("_orig.data)["), 0xfe10, {.d_s = i}}, {_SLIT("];"), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_set_current_pos_as_last_stmt_pos(g);
	bool is_embed_map_filter = false;
	v__ast__Expr expr = (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr;
	if (expr._typ == 278 /* v.ast.AnonFn */) {
		v__gen__c__Gen_write(g, _SLIT("if ("));
		v__gen__c__Gen_gen_anon_fn_decl(g, (voidptr)&/*qq*/(*expr._v__ast__AnonFn));
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = (*expr._v__ast__AnonFn).decl.name}}, {_SLIT("(it)"), 0, { .d_c = 0 }}})));
	}
	else if (expr._typ == 299 /* v.ast.Ident */) {
		v__gen__c__Gen_write(g, _SLIT("if ("));
		if ((*expr._v__ast__Ident).kind == v__ast__IdentKind__function) {
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__gen__c__c_name((*expr._v__ast__Ident).name)}}, {_SLIT("(it)"), 0, { .d_c = 0 }}})));
		} else if ((*expr._v__ast__Ident).kind == v__ast__IdentKind__variable) {
			v__ast__IdentVar var_info = v__ast__Ident_var_info(&(*expr._v__ast__Ident));
			v__ast__TypeSymbol* sym_t = v__ast__Table_sym(g->table, var_info.typ);
			if (sym_t->kind == v__ast__Kind__function) {
				v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__gen__c__c_name((*expr._v__ast__Ident).name)}}, {_SLIT("(it)"), 0, { .d_c = 0 }}})));
			} else {
				v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
			}
		} else {
			v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
		}
	}
	else if (expr._typ == 286 /* v.ast.CallExpr */) {
		if (string__eq((*expr._v__ast__CallExpr).name, _SLIT("map")) || string__eq((*expr._v__ast__CallExpr).name, _SLIT("filter")) || string__eq((*expr._v__ast__CallExpr).name, _SLIT("all")) || string__eq((*expr._v__ast__CallExpr).name, _SLIT("any"))) {
			is_embed_map_filter = true;
			v__gen__c__Gen_set_current_pos_as_last_stmt_pos(g);
		}
		v__gen__c__Gen_write(g, _SLIT("if ("));
		v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
	}
	
	else {
		v__gen__c__Gen_write(g, _SLIT("if ("));
		v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
	}
	;
	v__gen__c__Gen_writeln(g, _SLIT(") {"));
	v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = tmp}}, {_SLIT(" = true;"), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_writeln(g, _SLIT("\tbreak;"));
	v__gen__c__Gen_writeln(g, _SLIT("}"));
	g->indent--;
	v__gen__c__Gen_writeln(g, _SLIT("}"));
	if (!is_embed_map_filter) {
		v__gen__c__Gen_set_current_pos_as_last_stmt_pos(g);
	}
	if (has_infix_left_var_name) {
		g->indent--;
		v__gen__c__Gen_writeln(g, _SLIT("}"));
	}
	if (s_ends_with_ln) {
		v__gen__c__Gen_writeln(g, s);
	} else {
		v__gen__c__Gen_write(g, s);
	}
	v__gen__c__Gen_write(g, tmp);
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_array_all(v__gen__c__Gen* g, v__ast__CallExpr node) {
	string tmp = v__gen__c__Gen_new_tmp_var(g);
	string s = v__gen__c__Gen_go_before_stmt(g, 0);
	bool s_ends_with_ln = string_ends_with(s, _SLIT("\n"));
	s = string_trim_space(s);
	v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, node.left_type);
	v__ast__Array info = /* as */ *(v__ast__Array*)__as_cast((sym->info)._v__ast__Array,(sym->info)._typ, 441) /*expected idx: 441, name: v.ast.Array */ ;
	string elem_type_str = v__gen__c__Gen_typ(g, info.elem_type);
	g->empty_line = true;
	v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("bool "), 0xfe10, {.d_s = tmp}}, {_SLIT(" = true;"), 0, { .d_c = 0 }}})));
	bool has_infix_left_var_name = g->infix_left_var_name.len > 0;
	if (has_infix_left_var_name) {
		v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("if ("), 0xfe10, {.d_s = g->infix_left_var_name}}, {_SLIT(") {"), 0, { .d_c = 0 }}})));
		g->infix_left_var_name = _SLIT("");
		g->indent++;
	}
	v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__gen__c__Gen_typ(g, node.left_type)}}, {_SLIT(" "), 0xfe10, {.d_s = tmp}}, {_SLIT("_orig = "), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_expr(g, node.left);
	v__gen__c__Gen_writeln(g, _SLIT(";"));
	v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("int "), 0xfe10, {.d_s = tmp}}, {_SLIT("_len = "), 0xfe10, {.d_s = tmp}}, {_SLIT("_orig.len;"), 0, { .d_c = 0 }}})));
	string i = v__gen__c__Gen_new_tmp_var(g);
	v__gen__c__Gen_writeln(g,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("for (int "), 0xfe10, {.d_s = i}}, {_SLIT(" = 0; "), 0xfe10, {.d_s = i}}, {_SLIT(" < "), 0xfe10, {.d_s = tmp}}, {_SLIT("_len; ++"), 0xfe10, {.d_s = i}}, {_SLIT(") {"), 0, { .d_c = 0 }}})));
	g->indent++;
	v__gen__c__Gen_writeln(g,  str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = elem_type_str}}, {_SLIT(" it = (("), 0xfe10, {.d_s = elem_type_str}}, {_SLIT("*) "), 0xfe10, {.d_s = tmp}}, {_SLIT("_orig.data)["), 0xfe10, {.d_s = i}}, {_SLIT("];"), 0, { .d_c = 0 }}})));
	g->empty_line = true;
	v__gen__c__Gen_set_current_pos_as_last_stmt_pos(g);
	bool is_embed_map_filter = false;
	v__ast__Expr expr = (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr;
	if (expr._typ == 278 /* v.ast.AnonFn */) {
		v__gen__c__Gen_write(g, _SLIT("if (!("));
		v__gen__c__Gen_gen_anon_fn_decl(g, (voidptr)&/*qq*/(*expr._v__ast__AnonFn));
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = (*expr._v__ast__AnonFn).decl.name}}, {_SLIT("(it)"), 0, { .d_c = 0 }}})));
	}
	else if (expr._typ == 299 /* v.ast.Ident */) {
		v__gen__c__Gen_write(g, _SLIT("if (!("));
		if ((*expr._v__ast__Ident).kind == v__ast__IdentKind__function) {
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__gen__c__c_name((*expr._v__ast__Ident).name)}}, {_SLIT("(it)"), 0, { .d_c = 0 }}})));
		} else if ((*expr._v__ast__Ident).kind == v__ast__IdentKind__variable) {
			v__ast__IdentVar var_info = v__ast__Ident_var_info(&(*expr._v__ast__Ident));
			v__ast__TypeSymbol* sym_t = v__ast__Table_sym(g->table, var_info.typ);
			if (sym_t->kind == v__ast__Kind__function) {
				v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__gen__c__c_name((*expr._v__ast__Ident).name)}}, {_SLIT("(it)"), 0, { .d_c = 0 }}})));
			} else {
				v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
			}
		} else {
			v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
		}
	}
	else if (expr._typ == 286 /* v.ast.CallExpr */) {
		if (string__eq((*expr._v__ast__CallExpr).name, _SLIT("map")) || string__eq((*expr._v__ast__CallExpr).name, _SLIT("filter")) || string__eq((*expr._v__ast__CallExpr).name, _SLIT("all")) || string__eq((*expr._v__ast__CallExpr).name, _SLIT("any"))) {
			is_embed_map_filter = true;
			v__gen__c__Gen_set_current_pos_as_last_stmt_pos(g);
		}
		v__gen__c__Gen_write(g, _SLIT("if (!("));
		v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
	}
	
	else {
		v__gen__c__Gen_write(g, _SLIT("if (!("));
		v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
	}
	;
	v__gen__c__Gen_writeln(g, _SLIT(")) {"));
	v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = tmp}}, {_SLIT(" = false;"), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_writeln(g, _SLIT("\tbreak;"));
	v__gen__c__Gen_writeln(g, _SLIT("}"));
	g->indent--;
	v__gen__c__Gen_writeln(g, _SLIT("}"));
	if (!is_embed_map_filter) {
		v__gen__c__Gen_set_current_pos_as_last_stmt_pos(g);
	}
	if (has_infix_left_var_name) {
		g->indent--;
		v__gen__c__Gen_writeln(g, _SLIT("}"));
	}
	if (s_ends_with_ln) {
		v__gen__c__Gen_writeln(g, s);
	} else {
		v__gen__c__Gen_write(g, s);
	}
	v__gen__c__Gen_write(g, tmp);
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_assert_stmt(v__gen__c__Gen* g, v__ast__AssertStmt original_assert_statement) {
	if (!original_assert_statement.is_used) {
		return;
	}
	v__ast__AssertStmt node = original_assert_statement;
	v__gen__c__Gen_writeln(g, _SLIT("// assert"));
	if ((node.expr)._typ == 303 /* v.ast.InfixExpr */) {
		Option_v__ast__Expr _t1;
		if (_t1 = v__gen__c__Gen_assert_subexpression_to_ctemp(g, (*node.expr._v__ast__InfixExpr).left, (*node.expr._v__ast__InfixExpr).left_type), _t1.state == 0) {
			v__ast__Expr subst_expr = *(v__ast__Expr*)_t1.data;
			(*node.expr._v__ast__InfixExpr).left = subst_expr;
		}
		Option_v__ast__Expr _t2;
		if (_t2 = v__gen__c__Gen_assert_subexpression_to_ctemp(g, (*node.expr._v__ast__InfixExpr).right, (*node.expr._v__ast__InfixExpr).right_type), _t2.state == 0) {
			v__ast__Expr subst_expr = *(v__ast__Expr*)_t2.data;
			(*node.expr._v__ast__InfixExpr).right = subst_expr;
		}
	}
	g->inside_ternary++;
	if (g->pref->is_test) {
		v__gen__c__Gen_write(g, _SLIT("if ("));
		v__gen__c__Gen_expr(g, node.expr);
		v__gen__c__Gen_write(g, _SLIT(")"));
		v__gen__c__Gen_decrement_inside_ternary(g);
		v__gen__c__Gen_writeln(g, _SLIT(" {"));
		string metaname_ok = v__gen__c__Gen_gen_assert_metainfo(g, node);
		v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\tmain__TestRunner_name_table[test_runner._typ]._method_assert_pass(test_runner._object, &"), 0xfe10, {.d_s = metaname_ok}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_writeln(g, _SLIT("} else {"));
		string metaname_fail = v__gen__c__Gen_gen_assert_metainfo(g, node);
		v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\tmain__TestRunner_name_table[test_runner._typ]._method_assert_fail(test_runner._object, &"), 0xfe10, {.d_s = metaname_fail}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_gen_assert_postfailure_mode(g, node);
		v__gen__c__Gen_writeln(g, _SLIT("\tlongjmp(g_jump_buffer, 1);"));
		v__gen__c__Gen_writeln(g, _SLIT("\t// TODO"));
		v__gen__c__Gen_writeln(g, _SLIT("\t// Maybe print all vars in a test function if it fails?"));
		v__gen__c__Gen_writeln(g, _SLIT("}"));
	} else {
		v__gen__c__Gen_write(g, _SLIT("if (!("));
		v__gen__c__Gen_expr(g, node.expr);
		v__gen__c__Gen_write(g, _SLIT("))"));
		v__gen__c__Gen_decrement_inside_ternary(g);
		v__gen__c__Gen_writeln(g, _SLIT(" {"));
		string metaname_panic = v__gen__c__Gen_gen_assert_metainfo(g, node);
		v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t__print_assert_failure(&"), 0xfe10, {.d_s = metaname_panic}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_gen_assert_postfailure_mode(g, node);
		v__gen__c__Gen_writeln(g, _SLIT("\t_v_panic(_SLIT(\"Assertion failed...\"));"));
		v__gen__c__Gen_writeln(g, _SLIT("}"));
	}
}

VV_LOCAL_SYMBOL Option_v__ast__Expr v__gen__c__Gen_assert_subexpression_to_ctemp(v__gen__c__Gen* g, v__ast__Expr expr, v__ast__Type expr_type) {
	if (expr._typ == 286 /* v.ast.CallExpr */) {
		Option_v__ast__Expr _t1;
		opt_ok(&(v__ast__Expr[]) { v__ast__CTempVar_to_sumtype_v__ast__Expr(ADDR(v__ast__CTempVar, (v__gen__c__Gen_new_ctemp_var_then_gen(g, expr, expr_type)))) }, (Option*)(&_t1), sizeof(v__ast__Expr));
		return _t1;
	}
	else if (expr._typ == 314 /* v.ast.ParExpr */) {
		if (((*expr._v__ast__ParExpr).expr)._typ == 286 /* v.ast.CallExpr */) {
			Option_v__ast__Expr _t2;
			opt_ok(&(v__ast__Expr[]) { v__ast__CTempVar_to_sumtype_v__ast__Expr(ADDR(v__ast__CTempVar, (v__gen__c__Gen_new_ctemp_var_then_gen(g, (*expr._v__ast__ParExpr).expr, expr_type)))) }, (Option*)(&_t2), sizeof(v__ast__Expr));
			return _t2;
		}
	}
	else if (expr._typ == 319 /* v.ast.SelectorExpr */) {
		if (((*expr._v__ast__SelectorExpr).expr)._typ == 286 /* v.ast.CallExpr */) {
			v__ast__TypeSymbol* sym = v__ast__Table_final_sym(g->table, v__gen__c__Gen_unwrap_generic(g, (*(*expr._v__ast__SelectorExpr).expr._v__ast__CallExpr).return_type));
			if (sym->kind == v__ast__Kind__struct_) {
				if ((/* as */ *(v__ast__Struct*)__as_cast((sym->info)._v__ast__Struct,(sym->info)._typ, 446) /*expected idx: 446, name: v.ast.Struct */ ).is_union) {
					return (Option_v__ast__Expr){ .state=2, .err=_const_v__gen__c__unsupported_ctemp_assert_transform, .data={EMPTY_STRUCT_INITIALIZATION} };
				}
			}
			Option_v__ast__Expr _t4;
			opt_ok(&(v__ast__Expr[]) { v__ast__CTempVar_to_sumtype_v__ast__Expr(ADDR(v__ast__CTempVar, (v__gen__c__Gen_new_ctemp_var_then_gen(g, expr, expr_type)))) }, (Option*)(&_t4), sizeof(v__ast__Expr));
			return _t4;
		}
	}
	
	else {
	}
	;
	return (Option_v__ast__Expr){ .state=2, .err=_const_v__gen__c__unsupported_ctemp_assert_transform, .data={EMPTY_STRUCT_INITIALIZATION} };
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_assert_postfailure_mode(v__gen__c__Gen* g, v__ast__AssertStmt node) {
	v__gen__c__Gen_write_v_source_line_info(g, node.pos);

	if (g->pref->assert_failure_mode == (v__pref__AssertFailureMode__default)) {
	}
	else if (g->pref->assert_failure_mode == (v__pref__AssertFailureMode__aborts)) {
		v__gen__c__Gen_writeln(g, _SLIT("\tabort();"));
	}
	else if (g->pref->assert_failure_mode == (v__pref__AssertFailureMode__backtraces)) {
		v__gen__c__Gen_writeln(g, _SLIT("\tprint_backtrace();"));
	};
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_gen_assert_metainfo(v__gen__c__Gen* g, v__ast__AssertStmt node) {
	string mod_path = v__gen__c__cestring(g->file->path);
	string fn_name = g->fn_decl->name;
	int line_nr = node.pos.line_nr;
	string src = v__gen__c__cestring(v__ast__Expr_str(node.expr));
	string metaname =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("v_assert_meta_info_"), 0xfe10, {.d_s = v__gen__c__Gen_new_tmp_var(g)}}, {_SLIT0, 0, { .d_c = 0 }}}));
	v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\tVAssertMetaInfo "), 0xfe10, {.d_s = metaname}}, {_SLIT(" = {0};"), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = metaname}}, {_SLIT(".fpath = "), 0xfe10, {.d_s = v__gen__c__ctoslit(mod_path)}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = metaname}}, {_SLIT(".line_nr = "), 0xfe07, {.d_i32 = line_nr}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = metaname}}, {_SLIT(".fn_name = "), 0xfe10, {.d_s = v__gen__c__ctoslit(fn_name)}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
	string metasrc = v__gen__c__cnewlines(v__gen__c__ctoslit(src));
	v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = metaname}}, {_SLIT(".src = "), 0xfe10, {.d_s = metasrc}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
	if (node.expr._typ == 303 /* v.ast.InfixExpr */) {
		string expr_op_str = v__gen__c__ctoslit(v__token__Kind_str((*node.expr._v__ast__InfixExpr).op));
		string expr_left_str = v__gen__c__cnewlines(v__gen__c__ctoslit(v__ast__Expr_str((*node.expr._v__ast__InfixExpr).left)));
		string expr_right_str = v__gen__c__cnewlines(v__gen__c__ctoslit(v__ast__Expr_str((*node.expr._v__ast__InfixExpr).right)));
		v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = metaname}}, {_SLIT(".op = "), 0xfe10, {.d_s = expr_op_str}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = metaname}}, {_SLIT(".llabel = "), 0xfe10, {.d_s = expr_left_str}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = metaname}}, {_SLIT(".rlabel = "), 0xfe10, {.d_s = expr_right_str}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = metaname}}, {_SLIT(".lvalue = "), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_gen_assert_single_expr(g, (*node.expr._v__ast__InfixExpr).left, (*node.expr._v__ast__InfixExpr).left_type);
		v__gen__c__Gen_writeln(g, _SLIT(";"));
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = metaname}}, {_SLIT(".rvalue = "), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_gen_assert_single_expr(g, (*node.expr._v__ast__InfixExpr).right, (*node.expr._v__ast__InfixExpr).right_type);
		v__gen__c__Gen_writeln(g, _SLIT(";"));
	}
	else if (node.expr._typ == 286 /* v.ast.CallExpr */) {
		v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = metaname}}, {_SLIT(".op = _SLIT(\"call\");"), 0, { .d_c = 0 }}})));
	}
	
	else {
	}
	;
	string _t1 = metaname;
	return _t1;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_assert_single_expr(v__gen__c__Gen* g, v__ast__Expr expr, v__ast__Type typ) {
	string unknown_value = _SLIT("*unknown value*");
	if (expr._typ == 287 /* v.ast.CastExpr */) {
		v__gen__c__Gen_write(g, v__gen__c__ctoslit(unknown_value));
	}
	else if (expr._typ == 300 /* v.ast.IfExpr */) {
		v__gen__c__Gen_write(g, v__gen__c__ctoslit(unknown_value));
	}
	else if (expr._typ == 302 /* v.ast.IndexExpr */) {
		v__gen__c__Gen_write(g, v__gen__c__ctoslit(unknown_value));
	}
	else if (expr._typ == 309 /* v.ast.MatchExpr */) {
		v__gen__c__Gen_write(g, v__gen__c__ctoslit(unknown_value));
	}
	else if (expr._typ == 316 /* v.ast.PrefixExpr */) {
		if (((*expr._v__ast__PrefixExpr).right)._typ == 287 /* v.ast.CastExpr */) {
			v__gen__c__Gen_write(g, v__gen__c__ctoslit(unknown_value));
		} else {
			v__gen__c__Gen_gen_expr_to_string(g, expr, typ);
		}
	}
	else if (expr._typ == 325 /* v.ast.TypeNode */) {
		v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, v__gen__c__Gen_unwrap_generic(g, typ));
		v__gen__c__Gen_write(g, v__gen__c__ctoslit( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = sym->name}}, {_SLIT0, 0, { .d_c = 0 }}}))));
	}
	
	else {
		bool should_clone = true;
		if (v__ast__Type_alias_eq(typ, _const_v__ast__string_type) && (expr)._typ == 323 /* v.ast.StringLiteral */) {
			should_clone = false;
		}
		if ((expr)._typ == 285 /* v.ast.CTempVar */) {
			if (((*expr._v__ast__CTempVar).orig)._typ == 286 /* v.ast.CallExpr */) {
				should_clone = false;
				if ((*(*expr._v__ast__CTempVar).orig._v__ast__CallExpr).or_block.kind == v__ast__OrKind__propagate) {
					should_clone = true;
				}
				if ((*(*expr._v__ast__CTempVar).orig._v__ast__CallExpr).is_method && (*(*expr._v__ast__CTempVar).orig._v__ast__CallExpr).args.len == 0 && string__eq((*(*expr._v__ast__CTempVar).orig._v__ast__CallExpr).name, _SLIT("type_name"))) {
					should_clone = true;
				}
			}
		}
		if (should_clone) {
			v__gen__c__Gen_write(g, _SLIT("string_clone("));
		}
		v__gen__c__Gen_gen_expr_to_string(g, expr, typ);
		if (should_clone) {
			v__gen__c__Gen_write(g, _SLIT(")"));
		}
	}
	;
	v__gen__c__Gen_write(g, string__plus(string__plus(string__plus(string__plus(_SLIT(" /* typeof: "), charptr_vstring_literal( /* v.ast.Expr */ v_typeof_sumtype_v__ast__Expr( (expr)._typ ))), _SLIT(" type: ")), v__ast__Type_str(typ)), _SLIT(" */ ")));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_assign_stmt(v__gen__c__Gen* g, v__ast__AssignStmt node) {
bool v__gen__c__Gen_gen_assign_stmt_defer_0 = false;
bool af;
string type_to_free;
string sref_name;
	if (node.is_static) {
		v__gen__c__Gen_write(g, _SLIT("static "));
	}
	if (node.is_volatile) {
		v__gen__c__Gen_write(g, _SLIT("volatile "));
	}
	v__ast__Type return_type = _const_v__ast__void_type;
	bool is_decl = node.op == v__token__Kind__decl_assign;
	g->assign_op = node.op;
	v__token__Kind op = (is_decl ? (v__token__Kind__assign) : (node.op));
	v__ast__Expr right_expr = (*(v__ast__Expr*)/*ee elem_typ */array_get(node.right, 0));
	if (right_expr._typ == 286 /* v.ast.CallExpr */) {
		return_type = (*right_expr._v__ast__CallExpr).return_type;
	}
	else if (right_expr._typ == 307 /* v.ast.LockExpr */) {
		return_type = (*right_expr._v__ast__LockExpr).typ;
	}
	else if (right_expr._typ == 309 /* v.ast.MatchExpr */) {
		return_type = (*right_expr._v__ast__MatchExpr).return_type;
	}
	else if (right_expr._typ == 300 /* v.ast.IfExpr */) {
		return_type = (*right_expr._v__ast__IfExpr).typ;
	}
	
	else {
	}
	;
	af = g->is_autofree && !g->is_builtin_mod && node.op == v__token__Kind__assign && node.left_types.len == 1 && (((*(v__ast__Expr*)/*ee elem_typ */array_get(node.left, 0)))._typ == 299 /* v.ast.Ident */ || ((*(v__ast__Expr*)/*ee elem_typ */array_get(node.left, 0)))._typ == 319 /* v.ast.SelectorExpr */);
	sref_name = _SLIT("");
	type_to_free = _SLIT("");
	if (af) {
		v__ast__Type first_left_type = (*(v__ast__Type*)/*ee elem_typ */array_get(node.left_types, 0));
		v__ast__TypeSymbol* first_left_sym = v__ast__Table_sym(g->table, (*(v__ast__Type*)/*ee elem_typ */array_get(node.left_types, 0)));
		if (v__ast__Type_alias_eq(first_left_type, _const_v__ast__string_type) || first_left_sym->kind == v__ast__Kind__array) {
			type_to_free = (v__ast__Type_alias_eq(first_left_type, _const_v__ast__string_type) ? (_SLIT("string")) : (_SLIT("array")));
			bool ok = true;
			v__ast__Expr left0 = (*(v__ast__Expr*)/*ee elem_typ */array_get(node.left, 0));
			if ((left0)._typ == 299 /* v.ast.Ident */) {
				if (string__eq((*left0._v__ast__Ident).name, _SLIT("_"))) {
					ok = false;
				}
			}
			if (ok) {
				sref_name =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("_sref"), 0xfe07, {.d_i32 = node.pos.pos}}, {_SLIT0, 0, { .d_c = 0 }}}));
				v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = type_to_free}}, {_SLIT(" "), 0xfe10, {.d_s = sref_name}}, {_SLIT(" = ("), 0, { .d_c = 0 }}})));
				v__gen__c__Gen_expr(g, left0);
				v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("); // free "), 0xfe10, {.d_s = type_to_free}}, {_SLIT(" on re-assignment2"), 0, { .d_c = 0 }}})));
				v__gen__c__Gen_gen_assign_stmt_defer_0 = true;
			} else {
				af = false;
			}
		} else {
			af = false;
		}
	}
	v__gen__c__Gen_gen_assign_vars_autofree(g, (voidptr)&/*qq*/node);
	if (!v__ast__Type_alias_eq(return_type, _const_v__ast__void_type) && return_type != 0) {
		v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, return_type);
		if (sym->kind == v__ast__Kind__multi_return) {
			v__gen__c__Gen_gen_multi_return_assign(g, (voidptr)&/*qq*/node, return_type);
			// Defer begin
			if (v__gen__c__Gen_gen_assign_stmt_defer_0) {
				if (af) {
					v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = type_to_free}}, {_SLIT("_free(&"), 0xfe10, {.d_s = sref_name}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
				}
			}
			// Defer end
			return;
		}
	}
	if (node.has_cross_var) {
		v__gen__c__Gen_gen_cross_var_assign(g, (voidptr)&/*qq*/node);
	}
	if (node.right.len < node.left.len) {
		v__gen__c__Gen_checker_bug(g, _SLIT("node.right.len < node.left.len"), node.pos);
	}
	if (node.right_types.len < node.left.len) {
		v__gen__c__Gen_checker_bug(g, _SLIT("node.right_types.len < node.left.len"), node.pos);
	}
	if (node.left_types.len < node.left.len) {
		v__gen__c__Gen_checker_bug(g, _SLIT("node.left_types.len < node.left.len"), node.pos);
	}
	for (int i = 0; i < node.left.len; ++i) {
		v__ast__Expr left = ((v__ast__Expr*)node.left.data)[i];
		bool is_auto_heap = false;
		v__ast__Type var_type = (*(v__ast__Type*)/*ee elem_typ */array_get(node.left_types, i));
		v__ast__Type val_type = (*(v__ast__Type*)/*ee elem_typ */array_get(node.right_types, i));
		v__ast__Expr val = (*(v__ast__Expr*)/*ee elem_typ */array_get(node.right, i));
		bool is_call = false;
		bool blank_assign = false;
		v__ast__Ident ident = (v__ast__Ident){.language = 0,.tok_kind = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.mut_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comptime = 0,.scope = 0,.obj = {0},.mod = (string){.str=(byteptr)"", .is_lit=1},.name = (string){.str=(byteptr)"", .is_lit=1},.kind = 0,.info = {0},.is_mut = 0,};
		v__ast__TypeSymbol* left_sym = v__ast__Table_sym(g->table, v__gen__c__Gen_unwrap_generic(g, var_type));
		if ((left)._typ == 299 /* v.ast.Ident */) {
			ident = (*left._v__ast__Ident);
			blank_assign = (*left._v__ast__Ident).kind == v__ast__IdentKind__blank_ident;
			v__ast__IdentInfo left_info = (*left._v__ast__Ident).info;
			if ((left_info)._typ == 408 /* v.ast.IdentVar */) {
				v__ast__ShareType share = (*left_info._v__ast__IdentVar).share;
				if (share == v__ast__ShareType__shared_t) {
					var_type = v__ast__Type_set_flag(var_type, v__ast__TypeFlag__shared_f);
				}
				if (share == v__ast__ShareType__atomic_t) {
					var_type = v__ast__Type_set_flag(var_type, v__ast__TypeFlag__atomic_f);
				}
			}
			if (((*left._v__ast__Ident).obj)._typ == 357 /* v.ast.Var */) {
				if ((val)._typ == 292 /* v.ast.ComptimeSelector */) {
					if (((*val._v__ast__ComptimeSelector).field_expr)._typ == 319 /* v.ast.SelectorExpr */) {
						if (((*(*val._v__ast__ComptimeSelector).field_expr._v__ast__SelectorExpr).expr)._typ == 299 /* v.ast.Ident */) {
							string key_str =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = (*(*(*val._v__ast__ComptimeSelector).field_expr._v__ast__SelectorExpr).expr._v__ast__Ident).name}}, {_SLIT(".typ"), 0, { .d_c = 0 }}}));
							v__ast__Type* _t2 = (v__ast__Type*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, g->comptime_var_type_map), &(string[]){key_str}));
							Option_v__ast__Type _t1 = {0};
							if (_t2) {
								*((v__ast__Type*)&_t1.data) = *((v__ast__Type*)_t2);
							} else {
								_t1.state = 2; _t1.err = _v_error(_SLIT("array index out of range"));
							}
							;
							if (_t1.state != 0) { /*or block*/ 
								IError err = _t1.err;
								*(v__ast__Type*) _t1.data = var_type;
							}
							
							var_type = *(v__ast__Type*)_t1.data;
							(*(*left._v__ast__Ident).obj._v__ast__Var).typ = var_type;
						}
					}
				} else if ((val)._typ == 291 /* v.ast.ComptimeCall */) {
					string key_str =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = (*val._v__ast__ComptimeCall).method_name}}, {_SLIT(".return_type"), 0, { .d_c = 0 }}}));
					v__ast__Type* _t4 = (v__ast__Type*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, g->comptime_var_type_map), &(string[]){key_str}));
					Option_v__ast__Type _t3 = {0};
					if (_t4) {
						*((v__ast__Type*)&_t3.data) = *((v__ast__Type*)_t4);
					} else {
						_t3.state = 2; _t3.err = _v_error(_SLIT("array index out of range"));
					}
					;
					if (_t3.state != 0) { /*or block*/ 
						IError err = _t3.err;
						*(v__ast__Type*) _t3.data = var_type;
					}
					
					var_type = *(v__ast__Type*)_t3.data;
					(*(*left._v__ast__Ident).obj._v__ast__Var).typ = var_type;
				}
				is_auto_heap = (*(*left._v__ast__Ident).obj._v__ast__Var).is_auto_heap;
			}
		}
		string styp = v__gen__c__Gen_typ(g, var_type);
		bool is_fixed_array_init = false;
		bool has_val = false;
		if (val._typ == 280 /* v.ast.ArrayInit */) {
			is_fixed_array_init = (*val._v__ast__ArrayInit).is_fixed;
			has_val = (*val._v__ast__ArrayInit).has_val;
		}
		else if (val._typ == 286 /* v.ast.CallExpr */) {
			is_call = true;
			return_type = (*val._v__ast__CallExpr).return_type;
		}
		else if (val._typ == 278 /* v.ast.AnonFn */) {
			if (blank_assign) {
				v__gen__c__Gen_write(g, _SLIT("{"));
			}
			if ((is_decl || blank_assign) && (left)._typ == 299 /* v.ast.Ident */) {
				string ret_styp = v__gen__c__Gen_typ(g, (*val._v__ast__AnonFn).decl.return_type);
				v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ret_styp}}, {_SLIT(" (*"), 0xfe10, {.d_s = ident.name}}, {_SLIT(") ("), 0, { .d_c = 0 }}})));
				int def_pos = g->definitions.len;
				v__gen__c__Gen_fn_args(g, (*val._v__ast__AnonFn).decl.params, ((voidptr)(0)));
				strings__Builder_go_back(&g->definitions, g->definitions.len - def_pos);
				v__gen__c__Gen_write(g, _SLIT(") = "));
			} else {
				g->is_assign_lhs = true;
				g->assign_op = node.op;
				v__gen__c__Gen_expr(g, left);
				g->is_assign_lhs = false;
				g->is_arraymap_set = false;
				if ((left)._typ == 302 /* v.ast.IndexExpr */) {
					v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, (*left._v__ast__IndexExpr).left_type);
					if (sym->kind == v__ast__Kind__map || sym->kind == v__ast__Kind__array) {
						v__gen__c__Gen_expr(g, val);
						v__gen__c__Gen_writeln(g, _SLIT("});"));
						continue;
					}
				}
				v__gen__c__Gen_write(g, _SLIT(" = "));
			}
			v__gen__c__Gen_expr(g, val);
			v__gen__c__Gen_writeln(g, _SLIT(";"));
			if (blank_assign) {
				v__gen__c__Gen_write(g, _SLIT("}"));
			}
			continue;
		}
		
		else {
		}
		;
		v__ast__Type unwrapped_val_type = v__gen__c__Gen_unwrap_generic(g, val_type);
		v__ast__TypeSymbol* right_sym = v__ast__Table_sym(g->table, unwrapped_val_type);
		v__ast__TypeSymbol* unaliased_right_sym = v__ast__Table_final_sym(g->table, unwrapped_val_type);
		bool is_fixed_array_var = unaliased_right_sym->kind == v__ast__Kind__array_fixed && (val)._typ != 280 /* v.ast.ArrayInit */ && (((val)._typ == 299 /* v.ast.Ident */ || (val)._typ == 302 /* v.ast.IndexExpr */ || (val)._typ == 286 /* v.ast.CallExpr */ || (val)._typ == 319 /* v.ast.SelectorExpr */) || ((val)._typ == 287 /* v.ast.CastExpr */ && ((/* as */ *(v__ast__CastExpr*)__as_cast((val)._v__ast__CastExpr,(val)._typ, 287) /*expected idx: 287, name: v.ast.CastExpr */ ).expr)._typ != 280 /* v.ast.ArrayInit */));
		g->is_assign_lhs = true;
		g->assign_op = node.op;
		if (v__ast__Type_has_flag(val_type, v__ast__TypeFlag__optional)) {
			g->right_is_opt = true;
		}
		if (blank_assign) {
			if ((val)._typ == 302 /* v.ast.IndexExpr */) {
				g->assign_op = v__token__Kind__decl_assign;
			}
			g->is_assign_lhs = false;
			if (is_call) {
				bool old_is_void_expr_stmt = g->is_void_expr_stmt;
				g->is_void_expr_stmt = true;
				v__gen__c__Gen_expr(g, val);
				g->is_void_expr_stmt = old_is_void_expr_stmt;
			} else if (g->inside_for_c_stmt) {
				v__gen__c__Gen_expr(g, val);
			} else {
				v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("{"), 0xfe10, {.d_s = styp}}, {_SLIT(" _ = "), 0, { .d_c = 0 }}})));
				v__gen__c__Gen_expr(g, val);
				v__gen__c__Gen_writeln(g, _SLIT(";}"));
			}
		} else if (node.op == v__token__Kind__assign && (is_fixed_array_init || (right_sym->kind == v__ast__Kind__array_fixed && (val)._typ == 299 /* v.ast.Ident */))) {
			string v_var = _SLIT("");
			string arr_typ = string_trim(styp, _SLIT("*"));
			if (is_fixed_array_init) {
				v__ast__ArrayInit right = /* as */ *(v__ast__ArrayInit*)__as_cast((val)._v__ast__ArrayInit,(val)._typ, 280) /*expected idx: 280, name: v.ast.ArrayInit */ ;
				v_var = v__gen__c__Gen_new_tmp_var(g);
				v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = arr_typ}}, {_SLIT(" "), 0xfe10, {.d_s = v_var}}, {_SLIT(" = "), 0, { .d_c = 0 }}})));
				v__gen__c__Gen_expr(g, v__ast__ArrayInit_to_sumtype_v__ast__Expr(&right));
				v__gen__c__Gen_writeln(g, _SLIT(";"));
			} else {
				v__ast__Ident right = /* as */ *(v__ast__Ident*)__as_cast((val)._v__ast__Ident,(val)._typ, 299) /*expected idx: 299, name: v.ast.Ident */ ;
				v_var = right.name;
			}
			int pos = g->out.len;
			v__gen__c__Gen_expr(g, left);
			if (g->is_arraymap_set && g->arraymap_set_pos > 0) {
				strings__Builder_go_back_to(&g->out, g->arraymap_set_pos);
				v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(", &"), 0xfe10, {.d_s = v_var}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
				g->is_arraymap_set = false;
				g->arraymap_set_pos = 0;
			} else {
				strings__Builder_go_back_to(&g->out, pos);
				bool is_var_mut = !is_decl && v__ast__Expr_is_auto_deref_var(left);
				string addr = (is_var_mut ? (_SLIT("")) : (_SLIT("&")));
				v__gen__c__Gen_writeln(g, _SLIT(""));
				v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("memcpy("), 0xfe10, {.d_s = addr}}, {_SLIT0, 0, { .d_c = 0 }}})));
				v__gen__c__Gen_expr(g, left);
				v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT(", &"), 0xfe10, {.d_s = v_var}}, {_SLIT(", sizeof("), 0xfe10, {.d_s = arr_typ}}, {_SLIT("));"), 0, { .d_c = 0 }}})));
			}
			g->is_assign_lhs = false;
		} else {
			bool is_inside_ternary = g->inside_ternary != 0;
			string _t5; /* if prepend */
			if (is_inside_ternary && is_decl) {
				v__gen__c__Gen_register_ternary_name(g, ident.name);
				g->empty_line = false;
				_t5 = v__gen__c__Gen_go_before_ternary(g);
			} else {
				_t5 = _SLIT("");
			}
			string cur_line =  _t5;
			bool str_add = false;
			bool op_overloaded = false;
			v__ast__Type op_expected_left = ((v__ast__Type)(0));
			v__ast__Type op_expected_right = ((v__ast__Type)(0));
			if (var_type == _const_v__ast__string_type_idx && node.op == v__token__Kind__plus_assign) {
				if ((left)._typ == 302 /* v.ast.IndexExpr */) {
					v__gen__c__Gen_expr(g, left);
					v__gen__c__Gen_write(g, _SLIT("string__plus("));
				} else {
					v__gen__c__Gen_expr(g, left);
					v__gen__c__Gen_write(g, _SLIT(" = /*f*/string__plus("));
				}
				g->is_assign_lhs = false;
				str_add = true;
			}
			if (((left_sym->kind == v__ast__Kind__struct_ && right_sym->kind == v__ast__Kind__struct_) || (left_sym->kind == v__ast__Kind__alias && right_sym->kind == v__ast__Kind__alias)) && (node.op == v__token__Kind__plus_assign || node.op == v__token__Kind__minus_assign || node.op == v__token__Kind__div_assign || node.op == v__token__Kind__mult_assign || node.op == v__token__Kind__mod_assign)) {
				string _t6 = (string){.str=(byteptr)"", .is_lit=1};
				
				if (node.op == (v__token__Kind__plus_assign)) {
					_t6 = _SLIT("+");
				}
				else if (node.op == (v__token__Kind__minus_assign)) {
					_t6 = _SLIT("-");
				}
				else if (node.op == (v__token__Kind__div_assign)) {
					_t6 = _SLIT("/");
				}
				else if (node.op == (v__token__Kind__mod_assign)) {
					_t6 = _SLIT("%");
				}
				else if (node.op == (v__token__Kind__mult_assign)) {
					_t6 = _SLIT("*");
				}
				else {
					_t6 = _SLIT("unknown op");
				}string extracted_op = _t6;
				v__gen__c__Gen_expr(g, left);
				if (left_sym->kind == v__ast__Kind__struct_ && (/* as */ *(v__ast__Struct*)__as_cast((left_sym->info)._v__ast__Struct,(left_sym->info)._typ, 446) /*expected idx: 446, name: v.ast.Struct */ ).generic_types.len > 0) {
					Array_v__ast__Type concrete_types = (/* as */ *(v__ast__Struct*)__as_cast((left_sym->info)._v__ast__Struct,(left_sym->info)._typ, 446) /*expected idx: 446, name: v.ast.Struct */ ).concrete_types;
					string method_name = string__plus(string__plus(left_sym->cname, _SLIT("_")), v__util__replace_op(extracted_op));
					method_name = v__gen__c__Gen_generic_fn_name(g, concrete_types, method_name, true);
					v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(" = "), 0xfe10, {.d_s = method_name}}, {_SLIT("("), 0, { .d_c = 0 }}})));
					v__gen__c__Gen_expr(g, left);
					v__gen__c__Gen_write(g, _SLIT(", "));
					v__gen__c__Gen_expr(g, val);
					v__gen__c__Gen_writeln(g, _SLIT(");"));
					// Defer begin
					if (v__gen__c__Gen_gen_assign_stmt_defer_0) {
						if (af) {
							v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = type_to_free}}, {_SLIT("_free(&"), 0xfe10, {.d_s = sref_name}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
						}
					}
					// Defer end
					return;
				} else {
					v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT(" = "), 0xfe10, {.d_s = styp}}, {_SLIT("_"), 0xfe10, {.d_s = v__util__replace_op(extracted_op)}}, {_SLIT("("), 0, { .d_c = 0 }}})));
					Option_v__ast__Fn _t7 = v__ast__Table_find_method(g->table, left_sym, extracted_op);
					if (_t7.state != 0) { /*or block*/ 
						IError err = _t7.err;
						v__gen__c__Gen_error(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("assignemnt operator `"), 0xfe10, {.d_s = extracted_op}}, {_SLIT("=` used but no `"), 0xfe10, {.d_s = extracted_op}}, {_SLIT("` method defined"), 0, { .d_c = 0 }}})), node.pos);
						VUNREACHABLE();
						*(v__ast__Fn*) _t7.data = (v__ast__Fn){.is_variadic = 0,.language = 0,.is_pub = 0,.is_ctor_new = 0,.is_deprecated = 0,.is_noreturn = 0,.is_unsafe = 0,.is_placeholder = 0,.is_main = 0,.is_test = 0,.is_keep_alive = 0,.is_method = 0,.no_body = 0,.mod = (string){.str=(byteptr)"", .is_lit=1},.file = (string){.str=(byteptr)"", .is_lit=1},.file_mode = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.return_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.return_type = 0,.receiver_type = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.params = __new_array(0, 0, sizeof(v__ast__Param)),.source_fn = 0,.usages = 0,.generic_names = __new_array(0, 0, sizeof(string)),.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_conditional = 0,.ctdefine_idx = 0,};
					}
					
 					v__ast__Fn method =  (*(v__ast__Fn*)_t7.data);
					op_expected_left = (*(v__ast__Param*)/*ee elem_typ */array_get(method.params, 0)).typ;
					op_expected_right = (*(v__ast__Param*)/*ee elem_typ */array_get(method.params, 1)).typ;
					op_overloaded = true;
				}
			}
			if (right_sym->kind == v__ast__Kind__function && is_decl) {
				if (is_inside_ternary && is_decl) {
					strings__Builder_write_string(&g->out, v__util__tabs(g->indent - g->inside_ternary));
				}
				v__ast__FnType func = /* as */ *(v__ast__FnType*)__as_cast((right_sym->info)._v__ast__FnType,(right_sym->info)._typ, 472) /*expected idx: 472, name: v.ast.FnType */ ;
				string ret_styp = v__gen__c__Gen_typ(g, func.func.return_type);
				v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ret_styp}}, {_SLIT(" (*"), 0xfe10, {.d_s = v__gen__c__Gen_get_ternary_name(g, ident.name)}}, {_SLIT(") ("), 0, { .d_c = 0 }}})));
				int def_pos = g->definitions.len;
				v__gen__c__Gen_fn_args(g, func.func.params, ((voidptr)(0)));
				strings__Builder_go_back(&g->definitions, g->definitions.len - def_pos);
				v__gen__c__Gen_write(g, _SLIT(")"));
			} else {
				if (is_decl) {
					if (is_inside_ternary) {
						strings__Builder_write_string(&g->out, v__util__tabs(g->indent - g->inside_ternary));
					}
					bool is_used_var_styp = false;
					if (!Array_string_contains(g->defer_vars, ident.name)) {
						v__ast__TypeSymbol* val_sym = v__ast__Table_sym(g->table, val_type);
						if ((val_sym->info)._typ == 446 /* v.ast.Struct */) {
							if ((*val_sym->info._v__ast__Struct).generic_types.len > 0) {
								if ((val)._typ == 324 /* v.ast.StructInit */) {
									string var_styp = v__gen__c__Gen_typ(g, (*val._v__ast__StructInit).typ);
									v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = var_styp}}, {_SLIT(" "), 0, { .d_c = 0 }}})));
									is_used_var_styp = true;
								} else if ((val)._typ == 316 /* v.ast.PrefixExpr */) {
									if ((*val._v__ast__PrefixExpr).op == v__token__Kind__amp && ((*val._v__ast__PrefixExpr).right)._typ == 324 /* v.ast.StructInit */) {
										string var_styp = v__gen__c__Gen_typ(g, v__ast__Type_ref((*(*val._v__ast__PrefixExpr).right._v__ast__StructInit).typ));
										v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = var_styp}}, {_SLIT(" "), 0, { .d_c = 0 }}})));
										is_used_var_styp = true;
									}
								}
							}
						}
						if (!is_used_var_styp) {
							v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = styp}}, {_SLIT(" "), 0, { .d_c = 0 }}})));
						}
						if (is_auto_heap) {
							v__gen__c__Gen_write(g, _SLIT("*"));
						}
					}
				}
				if ((left)._typ == 299 /* v.ast.Ident */ || (left)._typ == 319 /* v.ast.SelectorExpr */) {
					g->prevent_sum_type_unwrapping_once = true;
				}
				if (!is_fixed_array_var || is_decl) {
					if (op_overloaded) {
						v__gen__c__Gen_op_arg(g, left, op_expected_left, var_type);
					} else {
						if (!is_decl && v__ast__Expr_is_auto_deref_var(left)) {
							v__gen__c__Gen_write(g, _SLIT("*"));
						}
						v__gen__c__Gen_expr(g, left);
					}
				}
			}
			if (is_inside_ternary && is_decl) {
				v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(";\n"), 0xfe10, {.d_s = cur_line}}, {_SLIT0, 0, { .d_c = 0 }}})));
				strings__Builder_write_string(&g->out, v__util__tabs(g->indent));
				v__gen__c__Gen_expr(g, left);
			}
			g->is_assign_lhs = false;
			if (is_fixed_array_var) {
				if (is_decl) {
					v__gen__c__Gen_writeln(g, _SLIT(";"));
				}
			} else if (!g->is_arraymap_set && !str_add && !op_overloaded) {
				v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(" "), 0xfe10, {.d_s = v__token__Kind_str(op)}}, {_SLIT(" "), 0, { .d_c = 0 }}})));
			} else if (str_add || op_overloaded) {
				v__gen__c__Gen_write(g, _SLIT(", "));
			}
			bool cloned = false;
			if (g->is_autofree && (right_sym->kind == v__ast__Kind__array || right_sym->kind == v__ast__Kind__string)) {
				if (v__gen__c__Gen_gen_clone_assignment(g, val, unwrapped_val_type, false)) {
					cloned = true;
				}
			}
			bool unwrap_optional = !v__ast__Type_has_flag(var_type, v__ast__TypeFlag__optional) && v__ast__Type_has_flag(val_type, v__ast__TypeFlag__optional);
			if (unwrap_optional) {
			}
			g->is_shared = v__ast__Type_has_flag(var_type, v__ast__TypeFlag__shared_f);
			if (!cloned) {
				if (is_fixed_array_var) {
					string typ_str = string_trim(v__gen__c__Gen_typ(g, val_type), _SLIT("*"));
					string ref_str = (v__ast__Type_is_ptr(val_type) ? (_SLIT("")) : (_SLIT("&")));
					v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("memcpy(("), 0xfe10, {.d_s = typ_str}}, {_SLIT("*)"), 0, { .d_c = 0 }}})));
					v__gen__c__Gen_expr(g, left);
					v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(", (byte*)"), 0xfe10, {.d_s = ref_str}}, {_SLIT0, 0, { .d_c = 0 }}})));
					v__gen__c__Gen_expr(g, val);
					v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(", sizeof("), 0xfe10, {.d_s = typ_str}}, {_SLIT("))"), 0, { .d_c = 0 }}})));
				} else if (is_decl) {
					if (is_fixed_array_init && !has_val) {
						if ((val)._typ == 280 /* v.ast.ArrayInit */) {
							v__gen__c__Gen_array_init(g, (*val._v__ast__ArrayInit));
						} else {
							v__gen__c__Gen_write(g, _SLIT("{0}"));
						}
					} else {
						if (is_auto_heap) {
							v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("HEAP("), 0xfe10, {.d_s = styp}}, {_SLIT(", ("), 0, { .d_c = 0 }}})));
						}
						if (v__ast__Expr_is_auto_deref_var(val)) {
							v__gen__c__Gen_write(g, _SLIT("*"));
						}
						v__gen__c__Gen_expr(g, val);
						if (is_auto_heap) {
							v__gen__c__Gen_write(g, _SLIT("))"));
						}
					}
				} else {
					if (node.has_cross_var) {
						v__gen__c__Gen_gen_cross_tmp_variable(g, node.left, val);
					} else {
						if (op_overloaded) {
							v__gen__c__Gen_op_arg(g, val, op_expected_right, val_type);
						} else {
							v__gen__c__Gen_expr_with_cast(g, val, val_type, var_type);
						}
					}
				}
			}
			if (str_add || op_overloaded) {
				v__gen__c__Gen_write(g, _SLIT(")"));
			}
			if (g->is_arraymap_set) {
				v__gen__c__Gen_write(g, _SLIT(" })"));
				g->is_arraymap_set = false;
			}
			g->is_shared = false;
		}
		g->right_is_opt = false;
		if (g->inside_ternary == 0 && (node.left.len > 1 || !node.is_simple)) {
			v__gen__c__Gen_writeln(g, _SLIT(";"));
		}
	}
// Defer begin
if (v__gen__c__Gen_gen_assign_stmt_defer_0) {
	if (af) {
		v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = type_to_free}}, {_SLIT("_free(&"), 0xfe10, {.d_s = sref_name}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
	}
}
// Defer end
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_multi_return_assign(v__gen__c__Gen* g, v__ast__AssignStmt* node, v__ast__Type return_type) {
	bool is_opt = v__ast__Type_has_flag(return_type, v__ast__TypeFlag__optional);
	string mr_var_name =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("mr_"), 0xfe07, {.d_i32 = node->pos.pos}}, {_SLIT0, 0, { .d_c = 0 }}}));
	string mr_styp = v__gen__c__Gen_typ(g, return_type);
	v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = mr_styp}}, {_SLIT(" "), 0xfe10, {.d_s = mr_var_name}}, {_SLIT(" = "), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_expr(g, (*(v__ast__Expr*)/*ee elem_typ */array_get(node->right, 0)));
	v__gen__c__Gen_writeln(g, _SLIT(";"));
	for (int i = 0; i < node->left.len; ++i) {
		v__ast__Expr lx = ((v__ast__Expr*)node->left.data)[i];
		bool is_auto_heap = false;
		v__ast__Ident ident = (v__ast__Ident){.language = 0,.tok_kind = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.mut_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comptime = 0,.scope = 0,.obj = {0},.mod = (string){.str=(byteptr)"", .is_lit=1},.name = (string){.str=(byteptr)"", .is_lit=1},.kind = 0,.info = {0},.is_mut = 0,};
		if ((lx)._typ == 299 /* v.ast.Ident */) {
			ident = (*lx._v__ast__Ident);
			if ((*lx._v__ast__Ident).kind == v__ast__IdentKind__blank_ident) {
				continue;
			}
			if (((*lx._v__ast__Ident).obj)._typ == 357 /* v.ast.Var */) {
				is_auto_heap = (*(*lx._v__ast__Ident).obj._v__ast__Var).is_auto_heap;
			}
		}
		string styp = (Array_string_contains(g->defer_vars, ident.name) ? (_SLIT("")) : (v__gen__c__Gen_typ(g, (*(v__ast__Type*)/*ee elem_typ */array_get(node->left_types, i)))));
		if (node->op == v__token__Kind__decl_assign) {
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = styp}}, {_SLIT(" "), 0, { .d_c = 0 }}})));
			if (is_auto_heap) {
				v__gen__c__Gen_write(g, _SLIT("*"));
			}
		}
		if (v__ast__Expr_is_auto_deref_var(lx)) {
			v__gen__c__Gen_write(g, _SLIT("*"));
		}
		v__gen__c__Gen_expr(g, lx);
		string noscan = (is_auto_heap ? (v__gen__c__Gen_check_noscan(g, return_type)) : (_SLIT("")));
		if (g->is_arraymap_set) {
			if (is_opt) {
				string mr_base_styp = v__gen__c__Gen_base_type(g, return_type);
				if (is_auto_heap) {
					v__gen__c__Gen_writeln(g,  str_intp(6, _MOV((StrIntpData[]){{_SLIT("HEAP"), 0xfe10, {.d_s = noscan}}, {_SLIT("("), 0xfe10, {.d_s = mr_base_styp}}, {_SLIT(", *("), 0xfe10, {.d_s = mr_base_styp}}, {_SLIT("*)"), 0xfe10, {.d_s = mr_var_name}}, {_SLIT(".data).arg"), 0xfe07, {.d_i32 = i}}, {_SLIT(") });"), 0, { .d_c = 0 }}})));
				} else {
					v__gen__c__Gen_writeln(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("(*("), 0xfe10, {.d_s = mr_base_styp}}, {_SLIT("*)"), 0xfe10, {.d_s = mr_var_name}}, {_SLIT(".data).arg"), 0xfe07, {.d_i32 = i}}, {_SLIT(" });"), 0, { .d_c = 0 }}})));
				}
			} else {
				if (is_auto_heap) {
					v__gen__c__Gen_writeln(g,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("HEAP"), 0xfe10, {.d_s = noscan}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT(", "), 0xfe10, {.d_s = mr_var_name}}, {_SLIT(".arg"), 0xfe07, {.d_i32 = i}}, {_SLIT(") });"), 0, { .d_c = 0 }}})));
				} else {
					v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = mr_var_name}}, {_SLIT(".arg"), 0xfe07, {.d_i32 = i}}, {_SLIT(" });"), 0, { .d_c = 0 }}})));
				}
			}
		} else {
			if (is_opt) {
				string mr_base_styp = v__gen__c__Gen_base_type(g, return_type);
				if (is_auto_heap) {
					v__gen__c__Gen_writeln(g,  str_intp(6, _MOV((StrIntpData[]){{_SLIT(" = HEAP"), 0xfe10, {.d_s = noscan}}, {_SLIT("("), 0xfe10, {.d_s = mr_base_styp}}, {_SLIT(", *("), 0xfe10, {.d_s = mr_base_styp}}, {_SLIT("*)"), 0xfe10, {.d_s = mr_var_name}}, {_SLIT(".data).arg"), 0xfe07, {.d_i32 = i}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
				} else {
					v__gen__c__Gen_writeln(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT(" = (*("), 0xfe10, {.d_s = mr_base_styp}}, {_SLIT("*)"), 0xfe10, {.d_s = mr_var_name}}, {_SLIT(".data).arg"), 0xfe07, {.d_i32 = i}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
				}
			} else {
				if (is_auto_heap) {
					v__gen__c__Gen_writeln(g,  str_intp(5, _MOV((StrIntpData[]){{_SLIT(" = HEAP"), 0xfe10, {.d_s = noscan}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT(", "), 0xfe10, {.d_s = mr_var_name}}, {_SLIT(".arg"), 0xfe07, {.d_i32 = i}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
				} else {
					v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT(" = "), 0xfe10, {.d_s = mr_var_name}}, {_SLIT(".arg"), 0xfe07, {.d_i32 = i}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
				}
			}
		}
	}
	if (g->is_arraymap_set) {
		g->is_arraymap_set = false;
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_assign_vars_autofree(v__gen__c__Gen* g, v__ast__AssignStmt* node) {
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_cross_var_assign(v__gen__c__Gen* g, v__ast__AssignStmt* node) {
	for (int i = 0; i < node->left.len; ++i) {
		v__ast__Expr left = ((v__ast__Expr*)node->left.data)[i];
		if (left._typ == 299 /* v.ast.Ident */) {
			v__ast__Type left_typ = (*(v__ast__Type*)/*ee elem_typ */array_get(node->left_types, i));
			v__ast__TypeSymbol* left_sym = v__ast__Table_sym(g->table, left_typ);
			if (left_sym->kind == v__ast__Kind__function) {
				v__gen__c__Gen_write_fn_ptr_decl(g, ADDR(v__ast__FnType/*qq*/, /* as */ *(v__ast__FnType*)__as_cast((left_sym->info)._v__ast__FnType,(left_sym->info)._typ, 472) /*expected idx: 472, name: v.ast.FnType */ ),  str_intp(2, _MOV((StrIntpData[]){{_SLIT("_var_"), 0xfe07, {.d_i32 = (*left._v__ast__Ident).pos.pos}}, {_SLIT0, 0, { .d_c = 0 }}})));
				v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(" = "), 0xfe10, {.d_s = (*left._v__ast__Ident).name}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
			} else {
				string styp = v__gen__c__Gen_typ(g, left_typ);
				v__gen__c__Gen_writeln(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = styp}}, {_SLIT(" _var_"), 0xfe07, {.d_i32 = (*left._v__ast__Ident).pos.pos}}, {_SLIT(" = "), 0xfe10, {.d_s = (*left._v__ast__Ident).name}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
			}
		}
		else if (left._typ == 302 /* v.ast.IndexExpr */) {
			v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, (*left._v__ast__IndexExpr).left_type);
			if (sym->kind == v__ast__Kind__array) {
				v__ast__Array info = /* as */ *(v__ast__Array*)__as_cast((sym->info)._v__ast__Array,(sym->info)._typ, 441) /*expected idx: 441, name: v.ast.Array */ ;
				v__ast__TypeSymbol* elem_typ = v__ast__Table_sym(g->table, info.elem_type);
				if (elem_typ->kind == v__ast__Kind__function) {
					v__ast__Type left_typ = (*(v__ast__Type*)/*ee elem_typ */array_get(node->left_types, i));
					v__ast__TypeSymbol* left_sym = v__ast__Table_sym(g->table, left_typ);
					v__gen__c__Gen_write_fn_ptr_decl(g, ADDR(v__ast__FnType/*qq*/, /* as */ *(v__ast__FnType*)__as_cast((left_sym->info)._v__ast__FnType,(left_sym->info)._typ, 472) /*expected idx: 472, name: v.ast.FnType */ ),  str_intp(2, _MOV((StrIntpData[]){{_SLIT("_var_"), 0xfe07, {.d_i32 = (*left._v__ast__IndexExpr).pos.pos}}, {_SLIT0, 0, { .d_c = 0 }}})));
					v__gen__c__Gen_write(g, _SLIT(" = *(voidptr*)array_get("));
				} else {
					string styp = v__gen__c__Gen_typ(g, info.elem_type);
					v__gen__c__Gen_write(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = styp}}, {_SLIT(" _var_"), 0xfe07, {.d_i32 = (*left._v__ast__IndexExpr).pos.pos}}, {_SLIT(" = *("), 0xfe10, {.d_s = styp}}, {_SLIT("*)array_get("), 0, { .d_c = 0 }}})));
				}
				if (v__ast__Type_is_ptr((*left._v__ast__IndexExpr).left_type)) {
					v__gen__c__Gen_write(g, _SLIT("*"));
				}
				bool needs_clone = v__ast__Type_alias_eq(info.elem_type, _const_v__ast__string_type) && g->is_autofree;
				if (needs_clone) {
					v__gen__c__Gen_write(g, _SLIT("/*1*/string_clone("));
				}
				v__gen__c__Gen_expr(g, (*left._v__ast__IndexExpr).left);
				if (needs_clone) {
					v__gen__c__Gen_write(g, _SLIT(")"));
				}
				v__gen__c__Gen_write(g, _SLIT(", "));
				v__gen__c__Gen_expr(g, (*left._v__ast__IndexExpr).index);
				v__gen__c__Gen_writeln(g, _SLIT(");"));
			} else if (sym->kind == v__ast__Kind__map) {
				v__ast__Map info = /* as */ *(v__ast__Map*)__as_cast((sym->info)._v__ast__Map,(sym->info)._typ, 442) /*expected idx: 442, name: v.ast.Map */ ;
				string skeytyp = v__gen__c__Gen_typ(g, info.key_type);
				string styp = v__gen__c__Gen_typ(g, info.value_type);
				string zero = v__gen__c__Gen_type_default(g, info.value_type);
				v__ast__TypeSymbol* val_typ = v__ast__Table_sym(g->table, info.value_type);
				if (val_typ->kind == v__ast__Kind__function) {
					v__ast__Type left_type = (*(v__ast__Type*)/*ee elem_typ */array_get(node->left_types, i));
					v__ast__TypeSymbol* left_sym = v__ast__Table_sym(g->table, left_type);
					v__gen__c__Gen_write_fn_ptr_decl(g, ADDR(v__ast__FnType/*qq*/, /* as */ *(v__ast__FnType*)__as_cast((left_sym->info)._v__ast__FnType,(left_sym->info)._typ, 472) /*expected idx: 472, name: v.ast.FnType */ ),  str_intp(2, _MOV((StrIntpData[]){{_SLIT("_var_"), 0xfe07, {.d_i32 = (*left._v__ast__IndexExpr).pos.pos}}, {_SLIT0, 0, { .d_c = 0 }}})));
					v__gen__c__Gen_write(g, _SLIT(" = *(voidptr*)map_get("));
				} else {
					v__gen__c__Gen_write(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = styp}}, {_SLIT(" _var_"), 0xfe07, {.d_i32 = (*left._v__ast__IndexExpr).pos.pos}}, {_SLIT(" = *("), 0xfe10, {.d_s = styp}}, {_SLIT("*)map_get("), 0, { .d_c = 0 }}})));
				}
				if (!v__ast__Type_is_ptr((*left._v__ast__IndexExpr).left_type)) {
					v__gen__c__Gen_write(g, _SLIT("ADDR(map, "));
					v__gen__c__Gen_expr(g, (*left._v__ast__IndexExpr).left);
					v__gen__c__Gen_write(g, _SLIT(")"));
				} else {
					v__gen__c__Gen_expr(g, (*left._v__ast__IndexExpr).left);
				}
				v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(", &("), 0xfe10, {.d_s = skeytyp}}, {_SLIT("[]){"), 0, { .d_c = 0 }}})));
				v__gen__c__Gen_expr(g, (*left._v__ast__IndexExpr).index);
				v__gen__c__Gen_write(g, _SLIT("}"));
				if (val_typ->kind == v__ast__Kind__function) {
					v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(", &(voidptr[]){ "), 0xfe10, {.d_s = zero}}, {_SLIT(" });"), 0, { .d_c = 0 }}})));
				} else {
					v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT(", &("), 0xfe10, {.d_s = styp}}, {_SLIT("[]){ "), 0xfe10, {.d_s = zero}}, {_SLIT(" });"), 0, { .d_c = 0 }}})));
				}
			}
		}
		else if (left._typ == 319 /* v.ast.SelectorExpr */) {
			string styp = v__gen__c__Gen_typ(g, (*left._v__ast__SelectorExpr).typ);
			v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = styp}}, {_SLIT(" _var_"), 0xfe07, {.d_i32 = (*left._v__ast__SelectorExpr).pos.pos}}, {_SLIT(" = "), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_expr(g, (*left._v__ast__SelectorExpr).expr);
			string sel = _SLIT(".");
			if (v__ast__Type_is_ptr((*left._v__ast__SelectorExpr).expr_type)) {
				if (v__ast__Type_has_flag((*left._v__ast__SelectorExpr).expr_type, v__ast__TypeFlag__shared_f)) {
					sel = _SLIT("->val.");
				} else {
					sel = _SLIT("->");
				}
			}
			v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = sel}}, {_SLIT0, 0xfe10, {.d_s = (*left._v__ast__SelectorExpr).field_name}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
		}
		
		else {
		}
		;
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_cross_tmp_variable(v__gen__c__Gen* g, Array_v__ast__Expr left, v__ast__Expr val) {
	v__ast__Expr val_ = val;
	if (val._typ == 299 /* v.ast.Ident */) {
		bool has_var = false;
		for (int _t1 = 0; _t1 < left.len; ++_t1) {
			v__ast__Expr lx = ((v__ast__Expr*)left.data)[_t1];
			if ((lx)._typ == 299 /* v.ast.Ident */) {
				if (string__eq((*val._v__ast__Ident).name, (*lx._v__ast__Ident).name)) {
					v__gen__c__Gen_write(g, _SLIT("_var_"));
					v__gen__c__Gen_write(g, int_str((*lx._v__ast__Ident).pos.pos));
					has_var = true;
					break;
				}
			}
		}
		if (!has_var) {
			v__gen__c__Gen_expr(g, val_);
		}
	}
	else if (val._typ == 302 /* v.ast.IndexExpr */) {
		bool has_var = false;
		for (int _t2 = 0; _t2 < left.len; ++_t2) {
			v__ast__Expr lx = ((v__ast__Expr*)left.data)[_t2];
			if (string__eq(v__ast__Expr_str(val_), v__ast__Expr_str(lx))) {
				v__gen__c__Gen_write(g, _SLIT("_var_"));
				v__gen__c__Gen_write(g, int_str(v__ast__Expr_position(lx).pos));
				has_var = true;
				break;
			}
		}
		if (!has_var) {
			v__gen__c__Gen_expr(g, val_);
		}
	}
	else if (val._typ == 303 /* v.ast.InfixExpr */) {
		v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, (*val._v__ast__InfixExpr).left_type);
		Option_v__ast__Fn _t3;
		if (_t3 = v__ast__Table_find_method(g->table, sym, v__token__Kind_str((*val._v__ast__InfixExpr).op)), _t3.state == 0) {
			string left_styp = v__gen__c__Gen_typ(g, v__ast__Type_set_nr_muls((*val._v__ast__InfixExpr).left_type, 0));
			v__gen__c__Gen_write(g, left_styp);
			v__gen__c__Gen_write(g, _SLIT("_"));
			v__gen__c__Gen_write(g, v__util__replace_op(v__token__Kind_str((*val._v__ast__InfixExpr).op)));
			v__gen__c__Gen_write(g, _SLIT("("));
			v__gen__c__Gen_gen_cross_tmp_variable(g, left, (*val._v__ast__InfixExpr).left);
			v__gen__c__Gen_write(g, _SLIT(", "));
			v__gen__c__Gen_gen_cross_tmp_variable(g, left, (*val._v__ast__InfixExpr).right);
			v__gen__c__Gen_write(g, _SLIT(")"));
		} else {
			IError err = _t3.err;
			v__gen__c__Gen_gen_cross_tmp_variable(g, left, (*val._v__ast__InfixExpr).left);
			v__gen__c__Gen_write(g, v__token__Kind_str((*val._v__ast__InfixExpr).op));
			v__gen__c__Gen_gen_cross_tmp_variable(g, left, (*val._v__ast__InfixExpr).right);
		}
	}
	else if (val._typ == 316 /* v.ast.PrefixExpr */) {
		v__gen__c__Gen_write(g, v__token__Kind_str((*val._v__ast__PrefixExpr).op));
		v__gen__c__Gen_gen_cross_tmp_variable(g, left, (*val._v__ast__PrefixExpr).right);
	}
	else if (val._typ == 315 /* v.ast.PostfixExpr */) {
		v__gen__c__Gen_gen_cross_tmp_variable(g, left, (*val._v__ast__PostfixExpr).expr);
		v__gen__c__Gen_write(g, v__token__Kind_str((*val._v__ast__PostfixExpr).op));
	}
	else if (val._typ == 319 /* v.ast.SelectorExpr */) {
		bool has_var = false;
		for (int _t4 = 0; _t4 < left.len; ++_t4) {
			v__ast__Expr lx = ((v__ast__Expr*)left.data)[_t4];
			if (string__eq(v__ast__Expr_str(val_), v__ast__Expr_str(lx))) {
				v__gen__c__Gen_write(g, _SLIT("_var_"));
				v__gen__c__Gen_write(g, int_str(v__ast__Expr_position(lx).pos));
				has_var = true;
				break;
			}
		}
		if (!has_var) {
			v__gen__c__Gen_expr(g, val_);
		}
	}
	
	else {
		v__gen__c__Gen_expr(g, val_);
	}
	;
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_equality_fn(v__gen__c__Gen* g, v__ast__Type typ) {
	array_push((array*)&g->needed_equality_fns, _MOV((v__ast__Type[]){ v__ast__Type_set_nr_muls(typ, 0) }));
	v__ast__Type t1 = v__gen__c__Gen_unwrap_generic(g, typ);
	v__ast__Type t2 = v__ast__Type_set_nr_muls(t1, 0);
	string st2 = v__gen__c__Gen_typ(g, t2);
	string res = string_replace(st2, _SLIT("struct "), _SLIT(""));
	string _t2 = res;
	return _t2;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_equality_fns(v__gen__c__Gen* g) {
	for (int _t1 = 0; _t1 < g->needed_equality_fns.len; ++_t1) {
		v__ast__Type needed_typ = ((v__ast__Type*)g->needed_equality_fns.data)[_t1];
		if (Array_v__ast__Type_contains(g->generated_eq_fns, needed_typ)) {
			continue;
		}
		v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, needed_typ);

		if (sym->kind == (v__ast__Kind__sum_type)) {
			v__gen__c__Gen_gen_sumtype_equality_fn(g, needed_typ);
		}
		else if (sym->kind == (v__ast__Kind__struct_)) {
			v__gen__c__Gen_gen_struct_equality_fn(g, needed_typ);
		}
		else if (sym->kind == (v__ast__Kind__array)) {
			v__gen__c__Gen_gen_array_equality_fn(g, needed_typ);
		}
		else if (sym->kind == (v__ast__Kind__array_fixed)) {
			v__gen__c__Gen_gen_fixed_array_equality_fn(g, needed_typ);
		}
		else if (sym->kind == (v__ast__Kind__map)) {
			v__gen__c__Gen_gen_map_equality_fn(g, needed_typ);
		}
		else if (sym->kind == (v__ast__Kind__alias)) {
			v__gen__c__Gen_gen_alias_equality_fn(g, needed_typ);
		}
		else if (sym->kind == (v__ast__Kind__interface_)) {
			v__gen__c__Gen_gen_interface_equality_fn(g, needed_typ);
		}
		else {
			v__gen__c__verror( str_intp(2, _MOV((StrIntpData[]){{_SLIT("could not generate equality function for type "), 0xfe10, {.d_s = v__ast__Kind_str(sym->kind)}}, {_SLIT0, 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		};
	}
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_gen_sumtype_equality_fn(v__gen__c__Gen* g, v__ast__Type left_type) {
	v__gen__c__Type left = v__gen__c__Gen_unwrap(g, left_type);
	string ptr_styp = v__gen__c__Gen_typ(g, v__ast__Type_set_nr_muls(left.typ, 0));
	if (Array_v__ast__Type_contains(g->generated_eq_fns, left_type)) {
		string _t1 = ptr_styp;
		return _t1;
	}
	array_push((array*)&g->generated_eq_fns, _MOV((v__ast__Type[]){ left_type }));
	v__ast__SumType info = v__ast__TypeSymbol_sumtype_info(left.sym);
	strings__Builder_writeln(&g->type_definitions,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("static bool "), 0xfe10, {.d_s = ptr_styp}}, {_SLIT("_sumtype_eq("), 0xfe10, {.d_s = ptr_styp}}, {_SLIT(" a, "), 0xfe10, {.d_s = ptr_styp}}, {_SLIT(" b); // auto"), 0, { .d_c = 0 }}})));
	strings__Builder fn_builder = strings__new_builder(512);
	strings__Builder_writeln(&fn_builder,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("static bool "), 0xfe10, {.d_s = ptr_styp}}, {_SLIT("_sumtype_eq("), 0xfe10, {.d_s = ptr_styp}}, {_SLIT(" a, "), 0xfe10, {.d_s = ptr_styp}}, {_SLIT(" b) {"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&fn_builder, _SLIT("\tif (a._typ != b._typ) { return false; }"));
	for (int _t3 = 0; _t3 < info.variants.len; ++_t3) {
		v__ast__Type typ = ((v__ast__Type*)info.variants.data)[_t3];
		v__gen__c__Type variant = v__gen__c__Gen_unwrap(g, typ);
		strings__Builder_writeln(&fn_builder,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\tif (a._typ == "), 0xfe07, {.d_i32 = variant.typ}}, {_SLIT(") {"), 0, { .d_c = 0 }}})));
		string name =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("_"), 0xfe10, {.d_s = variant.sym->cname}}, {_SLIT0, 0, { .d_c = 0 }}}));
		if (variant.sym->kind == v__ast__Kind__string) {
			strings__Builder_writeln(&fn_builder,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\treturn string__eq(*a."), 0xfe10, {.d_s = name}}, {_SLIT(", *b."), 0xfe10, {.d_s = name}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
		} else if (variant.sym->kind == v__ast__Kind__sum_type && !v__ast__Type_is_ptr(typ)) {
			string eq_fn = v__gen__c__Gen_gen_sumtype_equality_fn(g, typ);
			strings__Builder_writeln(&fn_builder,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\t\treturn "), 0xfe10, {.d_s = eq_fn}}, {_SLIT("_sumtype_eq(*a."), 0xfe10, {.d_s = name}}, {_SLIT(", *b."), 0xfe10, {.d_s = name}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
		} else if (variant.sym->kind == v__ast__Kind__struct_ && !v__ast__Type_is_ptr(typ)) {
			string eq_fn = v__gen__c__Gen_gen_struct_equality_fn(g, typ);
			strings__Builder_writeln(&fn_builder,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\t\treturn "), 0xfe10, {.d_s = eq_fn}}, {_SLIT("_struct_eq(*a."), 0xfe10, {.d_s = name}}, {_SLIT(", *b."), 0xfe10, {.d_s = name}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
		} else if (variant.sym->kind == v__ast__Kind__array && !v__ast__Type_is_ptr(typ)) {
			string eq_fn = v__gen__c__Gen_gen_array_equality_fn(g, typ);
			strings__Builder_writeln(&fn_builder,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\t\treturn "), 0xfe10, {.d_s = eq_fn}}, {_SLIT("_arr_eq(*a."), 0xfe10, {.d_s = name}}, {_SLIT(", *b."), 0xfe10, {.d_s = name}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
		} else if (variant.sym->kind == v__ast__Kind__array_fixed && !v__ast__Type_is_ptr(typ)) {
			string eq_fn = v__gen__c__Gen_gen_fixed_array_equality_fn(g, typ);
			strings__Builder_writeln(&fn_builder,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\t\treturn "), 0xfe10, {.d_s = eq_fn}}, {_SLIT("_arr_eq(*a."), 0xfe10, {.d_s = name}}, {_SLIT(", *b."), 0xfe10, {.d_s = name}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
		} else if (variant.sym->kind == v__ast__Kind__map && !v__ast__Type_is_ptr(typ)) {
			string eq_fn = v__gen__c__Gen_gen_map_equality_fn(g, typ);
			strings__Builder_writeln(&fn_builder,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\t\treturn "), 0xfe10, {.d_s = eq_fn}}, {_SLIT("_map_eq(*a."), 0xfe10, {.d_s = name}}, {_SLIT(", *b."), 0xfe10, {.d_s = name}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
		} else if (variant.sym->kind == v__ast__Kind__alias && !v__ast__Type_is_ptr(typ)) {
			string eq_fn = v__gen__c__Gen_gen_alias_equality_fn(g, typ);
			strings__Builder_writeln(&fn_builder,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\t\treturn "), 0xfe10, {.d_s = eq_fn}}, {_SLIT("_alias_eq(*a."), 0xfe10, {.d_s = name}}, {_SLIT(", *b."), 0xfe10, {.d_s = name}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
		} else if (variant.sym->kind == v__ast__Kind__function) {
			strings__Builder_writeln(&fn_builder,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\treturn *((voidptr*)(*a."), 0xfe10, {.d_s = name}}, {_SLIT(")) == *((voidptr*)(*b."), 0xfe10, {.d_s = name}}, {_SLIT("));"), 0, { .d_c = 0 }}})));
		} else {
			strings__Builder_writeln(&fn_builder,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\treturn *a."), 0xfe10, {.d_s = name}}, {_SLIT(" == *b."), 0xfe10, {.d_s = name}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
		}
		strings__Builder_writeln(&fn_builder, _SLIT("\t}"));
	}
	strings__Builder_writeln(&fn_builder, _SLIT("\treturn false;"));
	strings__Builder_writeln(&fn_builder, _SLIT("}"));
	array_push((array*)&g->auto_fn_definitions, _MOV((string[]){ string_clone(strings__Builder_str(&fn_builder)) }));
	string _t5 = ptr_styp;
	return _t5;
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_gen_struct_equality_fn(v__gen__c__Gen* g, v__ast__Type left_type) {
bool v__gen__c__Gen_gen_struct_equality_fn_defer_0 = false;
strings__Builder fn_builder;
	v__gen__c__Type left = v__gen__c__Gen_unwrap(g, left_type);
	string ptr_styp = v__gen__c__Gen_typ(g, v__ast__Type_set_nr_muls(left.typ, 0));
	string fn_name = string_replace(ptr_styp, _SLIT("struct "), _SLIT(""));
	if (Array_v__ast__Type_contains(g->generated_eq_fns, left_type)) {
		string _t1 = fn_name;
		return _t1;
	}
	array_push((array*)&g->generated_eq_fns, _MOV((v__ast__Type[]){ left_type }));
	v__ast__Struct info = v__ast__TypeSymbol_struct_info(left.sym);
	strings__Builder_writeln(&g->type_definitions,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("static bool "), 0xfe10, {.d_s = fn_name}}, {_SLIT("_struct_eq("), 0xfe10, {.d_s = ptr_styp}}, {_SLIT(" a, "), 0xfe10, {.d_s = ptr_styp}}, {_SLIT(" b); // auto"), 0, { .d_c = 0 }}})));
	fn_builder = strings__new_builder(512);
	v__gen__c__Gen_gen_struct_equality_fn_defer_0 = true;
	strings__Builder_writeln(&fn_builder,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("static bool "), 0xfe10, {.d_s = fn_name}}, {_SLIT("_struct_eq("), 0xfe10, {.d_s = ptr_styp}}, {_SLIT(" a, "), 0xfe10, {.d_s = ptr_styp}}, {_SLIT(" b) {"), 0, { .d_c = 0 }}})));
	if (v__ast__TypeSymbol_has_method(left.sym, _SLIT("=="))) {
		strings__Builder_writeln(&fn_builder,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\treturn "), 0xfe10, {.d_s = fn_name}}, {_SLIT("__eq(a, b);"), 0, { .d_c = 0 }}})));
		strings__Builder_writeln(&fn_builder, _SLIT("}"));
		string _t3 = fn_name;
		// Defer begin
		if (v__gen__c__Gen_gen_struct_equality_fn_defer_0) {
			array_push((array*)&g->auto_fn_definitions, _MOV((string[]){ string_clone(strings__Builder_str(&fn_builder)) }));
		}
		// Defer end
		return _t3;
	}
	strings__Builder_write_string(&fn_builder, _SLIT("\treturn "));
	if (info.fields.len > 0) {
		for (int i = 0; i < info.fields.len; ++i) {
			v__ast__StructField field = ((v__ast__StructField*)info.fields.data)[i];
			if (i > 0) {
				strings__Builder_write_string(&fn_builder, _SLIT("\n\t\t&& "));
			}
			v__gen__c__Type field_type = v__gen__c__Gen_unwrap(g, field.typ);
			string field_name = v__gen__c__c_name(field.name);
			if (field_type.sym->kind == v__ast__Kind__string) {
				strings__Builder_write_string(&fn_builder,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("string__eq(a."), 0xfe10, {.d_s = field_name}}, {_SLIT(", b."), 0xfe10, {.d_s = field_name}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
			} else if (field_type.sym->kind == v__ast__Kind__sum_type && !v__ast__Type_is_ptr(field.typ)) {
				string eq_fn = v__gen__c__Gen_gen_sumtype_equality_fn(g, field.typ);
				strings__Builder_write_string(&fn_builder,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = eq_fn}}, {_SLIT("_sumtype_eq(a."), 0xfe10, {.d_s = field_name}}, {_SLIT(", b."), 0xfe10, {.d_s = field_name}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
			} else if (field_type.sym->kind == v__ast__Kind__struct_ && !v__ast__Type_is_ptr(field.typ)) {
				string eq_fn = v__gen__c__Gen_gen_struct_equality_fn(g, field.typ);
				strings__Builder_write_string(&fn_builder,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = eq_fn}}, {_SLIT("_struct_eq(a."), 0xfe10, {.d_s = field_name}}, {_SLIT(", b."), 0xfe10, {.d_s = field_name}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
			} else if (field_type.sym->kind == v__ast__Kind__array && !v__ast__Type_is_ptr(field.typ)) {
				string eq_fn = v__gen__c__Gen_gen_array_equality_fn(g, field.typ);
				strings__Builder_write_string(&fn_builder,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = eq_fn}}, {_SLIT("_arr_eq(a."), 0xfe10, {.d_s = field_name}}, {_SLIT(", b."), 0xfe10, {.d_s = field_name}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
			} else if (field_type.sym->kind == v__ast__Kind__array_fixed && !v__ast__Type_is_ptr(field.typ)) {
				string eq_fn = v__gen__c__Gen_gen_fixed_array_equality_fn(g, field.typ);
				strings__Builder_write_string(&fn_builder,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = eq_fn}}, {_SLIT("_arr_eq(a."), 0xfe10, {.d_s = field_name}}, {_SLIT(", b."), 0xfe10, {.d_s = field_name}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
			} else if (field_type.sym->kind == v__ast__Kind__map && !v__ast__Type_is_ptr(field.typ)) {
				string eq_fn = v__gen__c__Gen_gen_map_equality_fn(g, field.typ);
				strings__Builder_write_string(&fn_builder,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = eq_fn}}, {_SLIT("_map_eq(a."), 0xfe10, {.d_s = field_name}}, {_SLIT(", b."), 0xfe10, {.d_s = field_name}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
			} else if (field_type.sym->kind == v__ast__Kind__alias && !v__ast__Type_is_ptr(field.typ)) {
				string eq_fn = v__gen__c__Gen_gen_alias_equality_fn(g, field.typ);
				strings__Builder_write_string(&fn_builder,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = eq_fn}}, {_SLIT("_alias_eq(a."), 0xfe10, {.d_s = field_name}}, {_SLIT(", b."), 0xfe10, {.d_s = field_name}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
			} else if (field_type.sym->kind == v__ast__Kind__function) {
				strings__Builder_write_string(&fn_builder,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("*((voidptr*)(a."), 0xfe10, {.d_s = field_name}}, {_SLIT(")) == *((voidptr*)(b."), 0xfe10, {.d_s = field_name}}, {_SLIT("))"), 0, { .d_c = 0 }}})));
			} else if (field_type.sym->kind == v__ast__Kind__interface_) {
				string eq_fn = v__gen__c__Gen_gen_interface_equality_fn(g, field.typ);
				strings__Builder_write_string(&fn_builder,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = eq_fn}}, {_SLIT("_interface_eq(a."), 0xfe10, {.d_s = field_name}}, {_SLIT(", b."), 0xfe10, {.d_s = field_name}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
			} else {
				strings__Builder_write_string(&fn_builder,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("a."), 0xfe10, {.d_s = field_name}}, {_SLIT(" == b."), 0xfe10, {.d_s = field_name}}, {_SLIT0, 0, { .d_c = 0 }}})));
			}
		}
	} else {
		strings__Builder_write_string(&fn_builder, _SLIT("true"));
	}
	strings__Builder_writeln(&fn_builder, _SLIT(";"));
	strings__Builder_writeln(&fn_builder, _SLIT("}"));
	string _t5 = fn_name;
	// Defer begin
	if (v__gen__c__Gen_gen_struct_equality_fn_defer_0) {
		array_push((array*)&g->auto_fn_definitions, _MOV((string[]){ string_clone(strings__Builder_str(&fn_builder)) }));
	}
	// Defer end
	return _t5;
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_gen_alias_equality_fn(v__gen__c__Gen* g, v__ast__Type left_type) {
	v__gen__c__Type left = v__gen__c__Gen_unwrap(g, left_type);
	string ptr_styp = v__gen__c__Gen_typ(g, v__ast__Type_set_nr_muls(left.typ, 0));
	if (Array_v__ast__Type_contains(g->generated_eq_fns, left_type)) {
		string _t1 = ptr_styp;
		return _t1;
	}
	array_push((array*)&g->generated_eq_fns, _MOV((v__ast__Type[]){ left_type }));
	v__ast__Alias info = /* as */ *(v__ast__Alias*)__as_cast((left.sym->info)._v__ast__Alias,(left.sym->info)._typ, 460) /*expected idx: 460, name: v.ast.Alias */ ;
	strings__Builder_writeln(&g->type_definitions,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("static bool "), 0xfe10, {.d_s = ptr_styp}}, {_SLIT("_alias_eq("), 0xfe10, {.d_s = ptr_styp}}, {_SLIT(" a, "), 0xfe10, {.d_s = ptr_styp}}, {_SLIT(" b); // auto"), 0, { .d_c = 0 }}})));
	strings__Builder fn_builder = strings__new_builder(512);
	strings__Builder_writeln(&fn_builder,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("static bool "), 0xfe10, {.d_s = ptr_styp}}, {_SLIT("_alias_eq("), 0xfe10, {.d_s = ptr_styp}}, {_SLIT(" a, "), 0xfe10, {.d_s = ptr_styp}}, {_SLIT(" b) {"), 0, { .d_c = 0 }}})));
	v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, info.parent_type);
	if (sym->kind == v__ast__Kind__string) {
		strings__Builder_writeln(&fn_builder, _SLIT("\treturn string__eq(a, b);"));
	} else if (sym->kind == v__ast__Kind__sum_type && !v__ast__Type_is_ptr(left.typ)) {
		string eq_fn = v__gen__c__Gen_gen_sumtype_equality_fn(g, info.parent_type);
		strings__Builder_writeln(&fn_builder,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\treturn "), 0xfe10, {.d_s = eq_fn}}, {_SLIT("_sumtype_eq(a, b);"), 0, { .d_c = 0 }}})));
	} else if (sym->kind == v__ast__Kind__struct_ && !v__ast__Type_is_ptr(left.typ)) {
		string eq_fn = v__gen__c__Gen_gen_struct_equality_fn(g, info.parent_type);
		strings__Builder_writeln(&fn_builder,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\treturn "), 0xfe10, {.d_s = eq_fn}}, {_SLIT("_struct_eq(a, b);"), 0, { .d_c = 0 }}})));
	} else if (sym->kind == v__ast__Kind__interface_ && !v__ast__Type_is_ptr(left.typ)) {
		string eq_fn = v__gen__c__Gen_gen_interface_equality_fn(g, info.parent_type);
		strings__Builder_writeln(&fn_builder,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\treturn "), 0xfe10, {.d_s = eq_fn}}, {_SLIT("_interface_eq(a, b);"), 0, { .d_c = 0 }}})));
	} else if (sym->kind == v__ast__Kind__array && !v__ast__Type_is_ptr(left.typ)) {
		string eq_fn = v__gen__c__Gen_gen_array_equality_fn(g, info.parent_type);
		strings__Builder_writeln(&fn_builder,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\treturn "), 0xfe10, {.d_s = eq_fn}}, {_SLIT("_arr_eq(a, b);"), 0, { .d_c = 0 }}})));
	} else if (sym->kind == v__ast__Kind__array_fixed && !v__ast__Type_is_ptr(left.typ)) {
		string eq_fn = v__gen__c__Gen_gen_fixed_array_equality_fn(g, info.parent_type);
		strings__Builder_writeln(&fn_builder,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\treturn "), 0xfe10, {.d_s = eq_fn}}, {_SLIT("_arr_eq(a, b);"), 0, { .d_c = 0 }}})));
	} else if (sym->kind == v__ast__Kind__map && !v__ast__Type_is_ptr(left.typ)) {
		string eq_fn = v__gen__c__Gen_gen_map_equality_fn(g, info.parent_type);
		strings__Builder_writeln(&fn_builder,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\treturn "), 0xfe10, {.d_s = eq_fn}}, {_SLIT("_map_eq(a, b);"), 0, { .d_c = 0 }}})));
	} else if (sym->kind == v__ast__Kind__function) {
		strings__Builder_writeln(&fn_builder, _SLIT("\treturn *((voidptr*)(a)) == *((voidptr*)(b));"));
	} else {
		strings__Builder_writeln(&fn_builder, _SLIT("\treturn a == b;"));
	}
	strings__Builder_writeln(&fn_builder, _SLIT("}"));
	array_push((array*)&g->auto_fn_definitions, _MOV((string[]){ string_clone(strings__Builder_str(&fn_builder)) }));
	string _t4 = ptr_styp;
	return _t4;
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_gen_array_equality_fn(v__gen__c__Gen* g, v__ast__Type left_type) {
	v__gen__c__Type left = v__gen__c__Gen_unwrap(g, left_type);
	string ptr_styp = v__gen__c__Gen_typ(g, v__ast__Type_set_nr_muls(left.typ, 0));
	if (Array_v__ast__Type_contains(g->generated_eq_fns, left_type)) {
		string _t1 = ptr_styp;
		return _t1;
	}
	array_push((array*)&g->generated_eq_fns, _MOV((v__ast__Type[]){ left_type }));
	v__gen__c__Type elem = v__gen__c__Gen_unwrap(g, v__ast__TypeSymbol_array_info(left.sym).elem_type);
	string ptr_elem_styp = v__gen__c__Gen_typ(g, elem.typ);
	strings__Builder_writeln(&g->type_definitions,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("static bool "), 0xfe10, {.d_s = ptr_styp}}, {_SLIT("_arr_eq("), 0xfe10, {.d_s = ptr_styp}}, {_SLIT(" a, "), 0xfe10, {.d_s = ptr_styp}}, {_SLIT(" b); // auto"), 0, { .d_c = 0 }}})));
	strings__Builder fn_builder = strings__new_builder(512);
	strings__Builder_writeln(&fn_builder,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("static bool "), 0xfe10, {.d_s = ptr_styp}}, {_SLIT("_arr_eq("), 0xfe10, {.d_s = ptr_styp}}, {_SLIT(" a, "), 0xfe10, {.d_s = ptr_styp}}, {_SLIT(" b) {"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&fn_builder, _SLIT("\tif (a.len != b.len) {"));
	strings__Builder_writeln(&fn_builder, _SLIT("\t\treturn false;"));
	strings__Builder_writeln(&fn_builder, _SLIT("\t}"));
	strings__Builder_writeln(&fn_builder, _SLIT("\tfor (int i = 0; i < a.len; ++i) {"));
	if (elem.sym->kind == v__ast__Kind__string) {
		strings__Builder_writeln(&fn_builder,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\tif (!string__eq(*(("), 0xfe10, {.d_s = ptr_elem_styp}}, {_SLIT("*)((byte*)a.data+(i*a.element_size))), *(("), 0xfe10, {.d_s = ptr_elem_styp}}, {_SLIT("*)((byte*)b.data+(i*b.element_size))))) {"), 0, { .d_c = 0 }}})));
	} else if (elem.sym->kind == v__ast__Kind__sum_type && !v__ast__Type_is_ptr(elem.typ)) {
		string eq_fn = v__gen__c__Gen_gen_sumtype_equality_fn(g, elem.typ);
		strings__Builder_writeln(&fn_builder,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\t\tif (!"), 0xfe10, {.d_s = eq_fn}}, {_SLIT("_sumtype_eq((("), 0xfe10, {.d_s = ptr_elem_styp}}, {_SLIT("*)a.data)[i], (("), 0xfe10, {.d_s = ptr_elem_styp}}, {_SLIT("*)b.data)[i])) {"), 0, { .d_c = 0 }}})));
	} else if (elem.sym->kind == v__ast__Kind__struct_ && !v__ast__Type_is_ptr(elem.typ)) {
		string eq_fn = v__gen__c__Gen_gen_struct_equality_fn(g, elem.typ);
		strings__Builder_writeln(&fn_builder,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\t\tif (!"), 0xfe10, {.d_s = eq_fn}}, {_SLIT("_struct_eq((("), 0xfe10, {.d_s = ptr_elem_styp}}, {_SLIT("*)a.data)[i], (("), 0xfe10, {.d_s = ptr_elem_styp}}, {_SLIT("*)b.data)[i])) {"), 0, { .d_c = 0 }}})));
	} else if (elem.sym->kind == v__ast__Kind__interface_ && !v__ast__Type_is_ptr(elem.typ)) {
		string eq_fn = v__gen__c__Gen_gen_interface_equality_fn(g, elem.typ);
		strings__Builder_writeln(&fn_builder,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\t\tif (!"), 0xfe10, {.d_s = eq_fn}}, {_SLIT("_interface_eq((("), 0xfe10, {.d_s = ptr_elem_styp}}, {_SLIT("*)a.data)[i], (("), 0xfe10, {.d_s = ptr_elem_styp}}, {_SLIT("*)b.data)[i])) {"), 0, { .d_c = 0 }}})));
	} else if (elem.sym->kind == v__ast__Kind__array && !v__ast__Type_is_ptr(elem.typ)) {
		string eq_fn = v__gen__c__Gen_gen_array_equality_fn(g, elem.typ);
		strings__Builder_writeln(&fn_builder,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\t\tif (!"), 0xfe10, {.d_s = eq_fn}}, {_SLIT("_arr_eq((("), 0xfe10, {.d_s = ptr_elem_styp}}, {_SLIT("*)a.data)[i], (("), 0xfe10, {.d_s = ptr_elem_styp}}, {_SLIT("*)b.data)[i])) {"), 0, { .d_c = 0 }}})));
	} else if (elem.sym->kind == v__ast__Kind__array_fixed && !v__ast__Type_is_ptr(elem.typ)) {
		string eq_fn = v__gen__c__Gen_gen_fixed_array_equality_fn(g, elem.typ);
		strings__Builder_writeln(&fn_builder,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\t\tif (!"), 0xfe10, {.d_s = eq_fn}}, {_SLIT("_arr_eq((("), 0xfe10, {.d_s = ptr_elem_styp}}, {_SLIT("*)a.data)[i], (("), 0xfe10, {.d_s = ptr_elem_styp}}, {_SLIT("*)b.data)[i])) {"), 0, { .d_c = 0 }}})));
	} else if (elem.sym->kind == v__ast__Kind__map && !v__ast__Type_is_ptr(elem.typ)) {
		string eq_fn = v__gen__c__Gen_gen_map_equality_fn(g, elem.typ);
		strings__Builder_writeln(&fn_builder,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\t\tif (!"), 0xfe10, {.d_s = eq_fn}}, {_SLIT("_map_eq((("), 0xfe10, {.d_s = ptr_elem_styp}}, {_SLIT("*)a.data)[i], (("), 0xfe10, {.d_s = ptr_elem_styp}}, {_SLIT("*)b.data)[i])) {"), 0, { .d_c = 0 }}})));
	} else if (elem.sym->kind == v__ast__Kind__alias && !v__ast__Type_is_ptr(elem.typ)) {
		string eq_fn = v__gen__c__Gen_gen_alias_equality_fn(g, elem.typ);
		strings__Builder_writeln(&fn_builder,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\t\tif (!"), 0xfe10, {.d_s = eq_fn}}, {_SLIT("_alias_eq((("), 0xfe10, {.d_s = ptr_elem_styp}}, {_SLIT("*)a.data)[i], (("), 0xfe10, {.d_s = ptr_elem_styp}}, {_SLIT("*)b.data)[i])) {"), 0, { .d_c = 0 }}})));
	} else if (elem.sym->kind == v__ast__Kind__function) {
		strings__Builder_writeln(&fn_builder, _SLIT("\t\tif (*((voidptr*)((byte*)a.data+(i*a.element_size))) != *((voidptr*)((byte*)b.data+(i*b.element_size)))) {"));
	} else {
		strings__Builder_writeln(&fn_builder,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\tif (*(("), 0xfe10, {.d_s = ptr_elem_styp}}, {_SLIT("*)((byte*)a.data+(i*a.element_size))) != *(("), 0xfe10, {.d_s = ptr_elem_styp}}, {_SLIT("*)((byte*)b.data+(i*b.element_size)))) {"), 0, { .d_c = 0 }}})));
	}
	strings__Builder_writeln(&fn_builder, _SLIT("\t\t\treturn false;"));
	strings__Builder_writeln(&fn_builder, _SLIT("\t\t}"));
	strings__Builder_writeln(&fn_builder, _SLIT("\t}"));
	strings__Builder_writeln(&fn_builder, _SLIT("\treturn true;"));
	strings__Builder_writeln(&fn_builder, _SLIT("}"));
	array_push((array*)&g->auto_fn_definitions, _MOV((string[]){ string_clone(strings__Builder_str(&fn_builder)) }));
	string _t4 = ptr_styp;
	return _t4;
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_gen_fixed_array_equality_fn(v__gen__c__Gen* g, v__ast__Type left_type) {
	v__gen__c__Type left = v__gen__c__Gen_unwrap(g, left_type);
	string ptr_styp = v__gen__c__Gen_typ(g, v__ast__Type_set_nr_muls(left.typ, 0));
	if (Array_v__ast__Type_contains(g->generated_eq_fns, left_type)) {
		string _t1 = ptr_styp;
		return _t1;
	}
	array_push((array*)&g->generated_eq_fns, _MOV((v__ast__Type[]){ left_type }));
	v__ast__ArrayFixed elem_info = v__ast__TypeSymbol_array_fixed_info(left.sym);
	v__gen__c__Type elem = v__gen__c__Gen_unwrap(g, elem_info.elem_type);
	int size = elem_info.size;
	strings__Builder_writeln(&g->type_definitions,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("static bool "), 0xfe10, {.d_s = ptr_styp}}, {_SLIT("_arr_eq("), 0xfe10, {.d_s = ptr_styp}}, {_SLIT(" a, "), 0xfe10, {.d_s = ptr_styp}}, {_SLIT(" b); // auto"), 0, { .d_c = 0 }}})));
	strings__Builder fn_builder = strings__new_builder(512);
	strings__Builder_writeln(&fn_builder,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("static bool "), 0xfe10, {.d_s = ptr_styp}}, {_SLIT("_arr_eq("), 0xfe10, {.d_s = ptr_styp}}, {_SLIT(" a, "), 0xfe10, {.d_s = ptr_styp}}, {_SLIT(" b) {"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&fn_builder,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\tfor (int i = 0; i < "), 0xfe07, {.d_i32 = size}}, {_SLIT("; ++i) {"), 0, { .d_c = 0 }}})));
	if (elem.sym->kind == v__ast__Kind__string) {
		strings__Builder_writeln(&fn_builder, _SLIT("\t\tif (!string__eq(a[i], b[i])) {"));
	} else if (elem.sym->kind == v__ast__Kind__sum_type && !v__ast__Type_is_ptr(elem.typ)) {
		string eq_fn = v__gen__c__Gen_gen_sumtype_equality_fn(g, elem.typ);
		strings__Builder_writeln(&fn_builder,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\tif (!"), 0xfe10, {.d_s = eq_fn}}, {_SLIT("_sumtype_eq(a[i], b[i])) {"), 0, { .d_c = 0 }}})));
	} else if (elem.sym->kind == v__ast__Kind__struct_ && !v__ast__Type_is_ptr(elem.typ)) {
		string eq_fn = v__gen__c__Gen_gen_struct_equality_fn(g, elem.typ);
		strings__Builder_writeln(&fn_builder,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\tif (!"), 0xfe10, {.d_s = eq_fn}}, {_SLIT("_struct_eq(a[i], b[i])) {"), 0, { .d_c = 0 }}})));
	} else if (elem.sym->kind == v__ast__Kind__interface_ && !v__ast__Type_is_ptr(elem.typ)) {
		string eq_fn = v__gen__c__Gen_gen_interface_equality_fn(g, elem.typ);
		strings__Builder_writeln(&fn_builder,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\tif (!"), 0xfe10, {.d_s = eq_fn}}, {_SLIT("_interface_eq(a[i], b[i])) {"), 0, { .d_c = 0 }}})));
	} else if (elem.sym->kind == v__ast__Kind__array && !v__ast__Type_is_ptr(elem.typ)) {
		string eq_fn = v__gen__c__Gen_gen_array_equality_fn(g, elem.typ);
		strings__Builder_writeln(&fn_builder,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\tif (!"), 0xfe10, {.d_s = eq_fn}}, {_SLIT("_arr_eq(a[i], b[i])) {"), 0, { .d_c = 0 }}})));
	} else if (elem.sym->kind == v__ast__Kind__array_fixed && !v__ast__Type_is_ptr(elem.typ)) {
		string eq_fn = v__gen__c__Gen_gen_fixed_array_equality_fn(g, elem.typ);
		strings__Builder_writeln(&fn_builder,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\tif (!"), 0xfe10, {.d_s = eq_fn}}, {_SLIT("_arr_eq(a[i], b[i])) {"), 0, { .d_c = 0 }}})));
	} else if (elem.sym->kind == v__ast__Kind__map && !v__ast__Type_is_ptr(elem.typ)) {
		string eq_fn = v__gen__c__Gen_gen_map_equality_fn(g, elem.typ);
		strings__Builder_writeln(&fn_builder,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\tif (!"), 0xfe10, {.d_s = eq_fn}}, {_SLIT("_map_eq(a[i], b[i])) {"), 0, { .d_c = 0 }}})));
	} else if (elem.sym->kind == v__ast__Kind__alias && !v__ast__Type_is_ptr(elem.typ)) {
		string eq_fn = v__gen__c__Gen_gen_alias_equality_fn(g, elem.typ);
		strings__Builder_writeln(&fn_builder,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\tif (!"), 0xfe10, {.d_s = eq_fn}}, {_SLIT("_alias_eq(a[i], b[i])) {"), 0, { .d_c = 0 }}})));
	} else if (elem.sym->kind == v__ast__Kind__function) {
		strings__Builder_writeln(&fn_builder, _SLIT("\t\tif (a[i] != b[i]) {"));
	} else {
		strings__Builder_writeln(&fn_builder, _SLIT("\t\tif (a[i] != b[i]) {"));
	}
	strings__Builder_writeln(&fn_builder, _SLIT("\t\t\treturn false;"));
	strings__Builder_writeln(&fn_builder, _SLIT("\t\t}"));
	strings__Builder_writeln(&fn_builder, _SLIT("\t}"));
	strings__Builder_writeln(&fn_builder, _SLIT("\treturn true;"));
	strings__Builder_writeln(&fn_builder, _SLIT("}"));
	array_push((array*)&g->auto_fn_definitions, _MOV((string[]){ string_clone(strings__Builder_str(&fn_builder)) }));
	string _t4 = ptr_styp;
	return _t4;
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_gen_map_equality_fn(v__gen__c__Gen* g, v__ast__Type left_type) {
	v__gen__c__Type left = v__gen__c__Gen_unwrap(g, left_type);
	string ptr_styp = v__gen__c__Gen_typ(g, v__ast__Type_set_nr_muls(left.typ, 0));
	if (Array_v__ast__Type_contains(g->generated_eq_fns, left_type)) {
		string _t1 = ptr_styp;
		return _t1;
	}
	array_push((array*)&g->generated_eq_fns, _MOV((v__ast__Type[]){ left_type }));
	v__gen__c__Type value = v__gen__c__Gen_unwrap(g, v__ast__TypeSymbol_map_info(left.sym).value_type);
	string ptr_value_styp = v__gen__c__Gen_typ(g, value.typ);
	strings__Builder_writeln(&g->type_definitions,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("static bool "), 0xfe10, {.d_s = ptr_styp}}, {_SLIT("_map_eq("), 0xfe10, {.d_s = ptr_styp}}, {_SLIT(" a, "), 0xfe10, {.d_s = ptr_styp}}, {_SLIT(" b); // auto"), 0, { .d_c = 0 }}})));
	strings__Builder fn_builder = strings__new_builder(512);
	strings__Builder_writeln(&fn_builder,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("static bool "), 0xfe10, {.d_s = ptr_styp}}, {_SLIT("_map_eq("), 0xfe10, {.d_s = ptr_styp}}, {_SLIT(" a, "), 0xfe10, {.d_s = ptr_styp}}, {_SLIT(" b) {"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&fn_builder, _SLIT("\tif (a.len != b.len) {"));
	strings__Builder_writeln(&fn_builder, _SLIT("\t\treturn false;"));
	strings__Builder_writeln(&fn_builder, _SLIT("\t}"));
	strings__Builder_writeln(&fn_builder, _SLIT("\tfor (int i = 0; i < a.key_values.len; ++i) {"));
	strings__Builder_writeln(&fn_builder, _SLIT("\t\tif (!DenseArray_has_index(&a.key_values, i)) continue;"));
	strings__Builder_writeln(&fn_builder, _SLIT("\t\tvoidptr k = DenseArray_key(&a.key_values, i);"));
	strings__Builder_writeln(&fn_builder, _SLIT("\t\tif (!map_exists(&b, k)) return false;"));
	v__ast__Kind kind = v__ast__Table_type_kind(g->table, value.typ);
	if (kind == v__ast__Kind__function) {
		v__ast__FnType func = /* as */ *(v__ast__FnType*)__as_cast((value.sym->info)._v__ast__FnType,(value.sym->info)._typ, 472) /*expected idx: 472, name: v.ast.FnType */ ;
		string ret_styp = v__gen__c__Gen_typ(g, func.func.return_type);
		strings__Builder_write_string(&fn_builder,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\t"), 0xfe10, {.d_s = ret_styp}}, {_SLIT(" (*v) ("), 0, { .d_c = 0 }}})));
		int arg_len = func.func.params.len;
		for (int j = 0; j < func.func.params.len; ++j) {
			v__ast__Param arg = ((v__ast__Param*)func.func.params.data)[j];
			string arg_styp = v__gen__c__Gen_typ(g, arg.typ);
			strings__Builder_write_string(&fn_builder,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = arg_styp}}, {_SLIT(" "), 0xfe10, {.d_s = arg.name}}, {_SLIT0, 0, { .d_c = 0 }}})));
			if (j < arg_len - 1) {
				strings__Builder_write_string(&fn_builder, _SLIT(", "));
			}
		}
		strings__Builder_writeln(&fn_builder, _SLIT(") = *(voidptr*)map_get(&a, k, &(voidptr[]){ 0 });"));
	} else {
		strings__Builder_writeln(&fn_builder,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\t\t"), 0xfe10, {.d_s = ptr_value_styp}}, {_SLIT(" v = *("), 0xfe10, {.d_s = ptr_value_styp}}, {_SLIT("*)map_get(&a, k, &("), 0xfe10, {.d_s = ptr_value_styp}}, {_SLIT("[]){ 0 });"), 0, { .d_c = 0 }}})));
	}
	switch (kind) {
		case v__ast__Kind__string: 
			{
				strings__Builder_writeln(&fn_builder, _SLIT("\t\tif (!fast_string_eq(*(string*)map_get(&b, k, &(string[]){_SLIT(\"\")}), v)) {"));
			} break;
		case v__ast__Kind__sum_type: 
			{
				string eq_fn = v__gen__c__Gen_gen_sumtype_equality_fn(g, value.typ);
				strings__Builder_writeln(&fn_builder,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\t\tif (!"), 0xfe10, {.d_s = eq_fn}}, {_SLIT("_sumtype_eq(*("), 0xfe10, {.d_s = ptr_value_styp}}, {_SLIT("*)map_get(&b, k, &("), 0xfe10, {.d_s = ptr_value_styp}}, {_SLIT("[]){ 0 }), v)) {"), 0, { .d_c = 0 }}})));
			} break;
		case v__ast__Kind__struct_: 
			{
				string eq_fn = v__gen__c__Gen_gen_struct_equality_fn(g, value.typ);
				strings__Builder_writeln(&fn_builder,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\t\tif (!"), 0xfe10, {.d_s = eq_fn}}, {_SLIT("_struct_eq(*("), 0xfe10, {.d_s = ptr_value_styp}}, {_SLIT("*)map_get(&b, k, &("), 0xfe10, {.d_s = ptr_value_styp}}, {_SLIT("[]){ 0 }), v)) {"), 0, { .d_c = 0 }}})));
			} break;
		case v__ast__Kind__interface_: 
			{
				string eq_fn = v__gen__c__Gen_gen_interface_equality_fn(g, value.typ);
				strings__Builder_writeln(&fn_builder,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\t\tif (!"), 0xfe10, {.d_s = eq_fn}}, {_SLIT("_interface_eq(*("), 0xfe10, {.d_s = ptr_value_styp}}, {_SLIT("*)map_get(&b, k, &("), 0xfe10, {.d_s = ptr_value_styp}}, {_SLIT("[]){ 0 }), v)) {"), 0, { .d_c = 0 }}})));
			} break;
		case v__ast__Kind__array: 
			{
				string eq_fn = v__gen__c__Gen_gen_array_equality_fn(g, value.typ);
				strings__Builder_writeln(&fn_builder,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\t\tif (!"), 0xfe10, {.d_s = eq_fn}}, {_SLIT("_arr_eq(*("), 0xfe10, {.d_s = ptr_value_styp}}, {_SLIT("*)map_get(&b, k, &("), 0xfe10, {.d_s = ptr_value_styp}}, {_SLIT("[]){ 0 }), v)) {"), 0, { .d_c = 0 }}})));
			} break;
		case v__ast__Kind__array_fixed: 
			{
				string eq_fn = v__gen__c__Gen_gen_fixed_array_equality_fn(g, value.typ);
				strings__Builder_writeln(&fn_builder,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\t\tif (!"), 0xfe10, {.d_s = eq_fn}}, {_SLIT("_arr_eq(*("), 0xfe10, {.d_s = ptr_value_styp}}, {_SLIT("*)map_get(&b, k, &("), 0xfe10, {.d_s = ptr_value_styp}}, {_SLIT("[]){ 0 }), v)) {"), 0, { .d_c = 0 }}})));
			} break;
		case v__ast__Kind__map: 
			{
				string eq_fn = v__gen__c__Gen_gen_map_equality_fn(g, value.typ);
				strings__Builder_writeln(&fn_builder,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\t\tif (!"), 0xfe10, {.d_s = eq_fn}}, {_SLIT("_map_eq(*("), 0xfe10, {.d_s = ptr_value_styp}}, {_SLIT("*)map_get(&b, k, &("), 0xfe10, {.d_s = ptr_value_styp}}, {_SLIT("[]){ 0 }), v)) {"), 0, { .d_c = 0 }}})));
			} break;
		case v__ast__Kind__alias: 
			{
				string eq_fn = v__gen__c__Gen_gen_alias_equality_fn(g, value.typ);
				strings__Builder_writeln(&fn_builder,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\t\tif (!"), 0xfe10, {.d_s = eq_fn}}, {_SLIT("_alias_eq(*("), 0xfe10, {.d_s = ptr_value_styp}}, {_SLIT("*)map_get(&b, k, &("), 0xfe10, {.d_s = ptr_value_styp}}, {_SLIT("[]){ 0 }), v)) {"), 0, { .d_c = 0 }}})));
			} break;
		case v__ast__Kind__function: 
			{
				strings__Builder_writeln(&fn_builder, _SLIT("\t\tif (*(voidptr*)map_get(&b, k, &(voidptr[]){ 0 }) != v) {"));
			} break;
		case v__ast__Kind__placeholder:
		case v__ast__Kind__void:
		case v__ast__Kind__voidptr:
		case v__ast__Kind__byteptr:
		case v__ast__Kind__charptr:
		case v__ast__Kind__i8:
		case v__ast__Kind__i16:
		case v__ast__Kind__int:
		case v__ast__Kind__i64:
		case v__ast__Kind__isize:
		case v__ast__Kind__byte:
		case v__ast__Kind__u8:
		case v__ast__Kind__u16:
		case v__ast__Kind__u32:
		case v__ast__Kind__u64:
		case v__ast__Kind__usize:
		case v__ast__Kind__f32:
		case v__ast__Kind__f64:
		case v__ast__Kind__char:
		case v__ast__Kind__rune:
		case v__ast__Kind__bool:
		case v__ast__Kind__none_:
		case v__ast__Kind__chan:
		case v__ast__Kind__any:
		case v__ast__Kind__generic_inst:
		case v__ast__Kind__multi_return:
		case v__ast__Kind__enum_:
		case v__ast__Kind__float_literal:
		case v__ast__Kind__int_literal:
		case v__ast__Kind__aggregate:
		case v__ast__Kind__thread:
		default:
			{
				strings__Builder_writeln(&fn_builder,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\tif (*("), 0xfe10, {.d_s = ptr_value_styp}}, {_SLIT("*)map_get(&b, k, &("), 0xfe10, {.d_s = ptr_value_styp}}, {_SLIT("[]){ 0 }) != v) {"), 0, { .d_c = 0 }}})));
			} break;
	}
	;
	strings__Builder_writeln(&fn_builder, _SLIT("\t\t\treturn false;"));
	strings__Builder_writeln(&fn_builder, _SLIT("\t\t}"));
	strings__Builder_writeln(&fn_builder, _SLIT("\t}"));
	strings__Builder_writeln(&fn_builder, _SLIT("\treturn true;"));
	strings__Builder_writeln(&fn_builder, _SLIT("}"));
	array_push((array*)&g->auto_fn_definitions, _MOV((string[]){ string_clone(strings__Builder_str(&fn_builder)) }));
	string _t4 = ptr_styp;
	return _t4;
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_gen_interface_equality_fn(v__gen__c__Gen* g, v__ast__Type left_type) {
bool v__gen__c__Gen_gen_interface_equality_fn_defer_0 = false;
strings__Builder fn_builder;
	v__gen__c__Type left = v__gen__c__Gen_unwrap(g, left_type);
	string ptr_styp = v__gen__c__Gen_typ(g, v__ast__Type_set_nr_muls(left.typ, 0));
	string fn_name = string_replace(ptr_styp, _SLIT("interface "), _SLIT(""));
	if (Array_v__ast__Type_contains(g->generated_eq_fns, left_type)) {
		string _t1 = fn_name;
		return _t1;
	}
	array_push((array*)&g->generated_eq_fns, _MOV((v__ast__Type[]){ left_type }));
	v__ast__TypeInfo info = left.sym->info;
	strings__Builder_writeln(&g->type_definitions,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("static bool "), 0xfe10, {.d_s = ptr_styp}}, {_SLIT("_interface_eq("), 0xfe10, {.d_s = ptr_styp}}, {_SLIT(" a, "), 0xfe10, {.d_s = ptr_styp}}, {_SLIT(" b); // auto"), 0, { .d_c = 0 }}})));
	fn_builder = strings__new_builder(512);
	v__gen__c__Gen_gen_interface_equality_fn_defer_0 = true;
	strings__Builder_writeln(&fn_builder,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("static int v_typeof_interface_idx_"), 0xfe10, {.d_s = ptr_styp}}, {_SLIT("(int sidx); // for auto eq method"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&fn_builder,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("static bool "), 0xfe10, {.d_s = fn_name}}, {_SLIT("_interface_eq("), 0xfe10, {.d_s = ptr_styp}}, {_SLIT(" a, "), 0xfe10, {.d_s = ptr_styp}}, {_SLIT(" b) {"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&fn_builder, _SLIT("\tif (a._typ == b._typ) {"));
	strings__Builder_writeln(&fn_builder,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\tint idx = v_typeof_interface_idx_"), 0xfe10, {.d_s = ptr_styp}}, {_SLIT("(a._typ);"), 0, { .d_c = 0 }}})));
	if ((info)._typ == 463 /* v.ast.Interface */) {
		for (int _t3 = 0; _t3 < (*info._v__ast__Interface).types.len; ++_t3) {
			v__ast__Type typ = ((v__ast__Type*)(*info._v__ast__Interface).types.data)[_t3];
			strings__Builder_writeln(&fn_builder,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\tif (idx == "), 0xfe07, {.d_i32 = typ}}, {_SLIT(") {"), 0, { .d_c = 0 }}})));
			strings__Builder_write_string(&fn_builder, _SLIT("\t\t\treturn "));
			v__ast__Kind _t4 = v__ast__Table_type_kind(g->table, typ);
			
			if (_t4 == (v__ast__Kind__struct_)) {
				string eq_fn = v__gen__c__Gen_gen_struct_equality_fn(g, typ);
				strings__Builder_write_string(&fn_builder,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = eq_fn}}, {_SLIT("_struct_eq(*(a._"), 0xfe10, {.d_s = eq_fn}}, {_SLIT("), *(b._"), 0xfe10, {.d_s = eq_fn}}, {_SLIT("))"), 0, { .d_c = 0 }}})));
			}
			else if (_t4 == (v__ast__Kind__string)) {
				strings__Builder_write_string(&fn_builder, _SLIT("string__eq(*(a._string), *(b._string))"));
			}
			else if (_t4 == (v__ast__Kind__sum_type)) {
				string eq_fn = v__gen__c__Gen_gen_sumtype_equality_fn(g, typ);
				strings__Builder_write_string(&fn_builder,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = eq_fn}}, {_SLIT("_sumtype_eq(*(a._"), 0xfe10, {.d_s = eq_fn}}, {_SLIT("), *(b._"), 0xfe10, {.d_s = eq_fn}}, {_SLIT("))"), 0, { .d_c = 0 }}})));
			}
			else if (_t4 == (v__ast__Kind__array)) {
				string eq_fn = v__gen__c__Gen_gen_array_equality_fn(g, typ);
				strings__Builder_write_string(&fn_builder,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = eq_fn}}, {_SLIT("_arr_eq(*(a._"), 0xfe10, {.d_s = eq_fn}}, {_SLIT("), *(b._"), 0xfe10, {.d_s = eq_fn}}, {_SLIT("))"), 0, { .d_c = 0 }}})));
			}
			else if (_t4 == (v__ast__Kind__array_fixed)) {
				string eq_fn = v__gen__c__Gen_gen_fixed_array_equality_fn(g, typ);
				strings__Builder_write_string(&fn_builder,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = eq_fn}}, {_SLIT("_arr_eq(*(a._"), 0xfe10, {.d_s = eq_fn}}, {_SLIT("), *(b._"), 0xfe10, {.d_s = eq_fn}}, {_SLIT("))"), 0, { .d_c = 0 }}})));
			}
			else if (_t4 == (v__ast__Kind__map)) {
				string eq_fn = v__gen__c__Gen_gen_map_equality_fn(g, typ);
				strings__Builder_write_string(&fn_builder,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = eq_fn}}, {_SLIT("_map_eq(*(a._"), 0xfe10, {.d_s = eq_fn}}, {_SLIT("), *(b._"), 0xfe10, {.d_s = eq_fn}}, {_SLIT("))"), 0, { .d_c = 0 }}})));
			}
			else if (_t4 == (v__ast__Kind__alias)) {
				string eq_fn = v__gen__c__Gen_gen_alias_equality_fn(g, typ);
				strings__Builder_write_string(&fn_builder,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = eq_fn}}, {_SLIT("_alias_eq(*(a._"), 0xfe10, {.d_s = eq_fn}}, {_SLIT("), *(b._"), 0xfe10, {.d_s = eq_fn}}, {_SLIT("))"), 0, { .d_c = 0 }}})));
			}
			else {
				strings__Builder_write_string(&fn_builder, _SLIT("false"));
			};
			strings__Builder_writeln(&fn_builder, _SLIT(";"));
			strings__Builder_writeln(&fn_builder, _SLIT("\t\t}"));
		}
	}
	strings__Builder_writeln(&fn_builder, _SLIT("\t}"));
	strings__Builder_writeln(&fn_builder, _SLIT("\treturn false;"));
	strings__Builder_writeln(&fn_builder, _SLIT("}"));
	string _t5 = fn_name;
	// Defer begin
	if (v__gen__c__Gen_gen_interface_equality_fn_defer_0) {
		array_push((array*)&g->auto_fn_definitions, _MOV((string[]){ string_clone(strings__Builder_str(&fn_builder)) }));
	}
	// Defer end
	return _t5;
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_gen_free_method_for_type(v__gen__c__Gen* g, v__ast__Type typ) {
	string styp = string_replace(v__gen__c__Gen_typ(g, typ), _SLIT("*"), _SLIT(""));
	v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, v__gen__c__Gen_unwrap_generic(g, typ));
	string fn_name = v__gen__c__styp_to_free_fn_name(styp);
	if ((sym->info)._typ == 460 /* v.ast.Alias */) {
		if ((*sym->info._v__ast__Alias).is_import) {
			sym = v__ast__Table_sym(g->table, (*sym->info._v__ast__Alias).parent_type);
		}
	}
	if (v__ast__TypeSymbol_has_method_with_generic_parent(sym, _SLIT("free"))) {
		string _t1 = fn_name;
		return _t1;
	}
	if (sym->info._typ == 446 /* v.ast.Struct */) {
		v__gen__c__Gen_gen_free_for_struct(g, (*sym->info._v__ast__Struct), styp, fn_name);
	}
	else if (sym->info._typ == 441 /* v.ast.Array */) {
		v__gen__c__Gen_gen_free_for_array(g, (*sym->info._v__ast__Array), styp, fn_name);
	}
	else if (sym->info._typ == 442 /* v.ast.Map */) {
		v__gen__c__Gen_gen_free_for_map(g, (*sym->info._v__ast__Map), styp, fn_name);
	}
	
	else {
		println(v__ast__Table_type_str(g->table, typ));
		v__gen__c__verror( str_intp(3, _MOV((StrIntpData[]){{_SLIT("could not generate free method '"), 0xfe10, {.d_s = fn_name}}, {_SLIT("' for type '"), 0xfe10, {.d_s = styp}}, {_SLIT("'"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	;
	string _t2 = fn_name;
	return _t2;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_free_for_struct(v__gen__c__Gen* g, v__ast__Struct info, string styp, string fn_name) {
bool v__gen__c__Gen_gen_free_for_struct_defer_0 = false;
strings__Builder fn_builder;
	strings__Builder_writeln(&g->type_definitions,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("void "), 0xfe10, {.d_s = fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT("* it); // auto"), 0, { .d_c = 0 }}})));
	fn_builder = strings__new_builder(128);
	v__gen__c__Gen_gen_free_for_struct_defer_0 = true;
	strings__Builder_writeln(&fn_builder,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("void "), 0xfe10, {.d_s = fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT("* it) {"), 0, { .d_c = 0 }}})));
	for (int _t1 = 0; _t1 < info.fields.len; ++_t1) {
		v__ast__StructField field = ((v__ast__StructField*)info.fields.data)[_t1];
		v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, v__gen__c__Gen_unwrap_generic(g, field.typ));
		if (!(sym->kind == v__ast__Kind__string || sym->kind == v__ast__Kind__array || sym->kind == v__ast__Kind__map || sym->kind == v__ast__Kind__struct_)) {
			continue;
		}
		string field_styp = string_replace(v__gen__c__Gen_typ(g, field.typ), _SLIT("*"), _SLIT(""));
		string field_styp_fn_name = (v__ast__TypeSymbol_has_method(sym, _SLIT("free")) ? ( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = field_styp}}, {_SLIT("_free"), 0, { .d_c = 0 }}}))) : (v__gen__c__Gen_gen_free_method_for_type(g, field.typ)));
		strings__Builder_writeln(&fn_builder,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = field_styp_fn_name}}, {_SLIT("(&(it->"), 0xfe10, {.d_s = field.name}}, {_SLIT("));"), 0, { .d_c = 0 }}})));
	}
	strings__Builder_writeln(&fn_builder, _SLIT("}"));
// Defer begin
if (v__gen__c__Gen_gen_free_for_struct_defer_0) {
	array_push((array*)&g->auto_fn_definitions, _MOV((string[]){ string_clone(strings__Builder_str(&fn_builder)) }));
}
// Defer end
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_free_for_array(v__gen__c__Gen* g, v__ast__Array info, string styp, string fn_name) {
bool v__gen__c__Gen_gen_free_for_array_defer_0 = false;
strings__Builder fn_builder;
	strings__Builder_writeln(&g->type_definitions,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("void "), 0xfe10, {.d_s = fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT("* it); // auto"), 0, { .d_c = 0 }}})));
	fn_builder = strings__new_builder(128);
	v__gen__c__Gen_gen_free_for_array_defer_0 = true;
	strings__Builder_writeln(&fn_builder,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("void "), 0xfe10, {.d_s = fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT("* it) {"), 0, { .d_c = 0 }}})));
	v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, v__gen__c__Gen_unwrap_generic(g, info.elem_type));
	if (sym->kind == v__ast__Kind__string || sym->kind == v__ast__Kind__array || sym->kind == v__ast__Kind__map || sym->kind == v__ast__Kind__struct_) {
		strings__Builder_writeln(&fn_builder, _SLIT("\tfor (int i = 0; i < it->len; i++) {"));
		string elem_styp = string_replace(v__gen__c__Gen_typ(g, info.elem_type), _SLIT("*"), _SLIT(""));
		string elem_styp_fn_name = (v__ast__TypeSymbol_has_method(sym, _SLIT("free")) ? ( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = elem_styp}}, {_SLIT("_free"), 0, { .d_c = 0 }}}))) : (v__gen__c__Gen_gen_free_method_for_type(g, info.elem_type)));
		strings__Builder_writeln(&fn_builder,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\t"), 0xfe10, {.d_s = elem_styp_fn_name}}, {_SLIT("(&((("), 0xfe10, {.d_s = elem_styp}}, {_SLIT("*)it->data)[i]));"), 0, { .d_c = 0 }}})));
		strings__Builder_writeln(&fn_builder, _SLIT("\t}"));
	}
	strings__Builder_writeln(&fn_builder, _SLIT("\tarray_free(it);"));
	strings__Builder_writeln(&fn_builder, _SLIT("}"));
// Defer begin
if (v__gen__c__Gen_gen_free_for_array_defer_0) {
	array_push((array*)&g->auto_fn_definitions, _MOV((string[]){ string_clone(strings__Builder_str(&fn_builder)) }));
}
// Defer end
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_free_for_map(v__gen__c__Gen* g, v__ast__Map info, string styp, string fn_name) {
bool v__gen__c__Gen_gen_free_for_map_defer_0 = false;
strings__Builder fn_builder;
	strings__Builder_writeln(&g->type_definitions,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("void "), 0xfe10, {.d_s = fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT("* it); // auto"), 0, { .d_c = 0 }}})));
	fn_builder = strings__new_builder(128);
	v__gen__c__Gen_gen_free_for_map_defer_0 = true;
	strings__Builder_writeln(&fn_builder,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("void "), 0xfe10, {.d_s = fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT("* it) {"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&fn_builder, _SLIT("\tmap_free(it);"));
	strings__Builder_writeln(&fn_builder, _SLIT("}"));
// Defer begin
if (v__gen__c__Gen_gen_free_for_map_defer_0) {
	array_push((array*)&g->auto_fn_definitions, _MOV((string[]){ string_clone(strings__Builder_str(&fn_builder)) }));
}
// Defer end
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL string v__gen__c__styp_to_free_fn_name(string styp) {
	string _t1 = string__plus(string_replace_each(styp, new_array_from_c_array(6, 6, sizeof(string), _MOV((string[6]){_SLIT("*"), _SLIT(""), _SLIT("."), _SLIT("__"), _SLIT(" "), _SLIT("__")}))), _SLIT("_free"));
	return _t1;
}

string v__gen__c__type_to_str(StrIntpType x) {
	switch (x) {
		case StrIntpType__si_no_str: 
			{
				string _t1 = _SLIT("no_str");
				return _t1;
			} break;
		case StrIntpType__si_c: 
			{
				string _t2 = _SLIT("c");
				return _t2;
			} break;
		case StrIntpType__si_u8: 
			{
				string _t3 = _SLIT("u8");
				return _t3;
			} break;
		case StrIntpType__si_i8: 
			{
				string _t4 = _SLIT("i8");
				return _t4;
			} break;
		case StrIntpType__si_u16: 
			{
				string _t5 = _SLIT("u16");
				return _t5;
			} break;
		case StrIntpType__si_i16: 
			{
				string _t6 = _SLIT("i16");
				return _t6;
			} break;
		case StrIntpType__si_u32: 
			{
				string _t7 = _SLIT("u32");
				return _t7;
			} break;
		case StrIntpType__si_i32: 
			{
				string _t8 = _SLIT("i32");
				return _t8;
			} break;
		case StrIntpType__si_u64: 
			{
				string _t9 = _SLIT("u64");
				return _t9;
			} break;
		case StrIntpType__si_i64: 
			{
				string _t10 = _SLIT("i64");
				return _t10;
			} break;
		case StrIntpType__si_f32: 
			{
				string _t11 = _SLIT("f32");
				return _t11;
			} break;
		case StrIntpType__si_f64: 
			{
				string _t12 = _SLIT("f64");
				return _t12;
			} break;
		case StrIntpType__si_g32: 
			{
				string _t13 = _SLIT("f32");
				return _t13;
			} break;
		case StrIntpType__si_g64: 
			{
				string _t14 = _SLIT("f64");
				return _t14;
			} break;
		case StrIntpType__si_e32: 
			{
				string _t15 = _SLIT("f32");
				return _t15;
			} break;
		case StrIntpType__si_e64: 
			{
				string _t16 = _SLIT("f64");
				return _t16;
			} break;
		case StrIntpType__si_s: 
			{
				string _t17 = _SLIT("s");
				return _t17;
			} break;
		case StrIntpType__si_p: 
			{
				string _t18 = _SLIT("p");
				return _t18;
			} break;
		case StrIntpType__si_vp: 
			{
				string _t19 = _SLIT("vp");
				return _t19;
			} break;
	}
	;
	return (string){.str=(byteptr)"", .is_lit=1};
}

string v__gen__c__data_str(StrIntpType x) {
	switch (x) {
		case StrIntpType__si_no_str: 
			{
				string _t1 = _SLIT("no_str");
				return _t1;
			} break;
		case StrIntpType__si_c: 
			{
				string _t2 = _SLIT("d_c");
				return _t2;
			} break;
		case StrIntpType__si_u8: 
			{
				string _t3 = _SLIT("d_u8");
				return _t3;
			} break;
		case StrIntpType__si_i8: 
			{
				string _t4 = _SLIT("d_i8");
				return _t4;
			} break;
		case StrIntpType__si_u16: 
			{
				string _t5 = _SLIT("d_u16");
				return _t5;
			} break;
		case StrIntpType__si_i16: 
			{
				string _t6 = _SLIT("d_i16");
				return _t6;
			} break;
		case StrIntpType__si_u32: 
			{
				string _t7 = _SLIT("d_u32");
				return _t7;
			} break;
		case StrIntpType__si_i32: 
			{
				string _t8 = _SLIT("d_i32");
				return _t8;
			} break;
		case StrIntpType__si_u64: 
			{
				string _t9 = _SLIT("d_u64");
				return _t9;
			} break;
		case StrIntpType__si_i64: 
			{
				string _t10 = _SLIT("d_i64");
				return _t10;
			} break;
		case StrIntpType__si_f32: 
			{
				string _t11 = _SLIT("d_f32");
				return _t11;
			} break;
		case StrIntpType__si_f64: 
			{
				string _t12 = _SLIT("d_f64");
				return _t12;
			} break;
		case StrIntpType__si_g32: 
			{
				string _t13 = _SLIT("d_f32");
				return _t13;
			} break;
		case StrIntpType__si_g64: 
			{
				string _t14 = _SLIT("d_f64");
				return _t14;
			} break;
		case StrIntpType__si_e32: 
			{
				string _t15 = _SLIT("d_f32");
				return _t15;
			} break;
		case StrIntpType__si_e64: 
			{
				string _t16 = _SLIT("d_f64");
				return _t16;
			} break;
		case StrIntpType__si_s: 
			{
				string _t17 = _SLIT("d_s");
				return _t17;
			} break;
		case StrIntpType__si_p: 
			{
				string _t18 = _SLIT("d_p");
				return _t18;
			} break;
		case StrIntpType__si_vp: 
			{
				string _t19 = _SLIT("d_vp");
				return _t19;
			} break;
	}
	;
	return (string){.str=(byteptr)"", .is_lit=1};
}

VV_LOCAL_SYMBOL bool v__gen__c__should_use_indent_func(v__ast__Kind kind) {
	bool _t1 = (kind == v__ast__Kind__struct_ || kind == v__ast__Kind__alias || kind == v__ast__Kind__array || kind == v__ast__Kind__array_fixed || kind == v__ast__Kind__map || kind == v__ast__Kind__sum_type || kind == v__ast__Kind__interface_);
	return _t1;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_default(v__gen__c__Gen* g, v__ast__TypeSymbol sym, string styp, string str_fn_name) {
	string convertor = _SLIT("");
	string typename_ = _SLIT("");
	if (Array_int_contains(_const_v__ast__integer_type_idxs, sym.parent_idx)) {
		convertor = _SLIT("int");
		typename_ = _SLIT("int");
	} else if (sym.parent_idx == _const_v__ast__f32_type_idx) {
		convertor = _SLIT("float");
		typename_ = _SLIT("f32");
	} else if (sym.parent_idx == _const_v__ast__f64_type_idx) {
		convertor = _SLIT("double");
		typename_ = _SLIT("f64");
	} else if (sym.parent_idx == _const_v__ast__bool_type_idx) {
		convertor = _SLIT("bool");
		typename_ = _SLIT("bool");
	} else {
		v__gen__c__verror( str_intp(2, _MOV((StrIntpData[]){{_SLIT("could not generate string method for type `"), 0xfe10, {.d_s = styp}}, {_SLIT("`"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	strings__Builder_writeln(&g->type_definitions,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("string "), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT(" it); // auto"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&g->auto_str_funcs,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("string "), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT(" it) {"), 0, { .d_c = 0 }}})));
	if (string__eq(convertor, _SLIT("bool"))) {
		strings__Builder_writeln(&g->auto_str_funcs,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\tstring tmp1 = string__plus(_SLIT(\""), 0xfe10, {.d_s = styp}}, {_SLIT("(\"), ("), 0xfe10, {.d_s = convertor}}, {_SLIT(")it ? _SLIT(\"true\") : _SLIT(\"false\"));"), 0, { .d_c = 0 }}})));
	} else {
		strings__Builder_writeln(&g->auto_str_funcs,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\tstring tmp1 = string__plus(_SLIT(\""), 0xfe10, {.d_s = styp}}, {_SLIT("(\"), tos3("), 0xfe10, {.d_s = typename_}}, {_SLIT("_str(("), 0xfe10, {.d_s = convertor}}, {_SLIT(")it).str));"), 0, { .d_c = 0 }}})));
	}
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tstring tmp2 = string__plus(tmp1, _SLIT(\")\"));"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tstring_free(&tmp1);"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\treturn tmp2;"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("}"));
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_get_str_fn(v__gen__c__Gen* g, v__ast__Type typ) {
	v__ast__Type unwrapped = v__ast__Type_clear_flag(v__ast__Type_set_nr_muls(v__gen__c__Gen_unwrap_generic(g, typ), 0), v__ast__TypeFlag__variadic);
	if (g->pref->nofloat) {
		if (v__ast__Type_alias_eq(typ, _const_v__ast__f32_type)) {
			unwrapped = _const_v__ast__u32_type;
		} else if (v__ast__Type_alias_eq(typ, _const_v__ast__f64_type)) {
			unwrapped = _const_v__ast__u64_type;
		}
	}
	if (v__ast__Type_has_flag(typ, v__ast__TypeFlag__optional)) {
		v__ast__Type_set_flag(unwrapped, v__ast__TypeFlag__optional);
	}
	string styp = v__gen__c__Gen_typ(g, unwrapped);
	v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, unwrapped);
	string str_fn_name = v__gen__c__styp_to_str_fn_name(styp);
	if ((sym->info)._typ == 460 /* v.ast.Alias */) {
		if ((*sym->info._v__ast__Alias).is_import) {
			sym = v__ast__Table_sym(g->table, (*sym->info._v__ast__Alias).parent_type);
			str_fn_name = v__gen__c__styp_to_str_fn_name(sym->name);
		}
	}
	if (v__ast__TypeSymbol_has_method_with_generic_parent(sym, _SLIT("str")) && (sym->info)._typ == 446 /* v.ast.Struct */) {
		str_fn_name = v__gen__c__Gen_generic_fn_name(g, (*sym->info._v__ast__Struct).concrete_types, str_fn_name, false);
	}
	array_push((array*)&g->str_types, _MOV((v__gen__c__StrType[]){ (v__gen__c__StrType){.styp = styp,.typ = unwrapped,} }));
	string _t2 = str_fn_name;
	return _t2;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_final_gen_str(v__gen__c__Gen* g, v__gen__c__StrType typ) {
	if (Array_v__gen__c__StrType_contains(g->generated_str_fns, typ)) {
		return;
	}
	array_push((array*)&g->generated_str_fns, _MOV((v__gen__c__StrType[]){ typ }));
	v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, typ.typ);
	if (v__ast__TypeSymbol_has_method_with_generic_parent(sym, _SLIT("str")) && !v__ast__Type_has_flag(typ.typ, v__ast__TypeFlag__optional)) {
		return;
	}
	string styp = typ.styp;
	string str_fn_name = v__gen__c__styp_to_str_fn_name(styp);
	if (v__ast__Type_has_flag(typ.typ, v__ast__TypeFlag__optional)) {
		v__gen__c__Gen_gen_str_for_option(g, typ.typ, styp, str_fn_name);
		return;
	}
	if (sym->info._typ == 460 /* v.ast.Alias */) {
		if ((*sym->info._v__ast__Alias).is_import) {
			v__gen__c__Gen_gen_str_default(g, *sym, styp, str_fn_name);
		} else {
			v__gen__c__Gen_gen_str_for_alias(g, (*sym->info._v__ast__Alias), styp, str_fn_name);
		}
	}
	else if (sym->info._typ == 441 /* v.ast.Array */) {
		v__gen__c__Gen_gen_str_for_array(g, (*sym->info._v__ast__Array), styp, str_fn_name);
	}
	else if (sym->info._typ == 468 /* v.ast.ArrayFixed */) {
		v__gen__c__Gen_gen_str_for_array_fixed(g, (*sym->info._v__ast__ArrayFixed), styp, str_fn_name);
	}
	else if (sym->info._typ == 474 /* v.ast.Enum */) {
		v__gen__c__Gen_gen_str_for_enum(g, (*sym->info._v__ast__Enum), styp, str_fn_name);
	}
	else if (sym->info._typ == 472 /* v.ast.FnType */) {
		v__gen__c__Gen_gen_str_for_fn_type(g, (*sym->info._v__ast__FnType), styp, str_fn_name);
	}
	else if (sym->info._typ == 446 /* v.ast.Struct */) {
		v__gen__c__Gen_gen_str_for_struct(g, (*sym->info._v__ast__Struct), styp, str_fn_name);
	}
	else if (sym->info._typ == 442 /* v.ast.Map */) {
		v__gen__c__Gen_gen_str_for_map(g, (*sym->info._v__ast__Map), styp, str_fn_name);
	}
	else if (sym->info._typ == 471 /* v.ast.MultiReturn */) {
		v__gen__c__Gen_gen_str_for_multi_return(g, (*sym->info._v__ast__MultiReturn), styp, str_fn_name);
	}
	else if (sym->info._typ == 464 /* v.ast.SumType */) {
		v__gen__c__Gen_gen_str_for_union_sum_type(g, (*sym->info._v__ast__SumType), styp, str_fn_name);
	}
	else if (sym->info._typ == 463 /* v.ast.Interface */) {
		v__gen__c__Gen_gen_str_for_interface(g, (*sym->info._v__ast__Interface), styp, str_fn_name);
	}
	else if (sym->info._typ == 469 /* v.ast.Chan */) {
		v__gen__c__Gen_gen_str_for_chan(g, (*sym->info._v__ast__Chan), styp, str_fn_name);
	}
	else if (sym->info._typ == 470 /* v.ast.Thread */) {
		v__gen__c__Gen_gen_str_for_thread(g, (*sym->info._v__ast__Thread), styp, str_fn_name);
	}
	
	else {
		v__gen__c__verror( str_intp(3, _MOV((StrIntpData[]){{_SLIT("could not generate string method `"), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("` for type `"), 0xfe10, {.d_s = styp}}, {_SLIT("`"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_option(v__gen__c__Gen* g, v__ast__Type typ, string styp, string str_fn_name) {
	v__ast__Type parent_type = v__ast__Type_clear_flag(typ, v__ast__TypeFlag__optional);
	v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, parent_type);
	multi_return_bool_bool_int mr_6203 = v__ast__TypeSymbol_str_method_info(sym);
	bool sym_has_str_method = mr_6203.arg0;
	string parent_str_fn_name = v__gen__c__Gen_get_str_fn(g, parent_type);
	strings__Builder_writeln(&g->type_definitions,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("string "), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT(" it); // auto"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&g->auto_str_funcs,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("string "), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT(" it) { return indent_"), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("(it, 0); }"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&g->type_definitions,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("string indent_"), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT(" it, int indent_count); // auto"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&g->auto_str_funcs,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("string indent_"), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT(" it, int indent_count) {"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tstring res;"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tif (it.state == 0) {"));
	if (sym->kind == v__ast__Kind__string) {
		string tmp_res =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = parent_str_fn_name}}, {_SLIT("(*("), 0xfe10, {.d_s = sym->cname}}, {_SLIT("*)it.data)"), 0, { .d_c = 0 }}}));
		strings__Builder_writeln(&g->auto_str_funcs,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\tres = "), 0xfe10, {.d_s = str_intp_sq(tmp_res)}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
	} else if (v__gen__c__should_use_indent_func(sym->kind) && !sym_has_str_method) {
		strings__Builder_writeln(&g->auto_str_funcs,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\tres = indent_"), 0xfe10, {.d_s = parent_str_fn_name}}, {_SLIT("(*("), 0xfe10, {.d_s = sym->cname}}, {_SLIT("*)it.data, indent_count);"), 0, { .d_c = 0 }}})));
	} else {
		strings__Builder_writeln(&g->auto_str_funcs,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\tres = "), 0xfe10, {.d_s = parent_str_fn_name}}, {_SLIT("(*("), 0xfe10, {.d_s = sym->cname}}, {_SLIT("*)it.data);"), 0, { .d_c = 0 }}})));
	}
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t} else {"));
	string tmp_str = str_intp_sub(_SLIT("error: %%"), _SLIT("IError_str(it.err)"));
	strings__Builder_writeln(&g->auto_str_funcs,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\tres = "), 0xfe10, {.d_s = tmp_str}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t}"));
	strings__Builder_writeln(&g->auto_str_funcs,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\treturn "), 0xfe10, {.d_s = str_intp_sub(_SLIT("Option(%%)"), _SLIT("res"))}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("}"));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_alias(v__gen__c__Gen* g, v__ast__Alias info, string styp, string str_fn_name) {
	string parent_str_fn_name = v__gen__c__Gen_get_str_fn(g, info.parent_type);
	string clean_type_v_type_name = v__util__strip_main_name(string_replace(styp, _SLIT("__"), _SLIT(".")));
	strings__Builder_writeln(&g->type_definitions,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("static string "), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT(" it); // auto"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&g->auto_str_funcs,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("static string "), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT(" it) { return indent_"), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("(it, 0); }"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&g->type_definitions,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("static string indent_"), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT(" it, int indent_count); // auto"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&g->auto_str_funcs,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("static string indent_"), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT(" it, int indent_count) {"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tstring indents = string_repeat(_SLIT(\"    \"), indent_count);"));
	strings__Builder_writeln(&g->auto_str_funcs,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\tstring tmp_ds = "), 0xfe10, {.d_s = parent_str_fn_name}}, {_SLIT("(it);"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&g->auto_str_funcs,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\tstring res = str_intp(3, _MOV((StrIntpData[]){\n		{_SLIT0, "), 0xfe10, {.d_s = _const_v__gen__c__si_s_code}}, {_SLIT(", {.d_s = indents }},\n		{_SLIT(\""), 0xfe10, {.d_s = clean_type_v_type_name}}, {_SLIT("(\"), "), 0xfe10, {.d_s = _const_v__gen__c__si_s_code}}, {_SLIT(", {.d_s = tmp_ds }},\n		{_SLIT(\")\"), 0, {.d_c = 0 }}\n	}));"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tstring_free(&indents);"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tstring_free(&tmp_ds);"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\treturn res;"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("}"));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_multi_return(v__gen__c__Gen* g, v__ast__MultiReturn info, string styp, string str_fn_name) {
	strings__Builder_writeln(&g->type_definitions,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("static string "), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT(" a); // auto"), 0, { .d_c = 0 }}})));
	strings__Builder fn_builder = strings__new_builder(512);
	strings__Builder_writeln(&fn_builder,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("static string "), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT(" a) {"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&fn_builder,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\tstrings__Builder sb = strings__new_builder("), 0xfe07, {.d_i32 = info.types.len}}, {_SLIT(" * 10);"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&fn_builder, _SLIT("\tstrings__Builder_write_string(&sb, _SLIT(\"(\"));"));
	for (int i = 0; i < info.types.len; ++i) {
		v__ast__Type typ = ((v__ast__Type*)info.types.data)[i];
		v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, typ);
		bool is_arg_ptr = v__ast__Type_is_ptr(typ);
		multi_return_bool_bool_int mr_9421 = v__ast__TypeSymbol_str_method_info(sym);
		bool sym_has_str_method = mr_9421.arg0;
		bool str_method_expects_ptr = mr_9421.arg1;
		string arg_str_fn_name = v__gen__c__Gen_get_str_fn(g, typ);
		if (v__gen__c__should_use_indent_func(sym->kind) && !sym_has_str_method) {
			strings__Builder_writeln(&fn_builder,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\tstrings__Builder_write_string(&sb, "), 0xfe10, {.d_s = arg_str_fn_name}}, {_SLIT("(a.arg"), 0xfe07, {.d_i32 = i}}, {_SLIT("));"), 0, { .d_c = 0 }}})));
		} else if (sym->kind == v__ast__Kind__f32 || sym->kind == v__ast__Kind__f64) {
			if (sym->kind == v__ast__Kind__f32) {
				string tmp_val = str_intp_g32( str_intp(2, _MOV((StrIntpData[]){{_SLIT("a.arg"), 0xfe07, {.d_i32 = i}}, {_SLIT0, 0, { .d_c = 0 }}})));
				strings__Builder_writeln(&fn_builder,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\tstrings__Builder_write_string(&sb, "), 0xfe10, {.d_s = tmp_val}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
			} else {
				string tmp_val = str_intp_g64( str_intp(2, _MOV((StrIntpData[]){{_SLIT("a.arg"), 0xfe07, {.d_i32 = i}}, {_SLIT0, 0, { .d_c = 0 }}})));
				strings__Builder_writeln(&fn_builder,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\tstrings__Builder_write_string(&sb, "), 0xfe10, {.d_s = tmp_val}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
			}
		} else if (sym->kind == v__ast__Kind__string) {
			string tmp_str = str_intp_sq( str_intp(2, _MOV((StrIntpData[]){{_SLIT("a.arg"), 0xfe07, {.d_i32 = i}}, {_SLIT0, 0, { .d_c = 0 }}})));
			strings__Builder_writeln(&fn_builder,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\tstrings__Builder_write_string(&sb, "), 0xfe10, {.d_s = tmp_str}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
		} else if (sym->kind == v__ast__Kind__function) {
			strings__Builder_writeln(&fn_builder,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\tstrings__Builder_write_string(&sb, "), 0xfe10, {.d_s = arg_str_fn_name}}, {_SLIT("());"), 0, { .d_c = 0 }}})));
		} else {
			multi_return_string_string mr_10246 = v__gen__c__deref_kind(str_method_expects_ptr, is_arg_ptr, typ);
			string deref = mr_10246.arg0;
			string deref_label = mr_10246.arg1;
			strings__Builder_writeln(&fn_builder,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\tstrings__Builder_write_string(&sb, _SLIT(\""), 0xfe10, {.d_s = deref_label}}, {_SLIT("\"));"), 0, { .d_c = 0 }}})));
			strings__Builder_writeln(&fn_builder,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\tstrings__Builder_write_string(&sb, "), 0xfe10, {.d_s = arg_str_fn_name}}, {_SLIT("( "), 0xfe10, {.d_s = deref}}, {_SLIT(" a.arg"), 0xfe07, {.d_i32 = i}}, {_SLIT("));"), 0, { .d_c = 0 }}})));
		}
		if (i != info.types.len - 1) {
			strings__Builder_writeln(&fn_builder, _SLIT("\tstrings__Builder_write_string(&sb, _SLIT(\", \"));"));
		}
	}
	strings__Builder_writeln(&fn_builder, _SLIT("\tstrings__Builder_write_string(&sb, _SLIT(\")\"));"));
	strings__Builder_writeln(&fn_builder, _SLIT("\tstring res = strings__Builder_str(&sb);"));
	strings__Builder_writeln(&fn_builder, _SLIT("\tstrings__Builder_free(&sb);"));
	strings__Builder_writeln(&fn_builder, _SLIT("\treturn res;"));
	strings__Builder_writeln(&fn_builder, _SLIT("}"));
	array_push((array*)&g->auto_fn_definitions, _MOV((string[]){ string_clone(strings__Builder_str(&fn_builder)) }));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_enum(v__gen__c__Gen* g, v__ast__Enum info, string styp, string str_fn_name) {
	string s = v__util__no_dots(styp);
	strings__Builder_writeln(&g->type_definitions,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("static string "), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT(" it); // auto"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&g->auto_str_funcs,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("static string "), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT(" it) { /* gen_str_for_enum */"), 0, { .d_c = 0 }}})));
	if (info.is_flag) {
		string clean_name = v__util__strip_main_name(string_replace(styp, _SLIT("__"), _SLIT(".")));
		strings__Builder_writeln(&g->auto_str_funcs,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\tstring ret = _SLIT(\""), 0xfe10, {.d_s = clean_name}}, {_SLIT("{\");"), 0, { .d_c = 0 }}})));
		strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tint first = 1;"));
		for (int i = 0; i < info.vals.len; ++i) {
			string val = ((string*)info.vals.data)[i];
			strings__Builder_writeln(&g->auto_str_funcs,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\tif (it & (1 << "), 0xfe07, {.d_i32 = i}}, {_SLIT(")) {if (!first) {ret = string__plus(ret, _SLIT(\" | \"));} ret = string__plus(ret, _SLIT(\"."), 0xfe10, {.d_s = val}}, {_SLIT("\")); first = 0;}"), 0, { .d_c = 0 }}})));
		}
		strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tret = string__plus(ret, _SLIT(\"}\"));"));
		strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\treturn ret;"));
	} else {
		strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tswitch(it) {"));
		Array_string seen = __new_array_with_default(info.vals.len, 0, sizeof(string), &(string[]){_SLIT("")});
		for (int _t1 = 0; _t1 < info.vals.len; ++_t1) {
			string val = ((string*)info.vals.data)[_t1];
			if (info.is_multi_allowed && Array_string_contains(seen, val)) {
				continue;
			} else if (info.is_multi_allowed) {
				array_push((array*)&seen, _MOV((string[]){ string_clone(val) }));
			}
			strings__Builder_writeln(&g->auto_str_funcs,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\t\tcase "), 0xfe10, {.d_s = s}}, {_SLIT("__"), 0xfe10, {.d_s = val}}, {_SLIT(": return _SLIT(\""), 0xfe10, {.d_s = val}}, {_SLIT("\");"), 0, { .d_c = 0 }}})));
		}
		strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t\tdefault: return _SLIT(\"unknown enum value\");"));
		strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t}"));
	}
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("}"));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_interface(v__gen__c__Gen* g, v__ast__Interface info, string styp, string str_fn_name) {
	strings__Builder_writeln(&g->type_definitions,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("static string "), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT(" x); // auto"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&g->auto_str_funcs,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("static string "), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT(" x) { return indent_"), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("(x, 0); }"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&g->type_definitions,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("static string indent_"), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT(" x, int indent_count); // auto"), 0, { .d_c = 0 }}})));
	strings__Builder fn_builder = strings__new_builder(512);
	string clean_interface_v_type_name = string_replace(styp, _SLIT("__"), _SLIT("."));
	if (string_ends_with(styp, _SLIT("*"))) {
		clean_interface_v_type_name = string__plus(_SLIT("&"), string_replace(clean_interface_v_type_name, _SLIT("*"), _SLIT("")));
	}
	if (string_contains(clean_interface_v_type_name, _SLIT("_T_"))) {
		clean_interface_v_type_name = string__plus(string_replace(string_replace(string_replace(clean_interface_v_type_name, _SLIT("Array_"), _SLIT("[]")), _SLIT("_T_"), _SLIT("<")), _SLIT("_"), _SLIT(", ")), _SLIT(">"));
	}
	clean_interface_v_type_name = v__util__strip_main_name(clean_interface_v_type_name);
	strings__Builder_writeln(&fn_builder,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("static string indent_"), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT(" x, int indent_count) { /* gen_str_for_interface */"), 0, { .d_c = 0 }}})));
	for (int _t1 = 0; _t1 < info.types.len; ++_t1) {
		v__ast__Type typ = ((v__ast__Type*)info.types.data)[_t1];
		v__ast__TypeSymbol* subtype = v__ast__Table_sym(g->table, typ);
		string func_name = v__gen__c__Gen_get_str_fn(g, typ);
		multi_return_bool_bool_int mr_13684 = v__ast__TypeSymbol_str_method_info(subtype);
		bool sym_has_str_method = mr_13684.arg0;
		bool str_method_expects_ptr = mr_13684.arg1;
		if (v__gen__c__should_use_indent_func(subtype->kind) && !sym_has_str_method) {
			func_name =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("indent_"), 0xfe10, {.d_s = func_name}}, {_SLIT0, 0, { .d_c = 0 }}}));
		}
		string deref = (sym_has_str_method && str_method_expects_ptr ? (_SLIT(" ")) : (_SLIT("*")));
		if (v__ast__Type_alias_eq(typ, _const_v__ast__string_type)) {
			string val =  str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = func_name}}, {_SLIT("("), 0xfe10, {.d_s = deref}}, {_SLIT("("), 0xfe10, {.d_s = subtype->cname}}, {_SLIT("*)x._"), 0xfe10, {.d_s = subtype->cname}}, {_SLIT0, 0, { .d_c = 0 }}}));
			if (v__gen__c__should_use_indent_func(subtype->kind) && !sym_has_str_method) {
				val = /*f*/string__plus(val, _SLIT(", indent_count"));
			}
			val = /*f*/string__plus(val, _SLIT(")"));
			string res =  str_intp(4, _MOV((StrIntpData[]){{_SLIT("str_intp(2, _MOV((StrIntpData[]){\n				{_SLIT(\""), 0xfe10, {.d_s = clean_interface_v_type_name}}, {_SLIT("(\'\"), "), 0xfe10, {.d_s = _const_v__gen__c__si_s_code}}, {_SLIT(", {.d_s = "), 0xfe10, {.d_s = val}}, {_SLIT("}},\n				{_SLIT(\"\')\"), 0, {.d_c = 0 }}\n			}))"), 0, { .d_c = 0 }}}));
			strings__Builder_write_string(&fn_builder,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\tif (x._typ == _"), 0xfe10, {.d_s = styp}}, {_SLIT("_"), 0xfe10, {.d_s = subtype->cname}}, {_SLIT("_index)"), 0, { .d_c = 0 }}})));
			strings__Builder_write_string(&fn_builder,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(" return "), 0xfe10, {.d_s = res}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
		} else {
			string val =  str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = func_name}}, {_SLIT("("), 0xfe10, {.d_s = deref}}, {_SLIT("("), 0xfe10, {.d_s = subtype->cname}}, {_SLIT("*)x._"), 0xfe10, {.d_s = subtype->cname}}, {_SLIT0, 0, { .d_c = 0 }}}));
			if (v__gen__c__should_use_indent_func(subtype->kind) && !sym_has_str_method) {
				val = /*f*/string__plus(val, _SLIT(", indent_count"));
			}
			val = /*f*/string__plus(val, _SLIT(")"));
			string res =  str_intp(4, _MOV((StrIntpData[]){{_SLIT("str_intp(2, _MOV((StrIntpData[]){\n				{_SLIT(\""), 0xfe10, {.d_s = clean_interface_v_type_name}}, {_SLIT("(\"), "), 0xfe10, {.d_s = _const_v__gen__c__si_s_code}}, {_SLIT(", {.d_s = "), 0xfe10, {.d_s = val}}, {_SLIT("}},\n				{_SLIT(\")\"), 0, {.d_c = 0 }}\n			}))"), 0, { .d_c = 0 }}}));
			strings__Builder_write_string(&fn_builder,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\tif (x._typ == _"), 0xfe10, {.d_s = styp}}, {_SLIT("_"), 0xfe10, {.d_s = subtype->cname}}, {_SLIT("_index)"), 0, { .d_c = 0 }}})));
			strings__Builder_write_string(&fn_builder,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(" return "), 0xfe10, {.d_s = res}}, {_SLIT(";\n"), 0, { .d_c = 0 }}})));
		}
	}
	strings__Builder_writeln(&fn_builder, _SLIT("\treturn _SLIT(\"unknown interface value\");"));
	strings__Builder_writeln(&fn_builder, _SLIT("}"));
	array_push((array*)&g->auto_fn_definitions, _MOV((string[]){ string_clone(strings__Builder_str(&fn_builder)) }));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_union_sum_type(v__gen__c__Gen* g, v__ast__SumType info, string styp, string str_fn_name) {
	strings__Builder_writeln(&g->type_definitions,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("static string "), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT(" x); // auto"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&g->auto_str_funcs,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("static string "), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT(" x) { return indent_"), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("(x, 0); }"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&g->type_definitions,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("static string indent_"), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT(" x, int indent_count); // auto"), 0, { .d_c = 0 }}})));
	strings__Builder fn_builder = strings__new_builder(512);
	strings__Builder_writeln(&fn_builder,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("static string indent_"), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT(" x, int indent_count) {"), 0, { .d_c = 0 }}})));
	string clean_sum_type_v_type_name = _SLIT("");
	if (info.is_anon) {
		Array_string _t1 = __new_array(0, 0, sizeof(string));
		Array_v__ast__Type _t1_orig = info.variants;
		int _t1_len = _t1_orig.len;
		_t1 = __new_array(0, _t1_len, sizeof(string));

		for (int _t2 = 0; _t2 < _t1_len; ++_t2) {
			v__ast__Type it = ((v__ast__Type*) _t1_orig.data)[_t2];
			string ti = v__util__strip_main_name(v__ast__Table_sym(g->table, it)->name);
			array_push((array*)&_t1, &ti);
		}
		Array_string variant_names =_t1;
		clean_sum_type_v_type_name =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("("), 0xfe10, {.d_s = Array_string_join(variant_names, _SLIT(" | "))}}, {_SLIT(")"), 0, { .d_c = 0 }}}));
	} else {
		clean_sum_type_v_type_name = string_replace(styp, _SLIT("__"), _SLIT("."));
		if (string_ends_with(styp, _SLIT("*"))) {
			clean_sum_type_v_type_name = string__plus(_SLIT("&"), string_replace(clean_sum_type_v_type_name, _SLIT("*"), _SLIT("")));
		}
		if (string_contains(clean_sum_type_v_type_name, _SLIT("_T_"))) {
			clean_sum_type_v_type_name = string__plus(string_replace(string_replace(string_replace(clean_sum_type_v_type_name, _SLIT("Array_"), _SLIT("[]")), _SLIT("_T_"), _SLIT("<")), _SLIT("_"), _SLIT(", ")), _SLIT(">"));
		}
		clean_sum_type_v_type_name = v__util__strip_main_name(clean_sum_type_v_type_name);
	}
	strings__Builder_writeln(&fn_builder, _SLIT("\tswitch(x._typ) {"));
	for (int _t3 = 0; _t3 < info.variants.len; ++_t3) {
		v__ast__Type typ = ((v__ast__Type*)info.variants.data)[_t3];
		string typ_str = v__gen__c__Gen_typ(g, typ);
		string func_name = v__gen__c__Gen_get_str_fn(g, typ);
		v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, typ);
		multi_return_bool_bool_int mr_16611 = v__ast__TypeSymbol_str_method_info(sym);
		bool sym_has_str_method = mr_16611.arg0;
		bool str_method_expects_ptr = mr_16611.arg1;
		string deref = (sym_has_str_method && str_method_expects_ptr ? (_SLIT(" ")) : (_SLIT("*")));
		if (v__gen__c__should_use_indent_func(sym->kind) && !sym_has_str_method) {
			func_name =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("indent_"), 0xfe10, {.d_s = func_name}}, {_SLIT0, 0, { .d_c = 0 }}}));
		}
		if (v__ast__Type_alias_eq(typ, _const_v__ast__string_type)) {
			string val =  str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = func_name}}, {_SLIT("("), 0xfe10, {.d_s = deref}}, {_SLIT("("), 0xfe10, {.d_s = typ_str}}, {_SLIT("*)x._"), 0xfe10, {.d_s = sym->cname}}, {_SLIT0, 0, { .d_c = 0 }}}));
			if (v__gen__c__should_use_indent_func(sym->kind) && !sym_has_str_method) {
				val = /*f*/string__plus(val, _SLIT(", indent_count"));
			}
			val = /*f*/string__plus(val, _SLIT(")"));
			string res =  str_intp(4, _MOV((StrIntpData[]){{_SLIT("str_intp(2, _MOV((StrIntpData[]){\n				{_SLIT(\""), 0xfe10, {.d_s = clean_sum_type_v_type_name}}, {_SLIT("(\'\"), "), 0xfe10, {.d_s = _const_v__gen__c__si_s_code}}, {_SLIT(", {.d_s = "), 0xfe10, {.d_s = val}}, {_SLIT("}},\n				{_SLIT(\"\')\"), 0, {.d_c = 0 }}\n			}))"), 0, { .d_c = 0 }}}));
			strings__Builder_write_string(&fn_builder,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\tcase "), 0xfe07, {.d_i32 = typ}}, {_SLIT(": return "), 0xfe10, {.d_s = res}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
		} else {
			string val =  str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = func_name}}, {_SLIT("("), 0xfe10, {.d_s = deref}}, {_SLIT("("), 0xfe10, {.d_s = typ_str}}, {_SLIT("*)x._"), 0xfe10, {.d_s = sym->cname}}, {_SLIT0, 0, { .d_c = 0 }}}));
			if (v__gen__c__should_use_indent_func(sym->kind) && !sym_has_str_method) {
				val = /*f*/string__plus(val, _SLIT(", indent_count"));
			}
			val = /*f*/string__plus(val, _SLIT(")"));
			string res =  str_intp(4, _MOV((StrIntpData[]){{_SLIT("str_intp(2, _MOV((StrIntpData[]){\n				{_SLIT(\""), 0xfe10, {.d_s = clean_sum_type_v_type_name}}, {_SLIT("(\"), "), 0xfe10, {.d_s = _const_v__gen__c__si_s_code}}, {_SLIT(", {.d_s = "), 0xfe10, {.d_s = val}}, {_SLIT("}},\n				{_SLIT(\")\"), 0, {.d_c = 0 }}\n			}))"), 0, { .d_c = 0 }}}));
			strings__Builder_write_string(&fn_builder,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\tcase "), 0xfe07, {.d_i32 = typ}}, {_SLIT(": return "), 0xfe10, {.d_s = res}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
		}
	}
	strings__Builder_writeln(&fn_builder, _SLIT("\t\tdefault: return _SLIT(\"unknown sum type value\");"));
	strings__Builder_writeln(&fn_builder, _SLIT("\t}"));
	strings__Builder_writeln(&fn_builder, _SLIT("}"));
	array_push((array*)&g->auto_fn_definitions, _MOV((string[]){ string_clone(strings__Builder_str(&fn_builder)) }));
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_fn_decl_str(v__gen__c__Gen* g, v__ast__FnType info) {
	string fn_str = _SLIT("fn (");
	for (int i = 0; i < info.func.params.len; ++i) {
		v__ast__Param arg = ((v__ast__Param*)info.func.params.data)[i];
		if (arg.is_mut) {
			fn_str = /*f*/string__plus(fn_str, _SLIT("mut "));
		}
		if (i > 0) {
			fn_str = /*f*/string__plus(fn_str, _SLIT(", "));
		}
		fn_str = /*f*/string__plus(fn_str, v__util__strip_main_name(v__ast__Table_get_type_name(g->table, v__gen__c__Gen_unwrap_generic(g, arg.typ))));
	}
	fn_str = /*f*/string__plus(fn_str, _SLIT(")"));
	if (v__ast__Type_alias_eq(info.func.return_type, _const_v__ast__ovoid_type)) {
		fn_str = /*f*/string__plus(fn_str, _SLIT(" ?"));
	} else if (!v__ast__Type_alias_eq(info.func.return_type, _const_v__ast__void_type)) {
		string x = v__util__strip_main_name(v__ast__Table_get_type_name(g->table, v__gen__c__Gen_unwrap_generic(g, info.func.return_type)));
		if (v__ast__Type_has_flag(info.func.return_type, v__ast__TypeFlag__optional)) {
			fn_str = /*f*/string__plus(fn_str,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(" ?"), 0xfe10, {.d_s = x}}, {_SLIT0, 0, { .d_c = 0 }}})));
		} else {
			fn_str = /*f*/string__plus(fn_str,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(" "), 0xfe10, {.d_s = x}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
	}
	string _t1 = fn_str;
	return _t1;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_fn_type(v__gen__c__Gen* g, v__ast__FnType info, string styp, string str_fn_name) {
	strings__Builder_writeln(&g->type_definitions,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("static string "), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("(); // auto"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&g->auto_str_funcs,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("static string "), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("() { return _SLIT(\""), 0xfe10, {.d_s = v__gen__c__Gen_fn_decl_str(g, info)}}, {_SLIT("\");}"), 0, { .d_c = 0 }}})));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_chan(v__gen__c__Gen* g, v__ast__Chan info, string styp, string str_fn_name) {
	string elem_type_name = v__util__strip_main_name(v__ast__Table_get_type_name(g->table, v__gen__c__Gen_unwrap_generic(g, info.elem_type)));
	strings__Builder_writeln(&g->type_definitions,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("static string "), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT(" x); // auto"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&g->auto_str_funcs,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("static string "), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT(" x) { return sync__Channel_auto_str(x, _SLIT(\""), 0xfe10, {.d_s = elem_type_name}}, {_SLIT("\")); }"), 0, { .d_c = 0 }}})));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_thread(v__gen__c__Gen* g, v__ast__Thread info, string styp, string str_fn_name) {
	string ret_type_name = v__util__strip_main_name(v__ast__Table_get_type_name(g->table, info.return_type));
	strings__Builder_writeln(&g->type_definitions,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("static string "), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT(" _); // auto}"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&g->auto_str_funcs,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("static string "), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT(" _) { return _SLIT(\"thread("), 0xfe10, {.d_s = ret_type_name}}, {_SLIT(")\");}"), 0, { .d_c = 0 }}})));
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL string v__gen__c__styp_to_str_fn_name(string styp) {
	string _t1 = string__plus(string_replace_each(styp, new_array_from_c_array(6, 6, sizeof(string), _MOV((string[6]){_SLIT("*"), _SLIT(""), _SLIT("."), _SLIT("__"), _SLIT(" "), _SLIT("__")}))), _SLIT("_str"));
	return _t1;
}

VV_LOCAL_SYMBOL multi_return_string_string v__gen__c__deref_kind(bool str_method_expects_ptr, bool is_elem_ptr, v__ast__Type typ) {
	if (str_method_expects_ptr != is_elem_ptr) {
		if (is_elem_ptr) {
			return (multi_return_string_string){.arg0=string_repeat(_SLIT("*"), v__ast__Type_nr_muls(typ)), .arg1=string_repeat(_SLIT("&"), v__ast__Type_nr_muls(typ))};
		} else {
			return (multi_return_string_string){.arg0=_SLIT("&"), .arg1=_SLIT("")};
		}
	}
	return (multi_return_string_string){.arg0=_SLIT(""), .arg1=_SLIT("")};
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_array(v__gen__c__Gen* g, v__ast__Array info, string styp, string str_fn_name) {
	v__ast__Type typ = info.elem_type;
	v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, info.elem_type);
	if ((sym->info)._typ == 460 /* v.ast.Alias */) {
		typ = (*sym->info._v__ast__Alias).parent_type;
		sym = v__ast__Table_sym(g->table, typ);
	}
	string field_styp = v__gen__c__Gen_typ(g, typ);
	bool is_elem_ptr = v__ast__Type_is_ptr(typ);
	multi_return_bool_bool_int mr_20686 = v__ast__TypeSymbol_str_method_info(sym);
	bool sym_has_str_method = mr_20686.arg0;
	bool str_method_expects_ptr = mr_20686.arg1;
	string elem_str_fn_name = v__gen__c__Gen_get_str_fn(g, typ);
	if (sym->kind == v__ast__Kind__byte) {
		elem_str_fn_name = string__plus(elem_str_fn_name, _SLIT("_escaped"));
	}
	strings__Builder_writeln(&g->type_definitions,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("static string "), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT(" a); // auto"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&g->auto_str_funcs,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("static string "), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT(" a) { return indent_"), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("(a, 0);}"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&g->type_definitions,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("static string indent_"), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT(" a, int indent_count); // auto"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&g->auto_str_funcs,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("static string indent_"), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT(" a, int indent_count) {"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tstrings__Builder sb = strings__new_builder(a.len * 10);"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tstrings__Builder_write_string(&sb, _SLIT(\"[\"));"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tfor (int i = 0; i < a.len; ++i) {"));
	if (sym->kind == v__ast__Kind__function) {
		strings__Builder_writeln(&g->auto_str_funcs,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\tstring x = "), 0xfe10, {.d_s = elem_str_fn_name}}, {_SLIT("();"), 0, { .d_c = 0 }}})));
	} else {
		if (sym->kind == v__ast__Kind__array_fixed) {
			strings__Builder_writeln(&g->auto_str_funcs,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\t"), 0xfe10, {.d_s = field_styp}}, {_SLIT(" it;"), 0, { .d_c = 0 }}})));
			strings__Builder_writeln(&g->auto_str_funcs,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\tmemcpy(*("), 0xfe10, {.d_s = field_styp}}, {_SLIT("*)it, (byte*)array_get(a, i), sizeof("), 0xfe10, {.d_s = field_styp}}, {_SLIT("));"), 0, { .d_c = 0 }}})));
		} else {
			strings__Builder_writeln(&g->auto_str_funcs,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\t"), 0xfe10, {.d_s = field_styp}}, {_SLIT(" it = *("), 0xfe10, {.d_s = field_styp}}, {_SLIT("*)array_get(a, i);"), 0, { .d_c = 0 }}})));
		}
		if (v__gen__c__should_use_indent_func(sym->kind) && !sym_has_str_method) {
			if (is_elem_ptr) {
				strings__Builder_writeln(&g->auto_str_funcs,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\tstring x = indent_"), 0xfe10, {.d_s = elem_str_fn_name}}, {_SLIT("(*it, indent_count);"), 0, { .d_c = 0 }}})));
			} else {
				strings__Builder_writeln(&g->auto_str_funcs,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\tstring x = indent_"), 0xfe10, {.d_s = elem_str_fn_name}}, {_SLIT("(it, indent_count);"), 0, { .d_c = 0 }}})));
			}
		} else if (sym->kind == v__ast__Kind__f32 || sym->kind == v__ast__Kind__f64) {
			if (sym->kind == v__ast__Kind__f32) {
				strings__Builder_writeln(&g->auto_str_funcs,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\tstring x = "), 0xfe10, {.d_s = str_intp_g32(_SLIT("it"))}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
			} else {
				strings__Builder_writeln(&g->auto_str_funcs,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\tstring x = "), 0xfe10, {.d_s = str_intp_g64(_SLIT("it"))}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
			}
		} else if (sym->kind == v__ast__Kind__rune) {
			strings__Builder_writeln(&g->auto_str_funcs,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\tstring x = str_intp(2, _MOV((StrIntpData[]){{_SLIT(\"`\"), "), 0xfe10, {.d_s = _const_v__gen__c__si_s_code}}, {_SLIT(", {.d_s = "), 0xfe10, {.d_s = elem_str_fn_name}}, {_SLIT("(it) }}, {_SLIT(\"`\"), 0, {.d_c = 0 }}}));\n"), 0, { .d_c = 0 }}})));
		} else if (sym->kind == v__ast__Kind__string) {
			strings__Builder_writeln(&g->auto_str_funcs,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\tstring x = str_intp(2, _MOV((StrIntpData[]){{_SLIT(\"\'\"), "), 0xfe10, {.d_s = _const_v__gen__c__si_s_code}}, {_SLIT(", {.d_s = it }}, {_SLIT(\"\'\"), 0, {.d_c = 0 }}}));\n"), 0, { .d_c = 0 }}})));
		} else {
			multi_return_string_string mr_23021 = v__gen__c__deref_kind(str_method_expects_ptr, is_elem_ptr, typ);
			string deref = mr_23021.arg0;
			string deref_label = mr_23021.arg1;
			strings__Builder_writeln(&g->auto_str_funcs,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\tstrings__Builder_write_string(&sb, _SLIT(\""), 0xfe10, {.d_s = deref_label}}, {_SLIT("\"));"), 0, { .d_c = 0 }}})));
			strings__Builder_writeln(&g->auto_str_funcs,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\tstring x = "), 0xfe10, {.d_s = elem_str_fn_name}}, {_SLIT("( "), 0xfe10, {.d_s = deref}}, {_SLIT(" it);"), 0, { .d_c = 0 }}})));
		}
	}
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t\tstrings__Builder_write_string(&sb, x);"));
	if (g->is_autofree && !v__ast__Type_alias_eq(typ, _const_v__ast__bool_type)) {
		strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t\tstring_free(&x);"));
	}
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t\tif (i < a.len-1) {"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t\t\tstrings__Builder_write_string(&sb, _SLIT(\", \"));"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t\t}"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t}"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tstrings__Builder_write_string(&sb, _SLIT(\"]\"));"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tstring res = strings__Builder_str(&sb);"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tstrings__Builder_free(&sb);"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\treturn res;"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("}"));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_array_fixed(v__gen__c__Gen* g, v__ast__ArrayFixed info, string styp, string str_fn_name) {
	v__ast__Type typ = info.elem_type;
	v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, info.elem_type);
	if ((sym->info)._typ == 460 /* v.ast.Alias */) {
		typ = (*sym->info._v__ast__Alias).parent_type;
		sym = v__ast__Table_sym(g->table, typ);
	}
	bool is_elem_ptr = v__ast__Type_is_ptr(typ);
	multi_return_bool_bool_int mr_24403 = v__ast__TypeSymbol_str_method_info(sym);
	bool sym_has_str_method = mr_24403.arg0;
	bool str_method_expects_ptr = mr_24403.arg1;
	string elem_str_fn_name = v__gen__c__Gen_get_str_fn(g, typ);
	strings__Builder_writeln(&g->type_definitions,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("static string "), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT(" a); // auto"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&g->auto_str_funcs,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("static string "), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT(" a) { return indent_"), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("(a, 0);}"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&g->type_definitions,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("static string indent_"), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT(" a, int indent_count); // auto"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&g->auto_str_funcs,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("static string indent_"), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT(" a, int indent_count) {"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&g->auto_str_funcs,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\tstrings__Builder sb = strings__new_builder("), 0xfe07, {.d_i32 = info.size}}, {_SLIT(" * 10);"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tstrings__Builder_write_string(&sb, _SLIT(\"[\"));"));
	strings__Builder_writeln(&g->auto_str_funcs,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\tfor (int i = 0; i < "), 0xfe07, {.d_i32 = info.size}}, {_SLIT("; ++i) {"), 0, { .d_c = 0 }}})));
	if (sym->kind == v__ast__Kind__function) {
		strings__Builder_writeln(&g->auto_str_funcs,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\tstring x = "), 0xfe10, {.d_s = elem_str_fn_name}}, {_SLIT("();"), 0, { .d_c = 0 }}})));
		strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t\tstrings__Builder_write_string(&sb, x);"));
	} else {
		multi_return_string_string mr_25290 = v__gen__c__deref_kind(str_method_expects_ptr, is_elem_ptr, typ);
		string deref = mr_25290.arg0;
		string deref_label = mr_25290.arg1;
		if (v__gen__c__should_use_indent_func(sym->kind) && !sym_has_str_method) {
			if (is_elem_ptr) {
				strings__Builder_writeln(&g->auto_str_funcs,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\tstrings__Builder_write_string(&sb, _SLIT(\""), 0xfe10, {.d_s = deref_label}}, {_SLIT("\"));"), 0, { .d_c = 0 }}})));
				strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t\tif ( 0 == a[i] ) {"));
				strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t\t\tstrings__Builder_write_string(&sb, _SLIT(\"0\"));"));
				strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t\t}else{"));
				strings__Builder_writeln(&g->auto_str_funcs,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\t\tstrings__Builder_write_string(&sb, "), 0xfe10, {.d_s = elem_str_fn_name}}, {_SLIT("( "), 0xfe10, {.d_s = deref}}, {_SLIT(" a[i]) );"), 0, { .d_c = 0 }}})));
				strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t\t}"));
			} else {
				strings__Builder_writeln(&g->auto_str_funcs,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\tstrings__Builder_write_string(&sb, "), 0xfe10, {.d_s = elem_str_fn_name}}, {_SLIT("( "), 0xfe10, {.d_s = deref}}, {_SLIT(" a[i]) );"), 0, { .d_c = 0 }}})));
			}
		} else if (sym->kind == v__ast__Kind__f32 || sym->kind == v__ast__Kind__f64) {
			if (sym->kind == v__ast__Kind__f32) {
				strings__Builder_writeln(&g->auto_str_funcs,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\tstrings__Builder_write_string(&sb, "), 0xfe10, {.d_s = str_intp_g32(_SLIT("a[i]"))}}, {_SLIT(" );"), 0, { .d_c = 0 }}})));
			} else {
				strings__Builder_writeln(&g->auto_str_funcs,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\tstrings__Builder_write_string(&sb, "), 0xfe10, {.d_s = str_intp_g64(_SLIT("a[i]"))}}, {_SLIT(" );"), 0, { .d_c = 0 }}})));
			}
		} else if (sym->kind == v__ast__Kind__string) {
			strings__Builder_writeln(&g->auto_str_funcs,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\tstrings__Builder_write_string(&sb, "), 0xfe10, {.d_s = str_intp_sq(_SLIT("a[i]"))}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
		} else if (sym->kind == v__ast__Kind__rune) {
			string tmp_str = str_intp_rune( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = elem_str_fn_name}}, {_SLIT("(  "), 0xfe10, {.d_s = deref}}, {_SLIT(" a[i])"), 0, { .d_c = 0 }}})));
			strings__Builder_writeln(&g->auto_str_funcs,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\tstrings__Builder_write_string(&sb, "), 0xfe10, {.d_s = tmp_str}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
		} else {
			strings__Builder_writeln(&g->auto_str_funcs,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\tstrings__Builder_write_string(&sb, "), 0xfe10, {.d_s = elem_str_fn_name}}, {_SLIT("( "), 0xfe10, {.d_s = deref}}, {_SLIT(" a[i]));"), 0, { .d_c = 0 }}})));
		}
	}
	strings__Builder_writeln(&g->auto_str_funcs,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\tif (i < "), 0xfe07, {.d_i32 = info.size - 1}}, {_SLIT(") {"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t\t\tstrings__Builder_write_string(&sb, _SLIT(\", \"));"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t\t}"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t}"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tstrings__Builder_write_string(&sb, _SLIT(\"]\"));"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tstring res = strings__Builder_str(&sb);"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tstrings__Builder_free(&sb);"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\treturn res;"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("}"));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_map(v__gen__c__Gen* g, v__ast__Map info, string styp, string str_fn_name) {
	v__ast__Type key_typ = info.key_type;
	v__ast__TypeSymbol* key_sym = v__ast__Table_sym(g->table, key_typ);
	if ((key_sym->info)._typ == 460 /* v.ast.Alias */) {
		key_typ = (*key_sym->info._v__ast__Alias).parent_type;
		key_sym = v__ast__Table_sym(g->table, key_typ);
	}
	string key_styp = v__gen__c__Gen_typ(g, key_typ);
	string key_str_fn_name = string__plus(string_replace(key_styp, _SLIT("*"), _SLIT("")), _SLIT("_str"));
	if (!v__ast__TypeSymbol_has_method(key_sym, _SLIT("str"))) {
		v__gen__c__Gen_get_str_fn(g, key_typ);
	}
	v__ast__Type val_typ = info.value_type;
	v__ast__TypeSymbol* val_sym = v__ast__Table_sym(g->table, val_typ);
	if ((val_sym->info)._typ == 460 /* v.ast.Alias */) {
		val_typ = (*val_sym->info._v__ast__Alias).parent_type;
		val_sym = v__ast__Table_sym(g->table, val_typ);
	}
	string val_styp = v__gen__c__Gen_typ(g, val_typ);
	string elem_str_fn_name = string__plus(string_replace(val_styp, _SLIT("*"), _SLIT("")), _SLIT("_str"));
	if (!v__ast__TypeSymbol_has_method(val_sym, _SLIT("str"))) {
		v__gen__c__Gen_get_str_fn(g, val_typ);
	}
	strings__Builder_writeln(&g->type_definitions,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("static string "), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT(" m); // auto"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&g->auto_str_funcs,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("static string "), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT(" m) { return indent_"), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("(m, 0);}"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&g->type_definitions,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("static string indent_"), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT(" m, int indent_count); // auto"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&g->auto_str_funcs,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("static string indent_"), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT(" m, int indent_count) { /* gen_str_for_map */"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tstrings__Builder sb = strings__new_builder(m.key_values.len*10);"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tstrings__Builder_write_string(&sb, _SLIT(\"{\"));"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tfor (int i = 0; i < m.key_values.len; ++i) {"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t\tif (!DenseArray_has_index(&m.key_values, i)) { continue; }"));
	if (key_sym->kind == v__ast__Kind__string) {
		strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t\tstring key = *(string*)DenseArray_key(&m.key_values, i);"));
	} else {
		strings__Builder_writeln(&g->auto_str_funcs,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\t"), 0xfe10, {.d_s = key_styp}}, {_SLIT(" key = *("), 0xfe10, {.d_s = key_styp}}, {_SLIT("*)DenseArray_key(&m.key_values, i);"), 0, { .d_c = 0 }}})));
	}
	if (key_sym->kind == v__ast__Kind__string) {
		strings__Builder_writeln(&g->auto_str_funcs,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\tstrings__Builder_write_string(&sb, "), 0xfe10, {.d_s = str_intp_sq(_SLIT("key"))}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
	} else if (key_sym->kind == v__ast__Kind__rune) {
		string tmp_str = str_intp_rune( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = key_str_fn_name}}, {_SLIT("(key)"), 0, { .d_c = 0 }}})));
		strings__Builder_writeln(&g->auto_str_funcs,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\tstrings__Builder_write_string(&sb, "), 0xfe10, {.d_s = tmp_str}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
	} else {
		strings__Builder_writeln(&g->auto_str_funcs,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\tstrings__Builder_write_string(&sb, "), 0xfe10, {.d_s = key_str_fn_name}}, {_SLIT("(key));"), 0, { .d_c = 0 }}})));
	}
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t\tstrings__Builder_write_string(&sb, _SLIT(\": \"));"));
	if (val_sym->kind == v__ast__Kind__function) {
		strings__Builder_writeln(&g->auto_str_funcs,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\tstrings__Builder_write_string(&sb, "), 0xfe10, {.d_s = elem_str_fn_name}}, {_SLIT("());"), 0, { .d_c = 0 }}})));
	} else if (val_sym->kind == v__ast__Kind__string) {
		string tmp_str = str_intp_sq( str_intp(2, _MOV((StrIntpData[]){{_SLIT("*("), 0xfe10, {.d_s = val_styp}}, {_SLIT("*)DenseArray_value(&m.key_values, i)"), 0, { .d_c = 0 }}})));
		strings__Builder_writeln(&g->auto_str_funcs,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\tstrings__Builder_write_string(&sb, "), 0xfe10, {.d_s = tmp_str}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
	} else if (v__gen__c__should_use_indent_func(val_sym->kind) && !v__ast__TypeSymbol_has_method(val_sym, _SLIT("str"))) {
		string ptr_str = string_repeat(_SLIT("*"), v__ast__Type_nr_muls(val_typ));
		strings__Builder_writeln(&g->auto_str_funcs,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\t\tstrings__Builder_write_string(&sb, indent_"), 0xfe10, {.d_s = elem_str_fn_name}}, {_SLIT("(*"), 0xfe10, {.d_s = ptr_str}}, {_SLIT("("), 0xfe10, {.d_s = val_styp}}, {_SLIT("*)DenseArray_value(&m.key_values, i), indent_count));"), 0, { .d_c = 0 }}})));
	} else if (val_sym->kind == v__ast__Kind__f32 || val_sym->kind == v__ast__Kind__f64) {
		string tmp_val =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("*("), 0xfe10, {.d_s = val_styp}}, {_SLIT("*)DenseArray_value(&m.key_values, i)"), 0, { .d_c = 0 }}}));
		if (val_sym->kind == v__ast__Kind__f32) {
			strings__Builder_writeln(&g->auto_str_funcs,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\tstrings__Builder_write_string(&sb, "), 0xfe10, {.d_s = str_intp_g32(tmp_val)}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
		} else {
			strings__Builder_writeln(&g->auto_str_funcs,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\tstrings__Builder_write_string(&sb, "), 0xfe10, {.d_s = str_intp_g64(tmp_val)}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
		}
	} else if (val_sym->kind == v__ast__Kind__rune) {
		string tmp_str = str_intp_rune( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = elem_str_fn_name}}, {_SLIT("(*("), 0xfe10, {.d_s = val_styp}}, {_SLIT("*)DenseArray_value(&m.key_values, i))"), 0, { .d_c = 0 }}})));
		strings__Builder_writeln(&g->auto_str_funcs,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\tstrings__Builder_write_string(&sb, "), 0xfe10, {.d_s = tmp_str}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
	} else {
		strings__Builder_writeln(&g->auto_str_funcs,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\tstrings__Builder_write_string(&sb, "), 0xfe10, {.d_s = elem_str_fn_name}}, {_SLIT("(*("), 0xfe10, {.d_s = val_styp}}, {_SLIT("*)DenseArray_value(&m.key_values, i)));"), 0, { .d_c = 0 }}})));
	}
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t\tif (i != m.key_values.len-1) {"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t\t\tstrings__Builder_write_string(&sb, _SLIT(\", \"));"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t\t}"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t}"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tstrings__Builder_write_string(&sb, _SLIT(\"}\"));"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tstring res = strings__Builder_str(&sb);"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tstrings__Builder_free(&sb);"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\treturn res;"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("}"));
}

VV_LOCAL_SYMBOL StrIntpType v__gen__c__Gen_type_to_fmt(v__gen__c__Gen* g, v__ast__Type typ) {
	if (typ == _const_v__ast__byte_type_idx) {
		StrIntpType _t1 = StrIntpType__si_u8;
		return _t1;
	}
	if (typ == _const_v__ast__char_type_idx) {
		StrIntpType _t2 = StrIntpType__si_c;
		return _t2;
	}
	if (Array_v__ast__Type_contains(_const_v__ast__voidptr_types, typ) || Array_v__ast__Type_contains(_const_v__ast__byteptr_types, typ)) {
		StrIntpType _t3 = StrIntpType__si_p;
		return _t3;
	}
	if (Array_v__ast__Type_contains(_const_v__ast__charptr_types, typ)) {
		StrIntpType _t4 = StrIntpType__si_s;
		return _t4;
	}
	v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, typ);
	if (v__ast__Type_is_ptr(typ) && (v__ast__Type_is_int_valptr(typ) || v__ast__Type_is_float_valptr(typ))) {
		StrIntpType _t5 = StrIntpType__si_s;
		return _t5;
	} else if (sym->kind == v__ast__Kind__struct_ || sym->kind == v__ast__Kind__array || sym->kind == v__ast__Kind__array_fixed || sym->kind == v__ast__Kind__map || sym->kind == v__ast__Kind__bool || sym->kind == v__ast__Kind__enum_ || sym->kind == v__ast__Kind__interface_ || sym->kind == v__ast__Kind__sum_type || sym->kind == v__ast__Kind__function || sym->kind == v__ast__Kind__alias || sym->kind == v__ast__Kind__chan) {
		StrIntpType _t6 = StrIntpType__si_s;
		return _t6;
	} else if (sym->kind == v__ast__Kind__string) {
		StrIntpType _t7 = StrIntpType__si_s;
		return _t7;
	} else if (sym->kind == v__ast__Kind__f32 || sym->kind == v__ast__Kind__f64) {
		if (sym->kind == v__ast__Kind__f32) {
			StrIntpType _t8 = StrIntpType__si_g32;
			return _t8;
		}
		StrIntpType _t9 = StrIntpType__si_g64;
		return _t9;
	} else if (sym->kind == v__ast__Kind__int) {
		StrIntpType _t10 = StrIntpType__si_i32;
		return _t10;
	} else if (sym->kind == v__ast__Kind__u32) {
		StrIntpType _t11 = StrIntpType__si_u32;
		return _t11;
	} else if (sym->kind == v__ast__Kind__u64) {
		StrIntpType _t12 = StrIntpType__si_u64;
		return _t12;
	} else if (sym->kind == v__ast__Kind__i64) {
		StrIntpType _t13 = StrIntpType__si_i64;
		return _t13;
	}
	StrIntpType _t14 = StrIntpType__si_i32;
	return _t14;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_struct(v__gen__c__Gen* g, v__ast__Struct info, string styp, string str_fn_name) {
bool v__gen__c__Gen_gen_str_for_struct_defer_0 = false;
strings__Builder fn_builder;
bool v__gen__c__Gen_gen_str_for_struct_defer_1 = false;
v__util__Surrounder fn_body_surrounder;
strings__Builder fn_body;
	strings__Builder_writeln(&g->type_definitions,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("static string "), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT(" it); // auto"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&g->auto_str_funcs,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("static string "), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT(" it) { return indent_"), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("(it, 0);}"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&g->type_definitions,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("static string indent_"), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT(" it, int indent_count); // auto"), 0, { .d_c = 0 }}})));
	fn_builder = strings__new_builder(512);
	v__gen__c__Gen_gen_str_for_struct_defer_0 = true;
	strings__Builder_writeln(&fn_builder,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("static string indent_"), 0xfe10, {.d_s = str_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT(" it, int indent_count) {"), 0, { .d_c = 0 }}})));
	string clean_struct_v_type_name = string_replace(styp, _SLIT("__"), _SLIT("."));
	if (string_contains(clean_struct_v_type_name, _SLIT("_T_"))) {
		clean_struct_v_type_name = string__plus(string_replace(string_replace(string_replace(clean_struct_v_type_name, _SLIT("Array_"), _SLIT("[]")), _SLIT("_T_"), _SLIT("<")), _SLIT("_"), _SLIT(", ")), _SLIT(">"));
	}
	clean_struct_v_type_name = v__util__strip_main_name(clean_struct_v_type_name);
	if (info.fields.len == 0) {
		strings__Builder_writeln(&fn_builder,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\treturn _SLIT(\""), 0xfe10, {.d_s = clean_struct_v_type_name}}, {_SLIT("{}\");"), 0, { .d_c = 0 }}})));
		strings__Builder_writeln(&fn_builder, _SLIT("}"));
		// Defer begin
		if (v__gen__c__Gen_gen_str_for_struct_defer_0) {
			array_push((array*)&g->auto_fn_definitions, _MOV((string[]){ string_clone(strings__Builder_str(&fn_builder)) }));
		}
		// Defer end
		return;
	}
	strings__Builder_writeln(&fn_builder, _SLIT("\tstring indents = string_repeat(_SLIT(\"    \"), indent_count);"));
	fn_body_surrounder = v__util__new_surrounder(info.fields.len);
	fn_body = strings__new_builder(info.fields.len * 256);
	v__gen__c__Gen_gen_str_for_struct_defer_1 = true;
	strings__Builder_writeln(&fn_body,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\tstring res = str_intp( "), 0xfe07, {.d_i32 = info.fields.len * 4 + 3}}, {_SLIT(", _MOV((StrIntpData[]){"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&fn_body,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\t{_SLIT(\""), 0xfe10, {.d_s = clean_struct_v_type_name}}, {_SLIT("{\\n\"), 0, {.d_c=0}},"), 0, { .d_c = 0 }}})));
	for (int i = 0; i < info.fields.len; ++i) {
		v__ast__StructField field = ((v__ast__StructField*)info.fields.data)[i];
		string ptr_amp = (v__ast__Type_is_ptr(field.typ) ? (_SLIT("&")) : (_SLIT("")));
		StrIntpType base_fmt = v__gen__c__Gen_type_to_fmt(g, v__gen__c__Gen_unwrap_generic(g, field.typ));
		string quote_str = _SLIT("");
		string prefix = _SLIT("");
		v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, v__gen__c__Gen_unwrap_generic(g, field.typ));
		if (sym->kind == v__ast__Kind__string) {
			quote_str = _SLIT("'");
		} else if (Array_v__ast__Type_contains(_const_v__ast__charptr_types, field.typ)) {
			quote_str = _SLIT("\\\"");
			prefix = _SLIT("C");
		}
		if (i == 0) {
			strings__Builder_write_string(&fn_body,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("\t\t{_SLIT0, "), 0xfe10, {.d_s = _const_v__gen__c__si_s_code}}, {_SLIT(", {.d_s=indents}}, {_SLIT(\"    "), 0xfe10, {.d_s = field.name}}, {_SLIT(": "), 0xfe10, {.d_s = ptr_amp}}, {_SLIT0, 0xfe10, {.d_s = prefix}}, {_SLIT("\"), 0, {.d_c=0}}, "), 0, { .d_c = 0 }}})));
		} else {
			strings__Builder_write_string(&fn_body,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("\t\t{_SLIT(\"\\n\"), "), 0xfe10, {.d_s = _const_v__gen__c__si_s_code}}, {_SLIT(", {.d_s=indents}}, {_SLIT(\"    "), 0xfe10, {.d_s = field.name}}, {_SLIT(": "), 0xfe10, {.d_s = ptr_amp}}, {_SLIT0, 0xfe10, {.d_s = prefix}}, {_SLIT("\"), 0, {.d_c=0}}, "), 0, { .d_c = 0 }}})));
		}
		multi_return_bool_bool_int mr_35132 = v__ast__TypeSymbol_str_method_info(sym);
		bool sym_has_str_method = mr_35132.arg0;
		bool str_method_expects_ptr = mr_35132.arg1;
		string sftyp = v__gen__c__Gen_typ(g, field.typ);
		string field_styp = string_replace(sftyp, _SLIT("*"), _SLIT(""));
		string field_styp_fn_name = (sym_has_str_method ? ( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = field_styp}}, {_SLIT("_str"), 0, { .d_c = 0 }}}))) : (v__gen__c__Gen_get_str_fn(g, field.typ)));
		if (!(sym->kind == v__ast__Kind__f32 || sym->kind == v__ast__Kind__f64)) {
			strings__Builder_write_string(&fn_body,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("{_SLIT(\""), 0xfe10, {.d_s = quote_str}}, {_SLIT("\"), "), 0xfe07, {.d_i32 = ((int)(base_fmt))}}, {_SLIT(", {."), 0xfe10, {.d_s = v__gen__c__data_str(base_fmt)}}, {_SLIT("="), 0, { .d_c = 0 }}})));
		} else {
			string g_fmt = string__plus(_SLIT("0x"), u32_hex(((((u32)(base_fmt)) | ((u32)(0x7FU)) << 9U))));
			strings__Builder_write_string(&fn_body,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("{_SLIT(\""), 0xfe10, {.d_s = quote_str}}, {_SLIT("\"), "), 0xfe10, {.d_s = g_fmt}}, {_SLIT(", {."), 0xfe10, {.d_s = v__gen__c__data_str(base_fmt)}}, {_SLIT("="), 0, { .d_c = 0 }}})));
		}
		string funcprefix = _SLIT("");
		multi_return_string_bool mr_35752 = v__gen__c__struct_auto_str_func(sym, field.typ, field_styp_fn_name, field.name, sym_has_str_method, str_method_expects_ptr);
		string func = mr_35752.arg0;
		bool caller_should_free = mr_35752.arg1;
		if (Array_v__ast__Type_contains(_const_v__ast__cptr_types, field.typ)) {
			func =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("(voidptr) it."), 0xfe10, {.d_s = field.name}}, {_SLIT0, 0, { .d_c = 0 }}}));
			caller_should_free = false;
		} else if (v__ast__Type_is_ptr(field.typ)) {
			funcprefix = /*f*/string__plus(funcprefix,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("isnil(it."), 0xfe10, {.d_s = v__gen__c__c_name(field.name)}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
			funcprefix = /*f*/string__plus(funcprefix, _SLIT(" ? _SLIT(\"nil\") : "));
			if (sym->kind != v__ast__Kind__struct_ && !v__ast__Type_is_int_valptr(field.typ) && !v__ast__Type_is_float_valptr(field.typ)) {
				funcprefix = /*f*/string__plus(funcprefix, _SLIT("*"));
			}
		}
		if (string__eq(styp, field_styp)) {
			strings__Builder_write_string(&fn_body,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = funcprefix}}, {_SLIT("_SLIT(\"<circular>\")"), 0, { .d_c = 0 }}})));
		} else {
			if (Array_v__ast__Type_contains(_const_v__ast__charptr_types, field.typ)) {
				strings__Builder_write_string(&fn_body,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("tos2((byteptr)"), 0xfe10, {.d_s = func}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
			} else {
				if (v__ast__Type_is_ptr(field.typ) && sym->kind == v__ast__Kind__struct_) {
					funcprefix = /*f*/string__plus(funcprefix, _SLIT("(indent_count > 25) ? _SLIT(\"<probably circular>\") : "));
				}
				if (caller_should_free) {
					string tmpvar = v__gen__c__Gen_new_tmp_var(g);
					v__util__Surrounder_add(&fn_body_surrounder,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\tstring "), 0xfe10, {.d_s = tmpvar}}, {_SLIT(" = "), 0xfe10, {.d_s = funcprefix}}, {_SLIT0, 0xfe10, {.d_s = func}}, {_SLIT(";"), 0, { .d_c = 0 }}})),  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\tstring_free(&"), 0xfe10, {.d_s = tmpvar}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
					strings__Builder_write_string(&fn_body, tmpvar);
				} else {
					strings__Builder_write_string(&fn_body, funcprefix);
					strings__Builder_write_string(&fn_body, func);
				}
			}
		}
		strings__Builder_writeln(&fn_body,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("}}, {_SLIT(\""), 0xfe10, {.d_s = quote_str}}, {_SLIT("\"), 0, {.d_c=0}},"), 0, { .d_c = 0 }}})));
	}
	strings__Builder_writeln(&fn_body,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\t{_SLIT(\"\\n\"), "), 0xfe10, {.d_s = _const_v__gen__c__si_s_code}}, {_SLIT(", {.d_s=indents}}, {_SLIT(\"}\"), 0, {.d_c=0}},"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&fn_body, _SLIT("\t}));"));
// Defer begin
if (v__gen__c__Gen_gen_str_for_struct_defer_1) {
	v__util__Surrounder_builder_write_befores(&fn_body_surrounder, (voidptr)&/*qq*/fn_builder);
	_PUSH_MANY(&fn_builder, (fn_body), _t2, strings__Builder);
	v__util__Surrounder_builder_write_afters(&fn_body_surrounder, (voidptr)&/*qq*/fn_builder);
	strings__Builder_writeln(&fn_builder, _SLIT("\tstring_free(&indents);"));
	strings__Builder_writeln(&fn_builder, _SLIT("\treturn res;"));
	strings__Builder_writeln(&fn_builder, _SLIT("}"));
}
// Defer end
// Defer begin
if (v__gen__c__Gen_gen_str_for_struct_defer_0) {
	array_push((array*)&g->auto_fn_definitions, _MOV((string[]){ string_clone(strings__Builder_str(&fn_builder)) }));
}
// Defer end
}

VV_LOCAL_SYMBOL multi_return_string_bool v__gen__c__struct_auto_str_func(v__ast__TypeSymbol* sym, v__ast__Type field_type, string fn_name, string field_name, bool has_custom_str, bool expects_ptr) {
	multi_return_string_string mr_37649 = v__gen__c__deref_kind(expects_ptr, v__ast__Type_is_ptr(field_type), field_type);
	string deref = mr_37649.arg0;
	if (sym->kind == v__ast__Kind__enum_) {
		return (multi_return_string_bool){.arg0= str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = fn_name}}, {_SLIT("("), 0xfe10, {.d_s = deref}}, {_SLIT("it."), 0xfe10, {.d_s = v__gen__c__c_name(field_name)}}, {_SLIT(")"), 0, { .d_c = 0 }}})), .arg1=true};
	} else if (v__gen__c__should_use_indent_func(sym->kind)) {
		string obj =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("it."), 0xfe10, {.d_s = v__gen__c__c_name(field_name)}}, {_SLIT0, 0, { .d_c = 0 }}}));
		if (has_custom_str) {
			return (multi_return_string_bool){.arg0= str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = fn_name}}, {_SLIT("("), 0xfe10, {.d_s = deref}}, {_SLIT0, 0xfe10, {.d_s = obj}}, {_SLIT(")"), 0, { .d_c = 0 }}})), .arg1=true};
		}
		return (multi_return_string_bool){.arg0= str_intp(4, _MOV((StrIntpData[]){{_SLIT("indent_"), 0xfe10, {.d_s = fn_name}}, {_SLIT("("), 0xfe10, {.d_s = deref}}, {_SLIT0, 0xfe10, {.d_s = obj}}, {_SLIT(", indent_count + 1)"), 0, { .d_c = 0 }}})), .arg1=true};
	} else if (sym->kind == v__ast__Kind__array || sym->kind == v__ast__Kind__array_fixed || sym->kind == v__ast__Kind__map || sym->kind == v__ast__Kind__sum_type) {
		if (has_custom_str) {
			return (multi_return_string_bool){.arg0= str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = fn_name}}, {_SLIT("("), 0xfe10, {.d_s = deref}}, {_SLIT("it."), 0xfe10, {.d_s = v__gen__c__c_name(field_name)}}, {_SLIT(")"), 0, { .d_c = 0 }}})), .arg1=true};
		}
		return (multi_return_string_bool){.arg0= str_intp(4, _MOV((StrIntpData[]){{_SLIT("indent_"), 0xfe10, {.d_s = fn_name}}, {_SLIT("("), 0xfe10, {.d_s = deref}}, {_SLIT("it."), 0xfe10, {.d_s = v__gen__c__c_name(field_name)}}, {_SLIT(", indent_count + 1)"), 0, { .d_c = 0 }}})), .arg1=true};
	} else if (sym->kind == v__ast__Kind__function) {
		return (multi_return_string_bool){.arg0= str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = fn_name}}, {_SLIT("()"), 0, { .d_c = 0 }}})), .arg1=true};
	} else {
		if (sym->kind == v__ast__Kind__chan) {
			return (multi_return_string_bool){.arg0= str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = fn_name}}, {_SLIT("("), 0xfe10, {.d_s = deref}}, {_SLIT("it."), 0xfe10, {.d_s = v__gen__c__c_name(field_name)}}, {_SLIT(")"), 0, { .d_c = 0 }}})), .arg1=true};
		}
		string method_str =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("it."), 0xfe10, {.d_s = v__gen__c__c_name(field_name)}}, {_SLIT0, 0, { .d_c = 0 }}}));
		bool caller_should_free = false;
		if (sym->kind == v__ast__Kind__bool) {
			method_str = /*f*/string__plus(method_str, _SLIT(" ? _SLIT(\"true\") : _SLIT(\"false\")"));
		} else if ((v__ast__Type_is_int_valptr(field_type) || v__ast__Type_is_float_valptr(field_type)) && v__ast__Type_is_ptr(field_type) && !expects_ptr) {
			if (sym->kind == v__ast__Kind__f32) {
				return (multi_return_string_bool){.arg0= str_intp(3, _MOV((StrIntpData[]){{_SLIT("str_intp(1, _MOV((StrIntpData[]){\n					{_SLIT0, "), 0xfe10, {.d_s = _const_si_g32_code}}, {_SLIT(", {.d_f32 = *"), 0xfe10, {.d_s = method_str}}, {_SLIT(" }}\n				}))"), 0, { .d_c = 0 }}})), .arg1=true};
			} else if (sym->kind == v__ast__Kind__f64) {
				return (multi_return_string_bool){.arg0= str_intp(3, _MOV((StrIntpData[]){{_SLIT("str_intp(1, _MOV((StrIntpData[]){\n					{_SLIT0, "), 0xfe10, {.d_s = _const_si_g64_code}}, {_SLIT(", {.d_f64 = *"), 0xfe10, {.d_s = method_str}}, {_SLIT(" }}\n				}))"), 0, { .d_c = 0 }}})), .arg1=true};
			} else if (sym->kind == v__ast__Kind__u64) {
				v__gen__c__StrIntpType fmt_type = v__gen__c__StrIntpType__si_u64;
				return (multi_return_string_bool){.arg0= str_intp(3, _MOV((StrIntpData[]){{_SLIT("str_intp(1, _MOV((StrIntpData[]){{_SLIT0, "), 0xfe06, {.d_u32 = (((u32)(fmt_type)) | 0xfe00U)}}, {_SLIT(", {.d_u64 = *"), 0xfe10, {.d_s = method_str}}, {_SLIT(" }}}))"), 0, { .d_c = 0 }}})), .arg1=true};
			}
			v__gen__c__StrIntpType fmt_type = v__gen__c__StrIntpType__si_i32;
			return (multi_return_string_bool){.arg0= str_intp(3, _MOV((StrIntpData[]){{_SLIT("str_intp(1, _MOV((StrIntpData[]){{_SLIT0, "), 0xfe06, {.d_u32 = (((u32)(fmt_type)) | 0xfe00U)}}, {_SLIT(", {.d_i32 = *"), 0xfe10, {.d_s = method_str}}, {_SLIT(" }}}))"), 0, { .d_c = 0 }}})), .arg1=true};
		}
		return (multi_return_string_bool){.arg0=method_str, .arg1=caller_should_free};
	}
	return (multi_return_string_bool){0};
}

VV_LOCAL_SYMBOL Map_string_bool v__gen__c__string_array_to_map(Array_string a) {
	Map_string_bool res = new_map(sizeof(string), sizeof(bool), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
	for (int _t1 = 0; _t1 < a.len; ++_t1) {
		string x = ((string*)a.data)[_t1];
		map_set(&res, &(string[]){x}, &(bool[]) { true });
	}
	Map_string_bool _t2 = res;
	return _t2;
}

string v__gen__c__gen(Array_v__ast__File_ptr files, v__ast__Table* table, v__pref__Preferences* pref) {
	string module_built = _SLIT("");
	if (pref->build_mode == v__pref__BuildMode__build_module) {
		for (int _t1 = 0; _t1 < files.len; ++_t1) {
			v__ast__File* file = ((v__ast__File**)files.data)[_t1];
			if (string_contains(file->path, pref->path) && string__eq(file->mod.short_name, string_trim_right(string_all_after_last(pref->path, _const_os__path_separator), _const_os__path_separator))) {
				module_built = file->mod.name;
				break;
			}
		}
	}
	bool timers_should_print = false;
	v__gen__c__Gen global_g = (v__gen__c__Gen){
		.pref = pref,
		.field_data_type = ((v__ast__Table_find_type_idx(table, _SLIT("FieldData")))),
		.module_built = module_built,
		.timers_should_print = timers_should_print,
		.table = table,
		.out = strings__new_builder(512000),
		.cheaders = strings__new_builder(15000),
		.includes = strings__new_builder(100),
		.typedefs = strings__new_builder(100),
		.enum_typedefs = strings__new_builder(100),
		.definitions = strings__new_builder(100),
		.type_definitions = strings__new_builder(100),
		.hotcode_definitions = strings__new_builder(100),
		.channel_definitions = strings__new_builder(100),
		.comptime_definitions = strings__new_builder(100),
		.global_inits = new_map(sizeof(string), sizeof(strings__Builder), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.global_init = __new_array(0, 0, sizeof(byte)),
		.inits = new_map(sizeof(string), sizeof(strings__Builder), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.init = strings__new_builder(100),
		.cleanup = __new_array(0, 0, sizeof(byte)),
		.cleanups = new_map(sizeof(string), sizeof(strings__Builder), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.gowrappers = strings__new_builder(100),
		.stringliterals = strings__new_builder(100),
		.auto_str_funcs = strings__new_builder(100),
		.pcs_declarations = strings__new_builder(100),
		.embedded_data = strings__new_builder(1000),
		.shared_types = strings__new_builder(100),
		.shared_functions = strings__new_builder(100),
		.options = strings__new_builder(100),
		.json_forward_decls = strings__new_builder(100),
		.sql_buf = strings__new_builder(100),
		.file = 0,
		.unique_file_path_hash = 0,
		.fn_decl = 0,
		.last_fn_c_name = (string){.str=(byteptr)"", .is_lit=1},
		.tmp_count = 0,
		.tmp_count_af = 0,
		.tmp_count_declarations = 0,
		.global_tmp_count = 0,
		.discard_or_result = 0,
		.is_assign_lhs = 0,
		.is_void_expr_stmt = 0,
		.is_arraymap_set = 0,
		.is_amp = 0,
		.is_sql = 0,
		.is_shared = 0,
		.is_vlines_enabled = 0,
		.is_autofree = pref->autofree,
		.is_builtin_mod = 0,
		.is_json_fn = 0,
		.is_js_call = 0,
		.is_fn_index_call = 0,
		.vlines_path = (string){.str=(byteptr)"", .is_lit=1},
		.optionals = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.done_optionals = (__shared__Array_string*)__dup_shared_array(&(__shared__Array_string){.mtx = {0}, .val =__new_array(0, 0, sizeof(string))}, sizeof(__shared__Array_string)),
		.chan_pop_optionals = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.chan_push_optionals = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.mtxs = (string){.str=(byteptr)"", .is_lit=1},
		.labeled_loops = new_map(sizeof(string), sizeof(v__ast__Stmt*), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.inner_loop = HEAP(v__ast__Stmt, v__ast__EmptyStmt_to_sumtype_v__ast__Stmt((v__ast__EmptyStmt*)memdup(&(v__ast__EmptyStmt){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},}, sizeof(v__ast__EmptyStmt)))),
		.shareds = new_map(sizeof(int), sizeof(string), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),
		.inside_ternary = 0,
		.inside_map_postfix = 0,
		.inside_map_infix = 0,
		.inside_map_index = 0,
		.inside_opt_data = 0,
		.inside_if_optional = 0,
		.inside_match_optional = 0,
		.inside_vweb_tmpl = 0,
		.inside_return = 0,
		.inside_or_block = 0,
		.inside_call = 0,
		.inside_for_c_stmt = 0,
		.inside_cast_in_heap = 0,
		.inside_const = 0,
		.inside_lambda = 0,
		.loop_depth = 0,
		.ternary_names = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.ternary_level_names = new_map(sizeof(string), sizeof(Array_string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.arraymap_set_pos = 0,
		.stmt_path_pos = __new_array(0, 0, sizeof(int)),
		.skip_stmt_pos = 0,
		.right_is_opt = 0,
		.indent = -1,
		.empty_line = 0,
		.assign_op = 0,
		.defer_stmts = __new_array(0, 0, sizeof(v__ast__DeferStmt)),
		.defer_ifdef = (string){.str=(byteptr)"", .is_lit=1},
		.defer_profile_code = (string){.str=(byteptr)"", .is_lit=1},
		.defer_vars = __new_array(0, 0, sizeof(string)),
		.str_types = __new_array(0, 0, sizeof(v__gen__c__StrType)),
		.generated_str_fns = __new_array(0, 0, sizeof(v__gen__c__StrType)),
		.threaded_fns = (__shared__Array_string*)__dup_shared_array(&(__shared__Array_string){.mtx = {0}, .val =__new_array(0, 0, sizeof(string))}, sizeof(__shared__Array_string)),
		.waiter_fns = (__shared__Array_string*)__dup_shared_array(&(__shared__Array_string){.mtx = {0}, .val =__new_array(0, 0, sizeof(string))}, sizeof(__shared__Array_string)),
		.needed_equality_fns = __new_array(0, 0, sizeof(v__ast__Type)),
		.generated_eq_fns = __new_array(0, 0, sizeof(v__ast__Type)),
		.array_sort_fn = (__shared__Array_string*)__dup_shared_array(&(__shared__Array_string){.mtx = {0}, .val =__new_array(0, 0, sizeof(string))}, sizeof(__shared__Array_string)),
		.array_contains_types = __new_array(0, 0, sizeof(v__ast__Type)),
		.array_index_types = __new_array(0, 0, sizeof(v__ast__Type)),
		.auto_fn_definitions = __new_array(0, 0, sizeof(string)),
		.sumtype_casting_fns = __new_array(0, 0, sizeof(v__gen__c__SumtypeCastingFn)),
		.anon_fn_definitions = __new_array(0, 0, sizeof(string)),
		.sumtype_definitions = new_map(sizeof(int), sizeof(bool), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),
		.json_types = __new_array(0, 0, sizeof(v__ast__Type)),
		.pcs = __new_array(0, 0, sizeof(v__gen__c__ProfileCounterMeta)),
		.hotcode_fn_names = __new_array(0, 0, sizeof(string)),
		.embedded_files = __new_array(0, 0, sizeof(v__ast__EmbeddedFile)),
		.sql_i = 0,
		.sql_stmt_name = (string){.str=(byteptr)"", .is_lit=1},
		.sql_bind_name = (string){.str=(byteptr)"", .is_lit=1},
		.sql_idents = __new_array(0, 0, sizeof(string)),
		.sql_idents_types = __new_array(0, 0, sizeof(v__ast__Type)),
		.sql_left_type = 0,
		.sql_table_name = (string){.str=(byteptr)"", .is_lit=1},
		.sql_fkey = (string){.str=(byteptr)"", .is_lit=1},
		.sql_parent_id = (string){.str=(byteptr)"", .is_lit=1},
		.sql_side = 0,
		.strs_to_free0 = __new_array(0, 0, sizeof(string)),
		.comptime_for_method = (string){.str=(byteptr)"", .is_lit=1},
		.comptime_for_field_var = (string){.str=(byteptr)"", .is_lit=1},
		.comptime_for_field_value = (v__ast__StructField){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.has_default_expr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_pub = 0,.default_val = (string){.str=(byteptr)"", .is_lit=1},.is_mut = 0,.is_global = 0,.is_volatile = 0,.default_expr_typ = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,},
		.comptime_for_field_type = 0,
		.comptime_var_type_map = new_map(sizeof(string), sizeof(v__ast__Type), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.prevent_sum_type_unwrapping_once = 0,
		.aggregate_type_idx = 0,
		.branch_parent_pos = 0,
		.returned_var_name = (string){.str=(byteptr)"", .is_lit=1},
		.infix_left_var_name = (string){.str=(byteptr)"", .is_lit=1},
		.called_fn_name = (string){.str=(byteptr)"", .is_lit=1},
		.timers = v__util__new_timers((v__util__TimerParams){.should_print = timers_should_print,.label = _SLIT("global_cgen"),}),
		.force_main_console = 0,
		.as_cast_type_names = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.obf_table = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.referenced_fns = (__shared__Map_string_bool*)__dup_shared_map(&(__shared__Map_string_bool){.mtx = {0}, .val =new_map(sizeof(string), sizeof(bool), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string)}, sizeof(__shared__Map_string_bool)),
		.nr_closures = 0,
		.expected_cast_type = 0,
		.anon_fn = 0,
		.tests_inited = 0,
		.has_main = 0,
		.cur_mod = (v__ast__Module){.name = (string){.str=(byteptr)"", .is_lit=1},.short_name = (string){.str=(byteptr)"", .is_lit=1},.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.name_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.is_skipped = 0,},
		.cur_concrete_types = __new_array(0, 0, sizeof(v__ast__Type)),
		.cur_fn = 0,
		.cur_lock = (v__ast__LockExpr){.stmts = __new_array(0, 0, sizeof(v__ast__Stmt)),.is_rlock = __new_array(0, 0, sizeof(bool)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.lockeds = __new_array(0, 0, sizeof(v__ast__Expr)),.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.is_expr = 0,.typ = 0,.scope = 0,},
	};
	if (pref->is_test) {
		v__gen__c__Gen_write_tests_definitions(&global_g);
	}
	v__util__Timers_start(global_g.timers, _SLIT("cgen init"));
	for (int _t2 = 0; _t2 < global_g.table->modules.len; ++_t2) {
		string mod = ((string*)global_g.table->modules.data)[_t2];
		map_set(&global_g.inits, &(string[]){mod}, &(strings__Builder[]) { strings__new_builder(200) });
		map_set(&global_g.global_inits, &(string[]){mod}, &(strings__Builder[]) { strings__new_builder(100) });
		map_set(&global_g.cleanups, &(string[]){mod}, &(strings__Builder[]) { strings__new_builder(100) });
	}
	v__gen__c__Gen_init(&global_g);
	v__util__Timers_show(global_g.timers, _SLIT("cgen init"));
	global_g.tests_inited = false;
	if (!pref->no_parallel) {
		sync__pool__PoolProcessor* pp = sync__pool__new_pool_processor((sync__pool__PoolProcessorConfig){.maxjobs = 0,.callback = (voidptr)v__gen__c__cgen_process_one_file_cb,});
		sync__pool__PoolProcessor_set_shared_context(pp, (voidptr)&/*qq*/global_g);
		sync__pool__PoolProcessor_work_on_items_T___ptr__v__ast__File(pp, files);
		v__util__Timers_start(global_g.timers, _SLIT("cgen unification"));
		Array_v__gen__c__Gen_ptr _t3 = sync__pool__PoolProcessor_get_results_ref_T_v__gen__c__Gen(pp);
		for (int _t4 = 0; _t4 < _t3.len; ++_t4) {
			v__gen__c__Gen* g = ((v__gen__c__Gen**)_t3.data)[_t4];
			_PUSH_MANY(&global_g.embedded_files, (g->embedded_files), _t5, Array_v__ast__EmbeddedFile);
			Option_int _t6 = strings__Builder_write(&global_g.out, g->out);
			if (_t6.state != 0) { /*or block*/ 
				IError err = _t6.err;
				_v_panic(IError_str(err));
				VUNREACHABLE();
			;
			}
			
  (*(int*)_t6.data);
			Option_int _t7 = strings__Builder_write(&global_g.cheaders, g->cheaders);
			if (_t7.state != 0) { /*or block*/ 
				IError err = _t7.err;
				_v_panic(IError_str(err));
				VUNREACHABLE();
			;
			}
			
  (*(int*)_t7.data);
			Option_int _t8 = strings__Builder_write(&global_g.includes, g->includes);
			if (_t8.state != 0) { /*or block*/ 
				IError err = _t8.err;
				_v_panic(IError_str(err));
				VUNREACHABLE();
			;
			}
			
  (*(int*)_t8.data);
			Option_int _t9 = strings__Builder_write(&global_g.typedefs, g->typedefs);
			if (_t9.state != 0) { /*or block*/ 
				IError err = _t9.err;
				_v_panic(IError_str(err));
				VUNREACHABLE();
			;
			}
			
  (*(int*)_t9.data);
			Option_int _t10 = strings__Builder_write(&global_g.type_definitions, g->type_definitions);
			if (_t10.state != 0) { /*or block*/ 
				IError err = _t10.err;
				_v_panic(IError_str(err));
				VUNREACHABLE();
			;
			}
			
  (*(int*)_t10.data);
			Option_int _t11 = strings__Builder_write(&global_g.definitions, g->definitions);
			if (_t11.state != 0) { /*or block*/ 
				IError err = _t11.err;
				_v_panic(IError_str(err));
				VUNREACHABLE();
			;
			}
			
  (*(int*)_t11.data);
			Option_int _t12 = strings__Builder_write(&global_g.gowrappers, g->gowrappers);
			if (_t12.state != 0) { /*or block*/ 
				IError err = _t12.err;
				_v_panic(IError_str(err));
				VUNREACHABLE();
			;
			}
			
  (*(int*)_t12.data);
			Option_int _t13 = strings__Builder_write(&global_g.stringliterals, g->stringliterals);
			if (_t13.state != 0) { /*or block*/ 
				IError err = _t13.err;
				_v_panic(IError_str(err));
				VUNREACHABLE();
			;
			}
			
  (*(int*)_t13.data);
			Option_int _t14 = strings__Builder_write(&global_g.auto_str_funcs, g->auto_str_funcs);
			if (_t14.state != 0) { /*or block*/ 
				IError err = _t14.err;
				_v_panic(IError_str(err));
				VUNREACHABLE();
			;
			}
			
  (*(int*)_t14.data);
			Option_int _t15 = strings__Builder_write(&global_g.comptime_definitions, g->comptime_definitions);
			if (_t15.state != 0) { /*or block*/ 
				IError err = _t15.err;
				_v_panic(IError_str(err));
				VUNREACHABLE();
			;
			}
			
  (*(int*)_t15.data);
			Option_int _t16 = strings__Builder_write(&global_g.pcs_declarations, g->pcs_declarations);
			if (_t16.state != 0) { /*or block*/ 
				IError err = _t16.err;
				_v_panic(IError_str(err));
				VUNREACHABLE();
			;
			}
			
  (*(int*)_t16.data);
			Option_int _t17 = strings__Builder_write(&global_g.hotcode_definitions, g->hotcode_definitions);
			if (_t17.state != 0) { /*or block*/ 
				IError err = _t17.err;
				_v_panic(IError_str(err));
				VUNREACHABLE();
			;
			}
			
  (*(int*)_t17.data);
			Option_int _t18 = strings__Builder_write(&global_g.embedded_data, g->embedded_data);
			if (_t18.state != 0) { /*or block*/ 
				IError err = _t18.err;
				_v_panic(IError_str(err));
				VUNREACHABLE();
			;
			}
			
  (*(int*)_t18.data);
			Option_int _t19 = strings__Builder_write(&global_g.shared_types, g->shared_types);
			if (_t19.state != 0) { /*or block*/ 
				IError err = _t19.err;
				_v_panic(IError_str(err));
				VUNREACHABLE();
			;
			}
			
  (*(int*)_t19.data);
			Option_int _t20 = strings__Builder_write(&global_g.shared_functions, g->channel_definitions);
			if (_t20.state != 0) { /*or block*/ 
				IError err = _t20.err;
				_v_panic(IError_str(err));
				VUNREACHABLE();
			;
			}
			
  (*(int*)_t20.data);
			global_g.force_main_console = global_g.force_main_console || g->force_main_console;
			Map_int_string _t21 = g->shareds;
			int _t23 = _t21.key_values.len;
			for (int _t22 = 0; _t22 < _t23; ++_t22 ) {
				int _t24 = _t21.key_values.len - _t23;
				_t23 = _t21.key_values.len;
				if (_t24 < 0) {
					_t22 = -1;
					continue;
				}
				if (!DenseArray_has_index(&_t21.key_values, _t22)) {continue;}
				int k = /*key*/ *(int*)DenseArray_key(&_t21.key_values, _t22);
				string v = (*(string*)DenseArray_value(&_t21.key_values, _t22));
				map_set(&global_g.shareds, &(int[]){k}, &(string[]) { v });
			}
			Map_string_string _t25 = g->chan_pop_optionals;
			int _t27 = _t25.key_values.len;
			for (int _t26 = 0; _t26 < _t27; ++_t26 ) {
				int _t28 = _t25.key_values.len - _t27;
				_t27 = _t25.key_values.len;
				if (_t28 < 0) {
					_t26 = -1;
					continue;
				}
				if (!DenseArray_has_index(&_t25.key_values, _t26)) {continue;}
				string k = /*key*/ *(string*)DenseArray_key(&_t25.key_values, _t26);
				k = string_clone(k);
				string v = (*(string*)DenseArray_value(&_t25.key_values, _t26));
				map_set(&global_g.chan_pop_optionals, &(string[]){k}, &(string[]) { v });
			}
			Map_string_string _t29 = g->chan_push_optionals;
			int _t31 = _t29.key_values.len;
			for (int _t30 = 0; _t30 < _t31; ++_t30 ) {
				int _t32 = _t29.key_values.len - _t31;
				_t31 = _t29.key_values.len;
				if (_t32 < 0) {
					_t30 = -1;
					continue;
				}
				if (!DenseArray_has_index(&_t29.key_values, _t30)) {continue;}
				string k = /*key*/ *(string*)DenseArray_key(&_t29.key_values, _t30);
				k = string_clone(k);
				string v = (*(string*)DenseArray_value(&_t29.key_values, _t30));
				map_set(&global_g.chan_push_optionals, &(string[]){k}, &(string[]) { v });
			}
			Map_string_string _t33 = g->optionals;
			int _t35 = _t33.key_values.len;
			for (int _t34 = 0; _t34 < _t35; ++_t34 ) {
				int _t36 = _t33.key_values.len - _t35;
				_t35 = _t33.key_values.len;
				if (_t36 < 0) {
					_t34 = -1;
					continue;
				}
				if (!DenseArray_has_index(&_t33.key_values, _t34)) {continue;}
				string k = /*key*/ *(string*)DenseArray_key(&_t33.key_values, _t34);
				k = string_clone(k);
				string v = (*(string*)DenseArray_value(&_t33.key_values, _t34));
				map_set(&global_g.optionals, &(string[]){k}, &(string[]) { v });
			}
			Map_string_string _t37 = g->as_cast_type_names;
			int _t39 = _t37.key_values.len;
			for (int _t38 = 0; _t38 < _t39; ++_t38 ) {
				int _t40 = _t37.key_values.len - _t39;
				_t39 = _t37.key_values.len;
				if (_t40 < 0) {
					_t38 = -1;
					continue;
				}
				if (!DenseArray_has_index(&_t37.key_values, _t38)) {continue;}
				string k = /*key*/ *(string*)DenseArray_key(&_t37.key_values, _t38);
				k = string_clone(k);
				string v = (*(string*)DenseArray_value(&_t37.key_values, _t38));
				map_set(&global_g.as_cast_type_names, &(string[]){k}, &(string[]) { v });
			}
			Map_int_bool _t41 = g->sumtype_definitions;
			int _t43 = _t41.key_values.len;
			for (int _t42 = 0; _t42 < _t43; ++_t42 ) {
				int _t44 = _t41.key_values.len - _t43;
				_t43 = _t41.key_values.len;
				if (_t44 < 0) {
					_t42 = -1;
					continue;
				}
				if (!DenseArray_has_index(&_t41.key_values, _t42)) {continue;}
				int k = /*key*/ *(int*)DenseArray_key(&_t41.key_values, _t42);
				bool v = (*(bool*)DenseArray_value(&_t41.key_values, _t42));
				map_set(&global_g.sumtype_definitions, &(int[]){k}, &(bool[]) { v });
			}
			Option_int _t45 = strings__Builder_write(&global_g.json_forward_decls, g->json_forward_decls);
			if (_t45.state != 0) { /*or block*/ 
				IError err = _t45.err;
				_v_panic(IError_str(err));
				VUNREACHABLE();
			;
			}
			
  (*(int*)_t45.data);
			Option_int _t46 = strings__Builder_write(&global_g.enum_typedefs, g->enum_typedefs);
			if (_t46.state != 0) { /*or block*/ 
				IError err = _t46.err;
				_v_panic(IError_str(err));
				VUNREACHABLE();
			;
			}
			
  (*(int*)_t46.data);
			Option_int _t47 = strings__Builder_write(&global_g.channel_definitions, g->channel_definitions);
			if (_t47.state != 0) { /*or block*/ 
				IError err = _t47.err;
				_v_panic(IError_str(err));
				VUNREACHABLE();
			;
			}
			
  (*(int*)_t47.data);
			Option_int _t48 = strings__Builder_write(&global_g.sql_buf, g->sql_buf);
			if (_t48.state != 0) { /*or block*/ 
				IError err = _t48.err;
				_v_panic(IError_str(err));
				VUNREACHABLE();
			;
			}
			
  (*(int*)_t48.data);
			Option_int _t49 = strings__Builder_write(&(*(strings__Builder*)map_get(ADDR(map, global_g.cleanups), &(string[]){g->file->mod.name}, &(strings__Builder[]){ __new_array(0, 0, sizeof(byte)) })), g->cleanup);
			if (_t49.state != 0) { /*or block*/ 
				IError err = _t49.err;
				_v_panic(IError_str(err));
				VUNREACHABLE();
			;
			}
			
  (*(int*)_t49.data);
			Option_int _t50 = strings__Builder_write(&(*(strings__Builder*)map_get(ADDR(map, global_g.inits), &(string[]){g->file->mod.name}, &(strings__Builder[]){ __new_array(0, 0, sizeof(byte)) })), g->init);
			if (_t50.state != 0) { /*or block*/ 
				IError err = _t50.err;
				_v_panic(IError_str(err));
				VUNREACHABLE();
			;
			}
			
  (*(int*)_t50.data);
			Option_int _t51 = strings__Builder_write(&(*(strings__Builder*)map_get(ADDR(map, global_g.global_inits), &(string[]){g->file->mod.name}, &(strings__Builder[]){ __new_array(0, 0, sizeof(byte)) })), g->global_init);
			if (_t51.state != 0) { /*or block*/ 
				IError err = _t51.err;
				_v_panic(IError_str(err));
				VUNREACHABLE();
			;
			}
			
  (*(int*)_t51.data);
			for (int _t52 = 0; _t52 < g->str_types.len; ++_t52) {
				v__gen__c__StrType str_type = ((v__gen__c__StrType*)g->str_types.data)[_t52];
				array_push((array*)&global_g.str_types, _MOV((v__gen__c__StrType[]){ str_type }));
			}
			for (int _t54 = 0; _t54 < g->sumtype_casting_fns.len; ++_t54) {
				v__gen__c__SumtypeCastingFn scf = ((v__gen__c__SumtypeCastingFn*)g->sumtype_casting_fns.data)[_t54];
				if (!Array_v__gen__c__SumtypeCastingFn_contains(global_g.sumtype_casting_fns, scf)) {
					array_push((array*)&global_g.sumtype_casting_fns, _MOV((v__gen__c__SumtypeCastingFn[]){ scf }));
				}
			}
			global_g.nr_closures += g->nr_closures;
			global_g.has_main = global_g.has_main || g->has_main;
			_PUSH_MANY(&global_g.auto_fn_definitions, (g->auto_fn_definitions), _t56, Array_string);
			_PUSH_MANY(&global_g.anon_fn_definitions, (g->anon_fn_definitions), _t57, Array_string);
			_PUSH_MANY(&global_g.needed_equality_fns, (g->needed_equality_fns), _t58, Array_v__ast__Type);
			_PUSH_MANY(&global_g.array_contains_types, (g->array_contains_types), _t59, Array_v__ast__Type);
			_PUSH_MANY(&global_g.array_index_types, (g->array_index_types), _t60, Array_v__ast__Type);
			_PUSH_MANY(&global_g.pcs, (g->pcs), _t61, Array_v__gen__c__ProfileCounterMeta);
			_PUSH_MANY(&global_g.json_types, (g->json_types), _t62, Array_v__ast__Type);
			_PUSH_MANY(&global_g.hotcode_fn_names, (g->hotcode_fn_names), _t63, Array_string);
			v__gen__c__Gen_free_builders(g);
		}
	} else {
		for (int _t64 = 0; _t64 < files.len; ++_t64) {
			v__ast__File* file = ((v__ast__File**)files.data)[_t64];
			global_g.file = file;
			v__gen__c__Gen_gen_file(&global_g);
			strings__Builder_drain_builder(&(*(strings__Builder*)map_get(ADDR(map, global_g.inits), &(string[]){file->mod.name}, &(strings__Builder[]){ __new_array(0, 0, sizeof(byte)) })), (voidptr)&/*qq*/global_g.init, 100);
			strings__Builder_drain_builder(&(*(strings__Builder*)map_get(ADDR(map, global_g.cleanups), &(string[]){file->mod.name}, &(strings__Builder[]){ __new_array(0, 0, sizeof(byte)) })), (voidptr)&/*qq*/global_g.cleanup, 100);
			strings__Builder_drain_builder(&(*(strings__Builder*)map_get(ADDR(map, global_g.global_inits), &(string[]){file->mod.name}, &(strings__Builder[]){ __new_array(0, 0, sizeof(byte)) })), (voidptr)&/*qq*/global_g.global_init, 100);
		}
		v__util__Timers_start(global_g.timers, _SLIT("cgen unification"));
	}
	v__gen__c__Gen_gen_jsons(&global_g);
	v__gen__c__Gen_write_optionals(&global_g);
	v__gen__c__Gen_dump_expr_definitions(&global_g);
	for (int i = 0; i < global_g.str_types.len; i++) {
		v__gen__c__Gen_final_gen_str(&global_g, (*(v__gen__c__StrType*)/*ee elem_typ */array_get(global_g.str_types, i)));
	}
	for (int _t65 = 0; _t65 < global_g.sumtype_casting_fns.len; ++_t65) {
		v__gen__c__SumtypeCastingFn sumtype_casting_fn = ((v__gen__c__SumtypeCastingFn*)global_g.sumtype_casting_fns.data)[_t65];
		v__gen__c__Gen_write_sumtype_casting_fn(&global_g, sumtype_casting_fn);
	}
	v__gen__c__Gen_write_shareds(&global_g);
	v__gen__c__Gen_write_chan_pop_optional_fns(&global_g);
	v__gen__c__Gen_write_chan_push_optional_fns(&global_g);
	v__gen__c__Gen_gen_array_contains_methods(&global_g);
	v__gen__c__Gen_gen_array_index_methods(&global_g);
	v__gen__c__Gen_gen_equality_fns(&global_g);
	v__util__Timers_show(global_g.timers, _SLIT("cgen unification"));
	v__gen__c__Gen g = global_g;
	v__util__Timers_start(g.timers, _SLIT("cgen common"));
	if (g.pref->build_mode == v__pref__BuildMode__build_module) {
		for (int idx = 0; idx < g.table->type_symbols.len; ++idx) {
			v__ast__TypeSymbol* sym = ((v__ast__TypeSymbol**)g.table->type_symbols.data)[idx];
			if (idx == 0) {
				continue;
			}
			strings__Builder_writeln(&g.definitions,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("int _v_type_idx_"), 0xfe10, {.d_s = sym->cname}}, {_SLIT("();"), 0, { .d_c = 0 }}})));
		}
	} else if (g.pref->use_cache) {
		for (int idx = 0; idx < g.table->type_symbols.len; ++idx) {
			v__ast__TypeSymbol* sym = ((v__ast__TypeSymbol**)g.table->type_symbols.data)[idx];
			if (idx == 0) {
				continue;
			}
			strings__Builder_writeln(&g.definitions,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("int _v_type_idx_"), 0xfe10, {.d_s = sym->cname}}, {_SLIT("() { return "), 0xfe07, {.d_i32 = idx}}, {_SLIT("; };"), 0, { .d_c = 0 }}})));
		}
	}
	v__gen__c__Gen_gen_vlines_reset(&g);
	if (g.pref->build_mode != v__pref__BuildMode__build_module) {
		v__gen__c__Gen_write_init_function(&g);
	}
	v__gen__c__Gen_finish(&g);
	strings__Builder b = strings__new_builder(640000);
	strings__Builder_write_string(&b, v__gen__c__Gen_hashes(&g));
	strings__Builder_writeln(&b, _SLIT("\n// V comptime_definitions:"));
	strings__Builder_write_string(&b, strings__Builder_str(&g.comptime_definitions));
	strings__Builder_writeln(&b, _SLIT("\n// V typedefs:"));
	strings__Builder_write_string(&b, strings__Builder_str(&g.typedefs));
	strings__Builder_writeln(&b, _SLIT("\n// V cheaders:"));
	strings__Builder_write_string(&b, strings__Builder_str(&g.cheaders));
	if (g.pcs_declarations.len > 0) {
		strings__Builder_writeln(&b, _SLIT("\n// V profile counters:"));
		strings__Builder_write_string(&b, strings__Builder_str(&g.pcs_declarations));
	}
	strings__Builder_writeln(&b, _SLIT("\n// V includes:"));
	strings__Builder_write_string(&b, strings__Builder_str(&g.includes));
	strings__Builder_writeln(&b, _SLIT("\n// Enum definitions:"));
	strings__Builder_write_string(&b, strings__Builder_str(&g.enum_typedefs));
	strings__Builder_writeln(&b, _SLIT("\n// V type definitions:"));
	strings__Builder_write_string(&b, strings__Builder_str(&g.type_definitions));
	strings__Builder_writeln(&b, _SLIT("\n// V shared types:"));
	strings__Builder_write_string(&b, strings__Builder_str(&g.shared_types));
	strings__Builder_writeln(&b, _SLIT("\n// V Option_xxx definitions:"));
	strings__Builder_write_string(&b, strings__Builder_str(&g.options));
	strings__Builder_writeln(&b, _SLIT("\n// V json forward decls:"));
	strings__Builder_write_string(&b, strings__Builder_str(&g.json_forward_decls));
	strings__Builder_writeln(&b, _SLIT("\n// V definitions:"));
	strings__Builder_write_string(&b, strings__Builder_str(&g.definitions));
	string interface_table = v__gen__c__Gen_interface_table(&g);
	if (interface_table.len > 0) {
		strings__Builder_writeln(&b, _SLIT("\n// V interface table:"));
		strings__Builder_write_string(&b, interface_table);
	}
	if (g.gowrappers.len > 0) {
		strings__Builder_writeln(&b, _SLIT("\n// V gowrappers:"));
		strings__Builder_write_string(&b, strings__Builder_str(&g.gowrappers));
	}
	if (g.hotcode_definitions.len > 0) {
		strings__Builder_writeln(&b, _SLIT("\n// V hotcode definitions:"));
		strings__Builder_write_string(&b, strings__Builder_str(&g.hotcode_definitions));
	}
	if (g.embedded_data.len > 0) {
		strings__Builder_writeln(&b, _SLIT("\n// V embedded data:"));
		strings__Builder_write_string(&b, strings__Builder_str(&g.embedded_data));
	}
	if (g.shared_functions.len > 0) {
		strings__Builder_writeln(&b, _SLIT("\n// V shared type functions:"));
		strings__Builder_write_string(&b, strings__Builder_str(&g.shared_functions));
		strings__Builder_write_string(&b, _const_v__gen__c__c_concurrency_helpers);
	}
	if (g.channel_definitions.len > 0) {
		strings__Builder_writeln(&b, _SLIT("\n// V channel code:"));
		strings__Builder_write_string(&b, strings__Builder_str(&g.channel_definitions));
	}
	if (g.stringliterals.len > 0) {
		strings__Builder_writeln(&b, _SLIT("\n// V stringliterals:"));
		strings__Builder_write_string(&b, strings__Builder_str(&g.stringliterals));
	}
	if (g.auto_str_funcs.len > 0) {
		strings__Builder_writeln(&b, _SLIT("\n// V auto str functions:"));
		strings__Builder_write_string(&b, strings__Builder_str(&g.auto_str_funcs));
	}
	if (g.auto_fn_definitions.len > 0) {
		for (int _t66 = 0; _t66 < g.auto_fn_definitions.len; ++_t66) {
			string fn_def = ((string*)g.auto_fn_definitions.data)[_t66];
			strings__Builder_writeln(&b, fn_def);
		}
	}
	if (g.anon_fn_definitions.len > 0) {
		if (g.nr_closures > 0) {
			strings__Builder_writeln(&b, _SLIT("\n// V closure helpers"));
			strings__Builder_writeln(&b, v__gen__c__c_closure_helpers(g.pref));
		}
		for (int _t67 = 0; _t67 < g.anon_fn_definitions.len; ++_t67) {
			string fn_def = ((string*)g.anon_fn_definitions.data)[_t67];
			strings__Builder_writeln(&b, fn_def);
		}
	}
	strings__Builder_writeln(&b, _SLIT("\n// V out"));
	strings__Builder_write_string(&b, strings__Builder_str(&g.out));
	strings__Builder_writeln(&b, _SLIT("\n// THE END."));
	v__util__Timers_show(g.timers, _SLIT("cgen common"));
	string res = strings__Builder_str(&b);
	strings__Builder_free(&b);
	v__gen__c__Gen_free_builders(&g);
	string _t68 = res;
	return _t68;
}

VV_LOCAL_SYMBOL v__gen__c__Gen* v__gen__c__cgen_process_one_file_cb(sync__pool__PoolProcessor* p, int idx, int wid) {
	v__ast__File* file = sync__pool__PoolProcessor_get_item_T___ptr__v__ast__File(p, idx);
	v__gen__c__Gen* global_g = ((v__gen__c__Gen*)(sync__pool__PoolProcessor_get_shared_context(p)));
	v__gen__c__Gen* g = (v__gen__c__Gen*)memdup(&(v__gen__c__Gen){.pref = global_g->pref,
		.field_data_type = ((v__ast__Table_find_type_idx(global_g->table, _SLIT("FieldData")))),
		.module_built = global_g->module_built,
		.timers_should_print = 0,
		.table = global_g->table,
		.out = strings__new_builder(512000),
		.cheaders = strings__new_builder(15000),
		.includes = strings__new_builder(100),
		.typedefs = strings__new_builder(100),
		.enum_typedefs = strings__new_builder(100),
		.definitions = strings__new_builder(100),
		.type_definitions = strings__new_builder(100),
		.hotcode_definitions = strings__new_builder(100),
		.channel_definitions = strings__new_builder(100),
		.comptime_definitions = strings__new_builder(100),
		.global_inits = new_map(sizeof(string), sizeof(strings__Builder), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.global_init = strings__new_builder(0),
		.inits = new_map(sizeof(string), sizeof(strings__Builder), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.init = strings__new_builder(100),
		.cleanup = strings__new_builder(100),
		.cleanups = new_map(sizeof(string), sizeof(strings__Builder), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.gowrappers = strings__new_builder(100),
		.stringliterals = strings__new_builder(100),
		.auto_str_funcs = strings__new_builder(100),
		.pcs_declarations = strings__new_builder(100),
		.embedded_data = strings__new_builder(1000),
		.shared_types = strings__new_builder(100),
		.shared_functions = strings__new_builder(100),
		.options = strings__new_builder(100),
		.json_forward_decls = strings__new_builder(100),
		.sql_buf = strings__new_builder(100),
		.file = file,
		.unique_file_path_hash = 0,
		.fn_decl = 0,
		.last_fn_c_name = (string){.str=(byteptr)"", .is_lit=1},
		.tmp_count = 0,
		.tmp_count_af = 0,
		.tmp_count_declarations = 0,
		.global_tmp_count = 0,
		.discard_or_result = 0,
		.is_assign_lhs = 0,
		.is_void_expr_stmt = 0,
		.is_arraymap_set = 0,
		.is_amp = 0,
		.is_sql = 0,
		.is_shared = 0,
		.is_vlines_enabled = 0,
		.is_autofree = global_g->pref->autofree,
		.is_builtin_mod = 0,
		.is_json_fn = 0,
		.is_js_call = 0,
		.is_fn_index_call = 0,
		.vlines_path = (string){.str=(byteptr)"", .is_lit=1},
		.optionals = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.done_optionals = global_g->done_optionals,
		.chan_pop_optionals = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.chan_push_optionals = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.mtxs = (string){.str=(byteptr)"", .is_lit=1},
		.labeled_loops = new_map(sizeof(string), sizeof(v__ast__Stmt*), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.inner_loop = HEAP(v__ast__Stmt, v__ast__EmptyStmt_to_sumtype_v__ast__Stmt((v__ast__EmptyStmt*)memdup(&(v__ast__EmptyStmt){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},}, sizeof(v__ast__EmptyStmt)))),
		.shareds = new_map(sizeof(int), sizeof(string), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),
		.inside_ternary = 0,
		.inside_map_postfix = 0,
		.inside_map_infix = 0,
		.inside_map_index = 0,
		.inside_opt_data = 0,
		.inside_if_optional = 0,
		.inside_match_optional = 0,
		.inside_vweb_tmpl = 0,
		.inside_return = 0,
		.inside_or_block = 0,
		.inside_call = 0,
		.inside_for_c_stmt = 0,
		.inside_cast_in_heap = 0,
		.inside_const = 0,
		.inside_lambda = 0,
		.loop_depth = 0,
		.ternary_names = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.ternary_level_names = new_map(sizeof(string), sizeof(Array_string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.arraymap_set_pos = 0,
		.stmt_path_pos = __new_array(0, 0, sizeof(int)),
		.skip_stmt_pos = 0,
		.right_is_opt = 0,
		.indent = -1,
		.empty_line = 0,
		.assign_op = 0,
		.defer_stmts = __new_array(0, 0, sizeof(v__ast__DeferStmt)),
		.defer_ifdef = (string){.str=(byteptr)"", .is_lit=1},
		.defer_profile_code = (string){.str=(byteptr)"", .is_lit=1},
		.defer_vars = __new_array(0, 0, sizeof(string)),
		.str_types = __new_array(0, 0, sizeof(v__gen__c__StrType)),
		.generated_str_fns = __new_array(0, 0, sizeof(v__gen__c__StrType)),
		.threaded_fns = global_g->threaded_fns,
		.waiter_fns = global_g->waiter_fns,
		.needed_equality_fns = __new_array(0, 0, sizeof(v__ast__Type)),
		.generated_eq_fns = __new_array(0, 0, sizeof(v__ast__Type)),
		.array_sort_fn = global_g->array_sort_fn,
		.array_contains_types = __new_array(0, 0, sizeof(v__ast__Type)),
		.array_index_types = __new_array(0, 0, sizeof(v__ast__Type)),
		.auto_fn_definitions = __new_array(0, 0, sizeof(string)),
		.sumtype_casting_fns = __new_array(0, 0, sizeof(v__gen__c__SumtypeCastingFn)),
		.anon_fn_definitions = __new_array(0, 0, sizeof(string)),
		.sumtype_definitions = new_map(sizeof(int), sizeof(bool), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),
		.json_types = __new_array(0, 0, sizeof(v__ast__Type)),
		.pcs = __new_array(0, 0, sizeof(v__gen__c__ProfileCounterMeta)),
		.hotcode_fn_names = __new_array(0, 0, sizeof(string)),
		.embedded_files = __new_array(0, 0, sizeof(v__ast__EmbeddedFile)),
		.sql_i = 0,
		.sql_stmt_name = (string){.str=(byteptr)"", .is_lit=1},
		.sql_bind_name = (string){.str=(byteptr)"", .is_lit=1},
		.sql_idents = __new_array(0, 0, sizeof(string)),
		.sql_idents_types = __new_array(0, 0, sizeof(v__ast__Type)),
		.sql_left_type = 0,
		.sql_table_name = (string){.str=(byteptr)"", .is_lit=1},
		.sql_fkey = (string){.str=(byteptr)"", .is_lit=1},
		.sql_parent_id = (string){.str=(byteptr)"", .is_lit=1},
		.sql_side = 0,
		.strs_to_free0 = __new_array(0, 0, sizeof(string)),
		.comptime_for_method = (string){.str=(byteptr)"", .is_lit=1},
		.comptime_for_field_var = (string){.str=(byteptr)"", .is_lit=1},
		.comptime_for_field_value = (v__ast__StructField){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.has_default_expr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_pub = 0,.default_val = (string){.str=(byteptr)"", .is_lit=1},.is_mut = 0,.is_global = 0,.is_volatile = 0,.default_expr_typ = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,},
		.comptime_for_field_type = 0,
		.comptime_var_type_map = new_map(sizeof(string), sizeof(v__ast__Type), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.prevent_sum_type_unwrapping_once = 0,
		.aggregate_type_idx = 0,
		.branch_parent_pos = 0,
		.returned_var_name = (string){.str=(byteptr)"", .is_lit=1},
		.infix_left_var_name = (string){.str=(byteptr)"", .is_lit=1},
		.called_fn_name = (string){.str=(byteptr)"", .is_lit=1},
		.timers = v__util__new_timers((v__util__TimerParams){.should_print = global_g->timers_should_print,.label =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("cgen_process_one_file_cb idx: "), 0xfe07, {.d_i32 = idx}}, {_SLIT(", wid: "), 0xfe07, {.d_i32 = wid}}, {_SLIT0, 0, { .d_c = 0 }}})),}),
		.force_main_console = 0,
		.as_cast_type_names = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.obf_table = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.referenced_fns = global_g->referenced_fns,
		.nr_closures = 0,
		.expected_cast_type = 0,
		.anon_fn = 0,
		.tests_inited = 0,
		.has_main = 0,
		.cur_mod = (v__ast__Module){.name = (string){.str=(byteptr)"", .is_lit=1},.short_name = (string){.str=(byteptr)"", .is_lit=1},.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.name_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.is_skipped = 0,},
		.cur_concrete_types = __new_array(0, 0, sizeof(v__ast__Type)),
		.cur_fn = 0,
		.cur_lock = (v__ast__LockExpr){.stmts = __new_array(0, 0, sizeof(v__ast__Stmt)),.is_rlock = __new_array(0, 0, sizeof(bool)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.lockeds = __new_array(0, 0, sizeof(v__ast__Expr)),.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.is_expr = 0,.typ = 0,.scope = 0,},
	}, sizeof(v__gen__c__Gen));
	v__gen__c__Gen_gen_file(g);
	v__gen__c__Gen* _t1 = g;
	return _t1;
}

// Attr: [unsafe]
void v__gen__c__Gen_free_builders(v__gen__c__Gen* g) {
	{ // Unsafe block
		strings__Builder_free(&g->out);
		strings__Builder_free(&g->cheaders);
		strings__Builder_free(&g->includes);
		strings__Builder_free(&g->typedefs);
		strings__Builder_free(&g->type_definitions);
		strings__Builder_free(&g->definitions);
		strings__Builder_free(&g->global_init);
		strings__Builder_free(&g->init);
		strings__Builder_free(&g->cleanup);
		strings__Builder_free(&g->gowrappers);
		strings__Builder_free(&g->stringliterals);
		strings__Builder_free(&g->auto_str_funcs);
		strings__Builder_free(&g->comptime_definitions);
		strings__Builder_free(&g->pcs_declarations);
		strings__Builder_free(&g->hotcode_definitions);
		strings__Builder_free(&g->embedded_data);
		strings__Builder_free(&g->shared_types);
		strings__Builder_free(&g->shared_functions);
		strings__Builder_free(&g->channel_definitions);
		strings__Builder_free(&g->options);
		strings__Builder_free(&g->json_forward_decls);
		strings__Builder_free(&g->enum_typedefs);
		strings__Builder_free(&g->sql_buf);
		Map_string_strings__Builder _t1 = g->global_inits;
		int _t3 = _t1.key_values.len;
		for (int _t2 = 0; _t2 < _t3; ++_t2 ) {
			int _t4 = _t1.key_values.len - _t3;
			_t3 = _t1.key_values.len;
			if (_t4 < 0) {
				_t2 = -1;
				continue;
			}
			if (!DenseArray_has_index(&_t1.key_values, _t2)) {continue;}
			strings__Builder* v = &(*(strings__Builder*)DenseArray_value(&_t1.key_values, _t2));
			strings__Builder_free(v);
		}
		Map_string_strings__Builder _t5 = g->inits;
		int _t7 = _t5.key_values.len;
		for (int _t6 = 0; _t6 < _t7; ++_t6 ) {
			int _t8 = _t5.key_values.len - _t7;
			_t7 = _t5.key_values.len;
			if (_t8 < 0) {
				_t6 = -1;
				continue;
			}
			if (!DenseArray_has_index(&_t5.key_values, _t6)) {continue;}
			strings__Builder* v = &(*(strings__Builder*)DenseArray_value(&_t5.key_values, _t6));
			strings__Builder_free(v);
		}
		Map_string_strings__Builder _t9 = g->cleanups;
		int _t11 = _t9.key_values.len;
		for (int _t10 = 0; _t10 < _t11; ++_t10 ) {
			int _t12 = _t9.key_values.len - _t11;
			_t11 = _t9.key_values.len;
			if (_t12 < 0) {
				_t10 = -1;
				continue;
			}
			if (!DenseArray_has_index(&_t9.key_values, _t10)) {continue;}
			strings__Builder* v = &(*(strings__Builder*)DenseArray_value(&_t9.key_values, _t10));
			strings__Builder_free(v);
		}
	}
}

void v__gen__c__Gen_gen_file(v__gen__c__Gen* g) {
	v__util__Timers_start(g->timers,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cgen_file "), 0xfe10, {.d_s = g->file->path}}, {_SLIT0, 0, { .d_c = 0 }}})));
	g->unique_file_path_hash = hash__fnv1a__sum64_string(g->file->path);
	if (g->pref->is_vlines) {
		g->vlines_path = v__util__vlines_escape_path(g->file->path, g->pref->ccompiler);
		g->is_vlines_enabled = true;
		g->inside_ternary = 0;
	}
	v__gen__c__Gen_stmts(g, g->file->stmts);
	for (int _t1 = 0; _t1 < g->file->embedded_files.len; ++_t1) {
		v__ast__EmbeddedFile path = ((v__ast__EmbeddedFile*)g->file->embedded_files.data)[_t1];
		if (!Array_v__ast__EmbeddedFile_contains(g->embedded_files, path)) {
			array_push((array*)&g->embedded_files, _MOV((v__ast__EmbeddedFile[]){ path }));
		}
	}
	v__util__Timers_show(g->timers,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cgen_file "), 0xfe10, {.d_s = g->file->path}}, {_SLIT0, 0, { .d_c = 0 }}})));
}

string v__gen__c__Gen_hashes(v__gen__c__Gen* g) {
	string res = string_replace(_const_v__gen__c__c_commit_hash_default, _SLIT("@@@"), v__util__version__vhash());
	res = /*f*/string__plus(res, string_replace(_const_v__gen__c__c_current_commit_hash_default, _SLIT("@@@"), v__util__version__githash(g->pref->building_v)));
	string _t1 = res;
	return _t1;
}

void v__gen__c__Gen_init(v__gen__c__Gen* g) {
	if ((g->pref->custom_prelude).len != 0) {
		strings__Builder_writeln(&g->cheaders, g->pref->custom_prelude);
	} else if (!g->pref->no_preludes) {
		strings__Builder_writeln(&g->cheaders, _SLIT("// Generated by the V compiler"));
		string tcc_undef_has_include = _SLIT("\n#if defined(__TINYC__) && defined(__has_include)\n// tcc does not support has_include properly yet, turn it off completely\n#undef __has_include\n#endif");
		strings__Builder_writeln(&g->cheaders, tcc_undef_has_include);
		strings__Builder_writeln(&g->includes, tcc_undef_has_include);
		if (g->pref->os == v__pref__OS__freebsd) {
			strings__Builder_writeln(&g->cheaders, _SLIT("#include <inttypes.h>"));
			strings__Builder_writeln(&g->cheaders, _SLIT("#include <stddef.h>"));
		} else {
			strings__Builder_writeln(&g->cheaders, v__gen__c__get_guarded_include_text(_SLIT("<inttypes.h>"), _SLIT("The C compiler can not find <inttypes.h>. Please install build-essentials")));
			strings__Builder_writeln(&g->cheaders, v__gen__c__get_guarded_include_text(_SLIT("<stddef.h>"), _SLIT("The C compiler can not find <stddef.h>. Please install build-essentials")));
		}
		strings__Builder_writeln(&g->cheaders, _const_v__gen__c__c_builtin_types);
		if (g->pref->is_bare) {
			strings__Builder_writeln(&g->cheaders, _const_v__gen__c__c_bare_headers);
		} else {
			strings__Builder_writeln(&g->cheaders, _const_v__gen__c__c_headers);
		}
		if (!g->pref->skip_unused || g->table->used_maps > 0) {
			strings__Builder_writeln(&g->cheaders, _const_v__gen__c__c_wyhash_headers);
		}
	}
	if (g->pref->os == v__pref__OS__ios) {
		strings__Builder_writeln(&g->cheaders, _SLIT("#define __TARGET_IOS__ 1"));
		strings__Builder_writeln(&g->cheaders, _SLIT("#include <spawn.h>"));
	}
	v__gen__c__Gen_write_builtin_types(g);
	v__gen__c__Gen_write_typedef_types(g);
	v__gen__c__Gen_write_typeof_functions(g);
	v__gen__c__Gen_write_sorted_types(g);
	v__gen__c__Gen_write_multi_return_types(g);
	strings__Builder_writeln(&g->definitions, _SLIT("// end of definitions #endif"));
	if (!g->pref->no_builtin) {
		strings__Builder_writeln(&g->stringliterals, _SLIT(""));
		strings__Builder_writeln(&g->stringliterals, _SLIT("// >> string literal consts"));
		if (g->pref->build_mode != v__pref__BuildMode__build_module) {
			strings__Builder_writeln(&g->stringliterals, _SLIT("void vinit_string_literals(void){"));
		}
	}
	if (g->pref->compile_defines_all.len > 0) {
		strings__Builder_writeln(&g->comptime_definitions, _SLIT("// V compile time defines by -d or -define flags:"));
		strings__Builder_writeln(&g->comptime_definitions, string__plus(_SLIT("//     All custom defines      : "), Array_string_join(g->pref->compile_defines_all, _SLIT(","))));
		strings__Builder_writeln(&g->comptime_definitions, string__plus(_SLIT("//     Turned ON custom defines: "), Array_string_join(g->pref->compile_defines, _SLIT(","))));
		for (int _t1 = 0; _t1 < g->pref->compile_defines.len; ++_t1) {
			string cdefine = ((string*)g->pref->compile_defines.data)[_t1];
			strings__Builder_writeln(&g->comptime_definitions,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("#define CUSTOM_DEFINE_"), 0xfe10, {.d_s = cdefine}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		strings__Builder_writeln(&g->comptime_definitions, _SLIT(""));
	}
	if (g->table->gostmts > 0) {
		strings__Builder_writeln(&g->comptime_definitions, _SLIT("#define __VTHREADS__ (1)"));
	}
	if (g->pref->gc_mode == v__pref__GarbageCollectionMode__boehm_full || g->pref->gc_mode == v__pref__GarbageCollectionMode__boehm_incr || g->pref->gc_mode == v__pref__GarbageCollectionMode__boehm_full_opt || g->pref->gc_mode == v__pref__GarbageCollectionMode__boehm_incr_opt || g->pref->gc_mode == v__pref__GarbageCollectionMode__boehm_leak) {
		strings__Builder_writeln(&g->comptime_definitions, _SLIT("#define _VGCBOEHM (1)"));
	}
	if (g->pref->is_debug || Array_string_contains(g->pref->compile_defines, _SLIT("debug"))) {
		strings__Builder_writeln(&g->comptime_definitions, _SLIT("#define _VDEBUG (1)"));
	}
	if (g->pref->is_prod || Array_string_contains(g->pref->compile_defines, _SLIT("prod"))) {
		strings__Builder_writeln(&g->comptime_definitions, _SLIT("#define _VPROD (1)"));
	}
	if (g->pref->is_test || Array_string_contains(g->pref->compile_defines, _SLIT("test"))) {
		strings__Builder_writeln(&g->comptime_definitions, _SLIT("#define _VTEST (1)"));
	}
	if (g->pref->autofree) {
		strings__Builder_writeln(&g->comptime_definitions, _SLIT("#define _VAUTOFREE (1)"));
	}
	if (g->pref->prealloc) {
		strings__Builder_writeln(&g->comptime_definitions, _SLIT("#define _VPREALLOC (1)"));
	}
	if (g->pref->is_livemain || g->pref->is_liveshared) {
		v__gen__c__Gen_generate_hotcode_reloading_declarations(g);
	}
	if (g->pref->obfuscate) {
		int i = 0;
		Map_string_v__ast__Fn _t2 = g->table->fns;
		int _t4 = _t2.key_values.len;
		for (int _t3 = 0; _t3 < _t4; ++_t3 ) {
			int _t5 = _t2.key_values.len - _t4;
			_t4 = _t2.key_values.len;
			if (_t5 < 0) {
				_t3 = -1;
				continue;
			}
			if (!DenseArray_has_index(&_t2.key_values, _t3)) {continue;}
			string key = /*key*/ *(string*)DenseArray_key(&_t2.key_values, _t3);
			key = string_clone(key);
			v__ast__Fn f = (*(v__ast__Fn*)DenseArray_value(&_t2.key_values, _t3));
			if (!string__eq(f.mod, _SLIT("main")) && !string__eq(key, _SLIT("main"))) {
				continue;
			}
			map_set(&g->obf_table, &(string[]){key}, &(string[]) {  str_intp(2, _MOV((StrIntpData[]){{_SLIT("_f"), 0xfe07, {.d_i32 = i}}, {_SLIT0, 0, { .d_c = 0 }}})) });
			i++;
		}
		for (int _t6 = 0; _t6 < g->table->type_symbols.len; ++_t6) {
			v__ast__TypeSymbol* type_sym = ((v__ast__TypeSymbol**)g->table->type_symbols.data)[_t6];
			if (!string__eq(type_sym->mod, _SLIT("main"))) {
				continue;
			}
			for (int _t7 = 0; _t7 < type_sym->methods.len; ++_t7) {
				v__ast__Fn method = ((v__ast__Fn*)type_sym->methods.data)[_t7];
				map_set(&g->obf_table, &(string[]){string__plus(string__plus(type_sym->name, _SLIT(".")), method.name)}, &(string[]) {  str_intp(2, _MOV((StrIntpData[]){{_SLIT("_f"), 0xfe07, {.d_i32 = i}}, {_SLIT0, 0, { .d_c = 0 }}})) });
				i++;
			}
		}
	}
	v__ast__Table* muttable = ((v__ast__Table*)(g->table));
	map_set(&muttable->used_fns, &(string[]){_SLIT("v_segmentation_fault_handler")}, &(bool[]) { true });
	map_set(&muttable->used_fns, &(string[]){_SLIT("eprintln")}, &(bool[]) { true });
	map_set(&muttable->used_fns, &(string[]){_SLIT("print_backtrace")}, &(bool[]) { true });
	map_set(&muttable->used_fns, &(string[]){_SLIT("exit")}, &(bool[]) { true });
}

void v__gen__c__Gen_finish(v__gen__c__Gen* g) {
	if (!g->pref->no_builtin) {
		if (g->pref->build_mode != v__pref__BuildMode__build_module) {
			strings__Builder_writeln(&g->stringliterals, _SLIT("}"));
		}
		strings__Builder_writeln(&g->stringliterals, _SLIT("// << string literal consts"));
		strings__Builder_writeln(&g->stringliterals, _SLIT(""));
	}
	if (g->pref->is_prof && g->pref->build_mode != v__pref__BuildMode__build_module) {
		v__gen__c__Gen_gen_vprint_profile_stats(g);
	}
	if (g->pref->is_livemain || g->pref->is_liveshared) {
		v__gen__c__Gen_generate_hotcode_reloader_code(g);
	}
	if (v__gen__c__Gen_embed_file_is_prod_mode(g) && g->embedded_files.len > 0) {
		v__gen__c__Gen_gen_embedded_data(g);
	}
	if (g->pref->is_test) {
		v__gen__c__Gen_gen_c_main_for_tests(g);
	} else {
		v__gen__c__Gen_gen_c_main(g);
	}
}

void v__gen__c__Gen_write_typeof_functions(v__gen__c__Gen* g) {
	v__gen__c__Gen_writeln(g, _SLIT(""));
	v__gen__c__Gen_writeln(g, _SLIT("// >> typeof() support for sum types / interfaces"));
	for (int ityp = 0; ityp < g->table->type_symbols.len; ++ityp) {
		v__ast__TypeSymbol* sym = ((v__ast__TypeSymbol**)g->table->type_symbols.data)[ityp];
		if (sym->kind == v__ast__Kind__sum_type) {
			v__ast__SumType sum_info = /* as */ *(v__ast__SumType*)__as_cast((sym->info)._v__ast__SumType,(sym->info)._typ, 464) /*expected idx: 464, name: v.ast.SumType */ ;
			if (sum_info.is_generic) {
				continue;
			}
			v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("static char * v_typeof_sumtype_"), 0xfe10, {.d_s = sym->cname}}, {_SLIT("(int sidx) { /* "), 0xfe10, {.d_s = sym->name}}, {_SLIT(" */ "), 0, { .d_c = 0 }}})));
			if (g->pref->build_mode == v__pref__BuildMode__build_module) {
				v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\tif( sidx == _v_type_idx_"), 0xfe10, {.d_s = sym->cname}}, {_SLIT("() ) return \""), 0xfe10, {.d_s = v__util__strip_main_name(sym->name)}}, {_SLIT("\";"), 0, { .d_c = 0 }}})));
				for (int _t1 = 0; _t1 < sum_info.variants.len; ++_t1) {
					v__ast__Type v = ((v__ast__Type*)sum_info.variants.data)[_t1];
					v__ast__TypeSymbol* subtype = v__ast__Table_sym(g->table, v);
					v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\tif( sidx == _v_type_idx_"), 0xfe10, {.d_s = subtype->cname}}, {_SLIT("() ) return \""), 0xfe10, {.d_s = v__util__strip_main_name(subtype->name)}}, {_SLIT("\";"), 0, { .d_c = 0 }}})));
				}
				v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\treturn \"unknown "), 0xfe10, {.d_s = v__util__strip_main_name(sym->name)}}, {_SLIT("\";"), 0, { .d_c = 0 }}})));
			} else {
				int tidx = v__ast__Table_find_type_idx(g->table, sym->name);
				v__gen__c__Gen_writeln(g, _SLIT("\tswitch(sidx) {"));
				v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\tcase "), 0xfe07, {.d_i32 = tidx}}, {_SLIT(": return \""), 0xfe10, {.d_s = v__util__strip_main_name(sym->name)}}, {_SLIT("\";"), 0, { .d_c = 0 }}})));
				for (int _t2 = 0; _t2 < sum_info.variants.len; ++_t2) {
					v__ast__Type v = ((v__ast__Type*)sum_info.variants.data)[_t2];
					v__ast__TypeSymbol* subtype = v__ast__Table_sym(g->table, v);
					v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\tcase "), 0xfe07, {.d_i32 = v}}, {_SLIT(": return \""), 0xfe10, {.d_s = v__util__strip_main_name(subtype->name)}}, {_SLIT("\";"), 0, { .d_c = 0 }}})));
				}
				v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\tdefault: return \"unknown "), 0xfe10, {.d_s = v__util__strip_main_name(sym->name)}}, {_SLIT("\";"), 0, { .d_c = 0 }}})));
				v__gen__c__Gen_writeln(g, _SLIT("\t}"));
			}
			v__gen__c__Gen_writeln(g, _SLIT("}"));
			v__gen__c__Gen_writeln(g, _SLIT(""));
			v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("int v_typeof_sumtype_idx_"), 0xfe10, {.d_s = sym->cname}}, {_SLIT("(int sidx) { /* "), 0xfe10, {.d_s = sym->name}}, {_SLIT(" */ "), 0, { .d_c = 0 }}})));
			if (g->pref->build_mode == v__pref__BuildMode__build_module) {
				v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\tif( sidx == _v_type_idx_"), 0xfe10, {.d_s = sym->cname}}, {_SLIT("() ) return "), 0xfe07, {.d_i32 = ((int)(ityp))}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
				for (int _t3 = 0; _t3 < sum_info.variants.len; ++_t3) {
					v__ast__Type v = ((v__ast__Type*)sum_info.variants.data)[_t3];
					v__ast__TypeSymbol* subtype = v__ast__Table_sym(g->table, v);
					v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\tif( sidx == _v_type_idx_"), 0xfe10, {.d_s = subtype->cname}}, {_SLIT("() ) return "), 0xfe07, {.d_i32 = ((int)(v))}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
				}
				v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\treturn "), 0xfe07, {.d_i32 = ((int)(ityp))}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
			} else {
				int tidx = v__ast__Table_find_type_idx(g->table, sym->name);
				v__gen__c__Gen_writeln(g, _SLIT("\tswitch(sidx) {"));
				v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\tcase "), 0xfe07, {.d_i32 = tidx}}, {_SLIT(": return "), 0xfe07, {.d_i32 = ((int)(ityp))}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
				for (int _t4 = 0; _t4 < sum_info.variants.len; ++_t4) {
					v__ast__Type v = ((v__ast__Type*)sum_info.variants.data)[_t4];
					v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\tcase "), 0xfe07, {.d_i32 = v}}, {_SLIT(": return "), 0xfe07, {.d_i32 = ((int)(v))}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
				}
				v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\tdefault: return "), 0xfe07, {.d_i32 = ((int)(ityp))}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
				v__gen__c__Gen_writeln(g, _SLIT("\t}"));
			}
			v__gen__c__Gen_writeln(g, _SLIT("}"));
		} else if (sym->kind == v__ast__Kind__interface_) {
			if ((sym->info)._typ != 463 /* v.ast.Interface */) {
				continue;
			}
			v__ast__Interface inter_info = /* as */ *(v__ast__Interface*)__as_cast((sym->info)._v__ast__Interface,(sym->info)._typ, 463) /*expected idx: 463, name: v.ast.Interface */ ;
			if (inter_info.is_generic) {
				continue;
			}
			strings__Builder_writeln(&g->definitions,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("static char * v_typeof_interface_"), 0xfe10, {.d_s = sym->cname}}, {_SLIT("(int sidx);"), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("static char * v_typeof_interface_"), 0xfe10, {.d_s = sym->cname}}, {_SLIT("(int sidx) { /* "), 0xfe10, {.d_s = sym->name}}, {_SLIT(" */ "), 0, { .d_c = 0 }}})));
			for (int _t5 = 0; _t5 < inter_info.types.len; ++_t5) {
				v__ast__Type t = ((v__ast__Type*)inter_info.types.data)[_t5];
				v__ast__TypeSymbol* subtype = v__ast__Table_sym(g->table, t);
				v__gen__c__Gen_writeln(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\tif (sidx == _"), 0xfe10, {.d_s = sym->cname}}, {_SLIT("_"), 0xfe10, {.d_s = subtype->cname}}, {_SLIT("_index) return \""), 0xfe10, {.d_s = v__util__strip_main_name(subtype->name)}}, {_SLIT("\";"), 0, { .d_c = 0 }}})));
			}
			v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\treturn \"unknown "), 0xfe10, {.d_s = v__util__strip_main_name(sym->name)}}, {_SLIT("\";"), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_writeln(g, _SLIT("}"));
			v__gen__c__Gen_writeln(g, _SLIT(""));
			v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("static int v_typeof_interface_idx_"), 0xfe10, {.d_s = sym->cname}}, {_SLIT("(int sidx) { /* "), 0xfe10, {.d_s = sym->name}}, {_SLIT(" */ "), 0, { .d_c = 0 }}})));
			for (int _t6 = 0; _t6 < inter_info.types.len; ++_t6) {
				v__ast__Type t = ((v__ast__Type*)inter_info.types.data)[_t6];
				v__ast__TypeSymbol* subtype = v__ast__Table_sym(g->table, t);
				v__gen__c__Gen_writeln(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\tif (sidx == _"), 0xfe10, {.d_s = sym->cname}}, {_SLIT("_"), 0xfe10, {.d_s = subtype->cname}}, {_SLIT("_index) return "), 0xfe07, {.d_i32 = ((int)(t))}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
			}
			v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\treturn "), 0xfe07, {.d_i32 = ((int)(ityp))}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_writeln(g, _SLIT("}"));
		}
	}
	v__gen__c__Gen_writeln(g, _SLIT("// << typeof() support for sum types"));
	v__gen__c__Gen_writeln(g, _SLIT(""));
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_typ(v__gen__c__Gen* g, v__ast__Type t) {
	if (v__ast__Type_has_flag(t, v__ast__TypeFlag__optional)) {
		string _t1 = v__gen__c__Gen_register_optional(g, t);
		return _t1;
	} else {
		string _t2 = v__gen__c__Gen_base_type(g, t);
		return _t2;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_base_type(v__gen__c__Gen* g, v__ast__Type _t) {
	v__ast__Type t = v__gen__c__Gen_unwrap_generic(g, _t);
	if (g->pref->nofloat) {
		if (v__ast__Type_alias_eq(t, _const_v__ast__f32_type)) {
			string _t1 = _SLIT("u32");
			return _t1;
		} else if (v__ast__Type_alias_eq(t, _const_v__ast__f64_type)) {
			string _t2 = _SLIT("u64");
			return _t2;
		}
	}
	v__ast__ShareType share = v__ast__Type_share(t);
	string styp = (share == v__ast__ShareType__atomic_t ? (v__ast__Type_atomic_typename(t)) : (v__gen__c__Gen_cc_type(g, t, true)));
	if (v__ast__Type_has_flag(t, v__ast__TypeFlag__shared_f)) {
		styp = v__gen__c__Gen_find_or_register_shared(g, t, styp);
	}
	if (!v__ast__Type_has_flag(t, v__ast__TypeFlag__variadic)) {
		int nr_muls = v__ast__Type_nr_muls(v__gen__c__Gen_unwrap_generic(g, t));
		if (nr_muls > 0) {
			styp = /*f*/string__plus(styp, strings__repeat('*', nr_muls));
		}
	}
	string _t3 = styp;
	return _t3;
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_generic_fn_name(v__gen__c__Gen* g, Array_v__ast__Type types, string before, bool is_decl) {
	if (types.len == 0) {
		string _t1 = before;
		return _t1;
	}
	string name = string__plus(before, _SLIT("_T"));
	for (int _t2 = 0; _t2 < types.len; ++_t2) {
		v__ast__Type typ = ((v__ast__Type*)types.data)[_t2];
		name = /*f*/string__plus(name, string__plus(string__plus(_SLIT("_"), strings__repeat_string(_SLIT("__ptr__"), v__ast__Type_nr_muls(typ))), v__gen__c__Gen_typ(g, v__ast__Type_set_nr_muls(typ, 0))));
	}
	string _t3 = name;
	return _t3;
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_expr_string(v__gen__c__Gen* g, v__ast__Expr expr) {
	int pos = g->out.len;
	v__gen__c__Gen_expr(g, expr);
	string _t1 = string_trim_space(strings__Builder_cut_to(&g->out, pos));
	return _t1;
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_expr_string_with_cast(v__gen__c__Gen* g, v__ast__Expr expr, v__ast__Type typ, v__ast__Type exp) {
	int pos = g->out.len;
	v__gen__c__Gen_expr_with_cast(g, expr, typ, exp);
	string _t1 = string_trim_space(strings__Builder_cut_to(&g->out, pos));
	return _t1;
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_expr_string_surround(v__gen__c__Gen* g, string prepend, v__ast__Expr expr, string append) {
bool v__gen__c__Gen_expr_string_surround_defer_0 = false;
	int pos = g->out.len;
	array_push((array*)&g->stmt_path_pos, _MOV((int[]){ pos }));
	v__gen__c__Gen_expr_string_surround_defer_0 = true;
	v__gen__c__Gen_write(g, prepend);
	v__gen__c__Gen_expr(g, expr);
	v__gen__c__Gen_write(g, append);
	string _t2 = strings__Builder_cut_to(&g->out, pos);
	// Defer begin
	if (v__gen__c__Gen_expr_string_surround_defer_0) {
		array_delete_last(&g->stmt_path_pos);
	}
	// Defer end
	return _t2;
}

VV_LOCAL_SYMBOL multi_return_string_string v__gen__c__Gen_optional_type_name(v__gen__c__Gen* g, v__ast__Type t) {
	string base = v__gen__c__Gen_base_type(g, t);
	string styp =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("Option_"), 0xfe10, {.d_s = base}}, {_SLIT0, 0, { .d_c = 0 }}}));
	if (v__ast__Type_is_ptr(t)) {
		styp = string_replace(styp, _SLIT("*"), _SLIT("_ptr"));
	}
	return (multi_return_string_string){.arg0=styp, .arg1=base};
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_optional_type_text(v__gen__c__Gen* g, string styp, string base) {
	string size = (string__eq(base, _SLIT("void")) ? (_SLIT("byte")) : (base));
	string ret =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("struct "), 0xfe10, {.d_s = styp}}, {_SLIT(" {\n	byte state;\n	IError err;\n	byte data[sizeof("), 0xfe10, {.d_s = size}}, {_SLIT(")];\n}"), 0, { .d_c = 0 }}}));
	string _t1 = ret;
	return _t1;
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_register_optional(v__gen__c__Gen* g, v__ast__Type t) {
	multi_return_string_string mr_34226 = v__gen__c__Gen_optional_type_name(g, t);
	string styp = mr_34226.arg0;
	string base = mr_34226.arg1;
	map_set(&g->optionals, &(string[]){base}, &(string[]) { styp });
	string _t1 = styp;
	return _t1;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_write_optionals(v__gen__c__Gen* g) {
	Array_string done = array_clone_to_depth(&g->done_optionals->val, 0);
	Map_string_string _t1 = g->optionals;
	int _t3 = _t1.key_values.len;
	for (int _t2 = 0; _t2 < _t3; ++_t2 ) {
		int _t4 = _t1.key_values.len - _t3;
		_t3 = _t1.key_values.len;
		if (_t4 < 0) {
			_t2 = -1;
			continue;
		}
		if (!DenseArray_has_index(&_t1.key_values, _t2)) {continue;}
		string base = /*key*/ *(string*)DenseArray_key(&_t1.key_values, _t2);
		base = string_clone(base);
		string styp = (*(string*)DenseArray_value(&_t1.key_values, _t2));
		if (Array_string_contains(done, base)) {
			continue;
		}
		array_push((array*)&done, _MOV((string[]){ string_clone(base) }));
		strings__Builder_writeln(&g->typedefs,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("typedef struct "), 0xfe10, {.d_s = styp}}, {_SLIT(" "), 0xfe10, {.d_s = styp}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
		strings__Builder_write_string(&g->options, string__plus(v__gen__c__Gen_optional_type_text(g, styp, base), _SLIT(";\n\n")));
	}
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_find_or_register_shared(v__gen__c__Gen* g, v__ast__Type t, string base) {
	map_set(&g->shareds, &(int[]){v__ast__Type_idx(t)}, &(string[]) { base });
	string _t1 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("__shared__"), 0xfe10, {.d_s = base}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t1;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_write_shareds(v__gen__c__Gen* g) {
	Array_int done_types = __new_array_with_default(0, 0, sizeof(int), 0);
	Map_int_string _t1 = g->shareds;
	int _t3 = _t1.key_values.len;
	for (int _t2 = 0; _t2 < _t3; ++_t2 ) {
		int _t4 = _t1.key_values.len - _t3;
		_t3 = _t1.key_values.len;
		if (_t4 < 0) {
			_t2 = -1;
			continue;
		}
		if (!DenseArray_has_index(&_t1.key_values, _t2)) {continue;}
		int typ = /*key*/ *(int*)DenseArray_key(&_t1.key_values, _t2);
		string base = (*(string*)DenseArray_value(&_t1.key_values, _t2));
		if (Array_int_contains(done_types, typ)) {
			continue;
		}
		array_push((array*)&done_types, _MOV((int[]){ typ }));
		string sh_typ =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("__shared__"), 0xfe10, {.d_s = base}}, {_SLIT0, 0, { .d_c = 0 }}}));
		string mtx_typ = _SLIT("sync__RwMutex");
		strings__Builder_writeln(&g->shared_types,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("struct "), 0xfe10, {.d_s = sh_typ}}, {_SLIT(" {"), 0, { .d_c = 0 }}})));
		strings__Builder_writeln(&g->shared_types,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = mtx_typ}}, {_SLIT(" mtx;"), 0, { .d_c = 0 }}})));
		strings__Builder_writeln(&g->shared_types,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = base}}, {_SLIT(" val;"), 0, { .d_c = 0 }}})));
		strings__Builder_writeln(&g->shared_types, _SLIT("};"));
		strings__Builder_writeln(&g->shared_functions,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("static inline voidptr __dup"), 0xfe10, {.d_s = sh_typ}}, {_SLIT("(voidptr src, int sz) {"), 0, { .d_c = 0 }}})));
		strings__Builder_writeln(&g->shared_functions,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = sh_typ}}, {_SLIT("* dest = memdup(src, sz);"), 0, { .d_c = 0 }}})));
		strings__Builder_writeln(&g->shared_functions, _SLIT("\tsync__RwMutex_init(&dest->mtx);"));
		strings__Builder_writeln(&g->shared_functions, _SLIT("\treturn dest;"));
		strings__Builder_writeln(&g->shared_functions, _SLIT("}"));
		strings__Builder_writeln(&g->typedefs,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("typedef struct "), 0xfe10, {.d_s = sh_typ}}, {_SLIT(" "), 0xfe10, {.d_s = sh_typ}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_register_thread_void_wait_call(v__gen__c__Gen* g) {
	sync__RwMutex_lock(&g->waiter_fns->mtx);
	/*lock*/ {
		if (Array_string_contains(g->waiter_fns->val, _SLIT("__v_thread_wait"))) {
			sync__RwMutex_unlock(&g->waiter_fns->mtx);return;
		}
		array_push((array*)&g->waiter_fns->val, _MOV((string[]){ string_clone(_SLIT("__v_thread_wait")) }));
	}
	sync__RwMutex_unlock(&g->waiter_fns->mtx);;
	strings__Builder_writeln(&g->gowrappers, _SLIT("void __v_thread_wait(__v_thread thread) {"));
	if (g->pref->os == v__pref__OS__windows) {
		strings__Builder_writeln(&g->gowrappers, _SLIT("\tu32 stat = WaitForSingleObject(thread, INFINITE);"));
	} else {
		strings__Builder_writeln(&g->gowrappers, _SLIT("\tint stat = pthread_join(thread, (void **)NULL);"));
	}
	strings__Builder_writeln(&g->gowrappers, _SLIT("\tif (stat != 0) { _v_panic(_SLIT(\"unable to join thread\")); }"));
	if (g->pref->os == v__pref__OS__windows) {
		strings__Builder_writeln(&g->gowrappers, _SLIT("\tCloseHandle(thread);"));
	}
	strings__Builder_writeln(&g->gowrappers, _SLIT("}"));
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_register_thread_array_wait_call(v__gen__c__Gen* g, string eltyp) {
	bool is_void = string__eq(eltyp, _SLIT("void"));
	string thread_typ = (is_void ? (_SLIT("__v_thread")) : ( str_intp(2, _MOV((StrIntpData[]){{_SLIT("__v_thread_"), 0xfe10, {.d_s = eltyp}}, {_SLIT0, 0, { .d_c = 0 }}}))));
	string ret_typ = (is_void ? (_SLIT("void")) : ( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Array_"), 0xfe10, {.d_s = eltyp}}, {_SLIT0, 0, { .d_c = 0 }}}))));
	string thread_arr_typ =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("Array_"), 0xfe10, {.d_s = thread_typ}}, {_SLIT0, 0, { .d_c = 0 }}}));
	string fn_name =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = thread_arr_typ}}, {_SLIT("_wait"), 0, { .d_c = 0 }}}));
	bool should_register = false;
	sync__RwMutex_lock(&g->waiter_fns->mtx);
	/*lock*/ {
		if (!Array_string_contains(g->waiter_fns->val, fn_name)) {
			array_push((array*)&g->waiter_fns->val, _MOV((string[]){ string_clone(fn_name) }));
			should_register = true;
		}
	}
	sync__RwMutex_unlock(&g->waiter_fns->mtx);;
	if (should_register) {
		if (is_void) {
			v__gen__c__Gen_register_thread_void_wait_call(g);
			strings__Builder_writeln(&g->gowrappers,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("\nvoid "), 0xfe10, {.d_s = fn_name}}, {_SLIT("("), 0xfe10, {.d_s = thread_arr_typ}}, {_SLIT(" a) {\n	for (int i = 0; i < a.len; ++i) {\n		"), 0xfe10, {.d_s = thread_typ}}, {_SLIT(" t = (("), 0xfe10, {.d_s = thread_typ}}, {_SLIT("*)a.data)[i];\n		if (t == 0) continue;\n		__v_thread_wait(t);\n	}\n}"), 0, { .d_c = 0 }}})));
		} else {
			strings__Builder_writeln(&g->gowrappers,  str_intp(8, _MOV((StrIntpData[]){{_SLIT("\n"), 0xfe10, {.d_s = ret_typ}}, {_SLIT(" "), 0xfe10, {.d_s = fn_name}}, {_SLIT("("), 0xfe10, {.d_s = thread_arr_typ}}, {_SLIT(" a) {\n	"), 0xfe10, {.d_s = ret_typ}}, {_SLIT(" res = __new_array_with_default(a.len, a.len, sizeof("), 0xfe10, {.d_s = eltyp}}, {_SLIT("), 0);\n	for (int i = 0; i < a.len; ++i) {\n		"), 0xfe10, {.d_s = thread_typ}}, {_SLIT(" t = (("), 0xfe10, {.d_s = thread_typ}}, {_SLIT("*)a.data)[i];"), 0, { .d_c = 0 }}})));
			if (g->pref->os == v__pref__OS__windows) {
				strings__Builder_writeln(&g->gowrappers, _SLIT("\t\tif (t.handle == 0) continue;"));
			} else {
				strings__Builder_writeln(&g->gowrappers, _SLIT("\t\tif (t == 0) continue;"));
			}
			strings__Builder_writeln(&g->gowrappers,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\t(("), 0xfe10, {.d_s = eltyp}}, {_SLIT("*)res.data)[i] = __v_thread_"), 0xfe10, {.d_s = eltyp}}, {_SLIT("_wait(t);\n	}\n	return res;\n}"), 0, { .d_c = 0 }}})));
		}
	}
	string _t2 = fn_name;
	return _t2;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_register_chan_pop_optional_call(v__gen__c__Gen* g, string opt_el_type, string styp) {
	map_set(&g->chan_pop_optionals, &(string[]){opt_el_type}, &(string[]) { styp });
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_write_chan_pop_optional_fns(v__gen__c__Gen* g) {
	Array_string done = __new_array_with_default(0, 0, sizeof(string), 0);
	Map_string_string _t1 = g->chan_pop_optionals;
	int _t3 = _t1.key_values.len;
	for (int _t2 = 0; _t2 < _t3; ++_t2 ) {
		int _t4 = _t1.key_values.len - _t3;
		_t3 = _t1.key_values.len;
		if (_t4 < 0) {
			_t2 = -1;
			continue;
		}
		if (!DenseArray_has_index(&_t1.key_values, _t2)) {continue;}
		string opt_el_type = /*key*/ *(string*)DenseArray_key(&_t1.key_values, _t2);
		opt_el_type = string_clone(opt_el_type);
		string styp = (*(string*)DenseArray_value(&_t1.key_values, _t2));
		if (Array_string_contains(done, opt_el_type)) {
			continue;
		}
		array_push((array*)&done, _MOV((string[]){ string_clone(opt_el_type) }));
		strings__Builder_writeln(&g->channel_definitions,  str_intp(6, _MOV((StrIntpData[]){{_SLIT("\nstatic inline "), 0xfe10, {.d_s = opt_el_type}}, {_SLIT(" __Option_"), 0xfe10, {.d_s = styp}}, {_SLIT("_popval("), 0xfe10, {.d_s = styp}}, {_SLIT(" ch) {\n	"), 0xfe10, {.d_s = opt_el_type}}, {_SLIT(" _tmp = {0};\n	if (sync__Channel_try_pop_priv(ch, _tmp.data, false)) {\n		return ("), 0xfe10, {.d_s = opt_el_type}}, {_SLIT("){ .state = 2, .err = _v_error(_SLIT(\"channel closed\")), .data = {EMPTY_STRUCT_INITIALIZATION} };\n	}\n	return _tmp;\n}"), 0, { .d_c = 0 }}})));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_register_chan_push_optional_fn(v__gen__c__Gen* g, string el_type, string styp) {
	map_set(&g->chan_push_optionals, &(string[]){styp}, &(string[]) { el_type });
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_write_chan_push_optional_fns(v__gen__c__Gen* g) {
	Array_string done = __new_array_with_default(0, 0, sizeof(string), 0);
	Map_string_string _t1 = g->chan_push_optionals;
	int _t3 = _t1.key_values.len;
	for (int _t2 = 0; _t2 < _t3; ++_t2 ) {
		int _t4 = _t1.key_values.len - _t3;
		_t3 = _t1.key_values.len;
		if (_t4 < 0) {
			_t2 = -1;
			continue;
		}
		if (!DenseArray_has_index(&_t1.key_values, _t2)) {continue;}
		string styp = /*key*/ *(string*)DenseArray_key(&_t1.key_values, _t2);
		styp = string_clone(styp);
		string el_type = (*(string*)DenseArray_value(&_t1.key_values, _t2));
		if (Array_string_contains(done, styp)) {
			continue;
		}
		array_push((array*)&done, _MOV((string[]){ string_clone(styp) }));
		v__gen__c__Gen_register_optional(g, v__ast__Type_set_flag(_const_v__ast__void_type, v__ast__TypeFlag__optional));
		strings__Builder_writeln(&g->channel_definitions,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\nstatic inline Option_void __Option_"), 0xfe10, {.d_s = styp}}, {_SLIT("_pushval("), 0xfe10, {.d_s = styp}}, {_SLIT(" ch, "), 0xfe10, {.d_s = el_type}}, {_SLIT(" e) {\n	if (sync__Channel_try_push_priv(ch, &e, false)) {\n		return (Option_void){ .state = 2, .err = _v_error(_SLIT(\"channel closed\")), .data = {EMPTY_STRUCT_INITIALIZATION} };\n	}\n	return (Option_void){0};\n}"), 0, { .d_c = 0 }}})));
	}
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_cc_type(v__gen__c__Gen* g, v__ast__Type typ, bool is_prefix_struct) {
	v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, v__gen__c__Gen_unwrap_generic(g, typ));
	string styp = sym->cname;
	if (sym->info._typ == 446 /* v.ast.Struct */) {
		if ((*sym->info._v__ast__Struct).is_generic) {
			string sgtyps = _SLIT("_T");
			for (int _t1 = 0; _t1 < (*sym->info._v__ast__Struct).generic_types.len; ++_t1) {
				v__ast__Type gt = ((v__ast__Type*)(*sym->info._v__ast__Struct).generic_types.data)[_t1];
				v__ast__TypeSymbol* gts = v__ast__Table_sym(g->table, v__gen__c__Gen_unwrap_generic(g, gt));
				sgtyps = /*f*/string__plus(sgtyps,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("_"), 0xfe10, {.d_s = gts->cname}}, {_SLIT0, 0, { .d_c = 0 }}})));
			}
			styp = /*f*/string__plus(styp, sgtyps);
		}
	}
	else if (sym->info._typ == 463 /* v.ast.Interface */) {
		if ((*sym->info._v__ast__Interface).is_generic) {
			string sgtyps = _SLIT("_T");
			for (int _t2 = 0; _t2 < (*sym->info._v__ast__Interface).generic_types.len; ++_t2) {
				v__ast__Type gt = ((v__ast__Type*)(*sym->info._v__ast__Interface).generic_types.data)[_t2];
				v__ast__TypeSymbol* gts = v__ast__Table_sym(g->table, v__gen__c__Gen_unwrap_generic(g, gt));
				sgtyps = /*f*/string__plus(sgtyps,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("_"), 0xfe10, {.d_s = gts->cname}}, {_SLIT0, 0, { .d_c = 0 }}})));
			}
			styp = /*f*/string__plus(styp, sgtyps);
		}
	}
	else if (sym->info._typ == 464 /* v.ast.SumType */) {
		if ((*sym->info._v__ast__SumType).is_generic) {
			string sgtyps = _SLIT("_T");
			for (int _t3 = 0; _t3 < (*sym->info._v__ast__SumType).generic_types.len; ++_t3) {
				v__ast__Type gt = ((v__ast__Type*)(*sym->info._v__ast__SumType).generic_types.data)[_t3];
				v__ast__TypeSymbol* gts = v__ast__Table_sym(g->table, v__gen__c__Gen_unwrap_generic(g, gt));
				sgtyps = /*f*/string__plus(sgtyps,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("_"), 0xfe10, {.d_s = gts->cname}}, {_SLIT0, 0, { .d_c = 0 }}})));
			}
			styp = /*f*/string__plus(styp, sgtyps);
		}
	}
	
	else {
	}
	;
	if (is_prefix_struct && sym->language == v__ast__Language__c) {
		styp = string_substr(styp, 3, styp.len);
		if (sym->kind == v__ast__Kind__struct_) {
			v__ast__Struct info = /* as */ *(v__ast__Struct*)__as_cast((sym->info)._v__ast__Struct,(sym->info)._typ, 446) /*expected idx: 446, name: v.ast.Struct */ ;
			if (!info.is_typedef) {
				styp =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("struct "), 0xfe10, {.d_s = styp}}, {_SLIT0, 0, { .d_c = 0 }}}));
			}
		}
	}
	string _t4 = styp;
	return _t4;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL string v__gen__c__Gen_type_sidx(v__gen__c__Gen* g, v__ast__Type t) {
	if (g->pref->build_mode == v__pref__BuildMode__build_module) {
		v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, t);
		string _t1 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("_v_type_idx_"), 0xfe10, {.d_s = sym->cname}}, {_SLIT("()"), 0, { .d_c = 0 }}}));
		return _t1;
	}
	string _t2 = int_str(v__ast__Type_idx(t));
	return _t2;
}

void v__gen__c__Gen_write_typedef_types(v__gen__c__Gen* g) {
	for (int _t1 = 0; _t1 < g->table->type_symbols.len; ++_t1) {
		v__ast__TypeSymbol* sym = ((v__ast__TypeSymbol**)g->table->type_symbols.data)[_t1];
		if (Array_string_contains(_const_v__gen__c__builtins, sym->name)) {
			continue;
		}

		if (sym->kind == (v__ast__Kind__array)) {
			v__ast__Array info = /* as */ *(v__ast__Array*)__as_cast((sym->info)._v__ast__Array,(sym->info)._typ, 441) /*expected idx: 441, name: v.ast.Array */ ;
			v__ast__TypeSymbol* elem_sym = v__ast__Table_sym(g->table, info.elem_type);
			if (elem_sym->kind != v__ast__Kind__placeholder && !v__ast__Type_has_flag(info.elem_type, v__ast__TypeFlag__generic)) {
				strings__Builder_writeln(&g->type_definitions,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("typedef array "), 0xfe10, {.d_s = sym->cname}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
			}
		}
		else if (sym->kind == (v__ast__Kind__array_fixed)) {
			v__ast__ArrayFixed info = /* as */ *(v__ast__ArrayFixed*)__as_cast((sym->info)._v__ast__ArrayFixed,(sym->info)._typ, 468) /*expected idx: 468, name: v.ast.ArrayFixed */ ;
			v__ast__TypeSymbol* elem_sym = v__ast__Table_sym(g->table, info.elem_type);
			if (v__ast__TypeSymbol_is_builtin(elem_sym)) {
				string styp = sym->cname;
				string len = string_after(styp, _SLIT("_"));
				string fixed = v__gen__c__Gen_typ(g, info.elem_type);
				if ((elem_sym->info)._typ == 472 /* v.ast.FnType */) {
					int pos = g->out.len;
					v__gen__c__Gen_write_fn_ptr_decl(g, &(*elem_sym->info._v__ast__FnType), _SLIT(""));
					fixed = strings__Builder_cut_to(&g->out, pos);
					string def_str =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("typedef "), 0xfe10, {.d_s = fixed}}, {_SLIT(";"), 0, { .d_c = 0 }}}));
					def_str = string_replace_once(def_str, _SLIT("(*)"),  str_intp(3, _MOV((StrIntpData[]){{_SLIT("(*"), 0xfe10, {.d_s = styp}}, {_SLIT("["), 0xfe10, {.d_s = len}}, {_SLIT("])"), 0, { .d_c = 0 }}})));
					strings__Builder_writeln(&g->type_definitions, def_str);
				} else {
					strings__Builder_writeln(&g->type_definitions,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("typedef "), 0xfe10, {.d_s = fixed}}, {_SLIT(" "), 0xfe10, {.d_s = styp}}, {_SLIT(" ["), 0xfe10, {.d_s = len}}, {_SLIT("];"), 0, { .d_c = 0 }}})));
				}
			}
		}
		else if (sym->kind == (v__ast__Kind__chan)) {
			if (!string__eq(sym->name, _SLIT("chan"))) {
				strings__Builder_writeln(&g->type_definitions,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("typedef chan "), 0xfe10, {.d_s = sym->cname}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
				v__ast__Chan chan_inf = v__ast__TypeSymbol_chan_info(sym);
				v__ast__Type chan_elem_type = chan_inf.elem_type;
				if (!v__ast__Type_has_flag(chan_elem_type, v__ast__TypeFlag__generic)) {
					string el_stype = v__gen__c__Gen_typ(g, chan_elem_type);
					strings__Builder_writeln(&g->channel_definitions,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("\nstatic inline "), 0xfe10, {.d_s = el_stype}}, {_SLIT(" __"), 0xfe10, {.d_s = sym->cname}}, {_SLIT("_popval("), 0xfe10, {.d_s = sym->cname}}, {_SLIT(" ch) {\n	"), 0xfe10, {.d_s = el_stype}}, {_SLIT(" val;\n	sync__Channel_try_pop_priv(ch, &val, false);\n	return val;\n}"), 0, { .d_c = 0 }}})));
					strings__Builder_writeln(&g->channel_definitions,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\nstatic inline void __"), 0xfe10, {.d_s = sym->cname}}, {_SLIT("_pushval("), 0xfe10, {.d_s = sym->cname}}, {_SLIT(" ch, "), 0xfe10, {.d_s = el_stype}}, {_SLIT(" val) {\n	sync__Channel_try_push_priv(ch, &val, false);\n}"), 0, { .d_c = 0 }}})));
				}
			}
		}
		else if (sym->kind == (v__ast__Kind__map)) {
			strings__Builder_writeln(&g->type_definitions,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("typedef map "), 0xfe10, {.d_s = sym->cname}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
		}
		else {
			continue;
		};
	}
	for (int _t2 = 0; _t2 < g->table->type_symbols.len; ++_t2) {
		v__ast__TypeSymbol* sym = ((v__ast__TypeSymbol**)g->table->type_symbols.data)[_t2];
		if (sym->kind == v__ast__Kind__alias && !Array_string_contains(_const_v__gen__c__builtins, sym->name)) {
			v__gen__c__Gen_write_alias_typesymbol_declaration(g, *sym);
		}
	}
	for (int _t3 = 0; _t3 < g->table->type_symbols.len; ++_t3) {
		v__ast__TypeSymbol* sym = ((v__ast__TypeSymbol**)g->table->type_symbols.data)[_t3];
		if (sym->kind == v__ast__Kind__function && !Array_string_contains(_const_v__gen__c__builtins, sym->name)) {
			v__gen__c__Gen_write_fn_typesymbol_declaration(g, *sym);
		}
	}
	for (int _t4 = 0; _t4 < g->table->type_symbols.len; ++_t4) {
		v__ast__TypeSymbol* sym = ((v__ast__TypeSymbol**)g->table->type_symbols.data)[_t4];
		if (sym->kind == v__ast__Kind__interface_ && !Array_string_contains(_const_v__gen__c__builtins, sym->name)) {
			v__gen__c__Gen_write_interface_typedef(g, *sym);
		}
	}
	for (int _t5 = 0; _t5 < g->table->type_symbols.len; ++_t5) {
		v__ast__TypeSymbol* sym = ((v__ast__TypeSymbol**)g->table->type_symbols.data)[_t5];
		if (sym->kind == v__ast__Kind__interface_ && !Array_string_contains(_const_v__gen__c__builtins, sym->name)) {
			v__gen__c__Gen_write_interface_typesymbol_declaration(g, *sym);
		}
	}
}

void v__gen__c__Gen_write_alias_typesymbol_declaration(v__gen__c__Gen* g, v__ast__TypeSymbol sym) {
	v__ast__TypeSymbol* parent = (*(v__ast__TypeSymbol**)/*ee elem_typ */array_get(g->table->type_symbols, sym.parent_idx));
	bool is_c_parent = parent->name.len > 2 && string_at(parent->name, 0) == 'C' && string_at(parent->name, 1) == '.';
	bool is_typedef = false;
	if ((parent->info)._typ == 446 /* v.ast.Struct */) {
		is_typedef = (*parent->info._v__ast__Struct).is_typedef;
	}
	string parent_styp = parent->cname;
	if (is_c_parent) {
		if (!is_typedef) {
			parent_styp = string__plus(_SLIT("struct "), string_substr(parent->cname, 3, parent->cname.len));
		} else {
			parent_styp = string_substr(parent->cname, 3, parent->cname.len);
		}
	} else {
		if ((sym.info)._typ == 460 /* v.ast.Alias */) {
			parent_styp = v__gen__c__Gen_typ(g, (*sym.info._v__ast__Alias).parent_type);
		}
	}
	if (string__eq(parent_styp, _SLIT("byte")) && string__eq(sym.cname, _SLIT("u8"))) {
		return;
	}
	strings__Builder_writeln(&g->type_definitions,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("typedef "), 0xfe10, {.d_s = parent_styp}}, {_SLIT(" "), 0xfe10, {.d_s = sym.cname}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
}

void v__gen__c__Gen_write_interface_typedef(v__gen__c__Gen* g, v__ast__TypeSymbol sym) {
	string struct_name = v__gen__c__c_name(sym.cname);
	strings__Builder_writeln(&g->typedefs,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("typedef struct "), 0xfe10, {.d_s = struct_name}}, {_SLIT(" "), 0xfe10, {.d_s = struct_name}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
}

void v__gen__c__Gen_write_interface_typesymbol_declaration(v__gen__c__Gen* g, v__ast__TypeSymbol sym) {
	if ((sym.info)._typ != 463 /* v.ast.Interface */) {
		return;
	}
	v__ast__Interface info = /* as */ *(v__ast__Interface*)__as_cast((sym.info)._v__ast__Interface,(sym.info)._typ, 463) /*expected idx: 463, name: v.ast.Interface */ ;
	if (info.is_generic) {
		return;
	}
	string struct_name = v__gen__c__c_name(sym.cname);
	strings__Builder_writeln(&g->type_definitions,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("struct "), 0xfe10, {.d_s = struct_name}}, {_SLIT(" {"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&g->type_definitions, _SLIT("\tunion {"));
	strings__Builder_writeln(&g->type_definitions, _SLIT("\t\tvoid* _object;"));
	for (int _t1 = 0; _t1 < info.types.len; ++_t1) {
		v__ast__Type variant = ((v__ast__Type*)info.types.data)[_t1];
		string vcname = v__ast__Table_sym(g->table, variant)->cname;
		strings__Builder_writeln(&g->type_definitions,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\t"), 0xfe10, {.d_s = vcname}}, {_SLIT("* _"), 0xfe10, {.d_s = vcname}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
	}
	strings__Builder_writeln(&g->type_definitions, _SLIT("\t};"));
	strings__Builder_writeln(&g->type_definitions, _SLIT("\tint _typ;"));
	for (int _t2 = 0; _t2 < info.fields.len; ++_t2) {
		v__ast__StructField field = ((v__ast__StructField*)info.fields.data)[_t2];
		string styp = v__gen__c__Gen_typ(g, field.typ);
		string cname = v__gen__c__c_name(field.name);
		strings__Builder_writeln(&g->type_definitions,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = styp}}, {_SLIT("* "), 0xfe10, {.d_s = cname}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
	}
	strings__Builder_writeln(&g->type_definitions, _SLIT("};"));
}

void v__gen__c__Gen_write_fn_typesymbol_declaration(v__gen__c__Gen* g, v__ast__TypeSymbol sym) {
	v__ast__FnType info = /* as */ *(v__ast__FnType*)__as_cast((sym.info)._v__ast__FnType,(sym.info)._typ, 472) /*expected idx: 472, name: v.ast.FnType */ ;
	v__ast__Fn func = info.func;
	bool is_fn_sig = (func.name).len == 0;
	bool not_anon = !info.is_anon;
	bool has_generic_arg = false;
	for (int _t1 = 0; _t1 < func.params.len; ++_t1) {
		v__ast__Param param = ((v__ast__Param*)func.params.data)[_t1];
		if (v__ast__Type_has_flag(param.typ, v__ast__TypeFlag__generic)) {
			has_generic_arg = true;
			break;
		}
	}
	if (!info.has_decl && (not_anon || is_fn_sig) && !v__ast__Type_has_flag(func.return_type, v__ast__TypeFlag__generic) && !has_generic_arg) {
		string fn_name = sym.cname;
		strings__Builder_write_string(&g->type_definitions,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("typedef "), 0xfe10, {.d_s = v__gen__c__Gen_typ(g, func.return_type)}}, {_SLIT(" (*"), 0xfe10, {.d_s = fn_name}}, {_SLIT(")("), 0, { .d_c = 0 }}})));
		for (int i = 0; i < func.params.len; ++i) {
			v__ast__Param param = ((v__ast__Param*)func.params.data)[i];
			strings__Builder_write_string(&g->type_definitions, v__gen__c__Gen_typ(g, param.typ));
			if (i < func.params.len - 1) {
				strings__Builder_write_string(&g->type_definitions, _SLIT(","));
			}
		}
		strings__Builder_writeln(&g->type_definitions, _SLIT(");"));
	}
}

void v__gen__c__Gen_write_multi_return_types(v__gen__c__Gen* g) {
	strings__Builder_writeln(&g->typedefs, _SLIT("\n// BEGIN_multi_return_typedefs"));
	strings__Builder_writeln(&g->type_definitions, _SLIT("\n// BEGIN_multi_return_structs"));
	for (int _t1 = 0; _t1 < g->table->type_symbols.len; ++_t1) {
		v__ast__TypeSymbol* sym = ((v__ast__TypeSymbol**)g->table->type_symbols.data)[_t1];
		if (sym->kind != v__ast__Kind__multi_return) {
			continue;
		}
		v__ast__MultiReturn info = v__ast__TypeSymbol_mr_info(sym);
		Array_v__ast__Type _t2 = __new_array(0, 0, sizeof(v__ast__Type));
		Array_v__ast__Type _t2_orig = info.types;
		int _t2_len = _t2_orig.len;
		_t2 = __new_array(0, _t2_len, sizeof(v__ast__Type));

		for (int _t3 = 0; _t3 < _t2_len; ++_t3) {
			v__ast__Type it = ((v__ast__Type*) _t2_orig.data)[_t3];
			if (v__ast__Type_has_flag(it, v__ast__TypeFlag__generic)) {
				array_push((array*)&_t2, &it);
			}
		}
		if (_t2.len > 0) {
			continue;
		}
		strings__Builder_writeln(&g->typedefs,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("typedef struct "), 0xfe10, {.d_s = sym->cname}}, {_SLIT(" "), 0xfe10, {.d_s = sym->cname}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
		strings__Builder_writeln(&g->type_definitions,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("struct "), 0xfe10, {.d_s = sym->cname}}, {_SLIT(" {"), 0, { .d_c = 0 }}})));
		for (int i = 0; i < info.types.len; ++i) {
			v__ast__Type mr_typ = ((v__ast__Type*)info.types.data)[i];
			string type_name = v__gen__c__Gen_typ(g, mr_typ);
			strings__Builder_writeln(&g->type_definitions,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = type_name}}, {_SLIT(" arg"), 0xfe07, {.d_i32 = i}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
		}
		strings__Builder_writeln(&g->type_definitions, _SLIT("};\n"));
	}
	strings__Builder_writeln(&g->typedefs, _SLIT("// END_multi_return_typedefs\n"));
	strings__Builder_writeln(&g->type_definitions, _SLIT("// END_multi_return_structs\n"));
}

void v__gen__c__Gen_write(v__gen__c__Gen* g, string s) {
	if (g->indent > 0 && g->empty_line) {
		strings__Builder_write_string(&g->out, v__util__tabs(g->indent));
	}
	strings__Builder_write_string(&g->out, s);
	g->empty_line = false;
}

void v__gen__c__Gen_writeln(v__gen__c__Gen* g, string s) {
	if (g->indent > 0 && g->empty_line) {
		strings__Builder_write_string(&g->out, v__util__tabs(g->indent));
	}
	strings__Builder_writeln(&g->out, s);
	g->empty_line = true;
}

string v__gen__c__Gen_new_tmp_var(v__gen__c__Gen* g) {
	g->tmp_count++;
	string _t1 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("_t"), 0xfe07, {.d_i32 = g->tmp_count}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t1;
}

string v__gen__c__Gen_new_global_tmp_var(v__gen__c__Gen* g) {
	g->global_tmp_count++;
	string _t1 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("_t"), 0xfe07, {.d_i32 = g->global_tmp_count}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t1;
}

string v__gen__c__Gen_new_tmp_declaration_name(v__gen__c__Gen* g) {
	g->tmp_count_declarations++;
	string _t1 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("_d"), 0xfe07, {.d_i32 = g->tmp_count_declarations}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t1;
}

string v__gen__c__Gen_current_tmp_var(v__gen__c__Gen* g) {
	string _t1 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("_t"), 0xfe07, {.d_i32 = g->tmp_count}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t1;
}

void v__gen__c__Gen_reset_tmp_count(v__gen__c__Gen* g) {
	g->tmp_count = 0;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_decrement_inside_ternary(v__gen__c__Gen* g) {
	string key = int_str(g->inside_ternary);
	Array_string _t1 = (*(Array_string*)map_get(ADDR(map, g->ternary_level_names), &(string[]){key}, &(Array_string[]){ __new_array(0, 0, sizeof(string)) }));
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		string name = ((string*)_t1.data)[_t2];
		map_delete(&g->ternary_names, &(string[]){name});
	}
	map_delete(&g->ternary_level_names, &(string[]){key});
	g->inside_ternary--;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_stmts(v__gen__c__Gen* g, Array_v__ast__Stmt stmts) {
	v__gen__c__Gen_stmts_with_tmp_var(g, stmts, _SLIT(""));
}

VV_LOCAL_SYMBOL bool v__gen__c__is_noreturn_callexpr(v__ast__Expr expr) {
	if ((expr)._typ == 286 /* v.ast.CallExpr */) {
		bool _t1 = (*expr._v__ast__CallExpr).is_noreturn;
		return _t1;
	}
	bool _t2 = false;
	return _t2;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_stmts_with_tmp_var(v__gen__c__Gen* g, Array_v__ast__Stmt stmts, string tmp_var) {
	g->indent++;
	if (g->inside_ternary > 0) {
		v__gen__c__Gen_write(g, _SLIT("("));
	}
	for (int i = 0; i < stmts.len; ++i) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)stmts.data)[i];
		if (i == stmts.len - 1 && (tmp_var).len != 0) {
			if (g->inside_if_optional || g->inside_match_optional) {
				v__gen__c__Gen_set_current_pos_as_last_stmt_pos(g);
				g->skip_stmt_pos = true;
				if ((stmt)._typ == 339 /* v.ast.ExprStmt */) {
					if ((*stmt._v__ast__ExprStmt).typ == _const_v__ast__error_type_idx || ((*stmt._v__ast__ExprStmt).expr)._typ == 311 /* v.ast.None */) {
						v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = tmp_var}}, {_SLIT(".state = 2;"), 0, { .d_c = 0 }}})));
						v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = tmp_var}}, {_SLIT(".err = "), 0, { .d_c = 0 }}})));
						v__gen__c__Gen_expr(g, (*stmt._v__ast__ExprStmt).expr);
						v__gen__c__Gen_writeln(g, _SLIT(";"));
					} else {
						string styp = v__gen__c__Gen_base_type(g, (*stmt._v__ast__ExprStmt).typ);
						v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("opt_ok(&("), 0xfe10, {.d_s = styp}}, {_SLIT("[]) { "), 0, { .d_c = 0 }}})));
						v__gen__c__Gen_stmt(g, stmt);
						v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT(" }, (Option*)(&"), 0xfe10, {.d_s = tmp_var}}, {_SLIT("), sizeof("), 0xfe10, {.d_s = styp}}, {_SLIT("));"), 0, { .d_c = 0 }}})));
					}
				}
			} else {
				v__gen__c__Gen_set_current_pos_as_last_stmt_pos(g);
				g->skip_stmt_pos = true;
				bool is_noreturn = false;
				if ((stmt)._typ == 339 /* v.ast.ExprStmt */) {
					is_noreturn = v__gen__c__is_noreturn_callexpr((*stmt._v__ast__ExprStmt).expr);
				}
				if (!is_noreturn) {
					v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = tmp_var}}, {_SLIT(" = "), 0, { .d_c = 0 }}})));
				}
				v__gen__c__Gen_stmt(g, stmt);
				if (!string_contains(strings__Builder_last_n(&g->out, 2), _SLIT(";"))) {
					v__gen__c__Gen_writeln(g, _SLIT(";"));
				}
			}
		} else {
			v__gen__c__Gen_stmt(g, stmt);
			if ((g->inside_if_optional || g->inside_match_optional) && (stmt)._typ == 339 /* v.ast.ExprStmt */) {
				v__gen__c__Gen_writeln(g, _SLIT(";"));
			}
		}
		g->skip_stmt_pos = false;
		if (g->inside_ternary > 0 && i < stmts.len - 1) {
			v__gen__c__Gen_write(g, _SLIT(","));
		}
	}
	g->indent--;
	if (g->inside_ternary > 0) {
		v__gen__c__Gen_write(g, _SLIT(""));
		v__gen__c__Gen_write(g, _SLIT(")"));
	}
	if (g->is_autofree && !g->inside_vweb_tmpl && stmts.len > 0) {
		v__ast__Stmt stmt = (*(v__ast__Stmt*)/*ee elem_typ */array_get(stmts, 0));
		if ((stmt)._typ != 216 /* v.ast.FnDecl */ && g->inside_ternary == 0) {
			v__token__Position stmt_pos = (*(stmt.pos));
			if (stmt_pos.pos == 0) {
				if ((stmt)._typ == 349 /* v.ast.Module */) {
					return;
				}
				if ((stmt)._typ == 339 /* v.ast.ExprStmt */) {
					stmt_pos = v__ast__Expr_position((*stmt._v__ast__ExprStmt).expr);
				}
				if (stmt_pos.pos == 0) {
					return;
				}
			}
			v__gen__c__Gen_autofree_scope_vars(g, stmt_pos.pos - 1, stmt_pos.line_nr, false);
		}
	}
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL void v__gen__c__Gen_write_v_source_line_info(v__gen__c__Gen* g, v__token__Position pos) {
	if (g->inside_ternary == 0 && g->pref->is_vlines && g->is_vlines_enabled) {
		int nline = pos.line_nr + 1;
		string lineinfo =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\n#line "), 0xfe07, {.d_i32 = nline}}, {_SLIT(" \""), 0xfe10, {.d_s = g->vlines_path}}, {_SLIT("\""), 0, { .d_c = 0 }}}));
		v__gen__c__Gen_writeln(g, lineinfo);
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_stmt(v__gen__c__Gen* g, v__ast__Stmt node) {
bool v__gen__c__Gen_stmt_defer_0 = false;
	if (!g->skip_stmt_pos) {
		v__gen__c__Gen_set_current_pos_as_last_stmt_pos(g);
	}
	v__gen__c__Gen_stmt_defer_0 = true;
	if (node._typ == 337 /* v.ast.EmptyStmt */) {
	}
	else if (node._typ == 329 /* v.ast.AsmStmt */) {
		v__gen__c__Gen_write_v_source_line_info(g, (*node._v__ast__AsmStmt).pos);
		v__gen__c__Gen_gen_asm_stmt(g, (*node._v__ast__AsmStmt));
	}
	else if (node._typ == 330 /* v.ast.AssertStmt */) {
		v__gen__c__Gen_write_v_source_line_info(g, (*node._v__ast__AssertStmt).pos);
		v__gen__c__Gen_gen_assert_stmt(g, (*node._v__ast__AssertStmt));
	}
	else if (node._typ == 331 /* v.ast.AssignStmt */) {
		v__gen__c__Gen_write_v_source_line_info(g, (*node._v__ast__AssignStmt).pos);
		v__gen__c__Gen_gen_assign_stmt(g, (*node._v__ast__AssignStmt));
	}
	else if (node._typ == 332 /* v.ast.Block */) {
		v__gen__c__Gen_write_v_source_line_info(g, (*node._v__ast__Block).pos);
		if ((*node._v__ast__Block).is_unsafe) {
			v__gen__c__Gen_writeln(g, _SLIT("{ // Unsafe block"));
		} else {
			v__gen__c__Gen_writeln(g, _SLIT("{"));
		}
		v__gen__c__Gen_stmts(g, (*node._v__ast__Block).stmts);
		v__gen__c__Gen_writeln(g, _SLIT("}"));
	}
	else if (node._typ == 333 /* v.ast.BranchStmt */) {
		v__gen__c__Gen_write_v_source_line_info(g, (*node._v__ast__BranchStmt).pos);
		if (((*node._v__ast__BranchStmt).label).len != 0) {
			v__ast__Stmt** _t2 = (v__ast__Stmt**)/*ee elem_ptr_typ */(map_get_check(ADDR(map, g->labeled_loops), &(string[]){(*node._v__ast__BranchStmt).label}));
			Option_v__ast__Stmt_ptr _t1 = {0};
			if (_t2) {
				*((v__ast__Stmt**)&_t1.data) = *((v__ast__Stmt**)_t2);
			} else {
				_t1.state = 2; _t1.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t1.state != 0) { /*or block*/ 
				IError err = _t1.err;
				_v_panic( str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = (*node._v__ast__BranchStmt).label}}, {_SLIT(" doesn\'t exist "), 0xfe10, {.d_s = g->file->path}}, {_SLIT(", "), 0xfe10, {.d_s = v__token__Position_str((*node._v__ast__BranchStmt).pos)}}, {_SLIT0, 0, { .d_c = 0 }}})));
				VUNREACHABLE();
			;
			}
			
			v__ast__Stmt* x = *(v__ast__Stmt**)_t1.data;
			if (x->_typ == 340 /* v.ast.ForCStmt */) {
				if (v__ast__Scope_contains((*x->_v__ast__ForCStmt).scope, g->cur_lock.pos.pos)) {
					v__gen__c__Gen_unlock_locks(g);
				}
			}
			else if (x->_typ == 341 /* v.ast.ForInStmt */) {
				if (v__ast__Scope_contains((*x->_v__ast__ForInStmt).scope, g->cur_lock.pos.pos)) {
					v__gen__c__Gen_unlock_locks(g);
				}
			}
			else if (x->_typ == 342 /* v.ast.ForStmt */) {
				if (v__ast__Scope_contains((*x->_v__ast__ForStmt).scope, g->cur_lock.pos.pos)) {
					v__gen__c__Gen_unlock_locks(g);
				}
			}
			
			else {
			}
			;
			if ((*node._v__ast__BranchStmt).kind == v__token__Kind__key_break) {
				v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("goto "), 0xfe10, {.d_s = (*node._v__ast__BranchStmt).label}}, {_SLIT("__break;"), 0, { .d_c = 0 }}})));
			} else {
				v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("goto "), 0xfe10, {.d_s = (*node._v__ast__BranchStmt).label}}, {_SLIT("__continue;"), 0, { .d_c = 0 }}})));
			}
		} else {
			v__ast__Stmt* inner_loop = g->inner_loop;
			if (inner_loop->_typ == 340 /* v.ast.ForCStmt */) {
				if (v__ast__Scope_contains((*inner_loop->_v__ast__ForCStmt).scope, g->cur_lock.pos.pos)) {
					v__gen__c__Gen_unlock_locks(g);
				}
			}
			else if (inner_loop->_typ == 341 /* v.ast.ForInStmt */) {
				if (v__ast__Scope_contains((*inner_loop->_v__ast__ForInStmt).scope, g->cur_lock.pos.pos)) {
					v__gen__c__Gen_unlock_locks(g);
				}
			}
			else if (inner_loop->_typ == 342 /* v.ast.ForStmt */) {
				if (v__ast__Scope_contains((*inner_loop->_v__ast__ForStmt).scope, g->cur_lock.pos.pos)) {
					v__gen__c__Gen_unlock_locks(g);
				}
			}
			
			else {
			}
			;
			if (g->is_autofree && !g->is_builtin_mod) {
				;
				v__gen__c__Gen_autofree_scope_vars_stop(g, (*node._v__ast__BranchStmt).pos.pos - 1, (*node._v__ast__BranchStmt).pos.line_nr, true, g->branch_parent_pos);
			}
			v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__token__Kind_str((*node._v__ast__BranchStmt).kind)}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
		}
	}
	else if (node._typ == 335 /* v.ast.ConstDecl */) {
		v__gen__c__Gen_write_v_source_line_info(g, (*node._v__ast__ConstDecl).pos);
		v__gen__c__Gen_const_decl(g, (*node._v__ast__ConstDecl));
	}
	else if (node._typ == 334 /* v.ast.ComptimeFor */) {
		v__gen__c__Gen_comptime_for(g, (*node._v__ast__ComptimeFor));
	}
	else if (node._typ == 336 /* v.ast.DeferStmt */) {
		v__ast__DeferStmt defer_stmt = (*node._v__ast__DeferStmt);
		defer_stmt.ifdef = g->defer_ifdef;
		v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__gen__c__Gen_defer_flag_var(g, (voidptr)&/*qq*/defer_stmt)}}, {_SLIT(" = true;"), 0, { .d_c = 0 }}})));
		array_push((array*)&g->defer_stmts, _MOV((v__ast__DeferStmt[]){ defer_stmt }));
	}
	else if (node._typ == 338 /* v.ast.EnumDecl */) {
		string enum_name = v__util__no_dots((*node._v__ast__EnumDecl).name);
		bool is_flag = (*node._v__ast__EnumDecl).is_flag;
		strings__Builder_writeln(&g->enum_typedefs, _SLIT("typedef enum {"));
		string cur_enum_expr = _SLIT("");
		int cur_enum_offset = 0;
		for (int i = 0; i < (*node._v__ast__EnumDecl).fields.len; ++i) {
			v__ast__EnumField field = ((v__ast__EnumField*)(*node._v__ast__EnumDecl).fields.data)[i];
			strings__Builder_write_string(&g->enum_typedefs,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = enum_name}}, {_SLIT("__"), 0xfe10, {.d_s = field.name}}, {_SLIT0, 0, { .d_c = 0 }}})));
			if (field.has_expr) {
				strings__Builder_write_string(&g->enum_typedefs, _SLIT(" = "));
				string expr_str = v__gen__c__Gen_expr_string(g, field.expr);
				strings__Builder_write_string(&g->enum_typedefs, expr_str);
				cur_enum_expr = expr_str;
				cur_enum_offset = 0;
			} else if (is_flag) {
				strings__Builder_write_string(&g->enum_typedefs, _SLIT(" = "));
				cur_enum_expr =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("1 << "), 0xfe07, {.d_i32 = i}}, {_SLIT0, 0, { .d_c = 0 }}}));
				strings__Builder_write_string(&g->enum_typedefs, int_literal_str((1 << i)));
				cur_enum_offset = 0;
			}
			string cur_value = (cur_enum_offset > 0 ? ( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = cur_enum_expr}}, {_SLIT("+"), 0xfe07, {.d_i32 = cur_enum_offset}}, {_SLIT0, 0, { .d_c = 0 }}}))) : (cur_enum_expr));
			strings__Builder_writeln(&g->enum_typedefs,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(", // "), 0xfe10, {.d_s = cur_value}}, {_SLIT0, 0, { .d_c = 0 }}})));
			cur_enum_offset++;
		}
		strings__Builder_writeln(&g->enum_typedefs,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("} "), 0xfe10, {.d_s = enum_name}}, {_SLIT(";\n"), 0, { .d_c = 0 }}})));
	}
	else if (node._typ == 339 /* v.ast.ExprStmt */) {
		v__gen__c__Gen_write_v_source_line_info(g, (*node._v__ast__ExprStmt).pos);
		bool old_is_void_expr_stmt = g->is_void_expr_stmt;
		g->is_void_expr_stmt = !(*node._v__ast__ExprStmt).is_expr;
		if (!v__ast__Type_alias_eq((*node._v__ast__ExprStmt).typ, _const_v__ast__void_type) && g->expected_cast_type != 0 && ((*node._v__ast__ExprStmt).expr)._typ != 309 /* v.ast.MatchExpr */) {
			v__gen__c__Gen_expr_with_cast(g, (*node._v__ast__ExprStmt).expr, (*node._v__ast__ExprStmt).typ, g->expected_cast_type);
		} else {
			v__gen__c__Gen_expr(g, (*node._v__ast__ExprStmt).expr);
		}
		g->is_void_expr_stmt = old_is_void_expr_stmt;
		if (g->inside_ternary == 0 && !g->inside_if_optional && !g->inside_match_optional && !(*node._v__ast__ExprStmt).is_expr && ((*node._v__ast__ExprStmt).expr)._typ != 300 /* v.ast.IfExpr */) {
			v__gen__c__Gen_writeln(g, _SLIT(";"));
		}
	}
	else if (node._typ == 216 /* v.ast.FnDecl */) {
		v__gen__c__Gen_fn_decl(g, (*node._v__ast__FnDecl));
	}
	else if (node._typ == 340 /* v.ast.ForCStmt */) {
		int prev_branch_parent_pos = g->branch_parent_pos;
		g->branch_parent_pos = (*node._v__ast__ForCStmt).pos.pos;
		v__ast__Stmt* save_inner_loop = g->inner_loop;
		g->inner_loop = HEAP(v__ast__Stmt, v__ast__ForCStmt_to_sumtype_v__ast__Stmt(&(*node._v__ast__ForCStmt)));
		if (((*node._v__ast__ForCStmt).label).len != 0) {
			map_set(&g->labeled_loops, &(string[]){(*node._v__ast__ForCStmt).label}, &(v__ast__Stmt*[]) { HEAP(v__ast__Stmt, v__ast__ForCStmt_to_sumtype_v__ast__Stmt(&(*node._v__ast__ForCStmt))) });
		}
		v__gen__c__Gen_write_v_source_line_info(g, (*node._v__ast__ForCStmt).pos);
		v__gen__c__Gen_for_c_stmt(g, (*node._v__ast__ForCStmt));
		g->branch_parent_pos = prev_branch_parent_pos;
		map_delete(&g->labeled_loops, &(string[]){(*node._v__ast__ForCStmt).label});
		g->inner_loop = save_inner_loop;
	}
	else if (node._typ == 341 /* v.ast.ForInStmt */) {
		int prev_branch_parent_pos = g->branch_parent_pos;
		g->branch_parent_pos = (*node._v__ast__ForInStmt).pos.pos;
		v__ast__Stmt* save_inner_loop = g->inner_loop;
		g->inner_loop = HEAP(v__ast__Stmt, v__ast__ForInStmt_to_sumtype_v__ast__Stmt(&(*node._v__ast__ForInStmt)));
		if (((*node._v__ast__ForInStmt).label).len != 0) {
			map_set(&g->labeled_loops, &(string[]){(*node._v__ast__ForInStmt).label}, &(v__ast__Stmt*[]) { HEAP(v__ast__Stmt, v__ast__ForInStmt_to_sumtype_v__ast__Stmt(&(*node._v__ast__ForInStmt))) });
		}
		v__gen__c__Gen_write_v_source_line_info(g, (*node._v__ast__ForInStmt).pos);
		v__gen__c__Gen_for_in_stmt(g, (*node._v__ast__ForInStmt));
		g->branch_parent_pos = prev_branch_parent_pos;
		map_delete(&g->labeled_loops, &(string[]){(*node._v__ast__ForInStmt).label});
		g->inner_loop = save_inner_loop;
	}
	else if (node._typ == 342 /* v.ast.ForStmt */) {
		int prev_branch_parent_pos = g->branch_parent_pos;
		g->branch_parent_pos = (*node._v__ast__ForStmt).pos.pos;
		v__ast__Stmt* save_inner_loop = g->inner_loop;
		g->inner_loop = HEAP(v__ast__Stmt, v__ast__ForStmt_to_sumtype_v__ast__Stmt(&(*node._v__ast__ForStmt)));
		if (((*node._v__ast__ForStmt).label).len != 0) {
			map_set(&g->labeled_loops, &(string[]){(*node._v__ast__ForStmt).label}, &(v__ast__Stmt*[]) { HEAP(v__ast__Stmt, v__ast__ForStmt_to_sumtype_v__ast__Stmt(&(*node._v__ast__ForStmt))) });
		}
		v__gen__c__Gen_write_v_source_line_info(g, (*node._v__ast__ForStmt).pos);
		v__gen__c__Gen_for_stmt(g, (*node._v__ast__ForStmt));
		g->branch_parent_pos = prev_branch_parent_pos;
		map_delete(&g->labeled_loops, &(string[]){(*node._v__ast__ForStmt).label});
		g->inner_loop = save_inner_loop;
	}
	else if (node._typ == 343 /* v.ast.GlobalDecl */) {
		v__gen__c__Gen_global_decl(g, (*node._v__ast__GlobalDecl));
	}
	else if (node._typ == 344 /* v.ast.GotoLabel */) {
		v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__gen__c__c_name((*node._v__ast__GotoLabel).name)}}, {_SLIT(": {}"), 0, { .d_c = 0 }}})));
	}
	else if (node._typ == 345 /* v.ast.GotoStmt */) {
		v__gen__c__Gen_write_v_source_line_info(g, (*node._v__ast__GotoStmt).pos);
		v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("goto "), 0xfe10, {.d_s = v__gen__c__c_name((*node._v__ast__GotoStmt).name)}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
	}
	else if (node._typ == 346 /* v.ast.HashStmt */) {
		string ct_condition = _SLIT("");
		if ((*node._v__ast__HashStmt).ct_conds.len > 0) {
			int ct_condition_start = g->out.len;
			for (int idx = 0; idx < (*node._v__ast__HashStmt).ct_conds.len; ++idx) {
				v__ast__Expr ct_expr = ((v__ast__Expr*)(*node._v__ast__HashStmt).ct_conds.data)[idx];
				v__gen__c__Gen_comptime_if_cond(g, ct_expr, false);
				if (idx < (*node._v__ast__HashStmt).ct_conds.len - 1) {
					v__gen__c__Gen_write(g, _SLIT(" && "));
				}
			}
			ct_condition = string_trim_space(strings__Builder_cut_to(&g->out, ct_condition_start));
		}
		if (string__eq((*node._v__ast__HashStmt).kind, _SLIT("include"))) {
			string missing_message =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("Header file "), 0xfe10, {.d_s = (*node._v__ast__HashStmt).main}}, {_SLIT(", needed for module `"), 0xfe10, {.d_s = (*node._v__ast__HashStmt).mod}}, {_SLIT("` was not found."), 0, { .d_c = 0 }}}));
			if (((*node._v__ast__HashStmt).msg).len != 0) {
				missing_message = /*f*/string__plus(missing_message,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(" "), 0xfe10, {.d_s = (*node._v__ast__HashStmt).msg}}, {_SLIT("."), 0, { .d_c = 0 }}})));
			} else {
				missing_message = /*f*/string__plus(missing_message, _SLIT(" Please install the corresponding development headers."));
			}
			string guarded_include = v__gen__c__get_guarded_include_text((*node._v__ast__HashStmt).main, missing_message);
			if (string__eq((*node._v__ast__HashStmt).main, _SLIT("<errno.h>"))) {
				guarded_include =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("#include "), 0xfe10, {.d_s = (*node._v__ast__HashStmt).main}}, {_SLIT0, 0, { .d_c = 0 }}}));
			}
			if (string_contains((*node._v__ast__HashStmt).main, _SLIT(".m"))) {
				strings__Builder_writeln(&g->definitions, _SLIT("\n"));
				if (ct_condition.len > 0) {
					strings__Builder_writeln(&g->definitions,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("#if "), 0xfe10, {.d_s = ct_condition}}, {_SLIT0, 0, { .d_c = 0 }}})));
				}
				strings__Builder_writeln(&g->definitions,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("// added by module `"), 0xfe10, {.d_s = (*node._v__ast__HashStmt).mod}}, {_SLIT("`"), 0, { .d_c = 0 }}})));
				strings__Builder_writeln(&g->definitions, guarded_include);
				if (ct_condition.len > 0) {
					strings__Builder_writeln(&g->definitions,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("#endif // $if "), 0xfe10, {.d_s = ct_condition}}, {_SLIT0, 0, { .d_c = 0 }}})));
				}
				strings__Builder_writeln(&g->definitions, _SLIT("\n"));
			} else {
				strings__Builder_writeln(&g->includes, _SLIT("\n"));
				if (ct_condition.len > 0) {
					strings__Builder_writeln(&g->includes,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("#if "), 0xfe10, {.d_s = ct_condition}}, {_SLIT0, 0, { .d_c = 0 }}})));
				}
				strings__Builder_writeln(&g->includes,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("// added by module `"), 0xfe10, {.d_s = (*node._v__ast__HashStmt).mod}}, {_SLIT("`"), 0, { .d_c = 0 }}})));
				strings__Builder_writeln(&g->includes, guarded_include);
				if (ct_condition.len > 0) {
					strings__Builder_writeln(&g->includes,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("#endif // $if "), 0xfe10, {.d_s = ct_condition}}, {_SLIT0, 0, { .d_c = 0 }}})));
				}
				strings__Builder_writeln(&g->includes, _SLIT("\n"));
			}
		} else if (string__eq((*node._v__ast__HashStmt).kind, _SLIT("define"))) {
			if (ct_condition.len > 0) {
				strings__Builder_writeln(&g->includes,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("#if "), 0xfe10, {.d_s = ct_condition}}, {_SLIT0, 0, { .d_c = 0 }}})));
			}
			strings__Builder_writeln(&g->includes,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("// defined by module `"), 0xfe10, {.d_s = (*node._v__ast__HashStmt).mod}}, {_SLIT("`"), 0, { .d_c = 0 }}})));
			strings__Builder_writeln(&g->includes,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("#define "), 0xfe10, {.d_s = (*node._v__ast__HashStmt).main}}, {_SLIT0, 0, { .d_c = 0 }}})));
			if (ct_condition.len > 0) {
				strings__Builder_writeln(&g->includes,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("#endif // $if "), 0xfe10, {.d_s = ct_condition}}, {_SLIT0, 0, { .d_c = 0 }}})));
			}
		}
	}
	else if (node._typ == 347 /* v.ast.Import */) {
	}
	else if (node._typ == 348 /* v.ast.InterfaceDecl */) {
		v__ast__TypeSymbol* ts = v__ast__Table_sym(g->table, (*node._v__ast__InterfaceDecl).typ);
		if (!(/* as */ *(v__ast__Interface*)__as_cast((ts->info)._v__ast__Interface,(ts->info)._typ, 463) /*expected idx: 463, name: v.ast.Interface */ ).is_generic) {
			for (int _t4 = 0; _t4 < (*node._v__ast__InterfaceDecl).methods.len; ++_t4) {
				v__ast__FnDecl method = ((v__ast__FnDecl*)(*node._v__ast__InterfaceDecl).methods.data)[_t4];
				if (v__ast__Type_has_flag(method.return_type, v__ast__TypeFlag__optional)) {
					v__gen__c__Gen_register_optional(g, method.return_type);
				}
			}
		}
	}
	else if (node._typ == 349 /* v.ast.Module */) {
		g->is_builtin_mod = (string__eq((*node._v__ast__Module).name, _SLIT("builtin")) || string__eq((*node._v__ast__Module).name, _SLIT("strconv")) || string__eq((*node._v__ast__Module).name, _SLIT("strings")));
		g->cur_mod = (*node._v__ast__Module);
	}
	else if (node._typ == 310 /* v.ast.NodeError */) {
	}
	else if (node._typ == 350 /* v.ast.Return */) {
		v__gen__c__Gen_return_stmt(g, (*node._v__ast__Return));
	}
	else if (node._typ == 351 /* v.ast.SqlStmt */) {
		v__gen__c__Gen_sql_stmt(g, (*node._v__ast__SqlStmt));
	}
	else if (node._typ == 352 /* v.ast.StructDecl */) {
		string name = ((*node._v__ast__StructDecl).language == v__ast__Language__c ? (v__util__no_dots((*node._v__ast__StructDecl).name)) : (string__eq((*node._v__ast__StructDecl).name, _SLIT("array")) || string__eq((*node._v__ast__StructDecl).name, _SLIT("string"))) ? ((*node._v__ast__StructDecl).name) : (v__gen__c__c_name((*node._v__ast__StructDecl).name)));
		if ((*node._v__ast__StructDecl).language == v__ast__Language__c) {
			// Defer begin
			if (v__gen__c__Gen_stmt_defer_0) {
			}
			// Defer end
			return;
		}
		if ((*node._v__ast__StructDecl).is_union) {
			strings__Builder_writeln(&g->typedefs,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("typedef union "), 0xfe10, {.d_s = name}}, {_SLIT(" "), 0xfe10, {.d_s = name}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
		} else {
			strings__Builder_writeln(&g->typedefs,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("typedef struct "), 0xfe10, {.d_s = name}}, {_SLIT(" "), 0xfe10, {.d_s = name}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
		}
	}
	else if (node._typ == 277 /* v.ast.TypeDecl */) {
		if (!g->pref->skip_unused) {
			v__gen__c__Gen_writeln(g, _SLIT("// TypeDecl"));
		}
	}
	;
	if (!g->skip_stmt_pos) {
		array_delete_last(&g->stmt_path_pos);
	}
	if (g->is_autofree) {
		if ((node)._typ != 216 /* v.ast.FnDecl */) {
		}
	}
// Defer begin
if (v__gen__c__Gen_stmt_defer_0) {
}
// Defer end
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_write_defer_stmts(v__gen__c__Gen* g) {
	for (int i = g->defer_stmts.len - 1; i >= 0; i--) {
		v__ast__DeferStmt defer_stmt = (*(v__ast__DeferStmt*)/*ee elem_typ */array_get(g->defer_stmts, i));
		v__gen__c__Gen_writeln(g, _SLIT("// Defer begin"));
		v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("if ("), 0xfe10, {.d_s = v__gen__c__Gen_defer_flag_var(g, (voidptr)&/*qq*/defer_stmt)}}, {_SLIT(") {"), 0, { .d_c = 0 }}})));
		g->indent++;
		if (defer_stmt.ifdef.len > 0) {
			v__gen__c__Gen_writeln(g, defer_stmt.ifdef);
			v__gen__c__Gen_stmts(g, defer_stmt.stmts);
			v__gen__c__Gen_writeln(g, _SLIT(""));
			v__gen__c__Gen_writeln(g, _SLIT("#endif"));
		} else {
			g->indent--;
			v__gen__c__Gen_stmts(g, defer_stmt.stmts);
			g->indent++;
		}
		g->indent--;
		v__gen__c__Gen_writeln(g, _SLIT("}"));
		v__gen__c__Gen_writeln(g, _SLIT("// Defer end"));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_for_c_stmt(v__gen__c__Gen* g, v__ast__ForCStmt node) {
	g->loop_depth++;
	if (node.is_multi) {
		g->is_vlines_enabled = false;
		g->inside_for_c_stmt = true;
		if (node.label.len > 0) {
			v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = node.label}}, {_SLIT(":"), 0, { .d_c = 0 }}})));
		}
		v__gen__c__Gen_writeln(g, _SLIT("{"));
		g->indent++;
		if (node.has_init) {
			v__gen__c__Gen_stmt(g, node.init);
		}
		v__gen__c__Gen_writeln(g, _SLIT("bool _is_first = true;"));
		v__gen__c__Gen_writeln(g, _SLIT("while (true) {"));
		v__gen__c__Gen_writeln(g, _SLIT("\tif (_is_first) {"));
		v__gen__c__Gen_writeln(g, _SLIT("\t\t_is_first = false;"));
		v__gen__c__Gen_writeln(g, _SLIT("\t} else {"));
		if (node.has_inc) {
			g->indent++;
			v__gen__c__Gen_stmt(g, node.inc);
			v__gen__c__Gen_writeln(g, _SLIT(";"));
			g->indent--;
		}
		v__gen__c__Gen_writeln(g, _SLIT("}"));
		if (node.has_cond) {
			v__gen__c__Gen_write(g, _SLIT("if (!("));
			v__gen__c__Gen_expr(g, node.cond);
			v__gen__c__Gen_writeln(g, _SLIT(")) break;"));
		}
		g->is_vlines_enabled = true;
		g->inside_for_c_stmt = false;
		v__gen__c__Gen_stmts(g, node.stmts);
		if (node.label.len > 0) {
			v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = node.label}}, {_SLIT("__continue: {}"), 0, { .d_c = 0 }}})));
		}
		v__gen__c__Gen_writeln(g, _SLIT("}"));
		g->indent--;
		v__gen__c__Gen_writeln(g, _SLIT("}"));
		if (node.label.len > 0) {
			v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = node.label}}, {_SLIT("__break: {}"), 0, { .d_c = 0 }}})));
		}
	} else {
		g->is_vlines_enabled = false;
		g->inside_for_c_stmt = true;
		if (node.label.len > 0) {
			v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = node.label}}, {_SLIT(":"), 0, { .d_c = 0 }}})));
		}
		v__gen__c__Gen_write(g, _SLIT("for ("));
		if (!node.has_init) {
			v__gen__c__Gen_write(g, _SLIT("; "));
		} else {
			v__gen__c__Gen_stmt(g, node.init);
			if (string__eq(strings__Builder_last_n(&g->out, 1), _SLIT("\n"))) {
				strings__Builder_go_back(&g->out, 1);
				g->empty_line = false;
				v__gen__c__Gen_write(g, _SLIT(" "));
			}
		}
		if (node.has_cond) {
			v__gen__c__Gen_expr(g, node.cond);
		}
		v__gen__c__Gen_write(g, _SLIT("; "));
		if (node.has_inc) {
			v__gen__c__Gen_stmt(g, node.inc);
		}
		v__gen__c__Gen_writeln(g, _SLIT(") {"));
		g->is_vlines_enabled = true;
		g->inside_for_c_stmt = false;
		v__gen__c__Gen_stmts(g, node.stmts);
		if (node.label.len > 0) {
			v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = node.label}}, {_SLIT("__continue: {}"), 0, { .d_c = 0 }}})));
		}
		v__gen__c__Gen_writeln(g, _SLIT("}"));
		if (node.label.len > 0) {
			v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = node.label}}, {_SLIT("__break: {}"), 0, { .d_c = 0 }}})));
		}
	}
	g->loop_depth--;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_for_stmt(v__gen__c__Gen* g, v__ast__ForStmt node) {
	g->loop_depth++;
	g->is_vlines_enabled = false;
	if (node.label.len > 0) {
		v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = node.label}}, {_SLIT(":"), 0, { .d_c = 0 }}})));
	}
	v__gen__c__Gen_writeln(g, _SLIT("for (;;) {"));
	if (!node.is_inf) {
		g->indent++;
		v__gen__c__Gen_set_current_pos_as_last_stmt_pos(g);
		v__gen__c__Gen_write(g, _SLIT("if (!("));
		v__gen__c__Gen_expr(g, node.cond);
		v__gen__c__Gen_writeln(g, _SLIT(")) break;"));
		g->indent--;
	}
	g->is_vlines_enabled = true;
	v__gen__c__Gen_stmts(g, node.stmts);
	if (node.label.len > 0) {
		v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = node.label}}, {_SLIT("__continue: {}"), 0, { .d_c = 0 }}})));
	}
	v__gen__c__Gen_writeln(g, _SLIT("}"));
	if (node.label.len > 0) {
		v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = node.label}}, {_SLIT("__break: {}"), 0, { .d_c = 0 }}})));
	}
	g->loop_depth--;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_for_in_stmt(v__gen__c__Gen* g, v__ast__ForInStmt node) {
	g->loop_depth++;
	if (node.label.len > 0) {
		v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = node.label}}, {_SLIT(": {}"), 0, { .d_c = 0 }}})));
	}
	if (node.is_range) {
		string i = (string__eq(node.val_var, _SLIT("_")) ? (v__gen__c__Gen_new_tmp_var(g)) : (v__gen__c__c_name(node.val_var)));
		v__ast__Type val_typ = v__ast__mktyp(node.val_type);
		v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("for ("), 0xfe10, {.d_s = v__gen__c__Gen_typ(g, val_typ)}}, {_SLIT(" "), 0xfe10, {.d_s = i}}, {_SLIT(" = "), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_expr(g, node.cond);
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("; "), 0xfe10, {.d_s = i}}, {_SLIT(" < "), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_expr(g, node.high);
		v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("; ++"), 0xfe10, {.d_s = i}}, {_SLIT(") {"), 0, { .d_c = 0 }}})));
	} else if (node.kind == v__ast__Kind__array) {
		string styp = v__gen__c__Gen_typ(g, node.val_type);
		v__ast__TypeSymbol* val_sym = v__ast__Table_sym(g->table, node.val_type);
		string cond_var = _SLIT("");
		if ((node.cond)._typ == 299 /* v.ast.Ident */ || (node.cond)._typ == 319 /* v.ast.SelectorExpr */) {
			cond_var = v__gen__c__Gen_expr_string(g, node.cond);
		} else {
			cond_var = v__gen__c__Gen_new_tmp_var(g);
			v__gen__c__Gen_write(g, v__gen__c__Gen_typ(g, node.cond_type));
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(" "), 0xfe10, {.d_s = cond_var}}, {_SLIT(" = "), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_expr(g, node.cond);
			v__gen__c__Gen_writeln(g, _SLIT(";"));
		}
		string i = ((string__eq(node.key_var, _SLIT("")) || string__eq(node.key_var, _SLIT("_"))) ? (v__gen__c__Gen_new_tmp_var(g)) : (node.key_var));
		string field_accessor = (v__ast__Type_is_ptr(node.cond_type) ? (_SLIT("->")) : (_SLIT(".")));
		string share_accessor = (v__ast__Type_share(node.cond_type) == v__ast__ShareType__shared_t ? (_SLIT("val.")) : (_SLIT("")));
		string op_field = string__plus(field_accessor, share_accessor);
		g->empty_line = true;
		v__gen__c__Gen_writeln(g,  str_intp(6, _MOV((StrIntpData[]){{_SLIT("for (int "), 0xfe10, {.d_s = i}}, {_SLIT(" = 0; "), 0xfe10, {.d_s = i}}, {_SLIT(" < "), 0xfe10, {.d_s = cond_var}}, {_SLIT0, 0xfe10, {.d_s = op_field}}, {_SLIT("len; ++"), 0xfe10, {.d_s = i}}, {_SLIT(") {"), 0, { .d_c = 0 }}})));
		if (!string__eq(node.val_var, _SLIT("_"))) {
			if (val_sym->kind == v__ast__Kind__function) {
				v__gen__c__Gen_write(g, _SLIT("\t"));
				v__gen__c__Gen_write_fn_ptr_decl(g, ADDR(v__ast__FnType/*qq*/, /* as */ *(v__ast__FnType*)__as_cast((val_sym->info)._v__ast__FnType,(val_sym->info)._typ, 472) /*expected idx: 472, name: v.ast.FnType */ ), v__gen__c__c_name(node.val_var));
				v__gen__c__Gen_writeln(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT(" = ((voidptr*)"), 0xfe10, {.d_s = cond_var}}, {_SLIT0, 0xfe10, {.d_s = op_field}}, {_SLIT("data)["), 0xfe10, {.d_s = i}}, {_SLIT("];"), 0, { .d_c = 0 }}})));
			} else if (val_sym->kind == v__ast__Kind__array_fixed && !node.val_is_mut) {
				string right =  str_intp(5, _MOV((StrIntpData[]){{_SLIT("(("), 0xfe10, {.d_s = styp}}, {_SLIT("*)"), 0xfe10, {.d_s = cond_var}}, {_SLIT0, 0xfe10, {.d_s = op_field}}, {_SLIT("data)["), 0xfe10, {.d_s = i}}, {_SLIT("]"), 0, { .d_c = 0 }}}));
				v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = styp}}, {_SLIT(" "), 0xfe10, {.d_s = v__gen__c__c_name(node.val_var)}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
				v__gen__c__Gen_writeln(g,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("\tmemcpy(*("), 0xfe10, {.d_s = styp}}, {_SLIT("*)"), 0xfe10, {.d_s = v__gen__c__c_name(node.val_var)}}, {_SLIT(", (byte*)"), 0xfe10, {.d_s = right}}, {_SLIT(", sizeof("), 0xfe10, {.d_s = styp}}, {_SLIT("));"), 0, { .d_c = 0 }}})));
			} else {
				string right = (node.val_is_mut ? ( str_intp(5, _MOV((StrIntpData[]){{_SLIT("(("), 0xfe10, {.d_s = styp}}, {_SLIT(")"), 0xfe10, {.d_s = cond_var}}, {_SLIT0, 0xfe10, {.d_s = op_field}}, {_SLIT("data) + "), 0xfe10, {.d_s = i}}, {_SLIT0, 0, { .d_c = 0 }}}))) : ( str_intp(5, _MOV((StrIntpData[]){{_SLIT("(("), 0xfe10, {.d_s = styp}}, {_SLIT("*)"), 0xfe10, {.d_s = cond_var}}, {_SLIT0, 0xfe10, {.d_s = op_field}}, {_SLIT("data)["), 0xfe10, {.d_s = i}}, {_SLIT("]"), 0, { .d_c = 0 }}}))));
				v__gen__c__Gen_writeln(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = styp}}, {_SLIT(" "), 0xfe10, {.d_s = v__gen__c__c_name(node.val_var)}}, {_SLIT(" = "), 0xfe10, {.d_s = right}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
			}
		}
	} else if (node.kind == v__ast__Kind__array_fixed) {
		string cond_var = _SLIT("");
		bool cond_type_is_ptr = v__ast__Type_is_ptr(node.cond_type);
		bool cond_is_literal = (node.cond)._typ == 280 /* v.ast.ArrayInit */;
		if (cond_is_literal) {
			cond_var = v__gen__c__Gen_new_tmp_var(g);
			v__gen__c__Gen_write(g, v__gen__c__Gen_typ(g, node.cond_type));
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(" "), 0xfe10, {.d_s = cond_var}}, {_SLIT(" = "), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_expr(g, node.cond);
			v__gen__c__Gen_writeln(g, _SLIT(";"));
		} else if (cond_type_is_ptr) {
			cond_var = v__gen__c__Gen_new_tmp_var(g);
			string cond_var_type = string_trim(v__gen__c__Gen_typ(g, node.cond_type), _SLIT("*"));
			if (!v__ast__Expr_is_lvalue(node.cond)) {
				v__gen__c__Gen_write(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = cond_var_type}}, {_SLIT(" *"), 0xfe10, {.d_s = cond_var}}, {_SLIT(" = (("), 0xfe10, {.d_s = cond_var_type}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
			} else {
				v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = cond_var_type}}, {_SLIT(" *"), 0xfe10, {.d_s = cond_var}}, {_SLIT(" = ("), 0, { .d_c = 0 }}})));
			}
			v__gen__c__Gen_expr(g, node.cond);
			v__gen__c__Gen_writeln(g, _SLIT(");"));
		} else {
			cond_var = v__gen__c__Gen_expr_string(g, node.cond);
		}
		string idx = ((string__eq(node.key_var, _SLIT("")) || string__eq(node.key_var, _SLIT("_"))) ? (v__gen__c__Gen_new_tmp_var(g)) : (node.key_var));
		v__ast__TypeSymbol* cond_sym = v__ast__Table_sym(g->table, node.cond_type);
		v__ast__ArrayFixed info = /* as */ *(v__ast__ArrayFixed*)__as_cast((cond_sym->info)._v__ast__ArrayFixed,(cond_sym->info)._typ, 468) /*expected idx: 468, name: v.ast.ArrayFixed */ ;
		v__gen__c__Gen_writeln(g,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("for (int "), 0xfe10, {.d_s = idx}}, {_SLIT(" = 0; "), 0xfe10, {.d_s = idx}}, {_SLIT(" != "), 0xfe07, {.d_i32 = info.size}}, {_SLIT("; ++"), 0xfe10, {.d_s = idx}}, {_SLIT(") {"), 0, { .d_c = 0 }}})));
		if (!string__eq(node.val_var, _SLIT("_"))) {
			v__ast__TypeSymbol* val_sym = v__ast__Table_sym(g->table, node.val_type);
			bool is_fixed_array = val_sym->kind == v__ast__Kind__array_fixed && !node.val_is_mut;
			if (val_sym->kind == v__ast__Kind__function) {
				v__gen__c__Gen_write(g, _SLIT("\t"));
				v__gen__c__Gen_write_fn_ptr_decl(g, ADDR(v__ast__FnType/*qq*/, /* as */ *(v__ast__FnType*)__as_cast((val_sym->info)._v__ast__FnType,(val_sym->info)._typ, 472) /*expected idx: 472, name: v.ast.FnType */ ), v__gen__c__c_name(node.val_var));
			} else if (is_fixed_array) {
				string styp = v__gen__c__Gen_typ(g, node.val_type);
				v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = styp}}, {_SLIT(" "), 0xfe10, {.d_s = v__gen__c__c_name(node.val_var)}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
				v__gen__c__Gen_writeln(g,  str_intp(6, _MOV((StrIntpData[]){{_SLIT("\tmemcpy(*("), 0xfe10, {.d_s = styp}}, {_SLIT("*)"), 0xfe10, {.d_s = v__gen__c__c_name(node.val_var)}}, {_SLIT(", (byte*)"), 0xfe10, {.d_s = cond_var}}, {_SLIT("["), 0xfe10, {.d_s = idx}}, {_SLIT("], sizeof("), 0xfe10, {.d_s = styp}}, {_SLIT("));"), 0, { .d_c = 0 }}})));
			} else {
				string styp = v__gen__c__Gen_typ(g, node.val_type);
				v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = styp}}, {_SLIT(" "), 0xfe10, {.d_s = v__gen__c__c_name(node.val_var)}}, {_SLIT0, 0, { .d_c = 0 }}})));
			}
			if (!is_fixed_array) {
				string addr = (node.val_is_mut ? (_SLIT("&")) : (_SLIT("")));
				if (cond_type_is_ptr) {
					v__gen__c__Gen_writeln(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT(" = "), 0xfe10, {.d_s = addr}}, {_SLIT("(*"), 0xfe10, {.d_s = cond_var}}, {_SLIT(")["), 0xfe10, {.d_s = idx}}, {_SLIT("];"), 0, { .d_c = 0 }}})));
				} else if (cond_is_literal) {
					v__gen__c__Gen_writeln(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT(" = "), 0xfe10, {.d_s = addr}}, {_SLIT0, 0xfe10, {.d_s = cond_var}}, {_SLIT("["), 0xfe10, {.d_s = idx}}, {_SLIT("];"), 0, { .d_c = 0 }}})));
				} else {
					v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(" = "), 0xfe10, {.d_s = addr}}, {_SLIT0, 0, { .d_c = 0 }}})));
					v__gen__c__Gen_expr(g, node.cond);
					v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("["), 0xfe10, {.d_s = idx}}, {_SLIT("];"), 0, { .d_c = 0 }}})));
				}
			}
		}
	} else if (node.kind == v__ast__Kind__map) {
		string cond_var = _SLIT("");
		if ((node.cond)._typ == 299 /* v.ast.Ident */) {
			cond_var = v__gen__c__Gen_expr_string(g, node.cond);
		} else {
			cond_var = v__gen__c__Gen_new_tmp_var(g);
			v__gen__c__Gen_write(g, v__gen__c__Gen_typ(g, node.cond_type));
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(" "), 0xfe10, {.d_s = cond_var}}, {_SLIT(" = "), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_expr(g, node.cond);
			v__gen__c__Gen_writeln(g, _SLIT(";"));
		}
		string arw_or_pt = (v__ast__Type_is_ptr(node.cond_type) ? (_SLIT("->")) : (_SLIT(".")));
		if (v__ast__Type_has_flag(node.cond_type, v__ast__TypeFlag__shared_f)) {
			arw_or_pt = _SLIT("->val.");
		}
		string idx = v__gen__c__Gen_new_tmp_var(g);
		string map_len = v__gen__c__Gen_new_tmp_var(g);
		g->empty_line = true;
		v__gen__c__Gen_writeln(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("int "), 0xfe10, {.d_s = map_len}}, {_SLIT(" = "), 0xfe10, {.d_s = cond_var}}, {_SLIT0, 0xfe10, {.d_s = arw_or_pt}}, {_SLIT("key_values.len;"), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_writeln(g,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("for (int "), 0xfe10, {.d_s = idx}}, {_SLIT(" = 0; "), 0xfe10, {.d_s = idx}}, {_SLIT(" < "), 0xfe10, {.d_s = map_len}}, {_SLIT("; ++"), 0xfe10, {.d_s = idx}}, {_SLIT(" ) {"), 0, { .d_c = 0 }}})));
		g->indent++;
		string diff = v__gen__c__Gen_new_tmp_var(g);
		v__gen__c__Gen_writeln(g,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("int "), 0xfe10, {.d_s = diff}}, {_SLIT(" = "), 0xfe10, {.d_s = cond_var}}, {_SLIT0, 0xfe10, {.d_s = arw_or_pt}}, {_SLIT("key_values.len - "), 0xfe10, {.d_s = map_len}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_writeln(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = map_len}}, {_SLIT(" = "), 0xfe10, {.d_s = cond_var}}, {_SLIT0, 0xfe10, {.d_s = arw_or_pt}}, {_SLIT("key_values.len;"), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("if ("), 0xfe10, {.d_s = diff}}, {_SLIT(" < 0) {"), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = idx}}, {_SLIT(" = -1;"), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_writeln(g, _SLIT("\tcontinue;"));
		v__gen__c__Gen_writeln(g, _SLIT("}"));
		v__gen__c__Gen_writeln(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("if (!DenseArray_has_index(&"), 0xfe10, {.d_s = cond_var}}, {_SLIT0, 0xfe10, {.d_s = arw_or_pt}}, {_SLIT("key_values, "), 0xfe10, {.d_s = idx}}, {_SLIT(")) {continue;}"), 0, { .d_c = 0 }}})));
		if (!string__eq(node.key_var, _SLIT("_"))) {
			string key_styp = v__gen__c__Gen_typ(g, node.key_type);
			string key = v__gen__c__c_name(node.key_var);
			v__gen__c__Gen_writeln(g,  str_intp(7, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = key_styp}}, {_SLIT(" "), 0xfe10, {.d_s = key}}, {_SLIT(" = /*key*/ *("), 0xfe10, {.d_s = key_styp}}, {_SLIT("*)DenseArray_key(&"), 0xfe10, {.d_s = cond_var}}, {_SLIT0, 0xfe10, {.d_s = arw_or_pt}}, {_SLIT("key_values, "), 0xfe10, {.d_s = idx}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
			if (v__ast__Type_alias_eq(node.key_type, _const_v__ast__string_type)) {
				v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = key}}, {_SLIT(" = string_clone("), 0xfe10, {.d_s = key}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
			}
		}
		if (!string__eq(node.val_var, _SLIT("_"))) {
			v__ast__TypeSymbol* val_sym = v__ast__Table_sym(g->table, node.val_type);
			if (val_sym->kind == v__ast__Kind__function) {
				v__gen__c__Gen_write_fn_ptr_decl(g, ADDR(v__ast__FnType/*qq*/, /* as */ *(v__ast__FnType*)__as_cast((val_sym->info)._v__ast__FnType,(val_sym->info)._typ, 472) /*expected idx: 472, name: v.ast.FnType */ ), v__gen__c__c_name(node.val_var));
				v__gen__c__Gen_write(g, _SLIT(" = (*(voidptr*)"));
				v__gen__c__Gen_writeln(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("DenseArray_value(&"), 0xfe10, {.d_s = cond_var}}, {_SLIT0, 0xfe10, {.d_s = arw_or_pt}}, {_SLIT("key_values, "), 0xfe10, {.d_s = idx}}, {_SLIT("));"), 0, { .d_c = 0 }}})));
			} else if (val_sym->kind == v__ast__Kind__array_fixed && !node.val_is_mut) {
				string val_styp = v__gen__c__Gen_typ(g, node.val_type);
				v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = val_styp}}, {_SLIT(" "), 0xfe10, {.d_s = v__gen__c__c_name(node.val_var)}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
				v__gen__c__Gen_writeln(g,  str_intp(7, _MOV((StrIntpData[]){{_SLIT("memcpy(*("), 0xfe10, {.d_s = val_styp}}, {_SLIT("*)"), 0xfe10, {.d_s = v__gen__c__c_name(node.val_var)}}, {_SLIT(", (byte*)DenseArray_value(&"), 0xfe10, {.d_s = cond_var}}, {_SLIT0, 0xfe10, {.d_s = arw_or_pt}}, {_SLIT("key_values, "), 0xfe10, {.d_s = idx}}, {_SLIT("), sizeof("), 0xfe10, {.d_s = val_styp}}, {_SLIT("));"), 0, { .d_c = 0 }}})));
			} else {
				string val_styp = v__gen__c__Gen_typ(g, node.val_type);
				if (v__ast__Type_is_ptr(node.val_type)) {
					if (node.val_is_mut) {
						v__gen__c__Gen_write(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = val_styp}}, {_SLIT(" "), 0xfe10, {.d_s = v__gen__c__c_name(node.val_var)}}, {_SLIT(" = &(*("), 0xfe10, {.d_s = val_styp}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
					} else {
						v__gen__c__Gen_write(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = val_styp}}, {_SLIT(" "), 0xfe10, {.d_s = v__gen__c__c_name(node.val_var)}}, {_SLIT(" = (*("), 0xfe10, {.d_s = val_styp}}, {_SLIT("*)"), 0, { .d_c = 0 }}})));
					}
				} else {
					v__gen__c__Gen_write(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = val_styp}}, {_SLIT(" "), 0xfe10, {.d_s = v__gen__c__c_name(node.val_var)}}, {_SLIT(" = (*("), 0xfe10, {.d_s = val_styp}}, {_SLIT("*)"), 0, { .d_c = 0 }}})));
				}
				v__gen__c__Gen_writeln(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("DenseArray_value(&"), 0xfe10, {.d_s = cond_var}}, {_SLIT0, 0xfe10, {.d_s = arw_or_pt}}, {_SLIT("key_values, "), 0xfe10, {.d_s = idx}}, {_SLIT("));"), 0, { .d_c = 0 }}})));
			}
		}
		g->indent--;
	} else if (node.kind == v__ast__Kind__string) {
		v__ast__Expr cond = ((node.cond)._typ == 323 /* v.ast.StringLiteral */ || (node.cond)._typ == 322 /* v.ast.StringInterLiteral */ ? (v__ast__CTempVar_to_sumtype_v__ast__Expr(ADDR(v__ast__CTempVar, (v__gen__c__Gen_new_ctemp_var_then_gen(g, node.cond, _const_v__ast__string_type))))) : (node.cond));
		string i = ((string__eq(node.key_var, _SLIT("")) || string__eq(node.key_var, _SLIT("_"))) ? (v__gen__c__Gen_new_tmp_var(g)) : (node.key_var));
		v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("for (int "), 0xfe10, {.d_s = i}}, {_SLIT(" = 0; "), 0xfe10, {.d_s = i}}, {_SLIT(" < "), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_expr(g, cond);
		v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(".len; ++"), 0xfe10, {.d_s = i}}, {_SLIT(") {"), 0, { .d_c = 0 }}})));
		if (!string__eq(node.val_var, _SLIT("_"))) {
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\tbyte "), 0xfe10, {.d_s = v__gen__c__c_name(node.val_var)}}, {_SLIT(" = "), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_expr(g, cond);
			v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(".str["), 0xfe10, {.d_s = i}}, {_SLIT("];"), 0, { .d_c = 0 }}})));
		}
	} else if (node.kind == v__ast__Kind__struct_) {
		v__ast__TypeSymbol* cond_type_sym = v__ast__Table_sym(g->table, node.cond_type);
		Option_v__ast__Fn _t1 = v__ast__TypeSymbol_find_method_with_generic_parent(cond_type_sym, _SLIT("next"));
		if (_t1.state != 0) { /*or block*/ 
			IError err = _t1.err;
			v__gen__c__verror(_SLIT("`next` method not found"));
			VUNREACHABLE();
			return;
		}
		
 		v__ast__Fn next_fn =  (*(v__ast__Fn*)_t1.data);
		v__ast__Type ret_typ = next_fn.return_type;
		string t_expr = v__gen__c__Gen_new_tmp_var(g);
		v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__gen__c__Gen_typ(g, node.cond_type)}}, {_SLIT(" "), 0xfe10, {.d_s = t_expr}}, {_SLIT(" = "), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_expr(g, node.cond);
		v__gen__c__Gen_writeln(g, _SLIT(";"));
		if (string__eq(node.key_var, _SLIT("")) || string__eq(node.key_var, _SLIT("_"))) {
			v__gen__c__Gen_writeln(g, _SLIT("while (1) {"));
		} else {
			v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("for (size_t "), 0xfe10, {.d_s = node.key_var}}, {_SLIT(" = 0;; ++"), 0xfe10, {.d_s = node.key_var}}, {_SLIT(") {"), 0, { .d_c = 0 }}})));
		}
		string t_var = v__gen__c__Gen_new_tmp_var(g);
		v__ast__Type receiver_typ = (*(v__ast__Param*)/*ee elem_typ */array_get(next_fn.params, 0)).typ;
		string receiver_styp = v__gen__c__Gen_typ(g, receiver_typ);
		string fn_name = string__plus(string_replace_each(receiver_styp, new_array_from_c_array(4, 4, sizeof(string), _MOV((string[4]){_SLIT("*"), _SLIT(""), _SLIT("."), _SLIT("__")}))), _SLIT("_next"));
		v__ast__TypeSymbol* receiver_sym = v__ast__Table_sym(g->table, receiver_typ);
		if ((receiver_sym->info)._typ == 446 /* v.ast.Struct */) {
			if ((*receiver_sym->info._v__ast__Struct).concrete_types.len > 0) {
				fn_name = v__gen__c__Gen_generic_fn_name(g, (*receiver_sym->info._v__ast__Struct).concrete_types, fn_name, false);
			}
		}
		v__gen__c__Gen_write(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = v__gen__c__Gen_typ(g, ret_typ)}}, {_SLIT(" "), 0xfe10, {.d_s = t_var}}, {_SLIT(" = "), 0xfe10, {.d_s = fn_name}}, {_SLIT("("), 0, { .d_c = 0 }}})));
		if (!v__ast__Type_is_ptr(node.cond_type) && v__ast__Type_is_ptr(receiver_typ)) {
			v__gen__c__Gen_write(g, _SLIT("&"));
		}
		v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = t_expr}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\tif ("), 0xfe10, {.d_s = t_var}}, {_SLIT(".state != 0) break;"), 0, { .d_c = 0 }}})));
		string val = ((string__eq(node.val_var, _SLIT("")) || string__eq(node.val_var, _SLIT("_"))) ? (v__gen__c__Gen_new_tmp_var(g)) : (node.val_var));
		string val_styp = v__gen__c__Gen_typ(g, node.val_type);
		if (node.val_is_mut) {
			v__gen__c__Gen_writeln(g,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = val_styp}}, {_SLIT(" "), 0xfe10, {.d_s = val}}, {_SLIT(" = ("), 0xfe10, {.d_s = val_styp}}, {_SLIT(")"), 0xfe10, {.d_s = t_var}}, {_SLIT(".data;"), 0, { .d_c = 0 }}})));
		} else {
			v__gen__c__Gen_writeln(g,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = val_styp}}, {_SLIT(" "), 0xfe10, {.d_s = val}}, {_SLIT(" = *("), 0xfe10, {.d_s = val_styp}}, {_SLIT("*)"), 0xfe10, {.d_s = t_var}}, {_SLIT(".data;"), 0, { .d_c = 0 }}})));
		}
	} else {
		string typ_str = v__ast__Table_type_to_str(g->table, node.cond_type);
		v__gen__c__Gen_error(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("for in: unhandled symbol `"), 0xfe10, {.d_s = v__ast__Expr_str(node.cond)}}, {_SLIT("` of type `"), 0xfe10, {.d_s = typ_str}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node.pos);
		VUNREACHABLE();
	}
	v__gen__c__Gen_stmts(g, node.stmts);
	if (node.label.len > 0) {
		v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = node.label}}, {_SLIT("__continue: {}"), 0, { .d_c = 0 }}})));
	}
	if (node.kind == v__ast__Kind__map) {
	}
	v__gen__c__Gen_writeln(g, _SLIT("}"));
	if (node.label.len > 0) {
		v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = node.label}}, {_SLIT("__break: {}"), 0, { .d_c = 0 }}})));
	}
	g->loop_depth--;
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_get_sumtype_casting_fn(v__gen__c__Gen* g, v__ast__Type got_, v__ast__Type exp_) {
	int got = v__ast__Type_idx(got_);
	int exp = v__ast__Type_idx(exp_);
	int i = (got | ((int)(((u32)(exp)) << 16U)));
	string got_cname = v__ast__Table_sym(g->table, got)->cname;
	string exp_cname = v__ast__Table_sym(g->table, exp)->cname;
	string fn_name =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = got_cname}}, {_SLIT("_to_sumtype_"), 0xfe10, {.d_s = exp_cname}}, {_SLIT0, 0, { .d_c = 0 }}}));
	if (got == exp || (*(bool*)map_get(ADDR(map, g->sumtype_definitions), &(int[]){i}, &(bool[]){ 0 }))) {
		string _t1 = fn_name;
		return _t1;
	}
	map_set(&g->sumtype_definitions, &(int[]){i}, &(bool[]) { true });
	array_push((array*)&g->sumtype_casting_fns, _MOV((v__gen__c__SumtypeCastingFn[]){ (v__gen__c__SumtypeCastingFn){.fn_name = fn_name,.got = got,.exp = exp,} }));
	string _t3 = fn_name;
	return _t3;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_write_sumtype_casting_fn(v__gen__c__Gen* g, v__gen__c__SumtypeCastingFn fun) {
	v__ast__Type got = fun.got;
	v__ast__Type exp = fun.exp;
	v__ast__TypeSymbol* got_sym = v__ast__Table_sym(g->table, got);
	v__ast__TypeSymbol* exp_sym = v__ast__Table_sym(g->table, exp);
	string got_cname = got_sym->cname;
	string exp_cname = exp_sym->cname;
	strings__Builder sb = strings__new_builder(128);
	strings__Builder_writeln(&sb,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("static inline "), 0xfe10, {.d_s = exp_cname}}, {_SLIT(" "), 0xfe10, {.d_s = fun.fn_name}}, {_SLIT("("), 0xfe10, {.d_s = got_cname}}, {_SLIT("* x) {"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&sb,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = got_cname}}, {_SLIT("* ptr = memdup(x, sizeof("), 0xfe10, {.d_s = got_cname}}, {_SLIT("));"), 0, { .d_c = 0 }}})));
	Array_Array_v__ast__Type _t1 = v__ast__Table_get_embeds(g->table, got_sym, (v__ast__GetEmbedsOptions){.preceding = __new_array(0, 0, sizeof(v__ast__Type)),});
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		Array_v__ast__Type embed_hierarchy = ((Array_v__ast__Type*)_t1.data)[_t2];
		string embed_cname = _SLIT("");
		string embed_name = _SLIT("");
		string accessor = _SLIT("&x->");
		for (int j = 0; j < embed_hierarchy.len; ++j) {
			v__ast__Type embed = ((v__ast__Type*)embed_hierarchy.data)[j];
			v__ast__TypeSymbol* embed_sym = v__ast__Table_sym(g->table, embed);
			embed_cname = embed_sym->cname;
			embed_name = v__ast__TypeSymbol_embed_name(embed_sym);
			if (j > 0) {
				accessor = /*f*/string__plus(accessor, _SLIT("."));
			}
			accessor = /*f*/string__plus(accessor, embed_name);
		}
		strings__Builder_writeln(&sb,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = embed_cname}}, {_SLIT("* "), 0xfe10, {.d_s = embed_name}}, {_SLIT("_ptr = memdup("), 0xfe10, {.d_s = accessor}}, {_SLIT(", sizeof("), 0xfe10, {.d_s = embed_cname}}, {_SLIT("));"), 0, { .d_c = 0 }}})));
	}
	strings__Builder_write_string(&sb,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\treturn ("), 0xfe10, {.d_s = exp_cname}}, {_SLIT("){ ._"), 0xfe10, {.d_s = got_cname}}, {_SLIT(" = ptr, ._typ = "), 0xfe10, {.d_s = v__gen__c__Gen_type_sidx(g, got)}}, {_SLIT0, 0, { .d_c = 0 }}})));
	for (int _t3 = 0; _t3 < (/* as */ *(v__ast__SumType*)__as_cast((exp_sym->info)._v__ast__SumType,(exp_sym->info)._typ, 464) /*expected idx: 464, name: v.ast.SumType */ ).fields.len; ++_t3) {
		v__ast__StructField field = ((v__ast__StructField*)(/* as */ *(v__ast__SumType*)__as_cast((exp_sym->info)._v__ast__SumType,(exp_sym->info)._typ, 464) /*expected idx: 464, name: v.ast.SumType */ ).fields.data)[_t3];
		string ptr = _SLIT("ptr");
		string type_cname = got_cname;
		Option_multi_return_v__ast__StructField_Array_v__ast__Type _t4 = v__ast__Table_find_field_from_embeds(g->table, got_sym, field.name);
		if (_t4.state != 0) { /*or block*/ 
			IError err = _t4.err;
			*(multi_return_v__ast__StructField_Array_v__ast__Type*) _t4.data = (multi_return_v__ast__StructField_Array_v__ast__Type){.arg0=(v__ast__StructField){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.has_default_expr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_pub = 0,.default_val = (string){.str=(byteptr)"", .is_lit=1},.is_mut = 0,.is_global = 0,.is_volatile = 0,.default_expr = {0},.default_expr_typ = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,},.arg1=__new_array_with_default(0, 0, sizeof(v__ast__Type), 0)};
		}
		
 		Option_multi_return_v__ast__StructField_Array_v__ast__Type mr_73115 =  _t4 /*U*/;
		Array_v__ast__Type embed_types = (*(multi_return_v__ast__StructField_Array_v__ast__Type*)mr_73115.data).arg1;
		if (embed_types.len > 0) {
			v__ast__TypeSymbol* embed_sym = v__ast__Table_sym(g->table, (*(v__ast__Type*)array_last(embed_types)));
			ptr =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__ast__TypeSymbol_embed_name(embed_sym)}}, {_SLIT("_ptr"), 0, { .d_c = 0 }}}));
			type_cname = embed_sym->cname;
		}
		string field_styp = v__gen__c__Gen_typ(g, field.typ);
		if (got_sym->kind == v__ast__Kind__sum_type || got_sym->kind == v__ast__Kind__interface_) {
			strings__Builder_write_string(&sb,  str_intp(3, _MOV((StrIntpData[]){{_SLIT(", ."), 0xfe10, {.d_s = field.name}}, {_SLIT(" = ptr->"), 0xfe10, {.d_s = field.name}}, {_SLIT0, 0, { .d_c = 0 }}})));
		} else {
			strings__Builder_write_string(&sb,  str_intp(7, _MOV((StrIntpData[]){{_SLIT(", ."), 0xfe10, {.d_s = field.name}}, {_SLIT(" = ("), 0xfe10, {.d_s = field_styp}}, {_SLIT("*)((char*)"), 0xfe10, {.d_s = ptr}}, {_SLIT(" + __offsetof_ptr("), 0xfe10, {.d_s = ptr}}, {_SLIT(", "), 0xfe10, {.d_s = type_cname}}, {_SLIT(", "), 0xfe10, {.d_s = field.name}}, {_SLIT("))"), 0, { .d_c = 0 }}})));
		}
	}
	strings__Builder_writeln(&sb, _SLIT("};\n}"));
	array_push((array*)&g->auto_fn_definitions, _MOV((string[]){ string_clone(strings__Builder_str(&sb)) }));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_call_cfn_for_casting_expr(v__gen__c__Gen* g, string fname, v__ast__Expr expr, bool exp_is_ptr, string exp_styp, bool got_is_ptr, string got_styp) {
	int rparen_n = 1;
	if (exp_is_ptr) {
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("HEAP("), 0xfe10, {.d_s = exp_styp}}, {_SLIT(", "), 0, { .d_c = 0 }}})));
		rparen_n++;
	}
	v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = fname}}, {_SLIT("("), 0, { .d_c = 0 }}})));
	if (!got_is_ptr) {
		if (!v__ast__Expr_is_lvalue(expr) || ((expr)._typ == 299 /* v.ast.Ident */ && v__ast__ScopeObject_is_simple_define_const((/* as */ *(v__ast__Ident*)__as_cast((expr)._v__ast__Ident,(expr)._typ, 299) /*expected idx: 299, name: v.ast.Ident */ ).obj))) {
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("ADDR("), 0xfe10, {.d_s = got_styp}}, {_SLIT(", ("), 0, { .d_c = 0 }}})));
			rparen_n += 2;
		} else {
			v__gen__c__Gen_write(g, _SLIT("&"));
		}
	}
	v__gen__c__Gen_expr(g, expr);
	v__gen__c__Gen_write(g, string_repeat(_SLIT(")"), rparen_n));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_expr_with_cast(v__gen__c__Gen* g, v__ast__Expr expr, v__ast__Type got_type_raw, v__ast__Type expected_type) {
	v__ast__Type got_type = v__ast__mktyp(got_type_raw);
	v__ast__TypeSymbol* exp_sym = v__ast__Table_sym(g->table, expected_type);
	v__ast__TypeSymbol* got_sym = v__ast__Table_sym(g->table, got_type);
	bool expected_is_ptr = v__ast__Type_is_ptr(expected_type);
	bool got_is_ptr = v__ast__Type_is_ptr(got_type);
	if (got_type == _const_v__ast__error_type_idx && expected_type == _const_v__ast__string_type_idx) {
		v__gen__c__Gen_write(g, _SLIT("(*("));
		v__gen__c__Gen_expr(g, expr);
		v__gen__c__Gen_write(g, _SLIT(".msg))"));
		return;
	}
	if (got_sym->kind == v__ast__Kind__none_ && string__eq(exp_sym->name, _SLIT("IError"))) {
		v__gen__c__Gen_expr(g, expr);
		return;
	}
	if ((exp_sym->info)._typ == 463 /* v.ast.Interface */ && v__ast__Type_idx(got_type_raw) != v__ast__Type_idx(expected_type) && !v__ast__Type_has_flag(expected_type, v__ast__TypeFlag__optional)) {
		if ((expr)._typ == 324 /* v.ast.StructInit */ && !v__ast__Type_is_ptr(got_type)) {
			g->inside_cast_in_heap++;
			string got_styp = v__gen__c__Gen_cc_type(g, v__ast__Type_ref(got_type), true);
			string exp_styp = exp_sym->cname;
			string fname =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("I_"), 0xfe10, {.d_s = got_styp}}, {_SLIT("_to_Interface_"), 0xfe10, {.d_s = exp_styp}}, {_SLIT0, 0, { .d_c = 0 }}}));
			if ((*exp_sym->info._v__ast__Interface).is_generic) {
				fname = v__gen__c__Gen_generic_fn_name(g, (*exp_sym->info._v__ast__Interface).concrete_types, fname, false);
			}
			v__gen__c__Gen_call_cfn_for_casting_expr(g, fname, expr, expected_is_ptr, exp_styp, true, got_styp);
			g->inside_cast_in_heap--;
		} else {
			string got_styp = v__gen__c__Gen_cc_type(g, got_type, true);
			got_styp = ((string__eq(got_styp, _SLIT("int"))) ? (_SLIT("int_literal")) : (string__eq(got_styp, _SLIT("f64"))) ? (_SLIT("float_literal")) : (got_styp));
			bool got_is_shared = v__ast__Type_has_flag(got_type, v__ast__TypeFlag__shared_f);
			string exp_styp = (got_is_shared ? ( str_intp(2, _MOV((StrIntpData[]){{_SLIT("__shared__"), 0xfe10, {.d_s = exp_sym->cname}}, {_SLIT0, 0, { .d_c = 0 }}}))) : (exp_sym->cname));
			string fname = (got_is_shared ? ( str_intp(3, _MOV((StrIntpData[]){{_SLIT("I___shared__"), 0xfe10, {.d_s = got_styp}}, {_SLIT("_to_shared_Interface_"), 0xfe10, {.d_s = exp_styp}}, {_SLIT0, 0, { .d_c = 0 }}}))) : ( str_intp(3, _MOV((StrIntpData[]){{_SLIT("I_"), 0xfe10, {.d_s = got_styp}}, {_SLIT("_to_Interface_"), 0xfe10, {.d_s = exp_styp}}, {_SLIT0, 0, { .d_c = 0 }}}))));
			sync__RwMutex_lock(&g->referenced_fns->mtx);
			/*lock*/ {
				map_set(&g->referenced_fns->val, &(string[]){fname}, &(bool[]) { true });
			}
			sync__RwMutex_unlock(&g->referenced_fns->mtx);;
			fname =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("/*"), 0xfe10, {.d_s = str_intp(1, _MOV((StrIntpData[]){{_SLIT("&"), 0xfe10 ,{.d_s=v__ast__TypeSymbol_str(exp_sym)}}}))}}, {_SLIT("*/"), 0xfe10, {.d_s = fname}}, {_SLIT0, 0, { .d_c = 0 }}}));
			if ((*exp_sym->info._v__ast__Interface).is_generic) {
				fname = v__gen__c__Gen_generic_fn_name(g, (*exp_sym->info._v__ast__Interface).concrete_types, fname, false);
			}
			v__gen__c__Gen_call_cfn_for_casting_expr(g, fname, expr, expected_is_ptr, exp_styp, got_is_ptr, got_styp);
		}
		return;
	}
	string exp_styp = v__gen__c__Gen_typ(g, expected_type);
	string got_styp = v__gen__c__Gen_typ(g, got_type);
	if (!v__ast__Type_alias_eq(expected_type, _const_v__ast__void_type)) {
		v__ast__Type unwrapped_expected_type = v__gen__c__Gen_unwrap_generic(g, expected_type);
		v__ast__Type unwrapped_got_type = v__gen__c__Gen_unwrap_generic(g, got_type);
		v__ast__TypeSymbol* unwrapped_exp_sym = v__ast__Table_sym(g->table, unwrapped_expected_type);
		v__ast__TypeSymbol* unwrapped_got_sym = v__ast__Table_sym(g->table, unwrapped_got_type);
		v__ast__Type expected_deref_type = (expected_is_ptr ? (v__ast__Type_deref(unwrapped_expected_type)) : (unwrapped_expected_type));
		v__ast__Type got_deref_type = (got_is_ptr ? (v__ast__Type_deref(unwrapped_got_type)) : (unwrapped_got_type));
		if (v__ast__Table_sumtype_has_variant(g->table, expected_deref_type, got_deref_type, false)) {
			bool is_already_sum_type = false;
			v__ast__Scope* scope = v__ast__Scope_innermost(g->file->scope, v__ast__Expr_position(expr).pos);
			if ((expr)._typ == 299 /* v.ast.Ident */) {
				Option_v__ast__Var_ptr _t1;
				if (_t1 = v__ast__Scope_find_var(scope, (*expr._v__ast__Ident).name), _t1.state == 0) {
					v__ast__Var* v = *(v__ast__Var**)_t1.data;
					if (v->smartcasts.len > 0) {
						is_already_sum_type = true;
					}
				}
			} else if ((expr)._typ == 319 /* v.ast.SelectorExpr */) {
				Option_v__ast__ScopeStructField _t2;
				if (_t2 = v__ast__Scope_find_struct_field(scope, v__ast__Expr_str((*expr._v__ast__SelectorExpr).expr), (*expr._v__ast__SelectorExpr).expr_type, (*expr._v__ast__SelectorExpr).field_name), _t2.state == 0) {
					is_already_sum_type = true;
				}
			}
			if (is_already_sum_type) {
				g->prevent_sum_type_unwrapping_once = true;
				v__gen__c__Gen_expr(g, expr);
			} else {
				v__gen__c__Gen_get_sumtype_casting_fn(g, unwrapped_got_type, unwrapped_expected_type);
				string fname =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = unwrapped_got_sym->cname}}, {_SLIT("_to_sumtype_"), 0xfe10, {.d_s = unwrapped_exp_sym->cname}}, {_SLIT0, 0, { .d_c = 0 }}}));
				v__gen__c__Gen_call_cfn_for_casting_expr(g, fname, expr, expected_is_ptr, unwrapped_exp_sym->cname, got_is_ptr, got_styp);
			}
			return;
		}
	}
	bool neither_void = !(_const_v__ast__voidptr_type == got_type || _const_v__ast__voidptr_type == expected_type);
	bool to_shared = v__ast__Type_has_flag(expected_type, v__ast__TypeFlag__shared_f) && !v__ast__Type_has_flag(got_type_raw, v__ast__TypeFlag__shared_f) && !v__ast__Type_has_flag(expected_type, v__ast__TypeFlag__optional);
	if (to_shared) {
		string shared_styp = string_substr(exp_styp, 0, exp_styp.len - 1);
		if (v__ast__Type_is_ptr(got_type_raw)) {
			v__gen__c__Gen_error(g, _SLIT("cannot convert reference to `shared`"), v__ast__Expr_position(expr));
			VUNREACHABLE();
		}
		if (exp_sym->kind == v__ast__Kind__array) {
			v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("("), 0xfe10, {.d_s = shared_styp}}, {_SLIT("*)__dup_shared_array(&("), 0xfe10, {.d_s = shared_styp}}, {_SLIT("){.mtx = {0}, .val ="), 0, { .d_c = 0 }}})));
		} else if (exp_sym->kind == v__ast__Kind__map) {
			v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("("), 0xfe10, {.d_s = shared_styp}}, {_SLIT("*)__dup_shared_map(&("), 0xfe10, {.d_s = shared_styp}}, {_SLIT("){.mtx = {0}, .val ="), 0, { .d_c = 0 }}})));
		} else {
			v__gen__c__Gen_writeln(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("("), 0xfe10, {.d_s = shared_styp}}, {_SLIT("*)__dup"), 0xfe10, {.d_s = shared_styp}}, {_SLIT("(&("), 0xfe10, {.d_s = shared_styp}}, {_SLIT("){.mtx = {0}, .val ="), 0, { .d_c = 0 }}})));
		}
		bool old_is_shared = g->is_shared;
		g->is_shared = false;
		v__gen__c__Gen_expr(g, expr);
		g->is_shared = old_is_shared;
		v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("}, sizeof("), 0xfe10, {.d_s = shared_styp}}, {_SLIT("))"), 0, { .d_c = 0 }}})));
		return;
	}
	if (got_is_ptr && !expected_is_ptr && neither_void && exp_sym->kind != v__ast__Kind__placeholder && (expr)._typ != 303 /* v.ast.InfixExpr */) {
		v__ast__Type got_deref_type = v__ast__Type_deref(got_type);
		v__ast__TypeSymbol* deref_sym = v__ast__Table_sym(g->table, got_deref_type);
		bool deref_will_match = (expected_type == got_type || expected_type == got_deref_type || expected_type == deref_sym->parent_idx);
		bool got_is_opt = v__ast__Type_has_flag(got_type, v__ast__TypeFlag__optional);
		if (deref_will_match || got_is_opt || v__ast__Expr_is_auto_deref_var(expr)) {
			v__gen__c__Gen_write(g, _SLIT("*"));
		}
	}
	if (v__ast__Type_has_flag(expected_type, v__ast__TypeFlag__optional) && (expr)._typ == 311 /* v.ast.None */) {
		v__gen__c__Gen_gen_optional_error(g, expected_type, expr);
		return;
	}
	if ((expr)._typ == 304 /* v.ast.IntegerLiteral */) {
		if ((expected_type == _const_v__ast__u64_type || expected_type == _const_v__ast__u32_type || expected_type == _const_v__ast__u16_type) && string_at((*expr._v__ast__IntegerLiteral).val, 0) != '-') {
			v__gen__c__Gen_expr(g, expr);
			v__gen__c__Gen_write(g, _SLIT("U"));
			return;
		}
	}
	if (exp_sym->kind == v__ast__Kind__function) {
		v__gen__c__Gen_write(g, _SLIT("(voidptr)"));
	}
	v__gen__c__Gen_expr(g, expr);
}

VV_LOCAL_SYMBOL string v__gen__c__cestring(string s) {
	string _t1 = string_replace(string_replace(s, _SLIT("\\"), _SLIT("\\\\")), _SLIT("\""), _SLIT("'"));
	return _t1;
}

VV_LOCAL_SYMBOL string v__gen__c__ctoslit(string s) {
	string _t1 = string__plus(string__plus(_SLIT("_SLIT(\""), v__gen__c__cestring(s)), _SLIT("\")"));
	return _t1;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_attrs(v__gen__c__Gen* g, Array_v__ast__Attr attrs) {
	if (g->pref->skip_unused) {
		return;
	}
	for (int _t1 = 0; _t1 < attrs.len; ++_t1) {
		v__ast__Attr attr = ((v__ast__Attr*)attrs.data)[_t1];
		v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("// Attr: ["), 0xfe10, {.d_s = attr.name}}, {_SLIT("]"), 0, { .d_c = 0 }}})));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_asm_stmt(v__gen__c__Gen* g, v__ast__AsmStmt stmt) {
	v__gen__c__Gen_write(g, _SLIT("__asm__"));
	if (stmt.is_volatile) {
		v__gen__c__Gen_write(g, _SLIT(" volatile"));
	}
	if (stmt.is_goto) {
		v__gen__c__Gen_write(g, _SLIT(" goto"));
	}
	v__gen__c__Gen_writeln(g, _SLIT(" ("));
	g->indent++;
	for (int _t1 = 0; _t1 < stmt.templates.len; ++_t1) {
		v__ast__AsmTemplate template_tmp = ((v__ast__AsmTemplate*)stmt.templates.data)[_t1];
		v__ast__AsmTemplate _v_template = template_tmp;
		v__gen__c__Gen_write(g, _SLIT("\""));
		if (_v_template.is_directive) {
			v__gen__c__Gen_write(g, _SLIT("."));
		}
		v__gen__c__Gen_write(g, _v_template.name);
		if (_v_template.is_label) {
			v__gen__c__Gen_write(g, _SLIT(":"));
		} else {
			v__gen__c__Gen_write(g, _SLIT(" "));
		}
		if (_v_template.args.len != 0 && !_v_template.is_directive) {
			array_prepend(&_v_template.args, &(v__ast__AsmArg[]){(*(v__ast__AsmArg*)/*ee elem_typ */array_get(_v_template.args, _v_template.args.len - 1))});
			array_delete(&_v_template.args, _v_template.args.len - 1);
		}
		for (int i = 0; i < _v_template.args.len; ++i) {
			v__ast__AsmArg arg = ((v__ast__AsmArg*)_v_template.args.data)[i];
			if (stmt.arch == v__pref__Arch__amd64 && (string__eq(_v_template.name, _SLIT("call")) || string_at(_v_template.name, 0) == 'j') && (arg)._typ == 354 /* v.ast.AsmRegister */) {
				v__gen__c__Gen_write(g, _SLIT("*"));
			}
			v__gen__c__Gen_asm_arg(g, arg, stmt);
			if (i + 1 < _v_template.args.len) {
				v__gen__c__Gen_write(g, _SLIT(", "));
			}
		}
		if (!_v_template.is_label) {
			v__gen__c__Gen_write(g, _SLIT(";"));
		}
		v__gen__c__Gen_writeln(g, _SLIT("\""));
	}
	if (stmt.output.len != 0 || stmt.input.len != 0 || stmt.clobbered.len != 0 || stmt.is_goto) {
		v__gen__c__Gen_write(g, _SLIT(": "));
	}
	v__gen__c__Gen_gen_asm_ios(g, stmt.output);
	if (stmt.input.len != 0 || stmt.clobbered.len != 0 || stmt.is_goto) {
		v__gen__c__Gen_write(g, _SLIT(": "));
	}
	v__gen__c__Gen_gen_asm_ios(g, stmt.input);
	if (stmt.clobbered.len != 0 || stmt.is_goto) {
		v__gen__c__Gen_write(g, _SLIT(": "));
	}
	for (int i = 0; i < stmt.clobbered.len; ++i) {
		v__ast__AsmClobbered clob = ((v__ast__AsmClobbered*)stmt.clobbered.data)[i];
		v__gen__c__Gen_write(g, _SLIT("\""));
		v__gen__c__Gen_write(g, clob.reg.name);
		v__gen__c__Gen_write(g, _SLIT("\""));
		if (i + 1 < stmt.clobbered.len) {
			v__gen__c__Gen_writeln(g, _SLIT(","));
		} else {
			v__gen__c__Gen_writeln(g, _SLIT(""));
		}
	}
	if (stmt.is_goto) {
		v__gen__c__Gen_write(g, _SLIT(": "));
	}
	for (int i = 0; i < stmt.global_labels.len; ++i) {
		string label = ((string*)stmt.global_labels.data)[i];
		v__gen__c__Gen_write(g, label);
		if (i + 1 < stmt.clobbered.len) {
			v__gen__c__Gen_writeln(g, _SLIT(","));
		} else {
			v__gen__c__Gen_writeln(g, _SLIT(""));
		}
	}
	g->indent--;
	v__gen__c__Gen_writeln(g, _SLIT(");"));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_asm_arg(v__gen__c__Gen* g, v__ast__AsmArg arg, v__ast__AsmStmt stmt) {
	if (arg._typ == 429 /* v.ast.AsmAlias */) {
		string name = (*arg._v__ast__AsmAlias).name;
		bool _t1 = (Array_string_contains(stmt.local_labels, name) || Array_string_contains(stmt.global_labels, name) || Array_string_contains(g->file->global_labels, name) || stmt.is_basic);
		Array_string _t3 = __new_array(0, 0, sizeof(string));
		if (!_t1) {
			Array_v__ast__AsmIO _t3_orig = stmt.input;
			int _t3_len = _t3_orig.len;
			_t3 = __new_array(0, _t3_len, sizeof(string));

			for (int _t4 = 0; _t4 < _t3_len; ++_t4) {
				v__ast__AsmIO it = ((v__ast__AsmIO*) _t3_orig.data)[_t4];
				string ti = it.alias;
				array_push((array*)&_t3, &ti);
			}
		}
		bool _t2 = ((!_t1) && !Array_string_contains(_t3, name));
		Array_string _t5 = __new_array(0, 0, sizeof(string));
		if (_t2) {
			Array_v__ast__AsmIO _t5_orig = stmt.output;
			int _t5_len = _t5_orig.len;
			_t5 = __new_array(0, _t5_len, sizeof(string));

			for (int _t6 = 0; _t6 < _t5_len; ++_t6) {
				v__ast__AsmIO it = ((v__ast__AsmIO*) _t5_orig.data)[_t6];
				string ti = it.alias;
				array_push((array*)&_t5, &ti);
			}
		}
		if ( _t1 || ( _t2 && !Array_string_contains(_t5, name))) {
			string asm_formatted_name = (Array_string_contains(stmt.global_labels, name) ? ( str_intp(2, _MOV((StrIntpData[]){{_SLIT("%l["), 0xfe10, {.d_s = name}}, {_SLIT("]"), 0, { .d_c = 0 }}}))) : (name));
			v__gen__c__Gen_write(g, asm_formatted_name);
		} else {
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("%["), 0xfe10, {.d_s = name}}, {_SLIT("]"), 0, { .d_c = 0 }}})));
		}
	}
	else if (arg._typ == 289 /* v.ast.CharLiteral */) {
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("'"), 0xfe10, {.d_s = (*arg._v__ast__CharLiteral).val}}, {_SLIT("'"), 0, { .d_c = 0 }}})));
	}
	else if (arg._typ == 304 /* v.ast.IntegerLiteral */) {
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("$"), 0xfe10, {.d_s = (*arg._v__ast__IntegerLiteral).val}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
	else if (arg._typ == 297 /* v.ast.FloatLiteral */) {
		if (g->pref->nofloat) {
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("$"), 0xfe07, {.d_i32 = string_int((*arg._v__ast__FloatLiteral).val)}}, {_SLIT0, 0, { .d_c = 0 }}})));
		} else {
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("$"), 0xfe10, {.d_s = (*arg._v__ast__FloatLiteral).val}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
	}
	else if (arg._typ == 284 /* v.ast.BoolLiteral */) {
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("$"), 0xfe10, {.d_s = bool_str((*arg._v__ast__BoolLiteral).val)}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
	else if (arg._typ == 354 /* v.ast.AsmRegister */) {
		if (!stmt.is_basic) {
			v__gen__c__Gen_write(g, _SLIT("%"));
		}
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("%"), 0xfe10, {.d_s = (*arg._v__ast__AsmRegister).name}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
	else if (arg._typ == 428 /* v.ast.AsmAddressing */) {
		if (((*arg._v__ast__AsmAddressing).segment).len != 0) {
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("%%"), 0xfe10, {.d_s = (*arg._v__ast__AsmAddressing).segment}}, {_SLIT(":"), 0, { .d_c = 0 }}})));
		}
		v__ast__AsmArg base = (*arg._v__ast__AsmAddressing).base;
		v__ast__AsmArg index = (*arg._v__ast__AsmAddressing).index;
		v__ast__AsmArg displacement = (*arg._v__ast__AsmAddressing).displacement;
		int scale = (*arg._v__ast__AsmAddressing).scale;
		switch ((*arg._v__ast__AsmAddressing).mode) {
			case v__ast__AddressingMode__base: 
				{
					v__gen__c__Gen_write(g, _SLIT("("));
					v__gen__c__Gen_asm_arg(g, base, stmt);
					v__gen__c__Gen_write(g, _SLIT(")"));
				} break;
			case v__ast__AddressingMode__displacement: 
				{
					v__gen__c__Gen_asm_arg(g, displacement, stmt);
				} break;
			case v__ast__AddressingMode__base_plus_displacement: 
				{
					v__gen__c__Gen_asm_arg(g, displacement, stmt);
					v__gen__c__Gen_write(g, _SLIT("("));
					v__gen__c__Gen_asm_arg(g, base, stmt);
					v__gen__c__Gen_write(g, _SLIT(")"));
				} break;
			case v__ast__AddressingMode__index_times_scale_plus_displacement: 
				{
					if ((displacement)._typ == 430 /* v.ast.AsmDisp */) {
						v__gen__c__Gen_asm_arg(g, displacement, stmt);
						v__gen__c__Gen_write(g, _SLIT("(, "));
					} else if ((displacement)._typ == 354 /* v.ast.AsmRegister */) {
						v__gen__c__Gen_write(g, _SLIT("("));
						v__gen__c__Gen_asm_arg(g, displacement, stmt);
						v__gen__c__Gen_write(g, _SLIT(","));
					} else {
						_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("unexpected "), 0xfe10, {.d_s = charptr_vstring_literal( /* v.ast.AsmArg */ v_typeof_sumtype_v__ast__AsmArg( (displacement)._typ ))}}, {_SLIT0, 0, { .d_c = 0 }}})));
						VUNREACHABLE();
					}
					v__gen__c__Gen_asm_arg(g, index, stmt);
					v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(","), 0xfe07, {.d_i32 = scale}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
				} break;
			case v__ast__AddressingMode__base_plus_index_plus_displacement: 
				{
					v__gen__c__Gen_asm_arg(g, displacement, stmt);
					v__gen__c__Gen_write(g, _SLIT("("));
					v__gen__c__Gen_asm_arg(g, base, stmt);
					v__gen__c__Gen_write(g, _SLIT(","));
					v__gen__c__Gen_asm_arg(g, index, stmt);
					v__gen__c__Gen_write(g, _SLIT(",1)"));
				} break;
			case v__ast__AddressingMode__base_plus_index_times_scale_plus_displacement: 
				{
					v__gen__c__Gen_asm_arg(g, displacement, stmt);
					v__gen__c__Gen_write(g, _SLIT("("));
					v__gen__c__Gen_asm_arg(g, base, stmt);
					v__gen__c__Gen_write(g, _SLIT(","));
					v__gen__c__Gen_asm_arg(g, index, stmt);
					v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(","), 0xfe07, {.d_i32 = scale}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
				} break;
			case v__ast__AddressingMode__rip_plus_displacement: 
				{
					v__gen__c__Gen_asm_arg(g, displacement, stmt);
					v__gen__c__Gen_write(g, _SLIT("("));
					v__gen__c__Gen_asm_arg(g, base, stmt);
					v__gen__c__Gen_write(g, _SLIT(")"));
				} break;
			case v__ast__AddressingMode__invalid: 
				{
					v__gen__c__Gen_error(g, _SLIT("invalid addressing mode"), (*arg._v__ast__AsmAddressing).pos);
					VUNREACHABLE();
				} break;
		}
		;
	}
	else if (arg._typ == 430 /* v.ast.AsmDisp */) {
		v__gen__c__Gen_write(g, (*arg._v__ast__AsmDisp).val);
	}
	else if (arg._typ == 20 /* string */) {
		v__gen__c__Gen_write(g, (*arg._string));
	}
	;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_asm_ios(v__gen__c__Gen* g, Array_v__ast__AsmIO ios) {
	for (int i = 0; i < ios.len; ++i) {
		v__ast__AsmIO io = ((v__ast__AsmIO*)ios.data)[i];
		if ((io.alias).len != 0) {
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("["), 0xfe10, {.d_s = io.alias}}, {_SLIT("] "), 0, { .d_c = 0 }}})));
		}
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\""), 0xfe10, {.d_s = io.constraint}}, {_SLIT("\" ("), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_expr(g, io.expr);
		v__gen__c__Gen_write(g, _SLIT(")"));
		if (i + 1 < ios.len) {
			v__gen__c__Gen_writeln(g, _SLIT(","));
		} else {
			v__gen__c__Gen_writeln(g, _SLIT(""));
		}
	}
}

VV_LOCAL_SYMBOL string v__gen__c__cnewlines(string s) {
	string _t1 = string_replace(s, _SLIT("\n"), _SLIT("\\n"));
	return _t1;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_write_fn_ptr_decl(v__gen__c__Gen* g, v__ast__FnType* func, string ptr_name) {
	string ret_styp = v__gen__c__Gen_typ(g, func->func.return_type);
	v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ret_styp}}, {_SLIT(" (*"), 0xfe10, {.d_s = ptr_name}}, {_SLIT(") ("), 0, { .d_c = 0 }}})));
	int arg_len = func->func.params.len;
	for (int i = 0; i < func->func.params.len; ++i) {
		v__ast__Param arg = ((v__ast__Param*)func->func.params.data)[i];
		string arg_styp = v__gen__c__Gen_typ(g, arg.typ);
		v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = arg_styp}}, {_SLIT(" "), 0xfe10, {.d_s = arg.name}}, {_SLIT0, 0, { .d_c = 0 }}})));
		if (i < arg_len - 1) {
			v__gen__c__Gen_write(g, _SLIT(", "));
		}
	}
	v__gen__c__Gen_write(g, _SLIT(")"));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_register_ternary_name(v__gen__c__Gen* g, string name) {
	string level_key = int_str(g->inside_ternary);
	if (!_IN_MAP(ADDR(string, level_key), ADDR(map, g->ternary_level_names))) {
		map_set(&g->ternary_level_names, &(string[]){level_key}, &(Array_string[]) { __new_array_with_default(0, 0, sizeof(string), 0) });
	}
	string new_name = v__gen__c__Gen_new_tmp_var(g);
	map_set(&g->ternary_names, &(string[]){name}, &(string[]) { new_name });
	array_push((array*)&(*(Array_string*)map_get_and_set((map*)&g->ternary_level_names, &(string[]){level_key}, &(Array_string[]){ __new_array(0, 0, sizeof(string)) })), _MOV((string[]){ string_clone(name) }));
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_get_ternary_name(v__gen__c__Gen* g, string name) {
	if (g->inside_ternary == 0) {
		string _t1 = name;
		return _t1;
	}
	if (!_IN_MAP(ADDR(string, name), ADDR(map, g->ternary_names))) {
		string _t2 = name;
		return _t2;
	}
	string _t3 = (*(string*)map_get(ADDR(map, g->ternary_names), &(string[]){name}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} }));
	return _t3;
}

VV_LOCAL_SYMBOL bool v__gen__c__Gen_gen_clone_assignment(v__gen__c__Gen* g, v__ast__Expr val, v__ast__Type typ, bool add_eq) {
	if ((val)._typ != 299 /* v.ast.Ident */ && (val)._typ != 319 /* v.ast.SelectorExpr */) {
		bool _t1 = false;
		return _t1;
	}
	v__ast__TypeSymbol* right_sym = v__ast__Table_sym(g->table, typ);
	if (g->is_autofree) {
		if (add_eq) {
			v__gen__c__Gen_write(g, _SLIT("="));
		}
		if (right_sym->kind == v__ast__Kind__array) {
			string shared_styp = v__gen__c__Gen_typ(g, v__ast__Type_set_nr_muls(typ, 0));
			if (v__ast__Type_share(typ) == v__ast__ShareType__shared_t) {
				v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("("), 0xfe10, {.d_s = shared_styp}}, {_SLIT("*)__dup_shared_array(&("), 0xfe10, {.d_s = shared_styp}}, {_SLIT("){.mtx = {0}, .val ="), 0, { .d_c = 0 }}})));
			}
			v__gen__c__Gen_write(g, _SLIT(" array_clone_static_to_depth("));
			v__gen__c__Gen_expr(g, val);
			if (v__ast__Type_share(typ) == v__ast__ShareType__shared_t) {
				v__gen__c__Gen_write(g, _SLIT("->val"));
			}
			v__ast__Type elem_type = (/* as */ *(v__ast__Array*)__as_cast((right_sym->info)._v__ast__Array,(right_sym->info)._typ, 441) /*expected idx: 441, name: v.ast.Array */ ).elem_type;
			int array_depth = v__gen__c__Gen_get_array_depth(g, elem_type);
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(", "), 0xfe07, {.d_i32 = array_depth}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
			if (v__ast__Type_share(typ) == v__ast__ShareType__shared_t) {
				v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("}, sizeof("), 0xfe10, {.d_s = shared_styp}}, {_SLIT("))"), 0, { .d_c = 0 }}})));
			}
		} else if (right_sym->kind == v__ast__Kind__string) {
			v__gen__c__Gen_write(g, _SLIT(" string_clone_static("));
			v__gen__c__Gen_expr(g, val);
			v__gen__c__Gen_write(g, _SLIT(")"));
		}
	}
	bool _t2 = true;
	return _t2;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_autofree_scope_vars(v__gen__c__Gen* g, int pos, int line_nr, bool free_parent_scopes) {
	v__gen__c__Gen_autofree_scope_vars_stop(g, pos, line_nr, free_parent_scopes, -1);
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_autofree_scope_vars_stop(v__gen__c__Gen* g, int pos, int line_nr, bool free_parent_scopes, int stop_pos) {
	if (g->is_builtin_mod) {
		return;
	}
	if (pos == -1) {
		return;
	}
	v__ast__Scope* scope = v__ast__Scope_innermost(g->file->scope, pos);
	if (scope->start_pos == 0) {
		return;
	}
	;
	v__gen__c__Gen_autofree_scope_vars2(g, scope, scope->start_pos, scope->end_pos, line_nr, free_parent_scopes, stop_pos);
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_autofree_scope_vars2(v__gen__c__Gen* g, v__ast__Scope* scope, int start_pos, int end_pos, int line_nr, bool free_parent_scopes, int stop_pos) {
	if (isnil(scope)) {
		return;
	}
	Map_string_v__ast__ScopeObject _t1 = scope->objects;
	int _t3 = _t1.key_values.len;
	for (int _t2 = 0; _t2 < _t3; ++_t2 ) {
		int _t4 = _t1.key_values.len - _t3;
		_t3 = _t1.key_values.len;
		if (_t4 < 0) {
			_t2 = -1;
			continue;
		}
		if (!DenseArray_has_index(&_t1.key_values, _t2)) {continue;}
		v__ast__ScopeObject obj = (*(v__ast__ScopeObject*)DenseArray_value(&_t1.key_values, _t2));
		if (obj._typ == 357 /* v.ast.Var */) {
			;
			if (string__eq((*obj._v__ast__Var).name, g->returned_var_name)) {
				;
				continue;
			}
			if ((*obj._v__ast__Var).is_or) {
				;
				continue;
			}
			if ((*obj._v__ast__Var).is_tmp) {
				;
				continue;
			}
			if ((*obj._v__ast__Var).is_inherited) {
				;
				continue;
			}
			if ((*obj._v__ast__Var).pos.pos > end_pos || ((*obj._v__ast__Var).pos.pos < start_pos && (*obj._v__ast__Var).pos.line_nr == line_nr)) {
				continue;
			}
			bool is_optional = v__ast__Type_has_flag((*obj._v__ast__Var).typ, v__ast__TypeFlag__optional);
			if (is_optional) {
				continue;
			}
			v__gen__c__Gen_autofree_variable(g, (*obj._v__ast__Var));
		}
		
		else {
		}
		;
	}
	if (free_parent_scopes && !isnil(scope->parent) && !scope->detached_from_parent && (stop_pos == -1 || scope->parent->start_pos >= stop_pos)) {
		;
		v__gen__c__Gen_autofree_scope_vars2(g, scope->parent, start_pos, end_pos, line_nr, true, stop_pos);
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_autofree_variable(v__gen__c__Gen* g, v__ast__Var v) {
	v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, v.typ);
	if (g->is_autofree) {
	}
	string free_fn = string__plus(v__gen__c__Gen_typ(g, v__ast__Type_set_nr_muls(v.typ, 0)), _SLIT("_free"));
	if (sym->kind == v__ast__Kind__array) {
		if (v__ast__TypeSymbol_has_method(sym, _SLIT("free"))) {
			v__gen__c__Gen_autofree_var_call(g, free_fn, v);
			return;
		}
		v__gen__c__Gen_autofree_var_call(g, _SLIT("array_free"), v);
		return;
	}
	if (sym->kind == v__ast__Kind__string) {
		if (v.expr._typ == 323 /* v.ast.StringLiteral */) {
			;
		}
		
		else {
		}
		;
		v__gen__c__Gen_autofree_var_call(g, _SLIT("string_free"), v);
		return;
	}
	if (v__ast__TypeSymbol_has_method(sym, _SLIT("free"))) {
		v__gen__c__Gen_autofree_var_call(g, free_fn, v);
	} else if (g->pref->experimental && v__ast__Type_is_ptr(v.typ) && byte_is_capital(string_at(string_after(sym->name, _SLIT(".")), 0))) {
		v__gen__c__Gen_autofree_var_call(g, _SLIT("free"), v);
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_autofree_var_call(v__gen__c__Gen* g, string free_fn_name, v__ast__Var v) {
	if (v.is_arg) {
		return;
	}
	if (v.is_used && v.is_autofree_tmp) {
		return;
	}
	if (g->is_builtin_mod) {
		return;
	}
	if (!g->is_autofree) {
		return;
	}
	if (string_contains(v.name, _SLIT("expr_write_string_1_"))) {
		return;
	}
	if (v__ast__Type_is_ptr(v.typ)) {
		v__gen__c__Gen_write(g, _SLIT("\t"));
		if (v__ast__Type_share(v.typ) == v__ast__ShareType__shared_t) {
			v__gen__c__Gen_write(g, string_replace_each(free_fn_name, new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT("__shared__"), _SLIT("")}))));
		} else {
			v__gen__c__Gen_write(g, free_fn_name);
		}
		v__gen__c__Gen_write(g, _SLIT("("));
		if (v__ast__Type_share(v.typ) == v__ast__ShareType__shared_t) {
			v__gen__c__Gen_write(g, _SLIT("&"));
		}
		v__gen__c__Gen_write(g, strings__repeat('*', v__ast__Type_nr_muls(v.typ) - 1));
		v__gen__c__Gen_write(g, v__gen__c__c_name(v.name));
		if (v__ast__Type_share(v.typ) == v__ast__ShareType__shared_t) {
			v__gen__c__Gen_write(g, _SLIT("->val"));
		}
		v__gen__c__Gen_writeln(g, _SLIT("); // autofreed ptr var"));
	} else {
		if (v__ast__Type_alias_eq(v.typ, _const_v__ast__error_type) && !v.is_autofree_tmp) {
			return;
		}
		v__gen__c__Gen_writeln(g,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = free_fn_name}}, {_SLIT("(&"), 0xfe10, {.d_s = v__gen__c__c_name(v.name)}}, {_SLIT("); // autofreed var "), 0xfe10, {.d_s = g->cur_mod.name}}, {_SLIT(" "), 0xfe10, {.d_s = g->is_builtin_mod ? _SLIT("true") : _SLIT("false")}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
}

VV_LOCAL_SYMBOL multi_return_string_string_string_string v__gen__c__Gen_map_fn_ptrs(v__gen__c__Gen* g, v__ast__TypeSymbol key_typ) {
	string hash_fn = _SLIT("");
	string key_eq_fn = _SLIT("");
	string clone_fn = _SLIT("");
	string free_fn = _SLIT("&map_free_nop");
	switch (key_typ.kind) {
		case v__ast__Kind__byte: 
		case v__ast__Kind__i8: 
		case v__ast__Kind__char: 
			{
				hash_fn = _SLIT("&map_hash_int_1");
				key_eq_fn = _SLIT("&map_eq_int_1");
				clone_fn = _SLIT("&map_clone_int_1");
			} break;
		case v__ast__Kind__i16: 
		case v__ast__Kind__u16: 
			{
				hash_fn = _SLIT("&map_hash_int_2");
				key_eq_fn = _SLIT("&map_eq_int_2");
				clone_fn = _SLIT("&map_clone_int_2");
			} break;
		case v__ast__Kind__int: 
		case v__ast__Kind__u32: 
		case v__ast__Kind__rune: 
		case v__ast__Kind__f32: 
		case v__ast__Kind__enum_: 
			{
				hash_fn = _SLIT("&map_hash_int_4");
				key_eq_fn = _SLIT("&map_eq_int_4");
				clone_fn = _SLIT("&map_clone_int_4");
			} break;
		case v__ast__Kind__voidptr: 
			{
				v__ast__TypeSymbol* ts = (g->pref->m64 ? (v__ast__Table_sym_by_idx(g->table, _const_v__ast__u64_type_idx)) : (v__ast__Table_sym_by_idx(g->table, _const_v__ast__u32_type_idx)));
				multi_return_string_string_string_string _t1 = v__gen__c__Gen_map_fn_ptrs(g, *ts);
				return _t1;
			} break;
		case v__ast__Kind__u64: 
		case v__ast__Kind__i64: 
		case v__ast__Kind__f64: 
			{
				hash_fn = _SLIT("&map_hash_int_8");
				key_eq_fn = _SLIT("&map_eq_int_8");
				clone_fn = _SLIT("&map_clone_int_8");
			} break;
		case v__ast__Kind__string: 
			{
				hash_fn = _SLIT("&map_hash_string");
				key_eq_fn = _SLIT("&map_eq_string");
				clone_fn = _SLIT("&map_clone_string");
				free_fn = _SLIT("&map_free_string");
			} break;
		case v__ast__Kind__placeholder:
		case v__ast__Kind__void:
		case v__ast__Kind__byteptr:
		case v__ast__Kind__charptr:
		case v__ast__Kind__isize:
		case v__ast__Kind__u8:
		case v__ast__Kind__usize:
		case v__ast__Kind__bool:
		case v__ast__Kind__none_:
		case v__ast__Kind__array:
		case v__ast__Kind__array_fixed:
		case v__ast__Kind__map:
		case v__ast__Kind__chan:
		case v__ast__Kind__any:
		case v__ast__Kind__struct_:
		case v__ast__Kind__generic_inst:
		case v__ast__Kind__multi_return:
		case v__ast__Kind__sum_type:
		case v__ast__Kind__alias:
		case v__ast__Kind__function:
		case v__ast__Kind__interface_:
		case v__ast__Kind__float_literal:
		case v__ast__Kind__int_literal:
		case v__ast__Kind__aggregate:
		case v__ast__Kind__thread:
		default:
			{
				v__gen__c__verror(_SLIT("map key type not supported"));
				VUNREACHABLE();
			} break;
	}
	;
	return (multi_return_string_string_string_string){.arg0=hash_fn, .arg1=key_eq_fn, .arg2=clone_fn, .arg3=free_fn};
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_expr(v__gen__c__Gen* g, v__ast__Expr node) {
	bool old_discard_or_result = g->discard_or_result;
	bool old_is_void_expr_stmt = g->is_void_expr_stmt;
	if (g->is_void_expr_stmt) {
		g->discard_or_result = true;
		g->is_void_expr_stmt = false;
	} else {
		g->discard_or_result = false;
	}
	if (node._typ == 295 /* v.ast.EmptyExpr */) {
		v__gen__c__Gen_error(g, _SLIT("g.expr(): unhandled EmptyExpr"), (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,});
		VUNREACHABLE();
	}
	else if (node._typ == 278 /* v.ast.AnonFn */) {
		v__gen__c__Gen_gen_anon_fn(g, (voidptr)&/*qq*/(*node._v__ast__AnonFn));
	}
	else if (node._typ == 279 /* v.ast.ArrayDecompose */) {
		v__gen__c__Gen_expr(g, (*node._v__ast__ArrayDecompose).expr);
	}
	else if (node._typ == 280 /* v.ast.ArrayInit */) {
		v__gen__c__Gen_array_init(g, (*node._v__ast__ArrayInit));
	}
	else if (node._typ == 281 /* v.ast.AsCast */) {
		v__gen__c__Gen_as_cast(g, (*node._v__ast__AsCast));
	}
	else if (node._typ == 282 /* v.ast.Assoc */) {
		v__gen__c__Gen_assoc(g, (*node._v__ast__Assoc));
	}
	else if (node._typ == 283 /* v.ast.AtExpr */) {
		v__gen__c__Gen_comptime_at(g, (*node._v__ast__AtExpr));
	}
	else if (node._typ == 284 /* v.ast.BoolLiteral */) {
		v__gen__c__Gen_write(g, bool_str((*node._v__ast__BoolLiteral).val));
	}
	else if (node._typ == 286 /* v.ast.CallExpr */) {
		v__ast__Type ret_type = ((*node._v__ast__CallExpr).or_block.kind == v__ast__OrKind__absent ? ((*node._v__ast__CallExpr).return_type) : (v__ast__Type_clear_flag((*node._v__ast__CallExpr).return_type, v__ast__TypeFlag__optional)));
		string shared_styp = _SLIT("");
		if (g->is_shared && !v__ast__Type_has_flag(ret_type, v__ast__TypeFlag__shared_f)) {
			v__ast__TypeSymbol* ret_sym = v__ast__Table_sym(g->table, ret_type);
			v__ast__Type shared_typ = v__ast__Type_set_flag(ret_type, v__ast__TypeFlag__shared_f);
			shared_styp = v__gen__c__Gen_typ(g, shared_typ);
			if (ret_sym->kind == v__ast__Kind__array) {
				v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("("), 0xfe10, {.d_s = shared_styp}}, {_SLIT("*)__dup_shared_array(&("), 0xfe10, {.d_s = shared_styp}}, {_SLIT("){.mtx = {0}, .val ="), 0, { .d_c = 0 }}})));
			} else if (ret_sym->kind == v__ast__Kind__map) {
				v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("("), 0xfe10, {.d_s = shared_styp}}, {_SLIT("*)__dup_shared_map(&("), 0xfe10, {.d_s = shared_styp}}, {_SLIT("){.mtx = {0}, .val ="), 0, { .d_c = 0 }}})));
			} else {
				v__gen__c__Gen_writeln(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("("), 0xfe10, {.d_s = shared_styp}}, {_SLIT("*)__dup"), 0xfe10, {.d_s = shared_styp}}, {_SLIT("(&("), 0xfe10, {.d_s = shared_styp}}, {_SLIT("){.mtx = {0}, .val ="), 0, { .d_c = 0 }}})));
			}
		}
		int last_stmt_pos = (*(int*)array_last(g->stmt_path_pos));
		v__gen__c__Gen_call_expr(g, (*node._v__ast__CallExpr));
		if (g->is_autofree && !g->is_builtin_mod && !g->is_js_call && g->strs_to_free0.len == 0 && !g->inside_lambda) {
			v__gen__c__Gen_autofree_call_pregen(g, (*node._v__ast__CallExpr));
			if (g->strs_to_free0.len > 0) {
				v__gen__c__Gen_insert_at(g, last_stmt_pos, string__plus(Array_string_join(g->strs_to_free0, _SLIT("\n")), _SLIT("/* inserted before */")));
			}
			g->strs_to_free0 = __new_array_with_default(0, 0, sizeof(string), 0);
		}
		if (g->is_shared && !v__ast__Type_has_flag(ret_type, v__ast__TypeFlag__shared_f)) {
			v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("}, sizeof("), 0xfe10, {.d_s = shared_styp}}, {_SLIT("))"), 0, { .d_c = 0 }}})));
		}
	}
	else if (node._typ == 287 /* v.ast.CastExpr */) {
		v__gen__c__Gen_cast_expr(g, (*node._v__ast__CastExpr));
	}
	else if (node._typ == 288 /* v.ast.ChanInit */) {
		string elem_typ_str = v__gen__c__Gen_typ(g, (*node._v__ast__ChanInit).elem_type);
		string noscan = v__gen__c__Gen_check_noscan(g, (*node._v__ast__ChanInit).elem_type);
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("sync__new_channel_st"), 0xfe10, {.d_s = noscan}}, {_SLIT("("), 0, { .d_c = 0 }}})));
		if ((*node._v__ast__ChanInit).has_cap) {
			v__gen__c__Gen_expr(g, (*node._v__ast__ChanInit).cap_expr);
		} else {
			v__gen__c__Gen_write(g, _SLIT("0"));
		}
		v__gen__c__Gen_write(g, _SLIT(", sizeof("));
		v__gen__c__Gen_write(g, elem_typ_str);
		v__gen__c__Gen_write(g, _SLIT("))"));
	}
	else if (node._typ == 289 /* v.ast.CharLiteral */) {
		if (string__eq((*node._v__ast__CharLiteral).val, _SLIT("\\`"))) {
			v__gen__c__Gen_write(g, _SLIT("'`'"));
		} else {
			if (utf8_str_len((*node._v__ast__CharLiteral).val) < (*node._v__ast__CharLiteral).val.len) {
				v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("((rune)0x"), 0xfe10, {.d_s = int_hex(string_utf32_code((*node._v__ast__CharLiteral).val))}}, {_SLIT(" /* `"), 0xfe10, {.d_s = (*node._v__ast__CharLiteral).val}}, {_SLIT("` */)"), 0, { .d_c = 0 }}})));
			} else {
				v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("'"), 0xfe10, {.d_s = (*node._v__ast__CharLiteral).val}}, {_SLIT("'"), 0, { .d_c = 0 }}})));
			}
		}
	}
	else if (node._typ == 290 /* v.ast.Comment */) {
	}
	else if (node._typ == 291 /* v.ast.ComptimeCall */) {
		v__gen__c__Gen_comptime_call(g, (voidptr)&/*qq*/(*node._v__ast__ComptimeCall));
	}
	else if (node._typ == 292 /* v.ast.ComptimeSelector */) {
		v__gen__c__Gen_comptime_selector(g, (*node._v__ast__ComptimeSelector));
	}
	else if (node._typ == 293 /* v.ast.ConcatExpr */) {
		v__gen__c__Gen_concat_expr(g, (*node._v__ast__ConcatExpr));
	}
	else if (node._typ == 285 /* v.ast.CTempVar */) {
		v__gen__c__Gen_write(g, (*node._v__ast__CTempVar).name);
	}
	else if (node._typ == 294 /* v.ast.DumpExpr */) {
		v__gen__c__Gen_dump_expr(g, (*node._v__ast__DumpExpr));
	}
	else if (node._typ == 296 /* v.ast.EnumVal */) {
		string styp = v__gen__c__Gen_typ(g, v__ast__Table_unaliased_type(g->table, (*node._v__ast__EnumVal).typ));
		v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = styp}}, {_SLIT("__"), 0xfe10, {.d_s = (*node._v__ast__EnumVal).val}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
	else if (node._typ == 297 /* v.ast.FloatLiteral */) {
		if (g->pref->nofloat) {
			v__gen__c__Gen_write(g, int_str(string_int((*node._v__ast__FloatLiteral).val)));
		} else {
			v__gen__c__Gen_write(g, (*node._v__ast__FloatLiteral).val);
		}
	}
	else if (node._typ == 298 /* v.ast.GoExpr */) {
		v__gen__c__Gen_go_expr(g, (*node._v__ast__GoExpr));
	}
	else if (node._typ == 299 /* v.ast.Ident */) {
		v__gen__c__Gen_ident(g, (*node._v__ast__Ident));
	}
	else if (node._typ == 300 /* v.ast.IfExpr */) {
		v__gen__c__Gen_if_expr(g, (*node._v__ast__IfExpr));
	}
	else if (node._typ == 301 /* v.ast.IfGuardExpr */) {
		v__gen__c__Gen_write(g, _SLIT("/* guard */"));
	}
	else if (node._typ == 302 /* v.ast.IndexExpr */) {
		v__gen__c__Gen_index_expr(g, (*node._v__ast__IndexExpr));
	}
	else if (node._typ == 303 /* v.ast.InfixExpr */) {
		if ((*node._v__ast__InfixExpr).op == v__token__Kind__left_shift || (*node._v__ast__InfixExpr).op == v__token__Kind__plus_assign || (*node._v__ast__InfixExpr).op == v__token__Kind__minus_assign) {
			g->inside_map_infix = true;
			v__gen__c__Gen_infix_expr(g, (*node._v__ast__InfixExpr));
			g->inside_map_infix = false;
		} else {
			v__gen__c__Gen_infix_expr(g, (*node._v__ast__InfixExpr));
		}
	}
	else if (node._typ == 304 /* v.ast.IntegerLiteral */) {
		if (string_starts_with((*node._v__ast__IntegerLiteral).val, _SLIT("0o"))) {
			v__gen__c__Gen_write(g, _SLIT("0"));
			v__gen__c__Gen_write(g, string_substr((*node._v__ast__IntegerLiteral).val, 2, (*node._v__ast__IntegerLiteral).val.len));
		} else if (string_starts_with((*node._v__ast__IntegerLiteral).val, _SLIT("-0o"))) {
			v__gen__c__Gen_write(g, _SLIT("-0"));
			v__gen__c__Gen_write(g, string_substr((*node._v__ast__IntegerLiteral).val, 3, (*node._v__ast__IntegerLiteral).val.len));
		} else {
			v__gen__c__Gen_write(g, (*node._v__ast__IntegerLiteral).val);
		}
	}
	else if (node._typ == 305 /* v.ast.IsRefType */) {
		v__ast__Type typ = (v__ast__Type_alias_eq((*node._v__ast__IsRefType).typ, g->field_data_type) ? (g->comptime_for_field_value.typ) : ((*node._v__ast__IsRefType).typ));
		v__ast__Type node_typ = v__gen__c__Gen_unwrap_generic(g, typ);
		v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, node_typ);
		if (sym->language == v__ast__Language__v && (sym->kind == v__ast__Kind__placeholder || sym->kind == v__ast__Kind__any)) {
			v__gen__c__Gen_error(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unknown type `"), 0xfe10, {.d_s = sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), (*node._v__ast__IsRefType).pos);
			VUNREACHABLE();
		}
		bool is_ref_type = v__gen__c__Gen_contains_ptr(g, node_typ);
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("/*IsRefType*/ "), 0xfe10, {.d_s = is_ref_type ? _SLIT("true") : _SLIT("false")}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
	else if (node._typ == 306 /* v.ast.Likely */) {
		if ((*node._v__ast__Likely).is_likely) {
			v__gen__c__Gen_write(g, _SLIT("_likely_"));
		} else {
			v__gen__c__Gen_write(g, _SLIT("_unlikely_"));
		}
		v__gen__c__Gen_write(g, _SLIT("("));
		v__gen__c__Gen_expr(g, (*node._v__ast__Likely).expr);
		v__gen__c__Gen_write(g, _SLIT(")"));
	}
	else if (node._typ == 307 /* v.ast.LockExpr */) {
		v__gen__c__Gen_lock_expr(g, (*node._v__ast__LockExpr));
	}
	else if (node._typ == 308 /* v.ast.MapInit */) {
		v__gen__c__Gen_map_init(g, (*node._v__ast__MapInit));
	}
	else if (node._typ == 309 /* v.ast.MatchExpr */) {
		v__gen__c__Gen_match_expr(g, (*node._v__ast__MatchExpr));
	}
	else if (node._typ == 310 /* v.ast.NodeError */) {
	}
	else if (node._typ == 311 /* v.ast.None */) {
		v__gen__c__Gen_write(g, _SLIT("_const_none__"));
	}
	else if (node._typ == 312 /* v.ast.OffsetOf */) {
		string styp = v__gen__c__Gen_typ(g, (*node._v__ast__OffsetOf).struct_type);
		v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("/*OffsetOf*/ (u32)(__offsetof("), 0xfe10, {.d_s = v__util__no_dots(styp)}}, {_SLIT(", "), 0xfe10, {.d_s = (*node._v__ast__OffsetOf).field}}, {_SLIT("))"), 0, { .d_c = 0 }}})));
	}
	else if (node._typ == 313 /* v.ast.OrExpr */) {
	}
	else if (node._typ == 314 /* v.ast.ParExpr */) {
		v__gen__c__Gen_write(g, _SLIT("("));
		v__gen__c__Gen_expr(g, (*node._v__ast__ParExpr).expr);
		v__gen__c__Gen_write(g, _SLIT(")"));
	}
	else if (node._typ == 315 /* v.ast.PostfixExpr */) {
		if (((*node._v__ast__PostfixExpr).auto_locked).len != 0) {
			v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("sync__RwMutex_lock(&"), 0xfe10, {.d_s = (*node._v__ast__PostfixExpr).auto_locked}}, {_SLIT("->mtx);"), 0, { .d_c = 0 }}})));
		}
		g->inside_map_postfix = true;
		if (v__ast__Expr_is_auto_deref_var((*node._v__ast__PostfixExpr).expr)) {
			v__gen__c__Gen_write(g, _SLIT("(*"));
			v__gen__c__Gen_expr(g, (*node._v__ast__PostfixExpr).expr);
			v__gen__c__Gen_write(g, _SLIT(")"));
		} else {
			v__gen__c__Gen_expr(g, (*node._v__ast__PostfixExpr).expr);
		}
		g->inside_map_postfix = false;
		v__gen__c__Gen_write(g, v__token__Kind_str((*node._v__ast__PostfixExpr).op));
		if (((*node._v__ast__PostfixExpr).auto_locked).len != 0) {
			v__gen__c__Gen_writeln(g, _SLIT(";"));
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("sync__RwMutex_unlock(&"), 0xfe10, {.d_s = (*node._v__ast__PostfixExpr).auto_locked}}, {_SLIT("->mtx)"), 0, { .d_c = 0 }}})));
		}
	}
	else if (node._typ == 316 /* v.ast.PrefixExpr */) {
		bool gen_or = (*node._v__ast__PrefixExpr).op == v__token__Kind__arrow && ((*node._v__ast__PrefixExpr).or_block.kind != v__ast__OrKind__absent || (*node._v__ast__PrefixExpr).is_option);
		if ((*node._v__ast__PrefixExpr).op == v__token__Kind__amp) {
			g->is_amp = true;
		}
		if ((*node._v__ast__PrefixExpr).op == v__token__Kind__arrow) {
			string styp = v__gen__c__Gen_typ(g, (*node._v__ast__PrefixExpr).right_type);
			v__ast__TypeSymbol* right_sym = v__ast__Table_sym(g->table, (*node._v__ast__PrefixExpr).right_type);
			v__ast__Chan right_inf = /* as */ *(v__ast__Chan*)__as_cast((right_sym->info)._v__ast__Chan,(right_sym->info)._typ, 469) /*expected idx: 469, name: v.ast.Chan */ ;
			v__ast__Type elem_type = right_inf.elem_type;
			bool is_gen_or_and_assign_rhs = gen_or && !g->discard_or_result;
			string _t1; /* if prepend */
			if (is_gen_or_and_assign_rhs) {
				string line = v__gen__c__Gen_go_before_stmt(g, 0);
				strings__Builder_write_string(&g->out, v__util__tabs(g->indent));
				_t1 = line;
			} else {
				_t1 = _SLIT("");
			}
			string cur_line =  _t1;
			string tmp_opt = (gen_or ? (v__gen__c__Gen_new_tmp_var(g)) : (_SLIT("")));
			if (gen_or) {
				string opt_elem_type = v__gen__c__Gen_typ(g, v__ast__Type_set_flag(elem_type, v__ast__TypeFlag__optional));
				v__gen__c__Gen_register_chan_pop_optional_call(g, opt_elem_type, styp);
				v__gen__c__Gen_write(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = opt_elem_type}}, {_SLIT(" "), 0xfe10, {.d_s = tmp_opt}}, {_SLIT(" = __Option_"), 0xfe10, {.d_s = styp}}, {_SLIT("_popval("), 0, { .d_c = 0 }}})));
			} else {
				v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("__"), 0xfe10, {.d_s = styp}}, {_SLIT("_popval("), 0, { .d_c = 0 }}})));
			}
			v__gen__c__Gen_expr(g, (*node._v__ast__PrefixExpr).right);
			v__gen__c__Gen_write(g, _SLIT(")"));
			if (gen_or) {
				if (!(*node._v__ast__PrefixExpr).is_option) {
					v__gen__c__Gen_or_block(g, tmp_opt, (*node._v__ast__PrefixExpr).or_block, elem_type);
				}
				if (is_gen_or_and_assign_rhs) {
					string elem_styp = v__gen__c__Gen_typ(g, elem_type);
					v__gen__c__Gen_write(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT(";\n"), 0xfe10, {.d_s = cur_line}}, {_SLIT("*("), 0xfe10, {.d_s = elem_styp}}, {_SLIT("*)"), 0xfe10, {.d_s = tmp_opt}}, {_SLIT(".data"), 0, { .d_c = 0 }}})));
				}
			}
		} else {
			if (!(g->is_amp && v__ast__Expr_is_auto_deref_var((*node._v__ast__PrefixExpr).right))) {
				v__gen__c__Gen_write(g, v__token__Kind_str((*node._v__ast__PrefixExpr).op));
			}
			v__gen__c__Gen_expr(g, (*node._v__ast__PrefixExpr).right);
		}
		g->is_amp = false;
	}
	else if (node._typ == 317 /* v.ast.RangeExpr */) {
	}
	else if (node._typ == 318 /* v.ast.SelectExpr */) {
		v__gen__c__Gen_select_expr(g, (*node._v__ast__SelectExpr));
	}
	else if (node._typ == 319 /* v.ast.SelectorExpr */) {
		v__gen__c__Gen_selector_expr(g, (*node._v__ast__SelectorExpr));
	}
	else if (node._typ == 320 /* v.ast.SizeOf */) {
		v__gen__c__Gen_size_of(g, (*node._v__ast__SizeOf));
	}
	else if (node._typ == 321 /* v.ast.SqlExpr */) {
		v__gen__c__Gen_sql_select_expr(g, (*node._v__ast__SqlExpr));
	}
	else if (node._typ == 323 /* v.ast.StringLiteral */) {
		v__gen__c__Gen_string_literal(g, (*node._v__ast__StringLiteral));
	}
	else if (node._typ == 322 /* v.ast.StringInterLiteral */) {
		v__gen__c__Gen_string_inter_literal(g, (*node._v__ast__StringInterLiteral));
	}
	else if (node._typ == 324 /* v.ast.StructInit */) {
		if ((*node._v__ast__StructInit).unresolved) {
			v__gen__c__Gen_expr(g, v__ast__resolve_init((*node._v__ast__StructInit), v__gen__c__Gen_unwrap_generic(g, (*node._v__ast__StructInit).typ), g->table));
		} else {
			v__gen__c__Gen_struct_init(g, (*node._v__ast__StructInit));
		}
	}
	else if (node._typ == 325 /* v.ast.TypeNode */) {
		v__ast__Type typ = v__gen__c__Gen_unwrap_generic(g, (*node._v__ast__TypeNode).typ);
		v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, typ);
		string sidx = v__gen__c__Gen_type_sidx(g, typ);
		v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = sidx}}, {_SLIT(" /* "), 0xfe10, {.d_s = sym->name}}, {_SLIT(" */"), 0, { .d_c = 0 }}})));
	}
	else if (node._typ == 326 /* v.ast.TypeOf */) {
		v__gen__c__Gen_typeof_expr(g, (*node._v__ast__TypeOf));
	}
	else if (node._typ == 327 /* v.ast.UnsafeExpr */) {
		v__gen__c__Gen_expr(g, (*node._v__ast__UnsafeExpr).expr);
	}
	;
	g->discard_or_result = old_discard_or_result;
	g->is_void_expr_stmt = old_is_void_expr_stmt;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_type_name(v__gen__c__Gen* g, v__ast__Type raw_type) {
	v__ast__Type typ = (v__ast__Type_alias_eq(raw_type, g->field_data_type) ? (g->comptime_for_field_value.typ) : (raw_type));
	v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, typ);
	string s = _SLIT("");
	if (sym->kind == v__ast__Kind__function) {
		if (v__ast__Type_is_ptr(typ)) {
			s = string__plus(_SLIT("&"), v__gen__c__Gen_fn_decl_str(g, /* as */ *(v__ast__FnType*)__as_cast((sym->info)._v__ast__FnType,(sym->info)._typ, 472) /*expected idx: 472, name: v.ast.FnType */ ));
		} else {
			s = v__gen__c__Gen_fn_decl_str(g, /* as */ *(v__ast__FnType*)__as_cast((sym->info)._v__ast__FnType,(sym->info)._typ, 472) /*expected idx: 472, name: v.ast.FnType */ );
		}
	} else {
		s = v__ast__Table_type_to_str(g->table, v__gen__c__Gen_unwrap_generic(g, typ));
	}
	v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("_SLIT(\""), 0xfe10, {.d_s = v__util__strip_main_name(s)}}, {_SLIT("\")"), 0, { .d_c = 0 }}})));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_typeof_expr(v__gen__c__Gen* g, v__ast__TypeOf node) {
	v__ast__Type typ = (v__ast__Type_alias_eq(node.expr_type, g->field_data_type) ? (g->comptime_for_field_value.typ) : (node.expr_type));
	v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, typ);
	if (sym->kind == v__ast__Kind__sum_type) {
		v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("charptr_vstring_literal( /* "), 0xfe10, {.d_s = sym->name}}, {_SLIT(" */ v_typeof_sumtype_"), 0xfe10, {.d_s = sym->cname}}, {_SLIT("( ("), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_expr(g, node.expr);
		v__gen__c__Gen_write(g, _SLIT(")._typ ))"));
	} else if (sym->kind == v__ast__Kind__array_fixed) {
		v__ast__ArrayFixed fixed_info = /* as */ *(v__ast__ArrayFixed*)__as_cast((sym->info)._v__ast__ArrayFixed,(sym->info)._typ, 468) /*expected idx: 468, name: v.ast.ArrayFixed */ ;
		string typ_name = v__ast__Table_get_type_name(g->table, fixed_info.elem_type);
		v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("_SLIT(\"["), 0xfe07, {.d_i32 = fixed_info.size}}, {_SLIT("]"), 0xfe10, {.d_s = v__util__strip_main_name(typ_name)}}, {_SLIT("\")"), 0, { .d_c = 0 }}})));
	} else if (sym->kind == v__ast__Kind__function) {
		v__ast__FnType info = /* as */ *(v__ast__FnType*)__as_cast((sym->info)._v__ast__FnType,(sym->info)._typ, 472) /*expected idx: 472, name: v.ast.FnType */ ;
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("_SLIT(\""), 0xfe10, {.d_s = v__gen__c__Gen_fn_decl_str(g, info)}}, {_SLIT("\")"), 0, { .d_c = 0 }}})));
	} else if (v__ast__Type_has_flag(typ, v__ast__TypeFlag__variadic)) {
		v__ast__TypeSymbol* varg_elem_type_sym = v__ast__Table_sym(g->table, v__ast__Table_value_type(g->table, typ));
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("_SLIT(\"..."), 0xfe10, {.d_s = v__util__strip_main_name(varg_elem_type_sym->name)}}, {_SLIT("\")"), 0, { .d_c = 0 }}})));
	} else {
		string x = v__ast__Table_type_to_str(g->table, typ);
		string y = v__util__strip_main_name(x);
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("_SLIT(\""), 0xfe10, {.d_s = y}}, {_SLIT("\")"), 0, { .d_c = 0 }}})));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_selector_expr(v__gen__c__Gen* g, v__ast__SelectorExpr node) {
	bool prevent_sum_type_unwrapping_once = g->prevent_sum_type_unwrapping_once;
	g->prevent_sum_type_unwrapping_once = false;
	if (node.name_type > 0) {

		if (node.gkind_field == (v__ast__GenericKindField__name)) {
			v__gen__c__Gen_type_name(g, node.name_type);
			return;
		}
		else if (node.gkind_field == (v__ast__GenericKindField__typ)) {
			v__gen__c__Gen_write(g, int_str(((int)(v__gen__c__Gen_unwrap_generic(g, node.name_type)))));
			return;
		}
		else if (node.gkind_field == (v__ast__GenericKindField__unknown)) {
			if (string__eq(node.field_name, _SLIT("name"))) {
				v__ast__Type name_type = node.name_type;
				if ((node.expr)._typ == 326 /* v.ast.TypeOf */) {
					if (((*node.expr._v__ast__TypeOf).expr)._typ == 292 /* v.ast.ComptimeSelector */) {
						if (((*(*node.expr._v__ast__TypeOf).expr._v__ast__ComptimeSelector).field_expr)._typ == 319 /* v.ast.SelectorExpr */) {
							if (((*(*(*node.expr._v__ast__TypeOf).expr._v__ast__ComptimeSelector).field_expr._v__ast__SelectorExpr).expr)._typ == 299 /* v.ast.Ident */) {
								string key_str =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = (*(*(*(*node.expr._v__ast__TypeOf).expr._v__ast__ComptimeSelector).field_expr._v__ast__SelectorExpr).expr._v__ast__Ident).name}}, {_SLIT(".typ"), 0, { .d_c = 0 }}}));
								v__ast__Type* _t2 = (v__ast__Type*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, g->comptime_var_type_map), &(string[]){key_str}));
								Option_v__ast__Type _t1 = {0};
								if (_t2) {
									*((v__ast__Type*)&_t1.data) = *((v__ast__Type*)_t2);
								} else {
									_t1.state = 2; _t1.err = _v_error(_SLIT("array index out of range"));
								}
								;
								if (_t1.state != 0) { /*or block*/ 
									IError err = _t1.err;
									*(v__ast__Type*) _t1.data = name_type;
								}
								
								name_type = *(v__ast__Type*)_t1.data;
							}
						}
					}
				}
				v__gen__c__Gen_type_name(g, name_type);
				return;
			} else if (string__eq(node.field_name, _SLIT("idx"))) {
				v__gen__c__Gen_write(g, int_str(((int)(v__gen__c__Gen_unwrap_generic(g, node.name_type)))));
				return;
			}
			v__gen__c__Gen_error(g, _SLIT("unknown generic field"), node.pos);
			VUNREACHABLE();
		};
	}
	if (node.expr_type == 0) {
		v__gen__c__Gen_checker_bug(g, _SLIT("unexpected SelectorExpr.expr_type = 0"), node.pos);
	}
	v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, v__gen__c__Gen_unwrap_generic(g, node.expr_type));
	bool is_optional = (node.expr)._typ == 299 /* v.ast.Ident */ && v__ast__Type_has_flag(node.expr_type, v__ast__TypeFlag__optional);
	if (is_optional) {
		string opt_base_typ = v__gen__c__Gen_base_type(g, node.expr_type);
		v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("(*("), 0xfe10, {.d_s = opt_base_typ}}, {_SLIT("*)"), 0, { .d_c = 0 }}})));
	}
	if (sym->kind == v__ast__Kind__interface_ || sym->kind == v__ast__Kind__sum_type) {
		v__gen__c__Gen_write(g, _SLIT("(*("));
	}
	if (sym->kind == v__ast__Kind__array_fixed) {
		if (!string__eq(node.field_name, _SLIT("len"))) {
			v__gen__c__Gen_error(g, _SLIT("field_name should be `len`"), node.pos);
			VUNREACHABLE();
		}
		v__ast__ArrayFixed info = /* as */ *(v__ast__ArrayFixed*)__as_cast((sym->info)._v__ast__ArrayFixed,(sym->info)._typ, 468) /*expected idx: 468, name: v.ast.ArrayFixed */ ;
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = info.size}}, {_SLIT0, 0, { .d_c = 0 }}})));
		return;
	}
	if (sym->kind == v__ast__Kind__chan && (string__eq(node.field_name, _SLIT("len")) || string__eq(node.field_name, _SLIT("closed")))) {
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("sync__Channel_"), 0xfe10, {.d_s = node.field_name}}, {_SLIT("("), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_expr(g, node.expr);
		v__gen__c__Gen_write(g, _SLIT(")"));
		return;
	}
	string sum_type_deref_field = _SLIT("");
	string sum_type_dot = _SLIT(".");
	Option_v__ast__StructField _t3;
	if (_t3 = v__ast__Table_find_field(g->table, sym, node.field_name), _t3.state == 0) {
		v__ast__StructField f = *(v__ast__StructField*)_t3.data;
		v__ast__TypeSymbol* field_sym = v__ast__Table_sym(g->table, f.typ);
		if (field_sym->kind == v__ast__Kind__sum_type || field_sym->kind == v__ast__Kind__interface_) {
			if (!prevent_sum_type_unwrapping_once) {
				v__ast__Scope* scope = v__ast__Scope_innermost(g->file->scope, node.pos.pos);
				Option_v__ast__ScopeStructField _t4;
				if (_t4 = v__ast__Scope_find_struct_field(scope, v__ast__Expr_str(node.expr), node.expr_type, node.field_name), _t4.state == 0) {
					v__ast__ScopeStructField field = *(v__ast__ScopeStructField*)_t4.data;
					if (v__ast__Type_is_ptr(field.orig_type)) {
						sum_type_dot = _SLIT("->");
					}
					for (int i = 0; i < field.smartcasts.len; ++i) {
						v__ast__Type typ = ((v__ast__Type*)field.smartcasts.data)[i];
						v__gen__c__Gen_write(g, _SLIT("("));
						if (field_sym->kind == v__ast__Kind__sum_type) {
							v__gen__c__Gen_write(g, _SLIT("*"));
						}
						v__ast__TypeSymbol* cast_sym = v__ast__Table_sym(g->table, typ);
						if (i != 0) {
							string dot = (v__ast__Type_is_ptr(field.typ) ? (_SLIT("->")) : (_SLIT(".")));
							sum_type_deref_field = /*f*/string__plus(sum_type_deref_field,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(")"), 0xfe10, {.d_s = dot}}, {_SLIT0, 0, { .d_c = 0 }}})));
						}
						if ((cast_sym->info)._typ == 458 /* v.ast.Aggregate */) {
							v__ast__TypeSymbol* agg_sym = v__ast__Table_sym(g->table, (*(v__ast__Type*)/*ee elem_typ */array_get((*cast_sym->info._v__ast__Aggregate).types, g->aggregate_type_idx)));
							sum_type_deref_field = /*f*/string__plus(sum_type_deref_field,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("_"), 0xfe10, {.d_s = agg_sym->cname}}, {_SLIT0, 0, { .d_c = 0 }}})));
						} else {
							sum_type_deref_field = /*f*/string__plus(sum_type_deref_field,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("_"), 0xfe10, {.d_s = cast_sym->cname}}, {_SLIT0, 0, { .d_c = 0 }}})));
						}
					}
				}
			}
		}
	}
	int n_ptr = v__ast__Type_nr_muls(node.expr_type) - 1;
	if (n_ptr > 0) {
		v__gen__c__Gen_write(g, _SLIT("("));
		v__gen__c__Gen_write(g, string_repeat(_SLIT("*"), n_ptr));
		v__gen__c__Gen_expr(g, node.expr);
		v__gen__c__Gen_write(g, _SLIT(")"));
	} else {
		v__gen__c__Gen_expr(g, node.expr);
	}
	if (is_optional) {
		v__gen__c__Gen_write(g, _SLIT(".data)"));
	}
	if ((sym->info)._typ == 446 /* v.ast.Struct */ || (sym->info)._typ == 458 /* v.ast.Aggregate */) {
		for (int _t5 = 0; _t5 < node.from_embed_types.len; ++_t5) {
			v__ast__Type embed = ((v__ast__Type*)node.from_embed_types.data)[_t5];
			v__ast__TypeSymbol* embed_sym = v__ast__Table_sym(g->table, embed);
			string embed_name = v__ast__TypeSymbol_embed_name(embed_sym);
			if (v__ast__Type_is_ptr(node.expr_type)) {
				v__gen__c__Gen_write(g, _SLIT("->"));
			} else {
				v__gen__c__Gen_write(g, _SLIT("."));
			}
			v__gen__c__Gen_write(g, embed_name);
		}
	}
	if ((v__ast__Type_is_ptr(node.expr_type) || sym->kind == v__ast__Kind__chan) && node.from_embed_types.len == 0) {
		v__gen__c__Gen_write(g, _SLIT("->"));
	} else {
		v__gen__c__Gen_write(g, _SLIT("."));
	}
	if (v__ast__Type_has_flag(node.expr_type, v__ast__TypeFlag__shared_f)) {
		v__gen__c__Gen_write(g, _SLIT("val."));
	}
	if (node.expr_type == 0) {
		v__gen__c__verror( str_intp(5, _MOV((StrIntpData[]){{_SLIT("cgen: SelectorExpr | expr_type: 0 | it.expr: `"), 0xfe10, {.d_s = v__ast__Expr_str(node.expr)}}, {_SLIT("` | field: `"), 0xfe10, {.d_s = node.field_name}}, {_SLIT("` | file: "), 0xfe10, {.d_s = g->file->path}}, {_SLIT(" | line: "), 0xfe07, {.d_i32 = node.pos.line_nr}}, {_SLIT0, 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	string field_name = (sym->language == v__ast__Language__v ? (v__gen__c__c_name(node.field_name)) : (node.field_name));
	v__gen__c__Gen_write(g, field_name);
	if ((sum_type_deref_field).len != 0) {
		v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = sum_type_dot}}, {_SLIT0, 0xfe10, {.d_s = sum_type_deref_field}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
	}
	if (sym->kind == v__ast__Kind__interface_ || sym->kind == v__ast__Kind__sum_type) {
		v__gen__c__Gen_write(g, _SLIT("))"));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_enum_expr(v__gen__c__Gen* g, v__ast__Expr node) {
	if (node._typ == 296 /* v.ast.EnumVal */) {
		v__gen__c__Gen_write(g, (*node._v__ast__EnumVal).val);
	}
	
	else {
		v__gen__c__Gen_expr(g, node);
	}
	;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_lock_expr(v__gen__c__Gen* g, v__ast__LockExpr node) {
bool v__gen__c__Gen_lock_expr_defer_0 = false;
bool v__gen__c__Gen_lock_expr_defer_1 = false;
	g->cur_lock = node;
	v__gen__c__Gen_lock_expr_defer_0 = true;
	string tmp_result = (node.is_expr ? (v__gen__c__Gen_new_tmp_var(g)) : (_SLIT("")));
	string cur_line = _SLIT("");
	if (node.is_expr) {
		string styp = v__gen__c__Gen_typ(g, node.typ);
		cur_line = v__gen__c__Gen_go_before_stmt(g, 0);
		v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = styp}}, {_SLIT(" "), 0xfe10, {.d_s = tmp_result}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
	}
	string mtxs = _SLIT("");
	if (node.lockeds.len == 0) {
	} else if (node.lockeds.len == 1) {
		string lock_prefix = ((*(bool*)/*ee elem_typ */array_get(node.is_rlock, 0)) ? (_SLIT("r")) : (_SLIT("")));
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("sync__RwMutex_"), 0xfe10, {.d_s = lock_prefix}}, {_SLIT("lock(&"), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_expr(g, (*(v__ast__Expr*)/*ee elem_typ */array_get(node.lockeds, 0)));
		v__gen__c__Gen_writeln(g, _SLIT("->mtx);"));
	} else {
		mtxs = v__gen__c__Gen_new_tmp_var(g);
		v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("uintptr_t _arr_"), 0xfe10, {.d_s = mtxs}}, {_SLIT("["), 0xfe07, {.d_i32 = node.lockeds.len}}, {_SLIT("];"), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("bool _isrlck_"), 0xfe10, {.d_s = mtxs}}, {_SLIT("["), 0xfe07, {.d_i32 = node.lockeds.len}}, {_SLIT("];"), 0, { .d_c = 0 }}})));
		int j = 0;
		for (int i = 0; i < node.is_rlock.len; ++i) {
			bool is_rlock = ((bool*)node.is_rlock.data)[i];
			if (!is_rlock) {
				v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("_arr_"), 0xfe10, {.d_s = mtxs}}, {_SLIT("["), 0xfe07, {.d_i32 = j}}, {_SLIT("] = (uintptr_t)&"), 0, { .d_c = 0 }}})));
				v__gen__c__Gen_expr(g, (*(v__ast__Expr*)/*ee elem_typ */array_get(node.lockeds, i)));
				v__gen__c__Gen_writeln(g, _SLIT("->mtx;"));
				v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("_isrlck_"), 0xfe10, {.d_s = mtxs}}, {_SLIT("["), 0xfe07, {.d_i32 = j}}, {_SLIT("] = false;"), 0, { .d_c = 0 }}})));
				j++;
			}
		}
		for (int i = 0; i < node.is_rlock.len; ++i) {
			bool is_rlock = ((bool*)node.is_rlock.data)[i];
			if (is_rlock) {
				v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("_arr_"), 0xfe10, {.d_s = mtxs}}, {_SLIT("["), 0xfe07, {.d_i32 = j}}, {_SLIT("] = (uintptr_t)&"), 0, { .d_c = 0 }}})));
				v__gen__c__Gen_expr(g, (*(v__ast__Expr*)/*ee elem_typ */array_get(node.lockeds, i)));
				v__gen__c__Gen_writeln(g, _SLIT("->mtx;"));
				v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("_isrlck_"), 0xfe10, {.d_s = mtxs}}, {_SLIT("["), 0xfe07, {.d_i32 = j}}, {_SLIT("] = true;"), 0, { .d_c = 0 }}})));
				j++;
			}
		}
		if (node.lockeds.len == 2) {
			v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("if (_arr_"), 0xfe10, {.d_s = mtxs}}, {_SLIT("[0] > _arr_"), 0xfe10, {.d_s = mtxs}}, {_SLIT("[1]) {"), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\tuintptr_t _ptr_"), 0xfe10, {.d_s = mtxs}}, {_SLIT(" = _arr_"), 0xfe10, {.d_s = mtxs}}, {_SLIT("[0];"), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t_arr_"), 0xfe10, {.d_s = mtxs}}, {_SLIT("[0] = _arr_"), 0xfe10, {.d_s = mtxs}}, {_SLIT("[1];"), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t_arr_"), 0xfe10, {.d_s = mtxs}}, {_SLIT("[1] = _ptr_"), 0xfe10, {.d_s = mtxs}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\tbool _bool_"), 0xfe10, {.d_s = mtxs}}, {_SLIT(" = _isrlck_"), 0xfe10, {.d_s = mtxs}}, {_SLIT("[0];"), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t_isrlck_"), 0xfe10, {.d_s = mtxs}}, {_SLIT("[0] = _isrlck_"), 0xfe10, {.d_s = mtxs}}, {_SLIT("[1];"), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t_isrlck_"), 0xfe10, {.d_s = mtxs}}, {_SLIT("[1] = _bool_"), 0xfe10, {.d_s = mtxs}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_writeln(g, _SLIT("}"));
		} else {
			v__gen__c__Gen_writeln(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("__sort_ptr(_arr_"), 0xfe10, {.d_s = mtxs}}, {_SLIT(", _isrlck_"), 0xfe10, {.d_s = mtxs}}, {_SLIT(", "), 0xfe07, {.d_i32 = node.lockeds.len}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
		}
		v__gen__c__Gen_writeln(g,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("for (int "), 0xfe10, {.d_s = mtxs}}, {_SLIT("=0; "), 0xfe10, {.d_s = mtxs}}, {_SLIT("<"), 0xfe07, {.d_i32 = node.lockeds.len}}, {_SLIT("; "), 0xfe10, {.d_s = mtxs}}, {_SLIT("++) {"), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_writeln(g,  str_intp(6, _MOV((StrIntpData[]){{_SLIT("\tif ("), 0xfe10, {.d_s = mtxs}}, {_SLIT(" && _arr_"), 0xfe10, {.d_s = mtxs}}, {_SLIT("["), 0xfe10, {.d_s = mtxs}}, {_SLIT("] == _arr_"), 0xfe10, {.d_s = mtxs}}, {_SLIT("["), 0xfe10, {.d_s = mtxs}}, {_SLIT("-1]) continue;"), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\tif (_isrlck_"), 0xfe10, {.d_s = mtxs}}, {_SLIT("["), 0xfe10, {.d_s = mtxs}}, {_SLIT("])"), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\tsync__RwMutex_rlock((sync__RwMutex*)_arr_"), 0xfe10, {.d_s = mtxs}}, {_SLIT("["), 0xfe10, {.d_s = mtxs}}, {_SLIT("]);"), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_writeln(g, _SLIT("\telse"));
		v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\tsync__RwMutex_lock((sync__RwMutex*)_arr_"), 0xfe10, {.d_s = mtxs}}, {_SLIT("["), 0xfe10, {.d_s = mtxs}}, {_SLIT("]);"), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_writeln(g, _SLIT("}"));
	}
	g->mtxs = mtxs;
	v__gen__c__Gen_lock_expr_defer_1 = true;
	v__gen__c__Gen_writeln(g, _SLIT("/*lock*/ {"));
	v__gen__c__Gen_stmts_with_tmp_var(g, node.stmts, tmp_result);
	if (node.is_expr) {
		v__gen__c__Gen_writeln(g, _SLIT(";"));
	}
	v__gen__c__Gen_writeln(g, _SLIT("}"));
	v__gen__c__Gen_unlock_locks(g);
	if (node.is_expr) {
		v__gen__c__Gen_writeln(g, _SLIT(""));
		v__gen__c__Gen_write(g, cur_line);
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = tmp_result}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
// Defer begin
if (v__gen__c__Gen_lock_expr_defer_1) {
	g->mtxs = _SLIT("");
}
// Defer end
// Defer begin
if (v__gen__c__Gen_lock_expr_defer_0) {
	g->cur_lock = (v__ast__LockExpr){.stmts = __new_array(0, 0, sizeof(v__ast__Stmt)),.is_rlock = __new_array(0, 0, sizeof(bool)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.lockeds = __new_array(0, 0, sizeof(v__ast__Expr)),.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.is_expr = 0,.typ = 0,.scope = 0,};
}
// Defer end
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_unlock_locks(v__gen__c__Gen* g) {
	if (g->cur_lock.lockeds.len == 0) {
	} else if (g->cur_lock.lockeds.len == 1) {
		string lock_prefix = ((*(bool*)/*ee elem_typ */array_get(g->cur_lock.is_rlock, 0)) ? (_SLIT("r")) : (_SLIT("")));
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("sync__RwMutex_"), 0xfe10, {.d_s = lock_prefix}}, {_SLIT("unlock(&"), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_expr(g, (*(v__ast__Expr*)/*ee elem_typ */array_get(g->cur_lock.lockeds, 0)));
		v__gen__c__Gen_write(g, _SLIT("->mtx);"));
	} else {
		v__gen__c__Gen_writeln(g,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("for (int "), 0xfe10, {.d_s = g->mtxs}}, {_SLIT("="), 0xfe07, {.d_i32 = g->cur_lock.lockeds.len - 1}}, {_SLIT("; "), 0xfe10, {.d_s = g->mtxs}}, {_SLIT(">=0; "), 0xfe10, {.d_s = g->mtxs}}, {_SLIT("--) {"), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_writeln(g,  str_intp(6, _MOV((StrIntpData[]){{_SLIT("\tif ("), 0xfe10, {.d_s = g->mtxs}}, {_SLIT(" && _arr_"), 0xfe10, {.d_s = g->mtxs}}, {_SLIT("["), 0xfe10, {.d_s = g->mtxs}}, {_SLIT("] == _arr_"), 0xfe10, {.d_s = g->mtxs}}, {_SLIT("["), 0xfe10, {.d_s = g->mtxs}}, {_SLIT("-1]) continue;"), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\tif (_isrlck_"), 0xfe10, {.d_s = g->mtxs}}, {_SLIT("["), 0xfe10, {.d_s = g->mtxs}}, {_SLIT("])"), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\tsync__RwMutex_runlock((sync__RwMutex*)_arr_"), 0xfe10, {.d_s = g->mtxs}}, {_SLIT("["), 0xfe10, {.d_s = g->mtxs}}, {_SLIT("]);"), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_writeln(g, _SLIT("\telse"));
		v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\tsync__RwMutex_unlock((sync__RwMutex*)_arr_"), 0xfe10, {.d_s = g->mtxs}}, {_SLIT("["), 0xfe10, {.d_s = g->mtxs}}, {_SLIT("]);"), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_write(g, _SLIT("}"));
	}
}

VV_LOCAL_SYMBOL bool v__gen__c__Gen_need_tmp_var_in_match(v__gen__c__Gen* g, v__ast__MatchExpr node) {
	if (node.is_expr && !v__ast__Type_alias_eq(node.return_type, _const_v__ast__void_type) && node.return_type != 0) {
		v__ast__TypeSymbol* cond_sym = v__ast__Table_final_sym(g->table, node.cond_type);
		v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, node.return_type);
		if (v__ast__Table_type_kind(g->table, node.return_type) == v__ast__Kind__sum_type) {
			bool _t1 = true;
			return _t1;
		}
		if (v__ast__Type_has_flag(node.return_type, v__ast__TypeFlag__optional)) {
			bool _t2 = true;
			return _t2;
		}
		if (sym->kind == v__ast__Kind__multi_return) {
			bool _t3 = false;
			return _t3;
		}
		if (cond_sym->kind == v__ast__Kind__enum_ && node.branches.len > 5) {
			bool _t4 = true;
			return _t4;
		}
		for (int _t5 = 0; _t5 < node.branches.len; ++_t5) {
			v__ast__MatchBranch branch = ((v__ast__MatchBranch*)node.branches.data)[_t5];
			if (branch.stmts.len > 1) {
				bool _t6 = true;
				return _t6;
			}
			if (branch.stmts.len == 1) {
				if (((*(v__ast__Stmt*)/*ee elem_typ */array_get(branch.stmts, 0)))._typ == 339 /* v.ast.ExprStmt */) {
					v__ast__ExprStmt stmt = /* as */ *(v__ast__ExprStmt*)__as_cast(((*(v__ast__Stmt*)/*ee elem_typ */array_get(branch.stmts, 0)))._v__ast__ExprStmt,((*(v__ast__Stmt*)/*ee elem_typ */array_get(branch.stmts, 0)))._typ, 339) /*expected idx: 339, name: v.ast.ExprStmt */ ;
					if (((stmt.expr)._typ == 286 /* v.ast.CallExpr */ || (stmt.expr)._typ == 300 /* v.ast.IfExpr */ || (stmt.expr)._typ == 309 /* v.ast.MatchExpr */) || ((stmt.expr)._typ == 302 /* v.ast.IndexExpr */ && (/* as */ *(v__ast__IndexExpr*)__as_cast((stmt.expr)._v__ast__IndexExpr,(stmt.expr)._typ, 302) /*expected idx: 302, name: v.ast.IndexExpr */ ).or_expr.kind != v__ast__OrKind__absent)) {
						bool _t7 = true;
						return _t7;
					}
				}
			}
		}
	}
	bool _t8 = false;
	return _t8;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_match_expr(v__gen__c__Gen* g, v__ast__MatchExpr node) {
bool v__gen__c__Gen_match_expr_defer_0 = false;
bool old;
	if (node.cond_type == 0) {
		v__gen__c__Gen_writeln(g, _SLIT("// match 0"));
		return;
	}
	bool need_tmp_var = v__gen__c__Gen_need_tmp_var_in_match(g, node);
	bool is_expr = (node.is_expr && !v__ast__Type_alias_eq(node.return_type, _const_v__ast__void_type)) || g->inside_ternary > 0;
	string cond_var = _SLIT("");
	string tmp_var = _SLIT("");
	string cur_line = _SLIT("");
	if (is_expr && !need_tmp_var) {
		g->inside_ternary++;
	}
	if (is_expr && v__ast__Type_has_flag(node.return_type, v__ast__TypeFlag__optional)) {
		old = g->inside_match_optional;
		v__gen__c__Gen_match_expr_defer_0 = true;
		g->inside_match_optional = true;
	}
	if ((node.cond)._typ == 299 /* v.ast.Ident */ || (node.cond)._typ == 319 /* v.ast.SelectorExpr */ || (node.cond)._typ == 304 /* v.ast.IntegerLiteral */ || (node.cond)._typ == 323 /* v.ast.StringLiteral */ || (node.cond)._typ == 297 /* v.ast.FloatLiteral */) {
		cond_var = v__gen__c__Gen_expr_string(g, node.cond);
	} else {
		string _t1; /* if prepend */
		if (is_expr) {
			g->empty_line = true;
			_t1 = v__gen__c__Gen_go_before_stmt(g, 0);
		} else {
			_t1 = _SLIT("");
		}
		string line =  _t1;
		cond_var = v__gen__c__Gen_new_tmp_var(g);
		v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__gen__c__Gen_typ(g, node.cond_type)}}, {_SLIT(" "), 0xfe10, {.d_s = cond_var}}, {_SLIT(" = "), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_expr(g, node.cond);
		v__gen__c__Gen_writeln(g, _SLIT(";"));
		v__gen__c__Gen_set_current_pos_as_last_stmt_pos(g);
		v__gen__c__Gen_write(g, line);
	}
	if (need_tmp_var) {
		g->empty_line = true;
		cur_line = string_trim_left(v__gen__c__Gen_go_before_stmt(g, 0), _SLIT(" \t"));
		tmp_var = v__gen__c__Gen_new_tmp_var(g);
		v__gen__c__Gen_writeln(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__gen__c__Gen_typ(g, node.return_type)}}, {_SLIT(" "), 0xfe10, {.d_s = tmp_var}}, {_SLIT(" = "), 0xfe10, {.d_s = v__gen__c__Gen_type_default(g, node.return_type)}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
	}
	if (is_expr && !need_tmp_var) {
		v__gen__c__Gen_write(g, _SLIT("("));
	}
	v__ast__TypeSymbol* typ = v__ast__Table_final_sym(g->table, node.cond_type);
	if (node.is_sum_type) {
		v__gen__c__Gen_match_expr_sumtype(g, node, is_expr, cond_var, tmp_var);
	} else if (typ->kind == v__ast__Kind__enum_ && g->loop_depth == 0 && node.branches.len > 5 && g->fn_decl != 0) {
		v__gen__c__Gen_match_expr_switch(g, node, is_expr, cond_var, tmp_var, *typ);
	} else {
		v__gen__c__Gen_match_expr_classic(g, node, is_expr, cond_var, tmp_var);
	}
	v__gen__c__Gen_set_current_pos_as_last_stmt_pos(g);
	v__gen__c__Gen_write(g, cur_line);
	if (need_tmp_var) {
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = tmp_var}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
	if (is_expr && !need_tmp_var) {
		v__gen__c__Gen_write(g, _SLIT(")"));
		v__gen__c__Gen_decrement_inside_ternary(g);
	}
// Defer begin
if (v__gen__c__Gen_match_expr_defer_0) {
	g->inside_match_optional = old;
}
// Defer end
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_match_expr_sumtype(v__gen__c__Gen* g, v__ast__MatchExpr node, bool is_expr, string cond_var, string tmp_var) {
	for (int j = 0; j < node.branches.len; ++j) {
		v__ast__MatchBranch branch = ((v__ast__MatchBranch*)node.branches.data)[j];
		int sumtype_index = 0;
		for (;;) {
			g->aggregate_type_idx = sumtype_index;
			bool is_last = j == node.branches.len - 1;
			v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, node.cond_type);
			if (branch.is_else || (node.is_expr && is_last && tmp_var.len == 0)) {
				if (is_expr && tmp_var.len == 0) {
					v__gen__c__Gen_write(g, _SLIT(" : "));
				} else {
					v__gen__c__Gen_writeln(g, _SLIT(""));
					v__gen__c__Gen_write_v_source_line_info(g, branch.pos);
					v__gen__c__Gen_writeln(g, _SLIT("else {"));
				}
			} else {
				if (j > 0 || sumtype_index > 0) {
					if (is_expr && tmp_var.len == 0) {
						v__gen__c__Gen_write(g, _SLIT(" : "));
					} else {
						v__gen__c__Gen_write_v_source_line_info(g, branch.pos);
						v__gen__c__Gen_write(g, _SLIT("else "));
					}
				}
				if (is_expr && tmp_var.len == 0) {
					v__gen__c__Gen_write(g, _SLIT("("));
				} else {
					if (j == 0 && sumtype_index == 0) {
						g->empty_line = true;
					}
					v__gen__c__Gen_write_v_source_line_info(g, branch.pos);
					v__gen__c__Gen_write(g, _SLIT("if ("));
				}
				v__gen__c__Gen_write(g, cond_var);
				string dot_or_ptr = (v__ast__Type_is_ptr(node.cond_type) ? (_SLIT("->")) : (_SLIT(".")));
				if (sym->kind == v__ast__Kind__sum_type) {
					v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = dot_or_ptr}}, {_SLIT("_typ == "), 0, { .d_c = 0 }}})));
					v__gen__c__Gen_expr(g, (*(v__ast__Expr*)/*ee elem_typ */array_get(branch.exprs, sumtype_index)));
				} else if (sym->kind == v__ast__Kind__interface_) {
					if (((*(v__ast__Expr*)/*ee elem_typ */array_get(branch.exprs, sumtype_index)))._typ == 325 /* v.ast.TypeNode */) {
						v__ast__TypeNode typ = /* as */ *(v__ast__TypeNode*)__as_cast(((*(v__ast__Expr*)/*ee elem_typ */array_get(branch.exprs, sumtype_index)))._v__ast__TypeNode,((*(v__ast__Expr*)/*ee elem_typ */array_get(branch.exprs, sumtype_index)))._typ, 325) /*expected idx: 325, name: v.ast.TypeNode */ ;
						v__ast__TypeSymbol* branch_sym = v__ast__Table_sym(g->table, v__gen__c__Gen_unwrap_generic(g, typ.typ));
						v__gen__c__Gen_write(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = dot_or_ptr}}, {_SLIT("_typ == _"), 0xfe10, {.d_s = sym->cname}}, {_SLIT("_"), 0xfe10, {.d_s = branch_sym->cname}}, {_SLIT("_index"), 0, { .d_c = 0 }}})));
					} else if (((*(v__ast__Expr*)/*ee elem_typ */array_get(branch.exprs, sumtype_index)))._typ == 311 /* v.ast.None */ && string__eq(sym->name, _SLIT("IError"))) {
						v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = dot_or_ptr}}, {_SLIT("_typ == _IError_None___index"), 0, { .d_c = 0 }}})));
					}
				}
				if (is_expr && tmp_var.len == 0) {
					v__gen__c__Gen_write(g, _SLIT(") ? "));
				} else {
					v__gen__c__Gen_writeln(g, _SLIT(") {"));
				}
			}
			if (is_expr && tmp_var.len > 0 && v__ast__Table_sym(g->table, node.return_type)->kind == v__ast__Kind__sum_type) {
				g->expected_cast_type = node.return_type;
			}
			v__gen__c__Gen_stmts_with_tmp_var(g, branch.stmts, tmp_var);
			g->expected_cast_type = 0;
			if (g->inside_ternary == 0) {
				v__gen__c__Gen_writeln(g, _SLIT("}"));
				v__gen__c__Gen_set_current_pos_as_last_stmt_pos(g);
			}
			sumtype_index++;
			if (branch.exprs.len == 0 || sumtype_index == branch.exprs.len) {
				break;
			}
		}
		g->aggregate_type_idx = 0;
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_match_expr_switch(v__gen__c__Gen* g, v__ast__MatchExpr node, bool is_expr, string cond_var, string tmp_var, v__ast__TypeSymbol enum_typ) {
	string cname =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = enum_typ.cname}}, {_SLIT("__"), 0, { .d_c = 0 }}}));
	Array_string covered_enum = __new_array_with_default(0, (/* as */ *(v__ast__Enum*)__as_cast((enum_typ.info)._v__ast__Enum,(enum_typ.info)._typ, 474) /*expected idx: 474, name: v.ast.Enum */ ).vals.len, sizeof(string), 0);
	Array_v__ast__MatchBranch range_branches = __new_array_with_default(0, node.branches.len, sizeof(v__ast__MatchBranch), 0);
	bool default_generated = false;
	g->empty_line = true;
	v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("switch ("), 0xfe10, {.d_s = cond_var}}, {_SLIT(") {"), 0, { .d_c = 0 }}})));
	g->indent++;
	for (int _t1 = 0; _t1 < node.branches.len; ++_t1) {
		v__ast__MatchBranch branch = ((v__ast__MatchBranch*)node.branches.data)[_t1];
		if (branch.is_else) {
			for (int _t2 = 0; _t2 < (/* as */ *(v__ast__Enum*)__as_cast((enum_typ.info)._v__ast__Enum,(enum_typ.info)._typ, 474) /*expected idx: 474, name: v.ast.Enum */ ).vals.len; ++_t2) {
				string val = ((string*)(/* as */ *(v__ast__Enum*)__as_cast((enum_typ.info)._v__ast__Enum,(enum_typ.info)._typ, 474) /*expected idx: 474, name: v.ast.Enum */ ).vals.data)[_t2];
				if (!Array_string_contains(covered_enum, val)) {
					v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("case "), 0xfe10, {.d_s = cname}}, {_SLIT0, 0xfe10, {.d_s = val}}, {_SLIT(":"), 0, { .d_c = 0 }}})));
				}
			}
			v__gen__c__Gen_writeln(g, _SLIT("default:"));
			default_generated = true;
			if (range_branches.len > 0) {
				g->indent++;
				for (int _t3 = 0; _t3 < range_branches.len; ++_t3) {
					v__ast__MatchBranch range_branch = ((v__ast__MatchBranch*)range_branches.data)[_t3];
					v__gen__c__Gen_write(g, _SLIT("if ("));
					for (int i = 0; i < range_branch.exprs.len; ++i) {
						v__ast__Expr expr = ((v__ast__Expr*)range_branch.exprs.data)[i];
						if (i > 0) {
							v__gen__c__Gen_write(g, _SLIT(" || "));
						}
						if ((expr)._typ == 317 /* v.ast.RangeExpr */) {
							bool skip_low = false;
							if (((*expr._v__ast__RangeExpr).low)._typ == 304 /* v.ast.IntegerLiteral */) {
								if ((node.cond_type == _const_v__ast__u16_type || node.cond_type == _const_v__ast__u32_type || node.cond_type == _const_v__ast__u64_type) && string__eq((*(*expr._v__ast__RangeExpr).low._v__ast__IntegerLiteral).val, _SLIT("0"))) {
									skip_low = true;
								}
							}
							v__gen__c__Gen_write(g, _SLIT("("));
							if (!skip_low) {
								v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = cond_var}}, {_SLIT(" >= "), 0, { .d_c = 0 }}})));
								v__gen__c__Gen_expr(g, (*expr._v__ast__RangeExpr).low);
								v__gen__c__Gen_write(g, _SLIT(" && "));
							}
							v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = cond_var}}, {_SLIT(" <= "), 0, { .d_c = 0 }}})));
							v__gen__c__Gen_expr(g, (*expr._v__ast__RangeExpr).high);
							v__gen__c__Gen_write(g, _SLIT(")"));
						} else {
							v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = cond_var}}, {_SLIT(" == ("), 0, { .d_c = 0 }}})));
							v__gen__c__Gen_expr(g, expr);
							v__gen__c__Gen_write(g, _SLIT(")"));
						}
					}
					v__gen__c__Gen_writeln(g, _SLIT(") {"));
					v__gen__c__Gen_stmts_with_tmp_var(g, range_branch.stmts, tmp_var);
					v__gen__c__Gen_writeln(g, _SLIT("break;"));
					v__gen__c__Gen_writeln(g, _SLIT("}"));
				}
				g->indent--;
			}
		} else {
			bool _t4 = false;
			Array_v__ast__Expr _t4_orig = branch.exprs;
			int _t4_len = _t4_orig.len;
			for (int _t5 = 0; _t5 < _t4_len; ++_t5) {
				v__ast__Expr it = ((v__ast__Expr*) _t4_orig.data)[_t5];
				if ((it)._typ == 317 /* v.ast.RangeExpr */) {
					_t4 = true;
					break;
				}
			}
			if (_t4) {
				array_push((array*)&range_branches, _MOV((v__ast__MatchBranch[]){ branch }));
				continue;
			}
			for (int _t7 = 0; _t7 < branch.exprs.len; ++_t7) {
				v__ast__Expr expr = ((v__ast__Expr*)branch.exprs.data)[_t7];
				if ((expr)._typ == 296 /* v.ast.EnumVal */) {
					array_push((array*)&covered_enum, _MOV((string[]){ string_clone((*expr._v__ast__EnumVal).val) }));
					v__gen__c__Gen_write(g, _SLIT("case "));
					v__gen__c__Gen_expr(g, expr);
					v__gen__c__Gen_writeln(g, _SLIT(": "));
				}
			}
		}
		g->indent++;
		v__gen__c__Gen_writeln(g, _SLIT("{"));
		if (is_expr && tmp_var.len > 0 && v__ast__Table_sym(g->table, node.return_type)->kind == v__ast__Kind__sum_type) {
			g->expected_cast_type = node.return_type;
		}
		v__gen__c__Gen_stmts_with_tmp_var(g, branch.stmts, tmp_var);
		g->expected_cast_type = 0;
		v__gen__c__Gen_writeln(g, _SLIT("} break;"));
		g->indent--;
	}
	if (range_branches.len > 0 && !default_generated) {
		v__gen__c__Gen_writeln(g, _SLIT("default:"));
		g->indent++;
		for (int _t9 = 0; _t9 < range_branches.len; ++_t9) {
			v__ast__MatchBranch range_branch = ((v__ast__MatchBranch*)range_branches.data)[_t9];
			v__gen__c__Gen_write(g, _SLIT("if ("));
			for (int i = 0; i < range_branch.exprs.len; ++i) {
				v__ast__Expr expr = ((v__ast__Expr*)range_branch.exprs.data)[i];
				if (i > 0) {
					v__gen__c__Gen_write(g, _SLIT(" || "));
				}
				if ((expr)._typ == 317 /* v.ast.RangeExpr */) {
					bool skip_low = false;
					if (((*expr._v__ast__RangeExpr).low)._typ == 304 /* v.ast.IntegerLiteral */) {
						if ((node.cond_type == _const_v__ast__u16_type || node.cond_type == _const_v__ast__u32_type || node.cond_type == _const_v__ast__u64_type) && string__eq((*(*expr._v__ast__RangeExpr).low._v__ast__IntegerLiteral).val, _SLIT("0"))) {
							skip_low = true;
						}
					}
					v__gen__c__Gen_write(g, _SLIT("("));
					if (!skip_low) {
						v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = cond_var}}, {_SLIT(" >= "), 0, { .d_c = 0 }}})));
						v__gen__c__Gen_expr(g, (*expr._v__ast__RangeExpr).low);
						v__gen__c__Gen_write(g, _SLIT(" && "));
					}
					v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = cond_var}}, {_SLIT(" <= "), 0, { .d_c = 0 }}})));
					v__gen__c__Gen_expr(g, (*expr._v__ast__RangeExpr).high);
					v__gen__c__Gen_write(g, _SLIT(")"));
				} else {
					v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = cond_var}}, {_SLIT(" == ("), 0, { .d_c = 0 }}})));
					v__gen__c__Gen_expr(g, expr);
					v__gen__c__Gen_write(g, _SLIT(")"));
				}
			}
			v__gen__c__Gen_writeln(g, _SLIT(") {"));
			v__gen__c__Gen_stmts_with_tmp_var(g, range_branch.stmts, tmp_var);
			v__gen__c__Gen_writeln(g, _SLIT("break;"));
			v__gen__c__Gen_writeln(g, _SLIT("}"));
		}
		g->indent--;
	}
	g->indent--;
	v__gen__c__Gen_writeln(g, _SLIT("}"));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_match_expr_classic(v__gen__c__Gen* g, v__ast__MatchExpr node, bool is_expr, string cond_var, string tmp_var) {
	v__ast__TypeSymbol* type_sym = v__ast__Table_sym(g->table, node.cond_type);
	for (int j = 0; j < node.branches.len; ++j) {
		v__ast__MatchBranch branch = ((v__ast__MatchBranch*)node.branches.data)[j];
		bool is_last = j == node.branches.len - 1;
		if (branch.is_else || (node.is_expr && is_last && tmp_var.len == 0)) {
			if (node.branches.len > 1) {
				if (is_expr && tmp_var.len == 0) {
					v__gen__c__Gen_write(g, _SLIT(" : "));
				} else {
					v__gen__c__Gen_writeln(g, _SLIT(""));
					v__gen__c__Gen_write_v_source_line_info(g, branch.pos);
					v__gen__c__Gen_writeln(g, _SLIT("else {"));
				}
			}
		} else {
			if (j > 0) {
				if (is_expr && tmp_var.len == 0) {
					v__gen__c__Gen_write(g, _SLIT(" : "));
				} else {
					v__gen__c__Gen_writeln(g, _SLIT(""));
					v__gen__c__Gen_write_v_source_line_info(g, branch.pos);
					v__gen__c__Gen_write(g, _SLIT("else "));
				}
			}
			if (is_expr && tmp_var.len == 0) {
				v__gen__c__Gen_write(g, _SLIT("("));
			} else {
				if (j == 0) {
					v__gen__c__Gen_writeln(g, _SLIT(""));
				}
				v__gen__c__Gen_write_v_source_line_info(g, branch.pos);
				v__gen__c__Gen_write(g, _SLIT("if ("));
			}
			for (int i = 0; i < branch.exprs.len; ++i) {
				v__ast__Expr expr = ((v__ast__Expr*)branch.exprs.data)[i];
				if (i > 0) {
					v__gen__c__Gen_write(g, _SLIT(" || "));
				}

				if (type_sym->kind == (v__ast__Kind__array)) {
					string ptr_typ = v__gen__c__Gen_equality_fn(g, node.cond_type);
					v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ptr_typ}}, {_SLIT("_arr_eq("), 0xfe10, {.d_s = cond_var}}, {_SLIT(", "), 0, { .d_c = 0 }}})));
					v__gen__c__Gen_expr(g, expr);
					v__gen__c__Gen_write(g, _SLIT(")"));
				}
				else if (type_sym->kind == (v__ast__Kind__array_fixed)) {
					string ptr_typ = v__gen__c__Gen_equality_fn(g, node.cond_type);
					v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ptr_typ}}, {_SLIT("_arr_eq("), 0xfe10, {.d_s = cond_var}}, {_SLIT(", "), 0, { .d_c = 0 }}})));
					v__gen__c__Gen_expr(g, expr);
					v__gen__c__Gen_write(g, _SLIT(")"));
				}
				else if (type_sym->kind == (v__ast__Kind__map)) {
					string ptr_typ = v__gen__c__Gen_equality_fn(g, node.cond_type);
					v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ptr_typ}}, {_SLIT("_map_eq("), 0xfe10, {.d_s = cond_var}}, {_SLIT(", "), 0, { .d_c = 0 }}})));
					v__gen__c__Gen_expr(g, expr);
					v__gen__c__Gen_write(g, _SLIT(")"));
				}
				else if (type_sym->kind == (v__ast__Kind__string)) {
					v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("string__eq("), 0xfe10, {.d_s = cond_var}}, {_SLIT(", "), 0, { .d_c = 0 }}})));
					v__gen__c__Gen_expr(g, expr);
					v__gen__c__Gen_write(g, _SLIT(")"));
				}
				else if (type_sym->kind == (v__ast__Kind__struct_)) {
					string ptr_typ = v__gen__c__Gen_equality_fn(g, node.cond_type);
					v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ptr_typ}}, {_SLIT("_struct_eq("), 0xfe10, {.d_s = cond_var}}, {_SLIT(", "), 0, { .d_c = 0 }}})));
					v__gen__c__Gen_expr(g, expr);
					v__gen__c__Gen_write(g, _SLIT(")"));
				}
				else {
					if ((expr)._typ == 317 /* v.ast.RangeExpr */) {
						bool skip_low = false;
						if (((*expr._v__ast__RangeExpr).low)._typ == 304 /* v.ast.IntegerLiteral */) {
							if ((node.cond_type == _const_v__ast__u16_type || node.cond_type == _const_v__ast__u32_type || node.cond_type == _const_v__ast__u64_type) && string__eq((*(*expr._v__ast__RangeExpr).low._v__ast__IntegerLiteral).val, _SLIT("0"))) {
								skip_low = true;
							}
						}
						v__gen__c__Gen_write(g, _SLIT("("));
						if (!skip_low) {
							v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = cond_var}}, {_SLIT(" >= "), 0, { .d_c = 0 }}})));
							v__gen__c__Gen_expr(g, (*expr._v__ast__RangeExpr).low);
							v__gen__c__Gen_write(g, _SLIT(" && "));
						}
						v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = cond_var}}, {_SLIT(" <= "), 0, { .d_c = 0 }}})));
						v__gen__c__Gen_expr(g, (*expr._v__ast__RangeExpr).high);
						v__gen__c__Gen_write(g, _SLIT(")"));
					} else {
						v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = cond_var}}, {_SLIT(" == ("), 0, { .d_c = 0 }}})));
						v__gen__c__Gen_expr(g, expr);
						v__gen__c__Gen_write(g, _SLIT(")"));
					}
				};
			}
			if (is_expr && tmp_var.len == 0) {
				v__gen__c__Gen_write(g, _SLIT(") ? "));
			} else {
				v__gen__c__Gen_writeln(g, _SLIT(") {"));
			}
		}
		if (is_expr && tmp_var.len > 0 && v__ast__Table_sym(g->table, node.return_type)->kind == v__ast__Kind__sum_type) {
			g->expected_cast_type = node.return_type;
		}
		v__gen__c__Gen_stmts_with_tmp_var(g, branch.stmts, tmp_var);
		g->expected_cast_type = 0;
		if (g->inside_ternary == 0 && node.branches.len >= 1) {
			v__gen__c__Gen_write(g, _SLIT("}"));
		}
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_map_init(v__gen__c__Gen* g, v__ast__MapInit node) {
	v__ast__Type unwrap_key_typ = v__gen__c__Gen_unwrap_generic(g, node.key_type);
	v__ast__Type unwrap_val_typ = v__gen__c__Gen_unwrap_generic(g, node.value_type);
	string key_typ_str = v__gen__c__Gen_typ(g, unwrap_key_typ);
	string value_typ_str = v__gen__c__Gen_typ(g, unwrap_val_typ);
	v__ast__TypeSymbol* value_typ = v__ast__Table_sym(g->table, unwrap_val_typ);
	v__ast__TypeSymbol* key_typ = v__ast__Table_final_sym(g->table, unwrap_key_typ);
	multi_return_string_string_string_string mr_121806 = v__gen__c__Gen_map_fn_ptrs(g, *key_typ);
	string hash_fn = mr_121806.arg0;
	string key_eq_fn = mr_121806.arg1;
	string clone_fn = mr_121806.arg2;
	string free_fn = mr_121806.arg3;
	int size = node.vals.len;
	string shared_styp = _SLIT("");
	string styp = _SLIT("");
	bool is_amp = g->is_amp;
	g->is_amp = false;
	if (is_amp) {
		strings__Builder_go_back(&g->out, 1);
	}
	if (g->is_shared) {
		v__ast__Type shared_typ = v__ast__Type_set_flag(node.typ, v__ast__TypeFlag__shared_f);
		shared_styp = v__gen__c__Gen_typ(g, shared_typ);
		v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("("), 0xfe10, {.d_s = shared_styp}}, {_SLIT("*)__dup_shared_map(&("), 0xfe10, {.d_s = shared_styp}}, {_SLIT("){.mtx = {0}, .val ="), 0, { .d_c = 0 }}})));
	} else if (is_amp) {
		styp = v__gen__c__Gen_typ(g, node.typ);
		v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT("*)memdup(ADDR("), 0xfe10, {.d_s = styp}}, {_SLIT(", "), 0, { .d_c = 0 }}})));
	}
	string noscan_key = v__gen__c__Gen_check_noscan(g, node.key_type);
	string noscan_value = v__gen__c__Gen_check_noscan(g, node.value_type);
	string noscan = (noscan_key.len != 0 || noscan_value.len != 0 ? (_SLIT("_noscan")) : (_SLIT("")));
	if (noscan.len != 0) {
		if (noscan_key.len != 0) {
			noscan = /*f*/string__plus(noscan, _SLIT("_key"));
		}
		if (noscan_value.len != 0) {
			noscan = /*f*/string__plus(noscan, _SLIT("_value"));
		}
	}
	if (size > 0) {
		if (value_typ->kind == v__ast__Kind__function) {
			v__gen__c__Gen_write(g,  str_intp(10, _MOV((StrIntpData[]){{_SLIT("new_map_init"), 0xfe10, {.d_s = noscan}}, {_SLIT("("), 0xfe10, {.d_s = hash_fn}}, {_SLIT(", "), 0xfe10, {.d_s = key_eq_fn}}, {_SLIT(", "), 0xfe10, {.d_s = clone_fn}}, {_SLIT(", "), 0xfe10, {.d_s = free_fn}}, {_SLIT(", "), 0xfe07, {.d_i32 = size}}, {_SLIT(", sizeof("), 0xfe10, {.d_s = key_typ_str}}, {_SLIT("), sizeof(voidptr), _MOV(("), 0xfe10, {.d_s = key_typ_str}}, {_SLIT("["), 0xfe07, {.d_i32 = size}}, {_SLIT("]){"), 0, { .d_c = 0 }}})));
		} else {
			v__gen__c__Gen_write(g,  str_intp(11, _MOV((StrIntpData[]){{_SLIT("new_map_init"), 0xfe10, {.d_s = noscan}}, {_SLIT("("), 0xfe10, {.d_s = hash_fn}}, {_SLIT(", "), 0xfe10, {.d_s = key_eq_fn}}, {_SLIT(", "), 0xfe10, {.d_s = clone_fn}}, {_SLIT(", "), 0xfe10, {.d_s = free_fn}}, {_SLIT(", "), 0xfe07, {.d_i32 = size}}, {_SLIT(", sizeof("), 0xfe10, {.d_s = key_typ_str}}, {_SLIT("), sizeof("), 0xfe10, {.d_s = value_typ_str}}, {_SLIT("), _MOV(("), 0xfe10, {.d_s = key_typ_str}}, {_SLIT("["), 0xfe07, {.d_i32 = size}}, {_SLIT("]){"), 0, { .d_c = 0 }}})));
		}
		for (int _t1 = 0; _t1 < node.keys.len; ++_t1) {
			v__ast__Expr expr = ((v__ast__Expr*)node.keys.data)[_t1];
			v__gen__c__Gen_expr(g, expr);
			v__gen__c__Gen_write(g, _SLIT(", "));
		}
		if (value_typ->kind == v__ast__Kind__function) {
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("}), _MOV((voidptr["), 0xfe07, {.d_i32 = size}}, {_SLIT("]){"), 0, { .d_c = 0 }}})));
		} else {
			v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("}), _MOV(("), 0xfe10, {.d_s = value_typ_str}}, {_SLIT("["), 0xfe07, {.d_i32 = size}}, {_SLIT("]){"), 0, { .d_c = 0 }}})));
		}
		for (int _t2 = 0; _t2 < node.vals.len; ++_t2) {
			v__ast__Expr expr = ((v__ast__Expr*)node.vals.data)[_t2];
			if (v__ast__Expr_is_auto_deref_var(expr)) {
				v__gen__c__Gen_write(g, _SLIT("*"));
			}
			v__gen__c__Gen_expr(g, expr);
			v__gen__c__Gen_write(g, _SLIT(", "));
		}
		v__gen__c__Gen_write(g, _SLIT("}))"));
	} else {
		v__gen__c__Gen_write(g,  str_intp(8, _MOV((StrIntpData[]){{_SLIT("new_map"), 0xfe10, {.d_s = noscan}}, {_SLIT("(sizeof("), 0xfe10, {.d_s = key_typ_str}}, {_SLIT("), sizeof("), 0xfe10, {.d_s = value_typ_str}}, {_SLIT("), "), 0xfe10, {.d_s = hash_fn}}, {_SLIT(", "), 0xfe10, {.d_s = key_eq_fn}}, {_SLIT(", "), 0xfe10, {.d_s = clone_fn}}, {_SLIT(", "), 0xfe10, {.d_s = free_fn}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
	}
	if (g->is_shared) {
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("}, sizeof("), 0xfe10, {.d_s = shared_styp}}, {_SLIT("))"), 0, { .d_c = 0 }}})));
	} else if (is_amp) {
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("), sizeof("), 0xfe10, {.d_s = styp}}, {_SLIT("))"), 0, { .d_c = 0 }}})));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_select_expr(v__gen__c__Gen* g, v__ast__SelectExpr node) {
	bool is_expr = node.is_expr || g->inside_ternary > 0;
	string _t1; /* if prepend */
	if (is_expr) {
		g->empty_line = true;
		_t1 = v__gen__c__Gen_go_before_stmt(g, 0);
	} else {
		_t1 = _SLIT("");
	}
	string cur_line =  _t1;
	int n_channels = (node.has_exception ? (node.branches.len - 1) : (node.branches.len));
	Array_v__ast__Expr channels = __new_array_with_default(0, n_channels, sizeof(v__ast__Expr), 0);
	Array_v__ast__Expr objs = __new_array_with_default(0, n_channels, sizeof(v__ast__Expr), 0);
	Array_string tmp_objs = __new_array_with_default(0, n_channels, sizeof(string), 0);
	Array_string elem_types = __new_array_with_default(0, n_channels, sizeof(string), 0);
	Array_bool is_push = __new_array_with_default(0, n_channels, sizeof(bool), 0);
	bool has_else = false;
	bool has_timeout = false;
	v__ast__Expr timeout_expr = v__ast__empty_expr();
	int exception_branch = -1;
	for (int j = 0; j < node.branches.len; ++j) {
		v__ast__SelectBranch branch = ((v__ast__SelectBranch*)node.branches.data)[j];
		if (branch.is_else) {
			has_else = true;
			exception_branch = j;
		} else if (branch.is_timeout) {
			has_timeout = true;
			exception_branch = j;
			timeout_expr = (/* as */ *(v__ast__ExprStmt*)__as_cast((branch.stmt)._v__ast__ExprStmt,(branch.stmt)._typ, 339) /*expected idx: 339, name: v.ast.ExprStmt */ ).expr;
		} else {
			if (branch.stmt._typ == 339 /* v.ast.ExprStmt */) {
				v__ast__InfixExpr expr = /* as */ *(v__ast__InfixExpr*)__as_cast(((*branch.stmt._v__ast__ExprStmt).expr)._v__ast__InfixExpr,((*branch.stmt._v__ast__ExprStmt).expr)._typ, 303) /*expected idx: 303, name: v.ast.InfixExpr */ ;
				array_push((array*)&channels, _MOV((v__ast__Expr[]){ expr.left }));
				if ((expr.right)._typ == 299 /* v.ast.Ident */ || (expr.right)._typ == 302 /* v.ast.IndexExpr */ || (expr.right)._typ == 319 /* v.ast.SelectorExpr */ || (expr.right)._typ == 324 /* v.ast.StructInit */) {
					array_push((array*)&objs, _MOV((v__ast__Expr[]){ expr.right }));
					array_push((array*)&tmp_objs, _MOV((string[]){ string_clone(_SLIT("")) }));
					array_push((array*)&elem_types, _MOV((string[]){ string_clone(_SLIT("")) }));
				} else {
					array_push((array*)&objs, _MOV((v__ast__Expr[]){ v__ast__empty_expr() }));
					string tmp_obj = v__gen__c__Gen_new_tmp_var(g);
					array_push((array*)&tmp_objs, _MOV((string[]){ string_clone(tmp_obj) }));
					string el_stype = v__gen__c__Gen_typ(g, v__ast__mktyp(expr.right_type));
					v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = el_stype}}, {_SLIT(" "), 0xfe10, {.d_s = tmp_obj}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
				}
				array_push((array*)&is_push, _MOV((bool[]){ true }));
			}
			else if (branch.stmt._typ == 331 /* v.ast.AssignStmt */) {
				v__ast__PrefixExpr rec_expr = /* as */ *(v__ast__PrefixExpr*)__as_cast(((*(v__ast__Expr*)/*ee elem_typ */array_get((*branch.stmt._v__ast__AssignStmt).right, 0)))._v__ast__PrefixExpr,((*(v__ast__Expr*)/*ee elem_typ */array_get((*branch.stmt._v__ast__AssignStmt).right, 0)))._typ, 316) /*expected idx: 316, name: v.ast.PrefixExpr */ ;
				array_push((array*)&channels, _MOV((v__ast__Expr[]){ rec_expr.right }));
				array_push((array*)&is_push, _MOV((bool[]){ false }));
				if ((*branch.stmt._v__ast__AssignStmt).op == v__token__Kind__decl_assign || !v__ast__Type_alias_eq((*(v__ast__Type*)/*ee elem_typ */array_get((*branch.stmt._v__ast__AssignStmt).right_types, 0)), (*(v__ast__Type*)/*ee elem_typ */array_get((*branch.stmt._v__ast__AssignStmt).left_types, 0)))) {
					string tmp_obj = v__gen__c__Gen_new_tmp_var(g);
					array_push((array*)&tmp_objs, _MOV((string[]){ string_clone(tmp_obj) }));
					string el_stype = v__gen__c__Gen_typ(g, (*(v__ast__Type*)/*ee elem_typ */array_get((*branch.stmt._v__ast__AssignStmt).right_types, 0)));
					array_push((array*)&elem_types, _MOV((string[]){ string_clone(((*branch.stmt._v__ast__AssignStmt).op == v__token__Kind__decl_assign ? (string__plus(el_stype, _SLIT(" "))) : (_SLIT("")))) }));
					v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = el_stype}}, {_SLIT(" "), 0xfe10, {.d_s = tmp_obj}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
				} else {
					array_push((array*)&tmp_objs, _MOV((string[]){ string_clone(_SLIT("")) }));
					array_push((array*)&elem_types, _MOV((string[]){ string_clone(_SLIT("")) }));
				}
				array_push((array*)&objs, _MOV((v__ast__Expr[]){ (*(v__ast__Expr*)/*ee elem_typ */array_get((*branch.stmt._v__ast__AssignStmt).left, 0)) }));
			}
			
			else {
			}
			;
		}
	}
	string chan_array = v__gen__c__Gen_new_tmp_var(g);
	v__gen__c__Gen_write(g,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("Array_sync__Channel_ptr "), 0xfe10, {.d_s = chan_array}}, {_SLIT(" = new_array_from_c_array("), 0xfe07, {.d_i32 = n_channels}}, {_SLIT(", "), 0xfe07, {.d_i32 = n_channels}}, {_SLIT(", sizeof(sync__Channel*), _MOV((sync__Channel*["), 0xfe07, {.d_i32 = n_channels}}, {_SLIT("]){"), 0, { .d_c = 0 }}})));
	for (int i = 0; i < n_channels; ++i) {
		if (i > 0) {
			v__gen__c__Gen_write(g, _SLIT(", "));
		}
		v__gen__c__Gen_write(g, _SLIT("(sync__Channel*)("));
		v__gen__c__Gen_expr(g, (*(v__ast__Expr*)/*ee elem_typ */array_get(channels, i)));
		v__gen__c__Gen_write(g, _SLIT(")"));
	}
	v__gen__c__Gen_writeln(g, _SLIT("}));\n"));
	string directions_array = v__gen__c__Gen_new_tmp_var(g);
	v__gen__c__Gen_write(g,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("Array_sync__Direction "), 0xfe10, {.d_s = directions_array}}, {_SLIT(" = new_array_from_c_array("), 0xfe07, {.d_i32 = n_channels}}, {_SLIT(", "), 0xfe07, {.d_i32 = n_channels}}, {_SLIT(", sizeof(sync__Direction), _MOV((sync__Direction["), 0xfe07, {.d_i32 = n_channels}}, {_SLIT("]){"), 0, { .d_c = 0 }}})));
	for (int i = 0; i < n_channels; ++i) {
		if (i > 0) {
			v__gen__c__Gen_write(g, _SLIT(", "));
		}
		if ((*(bool*)/*ee elem_typ */array_get(is_push, i))) {
			v__gen__c__Gen_write(g, _SLIT("sync__Direction__push"));
		} else {
			v__gen__c__Gen_write(g, _SLIT("sync__Direction__pop"));
		}
	}
	v__gen__c__Gen_writeln(g, _SLIT("}));\n"));
	string objs_array = v__gen__c__Gen_new_tmp_var(g);
	v__gen__c__Gen_write(g,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("Array_voidptr "), 0xfe10, {.d_s = objs_array}}, {_SLIT(" = new_array_from_c_array("), 0xfe07, {.d_i32 = n_channels}}, {_SLIT(", "), 0xfe07, {.d_i32 = n_channels}}, {_SLIT(", sizeof(voidptr), _MOV((voidptr["), 0xfe07, {.d_i32 = n_channels}}, {_SLIT("]){"), 0, { .d_c = 0 }}})));
	for (int i = 0; i < n_channels; ++i) {
		if (i > 0) {
			v__gen__c__Gen_write(g, _SLIT(", &"));
		} else {
			v__gen__c__Gen_write(g, _SLIT("&"));
		}
		if (((*(string*)/*ee elem_typ */array_get(tmp_objs, i))).len == 0) {
			v__gen__c__Gen_expr(g, (*(v__ast__Expr*)/*ee elem_typ */array_get(objs, i)));
		} else {
			v__gen__c__Gen_write(g, (*(string*)/*ee elem_typ */array_get(tmp_objs, i)));
		}
	}
	v__gen__c__Gen_writeln(g, _SLIT("}));\n"));
	string select_result = v__gen__c__Gen_new_tmp_var(g);
	v__gen__c__Gen_write(g,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("int "), 0xfe10, {.d_s = select_result}}, {_SLIT(" = sync__channel_select(&/*arr*/"), 0xfe10, {.d_s = chan_array}}, {_SLIT(", "), 0xfe10, {.d_s = directions_array}}, {_SLIT(", &/*arr*/"), 0xfe10, {.d_s = objs_array}}, {_SLIT(", "), 0, { .d_c = 0 }}})));
	if (has_timeout) {
		v__gen__c__Gen_expr(g, timeout_expr);
	} else if (has_else) {
		v__gen__c__Gen_write(g, _SLIT("0"));
	} else {
		v__gen__c__Gen_write(g, _SLIT("_const_time__infinite"));
	}
	v__gen__c__Gen_writeln(g, _SLIT(");"));
	v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("array_free(&"), 0xfe10, {.d_s = objs_array}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("array_free(&"), 0xfe10, {.d_s = directions_array}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("array_free(&"), 0xfe10, {.d_s = chan_array}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
	int i = 0;
	for (int j = 0; j < node.branches.len; ++j) {
		if (j > 0) {
			v__gen__c__Gen_write(g, _SLIT("} else "));
		}
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("if ("), 0xfe10, {.d_s = select_result}}, {_SLIT(" == "), 0, { .d_c = 0 }}})));
		if (j == exception_branch) {
			v__gen__c__Gen_writeln(g, _SLIT("-1) {"));
		} else {
			v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = i}}, {_SLIT(") {"), 0, { .d_c = 0 }}})));
			if (!(*(bool*)/*ee elem_typ */array_get(is_push, i)) && ((*(string*)/*ee elem_typ */array_get(tmp_objs, i))).len != 0) {
				v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = (*(string*)/*ee elem_typ */array_get(elem_types, i))}}, {_SLIT0, 0, { .d_c = 0 }}})));
				v__gen__c__Gen_expr(g, (*(v__ast__Expr*)/*ee elem_typ */array_get(objs, i)));
				v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(" = "), 0xfe10, {.d_s = (*(string*)/*ee elem_typ */array_get(tmp_objs, i))}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
			}
			i++;
		}
		v__gen__c__Gen_stmts(g, (*(v__ast__SelectBranch*)/*ee elem_typ */array_get(node.branches, j)).stmts);
	}
	v__gen__c__Gen_writeln(g, _SLIT("}"));
	if (is_expr) {
		g->empty_line = false;
		v__gen__c__Gen_write(g, cur_line);
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("("), 0xfe10, {.d_s = select_result}}, {_SLIT(" != -2)"), 0, { .d_c = 0 }}})));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_ident(v__gen__c__Gen* g, v__ast__Ident node) {
	bool prevent_sum_type_unwrapping_once = g->prevent_sum_type_unwrapping_once;
	g->prevent_sum_type_unwrapping_once = false;
	if (string__eq(node.name, _SLIT("lld"))) {
		return;
	}
	if (string_starts_with(node.name, _SLIT("C."))) {
		v__gen__c__Gen_write(g, v__util__no_dots(string_substr(node.name, 2, node.name.len)));
		return;
	}
	if (node.kind == v__ast__IdentKind__constant) {
		v__gen__c__Gen_write(g, _SLIT("_const_"));
	}
	string name = v__gen__c__c_name(node.name);
	v__ast__IdentInfo node_info = node.info;
	bool is_auto_heap = false;
	if ((node_info)._typ == 408 /* v.ast.IdentVar */) {
		if ((*node_info._v__ast__IdentVar).is_optional && !(g->is_assign_lhs && g->right_is_opt)) {
			v__gen__c__Gen_write(g, _SLIT("/*opt*/"));
			string styp = v__gen__c__Gen_base_type(g, (*node_info._v__ast__IdentVar).typ);
			v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("(*("), 0xfe10, {.d_s = styp}}, {_SLIT("*)"), 0xfe10, {.d_s = name}}, {_SLIT(".data)"), 0, { .d_c = 0 }}})));
			return;
		}
		if (!g->is_assign_lhs && (*node_info._v__ast__IdentVar).share == v__ast__ShareType__shared_t) {
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = name}}, {_SLIT(".val"), 0, { .d_c = 0 }}})));
			return;
		}
		v__ast__Scope* scope = v__ast__Scope_innermost(g->file->scope, node.pos.pos);
		Option_v__ast__Var_ptr _t1;
		if (_t1 = v__ast__Scope_find_var(scope, node.name), _t1.state == 0) {
			v__ast__Var* v = *(v__ast__Var**)_t1.data;
			is_auto_heap = v->is_auto_heap && (!g->is_assign_lhs || g->assign_op != v__token__Kind__decl_assign);
			if (is_auto_heap) {
				v__gen__c__Gen_write(g, _SLIT("(*("));
			}
			if (v->smartcasts.len > 0) {
				v__ast__TypeSymbol* v_sym = v__ast__Table_sym(g->table, v->typ);
				if (!prevent_sum_type_unwrapping_once) {
					for (int _t2 = 0; _t2 < v->smartcasts.len; ++_t2) {
						v__gen__c__Gen_write(g, _SLIT("("));
						if (v_sym->kind == v__ast__Kind__sum_type && !is_auto_heap) {
							v__gen__c__Gen_write(g, _SLIT("*"));
						}
					}
					for (int i = 0; i < v->smartcasts.len; ++i) {
						v__ast__Type typ = ((v__ast__Type*)v->smartcasts.data)[i];
						v__ast__TypeSymbol* cast_sym = v__ast__Table_sym(g->table, v__gen__c__Gen_unwrap_generic(g, typ));
						bool is_ptr = false;
						if (i == 0) {
							v__gen__c__Gen_write(g, name);
							if (v__ast__Type_is_ptr(v->orig_type)) {
								is_ptr = true;
							}
						}
						string dot = (is_ptr || is_auto_heap ? (_SLIT("->")) : (_SLIT(".")));
						if ((cast_sym->info)._typ == 458 /* v.ast.Aggregate */) {
							v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, (*(v__ast__Type*)/*ee elem_typ */array_get((*cast_sym->info._v__ast__Aggregate).types, g->aggregate_type_idx)));
							v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = dot}}, {_SLIT("_"), 0xfe10, {.d_s = sym->cname}}, {_SLIT0, 0, { .d_c = 0 }}})));
						} else {
							v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = dot}}, {_SLIT("_"), 0xfe10, {.d_s = cast_sym->cname}}, {_SLIT0, 0, { .d_c = 0 }}})));
						}
						v__gen__c__Gen_write(g, _SLIT(")"));
					}
					if (is_auto_heap) {
						v__gen__c__Gen_write(g, _SLIT("))"));
					}
					return;
				}
			}
			if (v->is_inherited) {
				v__gen__c__Gen_write(g, string__plus(_const_v__gen__c__closure_ctx, _SLIT("->")));
			}
		}
	} else if ((node_info)._typ == 407 /* v.ast.IdentFn */) {
		if (g->pref->translated) {
			Option_v__ast__Fn _t3;
			if (_t3 = v__ast__Table_find_fn(g->table, node.name), _t3.state == 0) {
				v__ast__Fn f = *(v__ast__Fn*)_t3.data;
				if (Array_v__ast__Attr_contains(f.attrs, _SLIT("c"))) {
					name = (*(v__ast__Attr*)/*ee elem_typ */array_get(f.attrs, 0)).arg;
				}
			}
		}
		if (g->pref->obfuscate && string__eq(g->cur_mod.name, _SLIT("main")) && string_starts_with(name, _SLIT("main__"))) {
			string key = node.name;
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("/* obf identfn: "), 0xfe10, {.d_s = key}}, {_SLIT(" */"), 0, { .d_c = 0 }}})));
			string* _t5 = (string*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, g->obf_table), &(string[]){key}));
			Option_string _t4 = {0};
			if (_t5) {
				*((string*)&_t4.data) = *((string*)_t5);
			} else {
				_t4.state = 2; _t4.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t4.state != 0) { /*or block*/ 
				IError err = _t4.err;
				_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("cgen: obf name \""), 0xfe10, {.d_s = key}}, {_SLIT("\" not found, this should never happen"), 0, { .d_c = 0 }}})));
				VUNREACHABLE();
			;
			}
			
			name = *(string*)_t4.data;
		}
	}
	v__gen__c__Gen_write(g, v__gen__c__Gen_get_ternary_name(g, name));
	if (is_auto_heap) {
		v__gen__c__Gen_write(g, _SLIT("))"));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_cast_expr(v__gen__c__Gen* g, v__ast__CastExpr node) {
	if (g->is_amp) {
		strings__Builder_go_back(&g->out, 1);
	}
	g->is_amp = false;
	v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, node.typ);
	if (sym->kind == v__ast__Kind__sum_type || sym->kind == v__ast__Kind__interface_) {
		v__gen__c__Gen_expr_with_cast(g, node.expr, node.expr_type, node.typ);
	} else if (sym->kind == v__ast__Kind__struct_ && !v__ast__Type_is_ptr(node.typ) && !(/* as */ *(v__ast__Struct*)__as_cast((sym->info)._v__ast__Struct,(sym->info)._typ, 446) /*expected idx: 446, name: v.ast.Struct */ ).is_typedef) {
		string styp = v__gen__c__Gen_typ(g, node.typ);
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("*(("), 0xfe10, {.d_s = styp}}, {_SLIT(" *)(&"), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_expr(g, node.expr);
		v__gen__c__Gen_write(g, _SLIT("))"));
	} else if (sym->kind == v__ast__Kind__alias && v__ast__Table_final_sym(g->table, node.typ)->kind == v__ast__Kind__array_fixed) {
		v__gen__c__Gen_expr(g, node.expr);
	} else {
		string styp = v__gen__c__Gen_typ(g, node.typ);
		if (g->pref->translated && sym->kind == v__ast__Kind__function) {
		}
		string cast_label = _SLIT("");
		if (sym->kind != v__ast__Kind__alias || !((/* as */ *(v__ast__Alias*)__as_cast((sym->info)._v__ast__Alias,(sym->info)._typ, 460) /*expected idx: 460, name: v.ast.Alias */ ).parent_type == node.expr_type || (/* as */ *(v__ast__Alias*)__as_cast((sym->info)._v__ast__Alias,(sym->info)._typ, 460) /*expected idx: 460, name: v.ast.Alias */ ).parent_type == _const_v__ast__string_type)) {
			cast_label =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT(")"), 0, { .d_c = 0 }}}));
		}
		if (v__ast__Type_has_flag(node.typ, v__ast__TypeFlag__optional) && (node.expr)._typ == 311 /* v.ast.None */) {
			v__gen__c__Gen_gen_optional_error(g, node.typ, node.expr);
		} else {
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("("), 0xfe10, {.d_s = cast_label}}, {_SLIT("("), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_expr(g, node.expr);
			if ((node.expr)._typ == 304 /* v.ast.IntegerLiteral */) {
				if (node.typ == _const_v__ast__u64_type || node.typ == _const_v__ast__u32_type || node.typ == _const_v__ast__u16_type) {
					if (!string_starts_with((*node.expr._v__ast__IntegerLiteral).val, _SLIT("-"))) {
						v__gen__c__Gen_write(g, _SLIT("U"));
					}
				}
			}
			v__gen__c__Gen_write(g, _SLIT("))"));
		}
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_concat_expr(v__gen__c__Gen* g, v__ast__ConcatExpr node) {
	string styp = v__gen__c__Gen_typ(g, node.return_type);
	if (g->inside_return) {
		styp = v__gen__c__Gen_typ(g, g->fn_decl->return_type);
	}
	v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, node.return_type);
	bool is_multi = sym->kind == v__ast__Kind__multi_return;
	if (!is_multi) {
		v__gen__c__Gen_expr(g, (*(v__ast__Expr*)/*ee elem_typ */array_get(node.vals, 0)));
	} else {
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT("){"), 0, { .d_c = 0 }}})));
		for (int i = 0; i < node.vals.len; ++i) {
			v__ast__Expr expr = ((v__ast__Expr*)node.vals.data)[i];
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(".arg"), 0xfe07, {.d_i32 = i}}, {_SLIT("="), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_expr(g, expr);
			if (i < node.vals.len - 1) {
				v__gen__c__Gen_write(g, _SLIT(","));
			}
		}
		v__gen__c__Gen_write(g, _SLIT("}"));
	}
}

VV_LOCAL_SYMBOL bool v__gen__c__Gen_need_tmp_var_in_if(v__gen__c__Gen* g, v__ast__IfExpr node) {
	if (node.is_expr && g->inside_ternary == 0) {
		if (g->is_autofree || v__ast__Type_has_flag(node.typ, v__ast__TypeFlag__optional)) {
			bool _t1 = true;
			return _t1;
		}
		for (int _t2 = 0; _t2 < node.branches.len; ++_t2) {
			v__ast__IfBranch branch = ((v__ast__IfBranch*)node.branches.data)[_t2];
			if ((branch.cond)._typ == 301 /* v.ast.IfGuardExpr */ || branch.stmts.len > 1) {
				bool _t3 = true;
				return _t3;
			}
			if (branch.stmts.len == 1) {
				if (((*(v__ast__Stmt*)/*ee elem_typ */array_get(branch.stmts, 0)))._typ == 339 /* v.ast.ExprStmt */) {
					v__ast__ExprStmt stmt = /* as */ *(v__ast__ExprStmt*)__as_cast(((*(v__ast__Stmt*)/*ee elem_typ */array_get(branch.stmts, 0)))._v__ast__ExprStmt,((*(v__ast__Stmt*)/*ee elem_typ */array_get(branch.stmts, 0)))._typ, 339) /*expected idx: 339, name: v.ast.ExprStmt */ ;
					if (v__gen__c__is_noreturn_callexpr(stmt.expr)) {
						bool _t4 = true;
						return _t4;
					}
					if ((stmt.expr)._typ == 286 /* v.ast.CallExpr */) {
						if ((*stmt.expr._v__ast__CallExpr).is_method) {
							v__ast__TypeSymbol* left_sym = v__ast__Table_sym(g->table, (*stmt.expr._v__ast__CallExpr).receiver_type);
							if (left_sym->kind == v__ast__Kind__array || left_sym->kind == v__ast__Kind__array_fixed || left_sym->kind == v__ast__Kind__map) {
								bool _t5 = true;
								return _t5;
							}
						} else if ((*stmt.expr._v__ast__CallExpr).or_block.kind != v__ast__OrKind__absent) {
							bool _t6 = true;
							return _t6;
						}
					}
				}
			}
		}
	}
	bool _t7 = false;
	return _t7;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_if_expr(v__gen__c__Gen* g, v__ast__IfExpr node) {
	if (node.is_comptime) {
		v__gen__c__Gen_comptime_if(g, node);
		return;
	}
	bool needs_tmp_var = v__gen__c__Gen_need_tmp_var_in_if(g, node);
	string tmp = (needs_tmp_var ? (v__gen__c__Gen_new_tmp_var(g)) : (_SLIT("")));
	string cur_line = _SLIT("");
	if (needs_tmp_var) {
		if (v__ast__Type_has_flag(node.typ, v__ast__TypeFlag__optional)) {
			g->inside_if_optional = true;
		}
		string styp = v__gen__c__Gen_typ(g, node.typ);
		cur_line = v__gen__c__Gen_go_before_stmt(g, 0);
		g->empty_line = true;
		v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = styp}}, {_SLIT(" "), 0xfe10, {.d_s = tmp}}, {_SLIT("; /* if prepend */"), 0, { .d_c = 0 }}})));
		if (g->infix_left_var_name.len > 0) {
			v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("if ("), 0xfe10, {.d_s = g->infix_left_var_name}}, {_SLIT(") {"), 0, { .d_c = 0 }}})));
			g->indent++;
		}
	} else if (node.is_expr || g->inside_ternary != 0) {
		g->inside_ternary++;
		v__gen__c__Gen_write(g, _SLIT("("));
		for (int i = 0; i < node.branches.len; ++i) {
			v__ast__IfBranch branch = ((v__ast__IfBranch*)node.branches.data)[i];
			if (i > 0) {
				v__gen__c__Gen_write(g, _SLIT(" : "));
			}
			if (i < node.branches.len - 1 || !node.has_else) {
				v__gen__c__Gen_expr(g, branch.cond);
				v__gen__c__Gen_write(g, _SLIT(" ? "));
			}
			v__gen__c__Gen_stmts(g, branch.stmts);
		}
		if (node.branches.len == 1) {
			v__gen__c__Gen_write(g, _SLIT(": 0"));
		}
		v__gen__c__Gen_write(g, _SLIT(")"));
		v__gen__c__Gen_decrement_inside_ternary(g);
		return;
	}
	bool is_guard = false;
	int guard_idx = 0;
	Array_string guard_vars = __new_array_with_default(0, 0, sizeof(string), 0);
	for (int i = 0; i < node.branches.len; ++i) {
		v__ast__IfBranch branch = ((v__ast__IfBranch*)node.branches.data)[i];
		v__ast__Expr cond = branch.cond;
		if ((cond)._typ == 301 /* v.ast.IfGuardExpr */) {
			if (!is_guard) {
				is_guard = true;
				guard_idx = i;
				guard_vars = __new_array_with_default(node.branches.len, 0, sizeof(string), &(string[]){_SLIT("")});
			}
			if (((*cond._v__ast__IfGuardExpr).expr)._typ != 302 /* v.ast.IndexExpr */ && ((*cond._v__ast__IfGuardExpr).expr)._typ != 316 /* v.ast.PrefixExpr */) {
				string var_name = v__gen__c__Gen_new_tmp_var(g);
				array_set(&guard_vars, i, &(string[]) { var_name });
				v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__gen__c__Gen_typ(g, (*cond._v__ast__IfGuardExpr).expr_type)}}, {_SLIT(" "), 0xfe10, {.d_s = var_name}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
			} else {
				array_set(&guard_vars, i, &(string[]) { _SLIT("") });
			}
		}
	}
	for (int i = 0; i < node.branches.len; ++i) {
		v__ast__IfBranch branch = ((v__ast__IfBranch*)node.branches.data)[i];
		if (i > 0) {
			v__gen__c__Gen_write(g, _SLIT("} else "));
		}
		if (i == node.branches.len - 1 && node.has_else) {
			v__gen__c__Gen_writeln(g, _SLIT("{"));
			if (is_guard && guard_idx == i - 1) {
				string cvar_name = (*(string*)/*ee elem_typ */array_get(guard_vars, guard_idx));
				v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\tIError err = "), 0xfe10, {.d_s = cvar_name}}, {_SLIT(".err;"), 0, { .d_c = 0 }}})));
			}
		} else {
			if (branch.cond._typ == 301 /* v.ast.IfGuardExpr */) {
				string var_name = (*(string*)/*ee elem_typ */array_get(guard_vars, i));
				bool short_opt = false;
				if ((var_name).len == 0) {
					short_opt = true;
					var_name = v__gen__c__Gen_new_tmp_var(g);
					array_set(&guard_vars, i, &(string[]) { var_name });
					g->tmp_count--;
					v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("if ("), 0xfe10, {.d_s = var_name}}, {_SLIT(".state == 0) {"), 0, { .d_c = 0 }}})));
				} else {
					v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("if ("), 0xfe10, {.d_s = var_name}}, {_SLIT(" = "), 0, { .d_c = 0 }}})));
					v__gen__c__Gen_expr(g, (*branch.cond._v__ast__IfGuardExpr).expr);
					v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(", "), 0xfe10, {.d_s = var_name}}, {_SLIT(".state == 0) {"), 0, { .d_c = 0 }}})));
				}
				if (short_opt || !string__eq((*branch.cond._v__ast__IfGuardExpr).var_name, _SLIT("_"))) {
					string base_type = v__gen__c__Gen_base_type(g, (*branch.cond._v__ast__IfGuardExpr).expr_type);
					if (short_opt) {
						string cond_var_name = (string__eq((*branch.cond._v__ast__IfGuardExpr).var_name, _SLIT("_")) ? ( str_intp(2, _MOV((StrIntpData[]){{_SLIT("_dummy_"), 0xfe07, {.d_i32 = g->tmp_count + 1}}, {_SLIT0, 0, { .d_c = 0 }}}))) : ((*branch.cond._v__ast__IfGuardExpr).var_name));
						v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = base_type}}, {_SLIT(" "), 0xfe10, {.d_s = cond_var_name}}, {_SLIT(" = "), 0, { .d_c = 0 }}})));
						v__gen__c__Gen_expr(g, (*branch.cond._v__ast__IfGuardExpr).expr);
						v__gen__c__Gen_writeln(g, _SLIT(";"));
					} else {
						bool is_auto_heap = false;
						if (branch.stmts.len > 0) {
							v__ast__Scope* scope = v__ast__Scope_innermost(g->file->scope, v__ast__Node_position(v__ast__Stmt_to_sumtype_v__ast__Node(&(*(v__ast__Stmt*)/*ee elem_typ */array_get(branch.stmts, branch.stmts.len - 1)))).pos);
							Option_v__ast__Var_ptr _t1;
							if (_t1 = v__ast__Scope_find_var(scope, (*branch.cond._v__ast__IfGuardExpr).var_name), _t1.state == 0) {
								v__ast__Var* v = *(v__ast__Var**)_t1.data;
								is_auto_heap = v->is_auto_heap;
							}
						}
						string left_var_name = v__gen__c__c_name((*branch.cond._v__ast__IfGuardExpr).var_name);
						if (is_auto_heap) {
							v__gen__c__Gen_writeln(g,  str_intp(6, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = base_type}}, {_SLIT("* "), 0xfe10, {.d_s = left_var_name}}, {_SLIT(" = HEAP("), 0xfe10, {.d_s = base_type}}, {_SLIT(", *("), 0xfe10, {.d_s = base_type}}, {_SLIT("*)"), 0xfe10, {.d_s = var_name}}, {_SLIT(".data);"), 0, { .d_c = 0 }}})));
						} else {
							v__gen__c__Gen_writeln(g,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = base_type}}, {_SLIT(" "), 0xfe10, {.d_s = left_var_name}}, {_SLIT(" = *("), 0xfe10, {.d_s = base_type}}, {_SLIT("*)"), 0xfe10, {.d_s = var_name}}, {_SLIT(".data;"), 0, { .d_c = 0 }}})));
						}
					}
				}
			}
			
			else {
				bool no_needs_par = false;
				if ((branch.cond)._typ == 303 /* v.ast.InfixExpr */) {
					if ((*branch.cond._v__ast__InfixExpr).op == v__token__Kind__key_in && ((*branch.cond._v__ast__InfixExpr).left)._typ != 303 /* v.ast.InfixExpr */ && ((*branch.cond._v__ast__InfixExpr).right)._typ == 280 /* v.ast.ArrayInit */) {
						no_needs_par = true;
					}
				}
				if (no_needs_par) {
					v__gen__c__Gen_write(g, _SLIT("if "));
				} else {
					v__gen__c__Gen_write(g, _SLIT("if ("));
				}
				v__gen__c__Gen_expr(g, branch.cond);
				if (no_needs_par) {
					v__gen__c__Gen_writeln(g, _SLIT(" {"));
				} else {
					v__gen__c__Gen_writeln(g, _SLIT(") {"));
				}
			}
			;
		}
		if (needs_tmp_var) {
			v__gen__c__Gen_stmts_with_tmp_var(g, branch.stmts, tmp);
		} else {
			int stmt_pos = v__gen__c__Gen_nth_stmt_pos(g, 0);
			v__gen__c__Gen_stmts(g, branch.stmts);
			array_push((array*)&g->stmt_path_pos, _MOV((int[]){ stmt_pos }));
		}
	}
	if (node.branches.len > 0) {
		v__gen__c__Gen_writeln(g, _SLIT("}"));
	}
	v__gen__c__Gen_set_current_pos_as_last_stmt_pos(g);
	if (needs_tmp_var) {
		if (g->infix_left_var_name.len > 0) {
			g->indent--;
			v__gen__c__Gen_writeln(g, _SLIT("}"));
		}
		g->empty_line = false;
		v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = cur_line}}, {_SLIT(" "), 0xfe10, {.d_s = tmp}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
	if (v__ast__Type_has_flag(node.typ, v__ast__TypeFlag__optional)) {
		g->inside_if_optional = false;
	}
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL bool v__gen__c__Gen_expr_is_multi_return_call(v__gen__c__Gen* g, v__ast__Expr expr) {
	if (expr._typ == 286 /* v.ast.CallExpr */) {
		bool _t1 = v__ast__Table_sym(g->table, (*expr._v__ast__CallExpr).return_type)->kind == v__ast__Kind__multi_return;
		return _t1;
	}
	
	else {
		bool _t2 = false;
		return _t2;
	}
	;
	return 0;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_optional_error(v__gen__c__Gen* g, v__ast__Type target_type, v__ast__Expr expr) {
	string styp = v__gen__c__Gen_typ(g, target_type);
	v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT("){ .state=2, .err="), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_expr(g, expr);
	v__gen__c__Gen_write(g, _SLIT(", .data={EMPTY_STRUCT_INITIALIZATION} }"));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_return_stmt(v__gen__c__Gen* g, v__ast__Return node) {
bool v__gen__c__Gen_return_stmt_defer_0 = false;
	v__gen__c__Gen_write_v_source_line_info(g, node.pos);
	g->inside_return = true;
	v__gen__c__Gen_return_stmt_defer_0 = true;
	if (node.exprs.len > 0) {
		if (((*(v__ast__Expr*)/*ee elem_typ */array_get(node.exprs, 0)))._typ == 291 /* v.ast.ComptimeCall */) {
			v__gen__c__Gen_expr(g, (*(v__ast__Expr*)/*ee elem_typ */array_get(node.exprs, 0)));
			v__gen__c__Gen_writeln(g, _SLIT(";"));
			// Defer begin
			if (v__gen__c__Gen_return_stmt_defer_0) {
				g->inside_return = false;
			}
			// Defer end
			return;
		}
	}
	v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, g->fn_decl->return_type);
	bool fn_return_is_multi = sym->kind == v__ast__Kind__multi_return;
	bool fn_return_is_optional = v__ast__Type_has_flag(g->fn_decl->return_type, v__ast__TypeFlag__optional);
	bool has_semicolon = false;
	if (node.exprs.len == 0) {
		v__gen__c__Gen_write_defer_stmts_when_needed(g);
		if (fn_return_is_optional) {
			string styp = v__gen__c__Gen_typ(g, g->fn_decl->return_type);
			v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("return ("), 0xfe10, {.d_s = styp}}, {_SLIT("){0};"), 0, { .d_c = 0 }}})));
		} else {
			if (g->is_autofree) {
				;
				v__gen__c__Gen_autofree_scope_vars(g, node.pos.pos - 1, node.pos.line_nr, true);
			}
			v__gen__c__Gen_writeln(g, _SLIT("return;"));
		}
		// Defer begin
		if (v__gen__c__Gen_return_stmt_defer_0) {
			g->inside_return = false;
		}
		// Defer end
		return;
	}
	string tmpvar = v__gen__c__Gen_new_tmp_var(g);
	string ret_typ = v__gen__c__Gen_typ(g, g->fn_decl->return_type);
	bool use_tmp_var = g->defer_stmts.len > 0 || g->defer_profile_code.len > 0;
	if (fn_return_is_optional) {
		bool optional_none = ((*(v__ast__Expr*)/*ee elem_typ */array_get(node.exprs, 0)))._typ == 311 /* v.ast.None */;
		string ftyp = v__gen__c__Gen_typ(g, (*(v__ast__Type*)/*ee elem_typ */array_get(node.types, 0)));
		bool is_regular_option = string__eq(ftyp, _SLIT("Option"));
		if (optional_none || is_regular_option || (*(v__ast__Type*)/*ee elem_typ */array_get(node.types, 0)) == _const_v__ast__error_type_idx) {
			if (!isnil(g->fn_decl) && g->fn_decl->is_test) {
				string test_error_var = v__gen__c__Gen_new_tmp_var(g);
				v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ret_typ}}, {_SLIT(" "), 0xfe10, {.d_s = test_error_var}}, {_SLIT(" = "), 0, { .d_c = 0 }}})));
				v__gen__c__Gen_gen_optional_error(g, g->fn_decl->return_type, (*(v__ast__Expr*)/*ee elem_typ */array_get(node.exprs, 0)));
				v__gen__c__Gen_writeln(g, _SLIT(";"));
				v__gen__c__Gen_write_defer_stmts_when_needed(g);
				v__gen__c__Gen_gen_failing_return_error_for_test_fn(g, node, test_error_var);
				// Defer begin
				if (v__gen__c__Gen_return_stmt_defer_0) {
					g->inside_return = false;
				}
				// Defer end
				return;
			}
			if (use_tmp_var) {
				v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ret_typ}}, {_SLIT(" "), 0xfe10, {.d_s = tmpvar}}, {_SLIT(" = "), 0, { .d_c = 0 }}})));
			} else {
				v__gen__c__Gen_write(g, _SLIT("return "));
			}
			v__gen__c__Gen_gen_optional_error(g, g->fn_decl->return_type, (*(v__ast__Expr*)/*ee elem_typ */array_get(node.exprs, 0)));
			v__gen__c__Gen_writeln(g, _SLIT(";"));
			if (use_tmp_var) {
				v__gen__c__Gen_write_defer_stmts_when_needed(g);
				v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("return "), 0xfe10, {.d_s = tmpvar}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
			}
			// Defer begin
			if (v__gen__c__Gen_return_stmt_defer_0) {
				g->inside_return = false;
			}
			// Defer end
			return;
		}
	}
	if (fn_return_is_multi && node.exprs.len > 0 && !v__gen__c__Gen_expr_is_multi_return_call(g, (*(v__ast__Expr*)/*ee elem_typ */array_get(node.exprs, 0)))) {
		if (node.exprs.len == 1 && (((*(v__ast__Expr*)/*ee elem_typ */array_get(node.exprs, 0)))._typ == 300 /* v.ast.IfExpr */ || ((*(v__ast__Expr*)/*ee elem_typ */array_get(node.exprs, 0)))._typ == 309 /* v.ast.MatchExpr */)) {
			v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ret_typ}}, {_SLIT(" "), 0xfe10, {.d_s = tmpvar}}, {_SLIT(" = "), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_expr(g, (*(v__ast__Expr*)/*ee elem_typ */array_get(node.exprs, 0)));
			v__gen__c__Gen_writeln(g, _SLIT(";"));
			v__gen__c__Gen_write_defer_stmts_when_needed(g);
			v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("return "), 0xfe10, {.d_s = tmpvar}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
			// Defer begin
			if (v__gen__c__Gen_return_stmt_defer_0) {
				g->inside_return = false;
			}
			// Defer end
			return;
		}
		v__ast__TypeSymbol* typ_sym = v__ast__Table_sym(g->table, g->fn_decl->return_type);
		v__ast__MultiReturn mr_info = /* as */ *(v__ast__MultiReturn*)__as_cast((typ_sym->info)._v__ast__MultiReturn,(typ_sym->info)._typ, 471) /*expected idx: 471, name: v.ast.MultiReturn */ ;
		string styp = _SLIT("");
		if (fn_return_is_optional) {
			v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ret_typ}}, {_SLIT(" "), 0xfe10, {.d_s = tmpvar}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
			styp = v__gen__c__Gen_base_type(g, g->fn_decl->return_type);
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("opt_ok(&("), 0xfe10, {.d_s = styp}}, {_SLIT("/*X*/[]) { "), 0, { .d_c = 0 }}})));
		} else {
			if (use_tmp_var) {
				v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ret_typ}}, {_SLIT(" "), 0xfe10, {.d_s = tmpvar}}, {_SLIT(" = "), 0, { .d_c = 0 }}})));
			} else {
				v__gen__c__Gen_write(g, _SLIT("return "));
			}
			styp = v__gen__c__Gen_typ(g, g->fn_decl->return_type);
		}
		string multi_unpack = _SLIT("");
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT("){"), 0, { .d_c = 0 }}})));
		int arg_idx = 0;
		for (int i = 0; i < node.exprs.len; ++i) {
			v__ast__Expr expr = ((v__ast__Expr*)node.exprs.data)[i];
			if (v__gen__c__Gen_expr_is_multi_return_call(g, expr)) {
				v__ast__CallExpr c = /* as */ *(v__ast__CallExpr*)__as_cast((expr)._v__ast__CallExpr,(expr)._typ, 286) /*expected idx: 286, name: v.ast.CallExpr */ ;
				v__ast__TypeSymbol* expr_sym = v__ast__Table_sym(g->table, c.return_type);
				string tmp = v__gen__c__Gen_new_tmp_var(g);
				if (!v__ast__Type_has_flag(c.return_type, v__ast__TypeFlag__optional)) {
					string s = v__gen__c__Gen_go_before_stmt(g, 0);
					string expr_styp = v__gen__c__Gen_typ(g, c.return_type);
					v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = expr_styp}}, {_SLIT(" "), 0xfe10, {.d_s = tmp}}, {_SLIT("="), 0, { .d_c = 0 }}})));
					v__gen__c__Gen_expr(g, expr);
					v__gen__c__Gen_writeln(g, _SLIT(";"));
					multi_unpack = /*f*/string__plus(multi_unpack, v__gen__c__Gen_go_before_stmt(g, 0));
					v__gen__c__Gen_write(g, s);
				} else {
					string s = v__gen__c__Gen_go_before_stmt(g, 0);
					g->tmp_count--;
					v__gen__c__Gen_expr(g, expr);
					multi_unpack = /*f*/string__plus(multi_unpack, v__gen__c__Gen_go_before_stmt(g, 0));
					v__gen__c__Gen_write(g, s);
					string expr_styp = v__gen__c__Gen_base_type(g, c.return_type);
					tmp = ( str_intp(3, _MOV((StrIntpData[]){{_SLIT("/*opt*/(*("), 0xfe10, {.d_s = expr_styp}}, {_SLIT("*)"), 0xfe10, {.d_s = tmp}}, {_SLIT(".data)"), 0, { .d_c = 0 }}})));
				}
				Array_v__ast__Type expr_types = v__ast__TypeSymbol_mr_info(expr_sym).types;
				for (int j = 0; j < expr_types.len; ++j) {
					v__gen__c__Gen_write(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT(".arg"), 0xfe07, {.d_i32 = arg_idx}}, {_SLIT("="), 0xfe10, {.d_s = tmp}}, {_SLIT(".arg"), 0xfe07, {.d_i32 = j}}, {_SLIT0, 0, { .d_c = 0 }}})));
					if (j < expr_types.len || i < node.exprs.len - 1) {
						v__gen__c__Gen_write(g, _SLIT(","));
					}
					arg_idx++;
				}
				continue;
			}
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(".arg"), 0xfe07, {.d_i32 = arg_idx}}, {_SLIT("="), 0, { .d_c = 0 }}})));
			if (v__ast__Expr_is_auto_deref_var(expr)) {
				v__gen__c__Gen_write(g, _SLIT("*"));
			}
			if (v__ast__Table_sym(g->table, (*(v__ast__Type*)/*ee elem_typ */array_get(mr_info.types, i)))->kind == v__ast__Kind__sum_type || v__ast__Table_sym(g->table, (*(v__ast__Type*)/*ee elem_typ */array_get(mr_info.types, i)))->kind == v__ast__Kind__interface_) {
				v__gen__c__Gen_expr_with_cast(g, expr, (*(v__ast__Type*)/*ee elem_typ */array_get(node.types, i)), (*(v__ast__Type*)/*ee elem_typ */array_get(mr_info.types, i)));
			} else {
				v__gen__c__Gen_expr(g, expr);
			}
			arg_idx++;
			if (i < node.exprs.len - 1) {
				v__gen__c__Gen_write(g, _SLIT(", "));
			}
		}
		v__gen__c__Gen_write(g, _SLIT("}"));
		if (fn_return_is_optional) {
			v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT(" }, (Option*)(&"), 0xfe10, {.d_s = tmpvar}}, {_SLIT("), sizeof("), 0xfe10, {.d_s = styp}}, {_SLIT("));"), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_write_defer_stmts_when_needed(g);
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("return "), 0xfe10, {.d_s = tmpvar}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		if (multi_unpack.len > 0) {
			v__gen__c__Gen_insert_before_stmt(g, multi_unpack);
		}
		if (use_tmp_var && !fn_return_is_optional) {
			if (!has_semicolon) {
				v__gen__c__Gen_writeln(g, _SLIT(";"));
			}
			v__gen__c__Gen_write_defer_stmts_when_needed(g);
			v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("return "), 0xfe10, {.d_s = tmpvar}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
			has_semicolon = true;
		}
	} else if (node.exprs.len >= 1) {
		if (node.types.len == 0) {
			v__gen__c__Gen_checker_bug(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("node.exprs.len == "), 0xfe07, {.d_i32 = node.exprs.len}}, {_SLIT(" && node.types.len == 0"), 0, { .d_c = 0 }}})), node.pos);
		}
		v__ast__TypeSymbol* return_sym = v__ast__Table_sym(g->table, (*(v__ast__Type*)/*ee elem_typ */array_get(node.types, 0)));
		v__ast__Expr expr0 = (*(v__ast__Expr*)/*ee elem_typ */array_get(node.exprs, 0));
		bool _t1 = 0;
		if (expr0._typ == 286 /* v.ast.CallExpr */) {
			_t1 = v__ast__Type_has_flag((*expr0._v__ast__CallExpr).return_type, v__ast__TypeFlag__optional) && (*expr0._v__ast__CallExpr).or_block.kind == v__ast__OrKind__absent;
		}
		
		else {
			_t1 = v__ast__Type_has_flag((*(v__ast__Type*)/*ee elem_typ */array_get(node.types, 0)), v__ast__TypeFlag__optional);
		}
		bool expr_type_is_opt = _t1;
		if (fn_return_is_optional && !expr_type_is_opt && !string__eq(return_sym->name, _SLIT("Option"))) {
			string styp = v__gen__c__Gen_base_type(g, g->fn_decl->return_type);
			v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ret_typ}}, {_SLIT(" "), 0xfe10, {.d_s = tmpvar}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("opt_ok(&("), 0xfe10, {.d_s = styp}}, {_SLIT("[]) { "), 0, { .d_c = 0 }}})));
			if (!v__ast__Type_is_ptr(g->fn_decl->return_type) && v__ast__Type_is_ptr((*(v__ast__Type*)/*ee elem_typ */array_get(node.types, 0)))) {
				if (!(((*(v__ast__Expr*)/*ee elem_typ */array_get(node.exprs, 0)))._typ == 299 /* v.ast.Ident */ && !g->is_amp)) {
					v__gen__c__Gen_write(g, _SLIT("*"));
				}
			}
			for (int i = 0; i < node.exprs.len; ++i) {
				v__ast__Expr expr = ((v__ast__Expr*)node.exprs.data)[i];
				v__gen__c__Gen_expr_with_cast(g, expr, (*(v__ast__Type*)/*ee elem_typ */array_get(node.types, i)), v__ast__Type_clear_flag(g->fn_decl->return_type, v__ast__TypeFlag__optional));
				if (i < node.exprs.len - 1) {
					v__gen__c__Gen_write(g, _SLIT(", "));
				}
			}
			v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT(" }, (Option*)(&"), 0xfe10, {.d_s = tmpvar}}, {_SLIT("), sizeof("), 0xfe10, {.d_s = styp}}, {_SLIT("));"), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_write_defer_stmts_when_needed(g);
			v__gen__c__Gen_autofree_scope_vars(g, node.pos.pos - 1, node.pos.line_nr, true);
			v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("return "), 0xfe10, {.d_s = tmpvar}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
			// Defer begin
			if (v__gen__c__Gen_return_stmt_defer_0) {
				g->inside_return = false;
			}
			// Defer end
			return;
		}
		if (g->is_autofree) {
			v__ast__Expr expr = (*(v__ast__Expr*)/*ee elem_typ */array_get(node.exprs, 0));
			if ((expr)._typ == 299 /* v.ast.Ident */) {
				g->returned_var_name = (*expr._v__ast__Ident).name;
			}
		}
		use_tmp_var = use_tmp_var || !g->is_builtin_mod;
		if (use_tmp_var) {
			if (((*(v__ast__Expr*)/*ee elem_typ */array_get(node.exprs, 0)))._typ != 299 /* v.ast.Ident */ || use_tmp_var) {
				v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ret_typ}}, {_SLIT(" "), 0xfe10, {.d_s = tmpvar}}, {_SLIT(" = "), 0, { .d_c = 0 }}})));
			} else {
				use_tmp_var = false;
				v__gen__c__Gen_write_defer_stmts_when_needed(g);
				if (!g->is_builtin_mod) {
					v__gen__c__Gen_autofree_scope_vars(g, node.pos.pos - 1, node.pos.line_nr, true);
				}
				v__gen__c__Gen_write(g, _SLIT("return "));
			}
		} else {
			v__gen__c__Gen_autofree_scope_vars(g, node.pos.pos - 1, node.pos.line_nr, true);
			v__gen__c__Gen_write(g, _SLIT("return "));
		}
		if (v__ast__Expr_is_auto_deref_var(expr0)) {
			if (v__ast__Type_is_ptr(g->fn_decl->return_type)) {
				string var_str = v__gen__c__Gen_expr_string(g, expr0);
				v__gen__c__Gen_write(g, string_trim(var_str, _SLIT("&")));
			} else {
				v__gen__c__Gen_write(g, _SLIT("*"));
				v__gen__c__Gen_expr(g, expr0);
			}
		} else {
			v__gen__c__Gen_expr_with_cast(g, (*(v__ast__Expr*)/*ee elem_typ */array_get(node.exprs, 0)), (*(v__ast__Type*)/*ee elem_typ */array_get(node.types, 0)), g->fn_decl->return_type);
		}
		if (use_tmp_var) {
			v__gen__c__Gen_writeln(g, _SLIT(";"));
			has_semicolon = true;
			v__gen__c__Gen_write_defer_stmts_when_needed(g);
			if (!g->is_builtin_mod) {
				v__gen__c__Gen_autofree_scope_vars(g, node.pos.pos - 1, node.pos.line_nr, true);
			}
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("return "), 0xfe10, {.d_s = tmpvar}}, {_SLIT0, 0, { .d_c = 0 }}})));
			has_semicolon = false;
		}
	} else {
		println(_SLIT("this should never happen"));
		v__gen__c__Gen_write(g, _SLIT("/*F*/return"));
	}
	if (!has_semicolon) {
		v__gen__c__Gen_writeln(g, _SLIT(";"));
	}
// Defer begin
if (v__gen__c__Gen_return_stmt_defer_0) {
	g->inside_return = false;
}
// Defer end
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_const_decl(v__gen__c__Gen* g, v__ast__ConstDecl node) {
bool v__gen__c__Gen_const_decl_defer_0 = false;
	g->inside_const = true;
	v__gen__c__Gen_const_decl_defer_0 = true;
	for (int _t1 = 0; _t1 < node.fields.len; ++_t1) {
		v__ast__ConstField field = ((v__ast__ConstField*)node.fields.data)[_t1];
		if (g->pref->skip_unused) {
			if (!_IN_MAP(ADDR(string, field.name), ADDR(map, g->table->used_consts))) {
				continue;
			}
		}
		string name = v__gen__c__c_name(field.name);
		v__ast__Expr field_expr = field.expr;
		if (field.expr._typ == 280 /* v.ast.ArrayInit */) {
			if ((*field.expr._v__ast__ArrayInit).is_fixed) {
				string styp = v__gen__c__Gen_typ(g, (*field.expr._v__ast__ArrayInit).typ);
				if (g->pref->build_mode != v__pref__BuildMode__build_module) {
					string val = v__gen__c__Gen_expr_string(g, field.expr);
					strings__Builder_writeln(&g->definitions,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = styp}}, {_SLIT(" _const_"), 0xfe10, {.d_s = name}}, {_SLIT(" = "), 0xfe10, {.d_s = val}}, {_SLIT("; // fixed array const"), 0, { .d_c = 0 }}})));
				} else {
					strings__Builder_writeln(&g->definitions,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = styp}}, {_SLIT(" _const_"), 0xfe10, {.d_s = name}}, {_SLIT("; // fixed array const"), 0, { .d_c = 0 }}})));
				}
			} else {
				v__gen__c__Gen_const_decl_init_later(g, field.mod, name, field.expr, field.typ, false);
			}
		}
		else if (field.expr._typ == 323 /* v.ast.StringLiteral */) {
			strings__Builder_writeln(&g->definitions,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("string _const_"), 0xfe10, {.d_s = name}}, {_SLIT("; // a string literal, inited later"), 0, { .d_c = 0 }}})));
			if (g->pref->build_mode != v__pref__BuildMode__build_module) {
				string val = v__gen__c__Gen_expr_string(g, field.expr);
				strings__Builder_writeln(&g->stringliterals,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t_const_"), 0xfe10, {.d_s = name}}, {_SLIT(" = "), 0xfe10, {.d_s = val}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
			}
		}
		else if (field.expr._typ == 286 /* v.ast.CallExpr */) {
			if (v__ast__Type_has_flag((*field.expr._v__ast__CallExpr).return_type, v__ast__TypeFlag__optional)) {
				bool unwrap_option = (*field.expr._v__ast__CallExpr).or_block.kind != v__ast__OrKind__absent;
				v__gen__c__Gen_const_decl_init_later(g, field.mod, name, field.expr, field.typ, unwrap_option);
			} else {
				v__gen__c__Gen_const_decl_init_later(g, field.mod, name, field.expr, field.typ, false);
			}
		}
		
		else {
			bool use_cache_mode = g->pref->build_mode == v__pref__BuildMode__build_module || g->pref->use_cache;
			if (!use_cache_mode) {
				Option_v__ast__ComptTimeConstValue _t2;
				if (_t2 = v__ast__ConstField_comptime_expr_value(&field), _t2.state == 0) {
					v__ast__ComptTimeConstValue ct_value = *(v__ast__ComptTimeConstValue*)_t2.data;
					if (v__gen__c__Gen_const_decl_precomputed(g, field.mod, name, ct_value, field.typ)) {
						continue;
					}
				}
			}
			if (v__ast__ConstField_is_simple_define_const(&field)) {
				v__gen__c__Gen_const_decl_simple_define(g, name, v__gen__c__Gen_expr_string(g, field_expr));
			} else {
				v__gen__c__Gen_const_decl_init_later(g, field.mod, name, field.expr, field.typ, false);
			}
		}
		;
	}
// Defer begin
if (v__gen__c__Gen_const_decl_defer_0) {
	g->inside_const = false;
}
// Defer end
}

VV_LOCAL_SYMBOL bool v__gen__c__Gen_const_decl_precomputed(v__gen__c__Gen* g, string mod, string name, v__ast__ComptTimeConstValue ct_value, v__ast__Type typ) {
	string styp = v__gen__c__Gen_typ(g, typ);
	string cname =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("_const_"), 0xfe10, {.d_s = name}}, {_SLIT0, 0, { .d_c = 0 }}}));
	if (ct_value._typ == 5 /* i8 */) {
		v__gen__c__Gen_const_decl_write_precomputed(g, styp, cname, i8_str((*ct_value._i8)));
	}
	else if (ct_value._typ == 6 /* i16 */) {
		v__gen__c__Gen_const_decl_write_precomputed(g, styp, cname, i16_str((*ct_value._i16)));
	}
	else if (ct_value._typ == 7 /* int */) {
		v__gen__c__Gen_const_decl_write_precomputed(g, styp, cname, int_str((*ct_value._int)));
	}
	else if (ct_value._typ == 8 /* i64 */) {
		if (v__ast__Type_alias_eq(typ, _const_v__ast__i64_type)) {
			bool _t1 = false;
			return _t1;
		}
		if (v__ast__Type_alias_eq(typ, _const_v__ast__int_type)) {
			v__gen__c__Gen_const_decl_simple_define(g, name, i64_str((*ct_value._i64)));
			bool _t2 = true;
			return _t2;
		}
		if (v__ast__Type_alias_eq(typ, _const_v__ast__u64_type)) {
			v__gen__c__Gen_const_decl_write_precomputed(g, styp, cname, string__plus(i64_str((*ct_value._i64)), _SLIT("U")));
		} else {
			v__gen__c__Gen_const_decl_write_precomputed(g, styp, cname, i64_str((*ct_value._i64)));
		}
	}
	else if (ct_value._typ == 10 /* byte */) {
		v__gen__c__Gen_const_decl_write_precomputed(g, styp, cname, byte_str((*ct_value._byte)));
	}
	else if (ct_value._typ == 11 /* u16 */) {
		v__gen__c__Gen_const_decl_write_precomputed(g, styp, cname, u16_str((*ct_value._u16)));
	}
	else if (ct_value._typ == 12 /* u32 */) {
		v__gen__c__Gen_const_decl_write_precomputed(g, styp, cname, u32_str((*ct_value._u32)));
	}
	else if (ct_value._typ == 13 /* u64 */) {
		v__gen__c__Gen_const_decl_write_precomputed(g, styp, cname, string__plus(u64_str((*ct_value._u64)), _SLIT("U")));
	}
	else if (ct_value._typ == 15 /* f32 */) {
		v__gen__c__Gen_const_decl_write_precomputed(g, styp, cname, f32_str((*ct_value._f32)));
	}
	else if (ct_value._typ == 16 /* f64 */) {
		v__gen__c__Gen_const_decl_write_precomputed(g, styp, cname, f64_str((*ct_value._f64)));
	}
	else if (ct_value._typ == 21 /* rune */) {
		u32 rune_code = ((u32)((*ct_value._rune)));
		if (rune_code <= 127U) {
			if (rune_code == '"' || rune_code == '\\' || rune_code == '\'') {
				bool _t3 = false;
				return _t3;
			}
			string escval = v__util__smart_quote(byte_ascii_str(((byte)(rune_code))), false);
			v__gen__c__Gen_const_decl_write_precomputed(g, styp, cname,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("'"), 0xfe10, {.d_s = escval}}, {_SLIT("'"), 0, { .d_c = 0 }}})));
		} else {
			v__gen__c__Gen_const_decl_write_precomputed(g, styp, cname, u32_str(((u32)((*ct_value._rune)))));
		}
	}
	else if (ct_value._typ == 20 /* string */) {
		string escaped_val = v__util__smart_quote((*ct_value._string), false);
		strings__Builder_writeln(&g->definitions,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = styp}}, {_SLIT(" "), 0xfe10, {.d_s = cname}}, {_SLIT("; // inited later"), 0, { .d_c = 0 }}})));
		strings__Builder_writeln(&g->init,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = cname}}, {_SLIT(" = _SLIT(\""), 0xfe10, {.d_s = escaped_val}}, {_SLIT("\");"), 0, { .d_c = 0 }}})));
		if (g->is_autofree) {
			strings__Builder_writeln(&(*(strings__Builder*)map_get(ADDR(map, g->cleanups), &(string[]){mod}, &(strings__Builder[]){ __new_array(0, 0, sizeof(byte)) })),  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\tstring_free(&"), 0xfe10, {.d_s = cname}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
		}
	}
	else if (ct_value._typ == 295 /* v.ast.EmptyExpr */) {
		bool _t4 = false;
		return _t4;
	}
	;
	bool _t5 = true;
	return _t5;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_const_decl_write_precomputed(v__gen__c__Gen* g, string styp, string cname, string ct_value) {
	strings__Builder_writeln(&g->definitions,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = styp}}, {_SLIT(" "), 0xfe10, {.d_s = cname}}, {_SLIT(" = "), 0xfe10, {.d_s = ct_value}}, {_SLIT("; // precomputed"), 0, { .d_c = 0 }}})));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_const_decl_simple_define(v__gen__c__Gen* g, string name, string val) {
	strings__Builder_write_string(&g->definitions,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("#define _const_"), 0xfe10, {.d_s = name}}, {_SLIT(" "), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&g->definitions, val);
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_const_decl_init_later(v__gen__c__Gen* g, string mod, string name, v__ast__Expr expr, v__ast__Type typ, bool unwrap_option) {
	string styp = v__gen__c__Gen_typ(g, typ);
	string cname =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("_const_"), 0xfe10, {.d_s = name}}, {_SLIT0, 0, { .d_c = 0 }}}));
	strings__Builder_writeln(&g->definitions,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = styp}}, {_SLIT(" "), 0xfe10, {.d_s = cname}}, {_SLIT("; // inited later"), 0, { .d_c = 0 }}})));
	if (string__eq(cname, _SLIT("_const_os__args"))) {
		if (g->pref->os == v__pref__OS__windows) {
			strings__Builder_writeln(&g->init, _SLIT("\t_const_os__args = os__init_os_args_wide(___argc, (byteptr*)___argv);"));
		} else {
			strings__Builder_writeln(&g->init, _SLIT("\t_const_os__args = os__init_os_args(___argc, (byte**)___argv);"));
		}
	} else {
		if (unwrap_option) {
			strings__Builder_writeln(&g->init, _SLIT("{"));
			strings__Builder_writeln(&g->init, v__gen__c__Gen_expr_string_surround(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = cname}}, {_SLIT(" = *("), 0xfe10, {.d_s = styp}}, {_SLIT("*)"), 0, { .d_c = 0 }}})), expr, _SLIT(".data;")));
			strings__Builder_writeln(&g->init, _SLIT("}"));
		} else {
			strings__Builder_writeln(&g->init, v__gen__c__Gen_expr_string_surround(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = cname}}, {_SLIT(" = "), 0, { .d_c = 0 }}})), expr, _SLIT(";")));
		}
	}
	if (g->is_autofree) {
		v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, typ);
		if (string_starts_with(styp, _SLIT("Array_"))) {
			if (v__ast__TypeSymbol_has_method_with_generic_parent(sym, _SLIT("free"))) {
				strings__Builder_writeln(&g->cleanup,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = styp}}, {_SLIT("_free(&"), 0xfe10, {.d_s = cname}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
			} else {
				strings__Builder_writeln(&g->cleanup,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\tarray_free(&"), 0xfe10, {.d_s = cname}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
			}
		} else if (string__eq(styp, _SLIT("string"))) {
			strings__Builder_writeln(&g->cleanup,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\tstring_free(&"), 0xfe10, {.d_s = cname}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
		} else if (sym->kind == v__ast__Kind__map) {
			strings__Builder_writeln(&g->cleanup,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\tmap_free(&"), 0xfe10, {.d_s = cname}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
		} else if (string__eq(styp, _SLIT("IError"))) {
			strings__Builder_writeln(&g->cleanup,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\tIError_free(&"), 0xfe10, {.d_s = cname}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
		}
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_global_decl(v__gen__c__Gen* g, v__ast__GlobalDecl node) {
	string mod = (g->pref->build_mode == v__pref__BuildMode__build_module && g->is_builtin_mod ? (_SLIT("static ")) : (_SLIT("")));
	string attributes = _SLIT("");
	if (Array_v__ast__Attr_contains(node.attrs, _SLIT("weak"))) {
		attributes = /*f*/string__plus(attributes, _SLIT("VWEAK "));
	}
	for (int _t1 = 0; _t1 < node.fields.len; ++_t1) {
		v__ast__GlobalField field = ((v__ast__GlobalField*)node.fields.data)[_t1];
		if (g->pref->skip_unused) {
			if (!_IN_MAP(ADDR(string, field.name), ADDR(map, g->table->used_globals))) {
				continue;
			}
		}
		string styp = v__gen__c__Gen_typ(g, field.typ);
		if (field.has_expr) {
			strings__Builder_write_string(&g->definitions,  str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = mod}}, {_SLIT0, 0xfe10, {.d_s = styp}}, {_SLIT(" "), 0xfe10, {.d_s = attributes}}, {_SLIT(" "), 0xfe10, {.d_s = field.name}}, {_SLIT0, 0, { .d_c = 0 }}})));
			if (v__ast__Expr_is_literal(field.expr)) {
				strings__Builder_writeln(&g->definitions,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(" = "), 0xfe10, {.d_s = v__gen__c__Gen_expr_string(g, field.expr)}}, {_SLIT("; // global"), 0, { .d_c = 0 }}})));
			} else {
				strings__Builder_writeln(&g->definitions, _SLIT(";"));
				strings__Builder_writeln(&g->global_init,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = field.name}}, {_SLIT(" = "), 0xfe10, {.d_s = v__gen__c__Gen_expr_string(g, field.expr)}}, {_SLIT("; // global"), 0, { .d_c = 0 }}})));
			}
		} else {
			string default_initializer = v__gen__c__Gen_type_default(g, field.typ);
			if (string__eq(default_initializer, _SLIT("{0}"))) {
				strings__Builder_writeln(&g->definitions,  str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = mod}}, {_SLIT0, 0xfe10, {.d_s = styp}}, {_SLIT(" "), 0xfe10, {.d_s = attributes}}, {_SLIT(" "), 0xfe10, {.d_s = field.name}}, {_SLIT(" = {0}; // global"), 0, { .d_c = 0 }}})));
			} else {
				strings__Builder_writeln(&g->definitions,  str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = mod}}, {_SLIT0, 0xfe10, {.d_s = styp}}, {_SLIT(" "), 0xfe10, {.d_s = attributes}}, {_SLIT(" "), 0xfe10, {.d_s = field.name}}, {_SLIT("; // global"), 0, { .d_c = 0 }}})));
				if (!(string__eq(field.name, _SLIT("as_cast_type_indexes")) || string__eq(field.name, _SLIT("g_memory_block")))) {
					strings__Builder_writeln(&g->global_init,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = field.name}}, {_SLIT(" = *("), 0xfe10, {.d_s = styp}}, {_SLIT("*)&(("), 0xfe10, {.d_s = styp}}, {_SLIT("[]){"), 0xfe10, {.d_s = v__gen__c__Gen_type_default(g, field.typ)}}, {_SLIT("}[0]); // global"), 0, { .d_c = 0 }}})));
				}
			}
		}
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_go_back_out(v__gen__c__Gen* g, int n) {
	strings__Builder_go_back(&g->out, n);
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_struct_init(v__gen__c__Gen* g, v__ast__StructInit node) {
	string styp = v__gen__c__Gen_typ(g, node.typ);
	string shared_styp = _SLIT("");
	if (Array_string_contains(_const_v__gen__c__skip_struct_init, styp)) {
		v__gen__c__Gen_go_back_out(g, 3);
		return;
	}
	v__ast__TypeSymbol* sym = v__ast__Table_final_sym(g->table, v__gen__c__Gen_unwrap_generic(g, node.typ));
	bool is_amp = g->is_amp;
	bool is_multiline = node.fields.len > 5;
	g->is_amp = false;
	if (is_amp) {
		strings__Builder_go_back(&g->out, 1);
	}
	if (g->is_shared && !g->inside_opt_data && !g->is_arraymap_set) {
		v__ast__Type shared_typ = v__ast__Type_set_flag(node.typ, v__ast__TypeFlag__shared_f);
		shared_styp = v__gen__c__Gen_typ(g, shared_typ);
		v__gen__c__Gen_writeln(g,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("("), 0xfe10, {.d_s = shared_styp}}, {_SLIT("*)__dup"), 0xfe10, {.d_s = shared_styp}}, {_SLIT("(&("), 0xfe10, {.d_s = shared_styp}}, {_SLIT("){.mtx = {0}, .val =("), 0xfe10, {.d_s = styp}}, {_SLIT("){"), 0, { .d_c = 0 }}})));
	} else if (is_amp || g->inside_cast_in_heap > 0) {
		v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT("*)memdup(&("), 0xfe10, {.d_s = styp}}, {_SLIT("){"), 0, { .d_c = 0 }}})));
	} else if (v__ast__Type_is_ptr(node.typ)) {
		string basetyp = v__gen__c__Gen_typ(g, v__ast__Type_set_nr_muls(node.typ, 0));
		if (is_multiline) {
			v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("&("), 0xfe10, {.d_s = basetyp}}, {_SLIT("){"), 0, { .d_c = 0 }}})));
		} else {
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("&("), 0xfe10, {.d_s = basetyp}}, {_SLIT("){"), 0, { .d_c = 0 }}})));
		}
	} else {
		if (is_multiline) {
			v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT("){"), 0, { .d_c = 0 }}})));
		} else {
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT("){"), 0, { .d_c = 0 }}})));
		}
	}
	Map_string_int inited_fields = new_map(sizeof(string), sizeof(int), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
	if (is_multiline) {
		g->indent++;
	}
	bool initialized = false;
	bool old_is_shared = g->is_shared;
	for (int i = 0; i < node.fields.len; ++i) {
		v__ast__StructInitField field = ((v__ast__StructInitField*)node.fields.data)[i];
		if (!v__ast__Type_has_flag(field.typ, v__ast__TypeFlag__shared_f)) {
			g->is_shared = false;
		}
		map_set(&inited_fields, &(string[]){field.name}, &(int[]) { i });
		if (sym->kind != v__ast__Kind__struct_) {
			string field_name = (sym->language == v__ast__Language__v ? (v__gen__c__c_name(field.name)) : (field.name));
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("."), 0xfe10, {.d_s = field_name}}, {_SLIT(" = "), 0, { .d_c = 0 }}})));
			if (field.typ == 0) {
				v__gen__c__Gen_checker_bug(g, _SLIT("struct init, field.typ is 0"), field.pos);
			}
			v__ast__TypeSymbol* field_type_sym = v__ast__Table_sym(g->table, field.typ);
			bool cloned = false;
			if (g->is_autofree && !v__ast__Type_is_ptr(field.typ) && (field_type_sym->kind == v__ast__Kind__array || field_type_sym->kind == v__ast__Kind__string)) {
				v__gen__c__Gen_write(g, _SLIT("/*clone1*/"));
				if (v__gen__c__Gen_gen_clone_assignment(g, field.expr, field.typ, false)) {
					cloned = true;
				}
			}
			if (!cloned) {
				if ((v__ast__Type_is_ptr(field.expected_type) && !v__ast__Type_has_flag(field.expected_type, v__ast__TypeFlag__shared_f)) && !(v__ast__Type_is_ptr(field.typ) || v__ast__Type_is_pointer(field.typ)) && !v__ast__Type_is_number(field.typ)) {
					v__gen__c__Gen_write(g, _SLIT("/* autoref */&"));
				}
				v__gen__c__Gen_expr_with_cast(g, field.expr, field.typ, field.expected_type);
			}
			if (i != node.fields.len - 1) {
				if (is_multiline) {
					v__gen__c__Gen_writeln(g, _SLIT(","));
				} else {
					v__gen__c__Gen_write(g, _SLIT(", "));
				}
			}
			initialized = true;
		}
		g->is_shared = old_is_shared;
	}
	g->is_shared = old_is_shared;
	int nr_fields = 1;
	if (sym->kind == v__ast__Kind__struct_) {
		v__ast__Struct info = /* as */ *(v__ast__Struct*)__as_cast((sym->info)._v__ast__Struct,(sym->info)._typ, 446) /*expected idx: 446, name: v.ast.Struct */ ;
		nr_fields = info.fields.len;
		if (info.is_union && node.fields.len > 1) {
			v__gen__c__verror(_SLIT("union must not have more than 1 initializer"));
			VUNREACHABLE();
		}
		if (!info.is_union) {
			bool old_is_shared2 = g->is_shared;
			Array_string used_embed_fields = __new_array_with_default(0, 0, sizeof(string), 0);
			Array_string _t1 = __new_array(0, 0, sizeof(string));
			Array_v__ast__StructField _t1_orig = info.fields;
			int _t1_len = _t1_orig.len;
			_t1 = __new_array(0, _t1_len, sizeof(string));

			for (int _t2 = 0; _t2 < _t1_len; ++_t2) {
				v__ast__StructField it = ((v__ast__StructField*) _t1_orig.data)[_t2];
				string ti = it.name;
				array_push((array*)&_t1, &ti);
			}
			Array_string init_field_names =_t1;
			Array_v__ast__StructInitField _t3 = __new_array(0, 0, sizeof(v__ast__StructInitField));
			Array_v__ast__StructInitField _t3_orig = node.fields;
			int _t3_len = _t3_orig.len;
			_t3 = __new_array(0, _t3_len, sizeof(v__ast__StructInitField));

			for (int _t4 = 0; _t4 < _t3_len; ++_t4) {
				v__ast__StructInitField it = ((v__ast__StructInitField*) _t3_orig.data)[_t4];
				if (!Array_string_contains(init_field_names, it.name)) {
					array_push((array*)&_t3, &it);
				}
			}
			Array_v__ast__StructInitField init_fields_to_embed =_t3;
			for (int _t5 = 0; _t5 < info.embeds.len; ++_t5) {
				v__ast__Type embed = ((v__ast__Type*)info.embeds.data)[_t5];
				v__ast__TypeSymbol* embed_sym = v__ast__Table_sym(g->table, embed);
				string embed_name = v__ast__TypeSymbol_embed_name(embed_sym);
				if (!_IN_MAP(ADDR(string, embed_name), ADDR(map, inited_fields))) {
					v__ast__Struct embed_info = /* as */ *(v__ast__Struct*)__as_cast((embed_sym->info)._v__ast__Struct,(embed_sym->info)._typ, 446) /*expected idx: 446, name: v.ast.Struct */ ;
					Array_string _t6 = __new_array(0, 0, sizeof(string));
					Array_v__ast__StructField _t6_orig = embed_info.fields;
					int _t6_len = _t6_orig.len;
					_t6 = __new_array(0, _t6_len, sizeof(string));

					for (int _t7 = 0; _t7 < _t6_len; ++_t7) {
						v__ast__StructField it = ((v__ast__StructField*) _t6_orig.data)[_t7];
						string ti = it.name;
						array_push((array*)&_t6, &ti);
					}
					Array_string embed_field_names =_t6;
					Array_v__ast__StructInitField _t8 = __new_array(0, 0, sizeof(v__ast__StructInitField));
					Array_v__ast__StructInitField _t8_orig = init_fields_to_embed;
					int _t8_len = _t8_orig.len;
					_t8 = __new_array(0, _t8_len, sizeof(v__ast__StructInitField));

					for (int _t9 = 0; _t9 < _t8_len; ++_t9) {
						v__ast__StructInitField it = ((v__ast__StructInitField*) _t8_orig.data)[_t9];
						if (!Array_string_contains(used_embed_fields, it.name) && Array_string_contains(embed_field_names, it.name)) {
							array_push((array*)&_t8, &it);
						}
					}
					Array_v__ast__StructInitField fields_to_embed =_t8;
					Array_string _t11 = __new_array(0, 0, sizeof(string));
					Array_v__ast__StructInitField _t11_orig = fields_to_embed;
					int _t11_len = _t11_orig.len;
					_t11 = __new_array(0, _t11_len, sizeof(string));

					for (int _t12 = 0; _t12 < _t11_len; ++_t12) {
						v__ast__StructInitField it = ((v__ast__StructInitField*) _t11_orig.data)[_t12];
						string ti = it.name;
						array_push((array*)&_t11, &ti);
					}
					_PUSH_MANY(&used_embed_fields, (_t11), _t10, Array_string);
					v__ast__StructInit default_init = (v__ast__StructInit){node.pos,node.name_pos,node.is_short,node.unresolved,node.pre_comments,.typ = embed,node.update_expr,node.update_expr_type,node.update_expr_comments,node.has_update_expr,.fields = init_fields_to_embed,node.embeds,};
					int inside_cast_in_heap = g->inside_cast_in_heap;
					g->inside_cast_in_heap = 0;
					v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("."), 0xfe10, {.d_s = embed_name}}, {_SLIT(" = "), 0, { .d_c = 0 }}})));
					v__gen__c__Gen_struct_init(g, default_init);
					g->inside_cast_in_heap = inside_cast_in_heap;
					if (is_multiline) {
						v__gen__c__Gen_writeln(g, _SLIT(","));
					} else {
						v__gen__c__Gen_write(g, _SLIT(","));
					}
					initialized = true;
				}
			}
			g->is_shared = old_is_shared2;
		}
		for (int _t13 = 0; _t13 < info.fields.len; ++_t13) {
			v__ast__StructField* field = ((v__ast__StructField*)info.fields.data) + _t13;
			if (!v__ast__Type_has_flag(field->typ, v__ast__TypeFlag__shared_f)) {
				g->is_shared = false;
			}
			if ((sym->info)._typ == 446 /* v.ast.Struct */) {
				int found_equal_fields = 0;
				for (int _t14 = 0; _t14 < (*sym->info._v__ast__Struct).fields.len; ++_t14) {
					v__ast__StructField* sifield = ((v__ast__StructField*)(*sym->info._v__ast__Struct).fields.data) + _t14;
					if (string__eq(sifield->name, field->name)) {
						found_equal_fields++;
						break;
					}
				}
				if (found_equal_fields == 0) {
					continue;
				}
			}
			if (_IN_MAP(ADDR(string, field->name), ADDR(map, inited_fields))) {
				v__ast__StructInitField sfield = (*(v__ast__StructInitField*)/*ee elem_typ */array_get(node.fields, (*(int*)map_get(ADDR(map, inited_fields), &(string[]){field->name}, &(int[]){ 0 }))));
				string field_name = (sym->language == v__ast__Language__v ? (v__gen__c__c_name(field->name)) : (field->name));
				if (sfield.typ == 0) {
					continue;
				}
				v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("."), 0xfe10, {.d_s = field_name}}, {_SLIT(" = "), 0, { .d_c = 0 }}})));
				v__ast__TypeSymbol* field_type_sym = v__ast__Table_sym(g->table, sfield.typ);
				bool cloned = false;
				if (g->is_autofree && !v__ast__Type_is_ptr(sfield.typ) && (field_type_sym->kind == v__ast__Kind__array || field_type_sym->kind == v__ast__Kind__string)) {
					v__gen__c__Gen_write(g, _SLIT("/*clone1*/"));
					if (v__gen__c__Gen_gen_clone_assignment(g, sfield.expr, sfield.typ, false)) {
						cloned = true;
					}
				}
				if (!cloned) {
					if (field_type_sym->kind == v__ast__Kind__array_fixed && (sfield.expr)._typ == 299 /* v.ast.Ident */) {
						v__ast__ArrayFixed fixed_array_info = /* as */ *(v__ast__ArrayFixed*)__as_cast((field_type_sym->info)._v__ast__ArrayFixed,(field_type_sym->info)._typ, 468) /*expected idx: 468, name: v.ast.ArrayFixed */ ;
						v__gen__c__Gen_write(g, _SLIT("{"));
						for (int i = 0; i < fixed_array_info.size; ++i) {
							v__gen__c__Gen_expr(g, sfield.expr);
							v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("["), 0xfe07, {.d_i32 = i}}, {_SLIT("]"), 0, { .d_c = 0 }}})));
							if (i != fixed_array_info.size - 1) {
								v__gen__c__Gen_write(g, _SLIT(", "));
							}
						}
						v__gen__c__Gen_write(g, _SLIT("}"));
					} else {
						if ((v__ast__Type_is_ptr(sfield.expected_type) && !v__ast__Type_has_flag(sfield.expected_type, v__ast__TypeFlag__shared_f)) && !(v__ast__Type_is_ptr(sfield.typ) || v__ast__Type_is_pointer(sfield.typ)) && !v__ast__Type_is_number(sfield.typ)) {
							v__gen__c__Gen_write(g, _SLIT("/* autoref */&"));
						}
						v__gen__c__Gen_expr_with_cast(g, sfield.expr, sfield.typ, sfield.expected_type);
					}
				}
				if (is_multiline) {
					v__gen__c__Gen_writeln(g, _SLIT(","));
				} else {
					v__gen__c__Gen_write(g, _SLIT(","));
				}
				initialized = true;
				continue;
			}
			if (info.is_union) {
				continue;
			}
			if (v__ast__Type_has_flag(field->typ, v__ast__TypeFlag__optional)) {
				string field_name = v__gen__c__c_name(field->name);
				v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("."), 0xfe10, {.d_s = field_name}}, {_SLIT(" = {EMPTY_STRUCT_INITIALIZATION},"), 0, { .d_c = 0 }}})));
				initialized = true;
				continue;
			}
			if (Array_v__ast__Type_contains(info.embeds, field->typ)) {
				continue;
			}
			if (node.has_update_expr) {
				v__gen__c__Gen_expr(g, node.update_expr);
				if (v__ast__Type_is_ptr(node.update_expr_type)) {
					v__gen__c__Gen_write(g, _SLIT("->"));
				} else {
					v__gen__c__Gen_write(g, _SLIT("."));
				}
				v__gen__c__Gen_write(g, field->name);
			} else {
				if (!v__gen__c__Gen_zero_struct_field(g, *field)) {
					nr_fields--;
					continue;
				}
			}
			if (is_multiline) {
				v__gen__c__Gen_writeln(g, _SLIT(","));
			} else {
				v__gen__c__Gen_write(g, _SLIT(","));
			}
			initialized = true;
			g->is_shared = old_is_shared;
		}
		g->is_shared = old_is_shared;
	}
	if (is_multiline) {
		g->indent--;
	}
	if (!initialized) {
		if (nr_fields > 0) {
			v__gen__c__Gen_write(g, _SLIT("0"));
		} else {
			v__gen__c__Gen_write(g, _SLIT("EMPTY_STRUCT_INITIALIZATION"));
		}
	}
	v__gen__c__Gen_write(g, _SLIT("}"));
	if (g->is_shared && !g->inside_opt_data && !g->is_arraymap_set) {
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("}, sizeof("), 0xfe10, {.d_s = shared_styp}}, {_SLIT("))"), 0, { .d_c = 0 }}})));
	} else if (is_amp || g->inside_cast_in_heap > 0) {
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(", sizeof("), 0xfe10, {.d_s = styp}}, {_SLIT("))"), 0, { .d_c = 0 }}})));
	}
}

VV_LOCAL_SYMBOL bool v__gen__c__Gen_zero_struct_field(v__gen__c__Gen* g, v__ast__StructField field) {
	v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, field.typ);
	if (sym->kind == v__ast__Kind__struct_) {
		v__ast__Struct info = /* as */ *(v__ast__Struct*)__as_cast((sym->info)._v__ast__Struct,(sym->info)._typ, 446) /*expected idx: 446, name: v.ast.Struct */ ;
		if (info.fields.len == 0) {
			bool _t1 = false;
			return _t1;
		}
	}
	string field_name = (sym->language == v__ast__Language__v ? (v__gen__c__c_name(field.name)) : (field.name));
	v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("."), 0xfe10, {.d_s = field_name}}, {_SLIT(" = "), 0, { .d_c = 0 }}})));
	if (field.has_default_expr) {
		if (sym->kind == v__ast__Kind__sum_type || sym->kind == v__ast__Kind__interface_) {
			v__gen__c__Gen_expr_with_cast(g, field.default_expr, field.default_expr_typ, field.typ);
			bool _t2 = true;
			return _t2;
		}
		v__gen__c__Gen_expr(g, field.default_expr);
	} else {
		v__gen__c__Gen_write(g, v__gen__c__Gen_type_default(g, field.typ));
	}
	bool _t3 = true;
	return _t3;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_assoc(v__gen__c__Gen* g, v__ast__Assoc node) {
	v__gen__c__Gen_writeln(g, _SLIT("// assoc"));
	if (node.typ == 0) {
		return;
	}
	string styp = v__gen__c__Gen_typ(g, node.typ);
	v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT("){"), 0, { .d_c = 0 }}})));
	Map_string_int inited_fields = new_map(sizeof(string), sizeof(int), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
	for (int i = 0; i < node.fields.len; ++i) {
		string field = ((string*)node.fields.data)[i];
		map_set(&inited_fields, &(string[]){field}, &(int[]) { i });
	}
	v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, node.typ);
	v__ast__Struct info = /* as */ *(v__ast__Struct*)__as_cast((sym->info)._v__ast__Struct,(sym->info)._typ, 446) /*expected idx: 446, name: v.ast.Struct */ ;
	for (int _t1 = 0; _t1 < info.fields.len; ++_t1) {
		v__ast__StructField field = ((v__ast__StructField*)info.fields.data)[_t1];
		string field_name = v__gen__c__c_name(field.name);
		if (_IN_MAP(ADDR(string, field.name), ADDR(map, inited_fields))) {
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t."), 0xfe10, {.d_s = field_name}}, {_SLIT(" = "), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_expr(g, (*(v__ast__Expr*)/*ee elem_typ */array_get(node.exprs, (*(int*)map_get(ADDR(map, inited_fields), &(string[]){field.name}, &(int[]){ 0 })))));
			v__gen__c__Gen_writeln(g, _SLIT(", "));
		} else {
			v__gen__c__Gen_writeln(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\t."), 0xfe10, {.d_s = field_name}}, {_SLIT(" = "), 0xfe10, {.d_s = node.var_name}}, {_SLIT("."), 0xfe10, {.d_s = field_name}}, {_SLIT(","), 0, { .d_c = 0 }}})));
		}
	}
	v__gen__c__Gen_write(g, _SLIT("}"));
	if (g->is_amp) {
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(", sizeof("), 0xfe10, {.d_s = styp}}, {_SLIT("))"), 0, { .d_c = 0 }}})));
	}
}

// Attr: [noreturn]
VNORETURN VV_LOCAL_SYMBOL void v__gen__c__verror(string s) {
	v__util__verror(_SLIT("cgen error"), s);
	VUNREACHABLE();
	while(1);
}

// Attr: [noreturn]
VNORETURN VV_LOCAL_SYMBOL void v__gen__c__Gen_error(v__gen__c__Gen* g, string s, v__token__Position pos) {
	string ferror = v__util__formatted_error(_SLIT("cgen error:"), s, g->file->path, pos);
	eprintln(ferror);
	_v_exit(1);
	VUNREACHABLE();
	while(1);
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_checker_bug(v__gen__c__Gen* g, string s, v__token__Position pos) {
	v__gen__c__Gen_error(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("checker bug; "), 0xfe10, {.d_s = s}}, {_SLIT0, 0, { .d_c = 0 }}})), pos);
	VUNREACHABLE();
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_write_init_function(v__gen__c__Gen* g) {
bool v__gen__c__Gen_write_init_function_defer_0 = false;
	if (g->pref->no_builtin) {
		return;
	}
	v__util__timing_start(_SLIT("Gen.write_init_function"));
	v__gen__c__Gen_write_init_function_defer_0 = true;
	if (g->pref->is_liveshared) {
		// Defer begin
		if (v__gen__c__Gen_write_init_function_defer_0) {
			v__util__timing_measure(_SLIT("Gen.write_init_function"));
		}
		// Defer end
		return;
	}
	int fn_vinit_start_pos = g->out.len;
	v__gen__c__Gen_writeln(g, _SLIT("void _vinit(int ___argc, voidptr ___argv) {"));
	if (!Array_string_contains(g->pref->compile_defines, _SLIT("no_segfault_handler"))) {
		v__gen__c__Gen_writeln(g, _SLIT("#if __STDC_HOSTED__ == 1\n\tsignal(11, v_segmentation_fault_handler);\n#endif"));
	}
	if (g->pref->prealloc) {
		v__gen__c__Gen_writeln(g, _SLIT("prealloc_vinit();"));
	}
	v__gen__c__Gen_write(g, _SLIT("\tas_cast_type_indexes = "));
	v__gen__c__Gen_writeln(g, v__gen__c__Gen_as_cast_name_table(g));
	v__gen__c__Gen_writeln(g, _SLIT("\tbuiltin_init();"));
	v__gen__c__Gen_writeln(g, _SLIT("\tvinit_string_literals();"));
	for (int _t1 = 0; _t1 < g->table->modules.len; ++_t1) {
		string mod_name = ((string*)g->table->modules.data)[_t1];
		v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t{ // Initializations for module "), 0xfe10, {.d_s = mod_name}}, {_SLIT(" :"), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_write(g, strings__Builder_str(&(*(strings__Builder*)map_get(ADDR(map, g->inits), &(string[]){mod_name}, &(strings__Builder[]){ __new_array(0, 0, sizeof(byte)) }))));
		v__gen__c__Gen_write(g, strings__Builder_str(&(*(strings__Builder*)map_get(ADDR(map, g->global_inits), &(string[]){mod_name}, &(strings__Builder[]){ __new_array(0, 0, sizeof(byte)) }))));
		string init_fn_name =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = mod_name}}, {_SLIT(".init"), 0, { .d_c = 0 }}}));
		Option_v__ast__Fn _t2;
		if (_t2 = v__ast__Table_find_fn(g->table, init_fn_name), _t2.state == 0) {
			v__ast__Fn initfn = *(v__ast__Fn*)_t2.data;
			if (v__ast__Type_alias_eq(initfn.return_type, _const_v__ast__void_type) && initfn.params.len == 0) {
				string mod_c_name = v__util__no_dots(mod_name);
				string init_fn_c_name =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = mod_c_name}}, {_SLIT("__init"), 0, { .d_c = 0 }}}));
				v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = init_fn_c_name}}, {_SLIT("();"), 0, { .d_c = 0 }}})));
			}
		}
		v__gen__c__Gen_writeln(g, _SLIT("\t}"));
	}
	v__gen__c__Gen_writeln(g, _SLIT("}"));
	if (g->pref->printfn_list.len > 0 && Array_string_contains(g->pref->printfn_list, _SLIT("_vinit"))) {
		println(strings__Builder_after(&g->out, fn_vinit_start_pos));
	}
	int fn_vcleanup_start_pos = g->out.len;
	v__gen__c__Gen_writeln(g, _SLIT("void _vcleanup(void) {"));
	if (g->is_autofree) {
		Array_string reversed_table_modules = array_reverse(g->table->modules);
		for (int _t3 = 0; _t3 < reversed_table_modules.len; ++_t3) {
			string mod_name = ((string*)reversed_table_modules.data)[_t3];
			v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t// Cleanups for module "), 0xfe10, {.d_s = mod_name}}, {_SLIT(" :"), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_writeln(g, strings__Builder_str(&(*(strings__Builder*)map_get(ADDR(map, g->cleanups), &(string[]){mod_name}, &(strings__Builder[]){ __new_array(0, 0, sizeof(byte)) }))));
		}
		v__gen__c__Gen_writeln(g, _SLIT("\tarray_free(&as_cast_type_indexes);"));
	}
	v__gen__c__Gen_writeln(g, _SLIT("}"));
	if (g->pref->printfn_list.len > 0 && Array_string_contains(g->pref->printfn_list, _SLIT("_vcleanup"))) {
		println(strings__Builder_after(&g->out, fn_vcleanup_start_pos));
	}
	bool needs_constructor = g->pref->is_shared && g->pref->os != v__pref__OS__windows;
	if (needs_constructor) {
		v__gen__c__Gen_writeln(g, _SLIT("__attribute__ ((constructor))"));
		v__gen__c__Gen_writeln(g, _SLIT("void _vinit_caller() {"));
		v__gen__c__Gen_writeln(g, _SLIT("\tstatic bool once = false; if (once) {return;} once = true;"));
		v__gen__c__Gen_writeln(g, _SLIT("\t_vinit(0,0);"));
		v__gen__c__Gen_writeln(g, _SLIT("}"));
		v__gen__c__Gen_writeln(g, _SLIT("__attribute__ ((destructor))"));
		v__gen__c__Gen_writeln(g, _SLIT("void _vcleanup_caller() {"));
		v__gen__c__Gen_writeln(g, _SLIT("\tstatic bool once = false; if (once) {return;} once = true;"));
		v__gen__c__Gen_writeln(g, _SLIT("\t_vcleanup();"));
		v__gen__c__Gen_writeln(g, _SLIT("}"));
	}
// Defer begin
if (v__gen__c__Gen_write_init_function_defer_0) {
	v__util__timing_measure(_SLIT("Gen.write_init_function"));
}
// Defer end
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_write_builtin_types(v__gen__c__Gen* g) {
	if (g->pref->no_builtin) {
		return;
	}
	Array_v__ast__TypeSymbol_ptr builtin_types = __new_array_with_default(0, 0, sizeof(v__ast__TypeSymbol*), 0);
	for (int _t1 = 0; _t1 < _const_v__gen__c__builtins.len; ++_t1) {
		string builtin_name = ((string*)_const_v__gen__c__builtins.data)[_t1];
		v__ast__TypeSymbol* sym = v__ast__Table_sym_by_idx(g->table, (*(int*)map_get(ADDR(map, g->table->type_idxs), &(string[]){builtin_name}, &(int[]){ 0 })));
		if (sym->kind == v__ast__Kind__interface_) {
			v__gen__c__Gen_write_interface_typedef(g, *sym);
			v__gen__c__Gen_write_interface_typesymbol_declaration(g, *sym);
		} else {
			array_push((array*)&builtin_types, _MOV((v__ast__TypeSymbol*[]){ sym }));
		}
	}
	v__gen__c__Gen_write_types(g, builtin_types);
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_write_sorted_types(v__gen__c__Gen* g) {
	Array_v__ast__TypeSymbol_ptr symbols = __new_array_with_default(0, g->table->type_symbols.len, sizeof(v__ast__TypeSymbol*), 0);
	for (int _t1 = 0; _t1 < g->table->type_symbols.len; ++_t1) {
		v__ast__TypeSymbol* sym = ((v__ast__TypeSymbol**)g->table->type_symbols.data)[_t1];
		if (!Array_string_contains(_const_v__gen__c__builtins, sym->name)) {
			array_push((array*)&symbols, _MOV((v__ast__TypeSymbol*[]){ sym }));
		}
	}
	Array_v__ast__TypeSymbol_ptr sorted_symbols = v__gen__c__Gen_sort_structs(g, symbols);
	strings__Builder_writeln(&g->type_definitions, _SLIT("// builtin types:"));
	strings__Builder_writeln(&g->type_definitions, _SLIT("//------------------ #endbuiltin"));
	v__gen__c__Gen_write_types(g, sorted_symbols);
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_write_types(v__gen__c__Gen* g, Array_v__ast__TypeSymbol_ptr symbols) {
	for (int _t1 = 0; _t1 < symbols.len; ++_t1) {
		v__ast__TypeSymbol* sym = ((v__ast__TypeSymbol**)symbols.data)[_t1];
		if (string_starts_with(sym->name, _SLIT("C."))) {
			continue;
		}
		if (sym->kind == v__ast__Kind__none_) {
			strings__Builder_writeln(&g->type_definitions, _SLIT("struct none {"));
			strings__Builder_writeln(&g->type_definitions, _SLIT("\tEMPTY_STRUCT_DECLARATION;"));
			strings__Builder_writeln(&g->type_definitions, _SLIT("};"));
			strings__Builder_writeln(&g->typedefs, _SLIT("typedef struct none none;"));
		}
		string name = sym->cname;
		if (sym->info._typ == 446 /* v.ast.Struct */) {
			if ((*sym->info._v__ast__Struct).is_generic) {
				continue;
			}
			if (string_contains(name, _SLIT("_T_"))) {
				strings__Builder_writeln(&g->typedefs,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("typedef struct "), 0xfe10, {.d_s = name}}, {_SLIT(" "), 0xfe10, {.d_s = name}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
			}
			int start_pos = g->type_definitions.len;
			string pre_pragma = _SLIT("");
			string post_pragma = _SLIT("");
			for (int _t2 = 0; _t2 < (*sym->info._v__ast__Struct).attrs.len; ++_t2) {
				v__ast__Attr attr = ((v__ast__Attr*)(*sym->info._v__ast__Struct).attrs.data)[_t2];

				if (string__eq(attr.name, _SLIT("_pack"))) {
					pre_pragma = /*f*/string__plus(pre_pragma,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("#pragma pack(push, "), 0xfe10, {.d_s = attr.arg}}, {_SLIT(")\n"), 0, { .d_c = 0 }}})));
					post_pragma = /*f*/string__plus(post_pragma, _SLIT("#pragma pack(pop)"));
				}
				else {
				};
			}
			strings__Builder_writeln(&g->type_definitions, pre_pragma);
			if ((*sym->info._v__ast__Struct).is_union) {
				strings__Builder_writeln(&g->type_definitions,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("union "), 0xfe10, {.d_s = name}}, {_SLIT(" {"), 0, { .d_c = 0 }}})));
			} else {
				strings__Builder_writeln(&g->type_definitions,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("struct "), 0xfe10, {.d_s = name}}, {_SLIT(" {"), 0, { .d_c = 0 }}})));
			}
			if ((*sym->info._v__ast__Struct).fields.len > 0 || (*sym->info._v__ast__Struct).embeds.len > 0) {
				for (int _t3 = 0; _t3 < (*sym->info._v__ast__Struct).fields.len; ++_t3) {
					v__ast__StructField field = ((v__ast__StructField*)(*sym->info._v__ast__Struct).fields.data)[_t3];
					if (v__ast__Type_has_flag(field.typ, v__ast__TypeFlag__optional)) {
						multi_return_string_string mr_169645 = v__gen__c__Gen_optional_type_name(g, field.typ);
						string styp = mr_169645.arg0;
						string base = mr_169645.arg1;
						sync__RwMutex_lock(&g->done_optionals->mtx);
						/*lock*/ {
							if (!Array_string_contains(g->done_optionals->val, base)) {
								array_push((array*)&g->done_optionals->val, _MOV((string[]){ string_clone(base) }));
								string last_text = string_clone(strings__Builder_after(&g->type_definitions, start_pos));
								strings__Builder_go_back_to(&g->type_definitions, start_pos);
								strings__Builder_writeln(&g->typedefs,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("typedef struct "), 0xfe10, {.d_s = styp}}, {_SLIT(" "), 0xfe10, {.d_s = styp}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
								strings__Builder_writeln(&g->type_definitions,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__gen__c__Gen_optional_type_text(g, styp, base)}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
								strings__Builder_write_string(&g->type_definitions, last_text);
							}
						}
						sync__RwMutex_unlock(&g->done_optionals->mtx);;
					}
					string type_name = v__gen__c__Gen_typ(g, field.typ);
					string field_name = v__gen__c__c_name(field.name);
					string volatile_prefix = (field.is_volatile ? (_SLIT("volatile ")) : (_SLIT("")));
					strings__Builder_writeln(&g->type_definitions,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = volatile_prefix}}, {_SLIT0, 0xfe10, {.d_s = type_name}}, {_SLIT(" "), 0xfe10, {.d_s = field_name}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
				}
			} else {
				strings__Builder_writeln(&g->type_definitions, _SLIT("\tEMPTY_STRUCT_DECLARATION;"));
			}
			string ti_attrs = (Array_v__ast__Attr_contains((*sym->info._v__ast__Struct).attrs, _SLIT("packed")) ? (_SLIT("__attribute__((__packed__))")) : (_SLIT("")));
			strings__Builder_writeln(&g->type_definitions,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("}"), 0xfe10, {.d_s = ti_attrs}}, {_SLIT(";\n"), 0, { .d_c = 0 }}})));
			strings__Builder_writeln(&g->type_definitions, post_pragma);
		}
		else if (sym->info._typ == 460 /* v.ast.Alias */) {
		}
		else if (sym->info._typ == 470 /* v.ast.Thread */) {
			if (g->pref->os == v__pref__OS__windows) {
				if (string__eq(name, _SLIT("__v_thread"))) {
					strings__Builder_writeln(&g->type_definitions,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("typedef HANDLE "), 0xfe10, {.d_s = name}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
				} else {
					strings__Builder_writeln(&g->type_definitions, _SLIT("typedef struct {"));
					strings__Builder_writeln(&g->type_definitions, _SLIT("\tvoid* ret_ptr;"));
					strings__Builder_writeln(&g->type_definitions, _SLIT("\tHANDLE handle;"));
					strings__Builder_writeln(&g->type_definitions,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("} "), 0xfe10, {.d_s = name}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
				}
			} else {
				if (!g->pref->is_bare && !g->pref->no_builtin) {
					strings__Builder_writeln(&g->type_definitions,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("typedef pthread_t "), 0xfe10, {.d_s = name}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
				}
			}
		}
		else if (sym->info._typ == 464 /* v.ast.SumType */) {
			if ((*sym->info._v__ast__SumType).is_generic) {
				continue;
			}
			strings__Builder_writeln(&g->typedefs,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("typedef struct "), 0xfe10, {.d_s = name}}, {_SLIT(" "), 0xfe10, {.d_s = name}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
			strings__Builder_writeln(&g->type_definitions, _SLIT(""));
			strings__Builder_writeln(&g->type_definitions,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("// Union sum type "), 0xfe10, {.d_s = name}}, {_SLIT(" = "), 0, { .d_c = 0 }}})));
			for (int _t5 = 0; _t5 < (*sym->info._v__ast__SumType).variants.len; ++_t5) {
				v__ast__Type variant = ((v__ast__Type*)(*sym->info._v__ast__SumType).variants.data)[_t5];
				strings__Builder_writeln(&g->type_definitions,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("//          | "), 0x8fe27, {.d_i32 = variant}}, {_SLIT(" = "), 0x28fe10, {.d_s = v__gen__c__Gen_typ(g, v__ast__Type_idx(variant))}}, {_SLIT0, 0, { .d_c = 0 }}})));
			}
			strings__Builder_writeln(&g->type_definitions,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("struct "), 0xfe10, {.d_s = name}}, {_SLIT(" {"), 0, { .d_c = 0 }}})));
			strings__Builder_writeln(&g->type_definitions, _SLIT("\tunion {"));
			for (int _t6 = 0; _t6 < (*sym->info._v__ast__SumType).variants.len; ++_t6) {
				v__ast__Type variant = ((v__ast__Type*)(*sym->info._v__ast__SumType).variants.data)[_t6];
				v__ast__TypeSymbol* variant_sym = v__ast__Table_sym(g->table, variant);
				strings__Builder_writeln(&g->type_definitions,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\t"), 0xfe10, {.d_s = v__gen__c__Gen_typ(g, v__ast__Type_ref(variant))}}, {_SLIT(" _"), 0xfe10, {.d_s = variant_sym->cname}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
			}
			strings__Builder_writeln(&g->type_definitions, _SLIT("\t};"));
			strings__Builder_writeln(&g->type_definitions, _SLIT("\tint _typ;"));
			if ((*sym->info._v__ast__SumType).fields.len > 0) {
				v__gen__c__Gen_writeln(g, _SLIT("\t// pointers to common sumtype fields"));
				for (int _t7 = 0; _t7 < (*sym->info._v__ast__SumType).fields.len; ++_t7) {
					v__ast__StructField field = ((v__ast__StructField*)(*sym->info._v__ast__SumType).fields.data)[_t7];
					strings__Builder_writeln(&g->type_definitions,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = v__gen__c__Gen_typ(g, v__ast__Type_ref(field.typ))}}, {_SLIT(" "), 0xfe10, {.d_s = field.name}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
				}
			}
			strings__Builder_writeln(&g->type_definitions, _SLIT("};"));
			strings__Builder_writeln(&g->type_definitions, _SLIT(""));
		}
		else if (sym->info._typ == 468 /* v.ast.ArrayFixed */) {
			v__ast__TypeSymbol* elem_sym = v__ast__Table_sym(g->table, (*sym->info._v__ast__ArrayFixed).elem_type);
			if (!v__ast__TypeSymbol_is_builtin(elem_sym) && !v__ast__Type_has_flag((*sym->info._v__ast__ArrayFixed).elem_type, v__ast__TypeFlag__generic)) {
				string styp = sym->cname;
				string fixed_elem_name = v__gen__c__Gen_typ(g, v__ast__Type_set_nr_muls((*sym->info._v__ast__ArrayFixed).elem_type, 0));
				if (v__ast__Type_is_ptr((*sym->info._v__ast__ArrayFixed).elem_type)) {
					fixed_elem_name = /*f*/string__plus(fixed_elem_name, string_repeat(_SLIT("*"), v__ast__Type_nr_muls((*sym->info._v__ast__ArrayFixed).elem_type)));
				}
				int len = (*sym->info._v__ast__ArrayFixed).size;
				if (string_starts_with(fixed_elem_name, _SLIT("C__"))) {
					fixed_elem_name = string_substr(fixed_elem_name, 3, fixed_elem_name.len);
				}
				if ((elem_sym->info)._typ == 472 /* v.ast.FnType */) {
					int pos = g->out.len;
					v__gen__c__Gen_write_fn_ptr_decl(g, &(*elem_sym->info._v__ast__FnType), _SLIT(""));
					fixed_elem_name = strings__Builder_cut_to(&g->out, pos);
					string def_str =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("typedef "), 0xfe10, {.d_s = fixed_elem_name}}, {_SLIT(";"), 0, { .d_c = 0 }}}));
					def_str = string_replace_once(def_str, _SLIT("(*)"),  str_intp(3, _MOV((StrIntpData[]){{_SLIT("(*"), 0xfe10, {.d_s = styp}}, {_SLIT("["), 0xfe07, {.d_i32 = len}}, {_SLIT("])"), 0, { .d_c = 0 }}})));
					strings__Builder_writeln(&g->type_definitions, def_str);
				} else {
					strings__Builder_writeln(&g->type_definitions,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("typedef "), 0xfe10, {.d_s = fixed_elem_name}}, {_SLIT(" "), 0xfe10, {.d_s = styp}}, {_SLIT(" ["), 0xfe07, {.d_i32 = len}}, {_SLIT("];"), 0, { .d_c = 0 }}})));
				}
			}
		}
		
		else {
		}
		;
	}
}

VV_LOCAL_SYMBOL Array_v__ast__TypeSymbol_ptr v__gen__c__Gen_sort_structs(v__gen__c__Gen* g, Array_v__ast__TypeSymbol_ptr typesa) {
bool v__gen__c__Gen_sort_structs_defer_0 = false;
	v__util__timing_start(_SLIT("Gen.sort_structs"));
	v__gen__c__Gen_sort_structs_defer_0 = true;
	v__depgraph__DepGraph* dep_graph = v__depgraph__new_dep_graph();
	Array_string type_names = __new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t1 = 0; _t1 < typesa.len; ++_t1) {
		v__ast__TypeSymbol* sym = ((v__ast__TypeSymbol**)typesa.data)[_t1];
		array_push((array*)&type_names, _MOV((string[]){ string_clone(sym->name) }));
	}
	for (int _t3 = 0; _t3 < typesa.len; ++_t3) {
		v__ast__TypeSymbol* sym = ((v__ast__TypeSymbol**)typesa.data)[_t3];
		if (sym->kind == v__ast__Kind__interface_) {
			v__depgraph__DepGraph_add(dep_graph, sym->name, __new_array_with_default(0, 0, sizeof(string), 0));
			continue;
		}
		Array_string field_deps = __new_array_with_default(0, 0, sizeof(string), 0);
		if (sym->info._typ == 468 /* v.ast.ArrayFixed */) {
			string dep = v__ast__Table_sym(g->table, (*sym->info._v__ast__ArrayFixed).elem_type)->name;
			if (Array_string_contains(type_names, dep)) {
				array_push((array*)&field_deps, _MOV((string[]){ string_clone(dep) }));
			}
		}
		else if (sym->info._typ == 446 /* v.ast.Struct */) {
			for (int _t5 = 0; _t5 < (*sym->info._v__ast__Struct).embeds.len; ++_t5) {
				v__ast__Type embed = ((v__ast__Type*)(*sym->info._v__ast__Struct).embeds.data)[_t5];
				string dep = v__ast__Table_sym(g->table, embed)->name;
				if (!Array_string_contains(type_names, dep) || Array_string_contains(field_deps, dep)) {
					continue;
				}
				array_push((array*)&field_deps, _MOV((string[]){ string_clone(dep) }));
			}
			for (int _t7 = 0; _t7 < (*sym->info._v__ast__Struct).fields.len; ++_t7) {
				v__ast__StructField field = ((v__ast__StructField*)(*sym->info._v__ast__Struct).fields.data)[_t7];
				string dep = v__ast__Table_sym(g->table, field.typ)->name;
				if (!Array_string_contains(type_names, dep) || Array_string_contains(field_deps, dep) || v__ast__Type_is_ptr(field.typ)) {
					continue;
				}
				array_push((array*)&field_deps, _MOV((string[]){ string_clone(dep) }));
			}
		}
		
		else {
		}
		;
		v__depgraph__DepGraph_add(dep_graph, sym->name, field_deps);
	}
	v__depgraph__DepGraph* dep_graph_sorted = v__depgraph__DepGraph_resolve(dep_graph);
	if (!dep_graph_sorted->acyclic) {
		v__gen__c__verror(string__plus(string__plus(string__plus(_SLIT("cgen.sort_structs(): the following structs form a dependency cycle:\n"), v__depgraph__DepGraph_display_cycles(dep_graph_sorted)), _SLIT("\nyou can solve this by making one or both of the dependant struct fields references, eg: field &MyStruct")), _SLIT("\nif you feel this is an error, please create a new issue here: https://github.com/vlang/v/issues and tag @joe-conigliaro")));
		VUNREACHABLE();
	}
	Array_v__ast__TypeSymbol_ptr sorted_symbols = __new_array_with_default(0, dep_graph_sorted->nodes.len, sizeof(v__ast__TypeSymbol*), 0);
	for (int _t9 = 0; _t9 < dep_graph_sorted->nodes.len; ++_t9) {
		v__depgraph__DepGraphNode node = ((v__depgraph__DepGraphNode*)dep_graph_sorted->nodes.data)[_t9];
		array_push((array*)&sorted_symbols, _MOV((v__ast__TypeSymbol*[]){ v__ast__Table_sym_by_idx(g->table, (*(int*)map_get((map*)&g->table->type_idxs, &(string[]){node.name}, &(int[]){ 0 }))) }));
	}
	Array_v__ast__TypeSymbol_ptr _t11 = sorted_symbols;
	// Defer begin
	if (v__gen__c__Gen_sort_structs_defer_0) {
		v__util__timing_measure(_SLIT("Gen.sort_structs"));
	}
	// Defer end
	return _t11;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL int v__gen__c__Gen_nth_stmt_pos(v__gen__c__Gen* g, int n) {
	int _t1 = (*(int*)/*ee elem_typ */array_get(g->stmt_path_pos, g->stmt_path_pos.len - (1 + n)));
	return _t1;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL void v__gen__c__Gen_set_current_pos_as_last_stmt_pos(v__gen__c__Gen* g) {
	array_push((array*)&g->stmt_path_pos, _MOV((int[]){ g->out.len }));
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_go_before_stmt(v__gen__c__Gen* g, int n) {
	int stmt_pos = v__gen__c__Gen_nth_stmt_pos(g, n);
	string _t1 = strings__Builder_cut_to(&g->out, stmt_pos);
	return _t1;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL string v__gen__c__Gen_go_before_ternary(v__gen__c__Gen* g) {
	string _t1 = v__gen__c__Gen_go_before_stmt(g, g->inside_ternary);
	return _t1;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_insert_before_stmt(v__gen__c__Gen* g, string s) {
	string cur_line = v__gen__c__Gen_go_before_stmt(g, 0);
	v__gen__c__Gen_writeln(g, s);
	v__gen__c__Gen_write(g, cur_line);
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_insert_at(v__gen__c__Gen* g, int pos, string s) {
	string cur_line = strings__Builder_cut_to(&g->out, pos);
	v__gen__c__Gen_writeln(g, s);
	v__gen__c__Gen_write(g, cur_line);
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_or_block(v__gen__c__Gen* g, string var_name, v__ast__OrExpr or_block, v__ast__Type return_type) {
bool v__gen__c__Gen_or_block_defer_0 = false;
	string cvar_name = v__gen__c__c_name(var_name);
	string mr_styp = v__gen__c__Gen_base_type(g, return_type);
	bool is_none_ok = v__ast__Type_alias_eq(return_type, _const_v__ast__ovoid_type);
	v__gen__c__Gen_writeln(g, _SLIT(";"));
	if (is_none_ok) {
		v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("if ("), 0xfe10, {.d_s = cvar_name}}, {_SLIT(".state != 0 && "), 0xfe10, {.d_s = cvar_name}}, {_SLIT(".err._typ != _IError_None___index) {"), 0, { .d_c = 0 }}})));
	} else {
		v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("if ("), 0xfe10, {.d_s = cvar_name}}, {_SLIT(".state != 0) { /*or block*/ "), 0, { .d_c = 0 }}})));
	}
	if (or_block.kind == v__ast__OrKind__block) {
		if (g->inside_or_block) {
			v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\terr = "), 0xfe10, {.d_s = cvar_name}}, {_SLIT(".err;"), 0, { .d_c = 0 }}})));
		} else {
			v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\tIError err = "), 0xfe10, {.d_s = cvar_name}}, {_SLIT(".err;"), 0, { .d_c = 0 }}})));
		}
		g->inside_or_block = true;
		v__gen__c__Gen_or_block_defer_0 = true;
		Array_v__ast__Stmt stmts = or_block.stmts;
		if (stmts.len > 0 && ((*(v__ast__Stmt*)/*ee elem_typ */array_get(stmts, or_block.stmts.len - 1)))._typ == 339 /* v.ast.ExprStmt */ && !v__ast__Type_alias_eq((/* as */ *(v__ast__ExprStmt*)__as_cast(((*(v__ast__Stmt*)/*ee elem_typ */array_get(stmts, stmts.len - 1)))._v__ast__ExprStmt,((*(v__ast__Stmt*)/*ee elem_typ */array_get(stmts, stmts.len - 1)))._typ, 339) /*expected idx: 339, name: v.ast.ExprStmt */ ).typ, _const_v__ast__void_type)) {
			g->indent++;
			for (int i = 0; i < stmts.len; ++i) {
				v__ast__Stmt stmt = ((v__ast__Stmt*)stmts.data)[i];
				if (i == stmts.len - 1) {
					v__ast__ExprStmt expr_stmt = /* as */ *(v__ast__ExprStmt*)__as_cast((stmt)._v__ast__ExprStmt,(stmt)._typ, 339) /*expected idx: 339, name: v.ast.ExprStmt */ ;
					v__gen__c__Gen_set_current_pos_as_last_stmt_pos(g);
					v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("*("), 0xfe10, {.d_s = mr_styp}}, {_SLIT("*) "), 0xfe10, {.d_s = cvar_name}}, {_SLIT(".data = "), 0, { .d_c = 0 }}})));
					bool old_inside_opt_data = g->inside_opt_data;
					g->inside_opt_data = true;
					v__gen__c__Gen_expr_with_cast(g, expr_stmt.expr, expr_stmt.typ, v__ast__Type_clear_flag(return_type, v__ast__TypeFlag__optional));
					g->inside_opt_data = old_inside_opt_data;
					if (g->inside_ternary == 0) {
						v__gen__c__Gen_writeln(g, _SLIT(";"));
					}
					array_delete_last(&g->stmt_path_pos);
				} else {
					v__gen__c__Gen_stmt(g, stmt);
				}
			}
			g->indent--;
		} else {
			v__gen__c__Gen_stmts(g, stmts);
			if (stmts.len > 0 && ((*(v__ast__Stmt*)/*ee elem_typ */array_get(stmts, or_block.stmts.len - 1)))._typ == 339 /* v.ast.ExprStmt */) {
				v__gen__c__Gen_writeln(g, _SLIT(";"));
			}
		}
	} else if (or_block.kind == v__ast__OrKind__propagate) {
		if (string__eq(g->file->mod.name, _SLIT("main")) && (isnil(g->fn_decl) || g->fn_decl->is_main)) {
			if (g->pref->is_debug) {
				multi_return_int_string_string_string mr_178288 = v__gen__c__Gen_panic_debug_info(g, or_block.pos);
				int paline = mr_178288.arg0;
				string pafile = mr_178288.arg1;
				string pamod = mr_178288.arg2;
				string pafn = mr_178288.arg3;
				v__gen__c__Gen_writeln(g,  str_intp(6, _MOV((StrIntpData[]){{_SLIT("panic_debug("), 0xfe07, {.d_i32 = paline}}, {_SLIT(", tos3(\""), 0xfe10, {.d_s = pafile}}, {_SLIT("\"), tos3(\""), 0xfe10, {.d_s = pamod}}, {_SLIT("\"), tos3(\""), 0xfe10, {.d_s = pafn}}, {_SLIT("\"), *"), 0xfe10, {.d_s = cvar_name}}, {_SLIT(".err.msg );"), 0, { .d_c = 0 }}})));
			} else {
				v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\tpanic_optional_not_set(*"), 0xfe10, {.d_s = cvar_name}}, {_SLIT(".err.msg);"), 0, { .d_c = 0 }}})));
			}
		} else if (!isnil(g->fn_decl) && g->fn_decl->is_test) {
			v__gen__c__Gen_gen_failing_error_propagation_for_test_fn(g, or_block, cvar_name);
		} else {
			v__gen__c__Gen_write_defer_stmts(g);
			if (v__ast__Type_alias_eq(g->fn_decl->return_type, _const_v__ast__void_type)) {
				v__gen__c__Gen_writeln(g, _SLIT("\treturn;"));
			} else {
				string styp = v__gen__c__Gen_typ(g, g->fn_decl->return_type);
				string err_obj = v__gen__c__Gen_new_tmp_var(g);
				v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = styp}}, {_SLIT(" "), 0xfe10, {.d_s = err_obj}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
				v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\tmemcpy(&"), 0xfe10, {.d_s = err_obj}}, {_SLIT(", &"), 0xfe10, {.d_s = cvar_name}}, {_SLIT(", sizeof(Option));"), 0, { .d_c = 0 }}})));
				v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\treturn "), 0xfe10, {.d_s = err_obj}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
			}
		}
	}
	v__gen__c__Gen_writeln(g, _SLIT("}"));
	v__gen__c__Gen_set_current_pos_as_last_stmt_pos(g);
// Defer begin
if (v__gen__c__Gen_or_block_defer_0) {
	g->inside_or_block = false;
}
// Defer end
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL string v__gen__c__c_name(string name_) {
	string name = v__util__no_dots(name_);
	if (_IN_MAP(ADDR(string, name), ADDR(map, _const_v__gen__c__c_reserved_map))) {
		string _t1 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("_v_"), 0xfe10, {.d_s = name}}, {_SLIT0, 0, { .d_c = 0 }}}));
		return _t1;
	}
	string _t2 = name;
	return _t2;
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_type_default(v__gen__c__Gen* g, v__ast__Type typ_) {
	v__ast__Type typ = v__gen__c__Gen_unwrap_generic(g, typ_);
	if (v__ast__Type_has_flag(typ, v__ast__TypeFlag__optional)) {
		string _t1 = _SLIT("{0}");
		return _t1;
	}
	if (v__ast__Type_is_ptr(typ) && !v__ast__Type_has_flag(typ, v__ast__TypeFlag__shared_f)) {
		string _t2 = _SLIT("0");
		return _t2;
	}
	if (v__ast__Type_idx(typ) < _const_v__ast__string_type_idx) {
		string _t3 = _SLIT("0");
		return _t3;
	}
	v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, typ);
	switch (sym->kind) {
		case v__ast__Kind__string: 
			{
				string _t4 = _SLIT("(string){.str=(byteptr)\"\", .is_lit=1}");
				return _t4;
			} break;
		case v__ast__Kind__interface_: 
		case v__ast__Kind__sum_type: 
		case v__ast__Kind__array_fixed: 
		case v__ast__Kind__multi_return: 
			{
				string _t5 = _SLIT("{0}");
				return _t5;
			} break;
		case v__ast__Kind__alias: 
			{
				string _t6 = v__gen__c__Gen_type_default(g, (/* as */ *(v__ast__Alias*)__as_cast((sym->info)._v__ast__Alias,(sym->info)._typ, 460) /*expected idx: 460, name: v.ast.Alias */ ).parent_type);
				return _t6;
			} break;
		case v__ast__Kind__chan: 
			{
				v__ast__Type elem_type = v__ast__TypeSymbol_chan_info(sym).elem_type;
				string elemtypstr = v__gen__c__Gen_typ(g, elem_type);
				string noscan = v__gen__c__Gen_check_noscan(g, elem_type);
				string _t7 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("sync__new_channel_st"), 0xfe10, {.d_s = noscan}}, {_SLIT("(0, sizeof("), 0xfe10, {.d_s = elemtypstr}}, {_SLIT("))"), 0, { .d_c = 0 }}}));
				return _t7;
			} break;
		case v__ast__Kind__array: 
			{
				v__ast__Type elem_typ = v__ast__TypeSymbol_array_info(sym).elem_type;
				string elem_sym = v__gen__c__Gen_typ(g, elem_typ);
				string elem_type_str = v__util__no_dots(elem_sym);
				if (string_starts_with(elem_type_str, _SLIT("C__"))) {
					elem_type_str = string_substr(elem_type_str, 3, elem_type_str.len);
				}
				string noscan = v__gen__c__Gen_check_noscan(g, elem_typ);
				string init_str =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("__new_array"), 0xfe10, {.d_s = noscan}}, {_SLIT("(0, 0, sizeof("), 0xfe10, {.d_s = elem_type_str}}, {_SLIT("))"), 0, { .d_c = 0 }}}));
				if (v__ast__Type_has_flag(typ, v__ast__TypeFlag__shared_f)) {
					string atyp =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("__shared__Array_"), 0xfe10, {.d_s = v__ast__Table_sym(g->table, elem_typ)->cname}}, {_SLIT0, 0, { .d_c = 0 }}}));
					string _t8 =  str_intp(5, _MOV((StrIntpData[]){{_SLIT("("), 0xfe10, {.d_s = atyp}}, {_SLIT("*)__dup_shared_array(&("), 0xfe10, {.d_s = atyp}}, {_SLIT("){.mtx = {0}, .val ="), 0xfe10, {.d_s = init_str}}, {_SLIT("}, sizeof("), 0xfe10, {.d_s = atyp}}, {_SLIT("))"), 0, { .d_c = 0 }}}));
					return _t8;
				} else {
					string _t9 = init_str;
					return _t9;
				}
			} break;
		case v__ast__Kind__map: 
			{
				v__ast__Map info = v__ast__TypeSymbol_map_info(sym);
				v__ast__TypeSymbol* key_typ = v__ast__Table_sym(g->table, info.key_type);
				multi_return_string_string_string_string mr_180920 = v__gen__c__Gen_map_fn_ptrs(g, *key_typ);
				string hash_fn = mr_180920.arg0;
				string key_eq_fn = mr_180920.arg1;
				string clone_fn = mr_180920.arg2;
				string free_fn = mr_180920.arg3;
				string noscan_key = v__gen__c__Gen_check_noscan(g, info.key_type);
				string noscan_value = v__gen__c__Gen_check_noscan(g, info.value_type);
				string noscan = (noscan_key.len != 0 || noscan_value.len != 0 ? (_SLIT("_noscan")) : (_SLIT("")));
				if (noscan.len != 0) {
					if (noscan_key.len != 0) {
						noscan = /*f*/string__plus(noscan, _SLIT("_key"));
					}
					if (noscan_value.len != 0) {
						noscan = /*f*/string__plus(noscan, _SLIT("_value"));
					}
				}
				string init_str =  str_intp(8, _MOV((StrIntpData[]){{_SLIT("new_map"), 0xfe10, {.d_s = noscan}}, {_SLIT("(sizeof("), 0xfe10, {.d_s = v__gen__c__Gen_typ(g, info.key_type)}}, {_SLIT("), sizeof("), 0xfe10, {.d_s = v__gen__c__Gen_typ(g, info.value_type)}}, {_SLIT("), "), 0xfe10, {.d_s = hash_fn}}, {_SLIT(", "), 0xfe10, {.d_s = key_eq_fn}}, {_SLIT(", "), 0xfe10, {.d_s = clone_fn}}, {_SLIT(", "), 0xfe10, {.d_s = free_fn}}, {_SLIT(")"), 0, { .d_c = 0 }}}));
				if (v__ast__Type_has_flag(typ, v__ast__TypeFlag__shared_f)) {
					string mtyp =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("__shared__Map_"), 0xfe10, {.d_s = key_typ->cname}}, {_SLIT("_"), 0xfe10, {.d_s = v__ast__Table_sym(g->table, info.value_type)->cname}}, {_SLIT0, 0, { .d_c = 0 }}}));
					string _t10 =  str_intp(5, _MOV((StrIntpData[]){{_SLIT("("), 0xfe10, {.d_s = mtyp}}, {_SLIT("*)__dup_shared_map(&("), 0xfe10, {.d_s = mtyp}}, {_SLIT("){.mtx = {0}, .val ="), 0xfe10, {.d_s = init_str}}, {_SLIT("}, sizeof("), 0xfe10, {.d_s = mtyp}}, {_SLIT("))"), 0, { .d_c = 0 }}}));
					return _t10;
				} else {
					string _t11 = init_str;
					return _t11;
				}
			} break;
		case v__ast__Kind__struct_: 
			{
				bool has_none_zero = false;
				string init_str = _SLIT("{");
				v__ast__Struct info = /* as */ *(v__ast__Struct*)__as_cast((sym->info)._v__ast__Struct,(sym->info)._typ, 446) /*expected idx: 446, name: v.ast.Struct */ ;
				bool typ_is_shared_f = v__ast__Type_has_flag(typ, v__ast__TypeFlag__shared_f);
				if (sym->language == v__ast__Language__v && !typ_is_shared_f) {
					for (int _t12 = 0; _t12 < info.fields.len; ++_t12) {
						v__ast__StructField field = ((v__ast__StructField*)info.fields.data)[_t12];
						v__ast__TypeSymbol* field_sym = v__ast__Table_sym(g->table, field.typ);
						if (field.has_default_expr || (field_sym->kind == v__ast__Kind__array || field_sym->kind == v__ast__Kind__map || field_sym->kind == v__ast__Kind__string || field_sym->kind == v__ast__Kind__bool || field_sym->kind == v__ast__Kind__alias || field_sym->kind == v__ast__Kind__i8 || field_sym->kind == v__ast__Kind__i16 || field_sym->kind == v__ast__Kind__int || field_sym->kind == v__ast__Kind__i64 || field_sym->kind == v__ast__Kind__byte || field_sym->kind == v__ast__Kind__u16 || field_sym->kind == v__ast__Kind__u32 || field_sym->kind == v__ast__Kind__u64 || field_sym->kind == v__ast__Kind__char || field_sym->kind == v__ast__Kind__voidptr || field_sym->kind == v__ast__Kind__byteptr || field_sym->kind == v__ast__Kind__charptr || field_sym->kind == v__ast__Kind__struct_)) {
							string field_name = v__gen__c__c_name(field.name);
							if (field.has_default_expr) {
								string expr_str = _SLIT("");
								if (v__ast__Table_sym(g->table, field.typ)->kind == v__ast__Kind__sum_type || v__ast__Table_sym(g->table, field.typ)->kind == v__ast__Kind__interface_) {
									expr_str = v__gen__c__Gen_expr_string_with_cast(g, field.default_expr, field.default_expr_typ, field.typ);
								} else {
									expr_str = v__gen__c__Gen_expr_string(g, field.default_expr);
								}
								init_str = /*f*/string__plus(init_str,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("."), 0xfe10, {.d_s = field_name}}, {_SLIT(" = "), 0xfe10, {.d_s = expr_str}}, {_SLIT(","), 0, { .d_c = 0 }}})));
							} else {
								string zero_str = v__gen__c__Gen_type_default(g, field.typ);
								if (string__eq(zero_str, _SLIT("{0}"))) {
									if ((field_sym->info)._typ == 446 /* v.ast.Struct */ && field_sym->language == v__ast__Language__v) {
										if ((*field_sym->info._v__ast__Struct).fields.len == 0 && (*field_sym->info._v__ast__Struct).embeds.len == 0) {
											zero_str = _SLIT("{EMPTY_STRUCT_INITIALIZATION}");
										}
									}
								}
								init_str = /*f*/string__plus(init_str,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("."), 0xfe10, {.d_s = field_name}}, {_SLIT(" = "), 0xfe10, {.d_s = zero_str}}, {_SLIT(","), 0, { .d_c = 0 }}})));
							}
							has_none_zero = true;
						}
					}
				}
				if (has_none_zero) {
					init_str = /*f*/string__plus(init_str, _SLIT("}"));
					string type_name = v__gen__c__Gen_typ(g, typ);
					init_str = string__plus( str_intp(2, _MOV((StrIntpData[]){{_SLIT("("), 0xfe10, {.d_s = type_name}}, {_SLIT(")"), 0, { .d_c = 0 }}})), init_str);
				} else {
					init_str = /*f*/string__plus(init_str, _SLIT("0}"));
				}
				if (v__ast__Type_has_flag(typ, v__ast__TypeFlag__shared_f)) {
					string styp =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("__shared__"), 0xfe10, {.d_s = v__ast__Table_sym(g->table, typ)->cname}}, {_SLIT0, 0, { .d_c = 0 }}}));
					string _t13 =  str_intp(6, _MOV((StrIntpData[]){{_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT("*)__dup"), 0xfe10, {.d_s = styp}}, {_SLIT("(&("), 0xfe10, {.d_s = styp}}, {_SLIT("){.mtx = {0}, .val ="), 0xfe10, {.d_s = init_str}}, {_SLIT("}, sizeof("), 0xfe10, {.d_s = styp}}, {_SLIT("))"), 0, { .d_c = 0 }}}));
					return _t13;
				} else {
					string _t14 = init_str;
					return _t14;
				}
			} break;
		case v__ast__Kind__placeholder:
		case v__ast__Kind__void:
		case v__ast__Kind__voidptr:
		case v__ast__Kind__byteptr:
		case v__ast__Kind__charptr:
		case v__ast__Kind__i8:
		case v__ast__Kind__i16:
		case v__ast__Kind__int:
		case v__ast__Kind__i64:
		case v__ast__Kind__isize:
		case v__ast__Kind__byte:
		case v__ast__Kind__u8:
		case v__ast__Kind__u16:
		case v__ast__Kind__u32:
		case v__ast__Kind__u64:
		case v__ast__Kind__usize:
		case v__ast__Kind__f32:
		case v__ast__Kind__f64:
		case v__ast__Kind__char:
		case v__ast__Kind__rune:
		case v__ast__Kind__bool:
		case v__ast__Kind__none_:
		case v__ast__Kind__any:
		case v__ast__Kind__generic_inst:
		case v__ast__Kind__enum_:
		case v__ast__Kind__function:
		case v__ast__Kind__float_literal:
		case v__ast__Kind__int_literal:
		case v__ast__Kind__aggregate:
		case v__ast__Kind__thread:
		default:
			{
				string _t15 = _SLIT("0");
				return _t15;
			} break;
	}
	;
	return (string){.str=(byteptr)"", .is_lit=1};
}

VV_LOCAL_SYMBOL Array_string v__gen__c__Gen_get_all_test_function_names(v__gen__c__Gen* g) {
	Array_string tfuncs = __new_array_with_default(0, 0, sizeof(string), 0);
	string tsuite_begin = _SLIT("");
	string tsuite_end = _SLIT("");
	Map_string_v__ast__Fn _t1 = g->table->fns;
	int _t3 = _t1.key_values.len;
	for (int _t2 = 0; _t2 < _t3; ++_t2 ) {
		int _t4 = _t1.key_values.len - _t3;
		_t3 = _t1.key_values.len;
		if (_t4 < 0) {
			_t2 = -1;
			continue;
		}
		if (!DenseArray_has_index(&_t1.key_values, _t2)) {continue;}
		v__ast__Fn f = (*(v__ast__Fn*)DenseArray_value(&_t1.key_values, _t2));
		if (string_ends_with(f.name, _SLIT(".testsuite_begin"))) {
			tsuite_begin = f.name;
			continue;
		}
		if (string_contains(f.name, _SLIT(".test_"))) {
			array_push((array*)&tfuncs, _MOV((string[]){ string_clone(f.name) }));
			continue;
		}
		if (string_ends_with(f.name, _SLIT(".testsuite_end"))) {
			tsuite_end = f.name;
			continue;
		}
	}
	Array_string all_tfuncs = __new_array_with_default(0, 0, sizeof(string), 0);
	if (tsuite_begin.len > 0) {
		array_push((array*)&all_tfuncs, _MOV((string[]){ string_clone(tsuite_begin) }));
	}
	_PUSH_MANY(&all_tfuncs, (tfuncs), _t7, Array_string);
	if (tsuite_end.len > 0) {
		array_push((array*)&all_tfuncs, _MOV((string[]){ string_clone(tsuite_end) }));
	}
	Array_string _t9 = all_tfuncs;
	return _t9;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_size_of(v__gen__c__Gen* g, v__ast__SizeOf node) {
	v__ast__Type typ = (v__ast__Type_alias_eq(node.typ, g->field_data_type) ? (g->comptime_for_field_value.typ) : (node.typ));
	v__ast__Type node_typ = v__gen__c__Gen_unwrap_generic(g, typ);
	v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, node_typ);
	if (sym->language == v__ast__Language__v && (sym->kind == v__ast__Kind__placeholder || sym->kind == v__ast__Kind__any)) {
		v__gen__c__Gen_error(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unknown type `"), 0xfe10, {.d_s = sym->name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), node.pos);
		VUNREACHABLE();
	}
	string styp = v__gen__c__Gen_typ(g, node_typ);
	v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("sizeof("), 0xfe10, {.d_s = v__util__no_dots(styp)}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
}

VV_LOCAL_SYMBOL bool v__gen__c__Gen_is_importing_os(v__gen__c__Gen* g) {
	bool _t1 = Array_string_contains(g->table->imports, _SLIT("os"));
	return _t1;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_go_expr(v__gen__c__Gen* g, v__ast__GoExpr node) {
	string line = v__gen__c__Gen_go_before_stmt(g, 0);
	string handle = _SLIT("");
	string tmp = v__gen__c__Gen_new_tmp_var(g);
	v__ast__CallExpr expr = node.call_expr;
	string name = expr.name;
	for (int i = 0; i < expr.concrete_types.len; ++i) {
		v__ast__Type concrete_type = ((v__ast__Type*)expr.concrete_types.data)[i];
		if (!v__ast__Type_alias_eq(concrete_type, _const_v__ast__void_type) && concrete_type != 0) {
			if (i == 0) {
				name = /*f*/string__plus(name, _SLIT("_T"));
			}
			name = /*f*/string__plus(name, string__plus(_SLIT("_"), v__gen__c__Gen_typ(g, concrete_type)));
		}
	}
	if (expr.is_method) {
		v__ast__TypeSymbol* receiver_sym = v__ast__Table_sym(g->table, expr.receiver_type);
		name = string__plus(string__plus(receiver_sym->name, _SLIT("_")), name);
	} else if ((expr.left)._typ == 278 /* v.ast.AnonFn */) {
		v__gen__c__Gen_gen_anon_fn_decl(g, (voidptr)&/*qq*/(*expr.left._v__ast__AnonFn));
		name = (*expr.left._v__ast__AnonFn).decl.name;
	}
	name = v__util__no_dots(name);
	if (g->pref->obfuscate && string__eq(g->cur_mod.name, _SLIT("main")) && string_starts_with(name, _SLIT("main__"))) {
		string key = expr.name;
		if (expr.is_method) {
			v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, expr.receiver_type);
			key = string__plus(string__plus(sym->name, _SLIT(".")), expr.name);
		}
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("/* obf go: "), 0xfe10, {.d_s = key}}, {_SLIT(" */"), 0, { .d_c = 0 }}})));
		string* _t2 = (string*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, g->obf_table), &(string[]){key}));
		Option_string _t1 = {0};
		if (_t2) {
			*((string*)&_t1.data) = *((string*)_t2);
		} else {
			_t1.state = 2; _t1.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t1.state != 0) { /*or block*/ 
			IError err = _t1.err;
			_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("cgen: obf name \""), 0xfe10, {.d_s = key}}, {_SLIT("\" not found, this should never happen"), 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		;
		}
		
		name = *(string*)_t1.data;
	}
	v__gen__c__Gen_writeln(g, _SLIT("// go"));
	string wrapper_struct_name = string__plus(_SLIT("thread_arg_"), name);
	string wrapper_fn_name = string__plus(name, _SLIT("_thread_wrapper"));
	string arg_tmp_var = string__plus(_SLIT("arg_"), tmp);
	v__gen__c__Gen_writeln(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = wrapper_struct_name}}, {_SLIT(" *"), 0xfe10, {.d_s = arg_tmp_var}}, {_SLIT(" = malloc(sizeof(thread_arg_"), 0xfe10, {.d_s = name}}, {_SLIT("));"), 0, { .d_c = 0 }}})));
	if (expr.is_method) {
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = arg_tmp_var}}, {_SLIT("->arg0 = "), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_expr(g, expr.left);
		v__gen__c__Gen_writeln(g, _SLIT(";"));
	}
	for (int i = 0; i < expr.args.len; ++i) {
		v__ast__CallArg arg = ((v__ast__CallArg*)expr.args.data)[i];
		v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = arg_tmp_var}}, {_SLIT("->arg"), 0xfe07, {.d_i32 = i + 1}}, {_SLIT(" = "), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_expr(g, arg.expr);
		v__gen__c__Gen_writeln(g, _SLIT(";"));
	}
	string s_ret_typ = v__gen__c__Gen_typ(g, node.call_expr.return_type);
	if (g->pref->os == v__pref__OS__windows && !v__ast__Type_alias_eq(node.call_expr.return_type, _const_v__ast__void_type)) {
		v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = arg_tmp_var}}, {_SLIT("->ret_ptr = malloc(sizeof("), 0xfe10, {.d_s = s_ret_typ}}, {_SLIT("));"), 0, { .d_c = 0 }}})));
	}
	bool is_opt = v__ast__Type_has_flag(node.call_expr.return_type, v__ast__TypeFlag__optional);
	string gohandle_name = _SLIT("");
	if (v__ast__Type_alias_eq(node.call_expr.return_type, _const_v__ast__void_type)) {
		gohandle_name = (is_opt ? (_SLIT("__v_thread_Option_void")) : (_SLIT("__v_thread")));
	} else {
		string opt = (is_opt ? (_SLIT("Option_")) : (_SLIT("")));
		gohandle_name =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("__v_thread_"), 0xfe10, {.d_s = opt}}, {_SLIT0, 0xfe10, {.d_s = v__ast__Table_sym(g->table, v__gen__c__Gen_unwrap_generic(g, node.call_expr.return_type))->cname}}, {_SLIT0, 0, { .d_c = 0 }}}));
	}
	if (g->pref->os == v__pref__OS__windows) {
		string simple_handle = (node.is_expr && !v__ast__Type_alias_eq(node.call_expr.return_type, _const_v__ast__void_type) ? ( str_intp(2, _MOV((StrIntpData[]){{_SLIT("thread_handle_"), 0xfe10, {.d_s = tmp}}, {_SLIT0, 0, { .d_c = 0 }}}))) : ( str_intp(2, _MOV((StrIntpData[]){{_SLIT("thread_"), 0xfe10, {.d_s = tmp}}, {_SLIT0, 0, { .d_c = 0 }}}))));
		v__gen__c__Gen_writeln(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("HANDLE "), 0xfe10, {.d_s = simple_handle}}, {_SLIT(" = CreateThread(0,0, (LPTHREAD_START_ROUTINE)"), 0xfe10, {.d_s = wrapper_fn_name}}, {_SLIT(", "), 0xfe10, {.d_s = arg_tmp_var}}, {_SLIT(", 0,0);"), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("if (!"), 0xfe10, {.d_s = simple_handle}}, {_SLIT(") panic_lasterr(tos3(\"`go "), 0xfe10, {.d_s = name}}, {_SLIT("()`: \"));"), 0, { .d_c = 0 }}})));
		if (node.is_expr && !v__ast__Type_alias_eq(node.call_expr.return_type, _const_v__ast__void_type)) {
			v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = gohandle_name}}, {_SLIT(" thread_"), 0xfe10, {.d_s = tmp}}, {_SLIT(" = {"), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t.ret_ptr = "), 0xfe10, {.d_s = arg_tmp_var}}, {_SLIT("->ret_ptr,"), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t.handle = thread_handle_"), 0xfe10, {.d_s = tmp}}, {_SLIT0, 0, { .d_c = 0 }}})));
			v__gen__c__Gen_writeln(g, _SLIT("};"));
		}
		if (!node.is_expr) {
			v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("CloseHandle(thread_"), 0xfe10, {.d_s = tmp}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
		}
	} else {
		v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("pthread_t thread_"), 0xfe10, {.d_s = tmp}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_writeln(g,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("int "), 0xfe10, {.d_s = tmp}}, {_SLIT("_thr_res = pthread_create(&thread_"), 0xfe10, {.d_s = tmp}}, {_SLIT(", NULL, (void*)"), 0xfe10, {.d_s = wrapper_fn_name}}, {_SLIT(", "), 0xfe10, {.d_s = arg_tmp_var}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_writeln(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("if ("), 0xfe10, {.d_s = tmp}}, {_SLIT("_thr_res) panic_error_number(tos3(\"`go "), 0xfe10, {.d_s = name}}, {_SLIT("()`: \"), "), 0xfe10, {.d_s = tmp}}, {_SLIT("_thr_res);"), 0, { .d_c = 0 }}})));
		if (!node.is_expr) {
			v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("pthread_detach(thread_"), 0xfe10, {.d_s = tmp}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
		}
	}
	v__gen__c__Gen_writeln(g, _SLIT("// endgo\n"));
	if (node.is_expr) {
		handle =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("thread_"), 0xfe10, {.d_s = tmp}}, {_SLIT0, 0, { .d_c = 0 }}}));
		string waiter_fn_name = string__plus(gohandle_name, _SLIT("_wait"));
		bool should_register = false;
		sync__RwMutex_lock(&g->waiter_fns->mtx);
		/*lock*/ {
			if (!Array_string_contains(g->waiter_fns->val, waiter_fn_name)) {
				array_push((array*)&g->waiter_fns->val, _MOV((string[]){ string_clone(waiter_fn_name) }));
				should_register = true;
			}
		}
		sync__RwMutex_unlock(&g->waiter_fns->mtx);;
		if (should_register) {
			strings__Builder_writeln(&g->gowrappers,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\n"), 0xfe10, {.d_s = s_ret_typ}}, {_SLIT(" "), 0xfe10, {.d_s = waiter_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = gohandle_name}}, {_SLIT(" thread) {"), 0, { .d_c = 0 }}})));
			string c_ret_ptr_ptr = _SLIT("NULL");
			if (!v__ast__Type_alias_eq(node.call_expr.return_type, _const_v__ast__void_type)) {
				strings__Builder_writeln(&g->gowrappers,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = s_ret_typ}}, {_SLIT("* ret_ptr;"), 0, { .d_c = 0 }}})));
				c_ret_ptr_ptr = _SLIT("&ret_ptr");
			}
			if (g->pref->os == v__pref__OS__windows) {
				if (v__ast__Type_alias_eq(node.call_expr.return_type, _const_v__ast__void_type)) {
					strings__Builder_writeln(&g->gowrappers, _SLIT("\tu32 stat = WaitForSingleObject(thread, INFINITE);"));
				} else {
					strings__Builder_writeln(&g->gowrappers, _SLIT("\tu32 stat = WaitForSingleObject(thread.handle, INFINITE);"));
					strings__Builder_writeln(&g->gowrappers, _SLIT("\tret_ptr = thread.ret_ptr;"));
				}
			} else {
				strings__Builder_writeln(&g->gowrappers,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\tint stat = pthread_join(thread, (void **)"), 0xfe10, {.d_s = c_ret_ptr_ptr}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
			}
			strings__Builder_writeln(&g->gowrappers, _SLIT("\tif (stat != 0) { _v_panic(_SLIT(\"unable to join thread\")); }"));
			if (g->pref->os == v__pref__OS__windows) {
				if (v__ast__Type_alias_eq(node.call_expr.return_type, _const_v__ast__void_type)) {
					strings__Builder_writeln(&g->gowrappers, _SLIT("\tCloseHandle(thread);"));
				} else {
					strings__Builder_writeln(&g->gowrappers, _SLIT("\tCloseHandle(thread.handle);"));
				}
			}
			if (!v__ast__Type_alias_eq(node.call_expr.return_type, _const_v__ast__void_type)) {
				strings__Builder_writeln(&g->gowrappers,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = s_ret_typ}}, {_SLIT(" ret = *ret_ptr;"), 0, { .d_c = 0 }}})));
				strings__Builder_writeln(&g->gowrappers, _SLIT("\tfree(ret_ptr);"));
				strings__Builder_writeln(&g->gowrappers, _SLIT("\treturn ret;"));
			}
			strings__Builder_writeln(&g->gowrappers, _SLIT("}"));
		}
	}
	bool should_register = false;
	sync__RwMutex_lock(&g->threaded_fns->mtx);
	/*lock*/ {
		if (!Array_string_contains(g->threaded_fns->val, name)) {
			array_push((array*)&g->threaded_fns->val, _MOV((string[]){ string_clone(name) }));
			should_register = true;
		}
	}
	sync__RwMutex_unlock(&g->threaded_fns->mtx);;
	if (should_register) {
		strings__Builder_writeln(&g->type_definitions,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\ntypedef struct "), 0xfe10, {.d_s = wrapper_struct_name}}, {_SLIT(" {"), 0, { .d_c = 0 }}})));
		if (expr.is_method) {
			string styp = v__gen__c__Gen_typ(g, expr.receiver_type);
			strings__Builder_writeln(&g->type_definitions,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = styp}}, {_SLIT(" arg0;"), 0, { .d_c = 0 }}})));
		}
		bool need_return_ptr = g->pref->os == v__pref__OS__windows && !v__ast__Type_alias_eq(node.call_expr.return_type, _const_v__ast__void_type);
		if (expr.args.len == 0 && !need_return_ptr) {
			strings__Builder_writeln(&g->type_definitions, _SLIT("EMPTY_STRUCT_DECLARATION;"));
		} else {
			for (int i = 0; i < expr.args.len; ++i) {
				v__ast__CallArg arg = ((v__ast__CallArg*)expr.args.data)[i];
				string styp = v__gen__c__Gen_typ(g, arg.typ);
				strings__Builder_writeln(&g->type_definitions,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = styp}}, {_SLIT(" arg"), 0xfe07, {.d_i32 = i + 1}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
			}
		}
		if (need_return_ptr) {
			strings__Builder_writeln(&g->type_definitions, _SLIT("\tvoid* ret_ptr;"));
		}
		strings__Builder_writeln(&g->type_definitions,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("} "), 0xfe10, {.d_s = wrapper_struct_name}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
		string thread_ret_type = (g->pref->os == v__pref__OS__windows ? (_SLIT("u32")) : (_SLIT("void*")));
		strings__Builder_writeln(&g->type_definitions,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = thread_ret_type}}, {_SLIT(" "), 0xfe10, {.d_s = wrapper_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = wrapper_struct_name}}, {_SLIT(" *arg);"), 0, { .d_c = 0 }}})));
		strings__Builder_writeln(&g->gowrappers,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = thread_ret_type}}, {_SLIT(" "), 0xfe10, {.d_s = wrapper_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = wrapper_struct_name}}, {_SLIT(" *arg) {"), 0, { .d_c = 0 }}})));
		if (!v__ast__Type_alias_eq(node.call_expr.return_type, _const_v__ast__void_type)) {
			if (g->pref->os == v__pref__OS__windows) {
				strings__Builder_write_string(&g->gowrappers,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t*(("), 0xfe10, {.d_s = s_ret_typ}}, {_SLIT("*)(arg->ret_ptr)) = "), 0, { .d_c = 0 }}})));
			} else {
				strings__Builder_writeln(&g->gowrappers,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = s_ret_typ}}, {_SLIT("* ret_ptr = malloc(sizeof("), 0xfe10, {.d_s = s_ret_typ}}, {_SLIT("));"), 0, { .d_c = 0 }}})));
				strings__Builder_write_string(&g->gowrappers, _SLIT("\t*ret_ptr = "));
			}
		} else {
			strings__Builder_write_string(&g->gowrappers, _SLIT("\t"));
		}
		if (expr.is_method) {
			v__ast__Type unwrapped_rec_type = v__gen__c__Gen_unwrap_generic(g, expr.receiver_type);
			v__ast__TypeSymbol* typ_sym = v__ast__Table_sym(g->table, unwrapped_rec_type);
			if (typ_sym->kind == v__ast__Kind__interface_ && v__ast__Interface_defines_method(ADDR(v__ast__Interface, (/* as */ *(v__ast__Interface*)__as_cast((typ_sym->info)._v__ast__Interface,(typ_sym->info)._typ, 463) /*expected idx: 463, name: v.ast.Interface */ )), expr.name)) {
				string rec_cc_type = v__gen__c__Gen_cc_type(g, unwrapped_rec_type, false);
				string receiver_type_name = v__util__no_dots(rec_cc_type);
				strings__Builder_write_string(&g->gowrappers,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__gen__c__c_name(receiver_type_name)}}, {_SLIT("_name_table["), 0, { .d_c = 0 }}})));
				strings__Builder_write_string(&g->gowrappers, _SLIT("arg->arg0"));
				string dot = (v__ast__Type_is_ptr(expr.left_type) ? (_SLIT("->")) : (_SLIT(".")));
				string mname = v__gen__c__c_name(expr.name);
				strings__Builder_write_string(&g->gowrappers,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = dot}}, {_SLIT("_typ]._method_"), 0xfe10, {.d_s = mname}}, {_SLIT("("), 0, { .d_c = 0 }}})));
				strings__Builder_write_string(&g->gowrappers, _SLIT("arg->arg0"));
				strings__Builder_write_string(&g->gowrappers,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = dot}}, {_SLIT("_object"), 0, { .d_c = 0 }}})));
			} else {
				strings__Builder_write_string(&g->gowrappers,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = name}}, {_SLIT("("), 0, { .d_c = 0 }}})));
				strings__Builder_write_string(&g->gowrappers, _SLIT("arg->arg0"));
			}
			if (expr.args.len > 0) {
				strings__Builder_write_string(&g->gowrappers, _SLIT(", "));
			}
		} else {
			strings__Builder_write_string(&g->gowrappers,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = name}}, {_SLIT("("), 0, { .d_c = 0 }}})));
		}
		if (expr.args.len > 0) {
			bool has_cast = false;
			for (int i = 0; i < expr.args.len; ++i) {
				if (v__ast__Table_sym(g->table, (*(v__ast__Type*)/*ee elem_typ */array_get(expr.expected_arg_types, i)))->kind == v__ast__Kind__interface_ && v__ast__Table_sym(g->table, (*(v__ast__CallArg*)/*ee elem_typ */array_get(expr.args, i)).typ)->kind != v__ast__Kind__interface_) {
					has_cast = true;
					break;
				}
			}
			if (has_cast) {
				int pos = g->out.len;
				v__gen__c__Gen_call_args(g, expr);
				string call_args_str = strings__Builder_after(&g->out, pos);
				strings__Builder_go_back(&g->out, call_args_str.len);
				Array_string rep_group = __new_array_with_default(0, 2 * expr.args.len, sizeof(string), 0);
				for (int i = 0; i < expr.args.len; ++i) {
					array_push((array*)&rep_group, _MOV((string[]){ string_clone(v__gen__c__Gen_expr_string(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(expr.args, i)).expr)) }));
					array_push((array*)&rep_group, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("arg->arg"), 0xfe07, {.d_i32 = i + 1}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
				}
				call_args_str = string_replace_each(call_args_str, rep_group);
				strings__Builder_write_string(&g->gowrappers, call_args_str);
			} else {
				for (int i = 0; i < expr.args.len; ++i) {
					strings__Builder_write_string(&g->gowrappers,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("arg->arg"), 0xfe07, {.d_i32 = i + 1}}, {_SLIT0, 0, { .d_c = 0 }}})));
					if (i != expr.args.len - 1) {
						strings__Builder_write_string(&g->gowrappers, _SLIT(", "));
					}
				}
			}
		}
		strings__Builder_writeln(&g->gowrappers, _SLIT(");"));
		strings__Builder_writeln(&g->gowrappers, _SLIT("\tfree(arg);"));
		if (g->pref->os != v__pref__OS__windows && !v__ast__Type_alias_eq(node.call_expr.return_type, _const_v__ast__void_type)) {
			strings__Builder_writeln(&g->gowrappers, _SLIT("\treturn ret_ptr;"));
		} else {
			strings__Builder_writeln(&g->gowrappers, _SLIT("\treturn 0;"));
		}
		strings__Builder_writeln(&g->gowrappers, _SLIT("}"));
	}
	if (node.is_expr) {
		g->empty_line = false;
		v__gen__c__Gen_write(g, line);
		v__gen__c__Gen_write(g, handle);
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_as_cast(v__gen__c__Gen* g, v__ast__AsCast node) {
	string styp = v__gen__c__Gen_typ(g, node.typ);
	v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, node.typ);
	v__ast__TypeSymbol* expr_type_sym = v__ast__Table_sym(g->table, node.expr_type);
	if ((expr_type_sym->info)._typ == 464 /* v.ast.SumType */) {
		string dot = (v__ast__Type_is_ptr(node.expr_type) ? (_SLIT("->")) : (_SLIT(".")));
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("/* as */ *("), 0xfe10, {.d_s = styp}}, {_SLIT("*)__as_cast("), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_write(g, _SLIT("("));
		v__gen__c__Gen_expr(g, node.expr);
		v__gen__c__Gen_write(g, _SLIT(")"));
		v__gen__c__Gen_write(g, dot);
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("_"), 0xfe10, {.d_s = sym->cname}}, {_SLIT(","), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_write(g, _SLIT("("));
		v__gen__c__Gen_expr(g, node.expr);
		v__gen__c__Gen_write(g, _SLIT(")"));
		v__gen__c__Gen_write(g, dot);
		string sidx = v__gen__c__Gen_type_sidx(g, node.typ);
		v__ast__TypeSymbol* expected_sym = v__ast__Table_sym(g->table, node.typ);
		v__gen__c__Gen_write(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("_typ, "), 0xfe10, {.d_s = sidx}}, {_SLIT(") /*expected idx: "), 0xfe10, {.d_s = sidx}}, {_SLIT(", name: "), 0xfe10, {.d_s = expected_sym->name}}, {_SLIT(" */ "), 0, { .d_c = 0 }}})));
		for (int _t1 = 0; _t1 < (*expr_type_sym->info._v__ast__SumType).variants.len; ++_t1) {
			v__ast__Type variant = ((v__ast__Type*)(*expr_type_sym->info._v__ast__SumType).variants.data)[_t1];
			string idx = u32_str(((u32)(variant)));
			if (_IN_MAP(ADDR(string, idx), ADDR(map, g->as_cast_type_names))) {
				continue;
			}
			v__ast__TypeSymbol* variant_sym = v__ast__Table_sym(g->table, variant);
			map_set(&g->as_cast_type_names, &(string[]){idx}, &(string[]) { variant_sym->name });
		}
	} else if (expr_type_sym->kind == v__ast__Kind__interface_ && sym->kind == v__ast__Kind__interface_) {
		v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("I_"), 0xfe10, {.d_s = expr_type_sym->cname}}, {_SLIT("_as_I_"), 0xfe10, {.d_s = sym->cname}}, {_SLIT("("), 0, { .d_c = 0 }}})));
		if (v__ast__Type_is_ptr(node.expr_type)) {
			v__gen__c__Gen_write(g, _SLIT("*"));
		}
		v__gen__c__Gen_expr(g, node.expr);
		v__gen__c__Gen_write(g, _SLIT(")"));
		v__ast__Interface info = /* as */ *(v__ast__Interface*)__as_cast((expr_type_sym->info)._v__ast__Interface,(expr_type_sym->info)._typ, 463) /*expected idx: 463, name: v.ast.Interface */ ;
		if (!_IN_MAP(ADDR(int, node.typ), ADDR(map, info.conversions))) {
			Array_v__ast__Type left_variants = (*(Array_v__ast__Type*)map_get(ADDR(map, g->table->iface_types), &(string[]){expr_type_sym->name}, &(Array_v__ast__Type[]){ __new_array(0, 0, sizeof(v__ast__Type)) }));
			Array_v__ast__Type right_variants = (*(Array_v__ast__Type*)map_get(ADDR(map, g->table->iface_types), &(string[]){sym->name}, &(Array_v__ast__Type[]){ __new_array(0, 0, sizeof(v__ast__Type)) }));
			Array_v__ast__Type _t2 = __new_array(0, 0, sizeof(v__ast__Type));
			Array_v__ast__Type _t2_orig = left_variants;
			int _t2_len = _t2_orig.len;
			_t2 = __new_array(0, _t2_len, sizeof(v__ast__Type));

			for (int _t3 = 0; _t3 < _t2_len; ++_t3) {
				v__ast__Type it = ((v__ast__Type*) _t2_orig.data)[_t3];
				if (Array_v__ast__Type_contains(right_variants, it)) {
					array_push((array*)&_t2, &it);
				}
			}
			map_set(&info.conversions, &(int[]){node.typ}, &(Array_v__ast__Type[]) {_t2 });
		}
		expr_type_sym->info = v__ast__Interface_to_sumtype_v__ast__TypeInfo(&info);
	} else {
		v__gen__c__Gen_expr(g, node.expr);
	}
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_as_cast_name_table(v__gen__c__Gen* g) {
	if (g->as_cast_type_names.len == 0) {
		string _t1 = _SLIT("new_array_from_c_array(1, 1, sizeof(VCastTypeIndexName), _MOV((VCastTypeIndexName[1]){(VCastTypeIndexName){.tindex = 0,.tname = _SLIT(\"unknown\")}}));\n");
		return _t1;
	}
	strings__Builder name_ast = strings__new_builder(1024);
	int casts_len = g->as_cast_type_names.len + 1;
	strings__Builder_writeln(&name_ast,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("new_array_from_c_array("), 0xfe07, {.d_i32 = casts_len}}, {_SLIT(", "), 0xfe07, {.d_i32 = casts_len}}, {_SLIT(", sizeof(VCastTypeIndexName), _MOV((VCastTypeIndexName["), 0xfe07, {.d_i32 = casts_len}}, {_SLIT("]){"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&name_ast, _SLIT("\t\t  (VCastTypeIndexName){.tindex = 0, .tname = _SLIT(\"unknown\")}"));
	Map_string_string _t2 = g->as_cast_type_names;
	int _t4 = _t2.key_values.len;
	for (int _t3 = 0; _t3 < _t4; ++_t3 ) {
		int _t5 = _t2.key_values.len - _t4;
		_t4 = _t2.key_values.len;
		if (_t5 < 0) {
			_t3 = -1;
			continue;
		}
		if (!DenseArray_has_index(&_t2.key_values, _t3)) {continue;}
		string key = /*key*/ *(string*)DenseArray_key(&_t2.key_values, _t3);
		key = string_clone(key);
		string value = (*(string*)DenseArray_value(&_t2.key_values, _t3));
		strings__Builder_writeln(&name_ast,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\t, (VCastTypeIndexName){.tindex = "), 0xfe10, {.d_s = key}}, {_SLIT(", .tname = _SLIT(\""), 0xfe10, {.d_s = value}}, {_SLIT("\")}"), 0, { .d_c = 0 }}})));
	}
	strings__Builder_writeln(&name_ast, _SLIT("\t}));\n"));
	string _t6 = strings__Builder_str(&name_ast);
	return _t6;
}

VV_LOCAL_SYMBOL bool v__gen__c__Gen_has_been_referenced(v__gen__c__Gen* g, string fn_name) {
	bool referenced = false;
	sync__RwMutex_lock(&g->referenced_fns->mtx);
	/*lock*/ {
		referenced = (*(bool*)map_get(ADDR(map, g->referenced_fns->val), &(string[]){fn_name}, &(bool[]){ 0 }));
	}
	sync__RwMutex_unlock(&g->referenced_fns->mtx);;
	bool _t1 = referenced;
	return _t1;
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_interface_table(v__gen__c__Gen* g) {
	strings__Builder sb = strings__new_builder(100);
	strings__Builder conversion_functions = strings__new_builder(100);
	for (int _t1 = 0; _t1 < g->table->type_symbols.len; ++_t1) {
		v__ast__TypeSymbol* isym = ((v__ast__TypeSymbol**)g->table->type_symbols.data)[_t1];
		if (isym->kind != v__ast__Kind__interface_) {
			continue;
		}
		if ((isym->info)._typ != 463 /* v.ast.Interface */) {
			continue;
		}
		v__ast__Interface inter_info = /* as */ *(v__ast__Interface*)__as_cast((isym->info)._v__ast__Interface,(isym->info)._typ, 463) /*expected idx: 463, name: v.ast.Interface */ ;
		if (inter_info.is_generic) {
			continue;
		}
		string interface_name = isym->cname;
		string methods_struct_name =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("struct _"), 0xfe10, {.d_s = interface_name}}, {_SLIT("_interface_methods"), 0, { .d_c = 0 }}}));
		strings__Builder methods_struct_def = strings__new_builder(100);
		strings__Builder_writeln(&methods_struct_def,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = methods_struct_name}}, {_SLIT(" {"), 0, { .d_c = 0 }}})));
		Map_string_int methodidx = new_map(sizeof(string), sizeof(int), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
		for (int k = 0; k < inter_info.methods.len; ++k) {
			v__ast__Fn method = ((v__ast__Fn*)inter_info.methods.data)[k];
			map_set(&methodidx, &(string[]){method.name}, &(int[]) { k });
			string ret_styp = v__gen__c__Gen_typ(g, method.return_type);
			strings__Builder_write_string(&methods_struct_def,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = ret_styp}}, {_SLIT(" (*_method_"), 0xfe10, {.d_s = v__gen__c__c_name(method.name)}}, {_SLIT(")(void* _"), 0, { .d_c = 0 }}})));
			for (int i = 1; i < method.params.len; ++i) {
				v__ast__Param arg = (*(v__ast__Param*)/*ee elem_typ */array_get(method.params, i));
				strings__Builder_write_string(&methods_struct_def,  str_intp(3, _MOV((StrIntpData[]){{_SLIT(", "), 0xfe10, {.d_s = v__gen__c__Gen_typ(g, arg.typ)}}, {_SLIT(" "), 0xfe10, {.d_s = arg.name}}, {_SLIT0, 0, { .d_c = 0 }}})));
			}
			strings__Builder_writeln(&methods_struct_def, _SLIT(");"));
		}
		strings__Builder_writeln(&methods_struct_def, _SLIT("};"));
		strings__Builder methods_struct = strings__new_builder(100);
		int iname_table_length = inter_info.types.len;
		if (iname_table_length == 0) {
			strings__Builder_writeln(&methods_struct,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = methods_struct_name}}, {_SLIT(" "), 0xfe10, {.d_s = interface_name}}, {_SLIT("_name_table[1];"), 0, { .d_c = 0 }}})));
		} else {
			if (g->pref->build_mode != v__pref__BuildMode__build_module) {
				strings__Builder_writeln(&methods_struct,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = methods_struct_name}}, {_SLIT(" "), 0xfe10, {.d_s = interface_name}}, {_SLIT("_name_table["), 0xfe07, {.d_i32 = iname_table_length}}, {_SLIT("] = {"), 0, { .d_c = 0 }}})));
			} else {
				strings__Builder_writeln(&methods_struct,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = methods_struct_name}}, {_SLIT(" "), 0xfe10, {.d_s = interface_name}}, {_SLIT("_name_table["), 0xfe07, {.d_i32 = iname_table_length}}, {_SLIT("];"), 0, { .d_c = 0 }}})));
			}
		}
		strings__Builder cast_functions = strings__new_builder(100);
		strings__Builder methods_wrapper = strings__new_builder(100);
		strings__Builder_writeln(&methods_wrapper,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("// Methods wrapper for interface \""), 0xfe10, {.d_s = interface_name}}, {_SLIT("\""), 0, { .d_c = 0 }}})));
		Map_string_int already_generated_mwrappers = new_map(sizeof(string), sizeof(int), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
		int iinidx_minimum_base = 1000;
		int current_iinidx = iinidx_minimum_base;
		for (int _t2 = 0; _t2 < inter_info.types.len; ++_t2) {
			v__ast__Type st = ((v__ast__Type*)inter_info.types.data)[_t2];
			v__ast__TypeSymbol* st_sym = v__ast__Table_sym(g->table, st);
			string cctype = v__gen__c__Gen_cc_type(g, st, true);
			string interface_index_name =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("_"), 0xfe10, {.d_s = interface_name}}, {_SLIT("_"), 0xfe10, {.d_s = cctype}}, {_SLIT("_index"), 0, { .d_c = 0 }}}));
			if ((*(int*)map_get(ADDR(map, already_generated_mwrappers), &(string[]){interface_index_name}, &(int[]){ 0 })) > 0) {
				continue;
			}
			map_set(&already_generated_mwrappers, &(string[]){interface_index_name}, &(int[]) { current_iinidx });
			current_iinidx++;
			if (!string__eq(isym->name, _SLIT("vweb.DbInterface"))) {
				strings__Builder_writeln(&sb,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("static "), 0xfe10, {.d_s = interface_name}}, {_SLIT(" I_"), 0xfe10, {.d_s = cctype}}, {_SLIT("_to_Interface_"), 0xfe10, {.d_s = interface_name}}, {_SLIT("("), 0xfe10, {.d_s = cctype}}, {_SLIT("* x);"), 0, { .d_c = 0 }}})));
				strings__Builder cast_struct = strings__new_builder(100);
				strings__Builder_writeln(&cast_struct,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("("), 0xfe10, {.d_s = interface_name}}, {_SLIT(") {"), 0, { .d_c = 0 }}})));
				strings__Builder_writeln(&cast_struct,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\t._"), 0xfe10, {.d_s = cctype}}, {_SLIT(" = x,"), 0, { .d_c = 0 }}})));
				strings__Builder_writeln(&cast_struct,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\t._typ = "), 0xfe10, {.d_s = interface_index_name}}, {_SLIT(","), 0, { .d_c = 0 }}})));
				for (int _t3 = 0; _t3 < inter_info.fields.len; ++_t3) {
					v__ast__StructField field = ((v__ast__StructField*)inter_info.fields.data)[_t3];
					string cname = v__gen__c__c_name(field.name);
					string field_styp = v__gen__c__Gen_typ(g, field.typ);
					Option_v__ast__StructField _t4;
					if (_t4 = v__ast__TypeSymbol_find_field(st_sym, field.name), _t4.state == 0) {
						strings__Builder_writeln(&cast_struct,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("\t\t."), 0xfe10, {.d_s = cname}}, {_SLIT(" = ("), 0xfe10, {.d_s = field_styp}}, {_SLIT("*)((char*)x + __offsetof_ptr(x, "), 0xfe10, {.d_s = cctype}}, {_SLIT(", "), 0xfe10, {.d_s = cname}}, {_SLIT(")),"), 0, { .d_c = 0 }}})));
					} else {
						IError err = _t4.err;
						strings__Builder_write_string(&cast_struct,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\t."), 0xfe10, {.d_s = cname}}, {_SLIT(" = ("), 0xfe10, {.d_s = field_styp}}, {_SLIT("*)((char*)x"), 0, { .d_c = 0 }}})));
						if (v__ast__Type_alias_eq(st, _const_v__ast__voidptr_type)) {
							strings__Builder_write_string(&cast_struct, _SLIT("/*.... ast.voidptr_type */"));
						} else {
							for (int _t5 = 0; _t5 < v__ast__TypeSymbol_struct_info(st_sym).embeds.len; ++_t5) {
								v__ast__Type embed_type = ((v__ast__Type*)v__ast__TypeSymbol_struct_info(st_sym).embeds.data)[_t5];
								v__ast__TypeSymbol* embed_sym = v__ast__Table_sym(g->table, embed_type);
								Option_v__ast__StructField _t6;
								if (_t6 = v__ast__TypeSymbol_find_field(embed_sym, field.name), _t6.state == 0) {
									strings__Builder_write_string(&cast_struct,  str_intp(5, _MOV((StrIntpData[]){{_SLIT(" + __offsetof_ptr(x, "), 0xfe10, {.d_s = cctype}}, {_SLIT(", "), 0xfe10, {.d_s = v__ast__TypeSymbol_embed_name(embed_sym)}}, {_SLIT(") + __offsetof_ptr(x, "), 0xfe10, {.d_s = embed_sym->cname}}, {_SLIT(", "), 0xfe10, {.d_s = cname}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
									break;
								}
							}
						}
						strings__Builder_writeln(&cast_struct, _SLIT("),"));
					}
				}
				strings__Builder_write_string(&cast_struct, _SLIT("\t}"));
				string cast_struct_str = strings__Builder_str(&cast_struct);
				strings__Builder_writeln(&cast_functions,  str_intp(8, _MOV((StrIntpData[]){{_SLIT("\n// Casting functions for converting \""), 0xfe10, {.d_s = cctype}}, {_SLIT("\" to interface \""), 0xfe10, {.d_s = interface_name}}, {_SLIT("\"\nstatic inline "), 0xfe10, {.d_s = interface_name}}, {_SLIT(" I_"), 0xfe10, {.d_s = cctype}}, {_SLIT("_to_Interface_"), 0xfe10, {.d_s = interface_name}}, {_SLIT("("), 0xfe10, {.d_s = cctype}}, {_SLIT("* x) {\n	return "), 0xfe10, {.d_s = cast_struct_str}}, {_SLIT(";\n}"), 0, { .d_c = 0 }}})));
				string shared_fn_name =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("I___shared__"), 0xfe10, {.d_s = cctype}}, {_SLIT("_to_shared_Interface___shared__"), 0xfe10, {.d_s = interface_name}}, {_SLIT0, 0, { .d_c = 0 }}}));
				if (v__gen__c__Gen_has_been_referenced(g, shared_fn_name)) {
					strings__Builder cast_shared_struct = strings__new_builder(100);
					strings__Builder_writeln(&cast_shared_struct,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("(__shared__"), 0xfe10, {.d_s = interface_name}}, {_SLIT(") {"), 0, { .d_c = 0 }}})));
					strings__Builder_writeln(&cast_shared_struct, _SLIT("\t\t.mtx = {0},"));
					strings__Builder_writeln(&cast_shared_struct, _SLIT("\t\t.val = {"));
					strings__Builder_writeln(&cast_shared_struct,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\t\t._"), 0xfe10, {.d_s = cctype}}, {_SLIT(" = &x->val,"), 0, { .d_c = 0 }}})));
					strings__Builder_writeln(&cast_shared_struct,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\t\t._typ = "), 0xfe10, {.d_s = interface_index_name}}, {_SLIT(","), 0, { .d_c = 0 }}})));
					strings__Builder_writeln(&cast_shared_struct, _SLIT("\t\t}"));
					strings__Builder_write_string(&cast_shared_struct, _SLIT("\t}"));
					string cast_shared_struct_str = strings__Builder_str(&cast_shared_struct);
					strings__Builder_writeln(&cast_functions,  str_intp(7, _MOV((StrIntpData[]){{_SLIT("\n// Casting functions for converting \"__shared__"), 0xfe10, {.d_s = cctype}}, {_SLIT("\" to interface \"__shared__"), 0xfe10, {.d_s = interface_name}}, {_SLIT("\"\nstatic inline __shared__"), 0xfe10, {.d_s = interface_name}}, {_SLIT(" "), 0xfe10, {.d_s = shared_fn_name}}, {_SLIT("(__shared__"), 0xfe10, {.d_s = cctype}}, {_SLIT("* x) {\n	return "), 0xfe10, {.d_s = cast_shared_struct_str}}, {_SLIT(";\n}"), 0, { .d_c = 0 }}})));
				}
			}
			if (g->pref->build_mode != v__pref__BuildMode__build_module) {
				strings__Builder_writeln(&methods_struct, _SLIT("\t{"));
			}
			if (v__ast__Type_alias_eq(st, _const_v__ast__voidptr_type)) {
				int _t8 = methodidx.key_values.len;
				for (int _t7 = 0; _t7 < _t8; ++_t7 ) {
					int _t9 = methodidx.key_values.len - _t8;
					_t8 = methodidx.key_values.len;
					if (_t9 < 0) {
						_t7 = -1;
						continue;
					}
					if (!DenseArray_has_index(&methodidx.key_values, _t7)) {continue;}
					string mname = /*key*/ *(string*)DenseArray_key(&methodidx.key_values, _t7);
					mname = string_clone(mname);
					if (g->pref->build_mode != v__pref__BuildMode__build_module) {
						strings__Builder_writeln(&methods_struct,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\t._method_"), 0xfe10, {.d_s = v__gen__c__c_name(mname)}}, {_SLIT(" = (void*) 0,"), 0, { .d_c = 0 }}})));
					}
				}
			}
			Array_v__ast__Fn methods = st_sym->methods;
			Array_string _t10 = __new_array(0, 0, sizeof(string));
			Array_v__ast__Fn _t10_orig = methods;
			int _t10_len = _t10_orig.len;
			_t10 = __new_array(0, _t10_len, sizeof(string));

			for (int _t11 = 0; _t11 < _t10_len; ++_t11) {
				v__ast__Fn it = ((v__ast__Fn*) _t10_orig.data)[_t11];
				string ti = it.name;
				array_push((array*)&_t10, &ti);
			}
			Array_string method_names =_t10;
			if (st_sym->info._typ == 446 /* v.ast.Struct */) {
				if (v__ast__Type_has_flag((*st_sym->info._v__ast__Struct).parent_type, v__ast__TypeFlag__generic)) {
					v__ast__TypeSymbol* parent_sym = v__ast__Table_sym(g->table, (*st_sym->info._v__ast__Struct).parent_type);
					for (int _t12 = 0; _t12 < parent_sym->methods.len; ++_t12) {
						v__ast__Fn method = ((v__ast__Fn*)parent_sym->methods.data)[_t12];
						if (_IN_MAP(ADDR(string, method.name), ADDR(map, methodidx))) {
							Option_v__ast__Fn _t14 = v__ast__TypeSymbol_find_method_with_generic_parent(st_sym, method.name);
							if (_t14.state != 0) { /*or block*/ 
								IError err = _t14.err;
								continue;
							}
							
 							array_push((array*)&methods, _MOV((v__ast__Fn[]){  (*(v__ast__Fn*)_t14.data) }));
						}
					}
				}
			}
			else if (st_sym->info._typ == 463 /* v.ast.Interface */) {
				if (v__ast__Type_has_flag((*st_sym->info._v__ast__Interface).parent_type, v__ast__TypeFlag__generic)) {
					v__ast__TypeSymbol* parent_sym = v__ast__Table_sym(g->table, (*st_sym->info._v__ast__Interface).parent_type);
					for (int _t15 = 0; _t15 < parent_sym->methods.len; ++_t15) {
						v__ast__Fn method = ((v__ast__Fn*)parent_sym->methods.data)[_t15];
						if (_IN_MAP(ADDR(string, method.name), ADDR(map, methodidx))) {
							Option_v__ast__Fn _t17 = v__ast__TypeSymbol_find_method_with_generic_parent(st_sym, method.name);
							if (_t17.state != 0) { /*or block*/ 
								IError err = _t17.err;
								continue;
							}
							
 							array_push((array*)&methods, _MOV((v__ast__Fn[]){  (*(v__ast__Fn*)_t17.data) }));
						}
					}
				}
			}
			else if (st_sym->info._typ == 464 /* v.ast.SumType */) {
				if (v__ast__Type_has_flag((*st_sym->info._v__ast__SumType).parent_type, v__ast__TypeFlag__generic)) {
					v__ast__TypeSymbol* parent_sym = v__ast__Table_sym(g->table, (*st_sym->info._v__ast__SumType).parent_type);
					for (int _t18 = 0; _t18 < parent_sym->methods.len; ++_t18) {
						v__ast__Fn method = ((v__ast__Fn*)parent_sym->methods.data)[_t18];
						if (_IN_MAP(ADDR(string, method.name), ADDR(map, methodidx))) {
							Option_v__ast__Fn _t20 = v__ast__TypeSymbol_find_method_with_generic_parent(st_sym, method.name);
							if (_t20.state != 0) { /*or block*/ 
								IError err = _t20.err;
								continue;
							}
							
 							array_push((array*)&methods, _MOV((v__ast__Fn[]){  (*(v__ast__Fn*)_t20.data) }));
						}
					}
				}
			}
			
			else {
			}
			;
			if ((st_sym->info)._typ == 446 /* v.ast.Struct */) {
				for (int _t21 = 0; _t21 < (*st_sym->info._v__ast__Struct).embeds.len; ++_t21) {
					v__ast__Type embed = ((v__ast__Type*)(*st_sym->info._v__ast__Struct).embeds.data)[_t21];
					v__ast__TypeSymbol* embed_sym = v__ast__Table_sym(g->table, embed);
					for (int _t22 = 0; _t22 < embed_sym->methods.len; ++_t22) {
						v__ast__Fn embed_method = ((v__ast__Fn*)embed_sym->methods.data)[_t22];
						if (!Array_string_contains(method_names, embed_method.name)) {
							array_push((array*)&methods, _MOV((v__ast__Fn[]){ embed_method }));
						}
					}
				}
			}
			for (int _t24 = 0; _t24 < methods.len; ++_t24) {
				v__ast__Fn method = ((v__ast__Fn*)methods.data)[_t24];
				string name = method.name;
				if (v__ast__Type_has_flag(inter_info.parent_type, v__ast__TypeFlag__generic)) {
					v__ast__TypeSymbol* parent_sym = v__ast__Table_sym(g->table, inter_info.parent_type);
					if (parent_sym->info._typ == 446 /* v.ast.Struct */) {
						name = v__gen__c__Gen_generic_fn_name(g, (*parent_sym->info._v__ast__Struct).concrete_types, method.name, false);
					}
					else if (parent_sym->info._typ == 463 /* v.ast.Interface */) {
						name = v__gen__c__Gen_generic_fn_name(g, (*parent_sym->info._v__ast__Interface).concrete_types, method.name, false);
					}
					else if (parent_sym->info._typ == 464 /* v.ast.SumType */) {
						name = v__gen__c__Gen_generic_fn_name(g, (*parent_sym->info._v__ast__SumType).concrete_types, method.name, false);
					}
					
					else {
					}
					;
				}
				if (!_IN_MAP(ADDR(string, method.name), ADDR(map, methodidx))) {
					continue;
				}
				if ((st_sym->info)._typ == 446 /* v.ast.Struct */) {
					if (v__ast__Type_has_flag((*st_sym->info._v__ast__Struct).parent_type, v__ast__TypeFlag__generic)) {
						name = v__gen__c__Gen_generic_fn_name(g, (*st_sym->info._v__ast__Struct).concrete_types, method.name, false);
					}
				}
				string styp = v__gen__c__Gen_cc_type(g, (*(v__ast__Param*)/*ee elem_typ */array_get(method.params, 0)).typ, true);
				string method_call =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = styp}}, {_SLIT("_"), 0xfe10, {.d_s = name}}, {_SLIT0, 0, { .d_c = 0 }}}));
				if (!v__ast__Type_is_ptr((*(v__ast__Param*)/*ee elem_typ */array_get(method.params, 0)).typ)) {
					string iwpostfix =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("_Interface_"), 0xfe10, {.d_s = interface_name}}, {_SLIT("_method_wrapper"), 0, { .d_c = 0 }}}));
					strings__Builder_write_string(&methods_wrapper,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("static inline "), 0xfe10, {.d_s = v__gen__c__Gen_typ(g, method.return_type)}}, {_SLIT(" "), 0xfe10, {.d_s = cctype}}, {_SLIT("_"), 0xfe10, {.d_s = name}}, {_SLIT0, 0xfe10, {.d_s = iwpostfix}}, {_SLIT("("), 0, { .d_c = 0 }}})));
					int params_start_pos = g->out.len;
					Array_v__ast__Param params = array_clone_to_depth(&method.params, 0);
					array_set(&params, 0, &(v__ast__Param[]) { (v__ast__Param){(*(v__ast__Param*)/*ee elem_typ */array_get(params, 0)).pos,(*(v__ast__Param*)/*ee elem_typ */array_get(params, 0)).name,(*(v__ast__Param*)/*ee elem_typ */array_get(params, 0)).is_mut,(*(v__ast__Param*)/*ee elem_typ */array_get(params, 0)).is_auto_rec,(*(v__ast__Param*)/*ee elem_typ */array_get(params, 0)).type_pos,(*(v__ast__Param*)/*ee elem_typ */array_get(params, 0)).is_hidden,.typ = v__ast__Type_set_nr_muls(st, 1),} });
					multi_return_Array_string_Array_string_Array_bool mr_203361 = v__gen__c__Gen_fn_args(g, params, ((voidptr)(0)));
					Array_string fargs = mr_203361.arg0;
					string parameter_name = strings__Builder_cut_last(&g->out, g->out.len - params_start_pos);
					if (v__ast__Type_is_ptr(st)) {
						parameter_name = string_trim_left(parameter_name, _SLIT("__shared__"));
					}
					strings__Builder_write_string(&methods_wrapper, parameter_name);
					strings__Builder_writeln(&methods_wrapper, _SLIT(") {"));
					strings__Builder_write_string(&methods_wrapper, _SLIT("\t"));
					if (!v__ast__Type_alias_eq(method.return_type, _const_v__ast__void_type)) {
						strings__Builder_write_string(&methods_wrapper, _SLIT("return "));
					}
					Option_multi_return_v__ast__Fn_Array_v__ast__Type _t25 = v__ast__Table_find_method_from_embeds(g->table, st_sym, method.name);
					if (_t25.state != 0) { /*or block*/ 
						IError err = _t25.err;
						*(multi_return_v__ast__Fn_Array_v__ast__Type*) _t25.data = (multi_return_v__ast__Fn_Array_v__ast__Type){.arg0=(v__ast__Fn){.is_variadic = 0,.language = 0,.is_pub = 0,.is_ctor_new = 0,.is_deprecated = 0,.is_noreturn = 0,.is_unsafe = 0,.is_placeholder = 0,.is_main = 0,.is_test = 0,.is_keep_alive = 0,.is_method = 0,.no_body = 0,.mod = (string){.str=(byteptr)"", .is_lit=1},.file = (string){.str=(byteptr)"", .is_lit=1},.file_mode = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.return_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.return_type = 0,.receiver_type = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.params = __new_array(0, 0, sizeof(v__ast__Param)),.source_fn = 0,.usages = 0,.generic_names = __new_array(0, 0, sizeof(string)),.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_conditional = 0,.ctdefine_idx = 0,},.arg1=__new_array_with_default(0, 0, sizeof(v__ast__Type), 0)};
					}
					
 					Option_multi_return_v__ast__Fn_Array_v__ast__Type mr_203804 =  _t25 /*U*/;
					Array_v__ast__Type embed_types = (*(multi_return_v__ast__Fn_Array_v__ast__Type*)mr_203804.data).arg1;
					if (embed_types.len > 0 && !Array_string_contains(method_names, method.name)) {
						v__ast__TypeSymbol* embed_sym = v__ast__Table_sym(g->table, (*(v__ast__Type*)array_last(embed_types)));
						string method_name =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = embed_sym->cname}}, {_SLIT("_"), 0xfe10, {.d_s = method.name}}, {_SLIT0, 0, { .d_c = 0 }}}));
						strings__Builder_write_string(&methods_wrapper,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = method_name}}, {_SLIT("("), 0xfe10, {.d_s = (*(string*)/*ee elem_typ */array_get(fargs, 0))}}, {_SLIT0, 0, { .d_c = 0 }}})));
						for (int _t26 = 0; _t26 < embed_types.len; ++_t26) {
							v__ast__Type embed = ((v__ast__Type*)embed_types.data)[_t26];
							v__ast__TypeSymbol* esym = v__ast__Table_sym(g->table, embed);
							strings__Builder_write_string(&methods_wrapper,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("->"), 0xfe10, {.d_s = v__ast__TypeSymbol_embed_name(esym)}}, {_SLIT0, 0, { .d_c = 0 }}})));
						}
						strings__Builder_writeln(&methods_wrapper,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = Array_string_join(array_slice(fargs, 1, fargs.len), _SLIT(", "))}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
					} else {
						if (string_starts_with(parameter_name, _SLIT("__shared__"))) {
							strings__Builder_writeln(&methods_wrapper,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = method_call}}, {_SLIT("("), 0xfe10, {.d_s = Array_string_join(fargs, _SLIT(", "))}}, {_SLIT("->val);"), 0, { .d_c = 0 }}})));
						} else {
							strings__Builder_writeln(&methods_wrapper,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = method_call}}, {_SLIT("(*"), 0xfe10, {.d_s = Array_string_join(fargs, _SLIT(", "))}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
						}
					}
					strings__Builder_writeln(&methods_wrapper, _SLIT("}"));
					method_call = /*f*/string__plus(method_call, iwpostfix);
				}
				if (g->pref->build_mode != v__pref__BuildMode__build_module && !v__ast__Type_alias_eq(st, _const_v__ast__voidptr_type)) {
					strings__Builder_writeln(&methods_struct,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\t._method_"), 0xfe10, {.d_s = v__gen__c__c_name(method.name)}}, {_SLIT(" = (void*) "), 0xfe10, {.d_s = method_call}}, {_SLIT(","), 0, { .d_c = 0 }}})));
				}
			}
			if (g->pref->build_mode != v__pref__BuildMode__build_module) {
				strings__Builder_writeln(&methods_struct, _SLIT("\t},"));
			}
			int iin_idx = (*(int*)map_get(ADDR(map, already_generated_mwrappers), &(string[]){interface_index_name}, &(int[]){ 0 })) - iinidx_minimum_base;
			if (g->pref->build_mode != v__pref__BuildMode__build_module) {
				strings__Builder_writeln(&sb,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("const int "), 0xfe10, {.d_s = interface_index_name}}, {_SLIT(" = "), 0xfe07, {.d_i32 = iin_idx}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
			} else {
				strings__Builder_writeln(&sb,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("extern const int "), 0xfe10, {.d_s = interface_index_name}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
			}
		}
		Map_int_Array_v__ast__Type _t27 = inter_info.conversions;
		int _t29 = _t27.key_values.len;
		for (int _t28 = 0; _t28 < _t29; ++_t28 ) {
			int _t30 = _t27.key_values.len - _t29;
			_t29 = _t27.key_values.len;
			if (_t30 < 0) {
				_t28 = -1;
				continue;
			}
			if (!DenseArray_has_index(&_t27.key_values, _t28)) {continue;}
			int vtyp = /*key*/ *(int*)DenseArray_key(&_t27.key_values, _t28);
			Array_v__ast__Type variants = (*(Array_v__ast__Type*)DenseArray_value(&_t27.key_values, _t28));
			v__ast__TypeSymbol* vsym = v__ast__Table_sym(g->table, vtyp);
			strings__Builder_write_string(&conversion_functions,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("static inline bool I_"), 0xfe10, {.d_s = interface_name}}, {_SLIT("_is_I_"), 0xfe10, {.d_s = vsym->cname}}, {_SLIT("("), 0xfe10, {.d_s = interface_name}}, {_SLIT(" x) {\n\treturn "), 0, { .d_c = 0 }}})));
			for (int i = 0; i < variants.len; ++i) {
				v__ast__Type variant = ((v__ast__Type*)variants.data)[i];
				v__ast__TypeSymbol* variant_sym = v__ast__Table_sym(g->table, variant);
				if (i > 0) {
					strings__Builder_write_string(&conversion_functions, _SLIT(" || "));
				}
				strings__Builder_write_string(&conversion_functions,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("(x._typ == _"), 0xfe10, {.d_s = interface_name}}, {_SLIT("_"), 0xfe10, {.d_s = variant_sym->cname}}, {_SLIT("_index)"), 0, { .d_c = 0 }}})));
			}
			strings__Builder_writeln(&conversion_functions, _SLIT(";\n}"));
			strings__Builder_writeln(&conversion_functions,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("static inline "), 0xfe10, {.d_s = vsym->cname}}, {_SLIT(" I_"), 0xfe10, {.d_s = interface_name}}, {_SLIT("_as_I_"), 0xfe10, {.d_s = vsym->cname}}, {_SLIT("("), 0xfe10, {.d_s = interface_name}}, {_SLIT(" x) {"), 0, { .d_c = 0 }}})));
			for (int _t31 = 0; _t31 < variants.len; ++_t31) {
				v__ast__Type variant = ((v__ast__Type*)variants.data)[_t31];
				v__ast__TypeSymbol* variant_sym = v__ast__Table_sym(g->table, variant);
				strings__Builder_writeln(&conversion_functions,  str_intp(6, _MOV((StrIntpData[]){{_SLIT("\tif (x._typ == _"), 0xfe10, {.d_s = interface_name}}, {_SLIT("_"), 0xfe10, {.d_s = variant_sym->cname}}, {_SLIT("_index) return I_"), 0xfe10, {.d_s = variant_sym->cname}}, {_SLIT("_to_Interface_"), 0xfe10, {.d_s = vsym->cname}}, {_SLIT("(x._"), 0xfe10, {.d_s = variant_sym->cname}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
			}
			string pmessage =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("string__plus(string__plus(tos3(\"`as_cast`: cannot convert \"), tos3(v_typeof_interface_"), 0xfe10, {.d_s = interface_name}}, {_SLIT("(x._typ))), tos3(\" to "), 0xfe10, {.d_s = v__util__strip_main_name(vsym->name)}}, {_SLIT("\"))"), 0, { .d_c = 0 }}}));
			if (g->pref->is_debug) {
				strings__Builder_write_string(&conversion_functions, _SLIT("\tpanic_debug(1, tos3(\"builtin.v\"), tos3(\"builtin\"), tos3(\"__as_cast\"), "));
				strings__Builder_write_string(&conversion_functions, pmessage);
				strings__Builder_writeln(&conversion_functions, _SLIT(");"));
			} else {
				strings__Builder_write_string(&conversion_functions, _SLIT("\t_v_panic("));
				strings__Builder_write_string(&conversion_functions, pmessage);
				strings__Builder_writeln(&conversion_functions, _SLIT(");"));
			}
			strings__Builder_writeln(&conversion_functions,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\treturn ("), 0xfe10, {.d_s = vsym->cname}}, {_SLIT("){0};"), 0, { .d_c = 0 }}})));
			strings__Builder_writeln(&conversion_functions, _SLIT("}"));
		}
		strings__Builder_writeln(&sb,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("// ^^^ number of types for interface "), 0xfe10, {.d_s = interface_name}}, {_SLIT(": "), 0xfe07, {.d_i32 = current_iinidx - iinidx_minimum_base}}, {_SLIT0, 0, { .d_c = 0 }}})));
		if (iname_table_length == 0) {
			strings__Builder_writeln(&methods_struct, _SLIT(""));
		} else {
			if (g->pref->build_mode != v__pref__BuildMode__build_module) {
				strings__Builder_writeln(&methods_struct, _SLIT("};"));
			}
		}
		strings__Builder_writeln(&sb, _SLIT(""));
		if (inter_info.methods.len > 0) {
			strings__Builder_writeln(&sb, strings__Builder_str(&methods_wrapper));
			strings__Builder_writeln(&sb, strings__Builder_str(&methods_struct_def));
			strings__Builder_writeln(&sb, strings__Builder_str(&methods_struct));
		}
		strings__Builder_writeln(&sb, strings__Builder_str(&cast_functions));
	}
	strings__Builder_writeln(&sb, strings__Builder_str(&conversion_functions));
	string _t32 = strings__Builder_str(&sb);
	return _t32;
}

VV_LOCAL_SYMBOL multi_return_int_string_string_string v__gen__c__Gen_panic_debug_info(v__gen__c__Gen* g, v__token__Position pos) {
	int paline = pos.line_nr + 1;
	if (isnil(g->fn_decl)) {
		return (multi_return_int_string_string_string){.arg0=paline, .arg1=_SLIT(""), .arg2=_SLIT("main"), .arg3=_SLIT("C._vinit")};
	}
	string pafile = string_replace(g->fn_decl->file, _SLIT("\\"), _SLIT("/"));
	string pafn = string_after(g->fn_decl->name, _SLIT("."));
	string pamod = v__ast__FnDecl_modname(g->fn_decl);
	return (multi_return_int_string_string_string){.arg0=paline, .arg1=pafile, .arg2=pamod, .arg3=pafn};
}

string v__gen__c__get_guarded_include_text(string iname, string imessage) {
	string res = string_strip_margin( str_intp(5, _MOV((StrIntpData[]){{_SLIT("\n	|#if defined(__has_include)\n	|\n	|#if __has_include("), 0xfe10, {.d_s = iname}}, {_SLIT(")\n	|#include "), 0xfe10, {.d_s = iname}}, {_SLIT("\n	|#else\n	|#error VERROR_MESSAGE "), 0xfe10, {.d_s = imessage}}, {_SLIT("\n	|#endif\n	|\n	|#else\n	|#include "), 0xfe10, {.d_s = iname}}, {_SLIT("\n	|#endif\n	"), 0, { .d_c = 0 }}})));
	string _t1 = res;
	return _t1;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_trace(v__gen__c__Gen* g, string fbase, string message) {
	if (string__eq(g->file->path_base, fbase)) {
		println( str_intp(3, _MOV((StrIntpData[]){{_SLIT("> g.trace | "), 0x14fe10, {.d_s = fbase}}, {_SLIT(" | "), 0xfe10, {.d_s = message}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
}

int v__gen__c__Gen_get_array_depth(v__gen__c__Gen* g, v__ast__Type el_typ) {
	v__ast__Type typ = v__gen__c__Gen_unwrap_generic(g, el_typ);
	v__ast__TypeSymbol* sym = v__ast__Table_final_sym(g->table, typ);
	if (sym->kind == v__ast__Kind__array) {
		v__ast__Array info = /* as */ *(v__ast__Array*)__as_cast((sym->info)._v__ast__Array,(sym->info)._typ, 441) /*expected idx: 441, name: v.ast.Array */ ;
		int _t1 = 1 + v__gen__c__Gen_get_array_depth(g, info.elem_type);
		return _t1;
	} else {
		int _t2 = 0;
		return _t2;
	}
	return 0;
}

bool v__gen__c__Gen_contains_ptr(v__gen__c__Gen* g, v__ast__Type el_typ) {
	if (v__ast__Type_is_ptr(el_typ) || v__ast__Type_is_pointer(el_typ)) {
		bool _t1 = true;
		return _t1;
	}
	v__ast__Type typ = v__gen__c__Gen_unwrap_generic(g, el_typ);
	if (v__ast__Type_is_ptr(typ)) {
		bool _t2 = true;
		return _t2;
	}
	v__ast__TypeSymbol* sym = v__ast__Table_final_sym(g->table, typ);
	if (sym->language != v__ast__Language__v) {
		bool _t3 = true;
		return _t3;
	}
	switch (sym->kind) {
		case v__ast__Kind__i8: 
		case v__ast__Kind__i16: 
		case v__ast__Kind__int: 
		case v__ast__Kind__i64: 
		case v__ast__Kind__byte: 
		case v__ast__Kind__u16: 
		case v__ast__Kind__u32: 
		case v__ast__Kind__u64: 
		case v__ast__Kind__f32: 
		case v__ast__Kind__f64: 
		case v__ast__Kind__char: 
		case v__ast__Kind__rune: 
		case v__ast__Kind__bool: 
		case v__ast__Kind__enum_: 
			{
				bool _t4 = false;
				return _t4;
			} break;
		case v__ast__Kind__array_fixed: 
			{
				v__ast__ArrayFixed info = /* as */ *(v__ast__ArrayFixed*)__as_cast((sym->info)._v__ast__ArrayFixed,(sym->info)._typ, 468) /*expected idx: 468, name: v.ast.ArrayFixed */ ;
				bool _t5 = v__gen__c__Gen_contains_ptr(g, info.elem_type);
				return _t5;
			} break;
		case v__ast__Kind__struct_: 
			{
				v__ast__Struct info = /* as */ *(v__ast__Struct*)__as_cast((sym->info)._v__ast__Struct,(sym->info)._typ, 446) /*expected idx: 446, name: v.ast.Struct */ ;
				for (int _t6 = 0; _t6 < info.embeds.len; ++_t6) {
					v__ast__Type embed = ((v__ast__Type*)info.embeds.data)[_t6];
					if (v__gen__c__Gen_contains_ptr(g, embed)) {
						bool _t7 = true;
						return _t7;
					}
				}
				for (int _t8 = 0; _t8 < info.fields.len; ++_t8) {
					v__ast__StructField field = ((v__ast__StructField*)info.fields.data)[_t8];
					if (v__gen__c__Gen_contains_ptr(g, field.typ)) {
						bool _t9 = true;
						return _t9;
					}
				}
				bool _t10 = false;
				return _t10;
			} break;
		case v__ast__Kind__aggregate: 
			{
				v__ast__Aggregate info = /* as */ *(v__ast__Aggregate*)__as_cast((sym->info)._v__ast__Aggregate,(sym->info)._typ, 458) /*expected idx: 458, name: v.ast.Aggregate */ ;
				for (int _t11 = 0; _t11 < info.types.len; ++_t11) {
					v__ast__Type atyp = ((v__ast__Type*)info.types.data)[_t11];
					if (v__gen__c__Gen_contains_ptr(g, atyp)) {
						bool _t12 = true;
						return _t12;
					}
				}
				bool _t13 = false;
				return _t13;
			} break;
		case v__ast__Kind__multi_return: 
			{
				v__ast__MultiReturn info = /* as */ *(v__ast__MultiReturn*)__as_cast((sym->info)._v__ast__MultiReturn,(sym->info)._typ, 471) /*expected idx: 471, name: v.ast.MultiReturn */ ;
				for (int _t14 = 0; _t14 < info.types.len; ++_t14) {
					v__ast__Type mrtyp = ((v__ast__Type*)info.types.data)[_t14];
					if (v__gen__c__Gen_contains_ptr(g, mrtyp)) {
						bool _t15 = true;
						return _t15;
					}
				}
				bool _t16 = false;
				return _t16;
			} break;
		case v__ast__Kind__placeholder:
		case v__ast__Kind__void:
		case v__ast__Kind__voidptr:
		case v__ast__Kind__byteptr:
		case v__ast__Kind__charptr:
		case v__ast__Kind__isize:
		case v__ast__Kind__u8:
		case v__ast__Kind__usize:
		case v__ast__Kind__none_:
		case v__ast__Kind__string:
		case v__ast__Kind__array:
		case v__ast__Kind__map:
		case v__ast__Kind__chan:
		case v__ast__Kind__any:
		case v__ast__Kind__generic_inst:
		case v__ast__Kind__sum_type:
		case v__ast__Kind__alias:
		case v__ast__Kind__function:
		case v__ast__Kind__interface_:
		case v__ast__Kind__float_literal:
		case v__ast__Kind__int_literal:
		case v__ast__Kind__thread:
		default:
			{
				bool _t17 = true;
				return _t17;
			} break;
	}
	;
	return 0;
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_check_noscan(v__gen__c__Gen* g, v__ast__Type elem_typ) {
	if (g->pref->gc_mode == v__pref__GarbageCollectionMode__boehm_full_opt || g->pref->gc_mode == v__pref__GarbageCollectionMode__boehm_incr_opt) {
		if (!v__gen__c__Gen_contains_ptr(g, elem_typ)) {
			string _t1 = _SLIT("_noscan");
			return _t1;
		}
	}
	string _t2 = _SLIT("");
	return _t2;
}

VV_LOCAL_SYMBOL string v__gen__c__arm64_bytes(int nargs) {
	string bytes = _SLIT("0xd0, 0xff, 0xff, 0x58, 0x6<REG>, 0xff, 0xff, 0x58, 0x00, 0x02, 0x1f, 0xd6");
	string _t1 = string_replace(bytes, _SLIT("<REG>"), int_str(nargs));
	return _t1;
}

VV_LOCAL_SYMBOL string v__gen__c__arm32_bytes(int nargs) {
	string bytes = _SLIT("0x0c, 0x90, 0x1f, 0xe5, 0x14, 0x<REG>0, 0x1f, 0xe5, 0x19, 0xff, 0x2f, 0xe1");
	string _t1 = string_replace(bytes, _SLIT("<REG>"), int_str(nargs));
	return _t1;
}

VV_LOCAL_SYMBOL string v__gen__c__amd64_bytes(int nargs) {

	if (nargs == (1)) {
		string _t1 = _SLIT("0x48, 0x8b, 0x3d, 0xe9, 0xff, 0xff, 0xff, 0xff, 0x25, 0xeb, 0xff, 0xff, 0xff");
		return _t1;
	}
	else if (nargs == (2)) {
		string _t2 = _SLIT("0x48, 0x8b, 0x35, 0xe9, 0xff, 0xff, 0xff, 0xff, 0x25, 0xeb, 0xff, 0xff, 0xff");
		return _t2;
	}
	else if (nargs == (3)) {
		string _t3 = _SLIT("0x48, 0x8b, 0x15, 0xe9, 0xff, 0xff, 0xff, 0xff, 0x25, 0xeb, 0xff, 0xff, 0xff");
		return _t3;
	}
	else if (nargs == (4)) {
		string _t4 = _SLIT("0x48, 0x8b, 0x0d, 0xe9, 0xff, 0xff, 0xff, 0xff, 0x25, 0xeb, 0xff, 0xff, 0xff");
		return _t4;
	}
	else if (nargs == (5)) {
		string _t5 = _SLIT("0x4C, 0x8b, 0x05, 0xe9, 0xff, 0xff, 0xff, 0xff, 0x25, 0xeb, 0xff, 0xff, 0xff");
		return _t5;
	}
	else if (nargs == (6)) {
		string _t6 = _SLIT("0x4C, 0x8b, 0x0d, 0xe9, 0xff, 0xff, 0xff, 0xff, 0x25, 0xeb, 0xff, 0xff, 0xff");
		return _t6;
	}
	else {
		strings__Builder sb = strings__new_builder(256);
		string s = byte_hex(((((((byte)(nargs)) & 1)) + 1) << 3));
		strings__Builder_write_string(&sb,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("0x48, 0x83, 0xec, 0x"), 0xfe10, {.d_s = s}}, {_SLIT(", "), 0, { .d_c = 0 }}})));
		strings__Builder_write_string(&sb, _SLIT("0xff, 0x35, 0xe6, 0xff, 0xff, 0xff, "));
		string rsp_offset = byte_hex(((byte)(0x18 + ((((byte)(nargs - 7)) >> 1) << 4))));
		for (int _t7 = 0; _t7 < nargs - 7; ++_t7) {
			strings__Builder_write_string(&sb,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("0xff, 0xb4, 0x24, 0x"), 0xfe10, {.d_s = rsp_offset}}, {_SLIT(", 0x00, 0x00, 0x00, "), 0, { .d_c = 0 }}})));
		}
		strings__Builder_write_string(&sb,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("0xff, 0x15, 0x"), 0xfe10, {.d_s = byte_hex(((byte)(256 - sb.len / 6 - 6 - 8)))}}, {_SLIT(", 0xff, 0xff, 0xff, "), 0, { .d_c = 0 }}})));
		strings__Builder_write_string(&sb,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("0x48, 0x81, 0xc4, 0x"), 0xfe10, {.d_s = rsp_offset}}, {_SLIT(", 0x00, 0x00, 0x00, "), 0, { .d_c = 0 }}})));
		strings__Builder_write_string(&sb, _SLIT("0xc3"));
		string _t8 = strings__Builder_str(&sb);
		return _t8;
	};
	return (string){.str=(byteptr)"", .is_lit=1};
}

VV_LOCAL_SYMBOL string v__gen__c__c_closure_helpers(v__pref__Preferences* pref) {
	if (pref->os == v__pref__OS__windows) {
		v__gen__c__verror(_SLIT("closures are not implemented on Windows yet"));
		VUNREACHABLE();
	}
	if (!(pref->arch == v__pref__Arch__amd64 || pref->arch == v__pref__Arch__arm64 || pref->arch == v__pref__Arch__arm32)) {
		v__gen__c__verror( str_intp(2, _MOV((StrIntpData[]){{_SLIT("closures are not implemented on this architecture yet: "), 0xfe10, {.d_s = v__pref__Arch_str(pref->arch)}}, {_SLIT0, 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	strings__Builder builder = strings__new_builder(2048);
	if (pref->os != v__pref__OS__windows) {
		strings__Builder_writeln(&builder, _SLIT("#include <sys/mman.h>"));
	}
	if (pref->arch == v__pref__Arch__amd64) {
		strings__Builder_write_string(&builder,  str_intp(33, _MOV((StrIntpData[]){{_SLIT("\nstatic unsigned char __closure_thunk[32]["), 0xfe07, {.d_i32 = v__gen__c__amd64_bytes(31).len / 6 + 2}}, {_SLIT("] = {\n	{ "), 0xfe10, {.d_s = v__gen__c__amd64_bytes(1)}}, {_SLIT(" },\n	{ "), 0xfe10, {.d_s = v__gen__c__amd64_bytes(2)}}, {_SLIT(" },\n	{ "), 0xfe10, {.d_s = v__gen__c__amd64_bytes(3)}}, {_SLIT(" },\n	{ "), 0xfe10, {.d_s = v__gen__c__amd64_bytes(4)}}, {_SLIT(" },\n	{ "), 0xfe10, {.d_s = v__gen__c__amd64_bytes(5)}}, {_SLIT(" },\n	{ "), 0xfe10, {.d_s = v__gen__c__amd64_bytes(6)}}, {_SLIT(" },\n	{ "), 0xfe10, {.d_s = v__gen__c__amd64_bytes(7)}}, {_SLIT(" },\n	{ "), 0xfe10, {.d_s = v__gen__c__amd64_bytes(8)}}, {_SLIT(" },\n	{ "), 0xfe10, {.d_s = v__gen__c__amd64_bytes(9)}}, {_SLIT(" },\n	{ "), 0xfe10, {.d_s = v__gen__c__amd64_bytes(10)}}, {_SLIT(" },\n	{ "), 0xfe10, {.d_s = v__gen__c__amd64_bytes(11)}}, {_SLIT(" },\n	{ "), 0xfe10, {.d_s = v__gen__c__amd64_bytes(12)}}, {_SLIT(" },\n	{ "), 0xfe10, {.d_s = v__gen__c__amd64_bytes(13)}}, {_SLIT(" },\n	{ "), 0xfe10, {.d_s = v__gen__c__amd64_bytes(14)}}, {_SLIT(" },\n	{ "), 0xfe10, {.d_s = v__gen__c__amd64_bytes(15)}}, {_SLIT(" },\n	{ "), 0xfe10, {.d_s = v__gen__c__amd64_bytes(16)}}, {_SLIT(" },\n	{ "), 0xfe10, {.d_s = v__gen__c__amd64_bytes(17)}}, {_SLIT(" },\n	{ "), 0xfe10, {.d_s = v__gen__c__amd64_bytes(18)}}, {_SLIT(" },\n	{ "), 0xfe10, {.d_s = v__gen__c__amd64_bytes(19)}}, {_SLIT(" },\n	{ "), 0xfe10, {.d_s = v__gen__c__amd64_bytes(20)}}, {_SLIT(" },\n	{ "), 0xfe10, {.d_s = v__gen__c__amd64_bytes(21)}}, {_SLIT(" },\n	{ "), 0xfe10, {.d_s = v__gen__c__amd64_bytes(22)}}, {_SLIT(" },\n	{ "), 0xfe10, {.d_s = v__gen__c__amd64_bytes(23)}}, {_SLIT(" },\n	{ "), 0xfe10, {.d_s = v__gen__c__amd64_bytes(24)}}, {_SLIT(" },\n	{ "), 0xfe10, {.d_s = v__gen__c__amd64_bytes(25)}}, {_SLIT(" },\n	{ "), 0xfe10, {.d_s = v__gen__c__amd64_bytes(26)}}, {_SLIT(" },\n	{ "), 0xfe10, {.d_s = v__gen__c__amd64_bytes(27)}}, {_SLIT(" },\n	{ "), 0xfe10, {.d_s = v__gen__c__amd64_bytes(28)}}, {_SLIT(" },\n	{ "), 0xfe10, {.d_s = v__gen__c__amd64_bytes(29)}}, {_SLIT(" },\n	{ "), 0xfe10, {.d_s = v__gen__c__amd64_bytes(30)}}, {_SLIT(" },\n	{ "), 0xfe10, {.d_s = v__gen__c__amd64_bytes(31)}}, {_SLIT(" },\n};\n"), 0, { .d_c = 0 }}})));
	} else if (pref->arch == v__pref__Arch__arm64) {
		strings__Builder_write_string(&builder,  str_intp(9, _MOV((StrIntpData[]){{_SLIT("\nstatic unsigned char __closure_thunk[8][12] = {\n    {\n        "), 0xfe10, {.d_s = v__gen__c__arm64_bytes(0)}}, {_SLIT("\n    }, {\n        "), 0xfe10, {.d_s = v__gen__c__arm64_bytes(1)}}, {_SLIT("\n    }, {\n        "), 0xfe10, {.d_s = v__gen__c__arm64_bytes(2)}}, {_SLIT("\n    }, {\n        "), 0xfe10, {.d_s = v__gen__c__arm64_bytes(3)}}, {_SLIT("\n    }, {\n        "), 0xfe10, {.d_s = v__gen__c__arm64_bytes(4)}}, {_SLIT("\n    }, {\n        "), 0xfe10, {.d_s = v__gen__c__arm64_bytes(5)}}, {_SLIT("\n    }, {\n        "), 0xfe10, {.d_s = v__gen__c__arm64_bytes(6)}}, {_SLIT("\n    }, {\n        "), 0xfe10, {.d_s = v__gen__c__arm64_bytes(7)}}, {_SLIT("\n    },\n};\n"), 0, { .d_c = 0 }}})));
	} else if (pref->arch == v__pref__Arch__arm32) {
		strings__Builder_write_string(&builder,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("\nstatic unsigned char __closure_thunk[4][12] = {\n    {\n        "), 0xfe10, {.d_s = v__gen__c__arm32_bytes(0)}}, {_SLIT("\n    }, {\n        "), 0xfe10, {.d_s = v__gen__c__arm32_bytes(1)}}, {_SLIT("\n    }, {\n        "), 0xfe10, {.d_s = v__gen__c__arm32_bytes(2)}}, {_SLIT("\n    }, {\n        "), 0xfe10, {.d_s = v__gen__c__arm32_bytes(3)}}, {_SLIT("\n    },\n};\n"), 0, { .d_c = 0 }}})));
	}
	strings__Builder_write_string(&builder, _SLIT("\nstatic void __closure_set_data(void *closure, void *data) {\n    void **p = closure;\n    p[-2] = data;\n}\n\nstatic void __closure_set_function(void *closure, void *f) {\n    void **p = closure;\n    p[-1] = f;\n}\n\nstatic inline int __closure_check_nargs(int nargs) {\n	if (nargs > (int)_ARR_LEN(__closure_thunk)) {\n		_v_panic(_SLIT(\"Closure too large. Reduce the number of parameters, or pass the parameters by reference.\"));\n		VUNREACHABLE();\n	}\n	return nargs;\n}\n"));
	if (pref->os != v__pref__OS__windows) {
		strings__Builder_write_string(&builder, _SLIT("\nstatic void * __closure_create(void *f, int nargs, void *userdata) {\n    long page_size = sysconf(_SC_PAGESIZE);\n    int prot = PROT_READ | PROT_WRITE;\n    int flags = MAP_ANONYMOUS | MAP_PRIVATE;\n    char *p = mmap(0, page_size * 2, prot, flags, -1, 0);\n    if (p == MAP_FAILED)\n        return 0;\n    void *closure = p + page_size;\n    memcpy(closure, __closure_thunk[nargs - 1], sizeof(__closure_thunk[0]));\n    mprotect(closure, page_size, PROT_READ | PROT_EXEC);\n    __closure_set_function(closure, f);\n    __closure_set_data(closure, userdata);\n    return closure;\n}\n\nstatic void __closure_destroy(void *closure) {\n    long page_size = sysconf(_SC_PAGESIZE);\n    munmap((char *)closure - page_size, page_size * 2);\n}\n"));
	}
	string _t1 = strings__Builder_str(&builder);
	return _t1;
}

void v__gen__c__Gen_gen_c_main(v__gen__c__Gen* g) {
	if (!g->has_main) {
		return;
	}
	if (g->pref->is_liveshared) {
		return;
	}
	if (g->pref->is_o) {
		return;
	}
	if (Array_string_contains(g->pref->compile_defines, _SLIT("no_main"))) {
		return;
	}
	strings__Builder_writeln(&g->out, _SLIT(""));
	int main_fn_start_pos = g->out.len;
	bool is_sokol = Array_string_contains(g->table->imports, _SLIT("sokol"));
	if ((g->pref->os == v__pref__OS__android && g->pref->is_apk) || (g->pref->os == v__pref__OS__ios && is_sokol)) {
		v__gen__c__Gen_gen_c_android_sokol_main(g);
	} else {
		v__gen__c__Gen_gen_c_main_header(g);
		v__gen__c__Gen_writeln(g, _SLIT("\tmain__main();"));
		v__gen__c__Gen_gen_c_main_footer(g);
		if (g->pref->printfn_list.len > 0 && Array_string_contains(g->pref->printfn_list, _SLIT("main"))) {
			println(strings__Builder_after(&g->out, main_fn_start_pos));
		}
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_vlines_reset(v__gen__c__Gen* g) {
	if (g->pref->is_vlines) {
		int lines_so_far = 1000000;
		g->vlines_path = v__util__vlines_escape_path(g->pref->out_name_c, g->pref->ccompiler);
		v__gen__c__Gen_writeln(g, _SLIT(""));
		v__gen__c__Gen_writeln(g, _SLIT("\n// Reset the file/line numbers"));
		v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\n#line "), 0xfe07, {.d_i32 = lines_so_far}}, {_SLIT(" \""), 0xfe10, {.d_s = g->vlines_path}}, {_SLIT("\""), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_writeln(g, _SLIT(""));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_c_main_function_header(v__gen__c__Gen* g) {
	if (g->pref->os == v__pref__OS__windows) {
		if (v__gen__c__Gen_is_gui_app(g)) {
			v__gen__c__Gen_writeln(g, _SLIT("int WINAPI wWinMain(HINSTANCE instance, HINSTANCE prev_instance, LPWSTR cmd_line, int show_cmd){"));
			v__gen__c__Gen_writeln(g, _SLIT("\tLPWSTR full_cmd_line = GetCommandLineW(); // NB: do not use cmd_line"));
			v__gen__c__Gen_writeln(g, _SLIT("\ttypedef LPWSTR*(WINAPI *cmd_line_to_argv)(LPCWSTR, int*);"));
			v__gen__c__Gen_writeln(g, _SLIT("\tHMODULE shell32_module = LoadLibrary(L\"shell32.dll\");"));
			v__gen__c__Gen_writeln(g, _SLIT("\tcmd_line_to_argv CommandLineToArgvW = (cmd_line_to_argv)GetProcAddress(shell32_module, \"CommandLineToArgvW\");"));
			v__gen__c__Gen_writeln(g, _SLIT("\tint ___argc;"));
			v__gen__c__Gen_writeln(g, _SLIT("\twchar_t** ___argv = CommandLineToArgvW(full_cmd_line, &___argc);"));
		} else {
			v__gen__c__Gen_writeln(g, _SLIT("int wmain(int ___argc, wchar_t* ___argv[], wchar_t* ___envp[]){"));
		}
	} else {
		v__gen__c__Gen_writeln(g, _SLIT("int main(int ___argc, char** ___argv){"));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_c_main_header(v__gen__c__Gen* g) {
	v__gen__c__Gen_gen_c_main_function_header(g);
	if (g->pref->gc_mode == v__pref__GarbageCollectionMode__boehm_full || g->pref->gc_mode == v__pref__GarbageCollectionMode__boehm_incr || g->pref->gc_mode == v__pref__GarbageCollectionMode__boehm_full_opt || g->pref->gc_mode == v__pref__GarbageCollectionMode__boehm_incr_opt || g->pref->gc_mode == v__pref__GarbageCollectionMode__boehm_leak) {
		v__gen__c__Gen_writeln(g, _SLIT("#if defined(_VGCBOEHM)"));
		if (g->pref->gc_mode == v__pref__GarbageCollectionMode__boehm_leak) {
			v__gen__c__Gen_writeln(g, _SLIT("\tGC_set_find_leak(1);"));
		}
		v__gen__c__Gen_writeln(g, _SLIT("\tGC_INIT();"));
		if (g->pref->gc_mode == v__pref__GarbageCollectionMode__boehm_incr || g->pref->gc_mode == v__pref__GarbageCollectionMode__boehm_incr_opt) {
			v__gen__c__Gen_writeln(g, _SLIT("\tGC_enable_incremental();"));
		}
		v__gen__c__Gen_writeln(g, _SLIT("#endif"));
	}
	v__gen__c__Gen_writeln(g, _SLIT("\t_vinit(___argc, (voidptr)___argv);"));
	if (g->pref->is_prof) {
		v__gen__c__Gen_writeln(g, _SLIT(""));
		v__gen__c__Gen_writeln(g, _SLIT("\tatexit(vprint_profile_stats);"));
		v__gen__c__Gen_writeln(g, _SLIT(""));
	}
	if (g->pref->is_livemain) {
		v__gen__c__Gen_generate_hotcode_reloading_main_caller(g);
	}
}

void v__gen__c__Gen_gen_c_main_footer(v__gen__c__Gen* g) {
	v__gen__c__Gen_writeln(g, _SLIT("\t_vcleanup();"));
	v__gen__c__Gen_writeln(g, _SLIT("\treturn 0;"));
	v__gen__c__Gen_writeln(g, _SLIT("}"));
}

void v__gen__c__Gen_gen_c_android_sokol_main(v__gen__c__Gen* g) {
	if (g->is_autofree) {
		v__gen__c__Gen_writeln(g, _SLIT("// Wrapping cleanup/free callbacks for sokol to include _vcleanup()\nvoid (*_vsokol_user_cleanup_ptr)(void);\nvoid (*_vsokol_user_cleanup_cb_ptr)(void *);\n\nvoid (_vsokol_cleanup_cb)(void) {\n	if (_vsokol_user_cleanup_ptr) {\n		_vsokol_user_cleanup_ptr();\n	}\n	_vcleanup();\n}\n\nvoid (_vsokol_cleanup_userdata_cb)(void* user_data) {\n	if (_vsokol_user_cleanup_cb_ptr) {\n		_vsokol_user_cleanup_cb_ptr(g_desc.user_data);\n	}\n	_vcleanup();\n}\n"));
	}
	v__gen__c__Gen_writeln(g, _SLIT("// The sokol_main entry point on Android\nsapp_desc sokol_main(int argc, char* argv[]) {\n	(void)argc; (void)argv;\n\n	_vinit(argc, (voidptr)argv);\n	main__main();\n"));
	if (g->is_autofree) {
		v__gen__c__Gen_writeln(g, _SLIT("	// Wrap user provided cleanup/free functions for sokol to be able to call _vcleanup()\n	if (g_desc.cleanup_cb) {\n		_vsokol_user_cleanup_ptr = g_desc.cleanup_cb;\n		g_desc.cleanup_cb = _vsokol_cleanup_cb;\n	}\n	else if (g_desc.cleanup_userdata_cb) {\n		_vsokol_user_cleanup_cb_ptr = g_desc.cleanup_userdata_cb;\n		g_desc.cleanup_userdata_cb = _vsokol_cleanup_userdata_cb;\n	}\n"));
	}
	v__gen__c__Gen_writeln(g, _SLIT("	return g_desc;"));
	v__gen__c__Gen_writeln(g, _SLIT("}"));
}

void v__gen__c__Gen_write_tests_definitions(v__gen__c__Gen* g) {
	strings__Builder_writeln(&g->includes, _SLIT("#include <setjmp.h> // write_tests_main"));
	strings__Builder_writeln(&g->definitions, _SLIT("jmp_buf g_jump_buffer;"));
}

void v__gen__c__Gen_gen_failing_error_propagation_for_test_fn(v__gen__c__Gen* g, v__ast__OrExpr or_block, string cvar_name) {
	multi_return_int_string_string_string mr_4704 = v__gen__c__Gen_panic_debug_info(g, or_block.pos);
	int paline = mr_4704.arg0;
	string pafile = mr_4704.arg1;
	string pamod = mr_4704.arg2;
	string pafn = mr_4704.arg3;
	v__gen__c__Gen_writeln(g,  str_intp(6, _MOV((StrIntpData[]){{_SLIT("\tmain__TestRunner_name_table[test_runner._typ]._method_fn_error(test_runner._object, "), 0xfe07, {.d_i32 = paline}}, {_SLIT(", tos3(\""), 0xfe10, {.d_s = pafile}}, {_SLIT("\"), tos3(\""), 0xfe10, {.d_s = pamod}}, {_SLIT("\"), tos3(\""), 0xfe10, {.d_s = pafn}}, {_SLIT("\"), *("), 0xfe10, {.d_s = cvar_name}}, {_SLIT(".err.msg) );"), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_writeln(g, _SLIT("\tlongjmp(g_jump_buffer, 1);"));
}

void v__gen__c__Gen_gen_failing_return_error_for_test_fn(v__gen__c__Gen* g, v__ast__Return return_stmt, string cvar_name) {
	multi_return_int_string_string_string mr_5314 = v__gen__c__Gen_panic_debug_info(g, return_stmt.pos);
	int paline = mr_5314.arg0;
	string pafile = mr_5314.arg1;
	string pamod = mr_5314.arg2;
	string pafn = mr_5314.arg3;
	v__gen__c__Gen_writeln(g,  str_intp(6, _MOV((StrIntpData[]){{_SLIT("\tmain__TestRunner_name_table[test_runner._typ]._method_fn_error(test_runner._object, "), 0xfe07, {.d_i32 = paline}}, {_SLIT(", tos3(\""), 0xfe10, {.d_s = pafile}}, {_SLIT("\"), tos3(\""), 0xfe10, {.d_s = pamod}}, {_SLIT("\"), tos3(\""), 0xfe10, {.d_s = pafn}}, {_SLIT("\"), *("), 0xfe10, {.d_s = cvar_name}}, {_SLIT(".err.msg) );"), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_writeln(g, _SLIT("\tlongjmp(g_jump_buffer, 1);"));
}

void v__gen__c__Gen_gen_c_main_for_tests(v__gen__c__Gen* g) {
	int main_fn_start_pos = g->out.len;
	v__gen__c__Gen_writeln(g, _SLIT(""));
	v__gen__c__Gen_gen_c_main_function_header(g);
	if (g->pref->gc_mode == v__pref__GarbageCollectionMode__boehm_full || g->pref->gc_mode == v__pref__GarbageCollectionMode__boehm_incr || g->pref->gc_mode == v__pref__GarbageCollectionMode__boehm_full_opt || g->pref->gc_mode == v__pref__GarbageCollectionMode__boehm_incr_opt || g->pref->gc_mode == v__pref__GarbageCollectionMode__boehm_leak) {
		v__gen__c__Gen_writeln(g, _SLIT("#if defined(_VGCBOEHM)"));
		if (g->pref->gc_mode == v__pref__GarbageCollectionMode__boehm_leak) {
			v__gen__c__Gen_writeln(g, _SLIT("\tGC_set_find_leak(1);"));
		}
		v__gen__c__Gen_writeln(g, _SLIT("\tGC_INIT();"));
		if (g->pref->gc_mode == v__pref__GarbageCollectionMode__boehm_incr || g->pref->gc_mode == v__pref__GarbageCollectionMode__boehm_incr_opt) {
			v__gen__c__Gen_writeln(g, _SLIT("\tGC_enable_incremental();"));
		}
		v__gen__c__Gen_writeln(g, _SLIT("#endif"));
	}
	v__gen__c__Gen_writeln(g, _SLIT("\tmain__vtest_init();"));
	v__gen__c__Gen_writeln(g, _SLIT("\t_vinit(___argc, (voidptr)___argv);"));
	Array_string all_tfuncs = v__gen__c__Gen_get_all_test_function_names(g);
	all_tfuncs = v__gen__c__Gen_filter_only_matching_fn_names(g, all_tfuncs);
	v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\tstring v_test_file = "), 0xfe10, {.d_s = v__gen__c__ctoslit(g->pref->path)}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
	if (g->pref->is_stats) {
		v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\tmain__BenchedTests bt = main__start_testing("), 0xfe07, {.d_i32 = all_tfuncs.len}}, {_SLIT(", v_test_file);"), 0, { .d_c = 0 }}})));
	}
	v__gen__c__Gen_writeln(g, _SLIT(""));
	v__gen__c__Gen_writeln(g, _SLIT("\tstruct _main__TestRunner_interface_methods _vtrunner = main__TestRunner_name_table[test_runner._typ];"));
	v__gen__c__Gen_writeln(g, _SLIT("\tvoid * _vtobj = test_runner._object;"));
	v__gen__c__Gen_writeln(g, _SLIT(""));
	v__gen__c__Gen_writeln(g, _SLIT("\tmain__VTestFileMetaInfo_free(test_runner.file_test_info);"));
	v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t*(test_runner.file_test_info) = main__vtest_new_filemetainfo(v_test_file, "), 0xfe07, {.d_i32 = all_tfuncs.len}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t_vtrunner._method_start(_vtobj, "), 0xfe07, {.d_i32 = all_tfuncs.len}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_writeln(g, _SLIT(""));
	for (int tnumber = 0; tnumber < all_tfuncs.len; ++tnumber) {
		string tname = ((string*)all_tfuncs.data)[tnumber];
		string tcname = v__util__no_dots(tname);
		v__ast__Fn testfn = (*(v__ast__Fn*)map_get(ADDR(map, g->table->fns), &(string[]){tname}, &(v__ast__Fn[]){ (v__ast__Fn){.is_variadic = 0,.is_pub = 0,.is_ctor_new = 0,.is_deprecated = 0,.is_noreturn = 0,.is_unsafe = 0,.is_placeholder = 0,.is_main = 0,.is_test = 0,.is_keep_alive = 0,.is_method = 0,.no_body = 0,.mod = (string){.str=(byteptr)"", .is_lit=1},.file = (string){.str=(byteptr)"", .is_lit=1},.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.return_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.return_type = 0,.receiver_type = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.params = __new_array(0, 0, sizeof(v__ast__Param)),.source_fn = 0,.usages = 0,.generic_names = __new_array(0, 0, sizeof(string)),.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_conditional = 0,.ctdefine_idx = 0,} }));
		int lnum = testfn.pos.line_nr + 1;
		v__gen__c__Gen_writeln(g, _SLIT("\tmain__VTestFnMetaInfo_free(test_runner.fn_test_info);"));
		v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\tstring tcname_"), 0xfe07, {.d_i32 = tnumber}}, {_SLIT(" = _SLIT(\""), 0xfe10, {.d_s = tcname}}, {_SLIT("\");"), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\tstring tcmod_"), 0xfe07, {.d_i32 = tnumber}}, {_SLIT("  = _SLIT(\""), 0xfe10, {.d_s = testfn.mod}}, {_SLIT("\");"), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\tstring tcfile_"), 0xfe07, {.d_i32 = tnumber}}, {_SLIT(" = "), 0xfe10, {.d_s = v__gen__c__ctoslit(testfn.file)}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_writeln(g,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("\t*(test_runner.fn_test_info) = main__vtest_new_metainfo(tcname_"), 0xfe07, {.d_i32 = tnumber}}, {_SLIT(", tcmod_"), 0xfe07, {.d_i32 = tnumber}}, {_SLIT(", tcfile_"), 0xfe07, {.d_i32 = tnumber}}, {_SLIT(", "), 0xfe07, {.d_i32 = lnum}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_writeln(g, _SLIT("\t_vtrunner._method_fn_start(_vtobj);"));
		v__gen__c__Gen_writeln(g, _SLIT("\tif (!setjmp(g_jump_buffer)) {"));
		if (g->pref->is_stats) {
			v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\tmain__BenchedTests_testing_step_start(&bt, tcname_"), 0xfe07, {.d_i32 = tnumber}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
		}
		v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\t"), 0xfe10, {.d_s = tcname}}, {_SLIT("();"), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_writeln(g, _SLIT("\t\t_vtrunner._method_fn_pass(_vtobj);"));
		v__gen__c__Gen_writeln(g, _SLIT("\t}else{"));
		v__gen__c__Gen_writeln(g, _SLIT("\t\t_vtrunner._method_fn_fail(_vtobj);"));
		v__gen__c__Gen_writeln(g, _SLIT("\t}"));
		if (g->pref->is_stats) {
			v__gen__c__Gen_writeln(g, _SLIT("\tmain__BenchedTests_testing_step_end(&bt);"));
		}
		v__gen__c__Gen_writeln(g, _SLIT(""));
	}
	if (g->pref->is_stats) {
		v__gen__c__Gen_writeln(g, _SLIT("\tmain__BenchedTests_end_testing(&bt);"));
	}
	v__gen__c__Gen_writeln(g, _SLIT(""));
	v__gen__c__Gen_writeln(g, _SLIT("\t_vtrunner._method_finish(_vtobj);"));
	v__gen__c__Gen_writeln(g, _SLIT("\tint test_exit_code = _vtrunner._method_exit_code(_vtobj);"));
	v__gen__c__Gen_writeln(g, _SLIT("\t_vtrunner._method__v_free(_vtobj);"));
	v__gen__c__Gen_writeln(g, _SLIT(""));
	v__gen__c__Gen_writeln(g, _SLIT("\t_vcleanup();"));
	v__gen__c__Gen_writeln(g, _SLIT(""));
	v__gen__c__Gen_writeln(g, _SLIT("\treturn test_exit_code;"));
	v__gen__c__Gen_writeln(g, _SLIT("}"));
	if (g->pref->printfn_list.len > 0 && Array_string_contains(g->pref->printfn_list, _SLIT("main"))) {
		println(strings__Builder_after(&g->out, main_fn_start_pos));
	}
}

Array_string v__gen__c__Gen_filter_only_matching_fn_names(v__gen__c__Gen* g, Array_string fnames) {
	if (g->pref->run_only.len == 0) {
		Array_string _t1 = fnames;
		return _t1;
	}
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t2 = 0; _t2 < fnames.len; ++_t2) {
		string tname = ((string*)fnames.data)[_t2];
		if (string_contains(tname, _SLIT("testsuite_"))) {
			array_push((array*)&res, _MOV((string[]){ string_clone(tname) }));
			continue;
		}
		bool is_matching = false;
		for (int _t4 = 0; _t4 < g->pref->run_only.len; ++_t4) {
			string fn_glob_pattern = ((string*)g->pref->run_only.data)[_t4];
			if (string_match_glob(tname, fn_glob_pattern)) {
				is_matching = true;
				break;
			}
		}
		if (!is_matching) {
			continue;
		}
		array_push((array*)&res, _MOV((string[]){ string_clone(tname) }));
	}
	Array_string _t6 = res;
	return _t6;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_comptime_selector(v__gen__c__Gen* g, v__ast__ComptimeSelector node) {
	v__gen__c__Gen_expr(g, node.left);
	if (v__ast__Type_is_ptr(node.left_type)) {
		v__gen__c__Gen_write(g, _SLIT("->"));
	} else {
		v__gen__c__Gen_write(g, _SLIT("."));
	}
	if ((node.field_expr)._typ == 319 /* v.ast.SelectorExpr */) {
		if (((*node.field_expr._v__ast__SelectorExpr).expr)._typ == 299 /* v.ast.Ident */) {
			if (string__eq((*(*node.field_expr._v__ast__SelectorExpr).expr._v__ast__Ident).name, g->comptime_for_field_var) && string__eq((*node.field_expr._v__ast__SelectorExpr).field_name, _SLIT("name"))) {
				v__gen__c__Gen_write(g, v__gen__c__c_name(g->comptime_for_field_value.name));
				return;
			}
		}
	}
	v__gen__c__Gen_expr(g, node.field_expr);
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_comptime_call(v__gen__c__Gen* g, v__ast__ComptimeCall* node) {
	if (node->is_embed) {
		v__gen__c__Gen_gen_embed_file_init(g, node);
		return;
	}
	if (string__eq(node->method_name, _SLIT("env"))) {
		string val = v__util__cescaped_path(os__getenv(node->args_var));
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("_SLIT(\""), 0xfe10, {.d_s = val}}, {_SLIT("\")"), 0, { .d_c = 0 }}})));
		return;
	}
	if (node->is_vweb) {
		bool is_html = string__eq(node->method_name, _SLIT("html"));
		string cur_line = _SLIT("");
		if (!is_html) {
			cur_line = v__gen__c__Gen_go_before_stmt(g, 0);
		}
		for (int _t1 = 0; _t1 < node->vweb_tmpl.stmts.len; ++_t1) {
			v__ast__Stmt stmt = ((v__ast__Stmt*)node->vweb_tmpl.stmts.data)[_t1];
			if ((stmt)._typ == 216 /* v.ast.FnDecl */) {
				if (string_starts_with((*stmt._v__ast__FnDecl).name, _SLIT("main.vweb_tmpl"))) {
					if (is_html) {
						g->inside_vweb_tmpl = true;
					}
					Array_v__ast__Stmt _t2 = __new_array(0, 0, sizeof(v__ast__Stmt));
					Array_v__ast__Stmt _t2_orig = (*stmt._v__ast__FnDecl).stmts;
					int _t2_len = _t2_orig.len;
					_t2 = __new_array(0, _t2_len, sizeof(v__ast__Stmt));

					for (int _t3 = 0; _t3 < _t2_len; ++_t3) {
						v__ast__Stmt it = ((v__ast__Stmt*) _t2_orig.data)[_t3];
						if ((it)._typ != 350 /* v.ast.Return */) {
							array_push((array*)&_t2, &it);
						}
					}
					v__gen__c__Gen_stmts(g,_t2);
					g->inside_vweb_tmpl = false;
					break;
				}
			}
		}
		string fn_name = string__plus(string_replace(g->fn_decl->name, _SLIT("."), _SLIT("__")), int_str(node->pos.pos));
		if (is_html) {
			v__gen__c__Gen_writeln(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("vweb__Context_html(&app->Context, _tmpl_res_"), 0xfe10, {.d_s = fn_name}}, {_SLIT("); strings__Builder_free(&sb_"), 0xfe10, {.d_s = fn_name}}, {_SLIT("); string_free(&_tmpl_res_"), 0xfe10, {.d_s = fn_name}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
		} else {
			v__gen__c__Gen_write(g, cur_line);
			if (g->inside_return) {
				v__gen__c__Gen_write(g, _SLIT("return "));
			}
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("_tmpl_res_"), 0xfe10, {.d_s = fn_name}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		return;
	}
	v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, v__gen__c__Gen_unwrap_generic(g, node->left_type));
	;
	if (string__eq(node->method_name, _SLIT("method"))) {
		Option_v__ast__Fn _t4 = v__ast__TypeSymbol_find_method(sym, g->comptime_for_method);
		if (_t4.state != 0) { /*or block*/ 
			IError err = _t4.err;
			return;
		}
		
 		v__ast__Fn m =  (*(v__ast__Fn*)_t4.data);
		bool _t5; /* if prepend */
		if (node->args.len > 0 && m.params.len - 1 >= node->args.len) {
			v__ast__CallArg arg = (*(v__ast__CallArg*)/*ee elem_typ */array_get(node->args, node->args.len - 1));
			v__ast__Param param = (*(v__ast__Param*)/*ee elem_typ */array_get(m.params, node->args.len));
			_t5 = (arg.expr)._typ == 299 /* v.ast.Ident */ && string__eq(v__ast__Table_type_to_str(g->table, arg.typ), _SLIT("[]string")) && !string__eq(v__ast__Table_type_to_str(g->table, param.typ), _SLIT("[]string"));
		} else {
			_t5 = false;
		}
		bool expand_strs =  _t5;
		if (m.params.len - 1 != node->args.len && !expand_strs) {
			v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("/* skipping "), 0xfe10, {.d_s = sym->name}}, {_SLIT("."), 0xfe10, {.d_s = m.name}}, {_SLIT(" due to mismatched arguments list */"), 0, { .d_c = 0 }}})));
			return;
		}
		v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__util__no_dots(sym->name)}}, {_SLIT("_"), 0xfe10, {.d_s = g->comptime_for_method}}, {_SLIT("("), 0, { .d_c = 0 }}})));
		if ((node->left)._typ == 299 /* v.ast.Ident */) {
			v__ast__Scope* scope = v__ast__Scope_innermost(g->file->scope, node->pos.pos);
			Option_v__ast__Var_ptr _t6;
			if (_t6 = v__ast__Scope_find_var(scope, (*node->left._v__ast__Ident).name), _t6.state == 0) {
				v__ast__Var* v = *(v__ast__Var**)_t6.data;
				if (v__ast__Type_is_ptr((*(v__ast__Param*)/*ee elem_typ */array_get(m.params, 0)).typ) && !v__ast__Type_is_ptr(v->typ)) {
					v__gen__c__Gen_write(g, _SLIT("&"));
				}
			}
		}
		v__gen__c__Gen_expr(g, node->left);
		if (m.params.len > 1) {
			v__gen__c__Gen_write(g, _SLIT(", "));
		}
		for (int i = 1; i < m.params.len; ++i) {
			if ((node->left)._typ == 299 /* v.ast.Ident */) {
				if (string__eq((*(v__ast__Param*)/*ee elem_typ */array_get(m.params, i)).name, (*node->left._v__ast__Ident).name)) {
					continue;
				}
			}
			if (i - 1 < node->args.len - 1) {
				v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node->args, i - 1)).expr);
				v__gen__c__Gen_write(g, _SLIT(", "));
			} else if (!expand_strs && i == node->args.len) {
				v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node->args, i - 1)).expr);
				break;
			} else {
				int idx = i - node->args.len;
				if (v__ast__Type_is_int((*(v__ast__Param*)/*ee elem_typ */array_get(m.params, i)).typ) || v__ast__Type_idx((*(v__ast__Param*)/*ee elem_typ */array_get(m.params, i)).typ) == _const_v__ast__bool_type_idx) {
					string type_name = v__ast__TypeSymbol_str((*(v__ast__TypeSymbol**)/*ee elem_typ */array_get(g->table->type_symbols, ((int)((*(v__ast__Param*)/*ee elem_typ */array_get(m.params, i)).typ)))));
					v__gen__c__Gen_write(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("string_"), 0xfe10, {.d_s = type_name}}, {_SLIT("(((string*)"), 0xfe10, {.d_s = v__ast__CallArg_str((*(v__ast__CallArg*)/*ee elem_typ */array_get(node->args, node->args.len - 1)))}}, {_SLIT(".data) ["), 0xfe07, {.d_i32 = idx}}, {_SLIT("])"), 0, { .d_c = 0 }}})));
				} else {
					v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("((string*)"), 0xfe10, {.d_s = v__ast__CallArg_str((*(v__ast__CallArg*)/*ee elem_typ */array_get(node->args, node->args.len - 1)))}}, {_SLIT(".data) ["), 0xfe07, {.d_i32 = idx}}, {_SLIT("] "), 0, { .d_c = 0 }}})));
				}
				if (i < m.params.len - 1) {
					v__gen__c__Gen_write(g, _SLIT(", "));
				}
			}
		}
		v__gen__c__Gen_write(g, _SLIT(" ); // vweb action call with args"));
		return;
	}
	int j = 0;
	for (int _t7 = 0; _t7 < sym->methods.len; ++_t7) {
		v__ast__Fn method = ((v__ast__Fn*)sym->methods.data)[_t7];
		if (!v__ast__Type_alias_eq(method.return_type, node->result_type)) {
			continue;
		}
		if (method.params.len != 1) {
			continue;
		}
		string amp = _SLIT("");
		if (node->is_vweb) {
			if (j > 0) {
				v__gen__c__Gen_write(g, _SLIT(" else "));
			}
			v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("if (string__eq("), 0xfe10, {.d_s = node->method_name}}, {_SLIT(", _SLIT(\""), 0xfe10, {.d_s = method.name}}, {_SLIT("\"))) "), 0, { .d_c = 0 }}})));
		}
		v__gen__c__Gen_write(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__util__no_dots(sym->name)}}, {_SLIT("_"), 0xfe10, {.d_s = method.name}}, {_SLIT("("), 0xfe10, {.d_s = amp}}, {_SLIT(" "), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_expr(g, node->left);
		v__gen__c__Gen_writeln(g, _SLIT(");"));
		j++;
	}
}

VV_LOCAL_SYMBOL Array_string v__gen__c__cgen_attrs(Array_v__ast__Attr attrs) {
	Array_string res = __new_array_with_default(0, attrs.len, sizeof(string), 0);
	for (int _t1 = 0; _t1 < attrs.len; ++_t1) {
		v__ast__Attr attr = ((v__ast__Attr*)attrs.data)[_t1];
		string s = attr.name;
		if (attr.arg.len > 0) {
			s = /*f*/string__plus(s,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(": "), 0xfe10, {.d_s = attr.arg}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		array_push((array*)&res, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("_SLIT(\""), 0xfe10, {.d_s = s}}, {_SLIT("\")"), 0, { .d_c = 0 }}}))) }));
	}
	Array_string _t3 = res;
	return _t3;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_comptime_at(v__gen__c__Gen* g, v__ast__AtExpr node) {
	if (node.kind == v__token__AtKind__vmod_file) {
		string val = v__gen__c__cnewlines(string_replace(node.val, _SLIT("\r"), _SLIT("")));
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("_SLIT(\""), 0xfe10, {.d_s = val}}, {_SLIT("\")"), 0, { .d_c = 0 }}})));
	} else {
		string val = string_replace(node.val, _SLIT("\\"), _SLIT("\\\\"));
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("_SLIT(\""), 0xfe10, {.d_s = val}}, {_SLIT("\")"), 0, { .d_c = 0 }}})));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_comptime_if(v__gen__c__Gen* g, v__ast__IfExpr node) {
	if (!node.is_expr && !node.has_else && node.branches.len == 1) {
		if ((*(v__ast__IfBranch*)/*ee elem_typ */array_get(node.branches, 0)).stmts.len == 0) {
			return;
		}
		if (!g->pref->output_cross_c) {
			if (((*(v__ast__IfBranch*)/*ee elem_typ */array_get(node.branches, 0)).cond)._typ == 299 /* v.ast.Ident */) {
				Option_v__pref__OS _t1 = v__pref__os_from_string((*(*(v__ast__IfBranch*)/*ee elem_typ */array_get(node.branches, 0)).cond._v__ast__Ident).name);
				if (_t1.state != 0) { /*or block*/ 
					IError err = _t1.err;
					*(v__pref__OS*) _t1.data = v__pref__OS___auto;
				}
				
 				if (g->pref->os == ( (*(v__pref__OS*)_t1.data))) {
					g->indent--;
					v__gen__c__Gen_stmts(g, (*(v__ast__IfBranch*)/*ee elem_typ */array_get(node.branches, 0)).stmts);
					g->indent++;
					return;
				}
			}
		}
	}
	string _t2; /* if prepend */
	if (node.is_expr) {
		string stmt_str = v__gen__c__Gen_go_before_stmt(g, 0);
		v__gen__c__Gen_write(g, v__util__tabs(g->indent));
		_t2 = string_trim_space(stmt_str);
	} else {
		_t2 = _SLIT("");
	}
	string line =  _t2;
	bool comptime_if_stmts_skip = false;
	for (int i = 0; i < node.branches.len; ++i) {
		v__ast__IfBranch branch = ((v__ast__IfBranch*)node.branches.data)[i];
		int start_pos = g->out.len;
		if (i == node.branches.len - 1 && node.has_else) {
			v__gen__c__Gen_writeln(g, _SLIT("#else"));
			comptime_if_stmts_skip = false;
		} else {
			if (i == 0) {
				v__gen__c__Gen_write(g, _SLIT("#if "));
			} else {
				v__gen__c__Gen_write(g, _SLIT("#elif "));
			}
			comptime_if_stmts_skip = !v__gen__c__Gen_comptime_if_cond(g, branch.cond, branch.pkg_exist);
			v__gen__c__Gen_writeln(g, _SLIT(""));
		}
		string expr_str = string_trim_space(strings__Builder_last_n(&g->out, g->out.len - start_pos));
		g->defer_ifdef = expr_str;
		if (node.is_expr) {
			int len = branch.stmts.len;
			if (len > 0) {
				v__ast__ExprStmt last = /* as */ *(v__ast__ExprStmt*)__as_cast(((*(v__ast__Stmt*)/*ee elem_typ */array_get(branch.stmts, len - 1)))._v__ast__ExprStmt,((*(v__ast__Stmt*)/*ee elem_typ */array_get(branch.stmts, len - 1)))._typ, 339) /*expected idx: 339, name: v.ast.ExprStmt */ ;
				if (len > 1) {
					string tmp = v__gen__c__Gen_new_tmp_var(g);
					string styp = v__gen__c__Gen_typ(g, last.typ);
					g->indent++;
					v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = styp}}, {_SLIT(" "), 0xfe10, {.d_s = tmp}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
					v__gen__c__Gen_writeln(g, _SLIT("{"));
					v__gen__c__Gen_stmts(g, array_slice(branch.stmts, 0, len - 1));
					v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = tmp}}, {_SLIT(" = "), 0, { .d_c = 0 }}})));
					v__gen__c__Gen_stmt(g, v__ast__ExprStmt_to_sumtype_v__ast__Stmt(&last));
					v__gen__c__Gen_writeln(g, _SLIT("}"));
					g->indent--;
					v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = line}}, {_SLIT(" "), 0xfe10, {.d_s = tmp}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
				} else {
					v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = line}}, {_SLIT(" "), 0, { .d_c = 0 }}})));
					v__gen__c__Gen_stmt(g, v__ast__ExprStmt_to_sumtype_v__ast__Stmt(&last));
				}
			}
		} else {
			bool should_create_scope = g->fn_decl != 0;
			if (should_create_scope) {
				v__gen__c__Gen_writeln(g, _SLIT("{"));
			}
			if (!comptime_if_stmts_skip) {
				v__gen__c__Gen_stmts(g, branch.stmts);
			}
			if (should_create_scope) {
				v__gen__c__Gen_writeln(g, _SLIT("}"));
			}
		}
		g->defer_ifdef = _SLIT("");
	}
	v__gen__c__Gen_writeln(g, _SLIT("#endif"));
}

VV_LOCAL_SYMBOL bool v__gen__c__Gen_comptime_if_cond(v__gen__c__Gen* g, v__ast__Expr cond, bool pkg_exist) {
	if (cond._typ == 284 /* v.ast.BoolLiteral */) {
		v__gen__c__Gen_expr(g, cond);
		bool _t1 = true;
		return _t1;
	}
	else if (cond._typ == 314 /* v.ast.ParExpr */) {
		v__gen__c__Gen_write(g, _SLIT("("));
		bool is_cond_true = v__gen__c__Gen_comptime_if_cond(g, (*cond._v__ast__ParExpr).expr, pkg_exist);
		v__gen__c__Gen_write(g, _SLIT(")"));
		bool _t2 = is_cond_true;
		return _t2;
	}
	else if (cond._typ == 316 /* v.ast.PrefixExpr */) {
		v__gen__c__Gen_write(g, v__token__Kind_str((*cond._v__ast__PrefixExpr).op));
		bool _t3 = v__gen__c__Gen_comptime_if_cond(g, (*cond._v__ast__PrefixExpr).right, pkg_exist);
		return _t3;
	}
	else if (cond._typ == 315 /* v.ast.PostfixExpr */) {
		Option_string _t4 = v__gen__c__Gen_comptime_if_to_ifdef(g, (/* as */ *(v__ast__Ident*)__as_cast(((*cond._v__ast__PostfixExpr).expr)._v__ast__Ident,((*cond._v__ast__PostfixExpr).expr)._typ, 299) /*expected idx: 299, name: v.ast.Ident */ ).name, true);
		if (_t4.state != 0) { /*or block*/ 
			IError err = _t4.err;
			v__gen__c__verror((*(err.msg)));
			VUNREACHABLE();
			bool _t5 = false;
			return _t5;
		}
		
 		string ifdef =  (*(string*)_t4.data);
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("defined("), 0xfe10, {.d_s = ifdef}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
		bool _t6 = true;
		return _t6;
	}
	else if (cond._typ == 303 /* v.ast.InfixExpr */) {

		if ((*cond._v__ast__InfixExpr).op == (v__token__Kind__and) || (*cond._v__ast__InfixExpr).op == (v__token__Kind__logical_or)) {
			bool l = v__gen__c__Gen_comptime_if_cond(g, (*cond._v__ast__InfixExpr).left, pkg_exist);
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(" "), 0xfe10, {.d_s = v__token__Kind_str((*cond._v__ast__InfixExpr).op)}}, {_SLIT(" "), 0, { .d_c = 0 }}})));
			bool r = v__gen__c__Gen_comptime_if_cond(g, (*cond._v__ast__InfixExpr).right, pkg_exist);
			bool _t7 = ((*cond._v__ast__InfixExpr).op == v__token__Kind__and ? (l && r) : (l || r));
			return _t7;
		}
		else if ((*cond._v__ast__InfixExpr).op == (v__token__Kind__key_is) || (*cond._v__ast__InfixExpr).op == (v__token__Kind__not_is)) {
			v__ast__Expr left = (*cond._v__ast__InfixExpr).left;
			string name = _SLIT("");
			v__ast__Type exp_type = ((v__ast__Type)(0));
			v__ast__Type got_type = (/* as */ *(v__ast__TypeNode*)__as_cast(((*cond._v__ast__InfixExpr).right)._v__ast__TypeNode,((*cond._v__ast__InfixExpr).right)._typ, 325) /*expected idx: 325, name: v.ast.TypeNode */ ).typ;
			if ((left)._typ == 325 /* v.ast.TypeNode */ && ((*cond._v__ast__InfixExpr).right)._typ == 325 /* v.ast.TypeNode */ && v__ast__Table_sym(g->table, got_type)->kind == v__ast__Kind__interface_) {
				v__ast__TypeSymbol* interface_sym = v__ast__Table_sym(g->table, got_type);
				if ((interface_sym->info)._typ == 463 /* v.ast.Interface */) {
					v__ast__Type checked_type = v__gen__c__Gen_unwrap_generic(g, (*left._v__ast__TypeNode).typ);
					bool is_true = v__ast__Table_does_type_implement_interface(g->table, checked_type, got_type);
					if ((*cond._v__ast__InfixExpr).op == v__token__Kind__key_is) {
						if (is_true) {
							v__gen__c__Gen_write(g, _SLIT("1"));
						} else {
							v__gen__c__Gen_write(g, _SLIT("0"));
						}
						bool _t8 = is_true;
						return _t8;
					} else if ((*cond._v__ast__InfixExpr).op == v__token__Kind__not_is) {
						if (is_true) {
							v__gen__c__Gen_write(g, _SLIT("0"));
						} else {
							v__gen__c__Gen_write(g, _SLIT("1"));
						}
						bool _t9 = !is_true;
						return _t9;
					}
				}
			} else if ((left)._typ == 319 /* v.ast.SelectorExpr */) {
				name =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__ast__Expr_str((*left._v__ast__SelectorExpr).expr)}}, {_SLIT("."), 0xfe10, {.d_s = (*left._v__ast__SelectorExpr).field_name}}, {_SLIT0, 0, { .d_c = 0 }}}));
				exp_type = (*(v__ast__Type*)map_get(ADDR(map, g->comptime_var_type_map), &(string[]){name}, &(v__ast__Type[]){ 0 }));
			} else if ((left)._typ == 325 /* v.ast.TypeNode */) {
				exp_type = v__gen__c__Gen_unwrap_generic(g, (*left._v__ast__TypeNode).typ);
			}
			if ((*cond._v__ast__InfixExpr).op == v__token__Kind__key_is) {
				v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = exp_type}}, {_SLIT(" == "), 0xfe07, {.d_i32 = got_type}}, {_SLIT0, 0, { .d_c = 0 }}})));
				bool _t10 = v__ast__Type_alias_eq(exp_type, got_type);
				return _t10;
			} else {
				v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = exp_type}}, {_SLIT(" != "), 0xfe07, {.d_i32 = got_type}}, {_SLIT0, 0, { .d_c = 0 }}})));
				bool _t11 = !v__ast__Type_alias_eq(exp_type, got_type);
				return _t11;
			}
		}
		else if ((*cond._v__ast__InfixExpr).op == (v__token__Kind__eq) || (*cond._v__ast__InfixExpr).op == (v__token__Kind__ne)) {
			v__gen__c__Gen_write(g, _SLIT("1"));
			bool _t12 = true;
			return _t12;
		}
		else {
			bool _t13 = true;
			return _t13;
		};
	}
	else if (cond._typ == 299 /* v.ast.Ident */) {
		Option_string _t14 = v__gen__c__Gen_comptime_if_to_ifdef(g, (*cond._v__ast__Ident).name, false);
		if (_t14.state != 0) { /*or block*/ 
			IError err = _t14.err;
			*(string*) _t14.data = _SLIT("true");
		}
		
 		string ifdef =  (*(string*)_t14.data);
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("defined("), 0xfe10, {.d_s = ifdef}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
		bool _t15 = true;
		return _t15;
	}
	else if (cond._typ == 291 /* v.ast.ComptimeCall */) {
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = pkg_exist ? _SLIT("true") : _SLIT("false")}}, {_SLIT0, 0, { .d_c = 0 }}})));
		bool _t16 = true;
		return _t16;
	}
	
	else {
		v__gen__c__Gen_write(g, _SLIT("1"));
		bool _t17 = true;
		return _t17;
	}
	;
	return 0;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_comptime_for(v__gen__c__Gen* g, v__ast__ComptimeFor node) {
	v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, v__gen__c__Gen_unwrap_generic(g, node.typ));
	v__gen__c__Gen_writeln(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("/* $for "), 0xfe10, {.d_s = node.val_var}}, {_SLIT(" in "), 0xfe10, {.d_s = sym->name}}, {_SLIT("("), 0xfe10, {.d_s = v__ast__ComptimeForKind_str(node.kind)}}, {_SLIT(") */ {"), 0, { .d_c = 0 }}})));
	g->indent++;
	int i = 0;
	if (node.kind == v__ast__ComptimeForKind__methods) {
		Array_v__ast__Fn _t1 = __new_array(0, 0, sizeof(v__ast__Fn));
		Array_v__ast__Fn _t1_orig = sym->methods;
		int _t1_len = _t1_orig.len;
		_t1 = __new_array(0, _t1_len, sizeof(v__ast__Fn));

		for (int _t2 = 0; _t2 < _t1_len; ++_t2) {
			v__ast__Fn it = ((v__ast__Fn*) _t1_orig.data)[_t2];
			if (it.attrs.len == 0) {
				array_push((array*)&_t1, &it);
			}
		}
		Array_v__ast__Fn methods =_t1;
		Array_v__ast__Fn _t3 = __new_array(0, 0, sizeof(v__ast__Fn));
		Array_v__ast__Fn _t3_orig = sym->methods;
		int _t3_len = _t3_orig.len;
		_t3 = __new_array(0, _t3_len, sizeof(v__ast__Fn));

		for (int _t4 = 0; _t4 < _t3_len; ++_t4) {
			v__ast__Fn it = ((v__ast__Fn*) _t3_orig.data)[_t4];
			if (it.attrs.len > 0) {
				array_push((array*)&_t3, &it);
			}
		}
		Array_v__ast__Fn methods_with_attrs =_t3;
		_PUSH_MANY(&methods, (methods_with_attrs), _t5, Array_v__ast__Fn);
		if (methods.len > 0) {
			v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("FunctionData "), 0xfe10, {.d_s = node.val_var}}, {_SLIT(" = {0};"), 0, { .d_c = 0 }}})));
		}
		for (int _t6 = 0; _t6 < methods.len; ++_t6) {
			v__ast__Fn method = ((v__ast__Fn*)methods.data)[_t6];
			g->comptime_for_method = method.name;
			v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("/* method "), 0xfe07, {.d_i32 = i}}, {_SLIT(" */ {"), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = node.val_var}}, {_SLIT(".name = _SLIT(\""), 0xfe10, {.d_s = method.name}}, {_SLIT("\");"), 0, { .d_c = 0 }}})));
			if (method.attrs.len == 0) {
				v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = node.val_var}}, {_SLIT(".attrs = __new_array_with_default(0, 0, sizeof(string), 0);"), 0, { .d_c = 0 }}})));
			} else {
				Array_string attrs = v__gen__c__cgen_attrs(method.attrs);
				v__gen__c__Gen_writeln(g, string__plus(string__plus( str_intp(5, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = node.val_var}}, {_SLIT(".attrs = new_array_from_c_array("), 0xfe07, {.d_i32 = attrs.len}}, {_SLIT(", "), 0xfe07, {.d_i32 = attrs.len}}, {_SLIT(", sizeof(string), _MOV((string["), 0xfe07, {.d_i32 = attrs.len}}, {_SLIT("]){"), 0, { .d_c = 0 }}})), Array_string_join(attrs, _SLIT(", "))), _SLIT("}));\n")));
			}
			if (method.params.len < 2) {
				v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = node.val_var}}, {_SLIT(".args = __new_array_with_default(0, 0, sizeof(MethodArgs), 0);"), 0, { .d_c = 0 }}})));
			} else {
				int len = method.params.len - 1;
				v__gen__c__Gen_write(g,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = node.val_var}}, {_SLIT(".args = new_array_from_c_array("), 0xfe07, {.d_i32 = len}}, {_SLIT(", "), 0xfe07, {.d_i32 = len}}, {_SLIT(", sizeof(MethodArgs), _MOV((MethodArgs["), 0xfe07, {.d_i32 = len}}, {_SLIT("]){"), 0, { .d_c = 0 }}})));
				Array_v__ast__Param _t7 = array_slice(method.params, 1, method.params.len);
				for (int j = 0; j < _t7.len; ++j) {
					v__ast__Param arg = ((v__ast__Param*)_t7.data)[j];
					int typ = v__ast__Type_idx(arg.typ);
					v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("{"), 0xfe10, {.d_s = int_str(typ)}}, {_SLIT(", _SLIT(\""), 0xfe10, {.d_s = arg.name}}, {_SLIT("\")}"), 0, { .d_c = 0 }}})));
					if (j < len - 1) {
						v__gen__c__Gen_write(g, _SLIT(", "));
					}
					map_set(&g->comptime_var_type_map, &(string[]){ str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = node.val_var}}, {_SLIT(".args["), 0xfe07, {.d_i32 = j}}, {_SLIT("].typ"), 0, { .d_c = 0 }}}))}, &(v__ast__Type[]) { typ });
				}
				v__gen__c__Gen_writeln(g, _SLIT("}));\n"));
			}
			string sig = _SLIT("anon_fn_");
			Array_v__ast__Param _t8 = array_slice(method.params, 1, method.params.len);
			for (int j = 0; j < _t8.len; ++j) {
				v__ast__Param arg = ((v__ast__Param*)_t8.data)[j];
				v__ast__Type typ = v__ast__Type_set_nr_muls(arg.typ, 0);
				sig = /*f*/string__plus(sig,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = typ}}, {_SLIT0, 0, { .d_c = 0 }}})));
				if (j < method.params.len - 2) {
					sig = /*f*/string__plus(sig, _SLIT("_"));
				}
			}
			sig = /*f*/string__plus(sig,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("_"), 0xfe07, {.d_i32 = method.return_type}}, {_SLIT0, 0, { .d_c = 0 }}})));
			int styp = v__ast__Table_find_type_idx(g->table, sig);
			int ret_typ = v__ast__Type_idx(method.return_type);
			v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = node.val_var}}, {_SLIT(".typ = "), 0xfe07, {.d_i32 = styp}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = node.val_var}}, {_SLIT(".return_type = "), 0xfe07, {.d_i32 = ret_typ}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
			map_set(&g->comptime_var_type_map, &(string[]){ str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = node.val_var}}, {_SLIT(".return_type"), 0, { .d_c = 0 }}}))}, &(v__ast__Type[]) { ret_typ });
			map_set(&g->comptime_var_type_map, &(string[]){ str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = node.val_var}}, {_SLIT(".typ"), 0, { .d_c = 0 }}}))}, &(v__ast__Type[]) { styp });
			v__gen__c__Gen_stmts(g, node.stmts);
			i++;
			v__gen__c__Gen_writeln(g, _SLIT("}"));
			Array_string delete_keys = __new_array_with_default(0, 0, sizeof(string), 0);
			Map_string_v__ast__Type _t9 = g->comptime_var_type_map;
			int _t11 = _t9.key_values.len;
			for (int _t10 = 0; _t10 < _t11; ++_t10 ) {
				int _t12 = _t9.key_values.len - _t11;
				_t11 = _t9.key_values.len;
				if (_t12 < 0) {
					_t10 = -1;
					continue;
				}
				if (!DenseArray_has_index(&_t9.key_values, _t10)) {continue;}
				string key = /*key*/ *(string*)DenseArray_key(&_t9.key_values, _t10);
				key = string_clone(key);
				if (string_starts_with(key, node.val_var)) {
					array_push((array*)&delete_keys, _MOV((string[]){ string_clone(key) }));
				}
			}
			for (int _t14 = 0; _t14 < delete_keys.len; ++_t14) {
				string key = ((string*)delete_keys.data)[_t14];
				map_delete(&g->comptime_var_type_map, &(string[]){key});
			}
		}
	} else if (node.kind == v__ast__ComptimeForKind__fields) {
		if ((sym->info)._typ == 446 /* v.ast.Struct */) {
			if ((*sym->info._v__ast__Struct).fields.len > 0) {
				v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\tFieldData "), 0xfe10, {.d_s = node.val_var}}, {_SLIT(" = {0};"), 0, { .d_c = 0 }}})));
			}
			for (int _t15 = 0; _t15 < (*sym->info._v__ast__Struct).fields.len; ++_t15) {
				v__ast__StructField field = ((v__ast__StructField*)(*sym->info._v__ast__Struct).fields.data)[_t15];
				g->comptime_for_field_var = node.val_var;
				g->comptime_for_field_value = field;
				v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("/* field "), 0xfe07, {.d_i32 = i}}, {_SLIT(" */ {"), 0, { .d_c = 0 }}})));
				v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = node.val_var}}, {_SLIT(".name = _SLIT(\""), 0xfe10, {.d_s = field.name}}, {_SLIT("\");"), 0, { .d_c = 0 }}})));
				if (field.attrs.len == 0) {
					v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = node.val_var}}, {_SLIT(".attrs = __new_array_with_default(0, 0, sizeof(string), 0);"), 0, { .d_c = 0 }}})));
				} else {
					Array_string attrs = v__gen__c__cgen_attrs(field.attrs);
					v__gen__c__Gen_writeln(g, string__plus(string__plus( str_intp(5, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = node.val_var}}, {_SLIT(".attrs = new_array_from_c_array("), 0xfe07, {.d_i32 = attrs.len}}, {_SLIT(", "), 0xfe07, {.d_i32 = attrs.len}}, {_SLIT(", sizeof(string), _MOV((string["), 0xfe07, {.d_i32 = attrs.len}}, {_SLIT("]){"), 0, { .d_c = 0 }}})), Array_string_join(attrs, _SLIT(", "))), _SLIT("}));\n")));
				}
				v__ast__Type styp = field.typ;
				v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = node.val_var}}, {_SLIT(".typ = "), 0xfe07, {.d_i32 = styp}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
				v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = node.val_var}}, {_SLIT(".is_pub = "), 0xfe10, {.d_s = field.is_pub ? _SLIT("true") : _SLIT("false")}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
				v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = node.val_var}}, {_SLIT(".is_mut = "), 0xfe10, {.d_s = field.is_mut ? _SLIT("true") : _SLIT("false")}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
				v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = node.val_var}}, {_SLIT(".is_shared = "), 0xfe10, {.d_s = v__ast__Type_has_flag(field.typ, v__ast__TypeFlag__shared_f) ? _SLIT("true") : _SLIT("false")}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
				map_set(&g->comptime_var_type_map, &(string[]){ str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = node.val_var}}, {_SLIT(".typ"), 0, { .d_c = 0 }}}))}, &(v__ast__Type[]) { styp });
				v__gen__c__Gen_stmts(g, node.stmts);
				i++;
				v__gen__c__Gen_writeln(g, _SLIT("}"));
			}
			map_delete(&g->comptime_var_type_map, &(string[]){node.val_var});
		}
	} else if (node.kind == v__ast__ComptimeForKind__attributes) {
		if ((sym->info)._typ == 446 /* v.ast.Struct */) {
			if ((*sym->info._v__ast__Struct).attrs.len > 0) {
				v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\tStructAttribute "), 0xfe10, {.d_s = node.val_var}}, {_SLIT(" = {0};"), 0, { .d_c = 0 }}})));
			}
			for (int _t16 = 0; _t16 < (*sym->info._v__ast__Struct).attrs.len; ++_t16) {
				v__ast__Attr attr = ((v__ast__Attr*)(*sym->info._v__ast__Struct).attrs.data)[_t16];
				v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("/* attribute "), 0xfe07, {.d_i32 = i}}, {_SLIT(" */ {"), 0, { .d_c = 0 }}})));
				v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = node.val_var}}, {_SLIT(".name = _SLIT(\""), 0xfe10, {.d_s = attr.name}}, {_SLIT("\");"), 0, { .d_c = 0 }}})));
				v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = node.val_var}}, {_SLIT(".has_arg = "), 0xfe10, {.d_s = attr.has_arg ? _SLIT("true") : _SLIT("false")}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
				v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = node.val_var}}, {_SLIT(".arg = _SLIT(\""), 0xfe10, {.d_s = attr.arg}}, {_SLIT("\");"), 0, { .d_c = 0 }}})));
				v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = node.val_var}}, {_SLIT(".kind = AttributeKind__"), 0xfe10, {.d_s = v__ast__AttrKind_str(attr.kind)}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
				v__gen__c__Gen_stmts(g, node.stmts);
				v__gen__c__Gen_writeln(g, _SLIT("}"));
			}
		}
	}
	g->indent--;
	v__gen__c__Gen_writeln(g, _SLIT("}// $for"));
}

VV_LOCAL_SYMBOL Option_string v__gen__c__Gen_comptime_if_to_ifdef(v__gen__c__Gen* g, string name, bool is_comptime_optional) {

	if (string__eq(name, _SLIT("windows"))) {
		Option_string _t1;
		opt_ok(&(string[]) { _SLIT("_WIN32") }, (Option*)(&_t1), sizeof(string));
		return _t1;
	}
	else if (string__eq(name, _SLIT("ios"))) {
		Option_string _t2;
		opt_ok(&(string[]) { _SLIT("__TARGET_IOS__") }, (Option*)(&_t2), sizeof(string));
		return _t2;
	}
	else if (string__eq(name, _SLIT("macos"))) {
		Option_string _t3;
		opt_ok(&(string[]) { _SLIT("__APPLE__") }, (Option*)(&_t3), sizeof(string));
		return _t3;
	}
	else if (string__eq(name, _SLIT("mach"))) {
		Option_string _t4;
		opt_ok(&(string[]) { _SLIT("__MACH__") }, (Option*)(&_t4), sizeof(string));
		return _t4;
	}
	else if (string__eq(name, _SLIT("darwin"))) {
		Option_string _t5;
		opt_ok(&(string[]) { _SLIT("__DARWIN__") }, (Option*)(&_t5), sizeof(string));
		return _t5;
	}
	else if (string__eq(name, _SLIT("hpux"))) {
		Option_string _t6;
		opt_ok(&(string[]) { _SLIT("__HPUX__") }, (Option*)(&_t6), sizeof(string));
		return _t6;
	}
	else if (string__eq(name, _SLIT("gnu"))) {
		Option_string _t7;
		opt_ok(&(string[]) { _SLIT("__GNU__") }, (Option*)(&_t7), sizeof(string));
		return _t7;
	}
	else if (string__eq(name, _SLIT("qnx"))) {
		Option_string _t8;
		opt_ok(&(string[]) { _SLIT("__QNX__") }, (Option*)(&_t8), sizeof(string));
		return _t8;
	}
	else if (string__eq(name, _SLIT("linux"))) {
		Option_string _t9;
		opt_ok(&(string[]) { _SLIT("__linux__") }, (Option*)(&_t9), sizeof(string));
		return _t9;
	}
	else if (string__eq(name, _SLIT("serenity"))) {
		Option_string _t10;
		opt_ok(&(string[]) { _SLIT("__serenity__") }, (Option*)(&_t10), sizeof(string));
		return _t10;
	}
	else if (string__eq(name, _SLIT("vinix"))) {
		Option_string _t11;
		opt_ok(&(string[]) { _SLIT("__vinix__") }, (Option*)(&_t11), sizeof(string));
		return _t11;
	}
	else if (string__eq(name, _SLIT("freebsd"))) {
		Option_string _t12;
		opt_ok(&(string[]) { _SLIT("__FreeBSD__") }, (Option*)(&_t12), sizeof(string));
		return _t12;
	}
	else if (string__eq(name, _SLIT("openbsd"))) {
		Option_string _t13;
		opt_ok(&(string[]) { _SLIT("__OpenBSD__") }, (Option*)(&_t13), sizeof(string));
		return _t13;
	}
	else if (string__eq(name, _SLIT("netbsd"))) {
		Option_string _t14;
		opt_ok(&(string[]) { _SLIT("__NetBSD__") }, (Option*)(&_t14), sizeof(string));
		return _t14;
	}
	else if (string__eq(name, _SLIT("bsd"))) {
		Option_string _t15;
		opt_ok(&(string[]) { _SLIT("__BSD__") }, (Option*)(&_t15), sizeof(string));
		return _t15;
	}
	else if (string__eq(name, _SLIT("dragonfly"))) {
		Option_string _t16;
		opt_ok(&(string[]) { _SLIT("__DragonFly__") }, (Option*)(&_t16), sizeof(string));
		return _t16;
	}
	else if (string__eq(name, _SLIT("android"))) {
		Option_string _t17;
		opt_ok(&(string[]) { _SLIT("__ANDROID__") }, (Option*)(&_t17), sizeof(string));
		return _t17;
	}
	else if (string__eq(name, _SLIT("solaris"))) {
		Option_string _t18;
		opt_ok(&(string[]) { _SLIT("__sun") }, (Option*)(&_t18), sizeof(string));
		return _t18;
	}
	else if (string__eq(name, _SLIT("haiku"))) {
		Option_string _t19;
		opt_ok(&(string[]) { _SLIT("__HAIKU__") }, (Option*)(&_t19), sizeof(string));
		return _t19;
	}
	else if (string__eq(name, _SLIT("js"))) {
		Option_string _t20;
		opt_ok(&(string[]) { _SLIT("_VJS") }, (Option*)(&_t20), sizeof(string));
		return _t20;
	}
	else if (string__eq(name, _SLIT("gcc"))) {
		Option_string _t21;
		opt_ok(&(string[]) { _SLIT("__V_GCC__") }, (Option*)(&_t21), sizeof(string));
		return _t21;
	}
	else if (string__eq(name, _SLIT("tinyc"))) {
		Option_string _t22;
		opt_ok(&(string[]) { _SLIT("__TINYC__") }, (Option*)(&_t22), sizeof(string));
		return _t22;
	}
	else if (string__eq(name, _SLIT("clang"))) {
		Option_string _t23;
		opt_ok(&(string[]) { _SLIT("__clang__") }, (Option*)(&_t23), sizeof(string));
		return _t23;
	}
	else if (string__eq(name, _SLIT("mingw"))) {
		Option_string _t24;
		opt_ok(&(string[]) { _SLIT("__MINGW32__") }, (Option*)(&_t24), sizeof(string));
		return _t24;
	}
	else if (string__eq(name, _SLIT("msvc"))) {
		Option_string _t25;
		opt_ok(&(string[]) { _SLIT("_MSC_VER") }, (Option*)(&_t25), sizeof(string));
		return _t25;
	}
	else if (string__eq(name, _SLIT("cplusplus"))) {
		Option_string _t26;
		opt_ok(&(string[]) { _SLIT("__cplusplus") }, (Option*)(&_t26), sizeof(string));
		return _t26;
	}
	else if (string__eq(name, _SLIT("threads"))) {
		Option_string _t27;
		opt_ok(&(string[]) { _SLIT("__VTHREADS__") }, (Option*)(&_t27), sizeof(string));
		return _t27;
	}
	else if (string__eq(name, _SLIT("gcboehm"))) {
		Option_string _t28;
		opt_ok(&(string[]) { _SLIT("_VGCBOEHM") }, (Option*)(&_t28), sizeof(string));
		return _t28;
	}
	else if (string__eq(name, _SLIT("debug"))) {
		Option_string _t29;
		opt_ok(&(string[]) { _SLIT("_VDEBUG") }, (Option*)(&_t29), sizeof(string));
		return _t29;
	}
	else if (string__eq(name, _SLIT("prod"))) {
		Option_string _t30;
		opt_ok(&(string[]) { _SLIT("_VPROD") }, (Option*)(&_t30), sizeof(string));
		return _t30;
	}
	else if (string__eq(name, _SLIT("test"))) {
		Option_string _t31;
		opt_ok(&(string[]) { _SLIT("_VTEST") }, (Option*)(&_t31), sizeof(string));
		return _t31;
	}
	else if (string__eq(name, _SLIT("glibc"))) {
		Option_string _t32;
		opt_ok(&(string[]) { _SLIT("__GLIBC__") }, (Option*)(&_t32), sizeof(string));
		return _t32;
	}
	else if (string__eq(name, _SLIT("prealloc"))) {
		Option_string _t33;
		opt_ok(&(string[]) { _SLIT("_VPREALLOC") }, (Option*)(&_t33), sizeof(string));
		return _t33;
	}
	else if (string__eq(name, _SLIT("no_bounds_checking"))) {
		Option_string _t34;
		opt_ok(&(string[]) { _SLIT("CUSTOM_DEFINE_no_bounds_checking") }, (Option*)(&_t34), sizeof(string));
		return _t34;
	}
	else if (string__eq(name, _SLIT("freestanding"))) {
		Option_string _t35;
		opt_ok(&(string[]) { _SLIT("_VFREESTANDING") }, (Option*)(&_t35), sizeof(string));
		return _t35;
	}
	else if (string__eq(name, _SLIT("amd64"))) {
		Option_string _t36;
		opt_ok(&(string[]) { _SLIT("__V_amd64") }, (Option*)(&_t36), sizeof(string));
		return _t36;
	}
	else if (string__eq(name, _SLIT("aarch64")) || string__eq(name, _SLIT("arm64"))) {
		Option_string _t37;
		opt_ok(&(string[]) { _SLIT("__V_arm64") }, (Option*)(&_t37), sizeof(string));
		return _t37;
	}
	else if (string__eq(name, _SLIT("x64"))) {
		Option_string _t38;
		opt_ok(&(string[]) { _SLIT("TARGET_IS_64BIT") }, (Option*)(&_t38), sizeof(string));
		return _t38;
	}
	else if (string__eq(name, _SLIT("x32"))) {
		Option_string _t39;
		opt_ok(&(string[]) { _SLIT("TARGET_IS_32BIT") }, (Option*)(&_t39), sizeof(string));
		return _t39;
	}
	else if (string__eq(name, _SLIT("little_endian"))) {
		Option_string _t40;
		opt_ok(&(string[]) { _SLIT("TARGET_ORDER_IS_LITTLE") }, (Option*)(&_t40), sizeof(string));
		return _t40;
	}
	else if (string__eq(name, _SLIT("big_endian"))) {
		Option_string _t41;
		opt_ok(&(string[]) { _SLIT("TARGET_ORDER_IS_BIG") }, (Option*)(&_t41), sizeof(string));
		return _t41;
	}
	else {
		if (is_comptime_optional || (g->pref->compile_defines_all.len > 0 && Array_string_contains(g->pref->compile_defines_all, name))) {
			Option_string _t42;
			opt_ok(&(string[]) {  str_intp(2, _MOV((StrIntpData[]){{_SLIT("CUSTOM_DEFINE_"), 0xfe10, {.d_s = name}}, {_SLIT0, 0, { .d_c = 0 }}})) }, (Option*)(&_t42), sizeof(string));
			return _t42;
		}
		return (Option_string){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("bad os ifdef name \""), 0xfe10, {.d_s = name}}, {_SLIT("\""), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	};
	return (Option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
}

VV_LOCAL_SYMBOL v__ast__CTempVar v__gen__c__Gen_new_ctemp_var(v__gen__c__Gen* g, v__ast__Expr expr, v__ast__Type expr_type) {
	v__ast__CTempVar _t1 = (v__ast__CTempVar){.name = v__gen__c__Gen_new_tmp_var(g),.orig = expr,.typ = expr_type,.is_ptr = v__ast__Type_is_ptr(expr_type),};
	return _t1;
}

VV_LOCAL_SYMBOL v__ast__CTempVar v__gen__c__Gen_new_ctemp_var_then_gen(v__gen__c__Gen* g, v__ast__Expr expr, v__ast__Type expr_type) {
	v__ast__CTempVar x = v__gen__c__Gen_new_ctemp_var(g, expr, expr_type);
	v__gen__c__Gen_gen_ctemp_var(g, x);
	v__ast__CTempVar _t1 = x;
	return _t1;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_ctemp_var(v__gen__c__Gen* g, v__ast__CTempVar tvar) {
	string styp = v__gen__c__Gen_typ(g, tvar.typ);
	v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = styp}}, {_SLIT(" "), 0xfe10, {.d_s = tvar.name}}, {_SLIT(" = "), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_expr(g, tvar.orig);
	v__gen__c__Gen_writeln(g, _SLIT(";"));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_dump_expr(v__gen__c__Gen* g, v__ast__DumpExpr node) {
	string sexpr = v__gen__c__ctoslit(v__ast__Expr_str(node.expr));
	string fpath = v__gen__c__cestring(g->file->path);
	int line = node.pos.line_nr + 1;
	if (Array_string_contains(g->pref->compile_defines, _SLIT("nop_dump"))) {
		v__gen__c__Gen_expr(g, node.expr);
		return;
	}
	string dump_fn_name = string__plus( str_intp(2, _MOV((StrIntpData[]){{_SLIT("_v_dump_expr_"), 0xfe10, {.d_s = node.cname}}, {_SLIT0, 0, { .d_c = 0 }}})), ((v__ast__Type_is_ptr(node.expr_type) ? (_SLIT("_ptr")) : (_SLIT("")))));
	v__gen__c__Gen_write(g,  str_intp(5, _MOV((StrIntpData[]){{_SLIT(" "), 0xfe10, {.d_s = dump_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = v__gen__c__ctoslit(fpath)}}, {_SLIT(", "), 0xfe07, {.d_i32 = line}}, {_SLIT(", "), 0xfe10, {.d_s = sexpr}}, {_SLIT(", "), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_expr(g, node.expr);
	v__gen__c__Gen_write(g, _SLIT(" )"));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_dump_expr_definitions(v__gen__c__Gen* g) {
	Map_string_bool dump_typedefs = new_map(sizeof(string), sizeof(bool), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
	strings__Builder dump_fns = strings__new_builder(100);
	Map_int_string _t1 = g->table->dumps;
	int _t3 = _t1.key_values.len;
	for (int _t2 = 0; _t2 < _t3; ++_t2 ) {
		int _t4 = _t1.key_values.len - _t3;
		_t3 = _t1.key_values.len;
		if (_t4 < 0) {
			_t2 = -1;
			continue;
		}
		if (!DenseArray_has_index(&_t1.key_values, _t2)) {continue;}
		int dump_type = /*key*/ *(int*)DenseArray_key(&_t1.key_values, _t2);
		string cname = (*(string*)DenseArray_value(&_t1.key_values, _t2));
		v__ast__TypeSymbol* dump_sym = v__ast__Table_sym(g->table, dump_type);
		multi_return_bool_bool_int mr_702 = v__ast__TypeSymbol_str_method_info(dump_sym);
		bool str_method_expects_ptr = mr_702.arg1;
		bool is_ptr = v__ast__Type_is_ptr(((dump_type)));
		multi_return_string_string mr_784 = v__gen__c__deref_kind(str_method_expects_ptr, is_ptr, dump_type);
		string deref = mr_784.arg0;
		string to_string_fn_name = v__gen__c__Gen_get_str_fn(g, dump_type);
		string ptr_asterisk = (is_ptr ? (_SLIT("*")) : (_SLIT("")));
		string str_dumparg_type =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = cname}}, {_SLIT0, 0xfe10, {.d_s = ptr_asterisk}}, {_SLIT0, 0, { .d_c = 0 }}}));
		if (dump_sym->kind == v__ast__Kind__function) {
			v__ast__FnType fninfo = /* as */ *(v__ast__FnType*)__as_cast((dump_sym->info)._v__ast__FnType,(dump_sym->info)._typ, 472) /*expected idx: 472, name: v.ast.FnType */ ;
			str_dumparg_type =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("DumpFNType_"), 0xfe10, {.d_s = cname}}, {_SLIT0, 0, { .d_c = 0 }}}));
			int tdef_pos = g->out.len;
			v__gen__c__Gen_write_fn_ptr_decl(g, &fninfo, str_dumparg_type);
			string str_tdef = strings__Builder_after(&g->out, tdef_pos);
			strings__Builder_go_back(&g->out, str_tdef.len);
			map_set(&dump_typedefs, &(string[]){ str_intp(2, _MOV((StrIntpData[]){{_SLIT("typedef "), 0xfe10, {.d_s = str_tdef}}, {_SLIT(";"), 0, { .d_c = 0 }}}))}, &(bool[]) { true });
		}
		string dump_fn_name = string__plus( str_intp(2, _MOV((StrIntpData[]){{_SLIT("_v_dump_expr_"), 0xfe10, {.d_s = cname}}, {_SLIT0, 0, { .d_c = 0 }}})), ((is_ptr ? (_SLIT("_ptr")) : (_SLIT("")))));
		if (v__gen__c__Gen_writeln_fn_header(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = str_dumparg_type}}, {_SLIT(" "), 0xfe10, {.d_s = dump_fn_name}}, {_SLIT("(string fpath, int line, string sexpr, "), 0xfe10, {.d_s = str_dumparg_type}}, {_SLIT(" dump_arg)"), 0, { .d_c = 0 }}})), (voidptr)&/*qq*/dump_fns)) {
			continue;
		}
		v__util__Surrounder surrounder = v__util__new_surrounder(3);
		v__util__Surrounder_add(&surrounder, _SLIT("\tstring sline = int_str(line);"), _SLIT("\tstring_free(&sline);"));
		v__util__Surrounder_add(&surrounder,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\tstring value = "), 0xfe10, {.d_s = to_string_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = deref}}, {_SLIT("dump_arg);"), 0, { .d_c = 0 }}})), _SLIT("\tstring_free(&value);"));
		v__util__Surrounder_add(&surrounder, _SLIT("\n	strings__Builder sb = strings__new_builder(256);\n"), _SLIT("\n	string res;\n	res = strings__Builder_str(&sb);\n	eprint(res);\n	string_free(&res);\n	strings__Builder_free(&sb);\n"));
		v__util__Surrounder_builder_write_befores(&surrounder, (voidptr)&/*qq*/dump_fns);
		strings__Builder_writeln(&dump_fns, _SLIT("\tstrings__Builder_write_rune(&sb, '[');"));
		strings__Builder_writeln(&dump_fns, _SLIT("\tstrings__Builder_write_string(&sb, fpath);"));
		strings__Builder_writeln(&dump_fns, _SLIT("\tstrings__Builder_write_rune(&sb, ':');"));
		strings__Builder_writeln(&dump_fns, _SLIT("\tstrings__Builder_write_string(&sb, sline);"));
		strings__Builder_writeln(&dump_fns, _SLIT("\tstrings__Builder_write_rune(&sb, ']');"));
		strings__Builder_writeln(&dump_fns, _SLIT("\tstrings__Builder_write_rune(&sb, ' ');"));
		strings__Builder_writeln(&dump_fns, _SLIT("\tstrings__Builder_write_string(&sb, sexpr);"));
		strings__Builder_writeln(&dump_fns, _SLIT("\tstrings__Builder_write_rune(&sb, ':');"));
		strings__Builder_writeln(&dump_fns, _SLIT("\tstrings__Builder_write_rune(&sb, ' ');"));
		if (is_ptr) {
			strings__Builder_writeln(&dump_fns, _SLIT("\tstrings__Builder_write_rune(&sb, '&');"));
		}
		strings__Builder_writeln(&dump_fns, _SLIT("\tstrings__Builder_write_string(&sb, value);"));
		strings__Builder_writeln(&dump_fns, _SLIT("\tstrings__Builder_write_rune(&sb, '\\n');"));
		v__util__Surrounder_builder_write_afters(&surrounder, (voidptr)&/*qq*/dump_fns);
		strings__Builder_writeln(&dump_fns, _SLIT("\treturn dump_arg;"));
		strings__Builder_writeln(&dump_fns, _SLIT("}"));
	}
	int _t6 = dump_typedefs.key_values.len;
	for (int _t5 = 0; _t5 < _t6; ++_t5 ) {
		int _t7 = dump_typedefs.key_values.len - _t6;
		_t6 = dump_typedefs.key_values.len;
		if (_t7 < 0) {
			_t5 = -1;
			continue;
		}
		if (!DenseArray_has_index(&dump_typedefs.key_values, _t5)) {continue;}
		string tdef = /*key*/ *(string*)DenseArray_key(&dump_typedefs.key_values, _t5);
		tdef = string_clone(tdef);
		strings__Builder_writeln(&g->definitions, tdef);
	}
	string defs = strings__Builder_str(&dump_fns);
	strings__Builder_writeln(&g->definitions, defs);
}

VV_LOCAL_SYMBOL bool v__gen__c__Gen_writeln_fn_header(v__gen__c__Gen* g, string s, strings__Builder* sb) {
	if (g->pref->build_mode == v__pref__BuildMode__build_module) {
		strings__Builder_writeln(sb,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = s}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
		bool _t1 = true;
		return _t1;
	}
	strings__Builder_writeln(sb,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = s}}, {_SLIT(" {"), 0, { .d_c = 0 }}})));
	bool _t2 = false;
	return _t2;
}

VV_LOCAL_SYMBOL bool v__gen__c__Gen_embed_file_is_prod_mode(v__gen__c__Gen* g) {
	if (g->pref->is_prod || Array_string_contains(g->pref->compile_defines, _SLIT("debug_embed_file_in_prod"))) {
		bool _t1 = true;
		return _t1;
	}
	bool _t2 = false;
	return _t2;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_embed_file_init(v__gen__c__Gen* g, v__ast__ComptimeCall* node) {
	if (v__gen__c__Gen_embed_file_is_prod_mode(g)) {
		Option_Array_byte _t1 = os__read_bytes(node->embed_file.apath);
		if (_t1.state != 0) { /*or block*/ 
			IError err = _t1.err;
			_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("unable to read file: \""), 0xfe10, {.d_s = node->embed_file.rpath}}, {_SLIT0, 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		;
		}
		
 		Array_byte file_bytes =  (*(Array_byte*)_t1.data);
		if (string__eq(node->embed_file.compression_type, _SLIT("none"))) {
			node->embed_file.bytes = file_bytes;
		} else {
			string cache_dir = os__join_path(os__vmodules_dir(), new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT("cache"), _SLIT("embed_file")})));
			string cache_key = rand__ulid();
			if (!os__exists(cache_dir)) {
				Option_void _t2 = os__mkdir_all(cache_dir);
				if (_t2.state != 0 && _t2.err._typ != _IError_None___index) {
					IError err = _t2.err;
					_v_panic(IError_str(err));
					VUNREACHABLE();
				;
				}
				
 ;
			}
			string cache_path = os__join_path(cache_dir, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){cache_key})));
			string vexe = v__pref__vexe_path();
			os__Result result = os__execute( str_intp(5, _MOV((StrIntpData[]){{_SLIT("\""), 0xfe10, {.d_s = vexe}}, {_SLIT("\" compress "), 0xfe10, {.d_s = node->embed_file.compression_type}}, {_SLIT(" \""), 0xfe10, {.d_s = node->embed_file.apath}}, {_SLIT("\" \""), 0xfe10, {.d_s = cache_path}}, {_SLIT("\""), 0, { .d_c = 0 }}})));
			if (result.exit_code != 0) {
				eprintln( str_intp(3, _MOV((StrIntpData[]){{_SLIT("unable to compress file \""), 0xfe10, {.d_s = node->embed_file.rpath}}, {_SLIT("\": "), 0xfe10, {.d_s = result.output}}, {_SLIT0, 0, { .d_c = 0 }}})));
				node->embed_file.bytes = file_bytes;
			} else {
				Option_Array_byte _t3 = os__read_bytes(cache_path);
				if (_t3.state != 0) { /*or block*/ 
					IError err = _t3.err;
					eprintln(_SLIT("unable to read compressed file"));
					{
					}
					*(Array_byte*) _t3.data = __new_array_with_default(0, 0, sizeof(byte), 0);
				}
				
 				Array_byte compressed_bytes =  (*(Array_byte*)_t3.data);
				Option_void _t4 = os__rm(cache_path);
				if (_t4.state != 0 && _t4.err._typ != _IError_None___index) {
					IError err = _t4.err;
				}
				
 ;
				node->embed_file.is_compressed = compressed_bytes.len > 0 && compressed_bytes.len < file_bytes.len;
				node->embed_file.bytes = (node->embed_file.is_compressed ? (compressed_bytes) : (file_bytes));
			}
		}
		if (node->embed_file.bytes.len > 5242880) {
			eprintln(_SLIT("embedding of files >= ~5MB is currently not well supported"));
		}
		node->embed_file.len = file_bytes.len;
	}
	v__gen__c__Gen_writeln(g, _SLIT("(v__embed_file__EmbedFileData){"));
	v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\t.path = "), 0xfe10, {.d_s = v__gen__c__ctoslit(node->embed_file.rpath)}}, {_SLIT(","), 0, { .d_c = 0 }}})));
	if (v__gen__c__Gen_embed_file_is_prod_mode(g)) {
		v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\t.apath = "), 0xfe10, {.d_s = v__gen__c__ctoslit(_SLIT(""))}}, {_SLIT(","), 0, { .d_c = 0 }}})));
	} else {
		v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\t.apath = "), 0xfe10, {.d_s = v__gen__c__ctoslit(node->embed_file.apath)}}, {_SLIT(","), 0, { .d_c = 0 }}})));
	}
	if (v__gen__c__Gen_embed_file_is_prod_mode(g)) {
		if (node->embed_file.is_compressed) {
			v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\t.compression_type = "), 0xfe10, {.d_s = v__gen__c__ctoslit(node->embed_file.compression_type)}}, {_SLIT(","), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\t.compressed = v__embed_file__find_index_entry_by_path((voidptr)_v_embed_file_index, "), 0xfe10, {.d_s = v__gen__c__ctoslit(node->embed_file.rpath)}}, {_SLIT(", "), 0xfe10, {.d_s = v__gen__c__ctoslit(node->embed_file.compression_type)}}, {_SLIT(")->data,"), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_writeln(g, _SLIT("\t\t.uncompressed = NULL,"));
		} else {
			v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\t.uncompressed = v__embed_file__find_index_entry_by_path((voidptr)_v_embed_file_index, "), 0xfe10, {.d_s = v__gen__c__ctoslit(node->embed_file.rpath)}}, {_SLIT(", "), 0xfe10, {.d_s = v__gen__c__ctoslit(node->embed_file.compression_type)}}, {_SLIT(")->data,"), 0, { .d_c = 0 }}})));
		}
	} else {
		v__gen__c__Gen_writeln(g, _SLIT("\t\t.uncompressed = NULL,"));
	}
	v__gen__c__Gen_writeln(g, _SLIT("\t\t.free_compressed = 0,"));
	v__gen__c__Gen_writeln(g, _SLIT("\t\t.free_uncompressed = 0,"));
	if (v__gen__c__Gen_embed_file_is_prod_mode(g)) {
		v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\t.len = "), 0xfe07, {.d_i32 = node->embed_file.len}}, {_SLIT0, 0, { .d_c = 0 }}})));
	} else {
		u64 file_size = os__file_size(node->embed_file.apath);
		if (file_size > 5242880U) {
			eprintln(_SLIT("Warning: embedding of files >= ~5MB is currently not supported"));
		}
		v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\t.len = "), 0xfe08, {.d_u64 = file_size}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
	v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("} // $embed_file(\""), 0xfe10, {.d_s = node->embed_file.apath}}, {_SLIT("\")"), 0, { .d_c = 0 }}})));
	array_push((array*)&g->file->embedded_files, _MOV((v__ast__EmbeddedFile[]){ node->embed_file }));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_embedded_data(v__gen__c__Gen* g) {
	for (int i = 0; i < g->embedded_files.len; ++i) {
		v__ast__EmbeddedFile emfile = ((v__ast__EmbeddedFile*)g->embedded_files.data)[i];
		strings__Builder_write_string(&g->embedded_data,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("static const unsigned char _v_embed_blob_"), 0xfe07, {.d_i32 = i}}, {_SLIT("["), 0xfe07, {.d_i32 = emfile.bytes.len}}, {_SLIT("] = {\n    "), 0, { .d_c = 0 }}})));
		for (int j = 0; j < emfile.bytes.len; j++) {
			string b = byte_hex((*(byte*)/*ee elem_typ */array_get(emfile.bytes, j)));
			if (j < emfile.bytes.len - 1) {
				strings__Builder_write_string(&g->embedded_data,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("0x"), 0xfe10, {.d_s = b}}, {_SLIT(","), 0, { .d_c = 0 }}})));
			} else {
				strings__Builder_write_string(&g->embedded_data,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("0x"), 0xfe10, {.d_s = b}}, {_SLIT0, 0, { .d_c = 0 }}})));
			}
			if (0 == ((j + 1) % 16)) {
				strings__Builder_write_string(&g->embedded_data, _SLIT("\n    "));
			}
		}
		strings__Builder_writeln(&g->embedded_data, _SLIT("\n};"));
	}
	strings__Builder_writeln(&g->embedded_data, _SLIT(""));
	strings__Builder_writeln(&g->embedded_data, _SLIT("const v__embed_file__EmbedFileIndexEntry _v_embed_file_index[] = {"));
	for (int i = 0; i < g->embedded_files.len; ++i) {
		v__ast__EmbeddedFile emfile = ((v__ast__EmbeddedFile*)g->embedded_files.data)[i];
		strings__Builder_writeln(&g->embedded_data,  str_intp(7, _MOV((StrIntpData[]){{_SLIT("\t{"), 0xfe07, {.d_i32 = i}}, {_SLIT(", { .str=(byteptr)(\""), 0xfe10, {.d_s = v__gen__c__cestring(emfile.rpath)}}, {_SLIT("\"), .len="), 0xfe07, {.d_i32 = emfile.rpath.len}}, {_SLIT(", .is_lit=1 }, { .str=(byteptr)(\""), 0xfe10, {.d_s = v__gen__c__cestring(emfile.compression_type)}}, {_SLIT("\"), .len="), 0xfe07, {.d_i32 = emfile.compression_type.len}}, {_SLIT(", .is_lit=1 }, _v_embed_blob_"), 0xfe07, {.d_i32 = i}}, {_SLIT("},"), 0, { .d_c = 0 }}})));
	}
	strings__Builder_writeln(&g->embedded_data, _SLIT("\t{-1, { .str=(byteptr)(\"\"), .len=0, .is_lit=1 }, { .str=(byteptr)(\"\"), .len=0, .is_lit=1 }, NULL}"));
	strings__Builder_writeln(&g->embedded_data, _SLIT("};"));
}

VV_LOCAL_SYMBOL bool v__gen__c__Gen_is_used_by_main(v__gen__c__Gen* g, v__ast__FnDecl node) {
	bool is_used_by_main = true;
	if (g->pref->skip_unused) {
		string fkey = v__ast__FnDecl_fkey(&node);
		is_used_by_main = (*(bool*)map_get(ADDR(map, g->table->used_fns), &(string[]){fkey}, &(bool[]){ 0 }));
		if (!is_used_by_main) {
		}
	} else {
	}
	bool _t1 = is_used_by_main;
	return _t1;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_fn_decl(v__gen__c__Gen* g, v__ast__FnDecl node) {
	if (node.should_be_skipped) {
		return;
	}
	if (node.ninstances == 0 && node.generic_names.len > 0) {
		return;
	}
	if (!v__gen__c__Gen_is_used_by_main(g, node)) {
		return;
	}
	if (g->is_builtin_mod && g->pref->gc_mode == v__pref__GarbageCollectionMode__boehm_leak && string__eq(node.name, _SLIT("malloc"))) {
		strings__Builder_write_string(&g->definitions, _SLIT("#define _v_malloc GC_MALLOC\n"));
		return;
	}
	v__gen__c__Gen_gen_attrs(g, node.attrs);
	bool skip = false;
	int pos = g->out.len;
	bool should_bundle_module = v__util__should_bundle_module(node.mod);
	if (g->pref->build_mode == v__pref__BuildMode__build_module) {
		string mod = (g->is_builtin_mod ? (_SLIT("builtin")) : (string_all_before_last(node.name, _SLIT("."))));
		if ((!string__eq(mod, g->module_built) && !string__eq(node.mod, string_after(g->module_built, _SLIT("/")))) || should_bundle_module) {
			skip = true;
		}
		if (g->is_builtin_mod && string__eq(g->module_built, _SLIT("builtin")) && string__eq(node.mod, _SLIT("builtin"))) {
			skip = false;
		}
		if (!skip && g->pref->is_verbose) {
			println( str_intp(3, _MOV((StrIntpData[]){{_SLIT("build module `"), 0xfe10, {.d_s = g->module_built}}, {_SLIT("` fn `"), 0xfe10, {.d_s = node.name}}, {_SLIT("`"), 0, { .d_c = 0 }}})));
		}
	}
	if (g->pref->use_cache) {
		if (!string__eq(node.mod, _SLIT("main")) && !string__eq(node.mod, _SLIT("help")) && !should_bundle_module && !g->pref->is_test && node.generic_names.len == 0) {
			skip = true;
		}
	}
	v__ast__FnDecl* keep_fn_decl = g->fn_decl;
	{ // Unsafe block
		g->fn_decl = &node;
	}
	if (node.is_main) {
		g->has_main = true;
	}
	bool is_backtrace = string_starts_with(node.name, _SLIT("backtrace")) && (string__eq(node.name, _SLIT("backtrace_symbols")) || string__eq(node.name, _SLIT("backtrace")) || string__eq(node.name, _SLIT("backtrace_symbols_fd")));
	if (is_backtrace) {
		v__gen__c__Gen_write(g, _SLIT("\n#ifndef __cplusplus\n"));
	}
	v__gen__c__Gen_gen_fn_decl(g, (voidptr)&/*qq*/node, skip);
	if (is_backtrace) {
		v__gen__c__Gen_write(g, _SLIT("\n#endif\n"));
	}
	g->fn_decl = keep_fn_decl;
	if (skip) {
		strings__Builder_go_back_to(&g->out, pos);
	}
	if (!g->pref->skip_unused) {
		if (node.language != v__ast__Language__c) {
			v__gen__c__Gen_writeln(g, _SLIT(""));
		}
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_fn_decl(v__gen__c__Gen* g, v__ast__FnDecl* node, bool skip) {
bool v__gen__c__Gen_gen_fn_decl_defer_0 = false;
bool old_is_vlines_enabled;
bool v__gen__c__Gen_gen_fn_decl_defer_1 = false;
Array_string tmp_defer_vars;
bool v__gen__c__Gen_gen_fn_decl_defer_2 = false;
bool old_g_autofree;
bool v__gen__c__Gen_gen_fn_decl_defer_3 = false;
v__ast__FnDecl* cur_fn_save;
bool v__gen__c__Gen_gen_fn_decl_defer_4 = false;
string last_fn_c_name_save;
bool v__gen__c__Gen_gen_fn_decl_defer_5 = false;
int ctmp;
	if (node->language == v__ast__Language__c) {
		return;
	}
	old_is_vlines_enabled = g->is_vlines_enabled;
	g->is_vlines_enabled = true;
	v__gen__c__Gen_gen_fn_decl_defer_0 = true;
	tmp_defer_vars = g->defer_vars;
	if (!g->anon_fn) {
		g->defer_vars = __new_array_with_default(0, 0, sizeof(string), 0);
	} else {
		if (node->defer_stmts.len > 0) {
			g->defer_vars = __new_array_with_default(0, 0, sizeof(string), 0);
			v__gen__c__Gen_gen_fn_decl_defer_1 = true;
		}
	}
	g->returned_var_name = _SLIT("");
	old_g_autofree = g->is_autofree;
	if (node->is_manualfree) {
		g->is_autofree = false;
	}
	v__gen__c__Gen_gen_fn_decl_defer_2 = true;
	if (node->generic_names.len > 0 && g->cur_concrete_types.len == 0) {
		string nkey = v__ast__FnDecl_fkey(node);
		Array_Array_v__ast__Type generic_types_by_fn = (*(Array_Array_v__ast__Type*)map_get(ADDR(map, g->table->fn_generic_types), &(string[]){nkey}, &(Array_Array_v__ast__Type[]){ __new_array(0, 0, sizeof(Array_v__ast__Type)) }));
		for (int _t1 = 0; _t1 < generic_types_by_fn.len; ++_t1) {
			Array_v__ast__Type concrete_types = ((Array_v__ast__Type*)generic_types_by_fn.data)[_t1];
			if (g->pref->is_verbose) {
				Array_v__ast__TypeSymbol_ptr _t2 = __new_array(0, 0, sizeof(v__ast__TypeSymbol*));
				Array_v__ast__Type _t2_orig = concrete_types;
				int _t2_len = _t2_orig.len;
				_t2 = __new_array(0, _t2_len, sizeof(v__ast__TypeSymbol*));

				for (int _t3 = 0; _t3 < _t2_len; ++_t3) {
					v__ast__Type it = ((v__ast__Type*) _t2_orig.data)[_t3];
					v__ast__TypeSymbol* ti = v__ast__Table_sym(g->table, it);
					array_push((array*)&_t2, &ti);
				}
				Array_v__ast__TypeSymbol_ptr syms =_t2;
				Array_string _t4 = __new_array(0, 0, sizeof(string));
				Array_v__ast__TypeSymbol_ptr _t4_orig = syms;
				int _t4_len = _t4_orig.len;
				_t4 = __new_array(0, _t4_len, sizeof(string));

				for (int _t5 = 0; _t5 < _t4_len; ++_t5) {
					v__ast__TypeSymbol* it = ((v__ast__TypeSymbol**) _t4_orig.data)[_t5];
					string ti = it->name;
					array_push((array*)&_t4, &ti);
				}
				string the_type = Array_string_join(_t4, _SLIT(", "));
				println( str_intp(3, _MOV((StrIntpData[]){{_SLIT("gen fn `"), 0xfe10, {.d_s = node->name}}, {_SLIT("` for type `"), 0xfe10, {.d_s = the_type}}, {_SLIT("`"), 0, { .d_c = 0 }}})));
			}
			g->cur_concrete_types = concrete_types;
			v__gen__c__Gen_gen_fn_decl(g, node, skip);
		}
		g->cur_concrete_types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
		// Defer begin
		if (v__gen__c__Gen_gen_fn_decl_defer_2) {
			g->is_autofree = old_g_autofree;
		}
		// Defer end
		// Defer begin
		if (v__gen__c__Gen_gen_fn_decl_defer_1) {
			g->defer_vars = tmp_defer_vars;
		}
		// Defer end
		// Defer begin
		if (v__gen__c__Gen_gen_fn_decl_defer_0) {
			g->is_vlines_enabled = old_is_vlines_enabled;
		}
		// Defer end
		return;
	}
	cur_fn_save = g->cur_fn;
	v__gen__c__Gen_gen_fn_decl_defer_3 = true;
	{ // Unsafe block
		g->cur_fn = node;
	}
	int fn_start_pos = g->out.len;
	bool is_closure = v__ast__Scope_has_inherited_vars(node->scope);
	string cur_closure_ctx = _SLIT("");
	if (is_closure) {
		cur_closure_ctx = v__gen__c__closure_ctx_struct(*node);
		strings__Builder_write_string(&g->definitions, cur_closure_ctx);
		strings__Builder_writeln(&g->definitions, _SLIT(";"));
	}
	v__gen__c__Gen_write_v_source_line_info(g, node->pos);
	string fn_attrs = v__gen__c__Gen_write_fn_attrs(g, node->attrs);
	bool is_livefn = Array_v__ast__Attr_contains(node->attrs, _SLIT("live"));
	bool is_livemain = g->pref->is_livemain && is_livefn;
	bool is_liveshared = g->pref->is_liveshared && is_livefn;
	bool is_livemode = g->pref->is_livemain || g->pref->is_liveshared;
	bool is_live_wrap = is_livefn && is_livemode;
	if (is_livefn && !is_livemode) {
		eprintln( str_intp(3, _MOV((StrIntpData[]){{_SLIT("INFO: compile with `v -live "), 0xfe10, {.d_s = g->pref->path}}, {_SLIT(" `, if you want to use the [live] function "), 0xfe10, {.d_s = node->name}}, {_SLIT(" ."), 0, { .d_c = 0 }}})));
	}
	string name = node->name;
	if (string__eq(name, _SLIT("+")) || string__eq(name, _SLIT("-")) || string__eq(name, _SLIT("*")) || string__eq(name, _SLIT("/")) || string__eq(name, _SLIT("%")) || string__eq(name, _SLIT("<")) || string__eq(name, _SLIT("=="))) {
		name = v__util__replace_op(name);
	}
	if (node->is_method) {
		v__ast__TypeSymbol* unwrapped_rec_sym = v__ast__Table_sym(g->table, v__gen__c__Gen_unwrap_generic(g, node->receiver.typ));
		if (unwrapped_rec_sym->kind == v__ast__Kind__placeholder) {
			// Defer begin
			if (v__gen__c__Gen_gen_fn_decl_defer_3) {
				g->cur_fn = cur_fn_save;
			}
			// Defer end
			// Defer begin
			if (v__gen__c__Gen_gen_fn_decl_defer_2) {
				g->is_autofree = old_g_autofree;
			}
			// Defer end
			// Defer begin
			if (v__gen__c__Gen_gen_fn_decl_defer_1) {
				g->defer_vars = tmp_defer_vars;
			}
			// Defer end
			// Defer begin
			if (v__gen__c__Gen_gen_fn_decl_defer_0) {
				g->is_vlines_enabled = old_is_vlines_enabled;
			}
			// Defer end
			return;
		}
		name = string__plus(string__plus(v__gen__c__Gen_cc_type(g, node->receiver.typ, false), _SLIT("_")), name);
	}
	if (node->language == v__ast__Language__c) {
		name = v__util__no_dots(name);
	} else {
		name = v__gen__c__c_name(name);
	}
	string type_name = v__gen__c__Gen_typ(g, node->return_type);
	if (node->generic_names.len > 0) {
		name = v__gen__c__Gen_generic_fn_name(g, g->cur_concrete_types, name, true);
	}
	if (g->pref->translated && Array_v__ast__Attr_contains(node->attrs, _SLIT("c"))) {
		name = (*(v__ast__Attr*)/*ee elem_typ */array_get(node->attrs, 0)).arg;
	}
	if (g->pref->obfuscate && string__eq(g->cur_mod.name, _SLIT("main")) && string_starts_with(name, _SLIT("main__")) && !node->is_main && !string__eq(node->name, _SLIT("str"))) {
		string key = node->name;
		if (node->is_method) {
			v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, node->receiver.typ);
			key = string__plus(string__plus(sym->name, _SLIT(".")), node->name);
		}
		v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("/* obf: "), 0xfe10, {.d_s = key}}, {_SLIT(" */"), 0, { .d_c = 0 }}})));
		string* _t7 = (string*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, g->obf_table), &(string[]){key}));
		Option_string _t6 = {0};
		if (_t7) {
			*((string*)&_t6.data) = *((string*)_t7);
		} else {
			_t6.state = 2; _t6.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t6.state != 0) { /*or block*/ 
			IError err = _t6.err;
			_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("cgen: fn_decl: obf name \""), 0xfe10, {.d_s = key}}, {_SLIT("\" not found, this should never happen"), 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		;
		}
		
		name = *(string*)_t6.data;
	}
	if (is_livemain) {
		array_push((array*)&g->hotcode_fn_names, _MOV((string[]){ string_clone(name) }));
	}
	string impl_fn_name = name;
	if (is_live_wrap) {
		impl_fn_name =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("impl_live_"), 0xfe10, {.d_s = name}}, {_SLIT0, 0, { .d_c = 0 }}}));
	}
	last_fn_c_name_save = g->last_fn_c_name;
	v__gen__c__Gen_gen_fn_decl_defer_4 = true;
	g->last_fn_c_name = impl_fn_name;
	if (is_live_wrap) {
		if (is_livemain) {
			strings__Builder_write_string(&g->definitions,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = type_name}}, {_SLIT(" (* "), 0xfe10, {.d_s = impl_fn_name}}, {_SLIT(")("), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = type_name}}, {_SLIT(" no_impl_"), 0xfe10, {.d_s = name}}, {_SLIT("("), 0, { .d_c = 0 }}})));
		}
		if (is_liveshared) {
			strings__Builder_write_string(&g->definitions,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = type_name}}, {_SLIT(" "), 0xfe10, {.d_s = impl_fn_name}}, {_SLIT("("), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = type_name}}, {_SLIT(" "), 0xfe10, {.d_s = impl_fn_name}}, {_SLIT("("), 0, { .d_c = 0 }}})));
		}
	} else {
		if (!(node->is_pub || g->pref->is_debug)) {
			if (g->pref->build_mode != v__pref__BuildMode__build_module && !g->pref->use_cache) {
				v__gen__c__Gen_write(g, _SLIT("VV_LOCAL_SYMBOL "));
				strings__Builder_write_string(&g->definitions, _SLIT("VV_LOCAL_SYMBOL "));
			}
		}
		string fn_header =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = type_name}}, {_SLIT(" "), 0xfe10, {.d_s = fn_attrs}}, {_SLIT0, 0xfe10, {.d_s = name}}, {_SLIT("("), 0, { .d_c = 0 }}}));
		strings__Builder_write_string(&g->definitions, fn_header);
		v__gen__c__Gen_write(g, fn_header);
	}
	int arg_start_pos = g->out.len;
	multi_return_Array_string_Array_string_Array_bool mr_9044 = v__gen__c__Gen_fn_args(g, node->params, node->scope);
	Array_string fargs = mr_9044.arg0;
	Array_string fargtypes = mr_9044.arg1;
	Array_bool heap_promoted = mr_9044.arg2;
	if (is_closure) {
		string s =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = cur_closure_ctx}}, {_SLIT(" *"), 0xfe10, {.d_s = _const_v__gen__c__closure_ctx}}, {_SLIT0, 0, { .d_c = 0 }}}));
		if (node->params.len > 0) {
			s = string__plus(_SLIT(", "), s);
		} else {
			strings__Builder_cut_to(&g->out, arg_start_pos);
		}
		strings__Builder_write_string(&g->definitions, s);
		v__gen__c__Gen_write(g, s);
		g->nr_closures++;
	}
	string arg_str = strings__Builder_after(&g->out, arg_start_pos);
	if (node->no_body || ((g->pref->use_cache && g->pref->build_mode != v__pref__BuildMode__build_module) && node->is_builtin && !g->pref->is_test) || skip) {
		strings__Builder_writeln(&g->definitions, _SLIT(");"));
		v__gen__c__Gen_writeln(g, _SLIT(");"));
		// Defer begin
		if (v__gen__c__Gen_gen_fn_decl_defer_4) {
			g->last_fn_c_name = last_fn_c_name_save;
		}
		// Defer end
		// Defer begin
		if (v__gen__c__Gen_gen_fn_decl_defer_3) {
			g->cur_fn = cur_fn_save;
		}
		// Defer end
		// Defer begin
		if (v__gen__c__Gen_gen_fn_decl_defer_2) {
			g->is_autofree = old_g_autofree;
		}
		// Defer end
		// Defer begin
		if (v__gen__c__Gen_gen_fn_decl_defer_1) {
			g->defer_vars = tmp_defer_vars;
		}
		// Defer end
		// Defer begin
		if (v__gen__c__Gen_gen_fn_decl_defer_0) {
			g->is_vlines_enabled = old_is_vlines_enabled;
		}
		// Defer end
		return;
	}
	if (node->params.len == 0) {
		strings__Builder_write_string(&g->definitions, _SLIT("void"));
	}
	strings__Builder_writeln(&g->definitions, _SLIT(");"));
	v__gen__c__Gen_writeln(g, _SLIT(") {"));
	for (int i = 0; i < heap_promoted.len; ++i) {
		bool is_promoted = ((bool*)heap_promoted.data)[i];
		if (is_promoted) {
			v__gen__c__Gen_writeln(g,  str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = (*(string*)/*ee elem_typ */array_get(fargtypes, i))}}, {_SLIT("* "), 0xfe10, {.d_s = (*(string*)/*ee elem_typ */array_get(fargs, i))}}, {_SLIT(" = HEAP("), 0xfe10, {.d_s = (*(string*)/*ee elem_typ */array_get(fargtypes, i))}}, {_SLIT(", _v_toheap_"), 0xfe10, {.d_s = (*(string*)/*ee elem_typ */array_get(fargs, i))}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
		}
	}
	for (int _t9 = 0; _t9 < node->defer_stmts.len; ++_t9) {
		v__ast__DeferStmt defer_stmt = ((v__ast__DeferStmt*)node->defer_stmts.data)[_t9];
		v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("bool "), 0xfe10, {.d_s = v__gen__c__Gen_defer_flag_var(g, (voidptr)&/*qq*/defer_stmt)}}, {_SLIT(" = false;"), 0, { .d_c = 0 }}})));
		for (int _t10 = 0; _t10 < defer_stmt.defer_vars.len; ++_t10) {
			v__ast__Ident var = ((v__ast__Ident*)defer_stmt.defer_vars.data)[_t10];
			if (Array_string_contains(fargs, var.name) || var.kind == v__ast__IdentKind__constant) {
				continue;
			}
			if (var.kind == v__ast__IdentKind__variable) {
				if (!Array_string_contains(g->defer_vars, var.name)) {
					array_push((array*)&g->defer_vars, _MOV((string[]){ string_clone(var.name) }));
					string deref = _SLIT("");
					Option_v__ast__Var_ptr _t12;
					if (_t12 = v__ast__Scope_find_var(var.scope, var.name), _t12.state == 0) {
						v__ast__Var* v = *(v__ast__Var**)_t12.data;
						if (v->is_auto_heap) {
							deref = _SLIT("*");
						}
					}
					v__ast__Var info = /* as */ *(v__ast__Var*)__as_cast((var.obj)._v__ast__Var,(var.obj)._typ, 357) /*expected idx: 357, name: v.ast.Var */ ;
					if (v__ast__Table_sym(g->table, info.typ)->kind != v__ast__Kind__function) {
						v__gen__c__Gen_writeln(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__gen__c__Gen_typ(g, info.typ)}}, {_SLIT0, 0xfe10, {.d_s = deref}}, {_SLIT(" "), 0xfe10, {.d_s = var.name}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
					}
				}
			}
		}
	}
	if (is_live_wrap) {
		Array_string fn_args_list = __new_array_with_default(0, 0, sizeof(string), 0);
		for (int ia = 0; ia < fargs.len; ++ia) {
			string fa = ((string*)fargs.data)[ia];
			array_push((array*)&fn_args_list, _MOV((string[]){ string_clone( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = (*(string*)/*ee elem_typ */array_get(fargtypes, ia))}}, {_SLIT(" "), 0xfe10, {.d_s = fa}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
		}
		string live_fncall = string__plus(string__plus( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = impl_fn_name}}, {_SLIT("("), 0, { .d_c = 0 }}})), Array_string_join(fargs, _SLIT(", "))), _SLIT(");"));
		string live_fnreturn = _SLIT("");
		if (!string__eq(type_name, _SLIT("void"))) {
			live_fncall =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = type_name}}, {_SLIT(" res = "), 0xfe10, {.d_s = live_fncall}}, {_SLIT0, 0, { .d_c = 0 }}}));
			live_fnreturn = _SLIT("return res;");
		}
		strings__Builder_writeln(&g->definitions, string__plus(string__plus( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = type_name}}, {_SLIT(" "), 0xfe10, {.d_s = name}}, {_SLIT("("), 0, { .d_c = 0 }}})), Array_string_join(fn_args_list, _SLIT(", "))), _SLIT(");")));
		strings__Builder_writeln(&g->hotcode_definitions, string__plus(string__plus( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = type_name}}, {_SLIT(" "), 0xfe10, {.d_s = name}}, {_SLIT("("), 0, { .d_c = 0 }}})), Array_string_join(fn_args_list, _SLIT(", "))), _SLIT("){")));
		strings__Builder_writeln(&g->hotcode_definitions, _SLIT("  pthread_mutex_lock(&live_fn_mutex);"));
		strings__Builder_writeln(&g->hotcode_definitions,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("  "), 0xfe10, {.d_s = live_fncall}}, {_SLIT0, 0, { .d_c = 0 }}})));
		strings__Builder_writeln(&g->hotcode_definitions, _SLIT("  pthread_mutex_unlock(&live_fn_mutex);"));
		strings__Builder_writeln(&g->hotcode_definitions,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("  "), 0xfe10, {.d_s = live_fnreturn}}, {_SLIT0, 0, { .d_c = 0 }}})));
		strings__Builder_writeln(&g->hotcode_definitions, _SLIT("}"));
	}
	if (g->pref->is_prof && g->pref->build_mode != v__pref__BuildMode__build_module) {
		v__gen__c__Gen_profile_fn(g, *node);
	}
	Array_v__ast__DeferStmt prev_defer_stmts = g->defer_stmts;
	g->defer_stmts = __new_array_with_default(0, 0, sizeof(v__ast__DeferStmt), 0);
	ctmp = g->tmp_count;
	g->tmp_count = 0;
	v__gen__c__Gen_gen_fn_decl_defer_5 = true;
	v__gen__c__Gen_stmts(g, node->stmts);
	if (node->is_noreturn) {
		v__gen__c__Gen_writeln(g, _SLIT("\twhile(1);"));
	}
	if (!node->has_return) {
		v__gen__c__Gen_write_defer_stmts_when_needed(g);
	}
	if (node->is_anon) {
		g->defer_stmts = prev_defer_stmts;
	} else {
		g->defer_stmts = __new_array_with_default(0, 0, sizeof(v__ast__DeferStmt), 0);
	}
	if (!v__ast__Type_alias_eq(node->return_type, _const_v__ast__void_type) && node->stmts.len > 0 && ((*(v__ast__Stmt*)array_last(node->stmts)))._typ != 350 /* v.ast.Return */ && !Array_v__ast__Attr_contains(node->attrs, _SLIT("_naked"))) {
		string default_expr = v__gen__c__Gen_type_default(g, node->return_type);
		if (string__eq(default_expr, _SLIT("{0}"))) {
			v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\treturn ("), 0xfe10, {.d_s = type_name}}, {_SLIT(")"), 0xfe10, {.d_s = default_expr}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
		} else {
			v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\treturn "), 0xfe10, {.d_s = default_expr}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
		}
	}
	v__gen__c__Gen_writeln(g, _SLIT("}"));
	if (g->pref->printfn_list.len > 0 && Array_string_contains(g->pref->printfn_list, g->last_fn_c_name)) {
		println(strings__Builder_after(&g->out, fn_start_pos));
	}
	for (int _t14 = 0; _t14 < node->attrs.len; ++_t14) {
		v__ast__Attr attr = ((v__ast__Attr*)node->attrs.data)[_t14];
		if (string__eq(attr.name, _SLIT("export"))) {
			v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("// export alias: "), 0xfe10, {.d_s = attr.arg}}, {_SLIT(" -> "), 0xfe10, {.d_s = name}}, {_SLIT0, 0, { .d_c = 0 }}})));
			string export_alias =  str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = type_name}}, {_SLIT(" "), 0xfe10, {.d_s = fn_attrs}}, {_SLIT0, 0xfe10, {.d_s = attr.arg}}, {_SLIT("("), 0xfe10, {.d_s = arg_str}}, {_SLIT(")"), 0, { .d_c = 0 }}}));
			strings__Builder_writeln(&g->definitions,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("VV_EXPORTED_SYMBOL "), 0xfe10, {.d_s = export_alias}}, {_SLIT("; // exported fn "), 0xfe10, {.d_s = node->name}}, {_SLIT0, 0, { .d_c = 0 }}})));
			v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = export_alias}}, {_SLIT(" {"), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\treturn "), 0xfe10, {.d_s = name}}, {_SLIT("("), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_write(g, Array_string_join(fargs, _SLIT(", ")));
			v__gen__c__Gen_writeln(g, _SLIT(");"));
			v__gen__c__Gen_writeln(g, _SLIT("}"));
		}
	}
// Defer begin
if (v__gen__c__Gen_gen_fn_decl_defer_5) {
	g->tmp_count = ctmp;
}
// Defer end
// Defer begin
if (v__gen__c__Gen_gen_fn_decl_defer_4) {
	g->last_fn_c_name = last_fn_c_name_save;
}
// Defer end
// Defer begin
if (v__gen__c__Gen_gen_fn_decl_defer_3) {
	g->cur_fn = cur_fn_save;
}
// Defer end
// Defer begin
if (v__gen__c__Gen_gen_fn_decl_defer_2) {
	g->is_autofree = old_g_autofree;
}
// Defer end
// Defer begin
if (v__gen__c__Gen_gen_fn_decl_defer_1) {
	g->defer_vars = tmp_defer_vars;
}
// Defer end
// Defer begin
if (v__gen__c__Gen_gen_fn_decl_defer_0) {
	g->is_vlines_enabled = old_is_vlines_enabled;
}
// Defer end
}

VV_LOCAL_SYMBOL string v__gen__c__closure_ctx_struct(v__ast__FnDecl node) {
	string _t1 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("struct _V_"), 0xfe10, {.d_s = node.name}}, {_SLIT("_Ctx"), 0, { .d_c = 0 }}}));
	return _t1;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_anon_fn(v__gen__c__Gen* g, v__ast__AnonFn* node) {
	v__gen__c__Gen_gen_anon_fn_decl(g, node);
	if (!v__ast__Scope_has_inherited_vars(node->decl.scope)) {
		v__gen__c__Gen_write(g, node->decl.name);
		return;
	}
	string ctx_struct = v__gen__c__closure_ctx_struct(node->decl);
	strings__Builder size_sb = strings__new_builder(node->decl.params.len * 50);
	for (int _t1 = 0; _t1 < node->decl.params.len; ++_t1) {
		v__ast__Param param = ((v__ast__Param*)node->decl.params.data)[_t1];
		strings__Builder_write_string(&size_sb,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("_REG_WIDTH("), 0xfe10, {.d_s = v__gen__c__Gen_typ(g, param.typ)}}, {_SLIT(") + "), 0, { .d_c = 0 }}})));
	}
	if (g->pref->arch == v__pref__Arch__amd64 && !v__ast__Type_alias_eq(node->decl.return_type, _const_v__ast__void_type)) {
		strings__Builder_write_string(&size_sb,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("(_REG_WIDTH("), 0xfe10, {.d_s = v__gen__c__Gen_typ(g, node->decl.return_type)}}, {_SLIT(") > 2) + "), 0, { .d_c = 0 }}})));
	}
	strings__Builder_write_string(&size_sb, _SLIT("1"));
	string args_size = strings__Builder_str(&size_sb);
	v__gen__c__Gen_writeln(g, _SLIT(""));
	v__gen__c__Gen_write(g,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("__closure_create("), 0xfe10, {.d_s = node->decl.name}}, {_SLIT(", __closure_check_nargs("), 0xfe10, {.d_s = args_size}}, {_SLIT("), ("), 0xfe10, {.d_s = ctx_struct}}, {_SLIT("*) memdup(&("), 0xfe10, {.d_s = ctx_struct}}, {_SLIT("){"), 0, { .d_c = 0 }}})));
	g->indent++;
	for (int _t2 = 0; _t2 < node->inherited_vars.len; ++_t2) {
		v__ast__Param var = ((v__ast__Param*)node->inherited_vars.data)[_t2];
		v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("."), 0xfe10, {.d_s = var.name}}, {_SLIT(" = "), 0xfe10, {.d_s = var.name}}, {_SLIT(","), 0, { .d_c = 0 }}})));
	}
	g->indent--;
	v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("}, sizeof("), 0xfe10, {.d_s = ctx_struct}}, {_SLIT(")))"), 0, { .d_c = 0 }}})));
	g->empty_line = false;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_anon_fn_decl(v__gen__c__Gen* g, v__ast__AnonFn* node) {
	if (node->has_gen) {
		return;
	}
	node->has_gen = true;
	strings__Builder builder = strings__new_builder(256);
	if (node->inherited_vars.len > 0) {
		string ctx_struct = v__gen__c__closure_ctx_struct(node->decl);
		strings__Builder_writeln(&builder,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ctx_struct}}, {_SLIT(" {"), 0, { .d_c = 0 }}})));
		for (int _t1 = 0; _t1 < node->inherited_vars.len; ++_t1) {
			v__ast__Param var = ((v__ast__Param*)node->inherited_vars.data)[_t1];
			string styp = v__gen__c__Gen_typ(g, var.typ);
			strings__Builder_writeln(&builder,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = styp}}, {_SLIT(" "), 0xfe10, {.d_s = var.name}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
		}
		strings__Builder_writeln(&builder, _SLIT("};\n"));
	}
	int pos = g->out.len;
	bool was_anon_fn = g->anon_fn;
	g->anon_fn = true;
	v__gen__c__Gen_fn_decl(g, node->decl);
	g->anon_fn = was_anon_fn;
	strings__Builder_write_string(&builder, strings__Builder_cut_to(&g->out, pos));
	array_push((array*)&g->anon_fn_definitions, _MOV((string[]){ string_clone(strings__Builder_str(&builder)) }));
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_defer_flag_var(v__gen__c__Gen* g, v__ast__DeferStmt* stmt) {
	string _t1 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = g->last_fn_c_name}}, {_SLIT("_defer_"), 0xfe07, {.d_i32 = stmt->idx_in_fn}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t1;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_write_defer_stmts_when_needed(v__gen__c__Gen* g) {
	v__gen__c__Gen_unlock_locks(g);
	if (g->defer_stmts.len > 0) {
		v__gen__c__Gen_write_defer_stmts(g);
	}
	if (g->defer_profile_code.len > 0) {
		v__gen__c__Gen_writeln(g, _SLIT(""));
		v__gen__c__Gen_writeln(g, _SLIT("\t// defer_profile_code"));
		v__gen__c__Gen_writeln(g, g->defer_profile_code);
		v__gen__c__Gen_writeln(g, _SLIT(""));
	}
}

VV_LOCAL_SYMBOL multi_return_Array_string_Array_string_Array_bool v__gen__c__Gen_fn_args(v__gen__c__Gen* g, Array_v__ast__Param args, v__ast__Scope* scope) {
	Array_string fargs = __new_array_with_default(0, 0, sizeof(string), 0);
	Array_string fargtypes = __new_array_with_default(0, 0, sizeof(string), 0);
	Array_bool heap_promoted = __new_array_with_default(0, 0, sizeof(bool), 0);
	if (args.len == 0) {
		v__gen__c__Gen_write(g, _SLIT("void"));
	}
	for (int i = 0; i < args.len; ++i) {
		v__ast__Param arg = ((v__ast__Param*)args.data)[i];
		string caname = (string__eq(arg.name, _SLIT("_")) ? (v__gen__c__Gen_new_tmp_declaration_name(g)) : (v__gen__c__c_name(arg.name)));
		v__ast__Type typ = v__gen__c__Gen_unwrap_generic(g, arg.typ);
		v__ast__TypeSymbol* arg_type_sym = v__ast__Table_sym(g->table, typ);
		string arg_type_name = v__gen__c__Gen_typ(g, typ);
		if (arg_type_sym->kind == v__ast__Kind__function) {
			v__ast__FnType info = /* as */ *(v__ast__FnType*)__as_cast((arg_type_sym->info)._v__ast__FnType,(arg_type_sym->info)._typ, 472) /*expected idx: 472, name: v.ast.FnType */ ;
			v__ast__Fn func = info.func;
			v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__gen__c__Gen_typ(g, func.return_type)}}, {_SLIT(" (*"), 0xfe10, {.d_s = caname}}, {_SLIT(")("), 0, { .d_c = 0 }}})));
			strings__Builder_write_string(&g->definitions,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__gen__c__Gen_typ(g, func.return_type)}}, {_SLIT(" (*"), 0xfe10, {.d_s = caname}}, {_SLIT(")("), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_fn_args(g, func.params, ((voidptr)(0)));
			v__gen__c__Gen_write(g, _SLIT(")"));
			strings__Builder_write_string(&g->definitions, _SLIT(")"));
			array_push((array*)&fargs, _MOV((string[]){ string_clone(caname) }));
			array_push((array*)&fargtypes, _MOV((string[]){ string_clone(arg_type_name) }));
		} else {
			bool heap_prom = false;
			if (scope != ((voidptr)(0))) {
				if (!string__eq(arg.name, _SLIT("_"))) {
					Option_v__ast__Var_ptr _t3;
					if (_t3 = v__ast__Scope_find_var(scope, arg.name), _t3.state == 0) {
						v__ast__Var* v = *(v__ast__Var**)_t3.data;
						if (!v->is_stack_obj && v->is_auto_heap) {
							heap_prom = true;
						}
					}
				}
			}
			string var_name_prefix = (heap_prom ? (_SLIT("_v_toheap_")) : (_SLIT("")));
			string const_prefix = (v__ast__Type_is_any_kind_of_pointer(arg.typ) && !arg.is_mut && string_starts_with(arg.name, _SLIT("const_")) ? (_SLIT("const ")) : (_SLIT("")));
			string s =  str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = const_prefix}}, {_SLIT0, 0xfe10, {.d_s = arg_type_name}}, {_SLIT(" "), 0xfe10, {.d_s = var_name_prefix}}, {_SLIT0, 0xfe10, {.d_s = caname}}, {_SLIT0, 0, { .d_c = 0 }}}));
			v__gen__c__Gen_write(g, s);
			strings__Builder_write_string(&g->definitions, s);
			array_push((array*)&fargs, _MOV((string[]){ string_clone(caname) }));
			array_push((array*)&fargtypes, _MOV((string[]){ string_clone(arg_type_name) }));
			array_push((array*)&heap_promoted, _MOV((bool[]){ heap_prom }));
		}
		if (i < args.len - 1) {
			v__gen__c__Gen_write(g, _SLIT(", "));
			strings__Builder_write_string(&g->definitions, _SLIT(", "));
		}
	}
	return (multi_return_Array_string_Array_string_Array_bool){.arg0=fargs, .arg1=fargtypes, .arg2=heap_promoted};
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_call_expr(v__gen__c__Gen* g, v__ast__CallExpr node) {
bool v__gen__c__Gen_call_expr_defer_0 = false;
	if ((node.left)._typ == 278 /* v.ast.AnonFn */) {
		v__gen__c__Gen_expr(g, node.left);
	}
	if ((node.left)._typ == 302 /* v.ast.IndexExpr */ && (node.name).len == 0) {
		g->is_fn_index_call = true;
		v__gen__c__Gen_expr(g, node.left);
		g->is_fn_index_call = false;
	}
	if (node.should_be_skipped) {
		return;
	}
	g->inside_call = true;
	v__gen__c__Gen_call_expr_defer_0 = true;
	bool gen_keep_alive = node.is_keep_alive && !v__ast__Type_alias_eq(node.return_type, _const_v__ast__void_type) && (g->pref->gc_mode == v__pref__GarbageCollectionMode__boehm_full || g->pref->gc_mode == v__pref__GarbageCollectionMode__boehm_incr || g->pref->gc_mode == v__pref__GarbageCollectionMode__boehm_full_opt || g->pref->gc_mode == v__pref__GarbageCollectionMode__boehm_incr_opt);
	bool gen_or = node.or_block.kind != v__ast__OrKind__absent;
	bool is_gen_or_and_assign_rhs = gen_or && !g->discard_or_result;
	string _t1; /* if prepend */
	if (is_gen_or_and_assign_rhs || gen_keep_alive) {
		string line = v__gen__c__Gen_go_before_stmt(g, 0);
		strings__Builder_write_string(&g->out, v__util__tabs(g->indent));
		_t1 = line;
	} else {
		_t1 = _SLIT("");
	}
	string cur_line =  _t1;
	string tmp_opt = (gen_or || gen_keep_alive ? (v__gen__c__Gen_new_tmp_var(g)) : (_SLIT("")));
	if (gen_or || gen_keep_alive) {
		v__ast__Type ret_typ = node.return_type;
		if (gen_or) {
			ret_typ = v__ast__Type_set_flag(ret_typ, v__ast__TypeFlag__optional);
		}
		string styp = v__gen__c__Gen_typ(g, ret_typ);
		if (gen_or && !is_gen_or_and_assign_rhs) {
			cur_line = v__gen__c__Gen_go_before_stmt(g, 0);
		}
		v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = styp}}, {_SLIT(" "), 0xfe10, {.d_s = tmp_opt}}, {_SLIT(" = "), 0, { .d_c = 0 }}})));
	}
	if (node.is_method && !node.is_field) {
		if (string__eq(node.name, _SLIT("writeln")) && g->pref->experimental && node.args.len > 0 && ((*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr)._typ == 322 /* v.ast.StringInterLiteral */ && string__eq(v__ast__Table_sym(g->table, node.receiver_type)->name, _SLIT("strings.Builder"))) {
			v__gen__c__Gen_string_inter_literal_sb_optimized(g, node);
		} else {
			v__gen__c__Gen_method_call(g, node);
		}
	} else {
		v__gen__c__Gen_fn_call(g, node);
	}
	if (gen_or) {
		v__gen__c__Gen_or_block(g, tmp_opt, node.or_block, node.return_type);
		v__ast__Type unwrapped_typ = v__ast__Type_clear_flag(node.return_type, v__ast__TypeFlag__optional);
		string unwrapped_styp = v__gen__c__Gen_typ(g, unwrapped_typ);
		if (v__ast__Type_alias_eq(unwrapped_typ, _const_v__ast__void_type)) {
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\n "), 0xfe10, {.d_s = cur_line}}, {_SLIT0, 0, { .d_c = 0 }}})));
		} else if (v__ast__Table_sym(g->table, node.return_type)->kind == v__ast__Kind__multi_return) {
			v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\n "), 0xfe10, {.d_s = cur_line}}, {_SLIT(" "), 0xfe10, {.d_s = tmp_opt}}, {_SLIT(" /*U*/"), 0, { .d_c = 0 }}})));
		} else {
			if (!g->inside_const) {
				v__gen__c__Gen_write(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\n "), 0xfe10, {.d_s = cur_line}}, {_SLIT(" (*("), 0xfe10, {.d_s = unwrapped_styp}}, {_SLIT("*)"), 0xfe10, {.d_s = tmp_opt}}, {_SLIT(".data)"), 0, { .d_c = 0 }}})));
			} else {
				v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\n "), 0xfe10, {.d_s = cur_line}}, {_SLIT(" "), 0xfe10, {.d_s = tmp_opt}}, {_SLIT0, 0, { .d_c = 0 }}})));
			}
		}
	} else if (gen_keep_alive) {
		if (v__ast__Type_alias_eq(node.return_type, _const_v__ast__void_type)) {
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\n "), 0xfe10, {.d_s = cur_line}}, {_SLIT0, 0, { .d_c = 0 }}})));
		} else {
			v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\n "), 0xfe10, {.d_s = cur_line}}, {_SLIT(" "), 0xfe10, {.d_s = tmp_opt}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
	}
	if (node.is_noreturn) {
		if (g->inside_ternary == 0) {
			v__gen__c__Gen_writeln(g, _SLIT(";"));
			v__gen__c__Gen_write(g, _SLIT("VUNREACHABLE()"));
		} else {
			#if defined(_MSC_VER)
			{
			}
			#else
			{
				v__gen__c__Gen_write(g, _SLIT(", ({VUNREACHABLE();})"));
			}
			#endif
		}
	}
// Defer begin
if (v__gen__c__Gen_call_expr_defer_0) {
	g->inside_call = false;
}
// Defer end
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_conversion_function_call(v__gen__c__Gen* g, string prefix, string postfix, v__ast__CallExpr node) {
	v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = prefix}}, {_SLIT("( ("), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_expr(g, node.left);
	string dot = (v__ast__Type_is_ptr(node.left_type) ? (_SLIT("->")) : (_SLIT(".")));
	v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT(")"), 0xfe10, {.d_s = dot}}, {_SLIT("_typ )"), 0xfe10, {.d_s = postfix}}, {_SLIT0, 0, { .d_c = 0 }}})));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_method_call(v__gen__c__Gen* g, v__ast__CallExpr node) {
	if (node.left_type == 0) {
		v__gen__c__Gen_checker_bug(g, _SLIT("CallExpr.left_type is 0 in method_call"), node.pos);
	}
	if (node.receiver_type == 0) {
		v__gen__c__Gen_checker_bug(g, _SLIT("CallExpr.receiver_type is 0 in method_call"), node.pos);
	}
	v__ast__Type unwrapped_rec_type = node.receiver_type;
	if (g->cur_fn != 0 && g->cur_fn->generic_names.len > 0) {
		unwrapped_rec_type = v__gen__c__Gen_unwrap_generic(g, node.receiver_type);
	} else {
		v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, node.receiver_type);
		if (sym->info._typ == 446 /* v.ast.Struct */) {
			Array_string _t1 = __new_array(0, 0, sizeof(string));
			Array_v__ast__Type _t1_orig = (*sym->info._v__ast__Struct).generic_types;
			int _t1_len = _t1_orig.len;
			_t1 = __new_array(0, _t1_len, sizeof(string));

			for (int _t2 = 0; _t2 < _t1_len; ++_t2) {
				v__ast__Type it = ((v__ast__Type*) _t1_orig.data)[_t2];
				string ti = v__ast__Table_sym(g->table, it)->name;
				array_push((array*)&_t1, &ti);
			}
			Array_string generic_names =_t1;
			v__ast__Table* muttable = ((v__ast__Table*)(g->table));
			Option_v__ast__Type _t3;
			if (_t3 = v__ast__Table_resolve_generic_to_concrete(muttable, node.receiver_type, generic_names, (*sym->info._v__ast__Struct).concrete_types), _t3.state == 0) {
				v__ast__Type utyp = *(v__ast__Type*)_t3.data;
				unwrapped_rec_type = utyp;
			}
		}
		else if (sym->info._typ == 463 /* v.ast.Interface */) {
			Array_string _t4 = __new_array(0, 0, sizeof(string));
			Array_v__ast__Type _t4_orig = (*sym->info._v__ast__Interface).generic_types;
			int _t4_len = _t4_orig.len;
			_t4 = __new_array(0, _t4_len, sizeof(string));

			for (int _t5 = 0; _t5 < _t4_len; ++_t5) {
				v__ast__Type it = ((v__ast__Type*) _t4_orig.data)[_t5];
				string ti = v__ast__Table_sym(g->table, it)->name;
				array_push((array*)&_t4, &ti);
			}
			Array_string generic_names =_t4;
			v__ast__Table* muttable = ((v__ast__Table*)(g->table));
			Option_v__ast__Type _t6;
			if (_t6 = v__ast__Table_resolve_generic_to_concrete(muttable, node.receiver_type, generic_names, (*sym->info._v__ast__Interface).concrete_types), _t6.state == 0) {
				v__ast__Type utyp = *(v__ast__Type*)_t6.data;
				unwrapped_rec_type = utyp;
			}
		}
		else if (sym->info._typ == 464 /* v.ast.SumType */) {
			Array_string _t7 = __new_array(0, 0, sizeof(string));
			Array_v__ast__Type _t7_orig = (*sym->info._v__ast__SumType).generic_types;
			int _t7_len = _t7_orig.len;
			_t7 = __new_array(0, _t7_len, sizeof(string));

			for (int _t8 = 0; _t8 < _t7_len; ++_t8) {
				v__ast__Type it = ((v__ast__Type*) _t7_orig.data)[_t8];
				string ti = v__ast__Table_sym(g->table, it)->name;
				array_push((array*)&_t7, &ti);
			}
			Array_string generic_names =_t7;
			v__ast__Table* muttable = ((v__ast__Table*)(g->table));
			Option_v__ast__Type _t9;
			if (_t9 = v__ast__Table_resolve_generic_to_concrete(muttable, node.receiver_type, generic_names, (*sym->info._v__ast__SumType).concrete_types), _t9.state == 0) {
				v__ast__Type utyp = *(v__ast__Type*)_t9.data;
				unwrapped_rec_type = utyp;
			}
		}
		
		else {
		}
		;
	}
	v__ast__TypeSymbol* typ_sym = v__ast__Table_sym(g->table, unwrapped_rec_type);
	if (typ_sym->kind == v__ast__Kind__alias && !string__eq(node.name, _SLIT("str")) && !v__ast__TypeSymbol_has_method(typ_sym, node.name)) {
		unwrapped_rec_type = (/* as */ *(v__ast__Alias*)__as_cast((typ_sym->info)._v__ast__Alias,(typ_sym->info)._typ, 460) /*expected idx: 460, name: v.ast.Alias */ ).parent_type;
		typ_sym = v__ast__Table_sym(g->table, unwrapped_rec_type);
	}
	string rec_cc_type = v__gen__c__Gen_cc_type(g, unwrapped_rec_type, false);
	string receiver_type_name = v__util__no_dots(rec_cc_type);
	if (typ_sym->kind == v__ast__Kind__interface_ && v__ast__Interface_defines_method(ADDR(v__ast__Interface, (/* as */ *(v__ast__Interface*)__as_cast((typ_sym->info)._v__ast__Interface,(typ_sym->info)._typ, 463) /*expected idx: 463, name: v.ast.Interface */ )), node.name)) {
		bool left_is_shared = v__ast__Type_has_flag(node.left_type, v__ast__TypeFlag__shared_f);
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__gen__c__c_name(receiver_type_name)}}, {_SLIT("_name_table["), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_expr(g, node.left);
		string dot = (left_is_shared ? (_SLIT("->val.")) : v__ast__Type_is_ptr(node.left_type) ? (_SLIT("->")) : (_SLIT(".")));
		string mname = v__gen__c__c_name(node.name);
		v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = dot}}, {_SLIT("_typ]._method_"), 0xfe10, {.d_s = mname}}, {_SLIT("("), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_expr(g, node.left);
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = dot}}, {_SLIT("_object"), 0, { .d_c = 0 }}})));
		if (node.args.len > 0) {
			v__gen__c__Gen_write(g, _SLIT(", "));
			v__gen__c__Gen_call_args(g, node);
		}
		v__gen__c__Gen_write(g, _SLIT(")"));
		return;
	}
	v__ast__TypeSymbol* left_sym = v__ast__Table_sym(g->table, node.left_type);
	v__ast__TypeSymbol* final_left_sym = v__ast__Table_final_sym(g->table, node.left_type);
	if (left_sym->kind == v__ast__Kind__array) {

		if (string__eq(node.name, _SLIT("filter"))) {
			v__gen__c__Gen_gen_array_filter(g, node);
			return;
		}
		else if (string__eq(node.name, _SLIT("sort"))) {
			v__gen__c__Gen_gen_array_sort(g, node);
			return;
		}
		else if (string__eq(node.name, _SLIT("insert"))) {
			v__gen__c__Gen_gen_array_insert(g, node);
			return;
		}
		else if (string__eq(node.name, _SLIT("map"))) {
			v__gen__c__Gen_gen_array_map(g, node);
			return;
		}
		else if (string__eq(node.name, _SLIT("prepend"))) {
			v__gen__c__Gen_gen_array_prepend(g, node);
			return;
		}
		else if (string__eq(node.name, _SLIT("contains"))) {
			v__gen__c__Gen_gen_array_contains(g, node.left_type, node.left, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
			return;
		}
		else if (string__eq(node.name, _SLIT("index"))) {
			v__gen__c__Gen_gen_array_index(g, node);
			return;
		}
		else if (string__eq(node.name, _SLIT("wait"))) {
			v__gen__c__Gen_gen_array_wait(g, node);
			return;
		}
		else if (string__eq(node.name, _SLIT("any"))) {
			v__gen__c__Gen_gen_array_any(g, node);
			return;
		}
		else if (string__eq(node.name, _SLIT("all"))) {
			v__gen__c__Gen_gen_array_all(g, node);
			return;
		}
		else {
		};
	}
	if (left_sym->kind == v__ast__Kind__map && string__eq(node.name, _SLIT("delete"))) {
		v__ast__Map left_info = /* as */ *(v__ast__Map*)__as_cast((left_sym->info)._v__ast__Map,(left_sym->info)._typ, 442) /*expected idx: 442, name: v.ast.Map */ ;
		string elem_type_str = v__gen__c__Gen_typ(g, left_info.key_type);
		v__gen__c__Gen_write(g, _SLIT("map_delete("));
		if (v__ast__Type_is_ptr(node.left_type)) {
			v__gen__c__Gen_expr(g, node.left);
		} else {
			v__gen__c__Gen_write(g, _SLIT("&"));
			v__gen__c__Gen_expr(g, node.left);
		}
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(", &("), 0xfe10, {.d_s = elem_type_str}}, {_SLIT("[]){"), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
		v__gen__c__Gen_write(g, _SLIT("})"));
		return;
	} else if (left_sym->kind == v__ast__Kind__array && string__eq(node.name, _SLIT("delete"))) {
		v__gen__c__Gen_write(g, _SLIT("array_delete("));
		if (v__ast__Type_is_ptr(node.left_type)) {
			v__gen__c__Gen_expr(g, node.left);
		} else {
			v__gen__c__Gen_write(g, _SLIT("&"));
			v__gen__c__Gen_expr(g, node.left);
		}
		v__gen__c__Gen_write(g, _SLIT(", "));
		v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
		v__gen__c__Gen_write(g, _SLIT(")"));
		return;
	}
	if (left_sym->kind == v__ast__Kind__sum_type || left_sym->kind == v__ast__Kind__interface_) {
		if (string__eq(node.name, _SLIT("type_name"))) {
			if (left_sym->kind == v__ast__Kind__sum_type) {
				v__gen__c__Gen_conversion_function_call(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("charptr_vstring_literal( /* "), 0xfe10, {.d_s = left_sym->name}}, {_SLIT(" */ v_typeof_sumtype_"), 0xfe10, {.d_s = typ_sym->cname}}, {_SLIT0, 0, { .d_c = 0 }}})), _SLIT(")"), node);
				return;
			}
			if (left_sym->kind == v__ast__Kind__interface_) {
				v__gen__c__Gen_conversion_function_call(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("charptr_vstring_literal( /* "), 0xfe10, {.d_s = left_sym->name}}, {_SLIT(" */ v_typeof_interface_"), 0xfe10, {.d_s = typ_sym->cname}}, {_SLIT0, 0, { .d_c = 0 }}})), _SLIT(")"), node);
				return;
			}
		}
		if (string__eq(node.name, _SLIT("type_idx"))) {
			if (left_sym->kind == v__ast__Kind__sum_type) {
				v__gen__c__Gen_conversion_function_call(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("/* "), 0xfe10, {.d_s = left_sym->name}}, {_SLIT(" */ v_typeof_sumtype_idx_"), 0xfe10, {.d_s = typ_sym->cname}}, {_SLIT0, 0, { .d_c = 0 }}})), _SLIT(""), node);
				return;
			}
			if (left_sym->kind == v__ast__Kind__interface_) {
				v__gen__c__Gen_conversion_function_call(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("/* "), 0xfe10, {.d_s = left_sym->name}}, {_SLIT(" */ v_typeof_interface_idx_"), 0xfe10, {.d_s = typ_sym->cname}}, {_SLIT0, 0, { .d_c = 0 }}})), _SLIT(""), node);
				return;
			}
		}
	}
	if (string__eq(node.name, _SLIT("str"))) {
		v__ast__Type rec_type = node.receiver_type;
		if (v__ast__Type_has_flag(rec_type, v__ast__TypeFlag__shared_f)) {
			rec_type = v__ast__Type_set_nr_muls(v__ast__Type_clear_flag(rec_type, v__ast__TypeFlag__shared_f), 0);
		}
		if ((node.left)._typ == 292 /* v.ast.ComptimeSelector */) {
			if (((*node.left._v__ast__ComptimeSelector).field_expr)._typ == 319 /* v.ast.SelectorExpr */) {
				if (((*(*node.left._v__ast__ComptimeSelector).field_expr._v__ast__SelectorExpr).expr)._typ == 299 /* v.ast.Ident */) {
					string key_str =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = (*(*(*node.left._v__ast__ComptimeSelector).field_expr._v__ast__SelectorExpr).expr._v__ast__Ident).name}}, {_SLIT(".typ"), 0, { .d_c = 0 }}}));
					v__ast__Type* _t11 = (v__ast__Type*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, g->comptime_var_type_map), &(string[]){key_str}));
					Option_v__ast__Type _t10 = {0};
					if (_t11) {
						*((v__ast__Type*)&_t10.data) = *((v__ast__Type*)_t11);
					} else {
						_t10.state = 2; _t10.err = _v_error(_SLIT("array index out of range"));
					}
					;
					if (_t10.state != 0) { /*or block*/ 
						IError err = _t10.err;
						*(v__ast__Type*) _t10.data = rec_type;
					}
					
					rec_type = *(v__ast__Type*)_t10.data;
					v__gen__c__Gen_gen_expr_to_string(g, node.left, rec_type);
					return;
				}
			}
		} else if ((node.left)._typ == 299 /* v.ast.Ident */) {
			if (((*node.left._v__ast__Ident).obj)._typ == 357 /* v.ast.Var */) {
				if (g->comptime_var_type_map.len > 0) {
					rec_type = (*(*node.left._v__ast__Ident).obj._v__ast__Var).typ;
					v__gen__c__Gen_gen_expr_to_string(g, node.left, rec_type);
					return;
				} else if ((*(*node.left._v__ast__Ident).obj._v__ast__Var).smartcasts.len > 0) {
					v__ast__TypeSymbol* cast_sym = v__ast__Table_sym(g->table, (*(v__ast__Type*)array_last((*(*node.left._v__ast__Ident).obj._v__ast__Var).smartcasts)));
					if ((cast_sym->info)._typ == 458 /* v.ast.Aggregate */) {
						rec_type = (*(v__ast__Type*)/*ee elem_typ */array_get((*cast_sym->info._v__ast__Aggregate).types, g->aggregate_type_idx));
						v__gen__c__Gen_gen_expr_to_string(g, node.left, rec_type);
						return;
					}
				}
			}
		}
		v__gen__c__Gen_get_str_fn(g, rec_type);
	} else if (string__eq(node.name, _SLIT("free"))) {
		v__ast__Type rec_type = node.receiver_type;
		if (v__ast__Type_has_flag(rec_type, v__ast__TypeFlag__shared_f)) {
			rec_type = v__ast__Type_set_nr_muls(v__ast__Type_clear_flag(rec_type, v__ast__TypeFlag__shared_f), 0);
		}
		v__gen__c__Gen_gen_free_method_for_type(g, rec_type);
	}
	bool has_cast = false;
	if (left_sym->kind == v__ast__Kind__map && (string__eq(node.name, _SLIT("clone")) || string__eq(node.name, _SLIT("move")))) {
		receiver_type_name = _SLIT("map");
	}
	if (final_left_sym->kind == v__ast__Kind__array && (string__eq(node.name, _SLIT("repeat")) || string__eq(node.name, _SLIT("sort_with_compare")) || string__eq(node.name, _SLIT("free")) || string__eq(node.name, _SLIT("push_many")) || string__eq(node.name, _SLIT("trim")) || string__eq(node.name, _SLIT("first")) || string__eq(node.name, _SLIT("last")) || string__eq(node.name, _SLIT("pop")) || string__eq(node.name, _SLIT("clone")) || string__eq(node.name, _SLIT("reverse")) || string__eq(node.name, _SLIT("slice")) || string__eq(node.name, _SLIT("pointers")))) {
		if (!((left_sym->info)._typ == 460 /* v.ast.Alias */ && v__ast__TypeSymbol_has_method(typ_sym, node.name))) {
			receiver_type_name = _SLIT("array");
		}
		if (string__eq(node.name, _SLIT("last")) || string__eq(node.name, _SLIT("first")) || string__eq(node.name, _SLIT("pop"))) {
			string return_type_str = v__gen__c__Gen_typ(g, node.return_type);
			has_cast = true;
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("(*("), 0xfe10, {.d_s = return_type_str}}, {_SLIT("*)"), 0, { .d_c = 0 }}})));
		}
	}
	string name = v__util__no_dots( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = receiver_type_name}}, {_SLIT("_"), 0xfe10, {.d_s = node.name}}, {_SLIT0, 0, { .d_c = 0 }}})));
	int array_depth = -1;
	string noscan = _SLIT("");
	if (left_sym->kind == v__ast__Kind__array) {
		bool needs_depth = (string__eq(node.name, _SLIT("clone")) || string__eq(node.name, _SLIT("repeat")));
		if (needs_depth) {
			v__ast__Type elem_type = (/* as */ *(v__ast__Array*)__as_cast((left_sym->info)._v__ast__Array,(left_sym->info)._typ, 441) /*expected idx: 441, name: v.ast.Array */ ).elem_type;
			array_depth = v__gen__c__Gen_get_array_depth(g, elem_type);
		}
		bool maybe_noscan = needs_depth || (string__eq(node.name, _SLIT("pop")) || string__eq(node.name, _SLIT("push")) || string__eq(node.name, _SLIT("push_many")) || string__eq(node.name, _SLIT("reverse")) || string__eq(node.name, _SLIT("grow_cap")) || string__eq(node.name, _SLIT("grow_len")));
		if (maybe_noscan) {
			v__ast__Array info = /* as */ *(v__ast__Array*)__as_cast((left_sym->info)._v__ast__Array,(left_sym->info)._typ, 441) /*expected idx: 441, name: v.ast.Array */ ;
			noscan = v__gen__c__Gen_check_noscan(g, info.elem_type);
		}
	} else if (left_sym->kind == v__ast__Kind__chan) {
		if (string__eq(node.name, _SLIT("close")) || string__eq(node.name, _SLIT("try_pop")) || string__eq(node.name, _SLIT("try_push"))) {
			name =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("sync__Channel_"), 0xfe10, {.d_s = node.name}}, {_SLIT0, 0, { .d_c = 0 }}}));
		}
	} else if (final_left_sym->kind == v__ast__Kind__map) {
		if (string__eq(node.name, _SLIT("keys"))) {
			name = _SLIT("map_keys");
		}
	}
	if (g->pref->obfuscate && string__eq(g->cur_mod.name, _SLIT("main")) && string_starts_with(name, _SLIT("main__")) && !string__eq(node.name, _SLIT("str"))) {
		v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, node.receiver_type);
		string key = string__plus(string__plus(sym->name, _SLIT(".")), node.name);
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("/* obf method call: "), 0xfe10, {.d_s = key}}, {_SLIT(" */"), 0, { .d_c = 0 }}})));
		string* _t13 = (string*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, g->obf_table), &(string[]){key}));
		Option_string _t12 = {0};
		if (_t13) {
			*((string*)&_t12.data) = *((string*)_t13);
		} else {
			_t12.state = 2; _t12.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t12.state != 0) { /*or block*/ 
			IError err = _t12.err;
			_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("cgen: obf name \""), 0xfe10, {.d_s = key}}, {_SLIT("\" not found, this should never happen"), 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		;
		}
		
		name = *(string*)_t12.data;
	}
	bool is_range_slice = false;
	if (v__ast__Type_is_ptr(node.receiver_type) && !v__ast__Type_is_ptr(node.left_type)) {
		if ((node.left)._typ == 302 /* v.ast.IndexExpr */) {
			v__ast__Expr idx = (*node.left._v__ast__IndexExpr).index;
			if ((idx)._typ == 317 /* v.ast.RangeExpr */) {
				name = v__util__no_dots( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = receiver_type_name}}, {_SLIT("_"), 0xfe10, {.d_s = node.name}}, {_SLIT("_static"), 0, { .d_c = 0 }}})));
				is_range_slice = true;
			}
		}
	}
	name = v__gen__c__Gen_generic_fn_name(g, node.concrete_types, name, false);
	if (!v__ast__Type_is_ptr(node.receiver_type) && v__ast__Type_is_ptr(node.left_type) && string__eq(node.name, _SLIT("str"))) {
		v__gen__c__Gen_write(g, _SLIT("ptr_str("));
	} else if (v__ast__Type_is_ptr(node.receiver_type) && v__ast__Type_is_ptr(node.left_type) && string__eq(node.name, _SLIT("str")) && !v__ast__TypeSymbol_has_method(left_sym, _SLIT("str"))) {
		v__gen__c__Gen_gen_expr_to_string(g, node.left, node.left_type);
		return;
	} else {
		if (left_sym->kind == v__ast__Kind__array) {
			if (array_depth >= 0) {
				name = string__plus(name, _SLIT("_to_depth"));
			}
			v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = name}}, {_SLIT0, 0xfe10, {.d_s = noscan}}, {_SLIT("("), 0, { .d_c = 0 }}})));
		} else {
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = name}}, {_SLIT("("), 0, { .d_c = 0 }}})));
		}
	}
	if (v__ast__Type_is_ptr(node.receiver_type) && (!v__ast__Type_is_ptr(node.left_type) || v__ast__Type_has_flag(node.left_type, v__ast__TypeFlag__variadic) || node.from_embed_types.len != 0 || (v__ast__Type_has_flag(node.left_type, v__ast__TypeFlag__shared_f) && !string__eq(node.name, _SLIT("str"))))) {
		if (!is_range_slice) {
			if (!v__ast__Expr_is_lvalue(node.left)) {
				v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("ADDR("), 0xfe10, {.d_s = rec_cc_type}}, {_SLIT(", "), 0, { .d_c = 0 }}})));
				has_cast = true;
			} else {
				v__gen__c__Gen_write(g, _SLIT("&"));
			}
		}
	} else if (!v__ast__Type_is_ptr(node.receiver_type) && v__ast__Type_is_ptr(node.left_type) && !string__eq(node.name, _SLIT("str")) && node.from_embed_types.len == 0) {
		if (!v__ast__Type_has_flag(node.left_type, v__ast__TypeFlag__shared_f)) {
			v__gen__c__Gen_write(g, _SLIT("/*rec*/*"));
		}
	} else if (!is_range_slice && node.from_embed_types.len == 0 && !string__eq(node.name, _SLIT("str"))) {
		int diff = v__ast__Type_nr_muls(node.left_type) - v__ast__Type_nr_muls(node.receiver_type);
		if (diff < 0) {
		} else if (diff > 0) {
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("/*diff="), 0xfe07, {.d_i32 = diff}}, {_SLIT("*/"), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_write(g, Array_byte_bytestr(__new_array_with_default(diff, 0, sizeof(byte), &(byte[]){'*'})));
		}
	}
	if (g->is_autofree && node.free_receiver && !g->inside_lambda && !g->is_builtin_mod) {
		string fn_name = string_replace(node.name, _SLIT("."), _SLIT("_"));
		string arg_name =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("_arg_expr_"), 0xfe10, {.d_s = fn_name}}, {_SLIT("_0_"), 0xfe07, {.d_i32 = node.pos.pos}}, {_SLIT0, 0, { .d_c = 0 }}}));
		v__gen__c__Gen_write(g, string__plus(_SLIT("/*af receiver arg*/"), arg_name));
	} else {
		if (left_sym->kind == v__ast__Kind__array && v__ast__Expr_is_auto_deref_var(node.left) && (string__eq(node.name, _SLIT("first")) || string__eq(node.name, _SLIT("last")) || string__eq(node.name, _SLIT("repeat")))) {
			v__gen__c__Gen_write(g, _SLIT("*"));
		}
		if ((node.left)._typ == 308 /* v.ast.MapInit */) {
			v__gen__c__Gen_write(g, _SLIT("(map[]){"));
			v__gen__c__Gen_expr(g, node.left);
			v__gen__c__Gen_write(g, _SLIT("}[0]"));
		} else {
			v__gen__c__Gen_expr(g, node.left);
		}
		for (int _t14 = 0; _t14 < node.from_embed_types.len; ++_t14) {
			v__ast__Type embed = ((v__ast__Type*)node.from_embed_types.data)[_t14];
			v__ast__TypeSymbol* embed_sym = v__ast__Table_sym(g->table, embed);
			string embed_name = v__ast__TypeSymbol_embed_name(embed_sym);
			if (v__ast__Type_is_ptr(node.left_type)) {
				v__gen__c__Gen_write(g, _SLIT("->"));
			} else {
				v__gen__c__Gen_write(g, _SLIT("."));
			}
			v__gen__c__Gen_write(g, embed_name);
		}
		if (v__ast__Type_has_flag(node.left_type, v__ast__TypeFlag__shared_f)) {
			v__gen__c__Gen_write(g, _SLIT("->val"));
		}
	}
	if (has_cast) {
		v__gen__c__Gen_write(g, _SLIT(")"));
	}
	bool is_variadic = node.expected_arg_types.len > 0 && v__ast__Type_has_flag((*(v__ast__Type*)/*ee elem_typ */array_get(node.expected_arg_types, node.expected_arg_types.len - 1)), v__ast__TypeFlag__variadic);
	if (node.args.len > 0 || is_variadic) {
		v__gen__c__Gen_write(g, _SLIT(", "));
	}
	v__gen__c__Gen_call_args(g, node);
	if (array_depth >= 0) {
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(", "), 0xfe07, {.d_i32 = array_depth}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
	v__gen__c__Gen_write(g, _SLIT(")"));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_fn_call(v__gen__c__Gen* g, v__ast__CallExpr node) {
	bool is_interface_call = false;
	bool is_selector_call = false;
	if (node.left_type != 0) {
		v__ast__TypeSymbol* left_sym = v__ast__Table_sym(g->table, node.left_type);
		if (left_sym->kind == v__ast__Kind__interface_) {
			is_interface_call = true;
			v__gen__c__Gen_write(g, _SLIT("(*"));
		}
		v__gen__c__Gen_expr(g, node.left);
		if (v__ast__Type_is_ptr(node.left_type)) {
			v__gen__c__Gen_write(g, _SLIT("->"));
		} else {
			v__gen__c__Gen_write(g, _SLIT("."));
		}
		is_selector_call = true;
	}
	string name = node.name;
	bool is_print = (string__eq(name, _SLIT("print")) || string__eq(name, _SLIT("println")) || string__eq(name, _SLIT("eprint")) || string__eq(name, _SLIT("eprintln")) || string__eq(name, _SLIT("panic")));
	string print_method = name;
	bool is_json_encode = string__eq(name, _SLIT("json.encode"));
	bool is_json_encode_pretty = string__eq(name, _SLIT("json.encode_pretty"));
	bool is_json_decode = string__eq(name, _SLIT("json.decode"));
	g->is_json_fn = is_json_encode || is_json_encode_pretty || is_json_decode;
	string json_type_str = _SLIT("");
	string json_obj = _SLIT("");
	if (g->is_json_fn) {
		json_obj = v__gen__c__Gen_new_tmp_var(g);
		string tmp2 = _SLIT("");
		string cur_line = v__gen__c__Gen_go_before_stmt(g, 0);
		if (is_json_encode || is_json_encode_pretty) {
			v__gen__c__Gen_gen_json_for_type(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).typ);
			json_type_str = v__gen__c__Gen_typ(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).typ);
			string encode_name = v__gen__c__js_enc_name(json_type_str);
			v__gen__c__Gen_writeln(g, _SLIT("// json.encode"));
			v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("cJSON* "), 0xfe10, {.d_s = json_obj}}, {_SLIT(" = "), 0xfe10, {.d_s = encode_name}}, {_SLIT("("), 0, { .d_c = 0 }}})));
			if (v__ast__Type_is_ptr((*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).typ)) {
				v__gen__c__Gen_write(g, _SLIT("*"));
			}
			v__gen__c__Gen_call_args(g, node);
			v__gen__c__Gen_writeln(g, _SLIT(");"));
			tmp2 = v__gen__c__Gen_new_tmp_var(g);
			if (is_json_encode) {
				v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("string "), 0xfe10, {.d_s = tmp2}}, {_SLIT(" = json__json_print("), 0xfe10, {.d_s = json_obj}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
			} else {
				v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("string "), 0xfe10, {.d_s = tmp2}}, {_SLIT(" = json__json_print_pretty("), 0xfe10, {.d_s = json_obj}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
			}
		} else {
			v__ast__TypeNode ast_type = /* as */ *(v__ast__TypeNode*)__as_cast(((*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr)._v__ast__TypeNode,((*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr)._typ, 325) /*expected idx: 325, name: v.ast.TypeNode */ ;
			string typ = v__gen__c__c_name(v__gen__c__Gen_typ(g, ast_type.typ));
			string fn_name = string__plus(string__plus(v__gen__c__c_name(name), _SLIT("_")), typ);
			v__gen__c__Gen_gen_json_for_type(g, ast_type.typ);
			v__gen__c__Gen_writeln(g, _SLIT("// json.decode"));
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cJSON* "), 0xfe10, {.d_s = json_obj}}, {_SLIT(" = json__json_parse("), 0, { .d_c = 0 }}})));
			g->is_js_call = true;
			v__gen__c__Gen_call_args(g, node);
			g->is_js_call = false;
			v__gen__c__Gen_writeln(g, _SLIT(");"));
			tmp2 = v__gen__c__Gen_new_tmp_var(g);
			v__gen__c__Gen_writeln(g,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("Option_"), 0xfe10, {.d_s = typ}}, {_SLIT(" "), 0xfe10, {.d_s = tmp2}}, {_SLIT(" = "), 0xfe10, {.d_s = fn_name}}, {_SLIT(" ("), 0xfe10, {.d_s = json_obj}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
		}
		if (!g->is_autofree) {
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cJSON_Delete("), 0xfe10, {.d_s = json_obj}}, {_SLIT("); //del"), 0, { .d_c = 0 }}})));
		}
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\n"), 0xfe10, {.d_s = cur_line}}, {_SLIT0, 0, { .d_c = 0 }}})));
		name = _SLIT("");
		json_obj = tmp2;
	}
	if (node.language == v__ast__Language__c) {
		name = v__util__no_dots(string_substr(name, 2, name.len));
	} else {
		name = v__gen__c__c_name(name);
	}
	if (g->pref->translated) {
		Option_v__ast__Fn _t1;
		if (_t1 = v__ast__Table_find_fn(g->table, node.name), _t1.state == 0) {
			v__ast__Fn f = *(v__ast__Fn*)_t1.data;
			if (Array_v__ast__Attr_contains(f.attrs, _SLIT("c"))) {
				name = (*(v__ast__Attr*)/*ee elem_typ */array_get(f.attrs, 0)).arg;
			}
		}
	}
	if (g->pref->obfuscate && string__eq(g->cur_mod.name, _SLIT("main")) && string_starts_with(name, _SLIT("main__"))) {
		string key = node.name;
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("/* obf call: "), 0xfe10, {.d_s = key}}, {_SLIT(" */"), 0, { .d_c = 0 }}})));
		string* _t3 = (string*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, g->obf_table), &(string[]){key}));
		Option_string _t2 = {0};
		if (_t3) {
			*((string*)&_t2.data) = *((string*)_t3);
		} else {
			_t2.state = 2; _t2.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t2.state != 0) { /*or block*/ 
			IError err = _t2.err;
			_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("cgen: obf name \""), 0xfe10, {.d_s = key}}, {_SLIT("\" not found, this should never happen"), 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		;
		}
		
		name = *(string*)_t2.data;
	}
	if (!is_selector_call) {
		name = v__gen__c__Gen_generic_fn_name(g, node.concrete_types, name, false);
	}
	bool print_auto_str = false;
	if (is_print && (!v__ast__Type_alias_eq((*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).typ, _const_v__ast__string_type) || g->comptime_for_method.len > 0)) {
		v__ast__Type typ = (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).typ;
		if (typ == 0) {
			v__gen__c__Gen_checker_bug(g, _SLIT("print arg.typ is 0"), node.pos);
		}
		if (!v__ast__Type_alias_eq(typ, _const_v__ast__string_type) || g->comptime_for_method.len > 0) {
			v__ast__Expr expr = (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr;
			v__ast__TypeSymbol* typ_sym = v__ast__Table_sym(g->table, typ);
			if (typ_sym->kind == v__ast__Kind__interface_ && v__ast__Interface_defines_method(ADDR(v__ast__Interface, (/* as */ *(v__ast__Interface*)__as_cast((typ_sym->info)._v__ast__Interface,(typ_sym->info)._typ, 463) /*expected idx: 463, name: v.ast.Interface */ )), _SLIT("str"))) {
				v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__gen__c__c_name(print_method)}}, {_SLIT("("), 0, { .d_c = 0 }}})));
				string rec_type_name = v__util__no_dots(v__gen__c__Gen_cc_type(g, typ, false));
				v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__gen__c__c_name(rec_type_name)}}, {_SLIT("_name_table["), 0, { .d_c = 0 }}})));
				v__gen__c__Gen_expr(g, expr);
				string dot = (v__ast__Type_is_ptr(typ) ? (_SLIT("->")) : (_SLIT(".")));
				v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = dot}}, {_SLIT("_typ]._method_str("), 0, { .d_c = 0 }}})));
				v__gen__c__Gen_expr(g, expr);
				v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = dot}}, {_SLIT("_object"), 0, { .d_c = 0 }}})));
				v__gen__c__Gen_writeln(g, _SLIT("));"));
				return;
			}
			if (g->is_autofree && !v__ast__Type_has_flag(typ, v__ast__TypeFlag__optional)) {
				string tmp = v__gen__c__Gen_new_tmp_var(g);
				v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("string "), 0xfe10, {.d_s = tmp}}, {_SLIT(" = "), 0, { .d_c = 0 }}})));
				v__gen__c__Gen_gen_expr_to_string(g, expr, typ);
				v__gen__c__Gen_writeln(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("; "), 0xfe10, {.d_s = v__gen__c__c_name(print_method)}}, {_SLIT("("), 0xfe10, {.d_s = tmp}}, {_SLIT("); string_free(&"), 0xfe10, {.d_s = tmp}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
			} else {
				v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__gen__c__c_name(print_method)}}, {_SLIT("("), 0, { .d_c = 0 }}})));
				if ((expr)._typ == 292 /* v.ast.ComptimeSelector */) {
					if (((*expr._v__ast__ComptimeSelector).field_expr)._typ == 319 /* v.ast.SelectorExpr */) {
						if (((*(*expr._v__ast__ComptimeSelector).field_expr._v__ast__SelectorExpr).expr)._typ == 299 /* v.ast.Ident */) {
							string key_str =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = (*(*(*expr._v__ast__ComptimeSelector).field_expr._v__ast__SelectorExpr).expr._v__ast__Ident).name}}, {_SLIT(".typ"), 0, { .d_c = 0 }}}));
							v__ast__Type* _t5 = (v__ast__Type*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, g->comptime_var_type_map), &(string[]){key_str}));
							Option_v__ast__Type _t4 = {0};
							if (_t5) {
								*((v__ast__Type*)&_t4.data) = *((v__ast__Type*)_t5);
							} else {
								_t4.state = 2; _t4.err = _v_error(_SLIT("array index out of range"));
							}
							;
							if (_t4.state != 0) { /*or block*/ 
								IError err = _t4.err;
								*(v__ast__Type*) _t4.data = typ;
							}
							
							typ = *(v__ast__Type*)_t4.data;
						}
					}
				} else if ((expr)._typ == 299 /* v.ast.Ident */) {
					if (((*expr._v__ast__Ident).obj)._typ == 357 /* v.ast.Var */) {
						typ = (*(*expr._v__ast__Ident).obj._v__ast__Var).typ;
						if ((*(*expr._v__ast__Ident).obj._v__ast__Var).smartcasts.len > 0) {
							v__ast__TypeSymbol* cast_sym = v__ast__Table_sym(g->table, (*(v__ast__Type*)array_last((*(*expr._v__ast__Ident).obj._v__ast__Var).smartcasts)));
							if ((cast_sym->info)._typ == 458 /* v.ast.Aggregate */) {
								typ = (*(v__ast__Type*)/*ee elem_typ */array_get((*cast_sym->info._v__ast__Aggregate).types, g->aggregate_type_idx));
							}
						}
					}
				}
				v__gen__c__Gen_gen_expr_to_string(g, expr, typ);
				v__gen__c__Gen_write(g, _SLIT(")"));
			}
			print_auto_str = true;
		}
	}
	if (!print_auto_str) {
		if (g->pref->is_debug && string__eq(node.name, _SLIT("panic"))) {
			multi_return_int_string_string_string mr_36989 = v__gen__c__Gen_panic_debug_info(g, node.pos);
			int paline = mr_36989.arg0;
			string pafile = mr_36989.arg1;
			string pamod = mr_36989.arg2;
			string pafn = mr_36989.arg3;
			v__gen__c__Gen_write(g,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("panic_debug("), 0xfe07, {.d_i32 = paline}}, {_SLIT(", tos3(\""), 0xfe10, {.d_s = pafile}}, {_SLIT("\"), tos3(\""), 0xfe10, {.d_s = pamod}}, {_SLIT("\"), tos3(\""), 0xfe10, {.d_s = pafn}}, {_SLIT("\"),  "), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_call_args(g, node);
			v__gen__c__Gen_write(g, _SLIT(")"));
		} else {
			bool is_fn_var = false;
			Option_v__ast__ScopeObject _t6;
			if (_t6 = v__ast__Scope_find(node.scope, node.name), _t6.state == 0) {
				v__ast__ScopeObject obj = *(v__ast__ScopeObject*)_t6.data;
				if (obj._typ == 357 /* v.ast.Var */) {
					if ((*obj._v__ast__Var).smartcasts.len > 0) {
						for (int _t7 = 0; _t7 < (*obj._v__ast__Var).smartcasts.len; ++_t7) {
							v__gen__c__Gen_write(g, _SLIT("(*"));
						}
						for (int i = 0; i < (*obj._v__ast__Var).smartcasts.len; ++i) {
							v__ast__Type typ = ((v__ast__Type*)(*obj._v__ast__Var).smartcasts.data)[i];
							v__ast__TypeSymbol* cast_sym = v__ast__Table_sym(g->table, v__gen__c__Gen_unwrap_generic(g, typ));
							bool is_ptr = false;
							if (i == 0) {
								v__gen__c__Gen_write(g, node.name);
								if (v__ast__Type_is_ptr((*obj._v__ast__Var).orig_type)) {
									is_ptr = true;
								}
							}
							string dot = (is_ptr ? (_SLIT("->")) : (_SLIT(".")));
							if ((cast_sym->info)._typ == 458 /* v.ast.Aggregate */) {
								v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, (*(v__ast__Type*)/*ee elem_typ */array_get((*cast_sym->info._v__ast__Aggregate).types, g->aggregate_type_idx)));
								v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = dot}}, {_SLIT("_"), 0xfe10, {.d_s = sym->cname}}, {_SLIT0, 0, { .d_c = 0 }}})));
							} else {
								v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = dot}}, {_SLIT("_"), 0xfe10, {.d_s = cast_sym->cname}}, {_SLIT0, 0, { .d_c = 0 }}})));
							}
							v__gen__c__Gen_write(g, _SLIT(")"));
						}
						is_fn_var = true;
					}
				}
				
				else {
				}
				;
			}
			if (!is_fn_var) {
				v__gen__c__Gen_write(g, v__gen__c__Gen_get_ternary_name(g, name));
			}
			if (is_interface_call) {
				v__gen__c__Gen_write(g, _SLIT(")"));
			}
			int tmp_cnt_save = -1;
			v__gen__c__Gen_write(g, _SLIT("("));
			if (g->is_json_fn) {
				v__gen__c__Gen_write(g, json_obj);
			} else {
				if (node.is_keep_alive && (g->pref->gc_mode == v__pref__GarbageCollectionMode__boehm_full || g->pref->gc_mode == v__pref__GarbageCollectionMode__boehm_incr || g->pref->gc_mode == v__pref__GarbageCollectionMode__boehm_full_opt || g->pref->gc_mode == v__pref__GarbageCollectionMode__boehm_incr_opt)) {
					string cur_line = v__gen__c__Gen_go_before_stmt(g, 0);
					tmp_cnt_save = v__gen__c__Gen_keep_alive_call_pregen(g, node);
					v__gen__c__Gen_write(g, cur_line);
					for (int i = 0; i < node.args.len; ++i) {
						if (i > 0) {
							v__gen__c__Gen_write(g, _SLIT(", "));
						}
						v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("__tmp_arg_"), 0xfe07, {.d_i32 = tmp_cnt_save + i}}, {_SLIT0, 0, { .d_c = 0 }}})));
					}
				} else {
					v__gen__c__Gen_call_args(g, node);
				}
			}
			v__gen__c__Gen_write(g, _SLIT(")"));
			if (tmp_cnt_save >= 0) {
				v__gen__c__Gen_writeln(g, _SLIT(";"));
				v__gen__c__Gen_keep_alive_call_postgen(g, node, tmp_cnt_save);
			}
		}
	}
	g->is_json_fn = false;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_autofree_call_pregen(v__gen__c__Gen* g, v__ast__CallExpr node) {
	bool free_tmp_arg_vars = g->is_autofree && !g->is_builtin_mod && node.args.len > 0 && !v__ast__Type_has_flag((*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).typ, v__ast__TypeFlag__optional);
	if (!free_tmp_arg_vars) {
		return;
	}
	if (g->is_js_call) {
		return;
	}
	if (g->inside_const) {
		return;
	}
	free_tmp_arg_vars = false;
	g->tmp_count_af++;
	v__ast__Scope* scope = v__ast__Scope_innermost(g->file->scope, node.pos.pos);
	Array_v__ast__CallArg args = new_array_from_c_array(1, 1, sizeof(v__ast__CallArg), _MOV((v__ast__CallArg[1]){(v__ast__CallArg){.is_mut = 0,.share = 0,.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.expr = node.left,.typ = node.receiver_type,.is_tmp_autofree = node.free_receiver,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},}}));
	_PUSH_MANY(&args, (node.args), _t1, Array_v__ast__CallArg);
	for (int i = 0; i < args.len; ++i) {
		v__ast__CallArg arg = ((v__ast__CallArg*)args.data)[i];
		if (!arg.is_tmp_autofree) {
			continue;
		}
		if ((arg.expr)._typ == 286 /* v.ast.CallExpr */) {
			v__gen__c__Gen_autofree_call_pregen(g, (*arg.expr._v__ast__CallExpr));
		}
		free_tmp_arg_vars = true;
		string fn_name = string_replace(node.name, _SLIT("."), _SLIT("_"));
		string t =  str_intp(4, _MOV((StrIntpData[]){{_SLIT("_arg_expr_"), 0xfe10, {.d_s = fn_name}}, {_SLIT("_"), 0xfe07, {.d_i32 = i}}, {_SLIT("_"), 0xfe07, {.d_i32 = node.pos.pos}}, {_SLIT0, 0, { .d_c = 0 }}}));
		bool used = false;
		string s =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = t}}, {_SLIT(" = "), 0, { .d_c = 0 }}}));
		if (used) {
			Option_v__ast__ScopeObject _t2;
			if (_t2 = v__ast__Scope_find(scope, t), _t2.state == 0) {
				v__ast__ScopeObject x = *(v__ast__ScopeObject*)_t2.data;
				if (x._typ == 357 /* v.ast.Var */) {
					(*x._v__ast__Var).is_used = false;
				}
				
				else {
				}
				;
			}
			s =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = t}}, {_SLIT(" = "), 0, { .d_c = 0 }}}));
		} else {
			v__ast__Scope_register(scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){.name = t,.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = true,.is_arg = 0,.is_auto_deref = 0,.is_inherited = 0,.typ = _const_v__ast__string_type,.orig_type = 0,.smartcasts = __new_array(0, 0, sizeof(v__ast__Type)),.pos = node.pos,.is_used = 0,.is_changed = 0,.is_or = 0,.is_tmp = 0,.is_auto_heap = 0,.is_stack_obj = 0,}))));
			s =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("string "), 0xfe10, {.d_s = t}}, {_SLIT(" = "), 0, { .d_c = 0 }}}));
		}
		s = /*f*/string__plus(s, v__gen__c__Gen_expr_string(g, arg.expr));
		s = /*f*/string__plus(s, _SLIT(";// new af2 pre"));
		array_push((array*)&g->strs_to_free0, _MOV((string[]){ string_clone(s) }));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_autofree_call_postgen(v__gen__c__Gen* g, int node_pos) {
	if (g->inside_vweb_tmpl) {
		return;
	}
	v__ast__Scope* scope = v__ast__Scope_innermost(g->file->scope, node_pos);
	Map_string_v__ast__ScopeObject _t1 = scope->objects;
	int _t3 = _t1.key_values.len;
	for (int _t2 = 0; _t2 < _t3; ++_t2 ) {
		int _t4 = _t1.key_values.len - _t3;
		_t3 = _t1.key_values.len;
		if (_t4 < 0) {
			_t2 = -1;
			continue;
		}
		if (!DenseArray_has_index(&_t1.key_values, _t2)) {continue;}
		v__ast__ScopeObject obj = (*(v__ast__ScopeObject*)DenseArray_value(&_t1.key_values, _t2));
		if (obj._typ == 357 /* v.ast.Var */) {
			bool is_optional = v__ast__Type_has_flag((*obj._v__ast__Var).typ, v__ast__TypeFlag__optional);
			if (is_optional) {
				continue;
			}
			if (!(*obj._v__ast__Var).is_autofree_tmp) {
				continue;
			}
			if ((*obj._v__ast__Var).is_used) {
				continue;
			}
			(*obj._v__ast__Var).is_used = true;
			v__gen__c__Gen_autofree_variable(g, (*obj._v__ast__Var));
		}
		
		else {
		}
		;
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_call_args(v__gen__c__Gen* g, v__ast__CallExpr node) {
	Array_v__ast__CallArg _t1; /* if prepend */
	if (g->is_js_call) {
		if (node.args.len < 1) {
			v__gen__c__Gen_error(g, _SLIT("node should have at least 1 arg"), node.pos);
			VUNREACHABLE();
		}
		_t1 = array_slice(node.args, 1, node.args.len);
	} else {
		_t1 = node.args;
	}
	Array_v__ast__CallArg args =  _t1;
	Array_v__ast__Type expected_types = node.expected_arg_types;
	bool is_variadic = expected_types.len > 0 && v__ast__Type_has_flag((*(v__ast__Type*)array_last(expected_types)), v__ast__TypeFlag__variadic) && node.language == v__ast__Language__v;
	for (int i = 0; i < args.len; ++i) {
		v__ast__CallArg arg = ((v__ast__CallArg*)args.data)[i];
		if (is_variadic && i == expected_types.len - 1) {
			break;
		}
		bool use_tmp_var_autofree = g->is_autofree && v__ast__Type_alias_eq(arg.typ, _const_v__ast__string_type) && arg.is_tmp_autofree && !g->inside_const && !g->is_builtin_mod;
		if (i < expected_types.len) {
			if (use_tmp_var_autofree) {
				if (arg.is_tmp_autofree) {
					string fn_name = string_replace(node.name, _SLIT("."), _SLIT("_"));
					string name =  str_intp(4, _MOV((StrIntpData[]){{_SLIT("_arg_expr_"), 0xfe10, {.d_s = fn_name}}, {_SLIT("_"), 0xfe07, {.d_i32 = i + 1}}, {_SLIT("_"), 0xfe07, {.d_i32 = node.pos.pos}}, {_SLIT0, 0, { .d_c = 0 }}}));
					v__gen__c__Gen_write(g, string__plus(_SLIT("/*af arg*/"), name));
				}
			} else {
				v__gen__c__Gen_ref_or_deref_arg(g, arg, (*(v__ast__Type*)/*ee elem_typ */array_get(expected_types, i)), node.language);
			}
		} else {
			if (use_tmp_var_autofree) {
				string fn_name = string_replace(node.name, _SLIT("."), _SLIT("_"));
				string name =  str_intp(4, _MOV((StrIntpData[]){{_SLIT("_arg_expr_"), 0xfe10, {.d_s = fn_name}}, {_SLIT("_"), 0xfe07, {.d_i32 = i + 1}}, {_SLIT("_"), 0xfe07, {.d_i32 = node.pos.pos}}, {_SLIT0, 0, { .d_c = 0 }}}));
				v__gen__c__Gen_write(g, string__plus(_SLIT("/*af arg2*/"), name));
			} else {
				v__gen__c__Gen_expr(g, arg.expr);
			}
		}
		if (i < args.len - 1 || is_variadic) {
			v__gen__c__Gen_write(g, _SLIT(", "));
		}
	}
	int arg_nr = expected_types.len - 1;
	if (is_variadic) {
		v__ast__Type varg_type = (*(v__ast__Type*)array_last(expected_types));
		int variadic_count = args.len - arg_nr;
		v__ast__TypeSymbol* arr_sym = v__ast__Table_sym(g->table, varg_type);
		v__ast__Array arr_info = /* as */ *(v__ast__Array*)__as_cast((arr_sym->info)._v__ast__Array,(arr_sym->info)._typ, 441) /*expected idx: 441, name: v.ast.Array */ ;
		if (v__ast__Type_has_flag(varg_type, v__ast__TypeFlag__generic)) {
			Option_v__ast__Fn _t2;
			if (_t2 = v__ast__Table_find_fn(g->table, node.name), _t2.state == 0) {
				v__ast__Fn fn_def = *(v__ast__Fn*)_t2.data;
				v__ast__Table* muttable = ((v__ast__Table*)(g->table));
				Option_v__ast__Type _t3;
				if (_t3 = v__ast__Table_resolve_generic_to_concrete(muttable, arr_info.elem_type, fn_def.generic_names, node.concrete_types), _t3.state == 0) {
					v__ast__Type utyp = *(v__ast__Type*)_t3.data;
					arr_info.elem_type = utyp;
				}
			} else {
				IError err = _t2.err;
				v__gen__c__Gen_error(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unable to find function "), 0xfe10, {.d_s = node.name}}, {_SLIT0, 0, { .d_c = 0 }}})), node.pos);
				VUNREACHABLE();
			}
		}
		string elem_type = v__gen__c__Gen_typ(g, arr_info.elem_type);
		if (g->pref->translated && args.len == 1) {
			v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(args, 0)).expr);
		} else if (args.len > 0 && ((*(v__ast__CallArg*)/*ee elem_typ */array_get(args, args.len - 1)).expr)._typ == 279 /* v.ast.ArrayDecompose */) {
			v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(args, args.len - 1)).expr);
		} else {
			if (variadic_count > 0) {
				string noscan = v__gen__c__Gen_check_noscan(g, arr_info.elem_type);
				v__gen__c__Gen_write(g,  str_intp(7, _MOV((StrIntpData[]){{_SLIT("new_array_from_c_array"), 0xfe10, {.d_s = noscan}}, {_SLIT("("), 0xfe07, {.d_i32 = variadic_count}}, {_SLIT(", "), 0xfe07, {.d_i32 = variadic_count}}, {_SLIT(", sizeof("), 0xfe10, {.d_s = elem_type}}, {_SLIT("), _MOV(("), 0xfe10, {.d_s = elem_type}}, {_SLIT("["), 0xfe07, {.d_i32 = variadic_count}}, {_SLIT("]){"), 0, { .d_c = 0 }}})));
				for (int j = arg_nr; j < args.len; ++j) {
					v__gen__c__Gen_ref_or_deref_arg(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(args, j)), arr_info.elem_type, node.language);
					if (j < args.len - 1) {
						v__gen__c__Gen_write(g, _SLIT(", "));
					}
				}
				v__gen__c__Gen_write(g, _SLIT("}))"));
			} else {
				v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("__new_array(0, 0, sizeof("), 0xfe10, {.d_s = elem_type}}, {_SLIT("))"), 0, { .d_c = 0 }}})));
			}
		}
	}
}

VV_LOCAL_SYMBOL int v__gen__c__Gen_keep_alive_call_pregen(v__gen__c__Gen* g, v__ast__CallExpr node) {
	g->empty_line = true;
	v__gen__c__Gen_writeln(g, _SLIT("// keep_alive_call_pregen()"));
	int tmp_cnt_save = g->tmp_count + 1;
	g->tmp_count += node.args.len;
	for (int i = 0; i < node.args.len; ++i) {
		v__ast__CallArg arg = ((v__ast__CallArg*)node.args.data)[i];
		v__ast__Type expected_type = (*(v__ast__Type*)/*ee elem_typ */array_get(node.expected_arg_types, i));
		string typ = v__ast__Table_sym(g->table, expected_type)->cname;
		v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = typ}}, {_SLIT(" __tmp_arg_"), 0xfe07, {.d_i32 = tmp_cnt_save + i}}, {_SLIT(" = "), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_ref_or_deref_arg(g, arg, expected_type, node.language);
		v__gen__c__Gen_writeln(g, _SLIT(";"));
	}
	g->empty_line = false;
	int _t1 = tmp_cnt_save;
	return _t1;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_keep_alive_call_postgen(v__gen__c__Gen* g, v__ast__CallExpr node, int tmp_cnt_save) {
	v__gen__c__Gen_writeln(g, _SLIT("// keep_alive_call_postgen()"));
	for (int i = 0; i < node.expected_arg_types.len; ++i) {
		v__ast__Type expected_type = ((v__ast__Type*)node.expected_arg_types.data)[i];
		if (v__ast__Type_is_ptr(expected_type) || v__ast__Type_is_pointer(expected_type)) {
			v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("GC_reachable_here(__tmp_arg_"), 0xfe07, {.d_i32 = tmp_cnt_save + i}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
		}
	}
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL void v__gen__c__Gen_ref_or_deref_arg(v__gen__c__Gen* g, v__ast__CallArg arg, v__ast__Type expected_type, v__ast__Language lang) {
	bool arg_is_ptr = v__ast__Type_is_ptr(expected_type) || Array_int_contains(_const_v__ast__pointer_type_idxs, v__ast__Type_idx(expected_type));
	bool expr_is_ptr = v__ast__Type_is_ptr(arg.typ) || Array_int_contains(_const_v__ast__pointer_type_idxs, v__ast__Type_idx(arg.typ));
	if (expected_type == 0) {
		v__gen__c__Gen_checker_bug(g, _SLIT("ref_or_deref_arg expected_type is 0"), arg.pos);
	}
	v__ast__TypeSymbol* exp_sym = v__ast__Table_sym(g->table, expected_type);
	v__ast__Type arg_typ = v__gen__c__Gen_unwrap_generic(g, arg.typ);
	bool needs_closing = false;
	if (arg.is_mut && !arg_is_ptr) {
		v__gen__c__Gen_write(g, _SLIT("&/*mut*/"));
	} else if (arg_is_ptr && !expr_is_ptr) {
		if (arg.is_mut) {
			if (exp_sym->kind == v__ast__Kind__array) {
				if (((arg.expr)._typ == 299 /* v.ast.Ident */ && (/* as */ *(v__ast__Ident*)__as_cast((arg.expr)._v__ast__Ident,(arg.expr)._typ, 299) /*expected idx: 299, name: v.ast.Ident */ ).kind == v__ast__IdentKind__variable) || (arg.expr)._typ == 319 /* v.ast.SelectorExpr */) {
					v__gen__c__Gen_write(g, _SLIT("&/*arr*/"));
					v__gen__c__Gen_expr(g, arg.expr);
				} else {
					v__gen__c__Gen_write(g, _SLIT("&/*111*/(array[]){"));
					v__gen__c__Gen_expr(g, arg.expr);
					v__gen__c__Gen_write(g, _SLIT("}[0]"));
				}
				return;
			}
		}
		if (!g->is_json_fn) {
			if (arg_typ == 0) {
				v__gen__c__Gen_checker_bug(g, _SLIT("ref_or_deref_arg arg.typ is 0"), arg.pos);
			}
			v__ast__TypeSymbol* arg_typ_sym = v__ast__Table_sym(g->table, arg_typ);
			v__ast__Type expected_deref_type = (v__ast__Type_is_ptr(expected_type) ? (v__ast__Type_deref(expected_type)) : (expected_type));
			v__ast__TypeSymbol* deref_sym = v__ast__Table_sym(g->table, expected_deref_type);
			if (!((arg_typ_sym->kind == v__ast__Kind__function) || (deref_sym->kind == v__ast__Kind__sum_type || deref_sym->kind == v__ast__Kind__interface_)) && lang != v__ast__Language__c) {
				if (v__ast__Expr_is_lvalue(arg.expr)) {
					v__gen__c__Gen_write(g, _SLIT("(voidptr)&/*qq*/"));
				} else {
					v__ast__Type atype = expected_deref_type;
					if (v__ast__Type_has_flag(atype, v__ast__TypeFlag__generic)) {
						atype = v__gen__c__Gen_unwrap_generic(g, atype);
					}
					if (v__ast__Type_has_flag(atype, v__ast__TypeFlag__generic)) {
						v__gen__c__Gen_write(g, _SLIT("(voidptr)&/*qq*/"));
					} else {
						needs_closing = true;
						v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("ADDR("), 0xfe10, {.d_s = v__gen__c__Gen_typ(g, atype)}}, {_SLIT("/*qq*/, "), 0, { .d_c = 0 }}})));
					}
				}
			}
		}
	} else if (v__ast__Type_has_flag(arg_typ, v__ast__TypeFlag__shared_f) && !v__ast__Type_has_flag(expected_type, v__ast__TypeFlag__shared_f)) {
		if (v__ast__Type_is_ptr(expected_type)) {
			v__gen__c__Gen_write(g, _SLIT("&"));
		}
		v__gen__c__Gen_expr(g, arg.expr);
		v__gen__c__Gen_write(g, _SLIT("->val"));
		return;
	}
	v__gen__c__Gen_expr_with_cast(g, arg.expr, arg_typ, expected_type);
	if (needs_closing) {
		v__gen__c__Gen_write(g, _SLIT(")"));
	}
}

VV_LOCAL_SYMBOL bool v__gen__c__Gen_is_gui_app(v__gen__c__Gen* g) {
	if (g->pref->os == v__pref__OS__windows) {
		if (g->force_main_console) {
			bool _t1 = false;
			return _t1;
		}
		for (int _t2 = 0; _t2 < g->table->cflags.len; ++_t2) {
			v__cflag__CFlag cf = ((v__cflag__CFlag*)g->table->cflags.data)[_t2];
			if (string__eq(string_to_lower(cf.value), _SLIT("gdi32"))) {
				bool _t3 = true;
				return _t3;
			}
		}
	}
	bool _t4 = false;
	return _t4;
}

VV_LOCAL_SYMBOL bool v__gen__c__Gen_fileis(v__gen__c__Gen* g, string s) {
	bool _t1 = string_contains(g->file->path, s);
	return _t1;
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_write_fn_attrs(v__gen__c__Gen* g, Array_v__ast__Attr attrs) {
	string fn_attrs = _SLIT("");
	for (int _t1 = 0; _t1 < attrs.len; ++_t1) {
		v__ast__Attr attr = ((v__ast__Attr*)attrs.data)[_t1];

		if (string__eq(attr.name, _SLIT("inline"))) {
			v__gen__c__Gen_write(g, _SLIT("inline "));
		}
		else if (string__eq(attr.name, _SLIT("noinline"))) {
			v__gen__c__Gen_write(g, _SLIT("__NOINLINE "));
		}
		else if (string__eq(attr.name, _SLIT("weak"))) {
			v__gen__c__Gen_write(g, _SLIT("VWEAK "));
		}
		else if (string__eq(attr.name, _SLIT("noreturn"))) {
			v__gen__c__Gen_write(g, _SLIT("VNORETURN "));
		}
		else if (string__eq(attr.name, _SLIT("irq_handler"))) {
			v__gen__c__Gen_write(g, _SLIT("__IRQHANDLER "));
		}
		else if (string__eq(attr.name, _SLIT("_cold"))) {
			v__gen__c__Gen_write(g, _SLIT("__attribute__((cold)) "));
		}
		else if (string__eq(attr.name, _SLIT("_constructor"))) {
			v__gen__c__Gen_write(g, _SLIT("__attribute__((constructor)) "));
		}
		else if (string__eq(attr.name, _SLIT("_destructor"))) {
			v__gen__c__Gen_write(g, _SLIT("__attribute__((destructor)) "));
		}
		else if (string__eq(attr.name, _SLIT("_flatten"))) {
			v__gen__c__Gen_write(g, _SLIT("__attribute__((flatten)) "));
		}
		else if (string__eq(attr.name, _SLIT("_hot"))) {
			v__gen__c__Gen_write(g, _SLIT("__attribute__((hot)) "));
		}
		else if (string__eq(attr.name, _SLIT("_malloc"))) {
			v__gen__c__Gen_write(g, _SLIT("__attribute__((malloc)) "));
		}
		else if (string__eq(attr.name, _SLIT("_pure"))) {
			v__gen__c__Gen_write(g, _SLIT("__attribute__((const)) "));
		}
		else if (string__eq(attr.name, _SLIT("_naked"))) {
			v__gen__c__Gen_write(g, _SLIT("__attribute__((naked)) "));
		}
		else if (string__eq(attr.name, _SLIT("windows_stdcall"))) {
			fn_attrs = /*f*/string__plus(fn_attrs, _SLIT("__stdcall "));
		}
		else if (string__eq(attr.name, _SLIT("console"))) {
			g->force_main_console = true;
		}
		else {
		};
	}
	string _t2 = fn_attrs;
	return _t2;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_index_expr(v__gen__c__Gen* g, v__ast__IndexExpr node) {
	if ((node.index)._typ == 317 /* v.ast.RangeExpr */) {
		v__gen__c__Gen_range_expr(g, node, (*node.index._v__ast__RangeExpr));
	} else {
		v__ast__TypeSymbol* sym = v__ast__Table_final_sym(g->table, node.left_type);
		if (sym->kind == v__ast__Kind__array) {
			v__gen__c__Gen_index_of_array(g, node, *sym);
		} else if (sym->kind == v__ast__Kind__array_fixed) {
			v__gen__c__Gen_index_of_fixed_array(g, node, *sym);
		} else if (sym->kind == v__ast__Kind__map) {
			v__gen__c__Gen_index_of_map(g, node, *sym);
		} else if (sym->kind == v__ast__Kind__string && !v__ast__Type_is_ptr(node.left_type)) {
			bool is_direct_array_access = (g->fn_decl != 0 && g->fn_decl->is_direct_arr) || node.is_direct;
			if (is_direct_array_access) {
				v__gen__c__Gen_expr(g, node.left);
				v__gen__c__Gen_write(g, _SLIT(".str[ "));
				v__gen__c__Gen_expr(g, node.index);
				v__gen__c__Gen_write(g, _SLIT("]"));
			} else {
				bool gen_or = node.or_expr.kind != v__ast__OrKind__absent || node.is_option;
				if (gen_or) {
					string tmp_opt = v__gen__c__Gen_new_tmp_var(g);
					string cur_line = v__gen__c__Gen_go_before_stmt(g, 0);
					strings__Builder_write_string(&g->out, v__util__tabs(g->indent));
					string opt_elem_type = v__gen__c__Gen_typ(g, v__ast__Type_set_flag(_const_v__ast__byte_type, v__ast__TypeFlag__optional));
					v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = opt_elem_type}}, {_SLIT(" "), 0xfe10, {.d_s = tmp_opt}}, {_SLIT(" = string_at_with_check("), 0, { .d_c = 0 }}})));
					v__gen__c__Gen_expr(g, node.left);
					v__gen__c__Gen_write(g, _SLIT(", "));
					v__gen__c__Gen_expr(g, node.index);
					v__gen__c__Gen_writeln(g, _SLIT(");"));
					if (!node.is_option) {
						v__gen__c__Gen_or_block(g, tmp_opt, node.or_expr, _const_v__ast__byte_type);
					}
					v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\n"), 0xfe10, {.d_s = cur_line}}, {_SLIT("*(byte*)&"), 0xfe10, {.d_s = tmp_opt}}, {_SLIT(".data"), 0, { .d_c = 0 }}})));
				} else {
					v__gen__c__Gen_write(g, _SLIT("string_at("));
					v__gen__c__Gen_expr(g, node.left);
					v__gen__c__Gen_write(g, _SLIT(", "));
					v__gen__c__Gen_expr(g, node.index);
					v__gen__c__Gen_write(g, _SLIT(")"));
				}
			}
		} else {
			v__gen__c__Gen_expr(g, node.left);
			v__gen__c__Gen_write(g, _SLIT("["));
			v__gen__c__Gen_expr(g, node.index);
			v__gen__c__Gen_write(g, _SLIT("]"));
		}
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_range_expr(v__gen__c__Gen* g, v__ast__IndexExpr node, v__ast__RangeExpr range) {
	v__ast__TypeSymbol* sym = v__ast__Table_final_sym(g->table, node.left_type);
	if (sym->kind == v__ast__Kind__string) {
		if (node.is_gated) {
			v__gen__c__Gen_write(g, _SLIT("string_substr_ni("));
		} else {
			v__gen__c__Gen_write(g, _SLIT("string_substr("));
		}
		v__gen__c__Gen_expr(g, node.left);
	} else if (sym->kind == v__ast__Kind__array) {
		if (node.is_gated) {
			v__gen__c__Gen_write(g, _SLIT("array_slice_ni("));
		} else {
			v__gen__c__Gen_write(g, _SLIT("array_slice("));
		}
		if (v__ast__Type_is_ptr(node.left_type)) {
			v__gen__c__Gen_write(g, _SLIT("*"));
		}
		v__gen__c__Gen_expr(g, node.left);
	} else if (sym->kind == v__ast__Kind__array_fixed) {
		v__ast__ArrayFixed info = /* as */ *(v__ast__ArrayFixed*)__as_cast((sym->info)._v__ast__ArrayFixed,(sym->info)._typ, 468) /*expected idx: 468, name: v.ast.ArrayFixed */ ;
		string noscan = v__gen__c__Gen_check_noscan(g, info.elem_type);
		if (node.is_gated) {
			v__gen__c__Gen_write(g, _SLIT("array_slice_ni("));
		} else {
			v__gen__c__Gen_write(g, _SLIT("array_slice("));
		}
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("new_array_from_c_array"), 0xfe10, {.d_s = noscan}}, {_SLIT("("), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = info.size}}, {_SLIT0, 0, { .d_c = 0 }}})));
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(", "), 0xfe07, {.d_i32 = info.size}}, {_SLIT0, 0, { .d_c = 0 }}})));
		v__gen__c__Gen_write(g, _SLIT(", sizeof("));
		if (v__ast__Type_is_ptr(node.left_type)) {
			v__gen__c__Gen_write(g, _SLIT("(*"));
		}
		v__gen__c__Gen_expr(g, node.left);
		if (v__ast__Type_is_ptr(node.left_type)) {
			v__gen__c__Gen_write(g, _SLIT(")"));
		}
		v__gen__c__Gen_write(g, _SLIT("[0]), "));
		if (v__ast__Type_is_ptr(node.left_type)) {
			v__gen__c__Gen_write(g, _SLIT("*"));
		}
		v__gen__c__Gen_expr(g, node.left);
		v__gen__c__Gen_write(g, _SLIT(")"));
	} else {
		v__gen__c__Gen_expr(g, node.left);
	}
	v__gen__c__Gen_write(g, _SLIT(", "));
	if (range.has_low) {
		v__gen__c__Gen_expr(g, range.low);
	} else {
		v__gen__c__Gen_write(g, _SLIT("0"));
	}
	v__gen__c__Gen_write(g, _SLIT(", "));
	if (range.has_high) {
		v__gen__c__Gen_expr(g, range.high);
	} else if (sym->kind == v__ast__Kind__array_fixed) {
		v__ast__ArrayFixed info = /* as */ *(v__ast__ArrayFixed*)__as_cast((sym->info)._v__ast__ArrayFixed,(sym->info)._typ, 468) /*expected idx: 468, name: v.ast.ArrayFixed */ ;
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = info.size}}, {_SLIT0, 0, { .d_c = 0 }}})));
	} else if (v__ast__Type_is_ptr(node.left_type)) {
		v__gen__c__Gen_write(g, _SLIT("("));
		v__gen__c__Gen_write(g, _SLIT("*"));
		v__gen__c__Gen_expr(g, node.left);
		v__gen__c__Gen_write(g, _SLIT(")"));
		v__gen__c__Gen_write(g, _SLIT(".len"));
	} else {
		v__gen__c__Gen_expr(g, node.left);
		v__gen__c__Gen_write(g, _SLIT(".len"));
	}
	v__gen__c__Gen_write(g, _SLIT(")"));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_index_of_array(v__gen__c__Gen* g, v__ast__IndexExpr node, v__ast__TypeSymbol sym) {
	bool gen_or = node.or_expr.kind != v__ast__OrKind__absent || node.is_option;
	bool left_is_ptr = v__ast__Type_is_ptr(node.left_type);
	v__ast__Array info = /* as */ *(v__ast__Array*)__as_cast((sym.info)._v__ast__Array,(sym.info)._typ, 441) /*expected idx: 441, name: v.ast.Array */ ;
	string elem_type_str = v__gen__c__Gen_typ(g, info.elem_type);
	v__ast__Type elem_type = info.elem_type;
	v__ast__TypeSymbol* elem_typ = v__ast__Table_sym(g->table, elem_type);
	bool is_selector = (node.left)._typ == 319 /* v.ast.SelectorExpr */;
	if (g->is_assign_lhs && !is_selector && node.is_setter) {
		bool is_direct_array_access = (g->fn_decl != 0 && g->fn_decl->is_direct_arr) || node.is_direct;
		bool is_op_assign = g->assign_op != v__token__Kind__assign && !v__ast__Type_alias_eq(info.elem_type, _const_v__ast__string_type);
		string array_ptr_type_str = ((elem_typ->kind == (v__ast__Kind__function)) ? (_SLIT("voidptr*")) : ( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = elem_type_str}}, {_SLIT("*"), 0, { .d_c = 0 }}}))));
		if (is_direct_array_access) {
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("(("), 0xfe10, {.d_s = array_ptr_type_str}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
		} else if (is_op_assign) {
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("(*("), 0xfe10, {.d_s = array_ptr_type_str}}, {_SLIT(")array_get("), 0, { .d_c = 0 }}})));
			if (left_is_ptr && !v__ast__Type_has_flag(node.left_type, v__ast__TypeFlag__shared_f)) {
				v__gen__c__Gen_write(g, _SLIT("*"));
			}
		} else {
			g->is_arraymap_set = true;
			v__gen__c__Gen_write(g, _SLIT("array_set("));
			if (!left_is_ptr || v__ast__Type_has_flag(node.left_type, v__ast__TypeFlag__shared_f)) {
				v__gen__c__Gen_write(g, _SLIT("&"));
			}
		}
		v__gen__c__Gen_expr(g, node.left);
		if (v__ast__Type_has_flag(node.left_type, v__ast__TypeFlag__shared_f)) {
			if (left_is_ptr) {
				v__gen__c__Gen_write(g, _SLIT("->val"));
			} else {
				v__gen__c__Gen_write(g, _SLIT(".val"));
			}
		}
		if (is_direct_array_access) {
			if (left_is_ptr && !v__ast__Type_has_flag(node.left_type, v__ast__TypeFlag__shared_f)) {
				v__gen__c__Gen_write(g, _SLIT("->"));
			} else {
				v__gen__c__Gen_write(g, _SLIT("."));
			}
			v__gen__c__Gen_write(g, _SLIT("data)["));
			v__gen__c__Gen_expr(g, node.index);
			v__gen__c__Gen_write(g, _SLIT("]"));
		} else {
			v__gen__c__Gen_write(g, _SLIT(", "));
			v__gen__c__Gen_expr(g, node.index);
			if (!is_op_assign) {
				bool need_wrapper = true;
				if (need_wrapper) {
					if (elem_typ->kind == v__ast__Kind__function) {
						v__gen__c__Gen_write(g, _SLIT(", &(voidptr[]) { "));
					} else {
						v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(", &("), 0xfe10, {.d_s = elem_type_str}}, {_SLIT("[]) { "), 0, { .d_c = 0 }}})));
					}
				} else {
					v__gen__c__Gen_write(g, _SLIT(", &"));
				}
			} else {
				v__gen__c__Gen_write(g, _SLIT("))"));
			}
		}
	} else {
		bool is_direct_array_access = (g->fn_decl != 0 && g->fn_decl->is_direct_arr) || node.is_direct;
		string array_ptr_type_str = ((elem_typ->kind == (v__ast__Kind__function)) ? (_SLIT("voidptr*")) : ( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = elem_type_str}}, {_SLIT("*"), 0, { .d_c = 0 }}}))));
		bool needs_clone = info.elem_type == _const_v__ast__string_type_idx && g->is_autofree && !(g->inside_return && v__ast__Type_has_flag(g->fn_decl->return_type, v__ast__TypeFlag__optional)) && !g->is_assign_lhs;
		bool is_gen_or_and_assign_rhs = gen_or && !g->discard_or_result;
		string _t1; /* if prepend */
		if (is_gen_or_and_assign_rhs) {
			string line = v__gen__c__Gen_go_before_stmt(g, 0);
			strings__Builder_write_string(&g->out, v__util__tabs(g->indent));
			_t1 = line;
		} else {
			_t1 = _SLIT("");
		}
		string cur_line =  _t1;
		string tmp_opt = (gen_or ? (v__gen__c__Gen_new_tmp_var(g)) : (_SLIT("")));
		string tmp_opt_ptr = (gen_or ? (v__gen__c__Gen_new_tmp_var(g)) : (_SLIT("")));
		if (gen_or) {
			v__gen__c__Gen_write(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = array_ptr_type_str}}, {_SLIT(" "), 0xfe10, {.d_s = tmp_opt_ptr}}, {_SLIT(" = ("), 0xfe10, {.d_s = array_ptr_type_str}}, {_SLIT(")/*ee elem_ptr_typ */(array_get_with_check("), 0, { .d_c = 0 }}})));
		} else {
			if (needs_clone) {
				v__gen__c__Gen_write(g, _SLIT("/*2*/string_clone("));
			}
			if (g->is_fn_index_call) {
				if ((elem_typ->info)._typ == 472 /* v.ast.FnType */) {
					v__gen__c__Gen_write(g, _SLIT("(("));
					v__gen__c__Gen_write_fn_ptr_decl(g, &(*elem_typ->info._v__ast__FnType), _SLIT(""));
					v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(")(*("), 0xfe10, {.d_s = array_ptr_type_str}}, {_SLIT(")/*ee elem_typ */array_get("), 0, { .d_c = 0 }}})));
				}
				if (left_is_ptr && !v__ast__Type_has_flag(node.left_type, v__ast__TypeFlag__shared_f)) {
					v__gen__c__Gen_write(g, _SLIT("*"));
				}
			} else if (is_direct_array_access) {
				v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("(("), 0xfe10, {.d_s = array_ptr_type_str}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
			} else {
				v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("(*("), 0xfe10, {.d_s = array_ptr_type_str}}, {_SLIT(")/*ee elem_typ */array_get("), 0, { .d_c = 0 }}})));
				if (left_is_ptr && !v__ast__Type_has_flag(node.left_type, v__ast__TypeFlag__shared_f)) {
					v__gen__c__Gen_write(g, _SLIT("*"));
				}
			}
		}
		v__gen__c__Gen_expr(g, node.left);
		if (v__ast__Type_has_flag(node.left_type, v__ast__TypeFlag__shared_f)) {
			if (left_is_ptr) {
				v__gen__c__Gen_write(g, _SLIT("->val"));
			} else {
				v__gen__c__Gen_write(g, _SLIT(".val"));
			}
		}
		if (is_direct_array_access && !gen_or) {
			if (left_is_ptr && !v__ast__Type_has_flag(node.left_type, v__ast__TypeFlag__shared_f)) {
				v__gen__c__Gen_write(g, _SLIT("->"));
			} else {
				v__gen__c__Gen_write(g, _SLIT("."));
			}
			v__gen__c__Gen_write(g, _SLIT("data)["));
			v__gen__c__Gen_expr(g, node.index);
			v__gen__c__Gen_write(g, _SLIT("]"));
		} else {
			v__gen__c__Gen_write(g, _SLIT(", "));
			v__gen__c__Gen_expr(g, node.index);
			if (g->is_fn_index_call) {
				v__gen__c__Gen_write(g, _SLIT(")))"));
			} else {
				v__gen__c__Gen_write(g, _SLIT("))"));
			}
		}
		if (needs_clone) {
			v__gen__c__Gen_write(g, _SLIT(")"));
		}
		if (gen_or) {
			v__gen__c__Gen_writeln(g, _SLIT(";"));
			string opt_elem_type = v__gen__c__Gen_typ(g, v__ast__Type_set_flag(elem_type, v__ast__TypeFlag__optional));
			v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = opt_elem_type}}, {_SLIT(" "), 0xfe10, {.d_s = tmp_opt}}, {_SLIT(" = {0};"), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("if ("), 0xfe10, {.d_s = tmp_opt_ptr}}, {_SLIT(") {"), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_writeln(g,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("\t*(("), 0xfe10, {.d_s = elem_type_str}}, {_SLIT("*)&"), 0xfe10, {.d_s = tmp_opt}}, {_SLIT(".data) = *(("), 0xfe10, {.d_s = elem_type_str}}, {_SLIT("*)"), 0xfe10, {.d_s = tmp_opt_ptr}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_writeln(g, _SLIT("} else {"));
			v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = tmp_opt}}, {_SLIT(".state = 2; "), 0xfe10, {.d_s = tmp_opt}}, {_SLIT(".err = _v_error(_SLIT(\"array index out of range\"));"), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_writeln(g, _SLIT("}"));
			if (!node.is_option) {
				v__gen__c__Gen_or_block(g, tmp_opt, node.or_expr, elem_type);
			}
			v__gen__c__Gen_write(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\n"), 0xfe10, {.d_s = cur_line}}, {_SLIT("*("), 0xfe10, {.d_s = elem_type_str}}, {_SLIT("*)"), 0xfe10, {.d_s = tmp_opt}}, {_SLIT(".data"), 0, { .d_c = 0 }}})));
		}
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_index_of_fixed_array(v__gen__c__Gen* g, v__ast__IndexExpr node, v__ast__TypeSymbol sym) {
	v__ast__ArrayFixed info = /* as */ *(v__ast__ArrayFixed*)__as_cast((sym.info)._v__ast__ArrayFixed,(sym.info)._typ, 468) /*expected idx: 468, name: v.ast.ArrayFixed */ ;
	v__ast__Type elem_type = info.elem_type;
	v__ast__TypeSymbol* elem_sym = v__ast__Table_sym(g->table, elem_type);
	bool is_fn_index_call = g->is_fn_index_call && (elem_sym->info)._typ == 472 /* v.ast.FnType */;
	if (is_fn_index_call) {
		v__gen__c__Gen_write(g, _SLIT("(*"));
	}
	if (v__ast__Type_is_ptr(node.left_type)) {
		v__gen__c__Gen_write(g, _SLIT("(*"));
		v__gen__c__Gen_expr(g, node.left);
		v__gen__c__Gen_write(g, _SLIT(")"));
	} else {
		v__gen__c__Gen_expr(g, node.left);
	}
	v__gen__c__Gen_write(g, _SLIT("["));
	bool direct = g->fn_decl != 0 && g->fn_decl->is_direct_arr;
	if (direct || (node.index)._typ == 304 /* v.ast.IntegerLiteral */) {
		v__gen__c__Gen_expr(g, node.index);
	} else {
		v__gen__c__Gen_write(g, _SLIT("v_fixed_index("));
		v__gen__c__Gen_expr(g, node.index);
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(", "), 0xfe07, {.d_i32 = info.size}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
	}
	v__gen__c__Gen_write(g, _SLIT("]"));
	if (is_fn_index_call) {
		v__gen__c__Gen_write(g, _SLIT(")"));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_index_of_map(v__gen__c__Gen* g, v__ast__IndexExpr node, v__ast__TypeSymbol sym) {
	bool gen_or = node.or_expr.kind != v__ast__OrKind__absent || node.is_option;
	bool left_is_ptr = v__ast__Type_is_ptr(node.left_type);
	v__ast__Map info = /* as */ *(v__ast__Map*)__as_cast((sym.info)._v__ast__Map,(sym.info)._typ, 442) /*expected idx: 442, name: v.ast.Map */ ;
	string key_type_str = v__gen__c__Gen_typ(g, info.key_type);
	v__ast__Type elem_type = info.value_type;
	string elem_type_str = v__gen__c__Gen_typ(g, elem_type);
	v__ast__TypeSymbol* elem_typ = v__ast__Table_sym(g->table, elem_type);
	bool get_and_set_types = (elem_typ->kind == v__ast__Kind__struct_ || elem_typ->kind == v__ast__Kind__map);
	if (g->is_assign_lhs && !g->is_arraymap_set && !get_and_set_types) {
		if (g->assign_op == v__token__Kind__assign || v__ast__Type_alias_eq(info.value_type, _const_v__ast__string_type)) {
			g->is_arraymap_set = true;
			v__gen__c__Gen_write(g, _SLIT("map_set("));
		} else {
			if (node.is_setter) {
				v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("(*(("), 0xfe10, {.d_s = elem_type_str}}, {_SLIT("*)map_get_and_set((map*)"), 0, { .d_c = 0 }}})));
			} else {
				v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("(*(("), 0xfe10, {.d_s = elem_type_str}}, {_SLIT("*)map_get((map*)"), 0, { .d_c = 0 }}})));
			}
		}
		if (!left_is_ptr || v__ast__Type_has_flag(node.left_type, v__ast__TypeFlag__shared_f)) {
			v__gen__c__Gen_write(g, _SLIT("&"));
		}
		if ((node.left)._typ == 302 /* v.ast.IndexExpr */) {
			g->inside_map_index = true;
			v__gen__c__Gen_expr(g, node.left);
			g->inside_map_index = false;
		} else {
			v__gen__c__Gen_expr(g, node.left);
		}
		if (v__ast__Type_has_flag(node.left_type, v__ast__TypeFlag__shared_f)) {
			v__gen__c__Gen_write(g, _SLIT("->val"));
		}
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(", &("), 0xfe10, {.d_s = key_type_str}}, {_SLIT("[]){"), 0, { .d_c = 0 }}})));
		bool old_is_arraymap_set = g->is_arraymap_set;
		bool old_is_assign_lhs = g->is_assign_lhs;
		g->is_arraymap_set = false;
		g->is_assign_lhs = false;
		v__gen__c__Gen_expr(g, node.index);
		g->is_arraymap_set = old_is_arraymap_set;
		g->is_assign_lhs = old_is_assign_lhs;
		v__gen__c__Gen_write(g, _SLIT("}"));
		if (elem_typ->kind == v__ast__Kind__function) {
			v__gen__c__Gen_write(g, _SLIT(", &(voidptr[]) { "));
		} else {
			g->arraymap_set_pos = g->out.len;
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(", &("), 0xfe10, {.d_s = elem_type_str}}, {_SLIT("[]) { "), 0, { .d_c = 0 }}})));
		}
		if (g->assign_op != v__token__Kind__assign && !v__ast__Type_alias_eq(info.value_type, _const_v__ast__string_type)) {
			string zero = v__gen__c__Gen_type_default(g, info.value_type);
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = zero}}, {_SLIT(" })))"), 0, { .d_c = 0 }}})));
		}
	} else if (g->inside_map_postfix || g->inside_map_infix || g->inside_map_index || (g->is_assign_lhs && !g->is_arraymap_set && get_and_set_types)) {
		string zero = v__gen__c__Gen_type_default(g, info.value_type);
		if (node.is_setter) {
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("(*("), 0xfe10, {.d_s = elem_type_str}}, {_SLIT("*)map_get_and_set((map*)"), 0, { .d_c = 0 }}})));
		} else {
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("(*("), 0xfe10, {.d_s = elem_type_str}}, {_SLIT("*)map_get((map*)"), 0, { .d_c = 0 }}})));
		}
		if (!left_is_ptr || v__ast__Type_has_flag(node.left_type, v__ast__TypeFlag__shared_f)) {
			v__gen__c__Gen_write(g, _SLIT("&"));
		}
		v__gen__c__Gen_expr(g, node.left);
		if (v__ast__Type_has_flag(node.left_type, v__ast__TypeFlag__shared_f)) {
			v__gen__c__Gen_write(g, _SLIT("->val"));
		}
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(", &("), 0xfe10, {.d_s = key_type_str}}, {_SLIT("[]){"), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_expr(g, node.index);
		v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("}, &("), 0xfe10, {.d_s = elem_type_str}}, {_SLIT("[]){ "), 0xfe10, {.d_s = zero}}, {_SLIT(" }))"), 0, { .d_c = 0 }}})));
	} else {
		string zero = v__gen__c__Gen_type_default(g, info.value_type);
		bool is_gen_or_and_assign_rhs = gen_or && !g->discard_or_result;
		string _t1; /* if prepend */
		if (is_gen_or_and_assign_rhs) {
			string line = v__gen__c__Gen_go_before_stmt(g, 0);
			strings__Builder_write_string(&g->out, v__util__tabs(g->indent));
			_t1 = line;
		} else {
			_t1 = _SLIT("");
		}
		string cur_line =  _t1;
		string tmp_opt = (gen_or ? (v__gen__c__Gen_new_tmp_var(g)) : (_SLIT("")));
		string tmp_opt_ptr = (gen_or ? (v__gen__c__Gen_new_tmp_var(g)) : (_SLIT("")));
		if (gen_or) {
			v__gen__c__Gen_write(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = elem_type_str}}, {_SLIT("* "), 0xfe10, {.d_s = tmp_opt_ptr}}, {_SLIT(" = ("), 0xfe10, {.d_s = elem_type_str}}, {_SLIT("*)/*ee elem_ptr_typ */(map_get_check("), 0, { .d_c = 0 }}})));
		} else {
			if (g->is_fn_index_call) {
				if ((elem_typ->info)._typ == 472 /* v.ast.FnType */) {
					v__gen__c__Gen_write(g, _SLIT("(("));
					v__gen__c__Gen_write_fn_ptr_decl(g, &(*elem_typ->info._v__ast__FnType), _SLIT(""));
					v__gen__c__Gen_write(g, _SLIT(")(*(voidptr*)map_get("));
				}
			} else if (elem_typ->kind == v__ast__Kind__function) {
				v__gen__c__Gen_write(g, _SLIT("(*(voidptr*)map_get("));
			} else {
				v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("(*("), 0xfe10, {.d_s = elem_type_str}}, {_SLIT("*)map_get("), 0, { .d_c = 0 }}})));
			}
		}
		if (!left_is_ptr || v__ast__Type_has_flag(node.left_type, v__ast__TypeFlag__shared_f)) {
			v__gen__c__Gen_write(g, _SLIT("ADDR(map, "));
			v__gen__c__Gen_expr(g, node.left);
		} else {
			v__gen__c__Gen_write(g, _SLIT("("));
			v__gen__c__Gen_expr(g, node.left);
		}
		if (v__ast__Type_has_flag(node.left_type, v__ast__TypeFlag__shared_f)) {
			if (left_is_ptr) {
				v__gen__c__Gen_write(g, _SLIT("->val"));
			} else {
				v__gen__c__Gen_write(g, _SLIT(".val"));
			}
		}
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("), &("), 0xfe10, {.d_s = key_type_str}}, {_SLIT("[]){"), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_expr(g, node.index);
		v__gen__c__Gen_write(g, _SLIT("}"));
		if (gen_or) {
			v__gen__c__Gen_write(g, _SLIT("))"));
		} else if (g->is_fn_index_call) {
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(", &(voidptr[]){ "), 0xfe10, {.d_s = zero}}, {_SLIT(" })))"), 0, { .d_c = 0 }}})));
		} else if (elem_typ->kind == v__ast__Kind__function) {
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(", &(voidptr[]){ "), 0xfe10, {.d_s = zero}}, {_SLIT(" }))"), 0, { .d_c = 0 }}})));
		} else {
			v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT(", &("), 0xfe10, {.d_s = elem_type_str}}, {_SLIT("[]){ "), 0xfe10, {.d_s = zero}}, {_SLIT(" }))"), 0, { .d_c = 0 }}})));
		}
		if (gen_or) {
			v__gen__c__Gen_writeln(g, _SLIT(";"));
			string opt_elem_type = v__gen__c__Gen_typ(g, v__ast__Type_set_flag(elem_type, v__ast__TypeFlag__optional));
			v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = opt_elem_type}}, {_SLIT(" "), 0xfe10, {.d_s = tmp_opt}}, {_SLIT(" = {0};"), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("if ("), 0xfe10, {.d_s = tmp_opt_ptr}}, {_SLIT(") {"), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_writeln(g,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("\t*(("), 0xfe10, {.d_s = elem_type_str}}, {_SLIT("*)&"), 0xfe10, {.d_s = tmp_opt}}, {_SLIT(".data) = *(("), 0xfe10, {.d_s = elem_type_str}}, {_SLIT("*)"), 0xfe10, {.d_s = tmp_opt_ptr}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_writeln(g, _SLIT("} else {"));
			v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = tmp_opt}}, {_SLIT(".state = 2; "), 0xfe10, {.d_s = tmp_opt}}, {_SLIT(".err = _v_error(_SLIT(\"array index out of range\"));"), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_writeln(g, _SLIT("}"));
			if (!node.is_option) {
				v__gen__c__Gen_or_block(g, tmp_opt, node.or_expr, elem_type);
			}
			v__gen__c__Gen_write(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\n"), 0xfe10, {.d_s = cur_line}}, {_SLIT("*("), 0xfe10, {.d_s = elem_type_str}}, {_SLIT("*)"), 0xfe10, {.d_s = tmp_opt}}, {_SLIT(".data"), 0, { .d_c = 0 }}})));
		}
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_infix_expr(v__gen__c__Gen* g, v__ast__InfixExpr node) {
	if ((node.auto_locked).len != 0) {
		v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("sync__RwMutex_lock(&"), 0xfe10, {.d_s = node.auto_locked}}, {_SLIT("->mtx);"), 0, { .d_c = 0 }}})));
	}
	switch (node.op) {
		case v__token__Kind__arrow: 
			{
				v__gen__c__Gen_infix_expr_arrow_op(g, node);
			} break;
		case v__token__Kind__eq: 
		case v__token__Kind__ne: 
			{
				v__gen__c__Gen_infix_expr_eq_op(g, node);
			} break;
		case v__token__Kind__gt: 
		case v__token__Kind__ge: 
		case v__token__Kind__lt: 
		case v__token__Kind__le: 
			{
				v__gen__c__Gen_infix_expr_cmp_op(g, node);
			} break;
		case v__token__Kind__key_in: 
		case v__token__Kind__not_in: 
			{
				v__gen__c__Gen_infix_expr_in_op(g, node);
			} break;
		case v__token__Kind__key_is: 
		case v__token__Kind__not_is: 
			{
				v__gen__c__Gen_infix_expr_is_op(g, node);
			} break;
		case v__token__Kind__plus: 
		case v__token__Kind__minus: 
		case v__token__Kind__mul: 
		case v__token__Kind__div: 
		case v__token__Kind__mod: 
			{
				v__gen__c__Gen_infix_expr_arithmetic_op(g, node);
			} break;
		case v__token__Kind__left_shift: 
			{
				v__gen__c__Gen_infix_expr_left_shift_op(g, node);
			} break;
		case v__token__Kind__and: 
		case v__token__Kind__logical_or: 
			{
				v__gen__c__Gen_infix_expr_and_or_op(g, node);
			} break;
		case v__token__Kind__unknown:
		case v__token__Kind__eof:
		case v__token__Kind__name:
		case v__token__Kind__number:
		case v__token__Kind__string:
		case v__token__Kind__str_inter:
		case v__token__Kind__chartoken:
		case v__token__Kind__xor:
		case v__token__Kind__pipe:
		case v__token__Kind__inc:
		case v__token__Kind__dec:
		case v__token__Kind__not:
		case v__token__Kind__bit_not:
		case v__token__Kind__question:
		case v__token__Kind__comma:
		case v__token__Kind__semicolon:
		case v__token__Kind__colon:
		case v__token__Kind__amp:
		case v__token__Kind__hash:
		case v__token__Kind__dollar:
		case v__token__Kind__at:
		case v__token__Kind__str_dollar:
		case v__token__Kind__right_shift:
		case v__token__Kind__unsigned_right_shift:
		case v__token__Kind__assign:
		case v__token__Kind__decl_assign:
		case v__token__Kind__plus_assign:
		case v__token__Kind__minus_assign:
		case v__token__Kind__div_assign:
		case v__token__Kind__mult_assign:
		case v__token__Kind__xor_assign:
		case v__token__Kind__mod_assign:
		case v__token__Kind__or_assign:
		case v__token__Kind__and_assign:
		case v__token__Kind__right_shift_assign:
		case v__token__Kind__left_shift_assign:
		case v__token__Kind__unsigned_right_shift_assign:
		case v__token__Kind__lcbr:
		case v__token__Kind__rcbr:
		case v__token__Kind__lpar:
		case v__token__Kind__rpar:
		case v__token__Kind__lsbr:
		case v__token__Kind__nilsbr:
		case v__token__Kind__rsbr:
		case v__token__Kind__comment:
		case v__token__Kind__nl:
		case v__token__Kind__dot:
		case v__token__Kind__dotdot:
		case v__token__Kind__ellipsis:
		case v__token__Kind__keyword_beg:
		case v__token__Kind__key_as:
		case v__token__Kind__key_asm:
		case v__token__Kind__key_assert:
		case v__token__Kind__key_atomic:
		case v__token__Kind__key_break:
		case v__token__Kind__key_const:
		case v__token__Kind__key_continue:
		case v__token__Kind__key_defer:
		case v__token__Kind__key_else:
		case v__token__Kind__key_enum:
		case v__token__Kind__key_false:
		case v__token__Kind__key_for:
		case v__token__Kind__key_fn:
		case v__token__Kind__key_global:
		case v__token__Kind__key_go:
		case v__token__Kind__key_goto:
		case v__token__Kind__key_if:
		case v__token__Kind__key_import:
		case v__token__Kind__key_interface:
		case v__token__Kind__key_match:
		case v__token__Kind__key_module:
		case v__token__Kind__key_mut:
		case v__token__Kind__key_shared:
		case v__token__Kind__key_lock:
		case v__token__Kind__key_rlock:
		case v__token__Kind__key_none:
		case v__token__Kind__key_return:
		case v__token__Kind__key_select:
		case v__token__Kind__key_sizeof:
		case v__token__Kind__key_isreftype:
		case v__token__Kind__key_likely:
		case v__token__Kind__key_unlikely:
		case v__token__Kind__key_offsetof:
		case v__token__Kind__key_struct:
		case v__token__Kind__key_true:
		case v__token__Kind__key_type:
		case v__token__Kind__key_typeof:
		case v__token__Kind__key_dump:
		case v__token__Kind__key_orelse:
		case v__token__Kind__key_union:
		case v__token__Kind__key_pub:
		case v__token__Kind__key_static:
		case v__token__Kind__key_volatile:
		case v__token__Kind__key_unsafe:
		case v__token__Kind__keyword_end:
		case v__token__Kind___end_:
		default:
			{
				bool need_par = (node.op == v__token__Kind__amp || node.op == v__token__Kind__pipe || node.op == v__token__Kind__xor);
				if (need_par) {
					v__gen__c__Gen_write(g, _SLIT("("));
				}
				v__gen__c__Gen_gen_plain_infix_expr(g, node);
				if (need_par) {
					v__gen__c__Gen_write(g, _SLIT(")"));
				}
			} break;
	}
	;
	if ((node.auto_locked).len != 0) {
		v__gen__c__Gen_writeln(g, _SLIT(";"));
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("sync__RwMutex_unlock(&"), 0xfe10, {.d_s = node.auto_locked}}, {_SLIT("->mtx)"), 0, { .d_c = 0 }}})));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_infix_expr_arrow_op(v__gen__c__Gen* g, v__ast__InfixExpr node) {
	v__gen__c__Type left = v__gen__c__Gen_unwrap(g, node.left_type);
	string styp = left.sym->cname;
	v__ast__Type elem_type = (/* as */ *(v__ast__Chan*)__as_cast((left.sym->info)._v__ast__Chan,(left.sym->info)._typ, 469) /*expected idx: 469, name: v.ast.Chan */ ).elem_type;
	bool gen_or = node.or_block.kind != v__ast__OrKind__absent;
	string tmp_opt = (gen_or ? (v__gen__c__Gen_new_tmp_var(g)) : (_SLIT("")));
	if (gen_or) {
		string elem_styp = v__gen__c__Gen_typ(g, elem_type);
		v__gen__c__Gen_register_chan_push_optional_fn(g, elem_styp, styp);
		v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("Option_void "), 0xfe10, {.d_s = tmp_opt}}, {_SLIT(" = __Option_"), 0xfe10, {.d_s = styp}}, {_SLIT("_pushval("), 0, { .d_c = 0 }}})));
	} else {
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("__"), 0xfe10, {.d_s = styp}}, {_SLIT("_pushval("), 0, { .d_c = 0 }}})));
	}
	v__gen__c__Gen_expr(g, node.left);
	v__gen__c__Gen_write(g, _SLIT(", "));
	if (v__ast__Table_sym(g->table, elem_type)->kind == v__ast__Kind__sum_type || v__ast__Table_sym(g->table, elem_type)->kind == v__ast__Kind__interface_) {
		v__gen__c__Gen_expr_with_cast(g, node.right, node.right_type, elem_type);
	} else {
		v__gen__c__Gen_expr(g, node.right);
	}
	v__gen__c__Gen_write(g, _SLIT(")"));
	if (gen_or) {
		v__gen__c__Gen_or_block(g, tmp_opt, node.or_block, _const_v__ast__void_type);
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_infix_expr_eq_op(v__gen__c__Gen* g, v__ast__InfixExpr node) {
	v__gen__c__Type left = v__gen__c__Gen_unwrap(g, node.left_type);
	v__gen__c__Type right = v__gen__c__Gen_unwrap(g, node.right_type);
	bool has_defined_eq_operator = v__ast__Table_has_method(g->table, left.sym, _SLIT("=="));
	bool has_alias_eq_op_overload = (left.sym->info)._typ == 460 /* v.ast.Alias */ && v__ast__TypeSymbol_has_method(left.sym, _SLIT("=="));
	if ((v__ast__Type_is_ptr(left.typ) && v__ast__Type_is_int(right.typ)) || (v__ast__Type_is_ptr(right.typ) && v__ast__Type_is_int(left.typ))) {
		v__gen__c__Gen_gen_plain_infix_expr(g, node);
	} else if ((v__ast__Type_idx(left.typ) == _const_v__ast__string_type_idx || (!has_defined_eq_operator && v__ast__Type_idx(left.unaliased) == _const_v__ast__string_type_idx)) && (node.right)._typ == 323 /* v.ast.StringLiteral */ && ((/* as */ *(v__ast__StringLiteral*)__as_cast((node.right)._v__ast__StringLiteral,(node.right)._typ, 323) /*expected idx: 323, name: v.ast.StringLiteral */ ).val).len == 0) {
		v__gen__c__Gen_write(g, _SLIT("("));
		v__gen__c__Gen_expr(g, node.left);
		v__gen__c__Gen_write(g, _SLIT(")"));
		string arrow = (v__ast__Type_is_ptr(left.typ) ? (_SLIT("->")) : (_SLIT(".")));
		v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = arrow}}, {_SLIT("len "), 0xfe10, {.d_s = v__token__Kind_str(node.op)}}, {_SLIT(" 0"), 0, { .d_c = 0 }}})));
	} else if (has_defined_eq_operator) {
		if (node.op == v__token__Kind__ne) {
			v__gen__c__Gen_write(g, _SLIT("!"));
		}
		if (has_alias_eq_op_overload) {
			v__gen__c__Gen_write(g, v__gen__c__Gen_typ(g, v__ast__Type_set_nr_muls(left.typ, 0)));
		} else {
			v__gen__c__Gen_write(g, v__gen__c__Gen_typ(g, v__ast__Type_set_nr_muls(left.unaliased, 0)));
		}
		v__gen__c__Gen_write(g, _SLIT("__eq("));
		v__gen__c__Gen_write(g, string_repeat(_SLIT("*"), v__ast__Type_nr_muls(left.typ)));
		v__gen__c__Gen_expr(g, node.left);
		v__gen__c__Gen_write(g, _SLIT(", "));
		v__gen__c__Gen_write(g, string_repeat(_SLIT("*"), v__ast__Type_nr_muls(right.typ)));
		v__gen__c__Gen_expr(g, node.right);
		v__gen__c__Gen_write(g, _SLIT(")"));
	} else if (v__ast__Type_idx(left.typ) == v__ast__Type_idx(right.typ) && (left.sym->kind == v__ast__Kind__array || left.sym->kind == v__ast__Kind__array_fixed || left.sym->kind == v__ast__Kind__alias || left.sym->kind == v__ast__Kind__map || left.sym->kind == v__ast__Kind__struct_ || left.sym->kind == v__ast__Kind__sum_type || left.sym->kind == v__ast__Kind__interface_)) {
		switch (left.sym->kind) {
			case v__ast__Kind__alias: 
				{
					string ptr_typ = v__gen__c__Gen_equality_fn(g, left.typ);
					if (node.op == v__token__Kind__ne) {
						v__gen__c__Gen_write(g, _SLIT("!"));
					}
					v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ptr_typ}}, {_SLIT("_alias_eq("), 0, { .d_c = 0 }}})));
					if (v__ast__Type_is_ptr(left.typ)) {
						v__gen__c__Gen_write(g, _SLIT("*"));
					}
					v__gen__c__Gen_expr(g, node.left);
					v__gen__c__Gen_write(g, _SLIT(", "));
					if (v__ast__Type_is_ptr(right.typ)) {
						v__gen__c__Gen_write(g, _SLIT("*"));
					}
					v__gen__c__Gen_expr(g, node.right);
					v__gen__c__Gen_write(g, _SLIT(")"));
				} break;
			case v__ast__Kind__array: 
				{
					string ptr_typ = v__gen__c__Gen_equality_fn(g, v__ast__Type_clear_flag(left.unaliased, v__ast__TypeFlag__shared_f));
					if (node.op == v__token__Kind__ne) {
						v__gen__c__Gen_write(g, _SLIT("!"));
					}
					v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ptr_typ}}, {_SLIT("_arr_eq("), 0, { .d_c = 0 }}})));
					if (v__ast__Type_is_ptr(left.typ) && !v__ast__Type_has_flag(left.typ, v__ast__TypeFlag__shared_f)) {
						v__gen__c__Gen_write(g, _SLIT("*"));
					}
					v__gen__c__Gen_expr(g, node.left);
					if (v__ast__Type_has_flag(left.typ, v__ast__TypeFlag__shared_f)) {
						v__gen__c__Gen_write(g, _SLIT("->val"));
					}
					v__gen__c__Gen_write(g, _SLIT(", "));
					if (v__ast__Type_is_ptr(right.typ) && !v__ast__Type_has_flag(right.typ, v__ast__TypeFlag__shared_f)) {
						v__gen__c__Gen_write(g, _SLIT("*"));
					}
					v__gen__c__Gen_expr(g, node.right);
					if (v__ast__Type_has_flag(right.typ, v__ast__TypeFlag__shared_f)) {
						v__gen__c__Gen_write(g, _SLIT("->val"));
					}
					v__gen__c__Gen_write(g, _SLIT(")"));
				} break;
			case v__ast__Kind__array_fixed: 
				{
					string ptr_typ = v__gen__c__Gen_equality_fn(g, left.unaliased);
					if (node.op == v__token__Kind__ne) {
						v__gen__c__Gen_write(g, _SLIT("!"));
					}
					v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ptr_typ}}, {_SLIT("_arr_eq("), 0, { .d_c = 0 }}})));
					if (v__ast__Type_is_ptr(left.typ)) {
						v__gen__c__Gen_write(g, _SLIT("*"));
					}
					if ((node.left)._typ == 280 /* v.ast.ArrayInit */) {
						if (!(*node.left._v__ast__ArrayInit).has_it) {
							string s = v__gen__c__Gen_typ(g, left.unaliased);
							v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("("), 0xfe10, {.d_s = s}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
						}
					}
					v__gen__c__Gen_expr(g, node.left);
					v__gen__c__Gen_write(g, _SLIT(", "));
					if ((node.right)._typ == 280 /* v.ast.ArrayInit */) {
						if (!(*node.right._v__ast__ArrayInit).has_it) {
							string s = v__gen__c__Gen_typ(g, right.unaliased);
							v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("("), 0xfe10, {.d_s = s}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
						}
					}
					v__gen__c__Gen_expr(g, node.right);
					v__gen__c__Gen_write(g, _SLIT(")"));
				} break;
			case v__ast__Kind__map: 
				{
					string ptr_typ = v__gen__c__Gen_equality_fn(g, left.unaliased);
					if (node.op == v__token__Kind__ne) {
						v__gen__c__Gen_write(g, _SLIT("!"));
					}
					v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ptr_typ}}, {_SLIT("_map_eq("), 0, { .d_c = 0 }}})));
					if (v__ast__Type_is_ptr(left.typ)) {
						v__gen__c__Gen_write(g, _SLIT("*"));
					}
					v__gen__c__Gen_expr(g, node.left);
					v__gen__c__Gen_write(g, _SLIT(", "));
					if (v__ast__Type_is_ptr(right.typ)) {
						v__gen__c__Gen_write(g, _SLIT("*"));
					}
					v__gen__c__Gen_expr(g, node.right);
					v__gen__c__Gen_write(g, _SLIT(")"));
				} break;
			case v__ast__Kind__struct_: 
				{
					string ptr_typ = v__gen__c__Gen_equality_fn(g, left.unaliased);
					if (node.op == v__token__Kind__ne) {
						v__gen__c__Gen_write(g, _SLIT("!"));
					}
					v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ptr_typ}}, {_SLIT("_struct_eq("), 0, { .d_c = 0 }}})));
					if (v__ast__Type_is_ptr(left.typ)) {
						v__gen__c__Gen_write(g, _SLIT("*"));
					}
					v__gen__c__Gen_expr(g, node.left);
					v__gen__c__Gen_write(g, _SLIT(", "));
					if (v__ast__Type_is_ptr(right.typ)) {
						v__gen__c__Gen_write(g, _SLIT("*"));
					}
					v__gen__c__Gen_expr(g, node.right);
					v__gen__c__Gen_write(g, _SLIT(")"));
				} break;
			case v__ast__Kind__sum_type: 
				{
					string ptr_typ = v__gen__c__Gen_equality_fn(g, left.unaliased);
					if (node.op == v__token__Kind__ne) {
						v__gen__c__Gen_write(g, _SLIT("!"));
					}
					v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ptr_typ}}, {_SLIT("_sumtype_eq("), 0, { .d_c = 0 }}})));
					if (v__ast__Type_is_ptr(left.typ)) {
						v__gen__c__Gen_write(g, _SLIT("*"));
					}
					v__gen__c__Gen_expr(g, node.left);
					v__gen__c__Gen_write(g, _SLIT(", "));
					if (v__ast__Type_is_ptr(right.typ)) {
						v__gen__c__Gen_write(g, _SLIT("*"));
					}
					v__gen__c__Gen_expr(g, node.right);
					v__gen__c__Gen_write(g, _SLIT(")"));
				} break;
			case v__ast__Kind__interface_: 
				{
					string ptr_typ = v__gen__c__Gen_equality_fn(g, left.unaliased);
					if (node.op == v__token__Kind__ne) {
						v__gen__c__Gen_write(g, _SLIT("!"));
					}
					v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ptr_typ}}, {_SLIT("_interface_eq("), 0, { .d_c = 0 }}})));
					if (v__ast__Type_is_ptr(left.typ)) {
						v__gen__c__Gen_write(g, _SLIT("*"));
					}
					v__gen__c__Gen_expr(g, node.left);
					v__gen__c__Gen_write(g, _SLIT(", "));
					if (v__ast__Type_is_ptr(right.typ)) {
						v__gen__c__Gen_write(g, _SLIT("*"));
					}
					v__gen__c__Gen_expr(g, node.right);
					v__gen__c__Gen_write(g, _SLIT(")"));
				} break;
			case v__ast__Kind__placeholder:
			case v__ast__Kind__void:
			case v__ast__Kind__voidptr:
			case v__ast__Kind__byteptr:
			case v__ast__Kind__charptr:
			case v__ast__Kind__i8:
			case v__ast__Kind__i16:
			case v__ast__Kind__int:
			case v__ast__Kind__i64:
			case v__ast__Kind__isize:
			case v__ast__Kind__byte:
			case v__ast__Kind__u8:
			case v__ast__Kind__u16:
			case v__ast__Kind__u32:
			case v__ast__Kind__u64:
			case v__ast__Kind__usize:
			case v__ast__Kind__f32:
			case v__ast__Kind__f64:
			case v__ast__Kind__char:
			case v__ast__Kind__rune:
			case v__ast__Kind__bool:
			case v__ast__Kind__none_:
			case v__ast__Kind__string:
			case v__ast__Kind__chan:
			case v__ast__Kind__any:
			case v__ast__Kind__generic_inst:
			case v__ast__Kind__multi_return:
			case v__ast__Kind__enum_:
			case v__ast__Kind__function:
			case v__ast__Kind__float_literal:
			case v__ast__Kind__int_literal:
			case v__ast__Kind__aggregate:
			case v__ast__Kind__thread:
			default:
				{
				} break;
		}
		;
	} else if ((v__ast__Type_idx(left.unaliased) == _const_v__ast__u32_type_idx || v__ast__Type_idx(left.unaliased) == _const_v__ast__u64_type_idx) && v__ast__Type_is_signed(right.unaliased)) {
		v__gen__c__Gen_gen_safe_integer_infix_expr(g, (v__gen__c__GenSafeIntegerCfg){.op = node.op,.reverse = 0,.unsigned_type = left.unaliased,.unsigned_expr = node.left,.signed_type = right.unaliased,.signed_expr = node.right,});
	} else if ((v__ast__Type_idx(right.unaliased) == _const_v__ast__u32_type_idx || v__ast__Type_idx(right.unaliased) == _const_v__ast__u64_type_idx) && v__ast__Type_is_signed(left.unaliased)) {
		v__gen__c__Gen_gen_safe_integer_infix_expr(g, (v__gen__c__GenSafeIntegerCfg){
			.op = node.op,
			.reverse = true,
			.unsigned_type = right.unaliased,
			.unsigned_expr = node.right,
			.signed_type = left.unaliased,
			.signed_expr = node.left,
		});
	} else {
		v__gen__c__Gen_gen_plain_infix_expr(g, node);
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_infix_expr_cmp_op(v__gen__c__Gen* g, v__ast__InfixExpr node) {
	v__gen__c__Type left = v__gen__c__Gen_unwrap(g, node.left_type);
	v__gen__c__Type right = v__gen__c__Gen_unwrap(g, node.right_type);
	bool has_operator_overloading = v__ast__Table_has_method(g->table, left.sym, _SLIT("<"));
	if (left.sym->kind == v__ast__Kind__struct_ && (/* as */ *(v__ast__Struct*)__as_cast((left.sym->info)._v__ast__Struct,(left.sym->info)._typ, 446) /*expected idx: 446, name: v.ast.Struct */ ).generic_types.len > 0) {
		if (node.op == v__token__Kind__le || node.op == v__token__Kind__ge) {
			v__gen__c__Gen_write(g, _SLIT("!"));
		}
		Array_v__ast__Type concrete_types = (/* as */ *(v__ast__Struct*)__as_cast((left.sym->info)._v__ast__Struct,(left.sym->info)._typ, 446) /*expected idx: 446, name: v.ast.Struct */ ).concrete_types;
		string method_name = string__plus(left.sym->cname, _SLIT("__lt"));
		method_name = v__gen__c__Gen_generic_fn_name(g, concrete_types, method_name, true);
		v__gen__c__Gen_write(g, method_name);
		if (node.op == v__token__Kind__lt || node.op == v__token__Kind__ge) {
			v__gen__c__Gen_write(g, _SLIT("("));
			v__gen__c__Gen_write(g, string_repeat(_SLIT("*"), v__ast__Type_nr_muls(left.typ)));
			v__gen__c__Gen_expr(g, node.left);
			v__gen__c__Gen_write(g, _SLIT(", "));
			v__gen__c__Gen_write(g, string_repeat(_SLIT("*"), v__ast__Type_nr_muls(right.typ)));
			v__gen__c__Gen_expr(g, node.right);
			v__gen__c__Gen_write(g, _SLIT(")"));
		} else {
			v__gen__c__Gen_write(g, _SLIT("("));
			v__gen__c__Gen_write(g, string_repeat(_SLIT("*"), v__ast__Type_nr_muls(right.typ)));
			v__gen__c__Gen_expr(g, node.right);
			v__gen__c__Gen_write(g, _SLIT(", "));
			v__gen__c__Gen_write(g, string_repeat(_SLIT("*"), v__ast__Type_nr_muls(left.typ)));
			v__gen__c__Gen_expr(g, node.left);
			v__gen__c__Gen_write(g, _SLIT(")"));
		}
	} else if (left.sym->kind == right.sym->kind && has_operator_overloading) {
		if (node.op == v__token__Kind__le || node.op == v__token__Kind__ge) {
			v__gen__c__Gen_write(g, _SLIT("!"));
		}
		v__gen__c__Gen_write(g, v__gen__c__Gen_typ(g, v__ast__Type_set_nr_muls(left.typ, 0)));
		v__gen__c__Gen_write(g, _SLIT("__lt"));
		if (node.op == v__token__Kind__lt || node.op == v__token__Kind__ge) {
			v__gen__c__Gen_write(g, _SLIT("("));
			v__gen__c__Gen_write(g, string_repeat(_SLIT("*"), v__ast__Type_nr_muls(left.typ)));
			v__gen__c__Gen_expr(g, node.left);
			v__gen__c__Gen_write(g, _SLIT(", "));
			v__gen__c__Gen_write(g, string_repeat(_SLIT("*"), v__ast__Type_nr_muls(right.typ)));
			v__gen__c__Gen_expr(g, node.right);
			v__gen__c__Gen_write(g, _SLIT(")"));
		} else {
			v__gen__c__Gen_write(g, _SLIT("("));
			v__gen__c__Gen_write(g, string_repeat(_SLIT("*"), v__ast__Type_nr_muls(right.typ)));
			v__gen__c__Gen_expr(g, node.right);
			v__gen__c__Gen_write(g, _SLIT(", "));
			v__gen__c__Gen_write(g, string_repeat(_SLIT("*"), v__ast__Type_nr_muls(left.typ)));
			v__gen__c__Gen_expr(g, node.left);
			v__gen__c__Gen_write(g, _SLIT(")"));
		}
	} else if ((v__ast__Type_idx(left.unaliased) == _const_v__ast__u32_type_idx || v__ast__Type_idx(left.unaliased) == _const_v__ast__u64_type_idx) && v__ast__Type_is_signed(right.unaliased)) {
		v__gen__c__Gen_gen_safe_integer_infix_expr(g, (v__gen__c__GenSafeIntegerCfg){.op = node.op,.reverse = 0,.unsigned_type = left.unaliased,.unsigned_expr = node.left,.signed_type = right.unaliased,.signed_expr = node.right,});
	} else if ((v__ast__Type_idx(right.unaliased) == _const_v__ast__u32_type_idx || v__ast__Type_idx(right.unaliased) == _const_v__ast__u64_type_idx) && v__ast__Type_is_signed(left.unaliased)) {
		v__gen__c__Gen_gen_safe_integer_infix_expr(g, (v__gen__c__GenSafeIntegerCfg){
			.op = node.op,
			.reverse = true,
			.unsigned_type = right.unaliased,
			.unsigned_expr = node.right,
			.signed_type = left.unaliased,
			.signed_expr = node.left,
		});
	} else {
		v__gen__c__Gen_gen_plain_infix_expr(g, node);
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_infix_expr_in_sumtype_interface_array(v__gen__c__Gen* g, Array_v__ast__InfixExpr infix_exprs) {
	for (int i = 0; i < infix_exprs.len; ++i) {
		v__gen__c__Gen_infix_expr_is_op(g, (*(v__ast__InfixExpr*)/*ee elem_typ */array_get(infix_exprs, i)));
		if (i != infix_exprs.len - 1) {
			v__gen__c__Gen_write(g, _SLIT(" || "));
		}
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_infix_expr_in_op(v__gen__c__Gen* g, v__ast__InfixExpr node) {
	v__gen__c__Type left = v__gen__c__Gen_unwrap(g, node.left_type);
	v__gen__c__Type right = v__gen__c__Gen_unwrap(g, node.right_type);
	if (node.op == v__token__Kind__not_in) {
		v__gen__c__Gen_write(g, _SLIT("!"));
	}
	if (right.unaliased_sym->kind == v__ast__Kind__array) {
		if (left.sym->kind == v__ast__Kind__sum_type || left.sym->kind == v__ast__Kind__interface_) {
			if ((node.right)._typ == 280 /* v.ast.ArrayInit */) {
				if ((*node.right._v__ast__ArrayInit).exprs.len > 0) {
					Array_v__ast__InfixExpr infix_exprs = __new_array_with_default(0, 0, sizeof(v__ast__InfixExpr), 0);
					for (int i = 0; i < (*node.right._v__ast__ArrayInit).exprs.len; ++i) {
						array_push((array*)&infix_exprs, _MOV((v__ast__InfixExpr[]){ (v__ast__InfixExpr){.op = v__token__Kind__key_is,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.is_stmt = 0,.left = node.left,.right = (*(v__ast__Expr*)/*ee elem_typ */array_get((*node.right._v__ast__ArrayInit).exprs, i)),.left_type = node.left_type,.right_type = (*(v__ast__Type*)/*ee elem_typ */array_get((*node.right._v__ast__ArrayInit).expr_types, i)),.auto_locked = (string){.str=(byteptr)"", .is_lit=1},.or_block = (v__ast__OrExpr){.stmts = __new_array(0, 0, sizeof(v__ast__Stmt)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},},.ct_left_value_evaled = 0,.ct_left_value = v__ast__empty_comptime_const_expr(),.ct_right_value_evaled = 0,.ct_right_value = v__ast__empty_comptime_const_expr(),} }));
					}
					v__gen__c__Gen_write(g, _SLIT("("));
					v__gen__c__Gen_infix_expr_in_sumtype_interface_array(g, infix_exprs);
					v__gen__c__Gen_write(g, _SLIT(")"));
					return;
				}
			}
		}
		if ((node.right)._typ == 280 /* v.ast.ArrayInit */) {
			if ((*node.right._v__ast__ArrayInit).exprs.len > 0) {
				v__gen__c__Gen_write(g, _SLIT("("));
				v__gen__c__Gen_infix_expr_in_optimization(g, node.left, (*node.right._v__ast__ArrayInit));
				v__gen__c__Gen_write(g, _SLIT(")"));
				return;
			}
		}
		if ((right.sym->info)._typ == 441 /* v.ast.Array */) {
			v__ast__Type elem_type = (*right.sym->info._v__ast__Array).elem_type;
			v__gen__c__Type elem_type_ = v__gen__c__Gen_unwrap(g, elem_type);
			if (elem_type_.sym->kind == v__ast__Kind__sum_type) {
				if (Array_v__ast__Type_contains(v__ast__TypeSymbol_sumtype_info(elem_type_.sym).variants, node.left_type)) {
					v__ast__CastExpr new_node_left = (v__ast__CastExpr){.arg = v__ast__EmptyExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__EmptyExpr, ((v__ast__EmptyExpr){.x = 0,}))),.typ = elem_type,.expr = node.left,.typname = (string){.str=(byteptr)"", .is_lit=1},.expr_type = node.left_type,.has_arg = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},};
					v__gen__c__Gen_gen_array_contains(g, node.right_type, node.right, v__ast__CastExpr_to_sumtype_v__ast__Expr(&new_node_left));
					return;
				}
			}
		}
		v__gen__c__Gen_gen_array_contains(g, node.right_type, node.right, node.left);
	} else if (right.unaliased_sym->kind == v__ast__Kind__map) {
		v__gen__c__Gen_write(g, _SLIT("_IN_MAP("));
		if (!v__ast__Type_is_ptr(left.typ)) {
			string styp = v__gen__c__Gen_typ(g, node.left_type);
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("ADDR("), 0xfe10, {.d_s = styp}}, {_SLIT(", "), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_expr(g, node.left);
			v__gen__c__Gen_write(g, _SLIT(")"));
		} else {
			v__gen__c__Gen_expr(g, node.left);
		}
		v__gen__c__Gen_write(g, _SLIT(", "));
		if (!v__ast__Type_is_ptr(right.typ)) {
			v__gen__c__Gen_write(g, _SLIT("ADDR(map, "));
			v__gen__c__Gen_expr(g, node.right);
			v__gen__c__Gen_write(g, _SLIT(")"));
		} else {
			v__gen__c__Gen_expr(g, node.right);
		}
		v__gen__c__Gen_write(g, _SLIT(")"));
	} else if (right.unaliased_sym->kind == v__ast__Kind__string) {
		v__gen__c__Gen_write(g, _SLIT("string_contains("));
		v__gen__c__Gen_expr(g, node.right);
		v__gen__c__Gen_write(g, _SLIT(", "));
		v__gen__c__Gen_expr(g, node.left);
		v__gen__c__Gen_write(g, _SLIT(")"));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_infix_expr_in_optimization(v__gen__c__Gen* g, v__ast__Expr left, v__ast__ArrayInit right) {
	bool is_str = v__ast__Type_idx(right.elem_type) == _const_v__ast__string_type_idx;
	v__ast__TypeSymbol* elem_sym = v__ast__Table_sym(g->table, right.elem_type);
	bool is_array = elem_sym->kind == v__ast__Kind__array;
	for (int i = 0; i < right.exprs.len; ++i) {
		v__ast__Expr array_expr = ((v__ast__Expr*)right.exprs.data)[i];
		if (is_str) {
			v__gen__c__Gen_write(g, _SLIT("string__eq("));
		} else if (is_array) {
			string ptr_typ = v__gen__c__Gen_equality_fn(g, right.elem_type);
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ptr_typ}}, {_SLIT("_arr_eq("), 0, { .d_c = 0 }}})));
		}
		v__gen__c__Gen_expr(g, left);
		if (is_str || is_array) {
			v__gen__c__Gen_write(g, _SLIT(", "));
		} else {
			v__gen__c__Gen_write(g, _SLIT(" == "));
		}
		v__gen__c__Gen_expr(g, array_expr);
		if (is_str || is_array) {
			v__gen__c__Gen_write(g, _SLIT(")"));
		}
		if (i < right.exprs.len - 1) {
			v__gen__c__Gen_write(g, _SLIT(" || "));
		}
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_infix_expr_is_op(v__gen__c__Gen* g, v__ast__InfixExpr node) {
	v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, node.left_type);
	v__ast__TypeSymbol* right_sym = v__ast__Table_sym(g->table, node.right_type);
	if (sym->kind == v__ast__Kind__interface_ && right_sym->kind == v__ast__Kind__interface_) {
		v__gen__c__Gen_gen_interface_is_op(g, node);
		return;
	}
	string cmp_op = (node.op == v__token__Kind__key_is ? (_SLIT("==")) : (_SLIT("!=")));
	v__gen__c__Gen_write(g, _SLIT("("));
	v__gen__c__Gen_expr(g, node.left);
	v__gen__c__Gen_write(g, _SLIT(")"));
	if (v__ast__Type_is_ptr(node.left_type)) {
		v__gen__c__Gen_write(g, _SLIT("->"));
	} else {
		v__gen__c__Gen_write(g, _SLIT("."));
	}
	if (sym->kind == v__ast__Kind__interface_) {
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("_typ "), 0xfe10, {.d_s = cmp_op}}, {_SLIT(" "), 0, { .d_c = 0 }}})));
		v__ast__Type sub_type = ((node.right._typ == 325 /* v.ast.TypeNode */) ? ((*node.right._v__ast__TypeNode).typ) : (node.right._typ == 311 /* v.ast.None */) ? ((*(int*)map_get(ADDR(map, g->table->type_idxs), &(string[]){_SLIT("None__")}, &(int[]){ 0 }))) : (((v__ast__Type)(0))));
		v__ast__TypeSymbol* sub_sym = v__ast__Table_sym(g->table, sub_type);
		v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("_"), 0xfe10, {.d_s = v__gen__c__c_name(sym->name)}}, {_SLIT("_"), 0xfe10, {.d_s = v__gen__c__c_name(sub_sym->name)}}, {_SLIT("_index"), 0, { .d_c = 0 }}})));
		return;
	} else if (sym->kind == v__ast__Kind__sum_type) {
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("_typ "), 0xfe10, {.d_s = cmp_op}}, {_SLIT(" "), 0, { .d_c = 0 }}})));
	}
	v__gen__c__Gen_expr(g, node.right);
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_interface_is_op(v__gen__c__Gen* g, v__ast__InfixExpr node) {
	v__ast__TypeSymbol* left_sym = v__ast__Table_sym(g->table, node.left_type);
	v__ast__TypeSymbol* right_sym = v__ast__Table_sym(g->table, node.right_type);
	v__ast__Interface info = /* as */ *(v__ast__Interface*)__as_cast((left_sym->info)._v__ast__Interface,(left_sym->info)._typ, 463) /*expected idx: 463, name: v.ast.Interface */ ;
	Array_v__ast__Type* _t2 = (Array_v__ast__Type*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, info.conversions), &(int[]){node.right_type}));
	Option_Array_v__ast__Type _t1 = {0};
	if (_t2) {
		*((Array_v__ast__Type*)&_t1.data) = *((Array_v__ast__Type*)_t2);
	} else {
		_t1.state = 2; _t1.err = _v_error(_SLIT("array index out of range"));
	}
	;
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		Array_v__ast__Type left_variants = (*(Array_v__ast__Type*)map_get(ADDR(map, g->table->iface_types), &(string[]){left_sym->name}, &(Array_v__ast__Type[]){ __new_array(0, 0, sizeof(v__ast__Type)) }));
		Array_v__ast__Type right_variants = (*(Array_v__ast__Type*)map_get(ADDR(map, g->table->iface_types), &(string[]){right_sym->name}, &(Array_v__ast__Type[]){ __new_array(0, 0, sizeof(v__ast__Type)) }));
		Array_v__ast__Type _t3 = __new_array(0, 0, sizeof(v__ast__Type));
		Array_v__ast__Type _t3_orig = left_variants;
		int _t3_len = _t3_orig.len;
		_t3 = __new_array(0, _t3_len, sizeof(v__ast__Type));

		for (int _t4 = 0; _t4 < _t3_len; ++_t4) {
			v__ast__Type it = ((v__ast__Type*) _t3_orig.data)[_t4];
			if (Array_v__ast__Type_contains(right_variants, it)) {
				array_push((array*)&_t3, &it);
			}
		}
		Array_v__ast__Type c =_t3;
		map_set(&info.conversions, &(int[]){node.right_type}, &(Array_v__ast__Type[]) { c });
		*(Array_v__ast__Type*) _t1.data = c;
	}
	
	Array_v__ast__Type common_variants = *(Array_v__ast__Type*)_t1.data;
	left_sym->info = v__ast__Interface_to_sumtype_v__ast__TypeInfo(&info);
	if (common_variants.len == 0) {
		v__gen__c__Gen_write(g, _SLIT("false"));
		return;
	}
	v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("I_"), 0xfe10, {.d_s = left_sym->cname}}, {_SLIT("_is_I_"), 0xfe10, {.d_s = right_sym->cname}}, {_SLIT("("), 0, { .d_c = 0 }}})));
	if (v__ast__Type_is_ptr(node.left_type)) {
		v__gen__c__Gen_write(g, _SLIT("*"));
	}
	v__gen__c__Gen_expr(g, node.left);
	v__gen__c__Gen_write(g, _SLIT(")"));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_infix_expr_arithmetic_op(v__gen__c__Gen* g, v__ast__InfixExpr node) {
	v__gen__c__Type left = v__gen__c__Gen_unwrap(g, node.left_type);
	v__gen__c__Type right = v__gen__c__Gen_unwrap(g, node.right_type);
	if (left.sym->kind == v__ast__Kind__struct_ && (/* as */ *(v__ast__Struct*)__as_cast((left.sym->info)._v__ast__Struct,(left.sym->info)._typ, 446) /*expected idx: 446, name: v.ast.Struct */ ).generic_types.len > 0) {
		Array_v__ast__Type concrete_types = (/* as */ *(v__ast__Struct*)__as_cast((left.sym->info)._v__ast__Struct,(left.sym->info)._typ, 446) /*expected idx: 446, name: v.ast.Struct */ ).concrete_types;
		string method_name = string__plus(string__plus(left.sym->cname, _SLIT("_")), v__util__replace_op(v__token__Kind_str(node.op)));
		method_name = v__gen__c__Gen_generic_fn_name(g, concrete_types, method_name, true);
		v__gen__c__Gen_write(g, method_name);
		v__gen__c__Gen_write(g, _SLIT("("));
		v__gen__c__Gen_expr(g, node.left);
		v__gen__c__Gen_write(g, _SLIT(", "));
		v__gen__c__Gen_expr(g, node.right);
		v__gen__c__Gen_write(g, _SLIT(")"));
	} else {
		Option_v__ast__Fn _t1 = v__ast__Table_find_method(g->table, left.sym, v__token__Kind_str(node.op));
		if (_t1.state != 0) { /*or block*/ 
			IError err = _t1.err;
			v__gen__c__Gen_gen_plain_infix_expr(g, node);
			return;
		}
		
 		v__ast__Fn method =  (*(v__ast__Fn*)_t1.data);
		string left_styp = v__gen__c__Gen_typ(g, v__ast__Type_set_nr_muls(left.typ, 0));
		v__gen__c__Gen_write(g, left_styp);
		v__gen__c__Gen_write(g, _SLIT("_"));
		v__gen__c__Gen_write(g, v__util__replace_op(v__token__Kind_str(node.op)));
		v__gen__c__Gen_write(g, _SLIT("("));
		v__gen__c__Gen_op_arg(g, node.left, (*(v__ast__Param*)/*ee elem_typ */array_get(method.params, 0)).typ, left.typ);
		v__gen__c__Gen_write(g, _SLIT(", "));
		v__gen__c__Gen_op_arg(g, node.right, (*(v__ast__Param*)/*ee elem_typ */array_get(method.params, 1)).typ, right.typ);
		v__gen__c__Gen_write(g, _SLIT(")"));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_infix_expr_left_shift_op(v__gen__c__Gen* g, v__ast__InfixExpr node) {
	v__gen__c__Type left = v__gen__c__Gen_unwrap(g, node.left_type);
	v__gen__c__Type right = v__gen__c__Gen_unwrap(g, node.right_type);
	if (left.unaliased_sym->kind == v__ast__Kind__array) {
		string tmp_var = v__gen__c__Gen_new_tmp_var(g);
		v__ast__Array array_info = /* as */ *(v__ast__Array*)__as_cast((left.unaliased_sym->info)._v__ast__Array,(left.unaliased_sym->info)._typ, 441) /*expected idx: 441, name: v.ast.Array */ ;
		string noscan = v__gen__c__Gen_check_noscan(g, array_info.elem_type);
		if (right.unaliased_sym->kind == v__ast__Kind__array && !v__ast__Type_alias_eq(array_info.elem_type, right.typ)) {
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("_PUSH_MANY"), 0xfe10, {.d_s = noscan}}, {_SLIT("("), 0, { .d_c = 0 }}})));
			v__ast__Type expected_push_many_atype = left.typ;
			if (!v__ast__Type_is_ptr(expected_push_many_atype)) {
				v__gen__c__Gen_write(g, _SLIT("&"));
			} else {
				expected_push_many_atype = v__ast__Type_deref(expected_push_many_atype);
			}
			v__gen__c__Gen_expr(g, node.left);
			v__gen__c__Gen_write(g, _SLIT(", ("));
			v__gen__c__Gen_expr_with_cast(g, node.right, node.right_type, left.unaliased);
			string styp = v__gen__c__Gen_typ(g, expected_push_many_atype);
			v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("), "), 0xfe10, {.d_s = tmp_var}}, {_SLIT(", "), 0xfe10, {.d_s = styp}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
		} else {
			string elem_type_str = v__gen__c__Gen_typ(g, array_info.elem_type);
			v__ast__TypeSymbol* elem_sym = v__ast__Table_sym(g->table, array_info.elem_type);
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("array_push"), 0xfe10, {.d_s = noscan}}, {_SLIT("((array*)"), 0, { .d_c = 0 }}})));
			if (v__ast__Type_has_flag(node.left_type, v__ast__TypeFlag__shared_f) && !v__ast__Type_is_ptr(v__ast__Type_deref(node.left_type))) {
			}
			if (!v__ast__Type_is_ptr(left.typ) || (v__ast__Type_has_flag(node.left_type, v__ast__TypeFlag__shared_f) && !v__ast__Type_is_ptr(v__ast__Type_deref(node.left_type)))) {
				v__gen__c__Gen_write(g, _SLIT("&"));
			}
			v__gen__c__Gen_expr(g, node.left);
			if (v__ast__Type_has_flag(node.left_type, v__ast__TypeFlag__shared_f)) {
				v__gen__c__Gen_write(g, _SLIT("->val"));
			}
			if (elem_sym->kind == v__ast__Kind__function) {
				v__gen__c__Gen_write(g, _SLIT(", _MOV((voidptr[]){ "));
			} else {
				v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(", _MOV(("), 0xfe10, {.d_s = elem_type_str}}, {_SLIT("[]){ "), 0, { .d_c = 0 }}})));
			}
			bool needs_clone = v__ast__Type_idx(array_info.elem_type) == _const_v__ast__string_type_idx && !g->is_builtin_mod;
			if (needs_clone) {
				v__gen__c__Gen_write(g, _SLIT("string_clone("));
			}
			v__gen__c__Gen_expr_with_cast(g, node.right, node.right_type, array_info.elem_type);
			if (needs_clone) {
				v__gen__c__Gen_write(g, _SLIT(")"));
			}
			v__gen__c__Gen_write(g, _SLIT(" }))"));
		}
	} else {
		v__gen__c__Gen_gen_plain_infix_expr(g, node);
	}
}

VV_LOCAL_SYMBOL bool v__gen__c__Gen_need_tmp_var_in_array_call(v__gen__c__Gen* g, v__ast__Expr node) {
	if (node._typ == 286 /* v.ast.CallExpr */) {
		if ((*node._v__ast__CallExpr).left_type != 0 && v__ast__Table_sym(g->table, (*node._v__ast__CallExpr).left_type)->kind == v__ast__Kind__array && (string__eq((*node._v__ast__CallExpr).name, _SLIT("all")) || string__eq((*node._v__ast__CallExpr).name, _SLIT("any")) || string__eq((*node._v__ast__CallExpr).name, _SLIT("filter")) || string__eq((*node._v__ast__CallExpr).name, _SLIT("map")))) {
			bool _t1 = true;
			return _t1;
		}
	}
	else if (node._typ == 302 /* v.ast.IndexExpr */) {
		bool _t2 = v__gen__c__Gen_need_tmp_var_in_array_call(g, (*node._v__ast__IndexExpr).left);
		return _t2;
	}
	else if (node._typ == 303 /* v.ast.InfixExpr */) {
		bool _t3 = v__gen__c__Gen_need_tmp_var_in_array_call(g, (*node._v__ast__InfixExpr).left) || v__gen__c__Gen_need_tmp_var_in_array_call(g, (*node._v__ast__InfixExpr).right);
		return _t3;
	}
	else if (node._typ == 314 /* v.ast.ParExpr */) {
		bool _t4 = v__gen__c__Gen_need_tmp_var_in_array_call(g, (*node._v__ast__ParExpr).expr);
		return _t4;
	}
	else if (node._typ == 315 /* v.ast.PostfixExpr */) {
		bool _t5 = v__gen__c__Gen_need_tmp_var_in_array_call(g, (*node._v__ast__PostfixExpr).expr);
		return _t5;
	}
	else if (node._typ == 316 /* v.ast.PrefixExpr */) {
		bool _t6 = v__gen__c__Gen_need_tmp_var_in_array_call(g, (*node._v__ast__PrefixExpr).right);
		return _t6;
	}
	else if (node._typ == 317 /* v.ast.RangeExpr */) {
		bool _t7 = v__gen__c__Gen_need_tmp_var_in_array_call(g, (*node._v__ast__RangeExpr).low) || v__gen__c__Gen_need_tmp_var_in_array_call(g, (*node._v__ast__RangeExpr).high);
		return _t7;
	}
	else if (node._typ == 319 /* v.ast.SelectorExpr */) {
		bool _t8 = v__gen__c__Gen_need_tmp_var_in_array_call(g, (*node._v__ast__SelectorExpr).expr);
		return _t8;
	}
	
	else {
	}
	;
	bool _t9 = false;
	return _t9;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_infix_expr_and_or_op(v__gen__c__Gen* g, v__ast__InfixExpr node) {
	if ((node.right)._typ == 300 /* v.ast.IfExpr */) {
		int prev_inside_ternary = g->inside_ternary;
		g->inside_ternary = 0;
		if (v__gen__c__Gen_need_tmp_var_in_if(g, (*node.right._v__ast__IfExpr))) {
			string tmp = v__gen__c__Gen_new_tmp_var(g);
			string cur_line = string_trim_space(v__gen__c__Gen_go_before_stmt(g, 0));
			g->empty_line = true;
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("bool "), 0xfe10, {.d_s = tmp}}, {_SLIT(" = ("), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_expr(g, node.left);
			v__gen__c__Gen_writeln(g, _SLIT(");"));
			v__gen__c__Gen_set_current_pos_as_last_stmt_pos(g);
			v__gen__c__Gen_write(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = cur_line}}, {_SLIT(" "), 0xfe10, {.d_s = tmp}}, {_SLIT(" "), 0xfe10, {.d_s = v__token__Kind_str(node.op)}}, {_SLIT(" "), 0, { .d_c = 0 }}})));
			g->infix_left_var_name = (node.op == v__token__Kind__and ? (tmp) : ( str_intp(2, _MOV((StrIntpData[]){{_SLIT("!"), 0xfe10, {.d_s = tmp}}, {_SLIT0, 0, { .d_c = 0 }}}))));
			v__gen__c__Gen_expr(g, node.right);
			g->infix_left_var_name = _SLIT("");
			g->inside_ternary = prev_inside_ternary;
			return;
		}
		g->inside_ternary = prev_inside_ternary;
	} else if (v__gen__c__Gen_need_tmp_var_in_array_call(g, node.right)) {
		string tmp = v__gen__c__Gen_new_tmp_var(g);
		string cur_line = string_trim_space(v__gen__c__Gen_go_before_stmt(g, 0));
		g->empty_line = true;
		if (g->infix_left_var_name.len > 0) {
			v__gen__c__Gen_write(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("bool "), 0xfe10, {.d_s = tmp}}, {_SLIT(" = (("), 0xfe10, {.d_s = g->infix_left_var_name}}, {_SLIT(") "), 0xfe10, {.d_s = v__token__Kind_str(node.op)}}, {_SLIT(" "), 0, { .d_c = 0 }}})));
		} else {
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("bool "), 0xfe10, {.d_s = tmp}}, {_SLIT(" = ("), 0, { .d_c = 0 }}})));
		}
		v__gen__c__Gen_expr(g, node.left);
		v__gen__c__Gen_writeln(g, _SLIT(");"));
		v__gen__c__Gen_set_current_pos_as_last_stmt_pos(g);
		v__gen__c__Gen_write(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = cur_line}}, {_SLIT(" "), 0xfe10, {.d_s = tmp}}, {_SLIT(" "), 0xfe10, {.d_s = v__token__Kind_str(node.op)}}, {_SLIT(" "), 0, { .d_c = 0 }}})));
		g->infix_left_var_name = (node.op == v__token__Kind__and ? (tmp) : ( str_intp(2, _MOV((StrIntpData[]){{_SLIT("!"), 0xfe10, {.d_s = tmp}}, {_SLIT0, 0, { .d_c = 0 }}}))));
		v__gen__c__Gen_expr(g, node.right);
		g->infix_left_var_name = _SLIT("");
		return;
	}
	v__gen__c__Gen_gen_plain_infix_expr(g, node);
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_plain_infix_expr(v__gen__c__Gen* g, v__ast__InfixExpr node) {
	if (v__ast__Type_is_ptr(node.left_type) && v__ast__Expr_is_auto_deref_var(node.left)) {
		v__gen__c__Gen_write(g, _SLIT("*"));
	}
	v__gen__c__Gen_expr(g, node.left);
	v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(" "), 0xfe10, {.d_s = v__token__Kind_str(node.op)}}, {_SLIT(" "), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_expr_with_cast(g, node.right, node.right_type, node.left_type);
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_op_arg(v__gen__c__Gen* g, v__ast__Expr expr, v__ast__Type expected, v__ast__Type got) {
	bool needs_closing = false;
	int nr_muls = v__ast__Type_nr_muls(got);
	if (v__ast__Type_is_ptr(expected)) {
		if (nr_muls > 0) {
			nr_muls--;
		} else {
			if (v__ast__Expr_is_lvalue(expr)) {
				v__gen__c__Gen_write(g, _SLIT("&"));
			} else {
				string styp = v__gen__c__Gen_typ(g, v__ast__Type_set_nr_muls(got, 0));
				v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("ADDR("), 0xfe10, {.d_s = styp}}, {_SLIT(", "), 0, { .d_c = 0 }}})));
				needs_closing = true;
			}
		}
	}
	v__gen__c__Gen_write(g, string_repeat(_SLIT("*"), nr_muls));
	v__gen__c__Gen_expr(g, expr);
	if (needs_closing) {
		v__gen__c__Gen_write(g, _SLIT(")"));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_safe_integer_infix_expr(v__gen__c__Gen* g, v__gen__c__GenSafeIntegerCfg cfg) {
	int bitsize = (v__ast__Type_idx(cfg.unsigned_type) == _const_v__ast__u32_type_idx && v__ast__Type_idx(cfg.signed_type) != _const_v__ast__i64_type_idx ? (32) : (64));
	int op_idx = ((int)(cfg.op)) - ((int)(v__token__Kind__eq));
	string op_str = (cfg.reverse ? ((*(string*)/*ee elem_typ */array_get(_const_v__gen__c__cmp_rev, op_idx))) : ((*(string*)/*ee elem_typ */array_get(_const_v__gen__c__cmp_str, op_idx))));
	v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("_us"), 0xfe07, {.d_i32 = bitsize}}, {_SLIT("_"), 0xfe10, {.d_s = op_str}}, {_SLIT("("), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_expr(g, cfg.unsigned_expr);
	v__gen__c__Gen_write(g, _SLIT(","));
	v__gen__c__Gen_expr(g, cfg.signed_expr);
	v__gen__c__Gen_write(g, _SLIT(")"));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_json_for_type(v__gen__c__Gen* g, v__ast__Type typ) {
	v__ast__Type utyp = v__ast__Type_set_nr_muls(v__gen__c__Gen_unwrap_generic(g, typ), 0);
	v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, utyp);
	if (v__gen__c__is_js_prim(sym->name) || sym->kind == v__ast__Kind__enum_) {
		return;
	}
	array_push((array*)&g->json_types, _MOV((v__ast__Type[]){ utyp }));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_jsons(v__gen__c__Gen* g) {
	Array_v__ast__Type done = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
	for (int i = 0; i < g->json_types.len; i++) {
		v__ast__Type utyp = (*(v__ast__Type*)/*ee elem_typ */array_get(g->json_types, i));
		if (Array_v__ast__Type_contains(done, utyp)) {
			continue;
		}
		array_push((array*)&done, _MOV((v__ast__Type[]){ utyp }));
		strings__Builder dec = strings__new_builder(100);
		strings__Builder enc = strings__new_builder(100);
		v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, utyp);
		string styp = v__gen__c__Gen_typ(g, utyp);
		v__gen__c__Gen_register_optional(g, utyp);
		string dec_fn_name = v__gen__c__js_dec_name(styp);
		string dec_fn_dec =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("Option_"), 0xfe10, {.d_s = styp}}, {_SLIT(" "), 0xfe10, {.d_s = dec_fn_name}}, {_SLIT("(cJSON* root)"), 0, { .d_c = 0 }}}));
		strings__Builder_writeln(&dec,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("\n"), 0xfe10, {.d_s = dec_fn_dec}}, {_SLIT(" {\n	"), 0xfe10, {.d_s = styp}}, {_SLIT(" res;\n	if (!root) {\n		const char *error_ptr = cJSON_GetErrorPtr();\n		if (error_ptr != NULL)	{\n			// fprintf(stderr, \"Error in decode() for "), 0xfe10, {.d_s = styp}}, {_SLIT(" error_ptr=: %s\\n\", error_ptr);\n			// printf(\"\\nbad js=%%s\\n\", js.str);\n			return (Option_"), 0xfe10, {.d_s = styp}}, {_SLIT("){.state = 2,.err = _v_error(tos2((byteptr)error_ptr)),.data = {0}};\n		}\n	}\n"), 0, { .d_c = 0 }}})));
		strings__Builder_writeln(&g->json_forward_decls,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = dec_fn_dec}}, {_SLIT(";"), 0, { .d_c = 0 }}})));
		string enc_fn_name = v__gen__c__js_enc_name(styp);
		string enc_fn_dec =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("cJSON* "), 0xfe10, {.d_s = enc_fn_name}}, {_SLIT("("), 0xfe10, {.d_s = styp}}, {_SLIT(" val)"), 0, { .d_c = 0 }}}));
		strings__Builder_writeln(&g->json_forward_decls,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = enc_fn_dec}}, {_SLIT(";\n"), 0, { .d_c = 0 }}})));
		strings__Builder_writeln(&enc,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\n"), 0xfe10, {.d_s = enc_fn_dec}}, {_SLIT(" {\n\tcJSON *o;"), 0, { .d_c = 0 }}})));
		if (sym->kind == v__ast__Kind__array) {
			v__ast__Type value_type = v__ast__Table_value_type(g->table, utyp);
			v__gen__c__Gen_gen_json_for_type(g, value_type);
			strings__Builder_writeln(&dec, v__gen__c__Gen_decode_array(g, value_type));
			strings__Builder_writeln(&enc, v__gen__c__Gen_encode_array(g, value_type));
		} else if (sym->kind == v__ast__Kind__map) {
			v__ast__Map m = /* as */ *(v__ast__Map*)__as_cast((sym->info)._v__ast__Map,(sym->info)._typ, 442) /*expected idx: 442, name: v.ast.Map */ ;
			v__gen__c__Gen_gen_json_for_type(g, m.key_type);
			v__gen__c__Gen_gen_json_for_type(g, m.value_type);
			strings__Builder_writeln(&dec, v__gen__c__Gen_decode_map(g, m.key_type, m.value_type));
			strings__Builder_writeln(&enc, v__gen__c__Gen_encode_map(g, m.key_type, m.value_type));
		} else if (sym->kind == v__ast__Kind__alias) {
			v__ast__Alias a = /* as */ *(v__ast__Alias*)__as_cast((sym->info)._v__ast__Alias,(sym->info)._typ, 460) /*expected idx: 460, name: v.ast.Alias */ ;
			v__ast__Type parent_typ = a.parent_type;
			v__ast__TypeSymbol* psym = v__ast__Table_sym(g->table, parent_typ);
			if (v__gen__c__is_js_prim(v__gen__c__Gen_typ(g, parent_typ))) {
				v__gen__c__Gen_gen_json_for_type(g, parent_typ);
				continue;
			}
			strings__Builder_writeln(&enc, _SLIT("\to = cJSON_CreateObject();"));
			if ((psym->info)._typ == 446 /* v.ast.Struct */) {
				v__gen__c__Gen_gen_struct_enc_dec(g, psym->info, styp, (voidptr)&/*qq*/enc, (voidptr)&/*qq*/dec);
			} else if (psym->kind == v__ast__Kind__sum_type) {
				v__gen__c__verror( str_intp(2, _MOV((StrIntpData[]){{_SLIT("json: "), 0xfe10, {.d_s = sym->name}}, {_SLIT(" aliased sumtypes does not work at the moment"), 0, { .d_c = 0 }}})));
				VUNREACHABLE();
			} else {
				v__gen__c__verror( str_intp(2, _MOV((StrIntpData[]){{_SLIT("json: "), 0xfe10, {.d_s = sym->name}}, {_SLIT(" is not struct"), 0, { .d_c = 0 }}})));
				VUNREACHABLE();
			}
		} else if (sym->kind == v__ast__Kind__sum_type) {
			strings__Builder_writeln(&enc, _SLIT("\to = cJSON_CreateObject();"));
			if ((sym->info)._typ != 464 /* v.ast.SumType */) {
				v__gen__c__verror( str_intp(2, _MOV((StrIntpData[]){{_SLIT("json: "), 0xfe10, {.d_s = sym->name}}, {_SLIT(" is not a sumtype"), 0, { .d_c = 0 }}})));
				VUNREACHABLE();
			}
			v__gen__c__Gen_gen_sumtype_enc_dec(g, *sym, (voidptr)&/*qq*/enc, (voidptr)&/*qq*/dec);
		} else {
			strings__Builder_writeln(&enc, _SLIT("\to = cJSON_CreateObject();"));
			if ((sym->info)._typ != 446 /* v.ast.Struct */) {
				v__gen__c__verror( str_intp(2, _MOV((StrIntpData[]){{_SLIT("json: "), 0xfe10, {.d_s = sym->name}}, {_SLIT(" is not struct"), 0, { .d_c = 0 }}})));
				VUNREACHABLE();
			}
			v__gen__c__Gen_gen_struct_enc_dec(g, sym->info, styp, (voidptr)&/*qq*/enc, (voidptr)&/*qq*/dec);
		}
		strings__Builder_writeln(&dec,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\tOption_"), 0xfe10, {.d_s = styp}}, {_SLIT(" ret;"), 0, { .d_c = 0 }}})));
		strings__Builder_writeln(&dec, _SLIT("\topt_ok(&res, (Option*)&ret, sizeof(res));"));
		strings__Builder_writeln(&dec, _SLIT("\treturn ret;\n}"));
		strings__Builder_writeln(&enc, _SLIT("\treturn o;\n}"));
		strings__Builder_writeln(&g->definitions, strings__Builder_str(&dec));
		strings__Builder_writeln(&g->gowrappers, strings__Builder_str(&enc));
	}
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_sumtype_enc_dec(v__gen__c__Gen* g, v__ast__TypeSymbol sym, strings__Builder* enc, strings__Builder* dec) {
	v__ast__SumType info = /* as */ *(v__ast__SumType*)__as_cast((sym.info)._v__ast__SumType,(sym.info)._typ, 464) /*expected idx: 464, name: v.ast.SumType */ ;
	string type_var = v__gen__c__Gen_new_tmp_var(g);
	int typ = sym.idx;
	#if !defined(CUSTOM_DEFINE_json_no_inline_sumtypes)
	{
		string type_tmp = v__gen__c__Gen_new_tmp_var(g);
		strings__Builder_writeln(dec, _SLIT("\tif (cJSON_IsObject(root)) {"));
		strings__Builder_writeln(dec,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\tcJSON* "), 0xfe10, {.d_s = type_tmp}}, {_SLIT(" = js_get(root, \"_type\");"), 0, { .d_c = 0 }}})));
		strings__Builder_writeln(dec,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\tif ("), 0xfe10, {.d_s = type_tmp}}, {_SLIT(" != 0) {"), 0, { .d_c = 0 }}})));
		strings__Builder_writeln(dec,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\t\tchar* "), 0xfe10, {.d_s = type_var}}, {_SLIT(" = cJSON_GetStringValue("), 0xfe10, {.d_s = type_tmp}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
	}
	#endif
	Array_string variant_types = __new_array_with_default(0, 0, sizeof(string), 0);
	Array_v__ast__TypeSymbol variant_symbols = __new_array_with_default(0, 0, sizeof(v__ast__TypeSymbol), 0);
	bool at_least_one_prim = false;
	for (int _t1 = 0; _t1 < info.variants.len; ++_t1) {
		v__ast__Type variant = ((v__ast__Type*)info.variants.data)[_t1];
		string variant_typ = v__gen__c__Gen_typ(g, variant);
		array_push((array*)&variant_types, _MOV((string[]){ string_clone(variant_typ) }));
		v__ast__TypeSymbol* variant_sym = v__ast__Table_sym(g->table, variant);
		array_push((array*)&variant_symbols, _MOV((v__ast__TypeSymbol[]){ *variant_sym }));
		at_least_one_prim = at_least_one_prim || v__gen__c__is_js_prim(variant_typ) || variant_sym->kind == v__ast__Kind__enum_ || string__eq(variant_sym->name, _SLIT("time.Time"));
		string unmangled_variant_name = (*(string*)array_last(string_split(variant_sym->name, _SLIT("."))));
		v__gen__c__Gen_gen_json_for_type(g, variant);
		v__gen__c__Gen_get_sumtype_casting_fn(g, variant, typ);
		strings__Builder_writeln(&g->definitions,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("static inline "), 0xfe10, {.d_s = sym.cname}}, {_SLIT(" "), 0xfe10, {.d_s = variant_typ}}, {_SLIT("_to_sumtype_"), 0xfe10, {.d_s = sym.cname}}, {_SLIT("("), 0xfe10, {.d_s = variant_typ}}, {_SLIT("* x);"), 0, { .d_c = 0 }}})));
		strings__Builder_writeln(enc,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\tif (val._typ == "), 0xfe07, {.d_i32 = variant}}, {_SLIT(") {"), 0, { .d_c = 0 }}})));
		#if defined(CUSTOM_DEFINE_json_no_inline_sumtypes)
		{
		}
		#else
		{
			if (v__gen__c__is_js_prim(variant_typ)) {
				strings__Builder_writeln(enc,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\to = "), 0xfe10, {.d_s = v__gen__c__js_enc_name(variant_typ)}}, {_SLIT("(*val._"), 0xfe10, {.d_s = variant_typ}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
			} else if (variant_sym->kind == v__ast__Kind__enum_) {
				strings__Builder_writeln(enc,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\to = "), 0xfe10, {.d_s = v__gen__c__js_enc_name(_SLIT("u64"))}}, {_SLIT("(*val._"), 0xfe10, {.d_s = variant_typ}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
			} else if (string__eq(variant_sym->name, _SLIT("time.Time"))) {
				strings__Builder_writeln(enc,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\tcJSON_AddItemToObject(o, \"_type\", cJSON_CreateString(\""), 0xfe10, {.d_s = unmangled_variant_name}}, {_SLIT("\"));"), 0, { .d_c = 0 }}})));
				strings__Builder_writeln(enc,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\tcJSON_AddItemToObject(o, \"value\", "), 0xfe10, {.d_s = v__gen__c__js_enc_name(_SLIT("i64"))}}, {_SLIT("(val._"), 0xfe10, {.d_s = variant_typ}}, {_SLIT("->_v_unix));"), 0, { .d_c = 0 }}})));
			} else {
				strings__Builder_writeln(enc,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\to = "), 0xfe10, {.d_s = v__gen__c__js_enc_name(variant_typ)}}, {_SLIT("(*val._"), 0xfe10, {.d_s = variant_typ}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
				strings__Builder_writeln(enc,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\tcJSON_AddItemToObject(o, \"_type\", cJSON_CreateString(\""), 0xfe10, {.d_s = unmangled_variant_name}}, {_SLIT("\"));"), 0, { .d_c = 0 }}})));
			}
		}
		#endif
		strings__Builder_writeln(enc, _SLIT("\t}"));
		string tmp = v__gen__c__Gen_new_tmp_var(g);
		#if defined(CUSTOM_DEFINE_json_no_inline_sumtypes)
		{
		}
		#else
		{
			if (string__eq(variant_sym->name, _SLIT("time.Time"))) {
				strings__Builder_writeln(dec,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\t\tif (strcmp(\"Time\", "), 0xfe10, {.d_s = type_var}}, {_SLIT(") == 0) {"), 0, { .d_c = 0 }}})));
				v__gen__c__gen_js_get(sym.cname, tmp, _SLIT("value"), dec, true);
				strings__Builder_writeln(dec,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("\t\t\t\t"), 0xfe10, {.d_s = variant_typ}}, {_SLIT(" "), 0xfe10, {.d_s = tmp}}, {_SLIT(" = time__unix("), 0xfe10, {.d_s = v__gen__c__js_dec_name(_SLIT("i64"))}}, {_SLIT("(jsonroot_"), 0xfe10, {.d_s = tmp}}, {_SLIT("));"), 0, { .d_c = 0 }}})));
				strings__Builder_writeln(dec,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\t\t\t\tres = "), 0xfe10, {.d_s = variant_typ}}, {_SLIT("_to_sumtype_"), 0xfe10, {.d_s = sym.cname}}, {_SLIT("(&"), 0xfe10, {.d_s = tmp}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
				strings__Builder_writeln(dec, _SLIT("\t\t\t}"));
			} else if (!v__gen__c__is_js_prim(variant_typ) && variant_sym->kind != v__ast__Kind__enum_) {
				strings__Builder_writeln(dec,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\t\tif (strcmp(\""), 0xfe10, {.d_s = unmangled_variant_name}}, {_SLIT("\", "), 0xfe10, {.d_s = type_var}}, {_SLIT(") == 0) {"), 0, { .d_c = 0 }}})));
				strings__Builder_writeln(dec,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\t\t\t\tOption_"), 0xfe10, {.d_s = variant_typ}}, {_SLIT(" "), 0xfe10, {.d_s = tmp}}, {_SLIT(" = "), 0xfe10, {.d_s = v__gen__c__js_dec_name(variant_typ)}}, {_SLIT("(root);"), 0, { .d_c = 0 }}})));
				strings__Builder_writeln(dec,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\t\t\tif ("), 0xfe10, {.d_s = tmp}}, {_SLIT(".state != 0) {"), 0, { .d_c = 0 }}})));
				strings__Builder_writeln(dec,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\t\t\t\t\treturn (Option_"), 0xfe10, {.d_s = sym.cname}}, {_SLIT("){ .state = "), 0xfe10, {.d_s = tmp}}, {_SLIT(".state, .err = "), 0xfe10, {.d_s = tmp}}, {_SLIT(".err, .data = {0} };"), 0, { .d_c = 0 }}})));
				strings__Builder_writeln(dec, _SLIT("\t\t\t\t}"));
				strings__Builder_writeln(dec,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("\t\t\t\tres = "), 0xfe10, {.d_s = variant_typ}}, {_SLIT("_to_sumtype_"), 0xfe10, {.d_s = sym.cname}}, {_SLIT("(("), 0xfe10, {.d_s = variant_typ}}, {_SLIT("*)"), 0xfe10, {.d_s = tmp}}, {_SLIT(".data);"), 0, { .d_c = 0 }}})));
				strings__Builder_writeln(dec, _SLIT("\t\t\t}"));
			}
		}
		#endif
	}
	#if !defined(CUSTOM_DEFINE_json_no_inline_sumtypes)
	{
		strings__Builder_writeln(dec, _SLIT("\t\t}"));
		bool number_is_met = false;
		bool string_is_met = false;
		string last_number_type = _SLIT("");
		if (at_least_one_prim) {
			strings__Builder_writeln(dec, _SLIT("\t} else {"));
			if (Array_string_contains(variant_types, _SLIT("bool"))) {
				string var_t = _SLIT("bool");
				strings__Builder_writeln(dec, _SLIT("\t\tif (cJSON_IsBool(root)) {"));
				strings__Builder_writeln(dec,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\t\t"), 0xfe10, {.d_s = var_t}}, {_SLIT(" value = "), 0xfe10, {.d_s = v__gen__c__js_dec_name(var_t)}}, {_SLIT("(root);"), 0, { .d_c = 0 }}})));
				strings__Builder_writeln(dec,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\t\tres = "), 0xfe10, {.d_s = var_t}}, {_SLIT("_to_sumtype_"), 0xfe10, {.d_s = sym.cname}}, {_SLIT("(&value);"), 0, { .d_c = 0 }}})));
				strings__Builder_writeln(dec, _SLIT("\t\t}"));
			}
			for (int i = 0; i < variant_types.len; ++i) {
				string var_t = ((string*)variant_types.data)[i];
				if ((*(v__ast__TypeSymbol*)/*ee elem_typ */array_get(variant_symbols, i)).kind == v__ast__Kind__enum_) {
					if (number_is_met) {
						string var_num = string_replace(var_t, _SLIT("__"), _SLIT("."));
						string last_num = string_replace(last_number_type, _SLIT("__"), _SLIT("."));
						v__gen__c__verror( str_intp(5, _MOV((StrIntpData[]){{_SLIT("json: can not decode `"), 0xfe10, {.d_s = sym.name}}, {_SLIT("` sumtype, too many numeric types (conflict of `"), 0xfe10, {.d_s = last_num}}, {_SLIT("` and `"), 0xfe10, {.d_s = var_num}}, {_SLIT("`), you can try to use alias for `"), 0xfe10, {.d_s = var_num}}, {_SLIT("` or compile v with `json_no_inline_sumtypes` flag"), 0, { .d_c = 0 }}})));
						VUNREACHABLE();
					}
					number_is_met = true;
					last_number_type = var_t;
					strings__Builder_writeln(dec, _SLIT("\t\tif (cJSON_IsNumber(root)) {"));
					strings__Builder_writeln(dec,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\t\t"), 0xfe10, {.d_s = var_t}}, {_SLIT(" value = "), 0xfe10, {.d_s = v__gen__c__js_dec_name(_SLIT("u64"))}}, {_SLIT("(root);"), 0, { .d_c = 0 }}})));
					strings__Builder_writeln(dec,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\t\tres = "), 0xfe10, {.d_s = var_t}}, {_SLIT("_to_sumtype_"), 0xfe10, {.d_s = sym.cname}}, {_SLIT("(&value);"), 0, { .d_c = 0 }}})));
					strings__Builder_writeln(dec, _SLIT("\t\t}"));
				}
				if (string__eq(var_t, _SLIT("string")) || string__eq(var_t, _SLIT("rune"))) {
					if (string_is_met) {
						string var_num = string_replace(var_t, _SLIT("__"), _SLIT("."));
						v__gen__c__verror( str_intp(3, _MOV((StrIntpData[]){{_SLIT("json: can not decode `"), 0xfe10, {.d_s = sym.name}}, {_SLIT("` sumtype, too many string types (conflict of `string` and `rune`), you can try to use alias for `"), 0xfe10, {.d_s = var_num}}, {_SLIT("` or compile v with `json_no_inline_sumtypes` flag"), 0, { .d_c = 0 }}})));
						VUNREACHABLE();
					}
					string_is_met = true;
					strings__Builder_writeln(dec, _SLIT("\t\tif (cJSON_IsString(root)) {"));
					strings__Builder_writeln(dec,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\t\t"), 0xfe10, {.d_s = var_t}}, {_SLIT(" value = "), 0xfe10, {.d_s = v__gen__c__js_dec_name(var_t)}}, {_SLIT("(root);"), 0, { .d_c = 0 }}})));
					strings__Builder_writeln(dec,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\t\tres = "), 0xfe10, {.d_s = var_t}}, {_SLIT("_to_sumtype_"), 0xfe10, {.d_s = sym.cname}}, {_SLIT("(&value);"), 0, { .d_c = 0 }}})));
					strings__Builder_writeln(dec, _SLIT("\t\t}"));
				}
				if (string__eq(var_t, _SLIT("i64")) || string__eq(var_t, _SLIT("int")) || string__eq(var_t, _SLIT("i8")) || string__eq(var_t, _SLIT("u64")) || string__eq(var_t, _SLIT("u32")) || string__eq(var_t, _SLIT("u16")) || string__eq(var_t, _SLIT("byte")) || string__eq(var_t, _SLIT("u8")) || string__eq(var_t, _SLIT("rune")) || string__eq(var_t, _SLIT("f64")) || string__eq(var_t, _SLIT("f32"))) {
					if (number_is_met) {
						string var_num = string_replace(var_t, _SLIT("__"), _SLIT("."));
						string last_num = string_replace(last_number_type, _SLIT("__"), _SLIT("."));
						v__gen__c__verror( str_intp(5, _MOV((StrIntpData[]){{_SLIT("json: can not decode `"), 0xfe10, {.d_s = sym.name}}, {_SLIT("` sumtype, too many numeric types (conflict of `"), 0xfe10, {.d_s = last_num}}, {_SLIT("` and `"), 0xfe10, {.d_s = var_num}}, {_SLIT("`), you can try to use alias for `"), 0xfe10, {.d_s = var_num}}, {_SLIT("` or compile v with `json_no_inline_sumtypes` flag"), 0, { .d_c = 0 }}})));
						VUNREACHABLE();
					}
					number_is_met = true;
					last_number_type = var_t;
					strings__Builder_writeln(dec, _SLIT("\t\tif (cJSON_IsNumber(root)) {"));
					strings__Builder_writeln(dec,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\t\t"), 0xfe10, {.d_s = var_t}}, {_SLIT(" value = "), 0xfe10, {.d_s = v__gen__c__js_dec_name(var_t)}}, {_SLIT("(root);"), 0, { .d_c = 0 }}})));
					strings__Builder_writeln(dec,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\t\tres = "), 0xfe10, {.d_s = var_t}}, {_SLIT("_to_sumtype_"), 0xfe10, {.d_s = sym.cname}}, {_SLIT("(&value);"), 0, { .d_c = 0 }}})));
					strings__Builder_writeln(dec, _SLIT("\t\t}"));
				}
			}
		}
		strings__Builder_writeln(dec, _SLIT("\t}"));
	}
	#endif
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_struct_enc_dec(v__gen__c__Gen* g, v__ast__TypeInfo type_info, string styp, strings__Builder* enc, strings__Builder* dec) {
	v__ast__Struct info = /* as */ *(v__ast__Struct*)__as_cast((type_info)._v__ast__Struct,(type_info)._typ, 446) /*expected idx: 446, name: v.ast.Struct */ ;
	for (int _t1 = 0; _t1 < info.fields.len; ++_t1) {
		v__ast__StructField field = ((v__ast__StructField*)info.fields.data)[_t1];
		string name = field.name;
		bool is_raw = false;
		bool is_skip = false;
		bool is_required = false;
		bool is_omit_empty = false;
		for (int _t2 = 0; _t2 < field.attrs.len; ++_t2) {
			v__ast__Attr attr = ((v__ast__Attr*)field.attrs.data)[_t2];

			if (string__eq(attr.name, _SLIT("json"))) {
				name = attr.arg;
			}
			else if (string__eq(attr.name, _SLIT("skip"))) {
				is_skip = true;
			}
			else if (string__eq(attr.name, _SLIT("raw"))) {
				is_raw = true;
			}
			else if (string__eq(attr.name, _SLIT("required"))) {
				is_required = true;
			}
			else if (string__eq(attr.name, _SLIT("omitempty"))) {
				is_omit_empty = true;
			}
			else {
			};
		}
		if (is_skip) {
			continue;
		}
		string field_type = v__gen__c__Gen_typ(g, field.typ);
		v__ast__TypeSymbol* field_sym = v__ast__Table_sym(g->table, field.typ);
		if (is_raw) {
			strings__Builder_writeln(dec, string__plus( str_intp(2, _MOV((StrIntpData[]){{_SLIT("\tres."), 0xfe10, {.d_s = v__gen__c__c_name(field.name)}}, {_SLIT(" = tos5(cJSON_PrintUnformatted("), 0, { .d_c = 0 }}})),  str_intp(2, _MOV((StrIntpData[]){{_SLIT("js_get(root, \""), 0xfe10, {.d_s = name}}, {_SLIT("\")));"), 0, { .d_c = 0 }}}))));
		} else {
			v__gen__c__Gen_gen_json_for_type(g, field.typ);
			string dec_name = v__gen__c__js_dec_name(field_type);
			if (v__gen__c__is_js_prim(field_type)) {
				string tmp = v__gen__c__Gen_new_tmp_var(g);
				v__gen__c__gen_js_get(styp, tmp, name, dec, is_required);
				strings__Builder_writeln(dec,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\tres."), 0xfe10, {.d_s = v__gen__c__c_name(field.name)}}, {_SLIT(" = "), 0xfe10, {.d_s = dec_name}}, {_SLIT(" (jsonroot_"), 0xfe10, {.d_s = tmp}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
			} else if (field_sym->kind == v__ast__Kind__enum_) {
				string tmp = v__gen__c__Gen_new_tmp_var(g);
				v__gen__c__gen_js_get(styp, tmp, name, dec, is_required);
				strings__Builder_writeln(dec,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\tres."), 0xfe10, {.d_s = v__gen__c__c_name(field.name)}}, {_SLIT(" = json__decode_u64(jsonroot_"), 0xfe10, {.d_s = tmp}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
			} else if (string__eq(field_sym->name, _SLIT("time.Time"))) {
				string tmp = v__gen__c__Gen_new_tmp_var(g);
				v__gen__c__gen_js_get(styp, tmp, name, dec, is_required);
				strings__Builder_writeln(dec,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\tres."), 0xfe10, {.d_s = v__gen__c__c_name(field.name)}}, {_SLIT(" = time__unix(json__decode_u64(jsonroot_"), 0xfe10, {.d_s = tmp}}, {_SLIT("));"), 0, { .d_c = 0 }}})));
			} else if (field_sym->kind == v__ast__Kind__alias) {
				v__ast__Alias alias = /* as */ *(v__ast__Alias*)__as_cast((field_sym->info)._v__ast__Alias,(field_sym->info)._typ, 460) /*expected idx: 460, name: v.ast.Alias */ ;
				string parent_type = v__gen__c__Gen_typ(g, alias.parent_type);
				string parent_dec_name = v__gen__c__js_dec_name(parent_type);
				if (v__gen__c__is_js_prim(parent_type)) {
					string tmp = v__gen__c__Gen_new_tmp_var(g);
					v__gen__c__gen_js_get(styp, tmp, name, dec, is_required);
					strings__Builder_writeln(dec,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\tres."), 0xfe10, {.d_s = v__gen__c__c_name(field.name)}}, {_SLIT(" = "), 0xfe10, {.d_s = parent_dec_name}}, {_SLIT(" (jsonroot_"), 0xfe10, {.d_s = tmp}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
				} else {
					v__gen__c__Gen_gen_json_for_type(g, field.typ);
					string tmp = v__gen__c__Gen_new_tmp_var(g);
					v__gen__c__gen_js_get_opt(dec_name, field_type, styp, tmp, name, dec, is_required);
					strings__Builder_writeln(dec,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\tres."), 0xfe10, {.d_s = v__gen__c__c_name(field.name)}}, {_SLIT(" = *("), 0xfe10, {.d_s = field_type}}, {_SLIT("*) "), 0xfe10, {.d_s = tmp}}, {_SLIT(".data;"), 0, { .d_c = 0 }}})));
				}
			} else {
				string tmp = v__gen__c__Gen_new_tmp_var(g);
				v__gen__c__gen_js_get_opt(dec_name, field_type, styp, tmp, name, dec, is_required);
				strings__Builder_writeln(dec,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\tres."), 0xfe10, {.d_s = v__gen__c__c_name(field.name)}}, {_SLIT(" = *("), 0xfe10, {.d_s = field_type}}, {_SLIT("*) "), 0xfe10, {.d_s = tmp}}, {_SLIT(".data;"), 0, { .d_c = 0 }}})));
			}
		}
		string enc_name = v__gen__c__js_enc_name(field_type);
		if (is_omit_empty) {
			strings__Builder_writeln(enc,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t if (val."), 0xfe10, {.d_s = v__gen__c__c_name(field.name)}}, {_SLIT(" != "), 0xfe10, {.d_s = v__gen__c__Gen_type_default(g, field.typ)}}, {_SLIT(") \n"), 0, { .d_c = 0 }}})));
		}
		if (!v__gen__c__is_js_prim(field_type)) {
			if (field_sym->kind == v__ast__Kind__alias) {
				v__ast__Alias ainfo = /* as */ *(v__ast__Alias*)__as_cast((field_sym->info)._v__ast__Alias,(field_sym->info)._typ, 460) /*expected idx: 460, name: v.ast.Alias */ ;
				enc_name = v__gen__c__js_enc_name(v__gen__c__Gen_typ(g, ainfo.parent_type));
			}
		}
		if (field_sym->kind == v__ast__Kind__enum_) {
			strings__Builder_writeln(enc,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\tcJSON_AddItemToObject(o, \""), 0xfe10, {.d_s = name}}, {_SLIT("\", json__encode_u64(val."), 0xfe10, {.d_s = v__gen__c__c_name(field.name)}}, {_SLIT("));\n"), 0, { .d_c = 0 }}})));
		} else {
			if (string__eq(field_sym->name, _SLIT("time.Time"))) {
				strings__Builder_writeln(enc,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\tcJSON_AddItemToObject(o, \""), 0xfe10, {.d_s = name}}, {_SLIT("\", json__encode_u64(val."), 0xfe10, {.d_s = v__gen__c__c_name(field.name)}}, {_SLIT("._v_unix));"), 0, { .d_c = 0 }}})));
			} else {
				strings__Builder_writeln(enc,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\tcJSON_AddItemToObject(o, \""), 0xfe10, {.d_s = name}}, {_SLIT("\", "), 0xfe10, {.d_s = enc_name}}, {_SLIT("(val."), 0xfe10, {.d_s = v__gen__c__c_name(field.name)}}, {_SLIT("));\n"), 0, { .d_c = 0 }}})));
			}
		}
	}
}

VV_LOCAL_SYMBOL void v__gen__c__gen_js_get(string styp, string tmp, string name, strings__Builder* dec, bool is_required) {
	strings__Builder_writeln(dec,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\tcJSON *jsonroot_"), 0xfe10, {.d_s = tmp}}, {_SLIT(" = js_get(root,\""), 0xfe10, {.d_s = name}}, {_SLIT("\");"), 0, { .d_c = 0 }}})));
	if (is_required) {
		strings__Builder_writeln(dec,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\tif(jsonroot_"), 0xfe10, {.d_s = tmp}}, {_SLIT(" == 0) {"), 0, { .d_c = 0 }}})));
		strings__Builder_writeln(dec,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t\treturn (Option_"), 0xfe10, {.d_s = styp}}, {_SLIT("){ .state = 2, .err = _v_error(_SLIT(\"expected field \'"), 0xfe10, {.d_s = name}}, {_SLIT("\' is missing\")), .data = {0} };"), 0, { .d_c = 0 }}})));
		strings__Builder_writeln(dec, _SLIT("\t}"));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__gen_js_get_opt(string dec_name, string field_type, string styp, string tmp, string name, strings__Builder* dec, bool is_required) {
	v__gen__c__gen_js_get(styp, tmp, name, dec, is_required);
	strings__Builder_writeln(dec,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("\tOption_"), 0xfe10, {.d_s = field_type}}, {_SLIT(" "), 0xfe10, {.d_s = tmp}}, {_SLIT(" = "), 0xfe10, {.d_s = dec_name}}, {_SLIT(" (jsonroot_"), 0xfe10, {.d_s = tmp}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(dec,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\tif("), 0xfe10, {.d_s = tmp}}, {_SLIT(".state != 0) {"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(dec,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\t\treturn (Option_"), 0xfe10, {.d_s = styp}}, {_SLIT("){ .state = "), 0xfe10, {.d_s = tmp}}, {_SLIT(".state, .err = "), 0xfe10, {.d_s = tmp}}, {_SLIT(".err, .data = {0} };"), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(dec, _SLIT("\t}"));
}

VV_LOCAL_SYMBOL string v__gen__c__js_enc_name(string typ) {
	string suffix = (string_ends_with(typ, _SLIT("*")) ? (string_replace(typ, _SLIT("*"), _SLIT(""))) : (typ));
	string name =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("json__encode_"), 0xfe10, {.d_s = suffix}}, {_SLIT0, 0, { .d_c = 0 }}}));
	string _t1 = v__util__no_dots(name);
	return _t1;
}

VV_LOCAL_SYMBOL string v__gen__c__js_dec_name(string typ) {
	string name =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("json__decode_"), 0xfe10, {.d_s = typ}}, {_SLIT0, 0, { .d_c = 0 }}}));
	string _t1 = v__util__no_dots(name);
	return _t1;
}

VV_LOCAL_SYMBOL bool v__gen__c__is_js_prim(string typ) {
	bool _t1 = (string__eq(typ, _SLIT("int")) || string__eq(typ, _SLIT("rune")) || string__eq(typ, _SLIT("string")) || string__eq(typ, _SLIT("bool")) || string__eq(typ, _SLIT("f32")) || string__eq(typ, _SLIT("f64")) || string__eq(typ, _SLIT("i8")) || string__eq(typ, _SLIT("i16")) || string__eq(typ, _SLIT("i64")) || string__eq(typ, _SLIT("u8")) || string__eq(typ, _SLIT("u16")) || string__eq(typ, _SLIT("u32")) || string__eq(typ, _SLIT("u64")) || string__eq(typ, _SLIT("byte")));
	return _t1;
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_decode_array(v__gen__c__Gen* g, v__ast__Type value_type) {
	string styp = v__gen__c__Gen_typ(g, value_type);
	string fn_name = v__gen__c__js_dec_name(styp);
	string s = _SLIT("");
	if (v__gen__c__is_js_prim(styp)) {
		s =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = styp}}, {_SLIT(" val = "), 0xfe10, {.d_s = fn_name}}, {_SLIT("((cJSON *)jsval); "), 0, { .d_c = 0 }}}));
	} else {
		s =  str_intp(6, _MOV((StrIntpData[]){{_SLIT("\n		Option_"), 0xfe10, {.d_s = styp}}, {_SLIT(" val2 = "), 0xfe10, {.d_s = fn_name}}, {_SLIT(" ((cJSON *)jsval);\n		if(val2.state != 0) {\n			array_free(&res);\n			return *(Option_Array_"), 0xfe10, {.d_s = styp}}, {_SLIT("*)&val2;\n		}\n		"), 0xfe10, {.d_s = styp}}, {_SLIT(" val = *("), 0xfe10, {.d_s = styp}}, {_SLIT("*)val2.data;\n"), 0, { .d_c = 0 }}}));
	}
	string noscan = v__gen__c__Gen_check_noscan(g, value_type);
	string _t1 =  str_intp(6, _MOV((StrIntpData[]){{_SLIT("\n	if(root && !cJSON_IsArray(root) && !cJSON_IsNull(root)) {\n		return (Option_Array_"), 0xfe10, {.d_s = styp}}, {_SLIT("){.state = 2, .err = _v_error(string__plus(_SLIT(\"Json element is not an array: \"), tos2((byteptr)cJSON_PrintUnformatted(root)))), .data = {0}};\n	}\n	res = __new_array"), 0xfe10, {.d_s = noscan}}, {_SLIT("(0, 0, sizeof("), 0xfe10, {.d_s = styp}}, {_SLIT("));\n	const cJSON *jsval = NULL;\n	cJSON_ArrayForEach(jsval, root)\n	{\n	"), 0xfe10, {.d_s = s}}, {_SLIT("\n		array_push"), 0xfe10, {.d_s = noscan}}, {_SLIT("((array*)&res, &val);\n	}\n"), 0, { .d_c = 0 }}}));
	return _t1;
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_encode_array(v__gen__c__Gen* g, v__ast__Type value_type) {
	string styp = v__gen__c__Gen_typ(g, value_type);
	string fn_name = v__gen__c__js_enc_name(styp);
	string _t1 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\n	o = cJSON_CreateArray();\n	for (int i = 0; i < val.len; i++){\n		cJSON_AddItemToArray(o, "), 0xfe10, {.d_s = fn_name}}, {_SLIT(" (  (("), 0xfe10, {.d_s = styp}}, {_SLIT("*)val.data)[i]  ));\n	}\n"), 0, { .d_c = 0 }}}));
	return _t1;
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_decode_map(v__gen__c__Gen* g, v__ast__Type key_type, v__ast__Type value_type) {
	string styp = v__gen__c__Gen_typ(g, key_type);
	string styp_v = v__gen__c__Gen_typ(g, value_type);
	v__ast__TypeSymbol* key_type_symbol = v__ast__Table_sym(g->table, key_type);
	multi_return_string_string_string_string mr_17153 = v__gen__c__Gen_map_fn_ptrs(g, *key_type_symbol);
	string hash_fn = mr_17153.arg0;
	string key_eq_fn = mr_17153.arg1;
	string clone_fn = mr_17153.arg2;
	string free_fn = mr_17153.arg3;
	string fn_name_v = v__gen__c__js_dec_name(styp_v);
	string s = _SLIT("");
	if (v__gen__c__is_js_prim(styp_v)) {
		s =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = styp_v}}, {_SLIT(" val = "), 0xfe10, {.d_s = fn_name_v}}, {_SLIT(" (js_get(root, jsval->string));"), 0, { .d_c = 0 }}}));
	} else {
		s =  str_intp(7, _MOV((StrIntpData[]){{_SLIT("\n		Option_"), 0xfe10, {.d_s = styp_v}}, {_SLIT(" val2 = "), 0xfe10, {.d_s = fn_name_v}}, {_SLIT(" (js_get(root, jsval->string));\n		if(val2.state != 0) {\n			map_free(&res);\n			return *(Option_Map_"), 0xfe10, {.d_s = styp}}, {_SLIT("_"), 0xfe10, {.d_s = styp_v}}, {_SLIT("*)&val2;\n		}\n		"), 0xfe10, {.d_s = styp_v}}, {_SLIT(" val = *("), 0xfe10, {.d_s = styp_v}}, {_SLIT("*)val2.data;\n"), 0, { .d_c = 0 }}}));
	}
	string _t1 =  str_intp(10, _MOV((StrIntpData[]){{_SLIT("\n	if(!cJSON_IsObject(root) && !cJSON_IsNull(root)) {\n		return (Option_Map_"), 0xfe10, {.d_s = styp}}, {_SLIT("_"), 0xfe10, {.d_s = styp_v}}, {_SLIT("){ .state = 2, .err = _v_error(string__plus(_SLIT(\"Json element is not an object: \"), tos2((byteptr)cJSON_PrintUnformatted(root)))), .data = {0}};\n	}\n	res = new_map(sizeof("), 0xfe10, {.d_s = styp}}, {_SLIT("), sizeof("), 0xfe10, {.d_s = styp_v}}, {_SLIT("), "), 0xfe10, {.d_s = hash_fn}}, {_SLIT(", "), 0xfe10, {.d_s = key_eq_fn}}, {_SLIT(", "), 0xfe10, {.d_s = clone_fn}}, {_SLIT(", "), 0xfe10, {.d_s = free_fn}}, {_SLIT(");\n	cJSON *jsval = NULL;\n	cJSON_ArrayForEach(jsval, root)\n	{\n		"), 0xfe10, {.d_s = s}}, {_SLIT("\n		string key = tos2((byteptr)jsval->string);\n		map_set(&res, &key, &val);\n	}\n"), 0, { .d_c = 0 }}}));
	return _t1;
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_encode_map(v__gen__c__Gen* g, v__ast__Type key_type, v__ast__Type value_type) {
	string styp = v__gen__c__Gen_typ(g, key_type);
	string styp_v = v__gen__c__Gen_typ(g, value_type);
	string fn_name_v = v__gen__c__js_enc_name(styp_v);
	string zero = v__gen__c__Gen_type_default(g, value_type);
	string keys_tmp = v__gen__c__Gen_new_tmp_var(g);
	string key = _SLIT("string key = ");
	if (v__ast__Type_is_string(key_type)) {
		key = /*f*/string__plus(key,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("(("), 0xfe10, {.d_s = styp}}, {_SLIT("*)"), 0xfe10, {.d_s = keys_tmp}}, {_SLIT(".data)[i];"), 0, { .d_c = 0 }}})));
	} else {
		v__gen__c__verror(_SLIT("json: encode only maps with string keys"));
		VUNREACHABLE();
	}
	string _t1 =  str_intp(10, _MOV((StrIntpData[]){{_SLIT("\n	o = cJSON_CreateObject();\n	Array_"), 0xfe10, {.d_s = styp}}, {_SLIT(" "), 0xfe10, {.d_s = keys_tmp}}, {_SLIT(" = map_keys(&val);\n	for (int i = 0; i < "), 0xfe10, {.d_s = keys_tmp}}, {_SLIT(".len; ++i) {\n		"), 0xfe10, {.d_s = key}}, {_SLIT("\n		cJSON_AddItemToObject(o, (char*) key.str, "), 0xfe10, {.d_s = fn_name_v}}, {_SLIT(" ( *("), 0xfe10, {.d_s = styp_v}}, {_SLIT("*) map_get(&val, &key, &("), 0xfe10, {.d_s = styp_v}}, {_SLIT("[]) { "), 0xfe10, {.d_s = zero}}, {_SLIT(" } ) ) );\n	}\n	array_free(&"), 0xfe10, {.d_s = keys_tmp}}, {_SLIT(");\n"), 0, { .d_c = 0 }}}));
	return _t1;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_generate_hotcode_reloading_declarations(v__gen__c__Gen* g) {
	if (g->pref->os == v__pref__OS__windows) {
		if (g->pref->is_livemain) {
			strings__Builder_writeln(&g->hotcode_definitions, _SLIT("HANDLE live_fn_mutex = 0;"));
		}
		if (g->pref->is_liveshared) {
			strings__Builder_writeln(&g->hotcode_definitions, _SLIT("HANDLE live_fn_mutex;"));
		}
		strings__Builder_writeln(&g->hotcode_definitions, _SLIT("\nvoid pthread_mutex_lock(HANDLE *m) {\n	WaitForSingleObject(*m, INFINITE);\n}\nvoid pthread_mutex_unlock(HANDLE *m) {\n	ReleaseMutex(*m);\n}\n"));
	} else {
		if (g->pref->is_livemain) {
			strings__Builder_writeln(&g->hotcode_definitions, _SLIT("pthread_mutex_t live_fn_mutex = PTHREAD_MUTEX_INITIALIZER;"));
		}
		if (g->pref->is_liveshared) {
			strings__Builder_writeln(&g->hotcode_definitions, _SLIT("pthread_mutex_t live_fn_mutex;"));
		}
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_generate_hotcode_reloader_code(v__gen__c__Gen* g) {
	if (g->pref->is_liveshared) {
		strings__Builder_writeln(&g->hotcode_definitions, _SLIT(""));
		return;
	}
	if (g->pref->is_livemain) {
		string phd = _SLIT("");
		Array_string load_code = __new_array_with_default(0, 0, sizeof(string), 0);
		if (g->pref->os != v__pref__OS__windows) {
			for (int _t1 = 0; _t1 < g->hotcode_fn_names.len; ++_t1) {
				string so_fn = ((string*)g->hotcode_fn_names.data)[_t1];
				array_push((array*)&load_code, _MOV((string[]){ string_clone( str_intp(3, _MOV((StrIntpData[]){{_SLIT("impl_live_"), 0xfe10, {.d_s = so_fn}}, {_SLIT(" = dlsym(live_lib, \"impl_live_"), 0xfe10, {.d_s = so_fn}}, {_SLIT("\");"), 0, { .d_c = 0 }}}))) }));
			}
			phd = _const_v__gen__c__posix_hotcode_definitions_1;
		} else {
			for (int _t3 = 0; _t3 < g->hotcode_fn_names.len; ++_t3) {
				string so_fn = ((string*)g->hotcode_fn_names.data)[_t3];
				array_push((array*)&load_code, _MOV((string[]){ string_clone( str_intp(3, _MOV((StrIntpData[]){{_SLIT("impl_live_"), 0xfe10, {.d_s = so_fn}}, {_SLIT(" = (void *)GetProcAddress(live_lib, \"impl_live_"), 0xfe10, {.d_s = so_fn}}, {_SLIT("\");  "), 0, { .d_c = 0 }}}))) }));
			}
			phd = _const_v__gen__c__windows_hotcode_definitions_1;
		}
		strings__Builder_writeln(&g->hotcode_definitions, string_replace(phd, _SLIT("@LOAD_FNS@"), Array_string_join(load_code, _SLIT("\n"))));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_generate_hotcode_reloading_main_caller(v__gen__c__Gen* g) {
	if (!g->pref->is_livemain) {
		return;
	}
	v__gen__c__Gen_writeln(g, _SLIT(""));
	v__gen__c__Gen_writeln(g, _SLIT("\t// live code initialization section:"));
	v__gen__c__Gen_writeln(g, _SLIT("\t{"));
	v__gen__c__Gen_writeln(g, _SLIT("\t\t// initialization of live function pointers"));
	for (int _t1 = 0; _t1 < g->hotcode_fn_names.len; ++_t1) {
		string fname = ((string*)g->hotcode_fn_names.data)[_t1];
		v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\timpl_live_"), 0xfe10, {.d_s = fname}}, {_SLIT(" = 0;"), 0, { .d_c = 0 }}})));
	}
	string vexe = v__util__cescaped_path(v__pref__vexe_path());
	string file = v__util__cescaped_path(g->pref->path);
	string msvc = (string__eq(g->pref->ccompiler, _SLIT("msvc")) ? (_SLIT("-cc msvc")) : (_SLIT("")));
	string so_debug_flag = (g->pref->is_debug ? (_SLIT("-cg")) : (_SLIT("")));
	string vopts =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = msvc}}, {_SLIT(" "), 0xfe10, {.d_s = so_debug_flag}}, {_SLIT(" -sharedlive -shared"), 0, { .d_c = 0 }}}));
	v__gen__c__Gen_writeln(g, _SLIT("\t\t// start background reloading thread"));
	if (g->pref->os == v__pref__OS__windows) {
		v__gen__c__Gen_writeln(g, _SLIT("\t\tlive_fn_mutex = CreateMutexA(0, 0, 0);"));
	}
	v__gen__c__Gen_writeln(g, _SLIT("\t\tv__live__LiveReloadInfo* live_info = v__live__executable__new_live_reload_info("));
	v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\t\t\t\t tos2(\""), 0xfe10, {.d_s = file}}, {_SLIT("\"),"), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\t\t\t\t tos2(\""), 0xfe10, {.d_s = vexe}}, {_SLIT("\"),"), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\t\t\t\t\t tos2(\""), 0xfe10, {.d_s = vopts}}, {_SLIT("\"),"), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_writeln(g, _SLIT("\t\t\t\t\t &live_fn_mutex,"));
	v__gen__c__Gen_writeln(g, _SLIT("\t\t\t\t\t v_bind_live_symbols"));
	v__gen__c__Gen_writeln(g, _SLIT("\t\t);"));
	v__gen__c__Gen_writeln(g, _SLIT("\t\t   g_live_info = (void*)live_info;"));
	v__gen__c__Gen_writeln(g, _SLIT("\t\tv__live__executable__start_reloader(live_info);"));
	v__gen__c__Gen_writeln(g, _SLIT("\t}\t// end of live code initialization section"));
	v__gen__c__Gen_writeln(g, _SLIT(""));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_profile_fn(v__gen__c__Gen* g, v__ast__FnDecl fn_decl) {
	if (g->pref->profile_no_inline && Array_v__ast__Attr_contains(fn_decl.attrs, _SLIT("inline"))) {
		g->defer_profile_code = _SLIT("");
		return;
	}
	string fn_name = fn_decl.name;
	if (string_starts_with(fn_name, _SLIT("time.vpc_now"))) {
		g->defer_profile_code = _SLIT("");
	} else {
		string measure_fn_name = (g->pref->os == v__pref__OS__macos ? (_SLIT("time__vpc_now_darwin")) : (_SLIT("time__vpc_now")));
		string fn_profile_counter_name =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("vpc_"), 0xfe10, {.d_s = g->last_fn_c_name}}, {_SLIT0, 0, { .d_c = 0 }}}));
		string fn_profile_counter_name_calls =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = fn_profile_counter_name}}, {_SLIT("_calls"), 0, { .d_c = 0 }}}));
		v__gen__c__Gen_writeln(g, _SLIT(""));
		v__gen__c__Gen_writeln(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\tdouble _PROF_FN_START = "), 0xfe10, {.d_s = measure_fn_name}}, {_SLIT("(); "), 0xfe10, {.d_s = fn_profile_counter_name_calls}}, {_SLIT("++; // "), 0xfe10, {.d_s = fn_name}}, {_SLIT0, 0, { .d_c = 0 }}})));
		v__gen__c__Gen_writeln(g, _SLIT(""));
		g->defer_profile_code =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = fn_profile_counter_name}}, {_SLIT(" += "), 0xfe10, {.d_s = measure_fn_name}}, {_SLIT("() - _PROF_FN_START;"), 0, { .d_c = 0 }}}));
		strings__Builder_writeln(&g->pcs_declarations,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("double "), 0xfe10, {.d_s = fn_profile_counter_name}}, {_SLIT(" = 0.0; u64 "), 0xfe10, {.d_s = fn_profile_counter_name_calls}}, {_SLIT(" = 0;"), 0, { .d_c = 0 }}})));
		array_push((array*)&g->pcs, _MOV((v__gen__c__ProfileCounterMeta[]){ (v__gen__c__ProfileCounterMeta){.fn_name = g->last_fn_c_name,.vpc_name = fn_profile_counter_name,.vpc_calls = fn_profile_counter_name_calls,} }));
	}
}

void v__gen__c__Gen_gen_vprint_profile_stats(v__gen__c__Gen* g) {
	strings__Builder_writeln(&g->pcs_declarations, _SLIT("void vprint_profile_stats(){"));
	string fstring = _SLIT("\"%14llu %14.3fms %14.0fns %s \\n\"");
	if (string__eq(g->pref->profile_file, _SLIT("-"))) {
		for (int _t1 = 0; _t1 < g->pcs.len; ++_t1) {
			v__gen__c__ProfileCounterMeta pc_meta = ((v__gen__c__ProfileCounterMeta*)g->pcs.data)[_t1];
			strings__Builder_writeln(&g->pcs_declarations,  str_intp(8, _MOV((StrIntpData[]){{_SLIT("\tif ("), 0xfe10, {.d_s = pc_meta.vpc_calls}}, {_SLIT(") printf("), 0xfe10, {.d_s = fstring}}, {_SLIT(", "), 0xfe10, {.d_s = pc_meta.vpc_calls}}, {_SLIT(", "), 0xfe10, {.d_s = pc_meta.vpc_name}}, {_SLIT("/1000000.0, "), 0xfe10, {.d_s = pc_meta.vpc_name}}, {_SLIT("/"), 0xfe10, {.d_s = pc_meta.vpc_calls}}, {_SLIT(", \""), 0xfe10, {.d_s = pc_meta.fn_name}}, {_SLIT("\" );"), 0, { .d_c = 0 }}})));
		}
	} else {
		strings__Builder_writeln(&g->pcs_declarations, _SLIT("\tFILE * fp;"));
		strings__Builder_writeln(&g->pcs_declarations,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\tfp = fopen (\""), 0xfe10, {.d_s = g->pref->profile_file}}, {_SLIT("\", \"w+\");"), 0, { .d_c = 0 }}})));
		for (int _t2 = 0; _t2 < g->pcs.len; ++_t2) {
			v__gen__c__ProfileCounterMeta pc_meta = ((v__gen__c__ProfileCounterMeta*)g->pcs.data)[_t2];
			strings__Builder_writeln(&g->pcs_declarations,  str_intp(8, _MOV((StrIntpData[]){{_SLIT("\tif ("), 0xfe10, {.d_s = pc_meta.vpc_calls}}, {_SLIT(") fprintf(fp, "), 0xfe10, {.d_s = fstring}}, {_SLIT(", "), 0xfe10, {.d_s = pc_meta.vpc_calls}}, {_SLIT(", "), 0xfe10, {.d_s = pc_meta.vpc_name}}, {_SLIT("/1000000.0, "), 0xfe10, {.d_s = pc_meta.vpc_name}}, {_SLIT("/"), 0xfe10, {.d_s = pc_meta.vpc_calls}}, {_SLIT(", \""), 0xfe10, {.d_s = pc_meta.fn_name}}, {_SLIT("\" );"), 0, { .d_c = 0 }}})));
		}
		strings__Builder_writeln(&g->pcs_declarations, _SLIT("\tfclose(fp);"));
	}
	strings__Builder_writeln(&g->pcs_declarations, _SLIT("}"));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_sql_stmt(v__gen__c__Gen* g, v__ast__SqlStmt node) {
	string conn = v__gen__c__Gen_new_tmp_var(g);
	v__gen__c__Gen_writeln(g, _SLIT(""));
	v__gen__c__Gen_writeln(g, _SLIT("// orm"));
	v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("orm__Connection "), 0xfe10, {.d_s = conn}}, {_SLIT(" = (orm__Connection){._"), 0, { .d_c = 0 }}})));
	string fn_prefix = _SLIT("");
	v__gen__c__SqlType typ = v__gen__c__Gen_parse_db_type(g, node.db_expr);

	if (typ == (v__gen__c__SqlType__sqlite3)) {
		fn_prefix = _SLIT("sqlite__DB");
	}
	else if (typ == (v__gen__c__SqlType__mysql)) {
		fn_prefix = _SLIT("mysql__Connection");
	}
	else if (typ == (v__gen__c__SqlType__psql)) {
		fn_prefix = _SLIT("pg__DB");
	}
	else {
		v__gen__c__verror( str_intp(2, _MOV((StrIntpData[]){{_SLIT("This database type `"), 0xfe10, {.d_s = v__gen__c__SqlType_str(typ)}}, {_SLIT("` is not implemented yet in orm"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	};
	v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = fn_prefix}}, {_SLIT(" = &"), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_expr(g, node.db_expr);
	v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(", ._typ = _orm__Connection_"), 0xfe10, {.d_s = fn_prefix}}, {_SLIT("_index};"), 0, { .d_c = 0 }}})));
	for (int _t1 = 0; _t1 < node.lines.len; ++_t1) {
		v__ast__SqlStmtLine line = ((v__ast__SqlStmtLine*)node.lines.data)[_t1];
		v__gen__c__Gen_sql_stmt_line(g, line, conn);
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_sql_stmt_line(v__gen__c__Gen* g, v__ast__SqlStmtLine nd, string expr) {
	v__ast__SqlStmtLine node = nd;
	string table_name = v__gen__c__Gen_get_table_name(g, node.table_expr);
	g->sql_table_name = v__ast__Table_sym(g->table, node.table_expr.typ)->name;
	string res = v__gen__c__Gen_new_tmp_var(g);
	bool subs = false;
	bool dcheck = false;
	if (node.kind != v__ast__SqlStmtKind__create) {
		Array_v__ast__StructField fields = __new_array_with_default(0, 0, sizeof(v__ast__StructField), 0);
		for (int _t1 = 0; _t1 < node.fields.len; ++_t1) {
			v__ast__StructField f = ((v__ast__StructField*)node.fields.data)[_t1];
			bool skip = false;
			bool primary = false;
			for (int _t2 = 0; _t2 < f.attrs.len; ++_t2) {
				v__ast__Attr attr = ((v__ast__Attr*)f.attrs.data)[_t2];
				if (string__eq(attr.name, _SLIT("primary"))) {
					primary = true;
				}
				if (string__eq(attr.name, _SLIT("skip"))) {
					skip = true;
				}
			}
			if (!skip && !primary) {
				array_push((array*)&fields, _MOV((v__ast__StructField[]){ f }));
			}
		}
		node.fields = array_clone_to_depth(&fields, 0);
		array_free(&fields);
	}
	if (node.kind == v__ast__SqlStmtKind__create) {
		v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("Option_void "), 0xfe10, {.d_s = res}}, {_SLIT(" = orm__Connection_name_table["), 0xfe10, {.d_s = expr}}, {_SLIT("._typ]._method_"), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_sql_create_table(g, node, expr, table_name);
		subs = true;
	} else if (node.kind == v__ast__SqlStmtKind__drop) {
		v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("Option_void "), 0xfe10, {.d_s = res}}, {_SLIT(" = orm__Connection_name_table["), 0xfe10, {.d_s = expr}}, {_SLIT("._typ]._method_"), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("drop("), 0xfe10, {.d_s = expr}}, {_SLIT("._object, _SLIT(\""), 0xfe10, {.d_s = table_name}}, {_SLIT("\"));"), 0, { .d_c = 0 }}})));
		subs = true;
	} else if (node.kind == v__ast__SqlStmtKind__insert) {
		string arr = v__gen__c__Gen_new_tmp_var(g);
		v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("Array_orm__Primitive "), 0xfe10, {.d_s = arr}}, {_SLIT(" = new_array_from_c_array(0, 0, sizeof(orm__Primitive), NULL);"), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_sql_insert(g, node, expr, table_name, arr, res, _SLIT(""), false, _SLIT(""));
		dcheck = true;
	} else if (node.kind == v__ast__SqlStmtKind__update) {
		v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("Option_void "), 0xfe10, {.d_s = res}}, {_SLIT(" = orm__Connection_name_table["), 0xfe10, {.d_s = expr}}, {_SLIT("._typ]._method_"), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_sql_update(g, node, expr, table_name);
	} else if (node.kind == v__ast__SqlStmtKind__delete) {
		v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("Option_void "), 0xfe10, {.d_s = res}}, {_SLIT(" = orm__Connection_name_table["), 0xfe10, {.d_s = expr}}, {_SLIT("._typ]._method_"), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_sql_delete(g, node, expr, table_name);
	}
	if (!dcheck) {
		v__gen__c__Gen_writeln(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("if ("), 0xfe10, {.d_s = res}}, {_SLIT(".state != 0 && "), 0xfe10, {.d_s = res}}, {_SLIT(".err._typ != _IError_None___index) { _v_panic(IError_str("), 0xfe10, {.d_s = res}}, {_SLIT(".err)); }"), 0, { .d_c = 0 }}})));
	}
	if (subs) {
		Map_int_v__ast__SqlStmtLine _t4 = node.sub_structs;
		int _t6 = _t4.key_values.len;
		for (int _t5 = 0; _t5 < _t6; ++_t5 ) {
			int _t7 = _t4.key_values.len - _t6;
			_t6 = _t4.key_values.len;
			if (_t7 < 0) {
				_t5 = -1;
				continue;
			}
			if (!DenseArray_has_index(&_t4.key_values, _t5)) {continue;}
			v__ast__SqlStmtLine sub = (*(v__ast__SqlStmtLine*)DenseArray_value(&_t4.key_values, _t5));
			v__gen__c__Gen_sql_stmt_line(g, sub, expr);
		}
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_sql_create_table(v__gen__c__Gen* g, v__ast__SqlStmtLine node, string expr, string table_name) {
	v__gen__c__Gen_write(g,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("create("), 0xfe10, {.d_s = expr}}, {_SLIT("._object, _SLIT(\""), 0xfe10, {.d_s = table_name}}, {_SLIT("\"), new_array_from_c_array("), 0xfe07, {.d_i32 = node.fields.len}}, {_SLIT(", "), 0xfe07, {.d_i32 = node.fields.len}}, {_SLIT(", sizeof(orm__TableField),"), 0, { .d_c = 0 }}})));
	if (node.fields.len > 0) {
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(" _MOV((orm__TableField["), 0xfe07, {.d_i32 = node.fields.len}}, {_SLIT("]){"), 0, { .d_c = 0 }}})));
		for (int _t1 = 0; _t1 < node.fields.len; ++_t1) {
			v__ast__StructField field = ((v__ast__StructField*)node.fields.data)[_t1];
			v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, field.typ);
			v__gen__c__Gen_write(g, _SLIT("(orm__TableField){"));
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(".name = _SLIT(\""), 0xfe10, {.d_s = field.name}}, {_SLIT("\"),"), 0, { .d_c = 0 }}})));
			int typ = ((int)(field.typ));
			if (string__eq(sym->name, _SLIT("time.Time"))) {
				typ = -2;
			}
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(".typ = "), 0xfe07, {.d_i32 = typ}}, {_SLIT(","), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(".is_arr = "), 0xfe10, {.d_s = sym->kind == v__ast__Kind__array ? _SLIT("true") : _SLIT("false")}}, {_SLIT(", "), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(".is_time = "), 0xfe07, {.d_i32 = ((int)(string__eq(v__ast__Table_get_type_name(g->table, field.typ), _SLIT("time__Time"))))}}, {_SLIT(","), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(".default_val = (string){.str = (byteptr) \""), 0xfe10, {.d_s = field.default_val}}, {_SLIT("\", .is_lit = 1},"), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT(".attrs = new_array_from_c_array("), 0xfe07, {.d_i32 = field.attrs.len}}, {_SLIT(", "), 0xfe07, {.d_i32 = field.attrs.len}}, {_SLIT(", sizeof(StructAttribute),"), 0, { .d_c = 0 }}})));
			if (field.attrs.len > 0) {
				v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(" _MOV((StructAttribute["), 0xfe07, {.d_i32 = field.attrs.len}}, {_SLIT("]){"), 0, { .d_c = 0 }}})));
				for (int _t2 = 0; _t2 < field.attrs.len; ++_t2) {
					v__ast__Attr attr = ((v__ast__Attr*)field.attrs.data)[_t2];
					v__gen__c__Gen_write(g, _SLIT("(StructAttribute){"));
					v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(".name = _SLIT(\""), 0xfe10, {.d_s = attr.name}}, {_SLIT("\"),"), 0, { .d_c = 0 }}})));
					v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(".has_arg = "), 0xfe07, {.d_i32 = ((int)(attr.has_arg))}}, {_SLIT(","), 0, { .d_c = 0 }}})));
					v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(".arg = _SLIT(\""), 0xfe10, {.d_s = attr.arg}}, {_SLIT("\"),"), 0, { .d_c = 0 }}})));
					v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(".kind = "), 0xfe07, {.d_i32 = ((int)(attr.kind))}}, {_SLIT(","), 0, { .d_c = 0 }}})));
					v__gen__c__Gen_write(g, _SLIT("},"));
				}
				v__gen__c__Gen_write(g, _SLIT("})"));
			} else {
				v__gen__c__Gen_write(g, _SLIT("NULL"));
			}
			v__gen__c__Gen_write(g, _SLIT(")"));
			v__gen__c__Gen_write(g, _SLIT("},"));
		}
		v__gen__c__Gen_write(g, _SLIT("})"));
	} else {
		v__gen__c__Gen_write(g, _SLIT("NULL"));
	}
	v__gen__c__Gen_writeln(g, _SLIT("));"));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_sql_insert(v__gen__c__Gen* g, v__ast__SqlStmtLine node, string expr, string table_name, string last_ids_arr, string res, string pid, bool is_array, string fkey) {
	Array_v__ast__SqlStmtLine subs = __new_array_with_default(0, 0, sizeof(v__ast__SqlStmtLine), 0);
	Array_v__ast__SqlStmtLine arrs = __new_array_with_default(0, 0, sizeof(v__ast__SqlStmtLine), 0);
	Array_string fkeys = __new_array_with_default(0, 0, sizeof(string), 0);
	Array_string field_names = __new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t1 = 0; _t1 < node.fields.len; ++_t1) {
		v__ast__StructField f = ((v__ast__StructField*)node.fields.data)[_t1];
		v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, f.typ);
		if (sym->kind == v__ast__Kind__struct_ && !string__eq(sym->name, _SLIT("time.Time"))) {
			array_push((array*)&subs, _MOV((v__ast__SqlStmtLine[]){ (*(v__ast__SqlStmtLine*)map_get((map*)&node.sub_structs, &(int[]){((int)(f.typ))}, &(v__ast__SqlStmtLine[]){ (v__ast__SqlStmtLine){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.update_exprs = __new_array(0, 0, sizeof(v__ast__Expr)),.object_var_name = (string){.str=(byteptr)"", .is_lit=1},.updated_columns = __new_array(0, 0, sizeof(string)),.table_expr = (v__ast__TypeNode){.typ = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},},.fields = __new_array(0, 0, sizeof(v__ast__StructField)),.sub_structs = new_map(sizeof(int), sizeof(v__ast__SqlStmtLine), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),} })) }));
		} else if (sym->kind == v__ast__Kind__array) {
			string f_key = _SLIT("");
			for (int _t3 = 0; _t3 < f.attrs.len; ++_t3) {
				v__ast__Attr attr = ((v__ast__Attr*)f.attrs.data)[_t3];
				if (string__eq(attr.name, _SLIT("fkey")) && attr.has_arg && attr.kind == v__ast__AttrKind__string) {
					f_key = attr.arg;
				}
			}
			if ((f_key).len == 0) {
				v__gen__c__verror(_SLIT("An field which holds an array, needs a fkey defined"));
				VUNREACHABLE();
			}
			array_push((array*)&fkeys, _MOV((string[]){ string_clone(f_key) }));
			v__ast__Array info = v__ast__TypeSymbol_array_info(sym);
			if (info.nr_dims == 1) {
				array_push((array*)&arrs, _MOV((v__ast__SqlStmtLine[]){ (*(v__ast__SqlStmtLine*)map_get((map*)&node.sub_structs, &(int[]){((int)(info.elem_type))}, &(v__ast__SqlStmtLine[]){ (v__ast__SqlStmtLine){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.update_exprs = __new_array(0, 0, sizeof(v__ast__Expr)),.object_var_name = (string){.str=(byteptr)"", .is_lit=1},.updated_columns = __new_array(0, 0, sizeof(string)),.table_expr = (v__ast__TypeNode){.typ = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},},.fields = __new_array(0, 0, sizeof(v__ast__StructField)),.sub_structs = new_map(sizeof(int), sizeof(v__ast__SqlStmtLine), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),} })) }));
				array_push((array*)&field_names, _MOV((string[]){ string_clone(f.name) }));
			} else {
				v__gen__c__verror(_SLIT("V ORM only supports 1 dimensional arrays"));
				VUNREACHABLE();
			}
		}
	}
	Array_v__ast__StructField _t7 = __new_array(0, 0, sizeof(v__ast__StructField));
	Array_v__ast__StructField _t7_orig = node.fields;
	int _t7_len = _t7_orig.len;
	_t7 = __new_array(0, _t7_len, sizeof(v__ast__StructField));

	for (int _t8 = 0; _t8 < _t7_len; ++_t8) {
		v__ast__StructField it = ((v__ast__StructField*) _t7_orig.data)[_t8];
		if (v__ast__Table_sym(g->table, it.typ)->kind != v__ast__Kind__array) {
			array_push((array*)&_t7, &it);
		}
	}
	Array_v__ast__StructField fields =_t7;
	for (int _t9 = 0; _t9 < subs.len; ++_t9) {
		v__ast__SqlStmtLine sub = ((v__ast__SqlStmtLine*)subs.data)[_t9];
		v__gen__c__Gen_sql_stmt_line(g, sub, expr);
		v__gen__c__Gen_writeln(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("array_push(&"), 0xfe10, {.d_s = last_ids_arr}}, {_SLIT(", _MOV((orm__Primitive[]){orm__Connection_name_table["), 0xfe10, {.d_s = expr}}, {_SLIT("._typ]._method_last_id("), 0xfe10, {.d_s = expr}}, {_SLIT("._object)}));"), 0, { .d_c = 0 }}})));
	}
	v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("Option_void "), 0xfe10, {.d_s = res}}, {_SLIT(" = orm__Connection_name_table["), 0xfe10, {.d_s = expr}}, {_SLIT("._typ]._method_"), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("insert("), 0xfe10, {.d_s = expr}}, {_SLIT("._object, _SLIT(\""), 0xfe10, {.d_s = table_name}}, {_SLIT("\"), (orm__QueryData){"), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT(".fields = new_array_from_c_array("), 0xfe07, {.d_i32 = fields.len}}, {_SLIT(", "), 0xfe07, {.d_i32 = fields.len}}, {_SLIT(", sizeof(string),"), 0, { .d_c = 0 }}})));
	if (fields.len > 0) {
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("_MOV((string["), 0xfe07, {.d_i32 = fields.len}}, {_SLIT("]){"), 0, { .d_c = 0 }}})));
		for (int _t10 = 0; _t10 < fields.len; ++_t10) {
			v__ast__StructField f = ((v__ast__StructField*)fields.data)[_t10];
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("_SLIT(\""), 0xfe10, {.d_s = v__gen__c__Gen_get_field_name(g, f)}}, {_SLIT("\"),"), 0, { .d_c = 0 }}})));
		}
		v__gen__c__Gen_write(g, _SLIT("})"));
	} else {
		v__gen__c__Gen_write(g, _SLIT("NULL"));
	}
	v__gen__c__Gen_write(g, _SLIT("),"));
	v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT(".data = new_array_from_c_array("), 0xfe07, {.d_i32 = fields.len}}, {_SLIT(", "), 0xfe07, {.d_i32 = fields.len}}, {_SLIT(", sizeof(orm__Primitive),"), 0, { .d_c = 0 }}})));
	if (fields.len > 0) {
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(" _MOV((orm__Primitive["), 0xfe07, {.d_i32 = fields.len}}, {_SLIT("]){"), 0, { .d_c = 0 }}})));
		int structs = 0;
		for (int _t11 = 0; _t11 < fields.len; ++_t11) {
			v__ast__StructField f = ((v__ast__StructField*)fields.data)[_t11];
			if (string__eq(f.name, fkey)) {
				v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = pid}}, {_SLIT(", "), 0, { .d_c = 0 }}})));
				continue;
			}
			v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, f.typ);
			string typ = sym->cname;
			if (sym->kind == v__ast__Kind__struct_ && !string__eq(typ, _SLIT("time__Time"))) {
				v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("(*(orm__Primitive*) array_get("), 0xfe10, {.d_s = last_ids_arr}}, {_SLIT(", "), 0xfe07, {.d_i32 = structs}}, {_SLIT(")),"), 0, { .d_c = 0 }}})));
				structs++;
				continue;
			}
			if (string__eq(typ, _SLIT("time__Time"))) {
				typ = _SLIT("time");
			}
			v__gen__c__Gen_write(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("orm__"), 0xfe10, {.d_s = typ}}, {_SLIT("_to_primitive("), 0xfe10, {.d_s = node.object_var_name}}, {_SLIT("."), 0xfe10, {.d_s = f.name}}, {_SLIT("),"), 0, { .d_c = 0 }}})));
		}
		v__gen__c__Gen_write(g, _SLIT("})"));
	} else {
		v__gen__c__Gen_write(g, _SLIT("NULL"));
	}
	v__gen__c__Gen_write(g, _SLIT("),"));
	v__gen__c__Gen_write(g, _SLIT(".types = new_array_from_c_array(0, 0, sizeof(int), NULL),"));
	v__gen__c__Gen_write(g, _SLIT(".kinds = new_array_from_c_array(0, 0, sizeof(orm__OperationKind), NULL),"));
	v__gen__c__Gen_write(g, _SLIT(".is_and = new_array_from_c_array(0, 0, sizeof(bool), NULL),"));
	v__gen__c__Gen_writeln(g, _SLIT("});"));
	v__gen__c__Gen_writeln(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("if ("), 0xfe10, {.d_s = res}}, {_SLIT(".state != 0 && "), 0xfe10, {.d_s = res}}, {_SLIT(".err._typ != _IError_None___index) { _v_panic(IError_str("), 0xfe10, {.d_s = res}}, {_SLIT(".err)); }"), 0, { .d_c = 0 }}})));
	if (arrs.len > 0) {
		string id_name = v__gen__c__Gen_new_tmp_var(g);
		v__gen__c__Gen_writeln(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("orm__Primitive "), 0xfe10, {.d_s = id_name}}, {_SLIT(" = orm__Connection_name_table["), 0xfe10, {.d_s = expr}}, {_SLIT("._typ]._method_last_id("), 0xfe10, {.d_s = expr}}, {_SLIT("._object);"), 0, { .d_c = 0 }}})));
		for (int i = 0; i < arrs.len; ++i) {
			v__ast__SqlStmtLine* arr = ((v__ast__SqlStmtLine*)arrs.data) + i;
			string idx = v__gen__c__Gen_new_tmp_var(g);
			v__gen__c__Gen_writeln(g,  str_intp(6, _MOV((StrIntpData[]){{_SLIT("for (int "), 0xfe10, {.d_s = idx}}, {_SLIT(" = 0; "), 0xfe10, {.d_s = idx}}, {_SLIT(" < "), 0xfe10, {.d_s = arr->object_var_name}}, {_SLIT("."), 0xfe10, {.d_s = (*(string*)/*ee elem_typ */array_get(field_names, i))}}, {_SLIT(".len; "), 0xfe10, {.d_s = idx}}, {_SLIT("++) {"), 0, { .d_c = 0 }}})));
			string last_ids = v__gen__c__Gen_new_tmp_var(g);
			string res_ = v__gen__c__Gen_new_tmp_var(g);
			string tmp_var = v__gen__c__Gen_new_tmp_var(g);
			string ctyp = v__gen__c__Gen_typ(g, arr->table_expr.typ);
			v__gen__c__Gen_writeln(g,  str_intp(7, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ctyp}}, {_SLIT(" "), 0xfe10, {.d_s = tmp_var}}, {_SLIT(" = (*("), 0xfe10, {.d_s = ctyp}}, {_SLIT("*)array_get("), 0xfe10, {.d_s = arr->object_var_name}}, {_SLIT("."), 0xfe10, {.d_s = (*(string*)/*ee elem_typ */array_get(field_names, i))}}, {_SLIT(", "), 0xfe10, {.d_s = idx}}, {_SLIT("));"), 0, { .d_c = 0 }}})));
			arr->object_var_name = tmp_var;
			Array_v__ast__StructField fff = __new_array_with_default(0, 0, sizeof(v__ast__StructField), 0);
			for (int _t12 = 0; _t12 < arr->fields.len; ++_t12) {
				v__ast__StructField f = ((v__ast__StructField*)arr->fields.data)[_t12];
				bool skip = false;
				bool primary = false;
				for (int _t13 = 0; _t13 < f.attrs.len; ++_t13) {
					v__ast__Attr attr = ((v__ast__Attr*)f.attrs.data)[_t13];
					if (string__eq(attr.name, _SLIT("primary"))) {
						primary = true;
					}
					if (string__eq(attr.name, _SLIT("skip"))) {
						skip = true;
					}
				}
				if (!skip && !primary) {
					array_push((array*)&fff, _MOV((v__ast__StructField[]){ f }));
				}
			}
			arr->fields = array_clone_to_depth(&fff, 0);
			array_free(&fff);
			v__gen__c__Gen_sql_insert(g, *arr, expr, v__gen__c__Gen_get_table_name(g, arr->table_expr), last_ids, res_, id_name, true, (*(string*)/*ee elem_typ */array_get(fkeys, i)));
			v__gen__c__Gen_writeln(g, _SLIT("}"));
		}
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_sql_update(v__gen__c__Gen* g, v__ast__SqlStmtLine node, string expr, string table_name) {
	v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("update("), 0xfe10, {.d_s = expr}}, {_SLIT("._object, _SLIT(\""), 0xfe10, {.d_s = table_name}}, {_SLIT("\"), (orm__QueryData){"), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_write(g, _SLIT(".kinds = new_array_from_c_array(0, 0, sizeof(orm__OperationKind), NULL),"));
	v__gen__c__Gen_write(g, _SLIT(".is_and = new_array_from_c_array(0, 0, sizeof(bool), NULL),"));
	v__gen__c__Gen_write(g, _SLIT(".types = new_array_from_c_array(0, 0, sizeof(int), NULL),"));
	v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT(".fields = new_array_from_c_array("), 0xfe07, {.d_i32 = node.updated_columns.len}}, {_SLIT(", "), 0xfe07, {.d_i32 = node.updated_columns.len}}, {_SLIT(", sizeof(string),"), 0, { .d_c = 0 }}})));
	if (node.updated_columns.len > 0) {
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(" _MOV((string["), 0xfe07, {.d_i32 = node.updated_columns.len}}, {_SLIT("]){"), 0, { .d_c = 0 }}})));
		for (int _t1 = 0; _t1 < node.updated_columns.len; ++_t1) {
			string field = ((string*)node.updated_columns.data)[_t1];
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("_SLIT(\""), 0xfe10, {.d_s = field}}, {_SLIT("\"),"), 0, { .d_c = 0 }}})));
		}
		v__gen__c__Gen_write(g, _SLIT("})"));
	} else {
		v__gen__c__Gen_write(g, _SLIT("NULL"));
	}
	v__gen__c__Gen_write(g, _SLIT("),"));
	v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT(".data = new_array_from_c_array("), 0xfe07, {.d_i32 = node.update_exprs.len}}, {_SLIT(", "), 0xfe07, {.d_i32 = node.update_exprs.len}}, {_SLIT(", sizeof(orm__Primitive),"), 0, { .d_c = 0 }}})));
	if (node.update_exprs.len > 0) {
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(" _MOV((orm__Primitive["), 0xfe07, {.d_i32 = node.update_exprs.len}}, {_SLIT("]){"), 0, { .d_c = 0 }}})));
		for (int _t2 = 0; _t2 < node.update_exprs.len; ++_t2) {
			v__ast__Expr e = ((v__ast__Expr*)node.update_exprs.data)[_t2];
			v__gen__c__Gen_sql_expr_to_orm_primitive(g, e);
		}
		v__gen__c__Gen_write(g, _SLIT("})"));
	}
	v__gen__c__Gen_write(g, _SLIT("),},"));
	v__gen__c__Gen_sql_gen_where_data(g, node.where_expr);
	v__gen__c__Gen_writeln(g, _SLIT(");"));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_sql_delete(v__gen__c__Gen* g, v__ast__SqlStmtLine node, string expr, string table_name) {
	v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("_v_delete("), 0xfe10, {.d_s = expr}}, {_SLIT("._object, _SLIT(\""), 0xfe10, {.d_s = table_name}}, {_SLIT("\"),"), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_sql_gen_where_data(g, node.where_expr);
	v__gen__c__Gen_writeln(g, _SLIT(");"));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_sql_expr_to_orm_primitive(v__gen__c__Gen* g, v__ast__Expr expr) {
	if (expr._typ == 303 /* v.ast.InfixExpr */) {
		v__gen__c__Gen_sql_write_orm_primitive(g, v__ast__Table_find_type_idx(g->table, _SLIT("orm.InfixType")), expr);
	}
	else if (expr._typ == 323 /* v.ast.StringLiteral */) {
		v__gen__c__Gen_sql_write_orm_primitive(g, _const_v__ast__string_type, expr);
	}
	else if (expr._typ == 304 /* v.ast.IntegerLiteral */) {
		v__gen__c__Gen_sql_write_orm_primitive(g, _const_v__ast__int_type, expr);
	}
	else if (expr._typ == 284 /* v.ast.BoolLiteral */) {
		v__gen__c__Gen_sql_write_orm_primitive(g, _const_v__ast__bool_type, expr);
	}
	else if (expr._typ == 299 /* v.ast.Ident */) {
		v__ast__IdentVar info = /* as */ *(v__ast__IdentVar*)__as_cast(((*expr._v__ast__Ident).info)._v__ast__IdentVar,((*expr._v__ast__Ident).info)._typ, 408) /*expected idx: 408, name: v.ast.IdentVar */ ;
		v__gen__c__Gen_sql_write_orm_primitive(g, info.typ, expr);
	}
	else if (expr._typ == 319 /* v.ast.SelectorExpr */) {
		v__gen__c__Gen_sql_write_orm_primitive(g, (*expr._v__ast__SelectorExpr).typ, expr);
	}
	
	else {
		eprintln(v__ast__Expr_str(expr));
		v__gen__c__verror(_SLIT("Unknown expr"));
		VUNREACHABLE();
	}
	;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_sql_write_orm_primitive(v__gen__c__Gen* g, v__ast__Type t, v__ast__Expr expr) {
	v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, t);
	string typ = sym->cname;
	if (string__eq(typ, _SLIT("orm__Primitive"))) {
		v__gen__c__Gen_expr(g, expr);
		v__gen__c__Gen_write(g, _SLIT(","));
		return;
	}
	if (string__eq(typ, _SLIT("time__Time"))) {
		typ = _SLIT("time");
	}
	if (string__eq(typ, _SLIT("orm__InfixType"))) {
		typ = _SLIT("infix");
	}
	v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("orm__"), 0xfe10, {.d_s = typ}}, {_SLIT("_to_primitive("), 0, { .d_c = 0 }}})));
	if ((expr)._typ == 303 /* v.ast.InfixExpr */) {
		v__gen__c__Gen_write(g, _SLIT("(orm__InfixType){"));
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(".name = _SLIT(\""), 0xfe10, {.d_s = v__ast__Expr_str((*expr._v__ast__InfixExpr).left)}}, {_SLIT("\"),"), 0, { .d_c = 0 }}})));
		string kind = (((*expr._v__ast__InfixExpr).op == (v__token__Kind__plus)) ? (_SLIT("orm__MathOperationKind__add")) : ((*expr._v__ast__InfixExpr).op == (v__token__Kind__minus)) ? (_SLIT("orm__MathOperationKind__sub")) : ((*expr._v__ast__InfixExpr).op == (v__token__Kind__div)) ? (_SLIT("orm__MathOperationKind__div")) : ((*expr._v__ast__InfixExpr).op == (v__token__Kind__mul)) ? (_SLIT("orm__MathOperationKind__mul")) : (_SLIT("")));
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(".operator = "), 0xfe10, {.d_s = kind}}, {_SLIT(","), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_write(g, _SLIT(".right = "));
		v__gen__c__Gen_sql_expr_to_orm_primitive(g, (*expr._v__ast__InfixExpr).right);
		v__gen__c__Gen_write(g, _SLIT("}"));
	} else {
		v__gen__c__Gen_expr(g, expr);
	}
	v__gen__c__Gen_write(g, _SLIT("),"));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_sql_where_data(v__gen__c__Gen* g, v__ast__Expr expr, Array_string* fields, Array_string* kinds, Array_v__ast__Expr* data, Array_bool* is_and) {
	if (expr._typ == 303 /* v.ast.InfixExpr */) {
		g->sql_side = v__gen__c__SqlExprSide__left;
		v__gen__c__Gen_sql_where_data(g, (*expr._v__ast__InfixExpr).left, fields, kinds, data, is_and);
		string _t1 = (string){.str=(byteptr)"", .is_lit=1};
		switch ((*expr._v__ast__InfixExpr).op) {
			case v__token__Kind__ne: 
				{
					_t1 = _SLIT("orm__OperationKind__neq");
				} break;
			case v__token__Kind__eq: 
				{
					_t1 = _SLIT("orm__OperationKind__eq");
				} break;
			case v__token__Kind__lt: 
				{
					_t1 = _SLIT("orm__OperationKind__lt");
				} break;
			case v__token__Kind__gt: 
				{
					_t1 = _SLIT("orm__OperationKind__gt");
				} break;
			case v__token__Kind__ge: 
				{
					_t1 = _SLIT("orm__OperationKind__ge");
				} break;
			case v__token__Kind__le: 
				{
					_t1 = _SLIT("orm__OperationKind__le");
				} break;
			case v__token__Kind__unknown:
			case v__token__Kind__eof:
			case v__token__Kind__name:
			case v__token__Kind__number:
			case v__token__Kind__string:
			case v__token__Kind__str_inter:
			case v__token__Kind__chartoken:
			case v__token__Kind__plus:
			case v__token__Kind__minus:
			case v__token__Kind__mul:
			case v__token__Kind__div:
			case v__token__Kind__mod:
			case v__token__Kind__xor:
			case v__token__Kind__pipe:
			case v__token__Kind__inc:
			case v__token__Kind__dec:
			case v__token__Kind__and:
			case v__token__Kind__logical_or:
			case v__token__Kind__not:
			case v__token__Kind__bit_not:
			case v__token__Kind__question:
			case v__token__Kind__comma:
			case v__token__Kind__semicolon:
			case v__token__Kind__colon:
			case v__token__Kind__arrow:
			case v__token__Kind__amp:
			case v__token__Kind__hash:
			case v__token__Kind__dollar:
			case v__token__Kind__at:
			case v__token__Kind__str_dollar:
			case v__token__Kind__left_shift:
			case v__token__Kind__right_shift:
			case v__token__Kind__unsigned_right_shift:
			case v__token__Kind__not_in:
			case v__token__Kind__not_is:
			case v__token__Kind__assign:
			case v__token__Kind__decl_assign:
			case v__token__Kind__plus_assign:
			case v__token__Kind__minus_assign:
			case v__token__Kind__div_assign:
			case v__token__Kind__mult_assign:
			case v__token__Kind__xor_assign:
			case v__token__Kind__mod_assign:
			case v__token__Kind__or_assign:
			case v__token__Kind__and_assign:
			case v__token__Kind__right_shift_assign:
			case v__token__Kind__left_shift_assign:
			case v__token__Kind__unsigned_right_shift_assign:
			case v__token__Kind__lcbr:
			case v__token__Kind__rcbr:
			case v__token__Kind__lpar:
			case v__token__Kind__rpar:
			case v__token__Kind__lsbr:
			case v__token__Kind__nilsbr:
			case v__token__Kind__rsbr:
			case v__token__Kind__comment:
			case v__token__Kind__nl:
			case v__token__Kind__dot:
			case v__token__Kind__dotdot:
			case v__token__Kind__ellipsis:
			case v__token__Kind__keyword_beg:
			case v__token__Kind__key_as:
			case v__token__Kind__key_asm:
			case v__token__Kind__key_assert:
			case v__token__Kind__key_atomic:
			case v__token__Kind__key_break:
			case v__token__Kind__key_const:
			case v__token__Kind__key_continue:
			case v__token__Kind__key_defer:
			case v__token__Kind__key_else:
			case v__token__Kind__key_enum:
			case v__token__Kind__key_false:
			case v__token__Kind__key_for:
			case v__token__Kind__key_fn:
			case v__token__Kind__key_global:
			case v__token__Kind__key_go:
			case v__token__Kind__key_goto:
			case v__token__Kind__key_if:
			case v__token__Kind__key_import:
			case v__token__Kind__key_in:
			case v__token__Kind__key_interface:
			case v__token__Kind__key_is:
			case v__token__Kind__key_match:
			case v__token__Kind__key_module:
			case v__token__Kind__key_mut:
			case v__token__Kind__key_shared:
			case v__token__Kind__key_lock:
			case v__token__Kind__key_rlock:
			case v__token__Kind__key_none:
			case v__token__Kind__key_return:
			case v__token__Kind__key_select:
			case v__token__Kind__key_sizeof:
			case v__token__Kind__key_isreftype:
			case v__token__Kind__key_likely:
			case v__token__Kind__key_unlikely:
			case v__token__Kind__key_offsetof:
			case v__token__Kind__key_struct:
			case v__token__Kind__key_true:
			case v__token__Kind__key_type:
			case v__token__Kind__key_typeof:
			case v__token__Kind__key_dump:
			case v__token__Kind__key_orelse:
			case v__token__Kind__key_union:
			case v__token__Kind__key_pub:
			case v__token__Kind__key_static:
			case v__token__Kind__key_volatile:
			case v__token__Kind__key_unsafe:
			case v__token__Kind__keyword_end:
			case v__token__Kind___end_:
			default:
				{
					_t1 = _SLIT("");
				} break;
		}
		string kind = _t1;
		if ((kind).len == 0) {
			if ((*expr._v__ast__InfixExpr).op == v__token__Kind__logical_or) {
				array_push((array*)is_and, _MOV((bool[]){ false }));
			} else if ((*expr._v__ast__InfixExpr).op == v__token__Kind__and) {
				array_push((array*)is_and, _MOV((bool[]){ true }));
			} else {
				kind = _SLIT("orm__OperationKind__eq");
			}
		}
		if (((*expr._v__ast__InfixExpr).left)._typ != 303 /* v.ast.InfixExpr */ && ((*expr._v__ast__InfixExpr).right)._typ != 303 /* v.ast.InfixExpr */) {
			array_push((array*)kinds, _MOV((string[]){ string_clone(kind) }));
		}
		g->sql_side = v__gen__c__SqlExprSide__right;
		v__gen__c__Gen_sql_where_data(g, (*expr._v__ast__InfixExpr).right, fields, kinds, data, is_and);
	}
	else if (expr._typ == 299 /* v.ast.Ident */) {
		if (g->sql_side == v__gen__c__SqlExprSide__left) {
			array_push((array*)fields, _MOV((string[]){ string_clone(v__gen__c__Gen_get_field_name(g, v__gen__c__Gen_get_struct_field(g, (*expr._v__ast__Ident).name))) }));
		} else {
			array_push((array*)data, _MOV((v__ast__Expr[]){ expr }));
		}
	}
	else if (expr._typ == 323 /* v.ast.StringLiteral */) {
		array_push((array*)data, _MOV((v__ast__Expr[]){ expr }));
	}
	else if (expr._typ == 304 /* v.ast.IntegerLiteral */) {
		array_push((array*)data, _MOV((v__ast__Expr[]){ expr }));
	}
	else if (expr._typ == 319 /* v.ast.SelectorExpr */) {
		array_push((array*)data, _MOV((v__ast__Expr[]){ expr }));
	}
	else if (expr._typ == 284 /* v.ast.BoolLiteral */) {
		array_push((array*)data, _MOV((v__ast__Expr[]){ expr }));
	}
	
	else {
	}
	;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_sql_gen_where_data(v__gen__c__Gen* g, v__ast__Expr where_expr) {
	v__gen__c__Gen_write(g, _SLIT("(orm__QueryData){"));
	Array_string fields = __new_array_with_default(0, 0, sizeof(string), 0);
	Array_string kinds = __new_array_with_default(0, 0, sizeof(string), 0);
	Array_v__ast__Expr data = __new_array_with_default(0, 0, sizeof(v__ast__Expr), 0);
	Array_bool is_and = __new_array_with_default(0, 0, sizeof(bool), 0);
	v__gen__c__Gen_sql_where_data(g, where_expr, &/*arr*/fields, &/*arr*/kinds, &/*arr*/data, &/*arr*/is_and);
	v__gen__c__Gen_write(g, _SLIT(".types = new_array_from_c_array(0, 0, sizeof(int), NULL),"));
	v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT(".fields = new_array_from_c_array("), 0xfe07, {.d_i32 = fields.len}}, {_SLIT(", "), 0xfe07, {.d_i32 = fields.len}}, {_SLIT(", sizeof(string),"), 0, { .d_c = 0 }}})));
	if (fields.len > 0) {
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(" _MOV((string["), 0xfe07, {.d_i32 = fields.len}}, {_SLIT("]){"), 0, { .d_c = 0 }}})));
		for (int _t1 = 0; _t1 < fields.len; ++_t1) {
			string field = ((string*)fields.data)[_t1];
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("_SLIT(\""), 0xfe10, {.d_s = field}}, {_SLIT("\"),"), 0, { .d_c = 0 }}})));
		}
		v__gen__c__Gen_write(g, _SLIT("})"));
	} else {
		v__gen__c__Gen_write(g, _SLIT("NULL"));
	}
	v__gen__c__Gen_write(g, _SLIT("),"));
	v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT(".data = new_array_from_c_array("), 0xfe07, {.d_i32 = data.len}}, {_SLIT(", "), 0xfe07, {.d_i32 = data.len}}, {_SLIT(", sizeof(orm__Primitive),"), 0, { .d_c = 0 }}})));
	if (data.len > 0) {
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(" _MOV((orm__Primitive["), 0xfe07, {.d_i32 = data.len}}, {_SLIT("]){"), 0, { .d_c = 0 }}})));
		for (int _t2 = 0; _t2 < data.len; ++_t2) {
			v__ast__Expr e = ((v__ast__Expr*)data.data)[_t2];
			v__gen__c__Gen_sql_expr_to_orm_primitive(g, e);
		}
		v__gen__c__Gen_write(g, _SLIT("})"));
	}
	v__gen__c__Gen_write(g, _SLIT("),"));
	v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT(".kinds = new_array_from_c_array("), 0xfe07, {.d_i32 = kinds.len}}, {_SLIT(", "), 0xfe07, {.d_i32 = kinds.len}}, {_SLIT(", sizeof(orm__OperationKind),"), 0, { .d_c = 0 }}})));
	if (kinds.len > 0) {
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(" _MOV((orm__OperationKind["), 0xfe07, {.d_i32 = kinds.len}}, {_SLIT("]){"), 0, { .d_c = 0 }}})));
		for (int _t3 = 0; _t3 < kinds.len; ++_t3) {
			string k = ((string*)kinds.data)[_t3];
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = k}}, {_SLIT(","), 0, { .d_c = 0 }}})));
		}
		v__gen__c__Gen_write(g, _SLIT("})"));
	} else {
		v__gen__c__Gen_write(g, _SLIT("NULL"));
	}
	v__gen__c__Gen_write(g, _SLIT("),"));
	v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT(".is_and = new_array_from_c_array("), 0xfe07, {.d_i32 = is_and.len}}, {_SLIT(", "), 0xfe07, {.d_i32 = is_and.len}}, {_SLIT(", sizeof(bool),"), 0, { .d_c = 0 }}})));
	if (is_and.len > 0) {
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(" _MOV((bool["), 0xfe07, {.d_i32 = is_and.len}}, {_SLIT("]){"), 0, { .d_c = 0 }}})));
		for (int _t4 = 0; _t4 < is_and.len; ++_t4) {
			bool b = ((bool*)is_and.data)[_t4];
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = b ? _SLIT("true") : _SLIT("false")}}, {_SLIT(", "), 0, { .d_c = 0 }}})));
		}
		v__gen__c__Gen_write(g, _SLIT("})"));
	} else {
		v__gen__c__Gen_write(g, _SLIT("NULL"));
	}
	v__gen__c__Gen_write(g, _SLIT("),}"));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_sql_select_expr(v__gen__c__Gen* g, v__ast__SqlExpr node) {
	string left = v__gen__c__Gen_go_before_stmt(g, 0);
	string conn = v__gen__c__Gen_new_tmp_var(g);
	v__gen__c__Gen_writeln(g, _SLIT(""));
	v__gen__c__Gen_writeln(g, _SLIT("// orm"));
	v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("orm__Connection "), 0xfe10, {.d_s = conn}}, {_SLIT(" = (orm__Connection){._"), 0, { .d_c = 0 }}})));
	string fn_prefix = _SLIT("");
	v__gen__c__SqlType typ = v__gen__c__Gen_parse_db_type(g, node.db_expr);

	if (typ == (v__gen__c__SqlType__sqlite3)) {
		fn_prefix = _SLIT("sqlite__DB");
	}
	else if (typ == (v__gen__c__SqlType__mysql)) {
		fn_prefix = _SLIT("mysql__Connection");
	}
	else if (typ == (v__gen__c__SqlType__psql)) {
		fn_prefix = _SLIT("pg__DB");
	}
	else {
		v__gen__c__verror( str_intp(2, _MOV((StrIntpData[]){{_SLIT("This database type `"), 0xfe10, {.d_s = v__gen__c__SqlType_str(typ)}}, {_SLIT("` is not implemented yet in orm"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	};
	v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = fn_prefix}}, {_SLIT(" = &"), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_expr(g, node.db_expr);
	v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(", ._typ = _orm__Connection_"), 0xfe10, {.d_s = fn_prefix}}, {_SLIT("_index};"), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_sql_select(g, node, conn, left);
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_sql_select(v__gen__c__Gen* g, v__ast__SqlExpr node, string expr, string left) {
	Array_v__ast__StructField fields = __new_array_with_default(0, 0, sizeof(v__ast__StructField), 0);
	string prim = _SLIT("");
	for (int _t1 = 0; _t1 < node.fields.len; ++_t1) {
		v__ast__StructField f = ((v__ast__StructField*)node.fields.data)[_t1];
		bool skip = false;
		for (int _t2 = 0; _t2 < f.attrs.len; ++_t2) {
			v__ast__Attr attr = ((v__ast__Attr*)f.attrs.data)[_t2];
			if (string__eq(attr.name, _SLIT("primary"))) {
				prim = f.name;
			}
			if (string__eq(attr.name, _SLIT("skip"))) {
				skip = true;
			}
		}
		if (!skip) {
			array_push((array*)&fields, _MOV((v__ast__StructField[]){ f }));
		}
	}
	string res = v__gen__c__Gen_new_tmp_var(g);
	string table_name = v__gen__c__Gen_get_table_name(g, node.table_expr);
	g->sql_table_name = v__ast__Table_sym(g->table, node.table_expr.typ)->name;
	v__gen__c__Gen_write(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("Option_Array_Array_orm__Primitive _o"), 0xfe10, {.d_s = res}}, {_SLIT(" = orm__Connection_name_table["), 0xfe10, {.d_s = expr}}, {_SLIT("._typ]._method_select("), 0xfe10, {.d_s = expr}}, {_SLIT("._object, "), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_write(g, _SLIT("(orm__SelectConfig){"));
	v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(".table = _SLIT(\""), 0xfe10, {.d_s = table_name}}, {_SLIT("\"),"), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(".is_count = "), 0xfe10, {.d_s = node.is_count ? _SLIT("true") : _SLIT("false")}}, {_SLIT(","), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(".has_where = "), 0xfe10, {.d_s = node.has_where ? _SLIT("true") : _SLIT("false")}}, {_SLIT(","), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(".has_order = "), 0xfe10, {.d_s = node.has_order ? _SLIT("true") : _SLIT("false")}}, {_SLIT(","), 0, { .d_c = 0 }}})));
	if (node.has_order) {
		v__gen__c__Gen_write(g, _SLIT(".order = _SLIT(\""));
		v__gen__c__Gen_expr(g, node.order_expr);
		v__gen__c__Gen_write(g, _SLIT("\"),"));
		if (node.has_desc) {
			v__gen__c__Gen_write(g, _SLIT(".order_type = orm__OrderType__desc,"));
		} else {
			v__gen__c__Gen_write(g, _SLIT(".order_type = orm__OrderType__asc,"));
		}
	}
	v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(".has_limit = "), 0xfe10, {.d_s = node.has_limit ? _SLIT("true") : _SLIT("false")}}, {_SLIT(","), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(".has_offset = "), 0xfe10, {.d_s = node.has_offset ? _SLIT("true") : _SLIT("false")}}, {_SLIT(","), 0, { .d_c = 0 }}})));
	if ((prim).len != 0) {
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(".primary = _SLIT(\""), 0xfe10, {.d_s = prim}}, {_SLIT("\"),"), 0, { .d_c = 0 }}})));
	}
	Array_v__ast__StructField _t4 = __new_array(0, 0, sizeof(v__ast__StructField));
	Array_v__ast__StructField _t4_orig = fields;
	int _t4_len = _t4_orig.len;
	_t4 = __new_array(0, _t4_len, sizeof(v__ast__StructField));

	for (int _t5 = 0; _t5 < _t4_len; ++_t5) {
		v__ast__StructField it = ((v__ast__StructField*) _t4_orig.data)[_t5];
		if (v__ast__Table_sym(g->table, it.typ)->kind != v__ast__Kind__array) {
			array_push((array*)&_t4, &it);
		}
	}
	Array_v__ast__StructField select_fields =_t4;
	v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT(".fields = new_array_from_c_array("), 0xfe07, {.d_i32 = select_fields.len}}, {_SLIT(", "), 0xfe07, {.d_i32 = select_fields.len}}, {_SLIT(", sizeof(string),"), 0, { .d_c = 0 }}})));
	Array_int types = __new_array_with_default(0, 0, sizeof(int), 0);
	if (select_fields.len > 0) {
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(" _MOV((string["), 0xfe07, {.d_i32 = select_fields.len}}, {_SLIT("]){"), 0, { .d_c = 0 }}})));
		for (int _t6 = 0; _t6 < select_fields.len; ++_t6) {
			v__ast__StructField field = ((v__ast__StructField*)select_fields.data)[_t6];
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("_SLIT(\""), 0xfe10, {.d_s = v__gen__c__Gen_get_field_name(g, field)}}, {_SLIT("\"),"), 0, { .d_c = 0 }}})));
			v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, field.typ);
			if (string__eq(sym->name, _SLIT("time.Time"))) {
				array_push((array*)&types, _MOV((int[]){ -2 }));
				continue;
			}
			if (sym->kind == v__ast__Kind__struct_) {
				array_push((array*)&types, _MOV((int[]){ ((int)(_const_v__ast__int_type)) }));
				continue;
			}
			array_push((array*)&types, _MOV((int[]){ ((int)(field.typ)) }));
		}
		v__gen__c__Gen_write(g, _SLIT("})"));
	} else {
		v__gen__c__Gen_write(g, _SLIT("NULL"));
	}
	v__gen__c__Gen_write(g, _SLIT("),"));
	v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT(".types = new_array_from_c_array("), 0xfe07, {.d_i32 = types.len}}, {_SLIT(", "), 0xfe07, {.d_i32 = types.len}}, {_SLIT(", sizeof(int),"), 0, { .d_c = 0 }}})));
	if (types.len > 0) {
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(" _MOV((int["), 0xfe07, {.d_i32 = types.len}}, {_SLIT("]){"), 0, { .d_c = 0 }}})));
		for (int _t10 = 0; _t10 < types.len; ++_t10) {
			int typ = ((int*)types.data)[_t10];
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = typ}}, {_SLIT(","), 0, { .d_c = 0 }}})));
		}
		v__gen__c__Gen_write(g, _SLIT("})"));
	} else {
		v__gen__c__Gen_write(g, _SLIT("NULL"));
	}
	v__gen__c__Gen_write(g, _SLIT("),},"));
	Array_v__ast__Expr exprs = __new_array_with_default(0, 0, sizeof(v__ast__Expr), 0);
	if (node.has_limit) {
		array_push((array*)&exprs, _MOV((v__ast__Expr[]){ node.limit_expr }));
	}
	if (node.has_offset) {
		array_push((array*)&exprs, _MOV((v__ast__Expr[]){ node.offset_expr }));
	}
	v__gen__c__Gen_write(g, _SLIT("(orm__QueryData) {"));
	v__gen__c__Gen_write(g, _SLIT(".types = new_array_from_c_array(0, 0, sizeof(int), NULL),"));
	v__gen__c__Gen_write(g, _SLIT(".kinds = new_array_from_c_array(0, 0, sizeof(orm__OperationKind), NULL),"));
	v__gen__c__Gen_write(g, _SLIT(".is_and = new_array_from_c_array(0, 0, sizeof(bool), NULL),"));
	v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT(".data = new_array_from_c_array("), 0xfe07, {.d_i32 = exprs.len}}, {_SLIT(", "), 0xfe07, {.d_i32 = exprs.len}}, {_SLIT(", sizeof(orm__Primitive),"), 0, { .d_c = 0 }}})));
	if (exprs.len > 0) {
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(" _MOV((orm__Primitive["), 0xfe07, {.d_i32 = exprs.len}}, {_SLIT("]){"), 0, { .d_c = 0 }}})));
		for (int _t13 = 0; _t13 < exprs.len; ++_t13) {
			v__ast__Expr e = ((v__ast__Expr*)exprs.data)[_t13];
			v__gen__c__Gen_sql_expr_to_orm_primitive(g, e);
		}
		v__gen__c__Gen_write(g, _SLIT("})"));
	} else {
		v__gen__c__Gen_write(g, _SLIT("NULL"));
	}
	v__gen__c__Gen_write(g, _SLIT(")},"));
	if (node.has_where) {
		v__gen__c__Gen_sql_gen_where_data(g, node.where_expr);
	} else {
		v__gen__c__Gen_write(g, _SLIT("(orm__QueryData) {}"));
	}
	v__gen__c__Gen_writeln(g, _SLIT(");"));
	v__gen__c__Gen_writeln(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("if (_o"), 0xfe10, {.d_s = res}}, {_SLIT(".state != 0 && _o"), 0xfe10, {.d_s = res}}, {_SLIT(".err._typ != _IError_None___index) { _v_panic(IError_str(_o"), 0xfe10, {.d_s = res}}, {_SLIT(".err)); }"), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("Array_Array_orm__Primitive "), 0xfe10, {.d_s = res}}, {_SLIT(" = (*(Array_Array_orm__Primitive*)_o"), 0xfe10, {.d_s = res}}, {_SLIT(".data);"), 0, { .d_c = 0 }}})));
	if (node.is_count) {
		v__gen__c__Gen_writeln(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = left}}, {_SLIT(" *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*)array_get("), 0xfe10, {.d_s = res}}, {_SLIT(", 0)), 0))._int);"), 0, { .d_c = 0 }}})));
	} else {
		string tmp = v__gen__c__Gen_new_tmp_var(g);
		string styp = v__gen__c__Gen_typ(g, node.typ);
		string idx = v__gen__c__Gen_new_tmp_var(g);
		v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("int "), 0xfe10, {.d_s = idx}}, {_SLIT(" = 0;"), 0, { .d_c = 0 }}})));
		string typ_str = _SLIT("");
		if (node.is_array) {
			v__ast__Array info = v__ast__TypeSymbol_array_info(v__ast__Table_sym(g->table, node.typ));
			typ_str = v__gen__c__Gen_typ(g, info.elem_type);
			v__gen__c__Gen_writeln(g,  str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = styp}}, {_SLIT(" "), 0xfe10, {.d_s = tmp}}, {_SLIT("_array = __new_array(0, "), 0xfe10, {.d_s = res}}, {_SLIT(".len, sizeof("), 0xfe10, {.d_s = typ_str}}, {_SLIT("));"), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_writeln(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("for (; "), 0xfe10, {.d_s = idx}}, {_SLIT(" < "), 0xfe10, {.d_s = res}}, {_SLIT(".len; "), 0xfe10, {.d_s = idx}}, {_SLIT("++) {"), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_write(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = typ_str}}, {_SLIT(" "), 0xfe10, {.d_s = tmp}}, {_SLIT(" = ("), 0xfe10, {.d_s = typ_str}}, {_SLIT(") {"), 0, { .d_c = 0 }}})));
			v__ast__Struct inf = v__ast__TypeSymbol_struct_info(v__ast__Table_sym(g->table, info.elem_type));
			for (int i = 0; i < inf.fields.len; ++i) {
				v__ast__StructField field = ((v__ast__StructField*)inf.fields.data)[i];
				v__gen__c__Gen_zero_struct_field(g, field);
				if (i != inf.fields.len - 1) {
					v__gen__c__Gen_write(g, _SLIT(", "));
				}
			}
			v__gen__c__Gen_writeln(g, _SLIT("};"));
		} else {
			v__gen__c__Gen_write(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = styp}}, {_SLIT(" "), 0xfe10, {.d_s = tmp}}, {_SLIT(" = ("), 0xfe10, {.d_s = styp}}, {_SLIT("){"), 0, { .d_c = 0 }}})));
			v__ast__Struct info = v__ast__TypeSymbol_struct_info(v__ast__Table_sym(g->table, node.typ));
			for (int i = 0; i < info.fields.len; ++i) {
				v__ast__StructField field = ((v__ast__StructField*)info.fields.data)[i];
				v__gen__c__Gen_zero_struct_field(g, field);
				if (i != info.fields.len - 1) {
					v__gen__c__Gen_write(g, _SLIT(", "));
				}
			}
			v__gen__c__Gen_writeln(g, _SLIT("};"));
		}
		v__gen__c__Gen_writeln(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("if ("), 0xfe10, {.d_s = res}}, {_SLIT(".len > 0) {"), 0, { .d_c = 0 }}})));
		for (int i = 0; i < fields.len; ++i) {
			v__ast__StructField field = ((v__ast__StructField*)fields.data)[i];
			string sel =  str_intp(4, _MOV((StrIntpData[]){{_SLIT("(*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get("), 0xfe10, {.d_s = res}}, {_SLIT(", "), 0xfe10, {.d_s = idx}}, {_SLIT(")), "), 0xfe07, {.d_i32 = i}}, {_SLIT("))"), 0, { .d_c = 0 }}}));
			v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, field.typ);
			if (sym->kind == v__ast__Kind__struct_ && !string__eq(sym->name, _SLIT("time.Time"))) {
				v__ast__SqlExpr sub = (*(v__ast__SqlExpr*)map_get(ADDR(map, node.sub_structs), &(int[]){((int)(field.typ))}, &(v__ast__SqlExpr[]){ (v__ast__SqlExpr){.typ = 0,.is_count = 0,.has_where = 0,.has_offset = 0,.has_order = 0,.has_desc = 0,.is_array = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.has_limit = 0,.table_expr = (v__ast__TypeNode){.typ = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},},.fields = __new_array(0, 0, sizeof(v__ast__StructField)),.sub_structs = new_map(sizeof(int), sizeof(v__ast__SqlExpr), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),} }));
				v__ast__InfixExpr where_expr = /* as */ *(v__ast__InfixExpr*)__as_cast((sub.where_expr)._v__ast__InfixExpr,(sub.where_expr)._typ, 303) /*expected idx: 303, name: v.ast.InfixExpr */ ;
				v__ast__Ident ident = /* as */ *(v__ast__Ident*)__as_cast((where_expr.right)._v__ast__Ident,(where_expr.right)._typ, 299) /*expected idx: 299, name: v.ast.Ident */ ;
				string name = sel;
				int s = v__ast__Table_find_type_idx(g->table, _SLIT("orm.Primitive"));
				if (s != 0) {
					if ((ident.info)._typ == 408 /* v.ast.IdentVar */) {
						v__ast__IdentVar info = /* as */ *(v__ast__IdentVar*)__as_cast((ident.info)._v__ast__IdentVar,(ident.info)._typ, 408) /*expected idx: 408, name: v.ast.IdentVar */ ;
						info.typ = s;
						ident.info = v__ast__IdentVar_to_sumtype_v__ast__IdentInfo(&info);
					}
				}
				ident.name = name;
				where_expr.right = v__ast__Ident_to_sumtype_v__ast__Expr(&ident);
				sub.where_expr = v__ast__InfixExpr_to_sumtype_v__ast__Expr(&where_expr);
				v__gen__c__Gen_sql_select(g, sub, expr,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = tmp}}, {_SLIT("."), 0xfe10, {.d_s = field.name}}, {_SLIT(" = "), 0, { .d_c = 0 }}})));
			} else if (sym->kind == v__ast__Kind__array) {
				string fkey = _SLIT("");
				for (int _t14 = 0; _t14 < field.attrs.len; ++_t14) {
					v__ast__Attr attr = ((v__ast__Attr*)field.attrs.data)[_t14];
					if (string__eq(attr.name, _SLIT("fkey")) && attr.has_arg && attr.kind == v__ast__AttrKind__string) {
						fkey = attr.arg;
					}
				}
				if ((fkey).len == 0) {
					v__gen__c__verror(_SLIT("An field which holds an array, needs a fkey defined"));
					VUNREACHABLE();
				}
				v__ast__Array info = v__ast__TypeSymbol_array_info(sym);
				v__ast__Type arr_typ = info.elem_type;
				v__ast__SqlExpr sub = (*(v__ast__SqlExpr*)map_get(ADDR(map, node.sub_structs), &(int[]){((int)(arr_typ))}, &(v__ast__SqlExpr[]){ (v__ast__SqlExpr){.typ = 0,.is_count = 0,.has_where = 0,.has_offset = 0,.has_order = 0,.has_desc = 0,.is_array = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.has_limit = 0,.table_expr = (v__ast__TypeNode){.typ = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},},.fields = __new_array(0, 0, sizeof(v__ast__StructField)),.sub_structs = new_map(sizeof(int), sizeof(v__ast__SqlExpr), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),} }));
				v__ast__InfixExpr where_expr = /* as */ *(v__ast__InfixExpr*)__as_cast((sub.where_expr)._v__ast__InfixExpr,(sub.where_expr)._typ, 303) /*expected idx: 303, name: v.ast.InfixExpr */ ;
				v__ast__Ident l = /* as */ *(v__ast__Ident*)__as_cast((where_expr.left)._v__ast__Ident,(where_expr.left)._typ, 299) /*expected idx: 299, name: v.ast.Ident */ ;
				v__ast__Ident r = /* as */ *(v__ast__Ident*)__as_cast((where_expr.right)._v__ast__Ident,(where_expr.right)._typ, 299) /*expected idx: 299, name: v.ast.Ident */ ;
				l.name = fkey;
				r.name = tmp;
				where_expr.left = v__ast__Ident_to_sumtype_v__ast__Expr(&l);
				where_expr.right = v__ast__SelectorExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__SelectorExpr, ((v__ast__SelectorExpr){
					.pos = r.pos,
					.field_name = prim,
					.is_mut = false,
					.mut_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},
					.next_token = 0,
					.expr = v__ast__Ident_to_sumtype_v__ast__Expr(&r),
					.expr_type = (/* as */ *(v__ast__IdentVar*)__as_cast((r.info)._v__ast__IdentVar,(r.info)._typ, 408) /*expected idx: 408, name: v.ast.IdentVar */ ).typ,
					.typ = _const_v__ast__int_type,
					.name_type = 0,
					.gkind_field = 0,
					.scope = 0,
					.from_embed_types = __new_array(0, 0, sizeof(v__ast__Type)),
				})));
				v__ast__SqlExpr arr = (v__ast__SqlExpr){
					.typ = field.typ,
					.is_count = sub.is_count,
					.db_expr = sub.db_expr,
					.has_where = sub.has_where,
					.has_offset = sub.has_offset,
					.offset_expr = sub.offset_expr,
					.has_order = sub.has_order,
					.order_expr = sub.order_expr,
					.has_desc = sub.has_desc,
					.is_array = true,
					.pos = sub.pos,
					.has_limit = sub.has_limit,
					.limit_expr = sub.limit_expr,
					.where_expr = v__ast__InfixExpr_to_sumtype_v__ast__Expr(&where_expr),
					.table_expr = sub.table_expr,
					.fields = sub.fields,
					.sub_structs = new_map(sizeof(int), sizeof(v__ast__SqlExpr), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),
				};
				v__gen__c__Gen_sql_select(g, arr, expr,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = tmp}}, {_SLIT("."), 0xfe10, {.d_s = field.name}}, {_SLIT(" = "), 0, { .d_c = 0 }}})));
			} else {
				string typ = sym->cname;
				v__gen__c__Gen_writeln(g,  str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = tmp}}, {_SLIT("."), 0xfe10, {.d_s = field.name}}, {_SLIT(" = *("), 0xfe10, {.d_s = sel}}, {_SLIT("._"), 0xfe10, {.d_s = typ}}, {_SLIT(");"), 0, { .d_c = 0 }}})));
			}
		}
		v__gen__c__Gen_writeln(g, _SLIT("}"));
		if (node.is_array) {
			v__gen__c__Gen_writeln(g,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("array_push(&"), 0xfe10, {.d_s = tmp}}, {_SLIT("_array, _MOV(("), 0xfe10, {.d_s = typ_str}}, {_SLIT("[]){ "), 0xfe10, {.d_s = tmp}}, {_SLIT(" }));"), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_writeln(g, _SLIT("}"));
		}
		v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = left}}, {_SLIT(" "), 0xfe10, {.d_s = tmp}}, {_SLIT0, 0, { .d_c = 0 }}})));
		if (node.is_array) {
			v__gen__c__Gen_write(g, _SLIT("_array"));
		}
		v__gen__c__Gen_writeln(g, _SLIT(";"));
	}
}

VV_LOCAL_SYMBOL v__gen__c__SqlType v__gen__c__Gen_parse_db_type(v__gen__c__Gen* g, v__ast__Expr expr) {
	if (expr._typ == 299 /* v.ast.Ident */) {
		if (((*expr._v__ast__Ident).info)._typ == 408 /* v.ast.IdentVar */) {
			v__gen__c__SqlType _t1 = v__gen__c__Gen_parse_db_from_type_string(g, v__ast__Table_get_type_name(g->table, (*(*expr._v__ast__Ident).info._v__ast__IdentVar).typ));
			return _t1;
		}
	}
	else if (expr._typ == 319 /* v.ast.SelectorExpr */) {
		v__gen__c__SqlType _t2 = v__gen__c__Gen_parse_db_from_type_string(g, v__ast__Table_get_type_name(g->table, (*expr._v__ast__SelectorExpr).typ));
		return _t2;
	}
	
	else {
		v__gen__c__SqlType _t3 = v__gen__c__SqlType__unknown;
		return _t3;
	}
	;
	v__gen__c__SqlType _t4 = v__gen__c__SqlType__unknown;
	return _t4;
}

VV_LOCAL_SYMBOL v__gen__c__SqlType v__gen__c__Gen_parse_db_from_type_string(v__gen__c__Gen* g, string name) {

	if (string__eq(name, _SLIT("sqlite.DB"))) {
		v__gen__c__SqlType _t1 = v__gen__c__SqlType__sqlite3;
		return _t1;
	}
	else if (string__eq(name, _SLIT("mysql.Connection"))) {
		v__gen__c__SqlType _t2 = v__gen__c__SqlType__mysql;
		return _t2;
	}
	else if (string__eq(name, _SLIT("pg.DB"))) {
		v__gen__c__SqlType _t3 = v__gen__c__SqlType__psql;
		return _t3;
	}
	else if (string__eq(name, _SLIT("mssql.Connection"))) {
		v__gen__c__SqlType _t4 = v__gen__c__SqlType__mssql;
		return _t4;
	}
	else {
		v__gen__c__SqlType _t5 = v__gen__c__SqlType__unknown;
		return _t5;
	};
	return 0;
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_get_table_name(v__gen__c__Gen* g, v__ast__TypeNode table_expr) {
	v__ast__Struct info = v__ast__TypeSymbol_struct_info(v__ast__Table_sym(g->table, table_expr.typ));
	string tablename = v__util__strip_mod_name(v__ast__Table_sym(g->table, table_expr.typ)->name);
	for (int _t1 = 0; _t1 < info.attrs.len; ++_t1) {
		v__ast__Attr attr = ((v__ast__Attr*)info.attrs.data)[_t1];
		if (attr.kind == v__ast__AttrKind__string && string__eq(attr.name, _SLIT("table")) && (attr.arg).len != 0) {
			tablename = attr.arg;
			break;
		}
	}
	string _t2 = tablename;
	return _t2;
}

VV_LOCAL_SYMBOL v__ast__StructField v__gen__c__Gen_get_struct_field(v__gen__c__Gen* g, string name) {
	v__ast__Struct info = v__ast__TypeSymbol_struct_info(v__ast__Table_sym(g->table, (*(int*)map_get(ADDR(map, g->table->type_idxs), &(string[]){g->sql_table_name}, &(int[]){ 0 }))));
	v__ast__StructField f = (v__ast__StructField){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.has_default_expr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_pub = 0,.default_val = (string){.str=(byteptr)"", .is_lit=1},.is_mut = 0,.is_global = 0,.is_volatile = 0,.default_expr = {0},.default_expr_typ = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,};
	for (int _t1 = 0; _t1 < info.fields.len; ++_t1) {
		v__ast__StructField field = ((v__ast__StructField*)info.fields.data)[_t1];
		if (string__eq(field.name, name)) {
			f = field;
		}
	}
	v__ast__StructField _t2 = f;
	return _t2;
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_get_field_name(v__gen__c__Gen* g, v__ast__StructField field) {
	string name = field.name;
	for (int _t1 = 0; _t1 < field.attrs.len; ++_t1) {
		v__ast__Attr attr = ((v__ast__Attr*)field.attrs.data)[_t1];
		if (attr.kind == v__ast__AttrKind__string && string__eq(attr.name, _SLIT("sql")) && (attr.arg).len != 0) {
			name = attr.arg;
			break;
		}
	}
	v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, field.typ);
	if (sym->kind == v__ast__Kind__struct_ && !string__eq(sym->name, _SLIT("time.Time"))) {
		name =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = name}}, {_SLIT("_id"), 0, { .d_c = 0 }}}));
	}
	string _t2 = name;
	return _t2;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_string_literal(v__gen__c__Gen* g, v__ast__StringLiteral node) {
	string escaped_val = v__util__smart_quote(node.val, node.is_raw);
	if (node.language == v__ast__Language__c) {
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\""), 0xfe10, {.d_s = escaped_val}}, {_SLIT("\""), 0, { .d_c = 0 }}})));
	} else {
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("_SLIT(\""), 0xfe10, {.d_s = escaped_val}}, {_SLIT("\")"), 0, { .d_c = 0 }}})));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_string_inter_literal_sb_optimized(v__gen__c__Gen* g, v__ast__CallExpr call_expr) {
	v__ast__StringInterLiteral node = /* as */ *(v__ast__StringInterLiteral*)__as_cast(((*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr.args, 0)).expr)._v__ast__StringInterLiteral,((*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr.args, 0)).expr)._typ, 322) /*expected idx: 322, name: v.ast.StringInterLiteral */ ;
	v__gen__c__Gen_writeln(g, _SLIT("// sb inter opt"));
	bool is_nl = string__eq(call_expr.name, _SLIT("writeln"));
	for (int i = 0; i < node.vals.len; ++i) {
		string val = ((string*)node.vals.data)[i];
		string escaped_val = v__util__smart_quote(val, false);
		v__gen__c__Gen_write(g, _SLIT("strings__Builder_write_string(&"));
		v__gen__c__Gen_expr(g, call_expr.left);
		v__gen__c__Gen_write(g, _SLIT(", _SLIT(\""));
		v__gen__c__Gen_write(g, escaped_val);
		v__gen__c__Gen_writeln(g, _SLIT("\"));"));
		if (i >= node.exprs.len) {
			break;
		}
		if (is_nl && i == node.exprs.len - 1) {
			v__gen__c__Gen_write(g, _SLIT("strings__Builder_writeln(&"));
		} else {
			v__gen__c__Gen_write(g, _SLIT("strings__Builder_write_string(&"));
		}
		v__gen__c__Gen_expr(g, call_expr.left);
		v__gen__c__Gen_write(g, _SLIT(", "));
		v__ast__Type typ = (*(v__ast__Type*)/*ee elem_typ */array_get(node.expr_types, i));
		v__gen__c__Gen_write(g, v__gen__c__Gen_typ(g, typ));
		v__gen__c__Gen_write(g, _SLIT("_str("));
		v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, typ);
		if (sym->kind != v__ast__Kind__function) {
			v__gen__c__Gen_expr(g, (*(v__ast__Expr*)/*ee elem_typ */array_get(node.exprs, i)));
		}
		v__gen__c__Gen_writeln(g, _SLIT("));"));
	}
	v__gen__c__Gen_writeln(g, _SLIT(""));
	return;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_expr_to_string(v__gen__c__Gen* g, v__ast__Expr expr, v__ast__Type etype) {
	bool is_shared = v__ast__Type_has_flag(etype, v__ast__TypeFlag__shared_f);
	v__ast__Type typ = etype;
	if (is_shared) {
		typ = v__ast__Type_set_nr_muls(v__ast__Type_clear_flag(typ, v__ast__TypeFlag__shared_f), 0);
	}
	v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, typ);
	if ((sym->info)._typ == 460 /* v.ast.Alias */) {
		v__ast__TypeSymbol* parent_sym = v__ast__Table_sym(g->table, (*sym->info._v__ast__Alias).parent_type);
		if (v__ast__TypeSymbol_has_method(parent_sym, _SLIT("str"))) {
			typ = (*sym->info._v__ast__Alias).parent_type;
			sym = parent_sym;
		}
	}
	multi_return_bool_bool_int mr_2133 = v__ast__TypeSymbol_str_method_info(sym);
	bool sym_has_str_method = mr_2133.arg0;
	bool str_method_expects_ptr = mr_2133.arg1;
	if (v__ast__Type_has_flag(typ, v__ast__TypeFlag__variadic)) {
		string str_fn_name = v__gen__c__Gen_get_str_fn(g, typ);
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = str_fn_name}}, {_SLIT("("), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_expr(g, expr);
		v__gen__c__Gen_write(g, _SLIT(")"));
	} else if (v__ast__Type_alias_eq(typ, _const_v__ast__string_type)) {
		v__gen__c__Gen_expr(g, expr);
	} else if (v__ast__Type_alias_eq(typ, _const_v__ast__bool_type)) {
		v__gen__c__Gen_expr(g, expr);
		v__gen__c__Gen_write(g, _SLIT(" ? _SLIT(\"true\") : _SLIT(\"false\")"));
	} else if (sym->kind == v__ast__Kind__none_) {
		v__gen__c__Gen_write(g, _SLIT("_SLIT(\"<none>\")"));
	} else if (sym->kind == v__ast__Kind__enum_) {
		if ((expr)._typ != 296 /* v.ast.EnumVal */) {
			string str_fn_name = v__gen__c__Gen_get_str_fn(g, typ);
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = str_fn_name}}, {_SLIT("("), 0, { .d_c = 0 }}})));
			v__gen__c__Gen_enum_expr(g, expr);
			v__gen__c__Gen_write(g, _SLIT(")"));
		} else {
			v__gen__c__Gen_write(g, _SLIT("_SLIT(\""));
			v__gen__c__Gen_enum_expr(g, expr);
			v__gen__c__Gen_write(g, _SLIT("\")"));
		}
	} else if (sym_has_str_method || (sym->kind == v__ast__Kind__array || sym->kind == v__ast__Kind__array_fixed || sym->kind == v__ast__Kind__map || sym->kind == v__ast__Kind__struct_ || sym->kind == v__ast__Kind__multi_return || sym->kind == v__ast__Kind__sum_type || sym->kind == v__ast__Kind__interface_)) {
		bool is_ptr = v__ast__Type_is_ptr(typ);
		bool is_var_mut = v__ast__Expr_is_auto_deref_var(expr);
		string str_fn_name = v__gen__c__Gen_get_str_fn(g, typ);
		if (is_ptr && !is_var_mut) {
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("str_intp(1, _MOV((StrIntpData[]){{_SLIT(\"&\"), "), 0xfe10, {.d_s = _const_v__gen__c__si_s_code}}, {_SLIT(" ,{.d_s="), 0, { .d_c = 0 }}})));
		}
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = str_fn_name}}, {_SLIT("("), 0, { .d_c = 0 }}})));
		if (str_method_expects_ptr && !is_ptr) {
			v__gen__c__Gen_write(g, _SLIT("&"));
		} else if ((!str_method_expects_ptr && is_ptr && !is_shared) || is_var_mut) {
			v__gen__c__Gen_write(g, _SLIT("*"));
		}
		if ((expr)._typ == 280 /* v.ast.ArrayInit */) {
			if ((*expr._v__ast__ArrayInit).is_fixed) {
				string s = v__gen__c__Gen_typ(g, (*expr._v__ast__ArrayInit).typ);
				if (!(*expr._v__ast__ArrayInit).has_it) {
					v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("("), 0xfe10, {.d_s = s}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
				}
			}
		}
		v__gen__c__Gen_expr_with_cast(g, expr, typ, typ);
		if (is_shared) {
			v__gen__c__Gen_write(g, _SLIT("->val"));
		}
		v__gen__c__Gen_write(g, _SLIT(")"));
		if (is_ptr && !is_var_mut) {
			v__gen__c__Gen_write(g, _SLIT("}}}))"));
		}
	} else {
		string str_fn_name = v__gen__c__Gen_get_str_fn(g, typ);
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = str_fn_name}}, {_SLIT("("), 0, { .d_c = 0 }}})));
		if (v__ast__Expr_is_auto_deref_var(expr)) {
			v__gen__c__Gen_write(g, _SLIT("*"));
		}
		if (sym->kind != v__ast__Kind__function) {
			v__gen__c__Gen_expr_with_cast(g, expr, typ, typ);
		}
		v__gen__c__Gen_write(g, _SLIT(")"));
	}
}

VV_LOCAL_SYMBOL multi_return_u64_string v__gen__c__Gen_str_format(v__gen__c__Gen* g, v__ast__StringInterLiteral node, int i) {
	int base = 0;
	bool upper_case = false;
	v__ast__Type typ = v__gen__c__Gen_unwrap_generic(g, (*(v__ast__Type*)/*ee elem_typ */array_get(node.expr_types, i)));
	v__ast__TypeSymbol* sym = v__ast__Table_sym(g->table, typ);
	if (sym->kind == v__ast__Kind__alias) {
		typ = (/* as */ *(v__ast__Alias*)__as_cast((sym->info)._v__ast__Alias,(sym->info)._typ, 460) /*expected idx: 460, name: v.ast.Alias */ ).parent_type;
	}
	bool remove_tail_zeros = false;
	byte fspec = (*(byte*)/*ee elem_typ */array_get(node.fmts, i));
	StrIntpType fmt_type = (StrIntpType){0};
	if ((fspec - 'A') <= ('Z' - 'A')) {
		upper_case = true;
	}
	if (fspec == 's' || fspec == 'S') {
		fmt_type = StrIntpType__si_s;
	} else if (v__ast__Type_is_float(typ)) {
		if (fspec == 'g' || fspec == 'G') {

			if (typ == (_const_v__ast__f32_type)) {
				fmt_type = StrIntpType__si_g32;
			}
			else {
				fmt_type = StrIntpType__si_g64;
			};
			remove_tail_zeros = true;
		} else if (fspec == 'e' || fspec == 'E') {

			if (typ == (_const_v__ast__f32_type)) {
				fmt_type = StrIntpType__si_e32;
			}
			else {
				fmt_type = StrIntpType__si_e64;
			};
		} else if (fspec == 'f' || fspec == 'F') {

			if (typ == (_const_v__ast__f32_type)) {
				fmt_type = StrIntpType__si_f32;
			}
			else {
				fmt_type = StrIntpType__si_f64;
			};
		}
	} else if (v__ast__Type_is_pointer(typ)) {
		if (fspec == 'x' || fspec == 'X') {
			base = 14;
		}
		if (fspec == 'p' || fspec == 'x' || fspec == 'X') {
			fmt_type = StrIntpType__si_p;
		} else {
			fmt_type = StrIntpType__si_vp;
		}
	} else if (v__ast__Type_is_int(typ)) {
		if (fspec == 'x' || fspec == 'X') {
			base = 14;
		}
		if (fspec == 'o') {
			base = 6;
		}
		if (fspec == 'b') {
			base = 1;
		}
		if (fspec == 'c') {
			fmt_type = StrIntpType__si_c;
		} else {

			if (typ == (_const_v__ast__i8_type)) {
				fmt_type = StrIntpType__si_i8;
			}
			else if (typ == (_const_v__ast__byte_type)) {
				fmt_type = StrIntpType__si_u8;
			}
			else if (typ == (_const_v__ast__i16_type)) {
				fmt_type = StrIntpType__si_i16;
			}
			else if (typ == (_const_v__ast__u16_type)) {
				fmt_type = StrIntpType__si_u16;
			}
			else if (typ == (_const_v__ast__i64_type)) {
				fmt_type = StrIntpType__si_i64;
			}
			else if (typ == (_const_v__ast__u64_type)) {
				fmt_type = StrIntpType__si_u64;
			}
			else if (typ == (_const_v__ast__u32_type)) {
				fmt_type = StrIntpType__si_u32;
			}
			else if (typ == (_const_v__ast__usize_type)) {
				fmt_type = StrIntpType__si_u64;
			}
			else if (typ == (_const_v__ast__isize_type)) {
				fmt_type = StrIntpType__si_i64;
			}
			else {
				fmt_type = StrIntpType__si_i32;
			};
		}
	} else {
		fmt_type = StrIntpType__si_p;
	}
	int pad_ch = 0;
	if ((*(bool*)/*ee elem_typ */array_get(node.fills, i))) {
		pad_ch = 1;
	}
	u32 res = get_str_intp_u32_format(fmt_type, (*(int*)/*ee elem_typ */array_get(node.fwidths, i)), (*(int*)/*ee elem_typ */array_get(node.precisions, i)), remove_tail_zeros, (*(bool*)/*ee elem_typ */array_get(node.pluss, i)), ((byte)(pad_ch)), base, upper_case);
	return (multi_return_u64_string){.arg0=res, .arg1=StrIntpType_str(fmt_type)};
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_str_val(v__gen__c__Gen* g, v__ast__StringInterLiteral node, int i) {
	v__ast__Expr expr = (*(v__ast__Expr*)/*ee elem_typ */array_get(node.exprs, i));
	v__ast__Type typ = v__gen__c__Gen_unwrap_generic(g, (*(v__ast__Type*)/*ee elem_typ */array_get(node.expr_types, i)));
	v__ast__TypeSymbol* typ_sym = v__ast__Table_sym(g->table, typ);
	if (v__ast__Type_alias_eq(typ, _const_v__ast__string_type) && g->comptime_for_method.len == 0) {
		if (g->inside_vweb_tmpl) {
			v__gen__c__Gen_write(g, _SLIT("vweb__filter("));
			if (v__ast__Expr_is_auto_deref_var(expr)) {
				v__gen__c__Gen_write(g, _SLIT("*"));
			}
			v__gen__c__Gen_expr(g, expr);
			v__gen__c__Gen_write(g, _SLIT(")"));
		} else {
			if (v__ast__Expr_is_auto_deref_var(expr)) {
				v__gen__c__Gen_write(g, _SLIT("*"));
			}
			v__gen__c__Gen_expr(g, expr);
		}
	} else if (typ_sym->kind == v__ast__Kind__interface_ && v__ast__Interface_defines_method(ADDR(v__ast__Interface, (/* as */ *(v__ast__Interface*)__as_cast((typ_sym->info)._v__ast__Interface,(typ_sym->info)._typ, 463) /*expected idx: 463, name: v.ast.Interface */ )), _SLIT("str"))) {
		string rec_type_name = v__util__no_dots(v__gen__c__Gen_cc_type(g, typ, false));
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__gen__c__c_name(rec_type_name)}}, {_SLIT("_name_table["), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_expr(g, expr);
		string dot = (v__ast__Type_is_ptr(typ) ? (_SLIT("->")) : (_SLIT(".")));
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = dot}}, {_SLIT("_typ]._method_str("), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_expr(g, expr);
		v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = dot}}, {_SLIT("_object"), 0, { .d_c = 0 }}})));
		v__gen__c__Gen_write(g, _SLIT(")"));
	} else if ((*(byte*)/*ee elem_typ */array_get(node.fmts, i)) == 's' || v__ast__Type_has_flag(typ, v__ast__TypeFlag__variadic)) {
		v__ast__Type exp_typ = typ;
		if ((expr)._typ == 299 /* v.ast.Ident */) {
			if (((*expr._v__ast__Ident).obj)._typ == 357 /* v.ast.Var */) {
				if (g->comptime_var_type_map.len > 0 || g->comptime_for_method.len > 0) {
					exp_typ = (*(*expr._v__ast__Ident).obj._v__ast__Var).typ;
				} else if ((*(*expr._v__ast__Ident).obj._v__ast__Var).smartcasts.len > 0) {
					v__ast__TypeSymbol* cast_sym = v__ast__Table_sym(g->table, (*(v__ast__Type*)array_last((*(*expr._v__ast__Ident).obj._v__ast__Var).smartcasts)));
					if ((cast_sym->info)._typ == 458 /* v.ast.Aggregate */) {
						exp_typ = (*(v__ast__Type*)/*ee elem_typ */array_get((*cast_sym->info._v__ast__Aggregate).types, g->aggregate_type_idx));
					}
				}
			}
		}
		v__gen__c__Gen_gen_expr_to_string(g, expr, exp_typ);
	} else if (v__ast__Type_is_number(typ) || v__ast__Type_is_pointer(typ) || (*(byte*)/*ee elem_typ */array_get(node.fmts, i)) == 'd') {
		if (v__ast__Type_is_signed(typ) && ((*(byte*)/*ee elem_typ */array_get(node.fmts, i)) == 'x' || (*(byte*)/*ee elem_typ */array_get(node.fmts, i)) == 'X' || (*(byte*)/*ee elem_typ */array_get(node.fmts, i)) == 'o')) {
			if (v__ast__Type_alias_eq(typ, _const_v__ast__i8_type)) {
				v__gen__c__Gen_write(g, _SLIT("(byte)("));
			} else if (v__ast__Type_alias_eq(typ, _const_v__ast__i16_type)) {
				v__gen__c__Gen_write(g, _SLIT("(u16)("));
			} else if (v__ast__Type_alias_eq(typ, _const_v__ast__int_type)) {
				v__gen__c__Gen_write(g, _SLIT("(u32)("));
			} else {
				v__gen__c__Gen_write(g, _SLIT("(u64)("));
			}
			if (v__ast__Expr_is_auto_deref_var(expr)) {
				v__gen__c__Gen_write(g, _SLIT("*"));
			}
			v__gen__c__Gen_expr(g, expr);
			v__gen__c__Gen_write(g, _SLIT(")"));
		} else {
			if (v__ast__Expr_is_auto_deref_var(expr)) {
				v__gen__c__Gen_write(g, _SLIT("*"));
			}
			v__gen__c__Gen_expr(g, expr);
		}
	} else {
		if (v__ast__Expr_is_auto_deref_var(expr)) {
			v__gen__c__Gen_write(g, _SLIT("*"));
		}
		v__gen__c__Gen_expr(g, expr);
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_string_inter_literal(v__gen__c__Gen* g, v__ast__StringInterLiteral node) {
	v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(" str_intp("), 0xfe07, {.d_i32 = node.vals.len}}, {_SLIT(", "), 0, { .d_c = 0 }}})));
	v__gen__c__Gen_write(g, _SLIT("_MOV((StrIntpData[]){"));
	for (int i = 0; i < node.vals.len; ++i) {
		string val = ((string*)node.vals.data)[i];
		string escaped_val = v__util__smart_quote(val, false);
		if (escaped_val.len > 0) {
			v__gen__c__Gen_write(g,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("{_SLIT(\""), 0xfe10, {.d_s = escaped_val}}, {_SLIT("\"), "), 0, { .d_c = 0 }}})));
		} else {
			v__gen__c__Gen_write(g, _SLIT("{_SLIT0, "));
		}
		if (i >= node.exprs.len) {
			v__gen__c__Gen_write(g, _SLIT("0, { .d_c = 0 }}"));
			break;
		}
		multi_return_u64_string mr_5423 = v__gen__c__Gen_str_format(g, node, i);
		u64 ft_u64 = mr_5423.arg0;
		string ft_str = mr_5423.arg1;
		v__gen__c__Gen_write(g,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("0x"), 0xfe10, {.d_s = u64_hex(ft_u64)}}, {_SLIT(", {.d_"), 0xfe10, {.d_s = ft_str}}, {_SLIT(" = "), 0, { .d_c = 0 }}})));
		if (ft_str.str[0] == 'p') {
			v__gen__c__Gen_write(g, _SLIT("(void*)("));
			v__gen__c__Gen_str_val(g, node, i);
			v__gen__c__Gen_write(g, _SLIT(")"));
		} else {
			v__gen__c__Gen_str_val(g, node, i);
		}
		v__gen__c__Gen_write(g, _SLIT("}}"));
		if (i < (node.vals.len - 1)) {
			v__gen__c__Gen_write(g, _SLIT(", "));
		}
	}
	v__gen__c__Gen_write(g, _SLIT("}))"));
}

VV_LOCAL_SYMBOL v__ast__Type v__gen__c__Gen_unwrap_generic(v__gen__c__Gen* g, v__ast__Type typ) {
	if (v__ast__Type_has_flag(typ, v__ast__TypeFlag__generic)) {
		v__ast__Table* muttable = ((v__ast__Table*)(g->table));
		Option_v__ast__Type _t1;
		if (_t1 = v__ast__Table_resolve_generic_to_concrete(muttable, typ, (g->cur_fn != 0 ? (g->cur_fn->generic_names) : (__new_array_with_default(0, 0, sizeof(string), 0))), g->cur_concrete_types), _t1.state == 0) {
			v__ast__Type t_typ = *(v__ast__Type*)_t1.data;
			v__ast__Type _t2 = t_typ;
			return _t2;
		}
	}
	v__ast__Type _t3 = typ;
	return _t3;
}

VV_LOCAL_SYMBOL v__gen__c__Type v__gen__c__Gen_unwrap(v__gen__c__Gen* g, v__ast__Type typ) {
	v__ast__Type no_generic = v__gen__c__Gen_unwrap_generic(g, typ);
	v__ast__TypeSymbol* no_generic_sym = v__ast__Table_sym(g->table, no_generic);
	if (no_generic_sym->kind != v__ast__Kind__alias) {
		v__gen__c__Type _t1 = (v__gen__c__Type){.typ = no_generic,.sym = no_generic_sym,.unaliased = no_generic,.unaliased_sym = no_generic_sym,};
		return _t1;
	}
	v__gen__c__Type _t2 = (v__gen__c__Type){.typ = no_generic,.sym = no_generic_sym,.unaliased = no_generic_sym->parent_idx,.unaliased_sym = v__ast__Table_sym(g->table, no_generic_sym->parent_idx),};
	return _t2;
}

v__scanner__Scanner* v__scanner__new_scanner_file(string file_path, v__scanner__CommentsMode comments_mode, v__pref__Preferences* pref) {
	if (!os__is_file(file_path)) {
		v__scanner__verror( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = file_path}}, {_SLIT(" is not a file"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	Option_string _t1 = v__util__read_file(file_path);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		v__scanner__verror((*(err.msg)));
		VUNREACHABLE();
		v__scanner__Scanner* _t2 = ((voidptr)(0));
		return _t2;
	}
	
 	string raw_text =  (*(string*)_t1.data);
	v__scanner__Scanner* s = (v__scanner__Scanner*)memdup(&(v__scanner__Scanner){.file_path = file_path,
		.file_base = os__base(file_path),
		.text = raw_text,
		.pos = 0,
		.line_nr = 0,
		.last_nl_pos = -1,
		.is_crlf = 0,
		.is_inside_string = 0,
		.is_inter_start = 0,
		.is_inter_end = 0,
		.is_enclosed_inter = 0,
		.line_comment = (string){.str=(byteptr)"", .is_lit=1},
		.last_lt = -1,
		.is_started = 0,
		.is_print_line_on_error = true,
		.is_print_colored_error = true,
		.is_print_rel_paths_on_error = true,
		.quote = 0,
		.inter_quote = 0,
		.nr_lines = 0,
		.is_vh = 0,
		.is_fmt = pref->is_fmt,
		.comments_mode = comments_mode,
		.is_inside_toplvl_statement = 0,
		.all_tokens = __new_array(0, 0, sizeof(v__token__Token)),
		.tidx = 0,
		.eofs = 0,
		.pref = pref,
		.error_details = __new_array(0, 0, sizeof(string)),
		.errors = __new_array(0, 0, sizeof(v__errors__Error)),
		.warnings = __new_array(0, 0, sizeof(v__errors__Warning)),
		.notices = __new_array(0, 0, sizeof(v__errors__Notice)),
		.vet_errors = __new_array(0, 0, sizeof(v__vet__Error)),
		.should_abort = 0,
	}, sizeof(v__scanner__Scanner));
	v__scanner__Scanner_init_scanner(s);
	v__scanner__Scanner* _t3 = s;
	return _t3;
}

v__scanner__Scanner* v__scanner__new_scanner(string text, v__scanner__CommentsMode comments_mode, v__pref__Preferences* pref) {
	v__scanner__Scanner* s = (v__scanner__Scanner*)memdup(&(v__scanner__Scanner){.file_path = _SLIT("internal_memory"),
		.file_base = _SLIT("internal_memory"),
		.text = text,
		.pos = 0,
		.line_nr = 0,
		.last_nl_pos = -1,
		.is_crlf = 0,
		.is_inside_string = 0,
		.is_inter_start = 0,
		.is_inter_end = 0,
		.is_enclosed_inter = 0,
		.line_comment = (string){.str=(byteptr)"", .is_lit=1},
		.last_lt = -1,
		.is_started = 0,
		.is_print_line_on_error = true,
		.is_print_colored_error = true,
		.is_print_rel_paths_on_error = true,
		.quote = 0,
		.inter_quote = 0,
		.nr_lines = 0,
		.is_vh = 0,
		.is_fmt = pref->is_fmt,
		.comments_mode = comments_mode,
		.is_inside_toplvl_statement = 0,
		.all_tokens = __new_array(0, 0, sizeof(v__token__Token)),
		.tidx = 0,
		.eofs = 0,
		.pref = pref,
		.error_details = __new_array(0, 0, sizeof(string)),
		.errors = __new_array(0, 0, sizeof(v__errors__Error)),
		.warnings = __new_array(0, 0, sizeof(v__errors__Warning)),
		.notices = __new_array(0, 0, sizeof(v__errors__Notice)),
		.vet_errors = __new_array(0, 0, sizeof(v__vet__Error)),
		.should_abort = 0,
	}, sizeof(v__scanner__Scanner));
	v__scanner__Scanner_init_scanner(s);
	v__scanner__Scanner* _t1 = s;
	return _t1;
}

VV_LOCAL_SYMBOL void v__scanner__Scanner_init_scanner(v__scanner__Scanner* s) {
	v__scanner__Scanner_scan_all_tokens_in_buffer(s, s->comments_mode);
}

// Attr: [unsafe]
void v__scanner__Scanner_free(v__scanner__Scanner* s) {
	array_free(&s->all_tokens);
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL bool v__scanner__Scanner_should_parse_comment(v__scanner__Scanner* s) {
	bool _t1 = (s->comments_mode == v__scanner__CommentsMode__parse_comments) || (s->comments_mode == v__scanner__CommentsMode__toplevel_comments && !s->is_inside_toplvl_statement);
	return _t1;
}

void v__scanner__Scanner_set_is_inside_toplevel_statement(v__scanner__Scanner* s, bool newstate) {
	s->is_inside_toplvl_statement = newstate;
}

void v__scanner__Scanner_set_current_tidx(v__scanner__Scanner* s, int cidx) {
	int tidx = (cidx < 0 ? (0) : (cidx));
	tidx = (tidx > s->all_tokens.len ? (s->all_tokens.len) : (tidx));
	s->tidx = tidx;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL v__token__Token v__scanner__Scanner_new_token(v__scanner__Scanner* s, v__token__Kind tok_kind, string lit, int len) {
	int cidx = s->tidx;
	s->tidx++;
	int line_offset = (tok_kind == v__token__Kind__hash ? (0) : (1));
	v__token__Token _t1 = (v__token__Token){
		.kind = tok_kind,
		.lit = lit,
		.line_nr = s->line_nr + line_offset,
		.col = math__mathutil__max_T_int(1, v__scanner__Scanner_current_column(s) - len + 1),
		.pos = s->pos - len + 1,
		.len = len,
		.tidx = cidx,
	};
	return _t1;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL v__token__Token v__scanner__Scanner_new_eof_token(v__scanner__Scanner* s) {
	v__token__Token _t1 = (v__token__Token){
		.kind = v__token__Kind__eof,
		.lit = _SLIT(""),
		.line_nr = s->line_nr + 1,
		.col = v__scanner__Scanner_current_column(s),
		.pos = s->pos,
		.len = 1,
		.tidx = s->tidx,
	};
	return _t1;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL v__token__Token v__scanner__Scanner_new_multiline_token(v__scanner__Scanner* s, v__token__Kind tok_kind, string lit, int len, int start_line) {
	int cidx = s->tidx;
	s->tidx++;
	v__token__Token _t1 = (v__token__Token){
		.kind = tok_kind,
		.lit = lit,
		.line_nr = start_line + 1,
		.col = math__mathutil__max_T_int(1, v__scanner__Scanner_current_column(s) - len + 1),
		.pos = s->pos - len + 1,
		.len = len,
		.tidx = cidx,
	};
	return _t1;
}

// Attr: [direct_array_access]
// Attr: [inline]
inline VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_name(v__scanner__Scanner* s) {
	int start = s->pos;
	s->pos++;
	for (;;) {
		if (!(s->pos < s->text.len)) break;
		byte c = s->text.str[ s->pos];
		if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c == '_') {
			s->pos++;
			continue;
		}
		break;
	}
	string name = string_substr(s->text, start, s->pos);
	s->pos--;
	string _t1 = name;
	return _t1;
}

VV_LOCAL_SYMBOL string v__scanner__Scanner_num_lit(v__scanner__Scanner* s, int start, int end) {
	if (s->is_fmt) {
		string _t1 = string_substr(s->text, start, end);
		return _t1;
	}
	{ // Unsafe block
		byte* txt = s->text.str;
		byte* b = malloc_noscan(end - start + 1);
		int i1 = 0;
		for (int i = start; i < end; i++) {
			if (txt[i] != _const_v__scanner__num_sep) {
				b[i1] = txt[i];
				i1++;
			}
		}
		b[i1] = 0;
		string _t2 = byte_vstring_with_len(b, i1);
		return _t2;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_bin_number(v__scanner__Scanner* s) {
	bool has_wrong_digit = false;
	int first_wrong_digit_pos = 0;
	rune first_wrong_digit = '\0';
	int start_pos = s->pos;
	s->pos += 2;
	if (s->pos < s->text.len && string_at(s->text, s->pos) == _const_v__scanner__num_sep) {
		v__scanner__Scanner_error(s, _SLIT("separator `_` is only valid between digits in a numeric literal"));
	}
	for (;;) {
		if (!(s->pos < s->text.len)) break;
		byte c = string_at(s->text, s->pos);
		if (c == _const_v__scanner__num_sep && string_at(s->text, s->pos - 1) == _const_v__scanner__num_sep) {
			v__scanner__Scanner_error(s, _SLIT("cannot use `_` consecutively"));
		}
		if (!byte_is_bin_digit(c) && c != _const_v__scanner__num_sep) {
			if ((!byte_is_digit(c) && !byte_is_letter(c)) || s->is_inside_string) {
				break;
			} else if (!has_wrong_digit) {
				has_wrong_digit = true;
				first_wrong_digit_pos = s->pos;
				first_wrong_digit = c;
			}
		}
		s->pos++;
	}
	if (string_at(s->text, s->pos - 1) == _const_v__scanner__num_sep) {
		s->pos--;
		v__scanner__Scanner_error(s, _SLIT("cannot use `_` at the end of a numeric literal"));
	} else if (start_pos + 2 == s->pos) {
		s->pos--;
		v__scanner__Scanner_error(s, _SLIT("number part of this binary is not provided"));
	} else if (has_wrong_digit) {
		s->pos = first_wrong_digit_pos;
		v__scanner__Scanner_error(s,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("this binary number has unsuitable digit `"), 0xfe10, {.d_s = rune_str(first_wrong_digit)}}, {_SLIT("`"), 0, { .d_c = 0 }}})));
	}
	string number = v__scanner__Scanner_num_lit(s, start_pos, s->pos);
	s->pos--;
	string _t1 = number;
	return _t1;
}

// Attr: [direct_array_access]
VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_hex_number(v__scanner__Scanner* s) {
	bool has_wrong_digit = false;
	int first_wrong_digit_pos = 0;
	rune first_wrong_digit = '\0';
	int start_pos = s->pos;
	if (s->pos + 2 >= s->text.len) {
		string _t1 = _SLIT("0x");
		return _t1;
	}
	s->pos += 2;
	if (s->pos < s->text.len && s->text.str[ s->pos] == _const_v__scanner__num_sep) {
		v__scanner__Scanner_error(s, _SLIT("separator `_` is only valid between digits in a numeric literal"));
	}
	for (;;) {
		if (!(s->pos < s->text.len)) break;
		byte c = s->text.str[ s->pos];
		if (c == _const_v__scanner__num_sep && s->text.str[ s->pos - 1] == _const_v__scanner__num_sep) {
			v__scanner__Scanner_error(s, _SLIT("cannot use `_` consecutively"));
		}
		if (!byte_is_hex_digit(c) && c != _const_v__scanner__num_sep) {
			if (!byte_is_letter(c) || s->is_inside_string) {
				break;
			} else if (!has_wrong_digit) {
				has_wrong_digit = true;
				first_wrong_digit_pos = s->pos;
				first_wrong_digit = c;
			}
		}
		s->pos++;
	}
	if (s->text.str[ s->pos - 1] == _const_v__scanner__num_sep) {
		s->pos--;
		v__scanner__Scanner_error(s, _SLIT("cannot use `_` at the end of a numeric literal"));
	} else if (start_pos + 2 == s->pos) {
		s->pos--;
		v__scanner__Scanner_error(s, _SLIT("number part of this hexadecimal is not provided"));
	} else if (has_wrong_digit) {
		s->pos = first_wrong_digit_pos;
		v__scanner__Scanner_error(s,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("this hexadecimal number has unsuitable digit `"), 0xfe10, {.d_s = rune_str(first_wrong_digit)}}, {_SLIT("`"), 0, { .d_c = 0 }}})));
	}
	string number = v__scanner__Scanner_num_lit(s, start_pos, s->pos);
	s->pos--;
	string _t2 = number;
	return _t2;
}

VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_oct_number(v__scanner__Scanner* s) {
	bool has_wrong_digit = false;
	int first_wrong_digit_pos = 0;
	rune first_wrong_digit = '\0';
	int start_pos = s->pos;
	s->pos += 2;
	if (s->pos < s->text.len && string_at(s->text, s->pos) == _const_v__scanner__num_sep) {
		v__scanner__Scanner_error(s, _SLIT("separator `_` is only valid between digits in a numeric literal"));
	}
	for (;;) {
		if (!(s->pos < s->text.len)) break;
		byte c = string_at(s->text, s->pos);
		if (c == _const_v__scanner__num_sep && string_at(s->text, s->pos - 1) == _const_v__scanner__num_sep) {
			v__scanner__Scanner_error(s, _SLIT("cannot use `_` consecutively"));
		}
		if (!byte_is_oct_digit(c) && c != _const_v__scanner__num_sep) {
			if ((!byte_is_digit(c) && !byte_is_letter(c)) || s->is_inside_string) {
				break;
			} else if (!has_wrong_digit) {
				has_wrong_digit = true;
				first_wrong_digit_pos = s->pos;
				first_wrong_digit = c;
			}
		}
		s->pos++;
	}
	if (string_at(s->text, s->pos - 1) == _const_v__scanner__num_sep) {
		s->pos--;
		v__scanner__Scanner_error(s, _SLIT("cannot use `_` at the end of a numeric literal"));
	} else if (start_pos + 2 == s->pos) {
		s->pos--;
		v__scanner__Scanner_error(s, _SLIT("number part of this octal is not provided"));
	} else if (has_wrong_digit) {
		s->pos = first_wrong_digit_pos;
		v__scanner__Scanner_error(s,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("this octal number has unsuitable digit `"), 0xfe10, {.d_s = rune_str(first_wrong_digit)}}, {_SLIT("`"), 0, { .d_c = 0 }}})));
	}
	string number = v__scanner__Scanner_num_lit(s, start_pos, s->pos);
	s->pos--;
	string _t1 = number;
	return _t1;
}

// Attr: [direct_array_access]
VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_dec_number(v__scanner__Scanner* s) {
	bool has_wrong_digit = false;
	int first_wrong_digit_pos = 0;
	rune first_wrong_digit = '\0';
	int start_pos = s->pos;
	for (;;) {
		if (!(s->pos < s->text.len)) break;
		byte c = s->text.str[ s->pos];
		if (c == _const_v__scanner__num_sep && s->text.str[ s->pos - 1] == _const_v__scanner__num_sep) {
			v__scanner__Scanner_error(s, _SLIT("cannot use `_` consecutively"));
		}
		if (!byte_is_digit(c) && c != _const_v__scanner__num_sep) {
			if (!byte_is_letter(c) || (c == 'e' || c == 'E') || s->is_inside_string) {
				break;
			} else if (!has_wrong_digit) {
				has_wrong_digit = true;
				first_wrong_digit_pos = s->pos;
				first_wrong_digit = c;
			}
		}
		s->pos++;
	}
	if (s->text.str[ s->pos - 1] == _const_v__scanner__num_sep) {
		s->pos--;
		v__scanner__Scanner_error(s, _SLIT("cannot use `_` at the end of a numeric literal"));
	}
	bool call_method = false;
	bool is_range = false;
	if (s->pos < s->text.len && s->text.str[ s->pos] == '.') {
		s->pos++;
		if (s->pos < s->text.len) {
			if (byte_is_digit(s->text.str[ s->pos])) {
				for (;;) {
					if (!(s->pos < s->text.len)) break;
					byte c = s->text.str[ s->pos];
					if (!byte_is_digit(c)) {
						if (!byte_is_letter(c) || (c == 'e' || c == 'E') || s->is_inside_string) {
							if (c == '.' && s->pos + 1 < s->text.len && byte_is_letter(s->text.str[ s->pos + 1])) {
								call_method = true;
							}
							break;
						} else if (!has_wrong_digit) {
							has_wrong_digit = true;
							first_wrong_digit_pos = s->pos;
							first_wrong_digit = c;
						}
					}
					s->pos++;
				}
			} else if (s->text.str[ s->pos] == '.') {
				is_range = true;
				s->pos--;
			} else if (s->text.str[ s->pos] == 'e' || s->text.str[ s->pos] == 'E') {
			} else if (byte_is_letter(s->text.str[ s->pos])) {
				call_method = true;
				s->pos--;
			} else {
				int symbol_length = 0;
				for (int i = s->pos - 2; i > 0 && byte_is_digit(s->text.str[ i - 1]); i--) {
					symbol_length++;
				}
				string float_symbol = string_substr(s->text, s->pos - 2 - symbol_length, s->pos - 1);
				v__scanner__Scanner_warn(s,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("float literals should have a digit after the decimal point, e.g. `"), 0xfe10, {.d_s = float_symbol}}, {_SLIT(".0`"), 0, { .d_c = 0 }}})));
			}
		}
	}
	bool has_exp = false;
	if (s->pos < s->text.len && (s->text.str[ s->pos] == 'e' || s->text.str[ s->pos] == 'E')) {
		has_exp = true;
		s->pos++;
		if (s->pos < s->text.len && (s->text.str[ s->pos] == '-' || s->text.str[ s->pos] == '+')) {
			s->pos++;
		}
		for (;;) {
			if (!(s->pos < s->text.len)) break;
			byte c = s->text.str[ s->pos];
			if (!byte_is_digit(c)) {
				if (!byte_is_letter(c) || s->is_inside_string) {
					if (c == '.' && s->pos + 1 < s->text.len && byte_is_letter(s->text.str[ s->pos + 1])) {
						call_method = true;
					}
					break;
				} else if (!has_wrong_digit) {
					has_wrong_digit = true;
					first_wrong_digit_pos = s->pos;
					first_wrong_digit = c;
				}
			}
			s->pos++;
		}
	}
	if (has_wrong_digit) {
		s->pos = first_wrong_digit_pos;
		if (!s->pref->translated) {
			v__scanner__Scanner_error(s,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("this number has unsuitable digit `"), 0xfe10, {.d_s = rune_str(first_wrong_digit)}}, {_SLIT("`"), 0, { .d_c = 0 }}})));
		}
	} else if (s->text.str[ s->pos - 1] == 'e' || s->text.str[ s->pos - 1] == 'E') {
		s->pos--;
		v__scanner__Scanner_error(s, _SLIT("exponent has no digits"));
	} else if (s->pos < s->text.len && s->text.str[ s->pos] == '.' && !is_range && !call_method) {
		if (has_exp) {
			v__scanner__Scanner_error(s, _SLIT("exponential part should be integer"));
		} else {
			v__scanner__Scanner_error(s, _SLIT("too many decimal points in number"));
		}
	}
	string number = v__scanner__Scanner_num_lit(s, start_pos, s->pos);
	s->pos--;
	string _t1 = number;
	return _t1;
}

VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_number(v__scanner__Scanner* s) {
	if (v__scanner__Scanner_expect(s, _SLIT("0b"), s->pos)) {
		string _t1 = v__scanner__Scanner_ident_bin_number(s);
		return _t1;
	} else if (v__scanner__Scanner_expect(s, _SLIT("0x"), s->pos)) {
		string _t2 = v__scanner__Scanner_ident_hex_number(s);
		return _t2;
	} else if (v__scanner__Scanner_expect(s, _SLIT("0o"), s->pos)) {
		string _t3 = v__scanner__Scanner_ident_oct_number(s);
		return _t3;
	} else {
		string _t4 = v__scanner__Scanner_ident_dec_number(s);
		return _t4;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [direct_array_access]
// Attr: [inline]
inline VV_LOCAL_SYMBOL void v__scanner__Scanner_skip_whitespace(v__scanner__Scanner* s) {
	for (;;) {
		if (!(s->pos < s->text.len)) break;
		byte c = s->text.str[ s->pos];
		if (c == 8) {
			s->pos++;
			continue;
		}
		if (!(c == 32 || (c > 8 && c < 14) || (c == 0x85) || (c == 0xa0))) {
			return;
		}
		bool c_is_nl = c == _const_v__scanner__b_cr || c == _const_v__scanner__b_lf;
		if (c_is_nl && s->is_vh) {
			return;
		}
		if (s->pos + 1 < s->text.len && c == _const_v__scanner__b_cr && s->text.str[ s->pos + 1] == _const_v__scanner__b_lf) {
			s->is_crlf = true;
		}
		if (c_is_nl && !(s->pos > 0 && s->text.str[ s->pos - 1] == _const_v__scanner__b_cr && c == _const_v__scanner__b_lf)) {
			v__scanner__Scanner_inc_line_number(s);
		}
		s->pos++;
	}
}

VV_LOCAL_SYMBOL v__token__Token v__scanner__Scanner_end_of_file(v__scanner__Scanner* s) {
	s->eofs++;
	if (s->eofs > 50) {
		s->line_nr--;
		_v_panic(string__plus(string__plus( str_intp(2, _MOV((StrIntpData[]){{_SLIT("the end of file `"), 0xfe10, {.d_s = s->file_path}}, {_SLIT("` has been reached 50 times already, the v parser is probably stuck.\n"), 0, { .d_c = 0 }}})), _SLIT("This should not happen. Please report the bug here, and include the last 2-3 lines of your source code:\n")), _SLIT("https://github.com/vlang/v/issues/new?labels=Bug&template=bug_report.md")));
		VUNREACHABLE();
	}
	if (s->pos != s->text.len && s->eofs == 1) {
		v__scanner__Scanner_inc_line_number(s);
	}
	s->pos = s->text.len;
	v__token__Token _t1 = v__scanner__Scanner_new_eof_token(s);
	return _t1;
}

void v__scanner__Scanner_scan_all_tokens_in_buffer(v__scanner__Scanner* s, v__scanner__CommentsMode mode) {
bool v__scanner__Scanner_scan_all_tokens_in_buffer_defer_0 = false;
v__util__Timers* timers;
	timers = v__util__get_timers();
	v__util__Timers_measure_pause(timers, _SLIT("PARSE"));
	v__util__timing_start(_SLIT("SCAN"));
	v__scanner__Scanner_scan_all_tokens_in_buffer_defer_0 = true;
	v__scanner__CommentsMode oldmode = s->comments_mode;
	s->comments_mode = mode;
	s->all_tokens = __new_array_with_default(0, s->text.len / 3, sizeof(v__token__Token), 0);
	v__scanner__Scanner_scan_remaining_text(s);
	s->comments_mode = oldmode;
	s->tidx = 0;
// Defer begin
if (v__scanner__Scanner_scan_all_tokens_in_buffer_defer_0) {
	v__util__timing_measure_cumulative(_SLIT("SCAN"));
	v__util__Timers_measure_resume(timers, _SLIT("PARSE"));
}
// Defer end
}

void v__scanner__Scanner_scan_remaining_text(v__scanner__Scanner* s) {
	for (;;) {
		v__token__Token t = v__scanner__Scanner_text_scan(s);
		if (s->comments_mode == v__scanner__CommentsMode__skip_comments && t.kind == v__token__Kind__comment) {
			continue;
		}
		array_push((array*)&s->all_tokens, _MOV((v__token__Token[]){ t }));
		if (t.kind == v__token__Kind__eof || s->should_abort) {
			break;
		}
	}
}

v__token__Token v__scanner__Scanner_scan(v__scanner__Scanner* s) {
	v__token__Token _t1 = v__scanner__Scanner_buffer_scan(s);
	return _t1;
}

// Attr: [direct_array_access]
v__token__Token v__scanner__Scanner_buffer_scan(v__scanner__Scanner* s) {
	for (;;) {
		int cidx = s->tidx;
		s->tidx++;
		if (cidx >= s->all_tokens.len || s->should_abort) {
			v__token__Token _t1 = v__scanner__Scanner_end_of_file(s);
			return _t1;
		}
		if (((v__token__Token*)s->all_tokens.data)[cidx].kind == v__token__Kind__comment) {
			if (!v__scanner__Scanner_should_parse_comment(s)) {
				continue;
			}
		}
		v__token__Token _t2 = ((v__token__Token*)s->all_tokens.data)[cidx];
		return _t2;
	}
	v__token__Token _t3 = v__scanner__Scanner_new_eof_token(s);
	return _t3;
}

// Attr: [direct_array_access]
// Attr: [inline]
inline v__token__Token v__scanner__Scanner_peek_token(v__scanner__Scanner* s, int n) {
	int idx = s->tidx + n;
	if (idx >= s->all_tokens.len) {
		v__token__Token _t1 = v__scanner__Scanner_new_eof_token(s);
		return _t1;
	}
	v__token__Token t = ((v__token__Token*)s->all_tokens.data)[idx];
	v__token__Token _t2 = t;
	return _t2;
}

// Attr: [direct_array_access]
// Attr: [inline]
inline VV_LOCAL_SYMBOL byte v__scanner__Scanner_look_ahead(v__scanner__Scanner* s, int n) {
	if (s->pos + n < s->text.len) {
		byte _t1 = s->text.str[ s->pos + n];
		return _t1;
	} else {
		byte _t2 = '\0';
		return _t2;
	}
	return 0;
}

// Attr: [direct_array_access]
VV_LOCAL_SYMBOL v__token__Token v__scanner__Scanner_text_scan(v__scanner__Scanner* s) {
	for (;;) {
		if (s->is_started) {
			s->pos++;
		} else {
			s->is_started = true;
		}
		if (!s->is_inside_string) {
			v__scanner__Scanner_skip_whitespace(s);
		}
		if (s->pos >= s->text.len || s->should_abort) {
			v__token__Token _t1 = v__scanner__Scanner_end_of_file(s);
			return _t1;
		}
		if (s->is_inter_end) {
			if (s->text.str[ s->pos] == s->quote) {
				s->is_inter_end = false;
				v__token__Token _t2 = v__scanner__Scanner_new_token(s, v__token__Kind__string, _SLIT(""), 1);
				return _t2;
			}
			s->is_inter_end = false;
			string ident_string = v__scanner__Scanner_ident_string(s);
			v__token__Token _t3 = v__scanner__Scanner_new_token(s, v__token__Kind__string, ident_string, ident_string.len + 2);
			return _t3;
		}
		v__scanner__Scanner_skip_whitespace(s);
		if (s->pos >= s->text.len) {
			v__token__Token _t4 = v__scanner__Scanner_end_of_file(s);
			return _t4;
		}
		byte c = s->text.str[ s->pos];
		byte nextc = v__scanner__Scanner_look_ahead(s, 1);
		if (v__util__is_name_char(c)) {
			string name = v__scanner__Scanner_ident_name(s);
			byte next_char = v__scanner__Scanner_look_ahead(s, 1);
			int kind = v__token__KeywordsMatcher_find(&_const_v__token__matcher, name);
			if (kind != -1) {
				v__token__Token _t5 = v__scanner__Scanner_new_token(s, ((v__token__Kind)(kind)), name, name.len);
				return _t5;
			}
			if (s->is_inside_string) {
				if (next_char == s->quote) {
					s->is_inter_end = true;
					s->is_inter_start = false;
					s->is_inside_string = false;
				}
			}
			if (s->is_inter_start && next_char == '\\' && !(v__scanner__Scanner_look_ahead(s, 2) == 'x' || v__scanner__Scanner_look_ahead(s, 2) == 'n' || v__scanner__Scanner_look_ahead(s, 2) == 'r' || v__scanner__Scanner_look_ahead(s, 2) == '\\' || v__scanner__Scanner_look_ahead(s, 2) == 't' || v__scanner__Scanner_look_ahead(s, 2) == 'e' || v__scanner__Scanner_look_ahead(s, 2) == '"' || v__scanner__Scanner_look_ahead(s, 2) == '\'')) {
				v__scanner__Scanner_warn(s,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unknown escape sequence \\"), 0xfe02, {.d_u8 = v__scanner__Scanner_look_ahead(s, 2)}}, {_SLIT0, 0, { .d_c = 0 }}})));
			}
			if (s->is_inter_start && next_char == '(') {
				if (v__scanner__Scanner_look_ahead(s, 2) != ')') {
					v__scanner__Scanner_warn(s, _SLIT("use `${f(expr)}` instead of `$f(expr)`"));
				}
			} else if (s->is_inter_start && next_char != '.') {
				s->is_inter_end = true;
				s->is_inter_start = false;
			}
			v__token__Token _t6 = v__scanner__Scanner_new_token(s, v__token__Kind__name, name, name.len);
			return _t6;
		} else if (byte_is_digit(c) || (c == '.' && byte_is_digit(nextc))) {
			if (!s->is_inside_string) {
				int start_pos = s->pos;
				for (;;) {
					if (!(start_pos < s->text.len && s->text.str[ start_pos] == '0')) break;
					start_pos++;
				}
				int prefix_zero_num = start_pos - s->pos;
				if (start_pos == s->text.len || (c == '0' && !byte_is_digit(s->text.str[ start_pos]))) {
					prefix_zero_num--;
				}
				s->pos += prefix_zero_num;
			}
			string num = v__scanner__Scanner_ident_number(s);
			v__token__Token _t7 = v__scanner__Scanner_new_token(s, v__token__Kind__number, num, num.len);
			return _t7;
		}
		if (c == ')' && s->is_inter_start) {
			byte next_char = v__scanner__Scanner_look_ahead(s, 1);
			if (next_char != '.') {
				s->is_inter_end = true;
				s->is_inter_start = false;
				if (next_char == s->quote) {
					s->is_inside_string = false;
				}
				v__token__Token _t8 = v__scanner__Scanner_new_token(s, v__token__Kind__rpar, _SLIT(""), 1);
				return _t8;
			}
		}

		if (c == ('+')) {
			if (nextc == '+') {
				s->pos++;
				v__token__Token _t9 = v__scanner__Scanner_new_token(s, v__token__Kind__inc, _SLIT(""), 2);
				return _t9;
			} else if (nextc == '=') {
				s->pos++;
				v__token__Token _t10 = v__scanner__Scanner_new_token(s, v__token__Kind__plus_assign, _SLIT(""), 2);
				return _t10;
			}
			v__token__Token _t11 = v__scanner__Scanner_new_token(s, v__token__Kind__plus, _SLIT(""), 1);
			return _t11;
		}
		else if (c == ('-')) {
			if (nextc == '-') {
				s->pos++;
				v__token__Token _t12 = v__scanner__Scanner_new_token(s, v__token__Kind__dec, _SLIT(""), 2);
				return _t12;
			} else if (nextc == '=') {
				s->pos++;
				v__token__Token _t13 = v__scanner__Scanner_new_token(s, v__token__Kind__minus_assign, _SLIT(""), 2);
				return _t13;
			}
			v__token__Token _t14 = v__scanner__Scanner_new_token(s, v__token__Kind__minus, _SLIT(""), 1);
			return _t14;
		}
		else if (c == ('*')) {
			if (nextc == '=') {
				s->pos++;
				v__token__Token _t15 = v__scanner__Scanner_new_token(s, v__token__Kind__mult_assign, _SLIT(""), 2);
				return _t15;
			}
			v__token__Token _t16 = v__scanner__Scanner_new_token(s, v__token__Kind__mul, _SLIT(""), 1);
			return _t16;
		}
		else if (c == ('^')) {
			if (nextc == '=') {
				s->pos++;
				v__token__Token _t17 = v__scanner__Scanner_new_token(s, v__token__Kind__xor_assign, _SLIT(""), 2);
				return _t17;
			}
			v__token__Token _t18 = v__scanner__Scanner_new_token(s, v__token__Kind__xor, _SLIT(""), 1);
			return _t18;
		}
		else if (c == ('%')) {
			if (nextc == '=') {
				s->pos++;
				v__token__Token _t19 = v__scanner__Scanner_new_token(s, v__token__Kind__mod_assign, _SLIT(""), 2);
				return _t19;
			}
			v__token__Token _t20 = v__scanner__Scanner_new_token(s, v__token__Kind__mod, _SLIT(""), 1);
			return _t20;
		}
		else if (c == ('?')) {
			v__token__Token _t21 = v__scanner__Scanner_new_token(s, v__token__Kind__question, _SLIT("?"), 1);
			return _t21;
		}
		else if (c == (_const_v__scanner__single_quote) || c == (_const_v__scanner__double_quote)) {
			int start_line = s->line_nr;
			string ident_string = v__scanner__Scanner_ident_string(s);
			v__token__Token _t22 = v__scanner__Scanner_new_multiline_token(s, v__token__Kind__string, ident_string, ident_string.len + 2, start_line);
			return _t22;
		}
		else if (c == ('`')) {
			string ident_char = v__scanner__Scanner_ident_char(s);
			v__token__Token _t23 = v__scanner__Scanner_new_token(s, v__token__Kind__chartoken, ident_char, ident_char.len + 2);
			return _t23;
		}
		else if (c == ('(')) {
			if (s->pref->is_vet && s->text.str[ s->pos + 1] == ' ') {
				v__scanner__Scanner_vet_error(s, _SLIT("Looks like you are adding a space after `(`"), v__vet__FixKind__vfmt);
			}
			v__token__Token _t24 = v__scanner__Scanner_new_token(s, v__token__Kind__lpar, _SLIT(""), 1);
			return _t24;
		}
		else if (c == (')')) {
			if (s->pref->is_vet && s->text.str[ s->pos - 1] == ' ') {
				v__scanner__Scanner_vet_error(s, _SLIT("Looks like you are adding a space before `)`"), v__vet__FixKind__vfmt);
			}
			v__token__Token _t25 = v__scanner__Scanner_new_token(s, v__token__Kind__rpar, _SLIT(""), 1);
			return _t25;
		}
		else if (c == ('[')) {
			v__token__Token _t26 = v__scanner__Scanner_new_token(s, v__token__Kind__lsbr, _SLIT(""), 1);
			return _t26;
		}
		else if (c == (']')) {
			v__token__Token _t27 = v__scanner__Scanner_new_token(s, v__token__Kind__rsbr, _SLIT(""), 1);
			return _t27;
		}
		else if (c == ('{')) {
			if (s->is_inside_string) {
				continue;
			}
			v__token__Token _t28 = v__scanner__Scanner_new_token(s, v__token__Kind__lcbr, _SLIT(""), 1);
			return _t28;
		}
		else if (c == ('$')) {
			if (s->is_inside_string) {
				v__token__Token _t29 = v__scanner__Scanner_new_token(s, v__token__Kind__str_dollar, _SLIT(""), 1);
				return _t29;
			} else {
				v__token__Token _t30 = v__scanner__Scanner_new_token(s, v__token__Kind__dollar, _SLIT(""), 1);
				return _t30;
			}
		}
		else if (c == ('}')) {
			if (s->is_enclosed_inter) {
				if (s->pos < s->text.len - 1) {
					s->pos++;
				} else {
					v__scanner__Scanner_error(s, _SLIT("unfinished string literal"));
				}
				if (s->text.str[ s->pos] == s->quote) {
					s->is_inside_string = false;
					s->is_enclosed_inter = false;
					v__token__Token _t31 = v__scanner__Scanner_new_token(s, v__token__Kind__string, _SLIT(""), 1);
					return _t31;
				}
				s->is_enclosed_inter = false;
				string ident_string = v__scanner__Scanner_ident_string(s);
				v__token__Token _t32 = v__scanner__Scanner_new_token(s, v__token__Kind__string, ident_string, ident_string.len + 2);
				return _t32;
			} else {
				v__token__Token _t33 = v__scanner__Scanner_new_token(s, v__token__Kind__rcbr, _SLIT(""), 1);
				return _t33;
			}
		}
		else if (c == ('&')) {
			if (nextc == '=') {
				s->pos++;
				v__token__Token _t34 = v__scanner__Scanner_new_token(s, v__token__Kind__and_assign, _SLIT(""), 2);
				return _t34;
			}
			byte afternextc = v__scanner__Scanner_look_ahead(s, 2);
			if (nextc == '&' && byte_is_space(afternextc)) {
				s->pos++;
				v__token__Token _t35 = v__scanner__Scanner_new_token(s, v__token__Kind__and, _SLIT(""), 2);
				return _t35;
			}
			v__token__Token _t36 = v__scanner__Scanner_new_token(s, v__token__Kind__amp, _SLIT(""), 1);
			return _t36;
		}
		else if (c == ('|')) {
			if (nextc == '|') {
				s->pos++;
				v__token__Token _t37 = v__scanner__Scanner_new_token(s, v__token__Kind__logical_or, _SLIT(""), 2);
				return _t37;
			}
			if (nextc == '=') {
				s->pos++;
				v__token__Token _t38 = v__scanner__Scanner_new_token(s, v__token__Kind__or_assign, _SLIT(""), 2);
				return _t38;
			}
			v__token__Token _t39 = v__scanner__Scanner_new_token(s, v__token__Kind__pipe, _SLIT(""), 1);
			return _t39;
		}
		else if (c == (',')) {
			v__token__Token _t40 = v__scanner__Scanner_new_token(s, v__token__Kind__comma, _SLIT(""), 1);
			return _t40;
		}
		else if (c == ('@')) {
			string name = _SLIT("");
			if (nextc != '\0') {
				s->pos++;
				name = v__scanner__Scanner_ident_name(s);
			}
			if (s->is_fmt) {
				v__token__Token _t41 = v__scanner__Scanner_new_token(s, v__token__Kind__name, string__plus(_SLIT("@"), name), name.len + 1);
				return _t41;
			}
			if (Array_string_contains(_const_v__token__valid_at_tokens, string__plus(_SLIT("@"), name)) || string_starts_with(name, _SLIT("cc"))) {
				v__token__Token _t42 = v__scanner__Scanner_new_token(s, v__token__Kind__at, string__plus(_SLIT("@"), name), name.len + 1);
				return _t42;
			}
			if (!v__token__is_key(name)) {
				string at_error_msg = _SLIT("@ must be used before keywords or compile time variables (e.g. `@type string` or `@FN`)");
				if (string_is_upper(name)) {
					at_error_msg = /*f*/string__plus(at_error_msg,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\nAvailable compile time variables:\n"), 0xfe10, {.d_s = Array_string_str(_const_v__token__valid_at_tokens)}}, {_SLIT0, 0, { .d_c = 0 }}})));
				}
				v__scanner__Scanner_error(s, at_error_msg);
			}
			v__token__Token _t43 = v__scanner__Scanner_new_token(s, v__token__Kind__name, name, name.len);
			return _t43;
		}
		else if (c == ('.')) {
			if (nextc == '.') {
				s->pos++;
				if (s->pos + 1 < s->text.len && s->text.str[ s->pos + 1] == '.') {
					s->pos++;
					v__token__Token _t44 = v__scanner__Scanner_new_token(s, v__token__Kind__ellipsis, _SLIT(""), 3);
					return _t44;
				}
				v__token__Token _t45 = v__scanner__Scanner_new_token(s, v__token__Kind__dotdot, _SLIT(""), 2);
				return _t45;
			}
			v__token__Token _t46 = v__scanner__Scanner_new_token(s, v__token__Kind__dot, _SLIT(""), 1);
			return _t46;
		}
		else if (c == ('#')) {
			if (nextc == '[') {
				s->pos++;
				v__token__Token _t47 = v__scanner__Scanner_new_token(s, v__token__Kind__nilsbr, _SLIT(""), 2);
				return _t47;
			}
			int start = s->pos + 1;
			v__scanner__Scanner_ignore_line(s);
			if (nextc == '!') {
				string comment = string_trim_space(string_substr(s->text, start - 1, s->pos));
				v__token__Token _t48 = v__scanner__Scanner_new_token(s, v__token__Kind__comment, comment, comment.len + 2);
				return _t48;
			}
			string hash = string_trim_space(string_substr(s->text, start, s->pos));
			v__token__Token _t49 = v__scanner__Scanner_new_token(s, v__token__Kind__hash, hash, hash.len + 2);
			return _t49;
		}
		else if (c == ('>')) {
			if (nextc == '=') {
				s->pos++;
				v__token__Token _t50 = v__scanner__Scanner_new_token(s, v__token__Kind__ge, _SLIT(""), 2);
				return _t50;
			} else if (nextc == '>') {
				if (s->pos + 2 < s->text.len) {
					bool _t51; /* if prepend */
					if (s->last_lt >= 0 && s->pos - s->last_lt < 100) {
						Array_string _t52 = __new_array(0, 0, sizeof(string));
						Array_string _t52_orig = string_split(string_substr(s->text, s->last_lt + 1, s->pos), _SLIT(","));
						int _t52_len = _t52_orig.len;
						_t52 = __new_array(0, _t52_len, sizeof(string));

						for (int _t53 = 0; _t53 < _t52_len; ++_t53) {
							string it = ((string*) _t52_orig.data)[_t53];
							string ti = string_after(string_trim_right(string_trim_space(it), _SLIT(">")), _SLIT("]"));
							array_push((array*)&_t52, &ti);
						}
						Array_string typs =_t52;
						bool _t54 = true;
						Array_string _t54_orig = typs;
						int _t54_len = _t54_orig.len;
						for (int _t55 = 0; _t55 < _t54_len; ++_t55) {
							string it = ((string*) _t54_orig.data)[_t55];
							bool _t56 = (it.len > 0);
							bool _t57 = ((_t56) && byte_is_capital(it.str[ 0]));
							bool _t58 = true;
							if (_t57) {
								Array_byte _t58_orig = string_bytes(string_substr(it, 1, it.len));
								int _t58_len = _t58_orig.len;
								for (int _t59 = 0; _t59 < _t58_len; ++_t59) {
									byte it = ((byte*) _t58_orig.data)[_t59];
									if (!(byte_is_alnum(it) || it == '_')) {
										_t58 = false;
										break;
									}
								}
							}
							if (!( _t56 && (( _t57 &&_t58) || v__token__KeywordsMatcher_find(&_const_v__ast__builtin_type_names_matcher, it) > 0))) {
								_t54 = false;
								break;
							}
						}
						_t51 =_t54;
					} else {
						_t51 = false;
					}
					bool is_generic =  _t51;
					if (is_generic) {
						v__token__Token _t60 = v__scanner__Scanner_new_token(s, v__token__Kind__gt, _SLIT(""), 1);
						return _t60;
					} else if (s->text.str[ s->pos + 2] == '=') {
						s->pos += 2;
						v__token__Token _t61 = v__scanner__Scanner_new_token(s, v__token__Kind__right_shift_assign, _SLIT(""), 3);
						return _t61;
					} else if (s->text.str[ s->pos + 2] == '>') {
						if (s->pos + 3 < s->text.len && s->text.str[ s->pos + 3] == '=') {
							s->pos += 3;
							v__token__Token _t62 = v__scanner__Scanner_new_token(s, v__token__Kind__unsigned_right_shift_assign, _SLIT(""), 4);
							return _t62;
						}
						s->pos += 2;
						v__token__Token _t63 = v__scanner__Scanner_new_token(s, v__token__Kind__unsigned_right_shift, _SLIT(""), 3);
						return _t63;
					}
				}
				s->pos++;
				v__token__Token _t64 = v__scanner__Scanner_new_token(s, v__token__Kind__right_shift, _SLIT(""), 2);
				return _t64;
			}
			v__token__Token _t65 = v__scanner__Scanner_new_token(s, v__token__Kind__gt, _SLIT(""), 1);
			return _t65;
		}
		else if (c == ('<')) {
			if (nextc == '=') {
				s->pos++;
				v__token__Token _t66 = v__scanner__Scanner_new_token(s, v__token__Kind__le, _SLIT(""), 2);
				return _t66;
			} else if (nextc == '<') {
				if (s->pos + 2 < s->text.len && s->text.str[ s->pos + 2] == '=') {
					s->pos += 2;
					v__token__Token _t67 = v__scanner__Scanner_new_token(s, v__token__Kind__left_shift_assign, _SLIT(""), 3);
					return _t67;
				}
				s->pos++;
				v__token__Token _t68 = v__scanner__Scanner_new_token(s, v__token__Kind__left_shift, _SLIT(""), 2);
				return _t68;
			} else if (nextc == '-') {
				s->pos++;
				v__token__Token _t69 = v__scanner__Scanner_new_token(s, v__token__Kind__arrow, _SLIT(""), 2);
				return _t69;
			} else {
				s->last_lt = s->pos;
				v__token__Token _t70 = v__scanner__Scanner_new_token(s, v__token__Kind__lt, _SLIT(""), 1);
				return _t70;
			}
		}
		else if (c == ('=')) {
			if (nextc == '=') {
				s->pos++;
				v__token__Token _t71 = v__scanner__Scanner_new_token(s, v__token__Kind__eq, _SLIT(""), 2);
				return _t71;
			} else {
				v__token__Token _t72 = v__scanner__Scanner_new_token(s, v__token__Kind__assign, _SLIT(""), 1);
				return _t72;
			}
		}
		else if (c == (':')) {
			if (nextc == '=') {
				s->pos++;
				v__token__Token _t73 = v__scanner__Scanner_new_token(s, v__token__Kind__decl_assign, _SLIT(""), 2);
				return _t73;
			} else {
				v__token__Token _t74 = v__scanner__Scanner_new_token(s, v__token__Kind__colon, _SLIT(""), 1);
				return _t74;
			}
		}
		else if (c == (';')) {
			v__token__Token _t75 = v__scanner__Scanner_new_token(s, v__token__Kind__semicolon, _SLIT(""), 1);
			return _t75;
		}
		else if (c == ('!')) {
			if (nextc == '=') {
				s->pos++;
				v__token__Token _t76 = v__scanner__Scanner_new_token(s, v__token__Kind__ne, _SLIT(""), 2);
				return _t76;
			} else if (s->text.len > s->pos + 3 && nextc == 'i' && s->text.str[ s->pos + 2] == 'n' && byte_is_space(s->text.str[ s->pos + 3])) {
				s->pos += 2;
				v__token__Token _t77 = v__scanner__Scanner_new_token(s, v__token__Kind__not_in, _SLIT(""), 3);
				return _t77;
			} else if (s->text.len > s->pos + 3 && nextc == 'i' && s->text.str[ s->pos + 2] == 's' && byte_is_space(s->text.str[ s->pos + 3])) {
				s->pos += 2;
				v__token__Token _t78 = v__scanner__Scanner_new_token(s, v__token__Kind__not_is, _SLIT(""), 3);
				return _t78;
			} else {
				v__token__Token _t79 = v__scanner__Scanner_new_token(s, v__token__Kind__not, _SLIT(""), 1);
				return _t79;
			}
		}
		else if (c == ('~')) {
			v__token__Token _t80 = v__scanner__Scanner_new_token(s, v__token__Kind__bit_not, _SLIT(""), 1);
			return _t80;
		}
		else if (c == ('/')) {
			if (nextc == '=') {
				s->pos++;
				v__token__Token _t81 = v__scanner__Scanner_new_token(s, v__token__Kind__div_assign, _SLIT(""), 2);
				return _t81;
			}
			if (nextc == '/') {
				int start = s->pos + 1;
				v__scanner__Scanner_ignore_line(s);
				int comment_line_end = s->pos;
				if (s->text.str[ s->pos - 1] == _const_v__scanner__b_cr) {
					comment_line_end--;
				} else {
					s->pos--;
					s->line_nr--;
				}
				if (v__scanner__Scanner_should_parse_comment(s)) {
					s->line_comment = string_substr(s->text, start + 1, comment_line_end);
					string comment = s->line_comment;
					bool is_separate_line_comment = true;
					for (int j = start - 2; j >= 0 && s->text.str[ j] != _const_v__scanner__b_lf; j--) {
						if (!(s->text.str[ j] == '\t' || s->text.str[ j] == ' ')) {
							is_separate_line_comment = false;
						}
					}
					if (is_separate_line_comment) {
						comment = string__plus(_SLIT("\x01"), comment);
					}
					v__token__Token _t82 = v__scanner__Scanner_new_token(s, v__token__Kind__comment, comment, comment.len + 2);
					return _t82;
				}
				continue;
			} else if (nextc == '*') {
				int start = s->pos + 2;
				int start_line = s->line_nr;
				int nest_count = 1;
				s->pos++;
				for (;;) {
					if (!(nest_count > 0 && s->pos < s->text.len - 1)) break;
					s->pos++;
					if (s->pos >= s->text.len) {
						s->line_nr--;
						v__scanner__Scanner_error(s, _SLIT("comment not terminated"));
					}
					if (s->text.str[ s->pos] == _const_v__scanner__b_lf) {
						v__scanner__Scanner_inc_line_number(s);
						continue;
					}
					if (v__scanner__Scanner_expect(s, _SLIT("/*"), s->pos)) {
						nest_count++;
						continue;
					}
					if (v__scanner__Scanner_expect(s, _SLIT("*/"), s->pos)) {
						nest_count--;
					}
				}
				s->pos++;
				if (v__scanner__Scanner_should_parse_comment(s)) {
					string comment = string_trim(string_substr(s->text, start, (s->pos - 1)), _SLIT(" "));
					if (!string_contains(comment, _SLIT("\n"))) {
						comment = string__plus(_SLIT("\x01"), comment);
					}
					v__token__Token _t83 = v__scanner__Scanner_new_multiline_token(s, v__token__Kind__comment, comment, comment.len + 4, start_line);
					return _t83;
				}
				continue;
			}
			v__token__Token _t84 = v__scanner__Scanner_new_token(s, v__token__Kind__div, _SLIT(""), 1);
			return _t84;
		}
		else {
		};
		if (c == '\0') {
			v__token__Token _t85 = v__scanner__Scanner_end_of_file(s);
			return _t85;
		}
		v__scanner__Scanner_invalid_character(s);
		break;
	}
	v__token__Token _t86 = v__scanner__Scanner_end_of_file(s);
	return _t86;
}

VV_LOCAL_SYMBOL void v__scanner__Scanner_invalid_character(v__scanner__Scanner* s) {
	int len = utf8_char_len(string_at(s->text, s->pos));
	int end = math__mathutil__min_T_int(s->pos + len, s->text.len);
	string c = string_substr(s->text, s->pos, end);
	v__scanner__Scanner_error(s,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("invalid character `"), 0xfe10, {.d_s = c}}, {_SLIT("`"), 0, { .d_c = 0 }}})));
}

VV_LOCAL_SYMBOL int v__scanner__Scanner_current_column(v__scanner__Scanner* s) {
	int _t1 = s->pos - s->last_nl_pos;
	return _t1;
}

VV_LOCAL_SYMBOL int v__scanner__Scanner_count_symbol_before(v__scanner__Scanner* s, int p, byte sym) {
	int count = 0;
	for (int i = p; i >= 0; i--) {
		if (string_at(s->text, i) != sym) {
			break;
		}
		count++;
	}
	int _t1 = count;
	return _t1;
}

// Attr: [direct_array_access]
VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_string(v__scanner__Scanner* s) {
	v__token__Position lspos = (v__token__Position){.len = 0,.line_nr = s->line_nr,.pos = s->pos,.col = s->pos - s->last_nl_pos - 1,.last_line = 0,};
	byte q = s->text.str[ s->pos];
	bool is_quote = q == _const_v__scanner__single_quote || q == _const_v__scanner__double_quote;
	bool is_raw = is_quote && s->pos > 0 && s->text.str[ s->pos - 1] == 'r' && !s->is_inside_string;
	bool is_cstr = is_quote && s->pos > 0 && s->text.str[ s->pos - 1] == 'c' && !s->is_inside_string;
	if (is_quote) {
		if (s->is_inside_string || s->is_enclosed_inter || s->is_inter_start) {
			s->inter_quote = q;
		} else {
			s->quote = q;
		}
	}
	int n_cr_chars = 0;
	int start = s->pos;
	byte start_char = s->text.str[ start];
	if (start_char == s->quote || (start_char == s->inter_quote && (s->is_inter_start || s->is_enclosed_inter))) {
		start++;
	} else if (start_char == _const_v__scanner__b_lf) {
		v__scanner__Scanner_inc_line_number(s);
	}
	s->is_inside_string = false;
	Array_int u_escapes_pos = __new_array_with_default(0, 0, sizeof(int), 0);
	int backslash_count = (start_char == _const_v__scanner__backslash ? (1) : (0));
	for (;;) {
		s->pos++;
		if (s->pos >= s->text.len) {
			if (lspos.line_nr + 1 < s->line_nr) {
				v__scanner__Scanner_add_error_detail_with_pos(s, _SLIT("literal started here"), lspos);
			}
			v__scanner__Scanner_error(s, _SLIT("unfinished string literal"));
			break;
		}
		byte c = s->text.str[ s->pos];
		byte prevc = s->text.str[ s->pos - 1];
		if (c == _const_v__scanner__backslash) {
			backslash_count++;
		}
		if (c == s->quote && (is_raw || backslash_count % 2 == 0)) {
			break;
		}
		if (c == s->inter_quote && (s->is_inter_start || s->is_enclosed_inter)) {
			break;
		}
		if (c == _const_v__scanner__b_cr) {
			n_cr_chars++;
		}
		if (c == _const_v__scanner__b_lf) {
			v__scanner__Scanner_inc_line_number(s);
		}
		if (c == '0' && s->pos > 2 && prevc == _const_v__scanner__backslash) {
			if ((s->pos < s->text.len - 1 && byte_is_digit(s->text.str[ s->pos + 1])) || v__scanner__Scanner_count_symbol_before(s, s->pos - 1, _const_v__scanner__backslash) % 2 == 0) {
			} else if (!is_cstr && !is_raw) {
				v__scanner__Scanner_error(s, _SLIT("cannot use `\\0` (NULL character) in the string literal"));
			}
		}
		if (c == '0' && s->pos > 5 && v__scanner__Scanner_expect(s, _SLIT("\\x0"), s->pos - 3)) {
			if (v__scanner__Scanner_count_symbol_before(s, s->pos - 3, _const_v__scanner__backslash) % 2 == 0) {
			} else if (!is_cstr && !is_raw) {
				v__scanner__Scanner_error(s, _SLIT("cannot use `\\x00` (NULL character) in the string literal"));
			}
		}
		if (backslash_count % 2 == 1 && !is_raw && !is_cstr) {
			if (c == 'x' && (s->text.str[ s->pos + 1] == s->quote || !byte_is_hex_digit(s->text.str[ s->pos + 1]))) {
				v__scanner__Scanner_error(s, _SLIT("`\\x` used with no following hex digits"));
			}
			if (c == 'u') {
				if (s->text.str[ s->pos + 1] == s->quote || s->text.str[ s->pos + 2] == s->quote || s->text.str[ s->pos + 3] == s->quote || s->text.str[ s->pos + 4] == s->quote || !byte_is_hex_digit(s->text.str[ s->pos + 1]) || !byte_is_hex_digit(s->text.str[ s->pos + 2]) || !byte_is_hex_digit(s->text.str[ s->pos + 3]) || !byte_is_hex_digit(s->text.str[ s->pos + 4])) {
					v__scanner__Scanner_error(s, _SLIT("`\\u` incomplete unicode character value"));
				}
				array_push((array*)&u_escapes_pos, _MOV((int[]){ s->pos - 1 }));
			}
		}
		if (prevc == '$' && c == '{' && !is_raw && v__scanner__Scanner_count_symbol_before(s, s->pos - 2, _const_v__scanner__backslash) % 2 == 0) {
			s->is_inside_string = true;
			s->is_enclosed_inter = true;
			s->pos -= 2;
			break;
		}
		if (prevc == '$' && v__util__is_name_char(c) && !is_raw && v__scanner__Scanner_count_symbol_before(s, s->pos - 2, _const_v__scanner__backslash) % 2 == 0) {
			s->is_inside_string = true;
			s->is_inter_start = true;
			s->pos -= 2;
			break;
		}
		if (c != _const_v__scanner__backslash) {
			backslash_count = 0;
		}
	}
	string lit = _SLIT("");
	int end = s->pos;
	if (s->is_inside_string) {
		end++;
	}
	if (start <= s->pos) {
		string string_so_far = string_substr(s->text, start, end);
		if (!s->is_fmt && u_escapes_pos.len > 0) {
			string_so_far = v__scanner__decode_u_escapes(string_so_far, start, u_escapes_pos);
		}
		if (n_cr_chars > 0) {
			string_so_far = string_replace(string_so_far, _SLIT("\r"), _SLIT(""));
		}
		if (string_contains(string_so_far, _SLIT("\\\n"))) {
			lit = v__scanner__trim_slash_line_break(string_so_far);
		} else {
			lit = string_so_far;
		}
	}
	string _t2 = lit;
	return _t2;
}

VV_LOCAL_SYMBOL string v__scanner__decode_u_escapes(string s, int start, Array_int escapes_pos) {
	if (escapes_pos.len == 0) {
		string _t1 = s;
		return _t1;
	}
	Array_string ss = __new_array_with_default(0, escapes_pos.len * 2 + 1, sizeof(string), 0);
	array_push((array*)&ss, _MOV((string[]){ string_clone(string_substr(s, 0, (*(int*)array_first(escapes_pos)) - start)) }));
	for (int i = 0; i < escapes_pos.len; ++i) {
		int pos = ((int*)escapes_pos.data)[i];
		int idx = pos - start;
		int end_idx = idx + 6;
		Option_u64 _t4 = strconv__parse_uint(string_substr(s, idx + 2, end_idx), 16, 32);
		if (_t4.state != 0) { /*or block*/ 
			IError err = _t4.err;
			*(u64*) _t4.data = 0U;
		}
		
 		array_push((array*)&ss, _MOV((string[]){ string_clone(utf32_to_str(((u32)( (*(u64*)_t4.data))))) }));
		if (i + 1 < escapes_pos.len) {
			array_push((array*)&ss, _MOV((string[]){ string_clone(string_substr(s, end_idx, (*(int*)/*ee elem_typ */array_get(escapes_pos, i + 1)) - start)) }));
		} else {
			array_push((array*)&ss, _MOV((string[]){ string_clone(string_substr(s, end_idx, s.len)) }));
		}
	}
	string _t7 = Array_string_join(ss, _SLIT(""));
	return _t7;
}

VV_LOCAL_SYMBOL string v__scanner__trim_slash_line_break(string s) {
	int start = 0;
	string ret_str = s;
	for (;;) {
		int idx = string_index_after(ret_str, _SLIT("\\\n"), start);
		if (idx != -1) {
			ret_str = string__plus(string_substr(ret_str, 0, idx), string_trim_left(string_substr(ret_str, idx + 2, ret_str.len), _SLIT(" \n\t\v\f\r")));
			start = idx;
		} else {
			break;
		}
	}
	string _t1 = ret_str;
	return _t1;
}

VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_char(v__scanner__Scanner* s) {
	int start = s->pos;
	rune slash = '\\';
	int len = 0;
	for (;;) {
		s->pos++;
		if (s->pos >= s->text.len) {
			break;
		}
		if (string_at(s->text, s->pos) != slash) {
			len++;
		}
		bool double_slash = v__scanner__Scanner_expect(s, _SLIT("\\\\"), s->pos - 2);
		if (string_at(s->text, s->pos) == '`' && (string_at(s->text, s->pos - 1) != slash || double_slash)) {
			if (double_slash) {
				len++;
			}
			break;
		}
	}
	len--;
	string c = string_substr(s->text, start + 1, s->pos);
	if (len != 1) {
		Array_rune u = string_runes(c);
		if (u.len != 1) {
			v__scanner__Scanner_error(s, string__plus(_SLIT("invalid character literal (more than one character)\n"), _SLIT("use quotes for strings, backticks for characters")));
		}
	}
	if (string__eq(c, _SLIT("'"))) {
		string _t1 = string__plus(_SLIT("\\"), c);
		return _t1;
	}
	string _t2 = c;
	return _t2;
}

// Attr: [direct_array_access]
// Attr: [inline]
inline VV_LOCAL_SYMBOL bool v__scanner__Scanner_expect(v__scanner__Scanner* s, string want, int start_pos) {
	int end_pos = start_pos + want.len;
	if (start_pos < 0 || end_pos < 0 || start_pos >= s->text.len || end_pos > s->text.len) {
		bool _t1 = false;
		return _t1;
	}
	for (int pos = start_pos; pos < end_pos; ++pos) {
		if (s->text.str[ pos] != want.str[ pos - start_pos]) {
			bool _t2 = false;
			return _t2;
		}
	}
	bool _t3 = true;
	return _t3;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL void v__scanner__Scanner_ignore_line(v__scanner__Scanner* s) {
	v__scanner__Scanner_eat_to_end_of_line(s);
	v__scanner__Scanner_inc_line_number(s);
}

// Attr: [direct_array_access]
// Attr: [inline]
inline VV_LOCAL_SYMBOL void v__scanner__Scanner_eat_to_end_of_line(v__scanner__Scanner* s) {
	for (;;) {
		if (!(s->pos < s->text.len && s->text.str[ s->pos] != _const_v__scanner__b_lf)) break;
		s->pos++;
	}
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL void v__scanner__Scanner_inc_line_number(v__scanner__Scanner* s) {
	s->last_nl_pos = math__mathutil__min_T_int(s->text.len - 1, s->pos);
	if (s->is_crlf) {
		s->last_nl_pos++;
	}
	s->line_nr++;
	if (s->line_nr > s->nr_lines) {
		s->nr_lines = s->line_nr;
	}
}

void v__scanner__Scanner_note(v__scanner__Scanner* s, string msg) {
	v__token__Position pos = (v__token__Position){.len = 0,.line_nr = s->line_nr,.pos = s->pos,.col = 0,.last_line = 0,};
	if (s->pref->output_mode == v__pref__OutputMode__stdout && !s->pref->check_only) {
		eprintln(v__util__formatted_error(_SLIT("notice:"), msg, s->file_path, pos));
	} else {
		array_push((array*)&s->notices, _MOV((v__errors__Notice[]){ (v__errors__Notice){.message = msg,.details = (string){.str=(byteptr)"", .is_lit=1},.file_path = s->file_path,.pos = pos,.reporter = v__errors__Reporter__scanner,} }));
	}
}

void v__scanner__Scanner_add_error_detail(v__scanner__Scanner* s, string msg) {
	array_push((array*)&s->error_details, _MOV((string[]){ string_clone(msg) }));
}

void v__scanner__Scanner_add_error_detail_with_pos(v__scanner__Scanner* s, string msg, v__token__Position pos) {
	string details = v__util__formatted_error(_SLIT("details:"), msg, s->file_path, pos);
	v__scanner__Scanner_add_error_detail(s, details);
}

VV_LOCAL_SYMBOL string v__scanner__Scanner_eat_details(v__scanner__Scanner* s) {
	string details = _SLIT("");
	if (s->error_details.len > 0) {
		details = Array_string_join(s->error_details, _SLIT("\n"));
		s->error_details = __new_array_with_default(0, 0, sizeof(string), 0);
	}
	string _t1 = details;
	return _t1;
}

void v__scanner__Scanner_warn(v__scanner__Scanner* s, string msg) {
	if (s->pref->warns_are_errors) {
		v__scanner__Scanner_error(s, msg);
		return;
	}
	v__token__Position pos = (v__token__Position){.len = 0,.line_nr = s->line_nr,.pos = s->pos,.col = v__scanner__Scanner_current_column(s) - 1,.last_line = 0,};
	string details = v__scanner__Scanner_eat_details(s);
	if (s->pref->output_mode == v__pref__OutputMode__stdout && !s->pref->check_only) {
		eprintln(v__util__formatted_error(_SLIT("warning:"), msg, s->file_path, pos));
		if (details.len > 0) {
			eprintln(details);
		}
	} else {
		if (s->pref->message_limit >= 0 && s->warnings.len >= s->pref->message_limit) {
			s->should_abort = true;
			return;
		}
		array_push((array*)&s->warnings, _MOV((v__errors__Warning[]){ (v__errors__Warning){.message = msg,.details = details,.file_path = s->file_path,.pos = pos,.reporter = v__errors__Reporter__scanner,} }));
	}
}

void v__scanner__Scanner_error(v__scanner__Scanner* s, string msg) {
	v__token__Position pos = (v__token__Position){.len = 0,.line_nr = s->line_nr,.pos = s->pos,.col = v__scanner__Scanner_current_column(s) - 1,.last_line = 0,};
	string details = v__scanner__Scanner_eat_details(s);
	if (s->pref->output_mode == v__pref__OutputMode__stdout && !s->pref->check_only) {
		eprintln(v__util__formatted_error(_SLIT("error:"), msg, s->file_path, pos));
		if (details.len > 0) {
			eprintln(details);
		}
		_v_exit(1);
		VUNREACHABLE();
	} else {
		if (s->pref->fatal_errors) {
			_v_exit(1);
			VUNREACHABLE();
		}
		if (s->pref->message_limit >= 0 && s->errors.len >= s->pref->message_limit) {
			s->should_abort = true;
			return;
		}
		array_push((array*)&s->errors, _MOV((v__errors__Error[]){ (v__errors__Error){.message = msg,.details = details,.file_path = s->file_path,.pos = pos,.backtrace = (string){.str=(byteptr)"", .is_lit=1},.reporter = v__errors__Reporter__scanner,} }));
	}
}

VV_LOCAL_SYMBOL void v__scanner__Scanner_vet_error(v__scanner__Scanner* s, string msg, v__vet__FixKind fix) {
	v__vet__Error ve = (v__vet__Error){
		.kind = v__vet__ErrorKind__error,
		.message = msg,
		.details = (string){.str=(byteptr)"", .is_lit=1},
		.file_path = s->file_path,
		.pos = (v__token__Position){.len = 0,.line_nr = s->line_nr,.pos = 0,.col = v__scanner__Scanner_current_column(s) - 1,.last_line = 0,},
		.fix = fix,
		.typ = v__vet__ErrorType__default,
	};
	array_push((array*)&s->vet_errors, _MOV((v__vet__Error[]){ ve }));
}

// Attr: [noreturn]
VNORETURN void v__scanner__verror(string s) {
	v__util__verror(_SLIT("scanner error"), s);
	VUNREACHABLE();
	while(1);
}

VV_LOCAL_SYMBOL void v__scanner__Scanner_trace(v__scanner__Scanner* s, string fbase, string message) {
	if (string__eq(s->file_base, fbase)) {
		println( str_intp(3, _MOV((StrIntpData[]){{_SLIT("> s.trace | "), 0x14fe10, {.d_s = fbase}}, {_SLIT(" | "), 0xfe10, {.d_s = message}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
}

// TypeDecl
Option_void v__ast__walker__Inspector_visit(v__ast__walker__Inspector* i, v__ast__Node* node) {
	if (i->inspector_callback(node, i->data)) {
		return (Option_void){0};
	}
	return (Option_void){ .state=2, .err=_v_error(_SLIT("")), .data={EMPTY_STRUCT_INITIALIZATION} };
}

void v__ast__walker__inspect(v__ast__Node* node, voidptr data, bool (*inspector_callback)(v__ast__Node* node, voidptr data)) {
	v__ast__walker__Inspector *inspector = HEAP(v__ast__walker__Inspector, ((v__ast__walker__Inspector){.inspector_callback = (voidptr)inspector_callback,.data = data,}));
	v__ast__walker__walk(HEAP(v__ast__walker__Visitor, /*&v.ast.walker.Visitor*/I_v__ast__walker__Inspector_to_Interface_v__ast__walker__Visitor(&(*(inspector)))), node);
}

void v__ast__walker__walk(v__ast__walker__Visitor* visitor, v__ast__Node* node) {
	Option_void _t1 = v__ast__walker__Visitor_name_table[visitor->_typ]._method_visit(visitor->_object, node);
	if (_t1.state != 0 && _t1.err._typ != _IError_None___index) {
		IError err = _t1.err;
		return;
	}
	
 ;
	Array_v__ast__Node children = v__ast__Node_children(/*rec*/*node);
	for (int _t2 = 0; _t2 < children.len; ++_t2) {
		v__ast__Node child_node = ((v__ast__Node*)children.data)[_t2];
		v__ast__walker__walk(visitor, &child_node);
	}
}

VV_LOCAL_SYMBOL v__ast__Stmt v__parser__Parser_assign_stmt(v__parser__Parser* p) {
	Array_v__ast__Ident defer_vars = p->defer_vars;
	p->defer_vars = __new_array_with_default(0, 0, sizeof(v__ast__Ident), 0);
	multi_return_Array_v__ast__Expr_Array_v__ast__Comment mr_322 = v__parser__Parser_expr_list(p);
	Array_v__ast__Expr exprs = mr_322.arg0;
	Array_v__ast__Comment comments = mr_322.arg1;
	if (!(p->inside_defer && p->tok.kind == v__token__Kind__decl_assign)) {
		_PUSH_MANY(&defer_vars, (p->defer_vars), _t1, Array_v__ast__Ident);
	}
	p->defer_vars = defer_vars;
	v__ast__Stmt _t2 = v__parser__Parser_partial_assign_stmt(p, exprs, comments);
	return _t2;
}

VV_LOCAL_SYMBOL Option_void v__parser__Parser_check_undefined_variables(v__parser__Parser* p, Array_v__ast__Expr exprs, v__ast__Expr val) {
bool v__parser__Parser_check_undefined_variables_defer_0 = false;
	p->expr_level++;
	v__parser__Parser_check_undefined_variables_defer_0 = true;
	if (p->expr_level > _const_v__parser__max_expr_level) {
		Option_void _t1 = (Option_void){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("expr level > "), 0xfe07, {.d_i32 = _const_v__parser__max_expr_level}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		// Defer begin
		if (v__parser__Parser_check_undefined_variables_defer_0) {
			p->expr_level--;
		}
		// Defer end
		return _t1;
	}
	if (val._typ == 299 /* v.ast.Ident */) {
		for (int _t2 = 0; _t2 < exprs.len; ++_t2) {
			v__ast__Expr expr = ((v__ast__Expr*)exprs.data)[_t2];
			if ((expr)._typ == 299 /* v.ast.Ident */) {
				if (string__eq((*expr._v__ast__Ident).name, (*val._v__ast__Ident).name) && (*expr._v__ast__Ident).kind != v__ast__IdentKind__blank_ident) {
					v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("undefined variable: `"), 0xfe10, {.d_s = (*val._v__ast__Ident).name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), (*val._v__ast__Ident).pos);
					Option_void _t3 = (Option_void){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("undefined variable: `"), 0xfe10, {.d_s = (*val._v__ast__Ident).name}}, {_SLIT("`"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
					// Defer begin
					if (v__parser__Parser_check_undefined_variables_defer_0) {
						p->expr_level--;
					}
					// Defer end
					return _t3;
				}
			}
		}
	}
	else if (val._typ == 280 /* v.ast.ArrayInit */) {
		if ((*val._v__ast__ArrayInit).has_cap) {
			Option_void _t4 = v__parser__Parser_check_undefined_variables(p, exprs, (*val._v__ast__ArrayInit).cap_expr);
			if (_t4.state != 0 && _t4.err._typ != _IError_None___index) {
			// Defer begin
			if (v__parser__Parser_check_undefined_variables_defer_0) {
				p->expr_level--;
			}
			// Defer end
				Option_void _t5;
				memcpy(&_t5, &_t4, sizeof(Option));
				return _t5;
			}
			
 ;
		}
		if ((*val._v__ast__ArrayInit).has_len) {
			Option_void _t6 = v__parser__Parser_check_undefined_variables(p, exprs, (*val._v__ast__ArrayInit).len_expr);
			if (_t6.state != 0 && _t6.err._typ != _IError_None___index) {
			// Defer begin
			if (v__parser__Parser_check_undefined_variables_defer_0) {
				p->expr_level--;
			}
			// Defer end
				Option_void _t7;
				memcpy(&_t7, &_t6, sizeof(Option));
				return _t7;
			}
			
 ;
		}
		if ((*val._v__ast__ArrayInit).has_default) {
			Option_void _t8 = v__parser__Parser_check_undefined_variables(p, exprs, (*val._v__ast__ArrayInit).default_expr);
			if (_t8.state != 0 && _t8.err._typ != _IError_None___index) {
			// Defer begin
			if (v__parser__Parser_check_undefined_variables_defer_0) {
				p->expr_level--;
			}
			// Defer end
				Option_void _t9;
				memcpy(&_t9, &_t8, sizeof(Option));
				return _t9;
			}
			
 ;
		}
		for (int _t10 = 0; _t10 < (*val._v__ast__ArrayInit).exprs.len; ++_t10) {
			v__ast__Expr expr = ((v__ast__Expr*)(*val._v__ast__ArrayInit).exprs.data)[_t10];
			Option_void _t11 = v__parser__Parser_check_undefined_variables(p, exprs, expr);
			if (_t11.state != 0 && _t11.err._typ != _IError_None___index) {
			// Defer begin
			if (v__parser__Parser_check_undefined_variables_defer_0) {
				p->expr_level--;
			}
			// Defer end
				Option_void _t12;
				memcpy(&_t12, &_t11, sizeof(Option));
				return _t12;
			}
			
 ;
		}
	}
	else if (val._typ == 286 /* v.ast.CallExpr */) {
		Option_void _t13 = v__parser__Parser_check_undefined_variables(p, exprs, (*val._v__ast__CallExpr).left);
		if (_t13.state != 0 && _t13.err._typ != _IError_None___index) {
		// Defer begin
		if (v__parser__Parser_check_undefined_variables_defer_0) {
			p->expr_level--;
		}
		// Defer end
			Option_void _t14;
			memcpy(&_t14, &_t13, sizeof(Option));
			return _t14;
		}
		
 ;
		for (int _t15 = 0; _t15 < (*val._v__ast__CallExpr).args.len; ++_t15) {
			v__ast__CallArg arg = ((v__ast__CallArg*)(*val._v__ast__CallExpr).args.data)[_t15];
			Option_void _t16 = v__parser__Parser_check_undefined_variables(p, exprs, arg.expr);
			if (_t16.state != 0 && _t16.err._typ != _IError_None___index) {
			// Defer begin
			if (v__parser__Parser_check_undefined_variables_defer_0) {
				p->expr_level--;
			}
			// Defer end
				Option_void _t17;
				memcpy(&_t17, &_t16, sizeof(Option));
				return _t17;
			}
			
 ;
		}
	}
	else if (val._typ == 303 /* v.ast.InfixExpr */) {
		Option_void _t18 = v__parser__Parser_check_undefined_variables(p, exprs, (*val._v__ast__InfixExpr).left);
		if (_t18.state != 0 && _t18.err._typ != _IError_None___index) {
		// Defer begin
		if (v__parser__Parser_check_undefined_variables_defer_0) {
			p->expr_level--;
		}
		// Defer end
			Option_void _t19;
			memcpy(&_t19, &_t18, sizeof(Option));
			return _t19;
		}
		
 ;
		Option_void _t20 = v__parser__Parser_check_undefined_variables(p, exprs, (*val._v__ast__InfixExpr).right);
		if (_t20.state != 0 && _t20.err._typ != _IError_None___index) {
		// Defer begin
		if (v__parser__Parser_check_undefined_variables_defer_0) {
			p->expr_level--;
		}
		// Defer end
			Option_void _t21;
			memcpy(&_t21, &_t20, sizeof(Option));
			return _t21;
		}
		
 ;
	}
	else if (val._typ == 308 /* v.ast.MapInit */) {
		for (int _t22 = 0; _t22 < (*val._v__ast__MapInit).keys.len; ++_t22) {
			v__ast__Expr key = ((v__ast__Expr*)(*val._v__ast__MapInit).keys.data)[_t22];
			Option_void _t23 = v__parser__Parser_check_undefined_variables(p, exprs, key);
			if (_t23.state != 0 && _t23.err._typ != _IError_None___index) {
			// Defer begin
			if (v__parser__Parser_check_undefined_variables_defer_0) {
				p->expr_level--;
			}
			// Defer end
				Option_void _t24;
				memcpy(&_t24, &_t23, sizeof(Option));
				return _t24;
			}
			
 ;
		}
		for (int _t25 = 0; _t25 < (*val._v__ast__MapInit).vals.len; ++_t25) {
			v__ast__Expr value = ((v__ast__Expr*)(*val._v__ast__MapInit).vals.data)[_t25];
			Option_void _t26 = v__parser__Parser_check_undefined_variables(p, exprs, value);
			if (_t26.state != 0 && _t26.err._typ != _IError_None___index) {
			// Defer begin
			if (v__parser__Parser_check_undefined_variables_defer_0) {
				p->expr_level--;
			}
			// Defer end
				Option_void _t27;
				memcpy(&_t27, &_t26, sizeof(Option));
				return _t27;
			}
			
 ;
		}
	}
	else if (val._typ == 314 /* v.ast.ParExpr */) {
		Option_void _t28 = v__parser__Parser_check_undefined_variables(p, exprs, (*val._v__ast__ParExpr).expr);
		if (_t28.state != 0 && _t28.err._typ != _IError_None___index) {
		// Defer begin
		if (v__parser__Parser_check_undefined_variables_defer_0) {
			p->expr_level--;
		}
		// Defer end
			Option_void _t29;
			memcpy(&_t29, &_t28, sizeof(Option));
			return _t29;
		}
		
 ;
	}
	else if (val._typ == 315 /* v.ast.PostfixExpr */) {
		Option_void _t30 = v__parser__Parser_check_undefined_variables(p, exprs, (*val._v__ast__PostfixExpr).expr);
		if (_t30.state != 0 && _t30.err._typ != _IError_None___index) {
		// Defer begin
		if (v__parser__Parser_check_undefined_variables_defer_0) {
			p->expr_level--;
		}
		// Defer end
			Option_void _t31;
			memcpy(&_t31, &_t30, sizeof(Option));
			return _t31;
		}
		
 ;
	}
	else if (val._typ == 316 /* v.ast.PrefixExpr */) {
		Option_void _t32 = v__parser__Parser_check_undefined_variables(p, exprs, (*val._v__ast__PrefixExpr).right);
		if (_t32.state != 0 && _t32.err._typ != _IError_None___index) {
		// Defer begin
		if (v__parser__Parser_check_undefined_variables_defer_0) {
			p->expr_level--;
		}
		// Defer end
			Option_void _t33;
			memcpy(&_t33, &_t32, sizeof(Option));
			return _t33;
		}
		
 ;
	}
	else if (val._typ == 322 /* v.ast.StringInterLiteral */) {
		for (int _t34 = 0; _t34 < (*val._v__ast__StringInterLiteral).exprs.len; ++_t34) {
			v__ast__Expr expr_ = ((v__ast__Expr*)(*val._v__ast__StringInterLiteral).exprs.data)[_t34];
			Option_void _t35 = v__parser__Parser_check_undefined_variables(p, exprs, expr_);
			if (_t35.state != 0 && _t35.err._typ != _IError_None___index) {
			// Defer begin
			if (v__parser__Parser_check_undefined_variables_defer_0) {
				p->expr_level--;
			}
			// Defer end
				Option_void _t36;
				memcpy(&_t36, &_t35, sizeof(Option));
				return _t36;
			}
			
 ;
		}
	}
	
	else {
	}
	;
	// Defer begin
	if (v__parser__Parser_check_undefined_variables_defer_0) {
		p->expr_level--;
	}
	// Defer end
	return (Option_void){0};
}

VV_LOCAL_SYMBOL bool v__parser__Parser_check_cross_variables(v__parser__Parser* p, Array_v__ast__Expr exprs, v__ast__Expr val) {
	string val_str = v__ast__Expr_str(val);
	if (val._typ == 299 /* v.ast.Ident */) {
		for (int _t1 = 0; _t1 < exprs.len; ++_t1) {
			v__ast__Expr expr = ((v__ast__Expr*)exprs.data)[_t1];
			if ((expr)._typ == 299 /* v.ast.Ident */) {
				if (string__eq((*expr._v__ast__Ident).name, (*val._v__ast__Ident).name)) {
					bool _t2 = true;
					return _t2;
				}
			}
		}
	}
	else if (val._typ == 302 /* v.ast.IndexExpr */) {
		for (int _t3 = 0; _t3 < exprs.len; ++_t3) {
			v__ast__Expr expr = ((v__ast__Expr*)exprs.data)[_t3];
			if (string__eq(v__ast__Expr_str(expr), val_str)) {
				bool _t4 = true;
				return _t4;
			}
		}
	}
	else if (val._typ == 303 /* v.ast.InfixExpr */) {
		bool _t5 = v__parser__Parser_check_cross_variables(p, exprs, (*val._v__ast__InfixExpr).left) || v__parser__Parser_check_cross_variables(p, exprs, (*val._v__ast__InfixExpr).right);
		return _t5;
	}
	else if (val._typ == 316 /* v.ast.PrefixExpr */) {
		bool _t6 = v__parser__Parser_check_cross_variables(p, exprs, (*val._v__ast__PrefixExpr).right);
		return _t6;
	}
	else if (val._typ == 315 /* v.ast.PostfixExpr */) {
		bool _t7 = v__parser__Parser_check_cross_variables(p, exprs, (*val._v__ast__PostfixExpr).expr);
		return _t7;
	}
	else if (val._typ == 319 /* v.ast.SelectorExpr */) {
		for (int _t8 = 0; _t8 < exprs.len; ++_t8) {
			v__ast__Expr expr = ((v__ast__Expr*)exprs.data)[_t8];
			if (string__eq(v__ast__Expr_str(expr), val_str)) {
				bool _t9 = true;
				return _t9;
			}
		}
	}
	
	else {
	}
	;
	bool _t10 = false;
	return _t10;
}

VV_LOCAL_SYMBOL v__ast__Stmt v__parser__Parser_partial_assign_stmt(v__parser__Parser* p, Array_v__ast__Expr left, Array_v__ast__Comment left_comments) {
	p->is_stmt_ident = false;
	v__token__Kind op = p->tok.kind;
	v__token__Position pos = v__token__Token_position(&p->tok);
	v__parser__Parser_next(p);
	Array_v__ast__Comment comments = __new_array_with_default(0, 2 * left_comments.len + 1, sizeof(v__ast__Comment), 0);
	_PUSH_MANY(&comments, (left_comments), _t1, Array_v__ast__Comment);
	_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,})), _t2, Array_v__ast__Comment);
	Array_v__ast__Comment right_comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	Array_v__ast__Expr right = __new_array_with_default(0, left.len, sizeof(v__ast__Expr), 0);
	multi_return_Array_v__ast__Expr_Array_v__ast__Comment mr_3345 = v__parser__Parser_expr_list(p);
	right = mr_3345.arg0;
	right_comments = mr_3345.arg1;
	_PUSH_MANY(&comments, (right_comments), _t3, Array_v__ast__Comment);
	Array_v__ast__Comment end_comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = true,.follow_up = 0,});
	bool has_cross_var = false;
	bool is_static = false;
	bool is_volatile = false;
	for (int i = 0; i < left.len; ++i) {
		v__ast__Expr lx = ((v__ast__Expr*)left.data)[i];
		if (lx._typ == 299 /* v.ast.Ident */) {
			if (op == v__token__Kind__decl_assign) {
				if (v__ast__Scope_known_var(p->scope, (*lx._v__ast__Ident).name)) {
					v__ast__Stmt _t4 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("redefinition of `"), 0xfe10, {.d_s = (*lx._v__ast__Ident).name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), (*lx._v__ast__Ident).pos))));
					return _t4;
				}
				v__ast__ShareType share = ((v__ast__ShareType)(0));
				if (((*lx._v__ast__Ident).info)._typ == 408 /* v.ast.IdentVar */) {
					v__ast__IdentVar iv = /* as */ *(v__ast__IdentVar*)__as_cast(((*lx._v__ast__Ident).info)._v__ast__IdentVar,((*lx._v__ast__Ident).info)._typ, 408) /*expected idx: 408, name: v.ast.IdentVar */ ;
					share = iv.share;
					if (iv.is_static) {
						if (!p->pref->translated && !p->pref->is_fmt && !p->inside_unsafe_fn) {
							v__ast__Stmt _t5 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _SLIT("static variables are supported only in -translated mode or in [unsafe] fn"), (*lx._v__ast__Ident).pos))));
							return _t5;
						}
						is_static = true;
					}
					if (iv.is_volatile) {
						is_volatile = true;
					}
				}
				v__ast__Expr r0 = (*(v__ast__Expr*)/*ee elem_typ */array_get(right, 0));
				v__ast__Var v = (v__ast__Var){
					.name = (*lx._v__ast__Ident).name,
					.expr = (left.len == right.len ? ((*(v__ast__Expr*)/*ee elem_typ */array_get(right, i))) : (v__ast__empty_expr())),
					.share = share,
					.is_mut = (*lx._v__ast__Ident).is_mut || p->inside_for,
					.is_autofree_tmp = 0,
					.is_arg = 0,
					.is_auto_deref = 0,
					.is_inherited = 0,
					.typ = 0,
					.orig_type = 0,
					.smartcasts = __new_array(0, 0, sizeof(v__ast__Type)),
					.pos = (*lx._v__ast__Ident).pos,
					.is_used = 0,
					.is_changed = 0,
					.is_or = 0,
					.is_tmp = 0,
					.is_auto_heap = 0,
					.is_stack_obj = p->inside_for,
				};
				if (p->pref->autofree) {
					if ((r0)._typ == 286 /* v.ast.CallExpr */) {
						if ((*r0._v__ast__CallExpr).or_block.pos.pos > 0 && (*r0._v__ast__CallExpr).or_block.stmts.len > 0) {
							v.is_or = true;
						}
					}
				}
				v__ast__ScopeObject obj = v__ast__Var_to_sumtype_v__ast__ScopeObject(&v);
				(*lx._v__ast__Ident).obj = obj;
				v__ast__Scope_register(p->scope, obj);
			}
		}
		else if (lx._typ == 302 /* v.ast.IndexExpr */) {
			if (op == v__token__Kind__decl_assign) {
				v__ast__Stmt _t6 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("non-name `"), 0xfe10, {.d_s = v__ast__Expr_str((*lx._v__ast__IndexExpr).left)}}, {_SLIT("["), 0xfe10, {.d_s = v__ast__Expr_str((*lx._v__ast__IndexExpr).index)}}, {_SLIT("]` on left side of `:=`"), 0, { .d_c = 0 }}})), (*lx._v__ast__IndexExpr).pos))));
				return _t6;
			}
			(*lx._v__ast__IndexExpr).is_setter = true;
		}
		else if (lx._typ == 314 /* v.ast.ParExpr */) {
		}
		else if (lx._typ == 316 /* v.ast.PrefixExpr */) {
		}
		else if (lx._typ == 319 /* v.ast.SelectorExpr */) {
			if (op == v__token__Kind__decl_assign) {
				v__ast__Stmt _t7 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _SLIT("struct fields can only be declared during the initialization"), (*lx._v__ast__SelectorExpr).pos))));
				return _t7;
			}
		}
		
		else {
		}
		;
	}
	if (op == v__token__Kind__decl_assign) {
		for (int _t8 = 0; _t8 < right.len; ++_t8) {
			v__ast__Expr r = ((v__ast__Expr*)right.data)[_t8];
			Option_void _t9 = v__parser__Parser_check_undefined_variables(p, left, r);
			if (_t9.state != 0 && _t9.err._typ != _IError_None___index) {
				IError err = _t9.err;
				v__ast__Stmt _t10 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, (*(err.msg)), pos))));
				return _t10;
			}
			
 ;
		}
	} else if (left.len > 1) {
		for (int _t11 = 0; _t11 < right.len; ++_t11) {
			v__ast__Expr r = ((v__ast__Expr*)right.data)[_t11];
			has_cross_var = v__parser__Parser_check_cross_variables(p, left, r);
			if (!(op == v__token__Kind__assign || op == v__token__Kind__decl_assign)) {
				v__ast__Stmt _t12 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unexpected "), 0xfe10, {.d_s = v__token__Kind_str(op)}}, {_SLIT(", expecting := or = or comma"), 0, { .d_c = 0 }}})), pos))));
				return _t12;
			}
			if (has_cross_var) {
				break;
			}
		}
	}
	v__token__Position_update_last_line(&pos, p->prev_tok.line_nr);
	v__ast__Stmt _t13 = v__ast__AssignStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__AssignStmt, ((v__ast__AssignStmt){
		.op = op,
		.pos = pos,
		.comments = comments,
		.end_comments = end_comments,
		.right = right,
		.left = left,
		.left_types = __new_array(0, 0, sizeof(v__ast__Type)),
		.right_types = __new_array(0, 0, sizeof(v__ast__Type)),
		.is_static = is_static,
		.is_volatile = is_volatile,
		.is_simple = p->inside_for && p->tok.kind == v__token__Kind__lcbr,
		.has_cross_var = has_cross_var,
	})));
	return _t13;
}

VV_LOCAL_SYMBOL v__ast__HashStmt v__parser__Parser_hash(v__parser__Parser* p) {
	v__token__Position pos = v__token__Token_position(&p->tok);
	string val = p->tok.lit;
	string kind = string_all_before(val, _SLIT(" "));
	v__parser__Parser_next(p);
	string main_str = _SLIT("");
	string msg = _SLIT("");
	string content = string_all_before(string_all_after(val,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = kind}}, {_SLIT(" "), 0, { .d_c = 0 }}}))), _SLIT("//"));
	if (string_contains(content, _SLIT(" #"))) {
		main_str = string_trim_space(string_all_before(content, _SLIT(" #")));
		msg = string_trim_space(string_all_after(content, _SLIT(" #")));
	} else {
		main_str = string_trim_space(content);
		msg = _SLIT("");
	}
	v__ast__HashStmt _t1 = (v__ast__HashStmt){
		.mod = p->mod,
		.pos = pos,
		.source_file = p->file_name,
		.val = val,
		.kind = kind,
		.main = main_str,
		.msg = msg,
		.ct_conds = __new_array(0, 0, sizeof(v__ast__Expr)),
	};
	return _t1;
}

VV_LOCAL_SYMBOL v__ast__ComptimeCall v__parser__Parser_comptime_call(v__parser__Parser* p) {
	v__ast__ComptimeCall *err_node = HEAP(v__ast__ComptimeCall, ((v__ast__ComptimeCall){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.has_parens = 0,.method_name = (string){.str=(byteptr)"", .is_lit=1},.method_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.scope = 0,.left = {0},.args_var = (string){.str=(byteptr)"", .is_lit=1},.is_vweb = 0,.vweb_tmpl = (v__ast__File){.nr_lines = 0,.nr_bytes = 0,.mod = (v__ast__Module){.name = (string){.str=(byteptr)"", .is_lit=1},.short_name = (string){.str=(byteptr)"", .is_lit=1},.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.name_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.is_skipped = 0,},.global_scope = 0,.is_test = 0,.is_generated = 0,.path = (string){.str=(byteptr)"", .is_lit=1},.path_base = (string){.str=(byteptr)"", .is_lit=1},.scope = 0,.stmts = __new_array(0, 0, sizeof(v__ast__Stmt)),.imports = __new_array(0, 0, sizeof(v__ast__Import)),.auto_imports = __new_array(0, 0, sizeof(string)),.embedded_files = __new_array(0, 0, sizeof(v__ast__EmbeddedFile)),.imported_symbols = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.errors = __new_array(0, 0, sizeof(v__errors__Error)),.warnings = __new_array(0, 0, sizeof(v__errors__Warning)),.notices = __new_array(0, 0, sizeof(v__errors__Notice)),.generic_fns = __new_array(0, 0, sizeof(v__ast__FnDecl*)),.global_labels = __new_array(0, 0, sizeof(string)),},.is_embed = 0,.is_env = 0,.env_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.is_pkgconfig = 0,.left_type = 0,.result_type = 0,.env_value = (string){.str=(byteptr)"", .is_lit=1},.args = __new_array(0, 0, sizeof(v__ast__CallArg)),.embed_file = (v__ast__EmbeddedFile){.rpath = (string){.str=(byteptr)"", .is_lit=1},.apath = (string){.str=(byteptr)"", .is_lit=1},.compression_type = (string){.str=(byteptr)"", .is_lit=1},.is_compressed = 0,.bytes = __new_array(0, 0, sizeof(byte)),.len = 0,},}));
	v__parser__Parser_check(p, v__token__Kind__dollar);
	v__token__Position start_pos = v__token__Token_position(&p->prev_tok);
	string error_msg = _SLIT("only `$tmpl()`, `$env()`, `$embed_file()`, `$pkgconfig()` and `$vweb.html()` comptime functions are supported right now");
	if (p->peek_tok.kind == v__token__Kind__dot) {
		string name = v__parser__Parser_check_name(p);
		if (!string__eq(name, _SLIT("vweb"))) {
			v__parser__Parser_error(p, error_msg);
			v__ast__ComptimeCall _t1 = (*(err_node));
			return _t1;
		}
		v__parser__Parser_check(p, v__token__Kind__dot);
	}
	string method_name = v__parser__Parser_check_name(p);
	if (!Array_string_contains(_const_v__parser__supported_comptime_calls, method_name)) {
		v__parser__Parser_error(p, error_msg);
		v__ast__ComptimeCall _t2 = (*(err_node));
		return _t2;
	}
	bool is_embed_file = string__eq(method_name, _SLIT("embed_file"));
	bool is_html = string__eq(method_name, _SLIT("html"));
	v__parser__Parser_check(p, v__token__Kind__lpar);
	v__token__Position spos = v__token__Token_position(&p->tok);
	if (string__eq(method_name, _SLIT("env"))) {
		string s = p->tok.lit;
		v__parser__Parser_check(p, v__token__Kind__string);
		v__parser__Parser_check(p, v__token__Kind__rpar);
		v__ast__ComptimeCall _t3 = (v__ast__ComptimeCall){
			.pos = v__token__Position_extend(spos, v__token__Token_position(&p->prev_tok)),
			.has_parens = 0,
			.method_name = method_name,
			.method_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},
			.scope = 0,
			.left = {0},
			.args_var = s,
			.is_vweb = 0,
			.vweb_tmpl = (v__ast__File){.nr_lines = 0,.nr_bytes = 0,.mod = (v__ast__Module){.name = (string){.str=(byteptr)"", .is_lit=1},.short_name = (string){.str=(byteptr)"", .is_lit=1},.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.name_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.is_skipped = 0,},.global_scope = 0,.is_test = 0,.is_generated = 0,.path = (string){.str=(byteptr)"", .is_lit=1},.path_base = (string){.str=(byteptr)"", .is_lit=1},.scope = 0,.stmts = __new_array(0, 0, sizeof(v__ast__Stmt)),.imports = __new_array(0, 0, sizeof(v__ast__Import)),.auto_imports = __new_array(0, 0, sizeof(string)),.embedded_files = __new_array(0, 0, sizeof(v__ast__EmbeddedFile)),.imported_symbols = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.errors = __new_array(0, 0, sizeof(v__errors__Error)),.warnings = __new_array(0, 0, sizeof(v__errors__Warning)),.notices = __new_array(0, 0, sizeof(v__errors__Notice)),.generic_fns = __new_array(0, 0, sizeof(v__ast__FnDecl*)),.global_labels = __new_array(0, 0, sizeof(string)),},
			.is_embed = 0,
			.is_env = true,
			.env_pos = spos,
			.is_pkgconfig = 0,
			.left_type = 0,
			.result_type = 0,
			.env_value = (string){.str=(byteptr)"", .is_lit=1},
			.args = __new_array(0, 0, sizeof(v__ast__CallArg)),
			.embed_file = (v__ast__EmbeddedFile){.rpath = (string){.str=(byteptr)"", .is_lit=1},.apath = (string){.str=(byteptr)"", .is_lit=1},.compression_type = (string){.str=(byteptr)"", .is_lit=1},.is_compressed = 0,.bytes = __new_array(0, 0, sizeof(byte)),.len = 0,},
		};
		return _t3;
	}
	if (string__eq(method_name, _SLIT("pkgconfig"))) {
		string s = p->tok.lit;
		v__parser__Parser_check(p, v__token__Kind__string);
		v__parser__Parser_check(p, v__token__Kind__rpar);
		v__ast__ComptimeCall _t4 = (v__ast__ComptimeCall){
			.pos = v__token__Position_extend(spos, v__token__Token_position(&p->prev_tok)),
			.has_parens = 0,
			.method_name = method_name,
			.method_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},
			.scope = 0,
			.left = {0},
			.args_var = s,
			.is_vweb = 0,
			.vweb_tmpl = (v__ast__File){.nr_lines = 0,.nr_bytes = 0,.mod = (v__ast__Module){.name = (string){.str=(byteptr)"", .is_lit=1},.short_name = (string){.str=(byteptr)"", .is_lit=1},.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.name_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.is_skipped = 0,},.global_scope = 0,.is_test = 0,.is_generated = 0,.path = (string){.str=(byteptr)"", .is_lit=1},.path_base = (string){.str=(byteptr)"", .is_lit=1},.scope = 0,.stmts = __new_array(0, 0, sizeof(v__ast__Stmt)),.imports = __new_array(0, 0, sizeof(v__ast__Import)),.auto_imports = __new_array(0, 0, sizeof(string)),.embedded_files = __new_array(0, 0, sizeof(v__ast__EmbeddedFile)),.imported_symbols = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.errors = __new_array(0, 0, sizeof(v__errors__Error)),.warnings = __new_array(0, 0, sizeof(v__errors__Warning)),.notices = __new_array(0, 0, sizeof(v__errors__Notice)),.generic_fns = __new_array(0, 0, sizeof(v__ast__FnDecl*)),.global_labels = __new_array(0, 0, sizeof(string)),},
			.is_embed = 0,
			.is_env = 0,
			.env_pos = spos,
			.is_pkgconfig = true,
			.left_type = 0,
			.result_type = 0,
			.env_value = (string){.str=(byteptr)"", .is_lit=1},
			.args = __new_array(0, 0, sizeof(v__ast__CallArg)),
			.embed_file = (v__ast__EmbeddedFile){.rpath = (string){.str=(byteptr)"", .is_lit=1},.apath = (string){.str=(byteptr)"", .is_lit=1},.compression_type = (string){.str=(byteptr)"", .is_lit=1},.is_compressed = 0,.bytes = __new_array(0, 0, sizeof(byte)),.len = 0,},
		};
		return _t4;
	}
	string literal_string_param = (is_html ? (_SLIT("")) : (p->tok.lit));
	string path_of_literal_string_param = string_replace(literal_string_param, _SLIT("/"), _const_os__path_separator);
	if (!is_html) {
		v__parser__Parser_check(p, v__token__Kind__string);
	}
	string embed_compression_type = _SLIT("none");
	if (is_embed_file) {
		if (p->tok.kind == v__token__Kind__comma) {
			v__parser__Parser_check(p, v__token__Kind__comma);
			v__parser__Parser_check(p, v__token__Kind__dot);
			embed_compression_type = v__parser__Parser_check_name(p);
		}
	}
	v__parser__Parser_check(p, v__token__Kind__rpar);
	if (is_embed_file) {
		string epath = path_of_literal_string_param;
		if ((epath).len == 0) {
			v__parser__Parser_error_with_pos(p, _SLIT("supply a valid relative or absolute file path to the file to embed"), spos);
			v__ast__ComptimeCall _t5 = (*(err_node));
			return _t5;
		}
		if (!p->pref->is_fmt) {
			string abs_path = os__real_path(epath);
			if (!os__exists(abs_path)) {
				epath = os__real_path(os__join_path_single(os__dir(p->file_name), epath));
				if (!os__exists(epath)) {
					v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\""), 0xfe10, {.d_s = epath}}, {_SLIT("\" does not exist so it cannot be embedded"), 0, { .d_c = 0 }}})), spos);
					v__ast__ComptimeCall _t6 = (*(err_node));
					return _t6;
				}
				if (!os__is_file(epath)) {
					v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\""), 0xfe10, {.d_s = epath}}, {_SLIT("\" is not a file so it cannot be embedded"), 0, { .d_c = 0 }}})), spos);
					v__ast__ComptimeCall _t7 = (*(err_node));
					return _t7;
				}
			} else {
				epath = abs_path;
			}
		}
		v__parser__Parser_register_auto_import(p, _SLIT("v.preludes.embed_file"));
		if (string__eq(embed_compression_type, _SLIT("zlib")) && (p->pref->is_prod || Array_string_contains(p->pref->compile_defines, _SLIT("debug_embed_file_in_prod")))) {
			v__parser__Parser_register_auto_import(p, _SLIT("v.preludes.embed_file.zlib"));
		}
		v__ast__ComptimeCall _t8 = (v__ast__ComptimeCall){.pos = v__token__Position_extend(start_pos, v__token__Token_position(&p->prev_tok)),.has_parens = 0,.method_name = (string){.str=(byteptr)"", .is_lit=1},.method_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.scope = 0,.left = {0},.args_var = (string){.str=(byteptr)"", .is_lit=1},.is_vweb = 0,.vweb_tmpl = (v__ast__File){.nr_lines = 0,.nr_bytes = 0,.mod = (v__ast__Module){.name = (string){.str=(byteptr)"", .is_lit=1},.short_name = (string){.str=(byteptr)"", .is_lit=1},.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.name_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.is_skipped = 0,},.global_scope = 0,.is_test = 0,.is_generated = 0,.path = (string){.str=(byteptr)"", .is_lit=1},.path_base = (string){.str=(byteptr)"", .is_lit=1},.scope = 0,.stmts = __new_array(0, 0, sizeof(v__ast__Stmt)),.imports = __new_array(0, 0, sizeof(v__ast__Import)),.auto_imports = __new_array(0, 0, sizeof(string)),.embedded_files = __new_array(0, 0, sizeof(v__ast__EmbeddedFile)),.imported_symbols = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.errors = __new_array(0, 0, sizeof(v__errors__Error)),.warnings = __new_array(0, 0, sizeof(v__errors__Warning)),.notices = __new_array(0, 0, sizeof(v__errors__Notice)),.generic_fns = __new_array(0, 0, sizeof(v__ast__FnDecl*)),.global_labels = __new_array(0, 0, sizeof(string)),},.is_embed = true,.is_env = 0,.env_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.is_pkgconfig = 0,.left_type = 0,.result_type = 0,.env_value = (string){.str=(byteptr)"", .is_lit=1},.args = __new_array(0, 0, sizeof(v__ast__CallArg)),.embed_file = (v__ast__EmbeddedFile){.rpath = literal_string_param,.apath = epath,.compression_type = embed_compression_type,.is_compressed = 0,.bytes = __new_array(0, 0, sizeof(byte)),.len = 0,},};
		return _t8;
	}
	Array_string fn_path = string_split(p->cur_fn_name, _SLIT("_"));
	string fn_path_joined = Array_string_join(fn_path, _const_os__path_separator);
	string compiled_vfile_path = os__real_path(string_replace(p->scanner->file_path, _SLIT("/"), _const_os__path_separator));
	string tmpl_path = (is_html ? ( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = (*(string*)array_last(fn_path))}}, {_SLIT(".html"), 0, { .d_c = 0 }}}))) : (path_of_literal_string_param));
	string dir = os__dir(compiled_vfile_path);
	string path = os__join_path_single(dir, fn_path_joined);
	path = /*f*/string__plus(path, _SLIT(".html"));
	path = os__real_path(path);
	if (!is_html) {
		if (os__is_abs_path(tmpl_path)) {
			path = tmpl_path;
		} else {
			path = os__join_path_single(dir, tmpl_path);
		}
	}
	if (!os__exists(path)) {
		if (is_html) {
			path = os__join_path(dir, new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT("templates"), fn_path_joined})));
			path = /*f*/string__plus(path, _SLIT(".html"));
		}
		if (!os__exists(path)) {
			if (p->pref->is_fmt) {
				v__ast__ComptimeCall _t9 = (v__ast__ComptimeCall){.pos = v__token__Position_extend(start_pos, v__token__Token_position(&p->prev_tok)),.has_parens = 0,.method_name = method_name,.method_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.scope = 0,.left = {0},.args_var = literal_string_param,.is_vweb = true,.vweb_tmpl = (v__ast__File){.nr_lines = 0,.nr_bytes = 0,.mod = (v__ast__Module){.name = (string){.str=(byteptr)"", .is_lit=1},.short_name = (string){.str=(byteptr)"", .is_lit=1},.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.name_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.is_skipped = 0,},.global_scope = 0,.is_test = 0,.is_generated = 0,.path = (string){.str=(byteptr)"", .is_lit=1},.path_base = (string){.str=(byteptr)"", .is_lit=1},.scope = 0,.stmts = __new_array(0, 0, sizeof(v__ast__Stmt)),.imports = __new_array(0, 0, sizeof(v__ast__Import)),.auto_imports = __new_array(0, 0, sizeof(string)),.embedded_files = __new_array(0, 0, sizeof(v__ast__EmbeddedFile)),.imported_symbols = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.errors = __new_array(0, 0, sizeof(v__errors__Error)),.warnings = __new_array(0, 0, sizeof(v__errors__Warning)),.notices = __new_array(0, 0, sizeof(v__errors__Notice)),.generic_fns = __new_array(0, 0, sizeof(v__ast__FnDecl*)),.global_labels = __new_array(0, 0, sizeof(string)),},.is_embed = 0,.is_env = 0,.env_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.is_pkgconfig = 0,.left_type = 0,.result_type = 0,.env_value = (string){.str=(byteptr)"", .is_lit=1},.args = __new_array(0, 0, sizeof(v__ast__CallArg)),.embed_file = (v__ast__EmbeddedFile){.rpath = (string){.str=(byteptr)"", .is_lit=1},.apath = (string){.str=(byteptr)"", .is_lit=1},.compression_type = (string){.str=(byteptr)"", .is_lit=1},.is_compressed = 0,.bytes = __new_array(0, 0, sizeof(byte)),.len = 0,},};
				return _t9;
			}
			if (is_html) {
				v__parser__Parser_error(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("vweb HTML template \""), 0xfe10, {.d_s = path}}, {_SLIT("\" not found"), 0, { .d_c = 0 }}})));
			} else {
				v__parser__Parser_error(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("template file \""), 0xfe10, {.d_s = path}}, {_SLIT("\" not found"), 0, { .d_c = 0 }}})));
			}
			v__ast__ComptimeCall _t10 = (*(err_node));
			return _t10;
		}
	}
	string tmp_fn_name = string__plus(string_replace(p->cur_fn_name, _SLIT("."), _SLIT("__")), int_str(start_pos.pos));
	string v_code = v__parser__Parser_compile_template_file(p, path, tmp_fn_name);
	v__ast__Scope* scope = (v__ast__Scope*)memdup(&(v__ast__Scope){.objects = new_map(sizeof(string), sizeof(v__ast__ScopeObject), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.struct_fields = new_map(sizeof(string), sizeof(v__ast__ScopeStructField), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.parent = p->table->global_scope,.detached_from_parent = 0,.children = __new_array(0, 0, sizeof(v__ast__Scope*)),.start_pos = 0,.end_pos = 0,}, sizeof(v__ast__Scope));
	v__ast__File* file = v__parser__parse_comptime(v_code, p->table, p->pref, scope);
	file->path = tmpl_path;
	for (int _t11 = 0; _t11 < file->stmts.len; ++_t11) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)file->stmts.data)[_t11];
		if ((stmt)._typ == 216 /* v.ast.FnDecl */) {
			if (string__eq((*stmt._v__ast__FnDecl).name,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("main.vweb_tmpl_"), 0xfe10, {.d_s = tmp_fn_name}}, {_SLIT0, 0, { .d_c = 0 }}})))) {
				v__ast__Scope* tmpl_scope = (*stmt._v__ast__FnDecl).scope;
				Map_string_v__ast__ScopeObject _t12 = p->scope->objects;
				int _t14 = _t12.key_values.len;
				for (int _t13 = 0; _t13 < _t14; ++_t13 ) {
					int _t15 = _t12.key_values.len - _t14;
					_t14 = _t12.key_values.len;
					if (_t15 < 0) {
						_t13 = -1;
						continue;
					}
					if (!DenseArray_has_index(&_t12.key_values, _t13)) {continue;}
					v__ast__ScopeObject obj = (*(v__ast__ScopeObject*)DenseArray_value(&_t12.key_values, _t13));
					if ((obj)._typ == 357 /* v.ast.Var */) {
						v__ast__Var v = (*obj._v__ast__Var);
						v.pos = (*stmt._v__ast__FnDecl).body_pos;
						v__ast__Scope_register(tmpl_scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){v.name,v.expr,v.share,v.is_mut,v.is_autofree_tmp,v.is_arg,v.is_auto_deref,v.is_inherited,v.typ,v.orig_type,v.smartcasts,v.pos,.is_used = true,v.is_changed,v.is_or,v.is_tmp,v.is_auto_heap,v.is_stack_obj,}))));
						v.is_used = true;
					}
				}
				break;
			}
		}
	}
	v__ast__ComptimeCall _t16 = (v__ast__ComptimeCall){
		.pos = v__token__Position_extend(start_pos, v__token__Token_position(&p->prev_tok)),
		.has_parens = 0,
		.method_name = method_name,
		.method_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},
		.scope = 0,
		.left = {0},
		.args_var = literal_string_param,
		.is_vweb = true,
		.vweb_tmpl = *file,
		.is_embed = 0,
		.is_env = 0,
		.env_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},
		.is_pkgconfig = 0,
		.left_type = 0,
		.result_type = 0,
		.env_value = (string){.str=(byteptr)"", .is_lit=1},
		.args = __new_array(0, 0, sizeof(v__ast__CallArg)),
		.embed_file = (v__ast__EmbeddedFile){.rpath = (string){.str=(byteptr)"", .is_lit=1},.apath = (string){.str=(byteptr)"", .is_lit=1},.compression_type = (string){.str=(byteptr)"", .is_lit=1},.is_compressed = 0,.bytes = __new_array(0, 0, sizeof(byte)),.len = 0,},
	};
	return _t16;
}

VV_LOCAL_SYMBOL v__ast__ComptimeFor v__parser__Parser_comptime_for(v__parser__Parser* p) {
	v__parser__Parser_next(p);
	v__parser__Parser_check(p, v__token__Kind__key_for);
	v__token__Position var_pos = v__token__Token_position(&p->tok);
	string val_var = v__parser__Parser_check_name(p);
	v__parser__Parser_check(p, v__token__Kind__key_in);
	v__token__Position typ_pos = v__token__Token_position(&p->tok);
	v__ast__Language lang = v__parser__Parser_parse_language(p);
	v__ast__Type typ = v__parser__Parser_parse_any_type(p, lang, false, false);
	typ_pos = v__token__Position_extend(typ_pos, v__token__Token_position(&p->prev_tok));
	v__parser__Parser_check(p, v__token__Kind__dot);
	string for_val = v__parser__Parser_check_name(p);
	v__ast__ComptimeForKind kind = v__ast__ComptimeForKind__methods;
	v__parser__Parser_open_scope(p);
	if (string__eq(for_val, _SLIT("methods"))) {
		v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){.name = val_var,.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.is_auto_deref = 0,.is_inherited = 0,.typ = v__ast__Table_find_type_idx(p->table, _SLIT("FunctionData")),.orig_type = 0,.smartcasts = __new_array(0, 0, sizeof(v__ast__Type)),.pos = var_pos,.is_used = 0,.is_changed = 0,.is_or = 0,.is_tmp = 0,.is_auto_heap = 0,.is_stack_obj = 0,}))));
	} else if (string__eq(for_val, _SLIT("fields"))) {
		v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){.name = val_var,.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.is_auto_deref = 0,.is_inherited = 0,.typ = v__ast__Table_find_type_idx(p->table, _SLIT("FieldData")),.orig_type = 0,.smartcasts = __new_array(0, 0, sizeof(v__ast__Type)),.pos = var_pos,.is_used = 0,.is_changed = 0,.is_or = 0,.is_tmp = 0,.is_auto_heap = 0,.is_stack_obj = 0,}))));
		kind = v__ast__ComptimeForKind__fields;
	} else if (string__eq(for_val, _SLIT("attributes"))) {
		v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){.name = val_var,.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.is_auto_deref = 0,.is_inherited = 0,.typ = v__ast__Table_find_type_idx(p->table, _SLIT("StructAttribute")),.orig_type = 0,.smartcasts = __new_array(0, 0, sizeof(v__ast__Type)),.pos = var_pos,.is_used = 0,.is_changed = 0,.is_or = 0,.is_tmp = 0,.is_auto_heap = 0,.is_stack_obj = 0,}))));
		kind = v__ast__ComptimeForKind__attributes;
	} else {
		v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unknown kind `"), 0xfe10, {.d_s = for_val}}, {_SLIT("`, available are: `methods`, `fields` or `attributes`"), 0, { .d_c = 0 }}})), v__token__Token_position(&p->prev_tok));
		v__ast__ComptimeFor _t1 = (v__ast__ComptimeFor){.val_var = (string){.str=(byteptr)"", .is_lit=1},.stmts = __new_array(0, 0, sizeof(v__ast__Stmt)),.kind = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.typ_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.typ = 0,};
		return _t1;
	}
	v__token__Position spos = v__token__Token_position(&p->tok);
	Array_v__ast__Stmt stmts = v__parser__Parser_parse_block(p);
	v__parser__Parser_close_scope(p);
	v__ast__ComptimeFor _t2 = (v__ast__ComptimeFor){
		.val_var = val_var,
		.stmts = stmts,
		.kind = kind,
		.pos = v__token__Position_extend(spos, v__token__Token_position(&p->tok)),
		.typ_pos = typ_pos,
		.typ = typ,
	};
	return _t2;
}

VV_LOCAL_SYMBOL v__ast__AtExpr v__parser__Parser_at(v__parser__Parser* p) {
	string name = p->tok.lit;
	v__token__AtKind kind = ((string__eq(name, _SLIT("@FN"))) ? (v__token__AtKind__fn_name) : (string__eq(name, _SLIT("@METHOD"))) ? (v__token__AtKind__method_name) : (string__eq(name, _SLIT("@MOD"))) ? (v__token__AtKind__mod_name) : (string__eq(name, _SLIT("@STRUCT"))) ? (v__token__AtKind__struct_name) : (string__eq(name, _SLIT("@FILE"))) ? (v__token__AtKind__file_path) : (string__eq(name, _SLIT("@LINE"))) ? (v__token__AtKind__line_nr) : (string__eq(name, _SLIT("@COLUMN"))) ? (v__token__AtKind__column_nr) : (string__eq(name, _SLIT("@VHASH"))) ? (v__token__AtKind__vhash) : (string__eq(name, _SLIT("@VMOD_FILE"))) ? (v__token__AtKind__vmod_file) : (string__eq(name, _SLIT("@VEXE"))) ? (v__token__AtKind__vexe_path) : (string__eq(name, _SLIT("@VEXEROOT"))) ? (v__token__AtKind__vexeroot_path) : (string__eq(name, _SLIT("@VMODROOT"))) ? (v__token__AtKind__vmodroot_path) : (string__eq(name, _SLIT("@VROOT"))) ? (v__token__AtKind__vroot_path) : (v__token__AtKind__unknown));
	v__parser__Parser_next(p);
	v__ast__AtExpr _t1 = (v__ast__AtExpr){.name = name,.pos = v__token__Token_position(&p->tok),.kind = kind,.val = (string){.str=(byteptr)"", .is_lit=1},};
	return _t1;
}

VV_LOCAL_SYMBOL v__ast__Expr v__parser__Parser_comptime_selector(v__parser__Parser* p, v__ast__Expr left) {
	v__parser__Parser_check(p, v__token__Kind__dollar);
	v__token__Position start_pos = v__token__Token_position(&p->prev_tok);
	if (p->peek_tok.kind == v__token__Kind__lpar) {
		v__token__Position method_pos = v__token__Token_position(&p->tok);
		string method_name = v__parser__Parser_check_name(p);
		v__parser__Parser_mark_var_as_used(p, method_name);
		v__parser__Parser_check(p, v__token__Kind__lpar);
		Array_v__ast__CallArg args = v__parser__Parser_call_args(p);
		v__parser__Parser_check(p, v__token__Kind__rpar);
		if (p->tok.kind == v__token__Kind__key_orelse) {
			v__parser__Parser_check(p, v__token__Kind__key_orelse);
			v__parser__Parser_check(p, v__token__Kind__lcbr);
		}
		v__ast__Expr _t1 = v__ast__ComptimeCall_to_sumtype_v__ast__Expr(ADDR(v__ast__ComptimeCall, ((v__ast__ComptimeCall){
			.pos = v__token__Position_extend(start_pos, v__token__Token_position(&p->prev_tok)),
			.has_parens = 0,
			.method_name = method_name,
			.method_pos = method_pos,
			.scope = p->scope,
			.left = left,
			.args_var = _SLIT(""),
			.is_vweb = 0,
			.vweb_tmpl = (v__ast__File){.nr_lines = 0,.nr_bytes = 0,.mod = (v__ast__Module){.name = (string){.str=(byteptr)"", .is_lit=1},.short_name = (string){.str=(byteptr)"", .is_lit=1},.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.name_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.is_skipped = 0,},.global_scope = 0,.is_test = 0,.is_generated = 0,.path = (string){.str=(byteptr)"", .is_lit=1},.path_base = (string){.str=(byteptr)"", .is_lit=1},.scope = 0,.stmts = __new_array(0, 0, sizeof(v__ast__Stmt)),.imports = __new_array(0, 0, sizeof(v__ast__Import)),.auto_imports = __new_array(0, 0, sizeof(string)),.embedded_files = __new_array(0, 0, sizeof(v__ast__EmbeddedFile)),.imported_symbols = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.errors = __new_array(0, 0, sizeof(v__errors__Error)),.warnings = __new_array(0, 0, sizeof(v__errors__Warning)),.notices = __new_array(0, 0, sizeof(v__errors__Notice)),.generic_fns = __new_array(0, 0, sizeof(v__ast__FnDecl*)),.global_labels = __new_array(0, 0, sizeof(string)),},
			.is_embed = 0,
			.is_env = 0,
			.env_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},
			.is_pkgconfig = 0,
			.left_type = 0,
			.result_type = 0,
			.env_value = (string){.str=(byteptr)"", .is_lit=1},
			.args = args,
			.embed_file = (v__ast__EmbeddedFile){.rpath = (string){.str=(byteptr)"", .is_lit=1},.apath = (string){.str=(byteptr)"", .is_lit=1},.compression_type = (string){.str=(byteptr)"", .is_lit=1},.is_compressed = 0,.bytes = __new_array(0, 0, sizeof(byte)),.len = 0,},
		})));
		return _t1;
	}
	bool has_parens = false;
	if (p->tok.kind == v__token__Kind__lpar) {
		v__parser__Parser_check(p, v__token__Kind__lpar);
		has_parens = true;
	} else {
		v__parser__Parser_warn_with_pos(p, _SLIT("use brackets instead e.g. `s.$(field.name)` - run vfmt"), v__token__Token_position(&p->tok));
	}
	v__ast__Expr expr = v__parser__Parser_expr(p, 0);
	if (has_parens) {
		v__parser__Parser_check(p, v__token__Kind__rpar);
	}
	v__ast__Expr _t2 = v__ast__ComptimeSelector_to_sumtype_v__ast__Expr(ADDR(v__ast__ComptimeSelector, ((v__ast__ComptimeSelector){.has_parens = has_parens,.left = left,.field_expr = expr,.pos = v__token__Position_extend(start_pos, v__token__Token_position(&p->prev_tok)),.left_type = 0,.typ = 0,})));
	return _t2;
}

VV_LOCAL_SYMBOL v__ast__ArrayInit v__parser__Parser_array_init(v__parser__Parser* p) {
	v__token__Position first_pos = v__token__Token_position(&p->tok);
	v__token__Position last_pos = v__token__Token_position(&p->tok);
	v__parser__Parser_check(p, v__token__Kind__lsbr);
	v__ast__Type array_type = _const_v__ast__void_type;
	v__ast__Type elem_type = _const_v__ast__void_type;
	v__token__Position elem_type_pos = first_pos;
	Array_v__ast__Expr exprs = __new_array_with_default(0, 0, sizeof(v__ast__Expr), 0);
	Array_Array_v__ast__Comment ecmnts = __new_array_with_default(0, 0, sizeof(Array_v__ast__Comment), 0);
	Array_v__ast__Comment pre_cmnts = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	bool is_fixed = false;
	bool has_val = false;
	bool has_type = false;
	bool has_default = false;
	bool has_it = false;
	v__ast__Expr default_expr = v__ast__empty_expr();
	if (p->tok.kind == v__token__Kind__rsbr) {
		last_pos = v__token__Token_position(&p->tok);
		int line_nr = p->tok.line_nr;
		v__parser__Parser_next(p);
		if ((p->tok.kind == v__token__Kind__name || p->tok.kind == v__token__Kind__amp || p->tok.kind == v__token__Kind__lsbr || p->tok.kind == v__token__Kind__key_shared) && p->tok.line_nr == line_nr) {
			elem_type_pos = v__token__Token_position(&p->tok);
			elem_type = v__parser__Parser_parse_type(p);
			int idx = v__ast__Table_find_or_register_array(p->table, elem_type);
			if (v__ast__Type_has_flag(elem_type, v__ast__TypeFlag__generic)) {
				array_type = v__ast__Type_set_flag(v__ast__new_type(idx), v__ast__TypeFlag__generic);
			} else {
				array_type = v__ast__new_type(idx);
			}
			has_type = true;
		}
		last_pos = v__token__Token_position(&p->tok);
	} else {
		bool old_inside_array_lit = p->inside_array_lit;
		p->inside_array_lit = true;
		pre_cmnts = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,});
		for (int i = 0; !(p->tok.kind == v__token__Kind__rsbr || p->tok.kind == v__token__Kind__eof); i++) {
			array_push((array*)&exprs, _MOV((v__ast__Expr[]){ v__parser__Parser_expr(p, 0) }));
			array_push((array*)&ecmnts, _MOV((Array_v__ast__Comment[]){ v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}) }));
			if (p->tok.kind == v__token__Kind__comma) {
				v__parser__Parser_next(p);
			}
			_PUSH_MANY(&(*(Array_v__ast__Comment*)array_last(ecmnts)), (v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,})), _t3, Array_v__ast__Comment);
		}
		p->inside_array_lit = old_inside_array_lit;
		int line_nr = p->tok.line_nr;
		last_pos = v__token__Token_position(&p->tok);
		v__parser__Parser_check(p, v__token__Kind__rsbr);
		if (exprs.len == 1 && (p->tok.kind == v__token__Kind__name || p->tok.kind == v__token__Kind__amp || p->tok.kind == v__token__Kind__lsbr) && p->tok.line_nr == line_nr) {
			elem_type = v__parser__Parser_parse_type(p);
			last_pos = v__token__Token_position(&p->tok);
			is_fixed = true;
			if (p->tok.kind == v__token__Kind__lcbr) {
				v__parser__Parser_next(p);
				if (p->tok.kind != v__token__Kind__rcbr) {
					v__token__Position pos = v__token__Token_position(&p->tok);
					string n = v__parser__Parser_check_name(p);
					if (!string__eq(n, _SLIT("init"))) {
						v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("expected `init:`, not `"), 0xfe10, {.d_s = n}}, {_SLIT("`"), 0, { .d_c = 0 }}})), pos);
						v__ast__ArrayInit _t4 = (v__ast__ArrayInit){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.elem_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.exprs = __new_array(0, 0, sizeof(v__ast__Expr)),.ecmnts = __new_array(0, 0, sizeof(Array_v__ast__Comment)),.pre_cmnts = __new_array(0, 0, sizeof(v__ast__Comment)),.is_fixed = 0,.has_val = 0,.mod = (string){.str=(byteptr)"", .is_lit=1},.len_expr = {0},.cap_expr = {0},.default_expr = {0},.has_len = 0,.has_cap = 0,.has_default = 0,.has_it = 0,.expr_types = __new_array(0, 0, sizeof(v__ast__Type)),.elem_type = 0,.typ = 0,};
						return _t4;
					}
					v__parser__Parser_check(p, v__token__Kind__colon);
					v__parser__Parser_open_scope(p);
					has_default = true;
					v__parser__Parser_scope_register_it_as_index(p);
					default_expr = v__parser__Parser_expr(p, 0);
					bool _t5; /* if prepend */
					Option_v__ast__Var_ptr _t6;
					if (_t6 = v__ast__Scope_find_var(p->scope, _SLIT("it")), _t6.state == 0) {
						v__ast__Var* var = *(v__ast__Var**)_t6.data;
						v__ast__Var* variable = var;
						bool is_used = variable->is_used;
						variable->is_used = true;
						_t5 = is_used;
					} else {
						IError err = _t6.err;
						_t5 = false;
					}
					has_it =  _t5;
					v__parser__Parser_close_scope(p);
				}
				last_pos = v__token__Token_position(&p->tok);
				v__parser__Parser_check(p, v__token__Kind__rcbr);
			} else {
				v__parser__Parser_warn_with_pos(p, _SLIT("use e.g. `x := [1]Type{}` instead of `x := [1]Type`"), v__token__Position_extend(first_pos, last_pos));
			}
		} else {
			if (p->tok.kind == v__token__Kind__not) {
				last_pos = v__token__Token_position(&p->tok);
				is_fixed = true;
				has_val = true;
				v__parser__Parser_next(p);
			}
			if (p->tok.kind == v__token__Kind__not && p->tok.line_nr == p->prev_tok.line_nr) {
				last_pos = v__token__Token_position(&p->tok);
				v__parser__Parser_error_with_pos(p, _SLIT("use e.g. `[1, 2, 3]!` instead of `[1, 2, 3]!!`"), last_pos);
				v__parser__Parser_next(p);
			}
		}
	}
	if (exprs.len == 0 && p->tok.kind != v__token__Kind__lcbr && has_type) {
		if (!p->pref->is_fmt) {
			v__parser__Parser_warn_with_pos(p, _SLIT("use `x := []Type{}` instead of `x := []Type`"), v__token__Position_extend(first_pos, last_pos));
		}
	}
	bool has_len = false;
	bool has_cap = false;
	v__ast__Expr len_expr = v__ast__empty_expr();
	v__ast__Expr cap_expr = v__ast__empty_expr();
	if (p->tok.kind == v__token__Kind__lcbr && exprs.len == 0 && !v__ast__Type_alias_eq(array_type, _const_v__ast__void_type)) {
		v__parser__Parser_next(p);
		for (;;) {
			if (!(p->tok.kind != v__token__Kind__rcbr)) break;
			string key = v__parser__Parser_check_name(p);
			v__parser__Parser_check(p, v__token__Kind__colon);

			if (string__eq(key, _SLIT("len"))) {
				has_len = true;
				len_expr = v__parser__Parser_expr(p, 0);
			}
			else if (string__eq(key, _SLIT("cap"))) {
				has_cap = true;
				cap_expr = v__parser__Parser_expr(p, 0);
			}
			else if (string__eq(key, _SLIT("init"))) {
				v__parser__Parser_open_scope(p);
				has_default = true;
				v__parser__Parser_scope_register_it_as_index(p);
				default_expr = v__parser__Parser_expr(p, 0);
				bool _t7; /* if prepend */
				Option_v__ast__Var_ptr _t8;
				if (_t8 = v__ast__Scope_find_var(p->scope, _SLIT("it")), _t8.state == 0) {
					v__ast__Var* var = *(v__ast__Var**)_t8.data;
					v__ast__Var* variable = var;
					bool is_used = variable->is_used;
					variable->is_used = true;
					_t7 = is_used;
				} else {
					IError err = _t8.err;
					_t7 = false;
				}
				has_it =  _t7;
				v__parser__Parser_close_scope(p);
			}
			else {
				v__parser__Parser_error(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("wrong field `"), 0xfe10, {.d_s = key}}, {_SLIT("`, expecting `len`, `cap`, or `init`"), 0, { .d_c = 0 }}})));
				v__ast__ArrayInit _t9 = (v__ast__ArrayInit){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.elem_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.exprs = __new_array(0, 0, sizeof(v__ast__Expr)),.ecmnts = __new_array(0, 0, sizeof(Array_v__ast__Comment)),.pre_cmnts = __new_array(0, 0, sizeof(v__ast__Comment)),.is_fixed = 0,.has_val = 0,.mod = (string){.str=(byteptr)"", .is_lit=1},.len_expr = {0},.cap_expr = {0},.default_expr = {0},.has_len = 0,.has_cap = 0,.has_default = 0,.has_it = 0,.expr_types = __new_array(0, 0, sizeof(v__ast__Type)),.elem_type = 0,.typ = 0,};
				return _t9;
			};
			if (p->tok.kind != v__token__Kind__rcbr) {
				v__parser__Parser_check(p, v__token__Kind__comma);
			}
		}
		v__parser__Parser_check(p, v__token__Kind__rcbr);
	}
	v__token__Position pos = v__token__Position_extend_with_last_line(first_pos, last_pos, p->prev_tok.line_nr);
	v__ast__ArrayInit _t10 = (v__ast__ArrayInit){
		.pos = pos,
		.elem_type_pos = elem_type_pos,
		.exprs = exprs,
		.ecmnts = ecmnts,
		.pre_cmnts = pre_cmnts,
		.is_fixed = is_fixed,
		.has_val = has_val,
		.mod = p->mod,
		.len_expr = len_expr,
		.cap_expr = cap_expr,
		.default_expr = default_expr,
		.has_len = has_len,
		.has_cap = has_cap,
		.has_default = has_default,
		.has_it = has_it,
		.expr_types = __new_array(0, 0, sizeof(v__ast__Type)),
		.elem_type = elem_type,
		.typ = array_type,
	};
	return _t10;
}

VV_LOCAL_SYMBOL v__ast__MapInit v__parser__Parser_map_init(v__parser__Parser* p) {
	v__token__Position first_pos = v__token__Token_position(&p->prev_tok);
	Array_v__ast__Expr keys = __new_array_with_default(0, 0, sizeof(v__ast__Expr), 0);
	Array_v__ast__Expr vals = __new_array_with_default(0, 0, sizeof(v__ast__Expr), 0);
	Array_Array_v__ast__Comment comments = __new_array_with_default(0, 0, sizeof(Array_v__ast__Comment), 0);
	Array_v__ast__Comment pre_cmnts = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,});
	for (;;) {
		if (!(!(p->tok.kind == v__token__Kind__rcbr || p->tok.kind == v__token__Kind__eof))) break;
		v__ast__Expr key = v__parser__Parser_expr(p, 0);
		array_push((array*)&keys, _MOV((v__ast__Expr[]){ key }));
		v__parser__Parser_check(p, v__token__Kind__colon);
		v__ast__Expr val = v__parser__Parser_expr(p, 0);
		array_push((array*)&vals, _MOV((v__ast__Expr[]){ val }));
		if (p->tok.kind == v__token__Kind__comma) {
			v__parser__Parser_next(p);
		}
		array_push((array*)&comments, _MOV((Array_v__ast__Comment[]){ v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}) }));
	}
	v__ast__MapInit _t4 = (v__ast__MapInit){.pos = v__token__Position_extend_with_last_line(first_pos, v__token__Token_position(&p->tok), p->tok.line_nr),.keys = keys,.vals = vals,.comments = comments,.pre_cmnts = pre_cmnts,.typ = 0,.key_type = 0,.value_type = 0,};
	return _t4;
}

VV_LOCAL_SYMBOL void v__parser__Parser_scope_register_it_as_index(v__parser__Parser* p) {
	map_set(&p->scope->objects, &(string[]){_SLIT("it")}, &(v__ast__ScopeObject[]) { v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){.name = _SLIT("it"),.expr = {0},.share = 0,.is_mut = false,.is_autofree_tmp = 0,.is_arg = 0,.is_auto_deref = 0,.is_inherited = 0,.typ = _const_v__ast__int_type,.orig_type = 0,.smartcasts = __new_array(0, 0, sizeof(v__ast__Type)),.pos = v__token__Token_position(&p->tok),.is_used = false,.is_changed = 0,.is_or = 0,.is_tmp = 0,.is_auto_heap = 0,.is_stack_obj = 0,}))) });
}

v__ast__Expr v__parser__Parser_expr(v__parser__Parser* p, int precedence) {
	Option_v__ast__Expr _t2 = v__parser__Parser_check_expr(p, precedence);
	if (_t2.state != 0) { /*or block*/ 
		IError err = _t2.err;
		*(v__ast__Expr*) _t2.data = v__ast__NodeError_to_sumtype_v__ast__Expr(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("invalid expression: unexpected "), 0xfe10, {.d_s = v__token__Token_str(p->tok)}}, {_SLIT0, 0, { .d_c = 0 }}})), v__token__Token_position(&p->tok)))));
	}
	
 	v__ast__Expr _t1 =  (*(v__ast__Expr*)_t2.data);
	return _t1;
}

Option_v__ast__Expr v__parser__Parser_check_expr(v__parser__Parser* p, int precedence) {
bool v__parser__Parser_check_expr_defer_0 = false;
bool inside_array_lit;
	;
	v__ast__Expr node = v__ast__empty_expr();
	bool is_stmt_ident = p->is_stmt_ident;
	p->is_stmt_ident = false;
	if (!p->pref->is_fmt) {
		v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,});
	}
	inside_array_lit = p->inside_array_lit;
	p->inside_array_lit = false;
	v__parser__Parser_check_expr_defer_0 = true;
	switch (p->tok.kind) {
		case v__token__Kind__key_mut: 
		case v__token__Kind__key_shared: 
		case v__token__Kind__key_atomic: 
		case v__token__Kind__key_static: 
		case v__token__Kind__key_volatile: 
			{
				v__ast__Ident ident = v__parser__Parser_parse_ident(p, v__ast__Language__v);
				node = v__ast__Ident_to_sumtype_v__ast__Expr(&ident);
				if (p->inside_defer) {
					bool _t1 = false;
					Array_v__ast__Ident _t1_orig = p->defer_vars;
					int _t1_len = _t1_orig.len;
					for (int _t2 = 0; _t2 < _t1_len; ++_t2) {
						v__ast__Ident it = ((v__ast__Ident*) _t1_orig.data)[_t2];
						if (string__eq(it.name, ident.name) && string__eq(it.mod, ident.mod)) {
							_t1 = true;
							break;
						}
					}
					if (!_t1 && !string__eq(ident.name, _SLIT("err"))) {
						array_push((array*)&p->defer_vars, _MOV((v__ast__Ident[]){ ident }));
					}
				}
				p->is_stmt_ident = is_stmt_ident;
			} break;
		case v__token__Kind__name: 
		case v__token__Kind__question: 
			{
				if (string__eq(p->tok.lit, _SLIT("sql")) && p->peek_tok.kind == v__token__Kind__name) {
					p->inside_match = true;
					node = v__parser__Parser_sql_expr(p);
					p->inside_match = false;
				} else if (string__eq(p->tok.lit, _SLIT("map")) && p->peek_tok.kind == v__token__Kind__lcbr && !(p->builtin_mod && (string__eq(p->file_base, _SLIT("map.v")) || string__eq(p->file_base, _SLIT("map_d_gcboehm_opt.v"))))) {
					v__parser__Parser_warn_with_pos(p, _SLIT("deprecated map syntax, use syntax like `{'age': 20}`"), v__token__Token_position(&p->tok));
					v__parser__Parser_next(p);
					v__parser__Parser_next(p);
					node = v__ast__MapInit_to_sumtype_v__ast__Expr(ADDR(v__ast__MapInit, (v__parser__Parser_map_init(p))));
					v__parser__Parser_check(p, v__token__Kind__rcbr);
				} else {
					if (p->inside_if && v__parser__Parser_is_generic_name(p) && p->peek_tok.kind != v__token__Kind__dot) {
						p->expecting_type = true;
					}
					node = v__parser__Parser_name_expr(p);
					p->is_stmt_ident = is_stmt_ident;
				}
			} break;
		case v__token__Kind__string: 
			{
				node = v__parser__Parser_string_expr(p);
			} break;
		case v__token__Kind__comment: 
			{
				node = v__ast__Comment_to_sumtype_v__ast__Expr(ADDR(v__ast__Comment, (v__parser__Parser_comment(p))));
				Option_v__ast__Expr _t4;
				opt_ok(&(v__ast__Expr[]) { node }, (Option*)(&_t4), sizeof(v__ast__Expr));
				// Defer begin
				if (v__parser__Parser_check_expr_defer_0) {
					p->inside_array_lit = inside_array_lit;
				}
				// Defer end
				return _t4;
			} break;
		case v__token__Kind__dot: 
			{
				node = v__ast__EnumVal_to_sumtype_v__ast__Expr(ADDR(v__ast__EnumVal, (v__parser__Parser_enum_val(p))));
			} break;
		case v__token__Kind__at: 
			{
				node = v__ast__AtExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__AtExpr, (v__parser__Parser_at(p))));
			} break;
		case v__token__Kind__dollar: 
			{

				if (p->peek_tok.kind == (v__token__Kind__name)) {
					Option_v__ast__Expr _t5;
					opt_ok(&(v__ast__Expr[]) { v__ast__ComptimeCall_to_sumtype_v__ast__Expr(ADDR(v__ast__ComptimeCall, (v__parser__Parser_comptime_call(p)))) }, (Option*)(&_t5), sizeof(v__ast__Expr));
					// Defer begin
					if (v__parser__Parser_check_expr_defer_0) {
						p->inside_array_lit = inside_array_lit;
					}
					// Defer end
					return _t5;
				}
				else if (p->peek_tok.kind == (v__token__Kind__key_if)) {
					Option_v__ast__Expr _t6;
					opt_ok(&(v__ast__Expr[]) { v__ast__IfExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__IfExpr, (v__parser__Parser_if_expr(p, true)))) }, (Option*)(&_t6), sizeof(v__ast__Expr));
					// Defer begin
					if (v__parser__Parser_check_expr_defer_0) {
						p->inside_array_lit = inside_array_lit;
					}
					// Defer end
					return _t6;
				}
				else {
					Option_v__ast__Expr _t7;
					opt_ok(&(v__ast__Expr[]) { v__ast__NodeError_to_sumtype_v__ast__Expr(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _SLIT("unexpected `$`"), v__token__Token_position(&p->peek_tok))))) }, (Option*)(&_t7), sizeof(v__ast__Expr));
					// Defer begin
					if (v__parser__Parser_check_expr_defer_0) {
						p->inside_array_lit = inside_array_lit;
					}
					// Defer end
					return _t7;
				};
			} break;
		case v__token__Kind__chartoken: 
			{
				node = v__ast__CharLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__CharLiteral, ((v__ast__CharLiteral){.val = p->tok.lit,.pos = v__token__Token_position(&p->tok),})));
				v__parser__Parser_next(p);
			} break;
		case v__token__Kind__amp: 
		case v__token__Kind__mul: 
		case v__token__Kind__not: 
		case v__token__Kind__bit_not: 
		case v__token__Kind__arrow: 
			{
				node = v__parser__Parser_prefix_expr(p);
			} break;
		case v__token__Kind__minus: 
			{
				if (p->peek_tok.kind == v__token__Kind__number) {
					node = v__parser__Parser_parse_number_literal(p);
				} else {
					node = v__parser__Parser_prefix_expr(p);
				}
			} break;
		case v__token__Kind__key_go: 
			{
				v__ast__GoExpr go_expr = v__parser__Parser_go_expr(p);
				go_expr.is_expr = true;
				node = v__ast__GoExpr_to_sumtype_v__ast__Expr(&go_expr);
			} break;
		case v__token__Kind__key_true: 
		case v__token__Kind__key_false: 
			{
				node = v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, ((v__ast__BoolLiteral){.val = p->tok.kind == v__token__Kind__key_true,.pos = v__token__Token_position(&p->tok),})));
				v__parser__Parser_next(p);
			} break;
		case v__token__Kind__key_match: 
			{
				node = v__ast__MatchExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__MatchExpr, (v__parser__Parser_match_expr(p))));
			} break;
		case v__token__Kind__key_select: 
			{
				node = v__ast__SelectExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__SelectExpr, (v__parser__Parser_select_expr(p))));
			} break;
		case v__token__Kind__number: 
			{
				node = v__parser__Parser_parse_number_literal(p);
			} break;
		case v__token__Kind__lpar: 
			{
				v__token__Position pos = v__token__Token_position(&p->tok);
				v__parser__Parser_check(p, v__token__Kind__lpar);
				node = v__parser__Parser_expr(p, 0);
				v__parser__Parser_check(p, v__token__Kind__rpar);
				node = v__ast__ParExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__ParExpr, ((v__ast__ParExpr){.expr = node,.pos = v__token__Position_extend(pos, v__token__Token_position(&p->prev_tok)),})));
			} break;
		case v__token__Kind__key_if: 
			{
				node = v__ast__IfExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__IfExpr, (v__parser__Parser_if_expr(p, false))));
			} break;
		case v__token__Kind__key_unsafe: 
			{
				v__token__Position pos = v__token__Token_position(&p->tok);
				v__parser__Parser_next(p);
				if (p->inside_unsafe) {
					Option_v__ast__Expr _t8;
					opt_ok(&(v__ast__Expr[]) { v__ast__NodeError_to_sumtype_v__ast__Expr(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _SLIT("already inside `unsafe` block"), pos)))) }, (Option*)(&_t8), sizeof(v__ast__Expr));
					// Defer begin
					if (v__parser__Parser_check_expr_defer_0) {
						p->inside_array_lit = inside_array_lit;
					}
					// Defer end
					return _t8;
				}
				p->inside_unsafe = true;
				v__parser__Parser_check(p, v__token__Kind__lcbr);
				v__ast__Expr e = v__parser__Parser_expr(p, 0);
				v__parser__Parser_check(p, v__token__Kind__rcbr);
				v__token__Position_update_last_line(&pos, p->prev_tok.line_nr);
				node = v__ast__UnsafeExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__UnsafeExpr, ((v__ast__UnsafeExpr){.expr = e,.pos = pos,})));
				p->inside_unsafe = false;
			} break;
		case v__token__Kind__key_lock: 
		case v__token__Kind__key_rlock: 
			{
				node = v__ast__LockExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__LockExpr, (v__parser__Parser_lock_expr(p))));
			} break;
		case v__token__Kind__lsbr: 
			{
				if (p->expecting_type) {
					node = v__parser__Parser_name_expr(p);
				} else if (p->is_amp && p->peek_tok.kind == v__token__Kind__rsbr && v__parser__Parser_peek_token(p, 3).kind != v__token__Kind__lcbr) {
					v__token__Position pos = v__token__Token_position(&p->tok);
					v__ast__Type typ = v__parser__Parser_parse_type(p);
					string typname = v__ast__Table_sym(p->table, typ)->name;
					v__parser__Parser_check(p, v__token__Kind__lpar);
					v__ast__Expr expr = v__parser__Parser_expr(p, 0);
					v__parser__Parser_check(p, v__token__Kind__rpar);
					node = v__ast__CastExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__CastExpr, ((v__ast__CastExpr){.arg = {0},.typ = typ,.expr = expr,.typname = typname,.expr_type = 0,.has_arg = 0,.pos = pos,})));
				} else {
					node = v__ast__ArrayInit_to_sumtype_v__ast__Expr(ADDR(v__ast__ArrayInit, (v__parser__Parser_array_init(p))));
				}
			} break;
		case v__token__Kind__key_none: 
			{
				v__token__Position pos = v__token__Token_position(&p->tok);
				v__parser__Parser_next(p);
				node = v__ast__None_to_sumtype_v__ast__Expr(ADDR(v__ast__None, ((v__ast__None){.pos = pos,})));
			} break;
		case v__token__Kind__key_sizeof: 
		case v__token__Kind__key_isreftype: 
			{
				bool is_reftype = p->tok.kind == v__token__Kind__key_isreftype;
				v__parser__Parser_next(p);
				v__parser__Parser_check(p, v__token__Kind__lpar);
				v__token__Position pos = v__token__Token_position(&p->tok);
				bool is_known_var = v__parser__Parser_mark_var_as_used(p, p->tok.lit) || v__ast__Scope_known_const(p->table->global_scope, string__plus(string__plus(p->mod, _SLIT(".")), p->tok.lit));
				bool is_type = v__parser__Parser_known_import(p, p->tok.lit) || v__token__Kind_is_start_of_type(p->tok.kind) || (p->tok.lit.len > 0 && byte_is_capital(string_at(p->tok.lit, 0)));
				if (is_known_var || !is_type) {
					v__ast__Expr expr = v__parser__Parser_expr(p, 0);
					if (is_reftype) {
						node = v__ast__IsRefType_to_sumtype_v__ast__Expr(ADDR(v__ast__IsRefType, ((v__ast__IsRefType){.is_type = false,.expr = expr,.pos = pos,.typ = 0,})));
					} else {
						node = v__ast__SizeOf_to_sumtype_v__ast__Expr(ADDR(v__ast__SizeOf, ((v__ast__SizeOf){.is_type = false,.expr = expr,.pos = pos,.typ = 0,})));
					}
				} else {
					if (p->tok.kind == v__token__Kind__name) {
						v__parser__Parser_register_used_import(p, p->tok.lit);
					}
					string save_expr_mod = p->expr_mod;
					p->expr_mod = _SLIT("");
					v__ast__Type arg_type = v__parser__Parser_parse_type(p);
					p->expr_mod = save_expr_mod;
					if (is_reftype) {
						node = v__ast__IsRefType_to_sumtype_v__ast__Expr(ADDR(v__ast__IsRefType, ((v__ast__IsRefType){.is_type = true,.expr = {0},.pos = pos,.typ = arg_type,})));
					} else {
						node = v__ast__SizeOf_to_sumtype_v__ast__Expr(ADDR(v__ast__SizeOf, ((v__ast__SizeOf){.is_type = true,.expr = {0},.pos = pos,.typ = arg_type,})));
					}
				}
				v__parser__Parser_check(p, v__token__Kind__rpar);
			} break;
		case v__token__Kind__key_typeof: 
			{
				v__token__Position spos = v__token__Token_position(&p->tok);
				v__parser__Parser_next(p);
				v__parser__Parser_check(p, v__token__Kind__lpar);
				v__ast__Expr expr = v__parser__Parser_expr(p, 0);
				v__parser__Parser_check(p, v__token__Kind__rpar);
				if (p->tok.kind != v__token__Kind__dot && p->tok.line_nr == p->prev_tok.line_nr) {
					v__parser__Parser_warn_with_pos(p, _SLIT("use e.g. `typeof(expr).name` or `sum_type_instance.type_name()` instead"), spos);
				}
				node = v__ast__TypeOf_to_sumtype_v__ast__Expr(ADDR(v__ast__TypeOf, ((v__ast__TypeOf){.expr = expr,.pos = v__token__Position_extend(spos, v__token__Token_position(&p->tok)),.expr_type = 0,})));
			} break;
		case v__token__Kind__key_dump: 
			{
				v__token__Position spos = v__token__Token_position(&p->tok);
				v__parser__Parser_next(p);
				v__parser__Parser_check(p, v__token__Kind__lpar);
				v__ast__Expr expr = v__parser__Parser_expr(p, 0);
				v__parser__Parser_check(p, v__token__Kind__rpar);
				node = v__ast__DumpExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__DumpExpr, ((v__ast__DumpExpr){.expr = expr,.pos = v__token__Position_extend(spos, v__token__Token_position(&p->tok)),.expr_type = 0,.cname = (string){.str=(byteptr)"", .is_lit=1},})));
			} break;
		case v__token__Kind__key_offsetof: 
			{
				v__token__Position pos = v__token__Token_position(&p->tok);
				v__parser__Parser_next(p);
				v__parser__Parser_check(p, v__token__Kind__lpar);
				v__ast__Type st = v__parser__Parser_parse_type(p);
				v__parser__Parser_check(p, v__token__Kind__comma);
				if (p->tok.kind != v__token__Kind__name) {
					Option_v__ast__Expr _t9;
					opt_ok(&(v__ast__Expr[]) { v__ast__NodeError_to_sumtype_v__ast__Expr(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unexpected `"), 0xfe10, {.d_s = p->tok.lit}}, {_SLIT("`, expecting struct field"), 0, { .d_c = 0 }}})), v__token__Token_position(&p->tok))))) }, (Option*)(&_t9), sizeof(v__ast__Expr));
					// Defer begin
					if (v__parser__Parser_check_expr_defer_0) {
						p->inside_array_lit = inside_array_lit;
					}
					// Defer end
					return _t9;
				}
				string field = p->tok.lit;
				v__parser__Parser_next(p);
				v__parser__Parser_check(p, v__token__Kind__rpar);
				node = v__ast__OffsetOf_to_sumtype_v__ast__Expr(ADDR(v__ast__OffsetOf, ((v__ast__OffsetOf){.struct_type = st,.field = field,.pos = pos,})));
			} break;
		case v__token__Kind__key_likely: 
		case v__token__Kind__key_unlikely: 
			{
				bool is_likely = p->tok.kind == v__token__Kind__key_likely;
				v__parser__Parser_next(p);
				v__parser__Parser_check(p, v__token__Kind__lpar);
				v__token__Position lpos = v__token__Token_position(&p->tok);
				v__ast__Expr expr = v__parser__Parser_expr(p, 0);
				v__parser__Parser_check(p, v__token__Kind__rpar);
				node = v__ast__Likely_to_sumtype_v__ast__Expr(ADDR(v__ast__Likely, ((v__ast__Likely){.expr = expr,.pos = lpos,.is_likely = is_likely,})));
			} break;
		case v__token__Kind__lcbr: 
			{
				v__parser__Parser_next(p);
				node = v__ast__MapInit_to_sumtype_v__ast__Expr(ADDR(v__ast__MapInit, (v__parser__Parser_map_init(p))));
				v__parser__Parser_check(p, v__token__Kind__rcbr);
			} break;
		case v__token__Kind__key_fn: 
			{
				if (p->expecting_type) {
					v__token__Position start_pos = v__token__Token_position(&p->tok);
					Option_v__ast__Expr _t10;
					opt_ok(&(v__ast__Expr[]) { v__ast__TypeNode_to_sumtype_v__ast__Expr(ADDR(v__ast__TypeNode, ((v__ast__TypeNode){.typ = v__parser__Parser_parse_type(p),.pos = v__token__Position_extend(start_pos, v__token__Token_position(&p->prev_tok)),}))) }, (Option*)(&_t10), sizeof(v__ast__Expr));
					// Defer begin
					if (v__parser__Parser_check_expr_defer_0) {
						p->inside_array_lit = inside_array_lit;
					}
					// Defer end
					return _t10;
				} else {
					node = v__ast__AnonFn_to_sumtype_v__ast__Expr(ADDR(v__ast__AnonFn, (v__parser__Parser_anon_fn(p))));
					if (p->tok.kind == v__token__Kind__lpar) {
						v__parser__Parser_next(p);
						v__token__Position pos = v__token__Token_position(&p->tok);
						Array_v__ast__CallArg args = v__parser__Parser_call_args(p);
						v__parser__Parser_check(p, v__token__Kind__rpar);
						node = v__ast__CallExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__CallExpr, ((v__ast__CallExpr){.pos = pos,.name_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.mod = (string){.str=(byteptr)"", .is_lit=1},.name = _SLIT("anon"),.is_method = 0,.is_field = 0,.is_keep_alive = 0,.is_noreturn = 0,.is_ctor_new = 0,.args = args,.expected_arg_types = __new_array(0, 0, sizeof(v__ast__Type)),.language = 0,.or_block = (v__ast__OrExpr){.stmts = __new_array(0, 0, sizeof(v__ast__Stmt)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},},.left = node,.left_type = 0,.receiver_type = 0,.return_type = 0,.should_be_skipped = 0,.concrete_types = __new_array(0, 0, sizeof(v__ast__Type)),.concrete_list_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.free_receiver = 0,.scope = p->scope,.from_embed_types = __new_array(0, 0, sizeof(v__ast__Type)),.comments = __new_array(0, 0, sizeof(v__ast__Comment)),})));
					}
					Option_v__ast__Expr _t11;
					opt_ok(&(v__ast__Expr[]) { node }, (Option*)(&_t11), sizeof(v__ast__Expr));
					// Defer begin
					if (v__parser__Parser_check_expr_defer_0) {
						p->inside_array_lit = inside_array_lit;
					}
					// Defer end
					return _t11;
				}
			} break;
		case v__token__Kind__unknown:
		case v__token__Kind__eof:
		case v__token__Kind__str_inter:
		case v__token__Kind__plus:
		case v__token__Kind__div:
		case v__token__Kind__mod:
		case v__token__Kind__xor:
		case v__token__Kind__pipe:
		case v__token__Kind__inc:
		case v__token__Kind__dec:
		case v__token__Kind__and:
		case v__token__Kind__logical_or:
		case v__token__Kind__comma:
		case v__token__Kind__semicolon:
		case v__token__Kind__colon:
		case v__token__Kind__hash:
		case v__token__Kind__str_dollar:
		case v__token__Kind__left_shift:
		case v__token__Kind__right_shift:
		case v__token__Kind__unsigned_right_shift:
		case v__token__Kind__not_in:
		case v__token__Kind__not_is:
		case v__token__Kind__assign:
		case v__token__Kind__decl_assign:
		case v__token__Kind__plus_assign:
		case v__token__Kind__minus_assign:
		case v__token__Kind__div_assign:
		case v__token__Kind__mult_assign:
		case v__token__Kind__xor_assign:
		case v__token__Kind__mod_assign:
		case v__token__Kind__or_assign:
		case v__token__Kind__and_assign:
		case v__token__Kind__right_shift_assign:
		case v__token__Kind__left_shift_assign:
		case v__token__Kind__unsigned_right_shift_assign:
		case v__token__Kind__rcbr:
		case v__token__Kind__rpar:
		case v__token__Kind__nilsbr:
		case v__token__Kind__rsbr:
		case v__token__Kind__eq:
		case v__token__Kind__ne:
		case v__token__Kind__gt:
		case v__token__Kind__lt:
		case v__token__Kind__ge:
		case v__token__Kind__le:
		case v__token__Kind__nl:
		case v__token__Kind__dotdot:
		case v__token__Kind__ellipsis:
		case v__token__Kind__keyword_beg:
		case v__token__Kind__key_as:
		case v__token__Kind__key_asm:
		case v__token__Kind__key_assert:
		case v__token__Kind__key_break:
		case v__token__Kind__key_const:
		case v__token__Kind__key_continue:
		case v__token__Kind__key_defer:
		case v__token__Kind__key_else:
		case v__token__Kind__key_enum:
		case v__token__Kind__key_for:
		case v__token__Kind__key_global:
		case v__token__Kind__key_goto:
		case v__token__Kind__key_import:
		case v__token__Kind__key_in:
		case v__token__Kind__key_interface:
		case v__token__Kind__key_is:
		case v__token__Kind__key_module:
		case v__token__Kind__key_return:
		case v__token__Kind__key_struct:
		case v__token__Kind__key_type:
		case v__token__Kind__key_orelse:
		case v__token__Kind__key_union:
		case v__token__Kind__key_pub:
		case v__token__Kind__keyword_end:
		case v__token__Kind___end_:
		default:
			{
				if (p->tok.kind != v__token__Kind__eof && !(p->tok.kind == v__token__Kind__rsbr && p->inside_asm)) {
					Option_v__ast__Expr _t12 = (Option_v__ast__Expr){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
					// Defer begin
					if (v__parser__Parser_check_expr_defer_0) {
						p->inside_array_lit = inside_array_lit;
					}
					// Defer end
					return _t12;
				}
			} break;
	}
	;
	if (inside_array_lit) {
		if ((p->tok.kind == v__token__Kind__minus || p->tok.kind == v__token__Kind__mul || p->tok.kind == v__token__Kind__amp || p->tok.kind == v__token__Kind__arrow) && p->tok.pos + 1 == p->peek_tok.pos && p->prev_tok.pos + p->prev_tok.len + 1 != p->peek_tok.pos) {
			Option_v__ast__Expr _t13;
			opt_ok(&(v__ast__Expr[]) { node }, (Option*)(&_t13), sizeof(v__ast__Expr));
			// Defer begin
			if (v__parser__Parser_check_expr_defer_0) {
				p->inside_array_lit = inside_array_lit;
			}
			// Defer end
			return _t13;
		}
	}
	Option_v__ast__Expr _t14;
	opt_ok(&(v__ast__Expr[]) { v__parser__Parser_expr_with_left(p, node, precedence, is_stmt_ident) }, (Option*)(&_t14), sizeof(v__ast__Expr));
	// Defer begin
	if (v__parser__Parser_check_expr_defer_0) {
		p->inside_array_lit = inside_array_lit;
	}
	// Defer end
	return _t14;
}

v__ast__Expr v__parser__Parser_expr_with_left(v__parser__Parser* p, v__ast__Expr left, int precedence, bool is_stmt_ident) {
	v__ast__Expr node = left;
	if (p->inside_asm && v__token__Token_position(&p->prev_tok).line_nr < v__token__Token_position(&p->tok).line_nr) {
		v__ast__Expr _t1 = node;
		return _t1;
	}
	for (;;) {
		if (!(precedence < v__token__Token_precedence(p->tok))) break;
		if (p->tok.kind == v__token__Kind__dot) {
			node = v__parser__Parser_dot_expr(p, node);
			if (p->name_error) {
				v__ast__Expr _t2 = node;
				return _t2;
			}
			p->is_stmt_ident = is_stmt_ident;
		} else if ((p->tok.kind == v__token__Kind__lsbr || p->tok.kind == v__token__Kind__nilsbr) && (p->inside_fn || p->tok.line_nr == p->prev_tok.line_nr)) {
			if (p->tok.kind == v__token__Kind__nilsbr) {
				node = v__ast__IndexExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__IndexExpr, (v__parser__Parser_index_expr(p, node, true))));
			} else {
				node = v__ast__IndexExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__IndexExpr, (v__parser__Parser_index_expr(p, node, false))));
			}
			p->is_stmt_ident = is_stmt_ident;
			if (p->tok.kind == v__token__Kind__lpar && p->tok.line_nr == p->prev_tok.line_nr && (node)._typ == 302 /* v.ast.IndexExpr */) {
				v__parser__Parser_next(p);
				v__token__Position pos = v__token__Token_position(&p->tok);
				Array_v__ast__CallArg args = v__parser__Parser_call_args(p);
				v__parser__Parser_check(p, v__token__Kind__rpar);
				node = v__ast__CallExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__CallExpr, ((v__ast__CallExpr){.pos = pos,.name_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.mod = (string){.str=(byteptr)"", .is_lit=1},.name = (string){.str=(byteptr)"", .is_lit=1},.is_method = 0,.is_field = 0,.is_keep_alive = 0,.is_noreturn = 0,.is_ctor_new = 0,.args = args,.expected_arg_types = __new_array(0, 0, sizeof(v__ast__Type)),.language = 0,.or_block = (v__ast__OrExpr){.stmts = __new_array(0, 0, sizeof(v__ast__Stmt)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},},.left = node,.left_type = 0,.receiver_type = 0,.return_type = 0,.should_be_skipped = 0,.concrete_types = __new_array(0, 0, sizeof(v__ast__Type)),.concrete_list_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.free_receiver = 0,.scope = p->scope,.from_embed_types = __new_array(0, 0, sizeof(v__ast__Type)),.comments = __new_array(0, 0, sizeof(v__ast__Comment)),})));
				p->is_stmt_ident = is_stmt_ident;
			}
		} else if (p->tok.kind == v__token__Kind__key_as) {
			if (!p->inside_asm) {
				v__token__Position pos = v__token__Token_position(&p->tok);
				v__parser__Parser_next(p);
				v__ast__Type typ = v__parser__Parser_parse_type(p);
				node = v__ast__AsCast_to_sumtype_v__ast__Expr(ADDR(v__ast__AsCast, ((v__ast__AsCast){.expr = node,.typ = typ,.pos = pos,.expr_type = 0,})));
			} else {
				v__ast__Expr _t3 = node;
				return _t3;
			}
		} else if (p->tok.kind == v__token__Kind__left_shift && p->is_stmt_ident) {
			v__token__Token tok = p->tok;
			v__token__Position pos = v__token__Token_position(&tok);
			v__parser__Parser_next(p);
			v__ast__Expr right = v__parser__Parser_expr(p, precedence - 1);
			v__token__Position_update_last_line(&pos, p->prev_tok.line_nr);
			if ((node)._typ == 302 /* v.ast.IndexExpr */) {
				v__ast__IndexExpr_recursive_mapset_is_setter(&(*node._v__ast__IndexExpr), true);
			}
			node = v__ast__InfixExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__InfixExpr, ((v__ast__InfixExpr){.op = tok.kind,.pos = pos,.is_stmt = true,.left = node,.right = right,.left_type = 0,.right_type = 0,.auto_locked = (string){.str=(byteptr)"", .is_lit=1},.or_block = (v__ast__OrExpr){.stmts = __new_array(0, 0, sizeof(v__ast__Stmt)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},},.ct_left_value_evaled = 0,.ct_left_value = v__ast__empty_comptime_const_expr(),.ct_right_value_evaled = 0,.ct_right_value = v__ast__empty_comptime_const_expr(),})));
		} else if (v__token__Kind_is_infix(p->tok.kind)) {
			if (v__token__Kind_is_prefix(p->tok.kind) && p->tok.line_nr != p->prev_tok.line_nr) {
				if (p->tok.kind == v__token__Kind__mul && v__parser__Parser_peek_token(p, 2).kind == v__token__Kind__assign) {
					v__ast__Expr _t4 = node;
					return _t4;
				}
				v__parser__Parser_warn_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("move infix `"), 0xfe10, {.d_s = v__token__Kind_str(p->tok.kind)}}, {_SLIT("` operator before new line (if infix intended) or use brackets for a prefix expression"), 0, { .d_c = 0 }}})), v__token__Token_position(&p->tok));
			}
			node = v__parser__Parser_infix_expr(p, node);
			if (p->tok.kind == v__token__Kind__key_as && p->inside_if) {
				v__ast__Expr _t5 = node;
				return _t5;
			}
		} else if ((p->tok.kind == v__token__Kind__inc || p->tok.kind == v__token__Kind__dec) || (p->tok.kind == v__token__Kind__question && p->inside_ct_if_expr)) {
			if (p->peek_tok.kind == v__token__Kind__rpar || p->peek_tok.kind == v__token__Kind__rsbr) {
				if (!p->inside_ct_if_expr) {
					v__parser__Parser_warn_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = v__token__Kind_str(p->tok.kind)}}, {_SLIT("` operator can only be used as a statement"), 0, { .d_c = 0 }}})), v__token__Token_position(&p->peek_tok));
				}
			}
			if ((p->tok.kind == v__token__Kind__inc || p->tok.kind == v__token__Kind__dec) && p->prev_tok.line_nr != p->tok.line_nr) {
				v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__token__Token_str(p->tok)}}, {_SLIT(" must be on the same line as the previous token"), 0, { .d_c = 0 }}})), v__token__Token_position(&p->tok));
			}
			if ((node)._typ == 302 /* v.ast.IndexExpr */) {
				v__ast__IndexExpr_recursive_mapset_is_setter(&(*node._v__ast__IndexExpr), true);
			}
			node = v__ast__PostfixExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__PostfixExpr, ((v__ast__PostfixExpr){.op = p->tok.kind,.expr = node,.pos = v__token__Token_position(&p->tok),.auto_locked = (string){.str=(byteptr)"", .is_lit=1},})));
			v__parser__Parser_next(p);
		} else {
			v__ast__Expr _t6 = node;
			return _t6;
		}
	}
	v__ast__Expr _t7 = node;
	return _t7;
}

VV_LOCAL_SYMBOL v__ast__Expr v__parser__Parser_infix_expr(v__parser__Parser* p, v__ast__Expr left) {
	v__token__Kind op = p->tok.kind;
	if (op == v__token__Kind__arrow) {
		p->or_is_handled = true;
		v__parser__Parser_register_auto_import(p, _SLIT("sync"));
	}
	int precedence = v__token__Token_precedence(p->tok);
	v__token__Position pos = v__token__Token_position(&p->tok);
	v__parser__Parser_next(p);
	v__ast__Expr right = v__ast__empty_expr();
	bool prev_expecting_type = p->expecting_type;
	if (op == v__token__Kind__key_is || op == v__token__Kind__not_is) {
		p->expecting_type = true;
	}
	bool is_key_in = (op == v__token__Kind__key_in || op == v__token__Kind__not_in);
	if (is_key_in) {
		p->inside_in_array = true;
	}
	right = v__parser__Parser_expr(p, precedence);
	if (is_key_in) {
		p->inside_in_array = false;
	}
	p->expecting_type = prev_expecting_type;
	if (p->pref->is_vet && (op == v__token__Kind__key_in || op == v__token__Kind__not_in) && (right)._typ == 280 /* v.ast.ArrayInit */ && (/* as */ *(v__ast__ArrayInit*)__as_cast((right)._v__ast__ArrayInit,(right)._typ, 280) /*expected idx: 280, name: v.ast.ArrayInit */ ).exprs.len == 1) {
		v__parser__Parser_vet_error(p, _SLIT("Use `var == value` instead of `var in [value]`"), pos.line_nr, v__vet__FixKind__vfmt, v__vet__ErrorType__default);
	}
	Array_v__ast__Stmt or_stmts = __new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
	v__ast__OrKind or_kind = v__ast__OrKind__absent;
	v__token__Position or_pos = v__token__Token_position(&p->tok);
	if (op == v__token__Kind__arrow) {
		if (p->tok.kind == v__token__Kind__key_orelse) {
			bool was_inside_or_expr = p->inside_or_expr;
			p->inside_or_expr = true;
			v__parser__Parser_next(p);
			v__parser__Parser_open_scope(p);
			v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){.name = _SLIT("err"),.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.is_auto_deref = 0,.is_inherited = 0,.typ = _const_v__ast__error_type,.orig_type = 0,.smartcasts = __new_array(0, 0, sizeof(v__ast__Type)),.pos = v__token__Token_position(&p->tok),.is_used = true,.is_changed = 0,.is_or = 0,.is_tmp = 0,.is_auto_heap = 0,.is_stack_obj = true,}))));
			or_kind = v__ast__OrKind__block;
			or_stmts = v__parser__Parser_parse_block_no_scope(p, false);
			or_pos = v__token__Position_extend(or_pos, v__token__Token_position(&p->prev_tok));
			v__parser__Parser_close_scope(p);
			p->inside_or_expr = was_inside_or_expr;
		}
		if (p->tok.kind == v__token__Kind__question) {
			v__parser__Parser_next(p);
			or_kind = v__ast__OrKind__propagate;
		}
		p->or_is_handled = false;
	}
	v__token__Position_update_last_line(&pos, p->prev_tok.line_nr);
	v__ast__Expr _t1 = v__ast__InfixExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__InfixExpr, ((v__ast__InfixExpr){
		.op = op,
		.pos = pos,
		.is_stmt = p->is_stmt_ident,
		.left = left,
		.right = right,
		.left_type = 0,
		.right_type = 0,
		.auto_locked = (string){.str=(byteptr)"", .is_lit=1},
		.or_block = (v__ast__OrExpr){.stmts = or_stmts,.kind = or_kind,.pos = or_pos,},
		.ct_left_value_evaled = 0,
		.ct_left_value = v__ast__empty_comptime_const_expr(),
		.ct_right_value_evaled = 0,
		.ct_right_value = v__ast__empty_comptime_const_expr(),
	})));
	return _t1;
}

VV_LOCAL_SYMBOL v__ast__GoExpr v__parser__Parser_go_expr(v__parser__Parser* p) {
	v__parser__Parser_next(p);
	v__token__Position spos = v__token__Token_position(&p->tok);
	v__ast__Expr expr = v__parser__Parser_expr(p, 0);
	v__ast__CallExpr _t1; /* if prepend */
	if ((expr)._typ == 286 /* v.ast.CallExpr */) {
		_t1 = (*expr._v__ast__CallExpr);
	} else {
		v__parser__Parser_error_with_pos(p, _SLIT("expression in `go` must be a function call"), v__ast__Expr_position(expr));
		_t1 = (v__ast__CallExpr){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.name_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.mod = (string){.str=(byteptr)"", .is_lit=1},.name = (string){.str=(byteptr)"", .is_lit=1},.is_method = 0,.is_field = 0,.is_keep_alive = 0,.is_noreturn = 0,.is_ctor_new = 0,.args = __new_array(0, 0, sizeof(v__ast__CallArg)),.expected_arg_types = __new_array(0, 0, sizeof(v__ast__Type)),.language = 0,.or_block = (v__ast__OrExpr){.stmts = __new_array(0, 0, sizeof(v__ast__Stmt)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},},.left = {0},.left_type = 0,.receiver_type = 0,.return_type = 0,.should_be_skipped = 0,.concrete_types = __new_array(0, 0, sizeof(v__ast__Type)),.concrete_list_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.free_receiver = 0,.scope = p->scope,.from_embed_types = __new_array(0, 0, sizeof(v__ast__Type)),.comments = __new_array(0, 0, sizeof(v__ast__Comment)),};
	}
	v__ast__CallExpr call_expr =  _t1;
	v__token__Position pos = v__token__Position_extend(spos, v__token__Token_position(&p->prev_tok));
	v__parser__Parser_register_auto_import(p, _SLIT("sync.threads"));
	p->table->gostmts++;
	v__ast__GoExpr _t2 = (v__ast__GoExpr){.pos = pos,.call_expr = call_expr,.is_expr = 0,};
	return _t2;
}

VV_LOCAL_SYMBOL bool v__parser__Parser_fileis(v__parser__Parser* p, string s) {
	bool _t1 = string_contains(p->file_name, s);
	return _t1;
}

VV_LOCAL_SYMBOL v__ast__Expr v__parser__Parser_prefix_expr(v__parser__Parser* p) {
	v__token__Position pos = v__token__Token_position(&p->tok);
	v__token__Kind op = p->tok.kind;
	if (op == v__token__Kind__amp) {
		p->is_amp = true;
	}
	if (op == v__token__Kind__arrow) {
		p->or_is_handled = true;
		v__parser__Parser_register_auto_import(p, _SLIT("sync"));
	}
	v__parser__Parser_next(p);
	v__ast__Expr right = v__parser__Parser_expr(p, ((int)(v__token__Precedence__prefix)));
	p->is_amp = false;
	if (op == v__token__Kind__amp) {
		if ((right)._typ == 287 /* v.ast.CastExpr */) {
			v__parser__Parser_recast_as_pointer(p, (voidptr)&/*qq*/(*right._v__ast__CastExpr), pos);
			v__ast__Expr _t1 = right;
			return _t1;
		}
		if ((right)._typ == 319 /* v.ast.SelectorExpr */) {
			if (((*right._v__ast__SelectorExpr).expr)._typ == 287 /* v.ast.CastExpr */) {
				v__parser__Parser_recast_as_pointer(p, (voidptr)&/*qq*/(*(*right._v__ast__SelectorExpr).expr._v__ast__CastExpr), pos);
				v__ast__Expr _t2 = right;
				return _t2;
			}
		}
		if ((right)._typ == 302 /* v.ast.IndexExpr */) {
			if (((*right._v__ast__IndexExpr).left)._typ == 287 /* v.ast.CastExpr */) {
				v__parser__Parser_recast_as_pointer(p, (voidptr)&/*qq*/(*(*right._v__ast__IndexExpr).left._v__ast__CastExpr), pos);
				v__ast__Expr _t3 = right;
				return _t3;
			}
		}
	}
	Array_v__ast__Stmt or_stmts = __new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
	v__ast__OrKind or_kind = v__ast__OrKind__absent;
	v__token__Position or_pos = v__token__Token_position(&p->tok);
	if (op == v__token__Kind__arrow) {
		if (p->tok.kind == v__token__Kind__key_orelse) {
			bool was_inside_or_expr = p->inside_or_expr;
			p->inside_or_expr = true;
			v__parser__Parser_next(p);
			v__parser__Parser_open_scope(p);
			v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){.name = _SLIT("err"),.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.is_auto_deref = 0,.is_inherited = 0,.typ = _const_v__ast__error_type,.orig_type = 0,.smartcasts = __new_array(0, 0, sizeof(v__ast__Type)),.pos = v__token__Token_position(&p->tok),.is_used = true,.is_changed = 0,.is_or = 0,.is_tmp = 0,.is_auto_heap = 0,.is_stack_obj = true,}))));
			or_kind = v__ast__OrKind__block;
			or_stmts = v__parser__Parser_parse_block_no_scope(p, false);
			or_pos = v__token__Position_extend(or_pos, v__token__Token_position(&p->prev_tok));
			v__parser__Parser_close_scope(p);
			p->inside_or_expr = was_inside_or_expr;
		}
		if (p->tok.kind == v__token__Kind__question) {
			v__parser__Parser_next(p);
			or_kind = v__ast__OrKind__propagate;
		}
		p->or_is_handled = false;
	}
	v__token__Position_update_last_line(&pos, p->prev_tok.line_nr);
	v__ast__Expr _t4 = v__ast__PrefixExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__PrefixExpr, ((v__ast__PrefixExpr){.op = op,.pos = pos,.right_type = 0,.right = right,.or_block = (v__ast__OrExpr){.stmts = or_stmts,.kind = or_kind,.pos = or_pos,},.is_option = 0,})));
	return _t4;
}

VV_LOCAL_SYMBOL void v__parser__Parser_recast_as_pointer(v__parser__Parser* p, v__ast__CastExpr* cast_expr, v__token__Position pos) {
	cast_expr->typ = v__ast__Type_ref(cast_expr->typ);
	cast_expr->typname = v__ast__Table_sym(p->table, cast_expr->typ)->name;
	cast_expr->pos = v__token__Position_extend(pos, cast_expr->pos);
}

v__ast__CallExpr v__parser__Parser_call_expr(v__parser__Parser* p, v__ast__Language language, string mod) {
bool v__parser__Parser_call_expr_defer_0 = false;
string old_expr_mod;
	v__token__Position first_pos = v__token__Token_position(&p->tok);
	string fn_name = (language == v__ast__Language__c ? ( str_intp(2, _MOV((StrIntpData[]){{_SLIT("C."), 0xfe10, {.d_s = v__parser__Parser_check_name(p)}}, {_SLIT0, 0, { .d_c = 0 }}}))) : language == v__ast__Language__js ? ( str_intp(2, _MOV((StrIntpData[]){{_SLIT("JS."), 0xfe10, {.d_s = v__parser__Parser_check_js_name(p)}}, {_SLIT0, 0, { .d_c = 0 }}}))) : mod.len > 0 ? ( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = mod}}, {_SLIT("."), 0xfe10, {.d_s = v__parser__Parser_check_name(p)}}, {_SLIT0, 0, { .d_c = 0 }}}))) : (v__parser__Parser_check_name(p)));
	if (language != v__ast__Language__v) {
		v__parser__Parser_check_for_impure_v(p, language, first_pos);
	}
	v__ast__OrKind or_kind = v__ast__OrKind__absent;
	if (string__eq(fn_name, _SLIT("json.decode"))) {
		p->expecting_type = true;
		or_kind = v__ast__OrKind__block;
	}
	old_expr_mod = p->expr_mod;
	v__parser__Parser_call_expr_defer_0 = true;
	p->expr_mod = _SLIT("");
	Array_v__ast__Type concrete_types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
	v__token__Position concrete_list_pos = v__token__Token_position(&p->tok);
	if (p->tok.kind == v__token__Kind__lt) {
		p->expr_mod = _SLIT("");
		concrete_types = v__parser__Parser_parse_concrete_types(p);
		concrete_list_pos = v__token__Position_extend(concrete_list_pos, v__token__Token_position(&p->prev_tok));
	}
	v__parser__Parser_check(p, v__token__Kind__lpar);
	Array_v__ast__CallArg args = v__parser__Parser_call_args(p);
	v__token__Position last_pos = v__token__Token_position(&p->tok);
	v__parser__Parser_check(p, v__token__Kind__rpar);
	if (p->tok.kind == v__token__Kind__not) {
		v__parser__Parser_next(p);
	}
	v__token__Position pos = v__token__Position_extend(first_pos, last_pos);
	Array_v__ast__Stmt or_stmts = __new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
	v__token__Position or_pos = v__token__Token_position(&p->tok);
	if (p->tok.kind == v__token__Kind__key_orelse) {
		bool was_inside_or_expr = p->inside_or_expr;
		p->inside_or_expr = true;
		v__parser__Parser_next(p);
		v__parser__Parser_open_scope(p);
		v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){.name = _SLIT("err"),.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.is_auto_deref = 0,.is_inherited = 0,.typ = _const_v__ast__error_type,.orig_type = 0,.smartcasts = __new_array(0, 0, sizeof(v__ast__Type)),.pos = v__token__Token_position(&p->tok),.is_used = true,.is_changed = 0,.is_or = 0,.is_tmp = 0,.is_auto_heap = 0,.is_stack_obj = 0,}))));
		or_kind = v__ast__OrKind__block;
		or_stmts = v__parser__Parser_parse_block_no_scope(p, false);
		or_pos = v__token__Position_extend(or_pos, v__token__Token_position(&p->prev_tok));
		v__parser__Parser_close_scope(p);
		p->inside_or_expr = was_inside_or_expr;
	}
	if (p->tok.kind == v__token__Kind__question) {
		v__parser__Parser_next(p);
		if (p->inside_defer) {
			v__parser__Parser_error_with_pos(p, _SLIT("error propagation not allowed inside `defer` blocks"), v__token__Token_position(&p->prev_tok));
		}
		or_kind = v__ast__OrKind__propagate;
	}
	if (_IN_MAP(ADDR(string, fn_name), ADDR(map, p->imported_symbols))) {
		fn_name = (*(string*)map_get(ADDR(map, p->imported_symbols), &(string[]){fn_name}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} }));
	}
	Array_v__ast__Comment comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = true,.follow_up = 0,});
	v__token__Position_update_last_line(&pos, p->prev_tok.line_nr);
	v__ast__CallExpr _t1 = (v__ast__CallExpr){
		.pos = pos,
		.name_pos = first_pos,
		.mod = p->mod,
		.name = fn_name,
		.is_method = 0,
		.is_field = 0,
		.is_keep_alive = 0,
		.is_noreturn = 0,
		.is_ctor_new = 0,
		.args = args,
		.expected_arg_types = __new_array(0, 0, sizeof(v__ast__Type)),
		.language = language,
		.or_block = (v__ast__OrExpr){.stmts = or_stmts,.kind = or_kind,.pos = or_pos,},
		.left = {0},
		.left_type = 0,
		.receiver_type = 0,
		.return_type = 0,
		.should_be_skipped = 0,
		.concrete_types = concrete_types,
		.concrete_list_pos = concrete_list_pos,
		.free_receiver = 0,
		.scope = p->scope,
		.from_embed_types = __new_array(0, 0, sizeof(v__ast__Type)),
		.comments = comments,
	};
	// Defer begin
	if (v__parser__Parser_call_expr_defer_0) {
		p->expr_mod = old_expr_mod;
	}
	// Defer end
	return _t1;
}

Array_v__ast__CallArg v__parser__Parser_call_args(v__parser__Parser* p) {
	Array_v__ast__CallArg args = __new_array_with_default(0, 0, sizeof(v__ast__CallArg), 0);
	v__token__Position start_pos = v__token__Token_position(&p->tok);
	for (;;) {
		if (!(p->tok.kind != v__token__Kind__rpar)) break;
		if (p->tok.kind == v__token__Kind__eof) {
			v__parser__Parser_error_with_pos(p, _SLIT("unexpected eof reached, while parsing call argument"), start_pos);
			Array_v__ast__CallArg _t1 = __new_array_with_default(0, 0, sizeof(v__ast__CallArg), 0);
			return _t1;
		}
		bool is_shared = p->tok.kind == v__token__Kind__key_shared;
		bool is_atomic = p->tok.kind == v__token__Kind__key_atomic;
		bool is_mut = p->tok.kind == v__token__Kind__key_mut || is_shared || is_atomic;
		if (is_mut) {
			v__parser__Parser_next(p);
		}
		Array_v__ast__Comment comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,});
		v__token__Position arg_start_pos = v__token__Token_position(&p->tok);
		bool array_decompose = false;
		if (p->tok.kind == v__token__Kind__ellipsis) {
			v__parser__Parser_next(p);
			array_decompose = true;
		}
		v__ast__Expr expr = v__ast__empty_expr();
		if (p->tok.kind == v__token__Kind__name && p->peek_tok.kind == v__token__Kind__colon) {
			expr = v__ast__StructInit_to_sumtype_v__ast__Expr(ADDR(v__ast__StructInit, (v__parser__Parser_struct_init(p, true))));
		} else {
			expr = v__parser__Parser_expr(p, 0);
		}
		if (array_decompose) {
			expr = v__ast__ArrayDecompose_to_sumtype_v__ast__Expr(ADDR(v__ast__ArrayDecompose, ((v__ast__ArrayDecompose){.expr = expr,.pos = v__token__Token_position(&p->tok),.expr_type = 0,.arg_type = 0,})));
		}
		if ((expr)._typ == 324 /* v.ast.StructInit */) {
			_PUSH_MANY(&(*expr._v__ast__StructInit).pre_comments, (comments), _t2, Array_v__ast__Comment);
			comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
		}
		v__token__Position pos = v__token__Position_extend(arg_start_pos, v__token__Token_position(&p->prev_tok));
		_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,})), _t3, Array_v__ast__Comment);
		array_push((array*)&args, _MOV((v__ast__CallArg[]){ (v__ast__CallArg){.is_mut = is_mut,.share = v__ast__sharetype_from_flags(is_shared, is_atomic),.comments = comments,.expr = expr,.typ = 0,.is_tmp_autofree = 0,.pos = pos,} }));
		if (p->tok.kind != v__token__Kind__rpar) {
			v__parser__Parser_check(p, v__token__Kind__comma);
		}
	}
	Array_v__ast__CallArg _t5 = args;
	return _t5;
}

VV_LOCAL_SYMBOL v__ast__FnDecl v__parser__Parser_fn_decl(v__parser__Parser* p) {
	v__parser__Parser_top_level_statement_start(p);
	v__token__Position start_pos = v__token__Token_position(&p->tok);
	bool is_manualfree = p->is_manualfree;
	bool is_deprecated = false;
	bool is_direct_arr = false;
	bool is_keep_alive = false;
	bool is_exported = false;
	bool is_unsafe = false;
	bool is_trusted = false;
	bool is_noreturn = false;
	bool is_ctor_new = false;
	bool is_c2v_variadic = false;
	bool is_markused = false;
	for (int _t1 = 0; _t1 < p->attrs.len; ++_t1) {
		v__ast__Attr fna = ((v__ast__Attr*)p->attrs.data)[_t1];

		if (string__eq(fna.name, _SLIT("noreturn"))) {
			is_noreturn = true;
		}
		else if (string__eq(fna.name, _SLIT("manualfree"))) {
			is_manualfree = true;
		}
		else if (string__eq(fna.name, _SLIT("deprecated"))) {
			is_deprecated = true;
		}
		else if (string__eq(fna.name, _SLIT("direct_array_access"))) {
			is_direct_arr = true;
		}
		else if (string__eq(fna.name, _SLIT("keep_args_alive"))) {
			is_keep_alive = true;
		}
		else if (string__eq(fna.name, _SLIT("export"))) {
			is_exported = true;
		}
		else if (string__eq(fna.name, _SLIT("wasm_export"))) {
			is_exported = true;
		}
		else if (string__eq(fna.name, _SLIT("unsafe"))) {
			is_unsafe = true;
		}
		else if (string__eq(fna.name, _SLIT("trusted"))) {
			is_trusted = true;
		}
		else if (string__eq(fna.name, _SLIT("c2v_variadic"))) {
			is_c2v_variadic = true;
		}
		else if (string__eq(fna.name, _SLIT("use_new"))) {
			is_ctor_new = true;
		}
		else if (string__eq(fna.name, _SLIT("markused"))) {
			is_markused = true;
		}
		else {
		};
	}
	Option_int _t2 = Array_v__ast__Attr_find_comptime_define(p->attrs);
	if (_t2.state != 0) { /*or block*/ 
		IError err = _t2.err;
		*(int*) _t2.data = -1;
	}
	
 	int conditional_ctdefine_idx =  (*(int*)_t2.data);
	bool is_pub = p->tok.kind == v__token__Kind__key_pub;
	if (is_pub) {
		v__parser__Parser_next(p);
	}
	v__parser__Parser_check(p, v__token__Kind__key_fn);
	v__parser__Parser_open_scope(p);
	v__ast__Language language = v__ast__Language__v;
	v__token__Position language_tok_pos = v__token__Token_position(&p->tok);
	if (p->tok.kind == v__token__Kind__name && string__eq(p->tok.lit, _SLIT("C"))) {
		is_unsafe = !is_trusted;
		language = v__ast__Language__c;
	} else if (p->tok.kind == v__token__Kind__name && string__eq(p->tok.lit, _SLIT("JS"))) {
		language = v__ast__Language__js;
	}
	p->fn_language = language;
	if (language != v__ast__Language__v) {
		for (int _t3 = 0; _t3 < p->attrs.len; ++_t3) {
			v__ast__Attr fna = ((v__ast__Attr*)p->attrs.data)[_t3];
			if (string__eq(fna.name, _SLIT("export"))) {
				v__parser__Parser_error_with_pos(p, _SLIT("interop function cannot be exported"), fna.pos);
				break;
			}
		}
	}
	if (is_keep_alive && language != v__ast__Language__c) {
		v__parser__Parser_error_with_pos(p, _SLIT("attribute [keep_args_alive] is only supported for C functions"), language_tok_pos);
	}
	if (language != v__ast__Language__v) {
		v__parser__Parser_next(p);
		v__parser__Parser_check(p, v__token__Kind__dot);
		v__parser__Parser_check_for_impure_v(p, language, language_tok_pos);
	}
	v__parser__ReceiverParsingInfo rec = (v__parser__ReceiverParsingInfo){.name = (string){.str=(byteptr)"", .is_lit=1},.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.typ = _const_v__ast__void_type,.type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.is_mut = 0,.language = language,};
	bool is_method = false;
	Array_v__ast__Param params = __new_array_with_default(0, 0, sizeof(v__ast__Param), 0);
	if (p->tok.kind == v__token__Kind__lpar) {
		is_method = true;
		Option_void _t4 = v__parser__Parser_fn_receiver(p, &/*arr*/params, (voidptr)&/*qq*/rec);
		if (_t4.state != 0 && _t4.err._typ != _IError_None___index) {
			IError err = _t4.err;
			v__ast__FnDecl _t5 = (v__ast__FnDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.is_deprecated = 0,.is_pub = 0,.is_variadic = 0,.is_anon = 0,.is_noreturn = 0,.is_manualfree = 0,.is_main = 0,.is_test = 0,.is_conditional = 0,.is_exported = 0,.is_keep_alive = 0,.is_unsafe = 0,.is_markused = 0,.receiver = (v__ast__StructField){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.has_default_expr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_pub = 0,.default_val = (string){.str=(byteptr)"", .is_lit=1},.is_mut = 0,.is_global = 0,.is_volatile = 0,.default_expr_typ = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,},.receiver_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.is_method = 0,.method_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.method_idx = 0,.rec_mut = 0,.rec_share = 0,.language = 0,.file_mode = 0,.no_body = 0,.is_builtin = 0,.body_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.file = (string){.str=(byteptr)"", .is_lit=1},.generic_names = __new_array(0, 0, sizeof(string)),.is_direct_arr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.ctdefine_idx = -1,.params = __new_array(0, 0, sizeof(v__ast__Param)),.stmts = __new_array(0, 0, sizeof(v__ast__Stmt)),.defer_stmts = __new_array(0, 0, sizeof(v__ast__DeferStmt)),.return_type = 0,.return_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.has_return = 0,.should_be_skipped = 0,.ninstances = 0,.has_await = 0,.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.next_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.source_file = 0,.scope = 0,.label_names = __new_array(0, 0, sizeof(string)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},};
			return _t5;
		}
		
 ;
		language = rec.language;
		p->fn_language = language;
	}
	string name = _SLIT("");
	v__token__Position name_pos = v__token__Token_position(&p->tok);
	if (p->tok.kind == v__token__Kind__name) {
		name = (language == v__ast__Language__js ? (v__parser__Parser_check_js_name(p)) : (v__parser__Parser_check_name(p)));
		if (language == v__ast__Language__v && !p->pref->translated && v__util__contains_capital(name) && !p->builtin_mod) {
			v__parser__Parser_error_with_pos(p, _SLIT("function names cannot contain uppercase letters, use snake_case instead"), name_pos);
			v__ast__FnDecl _t6 = (v__ast__FnDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.is_deprecated = 0,.is_pub = 0,.is_variadic = 0,.is_anon = 0,.is_noreturn = 0,.is_manualfree = 0,.is_main = 0,.is_test = 0,.is_conditional = 0,.is_exported = 0,.is_keep_alive = 0,.is_unsafe = 0,.is_markused = 0,.receiver = (v__ast__StructField){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.has_default_expr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_pub = 0,.default_val = (string){.str=(byteptr)"", .is_lit=1},.is_mut = 0,.is_global = 0,.is_volatile = 0,.default_expr_typ = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,},.receiver_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.is_method = 0,.method_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.method_idx = 0,.rec_mut = 0,.rec_share = 0,.language = 0,.file_mode = 0,.no_body = 0,.is_builtin = 0,.body_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.file = (string){.str=(byteptr)"", .is_lit=1},.generic_names = __new_array(0, 0, sizeof(string)),.is_direct_arr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.ctdefine_idx = -1,.params = __new_array(0, 0, sizeof(v__ast__Param)),.stmts = __new_array(0, 0, sizeof(v__ast__Stmt)),.defer_stmts = __new_array(0, 0, sizeof(v__ast__DeferStmt)),.return_type = 0,.return_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.has_return = 0,.should_be_skipped = 0,.ninstances = 0,.has_await = 0,.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.next_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.source_file = 0,.scope = 0,.label_names = __new_array(0, 0, sizeof(string)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},};
			return _t6;
		}
		v__ast__TypeSymbol* type_sym = v__ast__Table_sym(p->table, rec.typ);
		if (is_method) {
			bool is_duplicate = v__ast__TypeSymbol_has_method(type_sym, name);
			if (type_sym->kind == v__ast__Kind__interface_ && is_duplicate) {
				if ((type_sym->info)._typ == 463 /* v.ast.Interface */) {
					is_duplicate = !v__ast__Interface_has_method(&(*type_sym->info._v__ast__Interface), name);
				}
			}
			if (is_duplicate) {
				v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("duplicate method `"), 0xfe10, {.d_s = name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), name_pos);
				v__ast__FnDecl _t7 = (v__ast__FnDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.is_deprecated = 0,.is_pub = 0,.is_variadic = 0,.is_anon = 0,.is_noreturn = 0,.is_manualfree = 0,.is_main = 0,.is_test = 0,.is_conditional = 0,.is_exported = 0,.is_keep_alive = 0,.is_unsafe = 0,.is_markused = 0,.receiver = (v__ast__StructField){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.has_default_expr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_pub = 0,.default_val = (string){.str=(byteptr)"", .is_lit=1},.is_mut = 0,.is_global = 0,.is_volatile = 0,.default_expr_typ = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,},.receiver_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.is_method = 0,.method_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.method_idx = 0,.rec_mut = 0,.rec_share = 0,.language = 0,.file_mode = 0,.no_body = 0,.is_builtin = 0,.body_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.file = (string){.str=(byteptr)"", .is_lit=1},.generic_names = __new_array(0, 0, sizeof(string)),.is_direct_arr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.ctdefine_idx = -1,.params = __new_array(0, 0, sizeof(v__ast__Param)),.stmts = __new_array(0, 0, sizeof(v__ast__Stmt)),.defer_stmts = __new_array(0, 0, sizeof(v__ast__DeferStmt)),.return_type = 0,.return_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.has_return = 0,.should_be_skipped = 0,.ninstances = 0,.has_await = 0,.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.next_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.source_file = 0,.scope = 0,.label_names = __new_array(0, 0, sizeof(string)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},};
				return _t7;
			}
		}
		if (!p->pref->is_fmt) {
			if (!is_method && !p->builtin_mod && Array_string_contains(_const_v__parser__builtin_functions, name)) {
				v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot redefine builtin function `"), 0xfe10, {.d_s = name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), name_pos);
				v__ast__FnDecl _t8 = (v__ast__FnDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.is_deprecated = 0,.is_pub = 0,.is_variadic = 0,.is_anon = 0,.is_noreturn = 0,.is_manualfree = 0,.is_main = 0,.is_test = 0,.is_conditional = 0,.is_exported = 0,.is_keep_alive = 0,.is_unsafe = 0,.is_markused = 0,.receiver = (v__ast__StructField){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.has_default_expr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_pub = 0,.default_val = (string){.str=(byteptr)"", .is_lit=1},.is_mut = 0,.is_global = 0,.is_volatile = 0,.default_expr_typ = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,},.receiver_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.is_method = 0,.method_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.method_idx = 0,.rec_mut = 0,.rec_share = 0,.language = 0,.file_mode = 0,.no_body = 0,.is_builtin = 0,.body_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.file = (string){.str=(byteptr)"", .is_lit=1},.generic_names = __new_array(0, 0, sizeof(string)),.is_direct_arr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.ctdefine_idx = -1,.params = __new_array(0, 0, sizeof(v__ast__Param)),.stmts = __new_array(0, 0, sizeof(v__ast__Stmt)),.defer_stmts = __new_array(0, 0, sizeof(v__ast__DeferStmt)),.return_type = 0,.return_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.has_return = 0,.should_be_skipped = 0,.ninstances = 0,.has_await = 0,.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.next_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.source_file = 0,.scope = 0,.label_names = __new_array(0, 0, sizeof(string)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},};
				return _t8;
			}
			if (_IN_MAP(ADDR(string, name), ADDR(map, p->imported_symbols))) {
				v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot redefine imported function `"), 0xfe10, {.d_s = name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), name_pos);
				v__ast__FnDecl _t9 = (v__ast__FnDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.is_deprecated = 0,.is_pub = 0,.is_variadic = 0,.is_anon = 0,.is_noreturn = 0,.is_manualfree = 0,.is_main = 0,.is_test = 0,.is_conditional = 0,.is_exported = 0,.is_keep_alive = 0,.is_unsafe = 0,.is_markused = 0,.receiver = (v__ast__StructField){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.has_default_expr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_pub = 0,.default_val = (string){.str=(byteptr)"", .is_lit=1},.is_mut = 0,.is_global = 0,.is_volatile = 0,.default_expr_typ = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,},.receiver_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.is_method = 0,.method_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.method_idx = 0,.rec_mut = 0,.rec_share = 0,.language = 0,.file_mode = 0,.no_body = 0,.is_builtin = 0,.body_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.file = (string){.str=(byteptr)"", .is_lit=1},.generic_names = __new_array(0, 0, sizeof(string)),.is_direct_arr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.ctdefine_idx = -1,.params = __new_array(0, 0, sizeof(v__ast__Param)),.stmts = __new_array(0, 0, sizeof(v__ast__Stmt)),.defer_stmts = __new_array(0, 0, sizeof(v__ast__DeferStmt)),.return_type = 0,.return_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.has_return = 0,.should_be_skipped = 0,.ninstances = 0,.has_await = 0,.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.next_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.source_file = 0,.scope = 0,.label_names = __new_array(0, 0, sizeof(string)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},};
				return _t9;
			}
		}
	} else if ((p->tok.kind == v__token__Kind__plus || p->tok.kind == v__token__Kind__minus || p->tok.kind == v__token__Kind__mul || p->tok.kind == v__token__Kind__div || p->tok.kind == v__token__Kind__mod || p->tok.kind == v__token__Kind__lt || p->tok.kind == v__token__Kind__eq) && p->peek_tok.kind == v__token__Kind__lpar) {
		name = v__token__Kind_str(p->tok.kind);
		if (v__ast__Type_alias_eq(rec.typ, _const_v__ast__void_type)) {
			v__parser__Parser_error_with_pos(p, _SLIT("cannot use operator overloading with normal functions"), v__token__Token_position(&p->tok));
		}
		v__parser__Parser_next(p);
	} else if ((p->tok.kind == v__token__Kind__ne || p->tok.kind == v__token__Kind__gt || p->tok.kind == v__token__Kind__ge || p->tok.kind == v__token__Kind__le) && p->peek_tok.kind == v__token__Kind__lpar) {
		v__parser__Parser_error_with_pos(p, _SLIT("cannot overload `!=`, `>`, `<=` and `>=` as they are auto generated from `==` and`<`"), v__token__Token_position(&p->tok));
	} else {
		v__parser__Parser_error_with_pos(p, _SLIT("expecting method name"), v__token__Token_position(&p->tok));
		v__ast__FnDecl _t10 = (v__ast__FnDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.is_deprecated = 0,.is_pub = 0,.is_variadic = 0,.is_anon = 0,.is_noreturn = 0,.is_manualfree = 0,.is_main = 0,.is_test = 0,.is_conditional = 0,.is_exported = 0,.is_keep_alive = 0,.is_unsafe = 0,.is_markused = 0,.receiver = (v__ast__StructField){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.has_default_expr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_pub = 0,.default_val = (string){.str=(byteptr)"", .is_lit=1},.is_mut = 0,.is_global = 0,.is_volatile = 0,.default_expr_typ = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,},.receiver_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.is_method = 0,.method_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.method_idx = 0,.rec_mut = 0,.rec_share = 0,.language = 0,.file_mode = 0,.no_body = 0,.is_builtin = 0,.body_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.file = (string){.str=(byteptr)"", .is_lit=1},.generic_names = __new_array(0, 0, sizeof(string)),.is_direct_arr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.ctdefine_idx = -1,.params = __new_array(0, 0, sizeof(v__ast__Param)),.stmts = __new_array(0, 0, sizeof(v__ast__Stmt)),.defer_stmts = __new_array(0, 0, sizeof(v__ast__DeferStmt)),.return_type = 0,.return_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.has_return = 0,.should_be_skipped = 0,.ninstances = 0,.has_await = 0,.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.next_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.source_file = 0,.scope = 0,.label_names = __new_array(0, 0, sizeof(string)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},};
		return _t10;
	}
	multi_return_Array_v__ast__Type_Array_string mr_8235 = v__parser__Parser_parse_generic_types(p);
	Array_string generic_names = mr_8235.arg1;
	if (is_method && v__ast__Type_has_flag(rec.typ, v__ast__TypeFlag__generic)) {
		v__ast__TypeSymbol* sym = v__ast__Table_sym(p->table, rec.typ);
		if ((sym->info)._typ == 446 /* v.ast.Struct */) {
			Array_string _t11 = __new_array(0, 0, sizeof(string));
			Array_v__ast__Type _t11_orig = (*sym->info._v__ast__Struct).generic_types;
			int _t11_len = _t11_orig.len;
			_t11 = __new_array(0, _t11_len, sizeof(string));

			for (int _t12 = 0; _t12 < _t11_len; ++_t12) {
				v__ast__Type it = ((v__ast__Type*) _t11_orig.data)[_t12];
				string ti = v__ast__Table_sym(p->table, it)->name;
				array_push((array*)&_t11, &ti);
			}
			Array_string rec_generic_names =_t11;
			for (int _t13 = 0; _t13 < rec_generic_names.len; ++_t13) {
				string gname = ((string*)rec_generic_names.data)[_t13];
				if (!Array_string_contains(generic_names, gname)) {
					array_push((array*)&generic_names, _MOV((string[]){ string_clone(gname) }));
				}
			}
		}
	}
	multi_return_Array_v__ast__Param_bool_bool mr_8670 = v__parser__Parser_fn_args(p);
	Array_v__ast__Param args2 = mr_8670.arg0;
	bool are_args_type_only = mr_8670.arg1;
	bool is_variadic = mr_8670.arg2;
	if (is_c2v_variadic) {
		is_variadic = true;
	}
	_PUSH_MANY(&params, (args2), _t15, Array_v__ast__Param);
	if (!are_args_type_only) {
		for (int _t16 = 0; _t16 < params.len; ++_t16) {
			v__ast__Param param = ((v__ast__Param*)params.data)[_t16];
			if (v__ast__Scope_known_var(p->scope, param.name)) {
				v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("redefinition of parameter `"), 0xfe10, {.d_s = param.name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), param.pos);
				v__ast__FnDecl _t17 = (v__ast__FnDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.is_deprecated = 0,.is_pub = 0,.is_variadic = 0,.is_anon = 0,.is_noreturn = 0,.is_manualfree = 0,.is_main = 0,.is_test = 0,.is_conditional = 0,.is_exported = 0,.is_keep_alive = 0,.is_unsafe = 0,.is_markused = 0,.receiver = (v__ast__StructField){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.has_default_expr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_pub = 0,.default_val = (string){.str=(byteptr)"", .is_lit=1},.is_mut = 0,.is_global = 0,.is_volatile = 0,.default_expr_typ = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,},.receiver_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.is_method = 0,.method_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.method_idx = 0,.rec_mut = 0,.rec_share = 0,.language = 0,.file_mode = 0,.no_body = 0,.is_builtin = 0,.body_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.file = (string){.str=(byteptr)"", .is_lit=1},.generic_names = __new_array(0, 0, sizeof(string)),.is_direct_arr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.ctdefine_idx = -1,.params = __new_array(0, 0, sizeof(v__ast__Param)),.stmts = __new_array(0, 0, sizeof(v__ast__Stmt)),.defer_stmts = __new_array(0, 0, sizeof(v__ast__DeferStmt)),.return_type = 0,.return_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.has_return = 0,.should_be_skipped = 0,.ninstances = 0,.has_await = 0,.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.next_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.source_file = 0,.scope = 0,.label_names = __new_array(0, 0, sizeof(string)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},};
				return _t17;
			}
			bool is_stack_obj = !v__ast__Type_has_flag(param.typ, v__ast__TypeFlag__shared_f) && (param.is_mut || v__ast__Type_is_ptr(param.typ));
			v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){
				.name = param.name,
				.expr = {0},
				.share = 0,
				.is_mut = param.is_mut,
				.is_autofree_tmp = 0,
				.is_arg = true,
				.is_auto_deref = param.is_mut || param.is_auto_rec,
				.is_inherited = 0,
				.typ = param.typ,
				.orig_type = 0,
				.smartcasts = __new_array(0, 0, sizeof(v__ast__Type)),
				.pos = param.pos,
				.is_used = true,
				.is_changed = 0,
				.is_or = 0,
				.is_tmp = 0,
				.is_auto_heap = 0,
				.is_stack_obj = is_stack_obj,
			}))));
		}
	}
	v__token__Position return_type_pos = v__token__Token_position(&p->tok);
	v__ast__Type return_type = _const_v__ast__void_type;
	bool same_line = p->tok.line_nr == p->prev_tok.line_nr;
	if ((v__token__Kind_is_start_of_type(p->tok.kind) && (same_line || p->tok.kind != v__token__Kind__lsbr)) || (same_line && p->tok.kind == v__token__Kind__key_fn)) {
		return_type = v__parser__Parser_parse_type(p);
		return_type_pos = v__token__Position_extend(return_type_pos, v__token__Token_position(&p->prev_tok));
	}
	int type_sym_method_idx = 0;
	bool no_body = p->tok.kind != v__token__Kind__lcbr;
	v__token__Position end_pos = v__token__Token_position(&p->prev_tok);
	string short_fn_name = name;
	bool is_main = string__eq(short_fn_name, _SLIT("main")) && string__eq(p->mod, _SLIT("main"));
	bool is_test = (string_starts_with(short_fn_name, _SLIT("test_")) || string_starts_with(short_fn_name, _SLIT("testsuite_"))) && (string_ends_with(p->file_base, _SLIT("_test.v")) || string_ends_with(string_all_before_last(string_all_before_last(p->file_base, _SLIT(".v")), _SLIT(".")), _SLIT("_test")));
	v__ast__Language file_mode = p->file_backend_mode;
	if (is_method) {
		v__ast__TypeSymbol* type_sym = v__ast__Table_sym(p->table, rec.typ);
		bool is_non_local = type_sym->mod.len > 0 && !string__eq(type_sym->mod, p->mod) && type_sym->language == v__ast__Language__v;
		if (!is_non_local && !(p->builtin_mod && p->pref->is_fmt) && (type_sym->kind == v__ast__Kind__array || type_sym->kind == v__ast__Kind__map)) {
			v__ast__TypeSymbol* elem_type_sym = v__ast__Table_sym(p->table, v__ast__Table_value_type(p->table, rec.typ));
			is_non_local = elem_type_sym->mod.len > 0 && !string__eq(elem_type_sym->mod, p->mod) && elem_type_sym->language == v__ast__Language__v;
		}
		if (is_non_local) {
			v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot define new methods on non-local type "), 0xfe10, {.d_s = type_sym->name}}, {_SLIT0, 0, { .d_c = 0 }}})), rec.type_pos);
			v__ast__FnDecl _t18 = (v__ast__FnDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.is_deprecated = 0,.is_pub = 0,.is_variadic = 0,.is_anon = 0,.is_noreturn = 0,.is_manualfree = 0,.is_main = 0,.is_test = 0,.is_conditional = 0,.is_exported = 0,.is_keep_alive = 0,.is_unsafe = 0,.is_markused = 0,.receiver = (v__ast__StructField){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.has_default_expr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_pub = 0,.default_val = (string){.str=(byteptr)"", .is_lit=1},.is_mut = 0,.is_global = 0,.is_volatile = 0,.default_expr_typ = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,},.receiver_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.is_method = 0,.method_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.method_idx = 0,.rec_mut = 0,.rec_share = 0,.language = 0,.file_mode = 0,.no_body = 0,.is_builtin = 0,.body_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.file = (string){.str=(byteptr)"", .is_lit=1},.generic_names = __new_array(0, 0, sizeof(string)),.is_direct_arr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.ctdefine_idx = -1,.params = __new_array(0, 0, sizeof(v__ast__Param)),.stmts = __new_array(0, 0, sizeof(v__ast__Stmt)),.defer_stmts = __new_array(0, 0, sizeof(v__ast__DeferStmt)),.return_type = 0,.return_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.has_return = 0,.should_be_skipped = 0,.ninstances = 0,.has_await = 0,.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.next_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.source_file = 0,.scope = 0,.label_names = __new_array(0, 0, sizeof(string)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},};
			return _t18;
		}
		type_sym_method_idx = v__ast__TypeSymbol_register_method(type_sym, (v__ast__Fn){
			.is_variadic = is_variadic,
			.language = language,
			.is_pub = is_pub,
			.is_ctor_new = 0,
			.is_deprecated = is_deprecated,
			.is_noreturn = is_noreturn,
			.is_unsafe = is_unsafe,
			.is_placeholder = 0,
			.is_main = is_main,
			.is_test = is_test,
			.is_keep_alive = is_keep_alive,
			.is_method = true,
			.no_body = no_body,
			.mod = p->mod,
			.file = p->file_name,
			.file_mode = file_mode,
			.pos = start_pos,
			.return_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},
			.return_type = return_type,
			.receiver_type = rec.typ,
			.name = name,
			.params = params,
			.source_fn = 0,
			.usages = 0,
			.generic_names = generic_names,
			.attrs = p->attrs,
			.is_conditional = conditional_ctdefine_idx != -1,
			.ctdefine_idx = conditional_ctdefine_idx,
		});
	} else {
		if (language == v__ast__Language__c) {
			name =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("C."), 0xfe10, {.d_s = name}}, {_SLIT0, 0, { .d_c = 0 }}}));
		} else if (language == v__ast__Language__js) {
			name =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("JS."), 0xfe10, {.d_s = name}}, {_SLIT0, 0, { .d_c = 0 }}}));
		} else {
			name = v__parser__Parser_prepend_mod(p, name);
		}
		if (!p->pref->translated && language == v__ast__Language__v) {
			v__ast__Fn* _t20 = (v__ast__Fn*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, p->table->fns), &(string[]){name}));
			Option_v__ast__Fn _t19 = {0};
			if (_t20) {
				*((v__ast__Fn*)&_t19.data) = *((v__ast__Fn*)_t20);
			} else {
				_t19.state = 2; _t19.err = _v_error(_SLIT("array index out of range"));
			}
			
			if (_t19.state == 0) {
				v__ast__Fn existing = *(v__ast__Fn*)_t19.data;
				if ((existing.name).len != 0) {
					if (file_mode == v__ast__Language__v && existing.file_mode != v__ast__Language__v) {
						if (!p->pref->is_fmt) {
							name = v__parser__Parser_prepend_mod(p,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("pure_v_but_overriden_by_"), 0xfe10, {.d_s = v__ast__Language_str(existing.file_mode)}}, {_SLIT("_"), 0xfe10, {.d_s = short_fn_name}}, {_SLIT0, 0, { .d_c = 0 }}})));
						}
					} else {
						array_push((array*)&p->table->redefined_fns, _MOV((string[]){ string_clone(name) }));
					}
				}
			}
		}
		v__ast__Table_register_fn(p->table, (v__ast__Fn){
			.is_variadic = is_variadic,
			.language = language,
			.is_pub = is_pub,
			.is_ctor_new = is_ctor_new,
			.is_deprecated = is_deprecated,
			.is_noreturn = is_noreturn,
			.is_unsafe = is_unsafe,
			.is_placeholder = 0,
			.is_main = is_main,
			.is_test = is_test,
			.is_keep_alive = is_keep_alive,
			.is_method = false,
			.no_body = no_body,
			.mod = p->mod,
			.file = p->file_name,
			.file_mode = file_mode,
			.pos = start_pos,
			.return_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},
			.return_type = return_type,
			.receiver_type = 0,
			.name = name,
			.params = params,
			.source_fn = 0,
			.usages = 0,
			.generic_names = generic_names,
			.attrs = p->attrs,
			.is_conditional = conditional_ctdefine_idx != -1,
			.ctdefine_idx = conditional_ctdefine_idx,
		});
	}
	p->cur_fn_name = name;
	Array_v__ast__Stmt stmts = __new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
	v__token__Position body_start_pos = v__token__Token_position(&p->peek_tok);
	if (p->tok.kind == v__token__Kind__lcbr) {
		if (language != v__ast__Language__v && language != v__ast__Language__js) {
			v__parser__Parser_error_with_pos(p, _SLIT("interop functions cannot have a body"), v__token__Token_position(&p->tok));
		}
		p->inside_fn = true;
		p->inside_unsafe_fn = is_unsafe;
		stmts = v__parser__Parser_parse_block_no_scope(p, true);
		p->inside_unsafe_fn = false;
		p->inside_fn = false;
	}
	if (!no_body && are_args_type_only) {
		v__parser__Parser_error_with_pos(p, _SLIT("functions with type only args can not have bodies"), body_start_pos);
		v__ast__FnDecl _t22 = (v__ast__FnDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.is_deprecated = 0,.is_pub = 0,.is_variadic = 0,.is_anon = 0,.is_noreturn = 0,.is_manualfree = 0,.is_main = 0,.is_test = 0,.is_conditional = 0,.is_exported = 0,.is_keep_alive = 0,.is_unsafe = 0,.is_markused = 0,.receiver = (v__ast__StructField){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.has_default_expr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_pub = 0,.default_val = (string){.str=(byteptr)"", .is_lit=1},.is_mut = 0,.is_global = 0,.is_volatile = 0,.default_expr_typ = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,},.receiver_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.is_method = 0,.method_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.method_idx = 0,.rec_mut = 0,.rec_share = 0,.language = 0,.file_mode = 0,.no_body = 0,.is_builtin = 0,.body_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.file = (string){.str=(byteptr)"", .is_lit=1},.generic_names = __new_array(0, 0, sizeof(string)),.is_direct_arr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.ctdefine_idx = -1,.params = __new_array(0, 0, sizeof(v__ast__Param)),.stmts = __new_array(0, 0, sizeof(v__ast__Stmt)),.defer_stmts = __new_array(0, 0, sizeof(v__ast__DeferStmt)),.return_type = 0,.return_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.has_return = 0,.should_be_skipped = 0,.ninstances = 0,.has_await = 0,.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.next_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.source_file = 0,.scope = 0,.label_names = __new_array(0, 0, sizeof(string)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},};
		return _t22;
	}
	v__ast__FnDecl fn_decl = (v__ast__FnDecl){
		.name = name,
		.mod = p->mod,
		.is_deprecated = is_deprecated,
		.is_pub = is_pub,
		.is_variadic = is_variadic,
		.is_anon = 0,
		.is_noreturn = is_noreturn,
		.is_manualfree = is_manualfree,
		.is_main = is_main,
		.is_test = is_test,
		.is_conditional = conditional_ctdefine_idx != -1,
		.is_exported = is_exported,
		.is_keep_alive = is_keep_alive,
		.is_unsafe = is_unsafe,
		.is_markused = is_markused,
		.receiver = (v__ast__StructField){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.has_default_expr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_pub = 0,.default_val = (string){.str=(byteptr)"", .is_lit=1},.is_mut = 0,.is_global = 0,.is_volatile = 0,.default_expr = {0},.default_expr_typ = 0,.name = rec.name,.typ = rec.typ,},
		.receiver_pos = rec.pos,
		.is_method = is_method,
		.method_type_pos = rec.type_pos,
		.method_idx = type_sym_method_idx,
		.rec_mut = rec.is_mut,
		.rec_share = 0,
		.language = language,
		.file_mode = 0,
		.no_body = no_body,
		.is_builtin = p->builtin_mod || Array_string_contains(_const_v__util__builtin_module_parts, p->mod),
		.body_pos = body_start_pos,
		.file = p->file_name,
		.generic_names = generic_names,
		.is_direct_arr = is_direct_arr,
		.attrs = p->attrs,
		.ctdefine_idx = conditional_ctdefine_idx,
		.params = params,
		.stmts = stmts,
		.defer_stmts = __new_array(0, 0, sizeof(v__ast__DeferStmt)),
		.return_type = return_type,
		.return_type_pos = return_type_pos,
		.has_return = 0,
		.should_be_skipped = 0,
		.ninstances = 0,
		.has_await = 0,
		.comments = __new_array(0, 0, sizeof(v__ast__Comment)),
		.next_comments = __new_array(0, 0, sizeof(v__ast__Comment)),
		.source_file = 0,
		.scope = p->scope,
		.label_names = p->label_names,
		.pos = v__token__Position_extend_with_last_line(start_pos, end_pos, p->prev_tok.line_nr),
	};
	if (generic_names.len > 0) {
		v__ast__Table_register_fn_generic_types(p->table, v__ast__FnDecl_fkey(&fn_decl));
	}
	p->label_names = __new_array_with_default(0, 0, sizeof(string), 0);
	v__parser__Parser_close_scope(p);
	v__ast__FnDecl _t23 = fn_decl;
	return _t23;
}

VV_LOCAL_SYMBOL Option_void v__parser__Parser_fn_receiver(v__parser__Parser* p, Array_v__ast__Param* params, v__parser__ReceiverParsingInfo* rec) {
bool v__parser__Parser_fn_receiver_defer_0 = false;
	p->inside_receiver_param = true;
	v__parser__Parser_fn_receiver_defer_0 = true;
	v__token__Position lpar_pos = v__token__Token_position(&p->tok);
	v__parser__Parser_next(p);
	bool is_shared = p->tok.kind == v__token__Kind__key_shared;
	bool is_atomic = p->tok.kind == v__token__Kind__key_atomic;
	rec->is_mut = p->tok.kind == v__token__Kind__key_mut || is_shared || is_atomic;
	if (rec->is_mut) {
		v__parser__Parser_next(p);
	}
	v__token__Position rec_start_pos = v__token__Token_position(&p->tok);
	rec->name = v__parser__Parser_check_name(p);
	if (!rec->is_mut) {
		rec->is_mut = p->tok.kind == v__token__Kind__key_mut;
		if (rec->is_mut) {
			v__token__Token ptoken2 = v__parser__Parser_peek_token(p, 2);
			v__parser__Parser_warn_with_pos(p, _SLIT("use `(mut f Foo)` instead of `(f mut Foo)`"), v__token__Position_extend(lpar_pos, v__token__Token_position(&ptoken2)));
		}
	}
	if (p->tok.kind == v__token__Kind__key_shared) {
		v__token__Token ptoken2 = v__parser__Parser_peek_token(p, 2);
		v__parser__Parser_error_with_pos(p, _SLIT("use `(shared f Foo)` instead of `(f shared Foo)`"), v__token__Position_extend(lpar_pos, v__token__Token_position(&ptoken2)));
	}
	rec->pos = v__token__Position_extend(rec_start_pos, v__token__Token_position(&p->tok));
	bool is_amp = p->tok.kind == v__token__Kind__amp;
	if (p->tok.kind == v__token__Kind__name && string__eq(p->tok.lit, _SLIT("JS"))) {
		rec->language = v__ast__Language__js;
	}
	rec->type_pos = v__token__Token_position(&p->tok);
	rec->typ = v__parser__Parser_parse_type_with_mut(p, rec->is_mut);
	if (v__ast__Type_idx(rec->typ) == 0) {
		Option_void _t1 = (Option_void){ .state=2, .err=_v_error(_SLIT("void receiver type")), .data={EMPTY_STRUCT_INITIALIZATION} };
		// Defer begin
		if (v__parser__Parser_fn_receiver_defer_0) {
			p->inside_receiver_param = false;
		}
		// Defer end
		return _t1;
	}
	rec->type_pos = v__token__Position_extend(rec->type_pos, v__token__Token_position(&p->prev_tok));
	if (is_amp && rec->is_mut) {
		v__parser__Parser_error_with_pos(p, _SLIT("use `(mut f Foo)` or `(f &Foo)` instead of `(mut f &Foo)`"), v__token__Position_extend(lpar_pos, v__token__Token_position(&p->tok)));
		Option_void _t2 = (Option_void){ .state=2, .err=_v_error(_SLIT("invalid `mut f &Foo`")), .data={EMPTY_STRUCT_INITIALIZATION} };
		// Defer begin
		if (v__parser__Parser_fn_receiver_defer_0) {
			p->inside_receiver_param = false;
		}
		// Defer end
		return _t2;
	}
	if (is_shared) {
		rec->typ = v__ast__Type_set_flag(rec->typ, v__ast__TypeFlag__shared_f);
	}
	if (is_atomic) {
		rec->typ = v__ast__Type_set_flag(rec->typ, v__ast__TypeFlag__atomic_f);
	}
	v__ast__TypeSymbol* type_sym = v__ast__Table_sym(p->table, rec->typ);
	bool is_auto_rec = false;
	if (type_sym->kind == v__ast__Kind__struct_) {
		v__ast__Struct info = /* as */ *(v__ast__Struct*)__as_cast((type_sym->info)._v__ast__Struct,(type_sym->info)._typ, 446) /*expected idx: 446, name: v.ast.Struct */ ;
		if (!rec->is_mut && !v__ast__Type_is_ptr(rec->typ) && info.fields.len > 8) {
			rec->typ = v__ast__Type_ref(rec->typ);
			is_auto_rec = true;
		}
	}
	if (rec->language != v__ast__Language__v) {
		v__parser__Parser_check_for_impure_v(p, rec->language, rec->type_pos);
	}
	array_push((array*)params, _MOV((v__ast__Param[]){ (v__ast__Param){
		.pos = rec_start_pos,
		.name = rec->name,
		.is_mut = rec->is_mut,
		.is_auto_rec = is_auto_rec,
		.type_pos = rec->type_pos,
		.is_hidden = 0,
		.typ = rec->typ,
	} }));
	v__parser__Parser_check(p, v__token__Kind__rpar);
	// Defer begin
	if (v__parser__Parser_fn_receiver_defer_0) {
		p->inside_receiver_param = false;
	}
	// Defer end
	return (Option_void){0};
}

VV_LOCAL_SYMBOL v__ast__AnonFn v__parser__Parser_anon_fn(v__parser__Parser* p) {
bool v__parser__Parser_anon_fn_defer_0 = false;
	v__token__Position pos = v__token__Token_position(&p->tok);
	v__parser__Parser_check(p, v__token__Kind__key_fn);
	if (p->pref->is_script && p->tok.kind == v__token__Kind__name) {
		v__parser__Parser_error_with_pos(p, _SLIT("function declarations in script mode should be before all script statements"), v__token__Token_position(&p->tok));
		v__ast__AnonFn _t1 = (v__ast__AnonFn){.decl = (v__ast__FnDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.is_deprecated = 0,.is_pub = 0,.is_variadic = 0,.is_anon = 0,.is_noreturn = 0,.is_manualfree = 0,.is_main = 0,.is_test = 0,.is_conditional = 0,.is_exported = 0,.is_keep_alive = 0,.is_unsafe = 0,.is_markused = 0,.receiver = (v__ast__StructField){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.has_default_expr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_pub = 0,.default_val = (string){.str=(byteptr)"", .is_lit=1},.is_mut = 0,.is_global = 0,.is_volatile = 0,.default_expr_typ = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,},.receiver_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.is_method = 0,.method_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.method_idx = 0,.rec_mut = 0,.no_body = 0,.is_builtin = 0,.body_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.file = (string){.str=(byteptr)"", .is_lit=1},.generic_names = __new_array(0, 0, sizeof(string)),.is_direct_arr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.ctdefine_idx = -1,.params = __new_array(0, 0, sizeof(v__ast__Param)),.stmts = __new_array(0, 0, sizeof(v__ast__Stmt)),.defer_stmts = __new_array(0, 0, sizeof(v__ast__DeferStmt)),.return_type = 0,.return_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.has_return = 0,.should_be_skipped = 0,.ninstances = 0,.has_await = 0,.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.next_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.source_file = 0,.scope = 0,.label_names = __new_array(0, 0, sizeof(string)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},},.inherited_vars = __new_array(0, 0, sizeof(v__ast__Param)),.typ = 0,.has_gen = 0,};
		return _t1;
	}
	bool old_inside_defer = p->inside_defer;
	p->inside_defer = false;
	v__parser__Parser_open_scope(p);
	v__parser__Parser_anon_fn_defer_0 = true;
	p->scope->detached_from_parent = true;
	Array_v__ast__Param inherited_vars = (p->tok.kind == v__token__Kind__lsbr ? (v__parser__Parser_closure_vars(p)) : (__new_array_with_default(0, 0, sizeof(v__ast__Param), 0)));
	multi_return_Array_v__ast__Param_bool_bool mr_17826 = v__parser__Parser_fn_args(p);
	Array_v__ast__Param args = mr_17826.arg0;
	bool is_variadic = mr_17826.arg2;
	for (int _t2 = 0; _t2 < args.len; ++_t2) {
		v__ast__Param arg = ((v__ast__Param*)args.data)[_t2];
		if (arg.name.len == 0) {
			v__parser__Parser_error_with_pos(p, _SLIT("use `_` to name an unused parameter"), arg.pos);
		}
		bool is_stack_obj = !v__ast__Type_has_flag(arg.typ, v__ast__TypeFlag__shared_f) && (arg.is_mut || v__ast__Type_is_ptr(arg.typ));
		v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){
			.name = arg.name,
			.expr = {0},
			.share = 0,
			.is_mut = arg.is_mut,
			.is_autofree_tmp = 0,
			.is_arg = true,
			.is_auto_deref = 0,
			.is_inherited = 0,
			.typ = arg.typ,
			.orig_type = 0,
			.smartcasts = __new_array(0, 0, sizeof(v__ast__Type)),
			.pos = arg.pos,
			.is_used = true,
			.is_changed = 0,
			.is_or = 0,
			.is_tmp = 0,
			.is_auto_heap = 0,
			.is_stack_obj = is_stack_obj,
		}))));
	}
	bool same_line = p->tok.line_nr == p->prev_tok.line_nr;
	v__ast__Type return_type = _const_v__ast__void_type;
	v__token__Position return_type_pos = v__token__Token_position(&p->tok);
	if (same_line) {
		if ((v__token__Kind_is_start_of_type(p->tok.kind) && (same_line || p->tok.kind != v__token__Kind__lsbr)) || (same_line && p->tok.kind == v__token__Kind__key_fn)) {
			return_type = v__parser__Parser_parse_type(p);
			return_type_pos = v__token__Position_extend(return_type_pos, v__token__Token_position(&p->tok));
		} else if (p->tok.kind != v__token__Kind__lcbr) {
			v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("expected return type, not "), 0xfe10, {.d_s = v__token__Token_str(p->tok)}}, {_SLIT(" for anonymous function"), 0, { .d_c = 0 }}})), v__token__Token_position(&p->tok));
		}
	}
	Array_v__ast__Stmt stmts = __new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
	bool no_body = p->tok.kind != v__token__Kind__lcbr;
	same_line = p->tok.line_nr == p->prev_tok.line_nr;
	if (no_body && same_line) {
		v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unexpected "), 0xfe10, {.d_s = v__token__Token_str(p->tok)}}, {_SLIT(" after anonymous function signature, expecting `{`"), 0, { .d_c = 0 }}})), v__token__Token_position(&p->tok));
	}
	Array_string label_names = __new_array_with_default(0, 0, sizeof(string), 0);
	v__ast__Fn func = (v__ast__Fn){.is_variadic = is_variadic,.language = 0,.is_pub = 0,.is_ctor_new = 0,.is_deprecated = 0,.is_noreturn = 0,.is_unsafe = 0,.is_placeholder = 0,.is_main = 0,.is_test = 0,.is_keep_alive = 0,.is_method = false,.no_body = 0,.mod = (string){.str=(byteptr)"", .is_lit=1},.file = (string){.str=(byteptr)"", .is_lit=1},.file_mode = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.return_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.return_type = return_type,.receiver_type = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.params = args,.source_fn = 0,.usages = 0,.generic_names = __new_array(0, 0, sizeof(string)),.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_conditional = 0,.ctdefine_idx = 0,};
	string name =  str_intp(4, _MOV((StrIntpData[]){{_SLIT("anon_fn_"), 0xfe10, {.d_s = p->unique_prefix}}, {_SLIT("_"), 0xfe10, {.d_s = v__ast__Table_fn_type_signature(p->table, (voidptr)&/*qq*/func)}}, {_SLIT("_"), 0xfe07, {.d_i32 = p->tok.pos}}, {_SLIT0, 0, { .d_c = 0 }}}));
	string keep_fn_name = p->cur_fn_name;
	p->cur_fn_name = name;
	if (p->tok.kind == v__token__Kind__lcbr) {
		Array_string tmp = p->label_names;
		p->label_names = __new_array_with_default(0, 0, sizeof(string), 0);
		stmts = v__parser__Parser_parse_block_no_scope(p, false);
		label_names = p->label_names;
		p->label_names = tmp;
	}
	p->cur_fn_name = keep_fn_name;
	func.name = name;
	int idx = v__ast__Table_find_or_register_fn_type(p->table, p->mod, func, true, false);
	v__ast__Type typ = v__ast__new_type(idx);
	p->inside_defer = old_inside_defer;
	v__ast__AnonFn _t3 = (v__ast__AnonFn){.decl = (v__ast__FnDecl){
		.name = name,
		.mod = p->mod,
		.is_deprecated = 0,
		.is_pub = 0,
		.is_variadic = is_variadic,
		.is_anon = true,
		.is_noreturn = 0,
		.is_manualfree = 0,
		.is_main = 0,
		.is_test = 0,
		.is_conditional = 0,
		.is_exported = 0,
		.is_keep_alive = 0,
		.is_unsafe = 0,
		.is_markused = 0,
		.receiver = (v__ast__StructField){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.has_default_expr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_pub = 0,.default_val = (string){.str=(byteptr)"", .is_lit=1},.is_mut = 0,.is_global = 0,.is_volatile = 0,.default_expr_typ = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,},
		.receiver_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},
		.is_method = false,
		.method_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},
		.method_idx = 0,
		.rec_mut = 0,
		.rec_share = 0,
		.language = 0,
		.file_mode = 0,
		.no_body = no_body,
		.is_builtin = 0,
		.body_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},
		.file = p->file_name,
		.generic_names = __new_array(0, 0, sizeof(string)),
		.is_direct_arr = 0,
		.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),
		.ctdefine_idx = -1,
		.params = args,
		.stmts = stmts,
		.defer_stmts = __new_array(0, 0, sizeof(v__ast__DeferStmt)),
		.return_type = return_type,
		.return_type_pos = return_type_pos,
		.has_return = 0,
		.should_be_skipped = 0,
		.ninstances = 0,
		.has_await = 0,
		.comments = __new_array(0, 0, sizeof(v__ast__Comment)),
		.next_comments = __new_array(0, 0, sizeof(v__ast__Comment)),
		.source_file = 0,
		.scope = p->scope,
		.label_names = label_names,
		.pos = v__token__Position_extend(pos, v__token__Token_position(&p->prev_tok)),
	},.inherited_vars = inherited_vars,.typ = typ,.has_gen = 0,};
	// Defer begin
	if (v__parser__Parser_anon_fn_defer_0) {
		v__parser__Parser_close_scope(p);
	}
	// Defer end
	return _t3;
}

VV_LOCAL_SYMBOL multi_return_Array_v__ast__Param_bool_bool v__parser__Parser_fn_args(v__parser__Parser* p) {
	v__parser__Parser_check(p, v__token__Kind__lpar);
	Array_v__ast__Param args = __new_array_with_default(0, 0, sizeof(v__ast__Param), 0);
	bool is_variadic = false;
	string argname = (p->tok.kind == v__token__Kind__name && p->tok.lit.len > 0 && byte_is_capital(string_at(p->tok.lit, 0)) ? (v__parser__Parser_prepend_mod(p, p->tok.lit)) : (p->tok.lit));
	bool types_only = (p->tok.kind == v__token__Kind__amp || p->tok.kind == v__token__Kind__ellipsis || p->tok.kind == v__token__Kind__key_fn || p->tok.kind == v__token__Kind__lsbr) || (p->peek_tok.kind == v__token__Kind__comma && v__ast__Table_known_type(p->table, argname)) || p->peek_tok.kind == v__token__Kind__dot || p->peek_tok.kind == v__token__Kind__rpar || (p->tok.kind == v__token__Kind__key_mut && (v__parser__Parser_peek_token(p, 2).kind == v__token__Kind__comma || v__parser__Parser_peek_token(p, 2).kind == v__token__Kind__rpar));
	if (types_only) {
		int arg_no = 1;
		for (;;) {
			if (!(p->tok.kind != v__token__Kind__rpar)) break;
			if (p->tok.kind == v__token__Kind__eof) {
				v__parser__Parser_error_with_pos(p, _SLIT("expecting `)`"), v__token__Token_position(&p->tok));
				return (multi_return_Array_v__ast__Param_bool_bool){.arg0=__new_array_with_default(0, 0, sizeof(v__ast__Param), 0), .arg1=false, .arg2=false};
			}
			bool is_shared = p->tok.kind == v__token__Kind__key_shared;
			bool is_atomic = p->tok.kind == v__token__Kind__key_atomic;
			bool is_mut = p->tok.kind == v__token__Kind__key_mut || is_shared || is_atomic;
			if (is_mut) {
				v__parser__Parser_next(p);
			}
			if (p->tok.kind == v__token__Kind__ellipsis) {
				v__parser__Parser_next(p);
				is_variadic = true;
			}
			v__token__Position pos = v__token__Token_position(&p->tok);
			v__ast__Type arg_type = v__parser__Parser_parse_type(p);
			if (arg_type == 0) {
				return (multi_return_Array_v__ast__Param_bool_bool){.arg0=__new_array_with_default(0, 0, sizeof(v__ast__Param), 0), .arg1=false, .arg2=false};
			}
			if (is_mut) {
				if (!v__ast__Type_has_flag(arg_type, v__ast__TypeFlag__generic)) {
					if (is_shared) {
						v__parser__Parser_check_fn_shared_arguments(p, arg_type, pos);
					} else if (is_atomic) {
						v__parser__Parser_check_fn_atomic_arguments(p, arg_type, pos);
					} else {
						v__parser__Parser_check_fn_mutable_arguments(p, arg_type, pos);
					}
				} else if (is_shared || is_atomic) {
					v__parser__Parser_error_with_pos(p, _SLIT("generic object cannot be `atomic`or `shared`"), pos);
					return (multi_return_Array_v__ast__Param_bool_bool){.arg0=__new_array_with_default(0, 0, sizeof(v__ast__Param), 0), .arg1=false, .arg2=false};
				}
				arg_type = v__ast__Type_set_nr_muls(arg_type, 1);
				if (is_shared) {
					arg_type = v__ast__Type_set_flag(arg_type, v__ast__TypeFlag__shared_f);
				}
				if (is_atomic) {
					arg_type = v__ast__Type_set_flag(arg_type, v__ast__TypeFlag__atomic_f);
				}
			}
			if (is_variadic) {
				arg_type = v__ast__Type_set_flag(v__ast__new_type(v__ast__Table_find_or_register_array(p->table, arg_type)), v__ast__TypeFlag__variadic);
			}
			if (p->tok.kind == v__token__Kind__eof) {
				v__parser__Parser_error_with_pos(p, _SLIT("expecting `)`"), v__token__Token_position(&p->prev_tok));
				return (multi_return_Array_v__ast__Param_bool_bool){.arg0=__new_array_with_default(0, 0, sizeof(v__ast__Param), 0), .arg1=false, .arg2=false};
			}
			if (p->tok.kind == v__token__Kind__comma) {
				if (is_variadic) {
					v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot use ...(variadic) with non-final parameter no "), 0xfe07, {.d_i32 = arg_no}}, {_SLIT0, 0, { .d_c = 0 }}})), pos);
					return (multi_return_Array_v__ast__Param_bool_bool){.arg0=__new_array_with_default(0, 0, sizeof(v__ast__Param), 0), .arg1=false, .arg2=false};
				}
				v__parser__Parser_next(p);
			}
			v__ast__Language alanguage = v__ast__Table_sym(p->table, arg_type)->language;
			if (alanguage != v__ast__Language__v) {
				v__parser__Parser_check_for_impure_v(p, alanguage, pos);
			}
			array_push((array*)&args, _MOV((v__ast__Param[]){ (v__ast__Param){.pos = pos,.name = _SLIT(""),.is_mut = is_mut,.is_auto_rec = 0,.type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.is_hidden = 0,.typ = arg_type,} }));
			arg_no++;
			if (arg_no > 1024) {
				v__parser__Parser_error_with_pos(p, _SLIT("too many args"), pos);
				return (multi_return_Array_v__ast__Param_bool_bool){.arg0=__new_array_with_default(0, 0, sizeof(v__ast__Param), 0), .arg1=false, .arg2=false};
			}
		}
	} else {
		for (;;) {
			if (!(p->tok.kind != v__token__Kind__rpar)) break;
			if (p->tok.kind == v__token__Kind__eof) {
				v__parser__Parser_error_with_pos(p, _SLIT("expecting `)`"), v__token__Token_position(&p->tok));
				return (multi_return_Array_v__ast__Param_bool_bool){.arg0=__new_array_with_default(0, 0, sizeof(v__ast__Param), 0), .arg1=false, .arg2=false};
			}
			bool is_shared = p->tok.kind == v__token__Kind__key_shared;
			bool is_atomic = p->tok.kind == v__token__Kind__key_atomic;
			bool is_mut = p->tok.kind == v__token__Kind__key_mut || is_shared || is_atomic;
			if (is_mut) {
				v__parser__Parser_next(p);
			}
			Array_v__token__Position arg_pos = new_array_from_c_array(1, 1, sizeof(v__token__Position), _MOV((v__token__Position[1]){v__token__Token_position(&p->tok)}));
			Array_string arg_names = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){string_clone(v__parser__Parser_check_name(p))}));
			Array_v__token__Position type_pos = new_array_from_c_array(1, 1, sizeof(v__token__Position), _MOV((v__token__Position[1]){v__token__Token_position(&p->tok)}));
			for (;;) {
				if (!(p->tok.kind == v__token__Kind__comma)) break;
				if (!p->pref->is_fmt) {
					v__parser__Parser_warn(p, string__plus(_SLIT("`fn f(x, y Type)` syntax has been deprecated and will soon be removed. "),  str_intp(2, _MOV((StrIntpData[]){{_SLIT("Use `fn f(x Type, y Type)` instead. You can run `v fmt -w \""), 0xfe10, {.d_s = p->scanner->file_path}}, {_SLIT("\"` to automatically fix your code."), 0, { .d_c = 0 }}}))));
				}
				v__parser__Parser_next(p);
				array_push((array*)&arg_pos, _MOV((v__token__Position[]){ v__token__Token_position(&p->tok) }));
				array_push((array*)&arg_names, _MOV((string[]){ string_clone(v__parser__Parser_check_name(p)) }));
				array_push((array*)&type_pos, _MOV((v__token__Position[]){ v__token__Token_position(&p->tok) }));
			}
			if (p->tok.kind == v__token__Kind__key_mut) {
				if (!p->pref->is_fmt) {
					v__parser__Parser_warn_with_pos(p, _SLIT("use `mut f Foo` instead of `f mut Foo`"), v__token__Token_position(&p->tok));
				}
				is_mut = true;
			}
			if (p->tok.kind == v__token__Kind__key_shared) {
				v__parser__Parser_error_with_pos(p, _SLIT("use `shared f Foo` instead of `f shared Foo`"), v__token__Token_position(&p->tok));
			}
			if (p->tok.kind == v__token__Kind__ellipsis) {
				v__parser__Parser_next(p);
				is_variadic = true;
			}
			v__token__Position pos = v__token__Token_position(&p->tok);
			v__ast__Type typ = v__parser__Parser_parse_type(p);
			if (typ == 0) {
				return (multi_return_Array_v__ast__Param_bool_bool){.arg0=__new_array_with_default(0, 0, sizeof(v__ast__Param), 0), .arg1=false, .arg2=false};
			}
			if (is_mut) {
				if (!v__ast__Type_has_flag(typ, v__ast__TypeFlag__generic)) {
					if (is_shared) {
						v__parser__Parser_check_fn_shared_arguments(p, typ, pos);
					} else if (is_atomic) {
						v__parser__Parser_check_fn_atomic_arguments(p, typ, pos);
					} else {
						v__parser__Parser_check_fn_mutable_arguments(p, typ, pos);
					}
				} else if (is_shared || is_atomic) {
					v__parser__Parser_error_with_pos(p, _SLIT("generic object cannot be `atomic` or `shared`"), pos);
					return (multi_return_Array_v__ast__Param_bool_bool){.arg0=__new_array_with_default(0, 0, sizeof(v__ast__Param), 0), .arg1=false, .arg2=false};
				}
				typ = v__ast__Type_set_nr_muls(typ, 1);
				if (is_shared) {
					typ = v__ast__Type_set_flag(typ, v__ast__TypeFlag__shared_f);
				}
				if (is_atomic) {
					typ = v__ast__Type_set_flag(typ, v__ast__TypeFlag__atomic_f);
				}
			}
			if (is_variadic) {
				typ = v__ast__Type_set_flag(v__ast__Type_derive(v__ast__new_type(v__ast__Table_find_or_register_array(p->table, typ)), typ), v__ast__TypeFlag__variadic);
			}
			for (int i = 0; i < arg_names.len; ++i) {
				string arg_name = ((string*)arg_names.data)[i];
				v__ast__Language alanguage = v__ast__Table_sym(p->table, typ)->language;
				if (alanguage != v__ast__Language__v) {
					v__parser__Parser_check_for_impure_v(p, alanguage, (*(v__token__Position*)/*ee elem_typ */array_get(type_pos, i)));
				}
				array_push((array*)&args, _MOV((v__ast__Param[]){ (v__ast__Param){.pos = (*(v__token__Position*)/*ee elem_typ */array_get(arg_pos, i)),.name = arg_name,.is_mut = is_mut,.is_auto_rec = 0,.type_pos = (*(v__token__Position*)/*ee elem_typ */array_get(type_pos, i)),.is_hidden = 0,.typ = typ,} }));
				if (is_variadic && p->tok.kind == v__token__Kind__comma) {
					v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot use ...(variadic) with non-final parameter "), 0xfe10, {.d_s = arg_name}}, {_SLIT0, 0, { .d_c = 0 }}})), (*(v__token__Position*)/*ee elem_typ */array_get(arg_pos, i)));
					return (multi_return_Array_v__ast__Param_bool_bool){.arg0=__new_array_with_default(0, 0, sizeof(v__ast__Param), 0), .arg1=false, .arg2=false};
				}
			}
			if (p->tok.kind == v__token__Kind__eof) {
				v__parser__Parser_error_with_pos(p, _SLIT("expecting `)`"), v__token__Token_position(&p->prev_tok));
				return (multi_return_Array_v__ast__Param_bool_bool){.arg0=__new_array_with_default(0, 0, sizeof(v__ast__Param), 0), .arg1=false, .arg2=false};
			}
			if (p->tok.kind != v__token__Kind__rpar) {
				v__parser__Parser_check(p, v__token__Kind__comma);
			}
		}
	}
	v__parser__Parser_check(p, v__token__Kind__rpar);
	return (multi_return_Array_v__ast__Param_bool_bool){.arg0=args, .arg1=types_only, .arg2=is_variadic};
}

VV_LOCAL_SYMBOL Array_v__ast__Param v__parser__Parser_closure_vars(v__parser__Parser* p) {
	v__parser__Parser_check(p, v__token__Kind__lsbr);
	Array_v__ast__Param vars = __new_array_with_default(0, 5, sizeof(v__ast__Param), 0);
	for (;;) {
		bool is_shared = p->tok.kind == v__token__Kind__key_shared;
		bool is_atomic = p->tok.kind == v__token__Kind__key_atomic;
		bool is_mut = p->tok.kind == v__token__Kind__key_mut || is_shared || is_atomic;
		if (is_mut) {
			v__parser__Parser_next(p);
		}
		v__token__Position var_pos = v__token__Token_position(&p->tok);
		v__parser__Parser_check(p, v__token__Kind__name);
		string var_name = p->prev_tok.lit;
		Option_v__ast__Var_ptr _t1 = v__ast__Scope_find_var(p->scope->parent, var_name);
		if (_t1.state != 0) { /*or block*/ 
			IError err = _t1.err;
			v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("undefined ident: `"), 0xfe10, {.d_s = var_name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), v__token__Token_position(&p->prev_tok));
			continue;
		}
		
 		v__ast__Var* var =  (*(v__ast__Var**)_t1.data);
		var->is_used = true;
		if (is_mut) {
			var->is_changed = true;
		}
		v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){(*var).name,(*var).expr,(*var).share,.is_mut = is_mut,(*var).is_autofree_tmp,(*var).is_arg,(*var).is_auto_deref,.is_inherited = true,(*var).typ,(*var).orig_type,(*var).smartcasts,.pos = var_pos,.is_used = false,.is_changed = false,(*var).is_or,(*var).is_tmp,(*var).is_auto_heap,(*var).is_stack_obj,}))));
		array_push((array*)&vars, _MOV((v__ast__Param[]){ (v__ast__Param){.pos = var_pos,.name = var_name,.is_mut = is_mut,.is_auto_rec = 0,.type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.is_hidden = 0,.typ = 0,} }));
		if (p->tok.kind != v__token__Kind__comma) {
			break;
		}
		v__parser__Parser_next(p);
	}
	v__parser__Parser_check(p, v__token__Kind__rsbr);
	Array_v__ast__Param _t3 = vars;
	return _t3;
}

VV_LOCAL_SYMBOL void v__parser__Parser_check_fn_mutable_arguments(v__parser__Parser* p, v__ast__Type typ, v__token__Position pos) {
	v__ast__TypeSymbol* sym = v__ast__Table_sym(p->table, typ);
	if (sym->kind == v__ast__Kind__array || sym->kind == v__ast__Kind__array_fixed || sym->kind == v__ast__Kind__interface_ || sym->kind == v__ast__Kind__map || sym->kind == v__ast__Kind__placeholder || sym->kind == v__ast__Kind__struct_ || sym->kind == v__ast__Kind__generic_inst || sym->kind == v__ast__Kind__sum_type) {
		return;
	}
	if (v__ast__Type_is_ptr(typ) || v__ast__Type_is_pointer(typ)) {
		return;
	}
	if (sym->kind == v__ast__Kind__alias) {
		v__ast__Type atyp = (/* as */ *(v__ast__Alias*)__as_cast((sym->info)._v__ast__Alias,(sym->info)._typ, 460) /*expected idx: 460, name: v.ast.Alias */ ).parent_type;
		v__parser__Parser_check_fn_mutable_arguments(p, atyp, pos);
		return;
	}
	if (p->fn_language == v__ast__Language__c) {
		return;
	}
	v__parser__Parser_error_with_pos(p, string__plus(_SLIT("mutable arguments are only allowed for arrays, interfaces, maps, pointers, structs or their aliases\n"),  str_intp(4, _MOV((StrIntpData[]){{_SLIT("return values instead: `fn foo(mut n "), 0xfe10, {.d_s = sym->name}}, {_SLIT(") {` => `fn foo(n "), 0xfe10, {.d_s = sym->name}}, {_SLIT(") "), 0xfe10, {.d_s = sym->name}}, {_SLIT(" {`"), 0, { .d_c = 0 }}}))), pos);
}

VV_LOCAL_SYMBOL void v__parser__Parser_check_fn_shared_arguments(v__parser__Parser* p, v__ast__Type typ, v__token__Position pos) {
	v__ast__TypeSymbol* sym = v__ast__Table_sym(p->table, typ);
	if (!(sym->kind == v__ast__Kind__array || sym->kind == v__ast__Kind__struct_ || sym->kind == v__ast__Kind__map || sym->kind == v__ast__Kind__placeholder) && !v__ast__Type_is_ptr(typ)) {
		v__parser__Parser_error_with_pos(p, _SLIT("shared arguments are only allowed for arrays, maps, and structs\n"), pos);
	}
}

VV_LOCAL_SYMBOL void v__parser__Parser_check_fn_atomic_arguments(v__parser__Parser* p, v__ast__Type typ, v__token__Position pos) {
	v__ast__TypeSymbol* sym = v__ast__Table_sym(p->table, typ);
	if (!(sym->kind == v__ast__Kind__u32 || sym->kind == v__ast__Kind__int || sym->kind == v__ast__Kind__u64)) {
		v__parser__Parser_error_with_pos(p, string__plus(_SLIT("atomic arguments are only allowed for 32/64 bit integers\n"),  str_intp(3, _MOV((StrIntpData[]){{_SLIT("use shared arguments instead: `fn foo(atomic n "), 0xfe10, {.d_s = sym->name}}, {_SLIT(") {` => `fn foo(shared n "), 0xfe10, {.d_s = sym->name}}, {_SLIT(") {`"), 0, { .d_c = 0 }}}))), pos);
	}
}

VV_LOCAL_SYMBOL bool v__parser__have_fn_main(Array_v__ast__Stmt stmts) {
	for (int _t1 = 0; _t1 < stmts.len; ++_t1) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)stmts.data)[_t1];
		if ((stmt)._typ == 216 /* v.ast.FnDecl */) {
			if (string__eq((*stmt._v__ast__FnDecl).name, _SLIT("main.main")) && string__eq((*stmt._v__ast__FnDecl).mod, _SLIT("main"))) {
				bool _t2 = true;
				return _t2;
			}
		}
	}
	bool _t3 = false;
	return _t3;
}

VV_LOCAL_SYMBOL v__ast__Stmt v__parser__Parser_for_stmt(v__parser__Parser* p) {
	v__parser__Parser_check(p, v__token__Kind__key_for);
	v__token__Position pos = v__token__Token_position(&p->tok);
	v__parser__Parser_open_scope(p);
	p->inside_for = true;
	if (p->tok.kind == v__token__Kind__key_match) {
		v__ast__Stmt _t1 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error(p, _SLIT("cannot use `match` in `for` loop")))));
		return _t1;
	}
	if (p->tok.kind == v__token__Kind__lcbr) {
		p->inside_for = false;
		Array_v__ast__Stmt stmts = v__parser__Parser_parse_block_no_scope(p, false);
		v__token__Position_update_last_line(&pos, p->prev_tok.line_nr);
		v__ast__ForStmt for_stmt = (v__ast__ForStmt){.cond = {0},.stmts = stmts,.is_inf = true,.pos = pos,.label = (string){.str=(byteptr)"", .is_lit=1},.scope = p->scope,};
		v__parser__Parser_close_scope(p);
		v__ast__Stmt _t2 = v__ast__ForStmt_to_sumtype_v__ast__Stmt(&for_stmt);
		return _t2;
	} else if ((p->peek_tok.kind == v__token__Kind__decl_assign || p->peek_tok.kind == v__token__Kind__assign || p->peek_tok.kind == v__token__Kind__semicolon) || p->tok.kind == v__token__Kind__semicolon || (p->peek_tok.kind == v__token__Kind__comma && v__parser__Parser_peek_token(p, 2).kind != v__token__Kind__key_mut && v__parser__Parser_peek_token(p, 3).kind != v__token__Kind__key_in)) {
		if (p->tok.kind == v__token__Kind__key_mut) {
			v__ast__Stmt _t3 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error(p, _SLIT("`mut` is not needed in `for ;;` loops: use `for i := 0; i < n; i ++ {`")))));
			return _t3;
		}
		v__ast__Stmt init = v__ast__empty_stmt();
		v__ast__Expr cond = v__parser__Parser_new_true_expr(p);
		v__ast__Stmt inc = v__ast__empty_stmt();
		bool has_init = false;
		bool has_cond = false;
		bool has_inc = false;
		bool is_multi = p->peek_tok.kind == v__token__Kind__comma && v__parser__Parser_peek_token(p, 2).kind != v__token__Kind__key_mut && v__parser__Parser_peek_token(p, 3).kind != v__token__Kind__key_in;
		if ((p->peek_tok.kind == v__token__Kind__assign || p->peek_tok.kind == v__token__Kind__decl_assign) || is_multi) {
			init = v__parser__Parser_assign_stmt(p);
			has_init = true;
		}
		v__parser__Parser_check(p, v__token__Kind__semicolon);
		if (p->tok.kind != v__token__Kind__semicolon) {
			if (p->tok.kind == v__token__Kind__name && (p->peek_tok.kind == v__token__Kind__inc || p->peek_tok.kind == v__token__Kind__dec)) {
				v__ast__Stmt _t4 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error(p,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("cannot use "), 0xfe10, {.d_s = p->tok.lit}}, {_SLIT0, 0xfe10, {.d_s = v__token__Kind_str(p->peek_tok.kind)}}, {_SLIT(" as value"), 0, { .d_c = 0 }}}))))));
				return _t4;
			}
			cond = v__parser__Parser_expr(p, 0);
			has_cond = true;
		}
		v__parser__Parser_check(p, v__token__Kind__semicolon);
		if (!is_multi) {
			is_multi = p->peek_tok.kind == v__token__Kind__comma;
		}
		if (p->tok.kind != v__token__Kind__lcbr) {
			inc = v__parser__Parser_stmt(p, false);
			has_inc = true;
		}
		p->inside_for = false;
		Array_v__ast__Stmt stmts = v__parser__Parser_parse_block_no_scope(p, false);
		v__token__Position_update_last_line(&pos, p->prev_tok.line_nr);
		v__ast__ForCStmt for_c_stmt = (v__ast__ForCStmt){
			.init = init,
			.has_init = has_init,
			.cond = cond,
			.has_cond = has_cond,
			.inc = inc,
			.has_inc = has_inc,
			.is_multi = is_multi,
			.stmts = stmts,
			.pos = pos,
			.label = (string){.str=(byteptr)"", .is_lit=1},
			.scope = p->scope,
		};
		v__parser__Parser_close_scope(p);
		v__ast__Stmt _t5 = v__ast__ForCStmt_to_sumtype_v__ast__Stmt(&for_c_stmt);
		return _t5;
	} else if ((p->peek_tok.kind == v__token__Kind__key_in || p->peek_tok.kind == v__token__Kind__comma) || (p->tok.kind == v__token__Kind__key_mut && (v__parser__Parser_peek_token(p, 2).kind == v__token__Kind__key_in || v__parser__Parser_peek_token(p, 2).kind == v__token__Kind__comma))) {
		bool val_is_mut = p->tok.kind == v__token__Kind__key_mut;
		v__token__Position mut_pos = v__token__Token_position(&p->tok);
		if (val_is_mut) {
			v__parser__Parser_next(p);
		}
		v__token__Position key_var_pos = v__token__Token_position(&p->tok);
		v__token__Position val_var_pos = v__token__Token_position(&p->tok);
		string key_var_name = _SLIT("");
		string val_var_name = v__parser__Parser_check_name(p);
		if (p->tok.kind == v__token__Kind__comma) {
			if (val_is_mut) {
				v__parser__Parser_error_with_pos(p, _SLIT("index of array or key of map cannot be mutated"), mut_pos);
			}
			v__parser__Parser_next(p);
			if (p->tok.kind == v__token__Kind__key_mut) {
				v__parser__Parser_next(p);
				val_is_mut = true;
			}
			key_var_name = val_var_name;
			val_var_pos = v__token__Token_position(&p->tok);
			val_var_name = v__parser__Parser_check_name(p);
			if (string__eq(key_var_name, val_var_name) && !string__eq(key_var_name, _SLIT("_"))) {
				v__ast__Stmt _t6 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _SLIT("key and value in a for loop cannot be the same"), val_var_pos))));
				return _t6;
			}
			if (v__ast__Scope_known_var(p->scope, key_var_name)) {
				v__ast__Stmt _t7 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("redefinition of key iteration variable `"), 0xfe10, {.d_s = key_var_name}}, {_SLIT("`"), 0, { .d_c = 0 }}}))))));
				return _t7;
			}
			if (v__ast__Scope_known_var(p->scope, val_var_name)) {
				v__ast__Stmt _t8 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("redefinition of value iteration variable `"), 0xfe10, {.d_s = val_var_name}}, {_SLIT("`"), 0, { .d_c = 0 }}}))))));
				return _t8;
			}
			v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){.name = key_var_name,.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.is_auto_deref = 0,.is_inherited = 0,.typ = _const_v__ast__int_type,.orig_type = 0,.smartcasts = __new_array(0, 0, sizeof(v__ast__Type)),.pos = key_var_pos,.is_used = 0,.is_changed = 0,.is_or = 0,.is_tmp = true,.is_auto_heap = 0,.is_stack_obj = true,}))));
		} else if (v__ast__Scope_known_var(p->scope, val_var_name)) {
			v__ast__Stmt _t9 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("redefinition of value iteration variable `"), 0xfe10, {.d_s = val_var_name}}, {_SLIT("`"), 0, { .d_c = 0 }}}))))));
			return _t9;
		}
		v__parser__Parser_check(p, v__token__Kind__key_in);
		if (p->tok.kind == v__token__Kind__name && (string__eq(p->tok.lit, key_var_name) || string__eq(p->tok.lit, val_var_name))) {
			v__ast__Stmt _t10 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("in a `for x in array` loop, the key or value iteration variable `"), 0xfe10, {.d_s = p->tok.lit}}, {_SLIT("` can not be the same as the array variable"), 0, { .d_c = 0 }}}))))));
			return _t10;
		}
		v__ast__Expr cond = v__parser__Parser_expr(p, 0);
		v__ast__Expr high_expr = v__ast__empty_expr();
		bool is_range = false;
		if (p->tok.kind == v__token__Kind__dotdot) {
			is_range = true;
			v__parser__Parser_next(p);
			high_expr = v__parser__Parser_expr(p, 0);
			v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){.name = val_var_name,.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.is_auto_deref = 0,.is_inherited = 0,.typ = _const_v__ast__int_type,.orig_type = 0,.smartcasts = __new_array(0, 0, sizeof(v__ast__Type)),.pos = val_var_pos,.is_used = 0,.is_changed = 0,.is_or = 0,.is_tmp = true,.is_auto_heap = 0,.is_stack_obj = true,}))));
			if (key_var_name.len > 0) {
				v__ast__Stmt _t11 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _SLIT("cannot declare index variable with range `for`"), key_var_pos))));
				return _t11;
			}
			if (val_is_mut) {
				v__ast__Stmt _t12 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _SLIT("variable in range `for` cannot be mut"), mut_pos))));
				return _t12;
			}
		} else {
			v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){
				.name = val_var_name,
				.expr = {0},
				.share = 0,
				.is_mut = val_is_mut,
				.is_autofree_tmp = 0,
				.is_arg = 0,
				.is_auto_deref = val_is_mut,
				.is_inherited = 0,
				.typ = 0,
				.orig_type = 0,
				.smartcasts = __new_array(0, 0, sizeof(v__ast__Type)),
				.pos = val_var_pos,
				.is_used = 0,
				.is_changed = 0,
				.is_or = 0,
				.is_tmp = true,
				.is_auto_heap = 0,
				.is_stack_obj = true,
			}))));
		}
		p->inside_for = false;
		Array_v__ast__Stmt stmts = v__parser__Parser_parse_block_no_scope(p, false);
		v__token__Position_update_last_line(&pos, p->prev_tok.line_nr);
		v__ast__ForInStmt for_in_stmt = (v__ast__ForInStmt){
			.key_var = key_var_name,
			.val_var = val_var_name,
			.cond = cond,
			.is_range = is_range,
			.high = high_expr,
			.stmts = stmts,
			.pos = pos,
			.val_is_mut = val_is_mut,
			.key_type = 0,
			.val_type = 0,
			.cond_type = 0,
			.high_type = 0,
			.kind = 0,
			.label = (string){.str=(byteptr)"", .is_lit=1},
			.scope = p->scope,
		};
		v__parser__Parser_close_scope(p);
		v__ast__Stmt _t13 = v__ast__ForInStmt_to_sumtype_v__ast__Stmt(&for_in_stmt);
		return _t13;
	}
	v__ast__Expr cond = v__parser__Parser_expr(p, 0);
	p->inside_for = false;
	v__parser__Parser_open_scope(p);
	Array_v__ast__Stmt stmts = v__parser__Parser_parse_block_no_scope(p, false);
	v__token__Position_update_last_line(&pos, p->prev_tok.line_nr);
	v__ast__ForStmt for_stmt = (v__ast__ForStmt){.cond = cond,.stmts = stmts,.is_inf = 0,.pos = pos,.label = (string){.str=(byteptr)"", .is_lit=1},.scope = p->scope,};
	v__parser__Parser_close_scope(p);
	v__parser__Parser_close_scope(p);
	v__ast__Stmt _t14 = v__ast__ForStmt_to_sumtype_v__ast__Stmt(&for_stmt);
	return _t14;
}

VV_LOCAL_SYMBOL v__ast__IfExpr v__parser__Parser_if_expr(v__parser__Parser* p, bool is_comptime) {
bool v__parser__Parser_if_expr_defer_0 = false;
bool was_inside_if_expr;
bool was_inside_ct_if_expr;
	was_inside_if_expr = p->inside_if_expr;
	was_inside_ct_if_expr = p->inside_ct_if_expr;
	v__parser__Parser_if_expr_defer_0 = true;
	p->inside_if_expr = true;
	bool is_expr = p->prev_tok.kind == v__token__Kind__key_return;
	v__token__Position pos = v__token__Token_position(&p->tok);
	if (is_comptime) {
		p->inside_ct_if_expr = true;
		v__parser__Parser_next(p);
		pos = v__token__Position_extend(v__token__Token_position(&p->prev_tok), v__token__Token_position(&p->tok));
	}
	Array_v__ast__IfBranch branches = __new_array_with_default(0, 0, sizeof(v__ast__IfBranch), 0);
	bool has_else = false;
	Array_v__ast__Comment comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	bool prev_guard = false;
	for (;;) {
		if (!((p->tok.kind == v__token__Kind__key_if || p->tok.kind == v__token__Kind__key_else))) break;
		p->inside_if = true;
		v__token__Position start_pos = (is_comptime ? (v__token__Position_extend(v__token__Token_position(&p->prev_tok), v__token__Token_position(&p->tok))) : (v__token__Token_position(&p->tok)));
		if (p->tok.kind == v__token__Kind__key_else) {
			_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,})), _t1, Array_v__ast__Comment);
			v__parser__Parser_check(p, v__token__Kind__key_else);
			_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,})), _t2, Array_v__ast__Comment);
			if (p->tok.kind == v__token__Kind__key_match) {
				v__parser__Parser_error(p, _SLIT("cannot use `match` with `if` statements"));
				v__ast__IfExpr _t3 = (v__ast__IfExpr){.is_comptime = 0,.tok_kind = 0,.left = {0},.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.post_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.branches = __new_array(0, 0, sizeof(v__ast__IfBranch)),.is_expr = 0,.typ = 0,.has_else = 0,};
				// Defer begin
				if (v__parser__Parser_if_expr_defer_0) {
					p->inside_if_expr = was_inside_if_expr;
					p->inside_ct_if_expr = was_inside_ct_if_expr;
				}
				// Defer end
				return _t3;
			}
			if (p->tok.kind == v__token__Kind__lcbr) {
				has_else = true;
				p->inside_if = false;
				v__token__Position end_pos = v__token__Token_position(&p->prev_tok);
				v__token__Position body_pos = v__token__Token_position(&p->tok);
				v__parser__Parser_open_scope(p);
				if (prev_guard) {
					v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){.name = _SLIT("err"),.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.is_auto_deref = 0,.is_inherited = 0,.typ = _const_v__ast__error_type,.orig_type = 0,.smartcasts = __new_array(0, 0, sizeof(v__ast__Type)),.pos = v__token__Token_position(&p->tok),.is_used = true,.is_changed = 0,.is_or = 0,.is_tmp = 0,.is_auto_heap = 0,.is_stack_obj = true,}))));
				}
				array_push((array*)&branches, _MOV((v__ast__IfBranch[]){ (v__ast__IfBranch){.cond = {0},.pos = v__token__Position_extend(start_pos, end_pos),.body_pos = v__token__Position_extend(body_pos, v__token__Token_position(&p->tok)),.comments = comments,.pkg_exist = 0,.stmts = v__parser__Parser_parse_block_no_scope(p, false),.scope = p->scope,} }));
				v__parser__Parser_close_scope(p);
				comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
				break;
			}
			if (is_comptime) {
				v__parser__Parser_check(p, v__token__Kind__dollar);
			}
		}
		v__parser__Parser_check(p, v__token__Kind__key_if);
		if (p->tok.kind == v__token__Kind__key_match) {
			v__parser__Parser_error(p, _SLIT("cannot use `match` with `if` statements"));
			v__ast__IfExpr _t5 = (v__ast__IfExpr){.is_comptime = 0,.tok_kind = 0,.left = {0},.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.post_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.branches = __new_array(0, 0, sizeof(v__ast__IfBranch)),.is_expr = 0,.typ = 0,.has_else = 0,};
			// Defer begin
			if (v__parser__Parser_if_expr_defer_0) {
				p->inside_if_expr = was_inside_if_expr;
				p->inside_ct_if_expr = was_inside_ct_if_expr;
			}
			// Defer end
			return _t5;
		}
		_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,})), _t6, Array_v__ast__Comment);
		v__ast__Expr cond = v__ast__empty_expr();
		bool is_guard = false;
		if (!is_comptime && p->peek_tok.kind == v__token__Kind__decl_assign) {
			v__parser__Parser_open_scope(p);
			is_guard = true;
			v__token__Position var_pos = v__token__Token_position(&p->tok);
			string var_name = v__parser__Parser_check_name(p);
			if (v__ast__Scope_known_var(p->scope, var_name)) {
				v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("redefinition of `"), 0xfe10, {.d_s = var_name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), var_pos);
			}
			_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,})), _t7, Array_v__ast__Comment);
			v__parser__Parser_check(p, v__token__Kind__decl_assign);
			_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,})), _t8, Array_v__ast__Comment);
			v__ast__Expr expr = v__parser__Parser_expr(p, 0);
			cond = v__ast__IfGuardExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__IfGuardExpr, ((v__ast__IfGuardExpr){.var_name = var_name,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.expr = expr,.expr_type = 0,})));
			v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){.name = var_name,.expr = cond,.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.is_auto_deref = 0,.is_inherited = 0,.typ = 0,.orig_type = 0,.smartcasts = __new_array(0, 0, sizeof(v__ast__Type)),.pos = var_pos,.is_used = 0,.is_changed = 0,.is_or = 0,.is_tmp = 0,.is_auto_heap = 0,.is_stack_obj = 0,}))));
			prev_guard = true;
		} else {
			prev_guard = false;
			p->comptime_if_cond = true;
			cond = v__parser__Parser_expr(p, 0);
			p->comptime_if_cond = false;
		}
		_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,})), _t9, Array_v__ast__Comment);
		v__token__Position end_pos = v__token__Token_position(&p->prev_tok);
		v__token__Position body_pos = v__token__Token_position(&p->tok);
		p->inside_if = false;
		v__parser__Parser_open_scope(p);
		Array_v__ast__Stmt stmts = v__parser__Parser_parse_block_no_scope(p, false);
		array_push((array*)&branches, _MOV((v__ast__IfBranch[]){ (v__ast__IfBranch){
			.cond = cond,
			.pos = v__token__Position_extend(start_pos, end_pos),
			.body_pos = v__token__Position_extend(body_pos, v__token__Token_position(&p->prev_tok)),
			.comments = comments,
			.pkg_exist = 0,
			.stmts = stmts,
			.scope = p->scope,
		} }));
		v__parser__Parser_close_scope(p);
		if (is_guard) {
			v__parser__Parser_close_scope(p);
		}
		comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,});
		if (is_comptime) {
			if (p->tok.kind == v__token__Kind__key_else) {
				v__parser__Parser_error(p, _SLIT("use `$else` instead of `else` in compile-time `if` branches"));
				v__ast__IfExpr _t11 = (v__ast__IfExpr){.is_comptime = 0,.tok_kind = 0,.left = {0},.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.post_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.branches = __new_array(0, 0, sizeof(v__ast__IfBranch)),.is_expr = 0,.typ = 0,.has_else = 0,};
				// Defer begin
				if (v__parser__Parser_if_expr_defer_0) {
					p->inside_if_expr = was_inside_if_expr;
					p->inside_ct_if_expr = was_inside_ct_if_expr;
				}
				// Defer end
				return _t11;
			}
			if (p->tok.kind != v__token__Kind__rcbr && p->peek_tok.kind == v__token__Kind__key_else) {
				v__parser__Parser_check(p, v__token__Kind__dollar);
			}
		}
		if (p->tok.kind != v__token__Kind__key_else) {
			break;
		}
	}
	v__token__Position_update_last_line(&pos, p->prev_tok.line_nr);
	if (comments.len > 0) {
		pos.last_line = (*(v__ast__Comment*)array_last(comments)).pos.last_line;
	}
	v__ast__IfExpr _t12 = (v__ast__IfExpr){
		.is_comptime = is_comptime,
		.tok_kind = 0,
		.left = {0},
		.pos = pos,
		.post_comments = comments,
		.branches = branches,
		.is_expr = is_expr,
		.typ = 0,
		.has_else = has_else,
	};
	// Defer begin
	if (v__parser__Parser_if_expr_defer_0) {
		p->inside_if_expr = was_inside_if_expr;
		p->inside_ct_if_expr = was_inside_ct_if_expr;
	}
	// Defer end
	return _t12;
}

VV_LOCAL_SYMBOL v__ast__MatchExpr v__parser__Parser_match_expr(v__parser__Parser* p) {
	v__token__Position match_first_pos = v__token__Token_position(&p->tok);
	p->inside_match = true;
	v__parser__Parser_check(p, v__token__Kind__key_match);
	bool is_sum_type = false;
	v__ast__Expr cond = v__parser__Parser_expr(p, 0);
	p->inside_match = false;
	bool no_lcbr = p->tok.kind != v__token__Kind__lcbr;
	if (!no_lcbr) {
		v__parser__Parser_check(p, v__token__Kind__lcbr);
	}
	Array_v__ast__Comment comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,});
	Array_v__ast__MatchBranch branches = __new_array_with_default(0, 0, sizeof(v__ast__MatchBranch), 0);
	for (;;) {
		if (!(p->tok.kind != v__token__Kind__eof)) break;
		v__token__Position branch_first_pos = v__token__Token_position(&p->tok);
		Array_v__ast__Expr exprs = __new_array_with_default(0, 0, sizeof(v__ast__Expr), 0);
		Array_Array_v__ast__Comment ecmnts = __new_array_with_default(0, 0, sizeof(Array_v__ast__Comment), 0);
		v__parser__Parser_open_scope(p);
		bool is_else = false;
		if (p->tok.kind == v__token__Kind__key_else) {
			is_else = true;
			v__parser__Parser_next(p);
		} else if ((p->tok.kind == v__token__Kind__name && !(string__eq(p->tok.lit, _SLIT("C")) && p->peek_tok.kind == v__token__Kind__dot) && (((v__token__KeywordsMatcher_find(&_const_v__ast__builtin_type_names_matcher, p->tok.lit) > 0 || byte_is_capital(string_at(p->tok.lit, 0))) && p->peek_tok.kind != v__token__Kind__lpar) || (p->peek_tok.kind == v__token__Kind__dot && v__parser__Parser_peek_token(p, 2).lit.len > 0 && byte_is_capital(string_at(v__parser__Parser_peek_token(p, 2).lit, 0))))) || p->tok.kind == v__token__Kind__lsbr) {
			Array_v__ast__Type types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
			for (;;) {
				v__ast__Type parsed_type = v__parser__Parser_parse_type(p);
				array_push((array*)&ecmnts, _MOV((Array_v__ast__Comment[]){ v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}) }));
				array_push((array*)&types, _MOV((v__ast__Type[]){ parsed_type }));
				array_push((array*)&exprs, _MOV((v__ast__Expr[]){ v__ast__TypeNode_to_sumtype_v__ast__Expr(ADDR(v__ast__TypeNode, ((v__ast__TypeNode){.typ = parsed_type,.pos = v__token__Token_position(&p->prev_tok),}))) }));
				if (p->tok.kind != v__token__Kind__comma) {
					break;
				}
				v__parser__Parser_check(p, v__token__Kind__comma);
				if (p->pref->is_fmt) {
					if (p->tok.kind == v__token__Kind__lcbr) {
						break;
					}
					for (;;) {
						if (!(p->tok.kind == v__token__Kind__comma)) break;
						v__parser__Parser_next(p);
					}
				}
			}
			is_sum_type = true;
		} else {
			for (;;) {
				p->inside_match_case = true;
				v__ast__Expr expr = v__parser__Parser_expr(p, 0);
				array_push((array*)&ecmnts, _MOV((Array_v__ast__Comment[]){ v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}) }));
				p->inside_match_case = false;
				if (p->tok.kind == v__token__Kind__dotdot) {
					v__parser__Parser_error_with_pos(p, _SLIT("match only supports inclusive (`...`) ranges, not exclusive (`..`)"), v__token__Token_position(&p->tok));
					v__ast__MatchExpr _t5 = (v__ast__MatchExpr){.tok_kind = 0,.cond = {0},.branches = __new_array(0, 0, sizeof(v__ast__MatchBranch)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.is_expr = 0,.return_type = 0,.cond_type = 0,.expected_type = 0,.is_sum_type = 0,};
					return _t5;
				} else if (p->tok.kind == v__token__Kind__ellipsis) {
					v__parser__Parser_next(p);
					v__ast__Expr expr2 = v__parser__Parser_expr(p, 0);
					array_push((array*)&exprs, _MOV((v__ast__Expr[]){ v__ast__RangeExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__RangeExpr, ((v__ast__RangeExpr){.low = expr,.high = expr2,.has_high = true,.has_low = true,.pos = v__token__Token_position(&p->tok),.is_gated = 0,}))) }));
				} else {
					array_push((array*)&exprs, _MOV((v__ast__Expr[]){ expr }));
				}
				if (p->tok.kind != v__token__Kind__comma) {
					break;
				}
				v__parser__Parser_check(p, v__token__Kind__comma);
				if (p->pref->is_fmt) {
					if (p->tok.kind == v__token__Kind__lcbr) {
						break;
					}
					for (;;) {
						if (!(p->tok.kind == v__token__Kind__comma)) break;
						v__parser__Parser_next(p);
					}
				}
			}
		}
		v__token__Position branch_last_pos = v__token__Token_position(&p->prev_tok);
		p->inside_match_body = true;
		Array_v__ast__Stmt stmts = v__parser__Parser_parse_block_no_scope(p, false);
		v__ast__Scope* branch_scope = p->scope;
		v__parser__Parser_close_scope(p);
		p->inside_match_body = false;
		v__token__Position pos = v__token__Position_extend_with_last_line(branch_first_pos, branch_last_pos, p->prev_tok.line_nr);
		v__token__Position branch_pos = v__token__Position_extend_with_last_line(branch_first_pos, v__token__Token_position(&p->tok), p->tok.line_nr);
		Array_v__ast__Comment post_comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,});
		array_push((array*)&branches, _MOV((v__ast__MatchBranch[]){ (v__ast__MatchBranch){
			.ecmnts = ecmnts,
			.pos = pos,
			.is_else = is_else,
			.post_comments = post_comments,
			.branch_pos = branch_pos,
			.stmts = stmts,
			.exprs = exprs,
			.scope = branch_scope,
		} }));
		if (is_else && branches.len == 1) {
			v__parser__Parser_error_with_pos(p, _SLIT("`match` must have at least one non `else` branch"), pos);
		}
		if (p->tok.kind == v__token__Kind__rcbr || (is_else && no_lcbr)) {
			break;
		}
	}
	v__token__Position match_last_pos = v__token__Token_position(&p->tok);
	v__token__Position pos = (v__token__Position){.len = match_last_pos.pos - match_first_pos.pos + match_last_pos.len,.line_nr = match_first_pos.line_nr,.pos = match_first_pos.pos,.col = match_first_pos.col,.last_line = 0,};
	if (p->tok.kind == v__token__Kind__rcbr) {
		v__parser__Parser_check(p, v__token__Kind__rcbr);
	}
	v__token__Position_update_last_line(&pos, p->prev_tok.line_nr);
	v__ast__MatchExpr _t9 = (v__ast__MatchExpr){.tok_kind = 0,.cond = cond,.branches = branches,.pos = pos,.comments = comments,.is_expr = 0,.return_type = 0,.cond_type = 0,.expected_type = 0,.is_sum_type = is_sum_type,};
	return _t9;
}

VV_LOCAL_SYMBOL v__ast__SelectExpr v__parser__Parser_select_expr(v__parser__Parser* p) {
	v__token__Position match_first_pos = v__token__Token_position(&p->tok);
	v__parser__Parser_check(p, v__token__Kind__key_select);
	bool no_lcbr = p->tok.kind != v__token__Kind__lcbr;
	if (!no_lcbr) {
		v__parser__Parser_check(p, v__token__Kind__lcbr);
	}
	Array_v__ast__SelectBranch branches = __new_array_with_default(0, 0, sizeof(v__ast__SelectBranch), 0);
	bool has_else = false;
	bool has_timeout = false;
	for (;;) {
		v__token__Position branch_first_pos = v__token__Token_position(&p->tok);
		v__ast__Comment comment = v__parser__Parser_check_comment(p);
		v__parser__Parser_open_scope(p);
		bool is_else = false;
		bool is_timeout = false;
		v__ast__Stmt stmt = v__ast__empty_stmt();
		if (p->tok.kind == v__token__Kind__key_else) {
			if (has_timeout) {
				v__parser__Parser_error_with_pos(p, _SLIT("timeout `> t` and `else` are mutually exclusive `select` keys"), v__token__Token_position(&p->tok));
				v__ast__SelectExpr _t1 = (v__ast__SelectExpr){.branches = __new_array(0, 0, sizeof(v__ast__SelectBranch)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.has_exception = 0,.is_expr = 0,.expected_type = 0,};
				return _t1;
			}
			if (has_else) {
				v__parser__Parser_error_with_pos(p, _SLIT("at most one `else` branch allowed in `select` block"), v__token__Token_position(&p->tok));
				v__ast__SelectExpr _t2 = (v__ast__SelectExpr){.branches = __new_array(0, 0, sizeof(v__ast__SelectBranch)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.has_exception = 0,.is_expr = 0,.expected_type = 0,};
				return _t2;
			}
			is_else = true;
			has_else = true;
			v__parser__Parser_next(p);
		} else {
			bool is_gt = false;
			if (p->tok.kind == v__token__Kind__gt) {
				is_gt = true;
				v__parser__Parser_note_with_pos(p, _SLIT("`>` is deprecated and will soon be forbidden - just state the timeout in nanoseconds"), v__token__Token_position(&p->tok));
				v__parser__Parser_next(p);
			}
			p->inside_match = true;
			p->inside_select = true;
			multi_return_Array_v__ast__Expr_Array_v__ast__Comment mr_8501 = v__parser__Parser_expr_list(p);
			Array_v__ast__Expr exprs = mr_8501.arg0;
			Array_v__ast__Comment comments = mr_8501.arg1;
			if (exprs.len != 1) {
				v__parser__Parser_error(p, _SLIT("only one expression allowed as `select` key"));
				v__ast__SelectExpr _t3 = (v__ast__SelectExpr){.branches = __new_array(0, 0, sizeof(v__ast__SelectBranch)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.has_exception = 0,.is_expr = 0,.expected_type = 0,};
				return _t3;
			}
			if (p->tok.kind == v__token__Kind__assign || p->tok.kind == v__token__Kind__decl_assign) {
				stmt = v__parser__Parser_partial_assign_stmt(p, exprs, comments);
			} else {
				stmt = v__ast__ExprStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__ExprStmt, ((v__ast__ExprStmt){.expr = (*(v__ast__Expr*)/*ee elem_typ */array_get(exprs, 0)),.pos = v__ast__Expr_position((*(v__ast__Expr*)/*ee elem_typ */array_get(exprs, 0))),.comments = new_array_from_c_array(1, 1, sizeof(v__ast__Comment), _MOV((v__ast__Comment[1]){comment})),.is_expr = true,.typ = 0,})));
			}
			p->inside_match = false;
			p->inside_select = false;
			if (stmt._typ == 339 /* v.ast.ExprStmt */) {
				bool check_timeout = false;
				if (!(*stmt._v__ast__ExprStmt).is_expr) {
					v__parser__Parser_error_with_pos(p, _SLIT("select: invalid expression"), (*stmt._v__ast__ExprStmt).pos);
					v__ast__SelectExpr _t4 = (v__ast__SelectExpr){.branches = __new_array(0, 0, sizeof(v__ast__SelectBranch)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.has_exception = 0,.is_expr = 0,.expected_type = 0,};
					return _t4;
				} else {
					if ((*stmt._v__ast__ExprStmt).expr._typ == 303 /* v.ast.InfixExpr */) {
						if ((*(*stmt._v__ast__ExprStmt).expr._v__ast__InfixExpr).op != v__token__Kind__arrow) {
							check_timeout = true;
						} else if (is_gt) {
							v__parser__Parser_error_with_pos(p, _SLIT("send expression cannot be used as timeout"), (*stmt._v__ast__ExprStmt).pos);
						}
					}
					
					else {
						check_timeout = true;
					}
					;
				}
				if (check_timeout) {
					if (has_else) {
						v__parser__Parser_error_with_pos(p, _SLIT("`else` and timeout value are mutually exclusive `select` keys"), (*stmt._v__ast__ExprStmt).pos);
						v__ast__SelectExpr _t5 = (v__ast__SelectExpr){.branches = __new_array(0, 0, sizeof(v__ast__SelectBranch)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.has_exception = 0,.is_expr = 0,.expected_type = 0,};
						return _t5;
					}
					if (has_timeout) {
						v__parser__Parser_error_with_pos(p, _SLIT("at most one timeout branch allowed in `select` block"), (*stmt._v__ast__ExprStmt).pos);
						v__ast__SelectExpr _t6 = (v__ast__SelectExpr){.branches = __new_array(0, 0, sizeof(v__ast__SelectBranch)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.has_exception = 0,.is_expr = 0,.expected_type = 0,};
						return _t6;
					}
					is_timeout = true;
					has_timeout = true;
				}
			}
			else if (stmt._typ == 331 /* v.ast.AssignStmt */) {
				v__ast__Expr expr = (*(v__ast__Expr*)/*ee elem_typ */array_get((*stmt._v__ast__AssignStmt).right, 0));
				if (expr._typ == 316 /* v.ast.PrefixExpr */) {
					if ((*expr._v__ast__PrefixExpr).op != v__token__Kind__arrow) {
						v__parser__Parser_error_with_pos(p, _SLIT("select key: `<-` operator expected"), (*expr._v__ast__PrefixExpr).pos);
						v__ast__SelectExpr _t7 = (v__ast__SelectExpr){.branches = __new_array(0, 0, sizeof(v__ast__SelectBranch)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.has_exception = 0,.is_expr = 0,.expected_type = 0,};
						return _t7;
					}
				}
				
				else {
					v__parser__Parser_error_with_pos(p, _SLIT("select key: receive expression expected"), v__ast__Expr_position((*(v__ast__Expr*)/*ee elem_typ */array_get((*stmt._v__ast__AssignStmt).right, 0))));
					v__ast__SelectExpr _t8 = (v__ast__SelectExpr){.branches = __new_array(0, 0, sizeof(v__ast__SelectBranch)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.has_exception = 0,.is_expr = 0,.expected_type = 0,};
					return _t8;
				}
				;
			}
			
			else {
				v__parser__Parser_error_with_pos(p, _SLIT("select: transmission statement, timeout (in ns) or `else` expected"), (*(stmt.pos)));
				v__ast__SelectExpr _t9 = (v__ast__SelectExpr){.branches = __new_array(0, 0, sizeof(v__ast__SelectBranch)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.has_exception = 0,.is_expr = 0,.expected_type = 0,};
				return _t9;
			}
			;
		}
		v__token__Position branch_last_pos = v__token__Token_position(&p->tok);
		p->inside_match_body = true;
		Array_v__ast__Stmt stmts = v__parser__Parser_parse_block_no_scope(p, false);
		v__parser__Parser_close_scope(p);
		p->inside_match_body = false;
		v__token__Position pos = (v__token__Position){.len = branch_last_pos.pos - branch_first_pos.pos + branch_last_pos.len,.line_nr = branch_first_pos.line_nr,.pos = branch_first_pos.pos,.col = branch_first_pos.col,.last_line = 0,};
		Array_v__ast__Comment post_comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,});
		v__token__Position_update_last_line(&pos, p->prev_tok.line_nr);
		if (post_comments.len > 0) {
			pos.last_line = (*(v__ast__Comment*)array_last(post_comments)).pos.last_line;
		}
		array_push((array*)&branches, _MOV((v__ast__SelectBranch[]){ (v__ast__SelectBranch){
			.stmt = stmt,
			.stmts = stmts,
			.pos = pos,
			.comment = comment,
			.is_else = is_else,
			.is_timeout = is_timeout,
			.post_comments = post_comments,
		} }));
		if (p->tok.kind == v__token__Kind__rcbr || ((is_else || is_timeout) && no_lcbr)) {
			break;
		}
	}
	v__token__Position match_last_pos = v__token__Token_position(&p->tok);
	v__token__Position pos = (v__token__Position){.len = match_last_pos.pos - match_first_pos.pos + match_last_pos.len,.line_nr = match_first_pos.line_nr,.pos = match_first_pos.pos,.col = match_first_pos.col,.last_line = 0,};
	if (p->tok.kind == v__token__Kind__rcbr) {
		v__parser__Parser_check(p, v__token__Kind__rcbr);
	}
	v__ast__SelectExpr _t11 = (v__ast__SelectExpr){.branches = branches,.pos = v__token__Position_extend_with_last_line(pos, v__token__Token_position(&p->prev_tok), p->prev_tok.line_nr),.has_exception = has_else || has_timeout,.is_expr = 0,.expected_type = 0,};
	return _t11;
}

VV_LOCAL_SYMBOL v__ast__Expr v__parser__Parser_lockable(v__parser__Parser* p) {
	Array_string names = __new_array_with_default(0, 0, sizeof(string), 0);
	Array_v__token__Position positions = __new_array_with_default(0, 0, sizeof(v__token__Position), 0);
	v__token__Position pos = v__token__Token_position(&p->tok);
	for (;;) {
		if (p->tok.kind != v__token__Kind__name) {
			v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unexpected `"), 0xfe10, {.d_s = p->tok.lit}}, {_SLIT("` (field/variable name expected)"), 0, { .d_c = 0 }}})), v__token__Token_position(&p->tok));
		}
		array_push((array*)&names, _MOV((string[]){ string_clone(p->tok.lit) }));
		array_push((array*)&positions, _MOV((v__token__Position[]){ pos }));
		v__parser__Parser_next(p);
		if (p->tok.kind != v__token__Kind__dot) {
			break;
		}
		v__parser__Parser_next(p);
		v__token__Position_extend(pos, v__token__Token_position(&p->tok));
	}
	v__ast__Expr expr = v__ast__Ident_to_sumtype_v__ast__Expr(ADDR(v__ast__Ident, ((v__ast__Ident){
		.language = v__ast__Language__v,
		.tok_kind = 0,
		.pos = (*(v__token__Position*)/*ee elem_typ */array_get(positions, 0)),
		.mut_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},
		.comptime = 0,
		.scope = p->scope,
		.obj = {0},
		.mod = p->mod,
		.name = (*(string*)/*ee elem_typ */array_get(names, 0)),
		.kind = 0,
		.info = v__ast__IdentVar_to_sumtype_v__ast__IdentInfo(ADDR(v__ast__IdentVar, ((v__ast__IdentVar){.typ = 0,.is_mut = 0,.is_static = 0,.is_volatile = 0,.is_optional = 0,.share = 0,}))),
		.is_mut = true,
	})));
	for (int i = 1; i < names.len; i++) {
		expr = v__ast__SelectorExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__SelectorExpr, ((v__ast__SelectorExpr){
			.pos = (*(v__token__Position*)/*ee elem_typ */array_get(positions, i)),
			.field_name = (*(string*)/*ee elem_typ */array_get(names, i)),
			.is_mut = true,
			.mut_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},
			.next_token = (i < names.len - 1 ? (v__token__Kind__dot) : (p->tok.kind)),
			.expr = expr,
			.expr_type = 0,
			.typ = 0,
			.name_type = 0,
			.gkind_field = 0,
			.scope = p->scope,
			.from_embed_types = __new_array(0, 0, sizeof(v__ast__Type)),
		})));
	}
	v__ast__Expr _t3 = expr;
	return _t3;
}

VV_LOCAL_SYMBOL multi_return_Array_v__ast__Expr_Array_v__ast__Comment v__parser__Parser_lockable_list(v__parser__Parser* p) {
	Array_v__ast__Expr exprs = __new_array_with_default(0, 0, sizeof(v__ast__Expr), 0);
	Array_v__ast__Comment comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	for (;;) {
		v__ast__Expr expr = v__parser__Parser_lockable(p);
		if ((expr)._typ == 290 /* v.ast.Comment */) {
			array_push((array*)&comments, _MOV((v__ast__Comment[]){ (*expr._v__ast__Comment) }));
		} else {
			array_push((array*)&exprs, _MOV((v__ast__Expr[]){ expr }));
			if (p->tok.kind != v__token__Kind__comma) {
				break;
			}
			v__parser__Parser_next(p);
		}
	}
	return (multi_return_Array_v__ast__Expr_Array_v__ast__Comment){.arg0=exprs, .arg1=comments};
}

VV_LOCAL_SYMBOL v__ast__LockExpr v__parser__Parser_lock_expr(v__parser__Parser* p) {
	v__parser__Parser_register_auto_import(p, _SLIT("sync"));
	v__parser__Parser_open_scope(p);
	v__token__Position pos = v__token__Token_position(&p->tok);
	Array_v__ast__Expr lockeds = __new_array_with_default(0, 0, sizeof(v__ast__Expr), 0);
	Array_v__ast__Comment comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	Array_bool is_rlocked = __new_array_with_default(0, 0, sizeof(bool), 0);
	for (;;) {
		bool is_rlock = p->tok.kind == v__token__Kind__key_rlock;
		if (!is_rlock && p->tok.kind != v__token__Kind__key_lock) {
			v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unexpected `"), 0xfe10, {.d_s = v__token__Token_str(p->tok)}}, {_SLIT("`, expected `lock` or `rlock`"), 0, { .d_c = 0 }}})), v__token__Token_position(&p->tok));
		}
		v__parser__Parser_next(p);
		if (p->tok.kind == v__token__Kind__lcbr) {
			break;
		}
		if (p->tok.kind == v__token__Kind__name) {
			multi_return_Array_v__ast__Expr_Array_v__ast__Comment mr_1883 = v__parser__Parser_lockable_list(p);
			Array_v__ast__Expr exprs = mr_1883.arg0;
			Array_v__ast__Comment comms = mr_1883.arg1;
			for (int _t1 = 0; _t1 < exprs.len; ++_t1) {
				v__ast__Expr e = ((v__ast__Expr*)exprs.data)[_t1];
				if (!v__ast__Expr_is_lockable(&e)) {
					v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = v__ast__Expr_str(e)}}, {_SLIT("` cannot be locked - only `x` or `x.y` are supported"), 0, { .d_c = 0 }}})), v__ast__Expr_position(e));
				}
				array_push((array*)&lockeds, _MOV((v__ast__Expr[]){ e }));
				array_push((array*)&is_rlocked, _MOV((bool[]){ is_rlock }));
			}
			_PUSH_MANY(&comments, (comms), _t4, Array_v__ast__Comment);
		}
		if (p->tok.kind == v__token__Kind__lcbr) {
			break;
		}
		if (p->tok.kind == v__token__Kind__semicolon) {
			v__parser__Parser_next(p);
		}
	}
	Array_v__ast__Stmt stmts = v__parser__Parser_parse_block_no_scope(p, false);
	v__ast__Scope* scope = p->scope;
	v__parser__Parser_close_scope(p);
	v__token__Position_update_last_line(&pos, p->prev_tok.line_nr);
	v__ast__LockExpr _t5 = (v__ast__LockExpr){.stmts = stmts,.is_rlock = is_rlocked,.pos = pos,.lockeds = lockeds,.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.is_expr = 0,.typ = 0,.scope = scope,};
	return _t5;
}

bool v__parser__Parser_known_import(v__parser__Parser* p, string mod) {
	bool _t1 = _IN_MAP(ADDR(string, mod), ADDR(map, p->imports));
	return _t1;
}

VV_LOCAL_SYMBOL string v__parser__Parser_prepend_mod(v__parser__Parser* p, string name) {
	if ((p->expr_mod).len != 0) {
		string _t1 = string__plus(string__plus(p->expr_mod, _SLIT(".")), name);
		return _t1;
	}
	if (p->builtin_mod) {
		string _t2 = name;
		return _t2;
	}
	string _t3 = string__plus(string__plus(p->mod, _SLIT(".")), name);
	return _t3;
}

VV_LOCAL_SYMBOL bool v__parser__Parser_is_used_import(v__parser__Parser* p, string alias) {
	bool _t1 = Array_string_contains(p->used_imports, alias);
	return _t1;
}

VV_LOCAL_SYMBOL void v__parser__Parser_register_used_import(v__parser__Parser* p, string alias) {
	if (!v__parser__Parser_is_used_import(p, alias)) {
		array_push((array*)&p->used_imports, _MOV((string[]){ string_clone(alias) }));
	}
}

VV_LOCAL_SYMBOL void v__parser__Parser_register_auto_import(v__parser__Parser* p, string alias) {
	if (!_IN_MAP(ADDR(string, alias), ADDR(map, p->imports))) {
		map_set(&p->imports, &(string[]){alias}, &(string[]) { alias });
		array_push((array*)&p->table->imports, _MOV((string[]){ string_clone(alias) }));
		v__ast__Import node = (v__ast__Import){.mod = alias,.alias = alias,.pos = v__token__Token_position(&p->tok),.mod_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.alias_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.syms_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.syms = __new_array(0, 0, sizeof(v__ast__ImportSymbol)),.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.next_comments = __new_array(0, 0, sizeof(v__ast__Comment)),};
		array_push((array*)&p->ast_imports, _MOV((v__ast__Import[]){ node }));
	}
	if (!Array_string_contains(p->auto_imports, alias)) {
		array_push((array*)&p->auto_imports, _MOV((string[]){ string_clone(alias) }));
	}
	v__parser__Parser_register_used_import(p, alias);
}

VV_LOCAL_SYMBOL void v__parser__Parser_check_unused_imports(v__parser__Parser* p) {
	if (p->pref->is_repl || p->pref->is_fmt) {
		return;
	}
	for (int _t1 = 0; _t1 < p->ast_imports.len; ++_t1) {
		v__ast__Import import_m = ((v__ast__Import*)p->ast_imports.data)[_t1];
		string alias = import_m.alias;
		string mod = import_m.mod;
		if (!v__parser__Parser_is_used_import(p, alias)) {
			string mod_alias = (string__eq(alias, mod) ? (alias) : ( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = alias}}, {_SLIT(" ("), 0xfe10, {.d_s = mod}}, {_SLIT(")"), 0, { .d_c = 0 }}}))));
			v__parser__Parser_warn_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("module '"), 0xfe10, {.d_s = mod_alias}}, {_SLIT("' is imported but never used"), 0, { .d_c = 0 }}})), import_m.mod_pos);
		}
	}
}

v__ast__Type v__parser__Parser_parse_array_type(v__parser__Parser* p, v__token__Kind expecting) {
	v__parser__Parser_check(p, expecting);
	if (p->tok.kind == v__token__Kind__number || p->tok.kind == v__token__Kind__name) {
		int fixed_size = 0;
		v__ast__Expr size_expr = v__parser__Parser_expr(p, 0);
		if (p->pref->is_fmt) {
			fixed_size = 987654321;
		} else {
			if (size_expr._typ == 304 /* v.ast.IntegerLiteral */) {
				fixed_size = string_int((*size_expr._v__ast__IntegerLiteral).val);
			}
			else if (size_expr._typ == 299 /* v.ast.Ident */) {
				bool show_non_const_error = false;
				Option_v__ast__ConstField_ptr _t1;
				if (_t1 = v__ast__Scope_find_const(p->table->global_scope,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = p->mod}}, {_SLIT("."), 0xfe10, {.d_s = (*size_expr._v__ast__Ident).name}}, {_SLIT0, 0, { .d_c = 0 }}}))), _t1.state == 0) {
					v__ast__ConstField* const_field = *(v__ast__ConstField**)_t1.data;
					if ((const_field->expr)._typ == 304 /* v.ast.IntegerLiteral */) {
						fixed_size = string_int((*const_field->expr._v__ast__IntegerLiteral).val);
					} else {
						if ((const_field->expr)._typ == 303 /* v.ast.InfixExpr */) {
							v__transformer__Transformer* t = v__transformer__new_transformer(p->pref);
							v__ast__Expr folded_expr = v__transformer__Transformer_infix_expr(t, (*const_field->expr._v__ast__InfixExpr));
							if ((folded_expr)._typ == 304 /* v.ast.IntegerLiteral */) {
								fixed_size = string_int((*folded_expr._v__ast__IntegerLiteral).val);
							} else {
								show_non_const_error = true;
							}
						} else {
							show_non_const_error = true;
						}
					}
				} else {
					IError err = _t1.err;
					if (p->pref->is_fmt) {
						fixed_size = 1;
					} else {
						show_non_const_error = true;
					}
				}
				if (show_non_const_error) {
					v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("non-constant array bound `"), 0xfe10, {.d_s = (*size_expr._v__ast__Ident).name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), (*size_expr._v__ast__Ident).pos);
				}
			}
			
			else {
				v__parser__Parser_error(p, _SLIT("expecting `int` for fixed size"));
			}
			;
		}
		v__parser__Parser_check(p, v__token__Kind__rsbr);
		v__ast__Type elem_type = v__parser__Parser_parse_type(p);
		if (v__ast__Type_idx(elem_type) == 0) {
			v__ast__Type _t2 = 0;
			return _t2;
		}
		if (fixed_size <= 0) {
			v__parser__Parser_error_with_pos(p, _SLIT("fixed size cannot be zero or negative"), v__ast__Expr_position(size_expr));
		}
		int idx = v__ast__Table_find_or_register_array_fixed(p->table, elem_type, fixed_size, size_expr);
		if (v__ast__Type_has_flag(elem_type, v__ast__TypeFlag__generic)) {
			v__ast__Type _t3 = v__ast__Type_set_flag(v__ast__new_type(idx), v__ast__TypeFlag__generic);
			return _t3;
		}
		v__ast__Type _t4 = v__ast__new_type(idx);
		return _t4;
	}
	v__parser__Parser_check(p, v__token__Kind__rsbr);
	v__ast__Type elem_type = v__parser__Parser_parse_type(p);
	if (v__ast__Type_idx(elem_type) == 0) {
		v__ast__Type _t5 = 0;
		return _t5;
	}
	if (v__ast__Type_idx(elem_type) == _const_v__ast__thread_type_idx) {
		v__parser__Parser_register_auto_import(p, _SLIT("sync.threads"));
	}
	int nr_dims = 1;
	bool not_attr = p->peek_tok.kind != v__token__Kind__name && !(v__parser__Parser_peek_token(p, 2).kind == v__token__Kind__semicolon || v__parser__Parser_peek_token(p, 2).kind == v__token__Kind__rsbr);
	for (;;) {
		if (!(p->tok.kind == expecting && not_attr)) break;
		v__parser__Parser_next(p);
		v__parser__Parser_check(p, v__token__Kind__rsbr);
		nr_dims++;
	}
	int idx = v__ast__Table_find_or_register_array_with_dims(p->table, elem_type, nr_dims);
	if (v__ast__Type_has_flag(elem_type, v__ast__TypeFlag__generic)) {
		v__ast__Type _t6 = v__ast__Type_set_flag(v__ast__new_type(idx), v__ast__TypeFlag__generic);
		return _t6;
	}
	v__ast__Type _t7 = v__ast__new_type(idx);
	return _t7;
}

v__ast__Type v__parser__Parser_parse_map_type(v__parser__Parser* p) {
	v__parser__Parser_next(p);
	if (p->tok.kind != v__token__Kind__lsbr) {
		v__ast__Type _t1 = _const_v__ast__map_type;
		return _t1;
	}
	v__parser__Parser_check(p, v__token__Kind__lsbr);
	v__ast__Type key_type = v__parser__Parser_parse_type(p);
	v__ast__TypeSymbol* key_sym = v__ast__Table_sym(p->table, key_type);
	bool is_alias = key_sym->kind == v__ast__Kind__alias;
	if (v__ast__Type_idx(key_type) == 0) {
		v__ast__Type _t2 = 0;
		return _t2;
	}
	bool key_type_supported = (key_type == _const_v__ast__string_type_idx || key_type == _const_v__ast__voidptr_type_idx) || (key_sym->kind == v__ast__Kind__enum_ || key_sym->kind == v__ast__Kind__placeholder || key_sym->kind == v__ast__Kind__any) || ((v__ast__Type_is_int(key_type) || v__ast__Type_is_float(key_type) || is_alias) && !v__ast__Type_is_ptr(key_type));
	if (!key_type_supported) {
		if (is_alias) {
			v__parser__Parser_error(p, _SLIT("cannot use the alias type as the parent type is unsupported"));
			v__ast__Type _t3 = 0;
			return _t3;
		}
		string s = v__ast__Table_type_to_str(p->table, key_type);
		v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("maps only support string, integer, float, rune, enum or voidptr keys for now (not `"), 0xfe10, {.d_s = s}}, {_SLIT("`)"), 0, { .d_c = 0 }}})), v__token__Token_position(&p->tok));
		v__ast__Type _t4 = 0;
		return _t4;
	}
	v__parser__Parser_check(p, v__token__Kind__rsbr);
	v__ast__Type value_type = v__parser__Parser_parse_type(p);
	if (v__ast__Type_idx(value_type) == 0) {
		v__ast__Type _t5 = 0;
		return _t5;
	}
	if (v__ast__Type_idx(value_type) == _const_v__ast__void_type_idx) {
		v__parser__Parser_error_with_pos(p, _SLIT("map value type cannot be void"), v__token__Token_position(&p->tok));
		v__ast__Type _t6 = 0;
		return _t6;
	}
	int idx = v__ast__Table_find_or_register_map(p->table, key_type, value_type);
	if (v__ast__Type_has_flag(key_type, v__ast__TypeFlag__generic) || v__ast__Type_has_flag(value_type, v__ast__TypeFlag__generic)) {
		v__ast__Type _t7 = v__ast__Type_set_flag(v__ast__new_type(idx), v__ast__TypeFlag__generic);
		return _t7;
	}
	v__ast__Type _t8 = v__ast__new_type(idx);
	return _t8;
}

v__ast__Type v__parser__Parser_parse_chan_type(v__parser__Parser* p) {
	if (p->peek_tok.kind != v__token__Kind__name && p->peek_tok.kind != v__token__Kind__key_mut && p->peek_tok.kind != v__token__Kind__amp && p->peek_tok.kind != v__token__Kind__lsbr) {
		v__parser__Parser_next(p);
		v__ast__Type _t1 = _const_v__ast__chan_type;
		return _t1;
	}
	v__parser__Parser_register_auto_import(p, _SLIT("sync"));
	v__parser__Parser_next(p);
	bool is_mut = p->tok.kind == v__token__Kind__key_mut;
	v__ast__Type elem_type = v__parser__Parser_parse_type(p);
	int idx = v__ast__Table_find_or_register_chan(p->table, elem_type, is_mut);
	if (v__ast__Type_has_flag(elem_type, v__ast__TypeFlag__generic)) {
		v__ast__Type _t2 = v__ast__Type_set_flag(v__ast__new_type(idx), v__ast__TypeFlag__generic);
		return _t2;
	}
	v__ast__Type _t3 = v__ast__new_type(idx);
	return _t3;
}

v__ast__Type v__parser__Parser_parse_thread_type(v__parser__Parser* p) {
	bool is_opt = p->peek_tok.kind == v__token__Kind__question;
	if (is_opt) {
		v__parser__Parser_next(p);
	}
	if (p->peek_tok.kind != v__token__Kind__name && p->peek_tok.kind != v__token__Kind__key_mut && p->peek_tok.kind != v__token__Kind__amp && p->peek_tok.kind != v__token__Kind__lsbr) {
		v__parser__Parser_next(p);
		if (is_opt) {
			v__ast__Type ret_type = _const_v__ast__void_type;
			ret_type = v__ast__Type_set_flag(ret_type, v__ast__TypeFlag__optional);
			int idx = v__ast__Table_find_or_register_thread(p->table, ret_type);
			v__ast__Type _t1 = v__ast__new_type(idx);
			return _t1;
		} else {
			v__ast__Type _t2 = _const_v__ast__thread_type;
			return _t2;
		}
	}
	if (!is_opt) {
		v__parser__Parser_next(p);
	}
	v__ast__Type ret_type = v__parser__Parser_parse_type(p);
	int idx = v__ast__Table_find_or_register_thread(p->table, ret_type);
	if (v__ast__Type_has_flag(ret_type, v__ast__TypeFlag__generic)) {
		v__ast__Type _t3 = v__ast__Type_set_flag(v__ast__new_type(idx), v__ast__TypeFlag__generic);
		return _t3;
	}
	v__ast__Type _t4 = v__ast__new_type(idx);
	return _t4;
}

v__ast__Type v__parser__Parser_parse_multi_return_type(v__parser__Parser* p) {
	v__parser__Parser_check(p, v__token__Kind__lpar);
	Array_v__ast__Type mr_types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
	bool has_generic = false;
	for (;;) {
		if (!(p->tok.kind != v__token__Kind__eof)) break;
		v__ast__Type mr_type = v__parser__Parser_parse_type(p);
		if (v__ast__Type_idx(mr_type) == 0) {
			break;
		}
		if (v__ast__Type_has_flag(mr_type, v__ast__TypeFlag__generic)) {
			has_generic = true;
		}
		array_push((array*)&mr_types, _MOV((v__ast__Type[]){ mr_type }));
		if (p->tok.kind == v__token__Kind__comma) {
			v__parser__Parser_next(p);
		} else {
			break;
		}
	}
	v__parser__Parser_check(p, v__token__Kind__rpar);
	if (mr_types.len == 1) {
		v__ast__Type _t2 = (*(v__ast__Type*)/*ee elem_typ */array_get(mr_types, 0));
		return _t2;
	}
	int idx = v__ast__Table_find_or_register_multi_return(p->table, mr_types);
	if (has_generic) {
		v__ast__Type _t3 = v__ast__Type_set_flag(v__ast__new_type(idx), v__ast__TypeFlag__generic);
		return _t3;
	}
	v__ast__Type _t4 = v__ast__new_type(idx);
	return _t4;
}

v__ast__Type v__parser__Parser_parse_fn_type(v__parser__Parser* p, string name) {
	v__parser__Parser_check(p, v__token__Kind__key_fn);
	bool has_generic = false;
	int line_nr = p->tok.line_nr;
	multi_return_Array_v__ast__Param_bool_bool mr_6100 = v__parser__Parser_fn_args(p);
	Array_v__ast__Param args = mr_6100.arg0;
	bool is_variadic = mr_6100.arg2;
	for (int _t1 = 0; _t1 < args.len; ++_t1) {
		v__ast__Param arg = ((v__ast__Param*)args.data)[_t1];
		if (v__ast__Type_has_flag(arg.typ, v__ast__TypeFlag__generic)) {
			has_generic = true;
			break;
		}
	}
	v__ast__Type return_type = _const_v__ast__void_type;
	v__token__Position return_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,};
	if (p->tok.line_nr == line_nr && v__token__Kind_is_start_of_type(p->tok.kind) && !v__parser__Parser_is_attributes(p)) {
		return_type_pos = v__token__Token_position(&p->tok);
		return_type = v__parser__Parser_parse_type(p);
		if (v__ast__Type_has_flag(return_type, v__ast__TypeFlag__generic)) {
			has_generic = true;
		}
		return_type_pos = v__token__Position_extend(return_type_pos, v__token__Token_position(&p->prev_tok));
	}
	v__ast__Fn func = (v__ast__Fn){
		.is_variadic = is_variadic,
		.language = 0,
		.is_pub = 0,
		.is_ctor_new = 0,
		.is_deprecated = 0,
		.is_noreturn = 0,
		.is_unsafe = 0,
		.is_placeholder = 0,
		.is_main = 0,
		.is_test = 0,
		.is_keep_alive = 0,
		.is_method = false,
		.no_body = 0,
		.mod = (string){.str=(byteptr)"", .is_lit=1},
		.file = (string){.str=(byteptr)"", .is_lit=1},
		.file_mode = 0,
		.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},
		.return_type_pos = return_type_pos,
		.return_type = return_type,
		.receiver_type = 0,
		.name = name,
		.params = args,
		.source_fn = 0,
		.usages = 0,
		.generic_names = __new_array(0, 0, sizeof(string)),
		.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),
		.is_conditional = 0,
		.ctdefine_idx = 0,
	};
	bool has_decl = p->builtin_mod && string_starts_with(name, _SLIT("Map")) && string_ends_with(name, _SLIT("Fn"));
	int idx = v__ast__Table_find_or_register_fn_type(p->table, p->mod, func, false, has_decl);
	if (has_generic) {
		v__ast__Type _t2 = v__ast__Type_set_flag(v__ast__new_type(idx), v__ast__TypeFlag__generic);
		return _t2;
	}
	v__ast__Type _t3 = v__ast__new_type(idx);
	return _t3;
}

v__ast__Type v__parser__Parser_parse_type_with_mut(v__parser__Parser* p, bool is_mut) {
	v__ast__Type typ = v__parser__Parser_parse_type(p);
	if (is_mut) {
		v__ast__Type _t1 = v__ast__Type_set_nr_muls(typ, 1);
		return _t1;
	}
	v__ast__Type _t2 = typ;
	return _t2;
}

v__ast__Language v__parser__Parser_parse_language(v__parser__Parser* p) {
	v__ast__Language language = (string__eq(p->tok.lit, _SLIT("C")) ? (v__ast__Language__c) : string__eq(p->tok.lit, _SLIT("JS")) ? (v__ast__Language__js) : (v__ast__Language__v));
	if (language != v__ast__Language__v) {
		v__parser__Parser_next(p);
		v__parser__Parser_check(p, v__token__Kind__dot);
	}
	v__ast__Language _t1 = language;
	return _t1;
}

v__ast__Type v__parser__Parser_parse_inline_sum_type(v__parser__Parser* p) {
	Array_v__ast__TypeNode variants = v__parser__Parser_parse_sum_type_variants(p);
	if (variants.len > 1) {
		if (variants.len > _const_v__parser__maximum_inline_sum_type_variants) {
			v__token__Position pos = v__token__Position_extend((*(v__ast__TypeNode*)/*ee elem_typ */array_get(variants, 0)).pos, (*(v__ast__TypeNode*)/*ee elem_typ */array_get(variants, variants.len - 1)).pos);
			v__parser__Parser_warn_with_pos(p,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("an inline sum type expects a maximum of "), 0xfe07, {.d_i32 = _const_v__parser__maximum_inline_sum_type_variants}}, {_SLIT(" types ("), 0xfe07, {.d_i32 = variants.len}}, {_SLIT(" were given)"), 0, { .d_c = 0 }}})), pos);
		}
		Array_string _t1 = __new_array(0, 0, sizeof(string));
		Array_v__ast__TypeNode _t1_orig = variants;
		int _t1_len = _t1_orig.len;
		_t1 = __new_array(0, _t1_len, sizeof(string));

		for (int _t2 = 0; _t2 < _t1_len; ++_t2) {
			v__ast__TypeNode it = ((v__ast__TypeNode*) _t1_orig.data)[_t2];
			string ti = v__ast__Table_sym(p->table, it.typ)->name;
			array_push((array*)&_t1, &ti);
		}
		Array_string variant_names =_t1;
		qsort(variant_names.data, variant_names.len, variant_names.element_size, (int (*)(const void *, const void *))&compare_1376677008124459278_string);
		string name =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("_v_anon_sum_type_"), 0xfe10, {.d_s = Array_string_join(variant_names, _SLIT("_"))}}, {_SLIT0, 0, { .d_c = 0 }}}));
		Array_v__ast__Type _t3 = __new_array(0, 0, sizeof(v__ast__Type));
		Array_v__ast__TypeNode _t3_orig = variants;
		int _t3_len = _t3_orig.len;
		_t3 = __new_array(0, _t3_len, sizeof(v__ast__Type));

		for (int _t4 = 0; _t4 < _t3_len; ++_t4) {
			v__ast__TypeNode it = ((v__ast__TypeNode*) _t3_orig.data)[_t4];
			v__ast__Type ti = it.typ;
			array_push((array*)&_t3, &ti);
		}
		Array_v__ast__Type variant_types =_t3;
		string prepend_mod_name = v__parser__Parser_prepend_mod(p, name);
		int idx = v__ast__Table_find_type_idx(p->table, prepend_mod_name);
		if (idx > 0) {
			v__ast__Type _t5 = v__ast__new_type(idx);
			return _t5;
		}
		idx = v__ast__Table_register_type_symbol(p->table, (v__ast__TypeSymbol){.parent_idx = 0,.info = v__ast__SumType_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__SumType, ((v__ast__SumType){.variants = variant_types,.fields = __new_array(0, 0, sizeof(v__ast__StructField)),.found_fields = 0,.is_anon = true,.is_generic = 0,.generic_types = __new_array(0, 0, sizeof(v__ast__Type)),.concrete_types = __new_array(0, 0, sizeof(v__ast__Type)),.parent_type = 0,}))),.kind = v__ast__Kind__sum_type,.name = prepend_mod_name,.cname = v__util__no_dots(prepend_mod_name),.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = p->mod,.is_public = 0,.language = 0,.idx = 0,});
		v__ast__Type _t6 = v__ast__new_type(idx);
		return _t6;
	} else if (variants.len == 1) {
		v__ast__Type _t7 = (*(v__ast__TypeNode*)/*ee elem_typ */array_get(variants, 0)).typ;
		return _t7;
	}
	v__ast__Type _t8 = ((v__ast__Type)(0));
	return _t8;
}

Array_v__ast__TypeNode v__parser__Parser_parse_sum_type_variants(v__parser__Parser* p) {
bool v__parser__Parser_parse_sum_type_variants_defer_0 = false;
	p->inside_sum_type = true;
	v__parser__Parser_parse_sum_type_variants_defer_0 = true;
	Array_v__ast__TypeNode types = __new_array_with_default(0, 0, sizeof(v__ast__TypeNode), 0);
	for (;;) {
		v__token__Position type_start_pos = v__token__Token_position(&p->tok);
		v__ast__Type typ = v__parser__Parser_parse_type(p);
		v__token__Token prev_tok = p->prev_tok;
		v__token__Position type_end_pos = v__token__Token_position(&prev_tok);
		v__token__Position type_pos = v__token__Position_extend(type_start_pos, type_end_pos);
		array_push((array*)&types, _MOV((v__ast__TypeNode[]){ (v__ast__TypeNode){.typ = typ,.pos = type_pos,} }));
		if (p->tok.kind != v__token__Kind__pipe) {
			break;
		}
		v__parser__Parser_check(p, v__token__Kind__pipe);
	}
	Array_v__ast__TypeNode _t2 = types;
	// Defer begin
	if (v__parser__Parser_parse_sum_type_variants_defer_0) {
		p->inside_sum_type = false;
	}
	// Defer end
	return _t2;
}

v__ast__Type v__parser__Parser_parse_type(v__parser__Parser* p) {
	bool is_optional = false;
	v__token__Position optional_pos = v__token__Token_position(&p->tok);
	if (p->tok.kind == v__token__Kind__question) {
		int line_nr = p->tok.line_nr;
		v__parser__Parser_next(p);
		is_optional = true;
		if (p->tok.line_nr > line_nr) {
			v__ast__Type typ = _const_v__ast__void_type;
			if (is_optional) {
				typ = v__ast__Type_set_flag(typ, v__ast__TypeFlag__optional);
			}
			v__ast__Type _t1 = typ;
			return _t1;
		}
	}
	bool is_shared = p->tok.kind == v__token__Kind__key_shared;
	bool is_atomic = p->tok.kind == v__token__Kind__key_atomic;
	if (is_shared) {
		v__parser__Parser_register_auto_import(p, _SLIT("sync"));
	}
	int nr_muls = 0;
	if (p->tok.kind == v__token__Kind__key_mut || is_shared || is_atomic) {
		nr_muls++;
		v__parser__Parser_next(p);
	}
	if (p->tok.kind == v__token__Kind__mul) {
		v__parser__Parser_error(p, _SLIT("use `&Type` instead of `*Type` when declaring references"));
		v__ast__Type _t2 = 0;
		return _t2;
	}
	int nr_amps = 0;
	for (;;) {
		if (!(p->tok.kind == v__token__Kind__amp)) break;
		nr_amps++;
		nr_muls++;
		v__parser__Parser_next(p);
	}
	v__ast__Language language = v__parser__Parser_parse_language(p);
	v__ast__Type typ = _const_v__ast__void_type;
	bool is_array = p->tok.kind == v__token__Kind__lsbr;
	if (p->tok.kind != v__token__Kind__lcbr) {
		v__token__Position pos = v__token__Token_position(&p->tok);
		typ = v__parser__Parser_parse_any_type(p, language, nr_muls > 0, true);
		if (v__ast__Type_idx(typ) == 0) {
			v__ast__Type _t3 = 0;
			return _t3;
		}
		if (v__ast__Type_alias_eq(typ, _const_v__ast__void_type)) {
			v__parser__Parser_error_with_pos(p, _SLIT("use `?` instead of `?void`"), pos);
			v__ast__Type _t4 = 0;
			return _t4;
		}
		v__ast__TypeSymbol* sym = v__ast__Table_sym(p->table, typ);
		if (is_optional && (sym->info)._typ == 464 /* v.ast.SumType */ && (/* as */ *(v__ast__SumType*)__as_cast((sym->info)._v__ast__SumType,(sym->info)._typ, 464) /*expected idx: 464, name: v.ast.SumType */ ).is_anon) {
			v__parser__Parser_error_with_pos(p, _SLIT("an inline sum type cannot be optional"), v__token__Position_extend(optional_pos, v__token__Token_position(&p->prev_tok)));
		}
	}
	if (is_optional) {
		typ = v__ast__Type_set_flag(typ, v__ast__TypeFlag__optional);
	}
	if (is_shared) {
		typ = v__ast__Type_set_flag(typ, v__ast__TypeFlag__shared_f);
	}
	if (is_atomic) {
		typ = v__ast__Type_set_flag(typ, v__ast__TypeFlag__atomic_f);
	}
	if (nr_muls > 0) {
		typ = v__ast__Type_set_nr_muls(typ, nr_muls);
		if (is_array && nr_amps > 0) {
			v__parser__Parser_error(p, _SLIT("V arrays are already references behind the scenes,\nthere is no need to use a reference to an array (e.g. use `[]string` instead of `&[]string`).\nIf you need to modify an array in a function, use a mutable argument instead: `fn foo(mut s []string) {}`."));
			v__ast__Type _t5 = 0;
			return _t5;
		}
	}
	v__ast__Type _t6 = typ;
	return _t6;
}

v__ast__Type v__parser__Parser_parse_any_type(v__parser__Parser* p, v__ast__Language language, bool is_ptr, bool check_dot) {
	string name = p->tok.lit;
	if (language == v__ast__Language__c) {
		name =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("C."), 0xfe10, {.d_s = name}}, {_SLIT0, 0, { .d_c = 0 }}}));
	} else if (language == v__ast__Language__js) {
		name =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("JS."), 0xfe10, {.d_s = name}}, {_SLIT0, 0, { .d_c = 0 }}}));
	} else if (p->peek_tok.kind == v__token__Kind__dot && check_dot) {
		string mod = name;
		v__token__Position mod_pos = v__token__Token_position(&p->tok);
		v__parser__Parser_next(p);
		v__parser__Parser_check(p, v__token__Kind__dot);
		string mod_last_part = mod;
		for (;;) {
			if (!(p->peek_tok.kind == v__token__Kind__dot)) break;
			mod_pos = v__token__Position_extend(mod_pos, v__token__Token_position(&p->tok));
			mod_last_part = p->tok.lit;
			mod = /*f*/string__plus(mod,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("."), 0xfe10, {.d_s = mod_last_part}}, {_SLIT0, 0, { .d_c = 0 }}})));
			v__parser__Parser_next(p);
			v__parser__Parser_check(p, v__token__Kind__dot);
		}
		if (!v__parser__Parser_known_import(p, mod) && !p->pref->is_fmt) {
			string msg =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unknown module `"), 0xfe10, {.d_s = mod}}, {_SLIT("`"), 0, { .d_c = 0 }}}));
			if (mod.len > mod_last_part.len && v__parser__Parser_known_import(p, mod_last_part)) {
				msg = /*f*/string__plus(msg,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("; did you mean `"), 0xfe10, {.d_s = mod_last_part}}, {_SLIT("`?"), 0, { .d_c = 0 }}})));
			}
			v__parser__Parser_error_with_pos(p, msg, mod_pos);
			v__ast__Type _t1 = 0;
			return _t1;
		}
		if (_IN_MAP(ADDR(string, mod), ADDR(map, p->imports))) {
			v__parser__Parser_register_used_import(p, mod);
			mod = (*(string*)map_get(ADDR(map, p->imports), &(string[]){mod}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} }));
		}
		name =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = mod}}, {_SLIT("."), 0xfe10, {.d_s = p->tok.lit}}, {_SLIT0, 0, { .d_c = 0 }}}));
		if (p->tok.lit.len > 0 && !byte_is_capital(string_at(p->tok.lit, 0))) {
			v__parser__Parser_error(p, _SLIT("imported types must start with a capital letter"));
			v__ast__Type _t2 = 0;
			return _t2;
		}
	} else if ((p->expr_mod).len != 0 && !p->inside_generic_params) {
		name = string__plus(string__plus(p->expr_mod, _SLIT(".")), name);
	} else if (_IN_MAP(ADDR(string, name), ADDR(map, p->imported_symbols))) {
		name = (*(string*)map_get(ADDR(map, p->imported_symbols), &(string[]){name}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} }));
	} else if (!p->builtin_mod && name.len > 1 && !_IN_MAP(ADDR(string, name), ADDR(map, p->table->type_idxs))) {
		name = string__plus(string__plus(p->mod, _SLIT(".")), name);
	}

	if (p->tok.kind == (v__token__Kind__key_fn)) {
		v__ast__Type _t3 = v__parser__Parser_parse_fn_type(p, _SLIT(""));
		return _t3;
	}
	else if (p->tok.kind == (v__token__Kind__lsbr) || p->tok.kind == (v__token__Kind__nilsbr)) {
		v__ast__Type _t4 = v__parser__Parser_parse_array_type(p, p->tok.kind);
		return _t4;
	}
	else {
		if (p->tok.kind == v__token__Kind__lpar && !p->inside_sum_type) {
			if (is_ptr) {
				v__parser__Parser_error(p, _SLIT("parse_type: unexpected `&` before multiple returns"));
				v__ast__Type _t5 = 0;
				return _t5;
			}
			v__ast__Type _t6 = v__parser__Parser_parse_multi_return_type(p);
			return _t6;
		}
		if (((p->peek_tok.kind == v__token__Kind__dot && v__parser__Parser_peek_token(p, 3).kind == v__token__Kind__pipe) || p->peek_tok.kind == v__token__Kind__pipe) && !p->inside_sum_type && !p->inside_receiver_param) {
			v__ast__Type _t7 = v__parser__Parser_parse_inline_sum_type(p);
			return _t7;
		}
		if (string__eq(name, _SLIT("map"))) {
			v__ast__Type _t8 = v__parser__Parser_parse_map_type(p);
			return _t8;
		}
		if (string__eq(name, _SLIT("chan"))) {
			v__ast__Type _t9 = v__parser__Parser_parse_chan_type(p);
			return _t9;
		}
		if (string__eq(name, _SLIT("thread"))) {
			v__ast__Type _t10 = v__parser__Parser_parse_thread_type(p);
			return _t10;
		}
		v__ast__Type ret = ((v__ast__Type)(0));
		if ((name).len == 0) {
			v__parser__Parser_error(p, _SLIT("expecting type declaration"));
		} else {

			if (string__eq(name, _SLIT("voidptr"))) {
				ret = _const_v__ast__voidptr_type;
			}
			else if (string__eq(name, _SLIT("byteptr"))) {
				ret = _const_v__ast__byteptr_type;
			}
			else if (string__eq(name, _SLIT("charptr"))) {
				ret = _const_v__ast__charptr_type;
			}
			else if (string__eq(name, _SLIT("i8"))) {
				ret = _const_v__ast__i8_type;
			}
			else if (string__eq(name, _SLIT("i16"))) {
				ret = _const_v__ast__i16_type;
			}
			else if (string__eq(name, _SLIT("int"))) {
				ret = _const_v__ast__int_type;
			}
			else if (string__eq(name, _SLIT("i64"))) {
				ret = _const_v__ast__i64_type;
			}
			else if (string__eq(name, _SLIT("byte"))) {
				ret = _const_v__ast__byte_type;
			}
			else if (string__eq(name, _SLIT("u16"))) {
				ret = _const_v__ast__u16_type;
			}
			else if (string__eq(name, _SLIT("u32"))) {
				ret = _const_v__ast__u32_type;
			}
			else if (string__eq(name, _SLIT("u64"))) {
				ret = _const_v__ast__u64_type;
			}
			else if (string__eq(name, _SLIT("f32"))) {
				ret = _const_v__ast__f32_type;
			}
			else if (string__eq(name, _SLIT("f64"))) {
				ret = _const_v__ast__f64_type;
			}
			else if (string__eq(name, _SLIT("string"))) {
				ret = _const_v__ast__string_type;
			}
			else if (string__eq(name, _SLIT("char"))) {
				ret = _const_v__ast__char_type;
			}
			else if (string__eq(name, _SLIT("bool"))) {
				ret = _const_v__ast__bool_type;
			}
			else if (string__eq(name, _SLIT("float_literal"))) {
				ret = _const_v__ast__float_literal_type;
			}
			else if (string__eq(name, _SLIT("int_literal"))) {
				ret = _const_v__ast__int_literal_type;
			}
			else {
				v__parser__Parser_next(p);
				if (name.len == 1 && byte_is_capital(string_at(name, 0))) {
					v__ast__Type _t11 = v__parser__Parser_parse_generic_type(p, name);
					return _t11;
				}
				if (p->tok.kind == v__token__Kind__lt) {
					v__ast__Type _t12 = v__parser__Parser_parse_generic_inst_type(p, name);
					return _t12;
				}
				v__ast__Type _t13 = v__parser__Parser_find_type_or_add_placeholder(p, name, language);
				return _t13;
			};
		}
		v__parser__Parser_next(p);
		v__ast__Type _t14 = ret;
		return _t14;
	};
	return 0;
}

v__ast__Type v__parser__Parser_find_type_or_add_placeholder(v__parser__Parser* p, string name, v__ast__Language language) {
	int idx = v__ast__Table_find_type_idx(p->table, name);
	if (idx > 0) {
		v__ast__Type _t1 = v__ast__new_type(idx);
		return _t1;
	}
	idx = v__ast__Table_add_placeholder_type(p->table, name, language);
	v__ast__Type _t2 = v__ast__new_type(idx);
	return _t2;
}

v__ast__Type v__parser__Parser_parse_generic_type(v__parser__Parser* p, string name) {
	int idx = v__ast__Table_find_type_idx(p->table, name);
	if (idx > 0) {
		v__ast__Type _t1 = v__ast__Type_set_flag(v__ast__new_type(idx), v__ast__TypeFlag__generic);
		return _t1;
	}
	idx = v__ast__Table_register_type_symbol(p->table, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind__any,.name = name,.cname = v__util__no_dots(name),.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = p->mod,.is_public = true,.language = 0,.idx = 0,});
	v__ast__Type _t2 = v__ast__Type_set_flag(v__ast__new_type(idx), v__ast__TypeFlag__generic);
	return _t2;
}

v__ast__Type v__parser__Parser_parse_generic_inst_type(v__parser__Parser* p, string name) {
	string bs_name = name;
	string bs_cname = name;
	v__token__Position start_pos = v__token__Token_position(&p->tok);
	v__parser__Parser_next(p);
	p->inside_generic_params = true;
	bs_name = /*f*/string__plus(bs_name, _SLIT("<"));
	bs_cname = /*f*/string__plus(bs_cname, _SLIT("_T_"));
	Array_v__ast__Type concrete_types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
	bool is_instance = false;
	for (;;) {
		if (!(p->tok.kind != v__token__Kind__eof)) break;
		v__ast__Type gt = v__parser__Parser_parse_type(p);
		if (!v__ast__Type_has_flag(gt, v__ast__TypeFlag__generic)) {
			is_instance = true;
		}
		v__ast__TypeSymbol* gts = v__ast__Table_sym(p->table, gt);
		bs_name = /*f*/string__plus(bs_name, gts->name);
		bs_cname = /*f*/string__plus(bs_cname, gts->cname);
		array_push((array*)&concrete_types, _MOV((v__ast__Type[]){ gt }));
		if (p->tok.kind != v__token__Kind__comma) {
			break;
		}
		v__parser__Parser_next(p);
		bs_name = /*f*/string__plus(bs_name, _SLIT(", "));
		bs_cname = /*f*/string__plus(bs_cname, _SLIT("_"));
	}
	v__token__Position concrete_types_pos = v__token__Position_extend(start_pos, v__token__Token_position(&p->tok));
	v__parser__Parser_check(p, v__token__Kind__gt);
	p->inside_generic_params = false;
	bs_name = /*f*/string__plus(bs_name, _SLIT(">"));
	if ((is_instance || p->pref->is_fmt) && concrete_types.len > 0) {
		int gt_idx = v__ast__Table_find_type_idx(p->table, bs_name);
		if (gt_idx > 0) {
			v__ast__Type _t2 = v__ast__new_type(gt_idx);
			return _t2;
		}
		gt_idx = v__ast__Table_add_placeholder_type(p->table, bs_name, v__ast__Language__v);
		int parent_idx = (*(int*)map_get(ADDR(map, p->table->type_idxs), &(string[]){name}, &(int[]){ 0 }));
		if (parent_idx == 0) {
			parent_idx = v__ast__Table_add_placeholder_type(p->table, name, v__ast__Language__v);
		}
		v__ast__TypeSymbol* parent_sym = v__ast__Table_sym(p->table, v__ast__new_type(parent_idx));
		if (parent_sym->info._typ == 446 /* v.ast.Struct */) {
			if ((*parent_sym->info._v__ast__Struct).generic_types.len == 0) {
				v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("struct `"), 0xfe10, {.d_s = parent_sym->name}}, {_SLIT("` is not a generic struct, cannot instantiate to the concrete types"), 0, { .d_c = 0 }}})), concrete_types_pos);
			} else if ((*parent_sym->info._v__ast__Struct).generic_types.len != concrete_types.len) {
				v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("the number of generic types of struct `"), 0xfe10, {.d_s = parent_sym->name}}, {_SLIT("` is inconsistent with the concrete types"), 0, { .d_c = 0 }}})), concrete_types_pos);
			}
		}
		else if (parent_sym->info._typ == 463 /* v.ast.Interface */) {
			if ((*parent_sym->info._v__ast__Interface).generic_types.len == 0) {
				v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("interface `"), 0xfe10, {.d_s = parent_sym->name}}, {_SLIT("` is not a generic interface, cannot instantiate to the concrete types"), 0, { .d_c = 0 }}})), concrete_types_pos);
			} else if ((*parent_sym->info._v__ast__Interface).generic_types.len != concrete_types.len) {
				v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("the number of generic types of interfce `"), 0xfe10, {.d_s = parent_sym->name}}, {_SLIT("` is inconsistent with the concrete types"), 0, { .d_c = 0 }}})), concrete_types_pos);
			}
		}
		else if (parent_sym->info._typ == 464 /* v.ast.SumType */) {
			if ((*parent_sym->info._v__ast__SumType).generic_types.len == 0) {
				v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("sumtype `"), 0xfe10, {.d_s = parent_sym->name}}, {_SLIT("` is not a generic sumtype, cannot instantiate to the concrete types"), 0, { .d_c = 0 }}})), concrete_types_pos);
			} else if ((*parent_sym->info._v__ast__SumType).generic_types.len != concrete_types.len) {
				v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("the number of generic types of sumtype `"), 0xfe10, {.d_s = parent_sym->name}}, {_SLIT("` is inconsistent with the concrete types"), 0, { .d_c = 0 }}})), concrete_types_pos);
			}
		}
		
		else {
		}
		;
		int idx = v__ast__Table_register_type_symbol(p->table, (v__ast__TypeSymbol){.parent_idx = 0,.info = v__ast__GenericInst_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__GenericInst, ((v__ast__GenericInst){.parent_idx = parent_idx,.concrete_types = concrete_types,}))),.kind = v__ast__Kind__generic_inst,.name = bs_name,.cname = v__util__no_dots(bs_cname),.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = p->mod,.is_public = 0,.language = 0,.idx = 0,});
		v__ast__Type _t3 = v__ast__new_type(idx);
		return _t3;
	}
	v__ast__Type _t4 = v__ast__Type_set_flag(v__parser__Parser_find_type_or_add_placeholder(p, name, v__ast__Language__v), v__ast__TypeFlag__generic);
	return _t4;
}

v__ast__Stmt v__parser__parse_stmt(string text, v__ast__Table* table, v__ast__Scope* scope) {
bool v__parser__parse_stmt_defer_0 = false;
	v__parser__Parser p = (v__parser__Parser){.pref = (v__pref__Preferences*)memdup(&(v__pref__Preferences){.os = 0,.backend = 0,.build_mode = 0,.arch = 0,.output_mode = v__pref__OutputMode__stdout,.is_verbose = 0,.is_test = 0,.is_script = 0,.is_vsh = 0,.is_livemain = 0,.is_liveshared = 0,.is_shared = 0,.is_o = 0,.is_prof = 0,.test_runner = (string){.str=(byteptr)"", .is_lit=1},.profile_file = (string){.str=(byteptr)"", .is_lit=1},.profile_no_inline = 0,.translated = 0,.is_prod = 0,.obfuscate = 0,.is_repl = 0,.is_run = 0,.is_debug = 0,.is_vlines = 0,.sanitize = 0,.sourcemap = 0,.sourcemap_inline = true,.sourcemap_src_included = 0,.show_cc = 0,.show_c_output = 0,.show_callgraph = 0,.show_depgraph = 0,.dump_c_flags = (string){.str=(byteptr)"", .is_lit=1},.use_cache = 0,.retry_compilation = true,.is_stats = 0,.cflags = (string){.str=(byteptr)"", .is_lit=1},.m64 = 0,.ccompiler = (string){.str=(byteptr)"", .is_lit=1},.ccompiler_type = 0,.third_party_option = (string){.str=(byteptr)"", .is_lit=1},.building_v = 0,.autofree = 0,.compress = 0,.no_builtin = 0,.enable_globals = 0,.is_fmt = 0,.is_vet = 0,.is_bare = 0,.bare_builtin_dir = (string){.str=(byteptr)"", .is_lit=1},.no_preludes = 0,.custom_prelude = (string){.str=(byteptr)"", .is_lit=1},.lookup_path = __new_array(0, 0, sizeof(string)),.output_cross_c = 0,.output_es5 = 0,.prealloc = 0,.vroot = (string){.str=(byteptr)"", .is_lit=1},.out_name_c = (string){.str=(byteptr)"", .is_lit=1},.out_name = (string){.str=(byteptr)"", .is_lit=1},.path = (string){.str=(byteptr)"", .is_lit=1},.run_only = __new_array(0, 0, sizeof(string)),.compile_defines = __new_array(0, 0, sizeof(string)),.compile_defines_all = __new_array(0, 0, sizeof(string)),.run_args = __new_array(0, 0, sizeof(string)),.printfn_list = __new_array(0, 0, sizeof(string)),.print_v_files = 0,.skip_running = 0,.skip_warnings = 0,.warn_impure_v = 0,.warns_are_errors = 0,.fatal_errors = 0,.reuse_tmpc = 0,.no_rsp = 0,.no_std = 0,.use_color = 0,.no_parallel = 0,.is_vweb = 0,.only_check_syntax = 0,.check_only = 0,.experimental = 0,.skip_unused = 0,.show_timings = 0,.is_ios_simulator = 0,.is_apk = 0,.cleanup_files = __new_array(0, 0, sizeof(string)),.build_options = __new_array(0, 0, sizeof(string)),.cache_manager = (v__vcache__CacheManager){.basepath = (string){.str=(byteptr)"", .is_lit=1},.original_vopts = (string){.str=(byteptr)"", .is_lit=1},.vopts = (string){.str=(byteptr)"", .is_lit=1},.k2cpath = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),},.is_help = 0,.gc_mode = v__pref__GarbageCollectionMode__no_gc,.is_cstrict = 0,.assert_failure_mode = 0,.message_limit = 100,.nofloat = 0,.checker_match_exhaustive_cutoff_limit = 12,}, sizeof(v__pref__Preferences)),.file_base = (string){.str=(byteptr)"", .is_lit=1},.file_name = (string){.str=(byteptr)"", .is_lit=1},.file_name_dir = (string){.str=(byteptr)"", .is_lit=1},.unique_prefix = (string){.str=(byteptr)"", .is_lit=1},.file_backend_mode = 0,.scanner = v__scanner__new_scanner(text, v__scanner__CommentsMode__skip_comments, (v__pref__Preferences*)memdup(&(v__pref__Preferences){.os = 0,.backend = 0,.build_mode = 0,.arch = 0,.output_mode = v__pref__OutputMode__stdout,.is_verbose = 0,.is_test = 0,.is_script = 0,.is_vsh = 0,.is_livemain = 0,.is_liveshared = 0,.is_shared = 0,.is_o = 0,.is_prof = 0,.test_runner = (string){.str=(byteptr)"", .is_lit=1},.profile_file = (string){.str=(byteptr)"", .is_lit=1},.profile_no_inline = 0,.translated = 0,.is_prod = 0,.obfuscate = 0,.is_repl = 0,.is_run = 0,.is_debug = 0,.is_vlines = 0,.sanitize = 0,.sourcemap = 0,.sourcemap_inline = true,.sourcemap_src_included = 0,.show_cc = 0,.show_c_output = 0,.show_callgraph = 0,.show_depgraph = 0,.dump_c_flags = (string){.str=(byteptr)"", .is_lit=1},.use_cache = 0,.retry_compilation = true,.is_stats = 0,.cflags = (string){.str=(byteptr)"", .is_lit=1},.m64 = 0,.ccompiler = (string){.str=(byteptr)"", .is_lit=1},.ccompiler_type = 0,.third_party_option = (string){.str=(byteptr)"", .is_lit=1},.building_v = 0,.autofree = 0,.compress = 0,.no_builtin = 0,.enable_globals = 0,.is_fmt = 0,.is_vet = 0,.is_bare = 0,.bare_builtin_dir = (string){.str=(byteptr)"", .is_lit=1},.no_preludes = 0,.custom_prelude = (string){.str=(byteptr)"", .is_lit=1},.lookup_path = __new_array(0, 0, sizeof(string)),.output_cross_c = 0,.output_es5 = 0,.prealloc = 0,.vroot = (string){.str=(byteptr)"", .is_lit=1},.out_name_c = (string){.str=(byteptr)"", .is_lit=1},.out_name = (string){.str=(byteptr)"", .is_lit=1},.path = (string){.str=(byteptr)"", .is_lit=1},.run_only = __new_array(0, 0, sizeof(string)),.compile_defines = __new_array(0, 0, sizeof(string)),.compile_defines_all = __new_array(0, 0, sizeof(string)),.run_args = __new_array(0, 0, sizeof(string)),.printfn_list = __new_array(0, 0, sizeof(string)),.print_v_files = 0,.skip_running = 0,.skip_warnings = 0,.warn_impure_v = 0,.warns_are_errors = 0,.fatal_errors = 0,.reuse_tmpc = 0,.no_rsp = 0,.no_std = 0,.use_color = 0,.no_parallel = 0,.is_vweb = 0,.only_check_syntax = 0,.check_only = 0,.experimental = 0,.skip_unused = 0,.show_timings = 0,.is_ios_simulator = 0,.is_apk = 0,.cleanup_files = __new_array(0, 0, sizeof(string)),.build_options = __new_array(0, 0, sizeof(string)),.cache_manager = (v__vcache__CacheManager){.basepath = (string){.str=(byteptr)"", .is_lit=1},.original_vopts = (string){.str=(byteptr)"", .is_lit=1},.vopts = (string){.str=(byteptr)"", .is_lit=1},.k2cpath = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),},.is_help = 0,.gc_mode = v__pref__GarbageCollectionMode__no_gc,.is_cstrict = 0,.assert_failure_mode = 0,.message_limit = 100,.nofloat = 0,.checker_match_exhaustive_cutoff_limit = 12,}, sizeof(v__pref__Preferences))),.comments_mode = v__scanner__CommentsMode__skip_comments,.tok = (v__token__Token){.lit = (string){.str=(byteptr)"", .is_lit=1},.line_nr = 0,.col = 0,.pos = 0,.len = 0,.tidx = 0,},.prev_tok = (v__token__Token){.lit = (string){.str=(byteptr)"", .is_lit=1},.line_nr = 0,.col = 0,.pos = 0,.len = 0,.tidx = 0,},.peek_tok = (v__token__Token){.lit = (string){.str=(byteptr)"", .is_lit=1},.line_nr = 0,.col = 0,.pos = 0,.len = 0,.tidx = 0,},.table = table,.language = 0,.fn_language = 0,.expr_level = 0,.inside_vlib_file = 0,.inside_test_file = true,.inside_if = 0,.inside_if_expr = 0,.inside_ct_if_expr = 0,.inside_or_expr = 0,.inside_for = 0,.inside_fn = 0,.inside_unsafe_fn = 0,.inside_str_interp = 0,.inside_array_lit = 0,.inside_in_array = 0,.inside_match = 0,.inside_select = 0,.inside_match_case = 0,.inside_match_body = 0,.inside_unsafe = 0,.inside_sum_type = 0,.inside_asm_template = 0,.inside_asm = 0,.inside_defer = 0,.inside_generic_params = 0,.inside_receiver_param = 0,.or_is_handled = 0,.builtin_mod = 0,.mod = (string){.str=(byteptr)"", .is_lit=1},.is_manualfree = 0,.has_globals = 0,.is_generated = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.expr_mod = (string){.str=(byteptr)"", .is_lit=1},.scope = scope,.imports = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.ast_imports = __new_array(0, 0, sizeof(v__ast__Import)),.used_imports = __new_array(0, 0, sizeof(string)),.auto_imports = __new_array(0, 0, sizeof(string)),.imported_symbols = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.is_amp = 0,.returns = 0,.is_stmt_ident = 0,.expecting_type = 0,.errors = __new_array(0, 0, sizeof(v__errors__Error)),.warnings = __new_array(0, 0, sizeof(v__errors__Warning)),.notices = __new_array(0, 0, sizeof(v__errors__Notice)),.vet_errors = __new_array(0, 0, sizeof(v__vet__Error)),.cur_fn_name = (string){.str=(byteptr)"", .is_lit=1},.label_names = __new_array(0, 0, sizeof(string)),.name_error = 0,.n_asm = 0,.global_labels = __new_array(0, 0, sizeof(string)),.comptime_if_cond = 0,.defer_vars = __new_array(0, 0, sizeof(v__ast__Ident)),.should_abort = 0,.codegen_text = (string){.str=(byteptr)"", .is_lit=1},};
	v__parser__Parser_init_parse_fns(&p);
	v__util__timing_start(_SLIT("PARSE stmt"));
	v__parser__parse_stmt_defer_0 = true;
	v__parser__Parser_read_first_token(&p);
	v__ast__Stmt _t1 = v__parser__Parser_stmt(&p, false);
	// Defer begin
	if (v__parser__parse_stmt_defer_0) {
		v__util__timing_measure_cumulative(_SLIT("PARSE stmt"));
	}
	// Defer end
	return _t1;
}

v__ast__File* v__parser__parse_comptime(string text, v__ast__Table* table, v__pref__Preferences* pref, v__ast__Scope* scope) {
	v__parser__Parser p = (v__parser__Parser){
		.pref = pref,
		.file_base = (string){.str=(byteptr)"", .is_lit=1},
		.file_name = (string){.str=(byteptr)"", .is_lit=1},
		.file_name_dir = (string){.str=(byteptr)"", .is_lit=1},
		.unique_prefix = (string){.str=(byteptr)"", .is_lit=1},
		.file_backend_mode = 0,
		.scanner = v__scanner__new_scanner(text, v__scanner__CommentsMode__skip_comments, pref),
		.comments_mode = v__scanner__CommentsMode__skip_comments,
		.tok = (v__token__Token){.lit = (string){.str=(byteptr)"", .is_lit=1},.line_nr = 0,.col = 0,.pos = 0,.len = 0,.tidx = 0,},
		.prev_tok = (v__token__Token){.lit = (string){.str=(byteptr)"", .is_lit=1},.line_nr = 0,.col = 0,.pos = 0,.len = 0,.tidx = 0,},
		.peek_tok = (v__token__Token){.lit = (string){.str=(byteptr)"", .is_lit=1},.line_nr = 0,.col = 0,.pos = 0,.len = 0,.tidx = 0,},
		.table = table,
		.language = 0,
		.fn_language = 0,
		.expr_level = 0,
		.inside_vlib_file = 0,
		.inside_test_file = 0,
		.inside_if = 0,
		.inside_if_expr = 0,
		.inside_ct_if_expr = 0,
		.inside_or_expr = 0,
		.inside_for = 0,
		.inside_fn = 0,
		.inside_unsafe_fn = 0,
		.inside_str_interp = 0,
		.inside_array_lit = 0,
		.inside_in_array = 0,
		.inside_match = 0,
		.inside_select = 0,
		.inside_match_case = 0,
		.inside_match_body = 0,
		.inside_unsafe = 0,
		.inside_sum_type = 0,
		.inside_asm_template = 0,
		.inside_asm = 0,
		.inside_defer = 0,
		.inside_generic_params = 0,
		.inside_receiver_param = 0,
		.or_is_handled = 0,
		.builtin_mod = 0,
		.mod = (string){.str=(byteptr)"", .is_lit=1},
		.is_manualfree = 0,
		.has_globals = 0,
		.is_generated = 0,
		.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),
		.expr_mod = (string){.str=(byteptr)"", .is_lit=1},
		.scope = scope,
		.imports = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.ast_imports = __new_array(0, 0, sizeof(v__ast__Import)),
		.used_imports = __new_array(0, 0, sizeof(string)),
		.auto_imports = __new_array(0, 0, sizeof(string)),
		.imported_symbols = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.is_amp = 0,
		.returns = 0,
		.is_stmt_ident = 0,
		.expecting_type = 0,
		.errors = __new_array_with_default(0, 0, sizeof(v__errors__Error), 0),
		.warnings = __new_array_with_default(0, 0, sizeof(v__errors__Warning), 0),
		.notices = __new_array(0, 0, sizeof(v__errors__Notice)),
		.vet_errors = __new_array(0, 0, sizeof(v__vet__Error)),
		.cur_fn_name = (string){.str=(byteptr)"", .is_lit=1},
		.label_names = __new_array(0, 0, sizeof(string)),
		.name_error = 0,
		.n_asm = 0,
		.global_labels = __new_array(0, 0, sizeof(string)),
		.comptime_if_cond = 0,
		.defer_vars = __new_array(0, 0, sizeof(v__ast__Ident)),
		.should_abort = 0,
		.codegen_text = (string){.str=(byteptr)"", .is_lit=1},
	};
	v__ast__File* res = v__parser__Parser_parse(&p);
	v__parser__Parser_free_scanner(&p);
	v__ast__File* _t1 = res;
	return _t1;
}

v__ast__File* v__parser__parse_text(string text, string path, v__ast__Table* table, v__scanner__CommentsMode comments_mode, v__pref__Preferences* pref) {
	v__parser__Parser p = (v__parser__Parser){
		.pref = pref,
		.file_base = (string){.str=(byteptr)"", .is_lit=1},
		.file_name = (string){.str=(byteptr)"", .is_lit=1},
		.file_name_dir = (string){.str=(byteptr)"", .is_lit=1},
		.unique_prefix = (string){.str=(byteptr)"", .is_lit=1},
		.file_backend_mode = 0,
		.scanner = v__scanner__new_scanner(text, comments_mode, pref),
		.comments_mode = comments_mode,
		.tok = (v__token__Token){.lit = (string){.str=(byteptr)"", .is_lit=1},.line_nr = 0,.col = 0,.pos = 0,.len = 0,.tidx = 0,},
		.prev_tok = (v__token__Token){.lit = (string){.str=(byteptr)"", .is_lit=1},.line_nr = 0,.col = 0,.pos = 0,.len = 0,.tidx = 0,},
		.peek_tok = (v__token__Token){.lit = (string){.str=(byteptr)"", .is_lit=1},.line_nr = 0,.col = 0,.pos = 0,.len = 0,.tidx = 0,},
		.table = table,
		.language = 0,
		.fn_language = 0,
		.expr_level = 0,
		.inside_vlib_file = 0,
		.inside_test_file = 0,
		.inside_if = 0,
		.inside_if_expr = 0,
		.inside_ct_if_expr = 0,
		.inside_or_expr = 0,
		.inside_for = 0,
		.inside_fn = 0,
		.inside_unsafe_fn = 0,
		.inside_str_interp = 0,
		.inside_array_lit = 0,
		.inside_in_array = 0,
		.inside_match = 0,
		.inside_select = 0,
		.inside_match_case = 0,
		.inside_match_body = 0,
		.inside_unsafe = 0,
		.inside_sum_type = 0,
		.inside_asm_template = 0,
		.inside_asm = 0,
		.inside_defer = 0,
		.inside_generic_params = 0,
		.inside_receiver_param = 0,
		.or_is_handled = 0,
		.builtin_mod = 0,
		.mod = (string){.str=(byteptr)"", .is_lit=1},
		.is_manualfree = 0,
		.has_globals = 0,
		.is_generated = 0,
		.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),
		.expr_mod = (string){.str=(byteptr)"", .is_lit=1},
		.scope = (v__ast__Scope*)memdup(&(v__ast__Scope){.objects = new_map(sizeof(string), sizeof(v__ast__ScopeObject), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.struct_fields = new_map(sizeof(string), sizeof(v__ast__ScopeStructField), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.parent = table->global_scope,.detached_from_parent = 0,.children = __new_array(0, 0, sizeof(v__ast__Scope*)),.start_pos = 0,.end_pos = 0,}, sizeof(v__ast__Scope)),
		.imports = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.ast_imports = __new_array(0, 0, sizeof(v__ast__Import)),
		.used_imports = __new_array(0, 0, sizeof(string)),
		.auto_imports = __new_array(0, 0, sizeof(string)),
		.imported_symbols = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.is_amp = 0,
		.returns = 0,
		.is_stmt_ident = 0,
		.expecting_type = 0,
		.errors = __new_array_with_default(0, 0, sizeof(v__errors__Error), 0),
		.warnings = __new_array_with_default(0, 0, sizeof(v__errors__Warning), 0),
		.notices = __new_array(0, 0, sizeof(v__errors__Notice)),
		.vet_errors = __new_array(0, 0, sizeof(v__vet__Error)),
		.cur_fn_name = (string){.str=(byteptr)"", .is_lit=1},
		.label_names = __new_array(0, 0, sizeof(string)),
		.name_error = 0,
		.n_asm = 0,
		.global_labels = __new_array(0, 0, sizeof(string)),
		.comptime_if_cond = 0,
		.defer_vars = __new_array(0, 0, sizeof(v__ast__Ident)),
		.should_abort = 0,
		.codegen_text = (string){.str=(byteptr)"", .is_lit=1},
	};
	v__parser__Parser_set_path(&p, path);
	v__ast__File* res = v__parser__Parser_parse(&p);
	v__parser__Parser_free_scanner(&p);
	v__ast__File* _t1 = res;
	return _t1;
}

// Attr: [unsafe]
void v__parser__Parser_free(v__parser__Parser* p) {
	v__parser__Parser_free_scanner(p);
}

// Attr: [unsafe]
void v__parser__Parser_free_scanner(v__parser__Parser* p) {
	{ // Unsafe block
		if (p->scanner != 0) {
			v__scanner__Scanner_free(p->scanner);
			p->scanner = ((v__scanner__Scanner*)(0));
		}
	}
}

void v__parser__Parser_set_path(v__parser__Parser* p, string path) {
	p->file_name = path;
	p->file_base = os__base(path);
	p->file_name_dir = os__dir(path);
	if (string_contains(p->file_name_dir, _SLIT("vlib"))) {
		p->inside_vlib_file = true;
	}
	u64 hash = hash__fnv1a__sum64_string(path);
	p->unique_prefix = u64_hex_full(hash);
	if (string_ends_with(p->file_base, _SLIT("_test.v")) || string_ends_with(p->file_base, _SLIT("_test.vv"))) {
		p->inside_test_file = true;
	}
	string before_dot_v = string_all_before_last(path, _SLIT(".v"));
	string language = string_all_after_last(before_dot_v, _SLIT("."));
	string language_with_underscore = string_all_after_last(before_dot_v, _SLIT("_"));
	if (string__eq(language, before_dot_v) && string__eq(language_with_underscore, before_dot_v)) {
		p->file_backend_mode = v__ast__Language__v;
		return;
	}
	string actual_language = (string__eq(language, before_dot_v) ? (language_with_underscore) : (language));

	if (string__eq(actual_language, _SLIT("c"))) {
		p->file_backend_mode = v__ast__Language__c;
	}
	else if (string__eq(actual_language, _SLIT("js"))) {
		p->file_backend_mode = v__ast__Language__js;
	}
	else {
		Option_v__pref__Arch _t1 = v__pref__arch_from_string(actual_language);
		if (_t1.state != 0) { /*or block*/ 
			IError err = _t1.err;
			*(v__pref__Arch*) _t1.data = v__pref__Arch___auto;
		}
		
 		v__pref__Arch arch =  (*(v__pref__Arch*)_t1.data);
		p->file_backend_mode = v__ast__pref_arch_to_table_language(arch);
		if (arch == v__pref__Arch___auto) {
			p->file_backend_mode = v__ast__Language__v;
		}
	};
}

v__ast__File* v__parser__parse_file(string path, v__ast__Table* table, v__scanner__CommentsMode comments_mode, v__pref__Preferences* pref) {
	v__parser__Parser p = (v__parser__Parser){
		.pref = pref,
		.file_base = (string){.str=(byteptr)"", .is_lit=1},
		.file_name = (string){.str=(byteptr)"", .is_lit=1},
		.file_name_dir = (string){.str=(byteptr)"", .is_lit=1},
		.unique_prefix = (string){.str=(byteptr)"", .is_lit=1},
		.file_backend_mode = 0,
		.scanner = v__scanner__new_scanner_file(path, comments_mode, pref),
		.comments_mode = comments_mode,
		.tok = (v__token__Token){.lit = (string){.str=(byteptr)"", .is_lit=1},.line_nr = 0,.col = 0,.pos = 0,.len = 0,.tidx = 0,},
		.prev_tok = (v__token__Token){.lit = (string){.str=(byteptr)"", .is_lit=1},.line_nr = 0,.col = 0,.pos = 0,.len = 0,.tidx = 0,},
		.peek_tok = (v__token__Token){.lit = (string){.str=(byteptr)"", .is_lit=1},.line_nr = 0,.col = 0,.pos = 0,.len = 0,.tidx = 0,},
		.table = table,
		.language = 0,
		.fn_language = 0,
		.expr_level = 0,
		.inside_vlib_file = 0,
		.inside_test_file = 0,
		.inside_if = 0,
		.inside_if_expr = 0,
		.inside_ct_if_expr = 0,
		.inside_or_expr = 0,
		.inside_for = 0,
		.inside_fn = 0,
		.inside_unsafe_fn = 0,
		.inside_str_interp = 0,
		.inside_array_lit = 0,
		.inside_in_array = 0,
		.inside_match = 0,
		.inside_select = 0,
		.inside_match_case = 0,
		.inside_match_body = 0,
		.inside_unsafe = 0,
		.inside_sum_type = 0,
		.inside_asm_template = 0,
		.inside_asm = 0,
		.inside_defer = 0,
		.inside_generic_params = 0,
		.inside_receiver_param = 0,
		.or_is_handled = 0,
		.builtin_mod = 0,
		.mod = (string){.str=(byteptr)"", .is_lit=1},
		.is_manualfree = 0,
		.has_globals = 0,
		.is_generated = 0,
		.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),
		.expr_mod = (string){.str=(byteptr)"", .is_lit=1},
		.scope = (v__ast__Scope*)memdup(&(v__ast__Scope){.objects = new_map(sizeof(string), sizeof(v__ast__ScopeObject), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.struct_fields = new_map(sizeof(string), sizeof(v__ast__ScopeStructField), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.parent = table->global_scope,.detached_from_parent = 0,.children = __new_array(0, 0, sizeof(v__ast__Scope*)),.start_pos = 0,.end_pos = 0,}, sizeof(v__ast__Scope)),
		.imports = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.ast_imports = __new_array(0, 0, sizeof(v__ast__Import)),
		.used_imports = __new_array(0, 0, sizeof(string)),
		.auto_imports = __new_array(0, 0, sizeof(string)),
		.imported_symbols = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.is_amp = 0,
		.returns = 0,
		.is_stmt_ident = 0,
		.expecting_type = 0,
		.errors = __new_array_with_default(0, 0, sizeof(v__errors__Error), 0),
		.warnings = __new_array_with_default(0, 0, sizeof(v__errors__Warning), 0),
		.notices = __new_array(0, 0, sizeof(v__errors__Notice)),
		.vet_errors = __new_array(0, 0, sizeof(v__vet__Error)),
		.cur_fn_name = (string){.str=(byteptr)"", .is_lit=1},
		.label_names = __new_array(0, 0, sizeof(string)),
		.name_error = 0,
		.n_asm = 0,
		.global_labels = __new_array(0, 0, sizeof(string)),
		.comptime_if_cond = 0,
		.defer_vars = __new_array(0, 0, sizeof(v__ast__Ident)),
		.should_abort = 0,
		.codegen_text = (string){.str=(byteptr)"", .is_lit=1},
	};
	v__parser__Parser_set_path(&p, path);
	v__ast__File* res = v__parser__Parser_parse(&p);
	v__parser__Parser_free_scanner(&p);
	v__ast__File* _t1 = res;
	return _t1;
}

multi_return_ref_v__ast__File_Array_v__vet__Error v__parser__parse_vet_file(string path, v__ast__Table* table_, v__pref__Preferences* pref) {
	v__ast__Scope* global_scope = (v__ast__Scope*)memdup(&(v__ast__Scope){.objects = new_map(sizeof(string), sizeof(v__ast__ScopeObject), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.struct_fields = new_map(sizeof(string), sizeof(v__ast__ScopeStructField), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.parent = 0,.detached_from_parent = 0,.children = __new_array(0, 0, sizeof(v__ast__Scope*)),.start_pos = 0,.end_pos = 0,}, sizeof(v__ast__Scope));
	v__parser__Parser p = (v__parser__Parser){
		.pref = pref,
		.file_base = (string){.str=(byteptr)"", .is_lit=1},
		.file_name = (string){.str=(byteptr)"", .is_lit=1},
		.file_name_dir = (string){.str=(byteptr)"", .is_lit=1},
		.unique_prefix = (string){.str=(byteptr)"", .is_lit=1},
		.file_backend_mode = 0,
		.scanner = v__scanner__new_scanner_file(path, v__scanner__CommentsMode__parse_comments, pref),
		.comments_mode = v__scanner__CommentsMode__parse_comments,
		.tok = (v__token__Token){.lit = (string){.str=(byteptr)"", .is_lit=1},.line_nr = 0,.col = 0,.pos = 0,.len = 0,.tidx = 0,},
		.prev_tok = (v__token__Token){.lit = (string){.str=(byteptr)"", .is_lit=1},.line_nr = 0,.col = 0,.pos = 0,.len = 0,.tidx = 0,},
		.peek_tok = (v__token__Token){.lit = (string){.str=(byteptr)"", .is_lit=1},.line_nr = 0,.col = 0,.pos = 0,.len = 0,.tidx = 0,},
		.table = table_,
		.language = 0,
		.fn_language = 0,
		.expr_level = 0,
		.inside_vlib_file = 0,
		.inside_test_file = 0,
		.inside_if = 0,
		.inside_if_expr = 0,
		.inside_ct_if_expr = 0,
		.inside_or_expr = 0,
		.inside_for = 0,
		.inside_fn = 0,
		.inside_unsafe_fn = 0,
		.inside_str_interp = 0,
		.inside_array_lit = 0,
		.inside_in_array = 0,
		.inside_match = 0,
		.inside_select = 0,
		.inside_match_case = 0,
		.inside_match_body = 0,
		.inside_unsafe = 0,
		.inside_sum_type = 0,
		.inside_asm_template = 0,
		.inside_asm = 0,
		.inside_defer = 0,
		.inside_generic_params = 0,
		.inside_receiver_param = 0,
		.or_is_handled = 0,
		.builtin_mod = 0,
		.mod = (string){.str=(byteptr)"", .is_lit=1},
		.is_manualfree = 0,
		.has_globals = 0,
		.is_generated = 0,
		.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),
		.expr_mod = (string){.str=(byteptr)"", .is_lit=1},
		.scope = (v__ast__Scope*)memdup(&(v__ast__Scope){.objects = new_map(sizeof(string), sizeof(v__ast__ScopeObject), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.struct_fields = new_map(sizeof(string), sizeof(v__ast__ScopeStructField), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.parent = global_scope,.detached_from_parent = 0,.children = __new_array(0, 0, sizeof(v__ast__Scope*)),.start_pos = 0,.end_pos = 0,}, sizeof(v__ast__Scope)),
		.imports = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.ast_imports = __new_array(0, 0, sizeof(v__ast__Import)),
		.used_imports = __new_array(0, 0, sizeof(string)),
		.auto_imports = __new_array(0, 0, sizeof(string)),
		.imported_symbols = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.is_amp = 0,
		.returns = 0,
		.is_stmt_ident = 0,
		.expecting_type = 0,
		.errors = __new_array_with_default(0, 0, sizeof(v__errors__Error), 0),
		.warnings = __new_array_with_default(0, 0, sizeof(v__errors__Warning), 0),
		.notices = __new_array(0, 0, sizeof(v__errors__Notice)),
		.vet_errors = __new_array(0, 0, sizeof(v__vet__Error)),
		.cur_fn_name = (string){.str=(byteptr)"", .is_lit=1},
		.label_names = __new_array(0, 0, sizeof(string)),
		.name_error = 0,
		.n_asm = 0,
		.global_labels = __new_array(0, 0, sizeof(string)),
		.comptime_if_cond = 0,
		.defer_vars = __new_array(0, 0, sizeof(v__ast__Ident)),
		.should_abort = 0,
		.codegen_text = (string){.str=(byteptr)"", .is_lit=1},
	};
	v__parser__Parser_set_path(&p, path);
	if (string_contains_any_substr(p.scanner->text, new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT("\n  "), _SLIT(" \n")})))) {
		Option_Array_string _t1 = os__read_lines(path);
		if (_t1.state != 0) { /*or block*/ 
			IError err = _t1.err;
			*(Array_string*) _t1.data = __new_array_with_default(0, 0, sizeof(string), 0);
		}
		
 		Array_string source_lines =  (*(Array_string*)_t1.data);
		for (int lnumber = 0; lnumber < source_lines.len; ++lnumber) {
			string line = ((string*)source_lines.data)[lnumber];
			if (string_starts_with(line, _SLIT("  "))) {
				v__parser__Parser_vet_error(&p, _SLIT("Looks like you are using spaces for indentation."), lnumber, v__vet__FixKind__vfmt, v__vet__ErrorType__space_indent);
			}
			if (string_ends_with(line, _SLIT(" "))) {
				v__parser__Parser_vet_error(&p, _SLIT("Looks like you have trailing whitespace."), lnumber, v__vet__FixKind__unknown, v__vet__ErrorType__trailing_space);
			}
		}
	}
	_PUSH_MANY(&p.vet_errors, (p.scanner->vet_errors), _t2, Array_v__vet__Error);
	v__ast__File* file = v__parser__Parser_parse(&p);
	v__parser__Parser_free_scanner(&p);
	return (multi_return_ref_v__ast__File_Array_v__vet__Error){.arg0=file, .arg1=p.vet_errors};
}

v__ast__File* v__parser__Parser_parse(v__parser__Parser* p) {
bool v__parser__Parser_parse_defer_0 = false;
	v__util__timing_start(_SLIT("PARSE"));
	v__parser__Parser_parse_defer_0 = true;
	v__parser__Parser_init_parse_fns(p);
	v__parser__Parser_read_first_token(p);
	Array_v__ast__Stmt stmts = __new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
	for (;;) {
		if (!(p->tok.kind == v__token__Kind__comment)) break;
		array_push((array*)&stmts, _MOV((v__ast__Stmt[]){ v__ast__ExprStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__ExprStmt, (v__parser__Parser_comment_stmt(p)))) }));
	}
	v__ast__Module module_decl = v__parser__Parser_module_decl(p);
	if (module_decl.is_skipped) {
		array_insert(&stmts, 0, &(v__ast__Stmt[]){v__ast__Module_to_sumtype_v__ast__Stmt(&module_decl)});
	} else {
		array_push((array*)&stmts, _MOV((v__ast__Stmt[]){ v__ast__Module_to_sumtype_v__ast__Stmt(&module_decl) }));
	}
	for (;;) {
		if (p->tok.kind == v__token__Kind__key_import) {
			array_push((array*)&stmts, _MOV((v__ast__Stmt[]){ v__ast__Import_to_sumtype_v__ast__Stmt(ADDR(v__ast__Import, (v__parser__Parser_import_stmt(p)))) }));
			continue;
		}
		if (p->tok.kind == v__token__Kind__comment) {
			array_push((array*)&stmts, _MOV((v__ast__Stmt[]){ v__ast__ExprStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__ExprStmt, (v__parser__Parser_comment_stmt(p)))) }));
			continue;
		}
		break;
	}
	for (;;) {
		if (p->tok.kind == v__token__Kind__eof) {
			v__parser__Parser_check_unused_imports(p);
			break;
		}
		v__ast__Stmt stmt = v__parser__Parser_top_stmt(p);
		if (!((stmt)._typ == 339 /* v.ast.ExprStmt */ && ((/* as */ *(v__ast__ExprStmt*)__as_cast((stmt)._v__ast__ExprStmt,(stmt)._typ, 339) /*expected idx: 339, name: v.ast.ExprStmt */ ).expr)._typ == 290 /* v.ast.Comment */)) {
			p->attrs = __new_array_with_default(0, 0, sizeof(v__ast__Attr), 0);
		}
		array_push((array*)&stmts, _MOV((v__ast__Stmt[]){ stmt }));
		if (p->should_abort) {
			break;
		}
	}
	p->scope->end_pos = p->tok.pos;
	Array_v__errors__Error errors = p->errors;
	Array_v__errors__Warning warnings = p->warnings;
	Array_v__errors__Notice notices = p->notices;
	if (p->pref->check_only) {
		_PUSH_MANY(&errors, (p->scanner->errors), _t6, Array_v__errors__Error);
		_PUSH_MANY(&warnings, (p->scanner->warnings), _t7, Array_v__errors__Warning);
		_PUSH_MANY(&notices, (p->scanner->notices), _t8, Array_v__errors__Notice);
	}
	if (p->codegen_text.len > 0 && !p->pref->is_fmt) {
		string ptext = string__plus(string__plus(_SLIT("module "), string_all_after_last(p->mod, _SLIT("."))), p->codegen_text);
		v__ast__File* codegen_file = v__parser__parse_text(ptext, p->file_name, p->table, p->comments_mode, p->pref);
		_PUSH_MANY(&stmts, (codegen_file->stmts), _t9, Array_v__ast__Stmt);
	}
	v__ast__File* _t10 = (v__ast__File*)memdup(&(v__ast__File){.nr_lines = p->scanner->line_nr,
		.nr_bytes = p->scanner->text.len,
		.mod = module_decl,
		.global_scope = p->table->global_scope,
		.is_test = p->inside_test_file,
		.is_generated = p->is_generated,
		.path = p->file_name,
		.path_base = p->file_base,
		.scope = p->scope,
		.stmts = stmts,
		.imports = p->ast_imports,
		.auto_imports = p->auto_imports,
		.embedded_files = __new_array(0, 0, sizeof(v__ast__EmbeddedFile)),
		.imported_symbols = p->imported_symbols,
		.errors = errors,
		.warnings = warnings,
		.notices = notices,
		.generic_fns = __new_array(0, 0, sizeof(v__ast__FnDecl*)),
		.global_labels = p->global_labels,
	}, sizeof(v__ast__File));
	// Defer begin
	if (v__parser__Parser_parse_defer_0) {
		v__util__timing_measure_cumulative(_SLIT("PARSE"));
	}
	// Defer end
	return _t10;
}

Array_v__ast__File_ptr v__parser__parse_files(Array_string paths, v__ast__Table* table, v__pref__Preferences* pref) {
	v__util__Timers* timers = v__util__new_timers((v__util__TimerParams){.should_print = false,.label =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("parse_files: "), 0xfe10, {.d_s = Array_string_str(paths)}}, {_SLIT0, 0, { .d_c = 0 }}})),});
	Array_v__ast__File_ptr files = __new_array_with_default(0, paths.len, sizeof(v__ast__File*), 0);
	for (int _t1 = 0; _t1 < paths.len; ++_t1) {
		string path = ((string*)paths.data)[_t1];
		v__util__Timers_start(timers,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("parse_file "), 0xfe10, {.d_s = path}}, {_SLIT0, 0, { .d_c = 0 }}})));
		array_push((array*)&files, _MOV((v__ast__File*[]){ v__parser__parse_file(path, table, v__scanner__CommentsMode__skip_comments, pref) }));
		v__util__Timers_show(timers,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("parse_file "), 0xfe10, {.d_s = path}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
	Array_v__ast__File_ptr _t3 = files;
	return _t3;
}

void v__parser__Parser_codegen(v__parser__Parser* p, string code) {
	p->codegen_text = /*f*/string__plus(p->codegen_text, string__plus(_SLIT("\n"), code));
}

void v__parser__Parser_init_parse_fns(v__parser__Parser* p) {
}

void v__parser__Parser_read_first_token(v__parser__Parser* p) {
	v__parser__Parser_next(p);
	v__parser__Parser_next(p);
}

// Attr: [inline]
inline v__token__Token v__parser__Parser_peek_token(v__parser__Parser* p, int n) {
	v__token__Token _t1 = v__scanner__Scanner_peek_token(p->scanner, n - 2);
	return _t1;
}

void v__parser__Parser_open_scope(v__parser__Parser* p) {
	p->scope = (v__ast__Scope*)memdup(&(v__ast__Scope){.objects = new_map(sizeof(string), sizeof(v__ast__ScopeObject), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.struct_fields = new_map(sizeof(string), sizeof(v__ast__ScopeStructField), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.parent = p->scope,.detached_from_parent = 0,.children = __new_array(0, 0, sizeof(v__ast__Scope*)),.start_pos = p->tok.pos,.end_pos = 0,}, sizeof(v__ast__Scope));
}

void v__parser__Parser_close_scope(v__parser__Parser* p) {
	p->scope->end_pos = p->prev_tok.pos;
	array_push((array*)&p->scope->parent->children, _MOV((v__ast__Scope*[]){ p->scope }));
	p->scope = p->scope->parent;
}

Array_v__ast__Stmt v__parser__Parser_parse_block(v__parser__Parser* p) {
	v__parser__Parser_open_scope(p);
	Array_v__ast__Stmt stmts = v__parser__Parser_parse_block_no_scope(p, false);
	v__parser__Parser_close_scope(p);
	Array_v__ast__Stmt _t1 = stmts;
	return _t1;
}

Array_v__ast__Stmt v__parser__Parser_parse_block_no_scope(v__parser__Parser* p, bool is_top_level) {
	v__parser__Parser_check(p, v__token__Kind__lcbr);
	Array_v__ast__Stmt stmts = __new_array_with_default(0, 20, sizeof(v__ast__Stmt), 0);
	if (p->tok.kind != v__token__Kind__rcbr) {
		int count = 0;
		for (;;) {
			if (!(!(p->tok.kind == v__token__Kind__eof || p->tok.kind == v__token__Kind__rcbr))) break;
			array_push((array*)&stmts, _MOV((v__ast__Stmt[]){ v__parser__Parser_stmt(p, is_top_level) }));
			count++;
			if (count % 100000 == 0) {
				eprintln( str_intp(3, _MOV((StrIntpData[]){{_SLIT("parsed "), 0xfe07, {.d_i32 = count}}, {_SLIT(" statements so far from fn "), 0xfe10, {.d_s = p->cur_fn_name}}, {_SLIT(" ..."), 0, { .d_c = 0 }}})));
			}
			if (count > 1000000) {
				v__parser__Parser_error_with_pos(p,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("parsed over "), 0xfe07, {.d_i32 = count}}, {_SLIT(" statements from fn "), 0xfe10, {.d_s = p->cur_fn_name}}, {_SLIT(", the parser is probably stuck"), 0, { .d_c = 0 }}})), v__token__Token_position(&p->tok));
				Array_v__ast__Stmt _t2 = __new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
				return _t2;
			}
		}
	}
	if (is_top_level) {
		v__parser__Parser_top_level_statement_end(p);
	}
	v__parser__Parser_check(p, v__token__Kind__rcbr);
	Array_v__ast__Stmt _t3 = stmts;
	return _t3;
}

VV_LOCAL_SYMBOL void v__parser__Parser_next(v__parser__Parser* p) {
	p->prev_tok = p->tok;
	p->tok = p->peek_tok;
	p->peek_tok = v__scanner__Scanner_scan(p->scanner);
}

VV_LOCAL_SYMBOL void v__parser__Parser_check(v__parser__Parser* p, v__token__Kind expected) {
	p->name_error = false;
	if (_likely_(p->tok.kind == expected)) {
		v__parser__Parser_next(p);
	} else {
		if (expected == v__token__Kind__name) {
			p->name_error = true;
		}
		string s = v__token__Kind_str(expected);
		if (v__token__is_key(s) || (s.len > 0 && !byte_is_letter(string_at(s, 0)))) {
			s =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = s}}, {_SLIT("`"), 0, { .d_c = 0 }}}));
		}
		v__parser__Parser_error(p,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("unexpected "), 0xfe10, {.d_s = v__token__Token_str(p->tok)}}, {_SLIT(", expecting "), 0xfe10, {.d_s = s}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
}

VV_LOCAL_SYMBOL string v__parser__Parser_check_js_name(v__parser__Parser* p) {
	string name = _SLIT("");
	for (;;) {
		if (!(p->peek_tok.kind == v__token__Kind__dot)) break;
		name = /*f*/string__plus(name,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = p->tok.lit}}, {_SLIT("."), 0, { .d_c = 0 }}})));
		v__parser__Parser_next(p);
		v__parser__Parser_next(p);
	}
	name = /*f*/string__plus(name, p->tok.lit);
	v__parser__Parser_next(p);
	string _t1 = name;
	return _t1;
}

VV_LOCAL_SYMBOL string v__parser__Parser_check_name(v__parser__Parser* p) {
	string name = p->tok.lit;
	if (p->peek_tok.kind == v__token__Kind__dot && _IN_MAP(ADDR(string, name), ADDR(map, p->imports))) {
		v__parser__Parser_register_used_import(p, name);
	}
	v__parser__Parser_check(p, v__token__Kind__name);
	string _t1 = name;
	return _t1;
}

v__ast__Stmt v__parser__Parser_top_stmt(v__parser__Parser* p) {
	;
	for (;;) {

		if (p->tok.kind == (v__token__Kind__key_pub)) {

			if (p->peek_tok.kind == (v__token__Kind__key_const)) {
				v__ast__Stmt _t1 = v__ast__ConstDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__ConstDecl, (v__parser__Parser_const_decl(p))));
				return _t1;
			}
			else if (p->peek_tok.kind == (v__token__Kind__key_fn)) {
				v__ast__Stmt _t2 = v__ast__FnDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__FnDecl, (v__parser__Parser_fn_decl(p))));
				return _t2;
			}
			else if (p->peek_tok.kind == (v__token__Kind__key_struct) || p->peek_tok.kind == (v__token__Kind__key_union)) {
				v__ast__Stmt _t3 = v__ast__StructDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__StructDecl, (v__parser__Parser_struct_decl(p))));
				return _t3;
			}
			else if (p->peek_tok.kind == (v__token__Kind__key_interface)) {
				v__ast__Stmt _t4 = v__ast__InterfaceDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__InterfaceDecl, (v__parser__Parser_interface_decl(p))));
				return _t4;
			}
			else if (p->peek_tok.kind == (v__token__Kind__key_enum)) {
				v__ast__Stmt _t5 = v__ast__EnumDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__EnumDecl, (v__parser__Parser_enum_decl(p))));
				return _t5;
			}
			else if (p->peek_tok.kind == (v__token__Kind__key_type)) {
				v__ast__Stmt _t6 = v__ast__TypeDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__TypeDecl, (v__parser__Parser_type_decl(p))));
				return _t6;
			}
			else {
				v__ast__Stmt _t7 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error(p, _SLIT("wrong pub keyword usage")))));
				return _t7;
			};
		}
		else if (p->tok.kind == (v__token__Kind__lsbr)) {
			v__parser__Parser_attributes(p);
			continue;
		}
		else if (p->tok.kind == (v__token__Kind__key_asm)) {
			v__ast__Stmt _t8 = v__ast__AsmStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__AsmStmt, (v__parser__Parser_asm_stmt(p, true))));
			return _t8;
		}
		else if (p->tok.kind == (v__token__Kind__key_interface)) {
			v__ast__Stmt _t9 = v__ast__InterfaceDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__InterfaceDecl, (v__parser__Parser_interface_decl(p))));
			return _t9;
		}
		else if (p->tok.kind == (v__token__Kind__key_import)) {
			v__parser__Parser_error_with_pos(p, _SLIT("`import x` can only be declared at the beginning of the file"), v__token__Token_position(&p->tok));
			v__ast__Stmt _t10 = v__ast__Import_to_sumtype_v__ast__Stmt(ADDR(v__ast__Import, (v__parser__Parser_import_stmt(p))));
			return _t10;
		}
		else if (p->tok.kind == (v__token__Kind__key_global)) {
			v__ast__Stmt _t11 = v__ast__GlobalDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__GlobalDecl, (v__parser__Parser_global_decl(p))));
			return _t11;
		}
		else if (p->tok.kind == (v__token__Kind__key_const)) {
			v__ast__Stmt _t12 = v__ast__ConstDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__ConstDecl, (v__parser__Parser_const_decl(p))));
			return _t12;
		}
		else if (p->tok.kind == (v__token__Kind__key_fn)) {
			v__ast__Stmt _t13 = v__ast__FnDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__FnDecl, (v__parser__Parser_fn_decl(p))));
			return _t13;
		}
		else if (p->tok.kind == (v__token__Kind__key_struct)) {
			v__ast__Stmt _t14 = v__ast__StructDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__StructDecl, (v__parser__Parser_struct_decl(p))));
			return _t14;
		}
		else if (p->tok.kind == (v__token__Kind__dollar)) {
			v__ast__IfExpr if_expr = v__parser__Parser_if_expr(p, true);
			v__ast__Stmt _t15 = v__ast__ExprStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__ExprStmt, ((v__ast__ExprStmt){.expr = v__ast__IfExpr_to_sumtype_v__ast__Expr(&if_expr),.pos = if_expr.pos,.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.is_expr = 0,.typ = 0,})));
			return _t15;
		}
		else if (p->tok.kind == (v__token__Kind__hash)) {
			v__ast__Stmt _t16 = v__ast__HashStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__HashStmt, (v__parser__Parser_hash(p))));
			return _t16;
		}
		else if (p->tok.kind == (v__token__Kind__key_type)) {
			v__ast__Stmt _t17 = v__ast__TypeDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__TypeDecl, (v__parser__Parser_type_decl(p))));
			return _t17;
		}
		else if (p->tok.kind == (v__token__Kind__key_enum)) {
			v__ast__Stmt _t18 = v__ast__EnumDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__EnumDecl, (v__parser__Parser_enum_decl(p))));
			return _t18;
		}
		else if (p->tok.kind == (v__token__Kind__key_union)) {
			v__ast__Stmt _t19 = v__ast__StructDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__StructDecl, (v__parser__Parser_struct_decl(p))));
			return _t19;
		}
		else if (p->tok.kind == (v__token__Kind__comment)) {
			v__ast__Stmt _t20 = v__ast__ExprStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__ExprStmt, (v__parser__Parser_comment_stmt(p))));
			return _t20;
		}
		else {
			p->inside_fn = true;
			if (p->pref->is_script && !p->pref->is_test) {
				v__parser__Parser_open_scope(p);
				Array_v__ast__Stmt stmts = __new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
				for (;;) {
					if (!(p->tok.kind != v__token__Kind__eof)) break;
					array_push((array*)&stmts, _MOV((v__ast__Stmt[]){ v__parser__Parser_stmt(p, false) }));
				}
				v__parser__Parser_close_scope(p);
				v__ast__Stmt _t22 = v__ast__FnDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__FnDecl, ((v__ast__FnDecl){
					.name = _SLIT("main.main"),
					.mod = _SLIT("main"),
					.is_deprecated = 0,
					.is_pub = 0,
					.is_variadic = 0,
					.is_anon = 0,
					.is_noreturn = 0,
					.is_manualfree = 0,
					.is_main = true,
					.is_test = 0,
					.is_conditional = 0,
					.is_exported = 0,
					.is_keep_alive = 0,
					.is_unsafe = 0,
					.is_markused = 0,
					.receiver = (v__ast__StructField){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.has_default_expr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_pub = 0,.default_val = (string){.str=(byteptr)"", .is_lit=1},.is_mut = 0,.is_global = 0,.is_volatile = 0,.default_expr_typ = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,},
					.receiver_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},
					.is_method = 0,
					.method_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},
					.method_idx = 0,
					.rec_mut = 0,
					.rec_share = 0,
					.language = 0,
					.file_mode = 0,
					.no_body = 0,
					.is_builtin = 0,
					.body_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},
					.file = p->file_name,
					.generic_names = __new_array(0, 0, sizeof(string)),
					.is_direct_arr = 0,
					.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),
					.ctdefine_idx = -1,
					.params = __new_array(0, 0, sizeof(v__ast__Param)),
					.stmts = stmts,
					.defer_stmts = __new_array(0, 0, sizeof(v__ast__DeferStmt)),
					.return_type = _const_v__ast__void_type,
					.return_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},
					.has_return = 0,
					.should_be_skipped = 0,
					.ninstances = 0,
					.has_await = 0,
					.comments = __new_array(0, 0, sizeof(v__ast__Comment)),
					.next_comments = __new_array(0, 0, sizeof(v__ast__Comment)),
					.source_file = 0,
					.scope = p->scope,
					.label_names = p->label_names,
					.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},
				})));
				return _t22;
			} else if (p->pref->is_fmt) {
				v__ast__Stmt _t23 = v__parser__Parser_stmt(p, false);
				return _t23;
			} else {
				v__ast__Stmt _t24 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error(p, string__plus(_SLIT("bad top level statement "), v__token__Token_str(p->tok))))));
				return _t24;
			}
		};
		if (p->should_abort) {
			break;
		}
	}
	v__ast__Stmt _t25 = v__ast__empty_stmt();
	return _t25;
}

v__ast__Comment v__parser__Parser_check_comment(v__parser__Parser* p) {
	if (p->tok.kind == v__token__Kind__comment) {
		v__ast__Comment _t1 = v__parser__Parser_comment(p);
		return _t1;
	}
	v__ast__Comment _t2 = (v__ast__Comment){.text = (string){.str=(byteptr)"", .is_lit=1},.is_multi = 0,.is_inline = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},};
	return _t2;
}

v__ast__Comment v__parser__Parser_comment(v__parser__Parser* p) {
	v__token__Position pos = v__token__Token_position(&p->tok);
	string text = p->tok.lit;
	int num_newlines = string_count(text, _SLIT("\n"));
	bool is_multi = num_newlines > 0;
	bool is_inline = text.len + 4 == p->tok.len;
	pos.last_line = pos.line_nr + num_newlines;
	v__parser__Parser_next(p);
	if (p->vet_errors.len > 0 && is_multi) {
		Array_v__vet__Error _t1 = __new_array(0, 0, sizeof(v__vet__Error));
		Array_v__vet__Error _t1_orig = p->vet_errors;
		int _t1_len = _t1_orig.len;
		_t1 = __new_array(0, _t1_len, sizeof(v__vet__Error));

		for (int _t2 = 0; _t2 < _t1_len; ++_t2) {
			v__vet__Error it = ((v__vet__Error*) _t1_orig.data)[_t2];
			if (it.typ != v__vet__ErrorType__space_indent || it.pos.line_nr - 1 > pos.last_line || it.pos.line_nr - 1 <= pos.line_nr) {
				array_push((array*)&_t1, &it);
			}
		}
		p->vet_errors =_t1;
	}
	v__ast__Comment _t3 = (v__ast__Comment){.text = text,.is_multi = is_multi,.is_inline = is_inline,.pos = pos,};
	return _t3;
}

v__ast__ExprStmt v__parser__Parser_comment_stmt(v__parser__Parser* p) {
	v__ast__Comment comment = v__parser__Parser_comment(p);
	v__ast__ExprStmt _t1 = (v__ast__ExprStmt){.expr = v__ast__Comment_to_sumtype_v__ast__Expr(&comment),.pos = comment.pos,.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.is_expr = 0,.typ = 0,};
	return _t1;
}

Array_v__ast__Comment v__parser__Parser_eat_comments(v__parser__Parser* p, v__parser__EatCommentsConfig cfg) {
	int line = p->prev_tok.line_nr;
	Array_v__ast__Comment comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	for (;;) {
		if (p->tok.kind != v__token__Kind__comment || (cfg.same_line && p->tok.line_nr > line) || (cfg.follow_up && (p->tok.line_nr > line + 1 || string_contains(p->tok.lit, _SLIT("\n"))))) {
			break;
		}
		array_push((array*)&comments, _MOV((v__ast__Comment[]){ v__parser__Parser_comment(p) }));
		if (cfg.follow_up) {
			line = p->prev_tok.line_nr;
		}
	}
	Array_v__ast__Comment _t2 = comments;
	return _t2;
}

v__ast__Stmt v__parser__Parser_stmt(v__parser__Parser* p, bool is_top_level) {
	;
	p->is_stmt_ident = p->tok.kind == v__token__Kind__name;
	switch (p->tok.kind) {
		case v__token__Kind__lcbr: 
			{
				v__token__Position pos = v__token__Token_position(&p->tok);
				Array_v__ast__Stmt stmts = v__parser__Parser_parse_block(p);
				pos.last_line = p->prev_tok.line_nr;
				v__ast__Stmt _t1 = v__ast__Block_to_sumtype_v__ast__Stmt(ADDR(v__ast__Block, ((v__ast__Block){.stmts = stmts,.is_unsafe = 0,.pos = pos,})));
				return _t1;
			} break;
		case v__token__Kind__key_assert: 
			{
				v__parser__Parser_next(p);
				v__token__Position pos = v__token__Token_position(&p->tok);
				v__ast__Expr expr = v__parser__Parser_expr(p, 0);
				v__token__Position_update_last_line(&pos, p->prev_tok.line_nr);
				v__ast__Stmt _t2 = v__ast__AssertStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__AssertStmt, ((v__ast__AssertStmt){.pos = v__token__Position_extend(pos, v__token__Token_position(&p->tok)),.expr = expr,.is_used = p->inside_test_file || !p->pref->is_prod,})));
				return _t2;
			} break;
		case v__token__Kind__key_for: 
			{
				v__ast__Stmt _t3 = v__parser__Parser_for_stmt(p);
				return _t3;
			} break;
		case v__token__Kind__name: 
			{
				if (string__eq(p->tok.lit, _SLIT("sql")) && p->peek_tok.kind == v__token__Kind__name) {
					v__ast__Stmt _t4 = v__ast__SqlStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__SqlStmt, (v__parser__Parser_sql_stmt(p))));
					return _t4;
				}
				if (p->peek_tok.kind == v__token__Kind__colon) {
					v__token__Position spos = v__token__Token_position(&p->tok);
					string name = v__parser__Parser_check_name(p);
					if (Array_string_contains(p->label_names, name)) {
						v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("duplicate label `"), 0xfe10, {.d_s = name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), spos);
					}
					array_push((array*)&p->label_names, _MOV((string[]){ string_clone(name) }));
					v__parser__Parser_next(p);
					if (p->tok.kind == v__token__Kind__key_for) {
						v__token__Position for_pos = v__token__Token_position(&p->tok);
						v__ast__Stmt stmt = v__parser__Parser_stmt(p, is_top_level);
						if (stmt._typ == 342 /* v.ast.ForStmt */) {
							(*stmt._v__ast__ForStmt).label = name;
							v__ast__Stmt _t6 = stmt;
							return _t6;
						}
						else if (stmt._typ == 341 /* v.ast.ForInStmt */) {
							(*stmt._v__ast__ForInStmt).label = name;
							v__ast__Stmt _t7 = stmt;
							return _t7;
						}
						else if (stmt._typ == 340 /* v.ast.ForCStmt */) {
							(*stmt._v__ast__ForCStmt).label = name;
							v__ast__Stmt _t8 = stmt;
							return _t8;
						}
						
						else {
							v__parser__Parser_error_with_pos(p, _SLIT("unknown kind of For statement"), for_pos);
						}
						;
					}
					v__ast__Stmt _t9 = v__ast__GotoLabel_to_sumtype_v__ast__Stmt(ADDR(v__ast__GotoLabel, ((v__ast__GotoLabel){.name = name,.pos = v__token__Position_extend(spos, v__token__Token_position(&p->tok)),})));
					return _t9;
				} else if (p->peek_tok.kind == v__token__Kind__name) {
					v__ast__Stmt _t10 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unexpected name `"), 0xfe10, {.d_s = p->tok.lit}}, {_SLIT("`"), 0, { .d_c = 0 }}})), v__token__Token_position(&p->tok)))));
					return _t10;
				} else if (!p->inside_if_expr && !p->inside_match_body && !p->inside_or_expr && (p->peek_tok.kind == v__token__Kind__rcbr || p->peek_tok.kind == v__token__Kind__eof) && !v__parser__Parser_mark_var_as_used(p, p->tok.lit)) {
					v__ast__Stmt _t11 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = p->tok.lit}}, {_SLIT("` evaluated but not used"), 0, { .d_c = 0 }}})), v__token__Token_position(&p->tok)))));
					return _t11;
				}
				v__ast__Stmt _t12 = v__parser__Parser_parse_multi_expr(p, is_top_level);
				return _t12;
			} break;
		case v__token__Kind__comment: 
			{
				v__ast__Stmt _t13 = v__ast__ExprStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__ExprStmt, (v__parser__Parser_comment_stmt(p))));
				return _t13;
			} break;
		case v__token__Kind__key_return: 
			{
				if (p->inside_defer) {
					v__ast__Stmt _t14 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _SLIT("`return` not allowed inside `defer` block"), v__token__Token_position(&p->tok)))));
					return _t14;
				} else {
					v__ast__Stmt _t15 = v__ast__Return_to_sumtype_v__ast__Stmt(ADDR(v__ast__Return, (v__parser__Parser_return_stmt(p))));
					return _t15;
				}
			} break;
		case v__token__Kind__dollar: 
			{

				if (p->peek_tok.kind == (v__token__Kind__key_if)) {
					v__token__Position pos = v__token__Token_position(&p->tok);
					v__ast__IfExpr expr = v__parser__Parser_if_expr(p, true);
					v__token__Position_update_last_line(&pos, p->prev_tok.line_nr);
					v__ast__Stmt _t16 = v__ast__ExprStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__ExprStmt, ((v__ast__ExprStmt){.expr = v__ast__IfExpr_to_sumtype_v__ast__Expr(&expr),.pos = pos,.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.is_expr = 0,.typ = 0,})));
					return _t16;
				}
				else if (p->peek_tok.kind == (v__token__Kind__key_for)) {
					v__ast__Stmt _t17 = v__ast__ComptimeFor_to_sumtype_v__ast__Stmt(ADDR(v__ast__ComptimeFor, (v__parser__Parser_comptime_for(p))));
					return _t17;
				}
				else if (p->peek_tok.kind == (v__token__Kind__name)) {
					v__token__Position pos = v__token__Token_position(&p->tok);
					v__ast__ComptimeCall *expr = HEAP(v__ast__ComptimeCall, (v__parser__Parser_comptime_call(p)));
					v__token__Position_update_last_line(&pos, p->prev_tok.line_nr);
					v__ast__Stmt _t18 = v__ast__ExprStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__ExprStmt, ((v__ast__ExprStmt){.expr = v__ast__ComptimeCall_to_sumtype_v__ast__Expr(&(*(expr))),.pos = pos,.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.is_expr = 0,.typ = 0,})));
					return _t18;
				}
				else {
					v__ast__Stmt _t19 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _SLIT("unexpected $"), v__token__Token_position(&p->tok)))));
					return _t19;
				};
			} break;
		case v__token__Kind__key_continue: 
		case v__token__Kind__key_break: 
			{
				v__token__Token tok = p->tok;
				int line = p->tok.line_nr;
				v__parser__Parser_next(p);
				string label = _SLIT("");
				if (p->tok.line_nr == line && p->tok.kind == v__token__Kind__name) {
					label = v__parser__Parser_check_name(p);
				}
				v__ast__Stmt _t20 = v__ast__BranchStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__BranchStmt, ((v__ast__BranchStmt){.kind = tok.kind,.label = label,.pos = v__token__Token_position(&tok),})));
				return _t20;
			} break;
		case v__token__Kind__key_unsafe: 
			{
				v__ast__Stmt _t21 = v__parser__Parser_unsafe_stmt(p);
				return _t21;
			} break;
		case v__token__Kind__hash: 
			{
				v__ast__Stmt _t22 = v__ast__HashStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__HashStmt, (v__parser__Parser_hash(p))));
				return _t22;
			} break;
		case v__token__Kind__key_defer: 
			{
				if (p->inside_defer) {
					v__ast__Stmt _t23 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _SLIT("`defer` blocks cannot be nested"), v__token__Token_position(&p->tok)))));
					return _t23;
				} else {
					v__parser__Parser_next(p);
					v__token__Position spos = v__token__Token_position(&p->tok);
					p->inside_defer = true;
					p->defer_vars = __new_array_with_default(0, 0, sizeof(v__ast__Ident), 0);
					Array_v__ast__Stmt stmts = v__parser__Parser_parse_block(p);
					p->inside_defer = false;
					v__ast__Stmt _t24 = v__ast__DeferStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__DeferStmt, ((v__ast__DeferStmt){.stmts = stmts,.pos = v__token__Position_extend_with_last_line(spos, v__token__Token_position(&p->tok), p->prev_tok.line_nr),.defer_vars = array_clone_to_depth(&p->defer_vars, 0),.ifdef = (string){.str=(byteptr)"", .is_lit=1},.idx_in_fn = -1,})));
					return _t24;
				}
			} break;
		case v__token__Kind__key_go: 
			{
				v__ast__GoExpr go_expr = v__parser__Parser_go_expr(p);
				v__ast__Stmt _t25 = v__ast__ExprStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__ExprStmt, ((v__ast__ExprStmt){.expr = v__ast__GoExpr_to_sumtype_v__ast__Expr(&go_expr),.pos = go_expr.pos,.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.is_expr = 0,.typ = 0,})));
				return _t25;
			} break;
		case v__token__Kind__key_goto: 
			{
				v__parser__Parser_next(p);
				v__token__Position spos = v__token__Token_position(&p->tok);
				string name = v__parser__Parser_check_name(p);
				v__ast__Stmt _t26 = v__ast__GotoStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__GotoStmt, ((v__ast__GotoStmt){.name = name,.pos = spos,})));
				return _t26;
			} break;
		case v__token__Kind__key_const: 
			{
				v__ast__Stmt _t27 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _SLIT("const can only be defined at the top level (outside of functions)"), v__token__Token_position(&p->tok)))));
				return _t27;
			} break;
		case v__token__Kind__key_asm: 
			{
				v__ast__Stmt _t28 = v__ast__AsmStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__AsmStmt, (v__parser__Parser_asm_stmt(p, false))));
				return _t28;
			} break;
		case v__token__Kind__unknown:
		case v__token__Kind__eof:
		case v__token__Kind__number:
		case v__token__Kind__string:
		case v__token__Kind__str_inter:
		case v__token__Kind__chartoken:
		case v__token__Kind__plus:
		case v__token__Kind__minus:
		case v__token__Kind__mul:
		case v__token__Kind__div:
		case v__token__Kind__mod:
		case v__token__Kind__xor:
		case v__token__Kind__pipe:
		case v__token__Kind__inc:
		case v__token__Kind__dec:
		case v__token__Kind__and:
		case v__token__Kind__logical_or:
		case v__token__Kind__not:
		case v__token__Kind__bit_not:
		case v__token__Kind__question:
		case v__token__Kind__comma:
		case v__token__Kind__semicolon:
		case v__token__Kind__colon:
		case v__token__Kind__arrow:
		case v__token__Kind__amp:
		case v__token__Kind__at:
		case v__token__Kind__str_dollar:
		case v__token__Kind__left_shift:
		case v__token__Kind__right_shift:
		case v__token__Kind__unsigned_right_shift:
		case v__token__Kind__not_in:
		case v__token__Kind__not_is:
		case v__token__Kind__assign:
		case v__token__Kind__decl_assign:
		case v__token__Kind__plus_assign:
		case v__token__Kind__minus_assign:
		case v__token__Kind__div_assign:
		case v__token__Kind__mult_assign:
		case v__token__Kind__xor_assign:
		case v__token__Kind__mod_assign:
		case v__token__Kind__or_assign:
		case v__token__Kind__and_assign:
		case v__token__Kind__right_shift_assign:
		case v__token__Kind__left_shift_assign:
		case v__token__Kind__unsigned_right_shift_assign:
		case v__token__Kind__rcbr:
		case v__token__Kind__lpar:
		case v__token__Kind__rpar:
		case v__token__Kind__lsbr:
		case v__token__Kind__nilsbr:
		case v__token__Kind__rsbr:
		case v__token__Kind__eq:
		case v__token__Kind__ne:
		case v__token__Kind__gt:
		case v__token__Kind__lt:
		case v__token__Kind__ge:
		case v__token__Kind__le:
		case v__token__Kind__nl:
		case v__token__Kind__dot:
		case v__token__Kind__dotdot:
		case v__token__Kind__ellipsis:
		case v__token__Kind__keyword_beg:
		case v__token__Kind__key_as:
		case v__token__Kind__key_atomic:
		case v__token__Kind__key_else:
		case v__token__Kind__key_enum:
		case v__token__Kind__key_false:
		case v__token__Kind__key_fn:
		case v__token__Kind__key_global:
		case v__token__Kind__key_if:
		case v__token__Kind__key_import:
		case v__token__Kind__key_in:
		case v__token__Kind__key_interface:
		case v__token__Kind__key_is:
		case v__token__Kind__key_match:
		case v__token__Kind__key_module:
		case v__token__Kind__key_mut:
		case v__token__Kind__key_shared:
		case v__token__Kind__key_lock:
		case v__token__Kind__key_rlock:
		case v__token__Kind__key_none:
		case v__token__Kind__key_select:
		case v__token__Kind__key_sizeof:
		case v__token__Kind__key_isreftype:
		case v__token__Kind__key_likely:
		case v__token__Kind__key_unlikely:
		case v__token__Kind__key_offsetof:
		case v__token__Kind__key_struct:
		case v__token__Kind__key_true:
		case v__token__Kind__key_type:
		case v__token__Kind__key_typeof:
		case v__token__Kind__key_dump:
		case v__token__Kind__key_orelse:
		case v__token__Kind__key_union:
		case v__token__Kind__key_pub:
		case v__token__Kind__key_static:
		case v__token__Kind__key_volatile:
		case v__token__Kind__keyword_end:
		case v__token__Kind___end_:
		default:
			{
				v__ast__Stmt _t29 = v__parser__Parser_parse_multi_expr(p, is_top_level);
				return _t29;
			} break;
	}
	;
	return (v__ast__Stmt){0};
}

VV_LOCAL_SYMBOL v__ast__AsmStmt v__parser__Parser_asm_stmt(v__parser__Parser* p, bool is_top_level) {
bool v__parser__Parser_asm_stmt_defer_0 = false;
	p->inside_asm = true;
	p->inside_asm_template = true;
	v__parser__Parser_asm_stmt_defer_0 = true;
	p->n_asm = 0;
	if (is_top_level) {
		v__parser__Parser_top_level_statement_start(p);
	}
	v__ast__Scope* backup_scope = p->scope;
	v__token__Position pos = v__token__Token_position(&p->tok);
	v__parser__Parser_check(p, v__token__Kind__key_asm);
	Option_v__pref__Arch _t1 = v__pref__arch_from_string(p->tok.lit);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		*(v__pref__Arch*) _t1.data = v__pref__Arch___auto;
	}
	
 	v__pref__Arch arch =  (*(v__pref__Arch*)_t1.data);
	bool is_volatile = false;
	bool is_goto = false;
	if (p->tok.kind == v__token__Kind__key_volatile) {
		Option_v__pref__Arch _t2 = v__pref__arch_from_string(p->peek_tok.lit);
		if (_t2.state != 0) { /*or block*/ 
			IError err = _t2.err;
			*(v__pref__Arch*) _t2.data = v__pref__Arch___auto;
		}
		
 		arch =  (*(v__pref__Arch*)_t2.data);
		is_volatile = true;
		v__parser__Parser_next(p);
	} else if (p->tok.kind == v__token__Kind__key_goto) {
		Option_v__pref__Arch _t3 = v__pref__arch_from_string(p->peek_tok.lit);
		if (_t3.state != 0) { /*or block*/ 
			IError err = _t3.err;
			*(v__pref__Arch*) _t3.data = v__pref__Arch___auto;
		}
		
 		arch =  (*(v__pref__Arch*)_t3.data);
		is_goto = true;
		v__parser__Parser_next(p);
	}
	if (arch == v__pref__Arch___auto && !p->pref->is_fmt) {
		if ((p->tok.lit).len == 0) {
			v__parser__Parser_error(p, _SLIT("missing assembly architecture. Try i386, amd64 or arm64."));
		}
		v__parser__Parser_error(p, _SLIT("unknown assembly architecture"));
	}
	if (p->tok.kind != v__token__Kind__name) {
		v__parser__Parser_error(p, _SLIT("must specify assembly architecture"));
	} else {
		v__parser__Parser_next(p);
	}
	v__parser__Parser_check_for_impure_v(p, v__ast__pref_arch_to_table_language(arch), v__token__Token_position(&p->prev_tok));
	v__parser__Parser_check(p, v__token__Kind__lcbr);
	p->scope = (v__ast__Scope*)memdup(&(v__ast__Scope){.objects = v__ast__all_registers(p->table, arch),.struct_fields = new_map(sizeof(string), sizeof(v__ast__ScopeStructField), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.parent = 0,.detached_from_parent = true,.children = __new_array(0, 0, sizeof(v__ast__Scope*)),.start_pos = p->tok.pos,.end_pos = 0,}, sizeof(v__ast__Scope));
	Array_string local_labels = __new_array_with_default(0, 0, sizeof(string), 0);
	Array_v__ast__AsmTemplate templates = __new_array_with_default(0, 0, sizeof(v__ast__AsmTemplate), 0);
	for (;;) {
		if (!(!(p->tok.kind == v__token__Kind__semicolon || p->tok.kind == v__token__Kind__rcbr))) break;
		v__token__Position template_pos = v__token__Token_position(&p->tok);
		string name = _SLIT("");
		if (p->tok.kind == v__token__Kind__name && arch == v__pref__Arch__amd64 && (string__eq(p->tok.lit, _SLIT("rex")) || string__eq(p->tok.lit, _SLIT("vex")) || string__eq(p->tok.lit, _SLIT("xop")))) {
			name = /*f*/string__plus(name, p->tok.lit);
			v__parser__Parser_next(p);
			for (;;) {
				if (!(p->tok.kind == v__token__Kind__dot)) break;
				v__parser__Parser_next(p);
				name = /*f*/string__plus(name, string__plus(_SLIT("."), p->tok.lit));
				v__parser__Parser_check(p, v__token__Kind__name);
			}
			name = /*f*/string__plus(name, _SLIT(" "));
		}
		bool is_directive = p->tok.kind == v__token__Kind__dot;
		if (is_directive) {
			v__parser__Parser_next(p);
		}
		if (p->tok.kind == v__token__Kind__key_in || p->tok.kind == v__token__Kind__key_lock || p->tok.kind == v__token__Kind__key_orelse) {
			name = /*f*/string__plus(name, v__token__Kind_str(p->tok.kind));
			v__parser__Parser_next(p);
		} else if (p->tok.kind == v__token__Kind__number) {
			name = /*f*/string__plus(name, p->tok.lit);
			v__parser__Parser_next(p);
		} else {
			name = /*f*/string__plus(name, p->tok.lit);
			v__parser__Parser_check(p, v__token__Kind__name);
		}
		if (arch == v__pref__Arch__rv32 || arch == v__pref__Arch__rv64) {
			for (;;) {
				if (!(p->tok.kind == v__token__Kind__dot)) break;
				name = /*f*/string__plus(name, _SLIT("."));
				v__parser__Parser_next(p);
				name = /*f*/string__plus(name, p->tok.lit);
				v__parser__Parser_check(p, v__token__Kind__name);
			}
		}
		bool is_label = false;
		Array_v__ast__AsmArg args = __new_array_with_default(0, 0, sizeof(v__ast__AsmArg), 0);
		if (p->tok.line_nr == p->prev_tok.line_nr) {
			args_loop:
			for (;;) {
				if (v__token__Token_position(&p->prev_tok).line_nr < v__token__Token_position(&p->tok).line_nr) {
					break;
				}
				string segment = _SLIT("");
				if (p->tok.kind == v__token__Kind__name && p->peek_tok.kind == v__token__Kind__colon) {
					segment = p->tok.lit;
					v__parser__Parser_next(p);
					v__parser__Parser_next(p);
				}

				if (p->tok.kind == (v__token__Kind__name)) {
					array_push((array*)&args, _MOV((v__ast__AsmArg[]){ v__parser__Parser_reg_or_alias(p) }));
				}
				else if (p->tok.kind == (v__token__Kind__number)) {
					v__ast__Expr number_lit = v__parser__Parser_parse_number_literal(p);
					if (number_lit._typ == 297 /* v.ast.FloatLiteral */) {
						array_push((array*)&args, _MOV((v__ast__AsmArg[]){ v__ast__FloatLiteral_to_sumtype_v__ast__AsmArg(ADDR(v__ast__FloatLiteral, ((v__ast__FloatLiteral){(*number_lit._v__ast__FloatLiteral).val,(*number_lit._v__ast__FloatLiteral).pos,}))) }));
					}
					else if (number_lit._typ == 304 /* v.ast.IntegerLiteral */) {
						if (is_directive) {
							array_push((array*)&args, _MOV((v__ast__AsmArg[]){ v__ast__AsmDisp_to_sumtype_v__ast__AsmArg(ADDR(v__ast__AsmDisp, ((v__ast__AsmDisp){.val = (*number_lit._v__ast__IntegerLiteral).val,.pos = (*number_lit._v__ast__IntegerLiteral).pos,}))) }));
						} else {
							array_push((array*)&args, _MOV((v__ast__AsmArg[]){ v__ast__IntegerLiteral_to_sumtype_v__ast__AsmArg(ADDR(v__ast__IntegerLiteral, ((v__ast__IntegerLiteral){(*number_lit._v__ast__IntegerLiteral).val,(*number_lit._v__ast__IntegerLiteral).pos,}))) }));
						}
					}
					
					else {
						v__parser__verror( str_intp(2, _MOV((StrIntpData[]){{_SLIT("p.parse_number_literal() invalid output: `"), 0xfe10, {.d_s = v__ast__Expr_str(number_lit)}}, {_SLIT("`"), 0, { .d_c = 0 }}})));
						VUNREACHABLE();
					}
					;
				}
				else if (p->tok.kind == (v__token__Kind__chartoken)) {
					array_push((array*)&args, _MOV((v__ast__AsmArg[]){ v__ast__CharLiteral_to_sumtype_v__ast__AsmArg(ADDR(v__ast__CharLiteral, ((v__ast__CharLiteral){.val = p->tok.lit,.pos = v__token__Token_position(&p->tok),}))) }));
					v__parser__Parser_next(p);
				}
				else if (p->tok.kind == (v__token__Kind__colon)) {
					is_label = true;
					v__parser__Parser_next(p);
					array_push((array*)&local_labels, _MOV((string[]){ string_clone(name) }));
					break;
				}
				else if (p->tok.kind == (v__token__Kind__lsbr)) {
					v__ast__AsmAddressing addressing = v__parser__Parser_asm_addressing(p);
					addressing.segment = segment;
					array_push((array*)&args, _MOV((v__ast__AsmArg[]){ v__ast__AsmAddressing_to_sumtype_v__ast__AsmArg(&addressing) }));
				}
				else if (p->tok.kind == (v__token__Kind__rcbr)) {
					break;
				}
				else if (p->tok.kind == (v__token__Kind__semicolon)) {
					break;
				}
				else {
					v__parser__Parser_error(p, _SLIT("invalid token in assembly block"));
				};
				if (p->tok.kind == v__token__Kind__comma) {
					v__parser__Parser_next(p);
				} else {
					break;
				}
				args_loop__continue: {}
			}
			args_loop__break: {}
		}
		Array_v__ast__Comment comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
		for (;;) {
			if (!(p->tok.kind == v__token__Kind__comment)) break;
			array_push((array*)&comments, _MOV((v__ast__Comment[]){ v__parser__Parser_comment(p) }));
		}
		if (is_directive && (string__eq(name, _SLIT("globl")) || string__eq(name, _SLIT("global")))) {
			for (int _t12 = 0; _t12 < args.len; ++_t12) {
				v__ast__AsmArg arg = ((v__ast__AsmArg*)args.data)[_t12];
				array_push((array*)&p->global_labels, _MOV((string[]){ string_clone((/* as */ *(v__ast__AsmAlias*)__as_cast((arg)._v__ast__AsmAlias,(arg)._typ, 429) /*expected idx: 429, name: v.ast.AsmAlias */ ).name) }));
			}
		}
		array_push((array*)&templates, _MOV((v__ast__AsmTemplate[]){ (v__ast__AsmTemplate){
			.name = name,
			.is_label = is_label,
			.is_directive = is_directive,
			.args = args,
			.comments = comments,
			.pos = v__token__Position_extend(template_pos, v__token__Token_position(&p->tok)),
		} }));
	}
	v__ast__Scope* scope = p->scope;
	p->scope = backup_scope;
	p->inside_asm_template = false;
	Array_v__ast__AsmIO output = __new_array_with_default(0, 0, sizeof(v__ast__AsmIO), 0);
	Array_v__ast__AsmIO input = __new_array_with_default(0, 0, sizeof(v__ast__AsmIO), 0);
	Array_v__ast__AsmClobbered clobbered = __new_array_with_default(0, 0, sizeof(v__ast__AsmClobbered), 0);
	Array_string global_labels = __new_array_with_default(0, 0, sizeof(string), 0);
	if (!is_top_level) {
		if (p->tok.kind == v__token__Kind__semicolon) {
			output = v__parser__Parser_asm_ios(p, true);
			if (p->tok.kind == v__token__Kind__semicolon) {
				input = v__parser__Parser_asm_ios(p, false);
			}
			if (p->tok.kind == v__token__Kind__semicolon) {
				backup_scope = p->scope;
				p->scope = scope;
				v__parser__Parser_next(p);
				for (;;) {
					if (!(p->tok.kind == v__token__Kind__name)) break;
					v__ast__AsmRegister reg = (v__ast__AsmRegister){.name = p->tok.lit,.typ = 0,.size = -1,};
					v__parser__Parser_next(p);
					Array_v__ast__Comment comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
					for (;;) {
						if (!(p->tok.kind == v__token__Kind__comment)) break;
						array_push((array*)&comments, _MOV((v__ast__Comment[]){ v__parser__Parser_comment(p) }));
					}
					array_push((array*)&clobbered, _MOV((v__ast__AsmClobbered[]){ (v__ast__AsmClobbered){.reg = reg,.comments = comments,} }));
					if (p->tok.kind == v__token__Kind__rcbr || p->tok.kind == v__token__Kind__semicolon) {
						break;
					}
				}
				if (is_goto && p->tok.kind == v__token__Kind__semicolon) {
					v__parser__Parser_next(p);
					for (;;) {
						if (!(p->tok.kind == v__token__Kind__name)) break;
						array_push((array*)&global_labels, _MOV((string[]){ string_clone(p->tok.lit) }));
						v__parser__Parser_next(p);
					}
				}
			}
		}
	} else if (p->tok.kind == v__token__Kind__semicolon) {
		v__parser__Parser_error(p, _SLIT("extended assembly is not allowed as a top level statement"));
	}
	p->scope = backup_scope;
	v__parser__Parser_check(p, v__token__Kind__rcbr);
	if (is_top_level) {
		v__parser__Parser_top_level_statement_end(p);
	}
	scope->end_pos = p->prev_tok.pos;
	v__ast__AsmStmt _t18 = (v__ast__AsmStmt){
		.arch = arch,
		.is_basic = is_top_level || output.len + input.len + clobbered.len == 0,
		.is_volatile = is_volatile,
		.is_goto = is_goto,
		.clobbered = clobbered,
		.pos = v__token__Position_extend(pos, v__token__Token_position(&p->prev_tok)),
		.templates = templates,
		.scope = scope,
		.output = output,
		.input = input,
		.global_labels = global_labels,
		.local_labels = local_labels,
	};
	// Defer begin
	if (v__parser__Parser_asm_stmt_defer_0) {
		p->inside_asm = false;
		p->inside_asm_template = false;
	}
	// Defer end
	return _t18;
}

VV_LOCAL_SYMBOL v__ast__AsmArg v__parser__Parser_reg_or_alias(v__parser__Parser* p) {
	v__parser__Parser_check(p, v__token__Kind__name);
	bool _t3 = (p->prev_tok.len >= 2 && (string_at(p->prev_tok.lit, 0) == 'b' || string_at(p->prev_tok.lit, 0) == 'f'));
	bool _t4 = true;
	if (_t3) {
		Array_byte _t4_orig = string_bytes(string_substr(p->prev_tok.lit, 1, p->prev_tok.lit.len));
		int _t4_len = _t4_orig.len;
		for (int _t5 = 0; _t5 < _t4_len; ++_t5) {
			byte it = ((byte*) _t4_orig.data)[_t5];
			if (!(byte_is_digit(it))) {
				_t4 = false;
				break;
			}
		}
	}
	if (_IN_MAP(ADDR(string, p->prev_tok.lit), ADDR(map, p->scope->objects))) {
		v__ast__ScopeObject x = (*(v__ast__ScopeObject*)map_get(ADDR(map, p->scope->objects), &(string[]){p->prev_tok.lit}, &(v__ast__ScopeObject[]){ {0} }));
		if ((x)._typ == 354 /* v.ast.AsmRegister */) {
			v__ast__AsmArg _t1 = v__ast__AsmRegister_to_sumtype_v__ast__AsmArg(ADDR(v__ast__AsmRegister, ((*x._v__ast__AsmRegister))));
			return _t1;
		} else {
			v__parser__verror(_SLIT("non-register ast.ScopeObject found in scope"));
			VUNREACHABLE();
			v__ast__AsmArg _t2 = v__ast__AsmDisp_to_sumtype_v__ast__AsmArg(ADDR(v__ast__AsmDisp, ((v__ast__AsmDisp){.val = (string){.str=(byteptr)"", .is_lit=1},.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},})));
			return _t2;
		}
	} else if ( _t3 &&_t4) {
		v__ast__AsmArg _t6 = v__ast__AsmDisp_to_sumtype_v__ast__AsmArg(ADDR(v__ast__AsmDisp, ((v__ast__AsmDisp){.val = string__plus(string_substr(p->prev_tok.lit, 1, p->prev_tok.lit.len), byte_ascii_str(string_at(p->prev_tok.lit, 0))),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},})));
		return _t6;
	} else {
		v__ast__AsmArg _t7 = v__ast__AsmAlias_to_sumtype_v__ast__AsmArg(ADDR(v__ast__AsmAlias, ((v__ast__AsmAlias){.pos = v__token__Token_position(&p->prev_tok),.name = p->prev_tok.lit,})));
		return _t7;
	}
	return (v__ast__AsmArg){0};
}

VV_LOCAL_SYMBOL v__ast__AsmAddressing v__parser__Parser_asm_addressing(v__parser__Parser* p) {
	v__token__Position pos = v__token__Token_position(&p->tok);
	v__parser__Parser_check(p, v__token__Kind__lsbr);
	string unknown_addressing_mode = _SLIT("unknown addressing mode. supported ones are [displacement],	[base], [base + displacement], [index ∗ scale + displacement], [base + index ∗ scale + displacement], [base + index + displacement], [rip + displacement]");
	if (p->peek_tok.kind == v__token__Kind__rsbr) {
		if (p->tok.kind == v__token__Kind__name) {
			v__ast__AsmArg base = v__parser__Parser_reg_or_alias(p);
			v__parser__Parser_check(p, v__token__Kind__rsbr);
			v__ast__AsmAddressing _t1 = (v__ast__AsmAddressing){.scale = -1,.mode = v__ast__AddressingMode__base,.pos = v__token__Position_extend(pos, v__token__Token_position(&p->prev_tok)),.segment = (string){.str=(byteptr)"", .is_lit=1},.displacement = {0},.base = base,.index = {0},};
			return _t1;
		} else if (p->tok.kind == v__token__Kind__number) {
			v__ast__AsmArg _t2; /* if prepend */
			if (p->tok.kind == v__token__Kind__name) {
				_t2 = v__parser__Parser_reg_or_alias(p);
			} else {
				v__ast__AsmArg x = v__ast__AsmDisp_to_sumtype_v__ast__AsmArg(ADDR(v__ast__AsmDisp, ((v__ast__AsmDisp){.val = p->tok.lit,.pos = v__token__Token_position(&p->tok),})));
				v__parser__Parser_check(p, v__token__Kind__number);
				_t2 = x;
			}
			v__ast__AsmArg displacement =  _t2;
			v__parser__Parser_check(p, v__token__Kind__rsbr);
			v__ast__AsmAddressing _t3 = (v__ast__AsmAddressing){.scale = -1,.mode = v__ast__AddressingMode__displacement,.pos = v__token__Position_extend(pos, v__token__Token_position(&p->prev_tok)),.segment = (string){.str=(byteptr)"", .is_lit=1},.displacement = displacement,.base = {0},.index = {0},};
			return _t3;
		} else {
			v__parser__Parser_error(p, unknown_addressing_mode);
		}
	}
	if (p->peek_tok.kind == v__token__Kind__plus && p->tok.kind == v__token__Kind__name) {
		if (string__eq(p->tok.lit, _SLIT("rip"))) {
			v__ast__AsmArg rip = v__parser__Parser_reg_or_alias(p);
			v__parser__Parser_next(p);
			v__ast__AsmArg _t4; /* if prepend */
			if (p->tok.kind == v__token__Kind__name) {
				_t4 = v__parser__Parser_reg_or_alias(p);
			} else {
				v__ast__AsmArg x = v__ast__AsmDisp_to_sumtype_v__ast__AsmArg(ADDR(v__ast__AsmDisp, ((v__ast__AsmDisp){.val = p->tok.lit,.pos = v__token__Token_position(&p->tok),})));
				v__parser__Parser_check(p, v__token__Kind__number);
				_t4 = x;
			}
			v__ast__AsmArg displacement =  _t4;
			v__parser__Parser_check(p, v__token__Kind__rsbr);
			v__ast__AsmAddressing _t5 = (v__ast__AsmAddressing){.scale = -1,.mode = v__ast__AddressingMode__rip_plus_displacement,.pos = v__token__Position_extend(pos, v__token__Token_position(&p->prev_tok)),.segment = (string){.str=(byteptr)"", .is_lit=1},.displacement = displacement,.base = rip,.index = {0},};
			return _t5;
		}
		v__ast__AsmArg base = v__parser__Parser_reg_or_alias(p);
		v__parser__Parser_next(p);
		if (p->peek_tok.kind == v__token__Kind__rsbr) {
			if (p->tok.kind == v__token__Kind__number) {
				v__ast__AsmArg _t6; /* if prepend */
				if (p->tok.kind == v__token__Kind__name) {
					_t6 = v__parser__Parser_reg_or_alias(p);
				} else {
					v__ast__AsmArg x = v__ast__AsmDisp_to_sumtype_v__ast__AsmArg(ADDR(v__ast__AsmDisp, ((v__ast__AsmDisp){.val = p->tok.lit,.pos = v__token__Token_position(&p->tok),})));
					v__parser__Parser_check(p, v__token__Kind__number);
					_t6 = x;
				}
				v__ast__AsmArg displacement =  _t6;
				v__parser__Parser_check(p, v__token__Kind__rsbr);
				v__ast__AsmAddressing _t7 = (v__ast__AsmAddressing){.scale = -1,.mode = v__ast__AddressingMode__base_plus_displacement,.pos = v__token__Position_extend(pos, v__token__Token_position(&p->prev_tok)),.segment = (string){.str=(byteptr)"", .is_lit=1},.displacement = displacement,.base = base,.index = {0},};
				return _t7;
			} else {
				v__parser__Parser_error(p, unknown_addressing_mode);
			}
		}
		v__ast__AsmArg index = v__parser__Parser_reg_or_alias(p);
		if (p->tok.kind == v__token__Kind__mul) {
			v__parser__Parser_next(p);
			int scale = string_int(p->tok.lit);
			v__parser__Parser_check(p, v__token__Kind__number);
			v__parser__Parser_check(p, v__token__Kind__plus);
			v__ast__AsmArg _t8; /* if prepend */
			if (p->tok.kind == v__token__Kind__name) {
				_t8 = v__parser__Parser_reg_or_alias(p);
			} else {
				v__ast__AsmArg x = v__ast__AsmDisp_to_sumtype_v__ast__AsmArg(ADDR(v__ast__AsmDisp, ((v__ast__AsmDisp){.val = p->tok.lit,.pos = v__token__Token_position(&p->tok),})));
				v__parser__Parser_check(p, v__token__Kind__number);
				_t8 = x;
			}
			v__ast__AsmArg displacement =  _t8;
			v__parser__Parser_check(p, v__token__Kind__rsbr);
			v__ast__AsmAddressing _t9 = (v__ast__AsmAddressing){
				.scale = scale,
				.mode = v__ast__AddressingMode__base_plus_index_times_scale_plus_displacement,
				.pos = v__token__Position_extend(pos, v__token__Token_position(&p->prev_tok)),
				.segment = (string){.str=(byteptr)"", .is_lit=1},
				.displacement = displacement,
				.base = base,
				.index = index,
			};
			return _t9;
		} else if (p->tok.kind == v__token__Kind__plus) {
			v__parser__Parser_next(p);
			v__ast__AsmArg _t10; /* if prepend */
			if (p->tok.kind == v__token__Kind__name) {
				_t10 = v__parser__Parser_reg_or_alias(p);
			} else {
				v__ast__AsmArg x = v__ast__AsmDisp_to_sumtype_v__ast__AsmArg(ADDR(v__ast__AsmDisp, ((v__ast__AsmDisp){.val = p->tok.lit,.pos = v__token__Token_position(&p->tok),})));
				v__parser__Parser_check(p, v__token__Kind__number);
				_t10 = x;
			}
			v__ast__AsmArg displacement =  _t10;
			v__parser__Parser_check(p, v__token__Kind__rsbr);
			v__ast__AsmAddressing _t11 = (v__ast__AsmAddressing){.scale = -1,.mode = v__ast__AddressingMode__base_plus_index_plus_displacement,.pos = v__token__Position_extend(pos, v__token__Token_position(&p->prev_tok)),.segment = (string){.str=(byteptr)"", .is_lit=1},.displacement = displacement,.base = base,.index = index,};
			return _t11;
		}
	}
	if (p->peek_tok.kind == v__token__Kind__mul) {
		v__ast__AsmArg index = v__parser__Parser_reg_or_alias(p);
		v__parser__Parser_next(p);
		int scale = string_int(p->tok.lit);
		v__parser__Parser_check(p, v__token__Kind__number);
		v__parser__Parser_check(p, v__token__Kind__plus);
		v__ast__AsmArg _t12; /* if prepend */
		if (p->tok.kind == v__token__Kind__name) {
			_t12 = v__parser__Parser_reg_or_alias(p);
		} else {
			v__ast__AsmArg x = v__ast__AsmDisp_to_sumtype_v__ast__AsmArg(ADDR(v__ast__AsmDisp, ((v__ast__AsmDisp){.val = p->tok.lit,.pos = v__token__Token_position(&p->tok),})));
			v__parser__Parser_check(p, v__token__Kind__number);
			_t12 = x;
		}
		v__ast__AsmArg displacement =  _t12;
		v__parser__Parser_check(p, v__token__Kind__rsbr);
		v__ast__AsmAddressing _t13 = (v__ast__AsmAddressing){.scale = scale,.mode = v__ast__AddressingMode__index_times_scale_plus_displacement,.pos = v__token__Position_extend(pos, v__token__Token_position(&p->prev_tok)),.segment = (string){.str=(byteptr)"", .is_lit=1},.displacement = displacement,.base = {0},.index = index,};
		return _t13;
	}
	v__parser__Parser_error(p, unknown_addressing_mode);
	v__ast__AsmAddressing _t14 = (v__ast__AsmAddressing){.scale = -1,.mode = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.segment = (string){.str=(byteptr)"", .is_lit=1},.displacement = {0},.base = {0},.index = {0},};
	return _t14;
}

VV_LOCAL_SYMBOL Array_v__ast__AsmIO v__parser__Parser_asm_ios(v__parser__Parser* p, bool output) {
	Array_v__ast__AsmIO res = __new_array_with_default(0, 0, sizeof(v__ast__AsmIO), 0);
	v__parser__Parser_check(p, v__token__Kind__semicolon);
	if (p->tok.kind == v__token__Kind__rcbr || p->tok.kind == v__token__Kind__semicolon) {
		Array_v__ast__AsmIO _t1 = __new_array_with_default(0, 0, sizeof(v__ast__AsmIO), 0);
		return _t1;
	}
	for (;;) {
		v__token__Position pos = v__token__Token_position(&p->tok);
		string constraint = _SLIT("");
		if (p->tok.kind == v__token__Kind__lpar) {
			constraint = (output ? (_SLIT("+r")) : (_SLIT("r")));
		} else {
			constraint = /*f*/string__plus(constraint, ((p->tok.kind == (v__token__Kind__assign)) ? (_SLIT("=")) : (p->tok.kind == (v__token__Kind__plus)) ? (_SLIT("+")) : (p->tok.kind == (v__token__Kind__mod)) ? (_SLIT("%")) : (p->tok.kind == (v__token__Kind__amp)) ? (_SLIT("&")) : (_SLIT(""))));
			if ((constraint).len != 0) {
				v__parser__Parser_next(p);
			}
			constraint = /*f*/string__plus(constraint, p->tok.lit);
			if (p->tok.kind == v__token__Kind__at) {
				v__parser__Parser_next(p);
			} else {
				v__parser__Parser_check(p, v__token__Kind__name);
			}
		}
		v__ast__Expr expr = v__parser__Parser_expr(p, 0);
		if ((expr)._typ == 314 /* v.ast.ParExpr */) {
			expr = (*expr._v__ast__ParExpr).expr;
		} else {
			v__parser__Parser_error(p, _SLIT("asm in/output must be enclosed in brackets"));
		}
		string alias = _SLIT("");
		if (p->tok.kind == v__token__Kind__key_as) {
			v__parser__Parser_next(p);
			alias = p->tok.lit;
			v__parser__Parser_check(p, v__token__Kind__name);
		} else if ((expr)._typ == 299 /* v.ast.Ident */) {
			alias = (*expr._v__ast__Ident).name;
		}
		Array_v__ast__Comment comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
		for (;;) {
			if (!(p->tok.kind == v__token__Kind__comment)) break;
			array_push((array*)&comments, _MOV((v__ast__Comment[]){ v__parser__Parser_comment(p) }));
		}
		array_push((array*)&res, _MOV((v__ast__AsmIO[]){ (v__ast__AsmIO){.alias = alias,.constraint = constraint,.expr = expr,.comments = comments,.typ = 0,.pos = v__token__Position_extend(pos, v__token__Token_position(&p->prev_tok)),} }));
		p->n_asm++;
		if (p->tok.kind == v__token__Kind__semicolon || p->tok.kind == v__token__Kind__rcbr) {
			break;
		}
	}
	Array_v__ast__AsmIO _t4 = res;
	return _t4;
}

VV_LOCAL_SYMBOL multi_return_Array_v__ast__Expr_Array_v__ast__Comment v__parser__Parser_expr_list(v__parser__Parser* p) {
	Array_v__ast__Expr exprs = __new_array_with_default(0, 0, sizeof(v__ast__Expr), 0);
	Array_v__ast__Comment comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	for (;;) {
		v__ast__Expr expr = v__parser__Parser_expr(p, 0);
		if ((expr)._typ == 290 /* v.ast.Comment */) {
			array_push((array*)&comments, _MOV((v__ast__Comment[]){ (*expr._v__ast__Comment) }));
		} else {
			array_push((array*)&exprs, _MOV((v__ast__Expr[]){ expr }));
			if (p->tok.kind != v__token__Kind__comma) {
				break;
			}
			v__parser__Parser_next(p);
		}
	}
	return (multi_return_Array_v__ast__Expr_Array_v__ast__Comment){.arg0=exprs, .arg1=comments};
}

VV_LOCAL_SYMBOL bool v__parser__Parser_is_attributes(v__parser__Parser* p) {
	if (p->tok.kind != v__token__Kind__lsbr) {
		bool _t1 = false;
		return _t1;
	}
	int i = 0;
	for (;;) {
		v__token__Token tok = v__parser__Parser_peek_token(p, i);
		if (tok.kind == v__token__Kind__eof || tok.line_nr != p->tok.line_nr) {
			bool _t2 = false;
			return _t2;
		}
		if (tok.kind == v__token__Kind__rsbr) {
			break;
		}
		i++;
	}
	v__token__Token peek_rsbr_tok = v__parser__Parser_peek_token(p, i + 1);
	if (peek_rsbr_tok.line_nr == p->tok.line_nr && peek_rsbr_tok.kind != v__token__Kind__rcbr) {
		bool _t3 = false;
		return _t3;
	}
	bool _t4 = true;
	return _t4;
}

VV_LOCAL_SYMBOL void v__parser__Parser_attributes(v__parser__Parser* p) {
	v__parser__Parser_check(p, v__token__Kind__lsbr);
	bool has_ctdefine = false;
	for (;;) {
		if (!(p->tok.kind != v__token__Kind__rsbr)) break;
		v__token__Position start_pos = v__token__Token_position(&p->tok);
		v__ast__Attr attr = v__parser__Parser_parse_attr(p);
		if (Array_v__ast__Attr_contains(p->attrs, attr.name) && !string__eq(attr.name, _SLIT("wasm_export"))) {
			v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("duplicate attribute `"), 0xfe10, {.d_s = attr.name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), v__token__Position_extend(start_pos, v__token__Token_position(&p->prev_tok)));
			return;
		}
		if (attr.kind == v__ast__AttrKind__comptime_define) {
			if (has_ctdefine) {
				v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("only one `[if flag]` may be applied at a time `"), 0xfe10, {.d_s = attr.name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), v__token__Position_extend(start_pos, v__token__Token_position(&p->prev_tok)));
				return;
			} else {
				has_ctdefine = true;
			}
		}
		array_push((array*)&p->attrs, _MOV((v__ast__Attr[]){ attr }));
		if (p->tok.kind != v__token__Kind__semicolon) {
			if (p->tok.kind == v__token__Kind__rsbr) {
				v__parser__Parser_next(p);
				break;
			}
			v__parser__Parser_error(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unexpected "), 0xfe10, {.d_s = v__token__Token_str(p->tok)}}, {_SLIT(", expecting `;`"), 0, { .d_c = 0 }}})));
			return;
		}
		v__parser__Parser_next(p);
	}
	if (p->attrs.len == 0) {
		v__parser__Parser_error_with_pos(p, _SLIT("attributes cannot be empty"), v__token__Position_extend(v__token__Token_position(&p->prev_tok), v__token__Token_position(&p->tok)));
		return;
	}
}

VV_LOCAL_SYMBOL v__ast__Attr v__parser__Parser_parse_attr(v__parser__Parser* p) {
	v__ast__AttrKind kind = v__ast__AttrKind__plain;
	v__token__Position apos = v__token__Token_position(&p->prev_tok);
	if (p->tok.kind == v__token__Kind__key_unsafe) {
		v__parser__Parser_next(p);
		v__ast__Attr _t1 = (v__ast__Attr){.name = _SLIT("unsafe"),.has_arg = 0,.arg = (string){.str=(byteptr)"", .is_lit=1},.kind = kind,.ct_expr = {0},.ct_opt = 0,.pos = v__token__Position_extend(apos, v__token__Token_position(&p->tok)),.ct_evaled = 0,.ct_skip = 0,};
		return _t1;
	}
	string name = _SLIT("");
	bool has_arg = false;
	string arg = _SLIT("");
	v__ast__Expr comptime_cond = v__ast__empty_expr();
	bool comptime_cond_opt = false;
	if (p->tok.kind == v__token__Kind__key_if) {
		kind = v__ast__AttrKind__comptime_define;
		v__parser__Parser_next(p);
		p->comptime_if_cond = true;
		p->inside_if_expr = true;
		p->inside_ct_if_expr = true;
		comptime_cond = v__parser__Parser_expr(p, 0);
		p->comptime_if_cond = false;
		p->inside_if_expr = false;
		p->inside_ct_if_expr = false;
		if ((comptime_cond)._typ == 315 /* v.ast.PostfixExpr */) {
			comptime_cond_opt = true;
		}
		name = v__ast__Expr_str(comptime_cond);
	} else if (p->tok.kind == v__token__Kind__string) {
		name = p->tok.lit;
		kind = v__ast__AttrKind__string;
		v__parser__Parser_next(p);
	} else {
		name = v__parser__Parser_check_name(p);
		if (p->tok.kind == v__token__Kind__dot) {
			v__parser__Parser_next(p);
			name = /*f*/string__plus(name, _SLIT("."));
			name = /*f*/string__plus(name, v__parser__Parser_check_name(p));
		}
		if (p->tok.kind == v__token__Kind__colon) {
			has_arg = true;
			v__parser__Parser_next(p);
			if (p->tok.kind == v__token__Kind__name) {
				kind = v__ast__AttrKind__plain;
				arg = v__parser__Parser_check_name(p);
			} else if (p->tok.kind == v__token__Kind__number) {
				kind = v__ast__AttrKind__number;
				arg = p->tok.lit;
				v__parser__Parser_next(p);
			} else if (p->tok.kind == v__token__Kind__string) {
				kind = v__ast__AttrKind__string;
				arg = p->tok.lit;
				v__parser__Parser_next(p);
			} else if (p->tok.kind == v__token__Kind__key_true || p->tok.kind == v__token__Kind__key_false) {
				kind = v__ast__AttrKind__bool;
				arg = v__token__Kind_str(p->tok.kind);
				v__parser__Parser_next(p);
			} else {
				v__parser__Parser_error(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unexpected "), 0xfe10, {.d_s = v__token__Token_str(p->tok)}}, {_SLIT(", an argument is expected after `:`"), 0, { .d_c = 0 }}})));
			}
		}
	}
	v__ast__Attr _t2 = (v__ast__Attr){
		.name = name,
		.has_arg = has_arg,
		.arg = arg,
		.kind = kind,
		.ct_expr = comptime_cond,
		.ct_opt = comptime_cond_opt,
		.pos = v__token__Position_extend(apos, v__token__Token_position(&p->tok)),
		.ct_evaled = 0,
		.ct_skip = 0,
	};
	return _t2;
}

void v__parser__Parser_language_not_allowed_error(v__parser__Parser* p, v__ast__Language language, v__token__Position pos) {
	string upcase_language = string_to_upper(v__ast__Language_str(language));
	v__parser__Parser_error_with_pos(p,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = upcase_language}}, {_SLIT(" code is not allowed in ."), 0xfe10, {.d_s = v__ast__Language_str(p->file_backend_mode)}}, {_SLIT(".v files, please move it to a ."), 0xfe10, {.d_s = v__ast__Language_str(language)}}, {_SLIT(".v file"), 0, { .d_c = 0 }}})), pos);
}

void v__parser__Parser_language_not_allowed_warning(v__parser__Parser* p, v__ast__Language language, v__token__Position pos) {
	string upcase_language = string_to_upper(v__ast__Language_str(language));
	v__parser__Parser_warn_with_pos(p,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = upcase_language}}, {_SLIT(" code will not be allowed in pure .v files, please move it to a ."), 0xfe10, {.d_s = v__ast__Language_str(language)}}, {_SLIT(".v file instead"), 0, { .d_c = 0 }}})), pos);
}

void v__parser__Parser_check_for_impure_v(v__parser__Parser* p, v__ast__Language language, v__token__Position pos) {
	if (language == v__ast__Language__v) {
		return;
	} else {

		if (p->file_backend_mode == (v__ast__Language__c)) {
			if (language != v__ast__Language__c) {
				v__parser__Parser_language_not_allowed_error(p, language, pos);
				return;
			}
		}
		else if (p->file_backend_mode == (v__ast__Language__js)) {
			if (language != v__ast__Language__js) {
				v__parser__Parser_language_not_allowed_error(p, language, pos);
				return;
			}
		}
		else {
		};
	}
	if (!p->pref->warn_impure_v) {
		return;
	}
	if (p->file_backend_mode != language) {
		if (p->file_backend_mode == v__ast__Language__v) {
			v__parser__Parser_language_not_allowed_warning(p, language, pos);
			return;
		}
	}
}

v__ast__NodeError v__parser__Parser_error(v__parser__Parser* p, string s) {
	v__ast__NodeError _t1 = v__parser__Parser_error_with_pos(p, s, v__token__Token_position(&p->tok));
	return _t1;
}

void v__parser__Parser_warn(v__parser__Parser* p, string s) {
	v__parser__Parser_warn_with_pos(p, s, v__token__Token_position(&p->tok));
}

void v__parser__Parser_note(v__parser__Parser* p, string s) {
	v__parser__Parser_note_with_pos(p, s, v__token__Token_position(&p->tok));
}

v__ast__NodeError v__parser__Parser_error_with_pos(v__parser__Parser* p, string s, v__token__Position pos) {
	if (p->pref->fatal_errors) {
		_v_exit(1);
		VUNREACHABLE();
	}
	string kind = _SLIT("error:");
	if (p->pref->output_mode == v__pref__OutputMode__stdout && !p->pref->check_only) {
		if (p->pref->is_verbose) {
			print_backtrace();
			kind = _SLIT("parser error:");
		}
		string ferror = v__util__formatted_error(kind, s, p->file_name, pos);
		eprintln(ferror);
		_v_exit(1);
		VUNREACHABLE();
	} else {
		array_push((array*)&p->errors, _MOV((v__errors__Error[]){ (v__errors__Error){.message = s,.details = (string){.str=(byteptr)"", .is_lit=1},.file_path = p->file_name,.pos = pos,.backtrace = (string){.str=(byteptr)"", .is_lit=1},.reporter = v__errors__Reporter__parser,} }));
		if (p->pref->check_only) {
			v__parser__Parser_next(p);
		}
	}
	if (p->pref->output_mode == v__pref__OutputMode__silent) {
		v__parser__Parser_next(p);
	}
	v__ast__NodeError _t2 = (v__ast__NodeError){.idx = p->errors.len - 1,.pos = pos,};
	return _t2;
}

void v__parser__Parser_error_with_error(v__parser__Parser* p, v__errors__Error _v_error) {
	if (p->pref->fatal_errors) {
		_v_exit(1);
		VUNREACHABLE();
	}
	string kind = _SLIT("error:");
	if (p->pref->output_mode == v__pref__OutputMode__stdout && !p->pref->check_only) {
		if (p->pref->is_verbose) {
			print_backtrace();
			kind = _SLIT("parser error:");
		}
		string ferror = v__util__formatted_error(kind, _v_error.message, _v_error.file_path, _v_error.pos);
		eprintln(ferror);
		_v_exit(1);
		VUNREACHABLE();
	} else {
		if (p->pref->message_limit >= 0 && p->errors.len >= p->pref->message_limit) {
			p->should_abort = true;
			return;
		}
		array_push((array*)&p->errors, _MOV((v__errors__Error[]){ _v_error }));
	}
	if (p->pref->output_mode == v__pref__OutputMode__silent) {
		v__parser__Parser_next(p);
	}
}

void v__parser__Parser_warn_with_pos(v__parser__Parser* p, string s, v__token__Position pos) {
	if (p->pref->warns_are_errors) {
		v__parser__Parser_error_with_pos(p, s, pos);
		return;
	}
	if (p->pref->skip_warnings) {
		return;
	}
	if (p->pref->output_mode == v__pref__OutputMode__stdout && !p->pref->check_only) {
		string ferror = v__util__formatted_error(_SLIT("warning:"), s, p->file_name, pos);
		eprintln(ferror);
	} else {
		if (p->pref->message_limit >= 0 && p->warnings.len >= p->pref->message_limit) {
			p->should_abort = true;
			return;
		}
		array_push((array*)&p->warnings, _MOV((v__errors__Warning[]){ (v__errors__Warning){.message = s,.details = (string){.str=(byteptr)"", .is_lit=1},.file_path = p->file_name,.pos = pos,.reporter = v__errors__Reporter__parser,} }));
	}
}

void v__parser__Parser_note_with_pos(v__parser__Parser* p, string s, v__token__Position pos) {
	if (p->pref->skip_warnings) {
		return;
	}
	if (p->is_generated) {
		return;
	}
	if (p->pref->output_mode == v__pref__OutputMode__stdout && !p->pref->check_only) {
		string ferror = v__util__formatted_error(_SLIT("notice:"), s, p->file_name, pos);
		eprintln(ferror);
	} else {
		array_push((array*)&p->notices, _MOV((v__errors__Notice[]){ (v__errors__Notice){.message = s,.details = (string){.str=(byteptr)"", .is_lit=1},.file_path = p->file_name,.pos = pos,.reporter = v__errors__Reporter__parser,} }));
	}
}

void v__parser__Parser_vet_error(v__parser__Parser* p, string msg, int line, v__vet__FixKind fix, v__vet__ErrorType typ) {
	v__token__Position pos = (v__token__Position){.len = 0,.line_nr = line + 1,.pos = 0,.col = 0,.last_line = 0,};
	array_push((array*)&p->vet_errors, _MOV((v__vet__Error[]){ (v__vet__Error){
		.kind = v__vet__ErrorKind__error,
		.message = msg,
		.details = (string){.str=(byteptr)"", .is_lit=1},
		.file_path = p->scanner->file_path,
		.pos = pos,
		.fix = fix,
		.typ = typ,
	} }));
}

VV_LOCAL_SYMBOL v__ast__Stmt v__parser__Parser_parse_multi_expr(v__parser__Parser* p, bool is_top_level) {
	v__token__Token tok = p->tok;
	v__token__Position pos = v__token__Token_position(&tok);
	Array_v__ast__Ident defer_vars = p->defer_vars;
	p->defer_vars = __new_array_with_default(0, 0, sizeof(v__ast__Ident), 0);
	multi_return_Array_v__ast__Expr_Array_v__ast__Comment mr_46501 = v__parser__Parser_expr_list(p);
	Array_v__ast__Expr left = mr_46501.arg0;
	Array_v__ast__Comment left_comments = mr_46501.arg1;
	if (!(p->inside_defer && p->tok.kind == v__token__Kind__decl_assign)) {
		_PUSH_MANY(&defer_vars, (p->defer_vars), _t1, Array_v__ast__Ident);
	}
	p->defer_vars = defer_vars;
	v__ast__Expr left0 = (*(v__ast__Expr*)/*ee elem_typ */array_get(left, 0));
	if (tok.kind == v__token__Kind__key_mut && p->tok.kind != v__token__Kind__decl_assign) {
		v__ast__Stmt _t2 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error(p, _SLIT("expecting `:=` (e.g. `mut x :=`)")))));
		return _t2;
	}
	if ((p->tok.kind == v__token__Kind__assign || p->tok.kind == v__token__Kind__decl_assign) || v__token__Kind_is_assign(p->tok.kind)) {
		v__ast__Stmt _t3 = v__parser__Parser_partial_assign_stmt(p, left, left_comments);
		return _t3;
	} else if (!p->pref->translated && !p->pref->is_fmt && !(tok.kind == v__token__Kind__key_if || tok.kind == v__token__Kind__key_match || tok.kind == v__token__Kind__key_lock || tok.kind == v__token__Kind__key_rlock || tok.kind == v__token__Kind__key_select)) {
		for (int _t4 = 0; _t4 < left.len; ++_t4) {
			v__ast__Expr node = ((v__ast__Expr*)left.data)[_t4];
			if ((is_top_level || p->tok.kind != v__token__Kind__rcbr) && (node)._typ != 286 /* v.ast.CallExpr */ && (node)._typ != 315 /* v.ast.PostfixExpr */ && (node)._typ != 291 /* v.ast.ComptimeCall */ && (node)._typ != 319 /* v.ast.SelectorExpr */ && (node)._typ != 294 /* v.ast.DumpExpr */) {
				bool is_complex_infix_expr = (node)._typ == 303 /* v.ast.InfixExpr */ && ((/* as */ *(v__ast__InfixExpr*)__as_cast((node)._v__ast__InfixExpr,(node)._typ, 303) /*expected idx: 303, name: v.ast.InfixExpr */ ).op == v__token__Kind__left_shift || (/* as */ *(v__ast__InfixExpr*)__as_cast((node)._v__ast__InfixExpr,(node)._typ, 303) /*expected idx: 303, name: v.ast.InfixExpr */ ).op == v__token__Kind__right_shift || (/* as */ *(v__ast__InfixExpr*)__as_cast((node)._v__ast__InfixExpr,(node)._typ, 303) /*expected idx: 303, name: v.ast.InfixExpr */ ).op == v__token__Kind__unsigned_right_shift || (/* as */ *(v__ast__InfixExpr*)__as_cast((node)._v__ast__InfixExpr,(node)._typ, 303) /*expected idx: 303, name: v.ast.InfixExpr */ ).op == v__token__Kind__arrow);
				if (!is_complex_infix_expr) {
					v__ast__Stmt _t5 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _SLIT("expression evaluated but not used"), v__ast__Expr_position(node)))));
					return _t5;
				}
			}
		}
	}
	v__token__Position_update_last_line(&pos, p->prev_tok.line_nr);
	if (left.len == 1) {
		v__ast__Stmt _t6 = v__ast__ExprStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__ExprStmt, ((v__ast__ExprStmt){.expr = left0,.pos = v__ast__Expr_position(left0),.comments = left_comments,.is_expr = p->inside_for,.typ = 0,})));
		return _t6;
	}
	v__ast__Stmt _t7 = v__ast__ExprStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__ExprStmt, ((v__ast__ExprStmt){.expr = v__ast__ConcatExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__ConcatExpr, ((v__ast__ConcatExpr){.vals = left,.pos = v__token__Token_position(&tok),.return_type = 0,}))),.pos = pos,.comments = left_comments,.is_expr = 0,.typ = 0,})));
	return _t7;
}

v__ast__Ident v__parser__Parser_parse_ident(v__parser__Parser* p, v__ast__Language language) {
	bool is_shared = p->tok.kind == v__token__Kind__key_shared;
	bool is_atomic = p->tok.kind == v__token__Kind__key_atomic;
	if (is_shared) {
		v__parser__Parser_register_auto_import(p, _SLIT("sync"));
	}
	v__token__Position mut_pos = v__token__Token_position(&p->tok);
	bool is_mut = p->tok.kind == v__token__Kind__key_mut || is_shared || is_atomic;
	if (is_mut) {
		v__parser__Parser_next(p);
	}
	bool is_static = p->tok.kind == v__token__Kind__key_static;
	if (is_static) {
		v__parser__Parser_next(p);
	}
	bool is_volatile = p->tok.kind == v__token__Kind__key_volatile;
	if (is_volatile) {
		v__parser__Parser_next(p);
	}
	if (p->tok.kind != v__token__Kind__name) {
		v__parser__Parser_error(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unexpected token `"), 0xfe10, {.d_s = p->tok.lit}}, {_SLIT("`"), 0, { .d_c = 0 }}})));
		v__ast__Ident _t1 = (v__ast__Ident){.language = 0,.tok_kind = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.mut_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comptime = 0,.scope = p->scope,.obj = {0},.mod = (string){.str=(byteptr)"", .is_lit=1},.name = (string){.str=(byteptr)"", .is_lit=1},.kind = 0,.info = {0},.is_mut = 0,};
		return _t1;
	}
	v__token__Position pos = v__token__Token_position(&p->tok);
	string name = v__parser__Parser_check_name(p);
	if (string__eq(name, _SLIT("_"))) {
		v__ast__Ident _t2 = (v__ast__Ident){
			.language = 0,
			.tok_kind = p->tok.kind,
			.pos = pos,
			.mut_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},
			.comptime = p->comptime_if_cond,
			.scope = p->scope,
			.obj = {0},
			.mod = (string){.str=(byteptr)"", .is_lit=1},
			.name = _SLIT("_"),
			.kind = v__ast__IdentKind__blank_ident,
			.info = v__ast__IdentVar_to_sumtype_v__ast__IdentInfo(ADDR(v__ast__IdentVar, ((v__ast__IdentVar){.typ = 0,.is_mut = false,.is_static = false,.is_volatile = false,.is_optional = 0,.share = 0,}))),
			.is_mut = 0,
		};
		return _t2;
	}
	if (p->inside_match_body && string__eq(name, _SLIT("it"))) {
	}
	if (p->expr_mod.len > 0) {
		name =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = p->expr_mod}}, {_SLIT("."), 0xfe10, {.d_s = name}}, {_SLIT0, 0, { .d_c = 0 }}}));
	}
	v__ast__Ident _t3 = (v__ast__Ident){
		.language = language,
		.tok_kind = p->tok.kind,
		.pos = pos,
		.mut_pos = mut_pos,
		.comptime = p->comptime_if_cond,
		.scope = p->scope,
		.obj = {0},
		.mod = p->mod,
		.name = name,
		.kind = v__ast__IdentKind__unresolved,
		.info = v__ast__IdentVar_to_sumtype_v__ast__IdentInfo(ADDR(v__ast__IdentVar, ((v__ast__IdentVar){.typ = 0,.is_mut = is_mut,.is_static = is_static,.is_volatile = is_volatile,.is_optional = 0,.share = v__ast__sharetype_from_flags(is_shared, is_atomic),}))),
		.is_mut = is_mut,
	};
	return _t3;
}

VV_LOCAL_SYMBOL bool v__parser__Parser_is_typename(v__parser__Parser* p, v__token__Token t) {
	bool _t1 = t.kind == v__token__Kind__name && (byte_is_capital(string_at(t.lit, 0)) || v__ast__Table_known_type(p->table, t.lit));
	return _t1;
}

VV_LOCAL_SYMBOL bool v__parser__Parser_is_generic_call(v__parser__Parser* p) {
	bool lit0_is_capital = p->tok.kind != v__token__Kind__eof && p->tok.lit.len > 0 && byte_is_capital(string_at(p->tok.lit, 0));
	if (lit0_is_capital || p->peek_tok.kind != v__token__Kind__lt) {
		bool _t1 = false;
		return _t1;
	}
	v__token__Token tok2 = v__parser__Parser_peek_token(p, 2);
	v__token__Token tok3 = v__parser__Parser_peek_token(p, 3);
	v__token__Token tok4 = v__parser__Parser_peek_token(p, 4);
	v__token__Token tok5 = v__parser__Parser_peek_token(p, 5);
	v__token__Kind kind2 = tok2.kind;
	v__token__Kind kind3 = tok3.kind;
	v__token__Kind kind4 = tok4.kind;
	v__token__Kind kind5 = tok5.kind;
	if (kind2 == v__token__Kind__amp) {
		tok2 = tok3;
		kind2 = kind3;
		tok3 = tok4;
		kind3 = kind4;
		tok4 = tok5;
		kind4 = kind5;
		tok5 = v__parser__Parser_peek_token(p, 6);
		kind5 = tok5.kind;
	}
	if (kind2 == v__token__Kind__lsbr) {
		bool _t2 = tok3.kind == v__token__Kind__rsbr;
		return _t2;
	}
	if (kind2 == v__token__Kind__name) {
		if (string__eq(tok2.lit, _SLIT("map")) && kind3 == v__token__Kind__lsbr) {
			bool _t3 = true;
			return _t3;
		}
		bool _t5 = 0;
		
		if (kind3 == (v__token__Kind__gt)) {
			_t5 = true;
		}
		else if (kind3 == (v__token__Kind__lt)) {
			_t5 = !(tok4.lit.len == 1 && byte_is_capital(string_at(tok4.lit, 0)));
		}
		else if (kind3 == (v__token__Kind__comma)) {
			_t5 = v__parser__Parser_is_typename(p, tok2);
		}
		else if (kind3 == (v__token__Kind__dot)) {
			_t5 = kind4 == v__token__Kind__name && (kind5 == v__token__Kind__gt || (kind5 == v__token__Kind__comma && v__parser__Parser_is_typename(p, tok4)));
		}
		else {
			_t5 = false;
		}bool _t4 = _t5;
		return _t4;
	}
	bool _t6 = false;
	return _t6;
}

VV_LOCAL_SYMBOL bool v__parser__Parser_is_generic_cast(v__parser__Parser* p) {
	if (!v__ast__type_can_start_with_token((voidptr)&/*qq*/p->tok)) {
		bool _t1 = false;
		return _t1;
	}
	int i = 0;
	int level = 0;
	int lt_count = 0;
	for (;;) {
		i++;
		v__token__Token tok = v__parser__Parser_peek_token(p, i);
		if (tok.kind == v__token__Kind__lt) {
			lt_count++;
			level++;
		} else if (tok.kind == v__token__Kind__gt) {
			level--;
		}
		if (lt_count > 0 && level == 0) {
			break;
		}
		if (i > 20 || !Array_v__token__Kind_contains(_const_v__parser__valid_tokens_inside_types, tok.kind)) {
			bool _t2 = false;
			return _t2;
		}
	}
	v__token__Token next_tok = v__parser__Parser_peek_token(p, i + 1);
	if (next_tok.kind == v__token__Kind__lpar) {
		bool _t3 = true;
		return _t3;
	}
	bool _t4 = false;
	return _t4;
}

v__ast__Expr v__parser__Parser_name_expr(v__parser__Parser* p) {
	v__token__Kind prev_tok_kind = p->prev_tok.kind;
	v__ast__Expr node = v__ast__empty_expr();
	if (p->expecting_type) {
		p->expecting_type = false;
		v__token__Position type_pos = v__token__Token_position(&p->tok);
		v__ast__Type typ = v__parser__Parser_parse_type(p);
		v__ast__Expr _t1 = v__ast__TypeNode_to_sumtype_v__ast__Expr(ADDR(v__ast__TypeNode, ((v__ast__TypeNode){.typ = typ,.pos = type_pos,})));
		return _t1;
	}
	v__ast__Language language = v__ast__Language__v;
	if (string__eq(p->tok.lit, _SLIT("C"))) {
		language = v__ast__Language__c;
		v__parser__Parser_check_for_impure_v(p, language, v__token__Token_position(&p->tok));
	} else if (string__eq(p->tok.lit, _SLIT("JS"))) {
		language = v__ast__Language__js;
		v__parser__Parser_check_for_impure_v(p, language, v__token__Token_position(&p->tok));
	}
	string mod = _SLIT("");
	p->expr_mod = _SLIT("");
	if (string__eq(p->tok.lit, _SLIT("map")) && p->peek_tok.kind == v__token__Kind__lsbr) {
		v__ast__Type map_type = v__parser__Parser_parse_map_type(p);
		if (p->tok.kind == v__token__Kind__lcbr) {
			v__parser__Parser_next(p);
			if (p->tok.kind == v__token__Kind__rcbr) {
				v__parser__Parser_next(p);
			} else {
				if (p->pref->is_fmt) {
					v__ast__MapInit map_init = v__parser__Parser_map_init(p);
					v__parser__Parser_check(p, v__token__Kind__rcbr);
					v__ast__Expr _t2 = v__ast__MapInit_to_sumtype_v__ast__Expr(&map_init);
					return _t2;
				}
				v__parser__Parser_error(p, _SLIT("`}` expected; explicit `map` initialization does not support parameters"));
			}
		}
		v__ast__Expr _t3 = v__ast__MapInit_to_sumtype_v__ast__Expr(ADDR(v__ast__MapInit, ((v__ast__MapInit){.pos = v__token__Token_position(&p->prev_tok),.keys = __new_array(0, 0, sizeof(v__ast__Expr)),.vals = __new_array(0, 0, sizeof(v__ast__Expr)),.comments = __new_array(0, 0, sizeof(Array_v__ast__Comment)),.pre_cmnts = __new_array(0, 0, sizeof(v__ast__Comment)),.typ = map_type,.key_type = 0,.value_type = 0,})));
		return _t3;
	}
	if (string__eq(p->tok.lit, _SLIT("chan"))) {
		v__token__Position first_pos = v__token__Token_position(&p->tok);
		v__token__Position last_pos = first_pos;
		v__ast__Type chan_type = v__parser__Parser_parse_chan_type(p);
		bool has_cap = false;
		v__ast__Expr cap_expr = v__ast__empty_expr();
		v__parser__Parser_check(p, v__token__Kind__lcbr);
		if (p->tok.kind == v__token__Kind__rcbr) {
			last_pos = v__token__Token_position(&p->tok);
			v__parser__Parser_next(p);
		} else {
			string key = v__parser__Parser_check_name(p);
			v__parser__Parser_check(p, v__token__Kind__colon);

			if (string__eq(key, _SLIT("cap"))) {
				has_cap = true;
				cap_expr = v__parser__Parser_expr(p, 0);
			}
			else if (string__eq(key, _SLIT("len")) || string__eq(key, _SLIT("init"))) {
				v__ast__Expr _t4 = v__ast__NodeError_to_sumtype_v__ast__Expr(ADDR(v__ast__NodeError, (v__parser__Parser_error(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = key}}, {_SLIT("` cannot be initialized for `chan`. Did you mean `cap`?"), 0, { .d_c = 0 }}}))))));
				return _t4;
			}
			else {
				v__ast__Expr _t5 = v__ast__NodeError_to_sumtype_v__ast__Expr(ADDR(v__ast__NodeError, (v__parser__Parser_error(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("wrong field `"), 0xfe10, {.d_s = key}}, {_SLIT("`, expecting `cap`"), 0, { .d_c = 0 }}}))))));
				return _t5;
			};
			last_pos = v__token__Token_position(&p->tok);
			v__parser__Parser_check(p, v__token__Kind__rcbr);
		}
		v__ast__Expr _t6 = v__ast__ChanInit_to_sumtype_v__ast__Expr(ADDR(v__ast__ChanInit, ((v__ast__ChanInit){.pos = v__token__Position_extend(first_pos, last_pos),.cap_expr = cap_expr,.has_cap = has_cap,.typ = chan_type,.elem_type = 0,})));
		return _t6;
	}
	if (p->peek_tok.kind == v__token__Kind__string && !p->inside_str_interp && v__parser__Parser_peek_token(p, 2).kind != v__token__Kind__colon) {
		if ((string__eq(p->tok.lit, _SLIT("r")) || string__eq(p->tok.lit, _SLIT("c")) || string__eq(p->tok.lit, _SLIT("js"))) && p->tok.kind == v__token__Kind__name) {
			v__ast__Expr _t7 = v__parser__Parser_string_expr(p);
			return _t7;
		} else {
			v__ast__Expr _t8 = v__ast__NodeError_to_sumtype_v__ast__Expr(ADDR(v__ast__NodeError, (v__parser__Parser_error(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("only `c`, `r`, `js` are recognized string prefixes, but you tried to use `"), 0xfe10, {.d_s = p->tok.lit}}, {_SLIT("`"), 0, { .d_c = 0 }}}))))));
			return _t8;
		}
	}
	if ((string__eq(p->tok.lit, _SLIT("r")) || string__eq(p->tok.lit, _SLIT("c"))) && p->peek_tok.kind == v__token__Kind__chartoken) {
		string opt = (string__eq(p->tok.lit, _SLIT("r")) ? (_SLIT("`r` (raw string)")) : (_SLIT("`c` (c string)")));
		v__ast__Expr _t9 = v__ast__NodeError_to_sumtype_v__ast__Expr(ADDR(v__ast__NodeError, (v__parser__Parser_error(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot use "), 0xfe10, {.d_s = opt}}, {_SLIT(" with `byte` and `rune`"), 0, { .d_c = 0 }}}))))));
		return _t9;
	}
	bool known_var = (v__token__Kind_is_assign(p->peek_tok.kind) ? (v__ast__Scope_known_var(p->scope, p->tok.lit)) : (v__parser__Parser_mark_var_as_used(p, p->tok.lit)));
	bool is_mod_cast = false;
	if (p->peek_tok.kind == v__token__Kind__dot && !known_var && (language != v__ast__Language__v || v__parser__Parser_known_import(p, p->tok.lit) || string__eq(string_all_after_last(p->mod, _SLIT(".")), p->tok.lit))) {
		if (language == v__ast__Language__c) {
			mod = _SLIT("C");
		} else if (language == v__ast__Language__js) {
			mod = _SLIT("JS");
		} else {
			if (_IN_MAP(ADDR(string, p->tok.lit), ADDR(map, p->imports))) {
				v__parser__Parser_register_used_import(p, p->tok.lit);
				if (p->peek_tok.kind == v__token__Kind__dot && v__parser__Parser_peek_token(p, 2).kind != v__token__Kind__eof && v__parser__Parser_peek_token(p, 2).lit.len > 0 && byte_is_capital(string_at(v__parser__Parser_peek_token(p, 2).lit, 0))) {
					is_mod_cast = true;
				} else if (p->peek_tok.kind == v__token__Kind__dot && v__parser__Parser_peek_token(p, 2).kind != v__token__Kind__eof && v__parser__Parser_peek_token(p, 2).lit.len == 0) {
					v__ast__Ident ident = v__parser__Parser_parse_ident(p, language);
					node = v__ast__Ident_to_sumtype_v__ast__Expr(&ident);
					if (p->inside_defer) {
						bool _t10 = false;
						Array_v__ast__Ident _t10_orig = p->defer_vars;
						int _t10_len = _t10_orig.len;
						for (int _t11 = 0; _t11 < _t10_len; ++_t11) {
							v__ast__Ident it = ((v__ast__Ident*) _t10_orig.data)[_t11];
							if (string__eq(it.name, ident.name) && string__eq(it.mod, ident.mod)) {
								_t10 = true;
								break;
							}
						}
						if (!_t10 && !string__eq(ident.name, _SLIT("err"))) {
							array_push((array*)&p->defer_vars, _MOV((v__ast__Ident[]){ ident }));
						}
					}
					v__ast__Expr _t13 = node;
					return _t13;
				}
			}
			mod = (*(string*)map_get(ADDR(map, p->imports), &(string[]){p->tok.lit}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} }));
		}
		v__parser__Parser_next(p);
		v__parser__Parser_check(p, v__token__Kind__dot);
		p->expr_mod = mod;
	}
	bool lit0_is_capital = (p->tok.kind != v__token__Kind__eof && p->tok.lit.len > 0 ? (byte_is_capital(string_at(p->tok.lit, 0))) : (false));
	bool is_optional = p->tok.kind == v__token__Kind__question;
	bool is_generic_call = v__parser__Parser_is_generic_call(p);
	bool is_generic_cast = v__parser__Parser_is_generic_cast(p);
	bool same_line = p->tok.line_nr == p->peek_tok.line_nr;
	if (!same_line && p->peek_tok.kind == v__token__Kind__lpar) {
		v__ast__Ident ident = v__parser__Parser_parse_ident(p, language);
		node = v__ast__Ident_to_sumtype_v__ast__Expr(&ident);
		if (p->inside_defer) {
			bool _t14 = false;
			Array_v__ast__Ident _t14_orig = p->defer_vars;
			int _t14_len = _t14_orig.len;
			for (int _t15 = 0; _t15 < _t14_len; ++_t15) {
				v__ast__Ident it = ((v__ast__Ident*) _t14_orig.data)[_t15];
				if (string__eq(it.name, ident.name) && string__eq(it.mod, ident.mod)) {
					_t14 = true;
					break;
				}
			}
			if (!_t14 && !string__eq(ident.name, _SLIT("err"))) {
				array_push((array*)&p->defer_vars, _MOV((v__ast__Ident[]){ ident }));
			}
		}
	} else if (p->peek_tok.kind == v__token__Kind__lpar || is_generic_call || is_generic_cast || (is_optional && v__parser__Parser_peek_token(p, 2).kind == v__token__Kind__lpar)) {
		string name = (is_optional ? (p->peek_tok.lit) : (p->tok.lit));
		if (mod.len > 0) {
			name =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = mod}}, {_SLIT("."), 0xfe10, {.d_s = name}}, {_SLIT0, 0, { .d_c = 0 }}}));
		}
		string name_w_mod = v__parser__Parser_prepend_mod(p, name);
		if ((!known_var && (_IN_MAP(ADDR(string, name), ADDR(map, p->table->type_idxs)) || _IN_MAP(ADDR(string, name_w_mod), ADDR(map, p->table->type_idxs))) && !(string__eq(name, _SLIT("C.stat")) || string__eq(name, _SLIT("C.sigaction")))) || is_mod_cast || is_generic_cast || (language == v__ast__Language__v && name.len > 0 && byte_is_capital(string_at(name, 0)))) {
			v__token__Position start_pos = v__token__Token_position(&p->tok);
			v__ast__Type to_typ = v__parser__Parser_parse_type(p);
			p->is_amp = false;
			v__parser__Parser_check(p, v__token__Kind__lpar);
			v__ast__Expr expr = v__ast__empty_expr();
			v__ast__Expr arg = v__ast__empty_expr();
			bool has_arg = false;
			expr = v__parser__Parser_expr(p, 0);
			if (p->tok.kind == v__token__Kind__comma && v__ast__Type_idx(to_typ) == _const_v__ast__string_type_idx) {
				v__parser__Parser_next(p);
				arg = v__parser__Parser_expr(p, 0);
				has_arg = true;
			}
			v__token__Position end_pos = v__token__Token_position(&p->tok);
			v__parser__Parser_check(p, v__token__Kind__rpar);
			node = v__ast__CastExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__CastExpr, ((v__ast__CastExpr){
				.arg = arg,
				.typ = to_typ,
				.expr = expr,
				.typname = v__ast__Table_sym(p->table, to_typ)->name,
				.expr_type = 0,
				.has_arg = has_arg,
				.pos = v__token__Position_extend(start_pos, end_pos),
			})));
			p->expr_mod = _SLIT("");
			v__ast__Expr _t17 = node;
			return _t17;
		} else {
			if (is_optional) {
				v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unexpected "), 0xfe10, {.d_s = v__token__Token_str(p->prev_tok)}}, {_SLIT0, 0, { .d_c = 0 }}})), v__token__Token_position(&p->prev_tok));
			}
			node = v__ast__CallExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__CallExpr, (v__parser__Parser_call_expr(p, language, mod))));
		}
	} else if ((p->peek_tok.kind == v__token__Kind__lcbr || (p->peek_tok.kind == v__token__Kind__lt && lit0_is_capital)) && (!p->inside_match || (p->inside_select && prev_tok_kind == v__token__Kind__arrow && lit0_is_capital)) && !p->inside_match_case && (!p->inside_if || p->inside_select) && (!p->inside_for || p->inside_select) && !known_var) {
		if (p->peek_tok.kind == v__token__Kind__lcbr && !(p->builtin_mod && (string__eq(p->file_base, _SLIT("map.v")) || string__eq(p->file_base, _SLIT("map_d_gcboehm_opt.v")))) && string__eq(p->tok.lit, _SLIT("map"))) {
			v__parser__Parser_check(p, v__token__Kind__name);
			v__parser__Parser_check(p, v__token__Kind__lcbr);
			v__ast__MapInit map_init = v__parser__Parser_map_init(p);
			v__parser__Parser_check(p, v__token__Kind__rcbr);
			v__ast__Expr _t18 = v__ast__MapInit_to_sumtype_v__ast__Expr(&map_init);
			return _t18;
		}
		v__ast__Expr _t19 = v__ast__StructInit_to_sumtype_v__ast__Expr(ADDR(v__ast__StructInit, (v__parser__Parser_struct_init(p, false))));
		return _t19;
	} else if (p->peek_tok.kind == v__token__Kind__lcbr && p->inside_if && lit0_is_capital && !known_var && language == v__ast__Language__v) {
		v__ast__Expr _t20 = v__ast__StructInit_to_sumtype_v__ast__Expr(ADDR(v__ast__StructInit, (v__parser__Parser_struct_init(p, false))));
		return _t20;
	} else if (p->peek_tok.kind == v__token__Kind__dot && (lit0_is_capital && !known_var && language == v__ast__Language__v)) {
		if (v__parser__Parser_is_generic_name(p)) {
			v__token__Position pos = v__token__Token_position(&p->tok);
			string name = v__parser__Parser_check_name(p);
			v__parser__Parser_check(p, v__token__Kind__dot);
			string field = v__parser__Parser_check_name(p);
			v__ast__GenericKindField fkind = ((string__eq(field, _SLIT("name"))) ? (v__ast__GenericKindField__name) : (string__eq(field, _SLIT("typ"))) ? (v__ast__GenericKindField__typ) : (v__ast__GenericKindField__unknown));
			v__token__Position_extend(pos, v__token__Token_position(&p->tok));
			v__ast__Expr _t21 = v__ast__SelectorExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__SelectorExpr, ((v__ast__SelectorExpr){.pos = pos,.field_name = field,.is_mut = 0,.mut_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.next_token = 0,.expr = v__ast__Ident_to_sumtype_v__ast__Expr(ADDR(v__ast__Ident, ((v__ast__Ident){.language = 0,.tok_kind = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.mut_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comptime = 0,.scope = p->scope,.obj = {0},.mod = (string){.str=(byteptr)"", .is_lit=1},.name = name,.kind = 0,.info = {0},.is_mut = 0,}))),.expr_type = 0,.typ = 0,.name_type = 0,.gkind_field = fkind,.scope = p->scope,.from_embed_types = __new_array(0, 0, sizeof(v__ast__Type)),})));
			return _t21;
		}
		string enum_name = v__parser__Parser_check_name(p);
		v__token__Position enum_name_pos = v__token__Token_position(&p->prev_tok);
		if ((mod).len != 0) {
			enum_name = string__plus(string__plus(mod, _SLIT(".")), enum_name);
		} else {
			string* _t23 = (string*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, p->imported_symbols), &(string[]){enum_name}));
			Option_string _t22 = {0};
			if (_t23) {
				*((string*)&_t22.data) = *((string*)_t23);
			} else {
				_t22.state = 2; _t22.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t22.state != 0) { /*or block*/ 
				IError err = _t22.err;
				*(string*) _t22.data = v__parser__Parser_prepend_mod(p, enum_name);
			}
			
			enum_name = *(string*)_t22.data;
		}
		v__parser__Parser_check(p, v__token__Kind__dot);
		string val = v__parser__Parser_check_name(p);
		p->expr_mod = _SLIT("");
		v__ast__Expr _t24 = v__ast__EnumVal_to_sumtype_v__ast__Expr(ADDR(v__ast__EnumVal, ((v__ast__EnumVal){.enum_name = enum_name,.val = val,.mod = mod,.pos = v__token__Position_extend(enum_name_pos, v__token__Token_position(&p->prev_tok)),.typ = 0,})));
		return _t24;
	} else if (language == v__ast__Language__js && p->peek_tok.kind == v__token__Kind__dot && v__parser__Parser_peek_token(p, 2).kind == v__token__Kind__name) {
		node = v__ast__CallExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__CallExpr, (v__parser__Parser_call_expr(p, language, mod))));
	} else {
		if (p->inside_in_array && ((lit0_is_capital && !known_var && language == v__ast__Language__v) || (p->peek_tok.kind == v__token__Kind__dot && v__parser__Parser_peek_token(p, 2).lit.len > 0 && byte_is_capital(string_at(v__parser__Parser_peek_token(p, 2).lit, 0))) || v__ast__Table_find_type_idx(p->table, string__plus(string__plus(p->mod, _SLIT(".")), p->tok.lit)) > 0)) {
			v__token__Position type_pos = v__token__Token_position(&p->tok);
			v__ast__Type typ = v__parser__Parser_parse_type(p);
			v__ast__Expr _t25 = v__ast__TypeNode_to_sumtype_v__ast__Expr(ADDR(v__ast__TypeNode, ((v__ast__TypeNode){.typ = typ,.pos = type_pos,})));
			return _t25;
		}
		v__ast__Ident ident = v__parser__Parser_parse_ident(p, language);
		node = v__ast__Ident_to_sumtype_v__ast__Expr(&ident);
		if (p->inside_defer) {
			bool _t26 = false;
			Array_v__ast__Ident _t26_orig = p->defer_vars;
			int _t26_len = _t26_orig.len;
			for (int _t27 = 0; _t27 < _t26_len; ++_t27) {
				v__ast__Ident it = ((v__ast__Ident*) _t26_orig.data)[_t27];
				if (string__eq(it.name, ident.name) && string__eq(it.mod, ident.mod)) {
					_t26 = true;
					break;
				}
			}
			if (!_t26 && !string__eq(ident.name, _SLIT("err"))) {
				array_push((array*)&p->defer_vars, _MOV((v__ast__Ident[]){ ident }));
			}
		}
	}
	p->expr_mod = _SLIT("");
	v__ast__Expr _t29 = node;
	return _t29;
}

VV_LOCAL_SYMBOL v__ast__IndexExpr v__parser__Parser_index_expr(v__parser__Parser* p, v__ast__Expr left, bool is_gated) {
	v__token__Position start_pos = v__token__Token_position(&p->tok);
	v__parser__Parser_next(p);
	bool has_low = true;
	if (p->tok.kind == v__token__Kind__dotdot) {
		has_low = false;
		v__parser__Parser_next(p);
		v__ast__Expr high = v__ast__empty_expr();
		bool has_high = false;
		if (p->tok.kind != v__token__Kind__rsbr) {
			high = v__parser__Parser_expr(p, 0);
			has_high = true;
		}
		v__token__Position pos = v__token__Position_extend(start_pos, v__token__Token_position(&p->tok));
		v__parser__Parser_check(p, v__token__Kind__rsbr);
		v__ast__IndexExpr _t1 = (v__ast__IndexExpr){.pos = pos,.index = v__ast__RangeExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__RangeExpr, ((v__ast__RangeExpr){.low = v__ast__empty_expr(),.high = high,.has_high = has_high,.has_low = 0,.pos = pos,.is_gated = is_gated,}))),.or_expr = (v__ast__OrExpr){.stmts = __new_array(0, 0, sizeof(v__ast__Stmt)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},},.left = left,.left_type = 0,.is_setter = 0,.is_map = 0,.is_array = 0,.is_farray = 0,.is_option = 0,.is_direct = 0,.is_gated = is_gated,};
		return _t1;
	}
	v__ast__Expr expr = v__parser__Parser_expr(p, 0);
	bool has_high = false;
	if (p->tok.kind == v__token__Kind__dotdot) {
		v__parser__Parser_next(p);
		v__ast__Expr high = v__ast__empty_expr();
		if (p->tok.kind != v__token__Kind__rsbr) {
			has_high = true;
			high = v__parser__Parser_expr(p, 0);
		}
		v__token__Position pos = v__token__Position_extend(start_pos, v__token__Token_position(&p->tok));
		v__parser__Parser_check(p, v__token__Kind__rsbr);
		v__ast__IndexExpr _t2 = (v__ast__IndexExpr){.pos = pos,.index = v__ast__RangeExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__RangeExpr, ((v__ast__RangeExpr){
			.low = expr,
			.high = high,
			.has_high = has_high,
			.has_low = has_low,
			.pos = pos,
			.is_gated = is_gated,
		}))),.or_expr = (v__ast__OrExpr){.stmts = __new_array(0, 0, sizeof(v__ast__Stmt)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},},.left = left,.left_type = 0,.is_setter = 0,.is_map = 0,.is_array = 0,.is_farray = 0,.is_option = 0,.is_direct = 0,.is_gated = is_gated,};
		return _t2;
	}
	v__token__Position pos = v__token__Position_extend(start_pos, v__token__Token_position(&p->tok));
	v__parser__Parser_check(p, v__token__Kind__rsbr);
	v__ast__OrKind or_kind = v__ast__OrKind__absent;
	Array_v__ast__Stmt or_stmts = __new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
	v__token__Position or_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,};
	if (!p->or_is_handled) {
		if (p->tok.kind == v__token__Kind__key_orelse) {
			bool was_inside_or_expr = p->inside_or_expr;
			p->inside_or_expr = true;
			or_pos = v__token__Token_position(&p->tok);
			v__parser__Parser_next(p);
			v__parser__Parser_open_scope(p);
			or_stmts = v__parser__Parser_parse_block_no_scope(p, false);
			or_pos = v__token__Position_extend(or_pos, v__token__Token_position(&p->prev_tok));
			v__parser__Parser_close_scope(p);
			p->inside_or_expr = was_inside_or_expr;
			v__ast__IndexExpr _t3 = (v__ast__IndexExpr){.pos = pos,.index = expr,.or_expr = (v__ast__OrExpr){.stmts = or_stmts,.kind = v__ast__OrKind__block,.pos = or_pos,},.left = left,.left_type = 0,.is_setter = 0,.is_map = 0,.is_array = 0,.is_farray = 0,.is_option = 0,.is_direct = 0,.is_gated = is_gated,};
			return _t3;
		}
		if (p->tok.kind == v__token__Kind__question) {
			or_pos = v__token__Token_position(&p->tok);
			or_kind = v__ast__OrKind__propagate;
			v__parser__Parser_next(p);
		}
	}
	v__ast__IndexExpr _t4 = (v__ast__IndexExpr){.pos = pos,.index = expr,.or_expr = (v__ast__OrExpr){.stmts = or_stmts,.kind = or_kind,.pos = or_pos,},.left = left,.left_type = 0,.is_setter = 0,.is_map = 0,.is_array = 0,.is_farray = 0,.is_option = 0,.is_direct = 0,.is_gated = is_gated,};
	return _t4;
}

VV_LOCAL_SYMBOL void v__parser__Parser_scope_register_it(v__parser__Parser* p) {
	v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){.name = _SLIT("it"),.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.is_auto_deref = 0,.is_inherited = 0,.typ = 0,.orig_type = 0,.smartcasts = __new_array(0, 0, sizeof(v__ast__Type)),.pos = v__token__Token_position(&p->tok),.is_used = true,.is_changed = 0,.is_or = 0,.is_tmp = 0,.is_auto_heap = 0,.is_stack_obj = 0,}))));
}

VV_LOCAL_SYMBOL void v__parser__Parser_scope_register_ab(v__parser__Parser* p) {
	v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){.name = _SLIT("a"),.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.is_auto_deref = 0,.is_inherited = 0,.typ = 0,.orig_type = 0,.smartcasts = __new_array(0, 0, sizeof(v__ast__Type)),.pos = v__token__Token_position(&p->tok),.is_used = true,.is_changed = 0,.is_or = 0,.is_tmp = 0,.is_auto_heap = 0,.is_stack_obj = 0,}))));
	v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){.name = _SLIT("b"),.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.is_auto_deref = 0,.is_inherited = 0,.typ = 0,.orig_type = 0,.smartcasts = __new_array(0, 0, sizeof(v__ast__Type)),.pos = v__token__Token_position(&p->tok),.is_used = true,.is_changed = 0,.is_or = 0,.is_tmp = 0,.is_auto_heap = 0,.is_stack_obj = 0,}))));
}

VV_LOCAL_SYMBOL v__ast__Expr v__parser__Parser_dot_expr(v__parser__Parser* p, v__ast__Expr left) {
	v__parser__Parser_next(p);
	if (p->tok.kind == v__token__Kind__dollar) {
		v__ast__Expr _t1 = v__parser__Parser_comptime_selector(p, left);
		return _t1;
	}
	bool is_generic_call = v__parser__Parser_is_generic_call(p);
	v__token__Position name_pos = v__token__Token_position(&p->tok);
	string field_name = _SLIT("");
	if ((v__token__Token_position(&p->prev_tok).line_nr == name_pos.line_nr) || p->tok.kind != v__token__Kind__name) {
		field_name = v__parser__Parser_check_name(p);
	} else {
		p->name_error = true;
	}
	bool is_filter = (string__eq(field_name, _SLIT("filter")) || string__eq(field_name, _SLIT("map")) || string__eq(field_name, _SLIT("any")) || string__eq(field_name, _SLIT("all")));
	if (is_filter || string__eq(field_name, _SLIT("sort"))) {
		v__parser__Parser_open_scope(p);
	}
	if (p->tok.kind == v__token__Kind__not && p->peek_tok.kind == v__token__Kind__lpar) {
		v__parser__Parser_next(p);
	}
	Array_v__ast__Type concrete_types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
	v__token__Position concrete_list_pos = v__token__Token_position(&p->tok);
	if (is_generic_call) {
		concrete_types = v__parser__Parser_parse_concrete_types(p);
		concrete_list_pos = v__token__Position_extend(concrete_list_pos, v__token__Token_position(&p->prev_tok));
		bool _t2 = false;
		Array_v__ast__Type _t2_orig = concrete_types;
		int _t2_len = _t2_orig.len;
		for (int _t3 = 0; _t3 < _t2_len; ++_t3) {
			v__ast__Type it = ((v__ast__Type*) _t2_orig.data)[_t3];
			if (v__ast__Type_has_flag(it, v__ast__TypeFlag__generic)) {
				_t2 = true;
				break;
			}
		}
		bool has_generic =_t2;
		if (!has_generic) {
			v__ast__Table_register_fn_concrete_types(p->table, field_name, concrete_types);
		}
	}
	if (p->tok.kind == v__token__Kind__lpar) {
		v__parser__Parser_next(p);
		Array_v__ast__CallArg args = v__parser__Parser_call_args(p);
		v__parser__Parser_check(p, v__token__Kind__rpar);
		Array_v__ast__Stmt or_stmts = __new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
		v__ast__OrKind or_kind = v__ast__OrKind__absent;
		v__token__Position or_pos = v__token__Token_position(&p->tok);
		if (p->tok.kind == v__token__Kind__key_orelse) {
			bool was_inside_or_expr = p->inside_or_expr;
			p->inside_or_expr = true;
			v__parser__Parser_next(p);
			v__parser__Parser_open_scope(p);
			v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){.name = _SLIT("err"),.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.is_auto_deref = 0,.is_inherited = 0,.typ = _const_v__ast__error_type,.orig_type = 0,.smartcasts = __new_array(0, 0, sizeof(v__ast__Type)),.pos = v__token__Token_position(&p->tok),.is_used = true,.is_changed = 0,.is_or = 0,.is_tmp = 0,.is_auto_heap = 0,.is_stack_obj = true,}))));
			or_kind = v__ast__OrKind__block;
			or_stmts = v__parser__Parser_parse_block_no_scope(p, false);
			or_pos = v__token__Position_extend(or_pos, v__token__Token_position(&p->prev_tok));
			v__parser__Parser_close_scope(p);
			p->inside_or_expr = was_inside_or_expr;
		}
		if (p->tok.kind == v__token__Kind__question) {
			v__parser__Parser_next(p);
			or_kind = v__ast__OrKind__propagate;
		}
		v__token__Position end_pos = v__token__Token_position(&p->prev_tok);
		v__token__Position pos = v__token__Position_extend(name_pos, end_pos);
		Array_v__ast__Comment comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = true,.follow_up = 0,});
		v__ast__CallExpr mcall_expr = (v__ast__CallExpr){
			.pos = pos,
			.name_pos = name_pos,
			.mod = (string){.str=(byteptr)"", .is_lit=1},
			.name = field_name,
			.is_method = true,
			.is_field = 0,
			.is_keep_alive = 0,
			.is_noreturn = 0,
			.is_ctor_new = 0,
			.args = args,
			.expected_arg_types = __new_array(0, 0, sizeof(v__ast__Type)),
			.language = 0,
			.or_block = (v__ast__OrExpr){.stmts = or_stmts,.kind = or_kind,.pos = or_pos,},
			.left = left,
			.left_type = 0,
			.receiver_type = 0,
			.return_type = 0,
			.should_be_skipped = 0,
			.concrete_types = concrete_types,
			.concrete_list_pos = concrete_list_pos,
			.free_receiver = 0,
			.scope = p->scope,
			.from_embed_types = __new_array(0, 0, sizeof(v__ast__Type)),
			.comments = comments,
		};
		if (is_filter || string__eq(field_name, _SLIT("sort"))) {
			v__parser__Parser_close_scope(p);
		}
		v__ast__Expr _t4 = v__ast__CallExpr_to_sumtype_v__ast__Expr(&mcall_expr);
		return _t4;
	}
	bool is_mut = false;
	v__token__Position mut_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,};
	if (p->inside_match || p->inside_if_expr) {
		if (left._typ == 299 /* v.ast.Ident */) {
			is_mut = (*left._v__ast__Ident).is_mut;
			mut_pos = (*left._v__ast__Ident).mut_pos;
		}
		else if (left._typ == 319 /* v.ast.SelectorExpr */) {
			is_mut = (*left._v__ast__SelectorExpr).is_mut;
			mut_pos = (*left._v__ast__SelectorExpr).mut_pos;
		}
		
		else {
		}
		;
	}
	v__token__Position pos = (p->name_error ? (v__token__Position_extend(v__ast__Expr_position(left), name_pos)) : (name_pos));
	v__ast__SelectorExpr sel_expr = (v__ast__SelectorExpr){
		.pos = pos,
		.field_name = field_name,
		.is_mut = is_mut,
		.mut_pos = mut_pos,
		.next_token = p->tok.kind,
		.expr = left,
		.expr_type = 0,
		.typ = 0,
		.name_type = 0,
		.gkind_field = 0,
		.scope = p->scope,
		.from_embed_types = __new_array(0, 0, sizeof(v__ast__Type)),
	};
	if (is_filter) {
		v__parser__Parser_close_scope(p);
	}
	v__ast__Expr _t5 = v__ast__SelectorExpr_to_sumtype_v__ast__Expr(&sel_expr);
	return _t5;
}

VV_LOCAL_SYMBOL multi_return_Array_v__ast__Type_Array_string v__parser__Parser_parse_generic_types(v__parser__Parser* p) {
	Array_v__ast__Type types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
	Array_string param_names = __new_array_with_default(0, 0, sizeof(string), 0);
	if (p->tok.kind != v__token__Kind__lt) {
		return (multi_return_Array_v__ast__Type_Array_string){.arg0=types, .arg1=param_names};
	}
	v__parser__Parser_check(p, v__token__Kind__lt);
	bool first_done = false;
	int count = 0;
	for (;;) {
		if (!(!(p->tok.kind == v__token__Kind__gt || p->tok.kind == v__token__Kind__eof))) break;
		if (first_done) {
			v__parser__Parser_check(p, v__token__Kind__comma);
		}
		string name = p->tok.lit;
		if (name.len > 0 && !byte_is_capital(string_at(name, 0))) {
			v__parser__Parser_error(p, _SLIT("generic parameter needs to be uppercase"));
		}
		if (name.len > 1) {
			v__parser__Parser_error(p, _SLIT("generic parameter name needs to be exactly one char"));
		}
		if (!v__util__is_generic_type_name(p->tok.lit)) {
			v__parser__Parser_error(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = p->tok.lit}}, {_SLIT("` is a reserved name and cannot be used for generics"), 0, { .d_c = 0 }}})));
		}
		if (Array_string_contains(param_names, name)) {
			v__parser__Parser_error(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("duplicated generic parameter `"), 0xfe10, {.d_s = name}}, {_SLIT("`"), 0, { .d_c = 0 }}})));
		}
		if (count > 8) {
			v__parser__Parser_error(p, _SLIT("cannot have more than 9 generic parameters"));
		}
		v__parser__Parser_check(p, v__token__Kind__name);
		array_push((array*)&param_names, _MOV((string[]){ string_clone(name) }));
		int idx = v__ast__Table_find_type_idx(p->table, name);
		if (idx == 0) {
			idx = v__ast__Table_register_type_symbol(p->table, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind__any,.name = name,.cname = v__util__no_dots(name),.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.mod = p->mod,.is_public = true,.language = 0,.idx = 0,});
		}
		array_push((array*)&types, _MOV((v__ast__Type[]){ v__ast__Type_set_flag(v__ast__new_type(idx), v__ast__TypeFlag__generic) }));
		first_done = true;
		count++;
	}
	v__parser__Parser_check(p, v__token__Kind__gt);
	return (multi_return_Array_v__ast__Type_Array_string){.arg0=types, .arg1=param_names};
}

VV_LOCAL_SYMBOL Array_v__ast__Type v__parser__Parser_parse_concrete_types(v__parser__Parser* p) {
	Array_v__ast__Type types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
	if (p->tok.kind != v__token__Kind__lt) {
		Array_v__ast__Type _t1 = types;
		return _t1;
	}
	v__parser__Parser_next(p);
	bool first_done = false;
	for (;;) {
		if (!(!(p->tok.kind == v__token__Kind__eof || p->tok.kind == v__token__Kind__gt))) break;
		if (first_done) {
			v__parser__Parser_check(p, v__token__Kind__comma);
		}
		array_push((array*)&types, _MOV((v__ast__Type[]){ v__parser__Parser_parse_type(p) }));
		first_done = true;
	}
	v__parser__Parser_check(p, v__token__Kind__gt);
	Array_v__ast__Type _t3 = types;
	return _t3;
}

VV_LOCAL_SYMBOL bool v__parser__Parser_is_generic_name(v__parser__Parser* p) {
	bool _t1 = p->tok.kind == v__token__Kind__name && v__util__is_generic_type_name(p->tok.lit);
	return _t1;
}

VV_LOCAL_SYMBOL v__ast__EnumVal v__parser__Parser_enum_val(v__parser__Parser* p) {
	v__token__Position start_pos = v__token__Token_position(&p->tok);
	v__parser__Parser_check(p, v__token__Kind__dot);
	string val = v__parser__Parser_check_name(p);
	v__ast__EnumVal _t1 = (v__ast__EnumVal){.enum_name = (string){.str=(byteptr)"", .is_lit=1},.val = val,.mod = (string){.str=(byteptr)"", .is_lit=1},.pos = v__token__Position_extend(start_pos, v__token__Token_position(&p->prev_tok)),.typ = 0,};
	return _t1;
}

VV_LOCAL_SYMBOL void v__parser__Parser_filter_string_vet_errors(v__parser__Parser* p, v__token__Position pos) {
	if (p->vet_errors.len == 0) {
		return;
	}
	Array_v__vet__Error _t1 = __new_array(0, 0, sizeof(v__vet__Error));
	Array_v__vet__Error _t1_orig = p->vet_errors;
	int _t1_len = _t1_orig.len;
	_t1 = __new_array(0, _t1_len, sizeof(v__vet__Error));

	for (int _t2 = 0; _t2 < _t1_len; ++_t2) {
		v__vet__Error it = ((v__vet__Error*) _t1_orig.data)[_t2];
		if ((it.typ == v__vet__ErrorType__trailing_space && it.pos.line_nr - 1 >= pos.last_line) || (it.typ != v__vet__ErrorType__trailing_space && it.pos.line_nr - 1 > pos.last_line) || (it.typ == v__vet__ErrorType__space_indent && it.pos.line_nr - 1 <= pos.line_nr) || (it.typ != v__vet__ErrorType__space_indent && it.pos.line_nr - 1 < pos.line_nr)) {
			array_push((array*)&_t1, &it);
		}
	}
	p->vet_errors =_t1;
}

VV_LOCAL_SYMBOL v__ast__Expr v__parser__Parser_string_expr(v__parser__Parser* p) {
	bool is_raw = p->tok.kind == v__token__Kind__name && string__eq(p->tok.lit, _SLIT("r"));
	bool is_cstr = p->tok.kind == v__token__Kind__name && string__eq(p->tok.lit, _SLIT("c"));
	if (is_raw || is_cstr) {
		v__parser__Parser_next(p);
	}
	v__ast__Expr node = v__ast__empty_expr();
	string val = p->tok.lit;
	v__token__Position pos = v__token__Token_position(&p->tok);
	pos.last_line = pos.line_nr + string_count(val, _SLIT("\n"));
	if (p->peek_tok.kind != v__token__Kind__str_dollar) {
		v__parser__Parser_next(p);
		v__parser__Parser_filter_string_vet_errors(p, pos);
		node = v__ast__StringLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__StringLiteral, ((v__ast__StringLiteral){.val = val,.is_raw = is_raw,.language = (is_cstr ? (v__ast__Language__c) : (v__ast__Language__v)),.pos = pos,})));
		v__ast__Expr _t1 = node;
		return _t1;
	}
	Array_v__ast__Expr exprs = __new_array_with_default(0, 0, sizeof(v__ast__Expr), 0);
	Array_string vals = __new_array_with_default(0, 0, sizeof(string), 0);
	Array_bool has_fmts = __new_array_with_default(0, 0, sizeof(bool), 0);
	Array_int fwidths = __new_array_with_default(0, 0, sizeof(int), 0);
	Array_int precisions = __new_array_with_default(0, 0, sizeof(int), 0);
	Array_bool visible_pluss = __new_array_with_default(0, 0, sizeof(bool), 0);
	Array_bool fills = __new_array_with_default(0, 0, sizeof(bool), 0);
	Array_byte fmts = __new_array_with_default(0, 0, sizeof(byte), 0);
	Array_v__token__Position fposs = __new_array_with_default(0, 0, sizeof(v__token__Position), 0);
	p->inside_str_interp = true;
	for (;;) {
		if (!(p->tok.kind == v__token__Kind__string)) break;
		array_push((array*)&vals, _MOV((string[]){ string_clone(p->tok.lit) }));
		v__parser__Parser_next(p);
		if (p->tok.kind != v__token__Kind__str_dollar) {
			break;
		}
		v__parser__Parser_next(p);
		array_push((array*)&exprs, _MOV((v__ast__Expr[]){ v__parser__Parser_expr(p, 0) }));
		bool has_fmt = false;
		int fwidth = 0;
		bool fwidthneg = false;
		int precision = 987698;
		bool visible_plus = false;
		bool fill = false;
		rune fmt = '_';
		if (p->tok.kind == v__token__Kind__colon) {
			v__parser__Parser_next(p);
			if (p->tok.kind == v__token__Kind__minus) {
				fwidthneg = true;
				v__parser__Parser_next(p);
			} else if (p->tok.kind == v__token__Kind__plus) {
				visible_plus = true;
				v__parser__Parser_next(p);
			}
			if (p->tok.kind == v__token__Kind__number) {
				Array_string fields = string_split(p->tok.lit, _SLIT("."));
				if ((*(string*)/*ee elem_typ */array_get(fields, 0)).len > 0 && string_at((*(string*)/*ee elem_typ */array_get(fields, 0)), 0) == '0') {
					fill = true;
				}
				fwidth = string_int((*(string*)/*ee elem_typ */array_get(fields, 0)));
				if (fwidthneg) {
					fwidth = -fwidth;
				}
				if (fields.len > 1) {
					precision = string_int((*(string*)/*ee elem_typ */array_get(fields, 1)));
				}
				v__parser__Parser_next(p);
			}
			if (p->tok.kind == v__token__Kind__name) {
				if (p->tok.lit.len == 1) {
					fmt = string_at(p->tok.lit, 0);
					has_fmt = true;
					v__parser__Parser_next(p);
				} else {
					v__ast__Expr _t4 = v__ast__NodeError_to_sumtype_v__ast__Expr(ADDR(v__ast__NodeError, (v__parser__Parser_error(p, _SLIT("format specifier may only be one letter")))));
					return _t4;
				}
			}
		}
		array_push((array*)&fwidths, _MOV((int[]){ fwidth }));
		array_push((array*)&has_fmts, _MOV((bool[]){ has_fmt }));
		array_push((array*)&precisions, _MOV((int[]){ precision }));
		array_push((array*)&visible_pluss, _MOV((bool[]){ visible_plus }));
		array_push((array*)&fmts, _MOV((byte[]){ fmt }));
		array_push((array*)&fills, _MOV((bool[]){ fill }));
		array_push((array*)&fposs, _MOV((v__token__Position[]){ v__token__Token_position(&p->prev_tok) }));
	}
	pos = v__token__Position_extend(pos, v__token__Token_position(&p->prev_tok));
	v__parser__Parser_filter_string_vet_errors(p, pos);
	node = v__ast__StringInterLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__StringInterLiteral, ((v__ast__StringInterLiteral){
		.vals = vals,
		.exprs = exprs,
		.fwidths = fwidths,
		.precisions = precisions,
		.pluss = visible_pluss,
		.fills = fills,
		.fmt_poss = fposs,
		.pos = pos,
		.expr_types = __new_array(0, 0, sizeof(v__ast__Type)),
		.fmts = fmts,
		.need_fmts = has_fmts,
	})));
	p->inside_str_interp = false;
	v__ast__Expr _t12 = node;
	return _t12;
}

VV_LOCAL_SYMBOL v__ast__Expr v__parser__Parser_parse_number_literal(v__parser__Parser* p) {
	v__token__Position pos = v__token__Token_position(&p->tok);
	bool is_neg = p->tok.kind == v__token__Kind__minus;
	if (is_neg) {
		v__parser__Parser_next(p);
		pos = v__token__Position_extend(pos, v__token__Token_position(&p->tok));
	}
	string lit = p->tok.lit;
	string full_lit = (is_neg ? (string__plus(_SLIT("-"), lit)) : (lit));
	v__ast__Expr node = v__ast__empty_expr();
	if (string_index_any(lit, _SLIT(".eE")) >= 0 && !(string__eq(string_substr(lit, 0, 2), _SLIT("0x")) || string__eq(string_substr(lit, 0, 2), _SLIT("0X")) || string__eq(string_substr(lit, 0, 2), _SLIT("0o")) || string__eq(string_substr(lit, 0, 2), _SLIT("0O")) || string__eq(string_substr(lit, 0, 2), _SLIT("0b")) || string__eq(string_substr(lit, 0, 2), _SLIT("0B")))) {
		node = v__ast__FloatLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__FloatLiteral, ((v__ast__FloatLiteral){.val = full_lit,.pos = pos,})));
	} else {
		node = v__ast__IntegerLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__IntegerLiteral, ((v__ast__IntegerLiteral){.val = full_lit,.pos = pos,})));
	}
	v__parser__Parser_next(p);
	v__ast__Expr _t1 = node;
	return _t1;
}

VV_LOCAL_SYMBOL v__ast__Module v__parser__Parser_module_decl(v__parser__Parser* p) {
	Array_v__ast__Attr module_attrs = __new_array_with_default(0, 0, sizeof(v__ast__Attr), 0);
	v__token__Position attrs_pos = v__token__Token_position(&p->tok);
	if (p->tok.kind == v__token__Kind__lsbr) {
		v__parser__Parser_attributes(p);
		module_attrs = p->attrs;
	}
	string name = _SLIT("main");
	bool is_skipped = p->tok.kind != v__token__Kind__key_module;
	v__token__Position module_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,};
	v__token__Position name_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,};
	v__ast__Module mod_node = (v__ast__Module){.name = (string){.str=(byteptr)"", .is_lit=1},.short_name = (string){.str=(byteptr)"", .is_lit=1},.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.name_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.is_skipped = 0,};
	if (!is_skipped) {
		p->attrs = __new_array_with_default(0, 0, sizeof(v__ast__Attr), 0);
		module_pos = v__token__Token_position(&p->tok);
		v__parser__Parser_next(p);
		name_pos = v__token__Token_position(&p->tok);
		name = v__parser__Parser_check_name(p);
		mod_node = (v__ast__Module){.name = (string){.str=(byteptr)"", .is_lit=1},.short_name = (string){.str=(byteptr)"", .is_lit=1},.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.pos = module_pos,.name_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.is_skipped = 0,};
		if (module_pos.line_nr != name_pos.line_nr) {
			v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("`module` and `"), 0xfe10, {.d_s = name}}, {_SLIT("` must be at same line"), 0, { .d_c = 0 }}})), name_pos);
			v__ast__Module _t1 = mod_node;
			return _t1;
		}
		v__token__Position n_pos = v__token__Token_position(&p->tok);
		if (module_pos.line_nr == n_pos.line_nr && p->tok.kind != v__token__Kind__comment && p->tok.kind != v__token__Kind__eof) {
			if (p->tok.kind == v__token__Kind__name) {
				v__parser__Parser_error_with_pos(p,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("`module "), 0xfe10, {.d_s = name}}, {_SLIT("`, you can only declare one module, unexpected `"), 0xfe10, {.d_s = p->tok.lit}}, {_SLIT("`"), 0, { .d_c = 0 }}})), n_pos);
				v__ast__Module _t2 = mod_node;
				return _t2;
			} else {
				v__parser__Parser_error_with_pos(p,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("`module "), 0xfe10, {.d_s = name}}, {_SLIT("`, unexpected `"), 0xfe10, {.d_s = v__token__Kind_str(p->tok.kind)}}, {_SLIT("` after module name"), 0, { .d_c = 0 }}})), n_pos);
				v__ast__Module _t3 = mod_node;
				return _t3;
			}
		}
		module_pos = v__token__Position_extend(attrs_pos, name_pos);
	}
	string full_name = v__util__qualify_module(p->pref, name, p->file_name);
	p->mod = full_name;
	p->builtin_mod = string__eq(p->mod, _SLIT("builtin"));
	mod_node = (v__ast__Module){
		.name = full_name,
		.short_name = name,
		.attrs = module_attrs,
		.pos = module_pos,
		.name_pos = name_pos,
		.is_skipped = is_skipped,
	};
	if (!is_skipped) {
		for (int _t4 = 0; _t4 < module_attrs.len; ++_t4) {
			v__ast__Attr ma = ((v__ast__Attr*)module_attrs.data)[_t4];

			if (string__eq(ma.name, _SLIT("manualfree"))) {
				p->is_manualfree = true;
			}
			else if (string__eq(ma.name, _SLIT("generated"))) {
				p->is_generated = true;
			}
			else if (string__eq(ma.name, _SLIT("has_globals"))) {
				if (p->inside_vlib_file) {
					p->has_globals = true;
				} else {
					v__parser__Parser_error_with_pos(p, _SLIT("[has_globals] is allowed only in .v files of `vlib` modules"), ma.pos);
				}
			}
			else {
				v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unknown module attribute `["), 0xfe10, {.d_s = ma.name}}, {_SLIT("]`"), 0, { .d_c = 0 }}})), ma.pos);
				v__ast__Module _t5 = mod_node;
				return _t5;
			};
		}
	}
	v__ast__Module _t6 = mod_node;
	return _t6;
}

VV_LOCAL_SYMBOL v__ast__Import v__parser__Parser_import_stmt(v__parser__Parser* p) {
	v__token__Position import_pos = v__token__Token_position(&p->tok);
	v__parser__Parser_check(p, v__token__Kind__key_import);
	v__token__Position pos = v__token__Token_position(&p->tok);
	v__ast__Import import_node = (v__ast__Import){.mod = (string){.str=(byteptr)"", .is_lit=1},.alias = (string){.str=(byteptr)"", .is_lit=1},.pos = v__token__Position_extend(import_pos, pos),.mod_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.alias_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.syms_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.syms = __new_array(0, 0, sizeof(v__ast__ImportSymbol)),.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.next_comments = __new_array(0, 0, sizeof(v__ast__Comment)),};
	if (p->tok.kind == v__token__Kind__lpar) {
		v__parser__Parser_error_with_pos(p, _SLIT("`import()` has been deprecated, use `import x` instead"), pos);
		v__ast__Import _t1 = import_node;
		return _t1;
	}
	Array_string mod_name_arr = __new_array_with_default(0, 0, sizeof(string), 0);
	array_push((array*)&mod_name_arr, _MOV((string[]){ string_clone(v__parser__Parser_check_name(p)) }));
	if (import_pos.line_nr != pos.line_nr) {
		v__parser__Parser_error_with_pos(p, _SLIT("`import` statements must be a single line"), pos);
		v__ast__Import _t3 = import_node;
		return _t3;
	}
	string mod_alias = (*(string*)/*ee elem_typ */array_get(mod_name_arr, 0));
	import_node = (v__ast__Import){.mod = (string){.str=(byteptr)"", .is_lit=1},.alias = (string){.str=(byteptr)"", .is_lit=1},.pos = v__token__Position_extend(import_pos, pos),.mod_pos = pos,.alias_pos = pos,.syms_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.syms = __new_array(0, 0, sizeof(v__ast__ImportSymbol)),.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.next_comments = __new_array(0, 0, sizeof(v__ast__Comment)),};
	for (;;) {
		if (!(p->tok.kind == v__token__Kind__dot)) break;
		v__parser__Parser_next(p);
		v__token__Position submod_pos = v__token__Token_position(&p->tok);
		if (p->tok.kind != v__token__Kind__name) {
			v__parser__Parser_error_with_pos(p, _SLIT("module syntax error, please use `x.y.z`"), submod_pos);
			v__ast__Import _t4 = import_node;
			return _t4;
		}
		if (import_pos.line_nr != submod_pos.line_nr) {
			v__parser__Parser_error_with_pos(p, _SLIT("`import` and `submodule` must be at same line"), submod_pos);
			v__ast__Import _t5 = import_node;
			return _t5;
		}
		string submod_name = v__parser__Parser_check_name(p);
		array_push((array*)&mod_name_arr, _MOV((string[]){ string_clone(submod_name) }));
		mod_alias = submod_name;
		pos = v__token__Position_extend(pos, submod_pos);
		import_node = (v__ast__Import){.mod = v__util__qualify_import(p->pref, Array_string_join(mod_name_arr, _SLIT(".")), p->file_name),.alias = mod_alias,.pos = v__token__Position_extend(import_pos, pos),.mod_pos = pos,.alias_pos = submod_pos,.syms_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.syms = __new_array(0, 0, sizeof(v__ast__ImportSymbol)),.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.next_comments = __new_array(0, 0, sizeof(v__ast__Comment)),};
	}
	if (mod_name_arr.len == 1) {
		import_node = (v__ast__Import){.mod = v__util__qualify_import(p->pref, (*(string*)/*ee elem_typ */array_get(mod_name_arr, 0)), p->file_name),.alias = mod_alias,.pos = import_node.pos,.mod_pos = import_node.mod_pos,.alias_pos = import_node.alias_pos,.syms_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.syms = __new_array(0, 0, sizeof(v__ast__ImportSymbol)),.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.next_comments = __new_array(0, 0, sizeof(v__ast__Comment)),};
	}
	string mod_name = import_node.mod;
	if (p->tok.kind == v__token__Kind__key_as) {
		v__parser__Parser_next(p);
		v__token__Position alias_pos = v__token__Token_position(&p->tok);
		mod_alias = v__parser__Parser_check_name(p);
		if (string__eq(mod_alias, (*(string*)array_last(mod_name_arr)))) {
			v__parser__Parser_error_with_pos(p,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("import alias `"), 0xfe10, {.d_s = mod_name}}, {_SLIT(" as "), 0xfe10, {.d_s = mod_alias}}, {_SLIT("` is redundant"), 0, { .d_c = 0 }}})), v__token__Token_position(&p->prev_tok));
			v__ast__Import _t7 = import_node;
			return _t7;
		}
		import_node = (v__ast__Import){.mod = import_node.mod,.alias = mod_alias,.pos = v__token__Position_extend(import_node.pos, alias_pos),.mod_pos = import_node.mod_pos,.alias_pos = alias_pos,.syms_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.syms = __new_array(0, 0, sizeof(v__ast__ImportSymbol)),.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.next_comments = __new_array(0, 0, sizeof(v__ast__Comment)),};
	}
	if (p->tok.kind == v__token__Kind__lcbr) {
		v__token__Position initial_syms_pos = v__token__Token_position(&p->tok);
		v__parser__Parser_import_syms(p, (voidptr)&/*qq*/import_node);
		initial_syms_pos = v__token__Position_extend(initial_syms_pos, v__token__Token_position(&p->tok));
		import_node = (v__ast__Import){import_node.mod,import_node.alias,.pos = v__token__Position_extend(import_node.pos, initial_syms_pos),import_node.mod_pos,import_node.alias_pos,.syms_pos = initial_syms_pos,import_node.syms,import_node.comments,import_node.next_comments,};
		v__parser__Parser_register_used_import(p, mod_alias);
	}
	v__token__Position pos_t = v__token__Token_position(&p->tok);
	if (import_pos.line_nr == pos_t.line_nr) {
		if (!(p->tok.kind == v__token__Kind__lcbr || p->tok.kind == v__token__Kind__eof || p->tok.kind == v__token__Kind__comment)) {
			v__parser__Parser_error_with_pos(p, _SLIT("cannot import multiple modules at a time"), pos_t);
			v__ast__Import _t8 = import_node;
			return _t8;
		}
	}
	import_node.comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = true,.follow_up = 0,});
	import_node.next_comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = true,});
	map_set(&p->imports, &(string[]){mod_alias}, &(string[]) { mod_name });
	array_push((array*)&p->table->imports, _MOV((string[]){ string_clone(mod_name) }));
	array_push((array*)&p->ast_imports, _MOV((v__ast__Import[]){ import_node }));
	v__ast__Import _t11 = import_node;
	return _t11;
}

VV_LOCAL_SYMBOL void v__parser__Parser_import_syms(v__parser__Parser* p, v__ast__Import* parent) {
	v__parser__Parser_next(p);
	v__token__Position pos_t = v__token__Token_position(&p->tok);
	if (p->tok.kind == v__token__Kind__rcbr) {
		v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("empty `"), 0xfe10, {.d_s = parent->mod}}, {_SLIT("` import set, remove `{}`"), 0, { .d_c = 0 }}})), pos_t);
		return;
	}
	if (p->tok.kind != v__token__Kind__name) {
		v__parser__Parser_error_with_pos(p, _SLIT("import syntax error, please specify a valid fn or type name"), pos_t);
		return;
	}
	for (;;) {
		if (!(p->tok.kind == v__token__Kind__name)) break;
		v__token__Position pos = v__token__Token_position(&p->tok);
		string alias = v__parser__Parser_check_name(p);
		map_set(&p->imported_symbols, &(string[]){alias}, &(string[]) { string__plus(string__plus(parent->mod, _SLIT(".")), alias) });
		array_push((array*)&parent->syms, _MOV((v__ast__ImportSymbol[]){ (v__ast__ImportSymbol){.pos = pos,.name = alias,} }));
		if (p->tok.kind == v__token__Kind__comma) {
			v__parser__Parser_next(p);
			continue;
		}
		if (p->tok.kind == v__token__Kind__rcbr) {
			break;
		}
	}
	if (p->tok.kind != v__token__Kind__rcbr) {
		v__parser__Parser_error_with_pos(p, _SLIT("import syntax error, no closing `}`"), v__token__Token_position(&p->tok));
		return;
	}
	v__parser__Parser_next(p);
}

VV_LOCAL_SYMBOL v__ast__ConstDecl v__parser__Parser_const_decl(v__parser__Parser* p) {
	v__parser__Parser_top_level_statement_start(p);
	Array_v__ast__Attr attrs = __new_array_with_default(0, 0, sizeof(v__ast__Attr), 0);
	if (p->attrs.len > 0) {
		attrs = p->attrs;
		p->attrs = __new_array_with_default(0, 0, sizeof(v__ast__Attr), 0);
	}
	bool is_markused = false;
	for (int _t1 = 0; _t1 < attrs.len; ++_t1) {
		v__ast__Attr ga = ((v__ast__Attr*)attrs.data)[_t1];

		if (string__eq(ga.name, _SLIT("markused"))) {
			is_markused = true;
		}
		else {
		};
	}
	v__token__Position start_pos = v__token__Token_position(&p->tok);
	bool is_pub = p->tok.kind == v__token__Kind__key_pub;
	if (is_pub) {
		v__parser__Parser_next(p);
	}
	v__token__Position const_pos = v__token__Token_position(&p->tok);
	v__parser__Parser_check(p, v__token__Kind__key_const);
	bool is_block = p->tok.kind == v__token__Kind__lpar;
	if (is_block) {
		v__parser__Parser_next(p);
	}
	Array_v__ast__ConstField fields = __new_array_with_default(0, 0, sizeof(v__ast__ConstField), 0);
	Array_v__ast__Comment comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	for (;;) {
		comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,});
		if (is_block && p->tok.kind == v__token__Kind__eof) {
			v__parser__Parser_error(p, _SLIT("unexpected eof, expecting ´)´"));
			v__ast__ConstDecl _t2 = (v__ast__ConstDecl){.is_pub = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.fields = __new_array(0, 0, sizeof(v__ast__ConstField)),.end_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.is_block = 0,};
			return _t2;
		}
		if (p->tok.kind == v__token__Kind__rpar) {
			break;
		}
		v__token__Position pos = v__token__Token_position(&p->tok);
		string name = v__parser__Parser_check_name(p);
		if (v__util__contains_capital(name)) {
			v__parser__Parser_warn_with_pos(p, _SLIT("const names cannot contain uppercase letters, use snake_case instead"), pos);
		}
		string full_name = v__parser__Parser_prepend_mod(p, name);
		v__parser__Parser_check(p, v__token__Kind__assign);
		if (p->tok.kind == v__token__Kind__key_fn) {
			v__parser__Parser_error(p, _SLIT("const initializer fn literal is not a constant"));
			v__ast__ConstDecl _t3 = (v__ast__ConstDecl){.is_pub = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.fields = __new_array(0, 0, sizeof(v__ast__ConstField)),.end_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.is_block = 0,};
			return _t3;
		}
		if (p->tok.kind == v__token__Kind__eof) {
			v__parser__Parser_error(p, _SLIT("unexpected eof, expecting an expression"));
			v__ast__ConstDecl _t4 = (v__ast__ConstDecl){.is_pub = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.fields = __new_array(0, 0, sizeof(v__ast__ConstField)),.end_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.is_block = 0,};
			return _t4;
		}
		v__ast__Expr expr = v__parser__Parser_expr(p, 0);
		v__ast__ConstField field = (v__ast__ConstField){
			.mod = p->mod,
			.name = full_name,
			.expr = expr,
			.is_pub = is_pub,
			.is_markused = is_markused,
			.pos = v__token__Position_extend(pos, v__ast__Expr_position(expr)),
			.typ = 0,
			.comments = comments,
			.comptime_expr_value = v__ast__empty_comptime_const_expr(),
		};
		array_push((array*)&fields, _MOV((v__ast__ConstField[]){ field }));
		v__ast__Scope_register(p->table->global_scope, v__ast__ConstField_to_sumtype_v__ast__ScopeObject(&field));
		comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
		if (!is_block) {
			break;
		}
	}
	v__parser__Parser_top_level_statement_end(p);
	if (is_block) {
		v__parser__Parser_check(p, v__token__Kind__rpar);
	}
	v__ast__ConstDecl _t6 = (v__ast__ConstDecl){
		.is_pub = is_pub,
		.pos = v__token__Position_extend_with_last_line(start_pos, const_pos, p->prev_tok.line_nr),
		.attrs = attrs,
		.fields = fields,
		.end_comments = comments,
		.is_block = is_block,
	};
	return _t6;
}

VV_LOCAL_SYMBOL v__ast__Return v__parser__Parser_return_stmt(v__parser__Parser* p) {
	v__token__Position first_pos = v__token__Token_position(&p->tok);
	v__parser__Parser_next(p);
	Array_v__ast__Comment comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,});
	if (p->tok.kind == v__token__Kind__rcbr || (p->tok.kind == v__token__Kind__name && p->peek_tok.kind == v__token__Kind__colon)) {
		v__ast__Return _t1 = (v__ast__Return){.pos = first_pos,.comments = comments,.exprs = __new_array(0, 0, sizeof(v__ast__Expr)),.types = __new_array(0, 0, sizeof(v__ast__Type)),};
		return _t1;
	}
	multi_return_Array_v__ast__Expr_Array_v__ast__Comment mr_79979 = v__parser__Parser_expr_list(p);
	Array_v__ast__Expr exprs = mr_79979.arg0;
	Array_v__ast__Comment comments2 = mr_79979.arg1;
	_PUSH_MANY(&comments, (comments2), _t2, Array_v__ast__Comment);
	v__token__Position end_pos = v__ast__Expr_position((*(v__ast__Expr*)array_last(exprs)));
	v__ast__Return _t3 = (v__ast__Return){.pos = v__token__Position_extend(first_pos, end_pos),.comments = comments,.exprs = exprs,.types = __new_array(0, 0, sizeof(v__ast__Type)),};
	return _t3;
}

VV_LOCAL_SYMBOL v__ast__GlobalDecl v__parser__Parser_global_decl(v__parser__Parser* p) {
	Array_v__ast__Attr attrs = __new_array_with_default(0, 0, sizeof(v__ast__Attr), 0);
	if (p->attrs.len > 0) {
		attrs = p->attrs;
		p->attrs = __new_array_with_default(0, 0, sizeof(v__ast__Attr), 0);
	}
	bool is_markused = false;
	for (int _t1 = 0; _t1 < attrs.len; ++_t1) {
		v__ast__Attr ga = ((v__ast__Attr*)attrs.data)[_t1];

		if (string__eq(ga.name, _SLIT("markused"))) {
			is_markused = true;
		}
		else {
		};
	}
	if (!p->has_globals && !p->pref->enable_globals && !p->pref->is_fmt && !p->pref->translated && !p->pref->is_livemain && !p->pref->building_v && !p->builtin_mod) {
		v__parser__Parser_error(p, _SLIT("use `v -enable-globals ...` to enable globals"));
		v__ast__GlobalDecl _t2 = (v__ast__GlobalDecl){.mod = (string){.str=(byteptr)"", .is_lit=1},.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.is_block = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.fields = __new_array(0, 0, sizeof(v__ast__GlobalField)),.end_comments = __new_array(0, 0, sizeof(v__ast__Comment)),};
		return _t2;
	}
	v__token__Position start_pos = v__token__Token_position(&p->tok);
	v__parser__Parser_check(p, v__token__Kind__key_global);
	bool is_block = p->tok.kind == v__token__Kind__lpar;
	if (is_block) {
		v__parser__Parser_next(p);
	}
	Array_v__ast__GlobalField fields = __new_array_with_default(0, 0, sizeof(v__ast__GlobalField), 0);
	Array_v__ast__Comment comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	for (;;) {
		comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,});
		if (is_block && p->tok.kind == v__token__Kind__eof) {
			v__parser__Parser_error(p, _SLIT("unexpected eof, expecting ´)´"));
			v__ast__GlobalDecl _t3 = (v__ast__GlobalDecl){.mod = (string){.str=(byteptr)"", .is_lit=1},.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.is_block = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.fields = __new_array(0, 0, sizeof(v__ast__GlobalField)),.end_comments = __new_array(0, 0, sizeof(v__ast__Comment)),};
			return _t3;
		}
		if (p->tok.kind == v__token__Kind__rpar) {
			break;
		}
		v__token__Position pos = v__token__Token_position(&p->tok);
		string name = v__parser__Parser_check_name(p);
		bool has_expr = p->tok.kind == v__token__Kind__assign;
		v__ast__Expr expr = v__ast__empty_expr();
		v__ast__Type typ = _const_v__ast__void_type;
		v__token__Position typ_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,};
		if (has_expr) {
			v__parser__Parser_next(p);
			expr = v__parser__Parser_expr(p, 0);
			if (expr._typ == 287 /* v.ast.CastExpr */) {
				typ = (/* as */ *(v__ast__CastExpr*)__as_cast((expr)._v__ast__CastExpr,(expr)._typ, 287) /*expected idx: 287, name: v.ast.CastExpr */ ).typ;
			}
			else if (expr._typ == 324 /* v.ast.StructInit */) {
				typ = (/* as */ *(v__ast__StructInit*)__as_cast((expr)._v__ast__StructInit,(expr)._typ, 324) /*expected idx: 324, name: v.ast.StructInit */ ).typ;
			}
			else if (expr._typ == 280 /* v.ast.ArrayInit */) {
				typ = (/* as */ *(v__ast__ArrayInit*)__as_cast((expr)._v__ast__ArrayInit,(expr)._typ, 280) /*expected idx: 280, name: v.ast.ArrayInit */ ).typ;
			}
			else if (expr._typ == 288 /* v.ast.ChanInit */) {
				typ = (/* as */ *(v__ast__ChanInit*)__as_cast((expr)._v__ast__ChanInit,(expr)._typ, 288) /*expected idx: 288, name: v.ast.ChanInit */ ).typ;
			}
			else if (expr._typ == 284 /* v.ast.BoolLiteral */) {
				typ = _const_v__ast__bool_type;
			}
			else if (expr._typ == 305 /* v.ast.IsRefType */) {
				typ = _const_v__ast__bool_type;
			}
			else if (expr._typ == 289 /* v.ast.CharLiteral */) {
				typ = _const_v__ast__char_type;
			}
			else if (expr._typ == 297 /* v.ast.FloatLiteral */) {
				typ = _const_v__ast__f64_type;
			}
			else if (expr._typ == 304 /* v.ast.IntegerLiteral */) {
				typ = _const_v__ast__int_type;
			}
			else if (expr._typ == 320 /* v.ast.SizeOf */) {
				typ = _const_v__ast__int_type;
			}
			else if (expr._typ == 323 /* v.ast.StringLiteral */) {
				typ = _const_v__ast__string_type;
			}
			else if (expr._typ == 322 /* v.ast.StringInterLiteral */) {
				typ = _const_v__ast__string_type;
			}
			
			else {
			}
			;
		} else {
			typ_pos = v__token__Token_position(&p->tok);
			typ = v__parser__Parser_parse_type(p);
		}
		v__ast__GlobalField field = (v__ast__GlobalField){
			.name = name,
			.has_expr = has_expr,
			.pos = pos,
			.typ_pos = typ_pos,
			.is_markused = is_markused,
			.expr = expr,
			.typ = typ,
			.comments = comments,
		};
		array_push((array*)&fields, _MOV((v__ast__GlobalField[]){ field }));
		v__ast__Scope_register(p->table->global_scope, v__ast__GlobalField_to_sumtype_v__ast__ScopeObject(&field));
		comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
		if (!is_block) {
			break;
		}
	}
	if (is_block) {
		v__parser__Parser_check(p, v__token__Kind__rpar);
	}
	v__ast__GlobalDecl _t5 = (v__ast__GlobalDecl){
		.mod = p->mod,
		.pos = v__token__Position_extend(start_pos, v__token__Token_position(&p->prev_tok)),
		.is_block = is_block,
		.attrs = attrs,
		.fields = fields,
		.end_comments = comments,
	};
	return _t5;
}

VV_LOCAL_SYMBOL v__ast__EnumDecl v__parser__Parser_enum_decl(v__parser__Parser* p) {
	v__parser__Parser_top_level_statement_start(p);
	bool is_pub = p->tok.kind == v__token__Kind__key_pub;
	v__token__Position start_pos = v__token__Token_position(&p->tok);
	if (is_pub) {
		v__parser__Parser_next(p);
	}
	v__parser__Parser_check(p, v__token__Kind__key_enum);
	v__token__Position end_pos = v__token__Token_position(&p->tok);
	string enum_name = v__parser__Parser_check_name(p);
	if (enum_name.len == 1) {
		v__parser__Parser_error_with_pos(p, _SLIT("single letter capital names are reserved for generic template types."), end_pos);
		v__ast__EnumDecl _t1 = (v__ast__EnumDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.is_pub = 0,.is_flag = 0,.is_multi_allowed = 0,.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.fields = __new_array(0, 0, sizeof(v__ast__EnumField)),.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},};
		return _t1;
	}
	if (_IN_MAP(ADDR(string, enum_name), ADDR(map, p->imported_symbols))) {
		v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot register enum `"), 0xfe10, {.d_s = enum_name}}, {_SLIT("`, this type was already imported"), 0, { .d_c = 0 }}})), end_pos);
		v__ast__EnumDecl _t2 = (v__ast__EnumDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.is_pub = 0,.is_flag = 0,.is_multi_allowed = 0,.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.fields = __new_array(0, 0, sizeof(v__ast__EnumField)),.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},};
		return _t2;
	}
	string name = v__parser__Parser_prepend_mod(p, enum_name);
	v__parser__Parser_check(p, v__token__Kind__lcbr);
	Array_v__ast__Comment enum_decl_comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,});
	Array_string vals = __new_array_with_default(0, 0, sizeof(string), 0);
	Array_v__ast__EnumField fields = __new_array_with_default(0, 0, sizeof(v__ast__EnumField), 0);
	for (;;) {
		if (!(p->tok.kind != v__token__Kind__eof && p->tok.kind != v__token__Kind__rcbr)) break;
		v__token__Position pos = v__token__Token_position(&p->tok);
		string val = v__parser__Parser_check_name(p);
		array_push((array*)&vals, _MOV((string[]){ string_clone(val) }));
		v__ast__Expr expr = v__ast__empty_expr();
		bool has_expr = false;
		if (p->tok.kind == v__token__Kind__assign) {
			v__parser__Parser_next(p);
			expr = v__parser__Parser_expr(p, 0);
			has_expr = true;
		}
		array_push((array*)&fields, _MOV((v__ast__EnumField[]){ (v__ast__EnumField){
			.name = val,
			.pos = pos,
			.comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = true,.follow_up = 0,}),
			.next_comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}),
			.has_expr = has_expr,
			.expr = expr,
		} }));
	}
	v__parser__Parser_top_level_statement_end(p);
	v__parser__Parser_check(p, v__token__Kind__rcbr);
	bool is_flag = Array_v__ast__Attr_contains(p->attrs, _SLIT("flag"));
	bool is_multi_allowed = Array_v__ast__Attr_contains(p->attrs, _SLIT("_allow_multiple_values"));
	if (is_flag) {
		if (fields.len > 32) {
			v__parser__Parser_error(p, _SLIT("when an enum is used as bit field, it must have a max of 32 fields"));
			v__ast__EnumDecl _t5 = (v__ast__EnumDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.is_pub = 0,.is_flag = 0,.is_multi_allowed = 0,.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.fields = __new_array(0, 0, sizeof(v__ast__EnumField)),.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},};
			return _t5;
		}
		for (int _t6 = 0; _t6 < fields.len; ++_t6) {
			v__ast__EnumField f = ((v__ast__EnumField*)fields.data)[_t6];
			if (f.has_expr) {
				v__parser__Parser_error_with_pos(p, _SLIT("when an enum is used as a bit field, you can not assign custom values"), f.pos);
				v__ast__EnumDecl _t7 = (v__ast__EnumDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.is_pub = 0,.is_flag = 0,.is_multi_allowed = 0,.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.fields = __new_array(0, 0, sizeof(v__ast__EnumField)),.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},};
				return _t7;
			}
		}
		string pubfn = (string__eq(p->mod, _SLIT("main")) ? (_SLIT("fn")) : (_SLIT("pub fn")));
		v__parser__Parser_codegen(p,  str_intp(21, _MOV((StrIntpData[]){{_SLIT("\n//\n[inline] "), 0xfe10, {.d_s = pubfn}}, {_SLIT(" (    e &"), 0xfe10, {.d_s = enum_name}}, {_SLIT(") is_empty() bool           { return  int(*e) == 0 }\n[inline] "), 0xfe10, {.d_s = pubfn}}, {_SLIT(" (    e &"), 0xfe10, {.d_s = enum_name}}, {_SLIT(") has(flag "), 0xfe10, {.d_s = enum_name}}, {_SLIT(") bool { return  (int(*e) &  (int(flag))) != 0 }\n[inline] "), 0xfe10, {.d_s = pubfn}}, {_SLIT(" (    e &"), 0xfe10, {.d_s = enum_name}}, {_SLIT(") all(flag "), 0xfe10, {.d_s = enum_name}}, {_SLIT(") bool { return  (int(*e) &  (int(flag))) == int(flag) }\n[inline] "), 0xfe10, {.d_s = pubfn}}, {_SLIT(" (mut e  "), 0xfe10, {.d_s = enum_name}}, {_SLIT(") set(flag "), 0xfe10, {.d_s = enum_name}}, {_SLIT(")      { unsafe{ *e = "), 0xfe10, {.d_s = enum_name}}, {_SLIT("(int(*e) |  (int(flag))) } }\n[inline] "), 0xfe10, {.d_s = pubfn}}, {_SLIT(" (mut e  "), 0xfe10, {.d_s = enum_name}}, {_SLIT(") clear(flag "), 0xfe10, {.d_s = enum_name}}, {_SLIT(")    { unsafe{ *e = "), 0xfe10, {.d_s = enum_name}}, {_SLIT("(int(*e) & ~(int(flag))) } }\n[inline] "), 0xfe10, {.d_s = pubfn}}, {_SLIT(" (mut e  "), 0xfe10, {.d_s = enum_name}}, {_SLIT(") toggle(flag "), 0xfe10, {.d_s = enum_name}}, {_SLIT(")   { unsafe{ *e = "), 0xfe10, {.d_s = enum_name}}, {_SLIT("(int(*e) ^  (int(flag))) } }\n//\n"), 0, { .d_c = 0 }}})));
	}
	int idx = v__ast__Table_register_type_symbol(p->table, (v__ast__TypeSymbol){
		.parent_idx = 0,
		.info = v__ast__Enum_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__Enum, ((v__ast__Enum){.vals = vals,.is_flag = is_flag,.is_multi_allowed = is_multi_allowed,}))),
		.kind = v__ast__Kind__enum_,
		.name = name,
		.cname = v__util__no_dots(name),
		.methods = __new_array(0, 0, sizeof(v__ast__Fn)),
		.mod = p->mod,
		.is_public = is_pub,
		.language = 0,
		.idx = 0,
	});
	if (idx == -1) {
		v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot register enum `"), 0xfe10, {.d_s = name}}, {_SLIT("`, another type with this name exists"), 0, { .d_c = 0 }}})), end_pos);
	}
	v__ast__EnumDecl enum_decl = (v__ast__EnumDecl){
		.name = name,
		.is_pub = is_pub,
		.is_flag = is_flag,
		.is_multi_allowed = is_multi_allowed,
		.comments = enum_decl_comments,
		.fields = fields,
		.attrs = p->attrs,
		.pos = v__token__Position_extend_with_last_line(start_pos, end_pos, p->prev_tok.line_nr),
	};
	v__ast__Table_register_enum_decl(p->table, enum_decl);
	v__ast__EnumDecl _t8 = enum_decl;
	return _t8;
}

VV_LOCAL_SYMBOL v__ast__TypeDecl v__parser__Parser_type_decl(v__parser__Parser* p) {
	v__token__Position start_pos = v__token__Token_position(&p->tok);
	bool is_pub = p->tok.kind == v__token__Kind__key_pub;
	if (is_pub) {
		v__parser__Parser_next(p);
	}
	v__parser__Parser_check(p, v__token__Kind__key_type);
	v__token__Position end_pos = v__token__Token_position(&p->tok);
	v__token__Position decl_pos = v__token__Position_extend(start_pos, end_pos);
	v__token__Position name_pos = v__token__Token_position(&p->tok);
	string name = v__parser__Parser_check_name(p);
	if (name.len == 1 && byte_is_capital(string_at(name, 0))) {
		v__parser__Parser_error_with_pos(p, _SLIT("single letter capital names are reserved for generic template types."), decl_pos);
		v__ast__TypeDecl _t1 = v__ast__FnTypeDecl_to_sumtype_v__ast__TypeDecl(ADDR(v__ast__FnTypeDecl, ((v__ast__FnTypeDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.is_pub = 0,.typ = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comments = __new_array(0, 0, sizeof(v__ast__Comment)),})));
		return _t1;
	}
	if (_IN_MAP(ADDR(string, name), ADDR(map, p->imported_symbols))) {
		v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot register alias `"), 0xfe10, {.d_s = name}}, {_SLIT("`, this type was already imported"), 0, { .d_c = 0 }}})), end_pos);
		v__ast__TypeDecl _t2 = v__ast__AliasTypeDecl_to_sumtype_v__ast__TypeDecl(ADDR(v__ast__AliasTypeDecl, ((v__ast__AliasTypeDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.is_pub = 0,.parent_type = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comments = __new_array(0, 0, sizeof(v__ast__Comment)),})));
		return _t2;
	}
	Array_v__ast__TypeNode sum_variants = __new_array_with_default(0, 0, sizeof(v__ast__TypeNode), 0);
	multi_return_Array_v__ast__Type_Array_string mr_86285 = v__parser__Parser_parse_generic_types(p);
	Array_v__ast__Type generic_types = mr_86285.arg0;
	v__token__Position decl_pos_with_generics = v__token__Position_extend(decl_pos, v__token__Token_position(&p->prev_tok));
	v__parser__Parser_check(p, v__token__Kind__assign);
	v__token__Position type_pos = v__token__Token_position(&p->tok);
	Array_v__ast__Comment comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	if (p->tok.kind == v__token__Kind__key_fn) {
		string fn_name = v__parser__Parser_prepend_mod(p, name);
		v__ast__Type fn_type = v__parser__Parser_parse_fn_type(p, fn_name);
		v__ast__Table_sym(p->table, fn_type)->is_public = is_pub;
		type_pos = v__token__Position_extend(type_pos, v__token__Token_position(&p->tok));
		comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = true,.follow_up = 0,});
		v__ast__TypeDecl _t3 = v__ast__FnTypeDecl_to_sumtype_v__ast__TypeDecl(ADDR(v__ast__FnTypeDecl, ((v__ast__FnTypeDecl){
			.name = fn_name,
			.is_pub = is_pub,
			.typ = fn_type,
			.pos = decl_pos,
			.type_pos = type_pos,
			.comments = comments,
		})));
		return _t3;
	}
	_PUSH_MANY(&sum_variants, (v__parser__Parser_parse_sum_type_variants(p)), _t4, Array_v__ast__TypeNode);
	if (sum_variants.len > 1) {
		for (int _t5 = 0; _t5 < sum_variants.len; ++_t5) {
			v__ast__TypeNode variant = ((v__ast__TypeNode*)sum_variants.data)[_t5];
			v__ast__TypeSymbol* variant_sym = v__ast__Table_sym(p->table, variant.typ);
			if (variant_sym->kind == v__ast__Kind__none_) {
				v__parser__Parser_error_with_pos(p, _SLIT("named sum type cannot have none as its variant"), variant.pos);
				v__ast__TypeDecl _t6 = v__ast__AliasTypeDecl_to_sumtype_v__ast__TypeDecl(ADDR(v__ast__AliasTypeDecl, ((v__ast__AliasTypeDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.is_pub = 0,.parent_type = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comments = __new_array(0, 0, sizeof(v__ast__Comment)),})));
				return _t6;
			}
		}
		Array_v__ast__Type _t7 = __new_array(0, 0, sizeof(v__ast__Type));
		Array_v__ast__TypeNode _t7_orig = sum_variants;
		int _t7_len = _t7_orig.len;
		_t7 = __new_array(0, _t7_len, sizeof(v__ast__Type));

		for (int _t8 = 0; _t8 < _t7_len; ++_t8) {
			v__ast__TypeNode it = ((v__ast__TypeNode*) _t7_orig.data)[_t8];
			v__ast__Type ti = it.typ;
			array_push((array*)&_t7, &ti);
		}
		Array_v__ast__Type variant_types =_t7;
		string prepend_mod_name = v__parser__Parser_prepend_mod(p, name);
		int typ = v__ast__Table_register_type_symbol(p->table, (v__ast__TypeSymbol){
			.parent_idx = 0,
			.info = v__ast__SumType_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__SumType, ((v__ast__SumType){.variants = variant_types,.fields = __new_array(0, 0, sizeof(v__ast__StructField)),.found_fields = 0,.is_anon = 0,.is_generic = generic_types.len > 0,.generic_types = generic_types,.concrete_types = __new_array(0, 0, sizeof(v__ast__Type)),.parent_type = 0,}))),
			.kind = v__ast__Kind__sum_type,
			.name = prepend_mod_name,
			.cname = v__util__no_dots(prepend_mod_name),
			.methods = __new_array(0, 0, sizeof(v__ast__Fn)),
			.mod = p->mod,
			.is_public = is_pub,
			.language = 0,
			.idx = 0,
		});
		if (typ == -1) {
			v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot register sum type `"), 0xfe10, {.d_s = name}}, {_SLIT("`, another type with this name exists"), 0, { .d_c = 0 }}})), name_pos);
			v__ast__TypeDecl _t9 = v__ast__SumTypeDecl_to_sumtype_v__ast__TypeDecl(ADDR(v__ast__SumTypeDecl, ((v__ast__SumTypeDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.is_pub = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.typ = 0,.generic_types = __new_array(0, 0, sizeof(v__ast__Type)),.variants = __new_array(0, 0, sizeof(v__ast__TypeNode)),})));
			return _t9;
		}
		comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = true,.follow_up = 0,});
		v__ast__TypeDecl _t10 = v__ast__SumTypeDecl_to_sumtype_v__ast__TypeDecl(ADDR(v__ast__SumTypeDecl, ((v__ast__SumTypeDecl){
			.name = name,
			.is_pub = is_pub,
			.pos = decl_pos,
			.comments = comments,
			.typ = typ,
			.generic_types = generic_types,
			.variants = sum_variants,
		})));
		return _t10;
	}
	if (generic_types.len > 0) {
		v__parser__Parser_error_with_pos(p, _SLIT("generic type aliases are not yet implemented"), decl_pos_with_generics);
		v__ast__TypeDecl _t11 = v__ast__AliasTypeDecl_to_sumtype_v__ast__TypeDecl(ADDR(v__ast__AliasTypeDecl, ((v__ast__AliasTypeDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.is_pub = 0,.parent_type = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comments = __new_array(0, 0, sizeof(v__ast__Comment)),})));
		return _t11;
	}
	v__ast__Type parent_type = (*(v__ast__TypeNode*)/*ee elem_typ */array_get(sum_variants, 0)).typ;
	v__ast__TypeSymbol* parent_sym = v__ast__Table_sym(p->table, parent_type);
	int pidx = v__ast__Type_idx(parent_type);
	v__parser__Parser_check_for_impure_v(p, parent_sym->language, decl_pos);
	string prepend_mod_name = v__parser__Parser_prepend_mod(p, name);
	int idx = v__ast__Table_register_type_symbol(p->table, (v__ast__TypeSymbol){
		.parent_idx = pidx,
		.info = v__ast__Alias_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__Alias, ((v__ast__Alias){.parent_type = parent_type,.language = parent_sym->language,.is_import = 0,}))),
		.kind = v__ast__Kind__alias,
		.name = prepend_mod_name,
		.cname = v__util__no_dots(prepend_mod_name),
		.methods = __new_array(0, 0, sizeof(v__ast__Fn)),
		.mod = p->mod,
		.is_public = is_pub,
		.language = 0,
		.idx = 0,
	});
	v__token__Position type_end_pos = v__token__Token_position(&p->prev_tok);
	if (idx == -1) {
		v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot register alias `"), 0xfe10, {.d_s = name}}, {_SLIT("`, another type with this name exists"), 0, { .d_c = 0 }}})), name_pos);
		v__ast__TypeDecl _t12 = v__ast__AliasTypeDecl_to_sumtype_v__ast__TypeDecl(ADDR(v__ast__AliasTypeDecl, ((v__ast__AliasTypeDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.is_pub = 0,.parent_type = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comments = __new_array(0, 0, sizeof(v__ast__Comment)),})));
		return _t12;
	}
	if (idx == pidx) {
		v__token__Position type_alias_pos = (*(v__ast__TypeNode*)/*ee elem_typ */array_get(sum_variants, 0)).pos;
		v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("a type alias can not refer to itself: "), 0xfe10, {.d_s = name}}, {_SLIT0, 0, { .d_c = 0 }}})), v__token__Position_extend(decl_pos, type_alias_pos));
		v__ast__TypeDecl _t13 = v__ast__AliasTypeDecl_to_sumtype_v__ast__TypeDecl(ADDR(v__ast__AliasTypeDecl, ((v__ast__AliasTypeDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.is_pub = 0,.parent_type = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comments = __new_array(0, 0, sizeof(v__ast__Comment)),})));
		return _t13;
	}
	comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = true,.follow_up = 0,});
	v__ast__TypeDecl _t14 = v__ast__AliasTypeDecl_to_sumtype_v__ast__TypeDecl(ADDR(v__ast__AliasTypeDecl, ((v__ast__AliasTypeDecl){
		.name = name,
		.is_pub = is_pub,
		.parent_type = parent_type,
		.pos = decl_pos,
		.type_pos = v__token__Position_extend(type_pos, type_end_pos),
		.comments = comments,
	})));
	return _t14;
}

VV_LOCAL_SYMBOL v__ast__Assoc v__parser__Parser_assoc(v__parser__Parser* p) {
	string var_name = v__parser__Parser_check_name(p);
	v__token__Position pos = v__token__Token_position(&p->tok);
	Option_v__ast__Var_ptr _t1 = v__ast__Scope_find_var(p->scope, var_name);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		v__parser__Parser_error(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unknown variable `"), 0xfe10, {.d_s = var_name}}, {_SLIT("`"), 0, { .d_c = 0 }}})));
		v__ast__Assoc _t2 = (v__ast__Assoc){.var_name = (string){.str=(byteptr)"", .is_lit=1},.fields = __new_array(0, 0, sizeof(string)),.exprs = __new_array(0, 0, sizeof(v__ast__Expr)),.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.typ = 0,.scope = 0,};
		return _t2;
	}
	
 	v__ast__Var* v =  (*(v__ast__Var**)_t1.data);
	v->is_used = true;
	Array_string fields = __new_array_with_default(0, 0, sizeof(string), 0);
	Array_v__ast__Expr vals = __new_array_with_default(0, 0, sizeof(v__ast__Expr), 0);
	v__parser__Parser_check(p, v__token__Kind__pipe);
	for (;;) {
		if (!(p->tok.kind != v__token__Kind__eof)) break;
		array_push((array*)&fields, _MOV((string[]){ string_clone(v__parser__Parser_check_name(p)) }));
		v__parser__Parser_check(p, v__token__Kind__colon);
		v__ast__Expr expr = v__parser__Parser_expr(p, 0);
		array_push((array*)&vals, _MOV((v__ast__Expr[]){ expr }));
		if (p->tok.kind == v__token__Kind__comma) {
			v__parser__Parser_next(p);
		}
		if (p->tok.kind == v__token__Kind__rcbr) {
			break;
		}
	}
	v__ast__Assoc _t5 = (v__ast__Assoc){.var_name = var_name,.fields = fields,.exprs = vals,.pos = pos,.typ = 0,.scope = p->scope,};
	return _t5;
}

VV_LOCAL_SYMBOL v__ast__Expr v__parser__Parser_new_true_expr(v__parser__Parser* p) {
	v__ast__Expr _t1 = v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, ((v__ast__BoolLiteral){.val = true,.pos = v__token__Token_position(&p->tok),})));
	return _t1;
}

// Attr: [noreturn]
VNORETURN VV_LOCAL_SYMBOL void v__parser__verror(string s) {
	v__util__verror(_SLIT("parser error"), s);
	VUNREACHABLE();
	while(1);
}

VV_LOCAL_SYMBOL void v__parser__Parser_top_level_statement_start(v__parser__Parser* p) {
	if (p->comments_mode == v__scanner__CommentsMode__toplevel_comments) {
		v__scanner__Scanner_set_is_inside_toplevel_statement(p->scanner, true);
		v__parser__Parser_rewind_scanner_to_current_token_in_new_mode(p);
	}
}

VV_LOCAL_SYMBOL void v__parser__Parser_top_level_statement_end(v__parser__Parser* p) {
	if (p->comments_mode == v__scanner__CommentsMode__toplevel_comments) {
		v__scanner__Scanner_set_is_inside_toplevel_statement(p->scanner, false);
		v__parser__Parser_rewind_scanner_to_current_token_in_new_mode(p);
	}
}

VV_LOCAL_SYMBOL void v__parser__Parser_rewind_scanner_to_current_token_in_new_mode(v__parser__Parser* p) {
	int tidx = p->tok.tidx;
	v__scanner__Scanner_set_current_tidx(p->scanner, tidx - 5);
	v__token__Token no_token = (v__token__Token){.kind = 0,.lit = (string){.str=(byteptr)"", .is_lit=1},.line_nr = 0,.col = 0,.pos = 0,.len = 0,.tidx = 0,};
	p->prev_tok = no_token;
	p->tok = no_token;
	p->peek_tok = no_token;
	v__parser__Parser_next(p);
	for (;;) {
		v__parser__Parser_next(p);
		if (tidx == p->tok.tidx) {
			break;
		}
	}
}

bool v__parser__Parser_mark_var_as_used(v__parser__Parser* p, string varname) {
	Option_v__ast__ScopeObject _t1;
	if (_t1 = v__ast__Scope_find(p->scope, varname), _t1.state == 0) {
		v__ast__ScopeObject obj = *(v__ast__ScopeObject*)_t1.data;
		if (obj._typ == 357 /* v.ast.Var */) {
			(*obj._v__ast__Var).is_used = true;
			bool _t2 = true;
			return _t2;
		}
		else if (obj._typ == 356 /* v.ast.GlobalField */) {
			bool _t3 = true;
			return _t3;
		}
		
		else {
		}
		;
	}
	bool _t4 = false;
	return _t4;
}

VV_LOCAL_SYMBOL v__ast__Stmt v__parser__Parser_unsafe_stmt(v__parser__Parser* p) {
bool v__parser__Parser_unsafe_stmt_defer_0 = false;
	v__token__Position pos = v__token__Token_position(&p->tok);
	v__parser__Parser_next(p);
	if (p->tok.kind != v__token__Kind__lcbr) {
		v__ast__Stmt _t1 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _SLIT("please use `unsafe {`"), v__token__Token_position(&p->tok)))));
		return _t1;
	}
	v__parser__Parser_next(p);
	if (p->inside_unsafe) {
		v__ast__Stmt _t2 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _SLIT("already inside `unsafe` block"), pos))));
		return _t2;
	}
	if (p->tok.kind == v__token__Kind__rcbr) {
		v__token__Position_update_last_line(&pos, p->tok.line_nr);
		v__parser__Parser_next(p);
		v__ast__Stmt _t3 = v__ast__Block_to_sumtype_v__ast__Stmt(ADDR(v__ast__Block, ((v__ast__Block){.stmts = __new_array(0, 0, sizeof(v__ast__Stmt)),.is_unsafe = true,.pos = pos,})));
		return _t3;
	}
	p->inside_unsafe = true;
	v__parser__Parser_open_scope(p);
	v__parser__Parser_unsafe_stmt_defer_0 = true;
	v__ast__Stmt stmt = v__parser__Parser_stmt(p, false);
	if (p->tok.kind == v__token__Kind__rcbr) {
		if ((stmt)._typ == 339 /* v.ast.ExprStmt */) {
			if (v__ast__Expr_is_expr((*stmt._v__ast__ExprStmt).expr)) {
				v__parser__Parser_next(p);
				v__token__Position_update_last_line(&pos, p->prev_tok.line_nr);
				v__ast__UnsafeExpr ue = (v__ast__UnsafeExpr){.expr = (*stmt._v__ast__ExprStmt).expr,.pos = pos,};
				v__ast__Expr expr = v__parser__Parser_expr_with_left(p, v__ast__UnsafeExpr_to_sumtype_v__ast__Expr(&ue), 0, p->is_stmt_ident);
				v__ast__Stmt _t4 = v__ast__ExprStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__ExprStmt, ((v__ast__ExprStmt){.expr = expr,.pos = pos,.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.is_expr = 0,.typ = 0,})));
				// Defer begin
				if (v__parser__Parser_unsafe_stmt_defer_0) {
					p->inside_unsafe = false;
					v__parser__Parser_close_scope(p);
				}
				// Defer end
				return _t4;
			}
		}
	}
	Array_v__ast__Stmt stmts = new_array_from_c_array(1, 1, sizeof(v__ast__Stmt), _MOV((v__ast__Stmt[1]){stmt}));
	for (;;) {
		if (!(p->tok.kind != v__token__Kind__rcbr)) break;
		array_push((array*)&stmts, _MOV((v__ast__Stmt[]){ v__parser__Parser_stmt(p, false) }));
	}
	v__parser__Parser_next(p);
	v__token__Position_update_last_line(&pos, p->tok.line_nr);
	v__ast__Stmt _t6 = v__ast__Block_to_sumtype_v__ast__Stmt(ADDR(v__ast__Block, ((v__ast__Block){.stmts = stmts,.is_unsafe = true,.pos = pos,})));
	// Defer begin
	if (v__parser__Parser_unsafe_stmt_defer_0) {
		p->inside_unsafe = false;
		v__parser__Parser_close_scope(p);
	}
	// Defer end
	return _t6;
}

VV_LOCAL_SYMBOL void v__parser__Parser_trace(v__parser__Parser* p, string fbase, string message) {
	if (string__eq(p->file_base, fbase)) {
		println( str_intp(3, _MOV((StrIntpData[]){{_SLIT("> p.trace | "), 0x14fe10, {.d_s = fbase}}, {_SLIT(" | "), 0xfe10, {.d_s = message}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
}

VV_LOCAL_SYMBOL v__ast__Expr v__parser__Parser_sql_expr(v__parser__Parser* p) {
	v__token__Position pos = v__token__Token_position(&p->tok);
	v__parser__Parser_check_name(p);
	Option_v__ast__Expr _t1 = v__parser__Parser_check_expr(p, 0);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		*(v__ast__Expr*) _t1.data = v__ast__NodeError_to_sumtype_v__ast__Expr(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("invalid expression: unexpected "), 0xfe10, {.d_s = v__token__Token_str(p->tok)}}, {_SLIT(", expecting database"), 0, { .d_c = 0 }}})), v__token__Token_position(&p->tok)))));
	}
	
 	v__ast__Expr db_expr =  (*(v__ast__Expr*)_t1.data);
	v__parser__Parser_check(p, v__token__Kind__lcbr);
	v__parser__Parser_check(p, v__token__Kind__key_select);
	string n = v__parser__Parser_check_name(p);
	bool is_count = string__eq(n, _SLIT("count"));
	v__ast__Type typ = _const_v__ast__void_type;
	if (is_count) {
		v__parser__Parser_check_name(p);
		typ = _const_v__ast__int_type;
	}
	v__token__Position table_pos = v__token__Token_position(&p->tok);
	v__ast__Type table_type = v__parser__Parser_parse_type(p);
	v__ast__Expr where_expr = v__ast__empty_expr();
	bool has_where = p->tok.kind == v__token__Kind__name && string__eq(p->tok.lit, _SLIT("where"));
	bool query_one = false;
	if (has_where) {
		v__parser__Parser_next(p);
		where_expr = v__parser__Parser_expr(p, 0);
		if (!is_count && (where_expr)._typ == 303 /* v.ast.InfixExpr */) {
			v__ast__InfixExpr e = /* as */ *(v__ast__InfixExpr*)__as_cast((where_expr)._v__ast__InfixExpr,(where_expr)._typ, 303) /*expected idx: 303, name: v.ast.InfixExpr */ ;
			if (e.op == v__token__Kind__eq && (e.left)._typ == 299 /* v.ast.Ident */) {
				if (string__eq((*e.left._v__ast__Ident).name, _SLIT("id"))) {
					query_one = true;
				}
			}
		}
	}
	bool has_limit = false;
	v__ast__Expr limit_expr = v__ast__empty_expr();
	bool has_offset = false;
	v__ast__Expr offset_expr = v__ast__empty_expr();
	bool has_order = false;
	v__ast__Expr order_expr = v__ast__empty_expr();
	bool has_desc = false;
	if (p->tok.kind == v__token__Kind__name && string__eq(p->tok.lit, _SLIT("order"))) {
		v__parser__Parser_check_name(p);
		v__token__Position order_pos = v__token__Token_position(&p->tok);
		if (p->tok.kind == v__token__Kind__name && string__eq(p->tok.lit, _SLIT("by"))) {
			v__parser__Parser_check_name(p);
		} else {
			v__ast__Expr _t2 = v__ast__NodeError_to_sumtype_v__ast__Expr(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _SLIT("use `order by` in ORM queries"), order_pos))));
			return _t2;
		}
		has_order = true;
		order_expr = v__parser__Parser_expr(p, 0);
		if (p->tok.kind == v__token__Kind__name && string__eq(p->tok.lit, _SLIT("desc"))) {
			v__parser__Parser_check_name(p);
			has_desc = true;
		}
	}
	if (p->tok.kind == v__token__Kind__name && string__eq(p->tok.lit, _SLIT("limit"))) {
		v__parser__Parser_check_name(p);
		if (p->tok.kind == v__token__Kind__number && string__eq(p->tok.lit, _SLIT("1"))) {
			query_one = true;
		}
		has_limit = true;
		limit_expr = v__parser__Parser_expr(p, 0);
	}
	if (p->tok.kind == v__token__Kind__name && string__eq(p->tok.lit, _SLIT("offset"))) {
		v__parser__Parser_check_name(p);
		has_offset = true;
		offset_expr = v__parser__Parser_expr(p, 0);
	}
	if (!query_one && !is_count) {
		typ = v__ast__new_type(v__ast__Table_find_or_register_array(p->table, table_type));
	} else if (!is_count) {
		typ = table_type;
	}
	v__parser__Parser_check(p, v__token__Kind__rcbr);
	v__ast__Expr _t3 = v__ast__SqlExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__SqlExpr, ((v__ast__SqlExpr){
		.typ = typ,
		.is_count = is_count,
		.db_expr = db_expr,
		.has_where = has_where,
		.has_offset = has_offset,
		.offset_expr = offset_expr,
		.has_order = has_order,
		.order_expr = order_expr,
		.has_desc = has_desc,
		.is_array = !query_one,
		.pos = v__token__Position_extend(pos, v__token__Token_position(&p->prev_tok)),
		.has_limit = has_limit,
		.limit_expr = limit_expr,
		.where_expr = where_expr,
		.table_expr = (v__ast__TypeNode){.typ = table_type,.pos = table_pos,},
		.fields = __new_array(0, 0, sizeof(v__ast__StructField)),
		.sub_structs = new_map(sizeof(int), sizeof(v__ast__SqlExpr), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),
	})));
	return _t3;
}

VV_LOCAL_SYMBOL v__ast__SqlStmt v__parser__Parser_sql_stmt(v__parser__Parser* p) {
bool v__parser__Parser_sql_stmt_defer_0 = false;
	v__token__Position pos = v__token__Token_position(&p->tok);
	p->inside_match = true;
	v__parser__Parser_sql_stmt_defer_0 = true;
	v__parser__Parser_check_name(p);
	Option_v__ast__Expr _t1 = v__parser__Parser_check_expr(p, 0);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		*(v__ast__Expr*) _t1.data = v__ast__NodeError_to_sumtype_v__ast__Expr(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("invalid expression: unexpected "), 0xfe10, {.d_s = v__token__Token_str(p->tok)}}, {_SLIT(", expecting database"), 0, { .d_c = 0 }}})), v__token__Token_position(&p->tok)))));
	}
	
 	v__ast__Expr db_expr =  (*(v__ast__Expr*)_t1.data);
	v__parser__Parser_check(p, v__token__Kind__lcbr);
	Array_v__ast__SqlStmtLine lines = __new_array_with_default(0, 0, sizeof(v__ast__SqlStmtLine), 0);
	for (;;) {
		if (!(p->tok.kind != v__token__Kind__rcbr)) break;
		array_push((array*)&lines, _MOV((v__ast__SqlStmtLine[]){ v__parser__Parser_parse_sql_stmt_line(p) }));
	}
	v__parser__Parser_next(p);
	pos.last_line = p->prev_tok.line_nr;
	v__ast__SqlStmt _t3 = (v__ast__SqlStmt){.pos = v__token__Position_extend(pos, v__token__Token_position(&p->prev_tok)),.db_expr = db_expr,.lines = lines,};
	// Defer begin
	if (v__parser__Parser_sql_stmt_defer_0) {
		p->inside_match = false;
	}
	// Defer end
	return _t3;
}

VV_LOCAL_SYMBOL v__ast__SqlStmtLine v__parser__Parser_parse_sql_stmt_line(v__parser__Parser* p) {
	string n = v__parser__Parser_check_name(p);
	v__token__Position pos = v__token__Token_position(&p->tok);
	v__ast__SqlStmtKind kind = v__ast__SqlStmtKind__insert;
	if (string__eq(n, _SLIT("delete"))) {
		kind = v__ast__SqlStmtKind__delete;
	} else if (string__eq(n, _SLIT("update"))) {
		kind = v__ast__SqlStmtKind__update;
	} else if (string__eq(n, _SLIT("create"))) {
		kind = v__ast__SqlStmtKind__create;
		string table = v__parser__Parser_check_name(p);
		if (!string__eq(table, _SLIT("table"))) {
			v__parser__Parser_error(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("expected `table` got `"), 0xfe10, {.d_s = table}}, {_SLIT("`"), 0, { .d_c = 0 }}})));
			v__ast__SqlStmtLine _t1 = (v__ast__SqlStmtLine){.kind = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.where_expr = {0},.update_exprs = __new_array(0, 0, sizeof(v__ast__Expr)),.object_var_name = (string){.str=(byteptr)"", .is_lit=1},.updated_columns = __new_array(0, 0, sizeof(string)),.table_expr = (v__ast__TypeNode){.typ = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},},.fields = __new_array(0, 0, sizeof(v__ast__StructField)),.sub_structs = new_map(sizeof(int), sizeof(v__ast__SqlStmtLine), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),};
			return _t1;
		}
		v__ast__Type typ = v__parser__Parser_parse_type(p);
		v__token__Position typ_pos = v__token__Token_position(&p->tok);
		v__ast__SqlStmtLine _t2 = (v__ast__SqlStmtLine){.kind = kind,.pos = v__token__Position_extend(pos, v__token__Token_position(&p->prev_tok)),.where_expr = {0},.update_exprs = __new_array(0, 0, sizeof(v__ast__Expr)),.object_var_name = (string){.str=(byteptr)"", .is_lit=1},.updated_columns = __new_array(0, 0, sizeof(string)),.table_expr = (v__ast__TypeNode){.typ = typ,.pos = typ_pos,},.fields = __new_array(0, 0, sizeof(v__ast__StructField)),.sub_structs = new_map(sizeof(int), sizeof(v__ast__SqlStmtLine), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),};
		return _t2;
	} else if (string__eq(n, _SLIT("drop"))) {
		kind = v__ast__SqlStmtKind__drop;
		string table = v__parser__Parser_check_name(p);
		if (!string__eq(table, _SLIT("table"))) {
			v__parser__Parser_error(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("expected `table` got `"), 0xfe10, {.d_s = table}}, {_SLIT("`"), 0, { .d_c = 0 }}})));
			v__ast__SqlStmtLine _t3 = (v__ast__SqlStmtLine){.kind = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.where_expr = {0},.update_exprs = __new_array(0, 0, sizeof(v__ast__Expr)),.object_var_name = (string){.str=(byteptr)"", .is_lit=1},.updated_columns = __new_array(0, 0, sizeof(string)),.table_expr = (v__ast__TypeNode){.typ = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},},.fields = __new_array(0, 0, sizeof(v__ast__StructField)),.sub_structs = new_map(sizeof(int), sizeof(v__ast__SqlStmtLine), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),};
			return _t3;
		}
		v__ast__Type typ = v__parser__Parser_parse_type(p);
		v__token__Position typ_pos = v__token__Token_position(&p->tok);
		v__ast__SqlStmtLine _t4 = (v__ast__SqlStmtLine){.kind = kind,.pos = v__token__Position_extend(pos, v__token__Token_position(&p->prev_tok)),.where_expr = {0},.update_exprs = __new_array(0, 0, sizeof(v__ast__Expr)),.object_var_name = (string){.str=(byteptr)"", .is_lit=1},.updated_columns = __new_array(0, 0, sizeof(string)),.table_expr = (v__ast__TypeNode){.typ = typ,.pos = typ_pos,},.fields = __new_array(0, 0, sizeof(v__ast__StructField)),.sub_structs = new_map(sizeof(int), sizeof(v__ast__SqlStmtLine), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),};
		return _t4;
	}
	string inserted_var_name = _SLIT("");
	v__ast__Type table_type = ((v__ast__Type)(0));
	if (kind != v__ast__SqlStmtKind__delete) {
		if (kind == v__ast__SqlStmtKind__update) {
			table_type = v__parser__Parser_parse_type(p);
		} else if (kind == v__ast__SqlStmtKind__insert) {
			v__ast__Expr expr = v__parser__Parser_expr(p, 0);
			if ((expr)._typ == 299 /* v.ast.Ident */) {
				inserted_var_name = (*expr._v__ast__Ident).name;
			} else {
				v__parser__Parser_error(p, _SLIT("can only insert variables"));
				v__ast__SqlStmtLine _t5 = (v__ast__SqlStmtLine){.kind = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.where_expr = {0},.update_exprs = __new_array(0, 0, sizeof(v__ast__Expr)),.object_var_name = (string){.str=(byteptr)"", .is_lit=1},.updated_columns = __new_array(0, 0, sizeof(string)),.table_expr = (v__ast__TypeNode){.typ = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},},.fields = __new_array(0, 0, sizeof(v__ast__StructField)),.sub_structs = new_map(sizeof(int), sizeof(v__ast__SqlStmtLine), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),};
				return _t5;
			}
		}
	}
	n = v__parser__Parser_check_name(p);
	Array_string updated_columns = __new_array_with_default(0, 0, sizeof(string), 0);
	Array_v__ast__Expr update_exprs = __new_array_with_default(0, 5, sizeof(v__ast__Expr), 0);
	if (kind == v__ast__SqlStmtKind__insert && !string__eq(n, _SLIT("into"))) {
		v__parser__Parser_error(p, _SLIT("expecting `into`"));
		v__ast__SqlStmtLine _t6 = (v__ast__SqlStmtLine){.kind = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.where_expr = {0},.update_exprs = __new_array(0, 0, sizeof(v__ast__Expr)),.object_var_name = (string){.str=(byteptr)"", .is_lit=1},.updated_columns = __new_array(0, 0, sizeof(string)),.table_expr = (v__ast__TypeNode){.typ = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},},.fields = __new_array(0, 0, sizeof(v__ast__StructField)),.sub_structs = new_map(sizeof(int), sizeof(v__ast__SqlStmtLine), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),};
		return _t6;
	} else if (kind == v__ast__SqlStmtKind__update) {
		if (!string__eq(n, _SLIT("set"))) {
			v__parser__Parser_error(p, _SLIT("expecting `set`"));
			v__ast__SqlStmtLine _t7 = (v__ast__SqlStmtLine){.kind = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.where_expr = {0},.update_exprs = __new_array(0, 0, sizeof(v__ast__Expr)),.object_var_name = (string){.str=(byteptr)"", .is_lit=1},.updated_columns = __new_array(0, 0, sizeof(string)),.table_expr = (v__ast__TypeNode){.typ = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},},.fields = __new_array(0, 0, sizeof(v__ast__StructField)),.sub_structs = new_map(sizeof(int), sizeof(v__ast__SqlStmtLine), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),};
			return _t7;
		}
		for (;;) {
			string column = v__parser__Parser_check_name(p);
			array_push((array*)&updated_columns, _MOV((string[]){ string_clone(column) }));
			v__parser__Parser_check(p, v__token__Kind__assign);
			array_push((array*)&update_exprs, _MOV((v__ast__Expr[]){ v__parser__Parser_expr(p, 0) }));
			if (p->tok.kind == v__token__Kind__comma) {
				v__parser__Parser_check(p, v__token__Kind__comma);
			} else {
				break;
			}
		}
	} else if (kind == v__ast__SqlStmtKind__delete && !string__eq(n, _SLIT("from"))) {
		v__parser__Parser_error(p, _SLIT("expecting `from`"));
		v__ast__SqlStmtLine _t10 = (v__ast__SqlStmtLine){.kind = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.where_expr = {0},.update_exprs = __new_array(0, 0, sizeof(v__ast__Expr)),.object_var_name = (string){.str=(byteptr)"", .is_lit=1},.updated_columns = __new_array(0, 0, sizeof(string)),.table_expr = (v__ast__TypeNode){.typ = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},},.fields = __new_array(0, 0, sizeof(v__ast__StructField)),.sub_structs = new_map(sizeof(int), sizeof(v__ast__SqlStmtLine), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),};
		return _t10;
	}
	v__token__Position table_pos = v__token__Token_position(&p->tok);
	v__ast__Expr where_expr = v__ast__empty_expr();
	if (kind == v__ast__SqlStmtKind__insert) {
		table_pos = v__token__Token_position(&p->tok);
		table_type = v__parser__Parser_parse_type(p);
	} else if (kind == v__ast__SqlStmtKind__update) {
		Option_bool _t11 = v__parser__Parser_check_sql_keyword(p, _SLIT("where"));
		if (_t11.state != 0) { /*or block*/ 
			IError err = _t11.err;
			v__ast__SqlStmtLine _t12 = (v__ast__SqlStmtLine){.kind = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.where_expr = {0},.update_exprs = __new_array(0, 0, sizeof(v__ast__Expr)),.object_var_name = (string){.str=(byteptr)"", .is_lit=1},.updated_columns = __new_array(0, 0, sizeof(string)),.table_expr = (v__ast__TypeNode){.typ = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},},.fields = __new_array(0, 0, sizeof(v__ast__StructField)),.sub_structs = new_map(sizeof(int), sizeof(v__ast__SqlStmtLine), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),};
			return _t12;
		}
		
  (*(bool*)_t11.data);
		where_expr = v__parser__Parser_expr(p, 0);
	} else if (kind == v__ast__SqlStmtKind__delete) {
		table_pos = v__token__Token_position(&p->tok);
		table_type = v__parser__Parser_parse_type(p);
		Option_bool _t13 = v__parser__Parser_check_sql_keyword(p, _SLIT("where"));
		if (_t13.state != 0) { /*or block*/ 
			IError err = _t13.err;
			v__ast__SqlStmtLine _t14 = (v__ast__SqlStmtLine){.kind = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.where_expr = {0},.update_exprs = __new_array(0, 0, sizeof(v__ast__Expr)),.object_var_name = (string){.str=(byteptr)"", .is_lit=1},.updated_columns = __new_array(0, 0, sizeof(string)),.table_expr = (v__ast__TypeNode){.typ = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},},.fields = __new_array(0, 0, sizeof(v__ast__StructField)),.sub_structs = new_map(sizeof(int), sizeof(v__ast__SqlStmtLine), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),};
			return _t14;
		}
		
  (*(bool*)_t13.data);
		where_expr = v__parser__Parser_expr(p, 0);
	}
	v__ast__SqlStmtLine _t15 = (v__ast__SqlStmtLine){
		.kind = kind,
		.pos = pos,
		.where_expr = where_expr,
		.update_exprs = update_exprs,
		.object_var_name = inserted_var_name,
		.updated_columns = updated_columns,
		.table_expr = (v__ast__TypeNode){.typ = table_type,.pos = table_pos,},
		.fields = __new_array(0, 0, sizeof(v__ast__StructField)),
		.sub_structs = new_map(sizeof(int), sizeof(v__ast__SqlStmtLine), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),
	};
	return _t15;
}

VV_LOCAL_SYMBOL Option_bool v__parser__Parser_check_sql_keyword(v__parser__Parser* p, string name) {
	if (!string__eq(v__parser__Parser_check_name(p), name)) {
		v__parser__Parser_error(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("orm: expecting `"), 0xfe10, {.d_s = name}}, {_SLIT("`"), 0, { .d_c = 0 }}})));
		return (Option_bool){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Option_bool _t2;
	opt_ok(&(bool[]) { true }, (Option*)(&_t2), sizeof(bool));
	return _t2;
}

VV_LOCAL_SYMBOL v__ast__StructDecl v__parser__Parser_struct_decl(v__parser__Parser* p) {
	v__parser__Parser_top_level_statement_start(p);
	Array_v__ast__Attr attrs = p->attrs;
	p->attrs = __new_array_with_default(0, 0, sizeof(v__ast__Attr), 0);
	v__token__Position start_pos = v__token__Token_position(&p->tok);
	bool is_pub = p->tok.kind == v__token__Kind__key_pub;
	if (is_pub) {
		v__parser__Parser_next(p);
	}
	bool is_union = p->tok.kind == v__token__Kind__key_union;
	if (p->tok.kind == v__token__Kind__key_struct) {
		v__parser__Parser_next(p);
	} else {
		v__parser__Parser_check(p, v__token__Kind__key_union);
	}
	v__ast__Language language = (string__eq(p->tok.lit, _SLIT("C")) && p->peek_tok.kind == v__token__Kind__dot ? (v__ast__Language__c) : string__eq(p->tok.lit, _SLIT("JS")) && p->peek_tok.kind == v__token__Kind__dot ? (v__ast__Language__js) : (v__ast__Language__v));
	if (language != v__ast__Language__v) {
		v__parser__Parser_next(p);
		v__parser__Parser_next(p);
	}
	v__token__Position name_pos = v__token__Token_position(&p->tok);
	v__parser__Parser_check_for_impure_v(p, language, name_pos);
	string name = v__parser__Parser_check_name(p);
	if (name.len == 1 && byte_is_capital(string_at(name, 0))) {
		v__parser__Parser_error_with_pos(p, _SLIT("single letter capital names are reserved for generic template types."), name_pos);
		v__ast__StructDecl _t1 = (v__ast__StructDecl){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.name = (string){.str=(byteptr)"", .is_lit=1},.generic_types = __new_array(0, 0, sizeof(v__ast__Type)),.is_pub = 0,.mut_pos = 0,.pub_pos = 0,.pub_mut_pos = 0,.global_pos = 0,.module_pos = 0,.language = 0,.is_union = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.end_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.embeds = __new_array(0, 0, sizeof(v__ast__Embed)),.fields = __new_array(0, 0, sizeof(v__ast__StructField)),};
		return _t1;
	}
	multi_return_Array_v__ast__Type_Array_string mr_1242 = v__parser__Parser_parse_generic_types(p);
	Array_v__ast__Type generic_types = mr_1242.arg0;
	bool no_body = p->tok.kind != v__token__Kind__lcbr;
	if (language == v__ast__Language__v && no_body) {
		v__parser__Parser_error(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = p->tok.lit}}, {_SLIT("` lacks body"), 0, { .d_c = 0 }}})));
		v__ast__StructDecl _t2 = (v__ast__StructDecl){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.name = (string){.str=(byteptr)"", .is_lit=1},.generic_types = __new_array(0, 0, sizeof(v__ast__Type)),.is_pub = 0,.mut_pos = 0,.pub_pos = 0,.pub_mut_pos = 0,.global_pos = 0,.module_pos = 0,.language = 0,.is_union = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.end_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.embeds = __new_array(0, 0, sizeof(v__ast__Embed)),.fields = __new_array(0, 0, sizeof(v__ast__StructField)),};
		return _t2;
	}
	if (language == v__ast__Language__v && !p->builtin_mod && name.len > 0 && !byte_is_capital(string_at(name, 0)) && !p->pref->translated) {
		v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("struct name `"), 0xfe10, {.d_s = name}}, {_SLIT("` must begin with capital letter"), 0, { .d_c = 0 }}})), name_pos);
		v__ast__StructDecl _t3 = (v__ast__StructDecl){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.name = (string){.str=(byteptr)"", .is_lit=1},.generic_types = __new_array(0, 0, sizeof(v__ast__Type)),.is_pub = 0,.mut_pos = 0,.pub_pos = 0,.pub_mut_pos = 0,.global_pos = 0,.module_pos = 0,.language = 0,.is_union = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.end_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.embeds = __new_array(0, 0, sizeof(v__ast__Embed)),.fields = __new_array(0, 0, sizeof(v__ast__StructField)),};
		return _t3;
	}
	if (name.len == 1) {
		v__parser__Parser_error_with_pos(p, _SLIT("struct names must have more than one character"), name_pos);
		v__ast__StructDecl _t4 = (v__ast__StructDecl){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.name = (string){.str=(byteptr)"", .is_lit=1},.generic_types = __new_array(0, 0, sizeof(v__ast__Type)),.is_pub = 0,.mut_pos = 0,.pub_pos = 0,.pub_mut_pos = 0,.global_pos = 0,.module_pos = 0,.language = 0,.is_union = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.end_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.embeds = __new_array(0, 0, sizeof(v__ast__Embed)),.fields = __new_array(0, 0, sizeof(v__ast__StructField)),};
		return _t4;
	}
	if (_IN_MAP(ADDR(string, name), ADDR(map, p->imported_symbols))) {
		v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot register struct `"), 0xfe10, {.d_s = name}}, {_SLIT("`, this type was already imported"), 0, { .d_c = 0 }}})), name_pos);
		v__ast__StructDecl _t5 = (v__ast__StructDecl){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.name = (string){.str=(byteptr)"", .is_lit=1},.generic_types = __new_array(0, 0, sizeof(v__ast__Type)),.is_pub = 0,.mut_pos = 0,.pub_pos = 0,.pub_mut_pos = 0,.global_pos = 0,.module_pos = 0,.language = 0,.is_union = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.end_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.embeds = __new_array(0, 0, sizeof(v__ast__Embed)),.fields = __new_array(0, 0, sizeof(v__ast__StructField)),};
		return _t5;
	}
	string orig_name = name;
	if (language == v__ast__Language__c) {
		name =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("C."), 0xfe10, {.d_s = name}}, {_SLIT0, 0, { .d_c = 0 }}}));
		orig_name = name;
	} else if (language == v__ast__Language__js) {
		name =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("JS."), 0xfe10, {.d_s = name}}, {_SLIT0, 0, { .d_c = 0 }}}));
		orig_name = name;
	} else {
		name = v__parser__Parser_prepend_mod(p, name);
	}
	Array_v__ast__StructField ast_fields = __new_array_with_default(0, 0, sizeof(v__ast__StructField), 0);
	Array_v__ast__StructField fields = __new_array_with_default(0, 0, sizeof(v__ast__StructField), 0);
	Array_v__ast__Type embed_types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
	Array_v__ast__Embed embeds = __new_array_with_default(0, 0, sizeof(v__ast__Embed), 0);
	Array_string embed_field_names = __new_array_with_default(0, 0, sizeof(string), 0);
	int mut_pos = -1;
	int pub_pos = -1;
	int pub_mut_pos = -1;
	int global_pos = -1;
	int module_pos = -1;
	bool is_field_mut = false;
	bool is_field_pub = false;
	bool is_field_global = false;
	int last_line = v__token__Token_position(&p->prev_tok).line_nr + 1;
	Array_v__ast__Comment end_comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	if (!no_body) {
		v__parser__Parser_check(p, v__token__Kind__lcbr);
		for (;;) {
			if (!(p->tok.kind != v__token__Kind__rcbr)) break;
			Array_v__ast__Comment comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
			for (;;) {
				if (!(p->tok.kind == v__token__Kind__comment)) break;
				array_push((array*)&comments, _MOV((v__ast__Comment[]){ v__parser__Parser_comment(p) }));
				if (p->tok.kind == v__token__Kind__rcbr) {
					break;
				}
			}
			if (p->tok.kind == v__token__Kind__rcbr) {
				end_comments = array_clone_to_depth(&comments, 0);
				break;
			}
			if (p->tok.kind == v__token__Kind__key_pub) {
				v__parser__Parser_next(p);
				if (p->tok.kind == v__token__Kind__key_mut) {
					if (pub_mut_pos != -1) {
						v__parser__Parser_error(p, _SLIT("redefinition of `pub mut` section"));
						v__ast__StructDecl _t7 = (v__ast__StructDecl){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.name = (string){.str=(byteptr)"", .is_lit=1},.generic_types = __new_array(0, 0, sizeof(v__ast__Type)),.is_pub = 0,.mut_pos = 0,.pub_pos = 0,.pub_mut_pos = 0,.global_pos = 0,.module_pos = 0,.language = 0,.is_union = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.end_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.embeds = __new_array(0, 0, sizeof(v__ast__Embed)),.fields = __new_array(0, 0, sizeof(v__ast__StructField)),};
						return _t7;
					}
					v__parser__Parser_next(p);
					pub_mut_pos = ast_fields.len;
					is_field_pub = true;
					is_field_mut = true;
					is_field_global = false;
				} else {
					if (pub_pos != -1) {
						v__parser__Parser_error(p, _SLIT("redefinition of `pub` section"));
						v__ast__StructDecl _t8 = (v__ast__StructDecl){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.name = (string){.str=(byteptr)"", .is_lit=1},.generic_types = __new_array(0, 0, sizeof(v__ast__Type)),.is_pub = 0,.mut_pos = 0,.pub_pos = 0,.pub_mut_pos = 0,.global_pos = 0,.module_pos = 0,.language = 0,.is_union = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.end_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.embeds = __new_array(0, 0, sizeof(v__ast__Embed)),.fields = __new_array(0, 0, sizeof(v__ast__StructField)),};
						return _t8;
					}
					pub_pos = ast_fields.len;
					is_field_pub = true;
					is_field_mut = false;
					is_field_global = false;
				}
				v__parser__Parser_check(p, v__token__Kind__colon);
			} else if (p->tok.kind == v__token__Kind__key_mut) {
				if (mut_pos != -1) {
					v__parser__Parser_error(p, _SLIT("redefinition of `mut` section"));
					v__ast__StructDecl _t9 = (v__ast__StructDecl){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.name = (string){.str=(byteptr)"", .is_lit=1},.generic_types = __new_array(0, 0, sizeof(v__ast__Type)),.is_pub = 0,.mut_pos = 0,.pub_pos = 0,.pub_mut_pos = 0,.global_pos = 0,.module_pos = 0,.language = 0,.is_union = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.end_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.embeds = __new_array(0, 0, sizeof(v__ast__Embed)),.fields = __new_array(0, 0, sizeof(v__ast__StructField)),};
					return _t9;
				}
				v__parser__Parser_next(p);
				v__parser__Parser_check(p, v__token__Kind__colon);
				mut_pos = ast_fields.len;
				is_field_pub = false;
				is_field_mut = true;
				is_field_global = false;
			} else if (p->tok.kind == v__token__Kind__key_global) {
				if (global_pos != -1) {
					v__parser__Parser_error(p, _SLIT("redefinition of `global` section"));
					v__ast__StructDecl _t10 = (v__ast__StructDecl){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.name = (string){.str=(byteptr)"", .is_lit=1},.generic_types = __new_array(0, 0, sizeof(v__ast__Type)),.is_pub = 0,.mut_pos = 0,.pub_pos = 0,.pub_mut_pos = 0,.global_pos = 0,.module_pos = 0,.language = 0,.is_union = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.end_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.embeds = __new_array(0, 0, sizeof(v__ast__Embed)),.fields = __new_array(0, 0, sizeof(v__ast__StructField)),};
					return _t10;
				}
				v__parser__Parser_next(p);
				v__parser__Parser_check(p, v__token__Kind__colon);
				global_pos = ast_fields.len;
				is_field_pub = true;
				is_field_mut = true;
				is_field_global = true;
			} else if (p->tok.kind == v__token__Kind__key_module) {
				if (module_pos != -1) {
					v__parser__Parser_error(p, _SLIT("redefinition of `module` section"));
					v__ast__StructDecl _t11 = (v__ast__StructDecl){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.name = (string){.str=(byteptr)"", .is_lit=1},.generic_types = __new_array(0, 0, sizeof(v__ast__Type)),.is_pub = 0,.mut_pos = 0,.pub_pos = 0,.pub_mut_pos = 0,.global_pos = 0,.module_pos = 0,.language = 0,.is_union = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.end_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.embeds = __new_array(0, 0, sizeof(v__ast__Embed)),.fields = __new_array(0, 0, sizeof(v__ast__StructField)),};
					return _t11;
				}
				v__parser__Parser_next(p);
				v__parser__Parser_check(p, v__token__Kind__colon);
				module_pos = ast_fields.len;
				is_field_pub = false;
				is_field_mut = false;
				is_field_global = false;
			}
			for (;;) {
				if (!(p->tok.kind == v__token__Kind__comment)) break;
				array_push((array*)&comments, _MOV((v__ast__Comment[]){ v__parser__Parser_comment(p) }));
				if (p->tok.kind == v__token__Kind__rcbr) {
					break;
				}
			}
			v__token__Position field_start_pos = v__token__Token_position(&p->tok);
			bool is_field_volatile = false;
			if (p->tok.kind == v__token__Kind__key_volatile) {
				v__parser__Parser_next(p);
				is_field_volatile = true;
			}
			bool is_embed = ((p->tok.lit.len > 1 && byte_is_capital(string_at(p->tok.lit, 0))) || p->peek_tok.kind == v__token__Kind__dot) && language == v__ast__Language__v && p->peek_tok.kind != v__token__Kind__key_fn;
			bool is_on_top = ast_fields.len == 0 && !(is_field_mut || is_field_global);
			string field_name = _SLIT("");
			v__ast__Type typ = ((v__ast__Type)(0));
			v__token__Position type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,};
			v__token__Position field_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,};
			if (is_embed) {
				type_pos = v__token__Token_position(&p->tok);
				typ = v__parser__Parser_parse_type(p);
				_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,})), _t13, Array_v__ast__Comment);
				type_pos = v__token__Position_extend(type_pos, v__token__Token_position(&p->prev_tok));
				if (!is_on_top) {
					v__parser__Parser_error_with_pos(p, _SLIT("struct embedding must be declared at the beginning of the struct body"), type_pos);
					v__ast__StructDecl _t14 = (v__ast__StructDecl){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.name = (string){.str=(byteptr)"", .is_lit=1},.generic_types = __new_array(0, 0, sizeof(v__ast__Type)),.is_pub = 0,.mut_pos = 0,.pub_pos = 0,.pub_mut_pos = 0,.global_pos = 0,.module_pos = 0,.language = 0,.is_union = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.end_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.embeds = __new_array(0, 0, sizeof(v__ast__Embed)),.fields = __new_array(0, 0, sizeof(v__ast__StructField)),};
					return _t14;
				}
				v__ast__TypeSymbol* sym = v__ast__Table_sym(p->table, typ);
				if (Array_v__ast__Type_contains(embed_types, typ)) {
					v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot embed `"), 0xfe10, {.d_s = sym->name}}, {_SLIT("` more than once"), 0, { .d_c = 0 }}})), type_pos);
					v__ast__StructDecl _t15 = (v__ast__StructDecl){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.name = (string){.str=(byteptr)"", .is_lit=1},.generic_types = __new_array(0, 0, sizeof(v__ast__Type)),.is_pub = 0,.mut_pos = 0,.pub_pos = 0,.pub_mut_pos = 0,.global_pos = 0,.module_pos = 0,.language = 0,.is_union = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.end_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.embeds = __new_array(0, 0, sizeof(v__ast__Embed)),.fields = __new_array(0, 0, sizeof(v__ast__StructField)),};
					return _t15;
				}
				field_name = v__ast__TypeSymbol_embed_name(sym);
				if (Array_string_contains(embed_field_names, field_name)) {
					v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("duplicate field `"), 0xfe10, {.d_s = field_name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), type_pos);
					v__ast__StructDecl _t16 = (v__ast__StructDecl){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.name = (string){.str=(byteptr)"", .is_lit=1},.generic_types = __new_array(0, 0, sizeof(v__ast__Type)),.is_pub = 0,.mut_pos = 0,.pub_pos = 0,.pub_mut_pos = 0,.global_pos = 0,.module_pos = 0,.language = 0,.is_union = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.end_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.embeds = __new_array(0, 0, sizeof(v__ast__Embed)),.fields = __new_array(0, 0, sizeof(v__ast__StructField)),};
					return _t16;
				}
				array_push((array*)&embed_field_names, _MOV((string[]){ string_clone(field_name) }));
				array_push((array*)&embed_types, _MOV((v__ast__Type[]){ typ }));
				array_push((array*)&embeds, _MOV((v__ast__Embed[]){ (v__ast__Embed){.typ = typ,.pos = type_pos,.comments = comments,} }));
			} else {
				field_name = v__parser__Parser_check_name(p);
				for (;;) {
					if (!(p->tok.kind == v__token__Kind__comment)) break;
					array_push((array*)&comments, _MOV((v__ast__Comment[]){ v__parser__Parser_comment(p) }));
					if (p->tok.kind == v__token__Kind__rcbr) {
						break;
					}
				}
				typ = v__parser__Parser_parse_type(p);
				if (v__ast__Type_idx(typ) == 0) {
					v__ast__StructDecl _t21 = (v__ast__StructDecl){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.name = (string){.str=(byteptr)"", .is_lit=1},.generic_types = __new_array(0, 0, sizeof(v__ast__Type)),.is_pub = 0,.mut_pos = 0,.pub_pos = 0,.pub_mut_pos = 0,.global_pos = 0,.module_pos = 0,.language = 0,.is_union = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.end_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.embeds = __new_array(0, 0, sizeof(v__ast__Embed)),.fields = __new_array(0, 0, sizeof(v__ast__StructField)),};
					return _t21;
				}
				type_pos = v__token__Token_position(&p->prev_tok);
				field_pos = v__token__Position_extend(field_start_pos, type_pos);
			}
			_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,})), _t22, Array_v__ast__Comment);
			if (p->tok.kind == v__token__Kind__lsbr) {
				v__parser__Parser_attributes(p);
			}
			v__ast__Expr default_expr = v__ast__empty_expr();
			bool has_default_expr = false;
			if (!is_embed) {
				if (p->tok.kind == v__token__Kind__assign) {
					v__parser__Parser_next(p);
					default_expr = v__parser__Parser_expr(p, 0);
					if (default_expr._typ == 296 /* v.ast.EnumVal */) {
						(*default_expr._v__ast__EnumVal).typ = typ;
					}
					
					else {
					}
					;
					has_default_expr = true;
					_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,})), _t23, Array_v__ast__Comment);
				}
				array_push((array*)&ast_fields, _MOV((v__ast__StructField[]){ (v__ast__StructField){
					.pos = field_pos,
					.type_pos = type_pos,
					.comments = comments,
					.has_default_expr = has_default_expr,
					.attrs = p->attrs,
					.is_pub = is_embed || is_field_pub,
					.default_val = (string){.str=(byteptr)"", .is_lit=1},
					.is_mut = is_embed || is_field_mut,
					.is_global = is_field_global,
					.is_volatile = is_field_volatile,
					.default_expr = default_expr,
					.default_expr_typ = 0,
					.name = field_name,
					.typ = typ,
				} }));
			}
			array_push((array*)&fields, _MOV((v__ast__StructField[]){ (v__ast__StructField){
				.pos = field_pos,
				.type_pos = type_pos,
				.comments = comments,
				.has_default_expr = has_default_expr,
				.attrs = p->attrs,
				.is_pub = is_embed || is_field_pub,
				.default_val = (string){.str=(byteptr)"", .is_lit=1},
				.is_mut = is_embed || is_field_mut,
				.is_global = is_field_global,
				.is_volatile = is_field_volatile,
				.default_expr = default_expr,
				.default_expr_typ = 0,
				.name = field_name,
				.typ = typ,
			} }));
			p->attrs = __new_array_with_default(0, 0, sizeof(v__ast__Attr), 0);
		}
		v__parser__Parser_top_level_statement_end(p);
		last_line = p->tok.line_nr;
		v__parser__Parser_check(p, v__token__Kind__rcbr);
	}
	v__ast__TypeSymbol t = (v__ast__TypeSymbol){
		.parent_idx = 0,
		.info = v__ast__Struct_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__Struct, ((v__ast__Struct){
			.attrs = attrs,
			.embeds = embed_types,
			.fields = fields,
			.is_typedef = Array_v__ast__Attr_contains(attrs, _SLIT("typedef")),
			.is_union = is_union,
			.is_heap = Array_v__ast__Attr_contains(attrs, _SLIT("heap")),
			.is_generic = generic_types.len > 0,
			.generic_types = generic_types,
			.concrete_types = __new_array(0, 0, sizeof(v__ast__Type)),
			.parent_type = 0,
		}))),
		.kind = v__ast__Kind__struct_,
		.name = name,
		.cname = v__util__no_dots(name),
		.methods = __new_array(0, 0, sizeof(v__ast__Fn)),
		.mod = p->mod,
		.is_public = is_pub,
		.language = language,
		.idx = 0,
	};
	if (v__ast__Table_has_deep_child_no_ref(p->table, &t, name)) {
		v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("invalid recursive struct `"), 0xfe10, {.d_s = orig_name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), name_pos);
		v__ast__StructDecl _t26 = (v__ast__StructDecl){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.name = (string){.str=(byteptr)"", .is_lit=1},.generic_types = __new_array(0, 0, sizeof(v__ast__Type)),.is_pub = 0,.mut_pos = 0,.pub_pos = 0,.pub_mut_pos = 0,.global_pos = 0,.module_pos = 0,.language = 0,.is_union = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.end_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.embeds = __new_array(0, 0, sizeof(v__ast__Embed)),.fields = __new_array(0, 0, sizeof(v__ast__StructField)),};
		return _t26;
	}
	int ret = 0;
	ret = v__ast__Table_register_type_symbol(p->table, t);
	if (ret == -1 && language != v__ast__Language__c) {
		v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot register struct `"), 0xfe10, {.d_s = name}}, {_SLIT("`, another type with this name exists"), 0, { .d_c = 0 }}})), name_pos);
		v__ast__StructDecl _t27 = (v__ast__StructDecl){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.name = (string){.str=(byteptr)"", .is_lit=1},.generic_types = __new_array(0, 0, sizeof(v__ast__Type)),.is_pub = 0,.mut_pos = 0,.pub_pos = 0,.pub_mut_pos = 0,.global_pos = 0,.module_pos = 0,.language = 0,.is_union = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.end_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.embeds = __new_array(0, 0, sizeof(v__ast__Embed)),.fields = __new_array(0, 0, sizeof(v__ast__StructField)),};
		return _t27;
	}
	p->expr_mod = _SLIT("");
	v__ast__StructDecl _t28 = (v__ast__StructDecl){
		.pos = v__token__Position_extend_with_last_line(start_pos, name_pos, last_line),
		.name = name,
		.generic_types = generic_types,
		.is_pub = is_pub,
		.mut_pos = mut_pos,
		.pub_pos = pub_pos,
		.pub_mut_pos = pub_mut_pos,
		.global_pos = global_pos,
		.module_pos = module_pos,
		.language = language,
		.is_union = is_union,
		.attrs = attrs,
		.end_comments = end_comments,
		.embeds = embeds,
		.fields = ast_fields,
	};
	return _t28;
}

VV_LOCAL_SYMBOL v__ast__StructInit v__parser__Parser_struct_init(v__parser__Parser* p, bool short_syntax) {
	v__token__Position first_pos = v__token__Token_position(ADDR(v__token__Token, ((short_syntax && p->prev_tok.kind == v__token__Kind__lcbr ? (p->prev_tok) : (p->tok)))));
	v__ast__Type typ = (short_syntax ? (_const_v__ast__void_type) : (v__parser__Parser_parse_type(p)));
	p->expr_mod = _SLIT("");
	if (!short_syntax) {
		v__parser__Parser_check(p, v__token__Kind__lcbr);
	}
	Array_v__ast__Comment pre_comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,});
	Array_v__ast__StructInitField fields = __new_array_with_default(0, 0, sizeof(v__ast__StructInitField), 0);
	int i = 0;
	bool no_keys = p->peek_tok.kind != v__token__Kind__colon && p->tok.kind != v__token__Kind__rcbr && p->tok.kind != v__token__Kind__ellipsis;
	bool saved_is_amp = p->is_amp;
	p->is_amp = false;
	v__ast__Expr update_expr = v__ast__empty_expr();
	Array_v__ast__Comment update_expr_comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	bool has_update_expr = false;
	for (;;) {
		if (!(!(p->tok.kind == v__token__Kind__rcbr || p->tok.kind == v__token__Kind__rpar || p->tok.kind == v__token__Kind__eof))) break;
		string field_name = _SLIT("");
		v__ast__Expr expr = v__ast__empty_expr();
		v__token__Position field_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,};
		v__token__Position first_field_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,};
		Array_v__ast__Comment comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
		Array_v__ast__Comment nline_comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
		bool is_update_expr = fields.len == 0 && p->tok.kind == v__token__Kind__ellipsis;
		if (no_keys) {
			expr = v__parser__Parser_expr(p, 0);
			field_pos = v__ast__Expr_position(expr);
			first_field_pos = field_pos;
			comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = true,.follow_up = 0,});
		} else if (is_update_expr) {
			v__parser__Parser_check(p, v__token__Kind__ellipsis);
			update_expr = v__parser__Parser_expr(p, 0);
			_PUSH_MANY(&update_expr_comments, (v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = true,.follow_up = 0,})), _t1, Array_v__ast__Comment);
			has_update_expr = true;
		} else {
			first_field_pos = v__token__Token_position(&p->tok);
			field_name = v__parser__Parser_check_name(p);
			v__parser__Parser_check(p, v__token__Kind__colon);
			expr = v__parser__Parser_expr(p, 0);
			comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = true,.follow_up = 0,});
			v__token__Position last_field_pos = v__ast__Expr_position(expr);
			int field_len = (last_field_pos.len > 0 ? (last_field_pos.pos - first_field_pos.pos + last_field_pos.len) : (first_field_pos.len + 1));
			field_pos = (v__token__Position){.len = field_len,.line_nr = first_field_pos.line_nr,.pos = first_field_pos.pos,.col = first_field_pos.col,.last_line = 0,};
		}
		i++;
		if (p->tok.kind == v__token__Kind__comma) {
			v__parser__Parser_next(p);
		}
		_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = true,.follow_up = 0,})), _t2, Array_v__ast__Comment);
		_PUSH_MANY(&nline_comments, (v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,})), _t3, Array_v__ast__Comment);
		if (!is_update_expr) {
			array_push((array*)&fields, _MOV((v__ast__StructInitField[]){ (v__ast__StructInitField){
				.pos = field_pos,
				.name_pos = first_field_pos,
				.comments = comments,
				.next_comments = nline_comments,
				.expr = expr,
				.name = field_name,
				.typ = 0,
				.expected_type = 0,
				.parent_type = typ,
			} }));
		}
	}
	if (!short_syntax) {
		v__parser__Parser_check(p, v__token__Kind__rcbr);
	}
	p->is_amp = saved_is_amp;
	v__ast__StructInit _t5 = (v__ast__StructInit){
		.pos = v__token__Position_extend(first_pos, (short_syntax ? (v__token__Token_position(&p->tok)) : (v__token__Token_position(&p->prev_tok)))),
		.name_pos = first_pos,
		.is_short = no_keys,
		.unresolved = v__ast__Type_has_flag(typ, v__ast__TypeFlag__generic),
		.pre_comments = pre_comments,
		.typ = typ,
		.update_expr = update_expr,
		.update_expr_type = 0,
		.update_expr_comments = update_expr_comments,
		.has_update_expr = has_update_expr,
		.fields = fields,
		.embeds = __new_array(0, 0, sizeof(v__ast__StructInitEmbed)),
	};
	return _t5;
}

VV_LOCAL_SYMBOL v__ast__InterfaceDecl v__parser__Parser_interface_decl(v__parser__Parser* p) {
	v__parser__Parser_top_level_statement_start(p);
	v__token__Position pos = v__token__Token_position(&p->tok);
	Array_v__ast__Attr attrs = p->attrs;
	bool is_pub = p->tok.kind == v__token__Kind__key_pub;
	if (is_pub) {
		v__parser__Parser_next(p);
	}
	v__parser__Parser_next(p);
	v__ast__Language language = (string__eq(p->tok.lit, _SLIT("C")) && p->peek_tok.kind == v__token__Kind__dot ? (v__ast__Language__c) : string__eq(p->tok.lit, _SLIT("JS")) && p->peek_tok.kind == v__token__Kind__dot ? (v__ast__Language__js) : (v__ast__Language__v));
	if (language != v__ast__Language__v) {
		v__parser__Parser_next(p);
		v__parser__Parser_next(p);
	}
	v__token__Position name_pos = v__token__Token_position(&p->tok);
	v__parser__Parser_check_for_impure_v(p, language, name_pos);
	string modless_name = v__parser__Parser_check_name(p);
	string interface_name = _SLIT("");
	if (language == v__ast__Language__js) {
		interface_name = string__plus(_SLIT("JS."), modless_name);
	} else {
		interface_name = v__parser__Parser_prepend_mod(p, modless_name);
	}
	multi_return_Array_v__ast__Type_Array_string mr_12296 = v__parser__Parser_parse_generic_types(p);
	Array_v__ast__Type generic_types = mr_12296.arg0;
	v__parser__Parser_check(p, v__token__Kind__lcbr);
	Array_v__ast__Comment pre_comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,});
	if (_IN_MAP(ADDR(string, modless_name), ADDR(map, p->imported_symbols))) {
		v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot register interface `"), 0xfe10, {.d_s = interface_name}}, {_SLIT("`, this type was already imported"), 0, { .d_c = 0 }}})), name_pos);
		v__ast__InterfaceDecl _t1 = (v__ast__InterfaceDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,.name_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.language = 0,.field_names = __new_array(0, 0, sizeof(string)),.is_pub = 0,.mut_pos = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.pre_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = __new_array(0, 0, sizeof(v__ast__Type)),.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.methods = __new_array(0, 0, sizeof(v__ast__FnDecl)),.fields = __new_array(0, 0, sizeof(v__ast__StructField)),.ifaces = __new_array(0, 0, sizeof(v__ast__InterfaceEmbedding)),.are_ifaces_expanded = 0,};
		return _t1;
	}
	int reg_idx = v__ast__Table_register_type_symbol(p->table, (v__ast__TypeSymbol){
		.parent_idx = 0,
		.info = v__ast__Interface_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__Interface, ((v__ast__Interface){.types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0),.fields = __new_array(0, 0, sizeof(v__ast__StructField)),.methods = __new_array(0, 0, sizeof(v__ast__Fn)),.ifaces = __new_array(0, 0, sizeof(v__ast__Type)),.conversions = new_map(sizeof(int), sizeof(Array_v__ast__Type), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),.is_generic = generic_types.len > 0,.generic_types = generic_types,.concrete_types = __new_array(0, 0, sizeof(v__ast__Type)),.parent_type = 0,}))),
		.kind = v__ast__Kind__interface_,
		.name = interface_name,
		.cname = v__util__no_dots(interface_name),
		.methods = __new_array(0, 0, sizeof(v__ast__Fn)),
		.mod = p->mod,
		.is_public = is_pub,
		.language = language,
		.idx = 0,
	});
	if (reg_idx == -1) {
		v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot register interface `"), 0xfe10, {.d_s = interface_name}}, {_SLIT("`, another type with this name exists"), 0, { .d_c = 0 }}})), name_pos);
		v__ast__InterfaceDecl _t2 = (v__ast__InterfaceDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,.name_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.language = 0,.field_names = __new_array(0, 0, sizeof(string)),.is_pub = 0,.mut_pos = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.pre_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = __new_array(0, 0, sizeof(v__ast__Type)),.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.methods = __new_array(0, 0, sizeof(v__ast__FnDecl)),.fields = __new_array(0, 0, sizeof(v__ast__StructField)),.ifaces = __new_array(0, 0, sizeof(v__ast__InterfaceEmbedding)),.are_ifaces_expanded = 0,};
		return _t2;
	}
	v__ast__Type typ = v__ast__new_type(reg_idx);
	v__ast__TypeSymbol* ts = v__ast__Table_sym(p->table, typ);
	v__ast__Interface info = /* as */ *(v__ast__Interface*)__as_cast((ts->info)._v__ast__Interface,(ts->info)._typ, 463) /*expected idx: 463, name: v.ast.Interface */ ;
	ts->methods = __new_array_with_default(0, 20, sizeof(v__ast__Fn), 0);
	Array_v__ast__StructField fields = __new_array_with_default(0, 20, sizeof(v__ast__StructField), 0);
	Array_v__ast__FnDecl methods = __new_array_with_default(0, 20, sizeof(v__ast__FnDecl), 0);
	bool is_mut = false;
	int mut_pos = -1;
	Array_v__ast__InterfaceEmbedding ifaces = __new_array_with_default(0, 0, sizeof(v__ast__InterfaceEmbedding), 0);
	for (;;) {
		if (!(p->tok.kind != v__token__Kind__rcbr && p->tok.kind != v__token__Kind__eof)) break;
		if (p->tok.kind == v__token__Kind__name && p->tok.lit.len > 0 && byte_is_capital(string_at(p->tok.lit, 0))) {
			v__token__Position iface_pos = v__token__Token_position(&p->tok);
			string iface_name = p->tok.lit;
			v__ast__Type iface_type = v__parser__Parser_parse_type(p);
			if (string__eq(iface_name, _SLIT("JS"))) {
				iface_name = v__ast__Table_sym(p->table, iface_type)->name;
			}
			Array_v__ast__Comment comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,});
			array_push((array*)&ifaces, _MOV((v__ast__InterfaceEmbedding[]){ (v__ast__InterfaceEmbedding){.name = iface_name,.typ = iface_type,.pos = iface_pos,.comments = comments,} }));
			if (p->tok.kind == v__token__Kind__rcbr) {
				break;
			}
			continue;
		}
		if (p->tok.kind == v__token__Kind__key_mut) {
			if (is_mut) {
				v__parser__Parser_error_with_pos(p, _SLIT("redefinition of `mut` section"), v__token__Token_position(&p->tok));
				v__ast__InterfaceDecl _t4 = (v__ast__InterfaceDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,.name_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.language = 0,.field_names = __new_array(0, 0, sizeof(string)),.is_pub = 0,.mut_pos = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.pre_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = __new_array(0, 0, sizeof(v__ast__Type)),.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.methods = __new_array(0, 0, sizeof(v__ast__FnDecl)),.fields = __new_array(0, 0, sizeof(v__ast__StructField)),.ifaces = __new_array(0, 0, sizeof(v__ast__InterfaceEmbedding)),.are_ifaces_expanded = 0,};
				return _t4;
			}
			v__parser__Parser_next(p);
			v__parser__Parser_check(p, v__token__Kind__colon);
			is_mut = true;
			mut_pos = fields.len;
		}
		if (p->peek_tok.kind == v__token__Kind__lpar) {
			v__token__Position method_start_pos = v__token__Token_position(&p->tok);
			int line_nr = p->tok.line_nr;
			string name = v__parser__Parser_check_name(p);
			if (string__eq(name, _SLIT("type_name")) || string__eq(name, _SLIT("type_idx"))) {
				v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot override built-in method `"), 0xfe10, {.d_s = name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), method_start_pos);
				v__ast__InterfaceDecl _t5 = (v__ast__InterfaceDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,.name_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.language = 0,.field_names = __new_array(0, 0, sizeof(string)),.is_pub = 0,.mut_pos = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.pre_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = __new_array(0, 0, sizeof(v__ast__Type)),.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.methods = __new_array(0, 0, sizeof(v__ast__FnDecl)),.fields = __new_array(0, 0, sizeof(v__ast__StructField)),.ifaces = __new_array(0, 0, sizeof(v__ast__InterfaceEmbedding)),.are_ifaces_expanded = 0,};
				return _t5;
			}
			if (v__ast__TypeSymbol_has_method(ts, name)) {
				v__parser__Parser_error_with_pos(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("duplicate method `"), 0xfe10, {.d_s = name}}, {_SLIT("`"), 0, { .d_c = 0 }}})), method_start_pos);
				v__ast__InterfaceDecl _t6 = (v__ast__InterfaceDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,.name_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.language = 0,.field_names = __new_array(0, 0, sizeof(string)),.is_pub = 0,.mut_pos = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.pre_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = __new_array(0, 0, sizeof(v__ast__Type)),.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.methods = __new_array(0, 0, sizeof(v__ast__FnDecl)),.fields = __new_array(0, 0, sizeof(v__ast__StructField)),.ifaces = __new_array(0, 0, sizeof(v__ast__InterfaceEmbedding)),.are_ifaces_expanded = 0,};
				return _t6;
			}
			if (language == v__ast__Language__v && v__util__contains_capital(name)) {
				v__parser__Parser_error(p, _SLIT("interface methods cannot contain uppercase letters, use snake_case instead"));
				v__ast__InterfaceDecl _t7 = (v__ast__InterfaceDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,.name_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.language = 0,.field_names = __new_array(0, 0, sizeof(string)),.is_pub = 0,.mut_pos = 0,.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.pre_comments = __new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = __new_array(0, 0, sizeof(v__ast__Type)),.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.methods = __new_array(0, 0, sizeof(v__ast__FnDecl)),.fields = __new_array(0, 0, sizeof(v__ast__StructField)),.ifaces = __new_array(0, 0, sizeof(v__ast__InterfaceEmbedding)),.are_ifaces_expanded = 0,};
				return _t7;
			}
			multi_return_Array_v__ast__Param_bool_bool mr_14856 = v__parser__Parser_fn_args(p);
			Array_v__ast__Param args2 = mr_14856.arg0;
			bool is_variadic = mr_14856.arg2;
			Array_v__ast__Param args = new_array_from_c_array(1, 1, sizeof(v__ast__Param), _MOV((v__ast__Param[1]){(v__ast__Param){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.name = _SLIT("x"),.is_mut = is_mut,.is_auto_rec = 0,.type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.is_hidden = true,.typ = typ,}}));
			_PUSH_MANY(&args, (args2), _t8, Array_v__ast__Param);
			v__ast__FnDecl method = (v__ast__FnDecl){
				.name = name,
				.mod = p->mod,
				.is_deprecated = 0,
				.is_pub = true,
				.is_variadic = is_variadic,
				.is_anon = 0,
				.is_noreturn = 0,
				.is_manualfree = 0,
				.is_main = 0,
				.is_test = 0,
				.is_conditional = 0,
				.is_exported = 0,
				.is_keep_alive = 0,
				.is_unsafe = 0,
				.is_markused = 0,
				.receiver = (v__ast__StructField){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.has_default_expr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_pub = 0,.default_val = (string){.str=(byteptr)"", .is_lit=1},.is_mut = 0,.is_global = 0,.is_volatile = 0,.default_expr_typ = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,},
				.receiver_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},
				.is_method = 0,
				.method_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},
				.method_idx = 0,
				.rec_mut = 0,
				.rec_share = 0,
				.language = 0,
				.file_mode = 0,
				.no_body = 0,
				.is_builtin = 0,
				.body_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},
				.file = p->file_name,
				.generic_names = __new_array(0, 0, sizeof(string)),
				.is_direct_arr = 0,
				.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),
				.ctdefine_idx = -1,
				.params = args,
				.stmts = __new_array(0, 0, sizeof(v__ast__Stmt)),
				.defer_stmts = __new_array(0, 0, sizeof(v__ast__DeferStmt)),
				.return_type = _const_v__ast__void_type,
				.return_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},
				.has_return = 0,
				.should_be_skipped = 0,
				.ninstances = 0,
				.has_await = 0,
				.comments = __new_array(0, 0, sizeof(v__ast__Comment)),
				.next_comments = __new_array(0, 0, sizeof(v__ast__Comment)),
				.source_file = 0,
				.scope = p->scope,
				.label_names = __new_array(0, 0, sizeof(string)),
				.pos = v__token__Position_extend(method_start_pos, v__token__Token_position(&p->prev_tok)),
			};
			if (v__token__Kind_is_start_of_type(p->tok.kind) && p->tok.line_nr == line_nr) {
				method.return_type_pos = v__token__Token_position(&p->tok);
				method.return_type = v__parser__Parser_parse_type(p);
				method.return_type_pos = v__token__Position_extend(method.return_type_pos, v__token__Token_position(&p->tok));
				method.pos = v__token__Position_extend(method.pos, method.return_type_pos);
			}
			Array_v__ast__Comment mcomments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = true,.follow_up = 0,});
			Array_v__ast__Comment mnext_comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,});
			method.comments = mcomments;
			method.next_comments = mnext_comments;
			array_push((array*)&methods, _MOV((v__ast__FnDecl[]){ method }));
			v__ast__Fn tmethod = (v__ast__Fn){
				.is_variadic = is_variadic,
				.language = 0,
				.is_pub = true,
				.is_ctor_new = 0,
				.is_deprecated = 0,
				.is_noreturn = 0,
				.is_unsafe = 0,
				.is_placeholder = 0,
				.is_main = 0,
				.is_test = 0,
				.is_keep_alive = 0,
				.is_method = true,
				.no_body = 0,
				.mod = (string){.str=(byteptr)"", .is_lit=1},
				.file = (string){.str=(byteptr)"", .is_lit=1},
				.file_mode = 0,
				.pos = method.pos,
				.return_type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},
				.return_type = method.return_type,
				.receiver_type = typ,
				.name = name,
				.params = args,
				.source_fn = 0,
				.usages = 0,
				.generic_names = __new_array(0, 0, sizeof(string)),
				.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),
				.is_conditional = 0,
				.ctdefine_idx = 0,
			};
			v__ast__TypeSymbol_register_method(ts, tmethod);
			array_push((array*)&info.methods, _MOV((v__ast__Fn[]){ tmethod }));
		} else {
			v__token__Position field_pos = v__token__Token_position(&p->tok);
			string field_name = v__parser__Parser_check_name(p);
			v__token__Position type_pos = v__token__Token_position(&p->tok);
			v__ast__Type field_typ = v__parser__Parser_parse_type(p);
			type_pos = v__token__Position_extend(type_pos, v__token__Token_position(&p->prev_tok));
			Array_v__ast__Comment comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
			for (;;) {
				if (!(p->tok.kind == v__token__Kind__comment)) break;
				array_push((array*)&comments, _MOV((v__ast__Comment[]){ v__parser__Parser_comment(p) }));
				if (p->tok.kind == v__token__Kind__rcbr) {
					break;
				}
			}
			array_push((array*)&fields, _MOV((v__ast__StructField[]){ (v__ast__StructField){
				.pos = field_pos,
				.type_pos = type_pos,
				.comments = comments,
				.has_default_expr = 0,
				.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),
				.is_pub = true,
				.default_val = (string){.str=(byteptr)"", .is_lit=1},
				.is_mut = 0,
				.is_global = 0,
				.is_volatile = 0,
				.default_expr = {0},
				.default_expr_typ = 0,
				.name = field_name,
				.typ = field_typ,
			} }));
			array_push((array*)&info.fields, _MOV((v__ast__StructField[]){ (v__ast__StructField){.pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,},.comments = __new_array(0, 0, sizeof(v__ast__Comment)),.has_default_expr = 0,.attrs = __new_array(0, 0, sizeof(v__ast__Attr)),.is_pub = true,.default_val = (string){.str=(byteptr)"", .is_lit=1},.is_mut = is_mut,.is_global = 0,.is_volatile = 0,.default_expr = {0},.default_expr_typ = 0,.name = field_name,.typ = field_typ,} }));
		}
	}
	Array_v__ast__Type _t14 = __new_array(0, 0, sizeof(v__ast__Type));
	Array_v__ast__InterfaceEmbedding _t14_orig = ifaces;
	int _t14_len = _t14_orig.len;
	_t14 = __new_array(0, _t14_len, sizeof(v__ast__Type));

	for (int _t15 = 0; _t15 < _t14_len; ++_t15) {
		v__ast__InterfaceEmbedding it = ((v__ast__InterfaceEmbedding*) _t14_orig.data)[_t15];
		v__ast__Type ti = it.typ;
		array_push((array*)&_t14, &ti);
	}
	info.ifaces =_t14;
	ts->info = v__ast__Interface_to_sumtype_v__ast__TypeInfo(&info);
	v__parser__Parser_top_level_statement_end(p);
	v__parser__Parser_check(p, v__token__Kind__rcbr);
	pos = v__token__Position_extend_with_last_line(pos, v__token__Token_position(&p->prev_tok), p->prev_tok.line_nr);
	v__ast__InterfaceDecl res = (v__ast__InterfaceDecl){
		.name = interface_name,
		.typ = typ,
		.name_pos = name_pos,
		.language = language,
		.field_names = __new_array(0, 0, sizeof(string)),
		.is_pub = is_pub,
		.mut_pos = mut_pos,
		.pos = pos,
		.pre_comments = pre_comments,
		.generic_types = generic_types,
		.attrs = attrs,
		.methods = methods,
		.fields = fields,
		.ifaces = ifaces,
		.are_ifaces_expanded = 0,
	};
	v__ast__Table_register_interface(p->table, res);
	v__ast__InterfaceDecl _t16 = res;
	return _t16;
}

VV_LOCAL_SYMBOL bool v__parser__is_html_open_tag(string name, string s) {
	int len = s.len;
	if (len < name.len) {
		bool _t1 = false;
		return _t1;
	}
	string sub = string_substr(s, 0, 1);
	if (!string__eq(sub, _SLIT("<"))) {
		bool _t2 = false;
		return _t2;
	}
	sub = string_substr(s, len - 1, len);
	if (!string__eq(sub, _SLIT(">"))) {
		bool _t3 = false;
		return _t3;
	}
	sub = string_substr(s, len - 2, len - 1);
	if (string__eq(sub, _SLIT("/"))) {
		bool _t4 = false;
		return _t4;
	}
	sub = string_substr(s, 1, len - 1);
	if (string_contains_any(sub, _SLIT("<>"))) {
		bool _t5 = false;
		return _t5;
	}
	if (string__eq(sub, name)) {
		bool _t6 = true;
		return _t6;
	} else {
		len = name.len;
		if (sub.len <= len) {
			bool _t7 = false;
			return _t7;
		}
		if (!string__eq(string_substr(sub, 0, len + 1),  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = name}}, {_SLIT(" "), 0, { .d_c = 0 }}})))) {
			bool _t8 = false;
			return _t8;
		}
		bool _t9 = true;
		return _t9;
	}
	return 0;
}

string v__parser__Parser_compile_template_file(v__parser__Parser* p, string template_file, string fn_name) {
	Option_Array_string _t1 = os__read_lines(template_file);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		v__parser__Parser_error(p,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("reading from "), 0xfe10, {.d_s = template_file}}, {_SLIT(" failed"), 0, { .d_c = 0 }}})));
		string _t2 = _SLIT("");
		return _t2;
	}
	
 	Array_string lines =  (*(Array_string*)_t1.data);
	string basepath = os__dir(template_file);
	int lstartlength = lines.len * 30;
	string tmpl_str_start =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("sb_"), 0xfe10, {.d_s = fn_name}}, {_SLIT(".write_string('"), 0, { .d_c = 0 }}}));
	string tmpl_str_end = _SLIT("')\n");
	strings__Builder source = strings__new_builder(1000);
	strings__Builder_writeln(&source,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\nimport strings\n// === vweb html template ===\nfn vweb_tmpl_"), 0xfe10, {.d_s = fn_name}}, {_SLIT("() string {\n	mut sb_"), 0xfe10, {.d_s = fn_name}}, {_SLIT(" := strings.new_builder("), 0xfe07, {.d_i32 = lstartlength}}, {_SLIT(")\n\n\n"), 0, { .d_c = 0 }}})));
	strings__Builder_write_string(&source, tmpl_str_start);
	v__parser__State state = v__parser__State__html;
	bool in_span = false;
	int end_of_line_pos = 0;
	int start_of_line_pos = 0;
	int tline_number = -1;
	for (int i = 0; i < lines.len; i++) {
		string line = (*(string*)/*ee elem_typ */array_get(lines, i));
		tline_number++;
		start_of_line_pos = end_of_line_pos;
		end_of_line_pos += line.len + 1;
		if (v__parser__is_html_open_tag(_SLIT("style"), line)) {
			state = v__parser__State__css;
		} else if (string__eq(line, _SLIT("</style>"))) {
			state = v__parser__State__html;
		} else if (v__parser__is_html_open_tag(_SLIT("script"), line)) {
			state = v__parser__State__js;
		} else if (string__eq(line, _SLIT("</script>"))) {
			state = v__parser__State__html;
		}
		if (string_contains(line, _SLIT("@header"))) {
			Option_int _t3 = string_index(line, _SLIT("@header"));
			if (_t3.state != 0) { /*or block*/ 
				IError err = _t3.err;
				*(int*) _t3.data = 0;
			}
			
 			int position =  (*(int*)_t3.data);
			v__parser__Parser_error_with_error(p, (v__errors__Error){.message = _SLIT("Please use @include 'header' instead of @header (deprecated)"),.details = (string){.str=(byteptr)"", .is_lit=1},.file_path = template_file,.pos = (v__token__Position){.len = _SLIT("@header").len,.line_nr = tline_number,.pos = start_of_line_pos + position,.col = 0,.last_line = lines.len,},.backtrace = (string){.str=(byteptr)"", .is_lit=1},.reporter = v__errors__Reporter__parser,});
		} else if (string_contains(line, _SLIT("@footer"))) {
			Option_int _t4 = string_index(line, _SLIT("@footer"));
			if (_t4.state != 0) { /*or block*/ 
				IError err = _t4.err;
				*(int*) _t4.data = 0;
			}
			
 			int position =  (*(int*)_t4.data);
			v__parser__Parser_error_with_error(p, (v__errors__Error){.message = _SLIT("Please use @include 'footer' instead of @footer (deprecated)"),.details = (string){.str=(byteptr)"", .is_lit=1},.file_path = template_file,.pos = (v__token__Position){.len = _SLIT("@footer").len,.line_nr = tline_number,.pos = start_of_line_pos + position,.col = 0,.last_line = lines.len,},.backtrace = (string){.str=(byteptr)"", .is_lit=1},.reporter = v__errors__Reporter__parser,});
		}
		if (string_contains(line, _SLIT("@include "))) {
			array_delete(&lines, i);
			string file_name = (*(string*)/*ee elem_typ */array_get(string_split(line, _SLIT("'")), 1));
			string file_ext = os__file_ext(file_name);
			if ((file_ext).len == 0) {
				file_ext = _SLIT(".html");
			}
			file_name = string_replace(file_name, file_ext, _SLIT(""));
			string templates_folder = os__real_path(basepath);
			if (string_contains(file_name, _SLIT("/")) && string_starts_with(file_name, _SLIT("/"))) {
				templates_folder = _SLIT("");
			}
			string file_path = os__real_path(os__join_path_single(templates_folder,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = file_name}}, {_SLIT0, 0xfe10, {.d_s = file_ext}}, {_SLIT0, 0, { .d_c = 0 }}}))));
			Option_string _t5 = os__read_file(file_path);
			if (_t5.state != 0) { /*or block*/ 
				IError err = _t5.err;
				Option_int _t6 = string_index(line, _SLIT("@include "));
				if (_t6.state != 0) { /*or block*/ 
					err = _t6.err;
					*(int*) _t6.data = 0;
				}
				
 				int position =  (*(int*)_t6.data) + _SLIT("@include ").len;
				v__parser__Parser_error_with_error(p, (v__errors__Error){.message =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("Reading file "), 0xfe10, {.d_s = file_name}}, {_SLIT(" from path: "), 0xfe10, {.d_s = file_path}}, {_SLIT(" failed"), 0, { .d_c = 0 }}})),.details =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("Failed to @include '"), 0xfe10, {.d_s = file_name}}, {_SLIT("'"), 0, { .d_c = 0 }}})),.file_path = template_file,.pos = (v__token__Position){.len = _SLIT("@include ").len + file_name.len,.line_nr = tline_number,.pos = start_of_line_pos + position,.col = 0,.last_line = lines.len,},.backtrace = (string){.str=(byteptr)"", .is_lit=1},.reporter = v__errors__Reporter__parser,});
				*(string*) _t5.data = _SLIT("");
			}
			
 			string file_content =  (*(string*)_t5.data);
			Array_string file_splitted = array_reverse(string_split_into_lines(file_content));
			for (int _t7 = 0; _t7 < file_splitted.len; ++_t7) {
				string f = ((string*)file_splitted.data)[_t7];
				tline_number--;
				array_insert(&lines, i, &(string[]){string_clone(f)});
			}
			i--;
		} else if (string_contains(line, _SLIT("@js "))) {
			Option_int _t8 = string_index(line, _SLIT("@js"));
			if (_t8.state != 0) { /*or block*/ 
				IError err = _t8.err;
				continue;
			}
			
 			int pos =  (*(int*)_t8.data);
			strings__Builder_write_string(&source, _SLIT("<script src=\""));
			strings__Builder_write_string(&source, string_substr(line, pos + 5, line.len - 1));
			strings__Builder_writeln(&source, _SLIT("\"></script>"));
		} else if (string_contains(line, _SLIT("@css "))) {
			Option_int _t9 = string_index(line, _SLIT("@css"));
			if (_t9.state != 0) { /*or block*/ 
				IError err = _t9.err;
				continue;
			}
			
 			int pos =  (*(int*)_t9.data);
			strings__Builder_write_string(&source, _SLIT("<link href=\""));
			strings__Builder_write_string(&source, string_substr(line, pos + 6, line.len - 1));
			strings__Builder_writeln(&source, _SLIT("\" rel=\"stylesheet\" type=\"text/css\">"));
		} else if (string_contains(line, _SLIT("@if "))) {
			strings__Builder_writeln(&source, tmpl_str_end);
			Option_int _t10 = string_index(line, _SLIT("@if"));
			if (_t10.state != 0) { /*or block*/ 
				IError err = _t10.err;
				continue;
			}
			
 			int pos =  (*(int*)_t10.data);
			strings__Builder_writeln(&source, string__plus(string__plus(_SLIT("if "), string_substr(line, pos + 4, line.len)), _SLIT("{")));
			strings__Builder_writeln(&source, tmpl_str_start);
		} else if (string_contains(line, _SLIT("@end"))) {
			strings__Builder_go_back(&source, 1);
			strings__Builder_writeln(&source, tmpl_str_end);
			strings__Builder_writeln(&source, _SLIT("}"));
			strings__Builder_writeln(&source, tmpl_str_start);
		} else if (string_contains(line, _SLIT("@else"))) {
			strings__Builder_go_back(&source, 1);
			strings__Builder_writeln(&source, tmpl_str_end);
			strings__Builder_writeln(&source, _SLIT(" } else { "));
			strings__Builder_writeln(&source, tmpl_str_start);
		} else if (string_contains(line, _SLIT("@for"))) {
			strings__Builder_writeln(&source, tmpl_str_end);
			Option_int _t11 = string_index(line, _SLIT("@for"));
			if (_t11.state != 0) { /*or block*/ 
				IError err = _t11.err;
				continue;
			}
			
 			int pos =  (*(int*)_t11.data);
			strings__Builder_writeln(&source, string__plus(string__plus(_SLIT("for "), string_substr(line, pos + 4, line.len)), _SLIT("{")));
			strings__Builder_writeln(&source, tmpl_str_start);
		} else if (state == v__parser__State__html && string_starts_with(line, _SLIT("span.")) && string_ends_with(line, _SLIT("{"))) {
			string _v_class = string_trim_space(string_find_between(line, _SLIT("span."), _SLIT("{")));
			strings__Builder_writeln(&source,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("<span class=\""), 0xfe10, {.d_s = _v_class}}, {_SLIT("\">"), 0, { .d_c = 0 }}})));
			in_span = true;
		} else if (state == v__parser__State__html && string_starts_with(string_trim_space(line), _SLIT(".")) && string_ends_with(line, _SLIT("{"))) {
			string _v_class = string_trim_space(string_find_between(line, _SLIT("."), _SLIT("{")));
			string trimmed = string_trim_space(line);
			strings__Builder_write_string(&source, strings__repeat('\t', line.len - trimmed.len));
			strings__Builder_writeln(&source,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("<div class=\""), 0xfe10, {.d_s = _v_class}}, {_SLIT("\">"), 0, { .d_c = 0 }}})));
		} else if (state == v__parser__State__html && string_starts_with(line, _SLIT("#")) && string_ends_with(line, _SLIT("{"))) {
			string _v_class = string_trim_space(string_find_between(line, _SLIT("#"), _SLIT("{")));
			strings__Builder_writeln(&source,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("<div id=\""), 0xfe10, {.d_s = _v_class}}, {_SLIT("\">"), 0, { .d_c = 0 }}})));
		} else if (state == v__parser__State__html && string__eq(string_trim_space(line), _SLIT("}"))) {
			string trimmed = string_trim_space(line);
			strings__Builder_write_string(&source, strings__repeat('\t', line.len - trimmed.len));
			if (in_span) {
				strings__Builder_writeln(&source, _SLIT("</span>"));
				in_span = false;
			} else {
				strings__Builder_writeln(&source, _SLIT("</div>"));
			}
		} else if (state == v__parser__State__js) {
			strings__Builder_writeln(&source, string_replace(string_replace(string_replace(string_replace(line, _SLIT("$"), _SLIT("\\$")), _SLIT("$$"), _SLIT("@")), _SLIT(".$"), _SLIT(".@")), _SLIT("'"), _SLIT("\\'")));
		} else if (state == v__parser__State__css) {
			strings__Builder_writeln(&source, string_replace(string_replace(line, _SLIT(".$"), _SLIT(".@")), _SLIT("'"), _SLIT("\\'")));
		} else {
			string trailing_bs = string__plus(string__plus(tmpl_str_end,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("sb_"), 0xfe10, {.d_s = fn_name}}, {_SLIT(".write_b(92)\n"), 0, { .d_c = 0 }}}))), tmpl_str_start);
			Array_string round1 = new_array_from_c_array(6, 6, sizeof(string), _MOV((string[6]){_SLIT("\\"), _SLIT("\\\\"), _SLIT("'"), _SLIT("\\'"), _SLIT("@"), _SLIT("$")}));
			Array_string round2 = new_array_from_c_array(4, 4, sizeof(string), _MOV((string[4]){_SLIT("$$"), _SLIT("\\@"), _SLIT(".$"), _SLIT(".@")}));
			string rline = string_replace_each(string_replace_each(line, round1), round2);
			if (string_ends_with(rline, _SLIT("\\"))) {
				strings__Builder_writeln(&source, string__plus(string_substr(rline, 0, rline.len - 2), trailing_bs));
			} else {
				strings__Builder_writeln(&source, rline);
			}
		}
	}
	strings__Builder_writeln(&source, tmpl_str_end);
	strings__Builder_writeln(&source,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("_tmpl_res_"), 0xfe10, {.d_s = fn_name}}, {_SLIT(" := sb_"), 0xfe10, {.d_s = fn_name}}, {_SLIT(".str() "), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&source,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("return _tmpl_res_"), 0xfe10, {.d_s = fn_name}}, {_SLIT0, 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&source, _SLIT("}"));
	strings__Builder_writeln(&source, _SLIT("// === end of vweb html template ==="));
	string result = strings__Builder_str(&source);
	string _t12 = result;
	return _t12;
}

void v__callgraph__show(v__ast__Table* table, v__pref__Preferences* pref, Array_v__ast__File_ptr ast_files) {
	v__callgraph__Mapper* mapper = (v__callgraph__Mapper*)memdup(&(v__callgraph__Mapper){.pos = 0,.pref = pref,.table = table,.file = 0,.node = 0,.fn_decl = 0,.caller_name = (string){.str=(byteptr)"", .is_lit=1},.dot_caller_name = (string){.str=(byteptr)"", .is_lit=1},.is_caller_used = 0,.dg = *v__dotgraph__new(_SLIT("CallGraph"),  str_intp(2, _MOV((StrIntpData[]){{_SLIT("CallGraph for "), 0xfe10, {.d_s = pref->path}}, {_SLIT0, 0, { .d_c = 0 }}})), _SLIT("green")),}, sizeof(v__callgraph__Mapper));
	for (int _t1 = 0; _t1 < ast_files.len; ++_t1) {
		v__ast__File* afile = ((v__ast__File**)ast_files.data)[_t1];
		v__ast__walker__walk(HEAP(v__ast__walker__Visitor, /*&v.ast.walker.Visitor*/I_v__callgraph__Mapper_to_Interface_v__ast__walker__Visitor(mapper)), HEAP(v__ast__Node, v__ast__File_to_sumtype_v__ast__Node(afile)));
	}
	v__dotgraph__DotGraph_finish(&mapper->dg);
}

VV_LOCAL_SYMBOL string v__callgraph__Mapper_dot_normalise_node_name(v__callgraph__Mapper* m, string name) {
	string res = string_replace_each(name, new_array_from_c_array(26, 26, sizeof(string), _MOV((string[26]){
			_SLIT("."), _SLIT("_"), _SLIT("=="), _SLIT("op_eq"), _SLIT(">="), _SLIT("op_greater_eq"), _SLIT("<="), _SLIT("op_lesser_eq"), _SLIT(">"),
			_SLIT("op_greater"), _SLIT("<"), _SLIT("op_lesser"), _SLIT("+"), _SLIT("op_plus"), _SLIT("-"), _SLIT("op_minus"), _SLIT("/"),
			_SLIT("op_divide"), _SLIT("*"), _SLIT("op_multiply"), _SLIT("^"), _SLIT("op_xor"), _SLIT("|"), _SLIT("op_or"), _SLIT("&"),
			_SLIT("op_and")})));
	string _t1 = res;
	return _t1;
}

VV_LOCAL_SYMBOL string v__callgraph__Mapper_fn_name(v__callgraph__Mapper* m, string fname, v__ast__Type receiver_type, bool is_method) {
	if (!is_method) {
		string _t1 = fname;
		return _t1;
	}
	v__ast__TypeSymbol* rec_sym = v__ast__Table_sym(m->table, receiver_type);
	string _t2 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = rec_sym->name}}, {_SLIT("."), 0xfe10, {.d_s = fname}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t2;
}

VV_LOCAL_SYMBOL string v__callgraph__Mapper_dot_fn_name(v__callgraph__Mapper* m, string fname, v__ast__Type recv_type, bool is_method) {
	if (is_method) {
		string _t1 = string__plus(string__plus(string__plus(_SLIT("Node_method_"), int_str(((int)(recv_type)))), _SLIT("_")), v__callgraph__Mapper_dot_normalise_node_name(m, fname));
		return _t1;
	}
	string _t2 = string__plus(_SLIT("Node_fn_"), v__callgraph__Mapper_dot_normalise_node_name(m, fname));
	return _t2;
}

VV_LOCAL_SYMBOL Option_void v__callgraph__Mapper_visit(v__callgraph__Mapper* m, v__ast__Node* node) {
	m->node = node;
	if (node->_typ == 207 /* v.ast.File */) {
		m->file = &(*node->_v__ast__File);
	}
	else if (node->_typ == 353 /* v.ast.Stmt */) {
		if ((*node->_v__ast__Stmt)._typ == 216 /* v.ast.FnDecl */) {
			m->is_caller_used = true;
			if (m->pref->skip_unused) {
				m->is_caller_used = (*(bool*)map_get(ADDR(map, m->table->used_fns), &(string[]){v__ast__FnDecl_fkey(&(*(*node->_v__ast__Stmt)._v__ast__FnDecl))}, &(bool[]){ 0 }));
			}
			m->fn_decl = &(*(*node->_v__ast__Stmt)._v__ast__FnDecl);
			m->caller_name = v__callgraph__Mapper_fn_name(m, (*(*node->_v__ast__Stmt)._v__ast__FnDecl).name, (*(*node->_v__ast__Stmt)._v__ast__FnDecl).receiver.typ, (*(*node->_v__ast__Stmt)._v__ast__FnDecl).is_method);
			m->dot_caller_name = v__callgraph__Mapper_dot_fn_name(m, (*(*node->_v__ast__Stmt)._v__ast__FnDecl).name, (*(*node->_v__ast__Stmt)._v__ast__FnDecl).receiver.typ, (*(*node->_v__ast__Stmt)._v__ast__FnDecl).is_method);
			if (m->is_caller_used) {
				v__dotgraph__DotGraph_new_node(&m->dg, m->caller_name, (v__dotgraph__NewNodeConfig){.node_name = m->dot_caller_name,.should_highlight = string__eq(m->caller_name, _SLIT("main.main")),.tooltip = (string){.str=(byteptr)"", .is_lit=1},.ctx = ((voidptr)(0)),.name2node_fn = v__dotgraph__node_name,});
			}
		}
		
		else {
		}
		;
	}
	else if (node->_typ == 328 /* v.ast.Expr */) {
		if ((*node->_v__ast__Expr)._typ == 286 /* v.ast.CallExpr */) {
			if (m->is_caller_used) {
				string dot_called_name = v__callgraph__Mapper_dot_fn_name(m, (*(*node->_v__ast__Expr)._v__ast__CallExpr).name, (*(*node->_v__ast__Expr)._v__ast__CallExpr).receiver_type, (*(*node->_v__ast__Expr)._v__ast__CallExpr).is_method);
				v__dotgraph__DotGraph_new_edge(&m->dg, m->dot_caller_name, dot_called_name, (v__dotgraph__NewEdgeConfig){.should_highlight = string__eq(m->caller_name, _SLIT("main.main")),.ctx = ((voidptr)(0)),.name2node_fn = v__dotgraph__node_name,});
			}
		}
		
		else {
		}
		;
	}
	
	else {
	}
	;
	return (Option_void){0};
}

v__builder__Builder v__builder__new_builder(v__pref__Preferences* pref) {
	string rdir = os__real_path(pref->path);
	string compiled_dir = (os__is_dir(rdir) ? (rdir) : (os__dir(rdir)));
	v__ast__Table* table = v__ast__new_table();
	table->is_fmt = false;
	if (pref->use_color == v__pref__ColorOutput__always) {
		v__util__EManager_set_support_color(_const_v__util__emanager, true);
	}
	if (pref->use_color == v__pref__ColorOutput__never) {
		v__util__EManager_set_support_color(_const_v__util__emanager, false);
	}
	Option_v__builder__MsvcResult _t1 = v__builder__find_msvc(pref->m64);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		if (string__eq(pref->ccompiler, _SLIT("msvc"))) {
		}
		*(v__builder__MsvcResult*) _t1.data = (v__builder__MsvcResult){.full_cl_exe_path = (string){.str=(byteptr)"", .is_lit=1},.exe_path = (string){.str=(byteptr)"", .is_lit=1},.um_lib_path = (string){.str=(byteptr)"", .is_lit=1},.ucrt_lib_path = (string){.str=(byteptr)"", .is_lit=1},.vs_lib_path = (string){.str=(byteptr)"", .is_lit=1},.um_include_path = (string){.str=(byteptr)"", .is_lit=1},.ucrt_include_path = (string){.str=(byteptr)"", .is_lit=1},.vs_include_path = (string){.str=(byteptr)"", .is_lit=1},.shared_include_path = (string){.str=(byteptr)"", .is_lit=1},.valid = false,};
	}
	
 	v__builder__MsvcResult msvc =  (*(v__builder__MsvcResult*)_t1.data);
	v__util__timing_set_should_print(pref->show_timings || pref->is_verbose);
	if (pref->show_callgraph || pref->show_depgraph) {
		v__dotgraph__start_digraph();
	}
	v__builder__Builder _t2 = (v__builder__Builder){
		.compiled_dir = compiled_dir,
		.module_path = (string){.str=(byteptr)"", .is_lit=1},
		.checker = v__checker__new_checker(table, pref),
		.transformer = v__transformer__new_transformer(pref),
		.out_name_c = (string){.str=(byteptr)"", .is_lit=1},
		.out_name_js = (string){.str=(byteptr)"", .is_lit=1},
		.stats_lines = 0,
		.stats_bytes = 0,
		.nr_errors = 0,
		.nr_warnings = 0,
		.nr_notices = 0,
		.pref = pref,
		.module_search_paths = __new_array(0, 0, sizeof(string)),
		.parsed_files = __new_array(0, 0, sizeof(v__ast__File*)),
		.cached_msvc = msvc,
		.table = table,
		.ccoptions = (v__builder__CcompilerOptions){.guessed_compiler = (string){.str=(byteptr)"", .is_lit=1},.shared_postfix = (string){.str=(byteptr)"", .is_lit=1},.debug_mode = 0,.is_cc_tcc = 0,.is_cc_gcc = 0,.is_cc_msvc = 0,.is_cc_clang = 0,.env_cflags = (string){.str=(byteptr)"", .is_lit=1},.env_ldflags = (string){.str=(byteptr)"", .is_lit=1},.args = __new_array(0, 0, sizeof(string)),.wargs = __new_array(0, 0, sizeof(string)),.pre_args = __new_array(0, 0, sizeof(string)),.o_args = __new_array(0, 0, sizeof(string)),.source_args = __new_array(0, 0, sizeof(string)),.post_args = __new_array(0, 0, sizeof(string)),.linker_flags = __new_array(0, 0, sizeof(string)),},
		.mod_invalidates_paths = new_map(sizeof(string), sizeof(Array_string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.mod_invalidates_mods = new_map(sizeof(string), sizeof(Array_string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.path_invalidates_mods = new_map(sizeof(string), sizeof(Array_string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
	};
	return _t2;
}

Option_void v__builder__Builder_front_stages(v__builder__Builder* b, Array_string v_files) {
	v__util__Timers* timers = v__util__get_timers();
	v__util__timing_start(_SLIT("PARSE"));
	v__util__timing_start(_SLIT("Builder.front_stages.parse_files"));
	b->parsed_files = v__parser__parse_files(v_files, b->table, b->pref);
	v__util__Timers_show(timers, _SLIT("Builder.front_stages.parse_files"));
	v__builder__Builder_parse_imports(b);
	v__util__Timers_show(timers, _SLIT("SCAN"));
	v__util__Timers_show(timers, _SLIT("PARSE"));
	v__util__Timers_show_if_exists(timers, _SLIT("PARSE stmt"));
	if (b->pref->only_check_syntax) {
		return (Option_void){ .state=2, .err=error_with_code(_SLIT("stop_after_parser"), 9999), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (Option_void){0};
}

Option_void v__builder__Builder_middle_stages(v__builder__Builder* b) {
	v__util__timing_start(_SLIT("CHECK"));
	v__util__timing_start(_SLIT("Checker.generic_insts_to_concrete"));
	v__ast__Table_generic_insts_to_concrete(b->table);
	v__util__timing_measure(_SLIT("Checker.generic_insts_to_concrete"));
	v__checker__Checker_check_files(b->checker, b->parsed_files);
	v__util__timing_measure(_SLIT("CHECK"));
	v__builder__Builder_print_warnings_and_errors(b);
	if (b->checker->should_abort) {
		return (Option_void){ .state=2, .err=_v_error(_SLIT("too many errors/warnings/notices")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (b->pref->check_only) {
		return (Option_void){ .state=2, .err=error_with_code(_SLIT("stop_after_checker"), 9999), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	v__util__timing_start(_SLIT("TRANSFORM"));
	v__transformer__Transformer_transform_files(b->transformer, b->parsed_files);
	v__util__timing_measure(_SLIT("TRANSFORM"));
	v__ast__Table_complete_interface_check(b->table);
	if (b->pref->skip_unused) {
		v__markused__mark_used(b->table, b->pref, b->parsed_files);
	}
	if (b->pref->show_callgraph) {
		v__callgraph__show(b->table, b->pref, b->parsed_files);
	}
	return (Option_void){0};
}

Option_void v__builder__Builder_front_and_middle_stages(v__builder__Builder* b, Array_string v_files) {
	Option_void _t1 = v__builder__Builder_front_stages(b, v_files);
	if (_t1.state != 0 && _t1.err._typ != _IError_None___index) {
		Option_void _t2;
		memcpy(&_t2, &_t1, sizeof(Option));
		return _t2;
	}
	
 ;
	Option_void _t3 = v__builder__Builder_middle_stages(b);
	if (_t3.state != 0 && _t3.err._typ != _IError_None___index) {
		Option_void _t4;
		memcpy(&_t4, &_t3, sizeof(Option));
		return _t4;
	}
	
 ;
	return (Option_void){0};
}

void v__builder__Builder_parse_imports(v__builder__Builder* b) {
bool v__builder__Builder_parse_imports_defer_0 = false;
	v__util__timing_start(_SLIT("Builder.parse_imports"));
	v__builder__Builder_parse_imports_defer_0 = true;
	Array_string done_imports = __new_array_with_default(0, 0, sizeof(string), 0);
	if (b->pref->is_vsh) {
		array_push((array*)&done_imports, _MOV((string[]){ string_clone(_SLIT("os")) }));
	}
	for (int _t2 = 0; _t2 < b->parsed_files.len; ++_t2) {
		v__ast__File* file = ((v__ast__File**)b->parsed_files.data)[_t2];
		if (!string__eq(file->mod.name, _SLIT("main")) && !Array_string_contains(done_imports, file->mod.name)) {
			array_push((array*)&done_imports, _MOV((string[]){ string_clone(file->mod.name) }));
		}
	}
	for (int i = 0; i < b->parsed_files.len; i++) {
		v__ast__File* ast_file = (*(v__ast__File**)/*ee elem_typ */array_get(b->parsed_files, i));
		array_push((array*)&(*(Array_string*)map_get_and_set((map*)&b->path_invalidates_mods, &(string[]){ast_file->path}, &(Array_string[]){ __new_array(0, 0, sizeof(string)) })), _MOV((string[]){ string_clone(ast_file->mod.name) }));
		if (!string__eq(ast_file->mod.name, _SLIT("builtin"))) {
			array_push((array*)&(*(Array_string*)map_get_and_set((map*)&b->mod_invalidates_paths, &(string[]){_SLIT("builtin")}, &(Array_string[]){ __new_array(0, 0, sizeof(string)) })), _MOV((string[]){ string_clone(ast_file->path) }));
			array_push((array*)&(*(Array_string*)map_get_and_set((map*)&b->mod_invalidates_mods, &(string[]){_SLIT("builtin")}, &(Array_string[]){ __new_array(0, 0, sizeof(string)) })), _MOV((string[]){ string_clone(ast_file->mod.name) }));
		}
		for (int _t7 = 0; _t7 < ast_file->imports.len; ++_t7) {
			v__ast__Import imp = ((v__ast__Import*)ast_file->imports.data)[_t7];
			string mod = imp.mod;
			array_push((array*)&(*(Array_string*)map_get_and_set((map*)&b->mod_invalidates_paths, &(string[]){mod}, &(Array_string[]){ __new_array(0, 0, sizeof(string)) })), _MOV((string[]){ string_clone(ast_file->path) }));
			array_push((array*)&(*(Array_string*)map_get_and_set((map*)&b->mod_invalidates_mods, &(string[]){mod}, &(Array_string[]){ __new_array(0, 0, sizeof(string)) })), _MOV((string[]){ string_clone(ast_file->mod.name) }));
			if (string__eq(mod, _SLIT("builtin"))) {
				array_push((array*)&(*(v__ast__File**)/*ee elem_typ */array_get(b->parsed_files, i))->errors, _MOV((v__errors__Error[]){ v__builder__Builder_error_with_pos(b, _SLIT("cannot import module \"builtin\""), ast_file->path, imp.pos) }));
				break;
			}
			if (Array_string_contains(done_imports, mod)) {
				continue;
			}
			Option_string _t11 = v__builder__Builder_find_module_path(b, mod, ast_file->path);
			if (_t11.state != 0) { /*or block*/ 
				IError err = _t11.err;
				array_push((array*)&(*(v__ast__File**)/*ee elem_typ */array_get(b->parsed_files, i))->errors, _MOV((v__errors__Error[]){ v__builder__Builder_error_with_pos(b,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot import module \""), 0xfe10, {.d_s = mod}}, {_SLIT("\" (not found)"), 0, { .d_c = 0 }}})), ast_file->path, imp.pos) }));
				break;
			}
			
 			string import_path =  (*(string*)_t11.data);
			Array_string v_files = v__builder__Builder_v_files_from_dir(b, import_path);
			if (v_files.len == 0) {
				array_push((array*)&(*(v__ast__File**)/*ee elem_typ */array_get(b->parsed_files, i))->errors, _MOV((v__errors__Error[]){ v__builder__Builder_error_with_pos(b,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("cannot import module \""), 0xfe10, {.d_s = mod}}, {_SLIT("\" (no .v files in \""), 0xfe10, {.d_s = import_path}}, {_SLIT("\")"), 0, { .d_c = 0 }}})), ast_file->path, imp.pos) }));
				continue;
			}
			Array_v__ast__File_ptr parsed_files = v__parser__parse_files(v_files, b->table, b->pref);
			for (int _t14 = 0; _t14 < parsed_files.len; ++_t14) {
				v__ast__File* file = ((v__ast__File**)parsed_files.data)[_t14];
				string name = file->mod.name;
				if ((name).len == 0) {
					name = file->mod.short_name;
				}
				string sname = string_all_after_last(name, _SLIT("."));
				string smod = string_all_after_last(mod, _SLIT("."));
				if (!string__eq(sname, smod)) {
					string msg =  str_intp(5, _MOV((StrIntpData[]){{_SLIT("bad module definition: "), 0xfe10, {.d_s = ast_file->path}}, {_SLIT(" imports module \""), 0xfe10, {.d_s = mod}}, {_SLIT("\" but "), 0xfe10, {.d_s = file->path}}, {_SLIT(" is defined as module `"), 0xfe10, {.d_s = name}}, {_SLIT("`"), 0, { .d_c = 0 }}}));
					array_push((array*)&(*(v__ast__File**)/*ee elem_typ */array_get(b->parsed_files, i))->errors, _MOV((v__errors__Error[]){ v__builder__Builder_error_with_pos(b, msg, ast_file->path, imp.pos) }));
				}
			}
			_PUSH_MANY(&b->parsed_files, (parsed_files), _t16, Array_v__ast__File_ptr);
			array_push((array*)&done_imports, _MOV((string[]){ string_clone(mod) }));
		}
	}
	v__builder__Builder_resolve_deps(b);
	if (b->pref->print_v_files) {
		for (int _t18 = 0; _t18 < b->parsed_files.len; ++_t18) {
			v__ast__File* p = ((v__ast__File**)b->parsed_files.data)[_t18];
			println(p->path);
		}
		_v_exit(0);
		VUNREACHABLE();
	}
	v__builder__Builder_rebuild_modules(b);
// Defer begin
if (v__builder__Builder_parse_imports_defer_0) {
	v__util__timing_measure(_SLIT("Builder.parse_imports"));
}
// Defer end
}

void v__builder__Builder_resolve_deps(v__builder__Builder* b) {
bool v__builder__Builder_resolve_deps_defer_0 = false;
	v__util__timing_start(_SLIT("Builder.resolve_deps"));
	v__builder__Builder_resolve_deps_defer_0 = true;
	v__depgraph__DepGraph* graph = v__builder__Builder_import_graph(b);
	v__depgraph__DepGraph* deps_resolved = v__depgraph__DepGraph_resolve(graph);
	if (b->pref->is_verbose) {
		eprintln(_SLIT("------ resolved dependencies graph: ------"));
		eprintln(v__depgraph__DepGraph_display(deps_resolved));
		eprintln(_SLIT("------------------------------------------"));
	}
	if (b->pref->show_depgraph) {
		v__depgraph__show(deps_resolved, b->pref->path);
	}
	string cycles = v__depgraph__DepGraph_display_cycles(deps_resolved);
	if (cycles.len > 1) {
		v__builder__verror(string__plus(_SLIT("error: import cycle detected between the following modules: \n"), cycles));
		VUNREACHABLE();
	}
	Array_string mods = __new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t1 = 0; _t1 < deps_resolved->nodes.len; ++_t1) {
		v__depgraph__DepGraphNode node = ((v__depgraph__DepGraphNode*)deps_resolved->nodes.data)[_t1];
		array_push((array*)&mods, _MOV((string[]){ string_clone(node.name) }));
	}
	if (b->pref->is_verbose) {
		eprintln(_SLIT("------ imported modules: ------"));
		eprintln(Array_string_str(mods));
		eprintln(_SLIT("-------------------------------"));
	}
	Array_v__ast__File_ptr reordered_parsed_files = __new_array_with_default(0, 0, sizeof(v__ast__File*), 0);
	for (int _t3 = 0; _t3 < mods.len; ++_t3) {
		string m = ((string*)mods.data)[_t3];
		for (int _t4 = 0; _t4 < b->parsed_files.len; ++_t4) {
			v__ast__File* pf = ((v__ast__File**)b->parsed_files.data)[_t4];
			if (string__eq(m, pf->mod.name)) {
				array_push((array*)&reordered_parsed_files, _MOV((v__ast__File*[]){ pf }));
			}
		}
	}
	b->table->modules = mods;
	b->parsed_files = reordered_parsed_files;
// Defer begin
if (v__builder__Builder_resolve_deps_defer_0) {
	v__util__timing_measure(_SLIT("Builder.resolve_deps"));
}
// Defer end
}

v__depgraph__DepGraph* v__builder__Builder_import_graph(v__builder__Builder* b) {
	Array_string builtins = array_clone_to_depth(&_const_v__util__builtin_module_parts, 0);
	v__depgraph__DepGraph* graph = v__depgraph__new_dep_graph();
	for (int _t1 = 0; _t1 < b->parsed_files.len; ++_t1) {
		v__ast__File* p = ((v__ast__File**)b->parsed_files.data)[_t1];
		Array_string deps = __new_array_with_default(0, 0, sizeof(string), 0);
		if (!Array_string_contains(builtins, p->mod.name)) {
			array_push((array*)&deps, _MOV((string[]){ string_clone(_SLIT("builtin")) }));
			if (b->pref->backend == v__pref__Backend__c) {
				if (b->pref->is_vsh && !(string__eq(p->mod.name, _SLIT("os")) || string__eq(p->mod.name, _SLIT("dl")))) {
					array_push((array*)&deps, _MOV((string[]){ string_clone(_SLIT("os")) }));
				}
			}
		}
		for (int _t4 = 0; _t4 < p->imports.len; ++_t4) {
			v__ast__Import m = ((v__ast__Import*)p->imports.data)[_t4];
			if (string__eq(m.mod, p->mod.name)) {
				continue;
			}
			array_push((array*)&deps, _MOV((string[]){ string_clone(m.mod) }));
		}
		v__depgraph__DepGraph_add(graph, p->mod.name, deps);
	}
	v__depgraph__DepGraph* _t6 = graph;
	return _t6;
}

Array_string v__builder__Builder_v_files_from_dir(v__builder__Builder* b, string dir) {
	if (!os__exists(dir)) {
		if (string__eq(dir, _SLIT("compiler")) && os__is_dir(_SLIT("vlib"))) {
			println(_SLIT("looks like you are trying to build V with an old command"));
			println(_SLIT("use `v -o v cmd/v` instead of `v -o v compiler`"));
		}
		v__builder__verror( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = dir}}, {_SLIT(" doesn't exist"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	} else if (!os__is_dir(dir)) {
		v__builder__verror( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = dir}}, {_SLIT(" isn't a directory!"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	Option_Array_string _t1 = os__ls(dir);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		_v_panic(IError_str(err));
		VUNREACHABLE();
	;
	}
	
 	Array_string files =  (*(Array_string*)_t1.data);
	if (b->pref->is_verbose) {
		println( str_intp(2, _MOV((StrIntpData[]){{_SLIT("v_files_from_dir (\""), 0xfe10, {.d_s = dir}}, {_SLIT("\")"), 0, { .d_c = 0 }}})));
	}
	Array_string _t2 = v__pref__Preferences_should_compile_filtered_files(b->pref, dir, files);
	return _t2;
}

void v__builder__Builder_log(v__builder__Builder* b, string s) {
	if (b->pref->is_verbose) {
		println(s);
	}
}

void v__builder__Builder_info(v__builder__Builder* b, string s) {
	if (b->pref->is_verbose) {
		println(s);
	}
}

// Attr: [inline]
inline string v__builder__module_path(string mod) {
	string _t1 = string_replace(mod, _SLIT("."), _const_os__path_separator);
	return _t1;
}

Option_string v__builder__Builder_find_module_path(v__builder__Builder* b, string mod, string fpath) {
	v__vmod__ModFileCacher* mcache = v__vmod__get_cache();
	v__vmod__ModFileAndFolder vmod_file_location = v__vmod__ModFileCacher_get_by_file(mcache, fpath);
	string mod_path = v__builder__module_path(mod);
	Array_string module_lookup_paths = __new_array_with_default(0, 0, sizeof(string), 0);
	if (vmod_file_location.vmod_file.len != 0 && !Array_string_contains(b->module_search_paths, vmod_file_location.vmod_folder)) {
		array_push((array*)&module_lookup_paths, _MOV((string[]){ string_clone(vmod_file_location.vmod_folder) }));
	}
	_PUSH_MANY(&module_lookup_paths, (b->module_search_paths), _t2, Array_string);
	array_push((array*)&module_lookup_paths, _MOV((string[]){ string_clone(os__getwd()) }));
	if (string_contains(fpath, string__plus(string__plus(_const_os__path_separator, _SLIT("modules")), _const_os__path_separator))) {
		Array_string parts = string_split(fpath, _const_os__path_separator);
		for (int i = parts.len - 2; i >= 0; i--) {
			if (string__eq((*(string*)/*ee elem_typ */array_get(parts, i)), _SLIT("modules"))) {
				array_push((array*)&module_lookup_paths, _MOV((string[]){ string_clone(Array_string_join(array_slice(parts, 0, i + 1), _const_os__path_separator)) }));
				break;
			}
		}
	}
	for (int _t5 = 0; _t5 < module_lookup_paths.len; ++_t5) {
		string search_path = ((string*)module_lookup_paths.data)[_t5];
		string try_path = os__join_path(search_path, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){mod_path})));
		if (b->pref->is_verbose) {
			println( str_intp(3, _MOV((StrIntpData[]){{_SLIT("  >> trying to find "), 0xfe10, {.d_s = mod}}, {_SLIT(" in "), 0xfe10, {.d_s = try_path}}, {_SLIT(" .."), 0, { .d_c = 0 }}})));
		}
		if (os__is_dir(try_path)) {
			if (b->pref->is_verbose) {
				println( str_intp(2, _MOV((StrIntpData[]){{_SLIT("  << found "), 0xfe10, {.d_s = try_path}}, {_SLIT(" ."), 0, { .d_c = 0 }}})));
			}
			Option_string _t6;
			opt_ok(&(string[]) { try_path }, (Option*)(&_t6), sizeof(string));
			return _t6;
		}
	}
	Array_string path_parts = string_split(fpath, _const_os__path_separator);
	for (int i = path_parts.len - 2; i > 0; i--) {
		string p1 = Array_string_join(array_slice(path_parts, 0, i), _const_os__path_separator);
		string try_path = os__join_path(p1, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){mod_path})));
		if (b->pref->is_verbose) {
			println( str_intp(3, _MOV((StrIntpData[]){{_SLIT("  >> trying to find "), 0xfe10, {.d_s = mod}}, {_SLIT(" in "), 0xfe10, {.d_s = try_path}}, {_SLIT(" .."), 0, { .d_c = 0 }}})));
		}
		if (os__is_dir(try_path)) {
			Option_string _t7;
			opt_ok(&(string[]) { try_path }, (Option*)(&_t7), sizeof(string));
			return _t7;
		}
	}
	string smodule_lookup_paths = Array_string_join(module_lookup_paths, _SLIT(", "));
	return (Option_string){ .state=2, .err=_v_error( str_intp(3, _MOV((StrIntpData[]){{_SLIT("module \""), 0xfe10, {.d_s = mod}}, {_SLIT("\" not found in:\n"), 0xfe10, {.d_s = smodule_lookup_paths}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
}

void v__builder__Builder_show_total_warns_and_errors_stats(v__builder__Builder* b) {
	if (b->nr_errors == 0 && b->nr_warnings == 0 && b->nr_notices == 0) {
		return;
	}
	if (b->pref->is_stats) {
		int nr_errors = b->checker->errors.len;
		int nr_warnings = b->checker->warnings.len;
		int nr_notices = b->checker->notices.len;
		if (b->pref->check_only) {
			nr_errors = b->nr_errors;
			nr_warnings = b->nr_warnings;
			nr_notices = b->nr_notices;
		}
		string estring = v__util__bold(int_str(nr_errors));
		string wstring = v__util__bold(int_str(nr_warnings));
		string nstring = v__util__bold(int_str(nr_notices));
		if (b->pref->check_only) {
			println( str_intp(4, _MOV((StrIntpData[]){{_SLIT("summary: "), 0xfe10, {.d_s = estring}}, {_SLIT(" V errors, "), 0xfe10, {.d_s = wstring}}, {_SLIT(" V warnings, "), 0xfe10, {.d_s = nstring}}, {_SLIT(" V notices"), 0, { .d_c = 0 }}})));
		} else {
			println( str_intp(4, _MOV((StrIntpData[]){{_SLIT("checker summary: "), 0xfe10, {.d_s = estring}}, {_SLIT(" V errors, "), 0xfe10, {.d_s = wstring}}, {_SLIT(" V warnings, "), 0xfe10, {.d_s = nstring}}, {_SLIT(" V notices"), 0, { .d_c = 0 }}})));
		}
	}
}

void v__builder__Builder_print_warnings_and_errors(v__builder__Builder* b) {
bool v__builder__Builder_print_warnings_and_errors_defer_0 = false;
	v__builder__Builder_print_warnings_and_errors_defer_0 = true;
	for (int _t1 = 0; _t1 < b->parsed_files.len; ++_t1) {
		v__ast__File* file = ((v__ast__File**)b->parsed_files.data)[_t1];
		b->nr_errors += file->errors.len;
		b->nr_warnings += file->warnings.len;
		b->nr_notices += file->notices.len;
	}
	if (b->pref->output_mode == v__pref__OutputMode__silent) {
		if (b->nr_errors > 0) {
			_v_exit(1);
			VUNREACHABLE();
		}
		// Defer begin
		if (v__builder__Builder_print_warnings_and_errors_defer_0) {
			v__builder__Builder_show_total_warns_and_errors_stats(b);
		}
		// Defer end
		return;
	}
	if (b->pref->check_only) {
		for (int _t2 = 0; _t2 < b->parsed_files.len; ++_t2) {
			v__ast__File* file = ((v__ast__File**)b->parsed_files.data)[_t2];
			if (!b->pref->skip_warnings) {
				for (int _t3 = 0; _t3 < file->notices.len; ++_t3) {
					v__errors__Notice err = ((v__errors__Notice*)file->notices.data)[_t3];
					string kind = (b->pref->is_verbose ? ( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__errors__Reporter_str(err.reporter)}}, {_SLIT(" notice #"), 0xfe07, {.d_i32 = b->nr_notices}}, {_SLIT(":"), 0, { .d_c = 0 }}}))) : (_SLIT("notice:")));
					string ferror = v__util__formatted_error(kind, err.message, err.file_path, err.pos);
					eprintln(ferror);
					if (err.details.len > 0) {
						eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Details: "), 0xfe10, {.d_s = err.details}}, {_SLIT0, 0, { .d_c = 0 }}})));
					}
				}
			}
		}
		for (int _t4 = 0; _t4 < b->parsed_files.len; ++_t4) {
			v__ast__File* file = ((v__ast__File**)b->parsed_files.data)[_t4];
			for (int _t5 = 0; _t5 < file->errors.len; ++_t5) {
				v__errors__Error err = ((v__errors__Error*)file->errors.data)[_t5];
				string kind = (b->pref->is_verbose ? ( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__errors__Reporter_str(err.reporter)}}, {_SLIT(" error #"), 0xfe07, {.d_i32 = b->nr_errors}}, {_SLIT(":"), 0, { .d_c = 0 }}}))) : (_SLIT("error:")));
				string ferror = v__util__formatted_error(kind, err.message, err.file_path, err.pos);
				eprintln(ferror);
				if (err.details.len > 0) {
					eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Details: "), 0xfe10, {.d_s = err.details}}, {_SLIT0, 0, { .d_c = 0 }}})));
				}
			}
		}
		for (int _t6 = 0; _t6 < b->parsed_files.len; ++_t6) {
			v__ast__File* file = ((v__ast__File**)b->parsed_files.data)[_t6];
			if (!b->pref->skip_warnings) {
				for (int _t7 = 0; _t7 < file->warnings.len; ++_t7) {
					v__errors__Warning err = ((v__errors__Warning*)file->warnings.data)[_t7];
					string kind = (b->pref->is_verbose ? ( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__errors__Reporter_str(err.reporter)}}, {_SLIT(" warning #"), 0xfe07, {.d_i32 = b->nr_warnings}}, {_SLIT(":"), 0, { .d_c = 0 }}}))) : (_SLIT("warning:")));
					string ferror = v__util__formatted_error(kind, err.message, err.file_path, err.pos);
					eprintln(ferror);
					if (err.details.len > 0) {
						eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Details: "), 0xfe10, {.d_s = err.details}}, {_SLIT0, 0, { .d_c = 0 }}})));
					}
				}
			}
		}
		v__builder__Builder_show_total_warns_and_errors_stats(b);
		if (b->nr_errors > 0) {
			_v_exit(1);
			VUNREACHABLE();
		}
		_v_exit(0);
		VUNREACHABLE();
	}
	if (b->pref->is_verbose && b->checker->nr_warnings > 1) {
		println( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = b->checker->nr_warnings}}, {_SLIT(" warnings"), 0, { .d_c = 0 }}})));
	}
	if (b->pref->is_verbose && b->checker->nr_notices > 1) {
		println( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = b->checker->nr_notices}}, {_SLIT(" notices"), 0, { .d_c = 0 }}})));
	}
	if (b->checker->nr_notices > 0 && !b->pref->skip_warnings) {
		for (int _t8 = 0; _t8 < b->checker->notices.len; ++_t8) {
			v__errors__Notice err = ((v__errors__Notice*)b->checker->notices.data)[_t8];
			string kind = (b->pref->is_verbose ? ( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__errors__Reporter_str(err.reporter)}}, {_SLIT(" notice #"), 0xfe07, {.d_i32 = b->checker->nr_notices}}, {_SLIT(":"), 0, { .d_c = 0 }}}))) : (_SLIT("notice:")));
			string ferror = v__util__formatted_error(kind, err.message, err.file_path, err.pos);
			eprintln(ferror);
			if (err.details.len > 0) {
				eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Details: "), 0xfe10, {.d_s = err.details}}, {_SLIT0, 0, { .d_c = 0 }}})));
			}
		}
	}
	if (b->checker->nr_warnings > 0 && !b->pref->skip_warnings) {
		for (int _t9 = 0; _t9 < b->checker->warnings.len; ++_t9) {
			v__errors__Warning err = ((v__errors__Warning*)b->checker->warnings.data)[_t9];
			string kind = (b->pref->is_verbose ? ( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__errors__Reporter_str(err.reporter)}}, {_SLIT(" warning #"), 0xfe07, {.d_i32 = b->checker->nr_warnings}}, {_SLIT(":"), 0, { .d_c = 0 }}}))) : (_SLIT("warning:")));
			string ferror = v__util__formatted_error(kind, err.message, err.file_path, err.pos);
			eprintln(ferror);
			if (err.details.len > 0) {
				eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Details: "), 0xfe10, {.d_s = err.details}}, {_SLIT0, 0, { .d_c = 0 }}})));
			}
		}
	}
	if (b->pref->is_verbose && b->checker->nr_errors > 1) {
		println( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = b->checker->nr_errors}}, {_SLIT(" errors"), 0, { .d_c = 0 }}})));
	}
	if (b->checker->nr_errors > 0) {
		for (int _t10 = 0; _t10 < b->checker->errors.len; ++_t10) {
			v__errors__Error err = ((v__errors__Error*)b->checker->errors.data)[_t10];
			string kind = (b->pref->is_verbose ? ( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__errors__Reporter_str(err.reporter)}}, {_SLIT(" error #"), 0xfe07, {.d_i32 = b->checker->nr_errors}}, {_SLIT(":"), 0, { .d_c = 0 }}}))) : (_SLIT("error:")));
			string ferror = v__util__formatted_error(kind, err.message, err.file_path, err.pos);
			eprintln(ferror);
			if (err.details.len > 0) {
				eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Details: "), 0xfe10, {.d_s = err.details}}, {_SLIT0, 0, { .d_c = 0 }}})));
			}
		}
		v__builder__Builder_show_total_warns_and_errors_stats(b);
		_v_exit(1);
		VUNREACHABLE();
	}
	if (b->table->redefined_fns.len > 0) {
		int total_conflicts = 0;
		for (int _t11 = 0; _t11 < b->table->redefined_fns.len; ++_t11) {
			string fn_name = ((string*)b->table->redefined_fns.data)[_t11];
			Array_v__builder__FunctionRedefinition redefines = __new_array_with_default(0, 0, sizeof(v__builder__FunctionRedefinition), 0);
			Map_string_int redefine_conflicts = new_map(sizeof(string), sizeof(int), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
			for (int _t12 = 0; _t12 < b->parsed_files.len; ++_t12) {
				v__ast__File* file = ((v__ast__File**)b->parsed_files.data)[_t12];
				for (int _t13 = 0; _t13 < file->stmts.len; ++_t13) {
					v__ast__Stmt stmt = ((v__ast__Stmt*)file->stmts.data)[_t13];
					if ((stmt)._typ == 216 /* v.ast.FnDecl */) {
						if (string__eq((*stmt._v__ast__FnDecl).name, fn_name)) {
							string fheader = v__ast__FnDecl_stringify(&(*stmt._v__ast__FnDecl), b->table, _SLIT("main"), new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string));
							array_push((array*)&redefines, _MOV((v__builder__FunctionRedefinition[]){ (v__builder__FunctionRedefinition){.fpath = file->path,.fline = (*stmt._v__ast__FnDecl).pos.line_nr,.fheader = fheader,.f = (*stmt._v__ast__FnDecl),} }));
							(*(int*)map_get_and_set((map*)&redefine_conflicts, &(string[]){fheader}, &(int[]){ 0 }))++;
						}
					}
				}
			}
			if (redefines.len > 0) {
				eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("redefinition of function `"), 0xfe10, {.d_s = fn_name}}, {_SLIT("`"), 0, { .d_c = 0 }}})));
				for (int _t15 = 0; _t15 < redefines.len; ++_t15) {
					v__builder__FunctionRedefinition redefine = ((v__builder__FunctionRedefinition*)redefines.data)[_t15];
					eprintln(v__util__formatted_error(_SLIT("conflicting declaration:"), redefine.fheader, redefine.fpath, redefine.f.pos));
				}
				total_conflicts++;
			}
		}
		if (total_conflicts > 0) {
			v__builder__Builder_show_total_warns_and_errors_stats(b);
			_v_exit(1);
			VUNREACHABLE();
		}
	}
// Defer begin
if (v__builder__Builder_print_warnings_and_errors_defer_0) {
	v__builder__Builder_show_total_warns_and_errors_stats(b);
}
// Defer end
}

v__errors__Error v__builder__Builder_error_with_pos(v__builder__Builder* b, string s, string fpath, v__token__Position pos) {
	if (!b->pref->check_only) {
		string ferror = v__util__formatted_error(_SLIT("builder error:"), s, fpath, pos);
		eprintln(ferror);
		_v_exit(1);
		VUNREACHABLE();
	}
	v__errors__Error _t1 = (v__errors__Error){.message = s,.details = (string){.str=(byteptr)"", .is_lit=1},.file_path = fpath,.pos = pos,.backtrace = (string){.str=(byteptr)"", .is_lit=1},.reporter = v__errors__Reporter__builder,};
	return _t1;
}

// Attr: [noreturn]
VNORETURN void v__builder__verror(string s) {
	v__util__verror(_SLIT("builder error"), s);
	VUNREACHABLE();
	while(1);
}

Option_void v__builder__Builder_find_win_cc(v__builder__Builder* v) {
	os__Result ccompiler_version_res = os__execute( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v->pref->ccompiler}}, {_SLIT(" -v"), 0, { .d_c = 0 }}})));
	if (ccompiler_version_res.exit_code != 0) {
		if (v->pref->is_verbose) {
			println( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v->pref->ccompiler}}, {_SLIT(" not found, looking for msvc..."), 0, { .d_c = 0 }}})));
		}
		Option_v__builder__MsvcResult _t1 = v__builder__find_msvc(v->pref->m64);
		if (_t1.state != 0) { /*or block*/ 
			IError err = _t1.err;
			if (v->pref->is_verbose) {
				println(_SLIT("msvc not found, looking for thirdparty/tcc..."));
			}
			string vpath = os__dir(v__pref__vexe_path());
			string thirdparty_tcc = os__join_path(vpath, new_array_from_c_array(3, 3, sizeof(string), _MOV((string[3]){_SLIT("thirdparty"), _SLIT("tcc"), _SLIT("tcc.exe")})));
			os__Result tcc_version_res = os__execute( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = thirdparty_tcc}}, {_SLIT(" -v"), 0, { .d_c = 0 }}})));
			if (tcc_version_res.exit_code != 0) {
				if (v->pref->is_verbose) {
					println(_SLIT("tcc not found"));
				}
				return (Option_void){ .state=2, .err=_v_error(_SLIT("tcc not found")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			v->pref->ccompiler = thirdparty_tcc;
			v->pref->ccompiler_type = v__pref__CompilerType__tinyc;
			return (Option_void){0};
		}
		
  (*(v__builder__MsvcResult*)_t1.data);
		v->pref->ccompiler = _SLIT("msvc");
		v->pref->ccompiler_type = v__pref__CompilerType__msvc;
		return (Option_void){0};
	}
	v->pref->ccompiler_type = v__pref__cc_from_string(v->pref->ccompiler);
	return (Option_void){0};
}

VV_LOCAL_SYMBOL void v__builder__Builder_show_c_compiler_output(v__builder__Builder* v, os__Result res) {
	println(_SLIT("======== C Compiler output ========"));
	println(res.output);
	println(_SLIT("================================="));
}

VV_LOCAL_SYMBOL void v__builder__Builder_post_process_c_compiler_output(v__builder__Builder* v, os__Result res) {
	if (res.exit_code == 0) {
		if (v->pref->reuse_tmpc) {
			return;
		}
		for (int _t1 = 0; _t1 < v->pref->cleanup_files.len; ++_t1) {
			string tmpfile = ((string*)v->pref->cleanup_files.data)[_t1];
			if (os__is_file(tmpfile)) {
				if (v->pref->is_verbose) {
					eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT(">> remove tmp file: "), 0xfe10, {.d_s = tmpfile}}, {_SLIT0, 0, { .d_c = 0 }}})));
				}
				Option_void _t2 = os__rm(tmpfile);
				if (_t2.state != 0 && _t2.err._typ != _IError_None___index) {
					IError err = _t2.err;
				}
				
 ;
			}
		}
		return;
	}
	Array_string _t3 = new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){string_clone(_const_v__builder__c_verror_message_marker), _SLIT("error: include file ")}));
	for (int _t4 = 0; _t4 < _t3.len; ++_t4) {
		string emsg_marker = ((string*)_t3.data)[_t4];
		if (string_contains(res.output, emsg_marker)) {
			string emessage = string_trim_right(string_all_before(string_all_before(string_all_after(res.output, emsg_marker), _SLIT("\n")), _SLIT("\r")), _SLIT("\r\n"));
			v__builder__verror(emessage);
			VUNREACHABLE();
		}
	}
	if (v->pref->is_debug) {
		string eword = _SLIT("error:");
		string khighlight = (term__can_show_color_on_stdout() ? (term__red(eword)) : (eword));
		println(string_replace(string_trim_right(res.output, _SLIT("\r\n")), eword, khighlight));
	} else {
		if (res.output.len < 30) {
			println(res.output);
		} else {
			Array_string elines = v__builder__error_context_lines(res.output, _SLIT("error:"), 1, 12);
			println(_SLIT("=================="));
			for (int _t5 = 0; _t5 < elines.len; ++_t5) {
				string eline = ((string*)elines.data)[_t5];
				println(eline);
			}
			println(_SLIT("..."));
			println(_SLIT("=================="));
			println(_SLIT("(Use `v -cg` to print the entire error message)\n"));
		}
	}
	v__builder__verror(_const_v__builder__c_error_info);
	VUNREACHABLE();
}

VV_LOCAL_SYMBOL void v__builder__Builder_show_cc(v__builder__Builder* v, string cmd, string response_file, string response_file_content) {
	if (v->pref->is_verbose || v->pref->show_cc) {
		println( str_intp(2, _MOV((StrIntpData[]){{_SLIT("> C compiler cmd: "), 0xfe10, {.d_s = cmd}}, {_SLIT0, 0, { .d_c = 0 }}})));
		if (v->pref->show_cc && !v->pref->no_rsp) {
			println( str_intp(2, _MOV((StrIntpData[]){{_SLIT("> C compiler response file \""), 0xfe10, {.d_s = response_file}}, {_SLIT("\":"), 0, { .d_c = 0 }}})));
			println(response_file_content);
		}
	}
}

VV_LOCAL_SYMBOL void v__builder__Builder_setup_ccompiler_options(v__builder__Builder* v, string ccompiler) {
	v__builder__CcompilerOptions ccoptions = (v__builder__CcompilerOptions){.guessed_compiler = (string){.str=(byteptr)"", .is_lit=1},.shared_postfix = (string){.str=(byteptr)"", .is_lit=1},.debug_mode = 0,.is_cc_tcc = 0,.is_cc_gcc = 0,.is_cc_msvc = 0,.is_cc_clang = 0,.env_cflags = (string){.str=(byteptr)"", .is_lit=1},.env_ldflags = (string){.str=(byteptr)"", .is_lit=1},.args = __new_array(0, 0, sizeof(string)),.wargs = __new_array(0, 0, sizeof(string)),.pre_args = __new_array(0, 0, sizeof(string)),.o_args = __new_array(0, 0, sizeof(string)),.source_args = __new_array(0, 0, sizeof(string)),.post_args = __new_array(0, 0, sizeof(string)),.linker_flags = __new_array(0, 0, sizeof(string)),};
	Array_string debug_options = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("-g")}));
	Array_string optimization_options = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("-O2")}));
	ccoptions.args = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){string_clone(v->pref->cflags)}));
	if (!v->pref->no_std) {
		if (v->pref->os == v__pref__OS__linux) {
			array_push((array*)&ccoptions.args, _MOV((string[]){ string_clone(_SLIT("-std=gnu99 -D_DEFAULT_SOURCE")) }));
		} else {
			array_push((array*)&ccoptions.args, _MOV((string[]){ string_clone(_SLIT("-std=c99 -D_DEFAULT_SOURCE")) }));
		}
	}
	ccoptions.wargs = new_array_from_c_array(27, 27, sizeof(string), _MOV((string[27]){
			_SLIT("-Wall"), _SLIT("-Wextra"), _SLIT("-Werror"), _SLIT("-Wno-unused-parameter"), _SLIT("-Wno-unused"), _SLIT("-Wno-type-limits"), _SLIT("-Wno-tautological-compare"), _SLIT("-Wno-shadow"), _SLIT("-Wno-int-to-pointer-cast"),
			_SLIT("-Wno-trigraphs"), _SLIT("-Wno-missing-braces"), _SLIT("-Wno-unknown-warning"), _SLIT("-Wno-unknown-warning-option"), _SLIT("-Wno-excess-initializers"), _SLIT("-Wdate-time"), _SLIT("-Wduplicated-branches"), _SLIT("-Wduplicated-cond"),
			_SLIT("-Winit-self"), _SLIT("-Winvalid-pch"), _SLIT("-Wjump-misses-init"), _SLIT("-Wlogical-op"), _SLIT("-Wmultichar"), _SLIT("-Wnested-externs"), _SLIT("-Wnull-dereference"), _SLIT("-Wpacked"),
			_SLIT("-Wpointer-arith"), _SLIT("-Wswitch-enum")}));
	if (v->pref->os == v__pref__OS__ios) {
		array_push((array*)&ccoptions.args, _MOV((string[]){ string_clone(_SLIT("-fobjc-arc")) }));
	}
	ccoptions.debug_mode = v->pref->is_debug;
	ccoptions.guessed_compiler = v->pref->ccompiler;
	if (string__eq(ccoptions.guessed_compiler, _SLIT("cc")) && v->pref->is_prod) {
		os__Result ccversion = os__execute(_SLIT("cc --version"));
		if (ccversion.exit_code == 0) {
			if (string_contains(ccversion.output, _SLIT("This is free software;")) && string_contains(ccversion.output, _SLIT("Free Software Foundation, Inc."))) {
				ccoptions.guessed_compiler = _SLIT("gcc");
			}
			if (string_contains(ccversion.output, _SLIT("clang version "))) {
				ccoptions.guessed_compiler = _SLIT("clang");
			}
		}
	}
	ccoptions.is_cc_tcc = string_contains(ccompiler, _SLIT("tcc")) || string__eq(ccoptions.guessed_compiler, _SLIT("tcc"));
	ccoptions.is_cc_gcc = string_contains(ccompiler, _SLIT("gcc")) || string__eq(ccoptions.guessed_compiler, _SLIT("gcc"));
	ccoptions.is_cc_msvc = string_contains(ccompiler, _SLIT("msvc")) || string__eq(ccoptions.guessed_compiler, _SLIT("msvc"));
	ccoptions.is_cc_clang = string_contains(ccompiler, _SLIT("clang")) || string__eq(ccoptions.guessed_compiler, _SLIT("clang"));
	if (string_contains(ccoptions.guessed_compiler, _SLIT("++"))) {
		array_push((array*)&ccoptions.args, _MOV((string[]){ string_clone(_SLIT("-fpermissive")) }));
		array_push((array*)&ccoptions.args, _MOV((string[]){ string_clone(_SLIT("-w")) }));
	}
	if (ccoptions.is_cc_clang) {
		if (ccoptions.debug_mode) {
			debug_options = new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT("-g"), _SLIT("-O0")}));
		}
		optimization_options = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("-O3")}));
		bool have_flto = true;
		if (have_flto) {
			array_push((array*)&optimization_options, _MOV((string[]){ string_clone(_SLIT("-flto")) }));
		}
		_PUSH_MANY(&ccoptions.wargs, (new_array_from_c_array(4, 4, sizeof(string), _MOV((string[4]){_SLIT("-Wno-tautological-bitwise-compare"), _SLIT("-Wno-enum-conversion"), _SLIT("-Wno-sometimes-uninitialized"), _SLIT("-Wno-int-to-void-pointer-cast")}))), _t7, Array_string);
	}
	if (ccoptions.is_cc_gcc) {
		if (ccoptions.debug_mode) {
			debug_options = new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT("-g"), _SLIT("-no-pie")}));
		}
		optimization_options = new_array_from_c_array(3, 3, sizeof(string), _MOV((string[3]){_SLIT("-O3"), _SLIT("-fno-strict-aliasing"), _SLIT("-flto")}));
	}
	if (ccoptions.debug_mode) {
		_PUSH_MANY(&ccoptions.args, (debug_options), _t8, Array_string);
	}
	if (v->pref->is_prod) {
		if (ccoptions.is_cc_tcc && !(v->parsed_files.len > 0 && string_contains((*(v__ast__File**)array_last(v->parsed_files))->path, _SLIT("vlib")))) {
			eprintln(_SLIT("Note: tcc is not recommended for -prod builds"));
		}
		_PUSH_MANY(&ccoptions.args, (optimization_options), _t9, Array_string);
	}
	if (v->pref->is_prod && !ccoptions.debug_mode) {
		array_push((array*)&ccoptions.args, _MOV((string[]){ string_clone(_SLIT("-DNDEBUG")) }));
	}
	if (v->pref->sanitize) {
		array_push((array*)&ccoptions.args, _MOV((string[]){ string_clone(_SLIT("-fsanitize=leak")) }));
	}
	ccoptions.shared_postfix = _SLIT(".so");
	#if defined(__APPLE__)
	{
	}
	#elif defined(_WIN32)
	{
		ccoptions.shared_postfix = _SLIT(".dll");
	}
	#endif
	if (v->pref->is_shared) {
		array_push((array*)&ccoptions.linker_flags, _MOV((string[]){ string_clone(_SLIT("-shared")) }));
	}
	if (v->pref->is_bare) {
		array_push((array*)&ccoptions.args, _MOV((string[]){ string_clone(_SLIT("-fno-stack-protector")) }));
		array_push((array*)&ccoptions.args, _MOV((string[]){ string_clone(_SLIT("-ffreestanding")) }));
		array_push((array*)&ccoptions.linker_flags, _MOV((string[]){ string_clone(_SLIT("-static")) }));
		array_push((array*)&ccoptions.linker_flags, _MOV((string[]){ string_clone(_SLIT("-nostdlib")) }));
	}
	if (ccoptions.debug_mode && !string__eq(os__user_os(), _SLIT("windows")) && v->pref->build_mode != v__pref__BuildMode__build_module) {
		array_push((array*)&ccoptions.linker_flags, _MOV((string[]){ string_clone(_SLIT("-rdynamic")) }));
	}
	if (v->pref->os == v__pref__OS__freebsd) {
		if (!ccoptions.is_cc_tcc) {
			array_push((array*)&ccoptions.linker_flags, _MOV((string[]){ string_clone(_SLIT("-Wl,--allow-multiple-definition")) }));
		} else {
			array_push((array*)&ccoptions.args, _MOV((string[]){ string_clone(_SLIT("-D__RUNETYPE_INTERNAL")) }));
		}
	}
	if (!string__eq(ccompiler, _SLIT("msvc")) && v->pref->os != v__pref__OS__freebsd) {
		array_push((array*)&ccoptions.wargs, _MOV((string[]){ string_clone(_SLIT("-Werror=implicit-function-declaration")) }));
	}
	if (v->pref->is_liveshared || v->pref->is_livemain) {
		if ((v->pref->os == v__pref__OS__linux || string__eq(os__user_os(), _SLIT("linux"))) && v->pref->build_mode != v__pref__BuildMode__build_module) {
			array_push((array*)&ccoptions.linker_flags, _MOV((string[]){ string_clone(_SLIT("-rdynamic")) }));
		}
		if (v->pref->os == v__pref__OS__macos || string__eq(os__user_os(), _SLIT("macos"))) {
			array_push((array*)&ccoptions.args, _MOV((string[]){ string_clone(_SLIT("-flat_namespace")) }));
		}
	}
	if (v->pref->os == v__pref__OS__macos || v->pref->os == v__pref__OS__ios) {
		if (!ccoptions.is_cc_tcc) {
			array_push((array*)&ccoptions.source_args, _MOV((string[]){ string_clone(_SLIT("-x objective-c")) }));
		}
	}
	array_push((array*)&ccoptions.source_args, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("\""), 0xfe10, {.d_s = v->out_name_c}}, {_SLIT("\""), 0, { .d_c = 0 }}}))) }));
	if (v->pref->os == v__pref__OS__macos) {
		array_push((array*)&ccoptions.source_args, _MOV((string[]){ string_clone(_SLIT("-x none")) }));
	}
	if (v->pref->os == v__pref__OS__macos) {
		array_push((array*)&ccoptions.post_args, _MOV((string[]){ string_clone(_SLIT("-mmacosx-version-min=10.7")) }));
	} else if (v->pref->os == v__pref__OS__ios) {
		array_push((array*)&ccoptions.post_args, _MOV((string[]){ string_clone(_SLIT("-miphoneos-version-min=10.0")) }));
	} else if (v->pref->os == v__pref__OS__windows) {
		array_push((array*)&ccoptions.post_args, _MOV((string[]){ string_clone(_SLIT("-municode")) }));
	}
	Array_v__cflag__CFlag cflags = v__builder__Builder_get_os_cflags(v);
	if (v->pref->build_mode != v__pref__BuildMode__build_module) {
		Array_string only_o_files = Array_v__cflag__CFlag_c_options_only_object_files(cflags);
		_PUSH_MANY(&ccoptions.o_args, (only_o_files), _t29, Array_string);
	}
	multi_return_Array_string_Array_string_Array_string mr_10795 = Array_v__cflag__CFlag_defines_others_libs(cflags);
	Array_string defines = mr_10795.arg0;
	Array_string others = mr_10795.arg1;
	Array_string libs = mr_10795.arg2;
	_PUSH_MANY(&ccoptions.pre_args, (defines), _t30, Array_string);
	_PUSH_MANY(&ccoptions.pre_args, (others), _t31, Array_string);
	_PUSH_MANY(&ccoptions.linker_flags, (libs), _t32, Array_string);
	if (v->pref->use_cache && v->pref->build_mode != v__pref__BuildMode__build_module) {
		if (!ccoptions.is_cc_tcc) {
		}
	}
	if (ccoptions.is_cc_tcc && !Array_string_contains(v->pref->compile_defines, _SLIT("no_backtrace"))) {
		array_push((array*)&ccoptions.post_args, _MOV((string[]){ string_clone(_SLIT("-bt25")) }));
	}
	if (!v->pref->is_bare && v->pref->build_mode != v__pref__BuildMode__build_module && (v->pref->os == v__pref__OS__linux || v->pref->os == v__pref__OS__freebsd || v->pref->os == v__pref__OS__openbsd || v->pref->os == v__pref__OS__netbsd || v->pref->os == v__pref__OS__dragonfly || v->pref->os == v__pref__OS__solaris || v->pref->os == v__pref__OS__haiku)) {
		if (v->pref->os == v__pref__OS__freebsd || v->pref->os == v__pref__OS__netbsd) {
			array_push((array*)&ccoptions.linker_flags, _MOV((string[]){ string_clone(_SLIT("-lexecinfo")) }));
		}
	}
	ccoptions.env_cflags = os__getenv(_SLIT("CFLAGS"));
	ccoptions.env_ldflags = os__getenv(_SLIT("LDFLAGS"));
	v->ccoptions = ccoptions;
	v__vcache__CacheManager_set_temporary_options(&v->pref->cache_manager, v__builder__Builder_thirdparty_object_args(v, v->ccoptions, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){string_clone(ccoptions.guessed_compiler)}))));
}

VV_LOCAL_SYMBOL Array_string v__builder__Builder_all_args(v__builder__Builder* v, v__builder__CcompilerOptions ccoptions) {
	Array_string all = __new_array_with_default(0, 0, sizeof(string), 0);
	array_push((array*)&all, _MOV((string[]){ string_clone(ccoptions.env_cflags) }));
	if (v->pref->is_cstrict) {
		_PUSH_MANY(&all, (ccoptions.wargs), _t2, Array_string);
	}
	_PUSH_MANY(&all, (ccoptions.args), _t3, Array_string);
	_PUSH_MANY(&all, (ccoptions.o_args), _t4, Array_string);
	_PUSH_MANY(&all, (ccoptions.pre_args), _t5, Array_string);
	_PUSH_MANY(&all, (ccoptions.source_args), _t6, Array_string);
	_PUSH_MANY(&all, (ccoptions.post_args), _t7, Array_string);
	if (v->pref->build_mode != v__pref__BuildMode__build_module) {
		_PUSH_MANY(&all, (ccoptions.linker_flags), _t8, Array_string);
	}
	array_push((array*)&all, _MOV((string[]){ string_clone(ccoptions.env_ldflags) }));
	Array_string _t10 = all;
	return _t10;
}

VV_LOCAL_SYMBOL Array_string v__builder__Builder_thirdparty_object_args(v__builder__Builder* v, v__builder__CcompilerOptions ccoptions, Array_string middle) {
	Array_string all = __new_array_with_default(0, 0, sizeof(string), 0);
	array_push((array*)&all, _MOV((string[]){ string_clone(ccoptions.env_cflags) }));
	_PUSH_MANY(&all, (ccoptions.args), _t2, Array_string);
	_PUSH_MANY(&all, (middle), _t3, Array_string);
	array_push((array*)&all, _MOV((string[]){ string_clone(ccoptions.env_ldflags) }));
	Array_string _t5 = all;
	return _t5;
}

VV_LOCAL_SYMBOL void v__builder__Builder_setup_output_name(v__builder__Builder* v) {
	if (!v->pref->is_shared && v->pref->build_mode != v__pref__BuildMode__build_module && string__eq(os__user_os(), _SLIT("windows")) && !string_ends_with(v->pref->out_name, _SLIT(".exe"))) {
		v->pref->out_name = /*f*/string__plus(v->pref->out_name, _SLIT(".exe"));
	}
	v__builder__Builder_log(v,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("cc() isprod="), 0xfe10, {.d_s = v->pref->is_prod ? _SLIT("true") : _SLIT("false")}}, {_SLIT(" outname="), 0xfe10, {.d_s = v->pref->out_name}}, {_SLIT0, 0, { .d_c = 0 }}})));
	if (v->pref->is_shared) {
		if (!string_ends_with(v->pref->out_name, v->ccoptions.shared_postfix)) {
			v->pref->out_name = /*f*/string__plus(v->pref->out_name, v->ccoptions.shared_postfix);
		}
	}
	if (v->pref->build_mode == v__pref__BuildMode__build_module) {
		v->pref->out_name = v__vcache__CacheManager_postfix_with_key2cpath(&v->pref->cache_manager, _SLIT(".o"), v->pref->path);
		if (v->pref->is_verbose) {
			println( str_intp(3, _MOV((StrIntpData[]){{_SLIT("Building "), 0xfe10, {.d_s = v->pref->path}}, {_SLIT(" to "), 0xfe10, {.d_s = v->pref->out_name}}, {_SLIT(" ..."), 0, { .d_c = 0 }}})));
		}
		Option_string _t1 = v__vcache__CacheManager_save(&v->pref->cache_manager, _SLIT(".description.txt"), v->pref->path,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0x3cfe10, {.d_s = v->pref->path}}, {_SLIT(" @ "), 0xfe10, {.d_s = v->pref->cache_manager.vopts}}, {_SLIT("\n"), 0, { .d_c = 0 }}})));
		if (_t1.state != 0) { /*or block*/ 
			IError err = _t1.err;
			_v_panic(IError_str(err));
			VUNREACHABLE();
		;
		}
		
  (*(string*)_t1.data);
	}
	if (os__is_dir(v->pref->out_name)) {
		v__builder__verror( str_intp(2, _MOV((StrIntpData[]){{_SLIT("'"), 0xfe10, {.d_s = v->pref->out_name}}, {_SLIT("' is a directory"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	array_push((array*)&v->ccoptions.o_args, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("-o \""), 0xfe10, {.d_s = v->pref->out_name}}, {_SLIT("\""), 0, { .d_c = 0 }}}))) }));
}

VV_LOCAL_SYMBOL void v__builder__Builder_dump_c_options(v__builder__Builder* v, Array_string all_args) {
	if ((v->pref->dump_c_flags).len != 0) {
		Array_string _t1 = __new_array(0, 0, sizeof(string));
		Array_string _t1_orig = all_args;
		int _t1_len = _t1_orig.len;
		_t1 = __new_array(0, _t1_len, sizeof(string));

		for (int _t2 = 0; _t2 < _t1_len; ++_t2) {
			string it = ((string*) _t1_orig.data)[_t2];
			if ((it).len != 0) {
				array_push((array*)&_t1, &it);
			}
		}
		string non_empty_args = string__plus(Array_string_join(_t1, _SLIT("\n")), _SLIT("\n"));
		if (string__eq(v->pref->dump_c_flags, _SLIT("-"))) {
			print(non_empty_args);
		} else {
			Option_void _t3 = os__write_file(v->pref->dump_c_flags, non_empty_args);
			if (_t3.state != 0 && _t3.err._typ != _IError_None___index) {
				IError err = _t3.err;
				_v_panic(IError_str(err));
				VUNREACHABLE();
			;
			}
			
 ;
		}
	}
}

void v__builder__Builder_cc(v__builder__Builder* v) {
	if (string_contains(os__executable(), _SLIT("vfmt"))) {
		return;
	}
	if (v->pref->is_verbose) {
		println( str_intp(2, _MOV((StrIntpData[]){{_SLIT("builder.cc() pref.out_name=\""), 0xfe10, {.d_s = v->pref->out_name}}, {_SLIT("\""), 0, { .d_c = 0 }}})));
	}
	if (v->pref->only_check_syntax) {
		if (v->pref->is_verbose) {
			println(_SLIT("builder.cc returning early, since pref.only_check_syntax is true"));
		}
		return;
	}
	if (v->pref->check_only) {
		if (v->pref->is_verbose) {
			println(_SLIT("builder.cc returning early, since pref.check_only is true"));
		}
		return;
	}
	if (v__pref__Preferences_should_output_to_stdout(v->pref)) {
		Option_string _t1 = os__read_file(v->out_name_c);
		if (_t1.state != 0) { /*or block*/ 
			IError err = _t1.err;
			_v_panic(IError_str(err));
			VUNREACHABLE();
		;
		}
		
 		string content =  (*(string*)_t1.data);
		println(content);
		Option_void _t2 = os__rm(v->out_name_c);
		if (_t2.state != 0 && _t2.err._typ != _IError_None___index) {
			IError err = _t2.err;
		}
		
 ;
		return;
	}
	bool ends_with_c = string_ends_with(v->pref->out_name, _SLIT(".c"));
	bool ends_with_js = string_ends_with(v->pref->out_name, _SLIT(".js"));
	if (ends_with_c || ends_with_js) {
		v->pref->skip_running = true;
		string msg_mv =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("os.mv_by_cp "), 0xfe10, {.d_s = v->out_name_c}}, {_SLIT(" => "), 0xfe10, {.d_s = v->pref->out_name}}, {_SLIT0, 0, { .d_c = 0 }}}));
		v__util__timing_start(msg_mv);
		Option_void _t3 = os__mv_by_cp(v->out_name_c, v->pref->out_name);
		if (_t3.state != 0 && _t3.err._typ != _IError_None___index) {
			IError err = _t3.err;
			_v_panic(IError_str(err));
			VUNREACHABLE();
		;
		}
		
 ;
		v__util__timing_measure(msg_mv);
		return;
	}
	if (v->pref->os == v__pref__OS__windows && !string__eq(v->pref->ccompiler, _SLIT("msvc"))) {
	}
	if (v->pref->os == v__pref__OS__linux) {
		#if !defined(__linux__)
		{
			v__builder__Builder_cc_linux_cross(v);
			return;
		}
		#endif
	}
	string vexe = v__pref__vexe_path();
	string vdir = os__dir(vexe);
	Array_string tried_compilation_commands = __new_array_with_default(0, 0, sizeof(string), 0);
	os__Result tcc_output = (os__Result){.exit_code = 0,.output = (string){.str=(byteptr)"", .is_lit=1},};
	string original_pwd = os__getwd();
	for (;;) {
		string ccompiler = v->pref->ccompiler;
		if (v->pref->os == v__pref__OS__ios) {
			string ios_sdk = (v->pref->is_ios_simulator ? (_SLIT("iphonesimulator")) : (_SLIT("iphoneos")));
			os__Result ios_sdk_path_res = os__execute_or_exit( str_intp(2, _MOV((StrIntpData[]){{_SLIT("xcrun --sdk "), 0xfe10, {.d_s = ios_sdk}}, {_SLIT(" --show-sdk-path"), 0, { .d_c = 0 }}})));
			string isysroot = string_replace(ios_sdk_path_res.output, _SLIT("\n"), _SLIT(""));
			string arch = (v->pref->is_ios_simulator ? (_SLIT("-arch x86_64")) : (_SLIT("-arch armv7 -arch armv7s -arch arm64")));
			ccompiler =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("xcrun --sdk iphoneos clang -isysroot "), 0xfe10, {.d_s = isysroot}}, {_SLIT(" "), 0xfe10, {.d_s = arch}}, {_SLIT0, 0, { .d_c = 0 }}}));
		}
		v__builder__Builder_setup_ccompiler_options(v, ccompiler);
		v__builder__Builder_build_thirdparty_obj_files(v);
		v__builder__Builder_setup_output_name(v);
		if (v->pref->os != v__pref__OS__windows && string_contains(ccompiler, _SLIT("++"))) {
			string cpp_atomic_h_path =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = _SLIT("/home/runner/work/v/v")}}, {_SLIT("/thirdparty/stdatomic/nix/cpp/atomic.h"), 0, { .d_c = 0 }}}));
			if (!os__exists(cpp_atomic_h_path)) {
				for (int _t4 = 0; _t4 < v->parsed_files.len; ++_t4) {
					v__ast__File* file = ((v__ast__File**)v->parsed_files.data)[_t4];
					bool _t5 = false;
					Array_v__ast__Import _t5_orig = file->imports;
					int _t5_len = _t5_orig.len;
					for (int _t6 = 0; _t6 < _t5_len; ++_t6) {
						v__ast__Import it = ((v__ast__Import*) _t5_orig.data)[_t6];
						if (string_contains(it.mod, _SLIT("sync"))) {
							_t5 = true;
							break;
						}
					}
					if (_t5) {
						os__execute( str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = vexe}}, {_SLIT(" run "), 0xfe10, {.d_s = _SLIT("/home/runner/work/v/v")}}, {_SLIT("/thirdparty/stdatomic/nix/cpp/gen.v "), 0xfe10, {.d_s = ccompiler}}, {_SLIT0, 0, { .d_c = 0 }}})));
						break;
					}
				}
			}
		}
		if (v->pref->build_mode == v__pref__BuildMode__build_module) {
			array_push((array*)&v->ccoptions.pre_args, _MOV((string[]){ string_clone(_SLIT("-c")) }));
		}
		v__builder__Builder_handle_usecache(v, vexe);
		if (string__eq(ccompiler, _SLIT("msvc"))) {
			v__builder__Builder_cc_msvc(v);
			return;
		}
		Array_string all_args = v__builder__Builder_all_args(v, v->ccoptions);
		v__builder__Builder_dump_c_options(v, all_args);
		string str_args = Array_string_join(all_args, _SLIT(" "));
		string cmd =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ccompiler}}, {_SLIT(" "), 0xfe10, {.d_s = str_args}}, {_SLIT0, 0, { .d_c = 0 }}}));
		string response_file = _SLIT("");
		string response_file_content = str_args;
		if (!v->pref->no_rsp) {
			response_file =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v->out_name_c}}, {_SLIT(".rsp"), 0, { .d_c = 0 }}}));
			response_file_content = string_replace(str_args, _SLIT("\\"), _SLIT("\\\\"));
			cmd =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ccompiler}}, {_SLIT(" \"@"), 0xfe10, {.d_s = response_file}}, {_SLIT("\""), 0, { .d_c = 0 }}}));
			Option_void _t8 = os__write_file(response_file, response_file_content);
			if (_t8.state != 0 && _t8.err._typ != _IError_None___index) {
				IError err = _t8.err;
				v__builder__verror( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Unable to write to C response file \""), 0xfe10, {.d_s = response_file}}, {_SLIT("\""), 0, { .d_c = 0 }}})));
				VUNREACHABLE();
			;
			}
			
 ;
		}
		if (!v->ccoptions.debug_mode) {
			array_push((array*)&v->pref->cleanup_files, _MOV((string[]){ string_clone(v->out_name_c) }));
			if (!v->pref->no_rsp) {
				array_push((array*)&v->pref->cleanup_files, _MOV((string[]){ string_clone(response_file) }));
			}
		}
		if (v->ccoptions.is_cc_tcc) {
			string def_name = string_substr(v->pref->out_name, 0, v->pref->out_name.len - 4);
			array_push((array*)&v->pref->cleanup_files, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = def_name}}, {_SLIT(".def"), 0, { .d_c = 0 }}}))) }));
		}
		Option_void _t12 = os__chdir(vdir);
		if (_t12.state != 0 && _t12.err._typ != _IError_None___index) {
			IError err = _t12.err;
		}
		
 ;
		array_push((array*)&tried_compilation_commands, _MOV((string[]){ string_clone(cmd) }));
		v__builder__Builder_show_cc(v, cmd, response_file, response_file_content);
		string ccompiler_label =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("C "), 0x6fe30, {.d_s = os__file_name(ccompiler)}}, {_SLIT0, 0, { .d_c = 0 }}}));
		v__util__timing_start(ccompiler_label);
		os__Result res = os__execute(cmd);
		v__util__timing_measure(ccompiler_label);
		if (v->pref->show_c_output) {
			v__builder__Builder_show_c_compiler_output(v, res);
		}
		Option_void _t14 = os__chdir(original_pwd);
		if (_t14.state != 0 && _t14.err._typ != _IError_None___index) {
			IError err = _t14.err;
		}
		
 ;
		;
		;
		;
		if (res.exit_code != 0) {
			if (string_contains(ccompiler, _SLIT("tcc.exe"))) {
				if (tried_compilation_commands.len > 1) {
					eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Recompilation loop detected (ccompiler: "), 0xfe10, {.d_s = ccompiler}}, {_SLIT("):"), 0, { .d_c = 0 }}})));
					for (int _t15 = 0; _t15 < tried_compilation_commands.len; ++_t15) {
						string recompile_command = ((string*)tried_compilation_commands.data)[_t15];
						eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("   "), 0xfe10, {.d_s = recompile_command}}, {_SLIT0, 0, { .d_c = 0 }}})));
					}
					_v_exit(101);
					VUNREACHABLE();
				}
				if (v->pref->retry_compilation) {
					tcc_output = res;
					v->pref->ccompiler = v__pref__default_c_compiler();
					if (v->pref->is_verbose) {
						eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Compilation with tcc failed. Retrying with "), 0xfe10, {.d_s = v->pref->ccompiler}}, {_SLIT(" ..."), 0, { .d_c = 0 }}})));
					}
					continue;
				}
			}
			if (res.exit_code == 127) {
				v__builder__verror(string__plus(string__plus(string__plus(string__plus(string__plus(string__plus(_SLIT("C compiler error, while attempting to run: \n"), _SLIT("-----------------------------------------------------------\n")),  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = cmd}}, {_SLIT("\n"), 0, { .d_c = 0 }}}))), _SLIT("-----------------------------------------------------------\n")), _SLIT("Probably your C compiler is missing. \n")), _SLIT("Please reinstall it, or make it available in your PATH.\n\n")), v__builder__missing_compiler_info()));
				VUNREACHABLE();
			}
		}
		if (!v->pref->show_c_output) {
			if (res.exit_code != 0 && (tcc_output.output).len != 0) {
				v__builder__Builder_post_process_c_compiler_output(v, tcc_output);
			} else {
				v__builder__Builder_post_process_c_compiler_output(v, res);
			}
		}
		if (v->pref->is_verbose) {
			println( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ccompiler}}, {_SLIT0, 0, { .d_c = 0 }}})));
			println(_SLIT("=========\n"));
		}
		break;
	}
	if (v->pref->compress) {
		println(_SLIT("-compress does not work on Windows for now"));
		return;
		int ret = os__system( str_intp(2, _MOV((StrIntpData[]){{_SLIT("strip "), 0xfe10, {.d_s = v->pref->out_name}}, {_SLIT0, 0, { .d_c = 0 }}})));
		if (ret != 0) {
			println(_SLIT("strip failed"));
			return;
		}
		int ret2 = os__system( str_intp(2, _MOV((StrIntpData[]){{_SLIT("upx --lzma -qqq "), 0xfe10, {.d_s = v->pref->out_name}}, {_SLIT0, 0, { .d_c = 0 }}})));
		if (ret2 != 0) {
			ret2 = os__system( str_intp(2, _MOV((StrIntpData[]){{_SLIT("upx -qqq "), 0xfe10, {.d_s = v->pref->out_name}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		if (ret2 != 0) {
			println(_SLIT("upx failed"));
		}
	}
}

VV_LOCAL_SYMBOL void v__builder__Builder_ensure_linuxroot_exists(v__builder__Builder* b, string sysroot) {
	string crossrepo_url = _SLIT("https://github.com/spytheman/vlinuxroot");
	string sysroot_git_config_path = os__join_path(sysroot, new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT(".git"), _SLIT("config")})));
	if (os__is_dir(sysroot) && !os__exists(sysroot_git_config_path)) {
		Option_void _t1 = os__rmdir_all(sysroot);
		if (_t1.state != 0 && _t1.err._typ != _IError_None___index) {
			IError err = _t1.err;
		}
		
 ;
	}
	if (!os__is_dir(sysroot)) {
		println(_SLIT("Downloading files for Linux cross compilation (~22MB) ..."));
		os__system( str_intp(3, _MOV((StrIntpData[]){{_SLIT("git clone "), 0xfe10, {.d_s = crossrepo_url}}, {_SLIT(" "), 0xfe10, {.d_s = sysroot}}, {_SLIT0, 0, { .d_c = 0 }}})));
		if (!os__exists(sysroot_git_config_path)) {
			v__builder__verror( str_intp(3, _MOV((StrIntpData[]){{_SLIT("Failed to clone `"), 0xfe10, {.d_s = crossrepo_url}}, {_SLIT("` to `"), 0xfe10, {.d_s = sysroot}}, {_SLIT("`"), 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		}
		Option_void _t2 = os__chmod(os__join_path(sysroot, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("ld.lld")}))), 0755);
		if (_t2.state != 0 && _t2.err._typ != _IError_None___index) {
			IError err = _t2.err;
			_v_panic(IError_str(err));
			VUNREACHABLE();
		;
		}
		
 ;
	}
}

VV_LOCAL_SYMBOL void v__builder__Builder_cc_linux_cross(v__builder__Builder* b) {
	v__builder__Builder_setup_ccompiler_options(b, b->pref->ccompiler);
	v__builder__Builder_build_thirdparty_obj_files(b);
	v__builder__Builder_setup_output_name(b);
	string parent_dir = os__vmodules_dir();
	if (!os__exists(parent_dir)) {
		Option_bool _t1 = os__mkdir(parent_dir);
		if (_t1.state != 0) { /*or block*/ 
			IError err = _t1.err;
			_v_panic(IError_str(err));
			VUNREACHABLE();
		;
		}
		
  (*(bool*)_t1.data);
	}
	string sysroot = os__join_path(os__vmodules_dir(), new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("linuxroot")})));
	v__builder__Builder_ensure_linuxroot_exists(b, sysroot);
	string obj_file = string__plus(b->out_name_c, _SLIT(".o"));
	Array_v__cflag__CFlag cflags = v__builder__Builder_get_os_cflags(b);
	multi_return_Array_string_Array_string_Array_string mr_22075 = Array_v__cflag__CFlag_defines_others_libs(cflags);
	Array_string defines = mr_22075.arg0;
	Array_string others = mr_22075.arg1;
	Array_string libs = mr_22075.arg2;
	Array_string cc_args = __new_array_with_default(0, 0, sizeof(string), 0);
	array_push((array*)&cc_args, _MOV((string[]){ string_clone(_SLIT("-w")) }));
	array_push((array*)&cc_args, _MOV((string[]){ string_clone(_SLIT("-fPIC")) }));
	array_push((array*)&cc_args, _MOV((string[]){ string_clone(_SLIT("-c")) }));
	array_push((array*)&cc_args, _MOV((string[]){ string_clone(_SLIT("-target x86_64-linux-gnu")) }));
	_PUSH_MANY(&cc_args, (defines), _t6, Array_string);
	array_push((array*)&cc_args, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("-I "), 0xfe10, {.d_s = sysroot}}, {_SLIT("/include "), 0, { .d_c = 0 }}}))) }));
	_PUSH_MANY(&cc_args, (others), _t8, Array_string);
	array_push((array*)&cc_args, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("-o \""), 0xfe10, {.d_s = obj_file}}, {_SLIT("\""), 0, { .d_c = 0 }}}))) }));
	array_push((array*)&cc_args, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("-c \""), 0xfe10, {.d_s = b->out_name_c}}, {_SLIT("\""), 0, { .d_c = 0 }}}))) }));
	_PUSH_MANY(&cc_args, (libs), _t11, Array_string);
	v__builder__Builder_dump_c_options(b, cc_args);
	string cc_cmd = string__plus(_SLIT("cc "), Array_string_join(cc_args, _SLIT(" ")));
	if (b->pref->show_cc) {
		println(cc_cmd);
	}
	os__Result cc_res = os__execute(cc_cmd);
	if (cc_res.exit_code != 0) {
		println(_SLIT("Cross compilation for Linux failed (first step, cc). Make sure you have clang installed."));
		v__builder__verror(cc_res.output);
		VUNREACHABLE();
		return;
	}
	Array_string linker_args = new_array_from_c_array(14, 14, sizeof(string), _MOV((string[14]){
			 str_intp(2, _MOV((StrIntpData[]){{_SLIT("-L"), 0xfe10, {.d_s = sysroot}}, {_SLIT("/usr/lib/x86_64-linux-gnu/"), 0, { .d_c = 0 }}})),  str_intp(2, _MOV((StrIntpData[]){{_SLIT("-L"), 0xfe10, {.d_s = sysroot}}, {_SLIT("/lib/x86_64-linux-gnu"), 0, { .d_c = 0 }}})),  str_intp(2, _MOV((StrIntpData[]){{_SLIT("--sysroot="), 0xfe10, {.d_s = sysroot}}, {_SLIT0, 0, { .d_c = 0 }}})), _SLIT("-v"),  str_intp(2, _MOV((StrIntpData[]){{_SLIT("-o "), 0xfe10, {.d_s = b->pref->out_name}}, {_SLIT0, 0, { .d_c = 0 }}})), _SLIT("-m elf_x86_64"), _SLIT("-dynamic-linker /lib/x86_64-linux-gnu/ld-linux-x86-64.so.2"),  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = sysroot}}, {_SLIT("/crt1.o "), 0xfe10, {.d_s = sysroot}}, {_SLIT("/crti.o "), 0xfe10, {.d_s = obj_file}}, {_SLIT0, 0, { .d_c = 0 }}})), _SLIT("-lc"),
			_SLIT("-lcrypto"), _SLIT("-lssl"), _SLIT("-lpthread"),  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = sysroot}}, {_SLIT("/crtn.o"), 0, { .d_c = 0 }}})), _SLIT("-lm")}));
	_PUSH_MANY(&linker_args, (Array_v__cflag__CFlag_c_options_only_object_files(cflags)), _t12, Array_string);
	v__builder__Builder_dump_c_options(b, linker_args);
	string linker_cmd = string__plus( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = sysroot}}, {_SLIT("/ld.lld "), 0, { .d_c = 0 }}})), Array_string_join(linker_args, _SLIT(" ")));
	if (b->pref->show_cc) {
		println(linker_cmd);
	}
	os__Result res = os__execute(linker_cmd);
	if (res.exit_code != 0) {
		println(_SLIT("Cross compilation for Linux failed (second step, lld)."));
		v__builder__verror(res.output);
		VUNREACHABLE();
		return;
	}
	println(string__plus(b->pref->out_name, _SLIT(" has been successfully compiled")));
}

VV_LOCAL_SYMBOL void v__builder__Builder_cc_windows_cross(v__builder__Builder* c) {
	println(_SLIT("Cross compiling for Windows..."));
	v__builder__Builder_setup_ccompiler_options(c, c->pref->ccompiler);
	v__builder__Builder_build_thirdparty_obj_files(c);
	v__builder__Builder_setup_output_name(c);
	if (!string_ends_with(c->pref->out_name, _SLIT(".exe"))) {
		c->pref->out_name = /*f*/string__plus(c->pref->out_name, _SLIT(".exe"));
	}
	Array_string args = __new_array_with_default(0, 0, sizeof(string), 0);
	array_push((array*)&args, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = c->pref->cflags}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
	array_push((array*)&args, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("-o "), 0xfe10, {.d_s = c->pref->out_name}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
	array_push((array*)&args, _MOV((string[]){ string_clone(_SLIT("-w -L.")) }));
	Array_v__cflag__CFlag cflags = v__builder__Builder_get_os_cflags(c);
	if (string__eq(c->pref->ccompiler, _SLIT("msvc"))) {
		_PUSH_MANY(&args, (Array_v__cflag__CFlag_c_options_before_target_msvc(cflags)), _t4, Array_string);
	} else {
		_PUSH_MANY(&args, (Array_v__cflag__CFlag_c_options_before_target(cflags)), _t5, Array_string);
	}
	Array_string optimization_options = __new_array_with_default(0, 0, sizeof(string), 0);
	Array_string debug_options = __new_array_with_default(0, 0, sizeof(string), 0);
	if (c->pref->is_prod) {
		if (!string__eq(c->pref->ccompiler, _SLIT("msvc"))) {
			optimization_options = new_array_from_c_array(3, 3, sizeof(string), _MOV((string[3]){_SLIT("-O3"), _SLIT("-fno-strict-aliasing"), _SLIT("-flto")}));
		}
	}
	if (c->pref->is_debug) {
		if (!string__eq(c->pref->ccompiler, _SLIT("msvc"))) {
			debug_options = new_array_from_c_array(3, 3, sizeof(string), _MOV((string[3]){_SLIT("-O0"), _SLIT("-g"), _SLIT("-gdwarf-2")}));
		}
	}
	Array_string libs = __new_array_with_default(0, 0, sizeof(string), 0);
	if (false && c->pref->build_mode == v__pref__BuildMode__default_mode) {
		string builtin_o =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\""), 0xfe10, {.d_s = _const_v__pref__default_module_path}}, {_SLIT("/vlib/builtin.o\""), 0, { .d_c = 0 }}}));
		array_push((array*)&libs, _MOV((string[]){ string_clone(builtin_o) }));
		if (!os__exists(builtin_o)) {
			v__builder__verror( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = builtin_o}}, {_SLIT(" not found"), 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		}
		for (int _t7 = 0; _t7 < c->table->imports.len; ++_t7) {
			string imp = ((string*)c->table->imports.data)[_t7];
			array_push((array*)&libs, _MOV((string[]){ string_clone( str_intp(3, _MOV((StrIntpData[]){{_SLIT("\""), 0xfe10, {.d_s = _const_v__pref__default_module_path}}, {_SLIT("/vlib/"), 0xfe10, {.d_s = imp}}, {_SLIT(".o\""), 0, { .d_c = 0 }}}))) }));
		}
	}
	_PUSH_MANY(&args, (Array_v__cflag__CFlag_c_options_only_object_files(cflags)), _t9, Array_string);
	array_push((array*)&args, _MOV((string[]){ string_clone(c->out_name_c) }));
	if (string__eq(c->pref->ccompiler, _SLIT("msvc"))) {
		_PUSH_MANY(&args, (Array_v__cflag__CFlag_c_options_after_target_msvc(cflags)), _t11, Array_string);
	} else {
		_PUSH_MANY(&args, (Array_v__cflag__CFlag_c_options_after_target(cflags)), _t12, Array_string);
	}
	if (!(string__eq(os__user_os(), _SLIT("macos")) || string__eq(os__user_os(), _SLIT("linux")))) {
		println(os__user_os());
		_v_panic(_SLIT("your platform is not supported yet"));
		VUNREACHABLE();
	}
	Array_string all_args = __new_array_with_default(0, 0, sizeof(string), 0);
	_PUSH_MANY(&all_args, (optimization_options), _t13, Array_string);
	_PUSH_MANY(&all_args, (debug_options), _t14, Array_string);
	array_push((array*)&all_args, _MOV((string[]){ string_clone(_SLIT("-std=gnu11")) }));
	_PUSH_MANY(&all_args, (args), _t16, Array_string);
	array_push((array*)&all_args, _MOV((string[]){ string_clone(_SLIT("-municode")) }));
	v__builder__Builder_dump_c_options(c, all_args);
	string cmd = string__plus(string__plus(v__pref__vcross_compiler_name(_const_v__pref__cc_to_windows), _SLIT(" ")), Array_string_join(all_args, _SLIT(" ")));
	if (c->pref->is_verbose || c->pref->show_cc) {
		println(cmd);
	}
	if (os__system(cmd) != 0) {
		println(_SLIT("Cross compilation for Windows failed. Make sure you have mingw-w64 installed."));
		_v_exit(1);
		VUNREACHABLE();
	}
	println(string__plus(c->pref->out_name, _SLIT(" has been successfully compiled")));
}

VV_LOCAL_SYMBOL void v__builder__Builder_build_thirdparty_obj_files(v__builder__Builder* b) {
	v__builder__Builder_log(b,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("build_thirdparty_obj_files: v.ast.cflags: "), 0xfe10, {.d_s = Array_v__cflag__CFlag_str(b->table->cflags)}}, {_SLIT0, 0, { .d_c = 0 }}})));
	Array_v__cflag__CFlag _t1 = v__builder__Builder_get_os_cflags(b);
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		v__cflag__CFlag flag = ((v__cflag__CFlag*)_t1.data)[_t2];
		if (string_ends_with(flag.value, _SLIT(".o"))) {
			Array_v__cflag__CFlag rest_of_module_flags = v__builder__Builder_get_rest_of_module_cflags(b, (voidptr)&/*qq*/flag);
			if (string__eq(b->pref->ccompiler, _SLIT("msvc"))) {
				v__builder__Builder_build_thirdparty_obj_file_with_msvc(b, flag.value, rest_of_module_flags);
			} else {
				v__builder__Builder_build_thirdparty_obj_file(b, flag.value, rest_of_module_flags);
			}
		}
	}
}

VV_LOCAL_SYMBOL void v__builder__Builder_build_thirdparty_obj_file(v__builder__Builder* v, string path, Array_v__cflag__CFlag moduleflags) {
	string obj_path = os__real_path(path);
	string cfile =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = string_substr(obj_path, 0, obj_path.len - 2)}}, {_SLIT(".c"), 0, { .d_c = 0 }}}));
	string opath = v__vcache__CacheManager_postfix_with_key2cpath(&v->pref->cache_manager, _SLIT(".o"), obj_path);
	string rebuild_reason_message =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = obj_path}}, {_SLIT(" not found, building it in "), 0xfe10, {.d_s = opath}}, {_SLIT(" ..."), 0, { .d_c = 0 }}}));
	if (os__exists(opath)) {
		if (os__exists(cfile) && os__file_last_mod_unix(opath) < os__file_last_mod_unix(cfile)) {
			rebuild_reason_message =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = opath}}, {_SLIT(" is older than "), 0xfe10, {.d_s = cfile}}, {_SLIT(", rebuilding ..."), 0, { .d_c = 0 }}}));
		} else {
			return;
		}
	}
	if (os__exists(obj_path)) {
		Option_void _t1 = os__cp(obj_path, opath);
		if (_t1.state != 0 && _t1.err._typ != _IError_None___index) {
			IError err = _t1.err;
			_v_panic(IError_str(err));
			VUNREACHABLE();
		;
		}
		
 ;
		return;
	}
	if (v->pref->is_verbose) {
		println(rebuild_reason_message);
	}
	string current_folder = os__getwd();
	Option_void _t2 = os__chdir(os__dir(v__pref__vexe_path()));
	if (_t2.state != 0 && _t2.err._typ != _IError_None___index) {
		IError err = _t2.err;
	}
	
 ;
	Array_string all_options = __new_array_with_default(0, 0, sizeof(string), 0);
	array_push((array*)&all_options, _MOV((string[]){ string_clone(v->pref->third_party_option) }));
	_PUSH_MANY(&all_options, (Array_v__cflag__CFlag_c_options_before_target(moduleflags)), _t4, Array_string);
	array_push((array*)&all_options, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("-o \""), 0xfe10, {.d_s = opath}}, {_SLIT("\""), 0, { .d_c = 0 }}}))) }));
	array_push((array*)&all_options, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("-c \""), 0xfe10, {.d_s = cfile}}, {_SLIT("\""), 0, { .d_c = 0 }}}))) }));
	string cc_options = Array_string_join(v__builder__Builder_thirdparty_object_args(v, v->ccoptions, all_options), _SLIT(" "));
	string cmd =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v->pref->ccompiler}}, {_SLIT(" "), 0xfe10, {.d_s = cc_options}}, {_SLIT0, 0, { .d_c = 0 }}}));
	os__Result res = os__execute(cmd);
	Option_void _t7 = os__chdir(current_folder);
	if (_t7.state != 0 && _t7.err._typ != _IError_None___index) {
		IError err = _t7.err;
	}
	
 ;
	if (res.exit_code != 0) {
		eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("failed thirdparty object build cmd:\n"), 0xfe10, {.d_s = cmd}}, {_SLIT0, 0, { .d_c = 0 }}})));
		v__builder__verror(res.output);
		VUNREACHABLE();
		return;
	}
	Option_string _t8 = v__vcache__CacheManager_save(&v->pref->cache_manager, _SLIT(".description.txt"), obj_path,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0x3cfe10, {.d_s = obj_path}}, {_SLIT(" @ "), 0xfe10, {.d_s = cmd}}, {_SLIT("\n"), 0, { .d_c = 0 }}})));
	if (_t8.state != 0) { /*or block*/ 
		IError err = _t8.err;
		_v_panic(IError_str(err));
		VUNREACHABLE();
	;
	}
	
  (*(string*)_t8.data);
	if ((res.output).len != 0) {
		println(res.output);
	}
}

VV_LOCAL_SYMBOL string v__builder__missing_compiler_info(void) {
	string _t1 = _SLIT("https://github.com/vlang/v/wiki/Installing-a-C-compiler-on-Windows");
	return _t1;
	string _t2 = _SLIT("");
	return _t2;
}

VV_LOCAL_SYMBOL Array_string v__builder__error_context_lines(string text, string keyword, int before, int after) {
	string khighlight = (term__can_show_color_on_stdout() ? (term__red(keyword)) : (keyword));
	int eline_idx = -1;
	Array_string lines = string_split_into_lines(text);
	for (int idx = 0; idx < lines.len; ++idx) {
		string eline = ((string*)lines.data)[idx];
		if (string_contains(eline, keyword)) {
			array_set(&lines, idx, &(string[]) { string_replace((*(string*)/*ee elem_typ */array_get(lines, idx)), keyword, khighlight) });
			if (eline_idx == -1) {
				eline_idx = idx;
			}
		}
	}
	int idx_s = (eline_idx - before >= 0 ? (eline_idx - before) : (0));
	int idx_e = (idx_s + after < lines.len ? (idx_s + after) : (lines.len));
	Array_string _t1 = array_slice(lines, idx_s, idx_e);
	return _t1;
}

VV_LOCAL_SYMBOL Array_v__cflag__CFlag v__builder__Builder_get_os_cflags(v__builder__Builder* v) {
	Array_v__cflag__CFlag flags = __new_array_with_default(0, 0, sizeof(v__cflag__CFlag), 0);
	Array_string ctimedefines = __new_array_with_default(0, 0, sizeof(string), 0);
	if (v->pref->compile_defines.len > 0) {
		_PUSH_MANY(&ctimedefines, (v->pref->compile_defines), _t1, Array_string);
	}
	for (int _t2 = 0; _t2 < v->table->cflags.len; ++_t2) {
		v__cflag__CFlag* flag = ((v__cflag__CFlag*)v->table->cflags.data) + _t2;
		if (string_ends_with(flag->value, _SLIT(".o"))) {
			flag->cached = v__vcache__CacheManager_postfix_with_key2cpath(&v->pref->cache_manager, _SLIT(".o"), os__real_path(flag->value));
		}
		if ((flag->os).len == 0 || (string__eq(flag->os, _SLIT("linux")) && v->pref->os == v__pref__OS__linux) || (string__eq(flag->os, _SLIT("macos")) && v->pref->os == v__pref__OS__macos) || (string__eq(flag->os, _SLIT("darwin")) && v->pref->os == v__pref__OS__macos) || (string__eq(flag->os, _SLIT("freebsd")) && v->pref->os == v__pref__OS__freebsd) || (string__eq(flag->os, _SLIT("windows")) && v->pref->os == v__pref__OS__windows) || (string__eq(flag->os, _SLIT("mingw")) && v->pref->os == v__pref__OS__windows && !string__eq(v->pref->ccompiler, _SLIT("msvc"))) || (string__eq(flag->os, _SLIT("solaris")) && v->pref->os == v__pref__OS__solaris)) {
			array_push((array*)&flags, _MOV((v__cflag__CFlag[]){ *flag }));
		}
		if (Array_string_contains(ctimedefines, flag->os)) {
			array_push((array*)&flags, _MOV((v__cflag__CFlag[]){ *flag }));
		}
	}
	Array_v__cflag__CFlag _t5 = flags;
	return _t5;
}

VV_LOCAL_SYMBOL Array_v__cflag__CFlag v__builder__Builder_get_rest_of_module_cflags(v__builder__Builder* v, v__cflag__CFlag* c) {
	Array_v__cflag__CFlag flags = __new_array_with_default(0, 0, sizeof(v__cflag__CFlag), 0);
	Array_v__cflag__CFlag cflags = v__builder__Builder_get_os_cflags(v);
	for (int _t1 = 0; _t1 < cflags.len; ++_t1) {
		v__cflag__CFlag flag = ((v__cflag__CFlag*)cflags.data)[_t1];
		if (string__eq(c->mod, flag.mod)) {
			if (string__eq(c->name, flag.name) && string__eq(c->value, flag.value) && string__eq(c->os, flag.os)) {
				continue;
			}
			array_push((array*)&flags, _MOV((v__cflag__CFlag[]){ flag }));
		}
	}
	Array_v__cflag__CFlag _t3 = flags;
	return _t3;
}

// TypeDecl
void v__builder__compile(string command, v__pref__Preferences* pref, void (*backend_cb)(v__builder__Builder* b)) {
	string odir = os__dir(pref->out_name);
	string output_folder = odir;
	if (odir.len == pref->out_name.len) {
		output_folder = os__getwd();
	}
	Option_bool _t1 = os__is_writable_folder(output_folder);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		v__builder__verror((*(err.msg)));
		VUNREACHABLE();
	;
	}
	
  (*(bool*)_t1.data);
	v__builder__Builder b = v__builder__new_builder(pref);
	if (pref->is_verbose) {
		println(_SLIT("builder.compile() pref:"));
	}
	time__StopWatch sw = time__new_stopwatch((time__StopWatchOptions){.auto_start = true,});
	backend_cb((voidptr)&/*qq*/b);
	v__util__Timers* timers = v__util__get_timers();
	v__util__Timers_show_remaining(timers);
	if (pref->is_stats) {
		i64 compilation_time_micros = 1 + time__Duration_microseconds(time__StopWatch_elapsed(sw));
		string scompilation_time_ms = v__util__bold( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xc062d, {.d_f64 = ((f64)(compilation_time_micros)) / 1000.0}}, {_SLIT0, 0, { .d_c = 0 }}})));
		int all_v_source_lines = 0;
		int all_v_source_bytes = 0;
		for (int _t2 = 0; _t2 < b.parsed_files.len; ++_t2) {
			v__ast__File* pf = ((v__ast__File**)b.parsed_files.data)[_t2];
			all_v_source_lines += pf->nr_lines;
			all_v_source_bytes += pf->nr_bytes;
		}
		string sall_v_source_lines = int_str(all_v_source_lines);
		string sall_v_source_bytes = int_str(all_v_source_bytes);
		sall_v_source_lines = v__util__bold( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0x14fe30, {.d_s = sall_v_source_lines}}, {_SLIT0, 0, { .d_c = 0 }}})));
		sall_v_source_bytes = v__util__bold( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0x14fe30, {.d_s = sall_v_source_bytes}}, {_SLIT0, 0, { .d_c = 0 }}})));
		println( str_intp(3, _MOV((StrIntpData[]){{_SLIT("        V  source  code size: "), 0xfe10, {.d_s = sall_v_source_lines}}, {_SLIT(" lines, "), 0xfe10, {.d_s = sall_v_source_bytes}}, {_SLIT(" bytes"), 0, { .d_c = 0 }}})));
		string slines = int_str(b.stats_lines);
		string sbytes = int_str(b.stats_bytes);
		slines = v__util__bold( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0x14fe30, {.d_s = slines}}, {_SLIT0, 0, { .d_c = 0 }}})));
		sbytes = v__util__bold( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0x14fe30, {.d_s = sbytes}}, {_SLIT0, 0, { .d_c = 0 }}})));
		println( str_intp(3, _MOV((StrIntpData[]){{_SLIT("generated  target  code size: "), 0xfe10, {.d_s = slines}}, {_SLIT(" lines, "), 0xfe10, {.d_s = sbytes}}, {_SLIT(" bytes"), 0, { .d_c = 0 }}})));
		int vlines_per_second = ((int)(1000000.0 * ((f64)(all_v_source_lines)) / ((f64)(compilation_time_micros))));
		string svlines_per_second = v__util__bold(int_str(vlines_per_second));
		println( str_intp(3, _MOV((StrIntpData[]){{_SLIT("compilation took: "), 0xfe10, {.d_s = scompilation_time_ms}}, {_SLIT(" ms, compilation speed: "), 0xfe10, {.d_s = svlines_per_second}}, {_SLIT(" vlines/s"), 0, { .d_c = 0 }}})));
	}
	v__builder__Builder_exit_on_invalid_syntax(&b);
	v__builder__Builder_myfree(&b);
	if (pref->is_test || pref->is_run) {
		v__builder__Builder_run_compiled_executable_and_exit(&b);
	}
}

string v__builder__Builder_get_vtmp_filename(v__builder__Builder* b, string base_file_name, string postfix) {
	string vtmp = v__util__get_vtmp_folder();
	string uniq = _SLIT("");
	if (!b->pref->reuse_tmpc) {
		uniq =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("."), 0xfe08, {.d_u64 = rand__u64()}}, {_SLIT0, 0, { .d_c = 0 }}}));
	}
	string fname = string__plus(os__file_name(os__real_path(base_file_name)),  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = uniq}}, {_SLIT0, 0xfe10, {.d_s = postfix}}, {_SLIT0, 0, { .d_c = 0 }}})));
	string _t1 = os__real_path(os__join_path(vtmp, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){fname}))));
	return _t1;
}

// Attr: [unsafe]
VV_LOCAL_SYMBOL void v__builder__Builder_myfree(v__builder__Builder* b) {
	array_free(&b->parsed_files);
	v__util__free_caches();
}

VV_LOCAL_SYMBOL void v__builder__Builder_exit_on_invalid_syntax(v__builder__Builder* b) {
	v__util__free_caches();
	if (b->pref->only_check_syntax) {
		for (int _t1 = 0; _t1 < b->parsed_files.len; ++_t1) {
			v__ast__File* pf = ((v__ast__File**)b->parsed_files.data)[_t1];
			if (pf->errors.len > 0) {
				_v_exit(1);
				VUNREACHABLE();
			}
		}
		if (b->checker->nr_errors > 0) {
			_v_exit(1);
			VUNREACHABLE();
		}
	}
}

VV_LOCAL_SYMBOL void v__builder__Builder_run_compiled_executable_and_exit(v__builder__Builder* b) {
	if (b->pref->backend == v__pref__Backend__interpret) {
		return;
	}
	if (b->pref->skip_running) {
		return;
	}
	if (b->pref->only_check_syntax || b->pref->check_only) {
		return;
	}
	if (v__pref__Preferences_should_output_to_stdout(b->pref)) {
		return;
	}
	if (b->pref->os == v__pref__OS__ios) {
		_v_panic(_SLIT("Running iOS apps is not supported yet."));
		VUNREACHABLE();
	}
	if (b->pref->is_verbose) {
	}
	if (b->pref->is_test || b->pref->is_run) {
		string compiled_file = os__real_path(b->pref->out_name);
		string _t1; /* if prepend */
		if (v__pref__Backend_is_js(b->pref->backend)) {
			#if defined(_WIN32)
			string node_basename = _SLIT("node.exe");
			#else
			#endif
			;
Option_string _t2 = os__find_abs_path_of_executable(node_basename);
			if (_t2.state != 0) { /*or block*/ 
				IError err = _t2.err;
				_v_panic(_SLIT("Could not find `node` in system path. Do you have Node.js installed?"));
				VUNREACHABLE();
			;
			}
			
 			_t1 =  (*(string*)_t2.data);
		} else {
			_t1 = compiled_file;
		}
		string run_file =  _t1;
		Array_string run_args = __new_array_with_default(0, b->pref->run_args.len + 1, sizeof(string), 0);
		if (v__pref__Backend_is_js(b->pref->backend)) {
			array_push((array*)&run_args, _MOV((string[]){ string_clone(compiled_file) }));
		}
		_PUSH_MANY(&run_args, (b->pref->run_args), _t4, Array_string);
		os__Process* run_process = os__new_process(run_file);
		os__Process_set_args(run_process, run_args);
		if (b->pref->is_verbose) {
			println( str_intp(3, _MOV((StrIntpData[]){{_SLIT("running "), 0xfe10, {.d_s = run_process->filename}}, {_SLIT(" with arguments "), 0xfe10, {.d_s = Array_string_str(run_process->args)}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		Option_os__SignalHandler _t5 = os__signal_opt(os__Signal__int, (voidptr)v__builder__eshcb);
		if (_t5.state != 0) { /*or block*/ 
			IError err = _t5.err;
			v__builder__serror(_SLIT("set .int"), err);
			VUNREACHABLE();
		;
		}
		
 		void (*prev_int_handler) (os__Signal ) =  (*(os__SignalHandler*)_t5.data);
		void (*prev_quit_handler) (os__Signal ) = ((os__SignalHandler)(v__builder__eshcb));
		os__Process_wait(run_process);
		Option_os__SignalHandler _t6 = os__signal_opt(os__Signal__int, (voidptr)prev_int_handler);
		if (_t6.state != 0) { /*or block*/ 
			IError err = _t6.err;
			v__builder__serror(_SLIT("restore .int"), err);
			VUNREACHABLE();
		;
		}
		
  (*(os__SignalHandler*)_t6.data);
		int ret = run_process->code;
		os__Process_close(run_process);
		v__builder__Builder_cleanup_run_executable_after_exit(b, compiled_file);
		_v_exit(ret);
		VUNREACHABLE();
	}
	_v_exit(0);
	VUNREACHABLE();
}

VV_LOCAL_SYMBOL void v__builder__eshcb(os__Signal _d1) {
}

// Attr: [noreturn]
VNORETURN VV_LOCAL_SYMBOL void v__builder__serror(string reason, IError e) {
	eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("could not "), 0xfe10, {.d_s = reason}}, {_SLIT(" handler"), 0, { .d_c = 0 }}})));
	_v_panic(IError_str(e));
	VUNREACHABLE();
	while(1);
}

VV_LOCAL_SYMBOL void v__builder__Builder_cleanup_run_executable_after_exit(v__builder__Builder* v, string exefile) {
	if (v->pref->reuse_tmpc) {
		v__pref__Preferences_vrun_elog(v->pref,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("keeping executable: "), 0xfe10, {.d_s = exefile}}, {_SLIT(" , because -keepc was passed"), 0, { .d_c = 0 }}})));
		return;
	}
	v__pref__Preferences_vrun_elog(v->pref,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("remove run executable: "), 0xfe10, {.d_s = exefile}}, {_SLIT0, 0, { .d_c = 0 }}})));
	Option_void _t1 = os__rm(exefile);
	if (_t1.state != 0 && _t1.err._typ != _IError_None___index) {
		IError err = _t1.err;
	}
	
 ;
}

void v__builder__Builder_set_module_lookup_paths(v__builder__Builder* v) {
	v->module_search_paths = __new_array_with_default(0, 0, sizeof(string), 0);
	if (v->pref->is_test) {
		array_push((array*)&v->module_search_paths, _MOV((string[]){ string_clone(os__dir(v->compiled_dir)) }));
	}
	array_push((array*)&v->module_search_paths, _MOV((string[]){ string_clone(v->compiled_dir) }));
	string x = os__join_path(v->compiled_dir, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("modules")})));
	if (v->pref->is_verbose) {
		println( str_intp(2, _MOV((StrIntpData[]){{_SLIT("x: \""), 0xfe10, {.d_s = x}}, {_SLIT("\""), 0, { .d_c = 0 }}})));
	}
	array_push((array*)&v->module_search_paths, _MOV((string[]){ string_clone(os__join_path(v->compiled_dir, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("modules")})))) }));
	_PUSH_MANY(&v->module_search_paths, (v->pref->lookup_path), _t4, Array_string);
	if (v->pref->is_verbose) {
		v__builder__Builder_log(v, _SLIT("v.module_search_paths:"));
		println(Array_string_str(v->module_search_paths));
	}
}

Array_string v__builder__Builder_get_builtin_files(v__builder__Builder* v) {
	if (v->pref->no_builtin) {
		v__builder__Builder_log(v, _SLIT("v.pref.no_builtin is true, get_builtin_files == []"));
		Array_string _t1 = __new_array_with_default(0, 0, sizeof(string), 0);
		return _t1;
	}
	v__builder__Builder_log(v,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("v.pref.lookup_path: "), 0xfe10, {.d_s = Array_string_str(v->pref->lookup_path)}}, {_SLIT0, 0, { .d_c = 0 }}})));
	for (int _t2 = 0; _t2 < v->pref->lookup_path.len; ++_t2) {
		string location = ((string*)v->pref->lookup_path.data)[_t2];
		if (os__exists(os__join_path(location, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("builtin")}))))) {
			Array_string builtin_files = __new_array_with_default(0, 0, sizeof(string), 0);
			if (v__pref__Backend_is_js(v->pref->backend)) {
				_PUSH_MANY(&builtin_files, (v__builder__Builder_v_files_from_dir(v, os__join_path(location, new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT("builtin"), _SLIT("js")}))))), _t3, Array_string);
			} else {
				_PUSH_MANY(&builtin_files, (v__builder__Builder_v_files_from_dir(v, os__join_path(location, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("builtin")}))))), _t4, Array_string);
			}
			if (v->pref->is_bare) {
				_PUSH_MANY(&builtin_files, (v__builder__Builder_v_files_from_dir(v, v->pref->bare_builtin_dir)), _t5, Array_string);
			}
			if (v->pref->backend == v__pref__Backend__c) {
				if (v->pref->is_vsh && os__exists(os__join_path(location, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("os")}))))) {
					_PUSH_MANY(&builtin_files, (v__builder__Builder_v_files_from_dir(v, os__join_path(location, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("os")}))))), _t6, Array_string);
				}
			}
			Array_string _t7 = builtin_files;
			return _t7;
		}
	}
	v__builder__verror(_SLIT("`builtin/` not included on module lookup path.\nDid you forget to add vlib to the path? (Use @vlib for default vlib)"));
	VUNREACHABLE();
	return __new_array(0, 0, sizeof(string));
}

Array_string v__builder__Builder_get_user_files(v__builder__Builder* v) {
	if ((string__eq(v->pref->path, _SLIT("vlib/builtin")) || string__eq(v->pref->path, _SLIT("vlib/strconv")) || string__eq(v->pref->path, _SLIT("vlib/strings")) || string__eq(v->pref->path, _SLIT("vlib/hash"))) || string_ends_with(v->pref->path, _SLIT("vlib/builtin"))) {
		v__builder__Builder_log(v, _SLIT("Skipping user files."));
		Array_string _t1 = __new_array_with_default(0, 0, sizeof(string), 0);
		return _t1;
	}
	string dir = v->pref->path;
	v__builder__Builder_log(v,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("get_v_files("), 0xfe10, {.d_s = dir}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
	Array_string user_files = __new_array_with_default(0, 0, sizeof(string), 0);
	string vroot = os__dir(v__pref__vexe_path());
	string preludes_path = os__join_path(vroot, new_array_from_c_array(3, 3, sizeof(string), _MOV((string[3]){_SLIT("vlib"), _SLIT("v"), _SLIT("preludes")})));
	if (v->pref->backend == v__pref__Backend__js_node) {
		preludes_path = os__join_path(vroot, new_array_from_c_array(3, 3, sizeof(string), _MOV((string[3]){_SLIT("vlib"), _SLIT("v"), _SLIT("preludes_js")})));
	}
	if (v->pref->is_livemain || v->pref->is_liveshared) {
		array_push((array*)&user_files, _MOV((string[]){ string_clone(os__join_path(preludes_path, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("live.v")})))) }));
	}
	if (v->pref->is_livemain) {
		array_push((array*)&user_files, _MOV((string[]){ string_clone(os__join_path(preludes_path, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("live_main.v")})))) }));
	}
	if (v->pref->is_liveshared) {
		array_push((array*)&user_files, _MOV((string[]){ string_clone(os__join_path(preludes_path, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("live_shared.v")})))) }));
	}
	if (v->pref->is_test) {
		array_push((array*)&user_files, _MOV((string[]){ string_clone(os__join_path(preludes_path, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("test_runner.v")})))) }));
		string v_test_runner_prelude = os__getenv(_SLIT("VTEST_RUNNER"));
		if ((v->pref->test_runner).len != 0) {
			v_test_runner_prelude = v->pref->test_runner;
		}
		if ((v_test_runner_prelude).len == 0) {
			v_test_runner_prelude = _SLIT("normal");
		}
		if (!string_contains(v_test_runner_prelude, _SLIT("/")) && !string_contains(v_test_runner_prelude, _SLIT("\\")) && !string_ends_with(v_test_runner_prelude, _SLIT(".v"))) {
			v_test_runner_prelude = os__join_path(preludes_path, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){ str_intp(2, _MOV((StrIntpData[]){{_SLIT("test_runner_"), 0xfe10, {.d_s = v_test_runner_prelude}}, {_SLIT(".v"), 0, { .d_c = 0 }}}))})));
		}
		if (!os__is_file(v_test_runner_prelude) || !os__is_readable(v_test_runner_prelude)) {
			eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("test runner error: File "), 0xfe10, {.d_s = v_test_runner_prelude}}, {_SLIT(" should be readable."), 0, { .d_c = 0 }}})));
			v__builder__verror(_SLIT("supported test runners are: tap, json, simple, normal"));
			VUNREACHABLE();
		}
		array_push((array*)&user_files, _MOV((string[]){ string_clone(v_test_runner_prelude) }));
	}
	if (v->pref->is_test && v->pref->is_stats) {
		array_push((array*)&user_files, _MOV((string[]){ string_clone(os__join_path(preludes_path, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("tests_with_stats.v")})))) }));
	}
	if (v__pref__Backend_is_js(v->pref->backend) && v->pref->is_stats && v->pref->is_test) {
		array_push((array*)&user_files, _MOV((string[]){ string_clone(os__join_path(preludes_path, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("stats_import.js.v")})))) }));
	}
	if (v->pref->is_prof) {
		array_push((array*)&user_files, _MOV((string[]){ string_clone(os__join_path(preludes_path, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("profiled_program.v")})))) }));
	}
	bool is_test = v->pref->is_test;
	bool is_internal_module_test = false;
	if (is_test) {
		Option_string _t10 = v__util__read_file(dir);
		if (_t10.state != 0) { /*or block*/ 
			IError err = _t10.err;
			v__builder__verror( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = dir}}, {_SLIT(" does not exist"), 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		;
		}
		
 		string tcontent =  (*(string*)_t10.data);
		Array_string slines = string_split_into_lines(tcontent);
		for (int _t11 = 0; _t11 < slines.len; ++_t11) {
			string sline = ((string*)slines.data)[_t11];
			string line = string_trim_space(sline);
			if (line.len > 2) {
				if (string_at(line, 0) == '/' && string_at(line, 1) == '/') {
					continue;
				}
				if (string_starts_with(line, _SLIT("module "))) {
					is_internal_module_test = true;
					break;
				}
			}
		}
	}
	if (is_internal_module_test) {
		string single_test_v_file = os__real_path(dir);
		if (v->pref->is_verbose) {
			v__builder__Builder_log(v,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("> Compiling an internal module _test.v file "), 0xfe10, {.d_s = single_test_v_file}}, {_SLIT(" ."), 0, { .d_c = 0 }}})));
			v__builder__Builder_log(v, _SLIT("> That brings in all other ordinary .v files in the same module too ."));
		}
		array_push((array*)&user_files, _MOV((string[]){ string_clone(single_test_v_file) }));
		dir = os__dir(single_test_v_file);
	}
	bool does_exist = os__exists(dir);
	if (!does_exist) {
		v__builder__verror( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = dir}}, {_SLIT(" doesn't exist"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	bool is_real_file = does_exist && !os__is_dir(dir);
	string resolved_link = (is_real_file && os__is_link(dir) ? (os__real_path(dir)) : (dir));
	if (is_real_file && (string_ends_with(dir, _SLIT(".v")) || string_ends_with(resolved_link, _SLIT(".vsh")) || string_ends_with(dir, _SLIT(".vv")))) {
		string single_v_file = (string_ends_with(resolved_link, _SLIT(".vsh")) ? (resolved_link) : (dir));
		array_push((array*)&user_files, _MOV((string[]){ string_clone(single_v_file) }));
		if (v->pref->is_verbose) {
			v__builder__Builder_log(v,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("> just compile one file: \""), 0xfe10, {.d_s = single_v_file}}, {_SLIT("\""), 0, { .d_c = 0 }}})));
		}
	} else if (os__is_dir(dir)) {
		if (v->pref->is_verbose) {
			v__builder__Builder_log(v,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("> add all .v files from directory \""), 0xfe10, {.d_s = dir}}, {_SLIT("\" ..."), 0, { .d_c = 0 }}})));
		}
		_PUSH_MANY(&user_files, (v__builder__Builder_v_files_from_dir(v, dir)), _t14, Array_string);
	} else {
		println(_SLIT("usage: `v file.v` or `v directory`"));
		string ext = os__file_ext(dir);
		println( str_intp(2, _MOV((StrIntpData[]){{_SLIT("unknown file extension `"), 0xfe10, {.d_s = ext}}, {_SLIT("`"), 0, { .d_c = 0 }}})));
		_v_exit(1);
		VUNREACHABLE();
	}
	if (user_files.len == 0) {
		println(_SLIT("No input .v files"));
		_v_exit(1);
		VUNREACHABLE();
	}
	if (v->pref->is_verbose) {
		v__builder__Builder_log(v,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("user_files: "), 0xfe10, {.d_s = Array_string_str(user_files)}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
	Array_string _t15 = user_files;
	return _t15;
}

// TypeDecl
VV_LOCAL_SYMBOL Option_string v__builder__find_windows_kit_internal(v__builder__RegKey key, Array_string versions) {
	{ // Unsafe block
		for (int _t1 = 0; _t1 < versions.len; ++_t1) {
			string version = ((string*)versions.data)[_t1];
			u32 required_bytes = ((u32)(0U));
			voidptr result = RegQueryValueEx(key, string_to_wide(version), 0, 0, 0, &required_bytes);
			u32 length = required_bytes / 2U;
			if (result != 0) {
				continue;
			}
			u32 alloc_length = (required_bytes + 2U);
			u16* value = ((u16*)(malloc_noscan(((int)(alloc_length)))));
			if (isnil(value)) {
				continue;
			} else {
			}
			voidptr result2 = RegQueryValueEx(key, string_to_wide(version), 0, 0, value, &alloc_length);
			if (result2 != 0) {
				continue;
			}
			if (value[length - 1U] != ((u16)(0U))) {
				value[length] = ((u16)(0U));
			}
			string res = string_from_wide(value);
			Option_string _t2;
			opt_ok(&(string[]) { res }, (Option*)(&_t2), sizeof(string));
			return _t2;
		}
	}
	return (Option_string){ .state=2, .err=_v_error(_SLIT("windows kit not found")), .data={EMPTY_STRUCT_INITIALIZATION} };
}

VV_LOCAL_SYMBOL Option_v__builder__WindowsKit v__builder__find_windows_kit_root(string target_arch) {
	#if defined(_WIN32)
	{
		Option_v__builder__WindowsKit _t1 = v__builder__find_windows_kit_root_by_reg(target_arch);
		if (_t1.state != 0) { /*or block*/ 
			IError err = _t1.err;
			Option_v__builder__WindowsKit _t2;
			if (_t2 = v__builder__find_windows_kit_root_by_env(target_arch), _t2.state == 0) {
				v__builder__WindowsKit wkroot = *(v__builder__WindowsKit*)_t2.data;
				Option_v__builder__WindowsKit _t3;
				opt_ok(&(v__builder__WindowsKit[]) { wkroot }, (Option*)(&_t3), sizeof(v__builder__WindowsKit));
				return _t3;
			}
			return (Option_v__builder__WindowsKit){ .state=2, .err=err, .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		
 		v__builder__WindowsKit wkroot =  (*(v__builder__WindowsKit*)_t1.data);
		Option_v__builder__WindowsKit _t5;
		opt_ok(&(v__builder__WindowsKit[]) { wkroot }, (Option*)(&_t5), sizeof(v__builder__WindowsKit));
		return _t5;
	}
	#else
	{
	}
	#endif
	return (Option_v__builder__WindowsKit){0};
}

VV_LOCAL_SYMBOL Option_v__builder__WindowsKit v__builder__find_windows_kit_root_by_reg(string target_arch) {
	#if defined(_WIN32)
	{
		v__builder__RegKey root_key = ((v__builder__RegKey)(0));
		string path = _SLIT("SOFTWARE\\Microsoft\\Windows Kits\\Installed Roots");
		voidptr rc = RegOpenKeyEx(_const_v__builder__hkey_local_machine, string_to_wide(path), 0U, ((_const_v__builder__key_query_value | _const_v__builder__key_wow64_32key) | _const_v__builder__key_enumerate_sub_keys), &root_key);
		if (rc != 0) {
			return (Option_v__builder__WindowsKit){ .state=2, .err=_v_error(_SLIT("Unable to open root key")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		Option_string _t2 = v__builder__find_windows_kit_internal(root_key, new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT("KitsRoot10"), _SLIT("KitsRoot81")})));
		if (_t2.state != 0) { /*or block*/ 
			IError err = _t2.err;
			RegCloseKey(root_key);
			return (Option_v__builder__WindowsKit){ .state=2, .err=_v_error(_SLIT("Unable to find a windows kit")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		
 		string kit_root =  (*(string*)_t2.data);
		RegCloseKey(root_key);
		Option_v__builder__WindowsKit _t4 = v__builder__new_windows_kit(kit_root, target_arch);
		return _t4;
	}
	#else
	{
	}
	#endif
	return (Option_v__builder__WindowsKit){0};
}

VV_LOCAL_SYMBOL Option_v__builder__WindowsKit v__builder__new_windows_kit(string kit_root, string target_arch) {
	string kit_lib = string__plus(kit_root, _SLIT("Lib"));
	Option_Array_string _t1 = os__ls(kit_lib);
	if (_t1.state != 0) { /*or block*/ 
		Option_v__builder__WindowsKit _t2;
		memcpy(&_t2, &_t1, sizeof(Option));
		return _t2;
	}
	
 	Array_string files =  (*(Array_string*)_t1.data);
	string highest_path = _SLIT("");
	int highest_int = 0;
	for (int _t3 = 0; _t3 < files.len; ++_t3) {
		string f = ((string*)files.data)[_t3];
		string no_dot = string_replace(f, _SLIT("."), _SLIT(""));
		int v_int = string_int(no_dot);
		if (v_int > highest_int) {
			highest_int = v_int;
			highest_path = f;
		}
	}
	string kit_lib_highest = string__plus(kit_lib,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\\"), 0xfe10, {.d_s = highest_path}}, {_SLIT0, 0, { .d_c = 0 }}})));
	string kit_include_highest = string_replace(kit_lib_highest, _SLIT("Lib"), _SLIT("Include"));
	Option_v__builder__WindowsKit _t4;
	opt_ok(&(v__builder__WindowsKit[]) { (v__builder__WindowsKit){.um_lib_path = string__plus(kit_lib_highest,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\\um\\"), 0xfe10, {.d_s = target_arch}}, {_SLIT0, 0, { .d_c = 0 }}}))),.ucrt_lib_path = string__plus(kit_lib_highest,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\\ucrt\\"), 0xfe10, {.d_s = target_arch}}, {_SLIT0, 0, { .d_c = 0 }}}))),.um_include_path = string__plus(kit_include_highest, _SLIT("\\um")),.ucrt_include_path = string__plus(kit_include_highest, _SLIT("\\ucrt")),.shared_include_path = string__plus(kit_include_highest, _SLIT("\\shared")),} }, (Option*)(&_t4), sizeof(v__builder__WindowsKit));
	return _t4;
}

VV_LOCAL_SYMBOL Option_v__builder__WindowsKit v__builder__find_windows_kit_root_by_env(string target_arch) {
	string kit_root = os__getenv(_SLIT("WindowsSdkDir"));
	if ((kit_root).len == 0) {
		return (Option_v__builder__WindowsKit){ .state=2, .err=_v_error(_SLIT("empty WindowsSdkDir")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Option_v__builder__WindowsKit _t2 = v__builder__new_windows_kit(kit_root, target_arch);
	return _t2;
}

VV_LOCAL_SYMBOL Option_v__builder__VsInstallation v__builder__find_vs(string vswhere_dir, string host_arch, string target_arch) {
	#if defined(_WIN32)
	{
		Option_v__builder__VsInstallation _t1 = v__builder__find_vs_by_reg(vswhere_dir, host_arch, target_arch);
		if (_t1.state != 0) { /*or block*/ 
			IError err = _t1.err;
			Option_v__builder__VsInstallation _t2;
			if (_t2 = v__builder__find_vs_by_env(host_arch, target_arch), _t2.state == 0) {
				v__builder__VsInstallation vsinst = *(v__builder__VsInstallation*)_t2.data;
				Option_v__builder__VsInstallation _t3;
				opt_ok(&(v__builder__VsInstallation[]) { vsinst }, (Option*)(&_t3), sizeof(v__builder__VsInstallation));
				return _t3;
			}
			return (Option_v__builder__VsInstallation){ .state=2, .err=err, .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		
 		v__builder__VsInstallation vsinst =  (*(v__builder__VsInstallation*)_t1.data);
		Option_v__builder__VsInstallation _t5;
		opt_ok(&(v__builder__VsInstallation[]) { vsinst }, (Option*)(&_t5), sizeof(v__builder__VsInstallation));
		return _t5;
	}
	#else
	{
	}
	#endif
	return (Option_v__builder__VsInstallation){0};
}

VV_LOCAL_SYMBOL Option_v__builder__VsInstallation v__builder__find_vs_by_reg(string vswhere_dir, string host_arch, string target_arch) {
	#if defined(_WIN32)
	{
		os__Result res = os__execute( str_intp(2, _MOV((StrIntpData[]){{_SLIT("\""), 0xfe10, {.d_s = vswhere_dir}}, {_SLIT("\\Microsoft Visual Studio\\Installer\\vswhere.exe\" -latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationPath"), 0, { .d_c = 0 }}})));
		if (res.exit_code != 0) {
			return (Option_v__builder__VsInstallation){ .state=2, .err=error_with_code(res.output, res.exit_code), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		string res_output = string_trim_right(res.output, _SLIT("\r\n"));
		Option_string _t2 = os__read_file( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = res_output}}, {_SLIT("\\VC\\Auxiliary\\Build\\Microsoft.VCToolsVersion.default.txt"), 0, { .d_c = 0 }}})));
		if (_t2.state != 0) { /*or block*/ 
			IError err = _t2.err;
			return (Option_v__builder__VsInstallation){ .state=2, .err=_v_error(_SLIT("Unable to find vs installation")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		
 		string version =  (*(string*)_t2.data);
		string version2 = version;
		string v = (string_ends_with(version, _SLIT("\n")) ? (string_substr(version2, 0, version.len - 2)) : (version2));
		string lib_path =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = res.output}}, {_SLIT("\\VC\\Tools\\MSVC\\"), 0xfe10, {.d_s = v}}, {_SLIT("\\lib\\"), 0xfe10, {.d_s = target_arch}}, {_SLIT0, 0, { .d_c = 0 }}}));
		string include_path =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = res.output}}, {_SLIT("\\VC\\Tools\\MSVC\\"), 0xfe10, {.d_s = v}}, {_SLIT("\\include"), 0, { .d_c = 0 }}}));
		if (os__exists( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = lib_path}}, {_SLIT("\\vcruntime.lib"), 0, { .d_c = 0 }}})))) {
			string p =  str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = res.output}}, {_SLIT("\\VC\\Tools\\MSVC\\"), 0xfe10, {.d_s = v}}, {_SLIT("\\bin\\Host"), 0xfe10, {.d_s = host_arch}}, {_SLIT("\\"), 0xfe10, {.d_s = target_arch}}, {_SLIT0, 0, { .d_c = 0 }}}));
			Option_v__builder__VsInstallation _t4;
			opt_ok(&(v__builder__VsInstallation[]) { (v__builder__VsInstallation){.include_path = include_path,.lib_path = lib_path,.exe_path = p,} }, (Option*)(&_t4), sizeof(v__builder__VsInstallation));
			return _t4;
		}
		println( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Unable to find vs installation (attempted to use lib path \""), 0xfe10, {.d_s = lib_path}}, {_SLIT("\")"), 0, { .d_c = 0 }}})));
		return (Option_v__builder__VsInstallation){ .state=2, .err=_v_error(_SLIT("Unable to find vs exe folder")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	#else
	{
	}
	#endif
	return (Option_v__builder__VsInstallation){0};
}

VV_LOCAL_SYMBOL Option_v__builder__VsInstallation v__builder__find_vs_by_env(string host_arch, string target_arch) {
	string vs_dir = os__getenv(_SLIT("VSINSTALLDIR"));
	if ((vs_dir).len == 0) {
		return (Option_v__builder__VsInstallation){ .state=2, .err=_v_error(_SLIT("empty VSINSTALLDIR")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	string vc_tools_dir = os__getenv(_SLIT("VCToolsInstallDir"));
	if ((vc_tools_dir).len == 0) {
		return (Option_v__builder__VsInstallation){ .state=2, .err=_v_error(_SLIT("empty VCToolsInstallDir")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	string bin_dir =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = vc_tools_dir}}, {_SLIT("bin\\Host"), 0xfe10, {.d_s = host_arch}}, {_SLIT("\\"), 0xfe10, {.d_s = target_arch}}, {_SLIT0, 0, { .d_c = 0 }}}));
	string lib_path =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = vc_tools_dir}}, {_SLIT("lib\\"), 0xfe10, {.d_s = target_arch}}, {_SLIT0, 0, { .d_c = 0 }}}));
	string include_path =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = vc_tools_dir}}, {_SLIT("include"), 0, { .d_c = 0 }}}));
	Option_v__builder__VsInstallation _t3;
	opt_ok(&(v__builder__VsInstallation[]) { (v__builder__VsInstallation){.include_path = include_path,.lib_path = lib_path,.exe_path = bin_dir,} }, (Option*)(&_t3), sizeof(v__builder__VsInstallation));
	return _t3;
}

VV_LOCAL_SYMBOL Option_v__builder__MsvcResult v__builder__find_msvc(bool m64_target) {
	#if defined(_WIN32)
	{
		string processor_architecture = os__getenv(_SLIT("PROCESSOR_ARCHITECTURE"));
		string vswhere_dir = (string__eq(processor_architecture, _SLIT("x86")) ? (_SLIT("%ProgramFiles%")) : (_SLIT("%ProgramFiles(x86)%")));
		string host_arch = (string__eq(processor_architecture, _SLIT("x86")) ? (_SLIT("X86")) : (_SLIT("X64")));
		string target_arch = (!m64_target ? (_SLIT("X86")) : (_SLIT("X64")));
		Option_v__builder__WindowsKit _t1 = v__builder__find_windows_kit_root(target_arch);
		if (_t1.state != 0) { /*or block*/ 
			IError err = _t1.err;
			return (Option_v__builder__MsvcResult){ .state=2, .err=_v_error(_SLIT("Unable to find windows sdk")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		
 		v__builder__WindowsKit wk =  (*(v__builder__WindowsKit*)_t1.data);
		Option_v__builder__VsInstallation _t3 = v__builder__find_vs(vswhere_dir, host_arch, target_arch);
		if (_t3.state != 0) { /*or block*/ 
			IError err = _t3.err;
			return (Option_v__builder__MsvcResult){ .state=2, .err=_v_error(_SLIT("Unable to find visual studio")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		
 		v__builder__VsInstallation vs =  (*(v__builder__VsInstallation*)_t3.data);
		Option_v__builder__MsvcResult _t5;
		opt_ok(&(v__builder__MsvcResult[]) { (v__builder__MsvcResult){
			.full_cl_exe_path = os__real_path(string__plus(string__plus(vs.exe_path, _const_os__path_separator), _SLIT("cl.exe"))),
			.exe_path = vs.exe_path,
			.um_lib_path = wk.um_lib_path,
			.ucrt_lib_path = wk.ucrt_lib_path,
			.vs_lib_path = vs.lib_path,
			.um_include_path = wk.um_include_path,
			.ucrt_include_path = wk.ucrt_include_path,
			.vs_include_path = vs.include_path,
			.shared_include_path = wk.shared_include_path,
			.valid = true,
		} }, (Option*)(&_t5), sizeof(v__builder__MsvcResult));
		return _t5;
	}
	#else
	{
	}
	#endif
	return (Option_v__builder__MsvcResult){0};
}

void v__builder__Builder_cc_msvc(v__builder__Builder* v) {
	v__builder__MsvcResult r = v->cached_msvc;
	if (r.valid == false) {
		v__builder__verror(_SLIT("Cannot find MSVC on this OS"));
		VUNREACHABLE();
	}
	string out_name_obj = os__real_path(string__plus(v->out_name_c, _SLIT(".obj")));
	string out_name_pdb = os__real_path(string__plus(v->out_name_c, _SLIT(".pdb")));
	string out_name_cmd_line = os__real_path(string__plus(v->out_name_c, _SLIT(".rsp")));
	string env_cflags = os__getenv(_SLIT("CFLAGS"));
	string env_ldflags = os__getenv(_SLIT("LDFLAGS"));
	Array_string a = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){string_clone(v->pref->cflags)}));
	if ((env_cflags).len != 0) {
		array_push((array*)&a, _MOV((string[]){ string_clone(env_cflags) }));
	}
	_PUSH_MANY(&a, (new_array_from_c_array(5, 5, sizeof(string), _MOV((string[5]){_SLIT("-w"), _SLIT("/we4013"), _SLIT("/volatile:ms"),  str_intp(2, _MOV((StrIntpData[]){{_SLIT("/Fo\""), 0xfe10, {.d_s = out_name_obj}}, {_SLIT("\""), 0, { .d_c = 0 }}})), _SLIT("/F 16777216")}))), _t2, Array_string);
	if (v->pref->is_prod) {
		array_push((array*)&a, _MOV((string[]){ string_clone(_SLIT("/O2")) }));
	}
	if (v->pref->is_debug) {
		array_push((array*)&a, _MOV((string[]){ string_clone(_SLIT("/MDd")) }));
		array_push((array*)&a, _MOV((string[]){ string_clone(_SLIT("/D_DEBUG")) }));
		_PUSH_MANY(&a, (new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT("/Zi"),  str_intp(2, _MOV((StrIntpData[]){{_SLIT("/Fd\""), 0xfe10, {.d_s = out_name_pdb}}, {_SLIT("\""), 0, { .d_c = 0 }}}))}))), _t6, Array_string);
	} else {
		array_push((array*)&a, _MOV((string[]){ string_clone(_SLIT("/MD")) }));
		array_push((array*)&a, _MOV((string[]){ string_clone(_SLIT("/DNDEBUG")) }));
	}
	if (v->pref->is_shared) {
		if (!string_ends_with(v->pref->out_name, _SLIT(".dll"))) {
			v->pref->out_name = /*f*/string__plus(v->pref->out_name, _SLIT(".dll"));
		}
		array_push((array*)&a, _MOV((string[]){ string_clone(_SLIT("/LD")) }));
	} else if (!string_ends_with(v->pref->out_name, _SLIT(".exe"))) {
		v->pref->out_name = /*f*/string__plus(v->pref->out_name, _SLIT(".exe"));
	}
	v->pref->out_name = os__real_path(v->pref->out_name);
	if (v->pref->build_mode == v__pref__BuildMode__build_module) {
		array_push((array*)&a, _MOV((string[]){ string_clone(_SLIT("/c")) }));
	} else if (v->pref->build_mode == v__pref__BuildMode__default_mode) {
	}
	if (v->pref->sanitize) {
		eprintln(_SLIT("Sanitize not supported on msvc."));
	}
	array_push((array*)&a, _MOV((string[]){ string_clone(string__plus(string__plus(_SLIT("\""), os__real_path(v->out_name_c)), _SLIT("\""))) }));
	Array_string real_libs = new_array_from_c_array(3, 3, sizeof(string), _MOV((string[3]){_SLIT("kernel32.lib"), _SLIT("user32.lib"), _SLIT("advapi32.lib")}));
	v__builder__MsvcStringFlags sflags = v__builder__msvc_string_flags(v__builder__Builder_get_os_cflags(v));
	_PUSH_MANY(&real_libs, (sflags.real_libs), _t12, Array_string);
	Array_string inc_paths = sflags.inc_paths;
	Array_string lib_paths = sflags.lib_paths;
	Array_string defines = sflags.defines;
	Array_string other_flags = sflags.other_flags;
	array_push((array*)&a, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("-I \""), 0xfe10, {.d_s = r.ucrt_include_path}}, {_SLIT("\""), 0, { .d_c = 0 }}}))) }));
	array_push((array*)&a, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("-I \""), 0xfe10, {.d_s = r.vs_include_path}}, {_SLIT("\""), 0, { .d_c = 0 }}}))) }));
	array_push((array*)&a, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("-I \""), 0xfe10, {.d_s = r.um_include_path}}, {_SLIT("\""), 0, { .d_c = 0 }}}))) }));
	array_push((array*)&a, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("-I \""), 0xfe10, {.d_s = r.shared_include_path}}, {_SLIT("\""), 0, { .d_c = 0 }}}))) }));
	_PUSH_MANY(&a, (defines), _t17, Array_string);
	_PUSH_MANY(&a, (inc_paths), _t18, Array_string);
	_PUSH_MANY(&a, (other_flags), _t19, Array_string);
	array_push((array*)&a, _MOV((string[]){ string_clone(Array_string_join(real_libs, _SLIT(" "))) }));
	array_push((array*)&a, _MOV((string[]){ string_clone(_SLIT("/link")) }));
	array_push((array*)&a, _MOV((string[]){ string_clone(_SLIT("/NOLOGO")) }));
	array_push((array*)&a, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("/OUT:\""), 0xfe10, {.d_s = v->pref->out_name}}, {_SLIT("\""), 0, { .d_c = 0 }}}))) }));
	array_push((array*)&a, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("/LIBPATH:\""), 0xfe10, {.d_s = r.ucrt_lib_path}}, {_SLIT("\""), 0, { .d_c = 0 }}}))) }));
	array_push((array*)&a, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("/LIBPATH:\""), 0xfe10, {.d_s = r.um_lib_path}}, {_SLIT("\""), 0, { .d_c = 0 }}}))) }));
	array_push((array*)&a, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("/LIBPATH:\""), 0xfe10, {.d_s = r.vs_lib_path}}, {_SLIT("\""), 0, { .d_c = 0 }}}))) }));
	array_push((array*)&a, _MOV((string[]){ string_clone(_SLIT("/DEBUG:FULL")) }));
	if (v->pref->is_prod) {
		array_push((array*)&a, _MOV((string[]){ string_clone(_SLIT("/INCREMENTAL:NO")) }));
		array_push((array*)&a, _MOV((string[]){ string_clone(_SLIT("/OPT:REF")) }));
		array_push((array*)&a, _MOV((string[]){ string_clone(_SLIT("/OPT:ICF")) }));
	}
	_PUSH_MANY(&a, (lib_paths), _t31, Array_string);
	if ((env_ldflags).len != 0) {
		array_push((array*)&a, _MOV((string[]){ string_clone(env_ldflags) }));
	}
	string args = Array_string_join(a, _SLIT(" "));
	Option_void _t33 = os__write_file(out_name_cmd_line, args);
	if (_t33.state != 0 && _t33.err._typ != _IError_None___index) {
		IError err = _t33.err;
		v__builder__verror( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Unable to write response file to \""), 0xfe10, {.d_s = out_name_cmd_line}}, {_SLIT("\""), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	;
	}
	
 ;
	string cmd =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\""), 0xfe10, {.d_s = r.full_cl_exe_path}}, {_SLIT("\" \"@"), 0xfe10, {.d_s = out_name_cmd_line}}, {_SLIT("\""), 0, { .d_c = 0 }}}));
	v__builder__Builder_show_cc(v, cmd, out_name_cmd_line, args);
	if (!string__eq(os__user_os(), _SLIT("windows")) && !string_ends_with(v->pref->out_name, _SLIT(".c"))) {
		v__builder__verror( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Cannot build with msvc on "), 0xfe10, {.d_s = os__user_os()}}, {_SLIT0, 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	v__util__timing_start(_SLIT("C msvc"));
	os__Result res = os__execute(cmd);
	if (res.exit_code != 0) {
		eprintln(res.output);
		v__builder__verror(_SLIT("msvc error"));
		VUNREACHABLE();
	}
	v__util__timing_measure(_SLIT("C msvc"));
	if (v->pref->show_c_output) {
		v__builder__Builder_show_c_compiler_output(v, res);
	} else {
		v__builder__Builder_post_process_c_compiler_output(v, res);
	}
	Option_void _t34 = os__rm(out_name_obj);
	if (_t34.state != 0 && _t34.err._typ != _IError_None___index) {
		IError err = _t34.err;
	}
	
 ;
}

VV_LOCAL_SYMBOL void v__builder__Builder_build_thirdparty_obj_file_with_msvc(v__builder__Builder* v, string path, Array_v__cflag__CFlag moduleflags) {
	v__builder__MsvcResult msvc = v->cached_msvc;
	if (msvc.valid == false) {
		v__builder__verror(_SLIT("Cannot find MSVC on this OS"));
		VUNREACHABLE();
	}
	string obj_path =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = path}}, {_SLIT("bj"), 0, { .d_c = 0 }}}));
	obj_path = os__real_path(obj_path);
	if (os__exists(obj_path)) {
		return;
	}
	println( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = obj_path}}, {_SLIT(" not found, building it (with msvc)..."), 0, { .d_c = 0 }}})));
	string cfiles =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = string_substr(path, 0, path.len - 2)}}, {_SLIT(".c"), 0, { .d_c = 0 }}}));
	v__builder__MsvcStringFlags flags = v__builder__msvc_string_flags(moduleflags);
	string inc_dirs = Array_string_join(flags.inc_paths, _SLIT(" "));
	string defines = Array_string_join(flags.defines, _SLIT(" "));
	string include_string =  str_intp(6, _MOV((StrIntpData[]){{_SLIT("-I \""), 0xfe10, {.d_s = msvc.ucrt_include_path}}, {_SLIT("\" -I \""), 0xfe10, {.d_s = msvc.vs_include_path}}, {_SLIT("\" -I \""), 0xfe10, {.d_s = msvc.um_include_path}}, {_SLIT("\" -I \""), 0xfe10, {.d_s = msvc.shared_include_path}}, {_SLIT("\" "), 0xfe10, {.d_s = inc_dirs}}, {_SLIT0, 0, { .d_c = 0 }}}));
	string env_cflags = os__getenv(_SLIT("CFLAGS"));
	string env_ldflags = os__getenv(_SLIT("LDFLAGS"));
	Array_string oargs = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){string_clone(v->pref->cflags)}));
	if ((env_cflags).len != 0) {
		array_push((array*)&oargs, _MOV((string[]){ string_clone(env_cflags) }));
	}
	if (v->pref->is_prod) {
		array_push((array*)&oargs, _MOV((string[]){ string_clone(_SLIT("/O2")) }));
		array_push((array*)&oargs, _MOV((string[]){ string_clone(_SLIT("/MD")) }));
		array_push((array*)&oargs, _MOV((string[]){ string_clone(_SLIT("/DNDEBUG")) }));
	} else {
		array_push((array*)&oargs, _MOV((string[]){ string_clone(_SLIT("/MDd")) }));
		array_push((array*)&oargs, _MOV((string[]){ string_clone(_SLIT("/D_DEBUG")) }));
	}
	if ((env_ldflags).len != 0) {
		array_push((array*)&oargs, _MOV((string[]){ string_clone(env_ldflags) }));
	}
	string str_oargs = Array_string_join(oargs, _SLIT(" "));
	string cmd =  str_intp(7, _MOV((StrIntpData[]){{_SLIT("\""), 0xfe10, {.d_s = msvc.full_cl_exe_path}}, {_SLIT("\" /volatile:ms "), 0xfe10, {.d_s = str_oargs}}, {_SLIT(" "), 0xfe10, {.d_s = defines}}, {_SLIT(" "), 0xfe10, {.d_s = include_string}}, {_SLIT(" /c "), 0xfe10, {.d_s = cfiles}}, {_SLIT(" /Fo\""), 0xfe10, {.d_s = obj_path}}, {_SLIT("\""), 0, { .d_c = 0 }}}));
	os__Result res = os__execute(cmd);
	if (res.exit_code != 0) {
		println( str_intp(2, _MOV((StrIntpData[]){{_SLIT("msvc: failed to build a thirdparty object; cmd: "), 0xfe10, {.d_s = cmd}}, {_SLIT0, 0, { .d_c = 0 }}})));
		v__builder__verror(res.output);
		VUNREACHABLE();
	}
	println(res.output);
}

v__builder__MsvcStringFlags v__builder__msvc_string_flags(Array_v__cflag__CFlag cflags) {
	Array_string real_libs = __new_array_with_default(0, 0, sizeof(string), 0);
	Array_string inc_paths = __new_array_with_default(0, 0, sizeof(string), 0);
	Array_string lib_paths = __new_array_with_default(0, 0, sizeof(string), 0);
	Array_string defines = __new_array_with_default(0, 0, sizeof(string), 0);
	Array_string other_flags = __new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t1 = 0; _t1 < cflags.len; ++_t1) {
		v__cflag__CFlag flag = ((v__cflag__CFlag*)cflags.data)[_t1];
		if (string__eq(flag.name, _SLIT("-l"))) {
			if (string_ends_with(flag.value, _SLIT(".dll"))) {
				v__builder__verror( str_intp(2, _MOV((StrIntpData[]){{_SLIT("MSVC cannot link against a dll (`#flag -l "), 0xfe10, {.d_s = flag.value}}, {_SLIT("`)"), 0, { .d_c = 0 }}})));
				VUNREACHABLE();
			}
			string lib_lib = string__plus(flag.value, _SLIT(".lib"));
			array_push((array*)&real_libs, _MOV((string[]){ string_clone(lib_lib) }));
		} else if (string__eq(flag.name, _SLIT("-I"))) {
			array_push((array*)&inc_paths, _MOV((string[]){ string_clone(v__cflag__CFlag_format(&flag)) }));
		} else if (string__eq(flag.name, _SLIT("-D"))) {
			array_push((array*)&defines, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("/D"), 0xfe10, {.d_s = flag.value}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
		} else if (string__eq(flag.name, _SLIT("-L"))) {
			array_push((array*)&lib_paths, _MOV((string[]){ string_clone(flag.value) }));
			array_push((array*)&lib_paths, _MOV((string[]){ string_clone(string__plus(string__plus(flag.value, _const_os__path_separator), _SLIT("msvc"))) }));
		} else if (string_ends_with(flag.value, _SLIT(".o"))) {
			array_push((array*)&other_flags, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("\""), 0xfe10, {.d_s = flag.value}}, {_SLIT("bj\""), 0, { .d_c = 0 }}}))) }));
		} else if (string_starts_with(flag.value, _SLIT("-D"))) {
			array_push((array*)&defines, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("/D"), 0xfe10, {.d_s = string_substr(flag.value, 2, flag.value.len)}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
		} else {
			array_push((array*)&other_flags, _MOV((string[]){ string_clone(flag.value) }));
		}
	}
	Array_string lpaths = __new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t10 = 0; _t10 < lib_paths.len; ++_t10) {
		string l = ((string*)lib_paths.data)[_t10];
		array_push((array*)&lpaths, _MOV((string[]){ string_clone(string__plus(string__plus(_SLIT("/LIBPATH:\""), os__real_path(l)), _SLIT("\""))) }));
	}
	v__builder__MsvcStringFlags _t12 = (v__builder__MsvcStringFlags){.real_libs = real_libs,.inc_paths = inc_paths,.lib_paths = lpaths,.defines = defines,.other_flags = other_flags,};
	return _t12;
}

void v__builder__Builder_rebuild_modules(v__builder__Builder* b) {
	if (!b->pref->use_cache || b->pref->build_mode == v__pref__BuildMode__build_module) {
		return;
	}
	v__util__timing_start( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = _SLIT("Builder.rebuild_modules")}}, {_SLIT(" source_hashing"), 0, { .d_c = 0 }}})));
	Map_string_string new_hashes = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
	Map_string_string old_hashes = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
	strings__Builder sb_new_hashes = strings__new_builder(1024);
	Array_string _t1 = __new_array(0, 0, sizeof(string));
	Array_v__ast__File_ptr _t1_orig = b->parsed_files;
	int _t1_len = _t1_orig.len;
	_t1 = __new_array(0, _t1_len, sizeof(string));

	for (int _t2 = 0; _t2 < _t1_len; ++_t2) {
		v__ast__File* it = ((v__ast__File**) _t1_orig.data)[_t2];
		string ti = it->path;
		array_push((array*)&_t1, &ti);
	}
	Array_string all_files =_t1;
	v__vcache__CacheManager cm = v__vcache__new_cache_manager(all_files);
	Option_string _t3 = v__vcache__CacheManager_load(&cm, _SLIT(".hashes"), _SLIT("all_files"));
	if (_t3.state != 0) { /*or block*/ 
		IError err = _t3.err;
		*(string*) _t3.data = _SLIT(" ");
	}
	
 	string sold_hashes =  (*(string*)_t3.data);
	Array_string sold_hashes_lines = string_split(sold_hashes, _SLIT("\n"));
	for (int _t4 = 0; _t4 < sold_hashes_lines.len; ++_t4) {
		string line = ((string*)sold_hashes_lines.data)[_t4];
		if (line.len == 0) {
			continue;
		}
		Array_string x = string_split(line, _SLIT(" "));
		string chash = (*(string*)/*ee elem_typ */array_get(x, 0));
		string cpath = (*(string*)/*ee elem_typ */array_get(x, 1));
		map_set(&old_hashes, &(string[]){cpath}, &(string[]) { chash });
	}
	for (int _t5 = 0; _t5 < b->parsed_files.len; ++_t5) {
		v__ast__File* p = ((v__ast__File**)b->parsed_files.data)[_t5];
		string cpath = p->path;
		Option_string _t6 = v__util__read_file(cpath);
		if (_t6.state != 0) { /*or block*/ 
			IError err = _t6.err;
			*(string*) _t6.data = _SLIT("");
		}
		
 		string ccontent =  (*(string*)_t6.data);
		string chash = u64_hex_full(hash__sum64_string(ccontent, 7U));
		map_set(&new_hashes, &(string[]){cpath}, &(string[]) { chash });
		strings__Builder_write_string(&sb_new_hashes, chash);
		strings__Builder_write_b(&sb_new_hashes, ' ');
		strings__Builder_write_string(&sb_new_hashes, cpath);
		strings__Builder_write_b(&sb_new_hashes, '\n');
	}
	string snew_hashes = strings__Builder_str(&sb_new_hashes);
	Option_string _t7 = v__vcache__CacheManager_save(&cm, _SLIT(".hashes"), _SLIT("all_files"), snew_hashes);
	if (_t7.state != 0) { /*or block*/ 
		IError err = _t7.err;
	}
	
  (*(string*)_t7.data);
	v__util__timing_measure( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = _SLIT("Builder.rebuild_modules")}}, {_SLIT(" source_hashing"), 0, { .d_c = 0 }}})));
	if (!Map_string_string_map_eq(new_hashes, old_hashes)) {
		v__util__timing_start( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = _SLIT("Builder.rebuild_modules")}}, {_SLIT(" rebuilding"), 0, { .d_c = 0 }}})));
		Map_string_int invalidated_paths = new_map(sizeof(string), sizeof(int), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
		Map_string_int invalidated_mod_paths = new_map(sizeof(string), sizeof(int), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
		int _t9 = new_hashes.key_values.len;
		for (int _t8 = 0; _t8 < _t9; ++_t8 ) {
			int _t10 = new_hashes.key_values.len - _t9;
			_t9 = new_hashes.key_values.len;
			if (_t10 < 0) {
				_t8 = -1;
				continue;
			}
			if (!DenseArray_has_index(&new_hashes.key_values, _t8)) {continue;}
			string npath = /*key*/ *(string*)DenseArray_key(&new_hashes.key_values, _t8);
			npath = string_clone(npath);
			string nhash = (*(string*)DenseArray_value(&new_hashes.key_values, _t8));
			if (!_IN_MAP(ADDR(string, npath), ADDR(map, old_hashes))) {
				(*(int*)map_get_and_set((map*)&invalidated_paths, &(string[]){npath}, &(int[]){ 0 }))++;
				continue;
			}
			if (!string__eq((*(string*)map_get(ADDR(map, old_hashes), &(string[]){npath}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })), nhash)) {
				(*(int*)map_get_and_set((map*)&invalidated_paths, &(string[]){npath}, &(int[]){ 0 }))++;
				continue;
			}
		}
		int _t12 = old_hashes.key_values.len;
		for (int _t11 = 0; _t11 < _t12; ++_t11 ) {
			int _t13 = old_hashes.key_values.len - _t12;
			_t12 = old_hashes.key_values.len;
			if (_t13 < 0) {
				_t11 = -1;
				continue;
			}
			if (!DenseArray_has_index(&old_hashes.key_values, _t11)) {continue;}
			string opath = /*key*/ *(string*)DenseArray_key(&old_hashes.key_values, _t11);
			opath = string_clone(opath);
			string ohash = (*(string*)DenseArray_value(&old_hashes.key_values, _t11));
			if (!_IN_MAP(ADDR(string, opath), ADDR(map, new_hashes))) {
				(*(int*)map_get_and_set((map*)&invalidated_paths, &(string[]){opath}, &(int[]){ 0 }))++;
				continue;
			}
			if (!string__eq((*(string*)map_get(ADDR(map, new_hashes), &(string[]){opath}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })), ohash)) {
				(*(int*)map_get_and_set((map*)&invalidated_paths, &(string[]){opath}, &(int[]){ 0 }))++;
				continue;
			}
		}
		bool rebuild_everything = false;
		for (int cycle = 0; true; cycle++) {
			Map_string_int new_invalidated_paths = new_map(sizeof(string), sizeof(int), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
			int _t15 = invalidated_paths.key_values.len;
			for (int _t14 = 0; _t14 < _t15; ++_t14 ) {
				int _t16 = invalidated_paths.key_values.len - _t15;
				_t15 = invalidated_paths.key_values.len;
				if (_t16 < 0) {
					_t14 = -1;
					continue;
				}
				if (!DenseArray_has_index(&invalidated_paths.key_values, _t14)) {continue;}
				string npath = /*key*/ *(string*)DenseArray_key(&invalidated_paths.key_values, _t14);
				npath = string_clone(npath);
				Array_string invalidated_mods = (*(Array_string*)map_get(ADDR(map, b->path_invalidates_mods), &(string[]){npath}, &(Array_string[]){ __new_array(0, 0, sizeof(string)) }));
				if (Array_string_arr_eq(invalidated_mods, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("main")})))) {
					continue;
				}
				if (Array_string_contains(invalidated_mods, _SLIT("builtin"))) {
					rebuild_everything = true;
					break;
				}
				for (int _t17 = 0; _t17 < invalidated_mods.len; ++_t17) {
					string imod = ((string*)invalidated_mods.data)[_t17];
					if (string__eq(imod, _SLIT("main"))) {
						continue;
					}
					Array_string _t18 = (*(Array_string*)map_get(ADDR(map, b->mod_invalidates_paths), &(string[]){imod}, &(Array_string[]){ __new_array(0, 0, sizeof(string)) }));
					for (int _t19 = 0; _t19 < _t18.len; ++_t19) {
						string np = ((string*)_t18.data)[_t19];
						(*(int*)map_get_and_set((map*)&new_invalidated_paths, &(string[]){np}, &(int[]){ 0 }))++;
					}
				}
				string mpath = os__dir(npath);
				(*(int*)map_get_and_set((map*)&invalidated_mod_paths, &(string[]){mpath}, &(int[]){ 0 }))++;
			}
			if (rebuild_everything) {
				break;
			}
			if (new_invalidated_paths.len == 0) {
				break;
			}
			invalidated_paths = map_clone(&new_invalidated_paths);
		}
		if (rebuild_everything) {
			invalidated_mod_paths = new_map(sizeof(string), sizeof(int), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
			int _t21 = new_hashes.key_values.len;
			for (int _t20 = 0; _t20 < _t21; ++_t20 ) {
				int _t22 = new_hashes.key_values.len - _t21;
				_t21 = new_hashes.key_values.len;
				if (_t22 < 0) {
					_t20 = -1;
					continue;
				}
				if (!DenseArray_has_index(&new_hashes.key_values, _t20)) {continue;}
				string npath = /*key*/ *(string*)DenseArray_key(&new_hashes.key_values, _t20);
				npath = string_clone(npath);
				string mpath = os__dir(npath);
				Array_string pimods = (*(Array_string*)map_get(ADDR(map, b->path_invalidates_mods), &(string[]){npath}, &(Array_string[]){ __new_array(0, 0, sizeof(string)) }));
				if (Array_string_arr_eq(pimods, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("main")})))) {
					continue;
				}
				(*(int*)map_get_and_set((map*)&invalidated_mod_paths, &(string[]){mpath}, &(int[]){ 0 }))++;
			}
		}
		if (invalidated_mod_paths.len > 0) {
			Array_string impaths = map_keys(&invalidated_mod_paths);
			string vexe = v__pref__vexe_path();
			for (int _t23 = 0; _t23 < impaths.len; ++_t23) {
				string imp = ((string*)impaths.data)[_t23];
				v__builder__Builder_v_build_module(b, vexe, imp);
			}
		}
		v__util__timing_measure( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = _SLIT("Builder.rebuild_modules")}}, {_SLIT(" rebuilding"), 0, { .d_c = 0 }}})));
	}
}

VV_LOCAL_SYMBOL void v__builder__Builder_v_build_module(v__builder__Builder* b, string vexe, string imp_path) {
bool v__builder__Builder_v_build_module_defer_0 = false;
string pwd;
	pwd = os__getwd();
	v__builder__Builder_v_build_module_defer_0 = true;
	string vroot = os__dir(vexe);
	Option_void _t1 = os__chdir(vroot);
	if (_t1.state != 0 && _t1.err._typ != _IError_None___index) {
		IError err = _t1.err;
	}
	
 ;
	string boptions = Array_string_join(b->pref->build_options, _SLIT(" "));
	string rebuild_cmd =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = vexe}}, {_SLIT(" "), 0xfe10, {.d_s = boptions}}, {_SLIT(" build-module "), 0xfe10, {.d_s = imp_path}}, {_SLIT0, 0, { .d_c = 0 }}}));
	;
	os__system(rebuild_cmd);
// Defer begin
if (v__builder__Builder_v_build_module_defer_0) {
	Option_void _t2 = os__chdir(pwd);
	if (_t2.state != 0 && _t2.err._typ != _IError_None___index) {
		IError err = _t2.err;
	}
	
 ;
}
// Defer end
}

VV_LOCAL_SYMBOL string v__builder__Builder_rebuild_cached_module(v__builder__Builder* b, string vexe, string imp_path) {
	Option_string _t1 = v__vcache__CacheManager_exists(&b->pref->cache_manager, _SLIT(".o"), imp_path);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		if (b->pref->is_verbose) {
			println( str_intp(3, _MOV((StrIntpData[]){{_SLIT("Cached "), 0xfe10, {.d_s = imp_path}}, {_SLIT(" .o file not found... Building .o file for "), 0xfe10, {.d_s = imp_path}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		v__builder__Builder_v_build_module(b, vexe, imp_path);
		Option_string _t2 = v__vcache__CacheManager_exists(&b->pref->cache_manager, _SLIT(".o"), imp_path);
		if (_t2.state != 0) { /*or block*/ 
			err = _t2.err;
			_v_panic( str_intp(3, _MOV((StrIntpData[]){{_SLIT("could not rebuild cache module for "), 0xfe10, {.d_s = imp_path}}, {_SLIT(", error: "), 0xfe10, {.d_s = (*(err.msg))}}, {_SLIT0, 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		;
		}
		
 		string rebuilded_o =  (*(string*)_t2.data);
		string _t3 = rebuilded_o;
		return _t3;
	}
	
 	string res =  (*(string*)_t1.data);
	string _t4 = res;
	return _t4;
}

VV_LOCAL_SYMBOL void v__builder__Builder_handle_usecache(v__builder__Builder* b, string vexe) {
	if (!b->pref->use_cache || b->pref->build_mode == v__pref__BuildMode__build_module) {
		return;
	}
	Array_string libs = __new_array_with_default(0, 0, sizeof(string), 0);
	Array_string built_modules = __new_array_with_default(0, 0, sizeof(string), 0);
	string builtin_obj_path = v__builder__Builder_rebuild_cached_module(b, vexe, _SLIT("vlib/builtin"));
	array_push((array*)&libs, _MOV((string[]){ string_clone(builtin_obj_path) }));
	for (int _t2 = 0; _t2 < b->parsed_files.len; ++_t2) {
		v__ast__File* ast_file = ((v__ast__File**)b->parsed_files.data)[_t2];
		if (b->pref->is_test && !string__eq(ast_file->mod.name, _SLIT("main"))) {
			Option_string _t3 = v__builder__Builder_find_module_path(b, ast_file->mod.name, ast_file->path);
			if (_t3.state != 0) { /*or block*/ 
				IError err = _t3.err;
				v__builder__verror( str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot import module \""), 0xfe10, {.d_s = ast_file->mod.name}}, {_SLIT("\" (not found)"), 0, { .d_c = 0 }}})));
				VUNREACHABLE();
				break;
			}
			
 			string imp_path =  (*(string*)_t3.data);
			string obj_path = v__builder__Builder_rebuild_cached_module(b, vexe, imp_path);
			array_push((array*)&libs, _MOV((string[]){ string_clone(obj_path) }));
			array_push((array*)&built_modules, _MOV((string[]){ string_clone(ast_file->mod.name) }));
		}
		for (int _t6 = 0; _t6 < ast_file->imports.len; ++_t6) {
			v__ast__Import imp_stmt = ((v__ast__Import*)ast_file->imports.data)[_t6];
			string imp = imp_stmt.mod;
			if (string__eq(imp, _SLIT("strconv")) || string__eq(imp, _SLIT("strings"))) {
				continue;
			}
			if (Array_string_contains(built_modules, imp)) {
				continue;
			}
			if (v__util__should_bundle_module(imp)) {
				continue;
			}
			if (string__eq(imp, _SLIT("help"))) {
				continue;
			}
			Option_string _t7 = v__builder__Builder_find_module_path(b, imp, ast_file->path);
			if (_t7.state != 0) { /*or block*/ 
				IError err = _t7.err;
				v__builder__verror( str_intp(2, _MOV((StrIntpData[]){{_SLIT("cannot import module \""), 0xfe10, {.d_s = imp}}, {_SLIT("\" (not found)"), 0, { .d_c = 0 }}})));
				VUNREACHABLE();
				break;
			}
			
 			string imp_path =  (*(string*)_t7.data);
			string obj_path = v__builder__Builder_rebuild_cached_module(b, vexe, imp_path);
			array_push((array*)&libs, _MOV((string[]){ string_clone(obj_path) }));
			array_push((array*)&built_modules, _MOV((string[]){ string_clone(imp) }));
		}
	}
	_PUSH_MANY(&b->ccoptions.post_args, (libs), _t10, Array_string);
}

void v__builder__cbuilder__start(void) {
	Array_string args_and_flags = array_slice(v__util__join_env_vflags_and_os_args(), 1, v__util__join_env_vflags_and_os_args().len);
	multi_return_ref_v__pref__Preferences_string mr_178 = v__pref__parse_args(__new_array_with_default(0, 0, sizeof(string), 0), args_and_flags);
	v__pref__Preferences* prefs = mr_178.arg0;
	v__builder__compile(_SLIT("build"), prefs, (voidptr)v__builder__cbuilder__compile_c);
}

void v__builder__cbuilder__compile_c(v__builder__Builder* b) {
	if (b->pref->is_verbose) {
		println(_SLIT("all .v files before:"));
	}
	Option_void _t1 = v__builder__Builder_find_win_cc(b);
	if (_t1.state != 0 && _t1.err._typ != _IError_None___index) {
		IError err = _t1.err;
		v__builder__verror(_const_v__builder__no_compiler_error);
		VUNREACHABLE();
	;
	}
	
 ;
	Array_string files = v__builder__Builder_get_builtin_files(b);
	_PUSH_MANY(&files, (v__builder__Builder_get_user_files(b)), _t2, Array_string);
	v__builder__Builder_set_module_lookup_paths(b);
	if (b->pref->is_verbose) {
		println(_SLIT("all .v files:"));
		println(Array_string_str(files));
	}
	string out_name_c = v__builder__Builder_get_vtmp_filename(b, b->pref->out_name, _SLIT(".tmp.c"));
	if (b->pref->is_shared) {
		out_name_c = v__builder__Builder_get_vtmp_filename(b, b->pref->out_name, _SLIT(".tmp.so.c"));
	}
	v__builder__cbuilder__build_c(b, files, out_name_c);
	v__builder__Builder_cc(b);
}

string v__builder__cbuilder__gen_c(v__builder__Builder* b, Array_string v_files) {
	Option_void _t1 = v__builder__Builder_front_and_middle_stages(b, v_files);
	if (_t1.state != 0 && _t1.err._typ != _IError_None___index) {
		IError err = _t1.err;
		if ((*(err.code)) != 9999) {
			v__builder__verror((*(err.msg)));
			VUNREACHABLE();
		}
		string _t2 = _SLIT("");
		return _t2;
	}
	
 ;
	v__util__timing_start(_SLIT("C GEN"));
	string res = v__gen__c__gen(b->parsed_files, b->table, b->pref);
	v__util__timing_measure(_SLIT("C GEN"));
	string _t3 = res;
	return _t3;
}

void v__builder__cbuilder__build_c(v__builder__Builder* b, Array_string v_files, string out_file) {
	b->out_name_c = out_file;
	b->pref->out_name_c = os__real_path(out_file);
	v__builder__Builder_info(b,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("build_c("), 0xfe10, {.d_s = out_file}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
	string output2 = v__builder__cbuilder__gen_c(b, v_files);
	Option_void _t1 = os__write_file(out_file, output2);
	if (_t1.state != 0 && _t1.err._typ != _IError_None___index) {
		IError err = _t1.err;
		_v_panic(IError_str(err));
		VUNREACHABLE();
	;
	}
	
 ;
	if (b->pref->is_stats) {
		b->stats_lines = string_count(output2, _SLIT("\n")) + 1;
		b->stats_bytes = output2.len;
	}
}

VV_LOCAL_SYMBOL void main__main(void) {
bool main__main_defer_0 = false;
v__util__Timers* timers;
	bool timers_should_print = false;
	timers = v__util__new_timers((v__util__TimerParams){.should_print = timers_should_print,.label = _SLIT("main"),});
	v__util__Timers_start(timers, _SLIT("v total"));
	main__main_defer_0 = true;
	v__util__Timers_start(timers, _SLIT("v start"));
	v__util__Timers_show(timers, _SLIT("v start"));
	v__util__Timers_start(timers, _SLIT("parse_CLI_args"));
	Array_string args = array_slice(_const_os__args, 1, _const_os__args.len);
	if (args.len == 0 || (string__eq((*(string*)/*ee elem_typ */array_get(args, 0)), _SLIT("-")) || string__eq((*(string*)/*ee elem_typ */array_get(args, 0)), _SLIT("repl")))) {
		if (args.len == 0) {
			if (os__is_atty(0) != 0) {
				string cmd_exit = term__highlight_command(_SLIT("exit"));
				string cmd_help = term__highlight_command(_SLIT("v help"));
				string file_main = term__highlight_command(_SLIT("main.v"));
				string cmd_run = term__highlight_command(_SLIT("v run main.v"));
				println( str_intp(3, _MOV((StrIntpData[]){{_SLIT("Welcome to the V REPL (for help with V itself, type "), 0xfe10, {.d_s = cmd_exit}}, {_SLIT(", then run "), 0xfe10, {.d_s = cmd_help}}, {_SLIT(")."), 0, { .d_c = 0 }}})));
				eprintln(_SLIT("  NB: the REPL is highly experimental. For best V experience, use a text editor,"));
				eprintln( str_intp(3, _MOV((StrIntpData[]){{_SLIT("  save your code in a "), 0xfe10, {.d_s = file_main}}, {_SLIT(" file and execute: "), 0xfe10, {.d_s = cmd_run}}, {_SLIT0, 0, { .d_c = 0 }}})));
			} else {
				Array_string args_and_flags = array_clone_static_to_depth(array_slice(v__util__join_env_vflags_and_os_args(), 1, v__util__join_env_vflags_and_os_args().len), 0);
				_PUSH_MANY(&args_and_flags, (new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT("run"), _SLIT("-")}))), _t1, Array_string);
				v__pref__parse_args_and_show_errors(_const_main__external_tools, args_and_flags, true);
			}
		}
		v__util__launch_tool(false, _SLIT("vrepl"), array_slice(_const_os__args, 1, _const_os__args.len));
		VUNREACHABLE();
		// Defer begin
		if (main__main_defer_0) {
			v__util__Timers_show(timers, _SLIT("v total"));
		}
		// Defer end
		return;
	}
	Array_string args_and_flags = array_slice(v__util__join_env_vflags_and_os_args(), 1, v__util__join_env_vflags_and_os_args().len);
	multi_return_ref_v__pref__Preferences_string mr_2214 = v__pref__parse_args_and_show_errors(_const_main__external_tools, args_and_flags, true);
	v__pref__Preferences* prefs = mr_2214.arg0;
	string command = mr_2214.arg1;
	if (prefs->use_cache && string__eq(os__user_os(), _SLIT("windows"))) {
		eprintln(_SLIT("-usecache is currently disabled on windows"));
		_v_exit(1);
		VUNREACHABLE();
	}
	v__util__Timers_show(timers, _SLIT("parse_CLI_args"));
	if (Array_string_contains(_const_main__external_tools, command)) {
		v__util__launch_tool(prefs->is_verbose, string__plus(_SLIT("v"), command), array_slice(_const_os__args, 1, _const_os__args.len));
		VUNREACHABLE();
		// Defer begin
		if (main__main_defer_0) {
			v__util__Timers_show(timers, _SLIT("v total"));
		}
		// Defer end
		return;
	}

	if (string__eq(command, _SLIT("help"))) {
		main__invoke_help_and_exit(args);
	}
	else if (string__eq(command, _SLIT("new")) || string__eq(command, _SLIT("init"))) {
		v__util__launch_tool(prefs->is_verbose, _SLIT("vcreate"), array_slice(_const_os__args, 1, _const_os__args.len));
		VUNREACHABLE();
		// Defer begin
		if (main__main_defer_0) {
			v__util__Timers_show(timers, _SLIT("v total"));
		}
		// Defer end
		return;
	}
	else if (string__eq(command, _SLIT("translate"))) {
		eprintln(_SLIT("Translating C to V will be available in V 0.3"));
		_v_exit(1);
		VUNREACHABLE();
	}
	else if (string__eq(command, _SLIT("install")) || string__eq(command, _SLIT("list")) || string__eq(command, _SLIT("outdated")) || string__eq(command, _SLIT("remove")) || string__eq(command, _SLIT("search")) || string__eq(command, _SLIT("show")) || string__eq(command, _SLIT("update")) || string__eq(command, _SLIT("upgrade"))) {
		v__util__launch_tool(prefs->is_verbose, _SLIT("vpm"), array_slice(_const_os__args, 1, _const_os__args.len));
		VUNREACHABLE();
		// Defer begin
		if (main__main_defer_0) {
			v__util__Timers_show(timers, _SLIT("v total"));
		}
		// Defer end
		return;
	}
	else if (string__eq(command, _SLIT("vlib-docs"))) {
		v__util__launch_tool(prefs->is_verbose, _SLIT("vdoc"), new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT("doc"), _SLIT("vlib")})));
		VUNREACHABLE();
	}
	else if (string__eq(command, _SLIT("interpret"))) {
		v__util__launch_tool(prefs->is_verbose, _SLIT("builders/interpret_builder"), array_slice(_const_os__args, 1, _const_os__args.len));
		VUNREACHABLE();
	}
	else if (string__eq(command, _SLIT("get"))) {
		eprintln(_SLIT("V Error: Use `v install` to install modules from vpm.vlang.io"));
		_v_exit(1);
		VUNREACHABLE();
	}
	else if (string__eq(command, _SLIT("version"))) {
		println(v__util__version__full_v_version(prefs->is_verbose));
		// Defer begin
		if (main__main_defer_0) {
			v__util__Timers_show(timers, _SLIT("v total"));
		}
		// Defer end
		return;
	}
	else {
	};
	if ((string__eq(command, _SLIT("run")) || string__eq(command, _SLIT("build")) || string__eq(command, _SLIT("build-module"))) || string_ends_with(command, _SLIT(".v")) || os__exists(command)) {

		if (prefs->backend == (v__pref__Backend__c)) {
			v__builder__compile(_SLIT("build"), prefs, (voidptr)v__builder__cbuilder__compile_c);
		}
		else if (prefs->backend == (v__pref__Backend__js_node) || prefs->backend == (v__pref__Backend__js_freestanding) || prefs->backend == (v__pref__Backend__js_browser)) {
			v__util__launch_tool(prefs->is_verbose, _SLIT("builders/js_builder"), array_slice(_const_os__args, 1, _const_os__args.len));
			VUNREACHABLE();
		}
		else if (prefs->backend == (v__pref__Backend__native)) {
			v__util__launch_tool(prefs->is_verbose, _SLIT("builders/native_builder"), array_slice(_const_os__args, 1, _const_os__args.len));
			VUNREACHABLE();
		}
		else if (prefs->backend == (v__pref__Backend__interpret)) {
			v__util__launch_tool(prefs->is_verbose, _SLIT("builders/interpret_builder"), array_slice(_const_os__args, 1, _const_os__args.len));
			VUNREACHABLE();
		};
		// Defer begin
		if (main__main_defer_0) {
			v__util__Timers_show(timers, _SLIT("v total"));
		}
		// Defer end
		return;
	}
	if (prefs->is_help) {
		main__invoke_help_and_exit(args);
	}
	eprintln( str_intp(3, _MOV((StrIntpData[]){{_SLIT("v "), 0xfe10, {.d_s = command}}, {_SLIT(": unknown command\nRun "), 0xfe10, {.d_s = term__highlight_command(_SLIT("v help"))}}, {_SLIT(" for usage."), 0, { .d_c = 0 }}})));
	_v_exit(1);
	VUNREACHABLE();
}

VV_LOCAL_SYMBOL void main__invoke_help_and_exit(Array_string remaining) {

	if (remaining.len == (0) || remaining.len == (1)) {
		help__print_and_exit(_SLIT("default"));
	}
	else if (remaining.len == (2)) {
		help__print_and_exit((*(string*)/*ee elem_typ */array_get(remaining, 1)));
	}
	else {
	};
	println( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = term__highlight_command(_SLIT("v help"))}}, {_SLIT(": provide only one help topic."), 0, { .d_c = 0 }}})));
	println( str_intp(2, _MOV((StrIntpData[]){{_SLIT("For usage information, use "), 0xfe10, {.d_s = term__highlight_command(_SLIT("v help"))}}, {_SLIT("."), 0, { .d_c = 0 }}})));
	_v_exit(1);
	VUNREACHABLE();
}

void _vinit(int ___argc, voidptr ___argv) {
#if __STDC_HOSTED__ == 1
	signal(11, v_segmentation_fault_handler);
#endif
	as_cast_type_indexes = new_array_from_c_array(101, 101, sizeof(VCastTypeIndexName), _MOV((VCastTypeIndexName[101]){
		  (VCastTypeIndexName){.tindex = 0, .tname = _SLIT("unknown")}
		, (VCastTypeIndexName){.tindex = 278, .tname = _SLIT("v.ast.AnonFn")}
		, (VCastTypeIndexName){.tindex = 279, .tname = _SLIT("v.ast.ArrayDecompose")}
		, (VCastTypeIndexName){.tindex = 280, .tname = _SLIT("v.ast.ArrayInit")}
		, (VCastTypeIndexName){.tindex = 281, .tname = _SLIT("v.ast.AsCast")}
		, (VCastTypeIndexName){.tindex = 282, .tname = _SLIT("v.ast.Assoc")}
		, (VCastTypeIndexName){.tindex = 283, .tname = _SLIT("v.ast.AtExpr")}
		, (VCastTypeIndexName){.tindex = 284, .tname = _SLIT("v.ast.BoolLiteral")}
		, (VCastTypeIndexName){.tindex = 285, .tname = _SLIT("v.ast.CTempVar")}
		, (VCastTypeIndexName){.tindex = 286, .tname = _SLIT("v.ast.CallExpr")}
		, (VCastTypeIndexName){.tindex = 287, .tname = _SLIT("v.ast.CastExpr")}
		, (VCastTypeIndexName){.tindex = 288, .tname = _SLIT("v.ast.ChanInit")}
		, (VCastTypeIndexName){.tindex = 289, .tname = _SLIT("v.ast.CharLiteral")}
		, (VCastTypeIndexName){.tindex = 290, .tname = _SLIT("v.ast.Comment")}
		, (VCastTypeIndexName){.tindex = 291, .tname = _SLIT("v.ast.ComptimeCall")}
		, (VCastTypeIndexName){.tindex = 292, .tname = _SLIT("v.ast.ComptimeSelector")}
		, (VCastTypeIndexName){.tindex = 293, .tname = _SLIT("v.ast.ConcatExpr")}
		, (VCastTypeIndexName){.tindex = 294, .tname = _SLIT("v.ast.DumpExpr")}
		, (VCastTypeIndexName){.tindex = 295, .tname = _SLIT("v.ast.EmptyExpr")}
		, (VCastTypeIndexName){.tindex = 296, .tname = _SLIT("v.ast.EnumVal")}
		, (VCastTypeIndexName){.tindex = 297, .tname = _SLIT("v.ast.FloatLiteral")}
		, (VCastTypeIndexName){.tindex = 298, .tname = _SLIT("v.ast.GoExpr")}
		, (VCastTypeIndexName){.tindex = 299, .tname = _SLIT("v.ast.Ident")}
		, (VCastTypeIndexName){.tindex = 300, .tname = _SLIT("v.ast.IfExpr")}
		, (VCastTypeIndexName){.tindex = 301, .tname = _SLIT("v.ast.IfGuardExpr")}
		, (VCastTypeIndexName){.tindex = 302, .tname = _SLIT("v.ast.IndexExpr")}
		, (VCastTypeIndexName){.tindex = 303, .tname = _SLIT("v.ast.InfixExpr")}
		, (VCastTypeIndexName){.tindex = 304, .tname = _SLIT("v.ast.IntegerLiteral")}
		, (VCastTypeIndexName){.tindex = 305, .tname = _SLIT("v.ast.IsRefType")}
		, (VCastTypeIndexName){.tindex = 306, .tname = _SLIT("v.ast.Likely")}
		, (VCastTypeIndexName){.tindex = 307, .tname = _SLIT("v.ast.LockExpr")}
		, (VCastTypeIndexName){.tindex = 308, .tname = _SLIT("v.ast.MapInit")}
		, (VCastTypeIndexName){.tindex = 309, .tname = _SLIT("v.ast.MatchExpr")}
		, (VCastTypeIndexName){.tindex = 310, .tname = _SLIT("v.ast.NodeError")}
		, (VCastTypeIndexName){.tindex = 311, .tname = _SLIT("v.ast.None")}
		, (VCastTypeIndexName){.tindex = 312, .tname = _SLIT("v.ast.OffsetOf")}
		, (VCastTypeIndexName){.tindex = 313, .tname = _SLIT("v.ast.OrExpr")}
		, (VCastTypeIndexName){.tindex = 314, .tname = _SLIT("v.ast.ParExpr")}
		, (VCastTypeIndexName){.tindex = 315, .tname = _SLIT("v.ast.PostfixExpr")}
		, (VCastTypeIndexName){.tindex = 316, .tname = _SLIT("v.ast.PrefixExpr")}
		, (VCastTypeIndexName){.tindex = 317, .tname = _SLIT("v.ast.RangeExpr")}
		, (VCastTypeIndexName){.tindex = 318, .tname = _SLIT("v.ast.SelectExpr")}
		, (VCastTypeIndexName){.tindex = 319, .tname = _SLIT("v.ast.SelectorExpr")}
		, (VCastTypeIndexName){.tindex = 320, .tname = _SLIT("v.ast.SizeOf")}
		, (VCastTypeIndexName){.tindex = 321, .tname = _SLIT("v.ast.SqlExpr")}
		, (VCastTypeIndexName){.tindex = 322, .tname = _SLIT("v.ast.StringInterLiteral")}
		, (VCastTypeIndexName){.tindex = 323, .tname = _SLIT("v.ast.StringLiteral")}
		, (VCastTypeIndexName){.tindex = 324, .tname = _SLIT("v.ast.StructInit")}
		, (VCastTypeIndexName){.tindex = 325, .tname = _SLIT("v.ast.TypeNode")}
		, (VCastTypeIndexName){.tindex = 326, .tname = _SLIT("v.ast.TypeOf")}
		, (VCastTypeIndexName){.tindex = 327, .tname = _SLIT("v.ast.UnsafeExpr")}
		, (VCastTypeIndexName){.tindex = 458, .tname = _SLIT("v.ast.Aggregate")}
		, (VCastTypeIndexName){.tindex = 460, .tname = _SLIT("v.ast.Alias")}
		, (VCastTypeIndexName){.tindex = 441, .tname = _SLIT("v.ast.Array")}
		, (VCastTypeIndexName){.tindex = 468, .tname = _SLIT("v.ast.ArrayFixed")}
		, (VCastTypeIndexName){.tindex = 469, .tname = _SLIT("v.ast.Chan")}
		, (VCastTypeIndexName){.tindex = 474, .tname = _SLIT("v.ast.Enum")}
		, (VCastTypeIndexName){.tindex = 472, .tname = _SLIT("v.ast.FnType")}
		, (VCastTypeIndexName){.tindex = 473, .tname = _SLIT("v.ast.GenericInst")}
		, (VCastTypeIndexName){.tindex = 463, .tname = _SLIT("v.ast.Interface")}
		, (VCastTypeIndexName){.tindex = 442, .tname = _SLIT("v.ast.Map")}
		, (VCastTypeIndexName){.tindex = 471, .tname = _SLIT("v.ast.MultiReturn")}
		, (VCastTypeIndexName){.tindex = 446, .tname = _SLIT("v.ast.Struct")}
		, (VCastTypeIndexName){.tindex = 464, .tname = _SLIT("v.ast.SumType")}
		, (VCastTypeIndexName){.tindex = 470, .tname = _SLIT("v.ast.Thread")}
		, (VCastTypeIndexName){.tindex = 407, .tname = _SLIT("v.ast.IdentFn")}
		, (VCastTypeIndexName){.tindex = 408, .tname = _SLIT("v.ast.IdentVar")}
		, (VCastTypeIndexName){.tindex = 354, .tname = _SLIT("v.ast.AsmRegister")}
		, (VCastTypeIndexName){.tindex = 355, .tname = _SLIT("v.ast.ConstField")}
		, (VCastTypeIndexName){.tindex = 356, .tname = _SLIT("v.ast.GlobalField")}
		, (VCastTypeIndexName){.tindex = 357, .tname = _SLIT("v.ast.Var")}
		, (VCastTypeIndexName){.tindex = 329, .tname = _SLIT("v.ast.AsmStmt")}
		, (VCastTypeIndexName){.tindex = 330, .tname = _SLIT("v.ast.AssertStmt")}
		, (VCastTypeIndexName){.tindex = 331, .tname = _SLIT("v.ast.AssignStmt")}
		, (VCastTypeIndexName){.tindex = 332, .tname = _SLIT("v.ast.Block")}
		, (VCastTypeIndexName){.tindex = 333, .tname = _SLIT("v.ast.BranchStmt")}
		, (VCastTypeIndexName){.tindex = 334, .tname = _SLIT("v.ast.ComptimeFor")}
		, (VCastTypeIndexName){.tindex = 335, .tname = _SLIT("v.ast.ConstDecl")}
		, (VCastTypeIndexName){.tindex = 336, .tname = _SLIT("v.ast.DeferStmt")}
		, (VCastTypeIndexName){.tindex = 337, .tname = _SLIT("v.ast.EmptyStmt")}
		, (VCastTypeIndexName){.tindex = 338, .tname = _SLIT("v.ast.EnumDecl")}
		, (VCastTypeIndexName){.tindex = 339, .tname = _SLIT("v.ast.ExprStmt")}
		, (VCastTypeIndexName){.tindex = 216, .tname = _SLIT("v.ast.FnDecl")}
		, (VCastTypeIndexName){.tindex = 340, .tname = _SLIT("v.ast.ForCStmt")}
		, (VCastTypeIndexName){.tindex = 341, .tname = _SLIT("v.ast.ForInStmt")}
		, (VCastTypeIndexName){.tindex = 342, .tname = _SLIT("v.ast.ForStmt")}
		, (VCastTypeIndexName){.tindex = 343, .tname = _SLIT("v.ast.GlobalDecl")}
		, (VCastTypeIndexName){.tindex = 344, .tname = _SLIT("v.ast.GotoLabel")}
		, (VCastTypeIndexName){.tindex = 345, .tname = _SLIT("v.ast.GotoStmt")}
		, (VCastTypeIndexName){.tindex = 346, .tname = _SLIT("v.ast.HashStmt")}
		, (VCastTypeIndexName){.tindex = 347, .tname = _SLIT("v.ast.Import")}
		, (VCastTypeIndexName){.tindex = 348, .tname = _SLIT("v.ast.InterfaceDecl")}
		, (VCastTypeIndexName){.tindex = 349, .tname = _SLIT("v.ast.Module")}
		, (VCastTypeIndexName){.tindex = 350, .tname = _SLIT("v.ast.Return")}
		, (VCastTypeIndexName){.tindex = 351, .tname = _SLIT("v.ast.SqlStmt")}
		, (VCastTypeIndexName){.tindex = 352, .tname = _SLIT("v.ast.StructDecl")}
		, (VCastTypeIndexName){.tindex = 277, .tname = _SLIT("v.ast.TypeDecl")}
		, (VCastTypeIndexName){.tindex = 428, .tname = _SLIT("v.ast.AsmAddressing")}
		, (VCastTypeIndexName){.tindex = 429, .tname = _SLIT("v.ast.AsmAlias")}
		, (VCastTypeIndexName){.tindex = 430, .tname = _SLIT("v.ast.AsmDisp")}
		, (VCastTypeIndexName){.tindex = 20, .tname = _SLIT("string")}
	}));


	builtin_init();
	vinit_string_literals();
	{ // Initializations for module strings :
	}
	{ // Initializations for module math.bits :
	_const_math__bits__de_bruijn32tab = new_array_from_c_array(32, 32, sizeof(byte), _MOV((byte[32]){
		((byte)(0)), 1, 28, 2, 29, 14, 24, 3, 30,
		22, 20, 15, 25, 17, 4, 8, 31,
		27, 13, 23, 21, 19, 16, 7, 26,
		12, 18, 6, 11, 5, 10, 9}));
	_const_math__bits__de_bruijn64tab = new_array_from_c_array(64, 64, sizeof(byte), _MOV((byte[64]){
		((byte)(0)), 1, 56, 2, 57, 49, 28, 3, 61,
		58, 42, 50, 38, 29, 17, 4, 62,
		47, 59, 36, 45, 43, 51, 22, 53,
		39, 33, 30, 24, 18, 12, 5, 63,
		55, 48, 27, 60, 41, 37, 16, 46,
		35, 44, 21, 52, 32, 23, 11, 54,
		26, 40, 15, 34, 20, 31, 10, 25,
		14, 19, 9, 13, 8, 7, 6}));
	_const_math__bits__ntz_8_tab = new_array_from_c_array(256, 256, sizeof(byte), _MOV((byte[256]){
		((byte)(0x08)), 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x05,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x06,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x05,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x07,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x05,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x06,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x05,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00}));
	_const_math__bits__pop_8_tab = new_array_from_c_array(256, 256, sizeof(byte), _MOV((byte[256]){
		((byte)(0x00)), 0x01, 0x01, 0x02, 0x01, 0x02, 0x02, 0x03, 0x01,
		0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x01,
		0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02,
		0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x01,
		0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02,
		0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x02,
		0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03,
		0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x01,
		0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02,
		0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x02,
		0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03,
		0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x02,
		0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03,
		0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x03,
		0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04,
		0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 0x01,
		0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02,
		0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x02,
		0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03,
		0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x02,
		0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03,
		0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x03,
		0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04,
		0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 0x02,
		0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03,
		0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x03,
		0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04,
		0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 0x03,
		0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04,
		0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 0x04,
		0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 0x05,
		0x06, 0x06, 0x07, 0x06, 0x07, 0x07, 0x08}));
	_const_math__bits__rev_8_tab = new_array_from_c_array(256, 256, sizeof(byte), _MOV((byte[256]){
		((byte)(0x00)), 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0, 0x10,
		0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0, 0x08,
		0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8, 0x18,
		0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8, 0x04,
		0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4, 0x14,
		0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4, 0x0c,
		0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec, 0x1c,
		0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc, 0x02,
		0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2, 0x12,
		0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2, 0x0a,
		0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea, 0x1a,
		0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa, 0x06,
		0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6, 0x16,
		0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6, 0x0e,
		0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee, 0x1e,
		0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe, 0x01,
		0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1, 0x11,
		0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1, 0x09,
		0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9, 0x19,
		0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9, 0x05,
		0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5, 0x15,
		0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5, 0x0d,
		0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed, 0x1d,
		0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd, 0x03,
		0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3, 0x13,
		0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3, 0x0b,
		0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb, 0x1b,
		0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb, 0x07,
		0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7, 0x17,
		0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7, 0x0f,
		0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef, 0x1f,
		0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff}));
	_const_math__bits__len_8_tab = new_array_from_c_array(256, 256, sizeof(byte), _MOV((byte[256]){
		((byte)(0x00)), 0x01, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03, 0x04,
		0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x05,
		0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
		0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x06,
		0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
		0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
		0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
		0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x07,
		0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
		0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
		0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
		0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
		0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
		0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
		0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
		0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x08,
		0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
		0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
		0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
		0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
		0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
		0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
		0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
		0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
		0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
		0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
		0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
		0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
		0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
		0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
		0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
		0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08}));
	}
	{ // Initializations for module strconv :
	_const_strconv__pos_exp = new_array_from_c_array(309, 309, sizeof(u64), _MOV((u64[309]){
		((u64)(0x3ff0000000000000U)), ((u64)(0x4024000000000000U)), ((u64)(0x4059000000000000U)), ((u64)(0x408f400000000000U)), ((u64)(0x40c3880000000000U)), ((u64)(0x40f86a0000000000U)), ((u64)(0x412e848000000000U)), ((u64)(0x416312d000000000U)), ((u64)(0x4197d78400000000U)),
		((u64)(0x41cdcd6500000000U)), ((u64)(0x4202a05f20000000U)), ((u64)(0x42374876e8000000U)), ((u64)(0x426d1a94a2000000U)), ((u64)(0x42a2309ce5400000U)), ((u64)(0x42d6bcc41e900000U)), ((u64)(0x430c6bf526340000U)), ((u64)(0x4341c37937e08000U)),
		((u64)(0x4376345785d8a000U)), ((u64)(0x43abc16d674ec800U)), ((u64)(0x43e158e460913d00U)), ((u64)(0x4415af1d78b58c40U)), ((u64)(0x444b1ae4d6e2ef50U)), ((u64)(0x4480f0cf064dd592U)), ((u64)(0x44b52d02c7e14af6U)), ((u64)(0x44ea784379d99db4U)),
		((u64)(0x45208b2a2c280291U)), ((u64)(0x4554adf4b7320335U)), ((u64)(0x4589d971e4fe8402U)), ((u64)(0x45c027e72f1f1281U)), ((u64)(0x45f431e0fae6d721U)), ((u64)(0x46293e5939a08ceaU)), ((u64)(0x465f8def8808b024U)), ((u64)(0x4693b8b5b5056e17U)),
		((u64)(0x46c8a6e32246c99cU)), ((u64)(0x46fed09bead87c03U)), ((u64)(0x4733426172c74d82U)), ((u64)(0x476812f9cf7920e3U)), ((u64)(0x479e17b84357691bU)), ((u64)(0x47d2ced32a16a1b1U)), ((u64)(0x48078287f49c4a1dU)), ((u64)(0x483d6329f1c35ca5U)),
		((u64)(0x48725dfa371a19e7U)), ((u64)(0x48a6f578c4e0a061U)), ((u64)(0x48dcb2d6f618c879U)), ((u64)(0x4911efc659cf7d4cU)), ((u64)(0x49466bb7f0435c9eU)), ((u64)(0x497c06a5ec5433c6U)), ((u64)(0x49b18427b3b4a05cU)), ((u64)(0x49e5e531a0a1c873U)),
		((u64)(0x4a1b5e7e08ca3a8fU)), ((u64)(0x4a511b0ec57e649aU)), ((u64)(0x4a8561d276ddfdc0U)), ((u64)(0x4ababa4714957d30U)), ((u64)(0x4af0b46c6cdd6e3eU)), ((u64)(0x4b24e1878814c9ceU)), ((u64)(0x4b5a19e96a19fc41U)), ((u64)(0x4b905031e2503da9U)),
		((u64)(0x4bc4643e5ae44d13U)), ((u64)(0x4bf97d4df19d6057U)), ((u64)(0x4c2fdca16e04b86dU)), ((u64)(0x4c63e9e4e4c2f344U)), ((u64)(0x4c98e45e1df3b015U)), ((u64)(0x4ccf1d75a5709c1bU)), ((u64)(0x4d03726987666191U)), ((u64)(0x4d384f03e93ff9f5U)),
		((u64)(0x4d6e62c4e38ff872U)), ((u64)(0x4da2fdbb0e39fb47U)), ((u64)(0x4dd7bd29d1c87a19U)), ((u64)(0x4e0dac74463a989fU)), ((u64)(0x4e428bc8abe49f64U)), ((u64)(0x4e772ebad6ddc73dU)), ((u64)(0x4eacfa698c95390cU)), ((u64)(0x4ee21c81f7dd43a7U)),
		((u64)(0x4f16a3a275d49491U)), ((u64)(0x4f4c4c8b1349b9b5U)), ((u64)(0x4f81afd6ec0e1411U)), ((u64)(0x4fb61bcca7119916U)), ((u64)(0x4feba2bfd0d5ff5bU)), ((u64)(0x502145b7e285bf99U)), ((u64)(0x50559725db272f7fU)), ((u64)(0x508afcef51f0fb5fU)),
		((u64)(0x50c0de1593369d1bU)), ((u64)(0x50f5159af8044462U)), ((u64)(0x512a5b01b605557bU)), ((u64)(0x516078e111c3556dU)), ((u64)(0x5194971956342ac8U)), ((u64)(0x51c9bcdfabc1357aU)), ((u64)(0x5200160bcb58c16cU)), ((u64)(0x52341b8ebe2ef1c7U)),
		((u64)(0x526922726dbaae39U)), ((u64)(0x529f6b0f092959c7U)), ((u64)(0x52d3a2e965b9d81dU)), ((u64)(0x53088ba3bf284e24U)), ((u64)(0x533eae8caef261adU)), ((u64)(0x53732d17ed577d0cU)), ((u64)(0x53a7f85de8ad5c4fU)), ((u64)(0x53ddf67562d8b363U)),
		((u64)(0x5412ba095dc7701eU)), ((u64)(0x5447688bb5394c25U)), ((u64)(0x547d42aea2879f2eU)), ((u64)(0x54b249ad2594c37dU)), ((u64)(0x54e6dc186ef9f45cU)), ((u64)(0x551c931e8ab87173U)), ((u64)(0x5551dbf316b346e8U)), ((u64)(0x558652efdc6018a2U)),
		((u64)(0x55bbe7abd3781ecaU)), ((u64)(0x55f170cb642b133fU)), ((u64)(0x5625ccfe3d35d80eU)), ((u64)(0x565b403dcc834e12U)), ((u64)(0x569108269fd210cbU)), ((u64)(0x56c54a3047c694feU)), ((u64)(0x56fa9cbc59b83a3dU)), ((u64)(0x5730a1f5b8132466U)),
		((u64)(0x5764ca732617ed80U)), ((u64)(0x5799fd0fef9de8e0U)), ((u64)(0x57d03e29f5c2b18cU)), ((u64)(0x58044db473335defU)), ((u64)(0x583961219000356bU)), ((u64)(0x586fb969f40042c5U)), ((u64)(0x58a3d3e2388029bbU)), ((u64)(0x58d8c8dac6a0342aU)),
		((u64)(0x590efb1178484135U)), ((u64)(0x59435ceaeb2d28c1U)), ((u64)(0x59783425a5f872f1U)), ((u64)(0x59ae412f0f768fadU)), ((u64)(0x59e2e8bd69aa19ccU)), ((u64)(0x5a17a2ecc414a03fU)), ((u64)(0x5a4d8ba7f519c84fU)), ((u64)(0x5a827748f9301d32U)),
		((u64)(0x5ab7151b377c247eU)), ((u64)(0x5aecda62055b2d9eU)), ((u64)(0x5b22087d4358fc82U)), ((u64)(0x5b568a9c942f3ba3U)), ((u64)(0x5b8c2d43b93b0a8cU)), ((u64)(0x5bc19c4a53c4e697U)), ((u64)(0x5bf6035ce8b6203dU)), ((u64)(0x5c2b843422e3a84dU)),
		((u64)(0x5c6132a095ce4930U)), ((u64)(0x5c957f48bb41db7cU)), ((u64)(0x5ccadf1aea12525bU)), ((u64)(0x5d00cb70d24b7379U)), ((u64)(0x5d34fe4d06de5057U)), ((u64)(0x5d6a3de04895e46dU)), ((u64)(0x5da066ac2d5daec4U)), ((u64)(0x5dd4805738b51a75U)),
		((u64)(0x5e09a06d06e26112U)), ((u64)(0x5e400444244d7cabU)), ((u64)(0x5e7405552d60dbd6U)), ((u64)(0x5ea906aa78b912ccU)), ((u64)(0x5edf485516e7577fU)), ((u64)(0x5f138d352e5096afU)), ((u64)(0x5f48708279e4bc5bU)), ((u64)(0x5f7e8ca3185deb72U)),
		((u64)(0x5fb317e5ef3ab327U)), ((u64)(0x5fe7dddf6b095ff1U)), ((u64)(0x601dd55745cbb7edU)), ((u64)(0x6052a5568b9f52f4U)), ((u64)(0x60874eac2e8727b1U)), ((u64)(0x60bd22573a28f19dU)), ((u64)(0x60f2357684599702U)), ((u64)(0x6126c2d4256ffcc3U)),
		((u64)(0x615c73892ecbfbf4U)), ((u64)(0x6191c835bd3f7d78U)), ((u64)(0x61c63a432c8f5cd6U)), ((u64)(0x61fbc8d3f7b3340cU)), ((u64)(0x62315d847ad00087U)), ((u64)(0x6265b4e5998400a9U)), ((u64)(0x629b221effe500d4U)), ((u64)(0x62d0f5535fef2084U)),
		((u64)(0x630532a837eae8a5U)), ((u64)(0x633a7f5245e5a2cfU)), ((u64)(0x63708f936baf85c1U)), ((u64)(0x63a4b378469b6732U)), ((u64)(0x63d9e056584240feU)), ((u64)(0x64102c35f729689fU)), ((u64)(0x6444374374f3c2c6U)), ((u64)(0x647945145230b378U)),
		((u64)(0x64af965966bce056U)), ((u64)(0x64e3bdf7e0360c36U)), ((u64)(0x6518ad75d8438f43U)), ((u64)(0x654ed8d34e547314U)), ((u64)(0x6583478410f4c7ecU)), ((u64)(0x65b819651531f9e8U)), ((u64)(0x65ee1fbe5a7e7861U)), ((u64)(0x6622d3d6f88f0b3dU)),
		((u64)(0x665788ccb6b2ce0cU)), ((u64)(0x668d6affe45f818fU)), ((u64)(0x66c262dfeebbb0f9U)), ((u64)(0x66f6fb97ea6a9d38U)), ((u64)(0x672cba7de5054486U)), ((u64)(0x6761f48eaf234ad4U)), ((u64)(0x679671b25aec1d89U)), ((u64)(0x67cc0e1ef1a724ebU)),
		((u64)(0x680188d357087713U)), ((u64)(0x6835eb082cca94d7U)), ((u64)(0x686b65ca37fd3a0dU)), ((u64)(0x68a11f9e62fe4448U)), ((u64)(0x68d56785fbbdd55aU)), ((u64)(0x690ac1677aad4ab1U)), ((u64)(0x6940b8e0acac4eafU)), ((u64)(0x6974e718d7d7625aU)),
		((u64)(0x69aa20df0dcd3af1U)), ((u64)(0x69e0548b68a044d6U)), ((u64)(0x6a1469ae42c8560cU)), ((u64)(0x6a498419d37a6b8fU)), ((u64)(0x6a7fe52048590673U)), ((u64)(0x6ab3ef342d37a408U)), ((u64)(0x6ae8eb0138858d0aU)), ((u64)(0x6b1f25c186a6f04cU)),
		((u64)(0x6b537798f4285630U)), ((u64)(0x6b88557f31326bbbU)), ((u64)(0x6bbe6adefd7f06aaU)), ((u64)(0x6bf302cb5e6f642aU)), ((u64)(0x6c27c37e360b3d35U)), ((u64)(0x6c5db45dc38e0c82U)), ((u64)(0x6c9290ba9a38c7d1U)), ((u64)(0x6cc734e940c6f9c6U)),
		((u64)(0x6cfd022390f8b837U)), ((u64)(0x6d3221563a9b7323U)), ((u64)(0x6d66a9abc9424febU)), ((u64)(0x6d9c5416bb92e3e6U)), ((u64)(0x6dd1b48e353bce70U)), ((u64)(0x6e0621b1c28ac20cU)), ((u64)(0x6e3baa1e332d728fU)), ((u64)(0x6e714a52dffc6799U)),
		((u64)(0x6ea59ce797fb817fU)), ((u64)(0x6edb04217dfa61dfU)), ((u64)(0x6f10e294eebc7d2cU)), ((u64)(0x6f451b3a2a6b9c76U)), ((u64)(0x6f7a6208b5068394U)), ((u64)(0x6fb07d457124123dU)), ((u64)(0x6fe49c96cd6d16ccU)), ((u64)(0x7019c3bc80c85c7fU)),
		((u64)(0x70501a55d07d39cfU)), ((u64)(0x708420eb449c8843U)), ((u64)(0x70b9292615c3aa54U)), ((u64)(0x70ef736f9b3494e9U)), ((u64)(0x7123a825c100dd11U)), ((u64)(0x7158922f31411456U)), ((u64)(0x718eb6bafd91596bU)), ((u64)(0x71c33234de7ad7e3U)),
		((u64)(0x71f7fec216198ddcU)), ((u64)(0x722dfe729b9ff153U)), ((u64)(0x7262bf07a143f6d4U)), ((u64)(0x72976ec98994f489U)), ((u64)(0x72cd4a7bebfa31abU)), ((u64)(0x73024e8d737c5f0bU)), ((u64)(0x7336e230d05b76cdU)), ((u64)(0x736c9abd04725481U)),
		((u64)(0x73a1e0b622c774d0U)), ((u64)(0x73d658e3ab795204U)), ((u64)(0x740bef1c9657a686U)), ((u64)(0x74417571ddf6c814U)), ((u64)(0x7475d2ce55747a18U)), ((u64)(0x74ab4781ead1989eU)), ((u64)(0x74e10cb132c2ff63U)), ((u64)(0x75154fdd7f73bf3cU)),
		((u64)(0x754aa3d4df50af0bU)), ((u64)(0x7580a6650b926d67U)), ((u64)(0x75b4cffe4e7708c0U)), ((u64)(0x75ea03fde214caf1U)), ((u64)(0x7620427ead4cfed6U)), ((u64)(0x7654531e58a03e8cU)), ((u64)(0x768967e5eec84e2fU)), ((u64)(0x76bfc1df6a7a61bbU)),
		((u64)(0x76f3d92ba28c7d15U)), ((u64)(0x7728cf768b2f9c5aU)), ((u64)(0x775f03542dfb8370U)), ((u64)(0x779362149cbd3226U)), ((u64)(0x77c83a99c3ec7eb0U)), ((u64)(0x77fe494034e79e5cU)), ((u64)(0x7832edc82110c2f9U)), ((u64)(0x7867a93a2954f3b8U)),
		((u64)(0x789d9388b3aa30a5U)), ((u64)(0x78d27c35704a5e67U)), ((u64)(0x79071b42cc5cf601U)), ((u64)(0x793ce2137f743382U)), ((u64)(0x79720d4c2fa8a031U)), ((u64)(0x79a6909f3b92c83dU)), ((u64)(0x79dc34c70a777a4dU)), ((u64)(0x7a11a0fc668aac70U)),
		((u64)(0x7a46093b802d578cU)), ((u64)(0x7a7b8b8a6038ad6fU)), ((u64)(0x7ab137367c236c65U)), ((u64)(0x7ae585041b2c477fU)), ((u64)(0x7b1ae64521f7595eU)), ((u64)(0x7b50cfeb353a97dbU)), ((u64)(0x7b8503e602893dd2U)), ((u64)(0x7bba44df832b8d46U)),
		((u64)(0x7bf06b0bb1fb384cU)), ((u64)(0x7c2485ce9e7a065fU)), ((u64)(0x7c59a742461887f6U)), ((u64)(0x7c9008896bcf54faU)), ((u64)(0x7cc40aabc6c32a38U)), ((u64)(0x7cf90d56b873f4c7U)), ((u64)(0x7d2f50ac6690f1f8U)), ((u64)(0x7d63926bc01a973bU)),
		((u64)(0x7d987706b0213d0aU)), ((u64)(0x7dce94c85c298c4cU)), ((u64)(0x7e031cfd3999f7b0U)), ((u64)(0x7e37e43c8800759cU)), ((u64)(0x7e6ddd4baa009303U)), ((u64)(0x7ea2aa4f4a405be2U)), ((u64)(0x7ed754e31cd072daU)), ((u64)(0x7f0d2a1be4048f90U)),
		((u64)(0x7f423a516e82d9baU)), ((u64)(0x7f76c8e5ca239029U)), ((u64)(0x7fac7b1f3cac7433U)), ((u64)(0x7fe1ccf385ebc8a0U))}));
	_const_strconv__neg_exp = new_array_from_c_array(324, 324, sizeof(u64), _MOV((u64[324]){
		((u64)(0x3ff0000000000000U)), ((u64)(0x3fb999999999999aU)), ((u64)(0x3f847ae147ae147bU)), ((u64)(0x3f50624dd2f1a9fcU)), ((u64)(0x3f1a36e2eb1c432dU)), ((u64)(0x3ee4f8b588e368f1U)), ((u64)(0x3eb0c6f7a0b5ed8dU)), ((u64)(0x3e7ad7f29abcaf48U)), ((u64)(0x3e45798ee2308c3aU)),
		((u64)(0x3e112e0be826d695U)), ((u64)(0x3ddb7cdfd9d7bdbbU)), ((u64)(0x3da5fd7fe1796495U)), ((u64)(0x3d719799812dea11U)), ((u64)(0x3d3c25c268497682U)), ((u64)(0x3d06849b86a12b9bU)), ((u64)(0x3cd203af9ee75616U)), ((u64)(0x3c9cd2b297d889bcU)),
		((u64)(0x3c670ef54646d497U)), ((u64)(0x3c32725dd1d243acU)), ((u64)(0x3bfd83c94fb6d2acU)), ((u64)(0x3bc79ca10c924223U)), ((u64)(0x3b92e3b40a0e9b4fU)), ((u64)(0x3b5e392010175ee6U)), ((u64)(0x3b282db34012b251U)), ((u64)(0x3af357c299a88ea7U)),
		((u64)(0x3abef2d0f5da7dd9U)), ((u64)(0x3a88c240c4aecb14U)), ((u64)(0x3a53ce9a36f23c10U)), ((u64)(0x3a1fb0f6be506019U)), ((u64)(0x39e95a5efea6b347U)), ((u64)(0x39b4484bfeebc2a0U)), ((u64)(0x398039d665896880U)), ((u64)(0x3949f623d5a8a733U)),
		((u64)(0x3914c4e977ba1f5cU)), ((u64)(0x38e09d8792fb4c49U)), ((u64)(0x38aa95a5b7f87a0fU)), ((u64)(0x38754484932d2e72U)), ((u64)(0x3841039d428a8b8fU)), ((u64)(0x380b38fb9daa78e4U)), ((u64)(0x37d5c72fb1552d83U)), ((u64)(0x37a16c262777579cU)),
		((u64)(0x376be03d0bf225c7U)), ((u64)(0x37364cfda3281e39U)), ((u64)(0x3701d7314f534b61U)), ((u64)(0x36cc8b8218854567U)), ((u64)(0x3696d601ad376ab9U)), ((u64)(0x366244ce242c5561U)), ((u64)(0x362d3ae36d13bbceU)), ((u64)(0x35f7624f8a762fd8U)),
		((u64)(0x35c2b50c6ec4f313U)), ((u64)(0x358dee7a4ad4b81fU)), ((u64)(0x3557f1fb6f10934cU)), ((u64)(0x352327fc58da0f70U)), ((u64)(0x34eea6608e29b24dU)), ((u64)(0x34b8851a0b548ea4U)), ((u64)(0x34839dae6f76d883U)), ((u64)(0x344f62b0b257c0d2U)),
		((u64)(0x34191bc08eac9a41U)), ((u64)(0x33e41633a556e1ceU)), ((u64)(0x33b011c2eaabe7d8U)), ((u64)(0x3379b604aaaca626U)), ((u64)(0x3344919d5556eb52U)), ((u64)(0x3310747ddddf22a8U)), ((u64)(0x32da53fc9631d10dU)), ((u64)(0x32a50ffd44f4a73dU)),
		((u64)(0x3270d9976a5d5297U)), ((u64)(0x323af5bf109550f2U)), ((u64)(0x32059165a6ddda5bU)), ((u64)(0x31d1411e1f17e1e3U)), ((u64)(0x319b9b6364f30304U)), ((u64)(0x316615e91d8f359dU)), ((u64)(0x3131ab20e472914aU)), ((u64)(0x30fc45016d841baaU)),
		((u64)(0x30c69d9abe034955U)), ((u64)(0x309217aefe690777U)), ((u64)(0x305cf2b1970e7258U)), ((u64)(0x3027288e1271f513U)), ((u64)(0x2ff286d80ec190dcU)), ((u64)(0x2fbda48ce468e7c7U)), ((u64)(0x2f87b6d71d20b96cU)), ((u64)(0x2f52f8ac174d6123U)),
		((u64)(0x2f1e5aacf2156838U)), ((u64)(0x2ee8488a5b445360U)), ((u64)(0x2eb36d3b7c36a91aU)), ((u64)(0x2e7f152bf9f10e90U)), ((u64)(0x2e48ddbcc7f40ba6U)), ((u64)(0x2e13e497065cd61fU)), ((u64)(0x2ddfd424d6faf031U)), ((u64)(0x2da97683df2f268dU)),
		((u64)(0x2d745ecfe5bf520bU)), ((u64)(0x2d404bd984990e6fU)), ((u64)(0x2d0a12f5a0f4e3e5U)), ((u64)(0x2cd4dbf7b3f71cb7U)), ((u64)(0x2ca0aff95cc5b092U)), ((u64)(0x2c6ab328946f80eaU)), ((u64)(0x2c355c2076bf9a55U)), ((u64)(0x2c0116805effaeaaU)),
		((u64)(0x2bcb5733cb32b111U)), ((u64)(0x2b95df5ca28ef40dU)), ((u64)(0x2b617f7d4ed8c33eU)), ((u64)(0x2b2bff2ee48e0530U)), ((u64)(0x2af665bf1d3e6a8dU)), ((u64)(0x2ac1eaff4a98553dU)), ((u64)(0x2a8cab3210f3bb95U)), ((u64)(0x2a56ef5b40c2fc77U)),
		((u64)(0x2a225915cd68c9f9U)), ((u64)(0x29ed5b561574765bU)), ((u64)(0x29b77c44ddf6c516U)), ((u64)(0x2982c9d0b1923745U)), ((u64)(0x294e0fb44f50586eU)), ((u64)(0x29180c903f7379f2U)), ((u64)(0x28e33d4032c2c7f5U)), ((u64)(0x28aec866b79e0cbaU)),
		((u64)(0x2878a0522c7e7095U)), ((u64)(0x2843b374f06526deU)), ((u64)(0x280f8587e7083e30U)), ((u64)(0x27d9379fec069826U)), ((u64)(0x27a42c7ff0054685U)), ((u64)(0x277023998cd10537U)), ((u64)(0x2739d28f47b4d525U)), ((u64)(0x2704a8729fc3ddb7U)),
		((u64)(0x26d086c219697e2cU)), ((u64)(0x269a71368f0f3047U)), ((u64)(0x2665275ed8d8f36cU)), ((u64)(0x2630ec4be0ad8f89U)), ((u64)(0x25fb13ac9aaf4c0fU)), ((u64)(0x25c5a956e225d672U)), ((u64)(0x2591544581b7dec2U)), ((u64)(0x255bba08cf8c979dU)),
		((u64)(0x25262e6d72d6dfb0U)), ((u64)(0x24f1bebdf578b2f4U)), ((u64)(0x24bc6463225ab7ecU)), ((u64)(0x2486b6b5b5155ff0U)), ((u64)(0x24522bc490dde65aU)), ((u64)(0x241d12d41afca3c3U)), ((u64)(0x23e7424348ca1c9cU)), ((u64)(0x23b29b69070816e3U)),
		((u64)(0x237dc574d80cf16bU)), ((u64)(0x2347d12a4670c123U)), ((u64)(0x23130dbb6b8d674fU)), ((u64)(0x22de7c5f127bd87eU)), ((u64)(0x22a8637f41fcad32U)), ((u64)(0x227382cc34ca2428U)), ((u64)(0x223f37ad21436d0cU)), ((u64)(0x2208f9574dcf8a70U)),
		((u64)(0x21d3faac3e3fa1f3U)), ((u64)(0x219ff779fd329cb9U)), ((u64)(0x216992c7fdc216faU)), ((u64)(0x2134756ccb01abfbU)), ((u64)(0x21005df0a267bcc9U)), ((u64)(0x20ca2fe76a3f9475U)), ((u64)(0x2094f31f8832dd2aU)), ((u64)(0x2060c27fa028b0efU)),
		((u64)(0x202ad0cc33744e4bU)), ((u64)(0x1ff573d68f903ea2U)), ((u64)(0x1fc1297872d9cbb5U)), ((u64)(0x1f8b758d848fac55U)), ((u64)(0x1f55f7a46a0c89ddU)), ((u64)(0x1f2192e9ee706e4bU)), ((u64)(0x1eec1e43171a4a11U)), ((u64)(0x1eb67e9c127b6e74U)),
		((u64)(0x1e81fee341fc585dU)), ((u64)(0x1e4ccb0536608d61U)), ((u64)(0x1e1708d0f84d3de7U)), ((u64)(0x1de26d73f9d764b9U)), ((u64)(0x1dad7becc2f23ac2U)), ((u64)(0x1d779657025b6235U)), ((u64)(0x1d42deac01e2b4f7U)), ((u64)(0x1d0e3113363787f2U)),
		((u64)(0x1cd8274291c6065bU)), ((u64)(0x1ca3529ba7d19eafU)), ((u64)(0x1c6eea92a61c3118U)), ((u64)(0x1c38bba884e35a7aU)), ((u64)(0x1c03c9539d82aec8U)), ((u64)(0x1bcfa885c8d117a6U)), ((u64)(0x1b99539e3a40dfb8U)), ((u64)(0x1b6442e4fb671960U)),
		((u64)(0x1b303583fc527ab3U)), ((u64)(0x1af9ef3993b72ab8U)), ((u64)(0x1ac4bf6142f8eefaU)), ((u64)(0x1a90991a9bfa58c8U)), ((u64)(0x1a5a8e90f9908e0dU)), ((u64)(0x1a253eda614071a4U)), ((u64)(0x19f0ff151a99f483U)), ((u64)(0x19bb31bb5dc320d2U)),
		((u64)(0x1985c162b168e70eU)), ((u64)(0x1951678227871f3eU)), ((u64)(0x191bd8d03f3e9864U)), ((u64)(0x18e6470cff6546b6U)), ((u64)(0x18b1d270cc51055fU)), ((u64)(0x187c83e7ad4e6efeU)), ((u64)(0x1846cfec8aa52598U)), ((u64)(0x18123ff06eea847aU)),
		((u64)(0x17dd331a4b10d3f6U)), ((u64)(0x17a75c1508da432bU)), ((u64)(0x1772b010d3e1cf56U)), ((u64)(0x173de6815302e556U)), ((u64)(0x1707eb9aa8cf1ddeU)), ((u64)(0x16d322e220a5b17eU)), ((u64)(0x169e9e369aa2b597U)), ((u64)(0x16687e92154ef7acU)),
		((u64)(0x16339874ddd8c623U)), ((u64)(0x15ff5a549627a36cU)), ((u64)(0x15c91510781fb5f0U)), ((u64)(0x159410d9f9b2f7f3U)), ((u64)(0x15600d7b2e28c65cU)), ((u64)(0x1529af2b7d0e0a2dU)), ((u64)(0x14f48c22ca71a1bdU)), ((u64)(0x14c0701bd527b498U)),
		((u64)(0x148a4cf9550c5426U)), ((u64)(0x14550a6110d6a9b8U)), ((u64)(0x1420d51a73deee2dU)), ((u64)(0x13eaee90b964b047U)), ((u64)(0x13b58ba6fab6f36cU)), ((u64)(0x13813c85955f2923U)), ((u64)(0x134b9408eefea839U)), ((u64)(0x1316100725988694U)),
		((u64)(0x12e1a66c1e139eddU)), ((u64)(0x12ac3d79c9b8fe2eU)), ((u64)(0x12769794a160cb58U)), ((u64)(0x124212dd4de70913U)), ((u64)(0x120ceafbafd80e85U)), ((u64)(0x11d72262f3133ed1U)), ((u64)(0x11a281e8c275cbdaU)), ((u64)(0x116d9ca79d89462aU)),
		((u64)(0x1137b08617a104eeU)), ((u64)(0x1102f39e794d9d8bU)), ((u64)(0x10ce5297287c2f45U)), ((u64)(0x1098421286c9bf6bU)), ((u64)(0x1063680ed23aff89U)), ((u64)(0x102f0ce4839198dbU)), ((u64)(0x0ff8d71d360e13e2U)), ((u64)(0x0fc3df4a91a4dcb5U)),
		((u64)(0x0f8fcbaa82a16121U)), ((u64)(0x0f596fbb9bb44db4U)), ((u64)(0x0f245962e2f6a490U)), ((u64)(0x0ef047824f2bb6daU)), ((u64)(0x0eba0c03b1df8af6U)), ((u64)(0x0e84d6695b193bf8U)), ((u64)(0x0e50ab877c142ffaU)), ((u64)(0x0e1aac0bf9b9e65cU)),
		((u64)(0x0de5566ffafb1eb0U)), ((u64)(0x0db111f32f2f4bc0U)), ((u64)(0x0d7b4feb7eb212cdU)), ((u64)(0x0d45d98932280f0aU)), ((u64)(0x0d117ad428200c08U)), ((u64)(0x0cdbf7b9d9cce00dU)), ((u64)(0x0ca65fc7e170b33eU)), ((u64)(0x0c71e6398126f5cbU)),
		((u64)(0x0c3ca38f350b22dfU)), ((u64)(0x0c06e93f5da2824cU)), ((u64)(0x0bd25432b14ecea3U)), ((u64)(0x0b9d53844ee47dd1U)), ((u64)(0x0b677603725064a8U)), ((u64)(0x0b32c4cf8ea6b6ecU)), ((u64)(0x0afe07b27dd78b14U)), ((u64)(0x0ac8062864ac6f43U)),
		((u64)(0x0a9338205089f29cU)), ((u64)(0x0a5ec033b40fea93U)), ((u64)(0x0a2899c2f6732210U)), ((u64)(0x09f3ae3591f5b4d9U)), ((u64)(0x09bf7d228322baf5U)), ((u64)(0x098930e868e89591U)), ((u64)(0x0954272053ed4474U)), ((u64)(0x09201f4d0ff10390U)),
		((u64)(0x08e9cbae7fe805b3U)), ((u64)(0x08b4a2f1ffecd15cU)), ((u64)(0x0880825b3323dab0U)), ((u64)(0x084a6a2b85062ab3U)), ((u64)(0x081521bc6a6b555cU)), ((u64)(0x07e0e7c9eebc444aU)), ((u64)(0x07ab0c764ac6d3a9U)), ((u64)(0x0775a391d56bdc87U)),
		((u64)(0x07414fa7ddefe3a0U)), ((u64)(0x070bb2a62fe638ffU)), ((u64)(0x06d62884f31e93ffU)), ((u64)(0x06a1ba03f5b21000U)), ((u64)(0x066c5cd322b67fffU)), ((u64)(0x0636b0a8e891ffffU)), ((u64)(0x060226ed86db3333U)), ((u64)(0x05cd0b15a491eb84U)),
		((u64)(0x05973c115074bc6aU)), ((u64)(0x05629674405d6388U)), ((u64)(0x052dbd86cd6238d9U)), ((u64)(0x04f7cad23de82d7bU)), ((u64)(0x04c308a831868ac9U)), ((u64)(0x048e74404f3daadbU)), ((u64)(0x04585d003f6488afU)), ((u64)(0x04237d99cc506d59U)),
		((u64)(0x03ef2f5c7a1a488eU)), ((u64)(0x03b8f2b061aea072U)), ((u64)(0x0383f559e7bee6c1U)), ((u64)(0x034feef63f97d79cU)), ((u64)(0x03198bf832dfdfb0U)), ((u64)(0x02e46ff9c24cb2f3U)), ((u64)(0x02b059949b708f29U)), ((u64)(0x027a28edc580e50eU)),
		((u64)(0x0244ed8b04671da5U)), ((u64)(0x0210be08d0527e1dU)), ((u64)(0x01dac9a7b3b7302fU)), ((u64)(0x01a56e1fc2f8f359U)), ((u64)(0x017124e63593f5e1U)), ((u64)(0x013b6e3d22865634U)), ((u64)(0x0105f1ca820511c3U)), ((u64)(0x00d18e3b9b374169U)),
		((u64)(0x009c16c5c5253575U)), ((u64)(0x0066789e3750f791U)), ((u64)(0x0031fa182c40c60dU)), ((u64)(0x000730d67819e8d2U)), ((u64)(0x0000b8157268fdafU)), ((u64)(0x000012688b70e62bU)), ((u64)(0x000001d74124e3d1U)), ((u64)(0x0000002f201d49fbU)),
		((u64)(0x00000004b6695433U)), ((u64)(0x0000000078a42205U)), ((u64)(0x000000000c1069cdU)), ((u64)(0x000000000134d761U)), ((u64)(0x00000000001ee257U)), ((u64)(0x00000000000316a2U)), ((u64)(0x0000000000004f10U)), ((u64)(0x00000000000007e8U)),
		((u64)(0x00000000000000caU)), ((u64)(0x0000000000000014U)), ((u64)(0x0000000000000002U))}));
	_const_strconv__ten_pow_table_32 = new_array_from_c_array(12, 12, sizeof(u32), _MOV((u32[12]){
		((u32)(1U)), ((u32)(10U)), ((u32)(100U)), ((u32)(1000U)), ((u32)(10000U)), ((u32)(100000U)), ((u32)(1000000U)), ((u32)(10000000U)), ((u32)(100000000U)),
		((u32)(1000000000U)), ((u32)(10000000000U)), ((u32)(100000000000U))}));
	_const_strconv__ten_pow_table_64 = new_array_from_c_array(20, 20, sizeof(u64), _MOV((u64[20]){
		((u64)(1U)), ((u64)(10U)), ((u64)(100U)), ((u64)(1000U)), ((u64)(10000U)), ((u64)(100000U)), ((u64)(1000000U)), ((u64)(10000000U)), ((u64)(100000000U)),
		((u64)(1000000000U)), ((u64)(10000000000U)), ((u64)(100000000000U)), ((u64)(1000000000000U)), ((u64)(10000000000000U)), ((u64)(100000000000000U)), ((u64)(1000000000000000U)), ((u64)(10000000000000000U)),
		((u64)(100000000000000000U)), ((u64)(1000000000000000000U)), ((u64)(10000000000000000000U))}));
	_const_strconv__dec_round = new_array_from_c_array(20, 20, sizeof(f64), _MOV((f64[20]){
		((f64)(0.5)), 0.05, 0.005, 0.0005, 0.00005, 0.000005, 0.0000005, 0.00000005, 0.000000005,
		0.0000000005, 0.00000000005, 0.000000000005, 0.0000000000005, 0.00000000000005, 0.000000000000005, 0.0000000000000005, 0.00000000000000005,
		0.000000000000000005, 0.0000000000000000005, 0.00000000000000000005}));
	_const_strconv__powers_of_10 = new_array_from_c_array(18, 18, sizeof(u64), _MOV((u64[18]){
		((u64)(1e0)), ((u64)(1e1)), ((u64)(1e2)), ((u64)(1e3)), ((u64)(1e4)), ((u64)(1e5)), ((u64)(1e6)), ((u64)(1e7)), ((u64)(1e8)),
		((u64)(1e9)), ((u64)(1e10)), ((u64)(1e11)), ((u64)(1e12)), ((u64)(1e13)), ((u64)(1e14)), ((u64)(1e15)), ((u64)(1e16)),
		((u64)(1e17))}));
	_const_strconv__pow5_split_32 = new_array_from_c_array(47, 47, sizeof(u64), _MOV((u64[47]){
		((u64)(1152921504606846976U)), ((u64)(1441151880758558720U)), ((u64)(1801439850948198400U)), ((u64)(2251799813685248000U)), ((u64)(1407374883553280000U)), ((u64)(1759218604441600000U)), ((u64)(2199023255552000000U)), ((u64)(1374389534720000000U)), ((u64)(1717986918400000000U)),
		((u64)(2147483648000000000U)), ((u64)(1342177280000000000U)), ((u64)(1677721600000000000U)), ((u64)(2097152000000000000U)), ((u64)(1310720000000000000U)), ((u64)(1638400000000000000U)), ((u64)(2048000000000000000U)), ((u64)(1280000000000000000U)),
		((u64)(1600000000000000000U)), ((u64)(2000000000000000000U)), ((u64)(1250000000000000000U)), ((u64)(1562500000000000000U)), ((u64)(1953125000000000000U)), ((u64)(1220703125000000000U)), ((u64)(1525878906250000000U)), ((u64)(1907348632812500000U)),
		((u64)(1192092895507812500U)), ((u64)(1490116119384765625U)), ((u64)(1862645149230957031U)), ((u64)(1164153218269348144U)), ((u64)(1455191522836685180U)), ((u64)(1818989403545856475U)), ((u64)(2273736754432320594U)), ((u64)(1421085471520200371U)),
		((u64)(1776356839400250464U)), ((u64)(2220446049250313080U)), ((u64)(1387778780781445675U)), ((u64)(1734723475976807094U)), ((u64)(2168404344971008868U)), ((u64)(1355252715606880542U)), ((u64)(1694065894508600678U)), ((u64)(2117582368135750847U)),
		((u64)(1323488980084844279U)), ((u64)(1654361225106055349U)), ((u64)(2067951531382569187U)), ((u64)(1292469707114105741U)), ((u64)(1615587133892632177U)), ((u64)(2019483917365790221U))}));
	_const_strconv__pow5_inv_split_32 = new_array_from_c_array(31, 31, sizeof(u64), _MOV((u64[31]){
		((u64)(576460752303423489U)), ((u64)(461168601842738791U)), ((u64)(368934881474191033U)), ((u64)(295147905179352826U)), ((u64)(472236648286964522U)), ((u64)(377789318629571618U)), ((u64)(302231454903657294U)), ((u64)(483570327845851670U)), ((u64)(386856262276681336U)),
		((u64)(309485009821345069U)), ((u64)(495176015714152110U)), ((u64)(396140812571321688U)), ((u64)(316912650057057351U)), ((u64)(507060240091291761U)), ((u64)(405648192073033409U)), ((u64)(324518553658426727U)), ((u64)(519229685853482763U)),
		((u64)(415383748682786211U)), ((u64)(332306998946228969U)), ((u64)(531691198313966350U)), ((u64)(425352958651173080U)), ((u64)(340282366920938464U)), ((u64)(544451787073501542U)), ((u64)(435561429658801234U)), ((u64)(348449143727040987U)),
		((u64)(557518629963265579U)), ((u64)(446014903970612463U)), ((u64)(356811923176489971U)), ((u64)(570899077082383953U)), ((u64)(456719261665907162U)), ((u64)(365375409332725730U))}));
	_const_strconv__pow5_split_64 = new_array_from_c_array(326, 326, sizeof(strconv__Uint128), _MOV((strconv__Uint128[326]){
		(strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x0100000000000000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x0140000000000000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x0190000000000000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x01f4000000000000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x0138800000000000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x0186a00000000000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x01e8480000000000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x01312d0000000000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x017d784000000000U)),},
		(strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x01dcd65000000000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x012a05f200000000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x0174876e80000000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x01d1a94a20000000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x012309ce54000000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x016bcc41e9000000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x01c6bf5263400000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x011c37937e080000U)),},
		(strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x016345785d8a0000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x01bc16d674ec8000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x01158e460913d000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x015af1d78b58c400U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x01b1ae4d6e2ef500U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x010f0cf064dd5920U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x0152d02c7e14af68U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x01a784379d99db42U)),},
		(strconv__Uint128){.lo = ((u64)(0x4000000000000000U)),.hi = ((u64)(0x0108b2a2c2802909U)),}, (strconv__Uint128){.lo = ((u64)(0x9000000000000000U)),.hi = ((u64)(0x014adf4b7320334bU)),}, (strconv__Uint128){.lo = ((u64)(0x7400000000000000U)),.hi = ((u64)(0x019d971e4fe8401eU)),}, (strconv__Uint128){.lo = ((u64)(0x0880000000000000U)),.hi = ((u64)(0x01027e72f1f12813U)),}, (strconv__Uint128){.lo = ((u64)(0xcaa0000000000000U)),.hi = ((u64)(0x01431e0fae6d7217U)),}, (strconv__Uint128){.lo = ((u64)(0xbd48000000000000U)),.hi = ((u64)(0x0193e5939a08ce9dU)),}, (strconv__Uint128){.lo = ((u64)(0x2c9a000000000000U)),.hi = ((u64)(0x01f8def8808b0245U)),}, (strconv__Uint128){.lo = ((u64)(0x3be0400000000000U)),.hi = ((u64)(0x013b8b5b5056e16bU)),},
		(strconv__Uint128){.lo = ((u64)(0x0ad8500000000000U)),.hi = ((u64)(0x018a6e32246c99c6U)),}, (strconv__Uint128){.lo = ((u64)(0x8d8e640000000000U)),.hi = ((u64)(0x01ed09bead87c037U)),}, (strconv__Uint128){.lo = ((u64)(0xb878fe8000000000U)),.hi = ((u64)(0x013426172c74d822U)),}, (strconv__Uint128){.lo = ((u64)(0x66973e2000000000U)),.hi = ((u64)(0x01812f9cf7920e2bU)),}, (strconv__Uint128){.lo = ((u64)(0x403d0da800000000U)),.hi = ((u64)(0x01e17b84357691b6U)),}, (strconv__Uint128){.lo = ((u64)(0xe826288900000000U)),.hi = ((u64)(0x012ced32a16a1b11U)),}, (strconv__Uint128){.lo = ((u64)(0x622fb2ab40000000U)),.hi = ((u64)(0x0178287f49c4a1d6U)),}, (strconv__Uint128){.lo = ((u64)(0xfabb9f5610000000U)),.hi = ((u64)(0x01d6329f1c35ca4bU)),},
		(strconv__Uint128){.lo = ((u64)(0x7cb54395ca000000U)),.hi = ((u64)(0x0125dfa371a19e6fU)),}, (strconv__Uint128){.lo = ((u64)(0x5be2947b3c800000U)),.hi = ((u64)(0x016f578c4e0a060bU)),}, (strconv__Uint128){.lo = ((u64)(0x32db399a0ba00000U)),.hi = ((u64)(0x01cb2d6f618c878eU)),}, (strconv__Uint128){.lo = ((u64)(0xdfc9040047440000U)),.hi = ((u64)(0x011efc659cf7d4b8U)),}, (strconv__Uint128){.lo = ((u64)(0x17bb450059150000U)),.hi = ((u64)(0x0166bb7f0435c9e7U)),}, (strconv__Uint128){.lo = ((u64)(0xddaa16406f5a4000U)),.hi = ((u64)(0x01c06a5ec5433c60U)),}, (strconv__Uint128){.lo = ((u64)(0x8a8a4de845986800U)),.hi = ((u64)(0x0118427b3b4a05bcU)),}, (strconv__Uint128){.lo = ((u64)(0xad2ce16256fe8200U)),.hi = ((u64)(0x015e531a0a1c872bU)),},
		(strconv__Uint128){.lo = ((u64)(0x987819baecbe2280U)),.hi = ((u64)(0x01b5e7e08ca3a8f6U)),}, (strconv__Uint128){.lo = ((u64)(0x1f4b1014d3f6d590U)),.hi = ((u64)(0x0111b0ec57e6499aU)),}, (strconv__Uint128){.lo = ((u64)(0xa71dd41a08f48af4U)),.hi = ((u64)(0x01561d276ddfdc00U)),}, (strconv__Uint128){.lo = ((u64)(0xd0e549208b31adb1U)),.hi = ((u64)(0x01aba4714957d300U)),}, (strconv__Uint128){.lo = ((u64)(0x828f4db456ff0c8eU)),.hi = ((u64)(0x010b46c6cdd6e3e0U)),}, (strconv__Uint128){.lo = ((u64)(0xa33321216cbecfb2U)),.hi = ((u64)(0x014e1878814c9cd8U)),}, (strconv__Uint128){.lo = ((u64)(0xcbffe969c7ee839eU)),.hi = ((u64)(0x01a19e96a19fc40eU)),}, (strconv__Uint128){.lo = ((u64)(0x3f7ff1e21cf51243U)),.hi = ((u64)(0x0105031e2503da89U)),},
		(strconv__Uint128){.lo = ((u64)(0x8f5fee5aa43256d4U)),.hi = ((u64)(0x014643e5ae44d12bU)),}, (strconv__Uint128){.lo = ((u64)(0x7337e9f14d3eec89U)),.hi = ((u64)(0x0197d4df19d60576U)),}, (strconv__Uint128){.lo = ((u64)(0x1005e46da08ea7abU)),.hi = ((u64)(0x01fdca16e04b86d4U)),}, (strconv__Uint128){.lo = ((u64)(0x8a03aec4845928cbU)),.hi = ((u64)(0x013e9e4e4c2f3444U)),}, (strconv__Uint128){.lo = ((u64)(0xac849a75a56f72fdU)),.hi = ((u64)(0x018e45e1df3b0155U)),}, (strconv__Uint128){.lo = ((u64)(0x17a5c1130ecb4fbdU)),.hi = ((u64)(0x01f1d75a5709c1abU)),}, (strconv__Uint128){.lo = ((u64)(0xeec798abe93f11d6U)),.hi = ((u64)(0x013726987666190aU)),}, (strconv__Uint128){.lo = ((u64)(0xaa797ed6e38ed64bU)),.hi = ((u64)(0x0184f03e93ff9f4dU)),},
		(strconv__Uint128){.lo = ((u64)(0x1517de8c9c728bdeU)),.hi = ((u64)(0x01e62c4e38ff8721U)),}, (strconv__Uint128){.lo = ((u64)(0xad2eeb17e1c7976bU)),.hi = ((u64)(0x012fdbb0e39fb474U)),}, (strconv__Uint128){.lo = ((u64)(0xd87aa5ddda397d46U)),.hi = ((u64)(0x017bd29d1c87a191U)),}, (strconv__Uint128){.lo = ((u64)(0x4e994f5550c7dc97U)),.hi = ((u64)(0x01dac74463a989f6U)),}, (strconv__Uint128){.lo = ((u64)(0xf11fd195527ce9deU)),.hi = ((u64)(0x0128bc8abe49f639U)),}, (strconv__Uint128){.lo = ((u64)(0x6d67c5faa71c2456U)),.hi = ((u64)(0x0172ebad6ddc73c8U)),}, (strconv__Uint128){.lo = ((u64)(0x88c1b77950e32d6cU)),.hi = ((u64)(0x01cfa698c95390baU)),}, (strconv__Uint128){.lo = ((u64)(0x957912abd28dfc63U)),.hi = ((u64)(0x0121c81f7dd43a74U)),},
		(strconv__Uint128){.lo = ((u64)(0xbad75756c7317b7cU)),.hi = ((u64)(0x016a3a275d494911U)),}, (strconv__Uint128){.lo = ((u64)(0x298d2d2c78fdda5bU)),.hi = ((u64)(0x01c4c8b1349b9b56U)),}, (strconv__Uint128){.lo = ((u64)(0xd9f83c3bcb9ea879U)),.hi = ((u64)(0x011afd6ec0e14115U)),}, (strconv__Uint128){.lo = ((u64)(0x50764b4abe865297U)),.hi = ((u64)(0x0161bcca7119915bU)),}, (strconv__Uint128){.lo = ((u64)(0x2493de1d6e27e73dU)),.hi = ((u64)(0x01ba2bfd0d5ff5b2U)),}, (strconv__Uint128){.lo = ((u64)(0x56dc6ad264d8f086U)),.hi = ((u64)(0x01145b7e285bf98fU)),}, (strconv__Uint128){.lo = ((u64)(0x2c938586fe0f2ca8U)),.hi = ((u64)(0x0159725db272f7f3U)),}, (strconv__Uint128){.lo = ((u64)(0xf7b866e8bd92f7d2U)),.hi = ((u64)(0x01afcef51f0fb5efU)),},
		(strconv__Uint128){.lo = ((u64)(0xfad34051767bdae3U)),.hi = ((u64)(0x010de1593369d1b5U)),}, (strconv__Uint128){.lo = ((u64)(0x79881065d41ad19cU)),.hi = ((u64)(0x015159af80444623U)),}, (strconv__Uint128){.lo = ((u64)(0x57ea147f49218603U)),.hi = ((u64)(0x01a5b01b605557acU)),}, (strconv__Uint128){.lo = ((u64)(0xb6f24ccf8db4f3c1U)),.hi = ((u64)(0x01078e111c3556cbU)),}, (strconv__Uint128){.lo = ((u64)(0xa4aee003712230b2U)),.hi = ((u64)(0x014971956342ac7eU)),}, (strconv__Uint128){.lo = ((u64)(0x4dda98044d6abcdfU)),.hi = ((u64)(0x019bcdfabc13579eU)),}, (strconv__Uint128){.lo = ((u64)(0xf0a89f02b062b60bU)),.hi = ((u64)(0x010160bcb58c16c2U)),}, (strconv__Uint128){.lo = ((u64)(0xacd2c6c35c7b638eU)),.hi = ((u64)(0x0141b8ebe2ef1c73U)),},
		(strconv__Uint128){.lo = ((u64)(0x98077874339a3c71U)),.hi = ((u64)(0x01922726dbaae390U)),}, (strconv__Uint128){.lo = ((u64)(0xbe0956914080cb8eU)),.hi = ((u64)(0x01f6b0f092959c74U)),}, (strconv__Uint128){.lo = ((u64)(0xf6c5d61ac8507f38U)),.hi = ((u64)(0x013a2e965b9d81c8U)),}, (strconv__Uint128){.lo = ((u64)(0x34774ba17a649f07U)),.hi = ((u64)(0x0188ba3bf284e23bU)),}, (strconv__Uint128){.lo = ((u64)(0x01951e89d8fdc6c8U)),.hi = ((u64)(0x01eae8caef261acaU)),}, (strconv__Uint128){.lo = ((u64)(0x40fd3316279e9c3dU)),.hi = ((u64)(0x0132d17ed577d0beU)),}, (strconv__Uint128){.lo = ((u64)(0xd13c7fdbb186434cU)),.hi = ((u64)(0x017f85de8ad5c4edU)),}, (strconv__Uint128){.lo = ((u64)(0x458b9fd29de7d420U)),.hi = ((u64)(0x01df67562d8b3629U)),},
		(strconv__Uint128){.lo = ((u64)(0xcb7743e3a2b0e494U)),.hi = ((u64)(0x012ba095dc7701d9U)),}, (strconv__Uint128){.lo = ((u64)(0x3e5514dc8b5d1db9U)),.hi = ((u64)(0x017688bb5394c250U)),}, (strconv__Uint128){.lo = ((u64)(0x4dea5a13ae346527U)),.hi = ((u64)(0x01d42aea2879f2e4U)),}, (strconv__Uint128){.lo = ((u64)(0xb0b2784c4ce0bf38U)),.hi = ((u64)(0x01249ad2594c37ceU)),}, (strconv__Uint128){.lo = ((u64)(0x5cdf165f6018ef06U)),.hi = ((u64)(0x016dc186ef9f45c2U)),}, (strconv__Uint128){.lo = ((u64)(0xf416dbf7381f2ac8U)),.hi = ((u64)(0x01c931e8ab871732U)),}, (strconv__Uint128){.lo = ((u64)(0xd88e497a83137abdU)),.hi = ((u64)(0x011dbf316b346e7fU)),}, (strconv__Uint128){.lo = ((u64)(0xceb1dbd923d8596cU)),.hi = ((u64)(0x01652efdc6018a1fU)),},
		(strconv__Uint128){.lo = ((u64)(0xc25e52cf6cce6fc7U)),.hi = ((u64)(0x01be7abd3781eca7U)),}, (strconv__Uint128){.lo = ((u64)(0xd97af3c1a40105dcU)),.hi = ((u64)(0x01170cb642b133e8U)),}, (strconv__Uint128){.lo = ((u64)(0x0fd9b0b20d014754U)),.hi = ((u64)(0x015ccfe3d35d80e3U)),}, (strconv__Uint128){.lo = ((u64)(0xd3d01cde90419929U)),.hi = ((u64)(0x01b403dcc834e11bU)),}, (strconv__Uint128){.lo = ((u64)(0x6462120b1a28ffb9U)),.hi = ((u64)(0x01108269fd210cb1U)),}, (strconv__Uint128){.lo = ((u64)(0xbd7a968de0b33fa8U)),.hi = ((u64)(0x0154a3047c694fddU)),}, (strconv__Uint128){.lo = ((u64)(0x2cd93c3158e00f92U)),.hi = ((u64)(0x01a9cbc59b83a3d5U)),}, (strconv__Uint128){.lo = ((u64)(0x3c07c59ed78c09bbU)),.hi = ((u64)(0x010a1f5b81324665U)),},
		(strconv__Uint128){.lo = ((u64)(0x8b09b7068d6f0c2aU)),.hi = ((u64)(0x014ca732617ed7feU)),}, (strconv__Uint128){.lo = ((u64)(0x2dcc24c830cacf34U)),.hi = ((u64)(0x019fd0fef9de8dfeU)),}, (strconv__Uint128){.lo = ((u64)(0xdc9f96fd1e7ec180U)),.hi = ((u64)(0x0103e29f5c2b18beU)),}, (strconv__Uint128){.lo = ((u64)(0x93c77cbc661e71e1U)),.hi = ((u64)(0x0144db473335deeeU)),}, (strconv__Uint128){.lo = ((u64)(0x38b95beb7fa60e59U)),.hi = ((u64)(0x01961219000356aaU)),}, (strconv__Uint128){.lo = ((u64)(0xc6e7b2e65f8f91efU)),.hi = ((u64)(0x01fb969f40042c54U)),}, (strconv__Uint128){.lo = ((u64)(0xfc50cfcffbb9bb35U)),.hi = ((u64)(0x013d3e2388029bb4U)),}, (strconv__Uint128){.lo = ((u64)(0x3b6503c3faa82a03U)),.hi = ((u64)(0x018c8dac6a0342a2U)),},
		(strconv__Uint128){.lo = ((u64)(0xca3e44b4f9523484U)),.hi = ((u64)(0x01efb1178484134aU)),}, (strconv__Uint128){.lo = ((u64)(0xbe66eaf11bd360d2U)),.hi = ((u64)(0x0135ceaeb2d28c0eU)),}, (strconv__Uint128){.lo = ((u64)(0x6e00a5ad62c83907U)),.hi = ((u64)(0x0183425a5f872f12U)),}, (strconv__Uint128){.lo = ((u64)(0x0980cf18bb7a4749U)),.hi = ((u64)(0x01e412f0f768fad7U)),}, (strconv__Uint128){.lo = ((u64)(0x65f0816f752c6c8dU)),.hi = ((u64)(0x012e8bd69aa19cc6U)),}, (strconv__Uint128){.lo = ((u64)(0xff6ca1cb527787b1U)),.hi = ((u64)(0x017a2ecc414a03f7U)),}, (strconv__Uint128){.lo = ((u64)(0xff47ca3e2715699dU)),.hi = ((u64)(0x01d8ba7f519c84f5U)),}, (strconv__Uint128){.lo = ((u64)(0xbf8cde66d86d6202U)),.hi = ((u64)(0x0127748f9301d319U)),},
		(strconv__Uint128){.lo = ((u64)(0x2f7016008e88ba83U)),.hi = ((u64)(0x017151b377c247e0U)),}, (strconv__Uint128){.lo = ((u64)(0x3b4c1b80b22ae923U)),.hi = ((u64)(0x01cda62055b2d9d8U)),}, (strconv__Uint128){.lo = ((u64)(0x250f91306f5ad1b6U)),.hi = ((u64)(0x012087d4358fc827U)),}, (strconv__Uint128){.lo = ((u64)(0xee53757c8b318623U)),.hi = ((u64)(0x0168a9c942f3ba30U)),}, (strconv__Uint128){.lo = ((u64)(0x29e852dbadfde7acU)),.hi = ((u64)(0x01c2d43b93b0a8bdU)),}, (strconv__Uint128){.lo = ((u64)(0x3a3133c94cbeb0ccU)),.hi = ((u64)(0x0119c4a53c4e6976U)),}, (strconv__Uint128){.lo = ((u64)(0xc8bd80bb9fee5cffU)),.hi = ((u64)(0x016035ce8b6203d3U)),}, (strconv__Uint128){.lo = ((u64)(0xbaece0ea87e9f43eU)),.hi = ((u64)(0x01b843422e3a84c8U)),},
		(strconv__Uint128){.lo = ((u64)(0x74d40c9294f238a7U)),.hi = ((u64)(0x01132a095ce492fdU)),}, (strconv__Uint128){.lo = ((u64)(0xd2090fb73a2ec6d1U)),.hi = ((u64)(0x0157f48bb41db7bcU)),}, (strconv__Uint128){.lo = ((u64)(0x068b53a508ba7885U)),.hi = ((u64)(0x01adf1aea12525acU)),}, (strconv__Uint128){.lo = ((u64)(0x8417144725748b53U)),.hi = ((u64)(0x010cb70d24b7378bU)),}, (strconv__Uint128){.lo = ((u64)(0x651cd958eed1ae28U)),.hi = ((u64)(0x014fe4d06de5056eU)),}, (strconv__Uint128){.lo = ((u64)(0xfe640faf2a8619b2U)),.hi = ((u64)(0x01a3de04895e46c9U)),}, (strconv__Uint128){.lo = ((u64)(0x3efe89cd7a93d00fU)),.hi = ((u64)(0x01066ac2d5daec3eU)),}, (strconv__Uint128){.lo = ((u64)(0xcebe2c40d938c413U)),.hi = ((u64)(0x014805738b51a74dU)),},
		(strconv__Uint128){.lo = ((u64)(0x426db7510f86f518U)),.hi = ((u64)(0x019a06d06e261121U)),}, (strconv__Uint128){.lo = ((u64)(0xc9849292a9b4592fU)),.hi = ((u64)(0x0100444244d7cab4U)),}, (strconv__Uint128){.lo = ((u64)(0xfbe5b73754216f7aU)),.hi = ((u64)(0x01405552d60dbd61U)),}, (strconv__Uint128){.lo = ((u64)(0x7adf25052929cb59U)),.hi = ((u64)(0x01906aa78b912cbaU)),}, (strconv__Uint128){.lo = ((u64)(0x1996ee4673743e2fU)),.hi = ((u64)(0x01f485516e7577e9U)),}, (strconv__Uint128){.lo = ((u64)(0xaffe54ec0828a6ddU)),.hi = ((u64)(0x0138d352e5096af1U)),}, (strconv__Uint128){.lo = ((u64)(0x1bfdea270a32d095U)),.hi = ((u64)(0x018708279e4bc5aeU)),}, (strconv__Uint128){.lo = ((u64)(0xa2fd64b0ccbf84baU)),.hi = ((u64)(0x01e8ca3185deb719U)),},
		(strconv__Uint128){.lo = ((u64)(0x05de5eee7ff7b2f4U)),.hi = ((u64)(0x01317e5ef3ab3270U)),}, (strconv__Uint128){.lo = ((u64)(0x0755f6aa1ff59fb1U)),.hi = ((u64)(0x017dddf6b095ff0cU)),}, (strconv__Uint128){.lo = ((u64)(0x092b7454a7f3079eU)),.hi = ((u64)(0x01dd55745cbb7ecfU)),}, (strconv__Uint128){.lo = ((u64)(0x65bb28b4e8f7e4c3U)),.hi = ((u64)(0x012a5568b9f52f41U)),}, (strconv__Uint128){.lo = ((u64)(0xbf29f2e22335ddf3U)),.hi = ((u64)(0x0174eac2e8727b11U)),}, (strconv__Uint128){.lo = ((u64)(0x2ef46f9aac035570U)),.hi = ((u64)(0x01d22573a28f19d6U)),}, (strconv__Uint128){.lo = ((u64)(0xdd58c5c0ab821566U)),.hi = ((u64)(0x0123576845997025U)),}, (strconv__Uint128){.lo = ((u64)(0x54aef730d6629ac0U)),.hi = ((u64)(0x016c2d4256ffcc2fU)),},
		(strconv__Uint128){.lo = ((u64)(0x29dab4fd0bfb4170U)),.hi = ((u64)(0x01c73892ecbfbf3bU)),}, (strconv__Uint128){.lo = ((u64)(0xfa28b11e277d08e6U)),.hi = ((u64)(0x011c835bd3f7d784U)),}, (strconv__Uint128){.lo = ((u64)(0x38b2dd65b15c4b1fU)),.hi = ((u64)(0x0163a432c8f5cd66U)),}, (strconv__Uint128){.lo = ((u64)(0xc6df94bf1db35de7U)),.hi = ((u64)(0x01bc8d3f7b3340bfU)),}, (strconv__Uint128){.lo = ((u64)(0xdc4bbcf772901ab0U)),.hi = ((u64)(0x0115d847ad000877U)),}, (strconv__Uint128){.lo = ((u64)(0xd35eac354f34215cU)),.hi = ((u64)(0x015b4e5998400a95U)),}, (strconv__Uint128){.lo = ((u64)(0x48365742a30129b4U)),.hi = ((u64)(0x01b221effe500d3bU)),}, (strconv__Uint128){.lo = ((u64)(0x0d21f689a5e0ba10U)),.hi = ((u64)(0x010f5535fef20845U)),},
		(strconv__Uint128){.lo = ((u64)(0x506a742c0f58e894U)),.hi = ((u64)(0x01532a837eae8a56U)),}, (strconv__Uint128){.lo = ((u64)(0xe4851137132f22b9U)),.hi = ((u64)(0x01a7f5245e5a2cebU)),}, (strconv__Uint128){.lo = ((u64)(0x6ed32ac26bfd75b4U)),.hi = ((u64)(0x0108f936baf85c13U)),}, (strconv__Uint128){.lo = ((u64)(0x4a87f57306fcd321U)),.hi = ((u64)(0x014b378469b67318U)),}, (strconv__Uint128){.lo = ((u64)(0x5d29f2cfc8bc07e9U)),.hi = ((u64)(0x019e056584240fdeU)),}, (strconv__Uint128){.lo = ((u64)(0xfa3a37c1dd7584f1U)),.hi = ((u64)(0x0102c35f729689eaU)),}, (strconv__Uint128){.lo = ((u64)(0xb8c8c5b254d2e62eU)),.hi = ((u64)(0x014374374f3c2c65U)),}, (strconv__Uint128){.lo = ((u64)(0x26faf71eea079fb9U)),.hi = ((u64)(0x01945145230b377fU)),},
		(strconv__Uint128){.lo = ((u64)(0xf0b9b4e6a48987a8U)),.hi = ((u64)(0x01f965966bce055eU)),}, (strconv__Uint128){.lo = ((u64)(0x5674111026d5f4c9U)),.hi = ((u64)(0x013bdf7e0360c35bU)),}, (strconv__Uint128){.lo = ((u64)(0x2c111554308b71fbU)),.hi = ((u64)(0x018ad75d8438f432U)),}, (strconv__Uint128){.lo = ((u64)(0xb7155aa93cae4e7aU)),.hi = ((u64)(0x01ed8d34e547313eU)),}, (strconv__Uint128){.lo = ((u64)(0x326d58a9c5ecf10cU)),.hi = ((u64)(0x013478410f4c7ec7U)),}, (strconv__Uint128){.lo = ((u64)(0xff08aed437682d4fU)),.hi = ((u64)(0x01819651531f9e78U)),}, (strconv__Uint128){.lo = ((u64)(0x3ecada89454238a3U)),.hi = ((u64)(0x01e1fbe5a7e78617U)),}, (strconv__Uint128){.lo = ((u64)(0x873ec895cb496366U)),.hi = ((u64)(0x012d3d6f88f0b3ceU)),},
		(strconv__Uint128){.lo = ((u64)(0x290e7abb3e1bbc3fU)),.hi = ((u64)(0x01788ccb6b2ce0c2U)),}, (strconv__Uint128){.lo = ((u64)(0xb352196a0da2ab4fU)),.hi = ((u64)(0x01d6affe45f818f2U)),}, (strconv__Uint128){.lo = ((u64)(0xb0134fe24885ab11U)),.hi = ((u64)(0x01262dfeebbb0f97U)),}, (strconv__Uint128){.lo = ((u64)(0x9c1823dadaa715d6U)),.hi = ((u64)(0x016fb97ea6a9d37dU)),}, (strconv__Uint128){.lo = ((u64)(0x031e2cd19150db4bU)),.hi = ((u64)(0x01cba7de5054485dU)),}, (strconv__Uint128){.lo = ((u64)(0x21f2dc02fad2890fU)),.hi = ((u64)(0x011f48eaf234ad3aU)),}, (strconv__Uint128){.lo = ((u64)(0xaa6f9303b9872b53U)),.hi = ((u64)(0x01671b25aec1d888U)),}, (strconv__Uint128){.lo = ((u64)(0xd50b77c4a7e8f628U)),.hi = ((u64)(0x01c0e1ef1a724eaaU)),},
		(strconv__Uint128){.lo = ((u64)(0xc5272adae8f199d9U)),.hi = ((u64)(0x01188d357087712aU)),}, (strconv__Uint128){.lo = ((u64)(0x7670f591a32e004fU)),.hi = ((u64)(0x015eb082cca94d75U)),}, (strconv__Uint128){.lo = ((u64)(0xd40d32f60bf98063U)),.hi = ((u64)(0x01b65ca37fd3a0d2U)),}, (strconv__Uint128){.lo = ((u64)(0xc4883fd9c77bf03eU)),.hi = ((u64)(0x0111f9e62fe44483U)),}, (strconv__Uint128){.lo = ((u64)(0xb5aa4fd0395aec4dU)),.hi = ((u64)(0x0156785fbbdd55a4U)),}, (strconv__Uint128){.lo = ((u64)(0xe314e3c447b1a760U)),.hi = ((u64)(0x01ac1677aad4ab0dU)),}, (strconv__Uint128){.lo = ((u64)(0xaded0e5aaccf089cU)),.hi = ((u64)(0x010b8e0acac4eae8U)),}, (strconv__Uint128){.lo = ((u64)(0xd96851f15802cac3U)),.hi = ((u64)(0x014e718d7d7625a2U)),},
		(strconv__Uint128){.lo = ((u64)(0x8fc2666dae037d74U)),.hi = ((u64)(0x01a20df0dcd3af0bU)),}, (strconv__Uint128){.lo = ((u64)(0x39d980048cc22e68U)),.hi = ((u64)(0x010548b68a044d67U)),}, (strconv__Uint128){.lo = ((u64)(0x084fe005aff2ba03U)),.hi = ((u64)(0x01469ae42c8560c1U)),}, (strconv__Uint128){.lo = ((u64)(0x4a63d8071bef6883U)),.hi = ((u64)(0x0198419d37a6b8f1U)),}, (strconv__Uint128){.lo = ((u64)(0x9cfcce08e2eb42a4U)),.hi = ((u64)(0x01fe52048590672dU)),}, (strconv__Uint128){.lo = ((u64)(0x821e00c58dd309a7U)),.hi = ((u64)(0x013ef342d37a407cU)),}, (strconv__Uint128){.lo = ((u64)(0xa2a580f6f147cc10U)),.hi = ((u64)(0x018eb0138858d09bU)),}, (strconv__Uint128){.lo = ((u64)(0x8b4ee134ad99bf15U)),.hi = ((u64)(0x01f25c186a6f04c2U)),},
		(strconv__Uint128){.lo = ((u64)(0x97114cc0ec80176dU)),.hi = ((u64)(0x0137798f428562f9U)),}, (strconv__Uint128){.lo = ((u64)(0xfcd59ff127a01d48U)),.hi = ((u64)(0x018557f31326bbb7U)),}, (strconv__Uint128){.lo = ((u64)(0xfc0b07ed7188249aU)),.hi = ((u64)(0x01e6adefd7f06aa5U)),}, (strconv__Uint128){.lo = ((u64)(0xbd86e4f466f516e0U)),.hi = ((u64)(0x01302cb5e6f642a7U)),}, (strconv__Uint128){.lo = ((u64)(0xace89e3180b25c98U)),.hi = ((u64)(0x017c37e360b3d351U)),}, (strconv__Uint128){.lo = ((u64)(0x1822c5bde0def3beU)),.hi = ((u64)(0x01db45dc38e0c826U)),}, (strconv__Uint128){.lo = ((u64)(0xcf15bb96ac8b5857U)),.hi = ((u64)(0x01290ba9a38c7d17U)),}, (strconv__Uint128){.lo = ((u64)(0xc2db2a7c57ae2e6dU)),.hi = ((u64)(0x01734e940c6f9c5dU)),},
		(strconv__Uint128){.lo = ((u64)(0x3391f51b6d99ba08U)),.hi = ((u64)(0x01d022390f8b8375U)),}, (strconv__Uint128){.lo = ((u64)(0x403b393124801445U)),.hi = ((u64)(0x01221563a9b73229U)),}, (strconv__Uint128){.lo = ((u64)(0x904a077d6da01956U)),.hi = ((u64)(0x016a9abc9424feb3U)),}, (strconv__Uint128){.lo = ((u64)(0x745c895cc9081facU)),.hi = ((u64)(0x01c5416bb92e3e60U)),}, (strconv__Uint128){.lo = ((u64)(0x48b9d5d9fda513cbU)),.hi = ((u64)(0x011b48e353bce6fcU)),}, (strconv__Uint128){.lo = ((u64)(0x5ae84b507d0e58beU)),.hi = ((u64)(0x01621b1c28ac20bbU)),}, (strconv__Uint128){.lo = ((u64)(0x31a25e249c51eeeeU)),.hi = ((u64)(0x01baa1e332d728eaU)),}, (strconv__Uint128){.lo = ((u64)(0x5f057ad6e1b33554U)),.hi = ((u64)(0x0114a52dffc67992U)),},
		(strconv__Uint128){.lo = ((u64)(0xf6c6d98c9a2002aaU)),.hi = ((u64)(0x0159ce797fb817f6U)),}, (strconv__Uint128){.lo = ((u64)(0xb4788fefc0a80354U)),.hi = ((u64)(0x01b04217dfa61df4U)),}, (strconv__Uint128){.lo = ((u64)(0xf0cb59f5d8690214U)),.hi = ((u64)(0x010e294eebc7d2b8U)),}, (strconv__Uint128){.lo = ((u64)(0x2cfe30734e83429aU)),.hi = ((u64)(0x0151b3a2a6b9c767U)),}, (strconv__Uint128){.lo = ((u64)(0xf83dbc9022241340U)),.hi = ((u64)(0x01a6208b50683940U)),}, (strconv__Uint128){.lo = ((u64)(0x9b2695da15568c08U)),.hi = ((u64)(0x0107d457124123c8U)),}, (strconv__Uint128){.lo = ((u64)(0xc1f03b509aac2f0aU)),.hi = ((u64)(0x0149c96cd6d16cbaU)),}, (strconv__Uint128){.lo = ((u64)(0x726c4a24c1573acdU)),.hi = ((u64)(0x019c3bc80c85c7e9U)),},
		(strconv__Uint128){.lo = ((u64)(0xe783ae56f8d684c0U)),.hi = ((u64)(0x0101a55d07d39cf1U)),}, (strconv__Uint128){.lo = ((u64)(0x616499ecb70c25f0U)),.hi = ((u64)(0x01420eb449c8842eU)),}, (strconv__Uint128){.lo = ((u64)(0xf9bdc067e4cf2f6cU)),.hi = ((u64)(0x019292615c3aa539U)),}, (strconv__Uint128){.lo = ((u64)(0x782d3081de02fb47U)),.hi = ((u64)(0x01f736f9b3494e88U)),}, (strconv__Uint128){.lo = ((u64)(0x4b1c3e512ac1dd0cU)),.hi = ((u64)(0x013a825c100dd115U)),}, (strconv__Uint128){.lo = ((u64)(0x9de34de57572544fU)),.hi = ((u64)(0x018922f31411455aU)),}, (strconv__Uint128){.lo = ((u64)(0x455c215ed2cee963U)),.hi = ((u64)(0x01eb6bafd91596b1U)),}, (strconv__Uint128){.lo = ((u64)(0xcb5994db43c151deU)),.hi = ((u64)(0x0133234de7ad7e2eU)),},
		(strconv__Uint128){.lo = ((u64)(0x7e2ffa1214b1a655U)),.hi = ((u64)(0x017fec216198ddbaU)),}, (strconv__Uint128){.lo = ((u64)(0x1dbbf89699de0febU)),.hi = ((u64)(0x01dfe729b9ff1529U)),}, (strconv__Uint128){.lo = ((u64)(0xb2957b5e202ac9f3U)),.hi = ((u64)(0x012bf07a143f6d39U)),}, (strconv__Uint128){.lo = ((u64)(0x1f3ada35a8357c6fU)),.hi = ((u64)(0x0176ec98994f4888U)),}, (strconv__Uint128){.lo = ((u64)(0x270990c31242db8bU)),.hi = ((u64)(0x01d4a7bebfa31aaaU)),}, (strconv__Uint128){.lo = ((u64)(0x5865fa79eb69c937U)),.hi = ((u64)(0x0124e8d737c5f0aaU)),}, (strconv__Uint128){.lo = ((u64)(0xee7f791866443b85U)),.hi = ((u64)(0x016e230d05b76cd4U)),}, (strconv__Uint128){.lo = ((u64)(0x2a1f575e7fd54a66U)),.hi = ((u64)(0x01c9abd04725480aU)),},
		(strconv__Uint128){.lo = ((u64)(0x5a53969b0fe54e80U)),.hi = ((u64)(0x011e0b622c774d06U)),}, (strconv__Uint128){.lo = ((u64)(0xf0e87c41d3dea220U)),.hi = ((u64)(0x01658e3ab7952047U)),}, (strconv__Uint128){.lo = ((u64)(0xed229b5248d64aa8U)),.hi = ((u64)(0x01bef1c9657a6859U)),}, (strconv__Uint128){.lo = ((u64)(0x3435a1136d85eea9U)),.hi = ((u64)(0x0117571ddf6c8138U)),}, (strconv__Uint128){.lo = ((u64)(0x4143095848e76a53U)),.hi = ((u64)(0x015d2ce55747a186U)),}, (strconv__Uint128){.lo = ((u64)(0xd193cbae5b2144e8U)),.hi = ((u64)(0x01b4781ead1989e7U)),}, (strconv__Uint128){.lo = ((u64)(0xe2fc5f4cf8f4cb11U)),.hi = ((u64)(0x0110cb132c2ff630U)),}, (strconv__Uint128){.lo = ((u64)(0x1bbb77203731fdd5U)),.hi = ((u64)(0x0154fdd7f73bf3bdU)),},
		(strconv__Uint128){.lo = ((u64)(0x62aa54e844fe7d4aU)),.hi = ((u64)(0x01aa3d4df50af0acU)),}, (strconv__Uint128){.lo = ((u64)(0xbdaa75112b1f0e4eU)),.hi = ((u64)(0x010a6650b926d66bU)),}, (strconv__Uint128){.lo = ((u64)(0xad15125575e6d1e2U)),.hi = ((u64)(0x014cffe4e7708c06U)),}, (strconv__Uint128){.lo = ((u64)(0x585a56ead360865bU)),.hi = ((u64)(0x01a03fde214caf08U)),}, (strconv__Uint128){.lo = ((u64)(0x37387652c41c53f8U)),.hi = ((u64)(0x010427ead4cfed65U)),}, (strconv__Uint128){.lo = ((u64)(0x850693e7752368f7U)),.hi = ((u64)(0x014531e58a03e8beU)),}, (strconv__Uint128){.lo = ((u64)(0x264838e1526c4334U)),.hi = ((u64)(0x01967e5eec84e2eeU)),}, (strconv__Uint128){.lo = ((u64)(0xafda4719a7075402U)),.hi = ((u64)(0x01fc1df6a7a61ba9U)),},
		(strconv__Uint128){.lo = ((u64)(0x0de86c7008649481U)),.hi = ((u64)(0x013d92ba28c7d14aU)),}, (strconv__Uint128){.lo = ((u64)(0x9162878c0a7db9a1U)),.hi = ((u64)(0x018cf768b2f9c59cU)),}, (strconv__Uint128){.lo = ((u64)(0xb5bb296f0d1d280aU)),.hi = ((u64)(0x01f03542dfb83703U)),}, (strconv__Uint128){.lo = ((u64)(0x5194f9e568323906U)),.hi = ((u64)(0x01362149cbd32262U)),}, (strconv__Uint128){.lo = ((u64)(0xe5fa385ec23ec747U)),.hi = ((u64)(0x0183a99c3ec7eafaU)),}, (strconv__Uint128){.lo = ((u64)(0x9f78c67672ce7919U)),.hi = ((u64)(0x01e494034e79e5b9U)),}, (strconv__Uint128){.lo = ((u64)(0x03ab7c0a07c10bb0U)),.hi = ((u64)(0x012edc82110c2f94U)),}, (strconv__Uint128){.lo = ((u64)(0x04965b0c89b14e9cU)),.hi = ((u64)(0x017a93a2954f3b79U)),},
		(strconv__Uint128){.lo = ((u64)(0x45bbf1cfac1da243U)),.hi = ((u64)(0x01d9388b3aa30a57U)),}, (strconv__Uint128){.lo = ((u64)(0x8b957721cb92856aU)),.hi = ((u64)(0x0127c35704a5e676U)),}, (strconv__Uint128){.lo = ((u64)(0x2e7ad4ea3e7726c4U)),.hi = ((u64)(0x0171b42cc5cf6014U)),}, (strconv__Uint128){.lo = ((u64)(0x3a198a24ce14f075U)),.hi = ((u64)(0x01ce2137f7433819U)),}, (strconv__Uint128){.lo = ((u64)(0xc44ff65700cd1649U)),.hi = ((u64)(0x0120d4c2fa8a030fU)),}, (strconv__Uint128){.lo = ((u64)(0xb563f3ecc1005bdbU)),.hi = ((u64)(0x016909f3b92c83d3U)),}, (strconv__Uint128){.lo = ((u64)(0xa2bcf0e7f14072d2U)),.hi = ((u64)(0x01c34c70a777a4c8U)),}, (strconv__Uint128){.lo = ((u64)(0x65b61690f6c847c3U)),.hi = ((u64)(0x011a0fc668aac6fdU)),},
		(strconv__Uint128){.lo = ((u64)(0xbf239c35347a59b4U)),.hi = ((u64)(0x016093b802d578bcU)),}, (strconv__Uint128){.lo = ((u64)(0xeeec83428198f021U)),.hi = ((u64)(0x01b8b8a6038ad6ebU)),}, (strconv__Uint128){.lo = ((u64)(0x7553d20990ff9615U)),.hi = ((u64)(0x01137367c236c653U)),}, (strconv__Uint128){.lo = ((u64)(0x52a8c68bf53f7b9aU)),.hi = ((u64)(0x01585041b2c477e8U)),}, (strconv__Uint128){.lo = ((u64)(0x6752f82ef28f5a81U)),.hi = ((u64)(0x01ae64521f7595e2U)),}, (strconv__Uint128){.lo = ((u64)(0x8093db1d57999890U)),.hi = ((u64)(0x010cfeb353a97dadU)),}, (strconv__Uint128){.lo = ((u64)(0xe0b8d1e4ad7ffeb4U)),.hi = ((u64)(0x01503e602893dd18U)),}, (strconv__Uint128){.lo = ((u64)(0x18e7065dd8dffe62U)),.hi = ((u64)(0x01a44df832b8d45fU)),},
		(strconv__Uint128){.lo = ((u64)(0x6f9063faa78bfefdU)),.hi = ((u64)(0x0106b0bb1fb384bbU)),}, (strconv__Uint128){.lo = ((u64)(0x4b747cf9516efebcU)),.hi = ((u64)(0x01485ce9e7a065eaU)),}, (strconv__Uint128){.lo = ((u64)(0xde519c37a5cabe6bU)),.hi = ((u64)(0x019a742461887f64U)),}, (strconv__Uint128){.lo = ((u64)(0x0af301a2c79eb703U)),.hi = ((u64)(0x01008896bcf54f9fU)),}, (strconv__Uint128){.lo = ((u64)(0xcdafc20b798664c4U)),.hi = ((u64)(0x0140aabc6c32a386U)),}, (strconv__Uint128){.lo = ((u64)(0x811bb28e57e7fdf5U)),.hi = ((u64)(0x0190d56b873f4c68U)),}, (strconv__Uint128){.lo = ((u64)(0xa1629f31ede1fd72U)),.hi = ((u64)(0x01f50ac6690f1f82U)),}, (strconv__Uint128){.lo = ((u64)(0xa4dda37f34ad3e67U)),.hi = ((u64)(0x013926bc01a973b1U)),},
		(strconv__Uint128){.lo = ((u64)(0x0e150c5f01d88e01U)),.hi = ((u64)(0x0187706b0213d09eU)),}, (strconv__Uint128){.lo = ((u64)(0x919a4f76c24eb181U)),.hi = ((u64)(0x01e94c85c298c4c5U)),}, (strconv__Uint128){.lo = ((u64)(0x7b0071aa39712ef1U)),.hi = ((u64)(0x0131cfd3999f7afbU)),}, (strconv__Uint128){.lo = ((u64)(0x59c08e14c7cd7aadU)),.hi = ((u64)(0x017e43c8800759baU)),}, (strconv__Uint128){.lo = ((u64)(0xf030b199f9c0d958U)),.hi = ((u64)(0x01ddd4baa0093028U)),}, (strconv__Uint128){.lo = ((u64)(0x961e6f003c1887d7U)),.hi = ((u64)(0x012aa4f4a405be19U)),}, (strconv__Uint128){.lo = ((u64)(0xfba60ac04b1ea9cdU)),.hi = ((u64)(0x01754e31cd072d9fU)),}, (strconv__Uint128){.lo = ((u64)(0xfa8f8d705de65440U)),.hi = ((u64)(0x01d2a1be4048f907U)),},
		(strconv__Uint128){.lo = ((u64)(0xfc99b8663aaff4a8U)),.hi = ((u64)(0x0123a516e82d9ba4U)),}, (strconv__Uint128){.lo = ((u64)(0x3bc0267fc95bf1d2U)),.hi = ((u64)(0x016c8e5ca239028eU)),}, (strconv__Uint128){.lo = ((u64)(0xcab0301fbbb2ee47U)),.hi = ((u64)(0x01c7b1f3cac74331U)),}, (strconv__Uint128){.lo = ((u64)(0x1eae1e13d54fd4ecU)),.hi = ((u64)(0x011ccf385ebc89ffU)),}, (strconv__Uint128){.lo = ((u64)(0xe659a598caa3ca27U)),.hi = ((u64)(0x01640306766bac7eU)),}, (strconv__Uint128){.lo = ((u64)(0x9ff00efefd4cbcb1U)),.hi = ((u64)(0x01bd03c81406979eU)),}, (strconv__Uint128){.lo = ((u64)(0x23f6095f5e4ff5efU)),.hi = ((u64)(0x0116225d0c841ec3U)),}, (strconv__Uint128){.lo = ((u64)(0xecf38bb735e3f36aU)),.hi = ((u64)(0x015baaf44fa52673U)),},
		(strconv__Uint128){.lo = ((u64)(0xe8306ea5035cf045U)),.hi = ((u64)(0x01b295b1638e7010U)),}, (strconv__Uint128){.lo = ((u64)(0x911e4527221a162bU)),.hi = ((u64)(0x010f9d8ede39060aU)),}, (strconv__Uint128){.lo = ((u64)(0x3565d670eaa09bb6U)),.hi = ((u64)(0x015384f295c7478dU)),}, (strconv__Uint128){.lo = ((u64)(0x82bf4c0d2548c2a3U)),.hi = ((u64)(0x01a8662f3b391970U)),}, (strconv__Uint128){.lo = ((u64)(0x51b78f88374d79a6U)),.hi = ((u64)(0x01093fdd8503afe6U)),}, (strconv__Uint128){.lo = ((u64)(0xe625736a4520d810U)),.hi = ((u64)(0x014b8fd4e6449bdfU)),}, (strconv__Uint128){.lo = ((u64)(0xdfaed044d6690e14U)),.hi = ((u64)(0x019e73ca1fd5c2d7U)),}, (strconv__Uint128){.lo = ((u64)(0xebcd422b0601a8ccU)),.hi = ((u64)(0x0103085e53e599c6U)),},
		(strconv__Uint128){.lo = ((u64)(0xa6c092b5c78212ffU)),.hi = ((u64)(0x0143ca75e8df0038U)),}, (strconv__Uint128){.lo = ((u64)(0xd070b763396297bfU)),.hi = ((u64)(0x0194bd136316c046U)),}, (strconv__Uint128){.lo = ((u64)(0x848ce53c07bb3dafU)),.hi = ((u64)(0x01f9ec583bdc7058U)),}, (strconv__Uint128){.lo = ((u64)(0x52d80f4584d5068dU)),.hi = ((u64)(0x013c33b72569c637U)),}, (strconv__Uint128){.lo = ((u64)(0x278e1316e60a4831U)),.hi = ((u64)(0x018b40a4eec437c5U)),}}));
	_const_strconv__pow5_inv_split_64 = new_array_from_c_array(292, 292, sizeof(strconv__Uint128), _MOV((strconv__Uint128[292]){
		(strconv__Uint128){.lo = ((u64)(0x0000000000000001U)),.hi = ((u64)(0x0400000000000000U)),}, (strconv__Uint128){.lo = ((u64)(0x3333333333333334U)),.hi = ((u64)(0x0333333333333333U)),}, (strconv__Uint128){.lo = ((u64)(0x28f5c28f5c28f5c3U)),.hi = ((u64)(0x028f5c28f5c28f5cU)),}, (strconv__Uint128){.lo = ((u64)(0xed916872b020c49cU)),.hi = ((u64)(0x020c49ba5e353f7cU)),}, (strconv__Uint128){.lo = ((u64)(0xaf4f0d844d013a93U)),.hi = ((u64)(0x0346dc5d63886594U)),}, (strconv__Uint128){.lo = ((u64)(0x8c3f3e0370cdc876U)),.hi = ((u64)(0x029f16b11c6d1e10U)),}, (strconv__Uint128){.lo = ((u64)(0xd698fe69270b06c5U)),.hi = ((u64)(0x0218def416bdb1a6U)),}, (strconv__Uint128){.lo = ((u64)(0xf0f4ca41d811a46eU)),.hi = ((u64)(0x035afe535795e90aU)),}, (strconv__Uint128){.lo = ((u64)(0xf3f70834acdae9f1U)),.hi = ((u64)(0x02af31dc4611873bU)),},
		(strconv__Uint128){.lo = ((u64)(0x5cc5a02a23e254c1U)),.hi = ((u64)(0x0225c17d04dad296U)),}, (strconv__Uint128){.lo = ((u64)(0xfad5cd10396a2135U)),.hi = ((u64)(0x036f9bfb3af7b756U)),}, (strconv__Uint128){.lo = ((u64)(0xfbde3da69454e75eU)),.hi = ((u64)(0x02bfaffc2f2c92abU)),}, (strconv__Uint128){.lo = ((u64)(0x2fe4fe1edd10b918U)),.hi = ((u64)(0x0232f33025bd4223U)),}, (strconv__Uint128){.lo = ((u64)(0x4ca19697c81ac1bfU)),.hi = ((u64)(0x0384b84d092ed038U)),}, (strconv__Uint128){.lo = ((u64)(0x3d4e1213067bce33U)),.hi = ((u64)(0x02d09370d4257360U)),}, (strconv__Uint128){.lo = ((u64)(0x643e74dc052fd829U)),.hi = ((u64)(0x024075f3dceac2b3U)),}, (strconv__Uint128){.lo = ((u64)(0x6d30baf9a1e626a7U)),.hi = ((u64)(0x039a5652fb113785U)),},
		(strconv__Uint128){.lo = ((u64)(0x2426fbfae7eb5220U)),.hi = ((u64)(0x02e1dea8c8da92d1U)),}, (strconv__Uint128){.lo = ((u64)(0x1cebfcc8b9890e80U)),.hi = ((u64)(0x024e4bba3a487574U)),}, (strconv__Uint128){.lo = ((u64)(0x94acc7a78f41b0ccU)),.hi = ((u64)(0x03b07929f6da5586U)),}, (strconv__Uint128){.lo = ((u64)(0xaa23d2ec729af3d7U)),.hi = ((u64)(0x02f394219248446bU)),}, (strconv__Uint128){.lo = ((u64)(0xbb4fdbf05baf2979U)),.hi = ((u64)(0x025c768141d369efU)),}, (strconv__Uint128){.lo = ((u64)(0xc54c931a2c4b758dU)),.hi = ((u64)(0x03c7240202ebdcb2U)),}, (strconv__Uint128){.lo = ((u64)(0x9dd6dc14f03c5e0bU)),.hi = ((u64)(0x0305b66802564a28U)),}, (strconv__Uint128){.lo = ((u64)(0x4b1249aa59c9e4d6U)),.hi = ((u64)(0x026af8533511d4edU)),},
		(strconv__Uint128){.lo = ((u64)(0x44ea0f76f60fd489U)),.hi = ((u64)(0x03de5a1ebb4fbb15U)),}, (strconv__Uint128){.lo = ((u64)(0x6a54d92bf80caa07U)),.hi = ((u64)(0x0318481895d96277U)),}, (strconv__Uint128){.lo = ((u64)(0x21dd7a89933d54d2U)),.hi = ((u64)(0x0279d346de4781f9U)),}, (strconv__Uint128){.lo = ((u64)(0x362f2a75b8622150U)),.hi = ((u64)(0x03f61ed7ca0c0328U)),}, (strconv__Uint128){.lo = ((u64)(0xf825bb91604e810dU)),.hi = ((u64)(0x032b4bdfd4d668ecU)),}, (strconv__Uint128){.lo = ((u64)(0xc684960de6a5340bU)),.hi = ((u64)(0x0289097fdd7853f0U)),}, (strconv__Uint128){.lo = ((u64)(0xd203ab3e521dc33cU)),.hi = ((u64)(0x02073accb12d0ff3U)),}, (strconv__Uint128){.lo = ((u64)(0xe99f7863b696052cU)),.hi = ((u64)(0x033ec47ab514e652U)),},
		(strconv__Uint128){.lo = ((u64)(0x87b2c6b62bab3757U)),.hi = ((u64)(0x02989d2ef743eb75U)),}, (strconv__Uint128){.lo = ((u64)(0xd2f56bc4efbc2c45U)),.hi = ((u64)(0x0213b0f25f69892aU)),}, (strconv__Uint128){.lo = ((u64)(0x1e55793b192d13a2U)),.hi = ((u64)(0x0352b4b6ff0f41deU)),}, (strconv__Uint128){.lo = ((u64)(0x4b77942f475742e8U)),.hi = ((u64)(0x02a8909265a5ce4bU)),}, (strconv__Uint128){.lo = ((u64)(0xd5f9435905df68baU)),.hi = ((u64)(0x022073a8515171d5U)),}, (strconv__Uint128){.lo = ((u64)(0x565b9ef4d6324129U)),.hi = ((u64)(0x03671f73b54f1c89U)),}, (strconv__Uint128){.lo = ((u64)(0xdeafb25d78283421U)),.hi = ((u64)(0x02b8e5f62aa5b06dU)),}, (strconv__Uint128){.lo = ((u64)(0x188c8eb12cecf681U)),.hi = ((u64)(0x022d84c4eeeaf38bU)),},
		(strconv__Uint128){.lo = ((u64)(0x8dadb11b7b14bd9bU)),.hi = ((u64)(0x037c07a17e44b8deU)),}, (strconv__Uint128){.lo = ((u64)(0x7157c0e2c8dd647cU)),.hi = ((u64)(0x02c99fb46503c718U)),}, (strconv__Uint128){.lo = ((u64)(0x8ddfcd823a4ab6caU)),.hi = ((u64)(0x023ae629ea696c13U)),}, (strconv__Uint128){.lo = ((u64)(0x1632e269f6ddf142U)),.hi = ((u64)(0x0391704310a8acecU)),}, (strconv__Uint128){.lo = ((u64)(0x44f581ee5f17f435U)),.hi = ((u64)(0x02dac035a6ed5723U)),}, (strconv__Uint128){.lo = ((u64)(0x372ace584c1329c4U)),.hi = ((u64)(0x024899c4858aac1cU)),}, (strconv__Uint128){.lo = ((u64)(0xbeaae3c079b842d3U)),.hi = ((u64)(0x03a75c6da27779c6U)),}, (strconv__Uint128){.lo = ((u64)(0x6555830061603576U)),.hi = ((u64)(0x02ec49f14ec5fb05U)),},
		(strconv__Uint128){.lo = ((u64)(0xb7779c004de6912bU)),.hi = ((u64)(0x0256a18dd89e626aU)),}, (strconv__Uint128){.lo = ((u64)(0xf258f99a163db512U)),.hi = ((u64)(0x03bdcf495a9703ddU)),}, (strconv__Uint128){.lo = ((u64)(0x5b7a614811caf741U)),.hi = ((u64)(0x02fe3f6de212697eU)),}, (strconv__Uint128){.lo = ((u64)(0xaf951aa00e3bf901U)),.hi = ((u64)(0x0264ff8b1b41edfeU)),}, (strconv__Uint128){.lo = ((u64)(0x7f54f7667d2cc19bU)),.hi = ((u64)(0x03d4cc11c5364997U)),}, (strconv__Uint128){.lo = ((u64)(0x32aa5f8530f09ae3U)),.hi = ((u64)(0x0310a3416a91d479U)),}, (strconv__Uint128){.lo = ((u64)(0xf55519375a5a1582U)),.hi = ((u64)(0x0273b5cdeedb1060U)),}, (strconv__Uint128){.lo = ((u64)(0xbbbb5b8bc3c3559dU)),.hi = ((u64)(0x03ec56164af81a34U)),},
		(strconv__Uint128){.lo = ((u64)(0x2fc916096969114aU)),.hi = ((u64)(0x03237811d593482aU)),}, (strconv__Uint128){.lo = ((u64)(0x596dab3ababa743cU)),.hi = ((u64)(0x0282c674aadc39bbU)),}, (strconv__Uint128){.lo = ((u64)(0x478aef622efb9030U)),.hi = ((u64)(0x0202385d557cfafcU)),}, (strconv__Uint128){.lo = ((u64)(0xd8de4bd04b2c19e6U)),.hi = ((u64)(0x0336c0955594c4c6U)),}, (strconv__Uint128){.lo = ((u64)(0xad7ea30d08f014b8U)),.hi = ((u64)(0x029233aaaadd6a38U)),}, (strconv__Uint128){.lo = ((u64)(0x24654f3da0c01093U)),.hi = ((u64)(0x020e8fbbbbe454faU)),}, (strconv__Uint128){.lo = ((u64)(0x3a3bb1fc346680ebU)),.hi = ((u64)(0x034a7f92c63a2190U)),}, (strconv__Uint128){.lo = ((u64)(0x94fc8e635d1ecd89U)),.hi = ((u64)(0x02a1ffa89e94e7a6U)),},
		(strconv__Uint128){.lo = ((u64)(0xaa63a51c4a7f0ad4U)),.hi = ((u64)(0x021b32ed4baa52ebU)),}, (strconv__Uint128){.lo = ((u64)(0xdd6c3b607731aaedU)),.hi = ((u64)(0x035eb7e212aa1e45U)),}, (strconv__Uint128){.lo = ((u64)(0x1789c919f8f488bdU)),.hi = ((u64)(0x02b22cb4dbbb4b6bU)),}, (strconv__Uint128){.lo = ((u64)(0xac6e3a7b2d906d64U)),.hi = ((u64)(0x022823c3e2fc3c55U)),}, (strconv__Uint128){.lo = ((u64)(0x13e390c515b3e23aU)),.hi = ((u64)(0x03736c6c9e606089U)),}, (strconv__Uint128){.lo = ((u64)(0xdcb60d6a77c31b62U)),.hi = ((u64)(0x02c2bd23b1e6b3a0U)),}, (strconv__Uint128){.lo = ((u64)(0x7d5e7121f968e2b5U)),.hi = ((u64)(0x0235641c8e52294dU)),}, (strconv__Uint128){.lo = ((u64)(0xc8971b698f0e3787U)),.hi = ((u64)(0x0388a02db0837548U)),},
		(strconv__Uint128){.lo = ((u64)(0xa078e2bad8d82c6cU)),.hi = ((u64)(0x02d3b357c0692aa0U)),}, (strconv__Uint128){.lo = ((u64)(0xe6c71bc8ad79bd24U)),.hi = ((u64)(0x0242f5dfcd20eee6U)),}, (strconv__Uint128){.lo = ((u64)(0x0ad82c7448c2c839U)),.hi = ((u64)(0x039e5632e1ce4b0bU)),}, (strconv__Uint128){.lo = ((u64)(0x3be023903a356cfaU)),.hi = ((u64)(0x02e511c24e3ea26fU)),}, (strconv__Uint128){.lo = ((u64)(0x2fe682d9c82abd95U)),.hi = ((u64)(0x0250db01d8321b8cU)),}, (strconv__Uint128){.lo = ((u64)(0x4ca4048fa6aac8eeU)),.hi = ((u64)(0x03b4919c8d1cf8e0U)),}, (strconv__Uint128){.lo = ((u64)(0x3d5003a61eef0725U)),.hi = ((u64)(0x02f6dae3a4172d80U)),}, (strconv__Uint128){.lo = ((u64)(0x9773361e7f259f51U)),.hi = ((u64)(0x025f1582e9ac2466U)),},
		(strconv__Uint128){.lo = ((u64)(0x8beb89ca6508fee8U)),.hi = ((u64)(0x03cb559e42ad070aU)),}, (strconv__Uint128){.lo = ((u64)(0x6fefa16eb73a6586U)),.hi = ((u64)(0x0309114b688a6c08U)),}, (strconv__Uint128){.lo = ((u64)(0xf3261abef8fb846bU)),.hi = ((u64)(0x026da76f86d52339U)),}, (strconv__Uint128){.lo = ((u64)(0x51d691318e5f3a45U)),.hi = ((u64)(0x03e2a57f3e21d1f6U)),}, (strconv__Uint128){.lo = ((u64)(0x0e4540f471e5c837U)),.hi = ((u64)(0x031bb798fe8174c5U)),}, (strconv__Uint128){.lo = ((u64)(0xd8376729f4b7d360U)),.hi = ((u64)(0x027c92e0cb9ac3d0U)),}, (strconv__Uint128){.lo = ((u64)(0xf38bd84321261effU)),.hi = ((u64)(0x03fa849adf5e061aU)),}, (strconv__Uint128){.lo = ((u64)(0x293cad0280eb4bffU)),.hi = ((u64)(0x032ed07be5e4d1afU)),},
		(strconv__Uint128){.lo = ((u64)(0xedca240200bc3cccU)),.hi = ((u64)(0x028bd9fcb7ea4158U)),}, (strconv__Uint128){.lo = ((u64)(0xbe3b50019a3030a4U)),.hi = ((u64)(0x02097b309321cde0U)),}, (strconv__Uint128){.lo = ((u64)(0xc9f88002904d1a9fU)),.hi = ((u64)(0x03425eb41e9c7c9aU)),}, (strconv__Uint128){.lo = ((u64)(0x3b2d3335403daee6U)),.hi = ((u64)(0x029b7ef67ee396e2U)),}, (strconv__Uint128){.lo = ((u64)(0x95bdc291003158b8U)),.hi = ((u64)(0x0215ff2b98b6124eU)),}, (strconv__Uint128){.lo = ((u64)(0x892f9db4cd1bc126U)),.hi = ((u64)(0x035665128df01d4aU)),}, (strconv__Uint128){.lo = ((u64)(0x07594af70a7c9a85U)),.hi = ((u64)(0x02ab840ed7f34aa2U)),}, (strconv__Uint128){.lo = ((u64)(0x6c476f2c0863aed1U)),.hi = ((u64)(0x0222d00bdff5d54eU)),},
		(strconv__Uint128){.lo = ((u64)(0x13a57eacda3917b4U)),.hi = ((u64)(0x036ae67966562217U)),}, (strconv__Uint128){.lo = ((u64)(0x0fb7988a482dac90U)),.hi = ((u64)(0x02bbeb9451de81acU)),}, (strconv__Uint128){.lo = ((u64)(0xd95fad3b6cf156daU)),.hi = ((u64)(0x022fefa9db1867bcU)),}, (strconv__Uint128){.lo = ((u64)(0xf565e1f8ae4ef15cU)),.hi = ((u64)(0x037fe5dc91c0a5faU)),}, (strconv__Uint128){.lo = ((u64)(0x911e4e608b725ab0U)),.hi = ((u64)(0x02ccb7e3a7cd5195U)),}, (strconv__Uint128){.lo = ((u64)(0xda7ea51a0928488dU)),.hi = ((u64)(0x023d5fe9530aa7aaU)),}, (strconv__Uint128){.lo = ((u64)(0xf7310829a8407415U)),.hi = ((u64)(0x039566421e7772aaU)),}, (strconv__Uint128){.lo = ((u64)(0x2c2739baed005cdeU)),.hi = ((u64)(0x02ddeb68185f8eefU)),},
		(strconv__Uint128){.lo = ((u64)(0xbcec2e2f24004a4bU)),.hi = ((u64)(0x024b22b9ad193f25U)),}, (strconv__Uint128){.lo = ((u64)(0x94ad16b1d333aa11U)),.hi = ((u64)(0x03ab6ac2ae8ecb6fU)),}, (strconv__Uint128){.lo = ((u64)(0xaa241227dc2954dbU)),.hi = ((u64)(0x02ef889bbed8a2bfU)),}, (strconv__Uint128){.lo = ((u64)(0x54e9a81fe35443e2U)),.hi = ((u64)(0x02593a163246e899U)),}, (strconv__Uint128){.lo = ((u64)(0x2175d9cc9eed396aU)),.hi = ((u64)(0x03c1f689ea0b0dc2U)),}, (strconv__Uint128){.lo = ((u64)(0xe7917b0a18bdc788U)),.hi = ((u64)(0x03019207ee6f3e34U)),}, (strconv__Uint128){.lo = ((u64)(0xb9412f3b46fe393aU)),.hi = ((u64)(0x0267a8065858fe90U)),}, (strconv__Uint128){.lo = ((u64)(0xf535185ed7fd285cU)),.hi = ((u64)(0x03d90cd6f3c1974dU)),},
		(strconv__Uint128){.lo = ((u64)(0xc42a79e57997537dU)),.hi = ((u64)(0x03140a458fce12a4U)),}, (strconv__Uint128){.lo = ((u64)(0x03552e512e12a931U)),.hi = ((u64)(0x02766e9e0ca4dbb7U)),}, (strconv__Uint128){.lo = ((u64)(0x9eeeb081e3510eb4U)),.hi = ((u64)(0x03f0b0fce107c5f1U)),}, (strconv__Uint128){.lo = ((u64)(0x4bf226ce4f740bc3U)),.hi = ((u64)(0x0326f3fd80d304c1U)),}, (strconv__Uint128){.lo = ((u64)(0xa3281f0b72c33c9cU)),.hi = ((u64)(0x02858ffe00a8d09aU)),}, (strconv__Uint128){.lo = ((u64)(0x1c2018d5f568fd4aU)),.hi = ((u64)(0x020473319a20a6e2U)),}, (strconv__Uint128){.lo = ((u64)(0xf9ccf48988a7fba9U)),.hi = ((u64)(0x033a51e8f69aa49cU)),}, (strconv__Uint128){.lo = ((u64)(0xfb0a5d3ad3b99621U)),.hi = ((u64)(0x02950e53f87bb6e3U)),},
		(strconv__Uint128){.lo = ((u64)(0x2f3b7dc8a96144e7U)),.hi = ((u64)(0x0210d8432d2fc583U)),}, (strconv__Uint128){.lo = ((u64)(0xe52bfc7442353b0cU)),.hi = ((u64)(0x034e26d1e1e608d1U)),}, (strconv__Uint128){.lo = ((u64)(0xb756639034f76270U)),.hi = ((u64)(0x02a4ebdb1b1e6d74U)),}, (strconv__Uint128){.lo = ((u64)(0x2c451c735d92b526U)),.hi = ((u64)(0x021d897c15b1f12aU)),}, (strconv__Uint128){.lo = ((u64)(0x13a1c71efc1deea3U)),.hi = ((u64)(0x0362759355e981ddU)),}, (strconv__Uint128){.lo = ((u64)(0x761b05b2634b2550U)),.hi = ((u64)(0x02b52adc44bace4aU)),}, (strconv__Uint128){.lo = ((u64)(0x91af37c1e908eaa6U)),.hi = ((u64)(0x022a88b036fbd83bU)),}, (strconv__Uint128){.lo = ((u64)(0x82b1f2cfdb417770U)),.hi = ((u64)(0x03774119f192f392U)),},
		(strconv__Uint128){.lo = ((u64)(0xcef4c23fe29ac5f3U)),.hi = ((u64)(0x02c5cdae5adbf60eU)),}, (strconv__Uint128){.lo = ((u64)(0x3f2a34ffe87bd190U)),.hi = ((u64)(0x0237d7beaf165e72U)),}, (strconv__Uint128){.lo = ((u64)(0x984387ffda5fb5b2U)),.hi = ((u64)(0x038c8c644b56fd83U)),}, (strconv__Uint128){.lo = ((u64)(0xe0360666484c915bU)),.hi = ((u64)(0x02d6d6b6a2abfe02U)),}, (strconv__Uint128){.lo = ((u64)(0x802b3851d3707449U)),.hi = ((u64)(0x024578921bbccb35U)),}, (strconv__Uint128){.lo = ((u64)(0x99dec082ebe72075U)),.hi = ((u64)(0x03a25a835f947855U)),}, (strconv__Uint128){.lo = ((u64)(0xae4bcd358985b391U)),.hi = ((u64)(0x02e8486919439377U)),}, (strconv__Uint128){.lo = ((u64)(0xbea30a913ad15c74U)),.hi = ((u64)(0x02536d20e102dc5fU)),},
		(strconv__Uint128){.lo = ((u64)(0xfdd1aa81f7b560b9U)),.hi = ((u64)(0x03b8ae9b019e2d65U)),}, (strconv__Uint128){.lo = ((u64)(0x97daeece5fc44d61U)),.hi = ((u64)(0x02fa2548ce182451U)),}, (strconv__Uint128){.lo = ((u64)(0xdfe258a51969d781U)),.hi = ((u64)(0x0261b76d71ace9daU)),}, (strconv__Uint128){.lo = ((u64)(0x996a276e8f0fbf34U)),.hi = ((u64)(0x03cf8be24f7b0fc4U)),}, (strconv__Uint128){.lo = ((u64)(0xe121b9253f3fcc2aU)),.hi = ((u64)(0x030c6fe83f95a636U)),}, (strconv__Uint128){.lo = ((u64)(0xb41afa8432997022U)),.hi = ((u64)(0x02705986994484f8U)),}, (strconv__Uint128){.lo = ((u64)(0xecf7f739ea8f19cfU)),.hi = ((u64)(0x03e6f5a4286da18dU)),}, (strconv__Uint128){.lo = ((u64)(0x23f99294bba5ae40U)),.hi = ((u64)(0x031f2ae9b9f14e0bU)),},
		(strconv__Uint128){.lo = ((u64)(0x4ffadbaa2fb7be99U)),.hi = ((u64)(0x027f5587c7f43e6fU)),}, (strconv__Uint128){.lo = ((u64)(0x7ff7c5dd1925fdc2U)),.hi = ((u64)(0x03feef3fa6539718U)),}, (strconv__Uint128){.lo = ((u64)(0xccc637e4141e649bU)),.hi = ((u64)(0x033258ffb842df46U)),}, (strconv__Uint128){.lo = ((u64)(0xd704f983434b83afU)),.hi = ((u64)(0x028ead9960357f6bU)),}, (strconv__Uint128){.lo = ((u64)(0x126a6135cf6f9c8cU)),.hi = ((u64)(0x020bbe144cf79923U)),}, (strconv__Uint128){.lo = ((u64)(0x83dd685618b29414U)),.hi = ((u64)(0x0345fced47f28e9eU)),}, (strconv__Uint128){.lo = ((u64)(0x9cb12044e08edcddU)),.hi = ((u64)(0x029e63f1065ba54bU)),}, (strconv__Uint128){.lo = ((u64)(0x16f419d0b3a57d7dU)),.hi = ((u64)(0x02184ff405161dd6U)),},
		(strconv__Uint128){.lo = ((u64)(0x8b20294dec3bfbfbU)),.hi = ((u64)(0x035a19866e89c956U)),}, (strconv__Uint128){.lo = ((u64)(0x3c19baa4bcfcc996U)),.hi = ((u64)(0x02ae7ad1f207d445U)),}, (strconv__Uint128){.lo = ((u64)(0xc9ae2eea30ca3adfU)),.hi = ((u64)(0x02252f0e5b39769dU)),}, (strconv__Uint128){.lo = ((u64)(0x0f7d17dd1add2afdU)),.hi = ((u64)(0x036eb1b091f58a96U)),}, (strconv__Uint128){.lo = ((u64)(0x3f97464a7be42264U)),.hi = ((u64)(0x02bef48d41913babU)),}, (strconv__Uint128){.lo = ((u64)(0xcc790508631ce850U)),.hi = ((u64)(0x02325d3dce0dc955U)),}, (strconv__Uint128){.lo = ((u64)(0xe0c1a1a704fb0d4dU)),.hi = ((u64)(0x0383c862e3494222U)),}, (strconv__Uint128){.lo = ((u64)(0x4d67b4859d95a43eU)),.hi = ((u64)(0x02cfd3824f6dce82U)),},
		(strconv__Uint128){.lo = ((u64)(0x711fc39e17aae9cbU)),.hi = ((u64)(0x023fdc683f8b0b9bU)),}, (strconv__Uint128){.lo = ((u64)(0xe832d2968c44a945U)),.hi = ((u64)(0x039960a6cc11ac2bU)),}, (strconv__Uint128){.lo = ((u64)(0xecf575453d03ba9eU)),.hi = ((u64)(0x02e11a1f09a7bcefU)),}, (strconv__Uint128){.lo = ((u64)(0x572ac4376402fbb1U)),.hi = ((u64)(0x024dae7f3aec9726U)),}, (strconv__Uint128){.lo = ((u64)(0x58446d256cd192b5U)),.hi = ((u64)(0x03af7d985e47583dU)),}, (strconv__Uint128){.lo = ((u64)(0x79d0575123dadbc4U)),.hi = ((u64)(0x02f2cae04b6c4697U)),}, (strconv__Uint128){.lo = ((u64)(0x94a6ac40e97be303U)),.hi = ((u64)(0x025bd5803c569edfU)),}, (strconv__Uint128){.lo = ((u64)(0x8771139b0f2c9e6cU)),.hi = ((u64)(0x03c62266c6f0fe32U)),},
		(strconv__Uint128){.lo = ((u64)(0x9f8da948d8f07ebdU)),.hi = ((u64)(0x0304e85238c0cb5bU)),}, (strconv__Uint128){.lo = ((u64)(0xe60aedd3e0c06564U)),.hi = ((u64)(0x026a5374fa33d5e2U)),}, (strconv__Uint128){.lo = ((u64)(0xa344afb9679a3bd2U)),.hi = ((u64)(0x03dd5254c3862304U)),}, (strconv__Uint128){.lo = ((u64)(0xe903bfc78614fca8U)),.hi = ((u64)(0x031775109c6b4f36U)),}, (strconv__Uint128){.lo = ((u64)(0xba6966393810ca20U)),.hi = ((u64)(0x02792a73b055d8f8U)),}, (strconv__Uint128){.lo = ((u64)(0x2a423d2859b4769aU)),.hi = ((u64)(0x03f510b91a22f4c1U)),}, (strconv__Uint128){.lo = ((u64)(0xee9b642047c39215U)),.hi = ((u64)(0x032a73c7481bf700U)),}, (strconv__Uint128){.lo = ((u64)(0xbee2b680396941aaU)),.hi = ((u64)(0x02885c9f6ce32c00U)),},
		(strconv__Uint128){.lo = ((u64)(0xff1bc53361210155U)),.hi = ((u64)(0x0206b07f8a4f5666U)),}, (strconv__Uint128){.lo = ((u64)(0x31c6085235019bbbU)),.hi = ((u64)(0x033de73276e5570bU)),}, (strconv__Uint128){.lo = ((u64)(0x27d1a041c4014963U)),.hi = ((u64)(0x0297ec285f1ddf3cU)),}, (strconv__Uint128){.lo = ((u64)(0xeca7b367d0010782U)),.hi = ((u64)(0x021323537f4b18fcU)),}, (strconv__Uint128){.lo = ((u64)(0xadd91f0c8001a59dU)),.hi = ((u64)(0x0351d21f3211c194U)),}, (strconv__Uint128){.lo = ((u64)(0xf17a7f3d3334847eU)),.hi = ((u64)(0x02a7db4c280e3476U)),}, (strconv__Uint128){.lo = ((u64)(0x279532975c2a0398U)),.hi = ((u64)(0x021fe2a3533e905fU)),}, (strconv__Uint128){.lo = ((u64)(0xd8eeb75893766c26U)),.hi = ((u64)(0x0366376bb8641a31U)),},
		(strconv__Uint128){.lo = ((u64)(0x7a5892ad42c52352U)),.hi = ((u64)(0x02b82c562d1ce1c1U)),}, (strconv__Uint128){.lo = ((u64)(0xfb7a0ef102374f75U)),.hi = ((u64)(0x022cf044f0e3e7cdU)),}, (strconv__Uint128){.lo = ((u64)(0xc59017e8038bb254U)),.hi = ((u64)(0x037b1a07e7d30c7cU)),}, (strconv__Uint128){.lo = ((u64)(0x37a67986693c8eaaU)),.hi = ((u64)(0x02c8e19feca8d6caU)),}, (strconv__Uint128){.lo = ((u64)(0xf951fad1edca0bbbU)),.hi = ((u64)(0x023a4e198a20abd4U)),}, (strconv__Uint128){.lo = ((u64)(0x28832ae97c76792bU)),.hi = ((u64)(0x03907cf5a9cddfbbU)),}, (strconv__Uint128){.lo = ((u64)(0x2068ef21305ec756U)),.hi = ((u64)(0x02d9fd9154a4b2fcU)),}, (strconv__Uint128){.lo = ((u64)(0x19ed8c1a8d189f78U)),.hi = ((u64)(0x0247fe0ddd508f30U)),},
		(strconv__Uint128){.lo = ((u64)(0x5caf4690e1c0ff26U)),.hi = ((u64)(0x03a66349621a7eb3U)),}, (strconv__Uint128){.lo = ((u64)(0x4a25d20d81673285U)),.hi = ((u64)(0x02eb82a11b48655cU)),}, (strconv__Uint128){.lo = ((u64)(0x3b5174d79ab8f537U)),.hi = ((u64)(0x0256021a7c39eab0U)),}, (strconv__Uint128){.lo = ((u64)(0x921bee25c45b21f1U)),.hi = ((u64)(0x03bcd02a605caab3U)),}, (strconv__Uint128){.lo = ((u64)(0xdb498b5169e2818eU)),.hi = ((u64)(0x02fd735519e3bbc2U)),}, (strconv__Uint128){.lo = ((u64)(0x15d46f7454b53472U)),.hi = ((u64)(0x02645c4414b62fcfU)),}, (strconv__Uint128){.lo = ((u64)(0xefba4bed545520b6U)),.hi = ((u64)(0x03d3c6d35456b2e4U)),}, (strconv__Uint128){.lo = ((u64)(0xf2fb6ff110441a2bU)),.hi = ((u64)(0x030fd242a9def583U)),},
		(strconv__Uint128){.lo = ((u64)(0x8f2f8cc0d9d014efU)),.hi = ((u64)(0x02730e9bbb18c469U)),}, (strconv__Uint128){.lo = ((u64)(0xb1e5ae015c80217fU)),.hi = ((u64)(0x03eb4a92c4f46d75U)),}, (strconv__Uint128){.lo = ((u64)(0xc1848b344a001accU)),.hi = ((u64)(0x0322a20f03f6bdf7U)),}, (strconv__Uint128){.lo = ((u64)(0xce03a2903b3348a3U)),.hi = ((u64)(0x02821b3f365efe5fU)),}, (strconv__Uint128){.lo = ((u64)(0xd802e873628f6d4fU)),.hi = ((u64)(0x0201af65c518cb7fU)),}, (strconv__Uint128){.lo = ((u64)(0x599e40b89db2487fU)),.hi = ((u64)(0x0335e56fa1c14599U)),}, (strconv__Uint128){.lo = ((u64)(0xe14b66fa17c1d399U)),.hi = ((u64)(0x029184594e3437adU)),}, (strconv__Uint128){.lo = ((u64)(0x81091f2e7967dc7aU)),.hi = ((u64)(0x020e037aa4f692f1U)),},
		(strconv__Uint128){.lo = ((u64)(0x9b41cb7d8f0c93f6U)),.hi = ((u64)(0x03499f2aa18a84b5U)),}, (strconv__Uint128){.lo = ((u64)(0xaf67d5fe0c0a0ff8U)),.hi = ((u64)(0x02a14c221ad536f7U)),}, (strconv__Uint128){.lo = ((u64)(0xf2b977fe70080cc7U)),.hi = ((u64)(0x021aa34e7bddc592U)),}, (strconv__Uint128){.lo = ((u64)(0x1df58cca4cd9ae0bU)),.hi = ((u64)(0x035dd2172c9608ebU)),}, (strconv__Uint128){.lo = ((u64)(0xe4c470a1d7148b3cU)),.hi = ((u64)(0x02b174df56de6d88U)),}, (strconv__Uint128){.lo = ((u64)(0x83d05a1b1276d5caU)),.hi = ((u64)(0x022790b2abe5246dU)),}, (strconv__Uint128){.lo = ((u64)(0x9fb3c35e83f1560fU)),.hi = ((u64)(0x0372811ddfd50715U)),}, (strconv__Uint128){.lo = ((u64)(0xb2f635e5365aab3fU)),.hi = ((u64)(0x02c200e4b310d277U)),},
		(strconv__Uint128){.lo = ((u64)(0xf591c4b75eaeef66U)),.hi = ((u64)(0x0234cd83c273db92U)),}, (strconv__Uint128){.lo = ((u64)(0xef4fa125644b18a3U)),.hi = ((u64)(0x0387af39371fc5b7U)),}, (strconv__Uint128){.lo = ((u64)(0x8c3fb41de9d5ad4fU)),.hi = ((u64)(0x02d2f2942c196af9U)),}, (strconv__Uint128){.lo = ((u64)(0x3cffc34b2177bdd9U)),.hi = ((u64)(0x02425ba9bce12261U)),}, (strconv__Uint128){.lo = ((u64)(0x94cc6bab68bf9628U)),.hi = ((u64)(0x039d5f75fb01d09bU)),}, (strconv__Uint128){.lo = ((u64)(0x10a38955ed6611b9U)),.hi = ((u64)(0x02e44c5e6267da16U)),}, (strconv__Uint128){.lo = ((u64)(0xda1c6dde5784dafbU)),.hi = ((u64)(0x02503d184eb97b44U)),}, (strconv__Uint128){.lo = ((u64)(0xf693e2fd58d49191U)),.hi = ((u64)(0x03b394f3b128c53aU)),},
		(strconv__Uint128){.lo = ((u64)(0xc5431bfde0aa0e0eU)),.hi = ((u64)(0x02f610c2f4209dc8U)),}, (strconv__Uint128){.lo = ((u64)(0x6a9c1664b3bb3e72U)),.hi = ((u64)(0x025e73cf29b3b16dU)),}, (strconv__Uint128){.lo = ((u64)(0x10f9bd6dec5eca4fU)),.hi = ((u64)(0x03ca52e50f85e8afU)),}, (strconv__Uint128){.lo = ((u64)(0xda616457f04bd50cU)),.hi = ((u64)(0x03084250d937ed58U)),}, (strconv__Uint128){.lo = ((u64)(0xe1e783798d09773dU)),.hi = ((u64)(0x026d01da475ff113U)),}, (strconv__Uint128){.lo = ((u64)(0x030c058f480f252eU)),.hi = ((u64)(0x03e19c9072331b53U)),}, (strconv__Uint128){.lo = ((u64)(0x68d66ad906728425U)),.hi = ((u64)(0x031ae3a6c1c27c42U)),}, (strconv__Uint128){.lo = ((u64)(0x8711ef14052869b7U)),.hi = ((u64)(0x027be952349b969bU)),},
		(strconv__Uint128){.lo = ((u64)(0x0b4fe4ecd50d75f2U)),.hi = ((u64)(0x03f97550542c242cU)),}, (strconv__Uint128){.lo = ((u64)(0xa2a650bd773df7f5U)),.hi = ((u64)(0x032df7737689b689U)),}, (strconv__Uint128){.lo = ((u64)(0xb551da312c31932aU)),.hi = ((u64)(0x028b2c5c5ed49207U)),}, (strconv__Uint128){.lo = ((u64)(0x5ddb14f4235adc22U)),.hi = ((u64)(0x0208f049e576db39U)),}, (strconv__Uint128){.lo = ((u64)(0x2fc4ee536bc49369U)),.hi = ((u64)(0x034180763bf15ec2U)),}, (strconv__Uint128){.lo = ((u64)(0xbfd0bea92303a921U)),.hi = ((u64)(0x029acd2b63277f01U)),}, (strconv__Uint128){.lo = ((u64)(0x9973cbba8269541aU)),.hi = ((u64)(0x021570ef8285ff34U)),}, (strconv__Uint128){.lo = ((u64)(0x5bec792a6a42202aU)),.hi = ((u64)(0x0355817f373ccb87U)),},
		(strconv__Uint128){.lo = ((u64)(0xe3239421ee9b4cefU)),.hi = ((u64)(0x02aacdff5f63d605U)),}, (strconv__Uint128){.lo = ((u64)(0xb5b6101b25490a59U)),.hi = ((u64)(0x02223e65e5e97804U)),}, (strconv__Uint128){.lo = ((u64)(0x22bce691d541aa27U)),.hi = ((u64)(0x0369fd6fd64259a1U)),}, (strconv__Uint128){.lo = ((u64)(0xb563eba7ddce21b9U)),.hi = ((u64)(0x02bb31264501e14dU)),}, (strconv__Uint128){.lo = ((u64)(0xf78322ecb171b494U)),.hi = ((u64)(0x022f5a850401810aU)),}, (strconv__Uint128){.lo = ((u64)(0x259e9e47824f8753U)),.hi = ((u64)(0x037ef73b399c01abU)),}, (strconv__Uint128){.lo = ((u64)(0x1e187e9f9b72d2a9U)),.hi = ((u64)(0x02cbf8fc2e1667bcU)),}, (strconv__Uint128){.lo = ((u64)(0x4b46cbb2e2c24221U)),.hi = ((u64)(0x023cc73024deb963U)),},
		(strconv__Uint128){.lo = ((u64)(0x120adf849e039d01U)),.hi = ((u64)(0x039471e6a1645bd2U)),}, (strconv__Uint128){.lo = ((u64)(0xdb3be603b19c7d9aU)),.hi = ((u64)(0x02dd27ebb4504974U)),}, (strconv__Uint128){.lo = ((u64)(0x7c2feb3627b0647cU)),.hi = ((u64)(0x024a865629d9d45dU)),}, (strconv__Uint128){.lo = ((u64)(0x2d197856a5e7072cU)),.hi = ((u64)(0x03aa7089dc8fba2fU)),}, (strconv__Uint128){.lo = ((u64)(0x8a7ac6abb7ec05bdU)),.hi = ((u64)(0x02eec06e4a0c94f2U)),}, (strconv__Uint128){.lo = ((u64)(0xd52f05562cbcd164U)),.hi = ((u64)(0x025899f1d4d6dd8eU)),}, (strconv__Uint128){.lo = ((u64)(0x21e4d556adfae8a0U)),.hi = ((u64)(0x03c0f64fbaf1627eU)),}, (strconv__Uint128){.lo = ((u64)(0xe7ea444557fbed4dU)),.hi = ((u64)(0x0300c50c958de864U)),},
		(strconv__Uint128){.lo = ((u64)(0xecbb69d1132ff10aU)),.hi = ((u64)(0x0267040a113e5383U)),}, (strconv__Uint128){.lo = ((u64)(0xadf8a94e851981aaU)),.hi = ((u64)(0x03d8067681fd526cU)),}, (strconv__Uint128){.lo = ((u64)(0x8b2d543ed0e13488U)),.hi = ((u64)(0x0313385ece6441f0U)),}, (strconv__Uint128){.lo = ((u64)(0xd5bddcff0d80f6d3U)),.hi = ((u64)(0x0275c6b23eb69b26U)),}, (strconv__Uint128){.lo = ((u64)(0x892fc7fe7c018aebU)),.hi = ((u64)(0x03efa45064575ea4U)),}, (strconv__Uint128){.lo = ((u64)(0x3a8c9ffec99ad589U)),.hi = ((u64)(0x03261d0d1d12b21dU)),}, (strconv__Uint128){.lo = ((u64)(0xc8707fff07af113bU)),.hi = ((u64)(0x0284e40a7da88e7dU)),}, (strconv__Uint128){.lo = ((u64)(0x39f39998d2f2742fU)),.hi = ((u64)(0x0203e9a1fe2071feU)),},
		(strconv__Uint128){.lo = ((u64)(0x8fec28f484b7204bU)),.hi = ((u64)(0x033975cffd00b663U)),}, (strconv__Uint128){.lo = ((u64)(0xd989ba5d36f8e6a2U)),.hi = ((u64)(0x02945e3ffd9a2b82U)),}, (strconv__Uint128){.lo = ((u64)(0x47a161e42bfa521cU)),.hi = ((u64)(0x02104b66647b5602U)),}, (strconv__Uint128){.lo = ((u64)(0x0c35696d132a1cf9U)),.hi = ((u64)(0x034d4570a0c5566aU)),}, (strconv__Uint128){.lo = ((u64)(0x09c454574288172dU)),.hi = ((u64)(0x02a4378d4d6aab88U)),}, (strconv__Uint128){.lo = ((u64)(0xa169dd129ba0128bU)),.hi = ((u64)(0x021cf93dd7888939U)),}, (strconv__Uint128){.lo = ((u64)(0x0242fb50f9001dabU)),.hi = ((u64)(0x03618ec958da7529U)),}, (strconv__Uint128){.lo = ((u64)(0x9b68c90d940017bcU)),.hi = ((u64)(0x02b4723aad7b90edU)),},
		(strconv__Uint128){.lo = ((u64)(0x4920a0d7a999ac96U)),.hi = ((u64)(0x0229f4fbbdfc73f1U)),}, (strconv__Uint128){.lo = ((u64)(0x750101590f5c4757U)),.hi = ((u64)(0x037654c5fcc71fe8U)),}, (strconv__Uint128){.lo = ((u64)(0x2a6734473f7d05dfU)),.hi = ((u64)(0x02c5109e63d27fedU)),}, (strconv__Uint128){.lo = ((u64)(0xeeb8f69f65fd9e4cU)),.hi = ((u64)(0x0237407eb641fff0U)),}, (strconv__Uint128){.lo = ((u64)(0xe45b24323cc8fd46U)),.hi = ((u64)(0x038b9a6456cfffe7U)),}, (strconv__Uint128){.lo = ((u64)(0xb6af502830a0ca9fU)),.hi = ((u64)(0x02d6151d123fffecU)),}, (strconv__Uint128){.lo = ((u64)(0xf88c402026e7087fU)),.hi = ((u64)(0x0244ddb0db666656U)),}, (strconv__Uint128){.lo = ((u64)(0x2746cd003e3e73feU)),.hi = ((u64)(0x03a162b4923d708bU)),},
		(strconv__Uint128){.lo = ((u64)(0x1f6bd73364fec332U)),.hi = ((u64)(0x02e7822a0e978d3cU)),}, (strconv__Uint128){.lo = ((u64)(0xe5efdf5c50cbcf5bU)),.hi = ((u64)(0x0252ce880bac70fcU)),}, (strconv__Uint128){.lo = ((u64)(0x3cb2fefa1adfb22bU)),.hi = ((u64)(0x03b7b0d9ac471b2eU)),}, (strconv__Uint128){.lo = ((u64)(0x308f3261af195b56U)),.hi = ((u64)(0x02f95a47bd05af58U)),}, (strconv__Uint128){.lo = ((u64)(0x5a0c284e25ade2abU)),.hi = ((u64)(0x0261150630d15913U)),}, (strconv__Uint128){.lo = ((u64)(0x29ad0d49d5e30445U)),.hi = ((u64)(0x03ce8809e7b55b52U)),}, (strconv__Uint128){.lo = ((u64)(0x548a7107de4f369dU)),.hi = ((u64)(0x030ba007ec9115dbU)),}, (strconv__Uint128){.lo = ((u64)(0xdd3b8d9fe50c2bb1U)),.hi = ((u64)(0x026fb3398a0dab15U)),},
		(strconv__Uint128){.lo = ((u64)(0x952c15cca1ad12b5U)),.hi = ((u64)(0x03e5eb8f434911bcU)),}, (strconv__Uint128){.lo = ((u64)(0x775677d6e7bda891U)),.hi = ((u64)(0x031e560c35d40e30U)),}, (strconv__Uint128){.lo = ((u64)(0xc5dec645863153a7U)),.hi = ((u64)(0x027eab3cf7dcd826U)),}}));
	}
	{ // Initializations for module builtin :
	_const_none__ = /*&IError*/I_None___to_Interface_IError((None__*)memdup(&(None__){.msg = (string){.str=(byteptr)"", .is_lit=1},.code = 0,}, sizeof(None__)));
	_const_children_bytes = sizeof(voidptr) * (_const_max_len + 1);
	}
	{ // Initializations for module dl :
	_const_dl__dl_ext = dl__get_shared_library_extension();
	}
	{ // Initializations for module strings.textscanner :
	}
	{ // Initializations for module os.cmdline :
	}
	{ // Initializations for module math.mathutil :
	}
	{ // Initializations for module v.token :
	_const_v__token__assign_tokens = new_array_from_c_array(12, 12, sizeof(v__token__Kind), _MOV((v__token__Kind[12]){
		v__token__Kind__assign, v__token__Kind__plus_assign, v__token__Kind__minus_assign, v__token__Kind__mult_assign, v__token__Kind__div_assign, v__token__Kind__xor_assign, v__token__Kind__mod_assign, v__token__Kind__or_assign, v__token__Kind__and_assign,
		v__token__Kind__right_shift_assign, v__token__Kind__left_shift_assign, v__token__Kind__unsigned_right_shift_assign}));
	_const_v__token__nr_tokens = ((int)(v__token__Kind___end_));
	_const_v__token__valid_at_tokens = new_array_from_c_array(13, 13, sizeof(string), _MOV((string[13]){
		_SLIT("@VROOT"), _SLIT("@VMODROOT"), _SLIT("@VEXEROOT"), _SLIT("@FN"), _SLIT("@METHOD"), _SLIT("@MOD"), _SLIT("@STRUCT"), _SLIT("@VEXE"), _SLIT("@FILE"),
		_SLIT("@LINE"), _SLIT("@COLUMN"), _SLIT("@VHASH"), _SLIT("@VMOD_FILE")}));
	_const_v__token__token_str = v__token__build_token_str();
	_const_v__token__keywords = v__token__build_keys();
	_const_v__token__matcher = v__token__new_keywords_matcher_T_v__token__Kind(_const_v__token__keywords);
	_const_v__token__precedences = v__token__build_precedences();
	}
	{ // Initializations for module time :
	_const_time__month_days = new_array_from_c_array(12, 12, sizeof(int), _MOV((int[12]){
		31, 28, 31, 30, 31, 30, 31, 31, 30,
		31, 30, 31}));
	_const_time__absolute_zero_year = ((i64)(-292277022399));
	_const_time__days_before = new_array_from_c_array(13, 13, sizeof(int), _MOV((int[13]){
		0, 31, 31 + 28, 31 + 28 + 31, 31 + 28 + 31 + 30, 31 + 28 + 31 + 30 + 31, 31 + 28 + 31 + 30 + 31 + 30, 31 + 28 + 31 + 30 + 31 + 30 + 31, 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31,
		31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30, 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31, 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30, 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31}));
	_const_time__long_days = new_array_from_c_array(7, 7, sizeof(string), _MOV((string[7]){_SLIT("Monday"), _SLIT("Tuesday"), _SLIT("Wednesday"), _SLIT("Thursday"), _SLIT("Friday"), _SLIT("Saturday"), _SLIT("Sunday")}));
	_const_time__nanosecond = ((time__Duration)(1));
	_const_time__microsecond = ((1000 * _const_time__nanosecond));
	_const_time__millisecond = ((1000 * _const_time__microsecond));
	_const_time__second = ((1000 * _const_time__millisecond));
	_const_time__minute = ((60 * _const_time__second));
	_const_time__hour = ((60 * _const_time__minute));
	_const_time__infinite = ((((i64)(9223372036854775807))));
	_const_time__start_time = time__init_win_time_start();
	_const_time__freq_time = time__init_win_time_freq();
	_const_time__start_local_time = time__local_as_unix_time();
	}
	{ // Initializations for module v.dotgraph :
	}
	{ // Initializations for module hash :
	}
	{ // Initializations for module hash.fnv1a :
	}
	{ // Initializations for module rand.constants :
	_const_rand__constants__max_u32_as_f32 = ((f32)(_const_rand__constants__max_u32)) + 1;
	_const_rand__constants__max_u64_as_f64 = ((f64)(_const_rand__constants__max_u64)) + 1;
	}
	{ // Initializations for module flag :
	}
	{ // Initializations for module semver :
	_const_semver__versions = new_array_from_c_array(3, 3, sizeof(int), _MOV((int[3]){_const_semver__ver_major, _const_semver__ver_minor, _const_semver__ver_patch}));
	}
	{ // Initializations for module sync.stdatomic :
	}
	{ // Initializations for module sync.threads :
	}
	{ // Initializations for module os :
	_const_os__invalid_handle_value = ((voidptr)(-1));
	_const_os__hkey_local_machine = ((voidptr)(0x80000002));
	_const_os__hkey_current_user = ((voidptr)(0x80000001));
	_const_os__hwnd_broadcast = ((voidptr)(0xFFFF));
	_const_os__args = os__init_os_args_wide(___argc, (byteptr*)___argv);
	_const_os__wd_at_startup = os__getwd();
	}
	{ // Initializations for module v.errors :
	}
	{ // Initializations for module v.depgraph :
	}
	{ // Initializations for module v.vet :
	}
	{ // Initializations for module rand.seed :
	}
	{ // Initializations for module term :
	}
	{ // Initializations for module v.util.version :
	}
	{ // Initializations for module v.vcache :
	}
	{ // Initializations for module v.util.diff :
	}
	{ // Initializations for module v.vmod :
	_const_v__vmod__mod_file_stop_paths = new_array_from_c_array(4, 4, sizeof(string), _MOV((string[4]){_SLIT(".git"), _SLIT(".hg"), _SLIT(".svn"), _SLIT(".v.mod.stop")}));
	_const_v__vmod__private_file_cacher = v__vmod__new_mod_file_cacher();
	}
	{ // Initializations for module v.util.recompilation :
	}
	{ // Initializations for module v.cflag :
	}
	{ // Initializations for module rand.config :
	}
	{ // Initializations for module rand.wyrand :
	}
	{ // Initializations for module v.pkgconfig :
	_const_v__pkgconfig__default_paths = new_array_from_c_array(11, 11, sizeof(string), _MOV((string[11]){
		_SLIT("/usr/local/lib/x86_64-linux-gnu/pkgconfig"), _SLIT("/usr/local/lib64/pkgconfig"), _SLIT("/usr/local/lib/pkgconfig"), _SLIT("/usr/local/share/pkgconfig"), _SLIT("/usr/lib/x86_64-linux-gnu/pkgconfig"), _SLIT("/usr/lib/aarch64-linux-gnu/pkgconfig"), _SLIT("/usr/lib64/pkgconfig"), _SLIT("/usr/lib/pkgconfig"), _SLIT("/usr/share/pkgconfig"),
		_SLIT("/opt/homebrew/lib/pkgconfig"), _SLIT("/usr/local/libdata/pkgconfig")}));
	}
	{ // Initializations for module runtime :
	}
	{ // Initializations for module rand :
	default_rng = *(rand__PRNG**)&((rand__PRNG*[]){0}[0]); // global
	rand__init();
	}
	{ // Initializations for module v.pref :
	_const_v__pref__default_module_path = os__vmodules_dir();
	_const_v__pref__list_of_flags_with_param = new_array_from_c_array(12, 12, sizeof(string), _MOV((string[12]){
		_SLIT("o"), _SLIT("d"), _SLIT("define"), _SLIT("b"), _SLIT("backend"), _SLIT("cc"), _SLIT("os"), _SLIT("target-os"), _SLIT("cf"),
		_SLIT("cflags"), _SLIT("path"), _SLIT("arch")}));
	}
	{ // Initializations for module sync :
	}
	{ // Initializations for module help :
	}
	{ // Initializations for module v.util :
	_const_v__util__emanager = v__util__new_error_manager();
	_const_v__util__invalid_escapes = string_bytes(_SLIT("({$`."));
	_const_v__util__builtin_module_parts = new_array_from_c_array(5, 5, sizeof(string), _MOV((string[5]){_SLIT("math.bits"), _SLIT("strconv"), _SLIT("strconv.ftoa"), _SLIT("strings"), _SLIT("builtin")}));
	_const_v__util__bundle_modules = new_array_from_c_array(7, 7, sizeof(string), _MOV((string[7]){_SLIT("clipboard"), _SLIT("fontstash"), _SLIT("gg"), _SLIT("gx"), _SLIT("sokol"), _SLIT("szip"), _SLIT("ui")}));
	_const_v__util__external_module_dependencies_for_tool = new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 1, sizeof(string), sizeof(Array_string), _MOV((string[1]){_SLIT("vdoc"), }), _MOV((Array_string[1]){new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("markdown")})), }));
	_const_v__util__const_tabs = new_array_from_c_array(10, 10, sizeof(string), _MOV((string[10]){
		_SLIT(""), _SLIT("\t"), _SLIT("\t\t"), _SLIT("\t\t\t"), _SLIT("\t\t\t\t"), _SLIT("\t\t\t\t\t"), _SLIT("\t\t\t\t\t\t"), _SLIT("\t\t\t\t\t\t\t"), _SLIT("\t\t\t\t\t\t\t\t"),
		_SLIT("\t\t\t\t\t\t\t\t\t")}));
	g_timers = v__util__new_timers((v__util__TimerParams){.should_print = false,.label = _SLIT("g_timers"),}); // global
	}
	{ // Initializations for module sync.pool :
	_const_sync__pool__no_result = ((voidptr)(0));
	}
	{ // Initializations for module v.ast :
	_const_v__ast__x86_no_number_register_list = new_map_init(&map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop, 4, sizeof(int), sizeof(Array_string), _MOV((int[4]){8, 16, 32, 64, }), _MOV((Array_string[4]){new_array_from_c_array(12, 12, sizeof(string), _MOV((string[12]){
		_SLIT("al"), _SLIT("ah"), _SLIT("bl"), _SLIT("bh"), _SLIT("cl"), _SLIT("ch"), _SLIT("dl"), _SLIT("dh"), _SLIT("bpl"),
		_SLIT("sil"), _SLIT("dil"), _SLIT("spl")})), new_array_from_c_array(23, 23, sizeof(string), _MOV((string[23]){
		_SLIT("ax"), _SLIT("bx"), _SLIT("cx"), _SLIT("dx"), _SLIT("bp"), _SLIT("si"), _SLIT("di"), _SLIT("sp"), _SLIT("cs"),
		_SLIT("ss"), _SLIT("ds"), _SLIT("es"), _SLIT("fs"), _SLIT("gs"), _SLIT("flags"), _SLIT("ip"), _SLIT("gdtr"),
		_SLIT("idtr"), _SLIT("tr"), _SLIT("ldtr"), _SLIT("fp_cs"), _SLIT("fp_ds"), _SLIT("fp_opc")})), new_array_from_c_array(11, 11, sizeof(string), _MOV((string[11]){
		_SLIT("eax"), _SLIT("ebx"), _SLIT("ecx"), _SLIT("edx"), _SLIT("ebp"), _SLIT("esi"), _SLIT("edi"), _SLIT("esp"), _SLIT("eflags"),
		_SLIT("eip"), _SLIT("mxcsr")})), new_array_from_c_array(10, 10, sizeof(string), _MOV((string[10]){
		_SLIT("rax"), _SLIT("rbx"), _SLIT("rcx"), _SLIT("rdx"), _SLIT("rbp"), _SLIT("rsi"), _SLIT("rdi"), _SLIT("rsp"), _SLIT("rflags"),
		_SLIT("rip")})), }));
	_const_v__ast__x86_with_number_register_list = new_map_init(&map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop, 8, sizeof(int), sizeof(Map_string_int), _MOV((int[8]){8, 16, 32, 64, 80, 128, 256, 512, }), _MOV((Map_string_int[8]){new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 1, sizeof(string), sizeof(int), _MOV((string[1]){_SLIT("r#b"), }), _MOV((int[1]){16, })), new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 1, sizeof(string), sizeof(int), _MOV((string[1]){_SLIT("r#w"), }), _MOV((int[1]){16, })), new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 1, sizeof(string), sizeof(int), _MOV((string[1]){_SLIT("r#d"), }), _MOV((int[1]){16, })), new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 4, sizeof(string), sizeof(int), _MOV((string[4]){_SLIT("r#"), _SLIT("mm#"), _SLIT("cr#"), _SLIT("dr#"), }), _MOV((int[4]){16, 16, 16, 16, })), new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 1, sizeof(string), sizeof(int), _MOV((string[1]){_SLIT("st#"), }), _MOV((int[1]){16, })), new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 1, sizeof(string), sizeof(int), _MOV((string[1]){_SLIT("xmm#"), }), _MOV((int[1]){32, })), new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 1, sizeof(string), sizeof(int), _MOV((string[1]){_SLIT("ymm#"), }), _MOV((int[1]){32, })), new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 1, sizeof(string), sizeof(int), _MOV((string[1]){_SLIT("zmm#"), }), _MOV((int[1]){32, })), }));
	_const_v__ast__arm_no_number_register_list = new_array_from_c_array(5, 5, sizeof(string), _MOV((string[5]){_SLIT("fp"), _SLIT("ip"), _SLIT("sp"), _SLIT("lr"), _SLIT("pc")}));
	_const_v__ast__arm_with_number_register_list = new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 1, sizeof(string), sizeof(int), _MOV((string[1]){_SLIT("r#"), }), _MOV((int[1]){16, }));
	_const_v__ast__riscv_no_number_register_list = new_array_from_c_array(5, 5, sizeof(string), _MOV((string[5]){_SLIT("zero"), _SLIT("ra"), _SLIT("sp"), _SLIT("gp"), _SLIT("tp")}));
	_const_v__ast__riscv_with_number_register_list = new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 4, sizeof(string), sizeof(int), _MOV((string[4]){_SLIT("x#"), _SLIT("t#"), _SLIT("s#"), _SLIT("a#"), }), _MOV((int[4]){32, 3, 12, 8, }));
	_const_v__ast__native_builtins = new_array_from_c_array(7, 7, sizeof(string), _MOV((string[7]){_SLIT("assert"), _SLIT("print"), _SLIT("eprint"), _SLIT("println"), _SLIT("eprintln"), _SLIT("exit"), _SLIT("C.syscall")}));
	_const_v__ast__invalid_type_symbol = (v__ast__TypeSymbol*)memdup(&(v__ast__TypeSymbol){.parent_idx = -1,
	.info = {0},
	.kind = v__ast__Kind__placeholder,
	.name = _SLIT("InvalidType"),
	.cname = _SLIT("InvalidType"),
	.methods = __new_array(0, 0, sizeof(v__ast__Fn)),
	.mod = _SLIT("builtin"),
	.is_public = 0,
	.language = v__ast__Language__v,
	.idx = -1,
}, sizeof(v__ast__TypeSymbol));
	_const_v__ast__builtin_type_names = new_array_from_c_array(30, 30, sizeof(string), _MOV((string[30]){
		_SLIT("void"), _SLIT("voidptr"), _SLIT("byteptr"), _SLIT("charptr"), _SLIT("i8"), _SLIT("i16"), _SLIT("int"), _SLIT("i64"), _SLIT("isize"),
		_SLIT("byte"), _SLIT("u16"), _SLIT("u32"), _SLIT("u64"), _SLIT("usize"), _SLIT("f32"), _SLIT("f64"), _SLIT("char"),
		_SLIT("bool"), _SLIT("none"), _SLIT("string"), _SLIT("rune"), _SLIT("array"), _SLIT("map"), _SLIT("chan"), _SLIT("any"),
		_SLIT("float_literal"), _SLIT("int_literal"), _SLIT("thread"), _SLIT("Error"), _SLIT("u8")}));
	_const_v__ast__builtin_type_names_matcher = v__ast__build_builtin_type_names_matcher();
	_const_v__ast__integer_type_idxs = new_array_from_c_array(13, 13, sizeof(int), _MOV((int[13]){
		_const_v__ast__i8_type_idx, _const_v__ast__i16_type_idx, _const_v__ast__int_type_idx, _const_v__ast__i64_type_idx, _const_v__ast__byte_type_idx, _const_v__ast__u8_type_idx, _const_v__ast__u16_type_idx, _const_v__ast__u32_type_idx, _const_v__ast__u64_type_idx,
		_const_v__ast__isize_type_idx, _const_v__ast__usize_type_idx, _const_v__ast__int_literal_type_idx, _const_v__ast__rune_type_idx}));
	_const_v__ast__signed_integer_type_idxs = new_array_from_c_array(6, 6, sizeof(int), _MOV((int[6]){_const_v__ast__char_type_idx, _const_v__ast__i8_type_idx, _const_v__ast__i16_type_idx, _const_v__ast__int_type_idx, _const_v__ast__i64_type_idx, _const_v__ast__isize_type_idx}));
	_const_v__ast__unsigned_integer_type_idxs = new_array_from_c_array(6, 6, sizeof(int), _MOV((int[6]){_const_v__ast__byte_type_idx, _const_v__ast__u8_type_idx, _const_v__ast__u16_type_idx, _const_v__ast__u32_type_idx, _const_v__ast__u64_type_idx, _const_v__ast__usize_type_idx}));
	_const_v__ast__float_type_idxs = new_array_from_c_array(3, 3, sizeof(int), _MOV((int[3]){_const_v__ast__f32_type_idx, _const_v__ast__f64_type_idx, _const_v__ast__float_literal_type_idx}));
	_const_v__ast__number_type_idxs = new_array_from_c_array(16, 16, sizeof(int), _MOV((int[16]){
		_const_v__ast__i8_type_idx, _const_v__ast__i16_type_idx, _const_v__ast__int_type_idx, _const_v__ast__i64_type_idx, _const_v__ast__byte_type_idx, _const_v__ast__char_type_idx, _const_v__ast__u16_type_idx, _const_v__ast__u32_type_idx, _const_v__ast__u64_type_idx,
		_const_v__ast__isize_type_idx, _const_v__ast__usize_type_idx, _const_v__ast__f32_type_idx, _const_v__ast__f64_type_idx, _const_v__ast__int_literal_type_idx, _const_v__ast__float_literal_type_idx, _const_v__ast__rune_type_idx}));
	_const_v__ast__pointer_type_idxs = new_array_from_c_array(3, 3, sizeof(int), _MOV((int[3]){_const_v__ast__voidptr_type_idx, _const_v__ast__byteptr_type_idx, _const_v__ast__charptr_type_idx}));
	_const_v__ast__string_type_idxs = new_array_from_c_array(1, 1, sizeof(int), _MOV((int[1]){_const_v__ast__string_type_idx}));
	_const_v__ast__void_type = v__ast__new_type(_const_v__ast__void_type_idx);
	_const_v__ast__ovoid_type = v__ast__Type_set_flag(v__ast__new_type(_const_v__ast__void_type_idx), v__ast__TypeFlag__optional);
	_const_v__ast__voidptr_type = v__ast__new_type(_const_v__ast__voidptr_type_idx);
	_const_v__ast__byteptr_type = v__ast__new_type(_const_v__ast__byteptr_type_idx);
	_const_v__ast__charptr_type = v__ast__new_type(_const_v__ast__charptr_type_idx);
	_const_v__ast__i8_type = v__ast__new_type(_const_v__ast__i8_type_idx);
	_const_v__ast__int_type = v__ast__new_type(_const_v__ast__int_type_idx);
	_const_v__ast__i16_type = v__ast__new_type(_const_v__ast__i16_type_idx);
	_const_v__ast__i64_type = v__ast__new_type(_const_v__ast__i64_type_idx);
	_const_v__ast__isize_type = v__ast__new_type(_const_v__ast__isize_type_idx);
	_const_v__ast__byte_type = v__ast__new_type(_const_v__ast__byte_type_idx);
	_const_v__ast__u8_type = v__ast__new_type(_const_v__ast__u8_type_idx);
	_const_v__ast__u16_type = v__ast__new_type(_const_v__ast__u16_type_idx);
	_const_v__ast__u32_type = v__ast__new_type(_const_v__ast__u32_type_idx);
	_const_v__ast__u64_type = v__ast__new_type(_const_v__ast__u64_type_idx);
	_const_v__ast__usize_type = v__ast__new_type(_const_v__ast__usize_type_idx);
	_const_v__ast__f32_type = v__ast__new_type(_const_v__ast__f32_type_idx);
	_const_v__ast__f64_type = v__ast__new_type(_const_v__ast__f64_type_idx);
	_const_v__ast__char_type = v__ast__new_type(_const_v__ast__char_type_idx);
	_const_v__ast__bool_type = v__ast__new_type(_const_v__ast__bool_type_idx);
	_const_v__ast__none_type = v__ast__new_type(_const_v__ast__none_type_idx);
	_const_v__ast__string_type = v__ast__new_type(_const_v__ast__string_type_idx);
	_const_v__ast__rune_type = v__ast__new_type(_const_v__ast__rune_type_idx);
	_const_v__ast__array_type = v__ast__new_type(_const_v__ast__array_type_idx);
	_const_v__ast__map_type = v__ast__new_type(_const_v__ast__map_type_idx);
	_const_v__ast__chan_type = v__ast__new_type(_const_v__ast__chan_type_idx);
	_const_v__ast__any_type = v__ast__new_type(_const_v__ast__any_type_idx);
	_const_v__ast__float_literal_type = v__ast__new_type(_const_v__ast__float_literal_type_idx);
	_const_v__ast__int_literal_type = v__ast__new_type(_const_v__ast__int_literal_type_idx);
	_const_v__ast__thread_type = v__ast__new_type(_const_v__ast__thread_type_idx);
	_const_v__ast__error_type = v__ast__new_type(_const_v__ast__error_type_idx);
	_const_v__ast__charptr_types = new_array_from_c_array(2, 2, sizeof(v__ast__Type), _MOV((v__ast__Type[2]){_const_v__ast__charptr_type, v__ast__Type_set_nr_muls(v__ast__new_type(_const_v__ast__char_type_idx), 1)}));
	_const_v__ast__byteptr_types = new_array_from_c_array(2, 2, sizeof(v__ast__Type), _MOV((v__ast__Type[2]){_const_v__ast__byteptr_type, v__ast__Type_set_nr_muls(v__ast__new_type(_const_v__ast__byte_type_idx), 1)}));
	_const_v__ast__voidptr_types = new_array_from_c_array(2, 2, sizeof(v__ast__Type), _MOV((v__ast__Type[2]){_const_v__ast__voidptr_type, v__ast__Type_set_nr_muls(v__ast__new_type(_const_v__ast__voidptr_type_idx), 1)}));
	_const_v__ast__cptr_types = v__ast__merge_types(new_array_from_c_array(3, 3, sizeof(Array_v__ast__Type), _MOV((Array_v__ast__Type[3]){_const_v__ast__voidptr_types, _const_v__ast__byteptr_types, _const_v__ast__charptr_types})));
	}
	{ // Initializations for module v.checker :
	_const_v__checker__int_min = ((int)(0x80000000));
	_const_v__checker__valid_comptime_if_os = new_array_from_c_array(19, 19, sizeof(string), _MOV((string[19]){
		_SLIT("windows"), _SLIT("ios"), _SLIT("macos"), _SLIT("mach"), _SLIT("darwin"), _SLIT("hpux"), _SLIT("gnu"), _SLIT("qnx"), _SLIT("linux"),
		_SLIT("freebsd"), _SLIT("openbsd"), _SLIT("netbsd"), _SLIT("bsd"), _SLIT("dragonfly"), _SLIT("android"), _SLIT("solaris"), _SLIT("haiku"),
		_SLIT("serenity"), _SLIT("vinix")}));
	_const_v__checker__valid_comptime_compression_types = new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT("none"), _SLIT("zlib")}));
	_const_v__checker__valid_comptime_if_compilers = new_array_from_c_array(6, 6, sizeof(string), _MOV((string[6]){_SLIT("gcc"), _SLIT("tinyc"), _SLIT("clang"), _SLIT("mingw"), _SLIT("msvc"), _SLIT("cplusplus")}));
	_const_v__checker__valid_comptime_if_platforms = new_array_from_c_array(7, 7, sizeof(string), _MOV((string[7]){_SLIT("amd64"), _SLIT("i386"), _SLIT("aarch64"), _SLIT("arm64"), _SLIT("arm32"), _SLIT("rv64"), _SLIT("rv32")}));
	_const_v__checker__valid_comptime_if_cpu_features = new_array_from_c_array(4, 4, sizeof(string), _MOV((string[4]){_SLIT("x64"), _SLIT("x32"), _SLIT("little_endian"), _SLIT("big_endian")}));
	_const_v__checker__valid_comptime_if_other = new_array_from_c_array(14, 14, sizeof(string), _MOV((string[14]){
		_SLIT("js"), _SLIT("debug"), _SLIT("prod"), _SLIT("test"), _SLIT("glibc"), _SLIT("prealloc"), _SLIT("no_bounds_checking"), _SLIT("freestanding"), _SLIT("threads"),
		_SLIT("js_node"), _SLIT("js_browser"), _SLIT("js_freestanding"), _SLIT("interpreter"), _SLIT("es5")}));
	_const_v__checker__valid_comptime_not_user_defined = v__checker__all_valid_comptime_idents();
	_const_v__checker__array_builtin_methods = new_array_from_c_array(15, 15, sizeof(string), _MOV((string[15]){
		_SLIT("filter"), _SLIT("clone"), _SLIT("repeat"), _SLIT("reverse"), _SLIT("map"), _SLIT("slice"), _SLIT("sort"), _SLIT("contains"), _SLIT("index"),
		_SLIT("wait"), _SLIT("any"), _SLIT("all"), _SLIT("first"), _SLIT("last"), _SLIT("pop")}));
	_const_v__checker__reserved_type_names = new_array_from_c_array(15, 15, sizeof(string), _MOV((string[15]){
		_SLIT("bool"), _SLIT("char"), _SLIT("i8"), _SLIT("i16"), _SLIT("int"), _SLIT("i64"), _SLIT("byte"), _SLIT("u16"), _SLIT("u32"),
		_SLIT("u64"), _SLIT("f32"), _SLIT("f64"), _SLIT("map"), _SLIT("string"), _SLIT("rune")}));
	}
	{ // Initializations for module v.transformer :
	}
	{ // Initializations for module v.markused :
	}
	{ // Initializations for module v.gen.c :
	_const_v__gen__c__unsupported_ctemp_assert_transform = I_v__gen__c__UnsupportedAssertCtempTransform_to_Interface_IError((v__gen__c__UnsupportedAssertCtempTransform*)memdup(&(v__gen__c__UnsupportedAssertCtempTransform){.msg = (string){.str=(byteptr)"", .is_lit=1},.code = 0,}, sizeof(v__gen__c__UnsupportedAssertCtempTransform)));
	_const_v__gen__c__c_reserved = new_array_from_c_array(57, 57, sizeof(string), _MOV((string[57]){
		_SLIT("array"), _SLIT("auto"), _SLIT("bool"), _SLIT("break"), _SLIT("calloc"), _SLIT("case"), _SLIT("char"), _SLIT("class"), _SLIT("complex"),
		_SLIT("const"), _SLIT("continue"), _SLIT("default"), _SLIT("delete"), _SLIT("do"), _SLIT("double"), _SLIT("else"), _SLIT("enum"),
		_SLIT("error"), _SLIT("exit"), _SLIT("export"), _SLIT("extern"), _SLIT("float"), _SLIT("for"), _SLIT("free"), _SLIT("goto"),
		_SLIT("if"), _SLIT("inline"), _SLIT("int"), _SLIT("link"), _SLIT("long"), _SLIT("malloc"), _SLIT("namespace"), _SLIT("new"),
		_SLIT("panic"), _SLIT("register"), _SLIT("restrict"), _SLIT("return"), _SLIT("short"), _SLIT("signed"), _SLIT("sizeof"), _SLIT("static"),
		_SLIT("string"), _SLIT("struct"), _SLIT("switch"), _SLIT("typedef"), _SLIT("typename"), _SLIT("union"), _SLIT("unix"), _SLIT("unsigned"),
		_SLIT("void"), _SLIT("volatile"), _SLIT("while"), _SLIT("template"), _SLIT("small"), _SLIT("stdout"), _SLIT("stdin"), _SLIT("stderr")}));
	_const_v__gen__c__c_reserved_map = v__gen__c__string_array_to_map(_const_v__gen__c__c_reserved);
	_const_v__gen__c__cmp_str = new_array_from_c_array(6, 6, sizeof(string), _MOV((string[6]){_SLIT("eq"), _SLIT("ne"), _SLIT("gt"), _SLIT("lt"), _SLIT("ge"), _SLIT("le")}));
	_const_v__gen__c__cmp_rev = new_array_from_c_array(6, 6, sizeof(string), _MOV((string[6]){_SLIT("eq"), _SLIT("ne"), _SLIT("lt"), _SLIT("gt"), _SLIT("le"), _SLIT("ge")}));
	_const_v__gen__c__skip_struct_init = new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT("struct stat"), _SLIT("struct addrinfo")}));
	_const_v__gen__c__builtins = new_array_from_c_array(7, 7, sizeof(string), _MOV((string[7]){_SLIT("string"), _SLIT("array"), _SLIT("DenseArray"), _SLIT("map"), _SLIT("Error"), _SLIT("IError"), _SLIT("Option")}));
	_const_v__gen__c__c_headers = _SLIT("//============================== HELPER C MACROS =============================*/\n// _SLIT0 is used as NULL string for literal arguments\n// `\"\" s` is used to enforce a string literal argument\n#define _SLIT0 (string){.str=(byteptr)(\"\"), .len=0, .is_lit=1}\n#define _SLIT(s) ((string){.str=(byteptr)(\"\" s), .len=(sizeof(s)-1), .is_lit=1})\n#define _SLEN(s, n) ((string){.str=(byteptr)(\"\" s), .len=n, .is_lit=1})\n\n// take the address of an rvalue\n#define ADDR(type, expr) (&((type[]){expr}[0]))\n\n// copy something to the heap\n#define HEAP(type, expr) ((type*)memdup((void*)&((type[]){expr}[0]), sizeof(type)))\n#define HEAP_noscan(type, expr) ((type*)memdup_noscan((void*)&((type[]){expr}[0]), sizeof(type)))\n\n#define _PUSH_MANY(arr, val, tmp, tmp_typ) {tmp_typ tmp = (val); array_push_many(arr, tmp.data, tmp.len);}\n#define _PUSH_MANY_noscan(arr, val, tmp, tmp_typ) {tmp_typ tmp = (val); array_push_many_noscan(arr, tmp.data, tmp.len);}\n\n// unsigned/signed comparisons\nstatic inline bool _us32_gt(uint32_t a, int32_t b) { return a > INT32_MAX || (int32_t)a > b; }\nstatic inline bool _us32_ge(uint32_t a, int32_t b) { return a >= INT32_MAX || (int32_t)a >= b; }\nstatic inline bool _us32_eq(uint32_t a, int32_t b) { return a <= INT32_MAX && (int32_t)a == b; }\nstatic inline bool _us32_ne(uint32_t a, int32_t b) { return a > INT32_MAX || (int32_t)a != b; }\nstatic inline bool _us32_le(uint32_t a, int32_t b) { return a <= INT32_MAX && (int32_t)a <= b; }\nstatic inline bool _us32_lt(uint32_t a, int32_t b) { return a < INT32_MAX && (int32_t)a < b; }\nstatic inline bool _us64_gt(uint64_t a, int64_t b) { return a > INT64_MAX || (int64_t)a > b; }\nstatic inline bool _us64_ge(uint64_t a, int64_t b) { return a >= INT64_MAX || (int64_t)a >= b; }\nstatic inline bool _us64_eq(uint64_t a, int64_t b) { return a <= INT64_MAX && (int64_t)a == b; }\nstatic inline bool _us64_ne(uint64_t a, int64_t b) { return a > INT64_MAX || (int64_t)a != b; }\nstatic inline bool _us64_le(uint64_t a, int64_t b) { return a <= INT64_MAX && (int64_t)a <= b; }\nstatic inline bool _us64_lt(uint64_t a, int64_t b) { return a < INT64_MAX && (int64_t)a < b; }\n\n#define EMPTY_VARG_INITIALIZATION 0\n#define EMPTY_STRUCT_DECLARATION\n#define EMPTY_STRUCT_INITIALIZATION\n// Due to a tcc bug, the length of an array needs to be specified, but GCC crashes if it is...\n#define EMPTY_ARRAY_OF_ELEMS(x,n) (x[])\n#define TCCSKIP(x) x\n\n#define __NOINLINE __attribute__((noinline))\n#define __IRQHANDLER __attribute__((interrupt))\n\n#define __V_architecture 0\n#if defined(__x86_64__)\n	#define __V_amd64  1\n	#undef __V_architecture\n	#define __V_architecture 1\n#endif\n\n#if defined(__aarch64__) || defined(__arm64__)\n	#define __V_arm64  1\n	#undef __V_architecture\n	#define __V_architecture 2\n#endif\n\n// Using just __GNUC__ for detecting gcc, is not reliable because other compilers define it too:\n#ifdef __GNUC__\n	#define __V_GCC__\n#endif\n#ifdef __TINYC__\n	#undef __V_GCC__\n#endif\n#ifdef __cplusplus\n	#undef __V_GCC__\n#endif\n#ifdef __clang__\n	#undef __V_GCC__\n#endif\n#ifdef _MSC_VER\n	#undef __V_GCC__\n	#undef EMPTY_STRUCT_INITIALIZATION\n	#define EMPTY_STRUCT_INITIALIZATION 0\n#endif\n\n#ifdef __TINYC__\n	#undef EMPTY_STRUCT_DECLARATION\n	#define EMPTY_STRUCT_DECLARATION char _dummy\n	#undef EMPTY_ARRAY_OF_ELEMS\n	#define EMPTY_ARRAY_OF_ELEMS(x,n) (x[n])\n	#undef __NOINLINE\n	#undef __IRQHANDLER\n	// tcc does not support inlining at all\n	#define __NOINLINE\n	#define __IRQHANDLER\n	#undef TCCSKIP\n	#define TCCSKIP(x)\n	// #include <byteswap.h>\n	#ifndef _WIN32\n		#include <execinfo.h>\n		int tcc_backtrace(const char *fmt, ...);\n	#endif\n#endif\n\n// Use __offsetof_ptr instead of __offset_of, when you *do* have a valid pointer, to avoid UB:\n#ifndef __offsetof_ptr\n	#define __offsetof_ptr(ptr,PTYPE,FIELDNAME) ((size_t)((byte *)&((PTYPE *)ptr)->FIELDNAME - (byte *)ptr))\n#endif\n\n// for __offset_of\n#ifndef __offsetof\n	#define __offsetof(PTYPE,FIELDNAME) ((size_t)((char *)&((PTYPE *)0)->FIELDNAME - (char *)0))\n#endif\n\n// returns the number of CPU registers that TYPE takes up\n#define _REG_WIDTH(T) (((sizeof(T) + sizeof(void*) - 1) & ~(sizeof(void*) - 1)) / sizeof(void*))\n\n#define OPTION_CAST(x) (x)\n\n#ifndef V64_PRINTFORMAT\n	#ifdef PRIx64\n		#define V64_PRINTFORMAT \"0x%\"PRIx64\n	#elif defined(__WIN32__)\n		#define V64_PRINTFORMAT \"0x%I64x\"\n	#elif defined(__linux__) && defined(__LP64__)\n		#define V64_PRINTFORMAT \"0x%lx\"\n	#else\n		#define V64_PRINTFORMAT \"0x%llx\"\n	#endif\n#endif\n\n#if defined(_WIN32) || defined(__CYGWIN__)\n	#define VV_EXPORTED_SYMBOL extern __declspec(dllexport)\n	#define VV_LOCAL_SYMBOL static\n#else\n	// 4 < gcc < 5 is used by some older Ubuntu LTS and Centos versions,\n	// and does not support __has_attribute(visibility) ...\n	#ifndef __has_attribute\n		#define __has_attribute(x) 0  // Compatibility with non-clang compilers.\n	#endif\n	#if (defined(__GNUC__) && (__GNUC__ >= 4)) || (defined(__clang__) && __has_attribute(visibility))\n		#ifdef ARM\n			#define VV_EXPORTED_SYMBOL  extern __attribute__((externally_visible,visibility(\"default\")))\n		#else\n			#define VV_EXPORTED_SYMBOL  extern __attribute__((visibility(\"default\")))\n		#endif\n		#define VV_LOCAL_SYMBOL  __attribute__ ((visibility (\"hidden\")))\n	#else\n		#define VV_EXPORTED_SYMBOL extern\n		#define VV_LOCAL_SYMBOL static\n	#endif\n#endif\n\n#ifdef __cplusplus\n	#include <utility>\n	#define _MOV std::move\n#else\n	#define _MOV\n#endif\n\n// tcc does not support has_include properly yet, turn it off completely\n#if defined(__TINYC__) && defined(__has_include)\n#undef __has_include\n#endif\n\n\n#if !defined(VWEAK)\n	#define VWEAK __attribute__((weak))\n	#ifdef _MSC_VER\n		#undef VWEAK\n		#define VWEAK\n	#endif\n#endif\n\n#if !defined(VNORETURN)\n	#if defined(__TINYC__)\n		#include <stdnoreturn.h>\n		#define VNORETURN noreturn\n	#endif\n	# if !defined(__TINYC__) && defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L\n	#  define VNORETURN _Noreturn\n	# elif defined(__GNUC__) && __GNUC__ >= 2\n	#  define VNORETURN __attribute__((noreturn))\n	# endif\n	#ifndef VNORETURN\n		#define VNORETURN\n	#endif\n#endif\n\n#if !defined(VUNREACHABLE)\n	#if defined(__GNUC__) && !defined(__clang__)\n		#define V_GCC_VERSION  (__GNUC__ * 10000L + __GNUC_MINOR__ * 100L + __GNUC_PATCHLEVEL__)\n		#if (V_GCC_VERSION >= 40500L)\n			#define VUNREACHABLE()  do { __builtin_unreachable(); } while (0)\n		#endif\n	#endif\n	#if defined(__clang__) && defined(__has_builtin)\n		#if __has_builtin(__builtin_unreachable)\n			#define VUNREACHABLE()  do { __builtin_unreachable(); } while (0)\n		#endif\n	#endif\n	#ifndef VUNREACHABLE\n		#define VUNREACHABLE() do { } while (0)\n	#endif\n	#if defined(__FreeBSD__) && defined(__TINYC__)\n		#define VUNREACHABLE() do { } while (0)\n	#endif\n#endif\n\n//likely and unlikely macros\n#if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)\n	#define _likely_(x)  __builtin_expect(x,1)\n	#define _unlikely_(x)  __builtin_expect(x,0)\n#else\n	#define _likely_(x) (x)\n	#define _unlikely_(x) (x)\n#endif\n\n\n// c_headers\ntypedef int (*qsort_callback_func)(const void*, const void*);\n#include <stdio.h>  // TODO remove all these includes, define all function signatures and types manually\n#include <stdlib.h>\n#include <string.h>\n\n#if defined(_WIN32) || defined(__CYGWIN__)\n	#define VV_EXPORTED_SYMBOL extern __declspec(dllexport)\n	#define VV_LOCAL_SYMBOL static\n#else\n	// 4 < gcc < 5 is used by some older Ubuntu LTS and Centos versions,\n	// and does not support __has_attribute(visibility) ...\n	#ifndef __has_attribute\n		#define __has_attribute(x) 0  // Compatibility with non-clang compilers.\n	#endif\n	#if (defined(__GNUC__) && (__GNUC__ >= 4)) || (defined(__clang__) && __has_attribute(visibility))\n		#ifdef ARM\n			#define VV_EXPORTED_SYMBOL  extern __attribute__((externally_visible,visibility(\"default\")))\n		#else\n			#define VV_EXPORTED_SYMBOL  extern __attribute__((visibility(\"default\")))\n		#endif\n		#define VV_LOCAL_SYMBOL  __attribute__ ((visibility (\"hidden\")))\n	#else\n		#define VV_EXPORTED_SYMBOL extern\n		#define VV_LOCAL_SYMBOL static\n	#endif\n#endif\n\n#if defined(__TINYC__) && defined(__has_include)\n// tcc does not support has_include properly yet, turn it off completely\n#undef __has_include\n#endif\n\n#ifndef _WIN32\n	#if defined __has_include\n		#if __has_include (<execinfo.h>)\n			#include <execinfo.h>\n		#else\n			// Most probably musl OR __ANDROID__ ...\n			int backtrace (void **__array, int __size) { return 0; }\n			char **backtrace_symbols (void *const *__array, int __size){ return 0; }\n			void backtrace_symbols_fd (void *const *__array, int __size, int __fd){}\n		#endif\n	#endif\n#endif\n\n#include <stdarg.h> // for va_list\n\n//================================== GLOBALS =================================*/\nint load_so(byteptr);\nvoid _vinit(int ___argc, voidptr ___argv);\nvoid _vcleanup(void);\n#define sigaction_size sizeof(sigaction);\n#define _ARR_LEN(a) ( (sizeof(a)) / (sizeof(a[0])) )\n\nvoid v_free(voidptr ptr);\nvoidptr memdup(voidptr src, int sz);\n\n#if INTPTR_MAX == INT32_MAX\n	#define TARGET_IS_32BIT 1\n#elif INTPTR_MAX == INT64_MAX\n	#define TARGET_IS_64BIT 1\n#else\n	#error \"The environment is not 32 or 64-bit.\"\n#endif\n\n#if defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__ || defined(__BYTE_ORDER) && __BYTE_ORDER == __BIG_ENDIAN || defined(__BIG_ENDIAN__) || defined(__ARMEB__) || defined(__THUMBEB__) || defined(__AARCH64EB__) || defined(_MIBSEB) || defined(__MIBSEB) || defined(__MIBSEB__)\n	#define TARGET_ORDER_IS_BIG 1\n#elif defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__ || defined(__BYTE_ORDER) && __BYTE_ORDER == __LITTLE_ENDIAN || defined(__LITTLE_ENDIAN__) || defined(__ARMEL__) || defined(__THUMBEL__) || defined(__AARCH64EL__) || defined(_MIPSEL) || defined(__MIPSEL) || defined(__MIPSEL__) || defined(_M_AMD64) || defined(_M_X64) || defined(_M_IX86)\n	#define TARGET_ORDER_IS_LITTLE 1\n#else\n	#error \"Unknown architecture endianness\"\n#endif\n\n#ifndef _WIN32\n	#include <ctype.h>\n	#include <locale.h> // tolower\n	#include <sys/time.h>\n	#include <unistd.h> // sleep\n	extern char **environ;\n#endif\n\n#if defined(__CYGWIN__) && !defined(_WIN32)\n	#error Cygwin is not supported, please use MinGW or Visual Studio.\n#endif\n\n#if defined(__linux__) || defined(__FreeBSD__) || defined(__DragonFly__) || defined(__vinix__) || defined(__serenity__) || defined(__sun)\n	#include <sys/types.h>\n	#include <sys/wait.h> // os__wait uses wait on nix\n#endif\n\n#ifdef __OpenBSD__\n	#include <sys/types.h>\n	#include <sys/resource.h>\n	#include <sys/wait.h> // os__wait uses wait on nix\n#endif\n\n#ifdef __NetBSD__\n	#include <sys/wait.h> // os__wait uses wait on nix\n#endif\n\n#ifdef _WIN32\n	#define WINVER 0x0600\n	#ifdef _WIN32_WINNT\n		#undef _WIN32_WINNT\n	#endif\n	#define _WIN32_WINNT 0x0600\n	#ifndef WIN32_FULL\n	#define WIN32_LEAN_AND_MEAN\n	#endif\n	#ifndef _UNICODE\n	#define _UNICODE\n	#endif\n	#ifndef UNICODE\n	#define UNICODE\n	#endif\n	#include <windows.h>\n\n	#include <io.h> // _waccess\n	#include <direct.h> // _wgetcwd\n	#include <signal.h> // signal and SIGSEGV for segmentation fault handler\n\n	#ifdef _MSC_VER\n		// On MSVC these are the same (as long as /volatile:ms is passed)\n		#define _Atomic volatile\n\n		// MSVC cannot parse some things properly\n		#undef EMPTY_STRUCT_DECLARATION\n		#undef OPTION_CAST\n\n		#define EMPTY_STRUCT_DECLARATION char __pad\n		#define OPTION_CAST(x)\n		#undef __NOINLINE\n		#undef __IRQHANDLER\n		#define __NOINLINE __declspec(noinline)\n		#define __IRQHANDLER __declspec(naked)\n\n		#include <dbghelp.h>\n		#pragma comment(lib, \"Dbghelp\")\n	#endif\n#else\n	#include <pthread.h>\n	#ifndef PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP\n		// musl does not have that\n		#define pthread_rwlockattr_setkind_np(a, b)\n	#endif\n#endif\n\n// g_live_info is used by live.info()\nstatic void* g_live_info = NULL;\n\n#if defined(__MINGW32__) || defined(__MINGW64__) || (defined(_WIN32) && defined(__TINYC__))\n	#undef PRId64\n	#undef PRIi64\n	#undef PRIo64\n	#undef PRIu64\n	#undef PRIx64\n	#undef PRIX64\n	#define PRId64 \"lld\"\n	#define PRIi64 \"lli\"\n	#define PRIo64 \"llo\"\n	#define PRIu64 \"llu\"\n	#define PRIx64 \"llx\"\n	#define PRIX64 \"llX\"\n#endif\n\n#ifdef _VFREESTANDING\n#undef _VFREESTANDING\n#endif\n");
	_const_v__gen__c__c_bare_headers = _SLIT("//============================== HELPER C MACROS =============================*/\n// _SLIT0 is used as NULL string for literal arguments\n// `\"\" s` is used to enforce a string literal argument\n#define _SLIT0 (string){.str=(byteptr)(\"\"), .len=0, .is_lit=1}\n#define _SLIT(s) ((string){.str=(byteptr)(\"\" s), .len=(sizeof(s)-1), .is_lit=1})\n#define _SLEN(s, n) ((string){.str=(byteptr)(\"\" s), .len=n, .is_lit=1})\n\n// take the address of an rvalue\n#define ADDR(type, expr) (&((type[]){expr}[0]))\n\n// copy something to the heap\n#define HEAP(type, expr) ((type*)memdup((void*)&((type[]){expr}[0]), sizeof(type)))\n#define HEAP_noscan(type, expr) ((type*)memdup_noscan((void*)&((type[]){expr}[0]), sizeof(type)))\n\n#define _PUSH_MANY(arr, val, tmp, tmp_typ) {tmp_typ tmp = (val); array_push_many(arr, tmp.data, tmp.len);}\n#define _PUSH_MANY_noscan(arr, val, tmp, tmp_typ) {tmp_typ tmp = (val); array_push_many_noscan(arr, tmp.data, tmp.len);}\n\n// unsigned/signed comparisons\nstatic inline bool _us32_gt(uint32_t a, int32_t b) { return a > INT32_MAX || (int32_t)a > b; }\nstatic inline bool _us32_ge(uint32_t a, int32_t b) { return a >= INT32_MAX || (int32_t)a >= b; }\nstatic inline bool _us32_eq(uint32_t a, int32_t b) { return a <= INT32_MAX && (int32_t)a == b; }\nstatic inline bool _us32_ne(uint32_t a, int32_t b) { return a > INT32_MAX || (int32_t)a != b; }\nstatic inline bool _us32_le(uint32_t a, int32_t b) { return a <= INT32_MAX && (int32_t)a <= b; }\nstatic inline bool _us32_lt(uint32_t a, int32_t b) { return a < INT32_MAX && (int32_t)a < b; }\nstatic inline bool _us64_gt(uint64_t a, int64_t b) { return a > INT64_MAX || (int64_t)a > b; }\nstatic inline bool _us64_ge(uint64_t a, int64_t b) { return a >= INT64_MAX || (int64_t)a >= b; }\nstatic inline bool _us64_eq(uint64_t a, int64_t b) { return a <= INT64_MAX && (int64_t)a == b; }\nstatic inline bool _us64_ne(uint64_t a, int64_t b) { return a > INT64_MAX || (int64_t)a != b; }\nstatic inline bool _us64_le(uint64_t a, int64_t b) { return a <= INT64_MAX && (int64_t)a <= b; }\nstatic inline bool _us64_lt(uint64_t a, int64_t b) { return a < INT64_MAX && (int64_t)a < b; }\n\n#define EMPTY_VARG_INITIALIZATION 0\n#define EMPTY_STRUCT_DECLARATION\n#define EMPTY_STRUCT_INITIALIZATION\n// Due to a tcc bug, the length of an array needs to be specified, but GCC crashes if it is...\n#define EMPTY_ARRAY_OF_ELEMS(x,n) (x[])\n#define TCCSKIP(x) x\n\n#define __NOINLINE __attribute__((noinline))\n#define __IRQHANDLER __attribute__((interrupt))\n\n#define __V_architecture 0\n#if defined(__x86_64__)\n	#define __V_amd64  1\n	#undef __V_architecture\n	#define __V_architecture 1\n#endif\n\n#if defined(__aarch64__) || defined(__arm64__)\n	#define __V_arm64  1\n	#undef __V_architecture\n	#define __V_architecture 2\n#endif\n\n// Using just __GNUC__ for detecting gcc, is not reliable because other compilers define it too:\n#ifdef __GNUC__\n	#define __V_GCC__\n#endif\n#ifdef __TINYC__\n	#undef __V_GCC__\n#endif\n#ifdef __cplusplus\n	#undef __V_GCC__\n#endif\n#ifdef __clang__\n	#undef __V_GCC__\n#endif\n#ifdef _MSC_VER\n	#undef __V_GCC__\n	#undef EMPTY_STRUCT_INITIALIZATION\n	#define EMPTY_STRUCT_INITIALIZATION 0\n#endif\n\n#ifdef __TINYC__\n	#undef EMPTY_STRUCT_DECLARATION\n	#define EMPTY_STRUCT_DECLARATION char _dummy\n	#undef EMPTY_ARRAY_OF_ELEMS\n	#define EMPTY_ARRAY_OF_ELEMS(x,n) (x[n])\n	#undef __NOINLINE\n	#undef __IRQHANDLER\n	// tcc does not support inlining at all\n	#define __NOINLINE\n	#define __IRQHANDLER\n	#undef TCCSKIP\n	#define TCCSKIP(x)\n	// #include <byteswap.h>\n	#ifndef _WIN32\n		#include <execinfo.h>\n		int tcc_backtrace(const char *fmt, ...);\n	#endif\n#endif\n\n// Use __offsetof_ptr instead of __offset_of, when you *do* have a valid pointer, to avoid UB:\n#ifndef __offsetof_ptr\n	#define __offsetof_ptr(ptr,PTYPE,FIELDNAME) ((size_t)((byte *)&((PTYPE *)ptr)->FIELDNAME - (byte *)ptr))\n#endif\n\n// for __offset_of\n#ifndef __offsetof\n	#define __offsetof(PTYPE,FIELDNAME) ((size_t)((char *)&((PTYPE *)0)->FIELDNAME - (char *)0))\n#endif\n\n// returns the number of CPU registers that TYPE takes up\n#define _REG_WIDTH(T) (((sizeof(T) + sizeof(void*) - 1) & ~(sizeof(void*) - 1)) / sizeof(void*))\n\n#define OPTION_CAST(x) (x)\n\n#ifndef V64_PRINTFORMAT\n	#ifdef PRIx64\n		#define V64_PRINTFORMAT \"0x%\"PRIx64\n	#elif defined(__WIN32__)\n		#define V64_PRINTFORMAT \"0x%I64x\"\n	#elif defined(__linux__) && defined(__LP64__)\n		#define V64_PRINTFORMAT \"0x%lx\"\n	#else\n		#define V64_PRINTFORMAT \"0x%llx\"\n	#endif\n#endif\n\n#if defined(_WIN32) || defined(__CYGWIN__)\n	#define VV_EXPORTED_SYMBOL extern __declspec(dllexport)\n	#define VV_LOCAL_SYMBOL static\n#else\n	// 4 < gcc < 5 is used by some older Ubuntu LTS and Centos versions,\n	// and does not support __has_attribute(visibility) ...\n	#ifndef __has_attribute\n		#define __has_attribute(x) 0  // Compatibility with non-clang compilers.\n	#endif\n	#if (defined(__GNUC__) && (__GNUC__ >= 4)) || (defined(__clang__) && __has_attribute(visibility))\n		#ifdef ARM\n			#define VV_EXPORTED_SYMBOL  extern __attribute__((externally_visible,visibility(\"default\")))\n		#else\n			#define VV_EXPORTED_SYMBOL  extern __attribute__((visibility(\"default\")))\n		#endif\n		#define VV_LOCAL_SYMBOL  __attribute__ ((visibility (\"hidden\")))\n	#else\n		#define VV_EXPORTED_SYMBOL extern\n		#define VV_LOCAL_SYMBOL static\n	#endif\n#endif\n\n#ifdef __cplusplus\n	#include <utility>\n	#define _MOV std::move\n#else\n	#define _MOV\n#endif\n\n// tcc does not support has_include properly yet, turn it off completely\n#if defined(__TINYC__) && defined(__has_include)\n#undef __has_include\n#endif\n\n\n#if !defined(VWEAK)\n	#define VWEAK __attribute__((weak))\n	#ifdef _MSC_VER\n		#undef VWEAK\n		#define VWEAK\n	#endif\n#endif\n\n#if !defined(VNORETURN)\n	#if defined(__TINYC__)\n		#include <stdnoreturn.h>\n		#define VNORETURN noreturn\n	#endif\n	# if !defined(__TINYC__) && defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L\n	#  define VNORETURN _Noreturn\n	# elif defined(__GNUC__) && __GNUC__ >= 2\n	#  define VNORETURN __attribute__((noreturn))\n	# endif\n	#ifndef VNORETURN\n		#define VNORETURN\n	#endif\n#endif\n\n#if !defined(VUNREACHABLE)\n	#if defined(__GNUC__) && !defined(__clang__)\n		#define V_GCC_VERSION  (__GNUC__ * 10000L + __GNUC_MINOR__ * 100L + __GNUC_PATCHLEVEL__)\n		#if (V_GCC_VERSION >= 40500L)\n			#define VUNREACHABLE()  do { __builtin_unreachable(); } while (0)\n		#endif\n	#endif\n	#if defined(__clang__) && defined(__has_builtin)\n		#if __has_builtin(__builtin_unreachable)\n			#define VUNREACHABLE()  do { __builtin_unreachable(); } while (0)\n		#endif\n	#endif\n	#ifndef VUNREACHABLE\n		#define VUNREACHABLE() do { } while (0)\n	#endif\n	#if defined(__FreeBSD__) && defined(__TINYC__)\n		#define VUNREACHABLE() do { } while (0)\n	#endif\n#endif\n\n//likely and unlikely macros\n#if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)\n	#define _likely_(x)  __builtin_expect(x,1)\n	#define _unlikely_(x)  __builtin_expect(x,0)\n#else\n	#define _likely_(x) (x)\n	#define _unlikely_(x) (x)\n#endif\n\n\n#define _VFREESTANDING\n\ntypedef long unsigned int size_t;\n\n// Memory allocation related headers\nvoid *malloc(size_t size);\nvoid *calloc(size_t nitems, size_t size);\nvoid *realloc(void *ptr, size_t size);\nvoid *memcpy(void *dest, void *src, size_t n);\nvoid *memset(void *s, int c, size_t n);\nvoid *memmove(void *dest, void *src, size_t n);\n\n// varargs implementation, TODO: works on tcc and gcc, but is very unportable and hacky\ntypedef __builtin_va_list va_list;\n#define va_start(a, b) __builtin_va_start(a, b)\n#define va_end(a)      __builtin_va_end(a)\n#define va_arg(a, b)   __builtin_va_arg(a, b)\n#define va_copy(a, b)  __builtin_va_copy(a, b)\n\n//================================== GLOBALS =================================*/\nint load_so(byteptr);\nvoid _vinit(int ___argc, voidptr ___argv);\nvoid _vcleanup();\n#define sigaction_size sizeof(sigaction);\n#define _ARR_LEN(a) ( (sizeof(a)) / (sizeof(a[0])) )\n\nvoid v_free(voidptr ptr);\nvoidptr memdup(voidptr src, int sz);\n\n");
	}
	{ // Initializations for module v.scanner :
	}
	{ // Initializations for module v.ast.walker :
	}
	{ // Initializations for module v.parser :
	_const_v__parser__supported_comptime_calls = new_array_from_c_array(5, 5, sizeof(string), _MOV((string[5]){_SLIT("html"), _SLIT("tmpl"), _SLIT("env"), _SLIT("embed_file"), _SLIT("pkgconfig")}));
	_const_v__parser__builtin_functions = new_array_from_c_array(7, 7, sizeof(string), _MOV((string[7]){_SLIT("print"), _SLIT("println"), _SLIT("eprint"), _SLIT("eprintln"), _SLIT("isnil"), _SLIT("panic"), _SLIT("exit")}));
	_const_v__parser__valid_tokens_inside_types = new_array_from_c_array(7, 7, sizeof(v__token__Kind), _MOV((v__token__Kind[7]){v__token__Kind__lsbr, v__token__Kind__rsbr, v__token__Kind__name, v__token__Kind__dot, v__token__Kind__comma, v__token__Kind__key_fn, v__token__Kind__lt}));
	}
	{ // Initializations for module v.callgraph :
	}
	{ // Initializations for module v.builder :
	_const_v__builder__hkey_local_machine = ((v__builder__RegKey)(0x80000002));
	}
	{ // Initializations for module v.builder.cbuilder :
	}
	{ // Initializations for module main :
	_const_main__external_tools = new_array_from_c_array(30, 30, sizeof(string), _MOV((string[30]){
		_SLIT("ast"), _SLIT("bin2v"), _SLIT("bug"), _SLIT("build-examples"), _SLIT("build-tools"), _SLIT("build-vbinaries"), _SLIT("bump"), _SLIT("check-md"), _SLIT("complete"),
		_SLIT("compress"), _SLIT("doc"), _SLIT("doctor"), _SLIT("fmt"), _SLIT("gret"), _SLIT("repl"), _SLIT("self"), _SLIT("setup-freetype"),
		_SLIT("shader"), _SLIT("symlink"), _SLIT("test"), _SLIT("test-all"), _SLIT("test-cleancode"), _SLIT("test-fmt"), _SLIT("test-parser"), _SLIT("test-self"),
		_SLIT("tracev"), _SLIT("up"), _SLIT("vet"), _SLIT("wipe-cache"), _SLIT("watch")}));
	_const_main__list_of_flags_that_allow_duplicates = new_array_from_c_array(5, 5, sizeof(string), _MOV((string[5]){_SLIT("cc"), _SLIT("d"), _SLIT("define"), _SLIT("cf"), _SLIT("cflags")}));
	}
}
void _vcleanup(void) {
}

int wmain(int ___argc, wchar_t* ___argv[], wchar_t* ___envp[]){
	_vinit(___argc, (voidptr)___argv);
	main__main();
	_vcleanup();
	return 0;
}

// THE END.
