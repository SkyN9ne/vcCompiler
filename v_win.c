#define V_COMMIT_HASH "a851901"

#ifndef V_COMMIT_HASH
	#define V_COMMIT_HASH "85e9cf1"
#endif

#ifndef V_CURRENT_COMMIT_HASH
	#define V_CURRENT_COMMIT_HASH "a851901"
#endif

// V comptime_defines:

// V typedefs:
typedef struct v__ast__TypeDecl v__ast__TypeDecl;
typedef struct v__ast__Expr v__ast__Expr;
typedef struct v__ast__Stmt v__ast__Stmt;
typedef struct v__ast__ScopeObject v__ast__ScopeObject;
typedef struct v__ast__Node v__ast__Node;
typedef struct v__ast__IdentInfo v__ast__IdentInfo;
typedef struct v__ast__AsmArg v__ast__AsmArg;
typedef struct v__ast__TypeInfo v__ast__TypeInfo;

// BEGIN_multi_return_typedefs
typedef struct multi_return_u32_u32 multi_return_u32_u32;
typedef struct multi_return_u32_u32_u32 multi_return_u32_u32_u32;
typedef struct multi_return_int_strconv__PrepNumber multi_return_int_strconv__PrepNumber;
typedef struct multi_return_u64_int multi_return_u64_int;
typedef struct multi_return_strconv__Dec32_bool multi_return_strconv__Dec32_bool;
typedef struct multi_return_strconv__Dec64_bool multi_return_strconv__Dec64_bool;
typedef struct multi_return_string_int multi_return_string_int;
typedef struct multi_return_int_bool multi_return_int_bool;
typedef struct multi_return_v__pref__Preferences_string multi_return_v__pref__Preferences_string;
typedef struct multi_return_string_string multi_return_string_string;
typedef struct multi_return_u64_u64 multi_return_u64_u64;
typedef struct multi_return_int_int_int multi_return_int_int_int;
typedef struct multi_return_int_int_int_int_i64_bool multi_return_int_int_int_int_i64_bool;
typedef struct multi_return_int_int multi_return_int_int;
typedef struct multi_return_Array_string_int multi_return_Array_string_int;
typedef struct multi_return_Array_string_v__vmod__ModFileAndFolder multi_return_Array_string_v__vmod__ModFileAndFolder;
typedef struct multi_return_bool_string multi_return_bool_string;
typedef struct multi_return_v__ast__ScopeObject_v__ast__Scope multi_return_v__ast__ScopeObject_v__ast__Scope;
typedef struct multi_return_string_bool multi_return_string_bool;
typedef struct multi_return_bool_bool_int multi_return_bool_bool_int;
typedef struct multi_return_string_v__token__Position multi_return_string_v__token__Position;
typedef struct multi_return_bool_int_int multi_return_bool_int_int;
typedef struct multi_return_Array_v__ast__Param_bool_bool multi_return_Array_v__ast__Param_bool_bool;
typedef struct multi_return_v__ast__File_Array_v__vet__Error multi_return_v__ast__File_Array_v__vet__Error;
typedef struct multi_return_Array_v__ast__Expr_Array_v__ast__Comment multi_return_Array_v__ast__Expr_Array_v__ast__Comment;
typedef struct multi_return_string_string_string_string multi_return_string_string_string_string;
typedef struct multi_return_int_string_string_string multi_return_int_string_string_string;
typedef struct multi_return_Array_string_Array_string multi_return_Array_string_Array_string;
typedef struct multi_return_Map_string_v__ast__FnDecl_Map_string_v__ast__ConstField multi_return_Map_string_v__ast__FnDecl_Map_string_v__ast__ConstField;
typedef struct multi_return_Array_string_Array_string_Array_string multi_return_Array_string_Array_string_Array_string;
// END_multi_return_typedefs

typedef struct strings__Builder strings__Builder;
typedef struct strconv__BF_param strconv__BF_param;
typedef struct strconv__PrepNumber strconv__PrepNumber;
typedef struct strconv__Dec32 strconv__Dec32;
typedef struct strconv__Dec64 strconv__Dec64;
typedef struct strconv__Uint128 strconv__Uint128;
typedef union strconv__Uf32 strconv__Uf32;
typedef union strconv__Uf64 strconv__Uf64;
typedef union strconv__Float64u strconv__Float64u;
typedef struct array array;
typedef struct VCastTypeIndexName VCastTypeIndexName;
typedef struct VAssertMetaInfo VAssertMetaInfo;
typedef struct MethodArgs MethodArgs;
typedef struct FunctionData FunctionData;
typedef struct FieldData FieldData;
typedef struct SymbolInfo SymbolInfo;
typedef struct SymbolInfoContainer SymbolInfoContainer;
typedef struct Line64 Line64;
typedef struct ExceptionRecord ExceptionRecord;
typedef struct ContextRecord ContextRecord;
typedef struct ExceptionPointers ExceptionPointers;
typedef struct DenseArray DenseArray;
typedef struct map map;
typedef struct Error Error;
typedef struct None__ None__;
typedef struct Option Option;
typedef struct SortedMap SortedMap;
typedef struct mapnode mapnode;
typedef struct string string;
typedef struct ustring ustring;
typedef struct RepIndex RepIndex;
typedef struct os__File os__File;
typedef struct os__FileInfo os__FileInfo;
typedef struct os__FilePermission os__FilePermission;
typedef struct os__FileMode os__FileMode;
typedef struct os__Result os__Result;
typedef struct os__Uname os__Uname;
typedef struct os__Filetime os__Filetime;
typedef struct os__Win32finddata os__Win32finddata;
typedef struct os__ProcessInformation os__ProcessInformation;
typedef struct os__StartupInfo os__StartupInfo;
typedef struct os__SecurityAttributes os__SecurityAttributes;
typedef struct os__ExceptionRecord os__ExceptionRecord;
typedef struct os__ContextRecord os__ContextRecord;
typedef struct os__ExceptionPointers os__ExceptionPointers;
typedef struct os__Process os__Process;
typedef struct os__WProcess os__WProcess;
typedef struct time__StopWatchOptions time__StopWatchOptions;
typedef struct time__StopWatch time__StopWatch;
typedef struct time__Time time__Time;
typedef struct time__SystemTime time__SystemTime;
typedef struct v__token__Position v__token__Position;
typedef struct v__token__Token v__token__Token;
typedef struct v__depgraph__DepGraphNode v__depgraph__DepGraphNode;
typedef struct v__depgraph__DepGraph v__depgraph__DepGraph;
typedef struct v__depgraph__OrderedDepMap v__depgraph__OrderedDepMap;
typedef struct flag__Flag flag__Flag;
typedef struct flag__UnkownFlagError flag__UnkownFlagError;
typedef struct flag__MinimumArgsCountError flag__MinimumArgsCountError;
typedef struct flag__MaximumArgsCountError flag__MaximumArgsCountError;
typedef struct flag__NoArgsExpectedError flag__NoArgsExpectedError;
typedef struct flag__FlagParser flag__FlagParser;
typedef struct semver__RawVersion semver__RawVersion;
typedef struct semver__Comparator semver__Comparator;
typedef struct semver__ComparatorSet semver__ComparatorSet;
typedef struct semver__Range semver__Range;
typedef struct semver__InvalidComparatorCountError semver__InvalidComparatorCountError;
typedef struct semver__InvalidComparatorFormatError semver__InvalidComparatorFormatError;
typedef struct semver__Version semver__Version;
typedef struct semver__EmptyInputError semver__EmptyInputError;
typedef struct semver__InvalidVersionFormatError semver__InvalidVersionFormatError;
typedef struct v__vcache__CacheManager v__vcache__CacheManager;
typedef struct term__Coord term__Coord;
typedef struct v__vmod__Manifest v__vmod__Manifest;
typedef struct v__vmod__Scanner v__vmod__Scanner;
typedef struct v__vmod__Parser v__vmod__Parser;
typedef struct v__vmod__Token v__vmod__Token;
typedef struct v__vmod__ModFileAndFolder v__vmod__ModFileAndFolder;
typedef struct v__vmod__ModFileCacher v__vmod__ModFileCacher;
typedef struct v__cflag__CFlag v__cflag__CFlag;
typedef struct v__errors__Error v__errors__Error;
typedef struct v__errors__Warning v__errors__Warning;
typedef struct v__errors__Notice v__errors__Notice;
typedef struct v__pkgconfig__Main v__pkgconfig__Main;
typedef struct v__pkgconfig__MainOptions v__pkgconfig__MainOptions;
typedef struct v__pkgconfig__Options v__pkgconfig__Options;
typedef struct v__pkgconfig__PkgConfig v__pkgconfig__PkgConfig;
typedef struct v__vet__Error v__vet__Error;
typedef struct rand__wyrand__WyRandRNG rand__wyrand__WyRandRNG;
typedef struct rand__PRNGConfigStruct rand__PRNGConfigStruct;
typedef struct v__pref__Preferences v__pref__Preferences;
typedef struct v__util__EManager v__util__EManager;
typedef struct v__util__Possibility v__util__Possibility;
typedef struct v__util__Suggestion v__util__Suggestion;
typedef struct v__util__Timers v__util__Timers;
typedef struct v__ast__TypeNode v__ast__TypeNode;
typedef struct v__ast__EmptyExpr v__ast__EmptyExpr;
typedef struct v__ast__EmptyStmt v__ast__EmptyStmt;
typedef struct v__ast__EmptyNode v__ast__EmptyNode;
typedef struct v__ast__Block v__ast__Block;
typedef struct v__ast__ExprStmt v__ast__ExprStmt;
typedef struct v__ast__IntegerLiteral v__ast__IntegerLiteral;
typedef struct v__ast__FloatLiteral v__ast__FloatLiteral;
typedef struct v__ast__StringLiteral v__ast__StringLiteral;
typedef struct v__ast__StringInterLiteral v__ast__StringInterLiteral;
typedef struct v__ast__CharLiteral v__ast__CharLiteral;
typedef struct v__ast__BoolLiteral v__ast__BoolLiteral;
typedef struct v__ast__SelectorExpr v__ast__SelectorExpr;
typedef struct v__ast__Module v__ast__Module;
typedef struct v__ast__StructField v__ast__StructField;
typedef struct v__ast__ConstField v__ast__ConstField;
typedef struct v__ast__ConstDecl v__ast__ConstDecl;
typedef struct v__ast__StructDecl v__ast__StructDecl;
typedef struct v__ast__Embed v__ast__Embed;
typedef struct v__ast__StructEmbedding v__ast__StructEmbedding;
typedef struct v__ast__InterfaceDecl v__ast__InterfaceDecl;
typedef struct v__ast__StructInitField v__ast__StructInitField;
typedef struct v__ast__StructInitEmbed v__ast__StructInitEmbed;
typedef struct v__ast__StructInit v__ast__StructInit;
typedef struct v__ast__Import v__ast__Import;
typedef struct v__ast__ImportSymbol v__ast__ImportSymbol;
typedef struct v__ast__AnonFn v__ast__AnonFn;
typedef struct v__ast__FnDecl v__ast__FnDecl;
typedef struct v__ast__BranchStmt v__ast__BranchStmt;
typedef struct v__ast__CallExpr v__ast__CallExpr;
typedef struct v__ast__CallArg v__ast__CallArg;
typedef struct v__ast__Return v__ast__Return;
typedef struct v__ast__Var v__ast__Var;
typedef struct v__ast__ScopeStructField v__ast__ScopeStructField;
typedef struct v__ast__GlobalField v__ast__GlobalField;
typedef struct v__ast__GlobalDecl v__ast__GlobalDecl;
typedef struct v__ast__EmbeddedFile v__ast__EmbeddedFile;
typedef struct v__ast__File v__ast__File;
typedef struct v__ast__IdentFn v__ast__IdentFn;
typedef struct v__ast__IdentVar v__ast__IdentVar;
typedef struct v__ast__Ident v__ast__Ident;
typedef struct v__ast__InfixExpr v__ast__InfixExpr;
typedef struct v__ast__PostfixExpr v__ast__PostfixExpr;
typedef struct v__ast__PrefixExpr v__ast__PrefixExpr;
typedef struct v__ast__IndexExpr v__ast__IndexExpr;
typedef struct v__ast__IfExpr v__ast__IfExpr;
typedef struct v__ast__IfBranch v__ast__IfBranch;
typedef struct v__ast__UnsafeExpr v__ast__UnsafeExpr;
typedef struct v__ast__LockExpr v__ast__LockExpr;
typedef struct v__ast__MatchExpr v__ast__MatchExpr;
typedef struct v__ast__MatchBranch v__ast__MatchBranch;
typedef struct v__ast__SelectExpr v__ast__SelectExpr;
typedef struct v__ast__SelectBranch v__ast__SelectBranch;
typedef struct v__ast__CompFor v__ast__CompFor;
typedef struct v__ast__ForStmt v__ast__ForStmt;
typedef struct v__ast__ForInStmt v__ast__ForInStmt;
typedef struct v__ast__ForCStmt v__ast__ForCStmt;
typedef struct v__ast__HashStmt v__ast__HashStmt;
typedef struct v__ast__AssignStmt v__ast__AssignStmt;
typedef struct v__ast__AsCast v__ast__AsCast;
typedef struct v__ast__EnumVal v__ast__EnumVal;
typedef struct v__ast__EnumField v__ast__EnumField;
typedef struct v__ast__EnumDecl v__ast__EnumDecl;
typedef struct v__ast__AliasTypeDecl v__ast__AliasTypeDecl;
typedef struct v__ast__SumTypeDecl v__ast__SumTypeDecl;
typedef struct v__ast__SumTypeVariant v__ast__SumTypeVariant;
typedef struct v__ast__FnTypeDecl v__ast__FnTypeDecl;
typedef struct v__ast__DeferStmt v__ast__DeferStmt;
typedef struct v__ast__ParExpr v__ast__ParExpr;
typedef struct v__ast__GoStmt v__ast__GoStmt;
typedef struct v__ast__GoExpr v__ast__GoExpr;
typedef struct v__ast__GotoLabel v__ast__GotoLabel;
typedef struct v__ast__GotoStmt v__ast__GotoStmt;
typedef struct v__ast__ArrayInit v__ast__ArrayInit;
typedef struct v__ast__ArrayDecompose v__ast__ArrayDecompose;
typedef struct v__ast__ChanInit v__ast__ChanInit;
typedef struct v__ast__MapInit v__ast__MapInit;
typedef struct v__ast__RangeExpr v__ast__RangeExpr;
typedef struct v__ast__CastExpr v__ast__CastExpr;
typedef struct v__ast__AsmStmt v__ast__AsmStmt;
typedef struct v__ast__AsmTemplate v__ast__AsmTemplate;
typedef struct v__ast__AsmRegister v__ast__AsmRegister;
typedef struct v__ast__AsmDisp v__ast__AsmDisp;
typedef struct v__ast__AsmAlias v__ast__AsmAlias;
typedef struct v__ast__AsmAddressing v__ast__AsmAddressing;
typedef struct v__ast__AsmClobbered v__ast__AsmClobbered;
typedef struct v__ast__AsmIO v__ast__AsmIO;
typedef struct v__ast__AssertStmt v__ast__AssertStmt;
typedef struct v__ast__IfGuardExpr v__ast__IfGuardExpr;
typedef struct v__ast__OrExpr v__ast__OrExpr;
typedef struct v__ast__Assoc v__ast__Assoc;
typedef struct v__ast__SizeOf v__ast__SizeOf;
typedef struct v__ast__OffsetOf v__ast__OffsetOf;
typedef struct v__ast__Likely v__ast__Likely;
typedef struct v__ast__TypeOf v__ast__TypeOf;
typedef struct v__ast__DumpExpr v__ast__DumpExpr;
typedef struct v__ast__Comment v__ast__Comment;
typedef struct v__ast__ConcatExpr v__ast__ConcatExpr;
typedef struct v__ast__AtExpr v__ast__AtExpr;
typedef struct v__ast__ComptimeSelector v__ast__ComptimeSelector;
typedef struct v__ast__ComptimeCall v__ast__ComptimeCall;
typedef struct v__ast__None v__ast__None;
typedef struct v__ast__SqlStmt v__ast__SqlStmt;
typedef struct v__ast__SqlExpr v__ast__SqlExpr;
typedef struct v__ast__NodeError v__ast__NodeError;
typedef struct v__ast__CTempVar v__ast__CTempVar;
typedef struct v__ast__Attr v__ast__Attr;
typedef struct v__ast__Scope v__ast__Scope;
typedef struct v__ast__Table v__ast__Table;
typedef struct v__ast__Fn v__ast__Fn;
typedef struct v__ast__Param v__ast__Param;
typedef struct v__ast__TypeSymbol v__ast__TypeSymbol;
typedef struct v__ast__MultiReturn v__ast__MultiReturn;
typedef struct v__ast__FnType v__ast__FnType;
typedef struct v__ast__Struct v__ast__Struct;
typedef struct v__ast__GenericStructInst v__ast__GenericStructInst;
typedef struct v__ast__Interface v__ast__Interface;
typedef struct v__ast__Enum v__ast__Enum;
typedef struct v__ast__Alias v__ast__Alias;
typedef struct v__ast__Aggregate v__ast__Aggregate;
typedef struct v__ast__Array v__ast__Array;
typedef struct v__ast__ArrayFixed v__ast__ArrayFixed;
typedef struct v__ast__Chan v__ast__Chan;
typedef struct v__ast__Thread v__ast__Thread;
typedef struct v__ast__Map v__ast__Map;
typedef struct v__ast__SumType v__ast__SumType;
typedef struct v__ast__FnSignatureOpts v__ast__FnSignatureOpts;
typedef struct v__scanner__Scanner v__scanner__Scanner;
typedef struct v__checker__Checker v__checker__Checker;
typedef struct v__parser__ReceiverParsingInfo v__parser__ReceiverParsingInfo;
typedef struct v__parser__Parser v__parser__Parser;
typedef struct v__parser__EatCommentsConfig v__parser__EatCommentsConfig;
typedef struct v__gen__c__Gen v__gen__c__Gen;
typedef struct v__gen__c__ProfileCounterMeta v__gen__c__ProfileCounterMeta;
typedef struct v__markused__Walker v__markused__Walker;
typedef struct v__gen__js__BuiltinPrototypeConfig v__gen__js__BuiltinPrototypeConfig;
typedef struct v__gen__js__Namespace v__gen__js__Namespace;
typedef struct v__gen__js__JsGen v__gen__js__JsGen;
typedef struct v__gen__js__JsDoc v__gen__js__JsDoc;
typedef struct v__gen__x64__SectionConfig v__gen__x64__SectionConfig;
typedef struct v__gen__x64__Gen v__gen__x64__Gen;
typedef struct v__gen__x64__Symbol v__gen__x64__Symbol;
typedef struct v__gen__x64__Reloc v__gen__x64__Reloc;
typedef struct v__builder__Builder v__builder__Builder;
typedef struct v__builder__FunctionRedefinition v__builder__FunctionRedefinition;
typedef struct v__builder__CcompilerOptions v__builder__CcompilerOptions;
typedef struct v__builder__MsvcResult v__builder__MsvcResult;
typedef struct v__builder__WindowsKit v__builder__WindowsKit;
typedef struct v__builder__VsInstallation v__builder__VsInstallation;
typedef struct v__builder__MsvcStringFlags v__builder__MsvcStringFlags;

// V typedefs2:
typedef struct Option_int Option_int;
typedef struct Option_os__File Option_os__File;
typedef struct Option_FILE_ptr Option_FILE_ptr;
typedef struct Option_void Option_void;
typedef struct Option_bool Option_bool;
typedef struct Option_Array_string Option_Array_string;
typedef struct Option_string Option_string;
typedef struct Option_Array_ustring Option_Array_ustring;
typedef struct Option_os__Result Option_os__Result;
typedef struct Option_Array_byte Option_Array_byte;
typedef struct Option_time__Time Option_time__Time;
typedef struct Option_multi_return_int_int_int Option_multi_return_int_int_int;
typedef struct Option_multi_return_int_int_int_int_i64_bool Option_multi_return_int_int_int_int_i64_bool;
typedef struct Option_f64 Option_f64;
typedef struct Option_semver__Range Option_semver__Range;
typedef struct Option_semver__Version Option_semver__Version;
typedef struct Option_semver__ComparatorSet Option_semver__ComparatorSet;
typedef struct Option_semver__Comparator Option_semver__Comparator;
typedef struct Option_v__vmod__Manifest Option_v__vmod__Manifest;
typedef struct Option_multi_return_Array_string_int Option_multi_return_Array_string_int;
typedef struct Option_v__pkgconfig__PkgConfig_ptr Option_v__pkgconfig__PkgConfig_ptr;
typedef struct Option_v__pkgconfig__Main_ptr Option_v__pkgconfig__Main_ptr;
typedef struct Option_v__pref__OS Option_v__pref__OS;
typedef struct Option_v__pref__Arch Option_v__pref__Arch;
typedef struct Option_v__pref__Backend Option_v__pref__Backend;
typedef struct Option_time__StopWatch Option_time__StopWatch;
typedef struct Option_v__ast__Ident Option_v__ast__Ident;
typedef struct Option_multi_return_v__ast__ScopeObject_v__ast__Scope Option_multi_return_v__ast__ScopeObject_v__ast__Scope;
typedef struct Option_v__ast__ScopeObject Option_v__ast__ScopeObject;
typedef struct Option_v__ast__ScopeStructField Option_v__ast__ScopeStructField;
typedef struct Option_v__ast__Var_ptr Option_v__ast__Var_ptr;
typedef struct Option_v__ast__ConstField_ptr Option_v__ast__ConstField_ptr;
typedef struct Option_v__ast__Fn Option_v__ast__Fn;
typedef struct Option_v__ast__StructField Option_v__ast__StructField;
typedef struct Option_v__ast__TypeSymbol Option_v__ast__TypeSymbol;
typedef struct Option_v__ast__Type Option_v__ast__Type;
typedef struct Option_v__ast__Expr Option_v__ast__Expr;
typedef struct Option_v__ast__ConstField Option_v__ast__ConstField;
typedef struct Option_v__ast__FnDecl Option_v__ast__FnDecl;
typedef struct Option_v__builder__MsvcResult Option_v__builder__MsvcResult;
typedef struct Option_v__builder__WindowsKit Option_v__builder__WindowsKit;
typedef struct Option_v__builder__VsInstallation Option_v__builder__VsInstallation;

// V cheaders:
// Generated by the V compiler

#if defined(__TINYC__) && defined(__has_include)
// tcc does not support has_include properly yet, turn it off completely
#undef __has_include
#endif

#if defined(__has_include)

#if __has_include(<inttypes.h>)
#include <inttypes.h>
#else
#error VERROR_MESSAGE The C compiler can not find <inttypes.h> . Please install build-essentials
#endif

#else
#include <inttypes.h>
#endif


//================================== builtin types ================================*/
typedef int64_t i64;
typedef int16_t i16;
typedef int8_t i8;
typedef uint64_t u64;
typedef uint32_t u32;
typedef uint16_t u16;
typedef uint8_t byte;
typedef uint32_t rune;
typedef float f32;
typedef double f64;
typedef int64_t int_literal;
typedef double float_literal;
typedef unsigned char* byteptr;
typedef void* voidptr;
typedef char* charptr;
typedef byte array_fixed_byte_300 [300];

typedef struct sync__Channel* chan;

#ifndef __cplusplus
	#ifndef bool
		typedef byte bool;
		#define true 1
		#define false 0
	#endif
#endif

typedef u64 (*MapHashFn)(voidptr);
typedef bool (*MapEqFn)(voidptr, voidptr);
typedef void (*MapCloneFn)(voidptr, voidptr);
typedef void (*MapFreeFn)(voidptr);


// c_headers
typedef int (*qsort_callback_func)(const void*, const void*);
#include <stdio.h>  // TODO remove all these includes, define all function signatures and types manually
#include <stdlib.h>

#if defined(_WIN32) || defined(__CYGWIN__)
	#define VV_EXPORTED_SYMBOL extern __declspec(dllexport)
	#define VV_LOCAL_SYMBOL static
#else
	// 4 < gcc < 5 is used by some older Ubuntu LTS and Centos versions,
	// and does not support __has_attribute(visibility) ...
	#ifndef __has_attribute
		#define __has_attribute(x) 0  // Compatibility with non-clang compilers.
	#endif
	#if (defined(__GNUC__) && (__GNUC__ >= 4)) || (defined(__clang__) && __has_attribute(visibility))
		#ifdef ARM
			#define VV_EXPORTED_SYMBOL  extern __attribute__((externally_visible,visibility("default")))
		#else
			#define VV_EXPORTED_SYMBOL  extern __attribute__((visibility("default")))
		#endif
		#define VV_LOCAL_SYMBOL  __attribute__ ((visibility ("hidden")))
	#else
		#define VV_EXPORTED_SYMBOL extern
		#define VV_LOCAL_SYMBOL static
	#endif
#endif

#ifdef __cplusplus
	#include <utility>
	#define _MOV std::move
#else
	#define _MOV
#endif

#if defined(__TINYC__) && defined(__has_include)
// tcc does not support has_include properly yet, turn it off completely
#undef __has_include
#endif

#ifndef _WIN32
	#if defined __has_include
		#if __has_include (<execinfo.h>)
			#include <execinfo.h>
		#else
			// Most probably musl OR __ANDROID__ ...
			int backtrace (void **__array, int __size) { return 0; }
			char **backtrace_symbols (void *const *__array, int __size){ return 0; }
			void backtrace_symbols_fd (void *const *__array, int __size, int __fd){}
		#endif
	#endif
#endif

//#include "fns.h"
#include <signal.h>
#include <stdarg.h> // for va_list
#include <string.h> // memcpy

#if INTPTR_MAX == INT32_MAX
	#define TARGET_IS_32BIT 1
#elif INTPTR_MAX == INT64_MAX
	#define TARGET_IS_64BIT 1
#else
	#error "The environment is not 32 or 64-bit."
#endif

#if defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__ || defined(__BYTE_ORDER) && __BYTE_ORDER == __BIG_ENDIAN || defined(__BIG_ENDIAN__) || defined(__ARMEB__) || defined(__THUMBEB__) || defined(__AARCH64EB__) || defined(_MIBSEB) || defined(__MIBSEB) || defined(__MIBSEB__)
	#define TARGET_ORDER_IS_BIG
#elif defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__ || defined(__BYTE_ORDER) && __BYTE_ORDER == __LITTLE_ENDIAN || defined(__LITTLE_ENDIAN__) || defined(__ARMEL__) || defined(__THUMBEL__) || defined(__AARCH64EL__) || defined(_MIPSEL) || defined(__MIPSEL) || defined(__MIPSEL__) || defined(_M_AMD64) || defined(_M_X64) || defined(_M_IX86)
	#define TARGET_ORDER_IS_LITTLE
#else
	#error "Unknown architecture endianness"
#endif

#ifndef _WIN32
	#include <ctype.h>
	#include <locale.h> // tolower
	#include <sys/time.h>
	#include <unistd.h> // sleep
	extern char **environ;
#endif

#if defined(__CYGWIN__) && !defined(_WIN32)
	#error Cygwin is not supported, please use MinGW or Visual Studio.
#endif

#ifdef __linux__
	#include <sys/types.h>
	#include <sys/wait.h> // os__wait uses wait on nix
#endif

#ifdef __FreeBSD__
	#include <sys/types.h>
	#include <sys/wait.h> // os__wait uses wait on nix
#endif

#ifdef __DragonFly__
	#include <sys/types.h>
	#include <sys/wait.h> // os__wait uses wait on nix
#endif

#ifdef __OpenBSD__
	#include <sys/types.h>
	#include <sys/resource.h>
	#include <sys/wait.h> // os__wait uses wait on nix
#endif

#ifdef __NetBSD__
	#include <sys/wait.h> // os__wait uses wait on nix
#endif

#ifdef __sun
	#include <sys/types.h>
	#include <sys/wait.h> // os__wait uses wait on nix
#endif


#define EMPTY_VARG_INITIALIZATION 0
#define EMPTY_STRUCT_DECLARATION
#define EMPTY_STRUCT_INITIALIZATION 0
// Due to a tcc bug, the length of an array needs to be specified, but GCC crashes if it is...
#define EMPTY_ARRAY_OF_ELEMS(x,n) (x[])
#define TCCSKIP(x) x

#define __NOINLINE __attribute__((noinline))
#define __IRQHANDLER __attribute__((interrupt))

#if defined(__x86_64__)
#define __V_amd64  1
#endif
#if defined(__aarch64__) || defined(__arm64__)
#define __V_aarch64  1
#endif

// Using just __GNUC__ for detecting gcc, is not reliable because other compilers define it too:
#ifdef __GNUC__
	#define __V_GCC__
#endif
#ifdef __TINYC__
	#undef __V_GCC__
#endif
#ifdef __cplusplus
	#undef __V_GCC__
#endif
#ifdef __clang__
	#undef __V_GCC__
#endif
#ifdef _MSC_VER
	#undef __V_GCC__
#endif

#ifdef __TINYC__
	#undef EMPTY_STRUCT_DECLARATION
	#undef EMPTY_STRUCT_INITIALIZATION
	#define EMPTY_STRUCT_DECLARATION char _dummy
	#define EMPTY_STRUCT_INITIALIZATION 0
	#undef EMPTY_ARRAY_OF_ELEMS
	#define EMPTY_ARRAY_OF_ELEMS(x,n) (x[n])
	#undef __NOINLINE
	#undef __IRQHANDLER
	// tcc does not support inlining at all
	#define __NOINLINE
	#define __IRQHANDLER
	#undef TCCSKIP
	#define TCCSKIP(x)
	// #include <byteswap.h>
	#ifndef _WIN32
		#include <execinfo.h>
		int tcc_backtrace(const char *fmt, ...);
	#endif
#endif

// Use __offsetof_ptr instead of __offset_of, when you *do* have a valid pointer, to avoid UB:
#ifndef __offsetof_ptr
	#define __offsetof_ptr(ptr,PTYPE,FIELDNAME) ((size_t)((byte *)&((PTYPE *)ptr)->FIELDNAME - (byte *)ptr))
#endif

// for __offset_of
#ifndef __offsetof
	#define __offsetof(PTYPE,FIELDNAME) ((size_t)((char *)&((PTYPE *)0)->FIELDNAME - (char *)0))
#endif

#define OPTION_CAST(x) (x)

#ifndef V64_PRINTFORMAT
	#ifdef PRIx64
		#define V64_PRINTFORMAT "0x%"PRIx64
	#elif defined(__WIN32__)
		#define V64_PRINTFORMAT "0x%I64x"
	#elif defined(__linux__) && defined(__LP64__)
		#define V64_PRINTFORMAT "0x%lx"
	#else
		#define V64_PRINTFORMAT "0x%llx"
	#endif
#endif


#ifdef _WIN32
	#define WINVER 0x0600
	#ifdef _WIN32_WINNT
		#undef _WIN32_WINNT
	#endif
	#define _WIN32_WINNT 0x0600
	#ifndef WIN32_FULL
	#define WIN32_LEAN_AND_MEAN
	#endif
	#ifndef _UNICODE
	#define _UNICODE
	#endif
	#ifndef UNICODE
	#define UNICODE
	#endif
	#include <windows.h>

	#include <io.h> // _waccess
	#include <direct.h> // _wgetcwd

	#ifdef _MSC_VER
		// On MSVC these are the same (as long as /volatile:ms is passed)
		#define _Atomic volatile

		// MSVC cannot parse some things properly
		#undef EMPTY_STRUCT_DECLARATION
		#undef OPTION_CAST

		#define EMPTY_STRUCT_DECLARATION int ____dummy_variable
		#define OPTION_CAST(x)
		#undef __NOINLINE
		#undef __IRQHANDLER
		#define __NOINLINE __declspec(noinline)
		#define __IRQHANDLER __declspec(naked)

		#include <dbghelp.h>
		#pragma comment(lib, "Dbghelp")
	#endif
#else
	#include <pthread.h>
	#ifndef PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP
		// musl does not have that
		#define pthread_rwlockattr_setkind_np(a, b)
	#endif
#endif

// g_live_info is used by live.info()
static void* g_live_info = NULL;

//============================== HELPER C MACROS =============================*/
//#define tos4(s, slen) ((string){.str=(s), .len=(slen)})
// `"" s` is used to enforce a string literal argument
#define _SLIT(s) ((string){.str=(byteptr)("" s), .len=(sizeof(s)-1), .is_lit=1})
// take the address of an rvalue
#define ADDR(type, expr) (&((type[]){expr}[0]))
// copy something to the heap
#define HEAP(type, expr) ((type*)memdup((void*)&((type[]){expr}[0]), sizeof(type)))
#define _PUSH_MANY(arr, val, tmp, tmp_typ) {tmp_typ tmp = (val); array_push_many(arr, tmp.data, tmp.len);}
#define _IN_MAP(val, m) map_exists(m, val)

// unsigned/signed comparisons
static inline bool _us32_gt(uint32_t a, int32_t b) { return a > INT32_MAX || (int32_t)a > b; }
static inline bool _us32_ge(uint32_t a, int32_t b) { return a >= INT32_MAX || (int32_t)a >= b; }
static inline bool _us32_eq(uint32_t a, int32_t b) { return a <= INT32_MAX && (int32_t)a == b; }
static inline bool _us32_ne(uint32_t a, int32_t b) { return a > INT32_MAX || (int32_t)a != b; }
static inline bool _us32_le(uint32_t a, int32_t b) { return a <= INT32_MAX && (int32_t)a <= b; }
static inline bool _us32_lt(uint32_t a, int32_t b) { return a < INT32_MAX && (int32_t)a < b; }
static inline bool _us64_gt(uint64_t a, int64_t b) { return a > INT64_MAX || (int64_t)a > b; }
static inline bool _us64_ge(uint64_t a, int64_t b) { return a >= INT64_MAX || (int64_t)a >= b; }
static inline bool _us64_eq(uint64_t a, int64_t b) { return a <= INT64_MAX && (int64_t)a == b; }
static inline bool _us64_ne(uint64_t a, int64_t b) { return a > INT64_MAX || (int64_t)a != b; }
static inline bool _us64_le(uint64_t a, int64_t b) { return a <= INT64_MAX && (int64_t)a <= b; }
static inline bool _us64_lt(uint64_t a, int64_t b) { return a < INT64_MAX && (int64_t)a < b; }

#if defined(__MINGW32__) || defined(__MINGW64__) || (defined(_WIN32) && defined(__TINYC__))
	#undef PRId64
	#undef PRIi64
	#undef PRIo64
	#undef PRIu64
	#undef PRIx64
	#undef PRIX64
	#define PRId64 "lld"
	#define PRIi64 "lli"
	#define PRIo64 "llo"
	#define PRIu64 "llu"
	#define PRIx64 "llx"
	#define PRIX64 "llX"
#endif

//================================== GLOBALS =================================*/
//byte g_str_buf[1024];
byte* g_str_buf;
int load_so(byteptr);
void reload_so();
void _vinit(int ___argc, voidptr ___argv);
void _vcleanup();
#define sigaction_size sizeof(sigaction);
#define _ARR_LEN(a) ( (sizeof(a)) / (sizeof(a[0])) )

// ============== wyhash ==============
#ifndef wyhash_final_version_3
#define wyhash_final_version_3

#ifndef WYHASH_CONDOM
//protections that produce different results:
//1: normal valid behavior
//2: extra protection against entropy loss (probability=2^-63), aka. "blind multiplication"
#define WYHASH_CONDOM 1
#endif

#ifndef WYHASH_32BIT_MUM
//0: normal version, slow on 32 bit systems
//1: faster on 32 bit systems but produces different results, incompatible with wy2u0k function
#define WYHASH_32BIT_MUM 0
#endif

//includes
#include <stdint.h>
#include <string.h>
#if defined(_MSC_VER) && defined(_M_X64)
	#include <intrin.h>
	#pragma intrinsic(_umul128)
#endif

//likely and unlikely macros
#if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)
	#define _likely_(x)  __builtin_expect(x,1)
	#define _unlikely_(x)  __builtin_expect(x,0)
#else
	#define _likely_(x) (x)
	#define _unlikely_(x) (x)
#endif

//128bit multiply function
static inline uint64_t _wyrot(uint64_t x) { return (x>>32)|(x<<32); }
static inline void _wymum(uint64_t *A, uint64_t *B){
#if(WYHASH_32BIT_MUM)
	uint64_t hh=(*A>>32)*(*B>>32), hl=(*A>>32)*(uint32_t)*B, lh=(uint32_t)*A*(*B>>32), ll=(uint64_t)(uint32_t)*A*(uint32_t)*B;
	#if(WYHASH_CONDOM>1)
	*A^=_wyrot(hl)^hh; *B^=_wyrot(lh)^ll;
	#else
	*A=_wyrot(hl)^hh; *B=_wyrot(lh)^ll;
	#endif
#elif defined(__SIZEOF_INT128__)
	__uint128_t r=*A; r*=*B;
	#if(WYHASH_CONDOM>1)
	*A^=(uint64_t)r; *B^=(uint64_t)(r>>64);
	#else
	*A=(uint64_t)r; *B=(uint64_t)(r>>64);
	#endif
#elif defined(_MSC_VER) && defined(_M_X64)
	#if(WYHASH_CONDOM>1)
	uint64_t  a,  b;
	a=_umul128(*A,*B,&b);
	*A^=a;  *B^=b;
	#else
	*A=_umul128(*A,*B,B);
	#endif
#else
	uint64_t ha=*A>>32, hb=*B>>32, la=(uint32_t)*A, lb=(uint32_t)*B, hi, lo;
	uint64_t rh=ha*hb, rm0=ha*lb, rm1=hb*la, rl=la*lb, t=rl+(rm0<<32), c=t<rl;
	lo=t+(rm1<<32); c+=lo<t; hi=rh+(rm0>>32)+(rm1>>32)+c;
	#if(WYHASH_CONDOM>1)
	*A^=lo;  *B^=hi;
	#else
	*A=lo;  *B=hi;
	#endif
#endif
}

//multiply and xor mix function, aka MUM
static inline uint64_t _wymix(uint64_t A, uint64_t B){ _wymum(&A,&B); return A^B; }

//endian macros
#ifndef WYHASH_LITTLE_ENDIAN
	#if defined(_WIN32) || defined(__LITTLE_ENDIAN__) || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)
		#define WYHASH_LITTLE_ENDIAN 1
	#elif defined(__BIG_ENDIAN__) || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)
		#define WYHASH_LITTLE_ENDIAN 0
	#else
		#warning could not determine endianness! Falling back to little endian.
		#define WYHASH_LITTLE_ENDIAN 1
	#endif
#endif

//read functions
#if (WYHASH_LITTLE_ENDIAN)
static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return v;}
static inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&v, p, 4); return v;}
#elif defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)
static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return __builtin_bswap64(v);}
static inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&v, p, 4); return __builtin_bswap32(v);}
#elif defined(_MSC_VER)
static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return _byteswap_uint64(v);}
static inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&v, p, 4); return _byteswap_ulong(v);}
#else
static inline uint64_t _wyr8(const uint8_t *p) {
	uint64_t v; memcpy(&v, p, 8);
	return (((v >> 56) & 0xff)| ((v >> 40) & 0xff00)| ((v >> 24) & 0xff0000)| ((v >>  8) & 0xff000000)| ((v <<  8) & 0xff00000000)| ((v << 24) & 0xff0000000000)| ((v << 40) & 0xff000000000000)| ((v << 56) & 0xff00000000000000));
}
static inline uint64_t _wyr4(const uint8_t *p) {
	uint32_t v; memcpy(&v, p, 4);
	return (((v >> 24) & 0xff)| ((v >>  8) & 0xff00)| ((v <<  8) & 0xff0000)| ((v << 24) & 0xff000000));
}
#endif
static inline uint64_t _wyr3(const uint8_t *p, size_t k) { return (((uint64_t)p[0])<<16)|(((uint64_t)p[k>>1])<<8)|p[k-1];}

//wyhash main function
static inline uint64_t wyhash(const void *key, size_t len, uint64_t seed, const uint64_t *secret){
	const uint8_t *p=(const uint8_t *)key; seed^=*secret;	uint64_t	a,	b;
	if(_likely_(len<=16)){
		if(_likely_(len>=4)){ a=(_wyr4(p)<<32)|_wyr4(p+((len>>3)<<2)); b=(_wyr4(p+len-4)<<32)|_wyr4(p+len-4-((len>>3)<<2)); }
		else if(_likely_(len>0)){ a=_wyr3(p,len); b=0;}
		else a=b=0;
	}
	else{
		size_t i=len;
		if(_unlikely_(i>48)){
			uint64_t see1=seed, see2=seed;
			do{
				seed=_wymix(_wyr8(p)^secret[1],_wyr8(p+8)^seed);
				see1=_wymix(_wyr8(p+16)^secret[2],_wyr8(p+24)^see1);
				see2=_wymix(_wyr8(p+32)^secret[3],_wyr8(p+40)^see2);
				p+=48; i-=48;
			}while(_likely_(i>48));
			seed^=see1^see2;
		}
		while(_unlikely_(i>16)){  seed=_wymix(_wyr8(p)^secret[1],_wyr8(p+8)^seed);  i-=16; p+=16;  }
		a=_wyr8(p+i-16);  b=_wyr8(p+i-8);
	}
	return _wymix(secret[1]^len,_wymix(a^secret[1],b^seed));
}
//the default secret parameters
static const uint64_t _wyp[4] = {0xa0761d6478bd642full, 0xe7037ed1a0b428dbull, 0x8ebc6af09c88c6e3ull, 0x589965cc75374cc3ull};

//a useful 64bit-64bit mix function to produce deterministic pseudo random numbers that can pass BigCrush and PractRand
static inline uint64_t wyhash64(uint64_t A, uint64_t B){ A^=_wyp[0]; B^=_wyp[1]; _wymum(&A,&B); return _wymix(A^_wyp[0],B^_wyp[1]);}

//The wyrand PRNG that pass BigCrush and PractRand
static inline uint64_t wyrand(uint64_t *seed){ *seed+=_wyp[0]; return _wymix(*seed,*seed^_wyp[1]);}

//convert any 64 bit pseudo random numbers to uniform distribution [0,1). It can be combined with wyrand, wyhash64 or wyhash.
static inline double wy2u01(uint64_t r){ const double _wynorm=1.0/(1ull<<52); return (r>>12)*_wynorm;}

//convert any 64 bit pseudo random numbers to APPROXIMATE Gaussian distribution. It can be combined with wyrand, wyhash64 or wyhash.
static inline double wy2gau(uint64_t r){ const double _wynorm=1.0/(1ull<<20); return ((r&0x1fffff)+((r>>21)&0x1fffff)+((r>>42)&0x1fffff))*_wynorm-3.0;}

#if(!WYHASH_32BIT_MUM)
//fast range integer random number generation on [0,k) credit to Daniel Lemire. May not work when WYHASH_32BIT_MUM=1. It can be combined with wyrand, wyhash64 or wyhash.
static inline uint64_t wy2u0k(uint64_t r, uint64_t k){ _wymum(&r,&k); return k; }
#endif

//make your own secret
static inline void make_secret(uint64_t seed, uint64_t *secret){
	uint8_t c[] = {15, 23, 27, 29, 30, 39, 43, 45, 46, 51, 53, 54, 57, 58, 60, 71, 75, 77, 78, 83, 85, 86, 89, 90, 92, 99, 101, 102, 105, 106, 108, 113, 114, 116, 120, 135, 139, 141, 142, 147, 149, 150, 153, 154, 156, 163, 165, 166, 169, 170, 172, 177, 178, 180, 184, 195, 197, 198, 201, 202, 204, 209, 210, 212, 216, 225, 226, 228, 232, 240 };
	for(size_t i=0;i<4;i++){
		uint8_t ok;
		do{
			ok=1; secret[i]=0;
			for(size_t j=0;j<64;j+=8) secret[i]|=((uint64_t)c[wyrand(&seed)%sizeof(c)])<<j;
			if(secret[i]%2==0){ ok=0; continue; }
			for(size_t j=0;j<i;j++) {
#if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)
				if(__builtin_popcountll(secret[j]^secret[i])!=32){ ok=0; break; }
#elif defined(_MSC_VER) && defined(_M_X64)
				if(_mm_popcnt_u64(secret[j]^secret[i])!=32){ ok=0; break; }
#else
				//manual popcount
				uint64_t x = secret[j]^secret[i];
				x -= (x >> 1) & 0x5555555555555555;
				x = (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333);
				x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0f;
				x = (x * 0x0101010101010101) >> 56;
				if(x!=32){ ok=0; break; }
#endif
			}
				if(!ok)continue;
				for(uint64_t j=3;j<0x100000000ull;j+=2) if(secret[i]%j==0){ ok=0; break; }
		}while(!ok);
	}
}
#endif

void v_free(voidptr ptr);
voidptr memdup(voidptr src, int sz);
static voidptr memfreedup(voidptr ptr, voidptr src, int sz) {
	v_free(ptr);
	return memdup(src, sz);
}


// V includes:

#if defined(__TINYC__) && defined(__has_include)
// tcc does not support has_include properly yet, turn it off completely
#undef __has_include
#endif
// added by module `builtin`:

#if defined(__has_include)

#if __has_include(<float.h>)
#include <float.h>
#else
#error VERROR_MESSAGE Header file <float.h>, needed for module `builtin` was not found. Please install the corresponding development headers.
#endif

#else
#include <float.h>
#endif

// added by module `os`:

#if defined(__has_include)

#if __has_include(<sys/stat.h>)
#include <sys/stat.h>
#else
#error VERROR_MESSAGE Header file <sys/stat.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <sys/stat.h>
#endif

// added by module `os`:
#include <errno.h>
// added by module `os`:

#if defined(__has_include)

#if __has_include(<process.h>)
#include <process.h>
#else
#error VERROR_MESSAGE Header file <process.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <process.h>
#endif

// added by module `time`:

#if defined(__has_include)

#if __has_include(<time.h>)
#include <time.h>
#else
#error VERROR_MESSAGE Header file <time.h>, needed for module `time` was not found. Please install the corresponding development headers.
#endif

#else
#include <time.h>
#endif

// added by module `time`:

#if defined(__has_include)

#if __has_include(<time.h>)
#include <time.h>
#else
#error VERROR_MESSAGE Header file <time.h>, needed for module `time` was not found. Please install the corresponding development headers.
#endif

#else
#include <time.h>
#endif


// Enum definitions:
typedef enum {
	strconv__Char_parse_state_start, // 
	strconv__Char_parse_state_norm_char, // +1
	strconv__Char_parse_state_field_char, // +2
	strconv__Char_parse_state_pad_ch, // +3
	strconv__Char_parse_state_len_set_start, // +4
	strconv__Char_parse_state_len_set_in, // +5
	strconv__Char_parse_state_check_type, // +6
	strconv__Char_parse_state_check_float, // +7
	strconv__Char_parse_state_check_float_in, // +8
	strconv__Char_parse_state_reset_params, // +9
} strconv__Char_parse_state;

typedef enum {
	strconv__Align_text_right = 0, // 0
	strconv__Align_text_left, // 0+1
	strconv__Align_text_center, // 0+2
} strconv__Align_text;

typedef enum {
	ChanState_success, // 
	ChanState_not_ready, // +1
	ChanState_closed, // +2
} ChanState;

typedef enum {
	os__FileType_regular, // 
	os__FileType_directory, // +1
	os__FileType_character_device, // +2
	os__FileType_block_device, // +3
	os__FileType_fifo, // +4
	os__FileType_symbolic_link, // +5
	os__FileType_socket, // +6
} os__FileType;

typedef enum {
	os__ProcessState_not_started, // 
	os__ProcessState_running, // +1
	os__ProcessState_stopped, // +2
	os__ProcessState_exited, // +3
	os__ProcessState_aborted, // +4
} os__ProcessState;

typedef enum {
	time__FormatTime_hhmm12, // 
	time__FormatTime_hhmm24, // +1
	time__FormatTime_hhmmss12, // +2
	time__FormatTime_hhmmss24, // +3
	time__FormatTime_hhmmss24_milli, // +4
	time__FormatTime_hhmmss24_micro, // +5
	time__FormatTime_no_time, // +6
} time__FormatTime;

typedef enum {
	time__FormatDate_ddmmyy, // 
	time__FormatDate_ddmmyyyy, // +1
	time__FormatDate_mmddyy, // +2
	time__FormatDate_mmddyyyy, // +3
	time__FormatDate_mmmd, // +4
	time__FormatDate_mmmdd, // +5
	time__FormatDate_mmmddyy, // +6
	time__FormatDate_mmmddyyyy, // +7
	time__FormatDate_no_date, // +8
	time__FormatDate_yyyymmdd, // +9
	time__FormatDate_yymmdd, // +10
} time__FormatDate;

typedef enum {
	time__FormatDelimiter_dot, // 
	time__FormatDelimiter_hyphen, // +1
	time__FormatDelimiter_slash, // +2
	time__FormatDelimiter_space, // +3
	time__FormatDelimiter_no_delimiter, // +4
} time__FormatDelimiter;

typedef enum {
	v__token__Kind_unknown, // 
	v__token__Kind_eof, // +1
	v__token__Kind_name, // +2
	v__token__Kind_number, // +3
	v__token__Kind_string, // +4
	v__token__Kind_str_inter, // +5
	v__token__Kind_chartoken, // +6
	v__token__Kind_plus, // +7
	v__token__Kind_minus, // +8
	v__token__Kind_mul, // +9
	v__token__Kind_div, // +10
	v__token__Kind_mod, // +11
	v__token__Kind_xor, // +12
	v__token__Kind_pipe, // +13
	v__token__Kind_inc, // +14
	v__token__Kind_dec, // +15
	v__token__Kind_and, // +16
	v__token__Kind_logical_or, // +17
	v__token__Kind_not, // +18
	v__token__Kind_bit_not, // +19
	v__token__Kind_question, // +20
	v__token__Kind_comma, // +21
	v__token__Kind_semicolon, // +22
	v__token__Kind_colon, // +23
	v__token__Kind_arrow, // +24
	v__token__Kind_amp, // +25
	v__token__Kind_hash, // +26
	v__token__Kind_dollar, // +27
	v__token__Kind_at, // +28
	v__token__Kind_str_dollar, // +29
	v__token__Kind_left_shift, // +30
	v__token__Kind_right_shift, // +31
	v__token__Kind_not_in, // +32
	v__token__Kind_not_is, // +33
	v__token__Kind_assign, // +34
	v__token__Kind_decl_assign, // +35
	v__token__Kind_plus_assign, // +36
	v__token__Kind_minus_assign, // +37
	v__token__Kind_div_assign, // +38
	v__token__Kind_mult_assign, // +39
	v__token__Kind_xor_assign, // +40
	v__token__Kind_mod_assign, // +41
	v__token__Kind_or_assign, // +42
	v__token__Kind_and_assign, // +43
	v__token__Kind_right_shift_assign, // +44
	v__token__Kind_left_shift_assign, // +45
	v__token__Kind_lcbr, // +46
	v__token__Kind_rcbr, // +47
	v__token__Kind_lpar, // +48
	v__token__Kind_rpar, // +49
	v__token__Kind_lsbr, // +50
	v__token__Kind_rsbr, // +51
	v__token__Kind_eq, // +52
	v__token__Kind_ne, // +53
	v__token__Kind_gt, // +54
	v__token__Kind_lt, // +55
	v__token__Kind_ge, // +56
	v__token__Kind_le, // +57
	v__token__Kind_comment, // +58
	v__token__Kind_nl, // +59
	v__token__Kind_dot, // +60
	v__token__Kind_dotdot, // +61
	v__token__Kind_ellipsis, // +62
	v__token__Kind_keyword_beg, // +63
	v__token__Kind_key_as, // +64
	v__token__Kind_key_asm, // +65
	v__token__Kind_key_assert, // +66
	v__token__Kind_key_atomic, // +67
	v__token__Kind_key_break, // +68
	v__token__Kind_key_const, // +69
	v__token__Kind_key_continue, // +70
	v__token__Kind_key_defer, // +71
	v__token__Kind_key_else, // +72
	v__token__Kind_key_enum, // +73
	v__token__Kind_key_false, // +74
	v__token__Kind_key_for, // +75
	v__token__Kind_key_fn, // +76
	v__token__Kind_key_global, // +77
	v__token__Kind_key_go, // +78
	v__token__Kind_key_goto, // +79
	v__token__Kind_key_if, // +80
	v__token__Kind_key_import, // +81
	v__token__Kind_key_in, // +82
	v__token__Kind_key_interface, // +83
	v__token__Kind_key_is, // +84
	v__token__Kind_key_match, // +85
	v__token__Kind_key_module, // +86
	v__token__Kind_key_mut, // +87
	v__token__Kind_key_shared, // +88
	v__token__Kind_key_lock, // +89
	v__token__Kind_key_rlock, // +90
	v__token__Kind_key_none, // +91
	v__token__Kind_key_return, // +92
	v__token__Kind_key_select, // +93
	v__token__Kind_key_sizeof, // +94
	v__token__Kind_key_likely, // +95
	v__token__Kind_key_unlikely, // +96
	v__token__Kind_key_offsetof, // +97
	v__token__Kind_key_struct, // +98
	v__token__Kind_key_true, // +99
	v__token__Kind_key_type, // +100
	v__token__Kind_key_typeof, // +101
	v__token__Kind_key_dump, // +102
	v__token__Kind_key_orelse, // +103
	v__token__Kind_key_union, // +104
	v__token__Kind_key_pub, // +105
	v__token__Kind_key_static, // +106
	v__token__Kind_key_unsafe, // +107
	v__token__Kind_keyword_end, // +108
	v__token__Kind__end_, // +109
} v__token__Kind;

typedef enum {
	v__token__AtKind_unknown, // 
	v__token__AtKind_fn_name, // +1
	v__token__AtKind_method_name, // +2
	v__token__AtKind_mod_name, // +3
	v__token__AtKind_struct_name, // +4
	v__token__AtKind_vexe_path, // +5
	v__token__AtKind_file_path, // +6
	v__token__AtKind_line_nr, // +7
	v__token__AtKind_column_nr, // +8
	v__token__AtKind_vhash, // +9
	v__token__AtKind_vmod_file, // +10
} v__token__AtKind;

typedef enum {
	v__token__Precedence_lowest, // 
	v__token__Precedence_cond, // +1
	v__token__Precedence_in_as, // +2
	v__token__Precedence_assign, // +3
	v__token__Precedence_eq, // +4
	v__token__Precedence_sum, // +5
	v__token__Precedence_product, // +6
	v__token__Precedence_prefix, // +7
	v__token__Precedence_postfix, // +8
	v__token__Precedence_call, // +9
	v__token__Precedence_index, // +10
} v__token__Precedence;

typedef enum {
	semver__Operator_gt, // 
	semver__Operator_lt, // +1
	semver__Operator_ge, // +2
	semver__Operator_le, // +3
	semver__Operator_eq, // +4
} semver__Operator;

typedef enum {
	semver__Increment_major, // 
	semver__Increment_minor, // +1
	semver__Increment_patch, // +2
} semver__Increment;

typedef enum {
	v__vmod__TokenKind_module_keyword, // 
	v__vmod__TokenKind_field_key, // +1
	v__vmod__TokenKind_lcbr, // +2
	v__vmod__TokenKind_rcbr, // +3
	v__vmod__TokenKind_labr, // +4
	v__vmod__TokenKind_rabr, // +5
	v__vmod__TokenKind_comma, // +6
	v__vmod__TokenKind_colon, // +7
	v__vmod__TokenKind_eof, // +8
	v__vmod__TokenKind_str, // +9
	v__vmod__TokenKind_ident, // +10
	v__vmod__TokenKind_unknown, // +11
} v__vmod__TokenKind;

typedef enum {
	v__errors__Reporter_scanner, // 
	v__errors__Reporter_parser, // +1
	v__errors__Reporter_checker, // +2
	v__errors__Reporter_gen, // +3
} v__errors__Reporter;

typedef enum {
	v__vet__ErrorKind_error, // 
	v__vet__ErrorKind_warning, // +1
} v__vet__ErrorKind;

typedef enum {
	v__vet__FixKind_unknown, // 
	v__vet__FixKind_doc, // +1
	v__vet__FixKind_vfmt, // +2
} v__vet__FixKind;

typedef enum {
	v__vet__ErrorType_default, // 
	v__vet__ErrorType_space_indent, // +1
	v__vet__ErrorType_trailing_space, // +2
} v__vet__ErrorType;

typedef enum {
	v__pref__OS__auto, // 
	v__pref__OS_ios, // +1
	v__pref__OS_macos, // +2
	v__pref__OS_linux, // +3
	v__pref__OS_windows, // +4
	v__pref__OS_freebsd, // +5
	v__pref__OS_openbsd, // +6
	v__pref__OS_netbsd, // +7
	v__pref__OS_dragonfly, // +8
	v__pref__OS_js, // +9
	v__pref__OS_android, // +10
	v__pref__OS_solaris, // +11
	v__pref__OS_haiku, // +12
	v__pref__OS_all, // +13
} v__pref__OS;

typedef enum {
	v__pref__BuildMode_default_mode, // 
	v__pref__BuildMode_build_module, // +1
} v__pref__BuildMode;

typedef enum {
	v__pref__GarbageCollectionMode_no_gc, // 
	v__pref__GarbageCollectionMode_boehm_full, // +1
	v__pref__GarbageCollectionMode_boehm_incr, // +2
	v__pref__GarbageCollectionMode_boehm, // +3
	v__pref__GarbageCollectionMode_boehm_leak, // +4
} v__pref__GarbageCollectionMode;

typedef enum {
	v__pref__OutputMode_stdout, // 
	v__pref__OutputMode_silent, // +1
} v__pref__OutputMode;

typedef enum {
	v__pref__ColorOutput_auto, // 
	v__pref__ColorOutput_always, // +1
	v__pref__ColorOutput_never, // +2
} v__pref__ColorOutput;

typedef enum {
	v__pref__Backend_c, // 
	v__pref__Backend_js, // +1
	v__pref__Backend_x64, // +2
} v__pref__Backend;

typedef enum {
	v__pref__CompilerType_gcc, // 
	v__pref__CompilerType_tinyc, // +1
	v__pref__CompilerType_clang, // +2
	v__pref__CompilerType_mingw, // +3
	v__pref__CompilerType_msvc, // +4
	v__pref__CompilerType_cplusplus, // +5
} v__pref__CompilerType;

typedef enum {
	v__pref__Arch__auto, // 
	v__pref__Arch_amd64, // +1
	v__pref__Arch_aarch64, // +2
	v__pref__Arch_aarch32, // +3
	v__pref__Arch_rv64, // +4
	v__pref__Arch_rv32, // +5
	v__pref__Arch_i386, // +6
} v__pref__Arch;

typedef enum {
	v__ast__IdentKind_unresolved, // 
	v__ast__IdentKind_blank_ident, // +1
	v__ast__IdentKind_variable, // +2
	v__ast__IdentKind_constant, // +3
	v__ast__IdentKind_global, // +4
	v__ast__IdentKind_function, // +5
} v__ast__IdentKind;

typedef enum {
	v__ast__CompForKind_methods, // 
	v__ast__CompForKind_fields, // +1
} v__ast__CompForKind;

typedef enum {
	v__ast__AddressingMode_invalid, // 
	v__ast__AddressingMode_displacement, // +1
	v__ast__AddressingMode_base, // +2
	v__ast__AddressingMode_base_plus_displacement, // +3
	v__ast__AddressingMode_index_times_scale_plus_displacement, // +4
	v__ast__AddressingMode_base_plus_index_plus_displacement, // +5
	v__ast__AddressingMode_base_plus_index_times_scale_plus_displacement, // +6
	v__ast__AddressingMode_rip_plus_displacement, // +7
} v__ast__AddressingMode;

typedef enum {
	v__ast__OrKind_absent, // 
	v__ast__OrKind_block, // +1
	v__ast__OrKind_propagate, // +2
} v__ast__OrKind;

typedef enum {
	v__ast__SqlStmtKind_insert, // 
	v__ast__SqlStmtKind_update, // +1
	v__ast__SqlStmtKind_delete, // +2
	v__ast__SqlStmtKind_create, // +3
} v__ast__SqlStmtKind;

typedef enum {
	v__ast__Language_v, // 
	v__ast__Language_c, // +1
	v__ast__Language_js, // +2
	v__ast__Language_amd64, // +3
	v__ast__Language_i386, // +4
	v__ast__Language_aarch64, // +5
	v__ast__Language_aarch32, // +6
	v__ast__Language_rv64, // +7
	v__ast__Language_rv32, // +8
} v__ast__Language;

typedef enum {
	v__ast__TypeFlag_optional, // 
	v__ast__TypeFlag_variadic, // +1
	v__ast__TypeFlag_generic, // +2
	v__ast__TypeFlag_shared_f, // +3
	v__ast__TypeFlag_atomic_f, // +4
} v__ast__TypeFlag;

typedef enum {
	v__ast__ShareType_mut_t, // 
	v__ast__ShareType_shared_t, // +1
	v__ast__ShareType_atomic_t, // +2
} v__ast__ShareType;

typedef enum {
	v__ast__Kind_placeholder, // 
	v__ast__Kind_void, // +1
	v__ast__Kind_voidptr, // +2
	v__ast__Kind_byteptr, // +3
	v__ast__Kind_charptr, // +4
	v__ast__Kind_i8, // +5
	v__ast__Kind_i16, // +6
	v__ast__Kind_int, // +7
	v__ast__Kind_i64, // +8
	v__ast__Kind_byte, // +9
	v__ast__Kind_u16, // +10
	v__ast__Kind_u32, // +11
	v__ast__Kind_u64, // +12
	v__ast__Kind_f32, // +13
	v__ast__Kind_f64, // +14
	v__ast__Kind_char, // +15
	v__ast__Kind_size_t, // +16
	v__ast__Kind_rune, // +17
	v__ast__Kind_bool, // +18
	v__ast__Kind_none_, // +19
	v__ast__Kind_string, // +20
	v__ast__Kind_ustring, // +21
	v__ast__Kind_array, // +22
	v__ast__Kind_array_fixed, // +23
	v__ast__Kind_map, // +24
	v__ast__Kind_chan, // +25
	v__ast__Kind_any, // +26
	v__ast__Kind_struct_, // +27
	v__ast__Kind_generic_struct_inst, // +28
	v__ast__Kind_multi_return, // +29
	v__ast__Kind_sum_type, // +30
	v__ast__Kind_alias, // +31
	v__ast__Kind_enum_, // +32
	v__ast__Kind_function, // +33
	v__ast__Kind_interface_, // +34
	v__ast__Kind_float_literal, // +35
	v__ast__Kind_int_literal, // +36
	v__ast__Kind_aggregate, // +37
	v__ast__Kind_thread, // +38
} v__ast__Kind;

typedef enum {
	v__scanner__CommentsMode_skip_comments, // 
	v__scanner__CommentsMode_parse_comments, // +1
	v__scanner__CommentsMode_toplevel_comments, // +2
} v__scanner__CommentsMode;

typedef enum {
	v__parser__State_html, // 
	v__parser__State_css, // +1
	v__parser__State_js, // +2
} v__parser__State;

typedef enum {
	v__gen__c__SqlExprSide_left, // 
	v__gen__c__SqlExprSide_right, // +1
} v__gen__c__SqlExprSide;

typedef enum {
	v__gen__c__SqlType_sqlite3, // 
	v__gen__c__SqlType_mysql, // +1
	v__gen__c__SqlType_psql, // +2
	v__gen__c__SqlType_unknown, // +3
} v__gen__c__SqlType;

typedef enum {
	v__gen__x64__SectionType_null = 0, // 0
	v__gen__x64__SectionType_progbits = 1, // 1
	v__gen__x64__SectionType_symtab = 2, // 2
	v__gen__x64__SectionType_strtab = 3, // 3
	v__gen__x64__SectionType_rela = 4, // 4
} v__gen__x64__SectionType;

typedef enum {
	v__gen__x64__Register_rax, // 
	v__gen__x64__Register_rcx, // +1
	v__gen__x64__Register_rdx, // +2
	v__gen__x64__Register_rbx, // +3
	v__gen__x64__Register_rsp, // +4
	v__gen__x64__Register_rbp, // +5
	v__gen__x64__Register_rsi, // +6
	v__gen__x64__Register_rdi, // +7
	v__gen__x64__Register_eax, // +8
	v__gen__x64__Register_edi, // +9
	v__gen__x64__Register_edx, // +10
	v__gen__x64__Register_r8, // +11
	v__gen__x64__Register_r9, // +12
	v__gen__x64__Register_r10, // +13
	v__gen__x64__Register_r11, // +14
	v__gen__x64__Register_r12, // +15
	v__gen__x64__Register_r13, // +16
	v__gen__x64__Register_r14, // +17
	v__gen__x64__Register_r15, // +18
} v__gen__x64__Register;

typedef enum {
	v__gen__x64__Size__8, // 
	v__gen__x64__Size__16, // +1
	v__gen__x64__Size__32, // +2
	v__gen__x64__Size__64, // +3
} v__gen__x64__Size;

typedef enum {
	v__gen__x64__Register2_x0, // 
	v__gen__x64__Register2_x1, // +1
	v__gen__x64__Register2_x2, // +2
	v__gen__x64__Register2_x3, // +3
	v__gen__x64__Register2_x4, // +4
	v__gen__x64__Register2_x5, // +5
	v__gen__x64__Register2_x6, // +6
	v__gen__x64__Register2_x7, // +7
	v__gen__x64__Register2_x8, // +8
	v__gen__x64__Register2_x9, // +9
	v__gen__x64__Register2_x10, // +10
	v__gen__x64__Register2_x11, // +11
	v__gen__x64__Register2_x12, // +12
	v__gen__x64__Register2_x13, // +13
	v__gen__x64__Register2_x14, // +14
	v__gen__x64__Register2_x15, // +15
	v__gen__x64__Register2_x16, // +16
} v__gen__x64__Register2;


// V type definitions:
typedef struct {
	union {
		void* _object;
		None__* _None__;
		Error* _Error;
		flag__UnkownFlagError* _flag__UnkownFlagError;
		flag__MinimumArgsCountError* _flag__MinimumArgsCountError;
		flag__MaximumArgsCountError* _flag__MaximumArgsCountError;
		flag__NoArgsExpectedError* _flag__NoArgsExpectedError;
		semver__InvalidComparatorFormatError* _semver__InvalidComparatorFormatError;
		semver__EmptyInputError* _semver__EmptyInputError;
		semver__InvalidVersionFormatError* _semver__InvalidVersionFormatError;
	};
	int _typ;
	string* msg;
	int* code;
} IError;
struct string {
	byte* str;
	int len;
	int is_lit;
} ;

struct array {
	int element_size;
	voidptr data;
	int len;
	int cap;
} ;

struct DenseArray {
	int key_bytes;
	int value_bytes;
	int cap;
	int len;
	u32 deletes;
	byte* all_deleted;
	byte* values;
	byte* keys;
} ;

struct map {
	int key_bytes;
	int value_bytes;
	u32 even_index;
	byte cached_hashbits;
	byte shift;
	DenseArray key_values;
	u32* metas;
	u32 extra_metas;
	bool has_string_keys;
	MapHashFn hash_fn;
	MapEqFn key_eq_fn;
	MapCloneFn clone_fn;
	MapFreeFn free_fn;
	int len;
} ;

struct Error {
	string msg;
	int code;
} ;

struct Option {
	byte state;
	IError err;
} ;

typedef array Array_string;
typedef array Array_byte;
typedef array Array_int;
typedef int (*anon_fn_int_int__int)(int,int);
typedef array Array_voidptr;
typedef void (*FnExitCb)();
typedef array Array_VCastTypeIndexName;
typedef array Array_MethodArgs;
typedef u64 Array_fixed_u64_2 [2];
typedef char Array_fixed_char_254 [254];
typedef int (*VectoredExceptionHandler)(ExceptionPointers*);
typedef array Array_byte_ptr;
typedef string Array_fixed_string_11 [11];
typedef voidptr Array_fixed_voidptr_11 [11];
typedef array Array_RepIndex;
typedef map Map_string_int;
typedef struct {
	union {
		void* _object;
	};
	int _typ;
} hash__Hasher;
typedef struct {
	union {
		void* _object;
	};
	int _typ;
} hash__Hash32er;
typedef struct {
	union {
		void* _object;
	};
	int _typ;
} hash__Hash64er;
typedef map Map_string_string;
typedef array Array_ustring;
typedef void (*anon_fn_string)(string);
typedef char Array_fixed_char_256 [256];
typedef void (*os__FN_SA_Handler)(int);
typedef array Array_T;
typedef array Array_char_ptr;
typedef voidptr os__HANDLE;
typedef voidptr os__HMODULE;
typedef u16 Array_fixed_u16_260 [260];
typedef u16 Array_fixed_u16_14 [14];
typedef u32 (*os__VectoredExceptionHandler)(ExceptionPointers*);
typedef int Array_fixed_int_3 [3];
typedef void (*os__FN_NTSuspendResume)(voidptr);
typedef u32* os__PU32;
typedef byte Array_fixed_byte_65536 [65536];
typedef map Map_string_Array_string;
typedef array Array_v__util__Possibility;
typedef map Map_string_time__StopWatch;
typedef array Array_v__ast__File;
typedef array Array_v__builder__FunctionRedefinition;
typedef array Array_v__cflag__CFlag;
typedef voidptr v__builder__RegKey;
typedef array Array_u32;
typedef struct {
	union {
		void* _object;
		rand__wyrand__WyRandRNG* _rand__wyrand__WyRandRNG;
	};
	int _typ;
} rand__PRNG;
typedef i64 time__Duration;
typedef i64 time__time_t;
typedef string (*anon_fn_string__string)(string);
typedef map Map_string_v__token__Kind;
typedef array Array_v__token__Precedence;
typedef array Array_v__vmod__Token;
typedef map Map_string_v__vmod__ModFileAndFolder;
typedef int v__ast__Type;
typedef array Array_v__ast__Stmt;
typedef array Array_v__ast__Comment;
typedef array Array_v__ast__Expr;
typedef array Array_bool;
typedef array Array_v__token__Position;
typedef array Array_v__ast__Type;
typedef array Array_v__ast__Attr;
typedef array Array_v__ast__ConstField;
typedef array Array_v__ast__Embed;
typedef array Array_v__ast__StructField;
typedef array Array_v__ast__FnDecl;
typedef array Array_v__ast__StructInitField;
typedef array Array_v__ast__StructInitEmbed;
typedef array Array_v__ast__ImportSymbol;
typedef array Array_v__ast__Param;
typedef array Array_v__ast__DeferStmt;
typedef array Array_v__ast__CallArg;
typedef array Array_v__ast__GlobalField;
typedef array Array_v__ast__Import;
typedef array Array_v__ast__EmbeddedFile;
typedef array Array_v__errors__Error;
typedef array Array_v__errors__Warning;
typedef array Array_v__errors__Notice;
typedef array Array_v__ast__FnDecl_ptr;
typedef array Array_v__ast__IfBranch;
typedef array Array_v__ast__Ident;
typedef array Array_v__ast__MatchBranch;
typedef array Array_Array_v__ast__Comment;
typedef array Array_v__ast__SelectBranch;
typedef array Array_v__ast__EnumField;
typedef array Array_v__ast__SumTypeVariant;
typedef array Array_v__ast__AsmClobbered;
typedef array Array_v__ast__AsmTemplate;
typedef array Array_v__ast__AsmIO;
typedef array Array_v__ast__AsmArg;
typedef map Map_int_v__ast__SqlStmt;
typedef map Map_int_v__ast__SqlExpr;
typedef array Array_v__ast__Node;
typedef map Map_string_v__ast__ScopeObject;
typedef array Array_v__ast__ScopeStructField;
typedef array Array_v__ast__Scope_ptr;
typedef array Array_v__ast__TypeSymbol;
typedef map Map_string_v__ast__Fn;
typedef map Map_int_string;
typedef array Array_Array_v__ast__Type;
typedef map Map_string_Array_Array_v__ast__Type;
typedef map Map_string_bool;
typedef map Map_string_v__ast__StructField;
typedef array Array_v__ast__Fn;
typedef array Array_v__ast__Kind;
typedef map Map_string_v__ast__Type;
typedef array Array_v__ast__File_ptr;
typedef array Array_i64;
typedef array Array_v__ast__TypeNode;
typedef array Array_v__vet__Error;
typedef array Array_v__depgraph__DepGraphNode;
typedef map Map_string_v__depgraph__DepGraphNode;
typedef map Map_string_strings__Builder;
typedef map Map_int_bool;
typedef array Array_v__gen__c__ProfileCounterMeta;
typedef map Map_string_v__ast__FnDecl;
typedef map Map_string_v__ast__ConstField;
typedef map Map_string_Array_v__ast__FnDecl;
typedef map Map_string_v__gen__js__Namespace_ptr;
typedef array Array_v__ast__CallExpr;
typedef map Map_string_i64;
typedef array Array_v__gen__x64__Symbol;
typedef array Array_v__gen__x64__Reloc;
typedef array Array_v__token__Token;
typedef array Array_flag__Flag;
typedef array Array_f64;
typedef array Array_semver__Comparator;
typedef array Array_semver__ComparatorSet;
typedef array Array_u64;
typedef array Array_strconv__Uint128;
typedef byte Array_fixed_byte_26 [26];
typedef array Array_rune;
typedef byte Array_fixed_byte_256 [256];
typedef u16 Array_fixed_u16_32768 [32768];
typedef byte Array_fixed_byte_4096 [4096];
typedef array Array_os__ProcessState;
typedef array Array_v__token__Kind;
typedef array Array_v__vmod__TokenKind;
typedef byte Array_fixed_byte_50 [50];
typedef map Map_int_Array_string;
typedef map Map_int_Map_string_int;
typedef array Array_v__ast__IdentKind;
typedef array Array_v__pref__Arch;
typedef array Array_v__pref__GarbageCollectionMode;
typedef array Array_v__ast__TypeSymbol_ptr;
typedef array Array_v__gen__x64__Register;
typedef array Array_v__pref__OS;
// builtin types:
//------------------ #endbuiltin
typedef HANDLE __v_thread;
struct ContextRecord {
EMPTY_STRUCT_DECLARATION;
} ;

struct ExceptionPointers {
	ExceptionRecord* exception_record;
	ContextRecord* context_record;
} ;

struct os__Uname {
	string sysname;
	string nodename;
	string release;
	string version;
	string machine;
} ;

struct os__ContextRecord {
EMPTY_STRUCT_DECLARATION;
} ;

struct os__ExceptionPointers {
	ExceptionRecord* exception_record;
	ContextRecord* context_record;
} ;

struct v__cflag__CFlag {
	string mod;
	string os;
	string name;
	string value;
	string cached;
} ;

struct v__builder__WindowsKit {
	string um_lib_path;
	string ucrt_lib_path;
	string um_include_path;
	string ucrt_include_path;
	string shared_include_path;
} ;

struct v__builder__VsInstallation {
	string include_path;
	string lib_path;
	string exe_path;
} ;

struct v__vmod__ModFileAndFolder {
	string vmod_file;
	string vmod_folder;
} ;


// Union sum type v__ast__TypeDecl = 
//          |  229 = v__ast__AliasTypeDecl
//          |  230 = v__ast__FnTypeDecl  
//          |  231 = v__ast__SumTypeDecl 
struct v__ast__TypeDecl {
	union {
		v__ast__AliasTypeDecl* _v__ast__AliasTypeDecl;
		v__ast__FnTypeDecl* _v__ast__FnTypeDecl;
		v__ast__SumTypeDecl* _v__ast__SumTypeDecl;
	};
	int _typ;
	string* name;
	bool* is_pub;
	v__token__Position* pos;
	Array_v__ast__Comment* comments;
};


// Union sum type v__ast__Expr = 
//          |  233 = v__ast__AnonFn      
//          |  234 = v__ast__ArrayDecompose
//          |  235 = v__ast__ArrayInit   
//          |  236 = v__ast__AsCast      
//          |  237 = v__ast__Assoc       
//          |  238 = v__ast__AtExpr      
//          |  239 = v__ast__BoolLiteral 
//          |  240 = v__ast__CTempVar    
//          |  241 = v__ast__CallExpr    
//          |  242 = v__ast__CastExpr    
//          |  243 = v__ast__ChanInit    
//          |  244 = v__ast__CharLiteral 
//          |  245 = v__ast__Comment     
//          |  246 = v__ast__ComptimeCall
//          |  247 = v__ast__ComptimeSelector
//          |  248 = v__ast__ConcatExpr  
//          |  249 = v__ast__DumpExpr    
//          |  250 = v__ast__EmptyExpr   
//          |  251 = v__ast__EnumVal     
//          |  252 = v__ast__FloatLiteral
//          |  253 = v__ast__GoExpr      
//          |  254 = v__ast__Ident       
//          |  255 = v__ast__IfExpr      
//          |  256 = v__ast__IfGuardExpr 
//          |  257 = v__ast__IndexExpr   
//          |  258 = v__ast__InfixExpr   
//          |  259 = v__ast__IntegerLiteral
//          |  260 = v__ast__Likely      
//          |  261 = v__ast__LockExpr    
//          |  262 = v__ast__MapInit     
//          |  263 = v__ast__MatchExpr   
//          |  264 = v__ast__NodeError   
//          |  265 = v__ast__None        
//          |  266 = v__ast__OffsetOf    
//          |  267 = v__ast__OrExpr      
//          |  268 = v__ast__ParExpr     
//          |  269 = v__ast__PostfixExpr 
//          |  270 = v__ast__PrefixExpr  
//          |  271 = v__ast__RangeExpr   
//          |  272 = v__ast__SelectExpr  
//          |  273 = v__ast__SelectorExpr
//          |  274 = v__ast__SizeOf      
//          |  275 = v__ast__SqlExpr     
//          |  276 = v__ast__StringInterLiteral
//          |  277 = v__ast__StringLiteral
//          |  278 = v__ast__StructInit  
//          |  279 = v__ast__TypeNode    
//          |  280 = v__ast__TypeOf      
//          |  281 = v__ast__UnsafeExpr  
struct v__ast__Expr {
	union {
		v__ast__AnonFn* _v__ast__AnonFn;
		v__ast__ArrayDecompose* _v__ast__ArrayDecompose;
		v__ast__ArrayInit* _v__ast__ArrayInit;
		v__ast__AsCast* _v__ast__AsCast;
		v__ast__Assoc* _v__ast__Assoc;
		v__ast__AtExpr* _v__ast__AtExpr;
		v__ast__BoolLiteral* _v__ast__BoolLiteral;
		v__ast__CTempVar* _v__ast__CTempVar;
		v__ast__CallExpr* _v__ast__CallExpr;
		v__ast__CastExpr* _v__ast__CastExpr;
		v__ast__ChanInit* _v__ast__ChanInit;
		v__ast__CharLiteral* _v__ast__CharLiteral;
		v__ast__Comment* _v__ast__Comment;
		v__ast__ComptimeCall* _v__ast__ComptimeCall;
		v__ast__ComptimeSelector* _v__ast__ComptimeSelector;
		v__ast__ConcatExpr* _v__ast__ConcatExpr;
		v__ast__DumpExpr* _v__ast__DumpExpr;
		v__ast__EmptyExpr* _v__ast__EmptyExpr;
		v__ast__EnumVal* _v__ast__EnumVal;
		v__ast__FloatLiteral* _v__ast__FloatLiteral;
		v__ast__GoExpr* _v__ast__GoExpr;
		v__ast__Ident* _v__ast__Ident;
		v__ast__IfExpr* _v__ast__IfExpr;
		v__ast__IfGuardExpr* _v__ast__IfGuardExpr;
		v__ast__IndexExpr* _v__ast__IndexExpr;
		v__ast__InfixExpr* _v__ast__InfixExpr;
		v__ast__IntegerLiteral* _v__ast__IntegerLiteral;
		v__ast__Likely* _v__ast__Likely;
		v__ast__LockExpr* _v__ast__LockExpr;
		v__ast__MapInit* _v__ast__MapInit;
		v__ast__MatchExpr* _v__ast__MatchExpr;
		v__ast__NodeError* _v__ast__NodeError;
		v__ast__None* _v__ast__None;
		v__ast__OffsetOf* _v__ast__OffsetOf;
		v__ast__OrExpr* _v__ast__OrExpr;
		v__ast__ParExpr* _v__ast__ParExpr;
		v__ast__PostfixExpr* _v__ast__PostfixExpr;
		v__ast__PrefixExpr* _v__ast__PrefixExpr;
		v__ast__RangeExpr* _v__ast__RangeExpr;
		v__ast__SelectExpr* _v__ast__SelectExpr;
		v__ast__SelectorExpr* _v__ast__SelectorExpr;
		v__ast__SizeOf* _v__ast__SizeOf;
		v__ast__SqlExpr* _v__ast__SqlExpr;
		v__ast__StringInterLiteral* _v__ast__StringInterLiteral;
		v__ast__StringLiteral* _v__ast__StringLiteral;
		v__ast__StructInit* _v__ast__StructInit;
		v__ast__TypeNode* _v__ast__TypeNode;
		v__ast__TypeOf* _v__ast__TypeOf;
		v__ast__UnsafeExpr* _v__ast__UnsafeExpr;
	};
	int _typ;
};


// Union sum type v__ast__Stmt = 
//          |  283 = v__ast__AsmStmt     
//          |  284 = v__ast__AssertStmt  
//          |  285 = v__ast__AssignStmt  
//          |  286 = v__ast__Block       
//          |  287 = v__ast__BranchStmt  
//          |  288 = v__ast__CompFor     
//          |  289 = v__ast__ConstDecl   
//          |  290 = v__ast__DeferStmt   
//          |  291 = v__ast__EmptyStmt   
//          |  292 = v__ast__EnumDecl    
//          |  293 = v__ast__ExprStmt    
//          |  175 = v__ast__FnDecl      
//          |  294 = v__ast__ForCStmt    
//          |  295 = v__ast__ForInStmt   
//          |  296 = v__ast__ForStmt     
//          |  297 = v__ast__GlobalDecl  
//          |  298 = v__ast__GoStmt      
//          |  299 = v__ast__GotoLabel   
//          |  300 = v__ast__GotoStmt    
//          |  301 = v__ast__HashStmt    
//          |  302 = v__ast__Import      
//          |  303 = v__ast__InterfaceDecl
//          |  304 = v__ast__Module      
//          |  264 = v__ast__NodeError   
//          |  305 = v__ast__Return      
//          |  306 = v__ast__SqlStmt     
//          |  307 = v__ast__StructDecl  
//          |  232 = v__ast__TypeDecl    
struct v__ast__Stmt {
	union {
		v__ast__AsmStmt* _v__ast__AsmStmt;
		v__ast__AssertStmt* _v__ast__AssertStmt;
		v__ast__AssignStmt* _v__ast__AssignStmt;
		v__ast__Block* _v__ast__Block;
		v__ast__BranchStmt* _v__ast__BranchStmt;
		v__ast__CompFor* _v__ast__CompFor;
		v__ast__ConstDecl* _v__ast__ConstDecl;
		v__ast__DeferStmt* _v__ast__DeferStmt;
		v__ast__EmptyStmt* _v__ast__EmptyStmt;
		v__ast__EnumDecl* _v__ast__EnumDecl;
		v__ast__ExprStmt* _v__ast__ExprStmt;
		v__ast__FnDecl* _v__ast__FnDecl;
		v__ast__ForCStmt* _v__ast__ForCStmt;
		v__ast__ForInStmt* _v__ast__ForInStmt;
		v__ast__ForStmt* _v__ast__ForStmt;
		v__ast__GlobalDecl* _v__ast__GlobalDecl;
		v__ast__GoStmt* _v__ast__GoStmt;
		v__ast__GotoLabel* _v__ast__GotoLabel;
		v__ast__GotoStmt* _v__ast__GotoStmt;
		v__ast__HashStmt* _v__ast__HashStmt;
		v__ast__Import* _v__ast__Import;
		v__ast__InterfaceDecl* _v__ast__InterfaceDecl;
		v__ast__Module* _v__ast__Module;
		v__ast__NodeError* _v__ast__NodeError;
		v__ast__Return* _v__ast__Return;
		v__ast__SqlStmt* _v__ast__SqlStmt;
		v__ast__StructDecl* _v__ast__StructDecl;
		v__ast__TypeDecl* _v__ast__TypeDecl;
	};
	int _typ;
	v__token__Position* pos;
};


// Union sum type v__ast__ScopeObject = 
//          |  309 = v__ast__AsmRegister 
//          |  310 = v__ast__ConstField  
//          |  311 = v__ast__GlobalField 
//          |  312 = v__ast__Var         
struct v__ast__ScopeObject {
	union {
		v__ast__AsmRegister* _v__ast__AsmRegister;
		v__ast__ConstField* _v__ast__ConstField;
		v__ast__GlobalField* _v__ast__GlobalField;
		v__ast__Var* _v__ast__Var;
	};
	int _typ;
};


// Union sum type v__ast__Node = 
//          |  314 = v__ast__CallArg     
//          |  310 = v__ast__ConstField  
//          |  315 = v__ast__EmptyNode   
//          |  316 = v__ast__EnumField   
//          |  282 = v__ast__Expr        
//          |  166 = v__ast__File        
//          |  311 = v__ast__GlobalField 
//          |  317 = v__ast__IfBranch    
//          |  318 = v__ast__MatchBranch 
//          |  264 = v__ast__NodeError   
//          |  319 = v__ast__Param       
//          |  313 = v__ast__ScopeObject 
//          |  320 = v__ast__SelectBranch
//          |  308 = v__ast__Stmt        
//          |  321 = v__ast__StructField 
//          |  322 = v__ast__StructInitField
//          |  323 = v__ast__SumTypeVariant
struct v__ast__Node {
	union {
		v__ast__CallArg* _v__ast__CallArg;
		v__ast__ConstField* _v__ast__ConstField;
		v__ast__EmptyNode* _v__ast__EmptyNode;
		v__ast__EnumField* _v__ast__EnumField;
		v__ast__Expr* _v__ast__Expr;
		v__ast__File* _v__ast__File;
		v__ast__GlobalField* _v__ast__GlobalField;
		v__ast__IfBranch* _v__ast__IfBranch;
		v__ast__MatchBranch* _v__ast__MatchBranch;
		v__ast__NodeError* _v__ast__NodeError;
		v__ast__Param* _v__ast__Param;
		v__ast__ScopeObject* _v__ast__ScopeObject;
		v__ast__SelectBranch* _v__ast__SelectBranch;
		v__ast__Stmt* _v__ast__Stmt;
		v__ast__StructField* _v__ast__StructField;
		v__ast__StructInitField* _v__ast__StructInitField;
		v__ast__SumTypeVariant* _v__ast__SumTypeVariant;
	};
	int _typ;
};

struct v__ast__EmbeddedFile {
	string rpath;
	string apath;
} ;


// Union sum type v__ast__IdentInfo = 
//          |  362 = v__ast__IdentFn     
//          |  363 = v__ast__IdentVar    
struct v__ast__IdentInfo {
	union {
		v__ast__IdentFn* _v__ast__IdentFn;
		v__ast__IdentVar* _v__ast__IdentVar;
	};
	int _typ;
	v__ast__Type* typ;
};


// Union sum type v__ast__AsmArg = 
//          |  383 = v__ast__AsmAddressing
//          |  384 = v__ast__AsmAlias    
//          |  385 = v__ast__AsmDisp     
//          |  309 = v__ast__AsmRegister 
//          |  239 = v__ast__BoolLiteral 
//          |  244 = v__ast__CharLiteral 
//          |  252 = v__ast__FloatLiteral
//          |  259 = v__ast__IntegerLiteral
//          |   18 = string              
struct v__ast__AsmArg {
	union {
		v__ast__AsmAddressing* _v__ast__AsmAddressing;
		v__ast__AsmAlias* _v__ast__AsmAlias;
		v__ast__AsmDisp* _v__ast__AsmDisp;
		v__ast__AsmRegister* _v__ast__AsmRegister;
		v__ast__BoolLiteral* _v__ast__BoolLiteral;
		v__ast__CharLiteral* _v__ast__CharLiteral;
		v__ast__FloatLiteral* _v__ast__FloatLiteral;
		v__ast__IntegerLiteral* _v__ast__IntegerLiteral;
		string* _string;
	};
	int _typ;
};


// Union sum type v__ast__TypeInfo = 
//          |  408 = v__ast__Aggregate   
//          |  413 = v__ast__Alias       
//          |  395 = v__ast__Array       
//          |  416 = v__ast__ArrayFixed  
//          |  414 = v__ast__Chan        
//          |  420 = v__ast__Enum        
//          |  418 = v__ast__FnType      
//          |  419 = v__ast__GenericStructInst
//          |  410 = v__ast__Interface   
//          |  396 = v__ast__Map         
//          |  417 = v__ast__MultiReturn 
//          |  409 = v__ast__Struct      
//          |  411 = v__ast__SumType     
//          |  415 = v__ast__Thread      
struct v__ast__TypeInfo {
	union {
		v__ast__Aggregate* _v__ast__Aggregate;
		v__ast__Alias* _v__ast__Alias;
		v__ast__Array* _v__ast__Array;
		v__ast__ArrayFixed* _v__ast__ArrayFixed;
		v__ast__Chan* _v__ast__Chan;
		v__ast__Enum* _v__ast__Enum;
		v__ast__FnType* _v__ast__FnType;
		v__ast__GenericStructInst* _v__ast__GenericStructInst;
		v__ast__Interface* _v__ast__Interface;
		v__ast__Map* _v__ast__Map;
		v__ast__MultiReturn* _v__ast__MultiReturn;
		v__ast__Struct* _v__ast__Struct;
		v__ast__SumType* _v__ast__SumType;
		v__ast__Thread* _v__ast__Thread;
	};
	int _typ;
};

struct v__gen__c__ProfileCounterMeta {
	string fn_name;
	string vpc_name;
	string vpc_calls;
} ;

struct v__gen__js__JsDoc {
	v__gen__js__JsGen* gen;
} ;

struct ustring {
	string s;
	Array_int runes;
	int len;
} ;

struct VCastTypeIndexName {
	int tindex;
	string tname;
} ;

struct VAssertMetaInfo {
	string fpath;
	int line_nr;
	string fn_name;
	string src;
	string op;
	string llabel;
	string rlabel;
	string lvalue;
	string rvalue;
} ;

struct MethodArgs {
	int typ;
	string name;
} ;

struct FunctionData {
	string name;
	Array_string attrs;
	Array_MethodArgs args;
	int return_type;
	int typ;
} ;

struct FieldData {
	string name;
	Array_string attrs;
	bool is_pub;
	bool is_mut;
	int typ;
} ;

struct Line64 {
	u32 f_size_of_struct;
	voidptr f_key;
	u32 f_line_number;
	byte* f_file_name;
	u64 f_address;
} ;

struct ExceptionRecord {
	u32 code;
	u32 flags;
	ExceptionRecord* record;
	voidptr address;
	u32 param_count;
} ;

struct None__ {
	string msg;
	int code;
} ;

struct SortedMap {
	int value_bytes;
	mapnode* root;
	int len;
} ;

struct RepIndex {
	int idx;
	int val_idx;
} ;

struct strings__Builder {
	Array_byte buf;
	int len;
	int initial_size;
} ;

struct strconv__PrepNumber {
	bool negative;
	int exponent;
	u64 mantissa;
} ;

union strconv__Float64u {
	f64 f;
	u64 u;
} ;

struct strconv__Dec32 {
	u32 m;
	int e;
} ;

union strconv__Uf32 {
	f32 f;
	u32 u;
} ;

struct strconv__Dec64 {
	u64 m;
	int e;
} ;

union strconv__Uf64 {
	f64 f;
	u64 u;
} ;

struct strconv__BF_param {
	byte pad_ch;
	int len0;
	int len1;
	bool positive;
	bool sign_flag;
	strconv__Align_text allign;
	bool rm_tail_zero;
} ;

struct strconv__Uint128 {
	u64 lo;
	u64 hi;
} ;

struct os__File {
	voidptr cfile;
	int fd;
	bool is_opened;
} ;

struct os__FileInfo {
	string name;
	int size;
} ;

struct os__FilePermission {
	bool read;
	bool write;
	bool execute;
} ;

struct os__Result {
	int exit_code;
	string output;
} ;

struct os__Filetime {
	u32 dw_low_date_time;
	u32 dw_high_date_time;
} ;

struct os__ProcessInformation {
	voidptr h_process;
	voidptr h_thread;
	u32 dw_process_id;
	u32 dw_thread_id;
} ;

struct os__StartupInfo {
	u32 cb;
	u16* lp_reserved;
	u16* lp_desktop;
	u16* lp_title;
	u32 dw_x;
	u32 dw_y;
	u32 dw_x_size;
	u32 dw_y_size;
	u32 dw_x_count_chars;
	u32 dw_y_count_chars;
	u32 dw_fill_attributes;
	u32 dw_flags;
	u16 w_show_window;
	u16 cb_reserved2;
	byte* lp_reserved2;
	voidptr h_std_input;
	voidptr h_std_output;
	voidptr h_std_error;
} ;

struct os__SecurityAttributes {
	u32 n_length;
	voidptr lp_security_descriptor;
	bool b_inherit_handle;
} ;

struct os__ExceptionRecord {
	u32 code;
	u32 flags;
	ExceptionRecord* record;
	voidptr address;
	u32 param_count;
} ;

struct v__vcache__CacheManager {
	string basepath;
	string original_vopts;
	string vopts;
	Map_string_string k2cpath;
} ;

struct v__util__EManager {
	bool support_color;
} ;

struct v__token__Position {
	int len;
	int line_nr;
	int pos;
	int col;
	int last_line;
} ;

struct v__util__Possibility {
	string value;
	string svalue;
	f32 similarity;
} ;

struct v__util__Suggestion {
	Array_v__util__Possibility known;
	string wanted;
	string swanted;
} ;

struct time__StopWatch {
	u64 elapsed;
	u64 start;
	u64 end;
} ;

struct v__util__Timers {
	Map_string_time__StopWatch swatches;
	bool should_print;
} ;

struct v__ast__Scope {
	Map_string_v__ast__ScopeObject objects;
	Array_v__ast__ScopeStructField struct_fields;
	v__ast__Scope* parent;
	bool detached_from_parent;
	Array_v__ast__Scope_ptr children;
	int start_pos;
	int end_pos;
} ;

struct v__builder__MsvcResult {
	string full_cl_exe_path;
	string exe_path;
	string um_lib_path;
	string ucrt_lib_path;
	string vs_lib_path;
	string um_include_path;
	string ucrt_include_path;
	string vs_include_path;
	string shared_include_path;
	bool valid;
} ;

struct v__ast__Table {
	Array_v__ast__TypeSymbol type_symbols;
	Map_string_int type_idxs;
	Map_string_v__ast__Fn fns;
	Map_int_string dumps;
	Array_string imports;
	Array_string modules;
	Array_v__cflag__CFlag cflags;
	Array_string redefined_fns;
	Map_string_Array_Array_v__ast__Type fn_gen_types;
	string cmod_prefix;
	bool is_fmt;
	Map_string_bool used_fns;
	Map_string_bool used_consts;
} ;

struct v__builder__CcompilerOptions {
	string guessed_compiler;
	string shared_postfix;
	bool debug_mode;
	bool is_cc_tcc;
	bool is_cc_gcc;
	bool is_cc_msvc;
	bool is_cc_clang;
	string env_cflags;
	string env_ldflags;
	Array_string args;
	Array_string wargs;
	Array_string pre_args;
	Array_string o_args;
	Array_string source_args;
	Array_string post_args;
	Array_string linker_flags;
} ;

struct v__depgraph__DepGraph {
	bool acyclic;
	Array_v__depgraph__DepGraphNode nodes;
} ;

struct v__builder__MsvcStringFlags {
	Array_string real_libs;
	Array_string inc_paths;
	Array_string lib_paths;
	Array_string defines;
	Array_string other_flags;
} ;

struct rand__PRNGConfigStruct {
	Array_u32 seed;
} ;

struct rand__wyrand__WyRandRNG {
	u64 state;
	bool has_extra;
	u32 extra;
} ;

struct time__Time {
	int year;
	int month;
	int day;
	int hour;
	int minute;
	int second;
	int microsecond;
	u64 v_unix;
} ;

struct time__StopWatchOptions {
	bool auto_start;
} ;

struct time__SystemTime {
	u16 year;
	u16 month;
	u16 day_of_week;
	u16 day;
	u16 hour;
	u16 minute;
	u16 second;
	u16 millisecond;
} ;

struct term__Coord {
	int x;
	int y;
} ;

struct v__token__Token {
	v__token__Kind kind;
	string lit;
	int line_nr;
	int col;
	int pos;
	int len;
	int tidx;
} ;

struct v__vmod__Manifest {
	string name;
	string version;
	string description;
	Array_string dependencies;
	string license;
	string repo_url;
	string author;
	Map_string_Array_string unknown;
} ;

struct v__vmod__Token {
	v__vmod__TokenKind typ;
	string val;
} ;

struct v__vmod__Scanner {
	int pos;
	string text;
	bool inside_text;
	Array_v__vmod__Token tokens;
} ;

struct v__vmod__ModFileCacher {
	Map_string_v__vmod__ModFileAndFolder cache;
	Map_string_Array_string folder_files;
} ;

struct v__ast__CTempVar {
	string name;
	v__ast__Expr orig;
	v__ast__Type typ;
	bool is_ptr;
} ;

struct v__ast__EmptyExpr {
	int x;
} ;

struct v__ast__AsmRegister {
	string name;
	v__ast__Type typ;
	int size;
} ;

struct v__ast__EmptyNode {
	int x;
} ;

struct v__ast__IdentFn {
	v__ast__Type typ;
} ;

struct v__ast__IdentVar {
	v__ast__Type typ;
	bool is_mut;
	bool is_static;
	bool is_optional;
	v__ast__ShareType share;
} ;

struct v__ast__TypeSymbol {
	int parent_idx;
	v__ast__TypeInfo info;
	v__ast__Kind kind;
	string name;
	string cname;
	Array_v__ast__Fn methods;
	string mod;
	bool is_public;
	v__ast__Language language;
} ;

struct v__ast__Array {
	int nr_dims;
	v__ast__Type elem_type;
} ;

struct v__ast__Map {
	v__ast__Type key_type;
	v__ast__Type value_type;
} ;

struct v__ast__Fn {
	Array_v__ast__Param params;
	v__ast__Type return_type;
	bool is_variadic;
	v__ast__Language language;
	Array_string generic_names;
	bool is_pub;
	bool is_deprecated;
	bool is_unsafe;
	bool is_placeholder;
	bool is_main;
	bool is_test;
	bool is_conditional;
	bool is_keep_alive;
	bool no_body;
	string mod;
	string ctdefine;
	Array_v__ast__Attr attrs;
	string name;
	voidptr source_fn;
	int usages;
} ;

struct v__ast__Aggregate {
	Array_v__ast__StructField fields;
	Array_v__ast__Type types;
} ;

struct v__ast__Struct {
	Array_v__ast__Attr attrs;
	Array_v__ast__Type embeds;
	Array_v__ast__StructField fields;
	bool is_typedef;
	bool is_union;
	bool is_heap;
	Array_v__ast__Type generic_types;
	Array_v__ast__Type concrete_types;
	v__ast__Type parent_type;
} ;

struct v__ast__Interface {
	Array_v__ast__Type types;
	Array_v__ast__StructField fields;
	Array_v__ast__Fn methods;
} ;

struct v__ast__SumType {
	Array_v__ast__Type variants;
	Array_v__ast__StructField fields;
	bool found_fields;
} ;

struct v__ast__Alias {
	v__ast__Type parent_type;
	v__ast__Language language;
	bool is_import;
} ;

struct v__ast__Chan {
	v__ast__Type elem_type;
	bool is_mut;
} ;

struct v__ast__Thread {
	v__ast__Type return_type;
} ;

struct v__ast__ArrayFixed {
	int size;
	v__ast__Type elem_type;
} ;

struct v__ast__MultiReturn {
	Array_v__ast__Type types;
} ;

struct v__ast__GenericStructInst {
	int parent_idx;
	Array_v__ast__Type generic_types;
} ;

struct v__ast__Enum {
	Array_string vals;
	bool is_flag;
	bool is_multi_allowed;
} ;

struct v__ast__FnSignatureOpts {
	bool skip_receiver;
	bool type_only;
} ;

struct v__scanner__Scanner {
	string file_path;
	string file_base;
	string text;
	int pos;
	int line_nr;
	int last_nl_pos;
	bool is_crlf;
	bool is_inside_string;
	bool is_inter_start;
	bool is_inter_end;
	bool is_enclosed_inter;
	string line_comment;
	bool is_started;
	bool is_print_line_on_error;
	bool is_print_colored_error;
	bool is_print_rel_paths_on_error;
	byte quote;
	byte inter_quote;
	Array_int line_ends;
	int nr_lines;
	bool is_vh;
	bool is_fmt;
	v__scanner__CommentsMode comments_mode;
	bool is_inside_toplvl_statement;
	Array_v__token__Token all_tokens;
	int tidx;
	int eofs;
	v__pref__Preferences* pref;
	Array_v__errors__Error errors;
	Array_v__errors__Warning warnings;
	Array_v__errors__Notice notices;
	Array_v__vet__Error vet_errors;
} ;

struct v__parser__EatCommentsConfig {
	bool same_line;
	bool follow_up;
} ;

struct v__depgraph__DepGraphNode {
	string name;
	Array_string deps;
} ;

struct v__depgraph__OrderedDepMap {
	Array_string keys;
	Map_string_Array_string data;
} ;

struct v__markused__Walker {
	v__ast__Table* table;
	Map_string_bool used_fns;
	Map_string_bool used_consts;
	int n_maps;
	int n_asserts;
	Array_v__ast__File files;
	Map_string_v__ast__FnDecl all_fns;
	Map_string_v__ast__ConstField all_consts;
} ;

struct v__gen__js__BuiltinPrototypeConfig {
	string typ_name;
	string val_name;
	string default_value;
	string constructor;
	string value_of;
	string to_string;
	string eq;
	string extras;
	bool has_strfn;
} ;

struct v__gen__x64__Gen {
	string out_name;
	v__pref__Preferences* pref;
	v__ast__Table* table;
	Array_byte buf;
	int sect_header_name_pos;
	i64 offset;
	Array_i64 str_pos;
	Array_string strings;
	i64 file_size_pos;
	i64 main_fn_addr;
	i64 code_start_pos;
	Map_string_i64 fn_addr;
	Map_string_int var_offset;
	int stack_var_pos;
	int debug_pos;
	Array_v__errors__Error errors;
	Array_v__errors__Warning warnings;
	Array_v__gen__x64__Symbol syms;
	Array_v__gen__x64__Reloc relocs;
	int nlines;
} ;

struct v__gen__x64__SectionConfig {
	string name;
	v__gen__x64__SectionType typ;
	i64 flags;
	voidptr data;
	bool is_saa;
	i64 datalen;
	int v_link;
	int info;
	i64 align;
	i64 entsize;
} ;

struct v__gen__x64__Symbol {
	int str_entry;
	int symbol_typ;
	int section;
	int desc;
	i64 val;
	string name;
	bool is_ext;
} ;

struct v__gen__x64__Reloc {
	int addr;
	int pcrel;
	int len;
	int ext;
	int typ;
	int snum;
} ;

struct v__pkgconfig__MainOptions {
	bool modversion;
	bool description;
	bool help;
	bool debug;
	bool listall;
	bool exists;
	bool variables;
	bool requires;
	string atleast;
	string atleastpc;
	string exactversion;
	bool version;
	bool cflags;
	bool cflags_only_path;
	bool cflags_only_other;
	bool stat1c;
	bool libs;
	bool libs_only_link;
	bool libs_only_path;
	bool libs_only_other;
	Array_string args;
} ;

struct v__pkgconfig__Main {
	v__pkgconfig__MainOptions* opt;
	string res;
	bool has_actions;
} ;

struct v__pkgconfig__Options {
	string path;
	bool debug;
	bool norecurse;
	bool only_description;
	bool use_default_paths;
} ;

struct flag__FlagParser {
	Array_string args;
	int max_free_args;
	Array_flag__Flag flags;
	string application_name;
	string application_version;
	string application_description;
	int min_free_args;
	string args_description;
} ;

struct flag__Flag {
	string name;
	byte abbr;
	string usage;
	string val_desc;
} ;

struct flag__UnkownFlagError {
	string msg;
	int code;
} ;

struct flag__MinimumArgsCountError {
	string msg;
	int code;
} ;

struct flag__MaximumArgsCountError {
	string msg;
	int code;
} ;

struct flag__NoArgsExpectedError {
	string msg;
	int code;
} ;

struct semver__Version {
	int major;
	int minor;
	int patch;
	string prerelease;
	string metadata;
} ;

struct semver__RawVersion {
	string prerelease;
	string metadata;
	Array_string raw_ints;
} ;

struct semver__ComparatorSet {
	Array_semver__Comparator comparators;
} ;

struct semver__Range {
	Array_semver__ComparatorSet comparator_sets;
} ;

struct semver__InvalidComparatorCountError {
	string msg;
	int code;
} ;

struct semver__InvalidComparatorFormatError {
	string msg;
	int code;
} ;

struct semver__EmptyInputError {
	string msg;
	int code;
} ;

struct semver__InvalidVersionFormatError {
	string msg;
	int code;
} ;

struct SymbolInfo {
	u32 f_size_of_struct;
	u32 f_type_index;
	Array_fixed_u64_2 f_reserved;
	u32 f_index;
	u32 f_size;
	u64 f_mod_base;
	u32 f_flags;
	u64 f_value;
	u64 f_address;
	u32 f_register;
	u32 f_scope;
	u32 f_tag;
	u32 f_name_len;
	u32 f_max_name_len;
	byte f_name;
} ;

struct mapnode {
	voidptr* children;
	int len;
	Array_fixed_string_11 keys;
	Array_fixed_voidptr_11 values;
} ;

struct os__FileMode {
	os__FileType typ;
	os__FilePermission owner;
	os__FilePermission group;
	os__FilePermission others;
} ;

struct os__Win32finddata {
	u32 dw_file_attributes;
	os__Filetime ft_creation_time;
	os__Filetime ft_last_access_time;
	os__Filetime ft_last_write_time;
	u32 n_file_size_high;
	u32 n_file_size_low;
	u32 dw_reserved0;
	u32 dw_reserved1;
	Array_fixed_u16_260 c_file_name;
	Array_fixed_u16_14 c_alternate_file_name;
	u32 dw_file_type;
	u32 dw_creator_type;
	u16 w_finder_flags;
} ;

struct os__Process {
	string filename;
	int pid;
	int code;
	os__ProcessState status;
	string err;
	Array_string args;
	bool env_is_custom;
	Array_string env;
	bool use_stdio_ctl;
	bool use_pgroup;
	Array_fixed_int_3 stdio_fd;
	voidptr wdata;
} ;

struct os__WProcess {
	os__ProcessInformation proc_info;
	Array_fixed_byte_65536 command_line;
	u32* child_stdin;
	u32* child_stdout_read;
	u32* child_stdout_write;
	u32* child_stderr_read;
	u32* child_stderr_write;
} ;

struct v__pref__Preferences {
	v__pref__OS os;
	v__pref__Backend backend;
	v__pref__BuildMode build_mode;
	v__pref__Arch arch;
	v__pref__OutputMode output_mode;
	bool is_verbose;
	bool is_watch;
	bool is_test;
	bool is_script;
	bool is_vsh;
	bool is_livemain;
	bool is_liveshared;
	bool is_shared;
	bool is_prof;
	string profile_file;
	bool profile_no_inline;
	bool translated;
	bool is_prod;
	bool obfuscate;
	bool is_repl;
	bool is_run;
	bool sanitize;
	bool is_debug;
	bool is_vlines;
	bool show_cc;
	bool show_c_output;
	string dump_c_flags;
	bool use_cache;
	bool retry_compilation;
	bool is_stats;
	string cflags;
	bool m64;
	string ccompiler;
	v__pref__CompilerType ccompiler_type;
	string third_party_option;
	bool building_v;
	bool autofree;
	bool compress;
	bool enable_globals;
	bool is_fmt;
	bool is_vet;
	bool is_bare;
	bool no_preludes;
	string custom_prelude;
	Array_string lookup_path;
	string bare_builtin_dir;
	bool output_cross_c;
	bool prealloc;
	string vroot;
	string out_name_c;
	string out_name;
	string path;
	Array_string compile_defines;
	Array_string compile_defines_all;
	Array_string run_args;
	Array_string printfn_list;
	bool print_v_files;
	bool skip_running;
	bool skip_warnings;
	bool warn_impure_v;
	bool warns_are_errors;
	bool fatal_errors;
	bool reuse_tmpc;
	v__pref__ColorOutput use_color;
	bool is_parallel;
	int error_limit;
	bool is_vweb;
	bool only_check_syntax;
	bool experimental;
	bool skip_unused;
	bool show_timings;
	bool is_ios_simulator;
	bool is_apk;
	Array_string cleanup_files;
	Array_string build_options;
	v__vcache__CacheManager cache_manager;
	bool is_help;
	v__pref__GarbageCollectionMode gc_mode;
	int checker_match_exhaustive_cutoff_limit;
} ;

struct v__vmod__Parser {
	string file_path;
	v__vmod__Scanner scanner;
} ;

struct v__ast__AliasTypeDecl {
	string name;
	bool is_pub;
	v__ast__Type parent_type;
	v__token__Position pos;
	v__token__Position type_pos;
	Array_v__ast__Comment comments;
} ;

struct v__ast__FnTypeDecl {
	string name;
	bool is_pub;
	v__ast__Type typ;
	v__token__Position pos;
	v__token__Position type_pos;
	Array_v__ast__Comment comments;
} ;

struct v__ast__SumTypeDecl {
	string name;
	bool is_pub;
	v__token__Position pos;
	Array_v__ast__Comment comments;
	v__ast__Type typ;
	Array_v__ast__SumTypeVariant variants;
} ;

struct v__ast__ArrayDecompose {
	v__ast__Expr expr;
	v__token__Position pos;
	v__ast__Type expr_type;
	v__ast__Type arg_type;
} ;

struct v__ast__ArrayInit {
	v__token__Position pos;
	v__token__Position elem_type_pos;
	Array_v__ast__Expr exprs;
	Array_Array_v__ast__Comment ecmnts;
	Array_v__ast__Comment pre_cmnts;
	bool is_fixed;
	bool has_val;
	string mod;
	v__ast__Expr len_expr;
	v__ast__Expr cap_expr;
	v__ast__Expr default_expr;
	bool has_len;
	bool has_cap;
	bool has_default;
	Array_v__ast__Type expr_types;
	v__ast__Type elem_type;
	v__ast__Type typ;
} ;

struct v__ast__AsCast {
	v__ast__Expr expr;
	v__ast__Type typ;
	v__token__Position pos;
	v__ast__Type expr_type;
} ;

struct v__ast__Assoc {
	string var_name;
	Array_string fields;
	Array_v__ast__Expr exprs;
	v__token__Position pos;
	v__ast__Type typ;
	v__ast__Scope* scope;
} ;

struct v__ast__AtExpr {
	string name;
	v__token__Position pos;
	v__token__AtKind kind;
	string val;
} ;

struct v__ast__BoolLiteral {
	bool val;
	v__token__Position pos;
} ;

struct v__ast__CastExpr {
	v__ast__Expr expr;
	v__ast__Expr arg;
	v__ast__Type typ;
	v__token__Position pos;
	string typname;
	v__ast__Type expr_type;
	bool has_arg;
	bool in_prexpr;
} ;

struct v__ast__ChanInit {
	v__token__Position pos;
	v__ast__Expr cap_expr;
	bool has_cap;
	v__ast__Type typ;
	v__ast__Type elem_type;
} ;

struct v__ast__CharLiteral {
	string val;
	v__token__Position pos;
} ;

struct v__ast__Comment {
	string text;
	bool is_multi;
	int line_nr;
	v__token__Position pos;
} ;

struct v__ast__ComptimeSelector {
	bool has_parens;
	v__ast__Expr left;
	v__ast__Expr field_expr;
	v__token__Position pos;
	v__ast__Type left_type;
	v__ast__Type typ;
} ;

struct v__ast__ConcatExpr {
	Array_v__ast__Expr vals;
	v__token__Position pos;
	v__ast__Type return_type;
} ;

struct v__ast__DumpExpr {
	v__ast__Expr expr;
	v__token__Position pos;
	v__ast__Type expr_type;
	string cname;
} ;

struct v__ast__EnumVal {
	string enum_name;
	string val;
	string mod;
	v__token__Position pos;
	v__ast__Type typ;
} ;

struct v__ast__FloatLiteral {
	string val;
	v__token__Position pos;
} ;

struct v__ast__Ident {
	v__ast__Language language;
	v__token__Kind tok_kind;
	v__token__Position pos;
	v__token__Position mut_pos;
	v__ast__Scope* scope;
	v__ast__ScopeObject obj;
	string mod;
	string name;
	v__ast__IdentKind kind;
	v__ast__IdentInfo info;
	bool is_mut;
} ;

struct v__ast__IfExpr {
	bool is_comptime;
	v__token__Kind tok_kind;
	v__ast__Expr left;
	v__token__Position pos;
	Array_v__ast__Comment post_comments;
	Array_v__ast__IfBranch branches;
	bool is_expr;
	v__ast__Type typ;
	bool has_else;
} ;

struct v__ast__IfGuardExpr {
	string var_name;
	v__token__Position pos;
	v__ast__Expr expr;
	v__ast__Type expr_type;
} ;

struct v__ast__IntegerLiteral {
	string val;
	v__token__Position pos;
} ;

struct v__ast__Likely {
	v__ast__Expr expr;
	v__token__Position pos;
	bool is_likely;
} ;

struct v__ast__LockExpr {
	Array_v__ast__Stmt stmts;
	Array_bool is_rlock;
	v__token__Position pos;
	Array_v__ast__Ident lockeds;
	bool is_expr;
	v__ast__Type typ;
} ;

struct v__ast__MapInit {
	v__token__Position pos;
	Array_v__ast__Expr keys;
	Array_v__ast__Expr vals;
	Array_Array_v__ast__Comment comments;
	Array_v__ast__Comment pre_cmnts;
	v__ast__Type typ;
	v__ast__Type key_type;
	v__ast__Type value_type;
} ;

struct v__ast__MatchExpr {
	v__token__Kind tok_kind;
	v__ast__Expr cond;
	Array_v__ast__MatchBranch branches;
	v__token__Position pos;
	Array_v__ast__Comment comments;
	bool is_expr;
	v__ast__Type return_type;
	v__ast__Type cond_type;
	v__ast__Type expected_type;
	bool is_sum_type;
} ;

struct v__ast__NodeError {
	int idx;
	v__token__Position pos;
} ;

struct v__ast__None {
	v__token__Position pos;
} ;

struct v__ast__OffsetOf {
	v__ast__Type struct_type;
	string field;
	v__token__Position pos;
} ;

struct v__ast__OrExpr {
	Array_v__ast__Stmt stmts;
	v__ast__OrKind kind;
	v__token__Position pos;
} ;

struct v__ast__ParExpr {
	v__ast__Expr expr;
	v__token__Position pos;
} ;

struct v__ast__PostfixExpr {
	v__token__Kind op;
	v__ast__Expr expr;
	v__token__Position pos;
	string auto_locked;
} ;

struct v__ast__RangeExpr {
	v__ast__Expr low;
	v__ast__Expr high;
	bool has_high;
	bool has_low;
	v__token__Position pos;
} ;

struct v__ast__SelectExpr {
	Array_v__ast__SelectBranch branches;
	v__token__Position pos;
	bool has_exception;
	bool is_expr;
	v__ast__Type expected_type;
} ;

struct v__ast__SelectorExpr {
	v__token__Position pos;
	string field_name;
	bool is_mut;
	v__token__Position mut_pos;
	v__token__Kind next_token;
	v__ast__Expr expr;
	v__ast__Type expr_type;
	v__ast__Type typ;
	v__ast__Type name_type;
	v__ast__Scope* scope;
	v__ast__Type from_embed_type;
} ;

struct v__ast__SizeOf {
	bool is_type;
	v__ast__Expr expr;
	v__token__Position pos;
	v__ast__Type typ;
} ;

struct v__ast__StringInterLiteral {
	Array_string vals;
	Array_v__ast__Expr exprs;
	Array_int fwidths;
	Array_int precisions;
	Array_bool pluss;
	Array_bool fills;
	Array_v__token__Position fmt_poss;
	v__token__Position pos;
	Array_v__ast__Type expr_types;
	Array_byte fmts;
	Array_bool need_fmts;
} ;

struct v__ast__StringLiteral {
	string val;
	bool is_raw;
	v__ast__Language language;
	v__token__Position pos;
} ;

struct v__ast__StructInit {
	v__token__Position pos;
	v__token__Position name_pos;
	bool is_short;
	bool unresolved;
	Array_v__ast__Comment pre_comments;
	v__ast__Type typ;
	v__ast__Expr update_expr;
	v__ast__Type update_expr_type;
	Array_v__ast__Comment update_expr_comments;
	bool has_update_expr;
	Array_v__ast__StructInitField fields;
	Array_v__ast__StructInitEmbed embeds;
} ;

struct v__ast__TypeNode {
	v__ast__Type typ;
	v__token__Position pos;
} ;

struct v__ast__TypeOf {
	v__ast__Expr expr;
	v__token__Position pos;
	v__ast__Type expr_type;
} ;

struct v__ast__UnsafeExpr {
	v__ast__Expr expr;
	v__token__Position pos;
} ;

struct v__ast__AsmStmt {
	v__pref__Arch arch;
	bool is_top_level;
	bool is_volatile;
	bool is_goto;
	Array_v__ast__AsmClobbered clobbered;
	v__token__Position pos;
	Array_v__ast__AsmTemplate templates;
	v__ast__Scope* scope;
	Array_v__ast__AsmIO output;
	Array_v__ast__AsmIO input;
	Array_string global_labels;
	Array_string local_labels;
} ;

struct v__ast__AssertStmt {
	v__token__Position pos;
	v__ast__Expr expr;
} ;

struct v__ast__AssignStmt {
	v__token__Kind op;
	v__token__Position pos;
	Array_v__ast__Comment comments;
	Array_v__ast__Comment end_comments;
	Array_v__ast__Expr right;
	Array_v__ast__Expr left;
	Array_v__ast__Type left_types;
	Array_v__ast__Type right_types;
	bool is_static;
	bool is_simple;
	bool has_cross_var;
} ;

struct v__ast__Block {
	Array_v__ast__Stmt stmts;
	bool is_unsafe;
	v__token__Position pos;
} ;

struct v__ast__BranchStmt {
	v__token__Kind kind;
	string label;
	v__token__Position pos;
} ;

struct v__ast__CompFor {
	string val_var;
	Array_v__ast__Stmt stmts;
	v__ast__CompForKind kind;
	v__token__Position pos;
	v__token__Position typ_pos;
	v__ast__Type typ;
} ;

struct v__ast__ConstDecl {
	bool is_pub;
	v__token__Position pos;
	Array_v__ast__ConstField fields;
	Array_v__ast__Comment end_comments;
	bool is_block;
} ;

struct v__ast__DeferStmt {
	Array_v__ast__Stmt stmts;
	v__token__Position pos;
	string ifdef;
	int idx_in_fn;
} ;

struct v__ast__EmptyStmt {
	v__token__Position pos;
} ;

struct v__ast__EnumDecl {
	string name;
	bool is_pub;
	bool is_flag;
	bool is_multi_allowed;
	Array_v__ast__Comment comments;
	Array_v__ast__EnumField fields;
	Array_v__ast__Attr attrs;
	v__token__Position pos;
} ;

struct v__ast__ExprStmt {
	v__ast__Expr expr;
	v__token__Position pos;
	Array_v__ast__Comment comments;
	bool is_expr;
	v__ast__Type typ;
} ;

struct v__ast__ForCStmt {
	v__ast__Stmt init;
	bool has_init;
	v__ast__Expr cond;
	bool has_cond;
	v__ast__Stmt inc;
	bool has_inc;
	bool is_multi;
	Array_v__ast__Stmt stmts;
	v__token__Position pos;
	string label;
	v__ast__Scope* scope;
} ;

struct v__ast__ForInStmt {
	string key_var;
	string val_var;
	v__ast__Expr cond;
	bool is_range;
	v__ast__Expr high;
	Array_v__ast__Stmt stmts;
	v__token__Position pos;
	bool val_is_mut;
	v__ast__Type key_type;
	v__ast__Type val_type;
	v__ast__Type cond_type;
	v__ast__Kind kind;
	string label;
	v__ast__Scope* scope;
} ;

struct v__ast__ForStmt {
	v__ast__Expr cond;
	Array_v__ast__Stmt stmts;
	bool is_inf;
	v__token__Position pos;
	string label;
	v__ast__Scope* scope;
} ;

struct v__ast__GlobalDecl {
	v__token__Position pos;
	Array_v__ast__GlobalField fields;
	Array_v__ast__Comment end_comments;
} ;

struct v__ast__GotoLabel {
	string name;
	v__token__Position pos;
} ;

struct v__ast__GotoStmt {
	string name;
	v__token__Position pos;
} ;

struct v__ast__HashStmt {
	string mod;
	v__token__Position pos;
	string source_file;
	string val;
	string kind;
	string main;
	string msg;
} ;

struct v__ast__Import {
	string mod;
	string alias;
	v__token__Position pos;
	v__token__Position mod_pos;
	v__token__Position alias_pos;
	v__token__Position syms_pos;
	Array_v__ast__ImportSymbol syms;
	Array_v__ast__Comment comments;
	Array_v__ast__Comment next_comments;
} ;

struct v__ast__InterfaceDecl {
	string name;
	v__token__Position name_pos;
	Array_string field_names;
	bool is_pub;
	Array_v__ast__FnDecl methods;
	int mut_pos;
	Array_v__ast__StructField fields;
	v__token__Position pos;
	Array_v__ast__Comment pre_comments;
} ;

struct v__ast__Module {
	string name;
	string short_name;
	Array_v__ast__Attr attrs;
	v__token__Position pos;
	v__token__Position name_pos;
	bool is_skipped;
} ;

struct v__ast__Return {
	v__token__Position pos;
	Array_v__ast__Expr exprs;
	Array_v__ast__Comment comments;
	Array_v__ast__Type types;
} ;

struct v__ast__StructDecl {
	v__token__Position pos;
	string name;
	Array_v__ast__Type gen_types;
	bool is_pub;
	int mut_pos;
	int pub_pos;
	int pub_mut_pos;
	int global_pos;
	int module_pos;
	v__ast__Language language;
	bool is_union;
	Array_v__ast__Attr attrs;
	Array_v__ast__Comment end_comments;
	Array_v__ast__Embed embeds;
	Array_v__ast__StructField fields;
} ;

struct v__ast__ConstField {
	string mod;
	string name;
	v__ast__Expr expr;
	bool is_pub;
	v__token__Position pos;
	v__ast__Type typ;
	Array_v__ast__Comment comments;
} ;

struct v__ast__GlobalField {
	string name;
	v__ast__Expr expr;
	bool has_expr;
	v__token__Position pos;
	v__ast__Type typ;
	Array_v__ast__Comment comments;
} ;

struct v__ast__Var {
	string name;
	v__ast__Expr expr;
	v__ast__ShareType share;
	bool is_mut;
	bool is_autofree_tmp;
	bool is_arg;
	bool is_auto_deref;
	v__ast__Type typ;
	v__ast__Type orig_type;
	Array_v__ast__Type smartcasts;
	v__token__Position pos;
	bool is_used;
	bool is_changed;
	bool is_or;
	bool is_tmp;
} ;

struct v__ast__CallArg {
	bool is_mut;
	v__ast__ShareType share;
	v__ast__Expr expr;
	Array_v__ast__Comment comments;
	v__ast__Type typ;
	bool is_tmp_autofree;
	v__token__Position pos;
} ;

struct v__ast__EnumField {
	string name;
	v__token__Position pos;
	Array_v__ast__Comment comments;
	Array_v__ast__Comment next_comments;
	v__ast__Expr expr;
	bool has_expr;
} ;

struct v__ast__IfBranch {
	v__ast__Expr cond;
	v__token__Position pos;
	v__token__Position body_pos;
	Array_v__ast__Comment comments;
	Array_v__ast__Stmt stmts;
	v__ast__Scope* scope;
} ;

struct v__ast__MatchBranch {
	Array_v__ast__Expr exprs;
	Array_Array_v__ast__Comment ecmnts;
	Array_v__ast__Stmt stmts;
	v__token__Position pos;
	bool is_else;
	Array_v__ast__Comment post_comments;
	v__ast__Scope* scope;
} ;

struct v__ast__Param {
	v__token__Position pos;
	string name;
	bool is_mut;
	bool is_auto_rec;
	v__ast__Type typ;
	v__token__Position type_pos;
	bool is_hidden;
} ;

struct v__ast__StructField {
	v__token__Position pos;
	v__token__Position type_pos;
	Array_v__ast__Comment comments;
	v__ast__Expr default_expr;
	bool has_default_expr;
	Array_v__ast__Attr attrs;
	bool is_pub;
	string default_val;
	bool is_mut;
	bool is_global;
	v__ast__Type default_expr_typ;
	string name;
	v__ast__Type typ;
} ;

struct v__ast__StructInitField {
	v__ast__Expr expr;
	v__token__Position pos;
	v__token__Position name_pos;
	Array_v__ast__Comment comments;
	Array_v__ast__Comment next_comments;
	string name;
	v__ast__Type typ;
	v__ast__Type expected_type;
	v__ast__Type parent_type;
} ;

struct v__ast__SumTypeVariant {
	v__ast__Type typ;
	v__token__Position pos;
} ;

struct v__ast__Attr {
	string name;
	bool is_string;
	bool is_comptime_define;
	string arg;
	bool is_string_arg;
	v__token__Position pos;
} ;

struct v__ast__Embed {
	v__ast__Type typ;
	v__token__Position pos;
} ;

struct v__ast__StructEmbedding {
	string name;
	v__ast__Type typ;
	v__token__Position pos;
} ;

struct v__ast__StructInitEmbed {
	v__ast__Expr expr;
	v__token__Position pos;
	Array_v__ast__Comment comments;
	Array_v__ast__Comment next_comments;
	string name;
	v__ast__Type typ;
	v__ast__Type expected_type;
} ;

struct v__ast__ImportSymbol {
	v__token__Position pos;
	string name;
} ;

struct v__ast__ScopeStructField {
	v__ast__Type struct_type;
	string name;
	v__token__Position pos;
	v__ast__Type typ;
	Array_v__ast__Type smartcasts;
	v__ast__Type orig_type;
} ;

struct v__errors__Error {
	string message;
	string details;
	string file_path;
	v__token__Position pos;
	string backtrace;
	v__errors__Reporter reporter;
} ;

struct v__errors__Warning {
	string message;
	string details;
	string file_path;
	v__token__Position pos;
	v__errors__Reporter reporter;
} ;

struct v__errors__Notice {
	string message;
	string details;
	string file_path;
	v__token__Position pos;
	v__errors__Reporter reporter;
} ;

struct v__ast__AsmClobbered {
	v__ast__AsmRegister reg;
	Array_v__ast__Comment comments;
} ;

struct v__ast__AsmTemplate {
	string name;
	bool is_label;
	bool is_directive;
	Array_v__ast__AsmArg args;
	Array_v__ast__Comment comments;
	v__token__Position pos;
} ;

struct v__ast__AsmIO {
	string alias;
	string constraint;
	v__ast__Expr expr;
	Array_v__ast__Comment comments;
	v__ast__Type typ;
	v__token__Position pos;
} ;

struct v__ast__AsmAddressing {
	int scale;
	v__ast__AddressingMode mode;
	v__token__Position pos;
	v__ast__AsmArg displacement;
	v__ast__AsmArg base;
	v__ast__AsmArg index;
} ;

struct v__ast__AsmAlias {
	string name;
	v__token__Position pos;
} ;

struct v__ast__AsmDisp {
	string val;
	v__token__Position pos;
} ;

struct v__ast__FnType {
	bool is_anon;
	bool has_decl;
	v__ast__Fn func;
} ;

struct v__parser__Parser {
	v__pref__Preferences* pref;
	string file_base;
	string file_name;
	string file_name_dir;
	v__ast__Language file_backend_mode;
	v__scanner__Scanner* scanner;
	v__scanner__CommentsMode comments_mode;
	v__token__Token tok;
	v__token__Token prev_tok;
	v__token__Token peek_tok;
	v__ast__Table* table;
	v__ast__Language language;
	bool inside_if;
	bool inside_if_expr;
	bool inside_ct_if_expr;
	bool inside_or_expr;
	bool inside_for;
	bool inside_fn;
	bool inside_unsafe_fn;
	bool inside_str_interp;
	bool or_is_handled;
	bool builtin_mod;
	string mod;
	bool is_manualfree;
	Array_v__ast__Attr attrs;
	string expr_mod;
	v__ast__Scope* scope;
	v__ast__Scope* global_scope;
	Map_string_string imports;
	Array_v__ast__Import ast_imports;
	Array_string used_imports;
	Array_string auto_imports;
	Map_string_string imported_symbols;
	bool is_amp;
	bool returns;
	bool inside_match;
	bool inside_select;
	bool inside_match_case;
	bool inside_match_body;
	bool inside_unsafe;
	bool is_stmt_ident;
	bool expecting_type;
	Array_v__errors__Error errors;
	Array_v__errors__Warning warnings;
	Array_v__errors__Notice notices;
	Array_v__vet__Error vet_errors;
	string cur_fn_name;
	Array_string label_names;
	bool in_generic_params;
	bool name_error;
	int n_asm;
	bool inside_asm_template;
	bool inside_asm;
	Array_string global_labels;
} ;

struct v__parser__ReceiverParsingInfo {
	string name;
	v__token__Position pos;
	v__ast__Type typ;
	v__token__Position type_pos;
	bool is_mut;
	v__ast__Language language;
} ;

struct v__vet__Error {
	v__vet__ErrorKind kind;
	string message;
	string details;
	string file_path;
	v__token__Position pos;
	v__vet__FixKind fix;
	v__vet__ErrorType typ;
} ;

struct v__gen__js__Namespace {
	string name;
	strings__Builder out;
	Array_string pub_vars;
	Map_string_string imports;
	int indent;
	Map_string_Array_v__ast__FnDecl methods;
} ;

struct v__pkgconfig__PkgConfig {
	v__pkgconfig__Options options;
	string name;
	string modname;
	string url;
	string version;
	string description;
	Array_string libs;
	Array_string libs_private;
	Array_string cflags;
	Array_string paths;
	Map_string_string vars;
	Array_string requires;
	Array_string requires_private;
	Array_string conflicts;
} ;

struct semver__Comparator {
	semver__Version ver;
	semver__Operator op;
} ;

struct SymbolInfoContainer {
	SymbolInfo syminfo;
	Array_fixed_char_254 f_name_rest;
} ;

struct v__ast__File {
	string path;
	string path_base;
	int lines;
	int bytes;
	v__ast__Module mod;
	v__ast__Scope* global_scope;
	v__ast__Scope* scope;
	Array_v__ast__Stmt stmts;
	Array_v__ast__Import imports;
	Array_string auto_imports;
	Array_v__ast__EmbeddedFile embedded_files;
	Map_string_string imported_symbols;
	Array_v__errors__Error errors;
	Array_v__errors__Warning warnings;
	Array_v__errors__Notice notices;
	Array_v__ast__FnDecl_ptr generic_fns;
	Array_string global_labels;
} ;

struct v__ast__FnDecl {
	string name;
	string mod;
	Array_v__ast__Param params;
	bool is_deprecated;
	bool is_pub;
	bool is_variadic;
	bool is_anon;
	bool is_manualfree;
	bool is_main;
	bool is_test;
	bool is_conditional;
	bool is_keep_alive;
	v__ast__StructField receiver;
	v__token__Position receiver_pos;
	bool is_method;
	v__token__Position method_type_pos;
	int method_idx;
	bool rec_mut;
	v__ast__ShareType rec_share;
	v__ast__Language language;
	bool no_body;
	bool is_builtin;
	v__token__Position body_pos;
	string file;
	Array_string generic_names;
	bool is_direct_arr;
	Array_v__ast__Attr attrs;
	bool skip_gen;
	Array_v__ast__Stmt stmts;
	Array_v__ast__DeferStmt defer_stmts;
	v__ast__Type return_type;
	v__token__Position return_type_pos;
	bool has_return;
	Array_v__ast__Comment comments;
	Array_v__ast__Comment next_comments;
	v__ast__File* source_file;
	v__ast__Scope* scope;
	Array_string label_names;
	v__token__Position pos;
} ;

struct v__ast__CallExpr {
	v__token__Position pos;
	v__token__Position name_pos;
	string mod;
	string name;
	bool is_method;
	bool is_field;
	bool is_keep_alive;
	Array_v__ast__CallArg args;
	Array_v__ast__Type expected_arg_types;
	v__ast__Language language;
	v__ast__OrExpr or_block;
	v__ast__Expr left;
	v__ast__Type left_type;
	v__ast__Type receiver_type;
	v__ast__Type return_type;
	bool should_be_skipped;
	Array_v__ast__Type generic_types;
	v__token__Position generic_list_pos;
	bool free_receiver;
	v__ast__Scope* scope;
	v__ast__Type from_embed_type;
	Array_v__ast__Comment comments;
} ;

struct v__ast__IndexExpr {
	v__token__Position pos;
	v__ast__Expr index;
	v__ast__OrExpr or_expr;
	v__ast__Expr left;
	v__ast__Type left_type;
	bool is_setter;
	bool is_map;
	bool is_array;
	bool is_farray;
	bool is_option;
} ;

struct v__ast__InfixExpr {
	v__token__Kind op;
	v__token__Position pos;
	bool is_stmt;
	v__ast__Expr left;
	v__ast__Expr right;
	v__ast__Type left_type;
	v__ast__Type right_type;
	string auto_locked;
	v__ast__OrExpr or_block;
} ;

struct v__ast__PrefixExpr {
	v__token__Kind op;
	v__token__Position pos;
	v__ast__Type right_type;
	v__ast__Expr right;
	v__ast__OrExpr or_block;
	bool is_option;
} ;

struct v__ast__SqlExpr {
	v__ast__Type typ;
	bool is_count;
	v__ast__Expr db_expr;
	bool has_where;
	bool has_offset;
	v__ast__Expr offset_expr;
	bool has_order;
	v__ast__Expr order_expr;
	bool has_desc;
	bool is_array;
	v__token__Position pos;
	bool has_limit;
	v__ast__Expr limit_expr;
	v__ast__Expr where_expr;
	v__ast__TypeNode table_expr;
	Array_v__ast__StructField fields;
	Map_int_v__ast__SqlExpr sub_structs;
} ;

struct v__ast__SqlStmt {
	v__ast__SqlStmtKind kind;
	v__ast__Expr db_expr;
	string object_var_name;
	v__token__Position pos;
	v__ast__Expr where_expr;
	Array_string updated_columns;
	Array_v__ast__Expr update_exprs;
	v__ast__TypeNode table_expr;
	Array_v__ast__StructField fields;
	Map_int_v__ast__SqlStmt sub_structs;
} ;

struct v__ast__SelectBranch {
	v__ast__Stmt stmt;
	Array_v__ast__Stmt stmts;
	v__token__Position pos;
	v__ast__Comment comment;
	bool is_else;
	bool is_timeout;
	Array_v__ast__Comment post_comments;
} ;

struct v__checker__Checker {
	v__pref__Preferences* pref;
	v__ast__Table* table;
	v__ast__File* file;
	int nr_errors;
	int nr_warnings;
	int nr_notices;
	Array_v__errors__Error errors;
	Array_v__errors__Warning warnings;
	Array_v__errors__Notice notices;
	Array_int error_lines;
	v__ast__Type expected_type;
	v__ast__Type expected_or_type;
	v__ast__FnDecl* cur_fn;
	string const_decl;
	Array_string const_deps;
	Array_string const_names;
	Array_string global_names;
	Array_string locked_names;
	Array_string rlocked_names;
	int in_for_count;
	bool returns;
	bool scope_returns;
	string mod;
	bool is_builtin_mod;
	bool inside_unsafe;
	bool inside_const;
	bool inside_anon_fn;
	bool inside_ref_lit;
	bool skip_flags;
	Array_v__ast__Type cur_generic_types;
	Array_v__ast__File files;
	int expr_level;
	bool inside_sql;
	v__ast__TypeSymbol cur_orm_ts;
	Array_string error_details;
	string vmod_file_content;
	Array_v__ast__Type vweb_gen_types;
	bool prevent_sum_type_unwrapping_once;
	string loop_label;
	v__util__Timers* timers;
	Map_string_v__ast__Type comptime_fields_type;
	v__ast__Scope* fn_scope;
	Map_string_bool used_fns;
	v__ast__FnDecl main_fn_decl_node;
	int match_exhaustive_cutoff_limit;
	bool using_new_err_struct;
	bool inside_selector_expr;
	bool inside_println_arg;
} ;

struct v__builder__FunctionRedefinition {
	string fpath;
	int fline;
	string fheader;
	v__ast__FnDecl f;
} ;

struct v__ast__AnonFn {
	v__ast__FnDecl decl;
	v__ast__Type typ;
	bool has_gen;
} ;

struct v__ast__ComptimeCall {
	v__token__Position pos;
	bool has_parens;
	string method_name;
	v__token__Position method_pos;
	v__ast__Scope* scope;
	v__ast__Expr left;
	string args_var;
	bool is_vweb;
	v__ast__File vweb_tmpl;
	bool is_embed;
	v__ast__EmbeddedFile embed_file;
	bool is_env;
	v__token__Position env_pos;
	v__ast__TypeSymbol sym;
	v__ast__Type result_type;
	string env_value;
	Array_v__ast__CallArg args;
} ;

struct v__ast__GoStmt {
	v__token__Position pos;
	v__ast__CallExpr call_expr;
} ;

struct v__gen__c__Gen {
	v__pref__Preferences* pref;
	string module_built;
	v__ast__Table* table;
	strings__Builder out;
	strings__Builder cheaders;
	strings__Builder includes;
	strings__Builder typedefs;
	strings__Builder typedefs2;
	strings__Builder type_definitions;
	strings__Builder definitions;
	Map_string_strings__Builder inits;
	Map_string_strings__Builder cleanups;
	strings__Builder gowrappers;
	strings__Builder stringliterals;
	strings__Builder auto_str_funcs;
	strings__Builder comptime_defines;
	strings__Builder pcs_declarations;
	strings__Builder hotcode_definitions;
	strings__Builder embedded_data;
	strings__Builder shared_types;
	strings__Builder shared_functions;
	strings__Builder channel_definitions;
	strings__Builder options_typedefs;
	strings__Builder options;
	strings__Builder json_forward_decls;
	strings__Builder enum_typedefs;
	strings__Builder sql_buf;
	v__ast__File file;
	v__ast__FnDecl* fn_decl;
	string last_fn_c_name;
	int tmp_count;
	int tmp_count2;
	bool is_c_call;
	bool is_assign_lhs;
	bool discard_or_result;
	bool is_void_expr_stmt;
	bool is_arraymap_set;
	bool is_amp;
	bool is_sql;
	bool is_shared;
	bool is_vlines_enabled;
	int arraymap_set_pos;
	string vlines_path;
	Array_string optionals;
	Array_string chan_pop_optionals;
	Array_string chan_push_optionals;
	Array_int shareds;
	int inside_ternary;
	bool inside_map_postfix;
	bool inside_map_infix;
	bool inside_map_index;
	bool inside_opt_data;
	bool inside_if_optional;
	Map_string_string ternary_names;
	Map_string_Array_string ternary_level_names;
	Array_int stmt_path_pos;
	bool skip_stmt_pos;
	bool right_is_opt;
	bool is_autofree;
	int indent;
	bool empty_line;
	bool is_test;
	v__token__Kind assign_op;
	Array_v__ast__DeferStmt defer_stmts;
	string defer_ifdef;
	string defer_profile_code;
	Array_string str_types;
	Array_string threaded_fns;
	Array_string waiter_fns;
	Array_string array_fn_definitions;
	Array_string map_fn_definitions;
	Array_string struct_fn_definitions;
	Array_string sumtype_fn_definitions;
	Array_string alias_fn_definitions;
	Array_string auto_fn_definitions;
	Array_string anon_fn_definitions;
	Map_int_bool sumtype_definitions;
	bool is_json_fn;
	Array_string json_types;
	Array_v__gen__c__ProfileCounterMeta pcs;
	bool is_builtin_mod;
	Array_string hotcode_fn_names;
	Array_v__ast__EmbeddedFile embedded_files;
	v__ast__FnDecl cur_fn;
	Array_v__ast__Type cur_generic_types;
	int sql_i;
	string sql_stmt_name;
	string sql_bind_name;
	Array_string sql_idents;
	Array_v__ast__Type sql_idents_types;
	v__ast__Type sql_left_type;
	string sql_table_name;
	v__gen__c__SqlExprSide sql_side;
	bool inside_vweb_tmpl;
	bool inside_return;
	bool inside_or_block;
	Array_string strs_to_free0;
	bool inside_call;
	bool has_main;
	bool inside_const;
	string comp_for_method;
	string comp_for_field_var;
	v__ast__StructField comp_for_field_value;
	v__ast__Type comp_for_field_type;
	Map_string_v__ast__Type comptime_var_type_map;
	string called_fn_name;
	v__ast__Module cur_mod;
	bool is_js_call;
	bool is_fn_index_call;
	bool inside_lambda;
	bool prevent_sum_type_unwrapping_once;
	int aggregate_type_idx;
	string returned_var_name;
	int branch_parent_pos;
	v__util__Timers* timers;
	bool force_main_console;
	Map_string_string as_cast_type_names;
	Map_string_string obf_table;
} ;

struct v__gen__js__JsGen {
	v__ast__Table* table;
	v__pref__Preferences* pref;
	strings__Builder definitions;
	v__gen__js__Namespace* ns;
	Map_string_v__gen__js__Namespace_ptr namespaces;
	v__gen__js__JsDoc* doc;
	bool enable_doc;
	v__ast__File file;
	int tmp_count;
	bool inside_ternary;
	bool inside_loop;
	bool inside_map_set;
	bool inside_builtin;
	bool generated_builtin;
	bool inside_def_typ_decl;
	bool is_test;
	int stmt_start_pos;
	Array_v__ast__DeferStmt defer_stmts;
	v__ast__FnDecl* fn_decl;
	Array_string str_types;
	Map_string_Array_v__ast__FnDecl method_fn_decls;
	Array_string builtin_fns;
	bool empty_line;
	Array_v__ast__Type cast_stack;
	Array_v__ast__CallExpr call_stack;
} ;

struct v__builder__Builder {
	string compiled_dir;
	string module_path;
	v__pref__Preferences* pref;
	v__checker__Checker checker;
	v__ast__Scope* global_scope;
	string out_name_c;
	string out_name_js;
	int max_nr_errors;
	int stats_lines;
	int stats_bytes;
	Array_string module_search_paths;
	Array_v__ast__File parsed_files;
	v__builder__MsvcResult cached_msvc;
	v__ast__Table* table;
	v__builder__CcompilerOptions ccoptions;
} ;

struct v__ast__GoExpr {
	v__token__Position pos;
	v__ast__GoStmt go_stmt;
	v__ast__Type return_type;
} ;


// BEGIN_multi_return_structs
struct multi_return_u32_u32 {
	u32 arg0;
	u32 arg1;
};

struct multi_return_u32_u32_u32 {
	u32 arg0;
	u32 arg1;
	u32 arg2;
};

struct multi_return_int_strconv__PrepNumber {
	int arg0;
	strconv__PrepNumber arg1;
};

struct multi_return_u64_int {
	u64 arg0;
	int arg1;
};

struct multi_return_strconv__Dec32_bool {
	strconv__Dec32 arg0;
	bool arg1;
};

struct multi_return_strconv__Dec64_bool {
	strconv__Dec64 arg0;
	bool arg1;
};

struct multi_return_string_int {
	string arg0;
	int arg1;
};

struct multi_return_int_bool {
	int arg0;
	bool arg1;
};

struct multi_return_v__pref__Preferences_string {
	v__pref__Preferences* arg0;
	string arg1;
};

struct multi_return_string_string {
	string arg0;
	string arg1;
};

struct multi_return_u64_u64 {
	u64 arg0;
	u64 arg1;
};

struct multi_return_int_int_int {
	int arg0;
	int arg1;
	int arg2;
};

struct multi_return_int_int_int_int_i64_bool {
	int arg0;
	int arg1;
	int arg2;
	int arg3;
	i64 arg4;
	bool arg5;
};

struct multi_return_int_int {
	int arg0;
	int arg1;
};

struct multi_return_Array_string_int {
	Array_string arg0;
	int arg1;
};

struct multi_return_Array_string_v__vmod__ModFileAndFolder {
	Array_string arg0;
	v__vmod__ModFileAndFolder arg1;
};

struct multi_return_bool_string {
	bool arg0;
	string arg1;
};

struct multi_return_v__ast__ScopeObject_v__ast__Scope {
	v__ast__ScopeObject arg0;
	v__ast__Scope* arg1;
};

struct multi_return_string_bool {
	string arg0;
	bool arg1;
};

struct multi_return_bool_bool_int {
	bool arg0;
	bool arg1;
	int arg2;
};

struct multi_return_string_v__token__Position {
	string arg0;
	v__token__Position arg1;
};

struct multi_return_bool_int_int {
	bool arg0;
	int arg1;
	int arg2;
};

struct multi_return_Array_v__ast__Param_bool_bool {
	Array_v__ast__Param arg0;
	bool arg1;
	bool arg2;
};

struct multi_return_v__ast__File_Array_v__vet__Error {
	v__ast__File arg0;
	Array_v__vet__Error arg1;
};

struct multi_return_Array_v__ast__Expr_Array_v__ast__Comment {
	Array_v__ast__Expr arg0;
	Array_v__ast__Comment arg1;
};

struct multi_return_string_string_string_string {
	string arg0;
	string arg1;
	string arg2;
	string arg3;
};

struct multi_return_int_string_string_string {
	int arg0;
	string arg1;
	string arg2;
	string arg3;
};

struct multi_return_Array_string_Array_string {
	Array_string arg0;
	Array_string arg1;
};

struct multi_return_Map_string_v__ast__FnDecl_Map_string_v__ast__ConstField {
	Map_string_v__ast__FnDecl arg0;
	Map_string_v__ast__ConstField arg1;
};

struct multi_return_Array_string_Array_string_Array_string {
	Array_string arg0;
	Array_string arg1;
	Array_string arg2;
};

// END_multi_return_structs

static bool Array_string_contains(Array_string a, string v); // auto
static string time__FormatTime_str(time__FormatTime it); // auto
static string time__FormatDate_str(time__FormatDate it); // auto
static bool Array_v__token__Kind_contains(Array_v__token__Kind a, v__token__Kind v); // auto
static string v__pref__Backend_str(v__pref__Backend it); // auto
static bool v__ast__Type_alias_eq(v__ast__Type a, v__ast__Type b); // auto
static string Array_v__ast__Expr_str(Array_v__ast__Expr a); // auto
static string indent_Array_v__ast__Expr_str(Array_v__ast__Expr a, int indent_count); // auto
static bool Array_string_arr_eq(Array_string a, Array_string b); // auto
static bool Array_Array_v__ast__Type_contains(Array_Array_v__ast__Type a, Array_v__ast__Type v); // auto
static bool Array_v__ast__Type_arr_eq(Array_v__ast__Type a, Array_v__ast__Type b); // auto
static bool Array_v__ast__Type_contains(Array_v__ast__Type a, v__ast__Type v); // auto
static int Array_v__ast__Type_index(Array_v__ast__Type a, v__ast__Type v); // auto
static string v__ast__Comment_str(v__ast__Comment it); // auto
static string indent_v__ast__Comment_str(v__ast__Comment it, int indent_count); // auto
static string Array_v__ast__Comment_str(Array_v__ast__Comment a); // auto
static string indent_Array_v__ast__Comment_str(Array_v__ast__Comment a, int indent_count); // auto
static string Array_v__ast__Attr_str(Array_v__ast__Attr a); // auto
static string indent_Array_v__ast__Attr_str(Array_v__ast__Attr a, int indent_count); // auto
static string v__ast__Type_str(v__ast__Type it); // auto
static string indent_v__ast__Type_str(v__ast__Type it, int indent_count); // auto
static string v__ast__StructField_str(v__ast__StructField it); // auto
static string indent_v__ast__StructField_str(v__ast__StructField it, int indent_count); // auto
static string Array_v__ast__StructField_str(Array_v__ast__StructField a); // auto
static string indent_Array_v__ast__StructField_str(Array_v__ast__StructField a, int indent_count); // auto
static string Array_v__ast__Type_str(Array_v__ast__Type a); // auto
static string indent_Array_v__ast__Type_str(Array_v__ast__Type a, int indent_count); // auto
static string v__ast__Aggregate_str(v__ast__Aggregate it); // auto
static string indent_v__ast__Aggregate_str(v__ast__Aggregate it, int indent_count); // auto
static string v__ast__Language_str(v__ast__Language it); // auto
static string v__ast__Alias_str(v__ast__Alias it); // auto
static string indent_v__ast__Alias_str(v__ast__Alias it, int indent_count); // auto
static string v__ast__Array_str(v__ast__Array it); // auto
static string indent_v__ast__Array_str(v__ast__Array it, int indent_count); // auto
static string v__ast__ArrayFixed_str(v__ast__ArrayFixed it); // auto
static string indent_v__ast__ArrayFixed_str(v__ast__ArrayFixed it, int indent_count); // auto
static string v__ast__Chan_str(v__ast__Chan it); // auto
static string indent_v__ast__Chan_str(v__ast__Chan it, int indent_count); // auto
static string v__ast__Enum_str(v__ast__Enum it); // auto
static string indent_v__ast__Enum_str(v__ast__Enum it, int indent_count); // auto
static string v__ast__Param_str(v__ast__Param it); // auto
static string indent_v__ast__Param_str(v__ast__Param it, int indent_count); // auto
static string Array_v__ast__Param_str(Array_v__ast__Param a); // auto
static string indent_Array_v__ast__Param_str(Array_v__ast__Param a, int indent_count); // auto
static string v__ast__Fn_str(v__ast__Fn it); // auto
static string indent_v__ast__Fn_str(v__ast__Fn it, int indent_count); // auto
static string v__ast__FnType_str(v__ast__FnType it); // auto
static string indent_v__ast__FnType_str(v__ast__FnType it, int indent_count); // auto
static string v__ast__GenericStructInst_str(v__ast__GenericStructInst it); // auto
static string indent_v__ast__GenericStructInst_str(v__ast__GenericStructInst it, int indent_count); // auto
static string Array_v__ast__Fn_str(Array_v__ast__Fn a); // auto
static string indent_Array_v__ast__Fn_str(Array_v__ast__Fn a, int indent_count); // auto
static string v__ast__Interface_str(v__ast__Interface it); // auto
static string indent_v__ast__Interface_str(v__ast__Interface it, int indent_count); // auto
static string v__ast__Map_str(v__ast__Map it); // auto
static string indent_v__ast__Map_str(v__ast__Map it, int indent_count); // auto
static string v__ast__MultiReturn_str(v__ast__MultiReturn it); // auto
static string indent_v__ast__MultiReturn_str(v__ast__MultiReturn it, int indent_count); // auto
static string v__ast__Struct_str(v__ast__Struct it); // auto
static string indent_v__ast__Struct_str(v__ast__Struct it, int indent_count); // auto
static string v__ast__SumType_str(v__ast__SumType it); // auto
static string indent_v__ast__SumType_str(v__ast__SumType it, int indent_count); // auto
static string v__ast__Thread_str(v__ast__Thread it); // auto
static string indent_v__ast__Thread_str(v__ast__Thread it, int indent_count); // auto
static string v__ast__TypeInfo_str(v__ast__TypeInfo x); // auto
static string indent_v__ast__TypeInfo_str(v__ast__TypeInfo x, int indent_count); // auto
static bool Array_int_contains(Array_int a, int v); // auto
static bool time__Time_struct_eq(time__Time a, time__Time b); // auto
static bool Array_i64_contains(Array_i64 a, i64 v); // auto
static string v__ast__IdentKind_str(v__ast__IdentKind it); // auto
static bool Array_v__ast__EmbeddedFile_contains(Array_v__ast__EmbeddedFile a, v__ast__EmbeddedFile v); // auto
static bool v__ast__EmbeddedFile_struct_eq(v__ast__EmbeddedFile a, v__ast__EmbeddedFile b); // auto
static string v__ast__TypeNode_str(v__ast__TypeNode it); // auto
static string indent_v__ast__TypeNode_str(v__ast__TypeNode it, int indent_count); // auto
static string v__gen__c__SqlType_str(v__gen__c__SqlType it); // auto
static bool Array_v__ast__Kind_contains(Array_v__ast__Kind a, v__ast__Kind v); // auto
static bool v__ast__IntegerLiteral_struct_eq(v__ast__IntegerLiteral a, v__ast__IntegerLiteral b); // auto
static bool v__token__Position_struct_eq(v__token__Position a, v__token__Position b); // auto
static bool v__ast__FloatLiteral_struct_eq(v__ast__FloatLiteral a, v__ast__FloatLiteral b); // auto
static string v__gen__x64__Register_str(v__gen__x64__Register it); // auto
static string v__errors__Reporter_str(v__errors__Reporter it); // auto
static string Array_v__cflag__CFlag_str(Array_v__cflag__CFlag a); // auto
static string indent_Array_v__cflag__CFlag_str(Array_v__cflag__CFlag a, int indent_count); // auto

// V shared types:

// V Option_xxx definitions:
struct Option_int {
	byte state;
	IError err;
	byte data[sizeof(int)];
};

struct Option_os__File {
	byte state;
	IError err;
	byte data[sizeof(os__File)];
};

struct Option_FILE_ptr {
	byte state;
	IError err;
	byte data[sizeof(FILE*)];
};

struct Option_void {
	byte state;
	IError err;
	byte data[sizeof(byte)];
};

struct Option_bool {
	byte state;
	IError err;
	byte data[sizeof(bool)];
};

struct Option_Array_string {
	byte state;
	IError err;
	byte data[sizeof(Array_string)];
};

struct Option_string {
	byte state;
	IError err;
	byte data[sizeof(string)];
};

struct Option_Array_ustring {
	byte state;
	IError err;
	byte data[sizeof(Array_ustring)];
};

struct Option_os__Result {
	byte state;
	IError err;
	byte data[sizeof(os__Result)];
};

struct Option_Array_byte {
	byte state;
	IError err;
	byte data[sizeof(Array_byte)];
};

struct Option_time__Time {
	byte state;
	IError err;
	byte data[sizeof(time__Time)];
};

struct Option_multi_return_int_int_int {
	byte state;
	IError err;
	byte data[sizeof(multi_return_int_int_int)];
};

struct Option_multi_return_int_int_int_int_i64_bool {
	byte state;
	IError err;
	byte data[sizeof(multi_return_int_int_int_int_i64_bool)];
};

struct Option_f64 {
	byte state;
	IError err;
	byte data[sizeof(f64)];
};

struct Option_semver__Range {
	byte state;
	IError err;
	byte data[sizeof(semver__Range)];
};

struct Option_semver__Version {
	byte state;
	IError err;
	byte data[sizeof(semver__Version)];
};

struct Option_semver__ComparatorSet {
	byte state;
	IError err;
	byte data[sizeof(semver__ComparatorSet)];
};

struct Option_semver__Comparator {
	byte state;
	IError err;
	byte data[sizeof(semver__Comparator)];
};

struct Option_v__vmod__Manifest {
	byte state;
	IError err;
	byte data[sizeof(v__vmod__Manifest)];
};

struct Option_multi_return_Array_string_int {
	byte state;
	IError err;
	byte data[sizeof(multi_return_Array_string_int)];
};

struct Option_v__pkgconfig__PkgConfig_ptr {
	byte state;
	IError err;
	byte data[sizeof(v__pkgconfig__PkgConfig*)];
};

struct Option_v__pkgconfig__Main_ptr {
	byte state;
	IError err;
	byte data[sizeof(v__pkgconfig__Main*)];
};

struct Option_v__pref__OS {
	byte state;
	IError err;
	byte data[sizeof(v__pref__OS)];
};

struct Option_v__pref__Arch {
	byte state;
	IError err;
	byte data[sizeof(v__pref__Arch)];
};

struct Option_v__pref__Backend {
	byte state;
	IError err;
	byte data[sizeof(v__pref__Backend)];
};

struct Option_time__StopWatch {
	byte state;
	IError err;
	byte data[sizeof(time__StopWatch)];
};

struct Option_v__ast__Ident {
	byte state;
	IError err;
	byte data[sizeof(v__ast__Ident)];
};

struct Option_multi_return_v__ast__ScopeObject_v__ast__Scope {
	byte state;
	IError err;
	byte data[sizeof(multi_return_v__ast__ScopeObject_v__ast__Scope)];
};

struct Option_v__ast__ScopeObject {
	byte state;
	IError err;
	byte data[sizeof(v__ast__ScopeObject)];
};

struct Option_v__ast__ScopeStructField {
	byte state;
	IError err;
	byte data[sizeof(v__ast__ScopeStructField)];
};

struct Option_v__ast__Var_ptr {
	byte state;
	IError err;
	byte data[sizeof(v__ast__Var*)];
};

struct Option_v__ast__ConstField_ptr {
	byte state;
	IError err;
	byte data[sizeof(v__ast__ConstField*)];
};

struct Option_v__ast__Fn {
	byte state;
	IError err;
	byte data[sizeof(v__ast__Fn)];
};

struct Option_v__ast__StructField {
	byte state;
	IError err;
	byte data[sizeof(v__ast__StructField)];
};

struct Option_v__ast__TypeSymbol {
	byte state;
	IError err;
	byte data[sizeof(v__ast__TypeSymbol)];
};

struct Option_v__ast__Type {
	byte state;
	IError err;
	byte data[sizeof(v__ast__Type)];
};

struct Option_v__ast__Expr {
	byte state;
	IError err;
	byte data[sizeof(v__ast__Expr)];
};

struct Option_v__ast__ConstField {
	byte state;
	IError err;
	byte data[sizeof(v__ast__ConstField)];
};

struct Option_v__ast__FnDecl {
	byte state;
	IError err;
	byte data[sizeof(v__ast__FnDecl)];
};

struct Option_v__builder__MsvcResult {
	byte state;
	IError err;
	byte data[sizeof(v__builder__MsvcResult)];
};

struct Option_v__builder__WindowsKit {
	byte state;
	IError err;
	byte data[sizeof(v__builder__WindowsKit)];
};

struct Option_v__builder__VsInstallation {
	byte state;
	IError err;
	byte data[sizeof(v__builder__VsInstallation)];
};


// V json forward decls:

// V definitions:
void _STR_PRINT_ARG(const char*, char**, int*, int*, int, ...);
string _STR(const char*, int, ...);
string _STR_TMP(const char*, ...);
// end of definitions #endif
strings__Builder strings__new_builder(int initial_size);
void strings__Builder_write_bytes(strings__Builder* b, byte* bytes, int len);
void strings__Builder_write_ptr(strings__Builder* b, byte* ptr, int len);
void strings__Builder_write_b(strings__Builder* b, byte data);
Option_int strings__Builder_write(strings__Builder* b, Array_byte data);
void strings__Builder_write_string(strings__Builder* b, string s);
void strings__Builder_go_back(strings__Builder* b, int n);
VV_LOCAL_SYMBOL string strings__bytes2string(Array_byte b);
string strings__Builder_cut_last(strings__Builder* b, int n);
void strings__Builder_go_back_to(strings__Builder* b, int pos);
void strings__Builder_writeln(strings__Builder* b, string s);
string strings__Builder_last_n(strings__Builder* b, int n);
string strings__Builder_after(strings__Builder* b, int n);
string strings__Builder_str(strings__Builder* b);
void strings__Builder_free(strings__Builder* b);
int strings__levenshtein_distance(string a, string b);
f32 strings__levenshtein_distance_percentage(string a, string b);
f32 strings__dice_coefficient(string s1, string s2);
string strings__repeat(byte c, int n);
string strings__repeat_string(string s, int n);
u64 hash__wyhash_c(byteptr key, u64 len, u64 seed);
u64 hash__wyhash64_c(u64 a, u64 b);
u64 _const_hash__wyp0; // inited later
u64 _const_hash__wyp1; // inited later
u64 _const_hash__wyp2; // inited later
u64 _const_hash__wyp3; // inited later
u64 _const_hash__wyp4; // inited later
u64 hash__sum64_string(string key, u64 seed);
u64 hash__sum64(Array_byte key, u64 seed);
VV_LOCAL_SYMBOL u64 hash__wyhash64(byteptr key, u64 len, u64 seed_);
VV_LOCAL_SYMBOL u64 hash__wyrotr(u64 v, u32 k);
u64 hash__wymum(u64 a, u64 b);
VV_LOCAL_SYMBOL u64 hash__wyr3(byteptr p, u64 k);
VV_LOCAL_SYMBOL u64 hash__wyr4(byteptr p);
VV_LOCAL_SYMBOL u64 hash__wyr8(byteptr p);
u32 _const_math__bits__de_bruijn32; // inited later
Array_byte _const_math__bits__de_bruijn32tab; // inited later
u64 _const_math__bits__de_bruijn64; // inited later
Array_byte _const_math__bits__de_bruijn64tab; // inited later
u64 _const_math__bits__m0; // inited later
u64 _const_math__bits__m1; // inited later
u64 _const_math__bits__m2; // inited later
u64 _const_math__bits__m3; // inited later
u64 _const_math__bits__m4; // inited later
u32 _const_math__bits__max_u32; // inited later
u64 _const_math__bits__max_u64; // inited later
int math__bits__leading_zeros_8(byte x);
int math__bits__leading_zeros_16(u16 x);
int math__bits__leading_zeros_32(u32 x);
int math__bits__leading_zeros_64(u64 x);
int math__bits__trailing_zeros_8(byte x);
int math__bits__trailing_zeros_16(u16 x);
int math__bits__trailing_zeros_32(u32 x);
int math__bits__trailing_zeros_64(u64 x);
int math__bits__ones_count_8(byte x);
int math__bits__ones_count_16(u16 x);
int math__bits__ones_count_32(u32 x);
int math__bits__ones_count_64(u64 x);
byte math__bits__rotate_left_8(byte x, int k);
u16 math__bits__rotate_left_16(u16 x, int k);
u32 math__bits__rotate_left_32(u32 x, int k);
u64 math__bits__rotate_left_64(u64 x, int k);
byte math__bits__reverse_8(byte x);
u16 math__bits__reverse_16(u16 x);
u32 math__bits__reverse_32(u32 x);
u64 math__bits__reverse_64(u64 x);
u16 math__bits__reverse_bytes_16(u16 x);
u32 math__bits__reverse_bytes_32(u32 x);
u64 math__bits__reverse_bytes_64(u64 x);
int math__bits__len_8(byte x);
int math__bits__len_16(u16 x);
int math__bits__len_32(u32 x);
int math__bits__len_64(u64 x);
multi_return_u32_u32 math__bits__add_32(u32 x, u32 y, u32 carry);
multi_return_u64_u64 math__bits__add_64(u64 x, u64 y, u64 carry);
multi_return_u32_u32 math__bits__sub_32(u32 x, u32 y, u32 borrow);
multi_return_u64_u64 math__bits__sub_64(u64 x, u64 y, u64 borrow);
u64 _const_math__bits__two32; // inited later
u64 _const_math__bits__mask32; // inited later
string _const_math__bits__overflow_error; // a string literal, inited later
string _const_math__bits__divide_error; // a string literal, inited later
multi_return_u32_u32 math__bits__mul_32(u32 x, u32 y);
multi_return_u64_u64 math__bits__mul_64(u64 x, u64 y);
multi_return_u32_u32 math__bits__div_32(u32 hi, u32 lo, u32 y);
multi_return_u64_u64 math__bits__div_64(u64 hi, u64 lo, u64 y1);
u32 math__bits__rem_32(u32 hi, u32 lo, u32 y);
u64 math__bits__rem_64(u64 hi, u64 lo, u64 y);
Array_byte _const_math__bits__ntz_8_tab; // inited later
Array_byte _const_math__bits__pop_8_tab; // inited later
Array_byte _const_math__bits__rev_8_tab; // inited later
Array_byte _const_math__bits__len_8_tab; // inited later
VV_LOCAL_SYMBOL multi_return_u32_u32_u32 strconv__lsr96(u32 s2, u32 s1, u32 s0);
VV_LOCAL_SYMBOL multi_return_u32_u32_u32 strconv__lsl96(u32 s2, u32 s1, u32 s0);
VV_LOCAL_SYMBOL multi_return_u32_u32_u32 strconv__add96(u32 s2, u32 s1, u32 s0, u32 d2, u32 d1, u32 d0);
VV_LOCAL_SYMBOL multi_return_u32_u32_u32 strconv__sub96(u32 s2, u32 s1, u32 s0, u32 d2, u32 d1, u32 d0);
#define _const_strconv__digits 18
u64 _const_strconv__double_plus_zero; // inited later
u64 _const_strconv__double_minus_zero; // inited later
u64 _const_strconv__double_plus_infinity; // inited later
u64 _const_strconv__double_minus_infinity; // inited later
#define _const_strconv__fsm_a 0
#define _const_strconv__fsm_b 1
#define _const_strconv__fsm_c 2
#define _const_strconv__fsm_d 3
#define _const_strconv__fsm_e 4
#define _const_strconv__fsm_f 5
#define _const_strconv__fsm_g 6
#define _const_strconv__fsm_h 7
#define _const_strconv__fsm_i 8
#define _const_strconv__fsm_stop 9
#define _const_strconv__parser_ok 0
#define _const_strconv__parser_pzero 1
#define _const_strconv__parser_mzero 2
#define _const_strconv__parser_pinf 3
#define _const_strconv__parser_minf 4
#define _const_strconv__c_dpoint L'.'
#define _const_strconv__c_plus L'+'
#define _const_strconv__c_minus L'-'
#define _const_strconv__c_zero L'0'
#define _const_strconv__c_nine L'9'
u32 _const_strconv__c_ten; // inited later
VV_LOCAL_SYMBOL bool strconv__is_digit(byte x);
VV_LOCAL_SYMBOL bool strconv__is_space(byte x);
VV_LOCAL_SYMBOL bool strconv__is_exp(byte x);
VV_LOCAL_SYMBOL multi_return_int_strconv__PrepNumber strconv__parser(string s);
VV_LOCAL_SYMBOL u64 strconv__converter(strconv__PrepNumber* pn);
f64 strconv__atof64(string s);
f64 strconv__atof_quick(string s);
Array_u64 _const_strconv__pos_exp; // inited later
Array_u64 _const_strconv__neg_exp; // inited later
#define _const_strconv__int_size 32
u64 _const_strconv__max_u64; // inited later
byte strconv__byte_to_lower(byte c);
u64 strconv__common_parse_uint(string s, int _base, int _bit_size, bool error_on_non_digit, bool error_on_high_digit);
multi_return_u64_int strconv__common_parse_uint2(string s, int _base, int _bit_size);
u64 strconv__parse_uint(string s, int _base, int _bit_size);
i64 strconv__common_parse_int(string _s, int base, int _bit_size, bool error_on_non_digit, bool error_on_high_digit);
i64 strconv__parse_int(string _s, int base, int _bit_size);
Option_int strconv__atoi(string s);
VV_LOCAL_SYMBOL bool strconv__underscore_ok(string s);
Array_u32 _const_strconv__ten_pow_table_32; // inited later
u32 _const_strconv__mantbits32; // inited later
u32 _const_strconv__expbits32; // inited later
#define _const_strconv__bias32 127
#define _const_strconv__maxexp32 255
string strconv__Dec32_get_string_32(strconv__Dec32 d, bool neg, int i_n_digit, int i_pad_digit);
VV_LOCAL_SYMBOL multi_return_strconv__Dec32_bool strconv__f32_to_decimal_exact_int(u32 i_mant, u32 exp);
strconv__Dec32 strconv__f32_to_decimal(u32 mant, u32 exp);
string strconv__f32_to_str(f32 f, int n_digit);
string strconv__f32_to_str_pad(f32 f, int n_digit);
Array_u64 _const_strconv__ten_pow_table_64; // inited later
u32 _const_strconv__mantbits64; // inited later
u32 _const_strconv__expbits64; // inited later
#define _const_strconv__bias64 1023
#define _const_strconv__maxexp64 2047
VV_LOCAL_SYMBOL string strconv__Dec64_get_string_64(strconv__Dec64 d, bool neg, int i_n_digit, int i_pad_digit);
VV_LOCAL_SYMBOL multi_return_strconv__Dec64_bool strconv__f64_to_decimal_exact_int(u64 i_mant, u64 exp);
VV_LOCAL_SYMBOL strconv__Dec64 strconv__f64_to_decimal(u64 mant, u64 exp);
string strconv__f64_to_str(f64 f, int n_digit);
string strconv__f64_to_str_pad(f64 f, int n_digit);
Array_f64 _const_strconv__dec_round; // inited later
string strconv__f64_to_str_lnd(f64 f, int dec_digit);
string strconv__format_str(string s, strconv__BF_param p);
string strconv__format_dec(u64 d, strconv__BF_param p);
string strconv__format_fl(f64 f, strconv__BF_param p);
string strconv__format_es(f64 f, strconv__BF_param p);
string strconv__remove_tail_zeros(string s);
void strconv__v_printf(string str, Array_voidptr pt);
string strconv__v_sprintf(string str, Array_voidptr pt);
VV_LOCAL_SYMBOL void strconv__v_sprintf_panic(int idx, int len);
VV_LOCAL_SYMBOL f64 strconv__fabs(f64 x);
string strconv__ftoa_64(f64 f);
string strconv__ftoa_long_64(f64 f);
string strconv__ftoa_32(f32 f);
string strconv__ftoa_long_32(f32 f);
string _const_strconv__base_digits; // a string literal, inited later
string strconv__format_int(i64 n, int radix);
string strconv__format_uint(u64 n, int radix);
#define _const_strconv__pow5_num_bits_32 61
#define _const_strconv__pow5_inv_num_bits_32 59
#define _const_strconv__pow5_num_bits_64 121
#define _const_strconv__pow5_inv_num_bits_64 122
Array_u64 _const_strconv__powers_of_10; // inited later
Array_u64 _const_strconv__pow5_split_32; // inited later
Array_u64 _const_strconv__pow5_inv_split_32; // inited later
Array_strconv__Uint128 _const_strconv__pow5_split_64; // inited later
Array_strconv__Uint128 _const_strconv__pow5_inv_split_64; // inited later
VV_LOCAL_SYMBOL void strconv__assert1(bool t, string msg);
VV_LOCAL_SYMBOL int strconv__bool_to_int(bool b);
VV_LOCAL_SYMBOL u32 strconv__bool_to_u32(bool b);
VV_LOCAL_SYMBOL u64 strconv__bool_to_u64(bool b);
VV_LOCAL_SYMBOL string strconv__get_string_special(bool neg, bool expZero, bool mantZero);
VV_LOCAL_SYMBOL int strconv__decimal_len_32(u32 u);
VV_LOCAL_SYMBOL u32 strconv__mul_shift_32(u32 m, u64 mul, int ishift);
VV_LOCAL_SYMBOL u32 strconv__mul_pow5_invdiv_pow2(u32 m, u32 q, int j);
VV_LOCAL_SYMBOL u32 strconv__mul_pow5_div_pow2(u32 m, u32 i, int j);
VV_LOCAL_SYMBOL u32 strconv__pow5_factor_32(u32 i_v);
VV_LOCAL_SYMBOL bool strconv__multiple_of_power_of_five_32(u32 v, u32 p);
VV_LOCAL_SYMBOL bool strconv__multiple_of_power_of_two_32(u32 v, u32 p);
VV_LOCAL_SYMBOL u32 strconv__log10_pow2(int e);
VV_LOCAL_SYMBOL u32 strconv__log10_pow5(int e);
VV_LOCAL_SYMBOL int strconv__pow5_bits(int e);
VV_LOCAL_SYMBOL int strconv__decimal_len_64(u64 u);
VV_LOCAL_SYMBOL u64 strconv__shift_right_128(strconv__Uint128 v, int shift);
VV_LOCAL_SYMBOL u64 strconv__mul_shift_64(u64 m, strconv__Uint128 mul, int shift);
VV_LOCAL_SYMBOL u32 strconv__pow5_factor_64(u64 v_i);
VV_LOCAL_SYMBOL bool strconv__multiple_of_power_of_five_64(u64 v, u32 p);
VV_LOCAL_SYMBOL bool strconv__multiple_of_power_of_two_64(u64 v, u32 p);
string strconv__f32_to_str_l(f64 f);
string strconv__f64_to_str_l(f64 f);
VV_LOCAL_SYMBOL array __new_array(int mylen, int cap, int elm_size);
VV_LOCAL_SYMBOL array __new_array_with_default(int mylen, int cap, int elm_size, voidptr val);
VV_LOCAL_SYMBOL array __new_array_with_array_default(int mylen, int cap, int elm_size, array val);
VV_LOCAL_SYMBOL array new_array_from_c_array(int len, int cap, int elm_size, voidptr c_array);
VV_LOCAL_SYMBOL array new_array_from_c_array_no_alloc(int len, int cap, int elm_size, voidptr c_array);
VV_LOCAL_SYMBOL void array_ensure_cap(array* a, int required);
array array_repeat(array a, int count);
void array_sort_with_compare(array* a, voidptr compare);
void array_insert(array* a, int i, voidptr val);
void array_insert_many(array* a, int i, voidptr val, int size);
void array_prepend(array* a, voidptr val);
void array_prepend_many(array* a, voidptr val, int size);
void array_delete(array* a, int i);
void array_clear(array* a);
void array_trim(array* a, int index);
VV_LOCAL_SYMBOL voidptr array_get_unsafe(array a, int i);
VV_LOCAL_SYMBOL voidptr array_get(array a, int i);
VV_LOCAL_SYMBOL voidptr array_get_with_check(array a, int i);
voidptr array_first(array a);
voidptr array_last(array a);
voidptr array_pop(array* a);
void array_delete_last(array* a);
VV_LOCAL_SYMBOL array array_slice(array a, int start, int _end);
VV_LOCAL_SYMBOL array array_slice2(array a, int start, int _end, bool end_max);
VV_LOCAL_SYMBOL array array_clone_static(array a);
array array_clone(array* a);
VV_LOCAL_SYMBOL array array_slice_clone(array* a, int start, int _end);
VV_LOCAL_SYMBOL void array_set_unsafe(array* a, int i, voidptr val);
VV_LOCAL_SYMBOL void array_set(array* a, int i, voidptr val);
VV_LOCAL_SYMBOL void array_push(array* a, voidptr val);
void array_push_many(array* a3, voidptr val, int size);
void array_reverse_in_place(array* a);
array array_reverse(array a);
void array_free(array* a);
void Array_string_free(Array_string* a);
string Array_string_str(Array_string a);
string Array_byte_hex(Array_byte b);
int copy(Array_byte dst, Array_byte src);
VV_LOCAL_SYMBOL int compare_ints(int* a, int* b);
VV_LOCAL_SYMBOL int compare_ints_reverse(int* a, int* b);
void Array_int_sort(Array_int* a);
int Array_string_index(Array_string a, string v);
int Array_int_reduce(Array_int a, int (*iter)(int , int ), int accum_start);
void array_grow_cap(array* a, int amount);
void array_grow_len(array* a, int amount);
bool Array_string_eq(Array_string a1, Array_string a2);
Array_voidptr array_pointers(array a);
Array_byte voidptr_vbytes(voidptr data, int len);
Array_byte byte_vbytes(byte* data, int len);
void v_exit(int code);
VV_LOCAL_SYMBOL void panic_debug(int line_no, string file, string mod, string fn_name, string s);
void panic_optional_not_set(string s);
void v_panic(string s);
void eprintln(string s);
void eprint(string s);
void print(string s);
void println(string s);
byte* v_malloc(int n);
byte* v_realloc(byte* b, int n);
byte* realloc_data(byte* old_data, int old_size, int new_size);
byte* vcalloc(int n);
void v_free(voidptr ptr);
voidptr memdup(voidptr src, int sz);
int is_atty(int fd);
VV_LOCAL_SYMBOL int v_fixed_index(int i, int len);
byte* g_m2_buf; // global
byte* g_m2_ptr; // global
bool isnil(voidptr v);
void print_backtrace();
i64 total_m = 0; // global
int nr_mallocs = 0; // global
Array_VCastTypeIndexName as_cast_type_indexes; // global
VV_LOCAL_SYMBOL voidptr __as_cast(voidptr obj, int obj_type, int expected_type);
VV_LOCAL_SYMBOL void __print_assert_failure(VAssertMetaInfo* i);
void gc_check_leaks();
#define _const_symopt_undname 0x00000002
#define _const_symopt_deferred_loads 0x00000004
#define _const_symopt_no_cpp 0x00000008
#define _const_symopt_load_lines 0x00000010
#define _const_symopt_include_32bit_modules 0x00002000
#define _const_symopt_allow_zero_address 0x01000000
#define _const_symopt_debug 0x80000000
u32 g_original_codepage = 0; // global
VV_LOCAL_SYMBOL void restore_codepage();
VV_LOCAL_SYMBOL void builtin_init();
VV_LOCAL_SYMBOL bool print_backtrace_skipping_top_frames(int skipframes);
VV_LOCAL_SYMBOL bool print_backtrace_skipping_top_frames_msvc(int skipframes);
VV_LOCAL_SYMBOL bool print_backtrace_skipping_top_frames_mingw(int skipframes);
VV_LOCAL_SYMBOL bool print_backtrace_skipping_top_frames_tcc(int skipframes);
VV_LOCAL_SYMBOL void add_vectored_exception_handler(VectoredExceptionHandler handler);
VV_LOCAL_SYMBOL int __stdcall  unhandled_exception_handler(ExceptionPointers* e);
VV_LOCAL_SYMBOL void add_unhandled_exception_handler();
VV_LOCAL_SYMBOL void break_if_debugger_attached();
int proc_pidpath(int , voidptr , int );
void chan_close(chan ch);
ChanState chan_try_pop(chan ch, voidptr obj);
ChanState chan_try_push(chan ch, voidptr obj);
string f64_str(f64 x);
string float_literal_str(float_literal d);
string f64_strsci(f64 x, int digit_num);
string f64_strlong(f64 x);
string f32_str(f32 x);
string f32_strsci(f32 x, int digit_num);
string f32_strlong(f32 x);
f32 f32_abs(f32 a);
VV_LOCAL_SYMBOL f64 f64_abs(f64 a);
f32 f32_max(f32 a, f32 b);
f32 f32_min(f32 a, f32 b);
f64 f64_max(f64 a, f64 b);
VV_LOCAL_SYMBOL f64 f64_min(f64 a, f64 b);
bool f32_eq_epsilon(f32 a, f32 b);
bool f64_eq_epsilon(f64 a, f64 b);
string ptr_str(voidptr ptr);
string char_str(char* cptr);
string _const_digit_pairs; // a string literal, inited later
VV_LOCAL_SYMBOL string int_str_l(int nn, int max);
string i8_str(i8 n);
string i16_str(i16 n);
string u16_str(u16 n);
string int_str(int n);
string u32_str(u32 nn);
string int_literal_str(int_literal n);
string i64_str(i64 nn);
string u64_str(u64 nn);
string bool_str(bool b);
VV_LOCAL_SYMBOL string u64_to_hex(u64 nn, byte len);
VV_LOCAL_SYMBOL string u64_to_hex_no_leading_zeros(u64 nn, byte len);
string byte_hex(byte nn);
string i8_hex(i8 nn);
string u16_hex(u16 nn);
string i16_hex(i16 nn);
string u32_hex(u32 nn);
string int_hex(int nn);
string int_hex2(int n);
string u64_hex(u64 nn);
string i64_hex(i64 nn);
string int_literal_hex(int_literal nn);
string voidptr_str(voidptr nn);
string byteptr_str(byteptr nn);
string u64_hex_full(u64 nn);
string byte_str(byte b);
string byte_ascii_str(byte b);
string byte_str_escaped(byte b);
#define _const_hashbits 24
#define _const_max_cached_hashbits 16
#define _const_init_log_capicity 5
int _const_init_capicity; // inited later
#define _const_max_load_factor 0.8
int _const_init_even_index; // inited later
#define _const_extra_metas_inc 4
u32 _const_hash_mask; // inited later
u32 _const_probe_inc; // inited later
VV_LOCAL_SYMBOL bool fast_string_eq(string a, string b);
VV_LOCAL_SYMBOL DenseArray new_dense_array(int key_bytes, int value_bytes);
VV_LOCAL_SYMBOL voidptr DenseArray_key(DenseArray* d, int i);
VV_LOCAL_SYMBOL voidptr DenseArray_value(DenseArray* d, int i);
VV_LOCAL_SYMBOL bool DenseArray_has_index(DenseArray* d, int i);
VV_LOCAL_SYMBOL int DenseArray_expand(DenseArray* d);
VV_LOCAL_SYMBOL void DenseArray_zeros_to_end(DenseArray* d);
VV_LOCAL_SYMBOL u64 map_hash_string(voidptr pkey);
VV_LOCAL_SYMBOL u64 map_hash_int_1(voidptr pkey);
VV_LOCAL_SYMBOL u64 map_hash_int_2(voidptr pkey);
VV_LOCAL_SYMBOL u64 map_hash_int_4(voidptr pkey);
VV_LOCAL_SYMBOL u64 map_hash_int_8(voidptr pkey);
VV_LOCAL_SYMBOL bool map_eq_string(voidptr a, voidptr b);
VV_LOCAL_SYMBOL bool map_eq_int_1(voidptr a, voidptr b);
VV_LOCAL_SYMBOL bool map_eq_int_2(voidptr a, voidptr b);
VV_LOCAL_SYMBOL bool map_eq_int_4(voidptr a, voidptr b);
VV_LOCAL_SYMBOL bool map_eq_int_8(voidptr a, voidptr b);
VV_LOCAL_SYMBOL void map_clone_string(voidptr dest, voidptr pkey);
VV_LOCAL_SYMBOL void map_clone_int_1(voidptr dest, voidptr pkey);
VV_LOCAL_SYMBOL void map_clone_int_2(voidptr dest, voidptr pkey);
VV_LOCAL_SYMBOL void map_clone_int_4(voidptr dest, voidptr pkey);
VV_LOCAL_SYMBOL void map_clone_int_8(voidptr dest, voidptr pkey);
VV_LOCAL_SYMBOL void map_free_string(voidptr pkey);
VV_LOCAL_SYMBOL void map_free_nop(voidptr _t65);
VV_LOCAL_SYMBOL map new_map(int key_bytes, int value_bytes, MapHashFn hash_fn, MapEqFn key_eq_fn, MapCloneFn clone_fn, MapFreeFn free_fn);
VV_LOCAL_SYMBOL map new_map_2(int key_bytes, int value_bytes, MapHashFn hash_fn, MapEqFn key_eq_fn, MapCloneFn clone_fn, MapFreeFn free_fn);
VV_LOCAL_SYMBOL map new_map_init(MapHashFn hash_fn, MapEqFn key_eq_fn, MapCloneFn clone_fn, MapFreeFn free_fn, int n, int key_bytes, int value_bytes, voidptr keys, voidptr values);
VV_LOCAL_SYMBOL map new_map_init_2(MapHashFn hash_fn, MapEqFn key_eq_fn, MapCloneFn clone_fn, MapFreeFn free_fn, int n, int key_bytes, int value_bytes, voidptr keys, voidptr values);
map map_move(map* m);
VV_LOCAL_SYMBOL multi_return_u32_u32 map_key_to_index(map* m, voidptr pkey);
VV_LOCAL_SYMBOL multi_return_u32_u32 map_meta_less(map* m, u32 _index, u32 _metas);
VV_LOCAL_SYMBOL void map_meta_greater(map* m, u32 _index, u32 _metas, u32 kvi);
VV_LOCAL_SYMBOL void map_ensure_extra_metas(map* m, u32 probe_count);
VV_LOCAL_SYMBOL void map_set(map* m, voidptr key, voidptr value);
VV_LOCAL_SYMBOL void map_set_1(map* m, voidptr key, voidptr value);
VV_LOCAL_SYMBOL void map_expand(map* m);
VV_LOCAL_SYMBOL void map_rehash(map* m);
VV_LOCAL_SYMBOL void map_cached_rehash(map* m, u32 old_cap);
VV_LOCAL_SYMBOL voidptr map_get_and_set(map* m, voidptr key, voidptr zero);
VV_LOCAL_SYMBOL voidptr map_get_and_set_1(map* m, voidptr key, voidptr zero);
VV_LOCAL_SYMBOL voidptr map_get(map* m, voidptr key, voidptr zero);
VV_LOCAL_SYMBOL voidptr map_get_1(map* m, voidptr key, voidptr zero);
VV_LOCAL_SYMBOL voidptr map_get_check(map* m, voidptr key);
VV_LOCAL_SYMBOL voidptr map_get_1_check(map* m, voidptr key);
VV_LOCAL_SYMBOL bool map_exists(map* m, voidptr key);
VV_LOCAL_SYMBOL bool map_exists_1(map* m, voidptr key);
VV_LOCAL_SYMBOL void DenseArray_delete(DenseArray* d, int i);
void map_delete(map* m, voidptr key);
VV_LOCAL_SYMBOL array map_keys(map* m);
VV_LOCAL_SYMBOL array map_keys_1(map* m);
VV_LOCAL_SYMBOL DenseArray DenseArray_clone(DenseArray* d);
map map_clone(map* m);
void map_free(map* m);
string IError_str(IError err);
IError _const_none__; // inited later
VV_LOCAL_SYMBOL string None___str(None__ _t68);
IError v_error(string message);
IError error_with_code(string message, int code);
VV_LOCAL_SYMBOL void opt_ok(voidptr data, Option* option, int size);
void Error_free(Error* e);
void None___free(None__* n);
void IError_free(IError* ie);
string rune_str(rune c);
bool byte_is_capital(byte c);
Array_byte Array_byte_clone(Array_byte b);
string Array_byte_bytestr(Array_byte b);
VV_LOCAL_SYMBOL string bytes2string(Array_byte b);
#define _const_degree 6
int _const_mid_index; // inited later
int _const_max_len; // inited later
u32 _const_children_bytes; // inited later
VV_LOCAL_SYMBOL SortedMap new_sorted_map(int n, int value_bytes);
VV_LOCAL_SYMBOL SortedMap new_sorted_map_init(int n, int value_bytes, string* keys, voidptr values);
VV_LOCAL_SYMBOL mapnode* new_node();
VV_LOCAL_SYMBOL void SortedMap_set(SortedMap* m, string key, voidptr value);
VV_LOCAL_SYMBOL void mapnode_split_child(mapnode* n, int child_index, mapnode* y);
VV_LOCAL_SYMBOL bool SortedMap_get(SortedMap m, string key, voidptr out);
VV_LOCAL_SYMBOL bool SortedMap_exists(SortedMap m, string key);
VV_LOCAL_SYMBOL int mapnode_find_key(mapnode* n, string k);
VV_LOCAL_SYMBOL bool mapnode_remove_key(mapnode* n, string k);
VV_LOCAL_SYMBOL void mapnode_remove_from_leaf(mapnode* n, int idx);
VV_LOCAL_SYMBOL void mapnode_remove_from_non_leaf(mapnode* n, int idx);
VV_LOCAL_SYMBOL void mapnode_fill(mapnode* n, int idx);
VV_LOCAL_SYMBOL void mapnode_borrow_from_prev(mapnode* n, int idx);
VV_LOCAL_SYMBOL void mapnode_borrow_from_next(mapnode* n, int idx);
VV_LOCAL_SYMBOL void mapnode_merge(mapnode* n, int idx);
void SortedMap_delete(SortedMap* m, string key);
VV_LOCAL_SYMBOL int mapnode_subkeys(mapnode* n, Array_string* keys, int at);
Array_string SortedMap_keys(SortedMap* m);
VV_LOCAL_SYMBOL void mapnode_free(mapnode* n);
void SortedMap_free(SortedMap* m);
void SortedMap_print(SortedMap m);
int vstrlen(byte* s);
string tos(byte* s, int len);
string tos_clone(byte* s);
string tos2(byte* s);
string tos3(char* s);
string tos4(byte* s);
string tos5(char* s);
string tos_lit(char* s);
string byte_vstring(byte* bp);
string byte_vstring_with_len(byte* bp, int len);
string char_vstring(char* cp);
string char_vstring_with_len(char* cp, int len);
string byte_vstring_literal(byte* bp);
string byte_vstring_literal_with_len(byte* bp, int len);
string char_vstring_literal(char* cp);
string char_vstring_literal_with_len(char* cp, int len);
VV_LOCAL_SYMBOL string string_clone_static(string a);
string string_clone(string a);
string cstring_to_vstring(char* cstr);
string string_replace_once(string s, string rep, string with);
string string_replace(string s, string rep, string with);
VV_LOCAL_SYMBOL int compare_rep_index(RepIndex* a, RepIndex* b);
VV_LOCAL_SYMBOL void Array_RepIndex_sort2(Array_RepIndex* a);
string string_replace_each(string s, Array_string vals);
bool string_bool(string s);
int string_int(string s);
i64 string_i64(string s);
i8 string_i8(string s);
i16 string_i16(string s);
f32 string_f32(string s);
f64 string_f64(string s);
u16 string_u16(string s);
u32 string_u32(string s);
u64 string_u64(string s);
VV_LOCAL_SYMBOL bool string_eq(string s, string a);
VV_LOCAL_SYMBOL bool string_ne(string s, string a);
VV_LOCAL_SYMBOL bool string_lt(string s, string a);
VV_LOCAL_SYMBOL bool string_le(string s, string a);
VV_LOCAL_SYMBOL bool string_gt(string s, string a);
VV_LOCAL_SYMBOL bool string_ge(string s, string a);
string string_add(string s, string a);
Array_string string_split(string s, string delim);
Array_string string_split_nth(string s, string delim, int nth);
Array_string string_split_into_lines(string s);
VV_LOCAL_SYMBOL string string_substr2(string s, int start, int _end, bool end_max);
string string_substr(string s, int start, int end);
VV_LOCAL_SYMBOL int string_index_(string s, string p);
Option_int string_index(string s, string p);
VV_LOCAL_SYMBOL int string_index_kmp(string s, string p);
int string_index_any(string s, string chars);
VV_LOCAL_SYMBOL int string_last_index_(string s, string p);
Option_int string_last_index(string s, string p);
int string_index_after(string s, string p, int start);
int string_index_byte(string s, byte c);
int string_last_index_byte(string s, byte c);
int string_count(string s, string substr);
bool string_contains(string s, string substr);
bool string_contains_any(string s, string chars);
bool string_contains_any_substr(string s, Array_string substrs);
bool string_starts_with(string s, string p);
bool string_ends_with(string s, string p);
string string_to_lower(string s);
bool string_is_lower(string s);
string string_to_upper(string s);
bool string_is_upper(string s);
string string_capitalize(string s);
bool string_is_capital(string s);
string string_title(string s);
bool string_is_title(string s);
string string_find_between(string s, string start, string end);
bool byte_is_space(byte c);
string string_trim_space(string s);
string string_trim(string s, string cutset);
string string_trim_left(string s, string cutset);
string string_trim_right(string s, string cutset);
string string_trim_prefix(string s, string str);
string string_trim_suffix(string s, string str);
int compare_strings(string* a, string* b);
VV_LOCAL_SYMBOL int compare_strings_reverse(string* a, string* b);
VV_LOCAL_SYMBOL int compare_strings_by_len(string* a, string* b);
VV_LOCAL_SYMBOL int compare_lower_strings(string* a, string* b);
void Array_string_sort(Array_string* s);
void Array_string_sort_ignore_case(Array_string* s);
void Array_string_sort_by_len(Array_string* s);
string string_str(string s);
string ustring_str(ustring s);
ustring string_ustring(string s);
Array_int g_ustring_runes; // global
ustring string_ustring_tmp(string s);
VV_LOCAL_SYMBOL bool ustring_eq(ustring u, ustring a);
VV_LOCAL_SYMBOL bool ustring_ne(ustring u, ustring a);
VV_LOCAL_SYMBOL bool ustring_lt(ustring u, ustring a);
VV_LOCAL_SYMBOL bool ustring_le(ustring u, ustring a);
VV_LOCAL_SYMBOL bool ustring_gt(ustring u, ustring a);
VV_LOCAL_SYMBOL bool ustring_ge(ustring u, ustring a);
ustring ustring_add(ustring u, ustring a);
int ustring_index_after(ustring u, ustring p, int start);
int ustring_count(ustring u, ustring substr);
string ustring_substr(ustring u, int _start, int _end);
string ustring_left(ustring u, int pos);
string ustring_right(ustring u, int pos);
VV_LOCAL_SYMBOL byte string_at(string s, int idx);
string ustring_at(ustring u, int idx);
VV_LOCAL_SYMBOL void ustring_free(ustring* u);
bool byte_is_digit(byte c);
bool byte_is_hex_digit(byte c);
bool byte_is_oct_digit(byte c);
bool byte_is_bin_digit(byte c);
bool byte_is_letter(byte c);
void string_free(string* s);
string string_before(string s, string dot);
string string_all_before(string s, string dot);
string string_all_before_last(string s, string dot);
string string_all_after(string s, string dot);
string string_all_after_last(string s, string dot);
string string_after(string s, string dot);
string string_after_char(string s, byte dot);
string Array_string_join(Array_string a, string del);
string Array_string_join_lines(Array_string s);
string string_reverse(string s);
string string_limit(string s, int max);
int string_hash(string s);
Array_byte string_bytes(string s);
string string_repeat(string s, int count);
Array_string string_fields(string s);
string string_strip_margin(string s);
string string_strip_margin_custom(string s, byte del);
Array_string string_split_by_whitespace(string s);
Array_byte byteptr_vbytes(byteptr data, int len);
string byteptr_vstring(byteptr bp);
string byteptr_vstring_with_len(byteptr bp, int len);
string charptr_vstring(charptr cp);
string charptr_vstring_with_len(charptr cp, int len);
string byteptr_vstring_literal(byteptr bp);
string byteptr_vstring_literal_with_len(byteptr bp, int len);
string charptr_vstring_literal(charptr cp);
string charptr_vstring_literal_with_len(charptr cp, int len);
#define _const_cp_utf8 65001
u16* string_to_wide(string _str);
string string_from_wide(u16* _wstr);
string string_from_wide2(u16* _wstr, int len);
int utf8_getchar();
int utf8_char_len(byte b);
string utf32_to_str(u32 code);
string utf32_to_str_no_malloc(u32 code, voidptr buf);
int string_utf32_code(string _rune);
VV_LOCAL_SYMBOL int utf8_len(byte c);
VV_LOCAL_SYMBOL int utf8_str_len(string s);
int utf8_str_visible_length(string s);
Array_string os__args_after(string cut_word);
Array_string os__args_before(string cut_word);
#define _const_os__success 0x0000
#define _const_os__error_insufficient_buffer 0x0082
#define _const_os__handle_generic_read 0x80000000
#define _const_os__handle_open_existing 0x00000003
#define _const_os__file_share_read 0x01
#define _const_os__file_share_write 0x02
#define _const_os__file_share_delete 0x04
#define _const_os__file_notify_change_file_name 0x01
#define _const_os__file_notify_change_dir_name 0x02
#define _const_os__file_notify_change_attributes 0x04
#define _const_os__file_notify_change_size 0x08
#define _const_os__file_notify_change_last_write 0x10
#define _const_os__file_notify_change_last_access 0x20
#define _const_os__file_notify_change_creation 0x40
#define _const_os__file_notify_change_security 0x80
#define _const_os__file_action_added 0x01
#define _const_os__file_action_removed 0x02
#define _const_os__file_action_modified 0x03
#define _const_os__file_action_renamed_old_name 0x04
#define _const_os__file_action_renamed_new_name 0x05
#define _const_os__file_attr_readonly 0x00000001
#define _const_os__file_attr_hidden 0x00000002
#define _const_os__file_attr_system 0x00000004
#define _const_os__file_attr_directory 0x00000010
#define _const_os__file_attr_archive 0x00000020
#define _const_os__file_attr_device 0x00000040
#define _const_os__file_attr_normal 0x00000080
#define _const_os__file_attr_temporary 0x00000100
#define _const_os__file_attr_sparse_file 0x00000200
#define _const_os__file_attr_reparse_point 0x00000400
#define _const_os__file_attr_compressed 0x00000800
#define _const_os__file_attr_offline 0x00001000
#define _const_os__file_attr_not_content_indexed 0x00002000
#define _const_os__file_attr_encrypted 0x00004000
#define _const_os__file_attr_integrity_stream 0x00008000
#define _const_os__file_attr_virtual 0x00010000
#define _const_os__file_attr_no_scrub_data 0x00020000
#define _const_os__file_type_unknown 0x00
#define _const_os__file_type_disk 0x01
#define _const_os__file_type_char 0x02
#define _const_os__file_type_pipe 0x03
int _const_os__file_invalid_file_id; // inited later
voidptr _const_os__invalid_handle_value; // inited later
#define _const_os__enable_echo_input 0x0004
#define _const_os__enable_extended_flags 0x0080
#define _const_os__enable_insert_mode 0x0020
#define _const_os__enable_line_input 0x0002
#define _const_os__enable_mouse_input 0x0010
#define _const_os__enable_processed_input 0x0001
#define _const_os__enable_quick_edit_mode 0x0040
#define _const_os__enable_window_input 0x0008
#define _const_os__enable_virtual_terminal_input 0x0200
#define _const_os__enable_processed_output 0x01
#define _const_os__enable_wrap_at_eol_output 0x02
#define _const_os__enable_virtual_terminal_processing 0x04
#define _const_os__disable_newline_auto_return 0x08
#define _const_os__enable_lvb_grid_worldwide 0x10
#define _const_os__o_rdonly 0x0000
#define _const_os__o_wronly 0x0001
#define _const_os__o_rdwr 0x0002
#define _const_os__o_append 0x0008
#define _const_os__o_create 0x0100
#define _const_os__o_binary 0x8000
#define _const_os__o_trunc 0x0200
#define _const_os__o_excl 0x0400
#define _const_os__o_sync 0x0000
#define _const_os__o_noctty 0x0000
#define _const_os__o_nonblock 0x0000
#define _const_os__status_access_violation 0xC0000005
#define _const_os__status_in_page_error 0xC0000006
#define _const_os__status_invalid_handle 0xC0000008
#define _const_os__status_invalid_parameter 0xC000000D
#define _const_os__status_no_memory 0xC0000017
#define _const_os__status_illegal_instruction 0xC000001D
#define _const_os__status_noncontinuable_exception 0xC0000025
#define _const_os__status_invalid_disposition 0xC0000026
#define _const_os__status_array_bounds_exceeded 0xC000008C
#define _const_os__status_float_denormal_operand 0xC000008D
#define _const_os__status_float_divide_by_zero 0xC000008E
#define _const_os__status_float_inexact_result 0xC000008F
#define _const_os__status_float_invalid_operation 0xC0000090
#define _const_os__status_float_overflow 0xC0000091
#define _const_os__status_float_stack_check 0xC0000092
#define _const_os__status_float_underflow 0xC0000093
#define _const_os__status_integer_divide_by_zero 0xC0000094
#define _const_os__status_integer_overflow 0xC0000095
#define _const_os__status_privileged_instruction 0xC0000096
#define _const_os__status_stack_overflow 0xC00000FD
#define _const_os__status_dll_not_found 0xC0000135
#define _const_os__status_ordinal_not_found 0xC0000138
#define _const_os__status_entrypoint_not_found 0xC0000139
#define _const_os__status_control_c_exit 0xC000013A
#define _const_os__status_dll_init_failed 0xC0000142
#define _const_os__status_float_multiple_faults 0xC00002B4
#define _const_os__status_float_multiple_traps 0xC00002B5
#define _const_os__status_reg_nat_consumption 0xC00002C9
#define _const_os__status_heap_corruption 0xC0000374
#define _const_os__status_stack_buffer_overrun 0xC0000409
#define _const_os__status_invalid_cruntime_parameter 0xC0000417
#define _const_os__status_assertion_failure 0xC0000420
voidptr _const_os__hkey_local_machine; // inited later
voidptr _const_os__hkey_current_user; // inited later
#define _const_os__key_query_value 0x0001
#define _const_os__key_set_value 0x0002
#define _const_os__key_enumerate_sub_keys 0x0008
#define _const_os__key_wow64_32key 0x0200
voidptr _const_os__hwnd_broadcast; // inited later
#define _const_os__wm_settingchange 0x001A
#define _const_os__smto_abortifhung 0x0002
string os__getenv(string key);
int os__setenv(string name, string value, bool overwrite);
int os__unsetenv(string name);
VV_LOCAL_SYMBOL char** os__unix_environ();
Map_string_string os__environ();
int os__fd_close(int fd);
void os__fd_write(int fd, string s);
Array_string os__fd_slurp(int fd);
multi_return_string_int os__fd_read(int fd, int maxbytes);
Option_os__File os__open_file(string path, string mode, Array_int options);
Option_os__File os__open(string path);
Option_os__File os__create(string path);
os__File os__open_stdin();
Option_int os__File_write(os__File* f, Array_byte buf);
Option_int os__File_writeln(os__File* f, string s);
Option_int os__File_write_string(os__File* f, string s);
Option_int os__File_write_to(os__File* f, u64 pos, Array_byte buf);
int os__File_write_bytes(os__File* f, voidptr data, int size);
int os__File_write_bytes_at(os__File* f, voidptr data, int size, u64 pos);
int os__File_write_ptr(os__File* f, voidptr data, int size);
int os__File_write_ptr_at(os__File* f, voidptr data, int size, u64 pos);
Array_byte os__File_read_bytes(os__File* f, int size);
Array_byte os__File_read_bytes_at(os__File* f, int size, u64 pos);
Option_int os__File_read_bytes_into(os__File* f, u64 pos, Array_byte* buf);
Option_int os__File_read(os__File* f, Array_byte* buf);
Option_int os__File_read_at(os__File* f, u64 pos, Array_byte* buf);
Option_int os__File_read_from(os__File* f, u64 pos, Array_byte* buf);
void os__File_flush(os__File* f);
Option_void os__File_write_str(os__File* f, string s);
os__FileMode os__inode(string path);
Array_string _const_os__args; // inited later
#define _const_os__max_path_len 4096
string _const_os__wd_at_startup; // inited later
#define _const_os__f_ok 0
#define _const_os__x_ok 1
#define _const_os__w_ok 2
#define _const_os__r_ok 4
void os__Result_free(os__Result* result);
Option_void os__cp_all(string src, string dst, bool overwrite);
Option_void os__mv_by_cp(string source, string target);
Option_Array_string os__read_lines(string path);
VV_LOCAL_SYMBOL Option_Array_ustring os__read_ulines(string path);
string os__sigint_to_signal_name(int si);
Option_void os__rmdir_all(string path);
bool os__is_dir_empty(string path);
string os__file_ext(string path);
string os__dir(string path);
string os__base(string path);
string os__file_name(string path);
Option_string os__input_opt(string prompt);
string os__input(string prompt);
string os__get_line();
Array_string os__get_lines();
string os__get_lines_joined();
string os__get_raw_lines_joined();
string os__user_os();
string os__home_dir();
Option_void os__write_file(string path, string text);
Option_void os__write_file_array(string path, array buffer);
VV_LOCAL_SYMBOL string os__executable_fallback();
Option_string os__find_abs_path_of_executable(string exepath);
bool os__exists_in_system_path(string prog);
bool os__is_file(string path);
bool os__is_abs_path(string path);
string os__join_path(string base, Array_string dirs);
Array_string os__walk_ext(string path, string ext);
void os__walk(string path, void (*f)(string ));
void os__log(string s);
Option_void os__mkdir_all(string path);
string os__cache_dir();
string os__temp_dir();
VV_LOCAL_SYMBOL string os__default_vmodules_path();
string os__vmodules_dir();
Array_string os__vmodules_paths();
string os__resource_abs_path(string path);
Option_os__Result os__exec(string cmd);
os__Result os__execute_or_panic(string cmd);
Option_Array_byte os__read_bytes(string path);
Option_string os__read_file(string path);
u64 os__file_size(string path);
Option_void os__mv(string src, string dst);
Option_void os__cp(string src, string dst);
Option_FILE_ptr os__vfopen(string path, string mode);
int os__fileno(voidptr cfile);
VV_LOCAL_SYMBOL voidptr os__vpopen(string path);
VV_LOCAL_SYMBOL multi_return_int_bool os__posix_wait4_to_exit_status(int waitret);
string os__posix_get_error_msg(int code);
VV_LOCAL_SYMBOL int os__vpclose(voidptr f);
int os__system(string cmd);
bool os__exists(string path);
bool os__is_executable(string path);
bool os__is_writable(string path);
bool os__is_readable(string path);
Option_void os__rm(string path);
Option_void os__rmdir(string path);
VV_LOCAL_SYMBOL void os__print_c_errno();
string os__get_raw_line();
Array_byte os__get_raw_stdin();
void os__on_segfault(voidptr f);
string os__executable();
bool os__is_dir(string path);
bool os__is_link(string path);
void os__chdir(string path);
string os__getwd();
string os__real_path(string fpath);
VV_LOCAL_SYMBOL string os__normalize_drive_letter(string path);
voidptr os__signal(int signum, voidptr handler);
int os__fork();
int os__wait();
int os__file_last_mod_unix(string path);
void os__flush();
void os__chmod(string path, int mode);
Option_os__File os__open_append(string path);
Option_void os__execvp(string cmdpath, Array_string args);
Option_void os__execve(string cmdpath, Array_string args, Array_string envs);
string _const_os__path_separator; // a string literal, inited later
string _const_os__path_delimiter; // a string literal, inited later
VV_LOCAL_SYMBOL Array_string os__init_os_args_wide(int argc, byte** argv);
Option_Array_string os__ls(string path);
Option_bool os__mkdir(string path);
os__HANDLE os__get_file_handle(string path);
Option_string os__get_module_filename(os__HANDLE handle);
#define _const_os__format_message_allocate_buffer 0x00000100
#define _const_os__format_message_argument_array 0x00002000
#define _const_os__format_message_from_hmodule 0x00000800
#define _const_os__format_message_from_string 0x00000400
#define _const_os__format_message_from_system 0x00001000
#define _const_os__format_message_ignore_inserts 0x00000200
#define _const_os__sublang_neutral 0x00
#define _const_os__sublang_default 0x01
int _const_os__lang_neutral; // inited later
#define _const_os__max_error_code 15841
VV_LOCAL_SYMBOL voidptr os__ptr_win_get_error_msg(u32 code);
string os__get_error_msg(int code);
os__Result os__execute(string cmd);
Option_bool os__symlink(string symlink_path, string target_path);
void os__File_close(os__File* f);
void os__add_vectored_exception_handler(bool first, VectoredExceptionHandler handler);
bool os__debugger_present();
os__Uname os__uname();
Option_bool os__is_writable_folder(string folder);
int os__getpid();
void os__posix_set_permission_bit(string path_s, u32 mode, bool enable);
os__Process* os__new_process(string filename);
void os__Process_set_args(os__Process* p, Array_string pargs);
void os__Process_set_environment(os__Process* p, Map_string_string envs);
void os__Process_run(os__Process* p);
void os__Process_signal_kill(os__Process* p);
void os__Process_signal_pgkill(os__Process* p);
void os__Process_signal_stop(os__Process* p);
void os__Process_signal_continue(os__Process* p);
void os__Process_wait(os__Process* p);
VV_LOCAL_SYMBOL int os__Process__spawn(os__Process* p);
bool os__Process_is_alive(os__Process* p);
void os__Process_set_redirect_stdio(os__Process* p);
void os__Process_stdin_write(os__Process* p, string s);
string os__Process_stdout_slurp(os__Process* p);
string os__Process_stderr_slurp(os__Process* p);
string os__Process_stdout_read(os__Process* p);
string os__Process_stderr_read(os__Process* p);
VV_LOCAL_SYMBOL void os__Process__check_redirection_call(os__Process* p, string fn_name);
VV_LOCAL_SYMBOL void os__Process__signal_stop(os__Process* p);
VV_LOCAL_SYMBOL void os__Process__signal_continue(os__Process* p);
VV_LOCAL_SYMBOL void os__Process__signal_kill(os__Process* p);
VV_LOCAL_SYMBOL void os__Process__signal_pgkill(os__Process* p);
VV_LOCAL_SYMBOL void os__Process__wait(os__Process* p);
VV_LOCAL_SYMBOL bool os__Process__is_alive(os__Process* p);
VV_LOCAL_SYMBOL os__FN_NTSuspendResume os__ntdll_fn(char* name);
VV_LOCAL_SYMBOL void os__failed_cfn_report_error(bool ok, string label);
VV_LOCAL_SYMBOL void os__close_valid_handle(voidptr p);
VV_LOCAL_SYMBOL int os__Process_win_spawn_process(os__Process* p);
VV_LOCAL_SYMBOL void os__Process_win_stop_process(os__Process* p);
VV_LOCAL_SYMBOL void os__Process_win_resume_process(os__Process* p);
VV_LOCAL_SYMBOL void os__Process_win_kill_process(os__Process* p);
VV_LOCAL_SYMBOL void os__Process_win_kill_pgroup(os__Process* p);
VV_LOCAL_SYMBOL void os__Process_win_wait(os__Process* p);
VV_LOCAL_SYMBOL bool os__Process_win_is_alive(os__Process* p);
VV_LOCAL_SYMBOL void os__Process_win_write_string(os__Process* p, int idx, string s);
VV_LOCAL_SYMBOL multi_return_string_int os__Process_win_read_string(os__Process* p, int idx, int maxbytes);
VV_LOCAL_SYMBOL string os__Process_win_slurp(os__Process* p, int idx);
VV_LOCAL_SYMBOL int os__Process_unix_spawn_process(os__Process* p);
VV_LOCAL_SYMBOL void os__Process_unix_stop_process(os__Process* p);
VV_LOCAL_SYMBOL void os__Process_unix_resume_process(os__Process* p);
VV_LOCAL_SYMBOL void os__Process_unix_kill_process(os__Process* p);
VV_LOCAL_SYMBOL void os__Process_unix_kill_pgroup(os__Process* p);
VV_LOCAL_SYMBOL void os__Process_unix_wait(os__Process* p);
VV_LOCAL_SYMBOL bool os__Process_unix_is_alive(os__Process* p);
Array_string os__cmdline__options(Array_string args, string param);
string os__cmdline__option(Array_string args, string param, string def);
Array_string os__cmdline__options_before(Array_string args, Array_string what);
Array_string os__cmdline__options_after(Array_string args, Array_string what);
Array_string os__cmdline__only_non_options(Array_string args);
Array_string os__cmdline__only_options(Array_string args);
string time__Time_format(time__Time t);
string time__Time_format_ss(time__Time t);
string time__Time_format_ss_milli(time__Time t);
string time__Time_format_ss_micro(time__Time t);
string time__Time_hhmm(time__Time t);
string time__Time_hhmmss(time__Time t);
string time__Time_hhmm12(time__Time t);
string time__Time_ymmdd(time__Time t);
string time__Time_ddmmy(time__Time t);
string time__Time_md(time__Time t);
string time__Time_clean(time__Time t);
string time__Time_clean12(time__Time t);
string time__Time_get_fmt_time_str(time__Time t, time__FormatTime fmt_time);
string time__Time_get_fmt_date_str(time__Time t, time__FormatDelimiter fmt_dlmtr, time__FormatDate fmt_date);
string time__Time_get_fmt_str(time__Time t, time__FormatDelimiter fmt_dlmtr, time__FormatTime fmt_time, time__FormatDate fmt_date);
string time__Time_utc_string(time__Time t);
bool time__Time__eq(time__Time t1, time__Time t2);
bool time__Time__lt(time__Time t1, time__Time t2);
time__Duration time__Time__minus(time__Time lhs, time__Time rhs);
Option_time__Time time__parse(string s);
Option_time__Time time__parse_rfc2822(string s);
IError _const_time__err_invalid_8601; // inited later
VV_LOCAL_SYMBOL Option_multi_return_int_int_int time__parse_iso8601_date(string s);
VV_LOCAL_SYMBOL Option_multi_return_int_int_int_int_i64_bool time__parse_iso8601_time(string s);
Option_time__Time time__parse_iso8601(string s);
time__StopWatch time__new_stopwatch(time__StopWatchOptions opts);
void time__StopWatch_start(time__StopWatch* t);
void time__StopWatch_restart(time__StopWatch* t);
void time__StopWatch_stop(time__StopWatch* t);
void time__StopWatch_pause(time__StopWatch* t);
time__Duration time__StopWatch_elapsed(time__StopWatch t);
string _const_time__days_string; // a string literal, inited later
Array_int _const_time__month_days; // inited later
string _const_time__months_string; // a string literal, inited later
i64 _const_time__absolute_zero_year; // inited later
#define _const_time__seconds_per_minute 60
int _const_time__seconds_per_hour; // inited later
int _const_time__seconds_per_day; // inited later
int _const_time__seconds_per_week; // inited later
int _const_time__days_per_400_years; // inited later
int _const_time__days_per_100_years; // inited later
int _const_time__days_per_4_years; // inited later
Array_int _const_time__days_before; // inited later
Array_string _const_time__long_days; // inited later
time__Time time__now();
time__Time time__utc();
string time__Time_smonth(time__Time t);
time__Time time__new_time(time__Time t);
int time__Time_unix_time(time__Time t);
u64 time__Time_unix_time_milli(time__Time t);
time__Time time__Time_add(time__Time t, time__Duration d);
time__Time time__Time_add_seconds(time__Time t, int seconds);
time__Time time__Time_add_days(time__Time t, int days);
VV_LOCAL_SYMBOL int time__since(time__Time t);
string time__Time_relative(time__Time t);
string time__Time_relative_short(time__Time t);
int time__day_of_week(int y, int m, int d);
int time__Time_day_of_week(time__Time t);
string time__Time_weekday_str(time__Time t);
string time__Time_long_weekday_str(time__Time t);
i64 time__ticks();
void time__sleep_ms(int milliseconds);
void time__usleep(int microseconds);
bool time__is_leap_year(int year);
Option_int time__days_in_month(int month, int year);
string time__Time_str(time__Time t);
VV_LOCAL_SYMBOL time__Time time__convert_ctime(struct tm t, int microsecond);
time__Duration _const_time__nanosecond; // inited later
time__Duration _const_time__microsecond; // inited later
time__Duration _const_time__millisecond; // inited later
time__Duration _const_time__second; // inited later
time__Duration _const_time__minute; // inited later
time__Duration _const_time__hour; // inited later
time__Duration _const_time__infinite; // inited later
i64 time__Duration_nanoseconds(time__Duration d);
i64 time__Duration_microseconds(time__Duration d);
i64 time__Duration_milliseconds(time__Duration d);
f64 time__Duration_seconds(time__Duration d);
f64 time__Duration_minutes(time__Duration d);
f64 time__Duration_hours(time__Duration d);
int time__offset();
u64 _const_time__start_time; // inited later
u64 _const_time__freq_time; // inited later
int _const_time__start_local_time; // inited later
VV_LOCAL_SYMBOL int time__make_unix_time(struct tm t);
VV_LOCAL_SYMBOL u64 time__init_win_time_freq();
VV_LOCAL_SYMBOL u64 time__init_win_time_start();
u64 time__sys_mono_now();
VV_LOCAL_SYMBOL u64 time__vpc_now();
VV_LOCAL_SYMBOL int time__local_as_unix_time();
time__Time time__Time_local(time__Time t);
VV_LOCAL_SYMBOL time__Time time__win_now();
VV_LOCAL_SYMBOL time__Time time__win_utc();
int time__SystemTime_unix_time(time__SystemTime st);
time__Time time__darwin_now();
time__Time time__linux_now();
time__Time time__solaris_now();
time__Time time__darwin_utc();
time__Time time__linux_utc();
time__Time time__solaris_utc();
void time__wait(time__Duration duration);
void time__sleep(time__Duration duration);
time__Time time__unix(int abs);
time__Time time__unix2(int abs, int microsecond);
VV_LOCAL_SYMBOL multi_return_int_int_int time__calculate_date_from_offset(int day_offset_);
VV_LOCAL_SYMBOL multi_return_int_int_int time__calculate_time_from_offset(int second_offset_);
int math__mathutil__min_T_int(int a, int b);
int math__mathutil__max_T_int(int a, int b);
string v__token__Position_str(v__token__Position pos);
v__token__Position v__token__Position_extend(v__token__Position pos, v__token__Position end);
v__token__Position v__token__Position_extend_with_last_line(v__token__Position pos, v__token__Position end, int last_line);
void v__token__Position_update_last_line(v__token__Position* pos, int last_line);
v__token__Position v__token__Token_position(v__token__Token* tok);
Array_v__token__Kind _const_v__token__assign_tokens; // inited later
int _const_v__token__nr_tokens; // inited later
Array_string _const_v__token__valid_at_tokens; // inited later
VV_LOCAL_SYMBOL Map_string_v__token__Kind v__token__build_keys();
VV_LOCAL_SYMBOL Array_string v__token__build_token_str();
Array_string _const_v__token__token_str; // inited later
Map_string_v__token__Kind _const_v__token__keywords; // inited later
v__token__Kind v__token__key_to_token(string key);
bool v__token__is_key(string key);
bool v__token__is_decl(v__token__Kind t);
bool v__token__Kind_is_assign(v__token__Kind t);
string v__token__Kind_str(v__token__Kind t);
string v__token__Token_str(v__token__Token t);
Array_v__token__Precedence v__token__build_precedences();
Array_v__token__Precedence _const_v__token__precedences; // inited later
int v__token__Token_precedence(v__token__Token tok);
bool v__token__Token_is_scalar(v__token__Token tok);
bool v__token__Token_is_unary(v__token__Token tok);
bool v__token__Kind_is_relational(v__token__Kind tok);
bool v__token__Kind_is_start_of_type(v__token__Kind k);
bool v__token__Kind_is_prefix(v__token__Kind kind);
bool v__token__Kind_is_infix(v__token__Kind kind);
bool v__token__Token_can_start_type(v__token__Token* tok, Array_string builtin_type_names);
void v__depgraph__OrderedDepMap_set(v__depgraph__OrderedDepMap* o, string name, Array_string deps);
void v__depgraph__OrderedDepMap_add(v__depgraph__OrderedDepMap* o, string name, Array_string deps);
Array_string v__depgraph__OrderedDepMap_get(v__depgraph__OrderedDepMap* o, string name);
void v__depgraph__OrderedDepMap_delete(v__depgraph__OrderedDepMap* o, string name);
void v__depgraph__OrderedDepMap_apply_diff(v__depgraph__OrderedDepMap* o, string name, Array_string deps);
int v__depgraph__OrderedDepMap_size(v__depgraph__OrderedDepMap* o);
v__depgraph__DepGraph* v__depgraph__new_dep_graph();
void v__depgraph__DepGraph_add(v__depgraph__DepGraph* graph, string mod, Array_string deps);
v__depgraph__DepGraph* v__depgraph__DepGraph_resolve(v__depgraph__DepGraph* graph);
v__depgraph__DepGraphNode v__depgraph__DepGraph_last_node(v__depgraph__DepGraph* graph);
string v__depgraph__DepGraph_display(v__depgraph__DepGraph* graph);
string v__depgraph__DepGraph_display_cycles(v__depgraph__DepGraph* graph);
u64 _const_rand__constants__lower_mask; // inited later
#define _const_rand__constants__max_u32 0xFFFFFFFF
#define _const_rand__constants__max_u64 0xFFFFFFFFFFFFFFFF
f32 _const_rand__constants__max_u32_as_f32; // inited later
f64 _const_rand__constants__max_u64_as_f64; // inited later
u32 _const_rand__constants__u31_mask; // inited later
u64 _const_rand__constants__u63_mask; // inited later
VV_LOCAL_SYMBOL void flag__Flag_free(flag__Flag* f);
string flag__Flag_str(flag__Flag f);
string Array_flag__Flag_str(Array_flag__Flag af);
VV_LOCAL_SYMBOL void flag__FlagParser_free(flag__FlagParser* f);
string _const_flag__space; // a string literal, inited later
string _const_flag__underline; // a string literal, inited later
#define _const_flag__max_args_number 4048
flag__FlagParser* flag__new_flag_parser(Array_string args);
void flag__FlagParser_application(flag__FlagParser* fs, string name);
void flag__FlagParser_version(flag__FlagParser* fs, string vers);
void flag__FlagParser_description(flag__FlagParser* fs, string desc);
void flag__FlagParser_skip_executable(flag__FlagParser* fs);
VV_LOCAL_SYMBOL void flag__FlagParser_add_flag(flag__FlagParser* fs, string name, byte abbr, string usage, string desc);
VV_LOCAL_SYMBOL Array_string flag__FlagParser_parse_value(flag__FlagParser* fs, string longhand, byte shorthand);
VV_LOCAL_SYMBOL Option_string flag__FlagParser_parse_bool_value(flag__FlagParser* fs, string longhand, byte shorthand);
Option_bool flag__FlagParser_bool_opt(flag__FlagParser* fs, string name, byte abbr, string usage);
bool flag__FlagParser_bool(flag__FlagParser* fs, string name, byte abbr, bool bdefault, string usage);
Array_int flag__FlagParser_int_multi(flag__FlagParser* fs, string name, byte abbr, string usage);
Option_int flag__FlagParser_int_opt(flag__FlagParser* fs, string name, byte abbr, string usage);
int flag__FlagParser_int(flag__FlagParser* fs, string name, byte abbr, int idefault, string usage);
Array_f64 flag__FlagParser_float_multi(flag__FlagParser* fs, string name, byte abbr, string usage);
Option_f64 flag__FlagParser_float_opt(flag__FlagParser* fs, string name, byte abbr, string usage);
f64 flag__FlagParser_float(flag__FlagParser* fs, string name, byte abbr, f64 fdefault, string usage);
Array_string flag__FlagParser_string_multi(flag__FlagParser* fs, string name, byte abbr, string usage);
Option_string flag__FlagParser_string_opt(flag__FlagParser* fs, string name, byte abbr, string usage);
string flag__FlagParser_string(flag__FlagParser* fs, string name, byte abbr, string sdefault, string usage);
void flag__FlagParser_limit_free_args_to_at_least(flag__FlagParser* fs, int n);
void flag__FlagParser_limit_free_args_to_exactly(flag__FlagParser* fs, int n);
void flag__FlagParser_limit_free_args(flag__FlagParser* fs, int min, int max);
void flag__FlagParser_arguments_description(flag__FlagParser* fs, string description);
string flag__FlagParser_usage(flag__FlagParser fs);
Option_Array_string flag__FlagParser_finalize(flag__FlagParser fs);
VV_LOCAL_SYMBOL bool semver__version_satisfies(semver__Version ver, string input);
VV_LOCAL_SYMBOL bool semver__compare_eq(semver__Version v1, semver__Version v2);
VV_LOCAL_SYMBOL bool semver__compare_gt(semver__Version v1, semver__Version v2);
VV_LOCAL_SYMBOL bool semver__compare_lt(semver__Version v1, semver__Version v2);
VV_LOCAL_SYMBOL bool semver__compare_ge(semver__Version v1, semver__Version v2);
VV_LOCAL_SYMBOL bool semver__compare_le(semver__Version v1, semver__Version v2);
#define _const_semver__ver_major 0
#define _const_semver__ver_minor 1
#define _const_semver__ver_patch 2
Array_int _const_semver__versions; // inited later
VV_LOCAL_SYMBOL semver__RawVersion semver__parse(string input);
VV_LOCAL_SYMBOL bool semver__RawVersion_is_valid(semver__RawVersion ver);
VV_LOCAL_SYMBOL bool semver__RawVersion_is_missing(semver__RawVersion ver, int typ);
VV_LOCAL_SYMBOL Option_semver__Version semver__RawVersion_coerce(semver__RawVersion raw_ver);
VV_LOCAL_SYMBOL semver__RawVersion semver__RawVersion_complete(semver__RawVersion raw_ver);
VV_LOCAL_SYMBOL Option_semver__Version semver__RawVersion_validate(semver__RawVersion raw_ver);
VV_LOCAL_SYMBOL semver__Version semver__RawVersion_to_version(semver__RawVersion raw_ver);
string _const_semver__comparator_sep; // a string literal, inited later
string _const_semver__comparator_set_sep; // a string literal, inited later
string _const_semver__hyphen_range_sep; // a string literal, inited later
string _const_semver__x_range_symbols; // a string literal, inited later
VV_LOCAL_SYMBOL bool semver__Range_satisfies(semver__Range r, semver__Version ver);
VV_LOCAL_SYMBOL bool semver__ComparatorSet_satisfies(semver__ComparatorSet set, semver__Version ver);
VV_LOCAL_SYMBOL bool semver__Comparator_satisfies(semver__Comparator c, semver__Version ver);
VV_LOCAL_SYMBOL Option_semver__Range semver__parse_range(string input);
VV_LOCAL_SYMBOL Option_semver__ComparatorSet semver__parse_comparator_set(string input);
VV_LOCAL_SYMBOL Option_semver__Comparator semver__parse_comparator(string input);
VV_LOCAL_SYMBOL Option_semver__Version semver__parse_xrange(string input);
VV_LOCAL_SYMBOL bool semver__can_expand(string input);
VV_LOCAL_SYMBOL Option_semver__ComparatorSet semver__expand_comparator_set(string input);
VV_LOCAL_SYMBOL Option_semver__ComparatorSet semver__expand_tilda(string raw_version);
VV_LOCAL_SYMBOL Option_semver__ComparatorSet semver__expand_caret(string raw_version);
VV_LOCAL_SYMBOL Option_semver__ComparatorSet semver__expand_hyphen(string raw_range);
VV_LOCAL_SYMBOL Option_semver__ComparatorSet semver__expand_xrange(string raw_range);
VV_LOCAL_SYMBOL semver__ComparatorSet semver__make_comparator_set_ge_lt(semver__Version min, semver__Version max);
VV_LOCAL_SYMBOL semver__ComparatorSet semver__make_comparator_set_ge_le(semver__Version min, semver__Version max);
Option_semver__Version semver__from(string input);
semver__Version semver__build(int major, int minor, int patch);
semver__Version semver__Version_increment(semver__Version ver, semver__Increment typ);
bool semver__Version_satisfies(semver__Version ver, string input);
bool semver__Version_eq(semver__Version v1, semver__Version v2);
bool semver__Version_gt(semver__Version v1, semver__Version v2);
bool semver__Version_lt(semver__Version v1, semver__Version v2);
bool semver__Version_ge(semver__Version v1, semver__Version v2);
bool semver__Version_le(semver__Version v1, semver__Version v2);
Option_semver__Version semver__coerce(string input);
bool semver__is_valid(string input);
VV_LOCAL_SYMBOL bool semver__is_version_valid(string input);
VV_LOCAL_SYMBOL Option_semver__Version semver__coerce_version(string input);
VV_LOCAL_SYMBOL semver__Version semver__increment_version(semver__Version ver, semver__Increment typ);
VV_LOCAL_SYMBOL bool semver__is_valid_string(string input);
VV_LOCAL_SYMBOL bool semver__is_valid_number(string input);
v__vcache__CacheManager v__vcache__new_cache_manager(Array_string opts);
void v__vcache__CacheManager_set_temporary_options(v__vcache__CacheManager* cm, Array_string new_opts);
string v__vcache__CacheManager_key2cpath(v__vcache__CacheManager* cm, string key);
string v__vcache__CacheManager_postfix_with_key2cpath(v__vcache__CacheManager* cm, string postfix, string key);
Option_string v__vcache__CacheManager_exists(v__vcache__CacheManager* cm, string postfix, string key);
Option_string v__vcache__CacheManager_save(v__vcache__CacheManager* cm, string postfix, string key, string content);
Option_string v__vcache__CacheManager_load(v__vcache__CacheManager* cm, string postfix, string key);
int _const_v__vcache__process_pid; // inited later
void v__vcache__dlog(string fname, string s);
string term__format(string msg, string open, string close);
string term__format_rgb(int r, int g, int b, string msg, string open, string close);
string term__rgb(int r, int g, int b, string msg);
string term__bg_rgb(int r, int g, int b, string msg);
string term__hex(int hex, string msg);
string term__bg_hex(int hex, string msg);
string term__bg_black(string msg);
string term__bright_bg_black(string msg);
string term__bg_blue(string msg);
string term__bright_bg_blue(string msg);
string term__bg_cyan(string msg);
string term__bright_bg_cyan(string msg);
string term__bg_green(string msg);
string term__bright_bg_green(string msg);
string term__bg_magenta(string msg);
string term__bright_bg_magenta(string msg);
string term__bg_red(string msg);
string term__bright_bg_red(string msg);
string term__bg_white(string msg);
string term__bright_bg_white(string msg);
string term__bg_yellow(string msg);
string term__bright_bg_yellow(string msg);
string term__black(string msg);
string term__bright_black(string msg);
string term__blue(string msg);
string term__bright_blue(string msg);
string term__bold(string msg);
string term__cyan(string msg);
string term__bright_cyan(string msg);
string term__dim(string msg);
string term__green(string msg);
string term__bright_green(string msg);
string term__gray(string msg);
string term__hidden(string msg);
string term__italic(string msg);
string term__inverse(string msg);
string term__magenta(string msg);
string term__bright_magenta(string msg);
string term__reset(string msg);
string term__red(string msg);
string term__bright_red(string msg);
string term__strikethrough(string msg);
string term__underline(string msg);
string term__white(string msg);
string term__bright_white(string msg);
string term__yellow(string msg);
string term__bright_yellow(string msg);
void term__set_cursor_position(term__Coord c);
void term__move(int n, string direction);
void term__cursor_up(int n);
void term__cursor_down(int n);
void term__cursor_forward(int n);
void term__cursor_back(int n);
void term__erase_display(string t);
void term__erase_toend();
void term__erase_tobeg();
void term__erase_clear();
void term__erase_del_clear();
void term__erase_line(string t);
void term__erase_line_toend();
void term__erase_line_tobeg();
void term__erase_line_clear();
void term__show_cursor();
void term__hide_cursor();
void term__clear_previous_line();
#define _const_term__default_columns_size 80
#define _const_term__default_rows_size 25
bool term__can_show_color_on_stdout();
bool term__can_show_color_on_stderr();
string term__ok_message(string s);
string term__fail_message(string s);
string term__warn_message(string s);
string term__colorize(string (*cfn)(string ), string s);
string term__h_divider(string divider);
string term__header(string text, string divider);
VV_LOCAL_SYMBOL int term__imax(int x, int y);
VV_LOCAL_SYMBOL bool term__supports_escape_sequences(int fd);
multi_return_int_int term__get_terminal_size();
term__Coord term__get_cursor_position();
bool term__set_terminal_title(string title);
void term__clear();
Option_v__vmod__Manifest v__vmod__from_file(string vmod_path);
Option_v__vmod__Manifest v__vmod__decode(string contents);
VV_LOCAL_SYMBOL void v__vmod__Scanner_tokenize(v__vmod__Scanner* s, v__vmod__TokenKind t_type, string val);
VV_LOCAL_SYMBOL void v__vmod__Scanner_skip_whitespace(v__vmod__Scanner* s);
VV_LOCAL_SYMBOL bool v__vmod__is_name_alpha(byte chr);
VV_LOCAL_SYMBOL string v__vmod__Scanner_create_string(v__vmod__Scanner* s, byte q);
VV_LOCAL_SYMBOL string v__vmod__Scanner_create_ident(v__vmod__Scanner* s);
VV_LOCAL_SYMBOL bool v__vmod__Scanner_peek_char(v__vmod__Scanner s, byte c);
VV_LOCAL_SYMBOL void v__vmod__Scanner_scan_all(v__vmod__Scanner* s);
VV_LOCAL_SYMBOL Option_multi_return_Array_string_int v__vmod__get_array_content(Array_v__vmod__Token tokens, int st_idx);
VV_LOCAL_SYMBOL Option_v__vmod__Manifest v__vmod__Parser_parse(v__vmod__Parser* p);
v__vmod__ModFileCacher* v__vmod__new_mod_file_cacher();
void v__vmod__ModFileCacher_debug(v__vmod__ModFileCacher* mcache);
v__vmod__ModFileAndFolder v__vmod__ModFileCacher_get_by_file(v__vmod__ModFileCacher* mcache, string vfile);
v__vmod__ModFileAndFolder v__vmod__ModFileCacher_get_by_folder(v__vmod__ModFileCacher* mcache, string vfolder);
VV_LOCAL_SYMBOL void v__vmod__ModFileCacher_add(v__vmod__ModFileCacher* cacher, string path, v__vmod__ModFileAndFolder result);
VV_LOCAL_SYMBOL multi_return_Array_string_v__vmod__ModFileAndFolder v__vmod__ModFileCacher_traverse(v__vmod__ModFileCacher* mcache, string mfolder);
VV_LOCAL_SYMBOL void v__vmod__ModFileCacher_mark_folders_with_vmod(v__vmod__ModFileCacher* mcache, Array_string folders_so_far, v__vmod__ModFileAndFolder vmod);
VV_LOCAL_SYMBOL void v__vmod__ModFileCacher_mark_folders_as_vmod_free(v__vmod__ModFileCacher* mcache, Array_string folders_so_far);
Array_string _const_v__vmod__mod_file_stop_paths; // inited later
VV_LOCAL_SYMBOL bool v__vmod__ModFileCacher_check_for_stop(v__vmod__ModFileCacher* mcache, string cfolder, Array_string files);
VV_LOCAL_SYMBOL Array_string v__vmod__ModFileCacher_get_files(v__vmod__ModFileCacher* mcache, string cfolder);
v__vmod__ModFileCacher* _const_v__vmod__private_file_cacher; // inited later
v__vmod__ModFileCacher* v__vmod__get_cache();
string v__util__recompilation__disabling_file(string vroot);
void v__util__recompilation__must_be_enabled(string vroot, string error_message);
string v__cflag__CFlag_str(v__cflag__CFlag* c);
string _const_v__cflag__fexisting_literal; // a string literal, inited later
string v__cflag__CFlag_eval(v__cflag__CFlag* cf);
string v__cflag__CFlag_format(v__cflag__CFlag* cf);
Array_string Array_v__cflag__CFlag_c_options_before_target_msvc(Array_v__cflag__CFlag cflags);
Array_string Array_v__cflag__CFlag_c_options_after_target_msvc(Array_v__cflag__CFlag cflags);
Array_string Array_v__cflag__CFlag_c_options_before_target(Array_v__cflag__CFlag cflags);
Array_string Array_v__cflag__CFlag_c_options_after_target(Array_v__cflag__CFlag cflags);
Array_string Array_v__cflag__CFlag_c_options_without_object_files(Array_v__cflag__CFlag cflags);
Array_string Array_v__cflag__CFlag_c_options_only_object_files(Array_v__cflag__CFlag cflags);
multi_return_Array_string_Array_string_Array_string Array_v__cflag__CFlag_defines_others_libs(Array_v__cflag__CFlag cflags);
VV_LOCAL_SYMBOL u32 rand__seed__nr_next(u32 prev);
Array_u32 rand__seed__time_seed_array(int count);
u32 rand__seed__time_seed_32();
u64 rand__seed__time_seed_64();
VV_LOCAL_SYMBOL Option_string v__pkgconfig__desc(string mod);
Option_v__pkgconfig__Main_ptr v__pkgconfig__main(Array_string args);
Option_string v__pkgconfig__Main_run(v__pkgconfig__Main* m);
VV_LOCAL_SYMBOL string v__pkgconfig__filter(Array_string libs, string prefix, string prefix2);
VV_LOCAL_SYMBOL v__pkgconfig__MainOptions* v__pkgconfig__parse_options(flag__FlagParser* fp);
Array_string _const_v__pkgconfig__default_paths; // inited later
string _const_v__pkgconfig__version; // a string literal, inited later
VV_LOCAL_SYMBOL Array_string v__pkgconfig__PkgConfig_parse_list_no_comma(v__pkgconfig__PkgConfig* pc, string s);
VV_LOCAL_SYMBOL Array_string v__pkgconfig__PkgConfig_parse_list(v__pkgconfig__PkgConfig* pc, string s);
VV_LOCAL_SYMBOL string v__pkgconfig__PkgConfig_parse_line(v__pkgconfig__PkgConfig* pc, string s);
VV_LOCAL_SYMBOL void v__pkgconfig__PkgConfig_setvar(v__pkgconfig__PkgConfig* pc, string line);
VV_LOCAL_SYMBOL bool v__pkgconfig__PkgConfig_parse(v__pkgconfig__PkgConfig* pc, string file);
VV_LOCAL_SYMBOL Option_string v__pkgconfig__PkgConfig_resolve(v__pkgconfig__PkgConfig* pc, string pkgname);
bool v__pkgconfig__atleast(string v);
bool v__pkgconfig__PkgConfig_atleast(v__pkgconfig__PkgConfig* pc, string v);
Option_string v__pkgconfig__PkgConfig_extend(v__pkgconfig__PkgConfig* pc, v__pkgconfig__PkgConfig* pcdep);
VV_LOCAL_SYMBOL Option_void v__pkgconfig__PkgConfig_load_requires(v__pkgconfig__PkgConfig* pc);
VV_LOCAL_SYMBOL Option_void v__pkgconfig__PkgConfig_load_require(v__pkgconfig__PkgConfig* pc, string dep);
VV_LOCAL_SYMBOL void v__pkgconfig__PkgConfig_add_path(v__pkgconfig__PkgConfig* pc, string path);
VV_LOCAL_SYMBOL void v__pkgconfig__PkgConfig_load_paths(v__pkgconfig__PkgConfig* pc);
Option_v__pkgconfig__PkgConfig_ptr v__pkgconfig__load(string pkgname, v__pkgconfig__Options options);
Array_string v__pkgconfig__list();
u64 _const_rand__wyrand__wyp0; // inited later
u64 _const_rand__wyrand__wyp1; // inited later
void rand__wyrand__WyRandRNG_seed(rand__wyrand__WyRandRNG* rng, Array_u32 seed_data);
u32 rand__wyrand__WyRandRNG_u32(rand__wyrand__WyRandRNG* rng);
u64 rand__wyrand__WyRandRNG_u64(rand__wyrand__WyRandRNG* rng);
u32 rand__wyrand__WyRandRNG_u32n(rand__wyrand__WyRandRNG* rng, u32 max);
u64 rand__wyrand__WyRandRNG_u64n(rand__wyrand__WyRandRNG* rng, u64 max);
u32 rand__wyrand__WyRandRNG_u32_in_range(rand__wyrand__WyRandRNG* rng, u32 min, u32 max);
u64 rand__wyrand__WyRandRNG_u64_in_range(rand__wyrand__WyRandRNG* rng, u64 min, u64 max);
int rand__wyrand__WyRandRNG_int(rand__wyrand__WyRandRNG* rng);
i64 rand__wyrand__WyRandRNG_i64(rand__wyrand__WyRandRNG* rng);
int rand__wyrand__WyRandRNG_int31(rand__wyrand__WyRandRNG* rng);
i64 rand__wyrand__WyRandRNG_int63(rand__wyrand__WyRandRNG* rng);
int rand__wyrand__WyRandRNG_intn(rand__wyrand__WyRandRNG* rng, int max);
i64 rand__wyrand__WyRandRNG_i64n(rand__wyrand__WyRandRNG* rng, i64 max);
int rand__wyrand__WyRandRNG_int_in_range(rand__wyrand__WyRandRNG* rng, int min, int max);
i64 rand__wyrand__WyRandRNG_i64_in_range(rand__wyrand__WyRandRNG* rng, i64 min, i64 max);
f32 rand__wyrand__WyRandRNG_f32(rand__wyrand__WyRandRNG* rng);
f64 rand__wyrand__WyRandRNG_f64(rand__wyrand__WyRandRNG* rng);
f32 rand__wyrand__WyRandRNG_f32n(rand__wyrand__WyRandRNG* rng, f32 max);
f64 rand__wyrand__WyRandRNG_f64n(rand__wyrand__WyRandRNG* rng, f64 max);
f32 rand__wyrand__WyRandRNG_f32_in_range(rand__wyrand__WyRandRNG* rng, f32 min, f32 max);
f64 rand__wyrand__WyRandRNG_f64_in_range(rand__wyrand__WyRandRNG* rng, f64 min, f64 max);
rand__PRNG* default_rng; // global
VV_LOCAL_SYMBOL void rand__init();
rand__PRNG* rand__new_default(rand__PRNGConfigStruct config);
rand__PRNG* rand__get_current_rng();
void rand__set_rng(rand__PRNG* rng);
void rand__seed(Array_u32 seed);
u32 rand__u32();
u64 rand__u64();
u32 rand__u32n(u32 max);
u64 rand__u64n(u64 max);
u32 rand__u32_in_range(u32 min, u32 max);
u64 rand__u64_in_range(u64 min, u64 max);
int rand__int();
int rand__intn(int max);
byte rand__byte();
int rand__int_in_range(int min, int max);
int rand__int31();
i64 rand__i64();
i64 rand__i64n(i64 max);
i64 rand__i64_in_range(i64 min, i64 max);
i64 rand__int63();
f32 rand__f32();
f64 rand__f64();
f32 rand__f32n(f32 max);
f64 rand__f64n(f64 max);
f32 rand__f32_in_range(f32 min, f32 max);
f64 rand__f64_in_range(f64 min, f64 max);
string _const_rand__english_letters; // a string literal, inited later
string _const_rand__hex_chars; // a string literal, inited later
string _const_rand__ascii_chars; // a string literal, inited later
string rand__string_from_set(string charset, int len);
string rand__string(int len);
string rand__hex(int len);
string rand__ascii(int len);
string rand__uuid_v4();
string _const_rand__ulid_encoding; // a string literal, inited later
string rand__ulid();
string rand__ulid_at_millisecond(u64 unix_time_milli);
string _const_v__pref__default_module_path; // inited later
v__pref__Preferences* v__pref__new_preferences();
VV_LOCAL_SYMBOL void v__pref__Preferences_expand_lookup_paths(v__pref__Preferences* p);
void v__pref__Preferences_fill_with_defaults(v__pref__Preferences* p);
VV_LOCAL_SYMBOL void v__pref__Preferences_find_cc_if_cross_compiling(v__pref__Preferences* p);
VV_LOCAL_SYMBOL void v__pref__Preferences_try_to_use_tcc_by_default(v__pref__Preferences* p);
string v__pref__default_tcc_compiler();
string v__pref__default_c_compiler();
string v__pref__vexe_path();
Option_v__pref__OS v__pref__os_from_string(string os_str);
string v__pref__OS_str(v__pref__OS o);
v__pref__OS v__pref__get_host_os();
Array_string _const_v__pref__list_of_flags_with_param; // inited later
multi_return_v__pref__Preferences_string v__pref__parse_args(Array_string known_external_commands, Array_string args);
void v__pref__Preferences_vrun_elog(v__pref__Preferences* pref, string s);
Option_v__pref__Arch v__pref__arch_from_string(string arch_str);
VV_LOCAL_SYMBOL void v__pref__must_exist(string path);
VV_LOCAL_SYMBOL bool v__pref__is_source_file(string path);
Option_v__pref__Backend v__pref__backend_from_string(string s);
v__pref__CompilerType v__pref__cc_from_string(string cc_str);
v__pref__Arch v__pref__get_host_arch();
VV_LOCAL_SYMBOL void v__pref__parse_define(v__pref__Preferences* prefs, string define);
Array_string v__pref__Preferences_should_compile_filtered_files(v__pref__Preferences* prefs, string dir, Array_string files_);
VV_LOCAL_SYMBOL string v__pref__fname_without_platform_postfix(string file);
bool v__pref__Preferences_should_compile_c(v__pref__Preferences* prefs, string file);
bool v__pref__Preferences_should_compile_asm(v__pref__Preferences* prefs, string path);
bool v__pref__Preferences_should_compile_js(v__pref__Preferences* prefs, string file);
string _const_help__unknown_topic; // a string literal, inited later
void help__print_and_exit(string topic);
Option_string v__util__find_working_diff_command();
VV_LOCAL_SYMBOL bool v__util__opendiff_exists();
string v__util__color_compare_files(string diff_cmd, string file1, string file2);
string v__util__color_compare_strings(string diff_cmd, string unique_prefix, string expected, string found);
#define _const_v__util__error_context_before 2
#define _const_v__util__error_context_after 2
v__util__EManager* _const_v__util__emanager; // inited later
v__util__EManager* v__util__new_error_manager();
void v__util__EManager_set_support_color(v__util__EManager* e, bool b);
string v__util__bold(string msg);
VV_LOCAL_SYMBOL string v__util__color(string kind, string msg);
string v__util__formatted_error(string kind, string omsg, string filepath, v__token__Position pos);
Array_string v__util__source_context(string kind, string source, v__token__Position pos);
void v__util__verror(string kind, string s);
string v__util__vlines_escape_path(string path, string ccompiler);
VV_LOCAL_SYMBOL void v__util__trace_mod_path_to_full_name(string line, string mod, string file_path, string res);
string v__util__qualify_import(v__pref__Preferences* pref, string mod, string file_path);
string v__util__qualify_module(string mod, string file_path);
Option_string v__util__mod_path_to_full_name(string mod, string path);
Array_string _const_v__util__invalid_escapes; // inited later
string v__util__smart_quote(string str, bool raw);
bool v__util__is_name_char(byte c);
bool v__util__is_func_char(byte c);
bool v__util__is_nl(byte c);
bool v__util__contains_capital(string s);
bool v__util__good_type_name(string s);
bool v__util__is_generic_type_name(string name);
string v__util__cescaped_path(string s);
v__util__Suggestion v__util__new_suggestion(string wanted, Array_string possibilities);
void v__util__Suggestion_add(v__util__Suggestion* s, string val);
void v__util__Suggestion_add_many(v__util__Suggestion* s, Array_string many);
void v__util__Suggestion_sort(v__util__Suggestion* s);
int compare__t972_v__util__Possibility (v__util__Possibility* a, v__util__Possibility* b) {
f32 a_ = 	a->similarity;
f32 b_ = b->similarity;
if (a_ < b_) return -1;
if (a_ > b_) return 1; return 0; }

string v__util__Suggestion_say(v__util__Suggestion s, string msg);
string v__util__short_module_name(string name);
v__util__Timers* v__util__new_timers(bool should_print);
v__util__Timers* _const_v__util__timers; // inited later
v__util__Timers* v__util__get_timers();
void v__util__timing_start(string label);
void v__util__timing_measure(string label);
void v__util__timing_measure_cumulative(string label);
void v__util__timing_set_should_print(bool should_print);
void v__util__Timers_start(v__util__Timers* t, string name);
i64 v__util__Timers_measure(v__util__Timers* t, string name);
i64 v__util__Timers_measure_cumulative(v__util__Timers* t, string name);
void v__util__Timers_measure_pause(v__util__Timers* t, string name);
void v__util__Timers_measure_resume(v__util__Timers* t, string name);
string v__util__Timers_message(v__util__Timers* t, string name);
void v__util__Timers_show(v__util__Timers* t, string label);
void v__util__Timers_show_if_exists(v__util__Timers* t, string label);
void v__util__Timers_dump_all(v__util__Timers* t);
string _const_v__util__v_version; // a string literal, inited later
Array_string _const_v__util__builtin_module_parts; // inited later
Array_string _const_v__util__bundle_modules; // inited later
Map_string_Array_string _const_v__util__external_module_dependencies_for_tool; // inited later
Array_string _const_v__util__const_tabs; // inited later
string v__util__tabs(int n);
string v__util__vhash();
string v__util__full_hash();
string v__util__full_v_version(bool is_verbose);
string v__util__githash(bool should_get_from_filesystem);
void v__util__set_vroot_folder(string vroot_path);
Option_string v__util__resolve_vroot(string str, string dir);
Option_string v__util__resolve_env_value(string str, bool check_for_presence);
void v__util__launch_tool(bool is_verbose, string tool_name, Array_string args);
bool v__util__should_recompile_tool(string vexe, string tool_source, string tool_name, string tool_exe);
VV_LOCAL_SYMBOL multi_return_string_string v__util__tool_source2name_and_exe(string tool_source);
string v__util__quote_path(string s);
string v__util__args_quote_paths(Array_string args);
string v__util__path_of_executable(string path);
Option_string v__util__read_file(string file_path);
string v__util__skip_bom(string file_content);
string v__util__replace_op(string s);
Array_string v__util__join_env_vflags_and_os_args();
VV_LOCAL_SYMBOL Array_string v__util__non_empty(Array_string arg);
Option_bool v__util__check_module_is_installed(string modulename, bool is_verbose);
void v__util__ensure_modules_for_all_tools_are_installed(bool is_verbose);
string v__util__strip_mod_name(string name);
string v__util__strip_main_name(string name);
string v__util__no_dots(string s);
string _const_v__util__map_prefix; // a string literal, inited later
string v__util__no_cur_mod(string v_typename, string cur_mod);
void v__util__prepare_tool_when_needed(string source_name);
void v__util__recompile_file(string vexe, string file);
string v__util__get_vtmp_folder();
bool v__util__should_bundle_module(string mod);
Option_Array_string v__util__find_all_v_files(Array_string roots);
v__ast__Expr v__ast__empty_expr();
v__ast__Stmt v__ast__empty_stmt();
v__ast__Node v__ast__empty_node();
Option_v__ast__Ident v__ast__SelectorExpr_root_ident(v__ast__SelectorExpr* e);
v__ast__IdentVar v__ast__Ident_var_info(v__ast__Ident* i);
Map_int_Array_string _const_v__ast__x86_no_number_register_list; // inited later
Map_int_Map_string_int _const_v__ast__x86_with_number_register_list; // inited later
Array_string _const_v__ast__arm_no_number_register_list; // inited later
Map_string_int _const_v__ast__arm_with_number_register_list; // inited later
Array_string _const_v__ast__riscv_no_number_register_list; // inited later
Map_string_int _const_v__ast__riscv_with_number_register_list; // inited later
bool v__ast__Expr_is_blank_ident(v__ast__Expr expr);
v__token__Position v__ast__Expr_position(v__ast__Expr expr);
bool v__ast__Expr_is_lvalue(v__ast__Expr expr);
bool v__ast__Expr_is_expr(v__ast__Expr expr);
bool v__ast__Expr_is_lit(v__ast__Expr expr);
bool v__ast__Expr_is_auto_deref_var(v__ast__Expr expr);
Option_void v__ast__Stmt_check_c_expr(v__ast__Stmt stmt);
v__token__Position v__ast__Node_position(v__ast__Node node);
Array_v__ast__Node v__ast__Node_children(v__ast__Node node);
void v__ast__IndexExpr_recursive_mapset_is_setter(v__ast__IndexExpr* lx, bool val);
Map_string_v__ast__ScopeObject v__ast__all_registers(v__ast__Table* t, v__pref__Arch arch);
VV_LOCAL_SYMBOL Map_string_v__ast__ScopeObject v__ast__gen_all_registers(v__ast__Table* t, Array_string without_numbers, Map_string_int with_numbers, int bit_size);
string v__ast__Attr_str(v__ast__Attr attr);
bool Array_v__ast__Attr_contains(Array_v__ast__Attr attrs, string str);
multi_return_bool_string Array_v__ast__Attr_has_comptime_define(Array_v__ast__Attr attrs);
VV_LOCAL_SYMBOL bool v__ast__Table_has_cflag(v__ast__Table* t, v__cflag__CFlag flag);
Option_bool v__ast__Table_parse_cflag(v__ast__Table* t, string cflg, string mod, Array_string ctimedefines);
v__ast__Expr v__ast__resolve_init(v__ast__StructInit node, v__ast__Type typ, v__ast__Table* t);
v__ast__Scope* v__ast__new_scope(v__ast__Scope* parent, int start_pos);
VV_LOCAL_SYMBOL bool v__ast__Scope_dont_lookup_parent(v__ast__Scope* s);
Option_multi_return_v__ast__ScopeObject_v__ast__Scope v__ast__Scope_find_with_scope(v__ast__Scope* s, string name);
Option_v__ast__ScopeObject v__ast__Scope_find(v__ast__Scope* s, string name);
Option_v__ast__ScopeStructField v__ast__Scope_find_struct_field(v__ast__Scope* s, v__ast__Type struct_type, string field_name);
bool v__ast__Scope_is_known(v__ast__Scope* s, string name);
Option_v__ast__Var_ptr v__ast__Scope_find_var(v__ast__Scope* s, string name);
Option_v__ast__ConstField_ptr v__ast__Scope_find_const(v__ast__Scope* s, string name);
bool v__ast__Scope_known_var(v__ast__Scope* s, string name);
void v__ast__Scope_update_var_type(v__ast__Scope* s, string name, v__ast__Type typ);
void v__ast__Scope_register_struct_field(v__ast__Scope* s, v__ast__ScopeStructField field);
void v__ast__Scope_register(v__ast__Scope* s, v__ast__ScopeObject obj);
v__ast__Scope* v__ast__Scope_outermost(v__ast__Scope* s);
v__ast__Scope* v__ast__Scope_innermost(v__ast__Scope* s, int pos);
VV_LOCAL_SYMBOL bool v__ast__Scope_contains(v__ast__Scope* s, int pos);
string v__ast__Scope_show(v__ast__Scope sc, int depth, int max_depth);
string v__ast__Scope_str(v__ast__Scope sc);
string v__ast__FnDecl_modname(v__ast__FnDecl* node);
string v__ast__FnDecl_stringify(v__ast__FnDecl* node, v__ast__Table* t, string cur_mod, Map_string_string m2a);
multi_return_string_bool v__ast__StringInterLiteral_get_fspec_braces(v__ast__StringInterLiteral* lit, int i);
string v__ast__Expr_str(v__ast__Expr x);
string v__ast__CallArg_str(v__ast__CallArg a);
string v__ast__args2str(Array_v__ast__CallArg args);
string v__ast__BranchStmt_str(v__ast__BranchStmt* node);
string v__ast__Stmt_str(v__ast__Stmt node);
VV_LOCAL_SYMBOL string v__ast__field_to_string(v__ast__ConstField f);
string v__ast__CompForKind_str(v__ast__CompForKind e);
VV_LOCAL_SYMBOL bool v__ast__Fn_method_equals(v__ast__Fn* f, v__ast__Fn* o);
VV_LOCAL_SYMBOL bool v__ast__Param_equals(v__ast__Param* p, v__ast__Param* o);
VV_LOCAL_SYMBOL bool Array_v__ast__Param_equals(Array_v__ast__Param p, Array_v__ast__Param o);
v__ast__Table* v__ast__new_table();
string v__ast__Table_fn_type_signature(v__ast__Table* t, v__ast__Fn* f);
string v__ast__Table_fn_type_source_signature(v__ast__Table* t, v__ast__Fn* f);
string v__ast__Table_is_same_method(v__ast__Table* t, v__ast__Fn* f, v__ast__Fn* func);
Option_v__ast__Fn v__ast__Table_find_fn(v__ast__Table* t, string name);
bool v__ast__Table_known_fn(v__ast__Table* t, string name);
void v__ast__Table_register_fn(v__ast__Table* t, v__ast__Fn new_fn);
int v__ast__TypeSymbol_register_method(v__ast__TypeSymbol* t, v__ast__Fn new_fn);
Option_v__ast__Fn v__ast__Table_register_aggregate_method(v__ast__Table* t, v__ast__TypeSymbol* sym, string name);
bool v__ast__Table_type_has_method(v__ast__Table* t, v__ast__TypeSymbol* s, string name);
Option_v__ast__Fn v__ast__Table_type_find_method(v__ast__Table* t, v__ast__TypeSymbol* s, string name);
VV_LOCAL_SYMBOL Option_v__ast__StructField v__ast__Table_register_aggregate_field(v__ast__Table* t, v__ast__TypeSymbol* sym, string name);
bool v__ast__Table_struct_has_field(v__ast__Table* t, v__ast__TypeSymbol* s, string name);
Option_v__ast__StructField v__ast__Table_find_field(v__ast__Table* t, v__ast__TypeSymbol* s, string name);
Option_v__ast__StructField v__ast__Table_find_field_with_embeds(v__ast__Table* t, v__ast__TypeSymbol* sym, string field_name);
void v__ast__Table_resolve_common_sumtype_fields(v__ast__Table* t, v__ast__TypeSymbol* sym_);
int v__ast__Table_find_type_idx(v__ast__Table* t, string name);
Option_v__ast__TypeSymbol v__ast__Table_find_type(v__ast__Table* t, string name);
v__ast__TypeSymbol* v__ast__Table_get_type_symbol(v__ast__Table* t, v__ast__Type typ);
v__ast__TypeSymbol* v__ast__Table_get_final_type_symbol(v__ast__Table* t, v__ast__Type typ);
string v__ast__Table_get_type_name(v__ast__Table* t, v__ast__Type typ);
v__ast__Type v__ast__Table_unalias_num_type(v__ast__Table* t, v__ast__Type typ);
int v__ast__Table_register_type_symbol(v__ast__Table* t, v__ast__TypeSymbol typ);
bool v__ast__Table_known_type(v__ast__Table* t, string name);
bool v__ast__Table_known_type_idx(v__ast__Table* t, v__ast__Type typ);
string v__ast__Table_array_name(v__ast__Table* t, v__ast__Type elem_type);
string v__ast__Table_array_cname(v__ast__Table* t, v__ast__Type elem_type);
string v__ast__Table_array_fixed_name(v__ast__Table* t, v__ast__Type elem_type, int size);
string v__ast__Table_array_fixed_cname(v__ast__Table* t, v__ast__Type elem_type, int size);
string v__ast__Table_chan_name(v__ast__Table* t, v__ast__Type elem_type, bool is_mut);
string v__ast__Table_chan_cname(v__ast__Table* t, v__ast__Type elem_type, bool is_mut);
string v__ast__Table_thread_name(v__ast__Table* t, v__ast__Type return_type);
string v__ast__Table_thread_cname(v__ast__Table* t, v__ast__Type return_type);
string v__ast__Table_map_name(v__ast__Table* t, v__ast__Type key_type, v__ast__Type value_type);
string v__ast__Table_map_cname(v__ast__Table* t, v__ast__Type key_type, v__ast__Type value_type);
int v__ast__Table_find_or_register_chan(v__ast__Table* t, v__ast__Type elem_type, bool is_mut);
int v__ast__Table_find_or_register_map(v__ast__Table* t, v__ast__Type key_type, v__ast__Type value_type);
int v__ast__Table_find_or_register_thread(v__ast__Table* t, v__ast__Type return_type);
int v__ast__Table_find_or_register_array(v__ast__Table* t, v__ast__Type elem_type);
int v__ast__Table_find_or_register_array_with_dims(v__ast__Table* t, v__ast__Type elem_type, int nr_dims);
int v__ast__Table_find_or_register_array_fixed(v__ast__Table* t, v__ast__Type elem_type, int size);
int v__ast__Table_find_or_register_multi_return(v__ast__Table* t, Array_v__ast__Type mr_typs);
int v__ast__Table_find_or_register_fn_type(v__ast__Table* t, string mod, v__ast__Fn f, bool is_anon, bool has_decl);
int v__ast__Table_add_placeholder_type(v__ast__Table* t, string name, v__ast__Language language);
v__ast__Type v__ast__Table_value_type(v__ast__Table* t, v__ast__Type typ);
v__ast__Type v__ast__Table_mktyp(v__ast__Table* t, v__ast__Type typ);
void v__ast__Table_register_fn_gen_type(v__ast__Table* t, string fn_name, Array_v__ast__Type types);
bool v__ast__Table_sumtype_has_variant(v__ast__Table* t, v__ast__Type parent, v__ast__Type variant);
Array_string v__ast__Table_known_type_names(v__ast__Table* t);
bool v__ast__Table_has_deep_child_no_ref(v__ast__Table* t, v__ast__TypeSymbol* ts, string name);
v__ast__Type v__ast__Table_bitsize_to_type(v__ast__Table* t, int bit_size);
Option_v__ast__Type v__ast__Table_resolve_generic_by_names(v__ast__Table* t, v__ast__Type generic_type, Array_string generic_names, Array_v__ast__Type generic_types);
Option_v__ast__Type v__ast__Table_resolve_generic_by_types(v__ast__Table* t, v__ast__Type generic_type, Array_v__ast__Type from_types, Array_v__ast__Type to_types);
void v__ast__Table_generic_struct_insts_to_concrete(v__ast__Table* t);
v__ast__Language v__ast__pref_arch_to_table_language(v__pref__Arch pref_arch);
string v__ast__ShareType_str(v__ast__ShareType t);
string v__ast__Type_atomic_typename(v__ast__Type t);
v__ast__ShareType v__ast__sharetype_from_flags(bool is_shared, bool is_atomic);
v__ast__ShareType v__ast__Type_share(v__ast__Type t);
int v__ast__Type_idx(v__ast__Type t);
bool v__ast__Type_is_void(v__ast__Type t);
bool v__ast__Type_is_full(v__ast__Type t);
int v__ast__Type_nr_muls(v__ast__Type t);
bool v__ast__Type_is_ptr(v__ast__Type t);
v__ast__Type v__ast__Type_set_nr_muls(v__ast__Type t, int nr_muls);
v__ast__Type v__ast__Type_to_ptr(v__ast__Type t);
v__ast__Type v__ast__Type_deref(v__ast__Type t);
v__ast__Type v__ast__Type_set_flag(v__ast__Type t, v__ast__TypeFlag flag);
v__ast__Type v__ast__Type_clear_flag(v__ast__Type t, v__ast__TypeFlag flag);
v__ast__Type v__ast__Type_clear_flags(v__ast__Type t);
bool v__ast__Type_has_flag(v__ast__Type t, v__ast__TypeFlag flag);
Array_string v__ast__TypeSymbol_debug(v__ast__TypeSymbol* ts);
Array_string v__ast__Type_debug(v__ast__Type t);
v__ast__Type v__ast__Type_derive(v__ast__Type t, v__ast__Type t_from);
v__ast__Type v__ast__new_type(int idx);
v__ast__Type v__ast__new_type_ptr(int idx, int nr_muls);
bool v__ast__Type_is_pointer(v__ast__Type typ);
bool v__ast__Type_is_float(v__ast__Type typ);
bool v__ast__Type_is_int(v__ast__Type typ);
bool v__ast__Type_is_int_valptr(v__ast__Type typ);
bool v__ast__Type_is_float_valptr(v__ast__Type typ);
bool v__ast__Type_is_pure_int(v__ast__Type typ);
bool v__ast__Type_is_pure_float(v__ast__Type typ);
bool v__ast__Type_is_signed(v__ast__Type typ);
bool v__ast__Type_is_unsigned(v__ast__Type typ);
bool v__ast__Type_is_int_literal(v__ast__Type typ);
bool v__ast__Type_is_number(v__ast__Type typ);
bool v__ast__Type_is_number_or_literal(v__ast__Type typ);
bool v__ast__Type_is_string(v__ast__Type typ);
#define _const_v__ast__void_type_idx 1
#define _const_v__ast__voidptr_type_idx 2
#define _const_v__ast__byteptr_type_idx 3
#define _const_v__ast__charptr_type_idx 4
#define _const_v__ast__i8_type_idx 5
#define _const_v__ast__i16_type_idx 6
#define _const_v__ast__int_type_idx 7
#define _const_v__ast__i64_type_idx 8
#define _const_v__ast__byte_type_idx 9
#define _const_v__ast__u16_type_idx 10
#define _const_v__ast__u32_type_idx 11
#define _const_v__ast__u64_type_idx 12
#define _const_v__ast__f32_type_idx 13
#define _const_v__ast__f64_type_idx 14
#define _const_v__ast__char_type_idx 15
#define _const_v__ast__bool_type_idx 16
#define _const_v__ast__none_type_idx 17
#define _const_v__ast__string_type_idx 18
#define _const_v__ast__ustring_type_idx 19
#define _const_v__ast__rune_type_idx 20
#define _const_v__ast__array_type_idx 21
#define _const_v__ast__map_type_idx 22
#define _const_v__ast__chan_type_idx 23
#define _const_v__ast__size_t_type_idx 24
#define _const_v__ast__any_type_idx 25
#define _const_v__ast__float_literal_type_idx 26
#define _const_v__ast__int_literal_type_idx 27
#define _const_v__ast__thread_type_idx 28
#define _const_v__ast__error_type_idx 29
Array_int _const_v__ast__integer_type_idxs; // inited later
Array_int _const_v__ast__signed_integer_type_idxs; // inited later
Array_int _const_v__ast__unsigned_integer_type_idxs; // inited later
Array_int _const_v__ast__float_type_idxs; // inited later
Array_int _const_v__ast__number_type_idxs; // inited later
Array_int _const_v__ast__pointer_type_idxs; // inited later
Array_int _const_v__ast__string_type_idxs; // inited later
v__ast__Type _const_v__ast__void_type; // inited later
v__ast__Type _const_v__ast__ovoid_type; // inited later
v__ast__Type _const_v__ast__voidptr_type; // inited later
v__ast__Type _const_v__ast__byteptr_type; // inited later
v__ast__Type _const_v__ast__charptr_type; // inited later
v__ast__Type _const_v__ast__i8_type; // inited later
v__ast__Type _const_v__ast__int_type; // inited later
v__ast__Type _const_v__ast__i16_type; // inited later
v__ast__Type _const_v__ast__i64_type; // inited later
v__ast__Type _const_v__ast__byte_type; // inited later
v__ast__Type _const_v__ast__u16_type; // inited later
v__ast__Type _const_v__ast__u32_type; // inited later
v__ast__Type _const_v__ast__u64_type; // inited later
v__ast__Type _const_v__ast__f32_type; // inited later
v__ast__Type _const_v__ast__f64_type; // inited later
v__ast__Type _const_v__ast__char_type; // inited later
v__ast__Type _const_v__ast__bool_type; // inited later
v__ast__Type _const_v__ast__none_type; // inited later
v__ast__Type _const_v__ast__string_type; // inited later
v__ast__Type _const_v__ast__ustring_type; // inited later
v__ast__Type _const_v__ast__rune_type; // inited later
v__ast__Type _const_v__ast__array_type; // inited later
v__ast__Type _const_v__ast__map_type; // inited later
v__ast__Type _const_v__ast__chan_type; // inited later
v__ast__Type _const_v__ast__any_type; // inited later
v__ast__Type _const_v__ast__float_literal_type; // inited later
v__ast__Type _const_v__ast__int_literal_type; // inited later
v__ast__Type _const_v__ast__thread_type; // inited later
v__ast__Type _const_v__ast__error_type; // inited later
Array_string _const_v__ast__builtin_type_names; // inited later
v__ast__Kind v__ast__Table_type_kind(v__ast__Table* t, v__ast__Type typ);
string v__ast__TypeSymbol_str(v__ast__TypeSymbol* t);
v__ast__Enum v__ast__TypeSymbol_enum_info(v__ast__TypeSymbol* t);
v__ast__MultiReturn v__ast__TypeSymbol_mr_info(v__ast__TypeSymbol* t);
v__ast__Array v__ast__TypeSymbol_array_info(v__ast__TypeSymbol* t);
v__ast__ArrayFixed v__ast__TypeSymbol_array_fixed_info(v__ast__TypeSymbol* t);
v__ast__Chan v__ast__TypeSymbol_chan_info(v__ast__TypeSymbol* t);
v__ast__Thread v__ast__TypeSymbol_thread_info(v__ast__TypeSymbol* t);
v__ast__Map v__ast__TypeSymbol_map_info(v__ast__TypeSymbol* t);
v__ast__Struct v__ast__TypeSymbol_struct_info(v__ast__TypeSymbol* t);
v__ast__SumType v__ast__TypeSymbol_sumtype_info(v__ast__TypeSymbol* t);
void v__ast__Table_register_builtin_type_symbols(v__ast__Table* t);
bool v__ast__TypeSymbol_is_pointer(v__ast__TypeSymbol* t);
bool v__ast__TypeSymbol_is_int(v__ast__TypeSymbol* t);
bool v__ast__TypeSymbol_is_float(v__ast__TypeSymbol* t);
bool v__ast__TypeSymbol_is_string(v__ast__TypeSymbol* t);
bool v__ast__TypeSymbol_is_number(v__ast__TypeSymbol* t);
bool v__ast__TypeSymbol_is_primitive(v__ast__TypeSymbol* t);
bool v__ast__TypeSymbol_is_builtin(v__ast__TypeSymbol* t);
string v__ast__Kind_str(v__ast__Kind k);
string Array_v__ast__Kind_str(Array_v__ast__Kind kinds);
bool v__ast__StructField_equals(v__ast__StructField* f, v__ast__StructField* o);
string v__ast__Table_type_to_str(v__ast__Table* t, v__ast__Type typ);
string v__ast__Table_type_to_code(v__ast__Table* mytable, v__ast__Type t);
string v__ast__Table_type_to_str_using_aliases(v__ast__Table* t, v__ast__Type typ, Map_string_string import_aliases);
VV_LOCAL_SYMBOL string v__ast__Table_shorten_user_defined_typenames(v__ast__Table* t, string originalname, Map_string_string import_aliases);
string v__ast__Table_fn_signature(v__ast__Table* t, v__ast__Fn* func, v__ast__FnSignatureOpts opts);
string v__ast__TypeSymbol_embed_name(v__ast__TypeSymbol* t);
bool v__ast__TypeSymbol_has_method(v__ast__TypeSymbol* t, string name);
Option_v__ast__Fn v__ast__TypeSymbol_find_method(v__ast__TypeSymbol* t, string name);
multi_return_bool_bool_int v__ast__TypeSymbol_str_method_info(v__ast__TypeSymbol* t);
Option_v__ast__StructField v__ast__TypeSymbol_find_field(v__ast__TypeSymbol* t, string name);
VV_LOCAL_SYMBOL Option_v__ast__StructField v__ast__Aggregate_find_field(v__ast__Aggregate* a, string name);
Option_v__ast__StructField v__ast__Interface_find_field(v__ast__Interface* i, string name);
Option_v__ast__Fn v__ast__Interface_find_method(v__ast__Interface* i, string name);
bool v__ast__Interface_has_method(v__ast__Interface* i, string name);
Option_v__ast__StructField v__ast__Struct_find_field(v__ast__Struct* s, string name);
v__ast__StructField v__ast__Struct_get_field(v__ast__Struct* s, string name);
Option_v__ast__StructField v__ast__SumType_find_field(v__ast__SumType* s, string name);
bool v__ast__Interface_defines_method(v__ast__Interface i, string name);
#define _const_v__scanner__single_quote L'\''
#define _const_v__scanner__double_quote L'"'
#define _const_v__scanner__num_sep L'_'
v__scanner__Scanner* v__scanner__new_scanner_file(string file_path, v__scanner__CommentsMode comments_mode, v__pref__Preferences* pref);
v__scanner__Scanner* v__scanner__new_scanner(string text, v__scanner__CommentsMode comments_mode, v__pref__Preferences* pref);
VV_LOCAL_SYMBOL void v__scanner__Scanner_init_scanner(v__scanner__Scanner* s);
void v__scanner__Scanner_free(v__scanner__Scanner* s);
VV_LOCAL_SYMBOL bool v__scanner__Scanner_should_parse_comment(v__scanner__Scanner* s);
void v__scanner__Scanner_set_is_inside_toplevel_statement(v__scanner__Scanner* s, bool newstate);
void v__scanner__Scanner_set_current_tidx(v__scanner__Scanner* s, int cidx);
VV_LOCAL_SYMBOL v__token__Token v__scanner__Scanner_new_token(v__scanner__Scanner* s, v__token__Kind tok_kind, string lit, int len);
VV_LOCAL_SYMBOL v__token__Token v__scanner__Scanner_new_eof_token(v__scanner__Scanner* s);
VV_LOCAL_SYMBOL v__token__Token v__scanner__Scanner_new_multiline_token(v__scanner__Scanner* s, v__token__Kind tok_kind, string lit, int len, int start_line);
VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_name(v__scanner__Scanner* s);
VV_LOCAL_SYMBOL string v__scanner__Scanner_num_lit(v__scanner__Scanner* s, int start, int end);
VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_bin_number(v__scanner__Scanner* s);
VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_hex_number(v__scanner__Scanner* s);
VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_oct_number(v__scanner__Scanner* s);
VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_dec_number(v__scanner__Scanner* s);
VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_number(v__scanner__Scanner* s);
VV_LOCAL_SYMBOL void v__scanner__Scanner_skip_whitespace(v__scanner__Scanner* s);
VV_LOCAL_SYMBOL v__token__Token v__scanner__Scanner_end_of_file(v__scanner__Scanner* s);
void v__scanner__Scanner_scan_all_tokens_in_buffer(v__scanner__Scanner* s, v__scanner__CommentsMode mode);
void v__scanner__Scanner_scan_remaining_text(v__scanner__Scanner* s);
v__token__Token v__scanner__Scanner_scan(v__scanner__Scanner* s);
v__token__Token v__scanner__Scanner_buffer_scan(v__scanner__Scanner* s);
v__token__Token v__scanner__Scanner_peek_token(v__scanner__Scanner* s, int n);
VV_LOCAL_SYMBOL byte v__scanner__Scanner_look_ahead(v__scanner__Scanner* s, int n);
VV_LOCAL_SYMBOL v__token__Token v__scanner__Scanner_text_scan(v__scanner__Scanner* s);
VV_LOCAL_SYMBOL void v__scanner__Scanner_invalid_character(v__scanner__Scanner* s);
VV_LOCAL_SYMBOL int v__scanner__Scanner_current_column(v__scanner__Scanner* s);
VV_LOCAL_SYMBOL int v__scanner__Scanner_count_symbol_before(v__scanner__Scanner* s, int p, byte sym);
VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_string(v__scanner__Scanner* s);
VV_LOCAL_SYMBOL string v__scanner__decode_u_escapes(string s, int start, Array_int escapes_pos);
VV_LOCAL_SYMBOL string v__scanner__trim_slash_line_break(string s);
VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_char(v__scanner__Scanner* s);
VV_LOCAL_SYMBOL bool v__scanner__Scanner_expect(v__scanner__Scanner* s, string want, int start_pos);
VV_LOCAL_SYMBOL void v__scanner__Scanner_ignore_line(v__scanner__Scanner* s);
VV_LOCAL_SYMBOL void v__scanner__Scanner_eat_to_end_of_line(v__scanner__Scanner* s);
VV_LOCAL_SYMBOL void v__scanner__Scanner_inc_line_number(v__scanner__Scanner* s);
void v__scanner__Scanner_note(v__scanner__Scanner* s, string msg);
void v__scanner__Scanner_warn(v__scanner__Scanner* s, string msg);
void v__scanner__Scanner_error(v__scanner__Scanner* s, string msg);
VV_LOCAL_SYMBOL void v__scanner__Scanner_vet_error(v__scanner__Scanner* s, string msg, v__vet__FixKind fix);
void v__scanner__verror(string s);
void v__scanner__Scanner_codegen(v__scanner__Scanner* s, string newtext);
VV_LOCAL_SYMBOL void v__scanner__Scanner_trace(v__scanner__Scanner* s, string fbase, string message);
Option_void v__checker__Checker_check_expected_call_arg(v__checker__Checker* c, v__ast__Type got, v__ast__Type expected_, v__ast__Language language);
bool v__checker__Checker_check_basic(v__checker__Checker* c, v__ast__Type got, v__ast__Type expected);
bool v__checker__Checker_check_matching_function_symbols(v__checker__Checker* c, v__ast__TypeSymbol* got_type_sym, v__ast__TypeSymbol* exp_type_sym);
VV_LOCAL_SYMBOL v__ast__Type v__checker__Checker_check_shift(v__checker__Checker* c, v__ast__Type left_type, v__ast__Type right_type, v__token__Position left_pos, v__token__Position right_pos);
v__ast__Type v__checker__Checker_promote(v__checker__Checker* c, v__ast__Type left_type, v__ast__Type right_type);
VV_LOCAL_SYMBOL v__ast__Type v__checker__Checker_promote_num(v__checker__Checker* c, v__ast__Type left_type, v__ast__Type right_type);
bool v__checker__Checker_check_types(v__checker__Checker* c, v__ast__Type got, v__ast__Type expected);
Option_void v__checker__Checker_check_expected(v__checker__Checker* c, v__ast__Type got, v__ast__Type expected);
VV_LOCAL_SYMBOL string v__checker__Checker_expected_msg(v__checker__Checker* c, v__ast__Type got, v__ast__Type expected);
bool v__checker__Checker_symmetric_check(v__checker__Checker* c, v__ast__Type left, v__ast__Type right);
byte v__checker__Checker_get_default_fmt(v__checker__Checker* c, v__ast__Type ftyp, v__ast__Type typ);
void v__checker__Checker_fail_if_unreadable(v__checker__Checker* c, v__ast__Expr expr, v__ast__Type typ, string what);
v__ast__Type v__checker__Checker_string_inter_lit(v__checker__Checker* c, v__ast__StringInterLiteral* node);
void v__checker__Checker_infer_fn_types(v__checker__Checker* c, v__ast__Fn f, v__ast__CallExpr* call_expr);
int _const_v__checker__int_min; // inited later
int _const_v__checker__int_max; // inited later
Array_string _const_v__checker__valid_comp_if_os; // inited later
Array_string _const_v__checker__valid_comp_if_compilers; // inited later
Array_string _const_v__checker__valid_comp_if_platforms; // inited later
Array_string _const_v__checker__valid_comp_if_other; // inited later
Array_string _const_v__checker__array_builtin_methods; // inited later
v__checker__Checker v__checker__new_checker(v__ast__Table* table, v__pref__Preferences* pref);
void v__checker__Checker_check(v__checker__Checker* c, v__ast__File* ast_file);
void v__checker__Checker_check_scope_vars(v__checker__Checker* c, v__ast__Scope* sc);
Array_v__errors__Error v__checker__Checker_check2(v__checker__Checker* c, v__ast__File* ast_file);
void v__checker__Checker_check_files(v__checker__Checker* c, Array_v__ast__File ast_files);
VV_LOCAL_SYMBOL bool v__checker__Checker_file_has_main_fn(v__checker__Checker* c, v__ast__File file);
VV_LOCAL_SYMBOL void v__checker__Checker_check_valid_snake_case(v__checker__Checker* c, string name, string identifier, v__token__Position pos);
VV_LOCAL_SYMBOL string v__checker__stripped_name(string name);
VV_LOCAL_SYMBOL void v__checker__Checker_check_valid_pascal_case(v__checker__Checker* c, string name, string identifier, v__token__Position pos);
void v__checker__Checker_type_decl(v__checker__Checker* c, v__ast__TypeDecl node);
void v__checker__Checker_alias_type_decl(v__checker__Checker* c, v__ast__AliasTypeDecl node);
void v__checker__Checker_fn_type_decl(v__checker__Checker* c, v__ast__FnTypeDecl node);
void v__checker__Checker_sum_type_decl(v__checker__Checker* c, v__ast__SumTypeDecl node);
void v__checker__Checker_interface_decl(v__checker__Checker* c, v__ast__InterfaceDecl decl);
void v__checker__Checker_struct_decl(v__checker__Checker* c, v__ast__StructDecl* decl);
v__ast__Type v__checker__Checker_struct_init(v__checker__Checker* c, v__ast__StructInit* struct_init);
VV_LOCAL_SYMBOL void v__checker__Checker_check_div_mod_by_zero(v__checker__Checker* c, v__ast__Expr expr, v__token__Kind op_kind);
v__ast__Type v__checker__Checker_infix_expr(v__checker__Checker* c, v__ast__InfixExpr* infix_expr);
VV_LOCAL_SYMBOL multi_return_string_v__token__Position v__checker__Checker_fail_if_immutable(v__checker__Checker* c, v__ast__Expr expr);
v__ast__Type v__checker__Checker_call_expr(v__checker__Checker* c, v__ast__CallExpr* call_expr);
VV_LOCAL_SYMBOL void v__checker__Checker_check_map_and_filter(v__checker__Checker* c, bool is_map, v__ast__Type elem_typ, v__ast__CallExpr call_expr);
VV_LOCAL_SYMBOL void v__checker__Checker_check_return_generics_struct(v__checker__Checker* c, v__ast__Type return_type, v__ast__CallExpr* call_expr, Array_v__ast__Type generic_types);
v__ast__Type v__checker__Checker_method_call(v__checker__Checker* c, v__ast__CallExpr* call_expr);
VV_LOCAL_SYMBOL v__ast__Type v__checker__Checker_map_builtin_method_call(v__checker__Checker* c, v__ast__CallExpr* call_expr, v__ast__Type left_type, v__ast__TypeSymbol left_type_sym);
VV_LOCAL_SYMBOL v__ast__Type v__checker__Checker_array_builtin_method_call(v__checker__Checker* c, v__ast__CallExpr* call_expr, v__ast__Type left_type, v__ast__TypeSymbol left_type_sym);
v__ast__Type v__checker__Checker_fn_call(v__checker__Checker* c, v__ast__CallExpr* call_expr);
VV_LOCAL_SYMBOL void v__checker__Checker_deprecate_fnmethod(v__checker__Checker* c, string kind, string name, v__ast__Fn the_fn, v__ast__CallExpr call_expr);
VV_LOCAL_SYMBOL string v__checker__semicolonize(string main, string details);
VV_LOCAL_SYMBOL bool v__checker__Checker_type_implements(v__checker__Checker* c, v__ast__Type typ, v__ast__Type inter_typ, v__token__Position pos);
v__ast__Type v__checker__Checker_check_expr_opt_call(v__checker__Checker* c, v__ast__Expr expr, v__ast__Type ret_type);
void v__checker__Checker_check_or_expr(v__checker__Checker* c, v__ast__OrExpr or_expr, v__ast__Type ret_type, v__ast__Type expr_return_type);
VV_LOCAL_SYMBOL bool v__checker__is_expr_panic_or_exit(v__ast__Expr expr);
v__ast__Type v__checker__Checker_selector_expr(v__checker__Checker* c, v__ast__SelectorExpr* selector_expr);
void v__checker__Checker_return_stmt(v__checker__Checker* c, v__ast__Return* return_stmt);
void v__checker__Checker_const_decl(v__checker__Checker* c, v__ast__ConstDecl* node);
void v__checker__Checker_enum_decl(v__checker__Checker* c, v__ast__EnumDecl decl);
void v__checker__Checker_assign_stmt(v__checker__Checker* c, v__ast__AssignStmt* assign_stmt);
VV_LOCAL_SYMBOL void v__checker__scope_register_it(v__ast__Scope* s, v__token__Position pos, v__ast__Type typ);
VV_LOCAL_SYMBOL void v__checker__scope_register_a_b(v__ast__Scope* s, v__token__Position pos, v__ast__Type typ);
VV_LOCAL_SYMBOL void v__checker__Checker_check_array_init_para_type(v__checker__Checker* c, string para, v__ast__Expr expr, v__token__Position pos);
void v__checker__Checker_ensure_sumtype_array_has_default_value(v__checker__Checker* c, v__ast__ArrayInit array_init);
v__ast__Type v__checker__Checker_array_init(v__checker__Checker* c, v__ast__ArrayInit* array_init);
VV_LOCAL_SYMBOL Option_int v__checker__eval_int_expr(v__ast__Expr expr, int nlevel);
VV_LOCAL_SYMBOL void v__checker__Checker_check_loop_label(v__checker__Checker* c, string label, v__token__Position pos);
VV_LOCAL_SYMBOL void v__checker__Checker_stmt(v__checker__Checker* c, v__ast__Stmt node);
VV_LOCAL_SYMBOL void v__checker__Checker_assert_stmt(v__checker__Checker* c, v__ast__AssertStmt node);
VV_LOCAL_SYMBOL void v__checker__Checker_block(v__checker__Checker* c, v__ast__Block node);
VV_LOCAL_SYMBOL void v__checker__Checker_branch_stmt(v__checker__Checker* c, v__ast__BranchStmt node);
VV_LOCAL_SYMBOL void v__checker__Checker_for_c_stmt(v__checker__Checker* c, v__ast__ForCStmt node);
VV_LOCAL_SYMBOL void v__checker__Checker_for_in_stmt(v__checker__Checker* c, v__ast__ForInStmt* node);
VV_LOCAL_SYMBOL void v__checker__Checker_for_stmt(v__checker__Checker* c, v__ast__ForStmt* node);
VV_LOCAL_SYMBOL void v__checker__Checker_global_decl(v__checker__Checker* c, v__ast__GlobalDecl node);
VV_LOCAL_SYMBOL void v__checker__Checker_go_stmt(v__checker__Checker* c, v__ast__GoStmt* node);
VV_LOCAL_SYMBOL void v__checker__Checker_asm_stmt(v__checker__Checker* c, v__ast__AsmStmt* stmt);
VV_LOCAL_SYMBOL void v__checker__Checker_asm_arg(v__checker__Checker* c, v__ast__AsmArg arg, v__ast__AsmStmt stmt, Array_string aliases);
VV_LOCAL_SYMBOL Array_string v__checker__Checker_asm_ios(v__checker__Checker* c, Array_v__ast__AsmIO ios, v__ast__Scope* scope, bool output);
VV_LOCAL_SYMBOL void v__checker__Checker_hash_stmt(v__checker__Checker* c, v__ast__HashStmt* node);
VV_LOCAL_SYMBOL void v__checker__Checker_import_stmt(v__checker__Checker* c, v__ast__Import imp);
VV_LOCAL_SYMBOL void v__checker__Checker_stmts(v__checker__Checker* c, Array_v__ast__Stmt stmts);
v__ast__Type v__checker__Checker_unwrap_generic(v__checker__Checker* c, v__ast__Type typ);
v__ast__Type v__checker__Checker_expr(v__checker__Checker* c, v__ast__Expr node);
v__ast__Type v__checker__Checker_cast_expr(v__checker__Checker* c, v__ast__CastExpr* node);
VV_LOCAL_SYMBOL v__ast__Type v__checker__Checker_comptime_call(v__checker__Checker* c, v__ast__ComptimeCall* node);
VV_LOCAL_SYMBOL v__ast__Type v__checker__Checker_at_expr(v__checker__Checker* c, v__ast__AtExpr* node);
v__ast__Type v__checker__Checker_ident(v__checker__Checker* c, v__ast__Ident* ident);
v__ast__Type v__checker__Checker_concat_expr(v__checker__Checker* c, v__ast__ConcatExpr* concat_expr);
v__ast__Type v__checker__Checker_match_expr(v__checker__Checker* c, v__ast__MatchExpr* node);
VV_LOCAL_SYMBOL void v__checker__Checker_match_exprs(v__checker__Checker* c, v__ast__MatchExpr* node, v__ast__TypeSymbol cond_type_sym);
VV_LOCAL_SYMBOL void v__checker__Checker_smartcast(v__checker__Checker* c, v__ast__Expr expr, v__ast__Type cur_type, v__ast__Type to_type_, v__ast__Scope* scope);
v__ast__Type v__checker__Checker_select_expr(v__checker__Checker* c, v__ast__SelectExpr* node);
v__ast__Type v__checker__Checker_lock_expr(v__checker__Checker* c, v__ast__LockExpr* node);
v__ast__Type v__checker__Checker_unsafe_expr(v__checker__Checker* c, v__ast__UnsafeExpr* node);
v__ast__Type v__checker__Checker_if_expr(v__checker__Checker* c, v__ast__IfExpr* node);
VV_LOCAL_SYMBOL bool v__checker__Checker_comp_if_branch(v__checker__Checker* c, v__ast__Expr cond, v__token__Position pos);
VV_LOCAL_SYMBOL Option_v__ast__Expr v__checker__Checker_find_definition(v__checker__Checker* c, v__ast__Ident ident);
VV_LOCAL_SYMBOL Option_v__ast__Expr v__checker__Checker_find_obj_definition(v__checker__Checker* c, v__ast__ScopeObject obj);
VV_LOCAL_SYMBOL Option_bool v__checker__Checker_has_return(v__checker__Checker* c, Array_v__ast__Stmt stmts);
v__ast__Type v__checker__Checker_postfix_expr(v__checker__Checker* c, v__ast__PostfixExpr* node);
v__ast__Type v__checker__Checker_prefix_expr(v__checker__Checker* c, v__ast__PrefixExpr* node);
VV_LOCAL_SYMBOL void v__checker__Checker_check_index(v__checker__Checker* c, v__ast__TypeSymbol* typ_sym, v__ast__Expr index, v__ast__Type index_type, v__token__Position pos, bool range_index);
v__ast__Type v__checker__Checker_index_expr(v__checker__Checker* c, v__ast__IndexExpr* node);
v__ast__Type v__checker__Checker_enum_val(v__checker__Checker* c, v__ast__EnumVal* node);
v__ast__Type v__checker__Checker_chan_init(v__checker__Checker* c, v__ast__ChanInit* node);
v__ast__Type v__checker__Checker_offset_of(v__checker__Checker* c, v__ast__OffsetOf node);
void v__checker__Checker_check_dup_keys(v__checker__Checker* c, v__ast__MapInit* node, int i);
v__ast__Type v__checker__Checker_map_init(v__checker__Checker* c, v__ast__MapInit* node);
void v__checker__Checker_add_error_detail(v__checker__Checker* c, string s);
void v__checker__Checker_warn(v__checker__Checker* c, string s, v__token__Position pos);
void v__checker__Checker_error(v__checker__Checker* c, string message, v__token__Position pos);
VV_LOCAL_SYMBOL bool v__checker__Checker_check_struct_signature(v__checker__Checker* c, v__ast__Struct from, v__ast__Struct to);
void v__checker__Checker_note(v__checker__Checker* c, string message, v__token__Position pos);
VV_LOCAL_SYMBOL void v__checker__Checker_warn_or_error(v__checker__Checker* c, string message, v__token__Position pos, bool warn);
VV_LOCAL_SYMBOL bool v__checker__Checker_fileis(v__checker__Checker* c, string s);
VV_LOCAL_SYMBOL v__ast__Type v__checker__Checker_sql_expr(v__checker__Checker* c, v__ast__SqlExpr* node);
VV_LOCAL_SYMBOL v__ast__Type v__checker__Checker_sql_stmt(v__checker__Checker* c, v__ast__SqlStmt* node);
VV_LOCAL_SYMBOL Array_v__ast__StructField v__checker__Checker_fetch_and_verify_orm_fields(v__checker__Checker* c, v__ast__Struct info, v__token__Position pos, string table_name);
VV_LOCAL_SYMBOL void v__checker__Checker_post_process_generic_fns(v__checker__Checker* c);
VV_LOCAL_SYMBOL void v__checker__Checker_fn_decl(v__checker__Checker* c, v__ast__FnDecl* node);
VV_LOCAL_SYMBOL bool v__checker__has_top_return(Array_v__ast__Stmt stmts);
VV_LOCAL_SYMBOL multi_return_bool_int_int v__checker__Checker_verify_vweb_params_for_method(v__checker__Checker* c, v__ast__Fn m);
VV_LOCAL_SYMBOL void v__checker__Checker_verify_all_vweb_routes(v__checker__Checker* c);
VV_LOCAL_SYMBOL void v__checker__Checker_trace(v__checker__Checker* c, string fbase, string message);
VV_LOCAL_SYMBOL Option_void v__checker__Checker_ensure_type_exists(v__checker__Checker* c, v__ast__Type typ, v__token__Position pos);
VV_LOCAL_SYMBOL v__ast__Stmt v__parser__Parser_assign_stmt(v__parser__Parser* p);
VV_LOCAL_SYMBOL Option_void v__parser__Parser_check_undefined_variables(v__parser__Parser* p, Array_v__ast__Expr exprs, v__ast__Expr val);
VV_LOCAL_SYMBOL bool v__parser__Parser_check_cross_variables(v__parser__Parser* p, Array_v__ast__Expr exprs, v__ast__Expr val);
VV_LOCAL_SYMBOL v__ast__Stmt v__parser__Parser_partial_assign_stmt(v__parser__Parser* p, Array_v__ast__Expr left, Array_v__ast__Comment left_comments);
Array_string _const_v__parser__supported_comptime_calls; // inited later
VV_LOCAL_SYMBOL v__ast__HashStmt v__parser__Parser_hash(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__ComptimeCall v__parser__Parser_comp_call(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__CompFor v__parser__Parser_comp_for(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__AtExpr v__parser__Parser_at(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__Expr v__parser__Parser_comptime_selector(v__parser__Parser* p, v__ast__Expr left);
VV_LOCAL_SYMBOL v__ast__ArrayInit v__parser__Parser_array_init(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__MapInit v__parser__Parser_map_init(v__parser__Parser* p);
v__ast__CallExpr v__parser__Parser_call_expr(v__parser__Parser* p, v__ast__Language language, string mod);
Array_v__ast__CallArg v__parser__Parser_call_args(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__FnDecl v__parser__Parser_fn_decl(v__parser__Parser* p);
VV_LOCAL_SYMBOL Option_void v__parser__Parser_fn_receiver(v__parser__Parser* p, Array_v__ast__Param* params, v__parser__ReceiverParsingInfo* rec);
VV_LOCAL_SYMBOL Array_string v__parser__Parser_parse_generic_names(v__parser__Parser* p);
VV_LOCAL_SYMBOL bool v__parser__Parser_is_generic_name(v__parser__Parser p);
VV_LOCAL_SYMBOL v__ast__AnonFn v__parser__Parser_anon_fn(v__parser__Parser* p);
VV_LOCAL_SYMBOL multi_return_Array_v__ast__Param_bool_bool v__parser__Parser_fn_args(v__parser__Parser* p);
VV_LOCAL_SYMBOL void v__parser__Parser_check_fn_mutable_arguments(v__parser__Parser* p, v__ast__Type typ, v__token__Position pos);
VV_LOCAL_SYMBOL void v__parser__Parser_check_fn_shared_arguments(v__parser__Parser* p, v__ast__Type typ, v__token__Position pos);
VV_LOCAL_SYMBOL void v__parser__Parser_check_fn_atomic_arguments(v__parser__Parser* p, v__ast__Type typ, v__token__Position pos);
VV_LOCAL_SYMBOL bool v__parser__have_fn_main(Array_v__ast__Stmt stmts);
VV_LOCAL_SYMBOL v__ast__Stmt v__parser__Parser_for_stmt(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__IfExpr v__parser__Parser_if_expr(v__parser__Parser* p, bool is_comptime);
VV_LOCAL_SYMBOL v__ast__MatchExpr v__parser__Parser_match_expr(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__SelectExpr v__parser__Parser_select_expr(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__LockExpr v__parser__Parser_lock_expr(v__parser__Parser* p);
bool v__parser__Parser_known_import(v__parser__Parser* p, string mod);
VV_LOCAL_SYMBOL string v__parser__Parser_prepend_mod(v__parser__Parser* p, string name);
VV_LOCAL_SYMBOL bool v__parser__Parser_is_used_import(v__parser__Parser* p, string alias);
VV_LOCAL_SYMBOL void v__parser__Parser_register_used_import(v__parser__Parser* p, string alias);
VV_LOCAL_SYMBOL void v__parser__Parser_register_auto_import(v__parser__Parser* p, string alias);
VV_LOCAL_SYMBOL void v__parser__Parser_check_unused_imports(v__parser__Parser* p);
v__ast__Type v__parser__Parser_parse_array_type(v__parser__Parser* p);
v__ast__Type v__parser__Parser_parse_map_type(v__parser__Parser* p);
v__ast__Type v__parser__Parser_parse_chan_type(v__parser__Parser* p);
v__ast__Type v__parser__Parser_parse_thread_type(v__parser__Parser* p);
v__ast__Type v__parser__Parser_parse_multi_return_type(v__parser__Parser* p);
v__ast__Type v__parser__Parser_parse_fn_type(v__parser__Parser* p, string name);
v__ast__Type v__parser__Parser_parse_type_with_mut(v__parser__Parser* p, bool is_mut);
v__ast__Language v__parser__Parser_parse_language(v__parser__Parser* p);
v__ast__Type v__parser__Parser_parse_type(v__parser__Parser* p);
v__ast__Type v__parser__Parser_parse_any_type(v__parser__Parser* p, v__ast__Language language, bool is_ptr, bool check_dot);
v__ast__Type v__parser__Parser_parse_enum_or_struct_type(v__parser__Parser* p, string name, v__ast__Language language);
v__ast__Type v__parser__Parser_parse_generic_template_type(v__parser__Parser* p, string name);
v__ast__Type v__parser__Parser_parse_generic_struct_inst_type(v__parser__Parser* p, string name);
Array_string _const_v__parser__builtin_functions; // inited later
v__ast__Stmt v__parser__parse_stmt(string text, v__ast__Table* table, v__ast__Scope* scope);
v__ast__File v__parser__parse_comptime(string text, v__ast__Table* table, v__pref__Preferences* pref, v__ast__Scope* scope, v__ast__Scope* global_scope);
v__ast__File v__parser__parse_text(string text, string path, v__ast__Table* table, v__scanner__CommentsMode comments_mode, v__pref__Preferences* pref, v__ast__Scope* global_scope);
void v__parser__Parser_free(v__parser__Parser* p);
void v__parser__Parser_set_path(v__parser__Parser* p, string path);
v__ast__File v__parser__parse_file(string path, v__ast__Table* table, v__scanner__CommentsMode comments_mode, v__pref__Preferences* pref, v__ast__Scope* global_scope);
multi_return_v__ast__File_Array_v__vet__Error v__parser__parse_vet_file(string path, v__ast__Table* table_, v__pref__Preferences* pref);
v__ast__File v__parser__Parser_parse(v__parser__Parser* p);
Array_v__ast__File v__parser__parse_files(Array_string paths, v__ast__Table* table, v__pref__Preferences* pref, v__ast__Scope* global_scope);
void v__parser__Parser_init_parse_fns(v__parser__Parser* p);
void v__parser__Parser_read_first_token(v__parser__Parser* p);
v__token__Token v__parser__Parser_peek_token(v__parser__Parser* p, int n);
void v__parser__Parser_open_scope(v__parser__Parser* p);
void v__parser__Parser_close_scope(v__parser__Parser* p);
Array_v__ast__Stmt v__parser__Parser_parse_block(v__parser__Parser* p);
Array_v__ast__Stmt v__parser__Parser_parse_block_no_scope(v__parser__Parser* p, bool is_top_level);
VV_LOCAL_SYMBOL void v__parser__Parser_next(v__parser__Parser* p);
VV_LOCAL_SYMBOL void v__parser__Parser_check(v__parser__Parser* p, v__token__Kind expected);
VV_LOCAL_SYMBOL string v__parser__Parser_check_js_name(v__parser__Parser* p);
VV_LOCAL_SYMBOL string v__parser__Parser_check_name(v__parser__Parser* p);
v__ast__Stmt v__parser__Parser_top_stmt(v__parser__Parser* p);
v__ast__Comment v__parser__Parser_check_comment(v__parser__Parser* p);
v__ast__Comment v__parser__Parser_comment(v__parser__Parser* p);
v__ast__ExprStmt v__parser__Parser_comment_stmt(v__parser__Parser* p);
Array_v__ast__Comment v__parser__Parser_eat_comments(v__parser__Parser* p, v__parser__EatCommentsConfig cfg);
v__ast__Stmt v__parser__Parser_stmt(v__parser__Parser* p, bool is_top_level);
VV_LOCAL_SYMBOL v__ast__AsmStmt v__parser__Parser_asm_stmt(v__parser__Parser* p, bool is_top_level);
VV_LOCAL_SYMBOL v__ast__AsmArg v__parser__Parser_reg_or_alias(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__AsmAddressing v__parser__Parser_asm_addressing(v__parser__Parser* p);
VV_LOCAL_SYMBOL Array_v__ast__AsmIO v__parser__Parser_asm_ios(v__parser__Parser* p, bool output);
VV_LOCAL_SYMBOL multi_return_Array_v__ast__Expr_Array_v__ast__Comment v__parser__Parser_expr_list(v__parser__Parser* p);
VV_LOCAL_SYMBOL void v__parser__Parser_attributes(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__Attr v__parser__Parser_parse_attr(v__parser__Parser* p);
void v__parser__Parser_check_for_impure_v(v__parser__Parser* p, v__ast__Language language, v__token__Position pos);
v__ast__NodeError v__parser__Parser_error(v__parser__Parser* p, string s);
void v__parser__Parser_warn(v__parser__Parser* p, string s);
void v__parser__Parser_note(v__parser__Parser* p, string s);
v__ast__NodeError v__parser__Parser_error_with_pos(v__parser__Parser* p, string s, v__token__Position pos);
void v__parser__Parser_error_with_error(v__parser__Parser* p, v__errors__Error v_error);
void v__parser__Parser_warn_with_pos(v__parser__Parser* p, string s, v__token__Position pos);
void v__parser__Parser_note_with_pos(v__parser__Parser* p, string s, v__token__Position pos);
void v__parser__Parser_vet_error(v__parser__Parser* p, string msg, int line, v__vet__FixKind fix, v__vet__ErrorType typ);
VV_LOCAL_SYMBOL v__ast__Stmt v__parser__Parser_parse_multi_expr(v__parser__Parser* p, bool is_top_level);
v__ast__Ident v__parser__Parser_parse_ident(v__parser__Parser* p, v__ast__Language language);
VV_LOCAL_SYMBOL bool v__parser__Parser_is_typename(v__parser__Parser* p, v__token__Token t);
VV_LOCAL_SYMBOL bool v__parser__Parser_is_generic_call(v__parser__Parser* p);
v__ast__Expr v__parser__Parser_name_expr(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__IndexExpr v__parser__Parser_index_expr(v__parser__Parser* p, v__ast__Expr left);
VV_LOCAL_SYMBOL void v__parser__Parser_scope_register_it(v__parser__Parser* p);
VV_LOCAL_SYMBOL void v__parser__Parser_scope_register_ab(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__Expr v__parser__Parser_dot_expr(v__parser__Parser* p, v__ast__Expr left);
VV_LOCAL_SYMBOL Array_v__ast__Type v__parser__Parser_parse_generic_type_list(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__EnumVal v__parser__Parser_enum_val(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__Expr v__parser__Parser_string_expr(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__Expr v__parser__Parser_parse_number_literal(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__Module v__parser__Parser_module_decl(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__Import v__parser__Parser_import_stmt(v__parser__Parser* p);
VV_LOCAL_SYMBOL void v__parser__Parser_import_syms(v__parser__Parser* p, v__ast__Import* parent);
VV_LOCAL_SYMBOL v__ast__ConstDecl v__parser__Parser_const_decl(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__Return v__parser__Parser_return_stmt(v__parser__Parser* p);
Array_string _const_v__parser__global_enabled_mods; // inited later
VV_LOCAL_SYMBOL v__ast__GlobalDecl v__parser__Parser_global_decl(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__EnumDecl v__parser__Parser_enum_decl(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__TypeDecl v__parser__Parser_type_decl(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__Assoc v__parser__Parser_assoc(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__Expr v__parser__Parser_new_true_expr(v__parser__Parser* p);
VV_LOCAL_SYMBOL void v__parser__verror(string s);
VV_LOCAL_SYMBOL void v__parser__Parser_top_level_statement_start(v__parser__Parser* p);
VV_LOCAL_SYMBOL void v__parser__Parser_top_level_statement_end(v__parser__Parser* p);
VV_LOCAL_SYMBOL void v__parser__Parser_rewind_scanner_to_current_token_in_new_mode(v__parser__Parser* p);
bool v__parser__Parser_mark_var_as_used(v__parser__Parser* p, string varname);
VV_LOCAL_SYMBOL v__ast__Stmt v__parser__Parser_unsafe_stmt(v__parser__Parser* p);
VV_LOCAL_SYMBOL void v__parser__Parser_trace(v__parser__Parser* p, string fbase, string message);
v__ast__Expr v__parser__Parser_expr(v__parser__Parser* p, int precedence);
v__ast__Expr v__parser__Parser_expr_with_left(v__parser__Parser* p, v__ast__Expr left, int precedence, bool is_stmt_ident);
VV_LOCAL_SYMBOL v__ast__Expr v__parser__Parser_infix_expr(v__parser__Parser* p, v__ast__Expr left);
VV_LOCAL_SYMBOL bool v__parser__Parser_fileis(v__parser__Parser* p, string s);
VV_LOCAL_SYMBOL v__ast__PrefixExpr v__parser__Parser_prefix_expr(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__Expr v__parser__Parser_sql_expr(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__SqlStmt v__parser__Parser_sql_stmt(v__parser__Parser* p);
VV_LOCAL_SYMBOL Option_bool v__parser__Parser_check_sql_keyword(v__parser__Parser* p, string name);
VV_LOCAL_SYMBOL v__ast__StructDecl v__parser__Parser_struct_decl(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__StructInit v__parser__Parser_struct_init(v__parser__Parser* p, bool short_syntax);
VV_LOCAL_SYMBOL v__ast__InterfaceDecl v__parser__Parser_interface_decl(v__parser__Parser* p);
string _const_v__parser__tmpl_str_start; // a string literal, inited later
string _const_v__parser__tmpl_str_end; // a string literal, inited later
VV_LOCAL_SYMBOL bool v__parser__is_html_open_tag(string name, string s);
string v__parser__Parser_compile_template_file(v__parser__Parser* p, string template_file, string fn_name);
VV_LOCAL_SYMBOL void v__gen__c__Gen_array_init(v__gen__c__Gen* g, v__ast__ArrayInit node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_array_map(v__gen__c__Gen* g, v__ast__CallExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_array_sort(v__gen__c__Gen* g, v__ast__CallExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_array_filter(v__gen__c__Gen* g, v__ast__CallExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_array_insert(v__gen__c__Gen* g, v__ast__CallExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_array_prepend(v__gen__c__Gen* g, v__ast__CallExpr node);
VV_LOCAL_SYMBOL string v__gen__c__Gen_gen_array_contains_method(v__gen__c__Gen* g, v__ast__Type left_type);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_array_contains(v__gen__c__Gen* g, v__ast__CallExpr node);
VV_LOCAL_SYMBOL string v__gen__c__Gen_gen_array_index_method(v__gen__c__Gen* g, v__ast__Type left_type);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_array_index(v__gen__c__Gen* g, v__ast__CallExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_array_wait(v__gen__c__Gen* g, v__ast__CallExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_array_any(v__gen__c__Gen* g, v__ast__CallExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_array_all(v__gen__c__Gen* g, v__ast__CallExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_assert_stmt(v__gen__c__Gen* g, v__ast__AssertStmt original_assert_statement);
VV_LOCAL_SYMBOL string v__gen__c__Gen_gen_assert_metainfo(v__gen__c__Gen* g, v__ast__AssertStmt node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_assert_single_expr(v__gen__c__Gen* g, v__ast__Expr expr, v__ast__Type typ);
VV_LOCAL_SYMBOL string v__gen__c__Gen_gen_sumtype_equality_fn(v__gen__c__Gen* g, v__ast__Type left);
VV_LOCAL_SYMBOL string v__gen__c__Gen_gen_struct_equality_fn(v__gen__c__Gen* g, v__ast__Type left);
VV_LOCAL_SYMBOL string v__gen__c__Gen_gen_alias_equality_fn(v__gen__c__Gen* g, v__ast__Type left);
VV_LOCAL_SYMBOL string v__gen__c__Gen_gen_array_equality_fn(v__gen__c__Gen* g, v__ast__Type left);
VV_LOCAL_SYMBOL string v__gen__c__Gen_gen_fixed_array_equality_fn(v__gen__c__Gen* g, v__ast__Type left);
VV_LOCAL_SYMBOL string v__gen__c__Gen_gen_map_equality_fn(v__gen__c__Gen* g, v__ast__Type left);
VV_LOCAL_SYMBOL bool v__gen__c__should_use_indent_func(v__ast__Kind kind);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_default(v__gen__c__Gen* g, v__ast__TypeSymbol sym, string styp, string str_fn_name);
VV_LOCAL_SYMBOL string v__gen__c__Gen_type_to_fmt(v__gen__c__Gen* g, v__ast__Type typ);
VV_LOCAL_SYMBOL string v__gen__c__Gen_gen_str_for_type(v__gen__c__Gen* g, v__ast__Type typ);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_option(v__gen__c__Gen* g, v__ast__Type typ, string styp, string str_fn_name);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_alias(v__gen__c__Gen* g, v__ast__Alias info, string styp, string str_fn_name);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_array(v__gen__c__Gen* g, v__ast__Array info, string styp, string str_fn_name);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_array_fixed(v__gen__c__Gen* g, v__ast__ArrayFixed info, string styp, string str_fn_name);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_map(v__gen__c__Gen* g, v__ast__Map info, string styp, string str_fn_name);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_multi_return(v__gen__c__Gen* g, v__ast__MultiReturn info, string styp, string str_fn_name);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_struct(v__gen__c__Gen* g, v__ast__Struct info, string styp, string str_fn_name);
VV_LOCAL_SYMBOL string v__gen__c__struct_auto_str_func(v__ast__TypeSymbol* sym, v__ast__Type field_type, string fn_name, string field_name);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_enum(v__gen__c__Gen* g, v__ast__Enum info, string styp, string str_fn_name);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_interface(v__gen__c__Gen* g, v__ast__Interface info, string styp, string str_fn_name);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_union_sum_type(v__gen__c__Gen* g, v__ast__SumType info, string styp, string str_fn_name);
VV_LOCAL_SYMBOL string v__gen__c__Gen_fn_decl_str(v__gen__c__Gen* g, v__ast__FnType info);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_fn_type(v__gen__c__Gen* g, v__ast__FnType info, string styp, string str_fn_name);
VV_LOCAL_SYMBOL string v__gen__c__styp_to_str_fn_name(string styp);
Array_string _const_v__gen__c__c_reserved; // inited later
Array_string _const_v__gen__c__cmp_str; // inited later
Array_string _const_v__gen__c__cmp_rev; // inited later
string v__gen__c__gen(Array_v__ast__File files, v__ast__Table* table, v__pref__Preferences* pref);
string v__gen__c__Gen_hashes(v__gen__c__Gen* g);
void v__gen__c__Gen_init(v__gen__c__Gen* g);
void v__gen__c__Gen_finish(v__gen__c__Gen* g);
void v__gen__c__Gen_write_typeof_functions(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL string v__gen__c__Gen_typ(v__gen__c__Gen* g, v__ast__Type t);
VV_LOCAL_SYMBOL string v__gen__c__Gen_base_type(v__gen__c__Gen* g, v__ast__Type t);
VV_LOCAL_SYMBOL string v__gen__c__Gen_expr_string(v__gen__c__Gen* g, v__ast__Expr expr);
VV_LOCAL_SYMBOL multi_return_string_string v__gen__c__Gen_optional_type_name(v__gen__c__Gen* g, v__ast__Type t);
VV_LOCAL_SYMBOL string v__gen__c__Gen_optional_type_text(v__gen__c__Gen* g, string styp, string base);
VV_LOCAL_SYMBOL string v__gen__c__Gen_register_optional(v__gen__c__Gen* g, v__ast__Type t);
VV_LOCAL_SYMBOL string v__gen__c__Gen_find_or_register_shared(v__gen__c__Gen* g, v__ast__Type t, string base);
VV_LOCAL_SYMBOL string v__gen__c__Gen_register_thread_array_wait_call(v__gen__c__Gen* g, string eltyp);
VV_LOCAL_SYMBOL void v__gen__c__Gen_register_chan_pop_optional_call(v__gen__c__Gen* g, string opt_el_type, string styp);
VV_LOCAL_SYMBOL void v__gen__c__Gen_register_chan_push_optional_call(v__gen__c__Gen* g, string el_type, string styp);
VV_LOCAL_SYMBOL string v__gen__c__Gen_cc_type(v__gen__c__Gen* g, v__ast__Type typ, bool is_prefix_struct);
VV_LOCAL_SYMBOL string v__gen__c__Gen_type_sidx(v__gen__c__Gen* g, v__ast__Type t);
void v__gen__c__Gen_write_typedef_types(v__gen__c__Gen* g);
void v__gen__c__Gen_write_interface_typesymbol_declaration(v__gen__c__Gen* g, v__ast__TypeSymbol sym);
void v__gen__c__Gen_write_fn_typesymbol_declaration(v__gen__c__Gen* g, v__ast__TypeSymbol sym);
void v__gen__c__Gen_write_multi_return_types(v__gen__c__Gen* g);
void v__gen__c__Gen_write(v__gen__c__Gen* g, string s);
void v__gen__c__Gen_writeln(v__gen__c__Gen* g, string s);
string v__gen__c__Gen_new_tmp_var(v__gen__c__Gen* g);
string v__gen__c__Gen_current_tmp_var(v__gen__c__Gen* g);
void v__gen__c__Gen_reset_tmp_count(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL void v__gen__c__Gen_decrement_inside_ternary(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL void v__gen__c__Gen_stmts(v__gen__c__Gen* g, Array_v__ast__Stmt stmts);
VV_LOCAL_SYMBOL void v__gen__c__Gen_stmts_with_tmp_var(v__gen__c__Gen* g, Array_v__ast__Stmt stmts, string tmp_var);
VV_LOCAL_SYMBOL void v__gen__c__Gen_write_v_source_line_info(v__gen__c__Gen* g, v__token__Position pos);
VV_LOCAL_SYMBOL void v__gen__c__Gen_stmt(v__gen__c__Gen* g, v__ast__Stmt node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_write_defer_stmts(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL void v__gen__c__Gen_for_c_stmt(v__gen__c__Gen* g, v__ast__ForCStmt node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_for_stmt(v__gen__c__Gen* g, v__ast__ForStmt node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_for_in_stmt(v__gen__c__Gen* g, v__ast__ForInStmt node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_write_sumtype_casting_fn(v__gen__c__Gen* g, v__ast__Type got_, v__ast__Type exp_);
VV_LOCAL_SYMBOL void v__gen__c__Gen_expr_with_cast(v__gen__c__Gen* g, v__ast__Expr expr, v__ast__Type got_type_raw, v__ast__Type expected_type);
VV_LOCAL_SYMBOL string v__gen__c__cestring(string s);
VV_LOCAL_SYMBOL string v__gen__c__ctoslit(string s);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_attrs(v__gen__c__Gen* g, Array_v__ast__Attr attrs);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_asm_stmt(v__gen__c__Gen* g, v__ast__AsmStmt stmt);
VV_LOCAL_SYMBOL void v__gen__c__Gen_asm_arg(v__gen__c__Gen* g, v__ast__AsmArg arg, v__ast__AsmStmt stmt);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_asm_ios(v__gen__c__Gen* g, Array_v__ast__AsmIO ios);
VV_LOCAL_SYMBOL string v__gen__c__cnewlines(string s);
VV_LOCAL_SYMBOL void v__gen__c__Gen_write_fn_ptr_decl(v__gen__c__Gen* g, v__ast__FnType* func, string ptr_name);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_assign_stmt(v__gen__c__Gen* g, v__ast__AssignStmt assign_stmt);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_cross_tmp_variable(v__gen__c__Gen* g, Array_v__ast__Expr left, v__ast__Expr val);
VV_LOCAL_SYMBOL void v__gen__c__Gen_register_ternary_name(v__gen__c__Gen* g, string name);
VV_LOCAL_SYMBOL string v__gen__c__Gen_get_ternary_name(v__gen__c__Gen* g, string name);
VV_LOCAL_SYMBOL bool v__gen__c__Gen_gen_clone_assignment(v__gen__c__Gen* g, v__ast__Expr val, v__ast__TypeSymbol right_sym, bool add_eq);
VV_LOCAL_SYMBOL void v__gen__c__Gen_autofree_scope_vars(v__gen__c__Gen* g, int pos, int line_nr, bool free_parent_scopes);
VV_LOCAL_SYMBOL void v__gen__c__Gen_autofree_scope_vars_stop(v__gen__c__Gen* g, int pos, int line_nr, bool free_parent_scopes, int stop_pos);
VV_LOCAL_SYMBOL void v__gen__c__Gen_autofree_scope_vars2(v__gen__c__Gen* g, v__ast__Scope* scope, int start_pos, int end_pos, int line_nr, bool free_parent_scopes, int stop_pos);
VV_LOCAL_SYMBOL void v__gen__c__Gen_autofree_variable(v__gen__c__Gen* g, v__ast__Var v);
VV_LOCAL_SYMBOL void v__gen__c__Gen_autofree_var_call(v__gen__c__Gen* g, string free_fn_name, v__ast__Var v);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_anon_fn_decl(v__gen__c__Gen* g, v__ast__AnonFn* node);
VV_LOCAL_SYMBOL multi_return_string_string_string_string v__gen__c__Gen_map_fn_ptrs(v__gen__c__Gen* g, v__ast__TypeSymbol key_typ);
VV_LOCAL_SYMBOL void v__gen__c__Gen_expr(v__gen__c__Gen* g, v__ast__Expr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_type_name(v__gen__c__Gen* g, v__ast__Type type_);
VV_LOCAL_SYMBOL void v__gen__c__Gen_typeof_expr(v__gen__c__Gen* g, v__ast__TypeOf node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_selector_expr(v__gen__c__Gen* g, v__ast__SelectorExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_enum_expr(v__gen__c__Gen* g, v__ast__Expr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_infix_gen_equality(v__gen__c__Gen* g, v__ast__InfixExpr node, v__ast__Type left_type, v__ast__TypeSymbol left_sym, v__ast__TypeSymbol right_sym);
VV_LOCAL_SYMBOL void v__gen__c__Gen_infix_in_or_not_in(v__gen__c__Gen* g, v__ast__InfixExpr node, v__ast__TypeSymbol left_sym, v__ast__TypeSymbol right_sym);
VV_LOCAL_SYMBOL void v__gen__c__Gen_infix_expr(v__gen__c__Gen* g, v__ast__InfixExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_lock_expr(v__gen__c__Gen* g, v__ast__LockExpr node);
VV_LOCAL_SYMBOL bool v__gen__c__Gen_need_tmp_var_in_match(v__gen__c__Gen* g, v__ast__MatchExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_match_expr(v__gen__c__Gen* g, v__ast__MatchExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_match_expr_sumtype(v__gen__c__Gen* g, v__ast__MatchExpr node, bool is_expr, string cond_var, string tmp_var);
VV_LOCAL_SYMBOL void v__gen__c__Gen_match_expr_classic(v__gen__c__Gen* g, v__ast__MatchExpr node, bool is_expr, string cond_var, string tmp_var);
VV_LOCAL_SYMBOL void v__gen__c__Gen_map_init(v__gen__c__Gen* g, v__ast__MapInit node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_select_expr(v__gen__c__Gen* g, v__ast__SelectExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_ident(v__gen__c__Gen* g, v__ast__Ident node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_cast_expr(v__gen__c__Gen* g, v__ast__CastExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_concat_expr(v__gen__c__Gen* g, v__ast__ConcatExpr node);
VV_LOCAL_SYMBOL bool v__gen__c__Gen_need_tmp_var_in_if(v__gen__c__Gen* g, v__ast__IfExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_if_expr(v__gen__c__Gen* g, v__ast__IfExpr node);
VV_LOCAL_SYMBOL bool v__gen__c__Gen_expr_is_multi_return_call(v__gen__c__Gen* g, v__ast__Expr expr);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_optional_error(v__gen__c__Gen* g, v__ast__Type target_type, v__ast__Expr expr);
VV_LOCAL_SYMBOL void v__gen__c__Gen_return_stmt(v__gen__c__Gen* g, v__ast__Return node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_const_decl(v__gen__c__Gen* g, v__ast__ConstDecl node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_const_decl_simple_define(v__gen__c__Gen* g, string name, string val);
VV_LOCAL_SYMBOL void v__gen__c__Gen_const_decl_init_later(v__gen__c__Gen* g, string mod, string name, string val, v__ast__Type typ, bool unwrap_option);
VV_LOCAL_SYMBOL void v__gen__c__Gen_global_decl(v__gen__c__Gen* g, v__ast__GlobalDecl node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_go_back_out(v__gen__c__Gen* g, int n);
Array_string _const_v__gen__c__skip_struct_init; // inited later
VV_LOCAL_SYMBOL void v__gen__c__Gen_struct_init(v__gen__c__Gen* g, v__ast__StructInit struct_init);
VV_LOCAL_SYMBOL void v__gen__c__Gen_zero_struct_field(v__gen__c__Gen* g, v__ast__StructField field);
VV_LOCAL_SYMBOL void v__gen__c__Gen_assoc(v__gen__c__Gen* g, v__ast__Assoc node);
VV_LOCAL_SYMBOL void v__gen__c__verror(string s);
VV_LOCAL_SYMBOL void v__gen__c__Gen_error(v__gen__c__Gen* g, string s, v__token__Position pos);
VV_LOCAL_SYMBOL void v__gen__c__Gen_checker_bug(v__gen__c__Gen* g, string s, v__token__Position pos);
VV_LOCAL_SYMBOL void v__gen__c__Gen_write_init_function(v__gen__c__Gen* g);
Array_string _const_v__gen__c__builtins; // inited later
VV_LOCAL_SYMBOL void v__gen__c__Gen_write_builtin_types(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL void v__gen__c__Gen_write_sorted_types(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL void v__gen__c__Gen_write_types(v__gen__c__Gen* g, Array_v__ast__TypeSymbol types);
VV_LOCAL_SYMBOL Array_v__ast__TypeSymbol v__gen__c__Gen_sort_structs(v__gen__c__Gen* g, Array_v__ast__TypeSymbol typesa);
VV_LOCAL_SYMBOL int v__gen__c__Gen_nth_stmt_pos(v__gen__c__Gen* g, int n);
VV_LOCAL_SYMBOL string v__gen__c__Gen_go_before_stmt(v__gen__c__Gen* g, int n);
VV_LOCAL_SYMBOL string v__gen__c__Gen_go_before_ternary(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL void v__gen__c__Gen_insert_before_stmt(v__gen__c__Gen* g, string s);
VV_LOCAL_SYMBOL string v__gen__c__Gen_write_expr_to_string(v__gen__c__Gen* g, v__ast__Expr expr);
VV_LOCAL_SYMBOL void v__gen__c__Gen_or_block(v__gen__c__Gen* g, string var_name, v__ast__OrExpr or_block, v__ast__Type return_type);
VV_LOCAL_SYMBOL void v__gen__c__Gen_in_optimization(v__gen__c__Gen* g, v__ast__Expr left, v__ast__ArrayInit right);
VV_LOCAL_SYMBOL string v__gen__c__op_to_fn_name(string name);
VV_LOCAL_SYMBOL string v__gen__c__c_name(string name_);
VV_LOCAL_SYMBOL string v__gen__c__Gen_type_default(v__gen__c__Gen* g, v__ast__Type typ_);
VV_LOCAL_SYMBOL Array_string v__gen__c__Gen_get_all_test_function_names(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL bool v__gen__c__Gen_is_importing_os(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL void v__gen__c__Gen_go_expr(v__gen__c__Gen* g, v__ast__GoExpr node);
VV_LOCAL_SYMBOL string v__gen__c__Gen_go_stmt(v__gen__c__Gen* g, v__ast__GoStmt node, bool joinable);
VV_LOCAL_SYMBOL void v__gen__c__Gen_as_cast(v__gen__c__Gen* g, v__ast__AsCast node);
VV_LOCAL_SYMBOL string v__gen__c__Gen_as_cast_name_table(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL void v__gen__c__Gen_is_expr(v__gen__c__Gen* g, v__ast__InfixExpr node);
VV_LOCAL_SYMBOL string v__gen__c__Gen_interface_table(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL multi_return_int_string_string_string v__gen__c__Gen_panic_debug_info(v__gen__c__Gen* g, v__token__Position pos);
string v__gen__c__get_guarded_include_text(string iname, string imessage);
VV_LOCAL_SYMBOL void v__gen__c__Gen_trace(v__gen__c__Gen* g, string fbase, string message);
string _const_v__gen__c__c_commit_hash_default; // a string literal, inited later
string _const_v__gen__c__c_current_commit_hash_default; // a string literal, inited later
string _const_v__gen__c__c_concurrency_helpers; // a string literal, inited later
string _const_v__gen__c__c_common_macros; // a string literal, inited later
string _const_v__gen__c__c_headers; // inited later
string _const_v__gen__c__c_builtin_types; // a string literal, inited later
string _const_v__gen__c__bare_c_headers; // inited later
void v__gen__c__Gen_gen_c_main(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_vlines_reset(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_c_main_function_header(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_c_main_header(v__gen__c__Gen* g);
void v__gen__c__Gen_gen_c_main_footer(v__gen__c__Gen* g);
void v__gen__c__Gen_gen_c_android_sokol_main(v__gen__c__Gen* g);
void v__gen__c__Gen_write_tests_definitions(v__gen__c__Gen* g);
void v__gen__c__Gen_gen_failing_error_propagation_for_test_fn(v__gen__c__Gen* g, v__ast__OrExpr or_block, string cvar_name);
void v__gen__c__Gen_gen_c_main_for_tests(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL void v__gen__c__Gen_comptime_selector(v__gen__c__Gen* g, v__ast__ComptimeSelector node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_comptime_call(v__gen__c__Gen* g, v__ast__ComptimeCall node);
VV_LOCAL_SYMBOL Array_string v__gen__c__cgen_attrs(Array_v__ast__Attr attrs);
VV_LOCAL_SYMBOL void v__gen__c__Gen_comp_at(v__gen__c__Gen* g, v__ast__AtExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_comp_if(v__gen__c__Gen* g, v__ast__IfExpr node);
VV_LOCAL_SYMBOL bool v__gen__c__Gen_comp_if_cond(v__gen__c__Gen* g, v__ast__Expr cond);
VV_LOCAL_SYMBOL void v__gen__c__Gen_comp_for(v__gen__c__Gen* g, v__ast__CompFor node);
VV_LOCAL_SYMBOL Option_string v__gen__c__Gen_comp_if_to_ifdef(v__gen__c__Gen* g, string name, bool is_comptime_optional);
VV_LOCAL_SYMBOL v__ast__CTempVar v__gen__c__Gen_new_ctemp_var(v__gen__c__Gen* g, v__ast__Expr expr, v__ast__Type expr_type);
VV_LOCAL_SYMBOL v__ast__CTempVar v__gen__c__Gen_new_ctemp_var_then_gen(v__gen__c__Gen* g, v__ast__Expr expr, v__ast__Type expr_type);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_ctemp_var(v__gen__c__Gen* g, v__ast__CTempVar tvar);
VV_LOCAL_SYMBOL void v__gen__c__Gen_dump_expr(v__gen__c__Gen* g, v__ast__DumpExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_dump_expr_definitions(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL bool v__gen__c__Gen_embed_file_is_prod_mode(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_embed_file_init(v__gen__c__Gen* g, v__ast__ComptimeCall node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_embedded_data(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL bool v__gen__c__Gen_is_used_by_main(v__gen__c__Gen* g, v__ast__FnDecl node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_process_fn_decl(v__gen__c__Gen* g, v__ast__FnDecl node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_fn_decl(v__gen__c__Gen* g, v__ast__FnDecl node, bool skip);
VV_LOCAL_SYMBOL string v__gen__c__Gen_defer_flag_var(v__gen__c__Gen* g, v__ast__DeferStmt* stmt);
VV_LOCAL_SYMBOL void v__gen__c__Gen_write_defer_stmts_when_needed(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL multi_return_Array_string_Array_string v__gen__c__Gen_fn_args(v__gen__c__Gen* g, Array_v__ast__Param args, bool is_variadic);
VV_LOCAL_SYMBOL void v__gen__c__Gen_call_expr(v__gen__c__Gen* g, v__ast__CallExpr node);
v__ast__Type v__gen__c__Gen_unwrap_generic(v__gen__c__Gen* g, v__ast__Type typ);
VV_LOCAL_SYMBOL void v__gen__c__Gen_method_call(v__gen__c__Gen* g, v__ast__CallExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_fn_call(v__gen__c__Gen* g, v__ast__CallExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_autofree_call_pregen(v__gen__c__Gen* g, v__ast__CallExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_autofree_call_postgen(v__gen__c__Gen* g, int node_pos);
VV_LOCAL_SYMBOL void v__gen__c__Gen_call_args(v__gen__c__Gen* g, v__ast__CallExpr node);
VV_LOCAL_SYMBOL int v__gen__c__Gen_keep_alive_call_pregen(v__gen__c__Gen* g, v__ast__CallExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_keep_alive_call_postgen(v__gen__c__Gen* g, v__ast__CallExpr node, int tmp_cnt_save);
VV_LOCAL_SYMBOL void v__gen__c__Gen_ref_or_deref_arg(v__gen__c__Gen* g, v__ast__CallArg arg, v__ast__Type expected_type, v__ast__Language lang);
VV_LOCAL_SYMBOL bool v__gen__c__Gen_is_gui_app(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL bool v__gen__c__Gen_fileis(v__gen__c__Gen* g, string s);
VV_LOCAL_SYMBOL string v__gen__c__Gen_write_fn_attrs(v__gen__c__Gen* g, Array_v__ast__Attr attrs);
VV_LOCAL_SYMBOL void v__gen__c__Gen_index_expr(v__gen__c__Gen* g, v__ast__IndexExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_range_expr(v__gen__c__Gen* g, v__ast__IndexExpr node, v__ast__RangeExpr range);
VV_LOCAL_SYMBOL void v__gen__c__Gen_index_of_array(v__gen__c__Gen* g, v__ast__IndexExpr node, v__ast__TypeSymbol sym);
VV_LOCAL_SYMBOL void v__gen__c__Gen_index_of_fixed_array(v__gen__c__Gen* g, v__ast__IndexExpr node, v__ast__TypeSymbol sym);
VV_LOCAL_SYMBOL void v__gen__c__Gen_index_of_map(v__gen__c__Gen* g, v__ast__IndexExpr node, v__ast__TypeSymbol sym);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_json_for_type(v__gen__c__Gen* g, v__ast__Type typ);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_struct_enc_dec(v__gen__c__Gen* g, v__ast__TypeInfo type_info, string styp, strings__Builder* enc, strings__Builder* dec);
VV_LOCAL_SYMBOL string v__gen__c__js_enc_name(string typ);
VV_LOCAL_SYMBOL string v__gen__c__js_dec_name(string typ);
VV_LOCAL_SYMBOL bool v__gen__c__is_js_prim(string typ);
VV_LOCAL_SYMBOL string v__gen__c__Gen_decode_array(v__gen__c__Gen* g, v__ast__Type value_type);
VV_LOCAL_SYMBOL string v__gen__c__Gen_encode_array(v__gen__c__Gen* g, v__ast__Type value_type);
VV_LOCAL_SYMBOL string v__gen__c__Gen_decode_map(v__gen__c__Gen* g, v__ast__Type key_type, v__ast__Type value_type);
VV_LOCAL_SYMBOL string v__gen__c__Gen_encode_map(v__gen__c__Gen* g, v__ast__Type key_type, v__ast__Type value_type);
VV_LOCAL_SYMBOL void v__gen__c__Gen_generate_hotcode_reloading_declarations(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL void v__gen__c__Gen_generate_hotcode_reloader_code(v__gen__c__Gen* g);
string _const_v__gen__c__posix_hotcode_definitions_1; // a string literal, inited later
string _const_v__gen__c__windows_hotcode_definitions_1; // a string literal, inited later
VV_LOCAL_SYMBOL void v__gen__c__Gen_generate_hotcode_reloading_main_caller(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL void v__gen__c__Gen_profile_fn(v__gen__c__Gen* g, v__ast__FnDecl fn_decl);
void v__gen__c__Gen_gen_vprint_profile_stats(v__gen__c__Gen* g);
string _const_v__gen__c__dbtype; // a string literal, inited later
VV_LOCAL_SYMBOL void v__gen__c__Gen_sql_stmt(v__gen__c__Gen* g, v__ast__SqlStmt node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_sql_create_table(v__gen__c__Gen* g, v__ast__SqlStmt node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_sql_select_expr(v__gen__c__Gen* g, v__ast__SqlExpr node, bool sub, string line);
VV_LOCAL_SYMBOL void v__gen__c__Gen_sql_bind(v__gen__c__Gen* g, string val, string len, v__ast__Type real_type, v__gen__c__SqlType typ);
VV_LOCAL_SYMBOL string v__gen__c__Gen_sql_type_from_v(v__gen__c__Gen* g, v__gen__c__SqlType typ, v__ast__Type v_typ);
VV_LOCAL_SYMBOL void v__gen__c__Gen_sqlite3_stmt(v__gen__c__Gen* g, v__ast__SqlStmt node, v__gen__c__SqlType typ);
VV_LOCAL_SYMBOL void v__gen__c__Gen_sqlite3_select_expr(v__gen__c__Gen* g, v__ast__SqlExpr node, bool sub, string line, v__gen__c__SqlType sql_typ);
VV_LOCAL_SYMBOL void v__gen__c__Gen_sqlite3_create_table(v__gen__c__Gen* g, v__ast__SqlStmt node, v__gen__c__SqlType typ);
VV_LOCAL_SYMBOL void v__gen__c__Gen_sqlite3_bind(v__gen__c__Gen* g, string val, string len, v__ast__Type typ);
VV_LOCAL_SYMBOL void v__gen__c__Gen_sqlite3_bind_int(v__gen__c__Gen* g, string val);
VV_LOCAL_SYMBOL void v__gen__c__Gen_sqlite3_bind_string(v__gen__c__Gen* g, string val, string len);
VV_LOCAL_SYMBOL string v__gen__c__Gen_sqlite3_type_from_v(v__gen__c__Gen* g, v__ast__Type v_typ);
VV_LOCAL_SYMBOL void v__gen__c__Gen_mysql_stmt(v__gen__c__Gen* g, v__ast__SqlStmt node, v__gen__c__SqlType typ);
VV_LOCAL_SYMBOL void v__gen__c__Gen_mysql_select_expr(v__gen__c__Gen* g, v__ast__SqlExpr node, bool sub, string line, v__gen__c__SqlType typ);
VV_LOCAL_SYMBOL void v__gen__c__Gen_mysql_create_table(v__gen__c__Gen* g, v__ast__SqlStmt node, v__gen__c__SqlType typ);
VV_LOCAL_SYMBOL void v__gen__c__Gen_mysql_bind(v__gen__c__Gen* g, string val, v__ast__Type _t3196);
VV_LOCAL_SYMBOL string v__gen__c__Gen_mysql_get_table_type(v__gen__c__Gen* g, v__ast__Type typ);
VV_LOCAL_SYMBOL string v__gen__c__Gen_mysql_buffer_typ_from_typ(v__gen__c__Gen* g, v__ast__Type typ);
VV_LOCAL_SYMBOL multi_return_string_string v__gen__c__Gen_mysql_buffer_typ_from_field(v__gen__c__Gen* g, v__ast__StructField field);
VV_LOCAL_SYMBOL void v__gen__c__Gen_sql_expr_defaults(v__gen__c__Gen* g, v__ast__SqlExpr node, v__gen__c__SqlType sql_typ);
VV_LOCAL_SYMBOL string v__gen__c__Gen_get_base_sql_select_query(v__gen__c__Gen* g, v__ast__SqlExpr node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_sql_defaults(v__gen__c__Gen* g, v__ast__SqlStmt node, v__gen__c__SqlType typ);
VV_LOCAL_SYMBOL string v__gen__c__Gen_table_gen(v__gen__c__Gen* g, v__ast__SqlStmt node, v__gen__c__SqlType typ);
VV_LOCAL_SYMBOL void v__gen__c__Gen_expr_to_sql(v__gen__c__Gen* g, v__ast__Expr expr, v__gen__c__SqlType typ);
VV_LOCAL_SYMBOL v__ast__Type v__gen__c__Gen_get_struct_field_typ(v__gen__c__Gen* g, string f);
VV_LOCAL_SYMBOL v__ast__Type v__gen__c__Gen_sql_get_real_type(v__gen__c__Gen* g, v__ast__Type typ);
VV_LOCAL_SYMBOL void v__gen__c__Gen_inc_sql_i(v__gen__c__Gen* g, v__gen__c__SqlType typ);
VV_LOCAL_SYMBOL v__gen__c__SqlType v__gen__c__Gen_parse_db_type(v__gen__c__Gen* g, v__ast__Expr expr);
VV_LOCAL_SYMBOL v__gen__c__SqlType v__gen__c__Gen_parse_db_from_type_string(v__gen__c__Gen* g, string name);
VV_LOCAL_SYMBOL v__ast__Type v__gen__c__Gen_get_sql_field_type(v__gen__c__Gen* g, v__ast__StructField field);
VV_LOCAL_SYMBOL void v__gen__c__Gen_write_str_fn_definitions(v__gen__c__Gen* g);
VV_LOCAL_SYMBOL void v__gen__c__Gen_string_literal(v__gen__c__Gen* g, v__ast__StringLiteral node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_string_inter_literal_sb_optimized(v__gen__c__Gen* g, v__ast__CallExpr call_expr);
VV_LOCAL_SYMBOL void v__gen__c__Gen_string_inter_literal(v__gen__c__Gen* g, v__ast__StringInterLiteral node);
VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_expr_to_string(v__gen__c__Gen* g, v__ast__Expr expr, v__ast__Type etype);
void v__markused__mark_used(v__ast__Table* table, v__pref__Preferences* pref, Array_v__ast__File ast_files);
VV_LOCAL_SYMBOL multi_return_Map_string_v__ast__FnDecl_Map_string_v__ast__ConstField v__markused__all_fn_and_const(Array_v__ast__File ast_files);
void v__markused__Walker_mark_fn_as_used(v__markused__Walker* w, string fkey);
void v__markused__Walker_mark_const_as_used(v__markused__Walker* w, string ckey);
void v__markused__Walker_mark_root_fns(v__markused__Walker* w, Array_string all_fn_root_names);
void v__markused__Walker_stmt(v__markused__Walker* w, v__ast__Stmt node);
VV_LOCAL_SYMBOL void v__markused__Walker_asm_io(v__markused__Walker* w, Array_v__ast__AsmIO ios);
VV_LOCAL_SYMBOL void v__markused__Walker_defer_stmts(v__markused__Walker* w, Array_v__ast__DeferStmt stmts);
VV_LOCAL_SYMBOL void v__markused__Walker_stmts(v__markused__Walker* w, Array_v__ast__Stmt stmts);
VV_LOCAL_SYMBOL void v__markused__Walker_exprs(v__markused__Walker* w, Array_v__ast__Expr exprs);
VV_LOCAL_SYMBOL void v__markused__Walker_expr(v__markused__Walker* w, v__ast__Expr node);
void v__markused__Walker_fn_decl(v__markused__Walker* w, v__ast__FnDecl* node);
void v__markused__Walker_call_expr(v__markused__Walker* w, v__ast__CallExpr* node);
void v__markused__Walker_fn_by_name(v__markused__Walker* w, string fn_name);
void v__markused__Walker_struct_fields(v__markused__Walker* w, Array_v__ast__StructField sfields);
void v__markused__Walker_const_fields(v__markused__Walker* w, Array_v__ast__ConstField cfields);
void v__markused__Walker_or_block(v__markused__Walker* w, v__ast__OrExpr node);
VV_LOCAL_SYMBOL string v__gen__js__JsGen_to_js_typ_def_val(v__gen__js__JsGen* g, string s);
VV_LOCAL_SYMBOL string v__gen__js__JsGen_to_js_typ_val(v__gen__js__JsGen* g, v__ast__Type t);
VV_LOCAL_SYMBOL string v__gen__js__JsGen_sym_to_js_typ(v__gen__js__JsGen* g, v__ast__TypeSymbol sym);
string v__gen__js__JsGen_typ(v__gen__js__JsGen* g, v__ast__Type t);
VV_LOCAL_SYMBOL string v__gen__js__JsGen_fn_typ(v__gen__js__JsGen* g, Array_v__ast__Param args, v__ast__Type return_type);
VV_LOCAL_SYMBOL string v__gen__js__JsGen_struct_typ(v__gen__js__JsGen* g, string s);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_builtin_prototype(v__gen__js__JsGen* g, v__gen__js__BuiltinPrototypeConfig c);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_builtin_type_defs(v__gen__js__JsGen* g);
Array_string _const_v__gen__js__js_reserved; // inited later
Array_string _const_v__gen__js__v_types; // inited later
Array_v__ast__Kind _const_v__gen__js__shallow_equatables; // inited later
string v__gen__js__gen(Array_v__ast__File files, v__ast__Table* table, v__pref__Preferences* pref);
void v__gen__js__JsGen_enter_namespace(v__gen__js__JsGen* g, string name);
void v__gen__js__JsGen_escape_namespace(v__gen__js__JsGen* g);
void v__gen__js__JsGen_push_pub_var(v__gen__js__JsGen* g, string s);
void v__gen__js__JsGen_find_class_methods(v__gen__js__JsGen* g, Array_v__ast__Stmt stmts);
void v__gen__js__JsGen_init(v__gen__js__JsGen* g);
string v__gen__js__JsGen_hashes(v__gen__js__JsGen* g);
VV_LOCAL_SYMBOL void v__gen__js__verror(string msg);
void v__gen__js__JsGen_gen_indent(v__gen__js__JsGen* g);
void v__gen__js__JsGen_inc_indent(v__gen__js__JsGen* g);
void v__gen__js__JsGen_dec_indent(v__gen__js__JsGen* g);
void v__gen__js__JsGen_write(v__gen__js__JsGen* g, string s);
void v__gen__js__JsGen_writeln(v__gen__js__JsGen* g, string s);
string v__gen__js__JsGen_new_tmp_var(v__gen__js__JsGen* g);
VV_LOCAL_SYMBOL string v__gen__js__get_ns(string s);
VV_LOCAL_SYMBOL string v__gen__js__JsGen_get_alias(v__gen__js__JsGen* g, string name);
VV_LOCAL_SYMBOL string v__gen__js__JsGen_js_name(v__gen__js__JsGen* g, string name_);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_stmts(v__gen__js__JsGen* g, Array_v__ast__Stmt stmts);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_stmt(v__gen__js__JsGen* g, v__ast__Stmt node);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_expr(v__gen__js__JsGen* g, v__ast__Expr node);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_assert_stmt(v__gen__js__JsGen* g, v__ast__AssertStmt a);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_assign_stmt(v__gen__js__JsGen* g, v__ast__AssignStmt stmt);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_attrs(v__gen__js__JsGen* g, Array_v__ast__Attr attrs);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_block(v__gen__js__JsGen* g, v__ast__Block it);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_branch_stmt(v__gen__js__JsGen* g, v__ast__BranchStmt it);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_const_decl(v__gen__js__JsGen* g, v__ast__ConstDecl it);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_defer_stmts(v__gen__js__JsGen* g);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_enum_decl(v__gen__js__JsGen* g, v__ast__EnumDecl it);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_expr_stmt(v__gen__js__JsGen* g, v__ast__ExprStmt it);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_fn_decl(v__gen__js__JsGen* g, v__ast__FnDecl it);
VV_LOCAL_SYMBOL bool v__gen__js__fn_has_go(v__ast__FnDecl it);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_method_decl(v__gen__js__JsGen* g, v__ast__FnDecl it);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_fn_args(v__gen__js__JsGen* g, Array_v__ast__Param args, bool is_variadic);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_for_c_stmt(v__gen__js__JsGen* g, v__ast__ForCStmt it);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_for_in_stmt(v__gen__js__JsGen* g, v__ast__ForInStmt it);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_for_stmt(v__gen__js__JsGen* g, v__ast__ForStmt it);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_go_stmt(v__gen__js__JsGen* g, v__ast__GoStmt node);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_import_stmt(v__gen__js__JsGen* g, v__ast__Import it);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_interface_decl(v__gen__js__JsGen* g, v__ast__InterfaceDecl it);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_return_stmt(v__gen__js__JsGen* g, v__ast__Return it);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_hash_stmt(v__gen__js__JsGen* g, v__ast__HashStmt it);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_struct_decl(v__gen__js__JsGen* g, v__ast__StructDecl node);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_array_init_expr(v__gen__js__JsGen* g, v__ast__ArrayInit it);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_array_init_values(v__gen__js__JsGen* g, Array_v__ast__Expr exprs);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_call_expr(v__gen__js__JsGen* g, v__ast__CallExpr it);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_ident(v__gen__js__JsGen* g, v__ast__Ident node);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_lock_expr(v__gen__js__JsGen* g, v__ast__LockExpr node);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_if_expr(v__gen__js__JsGen* g, v__ast__IfExpr node);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_index_expr(v__gen__js__JsGen* g, v__ast__IndexExpr expr);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_infix_expr(v__gen__js__JsGen* g, v__ast__InfixExpr it);
VV_LOCAL_SYMBOL v__ast__Type v__gen__js__JsGen_greater_typ(v__gen__js__JsGen* g, v__ast__Type left, v__ast__Type right);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_map_init_expr(v__gen__js__JsGen* g, v__ast__MapInit it);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_selector_expr(v__gen__js__JsGen* g, v__ast__SelectorExpr it);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_string_inter_literal(v__gen__js__JsGen* g, v__ast__StringInterLiteral it);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_string_literal(v__gen__js__JsGen* g, v__ast__StringLiteral it);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_struct_init(v__gen__js__JsGen* g, v__ast__StructInit it);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_typeof_expr(v__gen__js__JsGen* g, v__ast__TypeOf it);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_type_cast_expr(v__gen__js__JsGen* g, v__ast__CastExpr it);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_integer_literal_expr(v__gen__js__JsGen* g, v__ast__IntegerLiteral it);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_float_literal_expr(v__gen__js__JsGen* g, v__ast__FloatLiteral it);
VV_LOCAL_SYMBOL v__gen__js__JsDoc* v__gen__js__new_jsdoc(v__gen__js__JsGen* gen);
VV_LOCAL_SYMBOL void v__gen__js__JsDoc_write(v__gen__js__JsDoc* d, string s);
VV_LOCAL_SYMBOL void v__gen__js__JsDoc_writeln(v__gen__js__JsDoc* d, string s);
VV_LOCAL_SYMBOL void v__gen__js__JsDoc_gen_typ(v__gen__js__JsDoc* d, string typ);
VV_LOCAL_SYMBOL void v__gen__js__JsDoc_gen_const(v__gen__js__JsDoc* d, string typ);
VV_LOCAL_SYMBOL void v__gen__js__JsDoc_gen_enum(v__gen__js__JsDoc* d);
VV_LOCAL_SYMBOL void v__gen__js__JsDoc_gen_fac_fn(v__gen__js__JsDoc* d, Array_v__ast__StructField fields);
VV_LOCAL_SYMBOL void v__gen__js__JsDoc_gen_fn(v__gen__js__JsDoc* d, v__ast__FnDecl it);
VV_LOCAL_SYMBOL void v__gen__js__JsDoc_gen_interface(v__gen__js__JsDoc* d, v__ast__InterfaceDecl it);
string _const_v__gen__js__fast_deep_eq_fn; // a string literal, inited later
byte _const_v__gen__x64__mag0; // inited later
#define _const_v__gen__x64__mag1 L'E'
#define _const_v__gen__x64__mag2 L'L'
#define _const_v__gen__x64__mag3 L'F'
#define _const_v__gen__x64__ei_class 4
#define _const_v__gen__x64__elfclass64 2
#define _const_v__gen__x64__elfdata2lsb 1
#define _const_v__gen__x64__ev_current 1
#define _const_v__gen__x64__elf_osabi 0
#define _const_v__gen__x64__et_rel 1
#define _const_v__gen__x64__et_exec 2
#define _const_v__gen__x64__et_dyn 3
#define _const_v__gen__x64__e_machine 0x3e
#define _const_v__gen__x64__shn_xindex 0xffff
#define _const_v__gen__x64__sht_null 0
#define _const_v__gen__x64__segment_start 0x400000
#define _const_v__gen__x64__placeholder 0
#define _const_v__gen__x64__sevens 0x77777777
void v__gen__x64__Gen_generate_elf_header(v__gen__x64__Gen* g);
void v__gen__x64__Gen_generate_elf_footer(v__gen__x64__Gen* g);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_section_header(v__gen__x64__Gen* g, v__gen__x64__SectionConfig c);
VV_LOCAL_SYMBOL void v__gen__x64__genobj();
Array_v__gen__x64__Register _const_v__gen__x64__fn_arg_registers; // inited later
multi_return_int_int v__gen__x64__gen(Array_v__ast__File files, v__ast__Table* table, string out_name, v__pref__Preferences* pref);
void v__gen__x64__Gen_stmts(v__gen__x64__Gen* g, Array_v__ast__Stmt stmts);
i64 v__gen__x64__Gen_pos(v__gen__x64__Gen* g);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_write8(v__gen__x64__Gen* g, int n);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_write16(v__gen__x64__Gen* g, int n);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_write32(v__gen__x64__Gen* g, int n);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_write64(v__gen__x64__Gen* g, i64 n);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_write64_at(v__gen__x64__Gen* g, i64 n, i64 at);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_write32_at(v__gen__x64__Gen* g, i64 at, int n);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_write_string(v__gen__x64__Gen* g, string s);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_write_string_with_padding(v__gen__x64__Gen* g, string s, int max);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_inc(v__gen__x64__Gen* g, v__gen__x64__Register reg);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_cmp(v__gen__x64__Gen* g, v__gen__x64__Register reg, v__gen__x64__Size size, i64 val);
VV_LOCAL_SYMBOL int v__gen__x64__Gen_get_var_offset(v__gen__x64__Gen* g, string var_name);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_cmp_var(v__gen__x64__Gen* g, string var_name, int val);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_inc_var(v__gen__x64__Gen* g, string var_name);
VV_LOCAL_SYMBOL int v__gen__x64__Gen_jne(v__gen__x64__Gen* g);
VV_LOCAL_SYMBOL int v__gen__x64__Gen_jge(v__gen__x64__Gen* g);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_jmp(v__gen__x64__Gen* g, int addr);
VV_LOCAL_SYMBOL i64 v__gen__x64__abs(i64 a);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_jle(v__gen__x64__Gen* g, i64 addr);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_println(v__gen__x64__Gen* g, string comment);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_jl(v__gen__x64__Gen* g, i64 addr);
VV_LOCAL_SYMBOL int v__gen__x64__Gen_abs_to_rel_addr(v__gen__x64__Gen* g, i64 addr);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_mov64(v__gen__x64__Gen* g, v__gen__x64__Register reg, i64 val);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_mov_reg_to_rbp(v__gen__x64__Gen* g, int var_offset, v__gen__x64__Register reg);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_mov_var_to_reg(v__gen__x64__Gen* g, v__gen__x64__Register reg, int var_offset);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_call(v__gen__x64__Gen* g, int addr);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_syscall(v__gen__x64__Gen* g);
void v__gen__x64__Gen_ret(v__gen__x64__Gen* g);
void v__gen__x64__Gen_push(v__gen__x64__Gen* g, v__gen__x64__Register reg);
void v__gen__x64__Gen_pop(v__gen__x64__Gen* g, v__gen__x64__Register reg);
void v__gen__x64__Gen_sub32(v__gen__x64__Gen* g, v__gen__x64__Register reg, int val);
void v__gen__x64__Gen_sub8(v__gen__x64__Gen* g, v__gen__x64__Register reg, int val);
void v__gen__x64__Gen_add(v__gen__x64__Gen* g, v__gen__x64__Register reg, int val);
void v__gen__x64__Gen_add8(v__gen__x64__Gen* g, v__gen__x64__Register reg, int val);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_add8_var(v__gen__x64__Gen* g, v__gen__x64__Register reg, int var_offset);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_sub8_var(v__gen__x64__Gen* g, v__gen__x64__Register reg, int var_offset);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_mul8_var(v__gen__x64__Gen* g, v__gen__x64__Register reg, int var_offset);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_leave(v__gen__x64__Gen* g);
int v__gen__x64__Gen_gen_loop_start(v__gen__x64__Gen* g, int from);
void v__gen__x64__Gen_gen_loop_end(v__gen__x64__Gen* g, int to, int label);
void v__gen__x64__Gen_save_main_fn_addr(v__gen__x64__Gen* g);
void v__gen__x64__Gen_gen_print_from_expr(v__gen__x64__Gen* g, v__ast__Expr expr, bool newline);
void v__gen__x64__Gen_gen_print(v__gen__x64__Gen* g, string s);
void v__gen__x64__Gen_gen_exit(v__gen__x64__Gen* g);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_mov(v__gen__x64__Gen* g, v__gen__x64__Register reg, int val);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_mov_reg(v__gen__x64__Gen* g, v__gen__x64__Register a, v__gen__x64__Register b);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_mov_rbp_rsp(v__gen__x64__Gen* g);
void v__gen__x64__Gen_register_function_address(v__gen__x64__Gen* g, string name);
void v__gen__x64__Gen_call_fn(v__gen__x64__Gen* g, v__ast__CallExpr node);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_stmt(v__gen__x64__Gen* g, v__ast__Stmt node);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_expr(v__gen__x64__Gen* g, v__ast__Expr node);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_allocate_var(v__gen__x64__Gen* g, string name, int size, int initial_val);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_assign_stmt(v__gen__x64__Gen* g, v__ast__AssignStmt node);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_infix_expr(v__gen__x64__Gen* g, v__ast__InfixExpr node);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_if_expr(v__gen__x64__Gen* g, v__ast__IfExpr node);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_for_stmt(v__gen__x64__Gen* g, v__ast__ForStmt node);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_fn_decl(v__gen__x64__Gen* g, v__ast__FnDecl node);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_postfix_expr(v__gen__x64__Gen* g, v__ast__PostfixExpr node);
VV_LOCAL_SYMBOL void v__gen__x64__verror(string s);
void v__gen__x64__Gen_error_with_pos(v__gen__x64__Gen* g, string s, v__token__Position pos);
#define _const_v__gen__x64__s_attr_some_instructions 0x00000400
#define _const_v__gen__x64__s_attr_pure_instructions 0x80000000
#define _const_v__gen__x64__s_attr_ext_reloc 0x00000200
#define _const_v__gen__x64__s_attr_loc_reloc 0x00000100
#define _const_v__gen__x64__macho_symcmd_size 0x18
#define _const_v__gen__x64__macho_d_size 0x50
#define _const_v__gen__x64__lc_symtab 0x2
#define _const_v__gen__x64__lc_dymsymtab 0xB
void v__gen__x64__Gen_generate_macho_header(v__gen__x64__Gen* g);
void v__gen__x64__Gen_generate_macho_footer(v__gen__x64__Gen* g);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_sym_table_command(v__gen__x64__Gen* g);
void v__gen__x64__Gen_zeroes(v__gen__x64__Gen* g, int n);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_mov_arm(v__gen__x64__Gen* g, v__gen__x64__Register2 reg, u64 val);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_adr(v__gen__x64__Gen* g);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_bl(v__gen__x64__Gen* g);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_svc(v__gen__x64__Gen* g);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_write_relocs(v__gen__x64__Gen* g);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_sym_table(v__gen__x64__Gen* g);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_write_symbol(v__gen__x64__Gen* g, v__gen__x64__Symbol s);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_sym_string_table(v__gen__x64__Gen* g);
v__builder__Builder v__builder__new_builder(v__pref__Preferences* pref);
void v__builder__Builder_parse_imports(v__builder__Builder* b);
void v__builder__Builder_resolve_deps(v__builder__Builder* b);
v__depgraph__DepGraph* v__builder__Builder_import_graph(v__builder__Builder* b);
Array_string v__builder__Builder_v_files_from_dir(v__builder__Builder* b, string dir);
void v__builder__Builder_log(v__builder__Builder* b, string s);
void v__builder__Builder_info(v__builder__Builder* b, string s);
VV_LOCAL_SYMBOL string v__builder__module_path(string mod);
Option_string v__builder__Builder_find_module_path(v__builder__Builder* b, string mod, string fpath);
VV_LOCAL_SYMBOL void v__builder__Builder_show_total_warns_and_errors_stats(v__builder__Builder* b);
VV_LOCAL_SYMBOL void v__builder__Builder_print_warnings_and_errors(v__builder__Builder* b);
VV_LOCAL_SYMBOL void v__builder__error_with_pos(string s, string fpath, v__token__Position pos);
VV_LOCAL_SYMBOL void v__builder__verror(string s);
string v__builder__Builder_gen_c(v__builder__Builder* b, Array_string v_files);
void v__builder__Builder_build_c(v__builder__Builder* b, Array_string v_files, string out_file);
void v__builder__Builder_compile_c(v__builder__Builder* b);
string _const_v__builder__c_verror_message_marker; // a string literal, inited later
string _const_v__builder__c_error_info; // a string literal, inited later
string _const_v__builder__no_compiler_error; // a string literal, inited later
string _const_v__builder__mingw_cc; // a string literal, inited later
VV_LOCAL_SYMBOL Option_void v__builder__Builder_find_win_cc(v__builder__Builder* v);
VV_LOCAL_SYMBOL void v__builder__Builder_show_c_compiler_output(v__builder__Builder* v, os__Result res);
VV_LOCAL_SYMBOL void v__builder__Builder_post_process_c_compiler_output(v__builder__Builder* v, os__Result res);
VV_LOCAL_SYMBOL string v__builder__Builder_rebuild_cached_module(v__builder__Builder* v, string vexe, string imp_path);
VV_LOCAL_SYMBOL void v__builder__Builder_show_cc(v__builder__Builder* v, string cmd, string response_file, string response_file_content);
VV_LOCAL_SYMBOL void v__builder__Builder_setup_ccompiler_options(v__builder__Builder* v, string ccompiler);
VV_LOCAL_SYMBOL Array_string v__builder__CcompilerOptions_all_args(v__builder__CcompilerOptions* ccoptions);
VV_LOCAL_SYMBOL Array_string v__builder__CcompilerOptions_thirdparty_object_args(v__builder__CcompilerOptions* ccoptions, Array_string middle);
VV_LOCAL_SYMBOL void v__builder__Builder_setup_output_name(v__builder__Builder* v);
VV_LOCAL_SYMBOL bool v__builder__Builder_vjs_cc(v__builder__Builder* v);
VV_LOCAL_SYMBOL void v__builder__Builder_dump_c_options(v__builder__Builder* v, Array_string all_args);
VV_LOCAL_SYMBOL void v__builder__Builder_cc(v__builder__Builder* v);
VV_LOCAL_SYMBOL void v__builder__Builder_cc_linux_cross(v__builder__Builder* b);
VV_LOCAL_SYMBOL void v__builder__Builder_cc_windows_cross(v__builder__Builder* c);
VV_LOCAL_SYMBOL void v__builder__Builder_build_thirdparty_obj_files(v__builder__Builder* b);
VV_LOCAL_SYMBOL void v__builder__Builder_build_thirdparty_obj_file(v__builder__Builder* v, string path, Array_v__cflag__CFlag moduleflags);
VV_LOCAL_SYMBOL string v__builder__missing_compiler_info();
VV_LOCAL_SYMBOL Array_string v__builder__error_context_lines(string text, string keyword, int before, int after);
VV_LOCAL_SYMBOL Array_v__cflag__CFlag v__builder__Builder_get_os_cflags(v__builder__Builder* v);
VV_LOCAL_SYMBOL Array_v__cflag__CFlag v__builder__Builder_get_rest_of_module_cflags(v__builder__Builder* v, v__cflag__CFlag* c);
VV_LOCAL_SYMBOL string v__builder__Builder_get_vtmp_filename(v__builder__Builder* b, string base_file_name, string postfix);
void v__builder__compile(string command, v__pref__Preferences* pref);
VV_LOCAL_SYMBOL void v__builder__Builder_myfree(v__builder__Builder* b);
VV_LOCAL_SYMBOL void v__builder__Builder_exit_on_invalid_syntax(v__builder__Builder* b);
VV_LOCAL_SYMBOL void v__builder__Builder_run_compiled_executable_and_exit(v__builder__Builder* b);
VV_LOCAL_SYMBOL void v__builder__Builder_cleanup_run_executable_after_exit(v__builder__Builder* v, string exefile);
VV_LOCAL_SYMBOL void v__builder__Builder_set_module_lookup_paths(v__builder__Builder* v);
Array_string v__builder__Builder_get_builtin_files(v__builder__Builder* v);
Array_string v__builder__Builder_get_user_files(v__builder__Builder* v);
string v__builder__Builder_gen_js(v__builder__Builder* b, Array_string v_files);
void v__builder__Builder_build_js(v__builder__Builder* b, Array_string v_files, string out_file);
void v__builder__Builder_compile_js(v__builder__Builder* b);
VV_LOCAL_SYMBOL void v__builder__Builder_run_js(v__builder__Builder* b);
v__builder__RegKey _const_v__builder__hkey_local_machine; // inited later
int _const_v__builder__key_query_value; // inited later
int _const_v__builder__key_wow64_32key; // inited later
int _const_v__builder__key_enumerate_sub_keys; // inited later
VV_LOCAL_SYMBOL Option_string v__builder__find_windows_kit_internal(v__builder__RegKey key, Array_string versions);
VV_LOCAL_SYMBOL Option_v__builder__WindowsKit v__builder__find_windows_kit_root(string target_arch);
VV_LOCAL_SYMBOL Option_v__builder__VsInstallation v__builder__find_vs(string vswhere_dir, string host_arch, string target_arch);
VV_LOCAL_SYMBOL Option_v__builder__MsvcResult v__builder__find_msvc(bool m64_target);
void v__builder__Builder_cc_msvc(v__builder__Builder* v);
VV_LOCAL_SYMBOL void v__builder__Builder_build_thirdparty_obj_file_with_msvc(v__builder__Builder* v, string path, Array_v__cflag__CFlag moduleflags);
v__builder__MsvcStringFlags v__builder__msvc_string_flags(Array_v__cflag__CFlag cflags);
void v__builder__Builder_build_x64(v__builder__Builder* b, Array_string v_files, string out_file);
void v__builder__Builder_compile_x64(v__builder__Builder* b);
Array_string _const_main__external_tools; // inited later
Array_string _const_main__list_of_flags_that_allow_duplicates; // inited later
VV_LOCAL_SYMBOL void main__main();
VV_LOCAL_SYMBOL void main__invoke_help_and_exit(Array_string remaining);

// V interface table:
static IError I_None___to_Interface_IError(None__* x);
int _IError_None___index = 0;
static IError I_Error_to_Interface_IError(Error* x);
int _IError_Error_index = 1;
static IError I_flag__UnkownFlagError_to_Interface_IError(flag__UnkownFlagError* x);
int _IError_flag__UnkownFlagError_index = 2;
static IError I_flag__MinimumArgsCountError_to_Interface_IError(flag__MinimumArgsCountError* x);
int _IError_flag__MinimumArgsCountError_index = 3;
static IError I_flag__MaximumArgsCountError_to_Interface_IError(flag__MaximumArgsCountError* x);
int _IError_flag__MaximumArgsCountError_index = 4;
static IError I_flag__NoArgsExpectedError_to_Interface_IError(flag__NoArgsExpectedError* x);
int _IError_flag__NoArgsExpectedError_index = 5;
static IError I_semver__InvalidComparatorFormatError_to_Interface_IError(semver__InvalidComparatorFormatError* x);
int _IError_semver__InvalidComparatorFormatError_index = 6;
static IError I_semver__EmptyInputError_to_Interface_IError(semver__EmptyInputError* x);
int _IError_semver__EmptyInputError_index = 7;
static IError I_semver__InvalidVersionFormatError_to_Interface_IError(semver__InvalidVersionFormatError* x);
int _IError_semver__InvalidVersionFormatError_index = 8;
// ^^^ number of types for interface IError: 9


// Casting functions for converting "None__" to interface "IError"
static inline IError I_None___to_Interface_IError(None__* x) {
	return (IError) {
		._None__ = x,
		._typ = _IError_None___index,
		.msg = (string*)((char*)x + __offsetof_ptr(x, None__, msg)),
		.code = (int*)((char*)x + __offsetof_ptr(x, None__, code)),
	};
}

// Casting functions for converting "Error" to interface "IError"
static inline IError I_Error_to_Interface_IError(Error* x) {
	return (IError) {
		._Error = x,
		._typ = _IError_Error_index,
		.msg = (string*)((char*)x + __offsetof_ptr(x, Error, msg)),
		.code = (int*)((char*)x + __offsetof_ptr(x, Error, code)),
	};
}

// Casting functions for converting "flag__UnkownFlagError" to interface "IError"
static inline IError I_flag__UnkownFlagError_to_Interface_IError(flag__UnkownFlagError* x) {
	return (IError) {
		._flag__UnkownFlagError = x,
		._typ = _IError_flag__UnkownFlagError_index,
		.msg = (string*)((char*)x + __offsetof_ptr(x, flag__UnkownFlagError, msg)),
		.code = (int*)((char*)x + __offsetof_ptr(x, flag__UnkownFlagError, code)),
	};
}

// Casting functions for converting "flag__MinimumArgsCountError" to interface "IError"
static inline IError I_flag__MinimumArgsCountError_to_Interface_IError(flag__MinimumArgsCountError* x) {
	return (IError) {
		._flag__MinimumArgsCountError = x,
		._typ = _IError_flag__MinimumArgsCountError_index,
		.msg = (string*)((char*)x + __offsetof_ptr(x, flag__MinimumArgsCountError, msg)),
		.code = (int*)((char*)x + __offsetof_ptr(x, flag__MinimumArgsCountError, code)),
	};
}

// Casting functions for converting "flag__MaximumArgsCountError" to interface "IError"
static inline IError I_flag__MaximumArgsCountError_to_Interface_IError(flag__MaximumArgsCountError* x) {
	return (IError) {
		._flag__MaximumArgsCountError = x,
		._typ = _IError_flag__MaximumArgsCountError_index,
		.msg = (string*)((char*)x + __offsetof_ptr(x, flag__MaximumArgsCountError, msg)),
		.code = (int*)((char*)x + __offsetof_ptr(x, flag__MaximumArgsCountError, code)),
	};
}

// Casting functions for converting "flag__NoArgsExpectedError" to interface "IError"
static inline IError I_flag__NoArgsExpectedError_to_Interface_IError(flag__NoArgsExpectedError* x) {
	return (IError) {
		._flag__NoArgsExpectedError = x,
		._typ = _IError_flag__NoArgsExpectedError_index,
		.msg = (string*)((char*)x + __offsetof_ptr(x, flag__NoArgsExpectedError, msg)),
		.code = (int*)((char*)x + __offsetof_ptr(x, flag__NoArgsExpectedError, code)),
	};
}

// Casting functions for converting "semver__InvalidComparatorFormatError" to interface "IError"
static inline IError I_semver__InvalidComparatorFormatError_to_Interface_IError(semver__InvalidComparatorFormatError* x) {
	return (IError) {
		._semver__InvalidComparatorFormatError = x,
		._typ = _IError_semver__InvalidComparatorFormatError_index,
		.msg = (string*)((char*)x + __offsetof_ptr(x, semver__InvalidComparatorFormatError, msg)),
		.code = (int*)((char*)x + __offsetof_ptr(x, semver__InvalidComparatorFormatError, code)),
	};
}

// Casting functions for converting "semver__EmptyInputError" to interface "IError"
static inline IError I_semver__EmptyInputError_to_Interface_IError(semver__EmptyInputError* x) {
	return (IError) {
		._semver__EmptyInputError = x,
		._typ = _IError_semver__EmptyInputError_index,
		.msg = (string*)((char*)x + __offsetof_ptr(x, semver__EmptyInputError, msg)),
		.code = (int*)((char*)x + __offsetof_ptr(x, semver__EmptyInputError, code)),
	};
}

// Casting functions for converting "semver__InvalidVersionFormatError" to interface "IError"
static inline IError I_semver__InvalidVersionFormatError_to_Interface_IError(semver__InvalidVersionFormatError* x) {
	return (IError) {
		._semver__InvalidVersionFormatError = x,
		._typ = _IError_semver__InvalidVersionFormatError_index,
		.msg = (string*)((char*)x + __offsetof_ptr(x, semver__InvalidVersionFormatError, msg)),
		.code = (int*)((char*)x + __offsetof_ptr(x, semver__InvalidVersionFormatError, code)),
	};
}

// ^^^ number of types for interface hash__Hasher: 0

// Methods wrapper for interface "hash__Hasher"

typedef Array_byte (*_hash__Hasher_sum_fn)(void* _, Array_byte b);
typedef int (*_hash__Hasher_size_fn)(void* _);
typedef int (*_hash__Hasher_block_size_fn)(void* _);

struct _hash__Hasher_interface_methods {
	_hash__Hasher_sum_fn _method_sum;
	_hash__Hasher_size_fn _method_size;
	_hash__Hasher_block_size_fn _method_block_size;
};

struct _hash__Hasher_interface_methods hash__Hasher_name_table[1];



// ^^^ number of types for interface hash__Hash32er: 0

// Methods wrapper for interface "hash__Hash32er"

typedef u32 (*_hash__Hash32er_sum32_fn)(void* _);

struct _hash__Hash32er_interface_methods {
	_hash__Hash32er_sum32_fn _method_sum32;
};

struct _hash__Hash32er_interface_methods hash__Hash32er_name_table[1];



// ^^^ number of types for interface hash__Hash64er: 0

// Methods wrapper for interface "hash__Hash64er"

typedef u64 (*_hash__Hash64er_sum64_fn)(void* _);

struct _hash__Hash64er_interface_methods {
	_hash__Hash64er_sum64_fn _method_sum64;
};

struct _hash__Hash64er_interface_methods hash__Hash64er_name_table[1];



static rand__PRNG I_rand__wyrand__WyRandRNG_to_Interface_rand__PRNG(rand__wyrand__WyRandRNG* x);
int _rand__PRNG_rand__wyrand__WyRandRNG_index = 0;
// ^^^ number of types for interface rand__PRNG: 1

// Methods wrapper for interface "rand__PRNG"

typedef void (*_rand__PRNG_seed_fn)(void* _, Array_u32 seed_data);
typedef u32 (*_rand__PRNG_u32_fn)(void* _);
typedef u64 (*_rand__PRNG_u64_fn)(void* _);
typedef u32 (*_rand__PRNG_u32n_fn)(void* _, u32 max);
typedef u64 (*_rand__PRNG_u64n_fn)(void* _, u64 max);
typedef u32 (*_rand__PRNG_u32_in_range_fn)(void* _, u32 min, u32 max);
typedef u64 (*_rand__PRNG_u64_in_range_fn)(void* _, u64 min, u64 max);
typedef int (*_rand__PRNG_int_fn)(void* _);
typedef i64 (*_rand__PRNG_i64_fn)(void* _);
typedef int (*_rand__PRNG_int31_fn)(void* _);
typedef i64 (*_rand__PRNG_int63_fn)(void* _);
typedef int (*_rand__PRNG_intn_fn)(void* _, int max);
typedef i64 (*_rand__PRNG_i64n_fn)(void* _, i64 max);
typedef int (*_rand__PRNG_int_in_range_fn)(void* _, int min, int max);
typedef i64 (*_rand__PRNG_i64_in_range_fn)(void* _, i64 min, i64 max);
typedef f32 (*_rand__PRNG_f32_fn)(void* _);
typedef f64 (*_rand__PRNG_f64_fn)(void* _);
typedef f32 (*_rand__PRNG_f32n_fn)(void* _, f32 max);
typedef f64 (*_rand__PRNG_f64n_fn)(void* _, f64 max);
typedef f32 (*_rand__PRNG_f32_in_range_fn)(void* _, f32 min, f32 max);
typedef f64 (*_rand__PRNG_f64_in_range_fn)(void* _, f64 min, f64 max);

struct _rand__PRNG_interface_methods {
	_rand__PRNG_seed_fn _method_seed;
	_rand__PRNG_u32_fn _method_u32;
	_rand__PRNG_u64_fn _method_u64;
	_rand__PRNG_u32n_fn _method_u32n;
	_rand__PRNG_u64n_fn _method_u64n;
	_rand__PRNG_u32_in_range_fn _method_u32_in_range;
	_rand__PRNG_u64_in_range_fn _method_u64_in_range;
	_rand__PRNG_int_fn _method_v_int;
	_rand__PRNG_i64_fn _method_i64;
	_rand__PRNG_int31_fn _method_int31;
	_rand__PRNG_int63_fn _method_int63;
	_rand__PRNG_intn_fn _method_intn;
	_rand__PRNG_i64n_fn _method_i64n;
	_rand__PRNG_int_in_range_fn _method_int_in_range;
	_rand__PRNG_i64_in_range_fn _method_i64_in_range;
	_rand__PRNG_f32_fn _method_f32;
	_rand__PRNG_f64_fn _method_f64;
	_rand__PRNG_f32n_fn _method_f32n;
	_rand__PRNG_f64n_fn _method_f64n;
	_rand__PRNG_f32_in_range_fn _method_f32_in_range;
	_rand__PRNG_f64_in_range_fn _method_f64_in_range;
};

struct _rand__PRNG_interface_methods rand__PRNG_name_table[1] = {
	{
		._method_seed = (void*) rand__wyrand__WyRandRNG_seed,
		._method_u32 = (void*) rand__wyrand__WyRandRNG_u32,
		._method_u64 = (void*) rand__wyrand__WyRandRNG_u64,
		._method_u32n = (void*) rand__wyrand__WyRandRNG_u32n,
		._method_u64n = (void*) rand__wyrand__WyRandRNG_u64n,
		._method_u32_in_range = (void*) rand__wyrand__WyRandRNG_u32_in_range,
		._method_u64_in_range = (void*) rand__wyrand__WyRandRNG_u64_in_range,
		._method_v_int = (void*) rand__wyrand__WyRandRNG_int,
		._method_i64 = (void*) rand__wyrand__WyRandRNG_i64,
		._method_int31 = (void*) rand__wyrand__WyRandRNG_int31,
		._method_int63 = (void*) rand__wyrand__WyRandRNG_int63,
		._method_intn = (void*) rand__wyrand__WyRandRNG_intn,
		._method_i64n = (void*) rand__wyrand__WyRandRNG_i64n,
		._method_int_in_range = (void*) rand__wyrand__WyRandRNG_int_in_range,
		._method_i64_in_range = (void*) rand__wyrand__WyRandRNG_i64_in_range,
		._method_f32 = (void*) rand__wyrand__WyRandRNG_f32,
		._method_f64 = (void*) rand__wyrand__WyRandRNG_f64,
		._method_f32n = (void*) rand__wyrand__WyRandRNG_f32n,
		._method_f64n = (void*) rand__wyrand__WyRandRNG_f64n,
		._method_f32_in_range = (void*) rand__wyrand__WyRandRNG_f32_in_range,
		._method_f64_in_range = (void*) rand__wyrand__WyRandRNG_f64_in_range,
	},
};


// Casting functions for converting "rand__wyrand__WyRandRNG" to interface "rand__PRNG"
static inline rand__PRNG I_rand__wyrand__WyRandRNG_to_Interface_rand__PRNG(rand__wyrand__WyRandRNG* x) {
	return (rand__PRNG) {
		._rand__wyrand__WyRandRNG = x,
		._typ = _rand__PRNG_rand__wyrand__WyRandRNG_index,
	};
}


// V stringliterals:

// >> string literal consts
void vinit_string_literals(){
	_const_math__bits__overflow_error = _SLIT("Overflow Error");
	_const_math__bits__divide_error = _SLIT("Divide Error");
	_const_strconv__base_digits = _SLIT("0123456789abcdefghijklmnopqrstuvwxyz");
	_const_digit_pairs = _SLIT("00102030405060708090011121314151617181910212223242526272829203132333435363738393041424344454647484940515253545556575859506162636465666768696071727374757677787970818283848586878889809192939495969798999");
	_const_os__path_separator = _SLIT("\\");
	_const_os__path_delimiter = _SLIT(";");
	_const_time__days_string = _SLIT("MonTueWedThuFriSatSun");
	_const_time__months_string = _SLIT("JanFebMarAprMayJunJulAugSepOctNovDec");
	_const_flag__space = _SLIT("                            ");
	_const_flag__underline = _SLIT("-----------------------------------------------");
	_const_semver__comparator_sep = _SLIT(" ");
	_const_semver__comparator_set_sep = _SLIT(" || ");
	_const_semver__hyphen_range_sep = _SLIT(" - ");
	_const_semver__x_range_symbols = _SLIT("Xx*");
	_const_v__cflag__fexisting_literal = _SLIT("$first_existing");
	_const_v__pkgconfig__version = _SLIT("0.3.1");
	_const_rand__english_letters = _SLIT("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
	_const_rand__hex_chars = _SLIT("abcdef0123456789");
	_const_rand__ascii_chars = _SLIT("!\"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ\\^_`abcdefghijklmnopqrstuvwxyz{|}~");
	_const_rand__ulid_encoding = _SLIT("0123456789ABCDEFGHJKMNPQRSTVWXYZ");
	_const_help__unknown_topic = _SLIT("`v help`: unknown help topic provided. Use `v help` for usage information.");
	_const_v__util__v_version = _SLIT("0.2.2");
	_const_v__util__map_prefix = _SLIT("map[string]");
	_const_v__parser__tmpl_str_start = _SLIT("sb.write_string('");
	_const_v__parser__tmpl_str_end = _SLIT("' ) ");
	_const_v__gen__c__c_commit_hash_default = _SLIT("\n#ifndef V_COMMIT_HASH\n	#define V_COMMIT_HASH \"@@@\"\n#endif\n");
	_const_v__gen__c__c_current_commit_hash_default = _SLIT("\n#ifndef V_CURRENT_COMMIT_HASH\n	#define V_CURRENT_COMMIT_HASH \"@@@\"\n#endif\n");
	_const_v__gen__c__c_concurrency_helpers = _SLIT("\ntypedef struct __shared_map __shared_map;\nstruct __shared_map { map val; sync__RwMutex mtx; };\nstatic inline voidptr __dup_shared_map(voidptr src, int sz) {\n	__shared_map* dest = memdup(src, sz);\n	sync__RwMutex_init(&dest->mtx);\n	return dest;\n}\ntypedef struct __shared_array __shared_array;\nstruct __shared_array { array val; sync__RwMutex mtx; };\nstatic inline voidptr __dup_shared_array(voidptr src, int sz) {\n	__shared_array* dest = memdup(src, sz);\n	sync__RwMutex_init(&dest->mtx);\n	return dest;\n}\nstatic inline void __sort_ptr(uintptr_t a[], bool b[], int l)\n{\n	for (int i=1; i<l; i++) {\n		uintptr_t ins = a[i];\n		bool insb = b[i];\n		int j = i;\n		while(j>0 && a[j-1] > ins) {\n			a[j] = a[j-1];\n			b[j] = b[j-1];\n			j--;\n		}\n		a[j] = ins;\n		b[j] = insb;\n	}\n}\n");
	_const_v__gen__c__c_common_macros = _SLIT("\n#define EMPTY_VARG_INITIALIZATION 0\n#define EMPTY_STRUCT_DECLARATION\n#define EMPTY_STRUCT_INITIALIZATION 0\n// Due to a tcc bug, the length of an array needs to be specified, but GCC crashes if it is...\n#define EMPTY_ARRAY_OF_ELEMS(x,n) (x[])\n#define TCCSKIP(x) x\n\n#define __NOINLINE __attribute__((noinline))\n#define __IRQHANDLER __attribute__((interrupt))\n\n#if defined(__x86_64__)\n#define __V_amd64  1\n#endif\n#if defined(__aarch64__) || defined(__arm64__)\n#define __V_aarch64  1\n#endif\n\n// Using just __GNUC__ for detecting gcc, is not reliable because other compilers define it too:\n#ifdef __GNUC__\n	#define __V_GCC__\n#endif\n#ifdef __TINYC__\n	#undef __V_GCC__\n#endif\n#ifdef __cplusplus\n	#undef __V_GCC__\n#endif\n#ifdef __clang__\n	#undef __V_GCC__\n#endif\n#ifdef _MSC_VER\n	#undef __V_GCC__\n#endif\n\n#ifdef __TINYC__\n	#undef EMPTY_STRUCT_DECLARATION\n	#undef EMPTY_STRUCT_INITIALIZATION\n	#define EMPTY_STRUCT_DECLARATION char _dummy\n	#define EMPTY_STRUCT_INITIALIZATION 0\n	#undef EMPTY_ARRAY_OF_ELEMS\n	#define EMPTY_ARRAY_OF_ELEMS(x,n) (x[n])\n	#undef __NOINLINE\n	#undef __IRQHANDLER\n	// tcc does not support inlining at all\n	#define __NOINLINE\n	#define __IRQHANDLER\n	#undef TCCSKIP\n	#define TCCSKIP(x)\n	// #include <byteswap.h>\n	#ifndef _WIN32\n		#include <execinfo.h>\n		int tcc_backtrace(const char *fmt, ...);\n	#endif\n#endif\n\n// Use __offsetof_ptr instead of __offset_of, when you *do* have a valid pointer, to avoid UB:\n#ifndef __offsetof_ptr\n	#define __offsetof_ptr(ptr,PTYPE,FIELDNAME) ((size_t)((byte *)&((PTYPE *)ptr)->FIELDNAME - (byte *)ptr))\n#endif\n\n// for __offset_of\n#ifndef __offsetof\n	#define __offsetof(PTYPE,FIELDNAME) ((size_t)((char *)&((PTYPE *)0)->FIELDNAME - (char *)0))\n#endif\n\n#define OPTION_CAST(x) (x)\n\n#ifndef V64_PRINTFORMAT\n	#ifdef PRIx64\n		#define V64_PRINTFORMAT \"0x%\"PRIx64\n	#elif defined(__WIN32__)\n		#define V64_PRINTFORMAT \"0x%I64x\"\n	#elif defined(__linux__) && defined(__LP64__)\n		#define V64_PRINTFORMAT \"0x%lx\"\n	#else\n		#define V64_PRINTFORMAT \"0x%llx\"\n	#endif\n#endif\n");
	_const_v__gen__c__c_builtin_types = _SLIT("\n//================================== builtin types ================================*/\ntypedef int64_t i64;\ntypedef int16_t i16;\ntypedef int8_t i8;\ntypedef uint64_t u64;\ntypedef uint32_t u32;\ntypedef uint16_t u16;\ntypedef uint8_t byte;\ntypedef uint32_t rune;\ntypedef float f32;\ntypedef double f64;\ntypedef int64_t int_literal;\ntypedef double float_literal;\ntypedef unsigned char* byteptr;\ntypedef void* voidptr;\ntypedef char* charptr;\ntypedef byte array_fixed_byte_300 [300];\n\ntypedef struct sync__Channel* chan;\n\n#ifndef __cplusplus\n	#ifndef bool\n		typedef byte bool;\n		#define true 1\n		#define false 0\n	#endif\n#endif\n\ntypedef u64 (*MapHashFn)(voidptr);\ntypedef bool (*MapEqFn)(voidptr, voidptr);\ntypedef void (*MapCloneFn)(voidptr, voidptr);\ntypedef void (*MapFreeFn)(voidptr);\n");
	_const_v__gen__c__posix_hotcode_definitions_1 = _SLIT("\nvoid v_bind_live_symbols(void* live_lib){\n	@LOAD_FNS@\n}\n");
	_const_v__gen__c__windows_hotcode_definitions_1 = _SLIT("\nvoid v_bind_live_symbols(void* live_lib){\n	@LOAD_FNS@\n}\n");
	_const_v__gen__c__dbtype = _SLIT("sqlite");
	_const_v__gen__js__fast_deep_eq_fn = _SLIT("// https://www.npmjs.com/package/fast-deep-equal - 3/3/2021\nconst envHasBigInt64Array = typeof BigInt64Array !== 'undefined';\nfunction vEq(a, b) {\n	if (a === b) return true;\n\n	if (a && b && typeof a == 'object' && typeof b == 'object') {\n		if (a.constructor !== b.constructor) return false;\n\n		var length, i, keys;\n		if (Array.isArray(a)) {\n			length = a.length;\n			if (length != b.length) return false;\n			for (i = length; i-- !== 0;)\n				if (!vEq(a[i], b[i])) return false;\n			return true;\n		}\n\n\n		if ((a instanceof Map) && (b instanceof Map)) {\n			if (a.size !== b.size) return false;\n			for (i of a.entries())\n				if (!b.has(i[0])) return false;\n			for (i of a.entries())\n				if (!vEq(i[1], b.get(i[0]))) return false;\n			return true;\n		}\n\n		if ((a instanceof Set) && (b instanceof Set)) {\n			if (a.size !== b.size) return false;\n			for (i of a.entries())\n				if (!b.has(i[0])) return false;\n			return true;\n		}\n\n		if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {\n			length = a.length;\n			if (length != b.length) return false;\n			for (i = length; i-- !== 0;)\n				if (a[i] !== b[i]) return false;\n			return true;\n		}\n\n\n		if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n		if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n		if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n		keys = Object.keys(a);\n		length = keys.length;\n		if (length !== Object.keys(b).length) return false;\n\n		for (i = length; i-- !== 0;)\n			if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n		for (i = length; i-- !== 0;) {\n			var key = keys[i];\n\n			if (!vEq(a[key], b[key])) return false;\n		}\n\n		return true;\n	}\n\n	// true if both NaN, false otherwise\n	return a!==a && b!==b;\n};\n");
	_const_v__builder__c_verror_message_marker = _SLIT("VERROR_MESSAGE ");
	_const_v__builder__c_error_info = _SLIT("\n==================\nC error. This should never happen.\n\nIf you were not working with C interop, this is a compiler bug, please raise an issue on GitHub:\n\nhttps://github.com/vlang/v/issues/new/choose\n\nYou can also use #help on Discord: https://discord.gg/vlang\n");
	_const_v__builder__no_compiler_error = _SLIT("\n==================\nError: no C compiler detected.\n\nYou can find instructions on how to install one in the V wiki:\nhttps://github.com/vlang/v/wiki/Installing-a-C-compiler-on-Windows\n\nIf you think you have one installed, make sure it is in your PATH.\nIf you do have one in your PATH, please raise an issue on GitHub:\nhttps://github.com/vlang/v/issues/new/choose\n\nYou can also use `v doctor`, to see what V knows about your current environment.\n\nYou can also seek #help on Discord: https://discord.gg/vlang\n");
	_const_v__builder__mingw_cc = _SLIT("x86_64-w64-mingw32-gcc");
}
// << string literal consts


// V auto str functions:
static string time__FormatTime_str(time__FormatTime it) { /* gen_str_for_enum */
	switch(it) {
		case time__FormatTime_hhmm12: return _SLIT("hhmm12");
		case time__FormatTime_hhmm24: return _SLIT("hhmm24");
		case time__FormatTime_hhmmss12: return _SLIT("hhmmss12");
		case time__FormatTime_hhmmss24: return _SLIT("hhmmss24");
		case time__FormatTime_hhmmss24_milli: return _SLIT("hhmmss24_milli");
		case time__FormatTime_hhmmss24_micro: return _SLIT("hhmmss24_micro");
		case time__FormatTime_no_time: return _SLIT("no_time");
		default: return _SLIT("unknown enum value");
	}
}
static string time__FormatDate_str(time__FormatDate it) { /* gen_str_for_enum */
	switch(it) {
		case time__FormatDate_ddmmyy: return _SLIT("ddmmyy");
		case time__FormatDate_ddmmyyyy: return _SLIT("ddmmyyyy");
		case time__FormatDate_mmddyy: return _SLIT("mmddyy");
		case time__FormatDate_mmddyyyy: return _SLIT("mmddyyyy");
		case time__FormatDate_mmmd: return _SLIT("mmmd");
		case time__FormatDate_mmmdd: return _SLIT("mmmdd");
		case time__FormatDate_mmmddyy: return _SLIT("mmmddyy");
		case time__FormatDate_mmmddyyyy: return _SLIT("mmmddyyyy");
		case time__FormatDate_no_date: return _SLIT("no_date");
		case time__FormatDate_yyyymmdd: return _SLIT("yyyymmdd");
		case time__FormatDate_yymmdd: return _SLIT("yymmdd");
		default: return _SLIT("unknown enum value");
	}
}
static string v__pref__Backend_str(v__pref__Backend it) { /* gen_str_for_enum */
	switch(it) {
		case v__pref__Backend_c: return _SLIT("c");
		case v__pref__Backend_js: return _SLIT("js");
		case v__pref__Backend_x64: return _SLIT("x64");
		default: return _SLIT("unknown enum value");
	}
}
static string Array_v__ast__Expr_str(Array_v__ast__Expr a) { return indent_Array_v__ast__Expr_str(a, 0);}
static string indent_Array_v__ast__Expr_str(Array_v__ast__Expr a, int indent_count) {
	strings__Builder sb = strings__new_builder(a.len * 10);
	strings__Builder_write_string(&sb, _SLIT("["));
	for (int i = 0; i < a.len; ++i) {
		v__ast__Expr it = *(v__ast__Expr*)array_get(a, i);
		string x = v__ast__Expr_str(it);
		strings__Builder_write_string(&sb, x);
		if (i < a.len-1) {
			strings__Builder_write_string(&sb, _SLIT(", "));
		}
	}
	strings__Builder_write_string(&sb, _SLIT("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
static string v__ast__Comment_str(v__ast__Comment it) { return indent_v__ast__Comment_str(it, 0);}
static string indent_v__ast__Comment_str(v__ast__Comment it, int indent_count) {
	string indents = _SLIT("");
	for (int i = 0; i < indent_count; ++i) {
		indents = string_add(indents, _SLIT("    "));
	}
	return _STR("v.ast.Comment{\n"		"%.*s\000    text: '%.*s\000'\n"
		"%.*s\000    is_multi: %.*s\000\n"
		"%.*s\000    line_nr: %d\000\n"
		"%.*s\000    pos: %.*s\000\n"
		"%.*s\000}", 10,
		indents, it.text,
		indents, it.is_multi ? _SLIT("true") : _SLIT("false"),
		indents, it.line_nr,
		indents, v__token__Position_str(it.pos),
		indents);
}
static string Array_v__ast__Comment_str(Array_v__ast__Comment a) { return indent_Array_v__ast__Comment_str(a, 0);}
static string indent_Array_v__ast__Comment_str(Array_v__ast__Comment a, int indent_count) {
	strings__Builder sb = strings__new_builder(a.len * 10);
	strings__Builder_write_string(&sb, _SLIT("["));
	for (int i = 0; i < a.len; ++i) {
		v__ast__Comment it = *(v__ast__Comment*)array_get(a, i);
		string x = indent_v__ast__Comment_str(it, indent_count);
		strings__Builder_write_string(&sb, x);
		if (i < a.len-1) {
			strings__Builder_write_string(&sb, _SLIT(", "));
		}
	}
	strings__Builder_write_string(&sb, _SLIT("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
static string Array_v__ast__Attr_str(Array_v__ast__Attr a) { return indent_Array_v__ast__Attr_str(a, 0);}
static string indent_Array_v__ast__Attr_str(Array_v__ast__Attr a, int indent_count) {
	strings__Builder sb = strings__new_builder(a.len * 10);
	strings__Builder_write_string(&sb, _SLIT("["));
	for (int i = 0; i < a.len; ++i) {
		v__ast__Attr it = *(v__ast__Attr*)array_get(a, i);
		string x = v__ast__Attr_str(it);
		strings__Builder_write_string(&sb, x);
		if (i < a.len-1) {
			strings__Builder_write_string(&sb, _SLIT(", "));
		}
	}
	strings__Builder_write_string(&sb, _SLIT("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
static string v__ast__Type_str(v__ast__Type it) { return indent_v__ast__Type_str(it, 0); }
static string indent_v__ast__Type_str(v__ast__Type it, int indent_count) {
	string indents = _SLIT("");
	for (int i = 0; i < indent_count; ++i) {
		indents = string_add(indents, _SLIT("    "));
	}
	return _STR("%.*s\000v.ast.Type(%.*s\000)", 3, indents, int_str(it));
}
static string v__ast__StructField_str(v__ast__StructField it) { return indent_v__ast__StructField_str(it, 0);}
static string indent_v__ast__StructField_str(v__ast__StructField it, int indent_count) {
	string indents = _SLIT("");
	for (int i = 0; i < indent_count; ++i) {
		indents = string_add(indents, _SLIT("    "));
	}
	return _STR("v.ast.StructField{\n"		"%.*s\000    pos: %.*s\000\n"
		"%.*s\000    type_pos: %.*s\000\n"
		"%.*s\000    comments: %.*s\000\n"
		"%.*s\000    default_expr: %.*s\000\n"
		"%.*s\000    has_default_expr: %.*s\000\n"
		"%.*s\000    attrs: %.*s\000\n"
		"%.*s\000    is_pub: %.*s\000\n"
		"%.*s\000    default_val: '%.*s\000'\n"
		"%.*s\000    is_mut: %.*s\000\n"
		"%.*s\000    is_global: %.*s\000\n"
		"%.*s\000    default_expr_typ: %.*s\000\n"
		"%.*s\000    name: '%.*s\000'\n"
		"%.*s\000    typ: %.*s\000\n"
		"%.*s\000}", 28,
		indents, v__token__Position_str(it.pos),
		indents, v__token__Position_str(it.type_pos),
		indents, indent_Array_v__ast__Comment_str(it.comments, indent_count + 1),
		indents, v__ast__Expr_str(it.default_expr),
		indents, it.has_default_expr ? _SLIT("true") : _SLIT("false"),
		indents, indent_Array_v__ast__Attr_str(it.attrs, indent_count + 1),
		indents, it.is_pub ? _SLIT("true") : _SLIT("false"),
		indents, it.default_val,
		indents, it.is_mut ? _SLIT("true") : _SLIT("false"),
		indents, it.is_global ? _SLIT("true") : _SLIT("false"),
		indents, indent_v__ast__Type_str(it.default_expr_typ, indent_count + 1),
		indents, it.name,
		indents, indent_v__ast__Type_str(it.typ, indent_count + 1),
		indents);
}
static string Array_v__ast__StructField_str(Array_v__ast__StructField a) { return indent_Array_v__ast__StructField_str(a, 0);}
static string indent_Array_v__ast__StructField_str(Array_v__ast__StructField a, int indent_count) {
	strings__Builder sb = strings__new_builder(a.len * 10);
	strings__Builder_write_string(&sb, _SLIT("["));
	for (int i = 0; i < a.len; ++i) {
		v__ast__StructField it = *(v__ast__StructField*)array_get(a, i);
		string x = indent_v__ast__StructField_str(it, indent_count);
		strings__Builder_write_string(&sb, x);
		if (i < a.len-1) {
			strings__Builder_write_string(&sb, _SLIT(", "));
		}
	}
	strings__Builder_write_string(&sb, _SLIT("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
static string Array_v__ast__Type_str(Array_v__ast__Type a) { return indent_Array_v__ast__Type_str(a, 0);}
static string indent_Array_v__ast__Type_str(Array_v__ast__Type a, int indent_count) {
	strings__Builder sb = strings__new_builder(a.len * 10);
	strings__Builder_write_string(&sb, _SLIT("["));
	for (int i = 0; i < a.len; ++i) {
		int it = *(int*)array_get(a, i);
		string x = int_str(it);
		strings__Builder_write_string(&sb, x);
		if (i < a.len-1) {
			strings__Builder_write_string(&sb, _SLIT(", "));
		}
	}
	strings__Builder_write_string(&sb, _SLIT("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
static string v__ast__Aggregate_str(v__ast__Aggregate it) { return indent_v__ast__Aggregate_str(it, 0);}
static string indent_v__ast__Aggregate_str(v__ast__Aggregate it, int indent_count) {
	string indents = _SLIT("");
	for (int i = 0; i < indent_count; ++i) {
		indents = string_add(indents, _SLIT("    "));
	}
	return _STR("v.ast.Aggregate{\n"		"%.*s\000    fields: %.*s\000\n"
		"%.*s\000    types: %.*s\000\n"
		"%.*s\000}", 6,
		indents, indent_Array_v__ast__StructField_str(it.fields, indent_count + 1),
		indents, indent_Array_v__ast__Type_str(it.types, indent_count + 1),
		indents);
}
static string v__ast__Language_str(v__ast__Language it) { /* gen_str_for_enum */
	switch(it) {
		case v__ast__Language_v: return _SLIT("v");
		case v__ast__Language_c: return _SLIT("c");
		case v__ast__Language_js: return _SLIT("js");
		case v__ast__Language_amd64: return _SLIT("amd64");
		case v__ast__Language_i386: return _SLIT("i386");
		case v__ast__Language_aarch64: return _SLIT("aarch64");
		case v__ast__Language_aarch32: return _SLIT("aarch32");
		case v__ast__Language_rv64: return _SLIT("rv64");
		case v__ast__Language_rv32: return _SLIT("rv32");
		default: return _SLIT("unknown enum value");
	}
}
static string v__ast__Alias_str(v__ast__Alias it) { return indent_v__ast__Alias_str(it, 0);}
static string indent_v__ast__Alias_str(v__ast__Alias it, int indent_count) {
	string indents = _SLIT("");
	for (int i = 0; i < indent_count; ++i) {
		indents = string_add(indents, _SLIT("    "));
	}
	return _STR("v.ast.Alias{\n"		"%.*s\000    parent_type: %.*s\000\n"
		"%.*s\000    language: %.*s\000\n"
		"%.*s\000    is_import: %.*s\000\n"
		"%.*s\000}", 8,
		indents, indent_v__ast__Type_str(it.parent_type, indent_count + 1),
		indents, v__ast__Language_str(it.language),
		indents, it.is_import ? _SLIT("true") : _SLIT("false"),
		indents);
}
static string v__ast__Array_str(v__ast__Array it) { return indent_v__ast__Array_str(it, 0);}
static string indent_v__ast__Array_str(v__ast__Array it, int indent_count) {
	string indents = _SLIT("");
	for (int i = 0; i < indent_count; ++i) {
		indents = string_add(indents, _SLIT("    "));
	}
	return _STR("v.ast.Array{\n"		"%.*s\000    nr_dims: %d\000\n"
		"%.*s\000    elem_type: %.*s\000\n"
		"%.*s\000}", 6,
		indents, it.nr_dims,
		indents, indent_v__ast__Type_str(it.elem_type, indent_count + 1),
		indents);
}
static string v__ast__ArrayFixed_str(v__ast__ArrayFixed it) { return indent_v__ast__ArrayFixed_str(it, 0);}
static string indent_v__ast__ArrayFixed_str(v__ast__ArrayFixed it, int indent_count) {
	string indents = _SLIT("");
	for (int i = 0; i < indent_count; ++i) {
		indents = string_add(indents, _SLIT("    "));
	}
	return _STR("v.ast.ArrayFixed{\n"		"%.*s\000    size: %d\000\n"
		"%.*s\000    elem_type: %.*s\000\n"
		"%.*s\000}", 6,
		indents, it.size,
		indents, indent_v__ast__Type_str(it.elem_type, indent_count + 1),
		indents);
}
static string v__ast__Chan_str(v__ast__Chan it) { return indent_v__ast__Chan_str(it, 0);}
static string indent_v__ast__Chan_str(v__ast__Chan it, int indent_count) {
	string indents = _SLIT("");
	for (int i = 0; i < indent_count; ++i) {
		indents = string_add(indents, _SLIT("    "));
	}
	return _STR("v.ast.Chan{\n"		"%.*s\000    elem_type: %.*s\000\n"
		"%.*s\000    is_mut: %.*s\000\n"
		"%.*s\000}", 6,
		indents, indent_v__ast__Type_str(it.elem_type, indent_count + 1),
		indents, it.is_mut ? _SLIT("true") : _SLIT("false"),
		indents);
}
static string v__ast__Enum_str(v__ast__Enum it) { return indent_v__ast__Enum_str(it, 0);}
static string indent_v__ast__Enum_str(v__ast__Enum it, int indent_count) {
	string indents = _SLIT("");
	for (int i = 0; i < indent_count; ++i) {
		indents = string_add(indents, _SLIT("    "));
	}
	return _STR("v.ast.Enum{\n"		"%.*s\000    vals: %.*s\000\n"
		"%.*s\000    is_flag: %.*s\000\n"
		"%.*s\000    is_multi_allowed: %.*s\000\n"
		"%.*s\000}", 8,
		indents, Array_string_str(it.vals),
		indents, it.is_flag ? _SLIT("true") : _SLIT("false"),
		indents, it.is_multi_allowed ? _SLIT("true") : _SLIT("false"),
		indents);
}
static string v__ast__Param_str(v__ast__Param it) { return indent_v__ast__Param_str(it, 0);}
static string indent_v__ast__Param_str(v__ast__Param it, int indent_count) {
	string indents = _SLIT("");
	for (int i = 0; i < indent_count; ++i) {
		indents = string_add(indents, _SLIT("    "));
	}
	return _STR("v.ast.Param{\n"		"%.*s\000    pos: %.*s\000\n"
		"%.*s\000    name: '%.*s\000'\n"
		"%.*s\000    is_mut: %.*s\000\n"
		"%.*s\000    is_auto_rec: %.*s\000\n"
		"%.*s\000    typ: %.*s\000\n"
		"%.*s\000    type_pos: %.*s\000\n"
		"%.*s\000    is_hidden: %.*s\000\n"
		"%.*s\000}", 16,
		indents, v__token__Position_str(it.pos),
		indents, it.name,
		indents, it.is_mut ? _SLIT("true") : _SLIT("false"),
		indents, it.is_auto_rec ? _SLIT("true") : _SLIT("false"),
		indents, indent_v__ast__Type_str(it.typ, indent_count + 1),
		indents, v__token__Position_str(it.type_pos),
		indents, it.is_hidden ? _SLIT("true") : _SLIT("false"),
		indents);
}
static string Array_v__ast__Param_str(Array_v__ast__Param a) { return indent_Array_v__ast__Param_str(a, 0);}
static string indent_Array_v__ast__Param_str(Array_v__ast__Param a, int indent_count) {
	strings__Builder sb = strings__new_builder(a.len * 10);
	strings__Builder_write_string(&sb, _SLIT("["));
	for (int i = 0; i < a.len; ++i) {
		v__ast__Param it = *(v__ast__Param*)array_get(a, i);
		string x = indent_v__ast__Param_str(it, indent_count);
		strings__Builder_write_string(&sb, x);
		if (i < a.len-1) {
			strings__Builder_write_string(&sb, _SLIT(", "));
		}
	}
	strings__Builder_write_string(&sb, _SLIT("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
static string v__ast__Fn_str(v__ast__Fn it) { return indent_v__ast__Fn_str(it, 0);}
static string indent_v__ast__Fn_str(v__ast__Fn it, int indent_count) {
	string indents = _SLIT("");
	for (int i = 0; i < indent_count; ++i) {
		indents = string_add(indents, _SLIT("    "));
	}
	return _STR("v.ast.Fn{\n"		"%.*s\000    params: %.*s\000\n"
		"%.*s\000    return_type: %.*s\000\n"
		"%.*s\000    is_variadic: %.*s\000\n"
		"%.*s\000    language: %.*s\000\n"
		"%.*s\000    generic_names: %.*s\000\n"
		"%.*s\000    is_pub: %.*s\000\n"
		"%.*s\000    is_deprecated: %.*s\000\n"
		"%.*s\000    is_unsafe: %.*s\000\n"
		"%.*s\000    is_placeholder: %.*s\000\n"
		"%.*s\000    is_main: %.*s\000\n"
		"%.*s\000    is_test: %.*s\000\n"
		"%.*s\000    is_conditional: %.*s\000\n"
		"%.*s\000    is_keep_alive: %.*s\000\n"
		"%.*s\000    no_body: %.*s\000\n"
		"%.*s\000    mod: '%.*s\000'\n"
		"%.*s\000    ctdefine: '%.*s\000'\n"
		"%.*s\000    attrs: %.*s\000\n"
		"%.*s\000    name: '%.*s\000'\n"
		"%.*s\000    source_fn: %d\000\n"
		"%.*s\000    usages: %d\000\n"
		"%.*s\000}", 42,
		indents, indent_Array_v__ast__Param_str(it.params, indent_count + 1),
		indents, indent_v__ast__Type_str(it.return_type, indent_count + 1),
		indents, it.is_variadic ? _SLIT("true") : _SLIT("false"),
		indents, v__ast__Language_str(it.language),
		indents, Array_string_str(it.generic_names),
		indents, it.is_pub ? _SLIT("true") : _SLIT("false"),
		indents, it.is_deprecated ? _SLIT("true") : _SLIT("false"),
		indents, it.is_unsafe ? _SLIT("true") : _SLIT("false"),
		indents, it.is_placeholder ? _SLIT("true") : _SLIT("false"),
		indents, it.is_main ? _SLIT("true") : _SLIT("false"),
		indents, it.is_test ? _SLIT("true") : _SLIT("false"),
		indents, it.is_conditional ? _SLIT("true") : _SLIT("false"),
		indents, it.is_keep_alive ? _SLIT("true") : _SLIT("false"),
		indents, it.no_body ? _SLIT("true") : _SLIT("false"),
		indents, it.mod,
		indents, it.ctdefine,
		indents, indent_Array_v__ast__Attr_str(it.attrs, indent_count + 1),
		indents, it.name,
		indents, it.source_fn,
		indents, it.usages,
		indents);
}
static string v__ast__FnType_str(v__ast__FnType it) { return indent_v__ast__FnType_str(it, 0);}
static string indent_v__ast__FnType_str(v__ast__FnType it, int indent_count) {
	string indents = _SLIT("");
	for (int i = 0; i < indent_count; ++i) {
		indents = string_add(indents, _SLIT("    "));
	}
	return _STR("v.ast.FnType{\n"		"%.*s\000    is_anon: %.*s\000\n"
		"%.*s\000    has_decl: %.*s\000\n"
		"%.*s\000    func: %.*s\000\n"
		"%.*s\000}", 8,
		indents, it.is_anon ? _SLIT("true") : _SLIT("false"),
		indents, it.has_decl ? _SLIT("true") : _SLIT("false"),
		indents, indent_v__ast__Fn_str(it.func, indent_count + 1),
		indents);
}
static string v__ast__GenericStructInst_str(v__ast__GenericStructInst it) { return indent_v__ast__GenericStructInst_str(it, 0);}
static string indent_v__ast__GenericStructInst_str(v__ast__GenericStructInst it, int indent_count) {
	string indents = _SLIT("");
	for (int i = 0; i < indent_count; ++i) {
		indents = string_add(indents, _SLIT("    "));
	}
	return _STR("v.ast.GenericStructInst{\n"		"%.*s\000    parent_idx: %d\000\n"
		"%.*s\000    generic_types: %.*s\000\n"
		"%.*s\000}", 6,
		indents, it.parent_idx,
		indents, indent_Array_v__ast__Type_str(it.generic_types, indent_count + 1),
		indents);
}
static string Array_v__ast__Fn_str(Array_v__ast__Fn a) { return indent_Array_v__ast__Fn_str(a, 0);}
static string indent_Array_v__ast__Fn_str(Array_v__ast__Fn a, int indent_count) {
	strings__Builder sb = strings__new_builder(a.len * 10);
	strings__Builder_write_string(&sb, _SLIT("["));
	for (int i = 0; i < a.len; ++i) {
		v__ast__Fn it = *(v__ast__Fn*)array_get(a, i);
		string x = indent_v__ast__Fn_str(it, indent_count);
		strings__Builder_write_string(&sb, x);
		if (i < a.len-1) {
			strings__Builder_write_string(&sb, _SLIT(", "));
		}
	}
	strings__Builder_write_string(&sb, _SLIT("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
static string v__ast__Interface_str(v__ast__Interface it) { return indent_v__ast__Interface_str(it, 0);}
static string indent_v__ast__Interface_str(v__ast__Interface it, int indent_count) {
	string indents = _SLIT("");
	for (int i = 0; i < indent_count; ++i) {
		indents = string_add(indents, _SLIT("    "));
	}
	return _STR("v.ast.Interface{\n"		"%.*s\000    types: %.*s\000\n"
		"%.*s\000    fields: %.*s\000\n"
		"%.*s\000    methods: %.*s\000\n"
		"%.*s\000}", 8,
		indents, indent_Array_v__ast__Type_str(it.types, indent_count + 1),
		indents, indent_Array_v__ast__StructField_str(it.fields, indent_count + 1),
		indents, indent_Array_v__ast__Fn_str(it.methods, indent_count + 1),
		indents);
}
static string v__ast__Map_str(v__ast__Map it) { return indent_v__ast__Map_str(it, 0);}
static string indent_v__ast__Map_str(v__ast__Map it, int indent_count) {
	string indents = _SLIT("");
	for (int i = 0; i < indent_count; ++i) {
		indents = string_add(indents, _SLIT("    "));
	}
	return _STR("v.ast.Map{\n"		"%.*s\000    key_type: %.*s\000\n"
		"%.*s\000    value_type: %.*s\000\n"
		"%.*s\000}", 6,
		indents, indent_v__ast__Type_str(it.key_type, indent_count + 1),
		indents, indent_v__ast__Type_str(it.value_type, indent_count + 1),
		indents);
}
static string v__ast__MultiReturn_str(v__ast__MultiReturn it) { return indent_v__ast__MultiReturn_str(it, 0);}
static string indent_v__ast__MultiReturn_str(v__ast__MultiReturn it, int indent_count) {
	string indents = _SLIT("");
	for (int i = 0; i < indent_count; ++i) {
		indents = string_add(indents, _SLIT("    "));
	}
	return _STR("v.ast.MultiReturn{\n"		"%.*s\000    types: %.*s\000\n"
		"%.*s\000}", 4,
		indents, indent_Array_v__ast__Type_str(it.types, indent_count + 1),
		indents);
}
static string v__ast__Struct_str(v__ast__Struct it) { return indent_v__ast__Struct_str(it, 0);}
static string indent_v__ast__Struct_str(v__ast__Struct it, int indent_count) {
	string indents = _SLIT("");
	for (int i = 0; i < indent_count; ++i) {
		indents = string_add(indents, _SLIT("    "));
	}
	return _STR("v.ast.Struct{\n"		"%.*s\000    attrs: %.*s\000\n"
		"%.*s\000    embeds: %.*s\000\n"
		"%.*s\000    fields: %.*s\000\n"
		"%.*s\000    is_typedef: %.*s\000\n"
		"%.*s\000    is_union: %.*s\000\n"
		"%.*s\000    is_heap: %.*s\000\n"
		"%.*s\000    generic_types: %.*s\000\n"
		"%.*s\000    concrete_types: %.*s\000\n"
		"%.*s\000    parent_type: %.*s\000\n"
		"%.*s\000}", 20,
		indents, indent_Array_v__ast__Attr_str(it.attrs, indent_count + 1),
		indents, indent_Array_v__ast__Type_str(it.embeds, indent_count + 1),
		indents, indent_Array_v__ast__StructField_str(it.fields, indent_count + 1),
		indents, it.is_typedef ? _SLIT("true") : _SLIT("false"),
		indents, it.is_union ? _SLIT("true") : _SLIT("false"),
		indents, it.is_heap ? _SLIT("true") : _SLIT("false"),
		indents, indent_Array_v__ast__Type_str(it.generic_types, indent_count + 1),
		indents, indent_Array_v__ast__Type_str(it.concrete_types, indent_count + 1),
		indents, indent_v__ast__Type_str(it.parent_type, indent_count + 1),
		indents);
}
static string v__ast__SumType_str(v__ast__SumType it) { return indent_v__ast__SumType_str(it, 0);}
static string indent_v__ast__SumType_str(v__ast__SumType it, int indent_count) {
	string indents = _SLIT("");
	for (int i = 0; i < indent_count; ++i) {
		indents = string_add(indents, _SLIT("    "));
	}
	return _STR("v.ast.SumType{\n"		"%.*s\000    variants: %.*s\000\n"
		"%.*s\000    fields: %.*s\000\n"
		"%.*s\000    found_fields: %.*s\000\n"
		"%.*s\000}", 8,
		indents, indent_Array_v__ast__Type_str(it.variants, indent_count + 1),
		indents, indent_Array_v__ast__StructField_str(it.fields, indent_count + 1),
		indents, it.found_fields ? _SLIT("true") : _SLIT("false"),
		indents);
}
static string v__ast__Thread_str(v__ast__Thread it) { return indent_v__ast__Thread_str(it, 0);}
static string indent_v__ast__Thread_str(v__ast__Thread it, int indent_count) {
	string indents = _SLIT("");
	for (int i = 0; i < indent_count; ++i) {
		indents = string_add(indents, _SLIT("    "));
	}
	return _STR("v.ast.Thread{\n"		"%.*s\000    return_type: %.*s\000\n"
		"%.*s\000}", 4,
		indents, indent_v__ast__Type_str(it.return_type, indent_count + 1),
		indents);
}
static string v__ast__TypeInfo_str(v__ast__TypeInfo x) { return indent_v__ast__TypeInfo_str(x, 0); }
static string indent_v__ast__TypeInfo_str(v__ast__TypeInfo x, int indent_count) {
	switch(x._typ) {
		case 408: return _STR("v.ast.TypeInfo(%.*s\000)", 2, indent_v__ast__Aggregate_str(*(v__ast__Aggregate*)x._v__ast__Aggregate, indent_count));
		case 413: return _STR("v.ast.TypeInfo(%.*s\000)", 2, indent_v__ast__Alias_str(*(v__ast__Alias*)x._v__ast__Alias, indent_count));
		case 395: return _STR("v.ast.TypeInfo(%.*s\000)", 2, indent_v__ast__Array_str(*(v__ast__Array*)x._v__ast__Array, indent_count));
		case 416: return _STR("v.ast.TypeInfo(%.*s\000)", 2, indent_v__ast__ArrayFixed_str(*(v__ast__ArrayFixed*)x._v__ast__ArrayFixed, indent_count));
		case 414: return _STR("v.ast.TypeInfo(%.*s\000)", 2, indent_v__ast__Chan_str(*(v__ast__Chan*)x._v__ast__Chan, indent_count));
		case 420: return _STR("v.ast.TypeInfo(%.*s\000)", 2, indent_v__ast__Enum_str(*(v__ast__Enum*)x._v__ast__Enum, indent_count));
		case 418: return _STR("v.ast.TypeInfo(%.*s\000)", 2, indent_v__ast__FnType_str(*(v__ast__FnType*)x._v__ast__FnType, indent_count));
		case 419: return _STR("v.ast.TypeInfo(%.*s\000)", 2, indent_v__ast__GenericStructInst_str(*(v__ast__GenericStructInst*)x._v__ast__GenericStructInst, indent_count));
		case 410: return _STR("v.ast.TypeInfo(%.*s\000)", 2, indent_v__ast__Interface_str(*(v__ast__Interface*)x._v__ast__Interface, indent_count));
		case 396: return _STR("v.ast.TypeInfo(%.*s\000)", 2, indent_v__ast__Map_str(*(v__ast__Map*)x._v__ast__Map, indent_count));
		case 417: return _STR("v.ast.TypeInfo(%.*s\000)", 2, indent_v__ast__MultiReturn_str(*(v__ast__MultiReturn*)x._v__ast__MultiReturn, indent_count));
		case 409: return _STR("v.ast.TypeInfo(%.*s\000)", 2, indent_v__ast__Struct_str(*(v__ast__Struct*)x._v__ast__Struct, indent_count));
		case 411: return _STR("v.ast.TypeInfo(%.*s\000)", 2, indent_v__ast__SumType_str(*(v__ast__SumType*)x._v__ast__SumType, indent_count));
		case 415: return _STR("v.ast.TypeInfo(%.*s\000)", 2, indent_v__ast__Thread_str(*(v__ast__Thread*)x._v__ast__Thread, indent_count));
		default: return _SLIT("unknown sum type value");
	}
}
static string v__ast__IdentKind_str(v__ast__IdentKind it) { /* gen_str_for_enum */
	switch(it) {
		case v__ast__IdentKind_unresolved: return _SLIT("unresolved");
		case v__ast__IdentKind_blank_ident: return _SLIT("blank_ident");
		case v__ast__IdentKind_variable: return _SLIT("variable");
		case v__ast__IdentKind_constant: return _SLIT("constant");
		case v__ast__IdentKind_global: return _SLIT("global");
		case v__ast__IdentKind_function: return _SLIT("function");
		default: return _SLIT("unknown enum value");
	}
}
static string v__ast__TypeNode_str(v__ast__TypeNode it) { return indent_v__ast__TypeNode_str(it, 0);}
static string indent_v__ast__TypeNode_str(v__ast__TypeNode it, int indent_count) {
	string indents = _SLIT("");
	for (int i = 0; i < indent_count; ++i) {
		indents = string_add(indents, _SLIT("    "));
	}
	return _STR("v.ast.TypeNode{\n"		"%.*s\000    typ: %.*s\000\n"
		"%.*s\000    pos: %.*s\000\n"
		"%.*s\000}", 6,
		indents, indent_v__ast__Type_str(it.typ, indent_count + 1),
		indents, v__token__Position_str(it.pos),
		indents);
}
static string v__gen__c__SqlType_str(v__gen__c__SqlType it) { /* gen_str_for_enum */
	switch(it) {
		case v__gen__c__SqlType_sqlite3: return _SLIT("sqlite3");
		case v__gen__c__SqlType_mysql: return _SLIT("mysql");
		case v__gen__c__SqlType_psql: return _SLIT("psql");
		case v__gen__c__SqlType_unknown: return _SLIT("unknown");
		default: return _SLIT("unknown enum value");
	}
}
static string v__gen__x64__Register_str(v__gen__x64__Register it) { /* gen_str_for_enum */
	switch(it) {
		case v__gen__x64__Register_rax: return _SLIT("rax");
		case v__gen__x64__Register_rcx: return _SLIT("rcx");
		case v__gen__x64__Register_rdx: return _SLIT("rdx");
		case v__gen__x64__Register_rbx: return _SLIT("rbx");
		case v__gen__x64__Register_rsp: return _SLIT("rsp");
		case v__gen__x64__Register_rbp: return _SLIT("rbp");
		case v__gen__x64__Register_rsi: return _SLIT("rsi");
		case v__gen__x64__Register_rdi: return _SLIT("rdi");
		case v__gen__x64__Register_eax: return _SLIT("eax");
		case v__gen__x64__Register_edi: return _SLIT("edi");
		case v__gen__x64__Register_edx: return _SLIT("edx");
		case v__gen__x64__Register_r8: return _SLIT("r8");
		case v__gen__x64__Register_r9: return _SLIT("r9");
		case v__gen__x64__Register_r10: return _SLIT("r10");
		case v__gen__x64__Register_r11: return _SLIT("r11");
		case v__gen__x64__Register_r12: return _SLIT("r12");
		case v__gen__x64__Register_r13: return _SLIT("r13");
		case v__gen__x64__Register_r14: return _SLIT("r14");
		case v__gen__x64__Register_r15: return _SLIT("r15");
		default: return _SLIT("unknown enum value");
	}
}
static string v__errors__Reporter_str(v__errors__Reporter it) { /* gen_str_for_enum */
	switch(it) {
		case v__errors__Reporter_scanner: return _SLIT("scanner");
		case v__errors__Reporter_parser: return _SLIT("parser");
		case v__errors__Reporter_checker: return _SLIT("checker");
		case v__errors__Reporter_gen: return _SLIT("gen");
		default: return _SLIT("unknown enum value");
	}
}
static string Array_v__cflag__CFlag_str(Array_v__cflag__CFlag a) { return indent_Array_v__cflag__CFlag_str(a, 0);}
static string indent_Array_v__cflag__CFlag_str(Array_v__cflag__CFlag a, int indent_count) {
	strings__Builder sb = strings__new_builder(a.len * 10);
	strings__Builder_write_string(&sb, _SLIT("["));
	for (int i = 0; i < a.len; ++i) {
		v__cflag__CFlag it = *(v__cflag__CFlag*)array_get(a, i);
		string x = v__cflag__CFlag_str(&it);
		strings__Builder_write_string(&sb, x);
		if (i < a.len-1) {
			strings__Builder_write_string(&sb, _SLIT(", "));
		}
	}
	strings__Builder_write_string(&sb, _SLIT("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
static bool Array_string_contains(Array_string a, string v) {
	for (int i = 0; i < a.len; ++i) {
		if (string_eq((*(string*)array_get(a, i)), v)) {
			return true;
		}
	}
	return false;
}

static bool Array_v__token__Kind_contains(Array_v__token__Kind a, v__token__Kind v) {
	for (int i = 0; i < a.len; ++i) {
		if ((*(v__token__Kind*)array_get(a, i)) == v) {
			return true;
		}
	}
	return false;
}

static inline v__ast__Expr v__ast__EmptyExpr_to_sumtype_v__ast__Expr(v__ast__EmptyExpr* x) {
	v__ast__EmptyExpr* ptr = memdup(x, sizeof(v__ast__EmptyExpr));
	return (v__ast__Expr){ ._v__ast__EmptyExpr = ptr, ._typ = 250};
}

static inline v__ast__Stmt v__ast__EmptyStmt_to_sumtype_v__ast__Stmt(v__ast__EmptyStmt* x) {
	v__ast__EmptyStmt* ptr = memdup(x, sizeof(v__ast__EmptyStmt));
	return (v__ast__Stmt){ ._v__ast__EmptyStmt = ptr, ._typ = 291, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__EmptyStmt, pos))};
}

static inline v__ast__Node v__ast__EmptyNode_to_sumtype_v__ast__Node(v__ast__EmptyNode* x) {
	v__ast__EmptyNode* ptr = memdup(x, sizeof(v__ast__EmptyNode));
	return (v__ast__Node){ ._v__ast__EmptyNode = ptr, ._typ = 315};
}

static inline v__ast__Node v__ast__Expr_to_sumtype_v__ast__Node(v__ast__Expr* x) {
	v__ast__Expr* ptr = memdup(x, sizeof(v__ast__Expr));
	return (v__ast__Node){ ._v__ast__Expr = ptr, ._typ = 282};
}

static inline v__ast__Node v__ast__Stmt_to_sumtype_v__ast__Node(v__ast__Stmt* x) {
	v__ast__Stmt* ptr = memdup(x, sizeof(v__ast__Stmt));
	return (v__ast__Node){ ._v__ast__Stmt = ptr, ._typ = 308};
}

static inline v__ast__Node v__ast__StructInitField_to_sumtype_v__ast__Node(v__ast__StructInitField* x) {
	v__ast__StructInitField* ptr = memdup(x, sizeof(v__ast__StructInitField));
	return (v__ast__Node){ ._v__ast__StructInitField = ptr, ._typ = 322};
}

static inline v__ast__Stmt v__ast__FnDecl_to_sumtype_v__ast__Stmt(v__ast__FnDecl* x) {
	v__ast__FnDecl* ptr = memdup(x, sizeof(v__ast__FnDecl));
	return (v__ast__Stmt){ ._v__ast__FnDecl = ptr, ._typ = 175, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__FnDecl, pos))};
}

static inline v__ast__Node v__ast__CallArg_to_sumtype_v__ast__Node(v__ast__CallArg* x) {
	v__ast__CallArg* ptr = memdup(x, sizeof(v__ast__CallArg));
	return (v__ast__Node){ ._v__ast__CallArg = ptr, ._typ = 314};
}

static inline v__ast__Expr v__ast__OrExpr_to_sumtype_v__ast__Expr(v__ast__OrExpr* x) {
	v__ast__OrExpr* ptr = memdup(x, sizeof(v__ast__OrExpr));
	return (v__ast__Expr){ ._v__ast__OrExpr = ptr, ._typ = 267};
}

static inline v__ast__Node v__ast__IfBranch_to_sumtype_v__ast__Node(v__ast__IfBranch* x) {
	v__ast__IfBranch* ptr = memdup(x, sizeof(v__ast__IfBranch));
	return (v__ast__Node){ ._v__ast__IfBranch = ptr, ._typ = 317};
}

static inline v__ast__Node v__ast__MatchBranch_to_sumtype_v__ast__Node(v__ast__MatchBranch* x) {
	v__ast__MatchBranch* ptr = memdup(x, sizeof(v__ast__MatchBranch));
	return (v__ast__Node){ ._v__ast__MatchBranch = ptr, ._typ = 318};
}

static inline v__ast__Node v__ast__SelectBranch_to_sumtype_v__ast__Node(v__ast__SelectBranch* x) {
	v__ast__SelectBranch* ptr = memdup(x, sizeof(v__ast__SelectBranch));
	return (v__ast__Node){ ._v__ast__SelectBranch = ptr, ._typ = 320};
}

static inline v__ast__Node v__ast__StructField_to_sumtype_v__ast__Node(v__ast__StructField* x) {
	v__ast__StructField* ptr = memdup(x, sizeof(v__ast__StructField));
	return (v__ast__Node){ ._v__ast__StructField = ptr, ._typ = 321};
}

static inline v__ast__Node v__ast__GlobalField_to_sumtype_v__ast__Node(v__ast__GlobalField* x) {
	v__ast__GlobalField* ptr = memdup(x, sizeof(v__ast__GlobalField));
	return (v__ast__Node){ ._v__ast__GlobalField = ptr, ._typ = 311};
}

static inline v__ast__Node v__ast__ConstField_to_sumtype_v__ast__Node(v__ast__ConstField* x) {
	v__ast__ConstField* ptr = memdup(x, sizeof(v__ast__ConstField));
	return (v__ast__Node){ ._v__ast__ConstField = ptr, ._typ = 310};
}

static inline v__ast__Node v__ast__EnumField_to_sumtype_v__ast__Node(v__ast__EnumField* x) {
	v__ast__EnumField* ptr = memdup(x, sizeof(v__ast__EnumField));
	return (v__ast__Node){ ._v__ast__EnumField = ptr, ._typ = 316};
}

static inline v__ast__Node v__ast__Param_to_sumtype_v__ast__Node(v__ast__Param* x) {
	v__ast__Param* ptr = memdup(x, sizeof(v__ast__Param));
	return (v__ast__Node){ ._v__ast__Param = ptr, ._typ = 319};
}

static inline v__ast__Node v__ast__SumTypeVariant_to_sumtype_v__ast__Node(v__ast__SumTypeVariant* x) {
	v__ast__SumTypeVariant* ptr = memdup(x, sizeof(v__ast__SumTypeVariant));
	return (v__ast__Node){ ._v__ast__SumTypeVariant = ptr, ._typ = 323};
}

static inline v__ast__ScopeObject v__ast__AsmRegister_to_sumtype_v__ast__ScopeObject(v__ast__AsmRegister* x) {
	v__ast__AsmRegister* ptr = memdup(x, sizeof(v__ast__AsmRegister));
	return (v__ast__ScopeObject){ ._v__ast__AsmRegister = ptr, ._typ = 309};
}

static inline v__ast__Expr v__ast__ArrayInit_to_sumtype_v__ast__Expr(v__ast__ArrayInit* x) {
	v__ast__ArrayInit* ptr = memdup(x, sizeof(v__ast__ArrayInit));
	return (v__ast__Expr){ ._v__ast__ArrayInit = ptr, ._typ = 235};
}

static inline v__ast__Expr v__ast__StringLiteral_to_sumtype_v__ast__Expr(v__ast__StringLiteral* x) {
	v__ast__StringLiteral* ptr = memdup(x, sizeof(v__ast__StringLiteral));
	return (v__ast__Expr){ ._v__ast__StringLiteral = ptr, ._typ = 277};
}

static inline v__ast__Expr v__ast__MapInit_to_sumtype_v__ast__Expr(v__ast__MapInit* x) {
	v__ast__MapInit* ptr = memdup(x, sizeof(v__ast__MapInit));
	return (v__ast__Expr){ ._v__ast__MapInit = ptr, ._typ = 262};
}

static inline v__ast__Expr v__ast__StructInit_to_sumtype_v__ast__Expr(v__ast__StructInit* x) {
	v__ast__StructInit* ptr = memdup(x, sizeof(v__ast__StructInit));
	return (v__ast__Expr){ ._v__ast__StructInit = ptr, ._typ = 278};
}

static bool v__ast__Type_alias_eq(v__ast__Type a, v__ast__Type b) {
	if (a != b) {
		return false;
	}
	return true;
}

static bool Array_string_arr_eq(Array_string a, Array_string b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (string_ne(*((string*)((byte*)a.data+(i*a.element_size))), *((string*)((byte*)b.data+(i*b.element_size))))) {
			return false;
		}
	}
	return true;
}

static inline v__ast__TypeInfo v__ast__SumType_to_sumtype_v__ast__TypeInfo(v__ast__SumType* x) {
	v__ast__SumType* ptr = memdup(x, sizeof(v__ast__SumType));
	return (v__ast__TypeInfo){ ._v__ast__SumType = ptr, ._typ = 411};
}

static inline v__ast__TypeInfo v__ast__Chan_to_sumtype_v__ast__TypeInfo(v__ast__Chan* x) {
	v__ast__Chan* ptr = memdup(x, sizeof(v__ast__Chan));
	return (v__ast__TypeInfo){ ._v__ast__Chan = ptr, ._typ = 414};
}

static inline v__ast__TypeInfo v__ast__Map_to_sumtype_v__ast__TypeInfo(v__ast__Map* x) {
	v__ast__Map* ptr = memdup(x, sizeof(v__ast__Map));
	return (v__ast__TypeInfo){ ._v__ast__Map = ptr, ._typ = 396};
}

static inline v__ast__TypeInfo v__ast__Thread_to_sumtype_v__ast__TypeInfo(v__ast__Thread* x) {
	v__ast__Thread* ptr = memdup(x, sizeof(v__ast__Thread));
	return (v__ast__TypeInfo){ ._v__ast__Thread = ptr, ._typ = 415};
}

static inline v__ast__TypeInfo v__ast__Array_to_sumtype_v__ast__TypeInfo(v__ast__Array* x) {
	v__ast__Array* ptr = memdup(x, sizeof(v__ast__Array));
	return (v__ast__TypeInfo){ ._v__ast__Array = ptr, ._typ = 395};
}

static inline v__ast__TypeInfo v__ast__ArrayFixed_to_sumtype_v__ast__TypeInfo(v__ast__ArrayFixed* x) {
	v__ast__ArrayFixed* ptr = memdup(x, sizeof(v__ast__ArrayFixed));
	return (v__ast__TypeInfo){ ._v__ast__ArrayFixed = ptr, ._typ = 416};
}

static inline v__ast__TypeInfo v__ast__MultiReturn_to_sumtype_v__ast__TypeInfo(v__ast__MultiReturn* x) {
	v__ast__MultiReturn* ptr = memdup(x, sizeof(v__ast__MultiReturn));
	return (v__ast__TypeInfo){ ._v__ast__MultiReturn = ptr, ._typ = 417};
}

static inline v__ast__TypeInfo v__ast__FnType_to_sumtype_v__ast__TypeInfo(v__ast__FnType* x) {
	v__ast__FnType* ptr = memdup(x, sizeof(v__ast__FnType));
	return (v__ast__TypeInfo){ ._v__ast__FnType = ptr, ._typ = 418};
}

static bool Array_v__ast__Type_arr_eq(Array_v__ast__Type a, Array_v__ast__Type b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (!v__ast__Type_alias_eq(((v__ast__Type*)a.data)[i], ((v__ast__Type*)b.data)[i])) {
			return false;
		}
	}
	return true;
}

static bool Array_Array_v__ast__Type_contains(Array_Array_v__ast__Type a, Array_v__ast__Type v) {
	for (int i = 0; i < a.len; ++i) {
		if (Array_v__ast__Type_arr_eq(*(Array_v__ast__Type*)array_get(a, i), v)) {
			return true;
		}
	}
	return false;
}

static bool Array_v__ast__Type_contains(Array_v__ast__Type a, v__ast__Type v) {
	for (int i = 0; i < a.len; ++i) {
		if ((*(v__ast__Type*)array_get(a, i)) == v) {
			return true;
		}
	}
	return false;
}

static int Array_v__ast__Type_index(Array_v__ast__Type a, v__ast__Type v) {
	for (int i = 0; i < a.len; ++i) {
		if ((*(v__ast__Type*)array_get(a, i)) == v) {
			return i;
		}
	}
	return -1;
}

static inline v__ast__TypeInfo v__ast__Struct_to_sumtype_v__ast__TypeInfo(v__ast__Struct* x) {
	v__ast__Struct* ptr = memdup(x, sizeof(v__ast__Struct));
	return (v__ast__TypeInfo){ ._v__ast__Struct = ptr, ._typ = 409};
}

static bool Array_int_contains(Array_int a, int v) {
	for (int i = 0; i < a.len; ++i) {
		if ((*(int*)array_get(a, i)) == v) {
			return true;
		}
	}
	return false;
}

static bool time__Time_struct_eq(time__Time a, time__Time b) {
	return time__Time__eq(a, b);
}

static bool Array_i64_contains(Array_i64 a, i64 v) {
	for (int i = 0; i < a.len; ++i) {
		if ((*(i64*)array_get(a, i)) == v) {
			return true;
		}
	}
	return false;
}

static inline v__ast__IdentInfo v__ast__IdentVar_to_sumtype_v__ast__IdentInfo(v__ast__IdentVar* x) {
	v__ast__IdentVar* ptr = memdup(x, sizeof(v__ast__IdentVar));
	return (v__ast__IdentInfo){ ._v__ast__IdentVar = ptr, ._typ = 363, .typ = (v__ast__Type*)((char*)ptr + __offsetof_ptr(ptr, v__ast__IdentVar, typ))};
}

static inline v__ast__ScopeObject v__ast__Var_to_sumtype_v__ast__ScopeObject(v__ast__Var* x) {
	v__ast__Var* ptr = memdup(x, sizeof(v__ast__Var));
	return (v__ast__ScopeObject){ ._v__ast__Var = ptr, ._typ = 312};
}

static inline v__ast__AsmArg v__ast__AsmRegister_to_sumtype_v__ast__AsmArg(v__ast__AsmRegister* x) {
	v__ast__AsmRegister* ptr = memdup(x, sizeof(v__ast__AsmRegister));
	return (v__ast__AsmArg){ ._v__ast__AsmRegister = ptr, ._typ = 309};
}

static inline v__ast__IdentInfo v__ast__IdentFn_to_sumtype_v__ast__IdentInfo(v__ast__IdentFn* x) {
	v__ast__IdentFn* ptr = memdup(x, sizeof(v__ast__IdentFn));
	return (v__ast__IdentInfo){ ._v__ast__IdentFn = ptr, ._typ = 362, .typ = (v__ast__Type*)((char*)ptr + __offsetof_ptr(ptr, v__ast__IdentFn, typ))};
}

static inline v__ast__TypeInfo v__ast__Aggregate_to_sumtype_v__ast__TypeInfo(v__ast__Aggregate* x) {
	v__ast__Aggregate* ptr = memdup(x, sizeof(v__ast__Aggregate));
	return (v__ast__TypeInfo){ ._v__ast__Aggregate = ptr, ._typ = 408};
}

static inline v__ast__Expr v__ast__InfixExpr_to_sumtype_v__ast__Expr(v__ast__InfixExpr* x) {
	v__ast__InfixExpr* ptr = memdup(x, sizeof(v__ast__InfixExpr));
	return (v__ast__Expr){ ._v__ast__InfixExpr = ptr, ._typ = 258};
}

static inline v__ast__Expr v__ast__Ident_to_sumtype_v__ast__Expr(v__ast__Ident* x) {
	v__ast__Ident* ptr = memdup(x, sizeof(v__ast__Ident));
	return (v__ast__Expr){ ._v__ast__Ident = ptr, ._typ = 254};
}

static inline v__ast__Stmt v__ast__Return_to_sumtype_v__ast__Stmt(v__ast__Return* x) {
	v__ast__Return* ptr = memdup(x, sizeof(v__ast__Return));
	return (v__ast__Stmt){ ._v__ast__Return = ptr, ._typ = 305, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__Return, pos))};
}

static inline v__ast__Stmt v__ast__NodeError_to_sumtype_v__ast__Stmt(v__ast__NodeError* x) {
	v__ast__NodeError* ptr = memdup(x, sizeof(v__ast__NodeError));
	return (v__ast__Stmt){ ._v__ast__NodeError = ptr, ._typ = 264, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__NodeError, pos))};
}

static inline v__ast__Stmt v__ast__AssignStmt_to_sumtype_v__ast__Stmt(v__ast__AssignStmt* x) {
	v__ast__AssignStmt* ptr = memdup(x, sizeof(v__ast__AssignStmt));
	return (v__ast__Stmt){ ._v__ast__AssignStmt = ptr, ._typ = 285, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__AssignStmt, pos))};
}

static inline v__ast__Expr v__ast__ComptimeCall_to_sumtype_v__ast__Expr(v__ast__ComptimeCall* x) {
	v__ast__ComptimeCall* ptr = memdup(x, sizeof(v__ast__ComptimeCall));
	return (v__ast__Expr){ ._v__ast__ComptimeCall = ptr, ._typ = 246};
}

static inline v__ast__Expr v__ast__ComptimeSelector_to_sumtype_v__ast__Expr(v__ast__ComptimeSelector* x) {
	v__ast__ComptimeSelector* ptr = memdup(x, sizeof(v__ast__ComptimeSelector));
	return (v__ast__Expr){ ._v__ast__ComptimeSelector = ptr, ._typ = 247};
}

static inline v__ast__Expr v__ast__ArrayDecompose_to_sumtype_v__ast__Expr(v__ast__ArrayDecompose* x) {
	v__ast__ArrayDecompose* ptr = memdup(x, sizeof(v__ast__ArrayDecompose));
	return (v__ast__Expr){ ._v__ast__ArrayDecompose = ptr, ._typ = 234};
}

static inline v__ast__Stmt v__ast__ForStmt_to_sumtype_v__ast__Stmt(v__ast__ForStmt* x) {
	v__ast__ForStmt* ptr = memdup(x, sizeof(v__ast__ForStmt));
	return (v__ast__Stmt){ ._v__ast__ForStmt = ptr, ._typ = 296, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__ForStmt, pos))};
}

static inline v__ast__Stmt v__ast__ForCStmt_to_sumtype_v__ast__Stmt(v__ast__ForCStmt* x) {
	v__ast__ForCStmt* ptr = memdup(x, sizeof(v__ast__ForCStmt));
	return (v__ast__Stmt){ ._v__ast__ForCStmt = ptr, ._typ = 294, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__ForCStmt, pos))};
}

static inline v__ast__Stmt v__ast__ForInStmt_to_sumtype_v__ast__Stmt(v__ast__ForInStmt* x) {
	v__ast__ForInStmt* ptr = memdup(x, sizeof(v__ast__ForInStmt));
	return (v__ast__Stmt){ ._v__ast__ForInStmt = ptr, ._typ = 295, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__ForInStmt, pos))};
}

static inline v__ast__Expr v__ast__IfGuardExpr_to_sumtype_v__ast__Expr(v__ast__IfGuardExpr* x) {
	v__ast__IfGuardExpr* ptr = memdup(x, sizeof(v__ast__IfGuardExpr));
	return (v__ast__Expr){ ._v__ast__IfGuardExpr = ptr, ._typ = 256};
}

static inline v__ast__Expr v__ast__TypeNode_to_sumtype_v__ast__Expr(v__ast__TypeNode* x) {
	v__ast__TypeNode* ptr = memdup(x, sizeof(v__ast__TypeNode));
	return (v__ast__Expr){ ._v__ast__TypeNode = ptr, ._typ = 279};
}

static inline v__ast__Expr v__ast__RangeExpr_to_sumtype_v__ast__Expr(v__ast__RangeExpr* x) {
	v__ast__RangeExpr* ptr = memdup(x, sizeof(v__ast__RangeExpr));
	return (v__ast__Expr){ ._v__ast__RangeExpr = ptr, ._typ = 271};
}

static inline v__ast__Stmt v__ast__ExprStmt_to_sumtype_v__ast__Stmt(v__ast__ExprStmt* x) {
	v__ast__ExprStmt* ptr = memdup(x, sizeof(v__ast__ExprStmt));
	return (v__ast__Stmt){ ._v__ast__ExprStmt = ptr, ._typ = 293, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__ExprStmt, pos))};
}

static inline v__ast__TypeInfo v__ast__GenericStructInst_to_sumtype_v__ast__TypeInfo(v__ast__GenericStructInst* x) {
	v__ast__GenericStructInst* ptr = memdup(x, sizeof(v__ast__GenericStructInst));
	return (v__ast__TypeInfo){ ._v__ast__GenericStructInst = ptr, ._typ = 419};
}

static inline v__ast__Stmt v__ast__Module_to_sumtype_v__ast__Stmt(v__ast__Module* x) {
	v__ast__Module* ptr = memdup(x, sizeof(v__ast__Module));
	return (v__ast__Stmt){ ._v__ast__Module = ptr, ._typ = 304, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__Module, pos))};
}

static inline v__ast__Stmt v__ast__Import_to_sumtype_v__ast__Stmt(v__ast__Import* x) {
	v__ast__Import* ptr = memdup(x, sizeof(v__ast__Import));
	return (v__ast__Stmt){ ._v__ast__Import = ptr, ._typ = 302, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__Import, pos))};
}

static inline v__ast__Stmt v__ast__ConstDecl_to_sumtype_v__ast__Stmt(v__ast__ConstDecl* x) {
	v__ast__ConstDecl* ptr = memdup(x, sizeof(v__ast__ConstDecl));
	return (v__ast__Stmt){ ._v__ast__ConstDecl = ptr, ._typ = 289, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__ConstDecl, pos))};
}

static inline v__ast__Stmt v__ast__StructDecl_to_sumtype_v__ast__Stmt(v__ast__StructDecl* x) {
	v__ast__StructDecl* ptr = memdup(x, sizeof(v__ast__StructDecl));
	return (v__ast__Stmt){ ._v__ast__StructDecl = ptr, ._typ = 307, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__StructDecl, pos))};
}

static inline v__ast__Stmt v__ast__InterfaceDecl_to_sumtype_v__ast__Stmt(v__ast__InterfaceDecl* x) {
	v__ast__InterfaceDecl* ptr = memdup(x, sizeof(v__ast__InterfaceDecl));
	return (v__ast__Stmt){ ._v__ast__InterfaceDecl = ptr, ._typ = 303, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__InterfaceDecl, pos))};
}

static inline v__ast__Stmt v__ast__EnumDecl_to_sumtype_v__ast__Stmt(v__ast__EnumDecl* x) {
	v__ast__EnumDecl* ptr = memdup(x, sizeof(v__ast__EnumDecl));
	return (v__ast__Stmt){ ._v__ast__EnumDecl = ptr, ._typ = 292, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__EnumDecl, pos))};
}

static inline v__ast__Stmt v__ast__TypeDecl_to_sumtype_v__ast__Stmt(v__ast__TypeDecl* x) {
	v__ast__TypeDecl* ptr = memdup(x, sizeof(v__ast__TypeDecl));
	return (v__ast__Stmt){ ._v__ast__TypeDecl = ptr, ._typ = 232, .pos = ptr->pos};
}

static inline v__ast__Stmt v__ast__AsmStmt_to_sumtype_v__ast__Stmt(v__ast__AsmStmt* x) {
	v__ast__AsmStmt* ptr = memdup(x, sizeof(v__ast__AsmStmt));
	return (v__ast__Stmt){ ._v__ast__AsmStmt = ptr, ._typ = 283, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__AsmStmt, pos))};
}

static inline v__ast__Stmt v__ast__GlobalDecl_to_sumtype_v__ast__Stmt(v__ast__GlobalDecl* x) {
	v__ast__GlobalDecl* ptr = memdup(x, sizeof(v__ast__GlobalDecl));
	return (v__ast__Stmt){ ._v__ast__GlobalDecl = ptr, ._typ = 297, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__GlobalDecl, pos))};
}

static inline v__ast__Expr v__ast__IfExpr_to_sumtype_v__ast__Expr(v__ast__IfExpr* x) {
	v__ast__IfExpr* ptr = memdup(x, sizeof(v__ast__IfExpr));
	return (v__ast__Expr){ ._v__ast__IfExpr = ptr, ._typ = 255};
}

static inline v__ast__Stmt v__ast__HashStmt_to_sumtype_v__ast__Stmt(v__ast__HashStmt* x) {
	v__ast__HashStmt* ptr = memdup(x, sizeof(v__ast__HashStmt));
	return (v__ast__Stmt){ ._v__ast__HashStmt = ptr, ._typ = 301, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__HashStmt, pos))};
}

static inline v__ast__Expr v__ast__Comment_to_sumtype_v__ast__Expr(v__ast__Comment* x) {
	v__ast__Comment* ptr = memdup(x, sizeof(v__ast__Comment));
	return (v__ast__Expr){ ._v__ast__Comment = ptr, ._typ = 245};
}

static inline v__ast__Stmt v__ast__Block_to_sumtype_v__ast__Stmt(v__ast__Block* x) {
	v__ast__Block* ptr = memdup(x, sizeof(v__ast__Block));
	return (v__ast__Stmt){ ._v__ast__Block = ptr, ._typ = 286, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__Block, pos))};
}

static inline v__ast__Stmt v__ast__AssertStmt_to_sumtype_v__ast__Stmt(v__ast__AssertStmt* x) {
	v__ast__AssertStmt* ptr = memdup(x, sizeof(v__ast__AssertStmt));
	return (v__ast__Stmt){ ._v__ast__AssertStmt = ptr, ._typ = 284, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__AssertStmt, pos))};
}

static inline v__ast__Stmt v__ast__SqlStmt_to_sumtype_v__ast__Stmt(v__ast__SqlStmt* x) {
	v__ast__SqlStmt* ptr = memdup(x, sizeof(v__ast__SqlStmt));
	return (v__ast__Stmt){ ._v__ast__SqlStmt = ptr, ._typ = 306, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__SqlStmt, pos))};
}

static inline v__ast__Stmt v__ast__GotoLabel_to_sumtype_v__ast__Stmt(v__ast__GotoLabel* x) {
	v__ast__GotoLabel* ptr = memdup(x, sizeof(v__ast__GotoLabel));
	return (v__ast__Stmt){ ._v__ast__GotoLabel = ptr, ._typ = 299, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__GotoLabel, pos))};
}

static inline v__ast__Stmt v__ast__CompFor_to_sumtype_v__ast__Stmt(v__ast__CompFor* x) {
	v__ast__CompFor* ptr = memdup(x, sizeof(v__ast__CompFor));
	return (v__ast__Stmt){ ._v__ast__CompFor = ptr, ._typ = 288, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__CompFor, pos))};
}

static inline v__ast__Stmt v__ast__BranchStmt_to_sumtype_v__ast__Stmt(v__ast__BranchStmt* x) {
	v__ast__BranchStmt* ptr = memdup(x, sizeof(v__ast__BranchStmt));
	return (v__ast__Stmt){ ._v__ast__BranchStmt = ptr, ._typ = 287, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__BranchStmt, pos))};
}

static inline v__ast__Stmt v__ast__DeferStmt_to_sumtype_v__ast__Stmt(v__ast__DeferStmt* x) {
	v__ast__DeferStmt* ptr = memdup(x, sizeof(v__ast__DeferStmt));
	return (v__ast__Stmt){ ._v__ast__DeferStmt = ptr, ._typ = 290, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__DeferStmt, pos))};
}

static inline v__ast__Stmt v__ast__GoStmt_to_sumtype_v__ast__Stmt(v__ast__GoStmt* x) {
	v__ast__GoStmt* ptr = memdup(x, sizeof(v__ast__GoStmt));
	return (v__ast__Stmt){ ._v__ast__GoStmt = ptr, ._typ = 298, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__GoStmt, pos))};
}

static inline v__ast__Stmt v__ast__GotoStmt_to_sumtype_v__ast__Stmt(v__ast__GotoStmt* x) {
	v__ast__GotoStmt* ptr = memdup(x, sizeof(v__ast__GotoStmt));
	return (v__ast__Stmt){ ._v__ast__GotoStmt = ptr, ._typ = 300, .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__GotoStmt, pos))};
}

static inline v__ast__AsmArg v__ast__FloatLiteral_to_sumtype_v__ast__AsmArg(v__ast__FloatLiteral* x) {
	v__ast__FloatLiteral* ptr = memdup(x, sizeof(v__ast__FloatLiteral));
	return (v__ast__AsmArg){ ._v__ast__FloatLiteral = ptr, ._typ = 252};
}

static inline v__ast__AsmArg v__ast__AsmDisp_to_sumtype_v__ast__AsmArg(v__ast__AsmDisp* x) {
	v__ast__AsmDisp* ptr = memdup(x, sizeof(v__ast__AsmDisp));
	return (v__ast__AsmArg){ ._v__ast__AsmDisp = ptr, ._typ = 385};
}

static inline v__ast__AsmArg v__ast__IntegerLiteral_to_sumtype_v__ast__AsmArg(v__ast__IntegerLiteral* x) {
	v__ast__IntegerLiteral* ptr = memdup(x, sizeof(v__ast__IntegerLiteral));
	return (v__ast__AsmArg){ ._v__ast__IntegerLiteral = ptr, ._typ = 259};
}

static inline v__ast__AsmArg v__ast__CharLiteral_to_sumtype_v__ast__AsmArg(v__ast__CharLiteral* x) {
	v__ast__CharLiteral* ptr = memdup(x, sizeof(v__ast__CharLiteral));
	return (v__ast__AsmArg){ ._v__ast__CharLiteral = ptr, ._typ = 244};
}

static inline v__ast__AsmArg v__ast__AsmAddressing_to_sumtype_v__ast__AsmArg(v__ast__AsmAddressing* x) {
	v__ast__AsmAddressing* ptr = memdup(x, sizeof(v__ast__AsmAddressing));
	return (v__ast__AsmArg){ ._v__ast__AsmAddressing = ptr, ._typ = 383};
}

static inline v__ast__AsmArg v__ast__AsmAlias_to_sumtype_v__ast__AsmArg(v__ast__AsmAlias* x) {
	v__ast__AsmAlias* ptr = memdup(x, sizeof(v__ast__AsmAlias));
	return (v__ast__AsmArg){ ._v__ast__AsmAlias = ptr, ._typ = 384};
}

static inline v__ast__AsmArg string_to_sumtype_v__ast__AsmArg(string* x) {
	string* ptr = memdup(x, sizeof(string));
	return (v__ast__AsmArg){ ._string = ptr, ._typ = 18};
}

static inline v__ast__Expr v__ast__ConcatExpr_to_sumtype_v__ast__Expr(v__ast__ConcatExpr* x) {
	v__ast__ConcatExpr* ptr = memdup(x, sizeof(v__ast__ConcatExpr));
	return (v__ast__Expr){ ._v__ast__ConcatExpr = ptr, ._typ = 248};
}

static inline v__ast__Expr v__ast__NodeError_to_sumtype_v__ast__Expr(v__ast__NodeError* x) {
	v__ast__NodeError* ptr = memdup(x, sizeof(v__ast__NodeError));
	return (v__ast__Expr){ ._v__ast__NodeError = ptr, ._typ = 264};
}

static inline v__ast__Expr v__ast__ChanInit_to_sumtype_v__ast__Expr(v__ast__ChanInit* x) {
	v__ast__ChanInit* ptr = memdup(x, sizeof(v__ast__ChanInit));
	return (v__ast__Expr){ ._v__ast__ChanInit = ptr, ._typ = 243};
}

static inline v__ast__Expr v__ast__CastExpr_to_sumtype_v__ast__Expr(v__ast__CastExpr* x) {
	v__ast__CastExpr* ptr = memdup(x, sizeof(v__ast__CastExpr));
	return (v__ast__Expr){ ._v__ast__CastExpr = ptr, ._typ = 242};
}

static inline v__ast__Expr v__ast__CallExpr_to_sumtype_v__ast__Expr(v__ast__CallExpr* x) {
	v__ast__CallExpr* ptr = memdup(x, sizeof(v__ast__CallExpr));
	return (v__ast__Expr){ ._v__ast__CallExpr = ptr, ._typ = 241};
}

static inline v__ast__Expr v__ast__SelectorExpr_to_sumtype_v__ast__Expr(v__ast__SelectorExpr* x) {
	v__ast__SelectorExpr* ptr = memdup(x, sizeof(v__ast__SelectorExpr));
	return (v__ast__Expr){ ._v__ast__SelectorExpr = ptr, ._typ = 273};
}

static inline v__ast__Expr v__ast__EnumVal_to_sumtype_v__ast__Expr(v__ast__EnumVal* x) {
	v__ast__EnumVal* ptr = memdup(x, sizeof(v__ast__EnumVal));
	return (v__ast__Expr){ ._v__ast__EnumVal = ptr, ._typ = 251};
}

static inline v__ast__Expr v__ast__StringInterLiteral_to_sumtype_v__ast__Expr(v__ast__StringInterLiteral* x) {
	v__ast__StringInterLiteral* ptr = memdup(x, sizeof(v__ast__StringInterLiteral));
	return (v__ast__Expr){ ._v__ast__StringInterLiteral = ptr, ._typ = 276};
}

static inline v__ast__Expr v__ast__FloatLiteral_to_sumtype_v__ast__Expr(v__ast__FloatLiteral* x) {
	v__ast__FloatLiteral* ptr = memdup(x, sizeof(v__ast__FloatLiteral));
	return (v__ast__Expr){ ._v__ast__FloatLiteral = ptr, ._typ = 252};
}

static inline v__ast__Expr v__ast__IntegerLiteral_to_sumtype_v__ast__Expr(v__ast__IntegerLiteral* x) {
	v__ast__IntegerLiteral* ptr = memdup(x, sizeof(v__ast__IntegerLiteral));
	return (v__ast__Expr){ ._v__ast__IntegerLiteral = ptr, ._typ = 259};
}

static inline v__ast__ScopeObject v__ast__ConstField_to_sumtype_v__ast__ScopeObject(v__ast__ConstField* x) {
	v__ast__ConstField* ptr = memdup(x, sizeof(v__ast__ConstField));
	return (v__ast__ScopeObject){ ._v__ast__ConstField = ptr, ._typ = 310};
}

static inline v__ast__ScopeObject v__ast__GlobalField_to_sumtype_v__ast__ScopeObject(v__ast__GlobalField* x) {
	v__ast__GlobalField* ptr = memdup(x, sizeof(v__ast__GlobalField));
	return (v__ast__ScopeObject){ ._v__ast__GlobalField = ptr, ._typ = 311};
}

static inline v__ast__TypeInfo v__ast__Enum_to_sumtype_v__ast__TypeInfo(v__ast__Enum* x) {
	v__ast__Enum* ptr = memdup(x, sizeof(v__ast__Enum));
	return (v__ast__TypeInfo){ ._v__ast__Enum = ptr, ._typ = 420};
}

static inline v__ast__TypeDecl v__ast__FnTypeDecl_to_sumtype_v__ast__TypeDecl(v__ast__FnTypeDecl* x) {
	v__ast__FnTypeDecl* ptr = memdup(x, sizeof(v__ast__FnTypeDecl));
	return (v__ast__TypeDecl){ ._v__ast__FnTypeDecl = ptr, ._typ = 230, .name = (string*)((char*)ptr + __offsetof_ptr(ptr, v__ast__FnTypeDecl, name)), .is_pub = (bool*)((char*)ptr + __offsetof_ptr(ptr, v__ast__FnTypeDecl, is_pub)), .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__FnTypeDecl, pos)), .comments = (Array_v__ast__Comment*)((char*)ptr + __offsetof_ptr(ptr, v__ast__FnTypeDecl, comments))};
}

static inline v__ast__TypeDecl v__ast__SumTypeDecl_to_sumtype_v__ast__TypeDecl(v__ast__SumTypeDecl* x) {
	v__ast__SumTypeDecl* ptr = memdup(x, sizeof(v__ast__SumTypeDecl));
	return (v__ast__TypeDecl){ ._v__ast__SumTypeDecl = ptr, ._typ = 231, .name = (string*)((char*)ptr + __offsetof_ptr(ptr, v__ast__SumTypeDecl, name)), .is_pub = (bool*)((char*)ptr + __offsetof_ptr(ptr, v__ast__SumTypeDecl, is_pub)), .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__SumTypeDecl, pos)), .comments = (Array_v__ast__Comment*)((char*)ptr + __offsetof_ptr(ptr, v__ast__SumTypeDecl, comments))};
}

static inline v__ast__TypeInfo v__ast__Alias_to_sumtype_v__ast__TypeInfo(v__ast__Alias* x) {
	v__ast__Alias* ptr = memdup(x, sizeof(v__ast__Alias));
	return (v__ast__TypeInfo){ ._v__ast__Alias = ptr, ._typ = 413};
}

static inline v__ast__TypeDecl v__ast__AliasTypeDecl_to_sumtype_v__ast__TypeDecl(v__ast__AliasTypeDecl* x) {
	v__ast__AliasTypeDecl* ptr = memdup(x, sizeof(v__ast__AliasTypeDecl));
	return (v__ast__TypeDecl){ ._v__ast__AliasTypeDecl = ptr, ._typ = 229, .name = (string*)((char*)ptr + __offsetof_ptr(ptr, v__ast__AliasTypeDecl, name)), .is_pub = (bool*)((char*)ptr + __offsetof_ptr(ptr, v__ast__AliasTypeDecl, is_pub)), .pos = (v__token__Position*)((char*)ptr + __offsetof_ptr(ptr, v__ast__AliasTypeDecl, pos)), .comments = (Array_v__ast__Comment*)((char*)ptr + __offsetof_ptr(ptr, v__ast__AliasTypeDecl, comments))};
}

static inline v__ast__Expr v__ast__BoolLiteral_to_sumtype_v__ast__Expr(v__ast__BoolLiteral* x) {
	v__ast__BoolLiteral* ptr = memdup(x, sizeof(v__ast__BoolLiteral));
	return (v__ast__Expr){ ._v__ast__BoolLiteral = ptr, ._typ = 239};
}

static inline v__ast__Expr v__ast__UnsafeExpr_to_sumtype_v__ast__Expr(v__ast__UnsafeExpr* x) {
	v__ast__UnsafeExpr* ptr = memdup(x, sizeof(v__ast__UnsafeExpr));
	return (v__ast__Expr){ ._v__ast__UnsafeExpr = ptr, ._typ = 281};
}

static inline v__ast__Expr v__ast__AtExpr_to_sumtype_v__ast__Expr(v__ast__AtExpr* x) {
	v__ast__AtExpr* ptr = memdup(x, sizeof(v__ast__AtExpr));
	return (v__ast__Expr){ ._v__ast__AtExpr = ptr, ._typ = 238};
}

static inline v__ast__Expr v__ast__CharLiteral_to_sumtype_v__ast__Expr(v__ast__CharLiteral* x) {
	v__ast__CharLiteral* ptr = memdup(x, sizeof(v__ast__CharLiteral));
	return (v__ast__Expr){ ._v__ast__CharLiteral = ptr, ._typ = 244};
}

static inline v__ast__Expr v__ast__PrefixExpr_to_sumtype_v__ast__Expr(v__ast__PrefixExpr* x) {
	v__ast__PrefixExpr* ptr = memdup(x, sizeof(v__ast__PrefixExpr));
	return (v__ast__Expr){ ._v__ast__PrefixExpr = ptr, ._typ = 270};
}

static inline v__ast__Expr v__ast__GoExpr_to_sumtype_v__ast__Expr(v__ast__GoExpr* x) {
	v__ast__GoExpr* ptr = memdup(x, sizeof(v__ast__GoExpr));
	return (v__ast__Expr){ ._v__ast__GoExpr = ptr, ._typ = 253};
}

static inline v__ast__Expr v__ast__MatchExpr_to_sumtype_v__ast__Expr(v__ast__MatchExpr* x) {
	v__ast__MatchExpr* ptr = memdup(x, sizeof(v__ast__MatchExpr));
	return (v__ast__Expr){ ._v__ast__MatchExpr = ptr, ._typ = 263};
}

static inline v__ast__Expr v__ast__SelectExpr_to_sumtype_v__ast__Expr(v__ast__SelectExpr* x) {
	v__ast__SelectExpr* ptr = memdup(x, sizeof(v__ast__SelectExpr));
	return (v__ast__Expr){ ._v__ast__SelectExpr = ptr, ._typ = 272};
}

static inline v__ast__Expr v__ast__ParExpr_to_sumtype_v__ast__Expr(v__ast__ParExpr* x) {
	v__ast__ParExpr* ptr = memdup(x, sizeof(v__ast__ParExpr));
	return (v__ast__Expr){ ._v__ast__ParExpr = ptr, ._typ = 268};
}

static inline v__ast__Expr v__ast__LockExpr_to_sumtype_v__ast__Expr(v__ast__LockExpr* x) {
	v__ast__LockExpr* ptr = memdup(x, sizeof(v__ast__LockExpr));
	return (v__ast__Expr){ ._v__ast__LockExpr = ptr, ._typ = 261};
}

static inline v__ast__Expr v__ast__None_to_sumtype_v__ast__Expr(v__ast__None* x) {
	v__ast__None* ptr = memdup(x, sizeof(v__ast__None));
	return (v__ast__Expr){ ._v__ast__None = ptr, ._typ = 265};
}

static inline v__ast__Expr v__ast__SizeOf_to_sumtype_v__ast__Expr(v__ast__SizeOf* x) {
	v__ast__SizeOf* ptr = memdup(x, sizeof(v__ast__SizeOf));
	return (v__ast__Expr){ ._v__ast__SizeOf = ptr, ._typ = 274};
}

static inline v__ast__Expr v__ast__TypeOf_to_sumtype_v__ast__Expr(v__ast__TypeOf* x) {
	v__ast__TypeOf* ptr = memdup(x, sizeof(v__ast__TypeOf));
	return (v__ast__Expr){ ._v__ast__TypeOf = ptr, ._typ = 280};
}

static inline v__ast__Expr v__ast__DumpExpr_to_sumtype_v__ast__Expr(v__ast__DumpExpr* x) {
	v__ast__DumpExpr* ptr = memdup(x, sizeof(v__ast__DumpExpr));
	return (v__ast__Expr){ ._v__ast__DumpExpr = ptr, ._typ = 249};
}

static inline v__ast__Expr v__ast__OffsetOf_to_sumtype_v__ast__Expr(v__ast__OffsetOf* x) {
	v__ast__OffsetOf* ptr = memdup(x, sizeof(v__ast__OffsetOf));
	return (v__ast__Expr){ ._v__ast__OffsetOf = ptr, ._typ = 266};
}

static inline v__ast__Expr v__ast__Likely_to_sumtype_v__ast__Expr(v__ast__Likely* x) {
	v__ast__Likely* ptr = memdup(x, sizeof(v__ast__Likely));
	return (v__ast__Expr){ ._v__ast__Likely = ptr, ._typ = 260};
}

static inline v__ast__Expr v__ast__Assoc_to_sumtype_v__ast__Expr(v__ast__Assoc* x) {
	v__ast__Assoc* ptr = memdup(x, sizeof(v__ast__Assoc));
	return (v__ast__Expr){ ._v__ast__Assoc = ptr, ._typ = 237};
}

static inline v__ast__Expr v__ast__AnonFn_to_sumtype_v__ast__Expr(v__ast__AnonFn* x) {
	v__ast__AnonFn* ptr = memdup(x, sizeof(v__ast__AnonFn));
	return (v__ast__Expr){ ._v__ast__AnonFn = ptr, ._typ = 233};
}

static inline v__ast__Expr v__ast__IndexExpr_to_sumtype_v__ast__Expr(v__ast__IndexExpr* x) {
	v__ast__IndexExpr* ptr = memdup(x, sizeof(v__ast__IndexExpr));
	return (v__ast__Expr){ ._v__ast__IndexExpr = ptr, ._typ = 257};
}

static inline v__ast__Expr v__ast__AsCast_to_sumtype_v__ast__Expr(v__ast__AsCast* x) {
	v__ast__AsCast* ptr = memdup(x, sizeof(v__ast__AsCast));
	return (v__ast__Expr){ ._v__ast__AsCast = ptr, ._typ = 236};
}

static inline v__ast__Expr v__ast__PostfixExpr_to_sumtype_v__ast__Expr(v__ast__PostfixExpr* x) {
	v__ast__PostfixExpr* ptr = memdup(x, sizeof(v__ast__PostfixExpr));
	return (v__ast__Expr){ ._v__ast__PostfixExpr = ptr, ._typ = 269};
}

static inline v__ast__Expr v__ast__SqlExpr_to_sumtype_v__ast__Expr(v__ast__SqlExpr* x) {
	v__ast__SqlExpr* ptr = memdup(x, sizeof(v__ast__SqlExpr));
	return (v__ast__Expr){ ._v__ast__SqlExpr = ptr, ._typ = 275};
}

static inline v__ast__TypeInfo v__ast__Interface_to_sumtype_v__ast__TypeInfo(v__ast__Interface* x) {
	v__ast__Interface* ptr = memdup(x, sizeof(v__ast__Interface));
	return (v__ast__TypeInfo){ ._v__ast__Interface = ptr, ._typ = 410};
}

static inline v__ast__Expr v__ast__CTempVar_to_sumtype_v__ast__Expr(v__ast__CTempVar* x) {
	v__ast__CTempVar* ptr = memdup(x, sizeof(v__ast__CTempVar));
	return (v__ast__Expr){ ._v__ast__CTempVar = ptr, ._typ = 240};
}

static bool v__ast__EmbeddedFile_struct_eq(v__ast__EmbeddedFile a, v__ast__EmbeddedFile b) {
	if (string_ne(a.rpath, b.rpath)) {
		return false;
	}
	if (string_ne(a.apath, b.apath)) {
		return false;
	}
	return true;
}

static bool Array_v__ast__EmbeddedFile_contains(Array_v__ast__EmbeddedFile a, v__ast__EmbeddedFile v) {
	for (int i = 0; i < a.len; ++i) {
		if (v__ast__EmbeddedFile_struct_eq(*(v__ast__EmbeddedFile*)array_get(a, i), v)) {
			return true;
		}
	}
	return false;
}

static bool Array_v__ast__Kind_contains(Array_v__ast__Kind a, v__ast__Kind v) {
	for (int i = 0; i < a.len; ++i) {
		if ((*(v__ast__Kind*)array_get(a, i)) == v) {
			return true;
		}
	}
	return false;
}

static bool v__token__Position_struct_eq(v__token__Position a, v__token__Position b) {
	if (a.len != b.len) {
		return false;
	}
	if (a.line_nr != b.line_nr) {
		return false;
	}
	if (a.pos != b.pos) {
		return false;
	}
	if (a.col != b.col) {
		return false;
	}
	if (a.last_line != b.last_line) {
		return false;
	}
	return true;
}

static bool v__ast__IntegerLiteral_struct_eq(v__ast__IntegerLiteral a, v__ast__IntegerLiteral b) {
	if (string_ne(a.val, b.val)) {
		return false;
	}
	if (!v__token__Position_struct_eq(a.pos, b.pos)) {
		return false;
	}
	return true;
}

static bool v__ast__FloatLiteral_struct_eq(v__ast__FloatLiteral a, v__ast__FloatLiteral b) {
	if (string_ne(a.val, b.val)) {
		return false;
	}
	if (!v__token__Position_struct_eq(a.pos, b.pos)) {
		return false;
	}
	return true;
}


// V out

// >> typeof() support for sum types / interfaces
static char * v_typeof_interface_IError(int sidx) { /* IError */ 
	if (sidx == _IError_None___index) return "None__";
	if (sidx == _IError_Error_index) return "Error";
	if (sidx == _IError_flag__UnkownFlagError_index) return "flag.UnkownFlagError";
	if (sidx == _IError_flag__MinimumArgsCountError_index) return "flag.MinimumArgsCountError";
	if (sidx == _IError_flag__MaximumArgsCountError_index) return "flag.MaximumArgsCountError";
	if (sidx == _IError_flag__NoArgsExpectedError_index) return "flag.NoArgsExpectedError";
	if (sidx == _IError_semver__InvalidComparatorFormatError_index) return "semver.InvalidComparatorFormatError";
	if (sidx == _IError_semver__EmptyInputError_index) return "semver.EmptyInputError";
	if (sidx == _IError_semver__InvalidVersionFormatError_index) return "semver.InvalidVersionFormatError";
	return "unknown IError";
}
static char * v_typeof_interface_hash__Hasher(int sidx) { /* hash.Hasher */ 
	return "unknown hash.Hasher";
}
static char * v_typeof_interface_hash__Hash32er(int sidx) { /* hash.Hash32er */ 
	return "unknown hash.Hash32er";
}
static char * v_typeof_interface_hash__Hash64er(int sidx) { /* hash.Hash64er */ 
	return "unknown hash.Hash64er";
}
static char * v_typeof_interface_rand__PRNG(int sidx) { /* rand.PRNG */ 
	if (sidx == _rand__PRNG_rand__wyrand__WyRandRNG_index) return "rand.wyrand.WyRandRNG";
	return "unknown rand.PRNG";
}
static char * v_typeof_sumtype_v__ast__TypeDecl(int sidx) { /* v.ast.TypeDecl */ 
	switch(sidx) {
		case 232: return "v.ast.TypeDecl";
		case 229: return "v.ast.AliasTypeDecl";
		case 230: return "v.ast.FnTypeDecl";
		case 231: return "v.ast.SumTypeDecl";
		default: return "unknown v.ast.TypeDecl";
	}
}
static char * v_typeof_sumtype_v__ast__Expr(int sidx) { /* v.ast.Expr */ 
	switch(sidx) {
		case 282: return "v.ast.Expr";
		case 233: return "v.ast.AnonFn";
		case 234: return "v.ast.ArrayDecompose";
		case 235: return "v.ast.ArrayInit";
		case 236: return "v.ast.AsCast";
		case 237: return "v.ast.Assoc";
		case 238: return "v.ast.AtExpr";
		case 239: return "v.ast.BoolLiteral";
		case 240: return "v.ast.CTempVar";
		case 241: return "v.ast.CallExpr";
		case 242: return "v.ast.CastExpr";
		case 243: return "v.ast.ChanInit";
		case 244: return "v.ast.CharLiteral";
		case 245: return "v.ast.Comment";
		case 246: return "v.ast.ComptimeCall";
		case 247: return "v.ast.ComptimeSelector";
		case 248: return "v.ast.ConcatExpr";
		case 249: return "v.ast.DumpExpr";
		case 250: return "v.ast.EmptyExpr";
		case 251: return "v.ast.EnumVal";
		case 252: return "v.ast.FloatLiteral";
		case 253: return "v.ast.GoExpr";
		case 254: return "v.ast.Ident";
		case 255: return "v.ast.IfExpr";
		case 256: return "v.ast.IfGuardExpr";
		case 257: return "v.ast.IndexExpr";
		case 258: return "v.ast.InfixExpr";
		case 259: return "v.ast.IntegerLiteral";
		case 260: return "v.ast.Likely";
		case 261: return "v.ast.LockExpr";
		case 262: return "v.ast.MapInit";
		case 263: return "v.ast.MatchExpr";
		case 264: return "v.ast.NodeError";
		case 265: return "v.ast.None";
		case 266: return "v.ast.OffsetOf";
		case 267: return "v.ast.OrExpr";
		case 268: return "v.ast.ParExpr";
		case 269: return "v.ast.PostfixExpr";
		case 270: return "v.ast.PrefixExpr";
		case 271: return "v.ast.RangeExpr";
		case 272: return "v.ast.SelectExpr";
		case 273: return "v.ast.SelectorExpr";
		case 274: return "v.ast.SizeOf";
		case 275: return "v.ast.SqlExpr";
		case 276: return "v.ast.StringInterLiteral";
		case 277: return "v.ast.StringLiteral";
		case 278: return "v.ast.StructInit";
		case 279: return "v.ast.TypeNode";
		case 280: return "v.ast.TypeOf";
		case 281: return "v.ast.UnsafeExpr";
		default: return "unknown v.ast.Expr";
	}
}
static char * v_typeof_sumtype_v__ast__Stmt(int sidx) { /* v.ast.Stmt */ 
	switch(sidx) {
		case 308: return "v.ast.Stmt";
		case 283: return "v.ast.AsmStmt";
		case 284: return "v.ast.AssertStmt";
		case 285: return "v.ast.AssignStmt";
		case 286: return "v.ast.Block";
		case 287: return "v.ast.BranchStmt";
		case 288: return "v.ast.CompFor";
		case 289: return "v.ast.ConstDecl";
		case 290: return "v.ast.DeferStmt";
		case 291: return "v.ast.EmptyStmt";
		case 292: return "v.ast.EnumDecl";
		case 293: return "v.ast.ExprStmt";
		case 175: return "v.ast.FnDecl";
		case 294: return "v.ast.ForCStmt";
		case 295: return "v.ast.ForInStmt";
		case 296: return "v.ast.ForStmt";
		case 297: return "v.ast.GlobalDecl";
		case 298: return "v.ast.GoStmt";
		case 299: return "v.ast.GotoLabel";
		case 300: return "v.ast.GotoStmt";
		case 301: return "v.ast.HashStmt";
		case 302: return "v.ast.Import";
		case 303: return "v.ast.InterfaceDecl";
		case 304: return "v.ast.Module";
		case 264: return "v.ast.NodeError";
		case 305: return "v.ast.Return";
		case 306: return "v.ast.SqlStmt";
		case 307: return "v.ast.StructDecl";
		case 232: return "v.ast.TypeDecl";
		default: return "unknown v.ast.Stmt";
	}
}
static char * v_typeof_sumtype_v__ast__ScopeObject(int sidx) { /* v.ast.ScopeObject */ 
	switch(sidx) {
		case 313: return "v.ast.ScopeObject";
		case 309: return "v.ast.AsmRegister";
		case 310: return "v.ast.ConstField";
		case 311: return "v.ast.GlobalField";
		case 312: return "v.ast.Var";
		default: return "unknown v.ast.ScopeObject";
	}
}
static char * v_typeof_sumtype_v__ast__Node(int sidx) { /* v.ast.Node */ 
	switch(sidx) {
		case 324: return "v.ast.Node";
		case 314: return "v.ast.CallArg";
		case 310: return "v.ast.ConstField";
		case 315: return "v.ast.EmptyNode";
		case 316: return "v.ast.EnumField";
		case 282: return "v.ast.Expr";
		case 166: return "v.ast.File";
		case 311: return "v.ast.GlobalField";
		case 317: return "v.ast.IfBranch";
		case 318: return "v.ast.MatchBranch";
		case 264: return "v.ast.NodeError";
		case 319: return "v.ast.Param";
		case 313: return "v.ast.ScopeObject";
		case 320: return "v.ast.SelectBranch";
		case 308: return "v.ast.Stmt";
		case 321: return "v.ast.StructField";
		case 322: return "v.ast.StructInitField";
		case 323: return "v.ast.SumTypeVariant";
		default: return "unknown v.ast.Node";
	}
}
static char * v_typeof_sumtype_v__ast__IdentInfo(int sidx) { /* v.ast.IdentInfo */ 
	switch(sidx) {
		case 364: return "v.ast.IdentInfo";
		case 362: return "v.ast.IdentFn";
		case 363: return "v.ast.IdentVar";
		default: return "unknown v.ast.IdentInfo";
	}
}
static char * v_typeof_sumtype_v__ast__AsmArg(int sidx) { /* v.ast.AsmArg */ 
	switch(sidx) {
		case 381: return "v.ast.AsmArg";
		case 383: return "v.ast.AsmAddressing";
		case 384: return "v.ast.AsmAlias";
		case 385: return "v.ast.AsmDisp";
		case 309: return "v.ast.AsmRegister";
		case 239: return "v.ast.BoolLiteral";
		case 244: return "v.ast.CharLiteral";
		case 252: return "v.ast.FloatLiteral";
		case 259: return "v.ast.IntegerLiteral";
		case 18: return "string";
		default: return "unknown v.ast.AsmArg";
	}
}
static char * v_typeof_sumtype_v__ast__TypeInfo(int sidx) { /* v.ast.TypeInfo */ 
	switch(sidx) {
		case 421: return "v.ast.TypeInfo";
		case 408: return "v.ast.Aggregate";
		case 413: return "v.ast.Alias";
		case 395: return "v.ast.Array";
		case 416: return "v.ast.ArrayFixed";
		case 414: return "v.ast.Chan";
		case 420: return "v.ast.Enum";
		case 418: return "v.ast.FnType";
		case 419: return "v.ast.GenericStructInst";
		case 410: return "v.ast.Interface";
		case 396: return "v.ast.Map";
		case 417: return "v.ast.MultiReturn";
		case 409: return "v.ast.Struct";
		case 411: return "v.ast.SumType";
		case 415: return "v.ast.Thread";
		default: return "unknown v.ast.TypeInfo";
	}
}
// << typeof() support for sum types


void _STR_PRINT_ARG(const char *fmt, char** refbufp, int *nbytes, int *memsize, int guess, ...) {
	va_list args;
	va_start(args, guess);
	// NB: (*memsize - *nbytes) === how much free space is left at the end of the current buffer refbufp
	// *memsize === total length of the buffer refbufp
	// *nbytes === already occupied bytes of buffer refbufp
	// guess === how many bytes were taken during the current vsnprintf run
	for(;;) {
		if (guess < *memsize - *nbytes) {
			guess = vsnprintf(*refbufp + *nbytes, *memsize - *nbytes, fmt, args);
			if (guess < *memsize - *nbytes) { // result did fit into buffer
				*nbytes += guess;
				break;
			}
		}
		// increase buffer (somewhat exponentially)
		*memsize += (*memsize + *memsize) / 3 + guess;
#ifdef _VGCBOEHM
		*refbufp = (char*)GC_REALLOC((void*)*refbufp, *memsize);
#else
		*refbufp = (char*)realloc((void*)*refbufp, *memsize);
#endif
	}
	va_end(args);
}

string _STR(const char *fmt, int nfmts, ...) {
	va_list argptr;
	int memsize = 128;
	int nbytes = 0;
#ifdef _VGCBOEHM
	char* buf = (char*)GC_MALLOC(memsize);
#else
	char* buf = (char*)malloc(memsize);
#endif
	va_start(argptr, nfmts);
	for (int i=0; i<nfmts; ++i) {
		int k = strlen(fmt);
		bool is_fspec = false;
		for (int j=0; j<k; ++j) {
			if (fmt[j] == '%') {
				j++;
				if (fmt[j] != '%') {
					is_fspec = true;
					break;
				}
			}
		}
		if (is_fspec) {
			char f = fmt[k-1];
			char fup = f & 0xdf; // toupper
			bool l = fmt[k-2] == 'l';
			bool ll = l && fmt[k-3] == 'l';
			if (f == 'u' || fup == 'X' || f == 'o' || f == 'd' || f == 'c') { // int...
				if (ll) _STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+16, va_arg(argptr, long long));
				else if (l) _STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+10, va_arg(argptr, long));
				else _STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+8, va_arg(argptr, int));
			} else if (fup >= 'E' && fup <= 'G') { // floating point
				_STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+10, va_arg(argptr, double));
			} else if (f == 'p') {
				_STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+14, va_arg(argptr, void*));
			} else if (f == 's') { // v string
				string s = va_arg(argptr, string);
				if (fmt[k-4] == '*') { // %*.*s
					int fwidth = va_arg(argptr, int);
					if (fwidth < 0)
						fwidth -= (s.len - utf8_str_visible_length(s));
					else
						fwidth += (s.len - utf8_str_visible_length(s));
					_STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+s.len-4, fwidth, s.len, s.str);
				} else { // %.*s
					_STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+s.len-4, s.len, s.str);
				}
			} else {
				//v_panic(tos3('Invaid format specifier'));
			}
		} else {
			_STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k);
		}
		fmt += k+1;
	}
	va_end(argptr);
	buf[nbytes] = 0;

#ifdef _VGCBOEHM
	buf = (char*)GC_REALLOC((void*)buf, nbytes+1);
#else
	buf = (char*)realloc((void*)buf, nbytes+1);
#endif

#ifdef DEBUG_ALLOC
	//puts('_STR:');
	puts(buf);
#endif

#if _VAUTOFREE
	//g_cur_str = (byteptr)buf;
#endif
	return tos2((byteptr)buf);
}

string _STR_TMP(const char *fmt, ...) {
	va_list argptr;
	va_start(argptr, fmt);
	size_t len = vsnprintf(0, 0, fmt, argptr) + 1;
	va_end(argptr);
	va_start(argptr, fmt);
	vsprintf((char *)g_str_buf, fmt, argptr);
	va_end(argptr);

#ifdef DEBUG_ALLOC
	//puts('_STR_TMP:');
	//puts(g_str_buf);
#endif
	string res = tos(g_str_buf,  len);
	res.is_lit = 1;
	return res;

} // endof _STR_TMP


	// pointers to common sumtype fields
	// pointers to common sumtype fields
	// pointers to common sumtype fields
strings__Builder strings__new_builder(int initial_size) {
	return (strings__Builder){.buf = __new_array_with_default(0, initial_size, sizeof(byte), 0),.len = 0,.initial_size = initial_size,};
}

// Attr: [deprecated]
// Attr: [deprecated_after]
// Attr: [unsafe]
void strings__Builder_write_bytes(strings__Builder* b, byte* bytes, int len) {
	strings__Builder_write_ptr(b, bytes, len);
}

// Attr: [unsafe]
void strings__Builder_write_ptr(strings__Builder* b, byte* ptr, int len) {
	array_push_many(&b->buf, ptr, len);
	b->len += len;
}

void strings__Builder_write_b(strings__Builder* b, byte data) {
	array_push(&b->buf, _MOV((byte[]){ data }));
	b->len++;
}

Option_int strings__Builder_write(strings__Builder* b, Array_byte data) {
	_PUSH_MANY(&b->buf, (data), _t2, Array_byte);
	b->len += data.len;
	Option_int _t3;
	opt_ok(&(int[]) { data.len }, (Option*)(&_t3), sizeof(int));
	return _t3;
}

// Attr: [inline]
inline void strings__Builder_write_string(strings__Builder* b, string s) {
	if ((s).len == 0) {
		return;
	}
	array_push_many(&b->buf, s.str, s.len);
	b->len += s.len;
}

void strings__Builder_go_back(strings__Builder* b, int n) {
	array_trim(&b->buf, b->buf.len - n);
	b->len -= n;
}

VV_LOCAL_SYMBOL string strings__bytes2string(Array_byte b) {
	Array_byte copy = array_clone(&b);
	array_push(&copy, _MOV((byte[]){ ((byte)(L'\0')) }));
	return tos(copy.data, copy.len - 1);
}

string strings__Builder_cut_last(strings__Builder* b, int n) {
	string res = strings__bytes2string(array_slice(b->buf, b->len - n, b->buf.len));
	array_trim(&b->buf, b->buf.len - n);
	b->len -= n;
	return res;
}

void strings__Builder_go_back_to(strings__Builder* b, int pos) {
	array_trim(&b->buf, pos);
	b->len = pos;
}

// Attr: [inline]
inline void strings__Builder_writeln(strings__Builder* b, string s) {
	array_push_many(&b->buf, s.str, s.len);
	array_push(&b->buf, _MOV((byte[]){ L'\n' }));
	b->len += s.len + 1;
}

string strings__Builder_last_n(strings__Builder* b, int n) {
	if (n > b->len) {
		return _SLIT("");
	}
	return strings__bytes2string(array_slice(b->buf, b->len - n, b->buf.len));
}

string strings__Builder_after(strings__Builder* b, int n) {
	if (n >= b->len) {
		return _SLIT("");
	}
	return strings__bytes2string(array_slice(b->buf, n, b->buf.len));
}

string strings__Builder_str(strings__Builder* b) {
	array_push(&b->buf, _MOV((byte[]){ L'\0' }));
	string s = byte_vstring_with_len((((byte*)(memdup(b->buf.data, b->len)))), b->len);
	b->len = 0;
	array_trim(&b->buf, 0);
	return s;
}

// Attr: [unsafe]
void strings__Builder_free(strings__Builder* b) {
	v_free(b->buf.data);
	b->len = 0;
}

int strings__levenshtein_distance(string a, string b) {
	Array_int f = array_repeat(new_array_from_c_array(1, 1, sizeof(int), _MOV((int[1]){0})), b.len + 1);
	for (int j = 0; j < f.len; ++j) {
		array_set(&f, j, &(int[]) { j });
	}
	for (int _t7 = 0; _t7 < a.len; ++_t7) {
		byte ca = a.str[_t7];
		int j = 1;
		int fj1 = (*(int*)/*ee elem_typ */array_get(f, 0));
		(*(int*)/*ee elem_typ */array_get(f, 0))++;
		for (int _t8 = 0; _t8 < b.len; ++_t8) {
			byte cb = b.str[_t8];
			int mn = ((*(int*)/*ee elem_typ */array_get(f, j)) + 1 <= (*(int*)/*ee elem_typ */array_get(f, j - 1)) + 1 ? ((*(int*)/*ee elem_typ */array_get(f, j)) + 1) : ((*(int*)/*ee elem_typ */array_get(f, j - 1)) + 1));
			if (cb != ca) {
				mn = (mn <= fj1 + 1 ? (mn) : (fj1 + 1));
			} else {
				mn = (mn <= fj1 ? (mn) : (fj1));
			}
			fj1 = (*(int*)/*ee elem_typ */array_get(f, j));
			array_set(&f, j, &(int[]) { mn });
			j++;
		}
	}
	return (*(int*)/*ee elem_typ */array_get(f, f.len - 1));
}

f32 strings__levenshtein_distance_percentage(string a, string b) {
	int d = strings__levenshtein_distance(a, b);
	int l = (a.len >= b.len ? (a.len) : (b.len));
	return (1.00 - ((f32)(d)) / ((f32)(l))) * 100.00;
}

f32 strings__dice_coefficient(string s1, string s2) {
	if (s1.len == 0 || s2.len == 0) {
		return 0.0;
	}
	if (string_eq(s1, s2)) {
		return 1.0;
	}
	if (s1.len < 2 || s2.len < 2) {
		return 0.0;
	}
	string a = (s1.len > s2.len ? (s1) : (s2));
	string b = (string_eq(a, s1) ? (s2) : (s1));
	Map_string_int first_bigrams = new_map(sizeof(string), sizeof(int), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
	for (int i = 0; i < a.len - 1; ++i) {
		string bigram = string_substr(a, i, i + 2);
		int q = (_IN_MAP(ADDR(string, bigram), ADDR(map, first_bigrams)) ? ((*(int*)map_get(ADDR(map, first_bigrams), &(string[]){bigram}, &(int[]){ 0 })) + 1) : (1));
		map_set(&first_bigrams, &(string[]){bigram}, &(int[]) { q });
	}
	int intersection_size = 0;
	for (int i = 0; i < b.len - 1; ++i) {
		string bigram = string_substr(b, i, i + 2);
		int count = (_IN_MAP(ADDR(string, bigram), ADDR(map, first_bigrams)) ? ((*(int*)map_get(ADDR(map, first_bigrams), &(string[]){bigram}, &(int[]){ 0 }))) : (0));
		if (count > 0) {
			map_set(&first_bigrams, &(string[]){bigram}, &(int[]) { count - 1 });
			intersection_size++;
		}
	}
	return (2.0 * ((f32)(intersection_size))) / (((f32)(a.len)) + ((f32)(b.len)) - 2);
}

string strings__repeat(byte c, int n) {
	if (n <= 0) {
		return _SLIT("");
	}
	byte* bytes = v_malloc(n + 1);
	{ // Unsafe block
		memset(bytes, c, n);
		bytes[n] = L'0';
	}
	return byte_vstring_with_len(bytes, n);
}

string strings__repeat_string(string s, int n) {
	if (n <= 0 || s.len == 0) {
		return _SLIT("");
	}
	int slen = s.len;
	int blen = slen * n;
	byte* bytes = v_malloc(blen + 1);
	for (int bi = 0; bi < n; ++bi) {
		int bislen = bi * slen;
		for (int si = 0; si < slen; ++si) {
			{ // Unsafe block
				bytes[bislen + si] = string_at(s, si);
			}
		}
	}
	{ // Unsafe block
		bytes[blen] = L'0';
	}
	return byte_vstring_with_len(bytes, blen);
}

// Attr: [inline]
inline u64 hash__wyhash_c(byteptr key, u64 len, u64 seed) {
	 u64 _t9 = wyhash(key, len, seed, ((u64*)(_wyp)));
	// autofree_scope_vars(pos=204 line_nr=9 scope.pos=157 scope.end_pos=251)
	// var "key" var.pos=166 var.line_nr=8
	// var "len" var.pos=179 var.line_nr=8
	// var "seed" var.pos=188 var.line_nr=8
	// af parent scope:
	// af parent scope:
	return _t9;
}

// Attr: [inline]
inline u64 hash__wyhash64_c(u64 a, u64 b) {
	 u64 _t10 = wyhash64(a, b);
	// autofree_scope_vars(pos=301 line_nr=14 scope.pos=270 scope.end_pos=326)
	// var "a" var.pos=281 var.line_nr=13
	// var "b" var.pos=288 var.line_nr=13
	// af parent scope:
	// af parent scope:
	return _t10;
}

// Attr: [inline]
inline u64 hash__sum64_string(string key, u64 seed) {
	 u64 _t11 = hash__wyhash64(key.str, ((u64)(key.len)), seed);
	// autofree_scope_vars(pos=861 line_nr=27 scope.pos=820 scope.end_pos=907)
	// var "key" var.pos=833 var.line_nr=26
	// var "seed" var.pos=845 var.line_nr=26
	// af parent scope:
	// af parent scope:
	return _t11;
}

// Attr: [inline]
inline u64 hash__sum64(Array_byte key, u64 seed) {
	 u64 _t12 = hash__wyhash64(((byteptr)(key.data)), ((u64)(key.len)), seed);
	// autofree_scope_vars(pos=960 line_nr=32 scope.pos=926 scope.end_pos=1016)
	// var "key" var.pos=932 var.line_nr=31
	// var "seed" var.pos=944 var.line_nr=31
	// af parent scope:
	// af parent scope:
	return _t12;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL u64 hash__wyhash64(byteptr key, u64 len, u64 seed_) {
	if (len == 0) {
		 u64 _t13 = 0;
		// autofree_scope_vars(pos=1095 line_nr=38 scope.pos=1092 scope.end_pos=1106)
		// af parent scope:
		// var "key" var.pos=1040 var.line_nr=36
		// var "len" var.pos=1053 var.line_nr=36
		// var "seed_" var.pos=1062 var.line_nr=36
		// var "p" var.pos=1113 var.line_nr=40
		// var "seed" var.pos=1127 var.line_nr=41
		// var "i" var.pos=1146 var.line_nr=42
		// var "see1" var.pos=2010 var.line_nr=66
		// var "see2" var.pos=2028 var.line_nr=67
		// var "see3" var.pos=2046 var.line_nr=68
		// af parent scope:
		// af parent scope:
		return _t13;
	}
	byteptr p = key;
	u64 seed = seed_;
	u64 i = (len & 63);
	u64 _t14;
	
	if ((i <= 3)) {
		_t14 = hash__wymum(((hash__wyr3(p, i) ^ seed) ^ _const_hash__wyp0), (seed ^ _const_hash__wyp1));
	}
	else if ((i >= 4 && i <= 8)) {
		_t14 = hash__wymum(((hash__wyr4(p) ^ seed) ^ _const_hash__wyp0), ((hash__wyr4(p + i - 4) ^ seed) ^ _const_hash__wyp1));
	}
	else if ((i >= 9 && i <= 16)) {
		_t14 = hash__wymum(((hash__wyr8(p) ^ seed) ^ _const_hash__wyp0), ((hash__wyr8(p + i - 8) ^ seed) ^ _const_hash__wyp1));
	}
	else if ((i >= 17 && i <= 24)) {
		_t14 = (hash__wymum(((hash__wyr8(p) ^ seed) ^ _const_hash__wyp0), ((hash__wyr8(p + 8) ^ seed) ^ _const_hash__wyp1)) ^ hash__wymum(((hash__wyr8(p + i - 8) ^ seed) ^ _const_hash__wyp2), (seed ^ _const_hash__wyp3)));
	}
	else if ((i >= 25 && i <= 32)) {
		_t14 = (hash__wymum(((hash__wyr8(p) ^ seed) ^ _const_hash__wyp0), ((hash__wyr8(p + 8) ^ seed) ^ _const_hash__wyp1)) ^ hash__wymum(((hash__wyr8(p + 16) ^ seed) ^ _const_hash__wyp2), ((hash__wyr8(p + i - 8) ^ seed) ^ _const_hash__wyp3)));
	}
	else {
		_t14 = (((hash__wymum(((hash__wyr8(p) ^ seed) ^ _const_hash__wyp0), ((hash__wyr8(p + 8) ^ seed) ^ _const_hash__wyp1)) ^ hash__wymum(((hash__wyr8(p + 16) ^ seed) ^ _const_hash__wyp2), ((hash__wyr8(p + 24) ^ seed) ^ _const_hash__wyp3))) ^ hash__wymum(((hash__wyr8(p + i - 32) ^ seed) ^ _const_hash__wyp1), ((hash__wyr8(p + i - 24) ^ seed) ^ _const_hash__wyp2))) ^ hash__wymum(((hash__wyr8(p + i - 16) ^ seed) ^ _const_hash__wyp3), ((hash__wyr8(p + i - 8) ^ seed) ^ _const_hash__wyp0)));
	}	seed = _t14;
	if (i == len) {
		 u64 _t15 = hash__wymum(seed, (len ^ _const_hash__wyp4));
		// autofree_scope_vars(pos=1970 line_nr=64 scope.pos=1967 scope.end_pos=2003)
		// af parent scope:
		// var "key" var.pos=1040 var.line_nr=36
		// var "len" var.pos=1053 var.line_nr=36
		// var "seed_" var.pos=1062 var.line_nr=36
		// var "p" var.pos=1113 var.line_nr=40
		// var "seed" var.pos=1127 var.line_nr=41
		// var "i" var.pos=1146 var.line_nr=42
		// var "see1" var.pos=2010 var.line_nr=66
		// var "see2" var.pos=2028 var.line_nr=67
		// var "see3" var.pos=2046 var.line_nr=68
		// af parent scope:
		// af parent scope:
		return _t15;
	}
	u64 see1 = seed;
	u64 see2 = seed;
	u64 see3 = seed;
	{ // Unsafe block
		p = p + i;
		for (i = len - i; i >= 64; i -= 64) {
			seed = hash__wymum(((hash__wyr8(p) ^ seed) ^ _const_hash__wyp0), ((hash__wyr8(p + 8) ^ seed) ^ _const_hash__wyp1));
			see1 = hash__wymum(((hash__wyr8(p + 16) ^ see1) ^ _const_hash__wyp2), ((hash__wyr8(p + 24) ^ see1) ^ _const_hash__wyp3));
			see2 = hash__wymum(((hash__wyr8(p + 32) ^ see2) ^ _const_hash__wyp1), ((hash__wyr8(p + 40) ^ see2) ^ _const_hash__wyp2));
			see3 = hash__wymum(((hash__wyr8(p + 48) ^ see3) ^ _const_hash__wyp3), ((hash__wyr8(p + 56) ^ see3) ^ _const_hash__wyp0));
			p = p + 64;
		}
	}
	 u64 _t16 = hash__wymum(((seed ^ see1) ^ see2), ((see3 ^ len) ^ _const_hash__wyp4));
	// autofree_scope_vars(pos=2422 line_nr=79 scope.pos=1031 scope.end_pos=2475)
	// var "key" var.pos=1040 var.line_nr=36
	// var "len" var.pos=1053 var.line_nr=36
	// var "seed_" var.pos=1062 var.line_nr=36
	// var "p" var.pos=1113 var.line_nr=40
	// var "seed" var.pos=1127 var.line_nr=41
	// var "i" var.pos=1146 var.line_nr=42
	// var "see1" var.pos=2010 var.line_nr=66
	// var "see2" var.pos=2028 var.line_nr=67
	// var "see3" var.pos=2046 var.line_nr=68
	// af parent scope:
	// af parent scope:
	return _t16;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL u64 hash__wyrotr(u64 v, u32 k) {
	 u64 _t17 = ((v >> k) | (v << (64 - k)));
	// autofree_scope_vars(pos=2517 line_nr=84 scope.pos=2490 scope.end_pos=2548)
	// var "v" var.pos=2497 var.line_nr=83
	// var "k" var.pos=2504 var.line_nr=83
	// af parent scope:
	// af parent scope:
	return _t17;
}

// Attr: [inline]
inline u64 hash__wymum(u64 a, u64 b) {
	u32 mask32 = ((u32)(4294967295U));
	u64 x0 = (a & mask32);
	u64 x1 = a >> 32;
	u64 y0 = (b & mask32);
	u64 y1 = b >> 32;
	u64 w0 = x0 * y0;
	u64 t = x1 * y0 + (w0 >> 32);
	u64 w1 = (t & mask32);
	u64 w2 = t >> 32;
	w1 += x0 * y1;
	u64 hi = x1 * y1 + w2 + (w1 >> 32);
	u64 lo = a * b;
	 u64 _t18 = (hi ^ lo);
	// autofree_scope_vars(pos=2869 line_nr=106 scope.pos=2567 scope.end_pos=2885)
	// var "a" var.pos=2573 var.line_nr=88
	// var "b" var.pos=2580 var.line_nr=88
	// var "mask32" var.pos=2647 var.line_nr=94
	// var "x0" var.pos=2674 var.line_nr=95
	// var "x1" var.pos=2692 var.line_nr=96
	// var "y0" var.pos=2705 var.line_nr=97
	// var "y1" var.pos=2723 var.line_nr=98
	// var "w0" var.pos=2736 var.line_nr=99
	// var "t" var.pos=2751 var.line_nr=100
	// var "w1" var.pos=2780 var.line_nr=101
	// var "w2" var.pos=2798 var.line_nr=102
	// var "hi" var.pos=2826 var.line_nr=104
	// var "lo" var.pos=2857 var.line_nr=105
	// af parent scope:
	// af parent scope:
	return _t18;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL u64 hash__wyr3(byteptr p, u64 k) {
	{ // Unsafe block
		 u64 _t19 = (((((u64)(p[0])) << 16) | (((u64)(p[k >> 1])) << 8)) | ((u64)(p[k - 1])));
		// autofree_scope_vars(pos=2940 line_nr=112 scope.pos=2900 scope.end_pos=3003)
		// var "p" var.pos=2905 var.line_nr=110
		// var "k" var.pos=2916 var.line_nr=110
		// af parent scope:
		// af parent scope:
		return _t19;
	}
	return 0;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL u64 hash__wyr4(byteptr p) {
	{ // Unsafe block
		 u64 _t20 = (((((u32)(p[0])) | (((u32)(p[1])) << ((u32)(8U)))) | (((u32)(p[2])) << ((u32)(16U)))) | (((u32)(p[3])) << ((u32)(24U))));
		// autofree_scope_vars(pos=3051 line_nr=119 scope.pos=3018 scope.end_pos=3140)
		// var "p" var.pos=3023 var.line_nr=117
		// af parent scope:
		// af parent scope:
		return _t20;
	}
	return 0;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL u64 hash__wyr8(byteptr p) {
	{ // Unsafe block
		 u64 _t21 = (((((((((u64)(p[0])) | (((u64)(p[1])) << 8)) | (((u64)(p[2])) << 16)) | (((u64)(p[3])) << 24)) | (((u64)(p[4])) << 32)) | (((u64)(p[5])) << 40)) | (((u64)(p[6])) << 48)) | (((u64)(p[7])) << 56));
		// autofree_scope_vars(pos=3188 line_nr=126 scope.pos=3155 scope.end_pos=3334)
		// var "p" var.pos=3160 var.line_nr=124
		// af parent scope:
		// af parent scope:
		return _t21;
	}
	return 0;
}

int math__bits__leading_zeros_8(byte x) {
	 int _t22 = 8 - math__bits__len_8(x);
	// autofree_scope_vars(pos=1243 line_nr=35 scope.pos=1213 scope.end_pos=1264)
	// var "x" var.pos=1229 var.line_nr=34
	// af parent scope:
	// af parent scope:
	return _t22;
}

int math__bits__leading_zeros_16(u16 x) {
	 int _t23 = 16 - math__bits__len_16(x);
	// autofree_scope_vars(pos=1399 line_nr=40 scope.pos=1369 scope.end_pos=1422)
	// var "x" var.pos=1386 var.line_nr=39
	// af parent scope:
	// af parent scope:
	return _t23;
}

int math__bits__leading_zeros_32(u32 x) {
	 int _t24 = 32 - math__bits__len_32(x);
	// autofree_scope_vars(pos=1557 line_nr=45 scope.pos=1527 scope.end_pos=1580)
	// var "x" var.pos=1544 var.line_nr=44
	// af parent scope:
	// af parent scope:
	return _t24;
}

int math__bits__leading_zeros_64(u64 x) {
	 int _t25 = 64 - math__bits__len_64(x);
	// autofree_scope_vars(pos=1715 line_nr=50 scope.pos=1685 scope.end_pos=1738)
	// var "x" var.pos=1702 var.line_nr=49
	// af parent scope:
	// af parent scope:
	return _t25;
}

int math__bits__trailing_zeros_8(byte x) {
	 int _t26 = ((int)((*(byte*)/*ee elem_typ */array_get(_const_math__bits__ntz_8_tab, x))));
	// autofree_scope_vars(pos=1899 line_nr=56 scope.pos=1868 scope.end_pos=1925)
	// var "x" var.pos=1885 var.line_nr=55
	// af parent scope:
	// af parent scope:
	return _t26;
}

int math__bits__trailing_zeros_16(u16 x) {
	if (x == 0) {
		 int _t27 = 16;
		// autofree_scope_vars(pos=2077 line_nr=62 scope.pos=2074 scope.end_pos=2089)
		// af parent scope:
		// var "x" var.pos=2050 var.line_nr=60
		// af parent scope:
		// af parent scope:
		return _t27;
	}
	 int _t28 = ((int)((*(byte*)/*ee elem_typ */array_get(_const_math__bits__de_bruijn32tab, ((u32)((x & -x))) * _const_math__bits__de_bruijn32 >> (32 - 5)))));
	// autofree_scope_vars(pos=2128 line_nr=65 scope.pos=2032 scope.end_pos=2205)
	// var "x" var.pos=2050 var.line_nr=60
	// af parent scope:
	// af parent scope:
	return _t28;
}

int math__bits__trailing_zeros_32(u32 x) {
	if (x == 0) {
		 int _t29 = 32;
		// autofree_scope_vars(pos=2357 line_nr=71 scope.pos=2354 scope.end_pos=2369)
		// af parent scope:
		// var "x" var.pos=2330 var.line_nr=69
		// af parent scope:
		// af parent scope:
		return _t29;
	}
	 int _t30 = ((int)((*(byte*)/*ee elem_typ */array_get(_const_math__bits__de_bruijn32tab, ((x & -x)) * _const_math__bits__de_bruijn32 >> (32 - 5)))));
	// autofree_scope_vars(pos=2408 line_nr=74 scope.pos=2312 scope.end_pos=2482)
	// var "x" var.pos=2330 var.line_nr=69
	// af parent scope:
	// af parent scope:
	return _t30;
}

int math__bits__trailing_zeros_64(u64 x) {
	if (x == 0) {
		 int _t31 = 64;
		// autofree_scope_vars(pos=2634 line_nr=80 scope.pos=2631 scope.end_pos=2646)
		// af parent scope:
		// var "x" var.pos=2607 var.line_nr=78
		// af parent scope:
		// af parent scope:
		return _t31;
	}
	 int _t32 = ((int)((*(byte*)/*ee elem_typ */array_get(_const_math__bits__de_bruijn64tab, ((x & -x)) * _const_math__bits__de_bruijn64 >> (64 - 6)))));
	// autofree_scope_vars(pos=3314 line_nr=93 scope.pos=2589 scope.end_pos=3388)
	// var "x" var.pos=2607 var.line_nr=78
	// af parent scope:
	// af parent scope:
	return _t32;
}

int math__bits__ones_count_8(byte x) {
	 int _t33 = ((int)((*(byte*)/*ee elem_typ */array_get(_const_math__bits__pop_8_tab, x))));
	// autofree_scope_vars(pos=3520 line_nr=99 scope.pos=3493 scope.end_pos=3546)
	// var "x" var.pos=3506 var.line_nr=98
	// af parent scope:
	// af parent scope:
	return _t33;
}

int math__bits__ones_count_16(u16 x) {
	 int _t34 = ((int)((*(byte*)/*ee elem_typ */array_get(_const_math__bits__pop_8_tab, x >> 8)) + (*(byte*)/*ee elem_typ */array_get(_const_math__bits__pop_8_tab, (x & ((u16)(0xffU)))))));
	// autofree_scope_vars(pos=3658 line_nr=104 scope.pos=3631 scope.end_pos=3716)
	// var "x" var.pos=3645 var.line_nr=103
	// af parent scope:
	// af parent scope:
	return _t34;
}

int math__bits__ones_count_32(u32 x) {
	 int _t35 = ((int)((*(byte*)/*ee elem_typ */array_get(_const_math__bits__pop_8_tab, x >> 24)) + (*(byte*)/*ee elem_typ */array_get(_const_math__bits__pop_8_tab, (x >> 16 & 0xff))) + (*(byte*)/*ee elem_typ */array_get(_const_math__bits__pop_8_tab, (x >> 8 & 0xff))) + (*(byte*)/*ee elem_typ */array_get(_const_math__bits__pop_8_tab, (x & ((u32)(0xffU)))))));
	// autofree_scope_vars(pos=3828 line_nr=109 scope.pos=3801 scope.end_pos=3944)
	// var "x" var.pos=3815 var.line_nr=108
	// af parent scope:
	// af parent scope:
	return _t35;
}

int math__bits__ones_count_64(u64 x) {
	u64 y = ((x >> ((u64)(1U)) & ((_const_math__bits__m0 & _const_math__bits__max_u64)))) + ((x & ((_const_math__bits__m0 & _const_math__bits__max_u64))));
	y = ((y >> ((u64)(2U)) & ((_const_math__bits__m1 & _const_math__bits__max_u64)))) + ((y & ((_const_math__bits__m1 & _const_math__bits__max_u64))));
	y = (((y >> 4) + y) & ((_const_math__bits__m2 & _const_math__bits__max_u64)));
	y += y >> 8;
	y += y >> 16;
	y += y >> 32;
	 int _t36 = (((int)(y)) & ((1 << 7) - 1));
	// autofree_scope_vars(pos=5070 line_nr=140 scope.pos=4029 scope.end_pos=5102)
	// var "x" var.pos=4043 var.line_nr=114
	// var "y" var.pos=4824 var.line_nr=134
	// af parent scope:
	// af parent scope:
	return _t36;
}

// Attr: [inline]
inline byte math__bits__rotate_left_8(byte x, int k) {
	byte n = ((byte)(8));
	byte s = (((byte)(k)) & (n - ((byte)(1))));
	 byte _t37 = (((x << s) | (x >> (n - s))));
	// autofree_scope_vars(pos=5422 line_nr=152 scope.pos=5342 scope.end_pos=5458)
	// var "x" var.pos=5356 var.line_nr=149
	// var "k" var.pos=5364 var.line_nr=149
	// var "n" var.pos=5379 var.line_nr=150
	// var "s" var.pos=5393 var.line_nr=151
	// af parent scope:
	// af parent scope:
	return _t37;
}

// Attr: [inline]
inline u16 math__bits__rotate_left_16(u16 x, int k) {
	u16 n = ((u16)(16U));
	u16 s = (((u16)(k)) & (n - ((u16)(1U))));
	 u16 _t38 = (((x << s) | (x >> (n - s))));
	// autofree_scope_vars(pos=5756 line_nr=163 scope.pos=5679 scope.end_pos=5792)
	// var "x" var.pos=5694 var.line_nr=160
	// var "k" var.pos=5701 var.line_nr=160
	// var "n" var.pos=5715 var.line_nr=161
	// var "s" var.pos=5729 var.line_nr=162
	// af parent scope:
	// af parent scope:
	return _t38;
}

// Attr: [inline]
inline u32 math__bits__rotate_left_32(u32 x, int k) {
	u32 n = ((u32)(32U));
	u32 s = (((u32)(k)) & (n - ((u32)(1U))));
	 u32 _t39 = (((x << s) | (x >> (n - s))));
	// autofree_scope_vars(pos=6090 line_nr=174 scope.pos=6013 scope.end_pos=6126)
	// var "x" var.pos=6028 var.line_nr=171
	// var "k" var.pos=6035 var.line_nr=171
	// var "n" var.pos=6049 var.line_nr=172
	// var "s" var.pos=6063 var.line_nr=173
	// af parent scope:
	// af parent scope:
	return _t39;
}

// Attr: [inline]
inline u64 math__bits__rotate_left_64(u64 x, int k) {
	u64 n = ((u64)(64U));
	u64 s = (((u64)(k)) & (n - ((u64)(1U))));
	 u64 _t40 = (((x << s) | (x >> (n - s))));
	// autofree_scope_vars(pos=6424 line_nr=185 scope.pos=6347 scope.end_pos=6460)
	// var "x" var.pos=6362 var.line_nr=182
	// var "k" var.pos=6369 var.line_nr=182
	// var "n" var.pos=6383 var.line_nr=183
	// var "s" var.pos=6397 var.line_nr=184
	// af parent scope:
	// af parent scope:
	return _t40;
}

// Attr: [inline]
inline byte math__bits__reverse_8(byte x) {
	 byte _t41 = (*(byte*)/*ee elem_typ */array_get(_const_math__bits__rev_8_tab, x));
	// autofree_scope_vars(pos=6592 line_nr=192 scope.pos=6567 scope.end_pos=6613)
	// var "x" var.pos=6577 var.line_nr=191
	// af parent scope:
	// af parent scope:
	return _t41;
}

// Attr: [inline]
inline u16 math__bits__reverse_16(u16 x) {
	 u16 _t42 = (((u16)((*(byte*)/*ee elem_typ */array_get(_const_math__bits__rev_8_tab, x >> 8)))) | (((u16)((*(byte*)/*ee elem_typ */array_get(_const_math__bits__rev_8_tab, (x & ((u16)(0xffU))))))) << 8));
	// autofree_scope_vars(pos=6726 line_nr=198 scope.pos=6702 scope.end_pos=6796)
	// var "x" var.pos=6713 var.line_nr=197
	// af parent scope:
	// af parent scope:
	return _t42;
}

// Attr: [inline]
inline u32 math__bits__reverse_32(u32 x) {
	u64 y = ((((x >> ((u32)(1U)) & ((_const_math__bits__m0 & _const_math__bits__max_u32)))) | (((x & ((_const_math__bits__m0 & _const_math__bits__max_u32)))) << 1)));
	y = ((((y >> ((u32)(2U)) & ((_const_math__bits__m1 & _const_math__bits__max_u32)))) | (((y & ((_const_math__bits__m1 & _const_math__bits__max_u32)))) << ((u32)(2U)))));
	y = ((((y >> ((u32)(4U)) & ((_const_math__bits__m2 & _const_math__bits__max_u32)))) | (((y & ((_const_math__bits__m2 & _const_math__bits__max_u32)))) << ((u32)(4U)))));
	 u32 _t43 = math__bits__reverse_bytes_32(((u32)(y)));
	// autofree_scope_vars(pos=7188 line_nr=207 scope.pos=6885 scope.end_pos=7221)
	// var "x" var.pos=6896 var.line_nr=203
	// var "y" var.pos=6914 var.line_nr=204
	// af parent scope:
	// af parent scope:
	return _t43;
}

// Attr: [inline]
inline u64 math__bits__reverse_64(u64 x) {
	u64 y = ((((x >> ((u64)(1U)) & ((_const_math__bits__m0 & _const_math__bits__max_u64)))) | (((x & ((_const_math__bits__m0 & _const_math__bits__max_u64)))) << 1)));
	y = ((((y >> ((u64)(2U)) & ((_const_math__bits__m1 & _const_math__bits__max_u64)))) | (((y & ((_const_math__bits__m1 & _const_math__bits__max_u64)))) << 2)));
	y = ((((y >> ((u64)(4U)) & ((_const_math__bits__m2 & _const_math__bits__max_u64)))) | (((y & ((_const_math__bits__m2 & _const_math__bits__max_u64)))) << 4)));
	 u64 _t44 = math__bits__reverse_bytes_64(y);
	// autofree_scope_vars(pos=7603 line_nr=216 scope.pos=7310 scope.end_pos=7631)
	// var "x" var.pos=7321 var.line_nr=212
	// var "y" var.pos=7339 var.line_nr=213
	// af parent scope:
	// af parent scope:
	return _t44;
}

// Attr: [inline]
inline u16 math__bits__reverse_bytes_16(u16 x) {
	 u16 _t45 = ((x >> 8) | (x << 8));
	// autofree_scope_vars(pos=7849 line_nr=225 scope.pos=7819 scope.end_pos=7877)
	// var "x" var.pos=7836 var.line_nr=224
	// af parent scope:
	// af parent scope:
	return _t45;
}

// Attr: [inline]
inline u32 math__bits__reverse_bytes_32(u32 x) {
	u64 y = ((((x >> ((u32)(8U)) & ((_const_math__bits__m3 & _const_math__bits__max_u32)))) | (((x & ((_const_math__bits__m3 & _const_math__bits__max_u32)))) << ((u32)(8U)))));
	 u32 _t46 = ((u32)(((y >> 16) | (y << 16))));
	// autofree_scope_vars(pos=8165 line_nr=234 scope.pos=8041 scope.end_pos=8200)
	// var "x" var.pos=8058 var.line_nr=232
	// var "y" var.pos=8072 var.line_nr=233
	// af parent scope:
	// af parent scope:
	return _t46;
}

// Attr: [inline]
inline u64 math__bits__reverse_bytes_64(u64 x) {
	u64 y = ((((x >> ((u64)(8U)) & ((_const_math__bits__m3 & _const_math__bits__max_u64)))) | (((x & ((_const_math__bits__m3 & _const_math__bits__max_u64)))) << ((u64)(8U)))));
	y = ((((y >> ((u64)(16U)) & ((_const_math__bits__m4 & _const_math__bits__max_u64)))) | (((y & ((_const_math__bits__m4 & _const_math__bits__max_u64)))) << ((u64)(16U)))));
	 u64 _t47 = ((y >> 32) | (y << 32));
	// autofree_scope_vars(pos=8587 line_nr=244 scope.pos=8364 scope.end_pos=8617)
	// var "x" var.pos=8381 var.line_nr=241
	// var "y" var.pos=8399 var.line_nr=242
	// af parent scope:
	// af parent scope:
	return _t47;
}

int math__bits__len_8(byte x) {
	 int _t48 = ((int)((*(byte*)/*ee elem_typ */array_get(_const_math__bits__len_8_tab, x))));
	// autofree_scope_vars(pos=8759 line_nr=250 scope.pos=8739 scope.end_pos=8785)
	// var "x" var.pos=8745 var.line_nr=249
	// af parent scope:
	// af parent scope:
	return _t48;
}

int math__bits__len_16(u16 x) {
	u16 y = x;
	int n = 0;
	if (y >= 1 << 8) {
		y >>= 8;
		n = 8;
	}
	 int _t49 = n + ((int)((*(byte*)/*ee elem_typ */array_get(_const_math__bits__len_8_tab, y))));
	// autofree_scope_vars(pos=8976 line_nr=261 scope.pos=8893 scope.end_pos=9006)
	// var "x" var.pos=8900 var.line_nr=254
	// var "y" var.pos=8918 var.line_nr=255
	// var "n" var.pos=8930 var.line_nr=256
	// af parent scope:
	// af parent scope:
	return _t49;
}

int math__bits__len_32(u32 x) {
	u32 y = x;
	int n = 0;
	if (y >= (1 << 16)) {
		y >>= 16;
		n = 16;
	}
	if (y >= (1 << 8)) {
		y >>= 8;
		n += 8;
	}
	 int _t50 = n + ((int)((*(byte*)/*ee elem_typ */array_get(_const_math__bits__len_8_tab, y))));
	// autofree_scope_vars(pos=9244 line_nr=276 scope.pos=9114 scope.end_pos=9274)
	// var "x" var.pos=9121 var.line_nr=265
	// var "y" var.pos=9139 var.line_nr=266
	// var "n" var.pos=9151 var.line_nr=267
	// af parent scope:
	// af parent scope:
	return _t50;
}

int math__bits__len_64(u64 x) {
	u64 y = x;
	int n = 0;
	if (y >= ((u64)(1U)) << ((u64)(32U))) {
		y >>= 32;
		n = 32;
	}
	if (y >= ((u64)(1U)) << ((u64)(16U))) {
		y >>= 16;
		n += 16;
	}
	if (y >= ((u64)(1U)) << ((u64)(8U))) {
		y >>= 8;
		n += 8;
	}
	 int _t51 = n + ((int)((*(byte*)/*ee elem_typ */array_get(_const_math__bits__len_8_tab, y))));
	// autofree_scope_vars(pos=9581 line_nr=295 scope.pos=9382 scope.end_pos=9611)
	// var "x" var.pos=9389 var.line_nr=280
	// var "y" var.pos=9407 var.line_nr=281
	// var "n" var.pos=9419 var.line_nr=282
	// af parent scope:
	// af parent scope:
	return _t51;
}

multi_return_u32_u32 math__bits__add_32(u32 x, u32 y, u32 carry) {
	u64 sum64 = ((u64)(x)) + ((u64)(y)) + ((u64)(carry));
	u32 sum = ((u32)(sum64));
	u32 carry_out = ((u32)(sum64 >> 32));
	return (multi_return_u32_u32){.arg0=sum, .arg1=carry_out};
}

multi_return_u64_u64 math__bits__add_64(u64 x, u64 y, u64 carry) {
	u64 sum = x + y + carry;
	u64 carry_out = ((((x & y)) | ((((x | y)) & ~sum)))) >> 63;
	return (multi_return_u64_u64){.arg0=sum, .arg1=carry_out};
}

multi_return_u32_u32 math__bits__sub_32(u32 x, u32 y, u32 borrow) {
	u32 diff = x - y - borrow;
	u32 borrow_out = ((((~x & y)) | ((~((x ^ y)) & diff)))) >> 31;
	return (multi_return_u32_u32){.arg0=diff, .arg1=borrow_out};
}

multi_return_u64_u64 math__bits__sub_64(u64 x, u64 y, u64 borrow) {
	u64 diff = x - y - borrow;
	u64 borrow_out = ((((~x & y)) | ((~((x ^ y)) & diff)))) >> 63;
	return (multi_return_u64_u64){.arg0=diff, .arg1=borrow_out};
}

multi_return_u32_u32 math__bits__mul_32(u32 x, u32 y) {
	u64 tmp = ((u64)(x)) * ((u64)(y));
	u32 hi = ((u32)(tmp >> 32));
	u32 lo = ((u32)(tmp));
	return (multi_return_u32_u32){.arg0=hi, .arg1=lo};
}

multi_return_u64_u64 math__bits__mul_64(u64 x, u64 y) {
	u64 x0 = (x & _const_math__bits__mask32);
	u64 x1 = x >> 32;
	u64 y0 = (y & _const_math__bits__mask32);
	u64 y1 = y >> 32;
	u64 w0 = x0 * y0;
	u64 t = x1 * y0 + (w0 >> 32);
	u64 w1 = (t & _const_math__bits__mask32);
	u64 w2 = t >> 32;
	w1 += x0 * y1;
	u64 hi = x1 * y1 + w2 + (w1 >> 32);
	u64 lo = x * y;
	return (multi_return_u64_u64){.arg0=hi, .arg1=lo};
}

multi_return_u32_u32 math__bits__div_32(u32 hi, u32 lo, u32 y) {
	if (y != 0 && y <= hi) {
		v_panic(_const_math__bits__overflow_error);
	}
	u64 z = ((((u64)(hi)) << 32) | ((u64)(lo)));
	u32 quo = ((u32)(z / ((u64)(y))));
	u32 rem = ((u32)(z % ((u64)(y))));
	return (multi_return_u32_u32){.arg0=quo, .arg1=rem};
}

multi_return_u64_u64 math__bits__div_64(u64 hi, u64 lo, u64 y1) {
	u64 y = y1;
	if (y == 0) {
		v_panic(_const_math__bits__overflow_error);
	}
	if (y <= hi) {
		v_panic(_const_math__bits__overflow_error);
	}
	u32 s = ((u32)(math__bits__leading_zeros_64(y)));
	y <<= s;
	u64 yn1 = y >> 32;
	u64 yn0 = (y & _const_math__bits__mask32);
	u64 un32 = ((hi << s) | (lo >> (64 - s)));
	u64 un10 = lo << s;
	u64 un1 = un10 >> 32;
	u64 un0 = (un10 & _const_math__bits__mask32);
	u64 q1 = un32 / yn1;
	u64 rhat = un32 - q1 * yn1;
	for (;;) {
		if (!(q1 >= _const_math__bits__two32 || q1 * yn0 > _const_math__bits__two32 * rhat + un1)) break;
		q1--;
		rhat += yn1;
		if (rhat >= _const_math__bits__two32) {
			break;
		}
	}
	u64 un21 = un32 * _const_math__bits__two32 + un1 - q1 * y;
	u64 q0 = un21 / yn1;
	rhat = un21 - q0 * yn1;
	for (;;) {
		if (!(q0 >= _const_math__bits__two32 || q0 * yn0 > _const_math__bits__two32 * rhat + un0)) break;
		q0--;
		rhat += yn1;
		if (rhat >= _const_math__bits__two32) {
			break;
		}
	}
	return (multi_return_u64_u64){.arg0=q1 * _const_math__bits__two32 + q0, .arg1=(un21 * _const_math__bits__two32 + un0 - q0 * y) >> s};
}

u32 math__bits__rem_32(u32 hi, u32 lo, u32 y) {
	 u32 _t52 = ((u32)((((((u64)(hi)) << 32) | ((u64)(lo)))) % ((u64)(y))));
	// autofree_scope_vars(pos=15112 line_nr=462 scope.pos=15076 scope.end_pos=15162)
	// var "hi" var.pos=15083 var.line_nr=461
	// var "lo" var.pos=15091 var.line_nr=461
	// var "y" var.pos=15099 var.line_nr=461
	// af parent scope:
	// af parent scope:
	return _t52;
}

u64 math__bits__rem_64(u64 hi, u64 lo, u64 y) {
	multi_return_u64_u64 mr_15622 = math__bits__div_64(hi % y, lo, y);
	u64 rem = mr_15622.arg1;
	// autofree_scope_vars(pos=15647 line_nr=476 scope.pos=15340 scope.end_pos=15659)
	// var "hi" var.pos=15347 var.line_nr=468
	// var "lo" var.pos=15355 var.line_nr=468
	// var "y" var.pos=15363 var.line_nr=468
	// var "rem" var.pos=15618 var.line_nr=475
	// af parent scope:
	// af parent scope:
	return rem;
}

VV_LOCAL_SYMBOL multi_return_u32_u32_u32 strconv__lsr96(u32 s2, u32 s1, u32 s0) {
	u32 r0 = ((u32)(0U));
	u32 r1 = ((u32)(0U));
	u32 r2 = ((u32)(0U));
	r0 = ((s0 >> 1) | (((s1 & ((u32)(1U)))) << 31));
	r1 = ((s1 >> 1) | (((s2 & ((u32)(1U)))) << 31));
	r2 = s2 >> 1;
	return (multi_return_u32_u32_u32){.arg0=r2, .arg1=r1, .arg2=r0};
}

VV_LOCAL_SYMBOL multi_return_u32_u32_u32 strconv__lsl96(u32 s2, u32 s1, u32 s0) {
	u32 r0 = ((u32)(0U));
	u32 r1 = ((u32)(0U));
	u32 r2 = ((u32)(0U));
	r2 = ((s2 << 1) | (((s1 & (((u32)(1U)) << 31))) >> 31));
	r1 = ((s1 << 1) | (((s0 & (((u32)(1U)) << 31))) >> 31));
	r0 = s0 << 1;
	return (multi_return_u32_u32_u32){.arg0=r2, .arg1=r1, .arg2=r0};
}

VV_LOCAL_SYMBOL multi_return_u32_u32_u32 strconv__add96(u32 s2, u32 s1, u32 s0, u32 d2, u32 d1, u32 d0) {
	u64 w = ((u64)(0U));
	u32 r0 = ((u32)(0U));
	u32 r1 = ((u32)(0U));
	u32 r2 = ((u32)(0U));
	w = ((u64)(s0)) + ((u64)(d0));
	r0 = ((u32)(w));
	w >>= 32;
	w += ((u64)(s1)) + ((u64)(d1));
	r1 = ((u32)(w));
	w >>= 32;
	w += ((u64)(s2)) + ((u64)(d2));
	r2 = ((u32)(w));
	return (multi_return_u32_u32_u32){.arg0=r2, .arg1=r1, .arg2=r0};
}

VV_LOCAL_SYMBOL multi_return_u32_u32_u32 strconv__sub96(u32 s2, u32 s1, u32 s0, u32 d2, u32 d1, u32 d0) {
	u64 w = ((u64)(0U));
	u32 r0 = ((u32)(0U));
	u32 r1 = ((u32)(0U));
	u32 r2 = ((u32)(0U));
	w = ((u64)(s0)) - ((u64)(d0));
	r0 = ((u32)(w));
	w >>= 32;
	w += ((u64)(s1)) - ((u64)(d1));
	r1 = ((u32)(w));
	w >>= 32;
	w += ((u64)(s2)) - ((u64)(d2));
	r2 = ((u32)(w));
	return (multi_return_u32_u32_u32){.arg0=r2, .arg1=r1, .arg2=r0};
}

VV_LOCAL_SYMBOL bool strconv__is_digit(byte x) {
	return (x >= _const_strconv__c_zero && x <= _const_strconv__c_nine) == true;
}

VV_LOCAL_SYMBOL bool strconv__is_space(byte x) {
	return (x == L'\t' || x == L'\n' || x == L'\v' || x == L'\f' || x == L'\r' || x == L' ');
}

VV_LOCAL_SYMBOL bool strconv__is_exp(byte x) {
	return (x == L'E' || x == L'e') == true;
}

VV_LOCAL_SYMBOL multi_return_int_strconv__PrepNumber strconv__parser(string s) {
	int state = _const_strconv__fsm_a;
	int digx = 0;
	byte c = ((byte)(L' '));
	int result = _const_strconv__parser_ok;
	bool expneg = false;
	int expexp = 0;
	int i = 0;
	strconv__PrepNumber pn = (strconv__PrepNumber){.negative = 0,.exponent = 0,.mantissa = 0,};
	for (;;) {
		if (!(state != _const_strconv__fsm_stop)) break;

		if (state == (_const_strconv__fsm_a)) {
			if (strconv__is_space(c) == true) {
				c = string_at(s, i);
				i++;
			} else {
				state = _const_strconv__fsm_b;
			}
		}
		else if (state == (_const_strconv__fsm_b)) {
			state = _const_strconv__fsm_c;
			if (c == _const_strconv__c_plus) {
				c = string_at(s, i);
				i++;
			} else if (c == _const_strconv__c_minus) {
				pn.negative = true;
				c = string_at(s, i);
				i++;
			} else if (strconv__is_digit(c)) {
			} else if (c == _const_strconv__c_dpoint) {
			} else {
				state = _const_strconv__fsm_stop;
			}
		}
		else if (state == (_const_strconv__fsm_c)) {
			if (c == _const_strconv__c_zero) {
				c = string_at(s, i++);
			} else if (c == _const_strconv__c_dpoint) {
				c = string_at(s, i++);
				state = _const_strconv__fsm_d;
			} else {
				state = _const_strconv__fsm_e;
			}
		}
		else if (state == (_const_strconv__fsm_d)) {
			if (c == _const_strconv__c_zero) {
				c = string_at(s, i++);
				if (pn.exponent > -2147483647) {
					pn.exponent--;
				}
			} else {
				state = _const_strconv__fsm_f;
			}
		}
		else if (state == (_const_strconv__fsm_e)) {
			if (strconv__is_digit(c)) {
				if (digx < _const_strconv__digits) {
					pn.mantissa *= 10;
					pn.mantissa += ((u64)(c - _const_strconv__c_zero));
					digx++;
				} else if (pn.exponent < 2147483647) {
					pn.exponent++;
				}
				c = string_at(s, i++);
			} else if (c == _const_strconv__c_dpoint) {
				c = string_at(s, i++);
				state = _const_strconv__fsm_f;
			} else {
				state = _const_strconv__fsm_f;
			}
		}
		else if (state == (_const_strconv__fsm_f)) {
			if (strconv__is_digit(c)) {
				if (digx < _const_strconv__digits) {
					pn.mantissa *= 10;
					pn.mantissa += ((u64)(c - _const_strconv__c_zero));
					pn.exponent--;
					digx++;
				}
				c = string_at(s, i++);
			} else if (strconv__is_exp(c)) {
				c = string_at(s, i++);
				state = _const_strconv__fsm_g;
			} else {
				state = _const_strconv__fsm_g;
			}
		}
		else if (state == (_const_strconv__fsm_g)) {
			if (c == _const_strconv__c_plus) {
				c = string_at(s, i++);
			} else if (c == _const_strconv__c_minus) {
				expneg = true;
				c = string_at(s, i++);
			}
			state = _const_strconv__fsm_h;
		}
		else if (state == (_const_strconv__fsm_h)) {
			if (c == _const_strconv__c_zero) {
				c = string_at(s, i++);
			} else {
				state = _const_strconv__fsm_i;
			}
		}
		else if (state == (_const_strconv__fsm_i)) {
			if (strconv__is_digit(c)) {
				if (expexp < 214748364) {
					expexp *= 10;
					expexp += ((int)(c - _const_strconv__c_zero));
				}
				c = string_at(s, i++);
			} else {
				state = _const_strconv__fsm_stop;
			}
		}
		else {
		};
		if (i >= s.len) {
			state = _const_strconv__fsm_stop;
		}
	}
	if (expneg) {
		expexp = -expexp;
	}
	pn.exponent += expexp;
	if (pn.mantissa == 0) {
		if (pn.negative) {
			result = _const_strconv__parser_mzero;
		} else {
			result = _const_strconv__parser_pzero;
		}
	} else if (pn.exponent > 309) {
		if (pn.negative) {
			result = _const_strconv__parser_minf;
		} else {
			result = _const_strconv__parser_pinf;
		}
	} else if (pn.exponent < -328) {
		if (pn.negative) {
			result = _const_strconv__parser_mzero;
		} else {
			result = _const_strconv__parser_pzero;
		}
	}
	return (multi_return_int_strconv__PrepNumber){.arg0=result, .arg1=pn};
}

VV_LOCAL_SYMBOL u64 strconv__converter(strconv__PrepNumber* pn) {
	int binexp = 92;
	u32 s2 = ((u32)(0U));
	u32 s1 = ((u32)(0U));
	u32 s0 = ((u32)(0U));
	u32 q2 = ((u32)(0U));
	u32 q1 = ((u32)(0U));
	u32 q0 = ((u32)(0U));
	u32 r2 = ((u32)(0U));
	u32 r1 = ((u32)(0U));
	u32 r0 = ((u32)(0U));
	u32 mask28 = ((u32)(((u64)(0xFU)) << 28));
	u64 result = ((u64)(0U));
	s0 = ((u32)((pn->mantissa & ((u64)(0x00000000FFFFFFFFU)))));
	s1 = ((u32)(pn->mantissa >> 32));
	s2 = ((u32)(0U));
	for (;;) {
		if (!(pn->exponent > 0)) break;
		multi_return_u32_u32_u32 mr_6687 = strconv__lsl96(s2, s1, s0);
		q2 = mr_6687.arg0;
		q1 = mr_6687.arg1;
		q0 = mr_6687.arg2;
		multi_return_u32_u32_u32 mr_6731 = strconv__lsl96(q2, q1, q0);
		r2 = mr_6731.arg0;
		r1 = mr_6731.arg1;
		r0 = mr_6731.arg2;
		multi_return_u32_u32_u32 mr_6785 = strconv__lsl96(r2, r1, r0);
		s2 = mr_6785.arg0;
		s1 = mr_6785.arg1;
		s0 = mr_6785.arg2;
		multi_return_u32_u32_u32 mr_6839 = strconv__add96(s2, s1, s0, q2, q1, q0);
		s2 = mr_6839.arg0;
		s1 = mr_6839.arg1;
		s0 = mr_6839.arg2;
		pn->exponent--;
		for (;;) {
			if (!(((s2 & mask28)) != 0)) break;
			multi_return_u32_u32_u32 mr_6960 = strconv__lsr96(s2, s1, s0);
			q2 = mr_6960.arg0;
			q1 = mr_6960.arg1;
			q0 = mr_6960.arg2;
			binexp++;
			s2 = q2;
			s1 = q1;
			s0 = q0;
		}
	}
	for (;;) {
		if (!(pn->exponent < 0)) break;
		for (;;) {
			if (!(!(((s2 & (((u32)(1U)) << 31))) != 0))) break;
			multi_return_u32_u32_u32 mr_7103 = strconv__lsl96(s2, s1, s0);
			q2 = mr_7103.arg0;
			q1 = mr_7103.arg1;
			q0 = mr_7103.arg2;
			binexp--;
			s2 = q2;
			s1 = q1;
			s0 = q0;
		}
		q2 = s2 / _const_strconv__c_ten;
		r1 = s2 % _const_strconv__c_ten;
		r2 = ((s1 >> 8) | (r1 << 24));
		q1 = r2 / _const_strconv__c_ten;
		r1 = r2 % _const_strconv__c_ten;
		r2 = (((((s1 & ((u32)(0xFFU)))) << 16) | (s0 >> 16)) | (r1 << 24));
		r0 = r2 / _const_strconv__c_ten;
		r1 = r2 % _const_strconv__c_ten;
		q1 = ((q1 << 8) | (((r0 & ((u32)(0x00FF0000U)))) >> 16));
		q0 = r0 << 16;
		r2 = (((s0 & ((u32)(0xFFFFU)))) | (r1 << 16));
		q0 |= r2 / _const_strconv__c_ten;
		s2 = q2;
		s1 = q1;
		s0 = q0;
		pn->exponent++;
	}
	if (s2 != 0 || s1 != 0 || s0 != 0) {
		for (;;) {
			if (!(((s2 & mask28)) == 0)) break;
			multi_return_u32_u32_u32 mr_7762 = strconv__lsl96(s2, s1, s0);
			q2 = mr_7762.arg0;
			q1 = mr_7762.arg1;
			q0 = mr_7762.arg2;
			binexp--;
			s2 = q2;
			s1 = q1;
			s0 = q0;
		}
	}
	int nbit = 7;
	u32 check_round_bit = ((u32)(1U)) << ((u32)(nbit));
	u32 check_round_mask = ((u32)(0xFFFFFFFFU)) << ((u32)(nbit));
	if (((s1 & check_round_bit)) != 0) {
		if (((s1 & ~check_round_mask)) != 0) {
			multi_return_u32_u32_u32 mr_8835 = strconv__add96(s2, s1, s0, 0, check_round_bit, 0);
			s2 = mr_8835.arg0;
			s1 = mr_8835.arg1;
			s0 = mr_8835.arg2;
		} else {
			if (((s1 & (check_round_bit << ((u32)(1U))))) != 0) {
				multi_return_u32_u32_u32 mr_9025 = strconv__add96(s2, s1, s0, 0, check_round_bit, 0);
				s2 = mr_9025.arg0;
				s1 = mr_9025.arg1;
				s0 = mr_9025.arg2;
			}
		}
		s1 = (s1 & check_round_mask);
		s0 = ((u32)(0U));
		if ((s2 & (mask28 << ((u32)(1U)))) != 0) {
			multi_return_u32_u32_u32 mr_9225 = strconv__lsr96(s2, s1, s0);
			q2 = mr_9225.arg0;
			q1 = mr_9225.arg1;
			q0 = mr_9225.arg2;
			binexp--;
			s2 = q2;
			s1 = q1;
			s0 = q0;
		}
	}
	binexp += 1023;
	if (binexp > 2046) {
		if (pn->negative) {
			result = _const_strconv__double_minus_infinity;
		} else {
			result = _const_strconv__double_plus_infinity;
		}
	} else if (binexp < 1) {
		if (pn->negative) {
			result = _const_strconv__double_minus_zero;
		} else {
			result = _const_strconv__double_plus_zero;
		}
	} else if (s2 != 0) {
		u64 q = ((u64)(0U));
		u64 binexs2 = ((u64)(binexp)) << 52;
		q = (((((u64)((s2 & ~mask28))) << 24) | ((((u64)(s1)) + ((u64)(128U))) >> 8)) | binexs2);
		if (pn->negative) {
			q |= (((u64)(1U)) << 63);
		}
		result = q;
	}
	return result;
}

f64 strconv__atof64(string s) {
	strconv__PrepNumber pn = (strconv__PrepNumber){.negative = 0,.exponent = 0,.mantissa = 0,};
	int res_parsing = 0;
	strconv__Float64u res = (strconv__Float64u){0};
	multi_return_int_strconv__PrepNumber mr_10230 = strconv__parser(string_add(s, _SLIT(" ")));
	res_parsing = mr_10230.arg0;
	pn = mr_10230.arg1;

	if (res_parsing == (_const_strconv__parser_ok)) {
		res.u = strconv__converter((voidptr)&/*qq*/pn);
	}
	else if (res_parsing == (_const_strconv__parser_pzero)) {
		res.u = _const_strconv__double_plus_zero;
	}
	else if (res_parsing == (_const_strconv__parser_mzero)) {
		res.u = _const_strconv__double_minus_zero;
	}
	else if (res_parsing == (_const_strconv__parser_pinf)) {
		res.u = _const_strconv__double_plus_infinity;
	}
	else if (res_parsing == (_const_strconv__parser_minf)) {
		res.u = _const_strconv__double_minus_infinity;
	}
	else {
	};
	return res.f;
}

f64 strconv__atof_quick(string s) {
	strconv__Float64u f = (strconv__Float64u){0};
	f64 sign = ((f64)(1.0));
	int i = 0;
	for (;;) {
		if (!(i < s.len && string_at(s, i) == L' ')) break;
		i++;
	}
	if (i < s.len) {
		if (string_at(s, i) == L'-') {
			sign = -1.0;
			i++;
		} else if (string_at(s, i) == L'+') {
			i++;
		}
	}
	if (string_at(s, i) == L'i' && i + 2 < s.len && string_at(s, i + 1) == L'n' && string_at(s, i + 2) == L'f') {
		if (sign > 0.0) {
			f.u = _const_strconv__double_plus_infinity;
		} else {
			f.u = _const_strconv__double_minus_infinity;
		}
		return f.f;
	}
	for (;;) {
		if (!(i < s.len && string_at(s, i) == L'0')) break;
		i++;
		if (i >= s.len) {
			if (sign > 0.0) {
				f.u = _const_strconv__double_plus_zero;
			} else {
				f.u = _const_strconv__double_minus_zero;
			}
			return f.f;
		}
	}
	for (;;) {
		if (!(i < s.len && (string_at(s, i) >= L'0' && string_at(s, i) <= L'9'))) break;
		f.f *= ((f64)(10.0));
		f.f += ((f64)(string_at(s, i) - L'0'));
		i++;
	}
	if (i < s.len && string_at(s, i) == L'.') {
		i++;
		f64 frac_mul = ((f64)(0.1));
		for (;;) {
			if (!(i < s.len && (string_at(s, i) >= L'0' && string_at(s, i) <= L'9'))) break;
			f.f += ((f64)(string_at(s, i) - L'0')) * frac_mul;
			frac_mul *= ((f64)(0.1));
			i++;
		}
	}
	if (i < s.len && (string_at(s, i) == L'e' || string_at(s, i) == L'E')) {
		i++;
		int exp = 0;
		int exp_sign = 1;
		if (i < s.len) {
			if (string_at(s, i) == L'-') {
				exp_sign = -1;
				i++;
			} else if (string_at(s, i) == L'+') {
				i++;
			}
		}
		for (;;) {
			if (!(i < s.len && string_at(s, i) == L'0')) break;
			i++;
		}
		for (;;) {
			if (!(i < s.len && (string_at(s, i) >= L'0' && string_at(s, i) <= L'9'))) break;
			exp *= 10;
			exp += ((int)(string_at(s, i) - L'0'));
			i++;
		}
		if (exp_sign == 1) {
			if (exp > _const_strconv__pos_exp.len) {
				if (sign > 0) {
					f.u = _const_strconv__double_plus_infinity;
				} else {
					f.u = _const_strconv__double_minus_infinity;
				}
				return f.f;
			}
			strconv__Float64u tmp_mul = (strconv__Float64u){.u = (*(u64*)/*ee elem_typ */array_get(_const_strconv__pos_exp, exp)),};
			f.f = f.f * tmp_mul.f;
		} else {
			if (exp > _const_strconv__neg_exp.len) {
				if (sign > 0) {
					f.u = _const_strconv__double_plus_zero;
				} else {
					f.u = _const_strconv__double_minus_zero;
				}
				return f.f;
			}
			strconv__Float64u tmp_mul = (strconv__Float64u){.u = (*(u64*)/*ee elem_typ */array_get(_const_strconv__neg_exp, exp)),};
			f.f = f.f * tmp_mul.f;
		}
	}
	{ // Unsafe block
		f.f = f.f * sign;
		return f.f;
	}
	return 0;
}

byte strconv__byte_to_lower(byte c) {
	return (c | (L'x' - L'X'));
}

u64 strconv__common_parse_uint(string s, int _base, int _bit_size, bool error_on_non_digit, bool error_on_high_digit) {
	multi_return_u64_int mr_829 = strconv__common_parse_uint2(s, _base, _bit_size);
	u64 result = mr_829.arg0;
	int v_error = mr_829.arg1;
	if (v_error != 0) {
		if (v_error > 0 && (error_on_non_digit || error_on_high_digit)) {
			return ((u64)(0U));
		}
	}
	return result;
}

multi_return_u64_int strconv__common_parse_uint2(string s, int _base, int _bit_size) {
	int bit_size = _bit_size;
	int base = _base;
	if (s.len < 1 || !strconv__underscore_ok(s)) {
		return (multi_return_u64_int){.arg0=((u64)(0U)), .arg1=1};
	}
	bool base0 = base == 0;
	int start_index = 0;
	if (2 <= base && base <= 36) {
	} else if (base == 0) {
		base = 10;
		if (string_at(s, 0) == L'0') {
			if (s.len >= 3 && strconv__byte_to_lower(string_at(s, 1)) == L'b') {
				base = 2;
				start_index += 2;
			} else if (s.len >= 3 && strconv__byte_to_lower(string_at(s, 1)) == L'o') {
				base = 8;
				start_index += 2;
			} else if (s.len >= 3 && strconv__byte_to_lower(string_at(s, 1)) == L'x') {
				base = 16;
				start_index += 2;
			} else if (s.len >= 2 && (string_at(s, 1) >= L'0' && string_at(s, 1) <= L'9')) {
				base = 10;
				start_index++;
			} else {
				base = 8;
				start_index++;
			}
		}
	} else {
		return (multi_return_u64_int){.arg0=((u64)(0U)), .arg1=-1};
	}
	if (bit_size == 0) {
		bit_size = _const_strconv__int_size;
	} else if (bit_size < 0 || bit_size > 64) {
		return (multi_return_u64_int){.arg0=((u64)(0U)), .arg1=-2};
	}
	u64 cutoff = _const_strconv__max_u64 / ((u64)(base)) + ((u64)(1U));
	u64 max_val = (bit_size == 64 ? (_const_strconv__max_u64) : ((((u64)(1U)) << ((u64)(bit_size))) - ((u64)(1U))));
	u64 n = ((u64)(0U));
	for (int i = start_index; i < s.len; ++i) {
		byte c = string_at(s, i);
		byte cl = strconv__byte_to_lower(c);
		byte d = ((byte)(0));
		if (c == L'_' && base0) {
			continue;
		} else if (L'0' <= c && c <= L'9') {
			d = c - L'0';
		} else if (L'a' <= cl && cl <= L'z') {
			d = cl - L'a' + 10;
		} else {
			return (multi_return_u64_int){.arg0=n, .arg1=i + 1};
		}
		if (d >= ((byte)(base))) {
			return (multi_return_u64_int){.arg0=n, .arg1=i + 1};
		}
		if (n >= cutoff) {
			return (multi_return_u64_int){.arg0=max_val, .arg1=-3};
		}
		n *= ((u64)(base));
		u64 n1 = n + ((u64)(d));
		if (n1 < n || n1 > max_val) {
			return (multi_return_u64_int){.arg0=max_val, .arg1=-3};
		}
		n = n1;
	}
	return (multi_return_u64_int){.arg0=n, .arg1=0};
}

u64 strconv__parse_uint(string s, int _base, int _bit_size) {
	return strconv__common_parse_uint(s, _base, _bit_size, true, true);
}

i64 strconv__common_parse_int(string _s, int base, int _bit_size, bool error_on_non_digit, bool error_on_high_digit) {
	string s = _s;
	int bit_size = _bit_size;
	if (s.len < 1) {
		return ((i64)(0));
	}
	bool neg = false;
	if (string_at(s, 0) == L'+') {
		s = string_substr(s, 1, s.len);
	} else if (string_at(s, 0) == L'-') {
		neg = true;
		s = string_substr(s, 1, s.len);
	}
	u64 un = strconv__common_parse_uint(s, base, bit_size, error_on_non_digit, error_on_high_digit);
	if (un == 0) {
		return ((i64)(0));
	}
	if (bit_size == 0) {
		bit_size = _const_strconv__int_size;
	}
	u64 cutoff = ((u64)(1U)) << ((u64)(bit_size - 1));
	if (!neg && un >= cutoff) {
		return ((i64)(cutoff - ((u64)(1U))));
	}
	if (neg && un > cutoff) {
		return -((i64)(cutoff));
	}
	return (neg ? (-((i64)(un))) : (((i64)(un))));
}

i64 strconv__parse_int(string _s, int base, int _bit_size) {
	return strconv__common_parse_int(_s, base, _bit_size, true, true);
}

Option_int strconv__atoi(string s) {
	if ((s).len == 0) {
		return (Option_int){ .state=2, .err=v_error(_STR("strconv.atoi: parsing \"%.*s\000\": invalid syntax ", 2, s)) };
	}
	if ((_const_strconv__int_size == 32 && (0 < s.len && s.len < 10)) || (_const_strconv__int_size == 64 && (0 < s.len && s.len < 19))) {
		int start_idx = 0;
		if (string_at(s, 0) == L'-' || string_at(s, 0) == L'+') {
			start_idx++;
			if (s.len - start_idx < 1) {
				return (Option_int){ .state=2, .err=v_error(_STR("strconv.atoi: parsing \"%.*s\000\": invalid syntax ", 2, s)) };
			}
		}
		int n = 0;
		for (int i = start_idx; i < s.len; ++i) {
			rune ch = string_at(s, i) - L'0';
			if (ch > 9) {
				return (Option_int){ .state=2, .err=v_error(_STR("strconv.atoi: parsing \"%.*s\000\": invalid syntax ", 2, s)) };
			}
			n = n * 10 + ((int)(ch));
		}
		Option_int _t53; /* if prepend */
		if (string_at(s, 0) == L'-') {
			opt_ok(&(int[]) { -n }, (Option*)(&_t53), sizeof(int));
		} else {
			opt_ok(&(int[]) { n }, (Option*)(&_t53), sizeof(int));
		}
		return  _t53;
	}
	i64 int64 = strconv__parse_int(s, 10, 0);
	Option_int _t54;
	opt_ok(&(int[]) { ((int)(int64)) }, (Option*)(&_t54), sizeof(int));
	return _t54;
}

VV_LOCAL_SYMBOL bool strconv__underscore_ok(string s) {
	rune saw = L'^';
	int i = 0;
	if (s.len >= 1 && (string_at(s, 0) == L'-' || string_at(s, 0) == L'+')) {
		i++;
	}
	bool hex = false;
	if (s.len - i >= 2 && string_at(s, i) == L'0' && (strconv__byte_to_lower(string_at(s, i + 1)) == L'b' || strconv__byte_to_lower(string_at(s, i + 1)) == L'o' || strconv__byte_to_lower(string_at(s, i + 1)) == L'x')) {
		saw = L'0';
		hex = strconv__byte_to_lower(string_at(s, i + 1)) == L'x';
		i += 2;
	}
	for (; i < s.len; i++) {
		if ((L'0' <= string_at(s, i) && string_at(s, i) <= L'9') || (hex && L'a' <= strconv__byte_to_lower(string_at(s, i)) && strconv__byte_to_lower(string_at(s, i)) <= L'f')) {
			saw = L'0';
			continue;
		}
		if (string_at(s, i) == L'_') {
			if (saw != L'0') {
				return false;
			}
			saw = L'_';
			continue;
		}
		if (saw == L'_') {
			return false;
		}
		saw = L'!';
	}
	return saw != L'_';
}

string strconv__Dec32_get_string_32(strconv__Dec32 d, bool neg, int i_n_digit, int i_pad_digit) {
	int n_digit = i_n_digit + 1;
	int pad_digit = i_pad_digit + 1;
	u32 out = d.m;
	int out_len = strconv__decimal_len_32(out);
	int out_len_original = out_len;
	int fw_zeros = 0;
	if (pad_digit > out_len) {
		fw_zeros = pad_digit - out_len;
	}
	Array_byte buf = __new_array_with_default(((int)(out_len + 5 + 1 + 1)), 0, sizeof(byte), 0);
	int i = 0;
	if (neg) {
		array_set(&buf, i, &(byte[]) { L'-' });
		i++;
	}
	int disp = 0;
	if (out_len <= 1) {
		disp = 1;
	}
	if (n_digit < out_len) {
		out += (*(u32*)/*ee elem_typ */array_get(_const_strconv__ten_pow_table_32, out_len - n_digit - 1)) * 5;
		out /= (*(u32*)/*ee elem_typ */array_get(_const_strconv__ten_pow_table_32, out_len - n_digit));
		out_len = n_digit;
	}
	int y = i + out_len;
	int x = 0;
	for (;;) {
		if (!(x < (out_len - disp - 1))) break;
		array_set(&buf, y - x, &(byte[]) { L'0' + ((byte)(out % 10)) });
		out /= 10;
		i++;
		x++;
	}
	if (out_len >= 1) {
		array_set(&buf, y - x, &(byte[]) { L'.' });
		x++;
		i++;
	}
	if (y - x >= 0) {
		array_set(&buf, y - x, &(byte[]) { L'0' + ((byte)(out % 10)) });
		i++;
	}
	for (;;) {
		if (!(fw_zeros > 0)) break;
		array_set(&buf, i++, &(byte[]) { L'0' });
		fw_zeros--;
	}
	array_set(&buf, i, &(byte[]) { L'e' });
	i++;
	int exp = d.e + out_len_original - 1;
	if (exp < 0) {
		array_set(&buf, i, &(byte[]) { L'-' });
		i++;
		exp = -exp;
	} else {
		array_set(&buf, i, &(byte[]) { L'+' });
		i++;
	}
	int d1 = exp % 10;
	int d0 = exp / 10;
	array_set(&buf, i, &(byte[]) { L'0' + ((byte)(d0)) });
	i++;
	array_set(&buf, i, &(byte[]) { L'0' + ((byte)(d1)) });
	i++;
	array_set(&buf, i, &(byte[]) { 0 });
	return tos(((byteptr)(&(*(byte*)/*ee elem_typ */array_get(buf, 0)))), i);
}

VV_LOCAL_SYMBOL multi_return_strconv__Dec32_bool strconv__f32_to_decimal_exact_int(u32 i_mant, u32 exp) {
	strconv__Dec32 d = (strconv__Dec32){.m = 0,.e = 0,};
	u32 e = exp - _const_strconv__bias32;
	if (e > _const_strconv__mantbits32) {
		return (multi_return_strconv__Dec32_bool){.arg0=d, .arg1=false};
	}
	u32 shift = _const_strconv__mantbits32 - e;
	u32 mant = (i_mant | 0x00800000);
	d.m = mant >> shift;
	if ((d.m << shift) != mant) {
		return (multi_return_strconv__Dec32_bool){.arg0=d, .arg1=false};
	}
	for (;;) {
		if (!((d.m % 10) == 0)) break;
		d.m /= 10;
		d.e++;
	}
	return (multi_return_strconv__Dec32_bool){.arg0=d, .arg1=true};
}

strconv__Dec32 strconv__f32_to_decimal(u32 mant, u32 exp) {
	int e2 = 0;
	u32 m2 = ((u32)(0U));
	if (exp == 0) {
		e2 = 1 - _const_strconv__bias32 - ((int)(_const_strconv__mantbits32)) - 2;
		m2 = mant;
	} else {
		e2 = ((int)(exp)) - _const_strconv__bias32 - ((int)(_const_strconv__mantbits32)) - 2;
		m2 = ((((u32)(1U)) << _const_strconv__mantbits32) | mant);
	}
	bool even = ((m2 & 1)) == 0;
	bool accept_bounds = even;
	u32 mv = ((u32)(4 * m2));
	u32 mp = ((u32)(4 * m2 + 2));
	u32 mm_shift = strconv__bool_to_u32(mant != 0 || exp <= 1);
	u32 mm = ((u32)(4 * m2 - 1 - mm_shift));
	u32 vr = ((u32)(0U));
	u32 vp = ((u32)(0U));
	u32 vm = ((u32)(0U));
	int e10 = 0;
	bool vm_is_trailing_zeros = false;
	bool vr_is_trailing_zeros = false;
	byte last_removed_digit = ((byte)(0));
	if (e2 >= 0) {
		u32 q = strconv__log10_pow2(e2);
		e10 = ((int)(q));
		int k = _const_strconv__pow5_inv_num_bits_32 + strconv__pow5_bits(((int)(q))) - 1;
		int i = -e2 + ((int)(q)) + k;
		vr = strconv__mul_pow5_invdiv_pow2(mv, q, i);
		vp = strconv__mul_pow5_invdiv_pow2(mp, q, i);
		vm = strconv__mul_pow5_invdiv_pow2(mm, q, i);
		if (q != 0 && (vp - 1) / 10 <= vm / 10) {
			int l = _const_strconv__pow5_inv_num_bits_32 + strconv__pow5_bits(((int)(q - 1))) - 1;
			last_removed_digit = ((byte)(strconv__mul_pow5_invdiv_pow2(mv, q - 1, -e2 + ((int)(q - 1)) + l) % 10));
		}
		if (q <= 9) {
			if (mv % 5 == 0) {
				vr_is_trailing_zeros = strconv__multiple_of_power_of_five_32(mv, q);
			} else if (accept_bounds) {
				vm_is_trailing_zeros = strconv__multiple_of_power_of_five_32(mm, q);
			} else if (strconv__multiple_of_power_of_five_32(mp, q)) {
				vp--;
			}
		}
	} else {
		u32 q = strconv__log10_pow5(-e2);
		e10 = ((int)(q)) + e2;
		int i = -e2 - ((int)(q));
		int k = strconv__pow5_bits(i) - _const_strconv__pow5_num_bits_32;
		int j = ((int)(q)) - k;
		vr = strconv__mul_pow5_div_pow2(mv, ((u32)(i)), j);
		vp = strconv__mul_pow5_div_pow2(mp, ((u32)(i)), j);
		vm = strconv__mul_pow5_div_pow2(mm, ((u32)(i)), j);
		if (q != 0 && ((vp - 1) / 10) <= vm / 10) {
			j = ((int)(q)) - 1 - (strconv__pow5_bits(i + 1) - _const_strconv__pow5_num_bits_32);
			last_removed_digit = ((byte)(strconv__mul_pow5_div_pow2(mv, ((u32)(i + 1)), j) % 10));
		}
		if (q <= 1) {
			vr_is_trailing_zeros = true;
			if (accept_bounds) {
				vm_is_trailing_zeros = mm_shift == 1;
			} else {
				vp--;
			}
		} else if (q < 31) {
			vr_is_trailing_zeros = strconv__multiple_of_power_of_two_32(mv, q - 1);
		}
	}
	int removed = 0;
	u32 out = ((u32)(0U));
	if (vm_is_trailing_zeros || vr_is_trailing_zeros) {
		for (;;) {
			if (!(vp / 10 > vm / 10)) break;
			vm_is_trailing_zeros = vm_is_trailing_zeros && (vm % 10) == 0;
			vr_is_trailing_zeros = vr_is_trailing_zeros && (last_removed_digit == 0);
			last_removed_digit = ((byte)(vr % 10));
			vr /= 10;
			vp /= 10;
			vm /= 10;
			removed++;
		}
		if (vm_is_trailing_zeros) {
			for (;;) {
				if (!(vm % 10 == 0)) break;
				vr_is_trailing_zeros = vr_is_trailing_zeros && (last_removed_digit == 0);
				last_removed_digit = ((byte)(vr % 10));
				vr /= 10;
				vp /= 10;
				vm /= 10;
				removed++;
			}
		}
		if (vr_is_trailing_zeros && (last_removed_digit == 5) && (vr % 2) == 0) {
			last_removed_digit = 4;
		}
		out = vr;
		if ((vr == vm && (!accept_bounds || !vm_is_trailing_zeros)) || last_removed_digit >= 5) {
			out++;
		}
	} else {
		for (;;) {
			if (!(vp / 10 > vm / 10)) break;
			last_removed_digit = ((byte)(vr % 10));
			vr /= 10;
			vp /= 10;
			vm /= 10;
			removed++;
		}
		out = vr + strconv__bool_to_u32(vr == vm || last_removed_digit >= 5);
	}
	return (strconv__Dec32){.m = out,.e = e10 + removed,};
}

string strconv__f32_to_str(f32 f, int n_digit) {
	strconv__Uf32 u1 = (strconv__Uf32){0};
	u1.f = f;
	u32 u = u1.u;
	bool neg = (u >> (_const_strconv__mantbits32 + _const_strconv__expbits32)) != 0;
	u32 mant = (u & ((((u32)(1U)) << _const_strconv__mantbits32) - ((u32)(1U))));
	u32 exp = ((u >> _const_strconv__mantbits32) & ((((u32)(1U)) << _const_strconv__expbits32) - ((u32)(1U))));
	if ((exp == _const_strconv__maxexp32) || (exp == 0 && mant == 0)) {
		return strconv__get_string_special(neg, exp == 0, mant == 0);
	}
	multi_return_strconv__Dec32_bool mr_7987 = strconv__f32_to_decimal_exact_int(mant, exp);
	strconv__Dec32 d = mr_7987.arg0;
	bool ok = mr_7987.arg1;
	if (!ok) {
		d = strconv__f32_to_decimal(mant, exp);
	}
	return strconv__Dec32_get_string_32(d, neg, n_digit, 0);
}

string strconv__f32_to_str_pad(f32 f, int n_digit) {
	strconv__Uf32 u1 = (strconv__Uf32){0};
	u1.f = f;
	u32 u = u1.u;
	bool neg = (u >> (_const_strconv__mantbits32 + _const_strconv__expbits32)) != 0;
	u32 mant = (u & ((((u32)(1U)) << _const_strconv__mantbits32) - ((u32)(1U))));
	u32 exp = ((u >> _const_strconv__mantbits32) & ((((u32)(1U)) << _const_strconv__expbits32) - ((u32)(1U))));
	if ((exp == _const_strconv__maxexp32) || (exp == 0 && mant == 0)) {
		return strconv__get_string_special(neg, exp == 0, mant == 0);
	}
	multi_return_strconv__Dec32_bool mr_8704 = strconv__f32_to_decimal_exact_int(mant, exp);
	strconv__Dec32 d = mr_8704.arg0;
	bool ok = mr_8704.arg1;
	if (!ok) {
		d = strconv__f32_to_decimal(mant, exp);
	}
	return strconv__Dec32_get_string_32(d, neg, n_digit, n_digit);
}

VV_LOCAL_SYMBOL string strconv__Dec64_get_string_64(strconv__Dec64 d, bool neg, int i_n_digit, int i_pad_digit) {
	int n_digit = i_n_digit + 1;
	int pad_digit = i_pad_digit + 1;
	u64 out = d.m;
	int d_exp = d.e;
	int out_len = strconv__decimal_len_64(out);
	int out_len_original = out_len;
	int fw_zeros = 0;
	if (pad_digit > out_len) {
		fw_zeros = pad_digit - out_len;
	}
	Array_byte buf = __new_array_with_default((out_len + 6 + 1 + 1 + fw_zeros), 0, sizeof(byte), 0);
	int i = 0;
	if (neg) {
		array_set(&buf, i, &(byte[]) { L'-' });
		i++;
	}
	int disp = 0;
	if (out_len <= 1) {
		disp = 1;
	}
	if (n_digit < out_len) {
		out += (*(u64*)/*ee elem_typ */array_get(_const_strconv__ten_pow_table_64, out_len - n_digit - 1)) * 5;
		out /= (*(u64*)/*ee elem_typ */array_get(_const_strconv__ten_pow_table_64, out_len - n_digit));
		if (d.m / (*(u64*)/*ee elem_typ */array_get(_const_strconv__ten_pow_table_64, out_len - n_digit)) < out) {
			d_exp++;
			n_digit++;
		}
		out_len = n_digit;
	}
	int y = i + out_len;
	int x = 0;
	for (;;) {
		if (!(x < (out_len - disp - 1))) break;
		array_set(&buf, y - x, &(byte[]) { L'0' + ((byte)(out % 10)) });
		out /= 10;
		i++;
		x++;
	}
	if (out_len >= 1) {
		array_set(&buf, y - x, &(byte[]) { L'.' });
		x++;
		i++;
	}
	if (y - x >= 0) {
		array_set(&buf, y - x, &(byte[]) { L'0' + ((byte)(out % 10)) });
		i++;
	}
	for (;;) {
		if (!(fw_zeros > 0)) break;
		array_set(&buf, i++, &(byte[]) { L'0' });
		fw_zeros--;
	}
	array_set(&buf, i, &(byte[]) { L'e' });
	i++;
	int exp = d_exp + out_len_original - 1;
	if (exp < 0) {
		array_set(&buf, i, &(byte[]) { L'-' });
		i++;
		exp = -exp;
	} else {
		array_set(&buf, i, &(byte[]) { L'+' });
		i++;
	}
	int d2 = exp % 10;
	exp /= 10;
	int d1 = exp % 10;
	int d0 = exp / 10;
	if (d0 > 0) {
		array_set(&buf, i, &(byte[]) { L'0' + ((byte)(d0)) });
		i++;
	}
	array_set(&buf, i, &(byte[]) { L'0' + ((byte)(d1)) });
	i++;
	array_set(&buf, i, &(byte[]) { L'0' + ((byte)(d2)) });
	i++;
	array_set(&buf, i, &(byte[]) { 0 });
	return tos(((byteptr)(&(*(byte*)/*ee elem_typ */array_get(buf, 0)))), i);
}

VV_LOCAL_SYMBOL multi_return_strconv__Dec64_bool strconv__f64_to_decimal_exact_int(u64 i_mant, u64 exp) {
	strconv__Dec64 d = (strconv__Dec64){.m = 0,.e = 0,};
	u64 e = exp - _const_strconv__bias64;
	if (e > _const_strconv__mantbits64) {
		return (multi_return_strconv__Dec64_bool){.arg0=d, .arg1=false};
	}
	u64 shift = _const_strconv__mantbits64 - e;
	u64 mant = (i_mant | ((u64)(0x0010000000000000U)));
	d.m = mant >> shift;
	if ((d.m << shift) != mant) {
		return (multi_return_strconv__Dec64_bool){.arg0=d, .arg1=false};
	}
	for (;;) {
		if (!((d.m % 10) == 0)) break;
		d.m /= 10;
		d.e++;
	}
	return (multi_return_strconv__Dec64_bool){.arg0=d, .arg1=true};
}

VV_LOCAL_SYMBOL strconv__Dec64 strconv__f64_to_decimal(u64 mant, u64 exp) {
	int e2 = 0;
	u64 m2 = ((u64)(0U));
	if (exp == 0) {
		e2 = 1 - _const_strconv__bias64 - ((int)(_const_strconv__mantbits64)) - 2;
		m2 = mant;
	} else {
		e2 = ((int)(exp)) - _const_strconv__bias64 - ((int)(_const_strconv__mantbits64)) - 2;
		m2 = ((((u64)(1U)) << _const_strconv__mantbits64) | mant);
	}
	bool even = ((m2 & 1)) == 0;
	bool accept_bounds = even;
	u64 mv = ((u64)(4 * m2));
	u64 mm_shift = strconv__bool_to_u64(mant != 0 || exp <= 1);
	u64 vr = ((u64)(0U));
	u64 vp = ((u64)(0U));
	u64 vm = ((u64)(0U));
	int e10 = 0;
	bool vm_is_trailing_zeros = false;
	bool vr_is_trailing_zeros = false;
	if (e2 >= 0) {
		u32 q = strconv__log10_pow2(e2) - strconv__bool_to_u32(e2 > 3);
		e10 = ((int)(q));
		int k = _const_strconv__pow5_inv_num_bits_64 + strconv__pow5_bits(((int)(q))) - 1;
		int i = -e2 + ((int)(q)) + k;
		strconv__Uint128 mul = (*(strconv__Uint128*)/*ee elem_typ */array_get(_const_strconv__pow5_inv_split_64, q));
		vr = strconv__mul_shift_64(((u64)(4U)) * m2, mul, i);
		vp = strconv__mul_shift_64(((u64)(4U)) * m2 + ((u64)(2U)), mul, i);
		vm = strconv__mul_shift_64(((u64)(4U)) * m2 - ((u64)(1U)) - mm_shift, mul, i);
		if (q <= 21) {
			if (mv % 5 == 0) {
				vr_is_trailing_zeros = strconv__multiple_of_power_of_five_64(mv, q);
			} else if (accept_bounds) {
				vm_is_trailing_zeros = strconv__multiple_of_power_of_five_64(mv - 1 - mm_shift, q);
			} else if (strconv__multiple_of_power_of_five_64(mv + 2, q)) {
				vp--;
			}
		}
	} else {
		u32 q = strconv__log10_pow5(-e2) - strconv__bool_to_u32(-e2 > 1);
		e10 = ((int)(q)) + e2;
		int i = -e2 - ((int)(q));
		int k = strconv__pow5_bits(i) - _const_strconv__pow5_num_bits_64;
		int j = ((int)(q)) - k;
		strconv__Uint128 mul = (*(strconv__Uint128*)/*ee elem_typ */array_get(_const_strconv__pow5_split_64, i));
		vr = strconv__mul_shift_64(((u64)(4U)) * m2, mul, j);
		vp = strconv__mul_shift_64(((u64)(4U)) * m2 + ((u64)(2U)), mul, j);
		vm = strconv__mul_shift_64(((u64)(4U)) * m2 - ((u64)(1U)) - mm_shift, mul, j);
		if (q <= 1) {
			vr_is_trailing_zeros = true;
			if (accept_bounds) {
				vm_is_trailing_zeros = (mm_shift == 1);
			} else {
				vp--;
			}
		} else if (q < 63) {
			vr_is_trailing_zeros = strconv__multiple_of_power_of_two_64(mv, q - 1);
		}
	}
	int removed = 0;
	byte last_removed_digit = ((byte)(0));
	u64 out = ((u64)(0U));
	if (vm_is_trailing_zeros || vr_is_trailing_zeros) {
		for (;;) {
			u64 vp_div_10 = vp / 10;
			u64 vm_div_10 = vm / 10;
			if (vp_div_10 <= vm_div_10) {
				break;
			}
			u64 vm_mod_10 = vm % 10;
			u64 vr_div_10 = vr / 10;
			u64 vr_mod_10 = vr % 10;
			vm_is_trailing_zeros = vm_is_trailing_zeros && vm_mod_10 == 0;
			vr_is_trailing_zeros = vr_is_trailing_zeros && (last_removed_digit == 0);
			last_removed_digit = ((byte)(vr_mod_10));
			vr = vr_div_10;
			vp = vp_div_10;
			vm = vm_div_10;
			removed++;
		}
		if (vm_is_trailing_zeros) {
			for (;;) {
				u64 vm_div_10 = vm / 10;
				u64 vm_mod_10 = vm % 10;
				if (vm_mod_10 != 0) {
					break;
				}
				u64 vp_div_10 = vp / 10;
				u64 vr_div_10 = vr / 10;
				u64 vr_mod_10 = vr % 10;
				vr_is_trailing_zeros = vr_is_trailing_zeros && (last_removed_digit == 0);
				last_removed_digit = ((byte)(vr_mod_10));
				vr = vr_div_10;
				vp = vp_div_10;
				vm = vm_div_10;
				removed++;
			}
		}
		if (vr_is_trailing_zeros && (last_removed_digit == 5) && (vr % 2) == 0) {
			last_removed_digit = 4;
		}
		out = vr;
		if ((vr == vm && (!accept_bounds || !vm_is_trailing_zeros)) || last_removed_digit >= 5) {
			out++;
		}
	} else {
		bool round_up = false;
		for (;;) {
			if (!(vp / 100 > vm / 100)) break;
			round_up = (vr % 100) >= 50;
			vr /= 100;
			vp /= 100;
			vm /= 100;
			removed += 2;
		}
		for (;;) {
			if (!(vp / 10 > vm / 10)) break;
			round_up = (vr % 10) >= 5;
			vr /= 10;
			vp /= 10;
			vm /= 10;
			removed++;
		}
		out = vr + strconv__bool_to_u64(vr == vm || round_up);
	}
	return (strconv__Dec64){.m = out,.e = e10 + removed,};
}

string strconv__f64_to_str(f64 f, int n_digit) {
	strconv__Uf64 u1 = (strconv__Uf64){0};
	u1.f = f;
	u64 u = u1.u;
	bool neg = (u >> (_const_strconv__mantbits64 + _const_strconv__expbits64)) != 0;
	u64 mant = (u & ((((u64)(1U)) << _const_strconv__mantbits64) - ((u64)(1U))));
	u64 exp = ((u >> _const_strconv__mantbits64) & ((((u64)(1U)) << _const_strconv__expbits64) - ((u64)(1U))));
	if ((exp == _const_strconv__maxexp64) || (exp == 0 && mant == 0)) {
		return strconv__get_string_special(neg, exp == 0, mant == 0);
	}
	multi_return_strconv__Dec64_bool mr_9695 = strconv__f64_to_decimal_exact_int(mant, exp);
	strconv__Dec64 d = mr_9695.arg0;
	bool ok = mr_9695.arg1;
	if (!ok) {
		d = strconv__f64_to_decimal(mant, exp);
	}
	return strconv__Dec64_get_string_64(d, neg, n_digit, 0);
}

string strconv__f64_to_str_pad(f64 f, int n_digit) {
	strconv__Uf64 u1 = (strconv__Uf64){0};
	u1.f = f;
	u64 u = u1.u;
	bool neg = (u >> (_const_strconv__mantbits64 + _const_strconv__expbits64)) != 0;
	u64 mant = (u & ((((u64)(1U)) << _const_strconv__mantbits64) - ((u64)(1U))));
	u64 exp = ((u >> _const_strconv__mantbits64) & ((((u64)(1U)) << _const_strconv__expbits64) - ((u64)(1U))));
	if ((exp == _const_strconv__maxexp64) || (exp == 0 && mant == 0)) {
		return strconv__get_string_special(neg, exp == 0, mant == 0);
	}
	multi_return_strconv__Dec64_bool mr_10440 = strconv__f64_to_decimal_exact_int(mant, exp);
	strconv__Dec64 d = mr_10440.arg0;
	bool ok = mr_10440.arg1;
	if (!ok) {
		d = strconv__f64_to_decimal(mant, exp);
	}
	return strconv__Dec64_get_string_64(d, neg, n_digit, n_digit);
}

string strconv__f64_to_str_lnd(f64 f, int dec_digit) {
	string s = strconv__f64_to_str(f + (*(f64*)/*ee elem_typ */array_get(_const_strconv__dec_round, dec_digit)), 18);
	if (s.len > 2 && (string_at(s, 0) == L'n' || string_at(s, 1) == L'i')) {
		return s;
	}
	bool m_sgn_flag = false;
	int sgn = 1;
	Array_fixed_byte_26 b = {0};
	int d_pos = 1;
	int i = 0;
	int i1 = 0;
	int exp = 0;
	int exp_sgn = 1;
	int dot_res_sp = -1;
	for (int _t55 = 0; _t55 < s.len; ++_t55) {
		byte c = s.str[_t55];
		if (c == L'-') {
			sgn = -1;
			i++;
		} else if (c == L'+') {
			sgn = 1;
			i++;
		} else if (c >= L'0' && c <= L'9') {
			b[v_fixed_index(i1++, 26)] = c;
			i++;
		} else if (c == L'.') {
			if (sgn > 0) {
				d_pos = i;
			} else {
				d_pos = i - 1;
			}
			i++;
		} else if (c == L'e') {
			i++;
			break;
		} else {
			return _SLIT("[Float conversion error!!]");
		}
	}
	b[v_fixed_index(i1, 26)] = 0;
	if (string_at(s, i) == L'-') {
		exp_sgn = -1;
		i++;
	} else if (string_at(s, i) == L'+') {
		exp_sgn = 1;
		i++;
	}
	for (int _t56 = 0; _t56 < string_substr(s, i, s.len).len; ++_t56) {
		byte c = string_substr(s, i, s.len).str[_t56];
		exp = exp * 10 + ((int)(c - L'0'));
	}
	Array_byte res = __new_array_with_default(exp + 32, 0, sizeof(byte), &(byte[]){0});
	int r_i = 0;
	if (sgn == 1) {
		if (m_sgn_flag) {
			array_set(&res, r_i++, &(byte[]) { L'+' });
		}
	} else {
		array_set(&res, r_i++, &(byte[]) { L'-' });
	}
	i = 0;
	if (exp_sgn >= 0) {
		for (;;) {
			if (!(b[v_fixed_index(i, 26)] != 0)) break;
			array_set(&res, r_i++, &(byte[]) { b[v_fixed_index(i, 26)] });
			i++;
			if (i >= d_pos && exp >= 0) {
				if (exp == 0) {
					dot_res_sp = r_i;
					array_set(&res, r_i++, &(byte[]) { L'.' });
				}
				exp--;
			}
		}
		for (;;) {
			if (!(exp >= 0)) break;
			array_set(&res, r_i++, &(byte[]) { L'0' });
			exp--;
		}
	} else {
		bool dot_p = true;
		for (;;) {
			if (!(exp > 0)) break;
			array_set(&res, r_i++, &(byte[]) { L'0' });
			exp--;
			if (dot_p) {
				dot_res_sp = r_i;
				array_set(&res, r_i++, &(byte[]) { L'.' });
				dot_p = false;
			}
		}
		for (;;) {
			if (!(b[v_fixed_index(i, 26)] != 0)) break;
			array_set(&res, r_i++, &(byte[]) { b[v_fixed_index(i, 26)] });
			i++;
		}
	}
	if (dot_res_sp >= 0) {
		if ((r_i - dot_res_sp) > dec_digit) {
			r_i = dot_res_sp + dec_digit + 1;
		}
		array_set(&res, r_i, &(byte[]) { 0 });
		return tos(res.data, r_i);
	} else {
		if (dec_digit > 0) {
			int c = 0;
			array_set(&res, r_i++, &(byte[]) { L'.' });
			for (;;) {
				if (!(c < dec_digit)) break;
				array_set(&res, r_i++, &(byte[]) { L'0' });
				c++;
			}
			array_set(&res, r_i, &(byte[]) { 0 });
		}
		return tos(res.data, r_i);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

string strconv__format_str(string s, strconv__BF_param p) {
	int dif = p.len0 - s.len;
	if (dif <= 0) {
		return s;
	}
	strings__Builder res = strings__new_builder(s.len + dif);
	if (p.allign == strconv__Align_text_right) {
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_b(&res, p.pad_ch);
		}
	}
	strings__Builder_write_string(&res, s);
	if (p.allign == strconv__Align_text_left) {
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_b(&res, p.pad_ch);
		}
	}
	return strings__Builder_str(&res);
}

string strconv__format_dec(u64 d, strconv__BF_param p) {
	string s = _SLIT("");
	strings__Builder res = strings__new_builder(20);
	int sign_len_diff = 0;
	if (p.pad_ch == L'0') {
		if (p.positive) {
			if (p.sign_flag) {
				strings__Builder_write_b(&res, L'+');
				sign_len_diff = -1;
			}
		} else {
			strings__Builder_write_b(&res, L'-');
			sign_len_diff = -1;
		}
		s = u64_str(d);
	} else {
		if (p.positive) {
			if (p.sign_flag) {
				s = string_add(_SLIT("+"), u64_str(d));
			} else {
				s = u64_str(d);
			}
		} else {
			s = string_add(_SLIT("-"), u64_str(d));
		}
	}
	int dif = p.len0 - s.len + sign_len_diff;
	if (p.allign == strconv__Align_text_right) {
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_b(&res, p.pad_ch);
		}
	}
	strings__Builder_write_string(&res, s);
	if (p.allign == strconv__Align_text_left) {
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_b(&res, p.pad_ch);
		}
	}
	return strings__Builder_str(&res);
}

string strconv__format_fl(f64 f, strconv__BF_param p) {
	string s = _SLIT("");
	string fs = strconv__f64_to_str_lnd((f >= 0.0 ? (f) : (-f)), p.len1);
	if (string_at(fs, 0) == L'[') {
		return fs;
	}
	if (p.rm_tail_zero) {
		fs = strconv__remove_tail_zeros(fs);
	}
	strings__Builder res = strings__new_builder((p.len0 > fs.len ? (p.len0) : (fs.len)));
	int sign_len_diff = 0;
	if (p.pad_ch == L'0') {
		if (p.positive) {
			if (p.sign_flag) {
				strings__Builder_write_b(&res, L'+');
				sign_len_diff = -1;
			}
		} else {
			strings__Builder_write_b(&res, L'-');
			sign_len_diff = -1;
		}
		s = fs;
	} else {
		if (p.positive) {
			if (p.sign_flag) {
				s = string_add(_SLIT("+"), fs);
			} else {
				s = fs;
			}
		} else {
			s = string_add(_SLIT("-"), fs);
		}
	}
	int dif = p.len0 - s.len + sign_len_diff;
	if (p.allign == strconv__Align_text_right) {
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_b(&res, p.pad_ch);
		}
	}
	strings__Builder_write_string(&res, s);
	if (p.allign == strconv__Align_text_left) {
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_b(&res, p.pad_ch);
		}
	}
	return strings__Builder_str(&res);
}

string strconv__format_es(f64 f, strconv__BF_param p) {
	string s = _SLIT("");
	string fs = strconv__f64_to_str_pad((f > 0 ? (f) : (-f)), p.len1);
	if (p.rm_tail_zero) {
		fs = strconv__remove_tail_zeros(fs);
	}
	strings__Builder res = strings__new_builder((p.len0 > fs.len ? (p.len0) : (fs.len)));
	int sign_len_diff = 0;
	if (p.pad_ch == L'0') {
		if (p.positive) {
			if (p.sign_flag) {
				strings__Builder_write_b(&res, L'+');
				sign_len_diff = -1;
			}
		} else {
			strings__Builder_write_b(&res, L'-');
			sign_len_diff = -1;
		}
		s = fs;
	} else {
		if (p.positive) {
			if (p.sign_flag) {
				s = string_add(_SLIT("+"), fs);
			} else {
				s = fs;
			}
		} else {
			s = string_add(_SLIT("-"), fs);
		}
	}
	int dif = p.len0 - s.len + sign_len_diff;
	if (p.allign == strconv__Align_text_right) {
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_b(&res, p.pad_ch);
		}
	}
	strings__Builder_write_string(&res, s);
	if (p.allign == strconv__Align_text_left) {
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_b(&res, p.pad_ch);
		}
	}
	return strings__Builder_str(&res);
}

string strconv__remove_tail_zeros(string s) {
	int i = 0;
	int last_zero_start = -1;
	int dot_pos = -1;
	bool in_decimal = false;
	byte prev_ch = ((byte)(0));
	for (;;) {
		if (!(i < s.len)) break;
		byte ch = s.str[i];
		if (ch == L'.') {
			in_decimal = true;
			dot_pos = i;
		} else if (in_decimal) {
			if (ch == L'0' && prev_ch != L'0') {
				last_zero_start = i;
			} else if (ch >= L'1' && ch <= L'9') {
				last_zero_start = -1;
			} else if (ch == L'e') {
				break;
			}
		}
		prev_ch = ch;
		i++;
	}
	string tmp = _SLIT("");
	if (last_zero_start > 0) {
		if (last_zero_start == dot_pos + 1) {
			tmp = string_add(string_substr(s, 0, dot_pos), string_substr(s, i, s.len));
		} else {
			tmp = string_add(string_substr(s, 0, last_zero_start), string_substr(s, i, s.len));
		}
	} else {
		tmp = s;
	}
	if (tmp.str[tmp.len - 1] == L'.') {
		return string_substr(tmp, 0, tmp.len - 1);
	}
	return tmp;
}

void strconv__v_printf(string str, Array_voidptr pt) {
	print(strconv__v_sprintf(str, new_array_from_c_array(1, 1, sizeof(voidptr), _MOV((voidptr[1]){(voidptr)&/*qq*/pt}))));
}

string strconv__v_sprintf(string str, Array_voidptr pt) {
	strings__Builder res = strings__new_builder(pt.len * 16);
	int i = 0;
	int p_index = 0;
	bool sign = false;
	strconv__Align_text allign = strconv__Align_text_right;
	int len0 = -1;
	int len1 = -1;
	int def_len1 = 6;
	byte pad_ch = ((byte)(L' '));
	rune ch1 = L'0';
	rune ch2 = L'0';
	strconv__Char_parse_state status = strconv__Char_parse_state_norm_char;
	for (;;) {
		if (!(i < str.len)) break;
		if (status == strconv__Char_parse_state_reset_params) {
			sign = false;
			allign = strconv__Align_text_right;
			len0 = -1;
			len1 = -1;
			pad_ch = L' ';
			status = strconv__Char_parse_state_norm_char;
			ch1 = L'0';
			ch2 = L'0';
			continue;
		}
		byte ch = string_at(str, i);
		if (ch != L'%' && status == strconv__Char_parse_state_norm_char) {
			strings__Builder_write_b(&res, ch);
			i++;
			continue;
		}
		if (ch == L'%' && status == strconv__Char_parse_state_norm_char) {
			status = strconv__Char_parse_state_field_char;
			i++;
			continue;
		}
		if (ch == L'c' && status == strconv__Char_parse_state_field_char) {
			strconv__v_sprintf_panic(p_index, pt.len);
			byte d1 = *(((byte*)((*(voidptr*)/*ee elem_typ */array_get(pt, p_index)))));
			strings__Builder_write_b(&res, d1);
			status = strconv__Char_parse_state_reset_params;
			p_index++;
			i++;
			continue;
		}
		if (ch == L'p' && status == strconv__Char_parse_state_field_char) {
			strconv__v_sprintf_panic(p_index, pt.len);
			strings__Builder_write_string(&res, _SLIT("0x"));
			strings__Builder_write_string(&res, ptr_str((*(voidptr*)/*ee elem_typ */array_get(pt, p_index))));
			status = strconv__Char_parse_state_reset_params;
			p_index++;
			i++;
			continue;
		}
		if (status == strconv__Char_parse_state_field_char) {
			rune fc_ch1 = L'0';
			rune fc_ch2 = L'0';
			if ((i + 1) < str.len) {
				fc_ch1 = string_at(str, i + 1);
				if ((i + 2) < str.len) {
					fc_ch2 = string_at(str, i + 2);
				}
			}
			if (ch == L'+') {
				sign = true;
				i++;
				continue;
			} else if (ch == L'-') {
				allign = strconv__Align_text_left;
				i++;
				continue;
			} else if ((ch == L'0' || ch == L' ')) {
				if (allign == strconv__Align_text_right) {
					pad_ch = ch;
				}
				i++;
				continue;
			} else if (ch == L'\'') {
				i++;
				continue;
			} else if (ch == L'.' && fc_ch1 >= L'1' && fc_ch1 <= L'9') {
				status = strconv__Char_parse_state_check_float;
				i++;
				continue;
			} else if (ch == L'.' && fc_ch1 == L'*' && fc_ch2 == L's') {
				strconv__v_sprintf_panic(p_index, pt.len);
				int len = *(((int*)((*(voidptr*)/*ee elem_typ */array_get(pt, p_index)))));
				p_index++;
				strconv__v_sprintf_panic(p_index, pt.len);
				string s = *(((string*)((*(voidptr*)/*ee elem_typ */array_get(pt, p_index)))));
				s = string_substr(s, 0, len);
				p_index++;
				strings__Builder_write_string(&res, s);
				status = strconv__Char_parse_state_reset_params;
				i += 3;
				continue;
			}
			status = strconv__Char_parse_state_len_set_start;
			continue;
		}
		if (status == strconv__Char_parse_state_len_set_start) {
			if (ch >= L'1' && ch <= L'9') {
				len0 = ((int)(ch - L'0'));
				status = strconv__Char_parse_state_len_set_in;
				i++;
				continue;
			}
			if (ch == L'.') {
				status = strconv__Char_parse_state_check_float;
				i++;
				continue;
			}
			status = strconv__Char_parse_state_check_type;
			continue;
		}
		if (status == strconv__Char_parse_state_len_set_in) {
			if (ch >= L'0' && ch <= L'9') {
				len0 *= 10;
				len0 += ((int)(ch - L'0'));
				i++;
				continue;
			}
			if (ch == L'.') {
				status = strconv__Char_parse_state_check_float;
				i++;
				continue;
			}
			status = strconv__Char_parse_state_check_type;
			continue;
		}
		if (status == strconv__Char_parse_state_check_float) {
			if (ch >= L'0' && ch <= L'9') {
				len1 = ((int)(ch - L'0'));
				status = strconv__Char_parse_state_check_float_in;
				i++;
				continue;
			}
			status = strconv__Char_parse_state_check_type;
			continue;
		}
		if (status == strconv__Char_parse_state_check_float_in) {
			if (ch >= L'0' && ch <= L'9') {
				len1 *= 10;
				len1 += ((int)(ch - L'0'));
				i++;
				continue;
			}
			status = strconv__Char_parse_state_check_type;
			continue;
		}
		if (status == strconv__Char_parse_state_check_type) {
			if (ch == L'l') {
				if (ch1 == L'0') {
					ch1 = L'l';
					i++;
					continue;
				} else {
					ch2 = L'l';
					i++;
					continue;
				}
			} else if (ch == L'h') {
				if (ch1 == L'0') {
					ch1 = L'h';
					i++;
					continue;
				} else {
					ch2 = L'h';
					i++;
					continue;
				}
			} else if ((ch == L'd' || ch == L'i')) {
				u64 d1 = ((u64)(0U));
				bool positive = true;

				if (ch1 == (L'h')) {
					if (ch2 == L'h') {
						strconv__v_sprintf_panic(p_index, pt.len);
						i8 x = *(((i8*)((*(voidptr*)/*ee elem_typ */array_get(pt, p_index)))));
						positive = (x >= 0 ? (true) : (false));
						d1 = (positive ? (((u64)(x))) : (((u64)(-x))));
					} else {
						i16 x = *(((i16*)((*(voidptr*)/*ee elem_typ */array_get(pt, p_index)))));
						positive = (x >= 0 ? (true) : (false));
						d1 = (positive ? (((u64)(x))) : (((u64)(-x))));
					}
				}
				else if (ch1 == (L'l')) {
					strconv__v_sprintf_panic(p_index, pt.len);
					i64 x = *(((i64*)((*(voidptr*)/*ee elem_typ */array_get(pt, p_index)))));
					positive = (x >= 0 ? (true) : (false));
					d1 = (positive ? (((u64)(x))) : (((u64)(-x))));
				}
				else {
					strconv__v_sprintf_panic(p_index, pt.len);
					int x = *(((int*)((*(voidptr*)/*ee elem_typ */array_get(pt, p_index)))));
					positive = (x >= 0 ? (true) : (false));
					d1 = (positive ? (((u64)(x))) : (((u64)(-x))));
				};
				strings__Builder_write_string(&res, strconv__format_dec(d1, (strconv__BF_param){
					.pad_ch = pad_ch,
					.len0 = len0,
					.len1 = 0,
					.positive = positive,
					.sign_flag = sign,
					.allign = allign,
					.rm_tail_zero = 0,
				}));
				status = strconv__Char_parse_state_reset_params;
				p_index++;
				i++;
				ch1 = L'0';
				ch2 = L'0';
				continue;
			} else if (ch == L'u') {
				u64 d1 = ((u64)(0U));
				bool positive = true;
				strconv__v_sprintf_panic(p_index, pt.len);

				if (ch1 == (L'h')) {
					if (ch2 == L'h') {
						d1 = ((u64)(*(((byte*)((*(voidptr*)/*ee elem_typ */array_get(pt, p_index)))))));
					} else {
						d1 = ((u64)(*(((u16*)((*(voidptr*)/*ee elem_typ */array_get(pt, p_index)))))));
					}
				}
				else if (ch1 == (L'l')) {
					d1 = ((u64)(*(((u64*)((*(voidptr*)/*ee elem_typ */array_get(pt, p_index)))))));
				}
				else {
					d1 = ((u64)(*(((u32*)((*(voidptr*)/*ee elem_typ */array_get(pt, p_index)))))));
				};
				strings__Builder_write_string(&res, strconv__format_dec(d1, (strconv__BF_param){
					.pad_ch = pad_ch,
					.len0 = len0,
					.len1 = 0,
					.positive = positive,
					.sign_flag = sign,
					.allign = allign,
					.rm_tail_zero = 0,
				}));
				status = strconv__Char_parse_state_reset_params;
				p_index++;
				i++;
				continue;
			} else if ((ch == L'x' || ch == L'X')) {
				strconv__v_sprintf_panic(p_index, pt.len);
				string s = _SLIT("");

				if (ch1 == (L'h')) {
					if (ch2 == L'h') {
						i8 x = *(((i8*)((*(voidptr*)/*ee elem_typ */array_get(pt, p_index)))));
						s = i8_hex(x);
					} else {
						i16 x = *(((i16*)((*(voidptr*)/*ee elem_typ */array_get(pt, p_index)))));
						s = i16_hex(x);
					}
				}
				else if (ch1 == (L'l')) {
					i64 x = *(((i64*)((*(voidptr*)/*ee elem_typ */array_get(pt, p_index)))));
					s = i64_hex(x);
				}
				else {
					int x = *(((int*)((*(voidptr*)/*ee elem_typ */array_get(pt, p_index)))));
					s = int_hex(x);
				};
				if (ch == L'X') {
					s = string_to_upper(s);
				}
				strings__Builder_write_string(&res, strconv__format_str(s, (strconv__BF_param){
					.pad_ch = pad_ch,
					.len0 = len0,
					.len1 = 0,
					.positive = true,
					.sign_flag = false,
					.allign = allign,
					.rm_tail_zero = 0,
				}));
				status = strconv__Char_parse_state_reset_params;
				p_index++;
				i++;
				continue;
			}
			if ((ch == L'f' || ch == L'F')) {
				strconv__v_sprintf_panic(p_index, pt.len);
				f64 x = *(((f64*)((*(voidptr*)/*ee elem_typ */array_get(pt, p_index)))));
				bool positive = x >= ((f64)(0.0));
				len1 = (len1 >= 0 ? (len1) : (def_len1));
				string s = strconv__format_fl(((f64)(x)), (strconv__BF_param){
					.pad_ch = pad_ch,
					.len0 = len0,
					.len1 = len1,
					.positive = positive,
					.sign_flag = sign,
					.allign = allign,
					.rm_tail_zero = 0,
				});
				strings__Builder_write_string(&res, (ch == L'F' ? (string_to_upper(s)) : (s)));
				status = strconv__Char_parse_state_reset_params;
				p_index++;
				i++;
				continue;
			} else if ((ch == L'e' || ch == L'E')) {
				strconv__v_sprintf_panic(p_index, pt.len);
				f64 x = *(((f64*)((*(voidptr*)/*ee elem_typ */array_get(pt, p_index)))));
				bool positive = x >= ((f64)(0.0));
				len1 = (len1 >= 0 ? (len1) : (def_len1));
				string s = strconv__format_es(((f64)(x)), (strconv__BF_param){
					.pad_ch = pad_ch,
					.len0 = len0,
					.len1 = len1,
					.positive = positive,
					.sign_flag = sign,
					.allign = allign,
					.rm_tail_zero = 0,
				});
				strings__Builder_write_string(&res, (ch == L'E' ? (string_to_upper(s)) : (s)));
				status = strconv__Char_parse_state_reset_params;
				p_index++;
				i++;
				continue;
			} else if ((ch == L'g' || ch == L'G')) {
				strconv__v_sprintf_panic(p_index, pt.len);
				f64 x = *(((f64*)((*(voidptr*)/*ee elem_typ */array_get(pt, p_index)))));
				bool positive = x >= ((f64)(0.0));
				string s = _SLIT("");
				f64 tx = strconv__fabs(x);
				if (tx < 999999.0 && tx >= 0.00001) {
					len1 = (len1 >= 0 ? (len1 + 1) : (def_len1));
					s = strconv__format_fl(x, (strconv__BF_param){
						.pad_ch = pad_ch,
						.len0 = len0,
						.len1 = len1,
						.positive = positive,
						.sign_flag = sign,
						.allign = allign,
						.rm_tail_zero = true,
					});
				} else {
					len1 = (len1 >= 0 ? (len1 + 1) : (def_len1));
					s = strconv__format_es(x, (strconv__BF_param){
						.pad_ch = pad_ch,
						.len0 = len0,
						.len1 = len1,
						.positive = positive,
						.sign_flag = sign,
						.allign = allign,
						.rm_tail_zero = true,
					});
				}
				strings__Builder_write_string(&res, (ch == L'G' ? (string_to_upper(s)) : (s)));
				status = strconv__Char_parse_state_reset_params;
				p_index++;
				i++;
				continue;
			} else if (ch == L's') {
				strconv__v_sprintf_panic(p_index, pt.len);
				string s1 = *(((string*)((*(voidptr*)/*ee elem_typ */array_get(pt, p_index)))));
				pad_ch = L' ';
				strings__Builder_write_string(&res, strconv__format_str(s1, (strconv__BF_param){
					.pad_ch = pad_ch,
					.len0 = len0,
					.len1 = 0,
					.positive = true,
					.sign_flag = false,
					.allign = allign,
					.rm_tail_zero = 0,
				}));
				status = strconv__Char_parse_state_reset_params;
				p_index++;
				i++;
				continue;
			}
		}
		status = strconv__Char_parse_state_reset_params;
		p_index++;
		i++;
	}
	if (p_index != pt.len) {
		v_panic(_STR("%"PRId32"\000 %% conversion specifiers, but given %"PRId32"\000 args", 3, p_index, pt.len));
	}
	return strings__Builder_str(&res);
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL void strconv__v_sprintf_panic(int idx, int len) {
	if (idx >= len) {
		v_panic(_STR("%"PRId32"\000 %% conversion specifiers, but given only %"PRId32"\000 args", 3, idx + 1, len));
	}
}

VV_LOCAL_SYMBOL f64 strconv__fabs(f64 x) {
	if (x < 0.0) {
		return -x;
	}
	return x;
}

// Attr: [inline]
inline string strconv__ftoa_64(f64 f) {
	return strconv__f64_to_str(f, 17);
}

// Attr: [inline]
inline string strconv__ftoa_long_64(f64 f) {
	return strconv__f64_to_str_l(f);
}

// Attr: [inline]
inline string strconv__ftoa_32(f32 f) {
	return strconv__f32_to_str(f, 8);
}

// Attr: [inline]
inline string strconv__ftoa_long_32(f32 f) {
	return strconv__f32_to_str_l(f);
}

string strconv__format_int(i64 n, int radix) {
	if (radix < 2 || radix > 36) {
		v_panic(_STR("invalid radix: %"PRId32"\000 . It should be => 2 and <= 36", 2, radix));
	}
	if (n == 0) {
		return _SLIT("0");
	}
	i64 n_copy = n;
	string sign = _SLIT("");
	if (n < 0) {
		sign = _SLIT("-");
		n_copy = -n_copy;
	}
	string res = _SLIT("");
	for (;;) {
		if (!(n_copy != 0)) break;
		res = string_add(byte_ascii_str(string_at(_const_strconv__base_digits, n_copy % radix)), res);
		n_copy /= radix;
	}
	return _STR("%.*s\000%.*s", 2, sign, res);
}

string strconv__format_uint(u64 n, int radix) {
	if (radix < 2 || radix > 36) {
		v_panic(_STR("invalid radix: %"PRId32"\000 . It should be => 2 and <= 36", 2, radix));
	}
	if (n == 0) {
		return _SLIT("0");
	}
	u64 n_copy = n;
	string res = _SLIT("");
	u64 uradix = ((u64)(radix));
	for (;;) {
		if (!(n_copy != 0)) break;
		res = string_add(byte_ascii_str(string_at(_const_strconv__base_digits, n_copy % uradix)), res);
		n_copy /= uradix;
	}
	return res;
}

VV_LOCAL_SYMBOL void strconv__assert1(bool t, string msg) {
	if (!t) {
		v_panic(msg);
	}
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL int strconv__bool_to_int(bool b) {
	if (b) {
		return 1;
	}
	return 0;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL u32 strconv__bool_to_u32(bool b) {
	if (b) {
		return ((u32)(1U));
	}
	return ((u32)(0U));
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL u64 strconv__bool_to_u64(bool b) {
	if (b) {
		return ((u64)(1U));
	}
	return ((u64)(0U));
}

VV_LOCAL_SYMBOL string strconv__get_string_special(bool neg, bool expZero, bool mantZero) {
	if (!mantZero) {
		return _SLIT("nan");
	}
	if (!expZero) {
		if (neg) {
			return _SLIT("-inf");
		} else {
			return _SLIT("+inf");
		}
	}
	if (neg) {
		return _SLIT("-0e+00");
	}
	return _SLIT("0e+00");
}

VV_LOCAL_SYMBOL int strconv__decimal_len_32(u32 u) {
	strconv__assert1(u < 1000000000, _SLIT("too big"));
	if (u >= 100000000) {
		return 9;
	} else if (u >= 10000000) {
		return 8;
	} else if (u >= 1000000) {
		return 7;
	} else if (u >= 100000) {
		return 6;
	} else if (u >= 10000) {
		return 5;
	} else if (u >= 1000) {
		return 4;
	} else if (u >= 100) {
		return 3;
	} else if (u >= 10) {
		return 2;
	}
	return 1;
}

VV_LOCAL_SYMBOL u32 strconv__mul_shift_32(u32 m, u64 mul, int ishift) {
	multi_return_u64_u64 mr_1855 = math__bits__mul_64(((u64)(m)), mul);
	u64 hi = mr_1855.arg0;
	u64 lo = mr_1855.arg1;
	u64 shifted_sum = (lo >> ((u64)(ishift))) + (hi << ((u64)(64 - ishift)));
	strconv__assert1(shifted_sum <= 2147483647, _SLIT("shiftedSum <= math.max_u32"));
	return ((u32)(shifted_sum));
}

VV_LOCAL_SYMBOL u32 strconv__mul_pow5_invdiv_pow2(u32 m, u32 q, int j) {
	return strconv__mul_shift_32(m, (*(u64*)/*ee elem_typ */array_get(_const_strconv__pow5_inv_split_32, q)), j);
}

VV_LOCAL_SYMBOL u32 strconv__mul_pow5_div_pow2(u32 m, u32 i, int j) {
	return strconv__mul_shift_32(m, (*(u64*)/*ee elem_typ */array_get(_const_strconv__pow5_split_32, i)), j);
}

VV_LOCAL_SYMBOL u32 strconv__pow5_factor_32(u32 i_v) {
	u32 v = i_v;
	for (u32 n = ((u32)(0U)); ; n++) {
		u32 q = v / 5;
		u32 r = v % 5;
		if (r != 0) {
			return n;
		}
		v = q;
	}
	return v;
}

VV_LOCAL_SYMBOL bool strconv__multiple_of_power_of_five_32(u32 v, u32 p) {
	return strconv__pow5_factor_32(v) >= p;
}

VV_LOCAL_SYMBOL bool strconv__multiple_of_power_of_two_32(u32 v, u32 p) {
	return ((u32)(math__bits__trailing_zeros_32(v))) >= p;
}

VV_LOCAL_SYMBOL u32 strconv__log10_pow2(int e) {
	strconv__assert1(e >= 0, _SLIT("e >= 0"));
	strconv__assert1(e <= 1650, _SLIT("e <= 1650"));
	return (((u32)(e)) * 78913) >> 18;
}

VV_LOCAL_SYMBOL u32 strconv__log10_pow5(int e) {
	strconv__assert1(e >= 0, _SLIT("e >= 0"));
	strconv__assert1(e <= 2620, _SLIT("e <= 2620"));
	return (((u32)(e)) * 732923) >> 20;
}

VV_LOCAL_SYMBOL int strconv__pow5_bits(int e) {
	strconv__assert1(e >= 0, _SLIT("e >= 0"));
	strconv__assert1(e <= 3528, _SLIT("e <= 3528"));
	return ((int)(((((u32)(e)) * 1217359) >> 19) + 1));
}

VV_LOCAL_SYMBOL int strconv__decimal_len_64(u64 u) {
	int log2 = 64 - math__bits__leading_zeros_64(u) - 1;
	int t = (log2 + 1) * 1233 >> 12;
	return t - strconv__bool_to_int(u < (*(u64*)/*ee elem_typ */array_get(_const_strconv__powers_of_10, t))) + 1;
}

VV_LOCAL_SYMBOL u64 strconv__shift_right_128(strconv__Uint128 v, int shift) {
	strconv__assert1(shift < 64, _SLIT("shift < 64"));
	return ((v.hi << ((u64)(64 - shift))) | (v.lo >> ((u32)(shift))));
}

VV_LOCAL_SYMBOL u64 strconv__mul_shift_64(u64 m, strconv__Uint128 mul, int shift) {
	multi_return_u64_u64 mr_4388 = math__bits__mul_64(m, mul.hi);
	u64 hihi = mr_4388.arg0;
	u64 hilo = mr_4388.arg1;
	multi_return_u64_u64 mr_4426 = math__bits__mul_64(m, mul.lo);
	u64 lohi = mr_4426.arg0;
	strconv__Uint128 sum = (strconv__Uint128){.lo = lohi + hilo,.hi = hihi,};
	if (sum.lo < lohi) {
		sum.hi++;
	}
	return strconv__shift_right_128(sum, shift - 64);
}

VV_LOCAL_SYMBOL u32 strconv__pow5_factor_64(u64 v_i) {
	u64 v = v_i;
	for (u32 n = ((u32)(0U)); ; n++) {
		u64 q = v / 5;
		u64 r = v % 5;
		if (r != 0) {
			return n;
		}
		v = q;
	}
	return ((u32)(0U));
}

VV_LOCAL_SYMBOL bool strconv__multiple_of_power_of_five_64(u64 v, u32 p) {
	return strconv__pow5_factor_64(v) >= p;
}

VV_LOCAL_SYMBOL bool strconv__multiple_of_power_of_two_64(u64 v, u32 p) {
	return ((u32)(math__bits__trailing_zeros_64(v))) >= p;
}

string strconv__f32_to_str_l(f64 f) {
	return strconv__f64_to_str_l(((f32)(f)));
}

string strconv__f64_to_str_l(f64 f) {
	string s = strconv__f64_to_str(f, 18);
	if (s.len > 2 && (string_at(s, 0) == L'n' || string_at(s, 1) == L'i')) {
		return s;
	}
	bool m_sgn_flag = false;
	int sgn = 1;
	Array_fixed_byte_26 b = {0};
	int d_pos = 1;
	int i = 0;
	int i1 = 0;
	int exp = 0;
	int exp_sgn = 1;
	for (int _t57 = 0; _t57 < s.len; ++_t57) {
		byte c = s.str[_t57];
		if (c == L'-') {
			sgn = -1;
			i++;
		} else if (c == L'+') {
			sgn = 1;
			i++;
		} else if (c >= L'0' && c <= L'9') {
			b[v_fixed_index(i1++, 26)] = c;
			i++;
		} else if (c == L'.') {
			if (sgn > 0) {
				d_pos = i;
			} else {
				d_pos = i - 1;
			}
			i++;
		} else if (c == L'e') {
			i++;
			break;
		} else {
			return _SLIT("Float conversion error!!");
		}
	}
	b[v_fixed_index(i1, 26)] = 0;
	if (string_at(s, i) == L'-') {
		exp_sgn = -1;
		i++;
	} else if (string_at(s, i) == L'+') {
		exp_sgn = 1;
		i++;
	}
	for (int _t58 = 0; _t58 < string_substr(s, i, s.len).len; ++_t58) {
		byte c = string_substr(s, i, s.len).str[_t58];
		exp = exp * 10 + ((int)(c - L'0'));
	}
	Array_byte res = __new_array_with_default(exp + 32, 0, sizeof(byte), &(byte[]){0});
	int r_i = 0;
	if (sgn == 1) {
		if (m_sgn_flag) {
			array_set(&res, r_i++, &(byte[]) { L'+' });
		}
	} else {
		array_set(&res, r_i++, &(byte[]) { L'-' });
	}
	i = 0;
	if (exp_sgn >= 0) {
		for (;;) {
			if (!(b[v_fixed_index(i, 26)] != 0)) break;
			array_set(&res, r_i++, &(byte[]) { b[v_fixed_index(i, 26)] });
			i++;
			if (i >= d_pos && exp >= 0) {
				if (exp == 0) {
					array_set(&res, r_i++, &(byte[]) { L'.' });
				}
				exp--;
			}
		}
		for (;;) {
			if (!(exp >= 0)) break;
			array_set(&res, r_i++, &(byte[]) { L'0' });
			exp--;
		}
	} else {
		bool dot_p = true;
		for (;;) {
			if (!(exp > 0)) break;
			array_set(&res, r_i++, &(byte[]) { L'0' });
			exp--;
			if (dot_p) {
				array_set(&res, r_i++, &(byte[]) { L'.' });
				dot_p = false;
			}
		}
		for (;;) {
			if (!(b[v_fixed_index(i, 26)] != 0)) break;
			array_set(&res, r_i++, &(byte[]) { b[v_fixed_index(i, 26)] });
			i++;
		}
	}
	array_set(&res, r_i, &(byte[]) { 0 });
	return tos(res.data, r_i);
}

VV_LOCAL_SYMBOL array __new_array(int mylen, int cap, int elm_size) {
	int cap_ = (cap < mylen ? (mylen) : (cap));
	array arr = (array){.element_size = elm_size,.data = vcalloc(cap_ * elm_size),.len = mylen,.cap = cap_,};
	return arr;
}

VV_LOCAL_SYMBOL array __new_array_with_default(int mylen, int cap, int elm_size, voidptr val) {
	int cap_ = (cap < mylen ? (mylen) : (cap));
	array arr = (array){.element_size = elm_size,.data = vcalloc(cap_ * elm_size),.len = mylen,.cap = cap_,};
	if (val != 0) {
		for (int i = 0; i < arr.len; ++i) {
			array_set_unsafe(&arr, i, val);
		}
	}
	return arr;
}

VV_LOCAL_SYMBOL array __new_array_with_array_default(int mylen, int cap, int elm_size, array val) {
	int cap_ = (cap < mylen ? (mylen) : (cap));
	array arr = (array){.element_size = elm_size,.data = vcalloc(cap_ * elm_size),.len = mylen,.cap = cap_,};
	for (int i = 0; i < arr.len; ++i) {
		array val_clone = array_clone(&val);
		array_set_unsafe(&arr, i, &val_clone);
	}
	return arr;
}

VV_LOCAL_SYMBOL array new_array_from_c_array(int len, int cap, int elm_size, voidptr c_array) {
	int cap_ = (cap < len ? (len) : (cap));
	array arr = (array){.element_size = elm_size,.data = vcalloc(cap_ * elm_size),.len = len,.cap = cap_,};
	memcpy(arr.data, c_array, len * elm_size);
	return arr;
}

VV_LOCAL_SYMBOL array new_array_from_c_array_no_alloc(int len, int cap, int elm_size, voidptr c_array) {
	array arr = (array){.element_size = elm_size,.data = c_array,.len = len,.cap = cap,};
	return arr;
}

VV_LOCAL_SYMBOL void array_ensure_cap(array* a, int required) {
	if (required <= a->cap) {
		return;
	}
	int cap = (a->cap > 0 ? (a->cap) : (2));
	for (;;) {
		if (!(required > cap)) break;
		cap *= 2;
	}
	int new_size = cap * a->element_size;
	byte* new_data = ((byte*)(0));
	if (a->cap > 0) {
		new_data = realloc_data(a->data, a->cap * a->element_size, new_size);
	} else {
		new_data = vcalloc(new_size);
	}
	a->data = new_data;
	a->cap = cap;
}

array array_repeat(array a, int count) {
	if (count < 0) {
		v_panic(_STR("array.repeat: count is negative: %"PRId32"", 1, count));
	}
	int size = count * a.len * a.element_size;
	if (size == 0) {
		size = a.element_size;
	}
	array arr = (array){.element_size = a.element_size,.data = vcalloc(size),.len = count * a.len,.cap = count * a.len,};
	int size_of_array = ((int)(/*SizeOf*/ sizeof(array)));
	for (int i = 0; i < count; ++i) {
		if (a.len > 0 && a.element_size == size_of_array) {
			array ary = (array){.element_size = 0,.data = 0,.len = 0,.cap = 0,};
			memcpy(&ary, a.data, size_of_array);
			array ary_clone = array_clone(&ary);
			memcpy(array_get_unsafe(arr, i * a.len), &ary_clone, a.len * a.element_size);
		} else {
			memcpy(array_get_unsafe(arr, i * a.len), ((byte*)(a.data)), a.len * a.element_size);
		}
	}
	return arr;
}

void array_sort_with_compare(array* a, voidptr compare) {
	qsort(a->data, a->len, a->element_size, compare);
}

void array_insert(array* a, int i, voidptr val) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (i < 0 || i > a->len) {
			v_panic(_STR("array.insert: index out of range (i == %"PRId32"\000, a.len == %"PRId32"\000)", 3, i, a->len));
		}
	}
	#endif
	array_ensure_cap(a, a->len + 1);
	{ // Unsafe block
		memmove(array_get_unsafe(/*rec*/*a, i + 1), array_get_unsafe(/*rec*/*a, i), (a->len - i) * a->element_size);
		array_set_unsafe(a, i, val);
	}
	a->len++;
}

// Attr: [unsafe]
void array_insert_many(array* a, int i, voidptr val, int size) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (i < 0 || i > a->len) {
			v_panic(_STR("array.insert_many: index out of range (i == %"PRId32"\000, a.len == %"PRId32"\000)", 3, i, a->len));
		}
	}
	#endif
	array_ensure_cap(a, a->len + size);
	int elem_size = a->element_size;
	{ // Unsafe block
		voidptr iptr = array_get_unsafe(/*rec*/*a, i);
		memmove(array_get_unsafe(/*rec*/*a, i + size), iptr, (a->len - i) * elem_size);
		memcpy(iptr, val, size * elem_size);
	}
	a->len += size;
}

void array_prepend(array* a, voidptr val) {
	array_insert(a, 0, val);
}

// Attr: [unsafe]
void array_prepend_many(array* a, voidptr val, int size) {
	array_insert_many(a, 0, val, size);
}

void array_delete(array* a, int i) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (i < 0 || i >= a->len) {
			v_panic(_STR("array.delete: index out of range (i == %"PRId32"\000, a.len == %"PRId32"\000)", 3, i, a->len));
		}
	}
	#endif
	memmove(array_get_unsafe(/*rec*/*a, i), array_get_unsafe(/*rec*/*a, i + 1), (a->len - i - 1) * a->element_size);
	a->len--;
}

void array_clear(array* a) {
	a->len = 0;
}

void array_trim(array* a, int index) {
	if (index < a->len) {
		a->len = index;
	}
}

// Attr: [inline]
// Attr: [unsafe]
inline VV_LOCAL_SYMBOL voidptr array_get_unsafe(array a, int i) {
	{ // Unsafe block
		return ((byte*)(a.data)) + i * a.element_size;
	}
	return 0;
}

VV_LOCAL_SYMBOL voidptr array_get(array a, int i) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (i < 0 || i >= a.len) {
			v_panic(_STR("array.get: index out of range (i == %"PRId32"\000, a.len == %"PRId32"\000)", 3, i, a.len));
		}
	}
	#endif
	{ // Unsafe block
		return ((byte*)(a.data)) + i * a.element_size;
	}
	return 0;
}

VV_LOCAL_SYMBOL voidptr array_get_with_check(array a, int i) {
	if (i < 0 || i >= a.len) {
		return 0;
	}
	{ // Unsafe block
		return ((byte*)(a.data)) + i * a.element_size;
	}
	return 0;
}

voidptr array_first(array a) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (a.len == 0) {
			v_panic(_SLIT("array.first: array is empty"));
		}
	}
	#endif
	return a.data;
}

voidptr array_last(array a) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (a.len == 0) {
			v_panic(_SLIT("array.last: array is empty"));
		}
	}
	#endif
	{ // Unsafe block
		return ((byte*)(a.data)) + (a.len - 1) * a.element_size;
	}
	return 0;
}

voidptr array_pop(array* a) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (a->len == 0) {
			v_panic(_SLIT("array.pop: array is empty"));
		}
	}
	#endif
	int new_len = a->len - 1;
	byte* last_elem = ((byte*)(a->data)) + (new_len) * a->element_size;
	a->len = new_len;
	return memdup(last_elem, a->element_size);
}

void array_delete_last(array* a) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (a->len == 0) {
			v_panic(_SLIT("array.pop: array is empty"));
		}
	}
	#endif
	a->len--;
}

VV_LOCAL_SYMBOL array array_slice(array a, int start, int _end) {
	int end = _end;
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (start > end) {
			v_panic(_STR("array.slice: invalid slice index (%"PRId32"\000 > %"PRId32"\000)", 3, start, end));
		}
		if (end > a.len) {
			v_panic(_STR("array.slice: slice bounds out of range (%"PRId32"\000 >= %"PRId32"\000)", 3, end, a.len));
		}
		if (start < 0) {
			v_panic(_STR("array.slice: slice bounds out of range (%"PRId32"\000 < 0)", 2, start));
		}
	}
	#endif
	byte* data = ((byte*)(0));
	{ // Unsafe block
		data = ((byte*)(a.data)) + start * a.element_size;
	}
	int l = end - start;
	array res = (array){.element_size = a.element_size,.data = data,.len = l,.cap = l,};
	return res;
}

VV_LOCAL_SYMBOL array array_slice2(array a, int start, int _end, bool end_max) {
	int end = (end_max ? (a.len) : (_end));
	return array_slice(a, start, end);
}

VV_LOCAL_SYMBOL array array_clone_static(array a) {
	return array_clone(&a);
}

array array_clone(array* a) {
	int size = a->cap * a->element_size;
	if (size == 0) {
		size++;
	}
	array arr = (array){.element_size = a->element_size,.data = vcalloc(size),.len = a->len,.cap = a->cap,};
	int size_of_array = ((int)(/*SizeOf*/ sizeof(array)));
	if (a->element_size == size_of_array) {
		bool is_elem_array = true;
		for (int i = 0; i < a->len; ++i) {
			array ar = (array){.element_size = 0,.data = 0,.len = 0,.cap = 0,};
			memcpy(&ar, array_get_unsafe(/*rec*/*a, i), size_of_array);
			if (ar.len > ar.cap || ar.cap <= 0 || ar.element_size <= 0) {
				is_elem_array = false;
				break;
			}
			array ar_clone = array_clone(&ar);
			array_set_unsafe(&arr, i, &ar_clone);
		}
		if (is_elem_array) {
			return arr;
		}
	}
	if (!isnil(a->data)) {
		memcpy(((byte*)(arr.data)), a->data, a->cap * a->element_size);
	}
	return arr;
}

VV_LOCAL_SYMBOL array array_slice_clone(array* a, int start, int _end) {
	int end = _end;
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (start > end) {
			v_panic(_STR("array.slice: invalid slice index (%"PRId32"\000 > %"PRId32"\000)", 3, start, end));
		}
		if (end > a->len) {
			v_panic(_STR("array.slice: slice bounds out of range (%"PRId32"\000 >= %"PRId32"\000)", 3, end, a->len));
		}
		if (start < 0) {
			v_panic(_STR("array.slice: slice bounds out of range (%"PRId32"\000 < 0)", 2, start));
		}
	}
	#endif
	byte* data = ((byte*)(0));
	{ // Unsafe block
		data = ((byte*)(a->data)) + start * a->element_size;
	}
	int l = end - start;
	array res = (array){.element_size = a->element_size,.data = data,.len = l,.cap = l,};
	return array_clone(&res);
}

// Attr: [inline]
// Attr: [unsafe]
inline VV_LOCAL_SYMBOL void array_set_unsafe(array* a, int i, voidptr val) {
	memcpy(((byte*)(a->data)) + a->element_size * i, val, a->element_size);
}

VV_LOCAL_SYMBOL void array_set(array* a, int i, voidptr val) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (i < 0 || i >= a->len) {
			v_panic(_STR("array.set: index out of range (i == %"PRId32"\000, a.len == %"PRId32"\000)", 3, i, a->len));
		}
	}
	#endif
	memcpy(((byte*)(a->data)) + a->element_size * i, val, a->element_size);
}

VV_LOCAL_SYMBOL void array_push(array* a, voidptr val) {
	array_ensure_cap(a, a->len + 1);
	memmove(((byte*)(a->data)) + a->element_size * a->len, val, a->element_size);
	a->len++;
}

// Attr: [unsafe]
void array_push_many(array* a3, voidptr val, int size) {
	if (a3->data == val && !isnil(a3->data)) {
		array copy = array_clone(a3);
		array_ensure_cap(a3, a3->len + size);
		memcpy(array_get_unsafe(/*rec*/*a3, a3->len), copy.data, a3->element_size * size);
	} else {
		array_ensure_cap(a3, a3->len + size);
		if (!isnil(a3->data) && !isnil(val)) {
			memcpy(array_get_unsafe(/*rec*/*a3, a3->len), val, a3->element_size * size);
		}
	}
	a3->len += size;
}

void array_reverse_in_place(array* a) {
	if (a->len < 2) {
		return;
	}
	{ // Unsafe block
		byte* tmp_value = v_malloc(a->element_size);
		for (int i = 0; i < a->len / 2; ++i) {
			memcpy(tmp_value, ((byte*)(a->data)) + i * a->element_size, a->element_size);
			memcpy(((byte*)(a->data)) + i * a->element_size, ((byte*)(a->data)) + (a->len - 1 - i) * a->element_size, a->element_size);
			memcpy(((byte*)(a->data)) + (a->len - 1 - i) * a->element_size, tmp_value, a->element_size);
		}
		v_free(tmp_value);
	}
}

array array_reverse(array a) {
	if (a.len < 2) {
		return a;
	}
	array arr = (array){.element_size = a.element_size,.data = vcalloc(a.cap * a.element_size),.len = a.len,.cap = a.cap,};
	for (int i = 0; i < a.len; ++i) {
		array_set_unsafe(&arr, i, array_get_unsafe(a, a.len - 1 - i));
	}
	return arr;
}

// Attr: [unsafe]
void array_free(array* a) {
	v_free(a->data);
}

// Attr: [unsafe]
void Array_string_free(Array_string* a) {
	// FOR IN array
	for (int _t59 = 0; _t59 < a->len; ++_t59) {
		string s = ((string*)a->data)[_t59];
		string_free(&s);
	}
	v_free(a->data);
}

// Attr: [manualfree]
string Array_string_str(Array_string a) {
	strings__Builder sb = strings__new_builder(a.len * 3);
	strings__Builder_write_string(&sb, _SLIT("["));
	for (int i = 0; i < a.len; ++i) {
		string val = (*(string*)/*ee elem_typ */array_get(a, i));
		strings__Builder_write_string(&sb, _SLIT("'"));
		strings__Builder_write_string(&sb, val);
		strings__Builder_write_string(&sb, _SLIT("'"));
		if (i < a.len - 1) {
			strings__Builder_write_string(&sb, _SLIT(", "));
		}
	}
	strings__Builder_write_string(&sb, _SLIT("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}

string Array_byte_hex(Array_byte b) {
	byte* hex = v_malloc(b.len * 2 + 1);
	int dst_i = 0;
	// FOR IN array
	for (int _t60 = 0; _t60 < b.len; ++_t60) {
		byte i = ((byte*)b.data)[_t60];
		byte n0 = i >> 4;
		{ // Unsafe block
			hex[dst_i++] = (n0 < 10 ? (n0 + L'0') : (n0 + ((byte)(87))));
		}
		byte n1 = (i & 0xF);
		{ // Unsafe block
			hex[dst_i++] = (n1 < 10 ? (n1 + L'0') : (n1 + ((byte)(87))));
		}
	}
	{ // Unsafe block
		hex[dst_i] = L'\0';
		return tos(hex, dst_i);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

int copy(Array_byte dst, Array_byte src) {
	int min = (dst.len < src.len ? (dst.len) : (src.len));
	if (min > 0) {
		memcpy(((byte*)(dst.data)), src.data, min);
	}
	return min;
}

VV_LOCAL_SYMBOL int compare_ints(int* a, int* b) {
	if (*a < *b) {
		return -1;
	}
	if (*a > *b) {
		return 1;
	}
	return 0;
}

VV_LOCAL_SYMBOL int compare_ints_reverse(int* a, int* b) {
	if (*a > *b) {
		return -1;
	}
	if (*a < *b) {
		return 1;
	}
	return 0;
}

void Array_int_sort(Array_int* a) {
	array_sort_with_compare(a, compare_ints);
}

int Array_string_index(Array_string a, string v) {
	for (int i = 0; i < a.len; ++i) {
		if (string_eq((*(string*)/*ee elem_typ */array_get(a, i)), v)) {
			return i;
		}
	}
	return -1;
}

int Array_int_reduce(Array_int a, int (*iter)(int , int ), int accum_start) {
	int accum_ = accum_start;
	// FOR IN array
	for (int _t61 = 0; _t61 < a.len; ++_t61) {
		int i = ((int*)a.data)[_t61];
		accum_ = iter(accum_, i);
	}
	return accum_;
}

void array_grow_cap(array* a, int amount) {
	array_ensure_cap(a, a->cap + amount);
}

// Attr: [unsafe]
void array_grow_len(array* a, int amount) {
	array_ensure_cap(a, a->len + amount);
	a->len += amount;
}

bool Array_string_eq(Array_string a1, Array_string a2) {
	if (a1.len != a2.len) {
		return false;
	}
	int size_of_string = ((int)(/*SizeOf*/ sizeof(string)));
	for (int i = 0; i < a1.len; ++i) {
		int offset = i * size_of_string;
		string* s1 = ((string*)(((byte*)(a1.data)) + offset));
		string* s2 = ((string*)(((byte*)(a2.data)) + offset));
		if (string_ne(*s1, *s2)) {
			return false;
		}
	}
	return true;
}

// Attr: [unsafe]
Array_voidptr array_pointers(array a) {
	Array_voidptr res = __new_array_with_default(0, 0, sizeof(voidptr), 0);
	for (int i = 0; i < a.len; ++i) {
		array_push(&res, _MOV((voidptr[]){ array_get_unsafe(a, i) }));
	}
	return res;
}

// Attr: [unsafe]
Array_byte voidptr_vbytes(voidptr data, int len) {
	array res = (array){.element_size = 1,.data = data,.len = len,.cap = len,};
	return res;
}

// Attr: [unsafe]
Array_byte byte_vbytes(byte* data, int len) {
	return voidptr_vbytes(((voidptr)(data)), len);
}

// TypeDecl
void v_exit(int code) {
	exit(code);
}

VV_LOCAL_SYMBOL void panic_debug(int line_no, string file, string mod, string fn_name, string s) {
	eprintln(_SLIT("================ V panic ================"));
	eprintln(_STR("   module: %.*s", 1, mod));
	eprintln(_STR(" function: %.*s\000()", 2, fn_name));
	eprintln(_STR("  message: %.*s", 1, s));
	eprintln(_STR("     file: %.*s\000:%"PRId32"", 2, file, line_no));
	eprintln(_SLIT("========================================="));
	#if defined(CUSTOM_DEFINE_exit_after_panic_message)
	{
	}
	#else
	{
		#if defined(CUSTOM_DEFINE_no_backtrace)
		{
		}
		#else
		{
			print_backtrace_skipping_top_frames(1);
			exit(1);
		}
		#endif
	}
	#endif
}

void panic_optional_not_set(string s) {
	v_panic(_STR("optional not set (%.*s\000)", 2, s));
}

void v_panic(string s) {
	eprintln(_STR("V panic: %.*s", 1, s));
	#if defined(CUSTOM_DEFINE_exit_after_panic_message)
	{
	}
	#else
	{
		#if defined(CUSTOM_DEFINE_no_backtrace)
		{
		}
		#else
		{
			print_backtrace_skipping_top_frames(1);
			exit(1);
		}
		#endif
	}
	#endif
}

void eprintln(string s) {
	fflush(stdout);
	fflush(stderr);
	#if defined(__ANDROID__)
	{
	}
	#elif defined(__TARGET_IOS__)
	{
	}
	#else
	{
		if (s.str == 0) {
			write(2, "eprintln(NIL)\n", 14);
		} else {
			write(2, s.str, s.len);
			write(2, "\n", 1);
		}
	}
	#endif
	fflush(stderr);
}

void eprint(string s) {
	fflush(stdout);
	fflush(stderr);
	#if defined(__ANDROID__)
	{
	}
	#elif defined(__TARGET_IOS__)
	{
	}
	#else
	{
		if (s.str == 0) {
			write(2, "eprint(NIL)", 11);
		} else {
			write(2, s.str, s.len);
		}
	}
	#endif
	fflush(stderr);
}

void print(string s) {
	#if defined(__ANDROID__)
	{
	}
	#elif defined(__TARGET_IOS__)
	{
	}
	#else
	{
		write(1, s.str, s.len);
	}
	#endif
}

void println(string s) {
	if (s.str == 0) {
		#if defined(__ANDROID__)
		{
		}
		#elif defined(__TARGET_IOS__)
		{
		}
		#else
		{
			write(1, "println(NIL)\n", 13);
		}
		#endif
		return;
	}
	#if defined(__ANDROID__)
	{
	}
	#elif defined(__TARGET_IOS__)
	{
	}
	#else
	{
		write(1, s.str, s.len);
		write(1, "\n", 1);
	}
	#endif
}

// Attr: [unsafe]
byte* v_malloc(int n) {
	if (n <= 0) {
		v_panic(_SLIT("> V malloc(<=0)"));
	}
	byte* res = ((byte*)(0));
	#if defined(_VPREALLOC)
	{
	}
	#else
	{
		#if defined(_VGCBOEHM)
		{
		}
		#else
		{
			res = malloc(n);
		}
		#endif
		if (res == 0) {
			v_panic(_STR("malloc(%"PRId32"\000) failed", 2, n));
		}
	}
	#endif
	return res;
}

// Attr: [unsafe]
byte* v_realloc(byte* b, int n) {
	byte* new_ptr = ((byte*)(0));
	#if defined(_VPREALLOC)
	{
	}
	#else
	{
		#if defined(_VGCBOEHM)
		{
		}
		#else
		{
			new_ptr = realloc(b, n);
		}
		#endif
		if (new_ptr == 0) {
			v_panic(_STR("realloc(%"PRId32"\000) failed", 2, n));
		}
	}
	#endif
	return new_ptr;
}

// Attr: [unsafe]
byte* realloc_data(byte* old_data, int old_size, int new_size) {
	byte* nptr = ((byte*)(0));
	#if defined(_VGCBOEHM)
	{
	}
	#else
	{
		nptr = realloc(old_data, new_size);
	}
	#endif
	if (nptr == 0) {
		v_panic(_STR("realloc_data(%"PRId32"\000, %"PRId32"\000, %"PRId32"\000) failed", 4, old_data, old_size, new_size));
	}
	return nptr;
}

byte* vcalloc(int n) {
	if (n < 0) {
		v_panic(_SLIT("calloc(<=0)"));
	} else if (n == 0) {
		return ((byte*)(0));
	}
	#if defined(_VGCBOEHM)
	{
	}
	#else
	{
		return calloc(1, n);
	}
	#endif
	return 0;
}

// Attr: [unsafe]
void v_free(voidptr ptr) {
	free(ptr);
}

// Attr: [unsafe]
voidptr memdup(voidptr src, int sz) {
	if (sz == 0) {
		return vcalloc(1);
	}
	{ // Unsafe block
		byte* mem = v_malloc(sz);
		return memcpy(mem, src, sz);
	}
	return 0;
}

int is_atty(int fd) {
	#if defined(_WIN32)
	{
		u32 mode = ((u32)(0U));
		voidptr osfh = ((voidptr)(_get_osfhandle(fd)));
		GetConsoleMode(osfh, ((voidptr)(&mode)));
		return ((int)(mode));
	}
	#else
	{
	}
	#endif
	return 0;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL int v_fixed_index(int i, int len) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (i < 0 || i >= len) {
			string s = _STR("fixed array index out of range (index: %"PRId32"\000, len: %"PRId32"\000)", 3, i, len);
			v_panic(s);
		}
	}
	#endif
	return i;
}

bool isnil(voidptr v) {
	return v == 0;
}

void print_backtrace(void) {
	print_backtrace_skipping_top_frames(2);
}

VV_LOCAL_SYMBOL voidptr __as_cast(voidptr obj, int obj_type, int expected_type) {
	if (obj_type != expected_type) {
		string obj_name = string_clone((*(VCastTypeIndexName*)/*ee elem_typ */array_get(as_cast_type_indexes, 0)).tname);
		string expected_name = string_clone((*(VCastTypeIndexName*)/*ee elem_typ */array_get(as_cast_type_indexes, 0)).tname);
		// FOR IN array
		for (int _t63 = 0; _t63 < as_cast_type_indexes.len; ++_t63) {
			VCastTypeIndexName x = ((VCastTypeIndexName*)as_cast_type_indexes.data)[_t63];
			if (x.tindex == obj_type) {
				obj_name = string_clone(x.tname);
			}
			if (x.tindex == expected_type) {
				expected_name = string_clone(x.tname);
			}
		}
		v_panic(_STR("as cast: cannot cast `%.*s\000` to `%.*s\000`", 3, obj_name, expected_name));
	}
	return obj;
}

VV_LOCAL_SYMBOL void __print_assert_failure(VAssertMetaInfo* i) {
	eprintln(_STR("%.*s\000:%"PRId32"\000: FAIL: fn %.*s\000: assert %.*s", 4, i->fpath, i->line_nr + 1, i->fn_name, i->src));
	if (i->op.len > 0 && string_ne(i->op, _SLIT("call"))) {
		eprintln(_STR("   left value: %.*s\000 = %.*s", 2, i->llabel, i->lvalue));
		if (string_eq(i->rlabel, i->rvalue)) {
			eprintln(_STR("  right value: %.*s", 1, i->rlabel));
		} else {
			eprintln(_STR("  right value: %.*s\000 = %.*s", 2, i->rlabel, i->rvalue));
		}
	}
}

void gc_check_leaks(void) {
}

VV_LOCAL_SYMBOL void restore_codepage(void) {
	SetConsoleOutputCP(g_original_codepage);
}

VV_LOCAL_SYMBOL void builtin_init(void) {
	g_original_codepage = GetConsoleOutputCP();
	SetConsoleOutputCP(CP_UTF8);
	atexit(restore_codepage);
	if (is_atty(1) > 0) {
		SetConsoleMode(GetStdHandle(STD_OUTPUT_HANDLE), ((ENABLE_PROCESSED_OUTPUT | ENABLE_WRAP_AT_EOL_OUTPUT) | 0x0004));
		SetConsoleMode(GetStdHandle(STD_ERROR_HANDLE), ((ENABLE_PROCESSED_OUTPUT | ENABLE_WRAP_AT_EOL_OUTPUT) | 0x0004));
		{ // Unsafe block
			setbuf(stdout, 0);
			setbuf(stderr, 0);
		}
	}
	add_unhandled_exception_handler();
}

VV_LOCAL_SYMBOL bool print_backtrace_skipping_top_frames(int skipframes) {
	#if defined(__MINGW32__)
	{
		return print_backtrace_skipping_top_frames_mingw(skipframes);
	}
	#endif
	eprintln(_SLIT("print_backtrace_skipping_top_frames is not implemented"));
	return false;
}

VV_LOCAL_SYMBOL bool print_backtrace_skipping_top_frames_msvc(int skipframes) {
	#if defined(_MSC_VER)
	{
	}
	#else
	{
		eprintln(_SLIT("print_backtrace_skipping_top_frames_msvc must be called only when the compiler is msvc"));
		return false;
	}
	#endif
	return 0;
}

VV_LOCAL_SYMBOL bool print_backtrace_skipping_top_frames_mingw(int skipframes) {
	eprintln(_SLIT("print_backtrace_skipping_top_frames_mingw is not implemented"));
	return false;
}

VV_LOCAL_SYMBOL bool print_backtrace_skipping_top_frames_tcc(int skipframes) {
	#if defined(__TINYC__)
	{
	}
	#else
	{
		eprintln(_SLIT("print_backtrace_skipping_top_frames_tcc must be called only when the compiler is tcc"));
		return false;
	}
	#endif
	return false;
}

// TypeDecl
VV_LOCAL_SYMBOL void add_vectored_exception_handler(VectoredExceptionHandler handler) {
	AddVectoredExceptionHandler(1, ((PVECTORED_EXCEPTION_HANDLER)(handler)));
}

// Attr: [windows_stdcall]
VV_LOCAL_SYMBOL int __stdcall  unhandled_exception_handler(ExceptionPointers* e) {

	if (e->exception_record->code == (0x4001000A) || e->exception_record->code == (0x40010006)) {
		return 0;
	}
	else {
		println(_STR("Unhandled Exception 0x%"PRIX32"", 1, e->exception_record->code));
		print_backtrace_skipping_top_frames(5);
	};
	return 0;
}

VV_LOCAL_SYMBOL void add_unhandled_exception_handler(void) {
	add_vectored_exception_handler(((VectoredExceptionHandler)(((voidptr)(unhandled_exception_handler)))));
}

VV_LOCAL_SYMBOL void break_if_debugger_attached(void) {
	#if defined(__TINYC__)
	{
	}
	#else
	{
		if (IsDebuggerPresent()) {
			__debugbreak();
		}
	}
	#endif
}

// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
int proc_pidpath(int , voidptr , int );

// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
void chan_close(chan ch) {
}

ChanState chan_try_pop(chan ch, voidptr obj) {
	return ChanState_success;
}

ChanState chan_try_push(chan ch, voidptr obj) {
	return ChanState_success;
}

// Attr: [inline]
inline string f64_str(f64 x) {
	f64 abs_x = f64_abs(x);
	if (abs_x >= 0.0001 && abs_x < 1.0e6) {
		return strconv__f64_to_str_l(x);
	} else {
		return strconv__ftoa_64(x);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [inline]
inline string float_literal_str(float_literal d) {
	return f64_str(((f64)(d)));
}

// Attr: [inline]
inline string f64_strsci(f64 x, int digit_num) {
	int n_digit = digit_num;
	if (n_digit < 1) {
		n_digit = 1;
	} else if (n_digit > 17) {
		n_digit = 17;
	}
	return strconv__f64_to_str(x, n_digit);
}

// Attr: [inline]
inline string f64_strlong(f64 x) {
	return strconv__f64_to_str_l(x);
}

// Attr: [inline]
inline string f32_str(f32 x) {
	f32 abs_x = f32_abs(x);
	if (abs_x >= 0.0001 && abs_x < 1.0e6) {
		return strconv__f32_to_str_l(x);
	} else {
		return strconv__ftoa_32(x);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [inline]
inline string f32_strsci(f32 x, int digit_num) {
	int n_digit = digit_num;
	if (n_digit < 1) {
		n_digit = 1;
	} else if (n_digit > 8) {
		n_digit = 8;
	}
	return strconv__f32_to_str(x, n_digit);
}

// Attr: [inline]
inline string f32_strlong(f32 x) {
	return strconv__f32_to_str_l(x);
}

// Attr: [inline]
inline f32 f32_abs(f32 a) {
	return (a < 0 ? (-a) : (a));
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL f64 f64_abs(f64 a) {
	return (a < 0 ? (-a) : (a));
}

// Attr: [inline]
inline f32 f32_max(f32 a, f32 b) {
	return (a > b ? (a) : (b));
}

// Attr: [inline]
inline f32 f32_min(f32 a, f32 b) {
	return (a < b ? (a) : (b));
}

// Attr: [inline]
inline f64 f64_max(f64 a, f64 b) {
	return (a > b ? (a) : (b));
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL f64 f64_min(f64 a, f64 b) {
	return (a < b ? (a) : (b));
}

// Attr: [inline]
inline bool f32_eq_epsilon(f32 a, f32 b) {
	f32 hi = f32_max(f32_abs(a), f32_abs(b));
	f32 delta = f32_abs(a - b);
	if (hi > ((f32)(1.0))) {
		return delta <= hi * (4 * ((f32)(FLT_EPSILON)));
	} else {
		return (1 / (4 * ((f32)(FLT_EPSILON)))) * delta <= hi;
	}
	return 0;
}

// Attr: [inline]
inline bool f64_eq_epsilon(f64 a, f64 b) {
	f64 hi = f64_max(f64_abs(a), f64_abs(b));
	f64 delta = f64_abs(a - b);
	if (hi > 1.0) {
		return delta <= hi * (4 * ((f64)(DBL_EPSILON)));
	} else {
		return (1 / (4 * ((f64)(DBL_EPSILON)))) * delta <= hi;
	}
	return 0;
}

string ptr_str(voidptr ptr) {
	string buf1 = u64_hex(((u64)(ptr)));
	return buf1;
}

string char_str(char* cptr) {
	return u64_hex(((u64)(cptr)));
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL string int_str_l(int nn, int max) {
	i64 n = ((i64)(nn));
	int d = 0;
	if (n == 0) {
		return _SLIT("0");
	}
	byte* buf = v_malloc(max + 1);
	bool is_neg = false;
	if (n < 0) {
		n = -n;
		is_neg = true;
	}
	int index = max;
	{ // Unsafe block
		buf[index--] = L'\0';
	}
	for (;;) {
		if (!(n > 0)) break;
		int n1 = ((int)(n / 100));
		d = ((((int)(n)) - (n1 * 100)) << 1);
		n = n1;
		{ // Unsafe block
			buf[index--] = _const_digit_pairs.str[d++];
			buf[index--] = _const_digit_pairs.str[d];
		}
	}
	index++;
	if (d < 20) {
		index++;
	}
	if (is_neg) {
		index--;
		{ // Unsafe block
			buf[index] = L'-';
		}
	}
	{ // Unsafe block
		memmove(buf, buf + index, (max - index) + 1);
		return tos(buf, (max - index));
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

string i8_str(i8 n) {
	return int_str_l(((int)(n)), 5);
}

string i16_str(i16 n) {
	return int_str_l(((int)(n)), 7);
}

string u16_str(u16 n) {
	return int_str_l(((int)(n)), 7);
}

string int_str(int n) {
	return int_str_l(n, 12);
}

string u32_str(u32 nn) {
	u32 n = nn;
	u32 d = ((u32)(0U));
	if (n == 0) {
		return _SLIT("0");
	}
	int max = 12;
	byte* buf = v_malloc(max + 1);
	int index = max;
	{ // Unsafe block
		buf[index--] = L'\0';
	}
	for (;;) {
		if (!(n > 0)) break;
		u32 n1 = n / ((u32)(100U));
		d = ((n - (n1 * ((u32)(100U)))) << ((u32)(1U)));
		n = n1;
		{ // Unsafe block
			buf[index--] = string_at(_const_digit_pairs, d++);
			buf[index--] = string_at(_const_digit_pairs, d);
		}
	}
	index++;
	if (d < ((u32)(20U))) {
		index++;
	}
	{ // Unsafe block
		memmove(buf, buf + index, (max - index) + 1);
		return tos(buf, (max - index));
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [inline]
inline string int_literal_str(int_literal n) {
	return i64_str(((i64)(n)));
}

string i64_str(i64 nn) {
	i64 n = nn;
	i64 d = ((i64)(0));
	if (n == 0) {
		return _SLIT("0");
	}
	int max = 20;
	byte* buf = vcalloc(max + 1);
	bool is_neg = false;
	if (n < 0) {
		n = -n;
		is_neg = true;
	}
	int index = max;
	{ // Unsafe block
		buf[index--] = L'\0';
	}
	for (;;) {
		if (!(n > 0)) break;
		i64 n1 = n / ((i64)(100));
		d = ((n - (n1 * ((i64)(100)))) << ((i64)(1)));
		n = n1;
		{ // Unsafe block
			buf[index--] = string_at(_const_digit_pairs, d++);
			buf[index--] = string_at(_const_digit_pairs, d);
		}
	}
	index++;
	if (d < ((i64)(20))) {
		index++;
	}
	if (is_neg) {
		index--;
		{ // Unsafe block
			buf[index] = L'-';
		}
	}
	{ // Unsafe block
		memmove(buf, buf + index, (max - index) + 1);
		return tos(buf, (max - index));
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

string u64_str(u64 nn) {
	u64 n = nn;
	u64 d = ((u64)(0U));
	if (n == 0) {
		return _SLIT("0");
	}
	int max = 20;
	byte* buf = vcalloc(max + 1);
	int index = max;
	{ // Unsafe block
		buf[index--] = L'\0';
	}
	for (;;) {
		if (!(n > 0)) break;
		u64 n1 = n / 100;
		d = ((n - (n1 * 100)) << 1);
		n = n1;
		{ // Unsafe block
			buf[index--] = string_at(_const_digit_pairs, d++);
			buf[index--] = string_at(_const_digit_pairs, d);
		}
	}
	index++;
	if (d < 20) {
		index++;
	}
	{ // Unsafe block
		memmove(buf, buf + index, (max - index) + 1);
		return tos(buf, (max - index));
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

string bool_str(bool b) {
	if (b) {
		return _SLIT("true");
	}
	return _SLIT("false");
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL string u64_to_hex(u64 nn, byte len) {
	u64 n = nn;
	Array_fixed_byte_256 buf = {0};
	buf[v_fixed_index(len, 256)] = L'\0';
	int i = 0;
	for (i = len - 1; i >= 0; i--) {
		byte d = ((byte)((n & 0xF)));
		rune x = (d < 10 ? (d + L'0') : (d + 87));
		buf[v_fixed_index(i, 256)] = x;
		n = n >> 4;
	}
	return tos(memdup(&buf[0], len + 1), len);
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL string u64_to_hex_no_leading_zeros(u64 nn, byte len) {
	u64 n = nn;
	Array_fixed_byte_256 buf = {0};
	buf[v_fixed_index(len, 256)] = L'\0';
	int i = 0;
	for (i = len - 1; i >= 0; i--) {
		byte d = ((byte)((n & 0xF)));
		rune x = (d < 10 ? (d + L'0') : (d + 87));
		buf[v_fixed_index(i, 256)] = x;
		n = n >> 4;
		if (n == 0) {
			break;
		}
	}
	int res_len = len - i;
	return tos(memdup(&buf[v_fixed_index(i, 256)], res_len + 1), res_len);
}

string byte_hex(byte nn) {
	if (nn == 0) {
		return _SLIT("00");
	}
	return u64_to_hex(nn, 2);
}

string i8_hex(i8 nn) {
	return byte_hex(((byte)(nn)));
}

string u16_hex(u16 nn) {
	if (nn == 0) {
		return _SLIT("0");
	}
	return u64_to_hex_no_leading_zeros(nn, 4);
}

string i16_hex(i16 nn) {
	return u16_hex(((u16)(nn)));
}

string u32_hex(u32 nn) {
	if (nn == 0) {
		return _SLIT("0");
	}
	return u64_to_hex_no_leading_zeros(nn, 8);
}

string int_hex(int nn) {
	return u32_hex(((u32)(nn)));
}

string int_hex2(int n) {
	return string_add(_SLIT("0x"), int_hex(n));
}

string u64_hex(u64 nn) {
	if (nn == 0) {
		return _SLIT("0");
	}
	return u64_to_hex_no_leading_zeros(nn, 16);
}

string i64_hex(i64 nn) {
	return u64_hex(((u64)(nn)));
}

string int_literal_hex(int_literal nn) {
	return u64_hex(((u64)(nn)));
}

string voidptr_str(voidptr nn) {
	return u64_hex(((u64)(nn)));
}

string byteptr_str(byteptr nn) {
	return u64_hex(((u64)(nn)));
}

string u64_hex_full(u64 nn) {
	return u64_to_hex(nn, 16);
}

string byte_str(byte b) {
	return int_str_l(((int)(b)), 7);
}

string byte_ascii_str(byte b) {
	string str = (string){.str = v_malloc(2), .len = 1};
	{ // Unsafe block
		str.str[0] = b;
		str.str[1] = L'\0';
	}
	return str;
}

string byte_str_escaped(byte b) {
	string _t64;
	
	if (b == (0)) {
		_t64 = _SLIT("`\\0`");
	}
	else if (b == (7)) {
		_t64 = _SLIT("`\\a`");
	}
	else if (b == (8)) {
		_t64 = _SLIT("`\\b`");
	}
	else if (b == (9)) {
		_t64 = _SLIT("`\\t`");
	}
	else if (b == (10)) {
		_t64 = _SLIT("`\\n`");
	}
	else if (b == (11)) {
		_t64 = _SLIT("`\\v`");
	}
	else if (b == (12)) {
		_t64 = _SLIT("`\\f`");
	}
	else if (b == (13)) {
		_t64 = _SLIT("`\\r`");
	}
	else if ((b >= 32 && b <= 126)) {
		_t64 = byte_ascii_str(b);
	}
	else {
		_t64 = string_add(_SLIT("0x"), byte_hex(b));
	}	string str = _t64;
	return str;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL bool fast_string_eq(string a, string b) {
	if (a.len != b.len) {
		return false;
	}
	{ // Unsafe block
		return memcmp(a.str, b.str, b.len) == 0;
	}
	return 0;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL DenseArray new_dense_array(int key_bytes, int value_bytes) {
	int cap = 8;
	return (DenseArray){
		.key_bytes = key_bytes,
		.value_bytes = value_bytes,
		.cap = cap,
		.len = 0,
		.deletes = 0,
		.all_deleted = 0,
		.values = v_malloc(cap * value_bytes),
		.keys = v_malloc(cap * key_bytes),
	};
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL voidptr DenseArray_key(DenseArray* d, int i) {
	return d->keys + i * d->key_bytes;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL voidptr DenseArray_value(DenseArray* d, int i) {
	return d->values + i * d->value_bytes;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL bool DenseArray_has_index(DenseArray* d, int i) {
	return d->deletes == 0 || d->all_deleted[i] == 0;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL int DenseArray_expand(DenseArray* d) {
	int old_cap = d->cap;
	int old_value_size = d->value_bytes * old_cap;
	int old_key_size = d->key_bytes * old_cap;
	if (d->cap == d->len) {
		d->cap += d->cap >> 3;
		{ // Unsafe block
			d->keys = realloc_data(d->keys, old_key_size, d->key_bytes * d->cap);
			d->values = realloc_data(d->values, old_value_size, d->value_bytes * d->cap);
			if (d->deletes != 0) {
				d->all_deleted = realloc_data(d->all_deleted, old_cap, d->cap);
				memset(d->all_deleted + d->len, 0, d->cap - d->len);
			}
		}
	}
	int push_index = d->len;
	{ // Unsafe block
		if (d->deletes != 0) {
			d->all_deleted[push_index] = 0;
		}
	}
	d->len++;
	return push_index;
}

VV_LOCAL_SYMBOL void DenseArray_zeros_to_end(DenseArray* d) {
	byte* tmp_value = v_malloc(d->value_bytes);
	byte* tmp_key = v_malloc(d->key_bytes);
	int count = 0;
	for (int i = 0; i < d->len; ++i) {
		if (DenseArray_has_index(d, i)) {
			{ // Unsafe block
				memcpy(tmp_key, DenseArray_key(d, count), d->key_bytes);
				memcpy(DenseArray_key(d, count), DenseArray_key(d, i), d->key_bytes);
				memcpy(DenseArray_key(d, i), tmp_key, d->key_bytes);
				memcpy(tmp_value, DenseArray_value(d, count), d->value_bytes);
				memcpy(DenseArray_value(d, count), DenseArray_value(d, i), d->value_bytes);
				memcpy(DenseArray_value(d, i), tmp_value, d->value_bytes);
			}
			count++;
		}
	}
	{ // Unsafe block
		v_free(tmp_value);
		v_free(tmp_key);
		d->deletes = 0;
		v_free(d->all_deleted);
	}
	d->len = count;
	int old_cap = d->cap;
	d->cap = (count < 8 ? (8) : (count));
	{ // Unsafe block
		d->values = realloc_data(d->values, d->value_bytes * old_cap, d->value_bytes * d->cap);
		d->keys = realloc_data(d->keys, d->key_bytes * old_cap, d->key_bytes * d->cap);
	}
}

// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
VV_LOCAL_SYMBOL u64 map_hash_string(voidptr pkey) {
	string key = *((string*)(pkey));
	return hash__wyhash_c(key.str, ((u64)(key.len)), 0);
}

VV_LOCAL_SYMBOL u64 map_hash_int_1(voidptr pkey) {
	return hash__wyhash64_c(*((byte*)(pkey)), 0);
}

VV_LOCAL_SYMBOL u64 map_hash_int_2(voidptr pkey) {
	return hash__wyhash64_c(*((u16*)(pkey)), 0);
}

VV_LOCAL_SYMBOL u64 map_hash_int_4(voidptr pkey) {
	return hash__wyhash64_c(*((u32*)(pkey)), 0);
}

VV_LOCAL_SYMBOL u64 map_hash_int_8(voidptr pkey) {
	return hash__wyhash64_c(*((u64*)(pkey)), 0);
}

VV_LOCAL_SYMBOL bool map_eq_string(voidptr a, voidptr b) {
	return fast_string_eq(*((string*)(a)), *((string*)(b)));
}

VV_LOCAL_SYMBOL bool map_eq_int_1(voidptr a, voidptr b) {
	return *((byte*)(a)) == *((byte*)(b));
}

VV_LOCAL_SYMBOL bool map_eq_int_2(voidptr a, voidptr b) {
	return *((u16*)(a)) == *((u16*)(b));
}

VV_LOCAL_SYMBOL bool map_eq_int_4(voidptr a, voidptr b) {
	return *((u32*)(a)) == *((u32*)(b));
}

VV_LOCAL_SYMBOL bool map_eq_int_8(voidptr a, voidptr b) {
	return *((u64*)(a)) == *((u64*)(b));
}

VV_LOCAL_SYMBOL void map_clone_string(voidptr dest, voidptr pkey) {
	{ // Unsafe block
		string s = *((string*)(pkey));
		(*((string*)(dest))) = string_clone(s);
	}
}

VV_LOCAL_SYMBOL void map_clone_int_1(voidptr dest, voidptr pkey) {
	{ // Unsafe block
		*((byte*)(dest)) = *((byte*)(pkey));
	}
}

VV_LOCAL_SYMBOL void map_clone_int_2(voidptr dest, voidptr pkey) {
	{ // Unsafe block
		*((u16*)(dest)) = *((u16*)(pkey));
	}
}

VV_LOCAL_SYMBOL void map_clone_int_4(voidptr dest, voidptr pkey) {
	{ // Unsafe block
		*((u32*)(dest)) = *((u32*)(pkey));
	}
}

VV_LOCAL_SYMBOL void map_clone_int_8(voidptr dest, voidptr pkey) {
	{ // Unsafe block
		*((u64*)(dest)) = *((u64*)(pkey));
	}
}

VV_LOCAL_SYMBOL void map_free_string(voidptr pkey) {
	string_free(&(*((string*)(pkey))));
}

VV_LOCAL_SYMBOL void map_free_nop(voidptr _t65) {
}

VV_LOCAL_SYMBOL map new_map(int key_bytes, int value_bytes, MapHashFn hash_fn, MapEqFn key_eq_fn, MapCloneFn clone_fn, MapFreeFn free_fn) {
	return new_map_2(key_bytes, value_bytes, hash_fn, key_eq_fn, clone_fn, free_fn);
}

VV_LOCAL_SYMBOL map new_map_2(int key_bytes, int value_bytes, MapHashFn hash_fn, MapEqFn key_eq_fn, MapCloneFn clone_fn, MapFreeFn free_fn) {
	int metasize = ((int)(/*SizeOf*/ sizeof(u32) * (_const_init_capicity + _const_extra_metas_inc)));
	bool has_string_keys = _us32_lt(/*SizeOf*/ sizeof(voidptr),key_bytes);
	return (map){
		.key_bytes = key_bytes,
		.value_bytes = value_bytes,
		.even_index = _const_init_even_index,
		.cached_hashbits = _const_max_cached_hashbits,
		.shift = _const_init_log_capicity,
		.key_values = new_dense_array(key_bytes, value_bytes),
		.metas = ((u32*)(vcalloc(metasize))),
		.extra_metas = _const_extra_metas_inc,
		.has_string_keys = has_string_keys,
		.hash_fn = hash_fn,
		.key_eq_fn = key_eq_fn,
		.clone_fn = clone_fn,
		.free_fn = free_fn,
		.len = 0,
	};
}

VV_LOCAL_SYMBOL map new_map_init(MapHashFn hash_fn, MapEqFn key_eq_fn, MapCloneFn clone_fn, MapFreeFn free_fn, int n, int key_bytes, int value_bytes, voidptr keys, voidptr values) {
	return new_map_init_2(hash_fn, key_eq_fn, clone_fn, free_fn, n, key_bytes, value_bytes, keys, values);
}

VV_LOCAL_SYMBOL map new_map_init_2(MapHashFn hash_fn, MapEqFn key_eq_fn, MapCloneFn clone_fn, MapFreeFn free_fn, int n, int key_bytes, int value_bytes, voidptr keys, voidptr values) {
	map out = new_map_2(key_bytes, value_bytes, hash_fn, key_eq_fn, clone_fn, free_fn);
	byte* pkey = ((byte*)(keys));
	byte* pval = ((byte*)(values));
	for (int _t66 = 0; _t66 < n; ++_t66) {
		{ // Unsafe block
			map_set_1(&out, pkey, pval);
			pkey = pkey + key_bytes;
			pval = pval + value_bytes;
		}
	}
	return out;
}

map map_move(map* m) {
	map r = *m;
	memset(m, 0, /*SizeOf*/ sizeof(map));
	return r;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL multi_return_u32_u32 map_key_to_index(map* m, voidptr pkey) {
	u64 hash = m->hash_fn(pkey);
	u64 index = (hash & m->even_index);
	u64 meta = ((((hash >> m->shift) & _const_hash_mask)) | _const_probe_inc);
	return (multi_return_u32_u32){.arg0=((u32)(index)), .arg1=((u32)(meta))};
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL multi_return_u32_u32 map_meta_less(map* m, u32 _index, u32 _metas) {
	u32 index = _index;
	u32 meta = _metas;
	for (;;) {
		if (!(meta < m->metas[index])) break;
		index += 2;
		meta += _const_probe_inc;
	}
	return (multi_return_u32_u32){.arg0=index, .arg1=meta};
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL void map_meta_greater(map* m, u32 _index, u32 _metas, u32 kvi) {
	u32 meta = _metas;
	u32 index = _index;
	u32 kv_index = kvi;
	for (;;) {
		if (!(m->metas[index] != 0)) break;
		if (meta > m->metas[index]) {
			{ // Unsafe block
				u32 tmp_meta = m->metas[index];
				m->metas[index] = meta;
				meta = tmp_meta;
				u32 tmp_index = m->metas[index + 1];
				m->metas[index + 1] = kv_index;
				kv_index = tmp_index;
			}
		}
		index += 2;
		meta += _const_probe_inc;
	}
	{ // Unsafe block
		m->metas[index] = meta;
		m->metas[index + 1] = kv_index;
	}
	u32 probe_count = (meta >> _const_hashbits) - 1;
	map_ensure_extra_metas(m, probe_count);
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL void map_ensure_extra_metas(map* m, u32 probe_count) {
	if ((probe_count << 1) == m->extra_metas) {
		u32 size_of_u32 = /*SizeOf*/ sizeof(u32);
		u32 old_mem_size = (m->even_index + 2 + m->extra_metas);
		m->extra_metas += _const_extra_metas_inc;
		u32 mem_size = (m->even_index + 2 + m->extra_metas);
		{ // Unsafe block
			byte* x = realloc_data(((byte*)(m->metas)), ((int)(size_of_u32 * old_mem_size)), ((int)(size_of_u32 * mem_size)));
			m->metas = ((u32*)(x));
			memset(m->metas + mem_size - _const_extra_metas_inc, 0, ((int)(/*SizeOf*/ sizeof(u32) * _const_extra_metas_inc)));
		}
		if (probe_count == 252) {
			v_panic(_SLIT("Probe overflow"));
		}
	}
}

VV_LOCAL_SYMBOL void map_set(map* m, voidptr key, voidptr value) {
	map_set_1(m, key, value);
}

VV_LOCAL_SYMBOL void map_set_1(map* m, voidptr key, voidptr value) {
	f32 load_factor = ((f32)(m->len << 1)) / ((f32)(m->even_index));
	if (load_factor > _const_max_load_factor) {
		map_expand(m);
	}
	multi_return_u32_u32 mr_13287 = map_key_to_index(m, key);
	u32 index = mr_13287.arg0;
	u32 meta = mr_13287.arg1;
	multi_return_u32_u32 mr_13323 = map_meta_less(m, index, meta);
	index = mr_13323.arg0;
	meta = mr_13323.arg1;
	for (;;) {
		if (!(meta == m->metas[index])) break;
		int kv_index = ((int)(m->metas[index + 1]));
		voidptr pkey = DenseArray_key(&m->key_values, kv_index);
		if (m->key_eq_fn(key, pkey)) {
			{ // Unsafe block
				voidptr pval = DenseArray_value(&m->key_values, kv_index);
				memcpy(pval, value, m->value_bytes);
			}
			return;
		}
		index += 2;
		meta += _const_probe_inc;
	}
	int kv_index = DenseArray_expand(&m->key_values);
	{ // Unsafe block
		voidptr pkey = DenseArray_key(&m->key_values, kv_index);
		voidptr pvalue = DenseArray_value(&m->key_values, kv_index);
		m->clone_fn(pkey, key);
		memcpy(((byte*)(pvalue)), value, m->value_bytes);
	}
	map_meta_greater(m, index, meta, ((u32)(kv_index)));
	m->len++;
}

VV_LOCAL_SYMBOL void map_expand(map* m) {
	u32 old_cap = m->even_index;
	m->even_index = ((m->even_index + 2) << 1) - 2;
	if (m->cached_hashbits == 0) {
		m->shift += _const_max_cached_hashbits;
		m->cached_hashbits = _const_max_cached_hashbits;
		map_rehash(m);
	} else {
		map_cached_rehash(m, old_cap);
		m->cached_hashbits--;
	}
}

VV_LOCAL_SYMBOL void map_rehash(map* m) {
	u32 meta_bytes = /*SizeOf*/ sizeof(u32) * (m->even_index + 2 + m->extra_metas);
	{ // Unsafe block
		byte* x = v_realloc(((byte*)(m->metas)), ((int)(meta_bytes)));
		m->metas = ((u32*)(x));
		memset(m->metas, 0, meta_bytes);
	}
	for (int i = 0; i < m->key_values.len; i++) {
		if (!DenseArray_has_index(&m->key_values, i)) {
			continue;
		}
		voidptr pkey = DenseArray_key(&m->key_values, i);
		multi_return_u32_u32 mr_14988 = map_key_to_index(m, pkey);
		u32 index = mr_14988.arg0;
		u32 meta = mr_14988.arg1;
		multi_return_u32_u32 mr_15026 = map_meta_less(m, index, meta);
		index = mr_15026.arg0;
		meta = mr_15026.arg1;
		map_meta_greater(m, index, meta, ((u32)(i)));
	}
}

VV_LOCAL_SYMBOL void map_cached_rehash(map* m, u32 old_cap) {
	u32* old_metas = m->metas;
	int metasize = ((int)(/*SizeOf*/ sizeof(u32) * (m->even_index + 2 + m->extra_metas)));
	m->metas = ((u32*)(vcalloc(metasize)));
	u32 old_extra_metas = m->extra_metas;
	for (u32 i = ((u32)(0U)); i <= old_cap + old_extra_metas; i += 2) {
		if (old_metas[i] == 0) {
			continue;
		}
		u32 old_meta = old_metas[i];
		u32 old_probe_count = ((old_meta >> _const_hashbits) - 1) << 1;
		u32 old_index = ((i - old_probe_count) & (m->even_index >> 1));
		u32 index = (((old_index | (old_meta << m->shift))) & m->even_index);
		u32 meta = (((old_meta & _const_hash_mask)) | _const_probe_inc);
		multi_return_u32_u32 mr_15825 = map_meta_less(m, index, meta);
		index = mr_15825.arg0;
		meta = mr_15825.arg1;
		u32 kv_index = old_metas[i + 1];
		map_meta_greater(m, index, meta, kv_index);
	}
	v_free(old_metas);
}

VV_LOCAL_SYMBOL voidptr map_get_and_set(map* m, voidptr key, voidptr zero) {
	return map_get_and_set_1(m, key, zero);
}

VV_LOCAL_SYMBOL voidptr map_get_and_set_1(map* m, voidptr key, voidptr zero) {
	for (;;) {
		multi_return_u32_u32 mr_16377 = map_key_to_index(m, key);
		u32 index = mr_16377.arg0;
		u32 meta = mr_16377.arg1;
		for (;;) {
			if (meta == m->metas[index]) {
				int kv_index = ((int)(m->metas[index + 1]));
				voidptr pkey = DenseArray_key(&m->key_values, kv_index);
				if (m->key_eq_fn(key, pkey)) {
					voidptr pval = DenseArray_value(&m->key_values, kv_index);
					return ((byte*)(pval));
				}
			}
			index += 2;
			meta += _const_probe_inc;
			if (meta > m->metas[index]) {
				break;
			}
		}
		map_set_1(m, key, zero);
	}
	// assert
	if (!(false)) {
		VAssertMetaInfo v_assert_meta_info__t67 = {0};
		v_assert_meta_info__t67.fpath = _SLIT("/home/runner/work/v/v/vlib/builtin/map.v");
		v_assert_meta_info__t67.line_nr = 574;
		v_assert_meta_info__t67.fn_name = _SLIT("get_and_set_1");
		v_assert_meta_info__t67.src = _SLIT("false");
		__print_assert_failure(&v_assert_meta_info__t67);
		v_panic(_SLIT("Assertion failed..."));
	}
	return ((voidptr)(0));
}

VV_LOCAL_SYMBOL voidptr map_get(map* m, voidptr key, voidptr zero) {
	return map_get_1(m, key, zero);
}

VV_LOCAL_SYMBOL voidptr map_get_1(map* m, voidptr key, voidptr zero) {
	multi_return_u32_u32 mr_17203 = map_key_to_index(m, key);
	u32 index = mr_17203.arg0;
	u32 meta = mr_17203.arg1;
	for (;;) {
		if (meta == m->metas[index]) {
			int kv_index = ((int)(m->metas[index + 1]));
			voidptr pkey = DenseArray_key(&m->key_values, kv_index);
			if (m->key_eq_fn(key, pkey)) {
				voidptr pval = DenseArray_value(&m->key_values, kv_index);
				return ((byte*)(pval));
			}
		}
		index += 2;
		meta += _const_probe_inc;
		if (meta > m->metas[index]) {
			break;
		}
	}
	return zero;
}

VV_LOCAL_SYMBOL voidptr map_get_check(map* m, voidptr key) {
	return map_get_1_check(m, key);
}

VV_LOCAL_SYMBOL voidptr map_get_1_check(map* m, voidptr key) {
	multi_return_u32_u32 mr_17947 = map_key_to_index(m, key);
	u32 index = mr_17947.arg0;
	u32 meta = mr_17947.arg1;
	for (;;) {
		if (meta == m->metas[index]) {
			int kv_index = ((int)(m->metas[index + 1]));
			voidptr pkey = DenseArray_key(&m->key_values, kv_index);
			if (m->key_eq_fn(key, pkey)) {
				voidptr pval = DenseArray_value(&m->key_values, kv_index);
				return ((byte*)(pval));
			}
		}
		index += 2;
		meta += _const_probe_inc;
		if (meta > m->metas[index]) {
			break;
		}
	}
	return 0;
}

VV_LOCAL_SYMBOL bool map_exists(map* m, voidptr key) {
	return map_exists_1(m, key);
}

VV_LOCAL_SYMBOL bool map_exists_1(map* m, voidptr key) {
	multi_return_u32_u32 mr_18527 = map_key_to_index(m, key);
	u32 index = mr_18527.arg0;
	u32 meta = mr_18527.arg1;
	for (;;) {
		if (meta == m->metas[index]) {
			int kv_index = ((int)(m->metas[index + 1]));
			voidptr pkey = DenseArray_key(&m->key_values, kv_index);
			if (m->key_eq_fn(key, pkey)) {
				return true;
			}
		}
		index += 2;
		meta += _const_probe_inc;
		if (meta > m->metas[index]) {
			break;
		}
	}
	return false;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL void DenseArray_delete(DenseArray* d, int i) {
	if (d->deletes == 0) {
		d->all_deleted = vcalloc(d->cap);
	}
	d->deletes++;
	{ // Unsafe block
		d->all_deleted[i] = 1;
	}
}

// Attr: [unsafe]
void map_delete(map* m, voidptr key) {
	multi_return_u32_u32 mr_19156 = map_key_to_index(m, key);
	u32 index = mr_19156.arg0;
	u32 meta = mr_19156.arg1;
	multi_return_u32_u32 mr_19192 = map_meta_less(m, index, meta);
	index = mr_19192.arg0;
	meta = mr_19192.arg1;
	for (;;) {
		if (!(meta == m->metas[index])) break;
		int kv_index = ((int)(m->metas[index + 1]));
		voidptr pkey = DenseArray_key(&m->key_values, kv_index);
		if (m->key_eq_fn(key, pkey)) {
			for (;;) {
				if (!((m->metas[index + 2] >> _const_hashbits) > 1)) break;
				{ // Unsafe block
					m->metas[index] = m->metas[index + 2] - _const_probe_inc;
					m->metas[index + 1] = m->metas[index + 3];
				}
				index += 2;
			}
			m->len--;
			DenseArray_delete(&m->key_values, kv_index);
			{ // Unsafe block
				m->metas[index] = 0;
				m->free_fn(pkey);
				memset(pkey, 0, m->key_bytes);
			}
			if (m->key_values.len <= 32) {
				return;
			}
			if (_us32_ge(m->key_values.deletes,(m->key_values.len >> 1))) {
				DenseArray_zeros_to_end(&m->key_values);
				map_rehash(m);
			}
			return;
		}
		index += 2;
		meta += _const_probe_inc;
	}
}

VV_LOCAL_SYMBOL array map_keys(map* m) {
	return map_keys_1(m);
}

VV_LOCAL_SYMBOL array map_keys_1(map* m) {
	array keys = __new_array(m->len, 0, m->key_bytes);
	byte* item = ((byte*)(keys.data));
	if (m->key_values.deletes == 0) {
		for (int i = 0; i < m->key_values.len; i++) {
			{ // Unsafe block
				voidptr pkey = DenseArray_key(&m->key_values, i);
				m->clone_fn(item, pkey);
				item = item + m->key_bytes;
			}
		}
		return keys;
	}
	for (int i = 0; i < m->key_values.len; i++) {
		if (!DenseArray_has_index(&m->key_values, i)) {
			continue;
		}
		{ // Unsafe block
			voidptr pkey = DenseArray_key(&m->key_values, i);
			m->clone_fn(item, pkey);
			item = item + m->key_bytes;
		}
	}
	return keys;
}

// Attr: [unsafe]
VV_LOCAL_SYMBOL DenseArray DenseArray_clone(DenseArray* d) {
	DenseArray res = (DenseArray){
		.key_bytes = d->key_bytes,
		.value_bytes = d->value_bytes,
		.cap = d->cap,
		.len = d->len,
		.deletes = d->deletes,
		.all_deleted = 0,
		.values = 0,
		.keys = 0,
	};
	{ // Unsafe block
		if (d->deletes != 0) {
			res.all_deleted = memdup(d->all_deleted, d->cap);
		}
		res.keys = memdup(d->keys, d->cap * d->key_bytes);
		res.values = memdup(d->values, d->cap * d->value_bytes);
	}
	return res;
}

// Attr: [unsafe]
map map_clone(map* m) {
	int metasize = ((int)(/*SizeOf*/ sizeof(u32) * (m->even_index + 2 + m->extra_metas)));
	map res = (map){
		.key_bytes = m->key_bytes,
		.value_bytes = m->value_bytes,
		.even_index = m->even_index,
		.cached_hashbits = m->cached_hashbits,
		.shift = m->shift,
		.key_values = DenseArray_clone(&m->key_values),
		.metas = ((u32*)(v_malloc(metasize))),
		.extra_metas = m->extra_metas,
		.has_string_keys = m->has_string_keys,
		.hash_fn = m->hash_fn,
		.key_eq_fn = m->key_eq_fn,
		.clone_fn = m->clone_fn,
		.free_fn = m->free_fn,
		.len = m->len,
	};
	memcpy(res.metas, m->metas, metasize);
	if (!m->has_string_keys) {
		return res;
	}
	for (int i = 0; i < m->key_values.len; ++i) {
		if (!DenseArray_has_index(&m->key_values, i)) {
			continue;
		}
		m->clone_fn(DenseArray_key(&res.key_values, i), DenseArray_key(&m->key_values, i));
	}
	return res;
}

// Attr: [unsafe]
void map_free(map* m) {
	v_free(m->metas);
	if (m->key_values.deletes == 0) {
		for (int i = 0; i < m->key_values.len; i++) {
			{ // Unsafe block
				voidptr pkey = DenseArray_key(&m->key_values, i);
				m->free_fn(pkey);
			}
		}
	} else {
		for (int i = 0; i < m->key_values.len; i++) {
			if (!DenseArray_has_index(&m->key_values, i)) {
				continue;
			}
			{ // Unsafe block
				voidptr pkey = DenseArray_key(&m->key_values, i);
				m->free_fn(pkey);
			}
		}
		v_free(m->key_values.all_deleted);
	}
	{ // Unsafe block
		v_free(m->key_values.keys);
		v_free(m->key_values.values);
	}
}

string IError_str(IError err) {
	return ((err._typ == _IError_None___index) ? (_SLIT("none")) : (err._typ == _IError_Error_index) ? ((err._Error)->msg) : (_STR("%.*s\000: %.*s", 2, tos3( /* IError */ v_typeof_interface_IError( (err)._typ )), (*(err.msg)))));
}

VV_LOCAL_SYMBOL string None___str(None__ _t68) {
	return _SLIT("none");
}

// Attr: [inline]
inline IError v_error(string message) {
	return I_Error_to_Interface_IError((Error*)memdup(&(Error){.msg = message,.code = 0,}, sizeof(Error)));
}

// Attr: [inline]
inline IError error_with_code(string message, int code) {
	return I_Error_to_Interface_IError((Error*)memdup(&(Error){.msg = message,.code = code,}, sizeof(Error)));
}

VV_LOCAL_SYMBOL void opt_ok(voidptr data, Option* option, int size) {
	{ // Unsafe block
		*option = (Option){.state = 0,.err = _const_none__,};
		memcpy(((byte*)(&option->err)) + /*SizeOf*/ sizeof(IError), data, size);
	}
}

// Attr: [unsafe]
void Error_free(Error* e) {
	string_free(&e->msg);
}

// Attr: [unsafe]
void None___free(None__* n) {
	string_free(&n->msg);
}

// Attr: [unsafe]
void IError_free(IError* ie) {
	{ // Unsafe block
		string_free(&(*(ie->msg)));
		IError* cie = ((IError*)(ie));
		v_free(cie->_object);
	}
}

string rune_str(rune c) {
	return utf32_to_str(((u32)(c)));
}

bool byte_is_capital(byte c) {
	return c >= L'A' && c <= L'Z';
}

Array_byte Array_byte_clone(Array_byte b) {
	Array_byte res = __new_array_with_default(b.len, 0, sizeof(byte), 0);
	for (int i = 0; i < b.len; ++i) {
		array_set(&res, i, &(byte[]) { (*(byte*)/*ee elem_typ */array_get(b, i)) });
	}
	return res;
}

string Array_byte_bytestr(Array_byte b) {
	return bytes2string(b);
}

VV_LOCAL_SYMBOL string bytes2string(Array_byte b) {
	{ // Unsafe block
		byte* buf = v_malloc(b.len + 1);
		memcpy(buf, b.data, b.len);
		buf[b.len] = 0;
		return tos(buf, b.len);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

VV_LOCAL_SYMBOL SortedMap new_sorted_map(int n, int value_bytes) {
	return (SortedMap){.value_bytes = value_bytes,.root = new_node(),.len = 0,};
}

VV_LOCAL_SYMBOL SortedMap new_sorted_map_init(int n, int value_bytes, string* keys, voidptr values) {
	SortedMap out = new_sorted_map(n, value_bytes);
	for (int i = 0; i < n; ++i) {
		SortedMap_set(&out, keys[i], ((byte*)(values)) + i * value_bytes);
	}
	return out;
}

VV_LOCAL_SYMBOL mapnode* new_node(void) {
	return (mapnode*)memdup(&(mapnode){.children = 0,.len = 0,.keys = {0},.values = {0},}, sizeof(mapnode));
}

VV_LOCAL_SYMBOL void SortedMap_set(SortedMap* m, string key, voidptr value) {
	mapnode* node = m->root;
	int child_index = 0;
	mapnode* parent = ((mapnode*)(0));
	for (;;) {
		if (node->len == _const_max_len) {
			if (isnil(parent)) {
				parent = new_node();
				m->root = parent;
			}
			mapnode_split_child(parent, child_index, node);
			if (string_eq(key, parent->keys[v_fixed_index(child_index, 11)])) {
				memcpy(parent->values[v_fixed_index(child_index, 11)], value, m->value_bytes);
				return;
			}
			if (string_lt(key, parent->keys[v_fixed_index(child_index, 11)])) {
				node = ((mapnode*)(parent->children[child_index]));
			} else {
				node = ((mapnode*)(parent->children[child_index + 1]));
			}
		}
		int i = 0;
		for (;;) {
			if (!(i < node->len && string_gt(key, node->keys[v_fixed_index(i, 11)]))) break;
			i++;
		}
		if (i != node->len && string_eq(key, node->keys[v_fixed_index(i, 11)])) {
			memcpy(node->values[v_fixed_index(i, 11)], value, m->value_bytes);
			return;
		}
		if (isnil(node->children)) {
			int j = node->len - 1;
			for (;;) {
				if (!(j >= 0 && string_lt(key, node->keys[v_fixed_index(j, 11)]))) break;
				node->keys[v_fixed_index(j + 1, 11)] = node->keys[v_fixed_index(j, 11)];
				node->values[v_fixed_index(j + 1, 11)] = node->values[v_fixed_index(j, 11)];
				j--;
			}
			node->keys[v_fixed_index(j + 1, 11)] = key;
			{ // Unsafe block
				node->values[v_fixed_index(j + 1, 11)] = v_malloc(m->value_bytes);
				memcpy(node->values[v_fixed_index(j + 1, 11)], value, m->value_bytes);
			}
			node->len++;
			m->len++;
			return;
		}
		parent = node;
		child_index = i;
		node = ((mapnode*)(node->children[child_index]));
	}
}

VV_LOCAL_SYMBOL void mapnode_split_child(mapnode* n, int child_index, mapnode* y) {
	mapnode* z = new_node();
	z->len = _const_mid_index;
	y->len = _const_mid_index;
	for (int j = _const_mid_index - 1; j >= 0; j--) {
		z->keys[v_fixed_index(j, 11)] = y->keys[v_fixed_index(j + _const_degree, 11)];
		z->values[v_fixed_index(j, 11)] = y->values[v_fixed_index(j + _const_degree, 11)];
	}
	if (!isnil(y->children)) {
		z->children = ((voidptr*)(v_malloc(((int)(_const_children_bytes)))));
		for (int jj = _const_degree - 1; jj >= 0; jj--) {
			{ // Unsafe block
				z->children[jj] = y->children[jj + _const_degree];
			}
		}
	}
	{ // Unsafe block
		if (isnil(n->children)) {
			n->children = ((voidptr*)(v_malloc(((int)(_const_children_bytes)))));
		}
		n->children[n->len + 1] = n->children[n->len];
	}
	for (int j = n->len; j > child_index; j--) {
		n->keys[v_fixed_index(j, 11)] = n->keys[v_fixed_index(j - 1, 11)];
		n->values[v_fixed_index(j, 11)] = n->values[v_fixed_index(j - 1, 11)];
		{ // Unsafe block
			n->children[j] = n->children[j - 1];
		}
	}
	n->keys[v_fixed_index(child_index, 11)] = y->keys[v_fixed_index(_const_mid_index, 11)];
	n->values[v_fixed_index(child_index, 11)] = y->values[v_fixed_index(_const_mid_index, 11)];
	{ // Unsafe block
		n->children[child_index] = ((voidptr)(y));
		n->children[child_index + 1] = ((voidptr)(z));
	}
	n->len++;
}

VV_LOCAL_SYMBOL bool SortedMap_get(SortedMap m, string key, voidptr out) {
	mapnode* node = m.root;
	for (;;) {
		int i = node->len - 1;
		for (;;) {
			if (!(i >= 0 && string_lt(key, node->keys[v_fixed_index(i, 11)]))) break;
			i--;
		}
		if (i != -1 && string_eq(key, node->keys[v_fixed_index(i, 11)])) {
			memcpy(out, node->values[v_fixed_index(i, 11)], m.value_bytes);
			return true;
		}
		if (isnil(node->children)) {
			break;
		}
		node = ((mapnode*)(node->children[i + 1]));
	}
	return false;
}

VV_LOCAL_SYMBOL bool SortedMap_exists(SortedMap m, string key) {
	if (isnil(m.root)) {
		return false;
	}
	mapnode* node = m.root;
	for (;;) {
		int i = node->len - 1;
		for (;;) {
			if (!(i >= 0 && string_lt(key, node->keys[v_fixed_index(i, 11)]))) break;
			i--;
		}
		if (i != -1 && string_eq(key, node->keys[v_fixed_index(i, 11)])) {
			return true;
		}
		if (isnil(node->children)) {
			break;
		}
		node = ((mapnode*)(node->children[i + 1]));
	}
	return false;
}

VV_LOCAL_SYMBOL int mapnode_find_key(mapnode* n, string k) {
	int idx = 0;
	for (;;) {
		if (!(idx < n->len && string_lt(n->keys[v_fixed_index(idx, 11)], k))) break;
		idx++;
	}
	return idx;
}

VV_LOCAL_SYMBOL bool mapnode_remove_key(mapnode* n, string k) {
	int idx = mapnode_find_key(n, k);
	if (idx < n->len && string_eq(n->keys[v_fixed_index(idx, 11)], k)) {
		if (isnil(n->children)) {
			mapnode_remove_from_leaf(n, idx);
		} else {
			mapnode_remove_from_non_leaf(n, idx);
		}
		return true;
	} else {
		if (isnil(n->children)) {
			return false;
		}
		bool flag = (idx == n->len ? (true) : (false));
		if (((mapnode*)(n->children[idx]))->len < _const_degree) {
			mapnode_fill(n, idx);
		}
		mapnode* node = ((mapnode*)(0));
		if (flag && idx > n->len) {
			node = ((mapnode*)(n->children[idx - 1]));
		} else {
			node = ((mapnode*)(n->children[idx]));
		}
		return mapnode_remove_key(node, k);
	}
	return 0;
}

VV_LOCAL_SYMBOL void mapnode_remove_from_leaf(mapnode* n, int idx) {
	for (int i = idx + 1; i < n->len; i++) {
		n->keys[v_fixed_index(i - 1, 11)] = n->keys[v_fixed_index(i, 11)];
		n->values[v_fixed_index(i - 1, 11)] = n->values[v_fixed_index(i, 11)];
	}
	n->len--;
}

VV_LOCAL_SYMBOL void mapnode_remove_from_non_leaf(mapnode* n, int idx) {
	string k = n->keys[v_fixed_index(idx, 11)];
	if (((mapnode*)(n->children[idx]))->len >= _const_degree) {
		mapnode* current = ((mapnode*)(n->children[idx]));
		for (;;) {
			if (!(!isnil(current->children))) break;
			current = ((mapnode*)(current->children[current->len]));
		}
		string predecessor = current->keys[v_fixed_index(current->len - 1, 11)];
		n->keys[v_fixed_index(idx, 11)] = predecessor;
		n->values[v_fixed_index(idx, 11)] = current->values[v_fixed_index(current->len - 1, 11)];
		mapnode* node = ((mapnode*)(n->children[idx]));
		mapnode_remove_key(node, predecessor);
	} else if (((mapnode*)(n->children[idx + 1]))->len >= _const_degree) {
		mapnode* current = ((mapnode*)(n->children[idx + 1]));
		for (;;) {
			if (!(!isnil(current->children))) break;
			current = ((mapnode*)(current->children[0]));
		}
		string successor = current->keys[0];
		n->keys[v_fixed_index(idx, 11)] = successor;
		n->values[v_fixed_index(idx, 11)] = current->values[0];
		mapnode* node = ((mapnode*)(n->children[idx + 1]));
		mapnode_remove_key(node, successor);
	} else {
		mapnode_merge(n, idx);
		mapnode* node = ((mapnode*)(n->children[idx]));
		mapnode_remove_key(node, k);
	}
}

VV_LOCAL_SYMBOL void mapnode_fill(mapnode* n, int idx) {
	if (idx != 0 && ((mapnode*)(n->children[idx - 1]))->len >= _const_degree) {
		mapnode_borrow_from_prev(n, idx);
	} else if (idx != n->len && ((mapnode*)(n->children[idx + 1]))->len >= _const_degree) {
		mapnode_borrow_from_next(n, idx);
	} else if (idx != n->len) {
		mapnode_merge(n, idx);
	} else {
		mapnode_merge(n, idx - 1);
	}
}

VV_LOCAL_SYMBOL void mapnode_borrow_from_prev(mapnode* n, int idx) {
	mapnode* child = ((mapnode*)(n->children[idx]));
	mapnode* sibling = ((mapnode*)(n->children[idx - 1]));
	for (int i = child->len - 1; i >= 0; i--) {
		child->keys[v_fixed_index(i + 1, 11)] = child->keys[v_fixed_index(i, 11)];
		child->values[v_fixed_index(i + 1, 11)] = child->values[v_fixed_index(i, 11)];
	}
	if (!isnil(child->children)) {
		for (int i = child->len; i >= 0; i--) {
			{ // Unsafe block
				child->children[i + 1] = child->children[i];
			}
		}
	}
	child->keys[0] = n->keys[v_fixed_index(idx - 1, 11)];
	child->values[0] = n->values[v_fixed_index(idx - 1, 11)];
	if (!isnil(child->children)) {
		{ // Unsafe block
			child->children[0] = sibling->children[sibling->len];
		}
	}
	n->keys[v_fixed_index(idx - 1, 11)] = sibling->keys[v_fixed_index(sibling->len - 1, 11)];
	n->values[v_fixed_index(idx - 1, 11)] = sibling->values[v_fixed_index(sibling->len - 1, 11)];
	child->len++;
	sibling->len--;
}

VV_LOCAL_SYMBOL void mapnode_borrow_from_next(mapnode* n, int idx) {
	mapnode* child = ((mapnode*)(n->children[idx]));
	mapnode* sibling = ((mapnode*)(n->children[idx + 1]));
	child->keys[v_fixed_index(child->len, 11)] = n->keys[v_fixed_index(idx, 11)];
	child->values[v_fixed_index(child->len, 11)] = n->values[v_fixed_index(idx, 11)];
	if (!isnil(child->children)) {
		{ // Unsafe block
			child->children[child->len + 1] = sibling->children[0];
		}
	}
	n->keys[v_fixed_index(idx, 11)] = sibling->keys[0];
	n->values[v_fixed_index(idx, 11)] = sibling->values[0];
	for (int i = 1; i < sibling->len; i++) {
		sibling->keys[v_fixed_index(i - 1, 11)] = sibling->keys[v_fixed_index(i, 11)];
		sibling->values[v_fixed_index(i - 1, 11)] = sibling->values[v_fixed_index(i, 11)];
	}
	if (!isnil(sibling->children)) {
		for (int i = 1; i <= sibling->len; i++) {
			{ // Unsafe block
				sibling->children[i - 1] = sibling->children[i];
			}
		}
	}
	child->len++;
	sibling->len--;
}

VV_LOCAL_SYMBOL void mapnode_merge(mapnode* n, int idx) {
	mapnode* child = ((mapnode*)(n->children[idx]));
	mapnode* sibling = ((mapnode*)(n->children[idx + 1]));
	child->keys[v_fixed_index(_const_mid_index, 11)] = n->keys[v_fixed_index(idx, 11)];
	child->values[v_fixed_index(_const_mid_index, 11)] = n->values[v_fixed_index(idx, 11)];
	for (int i = 0; i < sibling->len; ++i) {
		child->keys[v_fixed_index(i + _const_degree, 11)] = sibling->keys[v_fixed_index(i, 11)];
		child->values[v_fixed_index(i + _const_degree, 11)] = sibling->values[v_fixed_index(i, 11)];
	}
	if (!isnil(child->children)) {
		for (int i = 0; i <= sibling->len; i++) {
			{ // Unsafe block
				child->children[i + _const_degree] = sibling->children[i];
			}
		}
	}
	for (int i = idx + 1; i < n->len; i++) {
		n->keys[v_fixed_index(i - 1, 11)] = n->keys[v_fixed_index(i, 11)];
		n->values[v_fixed_index(i - 1, 11)] = n->values[v_fixed_index(i, 11)];
	}
	for (int i = idx + 2; i <= n->len; i++) {
		{ // Unsafe block
			n->children[i - 1] = n->children[i];
		}
	}
	child->len += sibling->len + 1;
	n->len--;
}

void SortedMap_delete(SortedMap* m, string key) {
	if (m->root->len == 0) {
		return;
	}
	bool removed = mapnode_remove_key(m->root, key);
	if (removed) {
		m->len--;
	}
	if (m->root->len == 0) {
		if (isnil(m->root->children)) {
			return;
		} else {
			m->root = ((mapnode*)(m->root->children[0]));
		}
	}
}

VV_LOCAL_SYMBOL int mapnode_subkeys(mapnode* n, Array_string* keys, int at) {
	int position = at;
	if (!isnil(n->children)) {
		for (int i = 0; i < n->len; ++i) {
			mapnode* child = ((mapnode*)(n->children[i]));
			position += mapnode_subkeys(child, keys, position);
			array_set(keys, position, &(string[]) { n->keys[v_fixed_index(i, 11)] });
			position++;
		}
		mapnode* child = ((mapnode*)(n->children[n->len]));
		position += mapnode_subkeys(child, keys, position);
	} else {
		for (int i = 0; i < n->len; ++i) {
			array_set(keys, position + i, &(string[]) { n->keys[v_fixed_index(i, 11)] });
		}
		position += n->len;
	}
	return position - at;
}

Array_string SortedMap_keys(SortedMap* m) {
	Array_string keys = __new_array_with_default(m->len, 0, sizeof(string), &(string[]){_SLIT("")});
	if (isnil(m->root) || m->root->len == 0) {
		return keys;
	}
	mapnode_subkeys(m->root, &/*arr*/keys, 0);
	return keys;
}

VV_LOCAL_SYMBOL void mapnode_free(mapnode* n) {
	println(_SLIT("TODO"));
}

void SortedMap_free(SortedMap* m) {
	if (isnil(m->root)) {
		return;
	}
	mapnode_free(m->root);
}

void SortedMap_print(SortedMap m) {
	println(_SLIT("TODO"));
}

// Attr: [unsafe]
int vstrlen(byte* s) {
	return strlen(((char*)(s)));
}

// Attr: [unsafe]
string tos(byte* s, int len) {
	if (s == 0) {
		v_panic(_SLIT("tos(): nil string"));
	}
	return (string){.str = s, .len = len};
}

// Attr: [unsafe]
string tos_clone(byte* s) {
	return string_clone(tos2(s));
}

// Attr: [unsafe]
string tos2(byte* s) {
	if (s == 0) {
		v_panic(_SLIT("tos2: nil string"));
	}
	return (string){.str = s, .len = vstrlen(s)};
}

// Attr: [unsafe]
string tos3(char* s) {
	if (s == 0) {
		v_panic(_SLIT("tos3: nil string"));
	}
	return (string){.str = ((byte*)(s)), .len = strlen(s)};
}

// Attr: [unsafe]
string tos4(byte* s) {
	if (s == 0) {
		return _SLIT("");
	}
	return tos2(s);
}

// Attr: [unsafe]
string tos5(char* s) {
	if (s == 0) {
		return _SLIT("");
	}
	return tos3(s);
}

// Attr: [deprecated]
string tos_lit(char* s) {
	eprintln(_SLIT("warning: `tos_lit` has been deprecated, use `_SLIT` instead"));
	return (string){.str = ((byte*)(s)), .len = strlen(s), .is_lit = 1};
}

// Attr: [unsafe]
string byte_vstring(byte* bp) {
	return (string){.str = bp, .len = strlen(((char*)(bp)))};
}

// Attr: [unsafe]
string byte_vstring_with_len(byte* bp, int len) {
	return (string){.str = bp, .len = len, .is_lit = 0};
}

// Attr: [unsafe]
string char_vstring(char* cp) {
	return (string){.str = ((byte*)(cp)), .len = strlen(cp), .is_lit = 0};
}

// Attr: [unsafe]
string char_vstring_with_len(char* cp, int len) {
	return (string){.str = ((byte*)(cp)), .len = len, .is_lit = 0};
}

// Attr: [unsafe]
string byte_vstring_literal(byte* bp) {
	return (string){.str = bp, .len = strlen(((char*)(bp))), .is_lit = 1};
}

// Attr: [unsafe]
string byte_vstring_literal_with_len(byte* bp, int len) {
	return (string){.str = bp, .len = len, .is_lit = 1};
}

// Attr: [unsafe]
string char_vstring_literal(char* cp) {
	return (string){.str = ((byte*)(cp)), .len = strlen(cp), .is_lit = 1};
}

// Attr: [unsafe]
string char_vstring_literal_with_len(char* cp, int len) {
	return (string){.str = ((byte*)(cp)), .len = len, .is_lit = 1};
}

VV_LOCAL_SYMBOL string string_clone_static(string a) {
	return string_clone(a);
}

string string_clone(string a) {
	if ((a).len == 0) {
		return _SLIT("");
	}
	string b = (string){.str = v_malloc(a.len + 1), .len = a.len};
	{ // Unsafe block
		memcpy(b.str, a.str, a.len);
		b.str[a.len] = L'\0';
	}
	return b;
}

// Attr: [unsafe]
string cstring_to_vstring(char* cstr) {
	return tos_clone(((byte*)(cstr)));
}

string string_replace_once(string s, string rep, string with) {
	int idx = string_index_(s, rep);
	if (idx == -1) {
		return string_clone(s);
	}
	return string_add(string_add(string_substr(s, 0, idx), with), string_substr(s, idx + rep.len, s.len));
}

string string_replace(string s, string rep, string with) {
bool string_replace_defer_0 = false;
	if (s.len == 0 || rep.len == 0) {
		return string_clone(s);
	}
	Array_int idxs = __new_array_with_default(0, 0, sizeof(int), 0);
	string_replace_defer_0 = true;
	int idx = 0;
	for (;;) {
		idx = string_index_after(s, rep, idx);
		if (idx == -1) {
			break;
		}
		array_push(&idxs, _MOV((int[]){ idx }));
		idx += rep.len;
	}
	if (idxs.len == 0) {
		// Defer begin
		if (string_replace_defer_0 == true) {
			array_free(&idxs);
		}
		// Defer end
		return string_clone(s);
	}
	int new_len = s.len + idxs.len * (with.len - rep.len);
	byte* b = v_malloc(new_len + 1);
	int idx_pos = 0;
	int cur_idx = (*(int*)/*ee elem_typ */array_get(idxs, idx_pos));
	int b_i = 0;
	for (int i = 0; i < s.len; i++) {
		if (i == cur_idx) {
			for (int j = 0; j < with.len; ++j) {
				{ // Unsafe block
					b[b_i] = string_at(with, j);
				}
				b_i++;
			}
			i += rep.len - 1;
			idx_pos++;
			if (idx_pos < idxs.len) {
				cur_idx = (*(int*)/*ee elem_typ */array_get(idxs, idx_pos));
			}
		} else {
			{ // Unsafe block
				b[b_i] = string_at(s, i);
			}
			b_i++;
		}
	}
	{ // Unsafe block
		b[new_len] = L'\0';
		// Defer begin
		if (string_replace_defer_0 == true) {
			array_free(&idxs);
		}
		// Defer end
		return tos(b, new_len);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

VV_LOCAL_SYMBOL int compare_rep_index(RepIndex* a, RepIndex* b) {
	if (a->idx < b->idx) {
		return -1;
	}
	if (a->idx > b->idx) {
		return 1;
	}
	return 0;
}

VV_LOCAL_SYMBOL void Array_RepIndex_sort2(Array_RepIndex* a) {
	array_sort_with_compare(a, compare_rep_index);
}

string string_replace_each(string s, Array_string vals) {
	if (s.len == 0 || vals.len == 0) {
		return string_clone(s);
	}
	if (vals.len % 2 != 0) {
		println(_SLIT("string.replace_each(): odd number of strings"));
		return string_clone(s);
	}
	int new_len = s.len;
	Array_RepIndex idxs = __new_array_with_default(0, 0, sizeof(RepIndex), 0);
	int idx = 0;
	string s_ = string_clone(s);
	for (int rep_i = 0; rep_i < vals.len; rep_i += 2) {
		string rep = (*(string*)/*ee elem_typ */array_get(vals, rep_i));
		string with = (*(string*)/*ee elem_typ */array_get(vals, rep_i + 1));
		for (;;) {
			idx = string_index_after(s_, rep, idx);
			if (idx == -1) {
				break;
			}
			for (int i = 0; i < rep.len; ++i) {
				{ // Unsafe block
					s_.str[idx + i] = 127;
				}
			}
			array_push(&idxs, _MOV((RepIndex[]){ (RepIndex){.idx = idx,.val_idx = rep_i,} }));
			idx += rep.len;
			new_len += with.len - rep.len;
		}
	}
	if (idxs.len == 0) {
		return string_clone(s);
	}
	Array_RepIndex_sort2(&idxs);
	byte* b = v_malloc(new_len + 1);
	int idx_pos = 0;
	RepIndex cur_idx = (*(RepIndex*)/*ee elem_typ */array_get(idxs, idx_pos));
	int b_i = 0;
	for (int i = 0; i < s.len; i++) {
		if (i == cur_idx.idx) {
			string rep = (*(string*)/*ee elem_typ */array_get(vals, cur_idx.val_idx));
			string with = (*(string*)/*ee elem_typ */array_get(vals, cur_idx.val_idx + 1));
			for (int j = 0; j < with.len; ++j) {
				{ // Unsafe block
					b[b_i] = string_at(with, j);
				}
				b_i++;
			}
			i += rep.len - 1;
			idx_pos++;
			if (idx_pos < idxs.len) {
				cur_idx = (*(RepIndex*)/*ee elem_typ */array_get(idxs, idx_pos));
			}
		} else {
			{ // Unsafe block
				b[b_i] = s.str[i];
			}
			b_i++;
		}
	}
	{ // Unsafe block
		b[new_len] = L'\0';
		return tos(b, new_len);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

bool string_bool(string s) {
	return string_eq(s, _SLIT("true")) || string_eq(s, _SLIT("t"));
}

int string_int(string s) {
	return ((int)(strconv__common_parse_int(s, 0, 32, false, false)));
}

i64 string_i64(string s) {
	return strconv__common_parse_int(s, 0, 64, false, false);
}

i8 string_i8(string s) {
	return ((i8)(strconv__common_parse_int(s, 0, 8, false, false)));
}

i16 string_i16(string s) {
	return ((i16)(strconv__common_parse_int(s, 0, 16, false, false)));
}

f32 string_f32(string s) {
	return ((f32)(strconv__atof64(s)));
}

f64 string_f64(string s) {
	return strconv__atof64(s);
}

u16 string_u16(string s) {
	return ((u16)(strconv__common_parse_uint(s, 0, 16, false, false)));
}

u32 string_u32(string s) {
	return ((u32)(strconv__common_parse_uint(s, 0, 32, false, false)));
}

u64 string_u64(string s) {
	return strconv__common_parse_uint(s, 0, 64, false, false);
}

VV_LOCAL_SYMBOL bool string_eq(string s, string a) {
	if (s.str == 0) {
		v_panic(_SLIT("string.eq(): nil string"));
	}
	if (s.len != a.len) {
		return false;
	}
	{ // Unsafe block
		return memcmp(s.str, a.str, a.len) == 0;
	}
	return 0;
}

VV_LOCAL_SYMBOL bool string_ne(string s, string a) {
	return !string_eq(s, a);
}

VV_LOCAL_SYMBOL bool string_lt(string s, string a) {
	for (int i = 0; i < s.len; ++i) {
		if (i >= a.len || string_at(s, i) > string_at(a, i)) {
			return false;
		} else if (string_at(s, i) < string_at(a, i)) {
			return true;
		}
	}
	if (s.len < a.len) {
		return true;
	}
	return false;
}

VV_LOCAL_SYMBOL bool string_le(string s, string a) {
	return string_lt(s, a) || string_eq(s, a);
}

VV_LOCAL_SYMBOL bool string_gt(string s, string a) {
	return !string_le(s, a);
}

VV_LOCAL_SYMBOL bool string_ge(string s, string a) {
	return !string_lt(s, a);
}

string string_add(string s, string a) {
	int new_len = a.len + s.len;
	string res = (string){.str = v_malloc(new_len + 1), .len = new_len};
	for (int j = 0; j < s.len; ++j) {
		{ // Unsafe block
			res.str[j] = s.str[j];
		}
	}
	for (int j = 0; j < a.len; ++j) {
		{ // Unsafe block
			res.str[s.len + j] = a.str[j];
		}
	}
	{ // Unsafe block
		res.str[new_len] = L'\0';
	}
	return res;
}

Array_string string_split(string s, string delim) {
	return string_split_nth(s, delim, 0);
}

Array_string string_split_nth(string s, string delim, int nth) {
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	int i = 0;

	if (delim.len == (0)) {
		i = 1;
		for (int _t71 = 0; _t71 < s.len; ++_t71) {
			byte ch = s.str[_t71];
			if (nth > 0 && i >= nth) {
				array_push(&res, _MOV((string[]){ string_substr(s, i, s.len) }));
				break;
			}
			array_push(&res, _MOV((string[]){ byte_ascii_str(ch) }));
			i++;
		}
		return res;
	}
	else if (delim.len == (1)) {
		int start = 0;
		byte delim_byte = string_at(delim, 0);
		for (;;) {
			if (!(i < s.len)) break;
			if (string_at(s, i) == delim_byte) {
				bool was_last = nth > 0 && res.len == nth - 1;
				if (was_last) {
					break;
				}
				string val = string_substr(s, start, i);
				array_push(&res, _MOV((string[]){ val }));
				start = i + delim.len;
				i = start;
			} else {
				i++;
			}
		}
		if (nth < 1 || res.len < nth) {
			array_push(&res, _MOV((string[]){ string_substr(s, start, s.len) }));
		}
		return res;
	}
	else {
		int start = 0;
		for (;;) {
			if (!(i <= s.len)) break;
			bool is_delim = i + delim.len <= s.len && string_eq(string_substr(s, i, i + delim.len), delim);
			if (is_delim) {
				bool was_last = nth > 0 && res.len == nth - 1;
				if (was_last) {
					break;
				}
				string val = string_substr(s, start, i);
				array_push(&res, _MOV((string[]){ val }));
				start = i + delim.len;
				i = start;
			} else {
				i++;
			}
		}
		if (nth < 1 || res.len < nth) {
			array_push(&res, _MOV((string[]){ string_substr(s, start, s.len) }));
		}
		return res;
	};
	return __new_array(0, 1, sizeof(string));
}

Array_string string_split_into_lines(string s) {
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	if (s.len == 0) {
		return res;
	}
	int start = 0;
	for (int i = 0; i < s.len; i++) {
		bool is_lf = s.str[i] == L'\n';
		bool is_crlf = i != s.len - 1 && s.str[i] == L'\r' && s.str[i + 1] == L'\n';
		bool is_eol = is_lf || is_crlf;
		bool is_last = (is_crlf ? (i == s.len - 2) : (i == s.len - 1));
		if (is_eol || is_last) {
			if (is_last && !is_eol) {
				i++;
			}
			string line = string_substr(s, start, i);
			array_push(&res, _MOV((string[]){ line }));
			if (is_crlf) {
				i++;
			}
			start = i + 1;
		}
	}
	return res;
}

VV_LOCAL_SYMBOL string string_substr2(string s, int start, int _end, bool end_max) {
	int end = (end_max ? (s.len) : (_end));
	return string_substr(s, start, end);
}

string string_substr(string s, int start, int end) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (start > end || start > s.len || end > s.len || start < 0 || end < 0) {
			v_panic(_STR("substr(%"PRId32"\000, %"PRId32"\000) out of bounds (len=%"PRId32"\000)", 4, start, end, s.len));
		}
	}
	#endif
	int len = end - start;
	if (len == s.len) {
		return string_clone(s);
	}
	string res = (string){.str = v_malloc(len + 1), .len = len};
	for (int i = 0; i < len; ++i) {
		{ // Unsafe block
			res.str[i] = s.str[start + i];
		}
	}
	{ // Unsafe block
		res.str[len] = L'\0';
	}
	return res;
}

VV_LOCAL_SYMBOL int string_index_(string s, string p) {
	if (p.len > s.len || p.len == 0) {
		return -1;
	}
	if (p.len > 2) {
		return string_index_kmp(s, p);
	}
	int i = 0;
	for (;;) {
		if (!(i < s.len)) break;
		int j = 0;
		for (;;) {
			if (!(j < p.len && s.str[i + j] == p.str[j])) break;
			j++;
		}
		if (j == p.len) {
			return i;
		}
		i++;
	}
	return -1;
}

Option_int string_index(string s, string p) {
	int idx = string_index_(s, p);
	if (idx == -1) {
		return (Option_int){ .state=2, .err=_const_none__ };
	}
	Option_int _t79;
	opt_ok(&(int[]) { idx }, (Option*)(&_t79), sizeof(int));
	return _t79;
}

// Attr: [manualfree]
VV_LOCAL_SYMBOL int string_index_kmp(string s, string p) {
bool string_index_kmp_defer_0 = false;
	if (p.len > s.len) {
		return -1;
	}
	Array_int prefix = __new_array_with_default(p.len, 0, sizeof(int), 0);
	string_index_kmp_defer_0 = true;
	int j = 0;
	for (int i = 1; i < p.len; i++) {
		for (;;) {
			if (!(p.str[j] != p.str[i] && j > 0)) break;
			j = (*(int*)/*ee elem_typ */array_get(prefix, j - 1));
		}
		if (p.str[j] == p.str[i]) {
			j++;
		}
		array_set(&prefix, i, &(int[]) { j });
	}
	j = 0;
	for (int i = 0; i < s.len; ++i) {
		for (;;) {
			if (!(p.str[j] != s.str[i] && j > 0)) break;
			j = (*(int*)/*ee elem_typ */array_get(prefix, j - 1));
		}
		if (p.str[j] == s.str[i]) {
			j++;
		}
		if (j == p.len) {
			// Defer begin
			if (string_index_kmp_defer_0 == true) {
				array_free(&prefix);
			}
			// Defer end
			return i - p.len + 1;
		}
	}
	// Defer begin
	if (string_index_kmp_defer_0 == true) {
		array_free(&prefix);
	}
	// Defer end
	return -1;
}

int string_index_any(string s, string chars) {
	for (int _t80 = 0; _t80 < chars.len; ++_t80) {
		byte c = chars.str[_t80];
		int idx = string_index_(s, byte_ascii_str(c));
		if (idx == -1) {
			continue;
		}
		return idx;
	}
	return -1;
}

VV_LOCAL_SYMBOL int string_last_index_(string s, string p) {
	if (p.len > s.len || p.len == 0) {
		return -1;
	}
	int i = s.len - p.len;
	for (;;) {
		if (!(i >= 0)) break;
		int j = 0;
		for (;;) {
			if (!(j < p.len && s.str[i + j] == p.str[j])) break;
			j++;
		}
		if (j == p.len) {
			return i;
		}
		i--;
	}
	return -1;
}

Option_int string_last_index(string s, string p) {
	int idx = string_last_index_(s, p);
	if (idx == -1) {
		return (Option_int){ .state=2, .err=_const_none__ };
	}
	Option_int _t81;
	opt_ok(&(int[]) { idx }, (Option*)(&_t81), sizeof(int));
	return _t81;
}

int string_index_after(string s, string p, int start) {
	if (p.len > s.len) {
		return -1;
	}
	int strt = start;
	if (start < 0) {
		strt = 0;
	}
	if (start >= s.len) {
		return -1;
	}
	int i = strt;
	for (;;) {
		if (!(i < s.len)) break;
		int j = 0;
		int ii = i;
		for (;;) {
			if (!(j < p.len && s.str[ii] == p.str[j])) break;
			j++;
			ii++;
		}
		if (j == p.len) {
			return i;
		}
		i++;
	}
	return -1;
}

int string_index_byte(string s, byte c) {
	for (int i = 0; i < s.len; ++i) {
		if (s.str[i] == c) {
			return i;
		}
	}
	return -1;
}

int string_last_index_byte(string s, byte c) {
	for (int i = s.len - 1; i >= 0; i--) {
		if (s.str[i] == c) {
			return i;
		}
	}
	return -1;
}

int string_count(string s, string substr) {
	if (s.len == 0 || substr.len == 0) {
		return 0;
	}
	if (substr.len > s.len) {
		return 0;
	}
	int n = 0;
	if (substr.len == 1) {
		byte target = string_at(substr, 0);
		for (int _t82 = 0; _t82 < s.len; ++_t82) {
			byte letter = s.str[_t82];
			if (letter == target) {
				n++;
			}
		}
		return n;
	}
	int i = 0;
	for (;;) {
		i = string_index_after(s, substr, i);
		if (i == -1) {
			return n;
		}
		i += substr.len;
		n++;
	}
	return 0;
}

bool string_contains(string s, string substr) {
	if (substr.len == 0) {
		return true;
	}
	if (string_index_(s, substr) == -1) {
		return false;
	}
	return true;
}

bool string_contains_any(string s, string chars) {
	for (int _t83 = 0; _t83 < chars.len; ++_t83) {
		byte c = chars.str[_t83];
		if (string_contains(s, byte_ascii_str(c))) {
			return true;
		}
	}
	return false;
}

bool string_contains_any_substr(string s, Array_string substrs) {
	if (substrs.len == 0) {
		return true;
	}
	// FOR IN array
	for (int _t84 = 0; _t84 < substrs.len; ++_t84) {
		string sub = ((string*)substrs.data)[_t84];
		if (string_contains(s, sub)) {
			return true;
		}
	}
	return false;
}

bool string_starts_with(string s, string p) {
	if (p.len > s.len) {
		return false;
	}
	for (int i = 0; i < p.len; ++i) {
		if (s.str[i] != p.str[i]) {
			return false;
		}
	}
	return true;
}

bool string_ends_with(string s, string p) {
	if (p.len > s.len) {
		return false;
	}
	for (int i = 0; i < p.len; ++i) {
		if (string_at(p, i) != string_at(s, s.len - p.len + i)) {
			return false;
		}
	}
	return true;
}

string string_to_lower(string s) {
	{ // Unsafe block
		byte* b = v_malloc(s.len + 1);
		for (int i = 0; i < s.len; ++i) {
			b[i] = ((byte)(tolower(s.str[i])));
		}
		b[s.len] = 0;
		return tos(b, s.len);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

bool string_is_lower(string s) {
	for (int i = 0; i < s.len; ++i) {
		if (string_at(s, i) >= L'A' && string_at(s, i) <= L'Z') {
			return false;
		}
	}
	return true;
}

string string_to_upper(string s) {
	{ // Unsafe block
		byte* b = v_malloc(s.len + 1);
		for (int i = 0; i < s.len; ++i) {
			b[i] = ((byte)(toupper(s.str[i])));
		}
		b[s.len] = 0;
		return tos(b, s.len);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

bool string_is_upper(string s) {
	for (int i = 0; i < s.len; ++i) {
		if (string_at(s, i) >= L'a' && string_at(s, i) <= L'z') {
			return false;
		}
	}
	return true;
}

string string_capitalize(string s) {
	if (s.len == 0) {
		return _SLIT("");
	}
	byte s0 = string_at(s, 0);
	string letter = byte_ascii_str(s0);
	string uletter = string_to_upper(letter);
	if (s.len == 1) {
		return uletter;
	}
	string srest = string_substr(s, 1, s.len);
	string res = string_add(uletter, srest);
	return res;
}

bool string_is_capital(string s) {
	if (s.len == 0 || !(string_at(s, 0) >= L'A' && string_at(s, 0) <= L'Z')) {
		return false;
	}
	for (int i = 1; i < s.len; ++i) {
		if (string_at(s, i) >= L'A' && string_at(s, i) <= L'Z') {
			return false;
		}
	}
	return true;
}

string string_title(string s) {
	Array_string words = string_split(s, _SLIT(" "));
	Array_string tit = __new_array_with_default(0, 0, sizeof(string), 0);
	// FOR IN array
	for (int _t85 = 0; _t85 < words.len; ++_t85) {
		string word = ((string*)words.data)[_t85];
		array_push(&tit, _MOV((string[]){ string_capitalize(word) }));
	}
	string title = Array_string_join(tit, _SLIT(" "));
	return title;
}

bool string_is_title(string s) {
	Array_string words = string_split(s, _SLIT(" "));
	// FOR IN array
	for (int _t87 = 0; _t87 < words.len; ++_t87) {
		string word = ((string*)words.data)[_t87];
		if (!string_is_capital(word)) {
			return false;
		}
	}
	return true;
}

string string_find_between(string s, string start, string end) {
	int start_pos = string_index_(s, start);
	if (start_pos == -1) {
		return _SLIT("");
	}
	string val = string_substr(s, start_pos + start.len, s.len);
	int end_pos = string_index_(val, end);
	if (end_pos == -1) {
		return val;
	}
	return string_substr(val, 0, end_pos);
}

bool byte_is_space(byte c) {
	return (c == L' ' || c == L'\n' || c == L'\t' || c == L'\v' || c == L'\f' || c == L'\r' || c == 0x85 || c == 0xa0);
}

string string_trim_space(string s) {
	return string_trim(s, _SLIT(" \n\t\v\f\r"));
}

string string_trim(string s, string cutset) {
	if (s.len < 1 || cutset.len < 1) {
		return string_clone(s);
	}
	int pos_left = 0;
	int pos_right = s.len - 1;
	bool cs_match = true;
	for (;;) {
		if (!(pos_left <= s.len && pos_right >= -1 && cs_match)) break;
		cs_match = false;
		for (int _t88 = 0; _t88 < cutset.len; ++_t88) {
			byte cs = cutset.str[_t88];
			if (string_at(s, pos_left) == cs) {
				pos_left++;
				cs_match = true;
				break;
			}
		}
		for (int _t89 = 0; _t89 < cutset.len; ++_t89) {
			byte cs = cutset.str[_t89];
			if (string_at(s, pos_right) == cs) {
				pos_right--;
				cs_match = true;
				break;
			}
		}
		if (pos_left > pos_right) {
			return _SLIT("");
		}
	}
	return string_substr(s, pos_left, pos_right + 1);
}

string string_trim_left(string s, string cutset) {
	if (s.len < 1 || cutset.len < 1) {
		return string_clone(s);
	}
	int pos = 0;
	for (;;) {
		if (!(pos < s.len)) break;
		bool found = false;
		for (int _t90 = 0; _t90 < cutset.len; ++_t90) {
			byte cs = cutset.str[_t90];
			if (string_at(s, pos) == cs) {
				found = true;
				break;
			}
		}
		if (!found) {
			break;
		}
		pos++;
	}
	return string_substr(s, pos, s.len);
}

string string_trim_right(string s, string cutset) {
	if (s.len < 1 || cutset.len < 1) {
		return string_clone(s);
	}
	int pos = s.len - 1;
	for (;;) {
		if (!(pos >= 0)) break;
		bool found = false;
		for (int _t91 = 0; _t91 < cutset.len; ++_t91) {
			byte cs = cutset.str[_t91];
			if (string_at(s, pos) == cs) {
				found = true;
			}
		}
		if (!found) {
			break;
		}
		pos--;
	}
	if (pos < 0) {
		return _SLIT("");
	}
	return string_substr(s, 0, pos + 1);
}

string string_trim_prefix(string s, string str) {
	if (string_starts_with(s, str)) {
		return string_substr(s, str.len, s.len);
	}
	return string_clone(s);
}

string string_trim_suffix(string s, string str) {
	if (string_ends_with(s, str)) {
		return string_substr(s, 0, s.len - str.len);
	}
	return string_clone(s);
}

int compare_strings(string* a, string* b) {
	if (string_lt(/*rec*/*a, *b)) {
		return -1;
	}
	if (string_gt(/*rec*/*a, *b)) {
		return 1;
	}
	return 0;
}

VV_LOCAL_SYMBOL int compare_strings_reverse(string* a, string* b) {
	if (string_lt(/*rec*/*a, *b)) {
		return 1;
	}
	if (string_gt(/*rec*/*a, *b)) {
		return -1;
	}
	return 0;
}

VV_LOCAL_SYMBOL int compare_strings_by_len(string* a, string* b) {
	if (a->len < b->len) {
		return -1;
	}
	if (a->len > b->len) {
		return 1;
	}
	return 0;
}

VV_LOCAL_SYMBOL int compare_lower_strings(string* a, string* b) {
	string aa = string_to_lower(/*rec*/*a);
	string bb = string_to_lower(/*rec*/*b);
	return compare_strings(&aa, &bb);
}

void Array_string_sort(Array_string* s) {
	array_sort_with_compare(s, compare_strings);
}

void Array_string_sort_ignore_case(Array_string* s) {
	array_sort_with_compare(s, compare_lower_strings);
}

void Array_string_sort_by_len(Array_string* s) {
	array_sort_with_compare(s, compare_strings_by_len);
}

string string_str(string s) {
	return string_clone(s);
}

string ustring_str(ustring s) {
	return s.s;
}

ustring string_ustring(string s) {
	ustring res = (ustring){.s = s,.runes = __new_array(0, s.len, ((int)(/*SizeOf*/ sizeof(int)))),.len = 0,};
	for (int i = 0; i < s.len; i++) {
		int char_len = utf8_char_len(s.str[i]);
		array_push(&res.runes, _MOV((int[]){ i }));
		i += char_len - 1;
		res.len++;
	}
	return res;
}

ustring string_ustring_tmp(string s) {
	if (g_ustring_runes.len == 0) {
		g_ustring_runes = __new_array(0, 128, ((int)(/*SizeOf*/ sizeof(int))));
	}
	ustring res = (ustring){.s = s,.runes = __new_array(0, 1, sizeof(int)),.len = 0,};
	res.runes = g_ustring_runes;
	res.runes.len = s.len;
	int j = 0;
	for (int i = 0; i < s.len; i++) {
		int char_len = utf8_char_len(s.str[i]);
		(*(int*)/*ee elem_typ */array_get(res.runes, j)) = i;
		j++;
		i += char_len - 1;
		res.len++;
	}
	return res;
}

VV_LOCAL_SYMBOL bool ustring_eq(ustring u, ustring a) {
	if (u.len != a.len || string_ne(u.s, a.s)) {
		return false;
	}
	return true;
}

VV_LOCAL_SYMBOL bool ustring_ne(ustring u, ustring a) {
	return !ustring_eq(u, a);
}

VV_LOCAL_SYMBOL bool ustring_lt(ustring u, ustring a) {
	return string_lt(u.s, a.s);
}

VV_LOCAL_SYMBOL bool ustring_le(ustring u, ustring a) {
	return ustring_lt(u, a) || ustring_eq(u, a);
}

VV_LOCAL_SYMBOL bool ustring_gt(ustring u, ustring a) {
	return !ustring_le(u, a);
}

VV_LOCAL_SYMBOL bool ustring_ge(ustring u, ustring a) {
	return !ustring_lt(u, a);
}

ustring ustring_add(ustring u, ustring a) {
	ustring res = (ustring){.s = string_add(u.s, a.s),.runes = __new_array(0, u.s.len + a.s.len, ((int)(/*SizeOf*/ sizeof(int)))),.len = 0,};
	int j = 0;
	for (int i = 0; i < u.s.len; i++) {
		int char_len = utf8_char_len(u.s.str[i]);
		array_push(&res.runes, _MOV((int[]){ j }));
		i += char_len - 1;
		j += char_len;
		res.len++;
	}
	for (int i = 0; i < a.s.len; i++) {
		int char_len = utf8_char_len(a.s.str[i]);
		array_push(&res.runes, _MOV((int[]){ j }));
		i += char_len - 1;
		j += char_len;
		res.len++;
	}
	return res;
}

int ustring_index_after(ustring u, ustring p, int start) {
	if (p.len > u.len) {
		return -1;
	}
	int strt = start;
	if (start < 0) {
		strt = 0;
	}
	if (start > u.len) {
		return -1;
	}
	int i = strt;
	for (;;) {
		if (!(i < u.len)) break;
		int j = 0;
		int ii = i;
		for (;;) {
			if (!(j < p.len && string_eq(ustring_at(u, ii), ustring_at(p, j)))) break;
			j++;
			ii++;
		}
		if (j == p.len) {
			return i;
		}
		i++;
	}
	return -1;
}

int ustring_count(ustring u, ustring substr) {
	if (u.len == 0 || substr.len == 0) {
		return 0;
	}
	if (substr.len > u.len) {
		return 0;
	}
	int n = 0;
	int i = 0;
	for (;;) {
		i = ustring_index_after(u, substr, i);
		if (i == -1) {
			return n;
		}
		i += substr.len;
		n++;
	}
	return 0;
}

string ustring_substr(ustring u, int _start, int _end) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (_start > _end || _start > u.len || _end > u.len || _start < 0 || _end < 0) {
			v_panic(_STR("substr(%"PRId32"\000, %"PRId32"\000) out of bounds (len=%"PRId32"\000)", 4, _start, _end, u.len));
		}
	}
	#endif
	int end = (_end >= u.len ? (u.s.len) : ((*(int*)/*ee elem_typ */array_get(u.runes, _end))));
	return string_substr(u.s, (*(int*)/*ee elem_typ */array_get(u.runes, _start)), end);
}

string ustring_left(ustring u, int pos) {
	if (pos >= u.len) {
		return u.s;
	}
	return ustring_substr(u, 0, pos);
}

string ustring_right(ustring u, int pos) {
	if (pos >= u.len) {
		return _SLIT("");
	}
	return ustring_substr(u, pos, u.len);
}

VV_LOCAL_SYMBOL byte string_at(string s, int idx) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (idx < 0 || idx >= s.len) {
			v_panic(_STR("string index out of range: %"PRId32"\000 / %"PRId32"", 2, idx, s.len));
		}
	}
	#endif
	{ // Unsafe block
		return s.str[idx];
	}
	return 0;
}

string ustring_at(ustring u, int idx) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (idx < 0 || idx >= u.len) {
			v_panic(_STR("string index out of range: %"PRId32"\000 / %"PRId32"", 2, idx, u.runes.len));
		}
	}
	#endif
	return ustring_substr(u, idx, idx + 1);
}

// Attr: [unsafe]
VV_LOCAL_SYMBOL void ustring_free(ustring* u) {
	{ // Unsafe block
		array_free(&u->runes);
		string_free(&u->s);
	}
}

bool byte_is_digit(byte c) {
	return c >= L'0' && c <= L'9';
}

bool byte_is_hex_digit(byte c) {
	return byte_is_digit(c) || (c >= L'a' && c <= L'f') || (c >= L'A' && c <= L'F');
}

bool byte_is_oct_digit(byte c) {
	return c >= L'0' && c <= L'7';
}

bool byte_is_bin_digit(byte c) {
	return c == L'0' || c == L'1';
}

bool byte_is_letter(byte c) {
	return (c >= L'a' && c <= L'z') || (c >= L'A' && c <= L'Z');
}

// Attr: [unsafe]
void string_free(string* s) {
	if (s->is_lit == -98761234) {
		printf("double string.free() detected\n");
		return;
	}
	if (s->is_lit == 1 || s->len == 0) {
		return;
	}
	v_free(s->str);
	s->is_lit = -98761234;
}

string string_before(string s, string dot) {
	int pos = string_index_(s, dot);
	if (pos == -1) {
		return string_clone(s);
	}
	return string_substr(s, 0, pos);
}

string string_all_before(string s, string dot) {
	int pos = string_index_(s, dot);
	if (pos == -1) {
		return string_clone(s);
	}
	return string_substr(s, 0, pos);
}

string string_all_before_last(string s, string dot) {
	int pos = string_last_index_(s, dot);
	if (pos == -1) {
		return string_clone(s);
	}
	return string_substr(s, 0, pos);
}

string string_all_after(string s, string dot) {
	int pos = string_index_(s, dot);
	if (pos == -1) {
		return string_clone(s);
	}
	return string_substr(s, pos + dot.len, s.len);
}

string string_all_after_last(string s, string dot) {
	int pos = string_last_index_(s, dot);
	if (pos == -1) {
		return string_clone(s);
	}
	return string_substr(s, pos + dot.len, s.len);
}

string string_after(string s, string dot) {
	return string_all_after_last(s, dot);
}

string string_after_char(string s, byte dot) {
	int pos = 0;
	for (int i = 0; i < s.len; ++i) {
		byte c = s.str[i];
		if (c == dot) {
			pos = i;
			break;
		}
	}
	if (pos == 0) {
		return string_clone(s);
	}
	return string_substr(s, pos + 1, s.len);
}

string Array_string_join(Array_string a, string del) {
	if (a.len == 0) {
		return _SLIT("");
	}
	int len = 0;
	// FOR IN array
	for (int _t95 = 0; _t95 < a.len; ++_t95) {
		string val = ((string*)a.data)[_t95];
		len += val.len + del.len;
	}
	len -= del.len;
	string res = (string){.str = v_malloc(len + 1), .len = len};
	int idx = 0;
	// FOR IN array
	for (int i = 0; i < a.len; ++i) {
		string val = ((string*)a.data)[i];
		for (int j = 0; j < val.len; ++j) {
			{ // Unsafe block
				res.str[idx] = val.str[j];
			}
			idx++;
		}
		if (i != a.len - 1) {
			for (int k = 0; k < del.len; ++k) {
				{ // Unsafe block
					res.str[idx] = del.str[k];
				}
				idx++;
			}
		}
	}
	{ // Unsafe block
		res.str[res.len] = L'\0';
	}
	return res;
}

string Array_string_join_lines(Array_string s) {
	return Array_string_join(s, _SLIT("\n"));
}

string string_reverse(string s) {
	if (s.len == 0 || s.len == 1) {
		return string_clone(s);
	}
	string res = (string){.str = v_malloc(s.len), .len = s.len};
	for (int i = s.len - 1; i >= 0; i--) {
		{ // Unsafe block
			res.str[s.len - i - 1] = string_at(s, i);
		}
	}
	return res;
}

string string_limit(string s, int max) {
	ustring u = string_ustring(s);
	if (u.len <= max) {
		return string_clone(s);
	}
	return ustring_substr(u, 0, max);
}

int string_hash(string s) {
	u32 h = ((u32)(0U));
	if (h == 0 && s.len > 0) {
		for (int _t96 = 0; _t96 < s.len; ++_t96) {
			byte c = s.str[_t96];
			h = h * 31 + ((u32)(c));
		}
	}
	return ((int)(h));
}

Array_byte string_bytes(string s) {
	if (s.len == 0) {
		return __new_array_with_default(0, 0, sizeof(byte), 0);
	}
	Array_byte buf = __new_array_with_default(s.len, 0, sizeof(byte), 0);
	memcpy(buf.data, s.str, s.len);
	return buf;
}

string string_repeat(string s, int count) {
	if (count < 0) {
		v_panic(_STR("string.repeat: count is negative: %"PRId32"", 1, count));
	} else if (count == 0) {
		return _SLIT("");
	} else if (count == 1) {
		return string_clone(s);
	}
	byte* ret = v_malloc(s.len * count + 1);
	for (int i = 0; i < count; ++i) {
		for (int j = 0; j < s.len; ++j) {
			{ // Unsafe block
				ret[i * s.len + j] = string_at(s, j);
			}
		}
	}
	{ // Unsafe block
		int new_len = s.len * count;
		ret[new_len] = 0;
		return byte_vstring_with_len(ret, new_len);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

Array_string string_fields(string s) {
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	int word_start = 0;
	int word_len = 0;
	bool is_in_word = false;
	bool is_space = false;
	for (int i = 0; i < s.len; ++i) {
		byte c = s.str[i];
		is_space = (c == L' ' || c == L'\t' || c == L'\n');
		if (!is_space) {
			word_len++;
		}
		if (!is_in_word && !is_space) {
			word_start = i;
			is_in_word = true;
			continue;
		}
		if (is_space && is_in_word) {
			array_push(&res, _MOV((string[]){ string_substr(s, word_start, word_start + word_len) }));
			is_in_word = false;
			word_len = 0;
			word_start = 0;
			continue;
		}
	}
	if (is_in_word && word_len > 0) {
		array_push(&res, _MOV((string[]){ string_substr(s, word_start, s.len) }));
	}
	return res;
}

string string_strip_margin(string s) {
	return string_strip_margin_custom(s, L'|');
}

string string_strip_margin_custom(string s, byte del) {
	byte sep = del;
	if (byte_is_space(sep)) {
		eprintln(_SLIT("Warning: `strip_margin` cannot use white-space as a delimiter"));
		eprintln(_SLIT("    Defaulting to `|`"));
		sep = L'|';
	}
	byte* ret = v_malloc(s.len + 1);
	int count = 0;
	for (int i = 0; i < s.len; i++) {
		if ((string_at(s, i) == L'\n' || string_at(s, i) == L'\r')) {
			{ // Unsafe block
				ret[count] = string_at(s, i);
			}
			count++;
			if (string_at(s, i) == L'\r' && i < s.len - 1 && string_at(s, i + 1) == L'\n') {
				{ // Unsafe block
					ret[count] = string_at(s, i + 1);
				}
				count++;
				i++;
			}
			for (;;) {
				if (!(string_at(s, i) != sep)) break;
				i++;
				if (i >= s.len) {
					break;
				}
			}
		} else {
			{ // Unsafe block
				ret[count] = string_at(s, i);
			}
			count++;
		}
	}
	{ // Unsafe block
		ret[count] = 0;
		return byte_vstring_with_len(ret, count);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [deprecated]
Array_string string_split_by_whitespace(string s) {
	return string_fields(s);
}

// Attr: [unsafe]
Array_byte byteptr_vbytes(byteptr data, int len) {
	return voidptr_vbytes(((voidptr)(data)), len);
}

// Attr: [unsafe]
string byteptr_vstring(byteptr bp) {
	return (string){.str = bp, .len = strlen(((char*)(bp)))};
}

// Attr: [unsafe]
string byteptr_vstring_with_len(byteptr bp, int len) {
	return (string){.str = bp, .len = len, .is_lit = 0};
}

// Attr: [unsafe]
string charptr_vstring(charptr cp) {
	return (string){.str = ((byteptr)(cp)), .len = strlen(((char*)(cp))), .is_lit = 0};
}

// Attr: [unsafe]
string charptr_vstring_with_len(charptr cp, int len) {
	return (string){.str = ((byteptr)(cp)), .len = len, .is_lit = 0};
}

// Attr: [unsafe]
string byteptr_vstring_literal(byteptr bp) {
	return (string){.str = bp, .len = strlen(((char*)(bp))), .is_lit = 1};
}

// Attr: [unsafe]
string byteptr_vstring_literal_with_len(byteptr bp, int len) {
	return (string){.str = bp, .len = len, .is_lit = 1};
}

// Attr: [unsafe]
string charptr_vstring_literal(charptr cp) {
	return (string){.str = ((byteptr)(cp)), .len = strlen(((char*)(cp))), .is_lit = 1};
}

// Attr: [unsafe]
string charptr_vstring_literal_with_len(charptr cp, int len) {
	return (string){.str = ((byteptr)(cp)), .len = len, .is_lit = 1};
}

u16* string_to_wide(string _str) {
	#if defined(_WIN32)
	{
		{ // Unsafe block
			int num_chars = (MultiByteToWideChar(_const_cp_utf8, 0, ((char*)(_str.str)), _str.len, 0, 0));
			u16* wstr = ((u16*)(v_malloc((num_chars + 1) * 2)));
			if (wstr != 0) {
				MultiByteToWideChar(_const_cp_utf8, 0, ((char*)(_str.str)), _str.len, wstr, num_chars);
				memset(((byte*)(wstr)) + num_chars * 2, 0, 2);
			}
			return wstr;
		}
	}
	#else
	{
	}
	#endif
	return 0;
}

// Attr: [unsafe]
string string_from_wide(u16* _wstr) {
	#if defined(_WIN32)
	{
		{ // Unsafe block
			int wstr_len = wcslen(_wstr);
			return string_from_wide2(_wstr, wstr_len);
		}
	}
	#else
	{
	}
	#endif
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [unsafe]
string string_from_wide2(u16* _wstr, int len) {
	#if defined(_WIN32)
	{
		{ // Unsafe block
			int num_chars = WideCharToMultiByte(_const_cp_utf8, 0, _wstr, len, 0, 0, 0, 0);
			byte* str_to = v_malloc(num_chars + 1);
			if (str_to != 0) {
				WideCharToMultiByte(_const_cp_utf8, 0, _wstr, len, ((char*)(str_to)), num_chars, 0, 0);
				memset(str_to + num_chars, 0, 1);
			}
			return tos2(str_to);
		}
	}
	#else
	{
	}
	#endif
	return (string){.str=(byteptr)"", .is_lit=1};
}

int utf8_getchar(void) {
	int c = getchar();
	int len = utf8_len(((byte)(~c)));
	if (c < 0) {
		return 0;
	} else if (len == 0) {
		return c;
	} else if (len == 1) {
		return -1;
	} else {
		int uc = (c & ((1 << (7 - len)) - 1));
		for (int i = 0; i + 1 < len; i++) {
			int c2 = getchar();
			if (c2 != -1 && (c2 >> 6) == 2) {
				uc <<= 6;
				uc |= ((c2 & 63));
			} else if (c2 == -1) {
				return 0;
			} else {
				return -1;
			}
		}
		return uc;
	}
	return 0;
}

int utf8_char_len(byte b) {
	return (((0xe5000000 >> (((b >> 3) & 0x1e))) & 3)) + 1;
}

string utf32_to_str(u32 code) {
	{ // Unsafe block
		byte* buffer = v_malloc(5);
		return utf32_to_str_no_malloc(code, buffer);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [unsafe]
string utf32_to_str_no_malloc(u32 code, voidptr buf) {
	int icode = ((int)(code));
	string res = _SLIT("");
	{ // Unsafe block
		byte* buffer = ((byte*)(buf));
		if (icode <= 127) {
			buffer[0] = ((byte)(icode));
			buffer[1] = 0;
			res = tos(buffer, 1);
		} else if (icode <= 2047) {
			buffer[0] = (192 | ((byte)(icode >> 6)));
			buffer[1] = (128 | ((byte)((icode & 63))));
			buffer[2] = 0;
			res = tos(buffer, 2);
		} else if (icode <= 65535) {
			buffer[0] = (224 | ((byte)(icode >> 12)));
			buffer[1] = (128 | ((((byte)(icode >> 6)) & 63)));
			buffer[2] = (128 | ((byte)((icode & 63))));
			buffer[3] = 0;
			res = tos(buffer, 3);
		} else if (icode <= 1114111) {
			buffer[0] = (240 | ((byte)(icode >> 18)));
			buffer[1] = (128 | ((((byte)(icode >> 12)) & 63)));
			buffer[2] = (128 | ((((byte)(icode >> 6)) & 63)));
			buffer[3] = (128 | ((byte)((icode & 63))));
			buffer[4] = 0;
			res = tos(buffer, 4);
		}
	}
	res.is_lit = 1;
	return res;
}

int string_utf32_code(string _rune) {
	if (_rune.len == 0) {
		return 0;
	}
	if (_rune.len == 1) {
		return ((int)(string_at(_rune, 0)));
	}
	byte b = ((byte)(((int)(string_at(_rune, 0)))));
	b = b << _rune.len;
	int res = ((int)(b));
	int shift = 6 - _rune.len;
	for (int i = 1; i < _rune.len; i++) {
		int c = ((int)(string_at(_rune, i)));
		res = res << shift;
		res |= (c & 63);
		shift = 6;
	}
	return res;
}

VV_LOCAL_SYMBOL int utf8_len(byte c) {
	int b = 0;
	byte x = c;
	if (((x & 240)) != 0) {
		x >>= 4;
	} else {
		b += 4;
	}
	if (((x & 12)) != 0) {
		x >>= 2;
	} else {
		b += 2;
	}
	if (((x & 2)) == 0) {
		b++;
	}
	return b;
}

VV_LOCAL_SYMBOL int utf8_str_len(string s) {
	int l = 0;
	for (int i = 0; i < s.len; i++) {
		l++;
		byte c = s.str[i];
		if (((c & (1 << 7))) != 0) {
			for (byte t = ((byte)(1 << 6)); ((c & t)) != 0; t >>= 1) {
				i++;
			}
		}
	}
	return l;
}

int utf8_str_visible_length(string s) {
	int l = 0;
	int ul = 1;
	for (int i = 0; i < s.len; i += ul) {
		ul = 1;
		byte c = s.str[i];
		if (((c & (1 << 7))) != 0) {
			for (byte t = ((byte)(1 << 6)); ((c & t)) != 0; t >>= 1) {
				ul++;
			}
		}
		if (i + ul > s.len) {
			return l;
		}
		l++;

		if (ul == (2)) {
			u64 r = ((u64)(((((u16)(c)) << 8) | s.str[i + 1])));
			if (r >= 0xcc80 && r < 0xcdb0) {
				l--;
			}
		}
		else if (ul == (3)) {
			u64 r = ((u64)(((((u32)(c)) << 16) | ((((u32)(s.str[i + 1])) << 8) | s.str[i + 2]))));
			if ((r >= 0xe1aab0 && r <= 0xe1ac7f) || (r >= 0xe1b780 && r <= 0xe1b87f) || (r >= 0xe28390 && r <= 0xe2847f) || (r >= 0xefb8a0 && r <= 0xefb8af)) {
				l--;
			} else if ((r >= 0xe18480 && r <= 0xe1859f) || (r >= 0xe2ba80 && r <= 0xe2bf95) || (r >= 0xe38080 && r <= 0xe4b77f) || (r >= 0xe4b880 && r <= 0xea807f) || (r >= 0xeaa5a0 && r <= 0xeaa79f) || (r >= 0xeab080 && r <= 0xed9eaf) || (r >= 0xefa480 && r <= 0xefac7f) || (r >= 0xefb8b8 && r <= 0xefb9af)) {
				l++;
			}
		}
		else if (ul == (4)) {
			u64 r = ((u64)(((((u32)(c)) << 24) | (((((u32)(s.str[i + 1])) << 16) | (((u32)(s.str[i + 2])) << 8)) | s.str[i + 3]))));
			if ((r >= 0x0f9f8880 && r <= 0xf09f8a8f) || (r >= 0xf09f8c80 && r <= 0xf09f9c90) || (r >= 0xf09fa490 && r <= 0xf09fa7af) || (r >= 0xff0a08080 && r <= 0xf180807f)) {
				l++;
			}
		}
		else {
		};
	}
	return l;
}

Array_string os__args_after(string cut_word) {
	if (_const_os__args.len == 0) {
		return __new_array_with_default(0, 0, sizeof(string), 0);
	}
	Array_string cargs = __new_array_with_default(0, 0, sizeof(string), 0);
	if (!(Array_string_contains(_const_os__args, cut_word))) {
		cargs = array_clone(&_const_os__args);
	} else {
		bool found = false;
		array_push(&cargs, _MOV((string[]){ (*(string*)/*ee elem_typ */array_get(_const_os__args, 0)) }));
		// FOR IN array
		Array_string _t100 = array_slice(_const_os__args, 1, _const_os__args.len);
		for (int _t101 = 0; _t101 < _t100.len; ++_t101) {
			string a = ((string*)_t100.data)[_t101];
			if (string_eq(a, cut_word)) {
				found = true;
				continue;
			}
			if (!found) {
				continue;
			}
			array_push(&cargs, _MOV((string[]){ a }));
		}
	}
	return cargs;
}

Array_string os__args_before(string cut_word) {
	if (_const_os__args.len == 0) {
		return __new_array_with_default(0, 0, sizeof(string), 0);
	}
	Array_string cargs = __new_array_with_default(0, 0, sizeof(string), 0);
	if (!(Array_string_contains(_const_os__args, cut_word))) {
		cargs = array_clone(&_const_os__args);
	} else {
		array_push(&cargs, _MOV((string[]){ (*(string*)/*ee elem_typ */array_get(_const_os__args, 0)) }));
		// FOR IN array
		Array_string _t104 = array_slice(_const_os__args, 1, _const_os__args.len);
		for (int _t105 = 0; _t105 < _t104.len; ++_t105) {
			string a = ((string*)_t104.data)[_t105];
			if (string_eq(a, cut_word)) {
				break;
			}
			array_push(&cargs, _MOV((string[]){ a }));
		}
	}
	return cargs;
}

string os__getenv(string key) {
	{ // Unsafe block
		#if defined(_WIN32)
		{
			voidptr s = _wgetenv(string_to_wide(key));
			if (s == 0) {
				return _SLIT("");
			}
			return string_from_wide(s);
		}
		#else
		{
		}
		#endif
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

int os__setenv(string name, string value, bool overwrite) {
	#if defined(_WIN32)
	{
		string format = _STR("%.*s\000=%.*s", 2, name, value);
		if (overwrite) {
			{ // Unsafe block
				return _putenv(((char*)(format.str)));
			}
		} else {
			if (os__getenv(name).len == 0) {
				{ // Unsafe block
					return _putenv(((char*)(format.str)));
				}
			}
		}
		return -1;
	}
	#else
	{
	}
	#endif
	return 0;
}

int os__unsetenv(string name) {
	#if defined(_WIN32)
	{
		string format = _STR("%.*s\000=", 2, name);
		return _putenv(((char*)(format.str)));
	}
	#else
	{
	}
	#endif
	return 0;
}

VV_LOCAL_SYMBOL char** os__unix_environ(void) {
	return ((voidptr)(environ));
}

Map_string_string os__environ(void) {
	Map_string_string res = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
	#if defined(_WIN32)
	{
		u16* estrings = GetEnvironmentStringsW();
		string eline = _SLIT("");
		for (u16* c = estrings; *c != 0; ) {
			eline = string_from_wide(c);
			int eq_index = string_index_byte(eline, L'=');
			if (eq_index > 0) {
				map_set(&res, &(string[]){string_substr(eline, 0, eq_index)}, &(string[]) { string_substr(eline, eq_index + 1, eline.len) });
			}
			{ // Unsafe block
				c = c + eline.len + 1;
			}
		}
		FreeEnvironmentStringsW(estrings);
	}
	#else
	{
	}
	#endif
	return res;
}

int os__fd_close(int fd) {
	if (fd == -1) {
		return 0;
	}
	return close(fd);
}

void os__fd_write(int fd, string s) {
	if (fd == -1) {
		return;
	}
	byte* sp = s.str;
	int remaining = s.len;
	for (;;) {
		if (!(remaining > 0)) break;
		int written = write(fd, sp, remaining);
		if (written < 0) {
			return;
		}
		remaining = remaining - written;
		sp = sp + written;
	}
}

Array_string os__fd_slurp(int fd) {
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	if (fd == -1) {
		return res;
	}
	for (;;) {
		multi_return_string_int mr_573 = os__fd_read(fd, 4096);
		string s = mr_573.arg0;
		int b = mr_573.arg1;
		if (b <= 0) {
			break;
		}
		array_push(&res, _MOV((string[]){ s }));
	}
	return res;
}

multi_return_string_int os__fd_read(int fd, int maxbytes) {
	if (fd == -1) {
		return (multi_return_string_int){.arg0=_SLIT(""), .arg1=0};
	}
	{ // Unsafe block
		byte* buf = v_malloc(maxbytes);
		int nbytes = read(fd, buf, maxbytes);
		if (nbytes < 0) {
			v_free(buf);
			return (multi_return_string_int){.arg0=_SLIT(""), .arg1=nbytes};
		}
		buf[nbytes] = 0;
		return (multi_return_string_int){.arg0=tos(buf, nbytes), .arg1=nbytes};
	}
	return (multi_return_string_int){0};
}

Option_os__File os__open_file(string path, string mode, Array_int options) {
	int flags = 0;
	for (int _t108 = 0; _t108 < mode.len; ++_t108) {
		byte m = mode.str[_t108];

		if (m == (L'w')) {
			flags |= (_const_os__o_create | _const_os__o_trunc);
		}
		else if (m == (L'a')) {
			flags |= (_const_os__o_create | _const_os__o_append);
		}
		else if (m == (L'r')) {
			flags |= _const_os__o_rdonly;
		}
		else if (m == (L'b')) {
			flags |= _const_os__o_binary;
		}
		else if (m == (L's')) {
			flags |= _const_os__o_sync;
		}
		else if (m == (L'n')) {
			flags |= _const_os__o_nonblock;
		}
		else if (m == (L'c')) {
			flags |= _const_os__o_noctty;
		}
		else if (m == (L'+')) {
			flags |= _const_os__o_rdwr;
		}
		else {
		};
	}
	if (string_eq(mode, _SLIT("r+"))) {
		flags = _const_os__o_rdwr;
	}
	if (string_eq(mode, _SLIT("w"))) {
		flags = ((_const_os__o_wronly | _const_os__o_create) | _const_os__o_trunc);
	}
	if (string_eq(mode, _SLIT("a"))) {
		flags = ((_const_os__o_wronly | _const_os__o_create) | _const_os__o_append);
	}
	int permission = 0666;
	if (options.len > 0) {
		permission = (*(int*)/*ee elem_typ */array_get(options, 0));
	}
	if (permission < 0600) {
		permission = 0x0100;
	} else {
		permission = (0x0100 | 0x0080);
	}
	string p = path;
	p = string_replace(path, _SLIT("/"), _SLIT("\\"));
	int fd = open(((char*)(p.str)), flags, permission);
	if (fd == -1) {
		return (Option_os__File){ .state=2, .err=v_error(os__posix_get_error_msg(errno)) };
	}
	FILE* cfile = fdopen(fd, ((char*)(mode.str)));
	if (isnil(cfile)) {
		return (Option_os__File){ .state=2, .err=v_error(_STR("Failed to open or create file \"%.*s\000\"", 2, path)) };
	}
	Option_os__File _t109;
	opt_ok(&(os__File[]) { (os__File){.cfile = cfile,.fd = fd,.is_opened = true,} }, (Option*)(&_t109), sizeof(os__File));
	return _t109;
}

Option_os__File os__open(string path) {
	Option_FILE_ptr _t110 = os__vfopen(path, _SLIT("rb"));
	if (_t110.state != 0) { /*or block*/ 
		Option_os__File _t111;
		memcpy(&_t111, &_t110, sizeof(Option));
		return _t111;
	}
 	FILE* cfile =  *(FILE**)_t110.data;
	int fd = os__fileno(cfile);
	Option_os__File _t112;
	opt_ok(&(os__File[]) { (os__File){.cfile = cfile,.fd = fd,.is_opened = true,} }, (Option*)(&_t112), sizeof(os__File));
	return _t112;
}

Option_os__File os__create(string path) {
	Option_FILE_ptr _t113 = os__vfopen(path, _SLIT("wb"));
	if (_t113.state != 0) { /*or block*/ 
		Option_os__File _t114;
		memcpy(&_t114, &_t113, sizeof(Option));
		return _t114;
	}
 	FILE* cfile =  *(FILE**)_t113.data;
	int fd = os__fileno(cfile);
	Option_os__File _t115;
	opt_ok(&(os__File[]) { (os__File){.cfile = cfile,.fd = fd,.is_opened = true,} }, (Option*)(&_t115), sizeof(os__File));
	return _t115;
}

os__File os__open_stdin(void) {
	return (os__File){.cfile = stdin,.fd = 0,.is_opened = true,};
}

Option_int os__File_write(os__File* f, Array_byte buf) {
	if (!f->is_opened) {
		return (Option_int){ .state=2, .err=v_error(_SLIT("file is not opened")) };
	}
	int written = ((int)(fwrite(buf.data, buf.len, 1, f->cfile)));
	if (written == 0 && buf.len != 0) {
		return (Option_int){ .state=2, .err=v_error(_SLIT("0 bytes written")) };
	}
	Option_int _t116;
	opt_ok(&(int[]) { written }, (Option*)(&_t116), sizeof(int));
	return _t116;
}

Option_int os__File_writeln(os__File* f, string s) {
	if (!f->is_opened) {
		return (Option_int){ .state=2, .err=v_error(_SLIT("file is not opened")) };
	}
	int written = ((int)(fwrite(s.str, s.len, 1, f->cfile)));
	if (written == 0 && s.len != 0) {
		return (Option_int){ .state=2, .err=v_error(_SLIT("0 bytes written")) };
	}
	int x = fputs("\n", f->cfile);
	if (x < 0) {
		return (Option_int){ .state=2, .err=v_error(_SLIT("could not add newline")) };
	}
	Option_int _t117;
	opt_ok(&(int[]) { (written + 1) }, (Option*)(&_t117), sizeof(int));
	return _t117;
}

Option_int os__File_write_string(os__File* f, string s) {
	if (!f->is_opened) {
		return (Option_int){ .state=2, .err=v_error(_SLIT("file is not opened")) };
	}
	int written = ((int)(fwrite(s.str, s.len, 1, f->cfile)));
	if (written == 0 && s.len != 0) {
		return (Option_int){ .state=2, .err=v_error(_SLIT("0 bytes written")) };
	}
	Option_int _t118;
	opt_ok(&(int[]) { written }, (Option*)(&_t118), sizeof(int));
	return _t118;
}

Option_int os__File_write_to(os__File* f, u64 pos, Array_byte buf) {
	if (!f->is_opened) {
		return (Option_int){ .state=2, .err=v_error(_SLIT("file is not opened")) };
	}
	#if defined(TARGET_IS_64BIT)
	{
		#if defined(_WIN32)
		{
			_fseeki64(f->cfile, pos, SEEK_SET);
			int res = ((int)(fwrite(buf.data, 1, buf.len, f->cfile)));
			if (res == 0 && buf.len != 0) {
				return (Option_int){ .state=2, .err=v_error(_SLIT("0 bytes written")) };
			}
			_fseeki64(f->cfile, 0, SEEK_END);
			Option_int _t119;
			opt_ok(&(int[]) { res }, (Option*)(&_t119), sizeof(int));
			return _t119;
		}
		#else
		{
		}
		#endif
	}
	#endif
	#if defined(TARGET_IS_32BIT)
	{
		fseek(f->cfile, pos, SEEK_SET);
		int res = ((int)(fwrite(buf.data, 1, buf.len, f->cfile)));
		if (res == 0 && buf.len != 0) {
			return (Option_int){ .state=2, .err=v_error(_SLIT("0 bytes written")) };
		}
		fseek(f->cfile, 0, SEEK_END);
		Option_int _t120;
		opt_ok(&(int[]) { res }, (Option*)(&_t120), sizeof(int));
		return _t120;
	}
	#endif
	return (Option_int){ .state=2, .err=v_error(_SLIT("Could not write to file")) };
}

// Attr: [deprecated]
// Attr: [unsafe]
int os__File_write_bytes(os__File* f, voidptr data, int size) {
	return os__File_write_ptr(f, data, size);
}

// Attr: [deprecated]
// Attr: [unsafe]
int os__File_write_bytes_at(os__File* f, voidptr data, int size, u64 pos) {
	return os__File_write_ptr_at(f, data, size, pos);
}

// Attr: [unsafe]
int os__File_write_ptr(os__File* f, voidptr data, int size) {
	return ((int)(fwrite(data, 1, size, f->cfile)));
}

// Attr: [unsafe]
int os__File_write_ptr_at(os__File* f, voidptr data, int size, u64 pos) {
	#if defined(TARGET_IS_64BIT)
	{
		#if defined(_WIN32)
		{
			_fseeki64(f->cfile, pos, SEEK_SET);
			int res = ((int)(fwrite(data, 1, size, f->cfile)));
			_fseeki64(f->cfile, 0, SEEK_END);
			return res;
		}
		#else
		{
		}
		#endif
	}
	#endif
	#if defined(TARGET_IS_32BIT)
	{
		fseek(f->cfile, pos, SEEK_SET);
		int res = ((int)(fwrite(data, 1, size, f->cfile)));
		fseek(f->cfile, 0, SEEK_END);
		return res;
	}
	#endif
	return 0;
}

Array_byte os__File_read_bytes(os__File* f, int size) {
	return os__File_read_bytes_at(f, size, 0);
}

Array_byte os__File_read_bytes_at(os__File* f, int size, u64 pos) {
	Array_byte arr = __new_array_with_default(size, 0, sizeof(byte), 0);
	Option_int _t121 = os__File_read_bytes_into(f, pos, &/*arr*/arr);
	if (_t121.state != 0) { /*or block*/ 
		IError err = _t121.err;
		return __new_array_with_default(0, 0, sizeof(byte), 0);
	}
 	int nreadbytes =  *(int*)_t121.data;
	return array_slice(arr, 0, nreadbytes);
}

Option_int os__File_read_bytes_into(os__File* f, u64 pos, Array_byte* buf) {
	if (buf->len == 0) {
		v_panic(string_add(_SLIT("read_bytes_into"), _SLIT(": `buf.len` == 0")));
	}
	#if defined(TARGET_IS_64BIT)
	{
		#if defined(_WIN32)
		{
			_fseeki64(f->cfile, pos, SEEK_SET);
			errno = 0;
			int nbytes = ((int)(fread(buf->data, 1, buf->len, f->cfile)));
			if (errno != 0) {
				return (Option_int){ .state=2, .err=v_error(os__posix_get_error_msg(errno)) };
			}
			Option_int _t122;
			opt_ok(&(int[]) { nbytes }, (Option*)(&_t122), sizeof(int));
			return _t122;
		}
		#else
		{
		}
		#endif
	}
	#endif
	#if defined(TARGET_IS_32BIT)
	{
		fseek(f->cfile, pos, SEEK_SET);
		errno = 0;
		int nbytes = ((int)(fread(buf->data, 1, buf->len, f->cfile)));
		if (errno != 0) {
			return (Option_int){ .state=2, .err=v_error(os__posix_get_error_msg(errno)) };
		}
		Option_int _t123;
		opt_ok(&(int[]) { nbytes }, (Option*)(&_t123), sizeof(int));
		return _t123;
	}
	#endif
	return (Option_int){ .state=2, .err=v_error(_SLIT("Could not read file")) };
}

Option_int os__File_read(os__File* f, Array_byte* buf) {
	if (buf->len == 0) {
		Option_int _t124;
		opt_ok(&(int[]) { 0 }, (Option*)(&_t124), sizeof(int));
		return _t124;
	}
	errno = 0;
	int nbytes = ((int)(fread(buf->data, 1, buf->len, f->cfile)));
	if (errno != 0) {
		return (Option_int){ .state=2, .err=v_error(os__posix_get_error_msg(errno)) };
	}
	Option_int _t125;
	opt_ok(&(int[]) { nbytes }, (Option*)(&_t125), sizeof(int));
	return _t125;
}

// Attr: [deprecated]
Option_int os__File_read_at(os__File* f, u64 pos, Array_byte* buf) {
	return os__File_read_from(f, pos, buf);
}

Option_int os__File_read_from(os__File* f, u64 pos, Array_byte* buf) {
	if (buf->len == 0) {
		Option_int _t126;
		opt_ok(&(int[]) { 0 }, (Option*)(&_t126), sizeof(int));
		return _t126;
	}
	#if defined(TARGET_IS_64BIT)
	{
		#if defined(_WIN32)
		{
			_fseeki64(f->cfile, pos, SEEK_SET);
		}
		#else
		{
		}
		#endif
		errno = 0;
		int nbytes = ((int)(fread(buf->data, 1, buf->len, f->cfile)));
		if (errno != 0) {
			return (Option_int){ .state=2, .err=v_error(os__posix_get_error_msg(errno)) };
		}
		Option_int _t127;
		opt_ok(&(int[]) { nbytes }, (Option*)(&_t127), sizeof(int));
		return _t127;
	}
	#endif
	#if defined(TARGET_IS_32BIT)
	{
		fseek(f->cfile, pos, SEEK_SET);
		errno = 0;
		int nbytes = ((int)(fread(buf->data, 1, buf->len, f->cfile)));
		if (errno != 0) {
			return (Option_int){ .state=2, .err=v_error(os__posix_get_error_msg(errno)) };
		}
		Option_int _t128;
		opt_ok(&(int[]) { nbytes }, (Option*)(&_t128), sizeof(int));
		return _t128;
	}
	#endif
	return (Option_int){ .state=2, .err=v_error(_SLIT("Could not read file")) };
}

void os__File_flush(os__File* f) {
	if (!f->is_opened) {
		return;
	}
	fflush(f->cfile);
}

// Attr: [deprecated]
Option_void os__File_write_str(os__File* f, string s) {
	Option_int _t129 = os__File_write_string(f, s);
	if (_t129.state != 0) { /*or block*/ 
		IError err = _t129.err;
		return (Option_void){ .state=2, .err=err };
	};
	return (Option_void){0};
}









os__FileMode os__inode(string path) {
	struct stat attr;
	stat(((char*)(path.str)), &attr);
	os__FileType typ = os__FileType_regular;
	if ((attr.st_mode & ((u32)(S_IFMT))) == ((u32)(S_IFDIR))) {
		typ = os__FileType_directory;
	}
	#if defined(_WIN32)
	{
		return (os__FileMode){.typ = typ,.owner = (os__FilePermission){.read = ((attr.st_mode & ((u32)(S_IREAD)))) != 0,.write = ((attr.st_mode & ((u32)(S_IWRITE)))) != 0,.execute = ((attr.st_mode & ((u32)(S_IEXEC)))) != 0,},.group = (os__FilePermission){.read = ((attr.st_mode & ((u32)(S_IREAD)))) != 0,.write = ((attr.st_mode & ((u32)(S_IWRITE)))) != 0,.execute = ((attr.st_mode & ((u32)(S_IEXEC)))) != 0,},.others = (os__FilePermission){.read = ((attr.st_mode & ((u32)(S_IREAD)))) != 0,.write = ((attr.st_mode & ((u32)(S_IWRITE)))) != 0,.execute = ((attr.st_mode & ((u32)(S_IEXEC)))) != 0,},};
	}
	#else
	{
	}
	#endif
	return (os__FileMode){0};
}

// Attr: [unsafe]
void os__Result_free(os__Result* result) {
	string_free(&result->output);
}

Option_void os__cp_all(string src, string dst, bool overwrite) {
	string source_path = os__real_path(src);
	string dest_path = os__real_path(dst);
	if (!os__exists(source_path)) {
		return (Option_void){ .state=2, .err=v_error(_SLIT("Source path doesn't exist")) };
	}
	if (!os__is_dir(source_path)) {
		string adjusted_path = (os__is_dir(dest_path) ? (os__join_path(dest_path, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){os__file_name(source_path)})))) : (dest_path));
		if (os__exists(adjusted_path)) {
			if (overwrite) {
				Option_void _t130 = os__rm(adjusted_path);
				if (_t130.state != 0 && _t130.err._typ != _IError_None___index) {
					Option_void _t131;
					memcpy(&_t131, &_t130, sizeof(Option));
					return _t131;
				};
			} else {
				return (Option_void){ .state=2, .err=v_error(_SLIT("Destination file path already exist")) };
			}
		}
		Option_void _t132 = os__cp(source_path, adjusted_path);
		if (_t132.state != 0 && _t132.err._typ != _IError_None___index) {
			Option_void _t133;
			memcpy(&_t133, &_t132, sizeof(Option));
			return _t133;
		};
		return (Option_void){0};
	}
	if (!os__exists(dest_path)) {
		Option_bool _t134 = os__mkdir(dest_path);
		if (_t134.state != 0) { /*or block*/ 
			Option_void _t135;
			memcpy(&_t135, &_t134, sizeof(Option));
			return _t135;
		};
	}
	if (!os__is_dir(dest_path)) {
		return (Option_void){ .state=2, .err=v_error(_SLIT("Destination path is not a valid directory")) };
	}
	Option_Array_string _t136 = os__ls(source_path);
	if (_t136.state != 0) { /*or block*/ 
		Option_void _t137;
		memcpy(&_t137, &_t136, sizeof(Option));
		return _t137;
	}
 	Array_string files =  *(Array_string*)_t136.data;
	// FOR IN array
	for (int _t138 = 0; _t138 < files.len; ++_t138) {
		string file = ((string*)files.data)[_t138];
		string sp = os__join_path(source_path, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){file})));
		string dp = os__join_path(dest_path, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){file})));
		if (os__is_dir(sp)) {
			if (!os__exists(dp)) {
				Option_bool _t139 = os__mkdir(dp);
				if (_t139.state != 0) { /*or block*/ 
					Option_void _t140;
					memcpy(&_t140, &_t139, sizeof(Option));
					return _t140;
				};
			}
		}
		Option_void _t141 = os__cp_all(sp, dp, overwrite);
		if (_t141.state != 0 && _t141.err._typ != _IError_None___index) {
			IError err = _t141.err;
			Option_void _t142 = os__rmdir(dp);
			if (_t142.state != 0 && _t142.err._typ != _IError_None___index) {
				err = _t142.err;
				return (Option_void){ .state=2, .err=err };
			};
			return (Option_void){ .state=2, .err=err };
		};
	}
	return (Option_void){0};
}

Option_void os__mv_by_cp(string source, string target) {
	Option_void _t143 = os__cp(source, target);
	if (_t143.state != 0 && _t143.err._typ != _IError_None___index) {
		Option_void _t144;
		memcpy(&_t144, &_t143, sizeof(Option));
		return _t144;
	};
	Option_void _t145 = os__rm(source);
	if (_t145.state != 0 && _t145.err._typ != _IError_None___index) {
		Option_void _t146;
		memcpy(&_t146, &_t145, sizeof(Option));
		return _t146;
	};
	return (Option_void){0};
}

Option_Array_string os__read_lines(string path) {
	Option_string _t147 = os__read_file(path);
	if (_t147.state != 0) { /*or block*/ 
		Option_Array_string _t148;
		memcpy(&_t148, &_t147, sizeof(Option));
		return _t148;
	}
 	string buf =  *(string*)_t147.data;
	Array_string res = string_split_into_lines(buf);
	string_free(&buf);
	Option_Array_string _t149;
	opt_ok(&(Array_string[]) { res }, (Option*)(&_t149), sizeof(Array_string));
	return _t149;
}

VV_LOCAL_SYMBOL Option_Array_ustring os__read_ulines(string path) {
	Option_Array_string _t150 = os__read_lines(path);
	if (_t150.state != 0) { /*or block*/ 
		Option_Array_ustring _t151;
		memcpy(&_t151, &_t150, sizeof(Option));
		return _t151;
	}
 	Array_string lines =  *(Array_string*)_t150.data;
	Array_ustring ulines = __new_array_with_default(0, 0, sizeof(ustring), 0);
	// FOR IN array
	for (int _t152 = 0; _t152 < lines.len; ++_t152) {
		string myline = ((string*)lines.data)[_t152];
		array_push(&ulines, _MOV((ustring[]){ string_ustring(myline) }));
	}
	Option_Array_ustring _t154;
	opt_ok(&(Array_ustring[]) { ulines }, (Option*)(&_t154), sizeof(Array_ustring));
	return _t154;
}

string os__sigint_to_signal_name(int si) {

	if (si == (1)) {
		return _SLIT("SIGHUP");
	}
	else if (si == (2)) {
		return _SLIT("SIGINT");
	}
	else if (si == (3)) {
		return _SLIT("SIGQUIT");
	}
	else if (si == (4)) {
		return _SLIT("SIGILL");
	}
	else if (si == (6)) {
		return _SLIT("SIGABRT");
	}
	else if (si == (8)) {
		return _SLIT("SIGFPE");
	}
	else if (si == (9)) {
		return _SLIT("SIGKILL");
	}
	else if (si == (11)) {
		return _SLIT("SIGSEGV");
	}
	else if (si == (13)) {
		return _SLIT("SIGPIPE");
	}
	else if (si == (14)) {
		return _SLIT("SIGALRM");
	}
	else if (si == (15)) {
		return _SLIT("SIGTERM");
	}
	else {
	};
	return _SLIT("unknown");
}

Option_void os__rmdir_all(string path) {
	string ret_err = _SLIT("");
	Option_Array_string _t155 = os__ls(path);
	if (_t155.state != 0) { /*or block*/ 
		Option_void _t156;
		memcpy(&_t156, &_t155, sizeof(Option));
		return _t156;
	}
 	Array_string items =  *(Array_string*)_t155.data;
	// FOR IN array
	for (int _t157 = 0; _t157 < items.len; ++_t157) {
		string item = ((string*)items.data)[_t157];
		string fullpath = os__join_path(path, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){item})));
		if (os__is_dir(fullpath)) {
			Option_void _t158 = os__rmdir_all(fullpath);
			if (_t158.state != 0 && _t158.err._typ != _IError_None___index) {
				IError err = _t158.err;
				ret_err = (*(err.msg));
			};
		} else {
			Option_void _t159 = os__rm(fullpath);
			if (_t159.state != 0 && _t159.err._typ != _IError_None___index) {
				IError err = _t159.err;
				ret_err = (*(err.msg));
			};
		}
	}
	Option_void _t160 = os__rmdir(path);
	if (_t160.state != 0 && _t160.err._typ != _IError_None___index) {
		IError err = _t160.err;
		ret_err = (*(err.msg));
	};
	if (ret_err.len > 0) {
		return (Option_void){ .state=2, .err=v_error(ret_err) };
	}
	return (Option_void){0};
}

bool os__is_dir_empty(string path) {
	Option_Array_string _t161 = os__ls(path);
	if (_t161.state != 0) { /*or block*/ 
		IError err = _t161.err;
		return true;
	}
 	Array_string items =  *(Array_string*)_t161.data;
	return items.len == 0;
}

string os__file_ext(string path) {
	Option_int _t162 = string_last_index(path, _SLIT("."));
	if (_t162.state != 0) { /*or block*/ 
		IError err = _t162.err;
		return _SLIT("");
	}
 	int pos =  *(int*)_t162.data;
	return string_substr(path, pos, path.len);
}

string os__dir(string path) {
	if ((path).len == 0) {
		return _SLIT(".");
	}
	Option_int _t163 = string_last_index(path, _const_os__path_separator);
	if (_t163.state != 0) { /*or block*/ 
		IError err = _t163.err;
		return _SLIT(".");
	}
 	int pos =  *(int*)_t163.data;
	return string_substr(path, 0, pos);
}

string os__base(string path) {
	if ((path).len == 0) {
		return _SLIT(".");
	}
	if (string_eq(path, _const_os__path_separator)) {
		return _const_os__path_separator;
	}
	if (string_ends_with(path, _const_os__path_separator)) {
		string path2 = string_substr(path, 0, path.len - 1);
		Option_int _t164 = string_last_index(path2, _const_os__path_separator);
		if (_t164.state != 0) { /*or block*/ 
			IError err = _t164.err;
			return string_clone(path2);
		}
 		int pos =  *(int*)_t164.data;
		return string_substr(path2, pos + 1, path2.len);
	}
	Option_int _t165 = string_last_index(path, _const_os__path_separator);
	if (_t165.state != 0) { /*or block*/ 
		IError err = _t165.err;
		return string_clone(path);
	}
 	int pos =  *(int*)_t165.data;
	return string_substr(path, pos + 1, path.len);
}

string os__file_name(string path) {
	return string_all_after_last(path, _const_os__path_separator);
}

Option_string os__input_opt(string prompt) {
	print(prompt);
	os__flush();
	string res = os__get_raw_line();
	if (res.len > 0) {
		Option_string _t166;
		opt_ok(&(string[]) { string_trim_right(res, _SLIT("\r\n")) }, (Option*)(&_t166), sizeof(string));
		return _t166;
	}
	return (Option_string){ .state=2, .err=_const_none__ };
}

string os__input(string prompt) {
	Option_string _t167 = os__input_opt(prompt);
	if (_t167.state != 0) { /*or block*/ 
		IError err = _t167.err;
		return _SLIT("<EOF>");
	}
 	string res =  *(string*)_t167.data;
	return res;
}

string os__get_line(void) {
	string str = os__get_raw_line();
	return string_trim_right(str, _SLIT("\r\n"));
	return string_trim_right(str, _SLIT("\n"));
}

Array_string os__get_lines(void) {
	string line = _SLIT("");
	Array_string inputstr = __new_array_with_default(0, 0, sizeof(string), 0);
	for (;;) {
		line = os__get_line();
		if (line.len <= 0) {
			break;
		}
		line = string_trim_space(line);
		array_push(&inputstr, _MOV((string[]){ line }));
	}
	return inputstr;
}

string os__get_lines_joined(void) {
	string line = _SLIT("");
	string inputstr = _SLIT("");
	for (;;) {
		line = os__get_line();
		if (line.len <= 0) {
			break;
		}
		line = string_trim_space(line);
		inputstr = /*f*/string_add(inputstr, line);
	}
	return inputstr;
}

string os__get_raw_lines_joined(void) {
	string line = _SLIT("");
	Array_string lines = __new_array_with_default(0, 0, sizeof(string), 0);
	for (;;) {
		line = os__get_raw_line();
		if (line.len <= 0) {
			break;
		}
		array_push(&lines, _MOV((string[]){ line }));
	}
	string res = Array_string_join(lines, _SLIT(""));
	return res;
}

string os__user_os(void) {
	return _SLIT("windows");
	return _SLIT("unknown");
}

string os__home_dir(void) {
	#if defined(_WIN32)
	{
		return os__getenv(_SLIT("USERPROFILE"));
	}
	#else
	{
	}
	#endif
	return (string){.str=(byteptr)"", .is_lit=1};
}

Option_void os__write_file(string path, string text) {
	Option_os__File _t170 = os__create(path);
	if (_t170.state != 0) { /*or block*/ 
		Option_void _t171;
		memcpy(&_t171, &_t170, sizeof(Option));
		return _t171;
	}
 	os__File f =  *(os__File*)_t170.data;
	Option_int _t172 = os__File_write_string(&f, text);
	if (_t172.state != 0) { /*or block*/ 
		Option_void _t173;
		memcpy(&_t173, &_t172, sizeof(Option));
		return _t173;
	};
	os__File_close(&f);
	return (Option_void){0};
}

Option_void os__write_file_array(string path, array buffer) {
	Option_os__File _t174 = os__create(path);
	if (_t174.state != 0) { /*or block*/ 
		Option_void _t175;
		memcpy(&_t175, &_t174, sizeof(Option));
		return _t175;
	}
 	os__File f =  *(os__File*)_t174.data;
	os__File_write_ptr_at(&f, buffer.data, (buffer.len * buffer.element_size), 0);
	os__File_close(&f);
	return (Option_void){0};
}

VV_LOCAL_SYMBOL string os__executable_fallback(void) {
	if (_const_os__args.len == 0) {
		return _SLIT("");
	}
	string exepath = (*(string*)/*ee elem_typ */array_get(_const_os__args, 0));
	if (!string_contains(exepath, _SLIT(".exe"))) {
		exepath = /*f*/string_add(exepath, _SLIT(".exe"));
	}
	if (!os__is_abs_path(exepath)) {
		if (string_contains(exepath, _const_os__path_separator)) {
			exepath = os__join_path(_const_os__wd_at_startup, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){exepath})));
		} else {
			Option_string _t176 = os__find_abs_path_of_executable(exepath);
			if (_t176.state != 0) { /*or block*/ 
				IError err = _t176.err;
				*(string*) _t176.data = _SLIT("");
			}
 			string foundpath =  *(string*)_t176.data;
			if (foundpath.len > 0) {
				exepath = foundpath;
			}
		}
	}
	exepath = os__real_path(exepath);
	return exepath;
}

Option_string os__find_abs_path_of_executable(string exepath) {
	if ((exepath).len == 0) {
		return (Option_string){ .state=2, .err=v_error(_SLIT("expected non empty `exepath`")) };
	}
	if (os__is_abs_path(exepath)) {
		Option_string _t177;
		opt_ok(&(string[]) { os__real_path(exepath) }, (Option*)(&_t177), sizeof(string));
		return _t177;
	}
	string res = _SLIT("");
	Array_string paths = string_split(os__getenv(_SLIT("PATH")), _const_os__path_delimiter);
	// FOR IN array
	for (int _t178 = 0; _t178 < paths.len; ++_t178) {
		string p = ((string*)paths.data)[_t178];
		string found_abs_path = os__join_path(p, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){exepath})));
		if (os__exists(found_abs_path) && os__is_executable(found_abs_path)) {
			res = found_abs_path;
			break;
		}
	}
	if (res.len > 0) {
		Option_string _t179;
		opt_ok(&(string[]) { os__real_path(res) }, (Option*)(&_t179), sizeof(string));
		return _t179;
	}
	return (Option_string){ .state=2, .err=v_error(_SLIT("failed to find executable")) };
}

bool os__exists_in_system_path(string prog) {
	Option_string _t180 = os__find_abs_path_of_executable(prog);
	if (_t180.state != 0) { /*or block*/ 
		IError err = _t180.err;
		return false;
	};
	return true;
}

bool os__is_file(string path) {
	return os__exists(path) && !os__is_dir(path);
}

bool os__is_abs_path(string path) {
	return string_at(path, 0) == L'/' || (byte_is_letter(string_at(path, 0)) && string_at(path, 1) == L':');
	return string_at(path, 0) == L'/';
}

// Attr: [manualfree]
string os__join_path(string base, Array_string dirs) {
	Array_string result = __new_array_with_default(0, 0, sizeof(string), 0);
	array_push(&result, _MOV((string[]){ string_trim_right(base, _SLIT("\\/")) }));
	// FOR IN array
	for (int _t182 = 0; _t182 < dirs.len; ++_t182) {
		string d = ((string*)dirs.data)[_t182];
		array_push(&result, _MOV((string[]){ d }));
	}
	string res = Array_string_join(result, _const_os__path_separator);
	array_free(&result);
	return res;
}

Array_string os__walk_ext(string path, string ext) {
	if (!os__is_dir(path)) {
		return __new_array_with_default(0, 0, sizeof(string), 0);
	}
	Option_Array_string _t184 = os__ls(path);
	if (_t184.state != 0) { /*or block*/ 
		IError err = _t184.err;
		return __new_array_with_default(0, 0, sizeof(string), 0);
	}
 	Array_string files =  *(Array_string*)_t184.data;
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	string separator = (string_ends_with(path, _const_os__path_separator) ? (_SLIT("")) : (_const_os__path_separator));
	// FOR IN array
	for (int _t185 = 0; _t185 < files.len; ++_t185) {
		string file = ((string*)files.data)[_t185];
		if (string_starts_with(file, _SLIT("."))) {
			continue;
		}
		string p = string_add(string_add(path, separator), file);
		if (os__is_dir(p) && !os__is_link(p)) {
			_PUSH_MANY(&res, (os__walk_ext(p, ext)), _t186, Array_string);
		} else if (string_ends_with(file, ext)) {
			array_push(&res, _MOV((string[]){ p }));
		}
	}
	return res;
}

void os__walk(string path, void (*f)(string )) {
	if (!os__is_dir(path)) {
		return;
	}
	Option_Array_string _t188 = os__ls(path);
	if (_t188.state != 0) { /*or block*/ 
		IError err = _t188.err;
		return;
	}
 	Array_string files =  *(Array_string*)_t188.data;
	string local_path_separator = _const_os__path_separator;
	if (string_ends_with(path, _const_os__path_separator)) {
		local_path_separator = _SLIT("");
	}
	// FOR IN array
	for (int _t189 = 0; _t189 < files.len; ++_t189) {
		string file = ((string*)files.data)[_t189];
		string p = string_add(string_add(path, local_path_separator), file);
		if (os__is_dir(p) && !os__is_link(p)) {
			os__walk(p, f);
		} else if (os__exists(p)) {
			f(p);
		}
	}
	return;
}

void os__log(string s) {
	println(string_add(_SLIT("os.log: "), s));
}

Option_void os__mkdir_all(string path) {
	string p = (string_starts_with(path, _const_os__path_separator) ? (_const_os__path_separator) : (_SLIT("")));
	Array_string path_parts = string_split(string_trim_left(path, _const_os__path_separator), _const_os__path_separator);
	// FOR IN array
	for (int _t190 = 0; _t190 < path_parts.len; ++_t190) {
		string subdir = ((string*)path_parts.data)[_t190];
		p = /*f*/string_add(p, string_add(subdir, _const_os__path_separator));
		if (os__exists(p) && os__is_dir(p)) {
			continue;
		}
		Option_bool _t191 = os__mkdir(p);
		if (_t191.state != 0) { /*or block*/ 
			IError err = _t191.err;
			return (Option_void){ .state=2, .err=v_error(_STR("folder: %.*s\000, error: %.*s", 2, p, IError_str(err))) };
		};
	}
	return (Option_void){0};
}

string os__cache_dir(void) {
	string cdir = os__join_path(os__home_dir(), new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT(".cache")})));
	if (!os__is_dir(cdir) && !os__is_link(cdir)) {
		Option_bool _t192 = os__mkdir(cdir);
		if (_t192.state != 0) { /*or block*/ 
			IError err = _t192.err;
			v_panic(IError_str(err));
		};
	}
	return cdir;
}

string os__temp_dir(void) {
	string path = os__getenv(_SLIT("TMPDIR"));
	if ((path).len == 0) {
		path = os__getenv(_SLIT("TEMP"));
		if ((path).len == 0) {
			path = os__getenv(_SLIT("TMP"));
		}
		if ((path).len == 0) {
			path = _SLIT("C:/tmp");
		}
	}
	if ((path).len == 0) {
		path = _SLIT("/tmp");
	}
	return path;
}

VV_LOCAL_SYMBOL string os__default_vmodules_path(void) {
	return os__join_path(os__home_dir(), new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT(".vmodules")})));
}

string os__vmodules_dir(void) {
	Array_string paths = os__vmodules_paths();
	if (paths.len > 0) {
		return (*(string*)/*ee elem_typ */array_get(paths, 0));
	}
	return os__default_vmodules_path();
}

Array_string os__vmodules_paths(void) {
	string path = os__getenv(_SLIT("VMODULES"));
	if ((path).len == 0) {
		path = os__default_vmodules_path();
	}
	Array_string _t193_orig = string_split(path, _const_os__path_delimiter);
	int _t193_len = _t193_orig.len;
	Array_string _t193 = __new_array(0, _t193_len, sizeof(string));

	for (int _t194 = 0; _t194 < _t193_len; ++_t194) {
		string it = ((string*) _t193_orig.data)[_t194];
		string ti = string_trim_right(it, _const_os__path_separator);
		array_push(&_t193, &ti);
	}
	
	Array_string list = _t193;
	return list;
}

// Attr: [manualfree]
string os__resource_abs_path(string path) {
	string exe = os__executable();
	string dexe = os__dir(exe);
	string base_path = os__real_path(dexe);
	string vresource = os__getenv(_SLIT("V_RESOURCE_PATH"));
	if (vresource.len != 0) {
		base_path = vresource;
	}
	string fp = os__join_path(base_path, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){path})));
	string res = os__real_path(fp);
	{ // Unsafe block
		string_free(&fp);
		string_free(&base_path);
	}
	return res;
}

// Attr: [deprecated]
Option_os__Result os__exec(string cmd) {
	os__Result res = os__execute(cmd);
	if (res.exit_code < 0) {
		return (Option_os__Result){ .state=2, .err=error_with_code(res.output, -1) };
	}
	Option_os__Result _t195;
	opt_ok(&(os__Result[]) { res }, (Option*)(&_t195), sizeof(os__Result));
	return _t195;
}

os__Result os__execute_or_panic(string cmd) {
	os__Result res = os__execute(cmd);
	if (res.exit_code != 0) {
		eprintln(_STR("failed    cmd: %.*s", 1, cmd));
		eprintln(_STR("failed   code: %"PRId32"", 1, res.exit_code));
		v_panic(res.output);
	}
	return res;
}

// TypeDecl
// Attr: [manualfree]
Option_Array_byte os__read_bytes(string path) {
	Option_FILE_ptr _t196 = os__vfopen(path, _SLIT("rb"));
	if (_t196.state != 0) { /*or block*/ 
		Option_Array_byte _t197;
		memcpy(&_t197, &_t196, sizeof(Option));
		return _t197;
	}
 	FILE* fp =  *(FILE**)_t196.data;
	int cseek = fseek(fp, 0, SEEK_END);
	if (cseek != 0) {
		return (Option_Array_byte){ .state=2, .err=v_error(_SLIT("fseek failed")) };
	}
	int fsize = ftell(fp);
	if (fsize < 0) {
		return (Option_Array_byte){ .state=2, .err=v_error(_SLIT("ftell failed")) };
	}
	rewind(fp);
	Array_byte res = __new_array_with_default(fsize, 0, sizeof(byte), 0);
	int nr_read_elements = ((int)(fread(res.data, fsize, 1, fp)));
	if (nr_read_elements == 0 && fsize > 0) {
		return (Option_Array_byte){ .state=2, .err=v_error(_SLIT("fread failed")) };
	}
	fclose(fp);
	Array_byte fres = array_clone_static(array_slice(res, 0, nr_read_elements * fsize));
	array_free(&res);
	Option_Array_byte _t198;
	opt_ok(&(Array_byte[]) { fres }, (Option*)(&_t198), sizeof(Array_byte));
	return _t198;
}

Option_string os__read_file(string path) {
bool os__read_file_defer_0 = false;
	string mode = _SLIT("rb");
	Option_FILE_ptr _t199 = os__vfopen(path, mode);
	if (_t199.state != 0) { /*or block*/ 
		Option_string _t200;
		memcpy(&_t200, &_t199, sizeof(Option));
		return _t200;
	}
 	FILE* fp =  *(FILE**)_t199.data;
	os__read_file_defer_0 = true;
	int cseek = fseek(fp, 0, SEEK_END);
	if (cseek != 0) {
		// Defer begin
		if (os__read_file_defer_0 == true) {
			fclose(fp);
		}
		// Defer end
		return (Option_string){ .state=2, .err=v_error(_SLIT("fseek failed")) };
	}
	int fsize = ftell(fp);
	if (fsize < 0) {
		// Defer begin
		if (os__read_file_defer_0 == true) {
			fclose(fp);
		}
		// Defer end
		return (Option_string){ .state=2, .err=v_error(_SLIT("ftell failed")) };
	}
	rewind(fp);
	{ // Unsafe block
		byte* str = v_malloc(fsize + 1);
		int nelements = ((int)(fread(str, fsize, 1, fp)));
		if (nelements == 0 && fsize > 0) {
			v_free(str);
			// Defer begin
			if (os__read_file_defer_0 == true) {
				fclose(fp);
			}
			// Defer end
			return (Option_string){ .state=2, .err=v_error(_SLIT("fread failed")) };
		}
		str[fsize] = 0;
		// Defer begin
		if (os__read_file_defer_0 == true) {
			fclose(fp);
		}
		// Defer end
		Option_string _t201;
		opt_ok(&(string[]) { byte_vstring_with_len(str, fsize) }, (Option*)(&_t201), sizeof(string));
		return _t201;
	}
	return (Option_string){0};
}

u64 os__file_size(string path) {
	struct stat s;
	{ // Unsafe block
		#if defined(TARGET_IS_64BIT)
		{
			#if defined(_WIN32)
			{
				struct __stat64 swin = (struct __stat64){.st_size = 0,.st_mode = 0,.st_mtime = 0,};
				_wstat64(((char*)(string_to_wide(path))), ((voidptr)(&swin)));
				return swin.st_size;
			}
			#else
			{
			}
			#endif
		}
		#endif
		#if defined(TARGET_IS_32BIT)
		{
			#if defined(_WIN32)
			{
				_wstat(string_to_wide(path), ((voidptr)(&s)));
				return ((u64)(s.st_size));
			}
			#else
			{
			}
			#endif
		}
		#endif
	}
	return 0;
}

Option_void os__mv(string src, string dst) {
	string rdst = dst;
	if (os__is_dir(rdst)) {
		rdst = os__join_path(string_trim_right(rdst, _const_os__path_separator), new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){os__file_name(string_trim_right(src, _const_os__path_separator))})));
	}
	#if defined(_WIN32)
	{
		string w_src = string_replace(src, _SLIT("/"), _SLIT("\\"));
		string w_dst = string_replace(rdst, _SLIT("/"), _SLIT("\\"));
		int ret = _wrename(string_to_wide(w_src), string_to_wide(w_dst));
		if (ret != 0) {
			return (Option_void){ .state=2, .err=error_with_code(_STR("failed to rename %.*s\000 to %.*s", 2, src, dst), ((int)(ret))) };
		}
	}
	#else
	{
	}
	#endif
	return (Option_void){0};
}

Option_void os__cp(string src, string dst) {
	#if defined(_WIN32)
	{
		string w_src = string_replace(src, _SLIT("/"), _SLIT("\\"));
		string w_dst = string_replace(dst, _SLIT("/"), _SLIT("\\"));
		if (CopyFile(string_to_wide(w_src), string_to_wide(w_dst), false) == 0) {
			u32 result = GetLastError();
			return (Option_void){ .state=2, .err=error_with_code(_STR("failed to copy %.*s\000 to %.*s", 2, src, dst), ((int)(result))) };
		}
	}
	#else
	{
	}
	#endif
	return (Option_void){0};
}

Option_FILE_ptr os__vfopen(string path, string mode) {
	if (path.len == 0) {
		return (Option_FILE_ptr){ .state=2, .err=v_error(_SLIT("vfopen called with \"\"")) };
	}
	voidptr fp = ((voidptr)(0));
	#if defined(_WIN32)
	{
		fp = _wfopen(string_to_wide(path), string_to_wide(mode));
	}
	#else
	{
	}
	#endif
	if (isnil(fp)) {
		return (Option_FILE_ptr){ .state=2, .err=v_error(_STR("failed to open file \"%.*s\000\"", 2, path)) };
	} else {
		Option_FILE_ptr _t202;
		opt_ok(&(FILE*[]) { fp }, (Option*)(&_t202), sizeof(FILE*));
		return _t202;
	}
	return (Option_FILE_ptr){0};
}

int os__fileno(voidptr cfile) {
	#if defined(_WIN32)
	{
		return _fileno(cfile);
	}
	#else
	{
	}
	#endif
	return 0;
}

VV_LOCAL_SYMBOL voidptr os__vpopen(string path) {
	#if defined(_WIN32)
	{
		string mode = _SLIT("rb");
		u16* wpath = string_to_wide(path);
		return _wpopen(wpath, string_to_wide(mode));
	}
	#else
	{
	}
	#endif
	return 0;
}

VV_LOCAL_SYMBOL multi_return_int_bool os__posix_wait4_to_exit_status(int waitret) {
	#if defined(_WIN32)
	{
		return (multi_return_int_bool){.arg0=waitret, .arg1=false};
	}
	#else
	{
	}
	#endif
	return (multi_return_int_bool){0};
}

string os__posix_get_error_msg(int code) {
	char* ptr_text = strerror(code);
	if (ptr_text == 0) {
		return _SLIT("");
	}
	return tos3(ptr_text);
}

VV_LOCAL_SYMBOL int os__vpclose(voidptr f) {
	#if defined(_WIN32)
	{
		return _pclose(f);
	}
	#else
	{
	}
	#endif
	return 0;
}

int os__system(string cmd) {
	int ret = 0;
	#if defined(_WIN32)
	{
		string wcmd = (cmd.len > 1 && string_at(cmd, 0) == L'"' && string_at(cmd, 1) != L'"' ? (_STR("\"%.*s\000\"", 2, cmd)) : (cmd));
		{ // Unsafe block
			ret = _wsystem(string_to_wide(wcmd));
		}
	}
	#else
	{
	}
	#endif
	if (ret == -1) {
		os__print_c_errno();
	}
	return ret;
}

bool os__exists(string path) {
	#if defined(_WIN32)
	{
		string p = string_replace(path, _SLIT("/"), _SLIT("\\"));
		return _waccess(string_to_wide(p), _const_os__f_ok) != -1;
	}
	#else
	{
	}
	#endif
	return 0;
}

bool os__is_executable(string path) {
	string p = os__real_path(path);
	return (os__exists(p) && string_ends_with(p, _SLIT(".exe")));
	return access(((char*)(path.str)), _const_os__x_ok) != -1;
}

bool os__is_writable(string path) {
	#if defined(_WIN32)
	{
		string p = string_replace(path, _SLIT("/"), _SLIT("\\"));
		return _waccess(string_to_wide(p), _const_os__w_ok) != -1;
	}
	#else
	{
	}
	#endif
	return 0;
}

bool os__is_readable(string path) {
	#if defined(_WIN32)
	{
		string p = string_replace(path, _SLIT("/"), _SLIT("\\"));
		return _waccess(string_to_wide(p), _const_os__r_ok) != -1;
	}
	#else
	{
	}
	#endif
	return 0;
}

Option_void os__rm(string path) {
	int rc = 0;
	#if defined(_WIN32)
	{
		rc = _wremove(string_to_wide(path));
	}
	#else
	{
	}
	#endif
	if (rc == -1) {
		return (Option_void){ .state=2, .err=v_error(string_add(_STR("Failed to remove \"%.*s\000\": ", 2, path), os__posix_get_error_msg(errno))) };
	}
	return (Option_void){0};
}

Option_void os__rmdir(string path) {
	#if defined(_WIN32)
	{
		int rc = RemoveDirectory(((char*)(string_to_wide(path))));
		if (rc == 0) {
			return (Option_void){ .state=2, .err=v_error(string_add(_STR("Failed to remove \"%.*s\000\": ", 2, path), os__posix_get_error_msg(errno))) };
		}
	}
	#else
	{
	}
	#endif
	return (Option_void){0};
}

VV_LOCAL_SYMBOL void os__print_c_errno(void) {
	int e = errno;
	string se = tos_clone(((byte*)(strerror(errno))));
	println(_STR("errno=%"PRId32"\000 err=%.*s", 2, e, se));
}

string os__get_raw_line(void) {
	#if defined(_WIN32)
	{
		{ // Unsafe block
			int max_line_chars = 256;
			byte* buf = v_malloc(max_line_chars * 2);
			voidptr h_input = GetStdHandle(STD_INPUT_HANDLE);
			u32 bytes_read = ((u32)(0U));
			if (is_atty(0) > 0) {
				bool x = ReadConsole(h_input, buf, max_line_chars * 2, &bytes_read, 0);
				if (!x) {
					return tos(buf, 0);
				}
				return string_from_wide2(((u16*)(buf)), ((int)(bytes_read)));
			}
			int offset = 0;
			for (;;) {
				byte* pos = buf + offset;
				bool res = ReadFile(h_input, pos, 1, ((LPDWORD)(&bytes_read)), 0);
				if (!res && offset == 0) {
					return tos(buf, 0);
				}
				if (!res || bytes_read == 0) {
					break;
				}
				if (*pos == L'\n' || *pos == L'\r') {
					offset++;
					break;
				}
				offset++;
			}
			return byte_vstring_with_len(buf, offset);
		}
	}
	#else
	{
	}
	#endif
	return (string){.str=(byteptr)"", .is_lit=1};
}

Array_byte os__get_raw_stdin(void) {
	#if defined(_WIN32)
	{
		{ // Unsafe block
			int block_bytes = 512;
			int old_size = block_bytes;
			byte* buf = v_malloc(block_bytes);
			voidptr h_input = GetStdHandle(STD_INPUT_HANDLE);
			int bytes_read = 0;
			int offset = 0;
			for (;;) {
				byte* pos = buf + offset;
				bool res = ReadFile(h_input, pos, block_bytes, ((LPDWORD)(&bytes_read)), 0);
				offset += bytes_read;
				if (!res) {
					break;
				}
				int new_size = offset + block_bytes + (block_bytes - bytes_read);
				buf = realloc_data(buf, old_size, new_size);
				old_size = new_size;
			}
			return (array){.element_size = 1,.data = ((voidptr)(buf)),.len = offset,.cap = offset,};
		}
	}
	#else
	{
	}
	#endif
	return __new_array(0, 1, sizeof(byte));
}


void os__on_segfault(voidptr f) {
	return;
}

// Attr: [manualfree]
string os__executable(void) {
	int max = 512;
	int size = max * 2;
	u16* result = ((u16*)(vcalloc(size)));
	int len = GetModuleFileName(0, result, max);
	u32 attrs = GetFileAttributesW(result);
	u32 is_set = (attrs & 0x400);
	if (is_set != 0) {
		voidptr file = CreateFile(result, 0x80000000, 1, 0, 3, 0x80, 0);
		if (file != ((voidptr)(-1))) {
			u16* final_path = ((u16*)(vcalloc(size)));
			int final_len = GetFinalPathNameByHandleW(file, final_path, size, 0);
			if (final_len < size) {
				string ret = string_from_wide2(final_path, final_len);
				return string_substr(ret, 4, ret.len);
			} else {
				eprintln(_SLIT("os.executable() saw that the executable file path was too long"));
			}
		}
		CloseHandle(file);
	}
	return string_from_wide2(result, len);
	return os__executable_fallback();
}

bool os__is_dir(string path) {
	#if defined(_WIN32)
	{
		string w_path = string_replace(path, _SLIT("/"), _SLIT("\\"));
		u32 attr = GetFileAttributesW(string_to_wide(w_path));
		if (attr == ((u32)(INVALID_FILE_ATTRIBUTES))) {
			return false;
		}
		if ((((int)(attr)) & FILE_ATTRIBUTE_DIRECTORY) != 0) {
			return true;
		}
		return false;
	}
	#else
	{
	}
	#endif
	return 0;
}

bool os__is_link(string path) {
	#if defined(_WIN32)
	{
		return false;
	}
	#else
	{
	}
	#endif
	return 0;
}

void os__chdir(string path) {
	#if defined(_WIN32)
	{
		_wchdir(string_to_wide(path));
	}
	#else
	{
	}
	#endif
}

string os__getwd(void) {
	#if defined(_WIN32)
	{
		int max = 512;
		{ // Unsafe block
			u16* buf = ((u16*)(vcalloc(max * 2)));
			if (_wgetcwd(buf, max) == 0) {
				v_free(buf);
				return _SLIT("");
			}
			return string_from_wide(buf);
		}
	}
	#else
	{
	}
	#endif
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [manualfree]
string os__real_path(string fpath) {
bool os__real_path_defer_0 = false;
	byte* fullpath = ((byte*)(0));
	os__real_path_defer_0 = true;
	#if defined(_WIN32)
	{
		fullpath = ((u16*)(vcalloc(_const_os__max_path_len * 2)));
		u32 ret = GetFullPathName(string_to_wide(fpath), _const_os__max_path_len, fullpath, 0);
		if (ret == 0) {
			// Defer begin
			if (os__real_path_defer_0 == true) {
				v_free(fullpath);
			}
			// Defer end
			return fpath;
		}
	}
	#else
	{
	}
	#endif
	string res = _SLIT("");
	#if defined(_WIN32)
	{
		res = string_from_wide(fullpath);
	}
	#else
	{
	}
	#endif
	string nres = os__normalize_drive_letter(res);
	string cres = string_clone(nres);
	// Defer begin
	if (os__real_path_defer_0 == true) {
		v_free(fullpath);
	}
	// Defer end
	return cres;
}

VV_LOCAL_SYMBOL string os__normalize_drive_letter(string path) {
	if (path.len > 2 && string_at(path, 0) >= L'a' && string_at(path, 0) <= L'z' && string_at(path, 1) == L':' && string_at(path, 2) == string_at(_const_os__path_separator, 0)) {
		{ // Unsafe block
			byte* x = &path.str[0];
			(*x) = *x - 32;
		}
	}
	return path;
}

voidptr os__signal(int signum, voidptr handler) {
	voidptr res = signal(signum, handler);
	return res;
}

int os__fork(void) {
	int pid = -1;
	v_panic(_SLIT("os.fork not supported in windows"));
	return pid;
}

int os__wait(void) {
	int pid = -1;
	v_panic(_SLIT("os.wait not supported in windows"));
	return pid;
}

int os__file_last_mod_unix(string path) {
	struct stat attr;
	stat(((char*)(path.str)), &attr);
	return attr.st_mtime;
}

void os__flush(void) {
	fflush(stdout);
}

void os__chmod(string path, int mode) {
	chmod(((char*)(path.str)), mode);
}

Option_os__File os__open_append(string path) {
	os__File file = (os__File){.cfile = 0,.fd = 0,.is_opened = 0,};
	#if defined(_WIN32)
	{
		u16* wpath = string_to_wide(string_replace(path, _SLIT("/"), _SLIT("\\")));
		string mode = _SLIT("ab");
		file = (os__File){.cfile = _wfopen(wpath, string_to_wide(mode)),.fd = 0,.is_opened = 0,};
	}
	#else
	{
	}
	#endif
	if (isnil(file.cfile)) {
		return (Option_os__File){ .state=2, .err=v_error(_STR("failed to create(append) file \"%.*s\000\"", 2, path)) };
	}
	file.is_opened = true;
	Option_os__File _t203;
	opt_ok(&(os__File[]) { file }, (Option*)(&_t203), sizeof(os__File));
	return _t203;
}

Option_void os__execvp(string cmdpath, Array_string args) {
	Array_char_ptr cargs = __new_array_with_default(0, 0, sizeof(char*), 0);
	array_push(&cargs, _MOV((char*[]){ ((char*)(cmdpath.str)) }));
	for (int i = 0; i < args.len; ++i) {
		array_push(&cargs, _MOV((char*[]){ ((char*)((*(string*)/*ee elem_typ */array_get(args, i)).str)) }));
	}
	array_push(&cargs, _MOV((char*[]){ ((char*)(0)) }));
	int res = ((int)(0));
	#if defined(_WIN32)
	{
		res = _execvp(((char*)(cmdpath.str)), cargs.data);
	}
	#else
	{
	}
	#endif
	if (res == -1) {
		return (Option_void){ .state=2, .err=error_with_code(os__posix_get_error_msg(errno), errno) };
	}
	v_exit(res);
	return (Option_void){0};
}

Option_void os__execve(string cmdpath, Array_string args, Array_string envs) {
	Array_char_ptr cargv = __new_array_with_default(0, 0, sizeof(char*), 0);
	Array_char_ptr cenvs = __new_array_with_default(0, 0, sizeof(char*), 0);
	array_push(&cargv, _MOV((char*[]){ ((char*)(cmdpath.str)) }));
	for (int i = 0; i < args.len; ++i) {
		array_push(&cargv, _MOV((char*[]){ ((char*)((*(string*)/*ee elem_typ */array_get(args, i)).str)) }));
	}
	for (int i = 0; i < envs.len; ++i) {
		array_push(&cenvs, _MOV((char*[]){ ((char*)((*(string*)/*ee elem_typ */array_get(envs, i)).str)) }));
	}
	array_push(&cargv, _MOV((char*[]){ ((char*)(0)) }));
	array_push(&cenvs, _MOV((char*[]){ ((char*)(0)) }));
	int res = ((int)(0));
	#if defined(_WIN32)
	{
		res = _execve(((char*)(cmdpath.str)), cargv.data, cenvs.data);
	}
	#else
	{
	}
	#endif
	if (res == -1) {
		return (Option_void){ .state=2, .err=error_with_code(os__posix_get_error_msg(errno), errno) };
	}
	return (Option_void){0};
}

// TypeDecl
// TypeDecl
VV_LOCAL_SYMBOL Array_string os__init_os_args_wide(int argc, byte** argv) {
	Array_string args_ = __new_array_with_default(0, 0, sizeof(string), 0);
	for (int i = 0; i < argc; ++i) {
		array_push(&args_, _MOV((string[]){ string_from_wide(((u16*)(argv[i]))) }));
	}
	return args_;
}

Option_Array_string os__ls(string path) {
	os__Win32finddata find_file_data = (os__Win32finddata){.dw_file_attributes = 0,.ft_creation_time = {0},.ft_last_access_time = {0},.ft_last_write_time = {0},.n_file_size_high = 0,.n_file_size_low = 0,.dw_reserved0 = 0,.dw_reserved1 = 0,.c_file_name = {0},.c_alternate_file_name = {0},.dw_file_type = 0,.dw_creator_type = 0,.w_finder_flags = 0,};
	Array_string dir_files = __new_array_with_default(0, 0, sizeof(string), 0);
	if (!os__is_dir(path)) {
		return (Option_Array_string){ .state=2, .err=v_error(_STR("ls() couldnt open dir \"%.*s\000\": directory does not exist", 2, path)) };
	}
	string path_files = _STR("%.*s\000\\*", 2, path);
	voidptr h_find_files = FindFirstFile(string_to_wide(path_files), ((voidptr)(&find_file_data)));
	string first_filename = string_from_wide(&find_file_data.c_file_name[0]);
	if (string_ne(first_filename, _SLIT(".")) && string_ne(first_filename, _SLIT(".."))) {
		array_push(&dir_files, _MOV((string[]){ first_filename }));
	}
	for (;;) {
		if (!(FindNextFile(h_find_files, ((voidptr)(&find_file_data))) > 0)) break;
		string filename = string_from_wide(&find_file_data.c_file_name[0]);
		if (string_ne(filename, _SLIT(".")) && string_ne(filename, _SLIT(".."))) {
			array_push(&dir_files, _MOV((string[]){ string_clone(filename) }));
		}
	}
	FindClose(h_find_files);
	Option_Array_string _t215;
	opt_ok(&(Array_string[]) { dir_files }, (Option*)(&_t215), sizeof(Array_string));
	return _t215;
}

Option_bool os__mkdir(string path) {
	if (string_eq(path, _SLIT("."))) {
		Option_bool _t216;
		opt_ok(&(bool[]) { true }, (Option*)(&_t216), sizeof(bool));
		return _t216;
	}
	string apath = os__real_path(path);
	if (!CreateDirectory(string_to_wide(apath), 0)) {
		return (Option_bool){ .state=2, .err=v_error(string_add(_STR("mkdir failed for \"%.*s\000\", because CreateDirectory returned ", 2, apath), os__get_error_msg(((int)(GetLastError()))))) };
	}
	Option_bool _t217;
	opt_ok(&(bool[]) { true }, (Option*)(&_t217), sizeof(bool));
	return _t217;
}

os__HANDLE os__get_file_handle(string path) {
	Option_FILE_ptr _t218 = os__vfopen(path, _SLIT("rb"));
	if (_t218.state != 0) { /*or block*/ 
		IError err = _t218.err;
		return ((_const_os__invalid_handle_value));
	}
 	FILE* cfile =  *(FILE**)_t218.data;
	os__HANDLE handle = ((os__HANDLE)(_get_osfhandle(os__fileno(cfile))));
	return handle;
}

Option_string os__get_module_filename(os__HANDLE handle) {
	{ // Unsafe block
		int sz = 4096;
		u16* buf = ((u16*)(v_malloc(4096)));
		for (;;) {
			int status = ((int)(GetModuleFileNameW(handle, ((voidptr)(&buf)), sz)));

			if (status == (_const_os__success)) {
				Option_string _t219;
				opt_ok(&(string[]) { string_from_wide2(buf, sz) }, (Option*)(&_t219), sizeof(string));
				return _t219;
			}
			else {
				return (Option_string){ .state=2, .err=v_error(_SLIT("Cannot get file name from handle")) };
			};
		}
	}
	v_panic(_SLIT("this should be unreachable"));
	return (Option_string){0};
}

VV_LOCAL_SYMBOL voidptr os__ptr_win_get_error_msg(u32 code) {
	voidptr buf = ((voidptr)(0));
	if (code > ((u32)(_const_os__max_error_code))) {
		return buf;
	}
	FormatMessage(((_const_os__format_message_allocate_buffer | _const_os__format_message_from_system) | _const_os__format_message_ignore_inserts), 0, code, MAKELANGID(_const_os__lang_neutral, _const_os__sublang_default), ((voidptr)(&buf)), 0, 0);
	return buf;
}

string os__get_error_msg(int code) {
	if (code < 0) {
		return _SLIT("");
	}
	voidptr ptr_text = os__ptr_win_get_error_msg(((u32)(code)));
	if (ptr_text == 0) {
		return _SLIT("");
	}
	return string_from_wide(ptr_text);
}

os__Result os__execute(string cmd) {
	if (string_contains(cmd, _SLIT(";")) || string_contains(cmd, _SLIT("&&")) || string_contains(cmd, _SLIT("||")) || string_contains(cmd, _SLIT("\n"))) {
		return (os__Result){.exit_code = -1,.output = _SLIT(";, &&, || and \\n are not allowed in shell commands"),};
	}
	u32* child_stdin = ((u32*)(0));
	u32* child_stdout_read = ((u32*)(0));
	u32* child_stdout_write = ((u32*)(0));
	os__SecurityAttributes sa = (os__SecurityAttributes){.n_length = 0,.lp_security_descriptor = 0,.b_inherit_handle = 0,};
	sa.n_length = /*SizeOf*/ sizeof(SECURITY_ATTRIBUTES);
	sa.b_inherit_handle = true;
	bool create_pipe_ok = CreatePipe(((voidptr)(&child_stdout_read)), ((voidptr)(&child_stdout_write)), ((voidptr)(&sa)), 0);
	if (!create_pipe_ok) {
		int error_num = ((int)(GetLastError()));
		string error_msg = os__get_error_msg(error_num);
		return (os__Result){.exit_code = error_num,.output = _STR("exec failed (CreatePipe): %.*s", 1, error_msg),};
	}
	bool set_handle_info_ok = SetHandleInformation(child_stdout_read, HANDLE_FLAG_INHERIT, 0);
	if (!set_handle_info_ok) {
		int error_num = ((int)(GetLastError()));
		string error_msg = os__get_error_msg(error_num);
		return (os__Result){.exit_code = error_num,.output = _STR("exec failed (SetHandleInformation): %.*s", 1, error_msg),};
	}
	os__ProcessInformation proc_info = (os__ProcessInformation){.h_process = 0,.h_thread = 0,.dw_process_id = 0,.dw_thread_id = 0,};
	os__StartupInfo start_info = (os__StartupInfo){
		.cb = /*SizeOf*/ sizeof(PROCESS_INFORMATION),
		.lp_reserved = 0,
		.lp_desktop = 0,
		.lp_title = 0,
		.dw_x = 0,
		.dw_y = 0,
		.dw_x_size = 0,
		.dw_y_size = 0,
		.dw_x_count_chars = 0,
		.dw_y_count_chars = 0,
		.dw_fill_attributes = 0,
		.dw_flags = ((u32)(STARTF_USESTDHANDLES)),
		.w_show_window = 0,
		.cb_reserved2 = 0,
		.lp_reserved2 = 0,
		.h_std_input = child_stdin,
		.h_std_output = child_stdout_write,
		.h_std_error = child_stdout_write,
	};
	Array_fixed_u16_32768 command_line = {0};
	ExpandEnvironmentStringsW(string_to_wide(cmd), ((voidptr)(&command_line)), 32768);
	bool create_process_ok = CreateProcessW(0, &command_line[0], 0, 0, TRUE, 0, 0, 0, ((voidptr)(&start_info)), ((voidptr)(&proc_info)));
	if (!create_process_ok) {
		int error_num = ((int)(GetLastError()));
		string error_msg = os__get_error_msg(error_num);
		return (os__Result){.exit_code = error_num,.output = _STR("exec failed (CreateProcess) with code %"PRId32"\000: %.*s\000 cmd: %.*s", 3, error_num, error_msg, cmd),};
	}
	CloseHandle(child_stdin);
	CloseHandle(child_stdout_write);
	Array_fixed_byte_4096 buf = {0};
	u32 bytes_read = ((u32)(0U));
	strings__Builder read_data = strings__new_builder(1024);
	for (;;) {
		bool result = false;
		{ // Unsafe block
			result = ReadFile(child_stdout_read, &buf[0], 1000, ((voidptr)(&bytes_read)), 0);
			strings__Builder_write_ptr(&read_data, &buf[0], ((int)(bytes_read)));
		}
		if (result == false || ((int)(bytes_read)) == 0) {
			break;
		}
	}
	string soutput = string_trim_space(strings__Builder_str(&read_data));
	strings__Builder_free(&read_data);
	u32 exit_code = ((u32)(0U));
	WaitForSingleObject(proc_info.h_process, INFINITE);
	GetExitCodeProcess(proc_info.h_process, ((voidptr)(&exit_code)));
	CloseHandle(proc_info.h_process);
	CloseHandle(proc_info.h_thread);
	return (os__Result){.exit_code = ((int)(exit_code)),.output = soutput,};
}

Option_bool os__symlink(string symlink_path, string target_path) {
	int flags = 0;
	if (os__is_dir(symlink_path)) {
		flags |= 1;
	}
	flags |= 2;
	int res = CreateSymbolicLinkW(string_to_wide(symlink_path), string_to_wide(target_path), flags);
	if (res == 0) {
		return (Option_bool){ .state=2, .err=v_error(os__get_error_msg(((int)(GetLastError())))) };
	}
	if (!os__exists(symlink_path)) {
		return (Option_bool){ .state=2, .err=v_error(_SLIT("C.CreateSymbolicLinkW reported success, but symlink still does not exist")) };
	}
	Option_bool _t220;
	opt_ok(&(bool[]) { true }, (Option*)(&_t220), sizeof(bool));
	return _t220;
}

void os__File_close(os__File* f) {
	if (!f->is_opened) {
		return;
	}
	f->is_opened = false;
	fflush(f->cfile);
	fclose(f->cfile);
}

// TypeDecl
void os__add_vectored_exception_handler(bool first, VectoredExceptionHandler handler) {
	AddVectoredExceptionHandler(((u32)(first)), ((PVECTORED_EXCEPTION_HANDLER)(handler)));
}

bool os__debugger_present(void) {
	return IsDebuggerPresent();
}

os__Uname os__uname(void) {
	string unknown = _SLIT("unknown");
	return (os__Uname){.sysname = unknown,.nodename = unknown,.release = unknown,.version = unknown,.machine = unknown,};
}

Option_bool os__is_writable_folder(string folder) {
	if (!os__exists(folder)) {
		return (Option_bool){ .state=2, .err=v_error(_STR("`%.*s\000` does not exist", 2, folder)) };
	}
	if (!os__is_dir(folder)) {
		return (Option_bool){ .state=2, .err=v_error(_SLIT("`folder` is not a folder")) };
	}
	string tmp_perm_check = os__join_path(folder, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){string_add(_SLIT("tmp_perm_check_pid_"), int_str(os__getpid()))})));
	Option_os__File _t221 = os__open_file(tmp_perm_check, _SLIT("w+"), new_array_from_c_array(1, 1, sizeof(int), _MOV((int[1]){0700})));
	if (_t221.state != 0) { /*or block*/ 
		IError err = _t221.err;
		return (Option_bool){ .state=2, .err=v_error(_STR("cannot write to folder %.*s\000: %.*s", 2, folder, IError_str(err))) };
	}
 	os__File f =  *(os__File*)_t221.data;
	os__File_close(&f);
	Option_void _t222 = os__rm(tmp_perm_check);
	if (_t222.state != 0 && _t222.err._typ != _IError_None___index) {
		Option_bool _t223;
		memcpy(&_t223, &_t222, sizeof(Option));
		return _t223;
	};
	Option_bool _t224;
	opt_ok(&(bool[]) { true }, (Option*)(&_t224), sizeof(bool));
	return _t224;
}

// Attr: [inline]
inline int os__getpid(void) {
	return _getpid();
}

void os__posix_set_permission_bit(string path_s, u32 mode, bool enable) {
}

os__Process* os__new_process(string filename) {
	return (os__Process*)memdup(&(os__Process){.filename = filename,.pid = 0,.code = -1,.status = os__ProcessState_not_started,.err = (string){.str=(byteptr)"", .is_lit=1},.args = __new_array(0, 1, sizeof(string)),.env_is_custom = 0,.env = __new_array(0, 1, sizeof(string)),.use_stdio_ctl = 0,.use_pgroup = 0,.stdio_fd = {-1, -1, -1},.wdata = 0,}, sizeof(os__Process));
}

void os__Process_set_args(os__Process* p, Array_string pargs) {
	if (p->status != os__ProcessState_not_started) {
		return;
	}
	p->args = pargs;
	return;
}

void os__Process_set_environment(os__Process* p, Map_string_string envs) {
	if (p->status != os__ProcessState_not_started) {
		return;
	}
	p->env_is_custom = true;
	p->env = __new_array_with_default(0, 0, sizeof(string), 0);
	// FOR IN map
	int _t226 = envs.key_values.len;
	for (int _t225 = 0; _t225 < _t226; ++_t225 ) {
		int _t227 = envs.key_values.len - _t226;
		_t226 = envs.key_values.len;
		if (_t227 < 0) {
			_t225 = -1;
			continue;
		}
		if (!DenseArray_has_index(&envs.key_values, _t225)) {continue;}
		string k = /*key*/ *(string*)DenseArray_key(&envs.key_values, _t225);
		k = string_clone(k);
		string v = (*(string*)DenseArray_value(&envs.key_values, _t225));
		array_push(&p->env, _MOV((string[]){ _STR("%.*s\000=%.*s", 2, k, v) }));
	}
	return;
}

void os__Process_run(os__Process* p) {
	if (p->status != os__ProcessState_not_started) {
		return;
	}
	os__Process__spawn(p);
	return;
}

void os__Process_signal_kill(os__Process* p) {
	if (!(p->status == os__ProcessState_running || p->status == os__ProcessState_stopped)) {
		return;
	}
	os__Process__signal_kill(p);
	p->status = os__ProcessState_aborted;
	return;
}

void os__Process_signal_pgkill(os__Process* p) {
	if (!(p->status == os__ProcessState_running || p->status == os__ProcessState_stopped)) {
		return;
	}
	os__Process__signal_pgkill(p);
	return;
}

void os__Process_signal_stop(os__Process* p) {
	if (p->status != os__ProcessState_running) {
		return;
	}
	os__Process__signal_stop(p);
	p->status = os__ProcessState_stopped;
	return;
}

void os__Process_signal_continue(os__Process* p) {
	if (p->status != os__ProcessState_stopped) {
		return;
	}
	os__Process__signal_continue(p);
	p->status = os__ProcessState_running;
	return;
}

void os__Process_wait(os__Process* p) {
	if (p->status == os__ProcessState_not_started) {
		os__Process__spawn(p);
	}
	if (!(p->status == os__ProcessState_running || p->status == os__ProcessState_stopped)) {
		return;
	}
	os__Process__wait(p);
	return;
}

VV_LOCAL_SYMBOL int os__Process__spawn(os__Process* p) {
	if (!p->env_is_custom) {
		p->env = __new_array_with_default(0, 0, sizeof(string), 0);
		Map_string_string current_environment = os__environ();
		// FOR IN map
		int _t230 = current_environment.key_values.len;
		for (int _t229 = 0; _t229 < _t230; ++_t229 ) {
			int _t231 = current_environment.key_values.len - _t230;
			_t230 = current_environment.key_values.len;
			if (_t231 < 0) {
				_t229 = -1;
				continue;
			}
			if (!DenseArray_has_index(&current_environment.key_values, _t229)) {continue;}
			string k = /*key*/ *(string*)DenseArray_key(&current_environment.key_values, _t229);
			k = string_clone(k);
			string v = (*(string*)DenseArray_value(&current_environment.key_values, _t229));
			array_push(&p->env, _MOV((string[]){ _STR("%.*s\000=%.*s", 2, k, v) }));
		}
	}
	int pid = 0;
	#if defined(_WIN32)
	{
		pid = os__Process_win_spawn_process(p);
	}
	#else
	{
	}
	#endif
	p->pid = pid;
	p->status = os__ProcessState_running;
	return 0;
}

bool os__Process_is_alive(os__Process* p) {
	if ((p->status == os__ProcessState_running || p->status == os__ProcessState_stopped)) {
		return os__Process__is_alive(p);
	}
	return false;
}

void os__Process_set_redirect_stdio(os__Process* p) {
	p->use_stdio_ctl = true;
	return;
}

void os__Process_stdin_write(os__Process* p, string s) {
	os__Process__check_redirection_call(p, _SLIT("stdin_write"));
	#if defined(_WIN32)
	{
		os__Process_win_write_string(p, 0, s);
	}
	#else
	{
	}
	#endif
}

string os__Process_stdout_slurp(os__Process* p) {
	os__Process__check_redirection_call(p, _SLIT("stdout_slurp"));
	#if defined(_WIN32)
	{
		return os__Process_win_slurp(p, 1);
	}
	#else
	{
	}
	#endif
	return (string){.str=(byteptr)"", .is_lit=1};
}

string os__Process_stderr_slurp(os__Process* p) {
	os__Process__check_redirection_call(p, _SLIT("stderr_slurp"));
	#if defined(_WIN32)
	{
		return os__Process_win_slurp(p, 2);
	}
	#else
	{
	}
	#endif
	return (string){.str=(byteptr)"", .is_lit=1};
}

string os__Process_stdout_read(os__Process* p) {
	os__Process__check_redirection_call(p, _SLIT("stdout_read"));
	#if defined(_WIN32)
	{
		multi_return_string_int mr_5347 = os__Process_win_read_string(p, 1, 4096);
		string s = mr_5347.arg0;
		return s;
	}
	#else
	{
	}
	#endif
	return (string){.str=(byteptr)"", .is_lit=1};
}

string os__Process_stderr_read(os__Process* p) {
	os__Process__check_redirection_call(p, _SLIT("stderr_read"));
	#if defined(_WIN32)
	{
		multi_return_string_int mr_5565 = os__Process_win_read_string(p, 2, 4096);
		string s = mr_5565.arg0;
		return s;
	}
	#else
	{
	}
	#endif
	return (string){.str=(byteptr)"", .is_lit=1};
}

VV_LOCAL_SYMBOL void os__Process__check_redirection_call(os__Process* p, string fn_name) {
	if (!p->use_stdio_ctl) {
		v_panic(_STR("Call p.set_redirect_stdio() before calling p.%.*s", 1, fn_name));
	}
	if (p->status == os__ProcessState_not_started) {
		v_panic(_STR("Call p.%.*s\000() after you have called p.run()", 2, fn_name));
	}
}

VV_LOCAL_SYMBOL void os__Process__signal_stop(os__Process* p) {
	#if defined(_WIN32)
	{
		os__Process_win_stop_process(p);
	}
	#else
	{
	}
	#endif
}

VV_LOCAL_SYMBOL void os__Process__signal_continue(os__Process* p) {
	#if defined(_WIN32)
	{
		os__Process_win_resume_process(p);
	}
	#else
	{
	}
	#endif
}

VV_LOCAL_SYMBOL void os__Process__signal_kill(os__Process* p) {
	#if defined(_WIN32)
	{
		os__Process_win_kill_process(p);
	}
	#else
	{
	}
	#endif
}

VV_LOCAL_SYMBOL void os__Process__signal_pgkill(os__Process* p) {
	#if defined(_WIN32)
	{
		os__Process_win_kill_pgroup(p);
	}
	#else
	{
	}
	#endif
}

VV_LOCAL_SYMBOL void os__Process__wait(os__Process* p) {
	#if defined(_WIN32)
	{
		os__Process_win_wait(p);
	}
	#else
	{
	}
	#endif
}

VV_LOCAL_SYMBOL bool os__Process__is_alive(os__Process* p) {
	#if defined(_WIN32)
	{
		return os__Process_win_is_alive(p);
	}
	#else
	{
	}
	#endif
	return 0;
}

// TypeDecl
VV_LOCAL_SYMBOL os__FN_NTSuspendResume os__ntdll_fn(char* name) {
	os__HMODULE ntdll = GetModuleHandleA("NTDLL");
	if (ntdll == 0) {
		return ((os__FN_NTSuspendResume)(0));
	}
	void (*the_fn) (voidptr ) = ((os__FN_NTSuspendResume)(GetProcAddress(ntdll, name)));
	return the_fn;
}

VV_LOCAL_SYMBOL void os__failed_cfn_report_error(bool ok, string label) {
	if (ok) {
		return;
	}
	int error_num = ((int)(GetLastError()));
	string error_msg = os__get_error_msg(error_num);
	eprintln(_STR("failed %.*s\000: %.*s", 2, label, error_msg));
	v_exit(1);
}

// TypeDecl
VV_LOCAL_SYMBOL void os__close_valid_handle(voidptr p) {
	os__PU32* h = ((os__PU32*)(p));
	if (*h != ((u32*)(0))) {
		CloseHandle(*h);
		{ // Unsafe block
			*h = ((u32*)(0));
		}
	}
}

VV_LOCAL_SYMBOL int os__Process_win_spawn_process(os__Process* p) {
	os__WProcess* wdata = (os__WProcess*)memdup(&(os__WProcess){.proc_info = {0},.command_line = {0},.child_stdin = 0,.child_stdout_read = 0,.child_stdout_write = 0,.child_stderr_read = 0,.child_stderr_write = 0,}, sizeof(os__WProcess));
	p->wdata = ((voidptr)(wdata));
	os__StartupInfo start_info = (os__StartupInfo){.cb = /*SizeOf*/ sizeof(PROCESS_INFORMATION),.lp_reserved = 0,.lp_desktop = 0,.lp_title = 0,.dw_x = 0,.dw_y = 0,.dw_x_size = 0,.dw_y_size = 0,.dw_x_count_chars = 0,.dw_y_count_chars = 0,.dw_fill_attributes = 0,.dw_flags = 0,.w_show_window = 0,.cb_reserved2 = 0,.lp_reserved2 = 0,.h_std_input = 0,.h_std_output = 0,.h_std_error = 0,};
	if (p->use_stdio_ctl) {
		os__SecurityAttributes sa = (os__SecurityAttributes){.n_length = 0,.lp_security_descriptor = 0,.b_inherit_handle = 0,};
		sa.n_length = /*SizeOf*/ sizeof(SECURITY_ATTRIBUTES);
		sa.b_inherit_handle = true;
		bool create_pipe_ok1 = CreatePipe(((voidptr)(&wdata->child_stdout_read)), ((voidptr)(&wdata->child_stdout_write)), ((voidptr)(&sa)), 0);
		os__failed_cfn_report_error(create_pipe_ok1, _SLIT("CreatePipe stdout"));
		bool set_handle_info_ok1 = SetHandleInformation(wdata->child_stdout_read, HANDLE_FLAG_INHERIT, 0);
		os__failed_cfn_report_error(set_handle_info_ok1, _SLIT("SetHandleInformation"));
		bool create_pipe_ok2 = CreatePipe(((voidptr)(&wdata->child_stderr_read)), ((voidptr)(&wdata->child_stderr_write)), ((voidptr)(&sa)), 0);
		os__failed_cfn_report_error(create_pipe_ok2, _SLIT("CreatePipe stderr"));
		bool set_handle_info_ok2 = SetHandleInformation(wdata->child_stderr_read, HANDLE_FLAG_INHERIT, 0);
		os__failed_cfn_report_error(set_handle_info_ok2, _SLIT("SetHandleInformation stderr"));
		start_info.h_std_input = wdata->child_stdin;
		start_info.h_std_output = wdata->child_stdout_write;
		start_info.h_std_error = wdata->child_stderr_write;
		start_info.dw_flags = ((u32)(STARTF_USESTDHANDLES));
	}
	string cmd = string_add(_STR("%.*s\000 ", 2, p->filename), Array_string_join(p->args, _SLIT(" ")));
	ExpandEnvironmentStringsW(string_to_wide(cmd), ((voidptr)(&wdata->command_line[0])), 32768);
	int creation_flags = ((int)(NORMAL_PRIORITY_CLASS));
	if (p->use_pgroup) {
		creation_flags |= CREATE_NEW_PROCESS_GROUP;
	}
	bool create_process_ok = CreateProcessW(0, &wdata->command_line[0], 0, 0, TRUE, creation_flags, 0, 0, ((voidptr)(&start_info)), ((voidptr)(&wdata->proc_info)));
	os__failed_cfn_report_error(create_process_ok, _SLIT("CreateProcess"));
	if (p->use_stdio_ctl) {
		os__close_valid_handle(&wdata->child_stdout_write);
		os__close_valid_handle(&wdata->child_stderr_write);
	}
	p->pid = ((int)(wdata->proc_info.dw_process_id));
	return p->pid;
}

VV_LOCAL_SYMBOL void os__Process_win_stop_process(os__Process* p) {
	void (*the_fn) (voidptr ) = os__ntdll_fn("NtSuspendProcess");
	if (((voidptr)(the_fn)) == 0) {
		return;
	}
	os__WProcess* wdata = ((os__WProcess*)(p->wdata));
	the_fn(wdata->proc_info.h_process);
}

VV_LOCAL_SYMBOL void os__Process_win_resume_process(os__Process* p) {
	void (*the_fn) (voidptr ) = os__ntdll_fn("NtResumeProcess");
	if (((voidptr)(the_fn)) == 0) {
		return;
	}
	os__WProcess* wdata = ((os__WProcess*)(p->wdata));
	the_fn(wdata->proc_info.h_process);
}

VV_LOCAL_SYMBOL void os__Process_win_kill_process(os__Process* p) {
	os__WProcess* wdata = ((os__WProcess*)(p->wdata));
	TerminateProcess(wdata->proc_info.h_process, 3);
}

VV_LOCAL_SYMBOL void os__Process_win_kill_pgroup(os__Process* p) {
	os__WProcess* wdata = ((os__WProcess*)(p->wdata));
	GenerateConsoleCtrlEvent(CTRL_BREAK_EVENT, wdata->proc_info.dw_process_id);
	Sleep(20);
	TerminateProcess(wdata->proc_info.h_process, 3);
}

VV_LOCAL_SYMBOL void os__Process_win_wait(os__Process* p) {
	u32 exit_code = ((u32)(1U));
	os__WProcess* wdata = ((os__WProcess*)(p->wdata));
	if (p->wdata != 0) {
		WaitForSingleObject(wdata->proc_info.h_process, INFINITE);
		GetExitCodeProcess(wdata->proc_info.h_process, ((voidptr)(&exit_code)));
		os__close_valid_handle(&wdata->child_stdin);
		os__close_valid_handle(&wdata->child_stdout_write);
		os__close_valid_handle(&wdata->child_stderr_write);
		os__close_valid_handle(&wdata->proc_info.h_process);
		os__close_valid_handle(&wdata->proc_info.h_thread);
	}
	p->status = os__ProcessState_exited;
	p->code = ((int)(exit_code));
}

VV_LOCAL_SYMBOL bool os__Process_win_is_alive(os__Process* p) {
	u32 exit_code = ((u32)(0U));
	os__WProcess* wdata = ((os__WProcess*)(p->wdata));
	GetExitCodeProcess(wdata->proc_info.h_process, ((voidptr)(&exit_code)));
	if (_us32_eq(exit_code,STILL_ACTIVE)) {
		return true;
	}
	return false;
}

VV_LOCAL_SYMBOL void os__Process_win_write_string(os__Process* p, int idx, string s) {
	v_panic(_STR("Process.write_string %"PRId32"\000 is not implemented yet", 2, idx));
}

VV_LOCAL_SYMBOL multi_return_string_int os__Process_win_read_string(os__Process* p, int idx, int maxbytes) {
	v_panic(_STR("WProcess.read_string %"PRId32"\000 is not implemented yet", 2, idx));
	return (multi_return_string_int){.arg0=_SLIT(""), .arg1=0};
}

VV_LOCAL_SYMBOL string os__Process_win_slurp(os__Process* p, int idx) {
	os__WProcess* wdata = ((os__WProcess*)(p->wdata));
	if (wdata == 0) {
		return _SLIT("");
	}
	u32* rhandle = ((u32*)(0));
	if (idx == 1) {
		rhandle = wdata->child_stdout_read;
	}
	if (idx == 2) {
		rhandle = wdata->child_stderr_read;
	}
	if (rhandle == 0) {
		return _SLIT("");
	}
	u32 bytes_read = ((u32)(0U));
	Array_fixed_byte_4096 buf = {0};
	strings__Builder read_data = strings__new_builder(1024);
	for (;;) {
		bool result = false;
		{ // Unsafe block
			result = ReadFile(rhandle, &buf[0], 1000, ((voidptr)(&bytes_read)), 0);
			strings__Builder_write_ptr(&read_data, &buf[0], ((int)(bytes_read)));
		}
		if (result == false || ((int)(bytes_read)) == 0) {
			break;
		}
	}
	string soutput = strings__Builder_str(&read_data);
	strings__Builder_free(&read_data);
	if (idx == 1) {
		os__close_valid_handle(&wdata->child_stdout_read);
	}
	if (idx == 2) {
		os__close_valid_handle(&wdata->child_stderr_read);
	}
	return soutput;
}

VV_LOCAL_SYMBOL int os__Process_unix_spawn_process(os__Process* p) {
	return 0;
}

VV_LOCAL_SYMBOL void os__Process_unix_stop_process(os__Process* p) {
}

VV_LOCAL_SYMBOL void os__Process_unix_resume_process(os__Process* p) {
}

VV_LOCAL_SYMBOL void os__Process_unix_kill_process(os__Process* p) {
}

VV_LOCAL_SYMBOL void os__Process_unix_kill_pgroup(os__Process* p) {
}

VV_LOCAL_SYMBOL void os__Process_unix_wait(os__Process* p) {
}

VV_LOCAL_SYMBOL bool os__Process_unix_is_alive(os__Process* p) {
	return false;
}

Array_string os__cmdline__options(Array_string args, string param) {
	Array_string flags = __new_array_with_default(0, 0, sizeof(string), 0);
	// FOR IN array
	for (int i = 0; i < args.len; ++i) {
		string v = ((string*)args.data)[i];
		if (string_eq(v, param)) {
			if (i + 1 < args.len) {
				array_push(&flags, _MOV((string[]){ string_clone((*(string*)/*ee elem_typ */array_get(args, i + 1))) }));
			}
		}
	}
	// autofree_scope_vars(pos=329 line_nr=15 scope.pos=156 scope.end_pos=343)
	// var "args" var.pos=164 var.line_nr=6
	// var "param" var.pos=179 var.line_nr=6
	// var "flags" var.pos=209 var.line_nr=7
	// af parent scope:
	// af parent scope:
	return flags;
}

string os__cmdline__option(Array_string args, string param, string def) {
	bool found = false;
	// FOR IN array
	for (int _t234 = 0; _t234 < args.len; ++_t234) {
		string arg = ((string*)args.data)[_t234];
		if (found) {
			// autofree_scope_vars(pos=561 line_nr=27 scope.pos=557 scope.end_pos=575)
			// af parent scope:
			// var "arg" var.pos=532 var.line_nr=25
			// skipping tmp var "arg"
			// af parent scope:
			// var "args" var.pos=457 var.line_nr=23
			// var "param" var.pos=472 var.line_nr=23
			// var "def" var.pos=486 var.line_nr=23
			// var "found" var.pos=512 var.line_nr=24
			// af parent scope:
			// af parent scope:
			return arg;
		} else if (string_eq(param, arg)) {
			found = true;
		}
	}
	// autofree_scope_vars(pos=623 line_nr=32 scope.pos=450 scope.end_pos=635)
	// var "args" var.pos=457 var.line_nr=23
	// var "param" var.pos=472 var.line_nr=23
	// var "def" var.pos=486 var.line_nr=23
	// var "found" var.pos=512 var.line_nr=24
	// af parent scope:
	// af parent scope:
	return def;
}

Array_string os__cmdline__options_before(Array_string args, Array_string what) {
	Array_string args_before = __new_array_with_default(0, 0, sizeof(string), 0);
	// FOR IN array
	for (int _t235 = 0; _t235 < args.len; ++_t235) {
		string a = ((string*)args.data)[_t235];
		if ((Array_string_contains(what, a))) {
			break;
		}
		array_push(&args_before, _MOV((string[]){ string_clone(a) }));
	}
	// autofree_scope_vars(pos=919 line_nr=47 scope.pos=763 scope.end_pos=939)
	// var "args" var.pos=778 var.line_nr=39
	// var "what" var.pos=793 var.line_nr=39
	// var "args_before" var.pos=824 var.line_nr=40
	// af parent scope:
	// af parent scope:
	return args_before;
}

Array_string os__cmdline__options_after(Array_string args, Array_string what) {
	bool found = false;
	Array_string args_after = __new_array_with_default(0, 0, sizeof(string), 0);
	// FOR IN array
	for (int _t237 = 0; _t237 < args.len; ++_t237) {
		string a = ((string*)args.data)[_t237];
		if ((Array_string_contains(what, a))) {
			found = true;
			continue;
		}
		if (found) {
			array_push(&args_after, _MOV((string[]){ string_clone(a) }));
		}
	}
	// autofree_scope_vars(pos=1276 line_nr=66 scope.pos=1066 scope.end_pos=1295)
	// var "args" var.pos=1080 var.line_nr=54
	// var "what" var.pos=1095 var.line_nr=54
	// var "found" var.pos=1126 var.line_nr=55
	// var "args_after" var.pos=1146 var.line_nr=56
	// af parent scope:
	// af parent scope:
	return args_after;
}

Array_string os__cmdline__only_non_options(Array_string args) {
	Array_string _t240_orig = args;
	int _t240_len = _t240_orig.len;
	Array_string _t240 = __new_array(0, _t240_len, sizeof(string));

	for (int _t241 = 0; _t241 < _t240_len; ++_t241) {
		string it = ((string*) _t240_orig.data)[_t241];
		if (!string_starts_with(it, _SLIT("-"))) {
			array_push(&_t240, &it); 
		}
	}
	
	 Array_string _t239 = _t240;
	// autofree_scope_vars(pos=1453 line_nr=73 scope.pos=1410 scope.end_pos=1495)
	// var "args" var.pos=1427 var.line_nr=72
	// af parent scope:
	// af parent scope:
	return _t239;
}

Array_string os__cmdline__only_options(Array_string args) {
	Array_string _t243_orig = args;
	int _t243_len = _t243_orig.len;
	Array_string _t243 = __new_array(0, _t243_len, sizeof(string));

	for (int _t244 = 0; _t244 < _t243_len; ++_t244) {
		string it = ((string*) _t243_orig.data)[_t244];
		if (string_starts_with(it, _SLIT("-"))) {
			array_push(&_t243, &it); 
		}
	}
	
	 Array_string _t242 = _t243;
	// autofree_scope_vars(pos=1649 line_nr=80 scope.pos=1610 scope.end_pos=1690)
	// var "args" var.pos=1623 var.line_nr=79
	// af parent scope:
	// af parent scope:
	return _t242;
}

string time__Time_format(time__Time t) {
	 string _t245 = time__Time_get_fmt_str(t, time__FormatDelimiter_hyphen, time__FormatTime_hhmm24, time__FormatDate_yyyymmdd);
	// autofree_scope_vars(pos=285 line_nr=7 scope.pos=258 scope.end_pos=336)
	// var "t" var.pos=259 var.line_nr=6
	// af parent scope:
	// af parent scope:
	return _t245;
}

string time__Time_format_ss(time__Time t) {
	 string _t246 = time__Time_get_fmt_str(t, time__FormatDelimiter_hyphen, time__FormatTime_hhmmss24, time__FormatDate_yyyymmdd);
	// autofree_scope_vars(pos=450 line_nr=12 scope.pos=420 scope.end_pos=503)
	// var "t" var.pos=421 var.line_nr=11
	// af parent scope:
	// af parent scope:
	return _t246;
}

string time__Time_format_ss_milli(time__Time t) {
	 string _t247 = time__Time_get_fmt_str(t, time__FormatDelimiter_hyphen, time__FormatTime_hhmmss24_milli, time__FormatDate_yyyymmdd);
	// autofree_scope_vars(pos=633 line_nr=17 scope.pos=597 scope.end_pos=692)
	// var "t" var.pos=598 var.line_nr=16
	// af parent scope:
	// af parent scope:
	return _t247;
}

string time__Time_format_ss_micro(time__Time t) {
	 string _t248 = time__Time_get_fmt_str(t, time__FormatDelimiter_hyphen, time__FormatTime_hhmmss24_micro, time__FormatDate_yyyymmdd);
	// autofree_scope_vars(pos=825 line_nr=22 scope.pos=789 scope.end_pos=884)
	// var "t" var.pos=790 var.line_nr=21
	// af parent scope:
	// af parent scope:
	return _t248;
}

string time__Time_hhmm(time__Time t) {
	 string _t249 = time__Time_get_fmt_time_str(t, time__FormatTime_hhmm24);
	// autofree_scope_vars(pos=974 line_nr=27 scope.pos=949 scope.end_pos=1010)
	// var "t" var.pos=950 var.line_nr=26
	// af parent scope:
	// af parent scope:
	return _t249;
}

string time__Time_hhmmss(time__Time t) {
	 string _t250 = time__Time_get_fmt_time_str(t, time__FormatTime_hhmmss24);
	// autofree_scope_vars(pos=1107 line_nr=32 scope.pos=1080 scope.end_pos=1145)
	// var "t" var.pos=1081 var.line_nr=31
	// af parent scope:
	// af parent scope:
	return _t250;
}

string time__Time_hhmm12(time__Time t) {
	 string _t251 = time__Time_get_fmt_time_str(t, time__FormatTime_hhmm12);
	// autofree_scope_vars(pos=1239 line_nr=37 scope.pos=1212 scope.end_pos=1275)
	// var "t" var.pos=1213 var.line_nr=36
	// af parent scope:
	// af parent scope:
	return _t251;
}

string time__Time_ymmdd(time__Time t) {
	 string _t252 = time__Time_get_fmt_date_str(t, time__FormatDelimiter_hyphen, time__FormatDate_yyyymmdd);
	// autofree_scope_vars(pos=1366 line_nr=42 scope.pos=1340 scope.end_pos=1413)
	// var "t" var.pos=1341 var.line_nr=41
	// af parent scope:
	// af parent scope:
	return _t252;
}

string time__Time_ddmmy(time__Time t) {
	 string _t253 = time__Time_get_fmt_date_str(t, time__FormatDelimiter_dot, time__FormatDate_ddmmyyyy);
	// autofree_scope_vars(pos=1504 line_nr=47 scope.pos=1478 scope.end_pos=1548)
	// var "t" var.pos=1479 var.line_nr=46
	// af parent scope:
	// af parent scope:
	return _t253;
}

string time__Time_md(time__Time t) {
	 string _t254 = time__Time_get_fmt_date_str(t, time__FormatDelimiter_space, time__FormatDate_mmmd);
	// autofree_scope_vars(pos=1628 line_nr=52 scope.pos=1605 scope.end_pos=1670)
	// var "t" var.pos=1606 var.line_nr=51
	// af parent scope:
	// af parent scope:
	return _t254;
}

string time__Time_clean(time__Time t) {
	time__Time znow = time__now();
	if (t.month == znow.month && t.year == znow.year && t.day == znow.day) {
		 string _t255 = time__Time_get_fmt_time_str(t, time__FormatTime_hhmm24);
		// autofree_scope_vars(pos=2057 line_nr=63 scope.pos=2054 scope.end_pos=2094)
		// af parent scope:
		// var "t" var.pos=1934 var.line_nr=59
		// var "znow" var.pos=1960 var.line_nr=60
		// af parent scope:
		// af parent scope:
		return _t255;
	}
	if (t.year == znow.year) {
		 string _t256 = time__Time_get_fmt_str(t, time__FormatDelimiter_space, time__FormatTime_hhmm24, time__FormatDate_mmmd);
		// autofree_scope_vars(pos=2137 line_nr=67 scope.pos=2134 scope.end_pos=2184)
		// af parent scope:
		// var "t" var.pos=1934 var.line_nr=59
		// var "znow" var.pos=1960 var.line_nr=60
		// af parent scope:
		// af parent scope:
		return _t256;
	}
	 string _t257 = time__Time_format(t);
	// autofree_scope_vars(pos=2186 line_nr=69 scope.pos=1933 scope.end_pos=2205)
	// var "t" var.pos=1934 var.line_nr=59
	// var "znow" var.pos=1960 var.line_nr=60
	// af parent scope:
	// af parent scope:
	return _t257;
}

string time__Time_clean12(time__Time t) {
	time__Time znow = time__now();
	if (t.month == znow.month && t.year == znow.year && t.day == znow.day) {
		 string _t258 = time__Time_get_fmt_time_str(t, time__FormatTime_hhmm12);
		// autofree_scope_vars(pos=2596 line_nr=80 scope.pos=2593 scope.end_pos=2633)
		// af parent scope:
		// var "t" var.pos=2471 var.line_nr=76
		// var "znow" var.pos=2499 var.line_nr=77
		// af parent scope:
		// af parent scope:
		return _t258;
	}
	if (t.year == znow.year) {
		 string _t259 = time__Time_get_fmt_str(t, time__FormatDelimiter_space, time__FormatTime_hhmm12, time__FormatDate_mmmd);
		// autofree_scope_vars(pos=2676 line_nr=84 scope.pos=2673 scope.end_pos=2723)
		// af parent scope:
		// var "t" var.pos=2471 var.line_nr=76
		// var "znow" var.pos=2499 var.line_nr=77
		// af parent scope:
		// af parent scope:
		return _t259;
	}
	 string _t260 = time__Time_format(t);
	// autofree_scope_vars(pos=2725 line_nr=86 scope.pos=2470 scope.end_pos=2744)
	// var "t" var.pos=2471 var.line_nr=76
	// var "znow" var.pos=2499 var.line_nr=77
	// af parent scope:
	// af parent scope:
	return _t260;
}

string time__Time_get_fmt_time_str(time__Time t, time__FormatTime fmt_time) {
	if (fmt_time == time__FormatTime_no_time) {
		 string _t261 = _SLIT("");
		// autofree_scope_vars(pos=2912 line_nr=92 scope.pos=2909 scope.end_pos=2924)
		// af parent scope:
		// var "t" var.pos=2829 var.line_nr=90
		// var "fmt_time" var.pos=2854 var.line_nr=90
		// var "tp" var.pos=2927 var.line_nr=94
		// var "hour_" var.pos=2976 var.line_nr=95
		// af parent scope:
		// af parent scope:
		return _t261;
	}
	string tp = (t.hour > 11 ? (_SLIT("p.m.")) : (_SLIT("a.m.")));
	int hour_ = (t.hour > 12 ? (t.hour - 12) : t.hour == 0 ? (12) : (t.hour));
	 string _t262 = ((fmt_time == (time__FormatTime_hhmm12)) ? (_STR("%"PRId32"\000:%02"PRId32"\000 %.*s", 3, hour_, t.minute, tp)) : (fmt_time == (time__FormatTime_hhmm24)) ? (_STR("%02"PRId32"\000:%02"PRId32"", 2, t.hour, t.minute)) : (fmt_time == (time__FormatTime_hhmmss12)) ? (_STR("%"PRId32"\000:%02"PRId32"\000:%02"PRId32"\000 %.*s", 4, hour_, t.minute, t.second, tp)) : (fmt_time == (time__FormatTime_hhmmss24)) ? (_STR("%02"PRId32"\000:%02"PRId32"\000:%02"PRId32"", 3, t.hour, t.minute, t.second)) : (fmt_time == (time__FormatTime_hhmmss24_milli)) ? (_STR("%02"PRId32"\000:%02"PRId32"\000:%02"PRId32"\000.%03"PRId32"", 4, t.hour, t.minute, t.second, (t.microsecond / 1000))) : (fmt_time == (time__FormatTime_hhmmss24_micro)) ? (_STR("%02"PRId32"\000:%02"PRId32"\000:%02"PRId32"\000.%06"PRId32"", 4, t.hour, t.minute, t.second, t.microsecond)) : (_STR("unknown enumeration %.*s", 1, time__FormatTime_str(fmt_time))));
	// autofree_scope_vars(pos=3068 line_nr=102 scope.pos=2828 scope.end_pos=3544)
	// var "t" var.pos=2829 var.line_nr=90
	// var "fmt_time" var.pos=2854 var.line_nr=90
	// var "tp" var.pos=2927 var.line_nr=94
	// var "hour_" var.pos=2976 var.line_nr=95
	// af parent scope:
	// af parent scope:
	return _t262;
}

string time__Time_get_fmt_date_str(time__Time t, time__FormatDelimiter fmt_dlmtr, time__FormatDate fmt_date) {
	if (fmt_date == time__FormatDate_no_date) {
		 string _t263 = _SLIT("");
		// autofree_scope_vars(pos=3762 line_nr=117 scope.pos=3759 scope.end_pos=3774)
		// af parent scope:
		// var "t" var.pos=3652 var.line_nr=115
		// var "fmt_dlmtr" var.pos=3677 var.line_nr=115
		// var "fmt_date" var.pos=3704 var.line_nr=115
		// var "month" var.pos=3777 var.line_nr=119
		// var "year" var.pos=3801 var.line_nr=120
		// var "res" var.pos=3838 var.line_nr=121
		// var "del" var.pos=4398 var.line_nr=134
		// af parent scope:
		// af parent scope:
		return _t263;
	}
	string month = _STR("%.*s", 1, time__Time_smonth(t));
	string year = _STR("%02"PRId32"", 1, (t.year % 100));
	string res = ((fmt_date == (time__FormatDate_ddmmyy)) ? (_STR("%02"PRId32"\000|%02"PRId32"\000|%.*s", 3, t.day, t.month, year)) : (fmt_date == (time__FormatDate_ddmmyyyy)) ? (_STR("%02"PRId32"\000|%02"PRId32"\000|%04"PRId32"", 3, t.day, t.month, t.year)) : (fmt_date == (time__FormatDate_mmddyy)) ? (_STR("%02"PRId32"\000|%02"PRId32"\000|%.*s", 3, t.month, t.day, year)) : (fmt_date == (time__FormatDate_mmddyyyy)) ? (_STR("%02"PRId32"\000|%02"PRId32"\000|%04"PRId32"", 3, t.month, t.day, t.year)) : (fmt_date == (time__FormatDate_mmmd)) ? (_STR("%.*s\000|%"PRId32"", 2, month, t.day)) : (fmt_date == (time__FormatDate_mmmdd)) ? (_STR("%.*s\000|%02"PRId32"", 2, month, t.day)) : (fmt_date == (time__FormatDate_mmmddyy)) ? (_STR("%.*s\000|%02"PRId32"\000|%.*s", 3, month, t.day, year)) : (fmt_date == (time__FormatDate_mmmddyyyy)) ? (_STR("%.*s\000|%02"PRId32"\000|%04"PRId32"", 3, month, t.day, t.year)) : (fmt_date == (time__FormatDate_yyyymmdd)) ? (_STR("%04"PRId32"\000|%02"PRId32"\000|%02"PRId32"", 3, t.year, t.month, t.day)) : (fmt_date == (time__FormatDate_yymmdd)) ? (_STR("%.*s\000|%02"PRId32"\000|%02"PRId32"", 3, year, t.month, t.day)) : (_STR("unknown enumeration %.*s", 1, time__FormatDate_str(fmt_date))));
	string del = ((fmt_dlmtr == (time__FormatDelimiter_dot)) ? (_SLIT(".")) : (fmt_dlmtr == (time__FormatDelimiter_hyphen)) ? (_SLIT("-")) : (fmt_dlmtr == (time__FormatDelimiter_slash)) ? (_SLIT("/")) : (fmt_dlmtr == (time__FormatDelimiter_space)) ? (_SLIT(" ")) : (_SLIT("")));
	res = string_replace(res, _SLIT("|"), del);
	// autofree_scope_vars(pos=4545 line_nr=142 scope.pos=3651 scope.end_pos=4557)
	// var "t" var.pos=3652 var.line_nr=115
	// var "fmt_dlmtr" var.pos=3677 var.line_nr=115
	// var "fmt_date" var.pos=3704 var.line_nr=115
	// var "month" var.pos=3777 var.line_nr=119
	// var "year" var.pos=3801 var.line_nr=120
	// var "res" var.pos=3838 var.line_nr=121
	// var "del" var.pos=4398 var.line_nr=134
	// af parent scope:
	// af parent scope:
	return res;
}

string time__Time_get_fmt_str(time__Time t, time__FormatDelimiter fmt_dlmtr, time__FormatTime fmt_time, time__FormatDate fmt_date) {
	if (fmt_date == time__FormatDate_no_date) {
		if (fmt_time == time__FormatTime_no_time) {
			 string _t264 = _SLIT("");
			// autofree_scope_vars(pos=4941 line_nr=152 scope.pos=4829 scope.end_pos=4954)
			// af parent scope:
			// af parent scope:
			// var "t" var.pos=4678 var.line_nr=147
			// var "fmt_dlmtr" var.pos=4698 var.line_nr=147
			// var "fmt_time" var.pos=4725 var.line_nr=147
			// var "fmt_date" var.pos=4746 var.line_nr=147
			// af parent scope:
			// af parent scope:
			return _t264;
		} else {
			 string _t265 = time__Time_get_fmt_time_str(t, fmt_time);
			// autofree_scope_vars(pos=4965 line_nr=154 scope.pos=4961 scope.end_pos=5004)
			// af parent scope:
			// af parent scope:
			// var "t" var.pos=4678 var.line_nr=147
			// var "fmt_dlmtr" var.pos=4698 var.line_nr=147
			// var "fmt_time" var.pos=4725 var.line_nr=147
			// var "fmt_date" var.pos=4746 var.line_nr=147
			// af parent scope:
			// af parent scope:
			return _t265;
		}
	} else {
		if (fmt_time != time__FormatTime_no_time) {
			 string _t266 = string_add(string_add(time__Time_get_fmt_date_str(t, fmt_dlmtr, fmt_date), _SLIT(" ")), time__Time_get_fmt_time_str(t, fmt_time));
			// autofree_scope_vars(pos=5046 line_nr=158 scope.pos=5042 scope.end_pos=5133)
			// af parent scope:
			// af parent scope:
			// var "t" var.pos=4678 var.line_nr=147
			// var "fmt_dlmtr" var.pos=4698 var.line_nr=147
			// var "fmt_time" var.pos=4725 var.line_nr=147
			// var "fmt_date" var.pos=4746 var.line_nr=147
			// af parent scope:
			// af parent scope:
			return _t266;
		} else {
			 string _t267 = time__Time_get_fmt_date_str(t, fmt_dlmtr, fmt_date);
			// autofree_scope_vars(pos=5144 line_nr=160 scope.pos=5140 scope.end_pos=5194)
			// af parent scope:
			// af parent scope:
			// var "t" var.pos=4678 var.line_nr=147
			// var "fmt_dlmtr" var.pos=4698 var.line_nr=147
			// var "fmt_time" var.pos=4725 var.line_nr=147
			// var "fmt_date" var.pos=4746 var.line_nr=147
			// af parent scope:
			// af parent scope:
			return _t267;
		}
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

string time__Time_utc_string(time__Time t) {
	string day_str = time__Time_weekday_str(t);
	string month_str = time__Time_smonth(t);
	string utc_string = _STR("%.*s\000, %"PRId32"\000 %.*s\000 %"PRId32"\000 %02"PRId32"\000:%02"PRId32"\000:%02"PRId32"\000 UTC", 8, day_str, t.day, month_str, t.year, t.hour, t.minute, t.second);
	// autofree_scope_vars(pos=5468 line_nr=170 scope.pos=5281 scope.end_pos=5487)
	// var "t" var.pos=5282 var.line_nr=166
	// var "day_str" var.pos=5313 var.line_nr=167
	// var "month_str" var.pos=5341 var.line_nr=168
	// var "utc_string" var.pos=5366 var.line_nr=169
	// af parent scope:
	// af parent scope:
	return utc_string;
}

// Attr: [inline]
inline bool time__Time__eq(time__Time t1, time__Time t2) {
	 bool _t268 = t1.v_unix == t2.v_unix && t1.microsecond == t2.microsecond;
	// autofree_scope_vars(pos=123 line_nr=5 scope.pos=93 scope.end_pos=186)
	// var "t1" var.pos=94 var.line_nr=4
	// var "t2" var.pos=107 var.line_nr=4
	// af parent scope:
	// af parent scope:
	return _t268;
}

// Attr: [inline]
inline bool time__Time__lt(time__Time t1, time__Time t2) {
	 bool _t269 = t1.v_unix < t2.v_unix || (t1.v_unix == t2.v_unix && t1.microsecond < t2.microsecond);
	// autofree_scope_vars(pos=298 line_nr=11 scope.pos=269 scope.end_pos=383)
	// var "t1" var.pos=270 var.line_nr=10
	// var "t2" var.pos=282 var.line_nr=10
	// af parent scope:
	// af parent scope:
	return _t269;
}

// Attr: [inline]
inline time__Duration time__Time__minus(time__Time lhs, time__Time rhs) {
	u64 lhs_micro = lhs.v_unix * 1000 * 1000 + ((u64)(lhs.microsecond));
	u64 rhs_micro = rhs.v_unix * 1000 * 1000 + ((u64)(rhs.microsecond));
	 time__Duration _t270 = (((i64)(lhs_micro)) - ((i64)(rhs_micro))) * _const_time__microsecond;
	// autofree_scope_vars(pos=602 line_nr=19 scope.pos=447 scope.end_pos=658)
	// var "lhs" var.pos=448 var.line_nr=16
	// var "rhs" var.pos=461 var.line_nr=16
	// var "lhs_micro" var.pos=483 var.line_nr=17
	// var "rhs_micro" var.pos=543 var.line_nr=18
	// af parent scope:
	// af parent scope:
	return _t270;
}

Option_time__Time time__parse(string s) {
	Option_int _t271 = string_index(s, _SLIT(" "));
	if (_t271.state != 0) { /*or block*/ 
		IError err = _t271.err;
		return (Option_time__Time){ .state=2, .err=v_error(_STR("Invalid time format: %.*s", 1, s)) };
	}
 	int pos =  *(int*)_t271.data;
	string symd = string_substr(s, 0, pos);
	Array_string ymd = string_split(symd, _SLIT("-"));
	if (ymd.len != 3) {
		return (Option_time__Time){ .state=2, .err=v_error(_STR("Invalid time format: %.*s", 1, s)) };
	}
	string shms = string_substr(s, pos, s.len);
	Array_string hms = string_split(shms, _SLIT(":"));
	string hour_ = string_substr((*(string*)/*ee elem_typ */array_get(hms, 0)), 1, (*(string*)/*ee elem_typ */array_get(hms, 0)).len);
	string minute_ = (*(string*)/*ee elem_typ */array_get(hms, 1));
	string second_ = (*(string*)/*ee elem_typ */array_get(hms, 2));
	time__Time res = time__new_time((time__Time){
		.year = string_int((*(string*)/*ee elem_typ */array_get(ymd, 0))),
		.month = string_int((*(string*)/*ee elem_typ */array_get(ymd, 1))),
		.day = string_int((*(string*)/*ee elem_typ */array_get(ymd, 2))),
		.hour = string_int(hour_),
		.minute = string_int(minute_),
		.second = string_int(second_),
		.microsecond = 0,
		.v_unix = 0,
	});
	Option_time__Time _t272;
	opt_ok(&(time__Time[]) { res }, (Option*)(&_t272), sizeof(time__Time));
	// autofree_scope_vars(pos=722 line_nr=26 scope.pos=264 scope.end_pos=734)
	// var "s" var.pos=270 var.line_nr=6
	// var "pos" var.pos=289 var.line_nr=7
	// var "symd" var.pos=357 var.line_nr=8
	// var "ymd" var.pos=375 var.line_nr=9
	// var "shms" var.pos=463 var.line_nr=13
	// var "hms" var.pos=481 var.line_nr=14
	// var "hour_" var.pos=505 var.line_nr=15
	// var "minute_" var.pos=527 var.line_nr=16
	// var "second_" var.pos=546 var.line_nr=17
	// var "res" var.pos=565 var.line_nr=18
	// af parent scope:
	// af parent scope:
	return _t272;
}

Option_time__Time time__parse_rfc2822(string s) {
	Array_string fields = string_split(s, _SLIT(" "));
	if (fields.len < 5) {
		return (Option_time__Time){ .state=2, .err=v_error(_STR("Invalid time format: %.*s", 1, s)) };
	}
	Option_int _t273 = string_index(_const_time__months_string, (*(string*)/*ee elem_typ */array_get(fields, 2)));
	if (_t273.state != 0) { /*or block*/ 
		IError err = _t273.err;
		return (Option_time__Time){ .state=2, .err=v_error(_STR("Invalid time format: %.*s", 1, s)) };
	}
 	int pos =  *(int*)_t273.data;
	int mm = pos / 3 + 1;
	{ // Unsafe block
		byte* tmstr = v_malloc(s.len * 2);
		int count = snprintf(((char*)(tmstr)), (s.len * 2), "%s-%02d-%s %s", (*(string*)/*ee elem_typ */array_get(fields, 3)).str, mm, (*(string*)/*ee elem_typ */array_get(fields, 1)).str, (*(string*)/*ee elem_typ */array_get(fields, 4)).str);
		 Option_time__Time _t274 = time__parse(tos(tmstr, count));
		// autofree_scope_vars(pos=1208 line_nr=41 scope.pos=1061 scope.end_pos=1242)
		// var "tmstr" var.pos=1061 var.line_nr=38
		// var "count" var.pos=1090 var.line_nr=39
		// af parent scope:
		// var "s" var.pos=836 var.line_nr=30
		// var "fields" var.pos=855 var.line_nr=31
		// var "pos" var.pos=945 var.line_nr=35
		// var "mm" var.pos=1031 var.line_nr=36
		// af parent scope:
		// af parent scope:
		return _t274;
	}
	return (Option_time__Time){0};
}

VV_LOCAL_SYMBOL Option_multi_return_int_int_int time__parse_iso8601_date(string s) {
	int year = 0;
	int month = 0;
	int day = 0;
	byte dummy = ((byte)(0));
	int count = sscanf(((char*)(s.str)), "%4d-%2d-%2d%c", &year, &month, &day, &dummy);
	if (count != 3) {
		return (Option_multi_return_int_int_int){ .state=2, .err=_const_time__err_invalid_8601 };
	}
	Option_multi_return_int_int_int _t275;
	opt_ok(&(multi_return_int_int_int/*X*/[]) { (multi_return_int_int_int){.arg0=year, .arg1=month, .arg2=day} }, (Option*)(&_t275), sizeof(multi_return_int_int_int));
	return _t275;
}

VV_LOCAL_SYMBOL Option_multi_return_int_int_int_int_i64_bool time__parse_iso8601_time(string s) {
	int hour_ = 0;
	int minute_ = 0;
	int second_ = 0;
	int microsecond_ = 0;
	rune plus_min_z = L'a';
	int offset_hour = 0;
	int offset_minute = 0;
	int count = sscanf(((char*)(s.str)), "%2d:%2d:%2d.%6d%c%2d:%2d", &hour_, &minute_, &second_, &microsecond_, ((char*)(&plus_min_z)), &offset_hour, &offset_minute);
	if (count < 4) {
		count = sscanf(((char*)(s.str)), "%2d:%2d:%2d%c%2d:%2d", &hour_, &minute_, &second_, ((char*)(&plus_min_z)), &offset_hour, &offset_minute);
		count++;
	}
	if (count < 4) {
		return (Option_multi_return_int_int_int_int_i64_bool){ .state=2, .err=_const_time__err_invalid_8601 };
	}
	bool is_local_time = plus_min_z == L'a' && count == 4;
	bool is_utc = plus_min_z == L'Z' && count == 5;
	if (!(count == 7 || is_local_time || is_utc)) {
		return (Option_multi_return_int_int_int_int_i64_bool){ .state=2, .err=_const_time__err_invalid_8601 };
	}
	if (plus_min_z != L'+' && plus_min_z != L'-' && !is_utc && !is_local_time) {
		return (Option_multi_return_int_int_int_int_i64_bool){ .state=2, .err=v_error(_SLIT("Invalid 8601 format, expected `Z` or `+` or `-` as time separator")) };
	}
	int unix_offset = 0;
	if (offset_hour > 0) {
		unix_offset += 3600 * offset_hour;
	}
	if (offset_minute > 0) {
		unix_offset += 60 * offset_minute;
	}
	if (plus_min_z == L'+') {
		unix_offset *= -1;
	}
	Option_multi_return_int_int_int_int_i64_bool _t276;
	opt_ok(&(multi_return_int_int_int_int_i64_bool/*X*/[]) { (multi_return_int_int_int_int_i64_bool){.arg0=hour_, .arg1=minute_, .arg2=second_, .arg3=microsecond_, .arg4=unix_offset, .arg5=is_local_time} }, (Option*)(&_t276), sizeof(multi_return_int_int_int_int_i64_bool));
	return _t276;
}

Option_time__Time time__parse_iso8601(string s) {
	Option_int _t277 = string_index(s, _SLIT("T"));
	if (_t277.state != 0) { /*or block*/ 
		IError err = _t277.err;
		*(int*) _t277.data = -1;
	}
 	int t_i =  *(int*)_t277.data;
	Array_string parts = (t_i != -1 ? (new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){string_substr(s, 0, t_i), string_substr(s, t_i + 1, s.len)}))) : (string_split(s, _SLIT(" "))));
	if (!(parts.len == 1 || parts.len == 2)) {
		return (Option_time__Time){ .state=2, .err=_const_time__err_invalid_8601 };
	}
	Option_multi_return_int_int_int _t278 = time__parse_iso8601_date((*(string*)/*ee elem_typ */array_get(parts, 0)));
	if (_t278.state != 0) { /*or block*/ 
		Option_time__Time _t279;
		memcpy(&_t279, &_t278, sizeof(Option));
		return _t279;
	}
 	Option_multi_return_int_int_int mr_3465 =  _t278 /*U*/;
	int year = (*(multi_return_int_int_int*)mr_3465.data).arg0;
	int month = (*(multi_return_int_int_int*)mr_3465.data).arg1;
	int day = (*(multi_return_int_int_int*)mr_3465.data).arg2;
	int hour_ = 0;
	int minute_ = 0;
	int second_ = 0;
	int microsecond_ = 0;
	i64 unix_offset = ((i64)(0));
	bool is_local_time = true;
	if (parts.len == 2) {
		Option_multi_return_int_int_int_int_i64_bool _t280 = time__parse_iso8601_time((*(string*)/*ee elem_typ */array_get(parts, 1)));
		if (_t280.state != 0) { /*or block*/ 
			Option_time__Time _t281;
			memcpy(&_t281, &_t280, sizeof(Option));
			return _t281;
		}
 		Option_multi_return_int_int_int_int_i64_bool mr_3707 =  _t280 /*U*/;
		hour_ = (*(multi_return_int_int_int_int_i64_bool*)mr_3707.data).arg0;
		minute_ = (*(multi_return_int_int_int_int_i64_bool*)mr_3707.data).arg1;
		second_ = (*(multi_return_int_int_int_int_i64_bool*)mr_3707.data).arg2;
		microsecond_ = (*(multi_return_int_int_int_int_i64_bool*)mr_3707.data).arg3;
		unix_offset = (*(multi_return_int_int_int_int_i64_bool*)mr_3707.data).arg4;
		is_local_time = (*(multi_return_int_int_int_int_i64_bool*)mr_3707.data).arg5;
	}
	time__Time t = time__new_time((time__Time){
		.year = year,
		.month = month,
		.day = day,
		.hour = hour_,
		.minute = minute_,
		.second = second_,
		.microsecond = microsecond_,
		.v_unix = 0,
	});
	if (is_local_time) {
		Option_time__Time _t282;
		opt_ok(&(time__Time[]) { t }, (Option*)(&_t282), sizeof(time__Time));
		// autofree_scope_vars(pos=3910 line_nr=129 scope.pos=3907 scope.end_pos=3948)
		// af parent scope:
		// var "s" var.pos=3248 var.line_nr=108
		// var "t_i" var.pos=3267 var.line_nr=109
		// var "parts" var.pos=3298 var.line_nr=110
		// var "year" var.pos=3448 var.line_nr=114
		// var "month" var.pos=3454 var.line_nr=114
		// var "day" var.pos=3461 var.line_nr=114
		// var "hour_" var.pos=3504 var.line_nr=115
		// var "minute_" var.pos=3515 var.line_nr=115
		// var "second_" var.pos=3528 var.line_nr=115
		// var "microsecond_" var.pos=3541 var.line_nr=115
		// var "unix_offset" var.pos=3559 var.line_nr=115
		// var "is_local_time" var.pos=3576 var.line_nr=115
		// var "t" var.pos=3748 var.line_nr=119
		// var "unix_time" var.pos=3955 var.line_nr=131
		// af parent scope:
		// af parent scope:
		return _t282;
	}
	u64 unix_time = t.v_unix;
	if (unix_offset < 0) {
		unix_time -= ((u64)(-unix_offset));
	} else if (unix_offset > 0) {
		unix_time += ((u64)(unix_offset));
	}
	t = time__unix2(((int)(unix_time)), t.microsecond);
	Option_time__Time _t283;
	opt_ok(&(time__Time[]) { t }, (Option*)(&_t283), sizeof(time__Time));
	// autofree_scope_vars(pos=4136 line_nr=138 scope.pos=3234 scope.end_pos=4146)
	// var "s" var.pos=3248 var.line_nr=108
	// var "t_i" var.pos=3267 var.line_nr=109
	// var "parts" var.pos=3298 var.line_nr=110
	// var "year" var.pos=3448 var.line_nr=114
	// var "month" var.pos=3454 var.line_nr=114
	// var "day" var.pos=3461 var.line_nr=114
	// var "hour_" var.pos=3504 var.line_nr=115
	// var "minute_" var.pos=3515 var.line_nr=115
	// var "second_" var.pos=3528 var.line_nr=115
	// var "microsecond_" var.pos=3541 var.line_nr=115
	// var "unix_offset" var.pos=3559 var.line_nr=115
	// var "is_local_time" var.pos=3576 var.line_nr=115
	// var "t" var.pos=3748 var.line_nr=119
	// var "unix_time" var.pos=3955 var.line_nr=131
	// af parent scope:
	// af parent scope:
	return _t283;
}

time__StopWatch time__new_stopwatch(time__StopWatchOptions opts) {
	u64 initial = ((u64)(0U));
	if (opts.auto_start) {
		initial = time__sys_mono_now();
	}
	 time__StopWatch _t284 = (time__StopWatch){.elapsed = 0,.start = initial,.end = 0,};
	// autofree_scope_vars(pos=569 line_nr=24 scope.pos=445 scope.end_pos=630)
	// var "opts" var.pos=459 var.line_nr=19
	// var "initial" var.pos=499 var.line_nr=20
	// af parent scope:
	// af parent scope:
	return _t284;
}

void time__StopWatch_start(time__StopWatch* t) {
	t->start = time__sys_mono_now();
	t->end = 0;
}

void time__StopWatch_restart(time__StopWatch* t) {
	t->start = time__sys_mono_now();
	t->end = 0;
	t->elapsed = 0;
}

void time__StopWatch_stop(time__StopWatch* t) {
	t->end = time__sys_mono_now();
}

void time__StopWatch_pause(time__StopWatch* t) {
	if (t->start > 0) {
		if (t->end == 0) {
			t->elapsed += time__sys_mono_now() - t->start;
		} else {
			t->elapsed += t->end - t->start;
		}
	}
	t->start = 0;
}

time__Duration time__StopWatch_elapsed(time__StopWatch t) {
	if (t.start > 0) {
		if (t.end == 0) {
			 time__Duration _t285 = ((((i64)(time__sys_mono_now() - t.start + t.elapsed))));
			// autofree_scope_vars(pos=1482 line_nr=65 scope.pos=1478 scope.end_pos=1544)
			// af parent scope:
			// af parent scope:
			// var "t" var.pos=1410 var.line_nr=62
			// af parent scope:
			// af parent scope:
			return _t285;
		} else {
			 time__Duration _t286 = ((((i64)(t.end - t.start + t.elapsed))));
			// autofree_scope_vars(pos=1555 line_nr=67 scope.pos=1551 scope.end_pos=1608)
			// af parent scope:
			// af parent scope:
			// var "t" var.pos=1410 var.line_nr=62
			// af parent scope:
			// af parent scope:
			return _t286;
		}
	}
	 time__Duration _t287 = ((((i64)(t.elapsed))));
	// autofree_scope_vars(pos=1613 line_nr=70 scope.pos=1409 scope.end_pos=1646)
	// var "t" var.pos=1410 var.line_nr=62
	// af parent scope:
	// af parent scope:
	return _t287;
}

// TypeDecl
time__Time time__now(void) {
	 time__Time _t288 = time__win_now();
	// autofree_scope_vars(pos=2383 line_nr=108 scope.pos=2380 scope.end_pos=2402)
	// af parent scope:
	// var "t" var.pos=2595 var.line_nr=118
	// var "now" var.pos=2611 var.line_nr=119
	// af parent scope:
	// af parent scope:
	return _t288;
	time_t t = time(0);
	struct tm* now = localtime(&t);
	 time__Time _t289 = time__convert_ctime(*now, 0);
	// autofree_scope_vars(pos=2634 line_nr=120 scope.pos=2316 scope.end_pos=2665)
	// var "t" var.pos=2595 var.line_nr=118
	// var "now" var.pos=2611 var.line_nr=119
	// af parent scope:
	// af parent scope:
	return _t289;
}

time__Time time__utc(void) {
	 time__Time _t290 = time__win_utc();
	// autofree_scope_vars(pos=2779 line_nr=129 scope.pos=2776 scope.end_pos=2798)
	// af parent scope:
	// var "t" var.pos=2991 var.line_nr=139
	// af parent scope:
	// af parent scope:
	return _t290;
	time_t t = time(0);
	time(&t);
	 time__Time _t291 = time__unix2(((int)(t)), 0);
	// autofree_scope_vars(pos=3022 line_nr=141 scope.pos=2712 scope.end_pos=3047)
	// var "t" var.pos=2991 var.line_nr=139
	// af parent scope:
	// af parent scope:
	return _t291;
}

string time__Time_smonth(time__Time t) {
	if (t.month <= 0 || t.month > 12) {
		 string _t292 = _SLIT("---");
		// autofree_scope_vars(pos=3150 line_nr=147 scope.pos=3147 scope.end_pos=3165)
		// af parent scope:
		// var "t" var.pos=3088 var.line_nr=145
		// var "i" var.pos=3168 var.line_nr=149
		// af parent scope:
		// af parent scope:
		return _t292;
	}
	int i = t.month - 1;
	 string _t293 = string_substr(_const_time__months_string, i * 3, (i + 1) * 3);
	// autofree_scope_vars(pos=3185 line_nr=150 scope.pos=3087 scope.end_pos=3232)
	// var "t" var.pos=3088 var.line_nr=145
	// var "i" var.pos=3168 var.line_nr=149
	// af parent scope:
	// af parent scope:
	return _t293;
}

time__Time time__new_time(time__Time t) {
	if (t.v_unix != 0) {
		// autofree_scope_vars(pos=3346 line_nr=156 scope.pos=3343 scope.end_pos=3357)
		// af parent scope:
		// var "t" var.pos=3312 var.line_nr=154
		// var "tt" var.pos=3360 var.line_nr=158
		// var "utime" var.pos=3496 var.line_nr=166
		// af parent scope:
		// af parent scope:
		return t;
	}
	struct tm tt = (struct tm){
		.tm_year = t.year - 1900,
		.tm_mon = t.month - 1,
		.tm_mday = t.day,
		.tm_hour = t.hour,
		.tm_min = t.minute,
		.tm_sec = t.second,
	};
	u64 utime = ((u64)(time__make_unix_time(tt)));
	 time__Time _t294 = (time__Time){t.year,t.month,t.day,t.hour,t.minute,t.second,t.microsecond,.v_unix = utime,};
	// autofree_scope_vars(pos=3529 line_nr=167 scope.pos=3303 scope.end_pos=3567)
	// var "t" var.pos=3312 var.line_nr=154
	// var "tt" var.pos=3360 var.line_nr=158
	// var "utime" var.pos=3496 var.line_nr=166
	// af parent scope:
	// af parent scope:
	return _t294;
}

// Attr: [inline]
inline int time__Time_unix_time(time__Time t) {
	 int _t295 = ((int)(t.v_unix));
	// autofree_scope_vars(pos=3645 line_nr=176 scope.pos=3618 scope.end_pos=3665)
	// var "t" var.pos=3619 var.line_nr=175
	// af parent scope:
	// af parent scope:
	return _t295;
}

// Attr: [inline]
inline u64 time__Time_unix_time_milli(time__Time t) {
	 u64 _t296 = t.v_unix * 1000 + ((u64)(t.microsecond / 1000));
	// autofree_scope_vars(pos=3783 line_nr=182 scope.pos=3750 scope.end_pos=3833)
	// var "t" var.pos=3751 var.line_nr=181
	// af parent scope:
	// af parent scope:
	return _t296;
}

time__Time time__Time_add(time__Time t, time__Duration d) {
	i64 microseconds = ((i64)(t.v_unix)) * 1000 * 1000 + t.microsecond + time__Duration_microseconds(d);
	i64 v_unix = microseconds / (1000 * 1000);
	i64 micro = microseconds % (1000 * 1000);
	 time__Time _t297 = time__unix2(((int)(v_unix)), ((int)(micro)));
	// autofree_scope_vars(pos=4079 line_nr=190 scope.pos=3892 scope.end_pos=4116)
	// var "t" var.pos=3893 var.line_nr=186
	// var "d" var.pos=3905 var.line_nr=186
	// var "microseconds" var.pos=3925 var.line_nr=187
	// var "unix" var.pos=4003 var.line_nr=188
	// var "micro" var.pos=4041 var.line_nr=189
	// af parent scope:
	// af parent scope:
	return _t297;
}

time__Time time__Time_add_seconds(time__Time t, int seconds) {
	 time__Time _t298 = time__Time_add(t, seconds * _const_time__second);
	// autofree_scope_vars(pos=4241 line_nr=195 scope.pos=4200 scope.end_pos=4278)
	// var "t" var.pos=4201 var.line_nr=194
	// var "seconds" var.pos=4221 var.line_nr=194
	// af parent scope:
	// af parent scope:
	return _t298;
}

time__Time time__Time_add_days(time__Time t, int days) {
	 time__Time _t299 = time__Time_add(t, days * 24 * _const_time__hour);
	// autofree_scope_vars(pos=4391 line_nr=200 scope.pos=4356 scope.end_pos=4428)
	// var "t" var.pos=4357 var.line_nr=199
	// var "days" var.pos=4374 var.line_nr=199
	// af parent scope:
	// af parent scope:
	return _t299;
}

VV_LOCAL_SYMBOL int time__since(time__Time t) {
	 int _t300 = 0;
	// autofree_scope_vars(pos=4565 line_nr=206 scope.pos=4499 scope.end_pos=4575)
	// var "t" var.pos=4505 var.line_nr=204
	// af parent scope:
	// af parent scope:
	return _t300;
}

string time__Time_relative(time__Time t) {
	time__Time znow = time__now();
	u64 secs = znow.v_unix - t.v_unix;
	if (secs <= 30) {
		 string _t301 = _SLIT("now");
		// autofree_scope_vars(pos=4840 line_nr=217 scope.pos=4769 scope.end_pos=4855)
		// af parent scope:
		// var "t" var.pos=4683 var.line_nr=211
		// var "znow" var.pos=4712 var.line_nr=212
		// var "secs" var.pos=4727 var.line_nr=213
		// af parent scope:
		// af parent scope:
		return _t301;
	}
	if (secs < 60) {
		 string _t302 = _SLIT("1m");
		// autofree_scope_vars(pos=4874 line_nr=220 scope.pos=4871 scope.end_pos=4888)
		// af parent scope:
		// var "t" var.pos=4683 var.line_nr=211
		// var "znow" var.pos=4712 var.line_nr=212
		// var "secs" var.pos=4727 var.line_nr=213
		// af parent scope:
		// af parent scope:
		return _t302;
	}
	if (secs < 3600) {
		u64 m = secs / 60;
		if (m == 1) {
			 string _t303 = _SLIT("1 minute ago");
			// autofree_scope_vars(pos=4941 line_nr=225 scope.pos=4937 scope.end_pos=4966)
			// af parent scope:
			// var "m" var.pos=4910 var.line_nr=223
			// af parent scope:
			// var "t" var.pos=4683 var.line_nr=211
			// var "znow" var.pos=4712 var.line_nr=212
			// var "secs" var.pos=4727 var.line_nr=213
			// af parent scope:
			// af parent scope:
			return _t303;
		}
		 string _t304 = _STR("%"PRIu64"\000 minutes ago", 2, m);
		// autofree_scope_vars(pos=4969 line_nr=227 scope.pos=4906 scope.end_pos=4995)
		// var "m" var.pos=4910 var.line_nr=223
		// af parent scope:
		// var "t" var.pos=4683 var.line_nr=211
		// var "znow" var.pos=4712 var.line_nr=212
		// var "secs" var.pos=4727 var.line_nr=213
		// af parent scope:
		// af parent scope:
		return _t304;
	}
	if (secs < 3600 * 24) {
		u64 h = secs / 3600;
		if (h == 1) {
			 string _t305 = _SLIT("1 hour ago");
			// autofree_scope_vars(pos=5055 line_nr=232 scope.pos=5051 scope.end_pos=5078)
			// af parent scope:
			// var "h" var.pos=5022 var.line_nr=230
			// af parent scope:
			// var "t" var.pos=4683 var.line_nr=211
			// var "znow" var.pos=4712 var.line_nr=212
			// var "secs" var.pos=4727 var.line_nr=213
			// af parent scope:
			// af parent scope:
			return _t305;
		}
		 string _t306 = _STR("%"PRIu64"\000 hours ago", 2, h);
		// autofree_scope_vars(pos=5081 line_nr=234 scope.pos=5018 scope.end_pos=5105)
		// var "h" var.pos=5022 var.line_nr=230
		// af parent scope:
		// var "t" var.pos=4683 var.line_nr=211
		// var "znow" var.pos=4712 var.line_nr=212
		// var "secs" var.pos=4727 var.line_nr=213
		// af parent scope:
		// af parent scope:
		return _t306;
	}
	if (secs < 3600 * 24 * 5) {
		u64 d = secs / 3600 / 24;
		if (d == 1) {
			 string _t307 = _SLIT("1 day ago");
			// autofree_scope_vars(pos=5174 line_nr=239 scope.pos=5170 scope.end_pos=5196)
			// af parent scope:
			// var "d" var.pos=5136 var.line_nr=237
			// af parent scope:
			// var "t" var.pos=4683 var.line_nr=211
			// var "znow" var.pos=4712 var.line_nr=212
			// var "secs" var.pos=4727 var.line_nr=213
			// af parent scope:
			// af parent scope:
			return _t307;
		}
		 string _t308 = _STR("%"PRIu64"\000 days ago", 2, d);
		// autofree_scope_vars(pos=5199 line_nr=241 scope.pos=5132 scope.end_pos=5222)
		// var "d" var.pos=5136 var.line_nr=237
		// af parent scope:
		// var "t" var.pos=4683 var.line_nr=211
		// var "znow" var.pos=4712 var.line_nr=212
		// var "secs" var.pos=4727 var.line_nr=213
		// af parent scope:
		// af parent scope:
		return _t308;
	}
	if (secs > 3600 * 24 * 10000) {
		 string _t309 = _SLIT("");
		// autofree_scope_vars(pos=5256 line_nr=244 scope.pos=5253 scope.end_pos=5268)
		// af parent scope:
		// var "t" var.pos=4683 var.line_nr=211
		// var "znow" var.pos=4712 var.line_nr=212
		// var "secs" var.pos=4727 var.line_nr=213
		// af parent scope:
		// af parent scope:
		return _t309;
	}
	 string _t310 = time__Time_md(t);
	// autofree_scope_vars(pos=5270 line_nr=246 scope.pos=4682 scope.end_pos=5285)
	// var "t" var.pos=4683 var.line_nr=211
	// var "znow" var.pos=4712 var.line_nr=212
	// var "secs" var.pos=4727 var.line_nr=213
	// af parent scope:
	// af parent scope:
	return _t310;
}

string time__Time_relative_short(time__Time t) {
	time__Time znow = time__now();
	u64 secs = znow.v_unix - t.v_unix;
	if (secs <= 30) {
		 string _t311 = _SLIT("now");
		// autofree_scope_vars(pos=5919 line_nr=268 scope.pos=5848 scope.end_pos=5934)
		// af parent scope:
		// var "t" var.pos=5756 var.line_nr=262
		// var "znow" var.pos=5791 var.line_nr=263
		// var "secs" var.pos=5806 var.line_nr=264
		// af parent scope:
		// af parent scope:
		return _t311;
	}
	if (secs < 60) {
		 string _t312 = _SLIT("1m");
		// autofree_scope_vars(pos=5953 line_nr=271 scope.pos=5950 scope.end_pos=5967)
		// af parent scope:
		// var "t" var.pos=5756 var.line_nr=262
		// var "znow" var.pos=5791 var.line_nr=263
		// var "secs" var.pos=5806 var.line_nr=264
		// af parent scope:
		// af parent scope:
		return _t312;
	}
	if (secs < 3600) {
		 string _t313 = _STR("%"PRIu64"\000m", 2, secs / 60);
		// autofree_scope_vars(pos=5988 line_nr=274 scope.pos=5985 scope.end_pos=6013)
		// af parent scope:
		// var "t" var.pos=5756 var.line_nr=262
		// var "znow" var.pos=5791 var.line_nr=263
		// var "secs" var.pos=5806 var.line_nr=264
		// af parent scope:
		// af parent scope:
		return _t313;
	}
	if (secs < 3600 * 24) {
		 string _t314 = _STR("%"PRIu64"\000h", 2, secs / 3600);
		// autofree_scope_vars(pos=6039 line_nr=277 scope.pos=6036 scope.end_pos=6066)
		// af parent scope:
		// var "t" var.pos=5756 var.line_nr=262
		// var "znow" var.pos=5791 var.line_nr=263
		// var "secs" var.pos=5806 var.line_nr=264
		// af parent scope:
		// af parent scope:
		return _t314;
	}
	if (secs < 3600 * 24 * 5) {
		 string _t315 = _STR("%"PRIu64"\000d", 2, secs / 3600 / 24);
		// autofree_scope_vars(pos=6096 line_nr=280 scope.pos=6093 scope.end_pos=6128)
		// af parent scope:
		// var "t" var.pos=5756 var.line_nr=262
		// var "znow" var.pos=5791 var.line_nr=263
		// var "secs" var.pos=5806 var.line_nr=264
		// af parent scope:
		// af parent scope:
		return _t315;
	}
	if (secs > 3600 * 24 * 10000) {
		 string _t316 = _SLIT("");
		// autofree_scope_vars(pos=6162 line_nr=283 scope.pos=6159 scope.end_pos=6174)
		// af parent scope:
		// var "t" var.pos=5756 var.line_nr=262
		// var "znow" var.pos=5791 var.line_nr=263
		// var "secs" var.pos=5806 var.line_nr=264
		// af parent scope:
		// af parent scope:
		return _t316;
	}
	 string _t317 = time__Time_md(t);
	// autofree_scope_vars(pos=6176 line_nr=285 scope.pos=5755 scope.end_pos=6191)
	// var "t" var.pos=5756 var.line_nr=262
	// var "znow" var.pos=5791 var.line_nr=263
	// var "secs" var.pos=5806 var.line_nr=264
	// af parent scope:
	// af parent scope:
	return _t317;
}

int time__day_of_week(int y, int m, int d) {
	Array_int t = new_array_from_c_array(12, 12, sizeof(int), _MOV((int[12]){
			0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4}));
	int sy = y;
	if (m < 3) {
		sy = sy - 1;
	}
	 int _t318 = (sy + sy / 4 - sy / 100 + sy / 400 + (*(int*)/*ee elem_typ */array_get(t, m - 1)) + d - 1) % 7 + 1;
	// autofree_scope_vars(pos=6500 line_nr=298 scope.pos=6291 scope.end_pos=6571)
	// var "y" var.pos=6303 var.line_nr=290
	// var "m" var.pos=6310 var.line_nr=290
	// var "d" var.pos=6317 var.line_nr=290
	// var "t" var.pos=6416 var.line_nr=293
	// var "sy" var.pos=6463 var.line_nr=294
	// af parent scope:
	// af parent scope:
	return _t318;
}

int time__Time_day_of_week(time__Time t) {
	 int _t319 = time__day_of_week(t.year, t.month, t.day);
	// autofree_scope_vars(pos=6664 line_nr=303 scope.pos=6635 scope.end_pos=6708)
	// var "t" var.pos=6636 var.line_nr=302
	// af parent scope:
	// af parent scope:
	return _t319;
}

string time__Time_weekday_str(time__Time t) {
	int i = time__Time_day_of_week(t) - 1;
	 string _t320 = string_substr(_const_time__days_string, i * 3, (i + 1) * 3);
	// autofree_scope_vars(pos=6828 line_nr=309 scope.pos=6770 scope.end_pos=6873)
	// var "t" var.pos=6771 var.line_nr=307
	// var "i" var.pos=6803 var.line_nr=308
	// af parent scope:
	// af parent scope:
	return _t320;
}

string time__Time_long_weekday_str(time__Time t) {
	int i = time__Time_day_of_week(t) - 1;
	 string _t321 = (*(string*)/*ee elem_typ */array_get(_const_time__long_days, i));
	// autofree_scope_vars(pos=6998 line_nr=315 scope.pos=6935 scope.end_pos=7024)
	// var "t" var.pos=6936 var.line_nr=313
	// var "i" var.pos=6973 var.line_nr=314
	// af parent scope:
	// af parent scope:
	return _t321;
}

i64 time__ticks(void) {
	#if defined(_WIN32)
	{
		 i64 _t322 = GetTickCount();
		// autofree_scope_vars(pos=7134 line_nr=321 scope.pos=7131 scope.end_pos=7160)
		// af parent scope:
		// af parent scope:
		// af parent scope:
		return _t322;
	}
	#else
	{
	}
	#endif
	return 0;
}

// Attr: [deprecated]
void time__sleep_ms(int milliseconds) {
	time__wait(milliseconds * _const_time__millisecond);
}

// Attr: [deprecated]
void time__usleep(int microseconds) {
	time__wait(microseconds * _const_time__microsecond);
}

bool time__is_leap_year(int year) {
	 bool _t323 = (year % 4 == 0) && (year % 100 != 0 || year % 400 == 0);
	// autofree_scope_vars(pos=8160 line_nr=354 scope.pos=8130 scope.end_pos=8224)
	// var "year" var.pos=8143 var.line_nr=353
	// af parent scope:
	// af parent scope:
	return _t323;
}

Option_int time__days_in_month(int month, int year) {
	if (month > 12 || month < 1) {
		return (Option_int){ .state=2, .err=v_error(_STR("Invalid month: %"PRId32"", 1, month)) };
	}
	int extra = (month == 2 && time__is_leap_year(year) ? (1) : (0));
	int res = (*(int*)/*ee elem_typ */array_get(_const_time__month_days, month - 1)) + extra;
	Option_int _t324;
	opt_ok(&(int[]) { res }, (Option*)(&_t324), sizeof(int));
	// autofree_scope_vars(pos=8515 line_nr=364 scope.pos=8294 scope.end_pos=8527)
	// var "month" var.pos=8308 var.line_nr=358
	// var "year" var.pos=8319 var.line_nr=358
	// var "extra" var.pos=8410 var.line_nr=362
	// var "res" var.pos=8473 var.line_nr=363
	// af parent scope:
	// af parent scope:
	return _t324;
}

string time__Time_str(time__Time t) {
	 string _t325 = time__Time_format_ss(t);
	// autofree_scope_vars(pos=8732 line_nr=371 scope.pos=8620 scope.end_pos=8754)
	// var "t" var.pos=8621 var.line_nr=368
	// af parent scope:
	// af parent scope:
	return _t325;
}

VV_LOCAL_SYMBOL time__Time time__convert_ctime(struct tm t, int microsecond) {
	 time__Time _t326 = (time__Time){
		.year = t.tm_year + 1900,
		.month = t.tm_mon + 1,
		.day = t.tm_mday,
		.hour = t.tm_hour,
		.minute = t.tm_min,
		.second = t.tm_sec,
		.microsecond = microsecond,
		.v_unix = ((u64)(time__make_unix_time(t))),
	};
	// autofree_scope_vars(pos=8852 line_nr=376 scope.pos=8806 scope.end_pos=9052)
	// var "t" var.pos=8820 var.line_nr=375
	// var "microsecond" var.pos=8828 var.line_nr=375
	// af parent scope:
	// af parent scope:
	return _t326;
}

// TypeDecl
i64 time__Duration_nanoseconds(time__Duration d) {
	 i64 _t327 = ((i64)(d));
	// autofree_scope_vars(pos=9517 line_nr=403 scope.pos=9484 scope.end_pos=9532)
	// var "d" var.pos=9485 var.line_nr=402
	// af parent scope:
	// af parent scope:
	return _t327;
}

i64 time__Duration_microseconds(time__Duration d) {
	 i64 _t328 = ((i64)(d)) / 1000;
	// autofree_scope_vars(pos=9651 line_nr=408 scope.pos=9617 scope.end_pos=9673)
	// var "d" var.pos=9618 var.line_nr=407
	// af parent scope:
	// af parent scope:
	return _t328;
}

i64 time__Duration_milliseconds(time__Duration d) {
	 i64 _t329 = ((i64)(d)) / 1000000;
	// autofree_scope_vars(pos=9792 line_nr=413 scope.pos=9758 scope.end_pos=9817)
	// var "d" var.pos=9759 var.line_nr=412
	// af parent scope:
	// af parent scope:
	return _t329;
}

f64 time__Duration_seconds(time__Duration d) {
	i64 sec = d / _const_time__second;
	i64 nsec = d % _const_time__second;
	 f64 _t330 = ((f64)(sec)) + ((f64)(nsec)) / 1e9;
	// autofree_scope_vars(pos=10101 line_nr=422 scope.pos=10023 scope.end_pos=10136)
	// var "d" var.pos=10024 var.line_nr=419
	// var "sec" var.pos=10053 var.line_nr=420
	// var "nsec" var.pos=10077 var.line_nr=421
	// af parent scope:
	// af parent scope:
	return _t330;
}

f64 time__Duration_minutes(time__Duration d) {
	i64 min = d / _const_time__minute;
	i64 nsec = d % _const_time__minute;
	 f64 _t331 = ((f64)(min)) + ((f64)(nsec)) / (60 * 1e9);
	// autofree_scope_vars(pos=10295 line_nr=429 scope.pos=10217 scope.end_pos=10337)
	// var "d" var.pos=10218 var.line_nr=426
	// var "min" var.pos=10247 var.line_nr=427
	// var "nsec" var.pos=10271 var.line_nr=428
	// af parent scope:
	// af parent scope:
	return _t331;
}

f64 time__Duration_hours(time__Duration d) {
	i64 hr = d / _const_time__hour;
	i64 nsec = d % _const_time__hour;
	 f64 _t332 = ((f64)(hr)) + ((f64)(nsec)) / (60 * 60 * 1e9);
	// autofree_scope_vars(pos=10485 line_nr=436 scope.pos=10414 scope.end_pos=10531)
	// var "d" var.pos=10415 var.line_nr=433
	// var "hr" var.pos=10442 var.line_nr=434
	// var "nsec" var.pos=10463 var.line_nr=435
	// af parent scope:
	// af parent scope:
	return _t332;
}

int time__offset(void) {
	time__Time t = time__now();
	time__Time local = time__Time_local(t);
	 int _t333 = ((int)(local.v_unix - t.v_unix));
	// autofree_scope_vars(pos=10639 line_nr=443 scope.pos=10592 scope.end_pos=10672)
	// var "t" var.pos=10608 var.line_nr=441
	// var "local" var.pos=10620 var.line_nr=442
	// af parent scope:
	// af parent scope:
	return _t333;
}

VV_LOCAL_SYMBOL int time__make_unix_time(struct tm t) {
	 int _t334 = ((int)(_mkgmtime(&t)));
	// autofree_scope_vars(pos=1303 line_nr=59 scope.pos=1274 scope.end_pos=1332)
	// var "t" var.pos=1289 var.line_nr=58
	// af parent scope:
	// af parent scope:
	return _t334;
}

VV_LOCAL_SYMBOL u64 time__init_win_time_freq(void) {
	u64 f = ((u64)(0U));
	QueryPerformanceFrequency(&f);
	// autofree_scope_vars(pos=1411 line_nr=65 scope.pos=1338 scope.end_pos=1421)
	// var "f" var.pos=1366 var.line_nr=63
	// af parent scope:
	// af parent scope:
	return f;
}

VV_LOCAL_SYMBOL u64 time__init_win_time_start(void) {
	u64 s = ((u64)(0U));
	QueryPerformanceCounter(&s);
	// autofree_scope_vars(pos=1499 line_nr=71 scope.pos=1427 scope.end_pos=1509)
	// var "s" var.pos=1456 var.line_nr=69
	// af parent scope:
	// af parent scope:
	return s;
}

u64 time__sys_mono_now(void) {
	u64 tm = ((u64)(0U));
	QueryPerformanceCounter(&tm);
	 u64 _t335 = (tm - _const_time__start_time) * 1000000000 / _const_time__freq_time;
	// autofree_scope_vars(pos=1727 line_nr=78 scope.pos=1634 scope.end_pos=1788)
	// var "tm" var.pos=1656 var.line_nr=76
	// af parent scope:
	// af parent scope:
	return _t335;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL u64 time__vpc_now(void) {
	u64 tm = ((u64)(0U));
	QueryPerformanceCounter(&tm);
	// autofree_scope_vars(pos=1980 line_nr=87 scope.pos=1918 scope.end_pos=1991)
	// var "tm" var.pos=1935 var.line_nr=85
	// af parent scope:
	// af parent scope:
	return tm;
}

VV_LOCAL_SYMBOL int time__local_as_unix_time(void) {
	time_t t = time(0);
	struct tm* tm = localtime(&t);
	 int _t336 = time__make_unix_time(*tm);
	// autofree_scope_vars(pos=2129 line_nr=94 scope.pos=2063 scope.end_pos=2156)
	// var "t" var.pos=2091 var.line_nr=92
	// var "tm" var.pos=2107 var.line_nr=93
	// af parent scope:
	// af parent scope:
	return _t336;
}

time__Time time__Time_local(time__Time t) {
	time__SystemTime st_utc = (time__SystemTime){
		.year = ((u16)(t.year)),
		.month = ((u16)(t.month)),
		.day_of_week = 0,
		.day = ((u16)(t.day)),
		.hour = ((u16)(t.hour)),
		.minute = ((u16)(t.minute)),
		.second = ((u16)(t.second)),
		.millisecond = 0,
	};
	time__SystemTime st_local = (time__SystemTime){.year = 0,.month = 0,.day_of_week = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.millisecond = 0,};
	SystemTimeToTzSpecificLocalTime(((voidptr)(0)), &st_utc, &st_local);
	time__Time t_local = (time__Time){
		.year = st_local.year,
		.month = st_local.month,
		.day = st_local.day,
		.hour = st_local.hour,
		.minute = st_local.minute,
		.second = st_local.second,
		.microsecond = st_local.millisecond * 1000,
		.v_unix = ((u64)(time__SystemTime_unix_time(st_local))),
	};
	// autofree_scope_vars(pos=2778 line_nr=119 scope.pos=2247 scope.end_pos=2794)
	// var "t" var.pos=2248 var.line_nr=98
	// var "st_utc" var.pos=2272 var.line_nr=99
	// var "st_local" var.pos=2426 var.line_nr=107
	// var "t_local" var.pos=2519 var.line_nr=109
	// af parent scope:
	// af parent scope:
	return t_local;
}

VV_LOCAL_SYMBOL time__Time time__win_now(void) {
	struct _FILETIME ft_utc = (struct _FILETIME){0};
	GetSystemTimeAsFileTime(&ft_utc);
	time__SystemTime st_utc = (time__SystemTime){.year = 0,.month = 0,.day_of_week = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.millisecond = 0,};
	FileTimeToSystemTime(&ft_utc, &st_utc);
	time__SystemTime st_local = (time__SystemTime){.year = 0,.month = 0,.day_of_week = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.millisecond = 0,};
	SystemTimeToTzSpecificLocalTime(((voidptr)(0)), &st_utc, &st_local);
	time__Time t = (time__Time){
		.year = st_local.year,
		.month = st_local.month,
		.day = st_local.day,
		.hour = st_local.hour,
		.minute = st_local.minute,
		.second = st_local.second,
		.microsecond = st_local.millisecond * 1000,
		.v_unix = ((u64)(time__SystemTime_unix_time(st_local))),
	};
	// autofree_scope_vars(pos=3521 line_nr=142 scope.pos=3052 scope.end_pos=3531)
	// var "ft_utc" var.pos=3070 var.line_nr=126
	// var "st_utc" var.pos=3131 var.line_nr=128
	// var "st_local" var.pos=3197 var.line_nr=130
	// var "t" var.pos=3290 var.line_nr=132
	// af parent scope:
	// af parent scope:
	return t;
}

VV_LOCAL_SYMBOL time__Time time__win_utc(void) {
	struct _FILETIME ft_utc = (struct _FILETIME){0};
	GetSystemTimeAsFileTime(&ft_utc);
	time__SystemTime st_utc = (time__SystemTime){.year = 0,.month = 0,.day_of_week = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.millisecond = 0,};
	FileTimeToSystemTime(&ft_utc, &st_utc);
	time__Time t = (time__Time){
		.year = st_utc.year,
		.month = st_utc.month,
		.day = st_utc.day,
		.hour = st_utc.hour,
		.minute = st_utc.minute,
		.second = st_utc.second,
		.microsecond = st_utc.millisecond * 1000,
		.v_unix = ((u64)(time__SystemTime_unix_time(st_utc))),
	};
	// autofree_scope_vars(pos=4120 line_nr=163 scope.pos=3760 scope.end_pos=4130)
	// var "ft_utc" var.pos=3778 var.line_nr=149
	// var "st_utc" var.pos=3839 var.line_nr=151
	// var "t" var.pos=3905 var.line_nr=153
	// af parent scope:
	// af parent scope:
	return t;
}

int time__SystemTime_unix_time(time__SystemTime st) {
	struct tm tt = (struct tm){
		.tm_year = st.year - 1900,
		.tm_mon = st.month - 1,
		.tm_mday = st.day,
		.tm_hour = st.hour,
		.tm_min = st.minute,
		.tm_sec = st.second,
	};
	 int _t337 = time__make_unix_time(tt);
	// autofree_scope_vars(pos=4348 line_nr=176 scope.pos=4172 scope.end_pos=4375)
	// var "st" var.pos=4173 var.line_nr=167
	// var "tt" var.pos=4207 var.line_nr=168
	// af parent scope:
	// af parent scope:
	return _t337;
}

time__Time time__darwin_now(void) {
	 time__Time _t338 = (time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.microsecond = 0,.v_unix = 0,};
	// autofree_scope_vars(pos=4444 line_nr=181 scope.pos=4424 scope.end_pos=4459)
	// af parent scope:
	// af parent scope:
	return _t338;
}

time__Time time__linux_now(void) {
	 time__Time _t339 = (time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.microsecond = 0,.v_unix = 0,};
	// autofree_scope_vars(pos=4527 line_nr=186 scope.pos=4508 scope.end_pos=4542)
	// af parent scope:
	// af parent scope:
	return _t339;
}

time__Time time__solaris_now(void) {
	 time__Time _t340 = (time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.microsecond = 0,.v_unix = 0,};
	// autofree_scope_vars(pos=4612 line_nr=191 scope.pos=4591 scope.end_pos=4627)
	// af parent scope:
	// af parent scope:
	return _t340;
}

time__Time time__darwin_utc(void) {
	 time__Time _t341 = (time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.microsecond = 0,.v_unix = 0,};
	// autofree_scope_vars(pos=4696 line_nr=196 scope.pos=4676 scope.end_pos=4711)
	// af parent scope:
	// af parent scope:
	return _t341;
}

time__Time time__linux_utc(void) {
	 time__Time _t342 = (time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.microsecond = 0,.v_unix = 0,};
	// autofree_scope_vars(pos=4779 line_nr=201 scope.pos=4760 scope.end_pos=4794)
	// af parent scope:
	// af parent scope:
	return _t342;
}

time__Time time__solaris_utc(void) {
	 time__Time _t343 = (time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.microsecond = 0,.v_unix = 0,};
	// autofree_scope_vars(pos=4864 line_nr=206 scope.pos=4843 scope.end_pos=4879)
	// af parent scope:
	// af parent scope:
	return _t343;
}

// Attr: [deprecated]
void time__wait(time__Duration duration) {
	Sleep(((int)(duration / _const_time__millisecond)));
}

void time__sleep(time__Duration duration) {
	Sleep(((int)(duration / _const_time__millisecond)));
}

time__Time time__unix(int abs) {
	int day_offset = abs / _const_time__seconds_per_day;
	if (abs % _const_time__seconds_per_day < 0) {
		day_offset--;
	}
	multi_return_int_int_int mr_472 = time__calculate_date_from_offset(day_offset);
	int year = mr_472.arg0;
	int month = mr_472.arg1;
	int day = mr_472.arg2;
	multi_return_int_int_int mr_528 = time__calculate_time_from_offset(abs % _const_time__seconds_per_day);
	int hr = mr_528.arg0;
	int min = mr_528.arg1;
	int sec = mr_528.arg2;
	 time__Time _t344 = (time__Time){
		.year = year,
		.month = month,
		.day = day,
		.hour = hr,
		.minute = min,
		.second = sec,
		.microsecond = 0,
		.v_unix = ((u64)(abs)),
	};
	// autofree_scope_vars(pos=581 line_nr=15 scope.pos=236 scope.end_pos=693)
	// var "abs" var.pos=241 var.line_nr=6
	// var "day_offset" var.pos=290 var.line_nr=8
	// var "year" var.pos=455 var.line_nr=13
	// var "month" var.pos=461 var.line_nr=13
	// var "day" var.pos=468 var.line_nr=13
	// var "hr" var.pos=515 var.line_nr=14
	// var "min" var.pos=519 var.line_nr=14
	// var "sec" var.pos=524 var.line_nr=14
	// af parent scope:
	// af parent scope:
	return _t344;
}

time__Time time__unix2(int abs, int microsecond) {
	int day_offset = abs / _const_time__seconds_per_day;
	if (abs % _const_time__seconds_per_day < 0) {
		day_offset--;
	}
	multi_return_int_int_int mr_1025 = time__calculate_date_from_offset(day_offset);
	int year = mr_1025.arg0;
	int month = mr_1025.arg1;
	int day = mr_1025.arg2;
	multi_return_int_int_int mr_1081 = time__calculate_time_from_offset(abs % _const_time__seconds_per_day);
	int hr = mr_1081.arg0;
	int min = mr_1081.arg1;
	int sec = mr_1081.arg2;
	 time__Time _t345 = (time__Time){
		.year = year,
		.month = month,
		.day = day,
		.hour = hr,
		.minute = min,
		.second = sec,
		.microsecond = microsecond,
		.v_unix = ((u64)(abs)),
	};
	// autofree_scope_vars(pos=1134 line_nr=36 scope.pos=771 scope.end_pos=1273)
	// var "abs" var.pos=777 var.line_nr=27
	// var "microsecond" var.pos=786 var.line_nr=27
	// var "day_offset" var.pos=843 var.line_nr=29
	// var "year" var.pos=1008 var.line_nr=34
	// var "month" var.pos=1014 var.line_nr=34
	// var "day" var.pos=1021 var.line_nr=34
	// var "hr" var.pos=1068 var.line_nr=35
	// var "min" var.pos=1072 var.line_nr=35
	// var "sec" var.pos=1077 var.line_nr=35
	// af parent scope:
	// af parent scope:
	return _t345;
}

VV_LOCAL_SYMBOL multi_return_int_int_int time__calculate_date_from_offset(int day_offset_) {
	int day_offset = day_offset_;
	int year = 2001;
	day_offset -= 31 * 365 + 8;
	year += (day_offset / _const_time__days_per_400_years) * 400;
	day_offset %= _const_time__days_per_400_years;
	if (day_offset == _const_time__days_per_100_years * 4) {
		year += 300;
		day_offset -= _const_time__days_per_100_years * 3;
	} else {
		year += (day_offset / _const_time__days_per_100_years) * 100;
		day_offset %= _const_time__days_per_100_years;
	}
	if (day_offset == _const_time__days_per_4_years * 25) {
		year += 96;
		day_offset -= _const_time__days_per_4_years * 24;
	} else {
		year += (day_offset / _const_time__days_per_4_years) * 4;
		day_offset %= _const_time__days_per_4_years;
	}
	if (day_offset == 365 * 4) {
		year += 3;
		day_offset -= 365 * 3;
	} else {
		year += (day_offset / 365);
		day_offset %= 365;
	}
	if (day_offset < 0) {
		year--;
		if (time__is_leap_year(year)) {
			day_offset += 366;
		} else {
			day_offset += 365;
		}
	}
	if (time__is_leap_year(year)) {
		if (day_offset > 31 + 29 - 1) {
			day_offset--;
		} else if (day_offset == 31 + 29 - 1) {
			return (multi_return_int_int_int){.arg0=year, .arg1=2, .arg2=29};
		}
	}
	int estimated_month = day_offset / 31;
	for (;;) {
		if (!(day_offset >= (*(int*)/*ee elem_typ */array_get(_const_time__days_before, estimated_month + 1)))) break;
		estimated_month++;
	}
	for (;;) {
		if (!(day_offset < (*(int*)/*ee elem_typ */array_get(_const_time__days_before, estimated_month)))) break;
		if (estimated_month == 0) {
			break;
		}
		estimated_month--;
	}
	day_offset -= (*(int*)/*ee elem_typ */array_get(_const_time__days_before, estimated_month));
	return (multi_return_int_int_int){.arg0=year, .arg1=estimated_month + 1, .arg2=day_offset + 1};
}

VV_LOCAL_SYMBOL multi_return_int_int_int time__calculate_time_from_offset(int second_offset_) {
	int second_offset = second_offset_;
	if (second_offset < 0) {
		second_offset += _const_time__seconds_per_day;
	}
	int hour_ = second_offset / _const_time__seconds_per_hour;
	second_offset %= _const_time__seconds_per_hour;
	int min = second_offset / _const_time__seconds_per_minute;
	second_offset %= _const_time__seconds_per_minute;
	return (multi_return_int_int_int){.arg0=hour_, .arg1=min, .arg2=second_offset};
}

// Attr: [inline]
inline int math__mathutil__min_T_int(int a, int b) {
	if (a < b) {
		// autofree_scope_vars(pos=237 line_nr=8 scope.pos=234 scope.end_pos=248)
		// af parent scope:
		// var "a" var.pos=210 var.line_nr=6
		// var "b" var.pos=215 var.line_nr=6
		// af parent scope:
		// af parent scope:
		return a;
	} else {
		// autofree_scope_vars(pos=258 line_nr=10 scope.pos=255 scope.end_pos=269)
		// af parent scope:
		// var "a" var.pos=210 var.line_nr=6
		// var "b" var.pos=215 var.line_nr=6
		// af parent scope:
		// af parent scope:
		return b;
	}
	return 0;
}

// Attr: [inline]
inline int math__mathutil__max_T_int(int a, int b) {
	if (a > b) {
		// autofree_scope_vars(pos=324 line_nr=17 scope.pos=321 scope.end_pos=335)
		// af parent scope:
		// var "a" var.pos=297 var.line_nr=15
		// var "b" var.pos=302 var.line_nr=15
		// af parent scope:
		// af parent scope:
		return a;
	} else {
		// autofree_scope_vars(pos=345 line_nr=19 scope.pos=342 scope.end_pos=356)
		// af parent scope:
		// var "a" var.pos=297 var.line_nr=15
		// var "b" var.pos=302 var.line_nr=15
		// af parent scope:
		// af parent scope:
		return b;
	}
	return 0;
}

// Attr: [inline]

string v__token__Position_str(v__token__Position pos) {
	 string _t346 = _STR("Position{ line_nr: %"PRId32"\000, last_line: %"PRId32"\000, pos: %"PRId32"\000, col: %"PRId32"\000, len: %"PRId32"\000 }", 6, pos.line_nr, pos.last_line, pos.pos, pos.col, pos.len);
	// autofree_scope_vars(pos=580 line_nr=16 scope.pos=550 scope.end_pos=696)
	// var "pos" var.pos=551 var.line_nr=15
	// af parent scope:
	// af parent scope:
	return _t346;
}

v__token__Position v__token__Position_extend(v__token__Position pos, v__token__Position end) {
	 v__token__Position _t347 = (v__token__Position){.len = end.pos - pos.pos + end.len,pos.line_nr,pos.pos,pos.col,.last_line = end.last_line,};
	// autofree_scope_vars(pos=753 line_nr=20 scope.pos=706 scope.end_pos=845)
	// var "pos" var.pos=707 var.line_nr=19
	// var "end" var.pos=728 var.line_nr=19
	// af parent scope:
	// af parent scope:
	return _t347;
}

v__token__Position v__token__Position_extend_with_last_line(v__token__Position pos, v__token__Position end, int last_line) {
	 v__token__Position _t348 = (v__token__Position){.len = end.pos - pos.pos + end.len,.line_nr = pos.line_nr,.pos = pos.pos,.col = pos.col,.last_line = last_line - 1,};
	// autofree_scope_vars(pos=932 line_nr=28 scope.pos=855 scope.end_pos=1060)
	// var "pos" var.pos=856 var.line_nr=27
	// var "end" var.pos=892 var.line_nr=27
	// var "last_line" var.pos=906 var.line_nr=27
	// af parent scope:
	// af parent scope:
	return _t348;
}

void v__token__Position_update_last_line(v__token__Position* pos, int last_line) {
	pos->last_line = last_line - 1;
}

// Attr: [inline]
inline v__token__Position v__token__Token_position(v__token__Token* tok) {
	 v__token__Position _t349 = (v__token__Position){.len = tok->len,.line_nr = tok->line_nr - 1,.pos = tok->pos,.col = tok->col - 1,.last_line = tok->line_nr - 1,};
	// autofree_scope_vars(pos=1208 line_nr=43 scope.pos=1173 scope.end_pos=1334)
	// var "tok" var.pos=1174 var.line_nr=42
	// af parent scope:
	// af parent scope:
	return _t349;
}

VV_LOCAL_SYMBOL Map_string_v__token__Kind v__token__build_keys(void) {
	Map_string_v__token__Kind res = new_map(sizeof(string), sizeof(v__token__Kind), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
	for (int t = ((int)(v__token__Kind_keyword_beg)) + 1; t < ((int)(v__token__Kind_keyword_end)); ++t) {
		string key = (*(string*)/*ee elem_typ */array_get(_const_v__token__token_str, t));
		map_set(&res, &(string[]){key}, &(v__token__Kind[]) { ((v__token__Kind)(t)) });
	}
	// autofree_scope_vars(pos=3889 line_nr=182 scope.pos=3713 scope.end_pos=3901)
	// var "res" var.pos=3749 var.line_nr=177
	// af parent scope:
	// af parent scope:
	return res;
}

VV_LOCAL_SYMBOL Array_string v__token__build_token_str(void) {
	Array_string s = __new_array_with_default(_const_v__token__nr_tokens, 0, sizeof(string), &(string[]){_SLIT("")});
	array_set(&s, v__token__Kind_unknown, &(string[]) { _SLIT("unknown") });
	array_set(&s, v__token__Kind_eof, &(string[]) { _SLIT("eof") });
	array_set(&s, v__token__Kind_name, &(string[]) { _SLIT("name") });
	array_set(&s, v__token__Kind_number, &(string[]) { _SLIT("number") });
	array_set(&s, v__token__Kind_string, &(string[]) { _SLIT("string") });
	array_set(&s, v__token__Kind_chartoken, &(string[]) { _SLIT("char") });
	array_set(&s, v__token__Kind_plus, &(string[]) { _SLIT("+") });
	array_set(&s, v__token__Kind_minus, &(string[]) { _SLIT("-") });
	array_set(&s, v__token__Kind_mul, &(string[]) { _SLIT("*") });
	array_set(&s, v__token__Kind_div, &(string[]) { _SLIT("/") });
	array_set(&s, v__token__Kind_mod, &(string[]) { _SLIT("%") });
	array_set(&s, v__token__Kind_xor, &(string[]) { _SLIT("^") });
	array_set(&s, v__token__Kind_bit_not, &(string[]) { _SLIT("~") });
	array_set(&s, v__token__Kind_pipe, &(string[]) { _SLIT("|") });
	array_set(&s, v__token__Kind_hash, &(string[]) { _SLIT("#") });
	array_set(&s, v__token__Kind_amp, &(string[]) { _SLIT("&") });
	array_set(&s, v__token__Kind_inc, &(string[]) { _SLIT("++") });
	array_set(&s, v__token__Kind_dec, &(string[]) { _SLIT("--") });
	array_set(&s, v__token__Kind_and, &(string[]) { _SLIT("&&") });
	array_set(&s, v__token__Kind_logical_or, &(string[]) { _SLIT("||") });
	array_set(&s, v__token__Kind_not, &(string[]) { _SLIT("!") });
	array_set(&s, v__token__Kind_dot, &(string[]) { _SLIT(".") });
	array_set(&s, v__token__Kind_dotdot, &(string[]) { _SLIT("..") });
	array_set(&s, v__token__Kind_ellipsis, &(string[]) { _SLIT("...") });
	array_set(&s, v__token__Kind_comma, &(string[]) { _SLIT(",") });
	array_set(&s, v__token__Kind_not_in, &(string[]) { _SLIT("!in") });
	array_set(&s, v__token__Kind_not_is, &(string[]) { _SLIT("!is") });
	array_set(&s, v__token__Kind_semicolon, &(string[]) { _SLIT(";") });
	array_set(&s, v__token__Kind_colon, &(string[]) { _SLIT(":") });
	array_set(&s, v__token__Kind_arrow, &(string[]) { _SLIT("<-") });
	array_set(&s, v__token__Kind_assign, &(string[]) { _SLIT("=") });
	array_set(&s, v__token__Kind_decl_assign, &(string[]) { _SLIT(":=") });
	array_set(&s, v__token__Kind_plus_assign, &(string[]) { _SLIT("+=") });
	array_set(&s, v__token__Kind_minus_assign, &(string[]) { _SLIT("-=") });
	array_set(&s, v__token__Kind_mult_assign, &(string[]) { _SLIT("*=") });
	array_set(&s, v__token__Kind_div_assign, &(string[]) { _SLIT("/=") });
	array_set(&s, v__token__Kind_xor_assign, &(string[]) { _SLIT("^=") });
	array_set(&s, v__token__Kind_mod_assign, &(string[]) { _SLIT("%=") });
	array_set(&s, v__token__Kind_or_assign, &(string[]) { _SLIT("|=") });
	array_set(&s, v__token__Kind_and_assign, &(string[]) { _SLIT("&=") });
	array_set(&s, v__token__Kind_right_shift_assign, &(string[]) { _SLIT(">>=") });
	array_set(&s, v__token__Kind_left_shift_assign, &(string[]) { _SLIT("<<=") });
	array_set(&s, v__token__Kind_lcbr, &(string[]) { _SLIT("{") });
	array_set(&s, v__token__Kind_rcbr, &(string[]) { _SLIT("}") });
	array_set(&s, v__token__Kind_lpar, &(string[]) { _SLIT("(") });
	array_set(&s, v__token__Kind_rpar, &(string[]) { _SLIT(")") });
	array_set(&s, v__token__Kind_lsbr, &(string[]) { _SLIT("[") });
	array_set(&s, v__token__Kind_rsbr, &(string[]) { _SLIT("]") });
	array_set(&s, v__token__Kind_eq, &(string[]) { _SLIT("==") });
	array_set(&s, v__token__Kind_ne, &(string[]) { _SLIT("!=") });
	array_set(&s, v__token__Kind_gt, &(string[]) { _SLIT(">") });
	array_set(&s, v__token__Kind_lt, &(string[]) { _SLIT("<") });
	array_set(&s, v__token__Kind_ge, &(string[]) { _SLIT(">=") });
	array_set(&s, v__token__Kind_le, &(string[]) { _SLIT("<=") });
	array_set(&s, v__token__Kind_question, &(string[]) { _SLIT("?") });
	array_set(&s, v__token__Kind_left_shift, &(string[]) { _SLIT("<<") });
	array_set(&s, v__token__Kind_right_shift, &(string[]) { _SLIT(">>") });
	array_set(&s, v__token__Kind_comment, &(string[]) { _SLIT("comment") });
	array_set(&s, v__token__Kind_nl, &(string[]) { _SLIT("NLL") });
	array_set(&s, v__token__Kind_dollar, &(string[]) { _SLIT("$") });
	array_set(&s, v__token__Kind_at, &(string[]) { _SLIT("@") });
	array_set(&s, v__token__Kind_str_dollar, &(string[]) { _SLIT("$2") });
	array_set(&s, v__token__Kind_key_assert, &(string[]) { _SLIT("assert") });
	array_set(&s, v__token__Kind_key_struct, &(string[]) { _SLIT("struct") });
	array_set(&s, v__token__Kind_key_if, &(string[]) { _SLIT("if") });
	array_set(&s, v__token__Kind_key_else, &(string[]) { _SLIT("else") });
	array_set(&s, v__token__Kind_key_asm, &(string[]) { _SLIT("asm") });
	array_set(&s, v__token__Kind_key_return, &(string[]) { _SLIT("return") });
	array_set(&s, v__token__Kind_key_module, &(string[]) { _SLIT("module") });
	array_set(&s, v__token__Kind_key_sizeof, &(string[]) { _SLIT("sizeof") });
	array_set(&s, v__token__Kind_key_likely, &(string[]) { _SLIT("_likely_") });
	array_set(&s, v__token__Kind_key_unlikely, &(string[]) { _SLIT("_unlikely_") });
	array_set(&s, v__token__Kind_key_go, &(string[]) { _SLIT("go") });
	array_set(&s, v__token__Kind_key_goto, &(string[]) { _SLIT("goto") });
	array_set(&s, v__token__Kind_key_const, &(string[]) { _SLIT("const") });
	array_set(&s, v__token__Kind_key_mut, &(string[]) { _SLIT("mut") });
	array_set(&s, v__token__Kind_key_shared, &(string[]) { _SLIT("shared") });
	array_set(&s, v__token__Kind_key_lock, &(string[]) { _SLIT("lock") });
	array_set(&s, v__token__Kind_key_rlock, &(string[]) { _SLIT("rlock") });
	array_set(&s, v__token__Kind_key_type, &(string[]) { _SLIT("type") });
	array_set(&s, v__token__Kind_key_for, &(string[]) { _SLIT("for") });
	array_set(&s, v__token__Kind_key_fn, &(string[]) { _SLIT("fn") });
	array_set(&s, v__token__Kind_key_true, &(string[]) { _SLIT("true") });
	array_set(&s, v__token__Kind_key_false, &(string[]) { _SLIT("false") });
	array_set(&s, v__token__Kind_key_continue, &(string[]) { _SLIT("continue") });
	array_set(&s, v__token__Kind_key_break, &(string[]) { _SLIT("break") });
	array_set(&s, v__token__Kind_key_import, &(string[]) { _SLIT("import") });
	array_set(&s, v__token__Kind_key_unsafe, &(string[]) { _SLIT("unsafe") });
	array_set(&s, v__token__Kind_key_typeof, &(string[]) { _SLIT("typeof") });
	array_set(&s, v__token__Kind_key_dump, &(string[]) { _SLIT("dump") });
	array_set(&s, v__token__Kind_key_enum, &(string[]) { _SLIT("enum") });
	array_set(&s, v__token__Kind_key_interface, &(string[]) { _SLIT("interface") });
	array_set(&s, v__token__Kind_key_pub, &(string[]) { _SLIT("pub") });
	array_set(&s, v__token__Kind_key_in, &(string[]) { _SLIT("in") });
	array_set(&s, v__token__Kind_key_atomic, &(string[]) { _SLIT("atomic") });
	array_set(&s, v__token__Kind_key_orelse, &(string[]) { _SLIT("or") });
	array_set(&s, v__token__Kind_key_global, &(string[]) { _SLIT("__global") });
	array_set(&s, v__token__Kind_key_union, &(string[]) { _SLIT("union") });
	array_set(&s, v__token__Kind_key_static, &(string[]) { _SLIT("static") });
	array_set(&s, v__token__Kind_key_as, &(string[]) { _SLIT("as") });
	array_set(&s, v__token__Kind_key_defer, &(string[]) { _SLIT("defer") });
	array_set(&s, v__token__Kind_key_match, &(string[]) { _SLIT("match") });
	array_set(&s, v__token__Kind_key_select, &(string[]) { _SLIT("select") });
	array_set(&s, v__token__Kind_key_none, &(string[]) { _SLIT("none") });
	array_set(&s, v__token__Kind_key_offsetof, &(string[]) { _SLIT("__offsetof") });
	array_set(&s, v__token__Kind_key_is, &(string[]) { _SLIT("is") });
	// autofree_scope_vars(pos=6773 line_nr=295 scope.pos=3977 scope.end_pos=6783)
	// var "s" var.pos=4011 var.line_nr=187
	// af parent scope:
	// af parent scope:
	return s;
}

v__token__Kind v__token__key_to_token(string key) {
	 v__token__Kind _t350 = ((v__token__Kind)((*(v__token__Kind*)map_get(ADDR(map, _const_v__token__keywords), &(string[]){key}, &(v__token__Kind[]){ 0 }))));
	// autofree_scope_vars(pos=6907 line_nr=307 scope.pos=6875 scope.end_pos=6941)
	// var "key" var.pos=6888 var.line_nr=306
	// af parent scope:
	// af parent scope:
	return _t350;
}

bool v__token__is_key(string key) {
	 bool _t351 = ((int)(v__token__key_to_token(key))) > 0;
	// autofree_scope_vars(pos=6977 line_nr=311 scope.pos=6951 scope.end_pos=7012)
	// var "key" var.pos=6958 var.line_nr=310
	// af parent scope:
	// af parent scope:
	return _t351;
}

bool v__token__is_decl(v__token__Kind t) {
	 bool _t352 = (t == v__token__Kind_key_enum || t == v__token__Kind_key_interface || t == v__token__Kind_key_fn || t == v__token__Kind_key_struct || t == v__token__Kind_key_type || t == v__token__Kind_key_const || t == v__token__Kind_key_pub || t == v__token__Kind_eof);
	// autofree_scope_vars(pos=7045 line_nr=315 scope.pos=7022 scope.end_pos=7152)
	// var "t" var.pos=7030 var.line_nr=314
	// af parent scope:
	// af parent scope:
	return _t352;
}

bool v__token__Kind_is_assign(v__token__Kind t) {
	 bool _t353 = (Array_v__token__Kind_contains(_const_v__token__assign_tokens, t));
	// autofree_scope_vars(pos=7190 line_nr=321 scope.pos=7162 scope.end_pos=7223)
	// var "t" var.pos=7163 var.line_nr=320
	// af parent scope:
	// af parent scope:
	return _t353;
}

string v__token__Kind_str(v__token__Kind t) {
	 string _t354 = (*(string*)/*ee elem_typ */array_get(_const_v__token__token_str, ((int)(t))));
	// autofree_scope_vars(pos=7311 line_nr=326 scope.pos=7287 scope.end_pos=7343)
	// var "t" var.pos=7288 var.line_nr=325
	// af parent scope:
	// af parent scope:
	return _t354;
}

string v__token__Token_str(v__token__Token t) {
	string s = v__token__Kind_str(t.kind);
	if (s.len == 0) {
		eprintln(_SLIT("missing token kind string"));
	} else if (!byte_is_letter(string_at(s, 0))) {
		 string _t355 = _STR("token `%.*s\000`", 2, s);
		// autofree_scope_vars(pos=7518 line_nr=335 scope.pos=7487 scope.end_pos=7540)
		// af parent scope:
		// var "t" var.pos=7354 var.line_nr=329
		// var "s" var.pos=7383 var.line_nr=330
		// af parent scope:
		// af parent scope:
		return _t355;
	}
	if (v__token__is_key(t.lit)) {
		s = _SLIT("keyword");
	}
	if ((t.lit).len != 0) {
		s = /*f*/string_add(s, _STR(" `%.*s\000`", 2, t.lit));
	}
	// autofree_scope_vars(pos=7646 line_nr=344 scope.pos=7353 scope.end_pos=7656)
	// var "t" var.pos=7354 var.line_nr=329
	// var "s" var.pos=7383 var.line_nr=330
	// af parent scope:
	// af parent scope:
	return s;
}

Array_v__token__Precedence v__token__build_precedences(void) {
	Array_v__token__Precedence p = __new_array_with_default(((int)(v__token__Kind__end_)), 0, sizeof(v__token__Precedence), 0);
	array_set(&p, v__token__Kind_lsbr, &(v__token__Precedence[]) { v__token__Precedence_index });
	array_set(&p, v__token__Kind_dot, &(v__token__Precedence[]) { v__token__Precedence_call });
	array_set(&p, v__token__Kind_inc, &(v__token__Precedence[]) { v__token__Precedence_postfix });
	array_set(&p, v__token__Kind_dec, &(v__token__Precedence[]) { v__token__Precedence_postfix });
	array_set(&p, v__token__Kind_question, &(v__token__Precedence[]) { v__token__Precedence_postfix });
	array_set(&p, v__token__Kind_mul, &(v__token__Precedence[]) { v__token__Precedence_product });
	array_set(&p, v__token__Kind_div, &(v__token__Precedence[]) { v__token__Precedence_product });
	array_set(&p, v__token__Kind_mod, &(v__token__Precedence[]) { v__token__Precedence_product });
	array_set(&p, v__token__Kind_left_shift, &(v__token__Precedence[]) { v__token__Precedence_product });
	array_set(&p, v__token__Kind_right_shift, &(v__token__Precedence[]) { v__token__Precedence_product });
	array_set(&p, v__token__Kind_amp, &(v__token__Precedence[]) { v__token__Precedence_product });
	array_set(&p, v__token__Kind_arrow, &(v__token__Precedence[]) { v__token__Precedence_product });
	array_set(&p, v__token__Kind_plus, &(v__token__Precedence[]) { v__token__Precedence_sum });
	array_set(&p, v__token__Kind_minus, &(v__token__Precedence[]) { v__token__Precedence_sum });
	array_set(&p, v__token__Kind_pipe, &(v__token__Precedence[]) { v__token__Precedence_sum });
	array_set(&p, v__token__Kind_xor, &(v__token__Precedence[]) { v__token__Precedence_sum });
	array_set(&p, v__token__Kind_eq, &(v__token__Precedence[]) { v__token__Precedence_eq });
	array_set(&p, v__token__Kind_ne, &(v__token__Precedence[]) { v__token__Precedence_eq });
	array_set(&p, v__token__Kind_lt, &(v__token__Precedence[]) { v__token__Precedence_eq });
	array_set(&p, v__token__Kind_le, &(v__token__Precedence[]) { v__token__Precedence_eq });
	array_set(&p, v__token__Kind_gt, &(v__token__Precedence[]) { v__token__Precedence_eq });
	array_set(&p, v__token__Kind_ge, &(v__token__Precedence[]) { v__token__Precedence_eq });
	array_set(&p, v__token__Kind_assign, &(v__token__Precedence[]) { v__token__Precedence_assign });
	array_set(&p, v__token__Kind_plus_assign, &(v__token__Precedence[]) { v__token__Precedence_assign });
	array_set(&p, v__token__Kind_minus_assign, &(v__token__Precedence[]) { v__token__Precedence_assign });
	array_set(&p, v__token__Kind_div_assign, &(v__token__Precedence[]) { v__token__Precedence_assign });
	array_set(&p, v__token__Kind_mod_assign, &(v__token__Precedence[]) { v__token__Precedence_assign });
	array_set(&p, v__token__Kind_or_assign, &(v__token__Precedence[]) { v__token__Precedence_assign });
	array_set(&p, v__token__Kind_and_assign, &(v__token__Precedence[]) { v__token__Precedence_assign });
	array_set(&p, v__token__Kind_left_shift_assign, &(v__token__Precedence[]) { v__token__Precedence_assign });
	array_set(&p, v__token__Kind_right_shift_assign, &(v__token__Precedence[]) { v__token__Precedence_assign });
	array_set(&p, v__token__Kind_mult_assign, &(v__token__Precedence[]) { v__token__Precedence_assign });
	array_set(&p, v__token__Kind_xor_assign, &(v__token__Precedence[]) { v__token__Precedence_assign });
	array_set(&p, v__token__Kind_key_in, &(v__token__Precedence[]) { v__token__Precedence_in_as });
	array_set(&p, v__token__Kind_not_in, &(v__token__Precedence[]) { v__token__Precedence_in_as });
	array_set(&p, v__token__Kind_key_as, &(v__token__Precedence[]) { v__token__Precedence_in_as });
	array_set(&p, v__token__Kind_key_is, &(v__token__Precedence[]) { v__token__Precedence_in_as });
	array_set(&p, v__token__Kind_not_is, &(v__token__Precedence[]) { v__token__Precedence_in_as });
	array_set(&p, v__token__Kind_logical_or, &(v__token__Precedence[]) { v__token__Precedence_cond });
	array_set(&p, v__token__Kind_and, &(v__token__Precedence[]) { v__token__Precedence_cond });
	// autofree_scope_vars(pos=9317 line_nr=418 scope.pos=8048 scope.end_pos=9327)
	// var "p" var.pos=8088 var.line_nr=371
	// af parent scope:
	// af parent scope:
	return p;
}

int v__token__Token_precedence(v__token__Token tok) {
	 int _t356 = ((int)((*(v__token__Precedence*)/*ee elem_typ */array_get(_const_v__token__precedences, tok.kind))));
	// autofree_scope_vars(pos=9490 line_nr=427 scope.pos=9459 scope.end_pos=9531)
	// var "tok" var.pos=9460 var.line_nr=426
	// af parent scope:
	// af parent scope:
	return _t356;
}

bool v__token__Token_is_scalar(v__token__Token tok) {
	 bool _t357 = (tok.kind == v__token__Kind_number || tok.kind == v__token__Kind_string);
	// autofree_scope_vars(pos=9623 line_nr=432 scope.pos=9592 scope.end_pos=9662)
	// var "tok" var.pos=9593 var.line_nr=431
	// af parent scope:
	// af parent scope:
	return _t357;
}

bool v__token__Token_is_unary(v__token__Token tok) {
	 bool _t358 = (tok.kind == v__token__Kind_plus || tok.kind == v__token__Kind_minus || tok.kind == v__token__Kind_not || tok.kind == v__token__Kind_bit_not || tok.kind == v__token__Kind_mul || tok.kind == v__token__Kind_amp || tok.kind == v__token__Kind_arrow);
	// autofree_scope_vars(pos=9814 line_nr=438 scope.pos=9739 scope.end_pos=9886)
	// var "tok" var.pos=9740 var.line_nr=436
	// af parent scope:
	// af parent scope:
	return _t358;
}

bool v__token__Kind_is_relational(v__token__Kind tok) {
	 bool _t359 = (tok == v__token__Kind_lt || tok == v__token__Kind_le || tok == v__token__Kind_gt || tok == v__token__Kind_ge || tok == v__token__Kind_eq || tok == v__token__Kind_ne);
	// autofree_scope_vars(pos=9972 line_nr=443 scope.pos=9896 scope.end_pos=10018)
	// var "tok" var.pos=9897 var.line_nr=441
	// af parent scope:
	// af parent scope:
	return _t359;
}

bool v__token__Kind_is_start_of_type(v__token__Kind k) {
	 bool _t360 = (k == v__token__Kind_name || k == v__token__Kind_lpar || k == v__token__Kind_amp || k == v__token__Kind_lsbr || k == v__token__Kind_question || k == v__token__Kind_key_shared);
	// autofree_scope_vars(pos=10063 line_nr=447 scope.pos=10028 scope.end_pos=10128)
	// var "k" var.pos=10029 var.line_nr=446
	// af parent scope:
	// af parent scope:
	return _t360;
}

bool v__token__Kind_is_prefix(v__token__Kind kind) {
	 bool _t361 = (kind == v__token__Kind_minus || kind == v__token__Kind_amp || kind == v__token__Kind_mul || kind == v__token__Kind_not || kind == v__token__Kind_bit_not);
	// autofree_scope_vars(pos=10169 line_nr=451 scope.pos=10138 scope.end_pos=10222)
	// var "kind" var.pos=10139 var.line_nr=450
	// af parent scope:
	// af parent scope:
	return _t361;
}

bool v__token__Kind_is_infix(v__token__Kind kind) {
	 bool _t362 = (kind == v__token__Kind_plus || kind == v__token__Kind_minus || kind == v__token__Kind_mod || kind == v__token__Kind_mul || kind == v__token__Kind_div || kind == v__token__Kind_eq || kind == v__token__Kind_ne || kind == v__token__Kind_gt || kind == v__token__Kind_lt || kind == v__token__Kind_key_in || kind == v__token__Kind_key_as || kind == v__token__Kind_ge || kind == v__token__Kind_le || kind == v__token__Kind_logical_or || kind == v__token__Kind_xor || kind == v__token__Kind_not_in || kind == v__token__Kind_key_is || kind == v__token__Kind_not_is || kind == v__token__Kind_and || kind == v__token__Kind_dot || kind == v__token__Kind_pipe || kind == v__token__Kind_amp || kind == v__token__Kind_left_shift || kind == v__token__Kind_right_shift || kind == v__token__Kind_arrow);
	// autofree_scope_vars(pos=10262 line_nr=455 scope.pos=10232 scope.end_pos=10470)
	// var "kind" var.pos=10233 var.line_nr=454
	// af parent scope:
	// af parent scope:
	return _t362;
}

bool v__token__Token_can_start_type(v__token__Token* tok, Array_string builtin_type_names) {

	if (tok->kind == (v__token__Kind_name)) {
		 bool _t363 = byte_is_capital(string_at(tok->lit, 0)) || (Array_string_contains(builtin_type_names, tok->lit));
		// autofree_scope_vars(pos=10669 line_nr=464 scope.pos=10662 scope.end_pos=10734)
		// af parent scope:
		// var "tok" var.pos=10579 var.line_nr=462
		// var "builtin_type_names" var.pos=10606 var.line_nr=462
		// af parent scope:
		// af parent scope:
		return _t363;
	}
	else if (tok->kind == (v__token__Kind_amp) || tok->kind == (v__token__Kind_key_fn) || tok->kind == (v__token__Kind_lsbr) || tok->kind == (v__token__Kind_question)) {
		 bool _t364 = true;
		// autofree_scope_vars(pos=10831 line_nr=466 scope.pos=10798 scope.end_pos=10844)
		// af parent scope:
		// var "tok" var.pos=10579 var.line_nr=462
		// var "builtin_type_names" var.pos=10606 var.line_nr=462
		// af parent scope:
		// af parent scope:
		return _t364;
	}
	else {
	};
	 bool _t365 = false;
	// autofree_scope_vars(pos=10859 line_nr=469 scope.pos=10578 scope.end_pos=10873)
	// var "tok" var.pos=10579 var.line_nr=462
	// var "builtin_type_names" var.pos=10606 var.line_nr=462
	// af parent scope:
	// af parent scope:
	return _t365;
}

void v__depgraph__OrderedDepMap_set(v__depgraph__OrderedDepMap* o, string name, Array_string deps) {
	if (!_IN_MAP(ADDR(string, name), ADDR(map, o->data))) {
		array_push(&o->keys, _MOV((string[]){ string_clone(name) }));
	}
	map_set(&o->data, &(string[]){name}, &(Array_string[]) { deps });
}

void v__depgraph__OrderedDepMap_add(v__depgraph__OrderedDepMap* o, string name, Array_string deps) {
	Array_string d = v__depgraph__OrderedDepMap_get(o, name);
	// FOR IN array
	for (int _t367 = 0; _t367 < deps.len; ++_t367) {
		string dep = ((string*)deps.data)[_t367];
		if (!(Array_string_contains(d, dep))) {
			array_push(&d, _MOV((string[]){ string_clone(dep) }));
		} else {
		}
	}
	v__depgraph__OrderedDepMap_set(o, name, d);
}

Array_string v__depgraph__OrderedDepMap_get(v__depgraph__OrderedDepMap* o, string name) {
	Array_string* _t370 = (Array_string*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, o->data), &(string[]){name}));
	Option_Array_string _t369 = {0};
	if (_t370) {
		*((Array_string*)&_t369.data) = *((Array_string*)_t370);
	} else {
		_t369.state = 2; _t369.err = v_error(_SLIT("array index out of range"));
	}
	;
	if (_t369.state != 0) { /*or block*/ 
		IError err = _t369.err;
		*(Array_string*) _t369.data = __new_array_with_default(0, 0, sizeof(string), 0);
	}
	Array_string res = *(Array_string*)_t369.data;
	// autofree_scope_vars(pos=878 line_nr=45 scope.pos=792 scope.end_pos=890)
	// var "o" var.pos=793 var.line_nr=43
	// var "name" var.pos=815 var.line_nr=43
	// var "res" var.pos=840 var.line_nr=44
	// af parent scope:
	// af parent scope:
	return res;
}

void v__depgraph__OrderedDepMap_delete(v__depgraph__OrderedDepMap* o, string name) {
	if (!_IN_MAP(ADDR(string, name), ADDR(map, o->data))) {
		v_panic(_STR("delete: no such key: %.*s", 1, name));
	}
	// FOR IN array
	for (int i = 0; i < o->keys.len; ++i) {
		if (string_eq((*(string*)/*ee elem_typ */array_get(o->keys, i)), name)) {
			array_delete(&o->keys, i);
			break;
		}
	}
	map_delete(&o->data, &(string[]){name});
}

void v__depgraph__OrderedDepMap_apply_diff(v__depgraph__OrderedDepMap* o, string name, Array_string deps) {
	Array_string diff = __new_array_with_default(0, 0, sizeof(string), 0);
	Array_string deps_of_name = v__depgraph__OrderedDepMap_get(o, name);
	// FOR IN array
	for (int _t371 = 0; _t371 < deps_of_name.len; ++_t371) {
		string dep = ((string*)deps_of_name.data)[_t371];
		if (!(Array_string_contains(deps, dep))) {
			array_push(&diff, _MOV((string[]){ string_clone(dep) }));
		}
	}
	v__depgraph__OrderedDepMap_set(o, name, diff);
}

int v__depgraph__OrderedDepMap_size(v__depgraph__OrderedDepMap* o) {
	 int _t373 = o->data.len;
	// autofree_scope_vars(pos=1367 line_nr=73 scope.pos=1335 scope.end_pos=1386)
	// var "o" var.pos=1336 var.line_nr=72
	// af parent scope:
	// af parent scope:
	return _t373;
}

v__depgraph__DepGraph* v__depgraph__new_dep_graph(void) {
	 v__depgraph__DepGraph* _t374 = (v__depgraph__DepGraph*)memdup(&(v__depgraph__DepGraph){.acyclic = true,.nodes = __new_array_with_default(0, 1024, sizeof(v__depgraph__DepGraphNode), 0),}, sizeof(v__depgraph__DepGraph));
	// autofree_scope_vars(pos=1424 line_nr=77 scope.pos=1396 scope.end_pos=1497)
	// af parent scope:
	// af parent scope:
	return _t374;
}

void v__depgraph__DepGraph_add(v__depgraph__DepGraph* graph, string mod, Array_string deps) {
	v__depgraph__DepGraphNode new_node = (v__depgraph__DepGraphNode){.name = mod,.deps = array_clone(&deps),};
	array_push(&graph->nodes, _MOV((v__depgraph__DepGraphNode[]){ new_node }));
}

v__depgraph__DepGraph* v__depgraph__DepGraph_resolve(v__depgraph__DepGraph* graph) {
	v__depgraph__OrderedDepMap node_names = (v__depgraph__OrderedDepMap){.keys = __new_array(0, 1, sizeof(string)),.data = new_map(sizeof(string), sizeof(Array_string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),};
	v__depgraph__OrderedDepMap node_deps = (v__depgraph__OrderedDepMap){.keys = __new_array(0, 1, sizeof(string)),.data = new_map(sizeof(string), sizeof(Array_string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),};
	// FOR IN array
	for (int _t376 = 0; _t376 < graph->nodes.len; ++_t376) {
		v__depgraph__DepGraphNode node = ((v__depgraph__DepGraphNode*)graph->nodes.data)[_t376];
		v__depgraph__OrderedDepMap_add(&node_names, node.name, node.deps);
		v__depgraph__OrderedDepMap_add(&node_deps, node.name, node.deps);
	}
	v__depgraph__DepGraph* resolved = v__depgraph__new_dep_graph();
	for (;;) {
		if (!(v__depgraph__OrderedDepMap_size(&node_deps) != 0)) break;
		Array_string ready_set = __new_array_with_default(0, 0, sizeof(string), 0);
		// FOR IN array
		for (int _t377 = 0; _t377 < node_deps.keys.len; ++_t377) {
			string name = ((string*)node_deps.keys.data)[_t377];
			Array_string deps = v__depgraph__OrderedDepMap_get(&node_deps, name);
			if (deps.len == 0) {
				array_push(&ready_set, _MOV((string[]){ string_clone(name) }));
			}
		}
		if (ready_set.len == 0) {
			v__depgraph__DepGraph* g = v__depgraph__new_dep_graph();
			g->acyclic = false;
			// FOR IN array
			for (int _t379 = 0; _t379 < node_deps.keys.len; ++_t379) {
				string name = ((string*)node_deps.keys.data)[_t379];
				v__depgraph__DepGraph_add(g, name, v__depgraph__OrderedDepMap_get(&node_names, name));
			}
			// autofree_scope_vars(pos=2234 line_nr=113 scope.pos=2106 scope.end_pos=2246)
			// var "g" var.pos=2115 var.line_nr=108
			// af parent scope:
			// var "ready_set" var.pos=1943 var.line_nr=100
			// af parent scope:
			// af parent scope:
			// var "graph" var.pos=1660 var.line_nr=91
			// var "node_names" var.pos=1704 var.line_nr=92
			// var "node_deps" var.pos=1739 var.line_nr=93
			// var "resolved" var.pos=1880 var.line_nr=98
			// af parent scope:
			// af parent scope:
			return g;
		}
		// FOR IN array
		for (int _t380 = 0; _t380 < ready_set.len; ++_t380) {
			string name = ((string*)ready_set.data)[_t380];
			v__depgraph__OrderedDepMap_delete(&node_deps, name);
			Array_string resolved_deps = v__depgraph__OrderedDepMap_get(&node_names, name);
			v__depgraph__DepGraph_add(resolved, name, resolved_deps);
		}
		// FOR IN array
		for (int _t381 = 0; _t381 < node_deps.keys.len; ++_t381) {
			string name = ((string*)node_deps.keys.data)[_t381];
			v__depgraph__OrderedDepMap_apply_diff(&node_deps, name, ready_set);
		}
	}
	// autofree_scope_vars(pos=2461 line_nr=124 scope.pos=1659 scope.end_pos=2478)
	// var "graph" var.pos=1660 var.line_nr=91
	// var "node_names" var.pos=1704 var.line_nr=92
	// var "node_deps" var.pos=1739 var.line_nr=93
	// var "resolved" var.pos=1880 var.line_nr=98
	// af parent scope:
	// af parent scope:
	return resolved;
}

v__depgraph__DepGraphNode v__depgraph__DepGraph_last_node(v__depgraph__DepGraph* graph) {
	 v__depgraph__DepGraphNode _t382 = (*(v__depgraph__DepGraphNode*)/*ee elem_typ */array_get(graph->nodes, graph->nodes.len - 1));
	// autofree_scope_vars(pos=2533 line_nr=128 scope.pos=2488 scope.end_pos=2574)
	// var "graph" var.pos=2489 var.line_nr=127
	// af parent scope:
	// af parent scope:
	return _t382;
}

string v__depgraph__DepGraph_display(v__depgraph__DepGraph* graph) {
	string out = _SLIT("\n");
	// FOR IN array
	for (int _t383 = 0; _t383 < graph->nodes.len; ++_t383) {
		v__depgraph__DepGraphNode node = ((v__depgraph__DepGraphNode*)graph->nodes.data)[_t383];
		// FOR IN array
		for (int _t384 = 0; _t384 < node.deps.len; ++_t384) {
			string dep = ((string*)node.deps.data)[_t384];
			out = /*f*/string_add(out, _STR(" * %.*s\000 -> %.*s\000\n", 3, node.name, dep));
		}
	}
	// autofree_scope_vars(pos=2733 line_nr=138 scope.pos=2584 scope.end_pos=2745)
	// var "graph" var.pos=2585 var.line_nr=131
	// var "out" var.pos=2626 var.line_nr=132
	// str literal
	// af parent scope:
	// af parent scope:
	return out;
}

string v__depgraph__DepGraph_display_cycles(v__depgraph__DepGraph* graph) {
	Map_string_v__depgraph__DepGraphNode node_names = new_map(sizeof(string), sizeof(v__depgraph__DepGraphNode), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
	// FOR IN array
	for (int _t385 = 0; _t385 < graph->nodes.len; ++_t385) {
		v__depgraph__DepGraphNode node = ((v__depgraph__DepGraphNode*)graph->nodes.data)[_t385];
		(*(v__depgraph__DepGraphNode*)map_get_and_set(&node_names, &(string[]){node.name}, &(v__depgraph__DepGraphNode[]){ (v__depgraph__DepGraphNode){.deps = __new_array(0, 1, sizeof(string)),} })) = node;
	}
	string out = _SLIT("\n");
	// FOR IN array
	for (int _t386 = 0; _t386 < graph->nodes.len; ++_t386) {
		v__depgraph__DepGraphNode node = ((v__depgraph__DepGraphNode*)graph->nodes.data)[_t386];
		// FOR IN array
		for (int _t387 = 0; _t387 < node.deps.len; ++_t387) {
			string dep = ((string*)node.deps.data)[_t387];
			if (!_IN_MAP(ADDR(string, dep), ADDR(map, node_names))) {
				continue;
			}
			v__depgraph__DepGraphNode dn = (*(v__depgraph__DepGraphNode*)map_get(ADDR(map, node_names), &(string[]){dep}, &(v__depgraph__DepGraphNode[]){ (v__depgraph__DepGraphNode){.deps = __new_array(0, 1, sizeof(string)),} }));
			if ((Array_string_contains(dn.deps, node.name))) {
				out = /*f*/string_add(out, _STR(" * %.*s\000 -> %.*s\000\n", 3, node.name, dep));
			}
		}
	}
	// autofree_scope_vars(pos=3122 line_nr=158 scope.pos=2755 scope.end_pos=3134)
	// var "graph" var.pos=2756 var.line_nr=141
	// var "node_names" var.pos=2804 var.line_nr=142
	// var "out" var.pos=2910 var.line_nr=146
	// str literal
	// af parent scope:
	// af parent scope:
	return out;
}

// Attr: [unsafe]
VV_LOCAL_SYMBOL void flag__Flag_free(flag__Flag* f) {
	{ // Unsafe block
		string_free(&f->name);
		string_free(&f->usage);
		string_free(&f->val_desc);
	}
}

string flag__Flag_str(flag__Flag f) {
	 string _t388 = string_add(string_add(string_add(string_add(string_add(_SLIT(""), _SLIT("    flag:\n")), _STR("            name: %.*s\000\n", 2, f.name)), _STR("            abbr: %"PRIu8"\000\n", 2, f.abbr)), _STR("            usag: %.*s\000\n", 2, f.usage)), _STR("            desc: %.*s", 1, f.val_desc));
	// autofree_scope_vars(pos=691 line_nr=42 scope.pos=667 scope.end_pos=851)
	// var "f" var.pos=668 var.line_nr=41
	// af parent scope:
	// af parent scope:
	return _t388;
}

string Array_flag__Flag_str(Array_flag__Flag af) {
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	array_push(&res, _MOV((string[]){ string_clone(_SLIT("\n  []Flag = [")) }));
	// FOR IN array
	for (int _t390 = 0; _t390 < af.len; ++_t390) {
		flag__Flag f = ((flag__Flag*)af.data)[_t390];
		array_push(&res, _MOV((string[]){ string_clone(flag__Flag_str(f)) }));
	}
	array_push(&res, _MOV((string[]){ string_clone(_SLIT("  ]")) }));
	 string _t393 = Array_string_join(res, _SLIT("\n"));
	// autofree_scope_vars(pos=985 line_nr=53 scope.pos=861 scope.end_pos=1008)
	// var "af" var.pos=862 var.line_nr=46
	// var "res" var.pos=893 var.line_nr=47
	// af parent scope:
	// af parent scope:
	return _t393;
}

// Attr: [unsafe]
VV_LOCAL_SYMBOL void flag__FlagParser_free(flag__FlagParser* f) {
	{ // Unsafe block
		// FOR IN array
		for (int _t394 = 0; _t394 < f->args.len; ++_t394) {
			string a = ((string*)f->args.data)[_t394];
			string_free(&a);
		}
		array_free(&f->args);
		// FOR IN array
		for (int _t395 = 0; _t395 < f->flags.len; ++_t395) {
			flag__Flag flag = ((flag__Flag*)f->flags.data)[_t395];
			flag__Flag_free(&flag);
		}
		array_free(&f->flags);
		string_free(&f->application_name);
		string_free(&f->application_version);
		string_free(&f->application_description);
		string_free(&f->args_description);
	}
}

flag__FlagParser* flag__new_flag_parser(Array_string args) {
	 flag__FlagParser* _t396 = (flag__FlagParser*)memdup(&(flag__FlagParser){.args = array_clone(&args),.max_free_args = _const_flag__max_args_number,.flags = __new_array(0, 1, sizeof(flag__Flag)),.application_name = (string){.str=(byteptr)"", .is_lit=1},.application_version = (string){.str=(byteptr)"", .is_lit=1},.application_description = (string){.str=(byteptr)"", .is_lit=1},.min_free_args = 0,.args_description = (string){.str=(byteptr)"", .is_lit=1},}, sizeof(flag__FlagParser));
	// autofree_scope_vars(pos=1988 line_nr=99 scope.pos=1943 scope.end_pos=2071)
	// var "args" var.pos=1959 var.line_nr=98
	// af parent scope:
	// af parent scope:
	return _t396;
}

void flag__FlagParser_application(flag__FlagParser* fs, string name) {
	fs->application_name = name;
}

void flag__FlagParser_version(flag__FlagParser* fs, string vers) {
	fs->application_version = vers;
}

void flag__FlagParser_description(flag__FlagParser* fs, string desc) {
	fs->application_description = desc;
}

void flag__FlagParser_skip_executable(flag__FlagParser* fs) {
	array_delete(&fs->args, 0);
}

VV_LOCAL_SYMBOL void flag__FlagParser_add_flag(flag__FlagParser* fs, string name, byte abbr, string usage, string desc) {
	array_push(&fs->flags, _MOV((flag__Flag[]){ (flag__Flag){.name = name,.abbr = abbr,.usage = usage,.val_desc = desc,} }));
}

// Attr: [manualfree]
VV_LOCAL_SYMBOL Array_string flag__FlagParser_parse_value(flag__FlagParser* fs, string longhand, byte shorthand) {
bool flag__FlagParser_parse_value_defer_0 = false;
bool flag__FlagParser_parse_value_defer_1 = false;
	string full = _STR("--%.*s", 1, longhand);
	flag__FlagParser_parse_value_defer_0 = true;
	Array_string found_entries = __new_array_with_default(0, 0, sizeof(string), 0);
	Array_int to_delete = __new_array_with_default(0, 0, sizeof(int), 0);
	flag__FlagParser_parse_value_defer_1 = true;
	bool should_skip_one = false;
	// FOR IN array
	for (int i = 0; i < fs->args.len; ++i) {
		string arg = ((string*)fs->args.data)[i];
		if (should_skip_one) {
			should_skip_one = false;
			continue;
		}
		if (string_eq(arg, _SLIT("--"))) {
			break;
		}
		if (string_at(arg, 0) != L'-') {
			continue;
		}
		if ((arg.len == 2 && string_at(arg, 0) == L'-' && string_at(arg, 1) == shorthand) || string_eq(arg, full)) {
			if (i + 1 >= fs->args.len) {
				// Defer begin
				if (flag__FlagParser_parse_value_defer_1 == true) {
					array_free(&to_delete);
				}
				// Defer end
				// Defer begin
				if (flag__FlagParser_parse_value_defer_0 == true) {
					string_free(&full);
				}
				// Defer end
				 Array_string _t398 = __new_array_with_default(0, 0, sizeof(string), 0);
				// autofree_scope_vars(pos=3750 line_nr=170 scope.pos=3745 scope.end_pos=3764)
				// af parent scope:
				// var "nextarg" var.pos=3769 var.line_nr=172
				// af parent scope:
				// var "i" var.pos=3449 var.line_nr=156
				// skipping tmp var "i"
				// var "arg" var.pos=3452 var.line_nr=156
				// skipping tmp var "arg"
				// af parent scope:
				// var "fs" var.pos=3182 var.line_nr=145
				// var "longhand" var.pos=3209 var.line_nr=145
				// var "shorthand" var.pos=3226 var.line_nr=145
				// var "full" var.pos=3254 var.line_nr=146
				// var "found_entries" var.pos=3318 var.line_nr=150
				// var "to_delete" var.pos=3351 var.line_nr=151
				// var "should_skip_one" var.pos=3419 var.line_nr=155
				// af parent scope:
				// af parent scope:
				return _t398;
			}
			string nextarg = (*(string*)/*ee elem_typ */array_get(fs->args, i + 1));
			if (nextarg.len > 2) {
				string nextarg_rest = string_substr(nextarg, 0, 2);
				if (string_eq(nextarg_rest, _SLIT("--"))) {
					string_free(&nextarg_rest);
					// Defer begin
					if (flag__FlagParser_parse_value_defer_1 == true) {
						array_free(&to_delete);
					}
					// Defer end
					// Defer begin
					if (flag__FlagParser_parse_value_defer_0 == true) {
						string_free(&full);
					}
					// Defer end
					 Array_string _t399 = __new_array_with_default(0, 0, sizeof(string), 0);
					// autofree_scope_vars(pos=4022 line_nr=179 scope.pos=3880 scope.end_pos=4037)
					// af parent scope:
					// var "nextarg_rest" var.pos=3823 var.line_nr=174
					// af parent scope:
					// var "nextarg" var.pos=3769 var.line_nr=172
					// af parent scope:
					// var "i" var.pos=3449 var.line_nr=156
					// skipping tmp var "i"
					// var "arg" var.pos=3452 var.line_nr=156
					// skipping tmp var "arg"
					// af parent scope:
					// var "fs" var.pos=3182 var.line_nr=145
					// var "longhand" var.pos=3209 var.line_nr=145
					// var "shorthand" var.pos=3226 var.line_nr=145
					// var "full" var.pos=3254 var.line_nr=146
					// var "found_entries" var.pos=3318 var.line_nr=150
					// var "to_delete" var.pos=3351 var.line_nr=151
					// var "should_skip_one" var.pos=3419 var.line_nr=155
					// af parent scope:
					// af parent scope:
					return _t399;
				}
				string_free(&nextarg_rest);
			}
			array_push(&found_entries, _MOV((string[]){ string_clone((*(string*)/*ee elem_typ */array_get(fs->args, i + 1))) }));
			array_push(&to_delete, _MOV((int[]){ i }));
			array_push(&to_delete, _MOV((int[]){ i + 1 }));
			should_skip_one = true;
			continue;
		}
		if (arg.len > full.len + 1 && string_eq(string_substr(arg, 0, full.len + 1), _STR("%.*s\000=", 2, full))) {
			array_push(&found_entries, _MOV((string[]){ string_clone(string_substr(arg, full.len + 1, arg.len)) }));
			array_push(&to_delete, _MOV((int[]){ i }));
			continue;
		}
	}
	// FOR IN array
	for (int i = 0; i < to_delete.len; ++i) {
		int del = ((int*)to_delete.data)[i];
		array_delete(&fs->args, del - i);
	}
	// Defer begin
	if (flag__FlagParser_parse_value_defer_1 == true) {
		array_free(&to_delete);
	}
	// Defer end
	// Defer begin
	if (flag__FlagParser_parse_value_defer_0 == true) {
		string_free(&full);
	}
	// Defer end
	// autofree_scope_vars(pos=4450 line_nr=199 scope.pos=3177 scope.end_pos=4472)
	// var "fs" var.pos=3182 var.line_nr=145
	// var "longhand" var.pos=3209 var.line_nr=145
	// var "shorthand" var.pos=3226 var.line_nr=145
	// var "full" var.pos=3254 var.line_nr=146
	// var "found_entries" var.pos=3318 var.line_nr=150
	// var "to_delete" var.pos=3351 var.line_nr=151
	// var "should_skip_one" var.pos=3419 var.line_nr=155
	// af parent scope:
	// af parent scope:
	return found_entries;
}

VV_LOCAL_SYMBOL Option_string flag__FlagParser_parse_bool_value(flag__FlagParser* fs, string longhand, byte shorthand) {
	{
		string full = _STR("--%.*s", 1, longhand);
		// FOR IN array
		for (int i = 0; i < fs->args.len; ++i) {
			string arg = ((string*)fs->args.data)[i];
			if (string_eq(arg, _SLIT("--"))) {
				break;
			}
			if (arg.len == 0) {
				continue;
			}
			if (string_at(arg, 0) != L'-') {
				continue;
			}
			if ((arg.len == 2 && string_at(arg, 0) == L'-' && string_at(arg, 1) == shorthand) || string_eq(arg, full)) {
				if (fs->args.len > i + 1 && ((string_eq((*(string*)/*ee elem_typ */array_get(fs->args, i + 1)), _SLIT("true")) || string_eq((*(string*)/*ee elem_typ */array_get(fs->args, i + 1)), _SLIT("false"))))) {
					string val = (*(string*)/*ee elem_typ */array_get(fs->args, i + 1));
					array_delete(&fs->args, i + 1);
					array_delete(&fs->args, i);
					Option_string _t405;
					opt_ok(&(string[]) { val }, (Option*)(&_t405), sizeof(string));
					// autofree_scope_vars(pos=5185 line_nr=227 scope.pos=5102 scope.end_pos=5201)
					// var "val" var.pos=5109 var.line_nr=224
					// af parent scope:
					// af parent scope:
					// var "i" var.pos=4789 var.line_nr=211
					// skipping tmp var "i"
					// var "arg" var.pos=4792 var.line_nr=211
					// skipping tmp var "arg"
					// af parent scope:
					// var "full" var.pos=4761 var.line_nr=210
					// af parent scope:
					// var "fs" var.pos=4681 var.line_nr=208
					// var "longhand" var.pos=4713 var.line_nr=208
					// var "shorthand" var.pos=4730 var.line_nr=208
					// af parent scope:
					// af parent scope:
					return _t405;
				} else {
					array_delete(&fs->args, i);
					Option_string _t406;
					opt_ok(&(string[]) { _SLIT("true") }, (Option*)(&_t406), sizeof(string));
					// autofree_scope_vars(pos=5237 line_nr=230 scope.pos=5208 scope.end_pos=5256)
					// af parent scope:
					// af parent scope:
					// var "i" var.pos=4789 var.line_nr=211
					// skipping tmp var "i"
					// var "arg" var.pos=4792 var.line_nr=211
					// skipping tmp var "arg"
					// af parent scope:
					// var "full" var.pos=4761 var.line_nr=210
					// af parent scope:
					// var "fs" var.pos=4681 var.line_nr=208
					// var "longhand" var.pos=4713 var.line_nr=208
					// var "shorthand" var.pos=4730 var.line_nr=208
					// af parent scope:
					// af parent scope:
					return _t406;
				}
			}
			if (arg.len > full.len + 1 && string_eq(string_substr(arg, 0, full.len + 1), _STR("%.*s\000=", 2, full))) {
				string val = string_substr(arg, full.len + 1, arg.len);
				array_delete(&fs->args, i);
				Option_string _t407;
				opt_ok(&(string[]) { val }, (Option*)(&_t407), sizeof(string));
				// autofree_scope_vars(pos=5406 line_nr=237 scope.pos=5327 scope.end_pos=5421)
				// var "val" var.pos=5354 var.line_nr=235
				// af parent scope:
				// var "i" var.pos=4789 var.line_nr=211
				// skipping tmp var "i"
				// var "arg" var.pos=4792 var.line_nr=211
				// skipping tmp var "arg"
				// af parent scope:
				// var "full" var.pos=4761 var.line_nr=210
				// af parent scope:
				// var "fs" var.pos=4681 var.line_nr=208
				// var "longhand" var.pos=4713 var.line_nr=208
				// var "shorthand" var.pos=4730 var.line_nr=208
				// af parent scope:
				// af parent scope:
				return _t407;
			}
			if (arg.len > 1 && string_at(arg, 0) == L'-' && string_at(arg, 1) != L'-' && string_index_byte(arg, shorthand) != -1) {
				Option_string _t408;
				opt_ok(&(string[]) { _SLIT("true") }, (Option*)(&_t408), sizeof(string));
				// autofree_scope_vars(pos=5553 line_nr=241 scope.pos=5510 scope.end_pos=5571)
				// af parent scope:
				// var "i" var.pos=4789 var.line_nr=211
				// skipping tmp var "i"
				// var "arg" var.pos=4792 var.line_nr=211
				// skipping tmp var "arg"
				// af parent scope:
				// var "full" var.pos=4761 var.line_nr=210
				// af parent scope:
				// var "fs" var.pos=4681 var.line_nr=208
				// var "longhand" var.pos=4713 var.line_nr=208
				// var "shorthand" var.pos=4730 var.line_nr=208
				// af parent scope:
				// af parent scope:
				return _t408;
			}
		}
	}
	return (Option_string){ .state=2, .err=v_error(_STR("parameter '%.*s\000' not found", 2, longhand)) };
}

Option_bool flag__FlagParser_bool_opt(flag__FlagParser* fs, string name, byte abbr, string usage) {
	bool res = false;
	{
		flag__FlagParser_add_flag(fs, name, abbr, usage, _SLIT("<bool>"));
		Option_string _t409 = flag__FlagParser_parse_bool_value(fs, name, abbr);
		if (_t409.state != 0) { /*or block*/ 
			IError err = _t409.err;
			return (Option_bool){ .state=2, .err=v_error(_STR("parameter '%.*s\000' not provided", 2, name)) };
		}
 		string parsed =  *(string*)_t409.data;
		res = string_eq(parsed, _SLIT("true"));
	}
	Option_bool _t410;
	opt_ok(&(bool[]) { res }, (Option*)(&_t410), sizeof(bool));
	// autofree_scope_vars(pos=6059 line_nr=259 scope.pos=5789 scope.end_pos=6071)
	// var "fs" var.pos=5794 var.line_nr=250
	// var "name" var.pos=5818 var.line_nr=250
	// var "abbr" var.pos=5831 var.line_nr=250
	// var "usage" var.pos=5842 var.line_nr=250
	// var "res" var.pos=5869 var.line_nr=251
	// af parent scope:
	// af parent scope:
	return _t410;
}

bool flag__FlagParser_bool(flag__FlagParser* fs, string name, byte abbr, bool bdefault, string usage) {
	Option_bool _t411 = flag__FlagParser_bool_opt(fs, name, abbr, usage);
	if (_t411.state != 0) { /*or block*/ 
		IError err = _t411.err;
		// autofree_scope_vars(pos=6422 line_nr=270 scope.pos=6421 scope.end_pos=6439)
		// var "err" var.pos=6421 var.line_nr=270
		// af parent scope:
		// var "fs" var.pos=6297 var.line_nr=269
		// var "name" var.pos=6317 var.line_nr=269
		// var "abbr" var.pos=6330 var.line_nr=269
		// var "bdefault" var.pos=6341 var.line_nr=269
		// var "usage" var.pos=6356 var.line_nr=269
		// var "value" var.pos=6378 var.line_nr=270
		// af parent scope:
		// af parent scope:
		return bdefault;
	}
 	bool value =  *(bool*)_t411.data;
	// autofree_scope_vars(pos=6441 line_nr=271 scope.pos=6292 scope.end_pos=6455)
	// var "fs" var.pos=6297 var.line_nr=269
	// var "name" var.pos=6317 var.line_nr=269
	// var "abbr" var.pos=6330 var.line_nr=269
	// var "bdefault" var.pos=6341 var.line_nr=269
	// var "usage" var.pos=6356 var.line_nr=269
	// var "value" var.pos=6378 var.line_nr=270
	// af parent scope:
	// af parent scope:
	return value;
}

Array_int flag__FlagParser_int_multi(flag__FlagParser* fs, string name, byte abbr, string usage) {
	flag__FlagParser_add_flag(fs, name, abbr, usage, _SLIT("<multiple ints>"));
	Array_string parsed = flag__FlagParser_parse_value(fs, name, abbr);
	Array_int value = __new_array_with_default(0, 0, sizeof(int), 0);
	// FOR IN array
	for (int _t412 = 0; _t412 < parsed.len; ++_t412) {
		string val = ((string*)parsed.data)[_t412];
		array_push(&value, _MOV((int[]){ string_int(val) }));
	}
	// autofree_scope_vars(pos=6841 line_nr=283 scope.pos=6609 scope.end_pos=6855)
	// var "fs" var.pos=6614 var.line_nr=276
	// var "name" var.pos=6639 var.line_nr=276
	// var "abbr" var.pos=6652 var.line_nr=276
	// var "usage" var.pos=6663 var.line_nr=276
	// var "parsed" var.pos=6737 var.line_nr=278
	// var "value" var.pos=6779 var.line_nr=279
	// af parent scope:
	// af parent scope:
	return value;
}

Option_int flag__FlagParser_int_opt(flag__FlagParser* fs, string name, byte abbr, string usage) {
	int res = 0;
	{
		flag__FlagParser_add_flag(fs, name, abbr, usage, _SLIT("<int>"));
		Array_string parsed = flag__FlagParser_parse_value(fs, name, abbr);
		if (parsed.len == 0) {
			return (Option_int){ .state=2, .err=v_error(_STR("parameter '%.*s\000' not provided", 2, name)) };
		}
		string parsed0 = (*(string*)/*ee elem_typ */array_get(parsed, 0));
		res = string_int(parsed0);
	}
	Option_int _t414;
	opt_ok(&(int[]) { res }, (Option*)(&_t414), sizeof(int));
	// autofree_scope_vars(pos=7310 line_nr=299 scope.pos=7014 scope.end_pos=7322)
	// var "fs" var.pos=7019 var.line_nr=288
	// var "name" var.pos=7042 var.line_nr=288
	// var "abbr" var.pos=7055 var.line_nr=288
	// var "usage" var.pos=7066 var.line_nr=288
	// var "res" var.pos=7092 var.line_nr=289
	// af parent scope:
	// af parent scope:
	return _t414;
}

int flag__FlagParser_int(flag__FlagParser* fs, string name, byte abbr, int idefault, string usage) {
	Option_int _t415 = flag__FlagParser_int_opt(fs, name, abbr, usage);
	if (_t415.state != 0) { /*or block*/ 
		IError err = _t415.err;
		// autofree_scope_vars(pos=7661 line_nr=310 scope.pos=7660 scope.end_pos=7678)
		// var "err" var.pos=7660 var.line_nr=310
		// af parent scope:
		// var "fs" var.pos=7540 var.line_nr=309
		// var "name" var.pos=7559 var.line_nr=309
		// var "abbr" var.pos=7572 var.line_nr=309
		// var "idefault" var.pos=7583 var.line_nr=309
		// var "usage" var.pos=7597 var.line_nr=309
		// var "value" var.pos=7618 var.line_nr=310
		// af parent scope:
		// af parent scope:
		return idefault;
	}
 	int value =  *(int*)_t415.data;
	// autofree_scope_vars(pos=7680 line_nr=311 scope.pos=7535 scope.end_pos=7694)
	// var "fs" var.pos=7540 var.line_nr=309
	// var "name" var.pos=7559 var.line_nr=309
	// var "abbr" var.pos=7572 var.line_nr=309
	// var "idefault" var.pos=7583 var.line_nr=309
	// var "usage" var.pos=7597 var.line_nr=309
	// var "value" var.pos=7618 var.line_nr=310
	// af parent scope:
	// af parent scope:
	return value;
}

Array_f64 flag__FlagParser_float_multi(flag__FlagParser* fs, string name, byte abbr, string usage) {
	flag__FlagParser_add_flag(fs, name, abbr, usage, _SLIT("<multiple floats>"));
	Array_string parsed = flag__FlagParser_parse_value(fs, name, abbr);
	Array_f64 value = __new_array_with_default(0, 0, sizeof(f64), 0);
	// FOR IN array
	for (int _t416 = 0; _t416 < parsed.len; ++_t416) {
		string val = ((string*)parsed.data)[_t416];
		array_push(&value, _MOV((f64[]){ string_f64(val) }));
	}
	// autofree_scope_vars(pos=8086 line_nr=323 scope.pos=7850 scope.end_pos=8100)
	// var "fs" var.pos=7855 var.line_nr=316
	// var "name" var.pos=7882 var.line_nr=316
	// var "abbr" var.pos=7895 var.line_nr=316
	// var "usage" var.pos=7906 var.line_nr=316
	// var "parsed" var.pos=7982 var.line_nr=318
	// var "value" var.pos=8024 var.line_nr=319
	// af parent scope:
	// af parent scope:
	return value;
}

Option_f64 flag__FlagParser_float_opt(flag__FlagParser* fs, string name, byte abbr, string usage) {
	f64 res = 0.0;
	{
		flag__FlagParser_add_flag(fs, name, abbr, usage, _SLIT("<float>"));
		Array_string parsed = flag__FlagParser_parse_value(fs, name, abbr);
		if (parsed.len == 0) {
			return (Option_f64){ .state=2, .err=v_error(_STR("parameter '%.*s\000' not provided", 2, name)) };
		}
		res = string_f64((*(string*)/*ee elem_typ */array_get(parsed, 0)));
	}
	Option_f64 _t418;
	opt_ok(&(f64[]) { res }, (Option*)(&_t418), sizeof(f64));
	// autofree_scope_vars(pos=8542 line_nr=338 scope.pos=8261 scope.end_pos=8554)
	// var "fs" var.pos=8266 var.line_nr=328
	// var "name" var.pos=8291 var.line_nr=328
	// var "abbr" var.pos=8304 var.line_nr=328
	// var "usage" var.pos=8315 var.line_nr=328
	// var "res" var.pos=8341 var.line_nr=329
	// af parent scope:
	// af parent scope:
	return _t418;
}

f64 flag__FlagParser_float(flag__FlagParser* fs, string name, byte abbr, f64 fdefault, string usage) {
	Option_f64 _t419 = flag__FlagParser_float_opt(fs, name, abbr, usage);
	if (_t419.state != 0) { /*or block*/ 
		IError err = _t419.err;
		// autofree_scope_vars(pos=8902 line_nr=349 scope.pos=8901 scope.end_pos=8919)
		// var "err" var.pos=8901 var.line_nr=349
		// af parent scope:
		// var "fs" var.pos=8777 var.line_nr=348
		// var "name" var.pos=8798 var.line_nr=348
		// var "abbr" var.pos=8811 var.line_nr=348
		// var "fdefault" var.pos=8822 var.line_nr=348
		// var "usage" var.pos=8836 var.line_nr=348
		// var "value" var.pos=8857 var.line_nr=349
		// af parent scope:
		// af parent scope:
		return fdefault;
	}
 	f64 value =  *(f64*)_t419.data;
	// autofree_scope_vars(pos=8921 line_nr=350 scope.pos=8772 scope.end_pos=8935)
	// var "fs" var.pos=8777 var.line_nr=348
	// var "name" var.pos=8798 var.line_nr=348
	// var "abbr" var.pos=8811 var.line_nr=348
	// var "fdefault" var.pos=8822 var.line_nr=348
	// var "usage" var.pos=8836 var.line_nr=348
	// var "value" var.pos=8857 var.line_nr=349
	// af parent scope:
	// af parent scope:
	return value;
}

Array_string flag__FlagParser_string_multi(flag__FlagParser* fs, string name, byte abbr, string usage) {
	flag__FlagParser_add_flag(fs, name, abbr, usage, _SLIT("<multiple strings>"));
	 Array_string _t420 = flag__FlagParser_parse_value(fs, name, abbr);
	// autofree_scope_vars(pos=9228 line_nr=357 scope.pos=9092 scope.end_pos=9263)
	// var "fs" var.pos=9097 var.line_nr=355
	// var "name" var.pos=9125 var.line_nr=355
	// var "abbr" var.pos=9138 var.line_nr=355
	// var "usage" var.pos=9149 var.line_nr=355
	// af parent scope:
	// af parent scope:
	return _t420;
}

Option_string flag__FlagParser_string_opt(flag__FlagParser* fs, string name, byte abbr, string usage) {
	string res = _SLIT("");
	{
		flag__FlagParser_add_flag(fs, name, abbr, usage, _SLIT("<string>"));
		Array_string parsed = flag__FlagParser_parse_value(fs, name, abbr);
		if (parsed.len == 0) {
			return (Option_string){ .state=2, .err=v_error(_STR("parameter '%.*s\000' not provided", 2, name)) };
		}
		res = (*(string*)/*ee elem_typ */array_get(parsed, 0));
	}
	Option_string _t421;
	opt_ok(&(string[]) { res }, (Option*)(&_t421), sizeof(string));
	// autofree_scope_vars(pos=9704 line_nr=372 scope.pos=9425 scope.end_pos=9716)
	// var "fs" var.pos=9430 var.line_nr=362
	// var "name" var.pos=9456 var.line_nr=362
	// var "abbr" var.pos=9469 var.line_nr=362
	// var "usage" var.pos=9480 var.line_nr=362
	// var "res" var.pos=9509 var.line_nr=363
	// str literal
	// af parent scope:
	// af parent scope:
	return _t421;
}

string flag__FlagParser_string(flag__FlagParser* fs, string name, byte abbr, string sdefault, string usage) {
	Option_string _t422 = flag__FlagParser_string_opt(fs, name, abbr, usage);
	if (_t422.state != 0) { /*or block*/ 
		IError err = _t422.err;
		// autofree_scope_vars(pos=10012 line_nr=382 scope.pos=10011 scope.end_pos=10029)
		// var "err" var.pos=10011 var.line_nr=382
		// af parent scope:
		// var "fs" var.pos=9879 var.line_nr=381
		// var "name" var.pos=9901 var.line_nr=381
		// var "abbr" var.pos=9914 var.line_nr=381
		// var "sdefault" var.pos=9925 var.line_nr=381
		// var "usage" var.pos=9942 var.line_nr=381
		// var "value" var.pos=9966 var.line_nr=382
		// af parent scope:
		// af parent scope:
		return sdefault;
	}
 	string value =  *(string*)_t422.data;
	// autofree_scope_vars(pos=10031 line_nr=383 scope.pos=9874 scope.end_pos=10045)
	// var "fs" var.pos=9879 var.line_nr=381
	// var "name" var.pos=9901 var.line_nr=381
	// var "abbr" var.pos=9914 var.line_nr=381
	// var "sdefault" var.pos=9925 var.line_nr=381
	// var "usage" var.pos=9942 var.line_nr=381
	// var "value" var.pos=9966 var.line_nr=382
	// af parent scope:
	// af parent scope:
	return value;
}

void flag__FlagParser_limit_free_args_to_at_least(flag__FlagParser* fs, int n) {
	if (n > _const_flag__max_args_number) {
		v_panic(_STR("flag.limit_free_args_to_at_least expect n to be smaller than %"PRId32"", 1, _const_flag__max_args_number));
	}
	if (n <= 0) {
		v_panic(_SLIT("flag.limit_free_args_to_at_least expect n to be a positive number"));
	}
	fs->min_free_args = n;
}

void flag__FlagParser_limit_free_args_to_exactly(flag__FlagParser* fs, int n) {
	if (n > _const_flag__max_args_number) {
		v_panic(_STR("flag.limit_free_args_to_exactly expect n to be smaller than %"PRId32"", 1, _const_flag__max_args_number));
	}
	if (n < 0) {
		v_panic(_SLIT("flag.limit_free_args_to_exactly expect n to be a non negative number"));
	}
	fs->min_free_args = n;
	fs->max_free_args = n;
}

void flag__FlagParser_limit_free_args(flag__FlagParser* fs, int min, int max) {
	if (min > max) {
		v_panic(_STR("flag.limit_free_args expect min < max, got %"PRId32"\000 >= %"PRId32"", 2, min, max));
	}
	fs->min_free_args = min;
	fs->max_free_args = max;
}

void flag__FlagParser_arguments_description(flag__FlagParser* fs, string description) {
	fs->args_description = description;
}

string flag__FlagParser_usage(flag__FlagParser fs) {
	bool positive_min_arg = (fs.min_free_args > 0);
	bool positive_max_arg = (fs.max_free_args > 0 && fs.max_free_args != _const_flag__max_args_number);
	bool no_arguments = (fs.min_free_args == 0 && fs.max_free_args == 0);
	string adesc = (fs.args_description.len > 0 ? (fs.args_description) : (_SLIT("[ARGS]")));
	if (no_arguments) {
		adesc = _SLIT("");
	}
	Array_string use = __new_array_with_default(0, 0, sizeof(string), 0);
	if ((fs.application_version).len != 0) {
		array_push(&use, _MOV((string[]){ string_clone(_STR("%.*s\000 %.*s", 2, fs.application_name, fs.application_version)) }));
		array_push(&use, _MOV((string[]){ string_clone(_STR("%.*s", 1, _const_flag__underline)) }));
	}
	array_push(&use, _MOV((string[]){ string_clone(_STR("Usage: %.*s\000 [options] %.*s", 2, fs.application_name, adesc)) }));
	array_push(&use, _MOV((string[]){ string_clone(_SLIT("")) }));
	if ((fs.application_description).len != 0) {
		array_push(&use, _MOV((string[]){ string_clone(_STR("Description: %.*s", 1, fs.application_description)) }));
		array_push(&use, _MOV((string[]){ string_clone(_SLIT("")) }));
		array_push(&use, _MOV((string[]){ string_clone(_SLIT("")) }));
	}
	if (positive_min_arg || positive_max_arg || no_arguments) {
		if (no_arguments) {
			array_push(&use, _MOV((string[]){ string_clone(_SLIT("This application does not expect any arguments")) }));
			array_push(&use, _MOV((string[]){ string_clone(_SLIT("")) }));
		} else {
			Array_string s = __new_array_with_default(0, 0, sizeof(string), 0);
			if (positive_min_arg) {
				array_push(&s, _MOV((string[]){ string_clone(_STR("at least %"PRId32"", 1, fs.min_free_args)) }));
			}
			if (positive_max_arg) {
				array_push(&s, _MOV((string[]){ string_clone(_STR("at most %"PRId32"", 1, fs.max_free_args)) }));
			}
			if (positive_min_arg && positive_max_arg && fs.min_free_args == fs.max_free_args) {
				s = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_STR("exactly %"PRId32"", 1, fs.min_free_args)}));
			}
			string sargs = Array_string_join(s, _SLIT(" and "));
			array_push(&use, _MOV((string[]){ string_clone(_STR("The arguments should be %.*s\000 in number.", 2, sargs)) }));
			array_push(&use, _MOV((string[]){ string_clone(_SLIT("")) }));
		}
	}
	if (fs.flags.len > 0) {
		array_push(&use, _MOV((string[]){ string_clone(_SLIT("Options:")) }));
		// FOR IN array
		for (int _t437 = 0; _t437 < fs.flags.len; ++_t437) {
			flag__Flag f = ((flag__Flag*)fs.flags.data)[_t437];
			Array_string onames = __new_array_with_default(0, 0, sizeof(string), 0);
			if (f.abbr != 0) {
				array_push(&onames, _MOV((string[]){ string_clone(_STR("-%.*s", 1, byte_ascii_str(f.abbr))) }));
			}
			if ((f.name).len != 0) {
				if (!string_contains(f.val_desc, _SLIT("<bool>"))) {
					array_push(&onames, _MOV((string[]){ string_clone(_STR("--%.*s\000 %.*s", 2, f.name, f.val_desc)) }));
				} else {
					array_push(&onames, _MOV((string[]){ string_clone(_STR("--%.*s", 1, f.name)) }));
				}
			}
			string option_names = string_add(_SLIT("  "), Array_string_join(onames, _SLIT(", ")));
			string xspace = _SLIT("");
			if (option_names.len > _const_flag__space.len - 2) {
				xspace = _STR("\n%.*s", 1, _const_flag__space);
			} else {
				xspace = string_substr(_const_flag__space, option_names.len, _const_flag__space.len);
			}
			string fdesc = _STR("%.*s\000%.*s\000%.*s", 3, option_names, xspace, f.usage);
			array_push(&use, _MOV((string[]){ string_clone(fdesc) }));
		}
	}
	 string _t442 = string_replace(Array_string_join(use, _SLIT("\n")), _SLIT("- ,"), _SLIT("   "));
	// autofree_scope_vars(pos=12974 line_nr=488 scope.pos=11134 scope.end_pos=13019)
	// var "fs" var.pos=11135 var.line_nr=422
	// var "positive_min_arg" var.pos=11168 var.line_nr=423
	// var "positive_max_arg" var.pos=11212 var.line_nr=424
	// var "no_arguments" var.pos=11300 var.line_nr=425
	// var "adesc" var.pos=11370 var.line_nr=426
	// var "use" var.pos=11492 var.line_nr=430
	// af parent scope:
	// af parent scope:
	return _t442;
}

Option_Array_string flag__FlagParser_finalize(flag__FlagParser fs) {
	// FOR IN array
	for (int _t443 = 0; _t443 < fs.args.len; ++_t443) {
		string a = ((string*)fs.args.data)[_t443];
		if ((a.len >= 2 && string_eq(string_substr(a, 0, 2), _SLIT("--"))) || (a.len == 2 && string_at(a, 0) == L'-')) {
			return (Option_Array_string){ .state=2, .err=I_flag__UnkownFlagError_to_Interface_IError((flag__UnkownFlagError*)memdup(&(flag__UnkownFlagError){.msg = _STR("Unknown flag `%.*s\000`", 2, a),.code = 0,}, sizeof(flag__UnkownFlagError))) };
		}
	}
	if (fs.args.len < fs.min_free_args && fs.min_free_args > 0) {
		return (Option_Array_string){ .state=2, .err=I_flag__MinimumArgsCountError_to_Interface_IError((flag__MinimumArgsCountError*)memdup(&(flag__MinimumArgsCountError){.msg = _STR("Expected at least %"PRId32"\000 arguments, but given %"PRId32"", 2, fs.min_free_args, fs.args.len),.code = 0,}, sizeof(flag__MinimumArgsCountError))) };
	}
	if (fs.args.len > fs.max_free_args && fs.max_free_args > 0) {
		return (Option_Array_string){ .state=2, .err=I_flag__MaximumArgsCountError_to_Interface_IError((flag__MaximumArgsCountError*)memdup(&(flag__MaximumArgsCountError){.msg = _STR("Expected at most %"PRId32"\000 arguments, but given %"PRId32"", 2, fs.max_free_args, fs.args.len),.code = 0,}, sizeof(flag__MaximumArgsCountError))) };
	}
	if (fs.args.len > 0 && fs.max_free_args == 0 && fs.min_free_args == 0) {
		return (Option_Array_string){ .state=2, .err=I_flag__NoArgsExpectedError_to_Interface_IError((flag__NoArgsExpectedError*)memdup(&(flag__NoArgsExpectedError){.msg = _STR("Expected no arguments, but given %"PRId32"", 1, fs.args.len),.code = 0,}, sizeof(flag__NoArgsExpectedError))) };
	}
	Option_Array_string _t444;
	opt_ok(&(Array_string[]) { fs.args }, (Option*)(&_t444), sizeof(Array_string));
	// autofree_scope_vars(pos=14093 line_nr=519 scope.pos=13337 scope.end_pos=14109)
	// var "fs" var.pos=13338 var.line_nr=496
	// af parent scope:
	// af parent scope:
	return _t444;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL bool semver__version_satisfies(semver__Version ver, string input) {
	Option_semver__Range _t445 = semver__parse_range(input);
	if (_t445.state != 0) { /*or block*/ 
		IError err = _t445.err;
		 bool _t446 = false;
		// autofree_scope_vars(pos=136 line_nr=5 scope.pos=135 scope.end_pos=150)
		// var "err" var.pos=135 var.line_nr=5
		// af parent scope:
		// var "ver" var.pos=69 var.line_nr=4
		// var "input" var.pos=82 var.line_nr=4
		// var "range" var.pos=104 var.line_nr=5
		// af parent scope:
		// af parent scope:
		return _t446;
	}
 	semver__Range range =  *(semver__Range*)_t445.data;
	 bool _t447 = semver__Range_satisfies(range, ver);
	// autofree_scope_vars(pos=152 line_nr=6 scope.pos=51 scope.end_pos=181)
	// var "ver" var.pos=69 var.line_nr=4
	// var "input" var.pos=82 var.line_nr=4
	// var "range" var.pos=104 var.line_nr=5
	// af parent scope:
	// af parent scope:
	return _t447;
}

VV_LOCAL_SYMBOL bool semver__compare_eq(semver__Version v1, semver__Version v2) {
	 bool _t448 = v1.major == v2.major && v1.minor == v2.minor && v1.patch == v2.patch && string_eq(v1.prerelease, v2.prerelease);
	// autofree_scope_vars(pos=229 line_nr=10 scope.pos=187 scope.end_pos=342)
	// var "v1" var.pos=198 var.line_nr=9
	// var "v2" var.pos=210 var.line_nr=9
	// af parent scope:
	// af parent scope:
	return _t448;
}

VV_LOCAL_SYMBOL bool semver__compare_gt(semver__Version v1, semver__Version v2) {
	if (v1.major < v2.major) {
		 bool _t449 = false;
		// autofree_scope_vars(pos=417 line_nr=16 scope.pos=414 scope.end_pos=432)
		// af parent scope:
		// var "v1" var.pos=359 var.line_nr=14
		// var "v2" var.pos=371 var.line_nr=14
		// af parent scope:
		// af parent scope:
		return _t449;
	}
	if (v1.major > v2.major) {
		 bool _t450 = true;
		// autofree_scope_vars(pos=461 line_nr=19 scope.pos=458 scope.end_pos=475)
		// af parent scope:
		// var "v1" var.pos=359 var.line_nr=14
		// var "v2" var.pos=371 var.line_nr=14
		// af parent scope:
		// af parent scope:
		return _t450;
	}
	if (v1.minor < v2.minor) {
		 bool _t451 = false;
		// autofree_scope_vars(pos=504 line_nr=22 scope.pos=501 scope.end_pos=519)
		// af parent scope:
		// var "v1" var.pos=359 var.line_nr=14
		// var "v2" var.pos=371 var.line_nr=14
		// af parent scope:
		// af parent scope:
		return _t451;
	}
	if (v1.minor > v2.minor) {
		 bool _t452 = true;
		// autofree_scope_vars(pos=548 line_nr=25 scope.pos=545 scope.end_pos=562)
		// af parent scope:
		// var "v1" var.pos=359 var.line_nr=14
		// var "v2" var.pos=371 var.line_nr=14
		// af parent scope:
		// af parent scope:
		return _t452;
	}
	 bool _t453 = v1.patch > v2.patch;
	// autofree_scope_vars(pos=564 line_nr=27 scope.pos=348 scope.end_pos=592)
	// var "v1" var.pos=359 var.line_nr=14
	// var "v2" var.pos=371 var.line_nr=14
	// af parent scope:
	// af parent scope:
	return _t453;
}

VV_LOCAL_SYMBOL bool semver__compare_lt(semver__Version v1, semver__Version v2) {
	if (v1.major > v2.major) {
		 bool _t454 = false;
		// autofree_scope_vars(pos=667 line_nr=32 scope.pos=664 scope.end_pos=682)
		// af parent scope:
		// var "v1" var.pos=609 var.line_nr=30
		// var "v2" var.pos=621 var.line_nr=30
		// af parent scope:
		// af parent scope:
		return _t454;
	}
	if (v1.major < v2.major) {
		 bool _t455 = true;
		// autofree_scope_vars(pos=711 line_nr=35 scope.pos=708 scope.end_pos=725)
		// af parent scope:
		// var "v1" var.pos=609 var.line_nr=30
		// var "v2" var.pos=621 var.line_nr=30
		// af parent scope:
		// af parent scope:
		return _t455;
	}
	if (v1.minor > v2.minor) {
		 bool _t456 = false;
		// autofree_scope_vars(pos=754 line_nr=38 scope.pos=751 scope.end_pos=769)
		// af parent scope:
		// var "v1" var.pos=609 var.line_nr=30
		// var "v2" var.pos=621 var.line_nr=30
		// af parent scope:
		// af parent scope:
		return _t456;
	}
	if (v1.minor < v2.minor) {
		 bool _t457 = true;
		// autofree_scope_vars(pos=798 line_nr=41 scope.pos=795 scope.end_pos=812)
		// af parent scope:
		// var "v1" var.pos=609 var.line_nr=30
		// var "v2" var.pos=621 var.line_nr=30
		// af parent scope:
		// af parent scope:
		return _t457;
	}
	 bool _t458 = v1.patch < v2.patch;
	// autofree_scope_vars(pos=814 line_nr=43 scope.pos=598 scope.end_pos=842)
	// var "v1" var.pos=609 var.line_nr=30
	// var "v2" var.pos=621 var.line_nr=30
	// af parent scope:
	// af parent scope:
	return _t458;
}

VV_LOCAL_SYMBOL bool semver__compare_ge(semver__Version v1, semver__Version v2) {
	if (semver__compare_eq(v1, v2)) {
		 bool _t459 = true;
		// autofree_scope_vars(pos=916 line_nr=48 scope.pos=913 scope.end_pos=930)
		// af parent scope:
		// var "v1" var.pos=859 var.line_nr=46
		// var "v2" var.pos=871 var.line_nr=46
		// af parent scope:
		// af parent scope:
		return _t459;
	}
	 bool _t460 = semver__compare_gt(v1, v2);
	// autofree_scope_vars(pos=932 line_nr=50 scope.pos=848 scope.end_pos=959)
	// var "v1" var.pos=859 var.line_nr=46
	// var "v2" var.pos=871 var.line_nr=46
	// af parent scope:
	// af parent scope:
	return _t460;
}

VV_LOCAL_SYMBOL bool semver__compare_le(semver__Version v1, semver__Version v2) {
	if (semver__compare_eq(v1, v2)) {
		 bool _t461 = true;
		// autofree_scope_vars(pos=1033 line_nr=55 scope.pos=1030 scope.end_pos=1047)
		// af parent scope:
		// var "v1" var.pos=976 var.line_nr=53
		// var "v2" var.pos=988 var.line_nr=53
		// af parent scope:
		// af parent scope:
		return _t461;
	}
	 bool _t462 = semver__compare_lt(v1, v2);
	// autofree_scope_vars(pos=1049 line_nr=57 scope.pos=965 scope.end_pos=1076)
	// var "v1" var.pos=976 var.line_nr=53
	// var "v2" var.pos=988 var.line_nr=53
	// af parent scope:
	// af parent scope:
	return _t462;
}

VV_LOCAL_SYMBOL semver__RawVersion semver__parse(string input) {
	string raw_version = input;
	string prerelease = _SLIT("");
	string metadata = _SLIT("");
	Option_int _t463 = string_last_index(raw_version, _SLIT("+"));
	if (_t463.state != 0) { /*or block*/ 
		IError err = _t463.err;
		*(int*) _t463.data = -1;
	}
 	int plus_idx =  *(int*)_t463.data;
	if (plus_idx > 0) {
		metadata = string_substr(raw_version, (plus_idx + 1), raw_version.len);
		raw_version = string_substr(raw_version, 0, plus_idx);
	}
	Option_int _t464 = string_index(raw_version, _SLIT("-"));
	if (_t464.state != 0) { /*or block*/ 
		IError err = _t464.err;
		*(int*) _t464.data = -1;
	}
 	int hyphen_idx =  *(int*)_t464.data;
	if (hyphen_idx > 0) {
		prerelease = string_substr(raw_version, (hyphen_idx + 1), raw_version.len);
		raw_version = string_substr(raw_version, 0, hyphen_idx);
	}
	Array_string raw_ints = string_split(raw_version, _SLIT("."));
	 semver__RawVersion _t465 = (semver__RawVersion){.prerelease = prerelease,.metadata = metadata,.raw_ints = raw_ints,};
	// autofree_scope_vars(pos=800 line_nr=34 scope.pos=344 scope.end_pos=890)
	// var "input" var.pos=350 var.line_nr=19
	// var "raw_version" var.pos=382 var.line_nr=20
	// var "prerelease" var.pos=408 var.line_nr=21
	// str literal
	// var "metadata" var.pos=430 var.line_nr=22
	// str literal
	// var "plus_idx" var.pos=446 var.line_nr=23
	// var "hyphen_idx" var.pos=603 var.line_nr=28
	// var "raw_ints" var.pos=765 var.line_nr=33
	// af parent scope:
	// af parent scope:
	return _t465;
}

VV_LOCAL_SYMBOL bool semver__RawVersion_is_valid(semver__RawVersion ver) {
	if (ver.raw_ints.len != 3) {
		 bool _t466 = false;
		// autofree_scope_vars(pos=960 line_nr=43 scope.pos=957 scope.end_pos=975)
		// af parent scope:
		// var "ver" var.pos=897 var.line_nr=41
		// af parent scope:
		// af parent scope:
		return _t466;
	}
	 bool _t467 = semver__is_valid_number((*(string*)/*ee elem_typ */array_get(ver.raw_ints, _const_semver__ver_major))) && semver__is_valid_number((*(string*)/*ee elem_typ */array_get(ver.raw_ints, _const_semver__ver_minor))) && semver__is_valid_number((*(string*)/*ee elem_typ */array_get(ver.raw_ints, _const_semver__ver_patch))) && semver__is_valid_string(ver.prerelease) && semver__is_valid_string(ver.metadata);
	// autofree_scope_vars(pos=977 line_nr=45 scope.pos=896 scope.end_pos=1209)
	// var "ver" var.pos=897 var.line_nr=41
	// af parent scope:
	// af parent scope:
	return _t467;
}

VV_LOCAL_SYMBOL bool semver__RawVersion_is_missing(semver__RawVersion ver, int typ) {
	 bool _t468 = typ >= ver.raw_ints.len - 1;
	// autofree_scope_vars(pos=1259 line_nr=52 scope.pos=1215 scope.end_pos=1295)
	// var "ver" var.pos=1216 var.line_nr=51
	// var "typ" var.pos=1243 var.line_nr=51
	// af parent scope:
	// af parent scope:
	return _t468;
}

VV_LOCAL_SYMBOL Option_semver__Version semver__RawVersion_coerce(semver__RawVersion raw_ver) {
	semver__RawVersion ver = semver__RawVersion_complete(raw_ver);
	if (!semver__is_valid_number((*(string*)/*ee elem_typ */array_get(ver.raw_ints, _const_semver__ver_major)))) {
		return (Option_semver__Version){ .state=2, .err=v_error(_STR("Invalid major version: %.*s\000[ver_major]", 2, Array_string_str(ver.raw_ints))) };
	}
	Option_semver__Version _t469;
	opt_ok(&(semver__Version[]) { semver__RawVersion_to_version(ver) }, (Option*)(&_t469), sizeof(semver__Version));
	// autofree_scope_vars(pos=1493 line_nr=60 scope.pos=1301 scope.end_pos=1518)
	// var "raw_ver" var.pos=1302 var.line_nr=55
	// var "ver" var.pos=1343 var.line_nr=56
	// af parent scope:
	// af parent scope:
	return _t469;
}

VV_LOCAL_SYMBOL semver__RawVersion semver__RawVersion_complete(semver__RawVersion raw_ver) {
	Array_string raw_ints = raw_ver.raw_ints;
	for (;;) {
		if (!(raw_ints.len < 3)) break;
		array_push(&raw_ints, _MOV((string[]){ string_clone(_SLIT("0")) }));
	}
	 semver__RawVersion _t471 = (semver__RawVersion){.prerelease = raw_ver.prerelease,.metadata = raw_ver.metadata,.raw_ints = raw_ints,};
	// autofree_scope_vars(pos=1648 line_nr=68 scope.pos=1524 scope.end_pos=1754)
	// var "raw_ver" var.pos=1525 var.line_nr=63
	// var "raw_ints" var.pos=1574 var.line_nr=64
	// af parent scope:
	// af parent scope:
	return _t471;
}

VV_LOCAL_SYMBOL Option_semver__Version semver__RawVersion_validate(semver__RawVersion raw_ver) {
	if (!semver__RawVersion_is_valid(raw_ver)) {
		return (Option_semver__Version){ .state=2, .err=_const_none__ };
	}
	Option_semver__Version _t472;
	opt_ok(&(semver__Version[]) { semver__RawVersion_to_version(raw_ver) }, (Option*)(&_t472), sizeof(semver__Version));
	// autofree_scope_vars(pos=1846 line_nr=79 scope.pos=1760 scope.end_pos=1875)
	// var "raw_ver" var.pos=1761 var.line_nr=75
	// af parent scope:
	// af parent scope:
	return _t472;
}

VV_LOCAL_SYMBOL semver__Version semver__RawVersion_to_version(semver__RawVersion raw_ver) {
	 semver__Version _t473 = (semver__Version){.major = string_int((*(string*)/*ee elem_typ */array_get(raw_ver.raw_ints, _const_semver__ver_major))),.minor = string_int((*(string*)/*ee elem_typ */array_get(raw_ver.raw_ints, _const_semver__ver_minor))),.patch = string_int((*(string*)/*ee elem_typ */array_get(raw_ver.raw_ints, _const_semver__ver_patch))),.prerelease = raw_ver.prerelease,.metadata = raw_ver.metadata,};
	// autofree_scope_vars(pos=1925 line_nr=83 scope.pos=1881 scope.end_pos=2105)
	// var "raw_ver" var.pos=1882 var.line_nr=82
	// af parent scope:
	// af parent scope:
	return _t473;
}

VV_LOCAL_SYMBOL bool semver__Range_satisfies(semver__Range r, semver__Version ver) {
	bool final_result = false;
	// FOR IN array
	for (int _t474 = 0; _t474 < r.comparator_sets.len; ++_t474) {
		semver__ComparatorSet set = ((semver__ComparatorSet*)r.comparator_sets.data)[_t474];
		final_result = final_result || semver__ComparatorSet_satisfies(set, ver);
	}
	// autofree_scope_vars(pos=637 line_nr=46 scope.pos=483 scope.end_pos=658)
	// var "r" var.pos=484 var.line_nr=41
	// var "ver" var.pos=503 var.line_nr=41
	// var "final_result" var.pos=528 var.line_nr=42
	// af parent scope:
	// af parent scope:
	return final_result;
}

VV_LOCAL_SYMBOL bool semver__ComparatorSet_satisfies(semver__ComparatorSet set, semver__Version ver) {
	// FOR IN array
	for (int _t475 = 0; _t475 < set.comparators.len; ++_t475) {
		semver__Comparator comp = ((semver__Comparator*)set.comparators.data)[_t475];
		if (!semver__Comparator_satisfies(comp, ver)) {
			 bool _t476 = false;
			// autofree_scope_vars(pos=775 line_nr=52 scope.pos=771 scope.end_pos=791)
			// af parent scope:
			// var "comp" var.pos=719 var.line_nr=50
			// skipping tmp var "comp"
			// af parent scope:
			// var "set" var.pos=665 var.line_nr=49
			// var "ver" var.pos=694 var.line_nr=49
			// af parent scope:
			// af parent scope:
			return _t476;
		}
	}
	 bool _t477 = true;
	// autofree_scope_vars(pos=796 line_nr=55 scope.pos=664 scope.end_pos=809)
	// var "set" var.pos=665 var.line_nr=49
	// var "ver" var.pos=694 var.line_nr=49
	// af parent scope:
	// af parent scope:
	return _t477;
}

VV_LOCAL_SYMBOL bool semver__Comparator_satisfies(semver__Comparator c, semver__Version ver) {
	bool _t479;
	
	if (c.op == (semver__Operator_gt)) {
		_t479 = semver__Version_gt(ver, c.ver);
	}
	else if (c.op == (semver__Operator_lt)) {
		_t479 = semver__Version_lt(ver, c.ver);
	}
	else if (c.op == (semver__Operator_ge)) {
		_t479 = semver__Version_ge(ver, c.ver);
	}
	else if (c.op == (semver__Operator_le)) {
		_t479 = semver__Version_le(ver, c.ver);
	}
	else if (c.op == (semver__Operator_eq)) {
		_t479 = semver__Version_eq(ver, c.ver);
	}	 bool _t478 = _t479;
	// autofree_scope_vars(pos=860 line_nr=59 scope.pos=815 scope.end_pos=1004)
	// var "c" var.pos=816 var.line_nr=58
	// var "ver" var.pos=840 var.line_nr=58
	// af parent scope:
	// af parent scope:
	return _t478;
}

VV_LOCAL_SYMBOL Option_semver__Range semver__parse_range(string input) {
	Array_string raw_comparator_sets = string_split(input, _const_semver__comparator_set_sep);
	Array_semver__ComparatorSet comparator_sets = __new_array_with_default(0, 0, sizeof(semver__ComparatorSet), 0);
	// FOR IN array
	for (int _t480 = 0; _t480 < raw_comparator_sets.len; ++_t480) {
		string raw_comp_set = ((string*)raw_comparator_sets.data)[_t480];
		if (semver__can_expand(raw_comp_set)) {
			Option_semver__ComparatorSet _t481 = semver__expand_comparator_set(raw_comp_set);
			if (_t481.state != 0) { /*or block*/ 
				IError err = _t481.err;
				return (Option_semver__Range){ .state=2, .err=err };
			}
 			semver__ComparatorSet s =  *(semver__ComparatorSet*)_t481.data;
			array_push(&comparator_sets, _MOV((semver__ComparatorSet[]){ s }));
		} else {
			Option_semver__ComparatorSet _t483 = semver__parse_comparator_set(raw_comp_set);
			if (_t483.state != 0) { /*or block*/ 
				IError err = _t483.err;
				return (Option_semver__Range){ .state=2, .err=err };
			}
 			semver__ComparatorSet s =  *(semver__ComparatorSet*)_t483.data;
			array_push(&comparator_sets, _MOV((semver__ComparatorSet[]){ s }));
		}
	}
	Option_semver__Range _t485;
	opt_ok(&(semver__Range[]) { (semver__Range){.comparator_sets = comparator_sets,} }, (Option*)(&_t485), sizeof(semver__Range));
	// autofree_scope_vars(pos=1414 line_nr=80 scope.pos=1010 scope.end_pos=1445)
	// var "input" var.pos=1022 var.line_nr=68
	// var "raw_comparator_sets" var.pos=1046 var.line_nr=69
	// var "comparator_sets" var.pos=1113 var.line_nr=70
	// af parent scope:
	// af parent scope:
	return _t485;
}

VV_LOCAL_SYMBOL Option_semver__ComparatorSet semver__parse_comparator_set(string input) {
	Array_string raw_comparators = string_split(input, _const_semver__comparator_sep);
	if (raw_comparators.len > 2) {
		return (Option_semver__ComparatorSet){ .state=2, .err=I_semver__InvalidComparatorFormatError_to_Interface_IError((semver__InvalidComparatorFormatError*)memdup(&(semver__InvalidComparatorFormatError){.msg = _STR("Invalid format of comparator set for input \"%.*s\000\"", 2, input),.code = 0,}, sizeof(semver__InvalidComparatorFormatError))) };
	}
	Array_semver__Comparator comparators = __new_array_with_default(0, 0, sizeof(semver__Comparator), 0);
	// FOR IN array
	for (int _t486 = 0; _t486 < raw_comparators.len; ++_t486) {
		string raw_comp = ((string*)raw_comparators.data)[_t486];
		Option_semver__Comparator _t487 = semver__parse_comparator(raw_comp);
		if (_t487.state != 0) { /*or block*/ 
			IError err = _t487.err;
			return (Option_semver__ComparatorSet){ .state=2, .err=I_semver__InvalidComparatorFormatError_to_Interface_IError((semver__InvalidComparatorFormatError*)memdup(&(semver__InvalidComparatorFormatError){.msg = _STR("Invalid comparator \"%.*s\000\" in input \"%.*s\000\"", 3, raw_comp, input),.code = 0,}, sizeof(semver__InvalidComparatorFormatError))) };
		}
 		semver__Comparator c =  *(semver__Comparator*)_t487.data;
		array_push(&comparators, _MOV((semver__Comparator[]){ c }));
	}
	Option_semver__ComparatorSet _t489;
	opt_ok(&(semver__ComparatorSet[]) { (semver__ComparatorSet){.comparators = comparators,} }, (Option*)(&_t489), sizeof(semver__ComparatorSet));
	// autofree_scope_vars(pos=1954 line_nr=99 scope.pos=1451 scope.end_pos=1989)
	// var "input" var.pos=1472 var.line_nr=83
	// var "raw_comparators" var.pos=1504 var.line_nr=84
	// var "comparators" var.pos=1710 var.line_nr=90
	// af parent scope:
	// af parent scope:
	return _t489;
}

VV_LOCAL_SYMBOL Option_semver__Comparator semver__parse_comparator(string input) {
	semver__Operator op = semver__Operator_eq;
	string raw_version = _SLIT("");
	if (string_starts_with(input, _SLIT(">="))) {
		op = semver__Operator_ge;
		raw_version = string_substr(input, 2, input.len);
	} else if (string_starts_with(input, _SLIT("<="))) {
		op = semver__Operator_le;
		raw_version = string_substr(input, 2, input.len);
	} else if (string_starts_with(input, _SLIT(">"))) {
		op = semver__Operator_gt;
		raw_version = string_substr(input, 1, input.len);
	} else if (string_starts_with(input, _SLIT("<"))) {
		op = semver__Operator_lt;
		raw_version = string_substr(input, 1, input.len);
	} else if (string_starts_with(input, _SLIT("="))) {
		raw_version = string_substr(input, 1, input.len);
	} else {
		raw_version = input;
	}
	Option_semver__Version _t490 = semver__coerce_version(raw_version);
	if (_t490.state != 0) { /*or block*/ 
		IError err = _t490.err;
		return (Option_semver__Comparator){ .state=2, .err=_const_none__ };
	}
 	semver__Version version =  *(semver__Version*)_t490.data;
	Option_semver__Comparator _t491;
	opt_ok(&(semver__Comparator[]) { (semver__Comparator){.ver = version,.op = op,} }, (Option*)(&_t491), sizeof(semver__Comparator));
	// autofree_scope_vars(pos=2534 line_nr=123 scope.pos=1995 scope.end_pos=2566)
	// var "input" var.pos=2012 var.line_nr=102
	// var "op" var.pos=2045 var.line_nr=103
	// var "raw_version" var.pos=2068 var.line_nr=104
	// str literal
	// var "version" var.pos=2476 var.line_nr=122
	// af parent scope:
	// af parent scope:
	return _t491;
}

VV_LOCAL_SYMBOL Option_semver__Version semver__parse_xrange(string input) {
	semver__RawVersion raw_ver = semver__RawVersion_complete(semver__parse(input));
	// FOR IN array
	for (int _t492 = 0; _t492 < _const_semver__versions.len; ++_t492) {
		int typ = ((int*)_const_semver__versions.data)[_t492];
		if (string_index_any((*(string*)/*ee elem_typ */array_get(raw_ver.raw_ints, typ)), _const_semver__x_range_symbols) == -1) {
			continue;
		}

		if (typ == (_const_semver__ver_major)) {
			(*(string*)/*ee elem_typ */array_get(raw_ver.raw_ints, _const_semver__ver_major)) = _SLIT("0");
			(*(string*)/*ee elem_typ */array_get(raw_ver.raw_ints, _const_semver__ver_minor)) = _SLIT("0");
			(*(string*)/*ee elem_typ */array_get(raw_ver.raw_ints, _const_semver__ver_patch)) = _SLIT("0");
		}
		else if (typ == (_const_semver__ver_minor)) {
			(*(string*)/*ee elem_typ */array_get(raw_ver.raw_ints, _const_semver__ver_minor)) = _SLIT("0");
			(*(string*)/*ee elem_typ */array_get(raw_ver.raw_ints, _const_semver__ver_patch)) = _SLIT("0");
		}
		else if (typ == (_const_semver__ver_patch)) {
			(*(string*)/*ee elem_typ */array_get(raw_ver.raw_ints, _const_semver__ver_patch)) = _SLIT("0");
		}
		else {
		};
	}
	if (!semver__RawVersion_is_valid(raw_ver)) {
		return (Option_semver__Version){ .state=2, .err=_const_none__ };
	}
	Option_semver__Version _t493;
	opt_ok(&(semver__Version[]) { semver__RawVersion_to_version(raw_ver) }, (Option*)(&_t493), sizeof(semver__Version));
	// autofree_scope_vars(pos=3121 line_nr=151 scope.pos=2572 scope.end_pos=3150)
	// var "input" var.pos=2585 var.line_nr=126
	// var "raw_ver" var.pos=2615 var.line_nr=127
	// af parent scope:
	// af parent scope:
	return _t493;
}

VV_LOCAL_SYMBOL bool semver__can_expand(string input) {
	 bool _t494 = string_at(input, 0) == L'~' || string_at(input, 0) == L'^' || string_contains(input, _const_semver__hyphen_range_sep) || string_index_any(input, _const_semver__x_range_symbols) > -1;
	// autofree_scope_vars(pos=3188 line_nr=155 scope.pos=3156 scope.end_pos=3324)
	// var "input" var.pos=3167 var.line_nr=154
	// af parent scope:
	// af parent scope:
	return _t494;
}

VV_LOCAL_SYMBOL Option_semver__ComparatorSet semver__expand_comparator_set(string input) {
	byte _t495 = string_at(input, 0);
	
	if (_t495 == (L'~')) {
		 Option_semver__ComparatorSet _t496 = semver__expand_tilda(string_substr(input, 1, input.len));
		// autofree_scope_vars(pos=3408 line_nr=161 scope.pos=3403 scope.end_pos=3441)
		// af parent scope:
		// var "input" var.pos=3352 var.line_nr=159
		// af parent scope:
		// af parent scope:
		return _t496;
	}
	else if (_t495 == (L'^')) {
		 Option_semver__ComparatorSet _t497 = semver__expand_caret(string_substr(input, 1, input.len));
		// autofree_scope_vars(pos=3450 line_nr=162 scope.pos=3445 scope.end_pos=3483)
		// af parent scope:
		// var "input" var.pos=3352 var.line_nr=159
		// af parent scope:
		// af parent scope:
		return _t497;
	}
	else {
	};
	if (string_contains(input, _const_semver__hyphen_range_sep)) {
		 Option_semver__ComparatorSet _t498 = semver__expand_hyphen(input);
		// autofree_scope_vars(pos=3545 line_nr=166 scope.pos=3542 scope.end_pos=3575)
		// af parent scope:
		// var "input" var.pos=3352 var.line_nr=159
		// af parent scope:
		// af parent scope:
		return _t498;
	}
	 Option_semver__ComparatorSet _t499 = semver__expand_xrange(input);
	// autofree_scope_vars(pos=3577 line_nr=168 scope.pos=3330 scope.end_pos=3606)
	// var "input" var.pos=3352 var.line_nr=159
	// af parent scope:
	// af parent scope:
	return _t499;
}

VV_LOCAL_SYMBOL Option_semver__ComparatorSet semver__expand_tilda(string raw_version) {
	Option_semver__Version _t500 = semver__coerce_version(raw_version);
	if (_t500.state != 0) { /*or block*/ 
		IError err = _t500.err;
		return (Option_semver__ComparatorSet){ .state=2, .err=_const_none__ };
	}
 	semver__Version min_ver =  *(semver__Version*)_t500.data;
	semver__Version max_ver = min_ver;
	if (min_ver.minor == 0 && min_ver.patch == 0) {
		max_ver = semver__Version_increment(min_ver, semver__Increment_major);
	} else {
		max_ver = semver__Version_increment(min_ver, semver__Increment_minor);
	}
	Option_semver__ComparatorSet _t501;
	opt_ok(&(semver__ComparatorSet[]) { semver__make_comparator_set_ge_lt(min_ver, max_ver) }, (Option*)(&_t501), sizeof(semver__ComparatorSet));
	// autofree_scope_vars(pos=3881 line_nr=179 scope.pos=3612 scope.end_pos=3933)
	// var "raw_version" var.pos=3625 var.line_nr=171
	// var "min_ver" var.pos=3663 var.line_nr=172
	// var "max_ver" var.pos=3726 var.line_nr=173
	// af parent scope:
	// af parent scope:
	return _t501;
}

VV_LOCAL_SYMBOL Option_semver__ComparatorSet semver__expand_caret(string raw_version) {
	Option_semver__Version _t502 = semver__coerce_version(raw_version);
	if (_t502.state != 0) { /*or block*/ 
		IError err = _t502.err;
		return (Option_semver__ComparatorSet){ .state=2, .err=_const_none__ };
	}
 	semver__Version min_ver =  *(semver__Version*)_t502.data;
	semver__Version max_ver = min_ver;
	if (min_ver.major == 0) {
		max_ver = semver__Version_increment(min_ver, semver__Increment_minor);
	} else {
		max_ver = semver__Version_increment(min_ver, semver__Increment_major);
	}
	Option_semver__ComparatorSet _t503;
	opt_ok(&(semver__ComparatorSet[]) { semver__make_comparator_set_ge_lt(min_ver, max_ver) }, (Option*)(&_t503), sizeof(semver__ComparatorSet));
	// autofree_scope_vars(pos=4186 line_nr=190 scope.pos=3939 scope.end_pos=4238)
	// var "raw_version" var.pos=3952 var.line_nr=182
	// var "min_ver" var.pos=3990 var.line_nr=183
	// var "max_ver" var.pos=4053 var.line_nr=184
	// af parent scope:
	// af parent scope:
	return _t503;
}

VV_LOCAL_SYMBOL Option_semver__ComparatorSet semver__expand_hyphen(string raw_range) {
	Array_string raw_versions = string_split(raw_range, _const_semver__hyphen_range_sep);
	if (raw_versions.len != 2) {
		return (Option_semver__ComparatorSet){ .state=2, .err=_const_none__ };
	}
	Option_semver__Version _t504 = semver__coerce_version((*(string*)/*ee elem_typ */array_get(raw_versions, 0)));
	if (_t504.state != 0) { /*or block*/ 
		IError err = _t504.err;
		return (Option_semver__ComparatorSet){ .state=2, .err=_const_none__ };
	}
 	semver__Version min_ver =  *(semver__Version*)_t504.data;
	semver__RawVersion raw_max_ver = semver__parse((*(string*)/*ee elem_typ */array_get(raw_versions, 1)));
	if (semver__RawVersion_is_missing(raw_max_ver, _const_semver__ver_major)) {
		return (Option_semver__ComparatorSet){ .state=2, .err=_const_none__ };
	}
	Option_semver__Version _t505 = semver__RawVersion_coerce(raw_max_ver);
	if (_t505.state != 0) { /*or block*/ 
		IError err = _t505.err;
		return (Option_semver__ComparatorSet){ .state=2, .err=_const_none__ };
	}
 	semver__Version max_ver =  *(semver__Version*)_t505.data;
	if (semver__RawVersion_is_missing(raw_max_ver, _const_semver__ver_minor)) {
		max_ver = semver__Version_increment(max_ver, semver__Increment_minor);
		Option_semver__ComparatorSet _t506;
		opt_ok(&(semver__ComparatorSet[]) { semver__make_comparator_set_ge_lt(min_ver, max_ver) }, (Option*)(&_t506), sizeof(semver__ComparatorSet));
		// autofree_scope_vars(pos=4690 line_nr=206 scope.pos=4649 scope.end_pos=4743)
		// af parent scope:
		// var "raw_range" var.pos=4258 var.line_nr=193
		// var "raw_versions" var.pos=4294 var.line_nr=194
		// var "min_ver" var.pos=4397 var.line_nr=198
		// var "raw_max_ver" var.pos=4460 var.line_nr=199
		// var "max_ver" var.pos=4560 var.line_nr=203
		// af parent scope:
		// af parent scope:
		return _t506;
	}
	Option_semver__ComparatorSet _t507;
	opt_ok(&(semver__ComparatorSet[]) { semver__make_comparator_set_ge_le(min_ver, max_ver) }, (Option*)(&_t507), sizeof(semver__ComparatorSet));
	// autofree_scope_vars(pos=4745 line_nr=208 scope.pos=4244 scope.end_pos=4797)
	// var "raw_range" var.pos=4258 var.line_nr=193
	// var "raw_versions" var.pos=4294 var.line_nr=194
	// var "min_ver" var.pos=4397 var.line_nr=198
	// var "raw_max_ver" var.pos=4460 var.line_nr=199
	// var "max_ver" var.pos=4560 var.line_nr=203
	// af parent scope:
	// af parent scope:
	return _t507;
}

VV_LOCAL_SYMBOL Option_semver__ComparatorSet semver__expand_xrange(string raw_range) {
	Option_semver__Version _t508 = semver__parse_xrange(raw_range);
	if (_t508.state != 0) { /*or block*/ 
		IError err = _t508.err;
		return (Option_semver__ComparatorSet){ .state=2, .err=_const_none__ };
	}
 	semver__Version min_ver =  *(semver__Version*)_t508.data;
	if (min_ver.major == 0) {
		Array_semver__Comparator comparators = new_array_from_c_array(1, 1, sizeof(semver__Comparator), _MOV((semver__Comparator[1]){(semver__Comparator){.ver = min_ver,.op = semver__Operator_ge,}}));
		Option_semver__ComparatorSet _t509;
		opt_ok(&(semver__ComparatorSet[]) { (semver__ComparatorSet){.comparators = comparators,} }, (Option*)(&_t509), sizeof(semver__ComparatorSet));
		// autofree_scope_vars(pos=4993 line_nr=217 scope.pos=4930 scope.end_pos=5029)
		// var "comparators" var.pos=4934 var.line_nr=214
		// af parent scope:
		// var "raw_range" var.pos=4817 var.line_nr=211
		// var "min_ver" var.pos=4853 var.line_nr=212
		// var "max_ver" var.pos=5036 var.line_nr=219
		// af parent scope:
		// af parent scope:
		return _t509;
	}
	semver__Version max_ver = min_ver;
	if (min_ver.minor == 0) {
		max_ver = semver__Version_increment(min_ver, semver__Increment_major);
	} else {
		max_ver = semver__Version_increment(min_ver, semver__Increment_minor);
	}
	Option_semver__ComparatorSet _t510;
	opt_ok(&(semver__ComparatorSet[]) { semver__make_comparator_set_ge_lt(min_ver, max_ver) }, (Option*)(&_t510), sizeof(semver__ComparatorSet));
	// autofree_scope_vars(pos=5169 line_nr=225 scope.pos=4803 scope.end_pos=5221)
	// var "raw_range" var.pos=4817 var.line_nr=211
	// var "min_ver" var.pos=4853 var.line_nr=212
	// var "max_ver" var.pos=5036 var.line_nr=219
	// af parent scope:
	// af parent scope:
	return _t510;
}

VV_LOCAL_SYMBOL semver__ComparatorSet semver__make_comparator_set_ge_lt(semver__Version min, semver__Version max) {
	Array_semver__Comparator comparators = new_array_from_c_array(2, 2, sizeof(semver__Comparator), _MOV((semver__Comparator[2]){(semver__Comparator){.ver = min,.op = semver__Operator_ge,}, (semver__Comparator){.ver = max,.op = semver__Operator_lt,}}));
	 semver__ComparatorSet _t511 = (semver__ComparatorSet){.comparators = comparators,};
	// autofree_scope_vars(pos=5380 line_nr=233 scope.pos=5227 scope.end_pos=5415)
	// var "min" var.pos=5253 var.line_nr=228
	// var "max" var.pos=5266 var.line_nr=228
	// var "comparators" var.pos=5296 var.line_nr=229
	// af parent scope:
	// af parent scope:
	return _t511;
}

VV_LOCAL_SYMBOL semver__ComparatorSet semver__make_comparator_set_ge_le(semver__Version min, semver__Version max) {
	Array_semver__Comparator comparators = new_array_from_c_array(2, 2, sizeof(semver__Comparator), _MOV((semver__Comparator[2]){(semver__Comparator){.ver = min,.op = semver__Operator_ge,}, (semver__Comparator){.ver = max,.op = semver__Operator_le,}}));
	 semver__ComparatorSet _t512 = (semver__ComparatorSet){.comparators = comparators,};
	// autofree_scope_vars(pos=5574 line_nr=241 scope.pos=5421 scope.end_pos=5609)
	// var "min" var.pos=5447 var.line_nr=236
	// var "max" var.pos=5460 var.line_nr=236
	// var "comparators" var.pos=5490 var.line_nr=237
	// af parent scope:
	// af parent scope:
	return _t512;
}

Option_semver__Version semver__from(string input) {
	if (input.len == 0) {
		return (Option_semver__Version){ .state=2, .err=I_semver__EmptyInputError_to_Interface_IError((semver__EmptyInputError*)memdup(&(semver__EmptyInputError){.msg = _SLIT("Empty input"),.code = 0,}, sizeof(semver__EmptyInputError))) };
	}
	semver__RawVersion raw_version = semver__parse(input);
	Option_semver__Version _t513 = semver__RawVersion_validate(raw_version);
	if (_t513.state != 0) { /*or block*/ 
		IError err = _t513.err;
		return (Option_semver__Version){ .state=2, .err=I_semver__InvalidVersionFormatError_to_Interface_IError((semver__InvalidVersionFormatError*)memdup(&(semver__InvalidVersionFormatError){.msg = _STR("Invalid version format for input \"%.*s\000\"", 2, input),.code = 0,}, sizeof(semver__InvalidVersionFormatError))) };
	}
 	semver__Version version =  *(semver__Version*)_t513.data;
	Option_semver__Version _t514;
	opt_ok(&(semver__Version[]) { version }, (Option*)(&_t514), sizeof(semver__Version));
	// autofree_scope_vars(pos=859 line_nr=43 scope.pos=596 scope.end_pos=875)
	// var "input" var.pos=601 var.line_nr=33
	// var "raw_version" var.pos=687 var.line_nr=37
	// var "version" var.pos=716 var.line_nr=38
	// af parent scope:
	// af parent scope:
	return _t514;
}

semver__Version semver__build(int major, int minor, int patch) {
	 semver__Version _t515 = (semver__Version){.major = major,.minor = minor,.patch = patch,.prerelease = _SLIT(""),.metadata = _SLIT(""),};
	// autofree_scope_vars(pos=1073 line_nr=49 scope.pos=974 scope.end_pos=1118)
	// var "major" var.pos=980 var.line_nr=47
	// var "minor" var.pos=991 var.line_nr=47
	// var "patch" var.pos=1002 var.line_nr=47
	// af parent scope:
	// af parent scope:
	return _t515;
}

semver__Version semver__Version_increment(semver__Version ver, semver__Increment typ) {
	 semver__Version _t516 = semver__increment_version(ver, typ);
	// autofree_scope_vars(pos=1266 line_nr=55 scope.pos=1217 scope.end_pos=1302)
	// var "ver" var.pos=1218 var.line_nr=54
	// var "typ" var.pos=1241 var.line_nr=54
	// af parent scope:
	// af parent scope:
	return _t516;
}

bool semver__Version_satisfies(semver__Version ver, string input) {
	 bool _t517 = semver__version_satisfies(ver, input);
	// autofree_scope_vars(pos=1628 line_nr=64 scope.pos=1583 scope.end_pos=1666)
	// var "ver" var.pos=1584 var.line_nr=63
	// var "input" var.pos=1607 var.line_nr=63
	// af parent scope:
	// af parent scope:
	return _t517;
}

bool semver__Version_eq(semver__Version v1, semver__Version v2) {
	 bool _t518 = semver__compare_eq(v1, v2);
	// autofree_scope_vars(pos=1758 line_nr=69 scope.pos=1723 scope.end_pos=1785)
	// var "v1" var.pos=1724 var.line_nr=68
	// var "v2" var.pos=1739 var.line_nr=68
	// af parent scope:
	// af parent scope:
	return _t518;
}

bool semver__Version_gt(semver__Version v1, semver__Version v2) {
	 bool _t519 = semver__compare_gt(v1, v2);
	// autofree_scope_vars(pos=1881 line_nr=74 scope.pos=1846 scope.end_pos=1908)
	// var "v1" var.pos=1847 var.line_nr=73
	// var "v2" var.pos=1862 var.line_nr=73
	// af parent scope:
	// af parent scope:
	return _t519;
}

bool semver__Version_lt(semver__Version v1, semver__Version v2) {
	 bool _t520 = semver__compare_lt(v1, v2);
	// autofree_scope_vars(pos=2001 line_nr=79 scope.pos=1966 scope.end_pos=2028)
	// var "v1" var.pos=1967 var.line_nr=78
	// var "v2" var.pos=1982 var.line_nr=78
	// af parent scope:
	// af parent scope:
	return _t520;
}

bool semver__Version_ge(semver__Version v1, semver__Version v2) {
	 bool _t521 = semver__compare_ge(v1, v2);
	// autofree_scope_vars(pos=2136 line_nr=84 scope.pos=2101 scope.end_pos=2163)
	// var "v1" var.pos=2102 var.line_nr=83
	// var "v2" var.pos=2117 var.line_nr=83
	// af parent scope:
	// af parent scope:
	return _t521;
}

bool semver__Version_le(semver__Version v1, semver__Version v2) {
	 bool _t522 = semver__compare_le(v1, v2);
	// autofree_scope_vars(pos=2268 line_nr=89 scope.pos=2233 scope.end_pos=2295)
	// var "v1" var.pos=2234 var.line_nr=88
	// var "v2" var.pos=2249 var.line_nr=88
	// af parent scope:
	// af parent scope:
	return _t522;
}

Option_semver__Version semver__coerce(string input) {
	 Option_semver__Version _t523 = semver__coerce_version(input);
	// autofree_scope_vars(pos=2618 line_nr=102 scope.pos=2586 scope.end_pos=2648)
	// var "input" var.pos=2593 var.line_nr=101
	// af parent scope:
	// af parent scope:
	return _t523;
}

bool semver__is_valid(string input) {
	 bool _t524 = semver__is_version_valid(input);
	// autofree_scope_vars(pos=2794 line_nr=108 scope.pos=2764 scope.end_pos=2826)
	// var "input" var.pos=2773 var.line_nr=107
	// af parent scope:
	// af parent scope:
	return _t524;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL bool semver__is_version_valid(string input) {
	semver__RawVersion raw_ver = semver__parse(input);
	 bool _t525 = semver__RawVersion_is_valid(raw_ver);
	// autofree_scope_vars(pos=114 line_nr=6 scope.pos=51 scope.end_pos=141)
	// var "input" var.pos=68 var.line_nr=4
	// var "raw_ver" var.pos=90 var.line_nr=5
	// af parent scope:
	// af parent scope:
	return _t525;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL Option_semver__Version semver__coerce_version(string input) {
	semver__RawVersion raw_ver = semver__parse(input);
	Option_semver__Version _t526 = semver__RawVersion_coerce(raw_ver);
	if (_t526.state != 0) { /*or block*/ 
		IError err = _t526.err;
		return (Option_semver__Version){ .state=2, .err=v_error(_STR("Invalid version for input \"%.*s\000\"", 2, input)) };
	}
 	semver__Version ver =  *(semver__Version*)_t526.data;
	Option_semver__Version _t527;
	opt_ok(&(semver__Version[]) { ver }, (Option*)(&_t527), sizeof(semver__Version));
	// autofree_scope_vars(pos=304 line_nr=13 scope.pos=156 scope.end_pos=316)
	// var "input" var.pos=171 var.line_nr=10
	// var "raw_ver" var.pos=197 var.line_nr=11
	// var "ver" var.pos=222 var.line_nr=12
	// af parent scope:
	// af parent scope:
	return _t527;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL semver__Version semver__increment_version(semver__Version ver, semver__Increment typ) {
	int major = ver.major;
	int minor = ver.minor;
	int patch = ver.patch;

	if (typ == (semver__Increment_major)) {
		major++;
		minor = 0;
		patch = 0;
	}
	else if (typ == (semver__Increment_minor)) {
		minor++;
		patch = 0;
	}
	else if (typ == (semver__Increment_patch)) {
		patch++;
	};
	 semver__Version _t528 = (semver__Version){.major = major,.minor = minor,.patch = patch,.prerelease = ver.prerelease,.metadata = ver.metadata,};
	// autofree_scope_vars(pos=592 line_nr=35 scope.pos=331 scope.end_pos=659)
	// var "ver" var.pos=349 var.line_nr=17
	// var "typ" var.pos=362 var.line_nr=17
	// var "major" var.pos=392 var.line_nr=18
	// var "minor" var.pos=416 var.line_nr=19
	// var "patch" var.pos=440 var.line_nr=20
	// af parent scope:
	// af parent scope:
	return _t528;
}

VV_LOCAL_SYMBOL bool semver__is_valid_string(string input) {
	for (int _t529 = 0; _t529 < input.len; ++_t529) {
		byte c = input.str[_t529];
		if (!(byte_is_letter(c) || byte_is_digit(c) || c == L'.' || c == L'-')) {
			 bool _t530 = false;
			// autofree_scope_vars(pos=786 line_nr=41 scope.pos=782 scope.end_pos=802)
			// af parent scope:
			// var "c" var.pos=707 var.line_nr=39
			// skipping tmp var "c"
			// af parent scope:
			// var "input" var.pos=681 var.line_nr=38
			// af parent scope:
			// af parent scope:
			return _t530;
		}
	}
	 bool _t531 = true;
	// autofree_scope_vars(pos=807 line_nr=44 scope.pos=665 scope.end_pos=820)
	// var "input" var.pos=681 var.line_nr=38
	// af parent scope:
	// af parent scope:
	return _t531;
}

VV_LOCAL_SYMBOL bool semver__is_valid_number(string input) {
	for (int _t532 = 0; _t532 < input.len; ++_t532) {
		byte c = input.str[_t532];
		if (!byte_is_digit(c)) {
			 bool _t533 = false;
			// autofree_scope_vars(pos=904 line_nr=50 scope.pos=900 scope.end_pos=920)
			// af parent scope:
			// var "c" var.pos=868 var.line_nr=48
			// skipping tmp var "c"
			// af parent scope:
			// var "input" var.pos=842 var.line_nr=47
			// af parent scope:
			// af parent scope:
			return _t533;
		}
	}
	 bool _t534 = true;
	// autofree_scope_vars(pos=925 line_nr=53 scope.pos=826 scope.end_pos=938)
	// var "input" var.pos=842 var.line_nr=47
	// af parent scope:
	// af parent scope:
	return _t534;
}

v__vcache__CacheManager v__vcache__new_cache_manager(Array_string opts) {
	string vcache_basepath = os__getenv(_SLIT("VCACHE"));
	if ((vcache_basepath).len == 0) {
		vcache_basepath = os__join_path(os__vmodules_dir(), new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("cache")})));
	}
	v__vcache__dlog(_SLIT("new_cache_manager"), _STR("vcache_basepath: %.*s\000 | opts:\n     %.*s", 2, vcache_basepath, Array_string_str(opts)));
	if (!os__is_dir(vcache_basepath)) {
		Option_void _t535 = os__mkdir_all(vcache_basepath);
		if (_t535.state != 0 && _t535.err._typ != _IError_None___index) {
			IError err = _t535.err;
			v_panic(IError_str(err));
		};
		string readme_content = string_strip_margin(_SLIT("This folder contains cached build artifacts from the V build system.\n		|You can safely delete it, if it is getting too large.\n		|It will be recreated the next time you compile something with V.\n		|You can change its location with the VCACHE environment variable.\n		"));
		Option_void _t536 = os__write_file(os__join_path(vcache_basepath, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("README.md")}))), readme_content);
		if (_t536.state != 0 && _t536.err._typ != _IError_None___index) {
			IError err = _t536.err;
			v_panic(IError_str(err));
		};
	}
	string original_vopts = Array_string_join(opts, _SLIT("|"));
	 v__vcache__CacheManager _t537 = (v__vcache__CacheManager){.basepath = vcache_basepath,.original_vopts = original_vopts,.vopts = original_vopts,.k2cpath = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),};
	// autofree_scope_vars(pos=2241 line_nr=52 scope.pos=1471 scope.end_pos=2351)
	// var "opts" var.pos=1489 var.line_nr=36
	// var "vcache_basepath" var.pos=1524 var.line_nr=37
	// var "original_vopts" var.pos=2208 var.line_nr=51
	// af parent scope:
	// af parent scope:
	return _t537;
}

void v__vcache__CacheManager_set_temporary_options(v__vcache__CacheManager* cm, Array_string new_opts) {
	cm->vopts = string_add(string_add(cm->original_vopts, _SLIT("#")), Array_string_join(new_opts, _SLIT("|")));
	v__vcache__dlog(_SLIT("set_temporary_options"), _STR("cm.vopts:\n     %.*s", 1, cm->vopts));
}

string v__vcache__CacheManager_key2cpath(v__vcache__CacheManager* cm, string key) {
	string* _t539 = (string*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, cm->k2cpath), &(string[]){key}));
	Option_string _t538 = {0};
	if (_t539) {
		*((string*)&_t538.data) = *((string*)_t539);
	} else {
		_t538.state = 2; _t538.err = v_error(_SLIT("array index out of range"));
	}
	;
	if (_t538.state != 0) { /*or block*/ 
		IError err = _t538.err;
		*(string*) _t538.data = _SLIT("");
	}
	string cpath = *(string*)_t538.data;
	if ((cpath).len == 0) {
		string hk = string_add(cm->vopts, key);
		string a = u64_hex_full(hash__sum64_string(hk, 5));
		string b = u64_hex_full(hash__sum64_string(hk, 7));
		string khash = string_add(a, b);
		string prefix = string_substr(khash, 0, 2);
		string cprefix_folder = os__join_path(cm->basepath, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){prefix})));
		cpath = os__join_path(cprefix_folder, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){khash})));
		if (!os__is_dir(cprefix_folder)) {
			Option_void _t540 = os__mkdir_all(cprefix_folder);
			if (_t540.state != 0 && _t540.err._typ != _IError_None___index) {
				IError err = _t540.err;
				v_panic(IError_str(err));
			};
			os__chmod(cprefix_folder, 0777);
		}
		v__vcache__dlog(_SLIT("key2cpath"), _SLIT("new hk"));
		v__vcache__dlog(_SLIT("key2cpath"), _STR("       key: %.*s", 1, key));
		v__vcache__dlog(_SLIT("key2cpath"), _STR("     cpath: %.*s", 1, cpath));
		v__vcache__dlog(_SLIT("key2cpath"), _STR("  cm.vopts:\n     %.*s", 1, cm->vopts));
		map_set(&cm->k2cpath, &(string[]){key}, &(string[]) { cpath });
	}
	v__vcache__dlog(_SLIT("key2cpath"), _STR("key: %*.*s\000 => cpath: %.*s", 2, key, -30, cpath));
	// autofree_scope_vars(pos=3420 line_nr=88 scope.pos=2729 scope.end_pos=3434)
	// var "cm" var.pos=2734 var.line_nr=67
	// var "key" var.pos=2761 var.line_nr=67
	// var "cpath" var.pos=2787 var.line_nr=68
	// af parent scope:
	// af parent scope:
	return cpath;
}

string v__vcache__CacheManager_postfix_with_key2cpath(v__vcache__CacheManager* cm, string postfix, string key) {
	string prefix = v__vcache__CacheManager_key2cpath(cm, key);
	string res = string_add(prefix, postfix);
	// autofree_scope_vars(pos=3580 line_nr=94 scope.pos=3444 scope.end_pos=3592)
	// var "cm" var.pos=3449 var.line_nr=91
	// var "postfix" var.pos=3489 var.line_nr=91
	// var "key" var.pos=3505 var.line_nr=91
	// var "prefix" var.pos=3527 var.line_nr=92
	// var "res" var.pos=3556 var.line_nr=93
	// af parent scope:
	// af parent scope:
	return res;
}

Option_string v__vcache__CacheManager_exists(v__vcache__CacheManager* cm, string postfix, string key) {
	string fpath = v__vcache__CacheManager_postfix_with_key2cpath(cm, postfix, key);
	v__vcache__dlog(_SLIT("exists"), _STR("postfix: %.*s\000 | key: %.*s\000 | fpath: %.*s", 3, postfix, key, fpath));
	if (!os__exists(fpath)) {
		return (Option_string){ .state=2, .err=v_error(_SLIT("does not exist yet")) };
	}
	Option_string _t541;
	opt_ok(&(string[]) { fpath }, (Option*)(&_t541), sizeof(string));
	// autofree_scope_vars(pos=3843 line_nr=103 scope.pos=3602 scope.end_pos=3857)
	// var "cm" var.pos=3607 var.line_nr=97
	// var "postfix" var.pos=3631 var.line_nr=97
	// var "key" var.pos=3647 var.line_nr=97
	// var "fpath" var.pos=3670 var.line_nr=98
	// af parent scope:
	// af parent scope:
	return _t541;
}

Option_string v__vcache__CacheManager_save(v__vcache__CacheManager* cm, string postfix, string key, string content) {
	string fpath = v__vcache__CacheManager_postfix_with_key2cpath(cm, postfix, key);
	Option_void _t542 = os__write_file(fpath, content);
	if (_t542.state != 0 && _t542.err._typ != _IError_None___index) {
		Option_string _t543;
		memcpy(&_t543, &_t542, sizeof(Option));
		return _t543;
	};
	v__vcache__dlog(_SLIT("save"), _STR("postfix: %.*s\000 | key: %.*s\000 | fpath: %.*s", 3, postfix, key, fpath));
	Option_string _t544;
	opt_ok(&(string[]) { fpath }, (Option*)(&_t544), sizeof(string));
	// autofree_scope_vars(pos=4091 line_nr=110 scope.pos=3867 scope.end_pos=4105)
	// var "cm" var.pos=3872 var.line_nr=106
	// var "postfix" var.pos=3894 var.line_nr=106
	// var "key" var.pos=3910 var.line_nr=106
	// var "content" var.pos=3922 var.line_nr=106
	// var "fpath" var.pos=3949 var.line_nr=107
	// af parent scope:
	// af parent scope:
	return _t544;
}

Option_string v__vcache__CacheManager_load(v__vcache__CacheManager* cm, string postfix, string key) {
	Option_string _t545 = v__vcache__CacheManager_exists(cm, postfix, key);
	if (_t545.state != 0) { /*or block*/ 
		Option_string _t546;
		memcpy(&_t546, &_t545, sizeof(Option));
		return _t546;
	}
 	string fpath =  *(string*)_t545.data;
	Option_string _t547 = os__read_file(fpath);
	if (_t547.state != 0) { /*or block*/ 
		Option_string _t548;
		memcpy(&_t548, &_t547, sizeof(Option));
		return _t548;
	}
 	string content =  *(string*)_t547.data;
	v__vcache__dlog(_SLIT("load"), _STR("postfix: %.*s\000 | key: %.*s\000 | fpath: %.*s", 3, postfix, key, fpath));
	Option_string _t549;
	opt_ok(&(string[]) { content }, (Option*)(&_t549), sizeof(string));
	// autofree_scope_vars(pos=4310 line_nr=117 scope.pos=4115 scope.end_pos=4326)
	// var "cm" var.pos=4120 var.line_nr=113
	// var "postfix" var.pos=4142 var.line_nr=113
	// var "key" var.pos=4158 var.line_nr=113
	// var "fpath" var.pos=4181 var.line_nr=114
	// var "content" var.pos=4217 var.line_nr=115
	// af parent scope:
	// af parent scope:
	return _t549;
}

void v__vcache__dlog(string fname, string s) {
}

string term__format(string msg, string open, string close) {
	 string _t550 = string_add(string_add(string_add(string_add(string_add(string_add(_SLIT("\x1b["), open), _SLIT("m")), msg), _SLIT("\x1b[")), close), _SLIT("m"));
	// autofree_scope_vars(pos=245 line_nr=6 scope.pos=190 scope.end_pos=304)
	// var "msg" var.pos=197 var.line_nr=5
	// var "open" var.pos=209 var.line_nr=5
	// var "close" var.pos=222 var.line_nr=5
	// af parent scope:
	// af parent scope:
	return _t550;
}

string term__format_rgb(int r, int g, int b, string msg, string open, string close) {
	 string _t551 = string_add(string_add(string_add(string_add(string_add(string_add(string_add(string_add(string_add(string_add(string_add(string_add(_SLIT("\x1b["), open), _SLIT(";2;")), int_str(r)), _SLIT(";")), int_str(g)), _SLIT(";")), int_str(b)), _SLIT("m")), msg), _SLIT("\x1b[")), close), _SLIT("m"));
	// autofree_scope_vars(pos=394 line_nr=10 scope.pos=314 scope.end_pos=505)
	// var "r" var.pos=325 var.line_nr=9
	// var "g" var.pos=332 var.line_nr=9
	// var "b" var.pos=339 var.line_nr=9
	// var "msg" var.pos=346 var.line_nr=9
	// var "open" var.pos=358 var.line_nr=9
	// var "close" var.pos=371 var.line_nr=9
	// af parent scope:
	// af parent scope:
	return _t551;
}

string term__rgb(int r, int g, int b, string msg) {
	 string _t552 = term__format_rgb(r, g, b, msg, _SLIT("38"), _SLIT("39"));
	// autofree_scope_vars(pos=561 line_nr=15 scope.pos=515 scope.end_pos=606)
	// var "r" var.pos=519 var.line_nr=14
	// var "g" var.pos=526 var.line_nr=14
	// var "b" var.pos=533 var.line_nr=14
	// var "msg" var.pos=540 var.line_nr=14
	// af parent scope:
	// af parent scope:
	return _t552;
}

string term__bg_rgb(int r, int g, int b, string msg) {
	 string _t553 = term__format_rgb(r, g, b, msg, _SLIT("48"), _SLIT("49"));
	// autofree_scope_vars(pos=665 line_nr=19 scope.pos=616 scope.end_pos=710)
	// var "r" var.pos=623 var.line_nr=18
	// var "g" var.pos=630 var.line_nr=18
	// var "b" var.pos=637 var.line_nr=18
	// var "msg" var.pos=644 var.line_nr=18
	// af parent scope:
	// af parent scope:
	return _t553;
}

string term__hex(int hex, string msg) {
	 string _t554 = term__format_rgb(hex >> 16, (hex >> 8 & 0xFF), (hex & 0xFF), msg, _SLIT("38"), _SLIT("39"));
	// autofree_scope_vars(pos=754 line_nr=23 scope.pos=720 scope.end_pos=830)
	// var "hex" var.pos=724 var.line_nr=22
	// var "msg" var.pos=733 var.line_nr=22
	// af parent scope:
	// af parent scope:
	return _t554;
}

string term__bg_hex(int hex, string msg) {
	 string _t555 = term__format_rgb(hex >> 16, (hex >> 8 & 0xFF), (hex & 0xFF), msg, _SLIT("48"), _SLIT("49"));
	// autofree_scope_vars(pos=877 line_nr=27 scope.pos=840 scope.end_pos=953)
	// var "hex" var.pos=847 var.line_nr=26
	// var "msg" var.pos=856 var.line_nr=26
	// af parent scope:
	// af parent scope:
	return _t555;
}

string term__bg_black(string msg) {
	 string _t556 = term__format(msg, _SLIT("40"), _SLIT("49"));
	// autofree_scope_vars(pos=993 line_nr=31 scope.pos=963 scope.end_pos=1025)
	// var "msg" var.pos=972 var.line_nr=30
	// af parent scope:
	// af parent scope:
	return _t556;
}

string term__bright_bg_black(string msg) {
	 string _t557 = term__format(msg, _SLIT("100"), _SLIT("49"));
	// autofree_scope_vars(pos=1072 line_nr=35 scope.pos=1035 scope.end_pos=1105)
	// var "msg" var.pos=1051 var.line_nr=34
	// af parent scope:
	// af parent scope:
	return _t557;
}

string term__bg_blue(string msg) {
	 string _t558 = term__format(msg, _SLIT("44"), _SLIT("49"));
	// autofree_scope_vars(pos=1144 line_nr=39 scope.pos=1115 scope.end_pos=1176)
	// var "msg" var.pos=1123 var.line_nr=38
	// af parent scope:
	// af parent scope:
	return _t558;
}

string term__bright_bg_blue(string msg) {
	 string _t559 = term__format(msg, _SLIT("104"), _SLIT("49"));
	// autofree_scope_vars(pos=1222 line_nr=43 scope.pos=1186 scope.end_pos=1255)
	// var "msg" var.pos=1201 var.line_nr=42
	// af parent scope:
	// af parent scope:
	return _t559;
}

string term__bg_cyan(string msg) {
	 string _t560 = term__format(msg, _SLIT("46"), _SLIT("49"));
	// autofree_scope_vars(pos=1294 line_nr=47 scope.pos=1265 scope.end_pos=1326)
	// var "msg" var.pos=1273 var.line_nr=46
	// af parent scope:
	// af parent scope:
	return _t560;
}

string term__bright_bg_cyan(string msg) {
	 string _t561 = term__format(msg, _SLIT("106"), _SLIT("49"));
	// autofree_scope_vars(pos=1372 line_nr=51 scope.pos=1336 scope.end_pos=1405)
	// var "msg" var.pos=1351 var.line_nr=50
	// af parent scope:
	// af parent scope:
	return _t561;
}

string term__bg_green(string msg) {
	 string _t562 = term__format(msg, _SLIT("42"), _SLIT("49"));
	// autofree_scope_vars(pos=1445 line_nr=55 scope.pos=1415 scope.end_pos=1477)
	// var "msg" var.pos=1424 var.line_nr=54
	// af parent scope:
	// af parent scope:
	return _t562;
}

string term__bright_bg_green(string msg) {
	 string _t563 = term__format(msg, _SLIT("102"), _SLIT("49"));
	// autofree_scope_vars(pos=1524 line_nr=59 scope.pos=1487 scope.end_pos=1557)
	// var "msg" var.pos=1503 var.line_nr=58
	// af parent scope:
	// af parent scope:
	return _t563;
}

string term__bg_magenta(string msg) {
	 string _t564 = term__format(msg, _SLIT("45"), _SLIT("49"));
	// autofree_scope_vars(pos=1599 line_nr=63 scope.pos=1567 scope.end_pos=1631)
	// var "msg" var.pos=1578 var.line_nr=62
	// af parent scope:
	// af parent scope:
	return _t564;
}

string term__bright_bg_magenta(string msg) {
	 string _t565 = term__format(msg, _SLIT("105"), _SLIT("49"));
	// autofree_scope_vars(pos=1680 line_nr=67 scope.pos=1641 scope.end_pos=1713)
	// var "msg" var.pos=1659 var.line_nr=66
	// af parent scope:
	// af parent scope:
	return _t565;
}

string term__bg_red(string msg) {
	 string _t566 = term__format(msg, _SLIT("41"), _SLIT("49"));
	// autofree_scope_vars(pos=1751 line_nr=71 scope.pos=1723 scope.end_pos=1783)
	// var "msg" var.pos=1730 var.line_nr=70
	// af parent scope:
	// af parent scope:
	return _t566;
}

string term__bright_bg_red(string msg) {
	 string _t567 = term__format(msg, _SLIT("101"), _SLIT("49"));
	// autofree_scope_vars(pos=1828 line_nr=75 scope.pos=1793 scope.end_pos=1861)
	// var "msg" var.pos=1807 var.line_nr=74
	// af parent scope:
	// af parent scope:
	return _t567;
}

string term__bg_white(string msg) {
	 string _t568 = term__format(msg, _SLIT("47"), _SLIT("49"));
	// autofree_scope_vars(pos=1901 line_nr=79 scope.pos=1871 scope.end_pos=1933)
	// var "msg" var.pos=1880 var.line_nr=78
	// af parent scope:
	// af parent scope:
	return _t568;
}

string term__bright_bg_white(string msg) {
	 string _t569 = term__format(msg, _SLIT("107"), _SLIT("49"));
	// autofree_scope_vars(pos=1980 line_nr=83 scope.pos=1943 scope.end_pos=2013)
	// var "msg" var.pos=1959 var.line_nr=82
	// af parent scope:
	// af parent scope:
	return _t569;
}

string term__bg_yellow(string msg) {
	 string _t570 = term__format(msg, _SLIT("43"), _SLIT("49"));
	// autofree_scope_vars(pos=2054 line_nr=87 scope.pos=2023 scope.end_pos=2086)
	// var "msg" var.pos=2033 var.line_nr=86
	// af parent scope:
	// af parent scope:
	return _t570;
}

string term__bright_bg_yellow(string msg) {
	 string _t571 = term__format(msg, _SLIT("103"), _SLIT("49"));
	// autofree_scope_vars(pos=2134 line_nr=91 scope.pos=2096 scope.end_pos=2167)
	// var "msg" var.pos=2113 var.line_nr=90
	// af parent scope:
	// af parent scope:
	return _t571;
}

string term__black(string msg) {
	 string _t572 = term__format(msg, _SLIT("30"), _SLIT("39"));
	// autofree_scope_vars(pos=2204 line_nr=95 scope.pos=2177 scope.end_pos=2236)
	// var "msg" var.pos=2183 var.line_nr=94
	// af parent scope:
	// af parent scope:
	return _t572;
}

string term__bright_black(string msg) {
	 string _t573 = term__format(msg, _SLIT("90"), _SLIT("39"));
	// autofree_scope_vars(pos=2280 line_nr=99 scope.pos=2246 scope.end_pos=2312)
	// var "msg" var.pos=2259 var.line_nr=98
	// af parent scope:
	// af parent scope:
	return _t573;
}

string term__blue(string msg) {
	 string _t574 = term__format(msg, _SLIT("34"), _SLIT("39"));
	// autofree_scope_vars(pos=2348 line_nr=103 scope.pos=2322 scope.end_pos=2380)
	// var "msg" var.pos=2327 var.line_nr=102
	// af parent scope:
	// af parent scope:
	return _t574;
}

string term__bright_blue(string msg) {
	 string _t575 = term__format(msg, _SLIT("94"), _SLIT("39"));
	// autofree_scope_vars(pos=2423 line_nr=107 scope.pos=2390 scope.end_pos=2455)
	// var "msg" var.pos=2402 var.line_nr=106
	// af parent scope:
	// af parent scope:
	return _t575;
}

string term__bold(string msg) {
	 string _t576 = term__format(msg, _SLIT("1"), _SLIT("22"));
	// autofree_scope_vars(pos=2491 line_nr=111 scope.pos=2465 scope.end_pos=2522)
	// var "msg" var.pos=2470 var.line_nr=110
	// af parent scope:
	// af parent scope:
	return _t576;
}

string term__cyan(string msg) {
	 string _t577 = term__format(msg, _SLIT("36"), _SLIT("39"));
	// autofree_scope_vars(pos=2558 line_nr=115 scope.pos=2532 scope.end_pos=2590)
	// var "msg" var.pos=2537 var.line_nr=114
	// af parent scope:
	// af parent scope:
	return _t577;
}

string term__bright_cyan(string msg) {
	 string _t578 = term__format(msg, _SLIT("96"), _SLIT("39"));
	// autofree_scope_vars(pos=2633 line_nr=119 scope.pos=2600 scope.end_pos=2665)
	// var "msg" var.pos=2612 var.line_nr=118
	// af parent scope:
	// af parent scope:
	return _t578;
}

string term__dim(string msg) {
	 string _t579 = term__format(msg, _SLIT("2"), _SLIT("22"));
	// autofree_scope_vars(pos=2700 line_nr=123 scope.pos=2675 scope.end_pos=2731)
	// var "msg" var.pos=2679 var.line_nr=122
	// af parent scope:
	// af parent scope:
	return _t579;
}

string term__green(string msg) {
	 string _t580 = term__format(msg, _SLIT("32"), _SLIT("39"));
	// autofree_scope_vars(pos=2768 line_nr=127 scope.pos=2741 scope.end_pos=2800)
	// var "msg" var.pos=2747 var.line_nr=126
	// af parent scope:
	// af parent scope:
	return _t580;
}

string term__bright_green(string msg) {
	 string _t581 = term__format(msg, _SLIT("92"), _SLIT("39"));
	// autofree_scope_vars(pos=2844 line_nr=131 scope.pos=2810 scope.end_pos=2876)
	// var "msg" var.pos=2823 var.line_nr=130
	// af parent scope:
	// af parent scope:
	return _t581;
}

string term__gray(string msg) {
	 string _t582 = term__bright_black(msg);
	// autofree_scope_vars(pos=2912 line_nr=135 scope.pos=2886 scope.end_pos=2938)
	// var "msg" var.pos=2891 var.line_nr=134
	// af parent scope:
	// af parent scope:
	return _t582;
}

string term__hidden(string msg) {
	 string _t583 = term__format(msg, _SLIT("8"), _SLIT("28"));
	// autofree_scope_vars(pos=2976 line_nr=139 scope.pos=2948 scope.end_pos=3007)
	// var "msg" var.pos=2955 var.line_nr=138
	// af parent scope:
	// af parent scope:
	return _t583;
}

string term__italic(string msg) {
	 string _t584 = term__format(msg, _SLIT("3"), _SLIT("23"));
	// autofree_scope_vars(pos=3045 line_nr=143 scope.pos=3017 scope.end_pos=3076)
	// var "msg" var.pos=3024 var.line_nr=142
	// af parent scope:
	// af parent scope:
	return _t584;
}

string term__inverse(string msg) {
	 string _t585 = term__format(msg, _SLIT("7"), _SLIT("27"));
	// autofree_scope_vars(pos=3115 line_nr=147 scope.pos=3086 scope.end_pos=3146)
	// var "msg" var.pos=3094 var.line_nr=146
	// af parent scope:
	// af parent scope:
	return _t585;
}

string term__magenta(string msg) {
	 string _t586 = term__format(msg, _SLIT("35"), _SLIT("39"));
	// autofree_scope_vars(pos=3185 line_nr=151 scope.pos=3156 scope.end_pos=3217)
	// var "msg" var.pos=3164 var.line_nr=150
	// af parent scope:
	// af parent scope:
	return _t586;
}

string term__bright_magenta(string msg) {
	 string _t587 = term__format(msg, _SLIT("95"), _SLIT("39"));
	// autofree_scope_vars(pos=3263 line_nr=155 scope.pos=3227 scope.end_pos=3295)
	// var "msg" var.pos=3242 var.line_nr=154
	// af parent scope:
	// af parent scope:
	return _t587;
}

string term__reset(string msg) {
	 string _t588 = term__format(msg, _SLIT("0"), _SLIT("0"));
	// autofree_scope_vars(pos=3332 line_nr=159 scope.pos=3305 scope.end_pos=3362)
	// var "msg" var.pos=3311 var.line_nr=158
	// af parent scope:
	// af parent scope:
	return _t588;
}

string term__red(string msg) {
	 string _t589 = term__format(msg, _SLIT("31"), _SLIT("39"));
	// autofree_scope_vars(pos=3397 line_nr=163 scope.pos=3372 scope.end_pos=3429)
	// var "msg" var.pos=3376 var.line_nr=162
	// af parent scope:
	// af parent scope:
	return _t589;
}

string term__bright_red(string msg) {
	 string _t590 = term__format(msg, _SLIT("91"), _SLIT("39"));
	// autofree_scope_vars(pos=3471 line_nr=167 scope.pos=3439 scope.end_pos=3503)
	// var "msg" var.pos=3450 var.line_nr=166
	// af parent scope:
	// af parent scope:
	return _t590;
}

string term__strikethrough(string msg) {
	 string _t591 = term__format(msg, _SLIT("9"), _SLIT("29"));
	// autofree_scope_vars(pos=3548 line_nr=171 scope.pos=3513 scope.end_pos=3579)
	// var "msg" var.pos=3527 var.line_nr=170
	// af parent scope:
	// af parent scope:
	return _t591;
}

string term__underline(string msg) {
	 string _t592 = term__format(msg, _SLIT("4"), _SLIT("24"));
	// autofree_scope_vars(pos=3620 line_nr=175 scope.pos=3589 scope.end_pos=3651)
	// var "msg" var.pos=3599 var.line_nr=174
	// af parent scope:
	// af parent scope:
	return _t592;
}

string term__white(string msg) {
	 string _t593 = term__format(msg, _SLIT("37"), _SLIT("39"));
	// autofree_scope_vars(pos=3688 line_nr=179 scope.pos=3661 scope.end_pos=3720)
	// var "msg" var.pos=3667 var.line_nr=178
	// af parent scope:
	// af parent scope:
	return _t593;
}

string term__bright_white(string msg) {
	 string _t594 = term__format(msg, _SLIT("97"), _SLIT("39"));
	// autofree_scope_vars(pos=3764 line_nr=183 scope.pos=3730 scope.end_pos=3796)
	// var "msg" var.pos=3743 var.line_nr=182
	// af parent scope:
	// af parent scope:
	return _t594;
}

string term__yellow(string msg) {
	 string _t595 = term__format(msg, _SLIT("33"), _SLIT("39"));
	// autofree_scope_vars(pos=3834 line_nr=187 scope.pos=3806 scope.end_pos=3866)
	// var "msg" var.pos=3813 var.line_nr=186
	// af parent scope:
	// af parent scope:
	return _t595;
}

string term__bright_yellow(string msg) {
	 string _t596 = term__format(msg, _SLIT("93"), _SLIT("39"));
	// autofree_scope_vars(pos=3911 line_nr=191 scope.pos=3876 scope.end_pos=3943)
	// var "msg" var.pos=3890 var.line_nr=190
	// af parent scope:
	// af parent scope:
	return _t596;
}

void term__set_cursor_position(term__Coord c) {
	print(string_add(_STR("\x1b[%"PRId32"\000;%"PRId32"", 2, c.y, c.x), _SLIT("H")));
}

void term__move(int n, string direction) {
	print(_STR("\x1b[%"PRId32"\000%.*s", 2, n, direction));
}

void term__cursor_up(int n) {
	term__move(n, _SLIT("A"));
}

void term__cursor_down(int n) {
	term__move(n, _SLIT("B"));
}

void term__cursor_forward(int n) {
	term__move(n, _SLIT("C"));
}

void term__cursor_back(int n) {
	term__move(n, _SLIT("D"));
}

void term__erase_display(string t) {
	print(string_add(string_add(_SLIT("\x1b["), t), _SLIT("J")));
}

void term__erase_toend(void) {
	term__erase_display(_SLIT("0"));
}

void term__erase_tobeg(void) {
	term__erase_display(_SLIT("1"));
}

void term__erase_clear(void) {
	print(_SLIT("\033[H\033[J"));
}

void term__erase_del_clear(void) {
	term__erase_display(_SLIT("3"));
}

void term__erase_line(string t) {
	print(string_add(string_add(_SLIT("\x1b["), t), _SLIT("K")));
}

void term__erase_line_toend(void) {
	term__erase_line(_SLIT("0"));
}

void term__erase_line_tobeg(void) {
	term__erase_line(_SLIT("1"));
}

void term__erase_line_clear(void) {
	term__erase_line(_SLIT("2"));
}

void term__show_cursor(void) {
	print(_SLIT("\x1b[?25h"));
}

void term__hide_cursor(void) {
	print(_SLIT("\x1b[?25l"));
}

void term__clear_previous_line(void) {
	print(_SLIT("\r\x1b[1A\x1b[2K"));
}

bool term__can_show_color_on_stdout(void) {
	 bool _t597 = term__supports_escape_sequences(1);
	// autofree_scope_vars(pos=350 line_nr=19 scope.pos=316 scope.end_pos=387)
	// af parent scope:
	// af parent scope:
	return _t597;
}

bool term__can_show_color_on_stderr(void) {
	 bool _t598 = term__supports_escape_sequences(2);
	// autofree_scope_vars(pos=533 line_nr=25 scope.pos=499 scope.end_pos=570)
	// af parent scope:
	// af parent scope:
	return _t598;
}

string term__ok_message(string s) {
	if (term__can_show_color_on_stdout()) {
		 string _t599 = term__green(_STR(" %.*s\000 ", 2, s));
		// autofree_scope_vars(pos=755 line_nr=32 scope.pos=752 scope.end_pos=778)
		// af parent scope:
		// var "s" var.pos=702 var.line_nr=30
		// af parent scope:
		// af parent scope:
		return _t599;
	}
	// autofree_scope_vars(pos=780 line_nr=34 scope.pos=691 scope.end_pos=790)
	// var "s" var.pos=702 var.line_nr=30
	// af parent scope:
	// af parent scope:
	return s;
}

string term__fail_message(string s) {
	if (term__can_show_color_on_stdout()) {
		 string _t600 = term__inverse(term__bg_white(term__bold(term__red(_STR(" %.*s\000 ", 2, s)))));
		// autofree_scope_vars(pos=977 line_nr=41 scope.pos=974 scope.end_pos=1023)
		// af parent scope:
		// var "s" var.pos=924 var.line_nr=39
		// af parent scope:
		// af parent scope:
		return _t600;
	}
	// autofree_scope_vars(pos=1025 line_nr=43 scope.pos=911 scope.end_pos=1035)
	// var "s" var.pos=924 var.line_nr=39
	// af parent scope:
	// af parent scope:
	return s;
}

string term__warn_message(string s) {
	if (term__can_show_color_on_stdout()) {
		 string _t601 = term__bright_yellow(_STR(" %.*s\000 ", 2, s));
		// autofree_scope_vars(pos=1225 line_nr=50 scope.pos=1222 scope.end_pos=1256)
		// af parent scope:
		// var "s" var.pos=1172 var.line_nr=48
		// af parent scope:
		// af parent scope:
		return _t601;
	}
	// autofree_scope_vars(pos=1258 line_nr=52 scope.pos=1159 scope.end_pos=1268)
	// var "s" var.pos=1172 var.line_nr=48
	// af parent scope:
	// af parent scope:
	return s;
}

string term__colorize(string (*cfn)(string ), string s) {
	if (term__can_show_color_on_stdout()) {
		 string _t602 = cfn(s);
		// autofree_scope_vars(pos=1564 line_nr=60 scope.pos=1561 scope.end_pos=1580)
		// af parent scope:
		// var "cfn" var.pos=1487 var.line_nr=58
		// var "s" var.pos=1511 var.line_nr=58
		// af parent scope:
		// af parent scope:
		return _t602;
	}
	// autofree_scope_vars(pos=1582 line_nr=62 scope.pos=1478 scope.end_pos=1592)
	// var "cfn" var.pos=1487 var.line_nr=58
	// var "s" var.pos=1511 var.line_nr=58
	// af parent scope:
	// af parent scope:
	return s;
}

string term__h_divider(string divider) {
	multi_return_int_int mr_1840 = term__get_terminal_size();
	int cols = mr_1840.arg0;
	string result = _SLIT("");
	if (divider.len > 0) {
		result = string_repeat(divider, 1 + (cols / divider.len));
	} else {
		result = string_repeat(_SLIT(" "), 1 + cols);
	}
	 string _t603 = string_substr(result, 0, cols);
	// autofree_scope_vars(pos=2000 line_nr=76 scope.pos=1796 scope.end_pos=2024)
	// var "divider" var.pos=1806 var.line_nr=68
	// var "cols" var.pos=1832 var.line_nr=69
	// var "result" var.pos=1868 var.line_nr=70
	// str literal
	// af parent scope:
	// af parent scope:
	return _t603;
}

string term__header(string text, string divider) {
	if (text.len == 0) {
		 string _t604 = term__h_divider(divider);
		// autofree_scope_vars(pos=2253 line_nr=84 scope.pos=2250 scope.end_pos=2281)
		// af parent scope:
		// var "text" var.pos=2194 var.line_nr=82
		// var "divider" var.pos=2207 var.line_nr=82
		// var "xcols" var.pos=2284 var.line_nr=86
		// var "cols" var.pos=2317 var.line_nr=87
		// var "tlimit" var.pos=2341 var.line_nr=88
		// var "tlimit_alligned" var.pos=2457 var.line_nr=93
		// var "tstart" var.pos=2538 var.line_nr=94
		// var "ln" var.pos=2591 var.line_nr=95
		// af parent scope:
		// af parent scope:
		return _t604;
	}
	multi_return_int_int mr_2293 = term__get_terminal_size();
	int xcols = mr_2293.arg0;
	int cols = term__imax(1, xcols);
	int tlimit = term__imax(1, (cols > text.len + 2 + 2 * divider.len ? (text.len) : (cols - 3 - 2 * divider.len)));
	int tlimit_alligned = ((tlimit % 2) != (cols % 2) ? (tlimit + 1) : (tlimit));
	int tstart = term__imax(0, (cols - tlimit_alligned) / 2);
	string ln = _SLIT("");
	if (divider.len > 0) {
		ln = string_substr(string_repeat(divider, 1 + cols / divider.len), 0, cols);
	} else {
		ln = string_repeat(_SLIT(" "), 1 + cols);
	}
	if (ln.len == 1) {
		 string _t605 = string_add(string_add(string_add(string_add(ln, _SLIT(" ")), string_substr(text, 0, tlimit)), _SLIT(" ")), ln);
		// autofree_scope_vars(pos=2737 line_nr=102 scope.pos=2734 scope.end_pos=2784)
		// af parent scope:
		// var "text" var.pos=2194 var.line_nr=82
		// var "divider" var.pos=2207 var.line_nr=82
		// var "xcols" var.pos=2284 var.line_nr=86
		// var "cols" var.pos=2317 var.line_nr=87
		// var "tlimit" var.pos=2341 var.line_nr=88
		// var "tlimit_alligned" var.pos=2457 var.line_nr=93
		// var "tstart" var.pos=2538 var.line_nr=94
		// var "ln" var.pos=2591 var.line_nr=95
		// str literal
		// af parent scope:
		// af parent scope:
		return _t605;
	}
	 string _t606 = string_add(string_add(string_add(string_add(string_substr(ln, 0, tstart), _SLIT(" ")), string_substr(text, 0, tlimit)), _SLIT(" ")), string_substr(ln, tstart + tlimit + 2, cols));
	// autofree_scope_vars(pos=2786 line_nr=104 scope.pos=2187 scope.end_pos=2870)
	// var "text" var.pos=2194 var.line_nr=82
	// var "divider" var.pos=2207 var.line_nr=82
	// var "xcols" var.pos=2284 var.line_nr=86
	// var "cols" var.pos=2317 var.line_nr=87
	// var "tlimit" var.pos=2341 var.line_nr=88
	// var "tlimit_alligned" var.pos=2457 var.line_nr=93
	// var "tstart" var.pos=2538 var.line_nr=94
	// var "ln" var.pos=2591 var.line_nr=95
	// str literal
	// af parent scope:
	// af parent scope:
	return _t606;
}

VV_LOCAL_SYMBOL int term__imax(int x, int y) {
	 int _t607 = (x > y ? (x) : (y));
	// autofree_scope_vars(pos=2901 line_nr=108 scope.pos=2876 scope.end_pos=2935)
	// var "x" var.pos=2881 var.line_nr=107
	// var "y" var.pos=2888 var.line_nr=107
	// af parent scope:
	// af parent scope:
	return _t607;
}

VV_LOCAL_SYMBOL bool term__supports_escape_sequences(int fd) {
	string vcolors_override = os__getenv(_SLIT("VCOLORS"));
	if (string_eq(vcolors_override, _SLIT("always"))) {
		 bool _t608 = true;
		// autofree_scope_vars(pos=3060 line_nr=114 scope.pos=3057 scope.end_pos=3074)
		// af parent scope:
		// var "fd" var.pos=2967 var.line_nr=111
		// var "vcolors_override" var.pos=2983 var.line_nr=112
		// af parent scope:
		// af parent scope:
		return _t608;
	}
	if (string_eq(vcolors_override, _SLIT("never"))) {
		 bool _t609 = false;
		// autofree_scope_vars(pos=3111 line_nr=117 scope.pos=3108 scope.end_pos=3126)
		// af parent scope:
		// var "fd" var.pos=2967 var.line_nr=111
		// var "vcolors_override" var.pos=2983 var.line_nr=112
		// af parent scope:
		// af parent scope:
		return _t609;
	}
	if (string_eq(os__getenv(_SLIT("TERM")), _SLIT("dumb"))) {
		 bool _t610 = false;
		// autofree_scope_vars(pos=3163 line_nr=120 scope.pos=3160 scope.end_pos=3178)
		// af parent scope:
		// var "fd" var.pos=2967 var.line_nr=111
		// var "vcolors_override" var.pos=2983 var.line_nr=112
		// af parent scope:
		// af parent scope:
		return _t610;
	}
	#if defined(_WIN32)
	{
		if (string_eq(os__getenv(_SLIT("ConEmuANSI")), _SLIT("ON"))) {
			 bool _t611 = true;
			// autofree_scope_vars(pos=3236 line_nr=124 scope.pos=3232 scope.end_pos=3251)
			// af parent scope:
			// af parent scope:
			// var "fd" var.pos=2967 var.line_nr=111
			// var "vcolors_override" var.pos=2983 var.line_nr=112
			// af parent scope:
			// af parent scope:
			return _t611;
		}
		 bool _t612 = ((is_atty(fd) & 0x0004)) > 0;
		// autofree_scope_vars(pos=3299 line_nr=127 scope.pos=3193 scope.end_pos=3335)
		// af parent scope:
		// var "fd" var.pos=2967 var.line_nr=111
		// var "vcolors_override" var.pos=2983 var.line_nr=112
		// af parent scope:
		// af parent scope:
		return _t612;
	}
	#else
	{
	}
	#endif
	return 0;
}

multi_return_int_int term__get_terminal_size(void) {
	if (is_atty(1) > 0 && string_ne(os__getenv(_SLIT("TERM")), _SLIT("dumb"))) {
		CONSOLE_SCREEN_BUFFER_INFO info = (CONSOLE_SCREEN_BUFFER_INFO){.dwSize = {0},.dwCursorPosition = {0},.wAttributes = 0,.srWindow = {0},.dwMaximumWindowSize = {0},};
		if (GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &info)) {
			int columns = ((int)(info.srWindow.Right - info.srWindow.Left + 1));
			int rows = ((int)(info.srWindow.Bottom - info.srWindow.Top + 1));
			return (multi_return_int_int){.arg0=columns, .arg1=rows};
		}
	}
	return (multi_return_int_int){.arg0=_const_term__default_columns_size, .arg1=_const_term__default_rows_size};
}

term__Coord term__get_cursor_position(void) {
	term__Coord res = (term__Coord){.x = 0,.y = 0,};
	if (is_atty(1) > 0 && string_ne(os__getenv(_SLIT("TERM")), _SLIT("dumb"))) {
		CONSOLE_SCREEN_BUFFER_INFO info = (CONSOLE_SCREEN_BUFFER_INFO){.dwSize = {0},.dwCursorPosition = {0},.wAttributes = 0,.srWindow = {0},.dwMaximumWindowSize = {0},};
		if (GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &info)) {
			res.x = info.dwCursorPosition.X;
			res.y = info.dwCursorPosition.Y;
		}
	}
	// autofree_scope_vars(pos=2154 line_nr=80 scope.pos=1854 scope.end_pos=2166)
	// var "res" var.pos=1889 var.line_nr=72
	// af parent scope:
	// af parent scope:
	return res;
}

bool term__set_terminal_title(string title) {
	bool title_change = SetConsoleTitle(string_to_wide(title));
	// autofree_scope_vars(pos=2316 line_nr=86 scope.pos=2224 scope.end_pos=2337)
	// var "title" var.pos=2243 var.line_nr=84
	// var "title_change" var.pos=2265 var.line_nr=85
	// af parent scope:
	// af parent scope:
	return title_change;
}

void term__clear(void) {
	voidptr hconsole = GetStdHandle(STD_OUTPUT_HANDLE);
	CONSOLE_SCREEN_BUFFER_INFO csbi = (CONSOLE_SCREEN_BUFFER_INFO){.dwSize = {0},.dwCursorPosition = {0},.wAttributes = 0,.srWindow = {0},.dwMaximumWindowSize = {0},};
	SMALL_RECT scrollrect = (SMALL_RECT){.Left = 0,.Top = 0,.Right = 0,.Bottom = 0,};
	COORD scrolltarget = (COORD){.X = 0,.Y = 0,};
	CHAR_INFO fill = (CHAR_INFO){.Char = {0},.Attributes = 0,};
	if (!GetConsoleScreenBufferInfo(hconsole, &csbi)) {
		return;
	}
	scrollrect.Left = 0;
	scrollrect.Top = 0;
	scrollrect.Right = ((u16)(csbi.dwSize.X));
	scrollrect.Bottom = ((u16)(csbi.dwSize.Y));
	scrolltarget.X = 0;
	scrolltarget.Y = (0 - csbi.dwSize.Y);
	fill.Char.UnicodeChar = ((rune)(L' '));
	fill.Attributes = csbi.wAttributes;
	ScrollConsoleScreenBuffer(hconsole, &scrollrect, NULL, scrolltarget, &fill);
	csbi.dwCursorPosition.X = 0;
	csbi.dwCursorPosition.Y = 0;
	SetConsoleCursorPosition(hconsole, csbi.dwCursorPosition);
}

Option_v__vmod__Manifest v__vmod__from_file(string vmod_path) {
	if (!os__exists(vmod_path)) {
		return (Option_v__vmod__Manifest){ .state=2, .err=v_error(_SLIT("v.mod: v.mod file not found.")) };
	}
	Option_string _t613 = os__read_file(vmod_path);
	if (_t613.state != 0) { /*or block*/ 
		IError err = _t613.err;
		v_panic(_SLIT("v.mod: cannot parse v.mod"));
	}
 	string contents =  *(string*)_t613.data;
	 Option_v__vmod__Manifest _t614 = v__vmod__decode(contents);
	// autofree_scope_vars(pos=763 line_nr=55 scope.pos=566 scope.end_pos=788)
	// var "vmod_path" var.pos=576 var.line_nr=50
	// var "contents" var.pos=685 var.line_nr=54
	// af parent scope:
	// af parent scope:
	return _t614;
}

Option_v__vmod__Manifest v__vmod__decode(string contents) {
	v__vmod__Parser parser = (v__vmod__Parser){.file_path = (string){.str=(byteptr)"", .is_lit=1},.scanner = (v__vmod__Scanner){.pos = 0,.text = contents,.inside_text = 0,.tokens = __new_array(0, 1, sizeof(v__vmod__Token)),},};
	 Option_v__vmod__Manifest _t615 = v__vmod__Parser_parse(&parser);
	// autofree_scope_vars(pos=912 line_nr=65 scope.pos=798 scope.end_pos=935)
	// var "contents" var.pos=805 var.line_nr=58
	// var "parser" var.pos=839 var.line_nr=59
	// af parent scope:
	// af parent scope:
	return _t615;
}

VV_LOCAL_SYMBOL void v__vmod__Scanner_tokenize(v__vmod__Scanner* s, v__vmod__TokenKind t_type, string val) {
	array_push(&s->tokens, _MOV((v__vmod__Token[]){ (v__vmod__Token){.typ = t_type,.val = val,} }));
}

VV_LOCAL_SYMBOL void v__vmod__Scanner_skip_whitespace(v__vmod__Scanner* s) {
	for (;;) {
		if (!(s->pos < s->text.len && byte_is_space(string_at(s->text, s->pos)))) break;
		s->pos++;
	}
}

VV_LOCAL_SYMBOL bool v__vmod__is_name_alpha(byte chr) {
	 bool _t617 = byte_is_letter(chr) || chr == L'_';
	// autofree_scope_vars(pos=1176 line_nr=79 scope.pos=1145 scope.end_pos=1214)
	// var "chr" var.pos=1159 var.line_nr=78
	// af parent scope:
	// af parent scope:
	return _t617;
}

VV_LOCAL_SYMBOL string v__vmod__Scanner_create_string(v__vmod__Scanner* s, byte q) {
	string str = _SLIT("");
	for (;;) {
		if (!(string_at(s->text, s->pos) != q)) break;
		if (string_at(s->text, s->pos) == L'\\' && string_at(s->text, s->pos + 1) == q) {
			str = /*f*/string_add(str, string_substr(s->text, s->pos, s->pos + 1));
			s->pos += 2;
		} else {
			str = /*f*/string_add(str, byte_ascii_str(string_at(s->text, s->pos)));
			s->pos++;
		}
	}
	// autofree_scope_vars(pos=1477 line_nr=93 scope.pos=1220 scope.end_pos=1489)
	// var "s" var.pos=1225 var.line_nr=82
	// var "q" var.pos=1250 var.line_nr=82
	// var "str" var.pos=1272 var.line_nr=83
	// str literal
	// af parent scope:
	// af parent scope:
	return str;
}

VV_LOCAL_SYMBOL string v__vmod__Scanner_create_ident(v__vmod__Scanner* s) {
	string text = _SLIT("");
	for (;;) {
		if (!(v__vmod__is_name_alpha(string_at(s->text, s->pos)))) break;
		text = /*f*/string_add(text, byte_ascii_str(string_at(s->text, s->pos)));
		s->pos++;
	}
	// autofree_scope_vars(pos=1636 line_nr=102 scope.pos=1495 scope.end_pos=1649)
	// var "s" var.pos=1500 var.line_nr=96
	// var "text" var.pos=1540 var.line_nr=97
	// str literal
	// af parent scope:
	// af parent scope:
	return text;
}

VV_LOCAL_SYMBOL bool v__vmod__Scanner_peek_char(v__vmod__Scanner s, byte c) {
	 bool _t618 = s.pos - 1 < s.text.len && string_at(s.text, s.pos - 1) == c;
	// autofree_scope_vars(pos=1692 line_nr=106 scope.pos=1655 scope.end_pos=1749)
	// var "s" var.pos=1656 var.line_nr=105
	// var "c" var.pos=1677 var.line_nr=105
	// af parent scope:
	// af parent scope:
	return _t618;
}

VV_LOCAL_SYMBOL void v__vmod__Scanner_scan_all(v__vmod__Scanner* s) {
	for (;;) {
		if (!(s->pos < s->text.len)) break;
		byte c = string_at(s->text, s->pos);
		if (byte_is_space(c) || c == L'\\') {
			s->pos++;
			continue;
		}
		if (v__vmod__is_name_alpha(c)) {
			string name = v__vmod__Scanner_create_ident(s);
			if (string_eq(name, _SLIT("Module"))) {
				v__vmod__Scanner_tokenize(s, v__vmod__TokenKind_module_keyword, name);
				s->pos++;
				continue;
			} else if (string_at(s->text, s->pos) == L':') {
				v__vmod__Scanner_tokenize(s, v__vmod__TokenKind_field_key, string_add(name, _SLIT(":")));
				s->pos += 2;
				continue;
			} else {
				v__vmod__Scanner_tokenize(s, v__vmod__TokenKind_ident, name);
				s->pos++;
				continue;
			}
		}
		if ((c == L'\'' || c == L'\"') && !v__vmod__Scanner_peek_char(/*rec*/*s, L'\\')) {
			s->pos++;
			string str = v__vmod__Scanner_create_string(s, c);
			v__vmod__Scanner_tokenize(s, v__vmod__TokenKind_str, str);
			s->pos++;
			continue;
		}

		if (c == (L'{')) {
			v__vmod__Scanner_tokenize(s, v__vmod__TokenKind_lcbr, byte_ascii_str(c));
		}
		else if (c == (L'}')) {
			v__vmod__Scanner_tokenize(s, v__vmod__TokenKind_rcbr, byte_ascii_str(c));
		}
		else if (c == (L'[')) {
			v__vmod__Scanner_tokenize(s, v__vmod__TokenKind_labr, byte_ascii_str(c));
		}
		else if (c == (L']')) {
			v__vmod__Scanner_tokenize(s, v__vmod__TokenKind_rabr, byte_ascii_str(c));
		}
		else if (c == (L':')) {
			v__vmod__Scanner_tokenize(s, v__vmod__TokenKind_colon, byte_ascii_str(c));
		}
		else if (c == (L',')) {
			v__vmod__Scanner_tokenize(s, v__vmod__TokenKind_comma, byte_ascii_str(c));
		}
		else {
			v__vmod__Scanner_tokenize(s, v__vmod__TokenKind_unknown, byte_ascii_str(c));
		};
		s->pos++;
	}
	v__vmod__Scanner_tokenize(s, v__vmod__TokenKind_eof, _SLIT("eof"));
}

VV_LOCAL_SYMBOL Option_multi_return_Array_string_int v__vmod__get_array_content(Array_v__vmod__Token tokens, int st_idx) {
	Array_string vals = __new_array_with_default(0, 0, sizeof(string), 0);
	int idx = st_idx;
	if ((*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, idx)).typ != v__vmod__TokenKind_labr) {
		return (Option_multi_return_Array_string_int){ .state=2, .err=v_error(_SLIT("vmod: not a valid array")) };
	}
	idx++;
	for (;;) {
		v__vmod__Token tok = (*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, idx));

		if (tok.typ == (v__vmod__TokenKind_str)) {
			array_push(&vals, _MOV((string[]){ string_clone(tok.val) }));
			if (!((*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, idx + 1)).typ == v__vmod__TokenKind_comma || (*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, idx + 1)).typ == v__vmod__TokenKind_rabr)) {
				return (Option_multi_return_Array_string_int){ .state=2, .err=v_error(_STR("vmod: invalid separator \"%.*s\000\"", 2, (*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, idx + 1)).val)) };
			}
			idx += ((*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, idx + 1)).typ == v__vmod__TokenKind_comma ? (2) : (1));
		}
		else if (tok.typ == (v__vmod__TokenKind_rabr)) {
			idx++;
			break;
		}
		else {
			return (Option_multi_return_Array_string_int){ .state=2, .err=v_error(_STR("vmod: invalid token \"%.*s\000\"", 2, tok.val)) };
		};
	}
	Option_multi_return_Array_string_int _t620;
	opt_ok(&(multi_return_Array_string_int/*X*/[]) { (multi_return_Array_string_int){.arg0=vals, .arg1=idx} }, (Option*)(&_t620), sizeof(multi_return_Array_string_int));
	return _t620;
}

VV_LOCAL_SYMBOL Option_v__vmod__Manifest v__vmod__Parser_parse(v__vmod__Parser* p) {
	string err_label = _SLIT("vmod:");
	if (p->scanner.text.len == 0) {
		return (Option_v__vmod__Manifest){ .state=2, .err=v_error(_STR("%.*s\000 no content.", 2, err_label)) };
	}
	v__vmod__Scanner_scan_all(&p->scanner);
	Array_v__vmod__Token tokens = p->scanner.tokens;
	v__vmod__Manifest mn = (v__vmod__Manifest){.name = (string){.str=(byteptr)"", .is_lit=1},.version = (string){.str=(byteptr)"", .is_lit=1},.description = (string){.str=(byteptr)"", .is_lit=1},.dependencies = __new_array(0, 1, sizeof(string)),.license = (string){.str=(byteptr)"", .is_lit=1},.repo_url = (string){.str=(byteptr)"", .is_lit=1},.author = (string){.str=(byteptr)"", .is_lit=1},.unknown = new_map(sizeof(string), sizeof(Array_string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),};
	if ((*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, 0)).typ != v__vmod__TokenKind_module_keyword) {
		v_panic(_SLIT("not a valid v.mod"));
	}
	int i = 1;
	for (;;) {
		if (!(i < tokens.len)) break;
		v__vmod__Token tok = (*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, i));

		if (tok.typ == (v__vmod__TokenKind_lcbr)) {
			if (!((*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, i + 1)).typ == v__vmod__TokenKind_field_key || (*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, i + 1)).typ == v__vmod__TokenKind_rcbr)) {
				return (Option_v__vmod__Manifest){ .state=2, .err=v_error(_STR("%.*s\000 invalid content after opening brace", 2, err_label)) };
			}
			i++;
			continue;
		}
		else if (tok.typ == (v__vmod__TokenKind_rcbr)) {
			break;
		}
		else if (tok.typ == (v__vmod__TokenKind_field_key)) {
			string field_name = string_trim_right(tok.val, _SLIT(":"));
			if (!((*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, i + 1)).typ == v__vmod__TokenKind_str || (*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, i + 1)).typ == v__vmod__TokenKind_labr)) {
				return (Option_v__vmod__Manifest){ .state=2, .err=v_error(_STR("%.*s\000 value of field \"%.*s\000\" must be either string or an array of strings", 3, err_label, field_name)) };
			}
			string field_value = (*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, i + 1)).val;

			if (string_eq(field_name, _SLIT("name"))) {
				mn.name = field_value;
			}
			else if (string_eq(field_name, _SLIT("version"))) {
				mn.version = field_value;
			}
			else if (string_eq(field_name, _SLIT("license"))) {
				mn.license = field_value;
			}
			else if (string_eq(field_name, _SLIT("repo_url"))) {
				mn.repo_url = field_value;
			}
			else if (string_eq(field_name, _SLIT("description"))) {
				mn.description = field_value;
			}
			else if (string_eq(field_name, _SLIT("author"))) {
				mn.author = field_value;
			}
			else if (string_eq(field_name, _SLIT("dependencies"))) {
				Option_multi_return_Array_string_int _t621 = v__vmod__get_array_content(tokens, i + 1);
				if (_t621.state != 0) { /*or block*/ 
					Option_v__vmod__Manifest _t622;
					memcpy(&_t622, &_t621, sizeof(Option));
					return _t622;
				}
 				Option_multi_return_Array_string_int mr_4491 =  _t621 /*U*/;
				Array_string deps = (*(multi_return_Array_string_int*)mr_4491.data).arg0;
				int idx = (*(multi_return_Array_string_int*)mr_4491.data).arg1;
				mn.dependencies = deps;
				i = idx;
				continue;
			}
			else {
				if ((*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, i + 1)).typ == v__vmod__TokenKind_labr) {
					Option_multi_return_Array_string_int _t623 = v__vmod__get_array_content(tokens, i + 1);
					if (_t623.state != 0) { /*or block*/ 
						Option_v__vmod__Manifest _t624;
						memcpy(&_t624, &_t623, sizeof(Option));
						return _t624;
					}
 					Option_multi_return_Array_string_int mr_4661 =  _t623 /*U*/;
					Array_string vals = (*(multi_return_Array_string_int*)mr_4661.data).arg0;
					int idx = (*(multi_return_Array_string_int*)mr_4661.data).arg1;
					map_set(&mn.unknown, &(string[]){field_name}, &(Array_string[]) { vals });
					i = idx;
					continue;
				}
				map_set(&mn.unknown, &(string[]){field_name}, &(Array_string[]) { new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){field_value})) });
			};
			i += 2;
			continue;
		}
		else if (tok.typ == (v__vmod__TokenKind_comma)) {
			if (!((*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, i - 1)).typ == v__vmod__TokenKind_str || (*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, i - 1)).typ == v__vmod__TokenKind_rabr) || (*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, i + 1)).typ != v__vmod__TokenKind_field_key) {
				return (Option_v__vmod__Manifest){ .state=2, .err=v_error(_STR("%.*s\000 invalid comma placement", 2, err_label)) };
			}
			i++;
			continue;
		}
		else {
			return (Option_v__vmod__Manifest){ .state=2, .err=v_error(_STR("%.*s\000 invalid token \"%.*s\000\"", 3, err_label, tok.val)) };
		};
	}
	Option_v__vmod__Manifest _t625;
	opt_ok(&(v__vmod__Manifest[]) { mn }, (Option*)(&_t625), sizeof(v__vmod__Manifest));
	// autofree_scope_vars(pos=5120 line_nr=263 scope.pos=3313 scope.end_pos=5131)
	// var "p" var.pos=3318 var.line_nr=182
	// var "err_label" var.pos=3349 var.line_nr=183
	// str literal
	// var "tokens" var.pos=3467 var.line_nr=188
	// var "mn" var.pos=3499 var.line_nr=189
	// var "i" var.pos=3592 var.line_nr=193
	// af parent scope:
	// af parent scope:
	return _t625;
}

v__vmod__ModFileCacher* v__vmod__new_mod_file_cacher(void) {
	 v__vmod__ModFileCacher* _t626 = (v__vmod__ModFileCacher*)memdup(&(v__vmod__ModFileCacher){.cache = new_map(sizeof(string), sizeof(v__vmod__ModFileAndFolder), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.folder_files = new_map(sizeof(string), sizeof(Array_string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),}, sizeof(v__vmod__ModFileCacher));
	// autofree_scope_vars(pos=1394 line_nr=41 scope.pos=1355 scope.end_pos=1419)
	// af parent scope:
	// af parent scope:
	return _t626;
}

void v__vmod__ModFileCacher_debug(v__vmod__ModFileCacher* mcache) {
}

v__vmod__ModFileAndFolder v__vmod__ModFileCacher_get_by_file(v__vmod__ModFileCacher* mcache, string vfile) {
	 v__vmod__ModFileAndFolder _t627 = v__vmod__ModFileCacher_get_by_folder(mcache, os__dir(vfile));
	// autofree_scope_vars(pos=1875 line_nr=59 scope.pos=1803 scope.end_pos=1919)
	// var "mcache" var.pos=1808 var.line_nr=58
	// var "vfile" var.pos=1842 var.line_nr=58
	// af parent scope:
	// af parent scope:
	return _t627;
}

v__vmod__ModFileAndFolder v__vmod__ModFileCacher_get_by_folder(v__vmod__ModFileCacher* mcache, string vfolder) {
	string mfolder = os__real_path(vfolder);
	if (_IN_MAP(ADDR(string, mfolder), ADDR(map, mcache->cache))) {
		 v__vmod__ModFileAndFolder _t628 = (*(v__vmod__ModFileAndFolder*)map_get(ADDR(map, mcache->cache), &(string[]){mfolder}, &(v__vmod__ModFileAndFolder[]){ {0} }));
		// autofree_scope_vars(pos=2070 line_nr=65 scope.pos=2067 scope.end_pos=2101)
		// af parent scope:
		// var "mcache" var.pos=1934 var.line_nr=62
		// var "vfolder" var.pos=1970 var.line_nr=62
		// var "mfolder" var.pos=2006 var.line_nr=63
		// var "traversed_folders" var.pos=2104 var.line_nr=67
		// var "res" var.pos=2123 var.line_nr=67
		// af parent scope:
		// af parent scope:
		return _t628;
	}
	multi_return_Array_string_v__vmod__ModFileAndFolder mr_2127 = v__vmod__ModFileCacher_traverse(mcache, mfolder);
	Array_string traversed_folders = mr_2127.arg0;
	v__vmod__ModFileAndFolder res = mr_2127.arg1;
	// FOR IN array
	for (int _t629 = 0; _t629 < traversed_folders.len; ++_t629) {
		string tfolder = ((string*)traversed_folders.data)[_t629];
		v__vmod__ModFileCacher_add(mcache, tfolder, res);
	}
	// autofree_scope_vars(pos=2221 line_nr=71 scope.pos=1929 scope.end_pos=2233)
	// var "mcache" var.pos=1934 var.line_nr=62
	// var "vfolder" var.pos=1970 var.line_nr=62
	// var "mfolder" var.pos=2006 var.line_nr=63
	// var "traversed_folders" var.pos=2104 var.line_nr=67
	// var "res" var.pos=2123 var.line_nr=67
	// af parent scope:
	// af parent scope:
	return res;
}

VV_LOCAL_SYMBOL void v__vmod__ModFileCacher_add(v__vmod__ModFileCacher* cacher, string path, v__vmod__ModFileAndFolder result) {
	(*(v__vmod__ModFileAndFolder*)map_get_and_set(&cacher->cache, &(string[]){path}, &(v__vmod__ModFileAndFolder[]){ {0} })) = result;
}

VV_LOCAL_SYMBOL multi_return_Array_string_v__vmod__ModFileAndFolder v__vmod__ModFileCacher_traverse(v__vmod__ModFileCacher* mcache, string mfolder) {
	string cfolder = mfolder;
	Array_string folders_so_far = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){cfolder}));
	int levels = 0;
	for (;;) {
		if (levels > 255) {
			break;
		}
		if (string_eq(cfolder, _SLIT("/")) || (cfolder).len == 0) {
			break;
		}
		if (_IN_MAP(ADDR(string, cfolder), ADDR(map, mcache->cache))) {
			v__vmod__ModFileAndFolder res = (*(v__vmod__ModFileAndFolder*)map_get(ADDR(map, mcache->cache), &(string[]){cfolder}, &(v__vmod__ModFileAndFolder[]){ {0} }));
			if (res.vmod_file.len == 0) {
				v__vmod__ModFileCacher_mark_folders_as_vmod_free(mcache, folders_so_far);
			} else {
				v__vmod__ModFileCacher_mark_folders_with_vmod(mcache, folders_so_far, res);
			}
			return (multi_return_Array_string_v__vmod__ModFileAndFolder){.arg0=__new_array_with_default(0, 0, sizeof(string), 0), .arg1=res};
		}
		Array_string files = v__vmod__ModFileCacher_get_files(mcache, cfolder);
		if ((Array_string_contains(files, _SLIT("v.mod")))) {
			v__vmod__ModFileAndFolder res = (v__vmod__ModFileAndFolder){.vmod_file = os__join_path(cfolder, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("v.mod")}))),.vmod_folder = cfolder,};
			return (multi_return_Array_string_v__vmod__ModFileAndFolder){.arg0=folders_so_far, .arg1=res};
		}
		if (v__vmod__ModFileCacher_check_for_stop(mcache, cfolder, files)) {
			break;
		}
		cfolder = os__dir(cfolder);
		array_push(&folders_so_far, _MOV((string[]){ string_clone(cfolder) }));
		levels++;
	}
	v__vmod__ModFileCacher_mark_folders_as_vmod_free(mcache, folders_so_far);
	return (multi_return_Array_string_v__vmod__ModFileAndFolder){.arg0=new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){mfolder})), .arg1=(v__vmod__ModFileAndFolder){.vmod_file = _SLIT(""),.vmod_folder = mfolder,}};
}

VV_LOCAL_SYMBOL void v__vmod__ModFileCacher_mark_folders_with_vmod(v__vmod__ModFileCacher* mcache, Array_string folders_so_far, v__vmod__ModFileAndFolder vmod) {
	// FOR IN array
	for (int _t631 = 0; _t631 < folders_so_far.len; ++_t631) {
		string f = ((string*)folders_so_far.data)[_t631];
		v__vmod__ModFileCacher_add(mcache, f, vmod);
	}
}

VV_LOCAL_SYMBOL void v__vmod__ModFileCacher_mark_folders_as_vmod_free(v__vmod__ModFileCacher* mcache, Array_string folders_so_far) {
	// FOR IN array
	for (int _t632 = 0; _t632 < folders_so_far.len; ++_t632) {
		string f = ((string*)folders_so_far.data)[_t632];
		v__vmod__ModFileCacher_add(mcache, f, (v__vmod__ModFileAndFolder){.vmod_file = _SLIT(""),.vmod_folder = f,});
	}
}

VV_LOCAL_SYMBOL bool v__vmod__ModFileCacher_check_for_stop(v__vmod__ModFileCacher* mcache, string cfolder, Array_string files) {
	// FOR IN array
	for (int _t633 = 0; _t633 < _const_v__vmod__mod_file_stop_paths.len; ++_t633) {
		string i = ((string*)_const_v__vmod__mod_file_stop_paths.data)[_t633];
		if ((Array_string_contains(files, i))) {
			 bool _t634 = true;
			// autofree_scope_vars(pos=4042 line_nr=143 scope.pos=4038 scope.end_pos=4057)
			// af parent scope:
			// var "i" var.pos=3990 var.line_nr=141
			// skipping tmp var "i"
			// af parent scope:
			// var "mcache" var.pos=3908 var.line_nr=140
			// var "cfolder" var.pos=3946 var.line_nr=140
			// var "files" var.pos=3962 var.line_nr=140
			// af parent scope:
			// af parent scope:
			return _t634;
		}
	}
	 bool _t635 = false;
	// autofree_scope_vars(pos=4062 line_nr=146 scope.pos=3907 scope.end_pos=4076)
	// var "mcache" var.pos=3908 var.line_nr=140
	// var "cfolder" var.pos=3946 var.line_nr=140
	// var "files" var.pos=3962 var.line_nr=140
	// af parent scope:
	// af parent scope:
	return _t635;
}

VV_LOCAL_SYMBOL Array_string v__vmod__ModFileCacher_get_files(v__vmod__ModFileCacher* mcache, string cfolder) {
	if (_IN_MAP(ADDR(string, cfolder), ADDR(map, mcache->folder_files))) {
		 Array_string _t636 = (*(Array_string*)map_get(ADDR(map, mcache->folder_files), &(string[]){cfolder}, &(Array_string[]){ __new_array(0, 1, sizeof(string)) }));
		// autofree_scope_vars(pos=4184 line_nr=151 scope.pos=4181 scope.end_pos=4222)
		// af parent scope:
		// var "mcache" var.pos=4087 var.line_nr=149
		// var "cfolder" var.pos=4119 var.line_nr=149
		// var "files" var.pos=4229 var.line_nr=153
		// af parent scope:
		// af parent scope:
		return _t636;
	}
	Array_string files = __new_array_with_default(0, 0, sizeof(string), 0);
	if (os__exists(cfolder) && os__is_dir(cfolder)) {
		Option_Array_string _t637;
		if (_t637 = os__ls(cfolder), _t637.state == 0) {
			Array_string listing = *(Array_string*)_t637.data;
			files = array_clone(&listing);
		}
	}
	map_set(&mcache->folder_files, &(string[]){cfolder}, &(Array_string[]) { files });
	// autofree_scope_vars(pos=4401 line_nr=160 scope.pos=4082 scope.end_pos=4415)
	// var "mcache" var.pos=4087 var.line_nr=149
	// var "cfolder" var.pos=4119 var.line_nr=149
	// var "files" var.pos=4229 var.line_nr=153
	// af parent scope:
	// af parent scope:
	return files;
}

v__vmod__ModFileCacher* v__vmod__get_cache(void) {
	// autofree_scope_vars(pos=4560 line_nr=169 scope.pos=4531 scope.end_pos=4593)
	// af parent scope:
	// af parent scope:
	return _const_v__vmod__private_file_cacher;
}

string v__util__recompilation__disabling_file(string vroot) {
	string tools_folder = os__join_path(vroot, new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT("cmd"), _SLIT("tools")})));
	string res = os__join_path(tools_folder, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT(".disable_autorecompilation")})));
	// autofree_scope_vars(pos=616 line_nr=12 scope.pos=460 scope.end_pos=628)
	// var "vroot" var.pos=475 var.line_nr=9
	// var "tools_folder" var.pos=499 var.line_nr=10
	// var "res" var.pos=552 var.line_nr=11
	// af parent scope:
	// af parent scope:
	return res;
}

void v__util__recompilation__must_be_enabled(string vroot, string error_message) {
	string file = v__util__recompilation__disabling_file(vroot);
	bool is_recompilation_disabled = os__exists(file);
	if (is_recompilation_disabled) {
		eprintln(_STR("Recompilation is disabled, since there is a \"%.*s\000\" file present.", 2, file));
		eprintln(error_message);
		v_exit(1);
	}
}

string v__cflag__CFlag_str(v__cflag__CFlag* c) {
	 string _t638 = _STR("CFlag{ name: \"%.*s\000\" value: \"%.*s\000\" mod: \"%.*s\000\" os: \"%.*s\000\" cached: \"%.*s\000\" }", 6, c->name, c->value, c->mod, c->os, c->cached);
	// autofree_scope_vars(pos=526 line_nr=19 scope.pos=500 scope.end_pos=625)
	// var "c" var.pos=501 var.line_nr=18
	// af parent scope:
	// af parent scope:
	return _t638;
}

string v__cflag__CFlag_eval(v__cflag__CFlag* cf) {
	string value = _SLIT("");
	cflag_eval_outer_loop:
	for (int i = 0; i < cf->value.len; i++) {
		byte x = string_at(cf->value, i);
		if (x == L'$') {
			string remainder = string_substr(cf->value, i, cf->value.len);
			if (string_starts_with(remainder, _const_v__cflag__fexisting_literal)) {
				string sparams = string_all_before(string_substr(remainder, _const_v__cflag__fexisting_literal.len + 1, remainder.len), _SLIT(")"));
				i += sparams.len + _const_v__cflag__fexisting_literal.len + 1;
				Array_string _t639_orig = string_split_into_lines(string_replace(sparams, _SLIT(","), _SLIT("\n")));
				int _t639_len = _t639_orig.len;
				Array_string _t639 = __new_array(0, _t639_len, sizeof(string));

				for (int _t640 = 0; _t640 < _t639_len; ++_t640) {
					string it = ((string*) _t639_orig.data)[_t640];
					string ti = string_trim(it, _SLIT(" \'\""));
					array_push(&_t639, &ti);
				}
				
				Array_string svalues = _t639;
				string found_spath = _SLIT("");
				// FOR IN array
				for (int _t641 = 0; _t641 < svalues.len; ++_t641) {
					string spath = ((string*)svalues.data)[_t641];
					if (os__exists(spath)) {
						found_spath = spath;
						value = /*f*/string_add(value, spath);
						goto cflag_eval_outer_loop__continue;
					}
				}
				v_panic(_STR(">> error: none of the paths %.*s\000 exist", 2, Array_string_str(svalues)));
				continue;
			}
		}
		value = /*f*/string_add(value, byte_ascii_str(x));
	cflag_eval_outer_loop__continue: {}
	}
	cflag_eval_outer_loop__break: {}
	// autofree_scope_vars(pos=1427 line_nr=49 scope.pos=706 scope.end_pos=1441)
	// var "cf" var.pos=707 var.line_nr=25
	// var "value" var.pos=739 var.line_nr=26
	// str literal
	// af parent scope:
	// af parent scope:
	return value;
}

string v__cflag__CFlag_format(v__cflag__CFlag* cf) {
	string value = _SLIT("");
	if ((cf->cached).len != 0) {
		value = cf->cached;
	} else {
		value = v__cflag__CFlag_eval(cf);
	}
	if ((string_eq(cf->name, _SLIT("-l")) || string_eq(cf->name, _SLIT("-Wa")) || string_eq(cf->name, _SLIT("-Wl")) || string_eq(cf->name, _SLIT("-Wp"))) && value.len > 0) {
		 string _t642 = string_trim_space(_STR("%.*s\000%.*s", 2, cf->name, value));
		// autofree_scope_vars(pos=1651 line_nr=61 scope.pos=1648 scope.end_pos=1690)
		// af parent scope:
		// var "cf" var.pos=1467 var.line_nr=53
		// var "value" var.pos=1501 var.line_nr=54
		// str literal
		// af parent scope:
		// af parent scope:
		return _t642;
	}
	if (string_eq(cf->name, _SLIT("-I")) || string_eq(cf->name, _SLIT("-L")) || string_ends_with(value, _SLIT(".o"))) {
		value = string_add(string_add(_SLIT("\""), os__real_path(value)), _SLIT("\""));
	}
	 string _t643 = string_trim_space(_STR("%.*s\000 %.*s", 2, cf->name, value));
	// autofree_scope_vars(pos=1832 line_nr=67 scope.pos=1466 scope.end_pos=1871)
	// var "cf" var.pos=1467 var.line_nr=53
	// var "value" var.pos=1501 var.line_nr=54
	// str literal
	// af parent scope:
	// af parent scope:
	return _t643;
}

Array_string Array_v__cflag__CFlag_c_options_before_target_msvc(Array_v__cflag__CFlag cflags) {
	 Array_string _t644 = __new_array_with_default(0, 0, sizeof(string), 0);
	// autofree_scope_vars(pos=2028 line_nr=72 scope.pos=1969 scope.end_pos=2039)
	// var "cflags" var.pos=1970 var.line_nr=71
	// af parent scope:
	// af parent scope:
	return _t644;
}

Array_string Array_v__cflag__CFlag_c_options_after_target_msvc(Array_v__cflag__CFlag cflags) {
	 Array_string _t645 = __new_array_with_default(0, 0, sizeof(string), 0);
	// autofree_scope_vars(pos=2107 line_nr=76 scope.pos=2049 scope.end_pos=2118)
	// var "cflags" var.pos=2050 var.line_nr=75
	// af parent scope:
	// af parent scope:
	return _t645;
}

Array_string Array_v__cflag__CFlag_c_options_before_target(Array_v__cflag__CFlag cflags) {
	multi_return_Array_string_Array_string_Array_string mr_2202 = Array_v__cflag__CFlag_defines_others_libs(cflags);
	Array_string defines = mr_2202.arg0;
	Array_string others = mr_2202.arg1;
	Array_string args = __new_array_with_default(0, 0, sizeof(string), 0);
	_PUSH_MANY(&args, (defines), _t646, Array_string);
	_PUSH_MANY(&args, (others), _t647, Array_string);
	// autofree_scope_vars(pos=2291 line_nr=84 scope.pos=2128 scope.end_pos=2304)
	// var "cflags" var.pos=2129 var.line_nr=79
	// var "defines" var.pos=2183 var.line_nr=80
	// var "others" var.pos=2192 var.line_nr=80
	// var "args" var.pos=2239 var.line_nr=81
	// af parent scope:
	// af parent scope:
	return args;
}

Array_string Array_v__cflag__CFlag_c_options_after_target(Array_v__cflag__CFlag cflags) {
	multi_return_Array_string_Array_string_Array_string mr_2379 = Array_v__cflag__CFlag_defines_others_libs(cflags);
	Array_string libs = mr_2379.arg2;
	// autofree_scope_vars(pos=2411 line_nr=89 scope.pos=2314 scope.end_pos=2424)
	// var "cflags" var.pos=2315 var.line_nr=87
	// var "libs" var.pos=2374 var.line_nr=88
	// af parent scope:
	// af parent scope:
	return libs;
}

Array_string Array_v__cflag__CFlag_c_options_without_object_files(Array_v__cflag__CFlag cflags) {
	Array_string args = __new_array_with_default(0, 0, sizeof(string), 0);
	// FOR IN array
	for (int _t648 = 0; _t648 < cflags.len; ++_t648) {
		v__cflag__CFlag flag = ((v__cflag__CFlag*)cflags.data)[_t648];
		if (string_ends_with(flag.value, _SLIT(".o")) || string_ends_with(flag.value, _SLIT(".obj"))) {
			continue;
		}
		array_push(&args, _MOV((string[]){ string_clone(v__cflag__CFlag_format(&flag)) }));
	}
	// autofree_scope_vars(pos=2650 line_nr=100 scope.pos=2434 scope.end_pos=2663)
	// var "cflags" var.pos=2435 var.line_nr=92
	// var "args" var.pos=2500 var.line_nr=93
	// af parent scope:
	// af parent scope:
	return args;
}

Array_string Array_v__cflag__CFlag_c_options_only_object_files(Array_v__cflag__CFlag cflags) {
	Array_string args = __new_array_with_default(0, 0, sizeof(string), 0);
	// FOR IN array
	for (int _t650 = 0; _t650 < cflags.len; ++_t650) {
		v__cflag__CFlag flag = ((v__cflag__CFlag*)cflags.data)[_t650];
		if (string_ends_with(flag.value, _SLIT(".o")) || string_ends_with(flag.value, _SLIT(".obj"))) {
			array_push(&args, _MOV((string[]){ string_clone(v__cflag__CFlag_format(&flag)) }));
		}
	}
	// autofree_scope_vars(pos=2875 line_nr=110 scope.pos=2673 scope.end_pos=2888)
	// var "cflags" var.pos=2674 var.line_nr=103
	// var "args" var.pos=2736 var.line_nr=104
	// af parent scope:
	// af parent scope:
	return args;
}

multi_return_Array_string_Array_string_Array_string Array_v__cflag__CFlag_defines_others_libs(Array_v__cflag__CFlag cflags) {
	Array_string copts_without_obj_files = Array_v__cflag__CFlag_c_options_without_object_files(cflags);
	Array_string defines = __new_array_with_default(0, 0, sizeof(string), 0);
	Array_string others = __new_array_with_default(0, 0, sizeof(string), 0);
	Array_string libs = __new_array_with_default(0, 0, sizeof(string), 0);
	// FOR IN array
	for (int _t652 = 0; _t652 < copts_without_obj_files.len; ++_t652) {
		string copt = ((string*)copts_without_obj_files.data)[_t652];
		if (string_starts_with(copt, _SLIT("-l"))) {
			array_push(&libs, _MOV((string[]){ string_clone(copt) }));
			continue;
		}
		if (string_starts_with(copt, _SLIT("-D"))) {
			array_push(&defines, _MOV((string[]){ string_clone(copt) }));
			continue;
		}
		array_push(&others, _MOV((string[]){ string_clone(copt) }));
	}
	return (multi_return_Array_string_Array_string_Array_string){.arg0=defines, .arg1=others, .arg2=libs};
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL u32 rand__seed__nr_next(u32 prev) {
	 u32 _t656 = prev * 1664525 + 1013904223;
	// autofree_scope_vars(pos=300 line_nr=10 scope.pos=276 scope.end_pos=336)
	// var "prev" var.pos=284 var.line_nr=9
	// af parent scope:
	// af parent scope:
	return _t656;
}

// Attr: [inline]
inline Array_u32 rand__seed__time_seed_array(int count) {
	time__Time ctime = time__now();
	u32 seed = ((u32)((time__Time_unix_time(ctime) ^ ctime.microsecond)));
	Array_u32 seed_data = __new_array_with_default(0, count, sizeof(u32), 0);
	for (int _t657 = 0; _t657 < count; ++_t657) {
		seed = rand__seed__nr_next(seed);
		array_push(&seed_data, _MOV((u32[]){ rand__seed__nr_next(seed) }));
	}
	// autofree_scope_vars(pos=664 line_nr=23 scope.pos=438 scope.end_pos=682)
	// var "count" var.pos=454 var.line_nr=15
	// var "ctime" var.pos=474 var.line_nr=16
	// var "seed" var.pos=499 var.line_nr=17
	// var "seed_data" var.pos=555 var.line_nr=18
	// af parent scope:
	// af parent scope:
	return seed_data;
}

// Attr: [inline]
inline u32 rand__seed__time_seed_32(void) {
	 u32 _t659 = (*(u32*)/*ee elem_typ */array_get(rand__seed__time_seed_array(1), 0));
	// autofree_scope_vars(pos=788 line_nr=29 scope.pos=767 scope.end_pos=818)
	// af parent scope:
	// af parent scope:
	return _t659;
}

// Attr: [inline]
inline u64 rand__seed__time_seed_64(void) {
	Array_u32 seed_data = rand__seed__time_seed_array(2);
	u64 lower = ((u64)((*(u32*)/*ee elem_typ */array_get(seed_data, 0))));
	u64 upper = ((u64)((*(u32*)/*ee elem_typ */array_get(seed_data, 1))));
	 u64 _t660 = (lower | (upper << 32));
	// autofree_scope_vars(pos=1013 line_nr=38 scope.pos=903 scope.end_pos=1043)
	// var "seed_data" var.pos=925 var.line_nr=35
	// var "lower" var.pos=958 var.line_nr=36
	// var "upper" var.pos=986 var.line_nr=37
	// af parent scope:
	// af parent scope:
	return _t660;
}

VV_LOCAL_SYMBOL Option_string v__pkgconfig__desc(string mod) {
	v__pkgconfig__Options options = (v__pkgconfig__Options){.path = (string){.str=(byteptr)"", .is_lit=1},.debug = 0,.norecurse = 0,.only_description = true,.use_default_paths = true,};
	Option_v__pkgconfig__PkgConfig_ptr _t661 = v__pkgconfig__load(mod, options);
	if (_t661.state != 0) { /*or block*/ 
		IError err = _t661.err;
		return (Option_string){ .state=2, .err=v_error(_SLIT("cannot parse")) };
	}
 	v__pkgconfig__PkgConfig* pc =  *(v__pkgconfig__PkgConfig**)_t661.data;
	Option_string _t662;
	opt_ok(&(string[]) { pc->description }, (Option*)(&_t662), sizeof(string));
	// autofree_scope_vars(pos=819 line_nr=41 scope.pos=677 scope.end_pos=842)
	// var "mod" var.pos=682 var.line_nr=36
	// var "options" var.pos=705 var.line_nr=37
	// var "pc" var.pos=758 var.line_nr=40
	// af parent scope:
	// af parent scope:
	return _t662;
}

Option_v__pkgconfig__Main_ptr v__pkgconfig__main(Array_string args) {
	flag__FlagParser* fp = flag__new_flag_parser(args);
	flag__FlagParser_application(fp, _SLIT("pkgconfig"));
	flag__FlagParser_version(fp, _const_v__pkgconfig__version);
	v__pkgconfig__Main* m = (v__pkgconfig__Main*)memdup(&(v__pkgconfig__Main){.opt = v__pkgconfig__parse_options(fp),.res = (string){.str=(byteptr)"", .is_lit=1},.has_actions = 0,}, sizeof(v__pkgconfig__Main));
	v__pkgconfig__MainOptions* opt = m->opt;
	if (opt->help) {
		m->res = flag__FlagParser_usage(/*rec*/*fp);
	} else if (opt->version) {
		m->res = _const_v__pkgconfig__version;
	} else if (opt->listall) {
		Array_string modules = v__pkgconfig__list();
		qsort(modules.data, modules.len, modules.element_size, (int (*)(const void *, const void *))&compare_strings);
		if (opt->description) {
			// FOR IN array
			for (int _t663 = 0; _t663 < modules.len; ++_t663) {
				string mod = ((string*)modules.data)[_t663];
				Option_string _t664 = v__pkgconfig__desc(mod);
				if (_t664.state != 0) { /*or block*/ 
					IError err = _t664.err;
					continue;
				}
 				string d =  *(string*)_t664.data;
				string pad = strings__repeat(L' ', 20 - mod.len);
				m->res = /*f*/string_add(m->res, _STR("%.*s\000 %.*s\000 %.*s\000\n", 4, mod, pad, d));
			}
		} else {
			m->res = Array_string_join(modules, _SLIT("\n"));
		}
	} else if (opt->args.len == 0) {
		return (Option_v__pkgconfig__Main_ptr){ .state=2, .err=v_error(_SLIT("No packages given")) };
	}
	Option_v__pkgconfig__Main_ptr _t665;
	opt_ok(&(v__pkgconfig__Main*[]) { m }, (Option*)(&_t665), sizeof(v__pkgconfig__Main*));
	// autofree_scope_vars(pos=1454 line_nr=71 scope.pos=852 scope.end_pos=1464)
	// var "args" var.pos=857 var.line_nr=44
	// var "fp" var.pos=886 var.line_nr=45
	// var "m" var.pos=974 var.line_nr=48
	// var "opt" var.pos=1019 var.line_nr=51
	// af parent scope:
	// af parent scope:
	return _t665;
}

Option_string v__pkgconfig__Main_run(v__pkgconfig__Main* m) {
	v__pkgconfig__Options options = (v__pkgconfig__Options){.path = (string){.str=(byteptr)"", .is_lit=1},.debug = m->opt->debug,.norecurse = 0,.only_description = 0,.use_default_paths = true,};
	v__pkgconfig__MainOptions* opt = m->opt;
	v__pkgconfig__PkgConfig* pc = ((v__pkgconfig__PkgConfig*)(0));
	string res = m->res;
	// FOR IN array
	for (int _t666 = 0; _t666 < opt->args.len; ++_t666) {
		string arg = ((string*)opt->args.data)[_t666];
		Option_v__pkgconfig__PkgConfig_ptr _t667 = v__pkgconfig__load(arg, options);
		if (_t667.state != 0) { /*or block*/ 
			IError err = _t667.err;
			if (!opt->exists) {
				return (Option_string){ .state=2, .err=err };
			}
			continue;
		}
 		v__pkgconfig__PkgConfig* pcdep =  *(v__pkgconfig__PkgConfig**)_t667.data;
		if (opt->description) {
			if ((res).len != 0) {
				res = /*f*/string_add(res, _SLIT("\n"));
			}
			res = /*f*/string_add(res, pcdep->description);
		}
		if (pc != 0) {
			Option_string _t668 = v__pkgconfig__PkgConfig_extend(pc, pcdep);
			if (_t668.state != 0) { /*or block*/ 
				Option_string _t669;
				memcpy(&_t669, &_t668, sizeof(Option));
				return _t669;
			};
		} else {
			pc = pcdep;
		}
	}
	if (opt->exists) {
		Option_string _t670;
		opt_ok(&(string[]) { res }, (Option*)(&_t670), sizeof(string));
		// autofree_scope_vars(pos=1924 line_nr=102 scope.pos=1921 scope.end_pos=1937)
		// af parent scope:
		// var "m" var.pos=1479 var.line_nr=74
		// var "options" var.pos=1504 var.line_nr=75
		// var "opt" var.pos=1569 var.line_nr=79
		// var "pc" var.pos=1587 var.line_nr=80
		// var "res" var.pos=1612 var.line_nr=81
		// var "r" var.pos=2401 var.line_nr=128
		// af parent scope:
		// af parent scope:
		return _t670;
	}
	if ((opt->exactversion).len != 0) {
		if (string_ne(pc->version, opt->exactversion)) {
			return (Option_string){ .state=2, .err=v_error(_SLIT("version mismatch")) };
		}
		Option_string _t671;
		opt_ok(&(string[]) { res }, (Option*)(&_t671), sizeof(string));
		// autofree_scope_vars(pos=2047 line_nr=108 scope.pos=1966 scope.end_pos=2060)
		// af parent scope:
		// var "m" var.pos=1479 var.line_nr=74
		// var "options" var.pos=1504 var.line_nr=75
		// var "opt" var.pos=1569 var.line_nr=79
		// var "pc" var.pos=1587 var.line_nr=80
		// var "res" var.pos=1612 var.line_nr=81
		// var "r" var.pos=2401 var.line_nr=128
		// af parent scope:
		// af parent scope:
		return _t671;
	}
	if ((opt->atleast).len != 0) {
		if (v__pkgconfig__PkgConfig_atleast(pc, opt->atleast)) {
			return (Option_string){ .state=2, .err=v_error(_SLIT("version mismatch")) };
		}
		Option_string _t672;
		opt_ok(&(string[]) { res }, (Option*)(&_t672), sizeof(string));
		// autofree_scope_vars(pos=2158 line_nr=114 scope.pos=2084 scope.end_pos=2171)
		// af parent scope:
		// var "m" var.pos=1479 var.line_nr=74
		// var "options" var.pos=1504 var.line_nr=75
		// var "opt" var.pos=1569 var.line_nr=79
		// var "pc" var.pos=1587 var.line_nr=80
		// var "res" var.pos=1612 var.line_nr=81
		// var "r" var.pos=2401 var.line_nr=128
		// af parent scope:
		// af parent scope:
		return _t672;
	}
	if ((opt->atleastpc).len != 0) {
		if (v__pkgconfig__atleast(opt->atleastpc)) {
			return (Option_string){ .state=2, .err=v_error(_SLIT("version mismatch")) };
		}
		Option_string _t673;
		opt_ok(&(string[]) { res }, (Option*)(&_t673), sizeof(string));
		// autofree_scope_vars(pos=2270 line_nr=120 scope.pos=2197 scope.end_pos=2283)
		// af parent scope:
		// var "m" var.pos=1479 var.line_nr=74
		// var "options" var.pos=1504 var.line_nr=75
		// var "opt" var.pos=1569 var.line_nr=79
		// var "pc" var.pos=1587 var.line_nr=80
		// var "res" var.pos=1612 var.line_nr=81
		// var "r" var.pos=2401 var.line_nr=128
		// af parent scope:
		// af parent scope:
		return _t673;
	}
	if (opt->variables) {
		res = Array_string_join(map_keys(&pc->vars), _SLIT("\n"));
	}
	if (opt->requires) {
		res = /*f*/string_add(res, Array_string_join(pc->requires, _SLIT("\n")));
	}
	Array_string r = __new_array_with_default(0, 0, sizeof(string), 0);
	if (opt->cflags_only_path) {
		array_push(&r, _MOV((string[]){ string_clone(v__pkgconfig__filter(pc->cflags, _SLIT("-I"), _SLIT(""))) }));
	}
	if (opt->cflags_only_other) {
		array_push(&r, _MOV((string[]){ string_clone(v__pkgconfig__filter(pc->cflags, _SLIT("-I"), _SLIT("-I"))) }));
	}
	if (opt->cflags) {
		array_push(&r, _MOV((string[]){ string_clone(Array_string_join(pc->cflags, _SLIT(" "))) }));
	}
	if (opt->libs_only_link) {
		array_push(&r, _MOV((string[]){ string_clone(v__pkgconfig__filter(pc->libs, _SLIT("-l"), _SLIT(""))) }));
	}
	if (opt->libs_only_path) {
		array_push(&r, _MOV((string[]){ string_clone(v__pkgconfig__filter(pc->libs, _SLIT("-L"), _SLIT(""))) }));
	}
	if (opt->libs_only_other) {
		array_push(&r, _MOV((string[]){ string_clone(v__pkgconfig__filter(pc->libs, _SLIT("-l"), _SLIT("-L"))) }));
	}
	if (opt->libs) {
		if (opt->stat1c) {
			array_push(&r, _MOV((string[]){ string_clone(Array_string_join(pc->libs_private, _SLIT(" "))) }));
		} else {
			array_push(&r, _MOV((string[]){ string_clone(Array_string_join(pc->libs, _SLIT(" "))) }));
		}
	}
	if (opt->modversion) {
		array_push(&r, _MOV((string[]){ string_clone(pc->version) }));
	}
	Option_string _t683;
	opt_ok(&(string[]) { string_add(res, Array_string_join(r, _SLIT(" "))) }, (Option*)(&_t683), sizeof(string));
	// autofree_scope_vars(pos=2936 line_nr=157 scope.pos=1474 scope.end_pos=2962)
	// var "m" var.pos=1479 var.line_nr=74
	// var "options" var.pos=1504 var.line_nr=75
	// var "opt" var.pos=1569 var.line_nr=79
	// var "pc" var.pos=1587 var.line_nr=80
	// var "res" var.pos=1612 var.line_nr=81
	// var "r" var.pos=2401 var.line_nr=128
	// af parent scope:
	// af parent scope:
	return _t683;
}

VV_LOCAL_SYMBOL string v__pkgconfig__filter(Array_string libs, string prefix, string prefix2) {
	string res = _SLIT("");
	if ((prefix2).len != 0) {
		// FOR IN array
		for (int _t684 = 0; _t684 < libs.len; ++_t684) {
			string lib = ((string*)libs.data)[_t684];
			if (!string_starts_with(lib, prefix) && !string_starts_with(lib, prefix2)) {
				res = /*f*/string_add(res, _STR(" %.*s", 1, lib));
			}
		}
	} else {
		// FOR IN array
		for (int _t685 = 0; _t685 < libs.len; ++_t685) {
			string lib = ((string*)libs.data)[_t685];
			if (string_starts_with(lib, prefix)) {
				res = /*f*/string_add(res, _STR(" %.*s", 1, lib));
			}
		}
	}
	// autofree_scope_vars(pos=3268 line_nr=175 scope.pos=2968 scope.end_pos=3280)
	// var "libs" var.pos=2975 var.line_nr=160
	// var "prefix" var.pos=2990 var.line_nr=160
	// var "prefix2" var.pos=3005 var.line_nr=160
	// var "res" var.pos=3035 var.line_nr=161
	// str literal
	// af parent scope:
	// af parent scope:
	return res;
}

VV_LOCAL_SYMBOL v__pkgconfig__MainOptions* v__pkgconfig__parse_options(flag__FlagParser* fp) {
	 v__pkgconfig__MainOptions* _t686 = (v__pkgconfig__MainOptions*)memdup(&(v__pkgconfig__MainOptions){.modversion = flag__FlagParser_bool(fp, _SLIT("modversion"), L'V', false, _SLIT("show version of module")),
		.description = flag__FlagParser_bool(fp, _SLIT("description"), L'd', false, _SLIT("show pkg module description")),
		.help = flag__FlagParser_bool(fp, _SLIT("help"), L'h', false, _SLIT("show this help message")),
		.debug = flag__FlagParser_bool(fp, _SLIT("debug"), L'D', false, _SLIT("show debug information")),
		.listall = flag__FlagParser_bool(fp, _SLIT("list-all"), L'l', false, _SLIT("list all pkgmodules")),
		.exists = flag__FlagParser_bool(fp, _SLIT("exists"), L'e', false, _SLIT("return 0 if pkg exists")),
		.variables = flag__FlagParser_bool(fp, _SLIT("print-variables"), L'V', false, _SLIT("display variable names")),
		.requires = flag__FlagParser_bool(fp, _SLIT("print-requires"), L'r', false, _SLIT("display requires of the module")),
		.atleast = flag__FlagParser_string(fp, _SLIT("atleast-version"), L'a', _SLIT(""), _SLIT("return 0 if pkg version is at least the given one")),
		.atleastpc = flag__FlagParser_string(fp, _SLIT("atleast-pkgconfig-version"), L'A', _SLIT(""), _SLIT("return 0 if pkgconfig version is at least the given one")),
		.exactversion = flag__FlagParser_string(fp, _SLIT("exact-version"), L' ', _SLIT(""), _SLIT("return 0 if pkg version is at least the given one")),
		.version = flag__FlagParser_bool(fp, _SLIT("version"), L'v', false, _SLIT("show version of this tool")),
		.cflags = flag__FlagParser_bool(fp, _SLIT("cflags"), L'c', false, _SLIT("output all pre-processor and compiler flags")),
		.cflags_only_path = flag__FlagParser_bool(fp, _SLIT("cflags-only-I"), L'I', false, _SLIT("show only -I flags from CFLAGS")),
		.cflags_only_other = flag__FlagParser_bool(fp, _SLIT("cflags-only-other"), L' ', false, _SLIT("show cflags without -I")),
		.stat1c = flag__FlagParser_bool(fp, _SLIT("static"), L's', false, _SLIT("show --libs for static linking")),
		.libs = flag__FlagParser_bool(fp, _SLIT("libs"), L'l', false, _SLIT("output all linker flags")),
		.libs_only_link = flag__FlagParser_bool(fp, _SLIT("libs-only-l"), L' ', false, _SLIT("show only -l from ldflags")),
		.libs_only_path = flag__FlagParser_bool(fp, _SLIT("libs-only-L"), L'L', false, _SLIT("show only -L from ldflags")),
		.libs_only_other = flag__FlagParser_bool(fp, _SLIT("libs-only-other"), L' ', false, _SLIT("show flags not containing -l or -L")),
		.args = fp->args,
	}, sizeof(v__pkgconfig__MainOptions));
	// autofree_scope_vars(pos=3339 line_nr=179 scope.pos=3286 scope.end_pos=5016)
	// var "fp" var.pos=3304 var.line_nr=178
	// af parent scope:
	// af parent scope:
	return _t686;
}

VV_LOCAL_SYMBOL Array_string v__pkgconfig__PkgConfig_parse_list_no_comma(v__pkgconfig__PkgConfig* pc, string s) {
	 Array_string _t687 = v__pkgconfig__PkgConfig_parse_list(pc, string_replace(s, _SLIT(","), _SLIT(" ")));
	// autofree_scope_vars(pos=1050 line_nr=48 scope.pos=990 scope.end_pos=1093)
	// var "pc" var.pos=995 var.line_nr=47
	// var "s" var.pos=1029 var.line_nr=47
	// af parent scope:
	// af parent scope:
	return _t687;
}

VV_LOCAL_SYMBOL Array_string v__pkgconfig__PkgConfig_parse_list(v__pkgconfig__PkgConfig* pc, string s) {
	Array_string operators = new_array_from_c_array(5, 5, sizeof(string), _MOV((string[5]){_SLIT("="), _SLIT("<"), _SLIT(">"), _SLIT(">="), _SLIT("<=")}));
	Array_string r = string_split(v__pkgconfig__PkgConfig_parse_line(pc, string_replace(string_replace(s, _SLIT("  "), _SLIT(" ")), _SLIT(", "), _SLIT(" "))), _SLIT(" "));
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	bool skip = false;
	// FOR IN array
	for (int _t688 = 0; _t688 < r.len; ++_t688) {
		string a = ((string*)r.data)[_t688];
		string b = string_trim_space(a);
		if (skip) {
			skip = false;
		} else if ((Array_string_contains(operators, b))) {
			skip = true;
		} else if ((b).len != 0) {
			array_push(&res, _MOV((string[]){ string_clone(b) }));
		}
	}
	// autofree_scope_vars(pos=1455 line_nr=66 scope.pos=1099 scope.end_pos=1467)
	// var "pc" var.pos=1104 var.line_nr=51
	// var "s" var.pos=1129 var.line_nr=51
	// var "operators" var.pos=1151 var.line_nr=52
	// var "r" var.pos=1193 var.line_nr=53
	// var "res" var.pos=1269 var.line_nr=54
	// var "skip" var.pos=1292 var.line_nr=55
	// af parent scope:
	// af parent scope:
	return res;
}

VV_LOCAL_SYMBOL string v__pkgconfig__PkgConfig_parse_line(v__pkgconfig__PkgConfig* pc, string s) {
	string r = string_trim_space(s);
	for (;;) {
		if (!(string_contains(r, _SLIT("${")))) break;
		Option_int _t690 = string_index(r, _SLIT("${"));
		if (_t690.state != 0) { /*or block*/ 
			IError err = _t690.err;
			break;
		}
 		int tok0 =  *(int*)_t690.data;
		Option_int _t691 = string_index(string_substr(r, tok0, r.len), _SLIT("}"));
		if (_t691.state != 0) { /*or block*/ 
			IError err = _t691.err;
			break;
		}
 		int tok1 =  *(int*)_t691.data;
		tok1 += tok0;
		string v = string_substr(r, tok0 + 2, tok1);
		r = string_replace(r, _STR("${%.*s\000}", 2, v), (*(string*)map_get(ADDR(map, pc->vars), &(string[]){v}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })));
	}
	 string _t692 = string_trim_space(r);
	// autofree_scope_vars(pos=1739 line_nr=78 scope.pos=1473 scope.end_pos=1762)
	// var "pc" var.pos=1478 var.line_nr=69
	// var "s" var.pos=1503 var.line_nr=69
	// var "r" var.pos=1527 var.line_nr=70
	// af parent scope:
	// af parent scope:
	return _t692;
}

VV_LOCAL_SYMBOL void v__pkgconfig__PkgConfig_setvar(v__pkgconfig__PkgConfig* pc, string line) {
	Array_string kv = string_split(string_trim_space(line), _SLIT("="));
	if (kv.len == 2) {
		string k = (*(string*)/*ee elem_typ */array_get(kv, 0));
		string v = v__pkgconfig__PkgConfig_parse_line(pc, (*(string*)/*ee elem_typ */array_get(kv, 1)));
		map_set(&pc->vars, &(string[]){k}, &(string[]) { v__pkgconfig__PkgConfig_parse_line(pc, v) });
	}
}

VV_LOCAL_SYMBOL bool v__pkgconfig__PkgConfig_parse(v__pkgconfig__PkgConfig* pc, string file) {
	Option_string _t693 = os__read_file(file);
	if (_t693.state != 0) { /*or block*/ 
		IError err = _t693.err;
		 bool _t694 = false;
		// autofree_scope_vars(pos=2022 line_nr=91 scope.pos=2021 scope.end_pos=2036)
		// var "err" var.pos=2021 var.line_nr=91
		// af parent scope:
		// var "pc" var.pos=1950 var.line_nr=90
		// var "file" var.pos=1970 var.line_nr=90
		// var "data" var.pos=1991 var.line_nr=91
		// var "lines" var.pos=2082 var.line_nr=95
		// af parent scope:
		// af parent scope:
		return _t694;
	}
 	string data =  *(string*)_t693.data;
	if (pc->options.debug) {
		eprintln(data);
	}
	Array_string lines = string_split(data, _SLIT("\n"));
	if (pc->options.only_description) {
		// FOR IN array
		for (int _t695 = 0; _t695 < lines.len; ++_t695) {
			string line = ((string*)lines.data)[_t695];
			if (string_starts_with(line, _SLIT("Description: "))) {
				pc->description = v__pkgconfig__PkgConfig_parse_line(pc, string_substr(line, 13, line.len));
			}
		}
	} else {
		// FOR IN array
		for (int _t696 = 0; _t696 < lines.len; ++_t696) {
			string line = ((string*)lines.data)[_t696];
			if (string_starts_with(line, _SLIT("#"))) {
				continue;
			}
			if (string_contains(line, _SLIT("=")) && !string_contains(line, _SLIT(" "))) {
				v__pkgconfig__PkgConfig_setvar(pc, line);
				continue;
			}
			if (string_starts_with(line, _SLIT("Name:"))) {
				pc->name = v__pkgconfig__PkgConfig_parse_line(pc, string_substr(line, 5, line.len));
			} else if (string_starts_with(line, _SLIT("Description:"))) {
				pc->description = v__pkgconfig__PkgConfig_parse_line(pc, string_substr(line, 12, line.len));
			} else if (string_starts_with(line, _SLIT("Version:"))) {
				pc->version = v__pkgconfig__PkgConfig_parse_line(pc, string_substr(line, 8, line.len));
			} else if (string_starts_with(line, _SLIT("Requires:"))) {
				pc->requires = v__pkgconfig__PkgConfig_parse_list_no_comma(pc, string_substr(line, 9, line.len));
			} else if (string_starts_with(line, _SLIT("Requires.private:"))) {
				pc->requires_private = v__pkgconfig__PkgConfig_parse_list_no_comma(pc, string_substr(line, 17, line.len));
			} else if (string_starts_with(line, _SLIT("Conflicts:"))) {
				pc->conflicts = v__pkgconfig__PkgConfig_parse_list_no_comma(pc, string_substr(line, 10, line.len));
			} else if (string_starts_with(line, _SLIT("Cflags:"))) {
				pc->cflags = v__pkgconfig__PkgConfig_parse_list(pc, string_substr(line, 7, line.len));
			} else if (string_starts_with(line, _SLIT("Libs:"))) {
				pc->libs = v__pkgconfig__PkgConfig_parse_list(pc, string_substr(line, 5, line.len));
			} else if (string_starts_with(line, _SLIT("Libs.private:"))) {
				pc->libs_private = v__pkgconfig__PkgConfig_parse_list(pc, string_substr(line, 13, line.len));
			} else if (string_starts_with(line, _SLIT("URL:"))) {
				pc->url = v__pkgconfig__PkgConfig_parse_line(pc, string_substr(line, 4, line.len));
			}
		}
	}
	 bool _t697 = true;
	// autofree_scope_vars(pos=3415 line_nr=135 scope.pos=1945 scope.end_pos=3428)
	// var "pc" var.pos=1950 var.line_nr=90
	// var "file" var.pos=1970 var.line_nr=90
	// var "data" var.pos=1991 var.line_nr=91
	// var "lines" var.pos=2082 var.line_nr=95
	// af parent scope:
	// af parent scope:
	return _t697;
}

VV_LOCAL_SYMBOL Option_string v__pkgconfig__PkgConfig_resolve(v__pkgconfig__PkgConfig* pc, string pkgname) {
	if (string_ends_with(pkgname, _SLIT(".pc"))) {
		if (os__exists(pkgname)) {
			Option_string _t698;
			opt_ok(&(string[]) { pkgname }, (Option*)(&_t698), sizeof(string));
			// autofree_scope_vars(pos=3546 line_nr=141 scope.pos=3542 scope.end_pos=3564)
			// af parent scope:
			// af parent scope:
			// var "pc" var.pos=3439 var.line_nr=138
			// var "pkgname" var.pos=3461 var.line_nr=138
			// af parent scope:
			// af parent scope:
			return _t698;
		}
	} else {
		if (pc->paths.len == 0) {
			array_push(&pc->paths, _MOV((string[]){ string_clone(_SLIT(".")) }));
		}
		// FOR IN array
		for (int _t700 = 0; _t700 < pc->paths.len; ++_t700) {
			string path = ((string*)pc->paths.data)[_t700];
			string file = _STR("%.*s\000/%.*s\000.pc", 3, path, pkgname);
			if (os__exists(file)) {
				Option_string _t701;
				opt_ok(&(string[]) { file }, (Option*)(&_t701), sizeof(string));
				// autofree_scope_vars(pos=3709 line_nr=150 scope.pos=3704 scope.end_pos=3725)
				// af parent scope:
				// var "path" var.pos=3630 var.line_nr=147
				// skipping tmp var "path"
				// var "file" var.pos=3652 var.line_nr=148
				// af parent scope:
				// af parent scope:
				// var "pc" var.pos=3439 var.line_nr=138
				// var "pkgname" var.pos=3461 var.line_nr=138
				// af parent scope:
				// af parent scope:
				return _t701;
			}
		}
	}
	return (Option_string){ .state=2, .err=v_error(_STR("Cannot find \"%.*s\000\" pkgconfig file", 2, pkgname)) };
}

bool v__pkgconfig__atleast(string v) {
	Option_semver__Version _t702 = semver__from(_const_v__pkgconfig__version);
	if (_t702.state != 0) { /*or block*/ 
		IError err = _t702.err;
		 bool _t703 = false;
		// autofree_scope_vars(pos=3866 line_nr=158 scope.pos=3865 scope.end_pos=3880)
		// var "err" var.pos=3865 var.line_nr=158
		// af parent scope:
		// var "v" var.pos=3807 var.line_nr=157
		// var "v0" var.pos=3825 var.line_nr=158
		// var "v1" var.pos=3883 var.line_nr=159
		// af parent scope:
		// af parent scope:
		return _t703;
	}
 	semver__Version v0 =  *(semver__Version*)_t702.data;
	Option_semver__Version _t704 = semver__from(v);
	if (_t704.state != 0) { /*or block*/ 
		IError err = _t704.err;
		 bool _t705 = false;
		// autofree_scope_vars(pos=3908 line_nr=159 scope.pos=3907 scope.end_pos=3922)
		// var "err" var.pos=3907 var.line_nr=159
		// af parent scope:
		// var "v" var.pos=3807 var.line_nr=157
		// var "v0" var.pos=3825 var.line_nr=158
		// var "v1" var.pos=3883 var.line_nr=159
		// af parent scope:
		// af parent scope:
		return _t705;
	}
 	semver__Version v1 =  *(semver__Version*)_t704.data;
	 bool _t706 = semver__Version_gt(v0, v1);
	// autofree_scope_vars(pos=3924 line_nr=160 scope.pos=3799 scope.end_pos=3942)
	// var "v" var.pos=3807 var.line_nr=157
	// var "v0" var.pos=3825 var.line_nr=158
	// var "v1" var.pos=3883 var.line_nr=159
	// af parent scope:
	// af parent scope:
	return _t706;
}

bool v__pkgconfig__PkgConfig_atleast(v__pkgconfig__PkgConfig* pc, string v) {
	Option_semver__Version _t707 = semver__from(pc->version);
	if (_t707.state != 0) { /*or block*/ 
		IError err = _t707.err;
		 bool _t708 = false;
		// autofree_scope_vars(pos=4031 line_nr=164 scope.pos=4030 scope.end_pos=4045)
		// var "err" var.pos=4030 var.line_nr=164
		// af parent scope:
		// var "pc" var.pos=3957 var.line_nr=163
		// var "v" var.pos=3979 var.line_nr=163
		// var "v0" var.pos=3997 var.line_nr=164
		// var "v1" var.pos=4048 var.line_nr=165
		// af parent scope:
		// af parent scope:
		return _t708;
	}
 	semver__Version v0 =  *(semver__Version*)_t707.data;
	Option_semver__Version _t709 = semver__from(v);
	if (_t709.state != 0) { /*or block*/ 
		IError err = _t709.err;
		 bool _t710 = false;
		// autofree_scope_vars(pos=4073 line_nr=165 scope.pos=4072 scope.end_pos=4087)
		// var "err" var.pos=4072 var.line_nr=165
		// af parent scope:
		// var "pc" var.pos=3957 var.line_nr=163
		// var "v" var.pos=3979 var.line_nr=163
		// var "v0" var.pos=3997 var.line_nr=164
		// var "v1" var.pos=4048 var.line_nr=165
		// af parent scope:
		// af parent scope:
		return _t710;
	}
 	semver__Version v1 =  *(semver__Version*)_t709.data;
	 bool _t711 = semver__Version_gt(v0, v1);
	// autofree_scope_vars(pos=4089 line_nr=166 scope.pos=3952 scope.end_pos=4107)
	// var "pc" var.pos=3957 var.line_nr=163
	// var "v" var.pos=3979 var.line_nr=163
	// var "v0" var.pos=3997 var.line_nr=164
	// var "v1" var.pos=4048 var.line_nr=165
	// af parent scope:
	// af parent scope:
	return _t711;
}

Option_string v__pkgconfig__PkgConfig_extend(v__pkgconfig__PkgConfig* pc, v__pkgconfig__PkgConfig* pcdep) {
	// FOR IN array
	for (int _t712 = 0; _t712 < pcdep->cflags.len; ++_t712) {
		string flag = ((string*)pcdep->cflags.data)[_t712];
		if (Array_string_index(pc->cflags, flag) == -1) {
			array_push(&pc->cflags, _MOV((string[]){ string_clone(flag) }));
		}
	}
	// FOR IN array
	for (int _t714 = 0; _t714 < pcdep->libs.len; ++_t714) {
		string lib = ((string*)pcdep->libs.data)[_t714];
		if (Array_string_index(pc->libs, lib) == -1) {
			array_push(&pc->libs, _MOV((string[]){ string_clone(lib) }));
		}
	}
	// FOR IN array
	for (int _t716 = 0; _t716 < pcdep->libs_private.len; ++_t716) {
		string lib = ((string*)pcdep->libs_private.data)[_t716];
		if (Array_string_index(pc->libs_private, lib) == -1) {
			array_push(&pc->libs_private, _MOV((string[]){ string_clone(lib) }));
		}
	}
	return (Option_string){ .state=2, .err=_const_none__ };
}

VV_LOCAL_SYMBOL Option_void v__pkgconfig__PkgConfig_load_requires(v__pkgconfig__PkgConfig* pc) {
	// FOR IN array
	for (int _t718 = 0; _t718 < pc->requires.len; ++_t718) {
		string dep = ((string*)pc->requires.data)[_t718];
		Option_void _t719 = v__pkgconfig__PkgConfig_load_require(pc, dep);
		if (_t719.state != 0 && _t719.err._typ != _IError_None___index) {
			Option_void _t720;
			memcpy(&_t720, &_t719, sizeof(Option));
			return _t720;
		};
	}
	// FOR IN array
	for (int _t721 = 0; _t721 < pc->requires_private.len; ++_t721) {
		string dep = ((string*)pc->requires_private.data)[_t721];
		Option_void _t722 = v__pkgconfig__PkgConfig_load_require(pc, dep);
		if (_t722.state != 0 && _t722.err._typ != _IError_None___index) {
			Option_void _t723;
			memcpy(&_t723, &_t722, sizeof(Option));
			return _t723;
		};
	}
	return (Option_void){0};
}

VV_LOCAL_SYMBOL Option_void v__pkgconfig__PkgConfig_load_require(v__pkgconfig__PkgConfig* pc, string dep) {
	v__pkgconfig__PkgConfig pcdep = (v__pkgconfig__PkgConfig){.options = (v__pkgconfig__Options){.use_default_paths = true,},.name = (string){.str=(byteptr)"", .is_lit=1},.modname = (string){.str=(byteptr)"", .is_lit=1},.url = (string){.str=(byteptr)"", .is_lit=1},.version = (string){.str=(byteptr)"", .is_lit=1},.description = (string){.str=(byteptr)"", .is_lit=1},.libs = __new_array(0, 1, sizeof(string)),.libs_private = __new_array(0, 1, sizeof(string)),.cflags = __new_array(0, 1, sizeof(string)),.paths = pc->paths,.vars = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.requires = __new_array(0, 1, sizeof(string)),.requires_private = __new_array(0, 1, sizeof(string)),.conflicts = __new_array(0, 1, sizeof(string)),};
	Option_string _t724 = v__pkgconfig__PkgConfig_resolve(&pcdep, dep);
	if (_t724.state != 0) { /*or block*/ 
		IError err = _t724.err;
		if (pc->options.debug) {
			eprintln(_STR("cannot resolve %.*s", 1, dep));
		}
		return (Option_void){ .state=2, .err=v_error(_STR("could not resolve dependency %.*s", 1, dep)) };
	}
 	string depfile =  *(string*)_t724.data;
	if (!v__pkgconfig__PkgConfig_parse(&pcdep, depfile)) {
		return (Option_void){ .state=2, .err=v_error(_STR("required file \"%.*s\000\" could not be parsed", 2, depfile)) };
	}
	Option_void _t725 = v__pkgconfig__PkgConfig_load_requires(&pcdep);
	if (_t725.state != 0 && _t725.err._typ != _IError_None___index) {
		Option_void _t726;
		memcpy(&_t726, &_t725, sizeof(Option));
		return _t726;
	};
	Option_string _t727 = v__pkgconfig__PkgConfig_extend(pc, (voidptr)&/*qq*/pcdep);
	if (_t727.state != 0) { /*or block*/ 
		Option_void _t728;
		memcpy(&_t728, &_t727, sizeof(Option));
		return _t728;
	};
	return (Option_void){0};
}

VV_LOCAL_SYMBOL void v__pkgconfig__PkgConfig_add_path(v__pkgconfig__PkgConfig* pc, string path) {
	string p = (string_ends_with(path, _SLIT("/")) ? (string_substr(path, 0, path.len - 1)) : (path));
	if (!os__exists(p)) {
		return;
	}
	if (Array_string_index(pc->paths, p) == -1) {
		array_push(&pc->paths, _MOV((string[]){ string_clone(p) }));
	}
}

VV_LOCAL_SYMBOL void v__pkgconfig__PkgConfig_load_paths(v__pkgconfig__PkgConfig* pc) {
	if (pc->options.use_default_paths) {
		// FOR IN array
		for (int _t730 = 0; _t730 < _const_v__pkgconfig__default_paths.len; ++_t730) {
			string path = ((string*)_const_v__pkgconfig__default_paths.data)[_t730];
			v__pkgconfig__PkgConfig_add_path(pc, path);
		}
	}
	// FOR IN array
	Array_string _t731 = string_split(pc->options.path, _SLIT(":"));
	for (int _t732 = 0; _t732 < _t731.len; ++_t732) {
		string path = ((string*)_t731.data)[_t732];
		v__pkgconfig__PkgConfig_add_path(pc, path);
	}
	string env_var = os__getenv(_SLIT("PKG_CONFIG_PATH"));
	if ((env_var).len != 0) {
		Array_string env_paths = string_split(string_trim_space(env_var), _SLIT(":"));
		// FOR IN array
		for (int _t733 = 0; _t733 < env_paths.len; ++_t733) {
			string path = ((string*)env_paths.data)[_t733];
			v__pkgconfig__PkgConfig_add_path(pc, path);
		}
	}
}

Option_v__pkgconfig__PkgConfig_ptr v__pkgconfig__load(string pkgname, v__pkgconfig__Options options) {
	v__pkgconfig__PkgConfig* pc = (v__pkgconfig__PkgConfig*)memdup(&(v__pkgconfig__PkgConfig){.options = options,.name = (string){.str=(byteptr)"", .is_lit=1},.modname = pkgname,.url = (string){.str=(byteptr)"", .is_lit=1},.version = (string){.str=(byteptr)"", .is_lit=1},.description = (string){.str=(byteptr)"", .is_lit=1},.libs = __new_array(0, 1, sizeof(string)),.libs_private = __new_array(0, 1, sizeof(string)),.cflags = __new_array(0, 1, sizeof(string)),.paths = __new_array(0, 1, sizeof(string)),.vars = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.requires = __new_array(0, 1, sizeof(string)),.requires_private = __new_array(0, 1, sizeof(string)),.conflicts = __new_array(0, 1, sizeof(string)),}, sizeof(v__pkgconfig__PkgConfig));
	v__pkgconfig__PkgConfig_load_paths(pc);
	Option_string _t734 = v__pkgconfig__PkgConfig_resolve(pc, pkgname);
	if (_t734.state != 0) { /*or block*/ 
		IError err = _t734.err;
		return (Option_v__pkgconfig__PkgConfig_ptr){ .state=2, .err=err };
	}
 	string file =  *(string*)_t734.data;
	if (!v__pkgconfig__PkgConfig_parse(pc, file)) {
		return (Option_v__pkgconfig__PkgConfig_ptr){ .state=2, .err=v_error(_STR("file \"%.*s\000\" could not be parsed", 2, file)) };
	}
	if (!options.norecurse) {
		Option_void _t735 = v__pkgconfig__PkgConfig_load_requires(pc);
		if (_t735.state != 0 && _t735.err._typ != _IError_None___index) {
			Option_v__pkgconfig__PkgConfig_ptr _t736;
			memcpy(&_t736, &_t735, sizeof(Option));
			return _t736;
		};
	}
	Option_v__pkgconfig__PkgConfig_ptr _t737;
	opt_ok(&(v__pkgconfig__PkgConfig*[]) { pc }, (Option*)(&_t737), sizeof(v__pkgconfig__PkgConfig*));
	// autofree_scope_vars(pos=5903 line_nr=255 scope.pos=5596 scope.end_pos=5914)
	// var "pkgname" var.pos=5601 var.line_nr=242
	// var "options" var.pos=5617 var.line_nr=242
	// var "pc" var.pos=5653 var.line_nr=243
	// var "file" var.pos=5730 var.line_nr=248
	// af parent scope:
	// af parent scope:
	return _t737;
}

Array_string v__pkgconfig__list(void) {
	v__pkgconfig__PkgConfig* pc = (v__pkgconfig__PkgConfig*)memdup(&(v__pkgconfig__PkgConfig){.options = (v__pkgconfig__Options){.path = (string){.str=(byteptr)"", .is_lit=1},.debug = 0,.norecurse = 0,.only_description = 0,.use_default_paths = true,},.name = (string){.str=(byteptr)"", .is_lit=1},.modname = (string){.str=(byteptr)"", .is_lit=1},.url = (string){.str=(byteptr)"", .is_lit=1},.version = (string){.str=(byteptr)"", .is_lit=1},.description = (string){.str=(byteptr)"", .is_lit=1},.libs = __new_array(0, 1, sizeof(string)),.libs_private = __new_array(0, 1, sizeof(string)),.cflags = __new_array(0, 1, sizeof(string)),.paths = __new_array(0, 1, sizeof(string)),.vars = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.requires = __new_array(0, 1, sizeof(string)),.requires_private = __new_array(0, 1, sizeof(string)),.conflicts = __new_array(0, 1, sizeof(string)),}, sizeof(v__pkgconfig__PkgConfig));
	v__pkgconfig__PkgConfig_load_paths(pc);
	Array_string modules = __new_array_with_default(0, 0, sizeof(string), 0);
	// FOR IN array
	for (int _t738 = 0; _t738 < pc->paths.len; ++_t738) {
		string path = ((string*)pc->paths.data)[_t738];
		Option_Array_string _t739 = os__ls(path);
		if (_t739.state != 0) { /*or block*/ 
			IError err = _t739.err;
			continue;
		}
 		Array_string files =  *(Array_string*)_t739.data;
		// FOR IN array
		for (int _t740 = 0; _t740 < files.len; ++_t740) {
			string file = ((string*)files.data)[_t740];
			if (string_ends_with(file, _SLIT(".pc"))) {
				string name = string_replace(file, _SLIT(".pc"), _SLIT(""));
				if (Array_string_index(modules, name) == -1) {
					array_push(&modules, _MOV((string[]){ string_clone(name) }));
				}
			}
		}
	}
	// autofree_scope_vars(pos=6258 line_nr=275 scope.pos=5924 scope.end_pos=6274)
	// var "pc" var.pos=5947 var.line_nr=259
	// var "modules" var.pos=6011 var.line_nr=263
	// af parent scope:
	// af parent scope:
	return modules;
}

void rand__wyrand__WyRandRNG_seed(rand__wyrand__WyRandRNG* rng, Array_u32 seed_data) {
	if (seed_data.len != 2) {
		eprintln(_SLIT("WyRandRNG needs 2 32-bit unsigned integers as the seed."));
		v_exit(1);
	}
	rng->state = ((*(u32*)/*ee elem_typ */array_get(seed_data, 0)) | (((u64)((*(u32*)/*ee elem_typ */array_get(seed_data, 1)))) << 32));
	rng->has_extra = false;
}

// Attr: [inline]
inline u32 rand__wyrand__WyRandRNG_u32(rand__wyrand__WyRandRNG* rng) {
	if (rng->has_extra) {
		rng->has_extra = false;
		 u32 _t742 = rng->extra;
		// autofree_scope_vars(pos=1069 line_nr=39 scope.pos=1042 scope.end_pos=1088)
		// af parent scope:
		// var "rng" var.pos=997 var.line_nr=36
		// var "full_value" var.pos=1091 var.line_nr=41
		// var "lower" var.pos=1116 var.line_nr=42
		// var "upper" var.pos=1165 var.line_nr=43
		// af parent scope:
		// af parent scope:
		return _t742;
	}
	u64 full_value = rand__wyrand__WyRandRNG_u64(rng);
	u32 lower = ((u32)((full_value & _const_rand__constants__lower_mask)));
	u32 upper = ((u32)(full_value >> 32));
	rng->extra = upper;
	rng->has_extra = true;
	// autofree_scope_vars(pos=1237 line_nr=46 scope.pos=992 scope.end_pos=1251)
	// var "rng" var.pos=997 var.line_nr=36
	// var "full_value" var.pos=1091 var.line_nr=41
	// var "lower" var.pos=1116 var.line_nr=42
	// var "upper" var.pos=1165 var.line_nr=43
	// af parent scope:
	// af parent scope:
	return lower;
}

// Attr: [inline]
inline u64 rand__wyrand__WyRandRNG_u64(rand__wyrand__WyRandRNG* rng) {
	{ // Unsafe block
		u64 seed1 = rng->state;
		seed1 += _const_rand__wyrand__wyp0;
		rng->state = seed1;
		 u64 _t743 = hash__wymum((seed1 ^ _const_rand__wyrand__wyp1), seed1);
		// autofree_scope_vars(pos=1452 line_nr=56 scope.pos=1385 scope.end_pos=1500)
		// var "seed1" var.pos=1389 var.line_nr=53
		// af parent scope:
		// var "rng" var.pos=1346 var.line_nr=51
		// af parent scope:
		// af parent scope:
		return _t743;
	}
	 u64 _t744 = 0;
	// autofree_scope_vars(pos=1502 line_nr=58 scope.pos=1341 scope.end_pos=1512)
	// var "rng" var.pos=1346 var.line_nr=51
	// af parent scope:
	// af parent scope:
	return _t744;
}

// Attr: [inline]
inline u32 rand__wyrand__WyRandRNG_u32n(rand__wyrand__WyRandRNG* rng, u32 max) {
	if (max == 0) {
		eprintln(_SLIT("max must be positive integer"));
		v_exit(1);
	}
	int bit_len = math__bits__len_32(max);
	if (bit_len == 32) {
		for (;;) {
			u32 value = rand__wyrand__WyRandRNG_u32(rng);
			if (value < max) {
				// autofree_scope_vars(pos=1849 line_nr=74 scope.pos=1844 scope.end_pos=1866)
				// af parent scope:
				// var "value" var.pos=1807 var.line_nr=72
				// af parent scope:
				// af parent scope:
				// var "rng" var.pos=1590 var.line_nr=63
				// var "max" var.pos=1610 var.line_nr=63
				// var "bit_len" var.pos=1748 var.line_nr=69
				// af parent scope:
				// af parent scope:
				return value;
			}
		}
	} else {
		u32 mask = (((u32)(1U)) << (bit_len + 1)) - 1;
		for (;;) {
			u32 value = (rand__wyrand__WyRandRNG_u32(rng) & mask);
			if (value < max) {
				// autofree_scope_vars(pos=1982 line_nr=82 scope.pos=1977 scope.end_pos=1999)
				// af parent scope:
				// var "value" var.pos=1933 var.line_nr=80
				// af parent scope:
				// var "mask" var.pos=1884 var.line_nr=78
				// af parent scope:
				// var "rng" var.pos=1590 var.line_nr=63
				// var "max" var.pos=1610 var.line_nr=63
				// var "bit_len" var.pos=1748 var.line_nr=69
				// af parent scope:
				// af parent scope:
				return value;
			}
		}
	}
	 u32 _t745 = ((u32)(0U));
	// autofree_scope_vars(pos=2008 line_nr=86 scope.pos=1585 scope.end_pos=2023)
	// var "rng" var.pos=1590 var.line_nr=63
	// var "max" var.pos=1610 var.line_nr=63
	// var "bit_len" var.pos=1748 var.line_nr=69
	// af parent scope:
	// af parent scope:
	return _t745;
}

// Attr: [inline]
inline u64 rand__wyrand__WyRandRNG_u64n(rand__wyrand__WyRandRNG* rng, u64 max) {
	if (max == 0) {
		eprintln(_SLIT("max must be positive integer"));
		v_exit(1);
	}
	int bit_len = math__bits__len_64(max);
	if (bit_len == 64) {
		for (;;) {
			u64 value = rand__wyrand__WyRandRNG_u64(rng);
			if (value < max) {
				// autofree_scope_vars(pos=2309 line_nr=101 scope.pos=2304 scope.end_pos=2326)
				// af parent scope:
				// var "value" var.pos=2267 var.line_nr=99
				// af parent scope:
				// af parent scope:
				// var "rng" var.pos=2101 var.line_nr=91
				// var "max" var.pos=2121 var.line_nr=91
				// var "bit_len" var.pos=2208 var.line_nr=96
				// af parent scope:
				// af parent scope:
				return value;
			}
		}
	} else {
		u64 mask = (((u64)(1U)) << (bit_len + 1)) - 1;
		for (;;) {
			u64 value = (rand__wyrand__WyRandRNG_u64(rng) & mask);
			if (value < max) {
				// autofree_scope_vars(pos=2442 line_nr=109 scope.pos=2437 scope.end_pos=2459)
				// af parent scope:
				// var "value" var.pos=2393 var.line_nr=107
				// af parent scope:
				// var "mask" var.pos=2344 var.line_nr=105
				// af parent scope:
				// var "rng" var.pos=2101 var.line_nr=91
				// var "max" var.pos=2121 var.line_nr=91
				// var "bit_len" var.pos=2208 var.line_nr=96
				// af parent scope:
				// af parent scope:
				return value;
			}
		}
	}
	 u64 _t746 = ((u64)(0U));
	// autofree_scope_vars(pos=2468 line_nr=113 scope.pos=2096 scope.end_pos=2483)
	// var "rng" var.pos=2101 var.line_nr=91
	// var "max" var.pos=2121 var.line_nr=91
	// var "bit_len" var.pos=2208 var.line_nr=96
	// af parent scope:
	// af parent scope:
	return _t746;
}

// Attr: [inline]
inline u32 rand__wyrand__WyRandRNG_u32_in_range(rand__wyrand__WyRandRNG* rng, u32 min, u32 max) {
	if (max <= min) {
		eprintln(_SLIT("max must be greater than min"));
		v_exit(1);
	}
	 u32 _t747 = min + rand__wyrand__WyRandRNG_u32n(rng, max - min);
	// autofree_scope_vars(pos=2723 line_nr=123 scope.pos=2593 scope.end_pos=2757)
	// var "rng" var.pos=2598 var.line_nr=118
	// var "min" var.pos=2626 var.line_nr=118
	// var "max" var.pos=2635 var.line_nr=118
	// af parent scope:
	// af parent scope:
	return _t747;
}

// Attr: [inline]
inline u64 rand__wyrand__WyRandRNG_u64_in_range(rand__wyrand__WyRandRNG* rng, u64 min, u64 max) {
	if (max <= min) {
		eprintln(_SLIT("max must be greater than min"));
		v_exit(1);
	}
	 u64 _t748 = min + rand__wyrand__WyRandRNG_u64n(rng, max - min);
	// autofree_scope_vars(pos=2997 line_nr=133 scope.pos=2867 scope.end_pos=3031)
	// var "rng" var.pos=2872 var.line_nr=128
	// var "min" var.pos=2900 var.line_nr=128
	// var "max" var.pos=2909 var.line_nr=128
	// af parent scope:
	// af parent scope:
	return _t748;
}

// Attr: [inline]
inline int rand__wyrand__WyRandRNG_int(rand__wyrand__WyRandRNG* rng) {
	 int _t749 = ((int)(rand__wyrand__WyRandRNG_u32(rng)));
	// autofree_scope_vars(pos=3146 line_nr=139 scope.pos=3114 scope.end_pos=3169)
	// var "rng" var.pos=3119 var.line_nr=138
	// af parent scope:
	// af parent scope:
	return _t749;
}

// Attr: [inline]
inline i64 rand__wyrand__WyRandRNG_i64(rand__wyrand__WyRandRNG* rng) {
	 i64 _t750 = ((i64)(rand__wyrand__WyRandRNG_u64(rng)));
	// autofree_scope_vars(pos=3284 line_nr=145 scope.pos=3252 scope.end_pos=3307)
	// var "rng" var.pos=3257 var.line_nr=144
	// af parent scope:
	// af parent scope:
	return _t750;
}

// Attr: [inline]
inline int rand__wyrand__WyRandRNG_int31(rand__wyrand__WyRandRNG* rng) {
	 int _t751 = ((int)((rand__wyrand__WyRandRNG_u32(rng) & _const_rand__constants__u31_mask)));
	// autofree_scope_vars(pos=3415 line_nr=151 scope.pos=3381 scope.end_pos=3485)
	// var "rng" var.pos=3386 var.line_nr=150
	// af parent scope:
	// af parent scope:
	return _t751;
}

// Attr: [inline]
inline i64 rand__wyrand__WyRandRNG_int63(rand__wyrand__WyRandRNG* rng) {
	 i64 _t752 = ((i64)((rand__wyrand__WyRandRNG_u64(rng) & _const_rand__constants__u63_mask)));
	// autofree_scope_vars(pos=3593 line_nr=157 scope.pos=3559 scope.end_pos=3663)
	// var "rng" var.pos=3564 var.line_nr=156
	// af parent scope:
	// af parent scope:
	return _t752;
}

// Attr: [inline]
inline int rand__wyrand__WyRandRNG_intn(rand__wyrand__WyRandRNG* rng, int max) {
	if (max <= 0) {
		eprintln(_SLIT("max has to be positive."));
		v_exit(1);
	}
	 int _t753 = ((int)(rand__wyrand__WyRandRNG_u32n(rng, ((u32)(max)))));
	// autofree_scope_vars(pos=3846 line_nr=167 scope.pos=3740 scope.end_pos=3878)
	// var "rng" var.pos=3745 var.line_nr=162
	// var "max" var.pos=3765 var.line_nr=162
	// af parent scope:
	// af parent scope:
	return _t753;
}

// Attr: [inline]
inline i64 rand__wyrand__WyRandRNG_i64n(rand__wyrand__WyRandRNG* rng, i64 max) {
	if (max <= 0) {
		eprintln(_SLIT("max has to be positive."));
		v_exit(1);
	}
	 i64 _t754 = ((i64)(rand__wyrand__WyRandRNG_u64n(rng, ((u64)(max)))));
	// autofree_scope_vars(pos=4063 line_nr=177 scope.pos=3957 scope.end_pos=4095)
	// var "rng" var.pos=3962 var.line_nr=172
	// var "max" var.pos=3982 var.line_nr=172
	// af parent scope:
	// af parent scope:
	return _t754;
}

// Attr: [inline]
inline int rand__wyrand__WyRandRNG_int_in_range(rand__wyrand__WyRandRNG* rng, int min, int max) {
	if (max <= min) {
		eprintln(_SLIT("max must be greater than min"));
		v_exit(1);
	}
	 int _t755 = min + rand__wyrand__WyRandRNG_intn(rng, max - min);
	// autofree_scope_vars(pos=4396 line_nr=188 scope.pos=4182 scope.end_pos=4430)
	// var "rng" var.pos=4187 var.line_nr=182
	// var "min" var.pos=4215 var.line_nr=182
	// var "max" var.pos=4224 var.line_nr=182
	// af parent scope:
	// af parent scope:
	return _t755;
}

// Attr: [inline]
inline i64 rand__wyrand__WyRandRNG_i64_in_range(rand__wyrand__WyRandRNG* rng, i64 min, i64 max) {
	if (max <= min) {
		eprintln(_SLIT("max must be greater than min"));
		v_exit(1);
	}
	 i64 _t756 = min + rand__wyrand__WyRandRNG_i64n(rng, max - min);
	// autofree_scope_vars(pos=4647 line_nr=198 scope.pos=4517 scope.end_pos=4681)
	// var "rng" var.pos=4522 var.line_nr=193
	// var "min" var.pos=4550 var.line_nr=193
	// var "max" var.pos=4559 var.line_nr=193
	// af parent scope:
	// af parent scope:
	return _t756;
}

// Attr: [inline]
inline f32 rand__wyrand__WyRandRNG_f32(rand__wyrand__WyRandRNG* rng) {
	 f32 _t757 = ((f32)(rand__wyrand__WyRandRNG_u32(rng))) / _const_rand__constants__max_u32_as_f32;
	// autofree_scope_vars(pos=4793 line_nr=204 scope.pos=4761 scope.end_pos=4843)
	// var "rng" var.pos=4766 var.line_nr=203
	// af parent scope:
	// af parent scope:
	return _t757;
}

// Attr: [inline]
inline f64 rand__wyrand__WyRandRNG_f64(rand__wyrand__WyRandRNG* rng) {
	 f64 _t758 = ((f64)(rand__wyrand__WyRandRNG_u64(rng))) / _const_rand__constants__max_u64_as_f64;
	// autofree_scope_vars(pos=4955 line_nr=210 scope.pos=4923 scope.end_pos=5005)
	// var "rng" var.pos=4928 var.line_nr=209
	// af parent scope:
	// af parent scope:
	return _t758;
}

// Attr: [inline]
inline f32 rand__wyrand__WyRandRNG_f32n(rand__wyrand__WyRandRNG* rng, f32 max) {
	if (max <= 0) {
		eprintln(_SLIT("max has to be positive."));
		v_exit(1);
	}
	 f32 _t759 = rand__wyrand__WyRandRNG_f32(rng) * max;
	// autofree_scope_vars(pos=5194 line_nr=220 scope.pos=5088 scope.end_pos=5218)
	// var "rng" var.pos=5093 var.line_nr=215
	// var "max" var.pos=5113 var.line_nr=215
	// af parent scope:
	// af parent scope:
	return _t759;
}

// Attr: [inline]
inline f64 rand__wyrand__WyRandRNG_f64n(rand__wyrand__WyRandRNG* rng, f64 max) {
	if (max <= 0) {
		eprintln(_SLIT("max has to be positive."));
		v_exit(1);
	}
	 f64 _t760 = rand__wyrand__WyRandRNG_f64(rng) * max;
	// autofree_scope_vars(pos=5407 line_nr=230 scope.pos=5301 scope.end_pos=5431)
	// var "rng" var.pos=5306 var.line_nr=225
	// var "max" var.pos=5326 var.line_nr=225
	// af parent scope:
	// af parent scope:
	return _t760;
}

// Attr: [inline]
inline f32 rand__wyrand__WyRandRNG_f32_in_range(rand__wyrand__WyRandRNG* rng, f32 min, f32 max) {
	if (max <= min) {
		eprintln(_SLIT("max must be greater than min"));
		v_exit(1);
	}
	 f32 _t761 = min + rand__wyrand__WyRandRNG_f32n(rng, max - min);
	// autofree_scope_vars(pos=5648 line_nr=240 scope.pos=5518 scope.end_pos=5682)
	// var "rng" var.pos=5523 var.line_nr=235
	// var "min" var.pos=5551 var.line_nr=235
	// var "max" var.pos=5560 var.line_nr=235
	// af parent scope:
	// af parent scope:
	return _t761;
}

// Attr: [inline]
inline f64 rand__wyrand__WyRandRNG_f64_in_range(rand__wyrand__WyRandRNG* rng, f64 min, f64 max) {
	if (max <= min) {
		eprintln(_SLIT("max must be greater than min"));
		v_exit(1);
	}
	 f64 _t762 = min + rand__wyrand__WyRandRNG_f64n(rng, max - min);
	// autofree_scope_vars(pos=5899 line_nr=250 scope.pos=5769 scope.end_pos=5933)
	// var "rng" var.pos=5774 var.line_nr=245
	// var "min" var.pos=5802 var.line_nr=245
	// var "max" var.pos=5811 var.line_nr=245
	// af parent scope:
	// af parent scope:
	return _t762;
}

VV_LOCAL_SYMBOL void rand__init(void) {
	default_rng = rand__new_default((rand__PRNGConfigStruct){.seed = rand__seed__time_seed_array(2),});
}

rand__PRNG* rand__new_default(rand__PRNGConfigStruct config) {
	rand__wyrand__WyRandRNG* rng = (rand__wyrand__WyRandRNG*)memdup(&(rand__wyrand__WyRandRNG){.state = rand__seed__time_seed_64(),.has_extra = 0,.extra = 0,}, sizeof(rand__wyrand__WyRandRNG));
	rand__wyrand__WyRandRNG_seed(rng, config.seed);
	// autofree_scope_vars(pos=1793 line_nr=56 scope.pos=1693 scope.end_pos=1805)
	// var "config" var.pos=1705 var.line_nr=53
	// var "rng" var.pos=1743 var.line_nr=54
	// af parent scope:
	// af parent scope:
	return HEAP(rand__PRNG, I_rand__wyrand__WyRandRNG_to_Interface_rand__PRNG(rng));
}

rand__PRNG* rand__get_current_rng(void) {
	// autofree_scope_vars(pos=1970 line_nr=61 scope.pos=1944 scope.end_pos=1990)
	// af parent scope:
	// af parent scope:
	return default_rng;
}

void rand__set_rng(rand__PRNG* rng) {
	default_rng = rng;
}

void rand__seed(Array_u32 seed) {
	rand__PRNG_name_table[default_rng->_typ]._method_seed(default_rng->_object, seed);
}

u32 rand__u32(void) {
	 u32 _t763 = rand__PRNG_name_table[default_rng->_typ]._method_u32(default_rng->_object);
	// autofree_scope_vars(pos=2848 line_nr=82 scope.pos=2836 scope.end_pos=2874)
	// af parent scope:
	// af parent scope:
	return _t763;
}

u64 rand__u64(void) {
	 u64 _t764 = rand__PRNG_name_table[default_rng->_typ]._method_u64(default_rng->_object);
	// autofree_scope_vars(pos=2966 line_nr=87 scope.pos=2954 scope.end_pos=2992)
	// af parent scope:
	// af parent scope:
	return _t764;
}

u32 rand__u32n(u32 max) {
	 u32 _t765 = rand__PRNG_name_table[default_rng->_typ]._method_u32n(default_rng->_object, max);
	// autofree_scope_vars(pos=3125 line_nr=92 scope.pos=3105 scope.end_pos=3155)
	// var "max" var.pos=3110 var.line_nr=91
	// af parent scope:
	// af parent scope:
	return _t765;
}

u64 rand__u64n(u64 max) {
	 u64 _t766 = rand__PRNG_name_table[default_rng->_typ]._method_u64n(default_rng->_object, max);
	// autofree_scope_vars(pos=3288 line_nr=97 scope.pos=3268 scope.end_pos=3318)
	// var "max" var.pos=3273 var.line_nr=96
	// af parent scope:
	// af parent scope:
	return _t766;
}

u32 rand__u32_in_range(u32 min, u32 max) {
	 u32 _t767 = rand__PRNG_name_table[default_rng->_typ]._method_u32_in_range(default_rng->_object, min, max);
	// autofree_scope_vars(pos=3471 line_nr=102 scope.pos=3434 scope.end_pos=3514)
	// var "min" var.pos=3447 var.line_nr=101
	// var "max" var.pos=3456 var.line_nr=101
	// af parent scope:
	// af parent scope:
	return _t767;
}

u64 rand__u64_in_range(u64 min, u64 max) {
	 u64 _t768 = rand__PRNG_name_table[default_rng->_typ]._method_u64_in_range(default_rng->_object, min, max);
	// autofree_scope_vars(pos=3667 line_nr=107 scope.pos=3630 scope.end_pos=3710)
	// var "min" var.pos=3643 var.line_nr=106
	// var "max" var.pos=3652 var.line_nr=106
	// af parent scope:
	// af parent scope:
	return _t768;
}

int rand__int(void) {
	 int _t769 = rand__PRNG_name_table[default_rng->_typ]._method_v_int(default_rng->_object);
	// autofree_scope_vars(pos=3825 line_nr=112 scope.pos=3813 scope.end_pos=3851)
	// af parent scope:
	// af parent scope:
	return _t769;
}

int rand__intn(int max) {
	 int _t770 = rand__PRNG_name_table[default_rng->_typ]._method_intn(default_rng->_object, max);
	// autofree_scope_vars(pos=3984 line_nr=117 scope.pos=3964 scope.end_pos=4014)
	// var "max" var.pos=3969 var.line_nr=116
	// af parent scope:
	// af parent scope:
	return _t770;
}

byte rand__byte(void) {
	 byte _t771 = ((byte)((rand__PRNG_name_table[default_rng->_typ]._method_u32(default_rng->_object) & 0xff)));
	// autofree_scope_vars(pos=4123 line_nr=122 scope.pos=4109 scope.end_pos=4162)
	// af parent scope:
	// af parent scope:
	return _t771;
}

int rand__int_in_range(int min, int max) {
	 int _t772 = rand__PRNG_name_table[default_rng->_typ]._method_int_in_range(default_rng->_object, min, max);
	// autofree_scope_vars(pos=4383 line_nr=128 scope.pos=4346 scope.end_pos=4426)
	// var "min" var.pos=4359 var.line_nr=127
	// var "max" var.pos=4368 var.line_nr=127
	// af parent scope:
	// af parent scope:
	return _t772;
}

int rand__int31(void) {
	 int _t773 = rand__PRNG_name_table[default_rng->_typ]._method_int31(default_rng->_object);
	// autofree_scope_vars(pos=4534 line_nr=133 scope.pos=4520 scope.end_pos=4562)
	// af parent scope:
	// af parent scope:
	return _t773;
}

i64 rand__i64(void) {
	 i64 _t774 = rand__PRNG_name_table[default_rng->_typ]._method_i64(default_rng->_object);
	// autofree_scope_vars(pos=4677 line_nr=138 scope.pos=4665 scope.end_pos=4703)
	// af parent scope:
	// af parent scope:
	return _t774;
}

i64 rand__i64n(i64 max) {
	 i64 _t775 = rand__PRNG_name_table[default_rng->_typ]._method_i64n(default_rng->_object, max);
	// autofree_scope_vars(pos=4836 line_nr=143 scope.pos=4816 scope.end_pos=4866)
	// var "max" var.pos=4821 var.line_nr=142
	// af parent scope:
	// af parent scope:
	return _t775;
}

i64 rand__i64_in_range(i64 min, i64 max) {
	 i64 _t776 = rand__PRNG_name_table[default_rng->_typ]._method_i64_in_range(default_rng->_object, min, max);
	// autofree_scope_vars(pos=5017 line_nr=148 scope.pos=4980 scope.end_pos=5060)
	// var "min" var.pos=4993 var.line_nr=147
	// var "max" var.pos=5002 var.line_nr=147
	// af parent scope:
	// af parent scope:
	return _t776;
}

i64 rand__int63(void) {
	 i64 _t777 = rand__PRNG_name_table[default_rng->_typ]._method_int63(default_rng->_object);
	// autofree_scope_vars(pos=5168 line_nr=153 scope.pos=5154 scope.end_pos=5196)
	// af parent scope:
	// af parent scope:
	return _t777;
}

f32 rand__f32(void) {
	 f32 _t778 = rand__PRNG_name_table[default_rng->_typ]._method_f32(default_rng->_object);
	// autofree_scope_vars(pos=5298 line_nr=158 scope.pos=5286 scope.end_pos=5324)
	// af parent scope:
	// af parent scope:
	return _t778;
}

f64 rand__f64(void) {
	 f64 _t779 = rand__PRNG_name_table[default_rng->_typ]._method_f64(default_rng->_object);
	// autofree_scope_vars(pos=5426 line_nr=163 scope.pos=5414 scope.end_pos=5452)
	// af parent scope:
	// af parent scope:
	return _t779;
}

f32 rand__f32n(f32 max) {
	 f32 _t780 = rand__PRNG_name_table[default_rng->_typ]._method_f32n(default_rng->_object, max);
	// autofree_scope_vars(pos=5565 line_nr=168 scope.pos=5545 scope.end_pos=5595)
	// var "max" var.pos=5550 var.line_nr=167
	// af parent scope:
	// af parent scope:
	return _t780;
}

f64 rand__f64n(f64 max) {
	 f64 _t781 = rand__PRNG_name_table[default_rng->_typ]._method_f64n(default_rng->_object, max);
	// autofree_scope_vars(pos=5708 line_nr=173 scope.pos=5688 scope.end_pos=5738)
	// var "max" var.pos=5693 var.line_nr=172
	// af parent scope:
	// af parent scope:
	return _t781;
}

f32 rand__f32_in_range(f32 min, f32 max) {
	 f32 _t782 = rand__PRNG_name_table[default_rng->_typ]._method_f32_in_range(default_rng->_object, min, max);
	// autofree_scope_vars(pos=5878 line_nr=178 scope.pos=5841 scope.end_pos=5921)
	// var "min" var.pos=5854 var.line_nr=177
	// var "max" var.pos=5863 var.line_nr=177
	// af parent scope:
	// af parent scope:
	return _t782;
}

f64 rand__f64_in_range(f64 min, f64 max) {
	 f64 _t783 = rand__PRNG_name_table[default_rng->_typ]._method_f64_in_range(default_rng->_object, min, max);
	// autofree_scope_vars(pos=6061 line_nr=183 scope.pos=6024 scope.end_pos=6104)
	// var "min" var.pos=6037 var.line_nr=182
	// var "max" var.pos=6046 var.line_nr=182
	// af parent scope:
	// af parent scope:
	return _t783;
}

string rand__string_from_set(string charset, int len) {
	if (len == 0) {
		 string _t784 = _SLIT("");
		// autofree_scope_vars(pos=6533 line_nr=195 scope.pos=6530 scope.end_pos=6545)
		// af parent scope:
		// var "charset" var.pos=6483 var.line_nr=193
		// var "len" var.pos=6499 var.line_nr=193
		// var "buf" var.pos=6552 var.line_nr=197
		// af parent scope:
		// af parent scope:
		return _t784;
	}
	byte* buf = v_malloc(len);
	for (int i = 0; i < len; ++i) {
		{ // Unsafe block
			buf[i] = string_at(charset, rand__intn(charset.len));
		}
	}
	 string _t785 = byte_vstring_with_len(buf, len);
	// autofree_scope_vars(pos=6660 line_nr=203 scope.pos=6467 scope.end_pos=6705)
	// var "charset" var.pos=6483 var.line_nr=193
	// var "len" var.pos=6499 var.line_nr=193
	// var "buf" var.pos=6552 var.line_nr=197
	// af parent scope:
	// af parent scope:
	return _t785;
}

string rand__string(int len) {
	 string _t786 = rand__string_from_set(_const_rand__english_letters, len);
	// autofree_scope_vars(pos=6833 line_nr=208 scope.pos=6808 scope.end_pos=6884)
	// var "len" var.pos=6815 var.line_nr=207
	// af parent scope:
	// af parent scope:
	return _t786;
}

string rand__hex(int len) {
	 string _t787 = rand__string_from_set(_const_rand__hex_chars, len);
	// autofree_scope_vars(pos=7018 line_nr=213 scope.pos=6996 scope.end_pos=7063)
	// var "len" var.pos=7000 var.line_nr=212
	// af parent scope:
	// af parent scope:
	return _t787;
}

string rand__ascii(int len) {
	 string _t788 = rand__string_from_set(_const_rand__ascii_chars, len);
	// autofree_scope_vars(pos=7183 line_nr=218 scope.pos=7159 scope.end_pos=7230)
	// var "len" var.pos=7165 var.line_nr=217
	// af parent scope:
	// af parent scope:
	return _t788;
}

string rand__uuid_v4(void) {
	int buflen = 36;
	byte* buf = v_malloc(37);
	int i_buf = 0;
	u64 x = ((u64)(0U));
	byte d = ((byte)(0));
	for (;;) {
		if (!(i_buf < buflen)) break;
		int c = 0;
		x = rand__PRNG_name_table[default_rng->_typ]._method_u64(default_rng->_object);
		x &= 0x0F0F0F0F0F0F0F0F;
		x += 0x3030303030303030;
		for (;;) {
			if (!(c < 8 && i_buf < buflen)) break;
			d = ((byte)(x));
			{ // Unsafe block
				buf[i_buf] = (d > 0x39 ? (d + 0x27) : (d));
			}
			i_buf++;
			c++;
			x = x >> 8;
		}
	}
	x = x >> 8;
	d = ((byte)(x));
	{ // Unsafe block
		buf[19] = (d > 0x39 ? (d + 0x27) : (d));
		buf[8] = L'-';
		buf[13] = L'-';
		buf[18] = L'-';
		buf[23] = L'-';
		buf[14] = L'4';
		buf[buflen] = 0;
		 string _t789 = byte_vstring_with_len(buf, buflen);
		// autofree_scope_vars(pos=8063 line_nr=257 scope.pos=7919 scope.end_pos=8101)
		// af parent scope:
		// var "buflen" var.pos=7386 var.line_nr=224
		// var "buf" var.pos=7404 var.line_nr=225
		// var "i_buf" var.pos=7438 var.line_nr=226
		// var "x" var.pos=7454 var.line_nr=227
		// var "d" var.pos=7471 var.line_nr=228
		// af parent scope:
		// af parent scope:
		return _t789;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

string rand__ulid(void) {
	 string _t790 = rand__ulid_at_millisecond(time__Time_unix_time_milli(time__utc()));
	// autofree_scope_vars(pos=8530 line_nr=272 scope.pos=8514 scope.end_pos=8588)
	// af parent scope:
	// af parent scope:
	return _t790;
}

string rand__ulid_at_millisecond(u64 unix_time_milli) {
	int buflen = 26;
	byte* buf = v_malloc(27);
	u64 t = unix_time_milli;
	int i = 9;
	for (;;) {
		if (!(i >= 0)) break;
		{ // Unsafe block
			buf[i] = string_at(_const_rand__ulid_encoding, (t & 0x1F));
		}
		t = t >> 5;
		i--;
	}
	u64 x = rand__PRNG_name_table[default_rng->_typ]._method_u64(default_rng->_object);
	i = 10;
	for (;;) {
		if (!(i < 19)) break;
		{ // Unsafe block
			buf[i] = string_at(_const_rand__ulid_encoding, (x & 0x1F));
		}
		x = x >> 5;
		i++;
	}
	x = rand__PRNG_name_table[default_rng->_typ]._method_u64(default_rng->_object);
	for (;;) {
		if (!(i < 26)) break;
		{ // Unsafe block
			buf[i] = string_at(_const_rand__ulid_encoding, (x & 0x1F));
		}
		x = x >> 5;
		i++;
	}
	{ // Unsafe block
		buf[26] = 0;
		 string _t791 = byte_vstring_with_len(buf, buflen);
		// autofree_scope_vars(pos=9249 line_nr=309 scope.pos=9236 scope.end_pos=9287)
		// af parent scope:
		// var "unix_time_milli" var.pos=8734 var.line_nr=276
		// var "buflen" var.pos=8765 var.line_nr=277
		// var "buf" var.pos=8783 var.line_nr=278
		// var "t" var.pos=8817 var.line_nr=279
		// var "i" var.pos=8843 var.line_nr=280
		// var "x" var.pos=8966 var.line_nr=289
		// af parent scope:
		// af parent scope:
		return _t791;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

v__pref__Preferences* v__pref__new_preferences(void) {
	v__pref__Preferences* p = (v__pref__Preferences*)memdup(&(v__pref__Preferences){.os = 0,.backend = 0,.build_mode = 0,.arch = 0,.output_mode = v__pref__OutputMode_stdout,.is_verbose = 0,.is_watch = 0,.is_test = 0,.is_script = 0,.is_vsh = 0,.is_livemain = 0,.is_liveshared = 0,.is_shared = 0,.is_prof = 0,.profile_file = (string){.str=(byteptr)"", .is_lit=1},.profile_no_inline = 0,.translated = 0,.is_prod = 0,.obfuscate = 0,.is_repl = 0,.is_run = 0,.sanitize = 0,.is_debug = 0,.is_vlines = 0,.show_cc = 0,.show_c_output = 0,.dump_c_flags = (string){.str=(byteptr)"", .is_lit=1},.use_cache = 0,.retry_compilation = true,.is_stats = 0,.cflags = (string){.str=(byteptr)"", .is_lit=1},.m64 = 0,.ccompiler = (string){.str=(byteptr)"", .is_lit=1},.ccompiler_type = 0,.third_party_option = (string){.str=(byteptr)"", .is_lit=1},.building_v = 0,.autofree = 0,.compress = 0,.enable_globals = 0,.is_fmt = 0,.is_vet = 0,.is_bare = 0,.no_preludes = 0,.custom_prelude = (string){.str=(byteptr)"", .is_lit=1},.lookup_path = __new_array(0, 1, sizeof(string)),.bare_builtin_dir = (string){.str=(byteptr)"", .is_lit=1},.output_cross_c = 0,.prealloc = 0,.vroot = (string){.str=(byteptr)"", .is_lit=1},.out_name_c = (string){.str=(byteptr)"", .is_lit=1},.out_name = (string){.str=(byteptr)"", .is_lit=1},.path = (string){.str=(byteptr)"", .is_lit=1},.compile_defines = __new_array(0, 1, sizeof(string)),.compile_defines_all = __new_array(0, 1, sizeof(string)),.run_args = __new_array(0, 1, sizeof(string)),.printfn_list = __new_array(0, 1, sizeof(string)),.print_v_files = 0,.skip_running = 0,.skip_warnings = 0,.warn_impure_v = 0,.warns_are_errors = 0,.fatal_errors = 0,.reuse_tmpc = 0,.use_color = 0,.is_parallel = 0,.error_limit = 0,.is_vweb = 0,.only_check_syntax = 0,.experimental = 0,.skip_unused = 0,.show_timings = 0,.is_ios_simulator = 0,.is_apk = 0,.cleanup_files = __new_array(0, 1, sizeof(string)),.build_options = __new_array(0, 1, sizeof(string)),.cache_manager = (v__vcache__CacheManager){.k2cpath = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),},.is_help = 0,.gc_mode = v__pref__GarbageCollectionMode_no_gc,.checker_match_exhaustive_cutoff_limit = 10,}, sizeof(v__pref__Preferences));
	v__pref__Preferences_fill_with_defaults(p);
	// autofree_scope_vars(pos=355 line_nr=15 scope.pos=273 scope.end_pos=365)
	// var "p" var.pos=311 var.line_nr=13
	// af parent scope:
	// af parent scope:
	return p;
}

VV_LOCAL_SYMBOL void v__pref__Preferences_expand_lookup_paths(v__pref__Preferences* p) {
	if ((p->vroot).len == 0) {
		p->vroot = os__dir(v__pref__vexe_path());
	}
	string vlib_path = os__join_path(p->vroot, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("vlib")})));
	if (p->lookup_path.len == 0) {
		p->lookup_path = new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT("@vlib"), _SLIT("@vmodules")}));
	}
	Array_string expanded_paths = __new_array_with_default(0, 0, sizeof(string), 0);
	// FOR IN array
	for (int _t792 = 0; _t792 < p->lookup_path.len; ++_t792) {
		string path = ((string*)p->lookup_path.data)[_t792];

		if (string_eq(path, _SLIT("@vlib"))) {
			array_push(&expanded_paths, _MOV((string[]){ string_clone(vlib_path) }));
		}
		else if (string_eq(path, _SLIT("@vmodules"))) {
			_PUSH_MANY(&expanded_paths, (os__vmodules_paths()), _t794, Array_string);
		}
		else {
			array_push(&expanded_paths, _MOV((string[]){ string_clone(path) }));
		};
	}
	p->lookup_path = expanded_paths;
}

void v__pref__Preferences_fill_with_defaults(v__pref__Preferences* p) {
	v__pref__Preferences_expand_lookup_paths(p);
	string rpath = os__real_path(p->path);
	if ((p->out_name).len == 0) {
		string filename = string_trim_space(os__file_name(rpath));
		string base = string_all_before_last(filename, _SLIT("."));
		if ((base).len == 0) {
			base = filename;
		}
		string target_dir = (os__is_dir(rpath) ? (rpath) : (os__dir(rpath)));
		p->out_name = os__join_path(target_dir, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){base})));
		if (string_eq(rpath, _STR("%.*s\000/cmd/v", 2, p->vroot)) && os__is_dir(_SLIT("vlib/compiler"))) {
			println(_SLIT("Saving the resulting V executable in `./v2`"));
			println(string_add(_SLIT("Use `v -o v cmd/v` if you want to replace current "), _SLIT("V execuast.")));
			p->out_name = _SLIT("v2");
		}
	}
	string rpath_name = os__file_name(rpath);
	p->building_v = !p->is_repl && (string_eq(rpath_name, _SLIT("v")) || string_eq(rpath_name, _SLIT("vfmt.v")));
	if (p->os == v__pref__OS__auto) {
		p->os = v__pref__get_host_os();
	}
	v__pref__Preferences_try_to_use_tcc_by_default(p);
	if ((p->ccompiler).len == 0) {
		p->ccompiler = v__pref__default_c_compiler();
	}
	v__pref__Preferences_find_cc_if_cross_compiling(p);
	p->ccompiler_type = v__pref__cc_from_string(p->ccompiler);
	p->is_test = string_ends_with(p->path, _SLIT("_test.v")) || string_ends_with(p->path, _SLIT("_test.vv")) || string_ends_with(string_all_before_last(string_all_before_last(p->path, _SLIT(".v")), _SLIT(".")), _SLIT("_test"));
	p->is_vsh = string_ends_with(p->path, _SLIT(".vsh"));
	p->is_script = p->is_vsh || string_ends_with(p->path, _SLIT(".v")) || string_ends_with(p->path, _SLIT(".vv"));
	if ((p->third_party_option).len == 0) {
		p->third_party_option = p->cflags;
	}
	p->cache_manager = v__vcache__new_cache_manager(new_array_from_c_array(7, 7, sizeof(string), _MOV((string[7]){_SLIT("85e9cf1"), _STR("%.*s\000 | %.*s\000 | %.*s\000 | %.*s\000 | %.*s", 5, v__pref__Backend_str(p->backend), v__pref__OS_str(p->os), p->ccompiler, p->is_prod ? _SLIT("true") : _SLIT("false"), p->sanitize ? _SLIT("true") : _SLIT("false")), string_trim_space(p->cflags), string_trim_space(p->third_party_option), _STR("%.*s", 1, Array_string_str(p->compile_defines_all)), _STR("%.*s", 1, Array_string_str(p->compile_defines)), _STR("%.*s", 1, Array_string_str(p->lookup_path))})));
	if (string_eq(os__user_os(), _SLIT("windows"))) {
		p->use_cache = false;
	}
	if (p->build_mode == v__pref__BuildMode_build_module) {
		p->use_cache = false;
	}
	if (p->is_shared) {
		p->use_cache = false;
	}
	if ((p->bare_builtin_dir).len == 0) {
		p->bare_builtin_dir = os__join_path(p->vroot, new_array_from_c_array(3, 3, sizeof(string), _MOV((string[3]){_SLIT("vlib"), _SLIT("builtin"), _SLIT("linux_bare")})));
	}
}

VV_LOCAL_SYMBOL void v__pref__Preferences_find_cc_if_cross_compiling(v__pref__Preferences* p) {
	if (p->os == v__pref__OS_windows) {
	}
	if (p->os == v__pref__OS_linux) {
		#if !defined(__linux__)
		{
			p->ccompiler = _SLIT("clang");
		}
		#endif
	}
}

VV_LOCAL_SYMBOL void v__pref__Preferences_try_to_use_tcc_by_default(v__pref__Preferences* p) {
	if (string_eq(p->ccompiler, _SLIT("tcc"))) {
		p->ccompiler = v__pref__default_tcc_compiler();
		return;
	}
	if ((p->ccompiler).len == 0) {
		if (p->is_prod) {
			return;
		}
		p->ccompiler = v__pref__default_tcc_compiler();
		return;
	}
}

string v__pref__default_tcc_compiler(void) {
	string vexe = v__pref__vexe_path();
	string vroot = os__dir(vexe);
	string vtccexe = os__join_path(vroot, new_array_from_c_array(3, 3, sizeof(string), _MOV((string[3]){_SLIT("thirdparty"), _SLIT("tcc"), _SLIT("tcc.exe")})));
	if (os__exists(vtccexe)) {
		// autofree_scope_vars(pos=5589 line_nr=177 scope.pos=5586 scope.end_pos=5606)
		// af parent scope:
		// var "vexe" var.pos=5456 var.line_nr=173
		// var "vroot" var.pos=5477 var.line_nr=174
		// var "vtccexe" var.pos=5500 var.line_nr=175
		// af parent scope:
		// af parent scope:
		return vtccexe;
	}
	 string _t796 = _SLIT("");
	// autofree_scope_vars(pos=5608 line_nr=179 scope.pos=5423 scope.end_pos=5619)
	// var "vexe" var.pos=5456 var.line_nr=173
	// var "vroot" var.pos=5477 var.line_nr=174
	// var "vtccexe" var.pos=5500 var.line_nr=175
	// af parent scope:
	// af parent scope:
	return _t796;
}

string v__pref__default_c_compiler(void) {
	 string _t797 = _SLIT("gcc");
	// autofree_scope_vars(pos=5825 line_nr=189 scope.pos=5822 scope.end_pos=5840)
	// af parent scope:
	// af parent scope:
	// af parent scope:
	return _t797;
	 string _t798 = _SLIT("cc");
	// autofree_scope_vars(pos=5842 line_nr=191 scope.pos=5629 scope.end_pos=5855)
	// af parent scope:
	// af parent scope:
	return _t798;
}

string v__pref__vexe_path(void) {
	string vexe = os__getenv(_SLIT("VEXE"));
	if ((vexe).len != 0) {
		// autofree_scope_vars(pos=5931 line_nr=197 scope.pos=5928 scope.end_pos=5945)
		// af parent scope:
		// var "vexe" var.pos=5887 var.line_nr=195
		// var "real_vexe_path" var.pos=5948 var.line_nr=199
		// af parent scope:
		// af parent scope:
		return vexe;
	}
	string real_vexe_path = os__real_path(os__executable());
	os__setenv(_SLIT("VEXE"), real_vexe_path, true);
	// autofree_scope_vars(pos=6037 line_nr=201 scope.pos=5865 scope.end_pos=6060)
	// var "vexe" var.pos=5887 var.line_nr=195
	// var "real_vexe_path" var.pos=5948 var.line_nr=199
	// af parent scope:
	// af parent scope:
	return real_vexe_path;
}

Option_v__pref__OS v__pref__os_from_string(string os_str) {

	if (string_eq(os_str, _SLIT("linux"))) {
		Option_v__pref__OS _t799;
		opt_ok(&(v__pref__OS[]) { v__pref__OS_linux }, (Option*)(&_t799), sizeof(v__pref__OS));
		// autofree_scope_vars(pos=492 line_nr=25 scope.pos=483 scope.end_pos=507)
		// af parent scope:
		// var "os_str" var.pos=444 var.line_nr=23
		// af parent scope:
		// af parent scope:
		return _t799;
	}
	else if (string_eq(os_str, _SLIT("windows"))) {
		Option_v__pref__OS _t800;
		opt_ok(&(v__pref__OS[]) { v__pref__OS_windows }, (Option*)(&_t800), sizeof(v__pref__OS));
		// autofree_scope_vars(pos=522 line_nr=26 scope.pos=511 scope.end_pos=539)
		// af parent scope:
		// var "os_str" var.pos=444 var.line_nr=23
		// af parent scope:
		// af parent scope:
		return _t800;
	}
	else if (string_eq(os_str, _SLIT("ios"))) {
		Option_v__pref__OS _t801;
		opt_ok(&(v__pref__OS[]) { v__pref__OS_ios }, (Option*)(&_t801), sizeof(v__pref__OS));
		// autofree_scope_vars(pos=550 line_nr=27 scope.pos=543 scope.end_pos=563)
		// af parent scope:
		// var "os_str" var.pos=444 var.line_nr=23
		// af parent scope:
		// af parent scope:
		return _t801;
	}
	else if (string_eq(os_str, _SLIT("macos"))) {
		Option_v__pref__OS _t802;
		opt_ok(&(v__pref__OS[]) { v__pref__OS_macos }, (Option*)(&_t802), sizeof(v__pref__OS));
		// autofree_scope_vars(pos=576 line_nr=28 scope.pos=567 scope.end_pos=591)
		// af parent scope:
		// var "os_str" var.pos=444 var.line_nr=23
		// af parent scope:
		// af parent scope:
		return _t802;
	}
	else if (string_eq(os_str, _SLIT("freebsd"))) {
		Option_v__pref__OS _t803;
		opt_ok(&(v__pref__OS[]) { v__pref__OS_freebsd }, (Option*)(&_t803), sizeof(v__pref__OS));
		// autofree_scope_vars(pos=606 line_nr=29 scope.pos=595 scope.end_pos=623)
		// af parent scope:
		// var "os_str" var.pos=444 var.line_nr=23
		// af parent scope:
		// af parent scope:
		return _t803;
	}
	else if (string_eq(os_str, _SLIT("openbsd"))) {
		Option_v__pref__OS _t804;
		opt_ok(&(v__pref__OS[]) { v__pref__OS_openbsd }, (Option*)(&_t804), sizeof(v__pref__OS));
		// autofree_scope_vars(pos=638 line_nr=30 scope.pos=627 scope.end_pos=655)
		// af parent scope:
		// var "os_str" var.pos=444 var.line_nr=23
		// af parent scope:
		// af parent scope:
		return _t804;
	}
	else if (string_eq(os_str, _SLIT("netbsd"))) {
		Option_v__pref__OS _t805;
		opt_ok(&(v__pref__OS[]) { v__pref__OS_netbsd }, (Option*)(&_t805), sizeof(v__pref__OS));
		// autofree_scope_vars(pos=669 line_nr=31 scope.pos=659 scope.end_pos=685)
		// af parent scope:
		// var "os_str" var.pos=444 var.line_nr=23
		// af parent scope:
		// af parent scope:
		return _t805;
	}
	else if (string_eq(os_str, _SLIT("dragonfly"))) {
		Option_v__pref__OS _t806;
		opt_ok(&(v__pref__OS[]) { v__pref__OS_dragonfly }, (Option*)(&_t806), sizeof(v__pref__OS));
		// autofree_scope_vars(pos=702 line_nr=32 scope.pos=689 scope.end_pos=721)
		// af parent scope:
		// var "os_str" var.pos=444 var.line_nr=23
		// af parent scope:
		// af parent scope:
		return _t806;
	}
	else if (string_eq(os_str, _SLIT("js"))) {
		Option_v__pref__OS _t807;
		opt_ok(&(v__pref__OS[]) { v__pref__OS_js }, (Option*)(&_t807), sizeof(v__pref__OS));
		// autofree_scope_vars(pos=731 line_nr=33 scope.pos=725 scope.end_pos=743)
		// af parent scope:
		// var "os_str" var.pos=444 var.line_nr=23
		// af parent scope:
		// af parent scope:
		return _t807;
	}
	else if (string_eq(os_str, _SLIT("solaris"))) {
		Option_v__pref__OS _t808;
		opt_ok(&(v__pref__OS[]) { v__pref__OS_solaris }, (Option*)(&_t808), sizeof(v__pref__OS));
		// autofree_scope_vars(pos=758 line_nr=34 scope.pos=747 scope.end_pos=775)
		// af parent scope:
		// var "os_str" var.pos=444 var.line_nr=23
		// af parent scope:
		// af parent scope:
		return _t808;
	}
	else if (string_eq(os_str, _SLIT("android"))) {
		Option_v__pref__OS _t809;
		opt_ok(&(v__pref__OS[]) { v__pref__OS_android }, (Option*)(&_t809), sizeof(v__pref__OS));
		// autofree_scope_vars(pos=790 line_nr=35 scope.pos=779 scope.end_pos=807)
		// af parent scope:
		// var "os_str" var.pos=444 var.line_nr=23
		// af parent scope:
		// af parent scope:
		return _t809;
	}
	else if (string_eq(os_str, _SLIT("haiku"))) {
		Option_v__pref__OS _t810;
		opt_ok(&(v__pref__OS[]) { v__pref__OS_haiku }, (Option*)(&_t810), sizeof(v__pref__OS));
		// autofree_scope_vars(pos=820 line_nr=36 scope.pos=811 scope.end_pos=835)
		// af parent scope:
		// var "os_str" var.pos=444 var.line_nr=23
		// af parent scope:
		// af parent scope:
		return _t810;
	}
	else if (string_eq(os_str, _SLIT("linux_or_macos")) || string_eq(os_str, _SLIT("nix"))) {
		Option_v__pref__OS _t811;
		opt_ok(&(v__pref__OS[]) { v__pref__OS_linux }, (Option*)(&_t811), sizeof(v__pref__OS));
		// autofree_scope_vars(pos=864 line_nr=37 scope.pos=839 scope.end_pos=879)
		// af parent scope:
		// var "os_str" var.pos=444 var.line_nr=23
		// af parent scope:
		// af parent scope:
		return _t811;
	}
	else if (os_str.len == 0) {
		Option_v__pref__OS _t812;
		opt_ok(&(v__pref__OS[]) { v__pref__OS__auto }, (Option*)(&_t812), sizeof(v__pref__OS));
		// autofree_scope_vars(pos=887 line_nr=38 scope.pos=883 scope.end_pos=902)
		// af parent scope:
		// var "os_str" var.pos=444 var.line_nr=23
		// af parent scope:
		// af parent scope:
		return _t812;
	}
	else {
		return (Option_v__pref__OS){ .state=2, .err=v_error(_STR("bad OS %.*s", 1, os_str)) };
	};
	return (Option_v__pref__OS){0};
}

string v__pref__OS_str(v__pref__OS o) {

	if (o == (v__pref__OS__auto)) {
		 string _t813 = _SLIT("RESERVED: AUTO");
		// autofree_scope_vars(pos=1002 line_nr=45 scope.pos=994 scope.end_pos=1027)
		// af parent scope:
		// var "o" var.pos=960 var.line_nr=43
		// af parent scope:
		// af parent scope:
		return _t813;
	}
	else if (o == (v__pref__OS_ios)) {
		 string _t814 = _SLIT("iOS");
		// autofree_scope_vars(pos=1037 line_nr=46 scope.pos=1031 scope.end_pos=1051)
		// af parent scope:
		// var "o" var.pos=960 var.line_nr=43
		// af parent scope:
		// af parent scope:
		return _t814;
	}
	else if (o == (v__pref__OS_macos)) {
		 string _t815 = _SLIT("MacOS");
		// autofree_scope_vars(pos=1063 line_nr=47 scope.pos=1055 scope.end_pos=1079)
		// af parent scope:
		// var "o" var.pos=960 var.line_nr=43
		// af parent scope:
		// af parent scope:
		return _t815;
	}
	else if (o == (v__pref__OS_linux)) {
		 string _t816 = _SLIT("Linux");
		// autofree_scope_vars(pos=1091 line_nr=48 scope.pos=1083 scope.end_pos=1107)
		// af parent scope:
		// var "o" var.pos=960 var.line_nr=43
		// af parent scope:
		// af parent scope:
		return _t816;
	}
	else if (o == (v__pref__OS_windows)) {
		 string _t817 = _SLIT("Windows");
		// autofree_scope_vars(pos=1121 line_nr=49 scope.pos=1111 scope.end_pos=1139)
		// af parent scope:
		// var "o" var.pos=960 var.line_nr=43
		// af parent scope:
		// af parent scope:
		return _t817;
	}
	else if (o == (v__pref__OS_freebsd)) {
		 string _t818 = _SLIT("FreeBSD");
		// autofree_scope_vars(pos=1153 line_nr=50 scope.pos=1143 scope.end_pos=1171)
		// af parent scope:
		// var "o" var.pos=960 var.line_nr=43
		// af parent scope:
		// af parent scope:
		return _t818;
	}
	else if (o == (v__pref__OS_openbsd)) {
		 string _t819 = _SLIT("OpenBSD");
		// autofree_scope_vars(pos=1185 line_nr=51 scope.pos=1175 scope.end_pos=1203)
		// af parent scope:
		// var "o" var.pos=960 var.line_nr=43
		// af parent scope:
		// af parent scope:
		return _t819;
	}
	else if (o == (v__pref__OS_netbsd)) {
		 string _t820 = _SLIT("NetBSD");
		// autofree_scope_vars(pos=1216 line_nr=52 scope.pos=1207 scope.end_pos=1233)
		// af parent scope:
		// var "o" var.pos=960 var.line_nr=43
		// af parent scope:
		// af parent scope:
		return _t820;
	}
	else if (o == (v__pref__OS_dragonfly)) {
		 string _t821 = _SLIT("Dragonfly");
		// autofree_scope_vars(pos=1249 line_nr=53 scope.pos=1237 scope.end_pos=1269)
		// af parent scope:
		// var "o" var.pos=960 var.line_nr=43
		// af parent scope:
		// af parent scope:
		return _t821;
	}
	else if (o == (v__pref__OS_js)) {
		 string _t822 = _SLIT("JavaScript");
		// autofree_scope_vars(pos=1278 line_nr=54 scope.pos=1273 scope.end_pos=1299)
		// af parent scope:
		// var "o" var.pos=960 var.line_nr=43
		// af parent scope:
		// af parent scope:
		return _t822;
	}
	else if (o == (v__pref__OS_android)) {
		 string _t823 = _SLIT("Android");
		// autofree_scope_vars(pos=1313 line_nr=55 scope.pos=1303 scope.end_pos=1331)
		// af parent scope:
		// var "o" var.pos=960 var.line_nr=43
		// af parent scope:
		// af parent scope:
		return _t823;
	}
	else if (o == (v__pref__OS_solaris)) {
		 string _t824 = _SLIT("Solaris");
		// autofree_scope_vars(pos=1345 line_nr=56 scope.pos=1335 scope.end_pos=1363)
		// af parent scope:
		// var "o" var.pos=960 var.line_nr=43
		// af parent scope:
		// af parent scope:
		return _t824;
	}
	else if (o == (v__pref__OS_haiku)) {
		 string _t825 = _SLIT("Haiku");
		// autofree_scope_vars(pos=1375 line_nr=57 scope.pos=1367 scope.end_pos=1391)
		// af parent scope:
		// var "o" var.pos=960 var.line_nr=43
		// af parent scope:
		// af parent scope:
		return _t825;
	}
	else if (o == (v__pref__OS_all)) {
		 string _t826 = _SLIT("all");
		// autofree_scope_vars(pos=1401 line_nr=58 scope.pos=1395 scope.end_pos=1415)
		// af parent scope:
		// var "o" var.pos=960 var.line_nr=43
		// af parent scope:
		// af parent scope:
		return _t826;
	};
	return (string){.str=(byteptr)"", .is_lit=1};
}

v__pref__OS v__pref__get_host_os(void) {
	 v__pref__OS _t827 = v__pref__OS_windows;
	// autofree_scope_vars(pos=1557 line_nr=73 scope.pos=1554 scope.end_pos=1575)
	// af parent scope:
	// af parent scope:
	// af parent scope:
	return _t827;
	v_panic(_SLIT("unknown host OS"));
	return 0;
}

multi_return_v__pref__Preferences_string v__pref__parse_args(Array_string known_external_commands, Array_string args) {
	v__pref__Preferences* res = (v__pref__Preferences*)memdup(&(v__pref__Preferences){.os = 0,.backend = 0,.build_mode = 0,.arch = 0,.output_mode = v__pref__OutputMode_stdout,.is_verbose = 0,.is_watch = 0,.is_test = 0,.is_script = 0,.is_vsh = 0,.is_livemain = 0,.is_liveshared = 0,.is_shared = 0,.is_prof = 0,.profile_file = (string){.str=(byteptr)"", .is_lit=1},.profile_no_inline = 0,.translated = 0,.is_prod = 0,.obfuscate = 0,.is_repl = 0,.is_run = 0,.sanitize = 0,.is_debug = 0,.is_vlines = 0,.show_cc = 0,.show_c_output = 0,.dump_c_flags = (string){.str=(byteptr)"", .is_lit=1},.use_cache = 0,.retry_compilation = true,.is_stats = 0,.cflags = (string){.str=(byteptr)"", .is_lit=1},.m64 = 0,.ccompiler = (string){.str=(byteptr)"", .is_lit=1},.ccompiler_type = 0,.third_party_option = (string){.str=(byteptr)"", .is_lit=1},.building_v = 0,.autofree = 0,.compress = 0,.enable_globals = 0,.is_fmt = 0,.is_vet = 0,.is_bare = 0,.no_preludes = 0,.custom_prelude = (string){.str=(byteptr)"", .is_lit=1},.lookup_path = __new_array(0, 1, sizeof(string)),.bare_builtin_dir = (string){.str=(byteptr)"", .is_lit=1},.output_cross_c = 0,.prealloc = 0,.vroot = (string){.str=(byteptr)"", .is_lit=1},.out_name_c = (string){.str=(byteptr)"", .is_lit=1},.out_name = (string){.str=(byteptr)"", .is_lit=1},.path = (string){.str=(byteptr)"", .is_lit=1},.compile_defines = __new_array(0, 1, sizeof(string)),.compile_defines_all = __new_array(0, 1, sizeof(string)),.run_args = __new_array(0, 1, sizeof(string)),.printfn_list = __new_array(0, 1, sizeof(string)),.print_v_files = 0,.skip_running = 0,.skip_warnings = 0,.warn_impure_v = 0,.warns_are_errors = 0,.fatal_errors = 0,.reuse_tmpc = 0,.use_color = 0,.is_parallel = 0,.error_limit = 0,.is_vweb = 0,.only_check_syntax = 0,.experimental = 0,.skip_unused = 0,.show_timings = 0,.is_ios_simulator = 0,.is_apk = 0,.cleanup_files = __new_array(0, 1, sizeof(string)),.build_options = __new_array(0, 1, sizeof(string)),.cache_manager = (v__vcache__CacheManager){.k2cpath = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),},.is_help = 0,.gc_mode = v__pref__GarbageCollectionMode_no_gc,.checker_match_exhaustive_cutoff_limit = 10,}, sizeof(v__pref__Preferences));
	#if defined(TARGET_IS_64BIT)
	{
		res->m64 = true;
	}
	#endif
	string command = _SLIT("");
	int command_pos = 0;
	for (int i = 0; i < args.len; i++) {
		string arg = (*(string*)/*ee elem_typ */array_get(args, i));
		Array_string current_args = array_clone_static(array_slice(args, i, args.len));

		if (string_eq(arg, _SLIT("-apk"))) {
			res->is_apk = true;
			array_push(&res->build_options, _MOV((string[]){ string_clone(arg) }));
		}
		else if (string_eq(arg, _SLIT("-arch"))) {
			string target_arch = os__cmdline__option(current_args, _SLIT("-arch"), _SLIT(""));
			i++;
			Option_v__pref__Arch _t829 = v__pref__arch_from_string(target_arch);
			if (_t829.state != 0) { /*or block*/ 
				IError err = _t829.err;
				eprintln(_STR("unknown architecture target `%.*s\000`", 2, target_arch));
				v_exit(1);
			}
 			v__pref__Arch target_arch_kind =  *(v__pref__Arch*)_t829.data;
			res->arch = target_arch_kind;
			array_push(&res->build_options, _MOV((string[]){ string_clone(_STR("%.*s\000 %.*s", 2, arg, target_arch)) }));
		}
		else if (string_eq(arg, _SLIT("-show-timings"))) {
			res->show_timings = true;
		}
		else if (string_eq(arg, _SLIT("-check-syntax"))) {
			res->only_check_syntax = true;
		}
		else if (string_eq(arg, _SLIT("-h")) || string_eq(arg, _SLIT("-help")) || string_eq(arg, _SLIT("--help"))) {
			res->is_help = true;
		}
		else if (string_eq(arg, _SLIT("-v"))) {
			if (args.len > 1) {
				res->is_verbose = true;
			} else {
				command = _SLIT("version");
				command_pos = i;
			}
		}
		else if (string_eq(arg, _SLIT("-progress"))) {
		}
		else if (string_eq(arg, _SLIT("-Wimpure-v"))) {
			res->warn_impure_v = true;
		}
		else if (string_eq(arg, _SLIT("-Wfatal-errors"))) {
			res->fatal_errors = true;
		}
		else if (string_eq(arg, _SLIT("-silent"))) {
			res->output_mode = v__pref__OutputMode_silent;
		}
		else if (string_eq(arg, _SLIT("-gc"))) {
			string gc_mode = os__cmdline__option(current_args, _SLIT("-gc"), _SLIT(""));

			if (gc_mode.len == 0) {
				res->gc_mode = v__pref__GarbageCollectionMode_no_gc;
			}
			else if (string_eq(gc_mode, _SLIT("boehm_full"))) {
				res->gc_mode = v__pref__GarbageCollectionMode_boehm_full;
				v__pref__parse_define(res, _SLIT("gcboehm"));
				v__pref__parse_define(res, _SLIT("gcboehm_full"));
			}
			else if (string_eq(gc_mode, _SLIT("boehm_incr"))) {
				res->gc_mode = v__pref__GarbageCollectionMode_boehm_incr;
				v__pref__parse_define(res, _SLIT("gcboehm"));
				v__pref__parse_define(res, _SLIT("gcboehm_incr"));
			}
			else if (string_eq(gc_mode, _SLIT("boehm"))) {
				res->gc_mode = v__pref__GarbageCollectionMode_boehm;
				v__pref__parse_define(res, _SLIT("gcboehm"));
			}
			else if (string_eq(gc_mode, _SLIT("boehm_leak"))) {
				res->gc_mode = v__pref__GarbageCollectionMode_boehm_leak;
				v__pref__parse_define(res, _SLIT("gcboehm"));
				v__pref__parse_define(res, _SLIT("gcboehm_leak"));
			}
			else {
				eprintln(_SLIT("unknown garbage collection mode, only `-gc boehm`, `-gc boehm_incr`, `-gc boehm_full` and `-gc boehm_leak` are supported"));
				v_exit(1);
			};
			i++;
		}
		else if (string_eq(arg, _SLIT("-g"))) {
			res->is_debug = true;
			res->is_vlines = true;
			array_push(&res->build_options, _MOV((string[]){ string_clone(arg) }));
		}
		else if (string_eq(arg, _SLIT("-cg"))) {
			res->is_debug = true;
			res->is_vlines = false;
			array_push(&res->build_options, _MOV((string[]){ string_clone(arg) }));
		}
		else if (string_eq(arg, _SLIT("-debug-tcc"))) {
			res->ccompiler = _SLIT("tcc");
			array_push(&res->build_options, _MOV((string[]){ string_clone(_STR("%.*s\000 \"%.*s\000\"", 3, arg, res->ccompiler)) }));
			res->retry_compilation = false;
			res->show_cc = true;
			res->show_c_output = true;
		}
		else if (string_eq(arg, _SLIT("-repl"))) {
			res->is_repl = true;
		}
		else if (string_eq(arg, _SLIT("-live"))) {
			res->is_livemain = true;
		}
		else if (string_eq(arg, _SLIT("-sharedlive"))) {
			res->is_liveshared = true;
			res->is_shared = true;
		}
		else if (string_eq(arg, _SLIT("-shared"))) {
			res->is_shared = true;
		}
		else if (string_eq(arg, _SLIT("--enable-globals")) || string_eq(arg, _SLIT("-enable-globals"))) {
			res->enable_globals = true;
		}
		else if (string_eq(arg, _SLIT("-autofree"))) {
			res->autofree = true;
			array_push(&res->build_options, _MOV((string[]){ string_clone(arg) }));
		}
		else if (string_eq(arg, _SLIT("-manualfree"))) {
			res->autofree = false;
			array_push(&res->build_options, _MOV((string[]){ string_clone(arg) }));
		}
		else if (string_eq(arg, _SLIT("-skip-unused"))) {
			res->skip_unused = true;
		}
		else if (string_eq(arg, _SLIT("-compress"))) {
			res->compress = true;
		}
		else if (string_eq(arg, _SLIT("-freestanding"))) {
			res->is_bare = true;
			array_push(&res->build_options, _MOV((string[]){ string_clone(arg) }));
		}
		else if (string_eq(arg, _SLIT("-no-retry-compilation"))) {
			res->retry_compilation = false;
		}
		else if (string_eq(arg, _SLIT("-no-preludes"))) {
			res->no_preludes = true;
			array_push(&res->build_options, _MOV((string[]){ string_clone(arg) }));
		}
		else if (string_eq(arg, _SLIT("-prof")) || string_eq(arg, _SLIT("-profile"))) {
			res->profile_file = os__cmdline__option(current_args, arg, _SLIT("-"));
			res->is_prof = true;
			array_push(&res->build_options, _MOV((string[]){ string_clone(_STR("%.*s\000 %.*s", 2, arg, res->profile_file)) }));
			i++;
		}
		else if (string_eq(arg, _SLIT("-profile-no-inline"))) {
			res->profile_no_inline = true;
		}
		else if (string_eq(arg, _SLIT("-prod"))) {
			res->is_prod = true;
			array_push(&res->build_options, _MOV((string[]){ string_clone(arg) }));
		}
		else if (string_eq(arg, _SLIT("-sanitize"))) {
			res->sanitize = true;
			array_push(&res->build_options, _MOV((string[]){ string_clone(arg) }));
		}
		else if (string_eq(arg, _SLIT("-simulator"))) {
			res->is_ios_simulator = true;
		}
		else if (string_eq(arg, _SLIT("-stats"))) {
			res->is_stats = true;
		}
		else if (string_eq(arg, _SLIT("-obf")) || string_eq(arg, _SLIT("-obfuscate"))) {
			res->obfuscate = true;
		}
		else if (string_eq(arg, _SLIT("-translated"))) {
			res->translated = true;
		}
		else if (string_eq(arg, _SLIT("-color"))) {
			res->use_color = v__pref__ColorOutput_always;
		}
		else if (string_eq(arg, _SLIT("-m32")) || string_eq(arg, _SLIT("-m64"))) {
			res->m64 = string_at(arg, 2) == L'6';
			res->cflags = /*f*/string_add(res->cflags, _STR(" %.*s", 1, arg));
		}
		else if (string_eq(arg, _SLIT("-nocolor"))) {
			res->use_color = v__pref__ColorOutput_never;
		}
		else if (string_eq(arg, _SLIT("-showcc"))) {
			res->show_cc = true;
		}
		else if (string_eq(arg, _SLIT("-show-c-output"))) {
			res->show_c_output = true;
		}
		else if (string_eq(arg, _SLIT("-dump-c-flags"))) {
			res->dump_c_flags = os__cmdline__option(current_args, arg, _SLIT("-"));
			i++;
		}
		else if (string_eq(arg, _SLIT("-experimental"))) {
			res->experimental = true;
		}
		else if (string_eq(arg, _SLIT("-usecache"))) {
			res->use_cache = true;
		}
		else if (string_eq(arg, _SLIT("-nocache"))) {
			res->use_cache = false;
		}
		else if (string_eq(arg, _SLIT("-prealloc"))) {
			res->prealloc = true;
			array_push(&res->build_options, _MOV((string[]){ string_clone(arg) }));
		}
		else if (string_eq(arg, _SLIT("-parallel"))) {
			res->is_parallel = true;
		}
		else if (string_eq(arg, _SLIT("-x64"))) {
			res->backend = v__pref__Backend_x64;
			array_push(&res->build_options, _MOV((string[]){ string_clone(arg) }));
		}
		else if (string_eq(arg, _SLIT("-W"))) {
			res->warns_are_errors = true;
		}
		else if (string_eq(arg, _SLIT("-keepc"))) {
			res->reuse_tmpc = true;
		}
		else if (string_eq(arg, _SLIT("-w"))) {
			res->skip_warnings = true;
		}
		else if (string_eq(arg, _SLIT("-watch"))) {
			res->is_watch = true;
		}
		else if (string_eq(arg, _SLIT("-print-v-files"))) {
			res->print_v_files = true;
		}
		else if (string_eq(arg, _SLIT("-error-limit"))) {
			res->error_limit = string_int(os__cmdline__option(current_args, _SLIT("-error-limit"), _SLIT("0")));
		}
		else if (string_eq(arg, _SLIT("-os"))) {
			string target_os = os__cmdline__option(current_args, _SLIT("-os"), _SLIT(""));
			i++;
			Option_v__pref__OS _t843 = v__pref__os_from_string(target_os);
			if (_t843.state != 0) { /*or block*/ 
				IError err = _t843.err;
				if (string_eq(target_os, _SLIT("cross"))) {
					res->output_cross_c = true;
					continue;
				}
				eprintln(_STR("unknown operating system target `%.*s\000`", 2, target_os));
				v_exit(1);
			}
 			v__pref__OS target_os_kind =  *(v__pref__OS*)_t843.data;
			res->os = target_os_kind;
			array_push(&res->build_options, _MOV((string[]){ string_clone(_STR("%.*s\000 %.*s", 2, arg, target_os)) }));
		}
		else if (string_eq(arg, _SLIT("-printfn"))) {
			_PUSH_MANY(&res->printfn_list, (string_split(os__cmdline__option(current_args, _SLIT("-printfn"), _SLIT("")), _SLIT(","))), _t845, Array_string);
			i++;
		}
		else if (string_eq(arg, _SLIT("-cflags"))) {
			res->cflags = /*f*/string_add(res->cflags, string_add(_SLIT(" "), os__cmdline__option(current_args, _SLIT("-cflags"), _SLIT(""))));
			array_push(&res->build_options, _MOV((string[]){ string_clone(_STR("%.*s\000 \"%.*s\000\"", 3, arg, string_trim_space(res->cflags))) }));
			i++;
		}
		else if (string_eq(arg, _SLIT("-define")) || string_eq(arg, _SLIT("-d"))) {
			if (current_args.len > 1) {
				string define = (*(string*)/*ee elem_typ */array_get(current_args, 1));
				v__pref__parse_define(res, define);
			}
			i++;
		}
		else if (string_eq(arg, _SLIT("-cc"))) {
			res->ccompiler = os__cmdline__option(current_args, _SLIT("-cc"), _SLIT("cc"));
			array_push(&res->build_options, _MOV((string[]){ string_clone(_STR("%.*s\000 \"%.*s\000\"", 3, arg, res->ccompiler)) }));
			i++;
		}
		else if (string_eq(arg, _SLIT("-checker-match-exhaustive-cutoff-limit"))) {
			res->checker_match_exhaustive_cutoff_limit = string_int(os__cmdline__option(current_args, arg, _SLIT("10")));
			i++;
		}
		else if (string_eq(arg, _SLIT("-o"))) {
			res->out_name = os__cmdline__option(current_args, _SLIT("-o"), _SLIT(""));
			if (string_ends_with(res->out_name, _SLIT(".js"))) {
				res->backend = v__pref__Backend_js;
			}
			if (!os__is_abs_path(res->out_name)) {
				res->out_name = os__join_path(os__getwd(), new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){res->out_name})));
			}
			i++;
		}
		else if (string_eq(arg, _SLIT("-b"))) {
			string sbackend = os__cmdline__option(current_args, _SLIT("-b"), _SLIT("c"));
			array_push(&res->build_options, _MOV((string[]){ string_clone(_STR("%.*s\000 %.*s", 2, arg, sbackend)) }));
			Option_v__pref__Backend _t849 = v__pref__backend_from_string(sbackend);
			if (_t849.state != 0) { /*or block*/ 
				IError err = _t849.err;
				continue;
			}
 			v__pref__Backend b =  *(v__pref__Backend*)_t849.data;
			res->backend = b;
			i++;
		}
		else if (string_eq(arg, _SLIT("-path"))) {
			string path = os__cmdline__option(current_args, _SLIT("-path"), _SLIT(""));
			array_push(&res->build_options, _MOV((string[]){ string_clone(_STR("%.*s\000 \"%.*s\000\"", 3, arg, path)) }));
			res->lookup_path = string_split(string_replace(path, _SLIT("|"), _const_os__path_delimiter), _const_os__path_delimiter);
			i++;
		}
		else if (string_eq(arg, _SLIT("-bare-builtin-dir"))) {
			string bare_builtin_dir = os__cmdline__option(current_args, arg, _SLIT(""));
			array_push(&res->build_options, _MOV((string[]){ string_clone(_STR("%.*s\000 \"%.*s\000\"", 3, arg, bare_builtin_dir)) }));
			res->bare_builtin_dir = bare_builtin_dir;
			i++;
		}
		else if (string_eq(arg, _SLIT("-custom-prelude"))) {
			string path = os__cmdline__option(current_args, _SLIT("-custom-prelude"), _SLIT(""));
			array_push(&res->build_options, _MOV((string[]){ string_clone(_STR("%.*s\000 %.*s", 2, arg, path)) }));
			Option_string _t853 = os__read_file(path);
			if (_t853.state != 0) { /*or block*/ 
				IError err = _t853.err;
				eprintln(_STR("cannot open custom prelude file: %.*s", 1, IError_str(err)));
				v_exit(1);
			}
 			string prelude =  *(string*)_t853.data;
			res->custom_prelude = prelude;
			i++;
		}
		else {
			if (string_eq(command, _SLIT("build")) && v__pref__is_source_file(arg)) {
				eprintln(_STR("Use `v %.*s\000` instead.", 2, arg));
				v_exit(1);
			}
			if (string_at(arg, 0) == L'-') {
				if ((Array_string_contains(_const_v__pref__list_of_flags_with_param, string_substr(arg, 1, arg.len)))) {
					i++;
					continue;
				}
			} else {
				if ((command).len == 0) {
					command = arg;
					command_pos = i;
					if (string_eq(command, _SLIT("run"))) {
						break;
					}
				} else if (v__pref__is_source_file(command) && v__pref__is_source_file(arg) && !(Array_string_contains(known_external_commands, command))) {
					eprintln(_SLIT("Too many targets. Specify just one target: <target.v|target_directory>."));
					v_exit(1);
				}
				continue;
			}
			if ((string_eq(arg, _SLIT("-V")) || string_eq(arg, _SLIT("-version")) || string_eq(arg, _SLIT("--version")))) {
				command = _SLIT("version");
				command_pos = i;
				continue;
			}
			if ((command).len != 0 && string_ne(command, _SLIT("build-module"))) {
				continue;
			}
			string extension = (command.len == 0 ? (_SLIT("")) : (_STR(" for command `%.*s\000`", 2, command)));
			eprintln(_STR("Unknown argument `%.*s\000`%.*s", 2, arg, extension));
			v_exit(1);
		};
	}
	if (res->is_debug) {
		v__pref__parse_define(res, _SLIT("debug"));
	}
	if (string_ne(command, _SLIT("doc")) && string_ends_with(res->out_name, _SLIT(".v"))) {
		eprintln(_SLIT("Cannot save output binary in a .v file."));
		v_exit(1);
	}
	if (v__pref__is_source_file(command)) {
		res->path = command;
	} else if (string_eq(command, _SLIT("run"))) {
		res->is_run = true;
		if (command_pos + 2 > args.len) {
			eprintln(_SLIT("v run: no v files listed"));
			v_exit(1);
		}
		res->path = (*(string*)/*ee elem_typ */array_get(args, command_pos + 1));
		res->run_args = array_slice(args, command_pos + 2, args.len);
		if (string_eq(res->path, _SLIT("-"))) {
			string tmp_file_path = rand__ulid();
			string tmp_exe_file_path = res->out_name;
			string output_option = _SLIT("");
			if ((tmp_exe_file_path).len == 0) {
				tmp_exe_file_path = _STR("%.*s\000.exe", 2, tmp_file_path);
				output_option = _STR("-o \"%.*s\000\"", 2, tmp_exe_file_path);
			}
			string tmp_v_file_path = _STR("%.*s\000.v", 2, tmp_file_path);
			string contents = os__get_raw_lines_joined();
			Option_void _t854 = os__write_file(tmp_v_file_path, contents);
			if (_t854.state != 0 && _t854.err._typ != _IError_None___index) {
				IError err = _t854.err;
				v_panic(_STR("Failed to create temporary file %.*s", 1, tmp_v_file_path));
			};
			string run_options = Array_string_join(os__cmdline__options_before(args, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("run")}))), _SLIT(" "));
			string command_options = Array_string_join(array_slice(os__cmdline__options_after(args, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("run")}))), 1, os__cmdline__options_after(args, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("run")}))).len), _SLIT(" "));
			string vexe = v__pref__vexe_path();
			string tmp_cmd = _STR("\"%.*s\000\" %.*s\000 %.*s\000 run \"%.*s\000\" %.*s", 5, vexe, output_option, run_options, tmp_v_file_path, command_options);
			v__pref__Preferences_vrun_elog(res, _STR("tmp_cmd: %.*s", 1, tmp_cmd));
			int tmp_result = os__system(tmp_cmd);
			v__pref__Preferences_vrun_elog(res, _STR("exit code: %"PRId32"", 1, tmp_result));
			if (output_option.len != 0) {
				v__pref__Preferences_vrun_elog(res, _STR("remove tmp exe file: %.*s", 1, tmp_exe_file_path));
				Option_void _t855 = os__rm(tmp_exe_file_path);
				if (_t855.state != 0 && _t855.err._typ != _IError_None___index) {
					IError err = _t855.err;
				};
			}
			v__pref__Preferences_vrun_elog(res, _STR("remove tmp v file: %.*s", 1, tmp_v_file_path));
			Option_void _t856 = os__rm(tmp_v_file_path);
			if (_t856.state != 0 && _t856.err._typ != _IError_None___index) {
				IError err = _t856.err;
				v_panic(IError_str(err));
			};
			v_exit(tmp_result);
		}
		v__pref__must_exist(res->path);
		if (!string_ends_with(res->path, _SLIT(".v")) && os__is_executable(res->path) && os__is_file(res->path) && os__is_file(string_add(res->path, _SLIT(".v")))) {
			eprintln(_STR("It looks like you wanted to run \"%.*s\000.v\", so we went ahead and did that since \"%.*s\000\" is an execuast.", 3, res->path, res->path));
			res->path = /*f*/string_add(res->path, _SLIT(".v"));
		}
	}
	if (string_eq(command, _SLIT("build-module"))) {
		res->build_mode = v__pref__BuildMode_build_module;
		res->path = (*(string*)/*ee elem_typ */array_get(args, command_pos + 1));
	}
	Map_string_string m = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
	// FOR IN array
	for (int _t857 = 0; _t857 < res->build_options.len; ++_t857) {
		string x = ((string*)res->build_options.data)[_t857];
		map_set(&m, &(string[]){x}, &(string[]) { _SLIT("") });
	}
	res->build_options = map_keys(&m);
	v__pref__Preferences_fill_with_defaults(res);
	return (multi_return_v__pref__Preferences_string){.arg0=res, .arg1=command};
}

void v__pref__Preferences_vrun_elog(v__pref__Preferences* pref, string s) {
	if (pref->is_verbose) {
		eprintln(_STR("> v run -, %.*s", 1, s));
	}
}

Option_v__pref__Arch v__pref__arch_from_string(string arch_str) {

	if (string_eq(arch_str, _SLIT("amd64")) || string_eq(arch_str, _SLIT("x86_64")) || string_eq(arch_str, _SLIT("x64")) || string_eq(arch_str, _SLIT("x86"))) {
		Option_v__pref__Arch _t858;
		opt_ok(&(v__pref__Arch[]) { v__pref__Arch_amd64 }, (Option*)(&_t858), sizeof(v__pref__Arch));
		// autofree_scope_vars(pos=18618 line_nr=603 scope.pos=18560 scope.end_pos=18639)
		// af parent scope:
		// var "arch_str" var.pos=18515 var.line_nr=599
		// af parent scope:
		// af parent scope:
		return _t858;
	}
	else if (string_eq(arch_str, _SLIT("aarch64")) || string_eq(arch_str, _SLIT("arm64"))) {
		Option_v__pref__Arch _t859;
		opt_ok(&(v__pref__Arch[]) { v__pref__Arch_aarch64 }, (Option*)(&_t859), sizeof(v__pref__Arch));
		// autofree_scope_vars(pos=18690 line_nr=607 scope.pos=18643 scope.end_pos=18713)
		// af parent scope:
		// var "arch_str" var.pos=18515 var.line_nr=599
		// af parent scope:
		// af parent scope:
		return _t859;
	}
	else if (string_eq(arch_str, _SLIT("arm32")) || string_eq(arch_str, _SLIT("aarch32")) || string_eq(arch_str, _SLIT("arm"))) {
		Option_v__pref__Arch _t860;
		opt_ok(&(v__pref__Arch[]) { v__pref__Arch_aarch32 }, (Option*)(&_t860), sizeof(v__pref__Arch));
		// autofree_scope_vars(pos=18771 line_nr=611 scope.pos=18717 scope.end_pos=18794)
		// af parent scope:
		// var "arch_str" var.pos=18515 var.line_nr=599
		// af parent scope:
		// af parent scope:
		return _t860;
	}
	else if (string_eq(arch_str, _SLIT("rv64")) || string_eq(arch_str, _SLIT("riscv64")) || string_eq(arch_str, _SLIT("risc-v64")) || string_eq(arch_str, _SLIT("riscv")) || string_eq(arch_str, _SLIT("risc-v"))) {
		Option_v__pref__Arch _t861;
		opt_ok(&(v__pref__Arch[]) { v__pref__Arch_rv64 }, (Option*)(&_t861), sizeof(v__pref__Arch));
		// autofree_scope_vars(pos=18872 line_nr=615 scope.pos=18798 scope.end_pos=18892)
		// af parent scope:
		// var "arch_str" var.pos=18515 var.line_nr=599
		// af parent scope:
		// af parent scope:
		return _t861;
	}
	else if (string_eq(arch_str, _SLIT("rv32")) || string_eq(arch_str, _SLIT("riscv32"))) {
		Option_v__pref__Arch _t862;
		opt_ok(&(v__pref__Arch[]) { v__pref__Arch_rv32 }, (Option*)(&_t862), sizeof(v__pref__Arch));
		// autofree_scope_vars(pos=18939 line_nr=619 scope.pos=18896 scope.end_pos=18959)
		// af parent scope:
		// var "arch_str" var.pos=18515 var.line_nr=599
		// af parent scope:
		// af parent scope:
		return _t862;
	}
	else if (string_eq(arch_str, _SLIT("x86_32")) || string_eq(arch_str, _SLIT("x32")) || string_eq(arch_str, _SLIT("i386")) || string_eq(arch_str, _SLIT("IA-32")) || string_eq(arch_str, _SLIT("ia-32")) || string_eq(arch_str, _SLIT("ia32"))) {
		Option_v__pref__Arch _t863;
		opt_ok(&(v__pref__Arch[]) { v__pref__Arch_i386 }, (Option*)(&_t863), sizeof(v__pref__Arch));
		// autofree_scope_vars(pos=19038 line_nr=623 scope.pos=18963 scope.end_pos=19058)
		// af parent scope:
		// var "arch_str" var.pos=18515 var.line_nr=599
		// af parent scope:
		// af parent scope:
		return _t863;
	}
	else if (arch_str.len == 0) {
		Option_v__pref__Arch _t864;
		opt_ok(&(v__pref__Arch[]) { v__pref__Arch__auto }, (Option*)(&_t864), sizeof(v__pref__Arch));
		// autofree_scope_vars(pos=19069 line_nr=626 scope.pos=19062 scope.end_pos=19086)
		// af parent scope:
		// var "arch_str" var.pos=18515 var.line_nr=599
		// af parent scope:
		// af parent scope:
		return _t864;
	}
	else {
		return (Option_v__pref__Arch){ .state=2, .err=v_error(_STR("invalid arch: %.*s", 1, arch_str)) };
	};
	return (Option_v__pref__Arch){0};
}

VV_LOCAL_SYMBOL void v__pref__must_exist(string path) {
	if (!os__exists(path)) {
		eprintln(_STR("v expects that `%.*s\000` exists, but it does not", 2, path));
		v_exit(1);
	}
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL bool v__pref__is_source_file(string path) {
	 bool _t865 = string_ends_with(path, _SLIT(".v")) || os__exists(path);
	// autofree_scope_vars(pos=19326 line_nr=643 scope.pos=19291 scope.end_pos=19374)
	// var "path" var.pos=19306 var.line_nr=642
	// af parent scope:
	// af parent scope:
	return _t865;
}

Option_v__pref__Backend v__pref__backend_from_string(string s) {

	if (string_eq(s, _SLIT("c"))) {
		Option_v__pref__Backend _t866;
		opt_ok(&(v__pref__Backend[]) { v__pref__Backend_c }, (Option*)(&_t866), sizeof(v__pref__Backend));
		// autofree_scope_vars(pos=19443 line_nr=648 scope.pos=19438 scope.end_pos=19454)
		// af parent scope:
		// var "s" var.pos=19404 var.line_nr=646
		// af parent scope:
		// af parent scope:
		return _t866;
	}
	else if (string_eq(s, _SLIT("js"))) {
		Option_v__pref__Backend _t867;
		opt_ok(&(v__pref__Backend[]) { v__pref__Backend_js }, (Option*)(&_t867), sizeof(v__pref__Backend));
		// autofree_scope_vars(pos=19464 line_nr=649 scope.pos=19458 scope.end_pos=19476)
		// af parent scope:
		// var "s" var.pos=19404 var.line_nr=646
		// af parent scope:
		// af parent scope:
		return _t867;
	}
	else if (string_eq(s, _SLIT("x64"))) {
		Option_v__pref__Backend _t868;
		opt_ok(&(v__pref__Backend[]) { v__pref__Backend_x64 }, (Option*)(&_t868), sizeof(v__pref__Backend));
		// autofree_scope_vars(pos=19487 line_nr=650 scope.pos=19480 scope.end_pos=19500)
		// af parent scope:
		// var "s" var.pos=19404 var.line_nr=646
		// af parent scope:
		// af parent scope:
		return _t868;
	}
	else {
		return (Option_v__pref__Backend){ .state=2, .err=v_error(_STR("Unknown backend type %.*s", 1, s)) };
	};
	return (Option_v__pref__Backend){0};
}

v__pref__CompilerType v__pref__cc_from_string(string cc_str) {
	if (cc_str.len == 0) {
		 v__pref__CompilerType _t869 = v__pref__CompilerType_gcc;
		// autofree_scope_vars(pos=19688 line_nr=658 scope.pos=19685 scope.end_pos=19702)
		// af parent scope:
		// var "cc_str" var.pos=19635 var.line_nr=656
		// var "normalized_cc" var.pos=19714 var.line_nr=661
		// var "normalized_cc_array" var.pos=19758 var.line_nr=662
		// var "last_elem" var.pos=19807 var.line_nr=663
		// var "cc" var.pos=19848 var.line_nr=664
		// af parent scope:
		// af parent scope:
		return _t869;
	}
	string normalized_cc = string_replace(cc_str, _SLIT("\\"), _SLIT("/"));
	Array_string normalized_cc_array = string_split(normalized_cc, _SLIT("/"));
	string last_elem = (*(string*)array_last(normalized_cc_array));
	string cc = string_all_before(last_elem, _SLIT("."));
	if (string_contains(cc, _SLIT("++"))) {
		 v__pref__CompilerType _t870 = v__pref__CompilerType_cplusplus;
		// autofree_scope_vars(pos=19905 line_nr=666 scope.pos=19902 scope.end_pos=19925)
		// af parent scope:
		// var "cc_str" var.pos=19635 var.line_nr=656
		// var "normalized_cc" var.pos=19714 var.line_nr=661
		// var "normalized_cc_array" var.pos=19758 var.line_nr=662
		// var "last_elem" var.pos=19807 var.line_nr=663
		// var "cc" var.pos=19848 var.line_nr=664
		// af parent scope:
		// af parent scope:
		return _t870;
	}
	if (string_contains(cc, _SLIT("tcc")) || string_contains(cc, _SLIT("tinyc"))) {
		 v__pref__CompilerType _t871 = v__pref__CompilerType_tinyc;
		// autofree_scope_vars(pos=19977 line_nr=669 scope.pos=19974 scope.end_pos=19993)
		// af parent scope:
		// var "cc_str" var.pos=19635 var.line_nr=656
		// var "normalized_cc" var.pos=19714 var.line_nr=661
		// var "normalized_cc_array" var.pos=19758 var.line_nr=662
		// var "last_elem" var.pos=19807 var.line_nr=663
		// var "cc" var.pos=19848 var.line_nr=664
		// af parent scope:
		// af parent scope:
		return _t871;
	}
	if (string_contains(cc, _SLIT("clang"))) {
		 v__pref__CompilerType _t872 = v__pref__CompilerType_clang;
		// autofree_scope_vars(pos=20023 line_nr=672 scope.pos=20020 scope.end_pos=20039)
		// af parent scope:
		// var "cc_str" var.pos=19635 var.line_nr=656
		// var "normalized_cc" var.pos=19714 var.line_nr=661
		// var "normalized_cc_array" var.pos=19758 var.line_nr=662
		// var "last_elem" var.pos=19807 var.line_nr=663
		// var "cc" var.pos=19848 var.line_nr=664
		// af parent scope:
		// af parent scope:
		return _t872;
	}
	if (string_contains(cc, _SLIT("mingw"))) {
		 v__pref__CompilerType _t873 = v__pref__CompilerType_mingw;
		// autofree_scope_vars(pos=20069 line_nr=675 scope.pos=20066 scope.end_pos=20085)
		// af parent scope:
		// var "cc_str" var.pos=19635 var.line_nr=656
		// var "normalized_cc" var.pos=19714 var.line_nr=661
		// var "normalized_cc_array" var.pos=19758 var.line_nr=662
		// var "last_elem" var.pos=19807 var.line_nr=663
		// var "cc" var.pos=19848 var.line_nr=664
		// af parent scope:
		// af parent scope:
		return _t873;
	}
	if (string_contains(cc, _SLIT("msvc"))) {
		 v__pref__CompilerType _t874 = v__pref__CompilerType_msvc;
		// autofree_scope_vars(pos=20114 line_nr=678 scope.pos=20111 scope.end_pos=20129)
		// af parent scope:
		// var "cc_str" var.pos=19635 var.line_nr=656
		// var "normalized_cc" var.pos=19714 var.line_nr=661
		// var "normalized_cc_array" var.pos=19758 var.line_nr=662
		// var "last_elem" var.pos=19807 var.line_nr=663
		// var "cc" var.pos=19848 var.line_nr=664
		// af parent scope:
		// af parent scope:
		return _t874;
	}
	 v__pref__CompilerType _t875 = v__pref__CompilerType_gcc;
	// autofree_scope_vars(pos=20131 line_nr=680 scope.pos=19620 scope.end_pos=20144)
	// var "cc_str" var.pos=19635 var.line_nr=656
	// var "normalized_cc" var.pos=19714 var.line_nr=661
	// var "normalized_cc_array" var.pos=19758 var.line_nr=662
	// var "last_elem" var.pos=19807 var.line_nr=663
	// var "cc" var.pos=19848 var.line_nr=664
	// af parent scope:
	// af parent scope:
	return _t875;
}

v__pref__Arch v__pref__get_host_arch(void) {
	#if defined(__V_amd64)
	{
		 v__pref__Arch _t876 = v__pref__Arch_amd64;
		// autofree_scope_vars(pos=20191 line_nr=685 scope.pos=20188 scope.end_pos=20207)
		// af parent scope:
		// af parent scope:
		// af parent scope:
		return _t876;
	}
	#endif
	#if defined(__V_aarch64)
	{
		 v__pref__Arch _t877 = v__pref__Arch_aarch64;
		// autofree_scope_vars(pos=20265 line_nr=691 scope.pos=20262 scope.end_pos=20283)
		// af parent scope:
		// af parent scope:
		// af parent scope:
		return _t877;
	}
	#endif
	v_panic(_SLIT("unknown host OS"));
	return 0;
}

VV_LOCAL_SYMBOL void v__pref__parse_define(v__pref__Preferences* prefs, string define) {
	Array_string define_parts = string_split(define, _SLIT("="));
	array_push(&prefs->build_options, _MOV((string[]){ string_clone(_STR("-d %.*s", 1, define)) }));
	if (define_parts.len == 1) {
		array_push(&prefs->compile_defines, _MOV((string[]){ string_clone(define) }));
		array_push(&prefs->compile_defines_all, _MOV((string[]){ string_clone(define) }));
		return;
	}
	if (define_parts.len == 2) {
		array_push(&prefs->compile_defines_all, _MOV((string[]){ string_clone((*(string*)/*ee elem_typ */array_get(define_parts, 0))) }));
		string _t882 = (*(string*)/*ee elem_typ */array_get(define_parts, 1));
		
		if (string_eq(_t882, _SLIT("0"))) {
		}
		else if (string_eq(_t882, _SLIT("1"))) {
			array_push(&prefs->compile_defines, _MOV((string[]){ string_clone((*(string*)/*ee elem_typ */array_get(define_parts, 0))) }));
		}
		else {
			println(string_add(_STR("V error: Unknown define argument value `%.*s\000` for %.*s\000.", 3, (*(string*)/*ee elem_typ */array_get(define_parts, 1)), (*(string*)/*ee elem_typ */array_get(define_parts, 0))), _SLIT(" Expected `0` or `1`.")));
			v_exit(1);
		};
		return;
	}
	println(_STR("V error: Unknown define argument: %.*s\000. Expected at most one `=`.", 2, define));
	v_exit(1);
}

Array_string v__pref__Preferences_should_compile_filtered_files(v__pref__Preferences* prefs, string dir, Array_string files_) {
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	Array_string files = array_clone(&files_);
	qsort(files.data, files.len, files.element_size, (int (*)(const void *, const void *))&compare_strings);
	Array_string all_v_files = __new_array_with_default(0, 0, sizeof(string), 0);
	// FOR IN array
	for (int _t884 = 0; _t884 < files.len; ++_t884) {
		string file = ((string*)files.data)[_t884];
		if (prefs->is_bare && string_ends_with(os__join_path(dir, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){file}))), _SLIT("/vlib/builtin/builtin_nix.c.v"))) {
			continue;
		}
		if (!string_ends_with(file, _SLIT(".v")) && !string_ends_with(file, _SLIT(".vh"))) {
			continue;
		}
		if (string_ends_with(file, _SLIT("_test.v")) || string_ends_with(string_all_before_last(string_all_before_last(file, _SLIT(".v")), _SLIT(".")), _SLIT("_test"))) {
			continue;
		}
		if (prefs->backend == v__pref__Backend_c && !v__pref__Preferences_should_compile_c(prefs, file)) {
			continue;
		}
		if (prefs->backend == v__pref__Backend_js && !v__pref__Preferences_should_compile_js(prefs, file)) {
			continue;
		}
		if (prefs->backend != v__pref__Backend_js && !v__pref__Preferences_should_compile_asm(prefs, file)) {
			continue;
		}
		if (string_contains(file, _SLIT("_d_"))) {
			if (prefs->compile_defines_all.len == 0) {
				continue;
			}
			bool allowed = false;
			// FOR IN array
			for (int _t885 = 0; _t885 < prefs->compile_defines.len; ++_t885) {
				string cdefine = ((string*)prefs->compile_defines.data)[_t885];
				string file_postfix = _STR("_d_%.*s\000.v", 2, cdefine);
				if (string_ends_with(file, file_postfix)) {
					allowed = true;
					break;
				}
			}
			if (!allowed) {
				continue;
			}
		}
		if (string_contains(file, _SLIT("_notd_"))) {
			bool allowed = true;
			// FOR IN array
			for (int _t886 = 0; _t886 < prefs->compile_defines.len; ++_t886) {
				string cdefine = ((string*)prefs->compile_defines.data)[_t886];
				string file_postfix = _STR("_notd_%.*s\000.v", 2, cdefine);
				if (string_ends_with(file, file_postfix)) {
					allowed = false;
					break;
				}
			}
			if (!allowed) {
				continue;
			}
		}
		array_push(&all_v_files, _MOV((string[]){ string_clone(os__join_path(dir, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){file})))) }));
	}
	Array_string defaults = __new_array_with_default(0, 0, sizeof(string), 0);
	Map_string_Array_string fnames_no_postfixes = new_map(sizeof(string), sizeof(Array_string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
	// FOR IN array
	for (int _t888 = 0; _t888 < all_v_files.len; ++_t888) {
		string file = ((string*)all_v_files.data)[_t888];
		if (string_contains(file, _SLIT("default.c.v"))) {
			array_push(&defaults, _MOV((string[]){ string_clone(file) }));
		} else {
			array_push(&res, _MOV((string[]){ string_clone(file) }));
			string no_postfix_key = v__pref__fname_without_platform_postfix(file);
			Array_string candidates = (*(Array_string*)map_get(ADDR(map, fnames_no_postfixes), &(string[]){no_postfix_key}, &(Array_string[]){ __new_array(0, 1, sizeof(string)) }));
			array_push(&candidates, _MOV((string[]){ string_clone(file) }));
			map_set(&fnames_no_postfixes, &(string[]){no_postfix_key}, &(Array_string[]) { candidates });
		}
	}
	// FOR IN array
	for (int _t892 = 0; _t892 < defaults.len; ++_t892) {
		string file = ((string*)defaults.data)[_t892];
		string no_postfix_key = v__pref__fname_without_platform_postfix(file);
		if (_IN_MAP(ADDR(string, no_postfix_key), ADDR(map, fnames_no_postfixes))) {
			if (prefs->is_verbose) {
				println(_STR(">>> should_compile_filtered_files: skipping _default.c.v file %.*s\000 ; the specialized versions are: %.*s", 2, file, Array_string_str((*(Array_string*)map_get(ADDR(map, fnames_no_postfixes), &(string[]){no_postfix_key}, &(Array_string[]){ __new_array(0, 1, sizeof(string)) })))));
			}
			continue;
		}
		array_push(&res, _MOV((string[]){ string_clone(file) }));
	}
	if (prefs->is_verbose) {
		println(_STR(">>> should_compile_filtered_files: res: %.*s", 1, Array_string_str(res)));
	}
	// autofree_scope_vars(pos=2200 line_nr=87 scope.pos=31 scope.end_pos=2212)
	// var "prefs" var.pos=32 var.line_nr=4
	// var "dir" var.pos=82 var.line_nr=4
	// var "files_" var.pos=94 var.line_nr=4
	// var "res" var.pos=127 var.line_nr=5
	// var "files" var.pos=150 var.line_nr=6
	// var "all_v_files" var.pos=193 var.line_nr=8
	// var "defaults" var.pos=1395 var.line_nr=61
	// var "fnames_no_postfixes" var.pos=1423 var.line_nr=62
	// af parent scope:
	// af parent scope:
	return res;
}

VV_LOCAL_SYMBOL string v__pref__fname_without_platform_postfix(string file) {
	string res = string_replace_each(file, new_array_from_c_array(24, 24, sizeof(string), _MOV((string[24]){
			_SLIT("default.c.v"), _SLIT("_"), _SLIT("nix.c.v"), _SLIT("_"), _SLIT("windows.c.v"), _SLIT("_"), _SLIT("linux.c.v"), _SLIT("_"), _SLIT("darwin.c.v"), _SLIT("_"), _SLIT("macos.c.v"), _SLIT("_"), _SLIT("android.c.v"), _SLIT("_"), _SLIT("freebsd.c.v"), _SLIT("_"), _SLIT("netbsd.c.v"), _SLIT("_"), _SLIT("dragonfly.c.v"), _SLIT("_"), _SLIT("solaris.c.v"), _SLIT("_"), _SLIT("x64.v"), _SLIT("_")})));
	// autofree_scope_vars(pos=2577 line_nr=117 scope.pos=2218 scope.end_pos=2589)
	// var "file" var.pos=2249 var.line_nr=90
	// var "res" var.pos=2272 var.line_nr=91
	// af parent scope:
	// af parent scope:
	return res;
}

bool v__pref__Preferences_should_compile_c(v__pref__Preferences* prefs, string file) {
	if (string_ends_with(file, _SLIT(".js.v"))) {
		 bool _t894 = false;
		// autofree_scope_vars(pos=2727 line_nr=123 scope.pos=2685 scope.end_pos=2742)
		// af parent scope:
		// var "prefs" var.pos=2600 var.line_nr=120
		// var "file" var.pos=2637 var.line_nr=120
		// af parent scope:
		// af parent scope:
		return _t894;
	}
	if (prefs->os == v__pref__OS_all) {
		 bool _t895 = true;
		// autofree_scope_vars(pos=2768 line_nr=126 scope.pos=2765 scope.end_pos=2782)
		// af parent scope:
		// var "prefs" var.pos=2600 var.line_nr=120
		// var "file" var.pos=2637 var.line_nr=120
		// af parent scope:
		// af parent scope:
		return _t895;
	}
	if (!prefs->is_bare && string_ends_with(file, _SLIT(".freestanding.v"))) {
		 bool _t896 = false;
		// autofree_scope_vars(pos=2843 line_nr=129 scope.pos=2840 scope.end_pos=2858)
		// af parent scope:
		// var "prefs" var.pos=2600 var.line_nr=120
		// var "file" var.pos=2637 var.line_nr=120
		// af parent scope:
		// af parent scope:
		return _t896;
	}
	if ((string_ends_with(file, _SLIT("_windows.c.v")) || string_ends_with(file, _SLIT("_windows.v"))) && prefs->os != v__pref__OS_windows) {
		 bool _t897 = false;
		// autofree_scope_vars(pos=2956 line_nr=132 scope.pos=2953 scope.end_pos=2971)
		// af parent scope:
		// var "prefs" var.pos=2600 var.line_nr=120
		// var "file" var.pos=2637 var.line_nr=120
		// af parent scope:
		// af parent scope:
		return _t897;
	}
	if ((string_ends_with(file, _SLIT("_linux.c.v")) || string_ends_with(file, _SLIT("_linux.v"))) && prefs->os != v__pref__OS_linux) {
		 bool _t898 = false;
		// autofree_scope_vars(pos=3063 line_nr=135 scope.pos=3060 scope.end_pos=3078)
		// af parent scope:
		// var "prefs" var.pos=2600 var.line_nr=120
		// var "file" var.pos=2637 var.line_nr=120
		// af parent scope:
		// af parent scope:
		return _t898;
	}
	if ((string_ends_with(file, _SLIT("_darwin.c.v")) || string_ends_with(file, _SLIT("_darwin.v"))) && prefs->os != v__pref__OS_macos) {
		 bool _t899 = false;
		// autofree_scope_vars(pos=3172 line_nr=138 scope.pos=3169 scope.end_pos=3187)
		// af parent scope:
		// var "prefs" var.pos=2600 var.line_nr=120
		// var "file" var.pos=2637 var.line_nr=120
		// af parent scope:
		// af parent scope:
		return _t899;
	}
	if ((string_ends_with(file, _SLIT("_macos.c.v")) || string_ends_with(file, _SLIT("_macos.v"))) && prefs->os != v__pref__OS_macos) {
		 bool _t900 = false;
		// autofree_scope_vars(pos=3279 line_nr=141 scope.pos=3276 scope.end_pos=3294)
		// af parent scope:
		// var "prefs" var.pos=2600 var.line_nr=120
		// var "file" var.pos=2637 var.line_nr=120
		// af parent scope:
		// af parent scope:
		return _t900;
	}
	if ((string_ends_with(file, _SLIT("_ios.c.v")) || string_ends_with(file, _SLIT("_ios.v"))) && prefs->os != v__pref__OS_ios) {
		 bool _t901 = false;
		// autofree_scope_vars(pos=3380 line_nr=144 scope.pos=3377 scope.end_pos=3395)
		// af parent scope:
		// var "prefs" var.pos=2600 var.line_nr=120
		// var "file" var.pos=2637 var.line_nr=120
		// af parent scope:
		// af parent scope:
		return _t901;
	}
	if (string_ends_with(file, _SLIT("_nix.c.v")) && prefs->os == v__pref__OS_windows) {
		 bool _t902 = false;
		// autofree_scope_vars(pos=3455 line_nr=147 scope.pos=3452 scope.end_pos=3470)
		// af parent scope:
		// var "prefs" var.pos=2600 var.line_nr=120
		// var "file" var.pos=2637 var.line_nr=120
		// af parent scope:
		// af parent scope:
		return _t902;
	}
	if (string_ends_with(file, _SLIT("_android.c.v")) && prefs->os != v__pref__OS_android) {
		 bool _t903 = false;
		// autofree_scope_vars(pos=3534 line_nr=150 scope.pos=3531 scope.end_pos=3549)
		// af parent scope:
		// var "prefs" var.pos=2600 var.line_nr=120
		// var "file" var.pos=2637 var.line_nr=120
		// af parent scope:
		// af parent scope:
		return _t903;
	}
	if (string_ends_with(file, _SLIT("_freebsd.c.v")) && prefs->os != v__pref__OS_freebsd) {
		 bool _t904 = false;
		// autofree_scope_vars(pos=3613 line_nr=153 scope.pos=3610 scope.end_pos=3628)
		// af parent scope:
		// var "prefs" var.pos=2600 var.line_nr=120
		// var "file" var.pos=2637 var.line_nr=120
		// af parent scope:
		// af parent scope:
		return _t904;
	}
	if (string_ends_with(file, _SLIT("_openbsd.c.v")) && prefs->os != v__pref__OS_openbsd) {
		 bool _t905 = false;
		// autofree_scope_vars(pos=3692 line_nr=156 scope.pos=3689 scope.end_pos=3707)
		// af parent scope:
		// var "prefs" var.pos=2600 var.line_nr=120
		// var "file" var.pos=2637 var.line_nr=120
		// af parent scope:
		// af parent scope:
		return _t905;
	}
	if (string_ends_with(file, _SLIT("_netbsd.c.v")) && prefs->os != v__pref__OS_netbsd) {
		 bool _t906 = false;
		// autofree_scope_vars(pos=3769 line_nr=159 scope.pos=3766 scope.end_pos=3784)
		// af parent scope:
		// var "prefs" var.pos=2600 var.line_nr=120
		// var "file" var.pos=2637 var.line_nr=120
		// af parent scope:
		// af parent scope:
		return _t906;
	}
	if (string_ends_with(file, _SLIT("_dragonfly.c.v")) && prefs->os != v__pref__OS_dragonfly) {
		 bool _t907 = false;
		// autofree_scope_vars(pos=3852 line_nr=162 scope.pos=3849 scope.end_pos=3867)
		// af parent scope:
		// var "prefs" var.pos=2600 var.line_nr=120
		// var "file" var.pos=2637 var.line_nr=120
		// af parent scope:
		// af parent scope:
		return _t907;
	}
	if (string_ends_with(file, _SLIT("_solaris.c.v")) && prefs->os != v__pref__OS_solaris) {
		 bool _t908 = false;
		// autofree_scope_vars(pos=3931 line_nr=165 scope.pos=3928 scope.end_pos=3946)
		// af parent scope:
		// var "prefs" var.pos=2600 var.line_nr=120
		// var "file" var.pos=2637 var.line_nr=120
		// af parent scope:
		// af parent scope:
		return _t908;
	}
	if (string_ends_with(file, _SLIT("_x64.v")) && prefs->backend != v__pref__Backend_x64) {
		 bool _t909 = false;
		// autofree_scope_vars(pos=4005 line_nr=168 scope.pos=4002 scope.end_pos=4020)
		// af parent scope:
		// var "prefs" var.pos=2600 var.line_nr=120
		// var "file" var.pos=2637 var.line_nr=120
		// af parent scope:
		// af parent scope:
		return _t909;
	}
	 bool _t910 = true;
	// autofree_scope_vars(pos=4022 line_nr=170 scope.pos=2599 scope.end_pos=4035)
	// var "prefs" var.pos=2600 var.line_nr=120
	// var "file" var.pos=2637 var.line_nr=120
	// af parent scope:
	// af parent scope:
	return _t910;
}

bool v__pref__Preferences_should_compile_asm(v__pref__Preferences* prefs, string path) {
	if (string_count(path, _SLIT(".")) != 2 || string_ends_with(path, _SLIT("c.v")) || string_ends_with(path, _SLIT("js.v"))) {
		 bool _t911 = true;
		// autofree_scope_vars(pos=4184 line_nr=175 scope.pos=4181 scope.end_pos=4198)
		// af parent scope:
		// var "prefs" var.pos=4046 var.line_nr=173
		// var "path" var.pos=4085 var.line_nr=173
		// var "file" var.pos=4201 var.line_nr=177
		// var "arch" var.pos=4237 var.line_nr=178
		// var "os" var.pos=4393 var.line_nr=183
		// af parent scope:
		// af parent scope:
		return _t911;
	}
	string file = string_all_before_last(path, _SLIT(".v"));
	Option_v__pref__Arch _t912 = v__pref__arch_from_string(string_all_after_last(file, _SLIT(".")));
	if (_t912.state != 0) { /*or block*/ 
		IError err = _t912.err;
		*(v__pref__Arch*) _t912.data = v__pref__Arch__auto;
	}
 	v__pref__Arch arch =  *(v__pref__Arch*)_t912.data;
	if (arch != prefs->arch && prefs->arch != v__pref__Arch__auto && arch != v__pref__Arch__auto) {
		 bool _t913 = false;
		// autofree_scope_vars(pos=4375 line_nr=181 scope.pos=4372 scope.end_pos=4390)
		// af parent scope:
		// var "prefs" var.pos=4046 var.line_nr=173
		// var "path" var.pos=4085 var.line_nr=173
		// var "file" var.pos=4201 var.line_nr=177
		// var "arch" var.pos=4237 var.line_nr=178
		// var "os" var.pos=4393 var.line_nr=183
		// af parent scope:
		// af parent scope:
		return _t913;
	}
	Option_v__pref__OS _t914 = v__pref__os_from_string(string_all_before(string_all_after_last(file, _SLIT("_")), _SLIT(".")));
	if (_t914.state != 0) { /*or block*/ 
		IError err = _t914.err;
		*(v__pref__OS*) _t914.data = v__pref__OS__auto;
	}
 	v__pref__OS os =  *(v__pref__OS*)_t914.data;
	if (os != prefs->os && prefs->os != v__pref__OS__auto && os != v__pref__OS__auto) {
		 bool _t915 = false;
		// autofree_scope_vars(pos=4533 line_nr=186 scope.pos=4530 scope.end_pos=4548)
		// af parent scope:
		// var "prefs" var.pos=4046 var.line_nr=173
		// var "path" var.pos=4085 var.line_nr=173
		// var "file" var.pos=4201 var.line_nr=177
		// var "arch" var.pos=4237 var.line_nr=178
		// var "os" var.pos=4393 var.line_nr=183
		// af parent scope:
		// af parent scope:
		return _t915;
	}
	 bool _t916 = true;
	// autofree_scope_vars(pos=4550 line_nr=188 scope.pos=4045 scope.end_pos=4563)
	// var "prefs" var.pos=4046 var.line_nr=173
	// var "path" var.pos=4085 var.line_nr=173
	// var "file" var.pos=4201 var.line_nr=177
	// var "arch" var.pos=4237 var.line_nr=178
	// var "os" var.pos=4393 var.line_nr=183
	// af parent scope:
	// af parent scope:
	return _t916;
}

bool v__pref__Preferences_should_compile_js(v__pref__Preferences* prefs, string file) {
	if (!string_ends_with(file, _SLIT(".js.v")) && string_split(file, _SLIT(".")).len > 2) {
		 bool _t917 = false;
		// autofree_scope_vars(pos=4729 line_nr=194 scope.pos=4688 scope.end_pos=4744)
		// af parent scope:
		// var "prefs" var.pos=4574 var.line_nr=191
		// var "file" var.pos=4612 var.line_nr=191
		// af parent scope:
		// af parent scope:
		return _t917;
	}
	 bool _t918 = true;
	// autofree_scope_vars(pos=4746 line_nr=196 scope.pos=4573 scope.end_pos=4759)
	// var "prefs" var.pos=4574 var.line_nr=191
	// var "file" var.pos=4612 var.line_nr=191
	// af parent scope:
	// af parent scope:
	return _t918;
}

void help__print_and_exit(string topic) {
	string vexe = v__pref__vexe_path();
	string vroot = os__dir(vexe);
	for (int _t919 = 0; _t919 < topic.len; ++_t919) {
		byte b = topic.str[_t919];
		if ((b >= L'a' && b <= L'z') || b == L'-' || (b >= L'0' && b <= L'9')) {
			continue;
		}
		eprintln(_const_help__unknown_topic);
		v_exit(1);
	}
	string name = (string_eq(topic, _SLIT("init")) ? (_SLIT("new")) : (topic));
	string target_topic = os__join_path(vroot, new_array_from_c_array(4, 4, sizeof(string), _MOV((string[4]){_SLIT("cmd"), _SLIT("v"), _SLIT("help"), _STR("%.*s\000.txt", 2, name)})));
	Option_string _t920 = os__read_file(target_topic);
	if (_t920.state != 0) { /*or block*/ 
		IError err = _t920.err;
		eprintln(_const_help__unknown_topic);
		v_exit(1);
	}
 	string content =  *(string*)_t920.data;
	println(content);
	v_exit(0);
}

Option_string v__util__find_working_diff_command(void) {
	string env_difftool = os__getenv(_SLIT("VDIFF_TOOL"));
	string env_diffopts = os__getenv(_SLIT("VDIFF_OPTIONS"));
	if ((env_difftool).len != 0) {
		Option_string _t921;
		opt_ok(&(string[]) { _STR("%.*s\000 %.*s", 2, env_difftool, env_diffopts) }, (Option*)(&_t921), sizeof(string));
		// autofree_scope_vars(pos=283 line_nr=11 scope.pos=280 scope.end_pos=322)
		// af parent scope:
		// var "env_difftool" var.pos=173 var.line_nr=8
		// var "env_diffopts" var.pos=214 var.line_nr=9
		// var "known_diff_tools" var.pos=329 var.line_nr=13
		// af parent scope:
		// af parent scope:
		return _t921;
	}
	Array_string known_diff_tools = __new_array_with_default(0, 0, sizeof(string), 0);
	if (env_difftool.len > 0) {
		array_push(&known_diff_tools, _MOV((string[]){ string_clone(env_difftool) }));
	}
	_PUSH_MANY(&known_diff_tools, (new_array_from_c_array(8, 8, sizeof(string), _MOV((string[8]){_SLIT("colordiff"), _SLIT("gdiff"), _SLIT("diff"), _SLIT("colordiff.exe"), _SLIT("diff.exe"), _SLIT("opendiff"), _SLIT("code"), _SLIT("code.cmd")}))), _t923, Array_string);
	// FOR IN array
	for (int _t924 = 0; _t924 < known_diff_tools.len; ++_t924) {
		string diffcmd = ((string*)known_diff_tools.data)[_t924];
		if (string_eq(diffcmd, _SLIT("opendiff"))) {
			if (v__util__opendiff_exists()) {
				Option_string _t925;
				opt_ok(&(string[]) { diffcmd }, (Option*)(&_t925), sizeof(string));
				// autofree_scope_vars(pos=736 line_nr=23 scope.pos=731 scope.end_pos=755)
				// af parent scope:
				// af parent scope:
				// var "diffcmd" var.pos=610 var.line_nr=20
				// skipping tmp var "diffcmd"
				// var "p" var.pos=775 var.line_nr=27
				// af parent scope:
				// var "env_difftool" var.pos=173 var.line_nr=8
				// var "env_diffopts" var.pos=214 var.line_nr=9
				// var "known_diff_tools" var.pos=329 var.line_nr=13
				// af parent scope:
				// af parent scope:
				return _t925;
			}
			continue;
		}
		os__Result p = os__execute(_STR("%.*s\000 --version", 2, diffcmd));
		if (p.exit_code < 0) {
			continue;
		}
		if (p.exit_code == 127 && string_eq(diffcmd, env_difftool)) {
			return (Option_string){ .state=2, .err=v_error(_STR("could not find specified VDIFF_TOOL %.*s", 1, diffcmd)) };
		}
		if (p.exit_code == 0) {
			if ((string_eq(diffcmd, _SLIT("code")) || string_eq(diffcmd, _SLIT("code.cmd")))) {
				Option_string _t926;
				opt_ok(&(string[]) { _STR("%.*s\000 %.*s\000 -d", 3, diffcmd, env_diffopts) }, (Option*)(&_t926), sizeof(string));
				// autofree_scope_vars(pos=1185 line_nr=39 scope.pos=1080 scope.end_pos=1224)
				// af parent scope:
				// af parent scope:
				// var "diffcmd" var.pos=610 var.line_nr=20
				// skipping tmp var "diffcmd"
				// var "p" var.pos=775 var.line_nr=27
				// af parent scope:
				// var "env_difftool" var.pos=173 var.line_nr=8
				// var "env_diffopts" var.pos=214 var.line_nr=9
				// var "known_diff_tools" var.pos=329 var.line_nr=13
				// af parent scope:
				// af parent scope:
				return _t926;
			}
			Option_string _t927;
			opt_ok(&(string[]) { _STR("%.*s\000 %.*s", 2, diffcmd, env_diffopts) }, (Option*)(&_t927), sizeof(string));
			// autofree_scope_vars(pos=1228 line_nr=41 scope.pos=1029 scope.end_pos=1263)
			// af parent scope:
			// var "diffcmd" var.pos=610 var.line_nr=20
			// skipping tmp var "diffcmd"
			// var "p" var.pos=775 var.line_nr=27
			// af parent scope:
			// var "env_difftool" var.pos=173 var.line_nr=8
			// var "env_diffopts" var.pos=214 var.line_nr=9
			// var "known_diff_tools" var.pos=329 var.line_nr=13
			// af parent scope:
			// af parent scope:
			return _t927;
		}
	}
	return (Option_string){ .state=2, .err=v_error(_SLIT("No working \"diff\" command found")) };
}

VV_LOCAL_SYMBOL bool v__util__opendiff_exists(void) {
	os__Result o = os__execute(_SLIT("opendiff"));
	if (o.exit_code < 0) {
		 bool _t928 = false;
		// autofree_scope_vars(pos=1457 line_nr=51 scope.pos=1454 scope.end_pos=1472)
		// af parent scope:
		// var "o" var.pos=1406 var.line_nr=49
		// af parent scope:
		// af parent scope:
		return _t928;
	}
	if (o.exit_code == 1) {
		if (string_contains(o.output, _SLIT("too few arguments"))) {
			 bool _t929 = true;
			// autofree_scope_vars(pos=1620 line_nr=55 scope.pos=1588 scope.end_pos=1635)
			// af parent scope:
			// af parent scope:
			// var "o" var.pos=1406 var.line_nr=49
			// af parent scope:
			// af parent scope:
			return _t929;
		}
	}
	 bool _t930 = false;
	// autofree_scope_vars(pos=1640 line_nr=58 scope.pos=1380 scope.end_pos=1654)
	// var "o" var.pos=1406 var.line_nr=49
	// af parent scope:
	// af parent scope:
	return _t930;
}

string v__util__color_compare_files(string diff_cmd, string file1, string file2) {
	if ((diff_cmd).len != 0) {
		string full_cmd = _STR("%.*s\000 --minimal --text --unified=2  --show-function-line=\"fn \" \"%.*s\000\" \"%.*s\000\" ", 4, diff_cmd, file1, file2);
		os__Result x = os__execute(full_cmd);
		if (x.exit_code < 0) {
			 string _t931 = _STR("comparison command: `%.*s\000` not found", 2, full_cmd);
			// autofree_scope_vars(pos=1914 line_nr=66 scope.pos=1910 scope.end_pos=1968)
			// af parent scope:
			// var "full_cmd" var.pos=1761 var.line_nr=63
			// var "x" var.pos=1863 var.line_nr=64
			// af parent scope:
			// var "diff_cmd" var.pos=1684 var.line_nr=61
			// var "file1" var.pos=1701 var.line_nr=61
			// var "file2" var.pos=1715 var.line_nr=61
			// af parent scope:
			// af parent scope:
			return _t931;
		}
		 string _t932 = string_trim_right(x.output, _SLIT("\r\n"));
		// autofree_scope_vars(pos=1971 line_nr=68 scope.pos=1757 scope.end_pos=2008)
		// var "full_cmd" var.pos=1761 var.line_nr=63
		// var "x" var.pos=1863 var.line_nr=64
		// af parent scope:
		// var "diff_cmd" var.pos=1684 var.line_nr=61
		// var "file1" var.pos=1701 var.line_nr=61
		// var "file2" var.pos=1715 var.line_nr=61
		// af parent scope:
		// af parent scope:
		return _t932;
	}
	 string _t933 = _SLIT("");
	// autofree_scope_vars(pos=2010 line_nr=70 scope.pos=1664 scope.end_pos=2021)
	// var "diff_cmd" var.pos=1684 var.line_nr=61
	// var "file1" var.pos=1701 var.line_nr=61
	// var "file2" var.pos=1715 var.line_nr=61
	// af parent scope:
	// af parent scope:
	return _t933;
}

string v__util__color_compare_strings(string diff_cmd, string unique_prefix, string expected, string found) {
	string cdir = os__join_path(os__cache_dir(), new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){unique_prefix})));
	Option_bool _t934 = os__mkdir(cdir);
	if (_t934.state != 0) { /*or block*/ 
		IError err = _t934.err;
	};
	u64 ctime = time__sys_mono_now();
	string e_file = os__join_path(cdir, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_STR("%"PRIu64"\000.expected.txt", 2, ctime)})));
	string f_file = os__join_path(cdir, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_STR("%"PRIu64"\000.found.txt", 2, ctime)})));
	Option_void _t935 = os__write_file(e_file, expected);
	if (_t935.state != 0 && _t935.err._typ != _IError_None___index) {
		IError err = _t935.err;
		v_panic(IError_str(err));
	};
	Option_void _t936 = os__write_file(f_file, found);
	if (_t936.state != 0 && _t936.err._typ != _IError_None___index) {
		IError err = _t936.err;
		v_panic(IError_str(err));
	};
	string res = v__util__color_compare_files(diff_cmd, e_file, f_file);
	Option_void _t937 = os__rmdir_all(cdir);
	if (_t937.state != 0 && _t937.err._typ != _IError_None___index) {
		IError err = _t937.err;
	};
	// autofree_scope_vars(pos=2523 line_nr=83 scope.pos=2031 scope.end_pos=2535)
	// var "diff_cmd" var.pos=2053 var.line_nr=73
	// var "unique_prefix" var.pos=2070 var.line_nr=73
	// var "expected" var.pos=2092 var.line_nr=73
	// var "found" var.pos=2109 var.line_nr=73
	// var "cdir" var.pos=2133 var.line_nr=74
	// var "ctime" var.pos=2208 var.line_nr=76
	// var "e_file" var.pos=2238 var.line_nr=77
	// var "f_file" var.pos=2293 var.line_nr=78
	// var "res" var.pos=2444 var.line_nr=81
	// af parent scope:
	// af parent scope:
	return res;
}

v__util__EManager* v__util__new_error_manager(void) {
	 v__util__EManager* _t938 = (v__util__EManager*)memdup(&(v__util__EManager){.support_color = term__can_show_color_on_stderr() && term__can_show_color_on_stdout(),}, sizeof(v__util__EManager));
	// autofree_scope_vars(pos=1230 line_nr=38 scope.pos=1198 scope.end_pos=1336)
	// af parent scope:
	// af parent scope:
	return _t938;
}

void v__util__EManager_set_support_color(v__util__EManager* e, bool b) {
	{ // Unsafe block
		v__util__EManager* me = e;
		me->support_color = b;
	}
}

string v__util__bold(string msg) {
	if (!_const_v__util__emanager->support_color) {
		// autofree_scope_vars(pos=1510 line_nr=52 scope.pos=1507 scope.end_pos=1523)
		// af parent scope:
		// var "msg" var.pos=1453 var.line_nr=50
		// af parent scope:
		// af parent scope:
		return msg;
	}
	 string _t939 = term__bold(msg);
	// autofree_scope_vars(pos=1525 line_nr=54 scope.pos=1448 scope.end_pos=1548)
	// var "msg" var.pos=1453 var.line_nr=50
	// af parent scope:
	// af parent scope:
	return _t939;
}

VV_LOCAL_SYMBOL string v__util__color(string kind, string msg) {
	if (!_const_v__util__emanager->support_color) {
		// autofree_scope_vars(pos=1630 line_nr=59 scope.pos=1627 scope.end_pos=1643)
		// af parent scope:
		// var "kind" var.pos=1560 var.line_nr=57
		// var "msg" var.pos=1573 var.line_nr=57
		// af parent scope:
		// af parent scope:
		return msg;
	}
	if (string_contains(kind, _SLIT("error"))) {
		 string _t940 = term__red(msg);
		// autofree_scope_vars(pos=1675 line_nr=62 scope.pos=1672 scope.end_pos=1698)
		// af parent scope:
		// var "kind" var.pos=1560 var.line_nr=57
		// var "msg" var.pos=1573 var.line_nr=57
		// af parent scope:
		// af parent scope:
		return _t940;
	}
	if (string_contains(kind, _SLIT("notice"))) {
		 string _t941 = term__yellow(msg);
		// autofree_scope_vars(pos=1731 line_nr=65 scope.pos=1728 scope.end_pos=1757)
		// af parent scope:
		// var "kind" var.pos=1560 var.line_nr=57
		// var "msg" var.pos=1573 var.line_nr=57
		// af parent scope:
		// af parent scope:
		return _t941;
	}
	 string _t942 = term__magenta(msg);
	// autofree_scope_vars(pos=1759 line_nr=67 scope.pos=1554 scope.end_pos=1785)
	// var "kind" var.pos=1560 var.line_nr=57
	// var "msg" var.pos=1573 var.line_nr=57
	// af parent scope:
	// af parent scope:
	return _t942;
}

string v__util__formatted_error(string kind, string omsg, string filepath, v__token__Position pos) {
	string emsg = string_replace(omsg, _SLIT("main."), _SLIT(""));
	string path = filepath;
	string verror_paths_override = os__getenv(_SLIT("VERROR_PATHS"));
	if (string_eq(verror_paths_override, _SLIT("absolute"))) {
		path = os__real_path(path);
	} else {
		string workdir = string_add(os__getwd(), _const_os__path_separator);
		if (string_starts_with(path, workdir)) {
			path = string_replace(path, workdir, _SLIT(""));
		}
	}
	Option_string _t943 = v__util__read_file(filepath);
	if (_t943.state != 0) { /*or block*/ 
		IError err = _t943.err;
		*(string*) _t943.data = _SLIT("");
	}
 	string source =  *(string*)_t943.data;
	string position = _STR("%.*s\000:%"PRId32"\000:%"PRId32"\000:", 4, path, pos.line_nr + 1, math__mathutil__max_T_int(1, pos.col + 1));
	string scontext = Array_string_join(v__util__source_context(kind, source, pos), _SLIT("\n"));
	string final_position = v__util__bold(position);
	string final_kind = v__util__bold(v__util__color(kind, kind));
	string final_msg = emsg;
	string final_context = (scontext.len > 0 ? (_STR("\n%.*s", 1, scontext)) : (_SLIT("")));
	 string _t944 = string_trim_space(_STR("%.*s\000 %.*s\000 %.*s\000%.*s", 4, final_position, final_kind, final_msg, final_context));
	// autofree_scope_vars(pos=2602 line_nr=93 scope.pos=1848 scope.end_pos=2678)
	// var "kind" var.pos=1864 var.line_nr=71
	// var "omsg" var.pos=1877 var.line_nr=71
	// var "filepath" var.pos=1890 var.line_nr=71
	// var "pos" var.pos=1907 var.line_nr=71
	// var "emsg" var.pos=1937 var.line_nr=72
	// var "path" var.pos=1976 var.line_nr=73
	// var "verror_paths_override" var.pos=1994 var.line_nr=74
	// var "source" var.pos=2273 var.line_nr=85
	// var "position" var.pos=2314 var.line_nr=86
	// var "scontext" var.pos=2381 var.line_nr=87
	// var "final_position" var.pos=2439 var.line_nr=88
	// var "final_kind" var.pos=2473 var.line_nr=89
	// var "final_msg" var.pos=2512 var.line_nr=90
	// var "final_context" var.pos=2531 var.line_nr=91
	// af parent scope:
	// af parent scope:
	return _t944;
}

Array_string v__util__source_context(string kind, string source, v__token__Position pos) {
	Array_string clines = __new_array_with_default(0, 0, sizeof(string), 0);
	if (source.len == 0) {
		// autofree_scope_vars(pos=2811 line_nr=99 scope.pos=2808 scope.end_pos=2827)
		// af parent scope:
		// var "kind" var.pos=2703 var.line_nr=96
		// var "source" var.pos=2716 var.line_nr=96
		// var "pos" var.pos=2731 var.line_nr=96
		// var "clines" var.pos=2767 var.line_nr=97
		// var "source_lines" var.pos=2830 var.line_nr=101
		// var "bline" var.pos=2873 var.line_nr=102
		// var "aline" var.pos=2934 var.line_nr=103
		// var "tab_spaces" var.pos=3024 var.line_nr=104
		// af parent scope:
		// af parent scope:
		return clines;
	}
	Array_string source_lines = string_split_into_lines(source);
	int bline = math__mathutil__max_T_int(0, pos.line_nr - _const_v__util__error_context_before);
	int aline = math__mathutil__max_T_int(0, math__mathutil__min_T_int(source_lines.len - 1, pos.line_nr + _const_v__util__error_context_after));
	string tab_spaces = _SLIT("    ");
	for (int iline = bline; iline <= aline; iline++) {
		string sline = (*(string*)/*ee elem_typ */array_get(source_lines, iline));
		int start_column = math__mathutil__max_T_int(0, math__mathutil__min_T_int(pos.col, sline.len));
		int end_column = math__mathutil__max_T_int(0, math__mathutil__min_T_int(pos.col + math__mathutil__max_T_int(0, pos.len), sline.len));
		string cline = (iline == pos.line_nr ? (string_add(string_add(string_substr(sline, 0, start_column), v__util__color(kind, string_substr(sline, start_column, end_column))), string_substr(sline, end_column, sline.len))) : (sline));
		array_push(&clines, _MOV((string[]){ string_clone(string_add(_STR("%5"PRId32"\000 | ", 2, iline + 1), string_replace(cline, _SLIT("\t"), tab_spaces))) }));
		if (iline == pos.line_nr) {
			strings__Builder pointerline_builder = strings__new_builder(sline.len);
			for (int i = 0; i < start_column; ) {
				if (byte_is_space(string_at(sline, i))) {
					strings__Builder_write_b(&pointerline_builder, string_at(sline, i));
					i++;
				} else {
					int char_len = utf8_char_len(string_at(sline, i));
					string spaces = string_repeat(_SLIT(" "), utf8_str_visible_length(string_substr(sline, i, i + char_len)));
					strings__Builder_write_string(&pointerline_builder, spaces);
					i += char_len;
				}
			}
			int underline_len = utf8_str_visible_length(string_substr(sline, start_column, end_column));
			string underline = (underline_len > 1 ? (string_repeat(_SLIT("~"), underline_len)) : (_SLIT("^")));
			strings__Builder_write_string(&pointerline_builder, v__util__bold(v__util__color(kind, underline)));
			array_push(&clines, _MOV((string[]){ string_clone(string_add(_SLIT("      | "), string_replace(strings__Builder_str(&pointerline_builder), _SLIT("\t"), tab_spaces))) }));
		}
	}
	// autofree_scope_vars(pos=4456 line_nr=140 scope.pos=2688 scope.end_pos=4471)
	// var "kind" var.pos=2703 var.line_nr=96
	// var "source" var.pos=2716 var.line_nr=96
	// var "pos" var.pos=2731 var.line_nr=96
	// var "clines" var.pos=2767 var.line_nr=97
	// var "source_lines" var.pos=2830 var.line_nr=101
	// var "bline" var.pos=2873 var.line_nr=102
	// var "aline" var.pos=2934 var.line_nr=103
	// var "tab_spaces" var.pos=3024 var.line_nr=104
	// str literal
	// af parent scope:
	// af parent scope:
	return clines;
}

void v__util__verror(string kind, string s) {
	string final_kind = v__util__bold(v__util__color(kind, kind));
	eprintln(_STR("%.*s\000: %.*s", 2, final_kind, s));
	v_exit(1);
}

string v__util__vlines_escape_path(string path, string ccompiler) {
	bool is_cc_tcc = string_contains(ccompiler, _SLIT("tcc"));
	if (is_cc_tcc) {
		 string _t947 = string_add(_SLIT("../../../../../.."), v__util__cescaped_path(os__real_path(path)));
		// autofree_scope_vars(pos=4895 line_nr=155 scope.pos=4713 scope.end_pos=4960)
		// af parent scope:
		// var "path" var.pos=4619 var.line_nr=149
		// var "ccompiler" var.pos=4632 var.line_nr=149
		// var "is_cc_tcc" var.pos=4660 var.line_nr=150
		// af parent scope:
		// af parent scope:
		return _t947;
	}
	 string _t948 = v__util__cescaped_path(os__real_path(path));
	// autofree_scope_vars(pos=4962 line_nr=157 scope.pos=4600 scope.end_pos=5004)
	// var "path" var.pos=4619 var.line_nr=149
	// var "ccompiler" var.pos=4632 var.line_nr=149
	// var "is_cc_tcc" var.pos=4660 var.line_nr=150
	// af parent scope:
	// af parent scope:
	return _t948;
}

VV_LOCAL_SYMBOL void v__util__trace_mod_path_to_full_name(string line, string mod, string file_path, string res) {
	eprintln(_STR("> %.*s\000 %.*s\000 mod: %*.*s\000 | file_path: %*.*s\000 | result: %.*s", 5, line, _SLIT("trace_mod_path_to_full_name"), mod, -20, file_path, -30, res));
}

string v__util__qualify_import(v__pref__Preferences* pref, string mod, string file_path) {
	Array_string mod_paths = array_clone(&pref->lookup_path);
	_PUSH_MANY(&mod_paths, (os__vmodules_paths()), _t949, Array_string);
	string mod_path = string_replace(mod, _SLIT("."), _const_os__path_separator);
	// FOR IN array
	for (int _t950 = 0; _t950 < mod_paths.len; ++_t950) {
		string search_path = ((string*)mod_paths.data)[_t950];
		string try_path = os__join_path(search_path, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){mod_path})));
		if (os__is_dir(try_path)) {
			Option_string _t951;
			if (_t951 = v__util__mod_path_to_full_name(mod, try_path), _t951.state == 0) {
				string m1 = *(string*)_t951.data;
				// autofree_scope_vars(pos=697 line_nr=20 scope.pos=587 scope.end_pos=711)
				// af parent scope:
				// var "m1" var.pos=544 var.line_nr=16
				// af parent scope:
				// af parent scope:
				// var "search_path" var.pos=434 var.line_nr=13
				// skipping tmp var "search_path"
				// var "try_path" var.pos=463 var.line_nr=14
				// af parent scope:
				// var "pref" var.pos=240 var.line_nr=9
				// var "mod" var.pos=264 var.line_nr=9
				// var "file_path" var.pos=276 var.line_nr=9
				// var "mod_paths" var.pos=308 var.line_nr=10
				// var "mod_path" var.pos=381 var.line_nr=12
				// af parent scope:
				// af parent scope:
				return m1;
			}
		}
	}
	Option_string _t952;
	if (_t952 = v__util__mod_path_to_full_name(mod, file_path), _t952.state == 0) {
		string m1 = *(string*)_t952.data;
		// autofree_scope_vars(pos=871 line_nr=28 scope.pos=768 scope.end_pos=883)
		// af parent scope:
		// var "m1" var.pos=724 var.line_nr=24
		// af parent scope:
		// var "pref" var.pos=240 var.line_nr=9
		// var "mod" var.pos=264 var.line_nr=9
		// var "file_path" var.pos=276 var.line_nr=9
		// var "mod_paths" var.pos=308 var.line_nr=10
		// var "mod_path" var.pos=381 var.line_nr=12
		// af parent scope:
		// af parent scope:
		return m1;
	}
	// autofree_scope_vars(pos=885 line_nr=30 scope.pos=225 scope.end_pos=897)
	// var "pref" var.pos=240 var.line_nr=9
	// var "mod" var.pos=264 var.line_nr=9
	// var "file_path" var.pos=276 var.line_nr=9
	// var "mod_paths" var.pos=308 var.line_nr=10
	// var "mod_path" var.pos=381 var.line_nr=12
	// af parent scope:
	// af parent scope:
	return mod;
}

string v__util__qualify_module(string mod, string file_path) {
	if (string_eq(mod, _SLIT("main"))) {
		// autofree_scope_vars(pos=982 line_nr=35 scope.pos=979 scope.end_pos=995)
		// af parent scope:
		// var "mod" var.pos=922 var.line_nr=33
		// var "file_path" var.pos=934 var.line_nr=33
		// var "clean_file_path" var.pos=998 var.line_nr=37
		// af parent scope:
		// af parent scope:
		return mod;
	}
	string clean_file_path = string_all_before_last(file_path, _SLIT("/"));
	if (string_eq(string_replace(clean_file_path, string_add(os__getwd(), _const_os__path_separator), _SLIT("")), mod)) {
		// autofree_scope_vars(pos=1232 line_nr=41 scope.pos=1229 scope.end_pos=1245)
		// af parent scope:
		// var "mod" var.pos=922 var.line_nr=33
		// var "file_path" var.pos=934 var.line_nr=33
		// var "clean_file_path" var.pos=998 var.line_nr=37
		// af parent scope:
		// af parent scope:
		return mod;
	}
	Option_string _t953;
	if (_t953 = v__util__mod_path_to_full_name(mod, clean_file_path), _t953.state == 0) {
		string m1 = *(string*)_t953.data;
		// autofree_scope_vars(pos=1410 line_nr=47 scope.pos=1301 scope.end_pos=1422)
		// af parent scope:
		// var "m1" var.pos=1251 var.line_nr=43
		// af parent scope:
		// var "mod" var.pos=922 var.line_nr=33
		// var "file_path" var.pos=934 var.line_nr=33
		// var "clean_file_path" var.pos=998 var.line_nr=37
		// af parent scope:
		// af parent scope:
		return m1;
	}
	// autofree_scope_vars(pos=1424 line_nr=49 scope.pos=907 scope.end_pos=1436)
	// var "mod" var.pos=922 var.line_nr=33
	// var "file_path" var.pos=934 var.line_nr=33
	// var "clean_file_path" var.pos=998 var.line_nr=37
	// af parent scope:
	// af parent scope:
	return mod;
}

Option_string v__util__mod_path_to_full_name(string mod, string path) {
	Array_string vmod_folders = new_array_from_c_array(3, 3, sizeof(string), _MOV((string[3]){_SLIT("vlib"), _SLIT(".vmodules"), _SLIT("modules")}));
	bool in_vmod_path = false;
	// FOR IN array
	for (int _t954 = 0; _t954 < vmod_folders.len; ++_t954) {
		string vmod_folder = ((string*)vmod_folders.data)[_t954];
		if (string_contains(path, string_add(vmod_folder, _const_os__path_separator))) {
			in_vmod_path = true;
			break;
		}
	}
	Array_string path_parts = string_split(path, _const_os__path_separator);
	string mod_path = string_replace(mod, _SLIT("."), _const_os__path_separator);
	for (int i = path_parts.len - 1; i >= 0; i--) {
		string try_path = os__join_path(Array_string_join(array_slice(path_parts, 0, i), _const_os__path_separator), new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){mod_path})));
		if (os__is_dir(try_path)) {
			if (in_vmod_path) {
				for (int j = i; j >= 0; j--) {
					string path_part = (*(string*)/*ee elem_typ */array_get(path_parts, j));
					if ((Array_string_contains(vmod_folders, path_part))) {
						string mod_full_name = Array_string_join(array_slice(string_split(try_path, _const_os__path_separator), j + 1, string_split(try_path, _const_os__path_separator).len), _SLIT("."));
						Option_string _t955;
						opt_ok(&(string[]) { mod_full_name }, (Option*)(&_t955), sizeof(string));
						// autofree_scope_vars(pos=2802 line_nr=83 scope.pos=2719 scope.end_pos=2829)
						// var "mod_full_name" var.pos=2727 var.line_nr=82
						// af parent scope:
						// var "j" var.pos=2598 var.line_nr=78
						// var "path_part" var.pos=2625 var.line_nr=79
						// af parent scope:
						// af parent scope:
						// af parent scope:
						// var "i" var.pos=2282 var.line_nr=71
						// var "try_path" var.pos=2323 var.line_nr=72
						// af parent scope:
						// var "mod" var.pos=1732 var.line_nr=57
						// var "path" var.pos=1744 var.line_nr=57
						// var "vmod_folders" var.pos=1886 var.line_nr=60
						// var "in_vmod_path" var.pos=1940 var.line_nr=61
						// var "path_parts" var.pos=2091 var.line_nr=68
						// var "mod_path" var.pos=2136 var.line_nr=69
						// af parent scope:
						// af parent scope:
						return _t955;
					}
				}
			} else {
				Array_string try_path_parts = string_split(try_path, _const_os__path_separator);
				int last_v_mod = -1;
				for (int j = try_path_parts.len; j > 0; j--) {
					string parent = Array_string_join(array_slice(try_path_parts, 0, j), _const_os__path_separator);
					Option_Array_string _t956;
					if (_t956 = os__ls(parent), _t956.state == 0) {
						Array_string ls = *(Array_string*)_t956.data;
						if ((Array_string_contains(ls, _SLIT("v.mod"))) && (try_path_parts.len > i && string_ne((*(string*)/*ee elem_typ */array_get(try_path_parts, i)), _SLIT("v")) && !(Array_string_contains(ls, _SLIT("vlib"))))) {
							last_v_mod = j;
						}
						continue;
					}
					break;
				}
				if (last_v_mod > -1) {
					string mod_full_name = Array_string_join(array_slice(try_path_parts, last_v_mod, try_path_parts.len), _SLIT("."));
					Option_string _t957;
					opt_ok(&(string[]) { mod_full_name }, (Option*)(&_t957), sizeof(string));
					// autofree_scope_vars(pos=3708 line_nr=107 scope.pos=3641 scope.end_pos=3734)
					// var "mod_full_name" var.pos=3648 var.line_nr=106
					// af parent scope:
					// var "try_path_parts" var.pos=3012 var.line_nr=89
					// var "last_v_mod" var.pos=3132 var.line_nr=91
					// af parent scope:
					// af parent scope:
					// var "i" var.pos=2282 var.line_nr=71
					// var "try_path" var.pos=2323 var.line_nr=72
					// af parent scope:
					// var "mod" var.pos=1732 var.line_nr=57
					// var "path" var.pos=1744 var.line_nr=57
					// var "vmod_folders" var.pos=1886 var.line_nr=60
					// var "in_vmod_path" var.pos=1940 var.line_nr=61
					// var "path_parts" var.pos=2091 var.line_nr=68
					// var "mod_path" var.pos=2136 var.line_nr=69
					// af parent scope:
					// af parent scope:
					return _t957;
				}
			}
		}
	}
	return (Option_string){ .state=2, .err=v_error(_SLIT("module not found")) };
}

string v__util__smart_quote(string str, bool raw) {
	int len = str.len;
	if (len == 0) {
		// autofree_scope_vars(pos=167 line_nr=11 scope.pos=164 scope.end_pos=180)
		// af parent scope:
		// var "str" var.pos=104 var.line_nr=8
		// var "raw" var.pos=116 var.line_nr=8
		// var "len" var.pos=136 var.line_nr=9
		// var "result" var.pos=187 var.line_nr=13
		// var "pos" var.pos=225 var.line_nr=14
		// var "last" var.pos=240 var.line_nr=15
		// var "next" var.pos=296 var.line_nr=17
		// var "skip_next" var.pos=312 var.line_nr=18
		// af parent scope:
		// af parent scope:
		return str;
	}
	strings__Builder result = strings__new_builder(0);
	int pos = -1;
	string last = _SLIT("");
	string next = _SLIT("");
	bool skip_next = false;
	for (;;) {
		pos = pos + 1;
		if (skip_next) {
			skip_next = false;
			pos = pos + 1;
		}
		if (pos >= len) {
			break;
		}
		if (pos + 1 < len) {
			{ // Unsafe block
				next = byte_ascii_str(str.str[pos + 1]);
			}
		}
		string current = str;
		string toadd = str;
		if (len > 1) {
			{ // Unsafe block
				current = byte_ascii_str(str.str[pos]);
			}
			toadd = current;
		}
		if (string_eq(current, _SLIT("\""))) {
			toadd = _SLIT("\\\"");
			current = _SLIT("");
		}
		if (string_eq(current, _SLIT("\\"))) {
			if (raw) {
				toadd = _SLIT("\\\\");
			} else {
				if (string_eq(next, _SLIT("\\"))) {
					toadd = _SLIT("\\\\");
					skip_next = true;
				} else if ((next).len != 0) {
					if (raw) {
						toadd = string_add(_SLIT("\\\\"), next);
						skip_next = true;
					} else if (!(Array_string_contains(_const_v__util__invalid_escapes, next))) {
						toadd = string_add(_SLIT("\\"), next);
						skip_next = true;
					} else {
						toadd = next;
						skip_next = true;
					}
				}
			}
		}
		if (string_eq(current, _SLIT("\n"))) {
			toadd = _SLIT("\\n");
			current = _SLIT("");
		} else if (string_eq(current, _SLIT("\r")) && string_eq(next, _SLIT("\n"))) {
			toadd = _SLIT("\r\n");
			current = _SLIT("");
			skip_next = true;
		}
		if (!raw && string_eq(current, _SLIT("$"))) {
			if (string_eq(last, _SLIT("\\"))) {
				toadd = _SLIT("\\$");
			}
		}
		if (!raw && string_eq(current, _SLIT("\r"))) {
			if (string_eq(next, _SLIT("\n"))) {
				skip_next = true;
				toadd = _SLIT("\\n");
			}
		}
		strings__Builder_write_string(&result, toadd);
		last = current;
	}
	 string _t958 = strings__Builder_str(&result);
	// autofree_scope_vars(pos=1681 line_nr=95 scope.pos=92 scope.end_pos=1702)
	// var "str" var.pos=104 var.line_nr=8
	// var "raw" var.pos=116 var.line_nr=8
	// var "len" var.pos=136 var.line_nr=9
	// var "result" var.pos=187 var.line_nr=13
	// var "pos" var.pos=225 var.line_nr=14
	// var "last" var.pos=240 var.line_nr=15
	// str literal
	// var "next" var.pos=296 var.line_nr=17
	// str literal
	// var "skip_next" var.pos=312 var.line_nr=18
	// af parent scope:
	// af parent scope:
	return _t958;
}

// Attr: [inline]
inline bool v__util__is_name_char(byte c) {
	 bool _t959 = (c >= L'a' && c <= L'z') || (c >= L'A' && c <= L'Z') || c == L'_';
	// autofree_scope_vars(pos=57 line_nr=4 scope.pos=29 scope.end_pos=126)
	// var "c" var.pos=42 var.line_nr=3
	// af parent scope:
	// af parent scope:
	return _t959;
}

// Attr: [inline]
inline bool v__util__is_func_char(byte c) {
	 bool _t960 = (c >= L'a' && c <= L'z') || (c >= L'A' && c <= L'Z') || c == L'_' || byte_is_digit(c);
	// autofree_scope_vars(pos=173 line_nr=9 scope.pos=145 scope.end_pos=258)
	// var "c" var.pos=158 var.line_nr=8
	// af parent scope:
	// af parent scope:
	return _t960;
}

// Attr: [inline]
inline bool v__util__is_nl(byte c) {
	 bool _t961 = c == L'\r' || c == L'\n';
	// autofree_scope_vars(pos=298 line_nr=14 scope.pos=277 scope.end_pos=329)
	// var "c" var.pos=283 var.line_nr=13
	// af parent scope:
	// af parent scope:
	return _t961;
}

bool v__util__contains_capital(string s) {
	for (int _t962 = 0; _t962 < s.len; ++_t962) {
		byte c = s.str[_t962];
		if (c >= L'A' && c <= L'Z') {
			 bool _t963 = true;
			// autofree_scope_vars(pos=417 line_nr=20 scope.pos=413 scope.end_pos=432)
			// af parent scope:
			// var "c" var.pos=378 var.line_nr=18
			// skipping tmp var "c"
			// af parent scope:
			// var "s" var.pos=356 var.line_nr=17
			// af parent scope:
			// af parent scope:
			return _t963;
		}
	}
	 bool _t964 = false;
	// autofree_scope_vars(pos=437 line_nr=23 scope.pos=339 scope.end_pos=451)
	// var "s" var.pos=356 var.line_nr=17
	// af parent scope:
	// af parent scope:
	return _t964;
}

bool v__util__good_type_name(string s) {
	if (s.len < 4) {
		 bool _t965 = true;
		// autofree_scope_vars(pos=551 line_nr=30 scope.pos=548 scope.end_pos=565)
		// af parent scope:
		// var "s" var.pos=517 var.line_nr=28
		// af parent scope:
		// af parent scope:
		return _t965;
	}
	for (int i = 2; i < s.len; ++i) {
		if (byte_is_capital(string_at(s, i)) && byte_is_capital(string_at(s, i - 1)) && byte_is_capital(string_at(s, i - 2))) {
			 bool _t966 = false;
			// autofree_scope_vars(pos=667 line_nr=34 scope.pos=663 scope.end_pos=683)
			// af parent scope:
			// var "i" var.pos=572 var.line_nr=32
			// skipping tmp var "i"
			// af parent scope:
			// var "s" var.pos=517 var.line_nr=28
			// af parent scope:
			// af parent scope:
			return _t966;
		}
	}
	 bool _t967 = true;
	// autofree_scope_vars(pos=688 line_nr=37 scope.pos=502 scope.end_pos=701)
	// var "s" var.pos=517 var.line_nr=28
	// af parent scope:
	// af parent scope:
	return _t967;
}

// Attr: [inline]
inline bool v__util__is_generic_type_name(string name) {
	 bool _t968 = name.len == 1 && string_is_capital(name) && string_ne(name, _SLIT("C"));
	// autofree_scope_vars(pos=843 line_nr=43 scope.pos=802 scope.end_pos=901)
	// var "name" var.pos=823 var.line_nr=42
	// af parent scope:
	// af parent scope:
	return _t968;
}

string v__util__cescaped_path(string s) {
	 string _t969 = string_replace(s, _SLIT("\\"), _SLIT("\\\\"));
	// autofree_scope_vars(pos=944 line_nr=47 scope.pos=911 scope.end_pos=976)
	// var "s" var.pos=925 var.line_nr=46
	// af parent scope:
	// af parent scope:
	return _t969;
}

v__util__Suggestion v__util__new_suggestion(string wanted, Array_string possibilities) {
	v__util__Suggestion s = (v__util__Suggestion){.known = __new_array(0, 1, sizeof(v__util__Possibility)),.wanted = wanted,.swanted = v__util__short_module_name(wanted),};
	v__util__Suggestion_add_many(&s, possibilities);
	v__util__Suggestion_sort(&s);
	// autofree_scope_vars(pos=377 line_nr=25 scope.pos=194 scope.end_pos=387)
	// var "wanted" var.pos=209 var.line_nr=18
	// var "possibilities" var.pos=224 var.line_nr=18
	// var "s" var.pos=266 var.line_nr=19
	// af parent scope:
	// af parent scope:
	return s;
}

void v__util__Suggestion_add(v__util__Suggestion* s, string val) {
	if ((string_eq(val, s->wanted) || string_eq(val, s->swanted))) {
		return;
	}
	string sval = v__util__short_module_name(val);
	if ((string_eq(sval, s->wanted) || string_eq(sval, s->swanted))) {
		return;
	}
	f32 similarity = ((f32)(((int)(strings__dice_coefficient(s->swanted, sval) * 1000)))) / 1000;
	array_push(&s->known, _MOV((v__util__Possibility[]){ (v__util__Possibility){.value = val,.svalue = sval,.similarity = similarity,} }));
}

void v__util__Suggestion_add_many(v__util__Suggestion* s, Array_string many) {
	// FOR IN array
	for (int _t971 = 0; _t971 < many.len; ++_t971) {
		string x = ((string*)many.data)[_t971];
		v__util__Suggestion_add(s, x);
	}
}

void v__util__Suggestion_sort(v__util__Suggestion* s) {
	qsort(s->known.data, s->known.len, s->known.element_size, (int (*)(const void *, const void *))&compare__t972_v__util__Possibility);
}

string v__util__Suggestion_say(v__util__Suggestion s, string msg) {
	string res = msg;
	bool found = false;
	if (s.known.len > 0) {
		v__util__Possibility top_posibility = (*(v__util__Possibility*)array_last(s.known));
		if (top_posibility.similarity > 0.5) {
			string val = top_posibility.value;
			if (!string_starts_with(val, _SLIT("[]"))) {
				res = /*f*/string_add(res, _STR(".\nDid you mean `%.*s\000`?", 2, val));
				found = true;
			}
		}
	}
	if (!found) {
		if (s.known.len > 0) {
			Array_v__util__Possibility _t973_orig = s.known;
			int _t973_len = _t973_orig.len;
			Array_string _t973 = __new_array(0, _t973_len, sizeof(string));

			for (int _t974 = 0; _t974 < _t973_len; ++_t974) {
				v__util__Possibility it = ((v__util__Possibility*) _t973_orig.data)[_t974];
				string ti = _STR("`%.*s\000`", 2, it.svalue);
				array_push(&_t973, &ti);
			}
			
			Array_string values = _t973;
			qsort(values.data, values.len, values.element_size, (int (*)(const void *, const void *))&compare_strings);
			if (values.len == 1) {
				res = /*f*/string_add(res, _STR(".\n1 possibility: %.*s\000.", 2, (*(string*)/*ee elem_typ */array_get(values, 0))));
			} else if (values.len < 25) {
				res = /*f*/string_add(res, string_add(string_add(_STR(".\n%"PRId32"\000 possibilities: ", 2, values.len), Array_string_join(values, _SLIT(", "))), _SLIT(".")));
			}
		}
	}
	// autofree_scope_vars(pos=1594 line_nr=80 scope.pos=963 scope.end_pos=1606)
	// var "s" var.pos=964 var.line_nr=55
	// var "msg" var.pos=982 var.line_nr=55
	// var "res" var.pos=1008 var.line_nr=56
	// var "found" var.pos=1024 var.line_nr=57
	// af parent scope:
	// af parent scope:
	return res;
}

string v__util__short_module_name(string name) {
	if (!string_contains(name, _SLIT("."))) {
		// autofree_scope_vars(pos=1683 line_nr=85 scope.pos=1680 scope.end_pos=1697)
		// af parent scope:
		// var "name" var.pos=1634 var.line_nr=83
		// var "vals" var.pos=1700 var.line_nr=87
		// var "mname" var.pos=1761 var.line_nr=91
		// var "symname" var.pos=1790 var.line_nr=92
		// af parent scope:
		// af parent scope:
		return name;
	}
	Array_string vals = string_split(name, _SLIT("."));
	if (vals.len < 2) {
		// autofree_scope_vars(pos=1744 line_nr=89 scope.pos=1741 scope.end_pos=1758)
		// af parent scope:
		// var "name" var.pos=1634 var.line_nr=83
		// var "vals" var.pos=1700 var.line_nr=87
		// var "mname" var.pos=1761 var.line_nr=91
		// var "symname" var.pos=1790 var.line_nr=92
		// af parent scope:
		// af parent scope:
		return name;
	}
	string mname = (*(string*)/*ee elem_typ */array_get(vals, vals.len - 2));
	string symname = (*(string*)/*ee elem_typ */array_get(vals, vals.len - 1));
	 string _t975 = _STR("%.*s\000.%.*s", 2, mname, symname);
	// autofree_scope_vars(pos=1820 line_nr=93 scope.pos=1616 scope.end_pos=1848)
	// var "name" var.pos=1634 var.line_nr=83
	// var "vals" var.pos=1700 var.line_nr=87
	// var "mname" var.pos=1761 var.line_nr=91
	// var "symname" var.pos=1790 var.line_nr=92
	// af parent scope:
	// af parent scope:
	return _t975;
}

v__util__Timers* v__util__new_timers(bool should_print) {
	 v__util__Timers* _t976 = (v__util__Timers*)memdup(&(v__util__Timers){.swatches = new_map(sizeof(string), sizeof(time__StopWatch), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.should_print = should_print,}, sizeof(v__util__Timers));
	// autofree_scope_vars(pos=341 line_nr=15 scope.pos=301 scope.end_pos=430)
	// var "should_print" var.pos=312 var.line_nr=14
	// af parent scope:
	// af parent scope:
	return _t976;
}

v__util__Timers* v__util__get_timers(void) {
	// autofree_scope_vars(pos=497 line_nr=24 scope.pos=474 scope.end_pos=517)
	// af parent scope:
	// af parent scope:
	return _const_v__util__timers;
}

void v__util__timing_start(string label) {
	v__util__Timers_start(v__util__get_timers(), label);
}

void v__util__timing_measure(string label) {
	v__util__Timers_show(v__util__get_timers(), label);
}

void v__util__timing_measure_cumulative(string label) {
	v__util__Timers_measure_cumulative(v__util__get_timers(), label);
}

void v__util__timing_set_should_print(bool should_print) {
	v__util__Timers* t = _const_v__util__timers;
	t->should_print = should_print;
}

void v__util__Timers_start(v__util__Timers* t, string name) {
	time__StopWatch* _t978 = (time__StopWatch*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, t->swatches), &(string[]){name}));
	Option_time__StopWatch _t977 = {0};
	if (_t978) {
		*((time__StopWatch*)&_t977.data) = *((time__StopWatch*)_t978);
	} else {
		_t977.state = 2; _t977.err = v_error(_SLIT("array index out of range"));
	}
	;
	if (_t977.state != 0) { /*or block*/ 
		IError err = _t977.err;
		*(time__StopWatch*) _t977.data = time__new_stopwatch((time__StopWatchOptions){.auto_start = true,});
	}
	time__StopWatch sw = *(time__StopWatch*)_t977.data;
	time__StopWatch_start(&sw);
	(*(time__StopWatch*)map_get_and_set(&t->swatches, &(string[]){name}, &(time__StopWatch[]){ {0} })) = sw;
}

i64 v__util__Timers_measure(v__util__Timers* t, string name) {
	if (!_IN_MAP(ADDR(string, name), ADDR(map, t->swatches))) {
		Array_string timer_keys = map_keys(&t->swatches);
		eprintln(_STR("> Timer `%.*s\000` was NOT started.", 2, name));
		eprintln(_SLIT(">   Available timers:"));
		eprintln(_STR(">   %.*s", 1, Array_string_str(timer_keys)));
	}
	i64 ms = time__Duration_microseconds(time__StopWatch_elapsed((*(time__StopWatch*)map_get(ADDR(map, t->swatches), &(string[]){name}, &(time__StopWatch[]){ {0} }))));
	// autofree_scope_vars(pos=1266 line_nr=58 scope.pos=999 scope.end_pos=1277)
	// var "t" var.pos=1004 var.line_nr=50
	// var "name" var.pos=1022 var.line_nr=50
	// var "ms" var.pos=1218 var.line_nr=57
	// af parent scope:
	// af parent scope:
	return ms;
}

i64 v__util__Timers_measure_cumulative(v__util__Timers* t, string name) {
	i64 ms = v__util__Timers_measure(t, name);
	if (!_IN_MAP(ADDR(string, name), ADDR(map, t->swatches))) {
		// autofree_scope_vars(pos=1390 line_nr=64 scope.pos=1387 scope.end_pos=1402)
		// af parent scope:
		// var "t" var.pos=1292 var.line_nr=61
		// var "name" var.pos=1321 var.line_nr=61
		// var "ms" var.pos=1341 var.line_nr=62
		// var "sw" var.pos=1409 var.line_nr=66
		// af parent scope:
		// af parent scope:
		return ms;
	}
	time__StopWatch sw = (*(time__StopWatch*)map_get(ADDR(map, t->swatches), &(string[]){name}, &(time__StopWatch[]){ {0} }));
	time__StopWatch_pause(&sw);
	(*(time__StopWatch*)map_get_and_set(&t->swatches, &(string[]){name}, &(time__StopWatch[]){ {0} })) = sw;
	// autofree_scope_vars(pos=1467 line_nr=69 scope.pos=1287 scope.end_pos=1478)
	// var "t" var.pos=1292 var.line_nr=61
	// var "name" var.pos=1321 var.line_nr=61
	// var "ms" var.pos=1341 var.line_nr=62
	// var "sw" var.pos=1409 var.line_nr=66
	// af parent scope:
	// af parent scope:
	return ms;
}

void v__util__Timers_measure_pause(v__util__Timers* t, string name) {
	if (!_IN_MAP(ADDR(string, name), ADDR(map, t->swatches))) {
		return;
	}
	time__StopWatch sw = (*(time__StopWatch*)map_get(ADDR(map, t->swatches), &(string[]){name}, &(time__StopWatch[]){ {0} }));
	time__StopWatch_pause(&sw);
	(*(time__StopWatch*)map_get_and_set(&t->swatches, &(string[]){name}, &(time__StopWatch[]){ {0} })) = sw;
}

void v__util__Timers_measure_resume(v__util__Timers* t, string name) {
	if (!_IN_MAP(ADDR(string, name), ADDR(map, t->swatches))) {
		return;
	}
	time__StopWatch sw = (*(time__StopWatch*)map_get(ADDR(map, t->swatches), &(string[]){name}, &(time__StopWatch[]){ {0} }));
	time__StopWatch_start(&sw);
	(*(time__StopWatch*)map_get_and_set(&t->swatches, &(string[]){name}, &(time__StopWatch[]){ {0} })) = sw;
}

string v__util__Timers_message(v__util__Timers* t, string name) {
	f64 ms = ((f64)(v__util__Timers_measure(t, name))) / 1000.0;
	string value = v__util__bold(_STR("%-8.3f", 1, ms));
	string formatted_message = _STR("%.*s\000 ms %.*s", 2, value, name);
	// autofree_scope_vars(pos=1951 line_nr=94 scope.pos=1799 scope.end_pos=1977)
	// var "t" var.pos=1804 var.line_nr=90
	// var "name" var.pos=1822 var.line_nr=90
	// var "ms" var.pos=1845 var.line_nr=91
	// var "value" var.pos=1882 var.line_nr=92
	// var "formatted_message" var.pos=1912 var.line_nr=93
	// af parent scope:
	// af parent scope:
	return formatted_message;
}

void v__util__Timers_show(v__util__Timers* t, string label) {
	string formatted_message = v__util__Timers_message(t, label);
	if (t->should_print) {
		println(formatted_message);
	}
}

void v__util__Timers_show_if_exists(v__util__Timers* t, string label) {
	if (!_IN_MAP(ADDR(string, label), ADDR(map, t->swatches))) {
		return;
	}
	v__util__Timers_show(t, label);
}

void v__util__Timers_dump_all(v__util__Timers* t) {
	// FOR IN map
	Map_string_time__StopWatch _t979 = t->swatches;
	int _t981 = _t979.key_values.len;
	for (int _t980 = 0; _t980 < _t981; ++_t980 ) {
		int _t982 = _t979.key_values.len - _t981;
		_t981 = _t979.key_values.len;
		if (_t982 < 0) {
			_t980 = -1;
			continue;
		}
		if (!DenseArray_has_index(&_t979.key_values, _t980)) {continue;}
		string k = /*key*/ *(string*)DenseArray_key(&_t979.key_values, _t980);
		k = string_clone(k);
		string elapsed = v__util__Timers_message(t, k);
		println(elapsed);
	}
}

string v__util__tabs(int n) {
	 string _t983 = (n < _const_v__util__const_tabs.len ? ((*(string*)/*ee elem_typ */array_get(_const_v__util__const_tabs, n))) : (string_repeat(_SLIT("\t"), n)));
	// autofree_scope_vars(pos=828 line_nr=43 scope.pos=807 scope.end_pos=910)
	// var "n" var.pos=812 var.line_nr=42
	// af parent scope:
	// af parent scope:
	return _t983;
}

string v__util__vhash(void) {
	Array_fixed_byte_50 buf = {0};
	buf[0] = 0;
	{ // Unsafe block
		byte* bp = &buf[0];
		snprintf(((char*)(bp)), 50, "%s", V_COMMIT_HASH);
		 string _t984 = tos_clone(bp);
		// autofree_scope_vars(pos=1130 line_nr=53 scope.pos=1063 scope.end_pos=1153)
		// var "bp" var.pos=1063 var.line_nr=51
		// af parent scope:
		// var "buf" var.pos=1021 var.line_nr=48
		// af parent scope:
		// af parent scope:
		return _t984;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

string v__util__full_hash(void) {
	string build_hash = v__util__vhash();
	string current_hash = v__util__githash(false);
	if (string_eq(build_hash, current_hash)) {
		// autofree_scope_vars(pos=1275 line_nr=61 scope.pos=1272 scope.end_pos=1295)
		// af parent scope:
		// var "build_hash" var.pos=1187 var.line_nr=58
		// var "current_hash" var.pos=1210 var.line_nr=59
		// af parent scope:
		// af parent scope:
		return build_hash;
	}
	 string _t985 = _STR("%.*s\000.%.*s", 2, build_hash, current_hash);
	// autofree_scope_vars(pos=1297 line_nr=63 scope.pos=1165 scope.end_pos=1335)
	// var "build_hash" var.pos=1187 var.line_nr=58
	// var "current_hash" var.pos=1210 var.line_nr=59
	// af parent scope:
	// af parent scope:
	return _t985;
}

string v__util__full_v_version(bool is_verbose) {
	if (is_verbose) {
		 string _t986 = _STR("V %.*s\000 %.*s", 2, _const_v__util__v_version, v__util__full_hash());
		// autofree_scope_vars(pos=1467 line_nr=69 scope.pos=1464 scope.end_pos=1509)
		// af parent scope:
		// var "is_verbose" var.pos=1423 var.line_nr=67
		// var "hash" var.pos=1512 var.line_nr=71
		// af parent scope:
		// af parent scope:
		return _t986;
	}
	string hash = v__util__githash(false);
	 string _t987 = _STR("V %.*s\000 %.*s", 2, _const_v__util__v_version, hash);
	// autofree_scope_vars(pos=1535 line_nr=72 scope.pos=1408 scope.end_pos=1569)
	// var "is_verbose" var.pos=1423 var.line_nr=67
	// var "hash" var.pos=1512 var.line_nr=71
	// af parent scope:
	// af parent scope:
	return _t987;
}

string v__util__githash(bool should_get_from_filesystem) {
	for (;;) {
		if (should_get_from_filesystem) {
			string vexe = os__getenv(_SLIT("VEXE"));
			string vroot = os__dir(vexe);
			string git_head_file = os__join_path(vroot, new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT(".git"), _SLIT("HEAD")})));
			if (!os__exists(git_head_file)) {
				break;
			}
			Option_string _t988 = os__read_file(git_head_file);
			if (_t988.state != 0) { /*or block*/ 
				IError err = _t988.err;
				break;
			}
 			string head_content =  *(string*)_t988.data;
			string current_branch_hash = head_content;
			if (string_starts_with(head_content, _SLIT("ref: "))) {
				string gcbranch_rel_path = string_trim_space(string_replace(head_content, _SLIT("ref: "), _SLIT("")));
				string gcbranch_file = os__join_path(vroot, new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT(".git"), gcbranch_rel_path})));
				if (!os__exists(gcbranch_file)) {
					break;
				}
				Option_string _t989 = os__read_file(gcbranch_file);
				if (_t989.state != 0) { /*or block*/ 
					IError err = _t989.err;
					break;
				}
 				string branch_hash =  *(string*)_t989.data;
				current_branch_hash = branch_hash;
			}
			int desired_hash_length = 7;
			if (current_branch_hash.len > desired_hash_length) {
				 string _t990 = string_substr(current_branch_hash, 0, desired_hash_length);
				// autofree_scope_vars(pos=3236 line_nr=112 scope.pos=3231 scope.end_pos=3291)
				// af parent scope:
				// var "vexe" var.pos=2386 var.line_nr=89
				// var "vroot" var.pos=2415 var.line_nr=90
				// var "git_head_file" var.pos=2456 var.line_nr=92
				// var "head_content" var.pos=2620 var.line_nr=97
				// var "current_branch_hash" var.pos=2684 var.line_nr=98
				// var "desired_hash_length" var.pos=3154 var.line_nr=110
				// af parent scope:
				// af parent scope:
				// var "should_get_from_filesystem" var.pos=2131 var.line_nr=83
				// var "buf" var.pos=3313 var.line_nr=117
				// af parent scope:
				// af parent scope:
				return _t990;
			}
		}
		break;
	}
	Array_fixed_byte_50 buf = {0};
	buf[0] = 0;
	{ // Unsafe block
		byte* bp = &buf[0];
		snprintf(((char*)(bp)), 50, "%s", V_CURRENT_COMMIT_HASH);
		 string _t991 = tos_clone(bp);
		// autofree_scope_vars(pos=3430 line_nr=122 scope.pos=3355 scope.end_pos=3453)
		// var "bp" var.pos=3355 var.line_nr=120
		// af parent scope:
		// var "should_get_from_filesystem" var.pos=2131 var.line_nr=83
		// var "buf" var.pos=3313 var.line_nr=117
		// af parent scope:
		// af parent scope:
		return _t991;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

void v__util__set_vroot_folder(string vroot_path) {
	string vname = (string_eq(os__user_os(), _SLIT("windows")) ? (_SLIT("v.exe")) : (_SLIT("v")));
	os__setenv(_SLIT("VEXE"), os__real_path(os__join_path(vroot_path, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){vname})))), true);
	os__setenv(_SLIT("VCHILD"), _SLIT("true"), true);
}

Option_string v__util__resolve_vroot(string str, string dir) {
	v__vmod__ModFileCacher* mcache = v__vmod__get_cache();
	v__vmod__ModFileAndFolder vmod_file_location = v__vmod__ModFileCacher_get_by_folder(mcache, dir);
	if (vmod_file_location.vmod_file.len == 0) {
		return (Option_string){ .state=2, .err=v_error(_STR("To use @VROOT, you need to have a \"v.mod\" file in %.*s\000, or in one of its parent folders.", 2, dir)) };
	}
	string vmod_path = vmod_file_location.vmod_folder;
	Option_string _t992;
	opt_ok(&(string[]) { string_replace(str, _SLIT("@VROOT"), os__real_path(vmod_path)) }, (Option*)(&_t992), sizeof(string));
	// autofree_scope_vars(pos=4205 line_nr=144 scope.pos=3834 scope.end_pos=4260)
	// var "str" var.pos=3848 var.line_nr=136
	// var "dir" var.pos=3860 var.line_nr=136
	// var "mcache" var.pos=3887 var.line_nr=137
	// var "vmod_file_location" var.pos=3915 var.line_nr=138
	// var "vmod_path" var.pos=4161 var.line_nr=143
	// af parent scope:
	// af parent scope:
	return _t992;
}

Option_string v__util__resolve_env_value(string str, bool check_for_presence) {
	string env_ident = _SLIT("$env('");
	Option_int _t993 = string_index(str, env_ident);
	if (_t993.state != 0) { /*or block*/ 
		IError err = _t993.err;
		return (Option_string){ .state=2, .err=v_error(string_add(_STR("no \"%.*s", 1, env_ident), _STR("...\')\" could be found in \"%.*s\000\".", 2, str))) };
	}
 	int at =  *(int*)_t993.data;
	byte ch = ((byte)(L'.'));
	string env_lit = _SLIT("");
	for (int i = at + env_ident.len; i < str.len && ch != L')'; i++) {
		ch = ((byte)(string_at(str, i)));
		if (byte_is_letter(ch) || byte_is_digit(ch) || ch == L'_') {
			env_lit = /*f*/string_add(env_lit, byte_ascii_str(ch));
		} else {
			if (!(ch == L'\'' || ch == L')')) {
				if (ch == L'$') {
					return (Option_string){ .state=2, .err=v_error(_SLIT("cannot use string interpolation in compile time $env() expression")) };
				}
				return (Option_string){ .state=2, .err=v_error(_STR("invalid environment variable name in \"%.*s\000\", invalid character \"%.*s\000\"", 3, str, byte_ascii_str(ch))) };
			}
		}
	}
	if ((env_lit).len == 0) {
		return (Option_string){ .state=2, .err=v_error(_SLIT("supply an env variable name like HOME, PATH or USER")) };
	}
	string env_value = _SLIT("");
	if (check_for_presence) {
		string* _t995 = (string*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, os__environ()), &(string[]){env_lit}));
		Option_string _t994 = {0};
		if (_t995) {
			*((string*)&_t994.data) = *((string*)_t995);
		} else {
			_t994.state = 2; _t994.err = v_error(_SLIT("array index out of range"));
		}
		;
		if (_t994.state != 0) { /*or block*/ 
			IError err = _t994.err;
			return (Option_string){ .state=2, .err=v_error(_STR("the environment variable \"%.*s\000\" does not exist.", 2, env_lit)) };
		}
		env_value = *(string*)_t994.data;
		if ((env_value).len == 0) {
			return (Option_string){ .state=2, .err=v_error(_STR("the environment variable \"%.*s\000\" is empty.", 2, env_lit)) };
		}
	} else {
		env_value = os__getenv(env_lit);
	}
	string rep = string_replace_once(str, string_add(string_add(string_add(env_ident, env_lit), _SLIT("'")), _SLIT(")")), env_value);
	if (string_contains(rep, env_ident)) {
		 Option_string _t996 = v__util__resolve_env_value(rep, check_for_presence);
		// autofree_scope_vars(pos=5570 line_nr=185 scope.pos=5567 scope.end_pos=5622)
		// af parent scope:
		// var "str" var.pos=4424 var.line_nr=149
		// var "check_for_presence" var.pos=4436 var.line_nr=149
		// var "env_ident" var.pos=4472 var.line_nr=150
		// str literal
		// var "at" var.pos=4496 var.line_nr=151
		// var "ch" var.pos=4607 var.line_nr=154
		// var "env_lit" var.pos=4628 var.line_nr=155
		// str literal
		// var "env_value" var.pos=5175 var.line_nr=172
		// str literal
		// var "rep" var.pos=5471 var.line_nr=183
		// af parent scope:
		// af parent scope:
		return _t996;
	}
	Option_string _t997;
	opt_ok(&(string[]) { rep }, (Option*)(&_t997), sizeof(string));
	// autofree_scope_vars(pos=5624 line_nr=187 scope.pos=4406 scope.end_pos=5636)
	// var "str" var.pos=4424 var.line_nr=149
	// var "check_for_presence" var.pos=4436 var.line_nr=149
	// var "env_ident" var.pos=4472 var.line_nr=150
	// str literal
	// var "at" var.pos=4496 var.line_nr=151
	// var "ch" var.pos=4607 var.line_nr=154
	// var "env_lit" var.pos=4628 var.line_nr=155
	// str literal
	// var "env_value" var.pos=5175 var.line_nr=172
	// str literal
	// var "rep" var.pos=5471 var.line_nr=183
	// af parent scope:
	// af parent scope:
	return _t997;
}

void v__util__launch_tool(bool is_verbose, string tool_name, Array_string args) {
	string vexe = v__pref__vexe_path();
	string vroot = os__dir(vexe);
	v__util__set_vroot_folder(vroot);
	string tool_args = v__util__args_quote_paths(args);
	string tools_folder = os__join_path(vroot, new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT("cmd"), _SLIT("tools")})));
	string tool_basename = os__real_path(os__join_path(tools_folder, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){tool_name}))));
	string tool_exe = _SLIT("");
	string tool_source = _SLIT("");
	if (os__is_dir(tool_basename)) {
		tool_exe = v__util__path_of_executable(os__join_path(tool_basename, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){tool_name}))));
		tool_source = tool_basename;
	} else {
		tool_exe = v__util__path_of_executable(tool_basename);
		tool_source = string_add(tool_basename, _SLIT(".v"));
	}
	if (is_verbose) {
		println(_STR("launch_tool vexe        : %.*s", 1, vroot));
		println(_STR("launch_tool vroot       : %.*s", 1, vroot));
		println(_STR("launch_tool tool_source : %.*s", 1, tool_source));
		println(_STR("launch_tool tool_exe    : %.*s", 1, tool_exe));
		println(_STR("launch_tool tool_args   : %.*s", 1, tool_args));
	}
	string disabling_file = v__util__recompilation__disabling_file(vroot);
	bool is_recompilation_disabled = os__exists(disabling_file);
	bool should_compile = !is_recompilation_disabled && v__util__should_recompile_tool(vexe, tool_source, tool_name, tool_exe);
	if (is_verbose) {
		println(_STR("launch_tool should_compile: %.*s", 1, should_compile ? _SLIT("true") : _SLIT("false")));
	}
	if (should_compile) {
		Array_string emodules = (*(Array_string*)map_get(ADDR(map, _const_v__util__external_module_dependencies_for_tool), &(string[]){tool_name}, &(Array_string[]){ __new_array(0, 1, sizeof(string)) }));
		// FOR IN array
		for (int _t998 = 0; _t998 < emodules.len; ++_t998) {
			string emodule = ((string*)emodules.data)[_t998];
			Option_bool _t999 = v__util__check_module_is_installed(emodule, is_verbose);
			if (_t999.state != 0) { /*or block*/ 
				IError err = _t999.err;
				v_panic(IError_str(err));
			};
		}
		string compilation_command = _STR("\"%.*s\000\" ", 2, vexe);
		if ((string_eq(tool_name, _SLIT("vself")) || string_eq(tool_name, _SLIT("vup")) || string_eq(tool_name, _SLIT("vdoctor")) || string_eq(tool_name, _SLIT("vsymlink")))) {
			compilation_command = /*f*/string_add(compilation_command, _SLIT(" -g "));
		}
		compilation_command = /*f*/string_add(compilation_command, _STR("\"%.*s\000\"", 2, tool_source));
		if (is_verbose) {
			println(_STR("Compiling %.*s\000 with: \"%.*s\000\"", 3, tool_name, compilation_command));
		}
		os__Result tool_compilation = os__execute_or_panic(compilation_command);
		if (tool_compilation.exit_code != 0) {
			eprintln(_STR("cannot compile `%.*s\000`: \n%.*s", 2, tool_source, tool_compilation.output));
			v_exit(1);
		}
	}
	#if defined(_WIN32)
	{
		v_exit(os__system(_STR("\"%.*s\000\" %.*s", 2, tool_exe, tool_args)));
	}
	#else
	{
	}
	#endif
}

bool v__util__should_recompile_tool(string vexe, string tool_source, string tool_name, string tool_exe) {
	if (os__is_dir(tool_source)) {
		Array_string source_files = os__walk_ext(tool_source, _SLIT(".v"));
		string newest_sfile = _SLIT("");
		int newest_sfile_mtime = 0;
		// FOR IN array
		for (int _t1000 = 0; _t1000 < source_files.len; ++_t1000) {
			string sfile = ((string*)source_files.data)[_t1000];
			int mtime = os__file_last_mod_unix(sfile);
			if (mtime > newest_sfile_mtime) {
				newest_sfile_mtime = mtime;
				newest_sfile = sfile;
			}
		}
		bool single_file_recompile = v__util__should_recompile_tool(vexe, newest_sfile, tool_name, tool_exe);
		// autofree_scope_vars(pos=9661 line_nr=280 scope.pos=9179 scope.end_pos=9692)
		// var "source_files" var.pos=9183 var.line_nr=267
		// var "newest_sfile" var.pos=9236 var.line_nr=268
		// str literal
		// var "newest_sfile_mtime" var.pos=9261 var.line_nr=269
		// var "single_file_recompile" var.pos=9458 var.line_nr=277
		// af parent scope:
		// var "vexe" var.pos=9077 var.line_nr=265
		// var "tool_source" var.pos=9090 var.line_nr=265
		// var "tool_name" var.pos=9110 var.line_nr=265
		// var "tool_exe" var.pos=9128 var.line_nr=265
		// var "should_compile" var.pos=9754 var.line_nr=283
		// af parent scope:
		// af parent scope:
		return single_file_recompile;
	}
	bool should_compile = false;
	if (!os__exists(tool_exe)) {
		should_compile = true;
	} else {
		int mtime_vexe = os__file_last_mod_unix(vexe);
		int mtime_tool_exe = os__file_last_mod_unix(tool_exe);
		int mtime_tool_source = os__file_last_mod_unix(tool_source);
		if (mtime_tool_exe <= mtime_vexe) {
			should_compile = true;
			if (string_eq(tool_name, _SLIT("vself")) || string_eq(tool_name, _SLIT("vup"))) {
				should_compile = false;
			}
		}
		if (mtime_tool_exe <= mtime_tool_source) {
			should_compile = true;
		}
		if (mtime_vexe < 1024 && mtime_tool_exe < 1024) {
			should_compile = false;
		}
	}
	// autofree_scope_vars(pos=11294 line_nr=317 scope.pos=9055 scope.end_pos=11317)
	// var "vexe" var.pos=9077 var.line_nr=265
	// var "tool_source" var.pos=9090 var.line_nr=265
	// var "tool_name" var.pos=9110 var.line_nr=265
	// var "tool_exe" var.pos=9128 var.line_nr=265
	// var "should_compile" var.pos=9754 var.line_nr=283
	// af parent scope:
	// af parent scope:
	return should_compile;
}

VV_LOCAL_SYMBOL multi_return_string_string v__util__tool_source2name_and_exe(string tool_source) {
	string sfolder = os__dir(tool_source);
	string tool_name = string_replace(os__base(tool_source), _SLIT(".v"), _SLIT(""));
	string tool_exe = os__join_path(sfolder, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){v__util__path_of_executable(tool_name)})));
	return (multi_return_string_string){.arg0=tool_name, .arg1=tool_exe};
}

string v__util__quote_path(string s) {
	string qs = s;
	if (string_contains(qs, _SLIT("&"))) {
		qs = string_replace(qs, _SLIT("&"), _SLIT("\\&"));
	}
	if (string_contains(qs, _SLIT(" "))) {
		 string _t1001 = _STR("\"%.*s\000\"", 2, qs);
		// autofree_scope_vars(pos=11699 line_nr=333 scope.pos=11696 scope.end_pos=11716)
		// af parent scope:
		// var "s" var.pos=11587 var.line_nr=327
		// var "qs" var.pos=11611 var.line_nr=328
		// af parent scope:
		// af parent scope:
		return _t1001;
	}
	// autofree_scope_vars(pos=11718 line_nr=335 scope.pos=11576 scope.end_pos=11729)
	// var "s" var.pos=11587 var.line_nr=327
	// var "qs" var.pos=11611 var.line_nr=328
	// af parent scope:
	// af parent scope:
	return qs;
}

string v__util__args_quote_paths(Array_string args) {
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	// FOR IN array
	for (int _t1002 = 0; _t1002 < args.len; ++_t1002) {
		string a = ((string*)args.data)[_t1002];
		array_push(&res, _MOV((string[]){ string_clone(v__util__quote_path(a)) }));
	}
	 string _t1004 = Array_string_join(res, _SLIT(" "));
	// autofree_scope_vars(pos=11846 line_nr=343 scope.pos=11739 scope.end_pos=11868)
	// var "args" var.pos=11756 var.line_nr=338
	// var "res" var.pos=11785 var.line_nr=339
	// af parent scope:
	// af parent scope:
	return _t1004;
}

string v__util__path_of_executable(string path) {
	 string _t1005 = string_add(path, _SLIT(".exe"));
	// autofree_scope_vars(pos=11935 line_nr=348 scope.pos=11932 scope.end_pos=11958)
	// af parent scope:
	// var "path" var.pos=11897 var.line_nr=346
	// af parent scope:
	// af parent scope:
	return _t1005;
	// autofree_scope_vars(pos=11960 line_nr=350 scope.pos=11878 scope.end_pos=11973)
	// var "path" var.pos=11897 var.line_nr=346
	// af parent scope:
	// af parent scope:
	return path;
}

Option_string v__util__read_file(string file_path) {
	Option_string _t1006 = os__read_file(file_path);
	if (_t1006.state != 0) { /*or block*/ 
		IError err = _t1006.err;
		return (Option_string){ .state=2, .err=v_error(_STR("failed to open %.*s", 1, file_path)) };
	}
 	string raw_text =  *(string*)_t1006.data;
	Option_string _t1007;
	opt_ok(&(string[]) { v__util__skip_bom(raw_text) }, (Option*)(&_t1007), sizeof(string));
	// autofree_scope_vars(pos=12107 line_nr=355 scope.pos=11983 scope.end_pos=12134)
	// var "file_path" var.pos=11993 var.line_nr=353
	// var "raw_text" var.pos=12022 var.line_nr=354
	// af parent scope:
	// af parent scope:
	return _t1007;
}

string v__util__skip_bom(string file_content) {
	string raw_text = file_content;
	if (raw_text.len >= 3) {
		{ // Unsafe block
			byte* c_text = raw_text.str;
			if (c_text[0] == 0xEF && c_text[1] == 0xBB && c_text[2] == 0xBF) {
				int offset_from_begin = 3;
				raw_text = tos((voidptr)&/*qq*/c_text[offset_from_begin], vstrlen(c_text) - offset_from_begin);
			}
		}
	}
	// autofree_scope_vars(pos=12506 line_nr=371 scope.pos=12144 scope.end_pos=12523)
	// var "file_content" var.pos=12153 var.line_nr=358
	// var "raw_text" var.pos=12188 var.line_nr=359
	// af parent scope:
	// af parent scope:
	return raw_text;
}

string v__util__replace_op(string s) {
	if (s.len == 1) {
		byte last_char = string_at(s, s.len - 1);
		string suffix = ((last_char == (L'+')) ? (_SLIT("_plus")) : (last_char == (L'-')) ? (_SLIT("_minus")) : (last_char == (L'*')) ? (_SLIT("_mult")) : (last_char == (L'/')) ? (_SLIT("_div")) : (last_char == (L'%')) ? (_SLIT("_mod")) : (last_char == (L'<')) ? (_SLIT("_lt")) : (last_char == (L'>')) ? (_SLIT("_gt")) : (_SLIT("")));
		 string _t1008 = string_add(string_substr(s, 0, s.len - 1), suffix);
		// autofree_scope_vars(pos=12786 line_nr=387 scope.pos=12578 scope.end_pos=12819)
		// var "last_char" var.pos=12582 var.line_nr=376
		// var "suffix" var.pos=12610 var.line_nr=377
		// af parent scope:
		// var "s" var.pos=12544 var.line_nr=374
		// af parent scope:
		// af parent scope:
		return _t1008;
	} else {
		string suffix = ((string_eq(s, _SLIT("=="))) ? (_SLIT("_eq")) : (_SLIT("")));
		 string _t1009 = string_add(string_substr(s, 0, s.len - 2), suffix);
		// autofree_scope_vars(pos=12888 line_nr=393 scope.pos=12826 scope.end_pos=12921)
		// var "suffix" var.pos=12830 var.line_nr=389
		// af parent scope:
		// var "s" var.pos=12544 var.line_nr=374
		// af parent scope:
		// af parent scope:
		return _t1009;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

Array_string v__util__join_env_vflags_and_os_args(void) {
	string vosargs = os__getenv(_SLIT("VOSARGS"));
	if ((vosargs).len != 0) {
		 Array_string _t1010 = v__util__non_empty(string_split(vosargs, _SLIT(" ")));
		// autofree_scope_vars(pos=13028 line_nr=400 scope.pos=13025 scope.end_pos=13067)
		// af parent scope:
		// var "vosargs" var.pos=12975 var.line_nr=398
		// var "args" var.pos=13074 var.line_nr=402
		// var "vflags" var.pos=13094 var.line_nr=403
		// af parent scope:
		// af parent scope:
		return _t1010;
	}
	Array_string args = __new_array_with_default(0, 0, sizeof(string), 0);
	string vflags = os__getenv(_SLIT("VFLAGS"));
	if ((vflags).len != 0) {
		array_push(&args, _MOV((string[]){ string_clone((*(string*)/*ee elem_typ */array_get(_const_os__args, 0))) }));
		_PUSH_MANY(&args, (string_split(vflags, _SLIT(" "))), _t1012, Array_string);
		if (_const_os__args.len > 1) {
			_PUSH_MANY(&args, (array_slice(_const_os__args, 1, _const_os__args.len)), _t1013, Array_string);
		}
		 Array_string _t1014 = v__util__non_empty(args);
		// autofree_scope_vars(pos=13244 line_nr=410 scope.pos=13141 scope.end_pos=13269)
		// af parent scope:
		// var "vosargs" var.pos=12975 var.line_nr=398
		// var "args" var.pos=13074 var.line_nr=402
		// var "vflags" var.pos=13094 var.line_nr=403
		// af parent scope:
		// af parent scope:
		return _t1014;
	}
	// autofree_scope_vars(pos=13271 line_nr=412 scope.pos=12933 scope.end_pos=13287)
	// var "vosargs" var.pos=12975 var.line_nr=398
	// var "args" var.pos=13074 var.line_nr=402
	// var "vflags" var.pos=13094 var.line_nr=403
	// af parent scope:
	// af parent scope:
	return _const_os__args;
}

VV_LOCAL_SYMBOL Array_string v__util__non_empty(Array_string arg) {
	Array_string _t1016_orig = arg;
	int _t1016_len = _t1016_orig.len;
	Array_string _t1016 = __new_array(0, _t1016_len, sizeof(string));

	for (int _t1017 = 0; _t1017 < _t1016_len; ++_t1017) {
		string it = ((string*) _t1016_orig.data)[_t1017];
		if ((it).len != 0) {
			array_push(&_t1016, &it); 
		}
	}
	
	 Array_string _t1015 = _t1016;
	// autofree_scope_vars(pos=13328 line_nr=416 scope.pos=13293 scope.end_pos=13357)
	// var "arg" var.pos=13303 var.line_nr=415
	// af parent scope:
	// af parent scope:
	return _t1015;
}

Option_bool v__util__check_module_is_installed(string modulename, bool is_verbose) {
	string mpath = os__join_path(os__vmodules_dir(), new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){modulename})));
	string mod_v_file = os__join_path(mpath, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("v.mod")})));
	string murl = _STR("https://github.com/vlang/%.*s", 1, modulename);
	if (is_verbose) {
		eprintln(_STR("check_module_is_installed: mpath: %.*s", 1, mpath));
		eprintln(_STR("check_module_is_installed: mod_v_file: %.*s", 1, mod_v_file));
		eprintln(_STR("check_module_is_installed: murl: %.*s", 1, murl));
	}
	if (os__exists(mod_v_file)) {
		string vexe = v__pref__vexe_path();
		string update_cmd = _STR("\"%.*s\000\" update \"%.*s\000\"", 3, vexe, modulename);
		if (is_verbose) {
			eprintln(_STR("check_module_is_installed: updating with %.*s\000 ...", 2, update_cmd));
		}
		os__Result update_res = os__execute(update_cmd);
		if (update_res.exit_code < 0) {
			return (Option_bool){ .state=2, .err=v_error(_STR("can not start %.*s\000, error: %.*s", 2, update_cmd, update_res.output)) };
		}
		if (update_res.exit_code != 0) {
			eprintln(_STR("Warning: `%.*s\000` exists, but is not updated.\nV will continue, since updates can fail due to temporary network problems,\nand the existing module `%.*s\000` may still work.", 3, modulename, modulename));
			if (is_verbose) {
				eprintln(_SLIT("Details:"));
				eprintln(update_res.output);
			}
			eprintln(string_repeat(_SLIT("-"), 50));
		}
		Option_bool _t1018;
		opt_ok(&(bool[]) { true }, (Option*)(&_t1018), sizeof(bool));
		// autofree_scope_vars(pos=14461 line_nr=448 scope.pos=13802 scope.end_pos=14475)
		// var "vexe" var.pos=13806 var.line_nr=429
		// var "update_cmd" var.pos=13833 var.line_nr=430
		// var "update_res" var.pos=13974 var.line_nr=434
		// af parent scope:
		// var "modulename" var.pos=13393 var.line_nr=419
		// var "is_verbose" var.pos=13412 var.line_nr=419
		// var "mpath" var.pos=13438 var.line_nr=420
		// var "mod_v_file" var.pos=13492 var.line_nr=421
		// var "murl" var.pos=13536 var.line_nr=422
		// var "cloning_res" var.pos=14562 var.line_nr=453
		// af parent scope:
		// af parent scope:
		return _t1018;
	}
	if (is_verbose) {
		eprintln(_STR("check_module_is_installed: cloning from %.*s\000 ...", 2, murl));
	}
	os__Result cloning_res = os__execute(_STR("git clone %.*s\000 %.*s", 2, murl, mpath));
	if (cloning_res.exit_code < 0) {
		return (Option_bool){ .state=2, .err=error_with_code(_STR("git is not installed, error: %.*s", 1, cloning_res.output), cloning_res.exit_code) };
	}
	if (cloning_res.exit_code != 0) {
		return (Option_bool){ .state=2, .err=error_with_code(_STR("cloning failed, details: %.*s", 1, cloning_res.output), cloning_res.exit_code) };
	}
	if (!os__exists(mod_v_file)) {
		return (Option_bool){ .state=2, .err=v_error(_STR("even after cloning, %.*s\000 is still missing", 2, mod_v_file)) };
	}
	if (is_verbose) {
		eprintln(_SLIT("check_module_is_installed: done"));
	}
	Option_bool _t1019;
	opt_ok(&(bool[]) { true }, (Option*)(&_t1019), sizeof(bool));
	// autofree_scope_vars(pos=15046 line_nr=466 scope.pos=13367 scope.end_pos=15059)
	// var "modulename" var.pos=13393 var.line_nr=419
	// var "is_verbose" var.pos=13412 var.line_nr=419
	// var "mpath" var.pos=13438 var.line_nr=420
	// var "mod_v_file" var.pos=13492 var.line_nr=421
	// var "murl" var.pos=13536 var.line_nr=422
	// var "cloning_res" var.pos=14562 var.line_nr=453
	// af parent scope:
	// af parent scope:
	return _t1019;
}

void v__util__ensure_modules_for_all_tools_are_installed(bool is_verbose) {
	// FOR IN map
	int _t1021 = _const_v__util__external_module_dependencies_for_tool.key_values.len;
	for (int _t1020 = 0; _t1020 < _t1021; ++_t1020 ) {
		int _t1022 = _const_v__util__external_module_dependencies_for_tool.key_values.len - _t1021;
		_t1021 = _const_v__util__external_module_dependencies_for_tool.key_values.len;
		if (_t1022 < 0) {
			_t1020 = -1;
			continue;
		}
		if (!DenseArray_has_index(&_const_v__util__external_module_dependencies_for_tool.key_values, _t1020)) {continue;}
		string tool_name = /*key*/ *(string*)DenseArray_key(&_const_v__util__external_module_dependencies_for_tool.key_values, _t1020);
		tool_name = string_clone(tool_name);
		Array_string tool_modules = (*(Array_string*)DenseArray_value(&_const_v__util__external_module_dependencies_for_tool.key_values, _t1020));
		if (is_verbose) {
			eprintln(_STR("Installing modules for tool: %.*s\000 ...", 2, tool_name));
		}
		// FOR IN array
		for (int _t1023 = 0; _t1023 < tool_modules.len; ++_t1023) {
			string emodule = ((string*)tool_modules.data)[_t1023];
			Option_bool _t1024 = v__util__check_module_is_installed(emodule, is_verbose);
			if (_t1024.state != 0) { /*or block*/ 
				IError err = _t1024.err;
				v_panic(IError_str(err));
			};
		}
	}
}

string v__util__strip_mod_name(string name) {
	 string _t1025 = string_all_after_last(name, _SLIT("."));
	// autofree_scope_vars(pos=15443 line_nr=481 scope.pos=15406 scope.end_pos=15476)
	// var "name" var.pos=15421 var.line_nr=480
	// af parent scope:
	// af parent scope:
	return _t1025;
}

string v__util__strip_main_name(string name) {
	 string _t1026 = string_replace(name, _SLIT("main."), _SLIT(""));
	// autofree_scope_vars(pos=15524 line_nr=485 scope.pos=15486 scope.end_pos=15558)
	// var "name" var.pos=15502 var.line_nr=484
	// af parent scope:
	// af parent scope:
	return _t1026;
}

string v__util__no_dots(string s) {
	 string _t1027 = string_replace(s, _SLIT("."), _SLIT("__"));
	// autofree_scope_vars(pos=15595 line_nr=489 scope.pos=15568 scope.end_pos=15624)
	// var "s" var.pos=15576 var.line_nr=488
	// af parent scope:
	// af parent scope:
	return _t1027;
}

string v__util__no_cur_mod(string v_typename, string cur_mod) {
	string res = v_typename;
	string mod_prefix = string_add(cur_mod, _SLIT("."));
	bool has_map_prefix = string_starts_with(res, _const_v__util__map_prefix);
	if (has_map_prefix) {
		res = string_replace_once(res, _const_v__util__map_prefix, _SLIT(""));
	}
	string no_symbols = string_trim_left(res, _SLIT("&[]"));
	bool should_shorten = string_starts_with(no_symbols, mod_prefix);
	if (should_shorten) {
		res = string_replace_once(res, mod_prefix, _SLIT(""));
	}
	if (has_map_prefix) {
		res = string_add(_const_v__util__map_prefix, res);
	}
	// autofree_scope_vars(pos=16305 line_nr=515 scope.pos=15871 scope.end_pos=16317)
	// var "typename" var.pos=15882 var.line_nr=500
	// var "cur_mod" var.pos=15899 var.line_nr=500
	// var "res" var.pos=15929 var.line_nr=501
	// var "mod_prefix" var.pos=15946 var.line_nr=502
	// var "has_map_prefix" var.pos=15975 var.line_nr=503
	// var "no_symbols" var.pos=16097 var.line_nr=507
	// var "should_shorten" var.pos=16133 var.line_nr=508
	// af parent scope:
	// af parent scope:
	return res;
}

void v__util__prepare_tool_when_needed(string source_name) {
	string vexe = os__getenv(_SLIT("VEXE"));
	string vroot = os__dir(vexe);
	string stool = os__join_path(vroot, new_array_from_c_array(3, 3, sizeof(string), _MOV((string[3]){_SLIT("cmd"), _SLIT("tools"), source_name})));
	multi_return_string_string mr_16504 = v__util__tool_source2name_and_exe(stool);
	string tool_name = mr_16504.arg0;
	string tool_exe = mr_16504.arg1;
	if (v__util__should_recompile_tool(vexe, stool, tool_name, tool_exe)) {
		time__sleep(1001 * _const_time__millisecond);
		v__util__recompile_file(vexe, stool);
	}
}

void v__util__recompile_file(string vexe, string file) {
	string cmd = _STR("%.*s\000 %.*s", 2, vexe, file);
	int recompile_result = os__system(cmd);
	if (recompile_result != 0) {
		eprintln(_STR("could not recompile %.*s", 1, file));
		v_exit(2);
	}
}

string v__util__get_vtmp_folder(void) {
	string vtmp = os__getenv(_SLIT("VTMP"));
	if (vtmp.len > 0) {
		// autofree_scope_vars(pos=17093 line_nr=544 scope.pos=17090 scope.end_pos=17107)
		// af parent scope:
		// var "vtmp" var.pos=17047 var.line_nr=542
		// af parent scope:
		// af parent scope:
		return vtmp;
	}
	vtmp = os__join_path(os__temp_dir(), new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("v")})));
	if (!os__exists(vtmp) || !os__is_dir(vtmp)) {
		Option_void _t1028 = os__mkdir_all(vtmp);
		if (_t1028.state != 0 && _t1028.err._typ != _IError_None___index) {
			IError err = _t1028.err;
			v_panic(IError_str(err));
		};
	}
	os__setenv(_SLIT("VTMP"), vtmp, true);
	// autofree_scope_vars(pos=17266 line_nr=551 scope.pos=17015 scope.end_pos=17279)
	// var "vtmp" var.pos=17047 var.line_nr=542
	// af parent scope:
	// af parent scope:
	return vtmp;
}

bool v__util__should_bundle_module(string mod) {
	 bool _t1029 = (Array_string_contains(_const_v__util__bundle_modules, mod)) || (string_contains(mod, _SLIT(".")) && (Array_string_contains(_const_v__util__bundle_modules, string_all_before(mod, _SLIT(".")))));
	// autofree_scope_vars(pos=17329 line_nr=555 scope.pos=17289 scope.end_pos=17435)
	// var "mod" var.pos=17310 var.line_nr=554
	// af parent scope:
	// af parent scope:
	return _t1029;
}

Option_Array_string v__util__find_all_v_files(Array_string roots) {
	Array_string files = __new_array_with_default(0, 0, sizeof(string), 0);
	// FOR IN array
	for (int _t1030 = 0; _t1030 < roots.len; ++_t1030) {
		string file = ((string*)roots.data)[_t1030];
		if (os__is_dir(file)) {
			_PUSH_MANY(&files, (os__walk_ext(file, _SLIT(".v"))), _t1031, Array_string);
			_PUSH_MANY(&files, (os__walk_ext(file, _SLIT(".vsh"))), _t1032, Array_string);
			continue;
		}
		if (!string_ends_with(file, _SLIT(".v")) && !string_ends_with(file, _SLIT(".vv")) && !string_ends_with(file, _SLIT(".vsh"))) {
			return (Option_Array_string){ .state=2, .err=v_error(_STR("v fmt can only be used on .v files.\nOffending file: \"%.*s\000\"", 2, file)) };
		}
		if (!os__exists(file)) {
			return (Option_Array_string){ .state=2, .err=v_error(_STR("\"%.*s\000\" does not exist", 2, file)) };
		}
		array_push(&files, _MOV((string[]){ string_clone(file) }));
	}
	Option_Array_string _t1034;
	opt_ok(&(Array_string[]) { files }, (Option*)(&_t1034), sizeof(Array_string));
	// autofree_scope_vars(pos=18106 line_nr=578 scope.pos=17647 scope.end_pos=18120)
	// var "roots" var.pos=17664 var.line_nr=562
	// var "files" var.pos=17697 var.line_nr=563
	// af parent scope:
	// af parent scope:
	return _t1034;
}

// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
v__ast__Expr v__ast__empty_expr(void) {
	 v__ast__Expr _t1035 = v__ast__EmptyExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__EmptyExpr, ((v__ast__EmptyExpr){.x = 0,})));
	// autofree_scope_vars(pos=1786 line_nr=44 scope.pos=1766 scope.end_pos=1806)
	// af parent scope:
	// af parent scope:
	return _t1035;
}

v__ast__Stmt v__ast__empty_stmt(void) {
	 v__ast__Stmt _t1036 = v__ast__EmptyStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__EmptyStmt, ((v__ast__EmptyStmt){.pos = {0},})));
	// autofree_scope_vars(pos=1887 line_nr=53 scope.pos=1867 scope.end_pos=1907)
	// af parent scope:
	// af parent scope:
	return _t1036;
}

v__ast__Node v__ast__empty_node(void) {
	 v__ast__Node _t1037 = v__ast__EmptyNode_to_sumtype_v__ast__Node(ADDR(v__ast__EmptyNode, ((v__ast__EmptyNode){.x = 0,})));
	// autofree_scope_vars(pos=1970 line_nr=61 scope.pos=1950 scope.end_pos=1990)
	// af parent scope:
	// af parent scope:
	return _t1037;
}

Option_v__ast__Ident v__ast__SelectorExpr_root_ident(v__ast__SelectorExpr* e) {
	v__ast__Expr root = e->expr;
	for (;;) {
		if (!((root)._typ == 273 /* v.ast.SelectorExpr */)) break;
		v__ast__SelectorExpr selector_expr = /* as */ *(v__ast__SelectorExpr*)__as_cast((root)._v__ast__SelectorExpr,(root)._typ, 273) /*expected idx: 273, name: v.ast.SelectorExpr */ ;
		root = selector_expr.expr;
	}
	if ((root)._typ == 254 /* v.ast.Ident */) {
		Option_v__ast__Ident _t1038;
		opt_ok(&(v__ast__Ident[]) { /* as */ *(v__ast__Ident*)__as_cast((root)._v__ast__Ident,(root)._typ, 254) /*expected idx: 254, name: v.ast.Ident */  }, (Option*)(&_t1038), sizeof(v__ast__Ident));
		// autofree_scope_vars(pos=3910 line_nr=159 scope.pos=3907 scope.end_pos=3933)
		// af parent scope:
		// var "e" var.pos=3703 var.line_nr=151
		// var "root" var.pos=3747 var.line_nr=152
		// af parent scope:
		// af parent scope:
		return _t1038;
	}
	return (Option_v__ast__Ident){ .state=2, .err=_const_none__ };
}

// TypeDecl
v__ast__IdentVar v__ast__Ident_var_info(v__ast__Ident* i) {
	if (i->info._typ == 363 /* v.ast.IdentVar */) {
		 v__ast__IdentVar _t1039 = (*i->info._v__ast__IdentVar);
		// autofree_scope_vars(pos=15235 line_nr=611 scope.pos=15222 scope.end_pos=15252)
		// af parent scope:
		// var "i" var.pos=15168 var.line_nr=608
		// af parent scope:
		// af parent scope:
		return _t1039;
	}
	else {
		v_panic(_SLIT("Ident.var_info(): info is not IdentVar variant"));
	};
	return (v__ast__IdentVar){0};
}

// TypeDecl
// Attr: [inline]
inline bool v__ast__Expr_is_blank_ident(v__ast__Expr expr) {
	if (expr._typ == 254 /* v.ast.Ident */) {
		 bool _t1040 = (*expr._v__ast__Ident).kind == v__ast__IdentKind_blank_ident;
		// autofree_scope_vars(pos=32096 line_nr=1465 scope.pos=32089 scope.end_pos=32130)
		// var "expr" var.pos=32080 var.line_nr=1464
		// af parent scope:
		// var "expr" var.pos=32038 var.line_nr=1463
		// af parent scope:
		// af parent scope:
		return _t1040;
	}
	else {
		 bool _t1041 = false;
		// autofree_scope_vars(pos=32140 line_nr=1466 scope.pos=32134 scope.end_pos=32154)
		// af parent scope:
		// var "expr" var.pos=32038 var.line_nr=1463
		// af parent scope:
		// af parent scope:
		return _t1041;
	};
	return 0;
}

v__token__Position v__ast__Expr_position(v__ast__Expr expr) {
	if (expr._typ == 233 /* v.ast.AnonFn */) {
		 v__token__Position _t1042 = (*expr._v__ast__AnonFn).decl.pos;
		// autofree_scope_vars(pos=32393 line_nr=1476 scope.pos=32382 scope.end_pos=32417)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1042;
	}
	else if (expr._typ == 250 /* v.ast.EmptyExpr */) {
		 v__token__Position _t1043 = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,};
		// autofree_scope_vars(pos=32497 line_nr=1480 scope.pos=32421 scope.end_pos=32524)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1043;
	}
	else if (expr._typ == 264 /* v.ast.NodeError */) {
		 v__token__Position _t1044 = (*expr._v__ast__NodeError).pos;
		// autofree_scope_vars(pos=33010 line_nr=1488 scope.pos=32528 scope.end_pos=33029)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1044;
	}
	else if (expr._typ == 234 /* v.ast.ArrayDecompose */) {
		 v__token__Position _t1045 = (*expr._v__ast__ArrayDecompose).pos;
		// autofree_scope_vars(pos=33010 line_nr=1488 scope.pos=32528 scope.end_pos=33029)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1045;
	}
	else if (expr._typ == 235 /* v.ast.ArrayInit */) {
		 v__token__Position _t1046 = (*expr._v__ast__ArrayInit).pos;
		// autofree_scope_vars(pos=33010 line_nr=1488 scope.pos=32528 scope.end_pos=33029)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1046;
	}
	else if (expr._typ == 236 /* v.ast.AsCast */) {
		 v__token__Position _t1047 = (*expr._v__ast__AsCast).pos;
		// autofree_scope_vars(pos=33010 line_nr=1488 scope.pos=32528 scope.end_pos=33029)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1047;
	}
	else if (expr._typ == 237 /* v.ast.Assoc */) {
		 v__token__Position _t1048 = (*expr._v__ast__Assoc).pos;
		// autofree_scope_vars(pos=33010 line_nr=1488 scope.pos=32528 scope.end_pos=33029)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1048;
	}
	else if (expr._typ == 238 /* v.ast.AtExpr */) {
		 v__token__Position _t1049 = (*expr._v__ast__AtExpr).pos;
		// autofree_scope_vars(pos=33010 line_nr=1488 scope.pos=32528 scope.end_pos=33029)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1049;
	}
	else if (expr._typ == 239 /* v.ast.BoolLiteral */) {
		 v__token__Position _t1050 = (*expr._v__ast__BoolLiteral).pos;
		// autofree_scope_vars(pos=33010 line_nr=1488 scope.pos=32528 scope.end_pos=33029)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1050;
	}
	else if (expr._typ == 241 /* v.ast.CallExpr */) {
		 v__token__Position _t1051 = (*expr._v__ast__CallExpr).pos;
		// autofree_scope_vars(pos=33010 line_nr=1488 scope.pos=32528 scope.end_pos=33029)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1051;
	}
	else if (expr._typ == 242 /* v.ast.CastExpr */) {
		 v__token__Position _t1052 = (*expr._v__ast__CastExpr).pos;
		// autofree_scope_vars(pos=33010 line_nr=1488 scope.pos=32528 scope.end_pos=33029)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1052;
	}
	else if (expr._typ == 243 /* v.ast.ChanInit */) {
		 v__token__Position _t1053 = (*expr._v__ast__ChanInit).pos;
		// autofree_scope_vars(pos=33010 line_nr=1488 scope.pos=32528 scope.end_pos=33029)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1053;
	}
	else if (expr._typ == 244 /* v.ast.CharLiteral */) {
		 v__token__Position _t1054 = (*expr._v__ast__CharLiteral).pos;
		// autofree_scope_vars(pos=33010 line_nr=1488 scope.pos=32528 scope.end_pos=33029)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1054;
	}
	else if (expr._typ == 248 /* v.ast.ConcatExpr */) {
		 v__token__Position _t1055 = (*expr._v__ast__ConcatExpr).pos;
		// autofree_scope_vars(pos=33010 line_nr=1488 scope.pos=32528 scope.end_pos=33029)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1055;
	}
	else if (expr._typ == 245 /* v.ast.Comment */) {
		 v__token__Position _t1056 = (*expr._v__ast__Comment).pos;
		// autofree_scope_vars(pos=33010 line_nr=1488 scope.pos=32528 scope.end_pos=33029)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1056;
	}
	else if (expr._typ == 246 /* v.ast.ComptimeCall */) {
		 v__token__Position _t1057 = (*expr._v__ast__ComptimeCall).pos;
		// autofree_scope_vars(pos=33010 line_nr=1488 scope.pos=32528 scope.end_pos=33029)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1057;
	}
	else if (expr._typ == 247 /* v.ast.ComptimeSelector */) {
		 v__token__Position _t1058 = (*expr._v__ast__ComptimeSelector).pos;
		// autofree_scope_vars(pos=33010 line_nr=1488 scope.pos=32528 scope.end_pos=33029)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1058;
	}
	else if (expr._typ == 251 /* v.ast.EnumVal */) {
		 v__token__Position _t1059 = (*expr._v__ast__EnumVal).pos;
		// autofree_scope_vars(pos=33010 line_nr=1488 scope.pos=32528 scope.end_pos=33029)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1059;
	}
	else if (expr._typ == 249 /* v.ast.DumpExpr */) {
		 v__token__Position _t1060 = (*expr._v__ast__DumpExpr).pos;
		// autofree_scope_vars(pos=33010 line_nr=1488 scope.pos=32528 scope.end_pos=33029)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1060;
	}
	else if (expr._typ == 252 /* v.ast.FloatLiteral */) {
		 v__token__Position _t1061 = (*expr._v__ast__FloatLiteral).pos;
		// autofree_scope_vars(pos=33010 line_nr=1488 scope.pos=32528 scope.end_pos=33029)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1061;
	}
	else if (expr._typ == 253 /* v.ast.GoExpr */) {
		 v__token__Position _t1062 = (*expr._v__ast__GoExpr).pos;
		// autofree_scope_vars(pos=33010 line_nr=1488 scope.pos=32528 scope.end_pos=33029)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1062;
	}
	else if (expr._typ == 254 /* v.ast.Ident */) {
		 v__token__Position _t1063 = (*expr._v__ast__Ident).pos;
		// autofree_scope_vars(pos=33010 line_nr=1488 scope.pos=32528 scope.end_pos=33029)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1063;
	}
	else if (expr._typ == 255 /* v.ast.IfExpr */) {
		 v__token__Position _t1064 = (*expr._v__ast__IfExpr).pos;
		// autofree_scope_vars(pos=33010 line_nr=1488 scope.pos=32528 scope.end_pos=33029)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1064;
	}
	else if (expr._typ == 259 /* v.ast.IntegerLiteral */) {
		 v__token__Position _t1065 = (*expr._v__ast__IntegerLiteral).pos;
		// autofree_scope_vars(pos=33010 line_nr=1488 scope.pos=32528 scope.end_pos=33029)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1065;
	}
	else if (expr._typ == 260 /* v.ast.Likely */) {
		 v__token__Position _t1066 = (*expr._v__ast__Likely).pos;
		// autofree_scope_vars(pos=33010 line_nr=1488 scope.pos=32528 scope.end_pos=33029)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1066;
	}
	else if (expr._typ == 261 /* v.ast.LockExpr */) {
		 v__token__Position _t1067 = (*expr._v__ast__LockExpr).pos;
		// autofree_scope_vars(pos=33010 line_nr=1488 scope.pos=32528 scope.end_pos=33029)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1067;
	}
	else if (expr._typ == 262 /* v.ast.MapInit */) {
		 v__token__Position _t1068 = (*expr._v__ast__MapInit).pos;
		// autofree_scope_vars(pos=33010 line_nr=1488 scope.pos=32528 scope.end_pos=33029)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1068;
	}
	else if (expr._typ == 263 /* v.ast.MatchExpr */) {
		 v__token__Position _t1069 = (*expr._v__ast__MatchExpr).pos;
		// autofree_scope_vars(pos=33010 line_nr=1488 scope.pos=32528 scope.end_pos=33029)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1069;
	}
	else if (expr._typ == 265 /* v.ast.None */) {
		 v__token__Position _t1070 = (*expr._v__ast__None).pos;
		// autofree_scope_vars(pos=33010 line_nr=1488 scope.pos=32528 scope.end_pos=33029)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1070;
	}
	else if (expr._typ == 266 /* v.ast.OffsetOf */) {
		 v__token__Position _t1071 = (*expr._v__ast__OffsetOf).pos;
		// autofree_scope_vars(pos=33010 line_nr=1488 scope.pos=32528 scope.end_pos=33029)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1071;
	}
	else if (expr._typ == 267 /* v.ast.OrExpr */) {
		 v__token__Position _t1072 = (*expr._v__ast__OrExpr).pos;
		// autofree_scope_vars(pos=33010 line_nr=1488 scope.pos=32528 scope.end_pos=33029)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1072;
	}
	else if (expr._typ == 268 /* v.ast.ParExpr */) {
		 v__token__Position _t1073 = (*expr._v__ast__ParExpr).pos;
		// autofree_scope_vars(pos=33010 line_nr=1488 scope.pos=32528 scope.end_pos=33029)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1073;
	}
	else if (expr._typ == 269 /* v.ast.PostfixExpr */) {
		 v__token__Position _t1074 = (*expr._v__ast__PostfixExpr).pos;
		// autofree_scope_vars(pos=33010 line_nr=1488 scope.pos=32528 scope.end_pos=33029)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1074;
	}
	else if (expr._typ == 270 /* v.ast.PrefixExpr */) {
		 v__token__Position _t1075 = (*expr._v__ast__PrefixExpr).pos;
		// autofree_scope_vars(pos=33010 line_nr=1488 scope.pos=32528 scope.end_pos=33029)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1075;
	}
	else if (expr._typ == 271 /* v.ast.RangeExpr */) {
		 v__token__Position _t1076 = (*expr._v__ast__RangeExpr).pos;
		// autofree_scope_vars(pos=33010 line_nr=1488 scope.pos=32528 scope.end_pos=33029)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1076;
	}
	else if (expr._typ == 272 /* v.ast.SelectExpr */) {
		 v__token__Position _t1077 = (*expr._v__ast__SelectExpr).pos;
		// autofree_scope_vars(pos=33010 line_nr=1488 scope.pos=32528 scope.end_pos=33029)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1077;
	}
	else if (expr._typ == 273 /* v.ast.SelectorExpr */) {
		 v__token__Position _t1078 = (*expr._v__ast__SelectorExpr).pos;
		// autofree_scope_vars(pos=33010 line_nr=1488 scope.pos=32528 scope.end_pos=33029)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1078;
	}
	else if (expr._typ == 274 /* v.ast.SizeOf */) {
		 v__token__Position _t1079 = (*expr._v__ast__SizeOf).pos;
		// autofree_scope_vars(pos=33010 line_nr=1488 scope.pos=32528 scope.end_pos=33029)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1079;
	}
	else if (expr._typ == 275 /* v.ast.SqlExpr */) {
		 v__token__Position _t1080 = (*expr._v__ast__SqlExpr).pos;
		// autofree_scope_vars(pos=33010 line_nr=1488 scope.pos=32528 scope.end_pos=33029)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1080;
	}
	else if (expr._typ == 276 /* v.ast.StringInterLiteral */) {
		 v__token__Position _t1081 = (*expr._v__ast__StringInterLiteral).pos;
		// autofree_scope_vars(pos=33010 line_nr=1488 scope.pos=32528 scope.end_pos=33029)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1081;
	}
	else if (expr._typ == 277 /* v.ast.StringLiteral */) {
		 v__token__Position _t1082 = (*expr._v__ast__StringLiteral).pos;
		// autofree_scope_vars(pos=33010 line_nr=1488 scope.pos=32528 scope.end_pos=33029)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1082;
	}
	else if (expr._typ == 278 /* v.ast.StructInit */) {
		 v__token__Position _t1083 = (*expr._v__ast__StructInit).pos;
		// autofree_scope_vars(pos=33010 line_nr=1488 scope.pos=32528 scope.end_pos=33029)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1083;
	}
	else if (expr._typ == 279 /* v.ast.TypeNode */) {
		 v__token__Position _t1084 = (*expr._v__ast__TypeNode).pos;
		// autofree_scope_vars(pos=33010 line_nr=1488 scope.pos=32528 scope.end_pos=33029)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1084;
	}
	else if (expr._typ == 280 /* v.ast.TypeOf */) {
		 v__token__Position _t1085 = (*expr._v__ast__TypeOf).pos;
		// autofree_scope_vars(pos=33010 line_nr=1488 scope.pos=32528 scope.end_pos=33029)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1085;
	}
	else if (expr._typ == 281 /* v.ast.UnsafeExpr */) {
		 v__token__Position _t1086 = (*expr._v__ast__UnsafeExpr).pos;
		// autofree_scope_vars(pos=33010 line_nr=1488 scope.pos=32528 scope.end_pos=33029)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1086;
	}
	else if (expr._typ == 257 /* v.ast.IndexExpr */) {
		if ((*expr._v__ast__IndexExpr).or_expr.kind != v__ast__OrKind_absent) {
			 v__token__Position _t1087 = (*expr._v__ast__IndexExpr).or_expr.pos;
			// autofree_scope_vars(pos=33085 line_nr=1492 scope.pos=33080 scope.end_pos=33113)
			// af parent scope:
			// var "expr" var.pos=32373 var.line_nr=1474
			// af parent scope:
			// var "expr" var.pos=32170 var.line_nr=1470
			// af parent scope:
			// af parent scope:
			return _t1087;
		}
		 v__token__Position _t1088 = (*expr._v__ast__IndexExpr).pos;
		// autofree_scope_vars(pos=33117 line_nr=1494 scope.pos=33033 scope.end_pos=33136)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1088;
	}
	else if (expr._typ == 256 /* v.ast.IfGuardExpr */) {
		 v__token__Position _t1089 = v__ast__Expr_position((*expr._v__ast__IfGuardExpr).expr);
		// autofree_scope_vars(pos=33156 line_nr=1497 scope.pos=33140 scope.end_pos=33187)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1089;
	}
	else if (expr._typ == 258 /* v.ast.InfixExpr */) {
		v__token__Position left_pos = v__ast__Expr_position((*expr._v__ast__InfixExpr).left);
		v__token__Position right_pos = v__ast__Expr_position((*expr._v__ast__InfixExpr).right);
		 v__token__Position _t1090 = (v__token__Position){.len = right_pos.pos - left_pos.pos + right_pos.len,.line_nr = (*expr._v__ast__InfixExpr).pos.line_nr,.pos = left_pos.pos,.col = left_pos.col,.last_line = right_pos.last_line,};
		// autofree_scope_vars(pos=33279 line_nr=1502 scope.pos=33191 scope.end_pos=33473)
		// var "left_pos" var.pos=33206 var.line_nr=1500
		// var "right_pos" var.pos=33242 var.line_nr=1501
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1090;
	}
	else if (expr._typ == 240 /* v.ast.CTempVar */) {
		 v__token__Position _t1091 = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,};
		// autofree_scope_vars(pos=33490 line_nr=1511 scope.pos=33477 scope.end_pos=33517)
		// var "expr" var.pos=32373 var.line_nr=1474
		// af parent scope:
		// var "expr" var.pos=32170 var.line_nr=1470
		// af parent scope:
		// af parent scope:
		return _t1091;
	};
	return (v__token__Position){0};
}

bool v__ast__Expr_is_lvalue(v__ast__Expr expr) {
	if (expr._typ == 254 /* v.ast.Ident */) {
		 bool _t1092 = true;
		// autofree_scope_vars(pos=33731 line_nr=1521 scope.pos=33724 scope.end_pos=33744)
		// var "expr" var.pos=33715 var.line_nr=1520
		// af parent scope:
		// var "expr" var.pos=33678 var.line_nr=1519
		// af parent scope:
		// af parent scope:
		return _t1092;
	}
	else if (expr._typ == 240 /* v.ast.CTempVar */) {
		 bool _t1093 = true;
		// autofree_scope_vars(pos=33758 line_nr=1522 scope.pos=33748 scope.end_pos=33771)
		// var "expr" var.pos=33715 var.line_nr=1520
		// af parent scope:
		// var "expr" var.pos=33678 var.line_nr=1519
		// af parent scope:
		// af parent scope:
		return _t1093;
	}
	else if (expr._typ == 257 /* v.ast.IndexExpr */) {
		 bool _t1094 = v__ast__Expr_is_lvalue((*expr._v__ast__IndexExpr).left);
		// autofree_scope_vars(pos=33786 line_nr=1523 scope.pos=33775 scope.end_pos=33816)
		// var "expr" var.pos=33715 var.line_nr=1520
		// af parent scope:
		// var "expr" var.pos=33678 var.line_nr=1519
		// af parent scope:
		// af parent scope:
		return _t1094;
	}
	else if (expr._typ == 273 /* v.ast.SelectorExpr */) {
		 bool _t1095 = v__ast__Expr_is_lvalue((*expr._v__ast__SelectorExpr).expr);
		// autofree_scope_vars(pos=33834 line_nr=1524 scope.pos=33820 scope.end_pos=33864)
		// var "expr" var.pos=33715 var.line_nr=1520
		// af parent scope:
		// var "expr" var.pos=33678 var.line_nr=1519
		// af parent scope:
		// af parent scope:
		return _t1095;
	}
	else if (expr._typ == 268 /* v.ast.ParExpr */) {
		 bool _t1096 = v__ast__Expr_is_lvalue((*expr._v__ast__ParExpr).expr);
		// autofree_scope_vars(pos=33877 line_nr=1525 scope.pos=33868 scope.end_pos=33907)
		// var "expr" var.pos=33715 var.line_nr=1520
		// af parent scope:
		// var "expr" var.pos=33678 var.line_nr=1519
		// af parent scope:
		// af parent scope:
		return _t1096;
	}
	else if (expr._typ == 270 /* v.ast.PrefixExpr */) {
		 bool _t1097 = v__ast__Expr_is_lvalue((*expr._v__ast__PrefixExpr).right);
		// autofree_scope_vars(pos=33958 line_nr=1526 scope.pos=33946 scope.end_pos=33989)
		// var "expr" var.pos=33715 var.line_nr=1520
		// af parent scope:
		// var "expr" var.pos=33678 var.line_nr=1519
		// af parent scope:
		// af parent scope:
		return _t1097;
	}
	else {
	};
	 bool _t1098 = false;
	// autofree_scope_vars(pos=34004 line_nr=1529 scope.pos=33677 scope.end_pos=34018)
	// var "expr" var.pos=33678 var.line_nr=1519
	// af parent scope:
	// af parent scope:
	return _t1098;
}

bool v__ast__Expr_is_expr(v__ast__Expr expr) {
	if (expr._typ == 255 /* v.ast.IfExpr */) {
		 bool _t1099 = (*expr._v__ast__IfExpr).is_expr;
		// autofree_scope_vars(pos=34081 line_nr=1534 scope.pos=34073 scope.end_pos=34102)
		// var "expr" var.pos=34064 var.line_nr=1533
		// af parent scope:
		// var "expr" var.pos=34029 var.line_nr=1532
		// af parent scope:
		// af parent scope:
		return _t1099;
	}
	else if (expr._typ == 261 /* v.ast.LockExpr */) {
		 bool _t1100 = (*expr._v__ast__LockExpr).is_expr;
		// autofree_scope_vars(pos=34116 line_nr=1535 scope.pos=34106 scope.end_pos=34137)
		// var "expr" var.pos=34064 var.line_nr=1533
		// af parent scope:
		// var "expr" var.pos=34029 var.line_nr=1532
		// af parent scope:
		// af parent scope:
		return _t1100;
	}
	else if (expr._typ == 263 /* v.ast.MatchExpr */) {
		 bool _t1101 = (*expr._v__ast__MatchExpr).is_expr;
		// autofree_scope_vars(pos=34152 line_nr=1536 scope.pos=34141 scope.end_pos=34173)
		// var "expr" var.pos=34064 var.line_nr=1533
		// af parent scope:
		// var "expr" var.pos=34029 var.line_nr=1532
		// af parent scope:
		// af parent scope:
		return _t1101;
	}
	else if (expr._typ == 272 /* v.ast.SelectExpr */) {
		 bool _t1102 = (*expr._v__ast__SelectExpr).is_expr;
		// autofree_scope_vars(pos=34189 line_nr=1537 scope.pos=34177 scope.end_pos=34210)
		// var "expr" var.pos=34064 var.line_nr=1533
		// af parent scope:
		// var "expr" var.pos=34029 var.line_nr=1532
		// af parent scope:
		// af parent scope:
		return _t1102;
	}
	else {
	};
	 bool _t1103 = true;
	// autofree_scope_vars(pos=34225 line_nr=1540 scope.pos=34028 scope.end_pos=34238)
	// var "expr" var.pos=34029 var.line_nr=1532
	// af parent scope:
	// af parent scope:
	return _t1103;
}

bool v__ast__Expr_is_lit(v__ast__Expr expr) {
	 bool _t1104 = ((expr._typ == 239 /* v.ast.BoolLiteral */) ? (true) : (expr._typ == 277 /* v.ast.StringLiteral */) ? (true) : (expr._typ == 259 /* v.ast.IntegerLiteral */) ? (true) : (false));
	// autofree_scope_vars(pos=34276 line_nr=1544 scope.pos=34248 scope.end_pos=34371)
	// var "expr" var.pos=34249 var.line_nr=1543
	// af parent scope:
	// af parent scope:
	return _t1104;
}

bool v__ast__Expr_is_auto_deref_var(v__ast__Expr expr) {
	if (expr._typ == 254 /* v.ast.Ident */) {
		if (((*expr._v__ast__Ident).obj)._typ == 312 /* v.ast.Var */) {
			if ((*(*expr._v__ast__Ident).obj._v__ast__Var).is_auto_deref) {
				 bool _t1105 = true;
				// autofree_scope_vars(pos=34504 line_nr=1555 scope.pos=34498 scope.end_pos=34521)
				// af parent scope:
				// af parent scope:
				// var "expr" var.pos=34427 var.line_nr=1551
				// af parent scope:
				// var "expr" var.pos=34382 var.line_nr=1550
				// af parent scope:
				// af parent scope:
				return _t1105;
			}
		}
	}
	else if (expr._typ == 270 /* v.ast.PrefixExpr */) {
		if ((*expr._v__ast__PrefixExpr).op == v__token__Kind_amp && v__ast__Expr_is_auto_deref_var((*expr._v__ast__PrefixExpr).right)) {
			 bool _t1106 = true;
			// autofree_scope_vars(pos=34608 line_nr=1561 scope.pos=34603 scope.end_pos=34624)
			// af parent scope:
			// var "expr" var.pos=34427 var.line_nr=1551
			// af parent scope:
			// var "expr" var.pos=34382 var.line_nr=1550
			// af parent scope:
			// af parent scope:
			return _t1106;
		}
	}
	else {
	};
	 bool _t1107 = false;
	// autofree_scope_vars(pos=34643 line_nr=1566 scope.pos=34381 scope.end_pos=34657)
	// var "expr" var.pos=34382 var.line_nr=1550
	// af parent scope:
	// af parent scope:
	return _t1107;
}

Option_void v__ast__Stmt_check_c_expr(v__ast__Stmt stmt) {
	if (stmt._typ == 285 /* v.ast.AssignStmt */) {
		return (Option_void){0};
	}
	else if (stmt._typ == 293 /* v.ast.ExprStmt */) {
		if (v__ast__Expr_is_expr((*stmt._v__ast__ExprStmt).expr)) {
			return (Option_void){0};
		}
		return (Option_void){ .state=2, .err=v_error(_STR("unsupported statement (`%.*s\000`)", 2, tos3( /* v.ast.Expr */ v_typeof_sumtype_v__ast__Expr( ((*stmt._v__ast__ExprStmt).expr)._typ )))) };
	}
	else {
	};
	return (Option_void){ .state=2, .err=v_error(_STR("unsupported statement (`%.*s\000`)", 2, tos3( /* v.ast.Stmt */ v_typeof_sumtype_v__ast__Stmt( (stmt)._typ )))) };
}

v__token__Position v__ast__Node_position(v__ast__Node node) {
	if (node._typ == 264 /* v.ast.NodeError */) {
		 v__token__Position _t1108 = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,};
		// autofree_scope_vars(pos=35440 line_nr=1598 scope.pos=35426 scope.end_pos=35467)
		// var "node" var.pos=35417 var.line_nr=1596
		// af parent scope:
		// var "node" var.pos=35371 var.line_nr=1595
		// af parent scope:
		// af parent scope:
		return _t1108;
	}
	else if (node._typ == 315 /* v.ast.EmptyNode */) {
		 v__token__Position _t1109 = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,};
		// autofree_scope_vars(pos=35485 line_nr=1601 scope.pos=35471 scope.end_pos=35512)
		// var "node" var.pos=35417 var.line_nr=1596
		// af parent scope:
		// var "node" var.pos=35371 var.line_nr=1595
		// af parent scope:
		// af parent scope:
		return _t1109;
	}
	else if (node._typ == 308 /* v.ast.Stmt */) {
		v__token__Position pos = (*((*node._v__ast__Stmt).pos));
		if (((*node._v__ast__Stmt))._typ == 302 /* v.ast.Import */) {
			// FOR IN array
			for (int _t1110 = 0; _t1110 < (*(*node._v__ast__Stmt)._v__ast__Import).syms.len; ++_t1110) {
				v__ast__ImportSymbol sym = ((v__ast__ImportSymbol*)(*(*node._v__ast__Stmt)._v__ast__Import).syms.data)[_t1110];
				pos = v__token__Position_extend(pos, sym.pos);
			}
		} else if (((*node._v__ast__Stmt))._typ == 232 /* v.ast.TypeDecl */) {
			if ((*(*node._v__ast__Stmt)._v__ast__TypeDecl)._typ == 230 /* v.ast.FnTypeDecl */) {
				pos = v__token__Position_extend(pos, (*(*(*node._v__ast__Stmt)._v__ast__TypeDecl)._v__ast__FnTypeDecl).type_pos);
			}
			else if ((*(*node._v__ast__Stmt)._v__ast__TypeDecl)._typ == 229 /* v.ast.AliasTypeDecl */) {
				pos = v__token__Position_extend(pos, (*(*(*node._v__ast__Stmt)._v__ast__TypeDecl)._v__ast__AliasTypeDecl).type_pos);
			}
			else if ((*(*node._v__ast__Stmt)._v__ast__TypeDecl)._typ == 231 /* v.ast.SumTypeDecl */) {
				// FOR IN array
				for (int _t1111 = 0; _t1111 < (*(*(*node._v__ast__Stmt)._v__ast__TypeDecl)._v__ast__SumTypeDecl).variants.len; ++_t1111) {
					v__ast__SumTypeVariant variant = ((v__ast__SumTypeVariant*)(*(*(*node._v__ast__Stmt)._v__ast__TypeDecl)._v__ast__SumTypeDecl).variants.data)[_t1111];
					pos = v__token__Position_extend(pos, variant.pos);
				}
			};
		}
		if (((*node._v__ast__Stmt))._typ == 285 /* v.ast.AssignStmt */) {
			 v__token__Position _t1112 = v__token__Position_extend(pos, v__ast__Expr_position((*(v__ast__Expr*)array_last((*(*node._v__ast__Stmt)._v__ast__AssignStmt).right))));
			// autofree_scope_vars(pos=35909 line_nr=1622 scope.pos=35904 scope.end_pos=35961)
			// var "node" var.pos=35885 var.line_nr=1621
			// af parent scope:
			// var "pos" var.pos=35530 var.line_nr=1604
			// var "node" var.pos=35417 var.line_nr=1596
			// af parent scope:
			// var "node" var.pos=35371 var.line_nr=1595
			// af parent scope:
			// af parent scope:
			return _t1112;
		}
		if (((*node._v__ast__Stmt))._typ == 284 /* v.ast.AssertStmt */) {
			 v__token__Position _t1113 = v__token__Position_extend(pos, v__ast__Expr_position((*(*node._v__ast__Stmt)._v__ast__AssertStmt).expr));
			// autofree_scope_vars(pos=35993 line_nr=1625 scope.pos=35988 scope.end_pos=36037)
			// var "node" var.pos=35969 var.line_nr=1624
			// af parent scope:
			// var "pos" var.pos=35530 var.line_nr=1604
			// var "node" var.pos=35417 var.line_nr=1596
			// af parent scope:
			// var "node" var.pos=35371 var.line_nr=1595
			// af parent scope:
			// af parent scope:
			return _t1113;
		}
		// autofree_scope_vars(pos=36041 line_nr=1627 scope.pos=35516 scope.end_pos=36055)
		// var "pos" var.pos=35530 var.line_nr=1604
		// var "node" var.pos=35417 var.line_nr=1596
		// af parent scope:
		// var "node" var.pos=35371 var.line_nr=1595
		// af parent scope:
		// af parent scope:
		return pos;
	}
	else if (node._typ == 282 /* v.ast.Expr */) {
		 v__token__Position _t1114 = v__ast__Expr_position((*node._v__ast__Expr));
		// autofree_scope_vars(pos=36068 line_nr=1630 scope.pos=36059 scope.end_pos=36094)
		// var "node" var.pos=35417 var.line_nr=1596
		// af parent scope:
		// var "node" var.pos=35371 var.line_nr=1595
		// af parent scope:
		// af parent scope:
		return _t1114;
	}
	else if (node._typ == 321 /* v.ast.StructField */) {
		 v__token__Position _t1115 = v__token__Position_extend((*node._v__ast__StructField).pos, (*node._v__ast__StructField).type_pos);
		// autofree_scope_vars(pos=36114 line_nr=1633 scope.pos=36098 scope.end_pos=36155)
		// var "node" var.pos=35417 var.line_nr=1596
		// af parent scope:
		// var "node" var.pos=35371 var.line_nr=1595
		// af parent scope:
		// af parent scope:
		return _t1115;
	}
	else if (node._typ == 318 /* v.ast.MatchBranch */) {
		 v__token__Position _t1116 = (*node._v__ast__MatchBranch).pos;
		// autofree_scope_vars(pos=36269 line_nr=1637 scope.pos=36159 scope.end_pos=36288)
		// var "node" var.pos=35417 var.line_nr=1596
		// af parent scope:
		// var "node" var.pos=35371 var.line_nr=1595
		// af parent scope:
		// af parent scope:
		return _t1116;
	}
	else if (node._typ == 320 /* v.ast.SelectBranch */) {
		 v__token__Position _t1117 = (*node._v__ast__SelectBranch).pos;
		// autofree_scope_vars(pos=36269 line_nr=1637 scope.pos=36159 scope.end_pos=36288)
		// var "node" var.pos=35417 var.line_nr=1596
		// af parent scope:
		// var "node" var.pos=35371 var.line_nr=1595
		// af parent scope:
		// af parent scope:
		return _t1117;
	}
	else if (node._typ == 316 /* v.ast.EnumField */) {
		 v__token__Position _t1118 = (*node._v__ast__EnumField).pos;
		// autofree_scope_vars(pos=36269 line_nr=1637 scope.pos=36159 scope.end_pos=36288)
		// var "node" var.pos=35417 var.line_nr=1596
		// af parent scope:
		// var "node" var.pos=35371 var.line_nr=1595
		// af parent scope:
		// af parent scope:
		return _t1118;
	}
	else if (node._typ == 310 /* v.ast.ConstField */) {
		 v__token__Position _t1119 = (*node._v__ast__ConstField).pos;
		// autofree_scope_vars(pos=36269 line_nr=1637 scope.pos=36159 scope.end_pos=36288)
		// var "node" var.pos=35417 var.line_nr=1596
		// af parent scope:
		// var "node" var.pos=35371 var.line_nr=1595
		// af parent scope:
		// af parent scope:
		return _t1119;
	}
	else if (node._typ == 322 /* v.ast.StructInitField */) {
		 v__token__Position _t1120 = (*node._v__ast__StructInitField).pos;
		// autofree_scope_vars(pos=36269 line_nr=1637 scope.pos=36159 scope.end_pos=36288)
		// var "node" var.pos=35417 var.line_nr=1596
		// af parent scope:
		// var "node" var.pos=35371 var.line_nr=1595
		// af parent scope:
		// af parent scope:
		return _t1120;
	}
	else if (node._typ == 311 /* v.ast.GlobalField */) {
		 v__token__Position _t1121 = (*node._v__ast__GlobalField).pos;
		// autofree_scope_vars(pos=36269 line_nr=1637 scope.pos=36159 scope.end_pos=36288)
		// var "node" var.pos=35417 var.line_nr=1596
		// af parent scope:
		// var "node" var.pos=35371 var.line_nr=1595
		// af parent scope:
		// af parent scope:
		return _t1121;
	}
	else if (node._typ == 314 /* v.ast.CallArg */) {
		 v__token__Position _t1122 = (*node._v__ast__CallArg).pos;
		// autofree_scope_vars(pos=36269 line_nr=1637 scope.pos=36159 scope.end_pos=36288)
		// var "node" var.pos=35417 var.line_nr=1596
		// af parent scope:
		// var "node" var.pos=35371 var.line_nr=1595
		// af parent scope:
		// af parent scope:
		return _t1122;
	}
	else if (node._typ == 323 /* v.ast.SumTypeVariant */) {
		 v__token__Position _t1123 = (*node._v__ast__SumTypeVariant).pos;
		// autofree_scope_vars(pos=36269 line_nr=1637 scope.pos=36159 scope.end_pos=36288)
		// var "node" var.pos=35417 var.line_nr=1596
		// af parent scope:
		// var "node" var.pos=35371 var.line_nr=1595
		// af parent scope:
		// af parent scope:
		return _t1123;
	}
	else if (node._typ == 319 /* v.ast.Param */) {
		 v__token__Position _t1124 = v__token__Position_extend((*node._v__ast__Param).pos, (*node._v__ast__Param).type_pos);
		// autofree_scope_vars(pos=36302 line_nr=1640 scope.pos=36292 scope.end_pos=36343)
		// var "node" var.pos=35417 var.line_nr=1596
		// af parent scope:
		// var "node" var.pos=35371 var.line_nr=1595
		// af parent scope:
		// af parent scope:
		return _t1124;
	}
	else if (node._typ == 317 /* v.ast.IfBranch */) {
		 v__token__Position _t1125 = v__token__Position_extend((*node._v__ast__IfBranch).pos, (*node._v__ast__IfBranch).body_pos);
		// autofree_scope_vars(pos=36360 line_nr=1643 scope.pos=36347 scope.end_pos=36401)
		// var "node" var.pos=35417 var.line_nr=1596
		// af parent scope:
		// var "node" var.pos=35371 var.line_nr=1595
		// af parent scope:
		// af parent scope:
		return _t1125;
	}
	else if (node._typ == 313 /* v.ast.ScopeObject */) {
		if ((*node._v__ast__ScopeObject)._typ == 310 /* v.ast.ConstField */) {
			 v__token__Position _t1126 = (*(*node._v__ast__ScopeObject)._v__ast__ConstField).pos;
			// autofree_scope_vars(pos=36474 line_nr=1648 scope.pos=36439 scope.end_pos=36495)
			// var "node" var.pos=36428 var.line_nr=1646
			// af parent scope:
			// var "node" var.pos=35417 var.line_nr=1596
			// af parent scope:
			// var "node" var.pos=35371 var.line_nr=1595
			// af parent scope:
			// af parent scope:
			return _t1126;
		}
		else if ((*node._v__ast__ScopeObject)._typ == 311 /* v.ast.GlobalField */) {
			 v__token__Position _t1127 = (*(*node._v__ast__ScopeObject)._v__ast__GlobalField).pos;
			// autofree_scope_vars(pos=36474 line_nr=1648 scope.pos=36439 scope.end_pos=36495)
			// var "node" var.pos=36428 var.line_nr=1646
			// af parent scope:
			// var "node" var.pos=35417 var.line_nr=1596
			// af parent scope:
			// var "node" var.pos=35371 var.line_nr=1595
			// af parent scope:
			// af parent scope:
			return _t1127;
		}
		else if ((*node._v__ast__ScopeObject)._typ == 312 /* v.ast.Var */) {
			 v__token__Position _t1128 = (*(*node._v__ast__ScopeObject)._v__ast__Var).pos;
			// autofree_scope_vars(pos=36474 line_nr=1648 scope.pos=36439 scope.end_pos=36495)
			// var "node" var.pos=36428 var.line_nr=1646
			// af parent scope:
			// var "node" var.pos=35417 var.line_nr=1596
			// af parent scope:
			// var "node" var.pos=35371 var.line_nr=1595
			// af parent scope:
			// af parent scope:
			return _t1128;
		}
		else if ((*node._v__ast__ScopeObject)._typ == 309 /* v.ast.AsmRegister */) {
			 v__token__Position _t1129 = (v__token__Position){.len = -1,.line_nr = -1,.pos = -1,.col = -1,.last_line = -1,};
			// autofree_scope_vars(pos=36519 line_nr=1651 scope.pos=36501 scope.end_pos=36634)
			// var "node" var.pos=36428 var.line_nr=1646
			// af parent scope:
			// var "node" var.pos=35417 var.line_nr=1596
			// af parent scope:
			// var "node" var.pos=35371 var.line_nr=1595
			// af parent scope:
			// af parent scope:
			return _t1129;
		};
	}
	else if (node._typ == 166 /* v.ast.File */) {
		v__token__Position pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,};
		if ((*node._v__ast__File).stmts.len > 0) {
			v__token__Position first_pos = (*((*(v__ast__Stmt*)array_first((*node._v__ast__File).stmts)).pos));
			v__token__Position last_pos = (*((*(v__ast__Stmt*)array_last((*node._v__ast__File).stmts)).pos));
			pos = v__token__Position_extend_with_last_line(first_pos, last_pos, last_pos.line_nr);
		}
		// autofree_scope_vars(pos=36867 line_nr=1668 scope.pos=36647 scope.end_pos=36881)
		// var "pos" var.pos=36661 var.line_nr=1662
		// var "node" var.pos=35417 var.line_nr=1596
		// af parent scope:
		// var "node" var.pos=35371 var.line_nr=1595
		// af parent scope:
		// af parent scope:
		return pos;
	};
	return (v__token__Position){0};
}

Array_v__ast__Node v__ast__Node_children(v__ast__Node node) {
	Array_v__ast__Node children = __new_array_with_default(0, 0, sizeof(v__ast__Node), 0);
	if ((node)._typ == 282 /* v.ast.Expr */) {
		if ((*node._v__ast__Expr)._typ == 276 /* v.ast.StringInterLiteral */) {
			Array_v__ast__Expr _t1131_orig = (*(*node._v__ast__Expr)._v__ast__StringInterLiteral).exprs;
			int _t1131_len = _t1131_orig.len;
			Array_v__ast__Node _t1131 = __new_array(0, _t1131_len, sizeof(v__ast__Node));

			for (int _t1132 = 0; _t1132 < _t1131_len; ++_t1132) {
				v__ast__Expr it = ((v__ast__Expr*) _t1131_orig.data)[_t1132];
				v__ast__Node ti = v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, (it)));
				array_push(&_t1131, &ti);
			}
			
			 Array_v__ast__Node _t1130 = _t1131;
			// autofree_scope_vars(pos=37033 line_nr=1678 scope.pos=36991 scope.end_pos=37069)
			// var "node" var.pos=36981 var.line_nr=1676
			// af parent scope:
			// var "node" var.pos=36958 var.line_nr=1675
			// af parent scope:
			// var "node" var.pos=36897 var.line_nr=1673
			// var "children" var.pos=36933 var.line_nr=1674
			// af parent scope:
			// af parent scope:
			return _t1130;
		}
		else if ((*node._v__ast__Expr)._typ == 237 /* v.ast.Assoc */) {
			Array_v__ast__Expr _t1134_orig = (*(*node._v__ast__Expr)._v__ast__Assoc).exprs;
			int _t1134_len = _t1134_orig.len;
			Array_v__ast__Node _t1134 = __new_array(0, _t1134_len, sizeof(v__ast__Node));

			for (int _t1135 = 0; _t1135 < _t1134_len; ++_t1135) {
				v__ast__Expr it = ((v__ast__Expr*) _t1134_orig.data)[_t1135];
				v__ast__Node ti = v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, (it)));
				array_push(&_t1134, &ti);
			}
			
			 Array_v__ast__Node _t1133 = _t1134;
			// autofree_scope_vars(pos=37033 line_nr=1678 scope.pos=36991 scope.end_pos=37069)
			// var "node" var.pos=36981 var.line_nr=1676
			// af parent scope:
			// var "node" var.pos=36958 var.line_nr=1675
			// af parent scope:
			// var "node" var.pos=36897 var.line_nr=1673
			// var "children" var.pos=36933 var.line_nr=1674
			// af parent scope:
			// af parent scope:
			return _t1133;
		}
		else if ((*node._v__ast__Expr)._typ == 235 /* v.ast.ArrayInit */) {
			Array_v__ast__Expr _t1137_orig = (*(*node._v__ast__Expr)._v__ast__ArrayInit).exprs;
			int _t1137_len = _t1137_orig.len;
			Array_v__ast__Node _t1137 = __new_array(0, _t1137_len, sizeof(v__ast__Node));

			for (int _t1138 = 0; _t1138 < _t1137_len; ++_t1138) {
				v__ast__Expr it = ((v__ast__Expr*) _t1137_orig.data)[_t1138];
				v__ast__Node ti = v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, (it)));
				array_push(&_t1137, &ti);
			}
			
			 Array_v__ast__Node _t1136 = _t1137;
			// autofree_scope_vars(pos=37033 line_nr=1678 scope.pos=36991 scope.end_pos=37069)
			// var "node" var.pos=36981 var.line_nr=1676
			// af parent scope:
			// var "node" var.pos=36958 var.line_nr=1675
			// af parent scope:
			// var "node" var.pos=36897 var.line_nr=1673
			// var "children" var.pos=36933 var.line_nr=1674
			// af parent scope:
			// af parent scope:
			return _t1136;
		}
		else if ((*node._v__ast__Expr)._typ == 273 /* v.ast.SelectorExpr */) {
			array_push(&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, ((*(*node._v__ast__Expr)._v__ast__SelectorExpr).expr))) }));
		}
		else if ((*node._v__ast__Expr)._typ == 269 /* v.ast.PostfixExpr */) {
			array_push(&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, ((*(*node._v__ast__Expr)._v__ast__PostfixExpr).expr))) }));
		}
		else if ((*node._v__ast__Expr)._typ == 281 /* v.ast.UnsafeExpr */) {
			array_push(&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, ((*(*node._v__ast__Expr)._v__ast__UnsafeExpr).expr))) }));
		}
		else if ((*node._v__ast__Expr)._typ == 236 /* v.ast.AsCast */) {
			array_push(&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, ((*(*node._v__ast__Expr)._v__ast__AsCast).expr))) }));
		}
		else if ((*node._v__ast__Expr)._typ == 268 /* v.ast.ParExpr */) {
			array_push(&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, ((*(*node._v__ast__Expr)._v__ast__ParExpr).expr))) }));
		}
		else if ((*node._v__ast__Expr)._typ == 256 /* v.ast.IfGuardExpr */) {
			array_push(&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, ((*(*node._v__ast__Expr)._v__ast__IfGuardExpr).expr))) }));
		}
		else if ((*node._v__ast__Expr)._typ == 274 /* v.ast.SizeOf */) {
			array_push(&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, ((*(*node._v__ast__Expr)._v__ast__SizeOf).expr))) }));
		}
		else if ((*node._v__ast__Expr)._typ == 260 /* v.ast.Likely */) {
			array_push(&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, ((*(*node._v__ast__Expr)._v__ast__Likely).expr))) }));
		}
		else if ((*node._v__ast__Expr)._typ == 280 /* v.ast.TypeOf */) {
			array_push(&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, ((*(*node._v__ast__Expr)._v__ast__TypeOf).expr))) }));
		}
		else if ((*node._v__ast__Expr)._typ == 234 /* v.ast.ArrayDecompose */) {
			array_push(&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, ((*(*node._v__ast__Expr)._v__ast__ArrayDecompose).expr))) }));
		}
		else if ((*node._v__ast__Expr)._typ == 261 /* v.ast.LockExpr */) {
			Array_v__ast__Stmt _t1150_orig = (*(*node._v__ast__Expr)._v__ast__LockExpr).stmts;
			int _t1150_len = _t1150_orig.len;
			Array_v__ast__Node _t1150 = __new_array(0, _t1150_len, sizeof(v__ast__Node));

			for (int _t1151 = 0; _t1151 < _t1150_len; ++_t1151) {
				v__ast__Stmt it = ((v__ast__Stmt*) _t1150_orig.data)[_t1151];
				v__ast__Node ti = v__ast__Stmt_to_sumtype_v__ast__Node(ADDR(v__ast__Stmt, (it)));
				array_push(&_t1150, &ti);
			}
			
			 Array_v__ast__Node _t1149 = _t1150;
			// autofree_scope_vars(pos=37243 line_nr=1685 scope.pos=37221 scope.end_pos=37279)
			// var "node" var.pos=36981 var.line_nr=1676
			// af parent scope:
			// var "node" var.pos=36958 var.line_nr=1675
			// af parent scope:
			// var "node" var.pos=36897 var.line_nr=1673
			// var "children" var.pos=36933 var.line_nr=1674
			// af parent scope:
			// af parent scope:
			return _t1149;
		}
		else if ((*node._v__ast__Expr)._typ == 267 /* v.ast.OrExpr */) {
			Array_v__ast__Stmt _t1153_orig = (*(*node._v__ast__Expr)._v__ast__OrExpr).stmts;
			int _t1153_len = _t1153_orig.len;
			Array_v__ast__Node _t1153 = __new_array(0, _t1153_len, sizeof(v__ast__Node));

			for (int _t1154 = 0; _t1154 < _t1153_len; ++_t1154) {
				v__ast__Stmt it = ((v__ast__Stmt*) _t1153_orig.data)[_t1154];
				v__ast__Node ti = v__ast__Stmt_to_sumtype_v__ast__Node(ADDR(v__ast__Stmt, (it)));
				array_push(&_t1153, &ti);
			}
			
			 Array_v__ast__Node _t1152 = _t1153;
			// autofree_scope_vars(pos=37243 line_nr=1685 scope.pos=37221 scope.end_pos=37279)
			// var "node" var.pos=36981 var.line_nr=1676
			// af parent scope:
			// var "node" var.pos=36958 var.line_nr=1675
			// af parent scope:
			// var "node" var.pos=36897 var.line_nr=1673
			// var "children" var.pos=36933 var.line_nr=1674
			// af parent scope:
			// af parent scope:
			return _t1152;
		}
		else if ((*node._v__ast__Expr)._typ == 278 /* v.ast.StructInit */) {
			Array_v__ast__StructInitField _t1156_orig = (*(*node._v__ast__Expr)._v__ast__StructInit).fields;
			int _t1156_len = _t1156_orig.len;
			Array_v__ast__Node _t1156 = __new_array(0, _t1156_len, sizeof(v__ast__Node));

			for (int _t1157 = 0; _t1157 < _t1156_len; ++_t1157) {
				v__ast__StructInitField it = ((v__ast__StructInitField*) _t1156_orig.data)[_t1157];
				v__ast__Node ti = v__ast__StructInitField_to_sumtype_v__ast__Node(ADDR(v__ast__StructInitField, (it)));
				array_push(&_t1156, &ti);
			}
			
			 Array_v__ast__Node _t1155 = _t1156;
			// autofree_scope_vars(pos=37300 line_nr=1688 scope.pos=37284 scope.end_pos=37337)
			// var "node" var.pos=36981 var.line_nr=1676
			// af parent scope:
			// var "node" var.pos=36958 var.line_nr=1675
			// af parent scope:
			// var "node" var.pos=36897 var.line_nr=1673
			// var "children" var.pos=36933 var.line_nr=1674
			// af parent scope:
			// af parent scope:
			return _t1155;
		}
		else if ((*node._v__ast__Expr)._typ == 233 /* v.ast.AnonFn */) {
			array_push(&children, _MOV((v__ast__Node[]){ v__ast__Stmt_to_sumtype_v__ast__Node(ADDR(v__ast__Stmt, (v__ast__FnDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__FnDecl, ((*(*node._v__ast__Expr)._v__ast__AnonFn).decl)))))) }));
		}
		else if ((*node._v__ast__Expr)._typ == 241 /* v.ast.CallExpr */) {
			array_push(&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, ((*(*node._v__ast__Expr)._v__ast__CallExpr).left))) }));
			Array_v__ast__CallArg _t1161_orig = (*(*node._v__ast__Expr)._v__ast__CallExpr).args;
			int _t1161_len = _t1161_orig.len;
			Array_v__ast__Node _t1161 = __new_array(0, _t1161_len, sizeof(v__ast__Node));

			for (int _t1162 = 0; _t1162 < _t1161_len; ++_t1162) {
				v__ast__CallArg it = ((v__ast__CallArg*) _t1161_orig.data)[_t1162];
				v__ast__Node ti = v__ast__CallArg_to_sumtype_v__ast__Node(ADDR(v__ast__CallArg, (it)));
				array_push(&_t1161, &ti);
			}
			
			_PUSH_MANY(&children, (_t1161), _t1160, Array_v__ast__Node);
			array_push(&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, (v__ast__OrExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__OrExpr, ((*(*node._v__ast__Expr)._v__ast__CallExpr).or_block)))))) }));
		}
		else if ((*node._v__ast__Expr)._typ == 258 /* v.ast.InfixExpr */) {
			array_push(&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, ((*(*node._v__ast__Expr)._v__ast__InfixExpr).left))) }));
			array_push(&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, ((*(*node._v__ast__Expr)._v__ast__InfixExpr).right))) }));
		}
		else if ((*node._v__ast__Expr)._typ == 270 /* v.ast.PrefixExpr */) {
			array_push(&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, ((*(*node._v__ast__Expr)._v__ast__PrefixExpr).right))) }));
		}
		else if ((*node._v__ast__Expr)._typ == 257 /* v.ast.IndexExpr */) {
			array_push(&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, ((*(*node._v__ast__Expr)._v__ast__IndexExpr).left))) }));
			array_push(&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, ((*(*node._v__ast__Expr)._v__ast__IndexExpr).index))) }));
		}
		else if ((*node._v__ast__Expr)._typ == 255 /* v.ast.IfExpr */) {
			array_push(&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, ((*(*node._v__ast__Expr)._v__ast__IfExpr).left))) }));
			Array_v__ast__IfBranch _t1171_orig = (*(*node._v__ast__Expr)._v__ast__IfExpr).branches;
			int _t1171_len = _t1171_orig.len;
			Array_v__ast__Node _t1171 = __new_array(0, _t1171_len, sizeof(v__ast__Node));

			for (int _t1172 = 0; _t1172 < _t1171_len; ++_t1172) {
				v__ast__IfBranch it = ((v__ast__IfBranch*) _t1171_orig.data)[_t1172];
				v__ast__Node ti = v__ast__IfBranch_to_sumtype_v__ast__Node(ADDR(v__ast__IfBranch, (it)));
				array_push(&_t1171, &ti);
			}
			
			_PUSH_MANY(&children, (_t1171), _t1170, Array_v__ast__Node);
		}
		else if ((*node._v__ast__Expr)._typ == 263 /* v.ast.MatchExpr */) {
			array_push(&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, ((*(*node._v__ast__Expr)._v__ast__MatchExpr).cond))) }));
			Array_v__ast__MatchBranch _t1175_orig = (*(*node._v__ast__Expr)._v__ast__MatchExpr).branches;
			int _t1175_len = _t1175_orig.len;
			Array_v__ast__Node _t1175 = __new_array(0, _t1175_len, sizeof(v__ast__Node));

			for (int _t1176 = 0; _t1176 < _t1175_len; ++_t1176) {
				v__ast__MatchBranch it = ((v__ast__MatchBranch*) _t1175_orig.data)[_t1176];
				v__ast__Node ti = v__ast__MatchBranch_to_sumtype_v__ast__Node(ADDR(v__ast__MatchBranch, (it)));
				array_push(&_t1175, &ti);
			}
			
			_PUSH_MANY(&children, (_t1175), _t1174, Array_v__ast__Node);
		}
		else if ((*node._v__ast__Expr)._typ == 272 /* v.ast.SelectExpr */) {
			Array_v__ast__SelectBranch _t1178_orig = (*(*node._v__ast__Expr)._v__ast__SelectExpr).branches;
			int _t1178_len = _t1178_orig.len;
			Array_v__ast__Node _t1178 = __new_array(0, _t1178_len, sizeof(v__ast__Node));

			for (int _t1179 = 0; _t1179 < _t1178_len; ++_t1179) {
				v__ast__SelectBranch it = ((v__ast__SelectBranch*) _t1178_orig.data)[_t1179];
				v__ast__Node ti = v__ast__SelectBranch_to_sumtype_v__ast__Node(ADDR(v__ast__SelectBranch, (it)));
				array_push(&_t1178, &ti);
			}
			
			 Array_v__ast__Node _t1177 = _t1178;
			// autofree_scope_vars(pos=37899 line_nr=1718 scope.pos=37883 scope.end_pos=37938)
			// var "node" var.pos=36981 var.line_nr=1676
			// af parent scope:
			// var "node" var.pos=36958 var.line_nr=1675
			// af parent scope:
			// var "node" var.pos=36897 var.line_nr=1673
			// var "children" var.pos=36933 var.line_nr=1674
			// af parent scope:
			// af parent scope:
			return _t1177;
		}
		else if ((*node._v__ast__Expr)._typ == 243 /* v.ast.ChanInit */) {
			array_push(&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, ((*(*node._v__ast__Expr)._v__ast__ChanInit).cap_expr))) }));
		}
		else if ((*node._v__ast__Expr)._typ == 262 /* v.ast.MapInit */) {
			Array_v__ast__Expr _t1182_orig = (*(*node._v__ast__Expr)._v__ast__MapInit).keys;
			int _t1182_len = _t1182_orig.len;
			Array_v__ast__Node _t1182 = __new_array(0, _t1182_len, sizeof(v__ast__Node));

			for (int _t1183 = 0; _t1183 < _t1182_len; ++_t1183) {
				v__ast__Expr it = ((v__ast__Expr*) _t1182_orig.data)[_t1183];
				v__ast__Node ti = v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, (it)));
				array_push(&_t1182, &ti);
			}
			
			_PUSH_MANY(&children, (_t1182), _t1181, Array_v__ast__Node);
			Array_v__ast__Expr _t1185_orig = (*(*node._v__ast__Expr)._v__ast__MapInit).vals;
			int _t1185_len = _t1185_orig.len;
			Array_v__ast__Node _t1185 = __new_array(0, _t1185_len, sizeof(v__ast__Node));

			for (int _t1186 = 0; _t1186 < _t1185_len; ++_t1186) {
				v__ast__Expr it = ((v__ast__Expr*) _t1185_orig.data)[_t1186];
				v__ast__Node ti = v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, (it)));
				array_push(&_t1185, &ti);
			}
			
			_PUSH_MANY(&children, (_t1185), _t1184, Array_v__ast__Node);
		}
		else if ((*node._v__ast__Expr)._typ == 271 /* v.ast.RangeExpr */) {
			array_push(&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, ((*(*node._v__ast__Expr)._v__ast__RangeExpr).low))) }));
			array_push(&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, ((*(*node._v__ast__Expr)._v__ast__RangeExpr).high))) }));
		}
		else if ((*node._v__ast__Expr)._typ == 242 /* v.ast.CastExpr */) {
			array_push(&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, ((*(*node._v__ast__Expr)._v__ast__CastExpr).expr))) }));
			array_push(&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, ((*(*node._v__ast__Expr)._v__ast__CastExpr).arg))) }));
		}
		else if ((*node._v__ast__Expr)._typ == 248 /* v.ast.ConcatExpr */) {
			Array_v__ast__Expr _t1192_orig = (*(*node._v__ast__Expr)._v__ast__ConcatExpr).vals;
			int _t1192_len = _t1192_orig.len;
			Array_v__ast__Node _t1192 = __new_array(0, _t1192_len, sizeof(v__ast__Node));

			for (int _t1193 = 0; _t1193 < _t1192_len; ++_t1193) {
				v__ast__Expr it = ((v__ast__Expr*) _t1192_orig.data)[_t1193];
				v__ast__Node ti = v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, (it)));
				array_push(&_t1192, &ti);
			}
			
			 Array_v__ast__Node _t1191 = _t1192;
			// autofree_scope_vars(pos=38247 line_nr=1736 scope.pos=38231 scope.end_pos=38282)
			// var "node" var.pos=36981 var.line_nr=1676
			// af parent scope:
			// var "node" var.pos=36958 var.line_nr=1675
			// af parent scope:
			// var "node" var.pos=36897 var.line_nr=1673
			// var "children" var.pos=36933 var.line_nr=1674
			// af parent scope:
			// af parent scope:
			return _t1191;
		}
		else if ((*node._v__ast__Expr)._typ == 246 /* v.ast.ComptimeCall */) {
			array_push(&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, ((*(*node._v__ast__Expr)._v__ast__ComptimeCall).left))) }));
		}
		else if ((*node._v__ast__Expr)._typ == 247 /* v.ast.ComptimeSelector */) {
			array_push(&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, ((*(*node._v__ast__Expr)._v__ast__ComptimeSelector).left))) }));
		}
		else {
		};
	} else if ((node)._typ == 308 /* v.ast.Stmt */) {
		if ((*node._v__ast__Stmt)._typ == 286 /* v.ast.Block */) {
			Array_v__ast__Stmt _t1197_orig = (*(*node._v__ast__Stmt)._v__ast__Block).stmts;
			int _t1197_len = _t1197_orig.len;
			Array_v__ast__Node _t1197 = __new_array(0, _t1197_len, sizeof(v__ast__Node));

			for (int _t1198 = 0; _t1198 < _t1197_len; ++_t1198) {
				v__ast__Stmt it = ((v__ast__Stmt*) _t1197_orig.data)[_t1198];
				v__ast__Node ti = v__ast__Stmt_to_sumtype_v__ast__Node(ADDR(v__ast__Stmt, (it)));
				array_push(&_t1197, &ti);
			}
			
			 Array_v__ast__Node _t1196 = _t1197;
			// autofree_scope_vars(pos=38471 line_nr=1746 scope.pos=38410 scope.end_pos=38507)
			// var "node" var.pos=38400 var.line_nr=1744
			// af parent scope:
			// var "node" var.pos=38377 var.line_nr=1743
			// af parent scope:
			// var "node" var.pos=36897 var.line_nr=1673
			// var "children" var.pos=36933 var.line_nr=1674
			// af parent scope:
			// af parent scope:
			return _t1196;
		}
		else if ((*node._v__ast__Stmt)._typ == 290 /* v.ast.DeferStmt */) {
			Array_v__ast__Stmt _t1200_orig = (*(*node._v__ast__Stmt)._v__ast__DeferStmt).stmts;
			int _t1200_len = _t1200_orig.len;
			Array_v__ast__Node _t1200 = __new_array(0, _t1200_len, sizeof(v__ast__Node));

			for (int _t1201 = 0; _t1201 < _t1200_len; ++_t1201) {
				v__ast__Stmt it = ((v__ast__Stmt*) _t1200_orig.data)[_t1201];
				v__ast__Node ti = v__ast__Stmt_to_sumtype_v__ast__Node(ADDR(v__ast__Stmt, (it)));
				array_push(&_t1200, &ti);
			}
			
			 Array_v__ast__Node _t1199 = _t1200;
			// autofree_scope_vars(pos=38471 line_nr=1746 scope.pos=38410 scope.end_pos=38507)
			// var "node" var.pos=38400 var.line_nr=1744
			// af parent scope:
			// var "node" var.pos=38377 var.line_nr=1743
			// af parent scope:
			// var "node" var.pos=36897 var.line_nr=1673
			// var "children" var.pos=36933 var.line_nr=1674
			// af parent scope:
			// af parent scope:
			return _t1199;
		}
		else if ((*node._v__ast__Stmt)._typ == 294 /* v.ast.ForCStmt */) {
			Array_v__ast__Stmt _t1203_orig = (*(*node._v__ast__Stmt)._v__ast__ForCStmt).stmts;
			int _t1203_len = _t1203_orig.len;
			Array_v__ast__Node _t1203 = __new_array(0, _t1203_len, sizeof(v__ast__Node));

			for (int _t1204 = 0; _t1204 < _t1203_len; ++_t1204) {
				v__ast__Stmt it = ((v__ast__Stmt*) _t1203_orig.data)[_t1204];
				v__ast__Node ti = v__ast__Stmt_to_sumtype_v__ast__Node(ADDR(v__ast__Stmt, (it)));
				array_push(&_t1203, &ti);
			}
			
			 Array_v__ast__Node _t1202 = _t1203;
			// autofree_scope_vars(pos=38471 line_nr=1746 scope.pos=38410 scope.end_pos=38507)
			// var "node" var.pos=38400 var.line_nr=1744
			// af parent scope:
			// var "node" var.pos=38377 var.line_nr=1743
			// af parent scope:
			// var "node" var.pos=36897 var.line_nr=1673
			// var "children" var.pos=36933 var.line_nr=1674
			// af parent scope:
			// af parent scope:
			return _t1202;
		}
		else if ((*node._v__ast__Stmt)._typ == 295 /* v.ast.ForInStmt */) {
			Array_v__ast__Stmt _t1206_orig = (*(*node._v__ast__Stmt)._v__ast__ForInStmt).stmts;
			int _t1206_len = _t1206_orig.len;
			Array_v__ast__Node _t1206 = __new_array(0, _t1206_len, sizeof(v__ast__Node));

			for (int _t1207 = 0; _t1207 < _t1206_len; ++_t1207) {
				v__ast__Stmt it = ((v__ast__Stmt*) _t1206_orig.data)[_t1207];
				v__ast__Node ti = v__ast__Stmt_to_sumtype_v__ast__Node(ADDR(v__ast__Stmt, (it)));
				array_push(&_t1206, &ti);
			}
			
			 Array_v__ast__Node _t1205 = _t1206;
			// autofree_scope_vars(pos=38471 line_nr=1746 scope.pos=38410 scope.end_pos=38507)
			// var "node" var.pos=38400 var.line_nr=1744
			// af parent scope:
			// var "node" var.pos=38377 var.line_nr=1743
			// af parent scope:
			// var "node" var.pos=36897 var.line_nr=1673
			// var "children" var.pos=36933 var.line_nr=1674
			// af parent scope:
			// af parent scope:
			return _t1205;
		}
		else if ((*node._v__ast__Stmt)._typ == 296 /* v.ast.ForStmt */) {
			Array_v__ast__Stmt _t1209_orig = (*(*node._v__ast__Stmt)._v__ast__ForStmt).stmts;
			int _t1209_len = _t1209_orig.len;
			Array_v__ast__Node _t1209 = __new_array(0, _t1209_len, sizeof(v__ast__Node));

			for (int _t1210 = 0; _t1210 < _t1209_len; ++_t1210) {
				v__ast__Stmt it = ((v__ast__Stmt*) _t1209_orig.data)[_t1210];
				v__ast__Node ti = v__ast__Stmt_to_sumtype_v__ast__Node(ADDR(v__ast__Stmt, (it)));
				array_push(&_t1209, &ti);
			}
			
			 Array_v__ast__Node _t1208 = _t1209;
			// autofree_scope_vars(pos=38471 line_nr=1746 scope.pos=38410 scope.end_pos=38507)
			// var "node" var.pos=38400 var.line_nr=1744
			// af parent scope:
			// var "node" var.pos=38377 var.line_nr=1743
			// af parent scope:
			// var "node" var.pos=36897 var.line_nr=1673
			// var "children" var.pos=36933 var.line_nr=1674
			// af parent scope:
			// af parent scope:
			return _t1208;
		}
		else if ((*node._v__ast__Stmt)._typ == 288 /* v.ast.CompFor */) {
			Array_v__ast__Stmt _t1212_orig = (*(*node._v__ast__Stmt)._v__ast__CompFor).stmts;
			int _t1212_len = _t1212_orig.len;
			Array_v__ast__Node _t1212 = __new_array(0, _t1212_len, sizeof(v__ast__Node));

			for (int _t1213 = 0; _t1213 < _t1212_len; ++_t1213) {
				v__ast__Stmt it = ((v__ast__Stmt*) _t1212_orig.data)[_t1213];
				v__ast__Node ti = v__ast__Stmt_to_sumtype_v__ast__Node(ADDR(v__ast__Stmt, (it)));
				array_push(&_t1212, &ti);
			}
			
			 Array_v__ast__Node _t1211 = _t1212;
			// autofree_scope_vars(pos=38471 line_nr=1746 scope.pos=38410 scope.end_pos=38507)
			// var "node" var.pos=38400 var.line_nr=1744
			// af parent scope:
			// var "node" var.pos=38377 var.line_nr=1743
			// af parent scope:
			// var "node" var.pos=36897 var.line_nr=1673
			// var "children" var.pos=36933 var.line_nr=1674
			// af parent scope:
			// af parent scope:
			return _t1211;
		}
		else if ((*node._v__ast__Stmt)._typ == 293 /* v.ast.ExprStmt */) {
			array_push(&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, ((*(*node._v__ast__Stmt)._v__ast__ExprStmt).expr))) }));
		}
		else if ((*node._v__ast__Stmt)._typ == 284 /* v.ast.AssertStmt */) {
			array_push(&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, ((*(*node._v__ast__Stmt)._v__ast__AssertStmt).expr))) }));
		}
		else if ((*node._v__ast__Stmt)._typ == 303 /* v.ast.InterfaceDecl */) {
			Array_v__ast__FnDecl _t1217_orig = (*(*node._v__ast__Stmt)._v__ast__InterfaceDecl).methods;
			int _t1217_len = _t1217_orig.len;
			Array_v__ast__Node _t1217 = __new_array(0, _t1217_len, sizeof(v__ast__Node));

			for (int _t1218 = 0; _t1218 < _t1217_len; ++_t1218) {
				v__ast__FnDecl it = ((v__ast__FnDecl*) _t1217_orig.data)[_t1218];
				v__ast__Node ti = v__ast__Stmt_to_sumtype_v__ast__Node(ADDR(v__ast__Stmt, (v__ast__FnDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__FnDecl, (it))))));
				array_push(&_t1217, &ti);
			}
			
			_PUSH_MANY(&children, (_t1217), _t1216, Array_v__ast__Node);
			Array_v__ast__StructField _t1220_orig = (*(*node._v__ast__Stmt)._v__ast__InterfaceDecl).fields;
			int _t1220_len = _t1220_orig.len;
			Array_v__ast__Node _t1220 = __new_array(0, _t1220_len, sizeof(v__ast__Node));

			for (int _t1221 = 0; _t1221 < _t1220_len; ++_t1221) {
				v__ast__StructField it = ((v__ast__StructField*) _t1220_orig.data)[_t1221];
				v__ast__Node ti = v__ast__StructField_to_sumtype_v__ast__Node(ADDR(v__ast__StructField, (it)));
				array_push(&_t1220, &ti);
			}
			
			_PUSH_MANY(&children, (_t1220), _t1219, Array_v__ast__Node);
		}
		else if ((*node._v__ast__Stmt)._typ == 285 /* v.ast.AssignStmt */) {
			Array_v__ast__Expr _t1223_orig = (*(*node._v__ast__Stmt)._v__ast__AssignStmt).left;
			int _t1223_len = _t1223_orig.len;
			Array_v__ast__Node _t1223 = __new_array(0, _t1223_len, sizeof(v__ast__Node));

			for (int _t1224 = 0; _t1224 < _t1223_len; ++_t1224) {
				v__ast__Expr it = ((v__ast__Expr*) _t1223_orig.data)[_t1224];
				v__ast__Node ti = v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, (it)));
				array_push(&_t1223, &ti);
			}
			
			_PUSH_MANY(&children, (_t1223), _t1222, Array_v__ast__Node);
			Array_v__ast__Expr _t1226_orig = (*(*node._v__ast__Stmt)._v__ast__AssignStmt).right;
			int _t1226_len = _t1226_orig.len;
			Array_v__ast__Node _t1226 = __new_array(0, _t1226_len, sizeof(v__ast__Node));

			for (int _t1227 = 0; _t1227 < _t1226_len; ++_t1227) {
				v__ast__Expr it = ((v__ast__Expr*) _t1226_orig.data)[_t1227];
				v__ast__Node ti = v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, (it)));
				array_push(&_t1226, &ti);
			}
			
			_PUSH_MANY(&children, (_t1226), _t1225, Array_v__ast__Node);
		}
		else if ((*node._v__ast__Stmt)._typ == 305 /* v.ast.Return */) {
			Array_v__ast__Expr _t1229_orig = (*(*node._v__ast__Stmt)._v__ast__Return).exprs;
			int _t1229_len = _t1229_orig.len;
			Array_v__ast__Node _t1229 = __new_array(0, _t1229_len, sizeof(v__ast__Node));

			for (int _t1230 = 0; _t1230 < _t1229_len; ++_t1230) {
				v__ast__Expr it = ((v__ast__Expr*) _t1229_orig.data)[_t1230];
				v__ast__Node ti = v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, (it)));
				array_push(&_t1229, &ti);
			}
			
			 Array_v__ast__Node _t1228 = _t1229;
			// autofree_scope_vars(pos=38798 line_nr=1760 scope.pos=38786 scope.end_pos=38834)
			// var "node" var.pos=38400 var.line_nr=1744
			// af parent scope:
			// var "node" var.pos=38377 var.line_nr=1743
			// af parent scope:
			// var "node" var.pos=36897 var.line_nr=1673
			// var "children" var.pos=36933 var.line_nr=1674
			// af parent scope:
			// af parent scope:
			return _t1228;
		}
		else if ((*node._v__ast__Stmt)._typ == 307 /* v.ast.StructDecl */) {
			Array_v__ast__StructField _t1232_orig = (*(*node._v__ast__Stmt)._v__ast__StructDecl).fields;
			int _t1232_len = _t1232_orig.len;
			Array_v__ast__Node _t1232 = __new_array(0, _t1232_len, sizeof(v__ast__Node));

			for (int _t1233 = 0; _t1233 < _t1232_len; ++_t1233) {
				v__ast__StructField it = ((v__ast__StructField*) _t1232_orig.data)[_t1233];
				v__ast__Node ti = v__ast__StructField_to_sumtype_v__ast__Node(ADDR(v__ast__StructField, (it)));
				array_push(&_t1232, &ti);
			}
			
			 Array_v__ast__Node _t1231 = _t1232;
			// autofree_scope_vars(pos=38918 line_nr=1764 scope.pos=38902 scope.end_pos=38955)
			// var "node" var.pos=38400 var.line_nr=1744
			// af parent scope:
			// var "node" var.pos=38377 var.line_nr=1743
			// af parent scope:
			// var "node" var.pos=36897 var.line_nr=1673
			// var "children" var.pos=36933 var.line_nr=1674
			// af parent scope:
			// af parent scope:
			return _t1231;
		}
		else if ((*node._v__ast__Stmt)._typ == 297 /* v.ast.GlobalDecl */) {
			Array_v__ast__GlobalField _t1235_orig = (*(*node._v__ast__Stmt)._v__ast__GlobalDecl).fields;
			int _t1235_len = _t1235_orig.len;
			Array_v__ast__Node _t1235 = __new_array(0, _t1235_len, sizeof(v__ast__Node));

			for (int _t1236 = 0; _t1236 < _t1235_len; ++_t1236) {
				v__ast__GlobalField it = ((v__ast__GlobalField*) _t1235_orig.data)[_t1236];
				v__ast__Node ti = v__ast__GlobalField_to_sumtype_v__ast__Node(ADDR(v__ast__GlobalField, (it)));
				array_push(&_t1235, &ti);
			}
			
			 Array_v__ast__Node _t1234 = _t1235;
			// autofree_scope_vars(pos=38976 line_nr=1767 scope.pos=38960 scope.end_pos=39013)
			// var "node" var.pos=38400 var.line_nr=1744
			// af parent scope:
			// var "node" var.pos=38377 var.line_nr=1743
			// af parent scope:
			// var "node" var.pos=36897 var.line_nr=1673
			// var "children" var.pos=36933 var.line_nr=1674
			// af parent scope:
			// af parent scope:
			return _t1234;
		}
		else if ((*node._v__ast__Stmt)._typ == 289 /* v.ast.ConstDecl */) {
			Array_v__ast__ConstField _t1238_orig = (*(*node._v__ast__Stmt)._v__ast__ConstDecl).fields;
			int _t1238_len = _t1238_orig.len;
			Array_v__ast__Node _t1238 = __new_array(0, _t1238_len, sizeof(v__ast__Node));

			for (int _t1239 = 0; _t1239 < _t1238_len; ++_t1239) {
				v__ast__ConstField it = ((v__ast__ConstField*) _t1238_orig.data)[_t1239];
				v__ast__Node ti = v__ast__ConstField_to_sumtype_v__ast__Node(ADDR(v__ast__ConstField, (it)));
				array_push(&_t1238, &ti);
			}
			
			 Array_v__ast__Node _t1237 = _t1238;
			// autofree_scope_vars(pos=39033 line_nr=1770 scope.pos=39018 scope.end_pos=39070)
			// var "node" var.pos=38400 var.line_nr=1744
			// af parent scope:
			// var "node" var.pos=38377 var.line_nr=1743
			// af parent scope:
			// var "node" var.pos=36897 var.line_nr=1673
			// var "children" var.pos=36933 var.line_nr=1674
			// af parent scope:
			// af parent scope:
			return _t1237;
		}
		else if ((*node._v__ast__Stmt)._typ == 292 /* v.ast.EnumDecl */) {
			Array_v__ast__EnumField _t1241_orig = (*(*node._v__ast__Stmt)._v__ast__EnumDecl).fields;
			int _t1241_len = _t1241_orig.len;
			Array_v__ast__Node _t1241 = __new_array(0, _t1241_len, sizeof(v__ast__Node));

			for (int _t1242 = 0; _t1242 < _t1241_len; ++_t1242) {
				v__ast__EnumField it = ((v__ast__EnumField*) _t1241_orig.data)[_t1242];
				v__ast__Node ti = v__ast__EnumField_to_sumtype_v__ast__Node(ADDR(v__ast__EnumField, (it)));
				array_push(&_t1241, &ti);
			}
			
			 Array_v__ast__Node _t1240 = _t1241;
			// autofree_scope_vars(pos=39089 line_nr=1773 scope.pos=39075 scope.end_pos=39126)
			// var "node" var.pos=38400 var.line_nr=1744
			// af parent scope:
			// var "node" var.pos=38377 var.line_nr=1743
			// af parent scope:
			// var "node" var.pos=36897 var.line_nr=1673
			// var "children" var.pos=36933 var.line_nr=1674
			// af parent scope:
			// af parent scope:
			return _t1240;
		}
		else if ((*node._v__ast__Stmt)._typ == 175 /* v.ast.FnDecl */) {
			if ((*(*node._v__ast__Stmt)._v__ast__FnDecl).is_method) {
				array_push(&children, _MOV((v__ast__Node[]){ v__ast__StructField_to_sumtype_v__ast__Node(ADDR(v__ast__StructField, ((*(*node._v__ast__Stmt)._v__ast__FnDecl).receiver))) }));
			}
			Array_v__ast__Param _t1245_orig = (*(*node._v__ast__Stmt)._v__ast__FnDecl).params;
			int _t1245_len = _t1245_orig.len;
			Array_v__ast__Node _t1245 = __new_array(0, _t1245_len, sizeof(v__ast__Node));

			for (int _t1246 = 0; _t1246 < _t1245_len; ++_t1246) {
				v__ast__Param it = ((v__ast__Param*) _t1245_orig.data)[_t1246];
				v__ast__Node ti = v__ast__Param_to_sumtype_v__ast__Node(ADDR(v__ast__Param, (it)));
				array_push(&_t1245, &ti);
			}
			
			_PUSH_MANY(&children, (_t1245), _t1244, Array_v__ast__Node);
			Array_v__ast__Stmt _t1248_orig = (*(*node._v__ast__Stmt)._v__ast__FnDecl).stmts;
			int _t1248_len = _t1248_orig.len;
			Array_v__ast__Node _t1248 = __new_array(0, _t1248_len, sizeof(v__ast__Node));

			for (int _t1249 = 0; _t1249 < _t1248_len; ++_t1249) {
				v__ast__Stmt it = ((v__ast__Stmt*) _t1248_orig.data)[_t1249];
				v__ast__Node ti = v__ast__Stmt_to_sumtype_v__ast__Node(ADDR(v__ast__Stmt, (it)));
				array_push(&_t1248, &ti);
			}
			
			_PUSH_MANY(&children, (_t1248), _t1247, Array_v__ast__Node);
		}
		else if ((*node._v__ast__Stmt)._typ == 232 /* v.ast.TypeDecl */) {
			if (((*(*node._v__ast__Stmt)._v__ast__TypeDecl))._typ == 231 /* v.ast.SumTypeDecl */) {
				Array_v__ast__SumTypeVariant _t1251_orig = (*(*(*node._v__ast__Stmt)._v__ast__TypeDecl)._v__ast__SumTypeDecl).variants;
				int _t1251_len = _t1251_orig.len;
				Array_v__ast__Node _t1251 = __new_array(0, _t1251_len, sizeof(v__ast__Node));

				for (int _t1252 = 0; _t1252 < _t1251_len; ++_t1252) {
					v__ast__SumTypeVariant it = ((v__ast__SumTypeVariant*) _t1251_orig.data)[_t1252];
					v__ast__Node ti = v__ast__SumTypeVariant_to_sumtype_v__ast__Node(ADDR(v__ast__SumTypeVariant, (it)));
					array_push(&_t1251, &ti);
				}
				
				_PUSH_MANY(&children, (_t1251), _t1250, Array_v__ast__Node);
			}
		}
		else {
		};
	} else if ((node)._typ == 313 /* v.ast.ScopeObject */) {
		if ((*node._v__ast__ScopeObject)._typ == 311 /* v.ast.GlobalField */) {
			array_push(&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, ((*(*node._v__ast__ScopeObject)._v__ast__GlobalField).expr))) }));
		}
		else if ((*node._v__ast__ScopeObject)._typ == 310 /* v.ast.ConstField */) {
			array_push(&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, ((*(*node._v__ast__ScopeObject)._v__ast__ConstField).expr))) }));
		}
		else if ((*node._v__ast__ScopeObject)._typ == 312 /* v.ast.Var */) {
			array_push(&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, ((*(*node._v__ast__ScopeObject)._v__ast__Var).expr))) }));
		}
		else if ((*node._v__ast__ScopeObject)._typ == 309 /* v.ast.AsmRegister */) {
		};
	} else {
		if (node._typ == 311 /* v.ast.GlobalField */) {
			array_push(&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, ((*node._v__ast__GlobalField).expr))) }));
		}
		else if (node._typ == 310 /* v.ast.ConstField */) {
			array_push(&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, ((*node._v__ast__ConstField).expr))) }));
		}
		else if (node._typ == 316 /* v.ast.EnumField */) {
			array_push(&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, ((*node._v__ast__EnumField).expr))) }));
		}
		else if (node._typ == 322 /* v.ast.StructInitField */) {
			array_push(&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, ((*node._v__ast__StructInitField).expr))) }));
		}
		else if (node._typ == 314 /* v.ast.CallArg */) {
			array_push(&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, ((*node._v__ast__CallArg).expr))) }));
		}
		else if (node._typ == 320 /* v.ast.SelectBranch */) {
			array_push(&children, _MOV((v__ast__Node[]){ v__ast__Stmt_to_sumtype_v__ast__Node(ADDR(v__ast__Stmt, ((*node._v__ast__SelectBranch).stmt))) }));
			Array_v__ast__Stmt _t1263_orig = (*node._v__ast__SelectBranch).stmts;
			int _t1263_len = _t1263_orig.len;
			Array_v__ast__Node _t1263 = __new_array(0, _t1263_len, sizeof(v__ast__Node));

			for (int _t1264 = 0; _t1264 < _t1263_len; ++_t1264) {
				v__ast__Stmt it = ((v__ast__Stmt*) _t1263_orig.data)[_t1264];
				v__ast__Node ti = v__ast__Stmt_to_sumtype_v__ast__Node(ADDR(v__ast__Stmt, (it)));
				array_push(&_t1263, &ti);
			}
			
			_PUSH_MANY(&children, (_t1263), _t1262, Array_v__ast__Node);
		}
		else if (node._typ == 317 /* v.ast.IfBranch */) {
			Array_v__ast__Stmt _t1266_orig = (*node._v__ast__IfBranch).stmts;
			int _t1266_len = _t1266_orig.len;
			Array_v__ast__Node _t1266 = __new_array(0, _t1266_len, sizeof(v__ast__Node));

			for (int _t1267 = 0; _t1267 < _t1266_len; ++_t1267) {
				v__ast__Stmt it = ((v__ast__Stmt*) _t1266_orig.data)[_t1267];
				v__ast__Node ti = v__ast__Stmt_to_sumtype_v__ast__Node(ADDR(v__ast__Stmt, (it)));
				array_push(&_t1266, &ti);
			}
			
			 Array_v__ast__Node _t1265 = _t1266;
			// autofree_scope_vars(pos=39772 line_nr=1804 scope.pos=39752 scope.end_pos=39808)
			// var "node" var.pos=39555 var.line_nr=1795
			// af parent scope:
			// af parent scope:
			// var "node" var.pos=36897 var.line_nr=1673
			// var "children" var.pos=36933 var.line_nr=1674
			// af parent scope:
			// af parent scope:
			return _t1265;
		}
		else if (node._typ == 166 /* v.ast.File */) {
			Array_v__ast__Stmt _t1269_orig = (*node._v__ast__File).stmts;
			int _t1269_len = _t1269_orig.len;
			Array_v__ast__Node _t1269 = __new_array(0, _t1269_len, sizeof(v__ast__Node));

			for (int _t1270 = 0; _t1270 < _t1269_len; ++_t1270) {
				v__ast__Stmt it = ((v__ast__Stmt*) _t1269_orig.data)[_t1270];
				v__ast__Node ti = v__ast__Stmt_to_sumtype_v__ast__Node(ADDR(v__ast__Stmt, (it)));
				array_push(&_t1269, &ti);
			}
			
			 Array_v__ast__Node _t1268 = _t1269;
			// autofree_scope_vars(pos=39772 line_nr=1804 scope.pos=39752 scope.end_pos=39808)
			// var "node" var.pos=39555 var.line_nr=1795
			// af parent scope:
			// af parent scope:
			// var "node" var.pos=36897 var.line_nr=1673
			// var "children" var.pos=36933 var.line_nr=1674
			// af parent scope:
			// af parent scope:
			return _t1268;
		}
		else if (node._typ == 318 /* v.ast.MatchBranch */) {
			Array_v__ast__Stmt _t1272_orig = (*node._v__ast__MatchBranch).stmts;
			int _t1272_len = _t1272_orig.len;
			Array_v__ast__Node _t1272 = __new_array(0, _t1272_len, sizeof(v__ast__Node));

			for (int _t1273 = 0; _t1273 < _t1272_len; ++_t1273) {
				v__ast__Stmt it = ((v__ast__Stmt*) _t1272_orig.data)[_t1273];
				v__ast__Node ti = v__ast__Stmt_to_sumtype_v__ast__Node(ADDR(v__ast__Stmt, (it)));
				array_push(&_t1272, &ti);
			}
			
			_PUSH_MANY(&children, (_t1272), _t1271, Array_v__ast__Node);
			Array_v__ast__Expr _t1275_orig = (*node._v__ast__MatchBranch).exprs;
			int _t1275_len = _t1275_orig.len;
			Array_v__ast__Node _t1275 = __new_array(0, _t1275_len, sizeof(v__ast__Node));

			for (int _t1276 = 0; _t1276 < _t1275_len; ++_t1276) {
				v__ast__Expr it = ((v__ast__Expr*) _t1275_orig.data)[_t1276];
				v__ast__Node ti = v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, (it)));
				array_push(&_t1275, &ti);
			}
			
			_PUSH_MANY(&children, (_t1275), _t1274, Array_v__ast__Node);
		}
		else {
		};
	}
	// autofree_scope_vars(pos=39932 line_nr=1813 scope.pos=36896 scope.end_pos=39949)
	// var "node" var.pos=36897 var.line_nr=1673
	// var "children" var.pos=36933 var.line_nr=1674
	// af parent scope:
	// af parent scope:
	return children;
}

void v__ast__IndexExpr_recursive_mapset_is_setter(v__ast__IndexExpr* lx, bool val) {
	lx->is_setter = val;
	if ((lx->left)._typ == 257 /* v.ast.IndexExpr */) {
		if ((*lx->left._v__ast__IndexExpr).is_map) {
			v__ast__IndexExpr_recursive_mapset_is_setter(&(*lx->left._v__ast__IndexExpr), val);
		}
	}
}

Map_string_v__ast__ScopeObject v__ast__all_registers(v__ast__Table* t, v__pref__Arch arch) {
	Map_string_v__ast__ScopeObject res = new_map(sizeof(string), sizeof(v__ast__ScopeObject), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);

	if (arch == (v__pref__Arch_amd64) || arch == (v__pref__Arch_i386)) {
		// FOR IN map
		int _t1278 = _const_v__ast__x86_no_number_register_list.key_values.len;
		for (int _t1277 = 0; _t1277 < _t1278; ++_t1277 ) {
			int _t1279 = _const_v__ast__x86_no_number_register_list.key_values.len - _t1278;
			_t1278 = _const_v__ast__x86_no_number_register_list.key_values.len;
			if (_t1279 < 0) {
				_t1277 = -1;
				continue;
			}
			if (!DenseArray_has_index(&_const_v__ast__x86_no_number_register_list.key_values, _t1277)) {continue;}
			int bit_size = /*key*/ *(int*)DenseArray_key(&_const_v__ast__x86_no_number_register_list.key_values, _t1277);
			Array_string array = (*(Array_string*)DenseArray_value(&_const_v__ast__x86_no_number_register_list.key_values, _t1277));
			// FOR IN array
			for (int _t1280 = 0; _t1280 < array.len; ++_t1280) {
				string name = ((string*)array.data)[_t1280];
				map_set(&res, &(string[]){name}, &(v__ast__ScopeObject[]) { v__ast__AsmRegister_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__AsmRegister, ((v__ast__AsmRegister){.name = name,.typ = v__ast__Table_bitsize_to_type(t, bit_size),.size = bit_size,}))) });
			}
		}
		// FOR IN map
		int _t1282 = _const_v__ast__x86_with_number_register_list.key_values.len;
		for (int _t1281 = 0; _t1281 < _t1282; ++_t1281 ) {
			int _t1283 = _const_v__ast__x86_with_number_register_list.key_values.len - _t1282;
			_t1282 = _const_v__ast__x86_with_number_register_list.key_values.len;
			if (_t1283 < 0) {
				_t1281 = -1;
				continue;
			}
			if (!DenseArray_has_index(&_const_v__ast__x86_with_number_register_list.key_values, _t1281)) {continue;}
			int bit_size = /*key*/ *(int*)DenseArray_key(&_const_v__ast__x86_with_number_register_list.key_values, _t1281);
			Map_string_int array = (*(Map_string_int*)DenseArray_value(&_const_v__ast__x86_with_number_register_list.key_values, _t1281));
			// FOR IN map
			int _t1285 = array.key_values.len;
			for (int _t1284 = 0; _t1284 < _t1285; ++_t1284 ) {
				int _t1286 = array.key_values.len - _t1285;
				_t1285 = array.key_values.len;
				if (_t1286 < 0) {
					_t1284 = -1;
					continue;
				}
				if (!DenseArray_has_index(&array.key_values, _t1284)) {continue;}
				string name = /*key*/ *(string*)DenseArray_key(&array.key_values, _t1284);
				name = string_clone(name);
				int max_num = (*(int*)DenseArray_value(&array.key_values, _t1284));
				for (int i = 0; i < max_num; ++i) {
					Option_int _t1287 = string_index(name, _SLIT("#"));
					if (_t1287.state != 0) { /*or block*/ 
						IError err = _t1287.err;
						v_panic(_SLIT("all_registers: no hashtag found"));
					}
 					int hash_index =  *(int*)_t1287.data;
					string assembled_name = _STR("%.*s\000%"PRId32"\000%.*s", 3, string_substr(name, 0, hash_index), i, string_substr(name, hash_index + 1, name.len));
					map_set(&res, &(string[]){assembled_name}, &(v__ast__ScopeObject[]) { v__ast__AsmRegister_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__AsmRegister, ((v__ast__AsmRegister){.name = assembled_name,.typ = v__ast__Table_bitsize_to_type(t, bit_size),.size = bit_size,}))) });
				}
			}
		}
	}
	else if (arch == (v__pref__Arch_aarch32)) {
		Map_string_v__ast__ScopeObject aarch32 = v__ast__gen_all_registers(t, _const_v__ast__arm_no_number_register_list, _const_v__ast__arm_with_number_register_list, 32);
		// FOR IN map
		int _t1289 = aarch32.key_values.len;
		for (int _t1288 = 0; _t1288 < _t1289; ++_t1288 ) {
			int _t1290 = aarch32.key_values.len - _t1289;
			_t1289 = aarch32.key_values.len;
			if (_t1290 < 0) {
				_t1288 = -1;
				continue;
			}
			if (!DenseArray_has_index(&aarch32.key_values, _t1288)) {continue;}
			string k = /*key*/ *(string*)DenseArray_key(&aarch32.key_values, _t1288);
			k = string_clone(k);
			v__ast__ScopeObject v = (*(v__ast__ScopeObject*)DenseArray_value(&aarch32.key_values, _t1288));
			map_set(&res, &(string[]){k}, &(v__ast__ScopeObject[]) { v });
		}
	}
	else if (arch == (v__pref__Arch_aarch64)) {
		Map_string_v__ast__ScopeObject aarch64 = v__ast__gen_all_registers(t, _const_v__ast__arm_no_number_register_list, _const_v__ast__arm_with_number_register_list, 64);
		// FOR IN map
		int _t1292 = aarch64.key_values.len;
		for (int _t1291 = 0; _t1291 < _t1292; ++_t1291 ) {
			int _t1293 = aarch64.key_values.len - _t1292;
			_t1292 = aarch64.key_values.len;
			if (_t1293 < 0) {
				_t1291 = -1;
				continue;
			}
			if (!DenseArray_has_index(&aarch64.key_values, _t1291)) {continue;}
			string k = /*key*/ *(string*)DenseArray_key(&aarch64.key_values, _t1291);
			k = string_clone(k);
			v__ast__ScopeObject v = (*(v__ast__ScopeObject*)DenseArray_value(&aarch64.key_values, _t1291));
			map_set(&res, &(string[]){k}, &(v__ast__ScopeObject[]) { v });
		}
	}
	else if (arch == (v__pref__Arch_rv32)) {
		Map_string_v__ast__ScopeObject rv32 = v__ast__gen_all_registers(t, _const_v__ast__riscv_no_number_register_list, _const_v__ast__riscv_with_number_register_list, 32);
		// FOR IN map
		int _t1295 = rv32.key_values.len;
		for (int _t1294 = 0; _t1294 < _t1295; ++_t1294 ) {
			int _t1296 = rv32.key_values.len - _t1295;
			_t1295 = rv32.key_values.len;
			if (_t1296 < 0) {
				_t1294 = -1;
				continue;
			}
			if (!DenseArray_has_index(&rv32.key_values, _t1294)) {continue;}
			string k = /*key*/ *(string*)DenseArray_key(&rv32.key_values, _t1294);
			k = string_clone(k);
			v__ast__ScopeObject v = (*(v__ast__ScopeObject*)DenseArray_value(&rv32.key_values, _t1294));
			map_set(&res, &(string[]){k}, &(v__ast__ScopeObject[]) { v });
		}
	}
	else if (arch == (v__pref__Arch_rv64)) {
		Map_string_v__ast__ScopeObject rv64 = v__ast__gen_all_registers(t, _const_v__ast__riscv_no_number_register_list, _const_v__ast__riscv_with_number_register_list, 64);
		// FOR IN map
		int _t1298 = rv64.key_values.len;
		for (int _t1297 = 0; _t1297 < _t1298; ++_t1297 ) {
			int _t1299 = rv64.key_values.len - _t1298;
			_t1298 = rv64.key_values.len;
			if (_t1299 < 0) {
				_t1297 = -1;
				continue;
			}
			if (!DenseArray_has_index(&rv64.key_values, _t1297)) {continue;}
			string k = /*key*/ *(string*)DenseArray_key(&rv64.key_values, _t1297);
			k = string_clone(k);
			v__ast__ScopeObject v = (*(v__ast__ScopeObject*)DenseArray_value(&rv64.key_values, _t1297));
			map_set(&res, &(string[]){k}, &(v__ast__ScopeObject[]) { v });
		}
	}
	else {
		v_panic(_SLIT("all_registers: unhandled arch"));
	};
	// autofree_scope_vars(pos=41825 line_nr=1889 scope.pos=40257 scope.end_pos=41837)
	// var "t" var.pos=40275 var.line_nr=1827
	// var "arch" var.pos=40284 var.line_nr=1827
	// var "res" var.pos=40330 var.line_nr=1828
	// af parent scope:
	// af parent scope:
	return res;
}

VV_LOCAL_SYMBOL Map_string_v__ast__ScopeObject v__ast__gen_all_registers(v__ast__Table* t, Array_string without_numbers, Map_string_int with_numbers, int bit_size) {
	Map_string_v__ast__ScopeObject res = new_map(sizeof(string), sizeof(v__ast__ScopeObject), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
	// FOR IN array
	for (int _t1300 = 0; _t1300 < without_numbers.len; ++_t1300) {
		string name = ((string*)without_numbers.data)[_t1300];
		map_set(&res, &(string[]){name}, &(v__ast__ScopeObject[]) { v__ast__AsmRegister_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__AsmRegister, ((v__ast__AsmRegister){.name = name,.typ = v__ast__Table_bitsize_to_type(t, bit_size),.size = bit_size,}))) });
	}
	// FOR IN map
	int _t1302 = with_numbers.key_values.len;
	for (int _t1301 = 0; _t1301 < _t1302; ++_t1301 ) {
		int _t1303 = with_numbers.key_values.len - _t1302;
		_t1302 = with_numbers.key_values.len;
		if (_t1303 < 0) {
			_t1301 = -1;
			continue;
		}
		if (!DenseArray_has_index(&with_numbers.key_values, _t1301)) {continue;}
		string name = /*key*/ *(string*)DenseArray_key(&with_numbers.key_values, _t1301);
		name = string_clone(name);
		int max_num = (*(int*)DenseArray_value(&with_numbers.key_values, _t1301));
		for (int i = 0; i < max_num; ++i) {
			Option_int _t1304 = string_index(name, _SLIT("#"));
			if (_t1304.state != 0) { /*or block*/ 
				IError err = _t1304.err;
				v_panic(_SLIT("all_registers: no hashtag found"));
			}
 			int hash_index =  *(int*)_t1304.data;
			string assembled_name = _STR("%.*s\000%"PRId32"\000%.*s", 3, string_substr(name, 0, hash_index), i, string_substr(name, hash_index + 1, name.len));
			map_set(&res, &(string[]){assembled_name}, &(v__ast__ScopeObject[]) { v__ast__AsmRegister_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__AsmRegister, ((v__ast__AsmRegister){.name = assembled_name,.typ = v__ast__Table_bitsize_to_type(t, bit_size),.size = bit_size,}))) });
		}
	}
	// autofree_scope_vars(pos=42553 line_nr=1913 scope.pos=41911 scope.end_pos=42565)
	// var "t" var.pos=41933 var.line_nr=1893
	// var "without_numbers" var.pos=41942 var.line_nr=1893
	// var "with_numbers" var.pos=41968 var.line_nr=1893
	// var "bit_size" var.pos=41997 var.line_nr=1893
	// var "res" var.pos=42041 var.line_nr=1894
	// af parent scope:
	// af parent scope:
	return res;
}

string v__ast__Attr_str(v__ast__Attr attr) {
	string s = _SLIT("");
	if (attr.is_comptime_define) {
		s = /*f*/string_add(s, _SLIT("if "));
	}
	if (attr.is_string) {
		s = /*f*/string_add(s, _STR("'%.*s\000'", 2, attr.name));
	} else {
		s = /*f*/string_add(s, attr.name);
		if (attr.arg.len > 0) {
			s = /*f*/string_add(s, _SLIT(": "));
			if (attr.is_string_arg) {
				string a = string_replace(attr.arg, _SLIT("'"), _SLIT("\\'"));
				s = /*f*/string_add(s, _STR("'%.*s\000'", 2, a));
			} else {
				s = /*f*/string_add(s, attr.arg);
			}
		}
	}
	// autofree_scope_vars(pos=825 line_nr=38 scope.pos=509 scope.end_pos=835)
	// var "attr" var.pos=510 var.line_nr=19
	// var "s" var.pos=541 var.line_nr=20
	// str literal
	// af parent scope:
	// af parent scope:
	return s;
}

bool Array_v__ast__Attr_contains(Array_v__ast__Attr attrs, string str) {
	// FOR IN array
	for (int _t1305 = 0; _t1305 < attrs.len; ++_t1305) {
		v__ast__Attr a = ((v__ast__Attr*)attrs.data)[_t1305];
		if (string_eq(a.name, str)) {
			 bool _t1306 = true;
			// autofree_scope_vars(pos=929 line_nr=44 scope.pos=925 scope.end_pos=944)
			// af parent scope:
			// var "a" var.pos=893 var.line_nr=42
			// skipping tmp var "a"
			// af parent scope:
			// var "attrs" var.pos=846 var.line_nr=41
			// var "str" var.pos=869 var.line_nr=41
			// af parent scope:
			// af parent scope:
			return _t1306;
		}
	}
	 bool _t1307 = false;
	// autofree_scope_vars(pos=949 line_nr=47 scope.pos=845 scope.end_pos=963)
	// var "attrs" var.pos=846 var.line_nr=41
	// var "str" var.pos=869 var.line_nr=41
	// af parent scope:
	// af parent scope:
	return _t1307;
}

multi_return_bool_string Array_v__ast__Attr_has_comptime_define(Array_v__ast__Attr attrs) {
	// FOR IN array
	for (int _t1308 = 0; _t1308 < attrs.len; ++_t1308) {
		v__ast__Attr a = ((v__ast__Attr*)attrs.data)[_t1308];
		if (a.is_comptime_define) {
			return (multi_return_bool_string){.arg0=true, .arg1=a.name};
		}
	}
	return (multi_return_bool_string){.arg0=false, .arg1=_SLIT("")};
}

VV_LOCAL_SYMBOL bool v__ast__Table_has_cflag(v__ast__Table* t, v__cflag__CFlag flag) {
	// FOR IN array
	for (int _t1309 = 0; _t1309 < t->cflags.len; ++_t1309) {
		v__cflag__CFlag cf = ((v__cflag__CFlag*)t->cflags.data)[_t1309];
		if (string_eq(cf.os, flag.os) && string_eq(cf.name, flag.name) && string_eq(cf.value, flag.value)) {
			 bool _t1310 = true;
			// autofree_scope_vars(pos=375 line_nr=11 scope.pos=371 scope.end_pos=390)
			// af parent scope:
			// var "cf" var.pos=282 var.line_nr=9
			// skipping tmp var "cf"
			// af parent scope:
			// var "t" var.pos=232 var.line_nr=8
			// var "flag" var.pos=252 var.line_nr=8
			// af parent scope:
			// af parent scope:
			return _t1310;
		}
	}
	 bool _t1311 = false;
	// autofree_scope_vars(pos=395 line_nr=14 scope.pos=231 scope.end_pos=409)
	// var "t" var.pos=232 var.line_nr=8
	// var "flag" var.pos=252 var.line_nr=8
	// af parent scope:
	// af parent scope:
	return _t1311;
}

Option_bool v__ast__Table_parse_cflag(v__ast__Table* t, string cflg, string mod, Array_string ctimedefines) {
	Array_string allowed_flags = new_array_from_c_array(8, 8, sizeof(string), _MOV((string[8]){_SLIT("framework"), _SLIT("library"), _SLIT("Wa"), _SLIT("Wl"), _SLIT("Wp"), _SLIT("I"), _SLIT("l"), _SLIT("L")}));
	string flag_orig = string_trim_space(cflg);
	string flag = flag_orig;
	if ((flag).len == 0) {
		return (Option_bool){ .state=2, .err=_const_none__ };
	}
	string fos = _SLIT("");
	Array_string allowed_os_overrides = new_array_from_c_array(6, 6, sizeof(string), _MOV((string[6]){_SLIT("linux"), _SLIT("darwin"), _SLIT("freebsd"), _SLIT("windows"), _SLIT("mingw"), _SLIT("solaris")}));
	_PUSH_MANY(&allowed_os_overrides, (ctimedefines), _t1312, Array_string);
	// FOR IN array
	for (int _t1313 = 0; _t1313 < allowed_os_overrides.len; ++_t1313) {
		string os_override = ((string*)allowed_os_overrides.data)[_t1313];
		if (!string_starts_with(flag, os_override)) {
			continue;
		}
		Option_int _t1314 = string_index(flag, _SLIT(" "));
		if (_t1314.state != 0) { /*or block*/ 
			IError err = _t1314.err;
			return (Option_bool){ .state=2, .err=_const_none__ };
		}
 		int pos =  *(int*)_t1314.data;
		fos = string_trim_space(string_substr(flag, 0, pos));
		flag = string_trim_space(string_substr(flag, pos, flag.len));
	}
	for (;;) {
		string name = _SLIT("");
		string value = _SLIT("");
		if (string_at(flag, 0) == L'-') {
			// FOR IN array
			for (int _t1315 = 0; _t1315 < allowed_flags.len; ++_t1315) {
				string f = ((string*)allowed_flags.data)[_t1315];
				int i = 1 + f.len;
				if (i <= flag.len && string_eq(f, string_substr(flag, 1, i))) {
					name = string_trim_space(string_substr(flag, 0, i));
					flag = string_trim_space(string_substr(flag, i, flag.len));
					break;
				}
			}
		}
		Option_int _t1316 = string_index(flag, _SLIT(" -"));
		if (_t1316.state != 0) { /*or block*/ 
			IError err = _t1316.err;
			*(int*) _t1316.data = -1;
		}
 		int index =  *(int*)_t1316.data;
		for (;;) {
			if (!(index > -1)) break;
			bool has_next = false;
			// FOR IN array
			for (int _t1317 = 0; _t1317 < allowed_flags.len; ++_t1317) {
				string f = ((string*)allowed_flags.data)[_t1317];
				int i = index + 2 + f.len;
				if (i <= flag.len && string_eq(f, string_substr(flag, index + 2, i))) {
					value = string_trim_space(string_substr(flag, 0, index + 1));
					flag = string_trim_space(string_substr(flag, index + 1, flag.len));
					has_next = true;
					break;
				}
			}
			if (has_next) {
				break;
			}
			index = string_index_after(flag, _SLIT(" -"), index + 1);
		}
		if (index == -1) {
			value = string_trim_space(flag);
		}
		if (((string_eq(name, _SLIT("-I")) || string_eq(name, _SLIT("-l")) || string_eq(name, _SLIT("-L")))) && (value).len == 0) {
			string hint = (string_eq(name, _SLIT("-l")) ? (_SLIT("library name")) : (_SLIT("path")));
			return (Option_bool){ .state=2, .err=v_error(_STR("bad #flag `%.*s\000`: missing %.*s\000 after `%.*s\000`", 4, flag_orig, hint, name)) };
		}
		v__cflag__CFlag cf = (v__cflag__CFlag){.mod = mod,.os = fos,.name = name,.value = value,.cached = (string){.str=(byteptr)"", .is_lit=1},};
		if (!v__ast__Table_has_cflag(t, cf)) {
			array_push(&t->cflags, _MOV((v__cflag__CFlag[]){ cf }));
		}
		if (index == -1) {
			break;
		}
	}
	Option_bool _t1319;
	opt_ok(&(bool[]) { true }, (Option*)(&_t1319), sizeof(bool));
	// autofree_scope_vars(pos=2149 line_nr=87 scope.pos=497 scope.end_pos=2162)
	// var "t" var.pos=502 var.line_nr=19
	// var "cflg" var.pos=523 var.line_nr=19
	// var "mod" var.pos=536 var.line_nr=19
	// var "ctimedefines" var.pos=548 var.line_nr=19
	// var "allowed_flags" var.pos=580 var.line_nr=20
	// var "flag_orig" var.pos=656 var.line_nr=21
	// var "flag" var.pos=692 var.line_nr=22
	// var "fos" var.pos=749 var.line_nr=26
	// str literal
	// var "allowed_os_overrides" var.pos=764 var.line_nr=27
	// af parent scope:
	// af parent scope:
	return _t1319;
}

v__ast__Expr v__ast__resolve_init(v__ast__StructInit node, v__ast__Type typ, v__ast__Table* t) {
	v__ast__TypeSymbol* type_sym = v__ast__Table_get_type_symbol(t, typ);
	if (type_sym->kind == v__ast__Kind_array) {
		v__ast__Array array_info = /* as */ *(v__ast__Array*)__as_cast((type_sym->info)._v__ast__Array,(type_sym->info)._typ, 395) /*expected idx: 395, name: v.ast.Array */ ;
		bool has_len = false;
		bool has_cap = false;
		bool has_default = false;
		v__ast__Expr len_expr = v__ast__empty_expr();
		v__ast__Expr cap_expr = v__ast__empty_expr();
		v__ast__Expr default_expr = v__ast__empty_expr();
		Array_v__ast__Expr exprs = __new_array_with_default(0, 0, sizeof(v__ast__Expr), 0);
		// FOR IN array
		for (int _t1320 = 0; _t1320 < node.fields.len; ++_t1320) {
			v__ast__StructInitField field = ((v__ast__StructInitField*)node.fields.data)[_t1320];

			if (string_eq(field.name, _SLIT("len"))) {
				has_len = true;
				len_expr = field.expr;
			}
			else if (string_eq(field.name, _SLIT("cap"))) {
				has_cap = true;
				len_expr = field.expr;
			}
			else if (string_eq(field.name, _SLIT("default"))) {
				has_default = true;
				len_expr = field.expr;
			}
			else {
				array_push(&exprs, _MOV((v__ast__Expr[]){ field.expr }));
			};
		}
		 v__ast__Expr _t1322 = v__ast__ArrayInit_to_sumtype_v__ast__Expr(ADDR(v__ast__ArrayInit, ((v__ast__ArrayInit){
			.pos = node.pos,
			.elem_type_pos = {0},
			.exprs = exprs,
			.ecmnts = __new_array(0, 1, sizeof(Array_v__ast__Comment)),
			.pre_cmnts = __new_array(0, 1, sizeof(v__ast__Comment)),
			.is_fixed = 0,
			.has_val = 0,
			.mod = (string){.str=(byteptr)"", .is_lit=1},
			.len_expr = len_expr,
			.cap_expr = cap_expr,
			.default_expr = default_expr,
			.has_len = has_len,
			.has_cap = has_cap,
			.has_default = has_default,
			.expr_types = __new_array(0, 1, sizeof(v__ast__Type)),
			.elem_type = array_info.elem_type,
			.typ = typ,
		})));
		// autofree_scope_vars(pos=681 line_nr=32 scope.pos=140 scope.end_pos=1013)
		// var "array_info" var.pos=144 var.line_nr=5
		// var "has_len" var.pos=187 var.line_nr=6
		// var "has_cap" var.pos=210 var.line_nr=7
		// var "has_default" var.pos=233 var.line_nr=8
		// var "len_expr" var.pos=260 var.line_nr=9
		// var "cap_expr" var.pos=291 var.line_nr=10
		// var "default_expr" var.pos=322 var.line_nr=11
		// var "exprs" var.pos=357 var.line_nr=12
		// af parent scope:
		// var "node" var.pos=32 var.line_nr=2
		// var "typ" var.pos=49 var.line_nr=2
		// var "t" var.pos=59 var.line_nr=2
		// var "type_sym" var.pos=77 var.line_nr=3
		// af parent scope:
		// af parent scope:
		return _t1322;
	} else if (type_sym->kind == v__ast__Kind_map) {
		v__ast__Map map_info = /* as */ *(v__ast__Map*)__as_cast((type_sym->info)._v__ast__Map,(type_sym->info)._typ, 396) /*expected idx: 396, name: v.ast.Map */ ;
		Array_v__ast__Expr keys = __new_array_with_default(0, 0, sizeof(v__ast__Expr), 0);
		Array_v__ast__Expr vals = __new_array_with_default(0, 0, sizeof(v__ast__Expr), 0);
		// FOR IN array
		for (int _t1323 = 0; _t1323 < node.fields.len; ++_t1323) {
			v__ast__StructInitField field = ((v__ast__StructInitField*)node.fields.data)[_t1323];
			array_push(&keys, _MOV((v__ast__Expr[]){ v__ast__StringLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__StringLiteral, ((v__ast__StringLiteral){.val = field.name,.is_raw = 0,.language = 0,.pos = {0},}))) }));
			array_push(&vals, _MOV((v__ast__Expr[]){ field.expr }));
		}
		 v__ast__Expr _t1326 = v__ast__MapInit_to_sumtype_v__ast__Expr(ADDR(v__ast__MapInit, ((v__ast__MapInit){.pos = {0},.keys = keys,.vals = vals,.comments = __new_array(0, 1, sizeof(Array_v__ast__Comment)),.pre_cmnts = __new_array(0, 1, sizeof(v__ast__Comment)),.typ = typ,.key_type = map_info.key_type,.value_type = map_info.value_type,})));
		// autofree_scope_vars(pos=1235 line_nr=56 scope.pos=1045 scope.end_pos=1363)
		// var "map_info" var.pos=1049 var.line_nr=47
		// var "keys" var.pos=1088 var.line_nr=48
		// var "vals" var.pos=1111 var.line_nr=49
		// af parent scope:
		// var "node" var.pos=32 var.line_nr=2
		// var "typ" var.pos=49 var.line_nr=2
		// var "t" var.pos=59 var.line_nr=2
		// var "type_sym" var.pos=77 var.line_nr=3
		// af parent scope:
		// af parent scope:
		return _t1326;
	}
	 v__ast__Expr _t1327 = v__ast__StructInit_to_sumtype_v__ast__Expr(ADDR(v__ast__StructInit, ((v__ast__StructInit){node.pos,node.name_pos,node.is_short,.unresolved = false,node.pre_comments,node.typ,node.update_expr,node.update_expr_type,node.update_expr_comments,node.has_update_expr,node.fields,node.embeds,})));
	// autofree_scope_vars(pos=1395 line_nr=65 scope.pos=19 scope.end_pos=1448)
	// var "node" var.pos=32 var.line_nr=2
	// var "typ" var.pos=49 var.line_nr=2
	// var "t" var.pos=59 var.line_nr=2
	// var "type_sym" var.pos=77 var.line_nr=3
	// af parent scope:
	// af parent scope:
	return _t1327;
}

v__ast__Scope* v__ast__new_scope(v__ast__Scope* parent, int start_pos) {
	 v__ast__Scope* _t1328 = (v__ast__Scope*)memdup(&(v__ast__Scope){.objects = new_map(sizeof(string), sizeof(v__ast__ScopeObject), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.struct_fields = __new_array(0, 1, sizeof(v__ast__ScopeStructField)),.parent = parent,.detached_from_parent = 0,.children = __new_array(0, 1, sizeof(v__ast__Scope*)),.start_pos = start_pos,.end_pos = 0,}, sizeof(v__ast__Scope));
	// autofree_scope_vars(pos=503 line_nr=18 scope.pos=454 scope.end_pos=562)
	// var "parent" var.pos=464 var.line_nr=17
	// var "start_pos" var.pos=479 var.line_nr=17
	// af parent scope:
	// af parent scope:
	return _t1328;
}

VV_LOCAL_SYMBOL bool v__ast__Scope_dont_lookup_parent(v__ast__Scope* s) {
	 bool _t1329 = isnil(s->parent) || s->detached_from_parent;
	// autofree_scope_vars(pos=607 line_nr=25 scope.pos=568 scope.end_pos=657)
	// var "s" var.pos=569 var.line_nr=24
	// af parent scope:
	// af parent scope:
	return _t1329;
}

Option_multi_return_v__ast__ScopeObject_v__ast__Scope v__ast__Scope_find_with_scope(v__ast__Scope* s, string name) {
	v__ast__Scope* sc = s;
	for (;;) {
		if (_IN_MAP(ADDR(string, name), ADDR(map, sc->objects))) {
			Option_multi_return_v__ast__ScopeObject_v__ast__Scope _t1330;
			opt_ok(&(multi_return_v__ast__ScopeObject_v__ast__Scope/*X*/[]) { (multi_return_v__ast__ScopeObject_v__ast__Scope){.arg0=(*(v__ast__ScopeObject*)map_get(ADDR(map, sc->objects), &(string[]){name}, &(v__ast__ScopeObject[]){ {0} })), .arg1=sc} }, (Option*)(&_t1330), sizeof(multi_return_v__ast__ScopeObject_v__ast__Scope));
			return _t1330;
		}
		if (v__ast__Scope_dont_lookup_parent(sc)) {
			break;
		}
		sc = sc->parent;
	}
	return (Option_multi_return_v__ast__ScopeObject_v__ast__Scope){ .state=2, .err=_const_none__ };
}

Option_v__ast__ScopeObject v__ast__Scope_find(v__ast__Scope* s, string name) {
	for (v__ast__Scope* sc = s; true; sc = sc->parent) {
		if (_IN_MAP(ADDR(string, name), ADDR(map, sc->objects))) {
			Option_v__ast__ScopeObject _t1331;
			opt_ok(&(v__ast__ScopeObject[]) { (*(v__ast__ScopeObject*)map_get(ADDR(map, sc->objects), &(string[]){name}, &(v__ast__ScopeObject[]){ {0} })) }, (Option*)(&_t1331), sizeof(v__ast__ScopeObject));
			// autofree_scope_vars(pos=1009 line_nr=45 scope.pos=1005 scope.end_pos=1036)
			// af parent scope:
			// var "sc" var.pos=949 var.line_nr=43
			// af parent scope:
			// var "s" var.pos=901 var.line_nr=42
			// var "name" var.pos=916 var.line_nr=42
			// af parent scope:
			// af parent scope:
			return _t1331;
		}
		if (v__ast__Scope_dont_lookup_parent(sc)) {
			break;
		}
	}
	return (Option_v__ast__ScopeObject){ .state=2, .err=_const_none__ };
}

Option_v__ast__ScopeStructField v__ast__Scope_find_struct_field(v__ast__Scope* s, v__ast__Type struct_type, string field_name) {
	for (v__ast__Scope* sc = s; true; sc = sc->parent) {
		// FOR IN array
		for (int _t1332 = 0; _t1332 < sc->struct_fields.len; ++_t1332) {
			v__ast__ScopeStructField field = ((v__ast__ScopeStructField*)sc->struct_fields.data)[_t1332];
			if (v__ast__Type_alias_eq(field.struct_type, struct_type) && string_eq(field.name, field_name)) {
				Option_v__ast__ScopeStructField _t1333;
				opt_ok(&(v__ast__ScopeStructField[]) { field }, (Option*)(&_t1333), sizeof(v__ast__ScopeStructField));
				// autofree_scope_vars(pos=1337 line_nr=58 scope.pos=1332 scope.end_pos=1354)
				// af parent scope:
				// var "field" var.pos=1237 var.line_nr=56
				// skipping tmp var "field"
				// af parent scope:
				// var "sc" var.pos=1199 var.line_nr=55
				// af parent scope:
				// var "s" var.pos=1109 var.line_nr=54
				// var "struct_type" var.pos=1137 var.line_nr=54
				// var "field_name" var.pos=1155 var.line_nr=54
				// af parent scope:
				// af parent scope:
				return _t1333;
			}
		}
		if (v__ast__Scope_dont_lookup_parent(sc)) {
			break;
		}
	}
	return (Option_v__ast__ScopeStructField){ .state=2, .err=_const_none__ };
}

bool v__ast__Scope_is_known(v__ast__Scope* s, string name) {
	Option_v__ast__ScopeObject _t1334;
	if (_t1334 = v__ast__Scope_find(s, name), _t1334.state == 0) {
		 bool _t1335 = true;
		// autofree_scope_vars(pos=1495 line_nr=70 scope.pos=1492 scope.end_pos=1509)
		// af parent scope:
		// af parent scope:
		// var "s" var.pos=1431 var.line_nr=68
		// var "name" var.pos=1450 var.line_nr=68
		// af parent scope:
		// af parent scope:
		return _t1335;
	} else {
		IError err = _t1334.err;
	}
	 bool _t1336 = false;
	// autofree_scope_vars(pos=1521 line_nr=73 scope.pos=1430 scope.end_pos=1535)
	// var "s" var.pos=1431 var.line_nr=68
	// var "name" var.pos=1450 var.line_nr=68
	// af parent scope:
	// af parent scope:
	return _t1336;
}

Option_v__ast__Var_ptr v__ast__Scope_find_var(v__ast__Scope* s, string name) {
	Option_v__ast__ScopeObject _t1337;
	if (_t1337 = v__ast__Scope_find(s, name), _t1337.state == 0) {
		v__ast__ScopeObject obj = *(v__ast__ScopeObject*)_t1337.data;
		if (obj._typ == 312 /* v.ast.Var */) {
			Option_v__ast__Var_ptr _t1338;
			opt_ok(&(v__ast__Var*[]) { &(*obj._v__ast__Var) }, (Option*)(&_t1338), sizeof(v__ast__Var*));
			// autofree_scope_vars(pos=1634 line_nr=79 scope.pos=1629 scope.end_pos=1647)
			// var "obj" var.pos=1620 var.line_nr=78
			// af parent scope:
			// af parent scope:
			// var "obj" var.pos=1590 var.line_nr=77
			// af parent scope:
			// var "s" var.pos=1546 var.line_nr=76
			// var "name" var.pos=1565 var.line_nr=76
			// af parent scope:
			// af parent scope:
			return _t1338;
		}
		else {
		};
	}
	return (Option_v__ast__Var_ptr){ .state=2, .err=_const_none__ };
}

Option_v__ast__ConstField_ptr v__ast__Scope_find_const(v__ast__Scope* s, string name) {
	Option_v__ast__ScopeObject _t1339;
	if (_t1339 = v__ast__Scope_find(s, name), _t1339.state == 0) {
		v__ast__ScopeObject obj = *(v__ast__ScopeObject*)_t1339.data;
		if (obj._typ == 310 /* v.ast.ConstField */) {
			Option_v__ast__ConstField_ptr _t1340;
			opt_ok(&(v__ast__ConstField*[]) { &(*obj._v__ast__ConstField) }, (Option*)(&_t1340), sizeof(v__ast__ConstField*));
			// autofree_scope_vars(pos=1795 line_nr=89 scope.pos=1783 scope.end_pos=1808)
			// var "obj" var.pos=1774 var.line_nr=88
			// af parent scope:
			// af parent scope:
			// var "obj" var.pos=1744 var.line_nr=87
			// af parent scope:
			// var "s" var.pos=1691 var.line_nr=86
			// var "name" var.pos=1712 var.line_nr=86
			// af parent scope:
			// af parent scope:
			return _t1340;
		}
		else {
		};
	}
	return (Option_v__ast__ConstField_ptr){ .state=2, .err=_const_none__ };
}

bool v__ast__Scope_known_var(v__ast__Scope* s, string name) {
	Option_v__ast__Var_ptr _t1341;
	if (_t1341 = v__ast__Scope_find_var(s, name), _t1341.state == 0) {
		 bool _t1342 = true;
		// autofree_scope_vars(pos=1921 line_nr=98 scope.pos=1918 scope.end_pos=1935)
		// af parent scope:
		// af parent scope:
		// var "s" var.pos=1852 var.line_nr=96
		// var "name" var.pos=1872 var.line_nr=96
		// af parent scope:
		// af parent scope:
		return _t1342;
	}
	 bool _t1343 = false;
	// autofree_scope_vars(pos=1937 line_nr=100 scope.pos=1851 scope.end_pos=1951)
	// var "s" var.pos=1852 var.line_nr=96
	// var "name" var.pos=1872 var.line_nr=96
	// af parent scope:
	// af parent scope:
	return _t1343;
}

void v__ast__Scope_update_var_type(v__ast__Scope* s, string name, v__ast__Type typ) {
	s->end_pos = s->end_pos;
	v__ast__ScopeObject obj = (*(v__ast__ScopeObject*)map_get(ADDR(map, s->objects), &(string[]){name}, &(v__ast__ScopeObject[]){ {0} }));
	if (obj._typ == 312 /* v.ast.Var */) {
		if (v__ast__Type_alias_eq((*obj._v__ast__Var).typ, typ)) {
			return;
		}
		(*obj._v__ast__Var).typ = typ;
	}
	else {
	};
}

void v__ast__Scope_register_struct_field(v__ast__Scope* s, v__ast__ScopeStructField field) {
	// FOR IN array
	for (int _t1344 = 0; _t1344 < s->struct_fields.len; ++_t1344) {
		v__ast__ScopeStructField f = ((v__ast__ScopeStructField*)s->struct_fields.data)[_t1344];
		if (v__ast__Type_alias_eq(f.struct_type, field.struct_type) && string_eq(f.name, field.name)) {
			return;
		}
	}
	array_push(&s->struct_fields, _MOV((v__ast__ScopeStructField[]){ field }));
}

void v__ast__Scope_register(v__ast__Scope* s, v__ast__ScopeObject obj) {
	string name = ((obj)._typ == 310 /* v.ast.ConstField */ ? ((*obj._v__ast__ConstField).name) : (obj)._typ == 311 /* v.ast.GlobalField */ ? ((*obj._v__ast__GlobalField).name) : ((/* as */ *(v__ast__Var*)__as_cast((obj)._v__ast__Var,(obj)._typ, 312) /*expected idx: 312, name: v.ast.Var */ ).name));
	if (string_eq(name, _SLIT("_"))) {
		return;
	}
	if (_IN_MAP(ADDR(string, name), ADDR(map, s->objects))) {
		return;
	}
	map_set(&s->objects, &(string[]){name}, &(v__ast__ScopeObject[]) { obj });
}

v__ast__Scope* v__ast__Scope_outermost(v__ast__Scope* s) {
	v__ast__Scope* sc = s;
	for (;;) {
		if (!(!v__ast__Scope_dont_lookup_parent(sc))) break;
		sc = sc->parent;
	}
	// autofree_scope_vars(pos=2795 line_nr=149 scope.pos=2698 scope.end_pos=2806)
	// var "s" var.pos=2699 var.line_nr=144
	// var "sc" var.pos=2735 var.line_nr=145
	// af parent scope:
	// af parent scope:
	return sc;
}

v__ast__Scope* v__ast__Scope_innermost(v__ast__Scope* s, int pos) {
	if (v__ast__Scope_contains(s, pos)) {
		int first = 0;
		int last = s->children.len - 1;
		int middle = last / 2;
		for (;;) {
			if (!(first <= last)) break;
			v__ast__Scope* s1 = (*(v__ast__Scope**)/*ee elem_typ */array_get(s->children, middle));
			if (s1->end_pos < pos) {
				first = middle + 1;
			} else if (v__ast__Scope_contains(s1, pos)) {
				 v__ast__Scope* _t1346 = v__ast__Scope_innermost(s1, pos);
				// autofree_scope_vars(pos=3268 line_nr=166 scope.pos=3263 scope.end_pos=3297)
				// af parent scope:
				// var "s1" var.pos=3160 var.line_nr=162
				// af parent scope:
				// af parent scope:
				// var "first" var.pos=2998 var.line_nr=157
				// var "last" var.pos=3015 var.line_nr=158
				// var "middle" var.pos=3048 var.line_nr=159
				// af parent scope:
				// var "s" var.pos=2913 var.line_nr=154
				// var "pos" var.pos=2933 var.line_nr=154
				// af parent scope:
				// af parent scope:
				return _t1346;
			} else {
				last = middle - 1;
			}
			middle = (first + last) / 2;
			if (first > last) {
				break;
			}
		}
		// autofree_scope_vars(pos=3405 line_nr=175 scope.pos=2971 scope.end_pos=3416)
		// var "first" var.pos=2998 var.line_nr=157
		// var "last" var.pos=3015 var.line_nr=158
		// var "middle" var.pos=3048 var.line_nr=159
		// af parent scope:
		// var "s" var.pos=2913 var.line_nr=154
		// var "pos" var.pos=2933 var.line_nr=154
		// af parent scope:
		// af parent scope:
		return s;
	}
	// autofree_scope_vars(pos=3434 line_nr=178 scope.pos=2912 scope.end_pos=3444)
	// var "s" var.pos=2913 var.line_nr=154
	// var "pos" var.pos=2933 var.line_nr=154
	// af parent scope:
	// af parent scope:
	return s;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL bool v__ast__Scope_contains(v__ast__Scope* s, int pos) {
	 bool _t1347 = pos >= s->start_pos && pos <= s->end_pos;
	// autofree_scope_vars(pos=3495 line_nr=183 scope.pos=3459 scope.end_pos=3542)
	// var "s" var.pos=3460 var.line_nr=182
	// var "pos" var.pos=3479 var.line_nr=182
	// af parent scope:
	// af parent scope:
	return _t1347;
}

string v__ast__Scope_show(v__ast__Scope sc, int depth, int max_depth) {
	string out = _SLIT("");
	string indent = _SLIT("");
	for (int _t1348 = 0; _t1348 < depth * 4; ++_t1348) {
		indent = /*f*/string_add(indent, _SLIT(" "));
	}
	out = /*f*/string_add(out, _STR("%.*s\000# %"PRId32"\000 - %"PRId32"\000\n", 4, indent, sc.start_pos, sc.end_pos));
	// FOR IN map
	Map_string_v__ast__ScopeObject _t1349 = sc.objects;
	int _t1351 = _t1349.key_values.len;
	for (int _t1350 = 0; _t1350 < _t1351; ++_t1350 ) {
		int _t1352 = _t1349.key_values.len - _t1351;
		_t1351 = _t1349.key_values.len;
		if (_t1352 < 0) {
			_t1350 = -1;
			continue;
		}
		if (!DenseArray_has_index(&_t1349.key_values, _t1350)) {continue;}
		v__ast__ScopeObject obj = (*(v__ast__ScopeObject*)DenseArray_value(&_t1349.key_values, _t1350));
		if (obj._typ == 310 /* v.ast.ConstField */) {
			out = /*f*/string_add(out, _STR("%.*s\000  * const: %.*s\000 - %"PRId32"\000\n", 4, indent, (*obj._v__ast__ConstField).name, (*obj._v__ast__ConstField).typ));
		}
		else if (obj._typ == 312 /* v.ast.Var */) {
			out = /*f*/string_add(out, _STR("%.*s\000  * var: %.*s\000 - %"PRId32"\000\n", 4, indent, (*obj._v__ast__Var).name, (*obj._v__ast__Var).typ));
		}
		else {
		};
	}
	// FOR IN array
	for (int _t1353 = 0; _t1353 < sc.struct_fields.len; ++_t1353) {
		v__ast__ScopeStructField field = ((v__ast__ScopeStructField*)sc.struct_fields.data)[_t1353];
		out = /*f*/string_add(out, _STR("%.*s\000  * struct_field: %"PRId32"\000 %.*s\000 - %"PRId32"\000\n", 5, indent, field.struct_type, field.name, field.typ));
	}
	if (max_depth == 0 || depth < max_depth - 1) {
		// FOR IN array
		for (int i = 0; i < sc.children.len; ++i) {
			out = /*f*/string_add(out, v__ast__Scope_show(/*rec*/*(*(v__ast__Scope**)/*ee elem_typ */array_get(sc.children, i)), depth + 1, max_depth));
		}
	}
	// autofree_scope_vars(pos=4169 line_nr=208 scope.pos=3552 scope.end_pos=4181)
	// var "sc" var.pos=3553 var.line_nr=186
	// var "depth" var.pos=3568 var.line_nr=186
	// var "max_depth" var.pos=3579 var.line_nr=186
	// var "out" var.pos=3608 var.line_nr=187
	// str literal
	// var "indent" var.pos=3623 var.line_nr=188
	// str literal
	// af parent scope:
	// af parent scope:
	return out;
}

string v__ast__Scope_str(v__ast__Scope sc) {
	 string _t1354 = v__ast__Scope_show(sc, 0, 0);
	// autofree_scope_vars(pos=4217 line_nr=212 scope.pos=4191 scope.end_pos=4239)
	// var "sc" var.pos=4192 var.line_nr=211
	// af parent scope:
	// af parent scope:
	return _t1354;
}

string v__ast__FnDecl_modname(v__ast__FnDecl* node) {
	if ((node->mod).len != 0) {
		 string _t1355 = node->mod;
		// autofree_scope_vars(pos=275 line_nr=10 scope.pos=272 scope.end_pos=293)
		// af parent scope:
		// var "node" var.pos=220 var.line_nr=8
		// var "pamod" var.pos=300 var.line_nr=12
		// af parent scope:
		// af parent scope:
		return _t1355;
	}
	string pamod = string_all_before_last(node->name, _SLIT("."));
	if (string_eq(pamod, string_after(node->name, _SLIT(".")))) {
		pamod = (node->is_builtin ? (_SLIT("builtin")) : (_SLIT("main")));
	}
	// autofree_scope_vars(pos=438 line_nr=16 scope.pos=219 scope.end_pos=452)
	// var "node" var.pos=220 var.line_nr=8
	// var "pamod" var.pos=300 var.line_nr=12
	// af parent scope:
	// af parent scope:
	return pamod;
}

string v__ast__FnDecl_stringify(v__ast__FnDecl* node, v__ast__Table* t, string cur_mod, Map_string_string m2a) {
	strings__Builder f = strings__new_builder(30);
	if (node->is_pub) {
		strings__Builder_write_string(&f, _SLIT("pub "));
	}
	string receiver = _SLIT("");
	if (node->is_method) {
		string styp = v__util__no_cur_mod(v__ast__Table_type_to_code(t, v__ast__Type_clear_flag(node->receiver.typ, v__ast__TypeFlag_shared_f)), cur_mod);
		string m = (node->rec_mut ? (string_add(v__ast__ShareType_str(v__ast__Type_share(node->receiver.typ)), _SLIT(" "))) : (_SLIT("")));
		if (node->rec_mut) {
			styp = string_substr(styp, 1, styp.len);
		}
		styp = v__util__no_cur_mod(styp, cur_mod);
		if ((*(v__ast__Param*)/*ee elem_typ */array_get(node->params, 0)).is_auto_rec) {
			styp = string_trim(styp, _SLIT("&"));
		}
		receiver = _STR("(%.*s\000%.*s\000 %.*s\000) ", 4, m, node->receiver.name, styp);
	}
	string name = (node->is_anon ? (_SLIT("")) : (node->name));
	if (!node->is_anon && !node->is_method && node->language == v__ast__Language_v) {
		name = string_all_after_last(node->name, _SLIT("."));
	}
	strings__Builder_write_string(&f, _STR("fn %.*s\000%.*s", 2, receiver, name));
	if ((string_eq(name, _SLIT("+")) || string_eq(name, _SLIT("-")) || string_eq(name, _SLIT("*")) || string_eq(name, _SLIT("/")) || string_eq(name, _SLIT("%")) || string_eq(name, _SLIT("<")) || string_eq(name, _SLIT(">")) || string_eq(name, _SLIT("==")) || string_eq(name, _SLIT("!=")) || string_eq(name, _SLIT(">=")) || string_eq(name, _SLIT("<=")))) {
		strings__Builder_write_string(&f, _SLIT(" "));
	}
	if (node->generic_names.len > 0) {
		strings__Builder_write_string(&f, _SLIT("<"));
		// FOR IN array
		for (int i = 0; i < node->generic_names.len; ++i) {
			string gname = ((string*)node->generic_names.data)[i];
			bool is_last = i == node->generic_names.len - 1;
			strings__Builder_write_string(&f, gname);
			if (!is_last) {
				strings__Builder_write_string(&f, _SLIT(", "));
			}
		}
		strings__Builder_write_string(&f, _SLIT(">"));
	}
	strings__Builder_write_string(&f, _SLIT("("));
	// FOR IN array
	for (int i = 0; i < node->params.len; ++i) {
		v__ast__Param arg = ((v__ast__Param*)node->params.data)[i];
		if (node->is_method && i == 0) {
			continue;
		}
		if (arg.is_hidden) {
			continue;
		}
		bool is_last_arg = i == node->params.len - 1;
		bool is_type_only = (arg.name).len == 0;
		bool should_add_type = true;
		if (arg.is_mut) {
			strings__Builder_write_string(&f, string_add(v__ast__ShareType_str(v__ast__Type_share(arg.typ)), _SLIT(" ")));
		}
		strings__Builder_write_string(&f, arg.name);
		string s = v__ast__Table_type_to_str(t, v__ast__Type_clear_flag(arg.typ, v__ast__TypeFlag_shared_f));
		if (arg.is_mut) {
			if (string_starts_with(s, _SLIT("&"))) {
				s = string_substr(s, 1, s.len);
			}
		}
		s = v__util__no_cur_mod(s, cur_mod);
		// FOR IN map
		int _t1357 = m2a.key_values.len;
		for (int _t1356 = 0; _t1356 < _t1357; ++_t1356 ) {
			int _t1358 = m2a.key_values.len - _t1357;
			_t1357 = m2a.key_values.len;
			if (_t1358 < 0) {
				_t1356 = -1;
				continue;
			}
			if (!DenseArray_has_index(&m2a.key_values, _t1356)) {continue;}
			string mod = /*key*/ *(string*)DenseArray_key(&m2a.key_values, _t1356);
			mod = string_clone(mod);
			string alias = (*(string*)DenseArray_value(&m2a.key_values, _t1356));
			s = string_replace(s, mod, alias);
		}
		if (should_add_type) {
			if (!is_type_only) {
				strings__Builder_write_string(&f, _SLIT(" "));
			}
			if (node->is_variadic && is_last_arg) {
				strings__Builder_write_string(&f, _SLIT("..."));
			}
			strings__Builder_write_string(&f, s);
		}
		if (!is_last_arg) {
			strings__Builder_write_string(&f, _SLIT(", "));
		}
	}
	strings__Builder_write_string(&f, _SLIT(")"));
	if (!v__ast__Type_alias_eq(node->return_type, _const_v__ast__void_type)) {
		string rs = v__util__no_cur_mod(v__ast__Table_type_to_str(t, node->return_type), cur_mod);
		// FOR IN map
		int _t1360 = m2a.key_values.len;
		for (int _t1359 = 0; _t1359 < _t1360; ++_t1359 ) {
			int _t1361 = m2a.key_values.len - _t1360;
			_t1360 = m2a.key_values.len;
			if (_t1361 < 0) {
				_t1359 = -1;
				continue;
			}
			if (!DenseArray_has_index(&m2a.key_values, _t1359)) {continue;}
			string mod = /*key*/ *(string*)DenseArray_key(&m2a.key_values, _t1359);
			mod = string_clone(mod);
			string alias = (*(string*)DenseArray_value(&m2a.key_values, _t1359));
			rs = string_replace(rs, mod, alias);
		}
		strings__Builder_write_string(&f, string_add(_SLIT(" "), rs));
	}
	 string _t1362 = strings__Builder_str(&f);
	// autofree_scope_vars(pos=3344 line_nr=125 scope.pos=527 scope.end_pos=3360)
	// var "node" var.pos=528 var.line_nr=20
	// var "t" var.pos=552 var.line_nr=20
	// var "cur_mod" var.pos=562 var.line_nr=20
	// var "m2a" var.pos=578 var.line_nr=20
	// var "f" var.pos=615 var.line_nr=21
	// var "receiver" var.pos=695 var.line_nr=25
	// str literal
	// var "name" var.pos=1368 var.line_nr=48
	// af parent scope:
	// af parent scope:
	return _t1362;
}

multi_return_string_bool v__ast__StringInterLiteral_get_fspec_braces(v__ast__StringInterLiteral* lit, int i) {
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	bool needs_fspec = (*(bool*)/*ee elem_typ */array_get(lit->need_fmts, i)) || (*(bool*)/*ee elem_typ */array_get(lit->pluss, i)) || ((*(bool*)/*ee elem_typ */array_get(lit->fills, i)) && (*(int*)/*ee elem_typ */array_get(lit->fwidths, i)) >= 0) || (*(int*)/*ee elem_typ */array_get(lit->fwidths, i)) != 0 || (*(int*)/*ee elem_typ */array_get(lit->precisions, i)) != 987698;
	bool needs_braces = needs_fspec;
	if (!needs_braces) {
		if (i + 1 < lit->vals.len && (*(string*)/*ee elem_typ */array_get(lit->vals, i + 1)).len > 0) {
			byte next_char = string_at((*(string*)/*ee elem_typ */array_get(lit->vals, i + 1)), 0);
			if (v__util__is_func_char(next_char) || next_char == L'.' || next_char == L'(') {
				needs_braces = true;
			}
		}
	}
	if (!needs_braces) {
		v__ast__Expr sub_expr = (*(v__ast__Expr*)/*ee elem_typ */array_get(lit->exprs, i));
		for (;;) {
			if (sub_expr._typ == 254 /* v.ast.Ident */) {
				if (string_at((*sub_expr._v__ast__Ident).name, 0) == L'@') {
					needs_braces = true;
				}
				break;
			}
			else if (sub_expr._typ == 241 /* v.ast.CallExpr */) {
				if ((*sub_expr._v__ast__CallExpr).args.len != 0) {
					needs_braces = true;
				} else if (((*sub_expr._v__ast__CallExpr).left)._typ == 241 /* v.ast.CallExpr */) {
					sub_expr = (*sub_expr._v__ast__CallExpr).left;
					continue;
				} else if (((*sub_expr._v__ast__CallExpr).left)._typ == 242 /* v.ast.CastExpr */) {
					needs_braces = true;
				}
				break;
			}
			else if (sub_expr._typ == 273 /* v.ast.SelectorExpr */) {
				if (string_at((*sub_expr._v__ast__SelectorExpr).field_name, 0) == L'@') {
					needs_braces = true;
					break;
				}
				sub_expr = (*sub_expr._v__ast__SelectorExpr).expr;
				continue;
			}
			else {
				needs_braces = true;
				break;
			};
		}
	}
	if (needs_fspec) {
		array_push(&res, _MOV((string[]){ string_clone(_SLIT(":")) }));
		if ((*(bool*)/*ee elem_typ */array_get(lit->pluss, i))) {
			array_push(&res, _MOV((string[]){ string_clone(_SLIT("+")) }));
		}
		if ((*(bool*)/*ee elem_typ */array_get(lit->fills, i)) && (*(int*)/*ee elem_typ */array_get(lit->fwidths, i)) >= 0) {
			array_push(&res, _MOV((string[]){ string_clone(_SLIT("0")) }));
		}
		if ((*(int*)/*ee elem_typ */array_get(lit->fwidths, i)) != 0) {
			array_push(&res, _MOV((string[]){ string_clone(_STR("%"PRId32"", 1, (*(int*)/*ee elem_typ */array_get(lit->fwidths, i)))) }));
		}
		if ((*(int*)/*ee elem_typ */array_get(lit->precisions, i)) != 987698) {
			array_push(&res, _MOV((string[]){ string_clone(_STR(".%"PRId32"", 1, (*(int*)/*ee elem_typ */array_get(lit->precisions, i)))) }));
		}
		if ((*(bool*)/*ee elem_typ */array_get(lit->need_fmts, i))) {
			array_push(&res, _MOV((string[]){ string_clone(_STR("%c", 1, (*(byte*)/*ee elem_typ */array_get(lit->fmts, i)))) }));
		}
	}
	return (multi_return_string_bool){.arg0=Array_string_join(res, _SLIT("")), .arg1=needs_braces};
}

string v__ast__Expr_str(v__ast__Expr x) {
	if (x._typ == 233 /* v.ast.AnonFn */) {
		 string _t1369 = _SLIT("anon_fn");
		// autofree_scope_vars(pos=5476 line_nr=211 scope.pos=5465 scope.end_pos=5496)
		// var "x" var.pos=5459 var.line_nr=209
		// af parent scope:
		// var "x" var.pos=5429 var.line_nr=208
		// af parent scope:
		// af parent scope:
		return _t1369;
	}
	else if (x._typ == 249 /* v.ast.DumpExpr */) {
		 string _t1370 = _STR("dump(%.*s\000)", 2, v__ast__Expr_str((*x._v__ast__DumpExpr).expr));
		// autofree_scope_vars(pos=5513 line_nr=214 scope.pos=5500 scope.end_pos=5545)
		// var "x" var.pos=5459 var.line_nr=209
		// af parent scope:
		// var "x" var.pos=5429 var.line_nr=208
		// af parent scope:
		// af parent scope:
		return _t1370;
	}
	else if (x._typ == 235 /* v.ast.ArrayInit */) {
		Array_string fields = __new_array_with_default(0, 0, sizeof(string), 0);
		if ((*x._v__ast__ArrayInit).has_len) {
			array_push(&fields, _MOV((string[]){ string_clone(_STR("len: %.*s", 1, v__ast__Expr_str((*x._v__ast__ArrayInit).len_expr))) }));
		}
		if ((*x._v__ast__ArrayInit).has_cap) {
			array_push(&fields, _MOV((string[]){ string_clone(_STR("cap: %.*s", 1, v__ast__Expr_str((*x._v__ast__ArrayInit).cap_expr))) }));
		}
		if ((*x._v__ast__ArrayInit).has_default) {
			array_push(&fields, _MOV((string[]){ string_clone(_STR("init: %.*s", 1, v__ast__Expr_str((*x._v__ast__ArrayInit).default_expr))) }));
		}
		if (fields.len > 0) {
			 string _t1374 = _STR("[]T{%.*s\000}", 2, Array_string_join(fields, _SLIT(", ")));
			// autofree_scope_vars(pos=5810 line_nr=228 scope.pos=5805 scope.end_pos=5849)
			// af parent scope:
			// var "fields" var.pos=5568 var.line_nr=217
			// var "x" var.pos=5459 var.line_nr=209
			// af parent scope:
			// var "x" var.pos=5429 var.line_nr=208
			// af parent scope:
			// af parent scope:
			return _t1374;
		} else {
			 string _t1375 = Array_v__ast__Expr_str((*x._v__ast__ArrayInit).exprs);
			// autofree_scope_vars(pos=5861 line_nr=230 scope.pos=5856 scope.end_pos=5886)
			// af parent scope:
			// var "fields" var.pos=5568 var.line_nr=217
			// var "x" var.pos=5459 var.line_nr=209
			// af parent scope:
			// var "x" var.pos=5429 var.line_nr=208
			// af parent scope:
			// af parent scope:
			return _t1375;
		}
	}
	else if (x._typ == 236 /* v.ast.AsCast */) {
		 string _t1376 = _STR("%.*s\000 as Type(%"PRId32"\000)", 3, v__ast__Expr_str((*x._v__ast__AsCast).expr), (*x._v__ast__AsCast).typ);
		// autofree_scope_vars(pos=5905 line_nr=234 scope.pos=5894 scope.end_pos=5947)
		// var "x" var.pos=5459 var.line_nr=209
		// af parent scope:
		// var "x" var.pos=5429 var.line_nr=208
		// af parent scope:
		// af parent scope:
		return _t1376;
	}
	else if (x._typ == 238 /* v.ast.AtExpr */) {
		 string _t1377 = _STR("%.*s", 1, (*x._v__ast__AtExpr).val);
		// autofree_scope_vars(pos=5962 line_nr=237 scope.pos=5951 scope.end_pos=5981)
		// var "x" var.pos=5459 var.line_nr=209
		// af parent scope:
		// var "x" var.pos=5429 var.line_nr=208
		// af parent scope:
		// af parent scope:
		return _t1377;
	}
	else if (x._typ == 240 /* v.ast.CTempVar */) {
		 string _t1378 = v__ast__Expr_str((*x._v__ast__CTempVar).orig);
		// autofree_scope_vars(pos=5998 line_nr=240 scope.pos=5985 scope.end_pos=6021)
		// var "x" var.pos=5459 var.line_nr=209
		// af parent scope:
		// var "x" var.pos=5429 var.line_nr=208
		// af parent scope:
		// af parent scope:
		return _t1378;
	}
	else if (x._typ == 239 /* v.ast.BoolLiteral */) {
		 string _t1379 = bool_str((*x._v__ast__BoolLiteral).val);
		// autofree_scope_vars(pos=6041 line_nr=243 scope.pos=6025 scope.end_pos=6063)
		// var "x" var.pos=5459 var.line_nr=209
		// af parent scope:
		// var "x" var.pos=5429 var.line_nr=208
		// af parent scope:
		// af parent scope:
		return _t1379;
	}
	else if (x._typ == 242 /* v.ast.CastExpr */) {
		 string _t1380 = _STR("%.*s\000(%.*s\000)", 3, (*x._v__ast__CastExpr).typname, v__ast__Expr_str((*x._v__ast__CastExpr).expr));
		// autofree_scope_vars(pos=6080 line_nr=246 scope.pos=6067 scope.end_pos=6120)
		// var "x" var.pos=5459 var.line_nr=209
		// af parent scope:
		// var "x" var.pos=5429 var.line_nr=208
		// af parent scope:
		// af parent scope:
		return _t1380;
	}
	else if (x._typ == 241 /* v.ast.CallExpr */) {
		string sargs = v__ast__args2str((*x._v__ast__CallExpr).args);
		if ((*x._v__ast__CallExpr).is_method) {
			 string _t1381 = _STR("%.*s\000.%.*s\000(%.*s\000)", 4, v__ast__Expr_str((*x._v__ast__CallExpr).left), (*x._v__ast__CallExpr).name, sargs);
			// autofree_scope_vars(pos=6187 line_nr=251 scope.pos=6182 scope.end_pos=6234)
			// af parent scope:
			// var "sargs" var.pos=6138 var.line_nr=249
			// var "x" var.pos=5459 var.line_nr=209
			// af parent scope:
			// var "x" var.pos=5429 var.line_nr=208
			// af parent scope:
			// af parent scope:
			return _t1381;
		}
		if (string_starts_with((*x._v__ast__CallExpr).name, _STR("%.*s\000.", 2, (*x._v__ast__CallExpr).mod))) {
			 string _t1382 = v__util__strip_main_name(_STR("%.*s\000(%.*s\000)", 3, (*x._v__ast__CallExpr).name, sargs));
			// autofree_scope_vars(pos=6279 line_nr=254 scope.pos=6274 scope.end_pos=6332)
			// af parent scope:
			// var "sargs" var.pos=6138 var.line_nr=249
			// var "x" var.pos=5459 var.line_nr=209
			// af parent scope:
			// var "x" var.pos=5429 var.line_nr=208
			// af parent scope:
			// af parent scope:
			return _t1382;
		}
		if (((*x._v__ast__CallExpr).mod).len == 0 && ((*x._v__ast__CallExpr).name).len == 0) {
			 string _t1383 = string_add(v__ast__Expr_str((*x._v__ast__CallExpr).left), _STR("(%.*s\000)", 2, sargs));
			// autofree_scope_vars(pos=6373 line_nr=257 scope.pos=6368 scope.end_pos=6410)
			// af parent scope:
			// var "sargs" var.pos=6138 var.line_nr=249
			// var "x" var.pos=5459 var.line_nr=209
			// af parent scope:
			// var "x" var.pos=5429 var.line_nr=208
			// af parent scope:
			// af parent scope:
			return _t1383;
		}
		 string _t1384 = _STR("%.*s\000.%.*s\000(%.*s\000)", 4, (*x._v__ast__CallExpr).mod, (*x._v__ast__CallExpr).name, sargs);
		// autofree_scope_vars(pos=6414 line_nr=259 scope.pos=6124 scope.end_pos=6453)
		// var "sargs" var.pos=6138 var.line_nr=249
		// var "x" var.pos=5459 var.line_nr=209
		// af parent scope:
		// var "x" var.pos=5429 var.line_nr=208
		// af parent scope:
		// af parent scope:
		return _t1384;
	}
	else if (x._typ == 244 /* v.ast.CharLiteral */) {
		 string _t1385 = _STR("`%.*s\000`", 2, (*x._v__ast__CharLiteral).val);
		// autofree_scope_vars(pos=6473 line_nr=262 scope.pos=6457 scope.end_pos=6494)
		// var "x" var.pos=5459 var.line_nr=209
		// af parent scope:
		// var "x" var.pos=5429 var.line_nr=208
		// af parent scope:
		// af parent scope:
		return _t1385;
	}
	else if (x._typ == 245 /* v.ast.Comment */) {
		if ((*x._v__ast__Comment).is_multi) {
			Array_string lines = string_split_into_lines((*x._v__ast__Comment).text);
			 string _t1386 = _STR("/* %"PRId32"\000 lines comment */", 2, lines.len);
			// autofree_scope_vars(pos=6569 line_nr=267 scope.pos=6525 scope.end_pos=6613)
			// var "lines" var.pos=6531 var.line_nr=266
			// af parent scope:
			// var "x" var.pos=5459 var.line_nr=209
			// af parent scope:
			// var "x" var.pos=5429 var.line_nr=208
			// af parent scope:
			// af parent scope:
			return _t1386;
		} else {
			string text = string_trim_space(string_trim((*x._v__ast__Comment).text, _SLIT("\x01")));
			 string _t1387 = _STR("´// %.*s\000´", 2, text);
			// autofree_scope_vars(pos=6670 line_nr=270 scope.pos=6620 scope.end_pos=6696)
			// var "text" var.pos=6626 var.line_nr=269
			// af parent scope:
			// var "x" var.pos=5459 var.line_nr=209
			// af parent scope:
			// var "x" var.pos=5429 var.line_nr=208
			// af parent scope:
			// af parent scope:
			return _t1387;
		}
	}
	else if (x._typ == 247 /* v.ast.ComptimeSelector */) {
		 string _t1388 = _STR("%.*s\000.$%.*s", 2, v__ast__Expr_str((*x._v__ast__ComptimeSelector).left), v__ast__Expr_str((*x._v__ast__ComptimeSelector).field_expr));
		// autofree_scope_vars(pos=6725 line_nr=274 scope.pos=6704 scope.end_pos=6762)
		// var "x" var.pos=5459 var.line_nr=209
		// af parent scope:
		// var "x" var.pos=5429 var.line_nr=208
		// af parent scope:
		// af parent scope:
		return _t1388;
	}
	else if (x._typ == 251 /* v.ast.EnumVal */) {
		 string _t1389 = _STR(".%.*s", 1, (*x._v__ast__EnumVal).val);
		// autofree_scope_vars(pos=6778 line_nr=277 scope.pos=6766 scope.end_pos=6798)
		// var "x" var.pos=5459 var.line_nr=209
		// af parent scope:
		// var "x" var.pos=5429 var.line_nr=208
		// af parent scope:
		// af parent scope:
		return _t1389;
	}
	else if (x._typ == 252 /* v.ast.FloatLiteral */) {
		 string _t1390 = (*x._v__ast__FloatLiteral).val;
		// autofree_scope_vars(pos=6835 line_nr=280 scope.pos=6802 scope.end_pos=6851)
		// var "x" var.pos=5459 var.line_nr=209
		// af parent scope:
		// var "x" var.pos=5429 var.line_nr=208
		// af parent scope:
		// af parent scope:
		return _t1390;
	}
	else if (x._typ == 259 /* v.ast.IntegerLiteral */) {
		 string _t1391 = (*x._v__ast__IntegerLiteral).val;
		// autofree_scope_vars(pos=6835 line_nr=280 scope.pos=6802 scope.end_pos=6851)
		// var "x" var.pos=5459 var.line_nr=209
		// af parent scope:
		// var "x" var.pos=5429 var.line_nr=208
		// af parent scope:
		// af parent scope:
		return _t1391;
	}
	else if (x._typ == 254 /* v.ast.Ident */) {
		 string _t1392 = (*x._v__ast__Ident).name;
		// autofree_scope_vars(pos=6865 line_nr=283 scope.pos=6855 scope.end_pos=6882)
		// var "x" var.pos=5459 var.line_nr=209
		// af parent scope:
		// var "x" var.pos=5429 var.line_nr=208
		// af parent scope:
		// af parent scope:
		return _t1392;
	}
	else if (x._typ == 257 /* v.ast.IndexExpr */) {
		 string _t1393 = _STR("%.*s\000[%.*s\000]", 3, v__ast__Expr_str((*x._v__ast__IndexExpr).left), v__ast__Expr_str((*x._v__ast__IndexExpr).index));
		// autofree_scope_vars(pos=6900 line_nr=286 scope.pos=6886 scope.end_pos=6942)
		// var "x" var.pos=5459 var.line_nr=209
		// af parent scope:
		// var "x" var.pos=5429 var.line_nr=208
		// af parent scope:
		// af parent scope:
		return _t1393;
	}
	else if (x._typ == 258 /* v.ast.InfixExpr */) {
		 string _t1394 = _STR("%.*s\000 %.*s\000 %.*s", 3, v__ast__Expr_str((*x._v__ast__InfixExpr).left), v__token__Kind_str((*x._v__ast__InfixExpr).op), v__ast__Expr_str((*x._v__ast__InfixExpr).right));
		// autofree_scope_vars(pos=6960 line_nr=289 scope.pos=6946 scope.end_pos=7013)
		// var "x" var.pos=5459 var.line_nr=209
		// af parent scope:
		// var "x" var.pos=5429 var.line_nr=208
		// af parent scope:
		// af parent scope:
		return _t1394;
	}
	else if (x._typ == 262 /* v.ast.MapInit */) {
		Array_string pairs = __new_array_with_default(0, 0, sizeof(string), 0);
		// FOR IN array
		for (int ik = 0; ik < (*x._v__ast__MapInit).keys.len; ++ik) {
			v__ast__Expr kv = ((v__ast__Expr*)(*x._v__ast__MapInit).keys.data)[ik];
			string mv = v__ast__Expr_str((*(v__ast__Expr*)/*ee elem_typ */array_get((*x._v__ast__MapInit).vals, ik)));
			array_push(&pairs, _MOV((string[]){ string_clone(_STR("%.*s\000: %.*s", 2, v__ast__Expr_str(kv), mv)) }));
		}
		 string _t1396 = _STR("map{ %.*s\000 }", 2, Array_string_join(pairs, _SLIT(" ")));
		// autofree_scope_vars(pos=7138 line_nr=297 scope.pos=7017 scope.end_pos=7176)
		// var "pairs" var.pos=7034 var.line_nr=292
		// var "x" var.pos=5459 var.line_nr=209
		// af parent scope:
		// var "x" var.pos=5429 var.line_nr=208
		// af parent scope:
		// af parent scope:
		return _t1396;
	}
	else if (x._typ == 268 /* v.ast.ParExpr */) {
		 string _t1397 = _STR("(%.*s\000)", 2, v__ast__Expr_str((*x._v__ast__ParExpr).expr));
		// autofree_scope_vars(pos=7192 line_nr=300 scope.pos=7180 scope.end_pos=7214)
		// var "x" var.pos=5459 var.line_nr=209
		// af parent scope:
		// var "x" var.pos=5429 var.line_nr=208
		// af parent scope:
		// af parent scope:
		return _t1397;
	}
	else if (x._typ == 270 /* v.ast.PrefixExpr */) {
		 string _t1398 = string_add(v__token__Kind_str((*x._v__ast__PrefixExpr).op), v__ast__Expr_str((*x._v__ast__PrefixExpr).right));
		// autofree_scope_vars(pos=7233 line_nr=303 scope.pos=7218 scope.end_pos=7270)
		// var "x" var.pos=5459 var.line_nr=209
		// af parent scope:
		// var "x" var.pos=5429 var.line_nr=208
		// af parent scope:
		// af parent scope:
		return _t1398;
	}
	else if (x._typ == 271 /* v.ast.RangeExpr */) {
		string s = _SLIT("..");
		if ((*x._v__ast__RangeExpr).has_low) {
			s = string_add(_STR("%.*s\000 ", 2, v__ast__Expr_str((*x._v__ast__RangeExpr).low)), s);
		}
		if ((*x._v__ast__RangeExpr).has_high) {
			s = string_add(s, _STR(" %.*s", 1, v__ast__Expr_str((*x._v__ast__RangeExpr).high)));
		}
		// autofree_scope_vars(pos=7397 line_nr=313 scope.pos=7274 scope.end_pos=7409)
		// var "s" var.pos=7293 var.line_nr=306
		// str literal
		// var "x" var.pos=5459 var.line_nr=209
		// af parent scope:
		// var "x" var.pos=5429 var.line_nr=208
		// af parent scope:
		// af parent scope:
		return s;
	}
	else if (x._typ == 273 /* v.ast.SelectorExpr */) {
		 string _t1399 = _STR("%.*s\000.%.*s", 2, v__ast__Expr_str((*x._v__ast__SelectorExpr).expr), (*x._v__ast__SelectorExpr).field_name);
		// autofree_scope_vars(pos=7430 line_nr=316 scope.pos=7413 scope.end_pos=7472)
		// var "x" var.pos=5459 var.line_nr=209
		// af parent scope:
		// var "x" var.pos=5429 var.line_nr=208
		// af parent scope:
		// af parent scope:
		return _t1399;
	}
	else if (x._typ == 274 /* v.ast.SizeOf */) {
		if ((*x._v__ast__SizeOf).is_type) {
			 string _t1400 = _STR("sizeof(Type(%"PRId32"\000))", 2, (*x._v__ast__SizeOf).typ);
			// autofree_scope_vars(pos=7506 line_nr=320 scope.pos=7501 scope.end_pos=7540)
			// af parent scope:
			// var "x" var.pos=5459 var.line_nr=209
			// af parent scope:
			// var "x" var.pos=5429 var.line_nr=208
			// af parent scope:
			// af parent scope:
			return _t1400;
		}
		 string _t1401 = _STR("sizeof(%.*s\000)", 2, v__ast__Expr_str((*x._v__ast__SizeOf).expr));
		// autofree_scope_vars(pos=7544 line_nr=322 scope.pos=7476 scope.end_pos=7572)
		// var "x" var.pos=5459 var.line_nr=209
		// af parent scope:
		// var "x" var.pos=5429 var.line_nr=208
		// af parent scope:
		// af parent scope:
		return _t1401;
	}
	else if (x._typ == 266 /* v.ast.OffsetOf */) {
		 string _t1402 = _STR("__offsetof(%"PRId32"\000, %.*s\000)", 3, (*x._v__ast__OffsetOf).struct_type, (*x._v__ast__OffsetOf).field);
		// autofree_scope_vars(pos=7589 line_nr=325 scope.pos=7576 scope.end_pos=7638)
		// var "x" var.pos=5459 var.line_nr=209
		// af parent scope:
		// var "x" var.pos=5429 var.line_nr=208
		// af parent scope:
		// af parent scope:
		return _t1402;
	}
	else if (x._typ == 276 /* v.ast.StringInterLiteral */) {
		Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
		array_push(&res, _MOV((string[]){ string_clone(_SLIT("'")) }));
		// FOR IN array
		for (int i = 0; i < (*x._v__ast__StringInterLiteral).vals.len; ++i) {
			string val = ((string*)(*x._v__ast__StringInterLiteral).vals.data)[i];
			array_push(&res, _MOV((string[]){ string_clone(val) }));
			if (i >= (*x._v__ast__StringInterLiteral).exprs.len) {
				break;
			}
			array_push(&res, _MOV((string[]){ string_clone(_SLIT("$")) }));
			multi_return_string_bool mr_7829 = v__ast__StringInterLiteral_get_fspec_braces(&(*x._v__ast__StringInterLiteral), i);
			string fspec_str = mr_7829.arg0;
			bool needs_braces = mr_7829.arg1;
			if (needs_braces) {
				array_push(&res, _MOV((string[]){ string_clone(_SLIT("{")) }));
				array_push(&res, _MOV((string[]){ string_clone(v__ast__Expr_str((*(v__ast__Expr*)/*ee elem_typ */array_get((*x._v__ast__StringInterLiteral).exprs, i)))) }));
				array_push(&res, _MOV((string[]){ string_clone(fspec_str) }));
				array_push(&res, _MOV((string[]){ string_clone(_SLIT("}")) }));
			} else {
				array_push(&res, _MOV((string[]){ string_clone(v__ast__Expr_str((*(v__ast__Expr*)/*ee elem_typ */array_get((*x._v__ast__StringInterLiteral).exprs, i)))) }));
			}
		}
		array_push(&res, _MOV((string[]){ string_clone(_SLIT("'")) }));
		 string _t1412 = Array_string_join(res, _SLIT(""));
		// autofree_scope_vars(pos=8028 line_nr=347 scope.pos=7642 scope.end_pos=8051)
		// var "res" var.pos=7670 var.line_nr=328
		// var "x" var.pos=5459 var.line_nr=209
		// af parent scope:
		// var "x" var.pos=5429 var.line_nr=208
		// af parent scope:
		// af parent scope:
		return _t1412;
	}
	else if (x._typ == 277 /* v.ast.StringLiteral */) {
		 string _t1413 = _STR("'%.*s\000'", 2, (*x._v__ast__StringLiteral).val);
		// autofree_scope_vars(pos=8073 line_nr=350 scope.pos=8055 scope.end_pos=8094)
		// var "x" var.pos=5459 var.line_nr=209
		// af parent scope:
		// var "x" var.pos=5429 var.line_nr=208
		// af parent scope:
		// af parent scope:
		return _t1413;
	}
	else if (x._typ == 279 /* v.ast.TypeNode */) {
		 string _t1414 = _STR("TypeNode(%"PRId32"\000)", 2, (*x._v__ast__TypeNode).typ);
		// autofree_scope_vars(pos=8111 line_nr=353 scope.pos=8098 scope.end_pos=8140)
		// var "x" var.pos=5459 var.line_nr=209
		// af parent scope:
		// var "x" var.pos=5429 var.line_nr=208
		// af parent scope:
		// af parent scope:
		return _t1414;
	}
	else if (x._typ == 280 /* v.ast.TypeOf */) {
		 string _t1415 = _STR("typeof(%.*s\000)", 2, v__ast__Expr_str((*x._v__ast__TypeOf).expr));
		// autofree_scope_vars(pos=8155 line_nr=356 scope.pos=8144 scope.end_pos=8189)
		// var "x" var.pos=5459 var.line_nr=209
		// af parent scope:
		// var "x" var.pos=5429 var.line_nr=208
		// af parent scope:
		// af parent scope:
		return _t1415;
	}
	else if (x._typ == 260 /* v.ast.Likely */) {
		 string _t1416 = _STR("_likely_(%.*s\000)", 2, v__ast__Expr_str((*x._v__ast__Likely).expr));
		// autofree_scope_vars(pos=8204 line_nr=359 scope.pos=8193 scope.end_pos=8240)
		// var "x" var.pos=5459 var.line_nr=209
		// af parent scope:
		// var "x" var.pos=5429 var.line_nr=208
		// af parent scope:
		// af parent scope:
		return _t1416;
	}
	else if (x._typ == 281 /* v.ast.UnsafeExpr */) {
		 string _t1417 = _STR("unsafe { %.*s\000 }", 2, v__ast__Expr_str((*x._v__ast__UnsafeExpr).expr));
		// autofree_scope_vars(pos=8259 line_nr=362 scope.pos=8244 scope.end_pos=8290)
		// var "x" var.pos=5459 var.line_nr=209
		// af parent scope:
		// var "x" var.pos=5429 var.line_nr=208
		// af parent scope:
		// af parent scope:
		return _t1417;
	}
	else if (x._typ == 265 /* v.ast.None */) {
		 string _t1418 = _SLIT("none");
		// autofree_scope_vars(pos=8303 line_nr=365 scope.pos=8294 scope.end_pos=8320)
		// var "x" var.pos=5459 var.line_nr=209
		// af parent scope:
		// var "x" var.pos=5429 var.line_nr=208
		// af parent scope:
		// af parent scope:
		return _t1418;
	}
	else {
	};
	 string _t1419 = _STR("[unhandled expr type %.*s\000]", 2, tos3( /* v.ast.Expr */ v_typeof_sumtype_v__ast__Expr( (x)._typ )));
	// autofree_scope_vars(pos=8335 line_nr=369 scope.pos=5428 scope.end_pos=8382)
	// var "x" var.pos=5429 var.line_nr=208
	// af parent scope:
	// af parent scope:
	return _t1419;
}

string v__ast__CallArg_str(v__ast__CallArg a) {
	if (a.is_mut) {
		 string _t1420 = _STR("mut %.*s", 1, v__ast__Expr_str(a.expr));
		// autofree_scope_vars(pos=8435 line_nr=374 scope.pos=8432 scope.end_pos=8464)
		// af parent scope:
		// var "a" var.pos=8393 var.line_nr=372
		// af parent scope:
		// af parent scope:
		return _t1420;
	}
	 string _t1421 = _STR("%.*s", 1, v__ast__Expr_str(a.expr));
	// autofree_scope_vars(pos=8466 line_nr=376 scope.pos=8392 scope.end_pos=8490)
	// var "a" var.pos=8393 var.line_nr=372
	// af parent scope:
	// af parent scope:
	return _t1421;
}

string v__ast__args2str(Array_v__ast__CallArg args) {
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	// FOR IN array
	for (int _t1422 = 0; _t1422 < args.len; ++_t1422) {
		v__ast__CallArg a = ((v__ast__CallArg*)args.data)[_t1422];
		array_push(&res, _MOV((string[]){ string_clone(v__ast__CallArg_str(a)) }));
	}
	 string _t1424 = Array_string_join(res, _SLIT(", "));
	// autofree_scope_vars(pos=8594 line_nr=384 scope.pos=8500 scope.end_pos=8617)
	// var "args" var.pos=8509 var.line_nr=379
	// var "res" var.pos=8539 var.line_nr=380
	// af parent scope:
	// af parent scope:
	return _t1424;
}

string v__ast__BranchStmt_str(v__ast__BranchStmt* node) {
	string s = _STR("%.*s", 1, v__token__Kind_str(node->kind));
	if (node->label.len > 0) {
		s = /*f*/string_add(s, _STR(" %.*s", 1, node->label));
	}
	// autofree_scope_vars(pos=8734 line_nr=392 scope.pos=8627 scope.end_pos=8744)
	// var "node" var.pos=8628 var.line_nr=387
	// var "s" var.pos=8666 var.line_nr=388
	// af parent scope:
	// af parent scope:
	return s;
}

string v__ast__Stmt_str(v__ast__Stmt node) {
	if (node._typ == 284 /* v.ast.AssertStmt */) {
		 string _t1425 = _STR("assert %.*s", 1, v__ast__Expr_str((*node._v__ast__AssertStmt).expr));
		// autofree_scope_vars(pos=8812 line_nr=398 scope.pos=8797 scope.end_pos=8842)
		// var "node" var.pos=8788 var.line_nr=396
		// af parent scope:
		// var "node" var.pos=8755 var.line_nr=395
		// af parent scope:
		// af parent scope:
		return _t1425;
	}
	else if (node._typ == 285 /* v.ast.AssignStmt */) {
		string out = _SLIT("");
		// FOR IN array
		for (int i = 0; i < (*node._v__ast__AssignStmt).left.len; ++i) {
			v__ast__Expr left = ((v__ast__Expr*)(*node._v__ast__AssignStmt).left.data)[i];
			if ((left)._typ == 254 /* v.ast.Ident */) {
				v__ast__IdentVar var_info = v__ast__Ident_var_info(&(*left._v__ast__Ident));
				if (var_info.is_mut) {
					out = /*f*/string_add(out, _SLIT("mut "));
				}
			}
			out = /*f*/string_add(out, v__ast__Expr_str(left));
			if (i < (*node._v__ast__AssignStmt).left.len - 1) {
				out = /*f*/string_add(out, _SLIT(","));
			}
		}
		out = /*f*/string_add(out, _STR(" %.*s\000 ", 2, v__token__Kind_str((*node._v__ast__AssignStmt).op)));
		// FOR IN array
		for (int i = 0; i < (*node._v__ast__AssignStmt).right.len; ++i) {
			v__ast__Expr val = ((v__ast__Expr*)(*node._v__ast__AssignStmt).right.data)[i];
			out = /*f*/string_add(out, v__ast__Expr_str(val));
			if (i < (*node._v__ast__AssignStmt).right.len - 1) {
				out = /*f*/string_add(out, _SLIT(","));
			}
		}
		// autofree_scope_vars(pos=9242 line_nr=421 scope.pos=8846 scope.end_pos=9256)
		// var "out" var.pos=8866 var.line_nr=401
		// str literal
		// var "node" var.pos=8788 var.line_nr=396
		// af parent scope:
		// var "node" var.pos=8755 var.line_nr=395
		// af parent scope:
		// af parent scope:
		return out;
	}
	else if (node._typ == 287 /* v.ast.BranchStmt */) {
		 string _t1426 = v__ast__BranchStmt_str(&(*node._v__ast__BranchStmt));
		// autofree_scope_vars(pos=9275 line_nr=424 scope.pos=9260 scope.end_pos=9296)
		// var "node" var.pos=8788 var.line_nr=396
		// af parent scope:
		// var "node" var.pos=8755 var.line_nr=395
		// af parent scope:
		// af parent scope:
		return _t1426;
	}
	else if (node._typ == 289 /* v.ast.ConstDecl */) {
		Array_v__ast__ConstField _t1427_orig = (*node._v__ast__ConstDecl).fields;
		int _t1427_len = _t1427_orig.len;
		Array_string _t1427 = __new_array(0, _t1427_len, sizeof(string));

		for (int _t1428 = 0; _t1428 < _t1427_len; ++_t1428) {
			v__ast__ConstField it = ((v__ast__ConstField*) _t1427_orig.data)[_t1428];
			string ti = v__ast__field_to_string(it);
			array_push(&_t1427, &ti);
		}
		
		Array_string fields = _t1427;
		 string _t1429 = _STR("const (%.*s\000)", 2, Array_string_join(fields, _SLIT(" ")));
		// autofree_scope_vars(pos=9360 line_nr=428 scope.pos=9300 scope.end_pos=9400)
		// var "fields" var.pos=9315 var.line_nr=427
		// var "node" var.pos=8788 var.line_nr=396
		// af parent scope:
		// var "node" var.pos=8755 var.line_nr=395
		// af parent scope:
		// af parent scope:
		return _t1429;
	}
	else if (node._typ == 293 /* v.ast.ExprStmt */) {
		 string _t1430 = v__ast__Expr_str((*node._v__ast__ExprStmt).expr);
		// autofree_scope_vars(pos=9417 line_nr=431 scope.pos=9404 scope.end_pos=9443)
		// var "node" var.pos=8788 var.line_nr=396
		// af parent scope:
		// var "node" var.pos=8755 var.line_nr=395
		// af parent scope:
		// af parent scope:
		return _t1430;
	}
	else if (node._typ == 175 /* v.ast.FnDecl */) {
		 string _t1431 = _STR("fn %.*s\000( %"PRId32"\000 params ) { %"PRId32"\000 stmts }", 4, (*node._v__ast__FnDecl).name, (*node._v__ast__FnDecl).params.len, (*node._v__ast__FnDecl).stmts.len);
		// autofree_scope_vars(pos=9458 line_nr=434 scope.pos=9447 scope.end_pos=9539)
		// var "node" var.pos=8788 var.line_nr=396
		// af parent scope:
		// var "node" var.pos=8755 var.line_nr=395
		// af parent scope:
		// af parent scope:
		return _t1431;
	}
	else if (node._typ == 292 /* v.ast.EnumDecl */) {
		 string _t1432 = _STR("enum %.*s\000 { %"PRId32"\000 fields }", 3, (*node._v__ast__EnumDecl).name, (*node._v__ast__EnumDecl).fields.len);
		// autofree_scope_vars(pos=9556 line_nr=437 scope.pos=9543 scope.end_pos=9612)
		// var "node" var.pos=8788 var.line_nr=396
		// af parent scope:
		// var "node" var.pos=8755 var.line_nr=395
		// af parent scope:
		// af parent scope:
		return _t1432;
	}
	else if (node._typ == 304 /* v.ast.Module */) {
		 string _t1433 = _STR("module %.*s", 1, (*node._v__ast__Module).name);
		// autofree_scope_vars(pos=9627 line_nr=440 scope.pos=9616 scope.end_pos=9657)
		// var "node" var.pos=8788 var.line_nr=396
		// af parent scope:
		// var "node" var.pos=8755 var.line_nr=395
		// af parent scope:
		// af parent scope:
		return _t1433;
	}
	else if (node._typ == 302 /* v.ast.Import */) {
		string out = _STR("import %.*s", 1, (*node._v__ast__Import).mod);
		if ((*node._v__ast__Import).alias.len > 0) {
			out = /*f*/string_add(out, _STR(" as %.*s", 1, (*node._v__ast__Import).alias));
		}
		// autofree_scope_vars(pos=9766 line_nr=447 scope.pos=9661 scope.end_pos=9780)
		// var "out" var.pos=9677 var.line_nr=443
		// var "node" var.pos=8788 var.line_nr=396
		// af parent scope:
		// var "node" var.pos=8755 var.line_nr=395
		// af parent scope:
		// af parent scope:
		return out;
	}
	else if (node._typ == 307 /* v.ast.StructDecl */) {
		 string _t1434 = _STR("struct %.*s\000 { %"PRId32"\000 fields }", 3, (*node._v__ast__StructDecl).name, (*node._v__ast__StructDecl).fields.len);
		// autofree_scope_vars(pos=9799 line_nr=450 scope.pos=9784 scope.end_pos=9857)
		// var "node" var.pos=8788 var.line_nr=396
		// af parent scope:
		// var "node" var.pos=8755 var.line_nr=395
		// af parent scope:
		// af parent scope:
		return _t1434;
	}
	else {
		 string _t1435 = _STR("[unhandled stmt str type: %.*s\000 ]", 2, tos3( /* v.ast.Stmt */ v_typeof_sumtype_v__ast__Stmt( (node)._typ )));
		// autofree_scope_vars(pos=9870 line_nr=453 scope.pos=9861 scope.end_pos=9928)
		// af parent scope:
		// var "node" var.pos=8755 var.line_nr=395
		// af parent scope:
		// af parent scope:
		return _t1435;
	};
	return (string){.str=(byteptr)"", .is_lit=1};
}

VV_LOCAL_SYMBOL string v__ast__field_to_string(v__ast__ConstField f) {
	 string _t1436 = _STR("%.*s\000 = %.*s", 2, string_trim_prefix(f.name, string_add(f.mod, _SLIT("."))), v__ast__Expr_str(f.expr));
	// autofree_scope_vars(pos=9978 line_nr=459 scope.pos=9939 scope.end_pos=10033)
	// var "f" var.pos=9955 var.line_nr=458
	// af parent scope:
	// af parent scope:
	return _t1436;
}

string v__ast__CompForKind_str(v__ast__CompForKind e) {

	if (e == (v__ast__CompForKind_methods)) {
		 string _t1437 = _SLIT("methods");
		// autofree_scope_vars(pos=10097 line_nr=464 scope.pos=10087 scope.end_pos=10115)
		// af parent scope:
		// var "e" var.pos=10044 var.line_nr=462
		// af parent scope:
		// af parent scope:
		return _t1437;
	}
	else if (e == (v__ast__CompForKind_fields)) {
		 string _t1438 = _SLIT("fields");
		// autofree_scope_vars(pos=10128 line_nr=465 scope.pos=10119 scope.end_pos=10145)
		// af parent scope:
		// var "e" var.pos=10044 var.line_nr=462
		// af parent scope:
		// af parent scope:
		return _t1438;
	};
	return (string){.str=(byteptr)"", .is_lit=1};
}

VV_LOCAL_SYMBOL bool v__ast__Fn_method_equals(v__ast__Fn* f, v__ast__Fn* o) {
	 bool _t1439 = Array_v__ast__Param_equals(array_slice(f->params, 1, f->params.len), array_slice(o->params, 1, o->params.len)) && v__ast__Type_alias_eq(f->return_type, o->return_type) && f->is_variadic == o->is_variadic && f->language == o->language && Array_string_arr_eq(f->generic_names, o->generic_names) && f->is_pub == o->is_pub && string_eq(f->mod, o->mod) && string_eq(f->name, o->name);
	// autofree_scope_vars(pos=1865 line_nr=52 scope.pos=1829 scope.end_pos=2111)
	// var "f" var.pos=1830 var.line_nr=51
	// var "o" var.pos=1851 var.line_nr=51
	// af parent scope:
	// af parent scope:
	return _t1439;
}

VV_LOCAL_SYMBOL bool v__ast__Param_equals(v__ast__Param* p, v__ast__Param* o) {
	 bool _t1440 = string_eq(p->name, o->name) && p->is_mut == o->is_mut && v__ast__Type_alias_eq(p->typ, o->typ) && p->is_hidden == o->is_hidden;
	// autofree_scope_vars(pos=2350 line_nr=70 scope.pos=2315 scope.end_pos=2447)
	// var "p" var.pos=2316 var.line_nr=69
	// var "o" var.pos=2333 var.line_nr=69
	// af parent scope:
	// af parent scope:
	return _t1440;
}

VV_LOCAL_SYMBOL bool Array_v__ast__Param_equals(Array_v__ast__Param p, Array_v__ast__Param o) {
	if (p.len != o.len) {
		 bool _t1441 = false;
		// autofree_scope_vars(pos=2512 line_nr=75 scope.pos=2509 scope.end_pos=2527)
		// af parent scope:
		// var "p" var.pos=2454 var.line_nr=73
		// var "o" var.pos=2472 var.line_nr=73
		// af parent scope:
		// af parent scope:
		return _t1441;
	}
	for (int i = 0; i < p.len; ++i) {
		if (!v__ast__Param_equals(&(*(v__ast__Param*)/*ee elem_typ */array_get(p, i)), (voidptr)&/*qq*/(*(v__ast__Param*)/*ee elem_typ */array_get(o, i)))) {
			 bool _t1442 = false;
			// autofree_scope_vars(pos=2580 line_nr=79 scope.pos=2576 scope.end_pos=2596)
			// af parent scope:
			// var "i" var.pos=2534 var.line_nr=77
			// skipping tmp var "i"
			// af parent scope:
			// var "p" var.pos=2454 var.line_nr=73
			// var "o" var.pos=2472 var.line_nr=73
			// af parent scope:
			// af parent scope:
			return _t1442;
		}
	}
	 bool _t1443 = true;
	// autofree_scope_vars(pos=2601 line_nr=82 scope.pos=2453 scope.end_pos=2614)
	// var "p" var.pos=2454 var.line_nr=73
	// var "o" var.pos=2472 var.line_nr=73
	// af parent scope:
	// af parent scope:
	return _t1443;
}

v__ast__Table* v__ast__new_table(void) {
	v__ast__Table* t = (v__ast__Table*)memdup(&(v__ast__Table){.type_symbols = __new_array_with_default(0, 64000, sizeof(v__ast__TypeSymbol), 0),.type_idxs = new_map(sizeof(string), sizeof(int), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.fns = new_map(sizeof(string), sizeof(v__ast__Fn), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.dumps = new_map(sizeof(int), sizeof(string), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),.imports = __new_array(0, 1, sizeof(string)),.modules = __new_array(0, 1, sizeof(string)),.cflags = __new_array(0, 1, sizeof(v__cflag__CFlag)),.redefined_fns = __new_array(0, 1, sizeof(string)),.fn_gen_types = new_map(sizeof(string), sizeof(Array_Array_v__ast__Type), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.cmod_prefix = (string){.str=(byteptr)"", .is_lit=1},.is_fmt = 0,.used_fns = new_map(sizeof(string), sizeof(bool), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.used_consts = new_map(sizeof(string), sizeof(bool), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),}, sizeof(v__ast__Table));
	v__ast__Table_register_builtin_type_symbols(t);
	t->is_fmt = true;
	// autofree_scope_vars(pos=2833 line_nr=101 scope.pos=2698 scope.end_pos=2843)
	// var "t" var.pos=2724 var.line_nr=96
	// af parent scope:
	// af parent scope:
	return t;
}

string v__ast__Table_fn_type_signature(v__ast__Table* t, v__ast__Fn* f) {
	string sig = _SLIT("");
	// FOR IN array
	for (int i = 0; i < f->params.len; ++i) {
		v__ast__Param arg = ((v__ast__Param*)f->params.data)[i];
		v__ast__Type typ = v__ast__Type_set_nr_muls(arg.typ, 0);
		v__ast__TypeSymbol* arg_type_sym = v__ast__Table_get_type_symbol(t, typ);
		sig = /*f*/string_add(sig, _STR("%.*s", 1, v__ast__Kind_str(arg_type_sym->kind)));
		if (i < f->params.len - 1) {
			sig = /*f*/string_add(sig, _SLIT("_"));
		}
	}
	if (f->return_type != 0 && !v__ast__Type_alias_eq(f->return_type, _const_v__ast__void_type)) {
		v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(t, f->return_type);
		sig = /*f*/string_add(sig, _STR("__%.*s", 1, v__ast__Kind_str(sym->kind)));
	}
	// autofree_scope_vars(pos=3310 line_nr=120 scope.pos=2900 scope.end_pos=3322)
	// var "t" var.pos=2901 var.line_nr=105
	// var "f" var.pos=2929 var.line_nr=105
	// var "sig" var.pos=2950 var.line_nr=106
	// str literal
	// af parent scope:
	// af parent scope:
	return sig;
}

string v__ast__Table_fn_type_source_signature(v__ast__Table* t, v__ast__Fn* f) {
	string sig = _SLIT("(");
	// FOR IN array
	for (int i = 0; i < f->params.len; ++i) {
		v__ast__Param arg = ((v__ast__Param*)f->params.data)[i];
		if (arg.is_mut) {
			sig = /*f*/string_add(sig, _SLIT("mut "));
		}
		v__ast__TypeSymbol* arg_type_sym = v__ast__Table_get_type_symbol(t, arg.typ);
		sig = /*f*/string_add(sig, _STR("%.*s", 1, arg_type_sym->name));
		if (i < f->params.len - 1) {
			sig = /*f*/string_add(sig, _SLIT(", "));
		}
	}
	sig = /*f*/string_add(sig, _SLIT(")"));
	if (v__ast__Type_alias_eq(f->return_type, _const_v__ast__ovoid_type)) {
		sig = /*f*/string_add(sig, _SLIT(" ?"));
	} else if (!v__ast__Type_alias_eq(f->return_type, _const_v__ast__void_type)) {
		v__ast__TypeSymbol* return_type_sym = v__ast__Table_get_type_symbol(t, f->return_type);
		sig = /*f*/string_add(sig, _STR(" %.*s", 1, return_type_sym->name));
	}
	// autofree_scope_vars(pos=3872 line_nr=143 scope.pos=3423 scope.end_pos=3884)
	// var "t" var.pos=3424 var.line_nr=124
	// var "f" var.pos=3459 var.line_nr=124
	// var "sig" var.pos=3480 var.line_nr=125
	// str literal
	// af parent scope:
	// af parent scope:
	return sig;
}

string v__ast__Table_is_same_method(v__ast__Table* t, v__ast__Fn* f, v__ast__Fn* func) {
	if (!v__ast__Type_alias_eq(f->return_type, func->return_type)) {
		string s = v__ast__Table_type_to_str(t, f->return_type);
		 string _t1444 = _STR("expected return type `%.*s\000`", 2, s);
		// autofree_scope_vars(pos=4023 line_nr=149 scope.pos=3984 scope.end_pos=4060)
		// var "s" var.pos=3988 var.line_nr=148
		// af parent scope:
		// var "t" var.pos=3895 var.line_nr=146
		// var "f" var.pos=3920 var.line_nr=146
		// var "func" var.pos=3927 var.line_nr=146
		// af parent scope:
		// af parent scope:
		return _t1444;
	}
	if (f->params.len != func->params.len) {
		 string _t1445 = _STR("expected %"PRId32"\000 parameter(s), not %"PRId32"", 2, f->params.len, func->params.len);
		// autofree_scope_vars(pos=4101 line_nr=152 scope.pos=4098 scope.end_pos=4170)
		// af parent scope:
		// var "t" var.pos=3895 var.line_nr=146
		// var "f" var.pos=3920 var.line_nr=146
		// var "func" var.pos=3927 var.line_nr=146
		// af parent scope:
		// af parent scope:
		return _t1445;
	}
	for (int i = 1; i < f->params.len; ++i) {
		if (!v__ast__Type_alias_eq((*(v__ast__Param*)/*ee elem_typ */array_get(f->params, i)).typ, (*(v__ast__Param*)/*ee elem_typ */array_get(func->params, i)).typ)) {
			string exps = v__ast__Table_type_to_str(t, (*(v__ast__Param*)/*ee elem_typ */array_get(f->params, i)).typ);
			string gots = v__ast__Table_type_to_str(t, (*(v__ast__Param*)/*ee elem_typ */array_get(func->params, i)).typ);
			 string _t1446 = _STR("expected `%.*s\000`, not `%.*s\000` for parameter %"PRId32"", 3, exps, gots, i);
			// autofree_scope_vars(pos=4336 line_nr=158 scope.pos=4245 scope.end_pos=4395)
			// var "exps" var.pos=4250 var.line_nr=156
			// var "gots" var.pos=4292 var.line_nr=157
			// af parent scope:
			// var "i" var.pos=4177 var.line_nr=154
			// skipping tmp var "i"
			// af parent scope:
			// var "t" var.pos=3895 var.line_nr=146
			// var "f" var.pos=3920 var.line_nr=146
			// var "func" var.pos=3927 var.line_nr=146
			// af parent scope:
			// af parent scope:
			return _t1446;
		}
	}
	 string _t1447 = _SLIT("");
	// autofree_scope_vars(pos=4400 line_nr=161 scope.pos=3894 scope.end_pos=4411)
	// var "t" var.pos=3895 var.line_nr=146
	// var "f" var.pos=3920 var.line_nr=146
	// var "func" var.pos=3927 var.line_nr=146
	// af parent scope:
	// af parent scope:
	return _t1447;
}

Option_v__ast__Fn v__ast__Table_find_fn(v__ast__Table* t, string name) {
	v__ast__Fn f = (*(v__ast__Fn*)map_get(ADDR(map, t->fns), &(string[]){name}, &(v__ast__Fn[]){ (v__ast__Fn){.params = __new_array(0, 1, sizeof(v__ast__Param)),.generic_names = __new_array(0, 1, sizeof(string)),.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),} }));
	if (f.name.str != 0) {
		Option_v__ast__Fn _t1448;
		opt_ok(&(v__ast__Fn[]) { f }, (Option*)(&_t1448), sizeof(v__ast__Fn));
		// autofree_scope_vars(pos=4510 line_nr=168 scope.pos=4497 scope.end_pos=4521)
		// af parent scope:
		// var "t" var.pos=4422 var.line_nr=164
		// var "name" var.pos=4440 var.line_nr=164
		// var "f" var.pos=4460 var.line_nr=165
		// af parent scope:
		// af parent scope:
		return _t1448;
	}
	return (Option_v__ast__Fn){ .state=2, .err=_const_none__ };
}

bool v__ast__Table_known_fn(v__ast__Table* t, string name) {
	Option_v__ast__Fn _t1449 = v__ast__Table_find_fn(t, name);
	if (_t1449.state != 0) { /*or block*/ 
		IError err = _t1449.err;
		 bool _t1450 = false;
		// autofree_scope_vars(pos=4607 line_nr=174 scope.pos=4606 scope.end_pos=4621)
		// var "err" var.pos=4606 var.line_nr=174
		// af parent scope:
		// var "t" var.pos=4547 var.line_nr=173
		// var "name" var.pos=4566 var.line_nr=173
		// af parent scope:
		// af parent scope:
		return _t1450;
	};
	 bool _t1451 = true;
	// autofree_scope_vars(pos=4623 line_nr=175 scope.pos=4546 scope.end_pos=4636)
	// var "t" var.pos=4547 var.line_nr=173
	// var "name" var.pos=4566 var.line_nr=173
	// af parent scope:
	// af parent scope:
	return _t1451;
}

void v__ast__Table_register_fn(v__ast__Table* t, v__ast__Fn new_fn) {
	(*(v__ast__Fn*)map_get_and_set(&t->fns, &(string[]){new_fn.name}, &(v__ast__Fn[]){ (v__ast__Fn){.params = __new_array(0, 1, sizeof(v__ast__Param)),.generic_names = __new_array(0, 1, sizeof(string)),.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),} })) = new_fn;
}

int v__ast__TypeSymbol_register_method(v__ast__TypeSymbol* t, v__ast__Fn new_fn) {
	array_push(&t->methods, _MOV((v__ast__Fn[]){ new_fn }));
	 int _t1453 = t->methods.len - 1;
	// autofree_scope_vars(pos=5024 line_nr=188 scope.pos=4784 scope.end_pos=5050)
	// var "t" var.pos=4789 var.line_nr=183
	// var "new_fn" var.pos=4819 var.line_nr=183
	// af parent scope:
	// af parent scope:
	return _t1453;
}

Option_v__ast__Fn v__ast__Table_register_aggregate_method(v__ast__Table* t, v__ast__TypeSymbol* sym, string name) {
	if (sym->kind != v__ast__Kind_aggregate) {
		v_panic(_STR("Unexpected type symbol: %.*s", 1, v__ast__Kind_str(sym->kind)));
	}
	v__ast__Aggregate agg_info = /* as */ *(v__ast__Aggregate*)__as_cast((sym->info)._v__ast__Aggregate,(sym->info)._typ, 408) /*expected idx: 408, name: v.ast.Aggregate */ ;
	bool found_once = false;
	v__ast__Fn new_fn = (v__ast__Fn){.params = __new_array(0, 1, sizeof(v__ast__Param)),.return_type = 0,.is_variadic = 0,.language = 0,.generic_names = __new_array(0, 1, sizeof(string)),.is_pub = 0,.is_deprecated = 0,.is_unsafe = 0,.is_placeholder = 0,.is_main = 0,.is_test = 0,.is_conditional = 0,.is_keep_alive = 0,.no_body = 0,.mod = (string){.str=(byteptr)"", .is_lit=1},.ctdefine = (string){.str=(byteptr)"", .is_lit=1},.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.name = (string){.str=(byteptr)"", .is_lit=1},.source_fn = 0,.usages = 0,};
	// FOR IN array
	for (int _t1454 = 0; _t1454 < agg_info.types.len; ++_t1454) {
		v__ast__Type typ = ((v__ast__Type*)agg_info.types.data)[_t1454];
		v__ast__TypeSymbol* ts = v__ast__Table_get_type_symbol(t, typ);
		Option_v__ast__Fn _t1455;
		if (_t1455 = v__ast__TypeSymbol_find_method(ts, name), _t1455.state == 0) {
			v__ast__Fn type_method = *(v__ast__Fn*)_t1455.data;
			if (!found_once) {
				found_once = true;
				new_fn = type_method;
			} else if (!v__ast__Fn_method_equals(&new_fn, (voidptr)&/*qq*/type_method)) {
				return (Option_v__ast__Fn){ .state=2, .err=v_error(_STR("method `%.*s\000.%.*s\000` signature is different", 3, v__ast__Table_type_to_str(t, typ), name)) };
			}
		} else {
			IError err = _t1455.err;
			return (Option_v__ast__Fn){ .state=2, .err=v_error(_STR("unknown method: `%.*s\000.%.*s\000`", 3, v__ast__Table_type_to_str(t, typ), name)) };
		}
	}
	v__ast__TypeSymbol_register_method(sym, new_fn);
	Option_v__ast__Fn _t1456;
	opt_ok(&(v__ast__Fn[]) { new_fn }, (Option*)(&_t1456), sizeof(v__ast__Fn));
	// autofree_scope_vars(pos=5827 line_nr=214 scope.pos=5060 scope.end_pos=5842)
	// var "t" var.pos=5061 var.line_nr=191
	// var "sym" var.pos=5101 var.line_nr=191
	// var "name" var.pos=5117 var.line_nr=191
	// var "agg_info" var.pos=5214 var.line_nr=195
	// var "found_once" var.pos=5298 var.line_nr=197
	// var "new_fn" var.pos=5323 var.line_nr=198
	// af parent scope:
	// af parent scope:
	return _t1456;
}

bool v__ast__Table_type_has_method(v__ast__Table* t, v__ast__TypeSymbol* s, string name) {
	Option_v__ast__Fn _t1457;
	if (_t1457 = v__ast__Table_type_find_method(t, s, name), _t1457.state == 0) {
		 bool _t1458 = true;
		// autofree_scope_vars(pos=6051 line_nr=220 scope.pos=6048 scope.end_pos=6065)
		// af parent scope:
		// af parent scope:
		// var "t" var.pos=5853 var.line_nr=217
		// var "s" var.pos=5879 var.line_nr=217
		// var "name" var.pos=5894 var.line_nr=217
		// af parent scope:
		// af parent scope:
		return _t1458;
	}
	 bool _t1459 = false;
	// autofree_scope_vars(pos=6067 line_nr=222 scope.pos=5852 scope.end_pos=6081)
	// var "t" var.pos=5853 var.line_nr=217
	// var "s" var.pos=5879 var.line_nr=217
	// var "name" var.pos=5894 var.line_nr=217
	// af parent scope:
	// af parent scope:
	return _t1459;
}

Option_v__ast__Fn v__ast__Table_type_find_method(v__ast__Table* t, v__ast__TypeSymbol* s, string name) {
	v__ast__TypeSymbol* ts = s;
	for (;;) {
		Option_v__ast__Fn _t1460;
		if (_t1460 = v__ast__TypeSymbol_find_method(ts, name), _t1460.state == 0) {
			v__ast__Fn method = *(v__ast__Fn*)_t1460.data;
			Option_v__ast__Fn _t1461;
			opt_ok(&(v__ast__Fn[]) { method }, (Option*)(&_t1461), sizeof(v__ast__Fn));
			// autofree_scope_vars(pos=6381 line_nr=231 scope.pos=6377 scope.end_pos=6398)
			// af parent scope:
			// var "method" var.pos=6346 var.line_nr=230
			// af parent scope:
			// af parent scope:
			// var "t" var.pos=6162 var.line_nr=226
			// var "s" var.pos=6189 var.line_nr=226
			// var "name" var.pos=6204 var.line_nr=226
			// var "ts" var.pos=6326 var.line_nr=228
			// af parent scope:
			// af parent scope:
			return _t1461;
		}
		if (ts->kind == v__ast__Kind_aggregate) {
			Option_v__ast__Fn _t1462 = v__ast__Table_register_aggregate_method(t, ts, name);
			if (_t1462.state != 0) { /*or block*/ 
				Option_v__ast__Fn _t1463;
				memcpy(&_t1463, &_t1462, sizeof(Option));
				return _t1463;
			}
 			v__ast__Fn method =  *(v__ast__Fn*)_t1462.data;
			Option_v__ast__Fn _t1464;
			opt_ok(&(v__ast__Fn[]) { method }, (Option*)(&_t1464), sizeof(v__ast__Fn));
			// autofree_scope_vars(pos=6488 line_nr=235 scope.pos=6427 scope.end_pos=6505)
			// var "method" var.pos=6432 var.line_nr=234
			// af parent scope:
			// af parent scope:
			// var "t" var.pos=6162 var.line_nr=226
			// var "s" var.pos=6189 var.line_nr=226
			// var "name" var.pos=6204 var.line_nr=226
			// var "ts" var.pos=6326 var.line_nr=228
			// af parent scope:
			// af parent scope:
			return _t1464;
		}
		if (ts->parent_idx == 0) {
			break;
		}
		ts = &(*(v__ast__TypeSymbol*)/*ee elem_typ */array_get(t->type_symbols, ts->parent_idx));
	}
	return (Option_v__ast__Fn){ .state=2, .err=_const_none__ };
}

VV_LOCAL_SYMBOL Option_v__ast__StructField v__ast__Table_register_aggregate_field(v__ast__Table* t, v__ast__TypeSymbol* sym, string name) {
	if (sym->kind != v__ast__Kind_aggregate) {
		v_panic(_STR("Unexpected type symbol: %.*s", 1, v__ast__Kind_str(sym->kind)));
	}
	v__ast__Aggregate agg_info = /* as */ *(v__ast__Aggregate*)__as_cast((sym->info)._v__ast__Aggregate,(sym->info)._typ, 408) /*expected idx: 408, name: v.ast.Aggregate */ ;
	bool found_once = false;
	v__ast__StructField new_field = (v__ast__StructField){.pos = {0},.type_pos = {0},.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.default_expr = {0},.has_default_expr = 0,.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.is_pub = 0,.default_val = (string){.str=(byteptr)"", .is_lit=1},.is_mut = 0,.is_global = 0,.default_expr_typ = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,};
	// FOR IN array
	for (int _t1465 = 0; _t1465 < agg_info.types.len; ++_t1465) {
		v__ast__Type typ = ((v__ast__Type*)agg_info.types.data)[_t1465];
		v__ast__TypeSymbol* ts = v__ast__Table_get_type_symbol(t, typ);
		Option_v__ast__StructField _t1466;
		if (_t1466 = v__ast__Table_find_field(t, ts, name), _t1466.state == 0) {
			v__ast__StructField type_field = *(v__ast__StructField*)_t1466.data;
			if (!found_once) {
				found_once = true;
				new_field = type_field;
			} else if (!v__ast__StructField_equals(&new_field, (voidptr)&/*qq*/type_field)) {
				return (Option_v__ast__StructField){ .state=2, .err=v_error(_STR("field `%.*s\000.%.*s\000` type is different", 3, v__ast__Table_type_to_str(t, typ), name)) };
			}
		} else {
			IError err = _t1466.err;
			return (Option_v__ast__StructField){ .state=2, .err=v_error(_STR("type `%.*s\000` has no field or method `%.*s\000`", 3, v__ast__Table_type_to_str(t, typ), name)) };
		}
	}
	array_push(&agg_info.fields, _MOV((v__ast__StructField[]){ new_field }));
	Option_v__ast__StructField _t1468;
	opt_ok(&(v__ast__StructField[]) { new_field }, (Option*)(&_t1468), sizeof(v__ast__StructField));
	// autofree_scope_vars(pos=7381 line_nr=269 scope.pos=6617 scope.end_pos=7399)
	// var "t" var.pos=6618 var.line_nr=245
	// var "sym" var.pos=6657 var.line_nr=245
	// var "name" var.pos=6673 var.line_nr=245
	// var "agg_info" var.pos=6783 var.line_nr=249
	// var "found_once" var.pos=6867 var.line_nr=251
	// var "new_field" var.pos=6892 var.line_nr=252
	// af parent scope:
	// af parent scope:
	return _t1468;
}

bool v__ast__Table_struct_has_field(v__ast__Table* t, v__ast__TypeSymbol* s, string name) {
	Option_v__ast__StructField _t1469;
	if (_t1469 = v__ast__Table_find_field(t, s, name), _t1469.state == 0) {
		 bool _t1470 = true;
		// autofree_scope_vars(pos=7604 line_nr=275 scope.pos=7601 scope.end_pos=7618)
		// af parent scope:
		// af parent scope:
		// var "t" var.pos=7410 var.line_nr=272
		// var "s" var.pos=7437 var.line_nr=272
		// var "name" var.pos=7452 var.line_nr=272
		// af parent scope:
		// af parent scope:
		return _t1470;
	}
	 bool _t1471 = false;
	// autofree_scope_vars(pos=7620 line_nr=277 scope.pos=7409 scope.end_pos=7634)
	// var "t" var.pos=7410 var.line_nr=272
	// var "s" var.pos=7437 var.line_nr=272
	// var "name" var.pos=7452 var.line_nr=272
	// af parent scope:
	// af parent scope:
	return _t1471;
}

Option_v__ast__StructField v__ast__Table_find_field(v__ast__Table* t, v__ast__TypeSymbol* s, string name) {
	v__ast__TypeSymbol* ts = s;
	for (;;) {
		if (ts->info._typ == 409 /* v.ast.Struct */) {
			Option_v__ast__StructField _t1472;
			if (_t1472 = v__ast__Struct_find_field(&(*ts->info._v__ast__Struct), name), _t1472.state == 0) {
				v__ast__StructField field = *(v__ast__StructField*)_t1472.data;
				Option_v__ast__StructField _t1473;
				opt_ok(&(v__ast__StructField[]) { field }, (Option*)(&_t1473), sizeof(v__ast__StructField));
				// autofree_scope_vars(pos=7971 line_nr=288 scope.pos=7965 scope.end_pos=7989)
				// af parent scope:
				// var "field" var.pos=7931 var.line_nr=287
				// af parent scope:
				// af parent scope:
				// af parent scope:
				// var "t" var.pos=7714 var.line_nr=281
				// var "s" var.pos=7735 var.line_nr=281
				// var "name" var.pos=7750 var.line_nr=281
				// var "ts" var.pos=7875 var.line_nr=283
				// af parent scope:
				// af parent scope:
				return _t1473;
			}
		}
		else if (ts->info._typ == 408 /* v.ast.Aggregate */) {
			Option_v__ast__StructField _t1474;
			if (_t1474 = v__ast__Aggregate_find_field(&(*ts->info._v__ast__Aggregate), name), _t1474.state == 0) {
				v__ast__StructField field = *(v__ast__StructField*)_t1474.data;
				Option_v__ast__StructField _t1475;
				opt_ok(&(v__ast__StructField[]) { field }, (Option*)(&_t1475), sizeof(v__ast__StructField));
				// autofree_scope_vars(pos=8058 line_nr=293 scope.pos=8052 scope.end_pos=8076)
				// af parent scope:
				// var "field" var.pos=8018 var.line_nr=292
				// af parent scope:
				// var "field" var.pos=8082 var.line_nr=295
				// af parent scope:
				// af parent scope:
				// var "t" var.pos=7714 var.line_nr=281
				// var "s" var.pos=7735 var.line_nr=281
				// var "name" var.pos=7750 var.line_nr=281
				// var "ts" var.pos=7875 var.line_nr=283
				// af parent scope:
				// af parent scope:
				return _t1475;
			}
			Option_v__ast__StructField _t1476 = v__ast__Table_register_aggregate_field(t, ts, name);
			if (_t1476.state != 0) { /*or block*/ 
				IError err = _t1476.err;
				return (Option_v__ast__StructField){ .state=2, .err=err };
			}
 			v__ast__StructField field =  *(v__ast__StructField*)_t1476.data;
			Option_v__ast__StructField _t1477;
			opt_ok(&(v__ast__StructField[]) { field }, (Option*)(&_t1477), sizeof(v__ast__StructField));
			// autofree_scope_vars(pos=8153 line_nr=296 scope.pos=7999 scope.end_pos=8170)
			// var "field" var.pos=8082 var.line_nr=295
			// af parent scope:
			// af parent scope:
			// var "t" var.pos=7714 var.line_nr=281
			// var "s" var.pos=7735 var.line_nr=281
			// var "name" var.pos=7750 var.line_nr=281
			// var "ts" var.pos=7875 var.line_nr=283
			// af parent scope:
			// af parent scope:
			return _t1477;
		}
		else if (ts->info._typ == 410 /* v.ast.Interface */) {
			Option_v__ast__StructField _t1478;
			if (_t1478 = v__ast__Interface_find_field(&(*ts->info._v__ast__Interface), name), _t1478.state == 0) {
				v__ast__StructField field = *(v__ast__StructField*)_t1478.data;
				Option_v__ast__StructField _t1479;
				opt_ok(&(v__ast__StructField[]) { field }, (Option*)(&_t1479), sizeof(v__ast__StructField));
				// autofree_scope_vars(pos=8234 line_nr=300 scope.pos=8228 scope.end_pos=8252)
				// af parent scope:
				// var "field" var.pos=8194 var.line_nr=299
				// af parent scope:
				// af parent scope:
				// af parent scope:
				// var "t" var.pos=7714 var.line_nr=281
				// var "s" var.pos=7735 var.line_nr=281
				// var "name" var.pos=7750 var.line_nr=281
				// var "ts" var.pos=7875 var.line_nr=283
				// af parent scope:
				// af parent scope:
				return _t1479;
			}
		}
		else if (ts->info._typ == 411 /* v.ast.SumType */) {
			v__ast__Table_resolve_common_sumtype_fields(t, s);
			Option_v__ast__StructField _t1480;
			if (_t1480 = v__ast__SumType_find_field(&(*ts->info._v__ast__SumType), name), _t1480.state == 0) {
				v__ast__StructField field = *(v__ast__StructField*)_t1480.data;
				Option_v__ast__StructField _t1481;
				opt_ok(&(v__ast__StructField[]) { field }, (Option*)(&_t1481), sizeof(v__ast__StructField));
				// autofree_scope_vars(pos=8358 line_nr=306 scope.pos=8352 scope.end_pos=8376)
				// af parent scope:
				// var "field" var.pos=8318 var.line_nr=305
				// af parent scope:
				// af parent scope:
				// af parent scope:
				// var "t" var.pos=7714 var.line_nr=281
				// var "s" var.pos=7735 var.line_nr=281
				// var "name" var.pos=7750 var.line_nr=281
				// var "ts" var.pos=7875 var.line_nr=283
				// af parent scope:
				// af parent scope:
				return _t1481;
			}
			return (Option_v__ast__StructField){ .state=2, .err=v_error(_STR("field `%.*s\000` does not exist or have the same type in all sumtype variants", 2, name)) };
		}
		else {
		};
		if (ts->parent_idx == 0) {
			break;
		}
		ts = &(*(v__ast__TypeSymbol*)/*ee elem_typ */array_get(t->type_symbols, ts->parent_idx));
	}
	return (Option_v__ast__StructField){ .state=2, .err=_const_none__ };
}

Option_v__ast__StructField v__ast__Table_find_field_with_embeds(v__ast__Table* t, v__ast__TypeSymbol* sym, string field_name) {
	Option_v__ast__StructField _t1482;
	if (_t1482 = v__ast__Table_find_field(t, sym, field_name), _t1482.state == 0) {
		v__ast__StructField f = *(v__ast__StructField*)_t1482.data;
		Option_v__ast__StructField _t1483;
		opt_ok(&(v__ast__StructField[]) { f }, (Option*)(&_t1483), sizeof(v__ast__StructField));
		// autofree_scope_vars(pos=8795 line_nr=323 scope.pos=8792 scope.end_pos=8806)
		// af parent scope:
		// var "f" var.pos=8757 var.line_nr=322
		// af parent scope:
		// var "t" var.pos=8669 var.line_nr=321
		// var "sym" var.pos=8702 var.line_nr=321
		// var "field_name" var.pos=8719 var.line_nr=321
		// af parent scope:
		// af parent scope:
		return _t1483;
	} else {
		IError err = _t1482.err;
		if ((sym->info)._typ == 409 /* v.ast.Struct */) {
			Array_v__ast__StructField found_fields = __new_array_with_default(0, 0, sizeof(v__ast__StructField), 0);
			Array_v__ast__Type embed_of_found_fields = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
			// FOR IN array
			for (int _t1484 = 0; _t1484 < (*sym->info._v__ast__Struct).embeds.len; ++_t1484) {
				v__ast__Type embed = ((v__ast__Type*)(*sym->info._v__ast__Struct).embeds.data)[_t1484];
				v__ast__TypeSymbol* embed_sym = v__ast__Table_get_type_symbol(t, embed);
				Option_v__ast__StructField _t1485;
				if (_t1485 = v__ast__Table_find_field(t, embed_sym, field_name), _t1485.state == 0) {
					v__ast__StructField f = *(v__ast__StructField*)_t1485.data;
					array_push(&found_fields, _MOV((v__ast__StructField[]){ f }));
					array_push(&embed_of_found_fields, _MOV((v__ast__Type[]){ embed }));
				}
			}
			if (found_fields.len == 1) {
				Option_v__ast__StructField _t1488;
				opt_ok(&(v__ast__StructField[]) { (*(v__ast__StructField*)/*ee elem_typ */array_get(found_fields, 0)) }, (Option*)(&_t1488), sizeof(v__ast__StructField));
				// autofree_scope_vars(pos=9179 line_nr=337 scope.pos=9174 scope.end_pos=9206)
				// af parent scope:
				// var "found_fields" var.pos=8877 var.line_nr=327
				// var "embed_of_found_fields" var.pos=8916 var.line_nr=328
				// af parent scope:
				// var "err" var.pos=8813 var.line_nr=324
				// af parent scope:
				// var "t" var.pos=8669 var.line_nr=321
				// var "sym" var.pos=8702 var.line_nr=321
				// var "field_name" var.pos=8719 var.line_nr=321
				// af parent scope:
				// af parent scope:
				return _t1488;
			} else if (found_fields.len > 1) {
				return (Option_v__ast__StructField){ .state=2, .err=v_error(_STR("ambiguous field `%.*s\000`", 2, field_name)) };
			}
		}
		return (Option_v__ast__StructField){ .state=2, .err=err };
	}
	return (Option_v__ast__StructField){0};
}

void v__ast__Table_resolve_common_sumtype_fields(v__ast__Table* t, v__ast__TypeSymbol* sym_) {
	v__ast__TypeSymbol* sym = sym_;
	v__ast__SumType info = /* as */ *(v__ast__SumType*)__as_cast((sym->info)._v__ast__SumType,(sym->info)._typ, 411) /*expected idx: 411, name: v.ast.SumType */ ;
	if (info.found_fields) {
		return;
	}
	Map_string_v__ast__StructField field_map = new_map(sizeof(string), sizeof(v__ast__StructField), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
	Map_string_int field_usages = new_map(sizeof(string), sizeof(int), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
	// FOR IN array
	for (int _t1489 = 0; _t1489 < info.variants.len; ++_t1489) {
		v__ast__Type variant = ((v__ast__Type*)info.variants.data)[_t1489];
		v__ast__TypeSymbol* v_sym = v__ast__Table_get_type_symbol(t, variant);
		Array_v__ast__StructField _t1490;
		if (v_sym->info._typ == 409 /* v.ast.Struct */) {
			_t1490 = (*v_sym->info._v__ast__Struct).fields;
		}
		else if (v_sym->info._typ == 411 /* v.ast.SumType */) {
			v__ast__Table_resolve_common_sumtype_fields(t, v_sym);
			_t1490 = (*v_sym->info._v__ast__SumType).fields;
		}
		else {
			_t1490 = __new_array_with_default(0, 0, sizeof(v__ast__StructField), 0);
		}		Array_v__ast__StructField fields = _t1490;
		// FOR IN array
		for (int _t1491 = 0; _t1491 < fields.len; ++_t1491) {
			v__ast__StructField field = ((v__ast__StructField*)fields.data)[_t1491];
			if (!_IN_MAP(ADDR(string, field.name), ADDR(map, field_map))) {
				(*(v__ast__StructField*)map_get_and_set(&field_map, &(string[]){field.name}, &(v__ast__StructField[]){ (v__ast__StructField){.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),} })) = field;
				(*(int*)map_get_and_set(&field_usages, &(string[]){field.name}, &(int[]){ 0 }))++;
			} else if (v__ast__StructField_equals(&field, (voidptr)&/*qq*/(*(v__ast__StructField*)map_get(ADDR(map, field_map), &(string[]){field.name}, &(v__ast__StructField[]){ (v__ast__StructField){.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),} })))) {
				(*(int*)map_get_and_set(&field_usages, &(string[]){field.name}, &(int[]){ 0 }))++;
			}
		}
	}
	// FOR IN map
	int _t1493 = field_usages.key_values.len;
	for (int _t1492 = 0; _t1492 < _t1493; ++_t1492 ) {
		int _t1494 = field_usages.key_values.len - _t1493;
		_t1493 = field_usages.key_values.len;
		if (_t1494 < 0) {
			_t1492 = -1;
			continue;
		}
		if (!DenseArray_has_index(&field_usages.key_values, _t1492)) {continue;}
		string field = /*key*/ *(string*)DenseArray_key(&field_usages.key_values, _t1492);
		field = string_clone(field);
		int nr_definitions = (*(int*)DenseArray_value(&field_usages.key_values, _t1492));
		if (nr_definitions == info.variants.len) {
			array_push(&info.fields, _MOV((v__ast__StructField[]){ (*(v__ast__StructField*)map_get(&field_map, &(string[]){field}, &(v__ast__StructField[]){ (v__ast__StructField){.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),} })) }));
		}
	}
	info.found_fields = true;
	sym->info = v__ast__SumType_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__SumType, (info)));
}

// Attr: [inline]
inline int v__ast__Table_find_type_idx(v__ast__Table* t, string name) {
	 int _t1496 = (*(int*)map_get(ADDR(map, t->type_idxs), &(string[]){name}, &(int[]){ 0 }));
	// autofree_scope_vars(pos=10274 line_nr=388 scope.pos=10230 scope.end_pos=10300)
	// var "t" var.pos=10231 var.line_nr=387
	// var "name" var.pos=10255 var.line_nr=387
	// af parent scope:
	// af parent scope:
	return _t1496;
}

// Attr: [inline]
inline Option_v__ast__TypeSymbol v__ast__Table_find_type(v__ast__Table* t, string name) {
	int idx = (*(int*)map_get(ADDR(map, t->type_idxs), &(string[]){name}, &(int[]){ 0 }));
	if (idx > 0) {
		Option_v__ast__TypeSymbol _t1497;
		opt_ok(&(v__ast__TypeSymbol[]) { (*(v__ast__TypeSymbol*)/*ee elem_typ */array_get(t->type_symbols, idx)) }, (Option*)(&_t1497), sizeof(v__ast__TypeSymbol));
		// autofree_scope_vars(pos=10408 line_nr=395 scope.pos=10405 scope.end_pos=10437)
		// af parent scope:
		// var "t" var.pos=10320 var.line_nr=392
		// var "name" var.pos=10340 var.line_nr=392
		// var "idx" var.pos=10368 var.line_nr=393
		// af parent scope:
		// af parent scope:
		return _t1497;
	}
	return (Option_v__ast__TypeSymbol){ .state=2, .err=_const_none__ };
}

// Attr: [inline]
inline v__ast__TypeSymbol* v__ast__Table_get_type_symbol(v__ast__Table* t, v__ast__Type typ) {
	int idx = v__ast__Type_idx(typ);
	if (idx > 0) {
		 v__ast__TypeSymbol* _t1498 = &(*(v__ast__TypeSymbol*)/*ee elem_typ */array_get(t->type_symbols, idx));
		// autofree_scope_vars(pos=10591 line_nr=405 scope.pos=10588 scope.end_pos=10632)
		// af parent scope:
		// var "t" var.pos=10472 var.line_nr=401
		// var "typ" var.pos=10498 var.line_nr=401
		// var "idx" var.pos=10559 var.line_nr=403
		// af parent scope:
		// af parent scope:
		return _t1498;
	}
	v_panic(_STR("get_type_symbol: invalid type (typ=%"PRId32"\000 idx=%"PRId32"\000). Compiler bug. This should never happen. Please create a GitHub issue.\n", 3, typ, idx));
	return 0;
}

// Attr: [inline]
inline v__ast__TypeSymbol* v__ast__Table_get_final_type_symbol(v__ast__Table* t, v__ast__Type typ) {
	int idx = v__ast__Type_idx(typ);
	if (idx > 0) {
		v__ast__TypeSymbol current_type = (*(v__ast__TypeSymbol*)/*ee elem_typ */array_get(t->type_symbols, idx));
		if (current_type.kind == v__ast__Kind_alias) {
			v__ast__Alias alias_info = /* as */ *(v__ast__Alias*)__as_cast((current_type.info)._v__ast__Alias,(current_type.info)._typ, 413) /*expected idx: 413, name: v.ast.Alias */ ;
			 v__ast__TypeSymbol* _t1499 = v__ast__Table_get_final_type_symbol(t, alias_info.parent_type);
			// autofree_scope_vars(pos=11094 line_nr=420 scope.pos=11046 scope.end_pos=11152)
			// var "alias_info" var.pos=11051 var.line_nr=419
			// af parent scope:
			// var "current_type" var.pos=10977 var.line_nr=417
			// af parent scope:
			// var "t" var.pos=10887 var.line_nr=414
			// var "typ" var.pos=10919 var.line_nr=414
			// var "idx" var.pos=10944 var.line_nr=415
			// af parent scope:
			// af parent scope:
			return _t1499;
		}
		 v__ast__TypeSymbol* _t1500 = &(*(v__ast__TypeSymbol*)/*ee elem_typ */array_get(t->type_symbols, idx));
		// autofree_scope_vars(pos=11155 line_nr=422 scope.pos=10973 scope.end_pos=11196)
		// var "current_type" var.pos=10977 var.line_nr=417
		// af parent scope:
		// var "t" var.pos=10887 var.line_nr=414
		// var "typ" var.pos=10919 var.line_nr=414
		// var "idx" var.pos=10944 var.line_nr=415
		// af parent scope:
		// af parent scope:
		return _t1500;
	}
	v_panic(_STR("get_final_type_symbol: invalid type (typ=%"PRId32"\000 idx=%"PRId32"\000). Compiler bug. This should never happen. Please create a GitHub issue.", 3, typ, idx));
	return 0;
}

// Attr: [inline]
inline string v__ast__Table_get_type_name(v__ast__Table* t, v__ast__Type typ) {
	v__ast__TypeSymbol* typ_sym = v__ast__Table_get_type_symbol(t, typ);
	 string _t1501 = typ_sym->name;
	// autofree_scope_vars(pos=11462 line_nr=431 scope.pos=11383 scope.end_pos=11483)
	// var "t" var.pos=11384 var.line_nr=429
	// var "typ" var.pos=11408 var.line_nr=429
	// var "typ_sym" var.pos=11428 var.line_nr=430
	// af parent scope:
	// af parent scope:
	return _t1501;
}

// Attr: [inline]
inline v__ast__Type v__ast__Table_unalias_num_type(v__ast__Table* t, v__ast__Type typ) {
	v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(t, typ);
	if (sym->kind == v__ast__Kind_alias) {
		v__ast__Type pt = (/* as */ *(v__ast__Alias*)__as_cast((sym->info)._v__ast__Alias,(sym->info)._typ, 413) /*expected idx: 413, name: v.ast.Alias */ ).parent_type;
		if (pt <= _const_v__ast__f64_type && pt >= _const_v__ast__void_type) {
			// autofree_scope_vars(pos=11686 line_nr=440 scope.pos=11682 scope.end_pos=11699)
			// af parent scope:
			// var "pt" var.pos=11605 var.line_nr=438
			// af parent scope:
			// var "t" var.pos=11503 var.line_nr=435
			// var "typ" var.pos=11530 var.line_nr=435
			// var "sym" var.pos=11548 var.line_nr=436
			// af parent scope:
			// af parent scope:
			return pt;
		}
	}
	// autofree_scope_vars(pos=11704 line_nr=443 scope.pos=11502 scope.end_pos=11716)
	// var "t" var.pos=11503 var.line_nr=435
	// var "typ" var.pos=11530 var.line_nr=435
	// var "sym" var.pos=11548 var.line_nr=436
	// af parent scope:
	// af parent scope:
	return typ;
}

// Attr: [inline]
inline int v__ast__Table_register_type_symbol(v__ast__Table* t, v__ast__TypeSymbol typ) {
	int existing_idx = (*(int*)map_get(ADDR(map, t->type_idxs), &(string[]){typ.name}, &(int[]){ 0 }));
	if (existing_idx > 0) {
		v__ast__TypeSymbol ex_type = (*(v__ast__TypeSymbol*)/*ee elem_typ */array_get(t->type_symbols, existing_idx));

		if (ex_type.kind == (v__ast__Kind_placeholder)) {
			(*(v__ast__TypeSymbol*)/*ee elem_typ */array_get(t->type_symbols, existing_idx)) = (v__ast__TypeSymbol){typ.parent_idx,typ.info,typ.kind,typ.name,typ.cname,.methods = ex_type.methods,typ.mod,typ.is_public,typ.language,};
			// autofree_scope_vars(pos=12170 line_nr=460 scope.pos=11971 scope.end_pos=12194)
			// af parent scope:
			// var "ex_type" var.pos=11905 var.line_nr=451
			// af parent scope:
			// var "t" var.pos=11740 var.line_nr=447
			// var "typ" var.pos=11770 var.line_nr=447
			// var "existing_idx" var.pos=11842 var.line_nr=449
			// var "typ_idx" var.pos=12770 var.line_nr=483
			// af parent scope:
			// af parent scope:
			return existing_idx;
		}
		else {
			if ((existing_idx >= _const_v__ast__string_type_idx && existing_idx <= _const_v__ast__map_type_idx) || existing_idx == _const_v__ast__error_type_idx) {
				if (existing_idx == _const_v__ast__string_type_idx) {
					(*(v__ast__TypeSymbol*)/*ee elem_typ */array_get(t->type_symbols, existing_idx)) = (v__ast__TypeSymbol){typ.parent_idx,typ.info,.kind = ex_type.kind,typ.name,typ.cname,typ.methods,typ.mod,typ.is_public,typ.language,};
				} else {
					(*(v__ast__TypeSymbol*)/*ee elem_typ */array_get(t->type_symbols, existing_idx)) = typ;
				}
				// autofree_scope_vars(pos=12716 line_nr=477 scope.pos=12454 scope.end_pos=12741)
				// af parent scope:
				// af parent scope:
				// var "ex_type" var.pos=11905 var.line_nr=451
				// af parent scope:
				// var "t" var.pos=11740 var.line_nr=447
				// var "typ" var.pos=11770 var.line_nr=447
				// var "existing_idx" var.pos=11842 var.line_nr=449
				// var "typ_idx" var.pos=12770 var.line_nr=483
				// af parent scope:
				// af parent scope:
				return existing_idx;
			}
			 int _t1502 = -1;
			// autofree_scope_vars(pos=12746 line_nr=479 scope.pos=12199 scope.end_pos=12760)
			// af parent scope:
			// var "ex_type" var.pos=11905 var.line_nr=451
			// af parent scope:
			// var "t" var.pos=11740 var.line_nr=447
			// var "typ" var.pos=11770 var.line_nr=447
			// var "existing_idx" var.pos=11842 var.line_nr=449
			// var "typ_idx" var.pos=12770 var.line_nr=483
			// af parent scope:
			// af parent scope:
			return _t1502;
		};
	}
	int typ_idx = t->type_symbols.len;
	array_push(&t->type_symbols, _MOV((v__ast__TypeSymbol[]){ typ }));
	map_set(&t->type_idxs, &(string[]){typ.name}, &(int[]) { typ_idx });
	// autofree_scope_vars(pos=12856 line_nr=486 scope.pos=11735 scope.end_pos=12872)
	// var "t" var.pos=11740 var.line_nr=447
	// var "typ" var.pos=11770 var.line_nr=447
	// var "existing_idx" var.pos=11842 var.line_nr=449
	// var "typ_idx" var.pos=12770 var.line_nr=483
	// af parent scope:
	// af parent scope:
	return typ_idx;
}

bool v__ast__Table_known_type(v__ast__Table* t, string name) {
	 bool _t1504 = v__ast__Table_find_type_idx(t, name) != 0;
	// autofree_scope_vars(pos=12924 line_nr=490 scope.pos=12882 scope.end_pos=12959)
	// var "t" var.pos=12883 var.line_nr=489
	// var "name" var.pos=12904 var.line_nr=489
	// af parent scope:
	// af parent scope:
	return _t1504;
}

bool v__ast__Table_known_type_idx(v__ast__Table* t, v__ast__Type typ) {
	if (typ == 0) {
		 bool _t1505 = false;
		// autofree_scope_vars(pos=13028 line_nr=495 scope.pos=13025 scope.end_pos=13043)
		// af parent scope:
		// var "t" var.pos=12970 var.line_nr=493
		// var "typ" var.pos=12995 var.line_nr=493
		// var "sym" var.pos=13046 var.line_nr=497
		// af parent scope:
		// af parent scope:
		return _t1505;
	}
	v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(t, typ);

	if (sym->kind == (v__ast__Kind_placeholder)) {
		 bool _t1506 = sym->language != v__ast__Language_v || string_starts_with(sym->name, _SLIT("C."));
		// autofree_scope_vars(pos=13113 line_nr=500 scope.pos=13096 scope.end_pos=13172)
		// af parent scope:
		// var "t" var.pos=12970 var.line_nr=493
		// var "typ" var.pos=12995 var.line_nr=493
		// var "sym" var.pos=13046 var.line_nr=497
		// af parent scope:
		// af parent scope:
		return _t1506;
	}
	else if (sym->kind == (v__ast__Kind_array)) {
		 bool _t1507 = v__ast__Table_known_type_idx(t, (/* as */ *(v__ast__Array*)__as_cast((sym->info)._v__ast__Array,(sym->info)._typ, 395) /*expected idx: 395, name: v.ast.Array */ ).elem_type);
		// autofree_scope_vars(pos=13187 line_nr=503 scope.pos=13176 scope.end_pos=13245)
		// af parent scope:
		// var "t" var.pos=12970 var.line_nr=493
		// var "typ" var.pos=12995 var.line_nr=493
		// var "sym" var.pos=13046 var.line_nr=497
		// af parent scope:
		// af parent scope:
		return _t1507;
	}
	else if (sym->kind == (v__ast__Kind_map)) {
		v__ast__Map info = /* as */ *(v__ast__Map*)__as_cast((sym->info)._v__ast__Map,(sym->info)._typ, 396) /*expected idx: 396, name: v.ast.Map */ ;
		 bool _t1508 = v__ast__Table_known_type_idx(t, info.key_type) && v__ast__Table_known_type_idx(t, info.value_type);
		// autofree_scope_vars(pos=13285 line_nr=507 scope.pos=13249 scope.end_pos=13364)
		// var "info" var.pos=13259 var.line_nr=506
		// af parent scope:
		// var "t" var.pos=12970 var.line_nr=493
		// var "typ" var.pos=12995 var.line_nr=493
		// var "sym" var.pos=13046 var.line_nr=497
		// af parent scope:
		// af parent scope:
		return _t1508;
	}
	else {
	};
	 bool _t1509 = true;
	// autofree_scope_vars(pos=13379 line_nr=511 scope.pos=12969 scope.end_pos=13392)
	// var "t" var.pos=12970 var.line_nr=493
	// var "typ" var.pos=12995 var.line_nr=493
	// var "sym" var.pos=13046 var.line_nr=497
	// af parent scope:
	// af parent scope:
	return _t1509;
}

// Attr: [inline]
inline string v__ast__Table_array_name(v__ast__Table* t, v__ast__Type elem_type) {
	v__ast__TypeSymbol* elem_type_sym = v__ast__Table_get_type_symbol(t, elem_type);
	string ptr = (v__ast__Type_is_ptr(elem_type) ? (string_repeat(_SLIT("&"), v__ast__Type_nr_muls(elem_type))) : (_SLIT("")));
	 string _t1510 = _STR("[]%.*s\000%.*s", 2, ptr, elem_type_sym->name);
	// autofree_scope_vars(pos=13665 line_nr=520 scope.pos=13493 scope.end_pos=13701)
	// var "t" var.pos=13494 var.line_nr=517
	// var "elem_type" var.pos=13515 var.line_nr=517
	// var "elem_type_sym" var.pos=13541 var.line_nr=518
	// var "ptr" var.pos=13588 var.line_nr=519
	// af parent scope:
	// af parent scope:
	return _t1510;
}

// Attr: [inline]
inline string v__ast__Table_array_cname(v__ast__Table* t, v__ast__Type elem_type) {
	v__ast__TypeSymbol* elem_type_sym = v__ast__Table_get_type_symbol(t, elem_type);
	string res = _SLIT("");
	if (v__ast__Type_is_ptr(elem_type)) {
		res = string_repeat(_SLIT("_ptr"), v__ast__Type_nr_muls(elem_type));
	}
	 string _t1511 = string_add(_STR("Array_%.*s", 1, elem_type_sym->cname), res);
	// autofree_scope_vars(pos=13901 line_nr=530 scope.pos=13720 scope.end_pos=13944)
	// var "t" var.pos=13721 var.line_nr=524
	// var "elem_type" var.pos=13743 var.line_nr=524
	// var "elem_type_sym" var.pos=13769 var.line_nr=525
	// var "res" var.pos=13820 var.line_nr=526
	// str literal
	// af parent scope:
	// af parent scope:
	return _t1511;
}

// Attr: [inline]
inline string v__ast__Table_array_fixed_name(v__ast__Table* t, v__ast__Type elem_type, int size) {
	v__ast__TypeSymbol* elem_type_sym = v__ast__Table_get_type_symbol(t, elem_type);
	string ptr = (v__ast__Type_is_ptr(elem_type) ? (string_repeat(_SLIT("&"), v__ast__Type_nr_muls(elem_type))) : (_SLIT("")));
	 string _t1512 = _STR("[%"PRId32"\000]%.*s\000%.*s", 3, size, ptr, elem_type_sym->name);
	// autofree_scope_vars(pos=14244 line_nr=539 scope.pos=14056 scope.end_pos=14285)
	// var "t" var.pos=14057 var.line_nr=536
	// var "elem_type" var.pos=14084 var.line_nr=536
	// var "size" var.pos=14100 var.line_nr=536
	// var "elem_type_sym" var.pos=14120 var.line_nr=537
	// var "ptr" var.pos=14167 var.line_nr=538
	// af parent scope:
	// af parent scope:
	return _t1512;
}

// Attr: [inline]
inline string v__ast__Table_array_fixed_cname(v__ast__Table* t, v__ast__Type elem_type, int size) {
	v__ast__TypeSymbol* elem_type_sym = v__ast__Table_get_type_symbol(t, elem_type);
	string res = _SLIT("");
	if (v__ast__Type_is_ptr(elem_type)) {
		res = _SLIT("_ptr");
	}
	 string _t1513 = string_add(_STR("Array_fixed_%.*s\000_%"PRId32"", 2, elem_type_sym->cname, size), res);
	// autofree_scope_vars(pos=14473 line_nr=549 scope.pos=14304 scope.end_pos=14530)
	// var "t" var.pos=14305 var.line_nr=543
	// var "elem_type" var.pos=14333 var.line_nr=543
	// var "size" var.pos=14349 var.line_nr=543
	// var "elem_type_sym" var.pos=14369 var.line_nr=544
	// var "res" var.pos=14420 var.line_nr=545
	// str literal
	// af parent scope:
	// af parent scope:
	return _t1513;
}

// Attr: [inline]
inline string v__ast__Table_chan_name(v__ast__Table* t, v__ast__Type elem_type, bool is_mut) {
	v__ast__TypeSymbol* elem_type_sym = v__ast__Table_get_type_symbol(t, elem_type);
	string ptr = _SLIT("");
	if (is_mut) {
		ptr = _SLIT("mut ");
	} else if (v__ast__Type_is_ptr(elem_type)) {
		ptr = _SLIT("&");
	}
	 string _t1514 = _STR("chan %.*s\000%.*s", 2, ptr, elem_type_sym->name);
	// autofree_scope_vars(pos=14745 line_nr=561 scope.pos=14549 scope.end_pos=14784)
	// var "t" var.pos=14550 var.line_nr=553
	// var "elem_type" var.pos=14570 var.line_nr=553
	// var "is_mut" var.pos=14586 var.line_nr=553
	// var "elem_type_sym" var.pos=14609 var.line_nr=554
	// var "ptr" var.pos=14660 var.line_nr=555
	// str literal
	// af parent scope:
	// af parent scope:
	return _t1514;
}

// Attr: [inline]
inline string v__ast__Table_chan_cname(v__ast__Table* t, v__ast__Type elem_type, bool is_mut) {
	v__ast__TypeSymbol* elem_type_sym = v__ast__Table_get_type_symbol(t, elem_type);
	string suffix = _SLIT("");
	if (is_mut) {
		suffix = _SLIT("_mut");
	} else if (v__ast__Type_is_ptr(elem_type)) {
		suffix = _SLIT("_ptr");
	}
	 string _t1515 = string_add(_STR("chan_%.*s", 1, elem_type_sym->cname), suffix);
	// autofree_scope_vars(pos=15012 line_nr=573 scope.pos=14803 scope.end_pos=15057)
	// var "t" var.pos=14804 var.line_nr=565
	// var "elem_type" var.pos=14825 var.line_nr=565
	// var "is_mut" var.pos=14841 var.line_nr=565
	// var "elem_type_sym" var.pos=14864 var.line_nr=566
	// var "suffix" var.pos=14915 var.line_nr=567
	// str literal
	// af parent scope:
	// af parent scope:
	return _t1515;
}

// Attr: [inline]
inline string v__ast__Table_thread_name(v__ast__Table* t, v__ast__Type return_type) {
	if (v__ast__Type_idx(return_type) == _const_v__ast__void_type_idx) {
		if (v__ast__Type_has_flag(return_type, v__ast__TypeFlag_optional)) {
			 string _t1516 = _SLIT("thread ?");
			// autofree_scope_vars(pos=15208 line_nr=580 scope.pos=15204 scope.end_pos=15229)
			// af parent scope:
			// af parent scope:
			// var "t" var.pos=15077 var.line_nr=577
			// var "return_type" var.pos=15099 var.line_nr=577
			// var "return_type_sym" var.pos=15265 var.line_nr=585
			// var "ptr" var.pos=15316 var.line_nr=586
			// var "opt" var.pos=15368 var.line_nr=587
			// af parent scope:
			// af parent scope:
			return _t1516;
		} else {
			 string _t1517 = _SLIT("thread");
			// autofree_scope_vars(pos=15240 line_nr=582 scope.pos=15236 scope.end_pos=15259)
			// af parent scope:
			// af parent scope:
			// var "t" var.pos=15077 var.line_nr=577
			// var "return_type" var.pos=15099 var.line_nr=577
			// var "return_type_sym" var.pos=15265 var.line_nr=585
			// var "ptr" var.pos=15316 var.line_nr=586
			// var "opt" var.pos=15368 var.line_nr=587
			// af parent scope:
			// af parent scope:
			return _t1517;
		}
	}
	v__ast__TypeSymbol* return_type_sym = v__ast__Table_get_type_symbol(t, return_type);
	string ptr = (v__ast__Type_is_ptr(return_type) ? (_SLIT("&")) : (_SLIT("")));
	string opt = (v__ast__Type_has_flag(return_type, v__ast__TypeFlag_optional) ? (_SLIT("?")) : (_SLIT("")));
	 string _t1518 = _STR("thread %.*s\000%.*s\000%.*s", 3, opt, ptr, return_type_sym->name);
	// autofree_scope_vars(pos=15430 line_nr=588 scope.pos=15076 scope.end_pos=15477)
	// var "t" var.pos=15077 var.line_nr=577
	// var "return_type" var.pos=15099 var.line_nr=577
	// var "return_type_sym" var.pos=15265 var.line_nr=585
	// var "ptr" var.pos=15316 var.line_nr=586
	// var "opt" var.pos=15368 var.line_nr=587
	// af parent scope:
	// af parent scope:
	return _t1518;
}

// Attr: [inline]
inline string v__ast__Table_thread_cname(v__ast__Table* t, v__ast__Type return_type) {
	if (v__ast__Type_alias_eq(return_type, _const_v__ast__void_type)) {
		if (v__ast__Type_has_flag(return_type, v__ast__TypeFlag_optional)) {
			 string _t1519 = _SLIT("__v_thread_Option_void");
			// autofree_scope_vars(pos=15619 line_nr=595 scope.pos=15615 scope.end_pos=15654)
			// af parent scope:
			// af parent scope:
			// var "t" var.pos=15497 var.line_nr=592
			// var "return_type" var.pos=15520 var.line_nr=592
			// var "return_type_sym" var.pos=15694 var.line_nr=600
			// var "suffix" var.pos=15745 var.line_nr=601
			// var "prefix" var.pos=15803 var.line_nr=602
			// af parent scope:
			// af parent scope:
			return _t1519;
		} else {
			 string _t1520 = _SLIT("__v_thread");
			// autofree_scope_vars(pos=15665 line_nr=597 scope.pos=15661 scope.end_pos=15688)
			// af parent scope:
			// af parent scope:
			// var "t" var.pos=15497 var.line_nr=592
			// var "return_type" var.pos=15520 var.line_nr=592
			// var "return_type_sym" var.pos=15694 var.line_nr=600
			// var "suffix" var.pos=15745 var.line_nr=601
			// var "prefix" var.pos=15803 var.line_nr=602
			// af parent scope:
			// af parent scope:
			return _t1520;
		}
	}
	v__ast__TypeSymbol* return_type_sym = v__ast__Table_get_type_symbol(t, return_type);
	string suffix = (v__ast__Type_is_ptr(return_type) ? (_SLIT("_ptr")) : (_SLIT("")));
	string prefix = (v__ast__Type_has_flag(return_type, v__ast__TypeFlag_optional) ? (_SLIT("Option_")) : (_SLIT("")));
	 string _t1521 = _STR("__v_thread_%.*s\000%.*s\000%.*s", 3, prefix, return_type_sym->cname, suffix);
	// autofree_scope_vars(pos=15874 line_nr=603 scope.pos=15496 scope.end_pos=15932)
	// var "t" var.pos=15497 var.line_nr=592
	// var "return_type" var.pos=15520 var.line_nr=592
	// var "return_type_sym" var.pos=15694 var.line_nr=600
	// var "suffix" var.pos=15745 var.line_nr=601
	// var "prefix" var.pos=15803 var.line_nr=602
	// af parent scope:
	// af parent scope:
	return _t1521;
}

// Attr: [inline]
inline string v__ast__Table_map_name(v__ast__Table* t, v__ast__Type key_type, v__ast__Type value_type) {
	v__ast__TypeSymbol* key_type_sym = v__ast__Table_get_type_symbol(t, key_type);
	v__ast__TypeSymbol* value_type_sym = v__ast__Table_get_type_symbol(t, value_type);
	string ptr = (v__ast__Type_is_ptr(value_type) ? (_SLIT("&")) : (_SLIT("")));
	 string _t1522 = _STR("map[%.*s\000]%.*s\000%.*s", 3, key_type_sym->name, ptr, value_type_sym->name);
	// autofree_scope_vars(pos=16246 line_nr=613 scope.pos=16040 scope.end_pos=16304)
	// var "t" var.pos=16041 var.line_nr=609
	// var "key_type" var.pos=16060 var.line_nr=609
	// var "value_type" var.pos=16075 var.line_nr=609
	// var "key_type_sym" var.pos=16102 var.line_nr=610
	// var "value_type_sym" var.pos=16147 var.line_nr=611
	// var "ptr" var.pos=16196 var.line_nr=612
	// af parent scope:
	// af parent scope:
	return _t1522;
}

// Attr: [inline]
inline string v__ast__Table_map_cname(v__ast__Table* t, v__ast__Type key_type, v__ast__Type value_type) {
	v__ast__TypeSymbol* key_type_sym = v__ast__Table_get_type_symbol(t, key_type);
	v__ast__TypeSymbol* value_type_sym = v__ast__Table_get_type_symbol(t, value_type);
	string suffix = (v__ast__Type_is_ptr(value_type) ? (_SLIT("_ptr")) : (_SLIT("")));
	 string _t1523 = string_add(_STR("Map_%.*s\000_%.*s", 2, key_type_sym->cname, value_type_sym->cname), suffix);
	// autofree_scope_vars(pos=16536 line_nr=621 scope.pos=16323 scope.end_pos=16652)
	// var "t" var.pos=16324 var.line_nr=617
	// var "key_type" var.pos=16344 var.line_nr=617
	// var "value_type" var.pos=16359 var.line_nr=617
	// var "key_type_sym" var.pos=16386 var.line_nr=618
	// var "value_type_sym" var.pos=16431 var.line_nr=619
	// var "suffix" var.pos=16480 var.line_nr=620
	// af parent scope:
	// af parent scope:
	return _t1523;
}

int v__ast__Table_find_or_register_chan(v__ast__Table* t, v__ast__Type elem_type, bool is_mut) {
	string name = v__ast__Table_chan_name(t, elem_type, is_mut);
	string cname = v__ast__Table_chan_cname(t, elem_type, is_mut);
	int existing_idx = (*(int*)map_get(ADDR(map, t->type_idxs), &(string[]){name}, &(int[]){ 0 }));
	if (existing_idx > 0) {
		// autofree_scope_vars(pos=16887 line_nr=631 scope.pos=16884 scope.end_pos=16909)
		// af parent scope:
		// var "t" var.pos=16667 var.line_nr=625
		// var "elem_type" var.pos=16698 var.line_nr=625
		// var "is_mut" var.pos=16714 var.line_nr=625
		// var "name" var.pos=16734 var.line_nr=626
		// var "cname" var.pos=16774 var.line_nr=627
		// var "existing_idx" var.pos=16829 var.line_nr=629
		// var "chan_typ" var.pos=16925 var.line_nr=634
		// af parent scope:
		// af parent scope:
		return existing_idx;
	}
	v__ast__TypeSymbol chan_typ = (v__ast__TypeSymbol){.parent_idx = _const_v__ast__chan_type_idx,.info = v__ast__Chan_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__Chan, ((v__ast__Chan){.elem_type = elem_type,.is_mut = is_mut,}))),.kind = v__ast__Kind_chan,.name = name,.cname = cname,.methods = __new_array(0, 1, sizeof(v__ast__Fn)),.mod = (string){.str=(byteptr)"", .is_lit=1},.is_public = 0,.language = 0,};
	 int _t1524 = v__ast__Table_register_type_symbol(t, chan_typ);
	// autofree_scope_vars(pos=17082 line_nr=644 scope.pos=16662 scope.end_pos=17123)
	// var "t" var.pos=16667 var.line_nr=625
	// var "elem_type" var.pos=16698 var.line_nr=625
	// var "is_mut" var.pos=16714 var.line_nr=625
	// var "name" var.pos=16734 var.line_nr=626
	// var "cname" var.pos=16774 var.line_nr=627
	// var "existing_idx" var.pos=16829 var.line_nr=629
	// var "chan_typ" var.pos=16925 var.line_nr=634
	// af parent scope:
	// af parent scope:
	return _t1524;
}

int v__ast__Table_find_or_register_map(v__ast__Table* t, v__ast__Type key_type, v__ast__Type value_type) {
	string name = v__ast__Table_map_name(t, key_type, value_type);
	string cname = v__ast__Table_map_cname(t, key_type, value_type);
	int existing_idx = (*(int*)map_get(ADDR(map, t->type_idxs), &(string[]){name}, &(int[]){ 0 }));
	if (existing_idx > 0) {
		// autofree_scope_vars(pos=17364 line_nr=653 scope.pos=17361 scope.end_pos=17386)
		// af parent scope:
		// var "t" var.pos=17138 var.line_nr=647
		// var "key_type" var.pos=17168 var.line_nr=647
		// var "value_type" var.pos=17183 var.line_nr=647
		// var "name" var.pos=17207 var.line_nr=648
		// var "cname" var.pos=17249 var.line_nr=649
		// var "existing_idx" var.pos=17306 var.line_nr=651
		// var "map_typ" var.pos=17402 var.line_nr=656
		// af parent scope:
		// af parent scope:
		return existing_idx;
	}
	v__ast__TypeSymbol map_typ = (v__ast__TypeSymbol){.parent_idx = _const_v__ast__map_type_idx,.info = v__ast__Map_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__Map, ((v__ast__Map){.key_type = key_type,.value_type = value_type,}))),.kind = v__ast__Kind_map,.name = name,.cname = cname,.methods = __new_array(0, 1, sizeof(v__ast__Fn)),.mod = (string){.str=(byteptr)"", .is_lit=1},.is_public = 0,.language = 0,};
	 int _t1525 = v__ast__Table_register_type_symbol(t, map_typ);
	// autofree_scope_vars(pos=17561 line_nr=666 scope.pos=17133 scope.end_pos=17601)
	// var "t" var.pos=17138 var.line_nr=647
	// var "key_type" var.pos=17168 var.line_nr=647
	// var "value_type" var.pos=17183 var.line_nr=647
	// var "name" var.pos=17207 var.line_nr=648
	// var "cname" var.pos=17249 var.line_nr=649
	// var "existing_idx" var.pos=17306 var.line_nr=651
	// var "map_typ" var.pos=17402 var.line_nr=656
	// af parent scope:
	// af parent scope:
	return _t1525;
}

int v__ast__Table_find_or_register_thread(v__ast__Table* t, v__ast__Type return_type) {
	string name = v__ast__Table_thread_name(t, return_type);
	string cname = v__ast__Table_thread_cname(t, return_type);
	int existing_idx = (*(int*)map_get(ADDR(map, t->type_idxs), &(string[]){name}, &(int[]){ 0 }));
	if (existing_idx > 0) {
		// autofree_scope_vars(pos=17819 line_nr=675 scope.pos=17816 scope.end_pos=17841)
		// af parent scope:
		// var "t" var.pos=17616 var.line_nr=669
		// var "return_type" var.pos=17649 var.line_nr=669
		// var "name" var.pos=17674 var.line_nr=670
		// var "cname" var.pos=17710 var.line_nr=671
		// var "existing_idx" var.pos=17761 var.line_nr=673
		// var "thread_typ" var.pos=17857 var.line_nr=678
		// af parent scope:
		// af parent scope:
		return existing_idx;
	}
	v__ast__TypeSymbol thread_typ = (v__ast__TypeSymbol){.parent_idx = _const_v__ast__thread_type_idx,.info = v__ast__Thread_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__Thread, ((v__ast__Thread){.return_type = return_type,}))),.kind = v__ast__Kind_thread,.name = name,.cname = cname,.methods = __new_array(0, 1, sizeof(v__ast__Fn)),.mod = (string){.str=(byteptr)"", .is_lit=1},.is_public = 0,.language = 0,};
	 int _t1526 = v__ast__Table_register_type_symbol(t, thread_typ);
	// autofree_scope_vars(pos=18008 line_nr=687 scope.pos=17611 scope.end_pos=18051)
	// var "t" var.pos=17616 var.line_nr=669
	// var "return_type" var.pos=17649 var.line_nr=669
	// var "name" var.pos=17674 var.line_nr=670
	// var "cname" var.pos=17710 var.line_nr=671
	// var "existing_idx" var.pos=17761 var.line_nr=673
	// var "thread_typ" var.pos=17857 var.line_nr=678
	// af parent scope:
	// af parent scope:
	return _t1526;
}

int v__ast__Table_find_or_register_array(v__ast__Table* t, v__ast__Type elem_type) {
	string name = v__ast__Table_array_name(t, elem_type);
	string cname = v__ast__Table_array_cname(t, elem_type);
	int existing_idx = (*(int*)map_get(ADDR(map, t->type_idxs), &(string[]){name}, &(int[]){ 0 }));
	if (existing_idx > 0) {
		// autofree_scope_vars(pos=18260 line_nr=696 scope.pos=18257 scope.end_pos=18282)
		// af parent scope:
		// var "t" var.pos=18066 var.line_nr=690
		// var "elem_type" var.pos=18098 var.line_nr=690
		// var "name" var.pos=18121 var.line_nr=691
		// var "cname" var.pos=18154 var.line_nr=692
		// var "existing_idx" var.pos=18202 var.line_nr=694
		// var "array_type_" var.pos=18298 var.line_nr=699
		// af parent scope:
		// af parent scope:
		return existing_idx;
	}
	v__ast__TypeSymbol array_type_ = (v__ast__TypeSymbol){.parent_idx = _const_v__ast__array_type_idx,.info = v__ast__Array_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__Array, ((v__ast__Array){.nr_dims = 1,.elem_type = elem_type,}))),.kind = v__ast__Kind_array,.name = name,.cname = cname,.methods = __new_array(0, 1, sizeof(v__ast__Fn)),.mod = (string){.str=(byteptr)"", .is_lit=1},.is_public = 0,.language = 0,};
	 int _t1527 = v__ast__Table_register_type_symbol(t, array_type_);
	// autofree_scope_vars(pos=18457 line_nr=709 scope.pos=18061 scope.end_pos=18501)
	// var "t" var.pos=18066 var.line_nr=690
	// var "elem_type" var.pos=18098 var.line_nr=690
	// var "name" var.pos=18121 var.line_nr=691
	// var "cname" var.pos=18154 var.line_nr=692
	// var "existing_idx" var.pos=18202 var.line_nr=694
	// var "array_type_" var.pos=18298 var.line_nr=699
	// af parent scope:
	// af parent scope:
	return _t1527;
}

int v__ast__Table_find_or_register_array_with_dims(v__ast__Table* t, v__ast__Type elem_type, int nr_dims) {
	if (nr_dims == 1) {
		 int _t1528 = v__ast__Table_find_or_register_array(t, elem_type);
		// autofree_scope_vars(pos=18613 line_nr=714 scope.pos=18610 scope.end_pos=18658)
		// af parent scope:
		// var "t" var.pos=18516 var.line_nr=712
		// var "elem_type" var.pos=18558 var.line_nr=712
		// var "nr_dims" var.pos=18574 var.line_nr=712
		// af parent scope:
		// af parent scope:
		return _t1528;
	}
	 int _t1529 = v__ast__Table_find_or_register_array(t, v__ast__Table_find_or_register_array_with_dims(t, elem_type, nr_dims - 1));
	// autofree_scope_vars(pos=18660 line_nr=716 scope.pos=18511 scope.end_pos=18753)
	// var "t" var.pos=18516 var.line_nr=712
	// var "elem_type" var.pos=18558 var.line_nr=712
	// var "nr_dims" var.pos=18574 var.line_nr=712
	// af parent scope:
	// af parent scope:
	return _t1529;
}

int v__ast__Table_find_or_register_array_fixed(v__ast__Table* t, v__ast__Type elem_type, int size) {
	string name = v__ast__Table_array_fixed_name(t, elem_type, size);
	string cname = v__ast__Table_array_fixed_cname(t, elem_type, size);
	int existing_idx = (*(int*)map_get(ADDR(map, t->type_idxs), &(string[]){name}, &(int[]){ 0 }));
	if (existing_idx > 0) {
		// autofree_scope_vars(pos=19002 line_nr=725 scope.pos=18999 scope.end_pos=19024)
		// af parent scope:
		// var "t" var.pos=18768 var.line_nr=719
		// var "elem_type" var.pos=18806 var.line_nr=719
		// var "size" var.pos=18822 var.line_nr=719
		// var "name" var.pos=18839 var.line_nr=720
		// var "cname" var.pos=18884 var.line_nr=721
		// var "existing_idx" var.pos=18944 var.line_nr=723
		// var "array_fixed_type" var.pos=19040 var.line_nr=728
		// af parent scope:
		// af parent scope:
		return existing_idx;
	}
	v__ast__TypeSymbol array_fixed_type = (v__ast__TypeSymbol){.parent_idx = 0,.info = v__ast__ArrayFixed_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__ArrayFixed, ((v__ast__ArrayFixed){.size = size,.elem_type = elem_type,}))),.kind = v__ast__Kind_array_fixed,.name = name,.cname = cname,.methods = __new_array(0, 1, sizeof(v__ast__Fn)),.mod = (string){.str=(byteptr)"", .is_lit=1},.is_public = 0,.language = 0,};
	 int _t1530 = v__ast__Table_register_type_symbol(t, array_fixed_type);
	// autofree_scope_vars(pos=19186 line_nr=737 scope.pos=18763 scope.end_pos=19235)
	// var "t" var.pos=18768 var.line_nr=719
	// var "elem_type" var.pos=18806 var.line_nr=719
	// var "size" var.pos=18822 var.line_nr=719
	// var "name" var.pos=18839 var.line_nr=720
	// var "cname" var.pos=18884 var.line_nr=721
	// var "existing_idx" var.pos=18944 var.line_nr=723
	// var "array_fixed_type" var.pos=19040 var.line_nr=728
	// af parent scope:
	// af parent scope:
	return _t1530;
}

int v__ast__Table_find_or_register_multi_return(v__ast__Table* t, Array_v__ast__Type mr_typs) {
	string name = _SLIT("(");
	string cname = _SLIT("multi_return");
	// FOR IN array
	for (int i = 0; i < mr_typs.len; ++i) {
		v__ast__Type mr_typ = ((v__ast__Type*)mr_typs.data)[i];
		v__ast__TypeSymbol* mr_type_sym = v__ast__Table_get_type_symbol(t, mr_typ);
		name = /*f*/string_add(name, mr_type_sym->name);
		cname = /*f*/string_add(cname, _STR("_%.*s", 1, mr_type_sym->cname));
		if (i < mr_typs.len - 1) {
			name = /*f*/string_add(name, _SLIT(", "));
		}
	}
	name = /*f*/string_add(name, _SLIT(")"));
	int existing_idx = (*(int*)map_get(ADDR(map, t->type_idxs), &(string[]){name}, &(int[]){ 0 }));
	if (existing_idx > 0) {
		// autofree_scope_vars(pos=19623 line_nr=755 scope.pos=19620 scope.end_pos=19645)
		// af parent scope:
		// var "t" var.pos=19250 var.line_nr=740
		// var "mr_typs" var.pos=19289 var.line_nr=740
		// var "name" var.pos=19316 var.line_nr=741
		// str literal
		// var "cname" var.pos=19333 var.line_nr=742
		// str literal
		// var "existing_idx" var.pos=19565 var.line_nr=753
		// var "mr_type" var.pos=19661 var.line_nr=758
		// af parent scope:
		// af parent scope:
		return existing_idx;
	}
	v__ast__TypeSymbol mr_type = (v__ast__TypeSymbol){.parent_idx = 0,.info = v__ast__MultiReturn_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__MultiReturn, ((v__ast__MultiReturn){.types = mr_typs,}))),.kind = v__ast__Kind_multi_return,.name = name,.cname = cname,.methods = __new_array(0, 1, sizeof(v__ast__Fn)),.mod = (string){.str=(byteptr)"", .is_lit=1},.is_public = 0,.language = 0,};
	 int _t1531 = v__ast__Table_register_type_symbol(t, mr_type);
	// autofree_scope_vars(pos=19780 line_nr=766 scope.pos=19245 scope.end_pos=19820)
	// var "t" var.pos=19250 var.line_nr=740
	// var "mr_typs" var.pos=19289 var.line_nr=740
	// var "name" var.pos=19316 var.line_nr=741
	// str literal
	// var "cname" var.pos=19333 var.line_nr=742
	// str literal
	// var "existing_idx" var.pos=19565 var.line_nr=753
	// var "mr_type" var.pos=19661 var.line_nr=758
	// af parent scope:
	// af parent scope:
	return _t1531;
}

int v__ast__Table_find_or_register_fn_type(v__ast__Table* t, string mod, v__ast__Fn f, bool is_anon, bool has_decl) {
	string name = (f.name.len == 0 ? (_STR("fn %.*s", 1, v__ast__Table_fn_type_source_signature(t, (voidptr)&/*qq*/f))) : (string_clone(f.name)));
	string cname = (f.name.len == 0 ? (_STR("anon_fn_%.*s", 1, v__ast__Table_fn_type_signature(t, (voidptr)&/*qq*/f))) : (v__util__no_dots(string_clone(f.name))));
	bool anon = f.name.len == 0 || is_anon;
	int existing_idx = (*(int*)map_get(ADDR(map, t->type_idxs), &(string[]){name}, &(int[]){ 0 }));
	if (existing_idx > 0 && (*(v__ast__TypeSymbol*)/*ee elem_typ */array_get(t->type_symbols, existing_idx)).kind != v__ast__Kind_placeholder) {
		// autofree_scope_vars(pos=20290 line_nr=780 scope.pos=20287 scope.end_pos=20312)
		// af parent scope:
		// var "t" var.pos=19835 var.line_nr=769
		// var "mod" var.pos=19869 var.line_nr=769
		// var "f" var.pos=19881 var.line_nr=769
		// var "is_anon" var.pos=19887 var.line_nr=769
		// var "has_decl" var.pos=19901 var.line_nr=769
		// var "name" var.pos=19923 var.line_nr=770
		// var "cname" var.pos=20017 var.line_nr=771
		// var "anon" var.pos=20130 var.line_nr=776
		// var "existing_idx" var.pos=20179 var.line_nr=778
		// af parent scope:
		// af parent scope:
		return existing_idx;
	}
	 int _t1532 = v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = v__ast__FnType_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__FnType, ((v__ast__FnType){.is_anon = anon,.has_decl = has_decl,.func = f,}))),.kind = v__ast__Kind_function,.name = name,.cname = cname,.methods = __new_array(0, 1, sizeof(v__ast__Fn)),.mod = mod,.is_public = 0,.language = 0,});
	// autofree_scope_vars(pos=20314 line_nr=782 scope.pos=19830 scope.end_pos=20476)
	// var "t" var.pos=19835 var.line_nr=769
	// var "mod" var.pos=19869 var.line_nr=769
	// var "f" var.pos=19881 var.line_nr=769
	// var "is_anon" var.pos=19887 var.line_nr=769
	// var "has_decl" var.pos=19901 var.line_nr=769
	// var "name" var.pos=19923 var.line_nr=770
	// var "cname" var.pos=20017 var.line_nr=771
	// var "anon" var.pos=20130 var.line_nr=776
	// var "existing_idx" var.pos=20179 var.line_nr=778
	// af parent scope:
	// af parent scope:
	return _t1532;
}

int v__ast__Table_add_placeholder_type(v__ast__Table* t, string name, v__ast__Language language) {
	string modname = _SLIT("");
	if (string_contains(name, _SLIT("."))) {
		modname = string_all_before_last(name, _SLIT("."));
	}
	v__ast__TypeSymbol ph_type = (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind_placeholder,.name = name,.cname = v__util__no_dots(name),.methods = __new_array(0, 1, sizeof(v__ast__Fn)),.mod = modname,.is_public = 0,.language = language,};
	 int _t1533 = v__ast__Table_register_type_symbol(t, ph_type);
	// autofree_scope_vars(pos=20824 line_nr=808 scope.pos=20486 scope.end_pos=20864)
	// var "t" var.pos=20491 var.line_nr=795
	// var "name" var.pos=20521 var.line_nr=795
	// var "language" var.pos=20534 var.line_nr=795
	// var "modname" var.pos=20564 var.line_nr=796
	// str literal
	// var "ph_type" var.pos=20645 var.line_nr=800
	// af parent scope:
	// af parent scope:
	return _t1533;
}

// Attr: [inline]
inline v__ast__Type v__ast__Table_value_type(v__ast__Table* t, v__ast__Type typ) {
	v__ast__TypeSymbol* typ_sym = v__ast__Table_get_final_type_symbol(t, typ);
	if (v__ast__Type_has_flag(typ, v__ast__TypeFlag_variadic)) {
		v__ast__Array array_info = /* as */ *(v__ast__Array*)__as_cast((typ_sym->info)._v__ast__Array,(typ_sym->info)._typ, 395) /*expected idx: 395, name: v.ast.Array */ ;
		 v__ast__Type _t1534 = array_info.elem_type;
		// autofree_scope_vars(pos=21095 line_nr=818 scope.pos=20991 scope.end_pos=21125)
		// var "array_info" var.pos=21058 var.line_nr=817
		// af parent scope:
		// var "t" var.pos=20884 var.line_nr=812
		// var "typ" var.pos=20905 var.line_nr=812
		// var "typ_sym" var.pos=20923 var.line_nr=813
		// af parent scope:
		// af parent scope:
		return _t1534;
	}
	if (typ_sym->kind == v__ast__Kind_array) {
		v__ast__Array info = /* as */ *(v__ast__Array*)__as_cast((typ_sym->info)._v__ast__Array,(typ_sym->info)._typ, 395) /*expected idx: 395, name: v.ast.Array */ ;
		 v__ast__Type _t1535 = info.elem_type;
		// autofree_scope_vars(pos=21211 line_nr=823 scope.pos=21154 scope.end_pos=21235)
		// var "info" var.pos=21180 var.line_nr=822
		// af parent scope:
		// var "t" var.pos=20884 var.line_nr=812
		// var "typ" var.pos=20905 var.line_nr=812
		// var "typ_sym" var.pos=20923 var.line_nr=813
		// af parent scope:
		// af parent scope:
		return _t1535;
	}
	if (typ_sym->kind == v__ast__Kind_array_fixed) {
		v__ast__ArrayFixed info = /* as */ *(v__ast__ArrayFixed*)__as_cast((typ_sym->info)._v__ast__ArrayFixed,(typ_sym->info)._typ, 416) /*expected idx: 416, name: v.ast.ArrayFixed */ ;
		 v__ast__Type _t1536 = info.elem_type;
		// autofree_scope_vars(pos=21310 line_nr=827 scope.pos=21270 scope.end_pos=21334)
		// var "info" var.pos=21274 var.line_nr=826
		// af parent scope:
		// var "t" var.pos=20884 var.line_nr=812
		// var "typ" var.pos=20905 var.line_nr=812
		// var "typ_sym" var.pos=20923 var.line_nr=813
		// af parent scope:
		// af parent scope:
		return _t1536;
	}
	if (typ_sym->kind == v__ast__Kind_map) {
		v__ast__Map info = /* as */ *(v__ast__Map*)__as_cast((typ_sym->info)._v__ast__Map,(typ_sym->info)._typ, 396) /*expected idx: 396, name: v.ast.Map */ ;
		 v__ast__Type _t1537 = info.value_type;
		// autofree_scope_vars(pos=21394 line_nr=831 scope.pos=21361 scope.end_pos=21419)
		// var "info" var.pos=21365 var.line_nr=830
		// af parent scope:
		// var "t" var.pos=20884 var.line_nr=812
		// var "typ" var.pos=20905 var.line_nr=812
		// var "typ_sym" var.pos=20923 var.line_nr=813
		// af parent scope:
		// af parent scope:
		return _t1537;
	}
	if (typ_sym->kind == v__ast__Kind_string && v__ast__Type_is_ptr(typ)) {
		// autofree_scope_vars(pos=21496 line_nr=835 scope.pos=21465 scope.end_pos=21517)
		// af parent scope:
		// var "t" var.pos=20884 var.line_nr=812
		// var "typ" var.pos=20905 var.line_nr=812
		// var "typ_sym" var.pos=20923 var.line_nr=813
		// af parent scope:
		// af parent scope:
		return _const_v__ast__string_type;
	}
	if ((typ_sym->kind == v__ast__Kind_byteptr || typ_sym->kind == v__ast__Kind_string)) {
		// autofree_scope_vars(pos=21562 line_nr=838 scope.pos=21559 scope.end_pos=21581)
		// af parent scope:
		// var "t" var.pos=20884 var.line_nr=812
		// var "typ" var.pos=20905 var.line_nr=812
		// var "typ_sym" var.pos=20923 var.line_nr=813
		// af parent scope:
		// af parent scope:
		return _const_v__ast__byte_type;
	}
	if (v__ast__Type_is_ptr(typ)) {
		 v__ast__Type _t1538 = v__ast__Type_deref(typ);
		// autofree_scope_vars(pos=21657 line_nr=843 scope.pos=21600 scope.end_pos=21678)
		// af parent scope:
		// var "t" var.pos=20884 var.line_nr=812
		// var "typ" var.pos=20905 var.line_nr=812
		// var "typ_sym" var.pos=20923 var.line_nr=813
		// af parent scope:
		// af parent scope:
		return _t1538;
	}
	if (string_eq(typ_sym->name, _SLIT("map_string"))) {
		// autofree_scope_vars(pos=21760 line_nr=847 scope.pos=21757 scope.end_pos=21781)
		// af parent scope:
		// var "t" var.pos=20884 var.line_nr=812
		// var "typ" var.pos=20905 var.line_nr=812
		// var "typ_sym" var.pos=20923 var.line_nr=813
		// af parent scope:
		// af parent scope:
		return _const_v__ast__string_type;
	}
	// autofree_scope_vars(pos=21783 line_nr=849 scope.pos=20883 scope.end_pos=21801)
	// var "t" var.pos=20884 var.line_nr=812
	// var "typ" var.pos=20905 var.line_nr=812
	// var "typ_sym" var.pos=20923 var.line_nr=813
	// af parent scope:
	// af parent scope:
	return _const_v__ast__void_type;
}

// Attr: [inline]
inline v__ast__Type v__ast__Table_mktyp(v__ast__Table* t, v__ast__Type typ) {

	if (typ == (_const_v__ast__float_literal_type)) {
		// autofree_scope_vars(pos=21889 line_nr=855 scope.pos=21869 scope.end_pos=21906)
		// af parent scope:
		// var "t" var.pos=21821 var.line_nr=853
		// var "typ" var.pos=21837 var.line_nr=853
		// af parent scope:
		// af parent scope:
		return _const_v__ast__f64_type;
	}
	else if (typ == (_const_v__ast__int_literal_type)) {
		// autofree_scope_vars(pos=21928 line_nr=856 scope.pos=21910 scope.end_pos=21945)
		// af parent scope:
		// var "t" var.pos=21821 var.line_nr=853
		// var "typ" var.pos=21837 var.line_nr=853
		// af parent scope:
		// af parent scope:
		return _const_v__ast__int_type;
	}
	else {
		// autofree_scope_vars(pos=21955 line_nr=857 scope.pos=21949 scope.end_pos=21967)
		// af parent scope:
		// var "t" var.pos=21821 var.line_nr=853
		// var "typ" var.pos=21837 var.line_nr=853
		// af parent scope:
		// af parent scope:
		return typ;
	};
	return 0;
}

void v__ast__Table_register_fn_gen_type(v__ast__Table* t, string fn_name, Array_v__ast__Type types) {
	Array_Array_v__ast__Type a = (*(Array_Array_v__ast__Type*)map_get(ADDR(map, t->fn_gen_types), &(string[]){fn_name}, &(Array_Array_v__ast__Type[]){ __new_array(0, 1, sizeof(Array_v__ast__Type)) }));
	if ((Array_Array_v__ast__Type_contains(a, types))) {
		return;
	}
	array_push(&a, _MOV((Array_v__ast__Type[]){ types }));
	map_set(&t->fn_gen_types, &(string[]){fn_name}, &(Array_Array_v__ast__Type[]) { a });
}

bool v__ast__Table_sumtype_has_variant(v__ast__Table* t, v__ast__Type parent, v__ast__Type variant) {
	v__ast__TypeSymbol* parent_sym = v__ast__Table_get_type_symbol(t, parent);
	if (parent_sym->kind == v__ast__Kind_sum_type) {
		v__ast__SumType parent_info = /* as */ *(v__ast__SumType*)__as_cast((parent_sym->info)._v__ast__SumType,(parent_sym->info)._typ, 411) /*expected idx: 411, name: v.ast.SumType */ ;
		// FOR IN array
		for (int _t1540 = 0; _t1540 < parent_info.variants.len; ++_t1540) {
			v__ast__Type v = ((v__ast__Type*)parent_info.variants.data)[_t1540];
			if (v__ast__Type_idx(v) == v__ast__Type_idx(variant)) {
				 bool _t1541 = true;
				// autofree_scope_vars(pos=22568 line_nr=878 scope.pos=22563 scope.end_pos=22584)
				// af parent scope:
				// var "v" var.pos=22504 var.line_nr=876
				// skipping tmp var "v"
				// af parent scope:
				// var "parent_info" var.pos=22456 var.line_nr=875
				// af parent scope:
				// var "t" var.pos=22314 var.line_nr=872
				// var "parent" var.pos=22344 var.line_nr=872
				// var "variant" var.pos=22357 var.line_nr=872
				// var "parent_sym" var.pos=22379 var.line_nr=873
				// af parent scope:
				// af parent scope:
				return _t1541;
			}
		}
	}
	 bool _t1542 = false;
	// autofree_scope_vars(pos=22593 line_nr=882 scope.pos=22313 scope.end_pos=22607)
	// var "t" var.pos=22314 var.line_nr=872
	// var "parent" var.pos=22344 var.line_nr=872
	// var "variant" var.pos=22357 var.line_nr=872
	// var "parent_sym" var.pos=22379 var.line_nr=873
	// af parent scope:
	// af parent scope:
	return _t1542;
}

Array_string v__ast__Table_known_type_names(v__ast__Table* t) {
	Array_string res = __new_array_with_default(0, t->type_idxs.len, sizeof(string), 0);
	// FOR IN map
	Map_string_int _t1543 = t->type_idxs;
	int _t1545 = _t1543.key_values.len;
	for (int _t1544 = 0; _t1544 < _t1545; ++_t1544 ) {
		int _t1546 = _t1543.key_values.len - _t1545;
		_t1545 = _t1543.key_values.len;
		if (_t1546 < 0) {
			_t1544 = -1;
			continue;
		}
		if (!DenseArray_has_index(&_t1543.key_values, _t1544)) {continue;}
		int idx = (*(int*)DenseArray_value(&_t1543.key_values, _t1544));
		if (!(idx == 0 || idx == _const_v__ast__int_literal_type_idx || idx == _const_v__ast__float_literal_type_idx) && v__ast__Table_known_type_idx(t, idx)) {
			array_push(&res, _MOV((string[]){ string_clone(v__ast__Table_type_to_str(t, idx)) }));
		}
	}
	// autofree_scope_vars(pos=23013 line_nr=894 scope.pos=22665 scope.end_pos=23025)
	// var "t" var.pos=22666 var.line_nr=886
	// var "res" var.pos=22711 var.line_nr=887
	// af parent scope:
	// af parent scope:
	return res;
}

bool v__ast__Table_has_deep_child_no_ref(v__ast__Table* t, v__ast__TypeSymbol* ts, string name) {
	if ((ts->info)._typ == 409 /* v.ast.Struct */) {
		// FOR IN array
		for (int _t1548 = 0; _t1548 < (*ts->info._v__ast__Struct).fields.len; ++_t1548) {
			v__ast__StructField field = ((v__ast__StructField*)(*ts->info._v__ast__Struct).fields.data)[_t1548];
			v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(t, field.typ);
			if (!v__ast__Type_is_ptr(field.typ) && (string_eq(sym->name, name) || v__ast__Table_has_deep_child_no_ref(t, sym, name))) {
				 bool _t1549 = true;
				// autofree_scope_vars(pos=23523 line_nr=905 scope.pos=23518 scope.end_pos=23539)
				// af parent scope:
				// var "field" var.pos=23367 var.line_nr=902
				// skipping tmp var "field"
				// var "sym" var.pos=23396 var.line_nr=903
				// af parent scope:
				// af parent scope:
				// var "t" var.pos=23269 var.line_nr=900
				// var "ts" var.pos=23301 var.line_nr=900
				// var "name" var.pos=23317 var.line_nr=900
				// af parent scope:
				// af parent scope:
				return _t1549;
			}
		}
	}
	 bool _t1550 = false;
	// autofree_scope_vars(pos=23548 line_nr=909 scope.pos=23268 scope.end_pos=23562)
	// var "t" var.pos=23269 var.line_nr=900
	// var "ts" var.pos=23301 var.line_nr=900
	// var "name" var.pos=23317 var.line_nr=900
	// af parent scope:
	// af parent scope:
	return _t1550;
}

v__ast__Type v__ast__Table_bitsize_to_type(v__ast__Table* t, int bit_size) {

	if (bit_size == (8)) {
		// autofree_scope_vars(pos=23826 line_nr=927 scope.pos=23820 scope.end_pos=23844)
		// af parent scope:
		// var "t" var.pos=23754 var.line_nr=924
		// var "bit_size" var.pos=23779 var.line_nr=924
		// af parent scope:
		// af parent scope:
		return _const_v__ast__i8_type;
	}
	else if (bit_size == (16)) {
		// autofree_scope_vars(pos=23855 line_nr=930 scope.pos=23848 scope.end_pos=23874)
		// af parent scope:
		// var "t" var.pos=23754 var.line_nr=924
		// var "bit_size" var.pos=23779 var.line_nr=924
		// af parent scope:
		// af parent scope:
		return _const_v__ast__i16_type;
	}
	else if (bit_size == (32)) {
		// autofree_scope_vars(pos=23885 line_nr=933 scope.pos=23878 scope.end_pos=23904)
		// af parent scope:
		// var "t" var.pos=23754 var.line_nr=924
		// var "bit_size" var.pos=23779 var.line_nr=924
		// af parent scope:
		// af parent scope:
		return _const_v__ast__int_type;
	}
	else if (bit_size == (64)) {
		// autofree_scope_vars(pos=23915 line_nr=936 scope.pos=23908 scope.end_pos=23934)
		// af parent scope:
		// var "t" var.pos=23754 var.line_nr=924
		// var "bit_size" var.pos=23779 var.line_nr=924
		// af parent scope:
		// af parent scope:
		return _const_v__ast__i64_type;
	}
	else {
		if (bit_size % 8 != 0) {
			v_panic(_SLIT("compiler bug: bitsizes must be multiples of 8"));
		}
		 v__ast__Type _t1551 = v__ast__new_type(v__ast__Table_find_or_register_array_fixed(t, _const_v__ast__byte_type, bit_size / 8));
		// autofree_scope_vars(pos=24106 line_nr=942 scope.pos=23938 scope.end_pos=24182)
		// af parent scope:
		// var "t" var.pos=23754 var.line_nr=924
		// var "bit_size" var.pos=23779 var.line_nr=924
		// af parent scope:
		// af parent scope:
		return _t1551;
	};
	return 0;
}

Option_v__ast__Type v__ast__Table_resolve_generic_by_names(v__ast__Table* t, v__ast__Type generic_type, Array_string generic_names, Array_v__ast__Type generic_types) {
	v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(t, generic_type);
	if ((Array_string_contains(generic_names, sym->name))) {
		int index = Array_string_index(generic_names, sym->name);
		v__ast__Type typ = (*(v__ast__Type*)/*ee elem_typ */array_get(generic_types, index));
		typ = v__ast__Type_set_nr_muls(typ, v__ast__Type_nr_muls(generic_type));
		if (v__ast__Type_has_flag(generic_type, v__ast__TypeFlag_optional)) {
			typ = v__ast__Type_set_flag(typ, v__ast__TypeFlag_optional);
		}
		Option_v__ast__Type _t1552;
		opt_ok(&(v__ast__Type[]) { typ }, (Option*)(&_t1552), sizeof(v__ast__Type));
		// autofree_scope_vars(pos=24838 line_nr=959 scope.pos=24635 scope.end_pos=24851)
		// var "index" var.pos=24639 var.line_nr=953
		// var "typ" var.pos=24684 var.line_nr=954
		// af parent scope:
		// var "t" var.pos=24454 var.line_nr=950
		// var "generic_type" var.pos=24488 var.line_nr=950
		// var "generic_names" var.pos=24507 var.line_nr=950
		// var "generic_types" var.pos=24531 var.line_nr=950
		// var "sym" var.pos=24566 var.line_nr=951
		// af parent scope:
		// af parent scope:
		return _t1552;
	} else if (sym->kind == v__ast__Kind_array) {
		v__ast__Array info = /* as */ *(v__ast__Array*)__as_cast((sym->info)._v__ast__Array,(sym->info)._typ, 395) /*expected idx: 395, name: v.ast.Array */ ;
		v__ast__Type elem_type = info.elem_type;
		v__ast__TypeSymbol* elem_sym = v__ast__Table_get_type_symbol(t, elem_type);
		int dims = 1;
		for (;;) {
			if (!((elem_sym->info)._typ == 395 /* v.ast.Array */)) break;
			elem_type = (*elem_sym->info._v__ast__Array).elem_type;
			elem_sym = v__ast__Table_get_type_symbol(t, elem_type);
			dims++;
		}
		Option_v__ast__Type _t1553;
		if (_t1553 = v__ast__Table_resolve_generic_by_names(t, elem_type, generic_names, generic_types), _t1553.state == 0) {
			v__ast__Type typ = *(v__ast__Type*)_t1553.data;
			int idx = v__ast__Table_find_or_register_array_with_dims(t, typ, dims);
			v__ast__Type array_typ = v__ast__new_type(idx);
			Option_v__ast__Type _t1554;
			opt_ok(&(v__ast__Type[]) { array_typ }, (Option*)(&_t1554), sizeof(v__ast__Type));
			// autofree_scope_vars(pos=25308 line_nr=973 scope.pos=25218 scope.end_pos=25328)
			// var "idx" var.pos=25223 var.line_nr=971
			// var "array_typ" var.pos=25279 var.line_nr=972
			// af parent scope:
			// var "typ" var.pos=25143 var.line_nr=970
			// af parent scope:
			// var "info" var.pos=24884 var.line_nr=961
			// var "elem_type" var.pos=24916 var.line_nr=962
			// var "elem_sym" var.pos=24950 var.line_nr=963
			// var "dims" var.pos=24997 var.line_nr=964
			// af parent scope:
			// var "t" var.pos=24454 var.line_nr=950
			// var "generic_type" var.pos=24488 var.line_nr=950
			// var "generic_names" var.pos=24507 var.line_nr=950
			// var "generic_types" var.pos=24531 var.line_nr=950
			// var "sym" var.pos=24566 var.line_nr=951
			// af parent scope:
			// af parent scope:
			return _t1554;
		}
	} else if (sym->kind == v__ast__Kind_chan) {
		v__ast__Chan info = /* as */ *(v__ast__Chan*)__as_cast((sym->info)._v__ast__Chan,(sym->info)._typ, 414) /*expected idx: 414, name: v.ast.Chan */ ;
		Option_v__ast__Type _t1555;
		if (_t1555 = v__ast__Table_resolve_generic_by_names(t, info.elem_type, generic_names, generic_types), _t1555.state == 0) {
			v__ast__Type typ = *(v__ast__Type*)_t1555.data;
			int idx = v__ast__Table_find_or_register_chan(t, typ, v__ast__Type_nr_muls(typ) > 0);
			v__ast__Type chan_typ = v__ast__new_type(idx);
			Option_v__ast__Type _t1556;
			opt_ok(&(v__ast__Type[]) { chan_typ }, (Option*)(&_t1556), sizeof(v__ast__Type));
			// autofree_scope_vars(pos=25564 line_nr=980 scope.pos=25473 scope.end_pos=25583)
			// var "idx" var.pos=25478 var.line_nr=978
			// var "chan_typ" var.pos=25536 var.line_nr=979
			// af parent scope:
			// var "typ" var.pos=25393 var.line_nr=977
			// af parent scope:
			// var "info" var.pos=25363 var.line_nr=976
			// af parent scope:
			// var "t" var.pos=24454 var.line_nr=950
			// var "generic_type" var.pos=24488 var.line_nr=950
			// var "generic_names" var.pos=24507 var.line_nr=950
			// var "generic_types" var.pos=24531 var.line_nr=950
			// var "sym" var.pos=24566 var.line_nr=951
			// af parent scope:
			// af parent scope:
			return _t1556;
		}
	} else if ((sym->info)._typ == 417 /* v.ast.MultiReturn */) {
		Array_v__ast__Type types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
		bool type_changed = false;
		// FOR IN array
		for (int _t1557 = 0; _t1557 < (*sym->info._v__ast__MultiReturn).types.len; ++_t1557) {
			v__ast__Type ret_type = ((v__ast__Type*)(*sym->info._v__ast__MultiReturn).types.data)[_t1557];
			Option_v__ast__Type _t1558;
			if (_t1558 = v__ast__Table_resolve_generic_by_names(t, ret_type, generic_names, generic_types), _t1558.state == 0) {
				v__ast__Type typ = *(v__ast__Type*)_t1558.data;
				array_push(&types, _MOV((v__ast__Type[]){ typ }));
				type_changed = true;
			} else {
				IError err = _t1558.err;
				array_push(&types, _MOV((v__ast__Type[]){ ret_type }));
			}
		}
		if (type_changed) {
			int idx = v__ast__Table_find_or_register_multi_return(t, types);
			v__ast__Type typ = v__ast__new_type(idx);
			Option_v__ast__Type _t1561;
			opt_ok(&(v__ast__Type[]) { typ }, (Option*)(&_t1561), sizeof(v__ast__Type));
			// autofree_scope_vars(pos=25974 line_nr=996 scope.pos=25897 scope.end_pos=25988)
			// var "idx" var.pos=25902 var.line_nr=994
			// var "typ" var.pos=25951 var.line_nr=995
			// af parent scope:
			// var "types" var.pos=25632 var.line_nr=983
			// var "type_changed" var.pos=25656 var.line_nr=984
			// af parent scope:
			// var "t" var.pos=24454 var.line_nr=950
			// var "generic_type" var.pos=24488 var.line_nr=950
			// var "generic_names" var.pos=24507 var.line_nr=950
			// var "generic_types" var.pos=24531 var.line_nr=950
			// var "sym" var.pos=24566 var.line_nr=951
			// af parent scope:
			// af parent scope:
			return _t1561;
		}
	} else if ((sym->info)._typ == 396 /* v.ast.Map */) {
		bool type_changed = false;
		v__ast__Type unwrapped_key_type = (*sym->info._v__ast__Map).key_type;
		v__ast__Type unwrapped_value_type = (*sym->info._v__ast__Map).value_type;
		Option_v__ast__Type _t1562;
		if (_t1562 = v__ast__Table_resolve_generic_by_names(t, (*sym->info._v__ast__Map).key_type, generic_names, generic_types), _t1562.state == 0) {
			v__ast__Type typ = *(v__ast__Type*)_t1562.data;
			unwrapped_key_type = typ;
			type_changed = true;
		}
		Option_v__ast__Type _t1563;
		if (_t1563 = v__ast__Table_resolve_generic_by_names(t, (*sym->info._v__ast__Map).value_type, generic_names, generic_types), _t1563.state == 0) {
			v__ast__Type typ = *(v__ast__Type*)_t1563.data;
			unwrapped_value_type = typ;
			type_changed = true;
		}
		if (type_changed) {
			int idx = v__ast__Table_find_or_register_map(t, unwrapped_key_type, unwrapped_value_type);
			Option_v__ast__Type _t1564;
			opt_ok(&(v__ast__Type[]) { v__ast__new_type(idx) }, (Option*)(&_t1564), sizeof(v__ast__Type));
			// autofree_scope_vars(pos=26538 line_nr=1012 scope.pos=26459 scope.end_pos=26562)
			// var "idx" var.pos=26464 var.line_nr=1011
			// af parent scope:
			// var "type_changed" var.pos=26029 var.line_nr=999
			// var "unwrapped_key_type" var.pos=26057 var.line_nr=1000
			// var "unwrapped_value_type" var.pos=26103 var.line_nr=1001
			// af parent scope:
			// var "t" var.pos=24454 var.line_nr=950
			// var "generic_type" var.pos=24488 var.line_nr=950
			// var "generic_names" var.pos=24507 var.line_nr=950
			// var "generic_types" var.pos=24531 var.line_nr=950
			// var "sym" var.pos=24566 var.line_nr=951
			// af parent scope:
			// af parent scope:
			return _t1564;
		}
	}
	return (Option_v__ast__Type){ .state=2, .err=_const_none__ };
}

Option_v__ast__Type v__ast__Table_resolve_generic_by_types(v__ast__Table* t, v__ast__Type generic_type, Array_v__ast__Type from_types, Array_v__ast__Type to_types) {
	v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(t, generic_type);
	if ((Array_v__ast__Type_contains(from_types, generic_type))) {
		int index = Array_v__ast__Type_index(from_types, generic_type);
		v__ast__Type typ = (*(v__ast__Type*)/*ee elem_typ */array_get(to_types, index));
		typ = v__ast__Type_set_nr_muls(typ, v__ast__Type_nr_muls(generic_type));
		if (v__ast__Type_has_flag(generic_type, v__ast__TypeFlag_optional)) {
			typ = v__ast__Type_set_flag(typ, v__ast__TypeFlag_optional);
		}
		Option_v__ast__Type _t1565;
		opt_ok(&(v__ast__Type[]) { typ }, (Option*)(&_t1565), sizeof(v__ast__Type));
		// autofree_scope_vars(pos=27218 line_nr=1030 scope.pos=27019 scope.end_pos=27231)
		// var "index" var.pos=27023 var.line_nr=1024
		// var "typ" var.pos=27069 var.line_nr=1025
		// af parent scope:
		// var "t" var.pos=26847 var.line_nr=1021
		// var "generic_type" var.pos=26881 var.line_nr=1021
		// var "from_types" var.pos=26900 var.line_nr=1021
		// var "to_types" var.pos=26919 var.line_nr=1021
		// var "sym" var.pos=26949 var.line_nr=1022
		// af parent scope:
		// af parent scope:
		return _t1565;
	} else if (sym->kind == v__ast__Kind_array) {
		v__ast__Array info = /* as */ *(v__ast__Array*)__as_cast((sym->info)._v__ast__Array,(sym->info)._typ, 395) /*expected idx: 395, name: v.ast.Array */ ;
		v__ast__Type elem_type = info.elem_type;
		v__ast__TypeSymbol* elem_sym = v__ast__Table_get_type_symbol(t, elem_type);
		int dims = 1;
		for (;;) {
			if (!((elem_sym->info)._typ == 395 /* v.ast.Array */)) break;
			elem_type = (*elem_sym->info._v__ast__Array).elem_type;
			elem_sym = v__ast__Table_get_type_symbol(t, elem_type);
			dims++;
		}
		Option_v__ast__Type _t1566;
		if (_t1566 = v__ast__Table_resolve_generic_by_types(t, elem_type, from_types, to_types), _t1566.state == 0) {
			v__ast__Type typ = *(v__ast__Type*)_t1566.data;
			int idx = v__ast__Table_find_or_register_array_with_dims(t, typ, dims);
			Option_v__ast__Type _t1567;
			opt_ok(&(v__ast__Type[]) { v__ast__new_type(idx) }, (Option*)(&_t1567), sizeof(v__ast__Type));
			// autofree_scope_vars(pos=27650 line_nr=1043 scope.pos=27590 scope.end_pos=27674)
			// var "idx" var.pos=27595 var.line_nr=1042
			// af parent scope:
			// var "typ" var.pos=27523 var.line_nr=1041
			// af parent scope:
			// var "info" var.pos=27264 var.line_nr=1032
			// var "elem_type" var.pos=27296 var.line_nr=1033
			// var "elem_sym" var.pos=27330 var.line_nr=1034
			// var "dims" var.pos=27377 var.line_nr=1035
			// af parent scope:
			// var "t" var.pos=26847 var.line_nr=1021
			// var "generic_type" var.pos=26881 var.line_nr=1021
			// var "from_types" var.pos=26900 var.line_nr=1021
			// var "to_types" var.pos=26919 var.line_nr=1021
			// var "sym" var.pos=26949 var.line_nr=1022
			// af parent scope:
			// af parent scope:
			return _t1567;
		}
	} else if (sym->kind == v__ast__Kind_chan) {
		v__ast__Chan info = /* as */ *(v__ast__Chan*)__as_cast((sym->info)._v__ast__Chan,(sym->info)._typ, 414) /*expected idx: 414, name: v.ast.Chan */ ;
		Option_v__ast__Type _t1568;
		if (_t1568 = v__ast__Table_resolve_generic_by_types(t, info.elem_type, from_types, to_types), _t1568.state == 0) {
			v__ast__Type typ = *(v__ast__Type*)_t1568.data;
			int idx = v__ast__Table_find_or_register_chan(t, typ, v__ast__Type_nr_muls(typ) > 0);
			Option_v__ast__Type _t1569;
			opt_ok(&(v__ast__Type[]) { v__ast__new_type(idx) }, (Option*)(&_t1569), sizeof(v__ast__Type));
			// autofree_scope_vars(pos=27873 line_nr=1049 scope.pos=27811 scope.end_pos=27897)
			// var "idx" var.pos=27816 var.line_nr=1048
			// af parent scope:
			// var "typ" var.pos=27739 var.line_nr=1047
			// af parent scope:
			// var "info" var.pos=27709 var.line_nr=1046
			// af parent scope:
			// var "t" var.pos=26847 var.line_nr=1021
			// var "generic_type" var.pos=26881 var.line_nr=1021
			// var "from_types" var.pos=26900 var.line_nr=1021
			// var "to_types" var.pos=26919 var.line_nr=1021
			// var "sym" var.pos=26949 var.line_nr=1022
			// af parent scope:
			// af parent scope:
			return _t1569;
		}
	} else if ((sym->info)._typ == 417 /* v.ast.MultiReturn */) {
		Array_v__ast__Type types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
		bool type_changed = false;
		// FOR IN array
		for (int _t1570 = 0; _t1570 < (*sym->info._v__ast__MultiReturn).types.len; ++_t1570) {
			v__ast__Type ret_type = ((v__ast__Type*)(*sym->info._v__ast__MultiReturn).types.data)[_t1570];
			Option_v__ast__Type _t1571;
			if (_t1571 = v__ast__Table_resolve_generic_by_types(t, ret_type, from_types, to_types), _t1571.state == 0) {
				v__ast__Type typ = *(v__ast__Type*)_t1571.data;
				array_push(&types, _MOV((v__ast__Type[]){ typ }));
				type_changed = true;
			} else {
				IError err = _t1571.err;
				array_push(&types, _MOV((v__ast__Type[]){ ret_type }));
			}
		}
		if (type_changed) {
			int idx = v__ast__Table_find_or_register_multi_return(t, types);
			Option_v__ast__Type _t1574;
			opt_ok(&(v__ast__Type[]) { v__ast__new_type(idx) }, (Option*)(&_t1574), sizeof(v__ast__Type));
			// autofree_scope_vars(pos=28256 line_nr=1064 scope.pos=28203 scope.end_pos=28280)
			// var "idx" var.pos=28208 var.line_nr=1063
			// af parent scope:
			// var "types" var.pos=27946 var.line_nr=1052
			// var "type_changed" var.pos=27970 var.line_nr=1053
			// af parent scope:
			// var "t" var.pos=26847 var.line_nr=1021
			// var "generic_type" var.pos=26881 var.line_nr=1021
			// var "from_types" var.pos=26900 var.line_nr=1021
			// var "to_types" var.pos=26919 var.line_nr=1021
			// var "sym" var.pos=26949 var.line_nr=1022
			// af parent scope:
			// af parent scope:
			return _t1574;
		}
	} else if ((sym->info)._typ == 396 /* v.ast.Map */) {
		bool type_changed = false;
		v__ast__Type unwrapped_key_type = (*sym->info._v__ast__Map).key_type;
		v__ast__Type unwrapped_value_type = (*sym->info._v__ast__Map).value_type;
		Option_v__ast__Type _t1575;
		if (_t1575 = v__ast__Table_resolve_generic_by_types(t, (*sym->info._v__ast__Map).key_type, from_types, to_types), _t1575.state == 0) {
			v__ast__Type typ = *(v__ast__Type*)_t1575.data;
			unwrapped_key_type = typ;
			type_changed = true;
		}
		Option_v__ast__Type _t1576;
		if (_t1576 = v__ast__Table_resolve_generic_by_types(t, (*sym->info._v__ast__Map).value_type, from_types, to_types), _t1576.state == 0) {
			v__ast__Type typ = *(v__ast__Type*)_t1576.data;
			unwrapped_value_type = typ;
			type_changed = true;
		}
		if (type_changed) {
			int idx = v__ast__Table_find_or_register_map(t, unwrapped_key_type, unwrapped_value_type);
			Option_v__ast__Type _t1577;
			opt_ok(&(v__ast__Type[]) { v__ast__new_type(idx) }, (Option*)(&_t1577), sizeof(v__ast__Type));
			// autofree_scope_vars(pos=28814 line_nr=1080 scope.pos=28735 scope.end_pos=28838)
			// var "idx" var.pos=28740 var.line_nr=1079
			// af parent scope:
			// var "type_changed" var.pos=28321 var.line_nr=1067
			// var "unwrapped_key_type" var.pos=28349 var.line_nr=1068
			// var "unwrapped_value_type" var.pos=28395 var.line_nr=1069
			// af parent scope:
			// var "t" var.pos=26847 var.line_nr=1021
			// var "generic_type" var.pos=26881 var.line_nr=1021
			// var "from_types" var.pos=26900 var.line_nr=1021
			// var "to_types" var.pos=26919 var.line_nr=1021
			// var "sym" var.pos=26949 var.line_nr=1022
			// af parent scope:
			// af parent scope:
			return _t1577;
		}
	}
	return (Option_v__ast__Type){ .state=2, .err=_const_none__ };
}

void v__ast__Table_generic_struct_insts_to_concrete(v__ast__Table* t) {
	// FOR IN array
	for (int idx = 0; idx < t->type_symbols.len; ++idx) {
		v__ast__TypeSymbol* typ = &(*(v__ast__TypeSymbol*)/*ee elem_typ */array_get(t->type_symbols, idx));
		if (typ->kind == v__ast__Kind_generic_struct_inst) {
			v__ast__GenericStructInst info = /* as */ *(v__ast__GenericStructInst*)__as_cast((typ->info)._v__ast__GenericStructInst,(typ->info)._typ, 419) /*expected idx: 419, name: v.ast.GenericStructInst */ ;
			v__ast__TypeSymbol parent = (*(v__ast__TypeSymbol*)/*ee elem_typ */array_get(t->type_symbols, info.parent_idx));
			if (parent.kind == v__ast__Kind_placeholder) {
				typ->kind = v__ast__Kind_placeholder;
				continue;
			}
			v__ast__Struct parent_info = /* as */ *(v__ast__Struct*)__as_cast((parent.info)._v__ast__Struct,(parent.info)._typ, 409) /*expected idx: 409, name: v.ast.Struct */ ;
			Array_v__ast__StructField fields = array_clone(&parent_info.fields);
			if (parent_info.generic_types.len == info.generic_types.len) {
				for (int i = 0; i < fields.len; ++i) {
					Option_v__ast__Type _t1578;
					if (_t1578 = v__ast__Table_resolve_generic_by_types(t, (*(v__ast__StructField*)/*ee elem_typ */array_get(fields, i)).typ, parent_info.generic_types, info.generic_types), _t1578.state == 0) {
						v__ast__Type t_typ = *(v__ast__Type*)_t1578.data;
						(*(v__ast__StructField*)/*ee elem_typ */array_get(fields, i)).typ = t_typ;
					}
				}
				parent_info.generic_types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
				parent_info.concrete_types = array_clone(&info.generic_types);
				parent_info.fields = fields;
				parent_info.parent_type = v__ast__Type_set_flag(v__ast__new_type(info.parent_idx), v__ast__TypeFlag_generic);
				typ->is_public = true;
				typ->kind = v__ast__Kind_struct_;
				typ->info = v__ast__Struct_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__Struct, (parent_info)));
			}
		}
	}
}

// TypeDecl
// TypeDecl
v__ast__Language v__ast__pref_arch_to_table_language(v__pref__Arch pref_arch) {
	 v__ast__Language _t1579 = ((pref_arch == (v__pref__Arch_amd64)) ? (v__ast__Language_amd64) : (pref_arch == (v__pref__Arch_aarch64)) ? (v__ast__Language_aarch64) : (pref_arch == (v__pref__Arch_aarch32)) ? (v__ast__Language_aarch32) : (pref_arch == (v__pref__Arch_rv64)) ? (v__ast__Language_rv64) : (pref_arch == (v__pref__Arch_rv32)) ? (v__ast__Language_rv32) : (pref_arch == (v__pref__Arch_i386)) ? (v__ast__Language_i386) : (v__ast__Language_v));
	// autofree_scope_vars(pos=866 line_nr=34 scope.pos=806 scope.end_pos=1124)
	// var "pref_arch" var.pos=834 var.line_nr=33
	// af parent scope:
	// af parent scope:
	return _t1579;
}

string v__ast__ShareType_str(v__ast__ShareType t) {

	if (t == (v__ast__ShareType_mut_t)) {
		 string _t1580 = _SLIT("mut");
		// autofree_scope_vars(pos=2120 line_nr=101 scope.pos=2112 scope.end_pos=2134)
		// af parent scope:
		// var "t" var.pos=2071 var.line_nr=99
		// af parent scope:
		// af parent scope:
		return _t1580;
	}
	else if (t == (v__ast__ShareType_shared_t)) {
		 string _t1581 = _SLIT("shared");
		// autofree_scope_vars(pos=2149 line_nr=102 scope.pos=2138 scope.end_pos=2166)
		// af parent scope:
		// var "t" var.pos=2071 var.line_nr=99
		// af parent scope:
		// af parent scope:
		return _t1581;
	}
	else if (t == (v__ast__ShareType_atomic_t)) {
		 string _t1582 = _SLIT("atomic");
		// autofree_scope_vars(pos=2181 line_nr=103 scope.pos=2170 scope.end_pos=2198)
		// af parent scope:
		// var "t" var.pos=2071 var.line_nr=99
		// af parent scope:
		// af parent scope:
		return _t1582;
	};
	return (string){.str=(byteptr)"", .is_lit=1};
}

string v__ast__Type_atomic_typename(v__ast__Type t) {
	int idx = v__ast__Type_idx(t);

	if (idx == (_const_v__ast__u32_type_idx)) {
		 string _t1583 = _SLIT("atomic_uint");
		// autofree_scope_vars(pos=2338 line_nr=111 scope.pos=2320 scope.end_pos=2360)
		// af parent scope:
		// var "t" var.pos=2254 var.line_nr=108
		// var "idx" var.pos=2290 var.line_nr=109
		// af parent scope:
		// af parent scope:
		return _t1583;
	}
	else if (idx == (_const_v__ast__int_type_idx)) {
		 string _t1584 = _SLIT("atomic_int");
		// autofree_scope_vars(pos=2382 line_nr=112 scope.pos=2364 scope.end_pos=2403)
		// af parent scope:
		// var "t" var.pos=2254 var.line_nr=108
		// var "idx" var.pos=2290 var.line_nr=109
		// af parent scope:
		// af parent scope:
		return _t1584;
	}
	else if (idx == (_const_v__ast__u64_type_idx)) {
		 string _t1585 = _SLIT("atomic_ullong");
		// autofree_scope_vars(pos=2425 line_nr=113 scope.pos=2407 scope.end_pos=2449)
		// af parent scope:
		// var "t" var.pos=2254 var.line_nr=108
		// var "idx" var.pos=2290 var.line_nr=109
		// af parent scope:
		// af parent scope:
		return _t1585;
	}
	else if (idx == (_const_v__ast__i64_type_idx)) {
		 string _t1586 = _SLIT("atomic_llong");
		// autofree_scope_vars(pos=2471 line_nr=114 scope.pos=2453 scope.end_pos=2494)
		// af parent scope:
		// var "t" var.pos=2254 var.line_nr=108
		// var "idx" var.pos=2290 var.line_nr=109
		// af parent scope:
		// af parent scope:
		return _t1586;
	}
	else {
		 string _t1587 = _SLIT("unknown_atomic");
		// autofree_scope_vars(pos=2504 line_nr=115 scope.pos=2498 scope.end_pos=2529)
		// af parent scope:
		// var "t" var.pos=2254 var.line_nr=108
		// var "idx" var.pos=2290 var.line_nr=109
		// af parent scope:
		// af parent scope:
		return _t1587;
	};
	return (string){.str=(byteptr)"", .is_lit=1};
}

v__ast__ShareType v__ast__sharetype_from_flags(bool is_shared, bool is_atomic) {
	 v__ast__ShareType _t1588 = ((v__ast__ShareType)(((((int)(is_atomic)) << 1) | ((int)(is_shared)))));
	// autofree_scope_vars(pos=2609 line_nr=120 scope.pos=2544 scope.end_pos=2667)
	// var "is_shared" var.pos=2565 var.line_nr=119
	// var "is_atomic" var.pos=2581 var.line_nr=119
	// af parent scope:
	// af parent scope:
	return _t1588;
}

v__ast__ShareType v__ast__Type_share(v__ast__Type t) {
	 v__ast__ShareType _t1589 = v__ast__sharetype_from_flags(v__ast__Type_has_flag(t, v__ast__TypeFlag_shared_f), v__ast__Type_has_flag(t, v__ast__TypeFlag_atomic_f));
	// autofree_scope_vars(pos=2706 line_nr=124 scope.pos=2677 scope.end_pos=2781)
	// var "t" var.pos=2678 var.line_nr=123
	// af parent scope:
	// af parent scope:
	return _t1589;
}

// Attr: [inline]
inline int v__ast__Type_idx(v__ast__Type t) {
	 int _t1590 = (((u16)(t)) & 0xffff);
	// autofree_scope_vars(pos=2854 line_nr=130 scope.pos=2833 scope.end_pos=2878)
	// var "t" var.pos=2834 var.line_nr=129
	// af parent scope:
	// af parent scope:
	return _t1590;
}

// Attr: [inline]
inline bool v__ast__Type_is_void(v__ast__Type t) {
	 bool _t1591 = v__ast__Type_alias_eq(t, _const_v__ast__void_type);
	// autofree_scope_vars(pos=2923 line_nr=135 scope.pos=2897 scope.end_pos=2950)
	// var "t" var.pos=2898 var.line_nr=134
	// af parent scope:
	// af parent scope:
	return _t1591;
}

// Attr: [inline]
inline bool v__ast__Type_is_full(v__ast__Type t) {
	 bool _t1592 = t != 0 && !v__ast__Type_alias_eq(t, _const_v__ast__void_type);
	// autofree_scope_vars(pos=2995 line_nr=140 scope.pos=2969 scope.end_pos=3032)
	// var "t" var.pos=2970 var.line_nr=139
	// af parent scope:
	// af parent scope:
	return _t1592;
}

// Attr: [inline]
inline int v__ast__Type_nr_muls(v__ast__Type t) {
	 int _t1593 = ((((int)(t)) >> 16) & 0xff);
	// autofree_scope_vars(pos=3102 line_nr=146 scope.pos=3077 scope.end_pos=3132)
	// var "t" var.pos=3078 var.line_nr=145
	// af parent scope:
	// af parent scope:
	return _t1593;
}

// Attr: [inline]
inline bool v__ast__Type_is_ptr(v__ast__Type t) {
	 bool _t1594 = ((((int)(t)) >> 16) & 0xff) > 0;
	// autofree_scope_vars(pos=3326 line_nr=154 scope.pos=3198 scope.end_pos=3360)
	// var "t" var.pos=3199 var.line_nr=151
	// af parent scope:
	// af parent scope:
	return _t1594;
}

// Attr: [inline]
inline v__ast__Type v__ast__Type_set_nr_muls(v__ast__Type t, int nr_muls) {
	if (nr_muls < 0 || nr_muls > 255) {
		v_panic(_SLIT("set_nr_muls: nr_muls must be between 0 & 255"));
	}
	 v__ast__Type _t1595 = ((((int)(t)) & 0xff00ffff) | (nr_muls << 16));
	// autofree_scope_vars(pos=3550 line_nr=163 scope.pos=3415 scope.end_pos=3596)
	// var "t" var.pos=3416 var.line_nr=159
	// var "nr_muls" var.pos=3436 var.line_nr=159
	// af parent scope:
	// af parent scope:
	return _t1595;
}

// Attr: [inline]
inline v__ast__Type v__ast__Type_to_ptr(v__ast__Type t) {
	int nr_muls = ((((int)(t)) >> 16) & 0xff);
	if (nr_muls == 255) {
		v_panic(_SLIT("to_ptr: nr_muls is already at max of 255"));
	}
	 v__ast__Type _t1596 = ((((int)(t)) & 0xff00ffff) | ((nr_muls + 1) << 16));
	// autofree_scope_vars(pos=3793 line_nr=173 scope.pos=3658 scope.end_pos=3845)
	// var "t" var.pos=3659 var.line_nr=168
	// var "nr_muls" var.pos=3684 var.line_nr=169
	// af parent scope:
	// af parent scope:
	return _t1596;
}

// Attr: [inline]
inline v__ast__Type v__ast__Type_deref(v__ast__Type t) {
	int nr_muls = ((((int)(t)) >> 16) & 0xff);
	if (nr_muls == 0) {
		v_panic(_STR("deref: type `%"PRId32"\000` is not a pointer", 2, t));
	}
	 v__ast__Type _t1597 = ((((int)(t)) & 0xff00ffff) | ((nr_muls - 1) << 16));
	// autofree_scope_vars(pos=4031 line_nr=183 scope.pos=3906 scope.end_pos=4083)
	// var "t" var.pos=3907 var.line_nr=178
	// var "nr_muls" var.pos=3931 var.line_nr=179
	// af parent scope:
	// af parent scope:
	return _t1597;
}

// Attr: [inline]
inline v__ast__Type v__ast__Type_set_flag(v__ast__Type t, v__ast__TypeFlag flag) {
	 v__ast__Type _t1598 = (((int)(t)) | (1 << (((int)(flag)) + 24)));
	// autofree_scope_vars(pos=4178 line_nr=189 scope.pos=4138 scope.end_pos=4219)
	// var "t" var.pos=4139 var.line_nr=188
	// var "flag" var.pos=4156 var.line_nr=188
	// af parent scope:
	// af parent scope:
	return _t1598;
}

// Attr: [inline]
inline v__ast__Type v__ast__Type_clear_flag(v__ast__Type t, v__ast__TypeFlag flag) {
	 v__ast__Type _t1599 = (((int)(t)) & ~(1 << (((int)(flag)) + 24)));
	// autofree_scope_vars(pos=4318 line_nr=195 scope.pos=4276 scope.end_pos=4360)
	// var "t" var.pos=4277 var.line_nr=194
	// var "flag" var.pos=4296 var.line_nr=194
	// af parent scope:
	// af parent scope:
	return _t1599;
}

// Attr: [inline]
inline v__ast__Type v__ast__Type_clear_flags(v__ast__Type t) {
	 v__ast__Type _t1600 = (((int)(t)) & 0xffffff);
	// autofree_scope_vars(pos=4428 line_nr=201 scope.pos=4398 scope.end_pos=4454)
	// var "t" var.pos=4399 var.line_nr=200
	// af parent scope:
	// af parent scope:
	return _t1600;
}

// Attr: [inline]
inline bool v__ast__Type_has_flag(v__ast__Type t, v__ast__TypeFlag flag) {
	 bool _t1601 = (((int)(t)) & (1 << (((int)(flag)) + 24))) > 0;
	// autofree_scope_vars(pos=4552 line_nr=207 scope.pos=4512 scope.end_pos=4597)
	// var "t" var.pos=4513 var.line_nr=206
	// var "flag" var.pos=4530 var.line_nr=206
	// af parent scope:
	// af parent scope:
	return _t1601;
}

Array_string v__ast__TypeSymbol_debug(v__ast__TypeSymbol* ts) {
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	array_push(&res, _MOV((string[]){ string_clone(_STR("parent_idx: %"PRId32"", 1, ts->parent_idx)) }));
	array_push(&res, _MOV((string[]){ string_clone(_STR("mod: %.*s", 1, ts->mod)) }));
	array_push(&res, _MOV((string[]){ string_clone(_STR("name: %.*s", 1, ts->name)) }));
	array_push(&res, _MOV((string[]){ string_clone(_STR("cname: %.*s", 1, ts->cname)) }));
	array_push(&res, _MOV((string[]){ string_clone(_STR("info: %.*s", 1, v__ast__TypeInfo_str(ts->info))) }));
	array_push(&res, _MOV((string[]){ string_clone(_STR("kind: %.*s", 1, v__ast__Kind_str(ts->kind))) }));
	array_push(&res, _MOV((string[]){ string_clone(_STR("is_public: %.*s", 1, ts->is_public ? _SLIT("true") : _SLIT("false"))) }));
	array_push(&res, _MOV((string[]){ string_clone(_STR("language: %.*s", 1, v__ast__Language_str(ts->language))) }));
	Array_v__ast__Fn _t1611_orig = ts->methods;
	int _t1611_len = _t1611_orig.len;
	Array_string _t1611 = __new_array(0, _t1611_len, sizeof(string));

	for (int _t1612 = 0; _t1612 < _t1611_len; ++_t1612) {
		v__ast__Fn it = ((v__ast__Fn*) _t1611_orig.data)[_t1612];
		string ti = v__ast__Fn_str(it);
		array_push(&_t1611, &ti);
	}
	
	array_push(&res, _MOV((string[]){ string_clone(string_add(_STR("methods (%"PRId32"\000): ", 2, ts->methods.len), Array_string_join(_t1611, _SLIT(", ")))) }));
	// autofree_scope_vars(pos=4971 line_nr=221 scope.pos=4607 scope.end_pos=4983)
	// var "ts" var.pos=4608 var.line_nr=210
	// var "res" var.pos=4647 var.line_nr=211
	// af parent scope:
	// af parent scope:
	return res;
}

Array_string v__ast__Type_debug(v__ast__Type t) {
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	array_push(&res, _MOV((string[]){ string_clone(_STR("idx: %5"PRId32"", 1, v__ast__Type_idx(t))) }));
	array_push(&res, _MOV((string[]){ string_clone(_STR("type: %10"PRId32"", 1, t)) }));
	array_push(&res, _MOV((string[]){ string_clone(_STR("nr_muls: %"PRId32"", 1, v__ast__Type_nr_muls(t))) }));
	if (v__ast__Type_has_flag(t, v__ast__TypeFlag_optional)) {
		array_push(&res, _MOV((string[]){ string_clone(_SLIT("optional")) }));
	}
	if (v__ast__Type_has_flag(t, v__ast__TypeFlag_variadic)) {
		array_push(&res, _MOV((string[]){ string_clone(_SLIT("variadic")) }));
	}
	if (v__ast__Type_has_flag(t, v__ast__TypeFlag_generic)) {
		array_push(&res, _MOV((string[]){ string_clone(_SLIT("generic")) }));
	}
	if (v__ast__Type_has_flag(t, v__ast__TypeFlag_shared_f)) {
		array_push(&res, _MOV((string[]){ string_clone(_SLIT("shared_f")) }));
	}
	if (v__ast__Type_has_flag(t, v__ast__TypeFlag_atomic_f)) {
		array_push(&res, _MOV((string[]){ string_clone(_SLIT("atomic_f")) }));
	}
	// autofree_scope_vars(pos=5381 line_nr=244 scope.pos=4993 scope.end_pos=5393)
	// var "t" var.pos=4994 var.line_nr=224
	// var "res" var.pos=5026 var.line_nr=225
	// af parent scope:
	// af parent scope:
	return res;
}

// Attr: [inline]
inline v__ast__Type v__ast__Type_derive(v__ast__Type t, v__ast__Type t_from) {
	 v__ast__Type _t1621 = (((0xffff0000 & t_from)) | ((u16)(t)));
	// autofree_scope_vars(pos=5508 line_nr=250 scope.pos=5472 scope.end_pos=5547)
	// var "t" var.pos=5473 var.line_nr=249
	// var "t_from" var.pos=5488 var.line_nr=249
	// af parent scope:
	// af parent scope:
	return _t1621;
}

// Attr: [inline]
inline v__ast__Type v__ast__new_type(int idx) {
	if (idx < 1 || idx > 65535) {
		v_panic(_SLIT("new_type: idx must be between 1 & 65535"));
	}
	// autofree_scope_vars(pos=5726 line_nr=259 scope.pos=5618 scope.end_pos=5738)
	// var "idx" var.pos=5627 var.line_nr=255
	// af parent scope:
	// af parent scope:
	return idx;
}

// Attr: [inline]
inline v__ast__Type v__ast__new_type_ptr(int idx, int nr_muls) {
	if (idx < 1 || idx > 65535) {
		v_panic(_SLIT("new_type_ptr: idx must be between 1 & 65535"));
	}
	if (nr_muls < 0 || nr_muls > 255) {
		v_panic(_SLIT("new_type_ptr: nr_muls must be between 0 & 255"));
	}
	 v__ast__Type _t1622 = ((nr_muls << 16) | ((u16)(idx)));
	// autofree_scope_vars(pos=6060 line_nr=271 scope.pos=5836 scope.end_pos=6095)
	// var "idx" var.pos=5849 var.line_nr=264
	// var "nr_muls" var.pos=5858 var.line_nr=264
	// af parent scope:
	// af parent scope:
	return _t1622;
}

// Attr: [inline]
inline bool v__ast__Type_is_pointer(v__ast__Type typ) {
	 bool _t1623 = (Array_int_contains(_const_v__ast__pointer_type_idxs, v__ast__Type_idx(typ)));
	// autofree_scope_vars(pos=6199 line_nr=277 scope.pos=6114 scope.end_pos=6242)
	// var "typ" var.pos=6115 var.line_nr=275
	// af parent scope:
	// af parent scope:
	return _t1623;
}

// Attr: [inline]
inline bool v__ast__Type_is_float(v__ast__Type typ) {
	 bool _t1624 = (Array_int_contains(_const_v__ast__float_type_idxs, v__ast__Type_clear_flags(typ)));
	// autofree_scope_vars(pos=6290 line_nr=282 scope.pos=6261 scope.end_pos=6339)
	// var "typ" var.pos=6262 var.line_nr=281
	// af parent scope:
	// af parent scope:
	return _t1624;
}

// Attr: [inline]
inline bool v__ast__Type_is_int(v__ast__Type typ) {
	 bool _t1625 = (Array_int_contains(_const_v__ast__integer_type_idxs, v__ast__Type_clear_flags(typ)));
	// autofree_scope_vars(pos=6385 line_nr=287 scope.pos=6358 scope.end_pos=6436)
	// var "typ" var.pos=6359 var.line_nr=286
	// af parent scope:
	// af parent scope:
	return _t1625;
}

// Attr: [inline]
inline bool v__ast__Type_is_int_valptr(v__ast__Type typ) {
	 bool _t1626 = (Array_int_contains(_const_v__ast__integer_type_idxs, v__ast__Type_idx(typ)));
	// autofree_scope_vars(pos=6489 line_nr=292 scope.pos=6455 scope.end_pos=6532)
	// var "typ" var.pos=6456 var.line_nr=291
	// af parent scope:
	// af parent scope:
	return _t1626;
}

// Attr: [inline]
inline bool v__ast__Type_is_float_valptr(v__ast__Type typ) {
	 bool _t1627 = (Array_int_contains(_const_v__ast__float_type_idxs, v__ast__Type_idx(typ)));
	// autofree_scope_vars(pos=6587 line_nr=297 scope.pos=6551 scope.end_pos=6628)
	// var "typ" var.pos=6552 var.line_nr=296
	// af parent scope:
	// af parent scope:
	return _t1627;
}

// Attr: [inline]
inline bool v__ast__Type_is_pure_int(v__ast__Type typ) {
	 bool _t1628 = (Array_int_contains(_const_v__ast__integer_type_idxs, ((int)(typ))));
	// autofree_scope_vars(pos=6679 line_nr=302 scope.pos=6647 scope.end_pos=6721)
	// var "typ" var.pos=6648 var.line_nr=301
	// af parent scope:
	// af parent scope:
	return _t1628;
}

// Attr: [inline]
inline bool v__ast__Type_is_pure_float(v__ast__Type typ) {
	 bool _t1629 = (Array_int_contains(_const_v__ast__float_type_idxs, ((int)(typ))));
	// autofree_scope_vars(pos=6774 line_nr=307 scope.pos=6740 scope.end_pos=6814)
	// var "typ" var.pos=6741 var.line_nr=306
	// af parent scope:
	// af parent scope:
	return _t1629;
}

// Attr: [inline]
inline bool v__ast__Type_is_signed(v__ast__Type typ) {
	 bool _t1630 = (Array_int_contains(_const_v__ast__signed_integer_type_idxs, v__ast__Type_idx(typ)));
	// autofree_scope_vars(pos=6863 line_nr=312 scope.pos=6833 scope.end_pos=6913)
	// var "typ" var.pos=6834 var.line_nr=311
	// af parent scope:
	// af parent scope:
	return _t1630;
}

// Attr: [inline]
inline bool v__ast__Type_is_unsigned(v__ast__Type typ) {
	 bool _t1631 = (Array_int_contains(_const_v__ast__unsigned_integer_type_idxs, v__ast__Type_idx(typ)));
	// autofree_scope_vars(pos=6964 line_nr=317 scope.pos=6932 scope.end_pos=7016)
	// var "typ" var.pos=6933 var.line_nr=316
	// af parent scope:
	// af parent scope:
	return _t1631;
}

// Attr: [inline]
inline bool v__ast__Type_is_int_literal(v__ast__Type typ) {
	 bool _t1632 = ((int)(typ)) == _const_v__ast__int_literal_type_idx;
	// autofree_scope_vars(pos=7070 line_nr=322 scope.pos=7035 scope.end_pos=7115)
	// var "typ" var.pos=7036 var.line_nr=321
	// af parent scope:
	// af parent scope:
	return _t1632;
}

// Attr: [inline]
inline bool v__ast__Type_is_number(v__ast__Type typ) {
	 bool _t1633 = (Array_int_contains(_const_v__ast__number_type_idxs, v__ast__Type_clear_flags(typ)));
	// autofree_scope_vars(pos=7164 line_nr=327 scope.pos=7134 scope.end_pos=7214)
	// var "typ" var.pos=7135 var.line_nr=326
	// af parent scope:
	// af parent scope:
	return _t1633;
}

bool v__ast__Type_is_number_or_literal(v__ast__Type typ) {
	bool res = (Array_int_contains(_const_v__ast__number_type_idxs, ((int)(typ))));
	eprintln(_STR("> is_number_or_literal typ: %.*s\000 | res: %.*s", 2, Array_string_str(v__ast__Type_debug(typ)), res ? _SLIT("true") : _SLIT("false")));
	// autofree_scope_vars(pos=7372 line_nr=333 scope.pos=7224 scope.end_pos=7384)
	// var "typ" var.pos=7225 var.line_nr=330
	// var "res" var.pos=7266 var.line_nr=331
	// af parent scope:
	// af parent scope:
	return res;
}

// Attr: [inline]
inline bool v__ast__Type_is_string(v__ast__Type typ) {
	 bool _t1634 = (Array_int_contains(_const_v__ast__string_type_idxs, v__ast__Type_idx(typ)));
	// autofree_scope_vars(pos=7433 line_nr=338 scope.pos=7403 scope.end_pos=7475)
	// var "typ" var.pos=7404 var.line_nr=337
	// af parent scope:
	// af parent scope:
	return _t1634;
}

v__ast__Kind v__ast__Table_type_kind(v__ast__Table* t, v__ast__Type typ) {
	if (v__ast__Type_nr_muls(typ) > 0 || v__ast__Type_has_flag(typ, v__ast__TypeFlag_optional)) {
		 v__ast__Kind _t1635 = v__ast__Kind_placeholder;
		// autofree_scope_vars(pos=11207 line_nr=440 scope.pos=11204 scope.end_pos=11233)
		// af parent scope:
		// var "t" var.pos=11118 var.line_nr=438
		// var "typ" var.pos=11138 var.line_nr=438
		// af parent scope:
		// af parent scope:
		return _t1635;
	}
	 v__ast__Kind _t1636 = v__ast__Table_get_type_symbol(t, typ)->kind;
	// autofree_scope_vars(pos=11235 line_nr=442 scope.pos=11117 scope.end_pos=11271)
	// var "t" var.pos=11118 var.line_nr=438
	// var "typ" var.pos=11138 var.line_nr=438
	// af parent scope:
	// af parent scope:
	return _t1636;
}

string v__ast__TypeSymbol_str(v__ast__TypeSymbol* t) {
	 string _t1637 = t->name;
	// autofree_scope_vars(pos=11650 line_nr=488 scope.pos=11619 scope.end_pos=11665)
	// var "t" var.pos=11620 var.line_nr=487
	// af parent scope:
	// af parent scope:
	return _t1637;
}

// Attr: [inline]
inline v__ast__Enum v__ast__TypeSymbol_enum_info(v__ast__TypeSymbol* t) {
	if (t->info._typ == 420 /* v.ast.Enum */) {
		 v__ast__Enum _t1638 = (*t->info._v__ast__Enum);
		// autofree_scope_vars(pos=11747 line_nr=494 scope.pos=11741 scope.end_pos=11762)
		// af parent scope:
		// var "t" var.pos=11685 var.line_nr=492
		// af parent scope:
		// af parent scope:
		return _t1638;
	}
	else {
		v_panic(_STR("TypeSymbol.enum_info(): no enum info for type: %.*s", 1, t->name));
	};
	return (v__ast__Enum){.vals = __new_array(0, 1, sizeof(string)),};
}

// Attr: [inline]
inline v__ast__MultiReturn v__ast__TypeSymbol_mr_info(v__ast__TypeSymbol* t) {
	if (t->info._typ == 417 /* v.ast.MultiReturn */) {
		 v__ast__MultiReturn _t1639 = (*t->info._v__ast__MultiReturn);
		// autofree_scope_vars(pos=11936 line_nr=502 scope.pos=11923 scope.end_pos=11951)
		// af parent scope:
		// var "t" var.pos=11862 var.line_nr=500
		// af parent scope:
		// af parent scope:
		return _t1639;
	}
	else {
		v_panic(_STR("TypeSymbol.mr_info(): no multi return info for type: %.*s", 1, t->name));
	};
	return (v__ast__MultiReturn){.types = __new_array(0, 1, sizeof(v__ast__Type)),};
}

// Attr: [inline]
inline v__ast__Array v__ast__TypeSymbol_array_info(v__ast__TypeSymbol* t) {
	if (t->info._typ == 395 /* v.ast.Array */) {
		 v__ast__Array _t1640 = (*t->info._v__ast__Array);
		// autofree_scope_vars(pos=12122 line_nr=510 scope.pos=12115 scope.end_pos=12137)
		// af parent scope:
		// var "t" var.pos=12057 var.line_nr=508
		// af parent scope:
		// af parent scope:
		return _t1640;
	}
	else {
		v_panic(_STR("TypeSymbol.array_info(): no array info for type: %.*s", 1, t->name));
	};
	return (v__ast__Array){0};
}

// Attr: [inline]
inline v__ast__ArrayFixed v__ast__TypeSymbol_array_fixed_info(v__ast__TypeSymbol* t) {
	if (t->info._typ == 416 /* v.ast.ArrayFixed */) {
		 v__ast__ArrayFixed _t1641 = (*t->info._v__ast__ArrayFixed);
		// autofree_scope_vars(pos=12320 line_nr=518 scope.pos=12308 scope.end_pos=12335)
		// af parent scope:
		// var "t" var.pos=12239 var.line_nr=516
		// af parent scope:
		// af parent scope:
		return _t1641;
	}
	else {
		v_panic(_STR("TypeSymbol.array_fixed(): no array fixed info for type: %.*s", 1, t->name));
	};
	return (v__ast__ArrayFixed){0};
}

// Attr: [inline]
inline v__ast__Chan v__ast__TypeSymbol_chan_info(v__ast__TypeSymbol* t) {
	if (t->info._typ == 414 /* v.ast.Chan */) {
		 v__ast__Chan _t1642 = (*t->info._v__ast__Chan);
		// autofree_scope_vars(pos=12506 line_nr=526 scope.pos=12500 scope.end_pos=12521)
		// af parent scope:
		// var "t" var.pos=12444 var.line_nr=524
		// af parent scope:
		// af parent scope:
		return _t1642;
	}
	else {
		v_panic(_STR("TypeSymbol.chan_info(): no chan info for type: %.*s", 1, t->name));
	};
	return (v__ast__Chan){0};
}

// Attr: [inline]
inline v__ast__Thread v__ast__TypeSymbol_thread_info(v__ast__TypeSymbol* t) {
	if (t->info._typ == 415 /* v.ast.Thread */) {
		 v__ast__Thread _t1643 = (*t->info._v__ast__Thread);
		// autofree_scope_vars(pos=12689 line_nr=534 scope.pos=12681 scope.end_pos=12704)
		// af parent scope:
		// var "t" var.pos=12621 var.line_nr=532
		// af parent scope:
		// af parent scope:
		return _t1643;
	}
	else {
		v_panic(_STR("TypeSymbol.thread_info(): no thread info for type: %.*s", 1, t->name));
	};
	return (v__ast__Thread){0};
}

// Attr: [inline]
inline v__ast__Map v__ast__TypeSymbol_map_info(v__ast__TypeSymbol* t) {
	if (t->info._typ == 396 /* v.ast.Map */) {
		 v__ast__Map _t1644 = (*t->info._v__ast__Map);
		// autofree_scope_vars(pos=12867 line_nr=542 scope.pos=12862 scope.end_pos=12882)
		// af parent scope:
		// var "t" var.pos=12808 var.line_nr=540
		// af parent scope:
		// af parent scope:
		return _t1644;
	}
	else {
		v_panic(_STR("TypeSymbol.map_info(): no map info for type: %.*s", 1, t->name));
	};
	return (v__ast__Map){0};
}

// Attr: [inline]
inline v__ast__Struct v__ast__TypeSymbol_struct_info(v__ast__TypeSymbol* t) {
	if (t->info._typ == 409 /* v.ast.Struct */) {
		 v__ast__Struct _t1645 = (*t->info._v__ast__Struct);
		// autofree_scope_vars(pos=13048 line_nr=550 scope.pos=13040 scope.end_pos=13063)
		// af parent scope:
		// var "t" var.pos=12980 var.line_nr=548
		// af parent scope:
		// af parent scope:
		return _t1645;
	}
	else {
		v_panic(_STR("TypeSymbol.struct_info(): no struct info for type: %.*s", 1, t->name));
	};
	return (v__ast__Struct){.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.embeds = __new_array(0, 1, sizeof(v__ast__Type)),.fields = __new_array(0, 1, sizeof(v__ast__StructField)),.generic_types = __new_array(0, 1, sizeof(v__ast__Type)),.concrete_types = __new_array(0, 1, sizeof(v__ast__Type)),};
}

// Attr: [inline]
inline v__ast__SumType v__ast__TypeSymbol_sumtype_info(v__ast__TypeSymbol* t) {
	if (t->info._typ == 411 /* v.ast.SumType */) {
		 v__ast__SumType _t1646 = (*t->info._v__ast__SumType);
		// autofree_scope_vars(pos=13238 line_nr=558 scope.pos=13229 scope.end_pos=13253)
		// af parent scope:
		// var "t" var.pos=13167 var.line_nr=556
		// af parent scope:
		// af parent scope:
		return _t1646;
	}
	else {
		v_panic(_STR("TypeSymbol.sumtype_info(): no sumtype info for type: %.*s", 1, t->name));
	};
	return (v__ast__SumType){.variants = __new_array(0, 1, sizeof(v__ast__Type)),.fields = __new_array(0, 1, sizeof(v__ast__StructField)),};
}

void v__ast__Table_register_builtin_type_symbols(v__ast__Table* t) {
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind_placeholder,.name = _SLIT("reserved_0"),.cname = (string){.str=(byteptr)"", .is_lit=1},.methods = __new_array(0, 1, sizeof(v__ast__Fn)),.mod = (string){.str=(byteptr)"", .is_lit=1},.is_public = 0,.language = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind_void,.name = _SLIT("void"),.cname = _SLIT("void"),.methods = __new_array(0, 1, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind_voidptr,.name = _SLIT("voidptr"),.cname = _SLIT("voidptr"),.methods = __new_array(0, 1, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind_byteptr,.name = _SLIT("byteptr"),.cname = _SLIT("byteptr"),.methods = __new_array(0, 1, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind_charptr,.name = _SLIT("charptr"),.cname = _SLIT("charptr"),.methods = __new_array(0, 1, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind_i8,.name = _SLIT("i8"),.cname = _SLIT("i8"),.methods = __new_array(0, 1, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind_i16,.name = _SLIT("i16"),.cname = _SLIT("i16"),.methods = __new_array(0, 1, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind_int,.name = _SLIT("int"),.cname = _SLIT("int"),.methods = __new_array(0, 1, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind_i64,.name = _SLIT("i64"),.cname = _SLIT("i64"),.methods = __new_array(0, 1, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind_byte,.name = _SLIT("byte"),.cname = _SLIT("byte"),.methods = __new_array(0, 1, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind_u16,.name = _SLIT("u16"),.cname = _SLIT("u16"),.methods = __new_array(0, 1, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind_u32,.name = _SLIT("u32"),.cname = _SLIT("u32"),.methods = __new_array(0, 1, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind_u64,.name = _SLIT("u64"),.cname = _SLIT("u64"),.methods = __new_array(0, 1, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind_f32,.name = _SLIT("f32"),.cname = _SLIT("f32"),.methods = __new_array(0, 1, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind_f64,.name = _SLIT("f64"),.cname = _SLIT("f64"),.methods = __new_array(0, 1, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind_char,.name = _SLIT("char"),.cname = _SLIT("char"),.methods = __new_array(0, 1, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind_bool,.name = _SLIT("bool"),.cname = _SLIT("bool"),.methods = __new_array(0, 1, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind_none_,.name = _SLIT("none"),.cname = _SLIT("none"),.methods = __new_array(0, 1, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind_string,.name = _SLIT("string"),.cname = _SLIT("string"),.methods = __new_array(0, 1, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind_ustring,.name = _SLIT("ustring"),.cname = _SLIT("ustring"),.methods = __new_array(0, 1, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind_rune,.name = _SLIT("rune"),.cname = _SLIT("rune"),.methods = __new_array(0, 1, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind_array,.name = _SLIT("array"),.cname = _SLIT("array"),.methods = __new_array(0, 1, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind_map,.name = _SLIT("map"),.cname = _SLIT("map"),.methods = __new_array(0, 1, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind_chan,.name = _SLIT("chan"),.cname = _SLIT("chan"),.methods = __new_array(0, 1, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind_size_t,.name = _SLIT("size_t"),.cname = _SLIT("size_t"),.methods = __new_array(0, 1, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind_any,.name = _SLIT("any"),.cname = _SLIT("any"),.methods = __new_array(0, 1, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind_float_literal,.name = _SLIT("float literal"),.cname = _SLIT("float_literal"),.methods = __new_array(0, 1, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind_int_literal,.name = _SLIT("int literal"),.cname = _SLIT("int_literal"),.methods = __new_array(0, 1, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = v__ast__Thread_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__Thread, ((v__ast__Thread){.return_type = _const_v__ast__void_type,}))),.kind = v__ast__Kind_thread,.name = _SLIT("thread"),.cname = _SLIT("__v_thread"),.methods = __new_array(0, 1, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,});
	v__ast__Table_register_type_symbol(t, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind_interface_,.name = _SLIT("IError"),.cname = _SLIT("IError"),.methods = __new_array(0, 1, sizeof(v__ast__Fn)),.mod = _SLIT("builtin"),.is_public = 0,.language = 0,});
}

// Attr: [inline]
inline bool v__ast__TypeSymbol_is_pointer(v__ast__TypeSymbol* t) {
	 bool _t1647 = (t->kind == v__ast__Kind_byteptr || t->kind == v__ast__Kind_charptr || t->kind == v__ast__Kind_voidptr);
	// autofree_scope_vars(pos=16200 line_nr=623 scope.pos=16164 scope.end_pos=16249)
	// var "t" var.pos=16165 var.line_nr=622
	// af parent scope:
	// af parent scope:
	return _t1647;
}

// Attr: [inline]
inline bool v__ast__TypeSymbol_is_int(v__ast__TypeSymbol* t) {
	 bool _t1648 = (t->kind == v__ast__Kind_i8 || t->kind == v__ast__Kind_i16 || t->kind == v__ast__Kind_int || t->kind == v__ast__Kind_i64 || t->kind == v__ast__Kind_byte || t->kind == v__ast__Kind_u16 || t->kind == v__ast__Kind_u32 || t->kind == v__ast__Kind_u64 || t->kind == v__ast__Kind_int_literal || t->kind == v__ast__Kind_rune);
	// autofree_scope_vars(pos=16300 line_nr=628 scope.pos=16268 scope.end_pos=16388)
	// var "t" var.pos=16269 var.line_nr=627
	// af parent scope:
	// af parent scope:
	return _t1648;
}

// Attr: [inline]
inline bool v__ast__TypeSymbol_is_float(v__ast__TypeSymbol* t) {
	 bool _t1649 = (t->kind == v__ast__Kind_f32 || t->kind == v__ast__Kind_f64 || t->kind == v__ast__Kind_float_literal);
	// autofree_scope_vars(pos=16441 line_nr=633 scope.pos=16407 scope.end_pos=16488)
	// var "t" var.pos=16408 var.line_nr=632
	// af parent scope:
	// af parent scope:
	return _t1649;
}

// Attr: [inline]
inline bool v__ast__TypeSymbol_is_string(v__ast__TypeSymbol* t) {
	 bool _t1650 = (t->kind == v__ast__Kind_string || t->kind == v__ast__Kind_ustring);
	// autofree_scope_vars(pos=16542 line_nr=638 scope.pos=16507 scope.end_pos=16580)
	// var "t" var.pos=16508 var.line_nr=637
	// af parent scope:
	// af parent scope:
	return _t1650;
}

// Attr: [inline]
inline bool v__ast__TypeSymbol_is_number(v__ast__TypeSymbol* t) {
	 bool _t1651 = v__ast__TypeSymbol_is_int(t) || v__ast__TypeSymbol_is_float(t);
	// autofree_scope_vars(pos=16634 line_nr=643 scope.pos=16599 scope.end_pos=16669)
	// var "t" var.pos=16600 var.line_nr=642
	// af parent scope:
	// af parent scope:
	return _t1651;
}

// Attr: [inline]
inline bool v__ast__TypeSymbol_is_primitive(v__ast__TypeSymbol* t) {
	 bool _t1652 = v__ast__TypeSymbol_is_number(t) || v__ast__TypeSymbol_is_pointer(t) || v__ast__TypeSymbol_is_string(t);
	// autofree_scope_vars(pos=16726 line_nr=648 scope.pos=16688 scope.end_pos=16783)
	// var "t" var.pos=16689 var.line_nr=647
	// af parent scope:
	// af parent scope:
	return _t1652;
}

// Attr: [inline]
inline bool v__ast__TypeSymbol_is_builtin(v__ast__TypeSymbol* t) {
	 bool _t1653 = string_eq(t->mod, _SLIT("builtin"));
	// autofree_scope_vars(pos=16838 line_nr=653 scope.pos=16802 scope.end_pos=16865)
	// var "t" var.pos=16803 var.line_nr=652
	// af parent scope:
	// af parent scope:
	return _t1653;
}

string v__ast__Kind_str(v__ast__Kind k) {
	string k_str = ((k == (v__ast__Kind_placeholder)) ? (_SLIT("placeholder")) : (k == (v__ast__Kind_void)) ? (_SLIT("void")) : (k == (v__ast__Kind_voidptr)) ? (_SLIT("voidptr")) : (k == (v__ast__Kind_charptr)) ? (_SLIT("charptr")) : (k == (v__ast__Kind_byteptr)) ? (_SLIT("byteptr")) : (k == (v__ast__Kind_struct_)) ? (_SLIT("struct")) : (k == (v__ast__Kind_int)) ? (_SLIT("int")) : (k == (v__ast__Kind_i8)) ? (_SLIT("i8")) : (k == (v__ast__Kind_i16)) ? (_SLIT("i16")) : (k == (v__ast__Kind_i64)) ? (_SLIT("i64")) : (k == (v__ast__Kind_byte)) ? (_SLIT("byte")) : (k == (v__ast__Kind_u16)) ? (_SLIT("u16")) : (k == (v__ast__Kind_u32)) ? (_SLIT("u32")) : (k == (v__ast__Kind_u64)) ? (_SLIT("u64")) : (k == (v__ast__Kind_int_literal)) ? (_SLIT("int_literal")) : (k == (v__ast__Kind_f32)) ? (_SLIT("f32")) : (k == (v__ast__Kind_f64)) ? (_SLIT("f64")) : (k == (v__ast__Kind_float_literal)) ? (_SLIT("float_literal")) : (k == (v__ast__Kind_string)) ? (_SLIT("string")) : (k == (v__ast__Kind_char)) ? (_SLIT("char")) : (k == (v__ast__Kind_bool)) ? (_SLIT("bool")) : (k == (v__ast__Kind_size_t)) ? (_SLIT("size_t")) : (k == (v__ast__Kind_none_)) ? (_SLIT("none")) : (k == (v__ast__Kind_array)) ? (_SLIT("array")) : (k == (v__ast__Kind_array_fixed)) ? (_SLIT("array_fixed")) : (k == (v__ast__Kind_map)) ? (_SLIT("map")) : (k == (v__ast__Kind_chan)) ? (_SLIT("chan")) : (k == (v__ast__Kind_multi_return)) ? (_SLIT("multi_return")) : (k == (v__ast__Kind_sum_type)) ? (_SLIT("sum_type")) : (k == (v__ast__Kind_alias)) ? (_SLIT("alias")) : (k == (v__ast__Kind_enum_)) ? (_SLIT("enum")) : (k == (v__ast__Kind_any)) ? (_SLIT("any")) : (k == (v__ast__Kind_function)) ? (_SLIT("function")) : (k == (v__ast__Kind_interface_)) ? (_SLIT("interface")) : (k == (v__ast__Kind_ustring)) ? (_SLIT("ustring")) : (k == (v__ast__Kind_generic_struct_inst)) ? (_SLIT("generic_struct_inst")) : (k == (v__ast__Kind_rune)) ? (_SLIT("rune")) : (k == (v__ast__Kind_aggregate)) ? (_SLIT("aggregate")) : (_SLIT("thread")));
	// autofree_scope_vars(pos=17880 line_nr=699 scope.pos=16926 scope.end_pos=17894)
	// var "k" var.pos=16927 var.line_nr=657
	// var "k_str" var.pos=16951 var.line_nr=658
	// af parent scope:
	// af parent scope:
	return k_str;
}

string Array_v__ast__Kind_str(Array_v__ast__Kind kinds) {
	string kinds_str = _SLIT("");
	// FOR IN array
	for (int i = 0; i < kinds.len; ++i) {
		v__ast__Kind k = ((v__ast__Kind*)kinds.data)[i];
		kinds_str = /*f*/string_add(kinds_str, v__ast__Kind_str(k));
		if (i < kinds.len - 1) {
			kinds_str = /*f*/string_add(kinds_str, _SLIT("_"));
		}
	}
	// autofree_scope_vars(pos=18051 line_nr=710 scope.pos=17904 scope.end_pos=18069)
	// var "kinds" var.pos=17905 var.line_nr=702
	// var "kinds_str" var.pos=17939 var.line_nr=703
	// str literal
	// af parent scope:
	// af parent scope:
	return kinds_str;
}

bool v__ast__StructField_equals(v__ast__StructField* f, v__ast__StructField* o) {
	 bool _t1654 = string_eq(f->name, o->name) && v__ast__Type_alias_eq(f->typ, o->typ) && f->is_pub == o->is_pub && f->is_global == o->is_global;
	// autofree_scope_vars(pos=19751 line_nr=789 scope.pos=19379 scope.end_pos=19848)
	// var "f" var.pos=19380 var.line_nr=784
	// var "o" var.pos=19403 var.line_nr=784
	// af parent scope:
	// af parent scope:
	return _t1654;
}

string v__ast__Table_type_to_str(v__ast__Table* t, v__ast__Type typ) {
	 string _t1655 = v__ast__Table_type_to_str_using_aliases(t, typ, new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string));
	// autofree_scope_vars(pos=20337 line_nr=833 scope.pos=20295 scope.end_pos=20399)
	// var "t" var.pos=20296 var.line_nr=832
	// var "typ" var.pos=20318 var.line_nr=832
	// af parent scope:
	// af parent scope:
	return _t1655;
}

string v__ast__Table_type_to_code(v__ast__Table* mytable, v__ast__Type t) {

	if (t == (_const_v__ast__int_literal_type) || t == (_const_v__ast__float_literal_type)) {
		 string _t1656 = v__ast__Kind_str(v__ast__Table_get_type_symbol(mytable, t)->kind);
		// autofree_scope_vars(pos=20550 line_nr=839 scope.pos=20504 scope.end_pos=20596)
		// af parent scope:
		// var "mytable" var.pos=20445 var.line_nr=837
		// var "t" var.pos=20474 var.line_nr=837
		// af parent scope:
		// af parent scope:
		return _t1656;
	}
	else {
		 string _t1657 = v__ast__Table_type_to_str_using_aliases(mytable, t, new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string));
		// autofree_scope_vars(pos=20606 line_nr=840 scope.pos=20600 scope.end_pos=20672)
		// af parent scope:
		// var "mytable" var.pos=20445 var.line_nr=837
		// var "t" var.pos=20474 var.line_nr=837
		// af parent scope:
		// af parent scope:
		return _t1657;
	};
	return (string){.str=(byteptr)"", .is_lit=1};
}

string v__ast__Table_type_to_str_using_aliases(v__ast__Table* t, v__ast__Type typ, Map_string_string import_aliases) {
	v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(t, typ);
	string res = sym->name;

	if (sym->kind == (v__ast__Kind_int_literal) || sym->kind == (v__ast__Kind_float_literal)) {
		res = sym->name;
	}
	else if (sym->kind == (v__ast__Kind_i8) || sym->kind == (v__ast__Kind_i16) || sym->kind == (v__ast__Kind_int) || sym->kind == (v__ast__Kind_i64) || sym->kind == (v__ast__Kind_byte) || sym->kind == (v__ast__Kind_u16) || sym->kind == (v__ast__Kind_u32) || sym->kind == (v__ast__Kind_u64) || sym->kind == (v__ast__Kind_f32) || sym->kind == (v__ast__Kind_f64) || sym->kind == (v__ast__Kind_char) || sym->kind == (v__ast__Kind_rune) || sym->kind == (v__ast__Kind_string) || sym->kind == (v__ast__Kind_bool) || sym->kind == (v__ast__Kind_none_) || sym->kind == (v__ast__Kind_byteptr) || sym->kind == (v__ast__Kind_voidptr) || sym->kind == (v__ast__Kind_charptr)) {
		if (sym->kind == v__ast__Kind_byteptr) {
			res = _SLIT("&byte");
		} else if (sym->kind == v__ast__Kind_charptr) {
			res = _SLIT("&char");
		} else {
			res = v__ast__Kind_str(sym->kind);
		}
	}
	else if (sym->kind == (v__ast__Kind_array)) {
		if (v__ast__Type_alias_eq(typ, _const_v__ast__array_type)) {
			 string _t1658 = _SLIT("array");
			// autofree_scope_vars(pos=21389 line_nr=871 scope.pos=21384 scope.end_pos=21408)
			// af parent scope:
			// af parent scope:
			// var "t" var.pos=20766 var.line_nr=845
			// var "typ" var.pos=20802 var.line_nr=845
			// var "import_aliases" var.pos=20812 var.line_nr=845
			// var "sym" var.pos=20919 var.line_nr=852
			// var "res" var.pos=20954 var.line_nr=853
			// var "nr_muls" var.pos=23642 var.line_nr=959
			// af parent scope:
			// af parent scope:
			return _t1658;
		}
		if (v__ast__Type_has_flag(typ, v__ast__TypeFlag_variadic)) {
			res = v__ast__Table_type_to_str_using_aliases(t, v__ast__Table_value_type(t, typ), import_aliases);
		} else {
			v__ast__Array info = /* as */ *(v__ast__Array*)__as_cast((sym->info)._v__ast__Array,(sym->info)._typ, 395) /*expected idx: 395, name: v.ast.Array */ ;
			string elem_str = v__ast__Table_type_to_str_using_aliases(t, info.elem_type, import_aliases);
			res = _STR("[]%.*s", 1, elem_str);
		}
	}
	else if (sym->kind == (v__ast__Kind_array_fixed)) {
		v__ast__ArrayFixed info = /* as */ *(v__ast__ArrayFixed*)__as_cast((sym->info)._v__ast__ArrayFixed,(sym->info)._typ, 416) /*expected idx: 416, name: v.ast.ArrayFixed */ ;
		string elem_str = v__ast__Table_type_to_str_using_aliases(t, info.elem_type, import_aliases);
		res = _STR("[%"PRId32"\000]%.*s", 2, info.size, elem_str);
	}
	else if (sym->kind == (v__ast__Kind_chan)) {
		if (string_ne(sym->mod, _SLIT("builtin")) && string_ne(sym->name, _SLIT("chan"))) {
			v__ast__Chan info = /* as */ *(v__ast__Chan*)__as_cast((sym->info)._v__ast__Chan,(sym->info)._typ, 414) /*expected idx: 414, name: v.ast.Chan */ ;
			v__ast__Type elem_type = info.elem_type;
			string mut_str = _SLIT("");
			if (info.is_mut) {
				mut_str = _SLIT("mut ");
				elem_type = v__ast__Type_set_nr_muls(elem_type, v__ast__Type_nr_muls(elem_type) - 1);
			}
			string elem_str = v__ast__Table_type_to_str_using_aliases(t, elem_type, import_aliases);
			res = _STR("chan %.*s\000%.*s", 2, mut_str, elem_str);
		}
	}
	else if (sym->kind == (v__ast__Kind_function)) {
		v__ast__FnType info = /* as */ *(v__ast__FnType*)__as_cast((sym->info)._v__ast__FnType,(sym->info)._typ, 418) /*expected idx: 418, name: v.ast.FnType */ ;
		if (!t->is_fmt) {
			res = v__ast__Table_fn_signature(t, (voidptr)&/*qq*/info.func, (v__ast__FnSignatureOpts){.skip_receiver = 0,.type_only = true,});
		} else {
			if (string_starts_with(res, _SLIT("fn ("))) {
				res = v__ast__Table_fn_signature(t, (voidptr)&/*qq*/info.func, (v__ast__FnSignatureOpts){.skip_receiver = 0,.type_only = true,});
			} else {
				res = v__ast__Table_shorten_user_defined_typenames(t, res, import_aliases);
			}
		}
	}
	else if (sym->kind == (v__ast__Kind_map)) {
		if (((int)(typ)) == _const_v__ast__map_type_idx) {
			 string _t1659 = _SLIT("map");
			// autofree_scope_vars(pos=22681 line_nr=916 scope.pos=22676 scope.end_pos=22698)
			// af parent scope:
			// var "info" var.pos=22703 var.line_nr=918
			// var "key_str" var.pos=22730 var.line_nr=919
			// var "val_str" var.pos=22803 var.line_nr=920
			// af parent scope:
			// var "t" var.pos=20766 var.line_nr=845
			// var "typ" var.pos=20802 var.line_nr=845
			// var "import_aliases" var.pos=20812 var.line_nr=845
			// var "sym" var.pos=20919 var.line_nr=852
			// var "res" var.pos=20954 var.line_nr=853
			// var "nr_muls" var.pos=23642 var.line_nr=959
			// af parent scope:
			// af parent scope:
			return _t1659;
		}
		v__ast__Map info = /* as */ *(v__ast__Map*)__as_cast((sym->info)._v__ast__Map,(sym->info)._typ, 396) /*expected idx: 396, name: v.ast.Map */ ;
		string key_str = v__ast__Table_type_to_str_using_aliases(t, info.key_type, import_aliases);
		string val_str = v__ast__Table_type_to_str_using_aliases(t, info.value_type, import_aliases);
		res = _STR("map[%.*s\000]%.*s", 2, key_str, val_str);
	}
	else if (sym->kind == (v__ast__Kind_multi_return)) {
		res = _SLIT("(");
		v__ast__MultiReturn info = /* as */ *(v__ast__MultiReturn*)__as_cast((sym->info)._v__ast__MultiReturn,(sym->info)._typ, 417) /*expected idx: 417, name: v.ast.MultiReturn */ ;
		// FOR IN array
		for (int i = 0; i < info.types.len; ++i) {
			v__ast__Type typ2 = ((v__ast__Type*)info.types.data)[i];
			if (i > 0) {
				res = /*f*/string_add(res, _SLIT(", "));
			}
			res = /*f*/string_add(res, v__ast__Table_type_to_str_using_aliases(t, typ2, import_aliases));
		}
		res = /*f*/string_add(res, _SLIT(")"));
	}
	else if (sym->kind == (v__ast__Kind_struct_)) {
		if (v__ast__Type_has_flag(typ, v__ast__TypeFlag_generic)) {
			v__ast__Struct info = /* as */ *(v__ast__Struct*)__as_cast((sym->info)._v__ast__Struct,(sym->info)._typ, 409) /*expected idx: 409, name: v.ast.Struct */ ;
			res = /*f*/string_add(res, _SLIT("<"));
			// FOR IN array
			for (int i = 0; i < info.generic_types.len; ++i) {
				v__ast__Type gtyp = ((v__ast__Type*)info.generic_types.data)[i];
				res = /*f*/string_add(res, v__ast__Table_get_type_symbol(t, gtyp)->name);
				if (i != info.generic_types.len - 1) {
					res = /*f*/string_add(res, _SLIT(", "));
				}
			}
			res = /*f*/string_add(res, _SLIT(">"));
		} else {
			res = v__ast__Table_shorten_user_defined_typenames(t, res, import_aliases);
		}
	}
	else if (sym->kind == (v__ast__Kind_void)) {
		if (v__ast__Type_has_flag(typ, v__ast__TypeFlag_optional)) {
			 string _t1660 = _SLIT("?");
			// autofree_scope_vars(pos=23520 line_nr=951 scope.pos=23515 scope.end_pos=23535)
			// af parent scope:
			// af parent scope:
			// var "t" var.pos=20766 var.line_nr=845
			// var "typ" var.pos=20802 var.line_nr=845
			// var "import_aliases" var.pos=20812 var.line_nr=845
			// var "sym" var.pos=20919 var.line_nr=852
			// var "res" var.pos=20954 var.line_nr=853
			// var "nr_muls" var.pos=23642 var.line_nr=959
			// af parent scope:
			// af parent scope:
			return _t1660;
		}
		 string _t1661 = _SLIT("void");
		// autofree_scope_vars(pos=23539 line_nr=953 scope.pos=23477 scope.end_pos=23556)
		// af parent scope:
		// var "t" var.pos=20766 var.line_nr=845
		// var "typ" var.pos=20802 var.line_nr=845
		// var "import_aliases" var.pos=20812 var.line_nr=845
		// var "sym" var.pos=20919 var.line_nr=852
		// var "res" var.pos=20954 var.line_nr=853
		// var "nr_muls" var.pos=23642 var.line_nr=959
		// af parent scope:
		// af parent scope:
		return _t1661;
	}
	else {
		res = v__ast__Table_shorten_user_defined_typenames(t, res, import_aliases);
	};
	int nr_muls = v__ast__Type_nr_muls(typ);
	if (v__ast__Type_has_flag(typ, v__ast__TypeFlag_shared_f)) {
		nr_muls--;
		res = string_add(_SLIT("shared "), res);
	}
	if (nr_muls > 0) {
		res = string_add(strings__repeat(L'&', nr_muls), res);
	}
	if (v__ast__Type_has_flag(typ, v__ast__TypeFlag_optional)) {
		res = string_add(_SLIT("?"), res);
	}
	// autofree_scope_vars(pos=23851 line_nr=970 scope.pos=20765 scope.end_pos=23863)
	// var "t" var.pos=20766 var.line_nr=845
	// var "typ" var.pos=20802 var.line_nr=845
	// var "import_aliases" var.pos=20812 var.line_nr=845
	// var "sym" var.pos=20919 var.line_nr=852
	// var "res" var.pos=20954 var.line_nr=853
	// var "nr_muls" var.pos=23642 var.line_nr=959
	// af parent scope:
	// af parent scope:
	return res;
}

VV_LOCAL_SYMBOL string v__ast__Table_shorten_user_defined_typenames(v__ast__Table* t, string originalname, Map_string_string import_aliases) {
	string res = originalname;
	if (t->cmod_prefix.len > 0 && string_starts_with(res, t->cmod_prefix)) {
		res = string_replace_once(res, t->cmod_prefix, _SLIT(""));
	} else if (_IN_MAP(ADDR(string, res), ADDR(map, import_aliases))) {
		res = (*(string*)map_get(ADDR(map, import_aliases), &(string[]){res}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} }));
	} else {
		Array_string parts = string_split(res, _SLIT("."));
		if (parts.len > 1) {
			int ind = parts.len - 2;
			if (_IN_MAP(ADDR(string, (*(string*)/*ee elem_typ */array_get(parts, ind))), ADDR(map, import_aliases))) {
				array_set(&parts, ind, &(string[]) { (*(string*)map_get(ADDR(map, import_aliases), &(string[]){(*(string*)/*ee elem_typ */array_get(parts, ind))}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })) });
			}
			res = Array_string_join(array_slice(parts, ind, parts.len), _SLIT("."));
		} else {
			res = (*(string*)/*ee elem_typ */array_get(parts, 0));
		}
	}
	// autofree_scope_vars(pos=24509 line_nr=994 scope.pos=23869 scope.end_pos=24521)
	// var "t" var.pos=23870 var.line_nr=973
	// var "originalname" var.pos=23910 var.line_nr=973
	// var "import_aliases" var.pos=23931 var.line_nr=973
	// var "res" var.pos=23979 var.line_nr=974
	// af parent scope:
	// af parent scope:
	return res;
}

string v__ast__Table_fn_signature(v__ast__Table* t, v__ast__Fn* func, v__ast__FnSignatureOpts opts) {
	strings__Builder sb = strings__new_builder(20);
	if (!opts.skip_receiver) {
		strings__Builder_write_string(&sb, _SLIT("fn "));
	}
	if (!opts.type_only) {
		strings__Builder_write_string(&sb, _STR("%.*s", 1, func->name));
	}
	strings__Builder_write_string(&sb, _SLIT("("));
	int start = ((int)(opts.skip_receiver));
	for (int i = start; i < func->params.len; ++i) {
		if (i != start) {
			strings__Builder_write_string(&sb, _SLIT(", "));
		}
		v__ast__Param param = (*(v__ast__Param*)/*ee elem_typ */array_get(func->params, i));
		v__ast__Type typ = param.typ;
		if (param.is_mut) {
			typ = v__ast__Type_deref(typ);
			strings__Builder_write_string(&sb, _SLIT("mut "));
		}
		if (!opts.type_only) {
			strings__Builder_write_string(&sb, _STR("%.*s\000 ", 2, param.name));
		}
		string styp = v__ast__Table_type_to_str(t, typ);
		strings__Builder_write_string(&sb, _STR("%.*s", 1, styp));
	}
	strings__Builder_write_string(&sb, _SLIT(")"));
	if (!v__ast__Type_alias_eq(func->return_type, _const_v__ast__void_type)) {
		strings__Builder_write_string(&sb, _STR(" %.*s", 1, v__ast__Table_type_to_str(t, func->return_type)));
	}
	 string _t1662 = strings__Builder_str(&sb);
	// autofree_scope_vars(pos=25343 line_nr=1033 scope.pos=24603 scope.end_pos=25360)
	// var "t" var.pos=24604 var.line_nr=1002
	// var "func" var.pos=24627 var.line_nr=1002
	// var "opts" var.pos=24637 var.line_nr=1002
	// var "sb" var.pos=24673 var.line_nr=1003
	// var "start" var.pos=24862 var.line_nr=1012
	// af parent scope:
	// af parent scope:
	return _t1662;
}

string v__ast__TypeSymbol_embed_name(v__ast__TypeSymbol* t) {
	string embed_name = (*(string*)array_last(string_split(t->name, _SLIT("."))));
	if (string_contains(embed_name, _SLIT("<"))) {
		embed_name = (*(string*)/*ee elem_typ */array_get(string_split(embed_name, _SLIT("<")), 0));
	}
	// autofree_scope_vars(pos=25610 line_nr=1044 scope.pos=25370 scope.end_pos=25629)
	// var "t" var.pos=25371 var.line_nr=1036
	// var "embed_name" var.pos=25443 var.line_nr=1038
	// af parent scope:
	// af parent scope:
	return embed_name;
}

bool v__ast__TypeSymbol_has_method(v__ast__TypeSymbol* t, string name) {
	Option_v__ast__Fn _t1663 = v__ast__TypeSymbol_find_method(t, name);
	if (_t1663.state != 0) { /*or block*/ 
		IError err = _t1663.err;
		 bool _t1664 = false;
		// autofree_scope_vars(pos=25711 line_nr=1048 scope.pos=25710 scope.end_pos=25725)
		// var "err" var.pos=25710 var.line_nr=1048
		// af parent scope:
		// var "t" var.pos=25640 var.line_nr=1047
		// var "name" var.pos=25666 var.line_nr=1047
		// af parent scope:
		// af parent scope:
		return _t1664;
	};
	 bool _t1665 = true;
	// autofree_scope_vars(pos=25727 line_nr=1049 scope.pos=25639 scope.end_pos=25740)
	// var "t" var.pos=25640 var.line_nr=1047
	// var "name" var.pos=25666 var.line_nr=1047
	// af parent scope:
	// af parent scope:
	return _t1665;
}

Option_v__ast__Fn v__ast__TypeSymbol_find_method(v__ast__TypeSymbol* t, string name) {
	// FOR IN array
	for (int _t1666 = 0; _t1666 < t->methods.len; ++_t1666) {
		v__ast__Fn method = ((v__ast__Fn*)t->methods.data)[_t1666];
		if (string_eq(method.name, name)) {
			Option_v__ast__Fn _t1667;
			opt_ok(&(v__ast__Fn[]) { method }, (Option*)(&_t1667), sizeof(v__ast__Fn));
			// autofree_scope_vars(pos=25853 line_nr=1055 scope.pos=25849 scope.end_pos=25870)
			// af parent scope:
			// var "method" var.pos=25802 var.line_nr=1053
			// skipping tmp var "method"
			// af parent scope:
			// var "t" var.pos=25751 var.line_nr=1052
			// var "name" var.pos=25778 var.line_nr=1052
			// af parent scope:
			// af parent scope:
			return _t1667;
		}
	}
	return (Option_v__ast__Fn){ .state=2, .err=_const_none__ };
}

multi_return_bool_bool_int v__ast__TypeSymbol_str_method_info(v__ast__TypeSymbol* t) {
	bool has_str_method = false;
	bool expects_ptr = false;
	int nr_args = 0;
	Option_v__ast__Fn _t1668;
	if (_t1668 = v__ast__TypeSymbol_find_method(t, _SLIT("str")), _t1668.state == 0) {
		v__ast__Fn sym_str_method = *(v__ast__Fn*)_t1668.data;
		has_str_method = true;
		nr_args = sym_str_method.params.len;
		if (nr_args > 0) {
			expects_ptr = v__ast__Type_is_ptr((*(v__ast__Param*)/*ee elem_typ */array_get(sym_str_method.params, 0)).typ);
		}
	}
	return (multi_return_bool_bool_int){.arg0=has_str_method, .arg1=expects_ptr, .arg2=nr_args};
}

Option_v__ast__StructField v__ast__TypeSymbol_find_field(v__ast__TypeSymbol* t, string name) {
	if (t->info._typ == 408 /* v.ast.Aggregate */) {
		 Option_v__ast__StructField _t1669 = v__ast__Aggregate_find_field(&(*t->info._v__ast__Aggregate), name);
		// autofree_scope_vars(pos=26352 line_nr=1077 scope.pos=26341 scope.end_pos=26384)
		// af parent scope:
		// var "t" var.pos=26269 var.line_nr=1075
		// var "name" var.pos=26295 var.line_nr=1075
		// af parent scope:
		// af parent scope:
		return _t1669;
	}
	else if (t->info._typ == 409 /* v.ast.Struct */) {
		 Option_v__ast__StructField _t1670 = v__ast__Struct_find_field(&(*t->info._v__ast__Struct), name);
		// autofree_scope_vars(pos=26396 line_nr=1078 scope.pos=26388 scope.end_pos=26428)
		// af parent scope:
		// var "t" var.pos=26269 var.line_nr=1075
		// var "name" var.pos=26295 var.line_nr=1075
		// af parent scope:
		// af parent scope:
		return _t1670;
	}
	else if (t->info._typ == 410 /* v.ast.Interface */) {
		 Option_v__ast__StructField _t1671 = v__ast__Interface_find_field(&(*t->info._v__ast__Interface), name);
		// autofree_scope_vars(pos=26443 line_nr=1079 scope.pos=26432 scope.end_pos=26475)
		// af parent scope:
		// var "t" var.pos=26269 var.line_nr=1075
		// var "name" var.pos=26295 var.line_nr=1075
		// af parent scope:
		// af parent scope:
		return _t1671;
	}
	else if (t->info._typ == 411 /* v.ast.SumType */) {
		 Option_v__ast__StructField _t1672 = v__ast__SumType_find_field(&(*t->info._v__ast__SumType), name);
		// autofree_scope_vars(pos=26488 line_nr=1080 scope.pos=26479 scope.end_pos=26520)
		// af parent scope:
		// var "t" var.pos=26269 var.line_nr=1075
		// var "name" var.pos=26295 var.line_nr=1075
		// af parent scope:
		// af parent scope:
		return _t1672;
	}
	else {
		return (Option_v__ast__StructField){ .state=2, .err=_const_none__ };
	};
	return (Option_v__ast__StructField){0};
}

VV_LOCAL_SYMBOL Option_v__ast__StructField v__ast__Aggregate_find_field(v__ast__Aggregate* a, string name) {
	// FOR IN array
	for (int _t1673 = 0; _t1673 < a->fields.len; ++_t1673) {
		v__ast__StructField field = ((v__ast__StructField*)a->fields.data)[_t1673];
		if (string_eq(field.name, name)) {
			Option_v__ast__StructField _t1674;
			opt_ok(&(v__ast__StructField[]) { field }, (Option*)(&_t1674), sizeof(v__ast__StructField));
			// autofree_scope_vars(pos=26661 line_nr=1088 scope.pos=26657 scope.end_pos=26677)
			// af parent scope:
			// var "field" var.pos=26613 var.line_nr=1086
			// skipping tmp var "field"
			// af parent scope:
			// var "a" var.pos=26555 var.line_nr=1085
			// var "name" var.pos=26580 var.line_nr=1085
			// af parent scope:
			// af parent scope:
			return _t1674;
		}
	}
	return (Option_v__ast__StructField){ .state=2, .err=_const_none__ };
}

Option_v__ast__StructField v__ast__Interface_find_field(v__ast__Interface* i, string name) {
	// FOR IN array
	for (int _t1675 = 0; _t1675 < i->fields.len; ++_t1675) {
		v__ast__StructField field = ((v__ast__StructField*)i->fields.data)[_t1675];
		if (string_eq(field.name, name)) {
			Option_v__ast__StructField _t1676;
			opt_ok(&(v__ast__StructField[]) { field }, (Option*)(&_t1676), sizeof(v__ast__StructField));
			// autofree_scope_vars(pos=26812 line_nr=1097 scope.pos=26808 scope.end_pos=26828)
			// af parent scope:
			// var "field" var.pos=26764 var.line_nr=1095
			// skipping tmp var "field"
			// af parent scope:
			// var "i" var.pos=26706 var.line_nr=1094
			// var "name" var.pos=26731 var.line_nr=1094
			// af parent scope:
			// af parent scope:
			return _t1676;
		}
	}
	return (Option_v__ast__StructField){ .state=2, .err=_const_none__ };
}

Option_v__ast__Fn v__ast__Interface_find_method(v__ast__Interface* i, string name) {
	// FOR IN array
	for (int _t1677 = 0; _t1677 < i->methods.len; ++_t1677) {
		v__ast__Fn method = ((v__ast__Fn*)i->methods.data)[_t1677];
		if (string_eq(method.name, name)) {
			Option_v__ast__Fn _t1678;
			opt_ok(&(v__ast__Fn[]) { method }, (Option*)(&_t1678), sizeof(v__ast__Fn));
			// autofree_scope_vars(pos=26958 line_nr=1106 scope.pos=26954 scope.end_pos=26975)
			// af parent scope:
			// var "method" var.pos=26907 var.line_nr=1104
			// skipping tmp var "method"
			// af parent scope:
			// var "i" var.pos=26857 var.line_nr=1103
			// var "name" var.pos=26883 var.line_nr=1103
			// af parent scope:
			// af parent scope:
			return _t1678;
		}
	}
	return (Option_v__ast__Fn){ .state=2, .err=_const_none__ };
}

bool v__ast__Interface_has_method(v__ast__Interface* i, string name) {
	Option_v__ast__Fn _t1679;
	if (_t1679 = v__ast__Interface_find_method(i, name), _t1679.state == 0) {
		 bool _t1680 = true;
		// autofree_scope_vars(pos=27081 line_nr=1114 scope.pos=27078 scope.end_pos=27095)
		// af parent scope:
		// af parent scope:
		// var "i" var.pos=27004 var.line_nr=1112
		// var "name" var.pos=27029 var.line_nr=1112
		// af parent scope:
		// af parent scope:
		return _t1680;
	}
	 bool _t1681 = false;
	// autofree_scope_vars(pos=27097 line_nr=1116 scope.pos=27003 scope.end_pos=27111)
	// var "i" var.pos=27004 var.line_nr=1112
	// var "name" var.pos=27029 var.line_nr=1112
	// af parent scope:
	// af parent scope:
	return _t1681;
}

Option_v__ast__StructField v__ast__Struct_find_field(v__ast__Struct* s, string name) {
	// FOR IN array
	for (int _t1682 = 0; _t1682 < s->fields.len; ++_t1682) {
		v__ast__StructField field = ((v__ast__StructField*)s->fields.data)[_t1682];
		if (string_eq(field.name, name)) {
			Option_v__ast__StructField _t1683;
			opt_ok(&(v__ast__StructField[]) { field }, (Option*)(&_t1683), sizeof(v__ast__StructField));
			// autofree_scope_vars(pos=27224 line_nr=1122 scope.pos=27220 scope.end_pos=27240)
			// af parent scope:
			// var "field" var.pos=27176 var.line_nr=1120
			// skipping tmp var "field"
			// af parent scope:
			// var "s" var.pos=27122 var.line_nr=1119
			// var "name" var.pos=27143 var.line_nr=1119
			// af parent scope:
			// af parent scope:
			return _t1683;
		}
	}
	return (Option_v__ast__StructField){ .state=2, .err=_const_none__ };
}

v__ast__StructField v__ast__Struct_get_field(v__ast__Struct* s, string name) {
	Option_v__ast__StructField _t1684;
	if (_t1684 = v__ast__Struct_find_field(s, name), _t1684.state == 0) {
		v__ast__StructField field = *(v__ast__StructField*)_t1684.data;
		// autofree_scope_vars(pos=27351 line_nr=1130 scope.pos=27348 scope.end_pos=27366)
		// af parent scope:
		// var "field" var.pos=27320 var.line_nr=1129
		// af parent scope:
		// var "s" var.pos=27269 var.line_nr=1128
		// var "name" var.pos=27289 var.line_nr=1128
		// af parent scope:
		// af parent scope:
		return field;
	}
	v_panic(_STR("unknown field `%.*s\000`", 2, name));
	return (v__ast__StructField){.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),};
}

Option_v__ast__StructField v__ast__SumType_find_field(v__ast__SumType* s, string name) {
	// FOR IN array
	for (int _t1685 = 0; _t1685 < s->fields.len; ++_t1685) {
		v__ast__StructField field = ((v__ast__StructField*)s->fields.data)[_t1685];
		if (string_eq(field.name, name)) {
			Option_v__ast__StructField _t1686;
			opt_ok(&(v__ast__StructField[]) { field }, (Option*)(&_t1686), sizeof(v__ast__StructField));
			// autofree_scope_vars(pos=27515 line_nr=1138 scope.pos=27511 scope.end_pos=27531)
			// af parent scope:
			// var "field" var.pos=27467 var.line_nr=1136
			// skipping tmp var "field"
			// af parent scope:
			// var "s" var.pos=27411 var.line_nr=1135
			// var "name" var.pos=27434 var.line_nr=1135
			// af parent scope:
			// af parent scope:
			return _t1686;
		}
	}
	return (Option_v__ast__StructField){ .state=2, .err=_const_none__ };
}

bool v__ast__Interface_defines_method(v__ast__Interface i, string name) {
	// FOR IN array
	for (int _t1687 = 0; _t1687 < i.methods.len; ++_t1687) {
		v__ast__Fn method = ((v__ast__Fn*)i.methods.data)[_t1687];
		if (string_eq(method.name, name)) {
			 bool _t1688 = true;
			// autofree_scope_vars(pos=27664 line_nr=1147 scope.pos=27660 scope.end_pos=27679)
			// af parent scope:
			// var "method" var.pos=27613 var.line_nr=1145
			// skipping tmp var "method"
			// af parent scope:
			// var "i" var.pos=27560 var.line_nr=1144
			// var "name" var.pos=27588 var.line_nr=1144
			// af parent scope:
			// af parent scope:
			return _t1688;
		}
	}
	 bool _t1689 = false;
	// autofree_scope_vars(pos=27684 line_nr=1150 scope.pos=27559 scope.end_pos=27698)
	// var "i" var.pos=27560 var.line_nr=1144
	// var "name" var.pos=27588 var.line_nr=1144
	// af parent scope:
	// af parent scope:
	return _t1689;
}

v__scanner__Scanner* v__scanner__new_scanner_file(string file_path, v__scanner__CommentsMode comments_mode, v__pref__Preferences* pref) {
	if (!os__exists(file_path)) {
		v__scanner__verror(_STR("%.*s\000 doesn't exist", 2, file_path));
	}
	Option_string _t1690 = v__util__read_file(file_path);
	if (_t1690.state != 0) { /*or block*/ 
		IError err = _t1690.err;
		v__scanner__verror((*(err.msg)));
		 v__scanner__Scanner* _t1691 = ((voidptr)(0));
		// autofree_scope_vars(pos=4189 line_nr=107 scope.pos=4172 scope.end_pos=4209)
		// var "err" var.pos=4172 var.line_nr=105
		// af parent scope:
		// var "file_path" var.pos=3981 var.line_nr=101
		// var "comments_mode" var.pos=3999 var.line_nr=101
		// var "pref" var.pos=4027 var.line_nr=101
		// var "raw_text" var.pos=4131 var.line_nr=105
		// var "s" var.pos=4216 var.line_nr=109
		// af parent scope:
		// af parent scope:
		return _t1691;
	}
 	string raw_text =  *(string*)_t1690.data;
	v__scanner__Scanner* s = (v__scanner__Scanner*)memdup(&(v__scanner__Scanner){.file_path = file_path,
		.file_base = os__base(file_path),
		.text = raw_text,
		.pos = 0,
		.line_nr = 0,
		.last_nl_pos = -1,
		.is_crlf = 0,
		.is_inside_string = 0,
		.is_inter_start = 0,
		.is_inter_end = 0,
		.is_enclosed_inter = 0,
		.line_comment = (string){.str=(byteptr)"", .is_lit=1},
		.is_started = 0,
		.is_print_line_on_error = true,
		.is_print_colored_error = true,
		.is_print_rel_paths_on_error = true,
		.quote = 0,
		.inter_quote = 0,
		.line_ends = __new_array(0, 1, sizeof(int)),
		.nr_lines = 0,
		.is_vh = 0,
		.is_fmt = pref->is_fmt,
		.comments_mode = comments_mode,
		.is_inside_toplvl_statement = 0,
		.all_tokens = __new_array(0, 1, sizeof(v__token__Token)),
		.tidx = 0,
		.eofs = 0,
		.pref = pref,
		.errors = __new_array(0, 1, sizeof(v__errors__Error)),
		.warnings = __new_array(0, 1, sizeof(v__errors__Warning)),
		.notices = __new_array(0, 1, sizeof(v__errors__Notice)),
		.vet_errors = __new_array(0, 1, sizeof(v__vet__Error)),
	}, sizeof(v__scanner__Scanner));
	v__scanner__Scanner_init_scanner(s);
	// autofree_scope_vars(pos=4488 line_nr=121 scope.pos=3964 scope.end_pos=4498)
	// var "file_path" var.pos=3981 var.line_nr=101
	// var "comments_mode" var.pos=3999 var.line_nr=101
	// var "pref" var.pos=4027 var.line_nr=101
	// var "raw_text" var.pos=4131 var.line_nr=105
	// var "s" var.pos=4216 var.line_nr=109
	// af parent scope:
	// af parent scope:
	return s;
}

v__scanner__Scanner* v__scanner__new_scanner(string text, v__scanner__CommentsMode comments_mode, v__pref__Preferences* pref) {
	v__scanner__Scanner* s = (v__scanner__Scanner*)memdup(&(v__scanner__Scanner){.file_path = _SLIT("internal_memory"),
		.file_base = _SLIT("internal_memory"),
		.text = text,
		.pos = 0,
		.line_nr = 0,
		.last_nl_pos = -1,
		.is_crlf = 0,
		.is_inside_string = 0,
		.is_inter_start = 0,
		.is_inter_end = 0,
		.is_enclosed_inter = 0,
		.line_comment = (string){.str=(byteptr)"", .is_lit=1},
		.is_started = 0,
		.is_print_line_on_error = true,
		.is_print_colored_error = true,
		.is_print_rel_paths_on_error = true,
		.quote = 0,
		.inter_quote = 0,
		.line_ends = __new_array(0, 1, sizeof(int)),
		.nr_lines = 0,
		.is_vh = 0,
		.is_fmt = pref->is_fmt,
		.comments_mode = comments_mode,
		.is_inside_toplvl_statement = 0,
		.all_tokens = __new_array(0, 1, sizeof(v__token__Token)),
		.tidx = 0,
		.eofs = 0,
		.pref = pref,
		.errors = __new_array(0, 1, sizeof(v__errors__Error)),
		.warnings = __new_array(0, 1, sizeof(v__errors__Warning)),
		.notices = __new_array(0, 1, sizeof(v__errors__Notice)),
		.vet_errors = __new_array(0, 1, sizeof(v__vet__Error)),
	}, sizeof(v__scanner__Scanner));
	v__scanner__Scanner_init_scanner(s);
	// autofree_scope_vars(pos=4904 line_nr=138 scope.pos=4536 scope.end_pos=4914)
	// var "text" var.pos=4548 var.line_nr=125
	// var "comments_mode" var.pos=4561 var.line_nr=125
	// var "pref" var.pos=4589 var.line_nr=125
	// var "s" var.pos=4629 var.line_nr=126
	// af parent scope:
	// af parent scope:
	return s;
}

VV_LOCAL_SYMBOL void v__scanner__Scanner_init_scanner(v__scanner__Scanner* s) {
	v__util__Timers_measure_pause(v__util__get_timers(), _SLIT("PARSE"));
	v__scanner__Scanner_scan_all_tokens_in_buffer(s, s->comments_mode);
	v__util__Timers_measure_resume(v__util__get_timers(), _SLIT("PARSE"));
}

// Attr: [unsafe]
void v__scanner__Scanner_free(v__scanner__Scanner* s) {
	string_free(&s->text);
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL bool v__scanner__Scanner_should_parse_comment(v__scanner__Scanner* s) {
	 bool _t1692 = (s->comments_mode == v__scanner__CommentsMode_parse_comments) || (s->comments_mode == v__scanner__CommentsMode_toplevel_comments && !s->is_inside_toplvl_statement);
	// autofree_scope_vars(pos=5215 line_nr=156 scope.pos=5172 scope.end_pos=5338)
	// var "s" var.pos=5173 var.line_nr=155
	// af parent scope:
	// af parent scope:
	return _t1692;
}

void v__scanner__Scanner_set_is_inside_toplevel_statement(v__scanner__Scanner* s, bool newstate) {
	s->is_inside_toplvl_statement = newstate;
}

void v__scanner__Scanner_set_current_tidx(v__scanner__Scanner* s, int cidx) {
	int tidx = (cidx < 0 ? (0) : (cidx));
	tidx = (tidx > s->all_tokens.len ? (s->all_tokens.len) : (tidx));
	s->tidx = tidx;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL v__token__Token v__scanner__Scanner_new_token(v__scanner__Scanner* s, v__token__Kind tok_kind, string lit, int len) {
	int cidx = s->tidx;
	s->tidx++;
	int line_offset = (tok_kind == v__token__Kind_hash ? (0) : (1));
	 v__token__Token _t1693 = (v__token__Token){
		.kind = tok_kind,
		.lit = lit,
		.line_nr = s->line_nr + line_offset,
		.col = math__mathutil__max_T_int(1, v__scanner__Scanner_current_column(s) - len + 1),
		.pos = s->pos - len + 1,
		.len = len,
		.tidx = cidx,
	};
	// autofree_scope_vars(pos=5853 line_nr=176 scope.pos=5691 scope.end_pos=6034)
	// var "s" var.pos=5696 var.line_nr=172
	// var "tok_kind" var.pos=5717 var.line_nr=172
	// var "lit" var.pos=5738 var.line_nr=172
	// var "len" var.pos=5750 var.line_nr=172
	// var "cidx" var.pos=5774 var.line_nr=173
	// var "line_offset" var.pos=5800 var.line_nr=175
	// af parent scope:
	// af parent scope:
	return _t1693;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL v__token__Token v__scanner__Scanner_new_eof_token(v__scanner__Scanner* s) {
	 v__token__Token _t1694 = (v__token__Token){
		.kind = v__token__Kind_eof,
		.lit = _SLIT(""),
		.line_nr = s->line_nr + 1,
		.col = v__scanner__Scanner_current_column(s),
		.pos = s->pos,
		.len = 1,
		.tidx = s->tidx,
	};
	// autofree_scope_vars(pos=6092 line_nr=189 scope.pos=6049 scope.end_pos=6227)
	// var "s" var.pos=6050 var.line_nr=188
	// af parent scope:
	// af parent scope:
	return _t1694;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL v__token__Token v__scanner__Scanner_new_multiline_token(v__scanner__Scanner* s, v__token__Kind tok_kind, string lit, int len, int start_line) {
	int cidx = s->tidx;
	s->tidx++;
	 v__token__Token _t1695 = (v__token__Token){
		.kind = tok_kind,
		.lit = lit,
		.line_nr = start_line + 1,
		.col = math__mathutil__max_T_int(1, v__scanner__Scanner_current_column(s) - len + 1),
		.pos = s->pos - len + 1,
		.len = len,
		.tidx = cidx,
	};
	// autofree_scope_vars(pos=6376 line_nr=204 scope.pos=6242 scope.end_pos=6548)
	// var "s" var.pos=6247 var.line_nr=201
	// var "tok_kind" var.pos=6278 var.line_nr=201
	// var "lit" var.pos=6299 var.line_nr=201
	// var "len" var.pos=6311 var.line_nr=201
	// var "start_line" var.pos=6320 var.line_nr=201
	// var "cidx" var.pos=6351 var.line_nr=202
	// af parent scope:
	// af parent scope:
	return _t1695;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_name(v__scanner__Scanner* s) {
	int start = s->pos;
	s->pos++;
	for (;;) {
		if (!(s->pos < s->text.len && (v__util__is_name_char(string_at(s->text, s->pos)) || byte_is_digit(string_at(s->text, s->pos))))) break;
		s->pos++;
	}
	string name = string_substr(s->text, start, s->pos);
	s->pos--;
	// autofree_scope_vars(pos=6770 line_nr=224 scope.pos=6563 scope.end_pos=6783)
	// var "s" var.pos=6568 var.line_nr=216
	// var "start" var.pos=6602 var.line_nr=217
	// var "name" var.pos=6732 var.line_nr=222
	// af parent scope:
	// af parent scope:
	return name;
}

VV_LOCAL_SYMBOL string v__scanner__Scanner_num_lit(v__scanner__Scanner* s, int start, int end) {
	if (s->is_fmt) {
		 string _t1696 = string_substr(s->text, start, end);
		// autofree_scope_vars(pos=6854 line_nr=229 scope.pos=6851 scope.end_pos=6882)
		// af parent scope:
		// var "s" var.pos=6790 var.line_nr=227
		// var "start" var.pos=6809 var.line_nr=227
		// var "end" var.pos=6820 var.line_nr=227
		// af parent scope:
		// af parent scope:
		return _t1696;
	}
	{ // Unsafe block
		byte* txt = s->text.str;
		byte* b = v_malloc(end - start + 1);
		int i1 = 0;
		for (int i = start; i < end; i++) {
			if (txt[i] != _const_v__scanner__num_sep) {
				b[i1] = txt[i];
				i1++;
			}
		}
		b[i1] = 0;
		 string _t1697 = byte_vstring_with_len(b, i1);
		// autofree_scope_vars(pos=7140 line_nr=242 scope.pos=6896 scope.end_pos=7172)
		// var "txt" var.pos=6896 var.line_nr=232
		// var "b" var.pos=6920 var.line_nr=233
		// var "i1" var.pos=6989 var.line_nr=234
		// af parent scope:
		// var "s" var.pos=6790 var.line_nr=227
		// var "start" var.pos=6809 var.line_nr=227
		// var "end" var.pos=6820 var.line_nr=227
		// af parent scope:
		// af parent scope:
		return _t1697;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_bin_number(v__scanner__Scanner* s) {
	bool has_wrong_digit = false;
	int first_wrong_digit_pos = 0;
	rune first_wrong_digit = L'\0';
	int start_pos = s->pos;
	s->pos += 2;
	if (s->pos < s->text.len && string_at(s->text, s->pos) == _const_v__scanner__num_sep) {
		v__scanner__Scanner_error(s, _SLIT("separator `_` is only valid between digits in a numeric literal"));
	}
	for (;;) {
		if (!(s->pos < s->text.len)) break;
		byte c = string_at(s->text, s->pos);
		if (c == _const_v__scanner__num_sep && string_at(s->text, s->pos - 1) == _const_v__scanner__num_sep) {
			v__scanner__Scanner_error(s, _SLIT("cannot use `_` consecutively"));
		}
		if (!byte_is_bin_digit(c) && c != _const_v__scanner__num_sep) {
			if ((!byte_is_digit(c) && !byte_is_letter(c)) || s->is_inside_string) {
				break;
			} else if (!has_wrong_digit) {
				has_wrong_digit = true;
				first_wrong_digit_pos = s->pos;
				first_wrong_digit = c;
			}
		}
		s->pos++;
	}
	if (string_at(s->text, s->pos - 1) == _const_v__scanner__num_sep) {
		s->pos--;
		v__scanner__Scanner_error(s, _SLIT("cannot use `_` at the end of a numeric literal"));
	} else if (start_pos + 2 == s->pos) {
		s->pos--;
		v__scanner__Scanner_error(s, _SLIT("number part of this binary is not provided"));
	} else if (has_wrong_digit) {
		s->pos = first_wrong_digit_pos;
		v__scanner__Scanner_error(s, _STR("this binary number has unsuitable digit `%.*s\000`", 2, rune_str(first_wrong_digit)));
	}
	string number = v__scanner__Scanner_num_lit(s, start_pos, s->pos);
	s->pos--;
	// autofree_scope_vars(pos=8386 line_nr=283 scope.pos=7180 scope.end_pos=8401)
	// var "s" var.pos=7185 var.line_nr=246
	// var "has_wrong_digit" var.pos=7229 var.line_nr=247
	// var "first_wrong_digit_pos" var.pos=7259 var.line_nr=248
	// var "first_wrong_digit" var.pos=7291 var.line_nr=249
	// var "start_pos" var.pos=7318 var.line_nr=250
	// var "number" var.pos=8339 var.line_nr=281
	// af parent scope:
	// af parent scope:
	return number;
}

VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_hex_number(v__scanner__Scanner* s) {
	bool has_wrong_digit = false;
	int first_wrong_digit_pos = 0;
	rune first_wrong_digit = L'\0';
	int start_pos = s->pos;
	if (s->pos + 2 >= s->text.len) {
		 string _t1698 = _SLIT("0x");
		// autofree_scope_vars(pos=8595 line_nr=292 scope.pos=8592 scope.end_pos=8609)
		// af parent scope:
		// var "s" var.pos=8412 var.line_nr=286
		// var "has_wrong_digit" var.pos=8456 var.line_nr=287
		// var "first_wrong_digit_pos" var.pos=8486 var.line_nr=288
		// var "first_wrong_digit" var.pos=8518 var.line_nr=289
		// var "start_pos" var.pos=8545 var.line_nr=290
		// var "number" var.pos=9604 var.line_nr=324
		// af parent scope:
		// af parent scope:
		return _t1698;
	}
	s->pos += 2;
	if (s->pos < s->text.len && string_at(s->text, s->pos) == _const_v__scanner__num_sep) {
		v__scanner__Scanner_error(s, _SLIT("separator `_` is only valid between digits in a numeric literal"));
	}
	for (;;) {
		if (!(s->pos < s->text.len)) break;
		byte c = string_at(s->text, s->pos);
		if (c == _const_v__scanner__num_sep && string_at(s->text, s->pos - 1) == _const_v__scanner__num_sep) {
			v__scanner__Scanner_error(s, _SLIT("cannot use `_` consecutively"));
		}
		if (!byte_is_hex_digit(c) && c != _const_v__scanner__num_sep) {
			if (!byte_is_letter(c) || s->is_inside_string) {
				break;
			} else if (!has_wrong_digit) {
				has_wrong_digit = true;
				first_wrong_digit_pos = s->pos;
				first_wrong_digit = c;
			}
		}
		s->pos++;
	}
	if (string_at(s->text, s->pos - 1) == _const_v__scanner__num_sep) {
		s->pos--;
		v__scanner__Scanner_error(s, _SLIT("cannot use `_` at the end of a numeric literal"));
	} else if (start_pos + 2 == s->pos) {
		s->pos--;
		v__scanner__Scanner_error(s, _SLIT("number part of this hexadecimal is not provided"));
	} else if (has_wrong_digit) {
		s->pos = first_wrong_digit_pos;
		v__scanner__Scanner_error(s, _STR("this hexadecimal number has unsuitable digit `%.*s\000`", 2, rune_str(first_wrong_digit)));
	}
	string number = v__scanner__Scanner_num_lit(s, start_pos, s->pos);
	s->pos--;
	// autofree_scope_vars(pos=9651 line_nr=326 scope.pos=8407 scope.end_pos=9666)
	// var "s" var.pos=8412 var.line_nr=286
	// var "has_wrong_digit" var.pos=8456 var.line_nr=287
	// var "first_wrong_digit_pos" var.pos=8486 var.line_nr=288
	// var "first_wrong_digit" var.pos=8518 var.line_nr=289
	// var "start_pos" var.pos=8545 var.line_nr=290
	// var "number" var.pos=9604 var.line_nr=324
	// af parent scope:
	// af parent scope:
	return number;
}

VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_oct_number(v__scanner__Scanner* s) {
	bool has_wrong_digit = false;
	int first_wrong_digit_pos = 0;
	rune first_wrong_digit = L'\0';
	int start_pos = s->pos;
	s->pos += 2;
	if (s->pos < s->text.len && string_at(s->text, s->pos) == _const_v__scanner__num_sep) {
		v__scanner__Scanner_error(s, _SLIT("separator `_` is only valid between digits in a numeric literal"));
	}
	for (;;) {
		if (!(s->pos < s->text.len)) break;
		byte c = string_at(s->text, s->pos);
		if (c == _const_v__scanner__num_sep && string_at(s->text, s->pos - 1) == _const_v__scanner__num_sep) {
			v__scanner__Scanner_error(s, _SLIT("cannot use `_` consecutively"));
		}
		if (!byte_is_oct_digit(c) && c != _const_v__scanner__num_sep) {
			if ((!byte_is_digit(c) && !byte_is_letter(c)) || s->is_inside_string) {
				break;
			} else if (!has_wrong_digit) {
				has_wrong_digit = true;
				first_wrong_digit_pos = s->pos;
				first_wrong_digit = c;
			}
		}
		s->pos++;
	}
	if (string_at(s->text, s->pos - 1) == _const_v__scanner__num_sep) {
		s->pos--;
		v__scanner__Scanner_error(s, _SLIT("cannot use `_` at the end of a numeric literal"));
	} else if (start_pos + 2 == s->pos) {
		s->pos--;
		v__scanner__Scanner_error(s, _SLIT("number part of this octal is not provided"));
	} else if (has_wrong_digit) {
		s->pos = first_wrong_digit_pos;
		v__scanner__Scanner_error(s, _STR("this octal number has unsuitable digit `%.*s\000`", 2, rune_str(first_wrong_digit)));
	}
	string number = v__scanner__Scanner_num_lit(s, start_pos, s->pos);
	s->pos--;
	// autofree_scope_vars(pos=10876 line_nr=366 scope.pos=9672 scope.end_pos=10891)
	// var "s" var.pos=9677 var.line_nr=329
	// var "has_wrong_digit" var.pos=9721 var.line_nr=330
	// var "first_wrong_digit_pos" var.pos=9751 var.line_nr=331
	// var "first_wrong_digit" var.pos=9783 var.line_nr=332
	// var "start_pos" var.pos=9810 var.line_nr=333
	// var "number" var.pos=10829 var.line_nr=364
	// af parent scope:
	// af parent scope:
	return number;
}

VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_dec_number(v__scanner__Scanner* s) {
	bool has_wrong_digit = false;
	int first_wrong_digit_pos = 0;
	rune first_wrong_digit = L'\0';
	int start_pos = s->pos;
	for (;;) {
		if (!(s->pos < s->text.len)) break;
		byte c = string_at(s->text, s->pos);
		if (c == _const_v__scanner__num_sep && string_at(s->text, s->pos - 1) == _const_v__scanner__num_sep) {
			v__scanner__Scanner_error(s, _SLIT("cannot use `_` consecutively"));
		}
		if (!byte_is_digit(c) && c != _const_v__scanner__num_sep) {
			if (!byte_is_letter(c) || (c == L'e' || c == L'E') || s->is_inside_string) {
				break;
			} else if (!has_wrong_digit) {
				has_wrong_digit = true;
				first_wrong_digit_pos = s->pos;
				first_wrong_digit = c;
			}
		}
		s->pos++;
	}
	if (string_at(s->text, s->pos - 1) == _const_v__scanner__num_sep) {
		s->pos--;
		v__scanner__Scanner_error(s, _SLIT("cannot use `_` at the end of a numeric literal"));
	}
	bool call_method = false;
	bool is_range = false;
	if (s->pos < s->text.len && string_at(s->text, s->pos) == L'.') {
		s->pos++;
		if (s->pos < s->text.len) {
			if (byte_is_digit(string_at(s->text, s->pos))) {
				for (;;) {
					if (!(s->pos < s->text.len)) break;
					byte c = string_at(s->text, s->pos);
					if (!byte_is_digit(c)) {
						if (!byte_is_letter(c) || (c == L'e' || c == L'E') || s->is_inside_string) {
							if (c == L'.' && s->pos + 1 < s->text.len && byte_is_letter(string_at(s->text, s->pos + 1))) {
								call_method = true;
							}
							break;
						} else if (!has_wrong_digit) {
							has_wrong_digit = true;
							first_wrong_digit_pos = s->pos;
							first_wrong_digit = c;
						}
					}
					s->pos++;
				}
			} else if (string_at(s->text, s->pos) == L'.') {
				is_range = true;
				s->pos--;
			} else if ((string_at(s->text, s->pos) == L'e' || string_at(s->text, s->pos) == L'E')) {
			} else if (byte_is_letter(string_at(s->text, s->pos))) {
				call_method = true;
				s->pos--;
			} else {
			}
		}
	}
	bool has_exp = false;
	if (s->pos < s->text.len && (string_at(s->text, s->pos) == L'e' || string_at(s->text, s->pos) == L'E')) {
		has_exp = true;
		s->pos++;
		if (s->pos < s->text.len && (string_at(s->text, s->pos) == L'-' || string_at(s->text, s->pos) == L'+')) {
			s->pos++;
		}
		for (;;) {
			if (!(s->pos < s->text.len)) break;
			byte c = string_at(s->text, s->pos);
			if (!byte_is_digit(c)) {
				if (!byte_is_letter(c) || s->is_inside_string) {
					if (c == L'.' && s->pos + 1 < s->text.len && byte_is_letter(string_at(s->text, s->pos + 1))) {
						call_method = true;
					}
					break;
				} else if (!has_wrong_digit) {
					has_wrong_digit = true;
					first_wrong_digit_pos = s->pos;
					first_wrong_digit = c;
				}
			}
			s->pos++;
		}
	}
	if (has_wrong_digit) {
		s->pos = first_wrong_digit_pos;
		v__scanner__Scanner_error(s, _STR("this number has unsuitable digit `%.*s\000`", 2, rune_str(first_wrong_digit)));
	} else if ((string_at(s->text, s->pos - 1) == L'e' || string_at(s->text, s->pos - 1) == L'E')) {
		s->pos--;
		v__scanner__Scanner_error(s, _SLIT("exponent has no digits"));
	} else if (s->pos < s->text.len && string_at(s->text, s->pos) == L'.' && !is_range && !call_method) {
		if (has_exp) {
			v__scanner__Scanner_error(s, _SLIT("exponential part should be integer"));
		} else {
			v__scanner__Scanner_error(s, _SLIT("too many decimal points in number"));
		}
	}
	string number = v__scanner__Scanner_num_lit(s, start_pos, s->pos);
	s->pos--;
	// autofree_scope_vars(pos=13857 line_nr=479 scope.pos=10897 scope.end_pos=13872)
	// var "s" var.pos=10902 var.line_nr=369
	// var "has_wrong_digit" var.pos=10946 var.line_nr=370
	// var "first_wrong_digit_pos" var.pos=10976 var.line_nr=371
	// var "first_wrong_digit" var.pos=11008 var.line_nr=372
	// var "start_pos" var.pos=11035 var.line_nr=373
	// var "call_method" var.pos=11619 var.line_nr=395
	// var "is_range" var.pos=11694 var.line_nr=396
	// var "has_exp" var.pos=12659 var.line_nr=436
	// var "number" var.pos=13810 var.line_nr=477
	// af parent scope:
	// af parent scope:
	return number;
}

VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_number(v__scanner__Scanner* s) {
	if (v__scanner__Scanner_expect(s, _SLIT("0b"), s->pos)) {
		 string _t1699 = v__scanner__Scanner_ident_bin_number(s);
		// autofree_scope_vars(pos=13947 line_nr=484 scope.pos=13944 scope.end_pos=13977)
		// af parent scope:
		// var "s" var.pos=13883 var.line_nr=482
		// af parent scope:
		// af parent scope:
		return _t1699;
	} else if (v__scanner__Scanner_expect(s, _SLIT("0x"), s->pos)) {
		 string _t1700 = v__scanner__Scanner_ident_hex_number(s);
		// autofree_scope_vars(pos=14012 line_nr=486 scope.pos=14009 scope.end_pos=14042)
		// af parent scope:
		// var "s" var.pos=13883 var.line_nr=482
		// af parent scope:
		// af parent scope:
		return _t1700;
	} else if (v__scanner__Scanner_expect(s, _SLIT("0o"), s->pos)) {
		 string _t1701 = v__scanner__Scanner_ident_oct_number(s);
		// autofree_scope_vars(pos=14077 line_nr=488 scope.pos=14074 scope.end_pos=14107)
		// af parent scope:
		// var "s" var.pos=13883 var.line_nr=482
		// af parent scope:
		// af parent scope:
		return _t1701;
	} else {
		 string _t1702 = v__scanner__Scanner_ident_dec_number(s);
		// autofree_scope_vars(pos=14117 line_nr=490 scope.pos=14114 scope.end_pos=14147)
		// af parent scope:
		// var "s" var.pos=13883 var.line_nr=482
		// af parent scope:
		// af parent scope:
		return _t1702;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL void v__scanner__Scanner_skip_whitespace(v__scanner__Scanner* s) {
	for (;;) {
		if (!(s->pos < s->text.len && byte_is_space(string_at(s->text, s->pos)))) break;
		if (v__util__is_nl(string_at(s->text, s->pos)) && s->is_vh) {
			return;
		}
		if (s->pos + 1 < s->text.len && string_at(s->text, s->pos) == L'\r' && string_at(s->text, s->pos + 1) == L'\n') {
			s->is_crlf = true;
		}
		if (v__util__is_nl(string_at(s->text, s->pos)) && !v__scanner__Scanner_expect(s, _SLIT("\r\n"), s->pos - 1)) {
			v__scanner__Scanner_inc_line_number(s);
		}
		s->pos++;
	}
}

VV_LOCAL_SYMBOL v__token__Token v__scanner__Scanner_end_of_file(v__scanner__Scanner* s) {
	s->eofs++;
	if (s->eofs > 50) {
		s->line_nr--;
		v_panic(string_add(string_add(_STR("the end of file `%.*s\000` has been reached 50 times already, the v parser is probably stuck.\n", 2, s->file_path), _SLIT("This should not happen. Please report the bug here, and include the last 2-3 lines of your source code:\n")), _SLIT("https://github.com/vlang/v/issues/new?labels=Bug&template=bug_report.md")));
	}
	if (s->pos != s->text.len && s->eofs == 1) {
		v__scanner__Scanner_inc_line_number(s);
	}
	s->pos = s->text.len;
	 v__token__Token _t1703 = v__scanner__Scanner_new_eof_token(s);
	// autofree_scope_vars(pos=15081 line_nr=525 scope.pos=14599 scope.end_pos=15107)
	// var "s" var.pos=14604 var.line_nr=512
	// af parent scope:
	// af parent scope:
	return _t1703;
}

void v__scanner__Scanner_scan_all_tokens_in_buffer(v__scanner__Scanner* s, v__scanner__CommentsMode mode) {
bool v__scanner__Scanner_scan_all_tokens_in_buffer_defer_0 = false;
	v__util__timing_start(_SLIT("SCAN"));
	v__scanner__Scanner_scan_all_tokens_in_buffer_defer_0 = true;
	v__scanner__CommentsMode oldmode = s->comments_mode;
	s->comments_mode = mode;
	v__scanner__Scanner_scan_remaining_text(s);
	s->comments_mode = oldmode;
	s->tidx = 0;
// Defer begin
if (v__scanner__Scanner_scan_all_tokens_in_buffer_defer_0 == true) {
	v__util__timing_measure_cumulative(_SLIT("SCAN"));
}
// Defer end
}

void v__scanner__Scanner_scan_remaining_text(v__scanner__Scanner* s) {
	for (;;) {
		v__token__Token t = v__scanner__Scanner_text_scan(s);
		if (s->comments_mode == v__scanner__CommentsMode_skip_comments && t.kind == v__token__Kind_comment) {
			continue;
		}
		array_push(&s->all_tokens, _MOV((v__token__Token[]){ t }));
		if (t.kind == v__token__Kind_eof) {
			break;
		}
	}
}

v__token__Token v__scanner__Scanner_scan(v__scanner__Scanner* s) {
	 v__token__Token _t1705 = v__scanner__Scanner_buffer_scan(s);
	// autofree_scope_vars(pos=15875 line_nr=561 scope.pos=15838 scope.end_pos=15899)
	// var "s" var.pos=15843 var.line_nr=560
	// af parent scope:
	// af parent scope:
	return _t1705;
}

v__token__Token v__scanner__Scanner_buffer_scan(v__scanner__Scanner* s) {
	for (;;) {
		int cidx = s->tidx;
		s->tidx++;
		if (cidx >= s->all_tokens.len) {
			 v__token__Token _t1706 = v__scanner__Scanner_end_of_file(s);
			// autofree_scope_vars(pos=16022 line_nr=569 scope.pos=16018 scope.end_pos=16048)
			// af parent scope:
			// var "cidx" var.pos=15962 var.line_nr=566
			// af parent scope:
			// var "s" var.pos=15914 var.line_nr=564
			// af parent scope:
			// af parent scope:
			return _t1706;
		}
		if ((*(v__token__Token*)/*ee elem_typ */array_get(s->all_tokens, cidx)).kind == v__token__Kind_comment) {
			if (!v__scanner__Scanner_should_parse_comment(s)) {
				continue;
			}
		}
		 v__token__Token _t1707 = (*(v__token__Token*)/*ee elem_typ */array_get(s->all_tokens, cidx));
		// autofree_scope_vars(pos=16150 line_nr=576 scope.pos=15958 scope.end_pos=16178)
		// var "cidx" var.pos=15962 var.line_nr=566
		// af parent scope:
		// var "s" var.pos=15914 var.line_nr=564
		// af parent scope:
		// af parent scope:
		return _t1707;
	}
	 v__token__Token _t1708 = v__scanner__Scanner_new_eof_token(s);
	// autofree_scope_vars(pos=16180 line_nr=578 scope.pos=15909 scope.end_pos=16206)
	// var "s" var.pos=15914 var.line_nr=564
	// af parent scope:
	// af parent scope:
	return _t1708;
}

// Attr: [inline]
inline v__token__Token v__scanner__Scanner_peek_token(v__scanner__Scanner* s, int n) {
	int idx = s->tidx + n;
	if (idx >= s->all_tokens.len) {
		 v__token__Token _t1709 = v__scanner__Scanner_new_eof_token(s);
		// autofree_scope_vars(pos=16320 line_nr=585 scope.pos=16317 scope.end_pos=16347)
		// af parent scope:
		// var "s" var.pos=16226 var.line_nr=582
		// var "n" var.pos=16249 var.line_nr=582
		// var "idx" var.pos=16271 var.line_nr=583
		// var "t" var.pos=16350 var.line_nr=587
		// af parent scope:
		// af parent scope:
		return _t1709;
	}
	v__token__Token t = (*(v__token__Token*)/*ee elem_typ */array_get(s->all_tokens, idx));
	// autofree_scope_vars(pos=16373 line_nr=588 scope.pos=16225 scope.end_pos=16383)
	// var "s" var.pos=16226 var.line_nr=582
	// var "n" var.pos=16249 var.line_nr=582
	// var "idx" var.pos=16271 var.line_nr=583
	// var "t" var.pos=16350 var.line_nr=587
	// af parent scope:
	// af parent scope:
	return t;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL byte v__scanner__Scanner_look_ahead(v__scanner__Scanner* s, int n) {
	if (s->pos + n < s->text.len) {
		 byte _t1710 = string_at(s->text, s->pos + n);
		// autofree_scope_vars(pos=16466 line_nr=594 scope.pos=16463 scope.end_pos=16493)
		// af parent scope:
		// var "s" var.pos=16399 var.line_nr=592
		// var "n" var.pos=16422 var.line_nr=592
		// af parent scope:
		// af parent scope:
		return _t1710;
	} else {
		 byte _t1711 = L'\0';
		// autofree_scope_vars(pos=16503 line_nr=596 scope.pos=16500 scope.end_pos=16517)
		// af parent scope:
		// var "s" var.pos=16399 var.line_nr=592
		// var "n" var.pos=16422 var.line_nr=592
		// af parent scope:
		// af parent scope:
		return _t1711;
	}
	return 0;
}

VV_LOCAL_SYMBOL v__token__Token v__scanner__Scanner_text_scan(v__scanner__Scanner* s) {
	for (;;) {
		if (s->is_started) {
			s->pos++;
		} else {
			s->is_started = true;
		}
		if (!s->is_inside_string) {
			v__scanner__Scanner_skip_whitespace(s);
		}
		if (s->pos >= s->text.len) {
			 v__token__Token _t1712 = v__scanner__Scanner_end_of_file(s);
			// autofree_scope_vars(pos=17186 line_nr=624 scope.pos=17182 scope.end_pos=17212)
			// af parent scope:
			// var "c" var.pos=17645 var.line_nr=642
			// var "nextc" var.pos=17666 var.line_nr=643
			// af parent scope:
			// var "s" var.pos=16530 var.line_nr=600
			// af parent scope:
			// af parent scope:
			return _t1712;
		}
		if (s->is_inter_end) {
			if (string_at(s->text, s->pos) == s->quote) {
				s->is_inter_end = false;
				 v__token__Token _t1713 = v__scanner__Scanner_new_token(s, v__token__Kind_string, _SLIT(""), 1);
				// autofree_scope_vars(pos=17335 line_nr=630 scope.pos=17303 scope.end_pos=17374)
				// af parent scope:
				// var "ident_string" var.pos=17405 var.line_nr=633
				// af parent scope:
				// var "c" var.pos=17645 var.line_nr=642
				// var "nextc" var.pos=17666 var.line_nr=643
				// af parent scope:
				// var "s" var.pos=16530 var.line_nr=600
				// af parent scope:
				// af parent scope:
				return _t1713;
			}
			s->is_inter_end = false;
			string ident_string = v__scanner__Scanner_ident_string(s);
			 v__token__Token _t1714 = v__scanner__Scanner_new_token(s, v__token__Kind_string, ident_string, ident_string.len + 2);
			// autofree_scope_vars(pos=17440 line_nr=634 scope.pos=17270 scope.end_pos=17523)
			// var "ident_string" var.pos=17405 var.line_nr=633
			// af parent scope:
			// var "c" var.pos=17645 var.line_nr=642
			// var "nextc" var.pos=17666 var.line_nr=643
			// af parent scope:
			// var "s" var.pos=16530 var.line_nr=600
			// af parent scope:
			// af parent scope:
			return _t1714;
		}
		v__scanner__Scanner_skip_whitespace(s);
		if (s->pos >= s->text.len) {
			 v__token__Token _t1715 = v__scanner__Scanner_end_of_file(s);
			// autofree_scope_vars(pos=17593 line_nr=639 scope.pos=17589 scope.end_pos=17619)
			// af parent scope:
			// var "c" var.pos=17645 var.line_nr=642
			// var "nextc" var.pos=17666 var.line_nr=643
			// af parent scope:
			// var "s" var.pos=16530 var.line_nr=600
			// af parent scope:
			// af parent scope:
			return _t1715;
		}
		byte c = string_at(s->text, s->pos);
		byte nextc = v__scanner__Scanner_look_ahead(s, 1);
		if (v__util__is_name_char(c)) {
			string name = v__scanner__Scanner_ident_name(s);
			byte next_char = v__scanner__Scanner_look_ahead(s, 1);
			v__token__Kind kind = (*(v__token__Kind*)map_get(ADDR(map, _const_v__token__keywords), &(string[]){name}, &(v__token__Kind[]){ 0 }));
			if (kind != v__token__Kind_unknown) {
				 v__token__Token _t1716 = v__scanner__Scanner_new_token(s, kind, name, name.len);
				// autofree_scope_vars(pos=17933 line_nr=652 scope.pos=17928 scope.end_pos=17978)
				// af parent scope:
				// var "name" var.pos=17743 var.line_nr=646
				// var "next_char" var.pos=17844 var.line_nr=649
				// var "kind" var.pos=17876 var.line_nr=650
				// af parent scope:
				// var "c" var.pos=17645 var.line_nr=642
				// var "nextc" var.pos=17666 var.line_nr=643
				// af parent scope:
				// var "s" var.pos=16530 var.line_nr=600
				// af parent scope:
				// af parent scope:
				return _t1716;
			}
			if (s->is_inside_string) {
				if (next_char == s->quote) {
					s->is_inter_end = true;
					s->is_inter_start = false;
					s->is_inside_string = false;
				}
			}
			if (s->is_inter_start && next_char == L'\\' && !(v__scanner__Scanner_look_ahead(s, 2) == L'x' || v__scanner__Scanner_look_ahead(s, 2) == L'n' || v__scanner__Scanner_look_ahead(s, 2) == L'r' || v__scanner__Scanner_look_ahead(s, 2) == L'\\' || v__scanner__Scanner_look_ahead(s, 2) == L't' || v__scanner__Scanner_look_ahead(s, 2) == L'e' || v__scanner__Scanner_look_ahead(s, 2) == L'"' || v__scanner__Scanner_look_ahead(s, 2) == L'\'')) {
				v__scanner__Scanner_warn(s, _STR("unknown escape sequence \\%"PRIu8"", 1, v__scanner__Scanner_look_ahead(s, 2)));
			}
			if (s->is_inter_start && next_char == L'(') {
				if (v__scanner__Scanner_look_ahead(s, 2) != L')') {
					v__scanner__Scanner_warn(s, _SLIT("use `${f(expr)}` instead of `$f(expr)`"));
				}
			} else if (s->is_inter_start && next_char != L'.') {
				s->is_inter_end = true;
				s->is_inter_start = false;
			}
			if (s->pos == 0 && next_char == L' ') {
				s->pos++;
			}
			 v__token__Token _t1717 = v__scanner__Scanner_new_token(s, v__token__Kind_name, name, name.len);
			// autofree_scope_vars(pos=18917 line_nr=682 scope.pos=17738 scope.end_pos=18962)
			// var "name" var.pos=17743 var.line_nr=646
			// var "next_char" var.pos=17844 var.line_nr=649
			// var "kind" var.pos=17876 var.line_nr=650
			// af parent scope:
			// var "c" var.pos=17645 var.line_nr=642
			// var "nextc" var.pos=17666 var.line_nr=643
			// af parent scope:
			// var "s" var.pos=16530 var.line_nr=600
			// af parent scope:
			// af parent scope:
			return _t1717;
		} else if (byte_is_digit(c) || (c == L'.' && byte_is_digit(nextc))) {
			if (!s->is_inside_string) {
				int start_pos = s->pos;
				for (;;) {
					if (!(start_pos < s->text.len && string_at(s->text, start_pos) == L'0')) break;
					start_pos++;
				}
				int prefix_zero_num = start_pos - s->pos;
				if (start_pos == s->text.len || (c == L'0' && !byte_is_digit(string_at(s->text, start_pos)))) {
					prefix_zero_num--;
				}
				s->pos += prefix_zero_num;
			}
			string num = v__scanner__Scanner_ident_number(s);
			 v__token__Token _t1718 = v__scanner__Scanner_new_token(s, v__token__Kind_number, num, num.len);
			// autofree_scope_vars(pos=19624 line_nr=699 scope.pos=19019 scope.end_pos=19669)
			// var "num" var.pos=19598 var.line_nr=698
			// af parent scope:
			// var "c" var.pos=17645 var.line_nr=642
			// var "nextc" var.pos=17666 var.line_nr=643
			// af parent scope:
			// var "s" var.pos=16530 var.line_nr=600
			// af parent scope:
			// af parent scope:
			return _t1718;
		}
		if (c == L')' && s->is_inter_start) {
			byte next_char = v__scanner__Scanner_look_ahead(s, 1);
			if (next_char != L'.') {
				s->is_inter_end = true;
				s->is_inter_start = false;
				if (next_char == s->quote) {
					s->is_inside_string = false;
				}
				 v__token__Token _t1719 = v__scanner__Scanner_new_token(s, v__token__Kind_rpar, _SLIT(""), 1);
				// autofree_scope_vars(pos=19912 line_nr=710 scope.pos=19784 scope.end_pos=19949)
				// af parent scope:
				// var "next_char" var.pos=19732 var.line_nr=703
				// af parent scope:
				// var "c" var.pos=17645 var.line_nr=642
				// var "nextc" var.pos=17666 var.line_nr=643
				// af parent scope:
				// var "s" var.pos=16530 var.line_nr=600
				// af parent scope:
				// af parent scope:
				return _t1719;
			}
		}

		if (c == (L'+')) {
			if (nextc == L'+') {
				s->pos++;
				 v__token__Token _t1720 = v__scanner__Scanner_new_token(s, v__token__Kind_inc, _SLIT(""), 2);
				// autofree_scope_vars(pos=20037 line_nr=718 scope.pos=20018 scope.end_pos=20074)
				// af parent scope:
				// af parent scope:
				// var "c" var.pos=17645 var.line_nr=642
				// var "nextc" var.pos=17666 var.line_nr=643
				// af parent scope:
				// var "s" var.pos=16530 var.line_nr=600
				// af parent scope:
				// af parent scope:
				return _t1720;
			} else if (nextc == L'=') {
				s->pos++;
				 v__token__Token _t1721 = v__scanner__Scanner_new_token(s, v__token__Kind_plus_assign, _SLIT(""), 2);
				// autofree_scope_vars(pos=20116 line_nr=721 scope.pos=20097 scope.end_pos=20161)
				// af parent scope:
				// af parent scope:
				// var "c" var.pos=17645 var.line_nr=642
				// var "nextc" var.pos=17666 var.line_nr=643
				// af parent scope:
				// var "s" var.pos=16530 var.line_nr=600
				// af parent scope:
				// af parent scope:
				return _t1721;
			}
			 v__token__Token _t1722 = v__scanner__Scanner_new_token(s, v__token__Kind_plus, _SLIT(""), 1);
			// autofree_scope_vars(pos=20166 line_nr=723 scope.pos=19992 scope.end_pos=20203)
			// af parent scope:
			// var "c" var.pos=17645 var.line_nr=642
			// var "nextc" var.pos=17666 var.line_nr=643
			// af parent scope:
			// var "s" var.pos=16530 var.line_nr=600
			// af parent scope:
			// af parent scope:
			return _t1722;
		}
		else if (c == (L'-')) {
			if (nextc == L'-') {
				s->pos++;
				 v__token__Token _t1723 = v__scanner__Scanner_new_token(s, v__token__Kind_dec, _SLIT(""), 2);
				// autofree_scope_vars(pos=20253 line_nr=728 scope.pos=20234 scope.end_pos=20290)
				// af parent scope:
				// af parent scope:
				// var "c" var.pos=17645 var.line_nr=642
				// var "nextc" var.pos=17666 var.line_nr=643
				// af parent scope:
				// var "s" var.pos=16530 var.line_nr=600
				// af parent scope:
				// af parent scope:
				return _t1723;
			} else if (nextc == L'=') {
				s->pos++;
				 v__token__Token _t1724 = v__scanner__Scanner_new_token(s, v__token__Kind_minus_assign, _SLIT(""), 2);
				// autofree_scope_vars(pos=20332 line_nr=731 scope.pos=20313 scope.end_pos=20378)
				// af parent scope:
				// af parent scope:
				// var "c" var.pos=17645 var.line_nr=642
				// var "nextc" var.pos=17666 var.line_nr=643
				// af parent scope:
				// var "s" var.pos=16530 var.line_nr=600
				// af parent scope:
				// af parent scope:
				return _t1724;
			}
			 v__token__Token _t1725 = v__scanner__Scanner_new_token(s, v__token__Kind_minus, _SLIT(""), 1);
			// autofree_scope_vars(pos=20383 line_nr=733 scope.pos=20208 scope.end_pos=20421)
			// af parent scope:
			// var "c" var.pos=17645 var.line_nr=642
			// var "nextc" var.pos=17666 var.line_nr=643
			// af parent scope:
			// var "s" var.pos=16530 var.line_nr=600
			// af parent scope:
			// af parent scope:
			return _t1725;
		}
		else if (c == (L'*')) {
			if (nextc == L'=') {
				s->pos++;
				 v__token__Token _t1726 = v__scanner__Scanner_new_token(s, v__token__Kind_mult_assign, _SLIT(""), 2);
				// autofree_scope_vars(pos=20471 line_nr=738 scope.pos=20452 scope.end_pos=20516)
				// af parent scope:
				// af parent scope:
				// var "c" var.pos=17645 var.line_nr=642
				// var "nextc" var.pos=17666 var.line_nr=643
				// af parent scope:
				// var "s" var.pos=16530 var.line_nr=600
				// af parent scope:
				// af parent scope:
				return _t1726;
			}
			 v__token__Token _t1727 = v__scanner__Scanner_new_token(s, v__token__Kind_mul, _SLIT(""), 1);
			// autofree_scope_vars(pos=20521 line_nr=740 scope.pos=20426 scope.end_pos=20557)
			// af parent scope:
			// var "c" var.pos=17645 var.line_nr=642
			// var "nextc" var.pos=17666 var.line_nr=643
			// af parent scope:
			// var "s" var.pos=16530 var.line_nr=600
			// af parent scope:
			// af parent scope:
			return _t1727;
		}
		else if (c == (L'^')) {
			if (nextc == L'=') {
				s->pos++;
				 v__token__Token _t1728 = v__scanner__Scanner_new_token(s, v__token__Kind_xor_assign, _SLIT(""), 2);
				// autofree_scope_vars(pos=20607 line_nr=745 scope.pos=20588 scope.end_pos=20651)
				// af parent scope:
				// af parent scope:
				// var "c" var.pos=17645 var.line_nr=642
				// var "nextc" var.pos=17666 var.line_nr=643
				// af parent scope:
				// var "s" var.pos=16530 var.line_nr=600
				// af parent scope:
				// af parent scope:
				return _t1728;
			}
			 v__token__Token _t1729 = v__scanner__Scanner_new_token(s, v__token__Kind_xor, _SLIT(""), 1);
			// autofree_scope_vars(pos=20656 line_nr=747 scope.pos=20562 scope.end_pos=20692)
			// af parent scope:
			// var "c" var.pos=17645 var.line_nr=642
			// var "nextc" var.pos=17666 var.line_nr=643
			// af parent scope:
			// var "s" var.pos=16530 var.line_nr=600
			// af parent scope:
			// af parent scope:
			return _t1729;
		}
		else if (c == (L'%')) {
			if (nextc == L'=') {
				s->pos++;
				 v__token__Token _t1730 = v__scanner__Scanner_new_token(s, v__token__Kind_mod_assign, _SLIT(""), 2);
				// autofree_scope_vars(pos=20742 line_nr=752 scope.pos=20723 scope.end_pos=20786)
				// af parent scope:
				// af parent scope:
				// var "c" var.pos=17645 var.line_nr=642
				// var "nextc" var.pos=17666 var.line_nr=643
				// af parent scope:
				// var "s" var.pos=16530 var.line_nr=600
				// af parent scope:
				// af parent scope:
				return _t1730;
			}
			 v__token__Token _t1731 = v__scanner__Scanner_new_token(s, v__token__Kind_mod, _SLIT(""), 1);
			// autofree_scope_vars(pos=20791 line_nr=754 scope.pos=20697 scope.end_pos=20827)
			// af parent scope:
			// var "c" var.pos=17645 var.line_nr=642
			// var "nextc" var.pos=17666 var.line_nr=643
			// af parent scope:
			// var "s" var.pos=16530 var.line_nr=600
			// af parent scope:
			// af parent scope:
			return _t1731;
		}
		else if (c == (L'?')) {
			 v__token__Token _t1732 = v__scanner__Scanner_new_token(s, v__token__Kind_question, _SLIT(""), 1);
			// autofree_scope_vars(pos=20841 line_nr=757 scope.pos=20832 scope.end_pos=20882)
			// af parent scope:
			// var "c" var.pos=17645 var.line_nr=642
			// var "nextc" var.pos=17666 var.line_nr=643
			// af parent scope:
			// var "s" var.pos=16530 var.line_nr=600
			// af parent scope:
			// af parent scope:
			return _t1732;
		}
		else if (c == (_const_v__scanner__single_quote) || c == (_const_v__scanner__double_quote)) {
			int start_line = s->line_nr;
			string ident_string = v__scanner__Scanner_ident_string(s);
			 v__token__Token _t1733 = v__scanner__Scanner_new_multiline_token(s, v__token__Kind_string, ident_string, ident_string.len + 2, start_line);
			// autofree_scope_vars(pos=21000 line_nr=762 scope.pos=20887 scope.end_pos=21111)
			// var "start_line" var.pos=20936 var.line_nr=760
			// var "ident_string" var.pos=20964 var.line_nr=761
			// af parent scope:
			// var "c" var.pos=17645 var.line_nr=642
			// var "nextc" var.pos=17666 var.line_nr=643
			// af parent scope:
			// var "s" var.pos=16530 var.line_nr=600
			// af parent scope:
			// af parent scope:
			return _t1733;
		}
		else if (c == ('`')) {
			string ident_char = v__scanner__Scanner_ident_char(s);
			 v__token__Token _t1734 = v__scanner__Scanner_new_token(s, v__token__Kind_chartoken, ident_char, ident_char.len + 2);
			// autofree_scope_vars(pos=21213 line_nr=768 scope.pos=21116 scope.end_pos=21296)
			// var "ident_char" var.pos=21181 var.line_nr=767
			// af parent scope:
			// var "c" var.pos=17645 var.line_nr=642
			// var "nextc" var.pos=17666 var.line_nr=643
			// af parent scope:
			// var "s" var.pos=16530 var.line_nr=600
			// af parent scope:
			// af parent scope:
			return _t1734;
		}
		else if (c == (L'(')) {
			if (s->pref->is_vet && string_at(s->text, s->pos + 1) == L' ') {
				v__scanner__Scanner_vet_error(s, _SLIT("Looks like you are adding a space after `(`"), v__vet__FixKind_vfmt);
			}
			 v__token__Token _t1735 = v__scanner__Scanner_new_token(s, v__token__Kind_lpar, _SLIT(""), 1);
			// autofree_scope_vars(pos=21478 line_nr=775 scope.pos=21301 scope.end_pos=21515)
			// af parent scope:
			// var "c" var.pos=17645 var.line_nr=642
			// var "nextc" var.pos=17666 var.line_nr=643
			// af parent scope:
			// var "s" var.pos=16530 var.line_nr=600
			// af parent scope:
			// af parent scope:
			return _t1735;
		}
		else if (c == (L')')) {
			if (s->pref->is_vet && string_at(s->text, s->pos - 1) == L' ') {
				v__scanner__Scanner_vet_error(s, _SLIT("Looks like you are adding a space before `)`"), v__vet__FixKind_vfmt);
			}
			 v__token__Token _t1736 = v__scanner__Scanner_new_token(s, v__token__Kind_rpar, _SLIT(""), 1);
			// autofree_scope_vars(pos=21698 line_nr=782 scope.pos=21520 scope.end_pos=21735)
			// af parent scope:
			// var "c" var.pos=17645 var.line_nr=642
			// var "nextc" var.pos=17666 var.line_nr=643
			// af parent scope:
			// var "s" var.pos=16530 var.line_nr=600
			// af parent scope:
			// af parent scope:
			return _t1736;
		}
		else if (c == (L'[')) {
			 v__token__Token _t1737 = v__scanner__Scanner_new_token(s, v__token__Kind_lsbr, _SLIT(""), 1);
			// autofree_scope_vars(pos=21749 line_nr=785 scope.pos=21740 scope.end_pos=21786)
			// af parent scope:
			// var "c" var.pos=17645 var.line_nr=642
			// var "nextc" var.pos=17666 var.line_nr=643
			// af parent scope:
			// var "s" var.pos=16530 var.line_nr=600
			// af parent scope:
			// af parent scope:
			return _t1737;
		}
		else if (c == (L']')) {
			 v__token__Token _t1738 = v__scanner__Scanner_new_token(s, v__token__Kind_rsbr, _SLIT(""), 1);
			// autofree_scope_vars(pos=21800 line_nr=788 scope.pos=21791 scope.end_pos=21837)
			// af parent scope:
			// var "c" var.pos=17645 var.line_nr=642
			// var "nextc" var.pos=17666 var.line_nr=643
			// af parent scope:
			// var "s" var.pos=16530 var.line_nr=600
			// af parent scope:
			// af parent scope:
			return _t1738;
		}
		else if (c == (L'{')) {
			if (s->is_inside_string) {
				continue;
			}
			 v__token__Token _t1739 = v__scanner__Scanner_new_token(s, v__token__Kind_lcbr, _SLIT(""), 1);
			// autofree_scope_vars(pos=21932 line_nr=795 scope.pos=21842 scope.end_pos=21969)
			// af parent scope:
			// var "c" var.pos=17645 var.line_nr=642
			// var "nextc" var.pos=17666 var.line_nr=643
			// af parent scope:
			// var "s" var.pos=16530 var.line_nr=600
			// af parent scope:
			// af parent scope:
			return _t1739;
		}
		else if (c == (L'$')) {
			if (s->is_inside_string) {
				 v__token__Token _t1740 = v__scanner__Scanner_new_token(s, v__token__Kind_str_dollar, _SLIT(""), 1);
				// autofree_scope_vars(pos=22012 line_nr=799 scope.pos=22006 scope.end_pos=22056)
				// af parent scope:
				// af parent scope:
				// var "c" var.pos=17645 var.line_nr=642
				// var "nextc" var.pos=17666 var.line_nr=643
				// af parent scope:
				// var "s" var.pos=16530 var.line_nr=600
				// af parent scope:
				// af parent scope:
				return _t1740;
			} else {
				 v__token__Token _t1741 = v__scanner__Scanner_new_token(s, v__token__Kind_dollar, _SLIT(""), 1);
				// autofree_scope_vars(pos=22069 line_nr=801 scope.pos=22063 scope.end_pos=22109)
				// af parent scope:
				// af parent scope:
				// var "c" var.pos=17645 var.line_nr=642
				// var "nextc" var.pos=17666 var.line_nr=643
				// af parent scope:
				// var "s" var.pos=16530 var.line_nr=600
				// af parent scope:
				// af parent scope:
				return _t1741;
			}
		}
		else if (c == (L'}')) {
			if (s->is_enclosed_inter) {
				if (s->pos < s->text.len - 1) {
					s->pos++;
				} else {
					v__scanner__Scanner_error(s, _SLIT("unfinished string literal"));
				}
				if (string_at(s->text, s->pos) == s->quote) {
					s->is_inside_string = false;
					s->is_enclosed_inter = false;
					 v__token__Token _t1742 = v__scanner__Scanner_new_token(s, v__token__Kind_string, _SLIT(""), 1);
					// autofree_scope_vars(pos=22428 line_nr=816 scope.pos=22354 scope.end_pos=22469)
					// af parent scope:
					// var "ident_string" var.pos=22509 var.line_nr=819
					// af parent scope:
					// af parent scope:
					// var "c" var.pos=17645 var.line_nr=642
					// var "nextc" var.pos=17666 var.line_nr=643
					// af parent scope:
					// var "s" var.pos=16530 var.line_nr=600
					// af parent scope:
					// af parent scope:
					return _t1742;
				}
				s->is_enclosed_inter = false;
				string ident_string = v__scanner__Scanner_ident_string(s);
				 v__token__Token _t1743 = v__scanner__Scanner_new_token(s, v__token__Kind_string, ident_string, ident_string.len + 2);
				// autofree_scope_vars(pos=22546 line_nr=820 scope.pos=22208 scope.end_pos=22631)
				// var "ident_string" var.pos=22509 var.line_nr=819
				// af parent scope:
				// af parent scope:
				// var "c" var.pos=17645 var.line_nr=642
				// var "nextc" var.pos=17666 var.line_nr=643
				// af parent scope:
				// var "s" var.pos=16530 var.line_nr=600
				// af parent scope:
				// af parent scope:
				return _t1743;
			} else {
				 v__token__Token _t1744 = v__scanner__Scanner_new_token(s, v__token__Kind_rcbr, _SLIT(""), 1);
				// autofree_scope_vars(pos=22644 line_nr=822 scope.pos=22638 scope.end_pos=22682)
				// af parent scope:
				// af parent scope:
				// var "c" var.pos=17645 var.line_nr=642
				// var "nextc" var.pos=17666 var.line_nr=643
				// af parent scope:
				// var "s" var.pos=16530 var.line_nr=600
				// af parent scope:
				// af parent scope:
				return _t1744;
			}
		}
		else if (c == (L'&')) {
			if (nextc == L'=') {
				s->pos++;
				 v__token__Token _t1745 = v__scanner__Scanner_new_token(s, v__token__Kind_and_assign, _SLIT(""), 2);
				// autofree_scope_vars(pos=22737 line_nr=828 scope.pos=22718 scope.end_pos=22781)
				// af parent scope:
				// var "afternextc" var.pos=22787 var.line_nr=830
				// af parent scope:
				// var "c" var.pos=17645 var.line_nr=642
				// var "nextc" var.pos=17666 var.line_nr=643
				// af parent scope:
				// var "s" var.pos=16530 var.line_nr=600
				// af parent scope:
				// af parent scope:
				return _t1745;
			}
			byte afternextc = v__scanner__Scanner_look_ahead(s, 2);
			if (nextc == L'&' && byte_is_space(afternextc)) {
				s->pos++;
				 v__token__Token _t1746 = v__scanner__Scanner_new_token(s, v__token__Kind_and, _SLIT(""), 2);
				// autofree_scope_vars(pos=22881 line_nr=833 scope.pos=22862 scope.end_pos=22918)
				// af parent scope:
				// var "afternextc" var.pos=22787 var.line_nr=830
				// af parent scope:
				// var "c" var.pos=17645 var.line_nr=642
				// var "nextc" var.pos=17666 var.line_nr=643
				// af parent scope:
				// var "s" var.pos=16530 var.line_nr=600
				// af parent scope:
				// af parent scope:
				return _t1746;
			}
			 v__token__Token _t1747 = v__scanner__Scanner_new_token(s, v__token__Kind_amp, _SLIT(""), 1);
			// autofree_scope_vars(pos=22923 line_nr=835 scope.pos=22692 scope.end_pos=22959)
			// var "afternextc" var.pos=22787 var.line_nr=830
			// af parent scope:
			// var "c" var.pos=17645 var.line_nr=642
			// var "nextc" var.pos=17666 var.line_nr=643
			// af parent scope:
			// var "s" var.pos=16530 var.line_nr=600
			// af parent scope:
			// af parent scope:
			return _t1747;
		}
		else if (c == (L'|')) {
			if (nextc == L'|') {
				s->pos++;
				 v__token__Token _t1748 = v__scanner__Scanner_new_token(s, v__token__Kind_logical_or, _SLIT(""), 2);
				// autofree_scope_vars(pos=23009 line_nr=840 scope.pos=22990 scope.end_pos=23053)
				// af parent scope:
				// af parent scope:
				// var "c" var.pos=17645 var.line_nr=642
				// var "nextc" var.pos=17666 var.line_nr=643
				// af parent scope:
				// var "s" var.pos=16530 var.line_nr=600
				// af parent scope:
				// af parent scope:
				return _t1748;
			}
			if (nextc == L'=') {
				s->pos++;
				 v__token__Token _t1749 = v__scanner__Scanner_new_token(s, v__token__Kind_or_assign, _SLIT(""), 2);
				// autofree_scope_vars(pos=23094 line_nr=844 scope.pos=23075 scope.end_pos=23137)
				// af parent scope:
				// af parent scope:
				// var "c" var.pos=17645 var.line_nr=642
				// var "nextc" var.pos=17666 var.line_nr=643
				// af parent scope:
				// var "s" var.pos=16530 var.line_nr=600
				// af parent scope:
				// af parent scope:
				return _t1749;
			}
			 v__token__Token _t1750 = v__scanner__Scanner_new_token(s, v__token__Kind_pipe, _SLIT(""), 1);
			// autofree_scope_vars(pos=23142 line_nr=846 scope.pos=22964 scope.end_pos=23179)
			// af parent scope:
			// var "c" var.pos=17645 var.line_nr=642
			// var "nextc" var.pos=17666 var.line_nr=643
			// af parent scope:
			// var "s" var.pos=16530 var.line_nr=600
			// af parent scope:
			// af parent scope:
			return _t1750;
		}
		else if (c == (L',')) {
			 v__token__Token _t1751 = v__scanner__Scanner_new_token(s, v__token__Kind_comma, _SLIT(""), 1);
			// autofree_scope_vars(pos=23193 line_nr=849 scope.pos=23184 scope.end_pos=23231)
			// af parent scope:
			// var "c" var.pos=17645 var.line_nr=642
			// var "nextc" var.pos=17666 var.line_nr=643
			// af parent scope:
			// var "s" var.pos=16530 var.line_nr=600
			// af parent scope:
			// af parent scope:
			return _t1751;
		}
		else if (c == (L'@')) {
			string name = _SLIT("");
			if (nextc != L'\0') {
				s->pos++;
				name = v__scanner__Scanner_ident_name(s);
			}
			if (s->is_fmt) {
				 v__token__Token _t1752 = v__scanner__Scanner_new_token(s, v__token__Kind_name, string_add(_SLIT("@"), name), name.len + 1);
				// autofree_scope_vars(pos=23352 line_nr=858 scope.pos=23346 scope.end_pos=23409)
				// af parent scope:
				// var "name" var.pos=23250 var.line_nr=852
				// str literal
				// af parent scope:
				// var "c" var.pos=17645 var.line_nr=642
				// var "nextc" var.pos=17666 var.line_nr=643
				// af parent scope:
				// var "s" var.pos=16530 var.line_nr=600
				// af parent scope:
				// af parent scope:
				return _t1752;
			}
			if ((Array_string_contains(_const_v__token__valid_at_tokens, string_add(_SLIT("@"), name)))) {
				 v__token__Token _t1753 = v__scanner__Scanner_new_token(s, v__token__Kind_at, string_add(_SLIT("@"), name), name.len + 1);
				// autofree_scope_vars(pos=23530 line_nr=862 scope.pos=23524 scope.end_pos=23585)
				// af parent scope:
				// var "name" var.pos=23250 var.line_nr=852
				// str literal
				// af parent scope:
				// var "c" var.pos=17645 var.line_nr=642
				// var "nextc" var.pos=17666 var.line_nr=643
				// af parent scope:
				// var "s" var.pos=16530 var.line_nr=600
				// af parent scope:
				// af parent scope:
				return _t1753;
			}
			if (!v__token__is_key(name)) {
				string at_error_msg = _SLIT("@ must be used before keywords or compile time variables (e.g. `@type string` or `@FN`)");
				if (string_is_upper(name)) {
					at_error_msg = /*f*/string_add(at_error_msg, _STR("\nAvailable compile time variables:\n%.*s", 1, Array_string_str(_const_v__token__valid_at_tokens)));
				}
				v__scanner__Scanner_error(s, at_error_msg);
			}
			 v__token__Token _t1754 = v__scanner__Scanner_new_token(s, v__token__Kind_name, name, name.len);
			// autofree_scope_vars(pos=23988 line_nr=872 scope.pos=23236 scope.end_pos=24034)
			// var "name" var.pos=23250 var.line_nr=852
			// str literal
			// af parent scope:
			// var "c" var.pos=17645 var.line_nr=642
			// var "nextc" var.pos=17666 var.line_nr=643
			// af parent scope:
			// var "s" var.pos=16530 var.line_nr=600
			// af parent scope:
			// af parent scope:
			return _t1754;
		}
		else if (c == (L'.')) {
			if (nextc == L'.') {
				s->pos++;
				if (s->pos + 1 < s->text.len && string_at(s->text, s->pos + 1) == L'.') {
					s->pos++;
					 v__token__Token _t1755 = v__scanner__Scanner_new_token(s, v__token__Kind_ellipsis, _SLIT(""), 3);
					// autofree_scope_vars(pos=24160 line_nr=879 scope.pos=24139 scope.end_pos=24203)
					// af parent scope:
					// af parent scope:
					// af parent scope:
					// var "c" var.pos=17645 var.line_nr=642
					// var "nextc" var.pos=17666 var.line_nr=643
					// af parent scope:
					// var "s" var.pos=16530 var.line_nr=600
					// af parent scope:
					// af parent scope:
					return _t1755;
				}
				 v__token__Token _t1756 = v__scanner__Scanner_new_token(s, v__token__Kind_dotdot, _SLIT(""), 2);
				// autofree_scope_vars(pos=24209 line_nr=881 scope.pos=24065 scope.end_pos=24249)
				// af parent scope:
				// af parent scope:
				// var "c" var.pos=17645 var.line_nr=642
				// var "nextc" var.pos=17666 var.line_nr=643
				// af parent scope:
				// var "s" var.pos=16530 var.line_nr=600
				// af parent scope:
				// af parent scope:
				return _t1756;
			}
			 v__token__Token _t1757 = v__scanner__Scanner_new_token(s, v__token__Kind_dot, _SLIT(""), 1);
			// autofree_scope_vars(pos=24254 line_nr=883 scope.pos=24039 scope.end_pos=24290)
			// af parent scope:
			// var "c" var.pos=17645 var.line_nr=642
			// var "nextc" var.pos=17666 var.line_nr=643
			// af parent scope:
			// var "s" var.pos=16530 var.line_nr=600
			// af parent scope:
			// af parent scope:
			return _t1757;
		}
		else if (c == (L'#')) {
			int start = s->pos + 1;
			v__scanner__Scanner_ignore_line(s);
			if (nextc == L'!') {
				string comment = string_trim_space(string_substr(s->text, start - 1, s->pos));
				 v__token__Token _t1758 = v__scanner__Scanner_new_token(s, v__token__Kind_comment, comment, comment.len + 2);
				// autofree_scope_vars(pos=24523 line_nr=892 scope.pos=24364 scope.end_pos=24583)
				// var "comment" var.pos=24416 var.line_nr=890
				// af parent scope:
				// var "start" var.pos=24305 var.line_nr=886
				// var "hash" var.pos=24589 var.line_nr=894
				// af parent scope:
				// var "c" var.pos=17645 var.line_nr=642
				// var "nextc" var.pos=17666 var.line_nr=643
				// af parent scope:
				// var "s" var.pos=16530 var.line_nr=600
				// af parent scope:
				// af parent scope:
				return _t1758;
			}
			string hash = string_trim_space(string_substr(s->text, start, s->pos));
			 v__token__Token _t1759 = v__scanner__Scanner_new_token(s, v__token__Kind_hash, hash, hash.len + 2);
			// autofree_scope_vars(pos=24634 line_nr=895 scope.pos=24295 scope.end_pos=24684)
			// var "start" var.pos=24305 var.line_nr=886
			// var "hash" var.pos=24589 var.line_nr=894
			// af parent scope:
			// var "c" var.pos=17645 var.line_nr=642
			// var "nextc" var.pos=17666 var.line_nr=643
			// af parent scope:
			// var "s" var.pos=16530 var.line_nr=600
			// af parent scope:
			// af parent scope:
			return _t1759;
		}
		else if (c == (L'>')) {
			if (nextc == L'=') {
				s->pos++;
				 v__token__Token _t1760 = v__scanner__Scanner_new_token(s, v__token__Kind_ge, _SLIT(""), 2);
				// autofree_scope_vars(pos=24734 line_nr=900 scope.pos=24715 scope.end_pos=24770)
				// af parent scope:
				// af parent scope:
				// var "c" var.pos=17645 var.line_nr=642
				// var "nextc" var.pos=17666 var.line_nr=643
				// af parent scope:
				// var "s" var.pos=16530 var.line_nr=600
				// af parent scope:
				// af parent scope:
				return _t1760;
			} else if (nextc == L'>') {
				if (s->pos + 2 < s->text.len && string_at(s->text, s->pos + 2) == L'=') {
					s->pos += 2;
					 v__token__Token _t1761 = v__scanner__Scanner_new_token(s, v__token__Kind_right_shift_assign, _SLIT(""), 3);
					// autofree_scope_vars(pos=24878 line_nr=904 scope.pos=24854 scope.end_pos=24931)
					// af parent scope:
					// af parent scope:
					// af parent scope:
					// var "c" var.pos=17645 var.line_nr=642
					// var "nextc" var.pos=17666 var.line_nr=643
					// af parent scope:
					// var "s" var.pos=16530 var.line_nr=600
					// af parent scope:
					// af parent scope:
					return _t1761;
				}
				s->pos++;
				 v__token__Token _t1762 = v__scanner__Scanner_new_token(s, v__token__Kind_right_shift, _SLIT(""), 2);
				// autofree_scope_vars(pos=24950 line_nr=907 scope.pos=24793 scope.end_pos=24995)
				// af parent scope:
				// af parent scope:
				// var "c" var.pos=17645 var.line_nr=642
				// var "nextc" var.pos=17666 var.line_nr=643
				// af parent scope:
				// var "s" var.pos=16530 var.line_nr=600
				// af parent scope:
				// af parent scope:
				return _t1762;
			} else {
				 v__token__Token _t1763 = v__scanner__Scanner_new_token(s, v__token__Kind_gt, _SLIT(""), 1);
				// autofree_scope_vars(pos=25008 line_nr=909 scope.pos=25002 scope.end_pos=25044)
				// af parent scope:
				// af parent scope:
				// var "c" var.pos=17645 var.line_nr=642
				// var "nextc" var.pos=17666 var.line_nr=643
				// af parent scope:
				// var "s" var.pos=16530 var.line_nr=600
				// af parent scope:
				// af parent scope:
				return _t1763;
			}
		}
		else if (c == (L'<')) {
			if (nextc == L'=') {
				s->pos++;
				 v__token__Token _t1764 = v__scanner__Scanner_new_token(s, v__token__Kind_le, _SLIT(""), 2);
				// autofree_scope_vars(pos=25099 line_nr=915 scope.pos=25080 scope.end_pos=25135)
				// af parent scope:
				// af parent scope:
				// var "c" var.pos=17645 var.line_nr=642
				// var "nextc" var.pos=17666 var.line_nr=643
				// af parent scope:
				// var "s" var.pos=16530 var.line_nr=600
				// af parent scope:
				// af parent scope:
				return _t1764;
			} else if (nextc == L'<') {
				if (s->pos + 2 < s->text.len && string_at(s->text, s->pos + 2) == L'=') {
					s->pos += 2;
					 v__token__Token _t1765 = v__scanner__Scanner_new_token(s, v__token__Kind_left_shift_assign, _SLIT(""), 3);
					// autofree_scope_vars(pos=25243 line_nr=919 scope.pos=25219 scope.end_pos=25295)
					// af parent scope:
					// af parent scope:
					// af parent scope:
					// var "c" var.pos=17645 var.line_nr=642
					// var "nextc" var.pos=17666 var.line_nr=643
					// af parent scope:
					// var "s" var.pos=16530 var.line_nr=600
					// af parent scope:
					// af parent scope:
					return _t1765;
				}
				s->pos++;
				 v__token__Token _t1766 = v__scanner__Scanner_new_token(s, v__token__Kind_left_shift, _SLIT(""), 2);
				// autofree_scope_vars(pos=25314 line_nr=922 scope.pos=25158 scope.end_pos=25358)
				// af parent scope:
				// af parent scope:
				// var "c" var.pos=17645 var.line_nr=642
				// var "nextc" var.pos=17666 var.line_nr=643
				// af parent scope:
				// var "s" var.pos=16530 var.line_nr=600
				// af parent scope:
				// af parent scope:
				return _t1766;
			} else if (nextc == L'-') {
				s->pos++;
				 v__token__Token _t1767 = v__scanner__Scanner_new_token(s, v__token__Kind_arrow, _SLIT(""), 2);
				// autofree_scope_vars(pos=25400 line_nr=925 scope.pos=25381 scope.end_pos=25439)
				// af parent scope:
				// af parent scope:
				// var "c" var.pos=17645 var.line_nr=642
				// var "nextc" var.pos=17666 var.line_nr=643
				// af parent scope:
				// var "s" var.pos=16530 var.line_nr=600
				// af parent scope:
				// af parent scope:
				return _t1767;
			} else {
				 v__token__Token _t1768 = v__scanner__Scanner_new_token(s, v__token__Kind_lt, _SLIT(""), 1);
				// autofree_scope_vars(pos=25452 line_nr=927 scope.pos=25446 scope.end_pos=25488)
				// af parent scope:
				// af parent scope:
				// var "c" var.pos=17645 var.line_nr=642
				// var "nextc" var.pos=17666 var.line_nr=643
				// af parent scope:
				// var "s" var.pos=16530 var.line_nr=600
				// af parent scope:
				// af parent scope:
				return _t1768;
			}
		}
		else if (c == (L'=')) {
			if (nextc == L'=') {
				s->pos++;
				 v__token__Token _t1769 = v__scanner__Scanner_new_token(s, v__token__Kind_eq, _SLIT(""), 2);
				// autofree_scope_vars(pos=25543 line_nr=933 scope.pos=25524 scope.end_pos=25579)
				// af parent scope:
				// af parent scope:
				// var "c" var.pos=17645 var.line_nr=642
				// var "nextc" var.pos=17666 var.line_nr=643
				// af parent scope:
				// var "s" var.pos=16530 var.line_nr=600
				// af parent scope:
				// af parent scope:
				return _t1769;
			} else {
				 v__token__Token _t1770 = v__scanner__Scanner_new_token(s, v__token__Kind_assign, _SLIT(""), 1);
				// autofree_scope_vars(pos=25592 line_nr=935 scope.pos=25586 scope.end_pos=25632)
				// af parent scope:
				// af parent scope:
				// var "c" var.pos=17645 var.line_nr=642
				// var "nextc" var.pos=17666 var.line_nr=643
				// af parent scope:
				// var "s" var.pos=16530 var.line_nr=600
				// af parent scope:
				// af parent scope:
				return _t1770;
			}
		}
		else if (c == (L':')) {
			if (nextc == L'=') {
				s->pos++;
				 v__token__Token _t1771 = v__scanner__Scanner_new_token(s, v__token__Kind_decl_assign, _SLIT(""), 2);
				// autofree_scope_vars(pos=25687 line_nr=941 scope.pos=25668 scope.end_pos=25732)
				// af parent scope:
				// af parent scope:
				// var "c" var.pos=17645 var.line_nr=642
				// var "nextc" var.pos=17666 var.line_nr=643
				// af parent scope:
				// var "s" var.pos=16530 var.line_nr=600
				// af parent scope:
				// af parent scope:
				return _t1771;
			} else {
				 v__token__Token _t1772 = v__scanner__Scanner_new_token(s, v__token__Kind_colon, _SLIT(""), 1);
				// autofree_scope_vars(pos=25745 line_nr=943 scope.pos=25739 scope.end_pos=25784)
				// af parent scope:
				// af parent scope:
				// var "c" var.pos=17645 var.line_nr=642
				// var "nextc" var.pos=17666 var.line_nr=643
				// af parent scope:
				// var "s" var.pos=16530 var.line_nr=600
				// af parent scope:
				// af parent scope:
				return _t1772;
			}
		}
		else if (c == (L';')) {
			 v__token__Token _t1773 = v__scanner__Scanner_new_token(s, v__token__Kind_semicolon, _SLIT(""), 1);
			// autofree_scope_vars(pos=25803 line_nr=947 scope.pos=25794 scope.end_pos=25845)
			// af parent scope:
			// var "c" var.pos=17645 var.line_nr=642
			// var "nextc" var.pos=17666 var.line_nr=643
			// af parent scope:
			// var "s" var.pos=16530 var.line_nr=600
			// af parent scope:
			// af parent scope:
			return _t1773;
		}
		else if (c == (L'!')) {
			if (nextc == L'=') {
				s->pos++;
				 v__token__Token _t1774 = v__scanner__Scanner_new_token(s, v__token__Kind_ne, _SLIT(""), 2);
				// autofree_scope_vars(pos=25895 line_nr=952 scope.pos=25876 scope.end_pos=25931)
				// af parent scope:
				// af parent scope:
				// var "c" var.pos=17645 var.line_nr=642
				// var "nextc" var.pos=17666 var.line_nr=643
				// af parent scope:
				// var "s" var.pos=16530 var.line_nr=600
				// af parent scope:
				// af parent scope:
				return _t1774;
			} else if (s->text.len > s->pos + 3 && nextc == L'i' && string_at(s->text, s->pos + 2) == L'n' && byte_is_space(string_at(s->text, s->pos + 3))) {
				s->pos += 2;
				 v__token__Token _t1775 = v__scanner__Scanner_new_token(s, v__token__Kind_not_in, _SLIT(""), 3);
				// autofree_scope_vars(pos=26067 line_nr=956 scope.pos=26045 scope.end_pos=26107)
				// af parent scope:
				// af parent scope:
				// var "c" var.pos=17645 var.line_nr=642
				// var "nextc" var.pos=17666 var.line_nr=643
				// af parent scope:
				// var "s" var.pos=16530 var.line_nr=600
				// af parent scope:
				// af parent scope:
				return _t1775;
			} else if (s->text.len > s->pos + 3 && nextc == L'i' && string_at(s->text, s->pos + 2) == L's' && byte_is_space(string_at(s->text, s->pos + 3))) {
				s->pos += 2;
				 v__token__Token _t1776 = v__scanner__Scanner_new_token(s, v__token__Kind_not_is, _SLIT(""), 3);
				// autofree_scope_vars(pos=26243 line_nr=960 scope.pos=26221 scope.end_pos=26283)
				// af parent scope:
				// af parent scope:
				// var "c" var.pos=17645 var.line_nr=642
				// var "nextc" var.pos=17666 var.line_nr=643
				// af parent scope:
				// var "s" var.pos=16530 var.line_nr=600
				// af parent scope:
				// af parent scope:
				return _t1776;
			} else {
				 v__token__Token _t1777 = v__scanner__Scanner_new_token(s, v__token__Kind_not, _SLIT(""), 1);
				// autofree_scope_vars(pos=26296 line_nr=962 scope.pos=26290 scope.end_pos=26333)
				// af parent scope:
				// af parent scope:
				// var "c" var.pos=17645 var.line_nr=642
				// var "nextc" var.pos=17666 var.line_nr=643
				// af parent scope:
				// var "s" var.pos=16530 var.line_nr=600
				// af parent scope:
				// af parent scope:
				return _t1777;
			}
		}
		else if (c == (L'~')) {
			 v__token__Token _t1778 = v__scanner__Scanner_new_token(s, v__token__Kind_bit_not, _SLIT(""), 1);
			// autofree_scope_vars(pos=26352 line_nr=966 scope.pos=26343 scope.end_pos=26392)
			// af parent scope:
			// var "c" var.pos=17645 var.line_nr=642
			// var "nextc" var.pos=17666 var.line_nr=643
			// af parent scope:
			// var "s" var.pos=16530 var.line_nr=600
			// af parent scope:
			// af parent scope:
			return _t1778;
		}
		else if (c == (L'/')) {
			if (nextc == L'=') {
				s->pos++;
				 v__token__Token _t1779 = v__scanner__Scanner_new_token(s, v__token__Kind_div_assign, _SLIT(""), 2);
				// autofree_scope_vars(pos=26442 line_nr=971 scope.pos=26423 scope.end_pos=26486)
				// af parent scope:
				// af parent scope:
				// var "c" var.pos=17645 var.line_nr=642
				// var "nextc" var.pos=17666 var.line_nr=643
				// af parent scope:
				// var "s" var.pos=16530 var.line_nr=600
				// af parent scope:
				// af parent scope:
				return _t1779;
			}
			if (nextc == L'/') {
				int start = s->pos + 1;
				v__scanner__Scanner_ignore_line(s);
				int comment_line_end = s->pos;
				if (string_at(s->text, s->pos - 1) == L'\r') {
					comment_line_end--;
				} else {
					s->pos--;
					s->line_nr--;
				}
				if (v__scanner__Scanner_should_parse_comment(s)) {
					s->line_comment = string_substr(s->text, start + 1, comment_line_end);
					string comment = s->line_comment;
					bool is_separate_line_comment = true;
					for (int j = start - 2; j >= 0 && string_at(s->text, j) != L'\n'; j--) {
						if (!(string_at(s->text, j) == L'\t' || string_at(s->text, j) == L' ')) {
							is_separate_line_comment = false;
						}
					}
					if (is_separate_line_comment) {
						comment = string_add(_SLIT("\x01"), comment);
					}
					 v__token__Token _t1780 = v__scanner__Scanner_new_token(s, v__token__Kind_comment, comment, comment.len + 2);
					// autofree_scope_vars(pos=27375 line_nr=999 scope.pos=26811 scope.end_pos=27436)
					// var "comment" var.pos=26882 var.line_nr=986
					// var "is_separate_line_comment" var.pos=26982 var.line_nr=988
					// af parent scope:
					// var "start" var.pos=26515 var.line_nr=974
					// var "comment_line_end" var.pos=26564 var.line_nr=976
					// af parent scope:
					// af parent scope:
					// var "c" var.pos=17645 var.line_nr=642
					// var "nextc" var.pos=17666 var.line_nr=643
					// af parent scope:
					// var "s" var.pos=16530 var.line_nr=600
					// af parent scope:
					// af parent scope:
					return _t1780;
				}
				continue;
			}
			if (nextc == L'*') {
				int start = s->pos + 2;
				int start_line = s->line_nr;
				int nest_count = 1;
				for (;;) {
					if (!(nest_count > 0 && s->pos < s->text.len - 1)) break;
					s->pos++;
					if (s->pos >= s->text.len) {
						s->line_nr--;
						v__scanner__Scanner_error(s, _SLIT("comment not terminated"));
					}
					if (string_at(s->text, s->pos) == L'\n') {
						v__scanner__Scanner_inc_line_number(s);
						continue;
					}
					if (v__scanner__Scanner_expect(s, _SLIT("/*"), s->pos)) {
						nest_count++;
						continue;
					}
					if (v__scanner__Scanner_expect(s, _SLIT("*/"), s->pos)) {
						nest_count--;
					}
				}
				s->pos++;
				if (v__scanner__Scanner_should_parse_comment(s)) {
					string comment = string_trim(string_substr(s->text, start, (s->pos - 1)), _SLIT(" "));
					if (!string_contains(comment, _SLIT("\n"))) {
						comment = string_add(_SLIT("\x01"), comment);
					}
					 v__token__Token _t1781 = v__scanner__Scanner_new_multiline_token(s, v__token__Kind_comment, comment, comment.len + 4, start_line);
					// autofree_scope_vars(pos=28297 line_nr=1035 scope.pos=28155 scope.end_pos=28387)
					// var "comment" var.pos=28167 var.line_nr=1031
					// af parent scope:
					// var "start" var.pos=27621 var.line_nr=1007
					// var "start_line" var.pos=27645 var.line_nr=1008
					// var "nest_count" var.pos=27678 var.line_nr=1009
					// af parent scope:
					// af parent scope:
					// var "c" var.pos=17645 var.line_nr=642
					// var "nextc" var.pos=17666 var.line_nr=643
					// af parent scope:
					// var "s" var.pos=16530 var.line_nr=600
					// af parent scope:
					// af parent scope:
					return _t1781;
				}
				continue;
			}
			 v__token__Token _t1782 = v__scanner__Scanner_new_token(s, v__token__Kind_div, _SLIT(""), 1);
			// autofree_scope_vars(pos=28444 line_nr=1041 scope.pos=26397 scope.end_pos=28480)
			// af parent scope:
			// var "c" var.pos=17645 var.line_nr=642
			// var "nextc" var.pos=17666 var.line_nr=643
			// af parent scope:
			// var "s" var.pos=16530 var.line_nr=600
			// af parent scope:
			// af parent scope:
			return _t1782;
		}
		else {
		};
		if (c == L'\0') {
			 v__token__Token _t1783 = v__scanner__Scanner_end_of_file(s);
			// autofree_scope_vars(pos=28534 line_nr=1047 scope.pos=28529 scope.end_pos=28561)
			// af parent scope:
			// af parent scope:
			// var "c" var.pos=17645 var.line_nr=642
			// var "nextc" var.pos=17666 var.line_nr=643
			// af parent scope:
			// var "s" var.pos=16530 var.line_nr=600
			// af parent scope:
			// af parent scope:
			return _t1783;
		}
		v__scanner__Scanner_invalid_character(s);
		break;
	}
	 v__token__Token _t1784 = v__scanner__Scanner_end_of_file(s);
	// autofree_scope_vars(pos=28602 line_nr=1053 scope.pos=16525 scope.end_pos=28626)
	// var "s" var.pos=16530 var.line_nr=600
	// af parent scope:
	// af parent scope:
	return _t1784;
}

VV_LOCAL_SYMBOL void v__scanner__Scanner_invalid_character(v__scanner__Scanner* s) {
	int len = utf8_char_len(string_at(s->text, s->pos));
	int end = math__mathutil__min_T_int(s->pos + len, s->text.len);
	string c = string_substr(s->text, s->pos, end);
	v__scanner__Scanner_error(s, _STR("invalid character `%.*s\000`", 2, c));
}

VV_LOCAL_SYMBOL int v__scanner__Scanner_current_column(v__scanner__Scanner* s) {
	 int _t1785 = s->pos - s->last_nl_pos;
	// autofree_scope_vars(pos=28849 line_nr=1064 scope.pos=28813 scope.end_pos=28879)
	// var "s" var.pos=28814 var.line_nr=1063
	// af parent scope:
	// af parent scope:
	return _t1785;
}

VV_LOCAL_SYMBOL int v__scanner__Scanner_count_symbol_before(v__scanner__Scanner* s, int p, byte sym) {
	int count = 0;
	for (int i = p; i >= 0; i--) {
		if (string_at(s->text, i) != sym) {
			break;
		}
		count++;
	}
	// autofree_scope_vars(pos=29034 line_nr=1075 scope.pos=28885 scope.end_pos=29048)
	// var "s" var.pos=28886 var.line_nr=1067
	// var "p" var.pos=28918 var.line_nr=1067
	// var "sym" var.pos=28925 var.line_nr=1067
	// var "count" var.pos=28946 var.line_nr=1068
	// af parent scope:
	// af parent scope:
	return count;
}

VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_string(v__scanner__Scanner* s) {
	byte q = string_at(s->text, s->pos);
	bool is_quote = q == _const_v__scanner__single_quote || q == _const_v__scanner__double_quote;
	bool is_raw = is_quote && s->pos > 0 && string_at(s->text, s->pos - 1) == L'r' && !s->is_inside_string;
	bool is_cstr = is_quote && s->pos > 0 && string_at(s->text, s->pos - 1) == L'c' && !s->is_inside_string;
	if (is_quote) {
		if (s->is_inside_string || s->is_enclosed_inter || s->is_inter_start) {
			s->inter_quote = q;
		} else {
			s->quote = q;
		}
	}
	int n_cr_chars = 0;
	int start = s->pos;
	if (string_at(s->text, start) == s->quote || (string_at(s->text, start) == s->inter_quote && (s->is_inter_start || s->is_enclosed_inter))) {
		start++;
	}
	s->is_inside_string = false;
	Array_int u_escapes_pos = __new_array_with_default(0, 0, sizeof(int), 0);
	rune slash = L'\\';
	for (;;) {
		s->pos++;
		if (s->pos >= s->text.len) {
			v__scanner__Scanner_error(s, _SLIT("unfinished string literal"));
			break;
		}
		byte c = string_at(s->text, s->pos);
		byte prevc = string_at(s->text, s->pos - 1);
		if (c == s->quote && (prevc != slash || (prevc == slash && string_at(s->text, s->pos - 2) == slash))) {
			break;
		}
		if (c == s->inter_quote && (s->is_inter_start || s->is_enclosed_inter)) {
			break;
		}
		if (c == L'\r') {
			n_cr_chars++;
		}
		if (c == L'\n') {
			v__scanner__Scanner_inc_line_number(s);
		}
		if (c == L'0' && s->pos > 2 && prevc == slash) {
			if ((s->pos < s->text.len - 1 && byte_is_digit(string_at(s->text, s->pos + 1))) || v__scanner__Scanner_count_symbol_before(s, s->pos - 1, slash) % 2 == 0) {
			} else if (!is_cstr && !is_raw) {
				v__scanner__Scanner_error(s, _SLIT("cannot use `\\0` (NULL character) in the string literal"));
			}
		}
		if (c == L'0' && s->pos > 5 && v__scanner__Scanner_expect(s, _SLIT("\\x0"), s->pos - 3)) {
			if (v__scanner__Scanner_count_symbol_before(s, s->pos - 3, slash) % 2 == 0) {
			} else if (!is_cstr && !is_raw) {
				v__scanner__Scanner_error(s, _SLIT("cannot use `\\x00` (NULL character) in the string literal"));
			}
		}
		if (prevc == slash && !is_raw && !is_cstr && v__scanner__Scanner_count_symbol_before(s, s->pos - 2, slash) % 2 == 0) {
			if (c == L'x' && (string_at(s->text, s->pos + 1) == s->quote || !byte_is_hex_digit(string_at(s->text, s->pos + 1)))) {
				v__scanner__Scanner_error(s, _SLIT("`\\x` used with no following hex digits"));
			}
			if (c == L'u') {
				if (string_at(s->text, s->pos + 1) == s->quote || string_at(s->text, s->pos + 2) == s->quote || string_at(s->text, s->pos + 3) == s->quote || string_at(s->text, s->pos + 4) == s->quote || !byte_is_hex_digit(string_at(s->text, s->pos + 1)) || !byte_is_hex_digit(string_at(s->text, s->pos + 2)) || !byte_is_hex_digit(string_at(s->text, s->pos + 3)) || !byte_is_hex_digit(string_at(s->text, s->pos + 4))) {
					v__scanner__Scanner_error(s, _SLIT("`\\u` incomplete unicode character value"));
				}
				array_push(&u_escapes_pos, _MOV((int[]){ s->pos - 1 }));
			}
		}
		if (prevc == L'$' && c == L'{' && !is_raw && v__scanner__Scanner_count_symbol_before(s, s->pos - 2, slash) % 2 == 0) {
			s->is_inside_string = true;
			s->is_enclosed_inter = true;
			s->pos -= 2;
			break;
		}
		if (prevc == L'$' && v__util__is_name_char(c) && !is_raw && v__scanner__Scanner_count_symbol_before(s, s->pos - 2, slash) % 2 == 0) {
			s->is_inside_string = true;
			s->is_inter_start = true;
			s->pos -= 2;
			break;
		}
	}
	string lit = _SLIT("");
	int end = s->pos;
	if (s->is_inside_string) {
		end++;
	}
	if (start <= s->pos) {
		string string_so_far = string_substr(s->text, start, end);
		if (!s->is_fmt && u_escapes_pos.len > 0) {
			string_so_far = v__scanner__decode_u_escapes(string_so_far, start, u_escapes_pos);
		}
		if (n_cr_chars > 0) {
			string_so_far = string_replace(string_so_far, _SLIT("\r"), _SLIT(""));
		}
		if (string_contains(string_so_far, _SLIT("\\\n"))) {
			lit = v__scanner__trim_slash_line_break(string_so_far);
		} else {
			lit = string_so_far;
		}
	}
	// autofree_scope_vars(pos=32616 line_nr=1193 scope.pos=29054 scope.end_pos=32628)
	// var "s" var.pos=29059 var.line_nr=1078
	// var "q" var.pos=29095 var.line_nr=1079
	// var "is_quote" var.pos=29115 var.line_nr=1080
	// var "is_raw" var.pos=29183 var.line_nr=1081
	// var "is_cstr" var.pos=29267 var.line_nr=1082
	// var "n_cr_chars" var.pos=29673 var.line_nr=1094
	// var "start" var.pos=29694 var.line_nr=1095
	// var "u_escapes_pos" var.pos=29869 var.line_nr=1101
	// var "slash" var.pos=29917 var.line_nr=1102
	// var "lit" var.pos=32168 var.line_nr=1174
	// str literal
	// var "end" var.pos=32183 var.line_nr=1175
	// af parent scope:
	// af parent scope:
	return lit;
}

VV_LOCAL_SYMBOL string v__scanner__decode_u_escapes(string s, int start, Array_int escapes_pos) {
	if (escapes_pos.len == 0) {
		// autofree_scope_vars(pos=32728 line_nr=1198 scope.pos=32725 scope.end_pos=32739)
		// af parent scope:
		// var "s" var.pos=32651 var.line_nr=1196
		// var "start" var.pos=32661 var.line_nr=1196
		// var "escapes_pos" var.pos=32672 var.line_nr=1196
		// var "ss" var.pos=32746 var.line_nr=1200
		// af parent scope:
		// af parent scope:
		return s;
	}
	Array_string ss = __new_array_with_default(0, escapes_pos.len * 2 + 1, sizeof(string), 0);
	array_push(&ss, _MOV((string[]){ string_clone(string_substr(s, 0, (*(int*)array_first(escapes_pos)) - start)) }));
	// FOR IN array
	for (int i = 0; i < escapes_pos.len; ++i) {
		int pos = ((int*)escapes_pos.data)[i];
		int idx = pos - start;
		int end_idx = idx + 6;
		array_push(&ss, _MOV((string[]){ string_clone(utf32_to_str(((u32)(strconv__parse_uint(string_substr(s, idx + 2, end_idx), 16, 32))))) }));
		if (i + 1 < escapes_pos.len) {
			array_push(&ss, _MOV((string[]){ string_clone(string_substr(s, end_idx, (*(int*)/*ee elem_typ */array_get(escapes_pos, i + 1)) - start)) }));
		} else {
			array_push(&ss, _MOV((string[]){ string_clone(string_substr(s, end_idx, s.len)) }));
		}
	}
	 string _t1791 = Array_string_join(ss, _SLIT(""));
	// autofree_scope_vars(pos=33117 line_nr=1212 scope.pos=32634 scope.end_pos=33137)
	// var "s" var.pos=32651 var.line_nr=1196
	// var "start" var.pos=32661 var.line_nr=1196
	// var "escapes_pos" var.pos=32672 var.line_nr=1196
	// var "ss" var.pos=32746 var.line_nr=1200
	// af parent scope:
	// af parent scope:
	return _t1791;
}

VV_LOCAL_SYMBOL string v__scanner__trim_slash_line_break(string s) {
	int start = 0;
	string ret_str = s;
	for (;;) {
		int idx = string_index_after(ret_str, _SLIT("\\\n"), start);
		if (idx != -1) {
			ret_str = string_add(string_substr(ret_str, 0, idx), string_trim_left(string_substr(ret_str, idx + 2, ret_str.len), _SLIT(" \n\t\v\f\r")));
			start = idx;
		} else {
			break;
		}
	}
	// autofree_scope_vars(pos=33402 line_nr=1227 scope.pos=33143 scope.end_pos=33418)
	// var "s" var.pos=33165 var.line_nr=1215
	// var "start" var.pos=33189 var.line_nr=1216
	// var "ret_str" var.pos=33205 var.line_nr=1217
	// af parent scope:
	// af parent scope:
	return ret_str;
}

VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_char(v__scanner__Scanner* s) {
	int start = s->pos;
	rune slash = L'\\';
	int len = 0;
	for (;;) {
		s->pos++;
		if (s->pos >= s->text.len) {
			break;
		}
		if (string_at(s->text, s->pos) != slash) {
			len++;
		}
		bool double_slash = v__scanner__Scanner_expect(s, _SLIT("\\\\"), s->pos - 2);
		if (string_at(s->text, s->pos) == '`' && (string_at(s->text, s->pos - 1) != slash || double_slash)) {
			if (double_slash) {
				len++;
			}
			break;
		}
	}
	len--;
	string c = string_substr(s->text, start + 1, s->pos);
	if (len != 1) {
		ustring u = string_ustring(c);
		if (u.len != 1) {
			v__scanner__Scanner_error(s, string_add(_SLIT("invalid character literal (more than one character)\n"), _SLIT("use quotes for strings, backticks for characters")));
		}
	}
	if (string_eq(c, _SLIT("'"))) {
		 string _t1792 = string_add(_SLIT("\\"), c);
		// autofree_scope_vars(pos=34101 line_nr=1262 scope.pos=34098 scope.end_pos=34119)
		// af parent scope:
		// var "s" var.pos=33429 var.line_nr=1230
		// var "start" var.pos=33463 var.line_nr=1231
		// var "slash" var.pos=33479 var.line_nr=1232
		// var "len" var.pos=33498 var.line_nr=1233
		// var "c" var.pos=33843 var.line_nr=1252
		// af parent scope:
		// af parent scope:
		return _t1792;
	}
	// autofree_scope_vars(pos=34121 line_nr=1264 scope.pos=33424 scope.end_pos=34131)
	// var "s" var.pos=33429 var.line_nr=1230
	// var "start" var.pos=33463 var.line_nr=1231
	// var "slash" var.pos=33479 var.line_nr=1232
	// var "len" var.pos=33498 var.line_nr=1233
	// var "c" var.pos=33843 var.line_nr=1252
	// af parent scope:
	// af parent scope:
	return c;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL bool v__scanner__Scanner_expect(v__scanner__Scanner* s, string want, int start_pos) {
	int end_pos = start_pos + want.len;
	if (start_pos < 0 || end_pos < 0 || start_pos >= s->text.len || end_pos > s->text.len) {
		 bool _t1793 = false;
		// autofree_scope_vars(pos=34321 line_nr=1271 scope.pos=34318 scope.end_pos=34336)
		// af parent scope:
		// var "s" var.pos=34147 var.line_nr=1268
		// var "want" var.pos=34166 var.line_nr=1268
		// var "start_pos" var.pos=34179 var.line_nr=1268
		// var "end_pos" var.pos=34202 var.line_nr=1269
		// af parent scope:
		// af parent scope:
		return _t1793;
	}
	for (int pos = start_pos; pos < end_pos; ++pos) {
		if (string_at(s->text, pos) != string_at(want, pos - start_pos)) {
			 bool _t1794 = false;
			// autofree_scope_vars(pos=34419 line_nr=1275 scope.pos=34415 scope.end_pos=34435)
			// af parent scope:
			// var "pos" var.pos=34343 var.line_nr=1273
			// skipping tmp var "pos"
			// af parent scope:
			// var "s" var.pos=34147 var.line_nr=1268
			// var "want" var.pos=34166 var.line_nr=1268
			// var "start_pos" var.pos=34179 var.line_nr=1268
			// var "end_pos" var.pos=34202 var.line_nr=1269
			// af parent scope:
			// af parent scope:
			return _t1794;
		}
	}
	 bool _t1795 = true;
	// autofree_scope_vars(pos=34440 line_nr=1278 scope.pos=34146 scope.end_pos=34453)
	// var "s" var.pos=34147 var.line_nr=1268
	// var "want" var.pos=34166 var.line_nr=1268
	// var "start_pos" var.pos=34179 var.line_nr=1268
	// var "end_pos" var.pos=34202 var.line_nr=1269
	// af parent scope:
	// af parent scope:
	return _t1795;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL void v__scanner__Scanner_ignore_line(v__scanner__Scanner* s) {
	v__scanner__Scanner_eat_to_end_of_line(s);
	v__scanner__Scanner_inc_line_number(s);
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL void v__scanner__Scanner_eat_to_end_of_line(v__scanner__Scanner* s) {
	for (;;) {
		if (!(s->pos < s->text.len && string_at(s->text, s->pos) != L'\n')) break;
		s->pos++;
	}
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL void v__scanner__Scanner_inc_line_number(v__scanner__Scanner* s) {
	s->last_nl_pos = math__mathutil__min_T_int(s->text.len - 1, s->pos);
	if (s->is_crlf) {
		s->last_nl_pos++;
	}
	s->line_nr++;
	array_push(&s->line_ends, _MOV((int[]){ s->pos }));
	if (s->line_nr > s->nr_lines) {
		s->nr_lines = s->line_nr;
	}
}

void v__scanner__Scanner_note(v__scanner__Scanner* s, string msg) {
	v__token__Position pos = (v__token__Position){.len = 0,.line_nr = s->line_nr,.pos = s->pos,.col = 0,.last_line = 0,};
	if (s->pref->output_mode == v__pref__OutputMode_stdout) {
		eprintln(v__util__formatted_error(_SLIT("notice:"), msg, s->file_path, pos));
	} else {
		array_push(&s->notices, _MOV((v__errors__Notice[]){ (v__errors__Notice){.message = msg,.details = (string){.str=(byteptr)"", .is_lit=1},.file_path = s->file_path,.pos = pos,.reporter = v__errors__Reporter_scanner,} }));
	}
}

void v__scanner__Scanner_warn(v__scanner__Scanner* s, string msg) {
	if (s->pref->warns_are_errors) {
		v__scanner__Scanner_error(s, msg);
		return;
	}
	v__token__Position pos = (v__token__Position){.len = 0,.line_nr = s->line_nr,.pos = s->pos,.col = v__scanner__Scanner_current_column(s) - 1,.last_line = 0,};
	if (s->pref->output_mode == v__pref__OutputMode_stdout) {
		eprintln(v__util__formatted_error(_SLIT("warning:"), msg, s->file_path, pos));
	} else {
		array_push(&s->warnings, _MOV((v__errors__Warning[]){ (v__errors__Warning){.message = msg,.details = (string){.str=(byteptr)"", .is_lit=1},.file_path = s->file_path,.pos = pos,.reporter = v__errors__Reporter_scanner,} }));
	}
}

void v__scanner__Scanner_error(v__scanner__Scanner* s, string msg) {
	v__token__Position pos = (v__token__Position){.len = 0,.line_nr = s->line_nr,.pos = s->pos,.col = v__scanner__Scanner_current_column(s) - 1,.last_line = 0,};
	if (s->pref->output_mode == v__pref__OutputMode_stdout) {
		eprintln(v__util__formatted_error(_SLIT("error:"), msg, s->file_path, pos));
		v_exit(1);
	} else {
		if (s->pref->fatal_errors) {
			v_exit(1);
		}
		array_push(&s->errors, _MOV((v__errors__Error[]){ (v__errors__Error){.message = msg,.details = (string){.str=(byteptr)"", .is_lit=1},.file_path = s->file_path,.pos = pos,.backtrace = (string){.str=(byteptr)"", .is_lit=1},.reporter = v__errors__Reporter_scanner,} }));
	}
}

VV_LOCAL_SYMBOL void v__scanner__Scanner_vet_error(v__scanner__Scanner* s, string msg, v__vet__FixKind fix) {
	v__vet__Error ve = (v__vet__Error){
		.kind = v__vet__ErrorKind_error,
		.message = msg,
		.details = (string){.str=(byteptr)"", .is_lit=1},
		.file_path = s->file_path,
		.pos = (v__token__Position){.len = 0,.line_nr = s->line_nr,.pos = 0,.col = v__scanner__Scanner_current_column(s) - 1,.last_line = 0,},
		.fix = fix,
		.typ = v__vet__ErrorType_default,
	};
	array_push(&s->vet_errors, _MOV((v__vet__Error[]){ ve }));
}

void v__scanner__verror(string s) {
	v__util__verror(_SLIT("scanner error"), s);
}

void v__scanner__Scanner_codegen(v__scanner__Scanner* s, string newtext) {
	if (s->comments_mode == v__scanner__CommentsMode_skip_comments) {
		array_delete_last(&s->all_tokens);
		s->text = /*f*/string_add(s->text, newtext);
		int old_tidx = s->tidx;
		s->tidx = s->all_tokens.len;
		v__scanner__Scanner_scan_remaining_text(s);
		s->tidx = old_tidx;
	}
}

VV_LOCAL_SYMBOL void v__scanner__Scanner_trace(v__scanner__Scanner* s, string fbase, string message) {
	if (string_eq(s->file_base, fbase)) {
		println(_STR("> s.trace | %*.*s\000 | %.*s", 2, fbase, -10, message));
	}
}

Option_void v__checker__Checker_check_expected_call_arg(v__checker__Checker* c, v__ast__Type got, v__ast__Type expected_, v__ast__Language language) {
	v__ast__Type expected = expected_;
	if (v__ast__Type_has_flag(expected, v__ast__TypeFlag_variadic)) {
		v__ast__TypeSymbol* exp_type_sym = v__ast__Table_get_type_symbol(c->table, expected_);
		v__ast__Array exp_info = /* as */ *(v__ast__Array*)__as_cast((exp_type_sym->info)._v__ast__Array,(exp_type_sym->info)._typ, 395) /*expected idx: 395, name: v.ast.Array */ ;
		expected = exp_info.elem_type;
	}
	if (language == v__ast__Language_c) {
		if (v__ast__Type_is_number(got) && v__ast__Type_is_number(expected)) {
			return (Option_void){0};
		}
		if (v__ast__Type_is_number(got) && v__ast__Type_idx(expected) == _const_v__ast__size_t_type_idx) {
			return (Option_void){0};
		}
		if ((v__ast__Type_idx(got) == _const_v__ast__bool_type_idx && (v__ast__Type_idx(expected) == _const_v__ast__int_type_idx || v__ast__Type_idx(expected) == _const_v__ast__int_literal_type_idx)) || (v__ast__Type_idx(expected) == _const_v__ast__bool_type_idx && (v__ast__Type_idx(got) == _const_v__ast__int_type_idx || v__ast__Type_idx(got) == _const_v__ast__int_literal_type_idx))) {
			return (Option_void){0};
		}
		if (v__ast__Type_idx(got) == _const_v__ast__string_type_idx && ((expected == _const_v__ast__byteptr_type_idx || expected == _const_v__ast__charptr_type_idx) || (v__ast__Type_idx(expected) == _const_v__ast__char_type_idx && v__ast__Type_is_ptr(expected)))) {
			return (Option_void){0};
		}
		v__ast__TypeSymbol* exp_sym = v__ast__Table_get_type_symbol(c->table, expected);
		if (v__ast__Type_is_ptr(expected) && exp_sym->language == v__ast__Language_c && exp_sym->kind == v__ast__Kind_placeholder && got == _const_v__ast__int_type_idx) {
			return (Option_void){0};
		}
	}
	if (v__checker__Checker_check_types(c, got, expected)) {
		return (Option_void){0};
	}
	int idx_got = v__ast__Type_idx(got);
	int idx_expected = v__ast__Type_idx(expected);
	if ((idx_got == _const_v__ast__byteptr_type_idx || idx_got == _const_v__ast__charptr_type_idx) || (idx_expected == _const_v__ast__byteptr_type_idx || idx_expected == _const_v__ast__charptr_type_idx)) {
		int igot = ((int)(got));
		int iexpected = ((int)(expected));
		if ((igot == _const_v__ast__byteptr_type_idx && iexpected == 65545) || (iexpected == _const_v__ast__byteptr_type_idx && igot == 65545)) {
			return (Option_void){0};
		}
		if ((igot == _const_v__ast__charptr_type_idx && iexpected == 65551) || (iexpected == _const_v__ast__charptr_type_idx && igot == 65551)) {
			return (Option_void){0};
		}
		int muls_got = v__ast__Type_nr_muls(got);
		int muls_expected = v__ast__Type_nr_muls(expected);
		if (idx_got == _const_v__ast__byteptr_type_idx && idx_expected == _const_v__ast__byte_type_idx && muls_got + 1 == muls_expected) {
			return (Option_void){0};
		}
		if (idx_expected == _const_v__ast__byteptr_type_idx && idx_got == _const_v__ast__byte_type_idx && muls_expected + 1 == muls_got) {
			return (Option_void){0};
		}
		if (idx_got == _const_v__ast__charptr_type_idx && idx_expected == _const_v__ast__char_type_idx && muls_got + 1 == muls_expected) {
			return (Option_void){0};
		}
		if (idx_expected == _const_v__ast__charptr_type_idx && idx_got == _const_v__ast__char_type_idx && muls_expected + 1 == muls_got) {
			return (Option_void){0};
		}
	}
	return (Option_void){ .state=2, .err=v_error(_STR("cannot use `%.*s\000` as `%.*s\000`", 3, v__ast__Table_type_to_str(c->table, v__ast__Type_clear_flag(got, v__ast__TypeFlag_variadic)), v__ast__Table_type_to_str(c->table, v__ast__Type_clear_flag(expected, v__ast__TypeFlag_variadic)))) };
}

bool v__checker__Checker_check_basic(v__checker__Checker* c, v__ast__Type got, v__ast__Type expected) {
	v__ast__Type got_ = v__ast__Table_unalias_num_type(c->table, got);
	v__ast__Type exp_ = v__ast__Table_unalias_num_type(c->table, expected);
	if (v__ast__Type_idx(got_) == v__ast__Type_idx(exp_)) {
		 bool _t1801 = true;
		// autofree_scope_vars(pos=3572 line_nr=97 scope.pos=3461 scope.end_pos=3586)
		// af parent scope:
		// var "c" var.pos=3288 var.line_nr=92
		// var "got" var.pos=3311 var.line_nr=92
		// var "expected" var.pos=3325 var.line_nr=92
		// var "got_" var.pos=3352 var.line_nr=93
		// var "exp_" var.pos=3358 var.line_nr=93
		// var "got_sym" var.pos=4005 var.line_nr=110
		// var "exp_sym" var.pos=4014 var.line_nr=110
		// var "expected_nonflagged" var.pos=5162 var.line_nr=142
		// af parent scope:
		// af parent scope:
		return _t1801;
	}
	if ((v__ast__Type_is_pointer(exp_) || v__ast__Type_is_number(exp_)) && (v__ast__Type_is_pointer(got_) || v__ast__Type_is_number(got_))) {
		 bool _t1802 = true;
		// autofree_scope_vars(pos=3678 line_nr=100 scope.pos=3675 scope.end_pos=3692)
		// af parent scope:
		// var "c" var.pos=3288 var.line_nr=92
		// var "got" var.pos=3311 var.line_nr=92
		// var "expected" var.pos=3325 var.line_nr=92
		// var "got_" var.pos=3352 var.line_nr=93
		// var "exp_" var.pos=3358 var.line_nr=93
		// var "got_sym" var.pos=4005 var.line_nr=110
		// var "exp_sym" var.pos=4014 var.line_nr=110
		// var "expected_nonflagged" var.pos=5162 var.line_nr=142
		// af parent scope:
		// af parent scope:
		return _t1802;
	}
	if (v__ast__Type_is_ptr(expected) && v__ast__Type_alias_eq(got_, _const_v__ast__int_literal_type)) {
		 bool _t1803 = true;
		// autofree_scope_vars(pos=3819 line_nr=104 scope.pos=3816 scope.end_pos=3833)
		// af parent scope:
		// var "c" var.pos=3288 var.line_nr=92
		// var "got" var.pos=3311 var.line_nr=92
		// var "expected" var.pos=3325 var.line_nr=92
		// var "got_" var.pos=3352 var.line_nr=93
		// var "exp_" var.pos=3358 var.line_nr=93
		// var "got_sym" var.pos=4005 var.line_nr=110
		// var "exp_sym" var.pos=4014 var.line_nr=110
		// var "expected_nonflagged" var.pos=5162 var.line_nr=142
		// af parent scope:
		// af parent scope:
		return _t1803;
	}
	if (v__ast__Type_idx(expected) == _const_v__ast__array_type_idx || v__ast__Type_idx(got) == _const_v__ast__array_type_idx) {
		 bool _t1804 = true;
		// autofree_scope_vars(pos=3988 line_nr=108 scope.pos=3985 scope.end_pos=4002)
		// af parent scope:
		// var "c" var.pos=3288 var.line_nr=92
		// var "got" var.pos=3311 var.line_nr=92
		// var "expected" var.pos=3325 var.line_nr=92
		// var "got_" var.pos=3352 var.line_nr=93
		// var "exp_" var.pos=3358 var.line_nr=93
		// var "got_sym" var.pos=4005 var.line_nr=110
		// var "exp_sym" var.pos=4014 var.line_nr=110
		// var "expected_nonflagged" var.pos=5162 var.line_nr=142
		// af parent scope:
		// af parent scope:
		return _t1804;
	}
	v__ast__TypeSymbol* got_sym = v__ast__Table_get_type_symbol(c->table, got);
	v__ast__TypeSymbol* exp_sym = v__ast__Table_get_type_symbol(c->table, expected);
	if ((got_sym->kind == v__ast__Kind_array || got_sym->kind == v__ast__Kind_map || got_sym->kind == v__ast__Kind_array_fixed) && exp_sym->kind == got_sym->kind) {
		if (string_eq(v__ast__Table_type_to_str(c->table, got), string_trim(v__ast__Table_type_to_str(c->table, expected), _SLIT("&")))) {
			 bool _t1805 = true;
			// autofree_scope_vars(pos=4275 line_nr=114 scope.pos=4271 scope.end_pos=4290)
			// af parent scope:
			// af parent scope:
			// var "c" var.pos=3288 var.line_nr=92
			// var "got" var.pos=3311 var.line_nr=92
			// var "expected" var.pos=3325 var.line_nr=92
			// var "got_" var.pos=3352 var.line_nr=93
			// var "exp_" var.pos=3358 var.line_nr=93
			// var "got_sym" var.pos=4005 var.line_nr=110
			// var "exp_sym" var.pos=4014 var.line_nr=110
			// var "expected_nonflagged" var.pos=5162 var.line_nr=142
			// af parent scope:
			// af parent scope:
			return _t1805;
		}
	}
	if (!v__ast__Type_is_ptr(got_) && got_sym->kind == v__ast__Kind_array_fixed && (v__ast__Type_is_pointer(exp_) || v__ast__Type_is_ptr(exp_))) {
		 bool _t1806 = false;
		// autofree_scope_vars(pos=4442 line_nr=119 scope.pos=4386 scope.end_pos=4457)
		// af parent scope:
		// var "c" var.pos=3288 var.line_nr=92
		// var "got" var.pos=3311 var.line_nr=92
		// var "expected" var.pos=3325 var.line_nr=92
		// var "got_" var.pos=3352 var.line_nr=93
		// var "exp_" var.pos=3358 var.line_nr=93
		// var "got_sym" var.pos=4005 var.line_nr=110
		// var "exp_sym" var.pos=4014 var.line_nr=110
		// var "expected_nonflagged" var.pos=5162 var.line_nr=142
		// af parent scope:
		// af parent scope:
		return _t1806;
	}
	if ((exp_sym->kind == v__ast__Kind_voidptr || exp_sym->kind == v__ast__Kind_any) || (got_sym->kind == v__ast__Kind_voidptr || got_sym->kind == v__ast__Kind_any)) {
		 bool _t1807 = true;
		// autofree_scope_vars(pos=4535 line_nr=122 scope.pos=4532 scope.end_pos=4549)
		// af parent scope:
		// var "c" var.pos=3288 var.line_nr=92
		// var "got" var.pos=3311 var.line_nr=92
		// var "expected" var.pos=3325 var.line_nr=92
		// var "got_" var.pos=3352 var.line_nr=93
		// var "exp_" var.pos=3358 var.line_nr=93
		// var "got_sym" var.pos=4005 var.line_nr=110
		// var "exp_sym" var.pos=4014 var.line_nr=110
		// var "expected_nonflagged" var.pos=5162 var.line_nr=142
		// af parent scope:
		// af parent scope:
		return _t1807;
	}
	if (v__ast__Table_sumtype_has_variant(c->table, expected, v__ast__Table_mktyp(c->table, got))) {
		 bool _t1808 = true;
		// autofree_scope_vars(pos=4629 line_nr=126 scope.pos=4626 scope.end_pos=4643)
		// af parent scope:
		// var "c" var.pos=3288 var.line_nr=92
		// var "got" var.pos=3311 var.line_nr=92
		// var "expected" var.pos=3325 var.line_nr=92
		// var "got_" var.pos=3352 var.line_nr=93
		// var "exp_" var.pos=3358 var.line_nr=93
		// var "got_sym" var.pos=4005 var.line_nr=110
		// var "exp_sym" var.pos=4014 var.line_nr=110
		// var "expected_nonflagged" var.pos=5162 var.line_nr=142
		// af parent scope:
		// af parent scope:
		return _t1808;
	}
	if ((got_sym->kind == v__ast__Kind_alias && got_sym->parent_idx == v__ast__Type_idx(expected)) || (exp_sym->kind == v__ast__Kind_alias && exp_sym->parent_idx == v__ast__Type_idx(got))) {
		 bool _t1809 = true;
		// autofree_scope_vars(pos=4797 line_nr=131 scope.pos=4794 scope.end_pos=4811)
		// af parent scope:
		// var "c" var.pos=3288 var.line_nr=92
		// var "got" var.pos=3311 var.line_nr=92
		// var "expected" var.pos=3325 var.line_nr=92
		// var "got_" var.pos=3352 var.line_nr=93
		// var "exp_" var.pos=3358 var.line_nr=93
		// var "got_sym" var.pos=4005 var.line_nr=110
		// var "exp_sym" var.pos=4014 var.line_nr=110
		// var "expected_nonflagged" var.pos=5162 var.line_nr=142
		// af parent scope:
		// af parent scope:
		return _t1809;
	}
	if (got_sym->kind == v__ast__Kind_function && exp_sym->kind == v__ast__Kind_function) {
		 bool _t1810 = v__checker__Checker_check_matching_function_symbols(c, got_sym, exp_sym);
		// autofree_scope_vars(pos=4887 line_nr=135 scope.pos=4884 scope.end_pos=4948)
		// af parent scope:
		// var "c" var.pos=3288 var.line_nr=92
		// var "got" var.pos=3311 var.line_nr=92
		// var "expected" var.pos=3325 var.line_nr=92
		// var "got_" var.pos=3352 var.line_nr=93
		// var "exp_" var.pos=3358 var.line_nr=93
		// var "got_sym" var.pos=4005 var.line_nr=110
		// var "exp_sym" var.pos=4014 var.line_nr=110
		// var "expected_nonflagged" var.pos=5162 var.line_nr=142
		// af parent scope:
		// af parent scope:
		return _t1810;
	}
	if (got == _const_v__ast__error_type_idx && expected == _const_v__ast__string_type_idx) {
		 bool _t1811 = true;
		// autofree_scope_vars(pos=5086 line_nr=139 scope.pos=5083 scope.end_pos=5100)
		// af parent scope:
		// var "c" var.pos=3288 var.line_nr=92
		// var "got" var.pos=3311 var.line_nr=92
		// var "expected" var.pos=3325 var.line_nr=92
		// var "got_" var.pos=3352 var.line_nr=93
		// var "exp_" var.pos=3358 var.line_nr=93
		// var "got_sym" var.pos=4005 var.line_nr=110
		// var "exp_sym" var.pos=4014 var.line_nr=110
		// var "expected_nonflagged" var.pos=5162 var.line_nr=142
		// af parent scope:
		// af parent scope:
		return _t1811;
	}
	v__ast__Type expected_nonflagged = v__ast__Type_clear_flags(expected);
	if (v__ast__Type_alias_eq(got, _const_v__ast__int_literal_type) && v__ast__Type_is_int(expected_nonflagged)) {
		 bool _t1812 = true;
		// autofree_scope_vars(pos=5275 line_nr=144 scope.pos=5272 scope.end_pos=5289)
		// af parent scope:
		// var "c" var.pos=3288 var.line_nr=92
		// var "got" var.pos=3311 var.line_nr=92
		// var "expected" var.pos=3325 var.line_nr=92
		// var "got_" var.pos=3352 var.line_nr=93
		// var "exp_" var.pos=3358 var.line_nr=93
		// var "got_sym" var.pos=4005 var.line_nr=110
		// var "exp_sym" var.pos=4014 var.line_nr=110
		// var "expected_nonflagged" var.pos=5162 var.line_nr=142
		// af parent scope:
		// af parent scope:
		return _t1812;
	}
	if (v__ast__Type_alias_eq(got, _const_v__ast__float_literal_type) && v__ast__Type_is_float(expected_nonflagged)) {
		 bool _t1813 = true;
		// autofree_scope_vars(pos=5421 line_nr=148 scope.pos=5418 scope.end_pos=5435)
		// af parent scope:
		// var "c" var.pos=3288 var.line_nr=92
		// var "got" var.pos=3311 var.line_nr=92
		// var "expected" var.pos=3325 var.line_nr=92
		// var "got_" var.pos=3352 var.line_nr=93
		// var "exp_" var.pos=3358 var.line_nr=93
		// var "got_sym" var.pos=4005 var.line_nr=110
		// var "exp_sym" var.pos=4014 var.line_nr=110
		// var "expected_nonflagged" var.pos=5162 var.line_nr=142
		// af parent scope:
		// af parent scope:
		return _t1813;
	}
	 bool _t1814 = false;
	// autofree_scope_vars(pos=5437 line_nr=150 scope.pos=3283 scope.end_pos=5451)
	// var "c" var.pos=3288 var.line_nr=92
	// var "got" var.pos=3311 var.line_nr=92
	// var "expected" var.pos=3325 var.line_nr=92
	// var "got_" var.pos=3352 var.line_nr=93
	// var "exp_" var.pos=3358 var.line_nr=93
	// var "got_sym" var.pos=4005 var.line_nr=110
	// var "exp_sym" var.pos=4014 var.line_nr=110
	// var "expected_nonflagged" var.pos=5162 var.line_nr=142
	// af parent scope:
	// af parent scope:
	return _t1814;
}

bool v__checker__Checker_check_matching_function_symbols(v__checker__Checker* c, v__ast__TypeSymbol* got_type_sym, v__ast__TypeSymbol* exp_type_sym) {
	v__ast__FnType got_info = /* as */ *(v__ast__FnType*)__as_cast((got_type_sym->info)._v__ast__FnType,(got_type_sym->info)._typ, 418) /*expected idx: 418, name: v.ast.FnType */ ;
	v__ast__FnType exp_info = /* as */ *(v__ast__FnType*)__as_cast((exp_type_sym->info)._v__ast__FnType,(exp_type_sym->info)._typ, 418) /*expected idx: 418, name: v.ast.FnType */ ;
	v__ast__Fn got_fn = got_info.func;
	v__ast__Fn exp_fn = exp_info.func;
	if (got_fn.params.len != exp_fn.params.len) {
		 bool _t1815 = false;
		// autofree_scope_vars(pos=5910 line_nr=161 scope.pos=5907 scope.end_pos=5925)
		// af parent scope:
		// var "c" var.pos=5466 var.line_nr=153
		// var "got_type_sym" var.pos=5509 var.line_nr=153
		// var "exp_type_sym" var.pos=5539 var.line_nr=153
		// var "got_info" var.pos=5577 var.line_nr=154
		// var "exp_info" var.pos=5622 var.line_nr=155
		// var "got_fn" var.pos=5667 var.line_nr=156
		// var "exp_fn" var.pos=5692 var.line_nr=157
		// af parent scope:
		// af parent scope:
		return _t1815;
	}
	if (!v__checker__Checker_check_basic(c, got_fn.return_type, exp_fn.return_type)) {
		 bool _t1816 = false;
		// autofree_scope_vars(pos=5989 line_nr=164 scope.pos=5986 scope.end_pos=6004)
		// af parent scope:
		// var "c" var.pos=5466 var.line_nr=153
		// var "got_type_sym" var.pos=5509 var.line_nr=153
		// var "exp_type_sym" var.pos=5539 var.line_nr=153
		// var "got_info" var.pos=5577 var.line_nr=154
		// var "exp_info" var.pos=5622 var.line_nr=155
		// var "got_fn" var.pos=5667 var.line_nr=156
		// var "exp_fn" var.pos=5692 var.line_nr=157
		// af parent scope:
		// af parent scope:
		return _t1816;
	}
	// FOR IN array
	for (int i = 0; i < got_fn.params.len; ++i) {
		v__ast__Param got_arg = ((v__ast__Param*)got_fn.params.data)[i];
		v__ast__Param exp_arg = (*(v__ast__Param*)/*ee elem_typ */array_get(exp_fn.params, i));
		bool exp_arg_is_ptr = v__ast__Type_is_ptr(exp_arg.typ) || v__ast__Type_is_pointer(exp_arg.typ);
		bool got_arg_is_ptr = v__ast__Type_is_ptr(got_arg.typ) || v__ast__Type_is_pointer(got_arg.typ);
		if (exp_arg_is_ptr != got_arg_is_ptr) {
			string exp_arg_pointedness = (exp_arg_is_ptr ? (_SLIT("a pointer")) : (_SLIT("NOT a pointer")));
			string got_arg_pointedness = (got_arg_is_ptr ? (_SLIT("a pointer")) : (_SLIT("NOT a pointer")));
			v__checker__Checker_add_error_detail(c, _STR("`%.*s\000`\'s expected fn argument: `%.*s\000` is %.*s\000, but the passed fn argument: `%.*s\000` is %.*s", 5, exp_fn.name, exp_arg.name, exp_arg_pointedness, got_arg.name, got_arg_pointedness));
			 bool _t1817 = false;
			// autofree_scope_vars(pos=6595 line_nr=174 scope.pos=6247 scope.end_pos=6611)
			// var "exp_arg_pointedness" var.pos=6252 var.line_nr=171
			// var "got_arg_pointedness" var.pos=6337 var.line_nr=172
			// af parent scope:
			// var "i" var.pos=6011 var.line_nr=166
			// skipping tmp var "i"
			// var "got_arg" var.pos=6014 var.line_nr=166
			// skipping tmp var "got_arg"
			// var "exp_arg" var.pos=6043 var.line_nr=167
			// var "exp_arg_is_ptr" var.pos=6073 var.line_nr=168
			// var "got_arg_is_ptr" var.pos=6142 var.line_nr=169
			// af parent scope:
			// var "c" var.pos=5466 var.line_nr=153
			// var "got_type_sym" var.pos=5509 var.line_nr=153
			// var "exp_type_sym" var.pos=5539 var.line_nr=153
			// var "got_info" var.pos=5577 var.line_nr=154
			// var "exp_info" var.pos=5622 var.line_nr=155
			// var "got_fn" var.pos=5667 var.line_nr=156
			// var "exp_fn" var.pos=5692 var.line_nr=157
			// af parent scope:
			// af parent scope:
			return _t1817;
		}
		if (!v__checker__Checker_check_basic(c, got_arg.typ, exp_arg.typ)) {
			 bool _t1818 = false;
			// autofree_scope_vars(pos=6663 line_nr=177 scope.pos=6659 scope.end_pos=6679)
			// af parent scope:
			// var "i" var.pos=6011 var.line_nr=166
			// skipping tmp var "i"
			// var "got_arg" var.pos=6014 var.line_nr=166
			// skipping tmp var "got_arg"
			// var "exp_arg" var.pos=6043 var.line_nr=167
			// var "exp_arg_is_ptr" var.pos=6073 var.line_nr=168
			// var "got_arg_is_ptr" var.pos=6142 var.line_nr=169
			// af parent scope:
			// var "c" var.pos=5466 var.line_nr=153
			// var "got_type_sym" var.pos=5509 var.line_nr=153
			// var "exp_type_sym" var.pos=5539 var.line_nr=153
			// var "got_info" var.pos=5577 var.line_nr=154
			// var "exp_info" var.pos=5622 var.line_nr=155
			// var "got_fn" var.pos=5667 var.line_nr=156
			// var "exp_fn" var.pos=5692 var.line_nr=157
			// af parent scope:
			// af parent scope:
			return _t1818;
		}
	}
	 bool _t1819 = true;
	// autofree_scope_vars(pos=6684 line_nr=180 scope.pos=5461 scope.end_pos=6697)
	// var "c" var.pos=5466 var.line_nr=153
	// var "got_type_sym" var.pos=5509 var.line_nr=153
	// var "exp_type_sym" var.pos=5539 var.line_nr=153
	// var "got_info" var.pos=5577 var.line_nr=154
	// var "exp_info" var.pos=5622 var.line_nr=155
	// var "got_fn" var.pos=5667 var.line_nr=156
	// var "exp_fn" var.pos=5692 var.line_nr=157
	// af parent scope:
	// af parent scope:
	return _t1819;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL v__ast__Type v__checker__Checker_check_shift(v__checker__Checker* c, v__ast__Type left_type, v__ast__Type right_type, v__token__Position left_pos, v__token__Position right_pos) {
	if (!v__ast__Type_is_int(left_type)) {
		v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(c->table, left_type);
		if (sym->kind == v__ast__Kind_alias && v__ast__Type_is_int((/* as */ *(v__ast__Alias*)__as_cast((sym->info)._v__ast__Alias,(sym->info)._typ, 413) /*expected idx: 413, name: v.ast.Alias */ ).parent_type)) {
			// autofree_scope_vars(pos=7048 line_nr=189 scope.pos=7044 scope.end_pos=7068)
			// af parent scope:
			// var "sym" var.pos=6930 var.line_nr=187
			// af parent scope:
			// var "c" var.pos=6717 var.line_nr=184
			// var "left_type" var.pos=6740 var.line_nr=184
			// var "right_type" var.pos=6760 var.line_nr=184
			// var "left_pos" var.pos=6781 var.line_nr=184
			// var "right_pos" var.pos=6806 var.line_nr=184
			// af parent scope:
			// af parent scope:
			return left_type;
		}
		if (c->pref->translated && v__ast__Type_alias_eq(left_type, _const_v__ast__bool_type)) {
			// autofree_scope_vars(pos=7172 line_nr=193 scope.pos=7123 scope.end_pos=7195)
			// af parent scope:
			// var "sym" var.pos=6930 var.line_nr=187
			// af parent scope:
			// var "c" var.pos=6717 var.line_nr=184
			// var "left_type" var.pos=6740 var.line_nr=184
			// var "right_type" var.pos=6760 var.line_nr=184
			// var "left_pos" var.pos=6781 var.line_nr=184
			// var "right_pos" var.pos=6806 var.line_nr=184
			// af parent scope:
			// af parent scope:
			return _const_v__ast__int_type;
		}
		v__checker__Checker_error(c, _STR("invalid operation: shift on type `%.*s\000`", 2, sym->name), left_pos);
		// autofree_scope_vars(pos=7266 line_nr=196 scope.pos=6867 scope.end_pos=7289)
		// var "sym" var.pos=6930 var.line_nr=187
		// af parent scope:
		// var "c" var.pos=6717 var.line_nr=184
		// var "left_type" var.pos=6740 var.line_nr=184
		// var "right_type" var.pos=6760 var.line_nr=184
		// var "left_pos" var.pos=6781 var.line_nr=184
		// var "right_pos" var.pos=6806 var.line_nr=184
		// af parent scope:
		// af parent scope:
		return _const_v__ast__void_type;
	} else if (!v__ast__Type_is_int(right_type)) {
		v__checker__Checker_error(c, _STR("cannot shift non-integer type `%.*s\000` into type `%.*s\000`", 3, v__ast__Table_get_type_symbol(c->table, right_type)->name, v__ast__Table_get_type_symbol(c->table, left_type)->name), right_pos);
		// autofree_scope_vars(pos=7481 line_nr=200 scope.pos=7320 scope.end_pos=7504)
		// af parent scope:
		// var "c" var.pos=6717 var.line_nr=184
		// var "left_type" var.pos=6740 var.line_nr=184
		// var "right_type" var.pos=6760 var.line_nr=184
		// var "left_pos" var.pos=6781 var.line_nr=184
		// var "right_pos" var.pos=6806 var.line_nr=184
		// af parent scope:
		// af parent scope:
		return _const_v__ast__void_type;
	}
	// autofree_scope_vars(pos=7506 line_nr=202 scope.pos=6712 scope.end_pos=7524)
	// var "c" var.pos=6717 var.line_nr=184
	// var "left_type" var.pos=6740 var.line_nr=184
	// var "right_type" var.pos=6760 var.line_nr=184
	// var "left_pos" var.pos=6781 var.line_nr=184
	// var "right_pos" var.pos=6806 var.line_nr=184
	// af parent scope:
	// af parent scope:
	return left_type;
}

v__ast__Type v__checker__Checker_promote(v__checker__Checker* c, v__ast__Type left_type, v__ast__Type right_type) {
	if (v__ast__Type_is_ptr(left_type) || v__ast__Type_is_pointer(left_type)) {
		if (v__ast__Type_is_int(right_type)) {
			// autofree_scope_vars(pos=7690 line_nr=208 scope.pos=7686 scope.end_pos=7710)
			// af parent scope:
			// af parent scope:
			// var "c" var.pos=7539 var.line_nr=205
			// var "left_type" var.pos=7558 var.line_nr=205
			// var "right_type" var.pos=7578 var.line_nr=205
			// af parent scope:
			// af parent scope:
			return left_type;
		} else {
			// autofree_scope_vars(pos=7721 line_nr=210 scope.pos=7717 scope.end_pos=7745)
			// af parent scope:
			// af parent scope:
			// var "c" var.pos=7539 var.line_nr=205
			// var "left_type" var.pos=7558 var.line_nr=205
			// var "right_type" var.pos=7578 var.line_nr=205
			// af parent scope:
			// af parent scope:
			return _const_v__ast__void_type;
		}
	} else if (v__ast__Type_is_ptr(right_type) || v__ast__Type_is_pointer(right_type)) {
		if (v__ast__Type_is_int(left_type)) {
			// autofree_scope_vars(pos=7835 line_nr=214 scope.pos=7831 scope.end_pos=7856)
			// af parent scope:
			// af parent scope:
			// var "c" var.pos=7539 var.line_nr=205
			// var "left_type" var.pos=7558 var.line_nr=205
			// var "right_type" var.pos=7578 var.line_nr=205
			// af parent scope:
			// af parent scope:
			return right_type;
		} else {
			// autofree_scope_vars(pos=7867 line_nr=216 scope.pos=7863 scope.end_pos=7891)
			// af parent scope:
			// af parent scope:
			// var "c" var.pos=7539 var.line_nr=205
			// var "left_type" var.pos=7558 var.line_nr=205
			// var "right_type" var.pos=7578 var.line_nr=205
			// af parent scope:
			// af parent scope:
			return _const_v__ast__void_type;
		}
	}
	if (v__ast__Type_alias_eq(left_type, right_type)) {
		// autofree_scope_vars(pos=7927 line_nr=220 scope.pos=7924 scope.end_pos=7981)
		// af parent scope:
		// var "c" var.pos=7539 var.line_nr=205
		// var "left_type" var.pos=7558 var.line_nr=205
		// var "right_type" var.pos=7578 var.line_nr=205
		// af parent scope:
		// af parent scope:
		return left_type;
	}
	if (v__ast__Type_is_number(right_type) && v__ast__Type_is_number(left_type)) {
		 v__ast__Type _t1820 = v__checker__Checker_promote_num(c, left_type, right_type);
		// autofree_scope_vars(pos=8038 line_nr=223 scope.pos=8035 scope.end_pos=8084)
		// af parent scope:
		// var "c" var.pos=7539 var.line_nr=205
		// var "left_type" var.pos=7558 var.line_nr=205
		// var "right_type" var.pos=7578 var.line_nr=205
		// af parent scope:
		// af parent scope:
		return _t1820;
	} else if (v__ast__Type_has_flag(left_type, v__ast__TypeFlag_optional) != v__ast__Type_has_flag(right_type, v__ast__TypeFlag_optional)) {
		// autofree_scope_vars(pos=8179 line_nr=226 scope.pos=8158 scope.end_pos=8202)
		// af parent scope:
		// var "c" var.pos=7539 var.line_nr=205
		// var "left_type" var.pos=7558 var.line_nr=205
		// var "right_type" var.pos=7578 var.line_nr=205
		// af parent scope:
		// af parent scope:
		return _const_v__ast__void_type;
	} else {
		// autofree_scope_vars(pos=8212 line_nr=228 scope.pos=8209 scope.end_pos=8286)
		// af parent scope:
		// var "c" var.pos=7539 var.line_nr=205
		// var "left_type" var.pos=7558 var.line_nr=205
		// var "right_type" var.pos=7578 var.line_nr=205
		// af parent scope:
		// af parent scope:
		return left_type;
	}
	return 0;
}

VV_LOCAL_SYMBOL v__ast__Type v__checker__Checker_promote_num(v__checker__Checker* c, v__ast__Type left_type, v__ast__Type right_type) {
	v__ast__Type type_hi = left_type;
	v__ast__Type type_lo = right_type;
	if (v__ast__Type_idx(type_hi) < v__ast__Type_idx(type_lo)) {
		v__ast__Type _var_8497 = type_hi;
		v__ast__Type _var_8506 = type_lo;
		type_hi = _var_8506;
		type_lo = _var_8497;
	}
	int idx_hi = v__ast__Type_idx(type_hi);
	int idx_lo = v__ast__Type_idx(type_lo);
	if (idx_hi == _const_v__ast__int_literal_type_idx) {
		// autofree_scope_vars(pos=8708 line_nr=243 scope.pos=8705 scope.end_pos=8725)
		// af parent scope:
		// var "c" var.pos=8295 var.line_nr=232
		// var "left_type" var.pos=8319 var.line_nr=232
		// var "right_type" var.pos=8339 var.line_nr=232
		// var "type_hi" var.pos=8411 var.line_nr=234
		// var "type_lo" var.pos=8437 var.line_nr=235
		// var "idx_hi" var.pos=8537 var.line_nr=239
		// var "idx_lo" var.pos=8562 var.line_nr=240
		// af parent scope:
		// af parent scope:
		return type_lo;
	} else if (idx_hi == _const_v__ast__float_literal_type_idx) {
		if ((Array_int_contains(_const_v__ast__float_type_idxs, idx_lo))) {
			// autofree_scope_vars(pos=8813 line_nr=246 scope.pos=8809 scope.end_pos=8831)
			// af parent scope:
			// af parent scope:
			// var "c" var.pos=8295 var.line_nr=232
			// var "left_type" var.pos=8319 var.line_nr=232
			// var "right_type" var.pos=8339 var.line_nr=232
			// var "type_hi" var.pos=8411 var.line_nr=234
			// var "type_lo" var.pos=8437 var.line_nr=235
			// var "idx_hi" var.pos=8537 var.line_nr=239
			// var "idx_lo" var.pos=8562 var.line_nr=240
			// af parent scope:
			// af parent scope:
			return type_lo;
		} else {
			// autofree_scope_vars(pos=8842 line_nr=248 scope.pos=8838 scope.end_pos=8866)
			// af parent scope:
			// af parent scope:
			// var "c" var.pos=8295 var.line_nr=232
			// var "left_type" var.pos=8319 var.line_nr=232
			// var "right_type" var.pos=8339 var.line_nr=232
			// var "type_hi" var.pos=8411 var.line_nr=234
			// var "type_lo" var.pos=8437 var.line_nr=235
			// var "idx_hi" var.pos=8537 var.line_nr=239
			// var "idx_lo" var.pos=8562 var.line_nr=240
			// af parent scope:
			// af parent scope:
			return _const_v__ast__void_type;
		}
	} else if (v__ast__Type_is_float(type_hi)) {
		if (idx_hi == _const_v__ast__f32_type_idx) {
			if ((idx_lo == _const_v__ast__i64_type_idx || idx_lo == _const_v__ast__u64_type_idx)) {
				// autofree_scope_vars(pos=8992 line_nr=253 scope.pos=8987 scope.end_pos=9017)
				// af parent scope:
				// af parent scope:
				// af parent scope:
				// var "c" var.pos=8295 var.line_nr=232
				// var "left_type" var.pos=8319 var.line_nr=232
				// var "right_type" var.pos=8339 var.line_nr=232
				// var "type_hi" var.pos=8411 var.line_nr=234
				// var "type_lo" var.pos=8437 var.line_nr=235
				// var "idx_hi" var.pos=8537 var.line_nr=239
				// var "idx_lo" var.pos=8562 var.line_nr=240
				// af parent scope:
				// af parent scope:
				return _const_v__ast__void_type;
			} else {
				// autofree_scope_vars(pos=9029 line_nr=255 scope.pos=9024 scope.end_pos=9048)
				// af parent scope:
				// af parent scope:
				// af parent scope:
				// var "c" var.pos=8295 var.line_nr=232
				// var "left_type" var.pos=8319 var.line_nr=232
				// var "right_type" var.pos=8339 var.line_nr=232
				// var "type_hi" var.pos=8411 var.line_nr=234
				// var "type_lo" var.pos=8437 var.line_nr=235
				// var "idx_hi" var.pos=8537 var.line_nr=239
				// var "idx_lo" var.pos=8562 var.line_nr=240
				// af parent scope:
				// af parent scope:
				return type_hi;
			}
		} else {
			// autofree_scope_vars(pos=9085 line_nr=258 scope.pos=9059 scope.end_pos=9103)
			// af parent scope:
			// af parent scope:
			// var "c" var.pos=8295 var.line_nr=232
			// var "left_type" var.pos=8319 var.line_nr=232
			// var "right_type" var.pos=8339 var.line_nr=232
			// var "type_hi" var.pos=8411 var.line_nr=234
			// var "type_lo" var.pos=8437 var.line_nr=235
			// var "idx_hi" var.pos=8537 var.line_nr=239
			// var "idx_lo" var.pos=8562 var.line_nr=240
			// af parent scope:
			// af parent scope:
			return type_hi;
		}
	} else if (idx_lo >= _const_v__ast__byte_type_idx) {
		// autofree_scope_vars(pos=9177 line_nr=261 scope.pos=9144 scope.end_pos=9194)
		// af parent scope:
		// var "c" var.pos=8295 var.line_nr=232
		// var "left_type" var.pos=8319 var.line_nr=232
		// var "right_type" var.pos=8339 var.line_nr=232
		// var "type_hi" var.pos=8411 var.line_nr=234
		// var "type_lo" var.pos=8437 var.line_nr=235
		// var "idx_hi" var.pos=8537 var.line_nr=239
		// var "idx_lo" var.pos=8562 var.line_nr=240
		// af parent scope:
		// af parent scope:
		return type_hi;
	} else if (idx_lo >= _const_v__ast__i8_type_idx && (idx_hi <= _const_v__ast__i64_type_idx || idx_hi == _const_v__ast__rune_type_idx)) {
		 v__ast__Type _t1821 = (idx_lo == _const_v__ast__i64_type_idx ? (type_lo) : (type_hi));
		// autofree_scope_vars(pos=9313 line_nr=264 scope.pos=9295 scope.end_pos=9381)
		// af parent scope:
		// var "c" var.pos=8295 var.line_nr=232
		// var "left_type" var.pos=8319 var.line_nr=232
		// var "right_type" var.pos=8339 var.line_nr=232
		// var "type_hi" var.pos=8411 var.line_nr=234
		// var "type_lo" var.pos=8437 var.line_nr=235
		// var "idx_hi" var.pos=8537 var.line_nr=239
		// var "idx_lo" var.pos=8562 var.line_nr=240
		// af parent scope:
		// af parent scope:
		return _t1821;
	} else if (idx_hi - idx_lo < (_const_v__ast__byte_type_idx - _const_v__ast__i8_type_idx)) {
		// autofree_scope_vars(pos=9450 line_nr=266 scope.pos=9447 scope.end_pos=9525)
		// af parent scope:
		// var "c" var.pos=8295 var.line_nr=232
		// var "left_type" var.pos=8319 var.line_nr=232
		// var "right_type" var.pos=8339 var.line_nr=232
		// var "type_hi" var.pos=8411 var.line_nr=234
		// var "type_lo" var.pos=8437 var.line_nr=235
		// var "idx_hi" var.pos=8537 var.line_nr=239
		// var "idx_lo" var.pos=8562 var.line_nr=240
		// af parent scope:
		// af parent scope:
		return type_lo;
	} else {
		// autofree_scope_vars(pos=9535 line_nr=268 scope.pos=9532 scope.end_pos=9603)
		// af parent scope:
		// var "c" var.pos=8295 var.line_nr=232
		// var "left_type" var.pos=8319 var.line_nr=232
		// var "right_type" var.pos=8339 var.line_nr=232
		// var "type_hi" var.pos=8411 var.line_nr=234
		// var "type_lo" var.pos=8437 var.line_nr=235
		// var "idx_hi" var.pos=8537 var.line_nr=239
		// var "idx_lo" var.pos=8562 var.line_nr=240
		// af parent scope:
		// af parent scope:
		return _const_v__ast__void_type;
	}
	return 0;
}

bool v__checker__Checker_check_types(v__checker__Checker* c, v__ast__Type got, v__ast__Type expected) {
	if (v__ast__Type_alias_eq(got, expected)) {
		 bool _t1822 = true;
		// autofree_scope_vars(pos=9802 line_nr=275 scope.pos=9799 scope.end_pos=9816)
		// af parent scope:
		// var "c" var.pos=9716 var.line_nr=273
		// var "got" var.pos=9739 var.line_nr=273
		// var "expected" var.pos=9753 var.line_nr=273
		// var "got_is_ptr" var.pos=9819 var.line_nr=277
		// var "exp_is_ptr" var.pos=9847 var.line_nr=278
		// var "exp_idx" var.pos=9977 var.line_nr=284
		// var "got_idx" var.pos=10004 var.line_nr=285
		// af parent scope:
		// af parent scope:
		return _t1822;
	}
	bool got_is_ptr = v__ast__Type_is_ptr(got);
	bool exp_is_ptr = v__ast__Type_is_ptr(expected);
	if (got_is_ptr && exp_is_ptr) {
		if (v__ast__Type_nr_muls(got) != v__ast__Type_nr_muls(expected)) {
			 bool _t1823 = false;
			// autofree_scope_vars(pos=9955 line_nr=281 scope.pos=9951 scope.end_pos=9971)
			// af parent scope:
			// af parent scope:
			// var "c" var.pos=9716 var.line_nr=273
			// var "got" var.pos=9739 var.line_nr=273
			// var "expected" var.pos=9753 var.line_nr=273
			// var "got_is_ptr" var.pos=9819 var.line_nr=277
			// var "exp_is_ptr" var.pos=9847 var.line_nr=278
			// var "exp_idx" var.pos=9977 var.line_nr=284
			// var "got_idx" var.pos=10004 var.line_nr=285
			// af parent scope:
			// af parent scope:
			return _t1823;
		}
	}
	int exp_idx = v__ast__Type_idx(expected);
	int got_idx = v__ast__Type_idx(got);
	if (exp_idx == got_idx) {
		 bool _t1824 = true;
		// autofree_scope_vars(pos=10051 line_nr=287 scope.pos=10048 scope.end_pos=10065)
		// af parent scope:
		// var "c" var.pos=9716 var.line_nr=273
		// var "got" var.pos=9739 var.line_nr=273
		// var "expected" var.pos=9753 var.line_nr=273
		// var "got_is_ptr" var.pos=9819 var.line_nr=277
		// var "exp_is_ptr" var.pos=9847 var.line_nr=278
		// var "exp_idx" var.pos=9977 var.line_nr=284
		// var "got_idx" var.pos=10004 var.line_nr=285
		// af parent scope:
		// af parent scope:
		return _t1824;
	}
	if (exp_idx == _const_v__ast__voidptr_type_idx || exp_idx == _const_v__ast__byteptr_type_idx || (v__ast__Type_is_ptr(expected) && v__ast__Type_idx(v__ast__Type_deref(expected)) == _const_v__ast__byte_type_idx)) {
		if (v__ast__Type_is_ptr(got) || v__ast__Type_is_pointer(got)) {
			 bool _t1825 = true;
			// autofree_scope_vars(pos=10254 line_nr=292 scope.pos=10250 scope.end_pos=10269)
			// af parent scope:
			// af parent scope:
			// var "c" var.pos=9716 var.line_nr=273
			// var "got" var.pos=9739 var.line_nr=273
			// var "expected" var.pos=9753 var.line_nr=273
			// var "got_is_ptr" var.pos=9819 var.line_nr=277
			// var "exp_is_ptr" var.pos=9847 var.line_nr=278
			// var "exp_idx" var.pos=9977 var.line_nr=284
			// var "got_idx" var.pos=10004 var.line_nr=285
			// af parent scope:
			// af parent scope:
			return _t1825;
		}
	}
	if (v__ast__Type_is_ptr(expected) || v__ast__Type_is_pointer(expected)) {
		if (v__ast__Type_alias_eq(got, _const_v__ast__int_literal_type)) {
			 bool _t1826 = true;
			// autofree_scope_vars(pos=10479 line_nr=299 scope.pos=10475 scope.end_pos=10494)
			// af parent scope:
			// af parent scope:
			// var "c" var.pos=9716 var.line_nr=273
			// var "got" var.pos=9739 var.line_nr=273
			// var "expected" var.pos=9753 var.line_nr=273
			// var "got_is_ptr" var.pos=9819 var.line_nr=277
			// var "exp_is_ptr" var.pos=9847 var.line_nr=278
			// var "exp_idx" var.pos=9977 var.line_nr=284
			// var "got_idx" var.pos=10004 var.line_nr=285
			// af parent scope:
			// af parent scope:
			return _t1826;
		}
	}
	if (got_idx == _const_v__ast__voidptr_type_idx || got_idx == _const_v__ast__byteptr_type_idx || (got_idx == _const_v__ast__byte_type_idx && v__ast__Type_is_ptr(got))) {
		if (v__ast__Type_is_ptr(expected) || v__ast__Type_is_pointer(expected)) {
			 bool _t1827 = true;
			// autofree_scope_vars(pos=10676 line_nr=305 scope.pos=10672 scope.end_pos=10691)
			// af parent scope:
			// af parent scope:
			// var "c" var.pos=9716 var.line_nr=273
			// var "got" var.pos=9739 var.line_nr=273
			// var "expected" var.pos=9753 var.line_nr=273
			// var "got_is_ptr" var.pos=9819 var.line_nr=277
			// var "exp_is_ptr" var.pos=9847 var.line_nr=278
			// var "exp_idx" var.pos=9977 var.line_nr=284
			// var "got_idx" var.pos=10004 var.line_nr=285
			// af parent scope:
			// af parent scope:
			return _t1827;
		}
	}
	if (v__ast__Type_alias_eq(expected, _const_v__ast__charptr_type) && v__ast__Type_alias_eq(got, v__ast__Type_to_ptr(_const_v__ast__char_type))) {
		 bool _t1828 = true;
		// autofree_scope_vars(pos=10765 line_nr=309 scope.pos=10762 scope.end_pos=10779)
		// af parent scope:
		// var "c" var.pos=9716 var.line_nr=273
		// var "got" var.pos=9739 var.line_nr=273
		// var "expected" var.pos=9753 var.line_nr=273
		// var "got_is_ptr" var.pos=9819 var.line_nr=277
		// var "exp_is_ptr" var.pos=9847 var.line_nr=278
		// var "exp_idx" var.pos=9977 var.line_nr=284
		// var "got_idx" var.pos=10004 var.line_nr=285
		// af parent scope:
		// af parent scope:
		return _t1828;
	}
	if (!v__checker__Checker_check_basic(c, got, expected)) {
		 bool _t1829 = false;
		// autofree_scope_vars(pos=10850 line_nr=312 scope.pos=10815 scope.end_pos=10865)
		// af parent scope:
		// var "c" var.pos=9716 var.line_nr=273
		// var "got" var.pos=9739 var.line_nr=273
		// var "expected" var.pos=9753 var.line_nr=273
		// var "got_is_ptr" var.pos=9819 var.line_nr=277
		// var "exp_is_ptr" var.pos=9847 var.line_nr=278
		// var "exp_idx" var.pos=9977 var.line_nr=284
		// var "got_idx" var.pos=10004 var.line_nr=285
		// af parent scope:
		// af parent scope:
		return _t1829;
	}
	if (v__ast__Type_is_number(got) && v__ast__Type_is_number(expected)) {
		if (v__ast__Type_alias_eq(got, _const_v__ast__rune_type) && v__ast__Type_alias_eq(expected, _const_v__ast__byte_type)) {
			 bool _t1830 = true;
			// autofree_scope_vars(pos=10972 line_nr=316 scope.pos=10968 scope.end_pos=10987)
			// af parent scope:
			// af parent scope:
			// var "c" var.pos=9716 var.line_nr=273
			// var "got" var.pos=9739 var.line_nr=273
			// var "expected" var.pos=9753 var.line_nr=273
			// var "got_is_ptr" var.pos=9819 var.line_nr=277
			// var "exp_is_ptr" var.pos=9847 var.line_nr=278
			// var "exp_idx" var.pos=9977 var.line_nr=284
			// var "got_idx" var.pos=10004 var.line_nr=285
			// af parent scope:
			// af parent scope:
			return _t1830;
		} else if (v__ast__Type_alias_eq(expected, _const_v__ast__rune_type) && v__ast__Type_alias_eq(got, _const_v__ast__byte_type)) {
			 bool _t1831 = true;
			// autofree_scope_vars(pos=11051 line_nr=318 scope.pos=11047 scope.end_pos=11066)
			// af parent scope:
			// af parent scope:
			// var "c" var.pos=9716 var.line_nr=273
			// var "got" var.pos=9739 var.line_nr=273
			// var "expected" var.pos=9753 var.line_nr=273
			// var "got_is_ptr" var.pos=9819 var.line_nr=277
			// var "exp_is_ptr" var.pos=9847 var.line_nr=278
			// var "exp_idx" var.pos=9977 var.line_nr=284
			// var "got_idx" var.pos=10004 var.line_nr=285
			// af parent scope:
			// af parent scope:
			return _t1831;
		}
		if (!v__ast__Type_alias_eq(v__checker__Checker_promote_num(c, expected, got), expected)) {
			 bool _t1832 = false;
			// autofree_scope_vars(pos=11235 line_nr=322 scope.pos=11114 scope.end_pos=11251)
			// af parent scope:
			// af parent scope:
			// var "c" var.pos=9716 var.line_nr=273
			// var "got" var.pos=9739 var.line_nr=273
			// var "expected" var.pos=9753 var.line_nr=273
			// var "got_is_ptr" var.pos=9819 var.line_nr=277
			// var "exp_is_ptr" var.pos=9847 var.line_nr=278
			// var "exp_idx" var.pos=9977 var.line_nr=284
			// var "got_idx" var.pos=10004 var.line_nr=285
			// af parent scope:
			// af parent scope:
			return _t1832;
		}
	}
	if (v__ast__Type_has_flag(expected, v__ast__TypeFlag_generic)) {
		 bool _t1833 = false;
		// autofree_scope_vars(pos=11291 line_nr=326 scope.pos=11288 scope.end_pos=11306)
		// af parent scope:
		// var "c" var.pos=9716 var.line_nr=273
		// var "got" var.pos=9739 var.line_nr=273
		// var "expected" var.pos=9753 var.line_nr=273
		// var "got_is_ptr" var.pos=9819 var.line_nr=277
		// var "exp_is_ptr" var.pos=9847 var.line_nr=278
		// var "exp_idx" var.pos=9977 var.line_nr=284
		// var "got_idx" var.pos=10004 var.line_nr=285
		// af parent scope:
		// af parent scope:
		return _t1833;
	}
	 bool _t1834 = true;
	// autofree_scope_vars(pos=11308 line_nr=328 scope.pos=9711 scope.end_pos=11321)
	// var "c" var.pos=9716 var.line_nr=273
	// var "got" var.pos=9739 var.line_nr=273
	// var "expected" var.pos=9753 var.line_nr=273
	// var "got_is_ptr" var.pos=9819 var.line_nr=277
	// var "exp_is_ptr" var.pos=9847 var.line_nr=278
	// var "exp_idx" var.pos=9977 var.line_nr=284
	// var "got_idx" var.pos=10004 var.line_nr=285
	// af parent scope:
	// af parent scope:
	return _t1834;
}

Option_void v__checker__Checker_check_expected(v__checker__Checker* c, v__ast__Type got, v__ast__Type expected) {
	if (v__checker__Checker_check_types(c, got, expected)) {
		return (Option_void){0};
	}
	return (Option_void){ .state=2, .err=v_error(v__checker__Checker_expected_msg(c, got, expected)) };
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL string v__checker__Checker_expected_msg(v__checker__Checker* c, v__ast__Type got, v__ast__Type expected) {
	string exps = v__ast__Table_type_to_str(c->table, expected);
	string gots = v__ast__Table_type_to_str(c->table, got);
	 string _t1835 = _STR("expected `%.*s\000`, not `%.*s\000`", 3, exps, gots);
	// autofree_scope_vars(pos=11647 line_nr=342 scope.pos=11506 scope.end_pos=11687)
	// var "c" var.pos=11507 var.line_nr=339
	// var "got" var.pos=11532 var.line_nr=339
	// var "expected" var.pos=11546 var.line_nr=339
	// var "exps" var.pos=11575 var.line_nr=340
	// var "gots" var.pos=11614 var.line_nr=341
	// af parent scope:
	// af parent scope:
	return _t1835;
}

bool v__checker__Checker_symmetric_check(v__checker__Checker* c, v__ast__Type left, v__ast__Type right) {
	if (v__ast__Type_is_ptr(right) || v__ast__Type_is_pointer(right)) {
		if (v__ast__Type_alias_eq(left, _const_v__ast__int_literal_type)) {
			 bool _t1836 = true;
			// autofree_scope_vars(pos=11967 line_nr=350 scope.pos=11963 scope.end_pos=11982)
			// af parent scope:
			// af parent scope:
			// var "c" var.pos=11702 var.line_nr=345
			// var "left" var.pos=11729 var.line_nr=345
			// var "right" var.pos=11744 var.line_nr=345
			// af parent scope:
			// af parent scope:
			return _t1836;
		}
	}
	if (v__ast__Type_is_ptr(left) || v__ast__Type_is_pointer(left)) {
		if (v__ast__Type_alias_eq(right, _const_v__ast__int_literal_type)) {
			 bool _t1837 = true;
			// autofree_scope_vars(pos=12128 line_nr=356 scope.pos=12124 scope.end_pos=12143)
			// af parent scope:
			// af parent scope:
			// var "c" var.pos=11702 var.line_nr=345
			// var "left" var.pos=11729 var.line_nr=345
			// var "right" var.pos=11744 var.line_nr=345
			// af parent scope:
			// af parent scope:
			return _t1837;
		}
	}
	 bool _t1838 = v__checker__Checker_check_basic(c, left, right);
	// autofree_scope_vars(pos=12148 line_nr=359 scope.pos=11697 scope.end_pos=12183)
	// var "c" var.pos=11702 var.line_nr=345
	// var "left" var.pos=11729 var.line_nr=345
	// var "right" var.pos=11744 var.line_nr=345
	// af parent scope:
	// af parent scope:
	return _t1838;
}

byte v__checker__Checker_get_default_fmt(v__checker__Checker* c, v__ast__Type ftyp, v__ast__Type typ) {
	if (v__ast__Type_has_flag(ftyp, v__ast__TypeFlag_optional)) {
		 byte _t1839 = L's';
		// autofree_scope_vars(pos=12293 line_nr=364 scope.pos=12290 scope.end_pos=12306)
		// af parent scope:
		// var "c" var.pos=12198 var.line_nr=362
		// var "ftyp" var.pos=12225 var.line_nr=362
		// var "typ" var.pos=12240 var.line_nr=362
		// af parent scope:
		// af parent scope:
		return _t1839;
	} else if (v__ast__Type_is_float(typ)) {
		 byte _t1840 = L'g';
		// autofree_scope_vars(pos=12334 line_nr=366 scope.pos=12331 scope.end_pos=12347)
		// af parent scope:
		// var "c" var.pos=12198 var.line_nr=362
		// var "ftyp" var.pos=12225 var.line_nr=362
		// var "typ" var.pos=12240 var.line_nr=362
		// af parent scope:
		// af parent scope:
		return _t1840;
	} else if (v__ast__Type_is_signed(typ) || v__ast__Type_is_int_literal(typ)) {
		 byte _t1841 = L'd';
		// autofree_scope_vars(pos=12400 line_nr=368 scope.pos=12397 scope.end_pos=12413)
		// af parent scope:
		// var "c" var.pos=12198 var.line_nr=362
		// var "ftyp" var.pos=12225 var.line_nr=362
		// var "typ" var.pos=12240 var.line_nr=362
		// af parent scope:
		// af parent scope:
		return _t1841;
	} else if (v__ast__Type_is_unsigned(typ)) {
		 byte _t1842 = L'u';
		// autofree_scope_vars(pos=12444 line_nr=370 scope.pos=12441 scope.end_pos=12457)
		// af parent scope:
		// var "c" var.pos=12198 var.line_nr=362
		// var "ftyp" var.pos=12225 var.line_nr=362
		// var "typ" var.pos=12240 var.line_nr=362
		// af parent scope:
		// af parent scope:
		return _t1842;
	} else if (v__ast__Type_is_pointer(typ)) {
		 byte _t1843 = L'p';
		// autofree_scope_vars(pos=12487 line_nr=372 scope.pos=12484 scope.end_pos=12500)
		// af parent scope:
		// var "c" var.pos=12198 var.line_nr=362
		// var "ftyp" var.pos=12225 var.line_nr=362
		// var "typ" var.pos=12240 var.line_nr=362
		// af parent scope:
		// af parent scope:
		return _t1843;
	} else {
		v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(c->table, v__checker__Checker_unwrap_generic(c, ftyp));
		if (sym->kind == v__ast__Kind_alias) {
			v__ast__Alias info = /* as */ *(v__ast__Alias*)__as_cast((sym->info)._v__ast__Alias,(sym->info)._typ, 413) /*expected idx: 413, name: v.ast.Alias */ ;
			sym = v__ast__Table_get_type_symbol(c->table, info.parent_type);
			if (v__ast__Type_alias_eq(info.parent_type, _const_v__ast__string_type)) {
				 byte _t1844 = L's';
				// autofree_scope_vars(pos=12768 line_nr=380 scope.pos=12763 scope.end_pos=12783)
				// af parent scope:
				// var "info" var.pos=12640 var.line_nr=377
				// af parent scope:
				// var "sym" var.pos=12515 var.line_nr=374
				// af parent scope:
				// var "c" var.pos=12198 var.line_nr=362
				// var "ftyp" var.pos=12225 var.line_nr=362
				// var "typ" var.pos=12240 var.line_nr=362
				// af parent scope:
				// af parent scope:
				return _t1844;
			}
		}
		if (sym->kind == v__ast__Kind_function) {
			 byte _t1845 = L's';
			// autofree_scope_vars(pos=12820 line_nr=384 scope.pos=12816 scope.end_pos=12834)
			// af parent scope:
			// var "sym" var.pos=12515 var.line_nr=374
			// af parent scope:
			// var "c" var.pos=12198 var.line_nr=362
			// var "ftyp" var.pos=12225 var.line_nr=362
			// var "typ" var.pos=12240 var.line_nr=362
			// af parent scope:
			// af parent scope:
			return _t1845;
		}
		if ((ftyp == _const_v__ast__string_type || ftyp == _const_v__ast__bool_type) || (sym->kind == v__ast__Kind_enum_ || sym->kind == v__ast__Kind_array || sym->kind == v__ast__Kind_array_fixed || sym->kind == v__ast__Kind_struct_ || sym->kind == v__ast__Kind_map || sym->kind == v__ast__Kind_multi_return || sym->kind == v__ast__Kind_sum_type || sym->kind == v__ast__Kind_interface_ || sym->kind == v__ast__Kind_none_) || v__ast__Type_has_flag(ftyp, v__ast__TypeFlag_optional) || v__ast__TypeSymbol_has_method(sym, _SLIT("str"))) {
			 byte _t1846 = L's';
			// autofree_scope_vars(pos=13054 line_nr=389 scope.pos=13050 scope.end_pos=13068)
			// af parent scope:
			// var "sym" var.pos=12515 var.line_nr=374
			// af parent scope:
			// var "c" var.pos=12198 var.line_nr=362
			// var "ftyp" var.pos=12225 var.line_nr=362
			// var "typ" var.pos=12240 var.line_nr=362
			// af parent scope:
			// af parent scope:
			return _t1846;
		} else {
			 byte _t1847 = L'_';
			// autofree_scope_vars(pos=13079 line_nr=391 scope.pos=13075 scope.end_pos=13093)
			// af parent scope:
			// var "sym" var.pos=12515 var.line_nr=374
			// af parent scope:
			// var "c" var.pos=12198 var.line_nr=362
			// var "ftyp" var.pos=12225 var.line_nr=362
			// var "typ" var.pos=12240 var.line_nr=362
			// af parent scope:
			// af parent scope:
			return _t1847;
		}
	}
	return 0;
}

void v__checker__Checker_fail_if_unreadable(v__checker__Checker* c, v__ast__Expr expr, v__ast__Type typ, string what) {
	v__token__Position pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,};
	if (expr._typ == 254 /* v.ast.Ident */) {
		if (v__ast__Type_has_flag(typ, v__ast__TypeFlag_shared_f)) {
			if (!(Array_string_contains(c->rlocked_names, (*expr._v__ast__Ident).name)) && !(Array_string_contains(c->locked_names, (*expr._v__ast__Ident).name))) {
				string action = (string_eq(what, _SLIT("argument")) ? (_SLIT("passed")) : (_SLIT("used")));
				v__checker__Checker_error(c, _STR("%.*s\000 is `shared` and must be `rlock`ed or `lock`ed to be %.*s\000 as non-mut %.*s", 3, (*expr._v__ast__Ident).name, action, what), (*expr._v__ast__Ident).pos);
			}
		}
		return;
	}
	else if (expr._typ == 273 /* v.ast.SelectorExpr */) {
		pos = (*expr._v__ast__SelectorExpr).pos;
		v__checker__Checker_fail_if_unreadable(c, (*expr._v__ast__SelectorExpr).expr, (*expr._v__ast__SelectorExpr).expr_type, what);
	}
	else if (expr._typ == 257 /* v.ast.IndexExpr */) {
		pos = v__token__Position_extend(v__ast__Expr_position((*expr._v__ast__IndexExpr).left), (*expr._v__ast__IndexExpr).pos);
		v__checker__Checker_fail_if_unreadable(c, (*expr._v__ast__IndexExpr).left, (*expr._v__ast__IndexExpr).left_type, what);
	}
	else {
	};
	if (v__ast__Type_has_flag(typ, v__ast__TypeFlag_shared_f)) {
		v__checker__Checker_error(c, _STR("you have to create a handle and `rlock` it to use a `shared` element as non-mut %.*s", 1, what), pos);
	}
}

v__ast__Type v__checker__Checker_string_inter_lit(v__checker__Checker* c, v__ast__StringInterLiteral* node) {
	bool inside_println_arg_save = c->inside_println_arg;
	c->inside_println_arg = true;
	// FOR IN array
	for (int i = 0; i < node->exprs.len; ++i) {
		v__ast__Expr expr = ((v__ast__Expr*)node->exprs.data)[i];
		v__ast__Type ftyp = v__checker__Checker_expr(c, expr);
		v__checker__Checker_fail_if_unreadable(c, expr, ftyp, _SLIT("interpolation object"));
		array_push(&node->expr_types, _MOV((v__ast__Type[]){ ftyp }));
		v__ast__Type typ = v__ast__Table_unalias_num_type(c->table, ftyp);
		byte fmt = (*(byte*)/*ee elem_typ */array_get(node->fmts, i));
		if (!(fmt == L'E' || fmt == L'F' || fmt == L'G' || fmt == L'e' || fmt == L'f' || fmt == L'g' || fmt == L'd' || fmt == L'u' || fmt == L'x' || fmt == L'X' || fmt == L'o' || fmt == L'c' || fmt == L's' || fmt == L'p' || fmt == L'_')) {
			v__checker__Checker_error(c, _STR("unknown format specifier `%c\000`", 2, fmt), (*(v__token__Position*)/*ee elem_typ */array_get(node->fmt_poss, i)));
		}
		if (fmt == L'_') {
			fmt = v__checker__Checker_get_default_fmt(c, ftyp, typ);
			if (fmt == L'_') {
				if (!v__ast__Type_alias_eq(typ, _const_v__ast__void_type)) {
					v__checker__Checker_error(c, _STR("no known default format for type `%.*s\000`", 2, v__ast__Table_get_type_name(c->table, ftyp)), (*(v__token__Position*)/*ee elem_typ */array_get(node->fmt_poss, i)));
				}
			} else {
				(*(byte*)/*ee elem_typ */array_get(node->fmts, i)) = fmt;
				(*(bool*)/*ee elem_typ */array_get(node->need_fmts, i)) = false;
			}
		} else {
			if ((*(int*)/*ee elem_typ */array_get(node->precisions, i)) != 987698 && !v__ast__Type_is_float(typ)) {
				v__checker__Checker_error(c, _SLIT("precision specification only valid for float types"), (*(v__token__Position*)/*ee elem_typ */array_get(node->fmt_poss, i)));
			}
			if ((*(bool*)/*ee elem_typ */array_get(node->pluss, i)) && !v__ast__Type_is_number(typ)) {
				v__checker__Checker_error(c, _SLIT("plus prefix only allowed for numbers"), (*(v__token__Position*)/*ee elem_typ */array_get(node->fmt_poss, i)));
			}
			if ((v__ast__Type_is_unsigned(typ) && !(fmt == L'u' || fmt == L'x' || fmt == L'X' || fmt == L'o' || fmt == L'c')) || (v__ast__Type_is_signed(typ) && !(fmt == L'd' || fmt == L'x' || fmt == L'X' || fmt == L'o' || fmt == L'c')) || (v__ast__Type_is_int_literal(typ) && !(fmt == L'd' || fmt == L'c' || fmt == L'x' || fmt == L'X' || fmt == L'o' || fmt == L'u' || fmt == L'x' || fmt == L'X' || fmt == L'o')) || (v__ast__Type_is_float(typ) && !(fmt == L'E' || fmt == L'F' || fmt == L'G' || fmt == L'e' || fmt == L'f' || fmt == L'g')) || (v__ast__Type_is_pointer(typ) && !(fmt == L'p' || fmt == L'x' || fmt == L'X')) || (v__ast__Type_is_string(typ) && fmt != L's') || ((v__ast__Type_idx(typ) == _const_v__ast__i64_type_idx || v__ast__Type_idx(typ) == _const_v__ast__f64_type_idx) && fmt == L'c')) {
				v__checker__Checker_error(c, _STR("illegal format specifier `%c\000` for type `%.*s\000`", 3, fmt, v__ast__Table_get_type_name(c->table, ftyp)), (*(v__token__Position*)/*ee elem_typ */array_get(node->fmt_poss, i)));
			}
			(*(bool*)/*ee elem_typ */array_get(node->need_fmts, i)) = fmt != v__checker__Checker_get_default_fmt(c, ftyp, typ);
		}
		if (c->cur_fn->is_method && string_eq(c->cur_fn->name, _SLIT("str")) && string_eq(c->cur_fn->receiver.name, v__ast__Expr_str(expr))) {
			v__checker__Checker_error(c, _SLIT("cannot call `str()` method recursively"), v__ast__Expr_position(expr));
		}
	}
	c->inside_println_arg = inside_println_arg_save;
	// autofree_scope_vars(pos=16057 line_nr=474 scope.pos=13947 scope.end_pos=16081)
	// var "c" var.pos=13952 var.line_nr=425
	// var "node" var.pos=13984 var.line_nr=425
	// var "inside_println_arg_save" var.pos=14025 var.line_nr=426
	// af parent scope:
	// af parent scope:
	return _const_v__ast__string_type;
}

void v__checker__Checker_infer_fn_types(v__checker__Checker* c, v__ast__Fn f, v__ast__CallExpr* call_expr) {
	Array_v__ast__Type inferred_types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
	// FOR IN array
	for (int gi = 0; gi < f.generic_names.len; ++gi) {
		string gt_name = ((string*)f.generic_names.data)[gi];
		if (gi < call_expr->generic_types.len) {
			array_push(&inferred_types, _MOV((v__ast__Type[]){ (*(v__ast__Type*)/*ee elem_typ */array_get(call_expr->generic_types, gi)) }));
			continue;
		}
		v__ast__Type typ = _const_v__ast__void_type;
		// FOR IN array
		for (int i = 0; i < f.params.len; ++i) {
			v__ast__Param param = ((v__ast__Param*)f.params.data)[i];
			v__ast__Type to_set = _const_v__ast__void_type;
			if (i == 0 && call_expr->is_method && v__ast__Type_has_flag(param.typ, v__ast__TypeFlag_generic)) {
				v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(c->table, call_expr->receiver_type);
				if (sym->kind == v__ast__Kind_struct_) {
					v__ast__Struct info = /* as */ *(v__ast__Struct*)__as_cast((sym->info)._v__ast__Struct,(sym->info)._typ, 409) /*expected idx: 409, name: v.ast.Struct */ ;
					if (info.concrete_types.len > 0) {
						typ = (*(v__ast__Type*)/*ee elem_typ */array_get(info.concrete_types, 0));
					}
				}
			}
			int arg_i = (i != 0 && call_expr->is_method ? (i - 1) : (i));
			if (call_expr->args.len <= arg_i) {
				break;
			}
			v__ast__CallArg arg = (*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr->args, arg_i));
			v__ast__TypeSymbol* param_type_sym = v__ast__Table_get_type_symbol(c->table, param.typ);
			if (v__ast__Type_has_flag(param.typ, v__ast__TypeFlag_generic) && string_eq(param_type_sym->name, gt_name)) {
				to_set = v__ast__Table_mktyp(c->table, arg.typ);
				if (v__ast__Expr_is_auto_deref_var(arg.expr)) {
					to_set = v__ast__Type_deref(to_set);
				}
				if (v__ast__Type_has_flag(to_set, v__ast__TypeFlag_generic)) {
					to_set = v__checker__Checker_unwrap_generic(c, to_set);
				}
			} else {
				v__ast__TypeSymbol* arg_sym = v__ast__Table_get_type_symbol(c->table, arg.typ);
				if (arg_sym->kind == v__ast__Kind_array && param_type_sym->kind == v__ast__Kind_array) {
					v__ast__Array arg_elem_info = /* as */ *(v__ast__Array*)__as_cast((arg_sym->info)._v__ast__Array,(arg_sym->info)._typ, 395) /*expected idx: 395, name: v.ast.Array */ ;
					v__ast__Array param_elem_info = /* as */ *(v__ast__Array*)__as_cast((param_type_sym->info)._v__ast__Array,(param_type_sym->info)._typ, 395) /*expected idx: 395, name: v.ast.Array */ ;
					v__ast__TypeSymbol* arg_elem_sym = v__ast__Table_get_type_symbol(c->table, arg_elem_info.elem_type);
					v__ast__TypeSymbol* param_elem_sym = v__ast__Table_get_type_symbol(c->table, param_elem_info.elem_type);
					for (;;) {
						if (arg_elem_sym->kind == v__ast__Kind_array && param_elem_sym->kind == v__ast__Kind_array && !(Array_string_contains(c->cur_fn->generic_names, param_elem_sym->name))) {
							arg_elem_info = /* as */ *(v__ast__Array*)__as_cast((arg_elem_sym->info)._v__ast__Array,(arg_elem_sym->info)._typ, 395) /*expected idx: 395, name: v.ast.Array */ ;
							arg_elem_sym = v__ast__Table_get_type_symbol(c->table, arg_elem_info.elem_type);
							param_elem_info = /* as */ *(v__ast__Array*)__as_cast((param_elem_sym->info)._v__ast__Array,(param_elem_sym->info)._typ, 395) /*expected idx: 395, name: v.ast.Array */ ;
							param_elem_sym = v__ast__Table_get_type_symbol(c->table, param_elem_info.elem_type);
						} else {
							to_set = arg_elem_info.elem_type;
							break;
						}
					}
				} else if (v__ast__Type_has_flag(param.typ, v__ast__TypeFlag_variadic)) {
					to_set = v__ast__Table_mktyp(c->table, arg.typ);
				}
			}
			if (!v__ast__Type_alias_eq(to_set, _const_v__ast__void_type)) {
				if (!v__ast__Type_alias_eq(typ, _const_v__ast__void_type)) {
					if (v__ast__Type_is_number(typ) && v__ast__Type_is_number(to_set)) {
						v__ast__Type promoted = v__checker__Checker_promote_num(c, typ, to_set);
						if (!v__ast__Type_alias_eq(promoted, _const_v__ast__void_type)) {
							to_set = promoted;
						}
					}
					if (!v__checker__Checker_check_types(c, typ, to_set)) {
						v__checker__Checker_error(c, _STR("inferred generic type `%.*s\000` is ambiguous: got `%.*s\000`, expected `%.*s\000`", 4, gt_name, v__ast__Table_get_type_symbol(c->table, to_set)->name, v__ast__Table_get_type_symbol(c->table, typ)->name), arg.pos);
					}
				}
				typ = to_set;
			}
		}
		if (v__ast__Type_alias_eq(typ, _const_v__ast__void_type)) {
			v__checker__Checker_error(c, _STR("could not infer generic type `%.*s\000` in call to `%.*s\000`", 3, gt_name, f.name), call_expr->pos);
			return;
		}
		if (c->pref->is_verbose) {
			string s = v__ast__Table_type_to_str(c->table, typ);
			println(_STR("inferred `%.*s\000<%.*s\000>`", 3, f.name, s));
		}
		array_push(&inferred_types, _MOV((v__ast__Type[]){ typ }));
		array_push(&call_expr->generic_types, _MOV((v__ast__Type[]){ typ }));
	}
	v__ast__Table_register_fn_gen_type(c->table, f.name, inferred_types);
}

v__checker__Checker v__checker__new_checker(v__ast__Table* table, v__pref__Preferences* pref) {
	bool timers_should_print = false;
	 v__checker__Checker _t1852 = (v__checker__Checker){.pref = pref,.table = table,.file = 0,.nr_errors = 0,.nr_warnings = 0,.nr_notices = 0,.errors = __new_array(0, 1, sizeof(v__errors__Error)),.warnings = __new_array(0, 1, sizeof(v__errors__Warning)),.notices = __new_array(0, 1, sizeof(v__errors__Notice)),.error_lines = __new_array(0, 1, sizeof(int)),.expected_type = 0,.expected_or_type = 0,.cur_fn = 0,.const_decl = (string){.str=(byteptr)"", .is_lit=1},.const_deps = __new_array(0, 1, sizeof(string)),.const_names = __new_array(0, 1, sizeof(string)),.global_names = __new_array(0, 1, sizeof(string)),.locked_names = __new_array(0, 1, sizeof(string)),.rlocked_names = __new_array(0, 1, sizeof(string)),.in_for_count = 0,.returns = 0,.scope_returns = 0,.mod = (string){.str=(byteptr)"", .is_lit=1},.is_builtin_mod = 0,.inside_unsafe = 0,.inside_const = 0,.inside_anon_fn = 0,.inside_ref_lit = 0,.skip_flags = 0,.cur_generic_types = __new_array(0, 1, sizeof(v__ast__Type)),.files = __new_array(0, 1, sizeof(v__ast__File)),.expr_level = 0,.inside_sql = 0,.cur_orm_ts = (v__ast__TypeSymbol){.methods = __new_array(0, 1, sizeof(v__ast__Fn)),},.error_details = __new_array(0, 1, sizeof(string)),.vmod_file_content = (string){.str=(byteptr)"", .is_lit=1},.vweb_gen_types = __new_array(0, 1, sizeof(v__ast__Type)),.prevent_sum_type_unwrapping_once = 0,.loop_label = (string){.str=(byteptr)"", .is_lit=1},.timers = v__util__new_timers(timers_should_print),.comptime_fields_type = new_map(sizeof(string), sizeof(v__ast__Type), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.fn_scope = ((voidptr)(0)),.used_fns = new_map(sizeof(string), sizeof(bool), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.main_fn_decl_node = (v__ast__FnDecl){.params = __new_array(0, 1, sizeof(v__ast__Param)),.generic_names = __new_array(0, 1, sizeof(string)),.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.stmts = __new_array(0, 1, sizeof(v__ast__Stmt)),.defer_stmts = __new_array(0, 1, sizeof(v__ast__DeferStmt)),.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.next_comments = __new_array(0, 1, sizeof(v__ast__Comment)),.source_file = 0,.label_names = __new_array(0, 1, sizeof(string)),},.match_exhaustive_cutoff_limit = pref->checker_match_exhaustive_cutoff_limit,.using_new_err_struct = 0,.inside_selector_expr = 0,.inside_println_arg = 0,};
	// autofree_scope_vars(pos=3718 line_nr=92 scope.pos=3565 scope.end_pos=3901)
	// var "table" var.pos=3577 var.line_nr=87
	// var "pref" var.pos=3595 var.line_nr=87
	// var "timers_should_print" var.pos=3634 var.line_nr=88
	// af parent scope:
	// af parent scope:
	return _t1852;
}

void v__checker__Checker_check(v__checker__Checker* c, v__ast__File* ast_file) {
	c->file = ast_file;
	// FOR IN array
	for (int i = 0; i < ast_file->imports.len; ++i) {
		v__ast__Import ast_import = ((v__ast__Import*)ast_file->imports.data)[i];
		for (int j = 0; j < i; ++j) {
			if (string_eq(ast_import.mod, (*(v__ast__Import*)/*ee elem_typ */array_get(ast_file->imports, j)).mod)) {
				v__checker__Checker_error(c, _STR("module name `%.*s\000` duplicate", 2, ast_import.mod), ast_import.mod_pos);
			}
		}
	}
	// FOR IN array
	for (int _t1853 = 0; _t1853 < ast_file->stmts.len; ++_t1853) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)ast_file->stmts.data)[_t1853];
		c->expr_level = 0;
		v__checker__Checker_stmt(c, stmt);
	}
	v__checker__Checker_check_scope_vars(c, c->file->scope);
}

void v__checker__Checker_check_scope_vars(v__checker__Checker* c, v__ast__Scope* sc) {
	// FOR IN map
	Map_string_v__ast__ScopeObject _t1854 = sc->objects;
	int _t1856 = _t1854.key_values.len;
	for (int _t1855 = 0; _t1855 < _t1856; ++_t1855 ) {
		int _t1857 = _t1854.key_values.len - _t1856;
		_t1856 = _t1854.key_values.len;
		if (_t1857 < 0) {
			_t1855 = -1;
			continue;
		}
		if (!DenseArray_has_index(&_t1854.key_values, _t1855)) {continue;}
		v__ast__ScopeObject obj = (*(v__ast__ScopeObject*)DenseArray_value(&_t1854.key_values, _t1855));
		if (obj._typ == 312 /* v.ast.Var */) {
			if (!c->pref->is_repl) {
				if (!(*obj._v__ast__Var).is_used && string_at((*obj._v__ast__Var).name, 0) != L'_') {
					v__checker__Checker_warn(c, _STR("unused variable: `%.*s\000`", 2, (*obj._v__ast__Var).name), (*obj._v__ast__Var).pos);
				}
			}
			if ((*obj._v__ast__Var).is_mut && !(*obj._v__ast__Var).is_changed && !c->is_builtin_mod && string_ne((*obj._v__ast__Var).name, _SLIT("it"))) {
			}
		}
		else {
		};
	}
	// FOR IN array
	for (int _t1858 = 0; _t1858 < sc->children.len; ++_t1858) {
		v__ast__Scope* child = ((v__ast__Scope**)sc->children.data)[_t1858];
		v__checker__Checker_check_scope_vars(c, child);
	}
}

Array_v__errors__Error v__checker__Checker_check2(v__checker__Checker* c, v__ast__File* ast_file) {
	c->file = ast_file;
	// FOR IN array
	for (int _t1859 = 0; _t1859 < ast_file->stmts.len; ++_t1859) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)ast_file->stmts.data)[_t1859];
		v__checker__Checker_stmt(c, stmt);
	}
	 Array_v__errors__Error _t1860 = c->errors;
	// autofree_scope_vars(pos=5046 line_nr=146 scope.pos=4919 scope.end_pos=5063)
	// var "c" var.pos=4924 var.line_nr=141
	// var "ast_file" var.pos=4942 var.line_nr=141
	// af parent scope:
	// af parent scope:
	return _t1860;
}

void v__checker__Checker_check_files(v__checker__Checker* c, Array_v__ast__File ast_files) {
	bool has_main_mod_file = false;
	bool has_main_fn = false;
	Array_v__ast__File_ptr files_from_main_module = __new_array_with_default(0, 0, sizeof(v__ast__File*), 0);
	for (int i = 0; i < ast_files.len; ++i) {
		v__ast__File* file = &(*(v__ast__File*)/*ee elem_typ */array_get(ast_files, i));
		v__util__Timers_start(c->timers, _STR("checker_check %.*s", 1, file->path));
		v__checker__Checker_check(c, file);
		if (string_eq(file->mod.name, _SLIT("main"))) {
			array_push(&files_from_main_module, _MOV((v__ast__File*[]){ file }));
			has_main_mod_file = true;
			if (v__checker__Checker_file_has_main_fn(c, *file)) {
				has_main_fn = true;
			}
		}
		v__util__Timers_show(c->timers, _STR("checker_check %.*s", 1, file->path));
	}
	if (has_main_mod_file && !has_main_fn && files_from_main_module.len > 0) {
		if (c->pref->is_script && !c->pref->is_test) {
			v__ast__File* the_main_file = (*(v__ast__File**)array_last(files_from_main_module));
			array_push(&the_main_file->stmts, _MOV((v__ast__Stmt[]){ v__ast__FnDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__FnDecl, ((v__ast__FnDecl){
				.name = _SLIT("main.main"),
				.mod = _SLIT("main"),
				.params = __new_array(0, 1, sizeof(v__ast__Param)),
				.is_deprecated = 0,
				.is_pub = 0,
				.is_variadic = 0,
				.is_anon = 0,
				.is_manualfree = 0,
				.is_main = true,
				.is_test = 0,
				.is_conditional = 0,
				.is_keep_alive = 0,
				.receiver = (v__ast__StructField){.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),},
				.receiver_pos = {0},
				.is_method = 0,
				.method_type_pos = {0},
				.method_idx = 0,
				.rec_mut = 0,
				.rec_share = 0,
				.language = 0,
				.no_body = 0,
				.is_builtin = 0,
				.body_pos = {0},
				.file = the_main_file->path,
				.generic_names = __new_array(0, 1, sizeof(string)),
				.is_direct_arr = 0,
				.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),
				.skip_gen = 0,
				.stmts = __new_array(0, 1, sizeof(v__ast__Stmt)),
				.defer_stmts = __new_array(0, 1, sizeof(v__ast__DeferStmt)),
				.return_type = _const_v__ast__void_type,
				.return_type_pos = {0},
				.has_return = 0,
				.comments = __new_array(0, 1, sizeof(v__ast__Comment)),
				.next_comments = __new_array(0, 1, sizeof(v__ast__Comment)),
				.source_file = 0,
				.scope = (v__ast__Scope*)memdup(&(v__ast__Scope){.objects = new_map(sizeof(string), sizeof(v__ast__ScopeObject), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.struct_fields = __new_array(0, 1, sizeof(v__ast__ScopeStructField)),.parent = 0,.detached_from_parent = 0,.children = __new_array(0, 1, sizeof(v__ast__Scope*)),.start_pos = 0,.end_pos = 0,}, sizeof(v__ast__Scope)),
				.label_names = __new_array(0, 1, sizeof(string)),
				.pos = {0},
			}))) }));
			has_main_fn = true;
		}
	}
	v__util__Timers_start(c->timers, _SLIT("checker_post_process_generic_fns"));
	v__ast__File* last_file = c->file;
	string last_mod = c->mod;
	for (int i = 0; i < ast_files.len; ++i) {
		v__ast__File* file = &(*(v__ast__File*)/*ee elem_typ */array_get(ast_files, i));
		if (file->generic_fns.len > 0) {
			c->file = file;
			c->mod = file->mod.name;
			v__checker__Checker_post_process_generic_fns(c);
		}
	}
	c->file = last_file;
	c->mod = last_mod;
	v__util__Timers_show(c->timers, _SLIT("checker_post_process_generic_fns"));
	v__util__Timers_start(c->timers, _SLIT("checker_verify_all_vweb_routes"));
	v__checker__Checker_verify_all_vweb_routes(c);
	v__util__Timers_show(c->timers, _SLIT("checker_verify_all_vweb_routes"));
	if (c->pref->is_test) {
		int n_test_fns = 0;
		// FOR IN map
		Map_string_v__ast__Fn _t1863 = c->table->fns;
		int _t1865 = _t1863.key_values.len;
		for (int _t1864 = 0; _t1864 < _t1865; ++_t1864 ) {
			int _t1866 = _t1863.key_values.len - _t1865;
			_t1865 = _t1863.key_values.len;
			if (_t1866 < 0) {
				_t1864 = -1;
				continue;
			}
			if (!DenseArray_has_index(&_t1863.key_values, _t1864)) {continue;}
			v__ast__Fn f = (*(v__ast__Fn*)DenseArray_value(&_t1863.key_values, _t1864));
			if (f.is_test) {
				n_test_fns++;
			}
		}
		if (n_test_fns == 0) {
			v__checker__Checker_add_error_detail(c, _SLIT("The name of a test function in V, should start with `test_`."));
			v__checker__Checker_add_error_detail(c, _SLIT("The test function should take 0 parameters, and no return type. Example:"));
			v__checker__Checker_add_error_detail(c, _SLIT("fn test_xyz(){ assert 2 + 2 == 4 }"));
			v__checker__Checker_error(c, _SLIT("a _test.v file should have *at least* one `test_` function"), (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,});
		}
	}
	if (c->pref->build_mode == v__pref__BuildMode_build_module || c->pref->is_test) {
		return;
	}
	if (c->pref->is_shared) {
		return;
	}
	if (!has_main_mod_file) {
		v__checker__Checker_error(c, _SLIT("project must include a `main` module or be a shared library (compile with `v -shared`)"), (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,});
	} else if (!has_main_fn) {
		v__checker__Checker_error(c, _SLIT("function `main` must be declared in the main module"), (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,});
	}
}

VV_LOCAL_SYMBOL bool v__checker__Checker_file_has_main_fn(v__checker__Checker* c, v__ast__File file) {
	bool has_main_fn = false;
	// FOR IN array
	for (int _t1867 = 0; _t1867 < file.stmts.len; ++_t1867) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)file.stmts.data)[_t1867];
		if ((stmt)._typ == 175 /* v.ast.FnDecl */) {
			if (string_eq((*stmt._v__ast__FnDecl).name, _SLIT("main.main"))) {
				if (has_main_fn) {
					v__checker__Checker_error(c, _SLIT("function `main` is already defined"), (*stmt._v__ast__FnDecl).pos);
				}
				has_main_fn = true;
				if ((*stmt._v__ast__FnDecl).params.len > 0) {
					v__checker__Checker_error(c, _SLIT("function `main` cannot have arguments"), (*stmt._v__ast__FnDecl).pos);
				}
				if (!v__ast__Type_alias_eq((*stmt._v__ast__FnDecl).return_type, _const_v__ast__void_type)) {
					v__checker__Checker_error(c, _SLIT("function `main` cannot return values"), (*stmt._v__ast__FnDecl).pos);
				}
				if ((*stmt._v__ast__FnDecl).no_body) {
					v__checker__Checker_error(c, _SLIT("function `main` must declare a body"), (*stmt._v__ast__FnDecl).pos);
				}
			} else if (Array_v__ast__Attr_contains((*stmt._v__ast__FnDecl).attrs, _SLIT("console"))) {
				v__checker__Checker_error(c, _SLIT("only `main` can have the `[console]` attribute"), (*stmt._v__ast__FnDecl).pos);
			}
		}
	}
	// autofree_scope_vars(pos=8582 line_nr=262 scope.pos=7874 scope.end_pos=8602)
	// var "c" var.pos=7879 var.line_nr=239
	// var "file" var.pos=7907 var.line_nr=239
	// var "has_main_fn" var.pos=7934 var.line_nr=240
	// af parent scope:
	// af parent scope:
	return has_main_fn;
}

VV_LOCAL_SYMBOL void v__checker__Checker_check_valid_snake_case(v__checker__Checker* c, string name, string identifier, v__token__Position pos) {
	if (!c->pref->is_vweb && name.len > 0 && (string_at(name, 0) == L'_' || string_contains(name, _SLIT("._")))) {
		v__checker__Checker_error(c, _STR("%.*s\000 `%.*s\000` cannot start with `_`", 3, identifier, name), pos);
	}
	if (!c->pref->experimental && !c->pref->translated && v__util__contains_capital(name)) {
		v__checker__Checker_error(c, _STR("%.*s\000 `%.*s\000` cannot contain uppercase letters, use snake_case instead", 3, identifier, name), pos);
	}
}

VV_LOCAL_SYMBOL string v__checker__stripped_name(string name) {
	Option_int _t1868 = string_last_index(name, _SLIT("."));
	if (_t1868.state != 0) { /*or block*/ 
		IError err = _t1868.err;
		*(int*) _t1868.data = -1;
	}
 	int idx =  *(int*)_t1868.data;
	 string _t1869 = string_substr(name, (idx + 1), name.len);
	// autofree_scope_vars(pos=9107 line_nr=277 scope.pos=9032 scope.end_pos=9133)
	// var "name" var.pos=9046 var.line_nr=275
	// var "idx" var.pos=9069 var.line_nr=276
	// af parent scope:
	// af parent scope:
	return _t1869;
}

VV_LOCAL_SYMBOL void v__checker__Checker_check_valid_pascal_case(v__checker__Checker* c, string name, string identifier, v__token__Position pos) {
	string sname = v__checker__stripped_name(name);
	if (sname.len > 0 && !byte_is_capital(string_at(sname, 0)) && !c->pref->translated) {
		v__checker__Checker_error(c, _STR("%.*s\000 `%.*s\000` must begin with capital letter", 3, identifier, name), pos);
	}
}

void v__checker__Checker_type_decl(v__checker__Checker* c, v__ast__TypeDecl node) {
	if (node._typ == 229 /* v.ast.AliasTypeDecl */) {
		v__checker__Checker_alias_type_decl(c, (*node._v__ast__AliasTypeDecl));
	}
	else if (node._typ == 230 /* v.ast.FnTypeDecl */) {
		v__checker__Checker_fn_type_decl(c, (*node._v__ast__FnTypeDecl));
	}
	else if (node._typ == 231 /* v.ast.SumTypeDecl */) {
		v__checker__Checker_sum_type_decl(c, (*node._v__ast__SumTypeDecl));
	};
}

void v__checker__Checker_alias_type_decl(v__checker__Checker* c, v__ast__AliasTypeDecl node) {
	if (string_ne(c->file->mod.name, _SLIT("time")) && string_ne(c->file->mod.name, _SLIT("builtin"))) {
		v__checker__Checker_check_valid_pascal_case(c, node.name, _SLIT("type alias"), node.pos);
	}
	v__ast__TypeSymbol* typ_sym = v__ast__Table_get_type_symbol(c->table, node.parent_type);
	if ((typ_sym->kind == v__ast__Kind_placeholder || typ_sym->kind == v__ast__Kind_int_literal || typ_sym->kind == v__ast__Kind_float_literal)) {
		v__checker__Checker_error(c, _STR("type `%.*s\000` doesn't exist", 2, typ_sym->name), node.pos);
	} else if (typ_sym->kind == v__ast__Kind_alias) {
		v__ast__TypeSymbol* orig_sym = v__ast__Table_get_type_symbol(c->table, (/* as */ *(v__ast__Alias*)__as_cast((typ_sym->info)._v__ast__Alias,(typ_sym->info)._typ, 413) /*expected idx: 413, name: v.ast.Alias */ ).parent_type);
		v__checker__Checker_error(c, _STR("type `%.*s\000` is an alias, use the original alias type `%.*s\000` instead", 3, v__ast__TypeSymbol_str(typ_sym), orig_sym->name), node.pos);
	} else if (typ_sym->kind == v__ast__Kind_chan) {
		v__checker__Checker_error(c, _SLIT("aliases of `chan` types are not allowed."), node.pos);
	}
}

void v__checker__Checker_fn_type_decl(v__checker__Checker* c, v__ast__FnTypeDecl node) {
	v__checker__Checker_check_valid_pascal_case(c, node.name, _SLIT("fn type"), node.pos);
	v__ast__TypeSymbol* typ_sym = v__ast__Table_get_type_symbol(c->table, node.typ);
	v__ast__FnType fn_typ_info = /* as */ *(v__ast__FnType*)__as_cast((typ_sym->info)._v__ast__FnType,(typ_sym->info)._typ, 418) /*expected idx: 418, name: v.ast.FnType */ ;
	v__ast__Fn fn_info = fn_typ_info.func;
	v__ast__TypeSymbol* ret_sym = v__ast__Table_get_type_symbol(c->table, fn_info.return_type);
	if (ret_sym->kind == v__ast__Kind_placeholder) {
		v__checker__Checker_error(c, _STR("type `%.*s\000` doesn't exist", 2, ret_sym->name), node.pos);
	}
	// FOR IN array
	for (int _t1870 = 0; _t1870 < fn_info.params.len; ++_t1870) {
		v__ast__Param arg = ((v__ast__Param*)fn_info.params.data)[_t1870];
		v__ast__TypeSymbol* arg_sym = v__ast__Table_get_type_symbol(c->table, arg.typ);
		if (arg_sym->kind == v__ast__Kind_placeholder) {
			v__checker__Checker_error(c, _STR("type `%.*s\000` doesn't exist", 2, arg_sym->name), node.pos);
		}
	}
}

void v__checker__Checker_sum_type_decl(v__checker__Checker* c, v__ast__SumTypeDecl node) {
	v__checker__Checker_check_valid_pascal_case(c, node.name, _SLIT("sum type"), node.pos);
	Array_string names_used = __new_array_with_default(0, 0, sizeof(string), 0);
	// FOR IN array
	for (int _t1871 = 0; _t1871 < node.variants.len; ++_t1871) {
		v__ast__SumTypeVariant variant = ((v__ast__SumTypeVariant*)node.variants.data)[_t1871];
		if (v__ast__Type_is_ptr(variant.typ)) {
			v__checker__Checker_error(c, _SLIT("sum type cannot hold a reference type"), variant.pos);
		}
		v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(c->table, variant.typ);
		if ((Array_string_contains(names_used, sym->name))) {
			v__checker__Checker_error(c, _STR("sum type %.*s\000 cannot hold the type `%.*s\000` more than once", 3, node.name, sym->name), variant.pos);
		} else if ((sym->kind == v__ast__Kind_placeholder || sym->kind == v__ast__Kind_int_literal || sym->kind == v__ast__Kind_float_literal)) {
			v__checker__Checker_error(c, _STR("type `%.*s\000` doesn't exist", 2, sym->name), variant.pos);
		} else if (sym->kind == v__ast__Kind_interface_) {
			v__checker__Checker_error(c, _SLIT("sum type cannot hold an interface"), variant.pos);
		}
		array_push(&names_used, _MOV((string[]){ string_clone(sym->name) }));
	}
}

void v__checker__Checker_interface_decl(v__checker__Checker* c, v__ast__InterfaceDecl decl) {
	v__checker__Checker_check_valid_pascal_case(c, decl.name, _SLIT("interface name"), decl.pos);
	// FOR IN array
	for (int _t1873 = 0; _t1873 < decl.methods.len; ++_t1873) {
		v__ast__FnDecl method = ((v__ast__FnDecl*)decl.methods.data)[_t1873];
		v__checker__Checker_check_valid_snake_case(c, method.name, _SLIT("method name"), method.pos);
		if (!v__ast__Type_alias_eq(method.return_type, ((v__ast__Type)(0)))) {
			Option_void _t1874 = v__checker__Checker_ensure_type_exists(c, method.return_type, method.return_type_pos);
			if (_t1874.state != 0 && _t1874.err._typ != _IError_None___index) {
				IError err = _t1874.err;
				return;
			};
		}
		// FOR IN array
		for (int _t1875 = 0; _t1875 < method.params.len; ++_t1875) {
			v__ast__Param param = ((v__ast__Param*)method.params.data)[_t1875];
			Option_void _t1876 = v__checker__Checker_ensure_type_exists(c, param.typ, param.pos);
			if (_t1876.state != 0 && _t1876.err._typ != _IError_None___index) {
				IError err = _t1876.err;
				return;
			};
		}
	}
	// FOR IN array
	for (int i = 0; i < decl.fields.len; ++i) {
		v__ast__StructField field = ((v__ast__StructField*)decl.fields.data)[i];
		v__checker__Checker_check_valid_snake_case(c, field.name, _SLIT("field name"), field.pos);
		if (!v__ast__Type_alias_eq(field.typ, ((v__ast__Type)(0)))) {
			Option_void _t1877 = v__checker__Checker_ensure_type_exists(c, field.typ, field.pos);
			if (_t1877.state != 0 && _t1877.err._typ != _IError_None___index) {
				IError err = _t1877.err;
				return;
			};
		}
		for (int j = 0; j < i; ++j) {
			if (string_eq(field.name, (*(v__ast__StructField*)/*ee elem_typ */array_get(decl.fields, j)).name)) {
				v__checker__Checker_error(c, _STR("field name `%.*s\000` duplicate", 2, field.name), field.pos);
			}
		}
	}
}

void v__checker__Checker_struct_decl(v__checker__Checker* c, v__ast__StructDecl* decl) {
	if (decl->language == v__ast__Language_v && !c->is_builtin_mod) {
		v__checker__Checker_check_valid_pascal_case(c, decl->name, _SLIT("struct name"), decl->pos);
	}
	Option_v__ast__TypeSymbol _t1878 = v__ast__Table_find_type(c->table, decl->name);
	if (_t1878.state != 0) { /*or block*/ 
		IError err = _t1878.err;
		*(v__ast__TypeSymbol*) _t1878.data = (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.cname = (string){.str=(byteptr)"", .is_lit=1},.methods = __new_array(0, 1, sizeof(v__ast__Fn)),.mod = (string){.str=(byteptr)"", .is_lit=1},.is_public = 0,.language = 0,};
	}
 	v__ast__TypeSymbol struct_sym =  *(v__ast__TypeSymbol*)_t1878.data;
	if ((struct_sym.info)._typ == 409 /* v.ast.Struct */) {
		// FOR IN array
		for (int _t1879 = 0; _t1879 < decl->embeds.len; ++_t1879) {
			v__ast__Embed embed = ((v__ast__Embed*)decl->embeds.data)[_t1879];
			v__ast__TypeSymbol* embed_sym = v__ast__Table_get_type_symbol(c->table, embed.typ);
			if (embed_sym->kind != v__ast__Kind_struct_) {
				v__checker__Checker_error(c, _STR("`%.*s\000` is not a struct", 2, embed_sym->name), embed.pos);
			} else {
				v__ast__Struct info = /* as */ *(v__ast__Struct*)__as_cast((embed_sym->info)._v__ast__Struct,(embed_sym->info)._typ, 409) /*expected idx: 409, name: v.ast.Struct */ ;
				if (info.is_heap && !v__ast__Type_is_ptr(embed.typ)) {
					(*struct_sym.info._v__ast__Struct).is_heap = true;
				}
			}
		}
		// FOR IN array
		for (int _t1880 = 0; _t1880 < decl->attrs.len; ++_t1880) {
			v__ast__Attr attr = ((v__ast__Attr*)decl->attrs.data)[_t1880];
			if (string_eq(attr.name, _SLIT("typedef")) && decl->language != v__ast__Language_c) {
				v__checker__Checker_error(c, _SLIT("`typedef` attribute can only be used with C structs"), decl->pos);
			}
		}
		// FOR IN array
		for (int i = 0; i < decl->fields.len; ++i) {
			v__ast__StructField field = ((v__ast__StructField*)decl->fields.data)[i];
			Option_void _t1881 = v__checker__Checker_ensure_type_exists(c, field.typ, field.type_pos);
			if (_t1881.state != 0 && _t1881.err._typ != _IError_None___index) {
				IError err = _t1881.err;
				return;
			};
			if (decl->language == v__ast__Language_v) {
				v__checker__Checker_check_valid_snake_case(c, field.name, _SLIT("field name"), field.pos);
			}
			v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(c->table, field.typ);
			for (int j = 0; j < i; ++j) {
				if (string_eq(field.name, (*(v__ast__StructField*)/*ee elem_typ */array_get(decl->fields, j)).name)) {
					v__checker__Checker_error(c, _STR("field name `%.*s\000` duplicate", 2, field.name), field.pos);
				}
			}
			if (sym->kind == v__ast__Kind_struct_) {
				v__ast__Struct info = /* as */ *(v__ast__Struct*)__as_cast((sym->info)._v__ast__Struct,(sym->info)._typ, 409) /*expected idx: 409, name: v.ast.Struct */ ;
				if (info.is_heap && !v__ast__Type_is_ptr(field.typ)) {
					(*struct_sym.info._v__ast__Struct).is_heap = true;
				}
			}
			if (field.has_default_expr) {
				c->expected_type = field.typ;
				v__ast__Type field_expr_type = v__checker__Checker_expr(c, field.default_expr);
				if (!v__ast__Type_has_flag(field.typ, v__ast__TypeFlag_optional)) {
					v__checker__Checker_check_expr_opt_call(c, field.default_expr, field_expr_type);
				}
				(*(v__ast__StructField*)/*ee elem_typ */array_get((*struct_sym.info._v__ast__Struct).fields, i)).default_expr_typ = field_expr_type;
				Option_void _t1882 = v__checker__Checker_check_expected(c, field_expr_type, field.typ);
				if (_t1882.state != 0 && _t1882.err._typ != _IError_None___index) {
					IError err = _t1882.err;
					if (!(sym->kind == v__ast__Kind_interface_ && v__checker__Checker_type_implements(c, field_expr_type, field.typ, field.pos))) {
						v__checker__Checker_error(c, _STR("incompatible initializer for field `%.*s\000`: %.*s", 2, field.name, (*(err.msg))), v__ast__Expr_position(field.default_expr));
					}
				};
				if (v__ast__Type_is_ptr(field.typ)) {
					continue;
				}
				if ((field.default_expr)._typ == 259 /* v.ast.IntegerLiteral */) {
					if (string_eq((*field.default_expr._v__ast__IntegerLiteral).val, _SLIT("0"))) {
						v__checker__Checker_warn(c, _SLIT("unnecessary default value of `0`: struct fields are zeroed by default"), (*field.default_expr._v__ast__IntegerLiteral).pos);
					}
				} else if ((field.default_expr)._typ == 277 /* v.ast.StringLiteral */) {
					if (((*field.default_expr._v__ast__StringLiteral).val).len == 0) {
						v__checker__Checker_warn(c, _SLIT("unnecessary default value of '': struct fields are zeroed by default"), (*field.default_expr._v__ast__StringLiteral).pos);
					}
				} else if ((field.default_expr)._typ == 239 /* v.ast.BoolLiteral */) {
					if ((*field.default_expr._v__ast__BoolLiteral).val == false) {
						v__checker__Checker_warn(c, _SLIT("unnecessary default value `false`: struct fields are zeroed by default"), (*field.default_expr._v__ast__BoolLiteral).pos);
					}
				}
			}
		}
	}
}

v__ast__Type v__checker__Checker_struct_init(v__checker__Checker* c, v__ast__StructInit* struct_init) {
	if (v__ast__Type_alias_eq(struct_init->typ, _const_v__ast__void_type)) {
		if (v__ast__Type_alias_eq(c->expected_type, _const_v__ast__void_type)) {
			v__checker__Checker_error(c, _SLIT("unexpected short struct syntax"), struct_init->pos);
			// autofree_scope_vars(pos=15555 line_nr=460 scope.pos=15489 scope.end_pos=15579)
			// af parent scope:
			// var "sym" var.pos=15583 var.line_nr=462
			// af parent scope:
			// var "c" var.pos=15159 var.line_nr=451
			// var "struct_init" var.pos=15186 var.line_nr=451
			// var "utyp" var.pos=15770 var.line_nr=469
			// var "type_sym" var.pos=15864 var.line_nr=471
			// af parent scope:
			// af parent scope:
			return _const_v__ast__void_type;
		}
		v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(c->table, c->expected_type);
		if (sym->kind == v__ast__Kind_array) {
			struct_init->typ = v__ast__Table_value_type(c->table, c->expected_type);
		} else {
			struct_init->typ = c->expected_type;
		}
	}
	v__ast__Type utyp = v__checker__Checker_unwrap_generic(c, struct_init->typ);
	Option_void _t1883 = v__checker__Checker_ensure_type_exists(c, utyp, struct_init->pos);
	if (_t1883.state != 0 && _t1883.err._typ != _IError_None___index) {
		IError err = _t1883.err;
	};
	v__ast__TypeSymbol* type_sym = v__ast__Table_get_type_symbol(c->table, utyp);
	if (!c->inside_unsafe && type_sym->kind == v__ast__Kind_sum_type) {
		v__checker__Checker_note(c, _SLIT("direct sum type init (`x := SumType{}`) will be removed soon"), struct_init->pos);
	}
	if (!c->is_builtin_mod && !c->inside_unsafe && type_sym->language == v__ast__Language_v && c->cur_generic_types.len == 0) {
		Option_int _t1884 = string_last_index(type_sym->name, _SLIT("."));
		if (_t1884.state != 0) { /*or block*/ 
			IError err = _t1884.err;
			*(int*) _t1884.data = -1;
		}
 		int pos =  *(int*)_t1884.data;
		byte first_letter = string_at(type_sym->name, pos + 1);
		if (!byte_is_capital(first_letter)) {
			v__checker__Checker_error(c, _STR("cannot initialize builtin type `%.*s\000`", 2, type_sym->name), struct_init->pos);
		}
	}
	if (type_sym->kind == v__ast__Kind_sum_type && struct_init->fields.len == 1) {
		string sexpr = v__ast__Expr_str((*(v__ast__StructInitField*)/*ee elem_typ */array_get(struct_init->fields, 0)).expr);
		v__checker__Checker_error(c, _STR("cast to sum type using `%.*s\000(%.*s\000)` not `%.*s\000{%.*s\000}`", 5, type_sym->name, sexpr, type_sym->name, sexpr), struct_init->pos);
	}
	if (type_sym->kind == v__ast__Kind_interface_) {
		v__checker__Checker_error(c, _STR("cannot instantiate interface `%.*s\000`", 2, type_sym->name), struct_init->pos);
	}
	if ((type_sym->info)._typ == 413 /* v.ast.Alias */) {
		if (v__ast__Type_is_number((*type_sym->info._v__ast__Alias).parent_type)) {
			v__checker__Checker_error(c, _STR("cannot instantiate number type alias `%.*s\000`", 2, type_sym->name), struct_init->pos);
			// autofree_scope_vars(pos=16973 line_nr=496 scope.pos=16884 scope.end_pos=16997)
			// af parent scope:
			// af parent scope:
			// var "c" var.pos=15159 var.line_nr=451
			// var "struct_init" var.pos=15186 var.line_nr=451
			// var "utyp" var.pos=15770 var.line_nr=469
			// var "type_sym" var.pos=15864 var.line_nr=471
			// af parent scope:
			// af parent scope:
			return _const_v__ast__void_type;
		}
	}
	if (!type_sym->is_public && type_sym->kind != v__ast__Kind_placeholder && type_sym->language != v__ast__Language_c && (string_ne(type_sym->mod, c->mod) && !(v__ast__Type_has_flag(struct_init->typ, v__ast__TypeFlag_generic) && string_ne(type_sym->mod, _SLIT("builtin"))))) {
		v__checker__Checker_error(c, _STR("type `%.*s\000` is private", 2, type_sym->name), struct_init->pos);
	}
	if (type_sym->kind == v__ast__Kind_struct_) {
		v__ast__Struct info = /* as */ *(v__ast__Struct*)__as_cast((type_sym->info)._v__ast__Struct,(type_sym->info)._typ, 409) /*expected idx: 409, name: v.ast.Struct */ ;
		if (info.attrs.len > 0 && string_eq((*(v__ast__Attr*)/*ee elem_typ */array_get(info.attrs, 0)).name, _SLIT("noinit")) && string_ne(type_sym->mod, c->mod)) {
			v__checker__Checker_error(c, string_add(_STR("struct `%.*s\000` is declared with a `[noinit]` attribute, so ", 2, type_sym->name), _STR("it cannot be initialized with `%.*s\000{}`", 2, type_sym->name)), struct_init->pos);
		}
		if (info.is_heap && !c->inside_ref_lit && !c->inside_unsafe && !v__ast__Type_is_ptr(struct_init->typ)) {
			v__checker__Checker_error(c, _STR("`%.*s\000` type can only be used as a reference `&%.*s\000` or inside a `struct` reference", 3, type_sym->name, type_sym->name), struct_init->pos);
		}
	}
	if (type_sym->name.len == 1 && c->cur_fn->generic_names.len == 0) {
		v__checker__Checker_error(c, _STR("unknown struct `%.*s\000`", 2, type_sym->name), struct_init->pos);
		 v__ast__Type _t1885 = 0;
		// autofree_scope_vars(pos=18027 line_nr=518 scope.pos=17962 scope.end_pos=18038)
		// af parent scope:
		// var "c" var.pos=15159 var.line_nr=451
		// var "struct_init" var.pos=15186 var.line_nr=451
		// var "utyp" var.pos=15770 var.line_nr=469
		// var "type_sym" var.pos=15864 var.line_nr=471
		// af parent scope:
		// af parent scope:
		return _t1885;
	}

	if (type_sym->kind == (v__ast__Kind_placeholder)) {
		v__checker__Checker_error(c, _STR("unknown struct: %.*s", 1, type_sym->name), struct_init->pos);
		// autofree_scope_vars(pos=18144 line_nr=523 scope.pos=18065 scope.end_pos=18168)
		// af parent scope:
		// var "c" var.pos=15159 var.line_nr=451
		// var "struct_init" var.pos=15186 var.line_nr=451
		// var "utyp" var.pos=15770 var.line_nr=469
		// var "type_sym" var.pos=15864 var.line_nr=471
		// af parent scope:
		// af parent scope:
		return _const_v__ast__void_type;
	}
	else if (type_sym->kind == (v__ast__Kind_struct_) || type_sym->kind == (v__ast__Kind_string) || type_sym->kind == (v__ast__Kind_array) || type_sym->kind == (v__ast__Kind_alias)) {
		v__ast__Struct info = (v__ast__Struct){.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.embeds = __new_array(0, 1, sizeof(v__ast__Type)),.fields = __new_array(0, 1, sizeof(v__ast__StructField)),.is_typedef = 0,.is_union = 0,.is_heap = 0,.generic_types = __new_array(0, 1, sizeof(v__ast__Type)),.concrete_types = __new_array(0, 1, sizeof(v__ast__Type)),.parent_type = 0,};
		if (type_sym->kind == v__ast__Kind_alias) {
			v__ast__Alias info_t = /* as */ *(v__ast__Alias*)__as_cast((type_sym->info)._v__ast__Alias,(type_sym->info)._typ, 413) /*expected idx: 413, name: v.ast.Alias */ ;
			v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(c->table, info_t.parent_type);
			if (sym->kind == v__ast__Kind_placeholder) {
				v__checker__Checker_error(c, _STR("unknown struct: %.*s", 1, type_sym->name), struct_init->pos);
				// autofree_scope_vars(pos=18570 line_nr=533 scope.pos=18459 scope.end_pos=18596)
				// af parent scope:
				// var "info_t" var.pos=18335 var.line_nr=529
				// var "sym" var.pos=18376 var.line_nr=530
				// af parent scope:
				// var "info" var.pos=18278 var.line_nr=527
				// var "inited_fields" var.pos=19130 var.line_nr=551
				// af parent scope:
				// var "c" var.pos=15159 var.line_nr=451
				// var "struct_init" var.pos=15186 var.line_nr=451
				// var "utyp" var.pos=15770 var.line_nr=469
				// var "type_sym" var.pos=15864 var.line_nr=471
				// af parent scope:
				// af parent scope:
				return _const_v__ast__void_type;
			}
			if (sym->kind != v__ast__Kind_struct_) {
				v__checker__Checker_error(c, _STR("alias type name: %.*s\000 is not struct type", 2, sym->name), struct_init->pos);
			}
			info = /* as */ *(v__ast__Struct*)__as_cast((sym->info)._v__ast__Struct,(sym->info)._typ, 409) /*expected idx: 409, name: v.ast.Struct */ ;
		} else {
			info = /* as */ *(v__ast__Struct*)__as_cast((type_sym->info)._v__ast__Struct,(type_sym->info)._typ, 409) /*expected idx: 409, name: v.ast.Struct */ ;
		}
		if (struct_init->is_short) {
			int exp_len = info.fields.len;
			int got_len = struct_init->fields.len;
			if (exp_len != got_len) {
				string amount = (exp_len < got_len ? (_SLIT("many")) : (_SLIT("few")));
				v__checker__Checker_error(c, _STR("too %.*s\000 fields in `%.*s\000` literal (expecting %"PRId32"\000, got %"PRId32"\000)", 5, amount, type_sym->name, exp_len, got_len), struct_init->pos);
			}
		}
		Array_string inited_fields = __new_array_with_default(0, 0, sizeof(string), 0);
		// FOR IN array
		for (int i = 0; i < struct_init->fields.len; ++i) {
			v__ast__StructInitField field = ((v__ast__StructInitField*)struct_init->fields.data)[i];
			v__ast__StructField info_field = (v__ast__StructField){.pos = {0},.type_pos = {0},.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.default_expr = {0},.has_default_expr = 0,.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.is_pub = 0,.default_val = (string){.str=(byteptr)"", .is_lit=1},.is_mut = 0,.is_global = 0,.default_expr_typ = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,};
			v__ast__Type embed_type = ((v__ast__Type)(0));
			bool is_embed = false;
			string field_name = _SLIT("");
			if (struct_init->is_short) {
				if (i >= info.fields.len) {
					break;
				}
				info_field = (*(v__ast__StructField*)/*ee elem_typ */array_get(info.fields, i));
				field_name = info_field.name;
				(*(v__ast__StructInitField*)/*ee elem_typ */array_get(struct_init->fields, i)).name = field_name;
			} else {
				field_name = field.name;
				bool exists = false;
				// FOR IN array
				for (int _t1886 = 0; _t1886 < info.fields.len; ++_t1886) {
					v__ast__StructField f = ((v__ast__StructField*)info.fields.data)[_t1886];
					if (string_eq(f.name, field_name)) {
						info_field = f;
						exists = true;
						break;
					}
				}
				if (!exists) {
					// FOR IN array
					for (int _t1887 = 0; _t1887 < info.embeds.len; ++_t1887) {
						v__ast__Type embed = ((v__ast__Type*)info.embeds.data)[_t1887];
						v__ast__TypeSymbol* embed_sym = v__ast__Table_get_type_symbol(c->table, embed);
						if (string_eq(v__ast__TypeSymbol_embed_name(embed_sym), field_name)) {
							exists = true;
							embed_type = embed;
							is_embed = true;
							break;
						}
					}
				}
				if (!exists) {
					v__checker__Checker_error(c, _STR("unknown field `%.*s\000` in struct literal of type `%.*s\000`", 3, field.name, type_sym->name), field.pos);
					continue;
				}
				if ((Array_string_contains(inited_fields, field_name))) {
					v__checker__Checker_error(c, _STR("duplicate field name in struct literal: `%.*s\000`", 2, field_name), field.pos);
					continue;
				}
			}
			if (is_embed) {
				c->expected_type = embed_type;
				v__ast__Type expr_type = v__checker__Checker_expr(c, field.expr);
				v__ast__TypeSymbol* expr_type_sym = v__ast__Table_get_type_symbol(c->table, expr_type);
				if (!v__ast__Type_alias_eq(expr_type, _const_v__ast__void_type) && expr_type_sym->kind != v__ast__Kind_placeholder) {
					Option_void _t1888 = v__checker__Checker_check_expected(c, expr_type, embed_type);
					if (_t1888.state != 0 && _t1888.err._typ != _IError_None___index) {
						IError err = _t1888.err;
						v__checker__Checker_error(c, _STR("cannot assign to field `%.*s\000`: %.*s", 2, info_field.name, (*(err.msg))), field.pos);
					};
				}
				(*(v__ast__StructInitField*)/*ee elem_typ */array_get(struct_init->fields, i)).typ = expr_type;
				(*(v__ast__StructInitField*)/*ee elem_typ */array_get(struct_init->fields, i)).expected_type = embed_type;
			} else {
				array_push(&inited_fields, _MOV((string[]){ string_clone(field_name) }));
				v__ast__TypeSymbol* field_type_sym = v__ast__Table_get_type_symbol(c->table, info_field.typ);
				c->expected_type = info_field.typ;
				v__ast__Type expr_type = v__checker__Checker_expr(c, field.expr);
				if (!v__ast__Type_has_flag(info_field.typ, v__ast__TypeFlag_optional)) {
					expr_type = v__checker__Checker_check_expr_opt_call(c, field.expr, expr_type);
				}
				v__ast__TypeSymbol* expr_type_sym = v__ast__Table_get_type_symbol(c->table, expr_type);
				if (field_type_sym->kind == v__ast__Kind_interface_) {
					v__checker__Checker_type_implements(c, expr_type, info_field.typ, field.pos);
				} else if (!v__ast__Type_alias_eq(expr_type, _const_v__ast__void_type) && expr_type_sym->kind != v__ast__Kind_placeholder) {
					Option_void _t1890 = v__checker__Checker_check_expected(c, expr_type, info_field.typ);
					if (_t1890.state != 0 && _t1890.err._typ != _IError_None___index) {
						IError err = _t1890.err;
						v__checker__Checker_error(c, _STR("cannot assign to field `%.*s\000`: %.*s", 2, info_field.name, (*(err.msg))), field.pos);
					};
				}
				if (v__ast__Type_has_flag(info_field.typ, v__ast__TypeFlag_shared_f)) {
					if (!v__ast__Type_has_flag(expr_type, v__ast__TypeFlag_shared_f) && v__ast__Type_is_ptr(expr_type)) {
						v__checker__Checker_error(c, _SLIT("`shared` field must be initialized with `shared` or value"), field.pos);
					}
				} else {
					if (v__ast__Type_is_ptr(info_field.typ) && !v__ast__Type_is_ptr(expr_type) && !v__ast__Type_is_pointer(expr_type) && !v__ast__Type_is_number(expr_type)) {
						v__checker__Checker_error(c, _SLIT("reference field must be initialized with reference"), field.pos);
					}
				}
				(*(v__ast__StructInitField*)/*ee elem_typ */array_get(struct_init->fields, i)).typ = expr_type;
				(*(v__ast__StructInitField*)/*ee elem_typ */array_get(struct_init->fields, i)).expected_type = info_field.typ;
			}
		}
		// FOR IN array
		for (int _t1891 = 0; _t1891 < info.fields.len; ++_t1891) {
			v__ast__StructField field = ((v__ast__StructField*)info.fields.data)[_t1891];
			if (field.has_default_expr || (Array_string_contains(inited_fields, field.name))) {
				continue;
			}
			if (v__ast__Type_is_ptr(field.typ) && !v__ast__Type_has_flag(field.typ, v__ast__TypeFlag_shared_f) && !struct_init->has_update_expr && !c->pref->translated) {
				v__checker__Checker_error(c, _STR("reference field `%.*s\000.%.*s\000` must be initialized", 3, type_sym->name, field.name), struct_init->pos);
			}
			if (Array_v__ast__Attr_contains(field.attrs, _SLIT("required")) && !struct_init->is_short) {
				bool found = false;
				// FOR IN array
				for (int _t1892 = 0; _t1892 < struct_init->fields.len; ++_t1892) {
					v__ast__StructInitField init_field = ((v__ast__StructInitField*)struct_init->fields.data)[_t1892];
					if (string_eq(field.name, init_field.name)) {
						found = true;
						break;
					}
				}
				if (!found) {
					v__checker__Checker_error(c, _STR("field `%.*s\000.%.*s\000` must be initialized", 3, type_sym->name, field.name), struct_init->pos);
				}
			}
		}
	}
	else {
	};
	if (struct_init->has_update_expr) {
		v__ast__Type update_type = v__checker__Checker_expr(c, struct_init->update_expr);
		struct_init->update_expr_type = update_type;
		if (v__ast__Table_type_kind(c->table, update_type) != v__ast__Kind_struct_) {
			string s = v__ast__Table_type_to_str(c->table, update_type);
			v__checker__Checker_error(c, _STR("expected struct, found `%.*s\000`", 2, s), v__ast__Expr_position(struct_init->update_expr));
		} else if (!v__ast__Type_alias_eq(update_type, struct_init->typ)) {
			v__ast__TypeSymbol* from_sym = v__ast__Table_get_type_symbol(c->table, update_type);
			v__ast__TypeSymbol* to_sym = v__ast__Table_get_type_symbol(c->table, struct_init->typ);
			v__ast__Struct from_info = /* as */ *(v__ast__Struct*)__as_cast((from_sym->info)._v__ast__Struct,(from_sym->info)._typ, 409) /*expected idx: 409, name: v.ast.Struct */ ;
			v__ast__Struct to_info = /* as */ *(v__ast__Struct*)__as_cast((to_sym->info)._v__ast__Struct,(to_sym->info)._typ, 409) /*expected idx: 409, name: v.ast.Struct */ ;
			if (!v__checker__Checker_check_struct_signature(c, from_info, to_info)) {
				v__checker__Checker_error(c, _STR("struct `%.*s\000` is not compatible with struct `%.*s\000`", 3, from_sym->name, to_sym->name), v__ast__Expr_position(struct_init->update_expr));
			}
		}
		if (!v__ast__Expr_is_lvalue(struct_init->update_expr)) {
			v__checker__Checker_error(c, _SLIT("expression is not an lvalue"), v__ast__Expr_position(struct_init->update_expr));
		}
	}
	 v__ast__Type _t1893 = struct_init->typ;
	// autofree_scope_vars(pos=24154 line_nr=702 scope.pos=15154 scope.end_pos=24178)
	// var "c" var.pos=15159 var.line_nr=451
	// var "struct_init" var.pos=15186 var.line_nr=451
	// var "utyp" var.pos=15770 var.line_nr=469
	// var "type_sym" var.pos=15864 var.line_nr=471
	// af parent scope:
	// af parent scope:
	return _t1893;
}

VV_LOCAL_SYMBOL void v__checker__Checker_check_div_mod_by_zero(v__checker__Checker* c, v__ast__Expr expr, v__token__Kind op_kind) {
	if (expr._typ == 252 /* v.ast.FloatLiteral */) {
		if (string_f64((*expr._v__ast__FloatLiteral).val) == 0.0) {
			string oper = (op_kind == v__token__Kind_div ? (_SLIT("division")) : (_SLIT("modulo")));
			v__checker__Checker_error(c, _STR("%.*s\000 by zero", 2, oper), (*expr._v__ast__FloatLiteral).pos);
		}
	}
	else if (expr._typ == 259 /* v.ast.IntegerLiteral */) {
		if (string_int((*expr._v__ast__IntegerLiteral).val) == 0) {
			string oper = (op_kind == v__token__Kind_div ? (_SLIT("division")) : (_SLIT("modulo")));
			v__checker__Checker_error(c, _STR("%.*s\000 by zero", 2, oper), (*expr._v__ast__IntegerLiteral).pos);
		}
	}
	else if (expr._typ == 242 /* v.ast.CastExpr */) {
		v__checker__Checker_check_div_mod_by_zero(c, (*expr._v__ast__CastExpr).expr, op_kind);
	}
	else {
	};
}

v__ast__Type v__checker__Checker_infix_expr(v__checker__Checker* c, v__ast__InfixExpr* infix_expr) {
bool v__checker__Checker_infix_expr_defer_0 = false;
	v__ast__Type former_expected_type = c->expected_type;
	v__checker__Checker_infix_expr_defer_0 = true;
	v__ast__Type left_type = v__checker__Checker_expr(c, infix_expr->left);
	infix_expr->left_type = left_type;
	c->expected_type = left_type;
	v__ast__Type right_type = v__checker__Checker_expr(c, infix_expr->right);
	infix_expr->right_type = right_type;
	v__ast__TypeSymbol* right = v__ast__Table_get_type_symbol(c->table, right_type);
	v__ast__TypeSymbol* right_final = v__ast__Table_get_final_type_symbol(c->table, right_type);
	v__ast__TypeSymbol* left = v__ast__Table_get_type_symbol(c->table, left_type);
	v__ast__TypeSymbol* left_final = v__ast__Table_get_final_type_symbol(c->table, left_type);
	v__token__Position left_pos = v__ast__Expr_position(infix_expr->left);
	v__token__Position right_pos = v__ast__Expr_position(infix_expr->right);
	v__token__Position left_right_pos = v__token__Position_extend(left_pos, right_pos);
	if ((v__ast__Type_is_ptr(left_type) || v__ast__TypeSymbol_is_pointer(left)) && (infix_expr->op == v__token__Kind_plus || infix_expr->op == v__token__Kind_minus)) {
		if (!c->inside_unsafe && !v__ast__Expr_is_auto_deref_var(infix_expr->left) && !v__ast__Expr_is_auto_deref_var(infix_expr->right)) {
			v__checker__Checker_warn(c, _SLIT("pointer arithmetic is only allowed in `unsafe` blocks"), left_pos);
		}
		if (v__ast__Type_alias_eq(left_type, _const_v__ast__voidptr_type)) {
			v__checker__Checker_error(c, _STR("`%.*s\000` cannot be used with `voidptr`", 2, v__token__Kind_str(infix_expr->op)), left_pos);
		}
	}
	v__ast__Type return_type = left_type;
	if (infix_expr->op != v__token__Kind_key_is) {
		if (infix_expr->left._typ == 254 /* v.ast.Ident */) {
			if ((*infix_expr->left._v__ast__Ident).is_mut) {
				v__checker__Checker_error(c, _SLIT("remove unnecessary `mut`"), (*infix_expr->left._v__ast__Ident).mut_pos);
			}
		}
		else if (infix_expr->left._typ == 273 /* v.ast.SelectorExpr */) {
			if ((*infix_expr->left._v__ast__SelectorExpr).is_mut) {
				v__checker__Checker_error(c, _SLIT("remove unnecessary `mut`"), (*infix_expr->left._v__ast__SelectorExpr).mut_pos);
			}
		}
		else {
		};
	}
	bool eq_ne = (infix_expr->op == v__token__Kind_eq || infix_expr->op == v__token__Kind_ne);

	if (infix_expr->op == (v__token__Kind_eq) || infix_expr->op == (v__token__Kind_ne)) {
		bool is_mismatch = (left->kind == v__ast__Kind_alias && (right->kind == v__ast__Kind_struct_ || right->kind == v__ast__Kind_array || right->kind == v__ast__Kind_sum_type)) || (right->kind == v__ast__Kind_alias && (left->kind == v__ast__Kind_struct_ || left->kind == v__ast__Kind_array || left->kind == v__ast__Kind_sum_type));
		if (is_mismatch) {
			v__checker__Checker_error(c, _STR("possible type mismatch of compared values of `%.*s\000` operation", 2, v__token__Kind_str(infix_expr->op)), left_right_pos);
		}
	}
	else if (infix_expr->op == (v__token__Kind_key_in) || infix_expr->op == (v__token__Kind_not_in)) {

		if (right->kind == (v__ast__Kind_array)) {
			v__ast__Type elem_type = v__ast__TypeSymbol_array_info(right).elem_type;
			Option_void _t1894 = v__checker__Checker_check_expected(c, left_type, elem_type);
			if (_t1894.state != 0 && _t1894.err._typ != _IError_None___index) {
				IError err = _t1894.err;
				v__checker__Checker_error(c, _STR("left operand to `%.*s\000` does not match the array element type: %.*s", 2, v__token__Kind_str(infix_expr->op), (*(err.msg))), left_right_pos);
			};
		}
		else if (right->kind == (v__ast__Kind_map)) {
			v__ast__Map map_info = v__ast__TypeSymbol_map_info(right);
			Option_void _t1895 = v__checker__Checker_check_expected(c, left_type, map_info.key_type);
			if (_t1895.state != 0 && _t1895.err._typ != _IError_None___index) {
				IError err = _t1895.err;
				v__checker__Checker_error(c, _STR("left operand to `%.*s\000` does not match the map key type: %.*s", 2, v__token__Kind_str(infix_expr->op), (*(err.msg))), left_right_pos);
			};
			infix_expr->left_type = map_info.key_type;
		}
		else if (right->kind == (v__ast__Kind_string)) {
			v__checker__Checker_warn(c, _SLIT("use `str.contains(substr)` instead of `substr in str`"), left_right_pos);
			Option_void _t1896 = v__checker__Checker_check_expected(c, left_type, right_type);
			if (_t1896.state != 0 && _t1896.err._typ != _IError_None___index) {
				IError err = _t1896.err;
				v__checker__Checker_error(c, _STR("left operand to `%.*s\000` does not match: %.*s", 2, v__token__Kind_str(infix_expr->op), (*(err.msg))), left_right_pos);
			};
		}
		else {
			v__checker__Checker_error(c, _STR("`%.*s\000` can only be used with an array/map/string", 2, v__token__Kind_str(infix_expr->op)), infix_expr->pos);
		};
		// Defer begin
		if (v__checker__Checker_infix_expr_defer_0 == true) {
			c->expected_type = former_expected_type;
		}
		// Defer end
		// autofree_scope_vars(pos=27948 line_nr=811 scope.pos=26952 scope.end_pos=27972)
		// af parent scope:
		// var "c" var.pos=24699 var.line_nr=726
		// var "infix_expr" var.pos=24725 var.line_nr=726
		// var "former_expected_type" var.pos=24823 var.line_nr=728
		// var "left_type" var.pos=24917 var.line_nr=732
		// var "right_type" var.pos=25075 var.line_nr=736
		// var "right" var.pos=25214 var.line_nr=739
		// var "right_final" var.pos=25260 var.line_nr=740
		// var "left" var.pos=25322 var.line_nr=741
		// var "left_final" var.pos=25366 var.line_nr=742
		// var "left_pos" var.pos=25422 var.line_nr=743
		// var "right_pos" var.pos=25462 var.line_nr=744
		// var "left_right_pos" var.pos=25504 var.line_nr=745
		// var "return_type" var.pos=25942 var.line_nr=755
		// var "eq_ne" var.pos=26189 var.line_nr=766
		// var "left_is_optional" var.pos=39018 var.line_nr=1087
		// var "right_is_optional" var.pos=39069 var.line_nr=1088
		// af parent scope:
		// af parent scope:
		return _const_v__ast__bool_type;
	}
	else if (infix_expr->op == (v__token__Kind_plus) || infix_expr->op == (v__token__Kind_minus) || infix_expr->op == (v__token__Kind_mul) || infix_expr->op == (v__token__Kind_div) || infix_expr->op == (v__token__Kind_mod) || infix_expr->op == (v__token__Kind_xor) || infix_expr->op == (v__token__Kind_amp) || infix_expr->op == (v__token__Kind_pipe)) {
		if ((right->info)._typ == 413 /* v.ast.Alias */ && (/* as */ *(v__ast__Alias*)__as_cast((right->info)._v__ast__Alias,(right->info)._typ, 413) /*expected idx: 413, name: v.ast.Alias */ ).language != v__ast__Language_c && string_eq(c->mod, (*(string*)/*ee elem_typ */array_get(string_split(v__ast__Table_type_to_str(c->table, right_type), _SLIT(".")), 0))) && v__ast__TypeSymbol_is_primitive(v__ast__Table_get_type_symbol(c->table, (/* as */ *(v__ast__Alias*)__as_cast((right->info)._v__ast__Alias,(right->info)._typ, 413) /*expected idx: 413, name: v.ast.Alias */ ).parent_type))) {
			right = v__ast__Table_get_type_symbol(c->table, (/* as */ *(v__ast__Alias*)__as_cast((right->info)._v__ast__Alias,(right->info)._typ, 413) /*expected idx: 413, name: v.ast.Alias */ ).parent_type);
		}
		if ((left->info)._typ == 413 /* v.ast.Alias */ && (/* as */ *(v__ast__Alias*)__as_cast((left->info)._v__ast__Alias,(left->info)._typ, 413) /*expected idx: 413, name: v.ast.Alias */ ).language != v__ast__Language_c && string_eq(c->mod, (*(string*)/*ee elem_typ */array_get(string_split(v__ast__Table_type_to_str(c->table, left_type), _SLIT(".")), 0))) && v__ast__TypeSymbol_is_primitive(v__ast__Table_get_type_symbol(c->table, (/* as */ *(v__ast__Alias*)__as_cast((left->info)._v__ast__Alias,(left->info)._typ, 413) /*expected idx: 413, name: v.ast.Alias */ ).parent_type))) {
			left = v__ast__Table_get_type_symbol(c->table, (/* as */ *(v__ast__Alias*)__as_cast((left->info)._v__ast__Alias,(left->info)._typ, 413) /*expected idx: 413, name: v.ast.Alias */ ).parent_type);
		}
		if (left->kind == v__ast__Kind_alias && (left->info)._typ == 413 /* v.ast.Alias */ && !(v__ast__TypeSymbol_is_primitive(v__ast__Table_get_type_symbol(c->table, (/* as */ *(v__ast__Alias*)__as_cast((left->info)._v__ast__Alias,(left->info)._typ, 413) /*expected idx: 413, name: v.ast.Alias */ ).parent_type)))) {
			if (v__ast__TypeSymbol_has_method(left, v__token__Kind_str(infix_expr->op))) {
				Option_v__ast__Fn _t1897;
				if (_t1897 = v__ast__TypeSymbol_find_method(left, v__token__Kind_str(infix_expr->op)), _t1897.state == 0) {
					v__ast__Fn method = *(v__ast__Fn*)_t1897.data;
					return_type = method.return_type;
				} else {
					IError err = _t1897.err;
					return_type = left_type;
				}
			} else {
				string left_name = v__ast__Table_type_to_str(c->table, left_type);
				string right_name = v__ast__Table_type_to_str(c->table, right_type);
				if (string_eq(left_name, right_name)) {
					v__checker__Checker_error(c, _STR("undefined operation `%.*s\000` %.*s\000 `%.*s\000`", 4, left_name, v__token__Kind_str(infix_expr->op), right_name), left_right_pos);
				} else {
					v__checker__Checker_error(c, _STR("mismatched types `%.*s\000` and `%.*s\000`", 3, left_name, right_name), left_right_pos);
				}
			}
		} else if (right->kind == v__ast__Kind_alias && (right->info)._typ == 413 /* v.ast.Alias */ && !(v__ast__TypeSymbol_is_primitive(v__ast__Table_get_type_symbol(c->table, (/* as */ *(v__ast__Alias*)__as_cast((right->info)._v__ast__Alias,(right->info)._typ, 413) /*expected idx: 413, name: v.ast.Alias */ ).parent_type)))) {
			if (v__ast__TypeSymbol_has_method(right, v__token__Kind_str(infix_expr->op))) {
				Option_v__ast__Fn _t1898;
				if (_t1898 = v__ast__TypeSymbol_find_method(right, v__token__Kind_str(infix_expr->op)), _t1898.state == 0) {
					v__ast__Fn method = *(v__ast__Fn*)_t1898.data;
					return_type = method.return_type;
				} else {
					IError err = _t1898.err;
					return_type = right_type;
				}
			} else {
				string left_name = v__ast__Table_type_to_str(c->table, left_type);
				string right_name = v__ast__Table_type_to_str(c->table, right_type);
				if (string_eq(left_name, right_name)) {
					v__checker__Checker_error(c, _STR("undefined operation `%.*s\000` %.*s\000 `%.*s\000`", 4, left_name, v__token__Kind_str(infix_expr->op), right_name), left_right_pos);
				} else {
					v__checker__Checker_error(c, _STR("mismatched types `%.*s\000` and `%.*s\000`", 3, left_name, right_name), left_right_pos);
				}
			}
		}
		if ((left->kind == v__ast__Kind_array || left->kind == v__ast__Kind_array_fixed || left->kind == v__ast__Kind_map || left->kind == v__ast__Kind_struct_)) {
			if (v__ast__TypeSymbol_has_method(left, v__token__Kind_str(infix_expr->op))) {
				Option_v__ast__Fn _t1899;
				if (_t1899 = v__ast__TypeSymbol_find_method(left, v__token__Kind_str(infix_expr->op)), _t1899.state == 0) {
					v__ast__Fn method = *(v__ast__Fn*)_t1899.data;
					return_type = method.return_type;
				} else {
					IError err = _t1899.err;
					return_type = left_type;
				}
			} else {
				string left_name = v__ast__Table_type_to_str(c->table, left_type);
				string right_name = v__ast__Table_type_to_str(c->table, right_type);
				if (string_eq(left_name, right_name)) {
					v__checker__Checker_error(c, _STR("undefined operation `%.*s\000` %.*s\000 `%.*s\000`", 4, left_name, v__token__Kind_str(infix_expr->op), right_name), left_right_pos);
				} else {
					v__checker__Checker_error(c, _STR("mismatched types `%.*s\000` and `%.*s\000`", 3, left_name, right_name), left_right_pos);
				}
			}
		} else if ((right->kind == v__ast__Kind_array || right->kind == v__ast__Kind_array_fixed || right->kind == v__ast__Kind_map || right->kind == v__ast__Kind_struct_)) {
			if (v__ast__TypeSymbol_has_method(right, v__token__Kind_str(infix_expr->op))) {
				Option_v__ast__Fn _t1900;
				if (_t1900 = v__ast__TypeSymbol_find_method(right, v__token__Kind_str(infix_expr->op)), _t1900.state == 0) {
					v__ast__Fn method = *(v__ast__Fn*)_t1900.data;
					return_type = method.return_type;
				} else {
					IError err = _t1900.err;
					return_type = right_type;
				}
			} else {
				string left_name = v__ast__Table_type_to_str(c->table, left_type);
				string right_name = v__ast__Table_type_to_str(c->table, right_type);
				if (string_eq(left_name, right_name)) {
					v__checker__Checker_error(c, _STR("undefined operation `%.*s\000` %.*s\000 `%.*s\000`", 4, left_name, v__token__Kind_str(infix_expr->op), right_name), left_right_pos);
				} else {
					v__checker__Checker_error(c, _STR("mismatched types `%.*s\000` and `%.*s\000`", 3, left_name, right_name), left_right_pos);
				}
			}
		} else {
			v__ast__Type promoted_type = v__checker__Checker_promote(c, v__ast__Table_unalias_num_type(c->table, left_type), v__ast__Table_unalias_num_type(c->table, right_type));
			if (v__ast__Type_idx(promoted_type) == _const_v__ast__void_type_idx) {
				string left_name = v__ast__Table_type_to_str(c->table, left_type);
				string right_name = v__ast__Table_type_to_str(c->table, right_type);
				v__checker__Checker_error(c, _STR("mismatched types `%.*s\000` and `%.*s\000`", 3, left_name, right_name), left_right_pos);
			} else if (v__ast__Type_has_flag(promoted_type, v__ast__TypeFlag_optional)) {
				string s = v__ast__Table_type_to_str(c->table, promoted_type);
				v__checker__Checker_error(c, _STR("`%.*s\000` cannot be used with `%.*s\000`", 3, v__token__Kind_str(infix_expr->op), s), infix_expr->pos);
			} else if (v__ast__Type_is_float(promoted_type)) {
				if ((infix_expr->op == v__token__Kind_mod || infix_expr->op == v__token__Kind_xor || infix_expr->op == v__token__Kind_amp || infix_expr->op == v__token__Kind_pipe)) {
					string side = (v__ast__Type_alias_eq(left_type, promoted_type) ? (_SLIT("left")) : (_SLIT("right")));
					v__token__Position pos = (v__ast__Type_alias_eq(left_type, promoted_type) ? (left_pos) : (right_pos));
					string name = (v__ast__Type_alias_eq(left_type, promoted_type) ? (left->name) : (right->name));
					if (infix_expr->op == v__token__Kind_mod) {
						v__checker__Checker_error(c, _SLIT("float modulo not allowed, use math.fmod() instead"), pos);
					} else {
						v__checker__Checker_error(c, _STR("%.*s\000 type of `%.*s\000` cannot be non-integer type `%.*s\000`", 4, side, v__token__Kind_str(infix_expr->op), name), pos);
					}
				}
			}
			if ((infix_expr->op == v__token__Kind_div || infix_expr->op == v__token__Kind_mod)) {
				v__checker__Checker_check_div_mod_by_zero(c, infix_expr->right, infix_expr->op);
			}
			return_type = promoted_type;
		}
	}
	else if (infix_expr->op == (v__token__Kind_gt) || infix_expr->op == (v__token__Kind_lt) || infix_expr->op == (v__token__Kind_ge) || infix_expr->op == (v__token__Kind_le)) {
		if ((left->kind == v__ast__Kind_array || left->kind == v__ast__Kind_array_fixed) && (right->kind == v__ast__Kind_array || right->kind == v__ast__Kind_array_fixed)) {
			v__checker__Checker_error(c, _SLIT("only `==` and `!=` are defined on arrays"), infix_expr->pos);
		} else if (left->kind == v__ast__Kind_struct_ && right->kind == v__ast__Kind_struct_ && (infix_expr->op == v__token__Kind_eq || infix_expr->op == v__token__Kind_lt)) {
			if (!(v__ast__TypeSymbol_has_method(left, v__token__Kind_str(infix_expr->op)) && v__ast__TypeSymbol_has_method(right, v__token__Kind_str(infix_expr->op)))) {
				string left_name = v__ast__Table_type_to_str(c->table, left_type);
				string right_name = v__ast__Table_type_to_str(c->table, right_type);
				if (string_eq(left_name, right_name)) {
					v__checker__Checker_error(c, _STR("undefined operation `%.*s\000` %.*s\000 `%.*s\000`", 4, left_name, v__token__Kind_str(infix_expr->op), right_name), left_right_pos);
				} else {
					v__checker__Checker_error(c, _STR("mismatched types `%.*s\000` and `%.*s\000`", 3, left_name, right_name), left_right_pos);
				}
			}
		}
		if (left->kind == v__ast__Kind_struct_ && right->kind == v__ast__Kind_struct_) {
			if (!v__ast__TypeSymbol_has_method(left, _SLIT("<")) && (infix_expr->op == v__token__Kind_ge || infix_expr->op == v__token__Kind_le)) {
				v__checker__Checker_error(c, _STR("cannot use `%.*s\000` as `<` operator method is not defined", 2, v__token__Kind_str(infix_expr->op)), left_right_pos);
			} else if (!v__ast__TypeSymbol_has_method(left, _SLIT("<")) && infix_expr->op == v__token__Kind_gt) {
				v__checker__Checker_error(c, _SLIT("cannot use `>` as `<=` operator method is not defined"), left_right_pos);
			}
		}
	}
	else if (infix_expr->op == (v__token__Kind_left_shift)) {
		if (left_final->kind == v__ast__Kind_array) {
			if (!infix_expr->is_stmt) {
				v__checker__Checker_error(c, _SLIT("array append cannot be used in an expression"), infix_expr->pos);
			}
			v__checker__Checker_check_expr_opt_call(c, infix_expr->right, right_type);
			multi_return_string_v__token__Position mr_34064 = v__checker__Checker_fail_if_immutable(c, infix_expr->left);
			infix_expr->auto_locked = mr_34064.arg0;
			v__ast__Type left_value_type = v__ast__Table_value_type(c->table, left_type);
			v__ast__TypeSymbol* left_value_sym = v__ast__Table_get_type_symbol(c->table, left_value_type);
			if (left_value_sym->kind == v__ast__Kind_interface_) {
				if (right_final->kind != v__ast__Kind_array) {
					v__checker__Checker_type_implements(c, right_type, left_value_type, right_pos);
				} else {
					v__checker__Checker_type_implements(c, v__ast__Table_value_type(c->table, right_type), left_value_type, right_pos);
				}
				// Defer begin
				if (v__checker__Checker_infix_expr_defer_0 == true) {
					c->expected_type = former_expected_type;
				}
				// Defer end
				// autofree_scope_vars(pos=34532 line_nr=968 scope.pos=34261 scope.end_pos=34558)
				// af parent scope:
				// var "left_value_type" var.pos=34107 var.line_nr=957
				// var "left_value_sym" var.pos=34160 var.line_nr=958
				// af parent scope:
				// af parent scope:
				// var "c" var.pos=24699 var.line_nr=726
				// var "infix_expr" var.pos=24725 var.line_nr=726
				// var "former_expected_type" var.pos=24823 var.line_nr=728
				// var "left_type" var.pos=24917 var.line_nr=732
				// var "right_type" var.pos=25075 var.line_nr=736
				// var "right" var.pos=25214 var.line_nr=739
				// var "right_final" var.pos=25260 var.line_nr=740
				// var "left" var.pos=25322 var.line_nr=741
				// var "left_final" var.pos=25366 var.line_nr=742
				// var "left_pos" var.pos=25422 var.line_nr=743
				// var "right_pos" var.pos=25462 var.line_nr=744
				// var "left_right_pos" var.pos=25504 var.line_nr=745
				// var "return_type" var.pos=25942 var.line_nr=755
				// var "eq_ne" var.pos=26189 var.line_nr=766
				// var "left_is_optional" var.pos=39018 var.line_nr=1087
				// var "right_is_optional" var.pos=39069 var.line_nr=1088
				// af parent scope:
				// af parent scope:
				return _const_v__ast__void_type;
			}
			if (v__checker__Checker_check_types(c, right_type, left_value_type)) {
				// Defer begin
				if (v__checker__Checker_infix_expr_defer_0 == true) {
					c->expected_type = former_expected_type;
				}
				// Defer end
				// autofree_scope_vars(pos=34712 line_nr=973 scope.pos=34670 scope.end_pos=34738)
				// af parent scope:
				// var "left_value_type" var.pos=34107 var.line_nr=957
				// var "left_value_sym" var.pos=34160 var.line_nr=958
				// af parent scope:
				// af parent scope:
				// var "c" var.pos=24699 var.line_nr=726
				// var "infix_expr" var.pos=24725 var.line_nr=726
				// var "former_expected_type" var.pos=24823 var.line_nr=728
				// var "left_type" var.pos=24917 var.line_nr=732
				// var "right_type" var.pos=25075 var.line_nr=736
				// var "right" var.pos=25214 var.line_nr=739
				// var "right_final" var.pos=25260 var.line_nr=740
				// var "left" var.pos=25322 var.line_nr=741
				// var "left_final" var.pos=25366 var.line_nr=742
				// var "left_pos" var.pos=25422 var.line_nr=743
				// var "right_pos" var.pos=25462 var.line_nr=744
				// var "left_right_pos" var.pos=25504 var.line_nr=745
				// var "return_type" var.pos=25942 var.line_nr=755
				// var "eq_ne" var.pos=26189 var.line_nr=766
				// var "left_is_optional" var.pos=39018 var.line_nr=1087
				// var "right_is_optional" var.pos=39069 var.line_nr=1088
				// af parent scope:
				// af parent scope:
				return _const_v__ast__void_type;
			}
			if (right_final->kind == v__ast__Kind_array && v__checker__Checker_check_types(c, left_value_type, v__ast__Table_value_type(c->table, right_type))) {
				// Defer begin
				if (v__checker__Checker_infix_expr_defer_0 == true) {
					c->expected_type = former_expected_type;
				}
				// Defer end
				// autofree_scope_vars(pos=34870 line_nr=978 scope.pos=34845 scope.end_pos=34896)
				// af parent scope:
				// var "left_value_type" var.pos=34107 var.line_nr=957
				// var "left_value_sym" var.pos=34160 var.line_nr=958
				// af parent scope:
				// af parent scope:
				// var "c" var.pos=24699 var.line_nr=726
				// var "infix_expr" var.pos=24725 var.line_nr=726
				// var "former_expected_type" var.pos=24823 var.line_nr=728
				// var "left_type" var.pos=24917 var.line_nr=732
				// var "right_type" var.pos=25075 var.line_nr=736
				// var "right" var.pos=25214 var.line_nr=739
				// var "right_final" var.pos=25260 var.line_nr=740
				// var "left" var.pos=25322 var.line_nr=741
				// var "left_final" var.pos=25366 var.line_nr=742
				// var "left_pos" var.pos=25422 var.line_nr=743
				// var "right_pos" var.pos=25462 var.line_nr=744
				// var "left_right_pos" var.pos=25504 var.line_nr=745
				// var "return_type" var.pos=25942 var.line_nr=755
				// var "eq_ne" var.pos=26189 var.line_nr=766
				// var "left_is_optional" var.pos=39018 var.line_nr=1087
				// var "right_is_optional" var.pos=39069 var.line_nr=1088
				// af parent scope:
				// af parent scope:
				return _const_v__ast__void_type;
			}
			v__checker__Checker_error(c, _STR("cannot append `%.*s\000` to `%.*s\000`", 3, right->name, left->name), right_pos);
			// Defer begin
			if (v__checker__Checker_infix_expr_defer_0 == true) {
				c->expected_type = former_expected_type;
			}
			// Defer end
			// autofree_scope_vars(pos=34971 line_nr=981 scope.pos=33842 scope.end_pos=34996)
			// var "left_value_type" var.pos=34107 var.line_nr=957
			// var "left_value_sym" var.pos=34160 var.line_nr=958
			// af parent scope:
			// af parent scope:
			// var "c" var.pos=24699 var.line_nr=726
			// var "infix_expr" var.pos=24725 var.line_nr=726
			// var "former_expected_type" var.pos=24823 var.line_nr=728
			// var "left_type" var.pos=24917 var.line_nr=732
			// var "right_type" var.pos=25075 var.line_nr=736
			// var "right" var.pos=25214 var.line_nr=739
			// var "right_final" var.pos=25260 var.line_nr=740
			// var "left" var.pos=25322 var.line_nr=741
			// var "left_final" var.pos=25366 var.line_nr=742
			// var "left_pos" var.pos=25422 var.line_nr=743
			// var "right_pos" var.pos=25462 var.line_nr=744
			// var "left_right_pos" var.pos=25504 var.line_nr=745
			// var "return_type" var.pos=25942 var.line_nr=755
			// var "eq_ne" var.pos=26189 var.line_nr=766
			// var "left_is_optional" var.pos=39018 var.line_nr=1087
			// var "right_is_optional" var.pos=39069 var.line_nr=1088
			// af parent scope:
			// af parent scope:
			return _const_v__ast__void_type;
		} else {
			// Defer begin
			if (v__checker__Checker_infix_expr_defer_0 == true) {
				c->expected_type = former_expected_type;
			}
			// Defer end
			 v__ast__Type _t1901 = v__checker__Checker_check_shift(c, left_type, right_type, left_pos, right_pos);
			// autofree_scope_vars(pos=35008 line_nr=983 scope.pos=35003 scope.end_pos=35077)
			// af parent scope:
			// af parent scope:
			// var "c" var.pos=24699 var.line_nr=726
			// var "infix_expr" var.pos=24725 var.line_nr=726
			// var "former_expected_type" var.pos=24823 var.line_nr=728
			// var "left_type" var.pos=24917 var.line_nr=732
			// var "right_type" var.pos=25075 var.line_nr=736
			// var "right" var.pos=25214 var.line_nr=739
			// var "right_final" var.pos=25260 var.line_nr=740
			// var "left" var.pos=25322 var.line_nr=741
			// var "left_final" var.pos=25366 var.line_nr=742
			// var "left_pos" var.pos=25422 var.line_nr=743
			// var "right_pos" var.pos=25462 var.line_nr=744
			// var "left_right_pos" var.pos=25504 var.line_nr=745
			// var "return_type" var.pos=25942 var.line_nr=755
			// var "eq_ne" var.pos=26189 var.line_nr=766
			// var "left_is_optional" var.pos=39018 var.line_nr=1087
			// var "right_is_optional" var.pos=39069 var.line_nr=1088
			// af parent scope:
			// af parent scope:
			return _t1901;
		}
	}
	else if (infix_expr->op == (v__token__Kind_right_shift)) {
		// Defer begin
		if (v__checker__Checker_infix_expr_defer_0 == true) {
			c->expected_type = former_expected_type;
		}
		// Defer end
		 v__ast__Type _t1902 = v__checker__Checker_check_shift(c, left_type, right_type, left_pos, right_pos);
		// autofree_scope_vars(pos=35102 line_nr=987 scope.pos=35085 scope.end_pos=35170)
		// af parent scope:
		// var "c" var.pos=24699 var.line_nr=726
		// var "infix_expr" var.pos=24725 var.line_nr=726
		// var "former_expected_type" var.pos=24823 var.line_nr=728
		// var "left_type" var.pos=24917 var.line_nr=732
		// var "right_type" var.pos=25075 var.line_nr=736
		// var "right" var.pos=25214 var.line_nr=739
		// var "right_final" var.pos=25260 var.line_nr=740
		// var "left" var.pos=25322 var.line_nr=741
		// var "left_final" var.pos=25366 var.line_nr=742
		// var "left_pos" var.pos=25422 var.line_nr=743
		// var "right_pos" var.pos=25462 var.line_nr=744
		// var "left_right_pos" var.pos=25504 var.line_nr=745
		// var "return_type" var.pos=25942 var.line_nr=755
		// var "eq_ne" var.pos=26189 var.line_nr=766
		// var "left_is_optional" var.pos=39018 var.line_nr=1087
		// var "right_is_optional" var.pos=39069 var.line_nr=1088
		// af parent scope:
		// af parent scope:
		return _t1902;
	}
	else if (infix_expr->op == (v__token__Kind_key_is) || infix_expr->op == (v__token__Kind_not_is)) {
		v__ast__Expr right_expr = infix_expr->right;
		v__ast__Type _t1903;
		if (right_expr._typ == 279 /* v.ast.TypeNode */) {
			_t1903 = (*right_expr._v__ast__TypeNode).typ;
		}
		else if (right_expr._typ == 265 /* v.ast.None */) {
			_t1903 = _const_v__ast__none_type_idx;
		}
		else {
			v__checker__Checker_error(c, _STR("invalid type `%.*s\000`", 2, v__ast__Expr_str(right_expr)), v__ast__Expr_position(right_expr));
			_t1903 = ((v__ast__Type)(0));
		}		v__ast__Type typ = _t1903;
		v__ast__TypeSymbol* typ_sym = v__ast__Table_get_type_symbol(c->table, typ);
		string op = v__token__Kind_str(infix_expr->op);
		if (typ_sym->kind == v__ast__Kind_placeholder) {
			v__checker__Checker_error(c, _STR("%.*s\000: type `%.*s\000` does not exist", 3, op, typ_sym->name), v__ast__Expr_position(right_expr));
		}
		if (!(left->kind == v__ast__Kind_interface_ || left->kind == v__ast__Kind_sum_type)) {
			v__checker__Checker_error(c, _STR("`%.*s\000` can only be used with interfaces and sum types", 2, op), infix_expr->pos);
		} else if ((left->info)._typ == 411 /* v.ast.SumType */) {
			if (!(Array_v__ast__Type_contains((*left->info._v__ast__SumType).variants, typ))) {
				v__checker__Checker_error(c, _STR("`%.*s\000` has no variant `%.*s\000`", 3, left->name, right->name), infix_expr->pos);
			}
		}
		// Defer begin
		if (v__checker__Checker_infix_expr_defer_0 == true) {
			c->expected_type = former_expected_type;
		}
		// Defer end
		// autofree_scope_vars(pos=35945 line_nr=1015 scope.pos=35174 scope.end_pos=35969)
		// var "right_expr" var.pos=35196 var.line_nr=990
		// var "typ" var.pos=35234 var.line_nr=991
		// var "typ_sym" var.pos=35457 var.line_nr=1003
		// var "op" var.pos=35500 var.line_nr=1004
		// af parent scope:
		// var "c" var.pos=24699 var.line_nr=726
		// var "infix_expr" var.pos=24725 var.line_nr=726
		// var "former_expected_type" var.pos=24823 var.line_nr=728
		// var "left_type" var.pos=24917 var.line_nr=732
		// var "right_type" var.pos=25075 var.line_nr=736
		// var "right" var.pos=25214 var.line_nr=739
		// var "right_final" var.pos=25260 var.line_nr=740
		// var "left" var.pos=25322 var.line_nr=741
		// var "left_final" var.pos=25366 var.line_nr=742
		// var "left_pos" var.pos=25422 var.line_nr=743
		// var "right_pos" var.pos=25462 var.line_nr=744
		// var "left_right_pos" var.pos=25504 var.line_nr=745
		// var "return_type" var.pos=25942 var.line_nr=755
		// var "eq_ne" var.pos=26189 var.line_nr=766
		// var "left_is_optional" var.pos=39018 var.line_nr=1087
		// var "right_is_optional" var.pos=39069 var.line_nr=1088
		// af parent scope:
		// af parent scope:
		return _const_v__ast__bool_type;
	}
	else if (infix_expr->op == (v__token__Kind_arrow)) {
		if (left->kind == v__ast__Kind_chan) {
			v__ast__Chan chan_info = v__ast__TypeSymbol_chan_info(left);
			v__ast__Type elem_type = chan_info.elem_type;
			if (!v__checker__Checker_check_types(c, right_type, elem_type)) {
				v__checker__Checker_error(c, _STR("cannot push `%.*s\000` on `%.*s\000`", 3, right->name, left->name), right_pos);
			}
			if (chan_info.is_mut) {
				v__checker__Checker_fail_if_immutable(c, infix_expr->right);
			}
			if (v__ast__Type_is_ptr(elem_type) && !v__ast__Type_is_ptr(right_type)) {
				v__checker__Checker_error(c, _STR("cannot push non-reference `%.*s\000` on `%.*s\000`", 3, right->name, left->name), right_pos);
			}
			v__checker__Checker_stmts(c, infix_expr->or_block.stmts);
		} else {
			v__checker__Checker_error(c, _STR("cannot push on non-channel `%.*s\000`", 2, left->name), left_pos);
		}
		// Defer begin
		if (v__checker__Checker_infix_expr_defer_0 == true) {
			c->expected_type = former_expected_type;
		}
		// Defer end
		// autofree_scope_vars(pos=36640 line_nr=1036 scope.pos=35973 scope.end_pos=36664)
		// af parent scope:
		// var "c" var.pos=24699 var.line_nr=726
		// var "infix_expr" var.pos=24725 var.line_nr=726
		// var "former_expected_type" var.pos=24823 var.line_nr=728
		// var "left_type" var.pos=24917 var.line_nr=732
		// var "right_type" var.pos=25075 var.line_nr=736
		// var "right" var.pos=25214 var.line_nr=739
		// var "right_final" var.pos=25260 var.line_nr=740
		// var "left" var.pos=25322 var.line_nr=741
		// var "left_final" var.pos=25366 var.line_nr=742
		// var "left_pos" var.pos=25422 var.line_nr=743
		// var "right_pos" var.pos=25462 var.line_nr=744
		// var "left_right_pos" var.pos=25504 var.line_nr=745
		// var "return_type" var.pos=25942 var.line_nr=755
		// var "eq_ne" var.pos=26189 var.line_nr=766
		// var "left_is_optional" var.pos=39018 var.line_nr=1087
		// var "right_is_optional" var.pos=39069 var.line_nr=1088
		// af parent scope:
		// af parent scope:
		return _const_v__ast__void_type;
	}
	else if (infix_expr->op == (v__token__Kind_and) || infix_expr->op == (v__token__Kind_logical_or)) {
		if (infix_expr->left_type != _const_v__ast__bool_type_idx) {
			v__checker__Checker_error(c, _STR("left operand for `%.*s\000` is not a boolean", 2, v__token__Kind_str(infix_expr->op)), v__ast__Expr_position(infix_expr->left));
		}
		if (infix_expr->right_type != _const_v__ast__bool_type_idx) {
			v__checker__Checker_error(c, _STR("right operand for `%.*s\000` is not a boolean", 2, v__token__Kind_str(infix_expr->op)), v__ast__Expr_position(infix_expr->right));
		}
		if ((infix_expr->left)._typ == 258 /* v.ast.InfixExpr */) {
			if ((*infix_expr->left._v__ast__InfixExpr).op != infix_expr->op && ((*infix_expr->left._v__ast__InfixExpr).op == v__token__Kind_logical_or || (*infix_expr->left._v__ast__InfixExpr).op == v__token__Kind_and)) {
				v__checker__Checker_error(c, _SLIT("use `()` to make the boolean expression clear"), infix_expr->pos);
			}
		}
	}
	else {
	};
	if (v__ast__Type_alias_eq(left_type, _const_v__ast__bool_type) && !(infix_expr->op == v__token__Kind_eq || infix_expr->op == v__token__Kind_ne || infix_expr->op == v__token__Kind_logical_or || infix_expr->op == v__token__Kind_and)) {
		v__checker__Checker_error(c, _SLIT("bool types only have the following operators defined: `==`, `!=`, `||`, and `&&`"), infix_expr->pos);
	} else if (v__ast__Type_alias_eq(left_type, _const_v__ast__string_type) && !(infix_expr->op == v__token__Kind_plus || infix_expr->op == v__token__Kind_eq || infix_expr->op == v__token__Kind_ne || infix_expr->op == v__token__Kind_lt || infix_expr->op == v__token__Kind_gt || infix_expr->op == v__token__Kind_le || infix_expr->op == v__token__Kind_ge)) {
		v__checker__Checker_error(c, _SLIT("string types only have the following operators defined: `==`, `!=`, `<`, `>`, `<=`, `>=`, and `+`"), infix_expr->pos);
	} else if (left->kind == v__ast__Kind_enum_ && right->kind == v__ast__Kind_enum_ && !eq_ne) {
		v__ast__Enum left_enum = /* as */ *(v__ast__Enum*)__as_cast((left->info)._v__ast__Enum,(left->info)._typ, 420) /*expected idx: 420, name: v.ast.Enum */ ;
		v__ast__Enum right_enum = /* as */ *(v__ast__Enum*)__as_cast((right->info)._v__ast__Enum,(right->info)._typ, 420) /*expected idx: 420, name: v.ast.Enum */ ;
		if (left_enum.is_flag && right_enum.is_flag) {
			if (!(infix_expr->op == v__token__Kind_pipe || infix_expr->op == v__token__Kind_amp)) {
				v__checker__Checker_error(c, _SLIT("only `==`, `!=`, `|` and `&` are defined on `[flag]` tagged `enum`, use an explicit cast to `int` if needed"), infix_expr->pos);
			}
		} else {
			v__checker__Checker_error(c, _SLIT("only `==` and `!=` are defined on `enum`, use an explicit cast to `int` if needed"), infix_expr->pos);
		}
	}
	if (v__ast__Table_type_kind(c->table, left_type) == v__ast__Kind_sum_type && !eq_ne) {
		v__checker__Checker_error(c, _STR("cannot use operator `%.*s\000` with `%.*s\000`", 3, v__token__Kind_str(infix_expr->op), left->name), infix_expr->pos);
	} else if (v__ast__Table_type_kind(c->table, right_type) == v__ast__Kind_sum_type && !eq_ne) {
		v__checker__Checker_error(c, _STR("cannot use operator `%.*s\000` with `%.*s\000`", 3, v__token__Kind_str(infix_expr->op), right->name), infix_expr->pos);
	}
	bool left_is_optional = v__ast__Type_has_flag(left_type, v__ast__TypeFlag_optional);
	bool right_is_optional = v__ast__Type_has_flag(right_type, v__ast__TypeFlag_optional);
	if ((left_is_optional && !right_is_optional) || (!left_is_optional && right_is_optional)) {
		v__checker__Checker_error(c, _SLIT("unwrapped optional cannot be used in an infix expression"), left_right_pos);
	}
	if (!v__checker__Checker_symmetric_check(c, right_type, left_type) && !c->pref->translated) {
		if (v__ast__Type_alias_eq(left_type, _const_v__ast__void_type) || v__ast__Type_alias_eq(right_type, _const_v__ast__void_type)) {
			// Defer begin
			if (v__checker__Checker_infix_expr_defer_0 == true) {
				c->expected_type = former_expected_type;
			}
			// Defer end
			// autofree_scope_vars(pos=39513 line_nr=1096 scope.pos=39509 scope.end_pos=39537)
			// af parent scope:
			// af parent scope:
			// var "c" var.pos=24699 var.line_nr=726
			// var "infix_expr" var.pos=24725 var.line_nr=726
			// var "former_expected_type" var.pos=24823 var.line_nr=728
			// var "left_type" var.pos=24917 var.line_nr=732
			// var "right_type" var.pos=25075 var.line_nr=736
			// var "right" var.pos=25214 var.line_nr=739
			// var "right_final" var.pos=25260 var.line_nr=740
			// var "left" var.pos=25322 var.line_nr=741
			// var "left_final" var.pos=25366 var.line_nr=742
			// var "left_pos" var.pos=25422 var.line_nr=743
			// var "right_pos" var.pos=25462 var.line_nr=744
			// var "left_right_pos" var.pos=25504 var.line_nr=745
			// var "return_type" var.pos=25942 var.line_nr=755
			// var "eq_ne" var.pos=26189 var.line_nr=766
			// var "left_is_optional" var.pos=39018 var.line_nr=1087
			// var "right_is_optional" var.pos=39069 var.line_nr=1088
			// af parent scope:
			// af parent scope:
			return _const_v__ast__void_type;
		}
		if (v__ast__Type_nr_muls(left_type) > 0 && v__ast__Type_is_int(right_type)) {
			// Defer begin
			if (v__checker__Checker_infix_expr_defer_0 == true) {
				c->expected_type = former_expected_type;
			}
			// Defer end
			// autofree_scope_vars(pos=39659 line_nr=1100 scope.pos=39591 scope.end_pos=39681)
			// af parent scope:
			// af parent scope:
			// var "c" var.pos=24699 var.line_nr=726
			// var "infix_expr" var.pos=24725 var.line_nr=726
			// var "former_expected_type" var.pos=24823 var.line_nr=728
			// var "left_type" var.pos=24917 var.line_nr=732
			// var "right_type" var.pos=25075 var.line_nr=736
			// var "right" var.pos=25214 var.line_nr=739
			// var "right_final" var.pos=25260 var.line_nr=740
			// var "left" var.pos=25322 var.line_nr=741
			// var "left_final" var.pos=25366 var.line_nr=742
			// var "left_pos" var.pos=25422 var.line_nr=743
			// var "right_pos" var.pos=25462 var.line_nr=744
			// var "left_right_pos" var.pos=25504 var.line_nr=745
			// var "return_type" var.pos=25942 var.line_nr=755
			// var "eq_ne" var.pos=26189 var.line_nr=766
			// var "left_is_optional" var.pos=39018 var.line_nr=1087
			// var "right_is_optional" var.pos=39069 var.line_nr=1088
			// af parent scope:
			// af parent scope:
			return return_type;
		}
		v__checker__Checker_error(c, _STR("infix expr: cannot use `%.*s\000` (right expression) as `%.*s\000`", 3, right->name, left->name), left_right_pos);
	}
	// Defer begin
	if (v__checker__Checker_infix_expr_defer_0 == true) {
		c->expected_type = former_expected_type;
	}
	// Defer end
	 v__ast__Type _t1904 = (v__token__Kind_is_relational(infix_expr->op) ? (_const_v__ast__bool_type) : (return_type));
	// autofree_scope_vars(pos=40058 line_nr=1112 scope.pos=24694 scope.end_pos=40138)
	// var "c" var.pos=24699 var.line_nr=726
	// var "infix_expr" var.pos=24725 var.line_nr=726
	// var "former_expected_type" var.pos=24823 var.line_nr=728
	// var "left_type" var.pos=24917 var.line_nr=732
	// var "right_type" var.pos=25075 var.line_nr=736
	// var "right" var.pos=25214 var.line_nr=739
	// var "right_final" var.pos=25260 var.line_nr=740
	// var "left" var.pos=25322 var.line_nr=741
	// var "left_final" var.pos=25366 var.line_nr=742
	// var "left_pos" var.pos=25422 var.line_nr=743
	// var "right_pos" var.pos=25462 var.line_nr=744
	// var "left_right_pos" var.pos=25504 var.line_nr=745
	// var "return_type" var.pos=25942 var.line_nr=755
	// var "eq_ne" var.pos=26189 var.line_nr=766
	// var "left_is_optional" var.pos=39018 var.line_nr=1087
	// var "right_is_optional" var.pos=39069 var.line_nr=1088
	// af parent scope:
	// af parent scope:
	return _t1904;
}

VV_LOCAL_SYMBOL multi_return_string_v__token__Position v__checker__Checker_fail_if_immutable(v__checker__Checker* c, v__ast__Expr expr) {
	string to_lock = _SLIT("");
	v__token__Position pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,};
	bool explicit_lock_needed = false;
	if (expr._typ == 242 /* v.ast.CastExpr */) {
		return (multi_return_string_v__token__Position){.arg0=_SLIT(""), .arg1=pos};
	}
	else if (expr._typ == 247 /* v.ast.ComptimeSelector */) {
		return (multi_return_string_v__token__Position){.arg0=_SLIT(""), .arg1=pos};
	}
	else if (expr._typ == 254 /* v.ast.Ident */) {
		if (((*expr._v__ast__Ident).obj)._typ == 312 /* v.ast.Var */) {
			v__ast__Var v = /* as */ *(v__ast__Var*)__as_cast(((*expr._v__ast__Ident).obj)._v__ast__Var,((*expr._v__ast__Ident).obj)._typ, 312) /*expected idx: 312, name: v.ast.Var */ ;
			if (!v.is_mut && !c->pref->translated && !c->inside_unsafe) {
				v__checker__Checker_error(c, _STR("`%.*s\000` is immutable, declare it with `mut` to make it mutable", 2, (*expr._v__ast__Ident).name), (*expr._v__ast__Ident).pos);
			}
			v.is_changed = true;
			if (v__ast__Type_share(v.typ) == v__ast__ShareType_shared_t) {
				if (!(Array_string_contains(c->locked_names, (*expr._v__ast__Ident).name))) {
					if (c->locked_names.len > 0 || c->rlocked_names.len > 0) {
						if ((Array_string_contains(c->rlocked_names, (*expr._v__ast__Ident).name))) {
							v__checker__Checker_error(c, _STR("%.*s\000 has an `rlock` but needs a `lock`", 2, (*expr._v__ast__Ident).name), (*expr._v__ast__Ident).pos);
						} else {
							v__checker__Checker_error(c, _STR("%.*s\000 must be added to the `lock` list above", 2, (*expr._v__ast__Ident).name), (*expr._v__ast__Ident).pos);
						}
					}
					to_lock = (*expr._v__ast__Ident).name;
					pos = (*expr._v__ast__Ident).pos;
				}
			}
		} else if (((*expr._v__ast__Ident).obj)._typ == 310 /* v.ast.ConstField */ && (Array_string_contains(c->const_names, (*expr._v__ast__Ident).name))) {
			v__checker__Checker_error(c, _STR("cannot modify constant `%.*s\000`", 2, (*expr._v__ast__Ident).name), (*expr._v__ast__Ident).pos);
		}
	}
	else if (expr._typ == 257 /* v.ast.IndexExpr */) {
		v__ast__TypeSymbol* left_sym = v__ast__Table_get_type_symbol(c->table, (*expr._v__ast__IndexExpr).left_type);
		v__ast__Type elem_type = ((v__ast__Type)(0));
		string kind = _SLIT("");
		if (left_sym->info._typ == 395 /* v.ast.Array */) {
			elem_type = (*left_sym->info._v__ast__Array).elem_type;
			kind = _SLIT("array");
		}
		else if (left_sym->info._typ == 416 /* v.ast.ArrayFixed */) {
			elem_type = (*left_sym->info._v__ast__ArrayFixed).elem_type;
			kind = _SLIT("fixed array");
		}
		else if (left_sym->info._typ == 396 /* v.ast.Map */) {
			elem_type = (*left_sym->info._v__ast__Map).value_type;
			kind = _SLIT("map");
		}
		else {
		};
		if (v__ast__Type_has_flag(elem_type, v__ast__TypeFlag_shared_f)) {
			v__checker__Checker_error(c, _STR("you have to create a handle and `lock` it to modify `shared` %.*s\000 element", 2, kind), v__token__Position_extend(v__ast__Expr_position((*expr._v__ast__IndexExpr).left), (*expr._v__ast__IndexExpr).pos));
		}
		multi_return_string_v__token__Position mr_42060 = v__checker__Checker_fail_if_immutable(c, (*expr._v__ast__IndexExpr).left);
		to_lock = mr_42060.arg0;
		pos = mr_42060.arg1;
	}
	else if (expr._typ == 268 /* v.ast.ParExpr */) {
		multi_return_string_v__token__Position mr_42129 = v__checker__Checker_fail_if_immutable(c, (*expr._v__ast__ParExpr).expr);
		to_lock = mr_42129.arg0;
		pos = mr_42129.arg1;
	}
	else if (expr._typ == 270 /* v.ast.PrefixExpr */) {
		multi_return_string_v__token__Position mr_42201 = v__checker__Checker_fail_if_immutable(c, (*expr._v__ast__PrefixExpr).right);
		to_lock = mr_42201.arg0;
		pos = mr_42201.arg1;
	}
	else if (expr._typ == 273 /* v.ast.SelectorExpr */) {
		if ((*expr._v__ast__SelectorExpr).expr_type == 0) {
			return (multi_return_string_v__token__Position){.arg0=_SLIT(""), .arg1=pos};
		}
		Option_void _t1905 = v__checker__Checker_ensure_type_exists(c, (*expr._v__ast__SelectorExpr).expr_type, (*expr._v__ast__SelectorExpr).pos);
		if (_t1905.state != 0 && _t1905.err._typ != _IError_None___index) {
			IError err = _t1905.err;
			return (multi_return_string_v__token__Position){.arg0=_SLIT(""), .arg1=pos};
		};
		v__ast__TypeSymbol* typ_sym = v__ast__Table_get_final_type_symbol(c->table, v__checker__Checker_unwrap_generic(c, (*expr._v__ast__SelectorExpr).expr_type));

		if (typ_sym->kind == (v__ast__Kind_struct_)) {
			v__ast__Struct struct_info = /* as */ *(v__ast__Struct*)__as_cast((typ_sym->info)._v__ast__Struct,(typ_sym->info)._typ, 409) /*expected idx: 409, name: v.ast.Struct */ ;
			bool has_field = true;
			Option_v__ast__StructField _t1906 = v__ast__Struct_find_field(&struct_info, (*expr._v__ast__SelectorExpr).field_name);
			if (_t1906.state != 0) { /*or block*/ 
				IError err = _t1906.err;
				has_field = false;
				*(v__ast__StructField*) _t1906.data = (v__ast__StructField){.pos = {0},.type_pos = {0},.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.default_expr = {0},.has_default_expr = 0,.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.is_pub = 0,.default_val = (string){.str=(byteptr)"", .is_lit=1},.is_mut = 0,.is_global = 0,.default_expr_typ = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,};
			}
 			v__ast__StructField field_info =  *(v__ast__StructField*)_t1906.data;
			if (!has_field) {
				// FOR IN array
				for (int _t1907 = 0; _t1907 < struct_info.embeds.len; ++_t1907) {
					v__ast__Type embed = ((v__ast__Type*)struct_info.embeds.data)[_t1907];
					v__ast__TypeSymbol* embed_sym = v__ast__Table_get_type_symbol(c->table, embed);
					v__ast__Struct embed_struct_info = /* as */ *(v__ast__Struct*)__as_cast((embed_sym->info)._v__ast__Struct,(embed_sym->info)._typ, 409) /*expected idx: 409, name: v.ast.Struct */ ;
					Option_v__ast__StructField _t1908;
					if (_t1908 = v__ast__Struct_find_field(&embed_struct_info, (*expr._v__ast__SelectorExpr).field_name), _t1908.state == 0) {
						v__ast__StructField embed_field_info = *(v__ast__StructField*)_t1908.data;
						has_field = true;
						field_info = embed_field_info;
						break;
					}
				}
			}
			if (!has_field) {
				string type_str = v__ast__Table_type_to_str(c->table, (*expr._v__ast__SelectorExpr).expr_type);
				v__checker__Checker_error(c, _STR("unknown field `%.*s\000.%.*s\000`", 3, type_str, (*expr._v__ast__SelectorExpr).field_name), (*expr._v__ast__SelectorExpr).pos);
				return (multi_return_string_v__token__Position){.arg0=_SLIT(""), .arg1=pos};
			}
			if (!field_info.is_mut && !c->pref->translated) {
				string type_str = v__ast__Table_type_to_str(c->table, (*expr._v__ast__SelectorExpr).expr_type);
				v__checker__Checker_error(c, _STR("field `%.*s\000` of struct `%.*s\000` is immutable", 3, (*expr._v__ast__SelectorExpr).field_name, type_str), (*expr._v__ast__SelectorExpr).pos);
			}
			if (v__ast__Type_has_flag(field_info.typ, v__ast__TypeFlag_shared_f)) {
				string type_str = v__ast__Table_type_to_str(c->table, (*expr._v__ast__SelectorExpr).expr_type);
				v__checker__Checker_error(c, _STR("you have to create a handle and `lock` it to modify `shared` field `%.*s\000` of struct `%.*s\000`", 3, (*expr._v__ast__SelectorExpr).field_name, type_str), (*expr._v__ast__SelectorExpr).pos);
			}
			multi_return_string_v__token__Position mr_43722 = v__checker__Checker_fail_if_immutable(c, (*expr._v__ast__SelectorExpr).expr);
			to_lock = mr_43722.arg0;
			pos = mr_43722.arg1;
			if ((to_lock).len != 0) {
				explicit_lock_needed = true;
			}
		}
		else if (typ_sym->kind == (v__ast__Kind_interface_)) {
			v__ast__Interface interface_info = /* as */ *(v__ast__Interface*)__as_cast((typ_sym->info)._v__ast__Interface,(typ_sym->info)._typ, 410) /*expected idx: 410, name: v.ast.Interface */ ;
			Option_v__ast__StructField _t1909 = v__ast__Interface_find_field(&interface_info, (*expr._v__ast__SelectorExpr).field_name);
			if (_t1909.state != 0) { /*or block*/ 
				IError err = _t1909.err;
				string type_str = v__ast__Table_type_to_str(c->table, (*expr._v__ast__SelectorExpr).expr_type);
				v__checker__Checker_error(c, _STR("unknown field `%.*s\000.%.*s\000`", 3, type_str, (*expr._v__ast__SelectorExpr).field_name), (*expr._v__ast__SelectorExpr).pos);
				return (multi_return_string_v__token__Position){.arg0=_SLIT(""), .arg1=pos};
			}
 			v__ast__StructField field_info =  *(v__ast__StructField*)_t1909.data;
			if (!field_info.is_mut) {
				string type_str = v__ast__Table_type_to_str(c->table, (*expr._v__ast__SelectorExpr).expr_type);
				v__checker__Checker_error(c, _STR("field `%.*s\000` of interface `%.*s\000` is immutable", 3, (*expr._v__ast__SelectorExpr).field_name, type_str), (*expr._v__ast__SelectorExpr).pos);
			}
			v__checker__Checker_fail_if_immutable(c, (*expr._v__ast__SelectorExpr).expr);
		}
		else if (typ_sym->kind == (v__ast__Kind_array) || typ_sym->kind == (v__ast__Kind_string)) {
			if (!(string_eq(c->file->mod.name, _SLIT("builtin")) || string_eq(c->file->mod.name, _SLIT("crypto.rand")))) {
				v__checker__Checker_error(c, _STR("`%.*s\000` can not be modified", 2, v__ast__Kind_str(typ_sym->kind)), (*expr._v__ast__SelectorExpr).pos);
			}
		}
		else if (typ_sym->kind == (v__ast__Kind_aggregate)) {
			v__checker__Checker_fail_if_immutable(c, (*expr._v__ast__SelectorExpr).expr);
		}
		else {
			v__checker__Checker_error(c, _STR("unexpected symbol `%.*s\000`", 2, v__ast__Kind_str(typ_sym->kind)), (*expr._v__ast__SelectorExpr).pos);
		};
	}
	else if (expr._typ == 241 /* v.ast.CallExpr */) {
		if (string_eq((*expr._v__ast__CallExpr).name, _SLIT("slice"))) {
			multi_return_string_v__token__Position mr_45008 = v__checker__Checker_fail_if_immutable(c, (*expr._v__ast__CallExpr).left);
			to_lock = mr_45008.arg0;
			pos = mr_45008.arg1;
			if ((to_lock).len != 0) {
				explicit_lock_needed = true;
			}
		}
	}
	else if (expr._typ == 235 /* v.ast.ArrayInit */) {
		v__checker__Checker_error(c, _SLIT("array literal can not be modified"), (*expr._v__ast__ArrayInit).pos);
		return (multi_return_string_v__token__Position){.arg0=_SLIT(""), .arg1=pos};
	}
	else if (expr._typ == 278 /* v.ast.StructInit */) {
		return (multi_return_string_v__token__Position){.arg0=_SLIT(""), .arg1=pos};
	}
	else {
		v__checker__Checker_error(c, _STR("unexpected expression `%.*s\000`", 2, tos3( /* v.ast.Expr */ v_typeof_sumtype_v__ast__Expr( (expr)._typ ))), v__ast__Expr_position(expr));
	};
	if (explicit_lock_needed) {
		v__checker__Checker_error(c, _STR("`%.*s\000` is `shared` and needs explicit lock for `%.*s\000`", 3, to_lock, tos3( /* v.ast.Expr */ v_typeof_sumtype_v__ast__Expr( (expr)._typ ))), pos);
		to_lock = _SLIT("");
	}
	return (multi_return_string_v__token__Position){.arg0=to_lock, .arg1=pos};
}

v__ast__Type v__checker__Checker_call_expr(v__checker__Checker* c, v__ast__CallExpr* call_expr) {
	v__ast__Type typ = (call_expr->is_method ? (v__checker__Checker_method_call(c, call_expr)) : (v__checker__Checker_fn_call(c, call_expr)));
	bool free_tmp_arg_vars = c->pref->autofree && !c->is_builtin_mod && call_expr->args.len > 0 && !v__ast__Type_has_flag((*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr->args, 0)).typ, v__ast__TypeFlag_optional);
	if (free_tmp_arg_vars && !c->inside_const) {
		// FOR IN array
		for (int i = 0; i < call_expr->args.len; ++i) {
			v__ast__CallArg arg = ((v__ast__CallArg*)call_expr->args.data)[i];
			if (!v__ast__Type_alias_eq(arg.typ, _const_v__ast__string_type)) {
				continue;
			}
			if ((arg.expr)._typ == 254 /* v.ast.Ident */ || (arg.expr)._typ == 277 /* v.ast.StringLiteral */ || (arg.expr)._typ == 273 /* v.ast.SelectorExpr */) {
				continue;
			}
			(*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr->args, i)).is_tmp_autofree = true;
		}
		if (v__ast__Type_alias_eq(call_expr->receiver_type, _const_v__ast__string_type) && !((call_expr->left)._typ == 254 /* v.ast.Ident */ || (call_expr->left)._typ == 277 /* v.ast.StringLiteral */ || (call_expr->left)._typ == 273 /* v.ast.SelectorExpr */)) {
			call_expr->free_receiver = true;
		}
	}
	c->expected_or_type = v__ast__Type_clear_flag(call_expr->return_type, v__ast__TypeFlag_optional);
	v__checker__Checker_stmts(c, call_expr->or_block.stmts);
	c->expected_or_type = _const_v__ast__void_type;
	if (call_expr->or_block.kind == v__ast__OrKind_propagate && !v__ast__Type_has_flag(c->cur_fn->return_type, v__ast__TypeFlag_optional) && !c->inside_const) {
		if (!c->cur_fn->is_main) {
			v__checker__Checker_error(c, _STR("to propagate the optional call, `%.*s\000` must return an optional", 2, c->cur_fn->name), call_expr->or_block.pos);
		}
	}
	// autofree_scope_vars(pos=47954 line_nr=1350 scope.pos=45561 scope.end_pos=47966)
	// var "c" var.pos=45566 var.line_nr=1290
	// var "call_expr" var.pos=45591 var.line_nr=1290
	// var "typ" var.pos=46475 var.line_nr=1314
	// var "free_tmp_arg_vars" var.pos=46652 var.line_nr=1316
	// af parent scope:
	// af parent scope:
	return typ;
}

VV_LOCAL_SYMBOL void v__checker__Checker_check_map_and_filter(v__checker__Checker* c, bool is_map, v__ast__Type elem_typ, v__ast__CallExpr call_expr) {
	if (call_expr.args.len != 1) {
		v__checker__Checker_error(c, _STR("expected 1 argument, but got %"PRId32"", 1, call_expr.args.len), call_expr.pos);
		return;
	}
	v__ast__TypeSymbol* elem_sym = v__ast__Table_get_type_symbol(c->table, elem_typ);
	v__ast__Expr arg_expr = (*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr.args, 0)).expr;
	if (arg_expr._typ == 233 /* v.ast.AnonFn */) {
		if ((*arg_expr._v__ast__AnonFn).decl.params.len > 1) {
			v__checker__Checker_error(c, _SLIT("function needs exactly 1 argument"), (*arg_expr._v__ast__AnonFn).decl.pos);
		} else if (is_map && (v__ast__Type_alias_eq((*arg_expr._v__ast__AnonFn).decl.return_type, _const_v__ast__void_type) || !v__ast__Type_alias_eq((*(v__ast__Param*)/*ee elem_typ */array_get((*arg_expr._v__ast__AnonFn).decl.params, 0)).typ, elem_typ))) {
			v__checker__Checker_error(c, _STR("type mismatch, should use `fn(a %.*s\000) T {...}`", 2, elem_sym->name), (*arg_expr._v__ast__AnonFn).decl.pos);
		} else if (!is_map && (!v__ast__Type_alias_eq((*arg_expr._v__ast__AnonFn).decl.return_type, _const_v__ast__bool_type) || !v__ast__Type_alias_eq((*(v__ast__Param*)/*ee elem_typ */array_get((*arg_expr._v__ast__AnonFn).decl.params, 0)).typ, elem_typ))) {
			v__checker__Checker_error(c, _STR("type mismatch, should use `fn(a %.*s\000) bool {...}`", 2, elem_sym->name), (*arg_expr._v__ast__AnonFn).decl.pos);
		}
	}
	else if (arg_expr._typ == 254 /* v.ast.Ident */) {
		if ((*arg_expr._v__ast__Ident).kind == v__ast__IdentKind_function) {
			Option_v__ast__Fn _t1910 = v__ast__Table_find_fn(c->table, (*arg_expr._v__ast__Ident).name);
			if (_t1910.state != 0) { /*or block*/ 
				IError err = _t1910.err;
				v__checker__Checker_error(c, _STR("%.*s\000 does not exist", 2, (*arg_expr._v__ast__Ident).name), (*arg_expr._v__ast__Ident).pos);
				return;
			}
 			v__ast__Fn func =  *(v__ast__Fn*)_t1910.data;
			if (func.params.len > 1) {
				v__checker__Checker_error(c, _SLIT("function needs exactly 1 argument"), call_expr.pos);
			} else if (is_map && (v__ast__Type_alias_eq(func.return_type, _const_v__ast__void_type) || !v__ast__Type_alias_eq((*(v__ast__Param*)/*ee elem_typ */array_get(func.params, 0)).typ, elem_typ))) {
				v__checker__Checker_error(c, _STR("type mismatch, should use `fn(a %.*s\000) T {...}`", 2, elem_sym->name), (*arg_expr._v__ast__Ident).pos);
			} else if (!is_map && (!v__ast__Type_alias_eq(func.return_type, _const_v__ast__bool_type) || !v__ast__Type_alias_eq((*(v__ast__Param*)/*ee elem_typ */array_get(func.params, 0)).typ, elem_typ))) {
				v__checker__Checker_error(c, _STR("type mismatch, should use `fn(a %.*s\000) bool {...}`", 2, elem_sym->name), (*arg_expr._v__ast__Ident).pos);
			}
		} else if ((*arg_expr._v__ast__Ident).kind == v__ast__IdentKind_variable) {
			if (((*arg_expr._v__ast__Ident).obj)._typ == 312 /* v.ast.Var */) {
				v__ast__Expr expr = (*(*arg_expr._v__ast__Ident).obj._v__ast__Var).expr;
				if ((expr)._typ == 233 /* v.ast.AnonFn */) {
					if ((*expr._v__ast__AnonFn).decl.params.len > 1) {
						v__checker__Checker_error(c, _SLIT("function needs exactly 1 argument"), (*expr._v__ast__AnonFn).decl.pos);
					} else if (is_map && (v__ast__Type_alias_eq((*expr._v__ast__AnonFn).decl.return_type, _const_v__ast__void_type) || !v__ast__Type_alias_eq((*(v__ast__Param*)/*ee elem_typ */array_get((*expr._v__ast__AnonFn).decl.params, 0)).typ, elem_typ))) {
						v__checker__Checker_error(c, _STR("type mismatch, should use `fn(a %.*s\000) T {...}`", 2, elem_sym->name), (*expr._v__ast__AnonFn).decl.pos);
					} else if (!is_map && (!v__ast__Type_alias_eq((*expr._v__ast__AnonFn).decl.return_type, _const_v__ast__bool_type) || !v__ast__Type_alias_eq((*(v__ast__Param*)/*ee elem_typ */array_get((*expr._v__ast__AnonFn).decl.params, 0)).typ, elem_typ))) {
						v__checker__Checker_error(c, _STR("type mismatch, should use `fn(a %.*s\000) bool {...}`", 2, elem_sym->name), (*expr._v__ast__AnonFn).decl.pos);
					}
					return;
				}
			}
			if (!is_map && !v__ast__Type_alias_eq((*((*arg_expr._v__ast__Ident).info.typ)), _const_v__ast__bool_type)) {
				v__checker__Checker_error(c, _SLIT("type mismatch, should be bool"), (*arg_expr._v__ast__Ident).pos);
			}
		}
	}
	else if (arg_expr._typ == 241 /* v.ast.CallExpr */) {
		if (is_map && v__ast__Type_alias_eq((*arg_expr._v__ast__CallExpr).return_type, _const_v__ast__void_type)) {
			v__checker__Checker_error(c, _STR("type mismatch, `%.*s\000` does not return anything", 2, (*arg_expr._v__ast__CallExpr).name), (*arg_expr._v__ast__CallExpr).pos);
		} else if (!is_map && !v__ast__Type_alias_eq((*arg_expr._v__ast__CallExpr).return_type, _const_v__ast__bool_type)) {
			v__checker__Checker_error(c, _STR("type mismatch, `%.*s\000` must return a bool", 2, (*arg_expr._v__ast__CallExpr).name), (*arg_expr._v__ast__CallExpr).pos);
		}
	}
	else {
	};
}

VV_LOCAL_SYMBOL void v__checker__Checker_check_return_generics_struct(v__checker__Checker* c, v__ast__Type return_type, v__ast__CallExpr* call_expr, Array_v__ast__Type generic_types) {
	v__ast__TypeSymbol* rts = v__ast__Table_get_type_symbol(c->table, return_type);
	if ((rts->info)._typ == 409 /* v.ast.Struct */) {
		if ((*rts->info._v__ast__Struct).generic_types.len > 0) {
			v__ast__TypeSymbol* gts = v__ast__Table_get_type_symbol(c->table, (*(v__ast__Type*)/*ee elem_typ */array_get(call_expr->generic_types, 0)));
			string nrt = _STR("%.*s\000<%.*s\000>", 3, rts->name, gts->name);
			string c_nrt = _STR("%.*s\000_T_%.*s", 2, rts->name, gts->name);
			int idx = (*(int*)map_get(ADDR(map, c->table->type_idxs), &(string[]){nrt}, &(int[]){ 0 }));
			if (idx != 0) {
				Option_void _t1911 = v__checker__Checker_ensure_type_exists(c, idx, call_expr->pos);
				if (_t1911.state != 0 && _t1911.err._typ != _IError_None___index) {
					IError err = _t1911.err;
				};
				call_expr->return_type = v__ast__Type_derive(v__ast__new_type(idx), return_type);
			} else {
				Array_v__ast__StructField fields = array_clone(&(*rts->info._v__ast__Struct).fields);
				if ((*rts->info._v__ast__Struct).generic_types.len == generic_types.len) {
					// FOR IN array
					for (int i = 0; i < fields.len; ++i) {
						Option_v__ast__Type _t1912;
						if (_t1912 = v__ast__Table_resolve_generic_by_types(c->table, (*(v__ast__StructField*)/*ee elem_typ */array_get(fields, i)).typ, (*rts->info._v__ast__Struct).generic_types, generic_types), _t1912.state == 0) {
							v__ast__Type t_typ = *(v__ast__Type*)_t1912.data;
							(*(v__ast__StructField*)/*ee elem_typ */array_get(fields, i)).typ = t_typ;
						}
					}
					v__ast__Struct info = (*rts->info._v__ast__Struct);
					info.generic_types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
					info.concrete_types = array_clone(&generic_types);
					info.parent_type = return_type;
					info.fields = fields;
					int stru_idx = v__ast__Table_register_type_symbol(c->table, (v__ast__TypeSymbol){.parent_idx = 0,.info = v__ast__Struct_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__Struct, (info))),.kind = v__ast__Kind_struct_,.name = nrt,.cname = v__util__no_dots(c_nrt),.methods = __new_array(0, 1, sizeof(v__ast__Fn)),.mod = c->mod,.is_public = 0,.language = 0,});
					call_expr->return_type = v__ast__new_type(stru_idx);
				}
			}
		}
	}
}

v__ast__Type v__checker__Checker_method_call(v__checker__Checker* c, v__ast__CallExpr* call_expr) {
	v__ast__Type left_type = v__checker__Checker_expr(c, call_expr->left);
	c->expected_type = left_type;
	bool is_generic = v__ast__Type_has_flag(left_type, v__ast__TypeFlag_generic);
	call_expr->left_type = left_type;
	call_expr->return_type = left_type;
	call_expr->receiver_type = left_type;
	v__ast__TypeSymbol* left_type_sym = v__ast__Table_get_type_symbol(c->table, v__checker__Checker_unwrap_generic(c, left_type));
	string method_name = call_expr->name;
	string unknown_method_msg = _STR("unknown method: `%.*s\000.%.*s\000`", 3, left_type_sym->name, method_name);
	if (v__ast__Type_has_flag(left_type, v__ast__TypeFlag_optional)) {
		v__checker__Checker_error(c, _SLIT("optional type cannot be called directly"), v__ast__Expr_position(call_expr->left));
		// autofree_scope_vars(pos=52712 line_nr=1480 scope.pos=52629 scope.end_pos=52735)
		// af parent scope:
		// var "c" var.pos=52007 var.line_nr=1466
		// var "call_expr" var.pos=52034 var.line_nr=1466
		// var "left_type" var.pos=52070 var.line_nr=1467
		// var "is_generic" var.pos=52140 var.line_nr=1469
		// var "left_type_sym" var.pos=52412 var.line_nr=1475
		// var "method_name" var.pos=52483 var.line_nr=1476
		// var "unknown_method_msg" var.pos=52518 var.line_nr=1477
		// var "has_generic_generic" var.pos=52853 var.line_nr=1485
		// var "generic_types" var.pos=52925 var.line_nr=1486
		// var "method" var.pos=54692 var.line_nr=1529
		// var "has_method" var.pos=54716 var.line_nr=1530
		// var "is_method_from_embed" var.pos=54741 var.line_nr=1531
		// af parent scope:
		// af parent scope:
		return _const_v__ast__void_type;
	}
	if ((left_type_sym->kind == v__ast__Kind_sum_type || left_type_sym->kind == v__ast__Kind_interface_) && string_eq(method_name, _SLIT("type_name"))) {
		// autofree_scope_vars(pos=52821 line_nr=1483 scope.pos=52818 scope.end_pos=52846)
		// af parent scope:
		// var "c" var.pos=52007 var.line_nr=1466
		// var "call_expr" var.pos=52034 var.line_nr=1466
		// var "left_type" var.pos=52070 var.line_nr=1467
		// var "is_generic" var.pos=52140 var.line_nr=1469
		// var "left_type_sym" var.pos=52412 var.line_nr=1475
		// var "method_name" var.pos=52483 var.line_nr=1476
		// var "unknown_method_msg" var.pos=52518 var.line_nr=1477
		// var "has_generic_generic" var.pos=52853 var.line_nr=1485
		// var "generic_types" var.pos=52925 var.line_nr=1486
		// var "method" var.pos=54692 var.line_nr=1529
		// var "has_method" var.pos=54716 var.line_nr=1530
		// var "is_method_from_embed" var.pos=54741 var.line_nr=1531
		// af parent scope:
		// af parent scope:
		return _const_v__ast__string_type;
	}
	bool has_generic_generic = false;
	Array_v__ast__Type generic_types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
	// FOR IN array
	for (int _t1913 = 0; _t1913 < call_expr->generic_types.len; ++_t1913) {
		v__ast__Type generic_type = ((v__ast__Type*)call_expr->generic_types.data)[_t1913];
		if (v__ast__Type_has_flag(generic_type, v__ast__TypeFlag_generic)) {
			has_generic_generic = true;
			array_push(&generic_types, _MOV((v__ast__Type[]){ v__checker__Checker_unwrap_generic(c, generic_type) }));
		} else {
			array_push(&generic_types, _MOV((v__ast__Type[]){ generic_type }));
		}
	}
	if (has_generic_generic) {
		if ((c->mod).len != 0) {
			v__ast__Table_register_fn_gen_type(c->table, string_add(string_add(c->mod, _SLIT(".")), call_expr->name), generic_types);
		} else {
			v__ast__Table_register_fn_gen_type(c->table, call_expr->name, generic_types);
		}
	}
	if (left_type_sym->kind == v__ast__Kind_array && (Array_string_contains(_const_v__checker__array_builtin_methods, method_name))) {
		 v__ast__Type _t1916 = v__checker__Checker_array_builtin_method_call(c, call_expr, left_type, *left_type_sym);
		// autofree_scope_vars(pos=53652 line_nr=1506 scope.pos=53649 scope.end_pos=53730)
		// af parent scope:
		// var "c" var.pos=52007 var.line_nr=1466
		// var "call_expr" var.pos=52034 var.line_nr=1466
		// var "left_type" var.pos=52070 var.line_nr=1467
		// var "is_generic" var.pos=52140 var.line_nr=1469
		// var "left_type_sym" var.pos=52412 var.line_nr=1475
		// var "method_name" var.pos=52483 var.line_nr=1476
		// var "unknown_method_msg" var.pos=52518 var.line_nr=1477
		// var "has_generic_generic" var.pos=52853 var.line_nr=1485
		// var "generic_types" var.pos=52925 var.line_nr=1486
		// var "method" var.pos=54692 var.line_nr=1529
		// var "has_method" var.pos=54716 var.line_nr=1530
		// var "is_method_from_embed" var.pos=54741 var.line_nr=1531
		// af parent scope:
		// af parent scope:
		return _t1916;
	} else if (left_type_sym->kind == v__ast__Kind_map && (string_eq(method_name, _SLIT("clone")) || string_eq(method_name, _SLIT("keys")) || string_eq(method_name, _SLIT("move")) || string_eq(method_name, _SLIT("delete")))) {
		 v__ast__Type _t1917 = v__checker__Checker_map_builtin_method_call(c, call_expr, left_type, *left_type_sym);
		// autofree_scope_vars(pos=53824 line_nr=1508 scope.pos=53821 scope.end_pos=53900)
		// af parent scope:
		// var "c" var.pos=52007 var.line_nr=1466
		// var "call_expr" var.pos=52034 var.line_nr=1466
		// var "left_type" var.pos=52070 var.line_nr=1467
		// var "is_generic" var.pos=52140 var.line_nr=1469
		// var "left_type_sym" var.pos=52412 var.line_nr=1475
		// var "method_name" var.pos=52483 var.line_nr=1476
		// var "unknown_method_msg" var.pos=52518 var.line_nr=1477
		// var "has_generic_generic" var.pos=52853 var.line_nr=1485
		// var "generic_types" var.pos=52925 var.line_nr=1486
		// var "method" var.pos=54692 var.line_nr=1529
		// var "has_method" var.pos=54716 var.line_nr=1530
		// var "is_method_from_embed" var.pos=54741 var.line_nr=1531
		// af parent scope:
		// af parent scope:
		return _t1917;
	} else if (left_type_sym->kind == v__ast__Kind_array && (string_eq(method_name, _SLIT("insert")) || string_eq(method_name, _SLIT("prepend")))) {
		v__ast__Array info = /* as */ *(v__ast__Array*)__as_cast((left_type_sym->info)._v__ast__Array,(left_type_sym->info)._typ, 395) /*expected idx: 395, name: v.ast.Array */ ;
		v__ast__Expr arg_expr = (string_eq(method_name, _SLIT("insert")) ? ((*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr->args, 1)).expr) : ((*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr->args, 0)).expr));
		v__ast__Type arg_type = v__checker__Checker_expr(c, arg_expr);
		v__ast__TypeSymbol* arg_sym = v__ast__Table_get_type_symbol(c->table, arg_type);
		if (!v__checker__Checker_check_types(c, arg_type, info.elem_type) && !v__checker__Checker_check_types(c, left_type, arg_type)) {
			v__checker__Checker_error(c, _STR("cannot %.*s\000 `%.*s\000` to `%.*s\000`", 4, method_name, arg_sym->name, left_type_sym->name), v__ast__Expr_position(arg_expr));
		}
	} else if (left_type_sym->kind == v__ast__Kind_thread && string_eq(method_name, _SLIT("wait"))) {
		v__ast__Thread info = /* as */ *(v__ast__Thread*)__as_cast((left_type_sym->info)._v__ast__Thread,(left_type_sym->info)._typ, 415) /*expected idx: 415, name: v.ast.Thread */ ;
		if (call_expr->args.len > 0) {
			v__checker__Checker_error(c, _SLIT("wait() does not have any arguments"), (*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr->args, 0)).pos);
		}
		call_expr->return_type = info.return_type;
		 v__ast__Type _t1918 = info.return_type;
		// autofree_scope_vars(pos=54659 line_nr=1527 scope.pos=54464 scope.end_pos=54685)
		// var "info" var.pos=54468 var.line_nr=1522
		// af parent scope:
		// var "c" var.pos=52007 var.line_nr=1466
		// var "call_expr" var.pos=52034 var.line_nr=1466
		// var "left_type" var.pos=52070 var.line_nr=1467
		// var "is_generic" var.pos=52140 var.line_nr=1469
		// var "left_type_sym" var.pos=52412 var.line_nr=1475
		// var "method_name" var.pos=52483 var.line_nr=1476
		// var "unknown_method_msg" var.pos=52518 var.line_nr=1477
		// var "has_generic_generic" var.pos=52853 var.line_nr=1485
		// var "generic_types" var.pos=52925 var.line_nr=1486
		// var "method" var.pos=54692 var.line_nr=1529
		// var "has_method" var.pos=54716 var.line_nr=1530
		// var "is_method_from_embed" var.pos=54741 var.line_nr=1531
		// af parent scope:
		// af parent scope:
		return _t1918;
	}
	v__ast__Fn method = (v__ast__Fn){.params = __new_array(0, 1, sizeof(v__ast__Param)),.return_type = 0,.is_variadic = 0,.language = 0,.generic_names = __new_array(0, 1, sizeof(string)),.is_pub = 0,.is_deprecated = 0,.is_unsafe = 0,.is_placeholder = 0,.is_main = 0,.is_test = 0,.is_conditional = 0,.is_keep_alive = 0,.no_body = 0,.mod = (string){.str=(byteptr)"", .is_lit=1},.ctdefine = (string){.str=(byteptr)"", .is_lit=1},.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.name = (string){.str=(byteptr)"", .is_lit=1},.source_fn = 0,.usages = 0,};
	bool has_method = false;
	bool is_method_from_embed = false;
	Option_v__ast__Fn _t1919;
	if (_t1919 = v__ast__Table_type_find_method(c->table, left_type_sym, method_name), _t1919.state == 0) {
		v__ast__Fn m = *(v__ast__Fn*)_t1919.data;
		method = m;
		has_method = true;
	} else {
		IError err = _t1919.err;
		if ((left_type_sym->info)._typ == 409 /* v.ast.Struct */) {
			if ((*left_type_sym->info._v__ast__Struct).parent_type != 0) {
				v__ast__TypeSymbol* type_sym = v__ast__Table_get_type_symbol(c->table, (*left_type_sym->info._v__ast__Struct).parent_type);
				Option_v__ast__Fn _t1920;
				if (_t1920 = v__ast__Table_type_find_method(c->table, type_sym, method_name), _t1920.state == 0) {
					v__ast__Fn m = *(v__ast__Fn*)_t1920.data;
					method = m;
					has_method = true;
					is_generic = true;
				}
			} else {
				Array_v__ast__Fn found_methods = __new_array_with_default(0, 0, sizeof(v__ast__Fn), 0);
				Array_v__ast__Type embed_of_found_methods = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
				// FOR IN array
				for (int _t1921 = 0; _t1921 < (*left_type_sym->info._v__ast__Struct).embeds.len; ++_t1921) {
					v__ast__Type embed = ((v__ast__Type*)(*left_type_sym->info._v__ast__Struct).embeds.data)[_t1921];
					v__ast__TypeSymbol* embed_sym = v__ast__Table_get_type_symbol(c->table, embed);
					Option_v__ast__Fn _t1922;
					if (_t1922 = v__ast__Table_type_find_method(c->table, embed_sym, method_name), _t1922.state == 0) {
						v__ast__Fn m = *(v__ast__Fn*)_t1922.data;
						array_push(&found_methods, _MOV((v__ast__Fn[]){ m }));
						array_push(&embed_of_found_methods, _MOV((v__ast__Type[]){ embed }));
					}
				}
				if (found_methods.len == 1) {
					method = (*(v__ast__Fn*)/*ee elem_typ */array_get(found_methods, 0));
					has_method = true;
					is_method_from_embed = true;
					call_expr->from_embed_type = (*(v__ast__Type*)/*ee elem_typ */array_get(embed_of_found_methods, 0));
				} else if (found_methods.len > 1) {
					v__checker__Checker_error(c, _STR("ambiguous method `%.*s\000`", 2, method_name), call_expr->pos);
				}
			}
		}
		if (left_type_sym->kind == v__ast__Kind_aggregate) {
			unknown_method_msg = (*(err.msg));
		}
	}
	if (has_method) {
		if (!method.is_pub && !c->pref->is_test && string_ne(method.mod, c->mod)) {
			v__checker__Checker_error(c, _STR("method `%.*s\000.%.*s\000` is private", 3, left_type_sym->name, method_name), call_expr->pos);
		}
		v__ast__ShareType rec_share = v__ast__Type_share((*(v__ast__Param*)/*ee elem_typ */array_get(method.params, 0)).typ);
		if (rec_share == v__ast__ShareType_shared_t && (c->locked_names.len > 0 || c->rlocked_names.len > 0)) {
			v__checker__Checker_error(c, _SLIT("method with `shared` receiver cannot be called inside `lock`/`rlock` block"), call_expr->pos);
		}
		if ((*(v__ast__Param*)/*ee elem_typ */array_get(method.params, 0)).is_mut) {
			multi_return_string_v__token__Position mr_56651 = v__checker__Checker_fail_if_immutable(c, call_expr->left);
			string to_lock = mr_56651.arg0;
			v__token__Position pos = mr_56651.arg1;
			if ((to_lock).len != 0 && rec_share != v__ast__ShareType_shared_t) {
				v__checker__Checker_error(c, _STR("%.*s\000 is `shared` and must be `lock`ed to be passed as `mut`", 2, to_lock), pos);
			}
		} else {
			v__checker__Checker_fail_if_unreadable(c, call_expr->left, left_type, _SLIT("receiver"));
		}
		if ((!v__ast__TypeSymbol_is_builtin(left_type_sym) && string_ne(method.mod, _SLIT("builtin"))) && method.language == v__ast__Language_v && method.no_body) {
			v__checker__Checker_error(c, _SLIT("cannot call a method that does not have a body"), call_expr->pos);
		}
		if (v__ast__Type_alias_eq(method.return_type, _const_v__ast__void_type) && method.ctdefine.len > 0 && !(Array_string_contains(c->pref->compile_defines, method.ctdefine))) {
			call_expr->should_be_skipped = true;
		}
		int nr_args = (method.params.len == 0 ? (0) : (method.params.len - 1));
		int min_required_args = method.params.len - (method.is_variadic && method.params.len > 1 ? (2) : (1));
		if (call_expr->args.len < min_required_args) {
			v__checker__Checker_error(c, _STR("expected %"PRId32"\000 arguments, but got %"PRId32"", 2, min_required_args, call_expr->args.len), call_expr->pos);
		} else if (!method.is_variadic && call_expr->args.len > nr_args) {
			Array_v__ast__CallArg unexpected_arguments = array_slice(call_expr->args, min_required_args, call_expr->args.len);
			v__token__Position unexpected_arguments_pos = v__token__Position_extend((*(v__ast__CallArg*)/*ee elem_typ */array_get(unexpected_arguments, 0)).pos, (*(v__ast__CallArg*)array_last(unexpected_arguments)).pos);
			v__checker__Checker_error(c, _STR("expected %"PRId32"\000 arguments, but got %"PRId32"", 2, nr_args, call_expr->args.len), unexpected_arguments_pos);
			 v__ast__Type _t1925 = method.return_type;
			// autofree_scope_vars(pos=57957 line_nr=1613 scope.pos=57694 scope.end_pos=57986)
			// var "unexpected_arguments" var.pos=57699 var.line_nr=1610
			// var "unexpected_arguments_pos" var.pos=57762 var.line_nr=1611
			// af parent scope:
			// var "rec_share" var.pos=56365 var.line_nr=1577
			// var "nr_args" var.pos=57293 var.line_nr=1600
			// var "min_required_args" var.pos=57369 var.line_nr=1601
			// af parent scope:
			// var "c" var.pos=52007 var.line_nr=1466
			// var "call_expr" var.pos=52034 var.line_nr=1466
			// var "left_type" var.pos=52070 var.line_nr=1467
			// var "is_generic" var.pos=52140 var.line_nr=1469
			// var "left_type_sym" var.pos=52412 var.line_nr=1475
			// var "method_name" var.pos=52483 var.line_nr=1476
			// var "unknown_method_msg" var.pos=52518 var.line_nr=1477
			// var "has_generic_generic" var.pos=52853 var.line_nr=1485
			// var "generic_types" var.pos=52925 var.line_nr=1486
			// var "method" var.pos=54692 var.line_nr=1529
			// var "has_method" var.pos=54716 var.line_nr=1530
			// var "is_method_from_embed" var.pos=54741 var.line_nr=1531
			// af parent scope:
			// af parent scope:
			return _t1925;
		}
		if (method.generic_names.len > 0 && v__ast__Type_has_flag(method.return_type, v__ast__TypeFlag_generic)) {
			v__checker__Checker_check_return_generics_struct(c, method.return_type, call_expr, generic_types);
		} else {
			call_expr->return_type = method.return_type;
		}
		// FOR IN array
		for (int i = 0; i < call_expr->args.len; ++i) {
			v__ast__CallArg arg = ((v__ast__CallArg*)call_expr->args.data)[i];
			v__ast__Type exp_arg_typ = (method.is_variadic && i >= method.params.len - 1 ? ((*(v__ast__Param*)/*ee elem_typ */array_get(method.params, method.params.len - 1)).typ) : ((*(v__ast__Param*)/*ee elem_typ */array_get(method.params, i + 1)).typ));
			v__ast__TypeSymbol* exp_arg_sym = v__ast__Table_get_type_symbol(c->table, exp_arg_typ);
			c->expected_type = exp_arg_typ;
			v__ast__Type got_arg_typ = v__checker__Checker_check_expr_opt_call(c, arg.expr, v__checker__Checker_expr(c, arg.expr));
			(*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr->args, i)).typ = got_arg_typ;
			if (method.is_variadic && v__ast__Type_has_flag(got_arg_typ, v__ast__TypeFlag_variadic) && call_expr->args.len - 1 > i) {
				v__checker__Checker_error(c, _SLIT("when forwarding a variadic variable, it must be the final argument"), arg.pos);
			}
			if (exp_arg_sym->kind == v__ast__Kind_interface_) {
				v__checker__Checker_type_implements(c, got_arg_typ, exp_arg_typ, v__ast__Expr_position(arg.expr));
				continue;
			}
			if (method.generic_names.len > 0) {
				continue;
			}
			Option_void _t1926 = v__checker__Checker_check_expected_call_arg(c, got_arg_typ, exp_arg_typ, call_expr->language);
			if (_t1926.state != 0 && _t1926.err._typ != _IError_None___index) {
				IError err = _t1926.err;
				if (!v__ast__Type_alias_eq(got_arg_typ, _const_v__ast__void_type)) {
					v__checker__Checker_error(c, _STR("%.*s\000 in argument %"PRId32"\000 to `%.*s\000.%.*s\000`", 5, (*(err.msg)), i + 1, left_type_sym->name, method_name), arg.pos);
				}
			};
			v__ast__Param param = (method.is_variadic && i >= method.params.len - 1 ? ((*(v__ast__Param*)/*ee elem_typ */array_get(method.params, method.params.len - 1))) : ((*(v__ast__Param*)/*ee elem_typ */array_get(method.params, i + 1))));
			v__ast__ShareType param_share = v__ast__Type_share(param.typ);
			if (param_share == v__ast__ShareType_shared_t && (c->locked_names.len > 0 || c->rlocked_names.len > 0)) {
				v__checker__Checker_error(c, _SLIT("method with `shared` arguments cannot be called inside `lock`/`rlock` block"), arg.pos);
			}
			if (arg.is_mut) {
				multi_return_string_v__token__Position mr_60097 = v__checker__Checker_fail_if_immutable(c, arg.expr);
				string to_lock = mr_60097.arg0;
				v__token__Position pos = mr_60097.arg1;
				if (!param.is_mut) {
					string tok = v__ast__ShareType_str(arg.share);
					v__checker__Checker_error(c, _STR("`%.*s\000` parameter `%.*s\000` is not `%.*s\000`, `%.*s\000` is not needed`", 5, call_expr->name, param.name, tok, tok), v__ast__Expr_position(arg.expr));
				} else {
					if (v__ast__Type_share(param.typ) != arg.share) {
						v__checker__Checker_error(c, _SLIT("wrong shared type"), v__ast__Expr_position(arg.expr));
					}
					if ((to_lock).len != 0 && param_share != v__ast__ShareType_shared_t) {
						v__checker__Checker_error(c, _STR("%.*s\000 is `shared` and must be `lock`ed to be passed as `mut`", 2, to_lock), pos);
					}
				}
			} else {
				if (param.is_mut) {
					string tok = v__ast__ShareType_str(arg.share);
					v__checker__Checker_error(c, _STR("`%.*s\000` parameter `%.*s\000` is `%.*s\000`, you need to provide `%.*s\000` e.g. `%.*s\000 arg%"PRId32"\000`", 7, call_expr->name, param.name, tok, tok, tok, i + 1), v__ast__Expr_position(arg.expr));
				} else {
					v__checker__Checker_fail_if_unreadable(c, arg.expr, got_arg_typ, _SLIT("argument"));
				}
			}
		}
		if (method.is_unsafe && !c->inside_unsafe) {
			v__checker__Checker_warn(c, _STR("method `%.*s\000.%.*s\000` must be called from an `unsafe` block", 3, left_type_sym->name, method_name), call_expr->pos);
		}
		if (!c->cur_fn->is_deprecated && method.is_deprecated) {
			v__checker__Checker_deprecate_fnmethod(c, _SLIT("method"), _STR("%.*s\000.%.*s", 2, left_type_sym->name, method.name), method, *call_expr);
		}
		if (call_expr->expected_arg_types.len == 0) {
			for (int i = 1; i < method.params.len; ++i) {
				array_push(&call_expr->expected_arg_types, _MOV((v__ast__Type[]){ (*(v__ast__Param*)/*ee elem_typ */array_get(method.params, i)).typ }));
			}
		}
		if (is_method_from_embed) {
			call_expr->receiver_type = v__ast__Type_derive(call_expr->from_embed_type, (*(v__ast__Param*)/*ee elem_typ */array_get(method.params, 0)).typ);
		} else if (is_generic) {
			call_expr->receiver_type = v__ast__Type_set_flag(v__ast__Type_derive(left_type, (*(v__ast__Param*)/*ee elem_typ */array_get(method.params, 0)).typ), v__ast__TypeFlag_generic);
		} else {
			call_expr->receiver_type = (*(v__ast__Param*)/*ee elem_typ */array_get(method.params, 0)).typ;
		}
		if (method.generic_names.len != call_expr->generic_types.len) {
			v__checker__Checker_infer_fn_types(c, method, call_expr);
		}
		if (call_expr->generic_types.len > 0 && method.return_type != 0) {
			Option_v__ast__Type _t1928;
			if (_t1928 = v__ast__Table_resolve_generic_by_names(c->table, method.return_type, method.generic_names, call_expr->generic_types), _t1928.state == 0) {
				v__ast__Type typ = *(v__ast__Type*)_t1928.data;
				call_expr->return_type = typ;
				// autofree_scope_vars(pos=62238 line_nr=1726 scope.pos=62201 scope.end_pos=62253)
				// af parent scope:
				// var "typ" var.pos=62087 var.line_nr=1722
				// af parent scope:
				// af parent scope:
				// var "rec_share" var.pos=56365 var.line_nr=1577
				// var "nr_args" var.pos=57293 var.line_nr=1600
				// var "min_required_args" var.pos=57369 var.line_nr=1601
				// af parent scope:
				// var "c" var.pos=52007 var.line_nr=1466
				// var "call_expr" var.pos=52034 var.line_nr=1466
				// var "left_type" var.pos=52070 var.line_nr=1467
				// var "is_generic" var.pos=52140 var.line_nr=1469
				// var "left_type_sym" var.pos=52412 var.line_nr=1475
				// var "method_name" var.pos=52483 var.line_nr=1476
				// var "unknown_method_msg" var.pos=52518 var.line_nr=1477
				// var "has_generic_generic" var.pos=52853 var.line_nr=1485
				// var "generic_types" var.pos=52925 var.line_nr=1486
				// var "method" var.pos=54692 var.line_nr=1529
				// var "has_method" var.pos=54716 var.line_nr=1530
				// var "is_method_from_embed" var.pos=54741 var.line_nr=1531
				// af parent scope:
				// af parent scope:
				return typ;
			}
		}
		if (call_expr->generic_types.len > 0 && method.generic_names.len == 0) {
			v__checker__Checker_error(c, _SLIT("a non generic function called like a generic one"), call_expr->generic_list_pos);
		}
		if (call_expr->generic_types.len > method.generic_names.len) {
			v__checker__Checker_error(c, _STR("too many generic parameters got %"PRId32"\000, expected %"PRId32"", 2, call_expr->generic_types.len, method.generic_names.len), call_expr->generic_list_pos);
		}
		if (method.generic_names.len > 0) {
			 v__ast__Type _t1929 = call_expr->return_type;
			// autofree_scope_vars(pos=62673 line_nr=1737 scope.pos=62669 scope.end_pos=62705)
			// af parent scope:
			// var "rec_share" var.pos=56365 var.line_nr=1577
			// var "nr_args" var.pos=57293 var.line_nr=1600
			// var "min_required_args" var.pos=57369 var.line_nr=1601
			// af parent scope:
			// var "c" var.pos=52007 var.line_nr=1466
			// var "call_expr" var.pos=52034 var.line_nr=1466
			// var "left_type" var.pos=52070 var.line_nr=1467
			// var "is_generic" var.pos=52140 var.line_nr=1469
			// var "left_type_sym" var.pos=52412 var.line_nr=1475
			// var "method_name" var.pos=52483 var.line_nr=1476
			// var "unknown_method_msg" var.pos=52518 var.line_nr=1477
			// var "has_generic_generic" var.pos=52853 var.line_nr=1485
			// var "generic_types" var.pos=52925 var.line_nr=1486
			// var "method" var.pos=54692 var.line_nr=1529
			// var "has_method" var.pos=54716 var.line_nr=1530
			// var "is_method_from_embed" var.pos=54741 var.line_nr=1531
			// af parent scope:
			// af parent scope:
			return _t1929;
		}
		 v__ast__Type _t1930 = method.return_type;
		// autofree_scope_vars(pos=62708 line_nr=1739 scope.pos=56022 scope.end_pos=62736)
		// var "rec_share" var.pos=56365 var.line_nr=1577
		// var "nr_args" var.pos=57293 var.line_nr=1600
		// var "min_required_args" var.pos=57369 var.line_nr=1601
		// af parent scope:
		// var "c" var.pos=52007 var.line_nr=1466
		// var "call_expr" var.pos=52034 var.line_nr=1466
		// var "left_type" var.pos=52070 var.line_nr=1467
		// var "is_generic" var.pos=52140 var.line_nr=1469
		// var "left_type_sym" var.pos=52412 var.line_nr=1475
		// var "method_name" var.pos=52483 var.line_nr=1476
		// var "unknown_method_msg" var.pos=52518 var.line_nr=1477
		// var "has_generic_generic" var.pos=52853 var.line_nr=1485
		// var "generic_types" var.pos=52925 var.line_nr=1486
		// var "method" var.pos=54692 var.line_nr=1529
		// var "has_method" var.pos=54716 var.line_nr=1530
		// var "is_method_from_embed" var.pos=54741 var.line_nr=1531
		// af parent scope:
		// af parent scope:
		return _t1930;
	}
	if (string_eq(method_name, _SLIT("str"))) {
		if (left_type_sym->kind == v__ast__Kind_interface_) {
			string iname = left_type_sym->name;
			v__checker__Checker_error(c, _STR("interface `%.*s\000` does not have a .str() method. Use typeof() instead", 2, iname), call_expr->pos);
		}
		call_expr->receiver_type = left_type;
		call_expr->return_type = _const_v__ast__string_type;
		if (call_expr->args.len > 0) {
			v__checker__Checker_error(c, _SLIT(".str() method calls should have no arguments"), call_expr->pos);
		}
		v__checker__Checker_fail_if_unreadable(c, call_expr->left, left_type, _SLIT("receiver"));
		// autofree_scope_vars(pos=63218 line_nr=1754 scope.pos=62785 scope.end_pos=63243)
		// af parent scope:
		// var "c" var.pos=52007 var.line_nr=1466
		// var "call_expr" var.pos=52034 var.line_nr=1466
		// var "left_type" var.pos=52070 var.line_nr=1467
		// var "is_generic" var.pos=52140 var.line_nr=1469
		// var "left_type_sym" var.pos=52412 var.line_nr=1475
		// var "method_name" var.pos=52483 var.line_nr=1476
		// var "unknown_method_msg" var.pos=52518 var.line_nr=1477
		// var "has_generic_generic" var.pos=52853 var.line_nr=1485
		// var "generic_types" var.pos=52925 var.line_nr=1486
		// var "method" var.pos=54692 var.line_nr=1529
		// var "has_method" var.pos=54716 var.line_nr=1530
		// var "is_method_from_embed" var.pos=54741 var.line_nr=1531
		// af parent scope:
		// af parent scope:
		return _const_v__ast__string_type;
	}
	Option_v__ast__StructField _t1931;
	if (_t1931 = v__ast__Table_find_field(c->table, left_type_sym, method_name), _t1931.state == 0) {
		v__ast__StructField field = *(v__ast__StructField*)_t1931.data;
		v__ast__TypeSymbol* field_type_sym = v__ast__Table_get_type_symbol(c->table, field.typ);
		if (field_type_sym->kind == v__ast__Kind_function) {
			call_expr->is_field = true;
			v__ast__FnType info = /* as */ *(v__ast__FnType*)__as_cast((field_type_sym->info)._v__ast__FnType,(field_type_sym->info)._typ, 418) /*expected idx: 418, name: v.ast.FnType */ ;
			call_expr->return_type = info.func.return_type;
			Array_v__ast__Type earg_types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
			// FOR IN array
			for (int _t1932 = 0; _t1932 < call_expr->args.len; ++_t1932) {
				v__ast__CallArg* arg = ((v__ast__CallArg*)call_expr->args.data) + _t1932;
				v__ast__Type targ = v__checker__Checker_check_expr_opt_call(c, arg->expr, v__checker__Checker_expr(c, arg->expr));
				arg->typ = targ;
				array_push(&earg_types, _MOV((v__ast__Type[]){ targ }));
			}
			call_expr->expected_arg_types = earg_types;
			 v__ast__Type _t1934 = info.func.return_type;
			// autofree_scope_vars(pos=63888 line_nr=1772 scope.pos=63504 scope.end_pos=63920)
			// var "info" var.pos=63572 var.line_nr=1763
			// var "earg_types" var.pos=63670 var.line_nr=1765
			// af parent scope:
			// var "field_type_sym" var.pos=63413 var.line_nr=1759
			// af parent scope:
			// var "field" var.pos=63353 var.line_nr=1758
			// af parent scope:
			// var "c" var.pos=52007 var.line_nr=1466
			// var "call_expr" var.pos=52034 var.line_nr=1466
			// var "left_type" var.pos=52070 var.line_nr=1467
			// var "is_generic" var.pos=52140 var.line_nr=1469
			// var "left_type_sym" var.pos=52412 var.line_nr=1475
			// var "method_name" var.pos=52483 var.line_nr=1476
			// var "unknown_method_msg" var.pos=52518 var.line_nr=1477
			// var "has_generic_generic" var.pos=52853 var.line_nr=1485
			// var "generic_types" var.pos=52925 var.line_nr=1486
			// var "method" var.pos=54692 var.line_nr=1529
			// var "has_method" var.pos=54716 var.line_nr=1530
			// var "is_method_from_embed" var.pos=54741 var.line_nr=1531
			// af parent scope:
			// af parent scope:
			return _t1934;
		}
	}
	if (!v__ast__Type_alias_eq(left_type, _const_v__ast__void_type)) {
		Array_v__ast__Fn _t1935_orig = left_type_sym->methods;
		int _t1935_len = _t1935_orig.len;
		Array_string _t1935 = __new_array(0, _t1935_len, sizeof(string));

		for (int _t1936 = 0; _t1936 < _t1935_len; ++_t1936) {
			v__ast__Fn it = ((v__ast__Fn*) _t1935_orig.data)[_t1936];
			string ti = it.name;
			array_push(&_t1935, &ti);
		}
		
		v__util__Suggestion suggestion = v__util__new_suggestion(method_name, _t1935);
		v__checker__Checker_error(c, v__util__Suggestion_say(suggestion, unknown_method_msg), call_expr->pos);
	}
	// autofree_scope_vars(pos=64107 line_nr=1779 scope.pos=52002 scope.end_pos=64129)
	// var "c" var.pos=52007 var.line_nr=1466
	// var "call_expr" var.pos=52034 var.line_nr=1466
	// var "left_type" var.pos=52070 var.line_nr=1467
	// var "is_generic" var.pos=52140 var.line_nr=1469
	// var "left_type_sym" var.pos=52412 var.line_nr=1475
	// var "method_name" var.pos=52483 var.line_nr=1476
	// var "unknown_method_msg" var.pos=52518 var.line_nr=1477
	// var "has_generic_generic" var.pos=52853 var.line_nr=1485
	// var "generic_types" var.pos=52925 var.line_nr=1486
	// var "method" var.pos=54692 var.line_nr=1529
	// var "has_method" var.pos=54716 var.line_nr=1530
	// var "is_method_from_embed" var.pos=54741 var.line_nr=1531
	// af parent scope:
	// af parent scope:
	return _const_v__ast__void_type;
}

VV_LOCAL_SYMBOL v__ast__Type v__checker__Checker_map_builtin_method_call(v__checker__Checker* c, v__ast__CallExpr* call_expr, v__ast__Type left_type, v__ast__TypeSymbol left_type_sym) {
	string method_name = call_expr->name;
	v__ast__Type ret_type = _const_v__ast__void_type;

	if (string_eq(method_name, _SLIT("clone")) || string_eq(method_name, _SLIT("move"))) {
		if (string_at(method_name, 0) == L'm') {
			v__checker__Checker_fail_if_immutable(c, call_expr->left);
		}
		if (v__ast__Expr_is_auto_deref_var(call_expr->left)) {
			ret_type = v__ast__Type_deref(left_type);
		} else {
			ret_type = left_type;
		}
	}
	else if (string_eq(method_name, _SLIT("keys"))) {
		v__ast__Map info = /* as */ *(v__ast__Map*)__as_cast((left_type_sym.info)._v__ast__Map,(left_type_sym.info)._typ, 396) /*expected idx: 396, name: v.ast.Map */ ;
		int typ = v__ast__Table_find_or_register_array(c->table, info.key_type);
		ret_type = ((typ));
	}
	else if (string_eq(method_name, _SLIT("delete"))) {
		v__checker__Checker_fail_if_immutable(c, call_expr->left);
		if (call_expr->args.len != 1) {
			v__checker__Checker_error(c, _STR("expected 1 argument, but got %"PRId32"", 1, call_expr->args.len), call_expr->pos);
		}
		v__ast__Map info = /* as */ *(v__ast__Map*)__as_cast((left_type_sym.info)._v__ast__Map,(left_type_sym.info)._typ, 396) /*expected idx: 396, name: v.ast.Map */ ;
		v__ast__Type arg_type = v__checker__Checker_expr(c, (*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr->args, 0)).expr);
		Option_void _t1937 = v__checker__Checker_check_expected_call_arg(c, arg_type, info.key_type, call_expr->language);
		if (_t1937.state != 0 && _t1937.err._typ != _IError_None___index) {
			IError err = _t1937.err;
			v__checker__Checker_error(c, _STR("%.*s\000 in argument 1 to `Map.delete`", 2, (*(err.msg))), (*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr->args, 0)).pos);
		};
	}
	else {
	};
	call_expr->receiver_type = v__ast__Type_to_ptr(left_type);
	call_expr->return_type = ret_type;
	 v__ast__Type _t1938 = call_expr->return_type;
	// autofree_scope_vars(pos=65217 line_nr=1816 scope.pos=64135 scope.end_pos=65247)
	// var "c" var.pos=64140 var.line_nr=1782
	// var "call_expr" var.pos=64179 var.line_nr=1782
	// var "left_type" var.pos=64203 var.line_nr=1782
	// var "left_type_sym" var.pos=64223 var.line_nr=1782
	// var "method_name" var.pos=64265 var.line_nr=1783
	// var "ret_type" var.pos=64300 var.line_nr=1784
	// af parent scope:
	// af parent scope:
	return _t1938;
}

VV_LOCAL_SYMBOL v__ast__Type v__checker__Checker_array_builtin_method_call(v__checker__Checker* c, v__ast__CallExpr* call_expr, v__ast__Type left_type, v__ast__TypeSymbol left_type_sym) {
	string method_name = call_expr->name;
	v__ast__Type elem_typ = _const_v__ast__void_type;
	if (string_eq(method_name, _SLIT("slice")) && !c->is_builtin_mod) {
		v__checker__Checker_error(c, _SLIT(".slice() is a private method, use `x[start..end]` instead"), call_expr->pos);
	}
	v__ast__Array array_info = /* as */ *(v__ast__Array*)__as_cast((left_type_sym.info)._v__ast__Array,(left_type_sym.info)._typ, 395) /*expected idx: 395, name: v.ast.Array */ ;
	elem_typ = array_info.elem_type;
	if ((string_eq(method_name, _SLIT("filter")) || string_eq(method_name, _SLIT("map")) || string_eq(method_name, _SLIT("any")) || string_eq(method_name, _SLIT("all")))) {
		v__checker__scope_register_it(call_expr->scope, call_expr->pos, elem_typ);
	} else if (string_eq(method_name, _SLIT("sort"))) {
		v__checker__Checker_fail_if_immutable(c, call_expr->left);
		v__checker__scope_register_a_b(call_expr->scope, call_expr->pos, elem_typ);
		if (call_expr->args.len > 1) {
			v__checker__Checker_error(c, _STR("expected 0 or 1 argument, but got %"PRId32"", 1, call_expr->args.len), call_expr->pos);
		} else if (call_expr->args.len == 1) {
			if (((*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr->args, 0)).expr)._typ == 258 /* v.ast.InfixExpr */) {
				if (!((*(*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr->args, 0)).expr._v__ast__InfixExpr).op == v__token__Kind_gt || (*(*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr->args, 0)).expr._v__ast__InfixExpr).op == v__token__Kind_lt)) {
					v__checker__Checker_error(c, _SLIT("`.sort()` can only use `<` or `>` comparison"), call_expr->pos);
				}
				byte left_name = string_at(_STR("%.*s", 1, v__ast__Expr_str((*(*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr->args, 0)).expr._v__ast__InfixExpr).left)), 0);
				byte right_name = string_at(_STR("%.*s", 1, v__ast__Expr_str((*(*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr->args, 0)).expr._v__ast__InfixExpr).right)), 0);
				if (!(left_name == L'a' || left_name == L'b') || !(right_name == L'a' || right_name == L'b')) {
					v__checker__Checker_error(c, _SLIT("`.sort()` can only use `a` or `b` as argument, e.g. `arr.sort(a < b)`"), call_expr->pos);
				} else if (left_name == right_name) {
					v__checker__Checker_error(c, _SLIT("`.sort()` cannot use same argument"), call_expr->pos);
				}
			} else {
				v__checker__Checker_error(c, string_add(_SLIT("`.sort()` requires a `<` or `>` comparison as the first and only argument"), _SLIT("\ne.g. `users.sort(a.id < b.id)`")), call_expr->pos);
			}
		}
	} else if (string_eq(method_name, _SLIT("wait"))) {
		v__ast__TypeSymbol* elem_sym = v__ast__Table_get_type_symbol(c->table, elem_typ);
		if (elem_sym->kind == v__ast__Kind_thread) {
			if (call_expr->args.len != 0) {
				v__checker__Checker_error(c, _SLIT("`.wait()` does not have any arguments"), (*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr->args, 0)).pos);
			}
			v__ast__Type thread_ret_type = v__ast__TypeSymbol_thread_info(elem_sym).return_type;
			if (v__ast__Type_has_flag(thread_ret_type, v__ast__TypeFlag_optional)) {
				v__checker__Checker_error(c, _SLIT("`.wait()` cannot be called for an array when thread functions return optionals. Iterate over the arrays elements instead and handle each returned optional with `or`."), call_expr->pos);
			}
			call_expr->return_type = v__ast__Table_find_or_register_array(c->table, thread_ret_type);
		} else {
			v__checker__Checker_error(c, _STR("`%.*s\000` has no method `wait()` (only thread handles and arrays of them have)", 2, left_type_sym.name), v__ast__Expr_position(call_expr->left));
		}
	}
	v__ast__Type arg_type = left_type;
	// FOR IN array
	for (int _t1939 = 0; _t1939 < call_expr->args.len; ++_t1939) {
		v__ast__CallArg arg = ((v__ast__CallArg*)call_expr->args.data)[_t1939];
		arg_type = v__checker__Checker_check_expr_opt_call(c, arg.expr, v__checker__Checker_expr(c, arg.expr));
	}
	if (string_eq(method_name, _SLIT("map"))) {
		v__checker__Checker_check_map_and_filter(c, true, elem_typ, *call_expr);
		v__ast__TypeSymbol* arg_sym = v__ast__Table_get_type_symbol(c->table, arg_type);
		v__ast__Type ret_type = ((arg_sym->info._typ == 418 /* v.ast.FnType */) ? ((*arg_sym->info._v__ast__FnType).func.return_type) : (arg_type));
		call_expr->return_type = v__ast__Table_find_or_register_array(c->table, ret_type);
	} else if (string_eq(method_name, _SLIT("filter"))) {
		v__checker__Checker_check_map_and_filter(c, false, elem_typ, *call_expr);
	} else if ((string_eq(method_name, _SLIT("any")) || string_eq(method_name, _SLIT("all")))) {
		v__checker__Checker_check_map_and_filter(c, false, elem_typ, *call_expr);
		call_expr->return_type = _const_v__ast__bool_type;
	} else if (string_eq(method_name, _SLIT("clone"))) {
		call_expr->receiver_type = v__ast__Type_to_ptr(left_type);
		if (v__ast__Expr_is_auto_deref_var(call_expr->left)) {
			call_expr->return_type = v__ast__Type_deref(left_type);
		} else {
			call_expr->return_type = v__ast__Type_set_nr_muls(call_expr->receiver_type, 0);
		}
	} else if (string_eq(method_name, _SLIT("sort"))) {
		call_expr->return_type = _const_v__ast__void_type;
	} else if (string_eq(method_name, _SLIT("contains"))) {
		call_expr->return_type = _const_v__ast__bool_type;
	} else if (string_eq(method_name, _SLIT("index"))) {
		call_expr->return_type = _const_v__ast__int_type;
	} else if ((string_eq(method_name, _SLIT("first")) || string_eq(method_name, _SLIT("last")) || string_eq(method_name, _SLIT("pop")))) {
		call_expr->return_type = array_info.elem_type;
		if (string_eq(method_name, _SLIT("pop"))) {
			call_expr->receiver_type = v__ast__Type_to_ptr(left_type);
		} else {
			call_expr->receiver_type = left_type;
		}
	}
	 v__ast__Type _t1940 = call_expr->return_type;
	// autofree_scope_vars(pos=69197 line_nr=1916 scope.pos=65253 scope.end_pos=69227)
	// var "c" var.pos=65258 var.line_nr=1819
	// var "call_expr" var.pos=65299 var.line_nr=1819
	// var "left_type" var.pos=65323 var.line_nr=1819
	// var "left_type_sym" var.pos=65343 var.line_nr=1819
	// var "method_name" var.pos=65385 var.line_nr=1820
	// var "elem_typ" var.pos=65420 var.line_nr=1821
	// var "array_info" var.pos=65586 var.line_nr=1825
	// var "arg_type" var.pos=67734 var.line_nr=1874
	// af parent scope:
	// af parent scope:
	return _t1940;
}

v__ast__Type v__checker__Checker_fn_call(v__checker__Checker* c, v__ast__CallExpr* call_expr) {
	string fn_name = call_expr->name;
	if (string_eq(fn_name, _SLIT("main"))) {
		v__checker__Checker_error(c, _SLIT("the `main` function cannot be called in the program"), call_expr->pos);
	}
	if (string_eq(fn_name, _SLIT("typeof"))) {
		// autofree_scope_vars(pos=69530 line_nr=1926 scope.pos=69458 scope.end_pos=69555)
		// af parent scope:
		// var "c" var.pos=69242 var.line_nr=1919
		// var "call_expr" var.pos=69265 var.line_nr=1919
		// var "fn_name" var.pos=69301 var.line_nr=1920
		// var "has_generic_generic" var.pos=69562 var.line_nr=1928
		// var "generic_types" var.pos=69630 var.line_nr=1929
		// var "f" var.pos=71029 var.line_nr=1970
		// var "found" var.pos=71048 var.line_nr=1971
		// var "found_in_args" var.pos=71068 var.line_nr=1972
		// af parent scope:
		// af parent scope:
		return _const_v__ast__string_type;
	}
	bool has_generic_generic = false;
	Array_v__ast__Type generic_types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
	// FOR IN array
	for (int _t1941 = 0; _t1941 < call_expr->generic_types.len; ++_t1941) {
		v__ast__Type generic_type = ((v__ast__Type*)call_expr->generic_types.data)[_t1941];
		if (v__ast__Type_has_flag(generic_type, v__ast__TypeFlag_generic)) {
			has_generic_generic = true;
			array_push(&generic_types, _MOV((v__ast__Type[]){ v__checker__Checker_unwrap_generic(c, generic_type) }));
		} else {
			array_push(&generic_types, _MOV((v__ast__Type[]){ generic_type }));
		}
	}
	if (has_generic_generic) {
		if ((c->mod).len != 0) {
			v__ast__Table_register_fn_gen_type(c->table, string_add(string_add(c->mod, _SLIT(".")), fn_name), generic_types);
		} else {
			v__ast__Table_register_fn_gen_type(c->table, fn_name, generic_types);
		}
	}
	if (string_eq(fn_name, _SLIT("json.encode"))) {
	} else if (string_eq(fn_name, _SLIT("json.decode")) && call_expr->args.len > 0) {
		if (call_expr->args.len != 2) {
			v__checker__Checker_error(c, _SLIT("json.decode expects 2 arguments, a type and a string (e.g `json.decode(T, '')`)"), call_expr->pos);
			// autofree_scope_vars(pos=70382 line_nr=1951 scope.pos=70265 scope.end_pos=70406)
			// af parent scope:
			// var "expr" var.pos=70410 var.line_nr=1953
			// var "typ" var.pos=70839 var.line_nr=1964
			// var "ret_type" var.pos=70869 var.line_nr=1965
			// af parent scope:
			// var "c" var.pos=69242 var.line_nr=1919
			// var "call_expr" var.pos=69265 var.line_nr=1919
			// var "fn_name" var.pos=69301 var.line_nr=1920
			// var "has_generic_generic" var.pos=69562 var.line_nr=1928
			// var "generic_types" var.pos=69630 var.line_nr=1929
			// var "f" var.pos=71029 var.line_nr=1970
			// var "found" var.pos=71048 var.line_nr=1971
			// var "found_in_args" var.pos=71068 var.line_nr=1972
			// af parent scope:
			// af parent scope:
			return _const_v__ast__void_type;
		}
		v__ast__Expr expr = (*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr->args, 0)).expr;
		if ((expr)._typ != 279 /* v.ast.TypeNode */) {
			string typ = tos3( /* v.ast.Expr */ v_typeof_sumtype_v__ast__Expr( (expr)._typ ));
			v__checker__Checker_error(c, _STR("json.decode: first argument needs to be a type, got `%.*s\000`", 2, typ), call_expr->pos);
			// autofree_scope_vars(pos=70587 line_nr=1957 scope.pos=70468 scope.end_pos=70611)
			// var "typ" var.pos=70473 var.line_nr=1955
			// af parent scope:
			// var "expr" var.pos=70410 var.line_nr=1953
			// var "typ" var.pos=70839 var.line_nr=1964
			// var "ret_type" var.pos=70869 var.line_nr=1965
			// af parent scope:
			// var "c" var.pos=69242 var.line_nr=1919
			// var "call_expr" var.pos=69265 var.line_nr=1919
			// var "fn_name" var.pos=69301 var.line_nr=1920
			// var "has_generic_generic" var.pos=69562 var.line_nr=1928
			// var "generic_types" var.pos=69630 var.line_nr=1929
			// var "f" var.pos=71029 var.line_nr=1970
			// var "found" var.pos=71048 var.line_nr=1971
			// var "found_in_args" var.pos=71068 var.line_nr=1972
			// af parent scope:
			// af parent scope:
			return _const_v__ast__void_type;
		}
		c->expected_type = _const_v__ast__string_type;
		(*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr->args, 1)).typ = v__checker__Checker_expr(c, (*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr->args, 1)).expr);
		if (!v__ast__Type_alias_eq((*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr->args, 1)).typ, _const_v__ast__string_type)) {
			v__checker__Checker_error(c, _SLIT("json.decode: second argument needs to be a string"), call_expr->pos);
		}
		v__ast__TypeNode typ = /* as */ *(v__ast__TypeNode*)__as_cast((expr)._v__ast__TypeNode,(expr)._typ, 279) /*expected idx: 279, name: v.ast.TypeNode */ ;
		v__ast__Type ret_type = v__ast__Type_set_flag(typ.typ, v__ast__TypeFlag_optional);
		call_expr->return_type = ret_type;
		// autofree_scope_vars(pos=70945 line_nr=1967 scope.pos=70234 scope.end_pos=70963)
		// var "expr" var.pos=70410 var.line_nr=1953
		// var "typ" var.pos=70839 var.line_nr=1964
		// var "ret_type" var.pos=70869 var.line_nr=1965
		// af parent scope:
		// var "c" var.pos=69242 var.line_nr=1919
		// var "call_expr" var.pos=69265 var.line_nr=1919
		// var "fn_name" var.pos=69301 var.line_nr=1920
		// var "has_generic_generic" var.pos=69562 var.line_nr=1928
		// var "generic_types" var.pos=69630 var.line_nr=1929
		// var "f" var.pos=71029 var.line_nr=1970
		// var "found" var.pos=71048 var.line_nr=1971
		// var "found_in_args" var.pos=71068 var.line_nr=1972
		// af parent scope:
		// af parent scope:
		return ret_type;
	}
	v__ast__Fn f = (v__ast__Fn){.params = __new_array(0, 1, sizeof(v__ast__Param)),.return_type = 0,.is_variadic = 0,.language = 0,.generic_names = __new_array(0, 1, sizeof(string)),.is_pub = 0,.is_deprecated = 0,.is_unsafe = 0,.is_placeholder = 0,.is_main = 0,.is_test = 0,.is_conditional = 0,.is_keep_alive = 0,.no_body = 0,.mod = (string){.str=(byteptr)"", .is_lit=1},.ctdefine = (string){.str=(byteptr)"", .is_lit=1},.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.name = (string){.str=(byteptr)"", .is_lit=1},.source_fn = 0,.usages = 0,};
	bool found = false;
	bool found_in_args = false;
	if ((call_expr->left)._typ == 233 /* v.ast.AnonFn */) {
		call_expr->name = _SLIT("");
		v__checker__Checker_expr(c, call_expr->left);
		v__ast__TypeSymbol* anon_fn_sym = v__ast__Table_get_type_symbol(c->table, (*call_expr->left._v__ast__AnonFn).typ);
		f = (/* as */ *(v__ast__FnType*)__as_cast((anon_fn_sym->info)._v__ast__FnType,(anon_fn_sym->info)._typ, 418) /*expected idx: 418, name: v.ast.FnType */ ).func;
		found = true;
	}
	if (!found && !string_contains(fn_name, _SLIT(".")) && string_ne(call_expr->mod, _SLIT("builtin"))) {
		string name_prefixed = _STR("%.*s\000.%.*s", 2, call_expr->mod, fn_name);
		Option_v__ast__Fn _t1944;
		if (_t1944 = v__ast__Table_find_fn(c->table, name_prefixed), _t1944.state == 0) {
			v__ast__Fn f1 = *(v__ast__Fn*)_t1944.data;
			call_expr->name = name_prefixed;
			found = true;
			f = f1;
			(*(v__ast__Fn*)map_get(&c->table->fns, &(string[]){name_prefixed}, &(v__ast__Fn[]){ (v__ast__Fn){.params = __new_array(0, 1, sizeof(v__ast__Param)),.generic_names = __new_array(0, 1, sizeof(string)),.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),} })).usages++;
		}
	}
	if (!found && (call_expr->left)._typ == 257 /* v.ast.IndexExpr */) {
		v__checker__Checker_expr(c, call_expr->left);
		v__ast__IndexExpr expr = /* as */ *(v__ast__IndexExpr*)__as_cast((call_expr->left)._v__ast__IndexExpr,(call_expr->left)._typ, 257) /*expected idx: 257, name: v.ast.IndexExpr */ ;
		v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(c->table, expr.left_type);
		if (sym->kind == v__ast__Kind_array) {
			v__ast__Array info = /* as */ *(v__ast__Array*)__as_cast((sym->info)._v__ast__Array,(sym->info)._typ, 395) /*expected idx: 395, name: v.ast.Array */ ;
			v__ast__TypeSymbol* elem_typ = v__ast__Table_get_type_symbol(c->table, info.elem_type);
			if ((elem_typ->info)._typ == 418 /* v.ast.FnType */) {
				 v__ast__Type _t1945 = (*elem_typ->info._v__ast__FnType).func.return_type;
				// autofree_scope_vars(pos=72039 line_nr=2000 scope.pos=72034 scope.end_pos=72081)
				// af parent scope:
				// var "info" var.pos=71915 var.line_nr=1997
				// var "elem_typ" var.pos=71948 var.line_nr=1998
				// af parent scope:
				// var "expr" var.pos=71797 var.line_nr=1994
				// var "sym" var.pos=71839 var.line_nr=1995
				// af parent scope:
				// var "c" var.pos=69242 var.line_nr=1919
				// var "call_expr" var.pos=69265 var.line_nr=1919
				// var "fn_name" var.pos=69301 var.line_nr=1920
				// var "has_generic_generic" var.pos=69562 var.line_nr=1928
				// var "generic_types" var.pos=69630 var.line_nr=1929
				// var "f" var.pos=71029 var.line_nr=1970
				// var "found" var.pos=71048 var.line_nr=1971
				// var "found_in_args" var.pos=71068 var.line_nr=1972
				// af parent scope:
				// af parent scope:
				return _t1945;
			}
		} else if (sym->kind == v__ast__Kind_map) {
			v__ast__Map info = /* as */ *(v__ast__Map*)__as_cast((sym->info)._v__ast__Map,(sym->info)._typ, 396) /*expected idx: 396, name: v.ast.Map */ ;
			v__ast__TypeSymbol* value_typ = v__ast__Table_get_type_symbol(c->table, info.value_type);
			if ((value_typ->info)._typ == 418 /* v.ast.FnType */) {
				 v__ast__Type _t1946 = (*value_typ->info._v__ast__FnType).func.return_type;
				// autofree_scope_vars(pos=72242 line_nr=2006 scope.pos=72237 scope.end_pos=72285)
				// af parent scope:
				// var "info" var.pos=72117 var.line_nr=2003
				// var "value_typ" var.pos=72148 var.line_nr=2004
				// af parent scope:
				// var "expr" var.pos=71797 var.line_nr=1994
				// var "sym" var.pos=71839 var.line_nr=1995
				// af parent scope:
				// var "c" var.pos=69242 var.line_nr=1919
				// var "call_expr" var.pos=69265 var.line_nr=1919
				// var "fn_name" var.pos=69301 var.line_nr=1920
				// var "has_generic_generic" var.pos=69562 var.line_nr=1928
				// var "generic_types" var.pos=69630 var.line_nr=1929
				// var "f" var.pos=71029 var.line_nr=1970
				// var "found" var.pos=71048 var.line_nr=1971
				// var "found_in_args" var.pos=71068 var.line_nr=1972
				// af parent scope:
				// af parent scope:
				return _t1946;
			}
		} else if (sym->kind == v__ast__Kind_array_fixed) {
			v__ast__ArrayFixed info = /* as */ *(v__ast__ArrayFixed*)__as_cast((sym->info)._v__ast__ArrayFixed,(sym->info)._typ, 416) /*expected idx: 416, name: v.ast.ArrayFixed */ ;
			v__ast__TypeSymbol* elem_typ = v__ast__Table_get_type_symbol(c->table, info.elem_type);
			if ((elem_typ->info)._typ == 418 /* v.ast.FnType */) {
				 v__ast__Type _t1947 = (*elem_typ->info._v__ast__FnType).func.return_type;
				// autofree_scope_vars(pos=72458 line_nr=2012 scope.pos=72453 scope.end_pos=72500)
				// af parent scope:
				// var "info" var.pos=72329 var.line_nr=2009
				// var "elem_typ" var.pos=72367 var.line_nr=2010
				// af parent scope:
				// var "expr" var.pos=71797 var.line_nr=1994
				// var "sym" var.pos=71839 var.line_nr=1995
				// af parent scope:
				// var "c" var.pos=69242 var.line_nr=1919
				// var "call_expr" var.pos=69265 var.line_nr=1919
				// var "fn_name" var.pos=69301 var.line_nr=1920
				// var "has_generic_generic" var.pos=69562 var.line_nr=1928
				// var "generic_types" var.pos=69630 var.line_nr=1929
				// var "f" var.pos=71029 var.line_nr=1970
				// var "found" var.pos=71048 var.line_nr=1971
				// var "found_in_args" var.pos=71068 var.line_nr=1972
				// af parent scope:
				// af parent scope:
				return _t1947;
			}
		}
		found = true;
		// autofree_scope_vars(pos=72522 line_nr=2016 scope.pos=71768 scope.end_pos=72547)
		// var "expr" var.pos=71797 var.line_nr=1994
		// var "sym" var.pos=71839 var.line_nr=1995
		// af parent scope:
		// var "c" var.pos=69242 var.line_nr=1919
		// var "call_expr" var.pos=69265 var.line_nr=1919
		// var "fn_name" var.pos=69301 var.line_nr=1920
		// var "has_generic_generic" var.pos=69562 var.line_nr=1928
		// var "generic_types" var.pos=69630 var.line_nr=1929
		// var "f" var.pos=71029 var.line_nr=1970
		// var "found" var.pos=71048 var.line_nr=1971
		// var "found_in_args" var.pos=71068 var.line_nr=1972
		// af parent scope:
		// af parent scope:
		return _const_v__ast__string_type;
	}
	if (!found) {
		Option_v__ast__Fn _t1948;
		if (_t1948 = v__ast__Table_find_fn(c->table, fn_name), _t1948.state == 0) {
			v__ast__Fn f1 = *(v__ast__Fn*)_t1948.data;
			found = true;
			f = f1;
			(*(v__ast__Fn*)map_get(&c->table->fns, &(string[]){fn_name}, &(v__ast__Fn[]){ (v__ast__Fn){.params = __new_array(0, 1, sizeof(v__ast__Param)),.generic_names = __new_array(0, 1, sizeof(string)),.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),} })).usages++;
		}
	}
	if (c->pref->is_script && !found) {
		string os_name = _STR("os.%.*s", 1, fn_name);
		Option_v__ast__Fn _t1949;
		if (_t1949 = v__ast__Table_find_fn(c->table, os_name), _t1949.state == 0) {
			v__ast__Fn f1 = *(v__ast__Fn*)_t1949.data;
			if (f1.generic_names.len == call_expr->generic_types.len) {
				map_set(&c->table->fn_gen_types, &(string[]){os_name}, &(Array_Array_v__ast__Type[]) { (*(Array_Array_v__ast__Type*)map_get(ADDR(map, c->table->fn_gen_types), &(string[]){_STR("%.*s\000.%.*s", 2, call_expr->mod, call_expr->name)}, &(Array_Array_v__ast__Type[]){ __new_array(0, 1, sizeof(Array_v__ast__Type)) })) });
			}
			call_expr->name = os_name;
			found = true;
			f = f1;
			(*(v__ast__Fn*)map_get(&c->table->fns, &(string[]){os_name}, &(v__ast__Fn[]){ (v__ast__Fn){.params = __new_array(0, 1, sizeof(v__ast__Param)),.generic_names = __new_array(0, 1, sizeof(string)),.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),} })).usages++;
		}
	}
	if (!found) {
		Option_v__ast__Var_ptr _t1950;
		if (_t1950 = v__ast__Scope_find_var(call_expr->scope, fn_name), _t1950.state == 0) {
			v__ast__Var* v = *(v__ast__Var**)_t1950.data;
			if (v->typ != 0) {
				v__ast__TypeSymbol* vts = v__ast__Table_get_type_symbol(c->table, v->typ);
				if (vts->kind == v__ast__Kind_function) {
					v__ast__FnType info = /* as */ *(v__ast__FnType*)__as_cast((vts->info)._v__ast__FnType,(vts->info)._typ, 418) /*expected idx: 418, name: v.ast.FnType */ ;
					f = info.func;
					found = true;
					found_in_args = true;
				}
			}
		}
	}
	if (!found) {
		v__checker__Checker_error(c, _STR("unknown function: %.*s", 1, fn_name), call_expr->pos);
		// autofree_scope_vars(pos=73436 line_nr=2054 scope.pos=73378 scope.end_pos=73459)
		// af parent scope:
		// var "c" var.pos=69242 var.line_nr=1919
		// var "call_expr" var.pos=69265 var.line_nr=1919
		// var "fn_name" var.pos=69301 var.line_nr=1920
		// var "has_generic_generic" var.pos=69562 var.line_nr=1928
		// var "generic_types" var.pos=69630 var.line_nr=1929
		// var "f" var.pos=71029 var.line_nr=1970
		// var "found" var.pos=71048 var.line_nr=1971
		// var "found_in_args" var.pos=71068 var.line_nr=1972
		// af parent scope:
		// af parent scope:
		return _const_v__ast__void_type;
	}
	if (!found_in_args) {
		Option_v__ast__Var_ptr _t1951;
		if (_t1951 = v__ast__Scope_find_var(call_expr->scope, fn_name), _t1951.state == 0) {
			v__checker__Checker_error(c, _STR("ambiguous call to: `%.*s\000`, may refer to fn `%.*s\000` or variable `%.*s\000`", 4, fn_name, fn_name, fn_name), call_expr->pos);
		}
	}
	if (!f.is_pub && f.language == v__ast__Language_v && f.name.len > 0 && f.mod.len > 0 && string_ne(f.mod, c->mod)) {
		v__checker__Checker_error(c, _STR("function `%.*s\000` is private", 2, f.name), call_expr->pos);
	}
	if (!c->cur_fn->is_deprecated && f.is_deprecated) {
		v__checker__Checker_deprecate_fnmethod(c, _SLIT("function"), f.name, f, *call_expr);
	}
	if (f.is_unsafe && !c->inside_unsafe && (f.language != v__ast__Language_c || ((string_at(f.name, 2) == L'm' || string_at(f.name, 2) == L's') && string_eq(f.mod, _SLIT("builtin"))))) {
		v__checker__Checker_warn(c, _STR("function `%.*s\000` must be called from an `unsafe` block", 2, f.name), call_expr->pos);
	}
	call_expr->is_keep_alive = f.is_keep_alive;
	if (string_ne(f.mod, _SLIT("builtin")) && f.language == v__ast__Language_v && f.no_body && !c->pref->translated && !f.is_unsafe) {
		v__checker__Checker_error(c, _SLIT("cannot call a function that does not have a body"), call_expr->pos);
	}
	// FOR IN array
	for (int _t1952 = 0; _t1952 < call_expr->generic_types.len; ++_t1952) {
		v__ast__Type generic_type = ((v__ast__Type*)call_expr->generic_types.data)[_t1952];
		Option_void _t1953 = v__checker__Checker_ensure_type_exists(c, generic_type, call_expr->generic_list_pos);
		if (_t1953.state != 0 && _t1953.err._typ != _IError_None___index) {
			IError err = _t1953.err;
		};
	}
	if (f.generic_names.len > 0 && v__ast__Type_has_flag(f.return_type, v__ast__TypeFlag_generic)) {
		v__checker__Checker_check_return_generics_struct(c, f.return_type, call_expr, generic_types);
	} else {
		call_expr->return_type = f.return_type;
	}
	if (v__ast__Type_alias_eq(f.return_type, _const_v__ast__void_type) && f.ctdefine.len > 0 && !(Array_string_contains(c->pref->compile_defines, f.ctdefine))) {
		call_expr->should_be_skipped = true;
	}
	if (call_expr->language != v__ast__Language_js) {
		int min_required_args = (f.is_variadic ? (f.params.len - 1) : (f.params.len));
		if (call_expr->args.len < min_required_args) {
			v__checker__Checker_error(c, _STR("expected %"PRId32"\000 arguments, but got %"PRId32"", 2, min_required_args, call_expr->args.len), call_expr->pos);
		} else if (!f.is_variadic && call_expr->args.len > f.params.len) {
			Array_v__ast__CallArg unexpected_arguments = array_slice(call_expr->args, min_required_args, call_expr->args.len);
			v__token__Position unexpected_arguments_pos = v__token__Position_extend((*(v__ast__CallArg*)/*ee elem_typ */array_get(unexpected_arguments, 0)).pos, (*(v__ast__CallArg*)array_last(unexpected_arguments)).pos);
			v__checker__Checker_error(c, _STR("expected %"PRId32"\000 arguments, but got %"PRId32"", 2, min_required_args, call_expr->args.len), unexpected_arguments_pos);
			 v__ast__Type _t1954 = f.return_type;
			// autofree_scope_vars(pos=75503 line_nr=2099 scope.pos=75226 scope.end_pos=75527)
			// var "unexpected_arguments" var.pos=75231 var.line_nr=2095
			// var "unexpected_arguments_pos" var.pos=75294 var.line_nr=2096
			// af parent scope:
			// var "min_required_args" var.pos=74935 var.line_nr=2090
			// af parent scope:
			// var "c" var.pos=69242 var.line_nr=1919
			// var "call_expr" var.pos=69265 var.line_nr=1919
			// var "fn_name" var.pos=69301 var.line_nr=1920
			// var "has_generic_generic" var.pos=69562 var.line_nr=1928
			// var "generic_types" var.pos=69630 var.line_nr=1929
			// var "f" var.pos=71029 var.line_nr=1970
			// var "found" var.pos=71048 var.line_nr=1971
			// var "found_in_args" var.pos=71068 var.line_nr=1972
			// af parent scope:
			// af parent scope:
			return _t1954;
		}
	}
	if ((string_eq(fn_name, _SLIT("println")) || string_eq(fn_name, _SLIT("print")) || string_eq(fn_name, _SLIT("eprintln")) || string_eq(fn_name, _SLIT("eprint")) || string_eq(fn_name, _SLIT("panic"))) && call_expr->args.len > 0) {
		c->inside_println_arg = true;
		c->expected_type = _const_v__ast__string_type;
		(*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr->args, 0)).typ = v__checker__Checker_expr(c, (*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr->args, 0)).expr);
		if (v__ast__Type_is_void((*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr->args, 0)).typ)) {
			v__checker__Checker_error(c, _STR("`%.*s\000` can not print void expressions", 2, fn_name), call_expr->pos);
		}
		v__checker__Checker_fail_if_unreadable(c, (*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr->args, 0)).expr, (*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr->args, 0)).typ, _SLIT("argument to print"));
		c->inside_println_arg = false;
		 v__ast__Type _t1955 = f.return_type;
		// autofree_scope_vars(pos=76744 line_nr=2125 scope.pos=75675 scope.end_pos=76767)
		// af parent scope:
		// var "c" var.pos=69242 var.line_nr=1919
		// var "call_expr" var.pos=69265 var.line_nr=1919
		// var "fn_name" var.pos=69301 var.line_nr=1920
		// var "has_generic_generic" var.pos=69562 var.line_nr=1928
		// var "generic_types" var.pos=69630 var.line_nr=1929
		// var "f" var.pos=71029 var.line_nr=1970
		// var "found" var.pos=71048 var.line_nr=1971
		// var "found_in_args" var.pos=71068 var.line_nr=1972
		// af parent scope:
		// af parent scope:
		return _t1955;
	}
	if (string_eq(fn_name, _SLIT("error"))) {
		v__ast__CallArg arg = (*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr->args, 0));
		(*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr->args, 0)).typ = v__checker__Checker_expr(c, arg.expr);
		if (v__ast__Type_alias_eq((*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr->args, 0)).typ, _const_v__ast__error_type)) {
			v__checker__Checker_warn(c, _STR("`error(%.*s\000)` can be shortened to just `%.*s\000`", 3, v__ast__CallArg_str(arg), v__ast__CallArg_str(arg)), call_expr->pos);
		}
	}
	if (call_expr->expected_arg_types.len == 0) {
		// FOR IN array
		for (int _t1956 = 0; _t1956 < f.params.len; ++_t1956) {
			v__ast__Param param = ((v__ast__Param*)f.params.data)[_t1956];
			array_push(&call_expr->expected_arg_types, _MOV((v__ast__Type[]){ param.typ }));
		}
	}
	// FOR IN array
	for (int i = 0; i < call_expr->args.len; ++i) {
		v__ast__CallArg call_arg = ((v__ast__CallArg*)call_expr->args.data)[i];
		v__ast__Param param = (f.is_variadic && i >= f.params.len - 1 ? ((*(v__ast__Param*)/*ee elem_typ */array_get(f.params, f.params.len - 1))) : ((*(v__ast__Param*)/*ee elem_typ */array_get(f.params, i))));
		if (f.is_variadic && (call_arg.expr)._typ == 234 /* v.ast.ArrayDecompose */) {
			if (i > f.params.len - 1) {
				v__checker__Checker_error(c, _STR("too many arguments in call to `%.*s\000`", 2, f.name), call_expr->pos);
			}
		}
		c->expected_type = param.typ;
		v__ast__Type typ = v__checker__Checker_check_expr_opt_call(c, call_arg.expr, v__checker__Checker_expr(c, call_arg.expr));
		(*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr->args, i)).typ = typ;
		v__ast__TypeSymbol* typ_sym = v__ast__Table_get_type_symbol(c->table, typ);
		v__ast__TypeSymbol* arg_typ_sym = v__ast__Table_get_type_symbol(c->table, param.typ);
		if (f.is_variadic && v__ast__Type_has_flag(typ, v__ast__TypeFlag_variadic) && call_expr->args.len - 1 > i) {
			v__checker__Checker_error(c, _SLIT("when forwarding a variadic variable, it must be the final argument"), call_arg.pos);
		}
		v__ast__ShareType arg_share = v__ast__Type_share(param.typ);
		if (arg_share == v__ast__ShareType_shared_t && (c->locked_names.len > 0 || c->rlocked_names.len > 0)) {
			v__checker__Checker_error(c, _SLIT("function with `shared` arguments cannot be called inside `lock`/`rlock` block"), call_arg.pos);
		}
		if (call_arg.is_mut && f.language == v__ast__Language_v) {
			multi_return_string_v__token__Position mr_78237 = v__checker__Checker_fail_if_immutable(c, call_arg.expr);
			string to_lock = mr_78237.arg0;
			v__token__Position pos = mr_78237.arg1;
			if (!param.is_mut) {
				string tok = v__ast__ShareType_str(call_arg.share);
				v__checker__Checker_error(c, _STR("`%.*s\000` parameter `%.*s\000` is not `%.*s\000`, `%.*s\000` is not needed`", 5, call_expr->name, param.name, tok, tok), v__ast__Expr_position(call_arg.expr));
			} else {
				if (v__ast__Type_share(param.typ) != call_arg.share) {
					v__checker__Checker_error(c, _SLIT("wrong shared type"), v__ast__Expr_position(call_arg.expr));
				}
				if ((to_lock).len != 0 && !v__ast__Type_has_flag(param.typ, v__ast__TypeFlag_shared_f)) {
					v__checker__Checker_error(c, _STR("%.*s\000 is `shared` and must be `lock`ed to be passed as `mut`", 2, to_lock), pos);
				}
			}
		} else {
			if (param.is_mut) {
				string tok = v__ast__ShareType_str(call_arg.share);
				v__checker__Checker_error(c, _STR("`%.*s\000` parameter `%.*s\000` is `%.*s\000`, you need to provide `%.*s\000` e.g. `%.*s\000 arg%"PRId32"\000`", 7, call_expr->name, param.name, tok, tok, tok, i + 1), v__ast__Expr_position(call_arg.expr));
			} else {
				v__checker__Checker_fail_if_unreadable(c, call_arg.expr, typ, _SLIT("argument"));
			}
		}
		if (arg_typ_sym->kind == v__ast__Kind_interface_) {
			v__checker__Checker_type_implements(c, typ, param.typ, v__ast__Expr_position(call_arg.expr));
			continue;
		}
		Option_void _t1958 = v__checker__Checker_check_expected_call_arg(c, typ, param.typ, call_expr->language);
		if (_t1958.state != 0 && _t1958.err._typ != _IError_None___index) {
			IError err = _t1958.err;
			if (typ_sym->kind == v__ast__Kind_void && arg_typ_sym->kind == v__ast__Kind_string) {
				continue;
			}
			if (f.generic_names.len > 0) {
				if (v__ast__Type_has_flag(param.typ, v__ast__TypeFlag_generic) && f.generic_names.len == call_expr->generic_types.len) {
					Option_v__ast__Type _t1959;
					if (_t1959 = v__ast__Table_resolve_generic_by_names(c->table, param.typ, f.generic_names, call_expr->generic_types), _t1959.state == 0) {
						v__ast__Type unwrap_typ = *(v__ast__Type*)_t1959.data;
						if ((v__ast__Type_idx(unwrap_typ) == v__ast__Type_idx(typ)) || (v__ast__Type_is_int(unwrap_typ) && v__ast__Type_is_int(typ)) || (v__ast__Type_is_float(unwrap_typ) && v__ast__Type_is_float(typ))) {
							continue;
						}
						v__ast__TypeSymbol* expected_sym = v__ast__Table_get_type_symbol(c->table, unwrap_typ);
						v__ast__TypeSymbol* got_sym = v__ast__Table_get_type_symbol(c->table, typ);
						v__checker__Checker_error(c, _STR("argument %"PRId32"\000 got `%.*s\000`, expected `%.*s\000`", 4, i + 1, got_sym->name, expected_sym->name), call_arg.pos);
					} else {
						IError err = _t1959.err;
						continue;
					}
				} else {
					continue;
				}
			}
			v__checker__Checker_error(c, _STR("%.*s\000 in argument %"PRId32"\000 to `%.*s\000`", 4, (*(err.msg)), i + 1, fn_name), call_arg.pos);
		};
		if (f.language != v__ast__Language_c && !c->inside_unsafe && v__ast__Type_nr_muls(typ) != v__ast__Type_nr_muls(param.typ) && !(call_arg.is_mut && param.is_mut) && !(!call_arg.is_mut && !param.is_mut) && !(param.typ == _const_v__ast__byteptr_type || param.typ == _const_v__ast__charptr_type || param.typ == _const_v__ast__voidptr_type)) {
			v__checker__Checker_warn(c, _STR("automatic referencing/dereferencing is deprecated and will be removed soon (got: %"PRId32"\000 references, expected: %"PRId32"\000 references)", 3, v__ast__Type_nr_muls(typ), v__ast__Type_nr_muls(param.typ)), call_arg.pos);
		}
	}
	if (f.generic_names.len != call_expr->generic_types.len) {
		v__checker__Checker_infer_fn_types(c, f, call_expr);
	}
	if (call_expr->generic_types.len > 0 && f.return_type != 0) {
		Option_v__ast__Type _t1960;
		if (_t1960 = v__ast__Table_resolve_generic_by_names(c->table, f.return_type, f.generic_names, call_expr->generic_types), _t1960.state == 0) {
			v__ast__Type typ = *(v__ast__Type*)_t1960.data;
			call_expr->return_type = typ;
			// autofree_scope_vars(pos=81294 line_nr=2245 scope.pos=81259 scope.end_pos=81308)
			// af parent scope:
			// var "typ" var.pos=81162 var.line_nr=2243
			// af parent scope:
			// af parent scope:
			// var "c" var.pos=69242 var.line_nr=1919
			// var "call_expr" var.pos=69265 var.line_nr=1919
			// var "fn_name" var.pos=69301 var.line_nr=1920
			// var "has_generic_generic" var.pos=69562 var.line_nr=1928
			// var "generic_types" var.pos=69630 var.line_nr=1929
			// var "f" var.pos=71029 var.line_nr=1970
			// var "found" var.pos=71048 var.line_nr=1971
			// var "found_in_args" var.pos=71068 var.line_nr=1972
			// af parent scope:
			// af parent scope:
			return typ;
		}
	}
	if (call_expr->generic_types.len > 0 && f.generic_names.len == 0) {
		v__checker__Checker_error(c, _SLIT("a non generic function called like a generic one"), call_expr->generic_list_pos);
	}
	if (call_expr->generic_types.len > f.generic_names.len) {
		v__checker__Checker_error(c, _STR("too many generic parameters got %"PRId32"\000, expected %"PRId32"", 2, call_expr->generic_types.len, f.generic_names.len), call_expr->generic_list_pos);
	}
	if (f.generic_names.len > 0) {
		 v__ast__Type _t1961 = call_expr->return_type;
		// autofree_scope_vars(pos=81699 line_nr=2257 scope.pos=81696 scope.end_pos=81730)
		// af parent scope:
		// var "c" var.pos=69242 var.line_nr=1919
		// var "call_expr" var.pos=69265 var.line_nr=1919
		// var "fn_name" var.pos=69301 var.line_nr=1920
		// var "has_generic_generic" var.pos=69562 var.line_nr=1928
		// var "generic_types" var.pos=69630 var.line_nr=1929
		// var "f" var.pos=71029 var.line_nr=1970
		// var "found" var.pos=71048 var.line_nr=1971
		// var "found_in_args" var.pos=71068 var.line_nr=1972
		// af parent scope:
		// af parent scope:
		return _t1961;
	}
	 v__ast__Type _t1962 = f.return_type;
	// autofree_scope_vars(pos=81732 line_nr=2259 scope.pos=69237 scope.end_pos=81754)
	// var "c" var.pos=69242 var.line_nr=1919
	// var "call_expr" var.pos=69265 var.line_nr=1919
	// var "fn_name" var.pos=69301 var.line_nr=1920
	// var "has_generic_generic" var.pos=69562 var.line_nr=1928
	// var "generic_types" var.pos=69630 var.line_nr=1929
	// var "f" var.pos=71029 var.line_nr=1970
	// var "found" var.pos=71048 var.line_nr=1971
	// var "found_in_args" var.pos=71068 var.line_nr=1972
	// af parent scope:
	// af parent scope:
	return _t1962;
}

VV_LOCAL_SYMBOL void v__checker__Checker_deprecate_fnmethod(v__checker__Checker* c, string kind, string name, v__ast__Fn the_fn, v__ast__CallExpr call_expr) {
	string start_message = _STR("%.*s\000 `%.*s\000`", 3, kind, name);
	string deprecation_message = _SLIT("");
	time__Time now = time__now();
	time__Time after_time = now;
	// FOR IN array
	for (int _t1963 = 0; _t1963 < the_fn.attrs.len; ++_t1963) {
		v__ast__Attr attr = ((v__ast__Attr*)the_fn.attrs.data)[_t1963];
		if (string_eq(attr.name, _SLIT("deprecated")) && (attr.arg).len != 0) {
			deprecation_message = attr.arg;
		}
		if (string_eq(attr.name, _SLIT("deprecated_after")) && (attr.arg).len != 0) {
			Option_time__Time _t1964 = time__parse_iso8601(attr.arg);
			if (_t1964.state != 0) { /*or block*/ 
				IError err = _t1964.err;
				v__checker__Checker_error(c, _SLIT("invalid time format"), attr.pos);
				*(time__Time*) _t1964.data = time__now();
			}
 			after_time =  *(time__Time*)_t1964.data;
		}
	}
	if (time__Time__lt(after_time, now)) {
		v__checker__Checker_warn(c, v__checker__semicolonize(_STR("%.*s\000 has been deprecated since %.*s", 2, start_message, time__Time_ymmdd(after_time)), deprecation_message), call_expr.pos);
	} else if (time__Time_struct_eq(after_time, now)) {
		v__checker__Checker_warn(c, v__checker__semicolonize(_STR("%.*s\000 has been deprecated", 2, start_message), deprecation_message), call_expr.pos);
	} else {
		v__checker__Checker_note(c, v__checker__semicolonize(_STR("%.*s\000 will be deprecated after %.*s", 2, start_message, time__Time_ymmdd(after_time)), deprecation_message), call_expr.pos);
	}
}

VV_LOCAL_SYMBOL string v__checker__semicolonize(string main, string details) {
	if ((details).len == 0) {
		// autofree_scope_vars(pos=82761 line_nr=2292 scope.pos=82758 scope.end_pos=82775)
		// af parent scope:
		// var "main" var.pos=82702 var.line_nr=2290
		// var "details" var.pos=82715 var.line_nr=2290
		// af parent scope:
		// af parent scope:
		return main;
	}
	 string _t1965 = _STR("%.*s\000; %.*s", 2, main, details);
	// autofree_scope_vars(pos=82777 line_nr=2294 scope.pos=82689 scope.end_pos=82803)
	// var "main" var.pos=82702 var.line_nr=2290
	// var "details" var.pos=82715 var.line_nr=2290
	// af parent scope:
	// af parent scope:
	return _t1965;
}

VV_LOCAL_SYMBOL bool v__checker__Checker_type_implements(v__checker__Checker* c, v__ast__Type typ, v__ast__Type inter_typ, v__token__Position pos) {
	v__ast__Type utyp = v__checker__Checker_unwrap_generic(c, typ);
	v__ast__TypeSymbol* typ_sym = v__ast__Table_get_type_symbol(c->table, utyp);
	v__ast__TypeSymbol* inter_sym = v__ast__Table_get_type_symbol(c->table, inter_typ);
	if ((inter_sym->info)._typ == 410 /* v.ast.Interface */) {
		// FOR IN array
		for (int _t1966 = 0; _t1966 < (*inter_sym->info._v__ast__Interface).types.len; ++_t1966) {
			v__ast__Type t = ((v__ast__Type*)(*inter_sym->info._v__ast__Interface).types.data)[_t1966];
			if (v__ast__Type_idx(t) == v__ast__Type_idx(utyp)) {
				 bool _t1967 = true;
				// autofree_scope_vars(pos=83309 line_nr=2308 scope.pos=83304 scope.end_pos=83325)
				// af parent scope:
				// var "t" var.pos=83248 var.line_nr=2306
				// skipping tmp var "t"
				// af parent scope:
				// af parent scope:
				// var "c" var.pos=82814 var.line_nr=2297
				// var "typ" var.pos=82841 var.line_nr=2297
				// var "inter_typ" var.pos=82855 var.line_nr=2297
				// var "pos" var.pos=82875 var.line_nr=2297
				// var "utyp" var.pos=83029 var.line_nr=2301
				// var "typ_sym" var.pos=83060 var.line_nr=2302
				// var "inter_sym" var.pos=83106 var.line_nr=2303
				// var "styp" var.pos=83335 var.line_nr=2312
				// var "imethods" var.pos=83785 var.line_nr=2325
				// af parent scope:
				// af parent scope:
				return _t1967;
			}
		}
	}
	string styp = v__ast__Table_type_to_str(c->table, utyp);
	if (v__ast__Type_idx(utyp) == v__ast__Type_idx(inter_typ)) {
		 bool _t1968 = true;
		// autofree_scope_vars(pos=83456 line_nr=2315 scope.pos=83403 scope.end_pos=83470)
		// af parent scope:
		// var "c" var.pos=82814 var.line_nr=2297
		// var "typ" var.pos=82841 var.line_nr=2297
		// var "inter_typ" var.pos=82855 var.line_nr=2297
		// var "pos" var.pos=82875 var.line_nr=2297
		// var "utyp" var.pos=83029 var.line_nr=2301
		// var "typ_sym" var.pos=83060 var.line_nr=2302
		// var "inter_sym" var.pos=83106 var.line_nr=2303
		// var "styp" var.pos=83335 var.line_nr=2312
		// var "imethods" var.pos=83785 var.line_nr=2325
		// af parent scope:
		// af parent scope:
		return _t1968;
	}
	if (v__ast__Type_idx(inter_typ) == _const_v__ast__error_type_idx && v__ast__Type_idx(utyp) == _const_v__ast__none_type_idx) {
		 bool _t1969 = true;
		// autofree_scope_vars(pos=83597 line_nr=2319 scope.pos=83549 scope.end_pos=83611)
		// af parent scope:
		// var "c" var.pos=82814 var.line_nr=2297
		// var "typ" var.pos=82841 var.line_nr=2297
		// var "inter_typ" var.pos=82855 var.line_nr=2297
		// var "pos" var.pos=82875 var.line_nr=2297
		// var "utyp" var.pos=83029 var.line_nr=2301
		// var "typ_sym" var.pos=83060 var.line_nr=2302
		// var "inter_sym" var.pos=83106 var.line_nr=2303
		// var "styp" var.pos=83335 var.line_nr=2312
		// var "imethods" var.pos=83785 var.line_nr=2325
		// af parent scope:
		// af parent scope:
		return _t1969;
	}
	if (typ_sym->kind == v__ast__Kind_interface_ && inter_sym->kind == v__ast__Kind_interface_) {
		v__checker__Checker_error(c, _STR("cannot implement interface `%.*s\000` with a different interface `%.*s\000`", 3, inter_sym->name, styp), pos);
	}
	Array_v__ast__Fn imethods = (inter_sym->kind == v__ast__Kind_interface_ ? ((/* as */ *(v__ast__Interface*)__as_cast((inter_sym->info)._v__ast__Interface,(inter_sym->info)._typ, 410) /*expected idx: 410, name: v.ast.Interface */ ).methods) : (inter_sym->methods));
	// FOR IN array
	for (int _t1970 = 0; _t1970 < imethods.len; ++_t1970) {
		v__ast__Fn imethod = ((v__ast__Fn*)imethods.data)[_t1970];
		Option_v__ast__Fn _t1971;
		if (_t1971 = v__ast__TypeSymbol_find_method(typ_sym, imethod.name), _t1971.state == 0) {
			v__ast__Fn method = *(v__ast__Fn*)_t1971.data;
			string msg = v__ast__Table_is_same_method(c->table, (voidptr)&/*qq*/imethod, (voidptr)&/*qq*/method);
			if (msg.len > 0) {
				string sig = v__ast__Table_fn_signature(c->table, (voidptr)&/*qq*/imethod, (v__ast__FnSignatureOpts){.skip_receiver = true,.type_only = 0,});
				v__checker__Checker_add_error_detail(c, _STR("%.*s\000 has `%.*s\000`", 3, inter_sym->name, sig));
				v__checker__Checker_error(c, _STR("`%.*s\000` incorrectly implements method `%.*s\000` of interface `%.*s\000`: %.*s", 4, styp, imethod.name, inter_sym->name, msg), pos);
				 bool _t1972 = false;
				// autofree_scope_vars(pos=84291 line_nr=2338 scope.pos=84055 scope.end_pos=84308)
				// var "sig" var.pos=84061 var.line_nr=2334
				// af parent scope:
				// var "msg" var.pos=83990 var.line_nr=2332
				// af parent scope:
				// var "method" var.pos=83941 var.line_nr=2331
				// af parent scope:
				// var "imethod" var.pos=83914 var.line_nr=2330
				// skipping tmp var "imethod"
				// af parent scope:
				// var "c" var.pos=82814 var.line_nr=2297
				// var "typ" var.pos=82841 var.line_nr=2297
				// var "inter_typ" var.pos=82855 var.line_nr=2297
				// var "pos" var.pos=82875 var.line_nr=2297
				// var "utyp" var.pos=83029 var.line_nr=2301
				// var "typ_sym" var.pos=83060 var.line_nr=2302
				// var "inter_sym" var.pos=83106 var.line_nr=2303
				// var "styp" var.pos=83335 var.line_nr=2312
				// var "imethods" var.pos=83785 var.line_nr=2325
				// af parent scope:
				// af parent scope:
				return _t1972;
			}
			continue;
		}
		v__checker__Checker_error(c, _STR("`%.*s\000` doesn't implement method `%.*s\000` of interface `%.*s\000`", 4, styp, imethod.name, inter_sym->name), pos);
	}
	if ((inter_sym->info)._typ == 410 /* v.ast.Interface */) {
		// FOR IN array
		for (int _t1973 = 0; _t1973 < (*inter_sym->info._v__ast__Interface).fields.len; ++_t1973) {
			v__ast__StructField ifield = ((v__ast__StructField*)(*inter_sym->info._v__ast__Interface).fields.data)[_t1973];
			Option_v__ast__StructField _t1974;
			if (_t1974 = v__ast__Table_find_field_with_embeds(c->table, typ_sym, ifield.name), _t1974.state == 0) {
				v__ast__StructField field = *(v__ast__StructField*)_t1974.data;
				if (!v__ast__Type_alias_eq(ifield.typ, field.typ)) {
					string exp = v__ast__Table_type_to_str(c->table, ifield.typ);
					string got = v__ast__Table_type_to_str(c->table, field.typ);
					v__checker__Checker_error(c, _STR("`%.*s\000` incorrectly implements field `%.*s\000` of interface `%.*s\000`, expected `%.*s\000`, got `%.*s\000`", 6, styp, ifield.name, inter_sym->name, exp, got), pos);
					 bool _t1975 = false;
					// autofree_scope_vars(pos=84845 line_nr=2353 scope.pos=84613 scope.end_pos=84863)
					// var "exp" var.pos=84620 var.line_nr=2349
					// var "got" var.pos=84664 var.line_nr=2350
					// af parent scope:
					// af parent scope:
					// var "field" var.pos=84518 var.line_nr=2347
					// af parent scope:
					// var "ifield" var.pos=84478 var.line_nr=2346
					// skipping tmp var "ifield"
					// af parent scope:
					// af parent scope:
					// var "c" var.pos=82814 var.line_nr=2297
					// var "typ" var.pos=82841 var.line_nr=2297
					// var "inter_typ" var.pos=82855 var.line_nr=2297
					// var "pos" var.pos=82875 var.line_nr=2297
					// var "utyp" var.pos=83029 var.line_nr=2301
					// var "typ_sym" var.pos=83060 var.line_nr=2302
					// var "inter_sym" var.pos=83106 var.line_nr=2303
					// var "styp" var.pos=83335 var.line_nr=2312
					// var "imethods" var.pos=83785 var.line_nr=2325
					// af parent scope:
					// af parent scope:
					return _t1975;
				} else if (ifield.is_mut && !(field.is_mut || field.is_global)) {
					v__checker__Checker_error(c, _STR("`%.*s\000` incorrectly implements interface `%.*s\000`, field `%.*s\000` must be mutable", 4, styp, inter_sym->name, ifield.name), pos);
					 bool _t1976 = false;
					// autofree_scope_vars(pos=85055 line_nr=2357 scope.pos=84925 scope.end_pos=85073)
					// af parent scope:
					// af parent scope:
					// var "field" var.pos=84518 var.line_nr=2347
					// af parent scope:
					// var "ifield" var.pos=84478 var.line_nr=2346
					// skipping tmp var "ifield"
					// af parent scope:
					// af parent scope:
					// var "c" var.pos=82814 var.line_nr=2297
					// var "typ" var.pos=82841 var.line_nr=2297
					// var "inter_typ" var.pos=82855 var.line_nr=2297
					// var "pos" var.pos=82875 var.line_nr=2297
					// var "utyp" var.pos=83029 var.line_nr=2301
					// var "typ_sym" var.pos=83060 var.line_nr=2302
					// var "inter_sym" var.pos=83106 var.line_nr=2303
					// var "styp" var.pos=83335 var.line_nr=2312
					// var "imethods" var.pos=83785 var.line_nr=2325
					// af parent scope:
					// af parent scope:
					return _t1976;
				}
				continue;
			}
			v__checker__Checker_error(c, _STR("`%.*s\000` doesn't implement field `%.*s\000` of interface `%.*s\000`", 4, styp, ifield.name, inter_sym->name), pos);
		}
		array_push(&(*inter_sym->info._v__ast__Interface).types, _MOV((v__ast__Type[]){ utyp }));
	}
	 bool _t1978 = true;
	// autofree_scope_vars(pos=85232 line_nr=2366 scope.pos=82809 scope.end_pos=85245)
	// var "c" var.pos=82814 var.line_nr=2297
	// var "typ" var.pos=82841 var.line_nr=2297
	// var "inter_typ" var.pos=82855 var.line_nr=2297
	// var "pos" var.pos=82875 var.line_nr=2297
	// var "utyp" var.pos=83029 var.line_nr=2301
	// var "typ_sym" var.pos=83060 var.line_nr=2302
	// var "inter_sym" var.pos=83106 var.line_nr=2303
	// var "styp" var.pos=83335 var.line_nr=2312
	// var "imethods" var.pos=83785 var.line_nr=2325
	// af parent scope:
	// af parent scope:
	return _t1978;
}

v__ast__Type v__checker__Checker_check_expr_opt_call(v__checker__Checker* c, v__ast__Expr expr, v__ast__Type ret_type) {
	if ((expr)._typ == 241 /* v.ast.CallExpr */) {
		if (v__ast__Type_has_flag((*expr._v__ast__CallExpr).return_type, v__ast__TypeFlag_optional)) {
			if ((*expr._v__ast__CallExpr).or_block.kind == v__ast__OrKind_absent) {
				v__checker__Checker_error(c, _STR("%.*s\000() returns an option, so it should have either an `or {}` block, or `?` at the end", 2, (*expr._v__ast__CallExpr).name), (*expr._v__ast__CallExpr).pos);
			} else {
				v__checker__Checker_check_or_expr(c, (*expr._v__ast__CallExpr).or_block, ret_type, v__ast__Type_clear_flag((*expr._v__ast__CallExpr).return_type, v__ast__TypeFlag_optional));
			}
			 v__ast__Type _t1979 = v__ast__Type_clear_flag(ret_type, v__ast__TypeFlag_optional);
			// autofree_scope_vars(pos=85748 line_nr=2379 scope.pos=85479 scope.end_pos=85789)
			// af parent scope:
			// var "expr" var.pos=85414 var.line_nr=2371
			// af parent scope:
			// var "c" var.pos=85334 var.line_nr=2370
			// var "expr" var.pos=85365 var.line_nr=2370
			// var "ret_type" var.pos=85380 var.line_nr=2370
			// af parent scope:
			// af parent scope:
			return _t1979;
		} else if ((*expr._v__ast__CallExpr).or_block.kind == v__ast__OrKind_block) {
			v__checker__Checker_error(c, _STR("unexpected `or` block, the function `%.*s\000` does not return an optional", 2, (*expr._v__ast__CallExpr).name), (*expr._v__ast__CallExpr).or_block.pos);
		} else if ((*expr._v__ast__CallExpr).or_block.kind == v__ast__OrKind_propagate) {
			v__checker__Checker_error(c, _STR("unexpected `?`, the function `%.*s\000` does not return an optional", 2, (*expr._v__ast__CallExpr).name), (*expr._v__ast__CallExpr).or_block.pos);
		}
	} else if ((expr)._typ == 257 /* v.ast.IndexExpr */) {
		if ((*expr._v__ast__IndexExpr).or_expr.kind != v__ast__OrKind_absent) {
			v__checker__Checker_check_or_expr(c, (*expr._v__ast__IndexExpr).or_expr, ret_type, ret_type);
		}
	}
	// autofree_scope_vars(pos=86233 line_nr=2392 scope.pos=85329 scope.end_pos=86250)
	// var "c" var.pos=85334 var.line_nr=2370
	// var "expr" var.pos=85365 var.line_nr=2370
	// var "ret_type" var.pos=85380 var.line_nr=2370
	// af parent scope:
	// af parent scope:
	return ret_type;
}

void v__checker__Checker_check_or_expr(v__checker__Checker* c, v__ast__OrExpr or_expr, v__ast__Type ret_type, v__ast__Type expr_return_type) {
	if (or_expr.kind == v__ast__OrKind_propagate) {
		if (!v__ast__Type_has_flag(c->cur_fn->return_type, v__ast__TypeFlag_optional) && string_ne(c->cur_fn->name, _SLIT("main.main")) && !c->inside_const) {
			v__checker__Checker_error(c, _STR("to propagate the optional call, `%.*s\000` must return an optional", 2, c->cur_fn->name), or_expr.pos);
		}
		return;
	}
	int stmts_len = or_expr.stmts.len;
	if (stmts_len == 0) {
		if (!v__ast__Type_alias_eq(ret_type, _const_v__ast__void_type)) {
			v__checker__Checker_error(c, _SLIT("assignment requires a non empty `or {}` block"), or_expr.pos);
		}
		return;
	}
	v__ast__Stmt last_stmt = (*(v__ast__Stmt*)/*ee elem_typ */array_get(or_expr.stmts, stmts_len - 1));
	if (!v__ast__Type_alias_eq(ret_type, _const_v__ast__void_type)) {
		if (last_stmt._typ == 293 /* v.ast.ExprStmt */) {
			c->expected_type = ret_type;
			c->expected_or_type = v__ast__Type_clear_flag(ret_type, v__ast__TypeFlag_optional);
			v__ast__Type last_stmt_typ = v__checker__Checker_expr(c, (*last_stmt._v__ast__ExprStmt).expr);
			c->expected_or_type = _const_v__ast__void_type;
			bool type_fits = v__checker__Checker_check_types(c, last_stmt_typ, ret_type) && v__ast__Type_nr_muls(last_stmt_typ) == v__ast__Type_nr_muls(ret_type);
			bool is_panic_or_exit = v__checker__is_expr_panic_or_exit((*last_stmt._v__ast__ExprStmt).expr);
			if (type_fits || is_panic_or_exit) {
				return;
			}
			string expected_type_name = v__ast__Table_type_to_str(c->table, v__ast__Type_clear_flag(ret_type, v__ast__TypeFlag_optional));
			if (v__ast__Type_alias_eq((*last_stmt._v__ast__ExprStmt).typ, _const_v__ast__void_type)) {
				v__checker__Checker_error(c, _STR("`or` block must provide a default value of type `%.*s\000`, or return/exit/continue/break/panic", 2, expected_type_name), (*last_stmt._v__ast__ExprStmt).pos);
			} else {
				string type_name = v__ast__Table_type_to_str(c->table, last_stmt_typ);
				v__checker__Checker_error(c, _STR("wrong return type `%.*s\000` in the `or {}` block, expected `%.*s\000`", 3, type_name, expected_type_name), (*last_stmt._v__ast__ExprStmt).pos);
			}
			return;
		}
		else if (last_stmt._typ == 287 /* v.ast.BranchStmt */) {
			if (!((*last_stmt._v__ast__BranchStmt).kind == v__token__Kind_key_continue || (*last_stmt._v__ast__BranchStmt).kind == v__token__Kind_key_break)) {
				v__checker__Checker_error(c, _SLIT("only break/continue is allowed as a branch statement in the end of an `or {}` block"), (*last_stmt._v__ast__BranchStmt).pos);
				return;
			}
		}
		else if (last_stmt._typ == 305 /* v.ast.Return */) {
		}
		else {
			string expected_type_name = v__ast__Table_type_to_str(c->table, v__ast__Type_clear_flag(ret_type, v__ast__TypeFlag_optional));
			v__checker__Checker_error(c, _STR("last statement in the `or {}` block should be an expression of type `%.*s\000` or exit parent scope", 2, expected_type_name), or_expr.pos);
			return;
		};
	} else {
		if (last_stmt._typ == 293 /* v.ast.ExprStmt */) {
			if (v__ast__Type_alias_eq((*last_stmt._v__ast__ExprStmt).typ, _const_v__ast__void_type)) {
				return;
			}
			if (v__checker__is_expr_panic_or_exit((*last_stmt._v__ast__ExprStmt).expr)) {
				return;
			}
			if (v__checker__Checker_check_types(c, (*last_stmt._v__ast__ExprStmt).typ, expr_return_type)) {
				return;
			}
			string type_name = v__ast__Table_type_to_str(c->table, (*last_stmt._v__ast__ExprStmt).typ);
			string expr_return_type_name = v__ast__Table_type_to_str(c->table, expr_return_type);
			v__checker__Checker_error(c, _STR("the default expression type in the `or` block should be `%.*s\000`, instead you gave a value of type `%.*s\000`", 3, expr_return_type_name, type_name), v__ast__Expr_position((*last_stmt._v__ast__ExprStmt).expr));
		}
		else {
		};
	}
}

VV_LOCAL_SYMBOL bool v__checker__is_expr_panic_or_exit(v__ast__Expr expr) {
	if (expr._typ == 241 /* v.ast.CallExpr */) {
		 bool _t1980 = (string_eq((*expr._v__ast__CallExpr).name, _SLIT("panic")) || string_eq((*expr._v__ast__CallExpr).name, _SLIT("exit")));
		// autofree_scope_vars(pos=88992 line_nr=2478 scope.pos=88978 scope.end_pos=89031)
		// var "expr" var.pos=88969 var.line_nr=2477
		// af parent scope:
		// var "expr" var.pos=88940 var.line_nr=2476
		// af parent scope:
		// af parent scope:
		return _t1980;
	}
	else {
		 bool _t1981 = false;
		// autofree_scope_vars(pos=89041 line_nr=2479 scope.pos=89035 scope.end_pos=89055)
		// af parent scope:
		// var "expr" var.pos=88940 var.line_nr=2476
		// af parent scope:
		// af parent scope:
		return _t1981;
	};
	return 0;
}

v__ast__Type v__checker__Checker_selector_expr(v__checker__Checker* c, v__ast__SelectorExpr* selector_expr) {
	bool prevent_sum_type_unwrapping_once = c->prevent_sum_type_unwrapping_once;
	c->prevent_sum_type_unwrapping_once = false;
	bool using_new_err_struct_save = c->using_new_err_struct;
	if (string_eq(_STR("%.*s", 1, v__ast__Expr_str(selector_expr->expr)), _SLIT("err"))) {
		c->using_new_err_struct = true;
	}
	int name_type = 0;
	if (selector_expr->expr._typ == 254 /* v.ast.Ident */) {
		string name = (*selector_expr->expr._v__ast__Ident).name;
		bool valid_generic = v__util__is_generic_type_name(name) && (Array_string_contains(c->cur_fn->generic_names, name));
		if (valid_generic) {
			name_type = v__ast__Type_set_flag(((v__ast__Table_find_type_idx(c->table, name))), v__ast__TypeFlag_generic);
		}
	}
	else if (selector_expr->expr._typ == 280 /* v.ast.TypeOf */) {
		name_type = v__checker__Checker_expr(c, (*selector_expr->expr._v__ast__TypeOf).expr);
	}
	else {
	};
	if (name_type > 0) {
		if (string_ne(selector_expr->field_name, _SLIT("name"))) {
			v__checker__Checker_error(c, _STR("invalid field `.%.*s\000` for type `%.*s\000`", 3, selector_expr->field_name, v__ast__Expr_str(selector_expr->expr)), selector_expr->pos);
		}
		selector_expr->name_type = name_type;
		// autofree_scope_vars(pos=90181 line_nr=2516 scope.pos=89983 scope.end_pos=90206)
		// af parent scope:
		// var "c" var.pos=89075 var.line_nr=2483
		// var "selector_expr" var.pos=89104 var.line_nr=2483
		// var "prevent_sum_type_unwrapping_once" var.pos=89148 var.line_nr=2484
		// var "using_new_err_struct_save" var.pos=89265 var.line_nr=2487
		// var "name_type" var.pos=89482 var.line_nr=2494
		// var "old_selector_expr" var.pos=90213 var.line_nr=2519
		// var "typ" var.pos=90289 var.line_nr=2521
		// var "field_name" var.pos=90852 var.line_nr=2535
		// var "utyp" var.pos=90892 var.line_nr=2536
		// var "sym" var.pos=90923 var.line_nr=2537
		// var "unknown_field_msg" var.pos=91299 var.line_nr=2548
		// var "has_field" var.pos=91381 var.line_nr=2549
		// var "field" var.pos=91405 var.line_nr=2550
		// af parent scope:
		// af parent scope:
		return _const_v__ast__string_type;
	}
	bool old_selector_expr = c->inside_selector_expr;
	c->inside_selector_expr = true;
	v__ast__Type typ = v__checker__Checker_expr(c, selector_expr->expr);
	c->inside_selector_expr = old_selector_expr;
	c->using_new_err_struct = using_new_err_struct_save;
	if (typ == _const_v__ast__void_type_idx) {
		v__checker__Checker_error(c, _SLIT("unknown selector expression"), selector_expr->pos);
		// autofree_scope_vars(pos=90515 line_nr=2527 scope.pos=90452 scope.end_pos=90538)
		// af parent scope:
		// var "c" var.pos=89075 var.line_nr=2483
		// var "selector_expr" var.pos=89104 var.line_nr=2483
		// var "prevent_sum_type_unwrapping_once" var.pos=89148 var.line_nr=2484
		// var "using_new_err_struct_save" var.pos=89265 var.line_nr=2487
		// var "name_type" var.pos=89482 var.line_nr=2494
		// var "old_selector_expr" var.pos=90213 var.line_nr=2519
		// var "typ" var.pos=90289 var.line_nr=2521
		// var "field_name" var.pos=90852 var.line_nr=2535
		// var "utyp" var.pos=90892 var.line_nr=2536
		// var "sym" var.pos=90923 var.line_nr=2537
		// var "unknown_field_msg" var.pos=91299 var.line_nr=2548
		// var "has_field" var.pos=91381 var.line_nr=2549
		// var "field" var.pos=91405 var.line_nr=2550
		// af parent scope:
		// af parent scope:
		return _const_v__ast__void_type;
	}
	selector_expr->expr_type = typ;
	if (v__ast__Type_has_flag(selector_expr->expr_type, v__ast__TypeFlag_optional) && !(((selector_expr->expr)._typ == 254 /* v.ast.Ident */ && (/* as */ *(v__ast__Ident*)__as_cast((selector_expr->expr)._v__ast__Ident,(selector_expr->expr)._typ, 254) /*expected idx: 254, name: v.ast.Ident */ ).kind == v__ast__IdentKind_constant))) {
		v__checker__Checker_error(c, _SLIT("cannot access fields of an optional, handle the error with `or {...}` or propagate it with `?`"), selector_expr->pos);
	}
	string field_name = selector_expr->field_name;
	v__ast__Type utyp = v__checker__Checker_unwrap_generic(c, typ);
	v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(c->table, utyp);
	if (v__ast__Type_has_flag(typ, v__ast__TypeFlag_variadic) || sym->kind == v__ast__Kind_array_fixed || sym->kind == v__ast__Kind_chan) {
		if (string_eq(field_name, _SLIT("len")) || (sym->kind == v__ast__Kind_chan && string_eq(field_name, _SLIT("cap")))) {
			selector_expr->typ = _const_v__ast__int_type;
			// autofree_scope_vars(pos=91150 line_nr=2541 scope.pos=91110 scope.end_pos=91173)
			// af parent scope:
			// af parent scope:
			// var "c" var.pos=89075 var.line_nr=2483
			// var "selector_expr" var.pos=89104 var.line_nr=2483
			// var "prevent_sum_type_unwrapping_once" var.pos=89148 var.line_nr=2484
			// var "using_new_err_struct_save" var.pos=89265 var.line_nr=2487
			// var "name_type" var.pos=89482 var.line_nr=2494
			// var "old_selector_expr" var.pos=90213 var.line_nr=2519
			// var "typ" var.pos=90289 var.line_nr=2521
			// var "field_name" var.pos=90852 var.line_nr=2535
			// var "utyp" var.pos=90892 var.line_nr=2536
			// var "sym" var.pos=90923 var.line_nr=2537
			// var "unknown_field_msg" var.pos=91299 var.line_nr=2548
			// var "has_field" var.pos=91381 var.line_nr=2549
			// var "field" var.pos=91405 var.line_nr=2550
			// af parent scope:
			// af parent scope:
			return _const_v__ast__int_type;
		}
		if (sym->kind == v__ast__Kind_chan && string_eq(field_name, _SLIT("closed"))) {
			selector_expr->typ = _const_v__ast__bool_type;
			// autofree_scope_vars(pos=91265 line_nr=2545 scope.pos=91224 scope.end_pos=91289)
			// af parent scope:
			// af parent scope:
			// var "c" var.pos=89075 var.line_nr=2483
			// var "selector_expr" var.pos=89104 var.line_nr=2483
			// var "prevent_sum_type_unwrapping_once" var.pos=89148 var.line_nr=2484
			// var "using_new_err_struct_save" var.pos=89265 var.line_nr=2487
			// var "name_type" var.pos=89482 var.line_nr=2494
			// var "old_selector_expr" var.pos=90213 var.line_nr=2519
			// var "typ" var.pos=90289 var.line_nr=2521
			// var "field_name" var.pos=90852 var.line_nr=2535
			// var "utyp" var.pos=90892 var.line_nr=2536
			// var "sym" var.pos=90923 var.line_nr=2537
			// var "unknown_field_msg" var.pos=91299 var.line_nr=2548
			// var "has_field" var.pos=91381 var.line_nr=2549
			// var "field" var.pos=91405 var.line_nr=2550
			// af parent scope:
			// af parent scope:
			return _const_v__ast__bool_type;
		}
	}
	string unknown_field_msg = _STR("type `%.*s\000` has no field or method `%.*s\000`", 3, sym->name, field_name);
	bool has_field = false;
	v__ast__StructField field = (v__ast__StructField){.pos = {0},.type_pos = {0},.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.default_expr = {0},.has_default_expr = 0,.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.is_pub = 0,.default_val = (string){.str=(byteptr)"", .is_lit=1},.is_mut = 0,.is_global = 0,.default_expr_typ = 0,.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,};
	if (field_name.len > 0 && byte_is_capital(string_at(field_name, 0)) && (sym->info)._typ == 409 /* v.ast.Struct */ && sym->language == v__ast__Language_v) {
		v__ast__Struct sym_info = /* as */ *(v__ast__Struct*)__as_cast((sym->info)._v__ast__Struct,(sym->info)._typ, 409) /*expected idx: 409, name: v.ast.Struct */ ;
		// FOR IN array
		for (int _t1982 = 0; _t1982 < sym_info.embeds.len; ++_t1982) {
			v__ast__Type embed = ((v__ast__Type*)sym_info.embeds.data)[_t1982];
			v__ast__TypeSymbol* embed_sym = v__ast__Table_get_type_symbol(c->table, embed);
			if (string_eq(v__ast__TypeSymbol_embed_name(embed_sym), field_name)) {
				selector_expr->typ = embed;
				// autofree_scope_vars(pos=91775 line_nr=2559 scope.pos=91740 scope.end_pos=91792)
				// af parent scope:
				// var "embed" var.pos=91623 var.line_nr=2555
				// skipping tmp var "embed"
				// var "embed_sym" var.pos=91653 var.line_nr=2556
				// af parent scope:
				// var "sym_info" var.pos=91582 var.line_nr=2554
				// af parent scope:
				// var "c" var.pos=89075 var.line_nr=2483
				// var "selector_expr" var.pos=89104 var.line_nr=2483
				// var "prevent_sum_type_unwrapping_once" var.pos=89148 var.line_nr=2484
				// var "using_new_err_struct_save" var.pos=89265 var.line_nr=2487
				// var "name_type" var.pos=89482 var.line_nr=2494
				// var "old_selector_expr" var.pos=90213 var.line_nr=2519
				// var "typ" var.pos=90289 var.line_nr=2521
				// var "field_name" var.pos=90852 var.line_nr=2535
				// var "utyp" var.pos=90892 var.line_nr=2536
				// var "sym" var.pos=90923 var.line_nr=2537
				// var "unknown_field_msg" var.pos=91299 var.line_nr=2548
				// var "has_field" var.pos=91381 var.line_nr=2549
				// var "field" var.pos=91405 var.line_nr=2550
				// af parent scope:
				// af parent scope:
				return embed;
			}
		}
	} else {
		Option_v__ast__StructField _t1983;
		if (_t1983 = v__ast__Table_find_field(c->table, sym, field_name), _t1983.state == 0) {
			v__ast__StructField f = *(v__ast__StructField*)_t1983.data;
			has_field = true;
			field = f;
		} else {
			IError err = _t1983.err;
			if ((sym->info)._typ == 409 /* v.ast.Struct */) {
				Array_v__ast__StructField found_fields = __new_array_with_default(0, 0, sizeof(v__ast__StructField), 0);
				Array_v__ast__Type embed_of_found_fields = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
				// FOR IN array
				for (int _t1984 = 0; _t1984 < (*sym->info._v__ast__Struct).embeds.len; ++_t1984) {
					v__ast__Type embed = ((v__ast__Type*)(*sym->info._v__ast__Struct).embeds.data)[_t1984];
					v__ast__TypeSymbol* embed_sym = v__ast__Table_get_type_symbol(c->table, embed);
					Option_v__ast__StructField _t1985;
					if (_t1985 = v__ast__Table_find_field(c->table, embed_sym, field_name), _t1985.state == 0) {
						v__ast__StructField f = *(v__ast__StructField*)_t1985.data;
						array_push(&found_fields, _MOV((v__ast__StructField[]){ f }));
						array_push(&embed_of_found_fields, _MOV((v__ast__Type[]){ embed }));
					}
				}
				if (found_fields.len == 1) {
					field = (*(v__ast__StructField*)/*ee elem_typ */array_get(found_fields, 0));
					has_field = true;
					selector_expr->from_embed_type = (*(v__ast__Type*)/*ee elem_typ */array_get(embed_of_found_fields, 0));
				} else if (found_fields.len > 1) {
					v__checker__Checker_error(c, _STR("ambiguous field `%.*s\000`", 2, field_name), selector_expr->pos);
				}
			}
			if ((sym->kind == v__ast__Kind_aggregate || sym->kind == v__ast__Kind_sum_type)) {
				unknown_field_msg = (*(err.msg));
			}
		}
		if (!c->inside_unsafe) {
			if ((sym->info)._typ == 409 /* v.ast.Struct */) {
				if ((*sym->info._v__ast__Struct).is_union && !(Array_v__token__Kind_contains(_const_v__token__assign_tokens, selector_expr->next_token))) {
					v__checker__Checker_warn(c, _SLIT("reading a union field (or its address) requires `unsafe`"), selector_expr->pos);
				}
			}
		}
	}
	if (has_field) {
		if (string_ne(sym->mod, c->mod) && !field.is_pub && sym->language != v__ast__Language_c) {
			v__checker__Checker_error(c, _STR("field `%.*s\000.%.*s\000` is not public", 3, sym->name, field_name), selector_expr->pos);
		}
		v__ast__TypeSymbol* field_sym = v__ast__Table_get_type_symbol(c->table, field.typ);
		if ((field_sym->kind == v__ast__Kind_sum_type || field_sym->kind == v__ast__Kind_interface_)) {
			if (!prevent_sum_type_unwrapping_once) {
				Option_v__ast__ScopeStructField _t1988;
				if (_t1988 = v__ast__Scope_find_struct_field(selector_expr->scope, utyp, field_name), _t1988.state == 0) {
					v__ast__ScopeStructField scope_field = *(v__ast__ScopeStructField*)_t1988.data;
					 v__ast__Type _t1989 = (*(v__ast__Type*)array_last(scope_field.smartcasts));
					// autofree_scope_vars(pos=93245 line_nr=2607 scope.pos=93239 scope.end_pos=93287)
					// af parent scope:
					// var "scope_field" var.pos=93168 var.line_nr=2606
					// af parent scope:
					// af parent scope:
					// af parent scope:
					// var "field_sym" var.pos=93021 var.line_nr=2603
					// af parent scope:
					// var "c" var.pos=89075 var.line_nr=2483
					// var "selector_expr" var.pos=89104 var.line_nr=2483
					// var "prevent_sum_type_unwrapping_once" var.pos=89148 var.line_nr=2484
					// var "using_new_err_struct_save" var.pos=89265 var.line_nr=2487
					// var "name_type" var.pos=89482 var.line_nr=2494
					// var "old_selector_expr" var.pos=90213 var.line_nr=2519
					// var "typ" var.pos=90289 var.line_nr=2521
					// var "field_name" var.pos=90852 var.line_nr=2535
					// var "utyp" var.pos=90892 var.line_nr=2536
					// var "sym" var.pos=90923 var.line_nr=2537
					// var "unknown_field_msg" var.pos=91299 var.line_nr=2548
					// var "has_field" var.pos=91381 var.line_nr=2549
					// var "field" var.pos=91405 var.line_nr=2550
					// af parent scope:
					// af parent scope:
					return _t1989;
				}
			}
		}
		selector_expr->typ = field.typ;
		 v__ast__Type _t1990 = field.typ;
		// autofree_scope_vars(pos=93331 line_nr=2612 scope.pos=92871 scope.end_pos=93350)
		// var "field_sym" var.pos=93021 var.line_nr=2603
		// af parent scope:
		// var "c" var.pos=89075 var.line_nr=2483
		// var "selector_expr" var.pos=89104 var.line_nr=2483
		// var "prevent_sum_type_unwrapping_once" var.pos=89148 var.line_nr=2484
		// var "using_new_err_struct_save" var.pos=89265 var.line_nr=2487
		// var "name_type" var.pos=89482 var.line_nr=2494
		// var "old_selector_expr" var.pos=90213 var.line_nr=2519
		// var "typ" var.pos=90289 var.line_nr=2521
		// var "field_name" var.pos=90852 var.line_nr=2535
		// var "utyp" var.pos=90892 var.line_nr=2536
		// var "sym" var.pos=90923 var.line_nr=2537
		// var "unknown_field_msg" var.pos=91299 var.line_nr=2548
		// var "has_field" var.pos=91381 var.line_nr=2549
		// var "field" var.pos=91405 var.line_nr=2550
		// af parent scope:
		// af parent scope:
		return _t1990;
	}
	if (!(sym->kind == v__ast__Kind_struct_ || sym->kind == v__ast__Kind_aggregate || sym->kind == v__ast__Kind_interface_ || sym->kind == v__ast__Kind_sum_type)) {
		if (sym->kind != v__ast__Kind_placeholder) {
			v__checker__Checker_error(c, _STR("`%.*s\000` has no property `%.*s\000`", 3, sym->name, selector_expr->field_name), selector_expr->pos);
		}
	} else {
		if ((sym->info)._typ == 409 /* v.ast.Struct */) {
			Array_v__ast__StructField _t1991_orig = (*sym->info._v__ast__Struct).fields;
			int _t1991_len = _t1991_orig.len;
			Array_string _t1991 = __new_array(0, _t1991_len, sizeof(string));

			for (int _t1992 = 0; _t1992 < _t1991_len; ++_t1992) {
				v__ast__StructField it = ((v__ast__StructField*) _t1991_orig.data)[_t1992];
				string ti = it.name;
				array_push(&_t1991, &ti);
			}
			
			v__util__Suggestion suggestion = v__util__new_suggestion(field_name, _t1991);
			v__checker__Checker_error(c, v__util__Suggestion_say(suggestion, unknown_field_msg), selector_expr->pos);
		}
		v__checker__Checker_error(c, unknown_field_msg, selector_expr->pos);
	}
	// autofree_scope_vars(pos=93782 line_nr=2625 scope.pos=89070 scope.end_pos=93804)
	// var "c" var.pos=89075 var.line_nr=2483
	// var "selector_expr" var.pos=89104 var.line_nr=2483
	// var "prevent_sum_type_unwrapping_once" var.pos=89148 var.line_nr=2484
	// var "using_new_err_struct_save" var.pos=89265 var.line_nr=2487
	// var "name_type" var.pos=89482 var.line_nr=2494
	// var "old_selector_expr" var.pos=90213 var.line_nr=2519
	// var "typ" var.pos=90289 var.line_nr=2521
	// var "field_name" var.pos=90852 var.line_nr=2535
	// var "utyp" var.pos=90892 var.line_nr=2536
	// var "sym" var.pos=90923 var.line_nr=2537
	// var "unknown_field_msg" var.pos=91299 var.line_nr=2548
	// var "has_field" var.pos=91381 var.line_nr=2549
	// var "field" var.pos=91405 var.line_nr=2550
	// af parent scope:
	// af parent scope:
	return _const_v__ast__void_type;
}

void v__checker__Checker_return_stmt(v__checker__Checker* c, v__ast__Return* return_stmt) {
	c->expected_type = c->cur_fn->return_type;
	v__ast__Type expected_type = v__checker__Checker_unwrap_generic(c, c->expected_type);
	v__ast__TypeSymbol* expected_type_sym = v__ast__Table_get_type_symbol(c->table, expected_type);
	if (return_stmt->exprs.len > 0 && v__ast__Type_alias_eq(c->cur_fn->return_type, _const_v__ast__void_type)) {
		v__checker__Checker_error(c, _SLIT("unexpected argument, current function does not return anything"), v__ast__Expr_position((*(v__ast__Expr*)/*ee elem_typ */array_get(return_stmt->exprs, 0))));
		return;
	} else if (return_stmt->exprs.len == 0 && !(v__ast__Type_alias_eq(c->expected_type, _const_v__ast__void_type) || expected_type_sym->kind == v__ast__Kind_void)) {
		string stype = v__ast__Table_type_to_str(c->table, expected_type);
		string arg = (expected_type_sym->kind == v__ast__Kind_multi_return ? (_SLIT("arguments")) : (_SLIT("argument")));
		v__checker__Checker_error(c, _STR("expected `%.*s\000` %.*s", 2, stype, arg), return_stmt->pos);
		return;
	}
	if (return_stmt->exprs.len == 0) {
		return;
	}
	bool exp_is_optional = v__ast__Type_has_flag(expected_type, v__ast__TypeFlag_optional);
	Array_v__ast__Type expected_types = new_array_from_c_array(1, 1, sizeof(v__ast__Type), _MOV((v__ast__Type[1]){expected_type}));
	if ((expected_type_sym->info)._typ == 417 /* v.ast.MultiReturn */) {
		expected_types = (*expected_type_sym->info._v__ast__MultiReturn).types;
		if (c->cur_generic_types.len > 0) {
			Array_v__ast__Type _t1993_orig = expected_types;
			int _t1993_len = _t1993_orig.len;
			Array_v__ast__Type _t1993 = __new_array(0, _t1993_len, sizeof(v__ast__Type));

			for (int _t1994 = 0; _t1994 < _t1993_len; ++_t1994) {
				v__ast__Type it = ((v__ast__Type*) _t1993_orig.data)[_t1994];
				v__ast__Type ti = v__checker__Checker_unwrap_generic(c, it);
				array_push(&_t1993, &ti);
			}
			
			expected_types = _t1993;
		}
	}
	Array_v__ast__Type got_types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
	// FOR IN array
	for (int _t1995 = 0; _t1995 < return_stmt->exprs.len; ++_t1995) {
		v__ast__Expr expr = ((v__ast__Expr*)return_stmt->exprs.data)[_t1995];
		v__ast__Type typ = v__checker__Checker_expr(c, expr);
		v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(c->table, typ);
		if (sym->kind == v__ast__Kind_multi_return) {
			// FOR IN array
			for (int _t1996 = 0; _t1996 < v__ast__TypeSymbol_mr_info(sym).types.len; ++_t1996) {
				v__ast__Type t = ((v__ast__Type*)v__ast__TypeSymbol_mr_info(sym).types.data)[_t1996];
				array_push(&got_types, _MOV((v__ast__Type[]){ t }));
			}
		} else {
			array_push(&got_types, _MOV((v__ast__Type[]){ typ }));
		}
	}
	return_stmt->types = got_types;
	if (exp_is_optional && (v__ast__Type_idx((*(v__ast__Type*)/*ee elem_typ */array_get(got_types, 0))) == _const_v__ast__none_type_idx || v__ast__Type_idx((*(v__ast__Type*)/*ee elem_typ */array_get(got_types, 0))) == _const_v__ast__error_type_idx || v__ast__Type_idx((*(v__ast__Type*)/*ee elem_typ */array_get(got_types, 0))) == (*(int*)map_get(ADDR(map, c->table->type_idxs), &(string[]){_SLIT("Option")}, &(int[]){ 0 })))) {
		return;
	}
	if (expected_types.len > 0 && expected_types.len != got_types.len) {
		string arg = (expected_types.len == 1 ? (_SLIT("argument")) : (_SLIT("arguments")));
		v__checker__Checker_error(c, _STR("expected %"PRId32"\000 %.*s\000, but got %"PRId32"", 3, expected_types.len, arg, got_types.len), return_stmt->pos);
		return;
	}
	// FOR IN array
	for (int i = 0; i < expected_types.len; ++i) {
		v__ast__Type exp_type = ((v__ast__Type*)expected_types.data)[i];
		v__ast__Type got_typ = v__checker__Checker_unwrap_generic(c, (*(v__ast__Type*)/*ee elem_typ */array_get(got_types, i)));
		if (v__ast__Type_has_flag(got_typ, v__ast__TypeFlag_optional) && (!v__ast__Type_has_flag(exp_type, v__ast__TypeFlag_optional) || string_ne(v__ast__Table_type_to_str(c->table, got_typ), v__ast__Table_type_to_str(c->table, exp_type)))) {
			v__token__Position pos = v__ast__Expr_position((*(v__ast__Expr*)/*ee elem_typ */array_get(return_stmt->exprs, i)));
			v__checker__Checker_error(c, _STR("cannot use `%.*s\000` as type `%.*s\000` in return argument", 3, v__ast__Table_type_to_str(c->table, got_typ), v__ast__Table_type_to_str(c->table, exp_type)), pos);
		}
		if (!v__checker__Checker_check_types(c, got_typ, exp_type)) {
			v__ast__TypeSymbol* got_typ_sym = v__ast__Table_get_type_symbol(c->table, got_typ);
			v__ast__TypeSymbol* exp_typ_sym = v__ast__Table_get_type_symbol(c->table, exp_type);
			v__token__Position pos = v__ast__Expr_position((*(v__ast__Expr*)/*ee elem_typ */array_get(return_stmt->exprs, i)));
			if (v__ast__Expr_is_auto_deref_var((*(v__ast__Expr*)/*ee elem_typ */array_get(return_stmt->exprs, i)))) {
				continue;
			}
			if (exp_typ_sym->kind == v__ast__Kind_interface_) {
				v__checker__Checker_type_implements(c, got_typ, exp_type, return_stmt->pos);
				continue;
			}
			v__checker__Checker_error(c, _STR("cannot use `%.*s\000` as type `%.*s\000` in return argument", 3, got_typ_sym->name, exp_typ_sym->name), pos);
		}
		if ((v__ast__Type_is_ptr(got_typ) || v__ast__Type_is_pointer(got_typ)) && (!v__ast__Type_is_ptr(exp_type) && !v__ast__Type_is_pointer(exp_type))) {
			v__token__Position pos = v__ast__Expr_position((*(v__ast__Expr*)/*ee elem_typ */array_get(return_stmt->exprs, i)));
			if (v__ast__Expr_is_auto_deref_var((*(v__ast__Expr*)/*ee elem_typ */array_get(return_stmt->exprs, i)))) {
				continue;
			}
			v__checker__Checker_error(c, _STR("fn `%.*s\000` expects you to return a non reference type `%.*s\000`, but you are returning `%.*s\000` instead", 4, c->cur_fn->name, v__ast__Table_type_to_str(c->table, exp_type), v__ast__Table_type_to_str(c->table, got_typ)), pos);
		}
		if ((v__ast__Type_is_ptr(exp_type) || v__ast__Type_is_pointer(exp_type)) && (!v__ast__Type_is_ptr(got_typ) && !v__ast__Type_is_pointer(got_typ)) && !v__ast__Type_alias_eq(got_typ, _const_v__ast__int_literal_type)) {
			v__token__Position pos = v__ast__Expr_position((*(v__ast__Expr*)/*ee elem_typ */array_get(return_stmt->exprs, i)));
			if (v__ast__Expr_is_auto_deref_var((*(v__ast__Expr*)/*ee elem_typ */array_get(return_stmt->exprs, i)))) {
				continue;
			}
			v__checker__Checker_error(c, _STR("fn `%.*s\000` expects you to return a reference type `%.*s\000`, but you are returning `%.*s\000` instead", 4, c->cur_fn->name, v__ast__Table_type_to_str(c->table, exp_type), v__ast__Table_type_to_str(c->table, got_typ)), pos);
		}
	}
	if (exp_is_optional && return_stmt->exprs.len > 0) {
		v__ast__Expr expr0 = (*(v__ast__Expr*)/*ee elem_typ */array_get(return_stmt->exprs, 0));
		if ((expr0)._typ == 241 /* v.ast.CallExpr */) {
			if ((*expr0._v__ast__CallExpr).or_block.kind == v__ast__OrKind_propagate) {
				v__checker__Checker_error(c, _STR("`?` is not needed, use `return %.*s\000()`", 2, (*expr0._v__ast__CallExpr).name), (*expr0._v__ast__CallExpr).pos);
			}
		}
	}
}

void v__checker__Checker_const_decl(v__checker__Checker* c, v__ast__ConstDecl* node) {
	Array_string field_names = __new_array_with_default(0, 0, sizeof(string), 0);
	Array_int field_order = __new_array_with_default(0, 0, sizeof(int), 0);
	if (node->fields.len == 0) {
		v__checker__Checker_warn(c, _SLIT("const block must have at least 1 declaration"), node->pos);
	}
	// FOR IN array
	for (int i = 0; i < node->fields.len; ++i) {
		v__ast__ConstField field = ((v__ast__ConstField*)node->fields.data)[i];
		if ((Array_string_contains(c->const_names, field.name))) {
			v__token__Position name_pos = (v__token__Position){.len = v__util__no_cur_mod(field.name, c->mod).len,field.pos.line_nr,field.pos.pos,field.pos.col,field.pos.last_line,};
			v__checker__Checker_error(c, _STR("duplicate const `%.*s\000`", 2, field.name), name_pos);
		}
		array_push(&c->const_names, _MOV((string[]){ string_clone(field.name) }));
		array_push(&field_names, _MOV((string[]){ string_clone(field.name) }));
		array_push(&field_order, _MOV((int[]){ i }));
	}
	bool needs_order = false;
	Array_int done_fields = __new_array_with_default(0, 0, sizeof(int), 0);
	// FOR IN array
	for (int i = 0; i < node->fields.len; ++i) {
		v__ast__ConstField field = ((v__ast__ConstField*)node->fields.data)[i];
		c->const_decl = field.name;
		array_push(&c->const_deps, _MOV((string[]){ string_clone(field.name) }));
		v__ast__Type typ = v__checker__Checker_check_expr_opt_call(c, field.expr, v__checker__Checker_expr(c, field.expr));
		(*(v__ast__ConstField*)/*ee elem_typ */array_get(node->fields, i)).typ = v__ast__Table_mktyp(c->table, typ);
		// FOR IN array
		for (int _t2003 = 0; _t2003 < c->const_deps.len; ++_t2003) {
			string cd = ((string*)c->const_deps.data)[_t2003];
			// FOR IN array
			for (int j = 0; j < node->fields.len; ++j) {
				v__ast__ConstField f = ((v__ast__ConstField*)node->fields.data)[j];
				if (j != i && (Array_string_contains(field_names, cd)) && string_eq(cd, f.name) && !(Array_int_contains(done_fields, j))) {
					needs_order = true;
					int x = (*(int*)/*ee elem_typ */array_get(field_order, j));
					array_set(&field_order, j, &(int[]) { (*(int*)/*ee elem_typ */array_get(field_order, i)) });
					array_set(&field_order, i, &(int[]) { x });
					break;
				}
			}
		}
		array_push(&done_fields, _MOV((int[]){ i }));
		c->const_deps = __new_array_with_default(0, 0, sizeof(string), 0);
	}
	if (needs_order) {
		Array_v__ast__ConstField ordered_fields = __new_array_with_default(0, 0, sizeof(v__ast__ConstField), 0);
		// FOR IN array
		for (int _t2005 = 0; _t2005 < field_order.len; ++_t2005) {
			int order = ((int*)field_order.data)[_t2005];
			array_push(&ordered_fields, _MOV((v__ast__ConstField[]){ (*(v__ast__ConstField*)/*ee elem_typ */array_get(node->fields, order)) }));
		}
		node->fields = ordered_fields;
	}
}

void v__checker__Checker_enum_decl(v__checker__Checker* c, v__ast__EnumDecl decl) {
	v__checker__Checker_check_valid_pascal_case(c, decl.name, _SLIT("enum name"), decl.pos);
	Array_i64 seen = __new_array_with_default(0, 0, sizeof(i64), 0);
	if (decl.fields.len == 0) {
		v__checker__Checker_error(c, _SLIT("enum cannot be empty"), decl.pos);
	}
	// FOR IN array
	for (int i = 0; i < decl.fields.len; ++i) {
		v__ast__EnumField field = ((v__ast__EnumField*)decl.fields.data)[i];
		if (!c->pref->experimental && v__util__contains_capital(field.name)) {
			v__checker__Checker_error(c, _STR("field name `%.*s\000` cannot contain uppercase letters, use snake_case instead", 2, field.name), field.pos);
		}
		for (int j = 0; j < i; ++j) {
			if (string_eq(field.name, (*(v__ast__EnumField*)/*ee elem_typ */array_get(decl.fields, j)).name)) {
				v__checker__Checker_error(c, _STR("field name `%.*s\000` duplicate", 2, field.name), field.pos);
			}
		}
		if (field.has_expr) {
			if (field.expr._typ == 259 /* v.ast.IntegerLiteral */) {
				i64 val = string_i64((*field.expr._v__ast__IntegerLiteral).val);
				if (val < _const_v__checker__int_min || val > _const_v__checker__int_max) {
					v__checker__Checker_error(c, _STR("enum value `%"PRId64"\000` overflows int", 2, val), (*field.expr._v__ast__IntegerLiteral).pos);
				} else if (!decl.is_multi_allowed && (Array_i64_contains(seen, ((i64)(val))))) {
					v__checker__Checker_error(c, _STR("enum value `%"PRId64"\000` already exists", 2, val), (*field.expr._v__ast__IntegerLiteral).pos);
				}
				array_push(&seen, _MOV((i64[]){ ((i64)(val)) }));
			}
			else if (field.expr._typ == 270 /* v.ast.PrefixExpr */) {
			}
			else {
				if ((field.expr)._typ == 254 /* v.ast.Ident */) {
					if ((*field.expr._v__ast__Ident).language == v__ast__Language_c) {
						continue;
					}
				}
				v__token__Position pos = v__ast__Expr_position(field.expr);
				if (pos.pos == 0) {
					pos = field.pos;
				}
				v__checker__Checker_error(c, _SLIT("default value for enum has to be an integer"), pos);
			};
		} else {
			if (seen.len > 0) {
				i64 last = (*(i64*)/*ee elem_typ */array_get(seen, seen.len - 1));
				if (last == _const_v__checker__int_max) {
					v__checker__Checker_error(c, _SLIT("enum value overflows"), field.pos);
				}
				array_push(&seen, _MOV((i64[]){ last + 1 }));
			} else {
				array_push(&seen, _MOV((i64[]){ 0 }));
			}
		}
	}
}

void v__checker__Checker_assign_stmt(v__checker__Checker* c, v__ast__AssignStmt* assign_stmt) {
bool v__checker__Checker_assign_stmt_defer_0 = false;
	c->expected_type = _const_v__ast__none_type;
	v__checker__Checker_assign_stmt_defer_0 = true;
	v__ast__Expr right_first = (*(v__ast__Expr*)/*ee elem_typ */array_get(assign_stmt->right, 0));
	int right_len = assign_stmt->right.len;
	v__ast__Type right_type0 = _const_v__ast__void_type;
	// FOR IN array
	for (int i = 0; i < assign_stmt->right.len; ++i) {
		v__ast__Expr right = ((v__ast__Expr*)assign_stmt->right.data)[i];
		if ((right)._typ == 241 /* v.ast.CallExpr */ || (right)._typ == 255 /* v.ast.IfExpr */ || (right)._typ == 261 /* v.ast.LockExpr */ || (right)._typ == 263 /* v.ast.MatchExpr */) {
			v__ast__Type right_type = v__checker__Checker_expr(c, right);
			if (i == 0) {
				right_type0 = right_type;
				assign_stmt->right_types = new_array_from_c_array(1, 1, sizeof(v__ast__Type), _MOV((v__ast__Type[1]){v__checker__Checker_check_expr_opt_call(c, right, right_type0)}));
			}
			v__ast__TypeSymbol* right_type_sym = v__ast__Table_get_type_symbol(c->table, right_type);
			if (right_type_sym->kind == v__ast__Kind_multi_return) {
				if (assign_stmt->right.len > 1) {
					v__checker__Checker_error(c, _STR("cannot use multi-value %.*s\000 in single-value context", 2, right_type_sym->name), v__ast__Expr_position(right));
				}
				assign_stmt->right_types = v__ast__TypeSymbol_mr_info(right_type_sym).types;
				right_len = assign_stmt->right_types.len;
			} else if (v__ast__Type_alias_eq(right_type, _const_v__ast__void_type)) {
				right_len = 0;
			}
		}
	}
	if (assign_stmt->left.len != right_len) {
		if ((right_first)._typ == 241 /* v.ast.CallExpr */) {
			v__checker__Checker_error(c, _STR("assignment mismatch: %"PRId32"\000 variable(s) but `%.*s\000()` returns %"PRId32"\000 value(s)", 4, assign_stmt->left.len, (*right_first._v__ast__CallExpr).name, right_len), assign_stmt->pos);
		} else {
			v__checker__Checker_error(c, _STR("assignment mismatch: %"PRId32"\000 variable(s) %"PRId32"\000 value(s)", 3, assign_stmt->left.len, right_len), assign_stmt->pos);
		}
		// Defer begin
		if (v__checker__Checker_assign_stmt_defer_0 == true) {
			c->expected_type = _const_v__ast__void_type;
		}
		// Defer end
		return;
	}
	bool is_decl = assign_stmt->op == v__token__Kind_decl_assign;
	// FOR IN array
	for (int i = 0; i < assign_stmt->left.len; ++i) {
		v__ast__Expr left = ((v__ast__Expr*)assign_stmt->left.data)[i];
		if ((left)._typ == 241 /* v.ast.CallExpr */) {
			v__checker__Checker_error(c, _STR("cannot call function `%.*s\000()` on the left side of an assignment", 2, (*left._v__ast__CallExpr).name), (*left._v__ast__CallExpr).pos);
		}
		bool is_blank_ident = v__ast__Expr_is_blank_ident(left);
		v__ast__Type left_type = _const_v__ast__void_type;
		if (!is_decl && !is_blank_ident) {
			if ((left)._typ == 254 /* v.ast.Ident */ || (left)._typ == 273 /* v.ast.SelectorExpr */) {
				c->prevent_sum_type_unwrapping_once = true;
			}
			left_type = v__checker__Checker_expr(c, left);
			c->expected_type = v__checker__Checker_unwrap_generic(c, left_type);
			v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(c->table, left_type);
			if (sym->kind == v__ast__Kind_map && ((*(v__ast__Expr*)/*ee elem_typ */array_get(assign_stmt->right, i)))._typ == 278 /* v.ast.StructInit */) {
				v__checker__Checker_warn(c, _SLIT("assigning a struct literal to a map is deprecated - use `map{}` instead"), v__ast__Expr_position((*(v__ast__Expr*)/*ee elem_typ */array_get(assign_stmt->right, i))));
				(*(v__ast__Expr*)/*ee elem_typ */array_get(assign_stmt->right, i)) = v__ast__MapInit_to_sumtype_v__ast__Expr(ADDR(v__ast__MapInit, ((v__ast__MapInit){.pos = {0},.keys = __new_array(0, 1, sizeof(v__ast__Expr)),.vals = __new_array(0, 1, sizeof(v__ast__Expr)),.comments = __new_array(0, 1, sizeof(Array_v__ast__Comment)),.pre_cmnts = __new_array(0, 1, sizeof(v__ast__Comment)),.typ = 0,.key_type = 0,.value_type = 0,})));
			}
		}
		if (assign_stmt->right_types.len < assign_stmt->left.len) {
			bool old_inside_ref_lit = c->inside_ref_lit;
			if ((left)._typ == 254 /* v.ast.Ident */) {
				if (((*left._v__ast__Ident).info)._typ == 363 /* v.ast.IdentVar */) {
					c->inside_ref_lit = c->inside_ref_lit || (*(*left._v__ast__Ident).info._v__ast__IdentVar).share == v__ast__ShareType_shared_t;
				}
			}
			v__ast__Type right_type = v__checker__Checker_expr(c, (*(v__ast__Expr*)/*ee elem_typ */array_get(assign_stmt->right, i)));
			c->inside_ref_lit = old_inside_ref_lit;
			if (assign_stmt->right_types.len == i) {
				array_push(&assign_stmt->right_types, _MOV((v__ast__Type[]){ v__checker__Checker_check_expr_opt_call(c, (*(v__ast__Expr*)/*ee elem_typ */array_get(assign_stmt->right, i)), right_type) }));
			}
		}
		v__ast__Expr right = (i < assign_stmt->right.len ? ((*(v__ast__Expr*)/*ee elem_typ */array_get(assign_stmt->right, i))) : ((*(v__ast__Expr*)/*ee elem_typ */array_get(assign_stmt->right, 0))));
		v__ast__Type right_type = (*(v__ast__Type*)/*ee elem_typ */array_get(assign_stmt->right_types, i));
		if (is_decl) {
			if (v__ast__Expr_is_auto_deref_var(right)) {
				left_type = v__ast__Table_mktyp(c->table, v__ast__Type_deref(right_type));
			} else {
				left_type = v__ast__Table_mktyp(c->table, right_type);
			}
			if (v__ast__Type_alias_eq(left_type, _const_v__ast__int_type)) {
				if ((right)._typ == 259 /* v.ast.IntegerLiteral */) {
					bool is_large = (*right._v__ast__IntegerLiteral).val.len > 13;
					if (!is_large && (*right._v__ast__IntegerLiteral).val.len > 8) {
						i64 val = string_i64((*right._v__ast__IntegerLiteral).val);
						is_large = val > _const_v__checker__int_max || val < _const_v__checker__int_min;
					}
					if (is_large) {
						v__checker__Checker_error(c, _SLIT("overflow in implicit type `int`, use explicit type casting instead"), (*right._v__ast__IntegerLiteral).pos);
					}
				}
			}
		} else {
			v__checker__Checker_fail_if_immutable(c, left);
		}
		array_push(&assign_stmt->left_types, _MOV((v__ast__Type[]){ left_type }));
		if (left._typ == 254 /* v.ast.Ident */) {
			if ((*left._v__ast__Ident).kind == v__ast__IdentKind_blank_ident) {
				left_type = right_type;
				(*(v__ast__Type*)/*ee elem_typ */array_get(assign_stmt->left_types, i)) = right_type;
				if (!(assign_stmt->op == v__token__Kind_assign || assign_stmt->op == v__token__Kind_decl_assign)) {
					v__checker__Checker_error(c, _SLIT("cannot modify blank `_` identifier"), (*left._v__ast__Ident).pos);
				}
			} else if (((*left._v__ast__Ident).info)._typ != 363 /* v.ast.IdentVar */) {
				v__checker__Checker_error(c, _STR("cannot assign to %.*s\000 `%.*s\000`", 3, v__ast__IdentKind_str((*left._v__ast__Ident).kind), (*left._v__ast__Ident).name), (*left._v__ast__Ident).pos);
			} else {
				if (is_decl) {
					v__checker__Checker_check_valid_snake_case(c, (*left._v__ast__Ident).name, _SLIT("variable name"), (*left._v__ast__Ident).pos);
				}
				v__ast__IdentVar ident_var_info = /* as */ *(v__ast__IdentVar*)__as_cast(((*left._v__ast__Ident).info)._v__ast__IdentVar,((*left._v__ast__Ident).info)._typ, 363) /*expected idx: 363, name: v.ast.IdentVar */ ;
				if (ident_var_info.share == v__ast__ShareType_shared_t) {
					left_type = v__ast__Type_set_flag(left_type, v__ast__TypeFlag_shared_f);
					if (is_decl) {
						if (v__ast__Type_nr_muls(left_type) > 1) {
							v__checker__Checker_error(c, _SLIT("shared cannot be multi level reference"), (*left._v__ast__Ident).pos);
						}
						left_type = v__ast__Type_set_nr_muls(left_type, 1);
					}
				} else if (v__ast__Type_has_flag(left_type, v__ast__TypeFlag_shared_f)) {
					left_type = v__ast__Type_clear_flag(left_type, v__ast__TypeFlag_shared_f);
				}
				if (ident_var_info.share == v__ast__ShareType_atomic_t) {
					left_type = v__ast__Type_set_flag(left_type, v__ast__TypeFlag_atomic_f);
				}
				(*(v__ast__Type*)/*ee elem_typ */array_get(assign_stmt->left_types, i)) = left_type;
				ident_var_info.typ = left_type;
				(*left._v__ast__Ident).info = v__ast__IdentVar_to_sumtype_v__ast__IdentInfo(ADDR(v__ast__IdentVar, (ident_var_info)));
				if (left_type != 0) {
					if ((*left._v__ast__Ident).obj._typ == 312 /* v.ast.Var */) {
						(*(*left._v__ast__Ident).obj._v__ast__Var).typ = left_type;
					}
					else if ((*left._v__ast__Ident).obj._typ == 311 /* v.ast.GlobalField */) {
						(*(*left._v__ast__Ident).obj._v__ast__GlobalField).typ = left_type;
					}
					else {
					};
				}
				if (is_decl) {
					string full_name = _STR("%.*s\000.%.*s", 2, (*left._v__ast__Ident).mod, (*left._v__ast__Ident).name);
					Option_v__ast__ScopeObject _t2012;
					if (_t2012 = v__ast__Scope_find(c->file->global_scope, full_name), _t2012.state == 0) {
						v__ast__ScopeObject obj = *(v__ast__ScopeObject*)_t2012.data;
						if ((obj)._typ == 310 /* v.ast.ConstField */) {
							v__checker__Checker_warn(c, _STR("duplicate of a const name `%.*s\000`", 2, full_name), (*left._v__ast__Ident).pos);
						}
					}
				}
			}
		}
		else if (left._typ == 270 /* v.ast.PrefixExpr */) {
			if ((*left._v__ast__PrefixExpr).op == v__token__Kind_mul && !c->inside_unsafe) {
				v__checker__Checker_error(c, _SLIT("modifying variables via dereferencing can only be done in `unsafe` blocks"), assign_stmt->pos);
			}
			if (is_decl) {
				v__checker__Checker_error(c, _SLIT("non-name on the left side of `:=`"), (*left._v__ast__PrefixExpr).pos);
			}
		}
		else {
			if ((left)._typ == 257 /* v.ast.IndexExpr */) {
				if ((*left._v__ast__IndexExpr).is_map && (*left._v__ast__IndexExpr).is_setter) {
					v__ast__IndexExpr_recursive_mapset_is_setter(&(*left._v__ast__IndexExpr), true);
				}
			}
			if (is_decl) {
				v__checker__Checker_error(c, _STR("non-name `%.*s\000` on left side of `:=`", 2, v__ast__Expr_str(left)), v__ast__Expr_position(left));
			}
		};
		v__ast__Type left_type_unwrapped = v__checker__Checker_unwrap_generic(c, left_type);
		v__ast__Type right_type_unwrapped = v__checker__Checker_unwrap_generic(c, right_type);
		if (right_type_unwrapped == 0) {
			continue;
		}
		v__ast__TypeSymbol* left_sym = v__ast__Table_get_type_symbol(c->table, left_type_unwrapped);
		v__ast__TypeSymbol* right_sym = v__ast__Table_get_type_symbol(c->table, right_type_unwrapped);
		if (c->pref->translated) {
			continue;
		}
		if (left_sym->kind == v__ast__Kind_array && !c->inside_unsafe && (assign_stmt->op == v__token__Kind_assign || assign_stmt->op == v__token__Kind_decl_assign) && right_sym->kind == v__ast__Kind_array && ((left)._typ == 254 /* v.ast.Ident */ && !v__ast__Expr_is_blank_ident(left)) && (right)._typ == 254 /* v.ast.Ident */) {
			v__checker__Checker_error(c, _STR("use `array2 %.*s\000 array1.clone()` instead of `array2 %.*s\000 array1` (or use `unsafe`)", 3, v__token__Kind_str(assign_stmt->op), v__token__Kind_str(assign_stmt->op)), assign_stmt->pos);
		}
		if (left_sym->kind == v__ast__Kind_map && (assign_stmt->op == v__token__Kind_assign || assign_stmt->op == v__token__Kind_decl_assign) && right_sym->kind == v__ast__Kind_map && (((right)._typ == 254 /* v.ast.Ident */ && v__ast__Expr_is_auto_deref_var(right)) || !v__ast__Type_is_ptr(right_type)) && !v__ast__Expr_is_blank_ident(left) && v__ast__Expr_is_lvalue(right)) {
			v__checker__Checker_error(c, _SLIT("cannot copy map: call `move` or `clone` method (or use a reference)"), v__ast__Expr_position(right));
		}
		bool left_is_ptr = v__ast__Type_is_ptr(left_type) || v__ast__TypeSymbol_is_pointer(left_sym);
		if (left_is_ptr && !v__ast__Expr_is_auto_deref_var(left)) {
			if (!c->inside_unsafe && !(assign_stmt->op == v__token__Kind_assign || assign_stmt->op == v__token__Kind_decl_assign)) {
				v__checker__Checker_warn(c, _SLIT("pointer arithmetic is only allowed in `unsafe` blocks"), assign_stmt->pos);
			}
			bool right_is_ptr = v__ast__Type_is_ptr(right_type) || v__ast__TypeSymbol_is_pointer(right_sym);
			if (!right_is_ptr && assign_stmt->op == v__token__Kind_assign && v__ast__Type_is_number(right_type_unwrapped)) {
				v__checker__Checker_error(c, string_add(_STR("cannot assign to `%.*s\000`: ", 2, v__ast__Expr_str(left)), v__checker__Checker_expected_msg(c, right_type_unwrapped, left_type_unwrapped)), v__ast__Expr_position(right));
			}
			if (((right)._typ == 278 /* v.ast.StructInit */ || !right_is_ptr) && !(v__ast__TypeSymbol_is_number(right_sym) || v__ast__Type_has_flag(left_type, v__ast__TypeFlag_shared_f))) {
				string left_name = v__ast__Table_type_to_str(c->table, left_type_unwrapped);
				v__ast__Type rtype = right_type_unwrapped;
				if (v__ast__Type_is_ptr(rtype)) {
					rtype = v__ast__Type_deref(rtype);
				}
				string right_name = v__ast__Table_type_to_str(c->table, rtype);
				v__checker__Checker_error(c, _STR("mismatched types `%.*s\000` and `%.*s\000`", 3, left_name, right_name), assign_stmt->pos);
			}
		}

		if (assign_stmt->op == (v__token__Kind_assign)) {
		}
		else if (assign_stmt->op == (v__token__Kind_plus_assign) || assign_stmt->op == (v__token__Kind_minus_assign)) {
			if (v__ast__Type_alias_eq(left_type, _const_v__ast__string_type)) {
				if (assign_stmt->op != v__token__Kind_plus_assign) {
					v__checker__Checker_error(c, _STR("operator `%.*s\000` not defined on left operand type `%.*s\000`", 3, v__token__Kind_str(assign_stmt->op), left_sym->name), v__ast__Expr_position(left));
				}
				if (!v__ast__Type_alias_eq(right_type, _const_v__ast__string_type)) {
					v__checker__Checker_error(c, _STR("invalid right operand: %.*s\000 %.*s\000 %.*s", 3, left_sym->name, v__token__Kind_str(assign_stmt->op), right_sym->name), v__ast__Expr_position(right));
				}
			} else if (!v__ast__TypeSymbol_is_number(left_sym) && !(left_sym->kind == v__ast__Kind_byteptr || left_sym->kind == v__ast__Kind_charptr || left_sym->kind == v__ast__Kind_struct_ || left_sym->kind == v__ast__Kind_alias)) {
				v__checker__Checker_error(c, _STR("operator `%.*s\000` not defined on left operand type `%.*s\000`", 3, v__token__Kind_str(assign_stmt->op), left_sym->name), v__ast__Expr_position(left));
			} else if (!v__ast__TypeSymbol_is_number(right_sym) && !(left_sym->kind == v__ast__Kind_byteptr || left_sym->kind == v__ast__Kind_charptr || left_sym->kind == v__ast__Kind_struct_ || left_sym->kind == v__ast__Kind_alias)) {
				v__checker__Checker_error(c, _STR("invalid right operand: %.*s\000 %.*s\000 %.*s", 3, left_sym->name, v__token__Kind_str(assign_stmt->op), right_sym->name), v__ast__Expr_position(right));
			}
		}
		else if (assign_stmt->op == (v__token__Kind_mult_assign) || assign_stmt->op == (v__token__Kind_div_assign)) {
			if (!v__ast__TypeSymbol_is_number(left_sym) && !v__ast__TypeSymbol_is_int(v__ast__Table_get_final_type_symbol(c->table, left_type_unwrapped)) && !(left_sym->kind == v__ast__Kind_struct_ || left_sym->kind == v__ast__Kind_alias)) {
				v__checker__Checker_error(c, _STR("operator %.*s\000 not defined on left operand type `%.*s\000`", 3, v__token__Kind_str(assign_stmt->op), left_sym->name), v__ast__Expr_position(left));
			} else if (!v__ast__TypeSymbol_is_number(right_sym) && !v__ast__TypeSymbol_is_int(v__ast__Table_get_final_type_symbol(c->table, left_type_unwrapped)) && !(left_sym->kind == v__ast__Kind_struct_ || left_sym->kind == v__ast__Kind_alias)) {
				v__checker__Checker_error(c, _STR("operator %.*s\000 not defined on right operand type `%.*s\000`", 3, v__token__Kind_str(assign_stmt->op), right_sym->name), v__ast__Expr_position(right));
			}
		}
		else if (assign_stmt->op == (v__token__Kind_and_assign) || assign_stmt->op == (v__token__Kind_or_assign) || assign_stmt->op == (v__token__Kind_xor_assign) || assign_stmt->op == (v__token__Kind_mod_assign) || assign_stmt->op == (v__token__Kind_left_shift_assign) || assign_stmt->op == (v__token__Kind_right_shift_assign)) {
			if (!v__ast__TypeSymbol_is_int(left_sym) && !v__ast__TypeSymbol_is_int(v__ast__Table_get_final_type_symbol(c->table, left_type_unwrapped))) {
				v__checker__Checker_error(c, _STR("operator %.*s\000 not defined on left operand type `%.*s\000`", 3, v__token__Kind_str(assign_stmt->op), left_sym->name), v__ast__Expr_position(left));
			} else if (!v__ast__TypeSymbol_is_int(right_sym) && !v__ast__TypeSymbol_is_int(v__ast__Table_get_final_type_symbol(c->table, right_type_unwrapped))) {
				v__checker__Checker_error(c, _STR("operator %.*s\000 not defined on right operand type `%.*s\000`", 3, v__token__Kind_str(assign_stmt->op), right_sym->name), v__ast__Expr_position(right));
			}
		}
		else {
		};
		if ((assign_stmt->op == v__token__Kind_plus_assign || assign_stmt->op == v__token__Kind_minus_assign || assign_stmt->op == v__token__Kind_mod_assign || assign_stmt->op == v__token__Kind_mult_assign || assign_stmt->op == v__token__Kind_div_assign) && ((left_sym->kind == v__ast__Kind_struct_ && right_sym->kind == v__ast__Kind_struct_) || left_sym->kind == v__ast__Kind_alias)) {
			string left_name = v__ast__Table_type_to_str(c->table, left_type);
			string right_name = v__ast__Table_type_to_str(c->table, right_type);
			v__ast__TypeSymbol* parent_sym = v__ast__Table_get_final_type_symbol(c->table, left_type);
			if (left_sym->kind == v__ast__Kind_alias && right_sym->kind != v__ast__Kind_alias) {
				v__checker__Checker_error(c, _STR("mismatched types `%.*s\000` and `%.*s\000`", 3, left_name, right_name), assign_stmt->pos);
			}
			string extracted_op = ((assign_stmt->op == (v__token__Kind_plus_assign)) ? (_SLIT("+")) : (assign_stmt->op == (v__token__Kind_minus_assign)) ? (_SLIT("-")) : (assign_stmt->op == (v__token__Kind_div_assign)) ? (_SLIT("/")) : (assign_stmt->op == (v__token__Kind_mod_assign)) ? (_SLIT("%")) : (assign_stmt->op == (v__token__Kind_mult_assign)) ? (_SLIT("*")) : (_SLIT("unknown op")));
			Option_v__ast__Fn _t2013;
			if (_t2013 = v__ast__TypeSymbol_find_method(left_sym, extracted_op), _t2013.state == 0) {
				v__ast__Fn method = *(v__ast__Fn*)_t2013.data;
				if (!v__ast__Type_alias_eq(method.return_type, left_type)) {
					v__checker__Checker_error(c, _STR("operator `%.*s\000` must return `%.*s\000` to be used as an assignment operator", 3, extracted_op, left_name), assign_stmt->pos);
				}
			} else {
				IError err = _t2013.err;
				if (v__ast__TypeSymbol_is_primitive(parent_sym)) {
					v__checker__Checker_error(c, _STR("cannot use operator methods on type alias for `%.*s\000`", 2, parent_sym->name), assign_stmt->pos);
				}
				if (string_eq(left_name, right_name)) {
					v__checker__Checker_error(c, _STR("undefined operation `%.*s\000` %.*s\000 `%.*s\000`", 4, left_name, extracted_op, right_name), assign_stmt->pos);
				} else {
					v__checker__Checker_error(c, _STR("mismatched types `%.*s\000` and `%.*s\000`", 3, left_name, right_name), assign_stmt->pos);
				}
			}
		}
		if (!is_blank_ident && !v__ast__Expr_is_auto_deref_var(right) && right_sym->kind != v__ast__Kind_placeholder && left_sym->kind != v__ast__Kind_interface_) {
			Option_void _t2014 = v__checker__Checker_check_expected(c, right_type_unwrapped, left_type_unwrapped);
			if (_t2014.state != 0 && _t2014.err._typ != _IError_None___index) {
				IError err = _t2014.err;
				if (v__ast__Type_is_ptr(left_type_unwrapped) && v__ast__Type_is_int(right_type_unwrapped) && (assign_stmt->op == v__token__Kind_plus_assign || assign_stmt->op == v__token__Kind_minus_assign)) {
					if (!c->inside_unsafe) {
						v__checker__Checker_warn(c, _SLIT("pointer arithmetic is only allowed in `unsafe` blocks"), assign_stmt->pos);
					}
				} else {
					v__checker__Checker_error(c, _STR("cannot assign to `%.*s\000`: %.*s", 2, v__ast__Expr_str(left), (*(err.msg))), v__ast__Expr_position(right));
				}
			};
		}
		if (left_sym->kind == v__ast__Kind_interface_) {
			v__checker__Checker_type_implements(c, right_type, left_type, v__ast__Expr_position(right));
		}
	}
	if ((right_first)._typ == 270 /* v.ast.PrefixExpr */) {
		v__ast__PrefixExpr node = (*right_first._v__ast__PrefixExpr);
		v__ast__Expr left_first = (*(v__ast__Expr*)/*ee elem_typ */array_get(assign_stmt->left, 0));
		if ((left_first)._typ == 254 /* v.ast.Ident */) {
			v__ast__Ident assigned_var = (*left_first._v__ast__Ident);
			bool is_shared = false;
			if (((*left_first._v__ast__Ident).info)._typ == 363 /* v.ast.IdentVar */) {
				is_shared = (*(*left_first._v__ast__Ident).info._v__ast__IdentVar).share == v__ast__ShareType_shared_t;
			}
			bool old_inside_ref_lit = c->inside_ref_lit;
			c->inside_ref_lit = (c->inside_ref_lit || node.op == v__token__Kind_amp || is_shared);
			v__checker__Checker_expr(c, node.right);
			c->inside_ref_lit = old_inside_ref_lit;
			if ((node.right)._typ == 254 /* v.ast.Ident */) {
				if (((*node.right._v__ast__Ident).obj)._typ == 312 /* v.ast.Var */) {
					v__ast__Var v = (*(*node.right._v__ast__Ident).obj._v__ast__Var);
					right_type0 = v.typ;
					if (node.op == v__token__Kind_amp) {
						if (!v.is_mut && assigned_var.is_mut && !c->inside_unsafe) {
							v__checker__Checker_error(c, _STR("`%.*s\000` is immutable, cannot have a mutable reference to it", 2, (*node.right._v__ast__Ident).name), node.pos);
						}
					}
				}
			}
			if (node.op == v__token__Kind_arrow) {
				if (assigned_var.is_mut) {
					v__ast__TypeSymbol* right_sym = v__ast__Table_get_type_symbol(c->table, right_type0);
					if (right_sym->kind == v__ast__Kind_chan) {
						v__ast__Chan chan_info = v__ast__TypeSymbol_chan_info(right_sym);
						if (v__ast__Type_is_ptr(chan_info.elem_type) && !chan_info.is_mut) {
							v__checker__Checker_error(c, _STR("cannot have a mutable reference to object from `%.*s\000`", 2, right_sym->name), node.pos);
						}
					}
				}
			}
		}
	}
// Defer begin
if (v__checker__Checker_assign_stmt_defer_0 == true) {
	c->expected_type = _const_v__ast__void_type;
}
// Defer end
}

VV_LOCAL_SYMBOL void v__checker__scope_register_it(v__ast__Scope* s, v__token__Position pos, v__ast__Type typ) {
	v__ast__Scope_register(s, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){.name = _SLIT("it"),.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.is_auto_deref = 0,.typ = typ,.orig_type = 0,.smartcasts = __new_array(0, 1, sizeof(v__ast__Type)),.pos = pos,.is_used = true,.is_changed = 0,.is_or = 0,.is_tmp = 0,}))));
}

VV_LOCAL_SYMBOL void v__checker__scope_register_a_b(v__ast__Scope* s, v__token__Position pos, v__ast__Type typ) {
	v__ast__Scope_register(s, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){.name = _SLIT("a"),.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.is_auto_deref = 0,.typ = v__ast__Type_to_ptr(typ),.orig_type = 0,.smartcasts = __new_array(0, 1, sizeof(v__ast__Type)),.pos = pos,.is_used = true,.is_changed = 0,.is_or = 0,.is_tmp = 0,}))));
	v__ast__Scope_register(s, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){.name = _SLIT("b"),.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.is_auto_deref = 0,.typ = v__ast__Type_to_ptr(typ),.orig_type = 0,.smartcasts = __new_array(0, 1, sizeof(v__ast__Type)),.pos = pos,.is_used = true,.is_changed = 0,.is_or = 0,.is_tmp = 0,}))));
}

VV_LOCAL_SYMBOL void v__checker__Checker_check_array_init_para_type(v__checker__Checker* c, string para, v__ast__Expr expr, v__token__Position pos) {
	v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(c->table, v__checker__Checker_expr(c, expr));
	if (!(sym->kind == v__ast__Kind_int || sym->kind == v__ast__Kind_int_literal)) {
		v__checker__Checker_error(c, _STR("array %.*s\000 needs to be an int", 2, para), pos);
	}
}

void v__checker__Checker_ensure_sumtype_array_has_default_value(v__checker__Checker* c, v__ast__ArrayInit array_init) {
	v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(c->table, array_init.elem_type);
	if (sym->kind == v__ast__Kind_sum_type && !array_init.has_default) {
		v__checker__Checker_error(c, _SLIT("cannot initialize sum type array without default value"), array_init.pos);
	}
}

v__ast__Type v__checker__Checker_array_init(v__checker__Checker* c, v__ast__ArrayInit* array_init) {
	v__ast__Type elem_type = _const_v__ast__void_type;
	if (!v__ast__Type_alias_eq(array_init->typ, _const_v__ast__void_type)) {
		if (array_init->exprs.len == 0) {
			if (array_init->has_cap) {
				v__checker__Checker_check_array_init_para_type(c, _SLIT("cap"), array_init->cap_expr, array_init->pos);
			}
			if (array_init->has_len) {
				v__checker__Checker_check_array_init_para_type(c, _SLIT("len"), array_init->len_expr, array_init->pos);
			}
		}
		if (array_init->has_default) {
			v__ast__Expr default_expr = array_init->default_expr;
			v__ast__Type default_typ = v__checker__Checker_check_expr_opt_call(c, default_expr, v__checker__Checker_expr(c, default_expr));
			Option_void _t2015 = v__checker__Checker_check_expected(c, default_typ, array_init->elem_type);
			if (_t2015.state != 0 && _t2015.err._typ != _IError_None___index) {
				IError err = _t2015.err;
				v__checker__Checker_error(c, (*(err.msg)), v__ast__Expr_position(default_expr));
			};
		}
		if (array_init->has_len) {
			v__checker__Checker_ensure_sumtype_array_has_default_value(c, *array_init);
		}
		Option_void _t2016 = v__checker__Checker_ensure_type_exists(c, array_init->elem_type, array_init->elem_type_pos);
		if (_t2016.state != 0 && _t2016.err._typ != _IError_None___index) {
			IError err = _t2016.err;
		};
		 v__ast__Type _t2017 = array_init->typ;
		// autofree_scope_vars(pos=116120 line_nr=3277 scope.pos=115435 scope.end_pos=116144)
		// af parent scope:
		// var "c" var.pos=115199 var.line_nr=3253
		// var "array_init" var.pos=115225 var.line_nr=3253
		// var "elem_type" var.pos=115339 var.line_nr=3255
		// af parent scope:
		// af parent scope:
		return _t2017;
	}
	if (array_init->is_fixed) {
		v__checker__Checker_ensure_sumtype_array_has_default_value(c, *array_init);
		Option_void _t2018 = v__checker__Checker_ensure_type_exists(c, array_init->elem_type, array_init->elem_type_pos);
		if (_t2018.state != 0 && _t2018.err._typ != _IError_None___index) {
			IError err = _t2018.err;
		};
	}
	if (array_init->exprs.len == 0) {
		if (v__ast__Type_alias_eq(c->expected_type, _const_v__ast__void_type) && !v__ast__Type_alias_eq(c->expected_or_type, _const_v__ast__void_type)) {
			c->expected_type = c->expected_or_type;
		}
		v__ast__TypeSymbol* type_sym = v__ast__Table_get_type_symbol(c->table, c->expected_type);
		if (type_sym->kind != v__ast__Kind_array) {
			v__checker__Checker_error(c, _SLIT("array_init: no type specified (maybe: `[]Type{}` instead of `[]`)"), array_init->pos);
			// autofree_scope_vars(pos=116709 line_nr=3293 scope.pos=116605 scope.end_pos=116733)
			// af parent scope:
			// var "type_sym" var.pos=116523 var.line_nr=3289
			// var "array_info" var.pos=116974 var.line_nr=3300
			// af parent scope:
			// var "c" var.pos=115199 var.line_nr=3253
			// var "array_init" var.pos=115225 var.line_nr=3253
			// var "elem_type" var.pos=115339 var.line_nr=3255
			// af parent scope:
			// af parent scope:
			return _const_v__ast__void_type;
		}
		v__ast__Array array_info = v__ast__TypeSymbol_array_info(type_sym);
		array_init->elem_type = array_info.elem_type;
		 v__ast__Type _t2019 = v__ast__Type_clear_flag(c->expected_type, v__ast__TypeFlag_optional);
		// autofree_scope_vars(pos=117127 line_nr=3303 scope.pos=116348 scope.end_pos=117174)
		// var "type_sym" var.pos=116523 var.line_nr=3289
		// var "array_info" var.pos=116974 var.line_nr=3300
		// af parent scope:
		// var "c" var.pos=115199 var.line_nr=3253
		// var "array_init" var.pos=115225 var.line_nr=3253
		// var "elem_type" var.pos=115339 var.line_nr=3255
		// af parent scope:
		// af parent scope:
		return _t2019;
	}
	if (array_init->exprs.len > 0 && v__ast__Type_alias_eq(array_init->elem_type, _const_v__ast__void_type)) {
		v__ast__Type expected_value_type = _const_v__ast__void_type;
		bool expecting_interface_array = false;
		if (c->expected_type != 0) {
			expected_value_type = v__ast__Table_value_type(c->table, c->expected_type);
			if (v__ast__Table_get_type_symbol(c->table, expected_value_type)->kind == v__ast__Kind_interface_) {
				expecting_interface_array = true;
			}
		}
		// FOR IN array
		for (int i = 0; i < array_init->exprs.len; ++i) {
			v__ast__Expr expr = ((v__ast__Expr*)array_init->exprs.data)[i];
			v__ast__Type typ = v__checker__Checker_check_expr_opt_call(c, expr, v__checker__Checker_expr(c, expr));
			array_push(&array_init->expr_types, _MOV((v__ast__Type[]){ typ }));
			if (expecting_interface_array) {
				if (i == 0) {
					elem_type = expected_value_type;
					c->expected_type = elem_type;
					v__checker__Checker_type_implements(c, typ, elem_type, v__ast__Expr_position(expr));
				}
				continue;
			}
			if (i == 0) {
				if (v__ast__Expr_is_auto_deref_var(expr)) {
					elem_type = v__ast__Table_mktyp(c->table, v__ast__Type_deref(typ));
				} else {
					elem_type = v__ast__Table_mktyp(c->table, typ);
				}
				c->expected_type = elem_type;
				continue;
			}
			Option_void _t2021 = v__checker__Checker_check_expected(c, typ, elem_type);
			if (_t2021.state != 0 && _t2021.err._typ != _IError_None___index) {
				IError err = _t2021.err;
				v__checker__Checker_error(c, _STR("invalid array element: %.*s", 1, (*(err.msg))), v__ast__Expr_position(expr));
			};
		}
		if (array_init->is_fixed) {
			int idx = v__ast__Table_find_or_register_array_fixed(c->table, elem_type, array_init->exprs.len);
			array_init->typ = v__ast__new_type(idx);
		} else {
			int idx = v__ast__Table_find_or_register_array(c->table, elem_type);
			array_init->typ = v__ast__new_type(idx);
		}
		array_init->elem_type = elem_type;
	} else if (array_init->is_fixed && array_init->exprs.len == 1 && !v__ast__Type_alias_eq(array_init->elem_type, _const_v__ast__void_type)) {
		int fixed_size = 0;
		v__ast__Expr init_expr = (*(v__ast__Expr*)/*ee elem_typ */array_get(array_init->exprs, 0));
		v__checker__Checker_expr(c, init_expr);
		if (init_expr._typ == 259 /* v.ast.IntegerLiteral */) {
			fixed_size = string_int((*init_expr._v__ast__IntegerLiteral).val);
		}
		else if (init_expr._typ == 254 /* v.ast.Ident */) {
			if (((*init_expr._v__ast__Ident).obj)._typ == 310 /* v.ast.ConstField */) {
				Option_int _t2022;
				if (_t2022 = v__checker__eval_int_expr((*(*init_expr._v__ast__Ident).obj._v__ast__ConstField).expr, 0), _t2022.state == 0) {
					int cint = *(int*)_t2022.data;
					fixed_size = cint;
				}
			} else {
				v__checker__Checker_error(c, _STR("non-constant array bound `%.*s\000`", 2, (*init_expr._v__ast__Ident).name), (*init_expr._v__ast__Ident).pos);
			}
		}
		else if (init_expr._typ == 258 /* v.ast.InfixExpr */) {
			Option_int _t2023;
			if (_t2023 = v__checker__eval_int_expr(init_expr, 0), _t2023.state == 0) {
				int cint = *(int*)_t2023.data;
				fixed_size = cint;
			}
		}
		else {
			v__checker__Checker_error(c, _SLIT("expecting `int` for fixed size"), array_init->pos);
		};
		if (fixed_size <= 0) {
			v__checker__Checker_error(c, _SLIT("fixed size cannot be zero or negative"), v__ast__Expr_position(init_expr));
		}
		int idx = v__ast__Table_find_or_register_array_fixed(c->table, array_init->elem_type, fixed_size);
		v__ast__Type array_type = v__ast__new_type(idx);
		array_init->typ = array_type;
		if (array_init->has_default) {
			v__checker__Checker_expr(c, array_init->default_expr);
		}
	}
	 v__ast__Type _t2024 = array_init->typ;
	// autofree_scope_vars(pos=119857 line_nr=3394 scope.pos=115194 scope.end_pos=119880)
	// var "c" var.pos=115199 var.line_nr=3253
	// var "array_init" var.pos=115225 var.line_nr=3253
	// var "elem_type" var.pos=115339 var.line_nr=3255
	// af parent scope:
	// af parent scope:
	return _t2024;
}

VV_LOCAL_SYMBOL Option_int v__checker__eval_int_expr(v__ast__Expr expr, int nlevel) {
	if (nlevel > 100) {
		return (Option_int){ .state=2, .err=_const_none__ };
	}
	if (expr._typ == 259 /* v.ast.IntegerLiteral */) {
		Option_int _t2025;
		opt_ok(&(int[]) { string_int((*expr._v__ast__IntegerLiteral).val) }, (Option*)(&_t2025), sizeof(int));
		// autofree_scope_vars(pos=120066 line_nr=3404 scope.pos=120043 scope.end_pos=120091)
		// var "expr" var.pos=120034 var.line_nr=3402
		// af parent scope:
		// var "expr" var.pos=119900 var.line_nr=3397
		// var "nlevel" var.pos=119915 var.line_nr=3397
		// af parent scope:
		// af parent scope:
		return _t2025;
	}
	else if (expr._typ == 258 /* v.ast.InfixExpr */) {
		Option_int _t2026 = v__checker__eval_int_expr((*expr._v__ast__InfixExpr).left, nlevel + 1);
		if (_t2026.state != 0) { /*or block*/ 
			Option_int _t2027;
			memcpy(&_t2027, &_t2026, sizeof(Option));
			return _t2027;
		}
 		int left =  *(int*)_t2026.data;
		Option_int _t2028 = v__checker__eval_int_expr((*expr._v__ast__InfixExpr).right, nlevel + 1);
		if (_t2028.state != 0) { /*or block*/ 
			Option_int _t2029;
			memcpy(&_t2029, &_t2028, sizeof(Option));
			return _t2029;
		}
 		int right =  *(int*)_t2028.data;

		if ((*expr._v__ast__InfixExpr).op == (v__token__Kind_plus)) {
			Option_int _t2030;
			opt_ok(&(int[]) { left + right }, (Option*)(&_t2030), sizeof(int));
			// autofree_scope_vars(pos=120243 line_nr=3410 scope.pos=120236 scope.end_pos=120264)
			// af parent scope:
			// var "left" var.pos=120114 var.line_nr=3407
			// var "right" var.pos=120164 var.line_nr=3408
			// var "expr" var.pos=120034 var.line_nr=3402
			// af parent scope:
			// var "expr" var.pos=119900 var.line_nr=3397
			// var "nlevel" var.pos=119915 var.line_nr=3397
			// af parent scope:
			// af parent scope:
			return _t2030;
		}
		else if ((*expr._v__ast__InfixExpr).op == (v__token__Kind_minus)) {
			Option_int _t2031;
			opt_ok(&(int[]) { left - right }, (Option*)(&_t2031), sizeof(int));
			// autofree_scope_vars(pos=120278 line_nr=3411 scope.pos=120270 scope.end_pos=120299)
			// af parent scope:
			// var "left" var.pos=120114 var.line_nr=3407
			// var "right" var.pos=120164 var.line_nr=3408
			// var "expr" var.pos=120034 var.line_nr=3402
			// af parent scope:
			// var "expr" var.pos=119900 var.line_nr=3397
			// var "nlevel" var.pos=119915 var.line_nr=3397
			// af parent scope:
			// af parent scope:
			return _t2031;
		}
		else if ((*expr._v__ast__InfixExpr).op == (v__token__Kind_mul)) {
			Option_int _t2032;
			opt_ok(&(int[]) { left * right }, (Option*)(&_t2032), sizeof(int));
			// autofree_scope_vars(pos=120311 line_nr=3412 scope.pos=120305 scope.end_pos=120332)
			// af parent scope:
			// var "left" var.pos=120114 var.line_nr=3407
			// var "right" var.pos=120164 var.line_nr=3408
			// var "expr" var.pos=120034 var.line_nr=3402
			// af parent scope:
			// var "expr" var.pos=119900 var.line_nr=3397
			// var "nlevel" var.pos=119915 var.line_nr=3397
			// af parent scope:
			// af parent scope:
			return _t2032;
		}
		else if ((*expr._v__ast__InfixExpr).op == (v__token__Kind_div)) {
			Option_int _t2033;
			opt_ok(&(int[]) { left / right }, (Option*)(&_t2033), sizeof(int));
			// autofree_scope_vars(pos=120344 line_nr=3413 scope.pos=120338 scope.end_pos=120365)
			// af parent scope:
			// var "left" var.pos=120114 var.line_nr=3407
			// var "right" var.pos=120164 var.line_nr=3408
			// var "expr" var.pos=120034 var.line_nr=3402
			// af parent scope:
			// var "expr" var.pos=119900 var.line_nr=3397
			// var "nlevel" var.pos=119915 var.line_nr=3397
			// af parent scope:
			// af parent scope:
			return _t2033;
		}
		else if ((*expr._v__ast__InfixExpr).op == (v__token__Kind_mod)) {
			Option_int _t2034;
			opt_ok(&(int[]) { left % right }, (Option*)(&_t2034), sizeof(int));
			// autofree_scope_vars(pos=120377 line_nr=3414 scope.pos=120371 scope.end_pos=120398)
			// af parent scope:
			// var "left" var.pos=120114 var.line_nr=3407
			// var "right" var.pos=120164 var.line_nr=3408
			// var "expr" var.pos=120034 var.line_nr=3402
			// af parent scope:
			// var "expr" var.pos=119900 var.line_nr=3397
			// var "nlevel" var.pos=119915 var.line_nr=3397
			// af parent scope:
			// af parent scope:
			return _t2034;
		}
		else if ((*expr._v__ast__InfixExpr).op == (v__token__Kind_xor)) {
			Option_int _t2035;
			opt_ok(&(int[]) { (left ^ right) }, (Option*)(&_t2035), sizeof(int));
			// autofree_scope_vars(pos=120410 line_nr=3415 scope.pos=120404 scope.end_pos=120431)
			// af parent scope:
			// var "left" var.pos=120114 var.line_nr=3407
			// var "right" var.pos=120164 var.line_nr=3408
			// var "expr" var.pos=120034 var.line_nr=3402
			// af parent scope:
			// var "expr" var.pos=119900 var.line_nr=3397
			// var "nlevel" var.pos=119915 var.line_nr=3397
			// af parent scope:
			// af parent scope:
			return _t2035;
		}
		else if ((*expr._v__ast__InfixExpr).op == (v__token__Kind_pipe)) {
			Option_int _t2036;
			opt_ok(&(int[]) { (left | right) }, (Option*)(&_t2036), sizeof(int));
			// autofree_scope_vars(pos=120444 line_nr=3416 scope.pos=120437 scope.end_pos=120465)
			// af parent scope:
			// var "left" var.pos=120114 var.line_nr=3407
			// var "right" var.pos=120164 var.line_nr=3408
			// var "expr" var.pos=120034 var.line_nr=3402
			// af parent scope:
			// var "expr" var.pos=119900 var.line_nr=3397
			// var "nlevel" var.pos=119915 var.line_nr=3397
			// af parent scope:
			// af parent scope:
			return _t2036;
		}
		else if ((*expr._v__ast__InfixExpr).op == (v__token__Kind_amp)) {
			Option_int _t2037;
			opt_ok(&(int[]) { (left & right) }, (Option*)(&_t2037), sizeof(int));
			// autofree_scope_vars(pos=120477 line_nr=3417 scope.pos=120471 scope.end_pos=120498)
			// af parent scope:
			// var "left" var.pos=120114 var.line_nr=3407
			// var "right" var.pos=120164 var.line_nr=3408
			// var "expr" var.pos=120034 var.line_nr=3402
			// af parent scope:
			// var "expr" var.pos=119900 var.line_nr=3397
			// var "nlevel" var.pos=119915 var.line_nr=3397
			// af parent scope:
			// af parent scope:
			return _t2037;
		}
		else if ((*expr._v__ast__InfixExpr).op == (v__token__Kind_left_shift)) {
			Option_int _t2038;
			opt_ok(&(int[]) { left << right }, (Option*)(&_t2038), sizeof(int));
			// autofree_scope_vars(pos=120517 line_nr=3418 scope.pos=120504 scope.end_pos=120539)
			// af parent scope:
			// var "left" var.pos=120114 var.line_nr=3407
			// var "right" var.pos=120164 var.line_nr=3408
			// var "expr" var.pos=120034 var.line_nr=3402
			// af parent scope:
			// var "expr" var.pos=119900 var.line_nr=3397
			// var "nlevel" var.pos=119915 var.line_nr=3397
			// af parent scope:
			// af parent scope:
			return _t2038;
		}
		else if ((*expr._v__ast__InfixExpr).op == (v__token__Kind_right_shift)) {
			Option_int _t2039;
			opt_ok(&(int[]) { left >> right }, (Option*)(&_t2039), sizeof(int));
			// autofree_scope_vars(pos=120559 line_nr=3419 scope.pos=120545 scope.end_pos=120581)
			// af parent scope:
			// var "left" var.pos=120114 var.line_nr=3407
			// var "right" var.pos=120164 var.line_nr=3408
			// var "expr" var.pos=120034 var.line_nr=3402
			// af parent scope:
			// var "expr" var.pos=119900 var.line_nr=3397
			// var "nlevel" var.pos=119915 var.line_nr=3397
			// af parent scope:
			// af parent scope:
			return _t2039;
		}
		else {
			return (Option_int){ .state=2, .err=_const_none__ };
		};
	}
	else if (expr._typ == 254 /* v.ast.Ident */) {
		if (((*expr._v__ast__Ident).obj)._typ == 310 /* v.ast.ConstField */) {
			Option_int _t2040 = v__checker__eval_int_expr((*(*expr._v__ast__Ident).obj._v__ast__ConstField).expr, nlevel + 1);
			if (_t2040.state != 0) { /*or block*/ 
				Option_int _t2041;
				memcpy(&_t2041, &_t2040, sizeof(Option));
				return _t2041;
			}
 			int cint =  *(int*)_t2040.data;
			Option_int _t2042;
			opt_ok(&(int[]) { cint }, (Option*)(&_t2042), sizeof(int));
			// autofree_scope_vars(pos=120748 line_nr=3427 scope.pos=120664 scope.end_pos=120764)
			// var "cint" var.pos=120694 var.line_nr=3426
			// af parent scope:
			// var "expr" var.pos=120034 var.line_nr=3402
			// af parent scope:
			// var "expr" var.pos=119900 var.line_nr=3397
			// var "nlevel" var.pos=119915 var.line_nr=3397
			// af parent scope:
			// af parent scope:
			return _t2042;
		}
	}
	else {
		return (Option_int){ .state=2, .err=_const_none__ };
	};
	return (Option_int){ .state=2, .err=_const_none__ };
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL void v__checker__Checker_check_loop_label(v__checker__Checker* c, string label, v__token__Position pos) {
	if (label.len == 0) {
		return;
	}
	if (c->loop_label.len != 0) {
		v__checker__Checker_error(c, _SLIT("nesting of labelled `for` loops is not supported"), pos);
		return;
	}
	c->loop_label = label;
}

VV_LOCAL_SYMBOL void v__checker__Checker_stmt(v__checker__Checker* c, v__ast__Stmt node) {
	if (node._typ == 291 /* v.ast.EmptyStmt */) {
		if (c->pref->is_verbose) {
			eprintln(_SLIT("Checker.stmt() EmptyStmt"));
			print_backtrace();
		}
	}
	else if (node._typ == 264 /* v.ast.NodeError */) {
	}
	else if (node._typ == 283 /* v.ast.AsmStmt */) {
		v__checker__Checker_asm_stmt(c, (voidptr)&/*qq*/(*node._v__ast__AsmStmt));
	}
	else if (node._typ == 284 /* v.ast.AssertStmt */) {
		v__checker__Checker_assert_stmt(c, (*node._v__ast__AssertStmt));
	}
	else if (node._typ == 285 /* v.ast.AssignStmt */) {
		v__checker__Checker_assign_stmt(c, (voidptr)&/*qq*/(*node._v__ast__AssignStmt));
	}
	else if (node._typ == 286 /* v.ast.Block */) {
		v__checker__Checker_block(c, (*node._v__ast__Block));
	}
	else if (node._typ == 287 /* v.ast.BranchStmt */) {
		v__checker__Checker_branch_stmt(c, (*node._v__ast__BranchStmt));
	}
	else if (node._typ == 288 /* v.ast.CompFor */) {
		v__ast__Type typ = v__checker__Checker_unwrap_generic(c, (*node._v__ast__CompFor).typ);
		v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(c->table, typ);
		if (sym->kind == v__ast__Kind_placeholder || v__ast__Type_has_flag(typ, v__ast__TypeFlag_generic)) {
			v__checker__Checker_error(c, _STR("unknown type `%.*s\000`", 2, sym->name), (*node._v__ast__CompFor).typ_pos);
		}
		v__checker__Checker_stmts(c, (*node._v__ast__CompFor).stmts);
	}
	else if (node._typ == 289 /* v.ast.ConstDecl */) {
		c->inside_const = true;
		v__checker__Checker_const_decl(c, (voidptr)&/*qq*/(*node._v__ast__ConstDecl));
		c->inside_const = false;
	}
	else if (node._typ == 290 /* v.ast.DeferStmt */) {
		if ((*node._v__ast__DeferStmt).idx_in_fn < 0) {
			(*node._v__ast__DeferStmt).idx_in_fn = c->cur_fn->defer_stmts.len;
			array_push(&c->cur_fn->defer_stmts, _MOV((v__ast__DeferStmt[]){ *&(*node._v__ast__DeferStmt) }));
		}
		v__checker__Checker_stmts(c, (*node._v__ast__DeferStmt).stmts);
	}
	else if (node._typ == 292 /* v.ast.EnumDecl */) {
		v__checker__Checker_enum_decl(c, (*node._v__ast__EnumDecl));
	}
	else if (node._typ == 293 /* v.ast.ExprStmt */) {
		(*node._v__ast__ExprStmt).typ = v__checker__Checker_expr(c, (*node._v__ast__ExprStmt).expr);
		c->expected_type = _const_v__ast__void_type;
		v__ast__Type or_typ = _const_v__ast__void_type;
		if ((*node._v__ast__ExprStmt).expr._typ == 257 /* v.ast.IndexExpr */) {
			if ((*(*node._v__ast__ExprStmt).expr._v__ast__IndexExpr).or_expr.kind != v__ast__OrKind_absent) {
				(*node._v__ast__ExprStmt).is_expr = true;
				or_typ = (*node._v__ast__ExprStmt).typ;
			}
		}
		else if ((*node._v__ast__ExprStmt).expr._typ == 270 /* v.ast.PrefixExpr */) {
			if ((*(*node._v__ast__ExprStmt).expr._v__ast__PrefixExpr).or_block.kind != v__ast__OrKind_absent) {
				(*node._v__ast__ExprStmt).is_expr = true;
				or_typ = (*node._v__ast__ExprStmt).typ;
			}
		}
		else {
		};
		v__checker__Checker_check_expr_opt_call(c, (*node._v__ast__ExprStmt).expr, or_typ);
	}
	else if (node._typ == 175 /* v.ast.FnDecl */) {
		v__checker__Checker_fn_decl(c, (voidptr)&/*qq*/(*node._v__ast__FnDecl));
	}
	else if (node._typ == 294 /* v.ast.ForCStmt */) {
		v__checker__Checker_for_c_stmt(c, (*node._v__ast__ForCStmt));
	}
	else if (node._typ == 295 /* v.ast.ForInStmt */) {
		v__checker__Checker_for_in_stmt(c, (voidptr)&/*qq*/(*node._v__ast__ForInStmt));
	}
	else if (node._typ == 296 /* v.ast.ForStmt */) {
		v__checker__Checker_for_stmt(c, (voidptr)&/*qq*/(*node._v__ast__ForStmt));
	}
	else if (node._typ == 297 /* v.ast.GlobalDecl */) {
		v__checker__Checker_global_decl(c, (*node._v__ast__GlobalDecl));
	}
	else if (node._typ == 298 /* v.ast.GoStmt */) {
		v__checker__Checker_go_stmt(c, (voidptr)&/*qq*/(*node._v__ast__GoStmt));
		if ((*node._v__ast__GoStmt).call_expr.or_block.kind != v__ast__OrKind_absent) {
			v__checker__Checker_error(c, _SLIT("optional handling cannot be done in `go` call. Do it when calling `.wait()`"), (*node._v__ast__GoStmt).call_expr.or_block.pos);
		}
	}
	else if (node._typ == 299 /* v.ast.GotoLabel */) {
	}
	else if (node._typ == 300 /* v.ast.GotoStmt */) {
		if (!c->inside_unsafe) {
			v__checker__Checker_warn(c, _SLIT("`goto` requires `unsafe` (consider using labelled break/continue)"), (*node._v__ast__GotoStmt).pos);
		}
		if (!(Array_string_contains(c->cur_fn->label_names, (*node._v__ast__GotoStmt).name))) {
			v__checker__Checker_error(c, _STR("unknown label `%.*s\000`", 2, (*node._v__ast__GotoStmt).name), (*node._v__ast__GotoStmt).pos);
		}
	}
	else if (node._typ == 301 /* v.ast.HashStmt */) {
		v__checker__Checker_hash_stmt(c, (voidptr)&/*qq*/(*node._v__ast__HashStmt));
	}
	else if (node._typ == 302 /* v.ast.Import */) {
		v__checker__Checker_import_stmt(c, (*node._v__ast__Import));
	}
	else if (node._typ == 303 /* v.ast.InterfaceDecl */) {
		v__checker__Checker_interface_decl(c, (*node._v__ast__InterfaceDecl));
	}
	else if (node._typ == 304 /* v.ast.Module */) {
		c->mod = (*node._v__ast__Module).name;
		c->is_builtin_mod = (string_eq((*node._v__ast__Module).name, _SLIT("builtin")) || string_eq((*node._v__ast__Module).name, _SLIT("os")) || string_eq((*node._v__ast__Module).name, _SLIT("strconv")));
		v__checker__Checker_check_valid_snake_case(c, (*node._v__ast__Module).name, _SLIT("module name"), (*node._v__ast__Module).pos);
	}
	else if (node._typ == 305 /* v.ast.Return */) {
		v__checker__Checker_return_stmt(c, (voidptr)&/*qq*/(*node._v__ast__Return));
		c->scope_returns = true;
	}
	else if (node._typ == 306 /* v.ast.SqlStmt */) {
		v__checker__Checker_sql_stmt(c, (voidptr)&/*qq*/(*node._v__ast__SqlStmt));
	}
	else if (node._typ == 307 /* v.ast.StructDecl */) {
		v__checker__Checker_struct_decl(c, (voidptr)&/*qq*/(*node._v__ast__StructDecl));
	}
	else if (node._typ == 232 /* v.ast.TypeDecl */) {
		v__checker__Checker_type_decl(c, (*node._v__ast__TypeDecl));
	};
}

VV_LOCAL_SYMBOL void v__checker__Checker_assert_stmt(v__checker__Checker* c, v__ast__AssertStmt node) {
	v__ast__Type cur_exp_typ = c->expected_type;
	v__ast__Type assert_type = v__checker__Checker_check_expr_opt_call(c, node.expr, v__checker__Checker_expr(c, node.expr));
	if (assert_type != _const_v__ast__bool_type_idx) {
		string atype_name = v__ast__Table_get_type_symbol(c->table, assert_type)->name;
		v__checker__Checker_error(c, _STR("assert can be used only with `bool` expressions, but found `%.*s\000` instead", 2, atype_name), node.pos);
	}
	c->expected_type = cur_exp_typ;
}

VV_LOCAL_SYMBOL void v__checker__Checker_block(v__checker__Checker* c, v__ast__Block node) {
	if (node.is_unsafe) {
		c->inside_unsafe = true;
		v__checker__Checker_stmts(c, node.stmts);
		c->inside_unsafe = false;
	} else {
		v__checker__Checker_stmts(c, node.stmts);
	}
}

VV_LOCAL_SYMBOL void v__checker__Checker_branch_stmt(v__checker__Checker* c, v__ast__BranchStmt node) {
	if (c->in_for_count == 0) {
		v__checker__Checker_error(c, _STR("%.*s\000 statement not within a loop", 2, v__token__Kind_str(node.kind)), node.pos);
	}
	if (node.label.len > 0) {
		if (string_ne(node.label, c->loop_label)) {
			v__checker__Checker_error(c, _STR("invalid label name `%.*s\000`", 2, node.label), node.pos);
		}
	}
}

VV_LOCAL_SYMBOL void v__checker__Checker_for_c_stmt(v__checker__Checker* c, v__ast__ForCStmt node) {
	c->in_for_count++;
	string prev_loop_label = c->loop_label;
	if (node.has_init) {
		v__checker__Checker_stmt(c, node.init);
	}
	v__checker__Checker_expr(c, node.cond);
	if (node.has_inc) {
		v__checker__Checker_stmt(c, node.inc);
	}
	v__checker__Checker_check_loop_label(c, node.label, node.pos);
	v__checker__Checker_stmts(c, node.stmts);
	c->loop_label = prev_loop_label;
	c->in_for_count--;
}

VV_LOCAL_SYMBOL void v__checker__Checker_for_in_stmt(v__checker__Checker* c, v__ast__ForInStmt* node) {
	c->in_for_count++;
	string prev_loop_label = c->loop_label;
	v__ast__Type typ = v__checker__Checker_expr(c, node->cond);
	int typ_idx = v__ast__Type_idx(typ);
	if (node->key_var.len > 0 && string_ne(node->key_var, _SLIT("_"))) {
		v__checker__Checker_check_valid_snake_case(c, node->key_var, _SLIT("variable name"), node->pos);
	}
	if (node->val_var.len > 0 && string_ne(node->val_var, _SLIT("_"))) {
		v__checker__Checker_check_valid_snake_case(c, node->val_var, _SLIT("variable name"), node->pos);
	}
	if (node->is_range) {
		v__ast__Type high_type = v__checker__Checker_expr(c, node->high);
		int high_type_idx = v__ast__Type_idx(high_type);
		if ((Array_int_contains(_const_v__ast__integer_type_idxs, typ_idx)) && !(Array_int_contains(_const_v__ast__integer_type_idxs, high_type_idx))) {
			v__checker__Checker_error(c, _SLIT("range types do not match"), v__ast__Expr_position(node->cond));
		} else if ((Array_int_contains(_const_v__ast__float_type_idxs, typ_idx)) || (Array_int_contains(_const_v__ast__float_type_idxs, high_type_idx))) {
			v__checker__Checker_error(c, _SLIT("range type can not be float"), v__ast__Expr_position(node->cond));
		} else if (typ_idx == _const_v__ast__bool_type_idx || high_type_idx == _const_v__ast__bool_type_idx) {
			v__checker__Checker_error(c, _SLIT("range type can not be bool"), v__ast__Expr_position(node->cond));
		} else if (typ_idx == _const_v__ast__string_type_idx || high_type_idx == _const_v__ast__string_type_idx) {
			v__checker__Checker_error(c, _SLIT("range type can not be string"), v__ast__Expr_position(node->cond));
		}
	} else {
		v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(c->table, typ);
		if (sym->kind == v__ast__Kind_struct_) {
			Option_v__ast__Fn _t2044 = v__ast__TypeSymbol_find_method(sym, _SLIT("next"));
			if (_t2044.state != 0) { /*or block*/ 
				IError err = _t2044.err;
				v__checker__Checker_error(c, _SLIT("a struct must have a `next()` method to be an iterator"), v__ast__Expr_position(node->cond));
				return;
			}
 			v__ast__Fn next_fn =  *(v__ast__Fn*)_t2044.data;
			if (!v__ast__Type_has_flag(next_fn.return_type, v__ast__TypeFlag_optional)) {
				v__checker__Checker_error(c, _SLIT("iterator method `next()` must return an optional"), v__ast__Expr_position(node->cond));
			}
			if (next_fn.params.len != 1) {
				v__checker__Checker_error(c, _SLIT("iterator method `next()` must have 0 parameters"), v__ast__Expr_position(node->cond));
			}
			v__ast__Type val_type = v__ast__Type_clear_flag(next_fn.return_type, v__ast__TypeFlag_optional);
			node->cond_type = typ;
			node->kind = sym->kind;
			node->val_type = val_type;
			v__ast__Scope_update_var_type(node->scope, node->val_var, val_type);
		} else {
			if (sym->kind == v__ast__Kind_map && !(node->key_var.len > 0 && node->val_var.len > 0)) {
				v__checker__Checker_error(c, string_add(_SLIT("declare a key and a value variable when ranging a map: `for key, val in map {`\n"), _SLIT("use `_` if you do not need the variable")), node->pos);
			}
			if (node->key_var.len > 0) {
				v__ast__Type key_type = ((sym->kind == (v__ast__Kind_map)) ? (v__ast__TypeSymbol_map_info(sym).key_type) : (_const_v__ast__int_type));
				node->key_type = key_type;
				v__ast__Scope_update_var_type(node->scope, node->key_var, key_type);
			}
			v__ast__Type value_type = v__ast__Table_value_type(c->table, typ);
			if (v__ast__Type_alias_eq(value_type, _const_v__ast__void_type) || v__ast__Type_has_flag(typ, v__ast__TypeFlag_optional)) {
				if (!v__ast__Type_alias_eq(typ, _const_v__ast__void_type)) {
					v__checker__Checker_error(c, _STR("for in: cannot index `%.*s\000`", 2, v__ast__Table_type_to_str(c->table, typ)), v__ast__Expr_position(node->cond));
				}
			}
			if (node->val_is_mut) {
				value_type = v__ast__Type_to_ptr(value_type);
				if (node->cond._typ == 254 /* v.ast.Ident */) {
					if (((*node->cond._v__ast__Ident).obj)._typ == 312 /* v.ast.Var */) {
						v__ast__Var obj = /* as */ *(v__ast__Var*)__as_cast(((*node->cond._v__ast__Ident).obj)._v__ast__Var,((*node->cond._v__ast__Ident).obj)._typ, 312) /*expected idx: 312, name: v.ast.Var */ ;
						if (!obj.is_mut) {
							v__checker__Checker_error(c, _STR("`%.*s\000` is immutable, it cannot be changed", 2, obj.name), (*node->cond._v__ast__Ident).pos);
						}
					}
				}
				else if (node->cond._typ == 235 /* v.ast.ArrayInit */) {
					v__checker__Checker_error(c, _SLIT("array literal is immutable, it cannot be changed"), (*node->cond._v__ast__ArrayInit).pos);
				}
				else if (node->cond._typ == 262 /* v.ast.MapInit */) {
					v__checker__Checker_error(c, _SLIT("map literal is immutable, it cannot be changed"), (*node->cond._v__ast__MapInit).pos);
				}
				else {
				};
			}
			node->cond_type = typ;
			node->kind = sym->kind;
			node->val_type = value_type;
			v__ast__Scope_update_var_type(node->scope, node->val_var, value_type);
		}
	}
	v__checker__Checker_check_loop_label(c, node->label, node->pos);
	v__checker__Checker_stmts(c, node->stmts);
	c->loop_label = prev_loop_label;
	c->in_for_count--;
}

VV_LOCAL_SYMBOL void v__checker__Checker_for_stmt(v__checker__Checker* c, v__ast__ForStmt* node) {
	c->in_for_count++;
	string prev_loop_label = c->loop_label;
	c->expected_type = _const_v__ast__bool_type;
	v__ast__Type typ = v__checker__Checker_expr(c, node->cond);
	if (!node->is_inf && v__ast__Type_idx(typ) != _const_v__ast__bool_type_idx && !c->pref->translated) {
		v__checker__Checker_error(c, _SLIT("non-bool used as for condition"), node->pos);
	}
	if ((node->cond)._typ == 258 /* v.ast.InfixExpr */) {
		v__ast__InfixExpr infix = (*node->cond._v__ast__InfixExpr);
		if (infix.op == v__token__Kind_key_is) {
			if (((infix.left)._typ == 254 /* v.ast.Ident */ || (infix.left)._typ == 273 /* v.ast.SelectorExpr */) && (infix.right)._typ == 279 /* v.ast.TypeNode */) {
				v__ast__TypeNode right_expr = /* as */ *(v__ast__TypeNode*)__as_cast((infix.right)._v__ast__TypeNode,(infix.right)._typ, 279) /*expected idx: 279, name: v.ast.TypeNode */ ;
				bool is_variable = ((infix.left)._typ == 254 /* v.ast.Ident */ ? ((*infix.left._v__ast__Ident).kind == v__ast__IdentKind_variable) : (true));
				v__ast__Type left_type = v__checker__Checker_expr(c, infix.left);
				v__ast__TypeSymbol* left_sym = v__ast__Table_get_type_symbol(c->table, left_type);
				if (is_variable) {
					if ((left_sym->kind == v__ast__Kind_sum_type || left_sym->kind == v__ast__Kind_interface_)) {
						v__checker__Checker_smartcast(c, infix.left, infix.left_type, right_expr.typ, node->scope);
					}
				}
			}
		}
	}
	v__checker__Checker_check_loop_label(c, node->label, node->pos);
	v__checker__Checker_stmts(c, node->stmts);
	c->loop_label = prev_loop_label;
	c->in_for_count--;
}

VV_LOCAL_SYMBOL void v__checker__Checker_global_decl(v__checker__Checker* c, v__ast__GlobalDecl node) {
	// FOR IN array
	for (int _t2045 = 0; _t2045 < node.fields.len; ++_t2045) {
		v__ast__GlobalField field = ((v__ast__GlobalField*)node.fields.data)[_t2045];
		v__checker__Checker_check_valid_snake_case(c, field.name, _SLIT("global name"), field.pos);
		if ((Array_string_contains(c->global_names, field.name))) {
			v__checker__Checker_error(c, _STR("duplicate global `%.*s\000`", 2, field.name), field.pos);
		}
		array_push(&c->global_names, _MOV((string[]){ string_clone(field.name) }));
	}
}

VV_LOCAL_SYMBOL void v__checker__Checker_go_stmt(v__checker__Checker* c, v__ast__GoStmt* node) {
	v__checker__Checker_call_expr(c, (voidptr)&/*qq*/node->call_expr);
	// FOR IN array
	for (int _t2047 = 0; _t2047 < node->call_expr.args.len; ++_t2047) {
		v__ast__CallArg arg = ((v__ast__CallArg*)node->call_expr.args.data)[_t2047];
		if (arg.is_mut && !v__ast__Type_is_ptr(arg.typ)) {
			v__checker__Checker_error(c, _SLIT("function in `go` statement cannot contain mutable non-reference arguments"), v__ast__Expr_position(arg.expr));
		}
	}
	if (node->call_expr.is_method && v__ast__Type_is_ptr(node->call_expr.receiver_type) && !v__ast__Type_is_ptr(node->call_expr.left_type)) {
		v__checker__Checker_error(c, _SLIT("method in `go` statement cannot have non-reference mutable receiver"), v__ast__Expr_position(node->call_expr.left));
	}
}

VV_LOCAL_SYMBOL void v__checker__Checker_asm_stmt(v__checker__Checker* c, v__ast__AsmStmt* stmt) {
	if (stmt->is_goto) {
		v__checker__Checker_warn(c, _SLIT("inline assembly goto is not supported, it will most likely not work"), stmt->pos);
	}
	if (c->pref->backend == v__pref__Backend_js) {
		v__checker__Checker_error(c, _SLIT("inline assembly is not supported in js backend"), stmt->pos);
	}
	if (c->pref->backend == v__pref__Backend_c && c->pref->ccompiler_type == v__pref__CompilerType_msvc) {
		v__checker__Checker_error(c, _SLIT("msvc compiler does not support inline assembly"), stmt->pos);
	}
	Array_string aliases = v__checker__Checker_asm_ios(c, stmt->output, stmt->scope, true);
	Array_string aliases2 = v__checker__Checker_asm_ios(c, stmt->input, stmt->scope, false);
	_PUSH_MANY(&aliases, (aliases2), _t2048, Array_string);
	// FOR IN array
	for (int _t2049 = 0; _t2049 < stmt->templates.len; ++_t2049) {
		v__ast__AsmTemplate v_template = ((v__ast__AsmTemplate*)stmt->templates.data)[_t2049];
		if (v_template.is_directive) {
			if (!(string_eq(v_template.name, _SLIT("skip")) || string_eq(v_template.name, _SLIT("space")) || string_eq(v_template.name, _SLIT("byte")) || string_eq(v_template.name, _SLIT("word")) || string_eq(v_template.name, _SLIT("short")) || string_eq(v_template.name, _SLIT("int")) || string_eq(v_template.name, _SLIT("long")) || string_eq(v_template.name, _SLIT("quad")) || string_eq(v_template.name, _SLIT("globl")) || string_eq(v_template.name, _SLIT("global")) || string_eq(v_template.name, _SLIT("section")) || string_eq(v_template.name, _SLIT("text")) || string_eq(v_template.name, _SLIT("data")) || string_eq(v_template.name, _SLIT("bss")) || string_eq(v_template.name, _SLIT("fill")) || string_eq(v_template.name, _SLIT("org")) || string_eq(v_template.name, _SLIT("previous")) || string_eq(v_template.name, _SLIT("string")) || string_eq(v_template.name, _SLIT("asciz")) || string_eq(v_template.name, _SLIT("ascii")))) {
				v__checker__Checker_error(c, _STR("unknown assembler directive: `%.*s\000`", 2, v_template.name), v_template.pos);
			}
		}
		// FOR IN array
		for (int _t2050 = 0; _t2050 < v_template.args.len; ++_t2050) {
			v__ast__AsmArg* arg = ((v__ast__AsmArg*)v_template.args.data) + _t2050;
			v__checker__Checker_asm_arg(c, *arg, *stmt, aliases);
		}
	}
	// FOR IN array
	for (int _t2051 = 0; _t2051 < stmt->clobbered.len; ++_t2051) {
		v__ast__AsmClobbered* clob = ((v__ast__AsmClobbered*)stmt->clobbered.data) + _t2051;
		v__checker__Checker_asm_arg(c, v__ast__AsmRegister_to_sumtype_v__ast__AsmArg(ADDR(v__ast__AsmRegister, (clob->reg))), *stmt, aliases);
	}
}

VV_LOCAL_SYMBOL void v__checker__Checker_asm_arg(v__checker__Checker* c, v__ast__AsmArg arg, v__ast__AsmStmt stmt, Array_string aliases) {
	if (arg._typ == 384 /* v.ast.AsmAlias */) {
		string name = (*arg._v__ast__AsmAlias).name;
		if (!(Array_string_contains(aliases, name)) && !(Array_string_contains(stmt.local_labels, name)) && !(Array_string_contains(c->file->global_labels, name))) {
			Array_string possible = array_clone(&aliases);
			_PUSH_MANY(&possible, (stmt.local_labels), _t2052, Array_string);
			_PUSH_MANY(&possible, (c->file->global_labels), _t2053, Array_string);
			v__util__Suggestion suggestion = v__util__new_suggestion(name, possible);
			v__checker__Checker_error(c, v__util__Suggestion_say(suggestion, _STR("alias or label `%.*s\000` does not exist", 2, (*arg._v__ast__AsmAlias).name)), (*arg._v__ast__AsmAlias).pos);
		}
	}
	else if (arg._typ == 383 /* v.ast.AsmAddressing */) {
		if (!((*arg._v__ast__AsmAddressing).scale == -1 || (*arg._v__ast__AsmAddressing).scale == 1 || (*arg._v__ast__AsmAddressing).scale == 2 || (*arg._v__ast__AsmAddressing).scale == 4 || (*arg._v__ast__AsmAddressing).scale == 8)) {
			v__checker__Checker_error(c, _SLIT("scale must be one of 1, 2, 4, or 8"), (*arg._v__ast__AsmAddressing).pos);
		}
		v__checker__Checker_asm_arg(c, (*arg._v__ast__AsmAddressing).displacement, stmt, aliases);
		v__checker__Checker_asm_arg(c, (*arg._v__ast__AsmAddressing).base, stmt, aliases);
		v__checker__Checker_asm_arg(c, (*arg._v__ast__AsmAddressing).index, stmt, aliases);
	}
	else if (arg._typ == 239 /* v.ast.BoolLiteral */) {
	}
	else if (arg._typ == 252 /* v.ast.FloatLiteral */) {
	}
	else if (arg._typ == 244 /* v.ast.CharLiteral */) {
	}
	else if (arg._typ == 259 /* v.ast.IntegerLiteral */) {
	}
	else if (arg._typ == 309 /* v.ast.AsmRegister */) {
	}
	else if (arg._typ == 385 /* v.ast.AsmDisp */) {
	}
	else if (arg._typ == 18 /* string */) {
	};
}

VV_LOCAL_SYMBOL Array_string v__checker__Checker_asm_ios(v__checker__Checker* c, Array_v__ast__AsmIO ios, v__ast__Scope* scope, bool output) {
	Array_string aliases = __new_array_with_default(0, 0, sizeof(string), 0);
	// FOR IN array
	for (int _t2054 = 0; _t2054 < ios.len; ++_t2054) {
		v__ast__AsmIO io = ((v__ast__AsmIO*)ios.data)[_t2054];
		v__ast__Type typ = v__checker__Checker_expr(c, io.expr);
		if (output) {
			v__checker__Checker_fail_if_immutable(c, io.expr);
		}
		if ((io.alias).len != 0) {
			array_push(&aliases, _MOV((string[]){ string_clone(io.alias) }));
			if (_IN_MAP(ADDR(string, io.alias), ADDR(map, scope->objects))) {
				map_set(&scope->objects, &(string[]){io.alias}, &(v__ast__ScopeObject[]) { v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){
					.name = io.alias,
					.expr = io.expr,
					.share = 0,
					.is_mut = 0,
					.is_autofree_tmp = 0,
					.is_arg = true,
					.is_auto_deref = 0,
					.typ = typ,
					.orig_type = typ,
					.smartcasts = __new_array(0, 1, sizeof(v__ast__Type)),
					.pos = io.pos,
					.is_used = 0,
					.is_changed = 0,
					.is_or = 0,
					.is_tmp = 0,
				}))) });
			}
		}
	}
	// autofree_scope_vars(pos=133487 line_nr=3906 scope.pos=133037 scope.end_pos=133503)
	// var "c" var.pos=133042 var.line_nr=3884
	// var "ios" var.pos=133061 var.line_nr=3884
	// var "scope" var.pos=133082 var.line_nr=3884
	// var "output" var.pos=133099 var.line_nr=3884
	// var "aliases" var.pos=133128 var.line_nr=3885
	// af parent scope:
	// af parent scope:
	return aliases;
}

VV_LOCAL_SYMBOL void v__checker__Checker_hash_stmt(v__checker__Checker* c, v__ast__HashStmt* node) {
	if (c->skip_flags) {
		return;
	}
	if (c->pref->backend == v__pref__Backend_js) {
		if (!string_ends_with(c->file->path, _SLIT(".js.v"))) {
			v__checker__Checker_error(c, _SLIT("hash statements are only allowed in backend specific files such \"x.js.v\""), node->pos);
		}
		if (string_eq(c->mod, _SLIT("main"))) {
			v__checker__Checker_error(c, _SLIT("hash statements are not allowed in the main module. Please place them in a separate module."), node->pos);
		}
		return;
	}

	if (string_eq(node->kind, _SLIT("include"))) {
		string flag = node->main;
		if (string_contains(flag, _SLIT("@VROOT"))) {
			Option_string _t2056 = v__util__resolve_vroot(flag, c->file->path);
			if (_t2056.state != 0) { /*or block*/ 
				IError err = _t2056.err;
				v__checker__Checker_error(c, (*(err.msg)), node->pos);
				return;
			}
 			string vroot =  *(string*)_t2056.data;
			node->val = _STR("include %.*s", 1, vroot);
			node->main = vroot;
			flag = vroot;
		}
		if (string_contains(flag, _SLIT("$env("))) {
			Option_string _t2057 = v__util__resolve_env_value(flag, true);
			if (_t2057.state != 0) { /*or block*/ 
				IError err = _t2057.err;
				v__checker__Checker_error(c, (*(err.msg)), node->pos);
				return;
			}
 			string env =  *(string*)_t2057.data;
			node->main = env;
		}
		string flag_no_comment = string_trim_space(string_all_before(flag, _SLIT("//")));
		if (!((string_starts_with(flag_no_comment, _SLIT("\"")) && string_ends_with(flag_no_comment, _SLIT("\""))) || (string_starts_with(flag_no_comment, _SLIT("<")) && string_ends_with(flag_no_comment, _SLIT(">"))))) {
			v__checker__Checker_error(c, _SLIT("including C files should use either `\"header_file.h\"` or `<header_file.h>` quoting"), node->pos);
		}
	}
	else if (string_eq(node->kind, _SLIT("pkgconfig"))) {
		Array_string args = (string_contains(node->main, _SLIT("--")) ? (string_split(node->main, _SLIT(" "))) : (string_split(_STR("--cflags --libs %.*s", 1, node->main), _SLIT(" "))));
		Option_v__pkgconfig__Main_ptr _t2058 = v__pkgconfig__main(args);
		if (_t2058.state != 0) { /*or block*/ 
			IError err = _t2058.err;
			v__checker__Checker_error(c, (*(err.msg)), node->pos);
			return;
		}
 		v__pkgconfig__Main* m =  *(v__pkgconfig__Main**)_t2058.data;
		Option_string _t2059 = v__pkgconfig__Main_run(m);
		if (_t2059.state != 0) { /*or block*/ 
			IError err = _t2059.err;
			v__checker__Checker_error(c, (*(err.msg)), node->pos);
			return;
		}
 		string cflags =  *(string*)_t2059.data;
		Option_bool _t2060 = v__ast__Table_parse_cflag(c->table, cflags, c->mod, c->pref->compile_defines_all);
		if (_t2060.state != 0) { /*or block*/ 
			IError err = _t2060.err;
			v__checker__Checker_error(c, (*(err.msg)), node->pos);
			return;
		};
	}
	else if (string_eq(node->kind, _SLIT("flag"))) {
		string flag = node->main;
		if (string_contains(flag, _SLIT("@VROOT"))) {
			Option_string _t2061 = v__util__resolve_vroot(flag, c->file->path);
			if (_t2061.state != 0) { /*or block*/ 
				IError err = _t2061.err;
				v__checker__Checker_error(c, (*(err.msg)), node->pos);
				return;
			}
 			flag =  *(string*)_t2061.data;
		}
		if (string_contains(flag, _SLIT("$env("))) {
			Option_string _t2062 = v__util__resolve_env_value(flag, true);
			if (_t2062.state != 0) { /*or block*/ 
				IError err = _t2062.err;
				v__checker__Checker_error(c, (*(err.msg)), node->pos);
				return;
			}
 			flag =  *(string*)_t2062.data;
		}
		// FOR IN array
		Array_string _t2063 = new_array_from_c_array(4, 4, sizeof(string), _MOV((string[4]){_SLIT("@VMOD"), _SLIT("@VMODULE"), _SLIT("@VPATH"), _SLIT("@VLIB_PATH")}));
		for (int _t2064 = 0; _t2064 < _t2063.len; ++_t2064) {
			string deprecated = ((string*)_t2063.data)[_t2064];
			if (string_contains(flag, deprecated)) {
				v__checker__Checker_error(c, _STR("%.*s\000 had been deprecated, use @VROOT instead.", 2, deprecated), node->pos);
			}
		}
		Option_bool _t2065 = v__ast__Table_parse_cflag(c->table, flag, c->mod, c->pref->compile_defines_all);
		if (_t2065.state != 0) { /*or block*/ 
			IError err = _t2065.err;
			v__checker__Checker_error(c, (*(err.msg)), node->pos);
		};
	}
	else {
		if (string_ne(node->kind, _SLIT("define"))) {
			v__checker__Checker_error(c, _STR("expected `#define`, `#flag`, `#include` or `#pkgconfig` not %.*s", 1, node->val), node->pos);
		}
	};
}

VV_LOCAL_SYMBOL void v__checker__Checker_import_stmt(v__checker__Checker* c, v__ast__Import imp) {
	v__checker__Checker_check_valid_snake_case(c, imp.alias, _SLIT("module alias"), imp.pos);
	// FOR IN array
	for (int _t2066 = 0; _t2066 < imp.syms.len; ++_t2066) {
		v__ast__ImportSymbol sym = ((v__ast__ImportSymbol*)imp.syms.data)[_t2066];
		string name = _STR("%.*s\000.%.*s", 2, imp.mod, sym.name);
		if (byte_is_capital(string_at(sym.name, 0))) {
			Option_v__ast__TypeSymbol _t2067;
			if (_t2067 = v__ast__Table_find_type(c->table, name), _t2067.state == 0) {
				v__ast__TypeSymbol type_sym = *(v__ast__TypeSymbol*)_t2067.data;
				if (type_sym.kind != v__ast__Kind_placeholder) {
					if (!type_sym.is_public) {
						v__checker__Checker_error(c, _STR("module `%.*s\000` type `%.*s\000` is private", 3, imp.mod, sym.name), sym.pos);
					}
					continue;
				}
			}
			v__checker__Checker_error(c, _STR("module `%.*s\000` has no type `%.*s\000`", 3, imp.mod, sym.name), sym.pos);
			continue;
		}
		Option_v__ast__Fn _t2068;
		if (_t2068 = v__ast__Table_find_fn(c->table, name), _t2068.state == 0) {
			v__ast__Fn func = *(v__ast__Fn*)_t2068.data;
			if (!func.is_pub) {
				v__checker__Checker_error(c, _STR("module `%.*s\000` function `%.*s\000()` is private", 3, imp.mod, sym.name), sym.pos);
			}
			continue;
		}
		Option_v__ast__ConstField_ptr _t2069;
		if (_t2069 = v__ast__Scope_find_const(c->file->global_scope, name), _t2069.state == 0) {
			continue;
		}
		v__checker__Checker_error(c, _STR("module `%.*s\000` has no constant or function `%.*s\000`", 3, imp.mod, sym.name), sym.pos);
	}
}

VV_LOCAL_SYMBOL void v__checker__Checker_stmts(v__checker__Checker* c, Array_v__ast__Stmt stmts) {
	v__token__Position unreachable = (v__token__Position){.len = 0,.line_nr = -1,.pos = 0,.col = 0,.last_line = 0,};
	c->expected_type = _const_v__ast__void_type;
	// FOR IN array
	for (int _t2070 = 0; _t2070 < stmts.len; ++_t2070) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)stmts.data)[_t2070];
		if (c->scope_returns) {
			if (unreachable.line_nr == -1) {
				unreachable = (*(stmt.pos));
			}
		}
		v__checker__Checker_stmt(c, stmt);
	}
	if (unreachable.line_nr >= 0) {
		v__checker__Checker_error(c, _SLIT("unreachable code"), unreachable);
	}
	c->scope_returns = false;
	c->expected_type = _const_v__ast__void_type;
}

v__ast__Type v__checker__Checker_unwrap_generic(v__checker__Checker* c, v__ast__Type typ) {
	if (v__ast__Type_has_flag(typ, v__ast__TypeFlag_generic)) {
		Option_v__ast__Type _t2071;
		if (_t2071 = v__ast__Table_resolve_generic_by_names(c->table, typ, c->cur_fn->generic_names, c->cur_generic_types), _t2071.state == 0) {
			v__ast__Type t_typ = *(v__ast__Type*)_t2071.data;
			// autofree_scope_vars(pos=137383 line_nr=4056 scope.pos=137379 scope.end_pos=137399)
			// af parent scope:
			// var "t_typ" var.pos=137287 var.line_nr=4055
			// af parent scope:
			// af parent scope:
			// var "c" var.pos=137202 var.line_nr=4053
			// var "typ" var.pos=137228 var.line_nr=4053
			// af parent scope:
			// af parent scope:
			return t_typ;
		}
	}
	// autofree_scope_vars(pos=137404 line_nr=4059 scope.pos=137197 scope.end_pos=137416)
	// var "c" var.pos=137202 var.line_nr=4053
	// var "typ" var.pos=137228 var.line_nr=4053
	// af parent scope:
	// af parent scope:
	return typ;
}

v__ast__Type v__checker__Checker_expr(v__checker__Checker* c, v__ast__Expr node) {
bool v__checker__Checker_expr_defer_0 = false;
	c->expr_level++;
	v__checker__Checker_expr_defer_0 = true;
	if (c->expr_level > 200) {
		v__checker__Checker_error(c, _STR("checker: too many expr levels: %"PRId32"\000 ", 2, c->expr_level), v__ast__Expr_position(node));
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		// autofree_scope_vars(pos=137645 line_nr=4070 scope.pos=137566 scope.end_pos=137668)
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return _const_v__ast__void_type;
	}
	if (node._typ == 264 /* v.ast.NodeError */) {
	}
	else if (node._typ == 250 /* v.ast.EmptyExpr */) {
		v__checker__Checker_error(c, _SLIT("checker.expr(): unhandled EmptyExpr"), (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,});
	}
	else if (node._typ == 240 /* v.ast.CTempVar */) {
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		 v__ast__Type _t2072 = (*node._v__ast__CTempVar).typ;
		// autofree_scope_vars(pos=137816 line_nr=4078 scope.pos=137799 scope.end_pos=137835)
		// var "node" var.pos=137681 var.line_nr=4072
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return _t2072;
	}
	else if (node._typ == 233 /* v.ast.AnonFn */) {
		c->inside_anon_fn = true;
		v__ast__FnDecl* keep_fn = c->cur_fn;
		c->cur_fn = &(*node._v__ast__AnonFn).decl;
		v__checker__Checker_stmts(c, (*node._v__ast__AnonFn).decl.stmts);
		v__checker__Checker_fn_decl(c, (voidptr)&/*qq*/(*node._v__ast__AnonFn).decl);
		c->cur_fn = keep_fn;
		c->inside_anon_fn = false;
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		 v__ast__Type _t2073 = (*node._v__ast__AnonFn).typ;
		// autofree_scope_vars(pos=138035 line_nr=4088 scope.pos=137839 scope.end_pos=138054)
		// var "keep_fn" var.pos=137882 var.line_nr=4082
		// var "node" var.pos=137681 var.line_nr=4072
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return _t2073;
	}
	else if (node._typ == 234 /* v.ast.ArrayDecompose */) {
		v__ast__Type typ = v__checker__Checker_expr(c, (*node._v__ast__ArrayDecompose).expr);
		v__ast__TypeSymbol* type_sym = v__ast__Table_get_type_symbol(c->table, typ);
		if (type_sym->kind != v__ast__Kind_array) {
			v__checker__Checker_error(c, _SLIT("decomposition can only be used on arrays"), v__ast__Expr_position((*node._v__ast__ArrayDecompose).expr));
			// Defer begin
			if (v__checker__Checker_expr_defer_0 == true) {
				c->expr_level--;
			}
			// Defer end
			// autofree_scope_vars(pos=138264 line_nr=4095 scope.pos=138181 scope.end_pos=138289)
			// af parent scope:
			// var "typ" var.pos=138082 var.line_nr=4091
			// var "type_sym" var.pos=138110 var.line_nr=4092
			// var "array_info" var.pos=138294 var.line_nr=4097
			// var "elem_type" var.pos=138338 var.line_nr=4098
			// var "node" var.pos=137681 var.line_nr=4072
			// af parent scope:
			// var "c" var.pos=137456 var.line_nr=4063
			// var "node" var.pos=137472 var.line_nr=4063
			// af parent scope:
			// af parent scope:
			return _const_v__ast__void_type;
		}
		v__ast__Array array_info = /* as */ *(v__ast__Array*)__as_cast((type_sym->info)._v__ast__Array,(type_sym->info)._typ, 395) /*expected idx: 395, name: v.ast.Array */ ;
		v__ast__Type elem_type = v__ast__Type_set_flag(array_info.elem_type, v__ast__TypeFlag_variadic);
		(*node._v__ast__ArrayDecompose).expr_type = typ;
		(*node._v__ast__ArrayDecompose).arg_type = elem_type;
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		// autofree_scope_vars(pos=138447 line_nr=4101 scope.pos=138058 scope.end_pos=138467)
		// var "typ" var.pos=138082 var.line_nr=4091
		// var "type_sym" var.pos=138110 var.line_nr=4092
		// var "array_info" var.pos=138294 var.line_nr=4097
		// var "elem_type" var.pos=138338 var.line_nr=4098
		// var "node" var.pos=137681 var.line_nr=4072
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return elem_type;
	}
	else if (node._typ == 235 /* v.ast.ArrayInit */) {
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		 v__ast__Type _t2074 = v__checker__Checker_array_init(c, (voidptr)&/*qq*/(*node._v__ast__ArrayInit));
		// autofree_scope_vars(pos=138489 line_nr=4104 scope.pos=138471 scope.end_pos=138522)
		// var "node" var.pos=137681 var.line_nr=4072
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return _t2074;
	}
	else if (node._typ == 236 /* v.ast.AsCast */) {
		(*node._v__ast__AsCast).expr_type = v__checker__Checker_expr(c, (*node._v__ast__AsCast).expr);
		v__ast__TypeSymbol* expr_type_sym = v__ast__Table_get_type_symbol(c->table, (*node._v__ast__AsCast).expr_type);
		v__ast__TypeSymbol* type_sym = v__ast__Table_get_type_symbol(c->table, (*node._v__ast__AsCast).typ);
		if (expr_type_sym->kind == v__ast__Kind_sum_type) {
			Option_void _t2075 = v__checker__Checker_ensure_type_exists(c, (*node._v__ast__AsCast).typ, (*node._v__ast__AsCast).pos);
			if (_t2075.state != 0 && _t2075.err._typ != _IError_None___index) {
				IError err = _t2075.err;
			};
			if (!v__ast__Table_sumtype_has_variant(c->table, (*node._v__ast__AsCast).expr_type, (*node._v__ast__AsCast).typ)) {
				v__checker__Checker_error(c, _STR("cannot cast `%.*s\000` to `%.*s\000`", 3, expr_type_sym->name, type_sym->name), (*node._v__ast__AsCast).pos);
			}
		} else {
			string s = _STR("cannot cast non-sum type `%.*s\000` using `as`", 2, expr_type_sym->name);
			if (type_sym->kind == v__ast__Kind_sum_type) {
				s = /*f*/string_add(s, _STR(" - use e.g. `%.*s\000(some_expr)` instead.", 2, type_sym->name));
			}
			v__checker__Checker_error(c, s, (*node._v__ast__AsCast).pos);
		}
		if (expr_type_sym->kind == v__ast__Kind_sum_type) {
			// Defer begin
			if (v__checker__Checker_expr_defer_0 == true) {
				c->expr_level--;
			}
			// Defer end
			 v__ast__Type _t2076 = (*node._v__ast__AsCast).typ;
			// autofree_scope_vars(pos=139263 line_nr=4124 scope.pos=139258 scope.end_pos=139283)
			// af parent scope:
			// var "expr_type_sym" var.pos=138580 var.line_nr=4108
			// var "type_sym" var.pos=138640 var.line_nr=4109
			// var "node" var.pos=137681 var.line_nr=4072
			// af parent scope:
			// var "c" var.pos=137456 var.line_nr=4063
			// var "node" var.pos=137472 var.line_nr=4063
			// af parent scope:
			// af parent scope:
			return _t2076;
		}
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		 v__ast__Type _t2077 = v__ast__Type_to_ptr((*node._v__ast__AsCast).typ);
		// autofree_scope_vars(pos=139287 line_nr=4126 scope.pos=138526 scope.end_pos=139315)
		// var "expr_type_sym" var.pos=138580 var.line_nr=4108
		// var "type_sym" var.pos=138640 var.line_nr=4109
		// var "node" var.pos=137681 var.line_nr=4072
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return _t2077;
	}
	else if (node._typ == 237 /* v.ast.Assoc */) {
		Option_v__ast__Var_ptr _t2078 = v__ast__Scope_find_var((*node._v__ast__Assoc).scope, (*node._v__ast__Assoc).var_name);
		if (_t2078.state != 0) { /*or block*/ 
			IError err = _t2078.err;
			v_panic(IError_str(err));
		}
 		v__ast__Var* v =  *(v__ast__Var**)_t2078.data;
		// FOR IN array
		for (int i = 0; i < (*node._v__ast__Assoc).fields.len; ++i) {
			v__checker__Checker_expr(c, (*(v__ast__Expr*)/*ee elem_typ */array_get((*node._v__ast__Assoc).exprs, i)));
		}
		(*node._v__ast__Assoc).typ = v->typ;
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		 v__ast__Type _t2079 = v->typ;
		// autofree_scope_vars(pos=139474 line_nr=4134 scope.pos=139319 scope.end_pos=139490)
		// var "v" var.pos=139334 var.line_nr=4129
		// var "node" var.pos=137681 var.line_nr=4072
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return _t2079;
	}
	else if (node._typ == 239 /* v.ast.BoolLiteral */) {
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		// autofree_scope_vars(pos=139514 line_nr=4137 scope.pos=139494 scope.end_pos=139538)
		// var "node" var.pos=137681 var.line_nr=4072
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return _const_v__ast__bool_type;
	}
	else if (node._typ == 242 /* v.ast.CastExpr */) {
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		 v__ast__Type _t2080 = v__checker__Checker_cast_expr(c, (voidptr)&/*qq*/(*node._v__ast__CastExpr));
		// autofree_scope_vars(pos=139559 line_nr=4140 scope.pos=139542 scope.end_pos=139591)
		// var "node" var.pos=137681 var.line_nr=4072
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return _t2080;
	}
	else if (node._typ == 241 /* v.ast.CallExpr */) {
		v__ast__Type ret_type = v__checker__Checker_call_expr(c, (voidptr)&/*qq*/(*node._v__ast__CallExpr));
		if (!v__ast__Type_has_flag(ret_type, v__ast__TypeFlag_optional)) {
			if ((*node._v__ast__CallExpr).or_block.kind == v__ast__OrKind_block) {
				v__checker__Checker_error(c, _STR("unexpected `or` block, the function `%.*s\000` does not return an optional", 2, (*node._v__ast__CallExpr).name), (*node._v__ast__CallExpr).or_block.pos);
			} else if ((*node._v__ast__CallExpr).or_block.kind == v__ast__OrKind_propagate) {
				v__checker__Checker_error(c, _STR("unexpected `?`, the function `%.*s\000` does not return an optional", 2, (*node._v__ast__CallExpr).name), (*node._v__ast__CallExpr).or_block.pos);
			}
		}
		if (v__ast__Type_has_flag(ret_type, v__ast__TypeFlag_optional) && (*node._v__ast__CallExpr).or_block.kind != v__ast__OrKind_absent) {
			ret_type = v__ast__Type_clear_flag(ret_type, v__ast__TypeFlag_optional);
		}
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		// autofree_scope_vars(pos=140139 line_nr=4156 scope.pos=139595 scope.end_pos=140158)
		// var "ret_type" var.pos=139617 var.line_nr=4143
		// var "node" var.pos=137681 var.line_nr=4072
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return ret_type;
	}
	else if (node._typ == 253 /* v.ast.GoExpr */) {
		v__ast__Type ret_type = v__checker__Checker_call_expr(c, (voidptr)&/*qq*/(*node._v__ast__GoExpr).go_stmt.call_expr);
		if ((*node._v__ast__GoExpr).go_stmt.call_expr.or_block.kind != v__ast__OrKind_absent) {
			v__checker__Checker_error(c, _SLIT("optional handling cannot be done in `go` call. Do it when calling `.wait()`"), (*node._v__ast__GoExpr).go_stmt.call_expr.or_block.pos);
		}
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		 v__ast__Type _t2081 = v__ast__Table_find_or_register_thread(c->table, ret_type);
		// autofree_scope_vars(pos=140430 line_nr=4164 scope.pos=140162 scope.end_pos=140482)
		// var "ret_type" var.pos=140182 var.line_nr=4159
		// var "node" var.pos=137681 var.line_nr=4072
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return _t2081;
	}
	else if (node._typ == 243 /* v.ast.ChanInit */) {
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		 v__ast__Type _t2082 = v__checker__Checker_chan_init(c, (voidptr)&/*qq*/(*node._v__ast__ChanInit));
		// autofree_scope_vars(pos=140503 line_nr=4167 scope.pos=140486 scope.end_pos=140535)
		// var "node" var.pos=137681 var.line_nr=4072
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return _t2082;
	}
	else if (node._typ == 244 /* v.ast.CharLiteral */) {
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		// autofree_scope_vars(pos=140681 line_nr=4172 scope.pos=140539 scope.end_pos=140732)
		// var "node" var.pos=137681 var.line_nr=4072
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return _const_v__ast__rune_type;
	}
	else if (node._typ == 245 /* v.ast.Comment */) {
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		// autofree_scope_vars(pos=140752 line_nr=4176 scope.pos=140736 scope.end_pos=140776)
		// var "node" var.pos=137681 var.line_nr=4072
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return _const_v__ast__void_type;
	}
	else if (node._typ == 238 /* v.ast.AtExpr */) {
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		 v__ast__Type _t2083 = v__checker__Checker_at_expr(c, (voidptr)&/*qq*/(*node._v__ast__AtExpr));
		// autofree_scope_vars(pos=140795 line_nr=4179 scope.pos=140780 scope.end_pos=140825)
		// var "node" var.pos=137681 var.line_nr=4072
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return _t2083;
	}
	else if (node._typ == 246 /* v.ast.ComptimeCall */) {
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		 v__ast__Type _t2084 = v__checker__Checker_comptime_call(c, (voidptr)&/*qq*/(*node._v__ast__ComptimeCall));
		// autofree_scope_vars(pos=140850 line_nr=4182 scope.pos=140829 scope.end_pos=140886)
		// var "node" var.pos=137681 var.line_nr=4072
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return _t2084;
	}
	else if (node._typ == 247 /* v.ast.ComptimeSelector */) {
		(*node._v__ast__ComptimeSelector).left_type = v__checker__Checker_unwrap_generic(c, v__checker__Checker_expr(c, (*node._v__ast__ComptimeSelector).left));
		v__ast__Type expr_type = v__checker__Checker_unwrap_generic(c, v__checker__Checker_expr(c, (*node._v__ast__ComptimeSelector).field_expr));
		v__ast__TypeSymbol* expr_sym = v__ast__Table_get_type_symbol(c->table, expr_type);
		if (!v__ast__Type_alias_eq(expr_type, _const_v__ast__string_type)) {
			v__checker__Checker_error(c, _STR("expected `string` instead of `%.*s\000` (e.g. `field.name`)", 2, expr_sym->name), v__ast__Expr_position((*node._v__ast__ComptimeSelector).field_expr));
		}
		if (((*node._v__ast__ComptimeSelector).field_expr)._typ == 273 /* v.ast.SelectorExpr */) {
			v__token__Position left_pos = v__ast__Expr_position((*(*node._v__ast__ComptimeSelector).field_expr._v__ast__SelectorExpr).expr);
			if (c->comptime_fields_type.len == 0) {
				v__checker__Checker_error(c, _SLIT("compile time field access can only be used when iterating over `T.fields`"), left_pos);
			}
			string expr_name = v__ast__Expr_str((*(*node._v__ast__ComptimeSelector).field_expr._v__ast__SelectorExpr).expr);
			if (_IN_MAP(ADDR(string, expr_name), ADDR(map, c->comptime_fields_type))) {
				// Defer begin
				if (v__checker__Checker_expr_defer_0 == true) {
					c->expr_level--;
				}
				// Defer end
				 v__ast__Type _t2085 = (*(v__ast__Type*)map_get(ADDR(map, c->comptime_fields_type), &(string[]){expr_name}, &(v__ast__Type[]){ 0 }));
				// autofree_scope_vars(pos=141571 line_nr=4200 scope.pos=141565 scope.end_pos=141617)
				// af parent scope:
				// var "left_pos" var.pos=141281 var.line_nr=4193
				// var "expr_name" var.pos=141482 var.line_nr=4198
				// af parent scope:
				// var "expr_type" var.pos=140972 var.line_nr=4186
				// var "expr_sym" var.pos=141030 var.line_nr=4187
				// var "node" var.pos=137681 var.line_nr=4072
				// af parent scope:
				// var "c" var.pos=137456 var.line_nr=4063
				// var "node" var.pos=137472 var.line_nr=4063
				// af parent scope:
				// af parent scope:
				return _t2085;
			}
			v__checker__Checker_error(c, _STR("unknown `$for` variable `%.*s\000`", 2, expr_name), left_pos);
		} else {
			v__checker__Checker_error(c, _SLIT("expected selector expression e.g. `$(field.name)`"), v__ast__Expr_position((*node._v__ast__ComptimeSelector).field_expr));
		}
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		// autofree_scope_vars(pos=141794 line_nr=4206 scope.pos=140890 scope.end_pos=141818)
		// var "expr_type" var.pos=140972 var.line_nr=4186
		// var "expr_sym" var.pos=141030 var.line_nr=4187
		// var "node" var.pos=137681 var.line_nr=4072
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return _const_v__ast__void_type;
	}
	else if (node._typ == 248 /* v.ast.ConcatExpr */) {
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		 v__ast__Type _t2086 = v__checker__Checker_concat_expr(c, (voidptr)&/*qq*/(*node._v__ast__ConcatExpr));
		// autofree_scope_vars(pos=141841 line_nr=4209 scope.pos=141822 scope.end_pos=141875)
		// var "node" var.pos=137681 var.line_nr=4072
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return _t2086;
	}
	else if (node._typ == 249 /* v.ast.DumpExpr */) {
		(*node._v__ast__DumpExpr).expr_type = v__checker__Checker_expr(c, (*node._v__ast__DumpExpr).expr);
		if (v__ast__Type_idx((*node._v__ast__DumpExpr).expr_type) == _const_v__ast__void_type_idx) {
			v__checker__Checker_error(c, _SLIT("dump expression can not be void"), v__ast__Expr_position((*node._v__ast__DumpExpr).expr));
			// Defer begin
			if (v__checker__Checker_expr_defer_0 == true) {
				c->expr_level--;
			}
			// Defer end
			// autofree_scope_vars(pos=142054 line_nr=4215 scope.pos=141980 scope.end_pos=142079)
			// af parent scope:
			// var "tsym" var.pos=142084 var.line_nr=4217
			// var "node" var.pos=137681 var.line_nr=4072
			// af parent scope:
			// var "c" var.pos=137456 var.line_nr=4063
			// var "node" var.pos=137472 var.line_nr=4063
			// af parent scope:
			// af parent scope:
			return _const_v__ast__void_type;
		}
		v__ast__TypeSymbol* tsym = v__ast__Table_get_type_symbol(c->table, (*node._v__ast__DumpExpr).expr_type);
		map_set(&c->table->dumps, &(int[]){((int)((*node._v__ast__DumpExpr).expr_type))}, &(string[]) { tsym->cname });
		(*node._v__ast__DumpExpr).cname = tsym->cname;
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		 v__ast__Type _t2087 = (*node._v__ast__DumpExpr).expr_type;
		// autofree_scope_vars(pos=142212 line_nr=4220 scope.pos=141879 scope.end_pos=142237)
		// var "tsym" var.pos=142084 var.line_nr=4217
		// var "node" var.pos=137681 var.line_nr=4072
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return _t2087;
	}
	else if (node._typ == 251 /* v.ast.EnumVal */) {
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		 v__ast__Type _t2088 = v__checker__Checker_enum_val(c, (voidptr)&/*qq*/(*node._v__ast__EnumVal));
		// autofree_scope_vars(pos=142257 line_nr=4223 scope.pos=142241 scope.end_pos=142288)
		// var "node" var.pos=137681 var.line_nr=4072
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return _t2088;
	}
	else if (node._typ == 252 /* v.ast.FloatLiteral */) {
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		// autofree_scope_vars(pos=142313 line_nr=4226 scope.pos=142292 scope.end_pos=142346)
		// var "node" var.pos=137681 var.line_nr=4072
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return _const_v__ast__float_literal_type;
	}
	else if (node._typ == 254 /* v.ast.Ident */) {
		v__ast__Type res = v__checker__Checker_ident(c, (voidptr)&/*qq*/(*node._v__ast__Ident));
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		// autofree_scope_vars(pos=142453 line_nr=4232 scope.pos=142350 scope.end_pos=142467)
		// var "res" var.pos=142399 var.line_nr=4230
		// var "node" var.pos=137681 var.line_nr=4072
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return res;
	}
	else if (node._typ == 255 /* v.ast.IfExpr */) {
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		 v__ast__Type _t2089 = v__checker__Checker_if_expr(c, (voidptr)&/*qq*/(*node._v__ast__IfExpr));
		// autofree_scope_vars(pos=142486 line_nr=4235 scope.pos=142471 scope.end_pos=142516)
		// var "node" var.pos=137681 var.line_nr=4072
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return _t2089;
	}
	else if (node._typ == 256 /* v.ast.IfGuardExpr */) {
		(*node._v__ast__IfGuardExpr).expr_type = v__checker__Checker_expr(c, (*node._v__ast__IfGuardExpr).expr);
		if (!v__ast__Type_has_flag((*node._v__ast__IfGuardExpr).expr_type, v__ast__TypeFlag_optional)) {
			bool no_opt = true;
			if ((*node._v__ast__IfGuardExpr).expr._typ == 257 /* v.ast.IndexExpr */) {
				no_opt = false;
				(*node._v__ast__IfGuardExpr).expr_type = v__ast__Type_set_flag((*node._v__ast__IfGuardExpr).expr_type, v__ast__TypeFlag_optional);
				(*(*node._v__ast__IfGuardExpr).expr._v__ast__IndexExpr).is_option = true;
			}
			else if ((*node._v__ast__IfGuardExpr).expr._typ == 270 /* v.ast.PrefixExpr */) {
				if ((*(*node._v__ast__IfGuardExpr).expr._v__ast__PrefixExpr).op == v__token__Kind_arrow) {
					no_opt = false;
					(*node._v__ast__IfGuardExpr).expr_type = v__ast__Type_set_flag((*node._v__ast__IfGuardExpr).expr_type, v__ast__TypeFlag_optional);
					(*(*node._v__ast__IfGuardExpr).expr._v__ast__PrefixExpr).is_option = true;
				}
			}
			else {
			};
			if (no_opt) {
				v__checker__Checker_error(c, _SLIT("expression should return an option"), v__ast__Expr_position((*node._v__ast__IfGuardExpr).expr));
			}
		}
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		// autofree_scope_vars(pos=143116 line_nr=4260 scope.pos=142520 scope.end_pos=143140)
		// var "node" var.pos=137681 var.line_nr=4072
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return _const_v__ast__bool_type;
	}
	else if (node._typ == 257 /* v.ast.IndexExpr */) {
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		 v__ast__Type _t2090 = v__checker__Checker_index_expr(c, (voidptr)&/*qq*/(*node._v__ast__IndexExpr));
		// autofree_scope_vars(pos=143162 line_nr=4263 scope.pos=143144 scope.end_pos=143195)
		// var "node" var.pos=137681 var.line_nr=4072
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return _t2090;
	}
	else if (node._typ == 258 /* v.ast.InfixExpr */) {
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		 v__ast__Type _t2091 = v__checker__Checker_infix_expr(c, (voidptr)&/*qq*/(*node._v__ast__InfixExpr));
		// autofree_scope_vars(pos=143217 line_nr=4266 scope.pos=143199 scope.end_pos=143250)
		// var "node" var.pos=137681 var.line_nr=4072
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return _t2091;
	}
	else if (node._typ == 259 /* v.ast.IntegerLiteral */) {
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		// autofree_scope_vars(pos=143277 line_nr=4269 scope.pos=143254 scope.end_pos=143308)
		// var "node" var.pos=137681 var.line_nr=4072
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return _const_v__ast__int_literal_type;
	}
	else if (node._typ == 261 /* v.ast.LockExpr */) {
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		 v__ast__Type _t2092 = v__checker__Checker_lock_expr(c, (voidptr)&/*qq*/(*node._v__ast__LockExpr));
		// autofree_scope_vars(pos=143329 line_nr=4272 scope.pos=143312 scope.end_pos=143361)
		// var "node" var.pos=137681 var.line_nr=4072
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return _t2092;
	}
	else if (node._typ == 262 /* v.ast.MapInit */) {
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		 v__ast__Type _t2093 = v__checker__Checker_map_init(c, (voidptr)&/*qq*/(*node._v__ast__MapInit));
		// autofree_scope_vars(pos=143381 line_nr=4275 scope.pos=143365 scope.end_pos=143412)
		// var "node" var.pos=137681 var.line_nr=4072
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return _t2093;
	}
	else if (node._typ == 263 /* v.ast.MatchExpr */) {
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		 v__ast__Type _t2094 = v__checker__Checker_match_expr(c, (voidptr)&/*qq*/(*node._v__ast__MatchExpr));
		// autofree_scope_vars(pos=143434 line_nr=4278 scope.pos=143416 scope.end_pos=143467)
		// var "node" var.pos=137681 var.line_nr=4072
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return _t2094;
	}
	else if (node._typ == 269 /* v.ast.PostfixExpr */) {
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		 v__ast__Type _t2095 = v__checker__Checker_postfix_expr(c, (voidptr)&/*qq*/(*node._v__ast__PostfixExpr));
		// autofree_scope_vars(pos=143491 line_nr=4281 scope.pos=143471 scope.end_pos=143526)
		// var "node" var.pos=137681 var.line_nr=4072
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return _t2095;
	}
	else if (node._typ == 270 /* v.ast.PrefixExpr */) {
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		 v__ast__Type _t2096 = v__checker__Checker_prefix_expr(c, (voidptr)&/*qq*/(*node._v__ast__PrefixExpr));
		// autofree_scope_vars(pos=143549 line_nr=4284 scope.pos=143530 scope.end_pos=143583)
		// var "node" var.pos=137681 var.line_nr=4072
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return _t2096;
	}
	else if (node._typ == 265 /* v.ast.None */) {
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		// autofree_scope_vars(pos=143600 line_nr=4287 scope.pos=143587 scope.end_pos=143624)
		// var "node" var.pos=137681 var.line_nr=4072
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return _const_v__ast__none_type;
	}
	else if (node._typ == 267 /* v.ast.OrExpr */) {
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		// autofree_scope_vars(pos=143663 line_nr=4291 scope.pos=143628 scope.end_pos=143687)
		// var "node" var.pos=137681 var.line_nr=4072
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return _const_v__ast__void_type;
	}
	else if (node._typ == 268 /* v.ast.ParExpr */) {
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		 v__ast__Type _t2097 = v__checker__Checker_expr(c, (*node._v__ast__ParExpr).expr);
		// autofree_scope_vars(pos=143754 line_nr=4297 scope.pos=143738 scope.end_pos=143782)
		// var "node" var.pos=137681 var.line_nr=4072
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return _t2097;
	}
	else if (node._typ == 271 /* v.ast.RangeExpr */) {
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		// autofree_scope_vars(pos=143824 line_nr=4301 scope.pos=143786 scope.end_pos=143848)
		// var "node" var.pos=137681 var.line_nr=4072
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return _const_v__ast__void_type;
	}
	else if (node._typ == 272 /* v.ast.SelectExpr */) {
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		 v__ast__Type _t2098 = v__checker__Checker_select_expr(c, (voidptr)&/*qq*/(*node._v__ast__SelectExpr));
		// autofree_scope_vars(pos=143871 line_nr=4304 scope.pos=143852 scope.end_pos=143905)
		// var "node" var.pos=137681 var.line_nr=4072
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return _t2098;
	}
	else if (node._typ == 273 /* v.ast.SelectorExpr */) {
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		 v__ast__Type _t2099 = v__checker__Checker_selector_expr(c, (voidptr)&/*qq*/(*node._v__ast__SelectorExpr));
		// autofree_scope_vars(pos=143930 line_nr=4307 scope.pos=143909 scope.end_pos=143966)
		// var "node" var.pos=137681 var.line_nr=4072
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return _t2099;
	}
	else if (node._typ == 274 /* v.ast.SizeOf */) {
		if (!(*node._v__ast__SizeOf).is_type) {
			(*node._v__ast__SizeOf).typ = v__checker__Checker_expr(c, (*node._v__ast__SizeOf).expr);
		}
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		// autofree_scope_vars(pos=144045 line_nr=4313 scope.pos=143970 scope.end_pos=144068)
		// var "node" var.pos=137681 var.line_nr=4072
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return _const_v__ast__u32_type;
	}
	else if (node._typ == 266 /* v.ast.OffsetOf */) {
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		 v__ast__Type _t2100 = v__checker__Checker_offset_of(c, (*node._v__ast__OffsetOf));
		// autofree_scope_vars(pos=144089 line_nr=4316 scope.pos=144072 scope.end_pos=144117)
		// var "node" var.pos=137681 var.line_nr=4072
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return _t2100;
	}
	else if (node._typ == 275 /* v.ast.SqlExpr */) {
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		 v__ast__Type _t2101 = v__checker__Checker_sql_expr(c, (voidptr)&/*qq*/(*node._v__ast__SqlExpr));
		// autofree_scope_vars(pos=144137 line_nr=4319 scope.pos=144121 scope.end_pos=144168)
		// var "node" var.pos=137681 var.line_nr=4072
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return _t2101;
	}
	else if (node._typ == 277 /* v.ast.StringLiteral */) {
		if ((*node._v__ast__StringLiteral).language == v__ast__Language_c) {
			// Defer begin
			if (v__checker__Checker_expr_defer_0 == true) {
				c->expr_level--;
			}
			// Defer end
			 v__ast__Type _t2102 = v__ast__Type_set_nr_muls(_const_v__ast__byte_type, 1);
			// autofree_scope_vars(pos=144283 line_nr=4324 scope.pos=144218 scope.end_pos=144323)
			// af parent scope:
			// var "node" var.pos=137681 var.line_nr=4072
			// af parent scope:
			// var "c" var.pos=137456 var.line_nr=4063
			// var "node" var.pos=137472 var.line_nr=4063
			// af parent scope:
			// af parent scope:
			return _t2102;
		}
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		// autofree_scope_vars(pos=144327 line_nr=4326 scope.pos=144172 scope.end_pos=144353)
		// var "node" var.pos=137681 var.line_nr=4072
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return _const_v__ast__string_type;
	}
	else if (node._typ == 276 /* v.ast.StringInterLiteral */) {
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		 v__ast__Type _t2103 = v__checker__Checker_string_inter_lit(c, (voidptr)&/*qq*/(*node._v__ast__StringInterLiteral));
		// autofree_scope_vars(pos=144384 line_nr=4329 scope.pos=144357 scope.end_pos=144423)
		// var "node" var.pos=137681 var.line_nr=4072
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return _t2103;
	}
	else if (node._typ == 278 /* v.ast.StructInit */) {
		if ((*node._v__ast__StructInit).unresolved) {
			// Defer begin
			if (v__checker__Checker_expr_defer_0 == true) {
				c->expr_level--;
			}
			// Defer end
			 v__ast__Type _t2104 = v__checker__Checker_expr(c, v__ast__resolve_init((*node._v__ast__StructInit), v__checker__Checker_unwrap_generic(c, (*node._v__ast__StructInit).typ), c->table));
			// autofree_scope_vars(pos=144471 line_nr=4333 scope.pos=144466 scope.end_pos=144550)
			// af parent scope:
			// var "node" var.pos=137681 var.line_nr=4072
			// af parent scope:
			// var "c" var.pos=137456 var.line_nr=4063
			// var "node" var.pos=137472 var.line_nr=4063
			// af parent scope:
			// af parent scope:
			return _t2104;
		}
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		 v__ast__Type _t2105 = v__checker__Checker_struct_init(c, (voidptr)&/*qq*/(*node._v__ast__StructInit));
		// autofree_scope_vars(pos=144554 line_nr=4335 scope.pos=144427 scope.end_pos=144588)
		// var "node" var.pos=137681 var.line_nr=4072
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return _t2105;
	}
	else if (node._typ == 279 /* v.ast.TypeNode */) {
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		 v__ast__Type _t2106 = (*node._v__ast__TypeNode).typ;
		// autofree_scope_vars(pos=144609 line_nr=4338 scope.pos=144592 scope.end_pos=144628)
		// var "node" var.pos=137681 var.line_nr=4072
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return _t2106;
	}
	else if (node._typ == 280 /* v.ast.TypeOf */) {
		(*node._v__ast__TypeOf).expr_type = v__checker__Checker_expr(c, (*node._v__ast__TypeOf).expr);
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		// autofree_scope_vars(pos=144685 line_nr=4342 scope.pos=144632 scope.end_pos=144711)
		// var "node" var.pos=137681 var.line_nr=4072
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return _const_v__ast__string_type;
	}
	else if (node._typ == 281 /* v.ast.UnsafeExpr */) {
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		 v__ast__Type _t2107 = v__checker__Checker_unsafe_expr(c, (voidptr)&/*qq*/(*node._v__ast__UnsafeExpr));
		// autofree_scope_vars(pos=144734 line_nr=4345 scope.pos=144715 scope.end_pos=144768)
		// var "node" var.pos=137681 var.line_nr=4072
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return _t2107;
	}
	else if (node._typ == 260 /* v.ast.Likely */) {
		v__ast__Type ltype = v__checker__Checker_expr(c, (*node._v__ast__Likely).expr);
		if (!v__checker__Checker_check_types(c, ltype, _const_v__ast__bool_type)) {
			v__ast__TypeSymbol* ltype_sym = v__ast__Table_get_type_symbol(c->table, ltype);
			string lname = ((*node._v__ast__Likely).is_likely ? (_SLIT("_likely_")) : (_SLIT("_unlikely_")));
			v__checker__Checker_error(c, _STR("`%.*s\000()` expects a boolean expression, instead it got `%.*s\000`", 3, lname, ltype_sym->name), (*node._v__ast__Likely).pos);
		}
		// Defer begin
		if (v__checker__Checker_expr_defer_0 == true) {
			c->expr_level--;
		}
		// Defer end
		// autofree_scope_vars(pos=145089 line_nr=4355 scope.pos=144772 scope.end_pos=145113)
		// var "ltype" var.pos=144788 var.line_nr=4348
		// var "node" var.pos=137681 var.line_nr=4072
		// af parent scope:
		// var "c" var.pos=137456 var.line_nr=4063
		// var "node" var.pos=137472 var.line_nr=4063
		// af parent scope:
		// af parent scope:
		return _const_v__ast__bool_type;
	};
	// Defer begin
	if (v__checker__Checker_expr_defer_0 == true) {
		c->expr_level--;
	}
	// Defer end
	// autofree_scope_vars(pos=145118 line_nr=4358 scope.pos=137451 scope.end_pos=145140)
	// var "c" var.pos=137456 var.line_nr=4063
	// var "node" var.pos=137472 var.line_nr=4063
	// af parent scope:
	// af parent scope:
	return _const_v__ast__void_type;
}

v__ast__Type v__checker__Checker_cast_expr(v__checker__Checker* c, v__ast__CastExpr* node) {
	node->expr_type = v__checker__Checker_expr(c, node->expr);
	v__ast__TypeSymbol* from_type_sym = v__ast__Table_get_type_symbol(c->table, node->expr_type);
	v__ast__TypeSymbol* to_type_sym = v__ast__Table_get_type_symbol(c->table, node->typ);
	if (to_type_sym->language != v__ast__Language_c) {
		Option_void _t2108 = v__checker__Checker_ensure_type_exists(c, node->typ, node->pos);
		if (_t2108.state != 0 && _t2108.err._typ != _IError_None___index) {
			IError err = _t2108.err;
		};
	}
	bool expr_is_ptr = v__ast__Type_is_ptr(node->expr_type) || (Array_int_contains(_const_v__ast__pointer_type_idxs, v__ast__Type_idx(node->expr_type)));
	if (expr_is_ptr && to_type_sym->kind == v__ast__Kind_string && !node->in_prexpr) {
		if (node->has_arg) {
			v__checker__Checker_warn(c, _SLIT("to convert a C string buffer pointer to a V string, please use x.vstring_with_len(len) instead of string(x,len)"), node->pos);
		} else {
			v__checker__Checker_warn(c, _SLIT("to convert a C string buffer pointer to a V string, please use x.vstring() instead of string(x)"), node->pos);
		}
	}
	if (v__ast__Type_alias_eq(node->expr_type, _const_v__ast__byte_type) && to_type_sym->kind == v__ast__Kind_string) {
		v__checker__Checker_error(c, _STR("can not cast type `byte` to string, use `%.*s\000.str()` instead.", 2, v__ast__Expr_str(node->expr)), node->pos);
	}
	if (to_type_sym->kind == v__ast__Kind_sum_type) {
		if ((node->expr_type == _const_v__ast__int_literal_type || node->expr_type == _const_v__ast__float_literal_type)) {
			node->expr_type = v__checker__Checker_promote_num(c, node->expr_type, (v__ast__Type_alias_eq(node->expr_type, _const_v__ast__int_literal_type) ? (_const_v__ast__int_type) : (_const_v__ast__f64_type)));
		}
		if (!v__ast__Table_sumtype_has_variant(c->table, node->typ, node->expr_type) && !v__ast__Type_has_flag(node->typ, v__ast__TypeFlag_optional)) {
			v__checker__Checker_error(c, _STR("cannot cast `%.*s\000` to `%.*s\000`", 3, from_type_sym->name, to_type_sym->name), node->pos);
		}
	} else if ((to_type_sym->info)._typ == 413 /* v.ast.Alias */) {
		if (!v__checker__Checker_check_types(c, node->expr_type, (*to_type_sym->info._v__ast__Alias).parent_type)) {
			v__ast__TypeSymbol* parent_type_sym = v__ast__Table_get_type_symbol(c->table, (*to_type_sym->info._v__ast__Alias).parent_type);
			v__checker__Checker_error(c, _STR("cannot convert type `%.*s\000` to `%.*s\000` (alias to `%.*s\000`)", 4, from_type_sym->name, to_type_sym->name, parent_type_sym->name), node->pos);
		}
	} else if (v__ast__Type_alias_eq(node->typ, _const_v__ast__string_type) && ((from_type_sym->kind == v__ast__Kind_int_literal || from_type_sym->kind == v__ast__Kind_int || from_type_sym->kind == v__ast__Kind_byte || from_type_sym->kind == v__ast__Kind_byteptr || from_type_sym->kind == v__ast__Kind_bool) || (from_type_sym->kind == v__ast__Kind_array && string_eq(from_type_sym->name, _SLIT("array_byte"))))) {
		string type_name = v__ast__Table_type_to_str(c->table, node->expr_type);
		v__checker__Checker_error(c, _STR("cannot cast type `%.*s\000` to string, use `x.str()` instead", 2, type_name), node->pos);
	} else if (v__ast__Type_alias_eq(node->expr_type, _const_v__ast__string_type)) {
		if (to_type_sym->kind != v__ast__Kind_alias) {
			string error_msg = _SLIT("cannot cast a string");
			if ((node->expr)._typ == 277 /* v.ast.StringLiteral */) {
				if ((*node->expr._v__ast__StringLiteral).val.len == 1) {
					error_msg = /*f*/string_add(error_msg, _STR(", for denoting characters use `%.*s\000` instead of '%.*s\000'", 3, (*node->expr._v__ast__StringLiteral).val, (*node->expr._v__ast__StringLiteral).val));
				}
			}
			v__checker__Checker_error(c, error_msg, node->pos);
		}
	} else if (to_type_sym->kind == v__ast__Kind_byte && !v__ast__Type_alias_eq(node->expr_type, _const_v__ast__voidptr_type) && from_type_sym->kind != v__ast__Kind_enum_ && !v__ast__Type_is_int(node->expr_type) && !v__ast__Type_is_float(node->expr_type) && !v__ast__Type_alias_eq(node->expr_type, _const_v__ast__bool_type) && !v__ast__Type_is_ptr(node->expr_type)) {
		string type_name = v__ast__Table_type_to_str(c->table, node->expr_type);
		v__checker__Checker_error(c, _STR("cannot cast type `%.*s\000` to `byte`", 2, type_name), node->pos);
	} else if (to_type_sym->kind == v__ast__Kind_struct_ && !v__ast__Type_is_ptr(node->typ) && !(/* as */ *(v__ast__Struct*)__as_cast((to_type_sym->info)._v__ast__Struct,(to_type_sym->info)._typ, 409) /*expected idx: 409, name: v.ast.Struct */ ).is_typedef) {
		if (from_type_sym->kind == v__ast__Kind_struct_ && !v__ast__Type_is_ptr(node->expr_type)) {
			v__checker__Checker_warn(c, _SLIT("casting to struct is deprecated, use e.g. `Struct{...expr}` instead"), node->pos);
			v__ast__Struct from_type_info = /* as */ *(v__ast__Struct*)__as_cast((from_type_sym->info)._v__ast__Struct,(from_type_sym->info)._typ, 409) /*expected idx: 409, name: v.ast.Struct */ ;
			v__ast__Struct to_type_info = /* as */ *(v__ast__Struct*)__as_cast((to_type_sym->info)._v__ast__Struct,(to_type_sym->info)._typ, 409) /*expected idx: 409, name: v.ast.Struct */ ;
			if (!v__checker__Checker_check_struct_signature(c, from_type_info, to_type_info)) {
				v__checker__Checker_error(c, _STR("cannot convert struct `%.*s\000` to struct `%.*s\000`", 3, from_type_sym->name, to_type_sym->name), node->pos);
			}
		} else {
			string type_name = v__ast__Table_type_to_str(c->table, node->expr_type);
			v__checker__Checker_error(c, _STR("cannot cast `%.*s\000` to struct", 2, type_name), node->pos);
		}
	} else if (to_type_sym->kind == v__ast__Kind_interface_) {
		v__checker__Checker_type_implements(c, node->expr_type, node->typ, node->pos);
	} else if (v__ast__Type_alias_eq(node->typ, _const_v__ast__bool_type)) {
		v__checker__Checker_error(c, _SLIT("cannot cast to bool - use e.g. `some_int != 0` instead"), node->pos);
	} else if (v__ast__Type_alias_eq(node->expr_type, _const_v__ast__none_type) && !v__ast__Type_has_flag(node->typ, v__ast__TypeFlag_optional)) {
		string type_name = v__ast__Table_type_to_str(c->table, node->typ);
		v__checker__Checker_error(c, _STR("cannot cast `none` to `%.*s\000`", 2, type_name), node->pos);
	} else if (from_type_sym->kind == v__ast__Kind_struct_ && !v__ast__Type_is_ptr(node->expr_type)) {
		if ((v__ast__Type_is_ptr(node->typ) || !(to_type_sym->kind == v__ast__Kind_sum_type || to_type_sym->kind == v__ast__Kind_interface_)) && !c->is_builtin_mod) {
			string type_name = v__ast__Table_type_to_str(c->table, node->typ);
			v__checker__Checker_error(c, _STR("cannot cast struct to `%.*s\000`", 2, type_name), node->pos);
		}
	} else if (v__ast__Type_has_flag(node->expr_type, v__ast__TypeFlag_optional) || v__ast__Type_has_flag(node->expr_type, v__ast__TypeFlag_variadic)) {
		string msg = (v__ast__Type_has_flag(node->expr_type, v__ast__TypeFlag_optional) ? (_SLIT("an optional")) : (_SLIT("a variadic")));
		v__checker__Checker_error(c, _STR("cannot type cast %.*s", 1, msg), node->pos);
	} else if (!c->inside_unsafe && v__ast__Type_is_ptr(node->typ) && v__ast__Type_is_ptr(node->expr_type) && !v__ast__Type_alias_eq(v__ast__Type_deref(node->typ), _const_v__ast__char_type) && !v__ast__Type_alias_eq(v__ast__Type_deref(node->expr_type), _const_v__ast__char_type)) {
		string ft = v__ast__Table_type_to_str(c->table, node->expr_type);
		string tt = v__ast__Table_type_to_str(c->table, node->typ);
		v__checker__Checker_warn(c, _STR("casting `%.*s\000` to `%.*s\000` is only allowed in `unsafe` code", 3, ft, tt), node->pos);
	} else if (from_type_sym->kind == v__ast__Kind_array_fixed && !v__ast__Type_is_ptr(node->expr_type)) {
		v__checker__Checker_warn(c, _SLIT("cannot cast a fixed array (use e.g. `&arr[0]` instead)"), node->pos);
	}
	if (node->has_arg) {
		v__checker__Checker_expr(c, node->arg);
	}
	node->typname = v__ast__Table_get_type_symbol(c->table, node->typ)->name;
	 v__ast__Type _t2109 = node->typ;
	// autofree_scope_vars(pos=150663 line_nr=4480 scope.pos=145623 scope.end_pos=150680)
	// var "c" var.pos=145628 var.line_nr=4378
	// var "node" var.pos=145653 var.line_nr=4378
	// var "from_type_sym" var.pos=145741 var.line_nr=4380
	// var "to_type_sym" var.pos=145799 var.line_nr=4381
	// var "expr_is_ptr" var.pos=145961 var.line_nr=4385
	// af parent scope:
	// af parent scope:
	return _t2109;
}

VV_LOCAL_SYMBOL v__ast__Type v__checker__Checker_comptime_call(v__checker__Checker* c, v__ast__ComptimeCall* node) {
	node->sym = *v__ast__Table_get_type_symbol(c->table, v__checker__Checker_unwrap_generic(c, v__checker__Checker_expr(c, node->left)));
	if (node->is_env) {
		Option_string _t2110 = v__util__resolve_env_value(_STR("$env('%.*s\000')", 2, node->args_var), false);
		if (_t2110.state != 0) { /*or block*/ 
			IError err = _t2110.err;
			v__checker__Checker_error(c, (*(err.msg)), node->env_pos);
			// autofree_scope_vars(pos=150958 line_nr=4488 scope.pos=150920 scope.end_pos=150984)
			// var "err" var.pos=150920 var.line_nr=4486
			// af parent scope:
			// var "env_value" var.pos=150847 var.line_nr=4486
			// af parent scope:
			// var "c" var.pos=150691 var.line_nr=4483
			// var "node" var.pos=150720 var.line_nr=4483
			// var "v" var.pos=152336 var.line_nr=4543
			// var "method_name" var.pos=152774 var.line_nr=4554
			// var "f" var.pos=152924 var.line_nr=4560
			// af parent scope:
			// af parent scope:
			return _const_v__ast__string_type;
		}
 		string env_value =  *(string*)_t2110.data;
		node->env_value = env_value;
		// autofree_scope_vars(pos=151016 line_nr=4491 scope.pos=150843 scope.end_pos=151041)
		// var "env_value" var.pos=150847 var.line_nr=4486
		// af parent scope:
		// var "c" var.pos=150691 var.line_nr=4483
		// var "node" var.pos=150720 var.line_nr=4483
		// var "v" var.pos=152336 var.line_nr=4543
		// var "method_name" var.pos=152774 var.line_nr=4554
		// var "f" var.pos=152924 var.line_nr=4560
		// af parent scope:
		// af parent scope:
		return _const_v__ast__string_type;
	}
	if (node->is_embed) {
		array_push(&c->file->embedded_files, _MOV((v__ast__EmbeddedFile[]){ node->embed_file }));
		 v__ast__Type _t2112 = v__ast__Table_find_type_idx(c->table, _SLIT("v.embed_file.EmbedFileData"));
		// autofree_scope_vars(pos=151107 line_nr=4495 scope.pos=151061 scope.end_pos=151168)
		// af parent scope:
		// var "c" var.pos=150691 var.line_nr=4483
		// var "node" var.pos=150720 var.line_nr=4483
		// var "v" var.pos=152336 var.line_nr=4543
		// var "method_name" var.pos=152774 var.line_nr=4554
		// var "f" var.pos=152924 var.line_nr=4560
		// af parent scope:
		// af parent scope:
		return _t2112;
	}
	if (node->is_vweb) {
		v__pref__Preferences pref_ = *c->pref;
		v__pref__Preferences* pref2 = (v__pref__Preferences*)memdup(&(v__pref__Preferences){pref_.os,pref_.backend,pref_.build_mode,pref_.arch,pref_.output_mode,pref_.is_verbose,pref_.is_watch,pref_.is_test,pref_.is_script,pref_.is_vsh,pref_.is_livemain,pref_.is_liveshared,pref_.is_shared,pref_.is_prof,pref_.profile_file,pref_.profile_no_inline,pref_.translated,pref_.is_prod,pref_.obfuscate,pref_.is_repl,pref_.is_run,pref_.sanitize,pref_.is_debug,pref_.is_vlines,pref_.show_cc,pref_.show_c_output,pref_.dump_c_flags,pref_.use_cache,pref_.retry_compilation,pref_.is_stats,pref_.cflags,pref_.m64,pref_.ccompiler,pref_.ccompiler_type,pref_.third_party_option,pref_.building_v,pref_.autofree,pref_.compress,pref_.enable_globals,pref_.is_fmt,pref_.is_vet,pref_.is_bare,pref_.no_preludes,pref_.custom_prelude,pref_.lookup_path,pref_.bare_builtin_dir,pref_.output_cross_c,pref_.prealloc,pref_.vroot,pref_.out_name_c,pref_.out_name,pref_.path,pref_.compile_defines,pref_.compile_defines_all,pref_.run_args,pref_.printfn_list,pref_.print_v_files,pref_.skip_running,pref_.skip_warnings,pref_.warn_impure_v,pref_.warns_are_errors,pref_.fatal_errors,pref_.reuse_tmpc,pref_.use_color,pref_.is_parallel,pref_.error_limit,.is_vweb = true,pref_.only_check_syntax,pref_.experimental,pref_.skip_unused,pref_.show_timings,pref_.is_ios_simulator,pref_.is_apk,pref_.cleanup_files,pref_.build_options,pref_.cache_manager,pref_.is_help,pref_.gc_mode,pref_.checker_match_exhaustive_cutoff_limit,}, sizeof(v__pref__Preferences));
		v__checker__Checker c2 = v__checker__new_checker(c->table, pref2);
		v__checker__Checker_check(&c2, (voidptr)&/*qq*/node->vweb_tmpl);
		int i = 0;
		// FOR IN map
		Map_string_v__ast__ScopeObject _t2113 = (*(v__ast__Scope**)/*ee elem_typ */array_get(c2.file->scope->children, 0))->objects;
		int _t2115 = _t2113.key_values.len;
		for (int _t2114 = 0; _t2114 < _t2115; ++_t2114 ) {
			int _t2116 = _t2113.key_values.len - _t2115;
			_t2115 = _t2113.key_values.len;
			if (_t2116 < 0) {
				_t2114 = -1;
				continue;
			}
			if (!DenseArray_has_index(&_t2113.key_values, _t2114)) {continue;}
			string k = /*key*/ *(string*)DenseArray_key(&_t2113.key_values, _t2114);
			k = string_clone(k);
			if (i < 2) {
				i++;
				continue;
			}
			if (_IN_MAP(ADDR(string, k), ADDR(map, c->fn_scope->objects)) && ((*(v__ast__ScopeObject*)map_get(ADDR(map, c->fn_scope->objects), &(string[]){k}, &(v__ast__ScopeObject[]){ {0} })))._typ == 312 /* v.ast.Var */) {
				v__ast__Var vsc = /* as */ *(v__ast__Var*)__as_cast(((*(v__ast__ScopeObject*)map_get(ADDR(map, c->fn_scope->objects), &(string[]){k}, &(v__ast__ScopeObject[]){ {0} })))._v__ast__Var,((*(v__ast__ScopeObject*)map_get(ADDR(map, c->fn_scope->objects), &(string[]){k}, &(v__ast__ScopeObject[]){ {0} })))._typ, 312) /*expected idx: 312, name: v.ast.Var */ ;
				vsc.is_used = true;
				map_set(&c->fn_scope->objects, &(string[]){k}, &(v__ast__ScopeObject[]) { v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, (vsc))) });
			}
		}
		_PUSH_MANY(&c->warnings, (c2.warnings), _t2117, Array_v__errors__Warning);
		_PUSH_MANY(&c->errors, (c2.errors), _t2118, Array_v__errors__Error);
		_PUSH_MANY(&c->notices, (c2.notices), _t2119, Array_v__errors__Notice);
		c->nr_warnings += c2.nr_warnings;
		c->nr_errors += c2.nr_errors;
		c->nr_notices += c2.nr_notices;
	}
	if (string_eq(node->method_name, _SLIT("html"))) {
		int rtyp = v__ast__Table_find_type_idx(c->table, _SLIT("vweb.Result"));
		node->result_type = rtyp;
		// autofree_scope_vars(pos=152063 line_nr=4529 scope.pos=151987 scope.end_pos=152077)
		// var "rtyp" var.pos=151991 var.line_nr=4527
		// af parent scope:
		// var "c" var.pos=150691 var.line_nr=4483
		// var "node" var.pos=150720 var.line_nr=4483
		// var "v" var.pos=152336 var.line_nr=4543
		// var "method_name" var.pos=152774 var.line_nr=4554
		// var "f" var.pos=152924 var.line_nr=4560
		// af parent scope:
		// af parent scope:
		return rtyp;
	}
	if (string_eq(node->method_name, _SLIT("method"))) {
		// FOR IN array
		for (int i = 0; i < node->args.len; ++i) {
			v__ast__CallArg arg = ((v__ast__CallArg*)node->args.data)[i];
			(*(v__ast__CallArg*)/*ee elem_typ */array_get(node->args, i)).typ = v__checker__Checker_expr(c, arg.expr);
		}
		// autofree_scope_vars(pos=152245 line_nr=4537 scope.pos=152112 scope.end_pos=152270)
		// af parent scope:
		// var "c" var.pos=150691 var.line_nr=4483
		// var "node" var.pos=150720 var.line_nr=4483
		// var "v" var.pos=152336 var.line_nr=4543
		// var "method_name" var.pos=152774 var.line_nr=4554
		// var "f" var.pos=152924 var.line_nr=4560
		// af parent scope:
		// af parent scope:
		return _const_v__ast__string_type;
	}
	if (node->is_vweb) {
		// autofree_scope_vars(pos=152292 line_nr=4540 scope.pos=152289 scope.end_pos=152317)
		// af parent scope:
		// var "c" var.pos=150691 var.line_nr=4483
		// var "node" var.pos=150720 var.line_nr=4483
		// var "v" var.pos=152336 var.line_nr=4543
		// var "method_name" var.pos=152774 var.line_nr=4554
		// var "f" var.pos=152924 var.line_nr=4560
		// af parent scope:
		// af parent scope:
		return _const_v__ast__string_type;
	}
	Option_v__ast__Var_ptr _t2120 = v__ast__Scope_find_var(node->scope, node->method_name);
	if (_t2120.state != 0) { /*or block*/ 
		IError err = _t2120.err;
		v__checker__Checker_error(c, _STR("unknown identifier `%.*s\000`", 2, node->method_name), node->method_pos);
		// autofree_scope_vars(pos=152454 line_nr=4545 scope.pos=152382 scope.end_pos=152477)
		// var "err" var.pos=152382 var.line_nr=4543
		// af parent scope:
		// var "c" var.pos=150691 var.line_nr=4483
		// var "node" var.pos=150720 var.line_nr=4483
		// var "v" var.pos=152336 var.line_nr=4543
		// var "method_name" var.pos=152774 var.line_nr=4554
		// var "f" var.pos=152924 var.line_nr=4560
		// af parent scope:
		// af parent scope:
		return _const_v__ast__void_type;
	}
 	v__ast__Var* v =  *(v__ast__Var**)_t2120.data;
	if (!v__ast__Type_alias_eq(v->typ, _const_v__ast__string_type)) {
		string s = v__checker__Checker_expected_msg(c, v->typ, _const_v__ast__string_type);
		v__checker__Checker_error(c, _STR("invalid string method call: %.*s", 1, s), node->method_pos);
		// autofree_scope_vars(pos=152618 line_nr=4550 scope.pos=152508 scope.end_pos=152641)
		// var "s" var.pos=152512 var.line_nr=4548
		// af parent scope:
		// var "c" var.pos=150691 var.line_nr=4483
		// var "node" var.pos=150720 var.line_nr=4483
		// var "v" var.pos=152336 var.line_nr=4543
		// var "method_name" var.pos=152774 var.line_nr=4554
		// var "f" var.pos=152924 var.line_nr=4560
		// af parent scope:
		// af parent scope:
		return _const_v__ast__void_type;
	}
	string method_name = _SLIT("");
	if ((v->expr)._typ == 277 /* v.ast.StringLiteral */) {
		method_name = (*v->expr._v__ast__StringLiteral).val;
	} else {
		v__checker__Checker_error(c, _SLIT("todo: not a string literal"), node->method_pos);
	}
	Option_v__ast__Fn _t2121 = v__ast__TypeSymbol_find_method(&node->sym, method_name);
	if (_t2121.state != 0) { /*or block*/ 
		IError err = _t2121.err;
		v__checker__Checker_error(c, _STR("could not find method `%.*s\000`", 2, method_name), node->method_pos);
		// autofree_scope_vars(pos=153036 line_nr=4562 scope.pos=152966 scope.end_pos=153059)
		// var "err" var.pos=152966 var.line_nr=4560
		// af parent scope:
		// var "c" var.pos=150691 var.line_nr=4483
		// var "node" var.pos=150720 var.line_nr=4483
		// var "v" var.pos=152336 var.line_nr=4543
		// var "method_name" var.pos=152774 var.line_nr=4554
		// str literal
		// var "f" var.pos=152924 var.line_nr=4560
		// af parent scope:
		// af parent scope:
		return _const_v__ast__void_type;
	}
 	v__ast__Fn f =  *(v__ast__Fn*)_t2121.data;
	node->result_type = f.return_type;
	 v__ast__Type _t2122 = f.return_type;
	// autofree_scope_vars(pos=153158 line_nr=4566 scope.pos=150686 scope.end_pos=153180)
	// var "c" var.pos=150691 var.line_nr=4483
	// var "node" var.pos=150720 var.line_nr=4483
	// var "v" var.pos=152336 var.line_nr=4543
	// var "method_name" var.pos=152774 var.line_nr=4554
	// str literal
	// var "f" var.pos=152924 var.line_nr=4560
	// af parent scope:
	// af parent scope:
	return _t2122;
}

VV_LOCAL_SYMBOL v__ast__Type v__checker__Checker_at_expr(v__checker__Checker* c, v__ast__AtExpr* node) {

	if (node->kind == (v__token__AtKind_fn_name)) {
		node->val = string_all_after_last(c->cur_fn->name, _SLIT("."));
	}
	else if (node->kind == (v__token__AtKind_method_name)) {
		string fname = string_all_after_last(c->cur_fn->name, _SLIT("."));
		if (c->cur_fn->is_method) {
			node->val = string_add(string_add(string_all_after_last(v__ast__Table_type_to_str(c->table, c->cur_fn->receiver.typ), _SLIT(".")), _SLIT(".")), fname);
		} else {
			node->val = fname;
		}
	}
	else if (node->kind == (v__token__AtKind_mod_name)) {
		node->val = c->cur_fn->mod;
	}
	else if (node->kind == (v__token__AtKind_struct_name)) {
		if (c->cur_fn->is_method) {
			node->val = string_all_after_last(v__ast__Table_type_to_str(c->table, c->cur_fn->receiver.typ), _SLIT("."));
		} else {
			node->val = _SLIT("");
		}
	}
	else if (node->kind == (v__token__AtKind_vexe_path)) {
		node->val = v__pref__vexe_path();
	}
	else if (node->kind == (v__token__AtKind_file_path)) {
		node->val = os__real_path(c->file->path);
	}
	else if (node->kind == (v__token__AtKind_line_nr)) {
		node->val = int_str((node->pos.line_nr + 1));
	}
	else if (node->kind == (v__token__AtKind_column_nr)) {
		node->val = int_str((node->pos.col + 1));
	}
	else if (node->kind == (v__token__AtKind_vhash)) {
		node->val = v__util__vhash();
	}
	else if (node->kind == (v__token__AtKind_vmod_file)) {
		if (c->vmod_file_content.len == 0) {
			v__vmod__ModFileCacher* mcache = v__vmod__get_cache();
			v__vmod__ModFileAndFolder vmod_file_location = v__vmod__ModFileCacher_get_by_file(mcache, c->file->path);
			if (vmod_file_location.vmod_file.len == 0) {
				v__checker__Checker_error(c, _SLIT("@VMOD_FILE can be used only in projects, that have v.mod file"), node->pos);
			}
			Option_string _t2123 = os__read_file(vmod_file_location.vmod_file);
			if (_t2123.state != 0) { /*or block*/ 
				IError err = _t2123.err;
				*(string*) _t2123.data = _SLIT("");
			}
 			string vmod_content =  *(string*)_t2123.data;
			#if defined(_WIN32)
			{
				c->vmod_file_content = string_replace(vmod_content, _SLIT("\r\n"), _SLIT("\n"));
			}
			#else
			{
			}
			#endif
		}
		node->val = c->vmod_file_content;
	}
	else if (node->kind == (v__token__AtKind_unknown)) {
		v__checker__Checker_error(c, _STR("unknown @ identifier: %.*s\000. Available identifiers: %.*s", 2, node->name, Array_string_str(_const_v__token__valid_at_tokens)), node->pos);
	};
	// autofree_scope_vars(pos=154708 line_nr=4630 scope.pos=153186 scope.end_pos=154732)
	// var "c" var.pos=153191 var.line_nr=4569
	// var "node" var.pos=153214 var.line_nr=4569
	// af parent scope:
	// af parent scope:
	return _const_v__ast__string_type;
}

v__ast__Type v__checker__Checker_ident(v__checker__Checker* c, v__ast__Ident* ident) {
	if (c->const_deps.len > 0) {
		string name = ident->name;
		if (!string_contains(name, _SLIT(".")) && string_ne(ident->mod, _SLIT("builtin"))) {
			name = _STR("%.*s\000.%.*s", 2, ident->mod, ident->name);
		}
		if (string_eq(name, c->const_decl)) {
			v__checker__Checker_error(c, _STR("cycle in constant `%.*s\000`", 2, c->const_decl), ident->pos);
			// autofree_scope_vars(pos=155051 line_nr=4642 scope.pos=154988 scope.end_pos=155075)
			// af parent scope:
			// var "name" var.pos=154849 var.line_nr=4636
			// af parent scope:
			// var "c" var.pos=154747 var.line_nr=4633
			// var "ident" var.pos=154768 var.line_nr=4633
			// af parent scope:
			// af parent scope:
			return _const_v__ast__void_type;
		}
		array_push(&c->const_deps, _MOV((string[]){ string_clone(name) }));
	}
	if (ident->kind == v__ast__IdentKind_blank_ident) {
		if (!(ident->tok_kind == v__token__Kind_assign || ident->tok_kind == v__token__Kind_decl_assign)) {
			v__checker__Checker_error(c, _SLIT("undefined ident: `_` (may only be used in assignments)"), ident->pos);
		}
		// autofree_scope_vars(pos=155271 line_nr=4650 scope.pos=155134 scope.end_pos=155294)
		// af parent scope:
		// var "c" var.pos=154747 var.line_nr=4633
		// var "ident" var.pos=154768 var.line_nr=4633
		// af parent scope:
		// af parent scope:
		return _const_v__ast__void_type;
	}
	if ((ident->kind == v__ast__IdentKind_constant || ident->kind == v__ast__IdentKind_global || ident->kind == v__ast__IdentKind_variable)) {
		v__ast__IdentVar info = /* as */ *(v__ast__IdentVar*)__as_cast((ident->info)._v__ast__IdentVar,(ident->info)._typ, 363) /*expected idx: 363, name: v.ast.IdentVar */ ;
		 v__ast__Type _t2125 = info.typ;
		// autofree_scope_vars(pos=155457 line_nr=4656 scope.pos=155361 scope.end_pos=155475)
		// var "info" var.pos=155365 var.line_nr=4654
		// af parent scope:
		// var "c" var.pos=154747 var.line_nr=4633
		// var "ident" var.pos=154768 var.line_nr=4633
		// af parent scope:
		// af parent scope:
		return _t2125;
	} else if (ident->kind == v__ast__IdentKind_function) {
		v__ast__IdentFn info = /* as */ *(v__ast__IdentFn*)__as_cast((ident->info)._v__ast__IdentFn,(ident->info)._typ, 362) /*expected idx: 362, name: v.ast.IdentFn */ ;
		 v__ast__Type _t2126 = info.typ;
		// autofree_scope_vars(pos=155548 line_nr=4659 scope.pos=155509 scope.end_pos=155566)
		// var "info" var.pos=155513 var.line_nr=4658
		// af parent scope:
		// var "c" var.pos=154747 var.line_nr=4633
		// var "ident" var.pos=154768 var.line_nr=4633
		// af parent scope:
		// af parent scope:
		return _t2126;
	} else if (ident->kind == v__ast__IdentKind_unresolved) {
		if (ident->tok_kind == v__token__Kind_assign && ident->is_mut) {
			v__checker__Checker_error(c, _SLIT("`mut` not allowed with `=` (use `:=` to declare a variable)"), ident->pos);
		}
		Option_v__ast__ScopeObject _t2127;
		if (_t2127 = v__ast__Scope_find(ident->scope, ident->name), _t2127.state == 0) {
			v__ast__ScopeObject obj = *(v__ast__ScopeObject*)_t2127.data;
			if (obj._typ == 311 /* v.ast.GlobalField */) {
				ident->kind = v__ast__IdentKind_global;
				ident->info = v__ast__IdentVar_to_sumtype_v__ast__IdentInfo(ADDR(v__ast__IdentVar, ((v__ast__IdentVar){.typ = (*obj._v__ast__GlobalField).typ,.is_mut = 0,.is_static = 0,.is_optional = 0,.share = 0,})));
				ident->obj = obj;
				 v__ast__Type _t2128 = (*obj._v__ast__GlobalField).typ;
				// autofree_scope_vars(pos=155950 line_nr=4673 scope.pos=155823 scope.end_pos=155970)
				// var "obj" var.pos=155813 var.line_nr=4666
				// af parent scope:
				// af parent scope:
				// var "obj" var.pos=155762 var.line_nr=4665
				// af parent scope:
				// var "name" var.pos=158128 var.line_nr=4736
				// af parent scope:
				// var "c" var.pos=154747 var.line_nr=4633
				// var "ident" var.pos=154768 var.line_nr=4633
				// af parent scope:
				// af parent scope:
				return _t2128;
			}
			else if (obj._typ == 312 /* v.ast.Var */) {
				(*obj._v__ast__Var).is_used = true;
				if (ident->pos.pos < (*obj._v__ast__Var).pos.pos) {
					v__checker__Checker_error(c, _STR("undefined variable `%.*s\000` (used before declaration)", 2, ident->name), ident->pos);
				}
				bool is_sum_type_cast = (*obj._v__ast__Var).smartcasts.len != 0 && !c->prevent_sum_type_unwrapping_once;
				c->prevent_sum_type_unwrapping_once = false;
				v__ast__Type _t2129; /* if prepend */
				if (is_sum_type_cast) {
					_t2129 = (*(v__ast__Type*)array_last((*obj._v__ast__Var).smartcasts));
				} else {
					_t2129 = (*obj._v__ast__Var).typ;
				}
				v__ast__Type typ =  _t2129;
				if (typ == 0) {
					if (((*obj._v__ast__Var).expr)._typ == 254 /* v.ast.Ident */) {
						if ((*(*obj._v__ast__Var).expr._v__ast__Ident).kind == v__ast__IdentKind_unresolved) {
							v__checker__Checker_error(c, _STR("unresolved variable: `%.*s\000`", 2, ident->name), ident->pos);
							// autofree_scope_vars(pos=156597 line_nr=4690 scope.pos=156523 scope.end_pos=156626)
							// af parent scope:
							// af parent scope:
							// af parent scope:
							// var "is_sum_type_cast" var.pos=156212 var.line_nr=4682
							// var "typ" var.pos=156358 var.line_nr=4685
							// var "is_optional" var.pos=156994 var.line_nr=4702
							// var "obj" var.pos=155813 var.line_nr=4666
							// af parent scope:
							// af parent scope:
							// var "obj" var.pos=155762 var.line_nr=4665
							// af parent scope:
							// var "name" var.pos=158128 var.line_nr=4736
							// af parent scope:
							// var "c" var.pos=154747 var.line_nr=4633
							// var "ident" var.pos=154768 var.line_nr=4633
							// af parent scope:
							// af parent scope:
							return _const_v__ast__void_type;
						}
					}
					if (((*obj._v__ast__Var).expr)._typ == 256 /* v.ast.IfGuardExpr */) {
						v__ast__Type if_guard_var_type = v__checker__Checker_expr(c, (*(*obj._v__ast__Var).expr._v__ast__IfGuardExpr).expr);
						typ = v__ast__Type_clear_flag(if_guard_var_type, v__ast__TypeFlag_optional);
					} else {
						typ = v__checker__Checker_expr(c, (*obj._v__ast__Var).expr);
					}
				}
				bool is_optional = v__ast__Type_has_flag(typ, v__ast__TypeFlag_optional);
				ident->kind = v__ast__IdentKind_variable;
				ident->info = v__ast__IdentVar_to_sumtype_v__ast__IdentInfo(ADDR(v__ast__IdentVar, ((v__ast__IdentVar){.typ = typ,.is_mut = 0,.is_static = 0,.is_optional = is_optional,.share = 0,})));
				if (v__ast__Type_alias_eq(typ, _const_v__ast__error_type) && v__ast__Type_alias_eq(c->expected_type, _const_v__ast__string_type) && !c->using_new_err_struct && !c->inside_selector_expr && !c->inside_println_arg && !string_contains(c->file->mod.name, _SLIT("v.")) && !c->is_builtin_mod) {
					v__checker__Checker_warn(c, _SLIT("string errors are deprecated; use `err.msg` instead"), ident->pos);
				}
				if (!is_sum_type_cast) {
					(*obj._v__ast__Var).typ = typ;
				}
				ident->obj = obj;
				if (is_optional) {
					 v__ast__Type _t2130 = v__ast__Type_clear_flag(typ, v__ast__TypeFlag_optional);
					// autofree_scope_vars(pos=158038 line_nr=4729 scope.pos=158031 scope.end_pos=158077)
					// af parent scope:
					// var "is_sum_type_cast" var.pos=156212 var.line_nr=4682
					// var "typ" var.pos=156358 var.line_nr=4685
					// var "is_optional" var.pos=156994 var.line_nr=4702
					// var "obj" var.pos=155813 var.line_nr=4666
					// af parent scope:
					// af parent scope:
					// var "obj" var.pos=155762 var.line_nr=4665
					// af parent scope:
					// var "name" var.pos=158128 var.line_nr=4736
					// af parent scope:
					// var "c" var.pos=154747 var.line_nr=4633
					// var "ident" var.pos=154768 var.line_nr=4633
					// af parent scope:
					// af parent scope:
					return _t2130;
				}
				// autofree_scope_vars(pos=158083 line_nr=4731 scope.pos=155976 scope.end_pos=158099)
				// var "is_sum_type_cast" var.pos=156212 var.line_nr=4682
				// var "typ" var.pos=156358 var.line_nr=4685
				// var "is_optional" var.pos=156994 var.line_nr=4702
				// var "obj" var.pos=155813 var.line_nr=4666
				// af parent scope:
				// af parent scope:
				// var "obj" var.pos=155762 var.line_nr=4665
				// af parent scope:
				// var "name" var.pos=158128 var.line_nr=4736
				// af parent scope:
				// var "c" var.pos=154747 var.line_nr=4633
				// var "ident" var.pos=154768 var.line_nr=4633
				// af parent scope:
				// af parent scope:
				return typ;
			}
			else {
			};
		}
		string name = ident->name;
		if (_IN_MAP(ADDR(string, name), ADDR(map, c->file->imported_symbols))) {
			name = (*(string*)map_get(ADDR(map, c->file->imported_symbols), &(string[]){name}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} }));
		} else if (!string_contains(name, _SLIT(".")) && string_ne(ident->mod, _SLIT("builtin"))) {
			name = _STR("%.*s\000.%.*s", 2, ident->mod, ident->name);
		}
		Option_v__ast__ScopeObject _t2131;
		if (_t2131 = v__ast__Scope_find(c->file->global_scope, name), _t2131.state == 0) {
			v__ast__ScopeObject obj = *(v__ast__ScopeObject*)_t2131.data;
			if (obj._typ == 310 /* v.ast.ConstField */) {
				if (!((*obj._v__ast__ConstField).is_pub || string_eq((*obj._v__ast__ConstField).mod, c->mod) || c->pref->is_test)) {
					v__checker__Checker_error(c, _STR("constant `%.*s\000` is private", 2, (*obj._v__ast__ConstField).name), ident->pos);
				}
				v__ast__Type typ = (*obj._v__ast__ConstField).typ;
				if (typ == 0) {
					c->inside_const = true;
					typ = v__checker__Checker_expr(c, (*obj._v__ast__ConstField).expr);
					c->inside_const = false;
					if (((*obj._v__ast__ConstField).expr)._typ == 241 /* v.ast.CallExpr */) {
						if ((*(*obj._v__ast__ConstField).expr._v__ast__CallExpr).or_block.kind != v__ast__OrKind_absent) {
							typ = v__ast__Type_clear_flag(typ, v__ast__TypeFlag_optional);
						}
					}
				}
				ident->name = name;
				ident->kind = v__ast__IdentKind_constant;
				ident->info = v__ast__IdentVar_to_sumtype_v__ast__IdentInfo(ADDR(v__ast__IdentVar, ((v__ast__IdentVar){.typ = typ,.is_mut = 0,.is_static = 0,.is_optional = 0,.share = 0,})));
				(*obj._v__ast__ConstField).typ = typ;
				ident->obj = obj;
				// autofree_scope_vars(pos=159044 line_nr=4769 scope.pos=158474 scope.end_pos=159060)
				// var "typ" var.pos=158629 var.line_nr=4751
				// var "obj" var.pos=158464 var.line_nr=4746
				// af parent scope:
				// af parent scope:
				// var "obj" var.pos=158411 var.line_nr=4745
				// af parent scope:
				// var "name" var.pos=158128 var.line_nr=4736
				// af parent scope:
				// var "c" var.pos=154747 var.line_nr=4633
				// var "ident" var.pos=154768 var.line_nr=4633
				// af parent scope:
				// af parent scope:
				return typ;
			}
			else {
			};
		}
		Option_v__ast__Fn _t2132;
		if (_t2132 = v__ast__Table_find_fn(c->table, name), _t2132.state == 0) {
			v__ast__Fn func = *(v__ast__Fn*)_t2132.data;
			v__ast__Type fn_type = v__ast__new_type(v__ast__Table_find_or_register_fn_type(c->table, ident->mod, func, false, true));
			ident->name = name;
			ident->kind = v__ast__IdentKind_function;
			ident->info = v__ast__IdentFn_to_sumtype_v__ast__IdentInfo(ADDR(v__ast__IdentFn, ((v__ast__IdentFn){.typ = fn_type,})));
			// autofree_scope_vars(pos=159384 line_nr=4783 scope.pos=159187 scope.end_pos=159402)
			// var "fn_type" var.pos=159192 var.line_nr=4776
			// af parent scope:
			// var "func" var.pos=159157 var.line_nr=4775
			// af parent scope:
			// var "name" var.pos=158128 var.line_nr=4736
			// af parent scope:
			// var "c" var.pos=154747 var.line_nr=4633
			// var "ident" var.pos=154768 var.line_nr=4633
			// af parent scope:
			// af parent scope:
			return fn_type;
		}
	}
	if (ident->language == v__ast__Language_c) {
		if (string_eq(ident->name, _SLIT("C.NULL"))) {
			// autofree_scope_vars(pos=159466 line_nr=4788 scope.pos=159462 scope.end_pos=159493)
			// af parent scope:
			// af parent scope:
			// var "c" var.pos=154747 var.line_nr=4633
			// var "ident" var.pos=154768 var.line_nr=4633
			// af parent scope:
			// af parent scope:
			return _const_v__ast__voidptr_type;
		}
		// autofree_scope_vars(pos=159496 line_nr=4790 scope.pos=159432 scope.end_pos=159518)
		// af parent scope:
		// var "c" var.pos=154747 var.line_nr=4633
		// var "ident" var.pos=154768 var.line_nr=4633
		// af parent scope:
		// af parent scope:
		return _const_v__ast__int_type;
	}
	if (c->inside_sql) {
		Option_v__ast__StructField _t2133;
		if (_t2133 = v__ast__Table_find_field(c->table, (voidptr)&/*qq*/c->cur_orm_ts, ident->name), _t2133.state == 0) {
			v__ast__StructField field = *(v__ast__StructField*)_t2133.data;
			 v__ast__Type _t2134 = field.typ;
			// autofree_scope_vars(pos=159602 line_nr=4794 scope.pos=159598 scope.end_pos=159622)
			// af parent scope:
			// var "field" var.pos=159544 var.line_nr=4793
			// af parent scope:
			// af parent scope:
			// var "c" var.pos=154747 var.line_nr=4633
			// var "ident" var.pos=154768 var.line_nr=4633
			// af parent scope:
			// af parent scope:
			return _t2134;
		}
	}
	if (ident->kind == v__ast__IdentKind_unresolved && string_ne(ident->mod, _SLIT("builtin"))) {
		string saved_mod = ident->mod;
		ident->mod = _SLIT("builtin");
		v__ast__Type builtin_type = v__checker__Checker_ident(c, ident);
		if (!v__ast__Type_alias_eq(builtin_type, _const_v__ast__void_type)) {
			// autofree_scope_vars(pos=159917 line_nr=4804 scope.pos=159913 scope.end_pos=159940)
			// af parent scope:
			// var "saved_mod" var.pos=159794 var.line_nr=4800
			// var "builtin_type" var.pos=159843 var.line_nr=4802
			// af parent scope:
			// var "c" var.pos=154747 var.line_nr=4633
			// var "ident" var.pos=154768 var.line_nr=4633
			// af parent scope:
			// af parent scope:
			return builtin_type;
		}
		ident->mod = saved_mod;
	}
	if (ident->tok_kind == v__token__Kind_assign) {
		v__checker__Checker_error(c, _STR("undefined ident: `%.*s\000` (use `:=` to declare a variable)", 2, ident->name), ident->pos);
	} else if (string_eq(ident->name, _SLIT("errcode"))) {
		v__checker__Checker_error(c, _SLIT("undefined ident: `errcode`; did you mean `err.code`?"), ident->pos);
	} else {
		v__checker__Checker_error(c, _STR("undefined ident: `%.*s\000`", 2, ident->name), ident->pos);
	}
	if (v__ast__Table_known_type(c->table, ident->name)) {
		// autofree_scope_vars(pos=160357 line_nr=4817 scope.pos=160306 scope.end_pos=160380)
		// af parent scope:
		// var "c" var.pos=154747 var.line_nr=4633
		// var "ident" var.pos=154768 var.line_nr=4633
		// af parent scope:
		// af parent scope:
		return _const_v__ast__void_type;
	}
	// autofree_scope_vars(pos=160382 line_nr=4819 scope.pos=154742 scope.end_pos=160404)
	// var "c" var.pos=154747 var.line_nr=4633
	// var "ident" var.pos=154768 var.line_nr=4633
	// af parent scope:
	// af parent scope:
	return _const_v__ast__void_type;
}

v__ast__Type v__checker__Checker_concat_expr(v__checker__Checker* c, v__ast__ConcatExpr* concat_expr) {
	Array_v__ast__Type mr_types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
	// FOR IN array
	for (int _t2135 = 0; _t2135 < concat_expr->vals.len; ++_t2135) {
		v__ast__Expr expr = ((v__ast__Expr*)concat_expr->vals.data)[_t2135];
		array_push(&mr_types, _MOV((v__ast__Type[]){ v__checker__Checker_expr(c, expr) }));
	}
	if (concat_expr->vals.len == 1) {
		v__ast__Type typ = (*(v__ast__Type*)/*ee elem_typ */array_get(mr_types, 0));
		concat_expr->return_type = typ;
		// autofree_scope_vars(pos=160663 line_nr=4830 scope.pos=160607 scope.end_pos=160676)
		// var "typ" var.pos=160611 var.line_nr=4828
		// af parent scope:
		// var "c" var.pos=160419 var.line_nr=4822
		// var "concat_expr" var.pos=160446 var.line_nr=4822
		// var "mr_types" var.pos=160490 var.line_nr=4823
		// af parent scope:
		// af parent scope:
		return typ;
	} else {
		int typ = v__ast__Table_find_or_register_multi_return(c->table, mr_types);
		v__ast__new_type(typ);
		concat_expr->return_type = typ;
		// autofree_scope_vars(pos=160795 line_nr=4835 scope.pos=160683 scope.end_pos=160808)
		// var "typ" var.pos=160687 var.line_nr=4832
		// af parent scope:
		// var "c" var.pos=160419 var.line_nr=4822
		// var "concat_expr" var.pos=160446 var.line_nr=4822
		// var "mr_types" var.pos=160490 var.line_nr=4823
		// af parent scope:
		// af parent scope:
		return typ;
	}
	return 0;
}

v__ast__Type v__checker__Checker_match_expr(v__checker__Checker* c, v__ast__MatchExpr* node) {
	node->is_expr = !v__ast__Type_alias_eq(c->expected_type, _const_v__ast__void_type);
	node->expected_type = c->expected_type;
	v__ast__Type cond_type = v__checker__Checker_expr(c, node->cond);
	node->cond_type = v__ast__Table_mktyp(c->table, cond_type);
	Option_void _t2137 = v__checker__Checker_ensure_type_exists(c, node->cond_type, node->pos);
	if (_t2137.state != 0 && _t2137.err._typ != _IError_None___index) {
		IError err = _t2137.err;
		// autofree_scope_vars(pos=161222 line_nr=4846 scope.pos=161221 scope.end_pos=161244)
		// var "err" var.pos=161221 var.line_nr=4846
		// af parent scope:
		// var "c" var.pos=160825 var.line_nr=4839
		// var "node" var.pos=160851 var.line_nr=4839
		// var "cond_type" var.pos=160970 var.line_nr=4842
		// var "cond_type_sym" var.pos=161247 var.line_nr=4847
		// var "ret_type" var.pos=161457 var.line_nr=4853
		// var "nbranches_with_return" var.pos=161488 var.line_nr=4854
		// var "nbranches_without_return" var.pos=161520 var.line_nr=4855
		// af parent scope:
		// af parent scope:
		return _const_v__ast__void_type;
	};
	v__ast__TypeSymbol* cond_type_sym = v__ast__Table_get_type_symbol(c->table, cond_type);
	if (!(cond_type_sym->kind == v__ast__Kind_interface_ || cond_type_sym->kind == v__ast__Kind_sum_type)) {
		node->is_sum_type = false;
	}
	v__checker__Checker_match_exprs(c, node, *cond_type_sym);
	c->expected_type = cond_type;
	v__ast__Type ret_type = _const_v__ast__void_type;
	int nbranches_with_return = 0;
	int nbranches_without_return = 0;
	// FOR IN array
	for (int _t2138 = 0; _t2138 < node->branches.len; ++_t2138) {
		v__ast__MatchBranch branch = ((v__ast__MatchBranch*)node->branches.data)[_t2138];
		v__checker__Checker_stmts(c, branch.stmts);
		if (node->is_expr && branch.stmts.len > 0) {
			// FOR IN array
			Array_v__ast__Stmt _t2139 = array_slice(branch.stmts, 0, branch.stmts.len - 1);
			for (int _t2140 = 0; _t2140 < _t2139.len; ++_t2140) {
				v__ast__Stmt st = ((v__ast__Stmt*)_t2139.data)[_t2140];
				Option_void _t2141 = v__ast__Stmt_check_c_expr(st);
				if (_t2141.state != 0 && _t2141.err._typ != _IError_None___index) {
					IError err = _t2141.err;
					v__checker__Checker_error(c, _STR("`match` expression branch has %.*s", 1, (*(err.msg))), (*(st.pos)));
				};
			}
		}
		if (branch.stmts.len > 0) {
			v__ast__Stmt stmt = (*(v__ast__Stmt*)/*ee elem_typ */array_get(branch.stmts, branch.stmts.len - 1));
			if (stmt._typ == 293 /* v.ast.ExprStmt */) {
				v__ast__Type expr_type = v__checker__Checker_expr(c, (*stmt._v__ast__ExprStmt).expr);
				if (v__ast__Type_alias_eq(ret_type, _const_v__ast__void_type)) {
					ret_type = expr_type;
					(*stmt._v__ast__ExprStmt).typ = ret_type;
				} else if (node->is_expr && !v__ast__Type_alias_eq(ret_type, expr_type)) {
					if (!v__checker__Checker_check_types(c, ret_type, expr_type)) {
						v__ast__TypeSymbol* ret_sym = v__ast__Table_get_type_symbol(c->table, ret_type);
						v__checker__Checker_error(c, _STR("return type mismatch, it should be `%.*s\000`", 2, ret_sym->name), v__ast__Expr_position((*stmt._v__ast__ExprStmt).expr));
					}
				}
			}
			else {
			};
		}
		Option_bool _t2142;
		if (_t2142 = v__checker__Checker_has_return(c, branch.stmts), _t2142.state == 0) {
			bool has_return = *(bool*)_t2142.data;
			if (has_return) {
				nbranches_with_return++;
			} else {
				nbranches_without_return++;
			}
		}
	}
	if (nbranches_with_return > 0) {
		if (nbranches_with_return == node->branches.len) {
			c->returns = true;
		}
		if (nbranches_without_return > 0) {
			c->returns = false;
		}
	}
	node->return_type = ret_type;
	// autofree_scope_vars(pos=163470 line_nr=4918 scope.pos=160820 scope.end_pos=163487)
	// var "c" var.pos=160825 var.line_nr=4839
	// var "node" var.pos=160851 var.line_nr=4839
	// var "cond_type" var.pos=160970 var.line_nr=4842
	// var "cond_type_sym" var.pos=161247 var.line_nr=4847
	// var "ret_type" var.pos=161457 var.line_nr=4853
	// var "nbranches_with_return" var.pos=161488 var.line_nr=4854
	// var "nbranches_without_return" var.pos=161520 var.line_nr=4855
	// af parent scope:
	// af parent scope:
	return ret_type;
}

VV_LOCAL_SYMBOL void v__checker__Checker_match_exprs(v__checker__Checker* c, v__ast__MatchExpr* node, v__ast__TypeSymbol cond_type_sym) {
	Map_string_int branch_exprs = new_map(sizeof(string), sizeof(int), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
	// FOR IN array
	for (int branch_i = 0; branch_i < node->branches.len; ++branch_i) {
		v__ast__MatchBranch branch = (*(v__ast__MatchBranch*)/*ee elem_typ */array_get(node->branches, branch_i));
		Array_v__ast__TypeNode expr_types = __new_array_with_default(0, 0, sizeof(v__ast__TypeNode), 0);
		// FOR IN array
		for (int _t2143 = 0; _t2143 < branch.exprs.len; ++_t2143) {
			v__ast__Expr expr = ((v__ast__Expr*)branch.exprs.data)[_t2143];
			string key = _SLIT("");
			if ((expr)._typ == 271 /* v.ast.RangeExpr */) {
				i64 low = ((i64)(0));
				i64 high = ((i64)(0));
				c->expected_type = node->expected_type;
				v__ast__Expr low_expr = (*expr._v__ast__RangeExpr).low;
				v__ast__Expr high_expr = (*expr._v__ast__RangeExpr).high;
				if ((low_expr)._typ == 259 /* v.ast.IntegerLiteral */) {
					if ((high_expr)._typ == 259 /* v.ast.IntegerLiteral */) {
						low = string_i64((*low_expr._v__ast__IntegerLiteral).val);
						high = string_i64((*high_expr._v__ast__IntegerLiteral).val);
					} else {
						v__checker__Checker_error(c, _SLIT("mismatched range types"), (*low_expr._v__ast__IntegerLiteral).pos);
					}
				} else if ((low_expr)._typ == 244 /* v.ast.CharLiteral */) {
					if ((high_expr)._typ == 244 /* v.ast.CharLiteral */) {
						low = string_at((*low_expr._v__ast__CharLiteral).val, 0);
						high = string_at((*high_expr._v__ast__CharLiteral).val, 0);
					} else {
						v__checker__Checker_error(c, _SLIT("mismatched range types"), (*low_expr._v__ast__CharLiteral).pos);
					}
				} else {
					string typ = v__ast__Table_type_to_str(c->table, v__checker__Checker_expr(c, (*expr._v__ast__RangeExpr).low));
					v__checker__Checker_error(c, _STR("cannot use type `%.*s\000` in match range", 2, typ), branch.pos);
				}
				int high_low_cutoff = 1000;
				if (high - low > high_low_cutoff) {
					v__checker__Checker_warn(c, _STR("more than %"PRId32"\000 possibilities (%"PRId64"\000 ... %"PRId64"\000) in match range", 4, high_low_cutoff, low, high), branch.pos);
				}
				for (int i = low; i < high + 1; ++i) {
					key = int_str(i);
					int val = (_IN_MAP(ADDR(string, key), ADDR(map, branch_exprs)) ? ((*(int*)map_get(ADDR(map, branch_exprs), &(string[]){key}, &(int[]){ 0 }))) : (0));
					if (val == 1) {
						v__checker__Checker_error(c, _STR("match case `%.*s\000` is handled more than once", 2, key), branch.pos);
					}
					map_set(&branch_exprs, &(string[]){key}, &(int[]) { val + 1 });
				}
				continue;
			}
			if (expr._typ == 279 /* v.ast.TypeNode */) {
				key = v__ast__Table_type_to_str(c->table, (*expr._v__ast__TypeNode).typ);
				array_push(&expr_types, _MOV((v__ast__TypeNode[]){ (*expr._v__ast__TypeNode) }));
			}
			else if (expr._typ == 251 /* v.ast.EnumVal */) {
				key = (*expr._v__ast__EnumVal).val;
			}
			else {
				key = v__ast__Expr_str(expr);
			};
			int val = (_IN_MAP(ADDR(string, key), ADDR(map, branch_exprs)) ? ((*(int*)map_get(ADDR(map, branch_exprs), &(string[]){key}, &(int[]){ 0 }))) : (0));
			if (val == 1) {
				v__checker__Checker_error(c, _STR("match case `%.*s\000` is handled more than once", 2, key), branch.pos);
			}
			c->expected_type = node->cond_type;
			v__ast__Type expr_type = v__checker__Checker_expr(c, expr);
			if (v__ast__Type_idx(expr_type) == 0) {
				return;
			}
			if (cond_type_sym.kind == v__ast__Kind_interface_) {
				v__token__Position expr_pos = v__ast__Expr_position(expr);
				v__checker__Checker_type_implements(c, expr_type, c->expected_type, expr_pos);
			} else if ((cond_type_sym.info)._typ == 411 /* v.ast.SumType */) {
				if (!(Array_v__ast__Type_contains((*cond_type_sym.info._v__ast__SumType).variants, expr_type))) {
					string expr_str = v__ast__Table_type_to_str(c->table, expr_type);
					string expect_str = v__ast__Table_type_to_str(c->table, node->cond_type);
					v__checker__Checker_error(c, _STR("`%.*s\000` has no variant `%.*s\000`", 3, expect_str, expr_str), v__ast__Expr_position(expr));
				}
			} else if (!v__checker__Checker_check_types(c, expr_type, node->cond_type)) {
				string expr_str = v__ast__Table_type_to_str(c->table, expr_type);
				string expect_str = v__ast__Table_type_to_str(c->table, node->cond_type);
				v__checker__Checker_error(c, _STR("cannot match `%.*s\000` with `%.*s\000` condition", 3, expr_str, expect_str), v__ast__Expr_position(expr));
			}
			map_set(&branch_exprs, &(string[]){key}, &(int[]) { val + 1 });
		}
		if (expr_types.len > 0) {
			if ((cond_type_sym.kind == v__ast__Kind_sum_type || cond_type_sym.kind == v__ast__Kind_interface_)) {
				v__ast__Type expr_type = ((v__ast__Type)(0));
				if (expr_types.len > 1) {
					strings__Builder agg_name = strings__new_builder(20);
					strings__Builder agg_cname = strings__new_builder(20);
					strings__Builder_write_string(&agg_name, _SLIT("("));
					// FOR IN array
					for (int i = 0; i < expr_types.len; ++i) {
						v__ast__TypeNode expr = ((v__ast__TypeNode*)expr_types.data)[i];
						if (i > 0) {
							strings__Builder_write_string(&agg_name, _SLIT(" | "));
							strings__Builder_write_string(&agg_cname, _SLIT("___"));
						}
						string type_str = v__ast__Table_type_to_str(c->table, expr.typ);
						string name = (c->is_builtin_mod ? (type_str) : (_STR("%.*s\000.%.*s", 2, c->mod, type_str)));
						strings__Builder_write_string(&agg_name, name);
						strings__Builder_write_string(&agg_cname, v__util__no_dots(name));
					}
					strings__Builder_write_string(&agg_name, _SLIT(")"));
					string name = strings__Builder_str(&agg_name);
					int existing_idx = (*(int*)map_get(ADDR(map, c->table->type_idxs), &(string[]){name}, &(int[]){ 0 }));
					if (existing_idx > 0) {
						expr_type = existing_idx;
					} else {
						Array_v__ast__TypeNode _t2145_orig = expr_types;
						int _t2145_len = _t2145_orig.len;
						Array_v__ast__Type _t2145 = __new_array(0, _t2145_len, sizeof(v__ast__Type));

						for (int _t2146 = 0; _t2146 < _t2145_len; ++_t2146) {
							v__ast__TypeNode it = ((v__ast__TypeNode*) _t2145_orig.data)[_t2146];
							v__ast__Type ti = it.typ;
							array_push(&_t2145, &ti);
						}
						
						expr_type = v__ast__Table_register_type_symbol(c->table, (v__ast__TypeSymbol){.parent_idx = 0,.info = v__ast__Aggregate_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__Aggregate, ((v__ast__Aggregate){.fields = __new_array(0, 1, sizeof(v__ast__StructField)),.types = _t2145,}))),.kind = v__ast__Kind_aggregate,.name = name,.cname = strings__Builder_str(&agg_cname),.methods = __new_array(0, 1, sizeof(v__ast__Fn)),.mod = c->mod,.is_public = 0,.language = 0,});
					}
				} else {
					expr_type = (*(v__ast__TypeNode*)/*ee elem_typ */array_get(expr_types, 0)).typ;
				}
				v__checker__Checker_smartcast(c, node->cond, node->cond_type, expr_type, branch.scope);
			}
		}
	}
	bool is_exhaustive = true;
	Array_string unhandled = __new_array_with_default(0, 0, sizeof(string), 0);
	if (v__ast__Type_alias_eq(node->cond_type, _const_v__ast__bool_type)) {
		Array_string variants = new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT("true"), _SLIT("false")}));
		// FOR IN array
		for (int _t2147 = 0; _t2147 < variants.len; ++_t2147) {
			string v = ((string*)variants.data)[_t2147];
			if (!_IN_MAP(ADDR(string, v), ADDR(map, branch_exprs))) {
				is_exhaustive = false;
				array_push(&unhandled, _MOV((string[]){ string_clone(_STR("`%.*s\000`", 2, v)) }));
			}
		}
	} else {
		if (cond_type_sym.info._typ == 411 /* v.ast.SumType */) {
			// FOR IN array
			for (int _t2149 = 0; _t2149 < (*cond_type_sym.info._v__ast__SumType).variants.len; ++_t2149) {
				v__ast__Type v = ((v__ast__Type*)(*cond_type_sym.info._v__ast__SumType).variants.data)[_t2149];
				string v_str = v__ast__Table_type_to_str(c->table, v);
				if (!_IN_MAP(ADDR(string, v_str), ADDR(map, branch_exprs))) {
					is_exhaustive = false;
					array_push(&unhandled, _MOV((string[]){ string_clone(_STR("`%.*s\000`", 2, v_str)) }));
				}
			}
		}
		else if (cond_type_sym.info._typ == 420 /* v.ast.Enum */) {
			// FOR IN array
			for (int _t2151 = 0; _t2151 < (*cond_type_sym.info._v__ast__Enum).vals.len; ++_t2151) {
				string v = ((string*)(*cond_type_sym.info._v__ast__Enum).vals.data)[_t2151];
				if (!_IN_MAP(ADDR(string, v), ADDR(map, branch_exprs))) {
					is_exhaustive = false;
					array_push(&unhandled, _MOV((string[]){ string_clone(_STR("`.%.*s\000`", 2, v)) }));
				}
			}
		}
		else {
			is_exhaustive = false;
		};
	}
	v__ast__MatchBranch else_branch = (*(v__ast__MatchBranch*)/*ee elem_typ */array_get(node->branches, node->branches.len - 1));
	bool has_else = else_branch.is_else;
	if (!has_else) {
		// FOR IN array
		for (int i = 0; i < node->branches.len; ++i) {
			v__ast__MatchBranch branch = ((v__ast__MatchBranch*)node->branches.data)[i];
			if (branch.is_else && i != node->branches.len - 1) {
				v__checker__Checker_error(c, _SLIT("`else` must be the last branch of `match`"), branch.pos);
				else_branch = branch;
				has_else = true;
			}
		}
	}
	if (is_exhaustive) {
		if (has_else) {
			v__checker__Checker_error(c, _SLIT("match expression is exhaustive, `else` is unnecessary"), else_branch.pos);
		}
		return;
	}
	if (has_else) {
		return;
	}
	string err_details = _SLIT("match must be exhaustive");
	if (unhandled.len > 0) {
		err_details = /*f*/string_add(err_details, _SLIT(" (add match branches for: "));
		if (unhandled.len < c->match_exhaustive_cutoff_limit) {
			err_details = /*f*/string_add(err_details, Array_string_join(unhandled, _SLIT(", ")));
		} else {
			int remaining = unhandled.len - c->match_exhaustive_cutoff_limit;
			err_details = /*f*/string_add(err_details, Array_string_join(array_slice(unhandled, 0, c->match_exhaustive_cutoff_limit), _SLIT(", ")));
			err_details = /*f*/string_add(err_details, _STR(", and %"PRId32"\000 others ...", 2, remaining));
		}
		err_details = /*f*/string_add(err_details, _SLIT(" or `else {}` at the end)"));
	} else {
		err_details = /*f*/string_add(err_details, _SLIT(" (add `else {}` at the end)"));
	}
	v__checker__Checker_error(c, err_details, node->pos);
}

VV_LOCAL_SYMBOL void v__checker__Checker_smartcast(v__checker__Checker* c, v__ast__Expr expr, v__ast__Type cur_type, v__ast__Type to_type_, v__ast__Scope* scope) {
	v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(c->table, cur_type);
	v__ast__Type to_type = (sym->kind == v__ast__Kind_interface_ ? (v__ast__Type_to_ptr(to_type_)) : (to_type_));
	if (expr._typ == 273 /* v.ast.SelectorExpr */) {
		bool is_mut = false;
		Array_v__ast__Type smartcasts = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
		v__ast__TypeSymbol* expr_sym = v__ast__Table_get_type_symbol(c->table, (*expr._v__ast__SelectorExpr).expr_type);
		int orig_type = 0;
		Option_v__ast__StructField _t2153;
		if (_t2153 = v__ast__Table_find_field(c->table, expr_sym, (*expr._v__ast__SelectorExpr).field_name), _t2153.state == 0) {
			v__ast__StructField field = *(v__ast__StructField*)_t2153.data;
			if (field.is_mut) {
				Option_v__ast__Ident _t2154;
				if (_t2154 = v__ast__SelectorExpr_root_ident(&(*expr._v__ast__SelectorExpr)), _t2154.state == 0) {
					v__ast__Ident root_ident = *(v__ast__Ident*)_t2154.data;
					Option_v__ast__Var_ptr _t2155;
					if (_t2155 = v__ast__Scope_find_var(scope, root_ident.name), _t2155.state == 0) {
						v__ast__Var* v = *(v__ast__Var**)_t2155.data;
						is_mut = v->is_mut;
					}
				}
			}
			if (orig_type == 0) {
				orig_type = field.typ;
			}
		}
		Option_v__ast__ScopeStructField _t2156;
		if (_t2156 = v__ast__Scope_find_struct_field(scope, (*expr._v__ast__SelectorExpr).expr_type, (*expr._v__ast__SelectorExpr).field_name), _t2156.state == 0) {
			v__ast__ScopeStructField field = *(v__ast__ScopeStructField*)_t2156.data;
			_PUSH_MANY(&smartcasts, (field.smartcasts), _t2157, Array_v__ast__Type);
		}
		if (!is_mut || (*expr._v__ast__SelectorExpr).is_mut) {
			array_push(&smartcasts, _MOV((v__ast__Type[]){ to_type }));
			v__ast__Scope_register_struct_field(scope, (v__ast__ScopeStructField){
				.struct_type = (*expr._v__ast__SelectorExpr).expr_type,
				.name = (*expr._v__ast__SelectorExpr).field_name,
				.pos = (*expr._v__ast__SelectorExpr).pos,
				.typ = cur_type,
				.smartcasts = smartcasts,
				.orig_type = orig_type,
			});
		}
	}
	else if (expr._typ == 254 /* v.ast.Ident */) {
		bool is_mut = false;
		Array_v__ast__Type smartcasts = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
		bool is_already_casted = false;
		int orig_type = 0;
		if (((*expr._v__ast__Ident).obj)._typ == 312 /* v.ast.Var */) {
			is_mut = (*(*expr._v__ast__Ident).obj._v__ast__Var).is_mut;
			_PUSH_MANY(&smartcasts, ((*(*expr._v__ast__Ident).obj._v__ast__Var).smartcasts), _t2159, Array_v__ast__Type);
			is_already_casted = (*(*expr._v__ast__Ident).obj._v__ast__Var).pos.pos == (*expr._v__ast__Ident).pos.pos;
			if (orig_type == 0) {
				orig_type = (*(*expr._v__ast__Ident).obj._v__ast__Var).typ;
			}
		}
		if ((!is_mut || (*expr._v__ast__Ident).is_mut) && !is_already_casted) {
			array_push(&smartcasts, _MOV((v__ast__Type[]){ to_type }));
			v__ast__Scope_register(scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){
				.name = (*expr._v__ast__Ident).name,
				.expr = {0},
				.share = 0,
				.is_mut = (*expr._v__ast__Ident).is_mut,
				.is_autofree_tmp = 0,
				.is_arg = 0,
				.is_auto_deref = 0,
				.typ = cur_type,
				.orig_type = orig_type,
				.smartcasts = smartcasts,
				.pos = (*expr._v__ast__Ident).pos,
				.is_used = true,
				.is_changed = 0,
				.is_or = 0,
				.is_tmp = 0,
			}))));
		}
	}
	else {
	};
}

v__ast__Type v__checker__Checker_select_expr(v__checker__Checker* c, v__ast__SelectExpr* node) {
	node->is_expr = !v__ast__Type_alias_eq(c->expected_type, _const_v__ast__void_type);
	node->expected_type = c->expected_type;
	// FOR IN array
	for (int _t2161 = 0; _t2161 < node->branches.len; ++_t2161) {
		v__ast__SelectBranch branch = ((v__ast__SelectBranch*)node->branches.data)[_t2161];
		v__checker__Checker_stmt(c, branch.stmt);
		if (branch.stmt._typ == 293 /* v.ast.ExprStmt */) {
			if (branch.is_timeout) {
				if (!v__ast__Type_is_int((*branch.stmt._v__ast__ExprStmt).typ)) {
					v__ast__TypeSymbol* tsym = v__ast__Table_get_type_symbol(c->table, (*branch.stmt._v__ast__ExprStmt).typ);
					v__checker__Checker_error(c, _STR("invalid type `%.*s\000` for timeout - expected integer type aka `time.Duration`", 2, tsym->name), (*branch.stmt._v__ast__ExprStmt).pos);
				}
			} else {
				if (((*branch.stmt._v__ast__ExprStmt).expr)._typ == 258 /* v.ast.InfixExpr */) {
					if (((*(*branch.stmt._v__ast__ExprStmt).expr._v__ast__InfixExpr).left)._typ != 254 /* v.ast.Ident */ && ((*(*branch.stmt._v__ast__ExprStmt).expr._v__ast__InfixExpr).left)._typ != 273 /* v.ast.SelectorExpr */ && ((*(*branch.stmt._v__ast__ExprStmt).expr._v__ast__InfixExpr).left)._typ != 257 /* v.ast.IndexExpr */) {
						v__checker__Checker_error(c, _SLIT("channel in `select` key must be predefined"), v__ast__Expr_position((*(*branch.stmt._v__ast__ExprStmt).expr._v__ast__InfixExpr).left));
					}
				} else {
					v__checker__Checker_error(c, _SLIT("invalid expression for `select` key"), v__ast__Expr_position((*branch.stmt._v__ast__ExprStmt).expr));
				}
			}
		}
		else if (branch.stmt._typ == 285 /* v.ast.AssignStmt */) {
			v__ast__Expr expr = (*(v__ast__Expr*)/*ee elem_typ */array_get((*branch.stmt._v__ast__AssignStmt).right, 0));
			if (expr._typ == 270 /* v.ast.PrefixExpr */) {
				if (((*expr._v__ast__PrefixExpr).right)._typ != 254 /* v.ast.Ident */ && ((*expr._v__ast__PrefixExpr).right)._typ != 273 /* v.ast.SelectorExpr */ && ((*expr._v__ast__PrefixExpr).right)._typ != 257 /* v.ast.IndexExpr */) {
					v__checker__Checker_error(c, _SLIT("channel in `select` key must be predefined"), v__ast__Expr_position((*expr._v__ast__PrefixExpr).right));
				}
				if ((*expr._v__ast__PrefixExpr).or_block.kind != v__ast__OrKind_absent) {
					string err_prefix = ((*expr._v__ast__PrefixExpr).or_block.kind == v__ast__OrKind_block ? (_SLIT("or block")) : (_SLIT("error propagation")));
					v__checker__Checker_error(c, _STR("%.*s\000 not allowed in `select` key", 2, err_prefix), (*expr._v__ast__PrefixExpr).or_block.pos);
				}
			}
			else {
				v__checker__Checker_error(c, _SLIT("`<-` receive expression expected"), v__ast__Expr_position((*(v__ast__Expr*)/*ee elem_typ */array_get((*branch.stmt._v__ast__AssignStmt).right, 0))));
			};
		}
		else {
			if (!branch.is_else) {
				v__checker__Checker_error(c, _SLIT("receive or send statement expected as `select` key"), (*(branch.stmt.pos)));
			}
		};
		v__checker__Checker_stmts(c, branch.stmts);
	}
	// autofree_scope_vars(pos=173440 line_nr=5253 scope.pos=171696 scope.end_pos=173462)
	// var "c" var.pos=171701 var.line_nr=5198
	// var "node" var.pos=171728 var.line_nr=5198
	// af parent scope:
	// af parent scope:
	return _const_v__ast__bool_type;
}

v__ast__Type v__checker__Checker_lock_expr(v__checker__Checker* c, v__ast__LockExpr* node) {
	if (c->rlocked_names.len > 0 || c->locked_names.len > 0) {
		v__checker__Checker_error(c, _SLIT("nested `lock`/`rlock` not allowed"), node->pos);
	}
	for (int i = 0; i < node->lockeds.len; ++i) {
		v__checker__Checker_ident(c, (voidptr)&/*qq*/(*(v__ast__Ident*)/*ee elem_typ */array_get(node->lockeds, i)));
		v__ast__Ident id = (*(v__ast__Ident*)/*ee elem_typ */array_get(node->lockeds, i));
		if ((id.obj)._typ == 312 /* v.ast.Var */) {
			if (v__ast__Type_share((*id.obj._v__ast__Var).typ) != v__ast__ShareType_shared_t) {
				v__checker__Checker_error(c, _STR("`%.*s\000` must be declared `shared` to be locked", 2, id.name), id.pos);
			}
		} else {
			v__checker__Checker_error(c, _STR("`%.*s\000` is not a variable and cannot be locked", 2, id.name), id.pos);
		}
		if ((Array_string_contains(c->locked_names, id.name))) {
			v__checker__Checker_error(c, _STR("`%.*s\000` is already locked", 2, id.name), id.pos);
		} else if ((Array_string_contains(c->rlocked_names, id.name))) {
			v__checker__Checker_error(c, _STR("`%.*s\000` is already read-locked", 2, id.name), id.pos);
		}
		if ((*(bool*)/*ee elem_typ */array_get(node->is_rlock, i))) {
			array_push(&c->rlocked_names, _MOV((string[]){ string_clone(id.name) }));
		} else {
			array_push(&c->locked_names, _MOV((string[]){ string_clone(id.name) }));
		}
	}
	v__checker__Checker_stmts(c, node->stmts);
	c->rlocked_names = __new_array_with_default(0, 0, sizeof(string), 0);
	c->locked_names = __new_array_with_default(0, 0, sizeof(string), 0);
	v__ast__Type ret_type = _const_v__ast__void_type;
	if (node->stmts.len > 0) {
		v__ast__Stmt last_stmt = (*(v__ast__Stmt*)/*ee elem_typ */array_get(node->stmts, node->stmts.len - 1));
		if ((last_stmt)._typ == 293 /* v.ast.ExprStmt */) {
			ret_type = (*last_stmt._v__ast__ExprStmt).typ;
		}
	}
	if (!v__ast__Type_alias_eq(ret_type, _const_v__ast__void_type)) {
		node->is_expr = true;
	}
	node->typ = ret_type;
	// autofree_scope_vars(pos=174610 line_nr=5296 scope.pos=173472 scope.end_pos=174627)
	// var "c" var.pos=173477 var.line_nr=5256
	// var "node" var.pos=173502 var.line_nr=5256
	// var "ret_type" var.pos=174367 var.line_nr=5285
	// af parent scope:
	// af parent scope:
	return ret_type;
}

v__ast__Type v__checker__Checker_unsafe_expr(v__checker__Checker* c, v__ast__UnsafeExpr* node) {
	c->inside_unsafe = true;
	v__ast__Type t = v__checker__Checker_expr(c, node->expr);
	c->inside_unsafe = false;
	// autofree_scope_vars(pos=174774 line_nr=5303 scope.pos=174637 scope.end_pos=174784)
	// var "c" var.pos=174642 var.line_nr=5299
	// var "node" var.pos=174669 var.line_nr=5299
	// var "t" var.pos=174726 var.line_nr=5301
	// af parent scope:
	// af parent scope:
	return t;
}

v__ast__Type v__checker__Checker_if_expr(v__checker__Checker* c, v__ast__IfExpr* node) {
	string if_kind = (node->is_comptime ? (_SLIT("$if")) : (_SLIT("if")));
	bool expr_required = !v__ast__Type_alias_eq(c->expected_type, _const_v__ast__void_type);
	v__ast__Type former_expected_type = c->expected_type;
	node->typ = _const_v__ast__void_type;
	int nbranches_with_return = 0;
	int nbranches_without_return = 0;
	bool should_skip = false;
	bool found_branch = false;
	bool is_comptime_type_is_expr = false;
	for (int i = 0; i < node->branches.len; ++i) {
		v__ast__IfBranch branch = (*(v__ast__IfBranch*)/*ee elem_typ */array_get(node->branches, i));
		if ((branch.cond)._typ == 268 /* v.ast.ParExpr */) {
			v__checker__Checker_error(c, _STR("unnecessary `()` in `%.*s\000` condition, use `%.*s\000 expr {` instead of `%.*s\000 (expr) {`.", 4, if_kind, if_kind, if_kind), branch.pos);
		}
		if (!node->has_else || i < node->branches.len - 1) {
			if (node->is_comptime) {
				should_skip = v__checker__Checker_comp_if_branch(c, branch.cond, branch.pos);
			} else {
				c->expected_type = _const_v__ast__bool_type;
				v__ast__Type cond_typ = v__checker__Checker_expr(c, branch.cond);
				if (v__ast__Type_idx(cond_typ) != _const_v__ast__bool_type_idx && !c->pref->translated) {
					v__ast__TypeSymbol* typ_sym = v__ast__Table_get_type_symbol(c->table, cond_typ);
					v__checker__Checker_error(c, _STR("non-bool type `%.*s\000` used as if condition", 2, typ_sym->name), v__ast__Expr_position(branch.cond));
				}
			}
		}
		if (node->is_comptime) {
			string comptime_field_name = _SLIT("");
			if ((branch.cond)._typ == 258 /* v.ast.InfixExpr */) {
				if ((*branch.cond._v__ast__InfixExpr).op == v__token__Kind_key_is) {
					if (((*branch.cond._v__ast__InfixExpr).right)._typ != 279 /* v.ast.TypeNode */) {
						v__checker__Checker_error(c, _SLIT("invalid `$if` condition: expected a type"), v__ast__Expr_position((*branch.cond._v__ast__InfixExpr).right));
						 v__ast__Type _t2164 = 0;
						// autofree_scope_vars(pos=176361 line_nr=5342 scope.pos=176265 scope.end_pos=176376)
						// af parent scope:
						// var "got_type" var.pos=176383 var.line_nr=5344
						// var "sym" var.pos=176458 var.line_nr=5345
						// var "left" var.pos=176649 var.line_nr=5349
						// af parent scope:
						// af parent scope:
						// var "comptime_field_name" var.pos=176124 var.line_nr=5337
						// str literal
						// var "cur_skip_flags" var.pos=177062 var.line_nr=5363
						// af parent scope:
						// var "i" var.pos=175315 var.line_nr=5316
						// skipping tmp var "i"
						// var "branch" var.pos=175351 var.line_nr=5317
						// af parent scope:
						// var "c" var.pos=174799 var.line_nr=5306
						// var "node" var.pos=174822 var.line_nr=5306
						// var "if_kind" var.pos=174851 var.line_nr=5307
						// var "expr_required" var.pos=174908 var.line_nr=5308
						// var "former_expected_type" var.pos=174959 var.line_nr=5309
						// var "nbranches_with_return" var.pos=175030 var.line_nr=5311
						// var "nbranches_without_return" var.pos=175062 var.line_nr=5312
						// var "should_skip" var.pos=175097 var.line_nr=5313
						// var "found_branch" var.pos=175171 var.line_nr=5314
						// var "is_comptime_type_is_expr" var.pos=175252 var.line_nr=5315
						// af parent scope:
						// af parent scope:
						return _t2164;
					}
					v__ast__Type got_type = v__checker__Checker_unwrap_generic(c, (/* as */ *(v__ast__TypeNode*)__as_cast(((*branch.cond._v__ast__InfixExpr).right)._v__ast__TypeNode,((*branch.cond._v__ast__InfixExpr).right)._typ, 279) /*expected idx: 279, name: v.ast.TypeNode */ ).typ);
					v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(c->table, got_type);
					if (sym->kind == v__ast__Kind_placeholder || v__ast__Type_has_flag(got_type, v__ast__TypeFlag_generic)) {
						v__checker__Checker_error(c, _STR("unknown type `%.*s\000`", 2, sym->name), v__ast__Expr_position((*branch.cond._v__ast__InfixExpr).right));
					}
					v__ast__Expr left = (*branch.cond._v__ast__InfixExpr).left;
					if ((left)._typ == 273 /* v.ast.SelectorExpr */) {
						comptime_field_name = v__ast__Expr_str((*left._v__ast__SelectorExpr).expr);
						map_set(&c->comptime_fields_type, &(string[]){comptime_field_name}, &(v__ast__Type[]) { got_type });
						is_comptime_type_is_expr = true;
					} else if ((left)._typ == 279 /* v.ast.TypeNode */) {
						is_comptime_type_is_expr = true;
						v__ast__Type left_type = v__checker__Checker_unwrap_generic(c, (*left._v__ast__TypeNode).typ);
						if (!v__ast__Type_alias_eq(left_type, got_type)) {
							should_skip = true;
						}
					}
				}
			}
			bool cur_skip_flags = c->skip_flags;
			if (found_branch) {
				c->skip_flags = true;
			} else if (should_skip) {
				c->skip_flags = true;
				should_skip = false;
			} else if (!is_comptime_type_is_expr) {
				found_branch = true;
			}
			if (!c->skip_flags || c->pref->output_cross_c) {
				v__checker__Checker_stmts(c, branch.stmts);
			} else if (!is_comptime_type_is_expr) {
				(*(v__ast__IfBranch*)/*ee elem_typ */array_get(node->branches, i)).stmts = __new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
			}
			if (comptime_field_name.len > 0) {
				map_delete(&c->comptime_fields_type, &(string[]){comptime_field_name});
			}
			c->skip_flags = cur_skip_flags;
		} else {
			v__token__Position pos = v__ast__Expr_position(branch.cond);
			if ((branch.cond)._typ == 258 /* v.ast.InfixExpr */) {
				if ((*branch.cond._v__ast__InfixExpr).op == v__token__Kind_key_is) {
					v__ast__TypeNode right_expr = /* as */ *(v__ast__TypeNode*)__as_cast(((*branch.cond._v__ast__InfixExpr).right)._v__ast__TypeNode,((*branch.cond._v__ast__InfixExpr).right)._typ, 279) /*expected idx: 279, name: v.ast.TypeNode */ ;
					v__ast__TypeSymbol* left_sym = v__ast__Table_get_type_symbol(c->table, (*branch.cond._v__ast__InfixExpr).left_type);
					v__ast__Type expr_type = v__checker__Checker_expr(c, (*branch.cond._v__ast__InfixExpr).left);
					if (left_sym->kind == v__ast__Kind_interface_) {
						v__checker__Checker_type_implements(c, right_expr.typ, expr_type, pos);
					} else if (!v__checker__Checker_check_types(c, right_expr.typ, expr_type)) {
						string expect_str = v__ast__Table_type_to_str(c->table, right_expr.typ);
						string expr_str = v__ast__Table_type_to_str(c->table, expr_type);
						v__checker__Checker_error(c, _STR("cannot use type `%.*s\000` as type `%.*s\000`", 3, expect_str, expr_str), pos);
					}
					if ((((*branch.cond._v__ast__InfixExpr).left)._typ == 254 /* v.ast.Ident */ || ((*branch.cond._v__ast__InfixExpr).left)._typ == 273 /* v.ast.SelectorExpr */) && ((*branch.cond._v__ast__InfixExpr).right)._typ == 279 /* v.ast.TypeNode */) {
						bool is_variable = (((*branch.cond._v__ast__InfixExpr).left)._typ == 254 /* v.ast.Ident */ ? ((*(*branch.cond._v__ast__InfixExpr).left._v__ast__Ident).kind == v__ast__IdentKind_variable) : (true));
						if (is_variable) {
							if ((left_sym->kind == v__ast__Kind_interface_ || left_sym->kind == v__ast__Kind_sum_type)) {
								v__checker__Checker_smartcast(c, (*branch.cond._v__ast__InfixExpr).left, (*branch.cond._v__ast__InfixExpr).left_type, right_expr.typ, branch.scope);
							}
						}
					}
				}
			}
			v__checker__Checker_stmts(c, branch.stmts);
		}
		if (expr_required) {
			if (branch.stmts.len > 0 && ((*(v__ast__Stmt*)/*ee elem_typ */array_get(branch.stmts, branch.stmts.len - 1)))._typ == 293 /* v.ast.ExprStmt */) {
				v__ast__ExprStmt last_expr = /* as */ *(v__ast__ExprStmt*)__as_cast(((*(v__ast__Stmt*)/*ee elem_typ */array_get(branch.stmts, branch.stmts.len - 1)))._v__ast__ExprStmt,((*(v__ast__Stmt*)/*ee elem_typ */array_get(branch.stmts, branch.stmts.len - 1)))._typ, 293) /*expected idx: 293, name: v.ast.ExprStmt */ ;
				c->expected_type = former_expected_type;
				if (v__ast__Type_has_flag(c->expected_type, v__ast__TypeFlag_optional)) {
					if (v__ast__Type_alias_eq(node->typ, _const_v__ast__void_type)) {
						node->is_expr = true;
						node->typ = c->expected_type;
					}
					continue;
				}
				if (v__ast__Type_has_flag(c->expected_type, v__ast__TypeFlag_generic)) {
					if (v__ast__Type_alias_eq(node->typ, _const_v__ast__void_type)) {
						node->is_expr = true;
						node->typ = v__checker__Checker_unwrap_generic(c, c->expected_type);
					}
					continue;
				}
				last_expr.typ = v__checker__Checker_expr(c, last_expr.expr);
				if (!v__checker__Checker_check_types(c, last_expr.typ, node->typ)) {
					if (v__ast__Type_alias_eq(node->typ, _const_v__ast__void_type)) {
						node->is_expr = true;
						node->typ = last_expr.typ;
						continue;
					} else if ((node->typ == _const_v__ast__float_literal_type || node->typ == _const_v__ast__int_literal_type)) {
						if (v__ast__Type_alias_eq(node->typ, _const_v__ast__int_literal_type)) {
							if (v__ast__Type_is_int(last_expr.typ) || v__ast__Type_is_float(last_expr.typ)) {
								node->typ = last_expr.typ;
								continue;
							}
						} else {
							if (v__ast__Type_is_float(last_expr.typ)) {
								node->typ = last_expr.typ;
								continue;
							}
						}
					}
					if ((last_expr.typ == _const_v__ast__float_literal_type || last_expr.typ == _const_v__ast__int_literal_type)) {
						if (v__ast__Type_alias_eq(last_expr.typ, _const_v__ast__int_literal_type)) {
							if (v__ast__Type_is_int(node->typ) || v__ast__Type_is_float(node->typ)) {
								continue;
							}
						} else {
							if (v__ast__Type_is_float(node->typ)) {
								continue;
							}
						}
					}
					v__checker__Checker_error(c, _STR("mismatched types `%.*s\000` and `%.*s\000`", 3, v__ast__Table_type_to_str(c->table, node->typ), v__ast__Table_type_to_str(c->table, last_expr.typ)), node->pos);
				}
			} else {
				v__checker__Checker_error(c, _STR("`%.*s\000` expression requires an expression as the last statement of every branch", 2, if_kind), branch.pos);
			}
			// FOR IN array
			for (int _t2165 = 0; _t2165 < branch.stmts.len; ++_t2165) {
				v__ast__Stmt st = ((v__ast__Stmt*)branch.stmts.data)[_t2165];
				Option_void _t2166 = v__ast__Stmt_check_c_expr(st);
				if (_t2166.state != 0 && _t2166.err._typ != _IError_None___index) {
					IError err = _t2166.err;
					v__checker__Checker_error(c, _STR("`if` expression branch has %.*s", 1, (*(err.msg))), (*(st.pos)));
				};
			}
		}
		Option_bool _t2167;
		if (_t2167 = v__checker__Checker_has_return(c, branch.stmts), _t2167.state == 0) {
			bool has_return = *(bool*)_t2167.data;
			if (has_return) {
				nbranches_with_return++;
			} else {
				nbranches_without_return++;
			}
		}
	}
	if (nbranches_with_return > 0) {
		if (nbranches_with_return == node->branches.len) {
			c->returns = true;
		}
		if (!node->has_else) {
			c->returns = false;
		}
		if (nbranches_without_return > 0) {
			c->returns = false;
		}
	}
	if (v__ast__Type_alias_eq(node->typ, _const_v__ast__int_literal_type)) {
		node->typ = _const_v__ast__int_type;
	} else if (v__ast__Type_alias_eq(node->typ, _const_v__ast__float_literal_type)) {
		node->typ = _const_v__ast__f64_type;
	}
	if (expr_required && !node->has_else) {
		string d = (node->is_comptime ? (_SLIT("$")) : (_SLIT("")));
		v__checker__Checker_error(c, _STR("`%.*s\000` expression needs `%.*s\000else` clause", 3, if_kind, d), node->pos);
	}
	 v__ast__Type _t2168 = node->typ;
	// autofree_scope_vars(pos=181782 line_nr=5508 scope.pos=174794 scope.end_pos=181799)
	// var "c" var.pos=174799 var.line_nr=5306
	// var "node" var.pos=174822 var.line_nr=5306
	// var "if_kind" var.pos=174851 var.line_nr=5307
	// var "expr_required" var.pos=174908 var.line_nr=5308
	// var "former_expected_type" var.pos=174959 var.line_nr=5309
	// var "nbranches_with_return" var.pos=175030 var.line_nr=5311
	// var "nbranches_without_return" var.pos=175062 var.line_nr=5312
	// var "should_skip" var.pos=175097 var.line_nr=5313
	// var "found_branch" var.pos=175171 var.line_nr=5314
	// var "is_comptime_type_is_expr" var.pos=175252 var.line_nr=5315
	// af parent scope:
	// af parent scope:
	return _t2168;
}

VV_LOCAL_SYMBOL bool v__checker__Checker_comp_if_branch(v__checker__Checker* c, v__ast__Expr cond, v__token__Position pos) {
	if (cond._typ == 239 /* v.ast.BoolLiteral */) {
		 bool _t2169 = !(*cond._v__ast__BoolLiteral).val;
		// autofree_scope_vars(pos=182142 line_nr=5517 scope.pos=182122 scope.end_pos=182162)
		// var "cond" var.pos=182113 var.line_nr=5515
		// af parent scope:
		// var "c" var.pos=182001 var.line_nr=5513
		// var "cond" var.pos=182027 var.line_nr=5513
		// var "pos" var.pos=182042 var.line_nr=5513
		// af parent scope:
		// af parent scope:
		return _t2169;
	}
	else if (cond._typ == 268 /* v.ast.ParExpr */) {
		 bool _t2170 = v__checker__Checker_comp_if_branch(c, (*cond._v__ast__ParExpr).expr, pos);
		// autofree_scope_vars(pos=182182 line_nr=5520 scope.pos=182166 scope.end_pos=182225)
		// var "cond" var.pos=182113 var.line_nr=5515
		// af parent scope:
		// var "c" var.pos=182001 var.line_nr=5513
		// var "cond" var.pos=182027 var.line_nr=5513
		// var "pos" var.pos=182042 var.line_nr=5513
		// af parent scope:
		// af parent scope:
		return _t2170;
	}
	else if (cond._typ == 270 /* v.ast.PrefixExpr */) {
		if ((*cond._v__ast__PrefixExpr).op != v__token__Kind_not) {
			v__checker__Checker_error(c, _SLIT("invalid `$if` condition"), (*cond._v__ast__PrefixExpr).pos);
		}
		 bool _t2171 = !v__checker__Checker_comp_if_branch(c, (*cond._v__ast__PrefixExpr).right, (*cond._v__ast__PrefixExpr).pos);
		// autofree_scope_vars(pos=182327 line_nr=5526 scope.pos=182229 scope.end_pos=182377)
		// var "cond" var.pos=182113 var.line_nr=5515
		// af parent scope:
		// var "c" var.pos=182001 var.line_nr=5513
		// var "cond" var.pos=182027 var.line_nr=5513
		// var "pos" var.pos=182042 var.line_nr=5513
		// af parent scope:
		// af parent scope:
		return _t2171;
	}
	else if (cond._typ == 269 /* v.ast.PostfixExpr */) {
		if ((*cond._v__ast__PostfixExpr).op != v__token__Kind_question) {
			v__checker__Checker_error(c, _SLIT("invalid $if postfix operator"), (*cond._v__ast__PostfixExpr).pos);
		} else if (((*cond._v__ast__PostfixExpr).expr)._typ == 254 /* v.ast.Ident */) {
			 bool _t2172 = !(Array_string_contains(c->pref->compile_defines_all, (*(*cond._v__ast__PostfixExpr).expr._v__ast__Ident).name));
			// autofree_scope_vars(pos=182524 line_nr=5532 scope.pos=182519 scope.end_pos=182581)
			// af parent scope:
			// var "cond" var.pos=182113 var.line_nr=5515
			// af parent scope:
			// var "c" var.pos=182001 var.line_nr=5513
			// var "cond" var.pos=182027 var.line_nr=5513
			// var "pos" var.pos=182042 var.line_nr=5513
			// af parent scope:
			// af parent scope:
			return _t2172;
		} else {
			v__checker__Checker_error(c, _SLIT("invalid `$if` condition"), (*cond._v__ast__PostfixExpr).pos);
		}
	}
	else if (cond._typ == 258 /* v.ast.InfixExpr */) {

		if ((*cond._v__ast__InfixExpr).op == (v__token__Kind_and)) {
			bool l = v__checker__Checker_comp_if_branch(c, (*cond._v__ast__InfixExpr).left, (*cond._v__ast__InfixExpr).pos);
			bool r = v__checker__Checker_comp_if_branch(c, (*cond._v__ast__InfixExpr).right, (*cond._v__ast__InfixExpr).pos);
			 bool _t2173 = l || r;
			// autofree_scope_vars(pos=182798 line_nr=5542 scope.pos=182690 scope.end_pos=182873)
			// var "l" var.pos=182702 var.line_nr=5540
			// var "r" var.pos=182750 var.line_nr=5541
			// af parent scope:
			// var "cond" var.pos=182113 var.line_nr=5515
			// af parent scope:
			// var "c" var.pos=182001 var.line_nr=5513
			// var "cond" var.pos=182027 var.line_nr=5513
			// var "pos" var.pos=182042 var.line_nr=5513
			// af parent scope:
			// af parent scope:
			return _t2173;
		}
		else if ((*cond._v__ast__InfixExpr).op == (v__token__Kind_logical_or)) {
			bool l = v__checker__Checker_comp_if_branch(c, (*cond._v__ast__InfixExpr).left, (*cond._v__ast__InfixExpr).pos);
			bool r = v__checker__Checker_comp_if_branch(c, (*cond._v__ast__InfixExpr).right, (*cond._v__ast__InfixExpr).pos);
			 bool _t2174 = l && r;
			// autofree_scope_vars(pos=182994 line_nr=5547 scope.pos=182879 scope.end_pos=183066)
			// var "l" var.pos=182898 var.line_nr=5545
			// var "r" var.pos=182946 var.line_nr=5546
			// af parent scope:
			// var "cond" var.pos=182113 var.line_nr=5515
			// af parent scope:
			// var "c" var.pos=182001 var.line_nr=5513
			// var "cond" var.pos=182027 var.line_nr=5513
			// var "pos" var.pos=182042 var.line_nr=5513
			// af parent scope:
			// af parent scope:
			return _t2174;
		}
		else if ((*cond._v__ast__InfixExpr).op == (v__token__Kind_key_is) || (*cond._v__ast__InfixExpr).op == (v__token__Kind_not_is)) {
			if (((*cond._v__ast__InfixExpr).left)._typ == 273 /* v.ast.SelectorExpr */ || ((*cond._v__ast__InfixExpr).left)._typ == 279 /* v.ast.TypeNode */) {
				v__checker__Checker_expr(c, (*cond._v__ast__InfixExpr).left);
				 bool _t2175 = false;
				// autofree_scope_vars(pos=183225 line_nr=5553 scope.pos=183158 scope.end_pos=183244)
				// af parent scope:
				// af parent scope:
				// var "cond" var.pos=182113 var.line_nr=5515
				// af parent scope:
				// var "c" var.pos=182001 var.line_nr=5513
				// var "cond" var.pos=182027 var.line_nr=5513
				// var "pos" var.pos=182042 var.line_nr=5513
				// af parent scope:
				// af parent scope:
				return _t2175;
			} else {
				v__checker__Checker_error(c, _SLIT("invalid `$if` condition: expected a type or selector expression"), v__ast__Expr_position((*cond._v__ast__InfixExpr).left));
			}
		}
		else if ((*cond._v__ast__InfixExpr).op == (v__token__Kind_eq) || (*cond._v__ast__InfixExpr).op == (v__token__Kind_ne)) {
			if (((*cond._v__ast__InfixExpr).left)._typ == 273 /* v.ast.SelectorExpr */ && ((*cond._v__ast__InfixExpr).right)._typ == 259 /* v.ast.IntegerLiteral */) {
			} else if (((*cond._v__ast__InfixExpr).left)._typ == 254 /* v.ast.Ident */) {
				v__ast__Type left_type = v__checker__Checker_expr(c, (*cond._v__ast__InfixExpr).left);
				v__ast__Type right_type = v__checker__Checker_expr(c, (*cond._v__ast__InfixExpr).right);
				Option_v__ast__Expr _t2176 = v__checker__Checker_find_definition(c, (*(*cond._v__ast__InfixExpr).left._v__ast__Ident));
				if (_t2176.state != 0) { /*or block*/ 
					IError err = _t2176.err;
					v__checker__Checker_error(c, (*(err.msg)), (*(*cond._v__ast__InfixExpr).left._v__ast__Ident).pos);
					 bool _t2177 = false;
					// autofree_scope_vars(pos=183737 line_nr=5568 scope.pos=183690 scope.end_pos=183757)
					// var "err" var.pos=183690 var.line_nr=5566
					// af parent scope:
					// var "left_type" var.pos=183574 var.line_nr=5564
					// var "right_type" var.pos=183611 var.line_nr=5565
					// var "expr" var.pos=183650 var.line_nr=5566
					// var "different" var.pos=184098 var.line_nr=5578
					// af parent scope:
					// af parent scope:
					// var "cond" var.pos=182113 var.line_nr=5515
					// af parent scope:
					// var "c" var.pos=182001 var.line_nr=5513
					// var "cond" var.pos=182027 var.line_nr=5513
					// var "pos" var.pos=182042 var.line_nr=5513
					// af parent scope:
					// af parent scope:
					return _t2177;
				}
 				v__ast__Expr expr =  *(v__ast__Expr*)_t2176.data;
				if (!v__checker__Checker_check_types(c, right_type, left_type)) {
					string left_name = v__ast__Table_type_to_str(c->table, left_type);
					string right_name = v__ast__Table_type_to_str(c->table, right_type);
					v__checker__Checker_error(c, _STR("mismatched types `%.*s\000` and `%.*s\000`", 3, left_name, right_name), (*cond._v__ast__InfixExpr).pos);
				}
				bool different = string_ne(v__ast__Expr_str(expr), v__ast__Expr_str((*cond._v__ast__InfixExpr).right));
				 bool _t2178 = ((*cond._v__ast__InfixExpr).op == v__token__Kind_eq ? (different) : (!different));
				// autofree_scope_vars(pos=184147 line_nr=5579 scope.pos=183540 scope.end_pos=184212)
				// var "left_type" var.pos=183574 var.line_nr=5564
				// var "right_type" var.pos=183611 var.line_nr=5565
				// var "expr" var.pos=183650 var.line_nr=5566
				// var "different" var.pos=184098 var.line_nr=5578
				// af parent scope:
				// af parent scope:
				// var "cond" var.pos=182113 var.line_nr=5515
				// af parent scope:
				// var "c" var.pos=182001 var.line_nr=5513
				// var "cond" var.pos=182027 var.line_nr=5513
				// var "pos" var.pos=182042 var.line_nr=5513
				// af parent scope:
				// af parent scope:
				return _t2178;
			} else {
				v__checker__Checker_error(c, _STR("invalid `$if` condition: %.*s\0001", 2, tos3( /* v.ast.Expr */ v_typeof_sumtype_v__ast__Expr( ((*cond._v__ast__InfixExpr).left)._typ ))), (*cond._v__ast__InfixExpr).pos);
			}
		}
		else {
			v__checker__Checker_error(c, _SLIT("invalid `$if` condition"), (*cond._v__ast__InfixExpr).pos);
		};
	}
	else if (cond._typ == 254 /* v.ast.Ident */) {
		if ((Array_string_contains(_const_v__checker__valid_comp_if_os, (*cond._v__ast__Ident).name))) {
			 bool _t2179 = string_ne((*cond._v__ast__Ident).name, string_to_lower(v__pref__OS_str(c->pref->os)));
			// autofree_scope_vars(pos=184460 line_nr=5592 scope.pos=184455 scope.end_pos=184524)
			// af parent scope:
			// var "cond" var.pos=182113 var.line_nr=5515
			// af parent scope:
			// var "c" var.pos=182001 var.line_nr=5513
			// var "cond" var.pos=182027 var.line_nr=5513
			// var "pos" var.pos=182042 var.line_nr=5513
			// af parent scope:
			// af parent scope:
			return _t2179;
		} else if ((Array_string_contains(_const_v__checker__valid_comp_if_compilers, (*cond._v__ast__Ident).name))) {
			 bool _t2180 = v__pref__cc_from_string((*cond._v__ast__Ident).name) != c->pref->ccompiler_type;
			// autofree_scope_vars(pos=184584 line_nr=5594 scope.pos=184579 scope.end_pos=184651)
			// af parent scope:
			// var "cond" var.pos=182113 var.line_nr=5515
			// af parent scope:
			// var "c" var.pos=182001 var.line_nr=5513
			// var "cond" var.pos=182027 var.line_nr=5513
			// var "pos" var.pos=182042 var.line_nr=5513
			// af parent scope:
			// af parent scope:
			return _t2180;
		} else if ((Array_string_contains(_const_v__checker__valid_comp_if_platforms, (*cond._v__ast__Ident).name))) {
			 bool _t2181 = false;
			// autofree_scope_vars(pos=184711 line_nr=5596 scope.pos=184706 scope.end_pos=184736)
			// af parent scope:
			// var "cond" var.pos=182113 var.line_nr=5515
			// af parent scope:
			// var "c" var.pos=182001 var.line_nr=5513
			// var "cond" var.pos=182027 var.line_nr=5513
			// var "pos" var.pos=182042 var.line_nr=5513
			// af parent scope:
			// af parent scope:
			return _t2181;
		} else if ((Array_string_contains(_const_v__checker__valid_comp_if_other, (*cond._v__ast__Ident).name))) {

			if (string_eq((*cond._v__ast__Ident).name, _SLIT("js"))) {
				 bool _t2182 = c->pref->backend != v__pref__Backend_js;
				// autofree_scope_vars(pos=184865 line_nr=5600 scope.pos=184859 scope.end_pos=184895)
				// af parent scope:
				// af parent scope:
				// var "cond" var.pos=182113 var.line_nr=5515
				// af parent scope:
				// var "c" var.pos=182001 var.line_nr=5513
				// var "cond" var.pos=182027 var.line_nr=5513
				// var "pos" var.pos=182042 var.line_nr=5513
				// af parent scope:
				// af parent scope:
				return _t2182;
			}
			else if (string_eq((*cond._v__ast__Ident).name, _SLIT("debug"))) {
				 bool _t2183 = !c->pref->is_debug;
				// autofree_scope_vars(pos=184911 line_nr=5601 scope.pos=184902 scope.end_pos=184936)
				// af parent scope:
				// af parent scope:
				// var "cond" var.pos=182113 var.line_nr=5515
				// af parent scope:
				// var "c" var.pos=182001 var.line_nr=5513
				// var "cond" var.pos=182027 var.line_nr=5513
				// var "pos" var.pos=182042 var.line_nr=5513
				// af parent scope:
				// af parent scope:
				return _t2183;
			}
			else if (string_eq((*cond._v__ast__Ident).name, _SLIT("prod"))) {
				 bool _t2184 = !c->pref->is_prod;
				// autofree_scope_vars(pos=184951 line_nr=5602 scope.pos=184943 scope.end_pos=184975)
				// af parent scope:
				// af parent scope:
				// var "cond" var.pos=182113 var.line_nr=5515
				// af parent scope:
				// var "c" var.pos=182001 var.line_nr=5513
				// var "cond" var.pos=182027 var.line_nr=5513
				// var "pos" var.pos=182042 var.line_nr=5513
				// af parent scope:
				// af parent scope:
				return _t2184;
			}
			else if (string_eq((*cond._v__ast__Ident).name, _SLIT("test"))) {
				 bool _t2185 = !c->pref->is_test;
				// autofree_scope_vars(pos=184990 line_nr=5603 scope.pos=184982 scope.end_pos=185014)
				// af parent scope:
				// af parent scope:
				// var "cond" var.pos=182113 var.line_nr=5515
				// af parent scope:
				// var "c" var.pos=182001 var.line_nr=5513
				// var "cond" var.pos=182027 var.line_nr=5513
				// var "pos" var.pos=182042 var.line_nr=5513
				// af parent scope:
				// af parent scope:
				return _t2185;
			}
			else if (string_eq((*cond._v__ast__Ident).name, _SLIT("glibc"))) {
				 bool _t2186 = false;
				// autofree_scope_vars(pos=185030 line_nr=5604 scope.pos=185021 scope.end_pos=185044)
				// af parent scope:
				// af parent scope:
				// var "cond" var.pos=182113 var.line_nr=5515
				// af parent scope:
				// var "c" var.pos=182001 var.line_nr=5513
				// var "cond" var.pos=182027 var.line_nr=5513
				// var "pos" var.pos=182042 var.line_nr=5513
				// af parent scope:
				// af parent scope:
				return _t2186;
			}
			else if (string_eq((*cond._v__ast__Ident).name, _SLIT("prealloc"))) {
				 bool _t2187 = !c->pref->prealloc;
				// autofree_scope_vars(pos=185071 line_nr=5605 scope.pos=185059 scope.end_pos=185096)
				// af parent scope:
				// af parent scope:
				// var "cond" var.pos=182113 var.line_nr=5515
				// af parent scope:
				// var "c" var.pos=182001 var.line_nr=5513
				// var "cond" var.pos=182027 var.line_nr=5513
				// var "pos" var.pos=182042 var.line_nr=5513
				// af parent scope:
				// af parent scope:
				return _t2187;
			}
			else if (string_eq((*cond._v__ast__Ident).name, _SLIT("no_bounds_checking"))) {
				 bool _t2188 = !(Array_string_contains(c->pref->compile_defines_all, (*cond._v__ast__Ident).name));
				// autofree_scope_vars(pos=185125 line_nr=5606 scope.pos=185103 scope.end_pos=185174)
				// af parent scope:
				// af parent scope:
				// var "cond" var.pos=182113 var.line_nr=5515
				// af parent scope:
				// var "c" var.pos=182001 var.line_nr=5513
				// var "cond" var.pos=182027 var.line_nr=5513
				// var "pos" var.pos=182042 var.line_nr=5513
				// af parent scope:
				// af parent scope:
				return _t2188;
			}
			else if (string_eq((*cond._v__ast__Ident).name, _SLIT("freestanding"))) {
				 bool _t2189 = !c->pref->is_bare;
				// autofree_scope_vars(pos=185197 line_nr=5607 scope.pos=185181 scope.end_pos=185221)
				// af parent scope:
				// af parent scope:
				// var "cond" var.pos=182113 var.line_nr=5515
				// af parent scope:
				// var "c" var.pos=182001 var.line_nr=5513
				// var "cond" var.pos=182027 var.line_nr=5513
				// var "pos" var.pos=182042 var.line_nr=5513
				// af parent scope:
				// af parent scope:
				return _t2189;
			}
			else {
				 bool _t2190 = false;
				// autofree_scope_vars(pos=185234 line_nr=5608 scope.pos=185228 scope.end_pos=185248)
				// af parent scope:
				// af parent scope:
				// var "cond" var.pos=182113 var.line_nr=5515
				// af parent scope:
				// var "c" var.pos=182001 var.line_nr=5513
				// var "cond" var.pos=182027 var.line_nr=5513
				// var "pos" var.pos=182042 var.line_nr=5513
				// af parent scope:
				// af parent scope:
				return _t2190;
			};
		} else if (!(Array_string_contains(c->pref->compile_defines_all, (*cond._v__ast__Ident).name))) {
			v__ast__Type typ = v__checker__Checker_expr(c, cond);
			if (((*cond._v__ast__Ident).obj)._typ != 312 /* v.ast.Var */ && ((*cond._v__ast__Ident).obj)._typ != 310 /* v.ast.ConstField */ && ((*cond._v__ast__Ident).obj)._typ != 311 /* v.ast.GlobalField */) {
				v__checker__Checker_error(c, _STR("unknown var: `%.*s\000`", 2, (*cond._v__ast__Ident).name), pos);
				 bool _t2191 = false;
				// autofree_scope_vars(pos=185510 line_nr=5616 scope.pos=185457 scope.end_pos=185528)
				// af parent scope:
				// var "typ" var.pos=185341 var.line_nr=5612
				// var "expr" var.pos=185534 var.line_nr=5618
				// af parent scope:
				// var "cond" var.pos=182113 var.line_nr=5515
				// af parent scope:
				// var "c" var.pos=182001 var.line_nr=5513
				// var "cond" var.pos=182027 var.line_nr=5513
				// var "pos" var.pos=182042 var.line_nr=5513
				// af parent scope:
				// af parent scope:
				return _t2191;
			}
			Option_v__ast__Expr _t2192 = v__checker__Checker_find_obj_definition(c, (*cond._v__ast__Ident).obj);
			if (_t2192.state != 0) { /*or block*/ 
				IError err = _t2192.err;
				v__checker__Checker_error(c, (*(err.msg)), (*cond._v__ast__Ident).pos);
				 bool _t2193 = false;
				// autofree_scope_vars(pos=185615 line_nr=5620 scope.pos=185577 scope.end_pos=185633)
				// var "err" var.pos=185577 var.line_nr=5618
				// af parent scope:
				// var "typ" var.pos=185341 var.line_nr=5612
				// var "expr" var.pos=185534 var.line_nr=5618
				// af parent scope:
				// var "cond" var.pos=182113 var.line_nr=5515
				// af parent scope:
				// var "c" var.pos=182001 var.line_nr=5513
				// var "cond" var.pos=182027 var.line_nr=5513
				// var "pos" var.pos=182042 var.line_nr=5513
				// af parent scope:
				// af parent scope:
				return _t2193;
			}
 			v__ast__Expr expr =  *(v__ast__Expr*)_t2192.data;
			if (!v__checker__Checker_check_types(c, typ, _const_v__ast__bool_type)) {
				string type_name = v__ast__Table_type_to_str(c->table, typ);
				v__checker__Checker_error(c, _STR("non-bool type `%.*s\000` used as $if condition", 2, type_name), (*cond._v__ast__Ident).pos);
			}
			 bool _t2194 = !(/* as */ *(v__ast__BoolLiteral*)__as_cast((expr)._v__ast__BoolLiteral,(expr)._typ, 239) /*expected idx: 239, name: v.ast.BoolLiteral */ ).val;
			// autofree_scope_vars(pos=185891 line_nr=5628 scope.pos=185310 scope.end_pos=185933)
			// var "typ" var.pos=185341 var.line_nr=5612
			// var "expr" var.pos=185534 var.line_nr=5618
			// af parent scope:
			// var "cond" var.pos=182113 var.line_nr=5515
			// af parent scope:
			// var "c" var.pos=182001 var.line_nr=5513
			// var "cond" var.pos=182027 var.line_nr=5513
			// var "pos" var.pos=182042 var.line_nr=5513
			// af parent scope:
			// af parent scope:
			return _t2194;
		}
	}
	else {
		v__checker__Checker_error(c, _SLIT("invalid `$if` condition"), pos);
	};
	 bool _t2195 = false;
	// autofree_scope_vars(pos=185999 line_nr=5635 scope.pos=181996 scope.end_pos=186013)
	// var "c" var.pos=182001 var.line_nr=5513
	// var "cond" var.pos=182027 var.line_nr=5513
	// var "pos" var.pos=182042 var.line_nr=5513
	// af parent scope:
	// af parent scope:
	return _t2195;
}

VV_LOCAL_SYMBOL Option_v__ast__Expr v__checker__Checker_find_definition(v__checker__Checker* c, v__ast__Ident ident) {

	if (ident.kind == (v__ast__IdentKind_unresolved) || ident.kind == (v__ast__IdentKind_blank_ident)) {
		return (Option_v__ast__Expr){ .state=2, .err=_const_none__ };
	}
	else if (ident.kind == (v__ast__IdentKind_variable) || ident.kind == (v__ast__IdentKind_constant)) {
		 Option_v__ast__Expr _t2196 = v__checker__Checker_find_obj_definition(c, ident.obj);
		// autofree_scope_vars(pos=186168 line_nr=5641 scope.pos=186146 scope.end_pos=186209)
		// af parent scope:
		// var "c" var.pos=186024 var.line_nr=5638
		// var "ident" var.pos=186051 var.line_nr=5638
		// af parent scope:
		// af parent scope:
		return _t2196;
	}
	else if (ident.kind == (v__ast__IdentKind_global)) {
		return (Option_v__ast__Expr){ .state=2, .err=v_error(_STR("%.*s\000 is a global variable", 2, ident.name)) };
	}
	else if (ident.kind == (v__ast__IdentKind_function)) {
		return (Option_v__ast__Expr){ .state=2, .err=v_error(_STR("%.*s\000 is a function", 2, ident.name)) };
	};
	return (Option_v__ast__Expr){0};
}

VV_LOCAL_SYMBOL Option_v__ast__Expr v__checker__Checker_find_obj_definition(v__checker__Checker* c, v__ast__ScopeObject obj) {
	string name = _SLIT("");
	if (obj._typ == 312 /* v.ast.Var */) {
		name = (*obj._v__ast__Var).name;
	}
	else if (obj._typ == 310 /* v.ast.ConstField */) {
		name = (*obj._v__ast__ConstField).name;
	}
	else if (obj._typ == 311 /* v.ast.GlobalField */) {
		name = (*obj._v__ast__GlobalField).name;
	}
	else if (obj._typ == 309 /* v.ast.AsmRegister */) {
		name = (*obj._v__ast__AsmRegister).name;
	};
	v__ast__Expr expr = v__ast__empty_expr();
	if ((obj)._typ == 312 /* v.ast.Var */) {
		if ((*obj._v__ast__Var).is_mut) {
			return (Option_v__ast__Expr){ .state=2, .err=v_error(_STR("`%.*s\000` is mut and may have changed since its definition", 2, name)) };
		}
		expr = (*obj._v__ast__Var).expr;
	} else if ((obj)._typ == 310 /* v.ast.ConstField */) {
		expr = (*obj._v__ast__ConstField).expr;
	} else {
		return (Option_v__ast__Expr){ .state=2, .err=v_error(_STR("`%.*s\000` is a global variable and is unknown at compile time", 2, name)) };
	}
	if ((expr)._typ == 254 /* v.ast.Ident */) {
		 Option_v__ast__Expr _t2197 = v__checker__Checker_find_definition(c, /* as */ *(v__ast__Ident*)__as_cast((expr)._v__ast__Ident,(expr)._typ, 254) /*expected idx: 254, name: v.ast.Ident */ );
		// autofree_scope_vars(pos=186910 line_nr=5665 scope.pos=186907 scope.end_pos=186975)
		// af parent scope:
		// var "c" var.pos=186346 var.line_nr=5647
		// var "obj" var.pos=186377 var.line_nr=5647
		// var "name" var.pos=186467 var.line_nr=5649
		// str literal
		// var "expr" var.pos=186579 var.line_nr=5653
		// af parent scope:
		// af parent scope:
		return _t2197;
	}
	if (!v__ast__Expr_is_lit(expr)) {
		return (Option_v__ast__Expr){ .state=2, .err=v_error(_STR("definition of `%.*s\000` is unknown at compile time", 2, name)) };
	}
	Option_v__ast__Expr _t2198;
	opt_ok(&(v__ast__Expr[]) { expr }, (Option*)(&_t2198), sizeof(v__ast__Expr));
	// autofree_scope_vars(pos=187068 line_nr=5670 scope.pos=186341 scope.end_pos=187081)
	// var "c" var.pos=186346 var.line_nr=5647
	// var "obj" var.pos=186377 var.line_nr=5647
	// var "name" var.pos=186467 var.line_nr=5649
	// str literal
	// var "expr" var.pos=186579 var.line_nr=5653
	// af parent scope:
	// af parent scope:
	return _t2198;
}

VV_LOCAL_SYMBOL Option_bool v__checker__Checker_has_return(v__checker__Checker* c, Array_v__ast__Stmt stmts) {
	bool has_complexity = false;
	// FOR IN array
	for (int _t2199 = 0; _t2199 < stmts.len; ++_t2199) {
		v__ast__Stmt s = ((v__ast__Stmt*)stmts.data)[_t2199];
		if ((s)._typ == 293 /* v.ast.ExprStmt */) {
			if (((*s._v__ast__ExprStmt).expr)._typ == 255 /* v.ast.IfExpr */ || ((*s._v__ast__ExprStmt).expr)._typ == 263 /* v.ast.MatchExpr */) {
				has_complexity = true;
				break;
			}
		}
	}
	if (!has_complexity || !c->returns) {
		Option_bool _t2200;
		opt_ok(&(bool[]) { v__checker__has_top_return(stmts) }, (Option*)(&_t2200), sizeof(bool));
		// autofree_scope_vars(pos=187490 line_nr=5686 scope.pos=187487 scope.end_pos=187521)
		// af parent scope:
		// var "c" var.pos=187088 var.line_nr=5673
		// var "stmts" var.pos=187111 var.line_nr=5673
		// var "has_complexity" var.pos=187188 var.line_nr=5675
		// af parent scope:
		// af parent scope:
		return _t2200;
	}
	return (Option_bool){ .state=2, .err=_const_none__ };
}

v__ast__Type v__checker__Checker_postfix_expr(v__checker__Checker* c, v__ast__PostfixExpr* node) {
	v__ast__Type typ = v__checker__Checker_expr(c, node->expr);
	v__ast__TypeSymbol* typ_sym = v__ast__Table_get_type_symbol(c->table, typ);
	bool is_non_void_pointer = (v__ast__Type_is_ptr(typ) || v__ast__Type_is_pointer(typ)) && typ_sym->kind != v__ast__Kind_voidptr;
	if (!c->inside_unsafe && is_non_void_pointer && !v__ast__Expr_is_auto_deref_var(node->expr)) {
		v__checker__Checker_warn(c, _SLIT("pointer arithmetic is only allowed in `unsafe` blocks"), node->pos);
	}
	if (!(v__ast__TypeSymbol_is_number(typ_sym) || (c->inside_unsafe && is_non_void_pointer))) {
		v__checker__Checker_error(c, _STR("invalid operation: %.*s\000 (non-numeric type `%.*s\000`)", 3, v__token__Kind_str(node->op), typ_sym->name), node->pos);
	} else {
		multi_return_string_v__token__Position mr_188125 = v__checker__Checker_fail_if_immutable(c, node->expr);
		node->auto_locked = mr_188125.arg0;
	}
	// autofree_scope_vars(pos=188161 line_nr=5704 scope.pos=187546 scope.end_pos=188173)
	// var "c" var.pos=187551 var.line_nr=5691
	// var "node" var.pos=187579 var.line_nr=5691
	// var "typ" var.pos=187613 var.line_nr=5692
	// var "typ_sym" var.pos=187639 var.line_nr=5693
	// var "is_non_void_pointer" var.pos=187680 var.line_nr=5694
	// af parent scope:
	// af parent scope:
	return typ;
}

v__ast__Type v__checker__Checker_prefix_expr(v__checker__Checker* c, v__ast__PrefixExpr* node) {
	bool old_inside_ref_lit = c->inside_ref_lit;
	c->inside_ref_lit = c->inside_ref_lit || node->op == v__token__Kind_amp;
	v__ast__Type right_type = v__checker__Checker_expr(c, node->right);
	c->inside_ref_lit = old_inside_ref_lit;
	node->right_type = right_type;
	if (node->op == v__token__Kind_amp && !v__ast__Type_is_ptr(right_type)) {
		v__ast__Expr expr = node->right;
		for (;;) {
			if (!((expr)._typ == 268 /* v.ast.ParExpr */)) break;
			expr = (*expr._v__ast__ParExpr).expr;
		}
		if (expr._typ == 239 /* v.ast.BoolLiteral */) {
			v__checker__Checker_error(c, _STR("cannot take the address of %.*s", 1, v__ast__Expr_str(expr)), node->pos);
		}
		else if (expr._typ == 241 /* v.ast.CallExpr */) {
			v__checker__Checker_error(c, _STR("cannot take the address of %.*s", 1, v__ast__Expr_str(expr)), node->pos);
		}
		else if (expr._typ == 244 /* v.ast.CharLiteral */) {
			v__checker__Checker_error(c, _STR("cannot take the address of %.*s", 1, v__ast__Expr_str(expr)), node->pos);
		}
		else if (expr._typ == 252 /* v.ast.FloatLiteral */) {
			v__checker__Checker_error(c, _STR("cannot take the address of %.*s", 1, v__ast__Expr_str(expr)), node->pos);
		}
		else if (expr._typ == 259 /* v.ast.IntegerLiteral */) {
			v__checker__Checker_error(c, _STR("cannot take the address of %.*s", 1, v__ast__Expr_str(expr)), node->pos);
		}
		else if (expr._typ == 258 /* v.ast.InfixExpr */) {
			v__checker__Checker_error(c, _STR("cannot take the address of %.*s", 1, v__ast__Expr_str(expr)), node->pos);
		}
		else if (expr._typ == 277 /* v.ast.StringLiteral */) {
			v__checker__Checker_error(c, _STR("cannot take the address of %.*s", 1, v__ast__Expr_str(expr)), node->pos);
		}
		else if (expr._typ == 276 /* v.ast.StringInterLiteral */) {
			v__checker__Checker_error(c, _STR("cannot take the address of %.*s", 1, v__ast__Expr_str(expr)), node->pos);
		}
		else {
		};
		if ((node->right)._typ == 257 /* v.ast.IndexExpr */) {
			v__ast__TypeSymbol* typ_sym = v__ast__Table_get_type_symbol(c->table, (*node->right._v__ast__IndexExpr).left_type);
			bool is_mut = false;
			if (((*node->right._v__ast__IndexExpr).left)._typ == 254 /* v.ast.Ident */) {
				v__ast__Ident ident = (*(*node->right._v__ast__IndexExpr).left._v__ast__Ident);
				v__ast__ScopeObject ident_obj = ident.obj;
				if ((ident_obj)._typ == 312 /* v.ast.Var */) {
					is_mut = (*ident_obj._v__ast__Var).is_mut;
				}
			}
			if (typ_sym->kind == v__ast__Kind_map) {
				v__checker__Checker_error(c, _SLIT("cannot take the address of map values"), (*node->right._v__ast__IndexExpr).pos);
			}
			if (!c->inside_unsafe) {
				if (typ_sym->kind == v__ast__Kind_array && is_mut) {
					v__checker__Checker_error(c, _SLIT("cannot take the address of mutable array elements outside unsafe blocks"), (*node->right._v__ast__IndexExpr).pos);
				}
			}
		}
		 v__ast__Type _t2201 = v__ast__Type_to_ptr(right_type);
		// autofree_scope_vars(pos=189516 line_nr=5748 scope.pos=188527 scope.end_pos=189545)
		// var "expr" var.pos=188535 var.line_nr=5715
		// af parent scope:
		// var "c" var.pos=188188 var.line_nr=5707
		// var "node" var.pos=188215 var.line_nr=5707
		// var "old_inside_ref_lit" var.pos=188248 var.line_nr=5708
		// var "right_type" var.pos=188344 var.line_nr=5710
		// af parent scope:
		// af parent scope:
		return _t2201;
	} else if (node->op == v__token__Kind_amp && (node->right)._typ != 242 /* v.ast.CastExpr */) {
		 v__ast__Type _t2202 = v__ast__Type_to_ptr(right_type);
		// autofree_scope_vars(pos=189605 line_nr=5750 scope.pos=189602 scope.end_pos=189634)
		// af parent scope:
		// var "c" var.pos=188188 var.line_nr=5707
		// var "node" var.pos=188215 var.line_nr=5707
		// var "old_inside_ref_lit" var.pos=188248 var.line_nr=5708
		// var "right_type" var.pos=188344 var.line_nr=5710
		// af parent scope:
		// af parent scope:
		return _t2202;
	}
	if (node->op == v__token__Kind_mul) {
		if (v__ast__Type_is_ptr(right_type)) {
			 v__ast__Type _t2203 = v__ast__Type_deref(right_type);
			// autofree_scope_vars(pos=189687 line_nr=5754 scope.pos=189683 scope.end_pos=189716)
			// af parent scope:
			// af parent scope:
			// var "c" var.pos=188188 var.line_nr=5707
			// var "node" var.pos=188215 var.line_nr=5707
			// var "old_inside_ref_lit" var.pos=188248 var.line_nr=5708
			// var "right_type" var.pos=188344 var.line_nr=5710
			// af parent scope:
			// af parent scope:
			return _t2203;
		}
		if (!v__ast__Type_is_pointer(right_type)) {
			string s = v__ast__Table_type_to_str(c->table, right_type);
			v__checker__Checker_error(c, _STR("invalid indirect of `%.*s\000`", 2, s), node->pos);
		}
	}
	if (node->op == v__token__Kind_bit_not && !v__ast__Type_is_int(right_type) && !c->pref->translated) {
		v__checker__Checker_error(c, _SLIT("operator ~ only defined on int types"), node->pos);
	}
	if (node->op == v__token__Kind_not && right_type != _const_v__ast__bool_type_idx && !c->pref->translated) {
		v__checker__Checker_error(c, _SLIT("! operator can only be used with bool types"), node->pos);
	}
	if (node->op == v__token__Kind_arrow) {
		v__ast__TypeSymbol* right = v__ast__Table_get_type_symbol(c->table, right_type);
		if (right->kind == v__ast__Kind_chan) {
			v__checker__Checker_stmts(c, node->or_block.stmts);
			 v__ast__Type _t2204 = v__ast__TypeSymbol_chan_info(right).elem_type;
			// autofree_scope_vars(pos=190262 line_nr=5771 scope.pos=190226 scope.end_pos=190300)
			// af parent scope:
			// var "right" var.pos=190156 var.line_nr=5768
			// af parent scope:
			// var "c" var.pos=188188 var.line_nr=5707
			// var "node" var.pos=188215 var.line_nr=5707
			// var "old_inside_ref_lit" var.pos=188248 var.line_nr=5708
			// var "right_type" var.pos=188344 var.line_nr=5710
			// af parent scope:
			// af parent scope:
			return _t2204;
		} else {
			v__checker__Checker_error(c, _SLIT("<- operator can only be used with `chan` types"), node->pos);
		}
	}
	// autofree_scope_vars(pos=190387 line_nr=5776 scope.pos=188183 scope.end_pos=190406)
	// var "c" var.pos=188188 var.line_nr=5707
	// var "node" var.pos=188215 var.line_nr=5707
	// var "old_inside_ref_lit" var.pos=188248 var.line_nr=5708
	// var "right_type" var.pos=188344 var.line_nr=5710
	// af parent scope:
	// af parent scope:
	return right_type;
}

VV_LOCAL_SYMBOL void v__checker__Checker_check_index(v__checker__Checker* c, v__ast__TypeSymbol* typ_sym, v__ast__Expr index, v__ast__Type index_type, v__token__Position pos, bool range_index) {
	v__ast__TypeSymbol* index_type_sym = v__ast__Table_get_type_symbol(c->table, index_type);
	if ((typ_sym->kind == v__ast__Kind_array || typ_sym->kind == v__ast__Kind_array_fixed || typ_sym->kind == v__ast__Kind_string || typ_sym->kind == v__ast__Kind_ustring)) {
		if (!(v__ast__Type_is_int(index_type) || index_type_sym->kind == v__ast__Kind_enum_)) {
			string type_str = ((typ_sym->kind == v__ast__Kind_string || typ_sym->kind == v__ast__Kind_ustring) ? (_STR("non-integer string index `%.*s\000`", 2, index_type_sym->name)) : (_STR("non-integer index `%.*s\000` (array type `%.*s\000`)", 3, index_type_sym->name, typ_sym->name)));
			v__checker__Checker_error(c, _STR("%.*s", 1, type_str), pos);
		}
		if ((index)._typ == 259 /* v.ast.IntegerLiteral */) {
			if (string_at((*index._v__ast__IntegerLiteral).val, 0) == L'-') {
				v__checker__Checker_error(c, _STR("negative index `%.*s\000`", 2, (*index._v__ast__IntegerLiteral).val), (*index._v__ast__IntegerLiteral).pos);
			} else if (typ_sym->kind == v__ast__Kind_array_fixed) {
				int i = string_int((*index._v__ast__IntegerLiteral).val);
				v__ast__ArrayFixed info = /* as */ *(v__ast__ArrayFixed*)__as_cast((typ_sym->info)._v__ast__ArrayFixed,(typ_sym->info)._typ, 416) /*expected idx: 416, name: v.ast.ArrayFixed */ ;
				if ((!range_index && i >= info.size) || (range_index && i > info.size)) {
					v__checker__Checker_error(c, _STR("index out of range (index: %"PRId32"\000, len: %"PRId32"\000)", 3, i, info.size), (*index._v__ast__IntegerLiteral).pos);
				}
			}
		}
		if (v__ast__Type_has_flag(index_type, v__ast__TypeFlag_optional)) {
			string type_str = ((typ_sym->kind == v__ast__Kind_string || typ_sym->kind == v__ast__Kind_ustring) ? (_STR("(type `%.*s\000`)", 2, typ_sym->name)) : (_STR("(array type `%.*s\000`)", 2, typ_sym->name)));
			v__checker__Checker_error(c, _STR("cannot use optional as index %.*s", 1, type_str), pos);
		}
	}
}

v__ast__Type v__checker__Checker_index_expr(v__checker__Checker* c, v__ast__IndexExpr* node) {
	v__ast__Type typ = v__checker__Checker_expr(c, node->left);
	node->left_type = typ;
	v__ast__TypeSymbol* typ_sym = v__ast__Table_get_final_type_symbol(c->table, typ);

	if (typ_sym->kind == (v__ast__Kind_map)) {
		node->is_map = true;
	}
	else if (typ_sym->kind == (v__ast__Kind_array)) {
		node->is_array = true;
	}
	else if (typ_sym->kind == (v__ast__Kind_array_fixed)) {
		node->is_farray = true;
	}
	else {
	};
	if (!(typ_sym->kind == v__ast__Kind_array || typ_sym->kind == v__ast__Kind_array_fixed || typ_sym->kind == v__ast__Kind_string || typ_sym->kind == v__ast__Kind_map) && !v__ast__Type_is_ptr(typ) && !(typ == _const_v__ast__byteptr_type || typ == _const_v__ast__charptr_type) && !v__ast__Type_has_flag(typ, v__ast__TypeFlag_variadic)) {
		v__checker__Checker_error(c, _STR("type `%.*s\000` does not support indexing", 2, typ_sym->name), node->pos);
	}
	if (typ_sym->kind == v__ast__Kind_string && !v__ast__Type_is_ptr(typ) && node->is_setter) {
		v__checker__Checker_error(c, string_add(_SLIT("cannot assign to s[i] since V strings are immutable\n"), _SLIT("(note, that variables may be mutable but string values are always immutable, like in Go and Java)")), node->pos);
	}
	if (!c->inside_unsafe && ((v__ast__Type_is_ptr(typ) && !v__ast__Expr_is_auto_deref_var(node->left)) || v__ast__Type_is_pointer(typ))) {
		bool is_ok = false;
		if ((node->left)._typ == 254 /* v.ast.Ident */) {
			if (((*node->left._v__ast__Ident).obj)._typ == 312 /* v.ast.Var */) {
				v__ast__Var v = /* as */ *(v__ast__Var*)__as_cast(((*node->left._v__ast__Ident).obj)._v__ast__Var,((*node->left._v__ast__Ident).obj)._typ, 312) /*expected idx: 312, name: v.ast.Var */ ;
				is_ok = ((v.is_mut && v.is_arg) || v.share == v__ast__ShareType_shared_t) && !v__ast__Type_is_ptr(v__ast__Type_deref(typ));
			}
		}
		if (!is_ok && !c->pref->translated) {
			v__checker__Checker_warn(c, _SLIT("pointer indexing is only allowed in `unsafe` blocks"), node->pos);
		}
	}
	if ((node->index)._typ == 271 /* v.ast.RangeExpr */) {
		if ((*node->index._v__ast__RangeExpr).has_low) {
			v__ast__Type index_type = v__checker__Checker_expr(c, (*node->index._v__ast__RangeExpr).low);
			v__checker__Checker_check_index(c, typ_sym, (*node->index._v__ast__RangeExpr).low, index_type, node->pos, true);
		}
		if ((*node->index._v__ast__RangeExpr).has_high) {
			v__ast__Type index_type = v__checker__Checker_expr(c, (*node->index._v__ast__RangeExpr).high);
			v__checker__Checker_check_index(c, typ_sym, (*node->index._v__ast__RangeExpr).high, index_type, node->pos, true);
		}
		if (typ_sym->kind == v__ast__Kind_array_fixed) {
			v__ast__Type elem_type = v__ast__Table_value_type(c->table, typ);
			int idx = v__ast__Table_find_or_register_array(c->table, elem_type);
			typ = v__ast__new_type(idx);
		} else {
			typ = v__ast__Type_set_nr_muls(typ, 0);
		}
	} else {
		v__ast__Type index_type = v__checker__Checker_expr(c, node->index);
		if (typ_sym->kind == v__ast__Kind_map) {
			v__ast__Map info = /* as */ *(v__ast__Map*)__as_cast((typ_sym->info)._v__ast__Map,(typ_sym->info)._typ, 396) /*expected idx: 396, name: v.ast.Map */ ;
			if (!v__checker__Checker_check_types(c, index_type, info.key_type)) {
				string err = v__checker__Checker_expected_msg(c, index_type, info.key_type);
				v__checker__Checker_error(c, _STR("invalid key: %.*s", 1, err), node->pos);
			}
		} else {
			v__checker__Checker_check_index(c, typ_sym, node->index, index_type, node->pos, false);
		}
		v__ast__Type value_type = v__ast__Table_value_type(c->table, typ);
		if (!v__ast__Type_alias_eq(value_type, _const_v__ast__void_type)) {
			typ = value_type;
		}
	}
	v__checker__Checker_stmts(c, node->or_expr.stmts);
	// autofree_scope_vars(pos=194132 line_nr=5888 scope.pos=191794 scope.end_pos=194144)
	// var "c" var.pos=191799 var.line_nr=5815
	// var "node" var.pos=191825 var.line_nr=5815
	// var "typ" var.pos=191861 var.line_nr=5816
	// var "typ_sym" var.pos=191909 var.line_nr=5818
	// af parent scope:
	// af parent scope:
	return typ;
}

v__ast__Type v__checker__Checker_enum_val(v__checker__Checker* c, v__ast__EnumVal* node) {
	int typ_idx = ((node->enum_name).len == 0 ? (v__ast__Type_idx(c->expected_type)) : (v__ast__Table_find_type_idx(c->table, node->enum_name)));
	if (typ_idx == 0) {
		v__checker__Checker_error(c, _STR("not an enum (name=%.*s\000) (type_idx=0)", 2, node->enum_name), node->pos);
		// autofree_scope_vars(pos=194601 line_nr=5903 scope.pos=194527 scope.end_pos=194624)
		// af parent scope:
		// var "c" var.pos=194272 var.line_nr=5894
		// var "node" var.pos=194296 var.line_nr=5894
		// var "typ_idx" var.pos=194326 var.line_nr=5895
		// var "typ" var.pos=194631 var.line_nr=5905
		// var "typ_sym" var.pos=194837 var.line_nr=5915
		// var "info" var.pos=195471 var.line_nr=5932
		// af parent scope:
		// af parent scope:
		return _const_v__ast__void_type;
	}
	v__ast__Type typ = v__ast__new_type(typ_idx);
	if (c->pref->translated) {
		node->typ = typ;
		// autofree_scope_vars(pos=194729 line_nr=5909 scope.pos=194682 scope.end_pos=194742)
		// af parent scope:
		// var "c" var.pos=194272 var.line_nr=5894
		// var "node" var.pos=194296 var.line_nr=5894
		// var "typ_idx" var.pos=194326 var.line_nr=5895
		// var "typ" var.pos=194631 var.line_nr=5905
		// var "typ_sym" var.pos=194837 var.line_nr=5915
		// var "info" var.pos=195471 var.line_nr=5932
		// af parent scope:
		// af parent scope:
		return typ;
	}
	if (v__ast__Type_alias_eq(typ, _const_v__ast__void_type)) {
		v__checker__Checker_error(c, _SLIT("not an enum"), node->pos);
		// autofree_scope_vars(pos=194807 line_nr=5913 scope.pos=194769 scope.end_pos=194830)
		// af parent scope:
		// var "c" var.pos=194272 var.line_nr=5894
		// var "node" var.pos=194296 var.line_nr=5894
		// var "typ_idx" var.pos=194326 var.line_nr=5895
		// var "typ" var.pos=194631 var.line_nr=5905
		// var "typ_sym" var.pos=194837 var.line_nr=5915
		// var "info" var.pos=195471 var.line_nr=5932
		// af parent scope:
		// af parent scope:
		return _const_v__ast__void_type;
	}
	v__ast__TypeSymbol* typ_sym = v__ast__Table_get_type_symbol(c->table, typ);
	if (typ_sym->kind == v__ast__Kind_array && node->enum_name.len == 0) {
		v__ast__Array array_info = /* as */ *(v__ast__Array*)__as_cast((typ_sym->info)._v__ast__Array,(typ_sym->info)._typ, 395) /*expected idx: 395, name: v.ast.Array */ ;
		typ = array_info.elem_type;
		typ_sym = v__ast__Table_get_type_symbol(c->table, typ);
	}
	if (typ_sym->kind != v__ast__Kind_enum_ && !c->pref->translated) {
		v__checker__Checker_error(c, _STR("expected type is not an enum (`%.*s\000`)", 2, typ_sym->name), node->pos);
		// autofree_scope_vars(pos=195315 line_nr=5925 scope.pos=195163 scope.end_pos=195338)
		// af parent scope:
		// var "c" var.pos=194272 var.line_nr=5894
		// var "node" var.pos=194296 var.line_nr=5894
		// var "typ_idx" var.pos=194326 var.line_nr=5895
		// var "typ" var.pos=194631 var.line_nr=5905
		// var "typ_sym" var.pos=194837 var.line_nr=5915
		// var "info" var.pos=195471 var.line_nr=5932
		// af parent scope:
		// af parent scope:
		return _const_v__ast__void_type;
	}
	if ((typ_sym->info)._typ != 420 /* v.ast.Enum */) {
		v__checker__Checker_error(c, _SLIT("not an enum"), node->pos);
		// autofree_scope_vars(pos=195408 line_nr=5929 scope.pos=195370 scope.end_pos=195431)
		// af parent scope:
		// var "c" var.pos=194272 var.line_nr=5894
		// var "node" var.pos=194296 var.line_nr=5894
		// var "typ_idx" var.pos=194326 var.line_nr=5895
		// var "typ" var.pos=194631 var.line_nr=5905
		// var "typ_sym" var.pos=194837 var.line_nr=5915
		// var "info" var.pos=195471 var.line_nr=5932
		// af parent scope:
		// af parent scope:
		return _const_v__ast__void_type;
	}
	v__ast__Enum info = v__ast__TypeSymbol_enum_info(typ_sym);
	if (!(Array_string_contains(info.vals, node->val))) {
		v__util__Suggestion suggestion = v__util__new_suggestion(node->val, info.vals);
		v__checker__Checker_error(c, v__util__Suggestion_say(suggestion, _STR("enum `%.*s\000` does not have a value `%.*s\000`", 3, typ_sym->name, node->val)), node->pos);
	}
	node->typ = typ;
	// autofree_scope_vars(pos=195799 line_nr=5941 scope.pos=194267 scope.end_pos=195811)
	// var "c" var.pos=194272 var.line_nr=5894
	// var "node" var.pos=194296 var.line_nr=5894
	// var "typ_idx" var.pos=194326 var.line_nr=5895
	// var "typ" var.pos=194631 var.line_nr=5905
	// var "typ_sym" var.pos=194837 var.line_nr=5915
	// var "info" var.pos=195471 var.line_nr=5932
	// af parent scope:
	// af parent scope:
	return typ;
}

v__ast__Type v__checker__Checker_chan_init(v__checker__Checker* c, v__ast__ChanInit* node) {
	if (node->typ != 0) {
		v__ast__Chan info = v__ast__TypeSymbol_chan_info(v__ast__Table_get_type_symbol(c->table, node->typ));
		node->elem_type = info.elem_type;
		if (node->has_cap) {
			v__checker__Checker_check_array_init_para_type(c, _SLIT("cap"), node->cap_expr, node->pos);
		}
		 v__ast__Type _t2205 = node->typ;
		// autofree_scope_vars(pos=196080 line_nr=5951 scope.pos=195899 scope.end_pos=196098)
		// var "info" var.pos=195903 var.line_nr=5946
		// af parent scope:
		// var "c" var.pos=195826 var.line_nr=5944
		// var "node" var.pos=195851 var.line_nr=5944
		// af parent scope:
		// af parent scope:
		return _t2205;
	} else {
		v__checker__Checker_error(c, _SLIT("`chan` of unknown type"), node->pos);
		 v__ast__Type _t2206 = node->typ;
		// autofree_scope_vars(pos=196154 line_nr=5954 scope.pos=196105 scope.end_pos=196172)
		// af parent scope:
		// var "c" var.pos=195826 var.line_nr=5944
		// var "node" var.pos=195851 var.line_nr=5944
		// af parent scope:
		// af parent scope:
		return _t2206;
	}
	return 0;
}

v__ast__Type v__checker__Checker_offset_of(v__checker__Checker* c, v__ast__OffsetOf node) {
	v__ast__TypeSymbol* sym = v__ast__Table_get_final_type_symbol(c->table, node.struct_type);
	if (sym->kind != v__ast__Kind_struct_) {
		v__checker__Checker_error(c, _SLIT("first argument of __offsetof must be struct"), node.pos);
		// autofree_scope_vars(pos=196391 line_nr=5962 scope.pos=196321 scope.end_pos=196413)
		// af parent scope:
		// var "c" var.pos=196189 var.line_nr=5958
		// var "node" var.pos=196210 var.line_nr=5958
		// var "sym" var.pos=196241 var.line_nr=5959
		// af parent scope:
		// af parent scope:
		return _const_v__ast__u32_type;
	}
	if (!v__ast__Table_struct_has_field(c->table, sym, node.field)) {
		v__checker__Checker_error(c, _STR("struct `%.*s\000` has no field called `%.*s\000`", 3, sym->name, node.field), node.pos);
	}
	// autofree_scope_vars(pos=196543 line_nr=5967 scope.pos=196184 scope.end_pos=196564)
	// var "c" var.pos=196189 var.line_nr=5958
	// var "node" var.pos=196210 var.line_nr=5958
	// var "sym" var.pos=196241 var.line_nr=5959
	// af parent scope:
	// af parent scope:
	return _const_v__ast__u32_type;
}

void v__checker__Checker_check_dup_keys(v__checker__Checker* c, v__ast__MapInit* node, int i) {
	v__ast__Expr key_i = (*(v__ast__Expr*)/*ee elem_typ */array_get(node->keys, i));
	if ((key_i)._typ == 277 /* v.ast.StringLiteral */) {
		for (int j = 0; j < i; ++j) {
			v__ast__Expr key_j = (*(v__ast__Expr*)/*ee elem_typ */array_get(node->keys, j));
			if ((key_j)._typ == 277 /* v.ast.StringLiteral */) {
				if (string_eq((*key_i._v__ast__StringLiteral).val, (*key_j._v__ast__StringLiteral).val)) {
					v__checker__Checker_error(c, _STR("duplicate key \"%.*s\000\" in map literal", 2, (*key_i._v__ast__StringLiteral).val), (*key_i._v__ast__StringLiteral).pos);
				}
			}
		}
	} else if ((key_i)._typ == 259 /* v.ast.IntegerLiteral */) {
		for (int j = 0; j < i; ++j) {
			v__ast__Expr key_j = (*(v__ast__Expr*)/*ee elem_typ */array_get(node->keys, j));
			if ((key_j)._typ == 259 /* v.ast.IntegerLiteral */) {
				if (string_eq((*key_i._v__ast__IntegerLiteral).val, (*key_j._v__ast__IntegerLiteral).val)) {
					v__checker__Checker_error(c, _STR("duplicate key \"%.*s\000\" in map literal", 2, (*key_i._v__ast__IntegerLiteral).val), (*key_i._v__ast__IntegerLiteral).pos);
				}
			}
		}
	}
}

v__ast__Type v__checker__Checker_map_init(v__checker__Checker* c, v__ast__MapInit* node) {
	if (node->keys.len == 0 && node->vals.len == 0 && node->typ == 0) {
		v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(c->table, c->expected_type);
		if (sym->kind == v__ast__Kind_map) {
			v__ast__Map info = v__ast__TypeSymbol_map_info(sym);
			node->typ = c->expected_type;
			node->key_type = info.key_type;
			node->value_type = info.value_type;
			 v__ast__Type _t2207 = node->typ;
			// autofree_scope_vars(pos=197475 line_nr=6002 scope.pos=197345 scope.end_pos=197494)
			// var "info" var.pos=197350 var.line_nr=5998
			// af parent scope:
			// var "sym" var.pos=197275 var.line_nr=5996
			// af parent scope:
			// var "c" var.pos=197141 var.line_nr=5993
			// var "node" var.pos=197165 var.line_nr=5993
			// af parent scope:
			// af parent scope:
			return _t2207;
		} else {
			v__checker__Checker_error(c, _SLIT("invalid empty map initilization syntax, use e.g. map[string]int{} instead"), node->pos);
		}
	}
	if (node->typ != 0) {
		v__ast__Map info = v__ast__TypeSymbol_map_info(v__ast__Table_get_type_symbol(c->table, node->typ));
		Option_void _t2208 = v__checker__Checker_ensure_type_exists(c, info.key_type, node->pos);
		if (_t2208.state != 0 && _t2208.err._typ != _IError_None___index) {
			IError err = _t2208.err;
		};
		Option_void _t2209 = v__checker__Checker_ensure_type_exists(c, info.value_type, node->pos);
		if (_t2209.state != 0 && _t2209.err._typ != _IError_None___index) {
			IError err = _t2209.err;
		};
		node->key_type = info.key_type;
		node->value_type = info.value_type;
		 v__ast__Type _t2210 = node->typ;
		// autofree_scope_vars(pos=197911 line_nr=6015 scope.pos=197675 scope.end_pos=197929)
		// var "info" var.pos=197679 var.line_nr=6010
		// af parent scope:
		// var "c" var.pos=197141 var.line_nr=5993
		// var "node" var.pos=197165 var.line_nr=5993
		// af parent scope:
		// af parent scope:
		return _t2210;
	}
	if (node->keys.len > 0 && node->vals.len > 0) {
		v__ast__Type key0_type = v__ast__Table_mktyp(c->table, v__checker__Checker_expr(c, (*(v__ast__Expr*)/*ee elem_typ */array_get(node->keys, 0))));
		if (v__ast__Expr_is_auto_deref_var((*(v__ast__Expr*)/*ee elem_typ */array_get(node->keys, 0)))) {
			key0_type = v__ast__Type_deref(key0_type);
		}
		v__ast__Type val0_type = v__ast__Table_mktyp(c->table, v__checker__Checker_expr(c, (*(v__ast__Expr*)/*ee elem_typ */array_get(node->vals, 0))));
		if (v__ast__Expr_is_auto_deref_var((*(v__ast__Expr*)/*ee elem_typ */array_get(node->vals, 0)))) {
			val0_type = v__ast__Type_deref(val0_type);
		}
		bool same_key_type = true;
		// FOR IN array
		for (int i = 0; i < node->keys.len; ++i) {
			v__ast__Expr key = ((v__ast__Expr*)node->keys.data)[i];
			if (i == 0) {
				continue;
			}
			v__ast__Expr val = (*(v__ast__Expr*)/*ee elem_typ */array_get(node->vals, i));
			v__ast__Type key_type = v__checker__Checker_expr(c, key);
			c->expected_type = val0_type;
			v__ast__Type val_type = v__checker__Checker_expr(c, val);
			if (!v__checker__Checker_check_types(c, key_type, key0_type)) {
				string msg = v__checker__Checker_expected_msg(c, key_type, key0_type);
				v__checker__Checker_error(c, _STR("invalid map key: %.*s", 1, msg), v__ast__Expr_position(key));
				same_key_type = false;
			}
			if (!v__checker__Checker_check_types(c, val_type, val0_type)) {
				string msg = v__checker__Checker_expected_msg(c, val_type, val0_type);
				v__checker__Checker_error(c, _STR("invalid map value: %.*s", 1, msg), v__ast__Expr_position(val));
			}
		}
		if (same_key_type) {
			for (int i = 1; i < node->keys.len; ++i) {
				v__checker__Checker_check_dup_keys(c, node, i);
			}
		}
		v__ast__Type map_type = v__ast__new_type(v__ast__Table_find_or_register_map(c->table, key0_type, val0_type));
		node->typ = map_type;
		node->key_type = key0_type;
		node->value_type = val0_type;
		// autofree_scope_vars(pos=199039 line_nr=6055 scope.pos=197974 scope.end_pos=199057)
		// var "key0_type" var.pos=198001 var.line_nr=6019
		// var "val0_type" var.pos=198133 var.line_nr=6023
		// var "same_key_type" var.pos=198265 var.line_nr=6027
		// var "map_type" var.pos=198881 var.line_nr=6051
		// af parent scope:
		// var "c" var.pos=197141 var.line_nr=5993
		// var "node" var.pos=197165 var.line_nr=5993
		// af parent scope:
		// af parent scope:
		return map_type;
	}
	 v__ast__Type _t2211 = node->typ;
	// autofree_scope_vars(pos=199059 line_nr=6057 scope.pos=197136 scope.end_pos=199076)
	// var "c" var.pos=197141 var.line_nr=5993
	// var "node" var.pos=197165 var.line_nr=5993
	// af parent scope:
	// af parent scope:
	return _t2211;
}

void v__checker__Checker_add_error_detail(v__checker__Checker* c, string s) {
	array_push(&c->error_details, _MOV((string[]){ string_clone(s) }));
}

void v__checker__Checker_warn(v__checker__Checker* c, string s, v__token__Position pos) {
	bool allow_warnings = !(c->pref->is_prod || c->pref->warns_are_errors);
	v__checker__Checker_warn_or_error(c, s, pos, allow_warnings);
}

void v__checker__Checker_error(v__checker__Checker* c, string message, v__token__Position pos) {
	if (c->pref->translated && string_starts_with(message, _SLIT("mismatched types"))) {
		return;
	}
	if (c->pref->is_verbose) {
		print_backtrace();
	}
	string msg = string_replace(message, _SLIT("`Array_"), _SLIT("`[]"));
	v__checker__Checker_warn_or_error(c, msg, pos, false);
}

VV_LOCAL_SYMBOL bool v__checker__Checker_check_struct_signature(v__checker__Checker* c, v__ast__Struct from, v__ast__Struct to) {
	if (from.fields.len == 0) {
		 bool _t2213 = false;
		// autofree_scope_vars(pos=199879 line_nr=6086 scope.pos=199876 scope.end_pos=199894)
		// af parent scope:
		// var "c" var.pos=199740 var.line_nr=6083
		// var "from" var.pos=199775 var.line_nr=6083
		// var "to" var.pos=199792 var.line_nr=6083
		// af parent scope:
		// af parent scope:
		return _t2213;
	}
	// FOR IN array
	for (int _t2214 = 0; _t2214 < from.fields.len; ++_t2214) {
		v__ast__StructField field = ((v__ast__StructField*)from.fields.data)[_t2214];
		Array_v__ast__StructField _t2215_orig = to.fields;
		int _t2215_len = _t2215_orig.len;
		Array_v__ast__StructField _t2215 = __new_array(0, _t2215_len, sizeof(v__ast__StructField));

		for (int _t2216 = 0; _t2216 < _t2215_len; ++_t2216) {
			v__ast__StructField it = ((v__ast__StructField*) _t2215_orig.data)[_t2216];
			if (string_eq(it.name, field.name)) {
				array_push(&_t2215, &it); 
		}
		}
		
		Array_v__ast__StructField filtered = _t2215;
		if (filtered.len != 1) {
			 bool _t2217 = false;
			// autofree_scope_vars(pos=200031 line_nr=6092 scope.pos=200001 scope.end_pos=200047)
			// af parent scope:
			// var "field" var.pos=199901 var.line_nr=6088
			// skipping tmp var "field"
			// var "filtered" var.pos=199926 var.line_nr=6089
			// var "counterpart" var.pos=200051 var.line_nr=6094
			// af parent scope:
			// var "c" var.pos=199740 var.line_nr=6083
			// var "from" var.pos=199775 var.line_nr=6083
			// var "to" var.pos=199792 var.line_nr=6083
			// af parent scope:
			// af parent scope:
			return _t2217;
		}
		v__ast__StructField counterpart = (*(v__ast__StructField*)/*ee elem_typ */array_get(filtered, 0));
		if (!v__ast__Type_alias_eq(field.typ, counterpart.typ)) {
			 bool _t2218 = false;
			// autofree_scope_vars(pos=200146 line_nr=6097 scope.pos=200112 scope.end_pos=200162)
			// af parent scope:
			// var "field" var.pos=199901 var.line_nr=6088
			// skipping tmp var "field"
			// var "filtered" var.pos=199926 var.line_nr=6089
			// var "counterpart" var.pos=200051 var.line_nr=6094
			// af parent scope:
			// var "c" var.pos=199740 var.line_nr=6083
			// var "from" var.pos=199775 var.line_nr=6083
			// var "to" var.pos=199792 var.line_nr=6083
			// af parent scope:
			// af parent scope:
			return _t2218;
		}
		if (field.is_pub != counterpart.is_pub) {
			 bool _t2219 = false;
			// autofree_scope_vars(pos=200257 line_nr=6101 scope.pos=200204 scope.end_pos=200273)
			// af parent scope:
			// var "field" var.pos=199901 var.line_nr=6088
			// skipping tmp var "field"
			// var "filtered" var.pos=199926 var.line_nr=6089
			// var "counterpart" var.pos=200051 var.line_nr=6094
			// af parent scope:
			// var "c" var.pos=199740 var.line_nr=6083
			// var "from" var.pos=199775 var.line_nr=6083
			// var "to" var.pos=199792 var.line_nr=6083
			// af parent scope:
			// af parent scope:
			return _t2219;
		}
		if (field.is_mut != counterpart.is_mut) {
			 bool _t2220 = false;
			// autofree_scope_vars(pos=200369 line_nr=6105 scope.pos=200315 scope.end_pos=200385)
			// af parent scope:
			// var "field" var.pos=199901 var.line_nr=6088
			// skipping tmp var "field"
			// var "filtered" var.pos=199926 var.line_nr=6089
			// var "counterpart" var.pos=200051 var.line_nr=6094
			// af parent scope:
			// var "c" var.pos=199740 var.line_nr=6083
			// var "from" var.pos=199775 var.line_nr=6083
			// var "to" var.pos=199792 var.line_nr=6083
			// af parent scope:
			// af parent scope:
			return _t2220;
		}
	}
	 bool _t2221 = true;
	// autofree_scope_vars(pos=200390 line_nr=6108 scope.pos=199739 scope.end_pos=200403)
	// var "c" var.pos=199740 var.line_nr=6083
	// var "from" var.pos=199775 var.line_nr=6083
	// var "to" var.pos=199792 var.line_nr=6083
	// af parent scope:
	// af parent scope:
	return _t2221;
}

void v__checker__Checker_note(v__checker__Checker* c, string message, v__token__Position pos) {
	string details = _SLIT("");
	if (c->error_details.len > 0) {
		details = Array_string_join(c->error_details, _SLIT("\n"));
		c->error_details = __new_array_with_default(0, 0, sizeof(string), 0);
	}
	v__errors__Notice wrn = (v__errors__Notice){.message = message,.details = details,.file_path = c->file->path,.pos = pos,.reporter = v__errors__Reporter_checker,};
	array_push(&c->file->notices, _MOV((v__errors__Notice[]){ wrn }));
	array_push(&c->notices, _MOV((v__errors__Notice[]){ wrn }));
	c->nr_notices++;
}

VV_LOCAL_SYMBOL void v__checker__Checker_warn_or_error(v__checker__Checker* c, string message, v__token__Position pos, bool warn) {
	string details = _SLIT("");
	if (c->error_details.len > 0) {
		details = Array_string_join(c->error_details, _SLIT("\n"));
		c->error_details = __new_array_with_default(0, 0, sizeof(string), 0);
	}
	if (warn && !c->pref->skip_warnings) {
		c->nr_warnings++;
		v__errors__Warning wrn = (v__errors__Warning){.message = message,.details = details,.file_path = c->file->path,.pos = pos,.reporter = v__errors__Reporter_checker,};
		array_push(&c->file->warnings, _MOV((v__errors__Warning[]){ wrn }));
		array_push(&c->warnings, _MOV((v__errors__Warning[]){ wrn }));
		return;
	}
	if (!warn) {
		if (c->pref->fatal_errors) {
			v_exit(1);
		}
		c->nr_errors++;
		if (!(Array_int_contains(c->error_lines, pos.line_nr))) {
			v__errors__Error err = (v__errors__Error){.message = message,.details = details,.file_path = c->file->path,.pos = pos,.backtrace = (string){.str=(byteptr)"", .is_lit=1},.reporter = v__errors__Reporter_checker,};
			array_push(&c->file->errors, _MOV((v__errors__Error[]){ err }));
			array_push(&c->errors, _MOV((v__errors__Error[]){ err }));
			array_push(&c->error_lines, _MOV((int[]){ pos.line_nr }));
		}
	}
}

VV_LOCAL_SYMBOL bool v__checker__Checker_fileis(v__checker__Checker* c, string s) {
	 bool _t2229 = string_contains(c->file->path, s);
	// autofree_scope_vars(pos=201731 line_nr=6174 scope.pos=201694 scope.end_pos=201763)
	// var "c" var.pos=201695 var.line_nr=6173
	// var "s" var.pos=201714 var.line_nr=6173
	// af parent scope:
	// af parent scope:
	return _t2229;
}

VV_LOCAL_SYMBOL v__ast__Type v__checker__Checker_sql_expr(v__checker__Checker* c, v__ast__SqlExpr* node) {
bool v__checker__Checker_sql_expr_defer_0 = false;
	c->inside_sql = true;
	v__checker__Checker_sql_expr_defer_0 = true;
	v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(c->table, node->table_expr.typ);
	Option_void _t2230 = v__checker__Checker_ensure_type_exists(c, node->table_expr.typ, node->pos);
	if (_t2230.state != 0 && _t2230.err._typ != _IError_None___index) {
		IError err = _t2230.err;
		// Defer begin
		if (v__checker__Checker_sql_expr_defer_0 == true) {
			c->inside_sql = false;
		}
		// Defer end
		// autofree_scope_vars(pos=201993 line_nr=6183 scope.pos=201992 scope.end_pos=202015)
		// var "err" var.pos=201992 var.line_nr=6183
		// af parent scope:
		// var "c" var.pos=201774 var.line_nr=6177
		// var "node" var.pos=201798 var.line_nr=6177
		// var "sym" var.pos=201884 var.line_nr=6182
		// var "info" var.pos=202038 var.line_nr=6185
		// var "fields" var.pos=202070 var.line_nr=6186
		// var "sub_structs" var.pos=202152 var.line_nr=6187
		// af parent scope:
		// af parent scope:
		return _const_v__ast__void_type;
	};
	c->cur_orm_ts = *sym;
	v__ast__Struct info = /* as */ *(v__ast__Struct*)__as_cast((sym->info)._v__ast__Struct,(sym->info)._typ, 409) /*expected idx: 409, name: v.ast.Struct */ ;
	Array_v__ast__StructField fields = v__checker__Checker_fetch_and_verify_orm_fields(c, info, node->table_expr.pos, sym->name);
	Map_int_v__ast__SqlExpr sub_structs = new_map(sizeof(int), sizeof(v__ast__SqlExpr), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop);
	Array_v__ast__StructField _t2232_orig = fields;
	int _t2232_len = _t2232_orig.len;
	Array_v__ast__StructField _t2232 = __new_array(0, _t2232_len, sizeof(v__ast__StructField));

	for (int _t2233 = 0; _t2233 < _t2232_len; ++_t2233) {
		v__ast__StructField it = ((v__ast__StructField*) _t2232_orig.data)[_t2233];
		if ((*(v__ast__TypeSymbol*)/*ee elem_typ */array_get(c->table->type_symbols, ((int)(it.typ)))).kind == v__ast__Kind_struct_) {
			array_push(&_t2232, &it); 
		}
	}
	
	// FOR IN array
	Array_v__ast__StructField _t2231 = _t2232;
	for (int _t2234 = 0; _t2234 < _t2231.len; ++_t2234) {
		v__ast__StructField f = ((v__ast__StructField*)_t2231.data)[_t2234];
		v__ast__SqlExpr n = (v__ast__SqlExpr){.typ = f.typ,.is_count = 0,.db_expr = node->db_expr,.has_where = true,.has_offset = 0,.offset_expr = {0},.has_order = 0,.order_expr = {0},.has_desc = 0,.is_array = 0,.pos = node->pos,.has_limit = 0,.limit_expr = {0},.where_expr = {0},.table_expr = (v__ast__TypeNode){.typ = f.typ,.pos = node->table_expr.pos,},.fields = __new_array(0, 1, sizeof(v__ast__StructField)),.sub_structs = new_map(sizeof(int), sizeof(v__ast__SqlExpr), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),};
		bool tmp_inside_sql = c->inside_sql;
		v__checker__Checker_sql_expr(c, (voidptr)&/*qq*/n);
		c->inside_sql = tmp_inside_sql;
		n.where_expr = v__ast__InfixExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__InfixExpr, ((v__ast__InfixExpr){
			.op = v__token__Kind_eq,
			.pos = n.pos,
			.is_stmt = 0,
			.left = v__ast__Ident_to_sumtype_v__ast__Expr(ADDR(v__ast__Ident, ((v__ast__Ident){
				.language = v__ast__Language_v,
				.tok_kind = v__token__Kind_eq,
				.pos = {0},
				.mut_pos = {0},
				.scope = c->fn_scope,
				.obj = v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){.name = (string){.str=(byteptr)"", .is_lit=1},.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.is_auto_deref = 0,.typ = 0,.orig_type = 0,.smartcasts = __new_array(0, 1, sizeof(v__ast__Type)),.pos = {0},.is_used = 0,.is_changed = 0,.is_or = 0,.is_tmp = 0,}))),
				.mod = _SLIT("main"),
				.name = _SLIT("id"),
				.kind = v__ast__IdentKind_unresolved,
				.info = v__ast__IdentVar_to_sumtype_v__ast__IdentInfo(ADDR(v__ast__IdentVar, ((v__ast__IdentVar){.typ = 0,.is_mut = 0,.is_static = 0,.is_optional = 0,.share = 0,}))),
				.is_mut = false,
			}))),
			.right = v__ast__Ident_to_sumtype_v__ast__Expr(ADDR(v__ast__Ident, ((v__ast__Ident){
				.language = v__ast__Language_c,
				.tok_kind = v__token__Kind_eq,
				.pos = {0},
				.mut_pos = {0},
				.scope = c->fn_scope,
				.obj = v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){.name = (string){.str=(byteptr)"", .is_lit=1},.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.is_auto_deref = 0,.typ = 0,.orig_type = 0,.smartcasts = __new_array(0, 1, sizeof(v__ast__Type)),.pos = {0},.is_used = 0,.is_changed = 0,.is_or = 0,.is_tmp = 0,}))),
				.mod = _SLIT("main"),
				.name = (string){.str=(byteptr)"", .is_lit=1},
				.kind = 0,
				.info = v__ast__IdentVar_to_sumtype_v__ast__IdentInfo(ADDR(v__ast__IdentVar, ((v__ast__IdentVar){.typ = _const_v__ast__int_type,.is_mut = 0,.is_static = 0,.is_optional = 0,.share = 0,}))),
				.is_mut = false,
			}))),
			.left_type = _const_v__ast__int_type,
			.right_type = _const_v__ast__int_type,
			.auto_locked = _SLIT(""),
			.or_block = (v__ast__OrExpr){.stmts = __new_array(0, 1, sizeof(v__ast__Stmt)),.kind = 0,.pos = {0},},
		})));
		(*(v__ast__SqlExpr*)map_get_and_set(&sub_structs, &(int[]){((int)(f.typ))}, &(v__ast__SqlExpr[]){ (v__ast__SqlExpr){.fields = __new_array(0, 1, sizeof(v__ast__StructField)),.sub_structs = new_map(sizeof(int), sizeof(v__ast__SqlExpr), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),} })) = n;
	}
	node->fields = fields;
	node->sub_structs = map_move(&sub_structs);
	if (node->has_where) {
		v__checker__Checker_expr(c, node->where_expr);
	}
	if (node->has_offset) {
		v__checker__Checker_expr(c, node->offset_expr);
	}
	if (node->has_limit) {
		v__checker__Checker_expr(c, node->limit_expr);
	}
	if (node->has_order) {
		v__checker__Checker_expr(c, node->order_expr);
	}
	v__checker__Checker_expr(c, node->db_expr);
	// Defer begin
	if (v__checker__Checker_sql_expr_defer_0 == true) {
		c->inside_sql = false;
	}
	// Defer end
	 v__ast__Type _t2235 = node->typ;
	// autofree_scope_vars(pos=203399 line_nr=6250 scope.pos=201769 scope.end_pos=203416)
	// var "c" var.pos=201774 var.line_nr=6177
	// var "node" var.pos=201798 var.line_nr=6177
	// var "sym" var.pos=201884 var.line_nr=6182
	// var "info" var.pos=202038 var.line_nr=6185
	// var "fields" var.pos=202070 var.line_nr=6186
	// var "sub_structs" var.pos=202152 var.line_nr=6187
	// af parent scope:
	// af parent scope:
	return _t2235;
}

VV_LOCAL_SYMBOL v__ast__Type v__checker__Checker_sql_stmt(v__checker__Checker* c, v__ast__SqlStmt* node) {
bool v__checker__Checker_sql_stmt_defer_0 = false;
	c->inside_sql = true;
	v__checker__Checker_sql_stmt_defer_0 = true;
	Option_void _t2236 = v__checker__Checker_ensure_type_exists(c, node->table_expr.typ, node->pos);
	if (_t2236.state != 0 && _t2236.err._typ != _IError_None___index) {
		IError err = _t2236.err;
		// Defer begin
		if (v__checker__Checker_sql_stmt_defer_0 == true) {
			c->inside_sql = false;
		}
		// Defer end
		// autofree_scope_vars(pos=203593 line_nr=6258 scope.pos=203592 scope.end_pos=203615)
		// var "err" var.pos=203592 var.line_nr=6258
		// af parent scope:
		// var "c" var.pos=203427 var.line_nr=6253
		// var "node" var.pos=203451 var.line_nr=6253
		// var "table_sym" var.pos=203618 var.line_nr=6259
		// var "info" var.pos=203703 var.line_nr=6261
		// var "fields" var.pos=203741 var.line_nr=6262
		// var "sub_structs" var.pos=203829 var.line_nr=6263
		// af parent scope:
		// af parent scope:
		return _const_v__ast__void_type;
	};
	v__ast__TypeSymbol* table_sym = v__ast__Table_get_type_symbol(c->table, node->table_expr.typ);
	c->cur_orm_ts = *table_sym;
	v__ast__Struct info = /* as */ *(v__ast__Struct*)__as_cast((table_sym->info)._v__ast__Struct,(table_sym->info)._typ, 409) /*expected idx: 409, name: v.ast.Struct */ ;
	Array_v__ast__StructField fields = v__checker__Checker_fetch_and_verify_orm_fields(c, info, node->table_expr.pos, table_sym->name);
	Map_int_v__ast__SqlStmt sub_structs = new_map(sizeof(int), sizeof(v__ast__SqlStmt), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop);
	Array_v__ast__StructField _t2238_orig = fields;
	int _t2238_len = _t2238_orig.len;
	Array_v__ast__StructField _t2238 = __new_array(0, _t2238_len, sizeof(v__ast__StructField));

	for (int _t2239 = 0; _t2239 < _t2238_len; ++_t2239) {
		v__ast__StructField it = ((v__ast__StructField*) _t2238_orig.data)[_t2239];
		if ((*(v__ast__TypeSymbol*)/*ee elem_typ */array_get(c->table->type_symbols, ((int)(it.typ)))).kind == v__ast__Kind_struct_) {
			array_push(&_t2238, &it); 
		}
	}
	
	// FOR IN array
	Array_v__ast__StructField _t2237 = _t2238;
	for (int _t2240 = 0; _t2240 < _t2237.len; ++_t2240) {
		v__ast__StructField f = ((v__ast__StructField*)_t2237.data)[_t2240];
		v__ast__SqlStmt n = (v__ast__SqlStmt){.kind = node->kind,.db_expr = node->db_expr,.object_var_name = _STR("%.*s\000.%.*s", 2, node->object_var_name, f.name),.pos = node->pos,.where_expr = {0},.updated_columns = __new_array(0, 1, sizeof(string)),.update_exprs = __new_array(0, 1, sizeof(v__ast__Expr)),.table_expr = (v__ast__TypeNode){.typ = f.typ,.pos = node->table_expr.pos,},.fields = __new_array(0, 1, sizeof(v__ast__StructField)),.sub_structs = new_map(sizeof(int), sizeof(v__ast__SqlStmt), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),};
		bool tmp_inside_sql = c->inside_sql;
		v__checker__Checker_sql_stmt(c, (voidptr)&/*qq*/n);
		c->inside_sql = tmp_inside_sql;
		(*(v__ast__SqlStmt*)map_get_and_set(&sub_structs, &(int[]){((int)(f.typ))}, &(v__ast__SqlStmt[]){ (v__ast__SqlStmt){.updated_columns = __new_array(0, 1, sizeof(string)),.update_exprs = __new_array(0, 1, sizeof(v__ast__Expr)),.fields = __new_array(0, 1, sizeof(v__ast__StructField)),.sub_structs = new_map(sizeof(int), sizeof(v__ast__SqlStmt), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),} })) = n;
	}
	node->fields = fields;
	node->sub_structs = map_move(&sub_structs);
	v__checker__Checker_expr(c, node->db_expr);
	if (node->kind == v__ast__SqlStmtKind_update) {
		// FOR IN array
		for (int _t2241 = 0; _t2241 < node->update_exprs.len; ++_t2241) {
			v__ast__Expr expr = ((v__ast__Expr*)node->update_exprs.data)[_t2241];
			v__checker__Checker_expr(c, expr);
		}
	}
	if ((node->where_expr)._typ != 250 /* v.ast.EmptyExpr */) {
		v__checker__Checker_expr(c, node->where_expr);
	}
	// Defer begin
	if (v__checker__Checker_sql_stmt_defer_0 == true) {
		c->inside_sql = false;
	}
	// Defer end
	// autofree_scope_vars(pos=204520 line_nr=6292 scope.pos=203422 scope.end_pos=204542)
	// var "c" var.pos=203427 var.line_nr=6253
	// var "node" var.pos=203451 var.line_nr=6253
	// var "table_sym" var.pos=203618 var.line_nr=6259
	// var "info" var.pos=203703 var.line_nr=6261
	// var "fields" var.pos=203741 var.line_nr=6262
	// var "sub_structs" var.pos=203829 var.line_nr=6263
	// af parent scope:
	// af parent scope:
	return _const_v__ast__void_type;
}

VV_LOCAL_SYMBOL Array_v__ast__StructField v__checker__Checker_fetch_and_verify_orm_fields(v__checker__Checker* c, v__ast__Struct info, v__token__Position pos, string table_name) {
	Array_v__ast__StructField _t2242_orig = info.fields;
	int _t2242_len = _t2242_orig.len;
	Array_v__ast__StructField _t2242 = __new_array(0, _t2242_len, sizeof(v__ast__StructField));

	for (int _t2243 = 0; _t2243 < _t2242_len; ++_t2243) {
		v__ast__StructField it = ((v__ast__StructField*) _t2242_orig.data)[_t2243];
		if (((it.typ == _const_v__ast__string_type || it.typ == _const_v__ast__int_type || it.typ == _const_v__ast__bool_type) || (*(v__ast__TypeSymbol*)/*ee elem_typ */array_get(c->table->type_symbols, ((int)(it.typ)))).kind == v__ast__Kind_struct_) && !Array_v__ast__Attr_contains(it.attrs, _SLIT("skip"))) {
			array_push(&_t2242, &it); 
		}
	}
	
	Array_v__ast__StructField fields = _t2242;
	if (fields.len == 0) {
		v__checker__Checker_error(c, _STR("V orm: select: empty fields in `%.*s\000`", 2, table_name), pos);
		 Array_v__ast__StructField _t2244 = __new_array_with_default(0, 0, sizeof(v__ast__StructField), 0);
		// autofree_scope_vars(pos=204930 line_nr=6300 scope.pos=204864 scope.end_pos=204959)
		// af parent scope:
		// var "c" var.pos=204553 var.line_nr=6295
		// var "info" var.pos=204592 var.line_nr=6295
		// var "pos" var.pos=204609 var.line_nr=6295
		// var "table_name" var.pos=204629 var.line_nr=6295
		// var "fields" var.pos=204669 var.line_nr=6296
		// af parent scope:
		// af parent scope:
		return _t2244;
	}
	if (string_ne((*(v__ast__StructField*)/*ee elem_typ */array_get(fields, 0)).name, _SLIT("id"))) {
		v__checker__Checker_error(c, _STR("V orm: `id int` must be the first field in `%.*s\000`", 2, table_name), pos);
	}
	// autofree_scope_vars(pos=205068 line_nr=6305 scope.pos=204548 scope.end_pos=205083)
	// var "c" var.pos=204553 var.line_nr=6295
	// var "info" var.pos=204592 var.line_nr=6295
	// var "pos" var.pos=204609 var.line_nr=6295
	// var "table_name" var.pos=204629 var.line_nr=6295
	// var "fields" var.pos=204669 var.line_nr=6296
	// af parent scope:
	// af parent scope:
	return fields;
}

VV_LOCAL_SYMBOL void v__checker__Checker_post_process_generic_fns(v__checker__Checker* c) {
	for (int i = 0; i < c->file->generic_fns.len; ++i) {
		if (c->table->fn_gen_types.len == 0) {
			continue;
		}
		v__ast__FnDecl* node = (*(v__ast__FnDecl**)/*ee elem_typ */array_get(c->file->generic_fns, i));
		c->mod = node->mod;
		// FOR IN array
		Array_Array_v__ast__Type _t2245 = (*(Array_Array_v__ast__Type*)map_get(ADDR(map, c->table->fn_gen_types), &(string[]){node->name}, &(Array_Array_v__ast__Type[]){ __new_array(0, 1, sizeof(Array_v__ast__Type)) }));
		for (int _t2246 = 0; _t2246 < _t2245.len; ++_t2246) {
			Array_v__ast__Type gen_types = ((Array_v__ast__Type*)_t2245.data)[_t2246];
			c->cur_generic_types = gen_types;
			v__checker__Checker_fn_decl(c, node);
			if ((string_eq(node->name, _SLIT("vweb.run_app")) || string_eq(node->name, _SLIT("vweb.run")))) {
				_PUSH_MANY(&c->vweb_gen_types, (gen_types), _t2247, Array_v__ast__Type);
			}
		}
		c->cur_generic_types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
	}
}

VV_LOCAL_SYMBOL void v__checker__Checker_fn_decl(v__checker__Checker* c, v__ast__FnDecl* node) {
	c->returns = false;
	if (node->generic_names.len > 0 && c->cur_generic_types.len == 0) {
		array_push(&c->file->generic_fns, _MOV((v__ast__FnDecl*[]){ node }));
		return;
	}
	if (node->language == v__ast__Language_v && !c->is_builtin_mod) {
		v__checker__Checker_check_valid_snake_case(c, node->name, _SLIT("function name"), node->pos);
	}
	if (string_eq(node->name, _SLIT("main.main"))) {
		c->main_fn_decl_node = *node;
	}
	if (!v__ast__Type_alias_eq(node->return_type, _const_v__ast__void_type)) {
		// FOR IN array
		for (int _t2249 = 0; _t2249 < node->attrs.len; ++_t2249) {
			v__ast__Attr attr = ((v__ast__Attr*)node->attrs.data)[_t2249];
			if (attr.is_comptime_define) {
				v__checker__Checker_error(c, _STR("only functions that do NOT return values can have `[if %.*s\000]` tags", 2, attr.name), node->pos);
				break;
			}
		}
	}
	if (node->is_method) {
		v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(c->table, node->receiver.typ);
		if (sym->kind == v__ast__Kind_array && !c->is_builtin_mod && string_eq(node->name, _SLIT("map"))) {
			v__checker__Checker_error(c, _SLIT("method overrides built-in array method"), node->pos);
		} else if (sym->kind == v__ast__Kind_sum_type && string_eq(node->name, _SLIT("type_name"))) {
			v__checker__Checker_error(c, _SLIT("method overrides built-in sum type method"), node->pos);
		} else if (sym->kind == v__ast__Kind_multi_return) {
			v__checker__Checker_error(c, _SLIT("cannot define method on multi-value"), node->method_type_pos);
		}
		if (sym->name.len == 1) {
			v__checker__Checker_error(c, _STR("unknown type `%.*s\000`", 2, sym->name), node->receiver_pos);
			return;
		}
		if (sym->kind == v__ast__Kind_interface_ && v__ast__TypeSymbol_has_method(sym, node->name)) {
			if ((sym->info)._typ == 410 /* v.ast.Interface */) {
				v__ast__Interface info = /* as */ *(v__ast__Interface*)__as_cast((sym->info)._v__ast__Interface,(sym->info)._typ, 410) /*expected idx: 410, name: v.ast.Interface */ ;
				if (v__ast__Interface_has_method(&info, node->name)) {
					v__checker__Checker_error(c, _STR("interface `%.*s\000` cannot implement its own interface method `%.*s\000`", 3, sym->name, node->name), node->pos);
				}
			}
		}
		(*(v__ast__Fn*)/*ee elem_typ */array_get(sym->methods, node->method_idx)).source_fn = ((voidptr)(node));
	}
	if (node->language == v__ast__Language_v) {
		// FOR IN array
		for (int _t2250 = 0; _t2250 < node->params.len; ++_t2250) {
			v__ast__Param arg = ((v__ast__Param*)node->params.data)[_t2250];
			Option_void _t2251 = v__checker__Checker_ensure_type_exists(c, arg.typ, node->pos);
			if (_t2251.state != 0 && _t2251.err._typ != _IError_None___index) {
				IError err = _t2251.err;
				return;
			};
		}
	}
	if (node->language == v__ast__Language_v && string_eq(string_after_char(node->name, L'.'), _SLIT("init")) && !node->is_method && node->params.len == 0) {
		if (node->is_pub) {
			v__checker__Checker_error(c, _SLIT("fn `init` must not be public"), node->pos);
		}
		if (!v__ast__Type_alias_eq(node->return_type, _const_v__ast__void_type)) {
			v__checker__Checker_error(c, _SLIT("fn `init` cannot have a return type"), node->pos);
		}
	}
	if (!v__ast__Type_alias_eq(node->return_type, ((v__ast__Type)(0)))) {
		Option_void _t2252 = v__checker__Checker_ensure_type_exists(c, node->return_type, node->pos);
		if (_t2252.state != 0 && _t2252.err._typ != _IError_None___index) {
			IError err = _t2252.err;
			return;
		};
		if (node->language == v__ast__Language_v && node->is_method && string_eq(node->name, _SLIT("str"))) {
			if (!v__ast__Type_alias_eq(node->return_type, _const_v__ast__string_type)) {
				v__checker__Checker_error(c, _SLIT(".str() methods should return `string`"), node->pos);
			}
			if (node->params.len != 1) {
				v__checker__Checker_error(c, _SLIT(".str() methods should have 0 arguments"), node->pos);
			}
		}
		if (node->language == v__ast__Language_v && node->is_method && (string_eq(node->name, _SLIT("+")) || string_eq(node->name, _SLIT("-")) || string_eq(node->name, _SLIT("*")) || string_eq(node->name, _SLIT("%")) || string_eq(node->name, _SLIT("/")) || string_eq(node->name, _SLIT("<")) || string_eq(node->name, _SLIT("==")))) {
			if (node->params.len != 2) {
				v__checker__Checker_error(c, _SLIT("operator methods should have exactly 1 argument"), node->pos);
			} else {
				v__ast__TypeSymbol* receiver_sym = v__ast__Table_get_type_symbol(c->table, node->receiver.typ);
				v__ast__TypeSymbol* param_sym = v__ast__Table_get_type_symbol(c->table, (*(v__ast__Param*)/*ee elem_typ */array_get(node->params, 1)).typ);
				if (!(param_sym->kind == v__ast__Kind_struct_ || param_sym->kind == v__ast__Kind_alias) || !(receiver_sym->kind == v__ast__Kind_struct_ || receiver_sym->kind == v__ast__Kind_alias)) {
					v__checker__Checker_error(c, _SLIT("operator methods are only allowed for struct and type alias"), node->pos);
				} else {
					v__ast__TypeSymbol* parent_sym = v__ast__Table_get_final_type_symbol(c->table, node->receiver.typ);
					if (node->rec_mut) {
						v__checker__Checker_error(c, _SLIT("receiver cannot be `mut` for operator overloading"), node->receiver_pos);
					} else if ((*(v__ast__Param*)/*ee elem_typ */array_get(node->params, 1)).is_mut) {
						v__checker__Checker_error(c, _SLIT("argument cannot be `mut` for operator overloading"), node->pos);
					} else if (!v__ast__Type_alias_eq(node->receiver.typ, (*(v__ast__Param*)/*ee elem_typ */array_get(node->params, 1)).typ)) {
						v__checker__Checker_error(c, _STR("expected `%.*s\000` not `%.*s\000` - both operands must be the same type for operator overloading", 3, receiver_sym->name, param_sym->name), (*(v__ast__Param*)/*ee elem_typ */array_get(node->params, 1)).type_pos);
					} else if ((string_eq(node->name, _SLIT("<")) || string_eq(node->name, _SLIT("=="))) && !v__ast__Type_alias_eq(node->return_type, _const_v__ast__bool_type)) {
						v__checker__Checker_error(c, _SLIT("operator comparison methods should return `bool`"), node->pos);
					} else if (v__ast__TypeSymbol_is_primitive(parent_sym)) {
						v__checker__Checker_error(c, _STR("cannot define operator methods on type alias for `%.*s\000`", 2, parent_sym->name), node->pos);
					}
				}
			}
		}
	}
	if (node->language == v__ast__Language_v && !node->is_method && node->params.len == 0 && node->is_test) {
		if (!c->pref->is_test) {
			// FOR IN array
			for (int _t2253 = 0; _t2253 < node->stmts.len; ++_t2253) {
				v__ast__Stmt st = ((v__ast__Stmt*)node->stmts.data)[_t2253];
				if ((st)._typ == 284 /* v.ast.AssertStmt */) {
					v__checker__Checker_warn(c, _SLIT("tests will not be run, because filename does not end with `_test.v`"), node->pos);
					break;
				}
			}
		}
		if (node->return_type != _const_v__ast__void_type_idx && v__ast__Type_clear_flag(node->return_type, v__ast__TypeFlag_optional) != _const_v__ast__void_type_idx) {
			v__checker__Checker_error(c, _SLIT("test functions should either return nothing at all, or be marked to return `?`"), node->pos);
		}
	}
	c->expected_type = _const_v__ast__void_type;
	c->cur_fn = node;
	if (!v__ast__Type_alias_eq(node->return_type, _const_v__ast__void_type) && v__ast__Type_has_flag(node->return_type, v__ast__TypeFlag_optional) && (node->stmts.len == 0 || ((*(v__ast__Stmt*)/*ee elem_typ */array_get(node->stmts, node->stmts.len - 1)))._typ != 305 /* v.ast.Return */)) {
		v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(c->table, node->return_type);
		if (sym->kind == v__ast__Kind_void) {
			array_push(&node->stmts, _MOV((v__ast__Stmt[]){ v__ast__Return_to_sumtype_v__ast__Stmt(ADDR(v__ast__Return, ((v__ast__Return){.pos = node->pos,.exprs = __new_array(0, 1, sizeof(v__ast__Expr)),.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.types = __new_array(0, 1, sizeof(v__ast__Type)),}))) }));
		}
	}
	c->fn_scope = node->scope;
	v__checker__Checker_stmts(c, node->stmts);
	node->has_return = c->returns || v__checker__has_top_return(node->stmts);
	if (node->language == v__ast__Language_v && !node->no_body && !v__ast__Type_alias_eq(node->return_type, _const_v__ast__void_type) && !node->has_return && !(string_eq(node->name, _SLIT("panic")) || string_eq(node->name, _SLIT("exit")))) {
		if (c->inside_anon_fn) {
			v__checker__Checker_error(c, _SLIT("missing return at the end of an anonymous function"), node->pos);
		} else {
			v__checker__Checker_error(c, _STR("missing return at end of function `%.*s\000`", 2, node->name), node->pos);
		}
	}
	c->returns = false;
	node->source_file = c->file;
}

VV_LOCAL_SYMBOL bool v__checker__has_top_return(Array_v__ast__Stmt stmts) {
	// FOR IN array
	for (int _t2255 = 0; _t2255 < stmts.len; ++_t2255) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)stmts.data)[_t2255];
		if ((stmt)._typ == 305 /* v.ast.Return */) {
			 bool _t2256 = true;
			// autofree_scope_vars(pos=211482 line_nr=6487 scope.pos=211478 scope.end_pos=211497)
			// var "stmt" var.pos=211459 var.line_nr=6486
			// af parent scope:
			// var "stmt" var.pos=211438 var.line_nr=6485
			// skipping tmp var "stmt"
			// af parent scope:
			// var "stmts" var.pos=211408 var.line_nr=6484
			// af parent scope:
			// af parent scope:
			return _t2256;
		} else if ((stmt)._typ == 286 /* v.ast.Block */) {
			if (v__checker__has_top_return((*stmt._v__ast__Block).stmts)) {
				 bool _t2257 = true;
				// autofree_scope_vars(pos=211565 line_nr=6490 scope.pos=211560 scope.end_pos=211581)
				// af parent scope:
				// var "stmt" var.pos=211507 var.line_nr=6488
				// af parent scope:
				// var "stmt" var.pos=211438 var.line_nr=6485
				// skipping tmp var "stmt"
				// af parent scope:
				// var "stmts" var.pos=211408 var.line_nr=6484
				// af parent scope:
				// af parent scope:
				return _t2257;
			}
		} else if ((stmt)._typ == 293 /* v.ast.ExprStmt */) {
			if (((*stmt._v__ast__ExprStmt).expr)._typ == 241 /* v.ast.CallExpr */) {
				if ((string_eq((*(*stmt._v__ast__ExprStmt).expr._v__ast__CallExpr).name, _SLIT("panic")) || string_eq((*(*stmt._v__ast__ExprStmt).expr._v__ast__CallExpr).name, _SLIT("exit")))) {
					 bool _t2258 = true;
					// autofree_scope_vars(pos=211701 line_nr=6495 scope.pos=211695 scope.end_pos=211718)
					// af parent scope:
					// af parent scope:
					// var "stmt" var.pos=211595 var.line_nr=6492
					// af parent scope:
					// var "stmt" var.pos=211438 var.line_nr=6485
					// skipping tmp var "stmt"
					// af parent scope:
					// var "stmts" var.pos=211408 var.line_nr=6484
					// af parent scope:
					// af parent scope:
					return _t2258;
				}
			}
		}
	}
	 bool _t2259 = false;
	// autofree_scope_vars(pos=211732 line_nr=6500 scope.pos=211393 scope.end_pos=211746)
	// var "stmts" var.pos=211408 var.line_nr=6484
	// af parent scope:
	// af parent scope:
	return _t2259;
}

VV_LOCAL_SYMBOL multi_return_bool_int_int v__checker__Checker_verify_vweb_params_for_method(v__checker__Checker* c, v__ast__Fn m) {
	int margs = m.params.len - 1;
	if (m.attrs.len == 0) {
		return (multi_return_bool_int_int){.arg0=true, .arg1=-1, .arg2=margs};
	}
	int route_attributes = 0;
	// FOR IN array
	for (int _t2260 = 0; _t2260 < m.attrs.len; ++_t2260) {
		v__ast__Attr a = ((v__ast__Attr*)m.attrs.data)[_t2260];
		if (string_starts_with(a.name, _SLIT("/"))) {
			route_attributes += string_count(a.name, _SLIT(":"));
		}
	}
	return (multi_return_bool_int_int){.arg0=route_attributes == margs, .arg1=route_attributes, .arg2=margs};
}

VV_LOCAL_SYMBOL void v__checker__Checker_verify_all_vweb_routes(v__checker__Checker* c) {
	if (c->vweb_gen_types.len == 0) {
		return;
	}
	int typ_vweb_result = v__ast__Table_find_type_idx(c->table, _SLIT("vweb.Result"));
	// FOR IN array
	for (int _t2261 = 0; _t2261 < c->vweb_gen_types.len; ++_t2261) {
		v__ast__Type vgt = ((v__ast__Type*)c->vweb_gen_types.data)[_t2261];
		v__ast__TypeSymbol* sym_app = v__ast__Table_get_type_symbol(c->table, vgt);
		// FOR IN array
		for (int _t2262 = 0; _t2262 < sym_app->methods.len; ++_t2262) {
			v__ast__Fn m = ((v__ast__Fn*)sym_app->methods.data)[_t2262];
			if (m.return_type == typ_vweb_result) {
				multi_return_bool_int_int mr_212508 = v__checker__Checker_verify_vweb_params_for_method(c, m);
				bool is_ok = mr_212508.arg0;
				int nroute_attributes = mr_212508.arg1;
				int nargs = mr_212508.arg2;
				if (!is_ok) {
					v__ast__FnDecl* f = ((v__ast__FnDecl*)(m.source_fn));
					if (isnil(f)) {
						continue;
					}
					if (f->return_type == typ_vweb_result && v__ast__Type_alias_eq(f->receiver.typ, (*(v__ast__Param*)/*ee elem_typ */array_get(m.params, 0)).typ) && string_eq(f->name, m.name)) {
						c->file = f->source_file;
						v__checker__Checker_warn(c, _STR("mismatched parameters count between vweb method `%.*s\000.%.*s\000` (%"PRId32"\000) and route attribute %.*s\000 (%"PRId32"\000)", 6, sym_app->name, m.name, nargs, Array_v__ast__Attr_str(m.attrs), nroute_attributes), f->pos);
					}
				}
			}
		}
	}
}

VV_LOCAL_SYMBOL void v__checker__Checker_trace(v__checker__Checker* c, string fbase, string message) {
	if (string_eq(c->file->path_base, fbase)) {
		println(_STR("> c.trace | %*.*s\000 | %.*s", 2, fbase, -10, message));
	}
}

VV_LOCAL_SYMBOL Option_void v__checker__Checker_ensure_type_exists(v__checker__Checker* c, v__ast__Type typ, v__token__Position pos) {
	if (typ == 0) {
		v__checker__Checker_error(c, _SLIT("unknown type"), pos);
	}
	v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(c->table, typ);

	if (sym->kind == (v__ast__Kind_placeholder)) {
		if (sym->language == v__ast__Language_v && !string_starts_with(sym->name, _SLIT("C."))) {
			v__checker__Checker_error(c, v__util__Suggestion_say(v__util__new_suggestion(sym->name, v__ast__Table_known_type_names(c->table)), _STR("unknown type `%.*s\000`", 2, sym->name)), pos);
			return (Option_void){ .state=2, .err=_const_none__ };
		}
	}
	else if (sym->kind == (v__ast__Kind_int_literal) || sym->kind == (v__ast__Kind_float_literal)) {
		if (!c->is_builtin_mod) {
			string msg = (sym->kind == v__ast__Kind_int_literal ? (_STR("unknown type `%.*s\000`.\nDid you mean `int`?", 2, sym->name)) : (_STR("unknown type `%.*s\000`.\nDid you mean `f64`?", 2, sym->name)));
			v__checker__Checker_error(c, msg, pos);
			return (Option_void){ .state=2, .err=_const_none__ };
		}
	}
	else if (sym->kind == (v__ast__Kind_array)) {
		Option_void _t2263 = v__checker__Checker_ensure_type_exists(c, (/* as */ *(v__ast__Array*)__as_cast((sym->info)._v__ast__Array,(sym->info)._typ, 395) /*expected idx: 395, name: v.ast.Array */ ).elem_type, pos);
		if (_t2263.state != 0 && _t2263.err._typ != _IError_None___index) {
			Option_void _t2264;
			memcpy(&_t2264, &_t2263, sizeof(Option));
			return _t2264;
		};
	}
	else if (sym->kind == (v__ast__Kind_map)) {
		v__ast__Map info = /* as */ *(v__ast__Map*)__as_cast((sym->info)._v__ast__Map,(sym->info)._typ, 396) /*expected idx: 396, name: v.ast.Map */ ;
		Option_void _t2265 = v__checker__Checker_ensure_type_exists(c, info.key_type, pos);
		if (_t2265.state != 0 && _t2265.err._typ != _IError_None___index) {
			Option_void _t2266;
			memcpy(&_t2266, &_t2265, sizeof(Option));
			return _t2266;
		};
		Option_void _t2267 = v__checker__Checker_ensure_type_exists(c, info.value_type, pos);
		if (_t2267.state != 0 && _t2267.err._typ != _IError_None___index) {
			Option_void _t2268;
			memcpy(&_t2268, &_t2267, sizeof(Option));
			return _t2268;
		};
	}
	else {
	};
	return (Option_void){0};
}

VV_LOCAL_SYMBOL v__ast__Stmt v__parser__Parser_assign_stmt(v__parser__Parser* p) {
	multi_return_Array_v__ast__Expr_Array_v__ast__Comment mr_259 = v__parser__Parser_expr_list(p);
	Array_v__ast__Expr exprs = mr_259.arg0;
	Array_v__ast__Comment comments = mr_259.arg1;
	 v__ast__Stmt _t2269 = v__parser__Parser_partial_assign_stmt(p, exprs, comments);
	// autofree_scope_vars(pos=276 line_nr=9 scope.pos=202 scope.end_pos=323)
	// var "p" var.pos=207 var.line_nr=7
	// var "exprs" var.pos=243 var.line_nr=8
	// var "comments" var.pos=250 var.line_nr=8
	// af parent scope:
	// af parent scope:
	return _t2269;
}

VV_LOCAL_SYMBOL Option_void v__parser__Parser_check_undefined_variables(v__parser__Parser* p, Array_v__ast__Expr exprs, v__ast__Expr val) {
	if (val._typ == 254 /* v.ast.Ident */) {
		// FOR IN array
		for (int _t2270 = 0; _t2270 < exprs.len; ++_t2270) {
			v__ast__Expr expr = ((v__ast__Expr*)exprs.data)[_t2270];
			if ((expr)._typ == 254 /* v.ast.Ident */) {
				if (string_eq((*expr._v__ast__Ident).name, (*val._v__ast__Ident).name)) {
					v__parser__Parser_error_with_pos(p, _STR("undefined variable: `%.*s\000`", 2, (*val._v__ast__Ident).name), (*val._v__ast__Ident).pos);
					return (Option_void){ .state=2, .err=v_error(_STR("undefined variable: `%.*s\000`", 2, (*val._v__ast__Ident).name)) };
				}
			}
		}
	}
	else if (val._typ == 241 /* v.ast.CallExpr */) {
		Option_void _t2271 = v__parser__Parser_check_undefined_variables(p, exprs, (*val._v__ast__CallExpr).left);
		if (_t2271.state != 0 && _t2271.err._typ != _IError_None___index) {
			Option_void _t2272;
			memcpy(&_t2272, &_t2271, sizeof(Option));
			return _t2272;
		};
		// FOR IN array
		for (int _t2273 = 0; _t2273 < (*val._v__ast__CallExpr).args.len; ++_t2273) {
			v__ast__CallArg arg = ((v__ast__CallArg*)(*val._v__ast__CallExpr).args.data)[_t2273];
			Option_void _t2274 = v__parser__Parser_check_undefined_variables(p, exprs, arg.expr);
			if (_t2274.state != 0 && _t2274.err._typ != _IError_None___index) {
				Option_void _t2275;
				memcpy(&_t2275, &_t2274, sizeof(Option));
				return _t2275;
			};
		}
	}
	else if (val._typ == 258 /* v.ast.InfixExpr */) {
		Option_void _t2276 = v__parser__Parser_check_undefined_variables(p, exprs, (*val._v__ast__InfixExpr).left);
		if (_t2276.state != 0 && _t2276.err._typ != _IError_None___index) {
			Option_void _t2277;
			memcpy(&_t2277, &_t2276, sizeof(Option));
			return _t2277;
		};
		Option_void _t2278 = v__parser__Parser_check_undefined_variables(p, exprs, (*val._v__ast__InfixExpr).right);
		if (_t2278.state != 0 && _t2278.err._typ != _IError_None___index) {
			Option_void _t2279;
			memcpy(&_t2279, &_t2278, sizeof(Option));
			return _t2279;
		};
	}
	else if (val._typ == 268 /* v.ast.ParExpr */) {
		Option_void _t2280 = v__parser__Parser_check_undefined_variables(p, exprs, (*val._v__ast__ParExpr).expr);
		if (_t2280.state != 0 && _t2280.err._typ != _IError_None___index) {
			Option_void _t2281;
			memcpy(&_t2281, &_t2280, sizeof(Option));
			return _t2281;
		};
	}
	else if (val._typ == 269 /* v.ast.PostfixExpr */) {
		Option_void _t2282 = v__parser__Parser_check_undefined_variables(p, exprs, (*val._v__ast__PostfixExpr).expr);
		if (_t2282.state != 0 && _t2282.err._typ != _IError_None___index) {
			Option_void _t2283;
			memcpy(&_t2283, &_t2282, sizeof(Option));
			return _t2283;
		};
	}
	else if (val._typ == 270 /* v.ast.PrefixExpr */) {
		Option_void _t2284 = v__parser__Parser_check_undefined_variables(p, exprs, (*val._v__ast__PrefixExpr).right);
		if (_t2284.state != 0 && _t2284.err._typ != _IError_None___index) {
			Option_void _t2285;
			memcpy(&_t2285, &_t2284, sizeof(Option));
			return _t2285;
		};
	}
	else if (val._typ == 276 /* v.ast.StringInterLiteral */) {
		// FOR IN array
		for (int _t2286 = 0; _t2286 < (*val._v__ast__StringInterLiteral).exprs.len; ++_t2286) {
			v__ast__Expr expr_ = ((v__ast__Expr*)(*val._v__ast__StringInterLiteral).exprs.data)[_t2286];
			Option_void _t2287 = v__parser__Parser_check_undefined_variables(p, exprs, expr_);
			if (_t2287.state != 0 && _t2287.err._typ != _IError_None___index) {
				Option_void _t2288;
				memcpy(&_t2288, &_t2287, sizeof(Option));
				return _t2288;
			};
		}
	}
	else {
	};
	return (Option_void){0};
}

VV_LOCAL_SYMBOL bool v__parser__Parser_check_cross_variables(v__parser__Parser* p, Array_v__ast__Expr exprs, v__ast__Expr val) {
	v__ast__Expr val_ = val;
	if (val_._typ == 254 /* v.ast.Ident */) {
		// FOR IN array
		for (int _t2289 = 0; _t2289 < exprs.len; ++_t2289) {
			v__ast__Expr expr = ((v__ast__Expr*)exprs.data)[_t2289];
			if ((expr)._typ == 254 /* v.ast.Ident */) {
				if (string_eq((*expr._v__ast__Ident).name, (*val_._v__ast__Ident).name)) {
					 bool _t2290 = true;
					// autofree_scope_vars(pos=1487 line_nr=59 scope.pos=1480 scope.end_pos=1505)
					// af parent scope:
					// var "expr" var.pos=1429 var.line_nr=57
					// af parent scope:
					// var "expr" var.pos=1406 var.line_nr=56
					// skipping tmp var "expr"
					// af parent scope:
					// var "val_" var.pos=1378 var.line_nr=54
					// af parent scope:
					// var "p" var.pos=1287 var.line_nr=52
					// var "exprs" var.pos=1319 var.line_nr=52
					// var "val" var.pos=1337 var.line_nr=52
					// var "val_" var.pos=1359 var.line_nr=53
					// af parent scope:
					// af parent scope:
					return _t2290;
				}
			}
		}
	}
	else if (val_._typ == 257 /* v.ast.IndexExpr */) {
		// FOR IN array
		for (int _t2291 = 0; _t2291 < exprs.len; ++_t2291) {
			v__ast__Expr expr = ((v__ast__Expr*)exprs.data)[_t2291];
			if (string_eq(v__ast__Expr_str(expr), v__ast__Expr_str(val))) {
				 bool _t2292 = true;
				// autofree_scope_vars(pos=1600 line_nr=67 scope.pos=1594 scope.end_pos=1617)
				// af parent scope:
				// var "expr" var.pos=1547 var.line_nr=65
				// skipping tmp var "expr"
				// af parent scope:
				// var "val_" var.pos=1378 var.line_nr=54
				// af parent scope:
				// var "p" var.pos=1287 var.line_nr=52
				// var "exprs" var.pos=1319 var.line_nr=52
				// var "val" var.pos=1337 var.line_nr=52
				// var "val_" var.pos=1359 var.line_nr=53
				// af parent scope:
				// af parent scope:
				return _t2292;
			}
		}
	}
	else if (val_._typ == 258 /* v.ast.InfixExpr */) {
		 bool _t2293 = v__parser__Parser_check_cross_variables(p, exprs, (*val_._v__ast__InfixExpr).left) || v__parser__Parser_check_cross_variables(p, exprs, (*val_._v__ast__InfixExpr).right);
		// autofree_scope_vars(pos=1648 line_nr=72 scope.pos=1630 scope.end_pos=1750)
		// var "val_" var.pos=1378 var.line_nr=54
		// af parent scope:
		// var "p" var.pos=1287 var.line_nr=52
		// var "exprs" var.pos=1319 var.line_nr=52
		// var "val" var.pos=1337 var.line_nr=52
		// var "val_" var.pos=1359 var.line_nr=53
		// af parent scope:
		// af parent scope:
		return _t2293;
	}
	else if (val_._typ == 270 /* v.ast.PrefixExpr */) {
		 bool _t2294 = v__parser__Parser_check_cross_variables(p, exprs, (*val_._v__ast__PrefixExpr).right);
		// autofree_scope_vars(pos=1773 line_nr=76 scope.pos=1754 scope.end_pos=1826)
		// var "val_" var.pos=1378 var.line_nr=54
		// af parent scope:
		// var "p" var.pos=1287 var.line_nr=52
		// var "exprs" var.pos=1319 var.line_nr=52
		// var "val" var.pos=1337 var.line_nr=52
		// var "val_" var.pos=1359 var.line_nr=53
		// af parent scope:
		// af parent scope:
		return _t2294;
	}
	else if (val_._typ == 269 /* v.ast.PostfixExpr */) {
		 bool _t2295 = v__parser__Parser_check_cross_variables(p, exprs, (*val_._v__ast__PostfixExpr).expr);
		// autofree_scope_vars(pos=1850 line_nr=79 scope.pos=1830 scope.end_pos=1902)
		// var "val_" var.pos=1378 var.line_nr=54
		// af parent scope:
		// var "p" var.pos=1287 var.line_nr=52
		// var "exprs" var.pos=1319 var.line_nr=52
		// var "val" var.pos=1337 var.line_nr=52
		// var "val_" var.pos=1359 var.line_nr=53
		// af parent scope:
		// af parent scope:
		return _t2295;
	}
	else if (val_._typ == 273 /* v.ast.SelectorExpr */) {
		// FOR IN array
		for (int _t2296 = 0; _t2296 < exprs.len; ++_t2296) {
			v__ast__Expr expr = ((v__ast__Expr*)exprs.data)[_t2296];
			if (string_eq(v__ast__Expr_str(expr), v__ast__Expr_str(val))) {
				 bool _t2297 = true;
				// autofree_scope_vars(pos=1985 line_nr=84 scope.pos=1979 scope.end_pos=2002)
				// af parent scope:
				// var "expr" var.pos=1932 var.line_nr=82
				// skipping tmp var "expr"
				// af parent scope:
				// var "val_" var.pos=1378 var.line_nr=54
				// af parent scope:
				// var "p" var.pos=1287 var.line_nr=52
				// var "exprs" var.pos=1319 var.line_nr=52
				// var "val" var.pos=1337 var.line_nr=52
				// var "val_" var.pos=1359 var.line_nr=53
				// af parent scope:
				// af parent scope:
				return _t2297;
			}
		}
	}
	else {
	};
	 bool _t2298 = false;
	// autofree_scope_vars(pos=2026 line_nr=90 scope.pos=1282 scope.end_pos=2040)
	// var "p" var.pos=1287 var.line_nr=52
	// var "exprs" var.pos=1319 var.line_nr=52
	// var "val" var.pos=1337 var.line_nr=52
	// var "val_" var.pos=1359 var.line_nr=53
	// af parent scope:
	// af parent scope:
	return _t2298;
}

VV_LOCAL_SYMBOL v__ast__Stmt v__parser__Parser_partial_assign_stmt(v__parser__Parser* p, Array_v__ast__Expr left, Array_v__ast__Comment left_comments) {
	p->is_stmt_ident = false;
	v__token__Kind op = p->tok.kind;
	v__token__Position pos = v__token__Token_position(&p->tok);
	v__parser__Parser_next(p);
	Array_v__ast__Comment comments = __new_array_with_default(0, 2 * left_comments.len + 1, sizeof(v__ast__Comment), 0);
	_PUSH_MANY(&comments, (left_comments), _t2299, Array_v__ast__Comment);
	_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,})), _t2300, Array_v__ast__Comment);
	Array_v__ast__Comment right_comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	Array_v__ast__Expr right = __new_array_with_default(0, left.len, sizeof(v__ast__Expr), 0);
	multi_return_Array_v__ast__Expr_Array_v__ast__Comment mr_2444 = v__parser__Parser_expr_list(p);
	right = mr_2444.arg0;
	right_comments = mr_2444.arg1;
	_PUSH_MANY(&comments, (right_comments), _t2301, Array_v__ast__Comment);
	Array_v__ast__Comment end_comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = true,.follow_up = 0,});
	bool has_cross_var = false;
	if (op == v__token__Kind_decl_assign) {
		// FOR IN array
		for (int _t2302 = 0; _t2302 < right.len; ++_t2302) {
			v__ast__Expr r = ((v__ast__Expr*)right.data)[_t2302];
			Option_void _t2303 = v__parser__Parser_check_undefined_variables(p, left, r);
			if (_t2303.state != 0 && _t2303.err._typ != _IError_None___index) {
				IError err = _t2303.err;
				 v__ast__Stmt _t2304 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error(p, _SLIT("check_undefined_variables failed")))));
				// autofree_scope_vars(pos=2679 line_nr=111 scope.pos=2674 scope.end_pos=2734)
				// var "err" var.pos=2674 var.line_nr=110
				// af parent scope:
				// var "r" var.pos=2618 var.line_nr=109
				// skipping tmp var "r"
				// af parent scope:
				// af parent scope:
				// var "p" var.pos=2051 var.line_nr=93
				// var "left" var.pos=2081 var.line_nr=93
				// var "left_comments" var.pos=2098 var.line_nr=93
				// var "op" var.pos=2164 var.line_nr=95
				// var "pos" var.pos=2186 var.line_nr=96
				// var "comments" var.pos=2225 var.line_nr=98
				// var "right_comments" var.pos=2347 var.line_nr=101
				// var "right" var.pos=2386 var.line_nr=102
				// var "end_comments" var.pos=2489 var.line_nr=105
				// var "has_cross_var" var.pos=2542 var.line_nr=106
				// var "is_static" var.pos=3037 var.line_nr=127
				// af parent scope:
				// af parent scope:
				return _t2304;
			};
		}
	} else if (left.len > 1) {
		// FOR IN array
		for (int _t2305 = 0; _t2305 < right.len; ++_t2305) {
			v__ast__Expr r = ((v__ast__Expr*)right.data)[_t2305];
			has_cross_var = v__parser__Parser_check_cross_variables(p, left, r);
			if (!(op == v__token__Kind_assign || op == v__token__Kind_decl_assign)) {
				 v__ast__Stmt _t2306 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _STR("unexpected %.*s\000, expecting := or = or comma", 2, v__token__Kind_str(op)), pos))));
				// autofree_scope_vars(pos=2896 line_nr=119 scope.pos=2891 scope.end_pos=2986)
				// af parent scope:
				// var "r" var.pos=2789 var.line_nr=116
				// skipping tmp var "r"
				// af parent scope:
				// af parent scope:
				// var "p" var.pos=2051 var.line_nr=93
				// var "left" var.pos=2081 var.line_nr=93
				// var "left_comments" var.pos=2098 var.line_nr=93
				// var "op" var.pos=2164 var.line_nr=95
				// var "pos" var.pos=2186 var.line_nr=96
				// var "comments" var.pos=2225 var.line_nr=98
				// var "right_comments" var.pos=2347 var.line_nr=101
				// var "right" var.pos=2386 var.line_nr=102
				// var "end_comments" var.pos=2489 var.line_nr=105
				// var "has_cross_var" var.pos=2542 var.line_nr=106
				// var "is_static" var.pos=3037 var.line_nr=127
				// af parent scope:
				// af parent scope:
				return _t2306;
			}
			if (has_cross_var) {
				break;
			}
		}
	}
	bool is_static = false;
	// FOR IN array
	for (int i = 0; i < left.len; ++i) {
		v__ast__Expr lx = ((v__ast__Expr*)left.data)[i];
		if (lx._typ == 254 /* v.ast.Ident */) {
			if (op == v__token__Kind_decl_assign) {
				if (v__ast__Scope_known_var(p->scope, (*lx._v__ast__Ident).name)) {
					 v__ast__Stmt _t2307 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _STR("redefinition of `%.*s\000`", 2, (*lx._v__ast__Ident).name), (*lx._v__ast__Ident).pos))));
					// autofree_scope_vars(pos=3179 line_nr=133 scope.pos=3172 scope.end_pos=3247)
					// af parent scope:
					// var "share" var.pos=3258 var.line_nr=135
					// var "r0" var.pos=3652 var.line_nr=147
					// var "v" var.pos=3676 var.line_nr=148
					// var "obj" var.pos=4273 var.line_nr=166
					// af parent scope:
					// var "lx" var.pos=3089 var.line_nr=129
					// af parent scope:
					// var "i" var.pos=3061 var.line_nr=128
					// skipping tmp var "i"
					// var "lx" var.pos=3064 var.line_nr=128
					// skipping tmp var "lx"
					// af parent scope:
					// var "p" var.pos=2051 var.line_nr=93
					// var "left" var.pos=2081 var.line_nr=93
					// var "left_comments" var.pos=2098 var.line_nr=93
					// var "op" var.pos=2164 var.line_nr=95
					// var "pos" var.pos=2186 var.line_nr=96
					// var "comments" var.pos=2225 var.line_nr=98
					// var "right_comments" var.pos=2347 var.line_nr=101
					// var "right" var.pos=2386 var.line_nr=102
					// var "end_comments" var.pos=2489 var.line_nr=105
					// var "has_cross_var" var.pos=2542 var.line_nr=106
					// var "is_static" var.pos=3037 var.line_nr=127
					// af parent scope:
					// af parent scope:
					return _t2307;
				}
				v__ast__ShareType share = ((v__ast__ShareType)(0));
				if (((*lx._v__ast__Ident).info)._typ == 363 /* v.ast.IdentVar */) {
					v__ast__IdentVar iv = /* as */ *(v__ast__IdentVar*)__as_cast(((*lx._v__ast__Ident).info)._v__ast__IdentVar,((*lx._v__ast__Ident).info)._typ, 363) /*expected idx: 363, name: v.ast.IdentVar */ ;
					share = iv.share;
					if (iv.is_static) {
						if (!p->pref->translated && !p->pref->is_fmt && !p->inside_unsafe_fn) {
							 v__ast__Stmt _t2308 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _SLIT("static variables are supported only in -translated mode or in [unsafe] fn"), (*lx._v__ast__Ident).pos))));
							// autofree_scope_vars(pos=3480 line_nr=141 scope.pos=3471 scope.end_pos=3606)
							// af parent scope:
							// af parent scope:
							// var "iv" var.pos=3324 var.line_nr=137
							// af parent scope:
							// var "share" var.pos=3258 var.line_nr=135
							// var "r0" var.pos=3652 var.line_nr=147
							// var "v" var.pos=3676 var.line_nr=148
							// var "obj" var.pos=4273 var.line_nr=166
							// af parent scope:
							// var "lx" var.pos=3089 var.line_nr=129
							// af parent scope:
							// var "i" var.pos=3061 var.line_nr=128
							// skipping tmp var "i"
							// var "lx" var.pos=3064 var.line_nr=128
							// skipping tmp var "lx"
							// af parent scope:
							// var "p" var.pos=2051 var.line_nr=93
							// var "left" var.pos=2081 var.line_nr=93
							// var "left_comments" var.pos=2098 var.line_nr=93
							// var "op" var.pos=2164 var.line_nr=95
							// var "pos" var.pos=2186 var.line_nr=96
							// var "comments" var.pos=2225 var.line_nr=98
							// var "right_comments" var.pos=2347 var.line_nr=101
							// var "right" var.pos=2386 var.line_nr=102
							// var "end_comments" var.pos=2489 var.line_nr=105
							// var "has_cross_var" var.pos=2542 var.line_nr=106
							// var "is_static" var.pos=3037 var.line_nr=127
							// af parent scope:
							// af parent scope:
							return _t2308;
						}
						is_static = true;
					}
				}
				v__ast__Expr r0 = (*(v__ast__Expr*)/*ee elem_typ */array_get(right, 0));
				v__ast__Var v = (v__ast__Var){.name = (*lx._v__ast__Ident).name,.expr = (left.len == right.len ? ((*(v__ast__Expr*)/*ee elem_typ */array_get(right, i))) : (v__ast__empty_expr())),.share = share,.is_mut = (*lx._v__ast__Ident).is_mut || p->inside_for,.is_autofree_tmp = 0,.is_arg = 0,.is_auto_deref = 0,.typ = 0,.orig_type = 0,.smartcasts = __new_array(0, 1, sizeof(v__ast__Type)),.pos = (*lx._v__ast__Ident).pos,.is_used = 0,.is_changed = 0,.is_or = 0,.is_tmp = 0,};
				if (p->pref->autofree) {
					if ((r0)._typ == 241 /* v.ast.CallExpr */) {
						if ((*r0._v__ast__CallExpr).or_block.pos.pos > 0 && (*r0._v__ast__CallExpr).or_block.stmts.len > 0) {
							v.is_or = true;
						}
					}
				}
				v__ast__ScopeObject obj = v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, (v)));
				(*lx._v__ast__Ident).obj = obj;
				v__ast__Scope_register(p->scope, obj);
			}
		}
		else if (lx._typ == 257 /* v.ast.IndexExpr */) {
			if (op == v__token__Kind_decl_assign) {
				 v__ast__Stmt _t2309 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _STR("non-name `%.*s\000[%.*s\000]` on left side of `:=`", 3, v__ast__Expr_str((*lx._v__ast__IndexExpr).left), v__ast__Expr_str((*lx._v__ast__IndexExpr).index)), (*lx._v__ast__IndexExpr).pos))));
				// autofree_scope_vars(pos=4406 line_nr=173 scope.pos=4400 scope.end_pos=4504)
				// af parent scope:
				// var "lx" var.pos=3089 var.line_nr=129
				// af parent scope:
				// var "i" var.pos=3061 var.line_nr=128
				// skipping tmp var "i"
				// var "lx" var.pos=3064 var.line_nr=128
				// skipping tmp var "lx"
				// af parent scope:
				// var "p" var.pos=2051 var.line_nr=93
				// var "left" var.pos=2081 var.line_nr=93
				// var "left_comments" var.pos=2098 var.line_nr=93
				// var "op" var.pos=2164 var.line_nr=95
				// var "pos" var.pos=2186 var.line_nr=96
				// var "comments" var.pos=2225 var.line_nr=98
				// var "right_comments" var.pos=2347 var.line_nr=101
				// var "right" var.pos=2386 var.line_nr=102
				// var "end_comments" var.pos=2489 var.line_nr=105
				// var "has_cross_var" var.pos=2542 var.line_nr=106
				// var "is_static" var.pos=3037 var.line_nr=127
				// af parent scope:
				// af parent scope:
				return _t2309;
			}
			(*lx._v__ast__IndexExpr).is_setter = true;
		}
		else if (lx._typ == 268 /* v.ast.ParExpr */) {
		}
		else if (lx._typ == 270 /* v.ast.PrefixExpr */) {
		}
		else if (lx._typ == 273 /* v.ast.SelectorExpr */) {
			if (op == v__token__Kind_decl_assign) {
				 v__ast__Stmt _t2310 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _SLIT("struct fields can only be declared during the initialization"), (*lx._v__ast__SelectorExpr).pos))));
				// autofree_scope_vars(pos=4628 line_nr=182 scope.pos=4622 scope.end_pos=4735)
				// af parent scope:
				// var "lx" var.pos=3089 var.line_nr=129
				// af parent scope:
				// var "i" var.pos=3061 var.line_nr=128
				// skipping tmp var "i"
				// var "lx" var.pos=3064 var.line_nr=128
				// skipping tmp var "lx"
				// af parent scope:
				// var "p" var.pos=2051 var.line_nr=93
				// var "left" var.pos=2081 var.line_nr=93
				// var "left_comments" var.pos=2098 var.line_nr=93
				// var "op" var.pos=2164 var.line_nr=95
				// var "pos" var.pos=2186 var.line_nr=96
				// var "comments" var.pos=2225 var.line_nr=98
				// var "right_comments" var.pos=2347 var.line_nr=101
				// var "right" var.pos=2386 var.line_nr=102
				// var "end_comments" var.pos=2489 var.line_nr=105
				// var "has_cross_var" var.pos=2542 var.line_nr=106
				// var "is_static" var.pos=3037 var.line_nr=127
				// af parent scope:
				// af parent scope:
				return _t2310;
			}
		}
		else {
		};
	}
	v__token__Position_update_last_line(&pos, p->prev_tok.line_nr);
	 v__ast__Stmt _t2311 = v__ast__AssignStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__AssignStmt, ((v__ast__AssignStmt){
		.op = op,
		.pos = pos,
		.comments = comments,
		.end_comments = end_comments,
		.right = right,
		.left = left,
		.left_types = __new_array(0, 1, sizeof(v__ast__Type)),
		.right_types = __new_array(0, 1, sizeof(v__ast__Type)),
		.is_static = is_static,
		.is_simple = p->inside_for && p->tok.kind == v__token__Kind_lcbr,
		.has_cross_var = has_cross_var,
	})));
	// autofree_scope_vars(pos=4919 line_nr=193 scope.pos=2046 scope.end_pos=5147)
	// var "p" var.pos=2051 var.line_nr=93
	// var "left" var.pos=2081 var.line_nr=93
	// var "left_comments" var.pos=2098 var.line_nr=93
	// var "op" var.pos=2164 var.line_nr=95
	// var "pos" var.pos=2186 var.line_nr=96
	// var "comments" var.pos=2225 var.line_nr=98
	// var "right_comments" var.pos=2347 var.line_nr=101
	// var "right" var.pos=2386 var.line_nr=102
	// var "end_comments" var.pos=2489 var.line_nr=105
	// var "has_cross_var" var.pos=2542 var.line_nr=106
	// var "is_static" var.pos=3037 var.line_nr=127
	// af parent scope:
	// af parent scope:
	return _t2311;
}

VV_LOCAL_SYMBOL v__ast__HashStmt v__parser__Parser_hash(v__parser__Parser* p) {
	v__token__Position pos = v__token__Token_position(&p->tok);
	string val = p->tok.lit;
	string kind = string_all_before(val, _SLIT(" "));
	v__parser__Parser_next(p);
	string main_str = _SLIT("");
	string msg = _SLIT("");
	string content = string_all_before(string_all_after(val, _STR("%.*s\000 ", 2, kind)), _SLIT("//"));
	if (string_contains(content, _SLIT(" #"))) {
		main_str = string_trim_space(string_all_before(content, _SLIT(" #")));
		msg = string_trim_space(string_all_after(content, _SLIT(" #")));
	} else {
		main_str = string_trim_space(content);
		msg = _SLIT("");
	}
	 v__ast__HashStmt _t2312 = (v__ast__HashStmt){
		.mod = p->mod,
		.pos = pos,
		.source_file = p->file_name,
		.val = val,
		.kind = kind,
		.main = main_str,
		.msg = msg,
	};
	// autofree_scope_vars(pos=734 line_nr=30 scope.pos=344 scope.end_pos=862)
	// var "p" var.pos=349 var.line_nr=15
	// var "pos" var.pos=382 var.line_nr=16
	// var "val" var.pos=407 var.line_nr=17
	// var "kind" var.pos=425 var.line_nr=18
	// var "main_str" var.pos=468 var.line_nr=20
	// str literal
	// var "msg" var.pos=488 var.line_nr=21
	// str literal
	// var "content" var.pos=499 var.line_nr=22
	// af parent scope:
	// af parent scope:
	return _t2312;
}

VV_LOCAL_SYMBOL v__ast__ComptimeCall v__parser__Parser_comp_call(v__parser__Parser* p) {
	v__ast__ComptimeCall err_node = (v__ast__ComptimeCall){.pos = {0},.has_parens = 0,.method_name = (string){.str=(byteptr)"", .is_lit=1},.method_pos = {0},.scope = 0,.left = {0},.args_var = (string){.str=(byteptr)"", .is_lit=1},.is_vweb = 0,.vweb_tmpl = (v__ast__File){.stmts = __new_array(0, 1, sizeof(v__ast__Stmt)),.imports = __new_array(0, 1, sizeof(v__ast__Import)),.auto_imports = __new_array(0, 1, sizeof(string)),.embedded_files = __new_array(0, 1, sizeof(v__ast__EmbeddedFile)),.imported_symbols = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.errors = __new_array(0, 1, sizeof(v__errors__Error)),.warnings = __new_array(0, 1, sizeof(v__errors__Warning)),.notices = __new_array(0, 1, sizeof(v__errors__Notice)),.generic_fns = __new_array(0, 1, sizeof(v__ast__FnDecl*)),.global_labels = __new_array(0, 1, sizeof(string)),},.is_embed = 0,.embed_file = {0},.is_env = 0,.env_pos = {0},.sym = (v__ast__TypeSymbol){.methods = __new_array(0, 1, sizeof(v__ast__Fn)),},.result_type = 0,.env_value = (string){.str=(byteptr)"", .is_lit=1},.args = __new_array(0, 1, sizeof(v__ast__CallArg)),};
	v__parser__Parser_check(p, v__token__Kind_dollar);
	v__token__Position start_pos = v__token__Token_position(&p->prev_tok);
	string error_msg = _SLIT("only `$tmpl()`, `$env()`, `$embed_file()` and `$vweb.html()` comptime functions are supported right now");
	if (p->peek_tok.kind == v__token__Kind_dot) {
		string n = v__parser__Parser_check_name(p);
		if (string_ne(n, _SLIT("vweb"))) {
			v__parser__Parser_error(p, error_msg);
			// autofree_scope_vars(pos=1259 line_nr=52 scope.pos=1233 scope.end_pos=1278)
			// af parent scope:
			// var "n" var.pos=1169 var.line_nr=49
			// af parent scope:
			// var "p" var.pos=873 var.line_nr=41
			// var "err_node" var.pos=915 var.line_nr=42
			// var "start_pos" var.pos=978 var.line_nr=46
			// var "error_msg" var.pos=1014 var.line_nr=47
			// str literal
			// var "n" var.pos=1300 var.line_nr=56
			// var "is_embed_file" var.pos=1418 var.line_nr=61
			// var "is_html" var.pos=1454 var.line_nr=62
			// var "spos" var.pos=1788 var.line_nr=80
			// var "literal_string_param" var.pos=1814 var.line_nr=81
			// var "path_of_literal_string_param" var.pos=1876 var.line_nr=82
			// var "fn_path" var.pos=3243 var.line_nr=129
			// var "fn_path_joined" var.pos=3280 var.line_nr=130
			// var "compiled_vfile_path" var.pos=3331 var.line_nr=131
			// var "tmpl_path" var.pos=3421 var.line_nr=132
			// var "dir" var.pos=3550 var.line_nr=134
			// var "path" var.pos=3590 var.line_nr=135
			// var "tmp_fn_name" var.pos=4262 var.line_nr=165
			// var "v_code" var.pos=4413 var.line_nr=169
			// var "scope" var.pos=4609 var.line_nr=176
			// var "file" var.pos=4825 var.line_nr=187
			// af parent scope:
			// af parent scope:
			return err_node;
		}
		v__parser__Parser_check(p, v__token__Kind_dot);
	}
	string n = v__parser__Parser_check_name(p);
	if (!(Array_string_contains(_const_v__parser__supported_comptime_calls, n))) {
		v__parser__Parser_error(p, error_msg);
		// autofree_scope_vars(pos=1397 line_nr=59 scope.pos=1373 scope.end_pos=1415)
		// af parent scope:
		// var "p" var.pos=873 var.line_nr=41
		// var "err_node" var.pos=915 var.line_nr=42
		// var "start_pos" var.pos=978 var.line_nr=46
		// var "error_msg" var.pos=1014 var.line_nr=47
		// str literal
		// var "n" var.pos=1300 var.line_nr=56
		// var "is_embed_file" var.pos=1418 var.line_nr=61
		// var "is_html" var.pos=1454 var.line_nr=62
		// var "spos" var.pos=1788 var.line_nr=80
		// var "literal_string_param" var.pos=1814 var.line_nr=81
		// var "path_of_literal_string_param" var.pos=1876 var.line_nr=82
		// var "fn_path" var.pos=3243 var.line_nr=129
		// var "fn_path_joined" var.pos=3280 var.line_nr=130
		// var "compiled_vfile_path" var.pos=3331 var.line_nr=131
		// var "tmpl_path" var.pos=3421 var.line_nr=132
		// var "dir" var.pos=3550 var.line_nr=134
		// var "path" var.pos=3590 var.line_nr=135
		// var "tmp_fn_name" var.pos=4262 var.line_nr=165
		// var "v_code" var.pos=4413 var.line_nr=169
		// var "scope" var.pos=4609 var.line_nr=176
		// var "file" var.pos=4825 var.line_nr=187
		// af parent scope:
		// af parent scope:
		return err_node;
	}
	bool is_embed_file = string_eq(n, _SLIT("embed_file"));
	bool is_html = string_eq(n, _SLIT("html"));
	if (string_eq(n, _SLIT("env"))) {
		v__parser__Parser_check(p, v__token__Kind_lpar);
		v__token__Position spos = v__token__Token_position(&p->tok);
		string s = p->tok.lit;
		v__parser__Parser_check(p, v__token__Kind_string);
		v__parser__Parser_check(p, v__token__Kind_rpar);
		 v__ast__ComptimeCall _t2313 = (v__ast__ComptimeCall){
			.pos = v__token__Position_extend(spos, v__token__Token_position(&p->prev_tok)),
			.has_parens = 0,
			.method_name = n,
			.method_pos = {0},
			.scope = 0,
			.left = {0},
			.args_var = s,
			.is_vweb = 0,
			.vweb_tmpl = (v__ast__File){.stmts = __new_array(0, 1, sizeof(v__ast__Stmt)),.imports = __new_array(0, 1, sizeof(v__ast__Import)),.auto_imports = __new_array(0, 1, sizeof(string)),.embedded_files = __new_array(0, 1, sizeof(v__ast__EmbeddedFile)),.imported_symbols = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.errors = __new_array(0, 1, sizeof(v__errors__Error)),.warnings = __new_array(0, 1, sizeof(v__errors__Warning)),.notices = __new_array(0, 1, sizeof(v__errors__Notice)),.generic_fns = __new_array(0, 1, sizeof(v__ast__FnDecl*)),.global_labels = __new_array(0, 1, sizeof(string)),},
			.is_embed = 0,
			.embed_file = {0},
			.is_env = true,
			.env_pos = spos,
			.sym = (v__ast__TypeSymbol){.methods = __new_array(0, 1, sizeof(v__ast__Fn)),},
			.result_type = 0,
			.env_value = (string){.str=(byteptr)"", .is_lit=1},
			.args = __new_array(0, 1, sizeof(v__ast__CallArg)),
		};
		// autofree_scope_vars(pos=1617 line_nr=70 scope.pos=1517 scope.end_pos=1769)
		// var "spos" var.pos=1538 var.line_nr=66
		// var "s" var.pos=1565 var.line_nr=67
		// af parent scope:
		// var "p" var.pos=873 var.line_nr=41
		// var "err_node" var.pos=915 var.line_nr=42
		// var "start_pos" var.pos=978 var.line_nr=46
		// var "error_msg" var.pos=1014 var.line_nr=47
		// str literal
		// var "n" var.pos=1300 var.line_nr=56
		// var "is_embed_file" var.pos=1418 var.line_nr=61
		// var "is_html" var.pos=1454 var.line_nr=62
		// var "spos" var.pos=1788 var.line_nr=80
		// var "literal_string_param" var.pos=1814 var.line_nr=81
		// var "path_of_literal_string_param" var.pos=1876 var.line_nr=82
		// var "fn_path" var.pos=3243 var.line_nr=129
		// var "fn_path_joined" var.pos=3280 var.line_nr=130
		// var "compiled_vfile_path" var.pos=3331 var.line_nr=131
		// var "tmpl_path" var.pos=3421 var.line_nr=132
		// var "dir" var.pos=3550 var.line_nr=134
		// var "path" var.pos=3590 var.line_nr=135
		// var "tmp_fn_name" var.pos=4262 var.line_nr=165
		// var "v_code" var.pos=4413 var.line_nr=169
		// var "scope" var.pos=4609 var.line_nr=176
		// var "file" var.pos=4825 var.line_nr=187
		// af parent scope:
		// af parent scope:
		return _t2313;
	}
	v__parser__Parser_check(p, v__token__Kind_lpar);
	v__token__Position spos = v__token__Token_position(&p->tok);
	string literal_string_param = (is_html ? (_SLIT("")) : (p->tok.lit));
	string path_of_literal_string_param = string_replace(literal_string_param, _SLIT("/"), _const_os__path_separator);
	if (!is_html) {
		v__parser__Parser_check(p, v__token__Kind_string);
	}
	v__parser__Parser_check(p, v__token__Kind_rpar);
	if (is_embed_file) {
		string epath = path_of_literal_string_param;
		if ((epath).len == 0) {
			v__parser__Parser_error_with_pos(p, _SLIT("supply a valid relative or absolute file path to the file to embed"), spos);
			// autofree_scope_vars(pos=2301 line_nr=94 scope.pos=2197 scope.end_pos=2320)
			// af parent scope:
			// var "epath" var.pos=2073 var.line_nr=89
			// af parent scope:
			// var "p" var.pos=873 var.line_nr=41
			// var "err_node" var.pos=915 var.line_nr=42
			// var "start_pos" var.pos=978 var.line_nr=46
			// var "error_msg" var.pos=1014 var.line_nr=47
			// str literal
			// var "n" var.pos=1300 var.line_nr=56
			// var "is_embed_file" var.pos=1418 var.line_nr=61
			// var "is_html" var.pos=1454 var.line_nr=62
			// var "spos" var.pos=1788 var.line_nr=80
			// var "literal_string_param" var.pos=1814 var.line_nr=81
			// var "path_of_literal_string_param" var.pos=1876 var.line_nr=82
			// var "fn_path" var.pos=3243 var.line_nr=129
			// var "fn_path_joined" var.pos=3280 var.line_nr=130
			// var "compiled_vfile_path" var.pos=3331 var.line_nr=131
			// var "tmpl_path" var.pos=3421 var.line_nr=132
			// var "dir" var.pos=3550 var.line_nr=134
			// var "path" var.pos=3590 var.line_nr=135
			// var "tmp_fn_name" var.pos=4262 var.line_nr=165
			// var "v_code" var.pos=4413 var.line_nr=169
			// var "scope" var.pos=4609 var.line_nr=176
			// var "file" var.pos=4825 var.line_nr=187
			// af parent scope:
			// af parent scope:
			return err_node;
		}
		if (!p->pref->is_fmt) {
			string abs_path = os__real_path(epath);
			if (!os__exists(abs_path)) {
				epath = os__real_path(os__join_path(os__dir(p->file_name), new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){epath}))));
				if (!os__exists(epath)) {
					v__parser__Parser_error_with_pos(p, _STR("\"%.*s\000\" does not exist so it cannot be embedded", 2, epath), spos);
					// autofree_scope_vars(pos=2669 line_nr=105 scope.pos=2577 scope.end_pos=2690)
					// af parent scope:
					// af parent scope:
					// var "abs_path" var.pos=2347 var.line_nr=97
					// af parent scope:
					// var "epath" var.pos=2073 var.line_nr=89
					// af parent scope:
					// var "p" var.pos=873 var.line_nr=41
					// var "err_node" var.pos=915 var.line_nr=42
					// var "start_pos" var.pos=978 var.line_nr=46
					// var "error_msg" var.pos=1014 var.line_nr=47
					// str literal
					// var "n" var.pos=1300 var.line_nr=56
					// var "is_embed_file" var.pos=1418 var.line_nr=61
					// var "is_html" var.pos=1454 var.line_nr=62
					// var "spos" var.pos=1788 var.line_nr=80
					// var "literal_string_param" var.pos=1814 var.line_nr=81
					// var "path_of_literal_string_param" var.pos=1876 var.line_nr=82
					// var "fn_path" var.pos=3243 var.line_nr=129
					// var "fn_path_joined" var.pos=3280 var.line_nr=130
					// var "compiled_vfile_path" var.pos=3331 var.line_nr=131
					// var "tmpl_path" var.pos=3421 var.line_nr=132
					// var "dir" var.pos=3550 var.line_nr=134
					// var "path" var.pos=3590 var.line_nr=135
					// var "tmp_fn_name" var.pos=4262 var.line_nr=165
					// var "v_code" var.pos=4413 var.line_nr=169
					// var "scope" var.pos=4609 var.line_nr=176
					// var "file" var.pos=4825 var.line_nr=187
					// af parent scope:
					// af parent scope:
					return err_node;
				}
				if (!os__is_file(epath)) {
					v__parser__Parser_error_with_pos(p, _STR("\"%.*s\000\" is not a file so it cannot be embedded", 2, epath), spos);
					// autofree_scope_vars(pos=2809 line_nr=110 scope.pos=2718 scope.end_pos=2830)
					// af parent scope:
					// af parent scope:
					// var "abs_path" var.pos=2347 var.line_nr=97
					// af parent scope:
					// var "epath" var.pos=2073 var.line_nr=89
					// af parent scope:
					// var "p" var.pos=873 var.line_nr=41
					// var "err_node" var.pos=915 var.line_nr=42
					// var "start_pos" var.pos=978 var.line_nr=46
					// var "error_msg" var.pos=1014 var.line_nr=47
					// str literal
					// var "n" var.pos=1300 var.line_nr=56
					// var "is_embed_file" var.pos=1418 var.line_nr=61
					// var "is_html" var.pos=1454 var.line_nr=62
					// var "spos" var.pos=1788 var.line_nr=80
					// var "literal_string_param" var.pos=1814 var.line_nr=81
					// var "path_of_literal_string_param" var.pos=1876 var.line_nr=82
					// var "fn_path" var.pos=3243 var.line_nr=129
					// var "fn_path_joined" var.pos=3280 var.line_nr=130
					// var "compiled_vfile_path" var.pos=3331 var.line_nr=131
					// var "tmpl_path" var.pos=3421 var.line_nr=132
					// var "dir" var.pos=3550 var.line_nr=134
					// var "path" var.pos=3590 var.line_nr=135
					// var "tmp_fn_name" var.pos=4262 var.line_nr=165
					// var "v_code" var.pos=4413 var.line_nr=169
					// var "scope" var.pos=4609 var.line_nr=176
					// var "file" var.pos=4825 var.line_nr=187
					// af parent scope:
					// af parent scope:
					return err_node;
				}
			} else {
				epath = abs_path;
			}
		}
		v__parser__Parser_register_auto_import(p, _SLIT("v.embed_file"));
		 v__ast__ComptimeCall _t2314 = (v__ast__ComptimeCall){.pos = v__token__Position_extend(start_pos, v__token__Token_position(&p->prev_tok)),.has_parens = 0,.method_name = (string){.str=(byteptr)"", .is_lit=1},.method_pos = {0},.scope = 0,.left = {0},.args_var = (string){.str=(byteptr)"", .is_lit=1},.is_vweb = 0,.vweb_tmpl = (v__ast__File){.stmts = __new_array(0, 1, sizeof(v__ast__Stmt)),.imports = __new_array(0, 1, sizeof(v__ast__Import)),.auto_imports = __new_array(0, 1, sizeof(string)),.embedded_files = __new_array(0, 1, sizeof(v__ast__EmbeddedFile)),.imported_symbols = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.errors = __new_array(0, 1, sizeof(v__errors__Error)),.warnings = __new_array(0, 1, sizeof(v__errors__Warning)),.notices = __new_array(0, 1, sizeof(v__errors__Notice)),.generic_fns = __new_array(0, 1, sizeof(v__ast__FnDecl*)),.global_labels = __new_array(0, 1, sizeof(string)),},.is_embed = true,.embed_file = (v__ast__EmbeddedFile){.rpath = literal_string_param,.apath = epath,},.is_env = 0,.env_pos = {0},.sym = (v__ast__TypeSymbol){.methods = __new_array(0, 1, sizeof(v__ast__Fn)),},.result_type = 0,.env_value = (string){.str=(byteptr)"", .is_lit=1},.args = __new_array(0, 1, sizeof(v__ast__CallArg)),};
		// autofree_scope_vars(pos=2916 line_nr=117 scope.pos=2065 scope.end_pos=3112)
		// var "epath" var.pos=2073 var.line_nr=89
		// af parent scope:
		// var "p" var.pos=873 var.line_nr=41
		// var "err_node" var.pos=915 var.line_nr=42
		// var "start_pos" var.pos=978 var.line_nr=46
		// var "error_msg" var.pos=1014 var.line_nr=47
		// str literal
		// var "n" var.pos=1300 var.line_nr=56
		// var "is_embed_file" var.pos=1418 var.line_nr=61
		// var "is_html" var.pos=1454 var.line_nr=62
		// var "spos" var.pos=1788 var.line_nr=80
		// var "literal_string_param" var.pos=1814 var.line_nr=81
		// var "path_of_literal_string_param" var.pos=1876 var.line_nr=82
		// var "fn_path" var.pos=3243 var.line_nr=129
		// var "fn_path_joined" var.pos=3280 var.line_nr=130
		// var "compiled_vfile_path" var.pos=3331 var.line_nr=131
		// var "tmpl_path" var.pos=3421 var.line_nr=132
		// var "dir" var.pos=3550 var.line_nr=134
		// var "path" var.pos=3590 var.line_nr=135
		// var "tmp_fn_name" var.pos=4262 var.line_nr=165
		// var "v_code" var.pos=4413 var.line_nr=169
		// var "scope" var.pos=4609 var.line_nr=176
		// var "file" var.pos=4825 var.line_nr=187
		// af parent scope:
		// af parent scope:
		return _t2314;
	}
	Array_string fn_path = string_split(p->cur_fn_name, _SLIT("_"));
	string fn_path_joined = Array_string_join(fn_path, _const_os__path_separator);
	string compiled_vfile_path = os__real_path(string_replace(p->scanner->file_path, _SLIT("/"), _const_os__path_separator));
	string tmpl_path = (is_html ? (_STR("%.*s\000.html", 2, (*(string*)array_last(fn_path)))) : (path_of_literal_string_param));
	string dir = os__dir(compiled_vfile_path);
	string path = os__join_path(dir, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){fn_path_joined})));
	path = /*f*/string_add(path, _SLIT(".html"));
	path = os__real_path(path);
	if (!is_html) {
		path = os__join_path(dir, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){tmpl_path})));
	}
	if (!os__exists(path)) {
		if (is_html) {
			path = os__join_path(dir, new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT("templates"), fn_path_joined})));
			path = /*f*/string_add(path, _SLIT(".html"));
		}
		if (!os__exists(path)) {
			if (p->pref->is_fmt) {
				 v__ast__ComptimeCall _t2315 = (v__ast__ComptimeCall){.pos = v__token__Position_extend(start_pos, v__token__Token_position(&p->prev_tok)),.has_parens = 0,.method_name = n,.method_pos = {0},.scope = 0,.left = {0},.args_var = (string){.str=(byteptr)"", .is_lit=1},.is_vweb = true,.vweb_tmpl = (v__ast__File){.stmts = __new_array(0, 1, sizeof(v__ast__Stmt)),.imports = __new_array(0, 1, sizeof(v__ast__Import)),.auto_imports = __new_array(0, 1, sizeof(string)),.embedded_files = __new_array(0, 1, sizeof(v__ast__EmbeddedFile)),.imported_symbols = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.errors = __new_array(0, 1, sizeof(v__errors__Error)),.warnings = __new_array(0, 1, sizeof(v__errors__Warning)),.notices = __new_array(0, 1, sizeof(v__errors__Notice)),.generic_fns = __new_array(0, 1, sizeof(v__ast__FnDecl*)),.global_labels = __new_array(0, 1, sizeof(string)),},.is_embed = 0,.embed_file = {0},.is_env = 0,.env_pos = {0},.sym = (v__ast__TypeSymbol){.methods = __new_array(0, 1, sizeof(v__ast__Fn)),},.result_type = 0,.env_value = (string){.str=(byteptr)"", .is_lit=1},.args = __new_array(0, 1, sizeof(v__ast__CallArg)),};
				// autofree_scope_vars(pos=3927 line_nr=149 scope.pos=3922 scope.end_pos=4065)
				// af parent scope:
				// af parent scope:
				// af parent scope:
				// var "p" var.pos=873 var.line_nr=41
				// var "err_node" var.pos=915 var.line_nr=42
				// var "start_pos" var.pos=978 var.line_nr=46
				// var "error_msg" var.pos=1014 var.line_nr=47
				// str literal
				// var "n" var.pos=1300 var.line_nr=56
				// var "is_embed_file" var.pos=1418 var.line_nr=61
				// var "is_html" var.pos=1454 var.line_nr=62
				// var "spos" var.pos=1788 var.line_nr=80
				// var "literal_string_param" var.pos=1814 var.line_nr=81
				// var "path_of_literal_string_param" var.pos=1876 var.line_nr=82
				// var "fn_path" var.pos=3243 var.line_nr=129
				// var "fn_path_joined" var.pos=3280 var.line_nr=130
				// var "compiled_vfile_path" var.pos=3331 var.line_nr=131
				// var "tmpl_path" var.pos=3421 var.line_nr=132
				// var "dir" var.pos=3550 var.line_nr=134
				// var "path" var.pos=3590 var.line_nr=135
				// var "tmp_fn_name" var.pos=4262 var.line_nr=165
				// var "v_code" var.pos=4413 var.line_nr=169
				// var "scope" var.pos=4609 var.line_nr=176
				// var "file" var.pos=4825 var.line_nr=187
				// af parent scope:
				// af parent scope:
				return _t2315;
			}
			if (is_html) {
				v__parser__Parser_error(p, _STR("vweb HTML template \"%.*s\000\" not found", 2, path));
			} else {
				v__parser__Parser_error(p, _STR("template file \"%.*s\000\" not found", 2, path));
			}
			// autofree_scope_vars(pos=4201 line_nr=161 scope.pos=3900 scope.end_pos=4220)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=873 var.line_nr=41
			// var "err_node" var.pos=915 var.line_nr=42
			// var "start_pos" var.pos=978 var.line_nr=46
			// var "error_msg" var.pos=1014 var.line_nr=47
			// str literal
			// var "n" var.pos=1300 var.line_nr=56
			// var "is_embed_file" var.pos=1418 var.line_nr=61
			// var "is_html" var.pos=1454 var.line_nr=62
			// var "spos" var.pos=1788 var.line_nr=80
			// var "literal_string_param" var.pos=1814 var.line_nr=81
			// var "path_of_literal_string_param" var.pos=1876 var.line_nr=82
			// var "fn_path" var.pos=3243 var.line_nr=129
			// var "fn_path_joined" var.pos=3280 var.line_nr=130
			// var "compiled_vfile_path" var.pos=3331 var.line_nr=131
			// var "tmpl_path" var.pos=3421 var.line_nr=132
			// var "dir" var.pos=3550 var.line_nr=134
			// var "path" var.pos=3590 var.line_nr=135
			// var "tmp_fn_name" var.pos=4262 var.line_nr=165
			// var "v_code" var.pos=4413 var.line_nr=169
			// var "scope" var.pos=4609 var.line_nr=176
			// var "file" var.pos=4825 var.line_nr=187
			// af parent scope:
			// af parent scope:
			return err_node;
		}
	}
	string tmp_fn_name = string_replace(p->cur_fn_name, _SLIT("."), _SLIT("__"));
	string v_code = v__parser__Parser_compile_template_file(p, path, tmp_fn_name);
	v__ast__Scope* scope = (v__ast__Scope*)memdup(&(v__ast__Scope){.objects = new_map(sizeof(string), sizeof(v__ast__ScopeObject), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.struct_fields = __new_array(0, 1, sizeof(v__ast__ScopeStructField)),.parent = p->global_scope,.detached_from_parent = 0,.children = __new_array(0, 1, sizeof(v__ast__Scope*)),.start_pos = 0,.end_pos = 0,}, sizeof(v__ast__Scope));
	v__ast__File file = v__parser__parse_comptime(v_code, p->table, p->pref, scope, p->global_scope);
	file = (v__ast__File){.path = tmpl_path,file.path_base,file.lines,file.bytes,file.mod,file.global_scope,file.scope,file.stmts,file.imports,file.auto_imports,file.embedded_files,file.imported_symbols,file.errors,file.warnings,file.notices,file.generic_fns,file.global_labels,};
	// FOR IN array
	for (int _t2316 = 0; _t2316 < file.stmts.len; ++_t2316) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)file.stmts.data)[_t2316];
		if ((stmt)._typ == 175 /* v.ast.FnDecl */) {
			if (string_eq((*stmt._v__ast__FnDecl).name, _STR("main.vweb_tmpl_%.*s", 1, tmp_fn_name))) {
				v__ast__Scope* tmpl_scope = (*stmt._v__ast__FnDecl).scope;
				// FOR IN map
				Map_string_v__ast__ScopeObject _t2317 = p->scope->objects;
				int _t2319 = _t2317.key_values.len;
				for (int _t2318 = 0; _t2318 < _t2319; ++_t2318 ) {
					int _t2320 = _t2317.key_values.len - _t2319;
					_t2319 = _t2317.key_values.len;
					if (_t2320 < 0) {
						_t2318 = -1;
						continue;
					}
					if (!DenseArray_has_index(&_t2317.key_values, _t2318)) {continue;}
					v__ast__ScopeObject obj = (*(v__ast__ScopeObject*)DenseArray_value(&_t2317.key_values, _t2318));
					if ((obj)._typ == 312 /* v.ast.Var */) {
						v__ast__Var v = (*obj._v__ast__Var);
						v.pos = (*stmt._v__ast__FnDecl).body_pos;
						v__ast__Scope_register(tmpl_scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){v.name,v.expr,v.share,v.is_mut,v.is_autofree_tmp,v.is_arg,v.is_auto_deref,v.typ,v.orig_type,v.smartcasts,v.pos,.is_used = true,v.is_changed,v.is_or,v.is_tmp,}))));
						v.is_used = true;
					}
				}
				break;
			}
		}
	}
	 v__ast__ComptimeCall _t2321 = (v__ast__ComptimeCall){
		.pos = v__token__Position_extend(start_pos, v__token__Token_position(&p->prev_tok)),
		.has_parens = 0,
		.method_name = n,
		.method_pos = {0},
		.scope = 0,
		.left = {0},
		.args_var = literal_string_param,
		.is_vweb = true,
		.vweb_tmpl = file,
		.is_embed = 0,
		.embed_file = {0},
		.is_env = 0,
		.env_pos = {0},
		.sym = (v__ast__TypeSymbol){.methods = __new_array(0, 1, sizeof(v__ast__Fn)),},
		.result_type = 0,
		.env_value = (string){.str=(byteptr)"", .is_lit=1},
		.args = __new_array(0, 1, sizeof(v__ast__CallArg)),
	};
	// autofree_scope_vars(pos=5546 line_nr=215 scope.pos=868 scope.end_pos=5717)
	// var "p" var.pos=873 var.line_nr=41
	// var "err_node" var.pos=915 var.line_nr=42
	// var "start_pos" var.pos=978 var.line_nr=46
	// var "error_msg" var.pos=1014 var.line_nr=47
	// str literal
	// var "n" var.pos=1300 var.line_nr=56
	// var "is_embed_file" var.pos=1418 var.line_nr=61
	// var "is_html" var.pos=1454 var.line_nr=62
	// var "spos" var.pos=1788 var.line_nr=80
	// var "literal_string_param" var.pos=1814 var.line_nr=81
	// var "path_of_literal_string_param" var.pos=1876 var.line_nr=82
	// var "fn_path" var.pos=3243 var.line_nr=129
	// var "fn_path_joined" var.pos=3280 var.line_nr=130
	// var "compiled_vfile_path" var.pos=3331 var.line_nr=131
	// var "tmpl_path" var.pos=3421 var.line_nr=132
	// var "dir" var.pos=3550 var.line_nr=134
	// var "path" var.pos=3590 var.line_nr=135
	// var "tmp_fn_name" var.pos=4262 var.line_nr=165
	// var "v_code" var.pos=4413 var.line_nr=169
	// var "scope" var.pos=4609 var.line_nr=176
	// var "file" var.pos=4825 var.line_nr=187
	// af parent scope:
	// af parent scope:
	return _t2321;
}

VV_LOCAL_SYMBOL v__ast__CompFor v__parser__Parser_comp_for(v__parser__Parser* p) {
	v__parser__Parser_next(p);
	v__parser__Parser_check(p, v__token__Kind_key_for);
	v__token__Position var_pos = v__token__Token_position(&p->tok);
	string val_var = v__parser__Parser_check_name(p);
	v__parser__Parser_check(p, v__token__Kind_key_in);
	v__token__Position typ_pos = v__token__Token_position(&p->tok);
	v__ast__Language lang = v__parser__Parser_parse_language(p);
	v__ast__Type typ = v__parser__Parser_parse_any_type(p, lang, false, false);
	typ_pos = v__token__Position_extend(typ_pos, v__token__Token_position(&p->prev_tok));
	v__parser__Parser_check(p, v__token__Kind_dot);
	string for_val = v__parser__Parser_check_name(p);
	v__ast__CompForKind kind = v__ast__CompForKind_methods;
	v__parser__Parser_open_scope(p);
	if (string_eq(for_val, _SLIT("methods"))) {
		v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){.name = val_var,.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.is_auto_deref = 0,.typ = v__ast__Table_find_type_idx(p->table, _SLIT("FunctionData")),.orig_type = 0,.smartcasts = __new_array(0, 1, sizeof(v__ast__Type)),.pos = var_pos,.is_used = 0,.is_changed = 0,.is_or = 0,.is_tmp = 0,}))));
	} else if (string_eq(for_val, _SLIT("fields"))) {
		v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){.name = val_var,.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.is_auto_deref = 0,.typ = v__ast__Table_find_type_idx(p->table, _SLIT("FieldData")),.orig_type = 0,.smartcasts = __new_array(0, 1, sizeof(v__ast__Type)),.pos = var_pos,.is_used = 0,.is_changed = 0,.is_or = 0,.is_tmp = 0,}))));
		kind = v__ast__CompForKind_fields;
	} else {
		v__parser__Parser_error_with_pos(p, _STR("unknown kind `%.*s\000`, available are: `methods` or `fields`", 2, for_val), v__token__Token_position(&p->prev_tok));
		 v__ast__CompFor _t2322 = (v__ast__CompFor){.val_var = (string){.str=(byteptr)"", .is_lit=1},.stmts = __new_array(0, 1, sizeof(v__ast__Stmt)),.kind = 0,.pos = {0},.typ_pos = {0},.typ = 0,};
		// autofree_scope_vars(pos=6647 line_nr=258 scope.pos=6534 scope.end_pos=6670)
		// af parent scope:
		// var "p" var.pos=5728 var.line_nr=225
		// var "var_pos" var.pos=5905 var.line_nr=231
		// var "val_var" var.pos=5934 var.line_nr=232
		// var "typ_pos" var.pos=5983 var.line_nr=234
		// var "lang" var.pos=6012 var.line_nr=235
		// var "typ" var.pos=6040 var.line_nr=236
		// var "for_val" var.pos=6149 var.line_nr=239
		// var "kind" var.pos=6180 var.line_nr=240
		// var "spos" var.pos=6673 var.line_nr=260
		// var "stmts" var.pos=6699 var.line_nr=261
		// af parent scope:
		// af parent scope:
		return _t2322;
	}
	v__token__Position spos = v__token__Token_position(&p->tok);
	Array_v__ast__Stmt stmts = v__parser__Parser_parse_block(p);
	v__parser__Parser_close_scope(p);
	 v__ast__CompFor _t2323 = (v__ast__CompFor){
		.val_var = val_var,
		.stmts = stmts,
		.kind = kind,
		.pos = v__token__Position_extend(spos, v__token__Token_position(&p->tok)),
		.typ_pos = typ_pos,
		.typ = typ,
	};
	// autofree_scope_vars(pos=6741 line_nr=263 scope.pos=5723 scope.end_pos=6879)
	// var "p" var.pos=5728 var.line_nr=225
	// var "var_pos" var.pos=5905 var.line_nr=231
	// var "val_var" var.pos=5934 var.line_nr=232
	// var "typ_pos" var.pos=5983 var.line_nr=234
	// var "lang" var.pos=6012 var.line_nr=235
	// var "typ" var.pos=6040 var.line_nr=236
	// var "for_val" var.pos=6149 var.line_nr=239
	// var "kind" var.pos=6180 var.line_nr=240
	// var "spos" var.pos=6673 var.line_nr=260
	// var "stmts" var.pos=6699 var.line_nr=261
	// af parent scope:
	// af parent scope:
	return _t2323;
}

VV_LOCAL_SYMBOL v__ast__AtExpr v__parser__Parser_at(v__parser__Parser* p) {
	string name = p->tok.lit;
	v__token__AtKind kind = ((string_eq(name, _SLIT("@FN"))) ? (v__token__AtKind_fn_name) : (string_eq(name, _SLIT("@METHOD"))) ? (v__token__AtKind_method_name) : (string_eq(name, _SLIT("@MOD"))) ? (v__token__AtKind_mod_name) : (string_eq(name, _SLIT("@STRUCT"))) ? (v__token__AtKind_struct_name) : (string_eq(name, _SLIT("@VEXE"))) ? (v__token__AtKind_vexe_path) : (string_eq(name, _SLIT("@FILE"))) ? (v__token__AtKind_file_path) : (string_eq(name, _SLIT("@LINE"))) ? (v__token__AtKind_line_nr) : (string_eq(name, _SLIT("@COLUMN"))) ? (v__token__AtKind_column_nr) : (string_eq(name, _SLIT("@VHASH"))) ? (v__token__AtKind_vhash) : (string_eq(name, _SLIT("@VMOD_FILE"))) ? (v__token__AtKind_vmod_file) : (v__token__AtKind_unknown));
	v__parser__Parser_next(p);
	 v__ast__AtExpr _t2324 = (v__ast__AtExpr){.name = name,.pos = v__token__Token_position(&p->tok),.kind = kind,.val = (string){.str=(byteptr)"", .is_lit=1},};
	// autofree_scope_vars(pos=7444 line_nr=290 scope.pos=6951 scope.end_pos=7517)
	// var "p" var.pos=6956 var.line_nr=274
	// var "name" var.pos=6985 var.line_nr=275
	// var "kind" var.pos=7004 var.line_nr=276
	// af parent scope:
	// af parent scope:
	return _t2324;
}

VV_LOCAL_SYMBOL v__ast__Expr v__parser__Parser_comptime_selector(v__parser__Parser* p, v__ast__Expr left) {
	v__parser__Parser_check(p, v__token__Kind_dollar);
	v__token__Position start_pos = v__token__Token_position(&p->prev_tok);
	if (p->peek_tok.kind == v__token__Kind_lpar) {
		v__token__Position method_pos = v__token__Token_position(&p->tok);
		string method_name = v__parser__Parser_check_name(p);
		v__parser__Parser_mark_var_as_used(p, method_name);
		v__parser__Parser_check(p, v__token__Kind_lpar);
		Array_v__ast__CallArg args = v__parser__Parser_call_args(p);
		v__parser__Parser_check(p, v__token__Kind_rpar);
		if (p->tok.kind == v__token__Kind_key_orelse) {
			v__parser__Parser_check(p, v__token__Kind_key_orelse);
			v__parser__Parser_check(p, v__token__Kind_lcbr);
		}
		 v__ast__Expr _t2325 = v__ast__ComptimeCall_to_sumtype_v__ast__Expr(ADDR(v__ast__ComptimeCall, ((v__ast__ComptimeCall){
			.pos = v__token__Position_extend(start_pos, v__token__Token_position(&p->prev_tok)),
			.has_parens = 0,
			.method_name = method_name,
			.method_pos = method_pos,
			.scope = p->scope,
			.left = left,
			.args_var = _SLIT(""),
			.is_vweb = 0,
			.vweb_tmpl = (v__ast__File){.stmts = __new_array(0, 1, sizeof(v__ast__Stmt)),.imports = __new_array(0, 1, sizeof(v__ast__Import)),.auto_imports = __new_array(0, 1, sizeof(string)),.embedded_files = __new_array(0, 1, sizeof(v__ast__EmbeddedFile)),.imported_symbols = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.errors = __new_array(0, 1, sizeof(v__errors__Error)),.warnings = __new_array(0, 1, sizeof(v__errors__Warning)),.notices = __new_array(0, 1, sizeof(v__errors__Notice)),.generic_fns = __new_array(0, 1, sizeof(v__ast__FnDecl*)),.global_labels = __new_array(0, 1, sizeof(string)),},
			.is_embed = 0,
			.embed_file = {0},
			.is_env = 0,
			.env_pos = {0},
			.sym = (v__ast__TypeSymbol){.methods = __new_array(0, 1, sizeof(v__ast__Fn)),},
			.result_type = 0,
			.env_value = (string){.str=(byteptr)"", .is_lit=1},
			.args = args,
		})));
		// autofree_scope_vars(pos=7948 line_nr=312 scope.pos=7665 scope.end_pos=8143)
		// var "method_pos" var.pos=7669 var.line_nr=301
		// var "method_name" var.pos=7702 var.line_nr=302
		// var "args" var.pos=7829 var.line_nr=306
		// af parent scope:
		// var "p" var.pos=7528 var.line_nr=297
		// var "left" var.pos=7556 var.line_nr=297
		// var "start_pos" var.pos=7601 var.line_nr=299
		// var "has_parens" var.pos=8150 var.line_nr=322
		// var "expr" var.pos=8341 var.line_nr=329
		// af parent scope:
		// af parent scope:
		return _t2325;
	}
	bool has_parens = false;
	if (p->tok.kind == v__token__Kind_lpar) {
		v__parser__Parser_check(p, v__token__Kind_lpar);
		has_parens = true;
	} else {
		v__parser__Parser_warn_with_pos(p, _SLIT("use brackets instead e.g. `s.$(field.name)` - run vfmt"), v__token__Token_position(&p->tok));
	}
	v__ast__Expr expr = v__parser__Parser_expr(p, 0);
	if (has_parens) {
		v__parser__Parser_check(p, v__token__Kind_rpar);
	}
	 v__ast__Expr _t2326 = v__ast__ComptimeSelector_to_sumtype_v__ast__Expr(ADDR(v__ast__ComptimeSelector, ((v__ast__ComptimeSelector){.has_parens = has_parens,.left = left,.field_expr = expr,.pos = v__token__Position_extend(start_pos, v__token__Token_position(&p->prev_tok)),.left_type = 0,.typ = 0,})));
	// autofree_scope_vars(pos=8396 line_nr=333 scope.pos=7523 scope.end_pos=8533)
	// var "p" var.pos=7528 var.line_nr=297
	// var "left" var.pos=7556 var.line_nr=297
	// var "start_pos" var.pos=7601 var.line_nr=299
	// var "has_parens" var.pos=8150 var.line_nr=322
	// var "expr" var.pos=8341 var.line_nr=329
	// af parent scope:
	// af parent scope:
	return _t2326;
}

VV_LOCAL_SYMBOL v__ast__ArrayInit v__parser__Parser_array_init(v__parser__Parser* p) {
	v__token__Position first_pos = v__token__Token_position(&p->tok);
	v__token__Position last_pos = v__token__Token_position(&p->tok);
	v__parser__Parser_check(p, v__token__Kind_lsbr);
	v__ast__Type array_type = _const_v__ast__void_type;
	v__ast__Type elem_type = _const_v__ast__void_type;
	v__token__Position elem_type_pos = first_pos;
	Array_v__ast__Expr exprs = __new_array_with_default(0, 0, sizeof(v__ast__Expr), 0);
	Array_Array_v__ast__Comment ecmnts = __new_array_with_default(0, 0, sizeof(Array_v__ast__Comment), 0);
	Array_v__ast__Comment pre_cmnts = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	bool is_fixed = false;
	bool has_val = false;
	bool has_type = false;
	bool has_default = false;
	v__ast__Expr default_expr = v__ast__empty_expr();
	if (p->tok.kind == v__token__Kind_rsbr) {
		last_pos = v__token__Token_position(&p->tok);
		int line_nr = p->tok.line_nr;
		v__parser__Parser_next(p);
		if ((p->tok.kind == v__token__Kind_name || p->tok.kind == v__token__Kind_amp || p->tok.kind == v__token__Kind_lsbr || p->tok.kind == v__token__Kind_key_shared) && p->tok.line_nr == line_nr) {
			elem_type_pos = v__token__Token_position(&p->tok);
			elem_type = v__parser__Parser_parse_type(p);
			int idx = v__ast__Table_find_or_register_array(p->table, elem_type);
			array_type = v__ast__new_type(idx);
			has_type = true;
		}
		last_pos = v__token__Token_position(&p->tok);
	} else {
		pre_cmnts = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,});
		for (int i = 0; !(p->tok.kind == v__token__Kind_rsbr || p->tok.kind == v__token__Kind_eof); i++) {
			array_push(&exprs, _MOV((v__ast__Expr[]){ v__parser__Parser_expr(p, 0) }));
			array_push(&ecmnts, _MOV((Array_v__ast__Comment[]){ v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}) }));
			if (p->tok.kind == v__token__Kind_comma) {
				v__parser__Parser_next(p);
			}
			_PUSH_MANY(&(*(Array_v__ast__Comment*)array_last(ecmnts)), (v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,})), _t2329, Array_v__ast__Comment);
		}
		int line_nr = p->tok.line_nr;
		last_pos = v__token__Token_position(&p->tok);
		v__parser__Parser_check(p, v__token__Kind_rsbr);
		if (exprs.len == 1 && (p->tok.kind == v__token__Kind_name || p->tok.kind == v__token__Kind_amp || p->tok.kind == v__token__Kind_lsbr) && p->tok.line_nr == line_nr) {
			elem_type = v__parser__Parser_parse_type(p);
			last_pos = v__token__Token_position(&p->tok);
			is_fixed = true;
			if (p->tok.kind == v__token__Kind_lcbr) {
				v__parser__Parser_next(p);
				if (p->tok.kind != v__token__Kind_rcbr) {
					v__token__Position pos = v__token__Token_position(&p->tok);
					string n = v__parser__Parser_check_name(p);
					if (string_ne(n, _SLIT("init"))) {
						v__parser__Parser_error_with_pos(p, _STR("expected `init:`, not `%.*s\000`", 2, n), pos);
						 v__ast__ArrayInit _t2330 = (v__ast__ArrayInit){.pos = {0},.elem_type_pos = {0},.exprs = __new_array(0, 1, sizeof(v__ast__Expr)),.ecmnts = __new_array(0, 1, sizeof(Array_v__ast__Comment)),.pre_cmnts = __new_array(0, 1, sizeof(v__ast__Comment)),.is_fixed = 0,.has_val = 0,.mod = (string){.str=(byteptr)"", .is_lit=1},.len_expr = {0},.cap_expr = {0},.default_expr = {0},.has_len = 0,.has_cap = 0,.has_default = 0,.expr_types = __new_array(0, 1, sizeof(v__ast__Type)),.elem_type = 0,.typ = 0,};
						// autofree_scope_vars(pos=2155 line_nr=71 scope.pos=2090 scope.end_pos=2184)
						// af parent scope:
						// var "pos" var.pos=2021 var.line_nr=67
						// var "n" var.pos=2050 var.line_nr=68
						// af parent scope:
						// af parent scope:
						// af parent scope:
						// var "line_nr" var.pos=1532 var.line_nr=50
						// af parent scope:
						// var "p" var.pos=207 var.line_nr=7
						// var "first_pos" var.pos=247 var.line_nr=8
						// var "last_pos" var.pos=282 var.line_nr=9
						// var "array_type" var.pos=380 var.line_nr=12
						// var "elem_type" var.pos=413 var.line_nr=13
						// var "elem_type_pos" var.pos=445 var.line_nr=14
						// var "exprs" var.pos=477 var.line_nr=15
						// var "ecmnts" var.pos=504 var.line_nr=16
						// var "pre_cmnts" var.pos=537 var.line_nr=17
						// var "is_fixed" var.pos=571 var.line_nr=18
						// var "has_val" var.pos=594 var.line_nr=19
						// var "has_type" var.pos=616 var.line_nr=20
						// var "has_default" var.pos=639 var.line_nr=21
						// var "default_expr" var.pos=665 var.line_nr=22
						// var "has_len" var.pos=3003 var.line_nr=102
						// var "has_cap" var.pos=3025 var.line_nr=103
						// var "len_expr" var.pos=3047 var.line_nr=104
						// var "cap_expr" var.pos=3081 var.line_nr=105
						// var "pos" var.pos=3722 var.line_nr=136
						// af parent scope:
						// af parent scope:
						return _t2330;
					}
					v__parser__Parser_check(p, v__token__Kind_colon);
					has_default = true;
					default_expr = v__parser__Parser_expr(p, 0);
				}
				last_pos = v__token__Token_position(&p->tok);
				v__parser__Parser_check(p, v__token__Kind_rcbr);
			} else {
				v__parser__Parser_warn_with_pos(p, _SLIT("use e.g. `x := [1]Type{}` instead of `x := [1]Type`"), v__token__Position_extend(first_pos, last_pos));
			}
		} else {
			if (p->tok.kind == v__token__Kind_not) {
				last_pos = v__token__Token_position(&p->tok);
				is_fixed = true;
				has_val = true;
				v__parser__Parser_next(p);
			}
			if (p->tok.kind == v__token__Kind_not && p->tok.line_nr == p->prev_tok.line_nr) {
				last_pos = v__token__Token_position(&p->tok);
				v__parser__Parser_error_with_pos(p, _SLIT("use e.g. `[1, 2, 3]!` instead of `[1, 2, 3]!!`"), last_pos);
				v__parser__Parser_next(p);
			}
		}
	}
	if (exprs.len == 0 && p->tok.kind != v__token__Kind_lcbr && has_type) {
		if (!p->pref->is_fmt) {
			v__parser__Parser_warn_with_pos(p, _SLIT("use `x := []Type{}` instead of `x := []Type`"), v__token__Position_extend(first_pos, last_pos));
		}
	}
	bool has_len = false;
	bool has_cap = false;
	v__ast__Expr len_expr = v__ast__empty_expr();
	v__ast__Expr cap_expr = v__ast__empty_expr();
	if (p->tok.kind == v__token__Kind_lcbr && exprs.len == 0 && !v__ast__Type_alias_eq(array_type, _const_v__ast__void_type)) {
		v__parser__Parser_next(p);
		for (;;) {
			if (!(p->tok.kind != v__token__Kind_rcbr)) break;
			string key = v__parser__Parser_check_name(p);
			v__parser__Parser_check(p, v__token__Kind_colon);

			if (string_eq(key, _SLIT("len"))) {
				has_len = true;
				len_expr = v__parser__Parser_expr(p, 0);
			}
			else if (string_eq(key, _SLIT("cap"))) {
				has_cap = true;
				cap_expr = v__parser__Parser_expr(p, 0);
			}
			else if (string_eq(key, _SLIT("init"))) {
				has_default = true;
				default_expr = v__parser__Parser_expr(p, 0);
			}
			else {
				v__parser__Parser_error(p, _STR("wrong field `%.*s\000`, expecting `len`, `cap`, or `init`", 2, key));
				 v__ast__ArrayInit _t2331 = (v__ast__ArrayInit){.pos = {0},.elem_type_pos = {0},.exprs = __new_array(0, 1, sizeof(v__ast__Expr)),.ecmnts = __new_array(0, 1, sizeof(Array_v__ast__Comment)),.pre_cmnts = __new_array(0, 1, sizeof(v__ast__Comment)),.is_fixed = 0,.has_val = 0,.mod = (string){.str=(byteptr)"", .is_lit=1},.len_expr = {0},.cap_expr = {0},.default_expr = {0},.has_len = 0,.has_cap = 0,.has_default = 0,.expr_types = __new_array(0, 1, sizeof(v__ast__Type)),.elem_type = 0,.typ = 0,};
				// autofree_scope_vars(pos=3609 line_nr=127 scope.pos=3528 scope.end_pos=3637)
				// af parent scope:
				// var "key" var.pos=3267 var.line_nr=110
				// af parent scope:
				// af parent scope:
				// af parent scope:
				// var "p" var.pos=207 var.line_nr=7
				// var "first_pos" var.pos=247 var.line_nr=8
				// var "last_pos" var.pos=282 var.line_nr=9
				// var "array_type" var.pos=380 var.line_nr=12
				// var "elem_type" var.pos=413 var.line_nr=13
				// var "elem_type_pos" var.pos=445 var.line_nr=14
				// var "exprs" var.pos=477 var.line_nr=15
				// var "ecmnts" var.pos=504 var.line_nr=16
				// var "pre_cmnts" var.pos=537 var.line_nr=17
				// var "is_fixed" var.pos=571 var.line_nr=18
				// var "has_val" var.pos=594 var.line_nr=19
				// var "has_type" var.pos=616 var.line_nr=20
				// var "has_default" var.pos=639 var.line_nr=21
				// var "default_expr" var.pos=665 var.line_nr=22
				// var "has_len" var.pos=3003 var.line_nr=102
				// var "has_cap" var.pos=3025 var.line_nr=103
				// var "len_expr" var.pos=3047 var.line_nr=104
				// var "cap_expr" var.pos=3081 var.line_nr=105
				// var "pos" var.pos=3722 var.line_nr=136
				// af parent scope:
				// af parent scope:
				return _t2331;
			};
			if (p->tok.kind != v__token__Kind_rcbr) {
				v__parser__Parser_check(p, v__token__Kind_comma);
			}
		}
		v__parser__Parser_check(p, v__token__Kind_rcbr);
	}
	v__token__Position pos = v__token__Position_extend_with_last_line(first_pos, last_pos, p->prev_tok.line_nr);
	 v__ast__ArrayInit _t2332 = (v__ast__ArrayInit){
		.pos = pos,
		.elem_type_pos = elem_type_pos,
		.exprs = exprs,
		.ecmnts = ecmnts,
		.pre_cmnts = pre_cmnts,
		.is_fixed = is_fixed,
		.has_val = has_val,
		.mod = p->mod,
		.len_expr = len_expr,
		.cap_expr = cap_expr,
		.default_expr = default_expr,
		.has_len = has_len,
		.has_cap = has_cap,
		.has_default = has_default,
		.expr_types = __new_array(0, 1, sizeof(v__ast__Type)),
		.elem_type = elem_type,
		.typ = array_type,
	};
	// autofree_scope_vars(pos=3791 line_nr=137 scope.pos=202 scope.end_pos=4144)
	// var "p" var.pos=207 var.line_nr=7
	// var "first_pos" var.pos=247 var.line_nr=8
	// var "last_pos" var.pos=282 var.line_nr=9
	// var "array_type" var.pos=380 var.line_nr=12
	// var "elem_type" var.pos=413 var.line_nr=13
	// var "elem_type_pos" var.pos=445 var.line_nr=14
	// var "exprs" var.pos=477 var.line_nr=15
	// var "ecmnts" var.pos=504 var.line_nr=16
	// var "pre_cmnts" var.pos=537 var.line_nr=17
	// var "is_fixed" var.pos=571 var.line_nr=18
	// var "has_val" var.pos=594 var.line_nr=19
	// var "has_type" var.pos=616 var.line_nr=20
	// var "has_default" var.pos=639 var.line_nr=21
	// var "default_expr" var.pos=665 var.line_nr=22
	// var "has_len" var.pos=3003 var.line_nr=102
	// var "has_cap" var.pos=3025 var.line_nr=103
	// var "len_expr" var.pos=3047 var.line_nr=104
	// var "cap_expr" var.pos=3081 var.line_nr=105
	// var "pos" var.pos=3722 var.line_nr=136
	// af parent scope:
	// af parent scope:
	return _t2332;
}

VV_LOCAL_SYMBOL v__ast__MapInit v__parser__Parser_map_init(v__parser__Parser* p) {
	v__token__Position first_pos = v__token__Token_position(&p->prev_tok);
	Array_v__ast__Expr keys = __new_array_with_default(0, 0, sizeof(v__ast__Expr), 0);
	Array_v__ast__Expr vals = __new_array_with_default(0, 0, sizeof(v__ast__Expr), 0);
	Array_Array_v__ast__Comment comments = __new_array_with_default(0, 0, sizeof(Array_v__ast__Comment), 0);
	Array_v__ast__Comment pre_cmnts = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,});
	for (;;) {
		if (!(!(p->tok.kind == v__token__Kind_rcbr || p->tok.kind == v__token__Kind_eof))) break;
		v__ast__Expr key = v__parser__Parser_expr(p, 0);
		array_push(&keys, _MOV((v__ast__Expr[]){ key }));
		v__parser__Parser_check(p, v__token__Kind_colon);
		v__ast__Expr val = v__parser__Parser_expr(p, 0);
		array_push(&vals, _MOV((v__ast__Expr[]){ val }));
		if (p->tok.kind == v__token__Kind_comma) {
			v__parser__Parser_next(p);
		}
		array_push(&comments, _MOV((Array_v__ast__Comment[]){ v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}) }));
	}
	 v__ast__MapInit _t2336 = (v__ast__MapInit){.pos = v__token__Position_extend_with_last_line(first_pos, v__token__Token_position(&p->tok), p->tok.line_nr),.keys = keys,.vals = vals,.comments = comments,.pre_cmnts = pre_cmnts,.typ = 0,.key_type = 0,.value_type = 0,};
	// autofree_scope_vars(pos=4577 line_nr=175 scope.pos=4181 scope.end_pos=4743)
	// var "p" var.pos=4186 var.line_nr=158
	// var "first_pos" var.pos=4222 var.line_nr=159
	// var "keys" var.pos=4262 var.line_nr=160
	// var "vals" var.pos=4288 var.line_nr=161
	// var "comments" var.pos=4314 var.line_nr=162
	// var "pre_cmnts" var.pos=4345 var.line_nr=163
	// af parent scope:
	// af parent scope:
	return _t2336;
}

v__ast__CallExpr v__parser__Parser_call_expr(v__parser__Parser* p, v__ast__Language language, string mod) {
bool v__parser__Parser_call_expr_defer_0 = false;
	v__token__Position first_pos = v__token__Token_position(&p->tok);
	string fn_name = (language == v__ast__Language_c ? (_STR("C.%.*s", 1, v__parser__Parser_check_name(p))) : language == v__ast__Language_js ? (_STR("JS.%.*s", 1, v__parser__Parser_check_js_name(p))) : mod.len > 0 ? (_STR("%.*s\000.%.*s", 2, mod, v__parser__Parser_check_name(p))) : (v__parser__Parser_check_name(p)));
	if (language != v__ast__Language_v) {
		v__parser__Parser_check_for_impure_v(p, language, first_pos);
	}
	v__ast__OrKind or_kind = v__ast__OrKind_absent;
	if (string_eq(fn_name, _SLIT("json.decode"))) {
		p->expecting_type = true;
		or_kind = v__ast__OrKind_block;
	}
	string old_expr_mod = p->expr_mod;
	v__parser__Parser_call_expr_defer_0 = true;
	p->expr_mod = _SLIT("");
	Array_v__ast__Type generic_types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
	v__token__Position generic_list_pos = v__token__Token_position(&p->tok);
	if (p->tok.kind == v__token__Kind_lt) {
		p->expr_mod = _SLIT("");
		generic_types = v__parser__Parser_parse_generic_type_list(p);
		generic_list_pos = v__token__Position_extend(generic_list_pos, v__token__Token_position(&p->prev_tok));
		string full_generic_fn_name = (string_contains(fn_name, _SLIT(".")) ? (fn_name) : (v__parser__Parser_prepend_mod(p, fn_name)));
		Array_v__ast__Type _t2337_orig = generic_types;
		int _t2337_len = _t2337_orig.len;
		Array_v__ast__Type _t2337 = __new_array(0, _t2337_len, sizeof(v__ast__Type));

		for (int _t2338 = 0; _t2338 < _t2337_len; ++_t2338) {
			v__ast__Type it = ((v__ast__Type*) _t2337_orig.data)[_t2338];
			if (v__ast__Type_has_flag(it, v__ast__TypeFlag_generic)) {
				array_push(&_t2337, &it); 
		}
		}
		
		bool has_generic_generic = _t2337.len > 0;
		if (!has_generic_generic) {
			v__ast__Table_register_fn_gen_type(p->table, full_generic_fn_name, generic_types);
		}
	}
	v__parser__Parser_check(p, v__token__Kind_lpar);
	Array_v__ast__CallArg args = v__parser__Parser_call_args(p);
	v__token__Position last_pos = v__token__Token_position(&p->tok);
	v__parser__Parser_check(p, v__token__Kind_rpar);
	if (p->tok.kind == v__token__Kind_not) {
		v__parser__Parser_next(p);
	}
	v__token__Position pos = v__token__Position_extend(first_pos, last_pos);
	Array_v__ast__Stmt or_stmts = __new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
	v__token__Position or_pos = v__token__Token_position(&p->tok);
	if (p->tok.kind == v__token__Kind_key_orelse) {
		bool was_inside_or_expr = p->inside_or_expr;
		p->inside_or_expr = true;
		v__parser__Parser_next(p);
		v__parser__Parser_open_scope(p);
		v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){.name = _SLIT("err"),.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.is_auto_deref = 0,.typ = _const_v__ast__error_type,.orig_type = 0,.smartcasts = __new_array(0, 1, sizeof(v__ast__Type)),.pos = v__token__Token_position(&p->tok),.is_used = true,.is_changed = 0,.is_or = 0,.is_tmp = 0,}))));
		or_kind = v__ast__OrKind_block;
		or_stmts = v__parser__Parser_parse_block_no_scope(p, false);
		or_pos = v__token__Position_extend(or_pos, v__token__Token_position(&p->prev_tok));
		v__parser__Parser_close_scope(p);
		p->inside_or_expr = was_inside_or_expr;
	}
	if (p->tok.kind == v__token__Kind_question) {
		v__parser__Parser_next(p);
		or_kind = v__ast__OrKind_propagate;
	}
	if (_IN_MAP(ADDR(string, fn_name), ADDR(map, p->imported_symbols))) {
		fn_name = (*(string*)map_get(ADDR(map, p->imported_symbols), &(string[]){fn_name}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} }));
	}
	Array_v__ast__Comment comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = true,.follow_up = 0,});
	v__token__Position_update_last_line(&pos, p->prev_tok.line_nr);
	// Defer begin
	if (v__parser__Parser_call_expr_defer_0 == true) {
		p->expr_mod = old_expr_mod;
	}
	// Defer end
	 v__ast__CallExpr _t2339 = (v__ast__CallExpr){
		.pos = pos,
		.name_pos = first_pos,
		.mod = p->mod,
		.name = fn_name,
		.is_method = 0,
		.is_field = 0,
		.is_keep_alive = 0,
		.args = args,
		.expected_arg_types = __new_array(0, 1, sizeof(v__ast__Type)),
		.language = language,
		.or_block = (v__ast__OrExpr){.stmts = or_stmts,.kind = or_kind,.pos = or_pos,},
		.left = {0},
		.left_type = 0,
		.receiver_type = 0,
		.return_type = 0,
		.should_be_skipped = 0,
		.generic_types = generic_types,
		.generic_list_pos = generic_list_pos,
		.free_receiver = 0,
		.scope = p->scope,
		.from_embed_type = 0,
		.comments = comments,
	};
	// autofree_scope_vars(pos=2508 line_nr=90 scope.pos=235 scope.end_pos=2814)
	// var "p" var.pos=240 var.line_nr=9
	// var "language" var.pos=260 var.line_nr=9
	// var "mod" var.pos=283 var.line_nr=9
	// var "first_pos" var.pos=311 var.line_nr=10
	// var "fn_name" var.pos=346 var.line_nr=11
	// var "or_kind" var.pos=609 var.line_nr=23
	// var "old_expr_mod" var.pos=793 var.line_nr=29
	// var "generic_types" var.pos=886 var.line_nr=35
	// var "generic_list_pos" var.pos=921 var.line_nr=36
	// var "args" var.pos=1536 var.line_nr=52
	// var "last_pos" var.pos=1559 var.line_nr=53
	// var "pos" var.pos=1673 var.line_nr=59
	// var "or_stmts" var.pos=1712 var.line_nr=60
	// var "or_pos" var.pos=1803 var.line_nr=61
	// var "comments" var.pos=2422 var.line_nr=88
	// af parent scope:
	// af parent scope:
	return _t2339;
}

Array_v__ast__CallArg v__parser__Parser_call_args(v__parser__Parser* p) {
	Array_v__ast__CallArg args = __new_array_with_default(0, 0, sizeof(v__ast__CallArg), 0);
	v__token__Position start_pos = v__token__Token_position(&p->tok);
	for (;;) {
		if (!(p->tok.kind != v__token__Kind_rpar)) break;
		if (p->tok.kind == v__token__Kind_eof) {
			v__parser__Parser_error_with_pos(p, _SLIT("unexpected eof reached, while parsing call argument"), start_pos);
			 Array_v__ast__CallArg _t2340 = __new_array_with_default(0, 0, sizeof(v__ast__CallArg), 0);
			// autofree_scope_vars(pos=3068 line_nr=115 scope.pos=2978 scope.end_pos=3081)
			// af parent scope:
			// var "is_shared" var.pos=3085 var.line_nr=117
			// var "is_atomic" var.pos=3126 var.line_nr=118
			// var "is_mut" var.pos=3167 var.line_nr=119
			// var "comments" var.pos=3262 var.line_nr=123
			// var "arg_start_pos" var.pos=3295 var.line_nr=124
			// var "array_decompose" var.pos=3335 var.line_nr=125
			// var "expr" var.pos=3439 var.line_nr=130
			// var "pos" var.pos=3844 var.line_nr=147
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=2829 var.line_nr=109
			// var "args" var.pos=2872 var.line_nr=110
			// var "start_pos" var.pos=2897 var.line_nr=111
			// af parent scope:
			// af parent scope:
			return _t2340;
		}
		bool is_shared = p->tok.kind == v__token__Kind_key_shared;
		bool is_atomic = p->tok.kind == v__token__Kind_key_atomic;
		bool is_mut = p->tok.kind == v__token__Kind_key_mut || is_shared || is_atomic;
		if (is_mut) {
			v__parser__Parser_next(p);
		}
		Array_v__ast__Comment comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,});
		v__token__Position arg_start_pos = v__token__Token_position(&p->tok);
		bool array_decompose = false;
		if (p->tok.kind == v__token__Kind_ellipsis) {
			v__parser__Parser_next(p);
			array_decompose = true;
		}
		v__ast__Expr expr = v__ast__empty_expr();
		if (p->tok.kind == v__token__Kind_name && p->peek_tok.kind == v__token__Kind_colon) {
			expr = v__ast__StructInit_to_sumtype_v__ast__Expr(ADDR(v__ast__StructInit, (v__parser__Parser_struct_init(p, true))));
		} else {
			expr = v__parser__Parser_expr(p, 0);
		}
		if (array_decompose) {
			expr = v__ast__ArrayDecompose_to_sumtype_v__ast__Expr(ADDR(v__ast__ArrayDecompose, ((v__ast__ArrayDecompose){.expr = expr,.pos = v__token__Token_position(&p->tok),.expr_type = 0,.arg_type = 0,})));
		}
		if ((expr)._typ == 278 /* v.ast.StructInit */) {
			_PUSH_MANY(&(*expr._v__ast__StructInit).pre_comments, (comments), _t2341, Array_v__ast__Comment);
			comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
		}
		v__token__Position pos = v__token__Position_extend(arg_start_pos, v__token__Token_position(&p->prev_tok));
		_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,})), _t2342, Array_v__ast__Comment);
		array_push(&args, _MOV((v__ast__CallArg[]){ (v__ast__CallArg){.is_mut = is_mut,.share = v__ast__sharetype_from_flags(is_shared, is_atomic),.expr = expr,.comments = comments,.typ = 0,.is_tmp_autofree = 0,.pos = pos,} }));
		if (p->tok.kind != v__token__Kind_rpar) {
			v__parser__Parser_check(p, v__token__Kind_comma);
		}
	}
	// autofree_scope_vars(pos=4131 line_nr=160 scope.pos=2824 scope.end_pos=4144)
	// var "p" var.pos=2829 var.line_nr=109
	// var "args" var.pos=2872 var.line_nr=110
	// var "start_pos" var.pos=2897 var.line_nr=111
	// af parent scope:
	// af parent scope:
	return args;
}

VV_LOCAL_SYMBOL v__ast__FnDecl v__parser__Parser_fn_decl(v__parser__Parser* p) {
	v__parser__Parser_top_level_statement_start(p);
	v__token__Position start_pos = v__token__Token_position(&p->tok);
	bool is_manualfree = p->is_manualfree || Array_v__ast__Attr_contains(p->attrs, _SLIT("manualfree"));
	bool is_deprecated = Array_v__ast__Attr_contains(p->attrs, _SLIT("deprecated"));
	bool is_direct_arr = Array_v__ast__Attr_contains(p->attrs, _SLIT("direct_array_access"));
	multi_return_bool_string mr_4624 = Array_v__ast__Attr_has_comptime_define(p->attrs);
	bool is_conditional = mr_4624.arg0;
	string conditional_ctdefine = mr_4624.arg1;
	bool is_unsafe = Array_v__ast__Attr_contains(p->attrs, _SLIT("unsafe"));
	bool is_keep_alive = Array_v__ast__Attr_contains(p->attrs, _SLIT("keep_args_alive"));
	bool is_pub = p->tok.kind == v__token__Kind_key_pub;
	if (is_pub) {
		v__parser__Parser_next(p);
	}
	v__parser__Parser_check(p, v__token__Kind_key_fn);
	v__parser__Parser_open_scope(p);
	v__ast__Language language = v__ast__Language_v;
	if (p->tok.kind == v__token__Kind_name && string_eq(p->tok.lit, _SLIT("C"))) {
		is_unsafe = !Array_v__ast__Attr_contains(p->attrs, _SLIT("trusted"));
		language = v__ast__Language_c;
	} else if (p->tok.kind == v__token__Kind_name && string_eq(p->tok.lit, _SLIT("JS"))) {
		language = v__ast__Language_js;
	}
	if (is_keep_alive && language != v__ast__Language_c) {
		v__parser__Parser_error_with_pos(p, _SLIT("attribute [keep_args_alive] is only supported for C functions"), v__token__Token_position(&p->tok));
	}
	if (language != v__ast__Language_v) {
		v__parser__Parser_next(p);
		v__parser__Parser_check(p, v__token__Kind_dot);
		v__parser__Parser_check_for_impure_v(p, language, v__token__Token_position(&p->tok));
	}
	v__parser__ReceiverParsingInfo rec = (v__parser__ReceiverParsingInfo){.name = (string){.str=(byteptr)"", .is_lit=1},.pos = {0},.typ = _const_v__ast__void_type,.type_pos = {0},.is_mut = 0,.language = language,};
	bool is_method = false;
	Array_v__ast__Param params = __new_array_with_default(0, 0, sizeof(v__ast__Param), 0);
	if (p->tok.kind == v__token__Kind_lpar) {
		is_method = true;
		Option_void _t2344 = v__parser__Parser_fn_receiver(p, &/*arr*/params, (voidptr)&/*qq*/rec);
		if (_t2344.state != 0 && _t2344.err._typ != _IError_None___index) {
			IError err = _t2344.err;
			 v__ast__FnDecl _t2345 = (v__ast__FnDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.params = __new_array(0, 1, sizeof(v__ast__Param)),.is_deprecated = 0,.is_pub = 0,.is_variadic = 0,.is_anon = 0,.is_manualfree = 0,.is_main = 0,.is_test = 0,.is_conditional = 0,.is_keep_alive = 0,.receiver = (v__ast__StructField){.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),},.receiver_pos = {0},.is_method = 0,.method_type_pos = {0},.method_idx = 0,.rec_mut = 0,.rec_share = 0,.language = 0,.no_body = 0,.is_builtin = 0,.body_pos = {0},.file = (string){.str=(byteptr)"", .is_lit=1},.generic_names = __new_array(0, 1, sizeof(string)),.is_direct_arr = 0,.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.skip_gen = 0,.stmts = __new_array(0, 1, sizeof(v__ast__Stmt)),.defer_stmts = __new_array(0, 1, sizeof(v__ast__DeferStmt)),.return_type = 0,.return_type_pos = {0},.has_return = 0,.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.next_comments = __new_array(0, 1, sizeof(v__ast__Comment)),.source_file = 0,.scope = 0,.label_names = __new_array(0, 1, sizeof(string)),.pos = {0},};
			// autofree_scope_vars(pos=5579 line_nr=214 scope.pos=5578 scope.end_pos=5615)
			// var "err" var.pos=5578 var.line_nr=214
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=4316 var.line_nr=173
			// var "start_pos" var.pos=4381 var.line_nr=175
			// var "is_manualfree" var.pos=4412 var.line_nr=176
			// var "is_deprecated" var.pos=4480 var.line_nr=177
			// var "is_direct_arr" var.pos=4529 var.line_nr=178
			// var "is_conditional" var.pos=4587 var.line_nr=179
			// var "conditional_ctdefine" var.pos=4603 var.line_nr=179
			// var "is_unsafe" var.pos=4662 var.line_nr=180
			// var "is_keep_alive" var.pos=4703 var.line_nr=181
			// var "is_pub" var.pos=4757 var.line_nr=182
			// var "language" var.pos=4870 var.line_nr=189
			// var "rec" var.pos=5367 var.line_nr=206
			// var "is_method" var.pos=5445 var.line_nr=210
			// var "params" var.pos=5469 var.line_nr=211
			// var "name" var.pos=5777 var.line_nr=222
			// var "generic_names" var.pos=7549 var.line_nr=276
			// var "args2" var.pos=7600 var.line_nr=278
			// var "are_args_type_only" var.pos=7607 var.line_nr=278
			// var "is_variadic" var.pos=7627 var.line_nr=278
			// var "return_type_pos" var.pos=8117 var.line_nr=300
			// var "return_type" var.pos=8158 var.line_nr=301
			// var "same_line" var.pos=8251 var.line_nr=303
			// var "type_sym_method_idx" var.pos=8523 var.line_nr=309
			// var "no_body" var.pos=8549 var.line_nr=310
			// var "end_pos" var.pos=8581 var.line_nr=311
			// var "short_fn_name" var.pos=8615 var.line_nr=312
			// var "is_main" var.pos=8638 var.line_nr=313
			// var "is_test" var.pos=8693 var.line_nr=314
			// var "stmts" var.pos=10842 var.line_nr=386
			// var "body_start_pos" var.pos=10865 var.line_nr=387
			// var "fn_decl" var.pos=11368 var.line_nr=404
			// af parent scope:
			// af parent scope:
			return _t2345;
		};
		language = rec.language;
	}
	string name = _SLIT("");
	if (p->tok.kind == v__token__Kind_name) {
		v__token__Position pos = v__token__Token_position(&p->tok);
		name = (language == v__ast__Language_js ? (v__parser__Parser_check_js_name(p)) : (v__parser__Parser_check_name(p)));
		if (language == v__ast__Language_v && !p->pref->translated && v__util__contains_capital(name) && !p->builtin_mod) {
			v__parser__Parser_error_with_pos(p, _SLIT("function names cannot contain uppercase letters, use snake_case instead"), pos);
			 v__ast__FnDecl _t2346 = (v__ast__FnDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.params = __new_array(0, 1, sizeof(v__ast__Param)),.is_deprecated = 0,.is_pub = 0,.is_variadic = 0,.is_anon = 0,.is_manualfree = 0,.is_main = 0,.is_test = 0,.is_conditional = 0,.is_keep_alive = 0,.receiver = (v__ast__StructField){.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),},.receiver_pos = {0},.is_method = 0,.method_type_pos = {0},.method_idx = 0,.rec_mut = 0,.rec_share = 0,.language = 0,.no_body = 0,.is_builtin = 0,.body_pos = {0},.file = (string){.str=(byteptr)"", .is_lit=1},.generic_names = __new_array(0, 1, sizeof(string)),.is_direct_arr = 0,.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.skip_gen = 0,.stmts = __new_array(0, 1, sizeof(v__ast__Stmt)),.defer_stmts = __new_array(0, 1, sizeof(v__ast__DeferStmt)),.return_type = 0,.return_type_pos = {0},.has_return = 0,.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.next_comments = __new_array(0, 1, sizeof(v__ast__Comment)),.source_file = 0,.scope = 0,.label_names = __new_array(0, 1, sizeof(string)),.pos = {0},};
			// autofree_scope_vars(pos=6137 line_nr=230 scope.pos=6029 scope.end_pos=6177)
			// af parent scope:
			// var "pos" var.pos=5816 var.line_nr=224
			// var "type_sym" var.pos=6181 var.line_nr=234
			// af parent scope:
			// var "p" var.pos=4316 var.line_nr=173
			// var "start_pos" var.pos=4381 var.line_nr=175
			// var "is_manualfree" var.pos=4412 var.line_nr=176
			// var "is_deprecated" var.pos=4480 var.line_nr=177
			// var "is_direct_arr" var.pos=4529 var.line_nr=178
			// var "is_conditional" var.pos=4587 var.line_nr=179
			// var "conditional_ctdefine" var.pos=4603 var.line_nr=179
			// var "is_unsafe" var.pos=4662 var.line_nr=180
			// var "is_keep_alive" var.pos=4703 var.line_nr=181
			// var "is_pub" var.pos=4757 var.line_nr=182
			// var "language" var.pos=4870 var.line_nr=189
			// var "rec" var.pos=5367 var.line_nr=206
			// var "is_method" var.pos=5445 var.line_nr=210
			// var "params" var.pos=5469 var.line_nr=211
			// var "name" var.pos=5777 var.line_nr=222
			// str literal
			// var "generic_names" var.pos=7549 var.line_nr=276
			// var "args2" var.pos=7600 var.line_nr=278
			// var "are_args_type_only" var.pos=7607 var.line_nr=278
			// var "is_variadic" var.pos=7627 var.line_nr=278
			// var "return_type_pos" var.pos=8117 var.line_nr=300
			// var "return_type" var.pos=8158 var.line_nr=301
			// var "same_line" var.pos=8251 var.line_nr=303
			// var "type_sym_method_idx" var.pos=8523 var.line_nr=309
			// var "no_body" var.pos=8549 var.line_nr=310
			// var "end_pos" var.pos=8581 var.line_nr=311
			// var "short_fn_name" var.pos=8615 var.line_nr=312
			// var "is_main" var.pos=8638 var.line_nr=313
			// var "is_test" var.pos=8693 var.line_nr=314
			// var "stmts" var.pos=10842 var.line_nr=386
			// var "body_start_pos" var.pos=10865 var.line_nr=387
			// var "fn_decl" var.pos=11368 var.line_nr=404
			// af parent scope:
			// af parent scope:
			return _t2346;
		}
		v__ast__TypeSymbol* type_sym = v__ast__Table_get_type_symbol(p->table, rec.typ);
		if (is_method) {
			bool is_duplicate = v__ast__TypeSymbol_has_method(type_sym, name);
			if (type_sym->kind == v__ast__Kind_interface_ && is_duplicate) {
				if ((type_sym->info)._typ == 410 /* v.ast.Interface */) {
					is_duplicate = !v__ast__Interface_has_method(&(*type_sym->info._v__ast__Interface), name);
				}
			}
			if (is_duplicate) {
				v__parser__Parser_error_with_pos(p, _STR("duplicate method `%.*s\000`", 2, name), pos);
				 v__ast__FnDecl _t2347 = (v__ast__FnDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.params = __new_array(0, 1, sizeof(v__ast__Param)),.is_deprecated = 0,.is_pub = 0,.is_variadic = 0,.is_anon = 0,.is_manualfree = 0,.is_main = 0,.is_test = 0,.is_conditional = 0,.is_keep_alive = 0,.receiver = (v__ast__StructField){.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),},.receiver_pos = {0},.is_method = 0,.method_type_pos = {0},.method_idx = 0,.rec_mut = 0,.rec_share = 0,.language = 0,.no_body = 0,.is_builtin = 0,.body_pos = {0},.file = (string){.str=(byteptr)"", .is_lit=1},.generic_names = __new_array(0, 1, sizeof(string)),.is_direct_arr = 0,.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.skip_gen = 0,.stmts = __new_array(0, 1, sizeof(v__ast__Stmt)),.defer_stmts = __new_array(0, 1, sizeof(v__ast__DeferStmt)),.return_type = 0,.return_type_pos = {0},.has_return = 0,.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.next_comments = __new_array(0, 1, sizeof(v__ast__Comment)),.source_file = 0,.scope = 0,.label_names = __new_array(0, 1, sizeof(string)),.pos = {0},};
				// autofree_scope_vars(pos=6656 line_nr=246 scope.pos=6597 scope.end_pos=6699)
				// af parent scope:
				// var "is_duplicate" var.pos=6250 var.line_nr=236
				// af parent scope:
				// var "pos" var.pos=5816 var.line_nr=224
				// var "type_sym" var.pos=6181 var.line_nr=234
				// af parent scope:
				// var "p" var.pos=4316 var.line_nr=173
				// var "start_pos" var.pos=4381 var.line_nr=175
				// var "is_manualfree" var.pos=4412 var.line_nr=176
				// var "is_deprecated" var.pos=4480 var.line_nr=177
				// var "is_direct_arr" var.pos=4529 var.line_nr=178
				// var "is_conditional" var.pos=4587 var.line_nr=179
				// var "conditional_ctdefine" var.pos=4603 var.line_nr=179
				// var "is_unsafe" var.pos=4662 var.line_nr=180
				// var "is_keep_alive" var.pos=4703 var.line_nr=181
				// var "is_pub" var.pos=4757 var.line_nr=182
				// var "language" var.pos=4870 var.line_nr=189
				// var "rec" var.pos=5367 var.line_nr=206
				// var "is_method" var.pos=5445 var.line_nr=210
				// var "params" var.pos=5469 var.line_nr=211
				// var "name" var.pos=5777 var.line_nr=222
				// str literal
				// var "generic_names" var.pos=7549 var.line_nr=276
				// var "args2" var.pos=7600 var.line_nr=278
				// var "are_args_type_only" var.pos=7607 var.line_nr=278
				// var "is_variadic" var.pos=7627 var.line_nr=278
				// var "return_type_pos" var.pos=8117 var.line_nr=300
				// var "return_type" var.pos=8158 var.line_nr=301
				// var "same_line" var.pos=8251 var.line_nr=303
				// var "type_sym_method_idx" var.pos=8523 var.line_nr=309
				// var "no_body" var.pos=8549 var.line_nr=310
				// var "end_pos" var.pos=8581 var.line_nr=311
				// var "short_fn_name" var.pos=8615 var.line_nr=312
				// var "is_main" var.pos=8638 var.line_nr=313
				// var "is_test" var.pos=8693 var.line_nr=314
				// var "stmts" var.pos=10842 var.line_nr=386
				// var "body_start_pos" var.pos=10865 var.line_nr=387
				// var "fn_decl" var.pos=11368 var.line_nr=404
				// af parent scope:
				// af parent scope:
				return _t2347;
			}
		}
		if (!is_method && !p->builtin_mod && (Array_string_contains(_const_v__parser__builtin_functions, name))) {
			v__parser__Parser_error_with_pos(p, _STR("cannot redefine builtin function `%.*s\000`", 2, name), pos);
			 v__ast__FnDecl _t2348 = (v__ast__FnDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.params = __new_array(0, 1, sizeof(v__ast__Param)),.is_deprecated = 0,.is_pub = 0,.is_variadic = 0,.is_anon = 0,.is_manualfree = 0,.is_main = 0,.is_test = 0,.is_conditional = 0,.is_keep_alive = 0,.receiver = (v__ast__StructField){.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),},.receiver_pos = {0},.is_method = 0,.method_type_pos = {0},.method_idx = 0,.rec_mut = 0,.rec_share = 0,.language = 0,.no_body = 0,.is_builtin = 0,.body_pos = {0},.file = (string){.str=(byteptr)"", .is_lit=1},.generic_names = __new_array(0, 1, sizeof(string)),.is_direct_arr = 0,.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.skip_gen = 0,.stmts = __new_array(0, 1, sizeof(v__ast__Stmt)),.defer_stmts = __new_array(0, 1, sizeof(v__ast__DeferStmt)),.return_type = 0,.return_type_pos = {0},.has_return = 0,.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.next_comments = __new_array(0, 1, sizeof(v__ast__Comment)),.source_file = 0,.scope = 0,.label_names = __new_array(0, 1, sizeof(string)),.pos = {0},};
			// autofree_scope_vars(pos=6879 line_nr=254 scope.pos=6806 scope.end_pos=6919)
			// af parent scope:
			// var "pos" var.pos=5816 var.line_nr=224
			// var "type_sym" var.pos=6181 var.line_nr=234
			// af parent scope:
			// var "p" var.pos=4316 var.line_nr=173
			// var "start_pos" var.pos=4381 var.line_nr=175
			// var "is_manualfree" var.pos=4412 var.line_nr=176
			// var "is_deprecated" var.pos=4480 var.line_nr=177
			// var "is_direct_arr" var.pos=4529 var.line_nr=178
			// var "is_conditional" var.pos=4587 var.line_nr=179
			// var "conditional_ctdefine" var.pos=4603 var.line_nr=179
			// var "is_unsafe" var.pos=4662 var.line_nr=180
			// var "is_keep_alive" var.pos=4703 var.line_nr=181
			// var "is_pub" var.pos=4757 var.line_nr=182
			// var "language" var.pos=4870 var.line_nr=189
			// var "rec" var.pos=5367 var.line_nr=206
			// var "is_method" var.pos=5445 var.line_nr=210
			// var "params" var.pos=5469 var.line_nr=211
			// var "name" var.pos=5777 var.line_nr=222
			// str literal
			// var "generic_names" var.pos=7549 var.line_nr=276
			// var "args2" var.pos=7600 var.line_nr=278
			// var "are_args_type_only" var.pos=7607 var.line_nr=278
			// var "is_variadic" var.pos=7627 var.line_nr=278
			// var "return_type_pos" var.pos=8117 var.line_nr=300
			// var "return_type" var.pos=8158 var.line_nr=301
			// var "same_line" var.pos=8251 var.line_nr=303
			// var "type_sym_method_idx" var.pos=8523 var.line_nr=309
			// var "no_body" var.pos=8549 var.line_nr=310
			// var "end_pos" var.pos=8581 var.line_nr=311
			// var "short_fn_name" var.pos=8615 var.line_nr=312
			// var "is_main" var.pos=8638 var.line_nr=313
			// var "is_test" var.pos=8693 var.line_nr=314
			// var "stmts" var.pos=10842 var.line_nr=386
			// var "body_start_pos" var.pos=10865 var.line_nr=387
			// var "fn_decl" var.pos=11368 var.line_nr=404
			// af parent scope:
			// af parent scope:
			return _t2348;
		}
	} else if ((p->tok.kind == v__token__Kind_plus || p->tok.kind == v__token__Kind_minus || p->tok.kind == v__token__Kind_mul || p->tok.kind == v__token__Kind_div || p->tok.kind == v__token__Kind_mod || p->tok.kind == v__token__Kind_lt || p->tok.kind == v__token__Kind_eq) && p->peek_tok.kind == v__token__Kind_lpar) {
		name = v__token__Kind_str(p->tok.kind);
		if (v__ast__Type_alias_eq(rec.typ, _const_v__ast__void_type)) {
			v__parser__Parser_error_with_pos(p, _SLIT("cannot use operator overloading with normal functions"), v__token__Token_position(&p->tok));
		}
		v__parser__Parser_next(p);
	} else if ((p->tok.kind == v__token__Kind_ne || p->tok.kind == v__token__Kind_gt || p->tok.kind == v__token__Kind_ge || p->tok.kind == v__token__Kind_le) && p->peek_tok.kind == v__token__Kind_lpar) {
		v__parser__Parser_error_with_pos(p, _SLIT("cannot overload `!=`, `>`, `<=` and `>=` as they are auto generated from `==` and`<`"), v__token__Token_position(&p->tok));
	} else {
		v__token__Position pos = v__token__Token_position(&p->tok);
		v__parser__Parser_error_with_pos(p, _SLIT("expecting method name"), pos);
		 v__ast__FnDecl _t2349 = (v__ast__FnDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.params = __new_array(0, 1, sizeof(v__ast__Param)),.is_deprecated = 0,.is_pub = 0,.is_variadic = 0,.is_anon = 0,.is_manualfree = 0,.is_main = 0,.is_test = 0,.is_conditional = 0,.is_keep_alive = 0,.receiver = (v__ast__StructField){.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),},.receiver_pos = {0},.is_method = 0,.method_type_pos = {0},.method_idx = 0,.rec_mut = 0,.rec_share = 0,.language = 0,.no_body = 0,.is_builtin = 0,.body_pos = {0},.file = (string){.str=(byteptr)"", .is_lit=1},.generic_names = __new_array(0, 1, sizeof(string)),.is_direct_arr = 0,.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.skip_gen = 0,.stmts = __new_array(0, 1, sizeof(v__ast__Stmt)),.defer_stmts = __new_array(0, 1, sizeof(v__ast__DeferStmt)),.return_type = 0,.return_type_pos = {0},.has_return = 0,.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.next_comments = __new_array(0, 1, sizeof(v__ast__Comment)),.source_file = 0,.scope = 0,.label_names = __new_array(0, 1, sizeof(string)),.pos = {0},};
		// autofree_scope_vars(pos=7501 line_nr=271 scope.pos=7423 scope.end_pos=7538)
		// var "pos" var.pos=7427 var.line_nr=269
		// af parent scope:
		// var "p" var.pos=4316 var.line_nr=173
		// var "start_pos" var.pos=4381 var.line_nr=175
		// var "is_manualfree" var.pos=4412 var.line_nr=176
		// var "is_deprecated" var.pos=4480 var.line_nr=177
		// var "is_direct_arr" var.pos=4529 var.line_nr=178
		// var "is_conditional" var.pos=4587 var.line_nr=179
		// var "conditional_ctdefine" var.pos=4603 var.line_nr=179
		// var "is_unsafe" var.pos=4662 var.line_nr=180
		// var "is_keep_alive" var.pos=4703 var.line_nr=181
		// var "is_pub" var.pos=4757 var.line_nr=182
		// var "language" var.pos=4870 var.line_nr=189
		// var "rec" var.pos=5367 var.line_nr=206
		// var "is_method" var.pos=5445 var.line_nr=210
		// var "params" var.pos=5469 var.line_nr=211
		// var "name" var.pos=5777 var.line_nr=222
		// str literal
		// var "generic_names" var.pos=7549 var.line_nr=276
		// var "args2" var.pos=7600 var.line_nr=278
		// var "are_args_type_only" var.pos=7607 var.line_nr=278
		// var "is_variadic" var.pos=7627 var.line_nr=278
		// var "return_type_pos" var.pos=8117 var.line_nr=300
		// var "return_type" var.pos=8158 var.line_nr=301
		// var "same_line" var.pos=8251 var.line_nr=303
		// var "type_sym_method_idx" var.pos=8523 var.line_nr=309
		// var "no_body" var.pos=8549 var.line_nr=310
		// var "end_pos" var.pos=8581 var.line_nr=311
		// var "short_fn_name" var.pos=8615 var.line_nr=312
		// var "is_main" var.pos=8638 var.line_nr=313
		// var "is_test" var.pos=8693 var.line_nr=314
		// var "stmts" var.pos=10842 var.line_nr=386
		// var "body_start_pos" var.pos=10865 var.line_nr=387
		// var "fn_decl" var.pos=11368 var.line_nr=404
		// af parent scope:
		// af parent scope:
		return _t2349;
	}
	Array_string generic_names = v__parser__Parser_parse_generic_names(p);
	multi_return_Array_v__ast__Param_bool_bool mr_7639 = v__parser__Parser_fn_args(p);
	Array_v__ast__Param args2 = mr_7639.arg0;
	bool are_args_type_only = mr_7639.arg1;
	bool is_variadic = mr_7639.arg2;
	_PUSH_MANY(&params, (args2), _t2350, Array_v__ast__Param);
	if (!are_args_type_only) {
		// FOR IN array
		for (int _t2351 = 0; _t2351 < params.len; ++_t2351) {
			v__ast__Param param = ((v__ast__Param*)params.data)[_t2351];
			if (v__ast__Scope_known_var(p->scope, param.name)) {
				v__parser__Parser_error_with_pos(p, _STR("redefinition of parameter `%.*s\000`", 2, param.name), param.pos);
				 v__ast__FnDecl _t2352 = (v__ast__FnDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.params = __new_array(0, 1, sizeof(v__ast__Param)),.is_deprecated = 0,.is_pub = 0,.is_variadic = 0,.is_anon = 0,.is_manualfree = 0,.is_main = 0,.is_test = 0,.is_conditional = 0,.is_keep_alive = 0,.receiver = (v__ast__StructField){.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),},.receiver_pos = {0},.is_method = 0,.method_type_pos = {0},.method_idx = 0,.rec_mut = 0,.rec_share = 0,.language = 0,.no_body = 0,.is_builtin = 0,.body_pos = {0},.file = (string){.str=(byteptr)"", .is_lit=1},.generic_names = __new_array(0, 1, sizeof(string)),.is_direct_arr = 0,.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.skip_gen = 0,.stmts = __new_array(0, 1, sizeof(v__ast__Stmt)),.defer_stmts = __new_array(0, 1, sizeof(v__ast__DeferStmt)),.return_type = 0,.return_type_pos = {0},.has_return = 0,.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.next_comments = __new_array(0, 1, sizeof(v__ast__Comment)),.source_file = 0,.scope = 0,.label_names = __new_array(0, 1, sizeof(string)),.pos = {0},};
				// autofree_scope_vars(pos=7837 line_nr=284 scope.pos=7757 scope.end_pos=7880)
				// af parent scope:
				// var "param" var.pos=7703 var.line_nr=281
				// skipping tmp var "param"
				// af parent scope:
				// af parent scope:
				// var "p" var.pos=4316 var.line_nr=173
				// var "start_pos" var.pos=4381 var.line_nr=175
				// var "is_manualfree" var.pos=4412 var.line_nr=176
				// var "is_deprecated" var.pos=4480 var.line_nr=177
				// var "is_direct_arr" var.pos=4529 var.line_nr=178
				// var "is_conditional" var.pos=4587 var.line_nr=179
				// var "conditional_ctdefine" var.pos=4603 var.line_nr=179
				// var "is_unsafe" var.pos=4662 var.line_nr=180
				// var "is_keep_alive" var.pos=4703 var.line_nr=181
				// var "is_pub" var.pos=4757 var.line_nr=182
				// var "language" var.pos=4870 var.line_nr=189
				// var "rec" var.pos=5367 var.line_nr=206
				// var "is_method" var.pos=5445 var.line_nr=210
				// var "params" var.pos=5469 var.line_nr=211
				// var "name" var.pos=5777 var.line_nr=222
				// str literal
				// var "generic_names" var.pos=7549 var.line_nr=276
				// var "args2" var.pos=7600 var.line_nr=278
				// var "are_args_type_only" var.pos=7607 var.line_nr=278
				// var "is_variadic" var.pos=7627 var.line_nr=278
				// var "return_type_pos" var.pos=8117 var.line_nr=300
				// var "return_type" var.pos=8158 var.line_nr=301
				// var "same_line" var.pos=8251 var.line_nr=303
				// var "type_sym_method_idx" var.pos=8523 var.line_nr=309
				// var "no_body" var.pos=8549 var.line_nr=310
				// var "end_pos" var.pos=8581 var.line_nr=311
				// var "short_fn_name" var.pos=8615 var.line_nr=312
				// var "is_main" var.pos=8638 var.line_nr=313
				// var "is_test" var.pos=8693 var.line_nr=314
				// var "stmts" var.pos=10842 var.line_nr=386
				// var "body_start_pos" var.pos=10865 var.line_nr=387
				// var "fn_decl" var.pos=11368 var.line_nr=404
				// af parent scope:
				// af parent scope:
				return _t2352;
			}
			v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){
				.name = param.name,
				.expr = {0},
				.share = 0,
				.is_mut = param.is_mut,
				.is_autofree_tmp = 0,
				.is_arg = true,
				.is_auto_deref = param.is_mut || param.is_auto_rec,
				.typ = param.typ,
				.orig_type = 0,
				.smartcasts = __new_array(0, 1, sizeof(v__ast__Type)),
				.pos = param.pos,
				.is_used = true,
				.is_changed = 0,
				.is_or = 0,
				.is_tmp = 0,
			}))));
		}
	}
	v__token__Position return_type_pos = v__token__Token_position(&p->tok);
	v__ast__Type return_type = _const_v__ast__void_type;
	bool same_line = p->tok.line_nr == p->prev_tok.line_nr;
	if ((v__token__Kind_is_start_of_type(p->tok.kind) && (same_line || p->tok.kind != v__token__Kind_lsbr)) || (same_line && p->tok.kind == v__token__Kind_key_fn)) {
		return_type = v__parser__Parser_parse_type(p);
		return_type_pos = v__token__Position_extend(return_type_pos, v__token__Token_position(&p->prev_tok));
	}
	int type_sym_method_idx = 0;
	bool no_body = p->tok.kind != v__token__Kind_lcbr;
	v__token__Position end_pos = v__token__Token_position(&p->prev_tok);
	string short_fn_name = name;
	bool is_main = string_eq(short_fn_name, _SLIT("main")) && string_eq(p->mod, _SLIT("main"));
	bool is_test = string_starts_with(short_fn_name, _SLIT("test_")) || string_starts_with(short_fn_name, _SLIT("testsuite_"));
	if (is_method) {
		v__ast__TypeSymbol* type_sym = v__ast__Table_get_type_symbol(p->table, rec.typ);
		bool is_non_local = type_sym->mod.len > 0 && string_ne(type_sym->mod, p->mod) && type_sym->language == v__ast__Language_v;
		if (!is_non_local && (type_sym->kind == v__ast__Kind_array || type_sym->kind == v__ast__Kind_map)) {
			v__ast__TypeSymbol* elem_type_sym = v__ast__Table_get_type_symbol(p->table, v__ast__Table_value_type(p->table, rec.typ));
			is_non_local = elem_type_sym->mod.len > 0 && string_ne(elem_type_sym->mod, p->mod) && elem_type_sym->language == v__ast__Language_v;
		}
		if (is_non_local) {
			v__parser__Parser_error_with_pos(p, _STR("cannot define new methods on non-local type %.*s", 1, type_sym->name), rec.type_pos);
			 v__ast__FnDecl _t2353 = (v__ast__FnDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.params = __new_array(0, 1, sizeof(v__ast__Param)),.is_deprecated = 0,.is_pub = 0,.is_variadic = 0,.is_anon = 0,.is_manualfree = 0,.is_main = 0,.is_test = 0,.is_conditional = 0,.is_keep_alive = 0,.receiver = (v__ast__StructField){.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),},.receiver_pos = {0},.is_method = 0,.method_type_pos = {0},.method_idx = 0,.rec_mut = 0,.rec_share = 0,.language = 0,.no_body = 0,.is_builtin = 0,.body_pos = {0},.file = (string){.str=(byteptr)"", .is_lit=1},.generic_names = __new_array(0, 1, sizeof(string)),.is_direct_arr = 0,.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.skip_gen = 0,.stmts = __new_array(0, 1, sizeof(v__ast__Stmt)),.defer_stmts = __new_array(0, 1, sizeof(v__ast__DeferStmt)),.return_type = 0,.return_type_pos = {0},.has_return = 0,.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.next_comments = __new_array(0, 1, sizeof(v__ast__Comment)),.source_file = 0,.scope = 0,.label_names = __new_array(0, 1, sizeof(string)),.pos = {0},};
			// autofree_scope_vars(pos=9618 line_nr=331 scope.pos=9514 scope.end_pos=9658)
			// af parent scope:
			// var "type_sym" var.pos=8817 var.line_nr=317
			// var "is_non_local" var.pos=9090 var.line_nr=321
			// af parent scope:
			// var "p" var.pos=4316 var.line_nr=173
			// var "start_pos" var.pos=4381 var.line_nr=175
			// var "is_manualfree" var.pos=4412 var.line_nr=176
			// var "is_deprecated" var.pos=4480 var.line_nr=177
			// var "is_direct_arr" var.pos=4529 var.line_nr=178
			// var "is_conditional" var.pos=4587 var.line_nr=179
			// var "conditional_ctdefine" var.pos=4603 var.line_nr=179
			// var "is_unsafe" var.pos=4662 var.line_nr=180
			// var "is_keep_alive" var.pos=4703 var.line_nr=181
			// var "is_pub" var.pos=4757 var.line_nr=182
			// var "language" var.pos=4870 var.line_nr=189
			// var "rec" var.pos=5367 var.line_nr=206
			// var "is_method" var.pos=5445 var.line_nr=210
			// var "params" var.pos=5469 var.line_nr=211
			// var "name" var.pos=5777 var.line_nr=222
			// str literal
			// var "generic_names" var.pos=7549 var.line_nr=276
			// var "args2" var.pos=7600 var.line_nr=278
			// var "are_args_type_only" var.pos=7607 var.line_nr=278
			// var "is_variadic" var.pos=7627 var.line_nr=278
			// var "return_type_pos" var.pos=8117 var.line_nr=300
			// var "return_type" var.pos=8158 var.line_nr=301
			// var "same_line" var.pos=8251 var.line_nr=303
			// var "type_sym_method_idx" var.pos=8523 var.line_nr=309
			// var "no_body" var.pos=8549 var.line_nr=310
			// var "end_pos" var.pos=8581 var.line_nr=311
			// var "short_fn_name" var.pos=8615 var.line_nr=312
			// var "is_main" var.pos=8638 var.line_nr=313
			// var "is_test" var.pos=8693 var.line_nr=314
			// var "stmts" var.pos=10842 var.line_nr=386
			// var "body_start_pos" var.pos=10865 var.line_nr=387
			// var "fn_decl" var.pos=11368 var.line_nr=404
			// af parent scope:
			// af parent scope:
			return _t2353;
		}
		type_sym_method_idx = v__ast__TypeSymbol_register_method(type_sym, (v__ast__Fn){
			.params = params,
			.return_type = return_type,
			.is_variadic = is_variadic,
			.language = 0,
			.generic_names = generic_names,
			.is_pub = is_pub,
			.is_deprecated = is_deprecated,
			.is_unsafe = is_unsafe,
			.is_placeholder = 0,
			.is_main = is_main,
			.is_test = is_test,
			.is_conditional = is_conditional,
			.is_keep_alive = is_keep_alive,
			.no_body = no_body,
			.mod = p->mod,
			.ctdefine = conditional_ctdefine,
			.attrs = p->attrs,
			.name = name,
			.source_fn = 0,
			.usages = 0,
		});
	} else {
		if (language == v__ast__Language_c) {
			name = _STR("C.%.*s", 1, name);
		} else if (language == v__ast__Language_js) {
			name = _STR("JS.%.*s", 1, name);
		} else {
			name = v__parser__Parser_prepend_mod(p, name);
		}
		if (!p->pref->translated && language == v__ast__Language_v && _IN_MAP(ADDR(string, name), ADDR(map, p->table->fns))) {
			array_push(&p->table->redefined_fns, _MOV((string[]){ string_clone(name) }));
		}
		v__ast__Table_register_fn(p->table, (v__ast__Fn){
			.params = params,
			.return_type = return_type,
			.is_variadic = is_variadic,
			.language = language,
			.generic_names = generic_names,
			.is_pub = is_pub,
			.is_deprecated = is_deprecated,
			.is_unsafe = is_unsafe,
			.is_placeholder = 0,
			.is_main = is_main,
			.is_test = is_test,
			.is_conditional = is_conditional,
			.is_keep_alive = is_keep_alive,
			.no_body = no_body,
			.mod = p->mod,
			.ctdefine = conditional_ctdefine,
			.attrs = p->attrs,
			.name = name,
			.source_fn = 0,
			.usages = 0,
		});
	}
	p->cur_fn_name = name;
	Array_v__ast__Stmt stmts = __new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
	v__token__Position body_start_pos = v__token__Token_position(&p->peek_tok);
	if (p->tok.kind == v__token__Kind_lcbr) {
		p->inside_fn = true;
		p->inside_unsafe_fn = is_unsafe;
		stmts = v__parser__Parser_parse_block_no_scope(p, true);
		p->inside_unsafe_fn = false;
		p->inside_fn = false;
	}
	if (!no_body && are_args_type_only) {
		v__parser__Parser_error_with_pos(p, _SLIT("functions with type only args can not have bodies"), body_start_pos);
		 v__ast__FnDecl _t2355 = (v__ast__FnDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.params = __new_array(0, 1, sizeof(v__ast__Param)),.is_deprecated = 0,.is_pub = 0,.is_variadic = 0,.is_anon = 0,.is_manualfree = 0,.is_main = 0,.is_test = 0,.is_conditional = 0,.is_keep_alive = 0,.receiver = (v__ast__StructField){.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),},.receiver_pos = {0},.is_method = 0,.method_type_pos = {0},.method_idx = 0,.rec_mut = 0,.rec_share = 0,.language = 0,.no_body = 0,.is_builtin = 0,.body_pos = {0},.file = (string){.str=(byteptr)"", .is_lit=1},.generic_names = __new_array(0, 1, sizeof(string)),.is_direct_arr = 0,.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.skip_gen = 0,.stmts = __new_array(0, 1, sizeof(v__ast__Stmt)),.defer_stmts = __new_array(0, 1, sizeof(v__ast__DeferStmt)),.return_type = 0,.return_type_pos = {0},.has_return = 0,.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.next_comments = __new_array(0, 1, sizeof(v__ast__Comment)),.source_file = 0,.scope = 0,.label_names = __new_array(0, 1, sizeof(string)),.pos = {0},};
		// autofree_scope_vars(pos=11204 line_nr=397 scope.pos=11113 scope.end_pos=11241)
		// af parent scope:
		// var "p" var.pos=4316 var.line_nr=173
		// var "start_pos" var.pos=4381 var.line_nr=175
		// var "is_manualfree" var.pos=4412 var.line_nr=176
		// var "is_deprecated" var.pos=4480 var.line_nr=177
		// var "is_direct_arr" var.pos=4529 var.line_nr=178
		// var "is_conditional" var.pos=4587 var.line_nr=179
		// var "conditional_ctdefine" var.pos=4603 var.line_nr=179
		// var "is_unsafe" var.pos=4662 var.line_nr=180
		// var "is_keep_alive" var.pos=4703 var.line_nr=181
		// var "is_pub" var.pos=4757 var.line_nr=182
		// var "language" var.pos=4870 var.line_nr=189
		// var "rec" var.pos=5367 var.line_nr=206
		// var "is_method" var.pos=5445 var.line_nr=210
		// var "params" var.pos=5469 var.line_nr=211
		// var "name" var.pos=5777 var.line_nr=222
		// str literal
		// var "generic_names" var.pos=7549 var.line_nr=276
		// var "args2" var.pos=7600 var.line_nr=278
		// var "are_args_type_only" var.pos=7607 var.line_nr=278
		// var "is_variadic" var.pos=7627 var.line_nr=278
		// var "return_type_pos" var.pos=8117 var.line_nr=300
		// var "return_type" var.pos=8158 var.line_nr=301
		// var "same_line" var.pos=8251 var.line_nr=303
		// var "type_sym_method_idx" var.pos=8523 var.line_nr=309
		// var "no_body" var.pos=8549 var.line_nr=310
		// var "end_pos" var.pos=8581 var.line_nr=311
		// var "short_fn_name" var.pos=8615 var.line_nr=312
		// var "is_main" var.pos=8638 var.line_nr=313
		// var "is_test" var.pos=8693 var.line_nr=314
		// var "stmts" var.pos=10842 var.line_nr=386
		// var "body_start_pos" var.pos=10865 var.line_nr=387
		// var "fn_decl" var.pos=11368 var.line_nr=404
		// af parent scope:
		// af parent scope:
		return _t2355;
	}
	v__ast__FnDecl fn_decl = (v__ast__FnDecl){
		.name = name,
		.mod = p->mod,
		.params = params,
		.is_deprecated = is_deprecated,
		.is_pub = is_pub,
		.is_variadic = is_variadic,
		.is_anon = 0,
		.is_manualfree = is_manualfree,
		.is_main = is_main,
		.is_test = is_test,
		.is_conditional = is_conditional,
		.is_keep_alive = is_keep_alive,
		.receiver = (v__ast__StructField){.pos = {0},.type_pos = {0},.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.default_expr = {0},.has_default_expr = 0,.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.is_pub = 0,.default_val = (string){.str=(byteptr)"", .is_lit=1},.is_mut = 0,.is_global = 0,.default_expr_typ = 0,.name = rec.name,.typ = rec.typ,},
		.receiver_pos = rec.pos,
		.is_method = is_method,
		.method_type_pos = rec.type_pos,
		.method_idx = type_sym_method_idx,
		.rec_mut = rec.is_mut,
		.rec_share = 0,
		.language = language,
		.no_body = no_body,
		.is_builtin = p->builtin_mod || (Array_string_contains(_const_v__util__builtin_module_parts, p->mod)),
		.body_pos = body_start_pos,
		.file = p->file_name,
		.generic_names = generic_names,
		.is_direct_arr = is_direct_arr,
		.attrs = p->attrs,
		.skip_gen = 0,
		.stmts = stmts,
		.defer_stmts = __new_array(0, 1, sizeof(v__ast__DeferStmt)),
		.return_type = return_type,
		.return_type_pos = return_type_pos,
		.has_return = 0,
		.comments = __new_array(0, 1, sizeof(v__ast__Comment)),
		.next_comments = __new_array(0, 1, sizeof(v__ast__Comment)),
		.source_file = 0,
		.scope = p->scope,
		.label_names = p->label_names,
		.pos = v__token__Position_extend_with_last_line(start_pos, end_pos, p->prev_tok.line_nr),
	};
	p->label_names = __new_array_with_default(0, 0, sizeof(string), 0);
	v__parser__Parser_close_scope(p);
	// autofree_scope_vars(pos=12307 line_nr=442 scope.pos=4311 scope.end_pos=12323)
	// var "p" var.pos=4316 var.line_nr=173
	// var "start_pos" var.pos=4381 var.line_nr=175
	// var "is_manualfree" var.pos=4412 var.line_nr=176
	// var "is_deprecated" var.pos=4480 var.line_nr=177
	// var "is_direct_arr" var.pos=4529 var.line_nr=178
	// var "is_conditional" var.pos=4587 var.line_nr=179
	// var "conditional_ctdefine" var.pos=4603 var.line_nr=179
	// var "is_unsafe" var.pos=4662 var.line_nr=180
	// var "is_keep_alive" var.pos=4703 var.line_nr=181
	// var "is_pub" var.pos=4757 var.line_nr=182
	// var "language" var.pos=4870 var.line_nr=189
	// var "rec" var.pos=5367 var.line_nr=206
	// var "is_method" var.pos=5445 var.line_nr=210
	// var "params" var.pos=5469 var.line_nr=211
	// var "name" var.pos=5777 var.line_nr=222
	// str literal
	// var "generic_names" var.pos=7549 var.line_nr=276
	// var "args2" var.pos=7600 var.line_nr=278
	// var "are_args_type_only" var.pos=7607 var.line_nr=278
	// var "is_variadic" var.pos=7627 var.line_nr=278
	// var "return_type_pos" var.pos=8117 var.line_nr=300
	// var "return_type" var.pos=8158 var.line_nr=301
	// var "same_line" var.pos=8251 var.line_nr=303
	// var "type_sym_method_idx" var.pos=8523 var.line_nr=309
	// var "no_body" var.pos=8549 var.line_nr=310
	// var "end_pos" var.pos=8581 var.line_nr=311
	// var "short_fn_name" var.pos=8615 var.line_nr=312
	// var "is_main" var.pos=8638 var.line_nr=313
	// var "is_test" var.pos=8693 var.line_nr=314
	// var "stmts" var.pos=10842 var.line_nr=386
	// var "body_start_pos" var.pos=10865 var.line_nr=387
	// var "fn_decl" var.pos=11368 var.line_nr=404
	// af parent scope:
	// af parent scope:
	return fn_decl;
}

VV_LOCAL_SYMBOL Option_void v__parser__Parser_fn_receiver(v__parser__Parser* p, Array_v__ast__Param* params, v__parser__ReceiverParsingInfo* rec) {
	v__token__Position lpar_pos = v__token__Token_position(&p->tok);
	v__parser__Parser_next(p);
	bool is_shared = p->tok.kind == v__token__Kind_key_shared;
	bool is_atomic = p->tok.kind == v__token__Kind_key_atomic;
	rec->is_mut = p->tok.kind == v__token__Kind_key_mut || is_shared || is_atomic;
	if (rec->is_mut) {
		v__parser__Parser_next(p);
	}
	v__token__Position rec_start_pos = v__token__Token_position(&p->tok);
	rec->name = v__parser__Parser_check_name(p);
	if (!rec->is_mut) {
		rec->is_mut = p->tok.kind == v__token__Kind_key_mut;
		if (rec->is_mut) {
			v__token__Token ptoken2 = v__parser__Parser_peek_token(p, 2);
			v__parser__Parser_warn_with_pos(p, _SLIT("use `(mut f Foo)` instead of `(f mut Foo)`"), v__token__Position_extend(lpar_pos, v__token__Token_position(&ptoken2)));
		}
	}
	if (p->tok.kind == v__token__Kind_key_shared) {
		v__token__Token ptoken2 = v__parser__Parser_peek_token(p, 2);
		v__parser__Parser_error_with_pos(p, _SLIT("use `(shared f Foo)` instead of `(f shared Foo)`"), v__token__Position_extend(lpar_pos, v__token__Token_position(&ptoken2)));
	}
	rec->pos = v__token__Position_extend(rec_start_pos, v__token__Token_position(&p->tok));
	bool is_amp = p->tok.kind == v__token__Kind_amp;
	if (p->tok.kind == v__token__Kind_name && string_eq(p->tok.lit, _SLIT("JS"))) {
		rec->language = v__ast__Language_js;
	}
	rec->type_pos = v__token__Token_position(&p->tok);
	rec->typ = v__parser__Parser_parse_type_with_mut(p, rec->is_mut);
	if (v__ast__Type_idx(rec->typ) == 0) {
		return (Option_void){ .state=2, .err=_const_none__ };
	}
	rec->type_pos = v__token__Position_extend(rec->type_pos, v__token__Token_position(&p->prev_tok));
	if (is_amp && rec->is_mut) {
		v__parser__Parser_error_with_pos(p, _SLIT("use `(mut f Foo)` or `(f &Foo)` instead of `(mut f &Foo)`"), v__token__Position_extend(lpar_pos, v__token__Token_position(&p->tok)));
		return (Option_void){ .state=2, .err=_const_none__ };
	}
	if (is_shared) {
		rec->typ = v__ast__Type_set_flag(rec->typ, v__ast__TypeFlag_shared_f);
	}
	if (is_atomic) {
		rec->typ = v__ast__Type_set_flag(rec->typ, v__ast__TypeFlag_atomic_f);
	}
	v__ast__TypeSymbol* type_sym = v__ast__Table_get_type_symbol(p->table, rec->typ);
	bool is_auto_rec = false;
	if (type_sym->kind == v__ast__Kind_struct_) {
		v__ast__Struct info = /* as */ *(v__ast__Struct*)__as_cast((type_sym->info)._v__ast__Struct,(type_sym->info)._typ, 409) /*expected idx: 409, name: v.ast.Struct */ ;
		if (!rec->is_mut && !v__ast__Type_is_ptr(rec->typ) && info.fields.len > 8) {
			rec->typ = v__ast__Type_to_ptr(rec->typ);
			is_auto_rec = true;
		}
	}
	array_push(params, _MOV((v__ast__Param[]){ (v__ast__Param){
		.pos = rec_start_pos,
		.name = rec->name,
		.is_mut = rec->is_mut,
		.is_auto_rec = is_auto_rec,
		.typ = rec->typ,
		.type_pos = rec->type_pos,
		.is_hidden = 0,
	} }));
	v__parser__Parser_check(p, v__token__Kind_rpar);
	return (Option_void){0};
}

VV_LOCAL_SYMBOL Array_string v__parser__Parser_parse_generic_names(v__parser__Parser* p) {
	Array_string param_names = __new_array_with_default(0, 0, sizeof(string), 0);
	if (p->tok.kind != v__token__Kind_lt) {
		// autofree_scope_vars(pos=14710 line_nr=522 scope.pos=14707 scope.end_pos=14731)
		// af parent scope:
		// var "p" var.pos=14611 var.line_nr=519
		// var "param_names" var.pos=14659 var.line_nr=520
		// var "first_done" var.pos=14752 var.line_nr=525
		// var "count" var.pos=14777 var.line_nr=526
		// af parent scope:
		// af parent scope:
		return param_names;
	}
	v__parser__Parser_check(p, v__token__Kind_lt);
	bool first_done = false;
	int count = 0;
	for (;;) {
		if (!(!(p->tok.kind == v__token__Kind_gt || p->tok.kind == v__token__Kind_eof))) break;
		if (first_done) {
			v__parser__Parser_check(p, v__token__Kind_comma);
		}
		string name = p->tok.lit;
		if (name.len > 0 && !byte_is_capital(string_at(name, 0))) {
			v__parser__Parser_error(p, _SLIT("generic parameter needs to be uppercase"));
		}
		if (name.len > 1) {
			v__parser__Parser_error(p, _SLIT("generic parameter name needs to be exactly one char"));
		}
		if (!v__util__is_generic_type_name(p->tok.lit)) {
			v__parser__Parser_error(p, _STR("`%.*s\000` is a reserved name and cannot be used for generics", 2, p->tok.lit));
		}
		if ((Array_string_contains(param_names, name))) {
			v__parser__Parser_error(p, _STR("duplicated generic parameter `%.*s\000`", 2, name));
		}
		if (count > 8) {
			v__parser__Parser_error(p, _SLIT("cannot have more than 9 generic parameters"));
		}
		v__parser__Parser_check(p, v__token__Kind_name);
		array_push(&param_names, _MOV((string[]){ string_clone(name) }));
		first_done = true;
		count++;
	}
	v__parser__Parser_check(p, v__token__Kind_gt);
	// autofree_scope_vars(pos=15449 line_nr=553 scope.pos=14606 scope.end_pos=15469)
	// var "p" var.pos=14611 var.line_nr=519
	// var "param_names" var.pos=14659 var.line_nr=520
	// var "first_done" var.pos=14752 var.line_nr=525
	// var "count" var.pos=14777 var.line_nr=526
	// af parent scope:
	// af parent scope:
	return param_names;
}

VV_LOCAL_SYMBOL bool v__parser__Parser_is_generic_name(v__parser__Parser p) {
	 bool _t2358 = p.tok.kind == v__token__Kind_name && v__util__is_generic_type_name(p.tok.lit);
	// autofree_scope_vars(pos=15583 line_nr=558 scope.pos=15547 scope.end_pos=15651)
	// var "p" var.pos=15548 var.line_nr=557
	// af parent scope:
	// af parent scope:
	return _t2358;
}

VV_LOCAL_SYMBOL v__ast__AnonFn v__parser__Parser_anon_fn(v__parser__Parser* p) {
	v__token__Position pos = v__token__Token_position(&p->tok);
	v__parser__Parser_check(p, v__token__Kind_key_fn);
	if (p->pref->is_script && p->tok.kind == v__token__Kind_name) {
		v__parser__Parser_error_with_pos(p, _SLIT("function declarations in script mode should be before all script statements"), v__token__Token_position(&p->tok));
		 v__ast__AnonFn _t2359 = (v__ast__AnonFn){.decl = (v__ast__FnDecl){.params = __new_array(0, 1, sizeof(v__ast__Param)),.generic_names = __new_array(0, 1, sizeof(string)),.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.stmts = __new_array(0, 1, sizeof(v__ast__Stmt)),.defer_stmts = __new_array(0, 1, sizeof(v__ast__DeferStmt)),.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.next_comments = __new_array(0, 1, sizeof(v__ast__Comment)),.source_file = 0,.label_names = __new_array(0, 1, sizeof(string)),},.typ = 0,.has_gen = 0,};
		// autofree_scope_vars(pos=15904 line_nr=567 scope.pos=15782 scope.end_pos=15926)
		// af parent scope:
		// var "p" var.pos=15662 var.line_nr=561
		// var "pos" var.pos=15696 var.line_nr=562
		// var "args" var.pos=16000 var.line_nr=572
		// var "is_variadic" var.pos=16009 var.line_nr=572
		// var "same_line" var.pos=16298 var.line_nr=586
		// var "return_type" var.pos=16352 var.line_nr=587
		// var "return_type_pos" var.pos=16386 var.line_nr=588
		// var "stmts" var.pos=16748 var.line_nr=599
		// var "no_body" var.pos=16771 var.line_nr=600
		// var "label_names" var.pos=16997 var.line_nr=606
		// var "func" var.pos=17028 var.line_nr=607
		// var "name" var.pos=17117 var.line_nr=612
		// var "keep_fn_name" var.pos=17182 var.line_nr=613
		// var "idx" var.pos=17465 var.line_nr=625
		// var "typ" var.pos=17532 var.line_nr=626
		// af parent scope:
		// af parent scope:
		return _t2359;
	}
	v__parser__Parser_open_scope(p);
	p->scope->detached_from_parent = true;
	multi_return_Array_v__ast__Param_bool_bool mr_16021 = v__parser__Parser_fn_args(p);
	Array_v__ast__Param args = mr_16021.arg0;
	bool is_variadic = mr_16021.arg2;
	// FOR IN array
	for (int _t2360 = 0; _t2360 < args.len; ++_t2360) {
		v__ast__Param arg = ((v__ast__Param*)args.data)[_t2360];
		if (arg.name.len == 0) {
			v__parser__Parser_error_with_pos(p, _SLIT("use `_` to name an unused parameter"), arg.pos);
		}
		v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){
			.name = arg.name,
			.expr = {0},
			.share = 0,
			.is_mut = arg.is_mut,
			.is_autofree_tmp = 0,
			.is_arg = true,
			.is_auto_deref = 0,
			.typ = arg.typ,
			.orig_type = 0,
			.smartcasts = __new_array(0, 1, sizeof(v__ast__Type)),
			.pos = arg.pos,
			.is_used = true,
			.is_changed = 0,
			.is_or = 0,
			.is_tmp = 0,
		}))));
	}
	bool same_line = p->tok.line_nr == p->prev_tok.line_nr;
	v__ast__Type return_type = _const_v__ast__void_type;
	v__token__Position return_type_pos = v__token__Token_position(&p->tok);
	if (same_line) {
		if (v__token__Kind_is_start_of_type(p->tok.kind)) {
			return_type = v__parser__Parser_parse_type(p);
			return_type_pos = v__token__Position_extend(return_type_pos, v__token__Token_position(&p->tok));
		} else if (p->tok.kind != v__token__Kind_lcbr) {
			v__parser__Parser_error_with_pos(p, _STR("expected return type, not %.*s\000 for anonymous function", 2, v__token__Token_str(p->tok)), v__token__Token_position(&p->tok));
		}
	}
	Array_v__ast__Stmt stmts = __new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
	bool no_body = p->tok.kind != v__token__Kind_lcbr;
	same_line = p->tok.line_nr == p->prev_tok.line_nr;
	if (no_body && same_line) {
		v__parser__Parser_error_with_pos(p, _STR("unexpected %.*s\000 after anonymous function signature, expecting `{`", 2, v__token__Token_str(p->tok)), v__token__Token_position(&p->tok));
	}
	Array_string label_names = __new_array_with_default(0, 0, sizeof(string), 0);
	v__ast__Fn func = (v__ast__Fn){.params = args,.return_type = return_type,.is_variadic = is_variadic,.language = 0,.generic_names = __new_array(0, 1, sizeof(string)),.is_pub = 0,.is_deprecated = 0,.is_unsafe = 0,.is_placeholder = 0,.is_main = 0,.is_test = 0,.is_conditional = 0,.is_keep_alive = 0,.no_body = 0,.mod = (string){.str=(byteptr)"", .is_lit=1},.ctdefine = (string){.str=(byteptr)"", .is_lit=1},.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.name = (string){.str=(byteptr)"", .is_lit=1},.source_fn = 0,.usages = 0,};
	string name = _STR("anon_fn_%.*s\000_%"PRId32"", 2, v__ast__Table_fn_type_signature(p->table, (voidptr)&/*qq*/func), p->tok.pos);
	string keep_fn_name = p->cur_fn_name;
	p->cur_fn_name = name;
	if (p->tok.kind == v__token__Kind_lcbr) {
		Array_string tmp = p->label_names;
		p->label_names = __new_array_with_default(0, 0, sizeof(string), 0);
		stmts = v__parser__Parser_parse_block_no_scope(p, false);
		label_names = p->label_names;
		p->label_names = tmp;
	}
	p->cur_fn_name = keep_fn_name;
	v__parser__Parser_close_scope(p);
	func.name = name;
	int idx = v__ast__Table_find_or_register_fn_type(p->table, p->mod, func, true, false);
	v__ast__Type typ = v__ast__new_type(idx);
	 v__ast__AnonFn _t2361 = (v__ast__AnonFn){.decl = (v__ast__FnDecl){
		.name = name,
		.mod = p->mod,
		.params = args,
		.is_deprecated = 0,
		.is_pub = 0,
		.is_variadic = is_variadic,
		.is_anon = true,
		.is_manualfree = 0,
		.is_main = 0,
		.is_test = 0,
		.is_conditional = 0,
		.is_keep_alive = 0,
		.receiver = (v__ast__StructField){.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),},
		.receiver_pos = {0},
		.is_method = false,
		.method_type_pos = {0},
		.method_idx = 0,
		.rec_mut = 0,
		.rec_share = 0,
		.language = 0,
		.no_body = no_body,
		.is_builtin = 0,
		.body_pos = {0},
		.file = p->file_name,
		.generic_names = __new_array(0, 1, sizeof(string)),
		.is_direct_arr = 0,
		.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),
		.skip_gen = 0,
		.stmts = stmts,
		.defer_stmts = __new_array(0, 1, sizeof(v__ast__DeferStmt)),
		.return_type = return_type,
		.return_type_pos = return_type_pos,
		.has_return = 0,
		.comments = __new_array(0, 1, sizeof(v__ast__Comment)),
		.next_comments = __new_array(0, 1, sizeof(v__ast__Comment)),
		.source_file = 0,
		.scope = p->scope,
		.label_names = label_names,
		.pos = v__token__Position_extend(pos, v__token__Token_position(&p->prev_tok)),
	},.typ = typ,.has_gen = 0,};
	// autofree_scope_vars(pos=17596 line_nr=628 scope.pos=15657 scope.end_pos=17972)
	// var "p" var.pos=15662 var.line_nr=561
	// var "pos" var.pos=15696 var.line_nr=562
	// var "args" var.pos=16000 var.line_nr=572
	// var "is_variadic" var.pos=16009 var.line_nr=572
	// var "same_line" var.pos=16298 var.line_nr=586
	// var "return_type" var.pos=16352 var.line_nr=587
	// var "return_type_pos" var.pos=16386 var.line_nr=588
	// var "stmts" var.pos=16748 var.line_nr=599
	// var "no_body" var.pos=16771 var.line_nr=600
	// var "label_names" var.pos=16997 var.line_nr=606
	// var "func" var.pos=17028 var.line_nr=607
	// var "name" var.pos=17117 var.line_nr=612
	// var "keep_fn_name" var.pos=17182 var.line_nr=613
	// var "idx" var.pos=17465 var.line_nr=625
	// var "typ" var.pos=17532 var.line_nr=626
	// af parent scope:
	// af parent scope:
	return _t2361;
}

VV_LOCAL_SYMBOL multi_return_Array_v__ast__Param_bool_bool v__parser__Parser_fn_args(v__parser__Parser* p) {
	v__parser__Parser_check(p, v__token__Kind_lpar);
	Array_v__ast__Param args = __new_array_with_default(0, 0, sizeof(v__ast__Param), 0);
	bool is_variadic = false;
	string argname = (p->tok.kind == v__token__Kind_name && p->tok.lit.len > 0 && byte_is_capital(string_at(p->tok.lit, 0)) ? (v__parser__Parser_prepend_mod(p, p->tok.lit)) : (p->tok.lit));
	bool types_only = (p->tok.kind == v__token__Kind_amp || p->tok.kind == v__token__Kind_ellipsis || p->tok.kind == v__token__Kind_key_fn || p->tok.kind == v__token__Kind_lsbr) || (p->peek_tok.kind == v__token__Kind_comma && v__ast__Table_known_type(p->table, argname)) || p->peek_tok.kind == v__token__Kind_dot || p->peek_tok.kind == v__token__Kind_rpar;
	if (types_only) {
		int arg_no = 1;
		for (;;) {
			if (!(p->tok.kind != v__token__Kind_rpar)) break;
			if (p->tok.kind == v__token__Kind_eof) {
				v__parser__Parser_error_with_pos(p, _SLIT("expecting `)`"), v__token__Token_position(&p->tok));
				return (multi_return_Array_v__ast__Param_bool_bool){.arg0=__new_array_with_default(0, 0, sizeof(v__ast__Param), 0), .arg1=false, .arg2=false};
			}
			bool is_shared = p->tok.kind == v__token__Kind_key_shared;
			bool is_atomic = p->tok.kind == v__token__Kind_key_atomic;
			bool is_mut = p->tok.kind == v__token__Kind_key_mut || is_shared || is_atomic;
			if (is_mut) {
				v__parser__Parser_next(p);
			}
			if (p->tok.kind == v__token__Kind_ellipsis) {
				v__parser__Parser_next(p);
				is_variadic = true;
			}
			v__token__Position pos = v__token__Token_position(&p->tok);
			v__ast__Type arg_type = v__parser__Parser_parse_type(p);
			if (arg_type == 0) {
				return (multi_return_Array_v__ast__Param_bool_bool){.arg0=__new_array_with_default(0, 0, sizeof(v__ast__Param), 0), .arg1=false, .arg2=false};
			}
			if (is_mut) {
				if (!v__ast__Type_has_flag(arg_type, v__ast__TypeFlag_generic)) {
					if (is_shared) {
						v__parser__Parser_check_fn_shared_arguments(p, arg_type, pos);
					} else if (is_atomic) {
						v__parser__Parser_check_fn_atomic_arguments(p, arg_type, pos);
					} else {
						v__parser__Parser_check_fn_mutable_arguments(p, arg_type, pos);
					}
				} else if (is_shared || is_atomic) {
					v__parser__Parser_error_with_pos(p, _SLIT("generic object cannot be `atomic`or `shared`"), pos);
					return (multi_return_Array_v__ast__Param_bool_bool){.arg0=__new_array_with_default(0, 0, sizeof(v__ast__Param), 0), .arg1=false, .arg2=false};
				}
				arg_type = v__ast__Type_set_nr_muls(arg_type, 1);
				if (is_shared) {
					arg_type = v__ast__Type_set_flag(arg_type, v__ast__TypeFlag_shared_f);
				}
				if (is_atomic) {
					arg_type = v__ast__Type_set_flag(arg_type, v__ast__TypeFlag_atomic_f);
				}
			}
			if (is_variadic) {
				arg_type = v__ast__Type_set_flag(v__ast__new_type(v__ast__Table_find_or_register_array(p->table, arg_type)), v__ast__TypeFlag_variadic);
			}
			if (p->tok.kind == v__token__Kind_eof) {
				v__parser__Parser_error_with_pos(p, _SLIT("expecting `)`"), v__token__Token_position(&p->prev_tok));
				return (multi_return_Array_v__ast__Param_bool_bool){.arg0=__new_array_with_default(0, 0, sizeof(v__ast__Param), 0), .arg1=false, .arg2=false};
			}
			if (p->tok.kind == v__token__Kind_comma) {
				if (is_variadic) {
					v__parser__Parser_error_with_pos(p, _STR("cannot use ...(variadic) with non-final parameter no %"PRId32"", 1, arg_no), pos);
					return (multi_return_Array_v__ast__Param_bool_bool){.arg0=__new_array_with_default(0, 0, sizeof(v__ast__Param), 0), .arg1=false, .arg2=false};
				}
				v__parser__Parser_next(p);
			}
			array_push(&args, _MOV((v__ast__Param[]){ (v__ast__Param){.pos = pos,.name = _SLIT(""),.is_mut = is_mut,.is_auto_rec = 0,.typ = arg_type,.type_pos = {0},.is_hidden = 0,} }));
			arg_no++;
			if (arg_no > 1024) {
				v__parser__Parser_error_with_pos(p, _SLIT("too many args"), pos);
				return (multi_return_Array_v__ast__Param_bool_bool){.arg0=__new_array_with_default(0, 0, sizeof(v__ast__Param), 0), .arg1=false, .arg2=false};
			}
		}
	} else {
		for (;;) {
			if (!(p->tok.kind != v__token__Kind_rpar)) break;
			if (p->tok.kind == v__token__Kind_eof) {
				v__parser__Parser_error_with_pos(p, _SLIT("expecting `)`"), v__token__Token_position(&p->tok));
				return (multi_return_Array_v__ast__Param_bool_bool){.arg0=__new_array_with_default(0, 0, sizeof(v__ast__Param), 0), .arg1=false, .arg2=false};
			}
			bool is_shared = p->tok.kind == v__token__Kind_key_shared;
			bool is_atomic = p->tok.kind == v__token__Kind_key_atomic;
			bool is_mut = p->tok.kind == v__token__Kind_key_mut || is_shared || is_atomic;
			if (is_mut) {
				v__parser__Parser_next(p);
			}
			Array_v__token__Position arg_pos = new_array_from_c_array(1, 1, sizeof(v__token__Position), _MOV((v__token__Position[1]){v__token__Token_position(&p->tok)}));
			Array_string arg_names = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){v__parser__Parser_check_name(p)}));
			Array_v__token__Position type_pos = new_array_from_c_array(1, 1, sizeof(v__token__Position), _MOV((v__token__Position[1]){v__token__Token_position(&p->tok)}));
			for (;;) {
				if (!(p->tok.kind == v__token__Kind_comma)) break;
				if (!p->pref->is_fmt) {
					v__parser__Parser_warn(p, string_add(_SLIT("`fn f(x, y Type)` syntax has been deprecated and will soon be removed. "), _STR("Use `fn f(x Type, y Type)` instead. You can run `v fmt -w \"%.*s\000\"` to automatically fix your code.", 2, p->scanner->file_path)));
				}
				v__parser__Parser_next(p);
				array_push(&arg_pos, _MOV((v__token__Position[]){ v__token__Token_position(&p->tok) }));
				array_push(&arg_names, _MOV((string[]){ string_clone(v__parser__Parser_check_name(p)) }));
				array_push(&type_pos, _MOV((v__token__Position[]){ v__token__Token_position(&p->tok) }));
			}
			if (p->tok.kind == v__token__Kind_key_mut) {
				if (!p->pref->is_fmt) {
					v__parser__Parser_warn_with_pos(p, _SLIT("use `mut f Foo` instead of `f mut Foo`"), v__token__Token_position(&p->tok));
				}
				is_mut = true;
			}
			if (p->tok.kind == v__token__Kind_key_shared) {
				v__parser__Parser_error_with_pos(p, _SLIT("use `shared f Foo` instead of `f shared Foo`"), v__token__Token_position(&p->tok));
			}
			if (p->tok.kind == v__token__Kind_ellipsis) {
				v__parser__Parser_next(p);
				is_variadic = true;
			}
			v__token__Position pos = v__token__Token_position(&p->tok);
			v__ast__Type typ = v__parser__Parser_parse_type(p);
			if (typ == 0) {
				return (multi_return_Array_v__ast__Param_bool_bool){.arg0=__new_array_with_default(0, 0, sizeof(v__ast__Param), 0), .arg1=false, .arg2=false};
			}
			if (is_mut) {
				if (!v__ast__Type_has_flag(typ, v__ast__TypeFlag_generic)) {
					if (is_shared) {
						v__parser__Parser_check_fn_shared_arguments(p, typ, pos);
					} else if (is_atomic) {
						v__parser__Parser_check_fn_atomic_arguments(p, typ, pos);
					} else {
						v__parser__Parser_check_fn_mutable_arguments(p, typ, pos);
					}
				} else if (is_shared || is_atomic) {
					v__parser__Parser_error_with_pos(p, _SLIT("generic object cannot be `atomic` or `shared`"), pos);
					return (multi_return_Array_v__ast__Param_bool_bool){.arg0=__new_array_with_default(0, 0, sizeof(v__ast__Param), 0), .arg1=false, .arg2=false};
				}
				typ = v__ast__Type_set_nr_muls(typ, 1);
				if (is_shared) {
					typ = v__ast__Type_set_flag(typ, v__ast__TypeFlag_shared_f);
				}
				if (is_atomic) {
					typ = v__ast__Type_set_flag(typ, v__ast__TypeFlag_atomic_f);
				}
			}
			if (is_variadic) {
				typ = v__ast__Type_set_flag(v__ast__Type_derive(v__ast__new_type(v__ast__Table_find_or_register_array(p->table, typ)), typ), v__ast__TypeFlag_variadic);
			}
			// FOR IN array
			for (int i = 0; i < arg_names.len; ++i) {
				string arg_name = ((string*)arg_names.data)[i];
				array_push(&args, _MOV((v__ast__Param[]){ (v__ast__Param){.pos = (*(v__token__Position*)/*ee elem_typ */array_get(arg_pos, i)),.name = arg_name,.is_mut = is_mut,.is_auto_rec = 0,.typ = typ,.type_pos = (*(v__token__Position*)/*ee elem_typ */array_get(type_pos, i)),.is_hidden = 0,} }));
				if (is_variadic && p->tok.kind == v__token__Kind_comma) {
					v__parser__Parser_error_with_pos(p, _STR("cannot use ...(variadic) with non-final parameter %.*s", 1, arg_name), (*(v__token__Position*)/*ee elem_typ */array_get(arg_pos, i)));
					return (multi_return_Array_v__ast__Param_bool_bool){.arg0=__new_array_with_default(0, 0, sizeof(v__ast__Param), 0), .arg1=false, .arg2=false};
				}
			}
			if (p->tok.kind == v__token__Kind_eof) {
				v__parser__Parser_error_with_pos(p, _SLIT("expecting `)`"), v__token__Token_position(&p->prev_tok));
				return (multi_return_Array_v__ast__Param_bool_bool){.arg0=__new_array_with_default(0, 0, sizeof(v__ast__Param), 0), .arg1=false, .arg2=false};
			}
			if (p->tok.kind != v__token__Kind_rpar) {
				v__parser__Parser_check(p, v__token__Kind_comma);
			}
		}
	}
	v__parser__Parser_check(p, v__token__Kind_rpar);
	return (multi_return_Array_v__ast__Param_bool_bool){.arg0=args, .arg1=types_only, .arg2=is_variadic};
}

VV_LOCAL_SYMBOL void v__parser__Parser_check_fn_mutable_arguments(v__parser__Parser* p, v__ast__Type typ, v__token__Position pos) {
	v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(p->table, typ);
	if ((sym->kind == v__ast__Kind_array || sym->kind == v__ast__Kind_array_fixed || sym->kind == v__ast__Kind_interface_ || sym->kind == v__ast__Kind_map || sym->kind == v__ast__Kind_placeholder || sym->kind == v__ast__Kind_struct_ || sym->kind == v__ast__Kind_sum_type)) {
		return;
	}
	if (v__ast__Type_is_ptr(typ) || v__ast__Type_is_pointer(typ)) {
		return;
	}
	if (sym->kind == v__ast__Kind_alias) {
		v__ast__Type atyp = (/* as */ *(v__ast__Alias*)__as_cast((sym->info)._v__ast__Alias,(sym->info)._typ, 413) /*expected idx: 413, name: v.ast.Alias */ ).parent_type;
		v__parser__Parser_check_fn_mutable_arguments(p, atyp, pos);
		return;
	}
	v__parser__Parser_error_with_pos(p, string_add(_SLIT("mutable arguments are only allowed for arrays, interfaces, maps, pointers, structs or their aliases\n"), _STR("return values instead: `fn foo(mut n %.*s\000) {` => `fn foo(n %.*s\000) %.*s\000 {`", 4, sym->name, sym->name, sym->name)), pos);
}

VV_LOCAL_SYMBOL void v__parser__Parser_check_fn_shared_arguments(v__parser__Parser* p, v__ast__Type typ, v__token__Position pos) {
	v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(p->table, typ);
	if (!(sym->kind == v__ast__Kind_array || sym->kind == v__ast__Kind_struct_ || sym->kind == v__ast__Kind_map || sym->kind == v__ast__Kind_placeholder) && !v__ast__Type_is_ptr(typ)) {
		v__parser__Parser_error_with_pos(p, _SLIT("shared arguments are only allowed for arrays, maps, and structs\n"), pos);
	}
}

VV_LOCAL_SYMBOL void v__parser__Parser_check_fn_atomic_arguments(v__parser__Parser* p, v__ast__Type typ, v__token__Position pos) {
	v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(p->table, typ);
	if (!(sym->kind == v__ast__Kind_u32 || sym->kind == v__ast__Kind_int || sym->kind == v__ast__Kind_u64)) {
		v__parser__Parser_error_with_pos(p, string_add(_SLIT("atomic arguments are only allowed for 32/64 bit integers\n"), _STR("use shared arguments instead: `fn foo(atomic n %.*s\000) {` => `fn foo(shared n %.*s\000) {`", 3, sym->name, sym->name)), pos);
	}
}

VV_LOCAL_SYMBOL bool v__parser__have_fn_main(Array_v__ast__Stmt stmts) {
	// FOR IN array
	for (int _t2367 = 0; _t2367 < stmts.len; ++_t2367) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)stmts.data)[_t2367];
		if ((stmt)._typ == 175 /* v.ast.FnDecl */) {
			if (string_eq((*stmt._v__ast__FnDecl).name, _SLIT("main.main")) && string_eq((*stmt._v__ast__FnDecl).mod, _SLIT("main"))) {
				 bool _t2368 = true;
				// autofree_scope_vars(pos=24733 line_nr=879 scope.pos=24728 scope.end_pos=24749)
				// af parent scope:
				// var "stmt" var.pos=24654 var.line_nr=877
				// af parent scope:
				// var "stmt" var.pos=24633 var.line_nr=876
				// skipping tmp var "stmt"
				// af parent scope:
				// var "stmts" var.pos=24603 var.line_nr=875
				// af parent scope:
				// af parent scope:
				return _t2368;
			}
		}
	}
	 bool _t2369 = false;
	// autofree_scope_vars(pos=24758 line_nr=883 scope.pos=24590 scope.end_pos=24772)
	// var "stmts" var.pos=24603 var.line_nr=875
	// af parent scope:
	// af parent scope:
	return _t2369;
}

VV_LOCAL_SYMBOL v__ast__Stmt v__parser__Parser_for_stmt(v__parser__Parser* p) {
	v__parser__Parser_check(p, v__token__Kind_key_for);
	v__token__Position pos = v__token__Token_position(&p->tok);
	v__parser__Parser_open_scope(p);
	p->inside_for = true;
	if (p->tok.kind == v__token__Kind_key_match) {
		 v__ast__Stmt _t2370 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error(p, _SLIT("cannot use `match` in `for` loop")))));
		// autofree_scope_vars(pos=356 line_nr=13 scope.pos=353 scope.end_pos=409)
		// af parent scope:
		// var "p" var.pos=207 var.line_nr=7
		// var "pos" var.pos=263 var.line_nr=9
		// var "cond" var.pos=5165 var.line_nr=182
		// var "stmts" var.pos=5251 var.line_nr=186
		// var "for_stmt" var.pos=5333 var.line_nr=188
		// af parent scope:
		// af parent scope:
		return _t2370;
	}
	if (p->tok.kind == v__token__Kind_lcbr) {
		p->inside_for = false;
		Array_v__ast__Stmt stmts = v__parser__Parser_parse_block_no_scope(p, false);
		v__token__Position_update_last_line(&pos, p->prev_tok.line_nr);
		v__ast__ForStmt for_stmt = (v__ast__ForStmt){.cond = {0},.stmts = stmts,.is_inf = true,.pos = pos,.label = (string){.str=(byteptr)"", .is_lit=1},.scope = p->scope,};
		v__parser__Parser_close_scope(p);
		// autofree_scope_vars(pos=704 line_nr=28 scope.pos=483 scope.end_pos=722)
		// var "stmts" var.pos=510 var.line_nr=19
		// var "for_stmt" var.pos=594 var.line_nr=21
		// af parent scope:
		// var "p" var.pos=207 var.line_nr=7
		// var "pos" var.pos=263 var.line_nr=9
		// var "cond" var.pos=5165 var.line_nr=182
		// var "stmts" var.pos=5251 var.line_nr=186
		// var "for_stmt" var.pos=5333 var.line_nr=188
		// af parent scope:
		// af parent scope:
		return v__ast__ForStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__ForStmt, (for_stmt)));
	} else if ((p->peek_tok.kind == v__token__Kind_decl_assign || p->peek_tok.kind == v__token__Kind_assign || p->peek_tok.kind == v__token__Kind_semicolon) || p->tok.kind == v__token__Kind_semicolon || (p->peek_tok.kind == v__token__Kind_comma && v__parser__Parser_peek_token(p, 2).kind != v__token__Kind_key_mut && v__parser__Parser_peek_token(p, 3).kind != v__token__Kind_key_in)) {
		if (p->tok.kind == v__token__Kind_key_mut) {
			 v__ast__Stmt _t2371 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error(p, _SLIT("`mut` is not needed in `for ;;` loops: use `for i := 0; i < n; i ++ {`")))));
			// autofree_scope_vars(pos=1023 line_nr=34 scope.pos=1019 scope.end_pos=1115)
			// af parent scope:
			// var "init" var.pos=1123 var.line_nr=36
			// var "cond" var.pos=1154 var.line_nr=37
			// var "inc" var.pos=1186 var.line_nr=38
			// var "has_init" var.pos=1216 var.line_nr=39
			// var "has_cond" var.pos=1240 var.line_nr=40
			// var "has_inc" var.pos=1264 var.line_nr=41
			// var "is_multi" var.pos=1287 var.line_nr=42
			// var "stmts" var.pos=2024 var.line_nr=68
			// var "for_c_stmt" var.pos=2108 var.line_nr=70
			// af parent scope:
			// var "p" var.pos=207 var.line_nr=7
			// var "pos" var.pos=263 var.line_nr=9
			// var "cond" var.pos=5165 var.line_nr=182
			// var "stmts" var.pos=5251 var.line_nr=186
			// var "for_stmt" var.pos=5333 var.line_nr=188
			// af parent scope:
			// af parent scope:
			return _t2371;
		}
		v__ast__Stmt init = v__ast__empty_stmt();
		v__ast__Expr cond = v__parser__Parser_new_true_expr(p);
		v__ast__Stmt inc = v__ast__empty_stmt();
		bool has_init = false;
		bool has_cond = false;
		bool has_inc = false;
		bool is_multi = p->peek_tok.kind == v__token__Kind_comma && v__parser__Parser_peek_token(p, 2).kind != v__token__Kind_key_mut && v__parser__Parser_peek_token(p, 3).kind != v__token__Kind_key_in;
		if ((p->peek_tok.kind == v__token__Kind_assign || p->peek_tok.kind == v__token__Kind_decl_assign) || is_multi) {
			init = v__parser__Parser_assign_stmt(p);
			has_init = true;
		}
		v__parser__Parser_check(p, v__token__Kind_semicolon);
		if (p->tok.kind != v__token__Kind_semicolon) {
			if (p->tok.kind == v__token__Kind_name && (p->peek_tok.kind == v__token__Kind_inc || p->peek_tok.kind == v__token__Kind_dec)) {
				 v__ast__Stmt _t2372 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error(p, _STR("cannot use %.*s\000%.*s\000 as value", 3, p->tok.lit, v__token__Kind_str(p->peek_tok.kind))))));
				// autofree_scope_vars(pos=1730 line_nr=54 scope.pos=1725 scope.end_pos=1799)
				// af parent scope:
				// af parent scope:
				// var "init" var.pos=1123 var.line_nr=36
				// var "cond" var.pos=1154 var.line_nr=37
				// var "inc" var.pos=1186 var.line_nr=38
				// var "has_init" var.pos=1216 var.line_nr=39
				// var "has_cond" var.pos=1240 var.line_nr=40
				// var "has_inc" var.pos=1264 var.line_nr=41
				// var "is_multi" var.pos=1287 var.line_nr=42
				// var "stmts" var.pos=2024 var.line_nr=68
				// var "for_c_stmt" var.pos=2108 var.line_nr=70
				// af parent scope:
				// var "p" var.pos=207 var.line_nr=7
				// var "pos" var.pos=263 var.line_nr=9
				// var "cond" var.pos=5165 var.line_nr=182
				// var "stmts" var.pos=5251 var.line_nr=186
				// var "for_stmt" var.pos=5333 var.line_nr=188
				// af parent scope:
				// af parent scope:
				return _t2372;
			}
			cond = v__parser__Parser_expr(p, 0);
			has_cond = true;
		}
		v__parser__Parser_check(p, v__token__Kind_semicolon);
		if (!is_multi) {
			is_multi = p->peek_tok.kind == v__token__Kind_comma;
		}
		if (p->tok.kind != v__token__Kind_lcbr) {
			inc = v__parser__Parser_stmt(p, false);
			has_inc = true;
		}
		p->inside_for = false;
		Array_v__ast__Stmt stmts = v__parser__Parser_parse_block_no_scope(p, false);
		v__token__Position_update_last_line(&pos, p->prev_tok.line_nr);
		v__ast__ForCStmt for_c_stmt = (v__ast__ForCStmt){
			.init = init,
			.has_init = has_init,
			.cond = cond,
			.has_cond = has_cond,
			.inc = inc,
			.has_inc = has_inc,
			.is_multi = is_multi,
			.stmts = stmts,
			.pos = pos,
			.label = (string){.str=(byteptr)"", .is_lit=1},
			.scope = p->scope,
		};
		v__parser__Parser_close_scope(p);
		// autofree_scope_vars(pos=2331 line_nr=83 scope.pos=921 scope.end_pos=2351)
		// var "init" var.pos=1123 var.line_nr=36
		// var "cond" var.pos=1154 var.line_nr=37
		// var "inc" var.pos=1186 var.line_nr=38
		// var "has_init" var.pos=1216 var.line_nr=39
		// var "has_cond" var.pos=1240 var.line_nr=40
		// var "has_inc" var.pos=1264 var.line_nr=41
		// var "is_multi" var.pos=1287 var.line_nr=42
		// var "stmts" var.pos=2024 var.line_nr=68
		// var "for_c_stmt" var.pos=2108 var.line_nr=70
		// af parent scope:
		// var "p" var.pos=207 var.line_nr=7
		// var "pos" var.pos=263 var.line_nr=9
		// var "cond" var.pos=5165 var.line_nr=182
		// var "stmts" var.pos=5251 var.line_nr=186
		// var "for_stmt" var.pos=5333 var.line_nr=188
		// af parent scope:
		// af parent scope:
		return v__ast__ForCStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__ForCStmt, (for_c_stmt)));
	} else if ((p->peek_tok.kind == v__token__Kind_key_in || p->peek_tok.kind == v__token__Kind_comma) || (p->tok.kind == v__token__Kind_key_mut && (v__parser__Parser_peek_token(p, 2).kind == v__token__Kind_key_in || v__parser__Parser_peek_token(p, 2).kind == v__token__Kind_comma))) {
		bool val_is_mut = p->tok.kind == v__token__Kind_key_mut;
		v__token__Position mut_pos = v__token__Token_position(&p->tok);
		if (val_is_mut) {
			v__parser__Parser_next(p);
		}
		v__token__Position key_var_pos = v__token__Token_position(&p->tok);
		v__token__Position val_var_pos = v__token__Token_position(&p->tok);
		string key_var_name = _SLIT("");
		string val_var_name = v__parser__Parser_check_name(p);
		if (p->tok.kind == v__token__Kind_comma) {
			if (val_is_mut) {
				v__parser__Parser_error_with_pos(p, _SLIT("index of array or key of map cannot be mutated"), mut_pos);
			}
			v__parser__Parser_next(p);
			if (p->tok.kind == v__token__Kind_key_mut) {
				v__parser__Parser_next(p);
				val_is_mut = true;
			}
			key_var_name = val_var_name;
			val_var_pos = v__token__Token_position(&p->tok);
			val_var_name = v__parser__Parser_check_name(p);
			if (string_eq(key_var_name, val_var_name) && string_ne(key_var_name, _SLIT("_"))) {
				 v__ast__Stmt _t2373 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _SLIT("key and value in a for loop cannot be the same"), val_var_pos))));
				// autofree_scope_vars(pos=3227 line_nr=110 scope.pos=3222 scope.end_pos=3323)
				// af parent scope:
				// af parent scope:
				// var "val_is_mut" var.pos=2580 var.line_nr=87
				// var "mut_pos" var.pos=2619 var.line_nr=88
				// var "key_var_pos" var.pos=2683 var.line_nr=92
				// var "val_var_pos" var.pos=2721 var.line_nr=93
				// var "key_var_name" var.pos=2759 var.line_nr=94
				// str literal
				// var "val_var_name" var.pos=2784 var.line_nr=95
				// var "cond" var.pos=4068 var.line_nr=133
				// var "high_expr" var.pos=4159 var.line_nr=137
				// var "is_range" var.pos=4195 var.line_nr=138
				// var "stmts" var.pos=4774 var.line_nr=164
				// var "for_in_stmt" var.pos=4894 var.line_nr=167
				// af parent scope:
				// var "p" var.pos=207 var.line_nr=7
				// var "pos" var.pos=263 var.line_nr=9
				// var "cond" var.pos=5165 var.line_nr=182
				// var "stmts" var.pos=5251 var.line_nr=186
				// var "for_stmt" var.pos=5333 var.line_nr=188
				// af parent scope:
				// af parent scope:
				return _t2373;
			}
			if (v__ast__Scope_known_var(p->scope, key_var_name)) {
				 v__ast__Stmt _t2374 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error(p, _STR("redefinition of key iteration variable `%.*s\000`", 2, key_var_name)))));
				// autofree_scope_vars(pos=3368 line_nr=114 scope.pos=3363 scope.end_pos=3445)
				// af parent scope:
				// af parent scope:
				// var "val_is_mut" var.pos=2580 var.line_nr=87
				// var "mut_pos" var.pos=2619 var.line_nr=88
				// var "key_var_pos" var.pos=2683 var.line_nr=92
				// var "val_var_pos" var.pos=2721 var.line_nr=93
				// var "key_var_name" var.pos=2759 var.line_nr=94
				// str literal
				// var "val_var_name" var.pos=2784 var.line_nr=95
				// var "cond" var.pos=4068 var.line_nr=133
				// var "high_expr" var.pos=4159 var.line_nr=137
				// var "is_range" var.pos=4195 var.line_nr=138
				// var "stmts" var.pos=4774 var.line_nr=164
				// var "for_in_stmt" var.pos=4894 var.line_nr=167
				// af parent scope:
				// var "p" var.pos=207 var.line_nr=7
				// var "pos" var.pos=263 var.line_nr=9
				// var "cond" var.pos=5165 var.line_nr=182
				// var "stmts" var.pos=5251 var.line_nr=186
				// var "for_stmt" var.pos=5333 var.line_nr=188
				// af parent scope:
				// af parent scope:
				return _t2374;
			}
			if (v__ast__Scope_known_var(p->scope, val_var_name)) {
				 v__ast__Stmt _t2375 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error(p, _STR("redefinition of value iteration variable `%.*s\000`", 2, val_var_name)))));
				// autofree_scope_vars(pos=3490 line_nr=117 scope.pos=3485 scope.end_pos=3569)
				// af parent scope:
				// af parent scope:
				// var "val_is_mut" var.pos=2580 var.line_nr=87
				// var "mut_pos" var.pos=2619 var.line_nr=88
				// var "key_var_pos" var.pos=2683 var.line_nr=92
				// var "val_var_pos" var.pos=2721 var.line_nr=93
				// var "key_var_name" var.pos=2759 var.line_nr=94
				// str literal
				// var "val_var_name" var.pos=2784 var.line_nr=95
				// var "cond" var.pos=4068 var.line_nr=133
				// var "high_expr" var.pos=4159 var.line_nr=137
				// var "is_range" var.pos=4195 var.line_nr=138
				// var "stmts" var.pos=4774 var.line_nr=164
				// var "for_in_stmt" var.pos=4894 var.line_nr=167
				// af parent scope:
				// var "p" var.pos=207 var.line_nr=7
				// var "pos" var.pos=263 var.line_nr=9
				// var "cond" var.pos=5165 var.line_nr=182
				// var "stmts" var.pos=5251 var.line_nr=186
				// var "for_stmt" var.pos=5333 var.line_nr=188
				// af parent scope:
				// af parent scope:
				return _t2375;
			}
			v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){.name = key_var_name,.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.is_auto_deref = 0,.typ = _const_v__ast__int_type,.orig_type = 0,.smartcasts = __new_array(0, 1, sizeof(v__ast__Type)),.pos = key_var_pos,.is_used = 0,.is_changed = 0,.is_or = 0,.is_tmp = true,}))));
		} else if (v__ast__Scope_known_var(p->scope, val_var_name)) {
			 v__ast__Stmt _t2376 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error(p, _STR("redefinition of value iteration variable `%.*s\000`", 2, val_var_name)))));
			// autofree_scope_vars(pos=3737 line_nr=126 scope.pos=3733 scope.end_pos=3815)
			// af parent scope:
			// var "val_is_mut" var.pos=2580 var.line_nr=87
			// var "mut_pos" var.pos=2619 var.line_nr=88
			// var "key_var_pos" var.pos=2683 var.line_nr=92
			// var "val_var_pos" var.pos=2721 var.line_nr=93
			// var "key_var_name" var.pos=2759 var.line_nr=94
			// str literal
			// var "val_var_name" var.pos=2784 var.line_nr=95
			// var "cond" var.pos=4068 var.line_nr=133
			// var "high_expr" var.pos=4159 var.line_nr=137
			// var "is_range" var.pos=4195 var.line_nr=138
			// var "stmts" var.pos=4774 var.line_nr=164
			// var "for_in_stmt" var.pos=4894 var.line_nr=167
			// af parent scope:
			// var "p" var.pos=207 var.line_nr=7
			// var "pos" var.pos=263 var.line_nr=9
			// var "cond" var.pos=5165 var.line_nr=182
			// var "stmts" var.pos=5251 var.line_nr=186
			// var "for_stmt" var.pos=5333 var.line_nr=188
			// af parent scope:
			// af parent scope:
			return _t2376;
		}
		v__parser__Parser_check(p, v__token__Kind_key_in);
		if (p->tok.kind == v__token__Kind_name && (string_eq(p->tok.lit, key_var_name) || string_eq(p->tok.lit, val_var_name))) {
			 v__ast__Stmt _t2377 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error(p, _STR("in a `for x in array` loop, the key or value iteration variable `%.*s\000` can not be the same as the array variable", 2, p->tok.lit)))));
			// autofree_scope_vars(pos=3910 line_nr=130 scope.pos=3906 scope.end_pos=4050)
			// af parent scope:
			// var "val_is_mut" var.pos=2580 var.line_nr=87
			// var "mut_pos" var.pos=2619 var.line_nr=88
			// var "key_var_pos" var.pos=2683 var.line_nr=92
			// var "val_var_pos" var.pos=2721 var.line_nr=93
			// var "key_var_name" var.pos=2759 var.line_nr=94
			// str literal
			// var "val_var_name" var.pos=2784 var.line_nr=95
			// var "cond" var.pos=4068 var.line_nr=133
			// var "high_expr" var.pos=4159 var.line_nr=137
			// var "is_range" var.pos=4195 var.line_nr=138
			// var "stmts" var.pos=4774 var.line_nr=164
			// var "for_in_stmt" var.pos=4894 var.line_nr=167
			// af parent scope:
			// var "p" var.pos=207 var.line_nr=7
			// var "pos" var.pos=263 var.line_nr=9
			// var "cond" var.pos=5165 var.line_nr=182
			// var "stmts" var.pos=5251 var.line_nr=186
			// var "for_stmt" var.pos=5333 var.line_nr=188
			// af parent scope:
			// af parent scope:
			return _t2377;
		}
		v__ast__Expr cond = v__parser__Parser_expr(p, 0);
		v__ast__Expr high_expr = v__ast__empty_expr();
		bool is_range = false;
		if (p->tok.kind == v__token__Kind_dotdot) {
			is_range = true;
			v__parser__Parser_next(p);
			high_expr = v__parser__Parser_expr(p, 0);
			v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){.name = val_var_name,.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.is_auto_deref = 0,.typ = _const_v__ast__int_type,.orig_type = 0,.smartcasts = __new_array(0, 1, sizeof(v__ast__Type)),.pos = val_var_pos,.is_used = 0,.is_changed = 0,.is_or = 0,.is_tmp = true,}))));
			if (key_var_name.len > 0) {
				 v__ast__Stmt _t2378 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _SLIT("cannot declare index variable with range `for`"), key_var_pos))));
				// autofree_scope_vars(pos=4448 line_nr=150 scope.pos=4443 scope.end_pos=4544)
				// af parent scope:
				// af parent scope:
				// var "val_is_mut" var.pos=2580 var.line_nr=87
				// var "mut_pos" var.pos=2619 var.line_nr=88
				// var "key_var_pos" var.pos=2683 var.line_nr=92
				// var "val_var_pos" var.pos=2721 var.line_nr=93
				// var "key_var_name" var.pos=2759 var.line_nr=94
				// str literal
				// var "val_var_name" var.pos=2784 var.line_nr=95
				// var "cond" var.pos=4068 var.line_nr=133
				// var "high_expr" var.pos=4159 var.line_nr=137
				// var "is_range" var.pos=4195 var.line_nr=138
				// var "stmts" var.pos=4774 var.line_nr=164
				// var "for_in_stmt" var.pos=4894 var.line_nr=167
				// af parent scope:
				// var "p" var.pos=207 var.line_nr=7
				// var "pos" var.pos=263 var.line_nr=9
				// var "cond" var.pos=5165 var.line_nr=182
				// var "stmts" var.pos=5251 var.line_nr=186
				// var "for_stmt" var.pos=5333 var.line_nr=188
				// af parent scope:
				// af parent scope:
				return _t2378;
			}
		} else {
			v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){.name = val_var_name,.expr = {0},.share = 0,.is_mut = val_is_mut,.is_autofree_tmp = 0,.is_arg = 0,.is_auto_deref = val_is_mut,.typ = 0,.orig_type = 0,.smartcasts = __new_array(0, 1, sizeof(v__ast__Type)),.pos = val_var_pos,.is_used = 0,.is_changed = 0,.is_or = 0,.is_tmp = true,}))));
		}
		p->inside_for = false;
		Array_v__ast__Stmt stmts = v__parser__Parser_parse_block_no_scope(p, false);
		v__token__Position_update_last_line(&pos, p->prev_tok.line_nr);
		v__ast__ForInStmt for_in_stmt = (v__ast__ForInStmt){
			.key_var = key_var_name,
			.val_var = val_var_name,
			.cond = cond,
			.is_range = is_range,
			.high = high_expr,
			.stmts = stmts,
			.pos = pos,
			.val_is_mut = val_is_mut,
			.key_type = 0,
			.val_type = 0,
			.cond_type = 0,
			.kind = 0,
			.label = (string){.str=(byteptr)"", .is_lit=1},
			.scope = p->scope,
		};
		v__parser__Parser_close_scope(p);
		// autofree_scope_vars(pos=5124 line_nr=179 scope.pos=2473 scope.end_pos=5145)
		// var "val_is_mut" var.pos=2580 var.line_nr=87
		// var "mut_pos" var.pos=2619 var.line_nr=88
		// var "key_var_pos" var.pos=2683 var.line_nr=92
		// var "val_var_pos" var.pos=2721 var.line_nr=93
		// var "key_var_name" var.pos=2759 var.line_nr=94
		// str literal
		// var "val_var_name" var.pos=2784 var.line_nr=95
		// var "cond" var.pos=4068 var.line_nr=133
		// var "high_expr" var.pos=4159 var.line_nr=137
		// var "is_range" var.pos=4195 var.line_nr=138
		// var "stmts" var.pos=4774 var.line_nr=164
		// var "for_in_stmt" var.pos=4894 var.line_nr=167
		// af parent scope:
		// var "p" var.pos=207 var.line_nr=7
		// var "pos" var.pos=263 var.line_nr=9
		// var "cond" var.pos=5165 var.line_nr=182
		// var "stmts" var.pos=5251 var.line_nr=186
		// var "for_stmt" var.pos=5333 var.line_nr=188
		// af parent scope:
		// af parent scope:
		return v__ast__ForInStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__ForInStmt, (for_in_stmt)));
	}
	v__ast__Expr cond = v__parser__Parser_expr(p, 0);
	p->inside_for = false;
	v__parser__Parser_open_scope(p);
	Array_v__ast__Stmt stmts = v__parser__Parser_parse_block_no_scope(p, false);
	v__token__Position_update_last_line(&pos, p->prev_tok.line_nr);
	v__ast__ForStmt for_stmt = (v__ast__ForStmt){.cond = cond,.stmts = stmts,.is_inf = 0,.pos = pos,.label = (string){.str=(byteptr)"", .is_lit=1},.scope = p->scope,};
	v__parser__Parser_close_scope(p);
	v__parser__Parser_close_scope(p);
	// autofree_scope_vars(pos=5451 line_nr=196 scope.pos=202 scope.end_pos=5468)
	// var "p" var.pos=207 var.line_nr=7
	// var "pos" var.pos=263 var.line_nr=9
	// var "cond" var.pos=5165 var.line_nr=182
	// var "stmts" var.pos=5251 var.line_nr=186
	// var "for_stmt" var.pos=5333 var.line_nr=188
	// af parent scope:
	// af parent scope:
	return v__ast__ForStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__ForStmt, (for_stmt)));
}

VV_LOCAL_SYMBOL v__ast__IfExpr v__parser__Parser_if_expr(v__parser__Parser* p, bool is_comptime) {
bool v__parser__Parser_if_expr_defer_0 = false;
	bool was_inside_if_expr = p->inside_if_expr;
	bool was_inside_ct_if_expr = p->inside_ct_if_expr;
	v__parser__Parser_if_expr_defer_0 = true;
	p->inside_if_expr = true;
	bool is_expr = p->prev_tok.kind == v__token__Kind_key_return;
	v__token__Position pos = v__token__Token_position(&p->tok);
	if (is_comptime) {
		p->inside_ct_if_expr = true;
		v__parser__Parser_next(p);
		pos = v__token__Position_extend(v__token__Token_position(&p->prev_tok), v__token__Token_position(&p->tok));
	}
	Array_v__ast__IfBranch branches = __new_array_with_default(0, 0, sizeof(v__ast__IfBranch), 0);
	bool has_else = false;
	Array_v__ast__Comment comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	bool prev_guard = false;
	for (;;) {
		if (!((p->tok.kind == v__token__Kind_key_if || p->tok.kind == v__token__Kind_key_else))) break;
		p->inside_if = true;
		v__token__Position start_pos = (is_comptime ? (v__token__Position_extend(v__token__Token_position(&p->prev_tok), v__token__Token_position(&p->tok))) : (v__token__Token_position(&p->tok)));
		if (p->tok.kind == v__token__Kind_key_else) {
			_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,})), _t2379, Array_v__ast__Comment);
			v__parser__Parser_check(p, v__token__Kind_key_else);
			_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,})), _t2380, Array_v__ast__Comment);
			if (p->tok.kind == v__token__Kind_key_match) {
				v__parser__Parser_error(p, _SLIT("cannot use `match` with `if` statements"));
				// Defer begin
				if (v__parser__Parser_if_expr_defer_0 == true) {
					p->inside_if_expr = was_inside_if_expr;
					p->inside_ct_if_expr = was_inside_ct_if_expr;
				}
				// Defer end
				 v__ast__IfExpr _t2381 = (v__ast__IfExpr){.is_comptime = 0,.tok_kind = 0,.left = {0},.pos = {0},.post_comments = __new_array(0, 1, sizeof(v__ast__Comment)),.branches = __new_array(0, 1, sizeof(v__ast__IfBranch)),.is_expr = 0,.typ = 0,.has_else = 0,};
				// autofree_scope_vars(pos=1182 line_nr=40 scope.pos=1122 scope.end_pos=1206)
				// af parent scope:
				// af parent scope:
				// var "start_pos" var.pos=855 var.line_nr=29
				// var "cond" var.pos=2107 var.line_nr=80
				// var "is_guard" var.pos=2138 var.line_nr=81
				// var "end_pos" var.pos=2817 var.line_nr=110
				// var "body_pos" var.pos=2852 var.line_nr=111
				// var "stmts" var.pos=2922 var.line_nr=114
				// af parent scope:
				// af parent scope:
				// var "p" var.pos=222 var.line_nr=8
				// var "is_comptime" var.pos=240 var.line_nr=8
				// var "was_inside_if_expr" var.pos=272 var.line_nr=9
				// var "was_inside_ct_if_expr" var.pos=312 var.line_nr=10
				// var "is_expr" var.pos=481 var.line_nr=16
				// var "pos" var.pos=528 var.line_nr=17
				// var "branches" var.pos=680 var.line_nr=23
				// var "has_else" var.pos=714 var.line_nr=24
				// var "comments" var.pos=737 var.line_nr=25
				// var "prev_guard" var.pos=770 var.line_nr=26
				// af parent scope:
				// af parent scope:
				return _t2381;
			}
			if (p->tok.kind == v__token__Kind_lcbr) {
				has_else = true;
				p->inside_if = false;
				v__token__Position end_pos = v__token__Token_position(&p->prev_tok);
				v__token__Position body_pos = v__token__Token_position(&p->tok);
				v__parser__Parser_open_scope(p);
				if (prev_guard) {
					v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){.name = _SLIT("err"),.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.is_auto_deref = 0,.typ = _const_v__ast__error_type,.orig_type = 0,.smartcasts = __new_array(0, 1, sizeof(v__ast__Type)),.pos = v__token__Token_position(&p->tok),.is_used = true,.is_changed = 0,.is_or = 0,.is_tmp = 0,}))));
				}
				array_push(&branches, _MOV((v__ast__IfBranch[]){ (v__ast__IfBranch){.cond = {0},.pos = v__token__Position_extend(start_pos, end_pos),.body_pos = v__token__Position_extend(body_pos, v__token__Token_position(&p->tok)),.comments = comments,.stmts = v__parser__Parser_parse_block_no_scope(p, false),.scope = p->scope,} }));
				v__parser__Parser_close_scope(p);
				comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
				break;
			}
			if (is_comptime) {
				v__parser__Parser_check(p, v__token__Kind_dollar);
			}
		}
		v__parser__Parser_check(p, v__token__Kind_key_if);
		if (p->tok.kind == v__token__Kind_key_match) {
			v__parser__Parser_error(p, _SLIT("cannot use `match` with `if` statements"));
			// Defer begin
			if (v__parser__Parser_if_expr_defer_0 == true) {
				p->inside_if_expr = was_inside_if_expr;
				p->inside_ct_if_expr = was_inside_ct_if_expr;
			}
			// Defer end
			 v__ast__IfExpr _t2383 = (v__ast__IfExpr){.is_comptime = 0,.tok_kind = 0,.left = {0},.pos = {0},.post_comments = __new_array(0, 1, sizeof(v__ast__Comment)),.branches = __new_array(0, 1, sizeof(v__ast__IfBranch)),.is_expr = 0,.typ = 0,.has_else = 0,};
			// autofree_scope_vars(pos=2043 line_nr=77 scope.pos=1985 scope.end_pos=2066)
			// af parent scope:
			// var "start_pos" var.pos=855 var.line_nr=29
			// var "cond" var.pos=2107 var.line_nr=80
			// var "is_guard" var.pos=2138 var.line_nr=81
			// var "end_pos" var.pos=2817 var.line_nr=110
			// var "body_pos" var.pos=2852 var.line_nr=111
			// var "stmts" var.pos=2922 var.line_nr=114
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=222 var.line_nr=8
			// var "is_comptime" var.pos=240 var.line_nr=8
			// var "was_inside_if_expr" var.pos=272 var.line_nr=9
			// var "was_inside_ct_if_expr" var.pos=312 var.line_nr=10
			// var "is_expr" var.pos=481 var.line_nr=16
			// var "pos" var.pos=528 var.line_nr=17
			// var "branches" var.pos=680 var.line_nr=23
			// var "has_else" var.pos=714 var.line_nr=24
			// var "comments" var.pos=737 var.line_nr=25
			// var "prev_guard" var.pos=770 var.line_nr=26
			// af parent scope:
			// af parent scope:
			return _t2383;
		}
		_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,})), _t2384, Array_v__ast__Comment);
		v__ast__Expr cond = v__ast__empty_expr();
		bool is_guard = false;
		if (!is_comptime && p->peek_tok.kind == v__token__Kind_decl_assign) {
			v__parser__Parser_open_scope(p);
			is_guard = true;
			v__token__Position var_pos = v__token__Token_position(&p->tok);
			string var_name = v__parser__Parser_check_name(p);
			if (v__ast__Scope_known_var(p->scope, var_name)) {
				v__parser__Parser_error_with_pos(p, _STR("redefinition of `%.*s\000`", 2, var_name), var_pos);
			}
			_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,})), _t2385, Array_v__ast__Comment);
			v__parser__Parser_check(p, v__token__Kind_decl_assign);
			_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,})), _t2386, Array_v__ast__Comment);
			v__ast__Expr expr = v__parser__Parser_expr(p, 0);
			cond = v__ast__IfGuardExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__IfGuardExpr, ((v__ast__IfGuardExpr){.var_name = var_name,.pos = {0},.expr = expr,.expr_type = 0,})));
			v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){.name = var_name,.expr = cond,.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.is_auto_deref = 0,.typ = 0,.orig_type = 0,.smartcasts = __new_array(0, 1, sizeof(v__ast__Type)),.pos = var_pos,.is_used = 0,.is_changed = 0,.is_or = 0,.is_tmp = 0,}))));
			prev_guard = true;
		} else {
			prev_guard = false;
			cond = v__parser__Parser_expr(p, 0);
		}
		_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,})), _t2387, Array_v__ast__Comment);
		v__token__Position end_pos = v__token__Token_position(&p->prev_tok);
		v__token__Position body_pos = v__token__Token_position(&p->tok);
		p->inside_if = false;
		v__parser__Parser_open_scope(p);
		Array_v__ast__Stmt stmts = v__parser__Parser_parse_block_no_scope(p, false);
		array_push(&branches, _MOV((v__ast__IfBranch[]){ (v__ast__IfBranch){
			.cond = cond,
			.pos = v__token__Position_extend(start_pos, end_pos),
			.body_pos = v__token__Position_extend(body_pos, v__token__Token_position(&p->prev_tok)),
			.comments = comments,
			.stmts = stmts,
			.scope = p->scope,
		} }));
		v__parser__Parser_close_scope(p);
		if (is_guard) {
			v__parser__Parser_close_scope(p);
		}
		comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,});
		if (is_comptime) {
			if (p->tok.kind == v__token__Kind_key_else) {
				v__parser__Parser_error(p, _SLIT("use `$else` instead of `else` in compile-time `if` branches"));
				// Defer begin
				if (v__parser__Parser_if_expr_defer_0 == true) {
					p->inside_if_expr = was_inside_if_expr;
					p->inside_ct_if_expr = was_inside_ct_if_expr;
				}
				// Defer end
				 v__ast__IfExpr _t2389 = (v__ast__IfExpr){.is_comptime = 0,.tok_kind = 0,.left = {0},.pos = {0},.post_comments = __new_array(0, 1, sizeof(v__ast__Comment)),.branches = __new_array(0, 1, sizeof(v__ast__IfBranch)),.is_expr = 0,.typ = 0,.has_else = 0,};
				// autofree_scope_vars(pos=3368 line_nr=131 scope.pos=3287 scope.end_pos=3392)
				// af parent scope:
				// af parent scope:
				// var "start_pos" var.pos=855 var.line_nr=29
				// var "cond" var.pos=2107 var.line_nr=80
				// var "is_guard" var.pos=2138 var.line_nr=81
				// var "end_pos" var.pos=2817 var.line_nr=110
				// var "body_pos" var.pos=2852 var.line_nr=111
				// var "stmts" var.pos=2922 var.line_nr=114
				// af parent scope:
				// af parent scope:
				// var "p" var.pos=222 var.line_nr=8
				// var "is_comptime" var.pos=240 var.line_nr=8
				// var "was_inside_if_expr" var.pos=272 var.line_nr=9
				// var "was_inside_ct_if_expr" var.pos=312 var.line_nr=10
				// var "is_expr" var.pos=481 var.line_nr=16
				// var "pos" var.pos=528 var.line_nr=17
				// var "branches" var.pos=680 var.line_nr=23
				// var "has_else" var.pos=714 var.line_nr=24
				// var "comments" var.pos=737 var.line_nr=25
				// var "prev_guard" var.pos=770 var.line_nr=26
				// af parent scope:
				// af parent scope:
				return _t2389;
			}
			if (p->peek_tok.kind == v__token__Kind_key_else) {
				v__parser__Parser_check(p, v__token__Kind_dollar);
			}
		}
		if (p->tok.kind != v__token__Kind_key_else) {
			break;
		}
	}
	v__token__Position_update_last_line(&pos, p->prev_tok.line_nr);
	if (comments.len > 0) {
		pos.last_line = (*(v__ast__Comment*)array_last(comments)).pos.last_line;
	}
	// Defer begin
	if (v__parser__Parser_if_expr_defer_0 == true) {
		p->inside_if_expr = was_inside_if_expr;
		p->inside_ct_if_expr = was_inside_ct_if_expr;
	}
	// Defer end
	 v__ast__IfExpr _t2390 = (v__ast__IfExpr){
		.is_comptime = is_comptime,
		.tok_kind = 0,
		.left = {0},
		.pos = pos,
		.post_comments = comments,
		.branches = branches,
		.is_expr = is_expr,
		.typ = 0,
		.has_else = has_else,
	};
	// autofree_scope_vars(pos=3624 line_nr=145 scope.pos=217 scope.end_pos=3772)
	// var "p" var.pos=222 var.line_nr=8
	// var "is_comptime" var.pos=240 var.line_nr=8
	// var "was_inside_if_expr" var.pos=272 var.line_nr=9
	// var "was_inside_ct_if_expr" var.pos=312 var.line_nr=10
	// var "is_expr" var.pos=481 var.line_nr=16
	// var "pos" var.pos=528 var.line_nr=17
	// var "branches" var.pos=680 var.line_nr=23
	// var "has_else" var.pos=714 var.line_nr=24
	// var "comments" var.pos=737 var.line_nr=25
	// var "prev_guard" var.pos=770 var.line_nr=26
	// af parent scope:
	// af parent scope:
	return _t2390;
}

VV_LOCAL_SYMBOL v__ast__MatchExpr v__parser__Parser_match_expr(v__parser__Parser* p) {
	v__token__Position match_first_pos = v__token__Token_position(&p->tok);
	p->inside_match = true;
	v__parser__Parser_check(p, v__token__Kind_key_match);
	bool is_sum_type = false;
	v__ast__Expr cond = v__parser__Parser_expr(p, 0);
	p->inside_match = false;
	bool no_lcbr = p->tok.kind != v__token__Kind_lcbr;
	if (!no_lcbr) {
		v__parser__Parser_check(p, v__token__Kind_lcbr);
	}
	Array_v__ast__Comment comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,});
	Array_v__ast__MatchBranch branches = __new_array_with_default(0, 0, sizeof(v__ast__MatchBranch), 0);
	for (;;) {
		if (!(p->tok.kind != v__token__Kind_eof)) break;
		v__token__Position branch_first_pos = v__token__Token_position(&p->tok);
		Array_v__ast__Expr exprs = __new_array_with_default(0, 0, sizeof(v__ast__Expr), 0);
		Array_Array_v__ast__Comment ecmnts = __new_array_with_default(0, 0, sizeof(Array_v__ast__Comment), 0);
		v__parser__Parser_open_scope(p);
		bool is_else = false;
		if (p->tok.kind == v__token__Kind_key_else) {
			is_else = true;
			v__parser__Parser_next(p);
		} else if ((p->tok.kind == v__token__Kind_name && !(string_eq(p->tok.lit, _SLIT("C")) && p->peek_tok.kind == v__token__Kind_dot) && ((Array_string_contains(_const_v__ast__builtin_type_names, p->tok.lit)) || byte_is_capital(string_at(p->tok.lit, 0)) || (p->peek_tok.kind == v__token__Kind_dot && v__parser__Parser_peek_token(p, 2).lit.len > 0 && byte_is_capital(string_at(v__parser__Parser_peek_token(p, 2).lit, 0))))) || p->tok.kind == v__token__Kind_lsbr) {
			Array_v__ast__Type types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
			for (;;) {
				v__ast__Type parsed_type = v__parser__Parser_parse_type(p);
				array_push(&ecmnts, _MOV((Array_v__ast__Comment[]){ v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}) }));
				array_push(&types, _MOV((v__ast__Type[]){ parsed_type }));
				array_push(&exprs, _MOV((v__ast__Expr[]){ v__ast__TypeNode_to_sumtype_v__ast__Expr(ADDR(v__ast__TypeNode, ((v__ast__TypeNode){.typ = parsed_type,.pos = v__token__Token_position(&p->prev_tok),}))) }));
				if (p->tok.kind != v__token__Kind_comma) {
					break;
				}
				v__parser__Parser_check(p, v__token__Kind_comma);
			}
			is_sum_type = true;
		} else {
			for (;;) {
				p->inside_match_case = true;
				v__ast__Expr expr = v__parser__Parser_expr(p, 0);
				array_push(&ecmnts, _MOV((Array_v__ast__Comment[]){ v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}) }));
				p->inside_match_case = false;
				if (p->tok.kind == v__token__Kind_dotdot) {
					v__parser__Parser_error_with_pos(p, _SLIT("match only supports inclusive (`...`) ranges, not exclusive (`..`)"), v__token__Token_position(&p->tok));
					 v__ast__MatchExpr _t2395 = (v__ast__MatchExpr){.tok_kind = 0,.cond = {0},.branches = __new_array(0, 1, sizeof(v__ast__MatchBranch)),.pos = {0},.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.is_expr = 0,.return_type = 0,.cond_type = 0,.expected_type = 0,.is_sum_type = 0,};
					// autofree_scope_vars(pos=5320 line_nr=208 scope.pos=5198 scope.end_pos=5348)
					// af parent scope:
					// var "expr" var.pos=5086 var.line_nr=202
					// af parent scope:
					// af parent scope:
					// var "branch_first_pos" var.pos=4172 var.line_nr=169
					// var "exprs" var.pos=4215 var.line_nr=170
					// var "ecmnts" var.pos=4243 var.line_nr=171
					// var "is_else" var.pos=4310 var.line_nr=174
					// var "branch_last_pos" var.pos=5677 var.line_nr=228
					// var "stmts" var.pos=5776 var.line_nr=231
					// var "branch_scope" var.pos=5817 var.line_nr=232
					// var "pos" var.pos=5891 var.line_nr=235
					// var "post_comments" var.pos=5976 var.line_nr=236
					// af parent scope:
					// af parent scope:
					// var "p" var.pos=3783 var.line_nr=155
					// var "match_first_pos" var.pos=3823 var.line_nr=156
					// var "is_sum_type" var.pos=3908 var.line_nr=159
					// var "cond" var.pos=3930 var.line_nr=160
					// var "no_lcbr" var.pos=3973 var.line_nr=162
					// var "comments" var.pos=4040 var.line_nr=166
					// var "branches" var.pos=4112 var.line_nr=167
					// var "match_last_pos" var.pos=6368 var.line_nr=253
					// var "pos" var.pos=6408 var.line_nr=254
					// af parent scope:
					// af parent scope:
					return _t2395;
				} else if (p->tok.kind == v__token__Kind_ellipsis) {
					v__parser__Parser_next(p);
					v__ast__Expr expr2 = v__parser__Parser_expr(p, 0);
					array_push(&exprs, _MOV((v__ast__Expr[]){ v__ast__RangeExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__RangeExpr, ((v__ast__RangeExpr){.low = expr,.high = expr2,.has_high = true,.has_low = true,.pos = v__token__Token_position(&p->tok),}))) }));
				} else {
					array_push(&exprs, _MOV((v__ast__Expr[]){ expr }));
				}
				if (p->tok.kind != v__token__Kind_comma) {
					break;
				}
				v__parser__Parser_check(p, v__token__Kind_comma);
			}
		}
		v__token__Position branch_last_pos = v__token__Token_position(&p->prev_tok);
		p->inside_match_body = true;
		Array_v__ast__Stmt stmts = v__parser__Parser_parse_block_no_scope(p, false);
		v__ast__Scope* branch_scope = p->scope;
		v__parser__Parser_close_scope(p);
		p->inside_match_body = false;
		v__token__Position pos = v__token__Position_extend_with_last_line(branch_first_pos, branch_last_pos, p->prev_tok.line_nr);
		Array_v__ast__Comment post_comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,});
		array_push(&branches, _MOV((v__ast__MatchBranch[]){ (v__ast__MatchBranch){
			.exprs = exprs,
			.ecmnts = ecmnts,
			.stmts = stmts,
			.pos = pos,
			.is_else = is_else,
			.post_comments = post_comments,
			.scope = branch_scope,
		} }));
		if (is_else && branches.len == 1) {
			v__parser__Parser_warn_with_pos(p, _SLIT("`match` must have at least one non `else` branch"), pos);
		}
		if (p->tok.kind == v__token__Kind_rcbr || (is_else && no_lcbr)) {
			break;
		}
	}
	v__token__Position match_last_pos = v__token__Token_position(&p->tok);
	v__token__Position pos = (v__token__Position){.len = match_last_pos.pos - match_first_pos.pos + match_last_pos.len,.line_nr = match_first_pos.line_nr,.pos = match_first_pos.pos,.col = match_first_pos.col,.last_line = 0,};
	if (p->tok.kind == v__token__Kind_rcbr) {
		v__parser__Parser_check(p, v__token__Kind_rcbr);
	}
	v__token__Position_update_last_line(&pos, p->prev_tok.line_nr);
	 v__ast__MatchExpr _t2399 = (v__ast__MatchExpr){.tok_kind = 0,.cond = cond,.branches = branches,.pos = pos,.comments = comments,.is_expr = 0,.return_type = 0,.cond_type = 0,.expected_type = 0,.is_sum_type = is_sum_type,};
	// autofree_scope_vars(pos=6708 line_nr=265 scope.pos=3778 scope.end_pos=6827)
	// var "p" var.pos=3783 var.line_nr=155
	// var "match_first_pos" var.pos=3823 var.line_nr=156
	// var "is_sum_type" var.pos=3908 var.line_nr=159
	// var "cond" var.pos=3930 var.line_nr=160
	// var "no_lcbr" var.pos=3973 var.line_nr=162
	// var "comments" var.pos=4040 var.line_nr=166
	// var "branches" var.pos=4112 var.line_nr=167
	// var "match_last_pos" var.pos=6368 var.line_nr=253
	// var "pos" var.pos=6408 var.line_nr=254
	// af parent scope:
	// af parent scope:
	return _t2399;
}

VV_LOCAL_SYMBOL v__ast__SelectExpr v__parser__Parser_select_expr(v__parser__Parser* p) {
	v__token__Position match_first_pos = v__token__Token_position(&p->tok);
	v__parser__Parser_check(p, v__token__Kind_key_select);
	bool no_lcbr = p->tok.kind != v__token__Kind_lcbr;
	if (!no_lcbr) {
		v__parser__Parser_check(p, v__token__Kind_lcbr);
	}
	Array_v__ast__SelectBranch branches = __new_array_with_default(0, 0, sizeof(v__ast__SelectBranch), 0);
	bool has_else = false;
	bool has_timeout = false;
	for (;;) {
		v__token__Position branch_first_pos = v__token__Token_position(&p->tok);
		v__ast__Comment comment = v__parser__Parser_check_comment(p);
		v__parser__Parser_open_scope(p);
		bool is_else = false;
		bool is_timeout = false;
		v__ast__Stmt stmt = v__ast__empty_stmt();
		if (p->tok.kind == v__token__Kind_key_else) {
			if (has_timeout) {
				v__parser__Parser_error_with_pos(p, _SLIT("timeout `> t` and `else` are mutually exclusive `select` keys"), v__token__Token_position(&p->tok));
				 v__ast__SelectExpr _t2400 = (v__ast__SelectExpr){.branches = __new_array(0, 1, sizeof(v__ast__SelectBranch)),.pos = {0},.has_exception = 0,.is_expr = 0,.expected_type = 0,};
				// autofree_scope_vars(pos=7466 line_nr=296 scope.pos=7352 scope.end_pos=7494)
				// af parent scope:
				// af parent scope:
				// var "branch_first_pos" var.pos=7101 var.line_nr=285
				// var "comment" var.pos=7140 var.line_nr=286
				// var "is_else" var.pos=7229 var.line_nr=289
				// var "is_timeout" var.pos=7252 var.line_nr=290
				// var "stmt" var.pos=7278 var.line_nr=291
				// var "branch_last_pos" var.pos=9904 var.line_nr=394
				// var "stmts" var.pos=9971 var.line_nr=396
				// var "pos" var.pos=10064 var.line_nr=399
				// var "post_comments" var.pos=10261 var.line_nr=405
				// af parent scope:
				// var "p" var.pos=6838 var.line_nr=274
				// var "match_first_pos" var.pos=6880 var.line_nr=275
				// var "no_lcbr" var.pos=6939 var.line_nr=277
				// var "branches" var.pos=7010 var.line_nr=281
				// var "has_else" var.pos=7048 var.line_nr=282
				// var "has_timeout" var.pos=7071 var.line_nr=283
				// var "match_last_pos" var.pos=10687 var.line_nr=423
				// var "pos" var.pos=10723 var.line_nr=424
				// af parent scope:
				// af parent scope:
				return _t2400;
			}
			if (has_else) {
				v__parser__Parser_error_with_pos(p, _SLIT("at most one `else` branch allowed in `select` block"), v__token__Token_position(&p->tok));
				 v__ast__SelectExpr _t2401 = (v__ast__SelectExpr){.branches = __new_array(0, 1, sizeof(v__ast__SelectBranch)),.pos = {0},.has_exception = 0,.is_expr = 0,.expected_type = 0,};
				// autofree_scope_vars(pos=7615 line_nr=301 scope.pos=7511 scope.end_pos=7643)
				// af parent scope:
				// af parent scope:
				// var "branch_first_pos" var.pos=7101 var.line_nr=285
				// var "comment" var.pos=7140 var.line_nr=286
				// var "is_else" var.pos=7229 var.line_nr=289
				// var "is_timeout" var.pos=7252 var.line_nr=290
				// var "stmt" var.pos=7278 var.line_nr=291
				// var "branch_last_pos" var.pos=9904 var.line_nr=394
				// var "stmts" var.pos=9971 var.line_nr=396
				// var "pos" var.pos=10064 var.line_nr=399
				// var "post_comments" var.pos=10261 var.line_nr=405
				// af parent scope:
				// var "p" var.pos=6838 var.line_nr=274
				// var "match_first_pos" var.pos=6880 var.line_nr=275
				// var "no_lcbr" var.pos=6939 var.line_nr=277
				// var "branches" var.pos=7010 var.line_nr=281
				// var "has_else" var.pos=7048 var.line_nr=282
				// var "has_timeout" var.pos=7071 var.line_nr=283
				// var "match_last_pos" var.pos=10687 var.line_nr=423
				// var "pos" var.pos=10723 var.line_nr=424
				// af parent scope:
				// af parent scope:
				return _t2401;
			}
			is_else = true;
			has_else = true;
			v__parser__Parser_next(p);
		} else if (p->tok.kind == v__token__Kind_gt) {
			if (has_else) {
				v__parser__Parser_error_with_pos(p, _SLIT("`else` and timeout `> t` are mutually exclusive `select` keys"), v__token__Token_position(&p->tok));
				 v__ast__SelectExpr _t2402 = (v__ast__SelectExpr){.branches = __new_array(0, 1, sizeof(v__ast__SelectBranch)),.pos = {0},.has_exception = 0,.is_expr = 0,.expected_type = 0,};
				// autofree_scope_vars(pos=7855 line_nr=310 scope.pos=7741 scope.end_pos=7883)
				// af parent scope:
				// var "expr" var.pos=8127 var.line_nr=321
				// af parent scope:
				// var "branch_first_pos" var.pos=7101 var.line_nr=285
				// var "comment" var.pos=7140 var.line_nr=286
				// var "is_else" var.pos=7229 var.line_nr=289
				// var "is_timeout" var.pos=7252 var.line_nr=290
				// var "stmt" var.pos=7278 var.line_nr=291
				// var "branch_last_pos" var.pos=9904 var.line_nr=394
				// var "stmts" var.pos=9971 var.line_nr=396
				// var "pos" var.pos=10064 var.line_nr=399
				// var "post_comments" var.pos=10261 var.line_nr=405
				// af parent scope:
				// var "p" var.pos=6838 var.line_nr=274
				// var "match_first_pos" var.pos=6880 var.line_nr=275
				// var "no_lcbr" var.pos=6939 var.line_nr=277
				// var "branches" var.pos=7010 var.line_nr=281
				// var "has_else" var.pos=7048 var.line_nr=282
				// var "has_timeout" var.pos=7071 var.line_nr=283
				// var "match_last_pos" var.pos=10687 var.line_nr=423
				// var "pos" var.pos=10723 var.line_nr=424
				// af parent scope:
				// af parent scope:
				return _t2402;
			}
			if (has_timeout) {
				v__parser__Parser_error_with_pos(p, _SLIT("at most one timeout `> t` branch allowed in `select` block"), v__token__Token_position(&p->tok));
				 v__ast__SelectExpr _t2403 = (v__ast__SelectExpr){.branches = __new_array(0, 1, sizeof(v__ast__SelectBranch)),.pos = {0},.has_exception = 0,.is_expr = 0,.expected_type = 0,};
				// autofree_scope_vars(pos=8014 line_nr=315 scope.pos=7903 scope.end_pos=8042)
				// af parent scope:
				// var "expr" var.pos=8127 var.line_nr=321
				// af parent scope:
				// var "branch_first_pos" var.pos=7101 var.line_nr=285
				// var "comment" var.pos=7140 var.line_nr=286
				// var "is_else" var.pos=7229 var.line_nr=289
				// var "is_timeout" var.pos=7252 var.line_nr=290
				// var "stmt" var.pos=7278 var.line_nr=291
				// var "branch_last_pos" var.pos=9904 var.line_nr=394
				// var "stmts" var.pos=9971 var.line_nr=396
				// var "pos" var.pos=10064 var.line_nr=399
				// var "post_comments" var.pos=10261 var.line_nr=405
				// af parent scope:
				// var "p" var.pos=6838 var.line_nr=274
				// var "match_first_pos" var.pos=6880 var.line_nr=275
				// var "no_lcbr" var.pos=6939 var.line_nr=277
				// var "branches" var.pos=7010 var.line_nr=281
				// var "has_else" var.pos=7048 var.line_nr=282
				// var "has_timeout" var.pos=7071 var.line_nr=283
				// var "match_last_pos" var.pos=10687 var.line_nr=423
				// var "pos" var.pos=10723 var.line_nr=424
				// af parent scope:
				// af parent scope:
				return _t2403;
			}
			is_timeout = true;
			has_timeout = true;
			v__parser__Parser_next(p);
			p->inside_match = true;
			v__ast__Expr expr = v__parser__Parser_expr(p, 0);
			p->inside_match = false;
			stmt = v__ast__ExprStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__ExprStmt, ((v__ast__ExprStmt){.expr = expr,.pos = v__ast__Expr_position(expr),.comments = new_array_from_c_array(1, 1, sizeof(v__ast__Comment), _MOV((v__ast__Comment[1]){comment})),.is_expr = true,.typ = 0,})));
		} else {
			p->inside_match = true;
			p->inside_select = true;
			multi_return_Array_v__ast__Expr_Array_v__ast__Comment mr_8363 = v__parser__Parser_expr_list(p);
			Array_v__ast__Expr exprs = mr_8363.arg0;
			Array_v__ast__Comment comments = mr_8363.arg1;
			if (exprs.len != 1) {
				v__parser__Parser_error(p, _SLIT("only one expression allowed as `select` key"));
				 v__ast__SelectExpr _t2404 = (v__ast__SelectExpr){.branches = __new_array(0, 1, sizeof(v__ast__SelectBranch)),.pos = {0},.has_exception = 0,.is_expr = 0,.expected_type = 0,};
				// autofree_scope_vars(pos=8465 line_nr=335 scope.pos=8401 scope.end_pos=8493)
				// af parent scope:
				// var "exprs" var.pos=8347 var.line_nr=332
				// var "comments" var.pos=8354 var.line_nr=332
				// af parent scope:
				// var "branch_first_pos" var.pos=7101 var.line_nr=285
				// var "comment" var.pos=7140 var.line_nr=286
				// var "is_else" var.pos=7229 var.line_nr=289
				// var "is_timeout" var.pos=7252 var.line_nr=290
				// var "stmt" var.pos=7278 var.line_nr=291
				// var "branch_last_pos" var.pos=9904 var.line_nr=394
				// var "stmts" var.pos=9971 var.line_nr=396
				// var "pos" var.pos=10064 var.line_nr=399
				// var "post_comments" var.pos=10261 var.line_nr=405
				// af parent scope:
				// var "p" var.pos=6838 var.line_nr=274
				// var "match_first_pos" var.pos=6880 var.line_nr=275
				// var "no_lcbr" var.pos=6939 var.line_nr=277
				// var "branches" var.pos=7010 var.line_nr=281
				// var "has_else" var.pos=7048 var.line_nr=282
				// var "has_timeout" var.pos=7071 var.line_nr=283
				// var "match_last_pos" var.pos=10687 var.line_nr=423
				// var "pos" var.pos=10723 var.line_nr=424
				// af parent scope:
				// af parent scope:
				return _t2404;
			}
			if ((p->tok.kind == v__token__Kind_assign || p->tok.kind == v__token__Kind_decl_assign)) {
				stmt = v__parser__Parser_partial_assign_stmt(p, exprs, comments);
			} else {
				stmt = v__ast__ExprStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__ExprStmt, ((v__ast__ExprStmt){.expr = (*(v__ast__Expr*)/*ee elem_typ */array_get(exprs, 0)),.pos = v__ast__Expr_position((*(v__ast__Expr*)/*ee elem_typ */array_get(exprs, 0))),.comments = new_array_from_c_array(1, 1, sizeof(v__ast__Comment), _MOV((v__ast__Comment[1]){comment})),.is_expr = true,.typ = 0,})));
			}
			p->inside_match = false;
			p->inside_select = false;
			if (stmt._typ == 293 /* v.ast.ExprStmt */) {
				if (!(*stmt._v__ast__ExprStmt).is_expr) {
					v__parser__Parser_error_with_pos(p, _SLIT("select: invalid expression"), (*stmt._v__ast__ExprStmt).pos);
					 v__ast__SelectExpr _t2405 = (v__ast__SelectExpr){.branches = __new_array(0, 1, sizeof(v__ast__SelectBranch)),.pos = {0},.has_exception = 0,.is_expr = 0,.expected_type = 0,};
					// autofree_scope_vars(pos=8917 line_nr=353 scope.pos=8847 scope.end_pos=8947)
					// af parent scope:
					// var "stmt" var.pos=8799 var.line_nr=349
					// af parent scope:
					// var "exprs" var.pos=8347 var.line_nr=332
					// var "comments" var.pos=8354 var.line_nr=332
					// af parent scope:
					// var "branch_first_pos" var.pos=7101 var.line_nr=285
					// var "comment" var.pos=7140 var.line_nr=286
					// var "is_else" var.pos=7229 var.line_nr=289
					// var "is_timeout" var.pos=7252 var.line_nr=290
					// var "stmt" var.pos=7278 var.line_nr=291
					// var "branch_last_pos" var.pos=9904 var.line_nr=394
					// var "stmts" var.pos=9971 var.line_nr=396
					// var "pos" var.pos=10064 var.line_nr=399
					// var "post_comments" var.pos=10261 var.line_nr=405
					// af parent scope:
					// var "p" var.pos=6838 var.line_nr=274
					// var "match_first_pos" var.pos=6880 var.line_nr=275
					// var "no_lcbr" var.pos=6939 var.line_nr=277
					// var "branches" var.pos=7010 var.line_nr=281
					// var "has_else" var.pos=7048 var.line_nr=282
					// var "has_timeout" var.pos=7071 var.line_nr=283
					// var "match_last_pos" var.pos=10687 var.line_nr=423
					// var "pos" var.pos=10723 var.line_nr=424
					// af parent scope:
					// af parent scope:
					return _t2405;
				} else {
					if ((*stmt._v__ast__ExprStmt).expr._typ == 258 /* v.ast.InfixExpr */) {
						if ((*(*stmt._v__ast__ExprStmt).expr._v__ast__InfixExpr).op != v__token__Kind_arrow) {
							v__parser__Parser_error_with_pos(p, _SLIT("select key: `<-` operator expected"), (*(*stmt._v__ast__ExprStmt).expr._v__ast__InfixExpr).pos);
							 v__ast__SelectExpr _t2406 = (v__ast__SelectExpr){.branches = __new_array(0, 1, sizeof(v__ast__SelectBranch)),.pos = {0},.has_exception = 0,.is_expr = 0,.expected_type = 0,};
							// autofree_scope_vars(pos=9140 line_nr=360 scope.pos=9041 scope.end_pos=9173)
							// af parent scope:
							// af parent scope:
							// af parent scope:
							// var "stmt" var.pos=8799 var.line_nr=349
							// af parent scope:
							// var "exprs" var.pos=8347 var.line_nr=332
							// var "comments" var.pos=8354 var.line_nr=332
							// af parent scope:
							// var "branch_first_pos" var.pos=7101 var.line_nr=285
							// var "comment" var.pos=7140 var.line_nr=286
							// var "is_else" var.pos=7229 var.line_nr=289
							// var "is_timeout" var.pos=7252 var.line_nr=290
							// var "stmt" var.pos=7278 var.line_nr=291
							// var "branch_last_pos" var.pos=9904 var.line_nr=394
							// var "stmts" var.pos=9971 var.line_nr=396
							// var "pos" var.pos=10064 var.line_nr=399
							// var "post_comments" var.pos=10261 var.line_nr=405
							// af parent scope:
							// var "p" var.pos=6838 var.line_nr=274
							// var "match_first_pos" var.pos=6880 var.line_nr=275
							// var "no_lcbr" var.pos=6939 var.line_nr=277
							// var "branches" var.pos=7010 var.line_nr=281
							// var "has_else" var.pos=7048 var.line_nr=282
							// var "has_timeout" var.pos=7071 var.line_nr=283
							// var "match_last_pos" var.pos=10687 var.line_nr=423
							// var "pos" var.pos=10723 var.line_nr=424
							// af parent scope:
							// af parent scope:
							return _t2406;
						}
					}
					else {
						v__parser__Parser_error_with_pos(p, _SLIT("select key: send expression (`ch <- x`) expected"), (*stmt._v__ast__ExprStmt).pos);
						 v__ast__SelectExpr _t2407 = (v__ast__SelectExpr){.branches = __new_array(0, 1, sizeof(v__ast__SelectBranch)),.pos = {0},.has_exception = 0,.is_expr = 0,.expected_type = 0,};
						// autofree_scope_vars(pos=9301 line_nr=366 scope.pos=9191 scope.end_pos=9333)
						// af parent scope:
						// af parent scope:
						// var "stmt" var.pos=8799 var.line_nr=349
						// af parent scope:
						// var "exprs" var.pos=8347 var.line_nr=332
						// var "comments" var.pos=8354 var.line_nr=332
						// af parent scope:
						// var "branch_first_pos" var.pos=7101 var.line_nr=285
						// var "comment" var.pos=7140 var.line_nr=286
						// var "is_else" var.pos=7229 var.line_nr=289
						// var "is_timeout" var.pos=7252 var.line_nr=290
						// var "stmt" var.pos=7278 var.line_nr=291
						// var "branch_last_pos" var.pos=9904 var.line_nr=394
						// var "stmts" var.pos=9971 var.line_nr=396
						// var "pos" var.pos=10064 var.line_nr=399
						// var "post_comments" var.pos=10261 var.line_nr=405
						// af parent scope:
						// var "p" var.pos=6838 var.line_nr=274
						// var "match_first_pos" var.pos=6880 var.line_nr=275
						// var "no_lcbr" var.pos=6939 var.line_nr=277
						// var "branches" var.pos=7010 var.line_nr=281
						// var "has_else" var.pos=7048 var.line_nr=282
						// var "has_timeout" var.pos=7071 var.line_nr=283
						// var "match_last_pos" var.pos=10687 var.line_nr=423
						// var "pos" var.pos=10723 var.line_nr=424
						// af parent scope:
						// af parent scope:
						return _t2407;
					};
				}
			}
			else if (stmt._typ == 285 /* v.ast.AssignStmt */) {
				v__ast__Expr expr = (*(v__ast__Expr*)/*ee elem_typ */array_get((*stmt._v__ast__AssignStmt).right, 0));
				if (expr._typ == 270 /* v.ast.PrefixExpr */) {
					if ((*expr._v__ast__PrefixExpr).op != v__token__Kind_arrow) {
						v__parser__Parser_error_with_pos(p, _SLIT("select key: `<-` operator expected"), (*expr._v__ast__PrefixExpr).pos);
						 v__ast__SelectExpr _t2408 = (v__ast__SelectExpr){.branches = __new_array(0, 1, sizeof(v__ast__SelectBranch)),.pos = {0},.has_exception = 0,.is_expr = 0,.expected_type = 0,};
						// autofree_scope_vars(pos=9564 line_nr=378 scope.pos=9473 scope.end_pos=9596)
						// af parent scope:
						// var "expr" var.pos=9415 var.line_nr=373
						// af parent scope:
						// var "expr" var.pos=9382 var.line_nr=372
						// var "stmt" var.pos=8799 var.line_nr=349
						// af parent scope:
						// var "exprs" var.pos=8347 var.line_nr=332
						// var "comments" var.pos=8354 var.line_nr=332
						// af parent scope:
						// var "branch_first_pos" var.pos=7101 var.line_nr=285
						// var "comment" var.pos=7140 var.line_nr=286
						// var "is_else" var.pos=7229 var.line_nr=289
						// var "is_timeout" var.pos=7252 var.line_nr=290
						// var "stmt" var.pos=7278 var.line_nr=291
						// var "branch_last_pos" var.pos=9904 var.line_nr=394
						// var "stmts" var.pos=9971 var.line_nr=396
						// var "pos" var.pos=10064 var.line_nr=399
						// var "post_comments" var.pos=10261 var.line_nr=405
						// af parent scope:
						// var "p" var.pos=6838 var.line_nr=274
						// var "match_first_pos" var.pos=6880 var.line_nr=275
						// var "no_lcbr" var.pos=6939 var.line_nr=277
						// var "branches" var.pos=7010 var.line_nr=281
						// var "has_else" var.pos=7048 var.line_nr=282
						// var "has_timeout" var.pos=7071 var.line_nr=283
						// var "match_last_pos" var.pos=10687 var.line_nr=423
						// var "pos" var.pos=10723 var.line_nr=424
						// af parent scope:
						// af parent scope:
						return _t2408;
					}
				}
				else {
					v__parser__Parser_error_with_pos(p, _SLIT("select key: receive expression expected"), v__ast__Expr_position((*(v__ast__Expr*)/*ee elem_typ */array_get((*stmt._v__ast__AssignStmt).right, 0))));
					 v__ast__SelectExpr _t2409 = (v__ast__SelectExpr){.branches = __new_array(0, 1, sizeof(v__ast__SelectBranch)),.pos = {0},.has_exception = 0,.is_expr = 0,.expected_type = 0,};
					// autofree_scope_vars(pos=9726 line_nr=384 scope.pos=9612 scope.end_pos=9757)
					// af parent scope:
					// var "expr" var.pos=9382 var.line_nr=372
					// var "stmt" var.pos=8799 var.line_nr=349
					// af parent scope:
					// var "exprs" var.pos=8347 var.line_nr=332
					// var "comments" var.pos=8354 var.line_nr=332
					// af parent scope:
					// var "branch_first_pos" var.pos=7101 var.line_nr=285
					// var "comment" var.pos=7140 var.line_nr=286
					// var "is_else" var.pos=7229 var.line_nr=289
					// var "is_timeout" var.pos=7252 var.line_nr=290
					// var "stmt" var.pos=7278 var.line_nr=291
					// var "branch_last_pos" var.pos=9904 var.line_nr=394
					// var "stmts" var.pos=9971 var.line_nr=396
					// var "pos" var.pos=10064 var.line_nr=399
					// var "post_comments" var.pos=10261 var.line_nr=405
					// af parent scope:
					// var "p" var.pos=6838 var.line_nr=274
					// var "match_first_pos" var.pos=6880 var.line_nr=275
					// var "no_lcbr" var.pos=6939 var.line_nr=277
					// var "branches" var.pos=7010 var.line_nr=281
					// var "has_else" var.pos=7048 var.line_nr=282
					// var "has_timeout" var.pos=7071 var.line_nr=283
					// var "match_last_pos" var.pos=10687 var.line_nr=423
					// var "pos" var.pos=10723 var.line_nr=424
					// af parent scope:
					// af parent scope:
					return _t2409;
				};
			}
			else {
				v__parser__Parser_error_with_pos(p, _SLIT("select: transmission statement expected"), (*(stmt.pos)));
				 v__ast__SelectExpr _t2410 = (v__ast__SelectExpr){.branches = __new_array(0, 1, sizeof(v__ast__SelectBranch)),.pos = {0},.has_exception = 0,.is_expr = 0,.expected_type = 0,};
				// autofree_scope_vars(pos=9862 line_nr=390 scope.pos=9776 scope.end_pos=9891)
				// af parent scope:
				// var "exprs" var.pos=8347 var.line_nr=332
				// var "comments" var.pos=8354 var.line_nr=332
				// af parent scope:
				// var "branch_first_pos" var.pos=7101 var.line_nr=285
				// var "comment" var.pos=7140 var.line_nr=286
				// var "is_else" var.pos=7229 var.line_nr=289
				// var "is_timeout" var.pos=7252 var.line_nr=290
				// var "stmt" var.pos=7278 var.line_nr=291
				// var "branch_last_pos" var.pos=9904 var.line_nr=394
				// var "stmts" var.pos=9971 var.line_nr=396
				// var "pos" var.pos=10064 var.line_nr=399
				// var "post_comments" var.pos=10261 var.line_nr=405
				// af parent scope:
				// var "p" var.pos=6838 var.line_nr=274
				// var "match_first_pos" var.pos=6880 var.line_nr=275
				// var "no_lcbr" var.pos=6939 var.line_nr=277
				// var "branches" var.pos=7010 var.line_nr=281
				// var "has_else" var.pos=7048 var.line_nr=282
				// var "has_timeout" var.pos=7071 var.line_nr=283
				// var "match_last_pos" var.pos=10687 var.line_nr=423
				// var "pos" var.pos=10723 var.line_nr=424
				// af parent scope:
				// af parent scope:
				return _t2410;
			};
		}
		v__token__Position branch_last_pos = v__token__Token_position(&p->tok);
		p->inside_match_body = true;
		Array_v__ast__Stmt stmts = v__parser__Parser_parse_block_no_scope(p, false);
		v__parser__Parser_close_scope(p);
		p->inside_match_body = false;
		v__token__Position pos = (v__token__Position){.len = branch_last_pos.pos - branch_first_pos.pos + branch_last_pos.len,.line_nr = branch_first_pos.line_nr,.pos = branch_first_pos.pos,.col = branch_first_pos.col,.last_line = 0,};
		Array_v__ast__Comment post_comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,});
		v__token__Position_update_last_line(&pos, p->prev_tok.line_nr);
		if (post_comments.len > 0) {
			pos.last_line = (*(v__ast__Comment*)array_last(post_comments)).pos.last_line;
		}
		array_push(&branches, _MOV((v__ast__SelectBranch[]){ (v__ast__SelectBranch){
			.stmt = stmt,
			.stmts = stmts,
			.pos = pos,
			.comment = comment,
			.is_else = is_else,
			.is_timeout = is_timeout,
			.post_comments = post_comments,
		} }));
		if (p->tok.kind == v__token__Kind_rcbr || ((is_else || is_timeout) && no_lcbr)) {
			break;
		}
	}
	v__token__Position match_last_pos = v__token__Token_position(&p->tok);
	v__token__Position pos = (v__token__Position){.len = match_last_pos.pos - match_first_pos.pos + match_last_pos.len,.line_nr = match_first_pos.line_nr,.pos = match_first_pos.pos,.col = match_first_pos.col,.last_line = 0,};
	if (p->tok.kind == v__token__Kind_rcbr) {
		v__parser__Parser_check(p, v__token__Kind_rcbr);
	}
	 v__ast__SelectExpr _t2412 = (v__ast__SelectExpr){.branches = branches,.pos = v__token__Position_extend_with_last_line(pos, v__token__Token_position(&p->prev_tok), p->prev_tok.line_nr),.has_exception = has_else || has_timeout,.is_expr = 0,.expected_type = 0,};
	// autofree_scope_vars(pos=10953 line_nr=433 scope.pos=6833 scope.end_pos=11118)
	// var "p" var.pos=6838 var.line_nr=274
	// var "match_first_pos" var.pos=6880 var.line_nr=275
	// var "no_lcbr" var.pos=6939 var.line_nr=277
	// var "branches" var.pos=7010 var.line_nr=281
	// var "has_else" var.pos=7048 var.line_nr=282
	// var "has_timeout" var.pos=7071 var.line_nr=283
	// var "match_last_pos" var.pos=10687 var.line_nr=423
	// var "pos" var.pos=10723 var.line_nr=424
	// af parent scope:
	// af parent scope:
	return _t2412;
}

VV_LOCAL_SYMBOL v__ast__LockExpr v__parser__Parser_lock_expr(v__parser__Parser* p) {
	v__parser__Parser_register_auto_import(p, _SLIT("sync"));
	v__token__Position pos = v__token__Token_position(&p->tok);
	Array_v__ast__Ident lockeds = __new_array_with_default(0, 0, sizeof(v__ast__Ident), 0);
	Array_bool is_rlocked = __new_array_with_default(0, 0, sizeof(bool), 0);
	outer:
	for (;;) {
		if (p->tok.kind == v__token__Kind_lcbr) {
			break;
		}
		bool is_rlock = p->tok.kind == v__token__Kind_key_rlock;
		if (!is_rlock && p->tok.kind != v__token__Kind_key_lock) {
			v__parser__Parser_error_with_pos(p, _STR("unexpected %.*s\000, expected `lock` or `rlock`", 2, v__token__Token_str(p->tok)), v__token__Token_position(&p->tok));
		}
		v__parser__Parser_next(p);
		for (;;) {
			if (!(p->tok.kind == v__token__Kind_name)) break;
			array_push(&lockeds, _MOV((v__ast__Ident[]){ (v__ast__Ident){
				.language = v__ast__Language_v,
				.tok_kind = 0,
				.pos = v__token__Token_position(&p->tok),
				.mut_pos = {0},
				.scope = p->scope,
				.obj = {0},
				.mod = p->mod,
				.name = p->tok.lit,
				.kind = 0,
				.info = v__ast__IdentVar_to_sumtype_v__ast__IdentInfo(ADDR(v__ast__IdentVar, ((v__ast__IdentVar){.typ = 0,.is_mut = 0,.is_static = 0,.is_optional = 0,.share = 0,}))),
				.is_mut = true,
			} }));
			array_push(&is_rlocked, _MOV((bool[]){ is_rlock }));
			v__parser__Parser_next(p);
			if (p->tok.kind == v__token__Kind_lcbr) {
				goto outer__break;
			}
			if (p->tok.kind == v__token__Kind_semicolon) {
				v__parser__Parser_next(p);
				break;
			}
			v__parser__Parser_check(p, v__token__Kind_comma);
		}
		outer__continue: {}
	}
	outer__break: {}
	Array_v__ast__Stmt stmts = v__parser__Parser_parse_block(p);
	v__token__Position_update_last_line(&pos, p->prev_tok.line_nr);
	 v__ast__LockExpr _t2415 = (v__ast__LockExpr){.stmts = stmts,.is_rlock = is_rlocked,.pos = pos,.lockeds = lockeds,.is_expr = 0,.typ = 0,};
	// autofree_scope_vars(pos=913 line_nr=43 scope.pos=32 scope.end_pos=1006)
	// var "p" var.pos=37 var.line_nr=4
	// var "pos" var.pos=141 var.line_nr=7
	// var "lockeds" var.pos=170 var.line_nr=8
	// var "is_rlocked" var.pos=200 var.line_nr=9
	// var "stmts" var.pos=846 var.line_nr=41
	// af parent scope:
	// af parent scope:
	return _t2415;
}

bool v__parser__Parser_known_import(v__parser__Parser* p, string mod) {
	 bool _t2416 = _IN_MAP(ADDR(string, mod), ADDR(map, p->imports));
	// autofree_scope_vars(pos=300 line_nr=9 scope.pos=256 scope.end_pos=325)
	// var "p" var.pos=257 var.line_nr=8
	// var "mod" var.pos=281 var.line_nr=8
	// af parent scope:
	// af parent scope:
	return _t2416;
}

VV_LOCAL_SYMBOL string v__parser__Parser_prepend_mod(v__parser__Parser* p, string name) {
	if ((p->expr_mod).len != 0) {
		 string _t2417 = string_add(string_add(p->expr_mod, _SLIT(".")), name);
		// autofree_scope_vars(pos=475 line_nr=15 scope.pos=472 scope.end_pos=508)
		// af parent scope:
		// var "p" var.pos=332 var.line_nr=12
		// var "name" var.pos=355 var.line_nr=12
		// af parent scope:
		// af parent scope:
		return _t2417;
	}
	if (p->builtin_mod) {
		// autofree_scope_vars(pos=531 line_nr=18 scope.pos=528 scope.end_pos=545)
		// af parent scope:
		// var "p" var.pos=332 var.line_nr=12
		// var "name" var.pos=355 var.line_nr=12
		// af parent scope:
		// af parent scope:
		return name;
	}
	 string _t2418 = _STR("%.*s\000.%.*s", 2, p->mod, name);
	// autofree_scope_vars(pos=547 line_nr=20 scope.pos=331 scope.end_pos=572)
	// var "p" var.pos=332 var.line_nr=12
	// var "name" var.pos=355 var.line_nr=12
	// af parent scope:
	// af parent scope:
	return _t2418;
}

VV_LOCAL_SYMBOL bool v__parser__Parser_is_used_import(v__parser__Parser* p, string alias) {
	 bool _t2419 = (Array_string_contains(p->used_imports, alias));
	// autofree_scope_vars(pos=626 line_nr=24 scope.pos=578 scope.end_pos=658)
	// var "p" var.pos=579 var.line_nr=23
	// var "alias" var.pos=605 var.line_nr=23
	// af parent scope:
	// af parent scope:
	return _t2419;
}

VV_LOCAL_SYMBOL void v__parser__Parser_register_used_import(v__parser__Parser* p, string alias) {
	if (!v__parser__Parser_is_used_import(p, alias)) {
		array_push(&p->used_imports, _MOV((string[]){ string_clone(alias) }));
	}
}

VV_LOCAL_SYMBOL void v__parser__Parser_register_auto_import(v__parser__Parser* p, string alias) {
	if (!_IN_MAP(ADDR(string, alias), ADDR(map, p->imports))) {
		map_set(&p->imports, &(string[]){alias}, &(string[]) { alias });
		array_push(&p->table->imports, _MOV((string[]){ string_clone(alias) }));
		v__ast__Import node = (v__ast__Import){.mod = alias,.alias = alias,.pos = v__token__Token_position(&p->tok),.mod_pos = {0},.alias_pos = {0},.syms_pos = {0},.syms = __new_array(0, 1, sizeof(v__ast__ImportSymbol)),.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.next_comments = __new_array(0, 1, sizeof(v__ast__Comment)),};
		array_push(&p->ast_imports, _MOV((v__ast__Import[]){ node }));
	}
	if (!(Array_string_contains(p->auto_imports, alias))) {
		array_push(&p->auto_imports, _MOV((string[]){ string_clone(alias) }));
	}
	v__parser__Parser_register_used_import(p, alias);
}

VV_LOCAL_SYMBOL void v__parser__Parser_check_unused_imports(v__parser__Parser* p) {
	if (p->pref->is_repl || p->pref->is_fmt) {
		return;
	}
	// FOR IN array
	for (int _t2424 = 0; _t2424 < p->ast_imports.len; ++_t2424) {
		v__ast__Import import_m = ((v__ast__Import*)p->ast_imports.data)[_t2424];
		string alias = import_m.alias;
		string mod = import_m.mod;
		if (!v__parser__Parser_is_used_import(p, alias)) {
			string mod_alias = (string_eq(alias, mod) ? (alias) : (_STR("%.*s\000 (%.*s\000)", 3, alias, mod)));
			v__parser__Parser_warn_with_pos(p, _STR("module '%.*s\000' is imported but never used", 2, mod_alias), import_m.mod_pos);
		}
	}
}

v__ast__Type v__parser__Parser_parse_array_type(v__parser__Parser* p) {
	v__parser__Parser_check(p, v__token__Kind_lsbr);
	if ((p->tok.kind == v__token__Kind_number || p->tok.kind == v__token__Kind_name)) {
		int fixed_size = 0;
		v__ast__Expr size_expr = v__parser__Parser_expr(p, 0);
		if (size_expr._typ == 259 /* v.ast.IntegerLiteral */) {
			fixed_size = string_int((*size_expr._v__ast__IntegerLiteral).val);
		}
		else if (size_expr._typ == 254 /* v.ast.Ident */) {
			Option_v__ast__ConstField_ptr _t2425;
			if (_t2425 = v__ast__Scope_find_const(p->global_scope, _STR("%.*s\000.%.*s", 2, p->mod, (*size_expr._v__ast__Ident).name)), _t2425.state == 0) {
				v__ast__ConstField* const_field = *(v__ast__ConstField**)_t2425.data;
				if ((const_field->expr)._typ == 259 /* v.ast.IntegerLiteral */) {
					fixed_size = string_int((*const_field->expr._v__ast__IntegerLiteral).val);
				} else {
					v__parser__Parser_error_with_pos(p, _STR("non-constant array bound `%.*s\000`", 2, (*size_expr._v__ast__Ident).name), (*size_expr._v__ast__Ident).pos);
				}
			} else {
				IError err = _t2425.err;
				v__parser__Parser_error_with_pos(p, _STR("non-constant array bound `%.*s\000`", 2, (*size_expr._v__ast__Ident).name), (*size_expr._v__ast__Ident).pos);
			}
		}
		else {
			v__parser__Parser_error(p, _SLIT("expecting `int` for fixed size"));
		};
		v__parser__Parser_check(p, v__token__Kind_rsbr);
		v__ast__Type elem_type = v__parser__Parser_parse_type(p);
		if (v__ast__Type_idx(elem_type) == 0) {
			 v__ast__Type _t2426 = 0;
			// autofree_scope_vars(pos=1053 line_nr=38 scope.pos=1012 scope.end_pos=1065)
			// af parent scope:
			// var "fixed_size" var.pos=340 var.line_nr=12
			// var "size_expr" var.pos=358 var.line_nr=13
			// var "elem_type" var.pos=958 var.line_nr=35
			// var "idx" var.pos=1226 var.line_nr=44
			// af parent scope:
			// var "p" var.pos=225 var.line_nr=8
			// var "elem_type" var.pos=1350 var.line_nr=49
			// var "nr_dims" var.pos=1456 var.line_nr=54
			// var "not_attr" var.pos=1486 var.line_nr=56
			// var "idx" var.pos=1654 var.line_nr=62
			// af parent scope:
			// af parent scope:
			return _t2426;
		}
		if (fixed_size <= 0) {
			v__parser__Parser_error_with_pos(p, _SLIT("fixed size cannot be zero or negative"), v__ast__Expr_position(size_expr));
		}
		int idx = v__ast__Table_find_or_register_array_fixed(p->table, elem_type, fixed_size);
		 v__ast__Type _t2427 = v__ast__new_type(idx);
		// autofree_scope_vars(pos=1294 line_nr=45 scope.pos=332 scope.end_pos=1321)
		// var "fixed_size" var.pos=340 var.line_nr=12
		// var "size_expr" var.pos=358 var.line_nr=13
		// var "elem_type" var.pos=958 var.line_nr=35
		// var "idx" var.pos=1226 var.line_nr=44
		// af parent scope:
		// var "p" var.pos=225 var.line_nr=8
		// var "elem_type" var.pos=1350 var.line_nr=49
		// var "nr_dims" var.pos=1456 var.line_nr=54
		// var "not_attr" var.pos=1486 var.line_nr=56
		// var "idx" var.pos=1654 var.line_nr=62
		// af parent scope:
		// af parent scope:
		return _t2427;
	}
	v__parser__Parser_check(p, v__token__Kind_rsbr);
	v__ast__Type elem_type = v__parser__Parser_parse_type(p);
	if (v__ast__Type_idx(elem_type) == 0) {
		 v__ast__Type _t2428 = 0;
		// autofree_scope_vars(pos=1438 line_nr=52 scope.pos=1403 scope.end_pos=1449)
		// af parent scope:
		// var "p" var.pos=225 var.line_nr=8
		// var "elem_type" var.pos=1350 var.line_nr=49
		// var "nr_dims" var.pos=1456 var.line_nr=54
		// var "not_attr" var.pos=1486 var.line_nr=56
		// var "idx" var.pos=1654 var.line_nr=62
		// af parent scope:
		// af parent scope:
		return _t2428;
	}
	int nr_dims = 1;
	bool not_attr = p->peek_tok.kind != v__token__Kind_name && !(v__parser__Parser_peek_token(p, 2).kind == v__token__Kind_semicolon || v__parser__Parser_peek_token(p, 2).kind == v__token__Kind_rsbr);
	for (;;) {
		if (!(p->tok.kind == v__token__Kind_lsbr && not_attr)) break;
		v__parser__Parser_next(p);
		v__parser__Parser_check(p, v__token__Kind_rsbr);
		nr_dims++;
	}
	int idx = v__ast__Table_find_or_register_array_with_dims(p->table, elem_type, nr_dims);
	 v__ast__Type _t2429 = v__ast__new_type(idx);
	// autofree_scope_vars(pos=1722 line_nr=63 scope.pos=220 scope.end_pos=1748)
	// var "p" var.pos=225 var.line_nr=8
	// var "elem_type" var.pos=1350 var.line_nr=49
	// var "nr_dims" var.pos=1456 var.line_nr=54
	// var "not_attr" var.pos=1486 var.line_nr=56
	// var "idx" var.pos=1654 var.line_nr=62
	// af parent scope:
	// af parent scope:
	return _t2429;
}

v__ast__Type v__parser__Parser_parse_map_type(v__parser__Parser* p) {
	v__parser__Parser_next(p);
	if (p->tok.kind != v__token__Kind_lsbr) {
		// autofree_scope_vars(pos=1838 line_nr=69 scope.pos=1835 scope.end_pos=1860)
		// af parent scope:
		// var "p" var.pos=1763 var.line_nr=66
		// var "key_type" var.pos=1879 var.line_nr=72
		// var "key_sym" var.pos=1907 var.line_nr=73
		// var "is_alias" var.pos=1953 var.line_nr=74
		// var "value_type" var.pos=2677 var.line_nr=93
		// var "idx" var.pos=2914 var.line_nr=102
		// af parent scope:
		// af parent scope:
		return _const_v__ast__map_type;
	}
	v__parser__Parser_check(p, v__token__Kind_lsbr);
	v__ast__Type key_type = v__parser__Parser_parse_type(p);
	v__ast__TypeSymbol* key_sym = v__ast__Table_get_type_symbol(p->table, key_type);
	bool is_alias = key_sym->kind == v__ast__Kind_alias;
	if (v__ast__Type_idx(key_type) == 0) {
		 v__ast__Type _t2430 = 0;
		// autofree_scope_vars(pos=2052 line_nr=77 scope.pos=2012 scope.end_pos=2063)
		// af parent scope:
		// var "p" var.pos=1763 var.line_nr=66
		// var "key_type" var.pos=1879 var.line_nr=72
		// var "key_sym" var.pos=1907 var.line_nr=73
		// var "is_alias" var.pos=1953 var.line_nr=74
		// var "value_type" var.pos=2677 var.line_nr=93
		// var "idx" var.pos=2914 var.line_nr=102
		// af parent scope:
		// af parent scope:
		return _t2430;
	}
	if (is_alias && !((key_type == _const_v__ast__string_type_idx || key_type == _const_v__ast__voidptr_type_idx) || ((v__ast__Type_is_int(key_type) || v__ast__Type_is_float(key_type)) && !v__ast__Type_is_ptr(key_type)))) {
		v__parser__Parser_error(p, _SLIT("cannot use the alias type as the parent type is unsupported"));
		 v__ast__Type _t2431 = 0;
		// autofree_scope_vars(pos=2288 line_nr=82 scope.pos=2212 scope.end_pos=2299)
		// af parent scope:
		// var "p" var.pos=1763 var.line_nr=66
		// var "key_type" var.pos=1879 var.line_nr=72
		// var "key_sym" var.pos=1907 var.line_nr=73
		// var "is_alias" var.pos=1953 var.line_nr=74
		// var "value_type" var.pos=2677 var.line_nr=93
		// var "idx" var.pos=2914 var.line_nr=102
		// af parent scope:
		// af parent scope:
		return _t2431;
	}
	if (!((key_type == _const_v__ast__string_type_idx || key_type == _const_v__ast__voidptr_type_idx) || key_sym->kind == v__ast__Kind_enum_ || ((v__ast__Type_is_int(key_type) || v__ast__Type_is_float(key_type) || is_alias) && !v__ast__Type_is_ptr(key_type)))) {
		string s = v__ast__Table_type_to_str(p->table, key_type);
		v__parser__Parser_error_with_pos(p, _STR("maps only support string, integer, float, rune, enum or voidptr keys for now (not `%.*s\000`)", 2, s), v__token__Token_position(&p->tok));
		 v__ast__Type _t2432 = 0;
		// autofree_scope_vars(pos=2647 line_nr=90 scope.pos=2476 scope.end_pos=2658)
		// var "s" var.pos=2480 var.line_nr=87
		// af parent scope:
		// var "p" var.pos=1763 var.line_nr=66
		// var "key_type" var.pos=1879 var.line_nr=72
		// var "key_sym" var.pos=1907 var.line_nr=73
		// var "is_alias" var.pos=1953 var.line_nr=74
		// var "value_type" var.pos=2677 var.line_nr=93
		// var "idx" var.pos=2914 var.line_nr=102
		// af parent scope:
		// af parent scope:
		return _t2432;
	}
	v__parser__Parser_check(p, v__token__Kind_rsbr);
	v__ast__Type value_type = v__parser__Parser_parse_type(p);
	if (v__ast__Type_idx(value_type) == 0) {
		 v__ast__Type _t2433 = 0;
		// autofree_scope_vars(pos=2772 line_nr=96 scope.pos=2732 scope.end_pos=2783)
		// af parent scope:
		// var "p" var.pos=1763 var.line_nr=66
		// var "key_type" var.pos=1879 var.line_nr=72
		// var "key_sym" var.pos=1907 var.line_nr=73
		// var "is_alias" var.pos=1953 var.line_nr=74
		// var "value_type" var.pos=2677 var.line_nr=93
		// var "idx" var.pos=2914 var.line_nr=102
		// af parent scope:
		// af parent scope:
		return _t2433;
	}
	if (v__ast__Type_idx(value_type) == _const_v__ast__void_type_idx) {
		v__parser__Parser_error_with_pos(p, _SLIT("map value type cannot be void"), v__token__Token_position(&p->tok));
		 v__ast__Type _t2434 = 0;
		// autofree_scope_vars(pos=2900 line_nr=100 scope.pos=2827 scope.end_pos=2911)
		// af parent scope:
		// var "p" var.pos=1763 var.line_nr=66
		// var "key_type" var.pos=1879 var.line_nr=72
		// var "key_sym" var.pos=1907 var.line_nr=73
		// var "is_alias" var.pos=1953 var.line_nr=74
		// var "value_type" var.pos=2677 var.line_nr=93
		// var "idx" var.pos=2914 var.line_nr=102
		// af parent scope:
		// af parent scope:
		return _t2434;
	}
	int idx = v__ast__Table_find_or_register_map(p->table, key_type, value_type);
	 v__ast__Type _t2435 = v__ast__new_type(idx);
	// autofree_scope_vars(pos=2972 line_nr=103 scope.pos=1758 scope.end_pos=2998)
	// var "p" var.pos=1763 var.line_nr=66
	// var "key_type" var.pos=1879 var.line_nr=72
	// var "key_sym" var.pos=1907 var.line_nr=73
	// var "is_alias" var.pos=1953 var.line_nr=74
	// var "value_type" var.pos=2677 var.line_nr=93
	// var "idx" var.pos=2914 var.line_nr=102
	// af parent scope:
	// af parent scope:
	return _t2435;
}

v__ast__Type v__parser__Parser_parse_chan_type(v__parser__Parser* p) {
	if (p->peek_tok.kind != v__token__Kind_name && p->peek_tok.kind != v__token__Kind_key_mut && p->peek_tok.kind != v__token__Kind_amp && p->peek_tok.kind != v__token__Kind_lsbr) {
		v__parser__Parser_next(p);
		// autofree_scope_vars(pos=3183 line_nr=110 scope.pos=3169 scope.end_pos=3206)
		// af parent scope:
		// var "p" var.pos=3013 var.line_nr=106
		// var "is_mut" var.pos=3251 var.line_nr=114
		// var "elem_type" var.pos=3285 var.line_nr=115
		// var "idx" var.pos=3314 var.line_nr=116
		// af parent scope:
		// af parent scope:
		return _const_v__ast__chan_type;
	}
	v__parser__Parser_register_auto_import(p, _SLIT("sync"));
	v__parser__Parser_next(p);
	bool is_mut = p->tok.kind == v__token__Kind_key_mut;
	v__ast__Type elem_type = v__parser__Parser_parse_type(p);
	int idx = v__ast__Table_find_or_register_chan(p->table, elem_type, is_mut);
	 v__ast__Type _t2436 = v__ast__new_type(idx);
	// autofree_scope_vars(pos=3370 line_nr=117 scope.pos=3008 scope.end_pos=3396)
	// var "p" var.pos=3013 var.line_nr=106
	// var "is_mut" var.pos=3251 var.line_nr=114
	// var "elem_type" var.pos=3285 var.line_nr=115
	// var "idx" var.pos=3314 var.line_nr=116
	// af parent scope:
	// af parent scope:
	return _t2436;
}

v__ast__Type v__parser__Parser_parse_thread_type(v__parser__Parser* p) {
	bool is_opt = p->peek_tok.kind == v__token__Kind_question;
	if (is_opt) {
		v__parser__Parser_next(p);
	}
	if (p->peek_tok.kind != v__token__Kind_name && p->peek_tok.kind != v__token__Kind_key_mut && p->peek_tok.kind != v__token__Kind_amp && p->peek_tok.kind != v__token__Kind_lsbr) {
		v__parser__Parser_next(p);
		if (is_opt) {
			v__ast__Type ret_type = _const_v__ast__void_type;
			ret_type = v__ast__Type_set_flag(ret_type, v__ast__TypeFlag_optional);
			int idx = v__ast__Table_find_or_register_thread(p->table, ret_type);
			 v__ast__Type _t2437 = v__ast__new_type(idx);
			// autofree_scope_vars(pos=3793 line_nr=132 scope.pos=3661 scope.end_pos=3821)
			// var "ret_type" var.pos=3670 var.line_nr=129
			// var "idx" var.pos=3742 var.line_nr=131
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=3411 var.line_nr=120
			// var "is_opt" var.pos=3453 var.line_nr=121
			// var "ret_type" var.pos=3892 var.line_nr=140
			// var "idx" var.pos=3920 var.line_nr=141
			// af parent scope:
			// af parent scope:
			return _t2437;
		} else {
			// autofree_scope_vars(pos=3832 line_nr=134 scope.pos=3828 scope.end_pos=3858)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=3411 var.line_nr=120
			// var "is_opt" var.pos=3453 var.line_nr=121
			// var "ret_type" var.pos=3892 var.line_nr=140
			// var "idx" var.pos=3920 var.line_nr=141
			// af parent scope:
			// af parent scope:
			return _const_v__ast__thread_type;
		}
	}
	if (!is_opt) {
		v__parser__Parser_next(p);
	}
	v__ast__Type ret_type = v__parser__Parser_parse_type(p);
	int idx = v__ast__Table_find_or_register_thread(p->table, ret_type);
	 v__ast__Type _t2438 = v__ast__new_type(idx);
	// autofree_scope_vars(pos=3969 line_nr=142 scope.pos=3406 scope.end_pos=3995)
	// var "p" var.pos=3411 var.line_nr=120
	// var "is_opt" var.pos=3453 var.line_nr=121
	// var "ret_type" var.pos=3892 var.line_nr=140
	// var "idx" var.pos=3920 var.line_nr=141
	// af parent scope:
	// af parent scope:
	return _t2438;
}

v__ast__Type v__parser__Parser_parse_multi_return_type(v__parser__Parser* p) {
	v__parser__Parser_check(p, v__token__Kind_lpar);
	Array_v__ast__Type mr_types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
	for (;;) {
		if (!(p->tok.kind != v__token__Kind_eof)) break;
		v__ast__Type mr_type = v__parser__Parser_parse_type(p);
		if (v__ast__Type_idx(mr_type) == 0) {
			break;
		}
		array_push(&mr_types, _MOV((v__ast__Type[]){ mr_type }));
		if (p->tok.kind == v__token__Kind_comma) {
			v__parser__Parser_next(p);
		} else {
			break;
		}
	}
	v__parser__Parser_check(p, v__token__Kind_rpar);
	if (mr_types.len == 1) {
		 v__ast__Type _t2440 = (*(v__ast__Type*)/*ee elem_typ */array_get(mr_types, 0));
		// autofree_scope_vars(pos=4359 line_nr=163 scope.pos=4323 scope.end_pos=4380)
		// af parent scope:
		// var "p" var.pos=4010 var.line_nr=145
		// var "mr_types" var.pos=4078 var.line_nr=147
		// var "idx" var.pos=4383 var.line_nr=165
		// af parent scope:
		// af parent scope:
		return _t2440;
	}
	int idx = v__ast__Table_find_or_register_multi_return(p->table, mr_types);
	 v__ast__Type _t2441 = v__ast__new_type(idx);
	// autofree_scope_vars(pos=4438 line_nr=166 scope.pos=4005 scope.end_pos=4464)
	// var "p" var.pos=4010 var.line_nr=145
	// var "mr_types" var.pos=4078 var.line_nr=147
	// var "idx" var.pos=4383 var.line_nr=165
	// af parent scope:
	// af parent scope:
	return _t2441;
}

v__ast__Type v__parser__Parser_parse_fn_type(v__parser__Parser* p, string name) {
	v__parser__Parser_check(p, v__token__Kind_key_fn);
	int line_nr = p->tok.line_nr;
	multi_return_Array_v__ast__Param_bool_bool mr_4676 = v__parser__Parser_fn_args(p);
	Array_v__ast__Param args = mr_4676.arg0;
	bool is_variadic = mr_4676.arg2;
	v__ast__Type return_type = _const_v__ast__void_type;
	if (p->tok.line_nr == line_nr && v__token__Kind_is_start_of_type(p->tok.kind)) {
		return_type = v__parser__Parser_parse_type(p);
	}
	v__ast__Fn func = (v__ast__Fn){.params = args,.return_type = return_type,.is_variadic = is_variadic,.language = 0,.generic_names = __new_array(0, 1, sizeof(string)),.is_pub = 0,.is_deprecated = 0,.is_unsafe = 0,.is_placeholder = 0,.is_main = 0,.is_test = 0,.is_conditional = 0,.is_keep_alive = 0,.no_body = 0,.mod = (string){.str=(byteptr)"", .is_lit=1},.ctdefine = (string){.str=(byteptr)"", .is_lit=1},.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.name = name,.source_fn = 0,.usages = 0,};
	bool has_decl = p->builtin_mod && string_starts_with(name, _SLIT("Map")) && string_ends_with(name, _SLIT("Fn"));
	int idx = v__ast__Table_find_or_register_fn_type(p->table, p->mod, func, false, has_decl);
	 v__ast__Type _t2442 = v__ast__new_type(idx);
	// autofree_scope_vars(pos=5198 line_nr=189 scope.pos=4534 scope.end_pos=5224)
	// var "p" var.pos=4539 var.line_nr=170
	// var "name" var.pos=4563 var.line_nr=170
	// var "line_nr" var.pos=4629 var.line_nr=173
	// var "args" var.pos=4655 var.line_nr=174
	// var "is_variadic" var.pos=4664 var.line_nr=174
	// var "return_type" var.pos=4696 var.line_nr=175
	// var "func" var.pos=4824 var.line_nr=179
	// var "has_decl" var.pos=5050 var.line_nr=187
	// var "idx" var.pos=5128 var.line_nr=188
	// af parent scope:
	// af parent scope:
	return _t2442;
}

v__ast__Type v__parser__Parser_parse_type_with_mut(v__parser__Parser* p, bool is_mut) {
	v__ast__Type typ = v__parser__Parser_parse_type(p);
	if (is_mut) {
		 v__ast__Type _t2443 = v__ast__Type_set_nr_muls(typ, 1);
		// autofree_scope_vars(pos=5330 line_nr=195 scope.pos=5327 scope.end_pos=5358)
		// af parent scope:
		// var "p" var.pos=5239 var.line_nr=192
		// var "is_mut" var.pos=5269 var.line_nr=192
		// var "typ" var.pos=5294 var.line_nr=193
		// af parent scope:
		// af parent scope:
		return _t2443;
	}
	// autofree_scope_vars(pos=5360 line_nr=197 scope.pos=5234 scope.end_pos=5372)
	// var "p" var.pos=5239 var.line_nr=192
	// var "is_mut" var.pos=5269 var.line_nr=192
	// var "typ" var.pos=5294 var.line_nr=193
	// af parent scope:
	// af parent scope:
	return typ;
}

v__ast__Language v__parser__Parser_parse_language(v__parser__Parser* p) {
	v__ast__Language language = (string_eq(p->tok.lit, _SLIT("C")) ? (v__ast__Language_c) : string_eq(p->tok.lit, _SLIT("JS")) ? (v__ast__Language_js) : (v__ast__Language_v));
	if (language != v__ast__Language_v) {
		v__parser__Parser_next(p);
		v__parser__Parser_check(p, v__token__Kind_dot);
	}
	// autofree_scope_vars(pos=5656 line_nr=213 scope.pos=5427 scope.end_pos=5673)
	// var "p" var.pos=5432 var.line_nr=201
	// var "language" var.pos=5475 var.line_nr=202
	// af parent scope:
	// af parent scope:
	return language;
}

v__ast__Type v__parser__Parser_parse_type(v__parser__Parser* p) {
	bool is_optional = false;
	if (p->tok.kind == v__token__Kind_question) {
		int line_nr = p->tok.line_nr;
		v__parser__Parser_next(p);
		is_optional = true;
		if (p->tok.line_nr > line_nr) {
			v__ast__Type typ = _const_v__ast__void_type;
			if (is_optional) {
				typ = v__ast__Type_set_flag(typ, v__ast__TypeFlag_optional);
			}
			// autofree_scope_vars(pos=5970 line_nr=228 scope.pos=5879 scope.end_pos=5984)
			// var "typ" var.pos=5888 var.line_nr=224
			// af parent scope:
			// var "line_nr" var.pos=5793 var.line_nr=220
			// af parent scope:
			// var "p" var.pos=5688 var.line_nr=216
			// var "is_optional" var.pos=5740 var.line_nr=218
			// var "is_shared" var.pos=5990 var.line_nr=231
			// var "is_atomic" var.pos=6030 var.line_nr=232
			// var "nr_muls" var.pos=6126 var.line_nr=236
			// var "nr_amps" var.pos=6334 var.line_nr=245
			// var "language" var.pos=6422 var.line_nr=252
			// var "typ" var.pos=6458 var.line_nr=253
			// var "is_array" var.pos=6480 var.line_nr=254
			// af parent scope:
			// af parent scope:
			return typ;
		}
	}
	bool is_shared = p->tok.kind == v__token__Kind_key_shared;
	bool is_atomic = p->tok.kind == v__token__Kind_key_atomic;
	if (is_shared) {
		v__parser__Parser_register_auto_import(p, _SLIT("sync"));
	}
	int nr_muls = 0;
	if (p->tok.kind == v__token__Kind_key_mut || is_shared || is_atomic) {
		nr_muls++;
		v__parser__Parser_next(p);
	}
	if (p->tok.kind == v__token__Kind_mul) {
		v__parser__Parser_error(p, _SLIT("use `&Type` instead of `*Type` when declaring references"));
		 v__ast__Type _t2444 = 0;
		// autofree_scope_vars(pos=6316 line_nr=243 scope.pos=6243 scope.end_pos=6327)
		// af parent scope:
		// var "p" var.pos=5688 var.line_nr=216
		// var "is_optional" var.pos=5740 var.line_nr=218
		// var "is_shared" var.pos=5990 var.line_nr=231
		// var "is_atomic" var.pos=6030 var.line_nr=232
		// var "nr_muls" var.pos=6126 var.line_nr=236
		// var "nr_amps" var.pos=6334 var.line_nr=245
		// var "language" var.pos=6422 var.line_nr=252
		// var "typ" var.pos=6458 var.line_nr=253
		// var "is_array" var.pos=6480 var.line_nr=254
		// af parent scope:
		// af parent scope:
		return _t2444;
	}
	int nr_amps = 0;
	for (;;) {
		if (!(p->tok.kind == v__token__Kind_amp)) break;
		nr_amps++;
		nr_muls++;
		v__parser__Parser_next(p);
	}
	v__ast__Language language = v__parser__Parser_parse_language(p);
	v__ast__Type typ = _const_v__ast__void_type;
	bool is_array = p->tok.kind == v__token__Kind_lsbr;
	if (p->tok.kind != v__token__Kind_lcbr) {
		v__token__Position pos = v__token__Token_position(&p->tok);
		typ = v__parser__Parser_parse_any_type(p, language, nr_muls > 0, true);
		if (v__ast__Type_idx(typ) == 0) {
			 v__ast__Type _t2445 = 0;
			// autofree_scope_vars(pos=6675 line_nr=260 scope.pos=6638 scope.end_pos=6687)
			// af parent scope:
			// var "pos" var.pos=6540 var.line_nr=256
			// af parent scope:
			// var "p" var.pos=5688 var.line_nr=216
			// var "is_optional" var.pos=5740 var.line_nr=218
			// var "is_shared" var.pos=5990 var.line_nr=231
			// var "is_atomic" var.pos=6030 var.line_nr=232
			// var "nr_muls" var.pos=6126 var.line_nr=236
			// var "nr_amps" var.pos=6334 var.line_nr=245
			// var "language" var.pos=6422 var.line_nr=252
			// var "typ" var.pos=6458 var.line_nr=253
			// var "is_array" var.pos=6480 var.line_nr=254
			// af parent scope:
			// af parent scope:
			return _t2445;
		}
		if (v__ast__Type_alias_eq(typ, _const_v__ast__void_type)) {
			v__parser__Parser_error_with_pos(p, _SLIT("use `?` instead of `?void`"), pos);
			 v__ast__Type _t2446 = 0;
			// autofree_scope_vars(pos=6774 line_nr=264 scope.pos=6715 scope.end_pos=6786)
			// af parent scope:
			// var "pos" var.pos=6540 var.line_nr=256
			// af parent scope:
			// var "p" var.pos=5688 var.line_nr=216
			// var "is_optional" var.pos=5740 var.line_nr=218
			// var "is_shared" var.pos=5990 var.line_nr=231
			// var "is_atomic" var.pos=6030 var.line_nr=232
			// var "nr_muls" var.pos=6126 var.line_nr=236
			// var "nr_amps" var.pos=6334 var.line_nr=245
			// var "language" var.pos=6422 var.line_nr=252
			// var "typ" var.pos=6458 var.line_nr=253
			// var "is_array" var.pos=6480 var.line_nr=254
			// af parent scope:
			// af parent scope:
			return _t2446;
		}
	}
	if (is_optional) {
		typ = v__ast__Type_set_flag(typ, v__ast__TypeFlag_optional);
	}
	if (is_shared) {
		typ = v__ast__Type_set_flag(typ, v__ast__TypeFlag_shared_f);
	}
	if (is_atomic) {
		typ = v__ast__Type_set_flag(typ, v__ast__TypeFlag_atomic_f);
	}
	if (nr_muls > 0) {
		typ = v__ast__Type_set_nr_muls(typ, nr_muls);
		if (is_array && nr_amps > 0) {
			v__parser__Parser_error(p, _SLIT("V arrays are already references behind the scenes,\nthere is no need to use a reference to an array (e.g. use `[]string` instead of `&[]string`).\nIf you need to modify an array in a function, use a mutable argument instead: `fn foo(mut s []string) {}`."));
			 v__ast__Type _t2447 = 0;
			// autofree_scope_vars(pos=7296 line_nr=282 scope.pos=7026 scope.end_pos=7308)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=5688 var.line_nr=216
			// var "is_optional" var.pos=5740 var.line_nr=218
			// var "is_shared" var.pos=5990 var.line_nr=231
			// var "is_atomic" var.pos=6030 var.line_nr=232
			// var "nr_muls" var.pos=6126 var.line_nr=236
			// var "nr_amps" var.pos=6334 var.line_nr=245
			// var "language" var.pos=6422 var.line_nr=252
			// var "typ" var.pos=6458 var.line_nr=253
			// var "is_array" var.pos=6480 var.line_nr=254
			// af parent scope:
			// af parent scope:
			return _t2447;
		}
	}
	// autofree_scope_vars(pos=7313 line_nr=285 scope.pos=5683 scope.end_pos=7325)
	// var "p" var.pos=5688 var.line_nr=216
	// var "is_optional" var.pos=5740 var.line_nr=218
	// var "is_shared" var.pos=5990 var.line_nr=231
	// var "is_atomic" var.pos=6030 var.line_nr=232
	// var "nr_muls" var.pos=6126 var.line_nr=236
	// var "nr_amps" var.pos=6334 var.line_nr=245
	// var "language" var.pos=6422 var.line_nr=252
	// var "typ" var.pos=6458 var.line_nr=253
	// var "is_array" var.pos=6480 var.line_nr=254
	// af parent scope:
	// af parent scope:
	return typ;
}

v__ast__Type v__parser__Parser_parse_any_type(v__parser__Parser* p, v__ast__Language language, bool is_ptr, bool check_dot) {
bool v__parser__Parser_parse_any_type_defer_0 = false;
	string name = p->tok.lit;
	if (language == v__ast__Language_c) {
		name = _STR("C.%.*s", 1, name);
	} else if (language == v__ast__Language_js) {
		name = _STR("JS.%.*s", 1, name);
	} else if (p->peek_tok.kind == v__token__Kind_dot && check_dot) {
		if (!v__parser__Parser_known_import(p, name)) {
			v__parser__Parser_error(p, _STR("unknown module `%.*s\000`", 2, p->tok.lit));
			 v__ast__Type _t2448 = 0;
			// autofree_scope_vars(pos=7725 line_nr=299 scope.pos=7679 scope.end_pos=7737)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=7340 var.line_nr=288
			// var "language" var.pos=7365 var.line_nr=288
			// var "is_ptr" var.pos=7388 var.line_nr=288
			// var "check_dot" var.pos=7401 var.line_nr=288
			// var "name" var.pos=7433 var.line_nr=289
			// af parent scope:
			// af parent scope:
			return _t2448;
		}
		if (_IN_MAP(ADDR(string, p->tok.lit), ADDR(map, p->imports))) {
			v__parser__Parser_register_used_import(p, p->tok.lit);
		}
		v__parser__Parser_next(p);
		v__parser__Parser_check(p, v__token__Kind_dot);
		name = _STR("%.*s\000.%.*s", 2, (*(string*)map_get(ADDR(map, p->imports), &(string[]){name}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })), p->tok.lit);
		if (p->tok.lit.len > 0 && !byte_is_capital(string_at(p->tok.lit, 0))) {
			v__parser__Parser_error(p, _SLIT("imported types must start with a capital letter"));
			 v__ast__Type _t2449 = 0;
			// autofree_scope_vars(pos=8026 line_nr=310 scope.pos=7960 scope.end_pos=8038)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=7340 var.line_nr=288
			// var "language" var.pos=7365 var.line_nr=288
			// var "is_ptr" var.pos=7388 var.line_nr=288
			// var "check_dot" var.pos=7401 var.line_nr=288
			// var "name" var.pos=7433 var.line_nr=289
			// af parent scope:
			// af parent scope:
			return _t2449;
		}
	} else if ((p->expr_mod).len != 0 && !p->in_generic_params) {
		name = string_add(string_add(p->expr_mod, _SLIT(".")), name);
	} else if (_IN_MAP(ADDR(string, name), ADDR(map, p->imported_symbols))) {
		name = (*(string*)map_get(ADDR(map, p->imported_symbols), &(string[]){name}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} }));
	} else if (!p->builtin_mod && name.len > 1 && !_IN_MAP(ADDR(string, name), ADDR(map, p->table->type_idxs))) {
		name = string_add(string_add(p->mod, _SLIT(".")), name);
	}

	if (p->tok.kind == (v__token__Kind_key_fn)) {
		 v__ast__Type _t2450 = v__parser__Parser_parse_fn_type(p, _SLIT(""));
		// autofree_scope_vars(pos=8491 line_nr=324 scope.pos=8468 scope.end_pos=8521)
		// af parent scope:
		// var "p" var.pos=7340 var.line_nr=288
		// var "language" var.pos=7365 var.line_nr=288
		// var "is_ptr" var.pos=7388 var.line_nr=288
		// var "check_dot" var.pos=7401 var.line_nr=288
		// var "name" var.pos=7433 var.line_nr=289
		// af parent scope:
		// af parent scope:
		return _t2450;
	}
	else if (p->tok.kind == (v__token__Kind_lsbr)) {
		 v__ast__Type _t2451 = v__parser__Parser_parse_array_type(p);
		// autofree_scope_vars(pos=8547 line_nr=328 scope.pos=8525 scope.end_pos=8578)
		// af parent scope:
		// var "p" var.pos=7340 var.line_nr=288
		// var "language" var.pos=7365 var.line_nr=288
		// var "is_ptr" var.pos=7388 var.line_nr=288
		// var "check_dot" var.pos=7401 var.line_nr=288
		// var "name" var.pos=7433 var.line_nr=289
		// af parent scope:
		// af parent scope:
		return _t2451;
	}
	else if (p->tok.kind == (v__token__Kind_lpar)) {
		if (is_ptr) {
			v__parser__Parser_error(p, _SLIT("parse_type: unexpected `&` before multiple returns"));
			 v__ast__Type _t2452 = 0;
			// autofree_scope_vars(pos=8696 line_nr=334 scope.pos=8625 scope.end_pos=8709)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=7340 var.line_nr=288
			// var "language" var.pos=7365 var.line_nr=288
			// var "is_ptr" var.pos=7388 var.line_nr=288
			// var "check_dot" var.pos=7401 var.line_nr=288
			// var "name" var.pos=7433 var.line_nr=289
			// af parent scope:
			// af parent scope:
			return _t2452;
		}
		 v__ast__Type _t2453 = v__parser__Parser_parse_multi_return_type(p);
		// autofree_scope_vars(pos=8713 line_nr=336 scope.pos=8582 scope.end_pos=8751)
		// af parent scope:
		// var "p" var.pos=7340 var.line_nr=288
		// var "language" var.pos=7365 var.line_nr=288
		// var "is_ptr" var.pos=7388 var.line_nr=288
		// var "check_dot" var.pos=7401 var.line_nr=288
		// var "name" var.pos=7433 var.line_nr=289
		// af parent scope:
		// af parent scope:
		return _t2453;
	}
	else {
		if (string_eq(name, _SLIT("map"))) {
			 v__ast__Type _t2454 = v__parser__Parser_parse_map_type(p);
			// autofree_scope_vars(pos=8802 line_nr=341 scope.pos=8797 scope.end_pos=8832)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=7340 var.line_nr=288
			// var "language" var.pos=7365 var.line_nr=288
			// var "is_ptr" var.pos=7388 var.line_nr=288
			// var "check_dot" var.pos=7401 var.line_nr=288
			// var "name" var.pos=7433 var.line_nr=289
			// af parent scope:
			// af parent scope:
			return _t2454;
		}
		if (string_eq(name, _SLIT("chan"))) {
			 v__ast__Type _t2455 = v__parser__Parser_parse_chan_type(p);
			// autofree_scope_vars(pos=8860 line_nr=344 scope.pos=8855 scope.end_pos=8891)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=7340 var.line_nr=288
			// var "language" var.pos=7365 var.line_nr=288
			// var "is_ptr" var.pos=7388 var.line_nr=288
			// var "check_dot" var.pos=7401 var.line_nr=288
			// var "name" var.pos=7433 var.line_nr=289
			// af parent scope:
			// af parent scope:
			return _t2455;
		}
		if (string_eq(name, _SLIT("thread"))) {
			 v__ast__Type _t2456 = v__parser__Parser_parse_thread_type(p);
			// autofree_scope_vars(pos=8921 line_nr=347 scope.pos=8916 scope.end_pos=8954)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=7340 var.line_nr=288
			// var "language" var.pos=7365 var.line_nr=288
			// var "is_ptr" var.pos=7388 var.line_nr=288
			// var "check_dot" var.pos=7401 var.line_nr=288
			// var "name" var.pos=7433 var.line_nr=289
			// af parent scope:
			// af parent scope:
			return _t2456;
		}
		v__parser__Parser_parse_any_type_defer_0 = true;
		if ((name).len == 0) {
			v__parser__Parser_error(p, _SLIT("expecting type declaration"));
			// Defer begin
			if (v__parser__Parser_parse_any_type_defer_0 == true) {
				v__parser__Parser_next(p);
			}
			// Defer end
			 v__ast__Type _t2457 = 0;
			// autofree_scope_vars(pos=9141 line_nr=355 scope.pos=9002 scope.end_pos=9154)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=7340 var.line_nr=288
			// var "language" var.pos=7365 var.line_nr=288
			// var "is_ptr" var.pos=7388 var.line_nr=288
			// var "check_dot" var.pos=7401 var.line_nr=288
			// var "name" var.pos=7433 var.line_nr=289
			// af parent scope:
			// af parent scope:
			return _t2457;
		}

		if (string_eq(name, _SLIT("voidptr"))) {
			// Defer begin
			if (v__parser__Parser_parse_any_type_defer_0 == true) {
				v__parser__Parser_next(p);
			}
			// Defer end
			// autofree_scope_vars(pos=9192 line_nr=359 scope.pos=9176 scope.end_pos=9221)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=7340 var.line_nr=288
			// var "language" var.pos=7365 var.line_nr=288
			// var "is_ptr" var.pos=7388 var.line_nr=288
			// var "check_dot" var.pos=7401 var.line_nr=288
			// var "name" var.pos=7433 var.line_nr=289
			// af parent scope:
			// af parent scope:
			return _const_v__ast__voidptr_type;
		}
		else if (string_eq(name, _SLIT("byteptr"))) {
			// Defer begin
			if (v__parser__Parser_parse_any_type_defer_0 == true) {
				v__parser__Parser_next(p);
			}
			// Defer end
			// autofree_scope_vars(pos=9243 line_nr=362 scope.pos=9227 scope.end_pos=9272)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=7340 var.line_nr=288
			// var "language" var.pos=7365 var.line_nr=288
			// var "is_ptr" var.pos=7388 var.line_nr=288
			// var "check_dot" var.pos=7401 var.line_nr=288
			// var "name" var.pos=7433 var.line_nr=289
			// af parent scope:
			// af parent scope:
			return _const_v__ast__byteptr_type;
		}
		else if (string_eq(name, _SLIT("charptr"))) {
			// Defer begin
			if (v__parser__Parser_parse_any_type_defer_0 == true) {
				v__parser__Parser_next(p);
			}
			// Defer end
			// autofree_scope_vars(pos=9294 line_nr=365 scope.pos=9278 scope.end_pos=9323)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=7340 var.line_nr=288
			// var "language" var.pos=7365 var.line_nr=288
			// var "is_ptr" var.pos=7388 var.line_nr=288
			// var "check_dot" var.pos=7401 var.line_nr=288
			// var "name" var.pos=7433 var.line_nr=289
			// af parent scope:
			// af parent scope:
			return _const_v__ast__charptr_type;
		}
		else if (string_eq(name, _SLIT("i8"))) {
			// Defer begin
			if (v__parser__Parser_parse_any_type_defer_0 == true) {
				v__parser__Parser_next(p);
			}
			// Defer end
			// autofree_scope_vars(pos=9340 line_nr=368 scope.pos=9329 scope.end_pos=9364)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=7340 var.line_nr=288
			// var "language" var.pos=7365 var.line_nr=288
			// var "is_ptr" var.pos=7388 var.line_nr=288
			// var "check_dot" var.pos=7401 var.line_nr=288
			// var "name" var.pos=7433 var.line_nr=289
			// af parent scope:
			// af parent scope:
			return _const_v__ast__i8_type;
		}
		else if (string_eq(name, _SLIT("i16"))) {
			// Defer begin
			if (v__parser__Parser_parse_any_type_defer_0 == true) {
				v__parser__Parser_next(p);
			}
			// Defer end
			// autofree_scope_vars(pos=9382 line_nr=371 scope.pos=9370 scope.end_pos=9407)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=7340 var.line_nr=288
			// var "language" var.pos=7365 var.line_nr=288
			// var "is_ptr" var.pos=7388 var.line_nr=288
			// var "check_dot" var.pos=7401 var.line_nr=288
			// var "name" var.pos=7433 var.line_nr=289
			// af parent scope:
			// af parent scope:
			return _const_v__ast__i16_type;
		}
		else if (string_eq(name, _SLIT("int"))) {
			// Defer begin
			if (v__parser__Parser_parse_any_type_defer_0 == true) {
				v__parser__Parser_next(p);
			}
			// Defer end
			// autofree_scope_vars(pos=9425 line_nr=374 scope.pos=9413 scope.end_pos=9450)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=7340 var.line_nr=288
			// var "language" var.pos=7365 var.line_nr=288
			// var "is_ptr" var.pos=7388 var.line_nr=288
			// var "check_dot" var.pos=7401 var.line_nr=288
			// var "name" var.pos=7433 var.line_nr=289
			// af parent scope:
			// af parent scope:
			return _const_v__ast__int_type;
		}
		else if (string_eq(name, _SLIT("i64"))) {
			// Defer begin
			if (v__parser__Parser_parse_any_type_defer_0 == true) {
				v__parser__Parser_next(p);
			}
			// Defer end
			// autofree_scope_vars(pos=9468 line_nr=377 scope.pos=9456 scope.end_pos=9493)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=7340 var.line_nr=288
			// var "language" var.pos=7365 var.line_nr=288
			// var "is_ptr" var.pos=7388 var.line_nr=288
			// var "check_dot" var.pos=7401 var.line_nr=288
			// var "name" var.pos=7433 var.line_nr=289
			// af parent scope:
			// af parent scope:
			return _const_v__ast__i64_type;
		}
		else if (string_eq(name, _SLIT("byte"))) {
			// Defer begin
			if (v__parser__Parser_parse_any_type_defer_0 == true) {
				v__parser__Parser_next(p);
			}
			// Defer end
			// autofree_scope_vars(pos=9512 line_nr=380 scope.pos=9499 scope.end_pos=9538)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=7340 var.line_nr=288
			// var "language" var.pos=7365 var.line_nr=288
			// var "is_ptr" var.pos=7388 var.line_nr=288
			// var "check_dot" var.pos=7401 var.line_nr=288
			// var "name" var.pos=7433 var.line_nr=289
			// af parent scope:
			// af parent scope:
			return _const_v__ast__byte_type;
		}
		else if (string_eq(name, _SLIT("u16"))) {
			// Defer begin
			if (v__parser__Parser_parse_any_type_defer_0 == true) {
				v__parser__Parser_next(p);
			}
			// Defer end
			// autofree_scope_vars(pos=9556 line_nr=383 scope.pos=9544 scope.end_pos=9581)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=7340 var.line_nr=288
			// var "language" var.pos=7365 var.line_nr=288
			// var "is_ptr" var.pos=7388 var.line_nr=288
			// var "check_dot" var.pos=7401 var.line_nr=288
			// var "name" var.pos=7433 var.line_nr=289
			// af parent scope:
			// af parent scope:
			return _const_v__ast__u16_type;
		}
		else if (string_eq(name, _SLIT("u32"))) {
			// Defer begin
			if (v__parser__Parser_parse_any_type_defer_0 == true) {
				v__parser__Parser_next(p);
			}
			// Defer end
			// autofree_scope_vars(pos=9599 line_nr=386 scope.pos=9587 scope.end_pos=9624)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=7340 var.line_nr=288
			// var "language" var.pos=7365 var.line_nr=288
			// var "is_ptr" var.pos=7388 var.line_nr=288
			// var "check_dot" var.pos=7401 var.line_nr=288
			// var "name" var.pos=7433 var.line_nr=289
			// af parent scope:
			// af parent scope:
			return _const_v__ast__u32_type;
		}
		else if (string_eq(name, _SLIT("u64"))) {
			// Defer begin
			if (v__parser__Parser_parse_any_type_defer_0 == true) {
				v__parser__Parser_next(p);
			}
			// Defer end
			// autofree_scope_vars(pos=9642 line_nr=389 scope.pos=9630 scope.end_pos=9667)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=7340 var.line_nr=288
			// var "language" var.pos=7365 var.line_nr=288
			// var "is_ptr" var.pos=7388 var.line_nr=288
			// var "check_dot" var.pos=7401 var.line_nr=288
			// var "name" var.pos=7433 var.line_nr=289
			// af parent scope:
			// af parent scope:
			return _const_v__ast__u64_type;
		}
		else if (string_eq(name, _SLIT("f32"))) {
			// Defer begin
			if (v__parser__Parser_parse_any_type_defer_0 == true) {
				v__parser__Parser_next(p);
			}
			// Defer end
			// autofree_scope_vars(pos=9685 line_nr=392 scope.pos=9673 scope.end_pos=9710)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=7340 var.line_nr=288
			// var "language" var.pos=7365 var.line_nr=288
			// var "is_ptr" var.pos=7388 var.line_nr=288
			// var "check_dot" var.pos=7401 var.line_nr=288
			// var "name" var.pos=7433 var.line_nr=289
			// af parent scope:
			// af parent scope:
			return _const_v__ast__f32_type;
		}
		else if (string_eq(name, _SLIT("f64"))) {
			// Defer begin
			if (v__parser__Parser_parse_any_type_defer_0 == true) {
				v__parser__Parser_next(p);
			}
			// Defer end
			// autofree_scope_vars(pos=9728 line_nr=395 scope.pos=9716 scope.end_pos=9753)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=7340 var.line_nr=288
			// var "language" var.pos=7365 var.line_nr=288
			// var "is_ptr" var.pos=7388 var.line_nr=288
			// var "check_dot" var.pos=7401 var.line_nr=288
			// var "name" var.pos=7433 var.line_nr=289
			// af parent scope:
			// af parent scope:
			return _const_v__ast__f64_type;
		}
		else if (string_eq(name, _SLIT("string"))) {
			// Defer begin
			if (v__parser__Parser_parse_any_type_defer_0 == true) {
				v__parser__Parser_next(p);
			}
			// Defer end
			// autofree_scope_vars(pos=9774 line_nr=398 scope.pos=9759 scope.end_pos=9802)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=7340 var.line_nr=288
			// var "language" var.pos=7365 var.line_nr=288
			// var "is_ptr" var.pos=7388 var.line_nr=288
			// var "check_dot" var.pos=7401 var.line_nr=288
			// var "name" var.pos=7433 var.line_nr=289
			// af parent scope:
			// af parent scope:
			return _const_v__ast__string_type;
		}
		else if (string_eq(name, _SLIT("char"))) {
			// Defer begin
			if (v__parser__Parser_parse_any_type_defer_0 == true) {
				v__parser__Parser_next(p);
			}
			// Defer end
			// autofree_scope_vars(pos=9821 line_nr=401 scope.pos=9808 scope.end_pos=9847)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=7340 var.line_nr=288
			// var "language" var.pos=7365 var.line_nr=288
			// var "is_ptr" var.pos=7388 var.line_nr=288
			// var "check_dot" var.pos=7401 var.line_nr=288
			// var "name" var.pos=7433 var.line_nr=289
			// af parent scope:
			// af parent scope:
			return _const_v__ast__char_type;
		}
		else if (string_eq(name, _SLIT("bool"))) {
			// Defer begin
			if (v__parser__Parser_parse_any_type_defer_0 == true) {
				v__parser__Parser_next(p);
			}
			// Defer end
			// autofree_scope_vars(pos=9866 line_nr=404 scope.pos=9853 scope.end_pos=9892)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=7340 var.line_nr=288
			// var "language" var.pos=7365 var.line_nr=288
			// var "is_ptr" var.pos=7388 var.line_nr=288
			// var "check_dot" var.pos=7401 var.line_nr=288
			// var "name" var.pos=7433 var.line_nr=289
			// af parent scope:
			// af parent scope:
			return _const_v__ast__bool_type;
		}
		else if (string_eq(name, _SLIT("float_literal"))) {
			// Defer begin
			if (v__parser__Parser_parse_any_type_defer_0 == true) {
				v__parser__Parser_next(p);
			}
			// Defer end
			// autofree_scope_vars(pos=9920 line_nr=407 scope.pos=9898 scope.end_pos=9955)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=7340 var.line_nr=288
			// var "language" var.pos=7365 var.line_nr=288
			// var "is_ptr" var.pos=7388 var.line_nr=288
			// var "check_dot" var.pos=7401 var.line_nr=288
			// var "name" var.pos=7433 var.line_nr=289
			// af parent scope:
			// af parent scope:
			return _const_v__ast__float_literal_type;
		}
		else if (string_eq(name, _SLIT("int_literal"))) {
			// Defer begin
			if (v__parser__Parser_parse_any_type_defer_0 == true) {
				v__parser__Parser_next(p);
			}
			// Defer end
			// autofree_scope_vars(pos=9981 line_nr=410 scope.pos=9961 scope.end_pos=10014)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=7340 var.line_nr=288
			// var "language" var.pos=7365 var.line_nr=288
			// var "is_ptr" var.pos=7388 var.line_nr=288
			// var "check_dot" var.pos=7401 var.line_nr=288
			// var "name" var.pos=7433 var.line_nr=289
			// af parent scope:
			// af parent scope:
			return _const_v__ast__int_literal_type;
		}
		else {
			if (name.len == 1 && byte_is_capital(string_at(name, 0))) {
				// Defer begin
				if (v__parser__Parser_parse_any_type_defer_0 == true) {
					v__parser__Parser_next(p);
				}
				// Defer end
				 v__ast__Type _t2458 = v__parser__Parser_parse_generic_template_type(p, name);
				// autofree_scope_vars(pos=10080 line_nr=414 scope.pos=10073 scope.end_pos=10129)
				// af parent scope:
				// af parent scope:
				// af parent scope:
				// var "p" var.pos=7340 var.line_nr=288
				// var "language" var.pos=7365 var.line_nr=288
				// var "is_ptr" var.pos=7388 var.line_nr=288
				// var "check_dot" var.pos=7401 var.line_nr=288
				// var "name" var.pos=7433 var.line_nr=289
				// af parent scope:
				// af parent scope:
				return _t2458;
			}
			if (p->peek_tok.kind == v__token__Kind_lt) {
				// Defer begin
				if (v__parser__Parser_parse_any_type_defer_0 == true) {
					v__parser__Parser_next(p);
				}
				// Defer end
				 v__ast__Type _t2459 = v__parser__Parser_parse_generic_struct_inst_type(p, name);
				// autofree_scope_vars(pos=10169 line_nr=417 scope.pos=10162 scope.end_pos=10221)
				// af parent scope:
				// af parent scope:
				// af parent scope:
				// var "p" var.pos=7340 var.line_nr=288
				// var "language" var.pos=7365 var.line_nr=288
				// var "is_ptr" var.pos=7388 var.line_nr=288
				// var "check_dot" var.pos=7401 var.line_nr=288
				// var "name" var.pos=7433 var.line_nr=289
				// af parent scope:
				// af parent scope:
				return _t2459;
			}
			// Defer begin
			if (v__parser__Parser_parse_any_type_defer_0 == true) {
				v__parser__Parser_next(p);
			}
			// Defer end
			 v__ast__Type _t2460 = v__parser__Parser_parse_enum_or_struct_type(p, name, language);
			// autofree_scope_vars(pos=10227 line_nr=419 scope.pos=10020 scope.end_pos=10283)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=7340 var.line_nr=288
			// var "language" var.pos=7365 var.line_nr=288
			// var "is_ptr" var.pos=7388 var.line_nr=288
			// var "check_dot" var.pos=7401 var.line_nr=288
			// var "name" var.pos=7433 var.line_nr=289
			// af parent scope:
			// af parent scope:
			return _t2460;
		};
	};
	return 0;
}

v__ast__Type v__parser__Parser_parse_enum_or_struct_type(v__parser__Parser* p, string name, v__ast__Language language) {
	int idx = v__ast__Table_find_type_idx(p->table, name);
	if (idx > 0) {
		 v__ast__Type _t2461 = v__ast__new_type(idx);
		// autofree_scope_vars(pos=10500 line_nr=431 scope.pos=10497 scope.end_pos=10527)
		// af parent scope:
		// var "p" var.pos=10312 var.line_nr=426
		// var "name" var.pos=10348 var.line_nr=426
		// var "language" var.pos=10361 var.line_nr=426
		// var "idx" var.pos=10450 var.line_nr=429
		// af parent scope:
		// af parent scope:
		return _t2461;
	}
	idx = v__ast__Table_add_placeholder_type(p->table, name, language);
	 v__ast__Type _t2462 = v__ast__new_type(idx);
	// autofree_scope_vars(pos=10673 line_nr=436 scope.pos=10307 scope.end_pos=10699)
	// var "p" var.pos=10312 var.line_nr=426
	// var "name" var.pos=10348 var.line_nr=426
	// var "language" var.pos=10361 var.line_nr=426
	// var "idx" var.pos=10450 var.line_nr=429
	// af parent scope:
	// af parent scope:
	return _t2462;
}

v__ast__Type v__parser__Parser_parse_generic_template_type(v__parser__Parser* p, string name) {
	int idx = v__ast__Table_find_type_idx(p->table, name);
	if (idx > 0) {
		 v__ast__Type _t2463 = v__ast__Type_set_flag(v__ast__new_type(idx), v__ast__TypeFlag_generic);
		// autofree_scope_vars(pos=10831 line_nr=442 scope.pos=10828 scope.end_pos=10877)
		// af parent scope:
		// var "p" var.pos=10714 var.line_nr=439
		// var "name" var.pos=10752 var.line_nr=439
		// var "idx" var.pos=10781 var.line_nr=440
		// af parent scope:
		// af parent scope:
		return _t2463;
	}
	idx = v__ast__Table_register_type_symbol(p->table, (v__ast__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__ast__Kind_any,.name = name,.cname = v__util__no_dots(name),.methods = __new_array(0, 1, sizeof(v__ast__Fn)),.mod = p->mod,.is_public = true,.language = 0,});
	 v__ast__Type _t2464 = v__ast__Type_set_flag(v__ast__new_type(idx), v__ast__TypeFlag_generic);
	// autofree_scope_vars(pos=11020 line_nr=451 scope.pos=10709 scope.end_pos=11065)
	// var "p" var.pos=10714 var.line_nr=439
	// var "name" var.pos=10752 var.line_nr=439
	// var "idx" var.pos=10781 var.line_nr=440
	// af parent scope:
	// af parent scope:
	return _t2464;
}

v__ast__Type v__parser__Parser_parse_generic_struct_inst_type(v__parser__Parser* p, string name) {
	string bs_name = name;
	string bs_cname = name;
	v__parser__Parser_next(p);
	p->in_generic_params = true;
	bs_name = /*f*/string_add(bs_name, _SLIT("<"));
	bs_cname = /*f*/string_add(bs_cname, _SLIT("_T_"));
	Array_v__ast__Type generic_types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
	bool is_instance = false;
	for (;;) {
		if (!(p->tok.kind != v__token__Kind_eof)) break;
		v__ast__Type gt = v__parser__Parser_parse_type(p);
		if (!v__ast__Type_has_flag(gt, v__ast__TypeFlag_generic)) {
			is_instance = true;
		}
		v__ast__TypeSymbol* gts = v__ast__Table_get_type_symbol(p->table, gt);
		bs_name = /*f*/string_add(bs_name, gts->name);
		bs_cname = /*f*/string_add(bs_cname, gts->cname);
		array_push(&generic_types, _MOV((v__ast__Type[]){ gt }));
		if (p->tok.kind != v__token__Kind_comma) {
			break;
		}
		v__parser__Parser_next(p);
		bs_name = /*f*/string_add(bs_name, _SLIT(","));
		bs_cname = /*f*/string_add(bs_cname, _SLIT("_"));
	}
	v__parser__Parser_check(p, v__token__Kind_gt);
	p->in_generic_params = false;
	bs_name = /*f*/string_add(bs_name, _SLIT(">"));
	if (is_instance && generic_types.len > 0) {
		int gt_idx = v__ast__Table_find_type_idx(p->table, bs_name);
		if (gt_idx > 0) {
			 v__ast__Type _t2466 = v__ast__new_type(gt_idx);
			// autofree_scope_vars(pos=11791 line_nr=485 scope.pos=11787 scope.end_pos=11822)
			// af parent scope:
			// var "gt_idx" var.pos=11730 var.line_nr=483
			// var "parent_idx" var.pos=11883 var.line_nr=488
			// var "idx" var.pos=12005 var.line_nr=492
			// af parent scope:
			// var "p" var.pos=11080 var.line_nr=454
			// var "name" var.pos=11121 var.line_nr=454
			// var "bs_name" var.pos=11150 var.line_nr=455
			// var "bs_cname" var.pos=11171 var.line_nr=456
			// var "generic_types" var.pos=11266 var.line_nr=461
			// var "is_instance" var.pos=11301 var.line_nr=462
			// af parent scope:
			// af parent scope:
			return _t2466;
		}
		gt_idx = v__ast__Table_add_placeholder_type(p->table, bs_name, v__ast__Language_v);
		int parent_idx = (*(int*)map_get(ADDR(map, p->table->type_idxs), &(string[]){name}, &(int[]){ 0 }));
		if (parent_idx == 0) {
			parent_idx = v__ast__Table_add_placeholder_type(p->table, name, v__ast__Language_v);
		}
		int idx = v__ast__Table_register_type_symbol(p->table, (v__ast__TypeSymbol){.parent_idx = 0,.info = v__ast__GenericStructInst_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__GenericStructInst, ((v__ast__GenericStructInst){.parent_idx = parent_idx,.generic_types = generic_types,}))),.kind = v__ast__Kind_generic_struct_inst,.name = bs_name,.cname = v__util__no_dots(bs_cname),.methods = __new_array(0, 1, sizeof(v__ast__Fn)),.mod = p->mod,.is_public = 0,.language = 0,});
		 v__ast__Type _t2467 = v__ast__new_type(idx);
		// autofree_scope_vars(pos=12254 line_nr=502 scope.pos=11722 scope.end_pos=12281)
		// var "gt_idx" var.pos=11730 var.line_nr=483
		// var "parent_idx" var.pos=11883 var.line_nr=488
		// var "idx" var.pos=12005 var.line_nr=492
		// af parent scope:
		// var "p" var.pos=11080 var.line_nr=454
		// var "name" var.pos=11121 var.line_nr=454
		// var "bs_name" var.pos=11150 var.line_nr=455
		// var "bs_cname" var.pos=11171 var.line_nr=456
		// var "generic_types" var.pos=11266 var.line_nr=461
		// var "is_instance" var.pos=11301 var.line_nr=462
		// af parent scope:
		// af parent scope:
		return _t2467;
	} else {
		int idx = v__ast__Table_find_type_idx(p->table, name);
		if (idx != 0) {
			 v__ast__Type _t2468 = v__ast__Type_set_flag(v__ast__new_type(idx), v__ast__TypeFlag_generic);
			// autofree_scope_vars(pos=12345 line_nr=506 scope.pos=12341 scope.end_pos=12392)
			// af parent scope:
			// var "idx" var.pos=12292 var.line_nr=504
			// af parent scope:
			// var "p" var.pos=11080 var.line_nr=454
			// var "name" var.pos=11121 var.line_nr=454
			// var "bs_name" var.pos=11150 var.line_nr=455
			// var "bs_cname" var.pos=11171 var.line_nr=456
			// var "generic_types" var.pos=11266 var.line_nr=461
			// var "is_instance" var.pos=11301 var.line_nr=462
			// af parent scope:
			// af parent scope:
			return _t2468;
		}
	}
	 v__ast__Type _t2469 = v__parser__Parser_parse_enum_or_struct_type(p, name, v__ast__Language_v);
	// autofree_scope_vars(pos=12397 line_nr=509 scope.pos=11075 scope.end_pos=12443)
	// var "p" var.pos=11080 var.line_nr=454
	// var "name" var.pos=11121 var.line_nr=454
	// var "bs_name" var.pos=11150 var.line_nr=455
	// var "bs_cname" var.pos=11171 var.line_nr=456
	// var "generic_types" var.pos=11266 var.line_nr=461
	// var "is_instance" var.pos=11301 var.line_nr=462
	// af parent scope:
	// af parent scope:
	return _t2469;
}

v__ast__Stmt v__parser__parse_stmt(string text, v__ast__Table* table, v__ast__Scope* scope) {
bool v__parser__parse_stmt_defer_0 = false;
	v__parser__Parser p = (v__parser__Parser){.pref = (v__pref__Preferences*)memdup(&(v__pref__Preferences){.os = 0,.backend = 0,.build_mode = 0,.arch = 0,.output_mode = v__pref__OutputMode_stdout,.is_verbose = 0,.is_watch = 0,.is_test = 0,.is_script = 0,.is_vsh = 0,.is_livemain = 0,.is_liveshared = 0,.is_shared = 0,.is_prof = 0,.profile_file = (string){.str=(byteptr)"", .is_lit=1},.profile_no_inline = 0,.translated = 0,.is_prod = 0,.obfuscate = 0,.is_repl = 0,.is_run = 0,.sanitize = 0,.is_debug = 0,.is_vlines = 0,.show_cc = 0,.show_c_output = 0,.dump_c_flags = (string){.str=(byteptr)"", .is_lit=1},.use_cache = 0,.retry_compilation = true,.is_stats = 0,.cflags = (string){.str=(byteptr)"", .is_lit=1},.m64 = 0,.ccompiler = (string){.str=(byteptr)"", .is_lit=1},.ccompiler_type = 0,.third_party_option = (string){.str=(byteptr)"", .is_lit=1},.building_v = 0,.autofree = 0,.compress = 0,.enable_globals = 0,.is_fmt = 0,.is_vet = 0,.is_bare = 0,.no_preludes = 0,.custom_prelude = (string){.str=(byteptr)"", .is_lit=1},.lookup_path = __new_array(0, 1, sizeof(string)),.bare_builtin_dir = (string){.str=(byteptr)"", .is_lit=1},.output_cross_c = 0,.prealloc = 0,.vroot = (string){.str=(byteptr)"", .is_lit=1},.out_name_c = (string){.str=(byteptr)"", .is_lit=1},.out_name = (string){.str=(byteptr)"", .is_lit=1},.path = (string){.str=(byteptr)"", .is_lit=1},.compile_defines = __new_array(0, 1, sizeof(string)),.compile_defines_all = __new_array(0, 1, sizeof(string)),.run_args = __new_array(0, 1, sizeof(string)),.printfn_list = __new_array(0, 1, sizeof(string)),.print_v_files = 0,.skip_running = 0,.skip_warnings = 0,.warn_impure_v = 0,.warns_are_errors = 0,.fatal_errors = 0,.reuse_tmpc = 0,.use_color = 0,.is_parallel = 0,.error_limit = 0,.is_vweb = 0,.only_check_syntax = 0,.experimental = 0,.skip_unused = 0,.show_timings = 0,.is_ios_simulator = 0,.is_apk = 0,.cleanup_files = __new_array(0, 1, sizeof(string)),.build_options = __new_array(0, 1, sizeof(string)),.cache_manager = (v__vcache__CacheManager){.k2cpath = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),},.is_help = 0,.gc_mode = v__pref__GarbageCollectionMode_no_gc,.checker_match_exhaustive_cutoff_limit = 10,}, sizeof(v__pref__Preferences)),.file_base = (string){.str=(byteptr)"", .is_lit=1},.file_name = (string){.str=(byteptr)"", .is_lit=1},.file_name_dir = (string){.str=(byteptr)"", .is_lit=1},.file_backend_mode = 0,.scanner = v__scanner__new_scanner(text, v__scanner__CommentsMode_skip_comments, (v__pref__Preferences*)memdup(&(v__pref__Preferences){.os = 0,.backend = 0,.build_mode = 0,.arch = 0,.output_mode = v__pref__OutputMode_stdout,.is_verbose = 0,.is_watch = 0,.is_test = 0,.is_script = 0,.is_vsh = 0,.is_livemain = 0,.is_liveshared = 0,.is_shared = 0,.is_prof = 0,.profile_file = (string){.str=(byteptr)"", .is_lit=1},.profile_no_inline = 0,.translated = 0,.is_prod = 0,.obfuscate = 0,.is_repl = 0,.is_run = 0,.sanitize = 0,.is_debug = 0,.is_vlines = 0,.show_cc = 0,.show_c_output = 0,.dump_c_flags = (string){.str=(byteptr)"", .is_lit=1},.use_cache = 0,.retry_compilation = true,.is_stats = 0,.cflags = (string){.str=(byteptr)"", .is_lit=1},.m64 = 0,.ccompiler = (string){.str=(byteptr)"", .is_lit=1},.ccompiler_type = 0,.third_party_option = (string){.str=(byteptr)"", .is_lit=1},.building_v = 0,.autofree = 0,.compress = 0,.enable_globals = 0,.is_fmt = 0,.is_vet = 0,.is_bare = 0,.no_preludes = 0,.custom_prelude = (string){.str=(byteptr)"", .is_lit=1},.lookup_path = __new_array(0, 1, sizeof(string)),.bare_builtin_dir = (string){.str=(byteptr)"", .is_lit=1},.output_cross_c = 0,.prealloc = 0,.vroot = (string){.str=(byteptr)"", .is_lit=1},.out_name_c = (string){.str=(byteptr)"", .is_lit=1},.out_name = (string){.str=(byteptr)"", .is_lit=1},.path = (string){.str=(byteptr)"", .is_lit=1},.compile_defines = __new_array(0, 1, sizeof(string)),.compile_defines_all = __new_array(0, 1, sizeof(string)),.run_args = __new_array(0, 1, sizeof(string)),.printfn_list = __new_array(0, 1, sizeof(string)),.print_v_files = 0,.skip_running = 0,.skip_warnings = 0,.warn_impure_v = 0,.warns_are_errors = 0,.fatal_errors = 0,.reuse_tmpc = 0,.use_color = 0,.is_parallel = 0,.error_limit = 0,.is_vweb = 0,.only_check_syntax = 0,.experimental = 0,.skip_unused = 0,.show_timings = 0,.is_ios_simulator = 0,.is_apk = 0,.cleanup_files = __new_array(0, 1, sizeof(string)),.build_options = __new_array(0, 1, sizeof(string)),.cache_manager = (v__vcache__CacheManager){.k2cpath = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),},.is_help = 0,.gc_mode = v__pref__GarbageCollectionMode_no_gc,.checker_match_exhaustive_cutoff_limit = 10,}, sizeof(v__pref__Preferences))),.comments_mode = v__scanner__CommentsMode_skip_comments,.tok = {0},.prev_tok = {0},.peek_tok = {0},.table = table,.language = 0,.inside_if = 0,.inside_if_expr = 0,.inside_ct_if_expr = 0,.inside_or_expr = 0,.inside_for = 0,.inside_fn = 0,.inside_unsafe_fn = 0,.inside_str_interp = 0,.or_is_handled = 0,.builtin_mod = 0,.mod = (string){.str=(byteptr)"", .is_lit=1},.is_manualfree = 0,.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.expr_mod = (string){.str=(byteptr)"", .is_lit=1},.scope = scope,.global_scope = (v__ast__Scope*)memdup(&(v__ast__Scope){.objects = new_map(sizeof(string), sizeof(v__ast__ScopeObject), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.struct_fields = __new_array(0, 1, sizeof(v__ast__ScopeStructField)),.parent = 0,.detached_from_parent = 0,.children = __new_array(0, 1, sizeof(v__ast__Scope*)),.start_pos = 0,.end_pos = 0,}, sizeof(v__ast__Scope)),.imports = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.ast_imports = __new_array(0, 1, sizeof(v__ast__Import)),.used_imports = __new_array(0, 1, sizeof(string)),.auto_imports = __new_array(0, 1, sizeof(string)),.imported_symbols = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.is_amp = 0,.returns = 0,.inside_match = 0,.inside_select = 0,.inside_match_case = 0,.inside_match_body = 0,.inside_unsafe = 0,.is_stmt_ident = 0,.expecting_type = 0,.errors = __new_array(0, 1, sizeof(v__errors__Error)),.warnings = __new_array(0, 1, sizeof(v__errors__Warning)),.notices = __new_array(0, 1, sizeof(v__errors__Notice)),.vet_errors = __new_array(0, 1, sizeof(v__vet__Error)),.cur_fn_name = (string){.str=(byteptr)"", .is_lit=1},.label_names = __new_array(0, 1, sizeof(string)),.in_generic_params = 0,.name_error = 0,.n_asm = 0,.inside_asm_template = 0,.inside_asm = 0,.global_labels = __new_array(0, 1, sizeof(string)),};
	v__parser__Parser_init_parse_fns(&p);
	v__util__timing_start(_SLIT("PARSE stmt"));
	v__parser__parse_stmt_defer_0 = true;
	v__parser__Parser_read_first_token(&p);
	// Defer begin
	if (v__parser__parse_stmt_defer_0 == true) {
		v__util__timing_measure_cumulative(_SLIT("PARSE stmt"));
	}
	// Defer end
	 v__ast__Stmt _t2470 = v__parser__Parser_stmt(&p, false);
	// autofree_scope_vars(pos=3598 line_nr=95 scope.pos=3179 scope.end_pos=3620)
	// var "text" var.pos=3190 var.line_nr=78
	// var "table" var.pos=3203 var.line_nr=78
	// var "scope" var.pos=3221 var.line_nr=78
	// var "p" var.pos=3255 var.line_nr=79
	// af parent scope:
	// af parent scope:
	return _t2470;
}

v__ast__File v__parser__parse_comptime(string text, v__ast__Table* table, v__pref__Preferences* pref, v__ast__Scope* scope, v__ast__Scope* global_scope) {
	v__parser__Parser p = (v__parser__Parser){
		.pref = pref,
		.file_base = (string){.str=(byteptr)"", .is_lit=1},
		.file_name = (string){.str=(byteptr)"", .is_lit=1},
		.file_name_dir = (string){.str=(byteptr)"", .is_lit=1},
		.file_backend_mode = 0,
		.scanner = v__scanner__new_scanner(text, v__scanner__CommentsMode_skip_comments, pref),
		.comments_mode = v__scanner__CommentsMode_skip_comments,
		.tok = {0},
		.prev_tok = {0},
		.peek_tok = {0},
		.table = table,
		.language = 0,
		.inside_if = 0,
		.inside_if_expr = 0,
		.inside_ct_if_expr = 0,
		.inside_or_expr = 0,
		.inside_for = 0,
		.inside_fn = 0,
		.inside_unsafe_fn = 0,
		.inside_str_interp = 0,
		.or_is_handled = 0,
		.builtin_mod = 0,
		.mod = (string){.str=(byteptr)"", .is_lit=1},
		.is_manualfree = 0,
		.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),
		.expr_mod = (string){.str=(byteptr)"", .is_lit=1},
		.scope = scope,
		.global_scope = global_scope,
		.imports = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.ast_imports = __new_array(0, 1, sizeof(v__ast__Import)),
		.used_imports = __new_array(0, 1, sizeof(string)),
		.auto_imports = __new_array(0, 1, sizeof(string)),
		.imported_symbols = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.is_amp = 0,
		.returns = 0,
		.inside_match = 0,
		.inside_select = 0,
		.inside_match_case = 0,
		.inside_match_body = 0,
		.inside_unsafe = 0,
		.is_stmt_ident = 0,
		.expecting_type = 0,
		.errors = __new_array_with_default(0, 0, sizeof(v__errors__Error), 0),
		.warnings = __new_array_with_default(0, 0, sizeof(v__errors__Warning), 0),
		.notices = __new_array(0, 1, sizeof(v__errors__Notice)),
		.vet_errors = __new_array(0, 1, sizeof(v__vet__Error)),
		.cur_fn_name = (string){.str=(byteptr)"", .is_lit=1},
		.label_names = __new_array(0, 1, sizeof(string)),
		.in_generic_params = 0,
		.name_error = 0,
		.n_asm = 0,
		.inside_asm_template = 0,
		.inside_asm = 0,
		.global_labels = __new_array(0, 1, sizeof(string)),
	};
	 v__ast__File _t2471 = v__parser__Parser_parse(&p);
	// autofree_scope_vars(pos=3964 line_nr=108 scope.pos=3630 scope.end_pos=3982)
	// var "text" var.pos=3645 var.line_nr=98
	// var "table" var.pos=3658 var.line_nr=98
	// var "pref" var.pos=3676 var.line_nr=98
	// var "scope" var.pos=3700 var.line_nr=98
	// var "global_scope" var.pos=3718 var.line_nr=98
	// var "p" var.pos=3759 var.line_nr=99
	// af parent scope:
	// af parent scope:
	return _t2471;
}

v__ast__File v__parser__parse_text(string text, string path, v__ast__Table* table, v__scanner__CommentsMode comments_mode, v__pref__Preferences* pref, v__ast__Scope* global_scope) {
	v__parser__Parser p = (v__parser__Parser){
		.pref = pref,
		.file_base = (string){.str=(byteptr)"", .is_lit=1},
		.file_name = (string){.str=(byteptr)"", .is_lit=1},
		.file_name_dir = (string){.str=(byteptr)"", .is_lit=1},
		.file_backend_mode = 0,
		.scanner = v__scanner__new_scanner(text, comments_mode, pref),
		.comments_mode = comments_mode,
		.tok = {0},
		.prev_tok = {0},
		.peek_tok = {0},
		.table = table,
		.language = 0,
		.inside_if = 0,
		.inside_if_expr = 0,
		.inside_ct_if_expr = 0,
		.inside_or_expr = 0,
		.inside_for = 0,
		.inside_fn = 0,
		.inside_unsafe_fn = 0,
		.inside_str_interp = 0,
		.or_is_handled = 0,
		.builtin_mod = 0,
		.mod = (string){.str=(byteptr)"", .is_lit=1},
		.is_manualfree = 0,
		.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),
		.expr_mod = (string){.str=(byteptr)"", .is_lit=1},
		.scope = (v__ast__Scope*)memdup(&(v__ast__Scope){.objects = new_map(sizeof(string), sizeof(v__ast__ScopeObject), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.struct_fields = __new_array(0, 1, sizeof(v__ast__ScopeStructField)),.parent = global_scope,.detached_from_parent = 0,.children = __new_array(0, 1, sizeof(v__ast__Scope*)),.start_pos = 0,.end_pos = 0,}, sizeof(v__ast__Scope)),
		.global_scope = global_scope,
		.imports = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.ast_imports = __new_array(0, 1, sizeof(v__ast__Import)),
		.used_imports = __new_array(0, 1, sizeof(string)),
		.auto_imports = __new_array(0, 1, sizeof(string)),
		.imported_symbols = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.is_amp = 0,
		.returns = 0,
		.inside_match = 0,
		.inside_select = 0,
		.inside_match_case = 0,
		.inside_match_body = 0,
		.inside_unsafe = 0,
		.is_stmt_ident = 0,
		.expecting_type = 0,
		.errors = __new_array_with_default(0, 0, sizeof(v__errors__Error), 0),
		.warnings = __new_array_with_default(0, 0, sizeof(v__errors__Warning), 0),
		.notices = __new_array(0, 1, sizeof(v__errors__Notice)),
		.vet_errors = __new_array(0, 1, sizeof(v__vet__Error)),
		.cur_fn_name = (string){.str=(byteptr)"", .is_lit=1},
		.label_names = __new_array(0, 1, sizeof(string)),
		.in_generic_params = 0,
		.name_error = 0,
		.n_asm = 0,
		.inside_asm_template = 0,
		.inside_asm = 0,
		.global_labels = __new_array(0, 1, sizeof(string)),
	};
	v__parser__Parser_set_path(&p, path);
	 v__ast__File _t2472 = v__parser__Parser_parse(&p);
	// autofree_scope_vars(pos=4451 line_nr=126 scope.pos=3992 scope.end_pos=4469)
	// var "text" var.pos=4003 var.line_nr=111
	// var "path" var.pos=4016 var.line_nr=111
	// var "table" var.pos=4029 var.line_nr=111
	// var "comments_mode" var.pos=4047 var.line_nr=111
	// var "pref" var.pos=4083 var.line_nr=111
	// var "global_scope" var.pos=4107 var.line_nr=111
	// var "p" var.pos=4148 var.line_nr=112
	// af parent scope:
	// af parent scope:
	return _t2472;
}

// Attr: [unsafe]
void v__parser__Parser_free(v__parser__Parser* p) {
	v__scanner__Scanner_free(p->scanner);
}

void v__parser__Parser_set_path(v__parser__Parser* p, string path) {
	p->file_name = path;
	p->file_base = os__base(path);
	p->file_name_dir = os__dir(path);
	string before_dot_v = string_before(path, _SLIT(".v"));
	string language = string_all_after_last(before_dot_v, _SLIT("."));
	string langauge_with_underscore = string_all_after_last(before_dot_v, _SLIT("_"));
	if (string_eq(language, before_dot_v) && string_eq(langauge_with_underscore, before_dot_v)) {
		p->file_backend_mode = v__ast__Language_v;
		return;
	}
	string actual_language = (string_eq(language, before_dot_v) ? (langauge_with_underscore) : (language));

	if (string_eq(actual_language, _SLIT("c"))) {
		p->file_backend_mode = v__ast__Language_c;
	}
	else if (string_eq(actual_language, _SLIT("js"))) {
		p->file_backend_mode = v__ast__Language_js;
	}
	else {
		Option_v__pref__Arch _t2473 = v__pref__arch_from_string(actual_language);
		if (_t2473.state != 0) { /*or block*/ 
			IError err = _t2473.err;
			*(v__pref__Arch*) _t2473.data = v__pref__Arch__auto;
		}
 		v__pref__Arch arch =  *(v__pref__Arch*)_t2473.data;
		p->file_backend_mode = v__ast__pref_arch_to_table_language(arch);
		if (arch == v__pref__Arch__auto) {
			p->file_backend_mode = v__ast__Language_v;
		}
	};
}

v__ast__File v__parser__parse_file(string path, v__ast__Table* table, v__scanner__CommentsMode comments_mode, v__pref__Preferences* pref, v__ast__Scope* global_scope) {
	v__parser__Parser p = (v__parser__Parser){
		.pref = pref,
		.file_base = (string){.str=(byteptr)"", .is_lit=1},
		.file_name = (string){.str=(byteptr)"", .is_lit=1},
		.file_name_dir = (string){.str=(byteptr)"", .is_lit=1},
		.file_backend_mode = 0,
		.scanner = v__scanner__new_scanner_file(path, comments_mode, pref),
		.comments_mode = comments_mode,
		.tok = {0},
		.prev_tok = {0},
		.peek_tok = {0},
		.table = table,
		.language = 0,
		.inside_if = 0,
		.inside_if_expr = 0,
		.inside_ct_if_expr = 0,
		.inside_or_expr = 0,
		.inside_for = 0,
		.inside_fn = 0,
		.inside_unsafe_fn = 0,
		.inside_str_interp = 0,
		.or_is_handled = 0,
		.builtin_mod = 0,
		.mod = (string){.str=(byteptr)"", .is_lit=1},
		.is_manualfree = 0,
		.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),
		.expr_mod = (string){.str=(byteptr)"", .is_lit=1},
		.scope = (v__ast__Scope*)memdup(&(v__ast__Scope){.objects = new_map(sizeof(string), sizeof(v__ast__ScopeObject), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.struct_fields = __new_array(0, 1, sizeof(v__ast__ScopeStructField)),.parent = global_scope,.detached_from_parent = 0,.children = __new_array(0, 1, sizeof(v__ast__Scope*)),.start_pos = 0,.end_pos = 0,}, sizeof(v__ast__Scope)),
		.global_scope = global_scope,
		.imports = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.ast_imports = __new_array(0, 1, sizeof(v__ast__Import)),
		.used_imports = __new_array(0, 1, sizeof(string)),
		.auto_imports = __new_array(0, 1, sizeof(string)),
		.imported_symbols = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.is_amp = 0,
		.returns = 0,
		.inside_match = 0,
		.inside_select = 0,
		.inside_match_case = 0,
		.inside_match_body = 0,
		.inside_unsafe = 0,
		.is_stmt_ident = 0,
		.expecting_type = 0,
		.errors = __new_array_with_default(0, 0, sizeof(v__errors__Error), 0),
		.warnings = __new_array_with_default(0, 0, sizeof(v__errors__Warning), 0),
		.notices = __new_array(0, 1, sizeof(v__errors__Notice)),
		.vet_errors = __new_array(0, 1, sizeof(v__vet__Error)),
		.cur_fn_name = (string){.str=(byteptr)"", .is_lit=1},
		.label_names = __new_array(0, 1, sizeof(string)),
		.in_generic_params = 0,
		.name_error = 0,
		.n_asm = 0,
		.inside_asm_template = 0,
		.inside_asm = 0,
		.global_labels = __new_array(0, 1, sizeof(string)),
	};
	v__parser__Parser_set_path(&p, path);
	 v__ast__File _t2474 = v__parser__Parser_parse(&p);
	// autofree_scope_vars(pos=6277 line_nr=188 scope.pos=5383 scope.end_pos=6295)
	// var "path" var.pos=5394 var.line_nr=165
	// var "table" var.pos=5407 var.line_nr=165
	// var "comments_mode" var.pos=5425 var.line_nr=165
	// var "pref" var.pos=5461 var.line_nr=165
	// var "global_scope" var.pos=5485 var.line_nr=165
	// var "p" var.pos=5969 var.line_nr=174
	// af parent scope:
	// af parent scope:
	return _t2474;
}

multi_return_v__ast__File_Array_v__vet__Error v__parser__parse_vet_file(string path, v__ast__Table* table_, v__pref__Preferences* pref) {
	v__ast__Scope* global_scope = (v__ast__Scope*)memdup(&(v__ast__Scope){.objects = new_map(sizeof(string), sizeof(v__ast__ScopeObject), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.struct_fields = __new_array(0, 1, sizeof(v__ast__ScopeStructField)),.parent = 0,.detached_from_parent = 0,.children = __new_array(0, 1, sizeof(v__ast__Scope*)),.start_pos = 0,.end_pos = 0,}, sizeof(v__ast__Scope));
	v__parser__Parser p = (v__parser__Parser){
		.pref = pref,
		.file_base = (string){.str=(byteptr)"", .is_lit=1},
		.file_name = (string){.str=(byteptr)"", .is_lit=1},
		.file_name_dir = (string){.str=(byteptr)"", .is_lit=1},
		.file_backend_mode = 0,
		.scanner = v__scanner__new_scanner_file(path, v__scanner__CommentsMode_parse_comments, pref),
		.comments_mode = v__scanner__CommentsMode_parse_comments,
		.tok = {0},
		.prev_tok = {0},
		.peek_tok = {0},
		.table = table_,
		.language = 0,
		.inside_if = 0,
		.inside_if_expr = 0,
		.inside_ct_if_expr = 0,
		.inside_or_expr = 0,
		.inside_for = 0,
		.inside_fn = 0,
		.inside_unsafe_fn = 0,
		.inside_str_interp = 0,
		.or_is_handled = 0,
		.builtin_mod = 0,
		.mod = (string){.str=(byteptr)"", .is_lit=1},
		.is_manualfree = 0,
		.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),
		.expr_mod = (string){.str=(byteptr)"", .is_lit=1},
		.scope = (v__ast__Scope*)memdup(&(v__ast__Scope){.objects = new_map(sizeof(string), sizeof(v__ast__ScopeObject), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.struct_fields = __new_array(0, 1, sizeof(v__ast__ScopeStructField)),.parent = global_scope,.detached_from_parent = 0,.children = __new_array(0, 1, sizeof(v__ast__Scope*)),.start_pos = 0,.end_pos = 0,}, sizeof(v__ast__Scope)),
		.global_scope = global_scope,
		.imports = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.ast_imports = __new_array(0, 1, sizeof(v__ast__Import)),
		.used_imports = __new_array(0, 1, sizeof(string)),
		.auto_imports = __new_array(0, 1, sizeof(string)),
		.imported_symbols = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.is_amp = 0,
		.returns = 0,
		.inside_match = 0,
		.inside_select = 0,
		.inside_match_case = 0,
		.inside_match_body = 0,
		.inside_unsafe = 0,
		.is_stmt_ident = 0,
		.expecting_type = 0,
		.errors = __new_array_with_default(0, 0, sizeof(v__errors__Error), 0),
		.warnings = __new_array_with_default(0, 0, sizeof(v__errors__Warning), 0),
		.notices = __new_array(0, 1, sizeof(v__errors__Notice)),
		.vet_errors = __new_array(0, 1, sizeof(v__vet__Error)),
		.cur_fn_name = (string){.str=(byteptr)"", .is_lit=1},
		.label_names = __new_array(0, 1, sizeof(string)),
		.in_generic_params = 0,
		.name_error = 0,
		.n_asm = 0,
		.inside_asm_template = 0,
		.inside_asm = 0,
		.global_labels = __new_array(0, 1, sizeof(string)),
	};
	v__parser__Parser_set_path(&p, path);
	if (string_contains_any_substr(p.scanner->text, new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT("\n  "), _SLIT(" \n")})))) {
		Option_Array_string _t2475 = os__read_lines(path);
		if (_t2475.state != 0) { /*or block*/ 
			IError err = _t2475.err;
			*(Array_string*) _t2475.data = __new_array_with_default(0, 0, sizeof(string), 0);
		}
 		Array_string source_lines =  *(Array_string*)_t2475.data;
		// FOR IN array
		for (int lnumber = 0; lnumber < source_lines.len; ++lnumber) {
			string line = ((string*)source_lines.data)[lnumber];
			if (string_starts_with(line, _SLIT("  "))) {
				v__parser__Parser_vet_error(&p, _SLIT("Looks like you are using spaces for indentation."), lnumber, v__vet__FixKind_vfmt, v__vet__ErrorType_space_indent);
			}
			if (string_ends_with(line, _SLIT(" "))) {
				v__parser__Parser_vet_error(&p, _SLIT("Looks like you have trailing whitespace."), lnumber, v__vet__FixKind_unknown, v__vet__ErrorType_trailing_space);
			}
		}
	}
	_PUSH_MANY(&p.vet_errors, (p.scanner->vet_errors), _t2476, Array_v__vet__Error);
	v__ast__File file = v__parser__Parser_parse(&p);
	return (multi_return_v__ast__File_Array_v__vet__Error){.arg0=file, .arg1=p.vet_errors};
}

v__ast__File v__parser__Parser_parse(v__parser__Parser* p) {
bool v__parser__Parser_parse_defer_0 = false;
	v__util__timing_start(_SLIT("PARSE"));
	v__parser__Parser_parse_defer_0 = true;
	v__parser__Parser_init_parse_fns(p);
	v__parser__Parser_read_first_token(p);
	Array_v__ast__Stmt stmts = __new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
	for (;;) {
		if (!(p->tok.kind == v__token__Kind_comment)) break;
		array_push(&stmts, _MOV((v__ast__Stmt[]){ v__ast__ExprStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__ExprStmt, (v__parser__Parser_comment_stmt(p)))) }));
	}
	v__ast__Module module_decl = v__parser__Parser_module_decl(p);
	if (module_decl.is_skipped) {
		array_insert(&stmts, 0, &(v__ast__Stmt[]){v__ast__Module_to_sumtype_v__ast__Stmt(ADDR(v__ast__Module, (module_decl)))});
	} else {
		array_push(&stmts, _MOV((v__ast__Stmt[]){ v__ast__Module_to_sumtype_v__ast__Stmt(ADDR(v__ast__Module, (module_decl))) }));
	}
	for (;;) {
		if (p->tok.kind == v__token__Kind_key_import) {
			array_push(&stmts, _MOV((v__ast__Stmt[]){ v__ast__Import_to_sumtype_v__ast__Stmt(ADDR(v__ast__Import, (v__parser__Parser_import_stmt(p)))) }));
			continue;
		}
		if (p->tok.kind == v__token__Kind_comment) {
			array_push(&stmts, _MOV((v__ast__Stmt[]){ v__ast__ExprStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__ExprStmt, (v__parser__Parser_comment_stmt(p)))) }));
			continue;
		}
		break;
	}
	for (;;) {
		if (p->tok.kind == v__token__Kind_eof) {
			v__parser__Parser_check_unused_imports(p);
			break;
		}
		v__ast__Stmt stmt = v__parser__Parser_top_stmt(p);
		if (!((stmt)._typ == 293 /* v.ast.ExprStmt */ && ((/* as */ *(v__ast__ExprStmt*)__as_cast((stmt)._v__ast__ExprStmt,(stmt)._typ, 293) /*expected idx: 293, name: v.ast.ExprStmt */ ).expr)._typ == 245 /* v.ast.Comment */)) {
			p->attrs = __new_array_with_default(0, 0, sizeof(v__ast__Attr), 0);
		}
		array_push(&stmts, _MOV((v__ast__Stmt[]){ stmt }));
	}
	p->scope->end_pos = p->tok.pos;
	// Defer begin
	if (v__parser__Parser_parse_defer_0 == true) {
		v__util__timing_measure_cumulative(_SLIT("PARSE"));
	}
	// Defer end
	 v__ast__File _t2482 = (v__ast__File){
		.path = p->file_name,
		.path_base = p->file_base,
		.lines = p->scanner->line_nr,
		.bytes = p->scanner->text.len,
		.mod = module_decl,
		.global_scope = p->global_scope,
		.scope = p->scope,
		.stmts = stmts,
		.imports = p->ast_imports,
		.auto_imports = p->auto_imports,
		.embedded_files = __new_array(0, 1, sizeof(v__ast__EmbeddedFile)),
		.imported_symbols = p->imported_symbols,
		.errors = p->errors,
		.warnings = p->warnings,
		.notices = __new_array(0, 1, sizeof(v__errors__Notice)),
		.generic_fns = __new_array(0, 1, sizeof(v__ast__FnDecl*)),
		.global_labels = p->global_labels,
	};
	// autofree_scope_vars(pos=8292 line_nr=275 scope.pos=7291 scope.end_pos=8665)
	// var "p" var.pos=7296 var.line_nr=227
	// var "stmts" var.pos=7487 var.line_nr=235
	// var "module_decl" var.pos=7582 var.line_nr=240
	// af parent scope:
	// af parent scope:
	return _t2482;
}

Array_v__ast__File v__parser__parse_files(Array_string paths, v__ast__Table* table, v__pref__Preferences* pref, v__ast__Scope* global_scope) {
	v__util__Timers* timers = v__util__new_timers(false);
	Array_v__ast__File files = __new_array_with_default(0, 0, sizeof(v__ast__File), 0);
	// FOR IN array
	for (int _t2483 = 0; _t2483 < paths.len; ++_t2483) {
		string path = ((string*)paths.data)[_t2483];
		v__util__Timers_start(timers, _STR("parse_file %.*s", 1, path));
		array_push(&files, _MOV((v__ast__File[]){ v__parser__parse_file(path, table, v__scanner__CommentsMode_skip_comments, pref, global_scope) }));
		v__util__Timers_show(timers, _STR("parse_file %.*s", 1, path));
	}
	// autofree_scope_vars(pos=10259 line_nr=363 scope.pos=9304 scope.end_pos=10273)
	// var "paths" var.pos=9316 var.line_nr=326
	// var "table" var.pos=9332 var.line_nr=326
	// var "pref" var.pos=9350 var.line_nr=326
	// var "global_scope" var.pos=9374 var.line_nr=326
	// var "timers" var.pos=9417 var.line_nr=327
	// var "files" var.pos=10039 var.line_nr=356
	// af parent scope:
	// af parent scope:
	return files;
}

void v__parser__Parser_init_parse_fns(v__parser__Parser* p) {
}

void v__parser__Parser_read_first_token(v__parser__Parser* p) {
	v__parser__Parser_next(p);
	v__parser__Parser_next(p);
}

// Attr: [inline]
inline v__token__Token v__parser__Parser_peek_token(v__parser__Parser* p, int n) {
	 v__token__Token _t2485 = v__scanner__Scanner_peek_token(p->scanner, n - 2);
	// autofree_scope_vars(pos=10630 line_nr=379 scope.pos=10586 scope.end_pos=10666)
	// var "p" var.pos=10587 var.line_nr=378
	// var "n" var.pos=10609 var.line_nr=378
	// af parent scope:
	// af parent scope:
	return _t2485;
}

void v__parser__Parser_open_scope(v__parser__Parser* p) {
	p->scope = (v__ast__Scope*)memdup(&(v__ast__Scope){.objects = new_map(sizeof(string), sizeof(v__ast__ScopeObject), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.struct_fields = __new_array(0, 1, sizeof(v__ast__ScopeStructField)),.parent = p->scope,.detached_from_parent = 0,.children = __new_array(0, 1, sizeof(v__ast__Scope*)),.start_pos = p->tok.pos,.end_pos = 0,}, sizeof(v__ast__Scope));
}

void v__parser__Parser_close_scope(v__parser__Parser* p) {
	p->scope->end_pos = p->prev_tok.pos;
	array_push(&p->scope->parent->children, _MOV((v__ast__Scope*[]){ p->scope }));
	p->scope = p->scope->parent;
}

Array_v__ast__Stmt v__parser__Parser_parse_block(v__parser__Parser* p) {
	v__parser__Parser_open_scope(p);
	Array_v__ast__Stmt stmts = v__parser__Parser_parse_block_no_scope(p, false);
	v__parser__Parser_close_scope(p);
	// autofree_scope_vars(pos=11424 line_nr=406 scope.pos=11236 scope.end_pos=11438)
	// var "p" var.pos=11241 var.line_nr=400
	// var "stmts" var.pos=11322 var.line_nr=403
	// af parent scope:
	// af parent scope:
	return stmts;
}

Array_v__ast__Stmt v__parser__Parser_parse_block_no_scope(v__parser__Parser* p, bool is_top_level) {
	v__parser__Parser_check(p, v__token__Kind_lcbr);
	Array_v__ast__Stmt stmts = __new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
	if (p->tok.kind != v__token__Kind_rcbr) {
		int count = 0;
		for (;;) {
			if (!(!(p->tok.kind == v__token__Kind_eof || p->tok.kind == v__token__Kind_rcbr))) break;
			array_push(&stmts, _MOV((v__ast__Stmt[]){ v__parser__Parser_stmt(p, is_top_level) }));
			count++;
			if (count % 100000 == 0) {
				eprintln(_STR("parsed %"PRId32"\000 statements so far from fn %.*s\000 ...", 3, count, p->cur_fn_name));
			}
			if (count > 1000000) {
				v__parser__Parser_error_with_pos(p, _STR("parsed over %"PRId32"\000 statements from fn %.*s\000, the parser is probably stuck", 3, count, p->cur_fn_name), v__token__Token_position(&p->tok));
				 Array_v__ast__Stmt _t2488 = __new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
				// autofree_scope_vars(pos=11948 line_nr=423 scope.pos=11813 scope.end_pos=11962)
				// af parent scope:
				// af parent scope:
				// af parent scope:
				// var "count" var.pos=11591 var.line_nr=413
				// af parent scope:
				// var "p" var.pos=11453 var.line_nr=409
				// var "is_top_level" var.pos=11484 var.line_nr=409
				// var "stmts" var.pos=11537 var.line_nr=411
				// af parent scope:
				// af parent scope:
				return _t2488;
			}
		}
	}
	if (is_top_level) {
		v__parser__Parser_top_level_statement_end(p);
	}
	v__parser__Parser_check(p, v__token__Kind_rcbr);
	// autofree_scope_vars(pos=12039 line_nr=431 scope.pos=11448 scope.end_pos=12053)
	// var "p" var.pos=11453 var.line_nr=409
	// var "is_top_level" var.pos=11484 var.line_nr=409
	// var "stmts" var.pos=11537 var.line_nr=411
	// af parent scope:
	// af parent scope:
	return stmts;
}

VV_LOCAL_SYMBOL void v__parser__Parser_next(v__parser__Parser* p) {
	p->prev_tok = p->tok;
	p->tok = p->peek_tok;
	p->peek_tok = v__scanner__Scanner_scan(p->scanner);
}

VV_LOCAL_SYMBOL void v__parser__Parser_check(v__parser__Parser* p, v__token__Kind expected) {
	p->name_error = false;
	if (_likely_(p->tok.kind == expected)) {
		v__parser__Parser_next(p);
	} else {
		if (expected == v__token__Kind_name) {
			p->name_error = true;
		}
		string s = v__token__Kind_str(expected);
		if (v__token__is_key(s) || (s.len > 0 && !byte_is_letter(string_at(s, 0)))) {
			s = _STR("`%.*s\000`", 2, s);
		}
		v__parser__Parser_error(p, _STR("unexpected %.*s\000, expecting %.*s", 2, v__token__Token_str(p->tok), s));
	}
}

VV_LOCAL_SYMBOL string v__parser__Parser_check_js_name(v__parser__Parser* p) {
	string name = _SLIT("");
	for (;;) {
		if (!(p->peek_tok.kind == v__token__Kind_dot)) break;
		name = /*f*/string_add(name, _STR("%.*s\000.", 2, p->tok.lit));
		v__parser__Parser_next(p);
		v__parser__Parser_next(p);
	}
	name = /*f*/string_add(name, p->tok.lit);
	v__parser__Parser_next(p);
	// autofree_scope_vars(pos=13119 line_nr=485 scope.pos=12920 scope.end_pos=13132)
	// var "p" var.pos=12925 var.line_nr=475
	// var "name" var.pos=12965 var.line_nr=476
	// str literal
	// af parent scope:
	// af parent scope:
	return name;
}

VV_LOCAL_SYMBOL string v__parser__Parser_check_name(v__parser__Parser* p) {
	string name = p->tok.lit;
	if (p->peek_tok.kind == v__token__Kind_dot && _IN_MAP(ADDR(string, name), ADDR(map, p->imports))) {
		v__parser__Parser_register_used_import(p, name);
	}
	v__parser__Parser_check(p, v__token__Kind_name);
	// autofree_scope_vars(pos=13295 line_nr=494 scope.pos=13138 scope.end_pos=13308)
	// var "p" var.pos=13143 var.line_nr=488
	// var "name" var.pos=13176 var.line_nr=489
	// af parent scope:
	// af parent scope:
	return name;
}

v__ast__Stmt v__parser__Parser_top_stmt(v__parser__Parser* p) {
	for (;;) {

		if (p->tok.kind == (v__token__Kind_key_pub)) {

			if (p->peek_tok.kind == (v__token__Kind_key_const)) {
				 v__ast__Stmt _t2489 = v__ast__ConstDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__ConstDecl, (v__parser__Parser_const_decl(p))));
				// autofree_scope_vars(pos=13651 line_nr=507 scope.pos=13633 scope.end_pos=13679)
				// af parent scope:
				// af parent scope:
				// af parent scope:
				// var "p" var.pos=13323 var.line_nr=497
				// af parent scope:
				// af parent scope:
				return _t2489;
			}
			else if (p->peek_tok.kind == (v__token__Kind_key_fn)) {
				 v__ast__Stmt _t2490 = v__ast__FnDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__FnDecl, (v__parser__Parser_fn_decl(p))));
				// autofree_scope_vars(pos=13701 line_nr=510 scope.pos=13686 scope.end_pos=13726)
				// af parent scope:
				// af parent scope:
				// af parent scope:
				// var "p" var.pos=13323 var.line_nr=497
				// af parent scope:
				// af parent scope:
				return _t2490;
			}
			else if (p->peek_tok.kind == (v__token__Kind_key_struct) || p->peek_tok.kind == (v__token__Kind_key_union)) {
				 v__ast__Stmt _t2491 = v__ast__StructDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__StructDecl, (v__parser__Parser_struct_decl(p))));
				// autofree_scope_vars(pos=13764 line_nr=513 scope.pos=13733 scope.end_pos=13793)
				// af parent scope:
				// af parent scope:
				// af parent scope:
				// var "p" var.pos=13323 var.line_nr=497
				// af parent scope:
				// af parent scope:
				return _t2491;
			}
			else if (p->peek_tok.kind == (v__token__Kind_key_interface)) {
				 v__ast__Stmt _t2492 = v__ast__InterfaceDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__InterfaceDecl, (v__parser__Parser_interface_decl(p))));
				// autofree_scope_vars(pos=13822 line_nr=516 scope.pos=13800 scope.end_pos=13854)
				// af parent scope:
				// af parent scope:
				// af parent scope:
				// var "p" var.pos=13323 var.line_nr=497
				// af parent scope:
				// af parent scope:
				return _t2492;
			}
			else if (p->peek_tok.kind == (v__token__Kind_key_enum)) {
				 v__ast__Stmt _t2493 = v__ast__EnumDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__EnumDecl, (v__parser__Parser_enum_decl(p))));
				// autofree_scope_vars(pos=13878 line_nr=519 scope.pos=13861 scope.end_pos=13905)
				// af parent scope:
				// af parent scope:
				// af parent scope:
				// var "p" var.pos=13323 var.line_nr=497
				// af parent scope:
				// af parent scope:
				return _t2493;
			}
			else if (p->peek_tok.kind == (v__token__Kind_key_type)) {
				 v__ast__Stmt _t2494 = v__ast__TypeDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__TypeDecl, (v__parser__Parser_type_decl(p))));
				// autofree_scope_vars(pos=13929 line_nr=522 scope.pos=13912 scope.end_pos=13956)
				// af parent scope:
				// af parent scope:
				// af parent scope:
				// var "p" var.pos=13323 var.line_nr=497
				// af parent scope:
				// af parent scope:
				return _t2494;
			}
			else {
				 v__ast__Stmt _t2495 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error(p, _SLIT("wrong pub keyword usage")))));
				// autofree_scope_vars(pos=13975 line_nr=525 scope.pos=13963 scope.end_pos=14023)
				// af parent scope:
				// af parent scope:
				// af parent scope:
				// var "p" var.pos=13323 var.line_nr=497
				// af parent scope:
				// af parent scope:
				return _t2495;
			};
		}
		else if (p->tok.kind == (v__token__Kind_lsbr)) {
			v__parser__Parser_attributes(p);
			continue;
		}
		else if (p->tok.kind == (v__token__Kind_key_asm)) {
			 v__ast__Stmt _t2496 = v__ast__AsmStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__AsmStmt, (v__parser__Parser_asm_stmt(p, true))));
			// autofree_scope_vars(pos=14138 line_nr=535 scope.pos=14124 scope.end_pos=14166)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=13323 var.line_nr=497
			// af parent scope:
			// af parent scope:
			return _t2496;
		}
		else if (p->tok.kind == (v__token__Kind_key_interface)) {
			 v__ast__Stmt _t2497 = v__ast__InterfaceDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__InterfaceDecl, (v__parser__Parser_interface_decl(p))));
			// autofree_scope_vars(pos=14191 line_nr=538 scope.pos=14171 scope.end_pos=14221)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=13323 var.line_nr=497
			// af parent scope:
			// af parent scope:
			return _t2497;
		}
		else if (p->tok.kind == (v__token__Kind_key_import)) {
			v__parser__Parser_error_with_pos(p, _SLIT("`import x` can only be declared at the beginning of the file"), v__token__Token_position(&p->tok));
			 v__ast__Stmt _t2498 = v__ast__Import_to_sumtype_v__ast__Stmt(ADDR(v__ast__Import, (v__parser__Parser_import_stmt(p))));
			// autofree_scope_vars(pos=14351 line_nr=543 scope.pos=14226 scope.end_pos=14378)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=13323 var.line_nr=497
			// af parent scope:
			// af parent scope:
			return _t2498;
		}
		else if (p->tok.kind == (v__token__Kind_key_global)) {
			 v__ast__Stmt _t2499 = v__ast__GlobalDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__GlobalDecl, (v__parser__Parser_global_decl(p))));
			// autofree_scope_vars(pos=14400 line_nr=546 scope.pos=14383 scope.end_pos=14427)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=13323 var.line_nr=497
			// af parent scope:
			// af parent scope:
			return _t2499;
		}
		else if (p->tok.kind == (v__token__Kind_key_const)) {
			 v__ast__Stmt _t2500 = v__ast__ConstDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__ConstDecl, (v__parser__Parser_const_decl(p))));
			// autofree_scope_vars(pos=14448 line_nr=549 scope.pos=14432 scope.end_pos=14474)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=13323 var.line_nr=497
			// af parent scope:
			// af parent scope:
			return _t2500;
		}
		else if (p->tok.kind == (v__token__Kind_key_fn)) {
			 v__ast__Stmt _t2501 = v__ast__FnDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__FnDecl, (v__parser__Parser_fn_decl(p))));
			// autofree_scope_vars(pos=14492 line_nr=552 scope.pos=14479 scope.end_pos=14515)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=13323 var.line_nr=497
			// af parent scope:
			// af parent scope:
			return _t2501;
		}
		else if (p->tok.kind == (v__token__Kind_key_struct)) {
			 v__ast__Stmt _t2502 = v__ast__StructDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__StructDecl, (v__parser__Parser_struct_decl(p))));
			// autofree_scope_vars(pos=14537 line_nr=555 scope.pos=14520 scope.end_pos=14564)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=13323 var.line_nr=497
			// af parent scope:
			// af parent scope:
			return _t2502;
		}
		else if (p->tok.kind == (v__token__Kind_dollar)) {
			v__ast__IfExpr if_expr = v__parser__Parser_if_expr(p, true);
			 v__ast__Stmt _t2503 = v__ast__ExprStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__ExprStmt, ((v__ast__ExprStmt){.expr = v__ast__IfExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__IfExpr, (if_expr))),.pos = if_expr.pos,.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.is_expr = 0,.typ = 0,})));
			// autofree_scope_vars(pos=14613 line_nr=559 scope.pos=14569 scope.end_pos=14685)
			// var "if_expr" var.pos=14583 var.line_nr=558
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=13323 var.line_nr=497
			// af parent scope:
			// af parent scope:
			return _t2503;
		}
		else if (p->tok.kind == (v__token__Kind_hash)) {
			 v__ast__Stmt _t2504 = v__ast__HashStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__HashStmt, (v__parser__Parser_hash(p))));
			// autofree_scope_vars(pos=14701 line_nr=565 scope.pos=14690 scope.end_pos=14721)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=13323 var.line_nr=497
			// af parent scope:
			// af parent scope:
			return _t2504;
		}
		else if (p->tok.kind == (v__token__Kind_key_type)) {
			 v__ast__Stmt _t2505 = v__ast__TypeDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__TypeDecl, (v__parser__Parser_type_decl(p))));
			// autofree_scope_vars(pos=14741 line_nr=568 scope.pos=14726 scope.end_pos=14766)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=13323 var.line_nr=497
			// af parent scope:
			// af parent scope:
			return _t2505;
		}
		else if (p->tok.kind == (v__token__Kind_key_enum)) {
			 v__ast__Stmt _t2506 = v__ast__EnumDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__EnumDecl, (v__parser__Parser_enum_decl(p))));
			// autofree_scope_vars(pos=14786 line_nr=571 scope.pos=14771 scope.end_pos=14811)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=13323 var.line_nr=497
			// af parent scope:
			// af parent scope:
			return _t2506;
		}
		else if (p->tok.kind == (v__token__Kind_key_union)) {
			 v__ast__Stmt _t2507 = v__ast__StructDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__StructDecl, (v__parser__Parser_struct_decl(p))));
			// autofree_scope_vars(pos=14832 line_nr=574 scope.pos=14816 scope.end_pos=14859)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=13323 var.line_nr=497
			// af parent scope:
			// af parent scope:
			return _t2507;
		}
		else if (p->tok.kind == (v__token__Kind_comment)) {
			 v__ast__Stmt _t2508 = v__ast__ExprStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__ExprStmt, (v__parser__Parser_comment_stmt(p))));
			// autofree_scope_vars(pos=14878 line_nr=577 scope.pos=14864 scope.end_pos=14906)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=13323 var.line_nr=497
			// af parent scope:
			// af parent scope:
			return _t2508;
		}
		else {
			p->inside_fn = true;
			if (p->pref->is_script && !p->pref->is_test) {
				Array_v__ast__Stmt stmts = __new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
				for (;;) {
					if (!(p->tok.kind != v__token__Kind_eof)) break;
					array_push(&stmts, _MOV((v__ast__Stmt[]){ v__parser__Parser_stmt(p, false) }));
				}
				 v__ast__Stmt _t2510 = v__ast__FnDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__FnDecl, ((v__ast__FnDecl){
					.name = _SLIT("main.main"),
					.mod = _SLIT("main"),
					.params = __new_array(0, 1, sizeof(v__ast__Param)),
					.is_deprecated = 0,
					.is_pub = 0,
					.is_variadic = 0,
					.is_anon = 0,
					.is_manualfree = 0,
					.is_main = true,
					.is_test = 0,
					.is_conditional = 0,
					.is_keep_alive = 0,
					.receiver = (v__ast__StructField){.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),},
					.receiver_pos = {0},
					.is_method = 0,
					.method_type_pos = {0},
					.method_idx = 0,
					.rec_mut = 0,
					.rec_share = 0,
					.language = 0,
					.no_body = 0,
					.is_builtin = 0,
					.body_pos = {0},
					.file = p->file_name,
					.generic_names = __new_array(0, 1, sizeof(string)),
					.is_direct_arr = 0,
					.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),
					.skip_gen = 0,
					.stmts = stmts,
					.defer_stmts = __new_array(0, 1, sizeof(v__ast__DeferStmt)),
					.return_type = _const_v__ast__void_type,
					.return_type_pos = {0},
					.has_return = 0,
					.comments = __new_array(0, 1, sizeof(v__ast__Comment)),
					.next_comments = __new_array(0, 1, sizeof(v__ast__Comment)),
					.source_file = 0,
					.scope = p->scope,
					.label_names = p->label_names,
					.pos = {0},
				})));
				// autofree_scope_vars(pos=15087 line_nr=586 scope.pos=14984 scope.end_pos=15310)
				// var "stmts" var.pos=14995 var.line_nr=582
				// af parent scope:
				// af parent scope:
				// af parent scope:
				// var "p" var.pos=13323 var.line_nr=497
				// af parent scope:
				// af parent scope:
				return _t2510;
			} else if (p->pref->is_fmt) {
				 v__ast__Stmt _t2511 = v__parser__Parser_stmt(p, false);
				// autofree_scope_vars(pos=15340 line_nr=597 scope.pos=15334 scope.end_pos=15366)
				// af parent scope:
				// af parent scope:
				// af parent scope:
				// var "p" var.pos=13323 var.line_nr=497
				// af parent scope:
				// af parent scope:
				return _t2511;
			} else {
				 v__ast__Stmt _t2512 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error(p, string_add(_SLIT("bad top level statement "), v__token__Token_str(p->tok))))));
				// autofree_scope_vars(pos=15379 line_nr=599 scope.pos=15373 scope.end_pos=15441)
				// af parent scope:
				// af parent scope:
				// af parent scope:
				// var "p" var.pos=13323 var.line_nr=497
				// af parent scope:
				// af parent scope:
				return _t2512;
			}
		};
	}
	 v__ast__Stmt _t2513 = v__ast__empty_stmt();
	// autofree_scope_vars(pos=15539 line_nr=606 scope.pos=13318 scope.end_pos=15564)
	// var "p" var.pos=13323 var.line_nr=497
	// af parent scope:
	// af parent scope:
	return _t2513;
}

v__ast__Comment v__parser__Parser_check_comment(v__parser__Parser* p) {
	if (p->tok.kind == v__token__Kind_comment) {
		 v__ast__Comment _t2514 = v__parser__Parser_comment(p);
		// autofree_scope_vars(pos=15667 line_nr=612 scope.pos=15664 scope.end_pos=15688)
		// af parent scope:
		// var "p" var.pos=15597 var.line_nr=610
		// af parent scope:
		// af parent scope:
		return _t2514;
	}
	 v__ast__Comment _t2515 = (v__ast__Comment){.text = (string){.str=(byteptr)"", .is_lit=1},.is_multi = 0,.line_nr = 0,.pos = {0},};
	// autofree_scope_vars(pos=15690 line_nr=614 scope.pos=15592 scope.end_pos=15712)
	// var "p" var.pos=15597 var.line_nr=610
	// af parent scope:
	// af parent scope:
	return _t2515;
}

v__ast__Comment v__parser__Parser_comment(v__parser__Parser* p) {
	v__token__Position pos = v__token__Token_position(&p->tok);
	string text = p->tok.lit;
	pos.last_line = pos.line_nr + string_count(text, _SLIT("\n"));
	v__parser__Parser_next(p);
	bool is_multi = string_contains(text, _SLIT("\n"));
	if (p->vet_errors.len > 0 && is_multi) {
		Array_v__vet__Error _t2516_orig = p->vet_errors;
		int _t2516_len = _t2516_orig.len;
		Array_v__vet__Error _t2516 = __new_array(0, _t2516_len, sizeof(v__vet__Error));

		for (int _t2517 = 0; _t2517 < _t2516_len; ++_t2517) {
			v__vet__Error it = ((v__vet__Error*) _t2516_orig.data)[_t2517];
			if (it.typ != v__vet__ErrorType_space_indent || it.pos.line_nr - 1 > pos.last_line || it.pos.line_nr - 1 <= pos.line_nr) {
				array_push(&_t2516, &it); 
		}
		}
		
		p->vet_errors = _t2516;
	}
	 v__ast__Comment _t2518 = (v__ast__Comment){.text = text,.is_multi = is_multi,.line_nr = 0,.pos = pos,};
	// autofree_scope_vars(pos=16152 line_nr=628 scope.pos=15722 scope.end_pos=16221)
	// var "p" var.pos=15727 var.line_nr=617
	// var "pos" var.pos=15766 var.line_nr=618
	// var "text" var.pos=15791 var.line_nr=619
	// var "is_multi" var.pos=15868 var.line_nr=622
	// af parent scope:
	// af parent scope:
	return _t2518;
}

v__ast__ExprStmt v__parser__Parser_comment_stmt(v__parser__Parser* p) {
	v__ast__Comment comment = v__parser__Parser_comment(p);
	 v__ast__ExprStmt _t2519 = (v__ast__ExprStmt){.expr = v__ast__Comment_to_sumtype_v__ast__Expr(ADDR(v__ast__Comment, (comment))),.pos = comment.pos,.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.is_expr = 0,.typ = 0,};
	// autofree_scope_vars(pos=16300 line_nr=637 scope.pos=16231 scope.end_pos=16360)
	// var "p" var.pos=16236 var.line_nr=635
	// var "comment" var.pos=16277 var.line_nr=636
	// af parent scope:
	// af parent scope:
	return _t2519;
}

Array_v__ast__Comment v__parser__Parser_eat_comments(v__parser__Parser* p, v__parser__EatCommentsConfig cfg) {
	int line = p->prev_tok.line_nr;
	Array_v__ast__Comment comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	for (;;) {
		if (p->tok.kind != v__token__Kind_comment || (cfg.same_line && p->tok.line_nr > line) || (cfg.follow_up && p->tok.line_nr > line + 1)) {
			break;
		}
		array_push(&comments, _MOV((v__ast__Comment[]){ v__parser__Parser_comment(p) }));
		if (cfg.follow_up) {
			line = p->prev_tok.line_nr;
		}
	}
	// autofree_scope_vars(pos=16930 line_nr=661 scope.pos=16572 scope.end_pos=16947)
	// var "p" var.pos=16577 var.line_nr=648
	// var "cfg" var.pos=16600 var.line_nr=648
	// var "line" var.pos=16644 var.line_nr=649
	// var "comments" var.pos=16676 var.line_nr=650
	// af parent scope:
	// af parent scope:
	return comments;
}

v__ast__Stmt v__parser__Parser_stmt(v__parser__Parser* p, bool is_top_level) {
	p->is_stmt_ident = p->tok.kind == v__token__Kind_name;

	if (p->tok.kind == (v__token__Kind_lcbr)) {
		v__token__Position pos = v__token__Token_position(&p->tok);
		Array_v__ast__Stmt stmts = v__parser__Parser_parse_block(p);
		pos.last_line = p->prev_tok.line_nr;
		 v__ast__Stmt _t2521 = v__ast__Block_to_sumtype_v__ast__Stmt(ADDR(v__ast__Block, ((v__ast__Block){.stmts = stmts,.is_unsafe = 0,.pos = pos,})));
		// autofree_scope_vars(pos=17389 line_nr=675 scope.pos=17282 scope.end_pos=17445)
		// var "pos" var.pos=17297 var.line_nr=672
		// var "stmts" var.pos=17324 var.line_nr=673
		// af parent scope:
		// var "p" var.pos=16962 var.line_nr=664
		// var "is_top_level" var.pos=16977 var.line_nr=664
		// af parent scope:
		// af parent scope:
		return _t2521;
	}
	else if (p->tok.kind == (v__token__Kind_key_assert)) {
		v__parser__Parser_next(p);
		v__token__Position pos = v__token__Token_position(&p->tok);
		v__ast__Expr expr = v__parser__Parser_expr(p, 0);
		v__token__Position_update_last_line(&pos, p->prev_tok.line_nr);
		 v__ast__Stmt _t2522 = v__ast__AssertStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__AssertStmt, ((v__ast__AssertStmt){.pos = pos,.expr = expr,})));
		// autofree_scope_vars(pos=17573 line_nr=685 scope.pos=17449 scope.end_pos=17632)
		// var "pos" var.pos=17482 var.line_nr=682
		// var "expr" var.pos=17509 var.line_nr=683
		// af parent scope:
		// var "p" var.pos=16962 var.line_nr=664
		// var "is_top_level" var.pos=16977 var.line_nr=664
		// af parent scope:
		// af parent scope:
		return _t2522;
	}
	else if (p->tok.kind == (v__token__Kind_key_for)) {
		 v__ast__Stmt _t2523 = v__parser__Parser_for_stmt(p);
		// autofree_scope_vars(pos=17649 line_nr=691 scope.pos=17636 scope.end_pos=17672)
		// af parent scope:
		// var "p" var.pos=16962 var.line_nr=664
		// var "is_top_level" var.pos=16977 var.line_nr=664
		// af parent scope:
		// af parent scope:
		return _t2523;
	}
	else if (p->tok.kind == (v__token__Kind_name)) {
		if (string_eq(p->tok.lit, _SLIT("sql"))) {
			 v__ast__Stmt _t2524 = v__ast__SqlStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__SqlStmt, (v__parser__Parser_sql_stmt(p))));
			// autofree_scope_vars(pos=17714 line_nr=695 scope.pos=17709 scope.end_pos=17738)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=16962 var.line_nr=664
			// var "is_top_level" var.pos=16977 var.line_nr=664
			// af parent scope:
			// af parent scope:
			return _t2524;
		}
		if (p->peek_tok.kind == v__token__Kind_colon) {
			v__token__Position spos = v__token__Token_position(&p->tok);
			string name = v__parser__Parser_check_name(p);
			if ((Array_string_contains(p->label_names, name))) {
				v__parser__Parser_error_with_pos(p, _STR("duplicate label `%.*s\000`", 2, name), spos);
			}
			array_push(&p->label_names, _MOV((string[]){ string_clone(name) }));
			v__parser__Parser_next(p);
			if (p->tok.kind == v__token__Kind_key_for) {
				v__token__Position for_pos = v__token__Token_position(&p->tok);
				v__ast__Stmt stmt = v__parser__Parser_stmt(p, is_top_level);
				if (stmt._typ == 296 /* v.ast.ForStmt */) {
					(*stmt._v__ast__ForStmt).label = name;
					// autofree_scope_vars(pos=18153 line_nr=712 scope.pos=18108 scope.end_pos=18172)
					// var "stmt" var.pos=18095 var.line_nr=709
					// af parent scope:
					// var "for_pos" var.pos=18014 var.line_nr=707
					// var "stmt" var.pos=18051 var.line_nr=708
					// af parent scope:
					// var "spos" var.pos=17794 var.line_nr=699
					// var "name" var.pos=17823 var.line_nr=700
					// af parent scope:
					// af parent scope:
					// var "p" var.pos=16962 var.line_nr=664
					// var "is_top_level" var.pos=16977 var.line_nr=664
					// af parent scope:
					// af parent scope:
					return stmt;
				}
				else if (stmt._typ == 295 /* v.ast.ForInStmt */) {
					(*stmt._v__ast__ForInStmt).label = name;
					// autofree_scope_vars(pos=18227 line_nr=716 scope.pos=18180 scope.end_pos=18246)
					// var "stmt" var.pos=18095 var.line_nr=709
					// af parent scope:
					// var "for_pos" var.pos=18014 var.line_nr=707
					// var "stmt" var.pos=18051 var.line_nr=708
					// af parent scope:
					// var "spos" var.pos=17794 var.line_nr=699
					// var "name" var.pos=17823 var.line_nr=700
					// af parent scope:
					// af parent scope:
					// var "p" var.pos=16962 var.line_nr=664
					// var "is_top_level" var.pos=16977 var.line_nr=664
					// af parent scope:
					// af parent scope:
					return stmt;
				}
				else if (stmt._typ == 294 /* v.ast.ForCStmt */) {
					(*stmt._v__ast__ForCStmt).label = name;
					// autofree_scope_vars(pos=18300 line_nr=720 scope.pos=18254 scope.end_pos=18319)
					// var "stmt" var.pos=18095 var.line_nr=709
					// af parent scope:
					// var "for_pos" var.pos=18014 var.line_nr=707
					// var "stmt" var.pos=18051 var.line_nr=708
					// af parent scope:
					// var "spos" var.pos=17794 var.line_nr=699
					// var "name" var.pos=17823 var.line_nr=700
					// af parent scope:
					// af parent scope:
					// var "p" var.pos=16962 var.line_nr=664
					// var "is_top_level" var.pos=16977 var.line_nr=664
					// af parent scope:
					// af parent scope:
					return stmt;
				}
				else {
					v__parser__Parser_error_with_pos(p, _SLIT("unknown kind of For statement"), for_pos);
				};
			}
			 v__ast__Stmt _t2526 = v__ast__GotoLabel_to_sumtype_v__ast__Stmt(ADDR(v__ast__GotoLabel, ((v__ast__GotoLabel){.name = name,.pos = v__token__Position_extend(spos, v__token__Token_position(&p->tok)),})));
			// autofree_scope_vars(pos=18424 line_nr=727 scope.pos=17772 scope.end_pos=18512)
			// var "spos" var.pos=17794 var.line_nr=699
			// var "name" var.pos=17823 var.line_nr=700
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=16962 var.line_nr=664
			// var "is_top_level" var.pos=16977 var.line_nr=664
			// af parent scope:
			// af parent scope:
			return _t2526;
		} else if (p->peek_tok.kind == v__token__Kind_name) {
			 v__ast__Stmt _t2527 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _STR("unexpected name `%.*s\000`", 2, p->peek_tok.lit), v__token__Token_position(&p->peek_tok)))));
			// autofree_scope_vars(pos=18552 line_nr=732 scope.pos=18547 scope.end_pos=18640)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=16962 var.line_nr=664
			// var "is_top_level" var.pos=16977 var.line_nr=664
			// af parent scope:
			// af parent scope:
			return _t2527;
		} else if (!p->inside_if_expr && !p->inside_match_body && !p->inside_or_expr && (p->peek_tok.kind == v__token__Kind_rcbr || p->peek_tok.kind == v__token__Kind_eof) && !v__parser__Parser_mark_var_as_used(p, p->tok.lit)) {
			 v__ast__Stmt _t2528 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _STR("`%.*s\000` evaluated but not used", 2, p->tok.lit), v__token__Token_position(&p->tok)))));
			// autofree_scope_vars(pos=18792 line_nr=735 scope.pos=18787 scope.end_pos=18877)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=16962 var.line_nr=664
			// var "is_top_level" var.pos=16977 var.line_nr=664
			// af parent scope:
			// af parent scope:
			return _t2528;
		}
		 v__ast__Stmt _t2529 = v__parser__Parser_parse_multi_expr(p, is_top_level);
		// autofree_scope_vars(pos=18881 line_nr=737 scope.pos=17676 scope.end_pos=18924)
		// af parent scope:
		// var "p" var.pos=16962 var.line_nr=664
		// var "is_top_level" var.pos=16977 var.line_nr=664
		// af parent scope:
		// af parent scope:
		return _t2529;
	}
	else if (p->tok.kind == (v__token__Kind_comment)) {
		 v__ast__Stmt _t2530 = v__ast__ExprStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__ExprStmt, (v__parser__Parser_comment_stmt(p))));
		// autofree_scope_vars(pos=18941 line_nr=740 scope.pos=18928 scope.end_pos=18968)
		// af parent scope:
		// var "p" var.pos=16962 var.line_nr=664
		// var "is_top_level" var.pos=16977 var.line_nr=664
		// af parent scope:
		// af parent scope:
		return _t2530;
	}
	else if (p->tok.kind == (v__token__Kind_key_return)) {
		 v__ast__Stmt _t2531 = v__ast__Return_to_sumtype_v__ast__Stmt(ADDR(v__ast__Return, (v__parser__Parser_return_stmt(p))));
		// autofree_scope_vars(pos=18988 line_nr=743 scope.pos=18972 scope.end_pos=19014)
		// af parent scope:
		// var "p" var.pos=16962 var.line_nr=664
		// var "is_top_level" var.pos=16977 var.line_nr=664
		// af parent scope:
		// af parent scope:
		return _t2531;
	}
	else if (p->tok.kind == (v__token__Kind_dollar)) {

		if (p->peek_tok.kind == (v__token__Kind_key_if)) {
			v__token__Position pos = v__token__Token_position(&p->tok);
			v__ast__IfExpr expr = v__parser__Parser_if_expr(p, true);
			v__token__Position_update_last_line(&pos, p->prev_tok.line_nr);
			 v__ast__Stmt _t2532 = v__ast__ExprStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__ExprStmt, ((v__ast__ExprStmt){.expr = v__ast__IfExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__IfExpr, (expr))),.pos = pos,.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.is_expr = 0,.typ = 0,})));
			// autofree_scope_vars(pos=19181 line_nr=751 scope.pos=19059 scope.end_pos=19246)
			// var "pos" var.pos=19078 var.line_nr=748
			// var "expr" var.pos=19107 var.line_nr=749
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=16962 var.line_nr=664
			// var "is_top_level" var.pos=16977 var.line_nr=664
			// af parent scope:
			// af parent scope:
			return _t2532;
		}
		else if (p->peek_tok.kind == (v__token__Kind_key_for)) {
			 v__ast__Stmt _t2533 = v__ast__CompFor_to_sumtype_v__ast__Stmt(ADDR(v__ast__CompFor, (v__parser__Parser_comp_for(p))));
			// autofree_scope_vars(pos=19267 line_nr=757 scope.pos=19252 scope.end_pos=19292)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=16962 var.line_nr=664
			// var "is_top_level" var.pos=16977 var.line_nr=664
			// af parent scope:
			// af parent scope:
			return _t2533;
		}
		else if (p->peek_tok.kind == (v__token__Kind_name)) {
			v__token__Position pos = v__token__Token_position(&p->tok);
			v__ast__ComptimeCall expr = v__parser__Parser_comp_call(p);
			v__token__Position_update_last_line(&pos, p->prev_tok.line_nr);
			 v__ast__Stmt _t2534 = v__ast__ExprStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__ExprStmt, ((v__ast__ExprStmt){.expr = v__ast__ComptimeCall_to_sumtype_v__ast__Expr(ADDR(v__ast__ComptimeCall, (expr))),.pos = pos,.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.is_expr = 0,.typ = 0,})));
			// autofree_scope_vars(pos=19416 line_nr=763 scope.pos=19298 scope.end_pos=19481)
			// var "pos" var.pos=19315 var.line_nr=760
			// var "expr" var.pos=19344 var.line_nr=761
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=16962 var.line_nr=664
			// var "is_top_level" var.pos=16977 var.line_nr=664
			// af parent scope:
			// af parent scope:
			return _t2534;
		}
		else {
			 v__ast__Stmt _t2535 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _SLIT("unexpected $"), v__token__Token_position(&p->tok)))));
			// autofree_scope_vars(pos=19498 line_nr=769 scope.pos=19487 scope.end_pos=19562)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=16962 var.line_nr=664
			// var "is_top_level" var.pos=16977 var.line_nr=664
			// af parent scope:
			// af parent scope:
			return _t2535;
		};
	}
	else if (p->tok.kind == (v__token__Kind_key_continue) || p->tok.kind == (v__token__Kind_key_break)) {
		v__token__Token tok = p->tok;
		int line = p->tok.line_nr;
		v__parser__Parser_next(p);
		string label = _SLIT("");
		if (p->tok.line_nr == line && p->tok.kind == v__token__Kind_name) {
			label = v__parser__Parser_check_name(p);
		}
		 v__ast__Stmt _t2536 = v__ast__BranchStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__BranchStmt, ((v__ast__BranchStmt){.kind = tok.kind,.label = label,.pos = v__token__Token_position(&tok),})));
		// autofree_scope_vars(pos=19762 line_nr=781 scope.pos=19575 scope.end_pos=19853)
		// var "tok" var.pos=19606 var.line_nr=774
		// var "line" var.pos=19622 var.line_nr=775
		// var "label" var.pos=19663 var.line_nr=777
		// str literal
		// af parent scope:
		// var "p" var.pos=16962 var.line_nr=664
		// var "is_top_level" var.pos=16977 var.line_nr=664
		// af parent scope:
		// af parent scope:
		return _t2536;
	}
	else if (p->tok.kind == (v__token__Kind_key_unsafe)) {
		 v__ast__Stmt _t2537 = v__parser__Parser_unsafe_stmt(p);
		// autofree_scope_vars(pos=19873 line_nr=788 scope.pos=19857 scope.end_pos=19899)
		// af parent scope:
		// var "p" var.pos=16962 var.line_nr=664
		// var "is_top_level" var.pos=16977 var.line_nr=664
		// af parent scope:
		// af parent scope:
		return _t2537;
	}
	else if (p->tok.kind == (v__token__Kind_hash)) {
		 v__ast__Stmt _t2538 = v__ast__HashStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__HashStmt, (v__parser__Parser_hash(p))));
		// autofree_scope_vars(pos=19913 line_nr=791 scope.pos=19903 scope.end_pos=19932)
		// af parent scope:
		// var "p" var.pos=16962 var.line_nr=664
		// var "is_top_level" var.pos=16977 var.line_nr=664
		// af parent scope:
		// af parent scope:
		return _t2538;
	}
	else if (p->tok.kind == (v__token__Kind_key_defer)) {
		v__parser__Parser_next(p);
		v__token__Position spos = v__token__Token_position(&p->tok);
		Array_v__ast__Stmt stmts = v__parser__Parser_parse_block(p);
		 v__ast__Stmt _t2539 = v__ast__DeferStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__DeferStmt, ((v__ast__DeferStmt){.stmts = stmts,.pos = v__token__Position_extend_with_last_line(spos, v__token__Token_position(&p->tok), p->prev_tok.line_nr),.ifdef = (string){.str=(byteptr)"", .is_lit=1},.idx_in_fn = -1,})));
		// autofree_scope_vars(pos=20019 line_nr=797 scope.pos=19936 scope.end_pos=20140)
		// var "spos" var.pos=19964 var.line_nr=795
		// var "stmts" var.pos=19992 var.line_nr=796
		// af parent scope:
		// var "p" var.pos=16962 var.line_nr=664
		// var "is_top_level" var.pos=16977 var.line_nr=664
		// af parent scope:
		// af parent scope:
		return _t2539;
	}
	else if (p->tok.kind == (v__token__Kind_key_go)) {
		v__parser__Parser_next(p);
		v__token__Position spos = v__token__Token_position(&p->tok);
		v__ast__Expr expr = v__parser__Parser_expr(p, 0);
		v__ast__CallExpr call_expr = ((expr)._typ == 241 /* v.ast.CallExpr */ ? ((*expr._v__ast__CallExpr)) : (v__parser__Parser_error_with_pos(p, _SLIT("expression in `go` must be a function call"), v__ast__Expr_position(expr)),(v__ast__CallExpr){.pos = {0},.name_pos = {0},.mod = (string){.str=(byteptr)"", .is_lit=1},.name = (string){.str=(byteptr)"", .is_lit=1},.is_method = 0,.is_field = 0,.is_keep_alive = 0,.args = __new_array(0, 1, sizeof(v__ast__CallArg)),.expected_arg_types = __new_array(0, 1, sizeof(v__ast__Type)),.language = 0,.or_block = (v__ast__OrExpr){.stmts = __new_array(0, 1, sizeof(v__ast__Stmt)),},.left = {0},.left_type = 0,.receiver_type = 0,.return_type = 0,.should_be_skipped = 0,.generic_types = __new_array(0, 1, sizeof(v__ast__Type)),.generic_list_pos = {0},.free_receiver = 0,.scope = p->scope,.from_embed_type = 0,.comments = __new_array(0, 1, sizeof(v__ast__Comment)),}));
		 v__ast__Stmt _t2540 = v__ast__GoStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__GoStmt, ((v__ast__GoStmt){.pos = v__token__Position_extend(spos, v__token__Token_position(&p->prev_tok)),.call_expr = call_expr,})));
		// autofree_scope_vars(pos=20413 line_nr=814 scope.pos=20144 scope.end_pos=20509)
		// var "spos" var.pos=20169 var.line_nr=804
		// var "expr" var.pos=20197 var.line_nr=805
		// var "call_expr" var.pos=20218 var.line_nr=806
		// af parent scope:
		// var "p" var.pos=16962 var.line_nr=664
		// var "is_top_level" var.pos=16977 var.line_nr=664
		// af parent scope:
		// af parent scope:
		return _t2540;
	}
	else if (p->tok.kind == (v__token__Kind_key_goto)) {
		v__parser__Parser_next(p);
		v__token__Position spos = v__token__Token_position(&p->tok);
		string name = v__parser__Parser_check_name(p);
		 v__ast__Stmt _t2541 = v__ast__GotoStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__GotoStmt, ((v__ast__GotoStmt){.name = name,.pos = spos,})));
		// autofree_scope_vars(pos=20593 line_nr=823 scope.pos=20513 scope.end_pos=20651)
		// var "spos" var.pos=20540 var.line_nr=821
		// var "name" var.pos=20568 var.line_nr=822
		// af parent scope:
		// var "p" var.pos=16962 var.line_nr=664
		// var "is_top_level" var.pos=16977 var.line_nr=664
		// af parent scope:
		// af parent scope:
		return _t2541;
	}
	else if (p->tok.kind == (v__token__Kind_key_const)) {
		 v__ast__Stmt _t2542 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _SLIT("const can only be defined at the top level (outside of functions)"), v__token__Token_position(&p->tok)))));
		// autofree_scope_vars(pos=20670 line_nr=829 scope.pos=20655 scope.end_pos=20788)
		// af parent scope:
		// var "p" var.pos=16962 var.line_nr=664
		// var "is_top_level" var.pos=16977 var.line_nr=664
		// af parent scope:
		// af parent scope:
		return _t2542;
	}
	else if (p->tok.kind == (v__token__Kind_key_asm)) {
		 v__ast__Stmt _t2543 = v__ast__AsmStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__AsmStmt, (v__parser__Parser_asm_stmt(p, false))));
		// autofree_scope_vars(pos=20805 line_nr=833 scope.pos=20792 scope.end_pos=20833)
		// af parent scope:
		// var "p" var.pos=16962 var.line_nr=664
		// var "is_top_level" var.pos=16977 var.line_nr=664
		// af parent scope:
		// af parent scope:
		return _t2543;
	}
	else {
		 v__ast__Stmt _t2544 = v__parser__Parser_parse_multi_expr(p, is_top_level);
		// autofree_scope_vars(pos=20880 line_nr=837 scope.pos=20871 scope.end_pos=20923)
		// af parent scope:
		// var "p" var.pos=16962 var.line_nr=664
		// var "is_top_level" var.pos=16977 var.line_nr=664
		// af parent scope:
		// af parent scope:
		return _t2544;
	};
	return (v__ast__Stmt){0};
}

VV_LOCAL_SYMBOL v__ast__AsmStmt v__parser__Parser_asm_stmt(v__parser__Parser* p, bool is_top_level) {
bool v__parser__Parser_asm_stmt_defer_0 = false;
	p->inside_asm = true;
	p->inside_asm_template = true;
	v__parser__Parser_asm_stmt_defer_0 = true;
	p->n_asm = 0;
	if (is_top_level) {
		v__parser__Parser_top_level_statement_start(p);
	}
	v__ast__Scope* backup_scope = p->scope;
	v__token__Position pos = v__token__Token_position(&p->tok);
	v__parser__Parser_check(p, v__token__Kind_key_asm);
	Option_v__pref__Arch _t2545 = v__pref__arch_from_string(p->tok.lit);
	if (_t2545.state != 0) { /*or block*/ 
		IError err = _t2545.err;
		*(v__pref__Arch*) _t2545.data = v__pref__Arch__auto;
	}
 	v__pref__Arch arch =  *(v__pref__Arch*)_t2545.data;
	bool is_volatile = false;
	bool is_goto = false;
	if (string_eq(p->tok.lit, _SLIT("volatile")) && p->tok.kind == v__token__Kind_name) {
		Option_v__pref__Arch _t2546 = v__pref__arch_from_string(p->peek_tok.lit);
		if (_t2546.state != 0) { /*or block*/ 
			IError err = _t2546.err;
			*(v__pref__Arch*) _t2546.data = v__pref__Arch__auto;
		}
 		arch =  *(v__pref__Arch*)_t2546.data;
		is_volatile = true;
		v__parser__Parser_check(p, v__token__Kind_name);
	} else if (p->tok.kind == v__token__Kind_key_goto) {
		Option_v__pref__Arch _t2547 = v__pref__arch_from_string(p->peek_tok.lit);
		if (_t2547.state != 0) { /*or block*/ 
			IError err = _t2547.err;
			*(v__pref__Arch*) _t2547.data = v__pref__Arch__auto;
		}
 		arch =  *(v__pref__Arch*)_t2547.data;
		is_goto = true;
		v__parser__Parser_check(p, v__token__Kind_key_goto);
	}
	if (arch == v__pref__Arch__auto && !p->pref->is_fmt) {
		v__parser__Parser_error(p, _SLIT("unknown assembly architecture"));
	}
	if (p->tok.kind != v__token__Kind_name) {
		v__parser__Parser_error(p, _SLIT("must specify assembly architecture"));
	} else {
		v__parser__Parser_check(p, v__token__Kind_name);
	}
	v__parser__Parser_check_for_impure_v(p, v__ast__pref_arch_to_table_language(arch), v__token__Token_position(&p->prev_tok));
	v__parser__Parser_check(p, v__token__Kind_lcbr);
	p->scope = (v__ast__Scope*)memdup(&(v__ast__Scope){.objects = v__ast__all_registers(p->table, arch),.struct_fields = __new_array(0, 1, sizeof(v__ast__ScopeStructField)),.parent = 0,.detached_from_parent = true,.children = __new_array(0, 1, sizeof(v__ast__Scope*)),.start_pos = p->tok.pos,.end_pos = 0,}, sizeof(v__ast__Scope));
	Array_string local_labels = __new_array_with_default(0, 0, sizeof(string), 0);
	Array_v__ast__AsmTemplate templates = __new_array_with_default(0, 0, sizeof(v__ast__AsmTemplate), 0);
	for (;;) {
		if (!(!(p->tok.kind == v__token__Kind_semicolon || p->tok.kind == v__token__Kind_rcbr))) break;
		v__token__Position template_pos = v__token__Token_position(&p->tok);
		string name = _SLIT("");
		bool is_directive = p->tok.kind == v__token__Kind_dot;
		if (is_directive) {
			v__parser__Parser_check(p, v__token__Kind_dot);
		}
		if ((p->tok.kind == v__token__Kind_key_in || p->tok.kind == v__token__Kind_key_lock || p->tok.kind == v__token__Kind_key_orelse)) {
			name = v__token__Kind_str(p->tok.kind);
			v__parser__Parser_next(p);
		} else {
			name = p->tok.lit;
			v__parser__Parser_check(p, v__token__Kind_name);
		}
		if ((arch == v__pref__Arch_rv32 || arch == v__pref__Arch_rv64)) {
			for (;;) {
				if (!(p->tok.kind == v__token__Kind_dot)) break;
				name = /*f*/string_add(name, _SLIT("."));
				v__parser__Parser_check(p, v__token__Kind_dot);
				name = /*f*/string_add(name, p->tok.lit);
				v__parser__Parser_check(p, v__token__Kind_name);
			}
		}
		bool is_label = false;
		Array_v__ast__AsmArg args = __new_array_with_default(0, 0, sizeof(v__ast__AsmArg), 0);
		args_loop:
		for (;;) {

			if (p->tok.kind == (v__token__Kind_name)) {
				array_push(&args, _MOV((v__ast__AsmArg[]){ v__parser__Parser_reg_or_alias(p) }));
			}
			else if (p->tok.kind == (v__token__Kind_number)) {
				v__ast__Expr number_lit = v__parser__Parser_parse_number_literal(p);
				if (number_lit._typ == 252 /* v.ast.FloatLiteral */) {
					array_push(&args, _MOV((v__ast__AsmArg[]){ v__ast__FloatLiteral_to_sumtype_v__ast__AsmArg(ADDR(v__ast__FloatLiteral, ((v__ast__FloatLiteral){(*number_lit._v__ast__FloatLiteral).val,(*number_lit._v__ast__FloatLiteral).pos,}))) }));
				}
				else if (number_lit._typ == 259 /* v.ast.IntegerLiteral */) {
					if (is_directive) {
						array_push(&args, _MOV((v__ast__AsmArg[]){ v__ast__AsmDisp_to_sumtype_v__ast__AsmArg(ADDR(v__ast__AsmDisp, ((v__ast__AsmDisp){.val = (*number_lit._v__ast__IntegerLiteral).val,.pos = (*number_lit._v__ast__IntegerLiteral).pos,}))) }));
					} else {
						array_push(&args, _MOV((v__ast__AsmArg[]){ v__ast__IntegerLiteral_to_sumtype_v__ast__AsmArg(ADDR(v__ast__IntegerLiteral, ((v__ast__IntegerLiteral){(*number_lit._v__ast__IntegerLiteral).val,(*number_lit._v__ast__IntegerLiteral).pos,}))) }));
					}
				}
				else {
					v__parser__verror(_STR("p.parse_number_literal() invalid output: `%.*s\000`", 2, v__ast__Expr_str(number_lit)));
				};
			}
			else if (p->tok.kind == (v__token__Kind_chartoken)) {
				array_push(&args, _MOV((v__ast__AsmArg[]){ v__ast__CharLiteral_to_sumtype_v__ast__AsmArg(ADDR(v__ast__CharLiteral, ((v__ast__CharLiteral){.val = p->tok.lit,.pos = v__token__Token_position(&p->tok),}))) }));
				v__parser__Parser_check(p, v__token__Kind_chartoken);
			}
			else if (p->tok.kind == (v__token__Kind_colon)) {
				is_label = true;
				v__parser__Parser_check(p, v__token__Kind_colon);
				array_push(&local_labels, _MOV((string[]){ string_clone(name) }));
				break;
			}
			else if (p->tok.kind == (v__token__Kind_lsbr)) {
				array_push(&args, _MOV((v__ast__AsmArg[]){ v__ast__AsmAddressing_to_sumtype_v__ast__AsmArg(ADDR(v__ast__AsmAddressing, (v__parser__Parser_asm_addressing(p)))) }));
			}
			else if (p->tok.kind == (v__token__Kind_rcbr)) {
				break;
			}
			else if (p->tok.kind == (v__token__Kind_semicolon)) {
				break;
			}
			else {
				v__parser__Parser_error(p, _SLIT("invalid token in assembly block"));
			};
			if (p->tok.kind == v__token__Kind_comma) {
				v__parser__Parser_check(p, v__token__Kind_comma);
			} else {
				break;
			}
			args_loop__continue: {}
		}
		args_loop__break: {}
		Array_v__ast__Comment comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
		for (;;) {
			if (!(p->tok.kind == v__token__Kind_comment)) break;
			array_push(&comments, _MOV((v__ast__Comment[]){ v__parser__Parser_comment(p) }));
		}
		if (is_directive && (string_eq(name, _SLIT("globl")) || string_eq(name, _SLIT("global")))) {
			// FOR IN array
			for (int _t2556 = 0; _t2556 < args.len; ++_t2556) {
				v__ast__AsmArg arg = ((v__ast__AsmArg*)args.data)[_t2556];
				array_push(&p->global_labels, _MOV((string[]){ string_clone((/* as */ *(v__ast__AsmAlias*)__as_cast((arg)._v__ast__AsmAlias,(arg)._typ, 384) /*expected idx: 384, name: v.ast.AsmAlias */ ).name) }));
			}
		}
		array_push(&templates, _MOV((v__ast__AsmTemplate[]){ (v__ast__AsmTemplate){
			.name = name,
			.is_label = is_label,
			.is_directive = is_directive,
			.args = args,
			.comments = comments,
			.pos = v__token__Position_extend(template_pos, v__token__Token_position(&p->tok)),
		} }));
	}
	v__ast__Scope* scope = p->scope;
	p->scope = backup_scope;
	p->inside_asm_template = false;
	Array_v__ast__AsmIO output = __new_array_with_default(0, 0, sizeof(v__ast__AsmIO), 0);
	Array_v__ast__AsmIO input = __new_array_with_default(0, 0, sizeof(v__ast__AsmIO), 0);
	Array_v__ast__AsmClobbered clobbered = __new_array_with_default(0, 0, sizeof(v__ast__AsmClobbered), 0);
	Array_string global_labels = __new_array_with_default(0, 0, sizeof(string), 0);
	if (!is_top_level) {
		if (p->tok.kind == v__token__Kind_semicolon) {
			output = v__parser__Parser_asm_ios(p, true);
			if (p->tok.kind == v__token__Kind_semicolon) {
				input = v__parser__Parser_asm_ios(p, false);
			}
			if (p->tok.kind == v__token__Kind_semicolon) {
				backup_scope = p->scope;
				p->scope = scope;
				v__parser__Parser_check(p, v__token__Kind_semicolon);
				for (;;) {
					if (!(p->tok.kind == v__token__Kind_name)) break;
					v__ast__AsmRegister reg = (v__ast__AsmRegister){.name = p->tok.lit,.typ = 0,.size = -1,};
					v__parser__Parser_check(p, v__token__Kind_name);
					Array_v__ast__Comment comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
					for (;;) {
						if (!(p->tok.kind == v__token__Kind_comment)) break;
						array_push(&comments, _MOV((v__ast__Comment[]){ v__parser__Parser_comment(p) }));
					}
					array_push(&clobbered, _MOV((v__ast__AsmClobbered[]){ (v__ast__AsmClobbered){.reg = reg,.comments = comments,} }));
					if ((p->tok.kind == v__token__Kind_rcbr || p->tok.kind == v__token__Kind_semicolon)) {
						break;
					}
				}
				if (is_goto && p->tok.kind == v__token__Kind_semicolon) {
					v__parser__Parser_check(p, v__token__Kind_semicolon);
					for (;;) {
						if (!(p->tok.kind == v__token__Kind_name)) break;
						array_push(&global_labels, _MOV((string[]){ string_clone(p->tok.lit) }));
						v__parser__Parser_check(p, v__token__Kind_name);
					}
				}
			}
		}
	} else if (p->tok.kind == v__token__Kind_semicolon) {
		v__parser__Parser_error(p, _SLIT("extended assembly is not allowed as a top level statement"));
	}
	p->scope = backup_scope;
	v__parser__Parser_check(p, v__token__Kind_rcbr);
	if (is_top_level) {
		v__parser__Parser_top_level_statement_end(p);
	}
	scope->end_pos = p->prev_tok.pos;
	// Defer begin
	if (v__parser__Parser_asm_stmt_defer_0 == true) {
		p->inside_asm = false;
		p->inside_asm_template = false;
	}
	// Defer end
	 v__ast__AsmStmt _t2562 = (v__ast__AsmStmt){
		.arch = arch,
		.is_top_level = is_top_level,
		.is_volatile = is_volatile,
		.is_goto = is_goto,
		.clobbered = clobbered,
		.pos = v__token__Position_extend(pos, v__token__Token_position(&p->tok)),
		.templates = templates,
		.scope = scope,
		.output = output,
		.input = input,
		.global_labels = global_labels,
		.local_labels = local_labels,
	};
	// autofree_scope_vars(pos=26003 line_nr=1056 scope.pos=20934 scope.end_pos=26304)
	// var "p" var.pos=20939 var.line_nr=842
	// var "is_top_level" var.pos=20958 var.line_nr=842
	// var "backup_scope" var.pos=21181 var.line_nr=853
	// var "pos" var.pos=21207 var.line_nr=855
	// var "arch" var.pos=21256 var.line_nr=858
	// var "is_volatile" var.pos=21325 var.line_nr=859
	// var "is_goto" var.pos=21351 var.line_nr=860
	// var "local_labels" var.pos=22188 var.line_nr=889
	// var "templates" var.pos=22427 var.line_nr=893
	// var "scope" var.pos=24654 var.line_nr=1000
	// var "output" var.pos=24731 var.line_nr=1003
	// var "input" var.pos=24743 var.line_nr=1003
	// var "clobbered" var.pos=24754 var.line_nr=1003
	// var "global_labels" var.pos=24769 var.line_nr=1003
	// af parent scope:
	// af parent scope:
	return _t2562;
}

VV_LOCAL_SYMBOL v__ast__AsmArg v__parser__Parser_reg_or_alias(v__parser__Parser* p) {
	// assert
	if (!(p->tok.kind == v__token__Kind_name)) {
		VAssertMetaInfo v_assert_meta_info__t2563 = {0};
		v_assert_meta_info__t2563.fpath = _SLIT("/home/runner/work/v/v/vlib/v/parser/parser.v");
		v_assert_meta_info__t2563.line_nr = 1073;
		v_assert_meta_info__t2563.fn_name = _SLIT("reg_or_alias");
		v_assert_meta_info__t2563.src = _SLIT("p.tok.kind == .name");
		v_assert_meta_info__t2563.op = _SLIT("==");
		v_assert_meta_info__t2563.llabel = _SLIT("p.tok.kind");
		v_assert_meta_info__t2563.rlabel = _SLIT(".name");
		v_assert_meta_info__t2563.lvalue = v__token__Kind_str(p->tok.kind) /* typeof: v.ast.SelectorExpr type: 213 */ ;
		v_assert_meta_info__t2563.rvalue = _SLIT("name") /* typeof: v.ast.EnumVal type: 213 */ ;
		__print_assert_failure(&v_assert_meta_info__t2563);
		v_panic(_SLIT("Assertion failed..."));
	}
	if (_IN_MAP(ADDR(string, p->tok.lit), ADDR(map, p->scope->objects))) {
		v__ast__ScopeObject x = (*(v__ast__ScopeObject*)map_get(ADDR(map, p->scope->objects), &(string[]){p->tok.lit}, &(v__ast__ScopeObject[]){ {0} }));
		if ((x)._typ == 309 /* v.ast.AsmRegister */) {
			v__ast__AsmRegister b = (*x._v__ast__AsmRegister);
			v__parser__Parser_check(p, v__token__Kind_name);
			// autofree_scope_vars(pos=26508 line_nr=1079 scope.pos=26476 scope.end_pos=26520)
			// var "b" var.pos=26481 var.line_nr=1077
			// var "x" var.pos=26455 var.line_nr=1076
			// af parent scope:
			// var "x" var.pos=26418 var.line_nr=1075
			// af parent scope:
			// var "p" var.pos=26315 var.line_nr=1072
			// af parent scope:
			// af parent scope:
			return v__ast__AsmRegister_to_sumtype_v__ast__AsmArg(ADDR(v__ast__AsmRegister, (b)));
		} else {
			v__parser__verror(_SLIT("parser bug: non-register ast.ScopeObject found in scope"));
			 v__ast__AsmArg _t2564 = v__ast__AsmDisp_to_sumtype_v__ast__AsmArg(ADDR(v__ast__AsmDisp, ((v__ast__AsmDisp){.val = (string){.str=(byteptr)"", .is_lit=1},.pos = {0},})));
			// autofree_scope_vars(pos=26600 line_nr=1082 scope.pos=26527 scope.end_pos=26649)
			// af parent scope:
			// var "x" var.pos=26418 var.line_nr=1075
			// af parent scope:
			// var "p" var.pos=26315 var.line_nr=1072
			// af parent scope:
			// af parent scope:
			return _t2564;
		}
	} else {
		v__parser__Parser_check(p, v__token__Kind_name);
		 v__ast__AsmArg _t2565 = v__ast__AsmAlias_to_sumtype_v__ast__AsmArg(ADDR(v__ast__AsmAlias, ((v__ast__AsmAlias){.name = p->prev_tok.lit,.pos = v__token__Token_position(&p->prev_tok),})));
		// autofree_scope_vars(pos=26679 line_nr=1086 scope.pos=26659 scope.end_pos=26760)
		// af parent scope:
		// var "p" var.pos=26315 var.line_nr=1072
		// af parent scope:
		// af parent scope:
		return _t2565;
	}
	return (v__ast__AsmArg){0};
}

VV_LOCAL_SYMBOL v__ast__AsmAddressing v__parser__Parser_asm_addressing(v__parser__Parser* p) {
	v__token__Position pos = v__token__Token_position(&p->tok);
	v__parser__Parser_check(p, v__token__Kind_lsbr);
	string unknown_addressing_mode = _SLIT("unknown addressing mode. supported ones are [displacement],	[base], [base + displacement], [index ∗ scale + displacement], [base + index ∗ scale + displacement], [base + index + displacement], [rip + displacement]");
	if (p->peek_tok.kind == v__token__Kind_rsbr) {
		if (p->tok.kind == v__token__Kind_name) {
			v__ast__AsmArg base = v__parser__Parser_reg_or_alias(p);
			v__parser__Parser_check(p, v__token__Kind_rsbr);
			 v__ast__AsmAddressing _t2566 = (v__ast__AsmAddressing){.scale = -1,.mode = v__ast__AddressingMode_base,.pos = v__token__Position_extend(pos, v__token__Token_position(&p->prev_tok)),.displacement = {0},.base = base,.index = {0},};
			// autofree_scope_vars(pos=30028 line_nr=1191 scope.pos=29978 scope.end_pos=30136)
			// var "base" var.pos=29983 var.line_nr=1189
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=29475 var.line_nr=1182
			// var "pos" var.pos=29523 var.line_nr=1183
			// var "unknown_addressing_mode" var.pos=29564 var.line_nr=1185
			// str literal
			// af parent scope:
			// af parent scope:
			return _t2566;
		} else if (p->tok.kind == v__token__Kind_number) {
			v__ast__AsmArg _t2568;
			v__ast__AsmArg _t2567;
			v__ast__AsmArg displacement = (p->tok.kind == v__token__Kind_name ? (				_t2567 = string_to_sumtype_v__ast__AsmArg(ADDR(string, (p->tok.lit))),v__parser__Parser_check(p, v__token__Kind_name),_t2567) : (				_t2568 = string_to_sumtype_v__ast__AsmArg(ADDR(string, (p->tok.lit))),v__parser__Parser_check(p, v__token__Kind_number),_t2568));
			v__parser__Parser_check(p, v__token__Kind_rsbr);
			 v__ast__AsmAddressing _t2569 = (v__ast__AsmAddressing){.scale = -1,.mode = v__ast__AddressingMode_displacement,.pos = v__token__Position_extend(pos, v__token__Token_position(&p->prev_tok)),.displacement = displacement,.base = {0},.index = {0},};
			// autofree_scope_vars(pos=30365 line_nr=1207 scope.pos=30168 scope.end_pos=30497)
			// var "displacement" var.pos=30173 var.line_nr=1197
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=29475 var.line_nr=1182
			// var "pos" var.pos=29523 var.line_nr=1183
			// var "unknown_addressing_mode" var.pos=29564 var.line_nr=1185
			// str literal
			// af parent scope:
			// af parent scope:
			return _t2569;
		} else {
			v__parser__Parser_error(p, unknown_addressing_mode);
		}
	}
	if (p->peek_tok.kind == v__token__Kind_plus && p->tok.kind == v__token__Kind_name) {
		if (string_eq(p->tok.lit, _SLIT("rip"))) {
			v__ast__AsmArg rip = v__parser__Parser_reg_or_alias(p);
			v__parser__Parser_check(p, v__token__Kind_plus);
			v__ast__AsmArg _t2571;
			v__ast__AsmArg _t2570;
			v__ast__AsmArg displacement = (p->tok.kind == v__token__Kind_name ? (				_t2570 = string_to_sumtype_v__ast__AsmArg(ADDR(string, (p->tok.lit))),v__parser__Parser_check(p, v__token__Kind_name),_t2570) : (				_t2571 = string_to_sumtype_v__ast__AsmArg(ADDR(string, (p->tok.lit))),v__parser__Parser_check(p, v__token__Kind_number),_t2571));
			v__parser__Parser_check(p, v__token__Kind_rsbr);
			 v__ast__AsmAddressing _t2572 = (v__ast__AsmAddressing){.scale = -1,.mode = v__ast__AddressingMode_rip_plus_displacement,.pos = v__token__Position_extend(pos, v__token__Token_position(&p->prev_tok)),.displacement = displacement,.base = rip,.index = {0},};
			// autofree_scope_vars(pos=30991 line_nr=1231 scope.pos=30748 scope.end_pos=31146)
			// var "rip" var.pos=30753 var.line_nr=1218
			// var "displacement" var.pos=30799 var.line_nr=1221
			// af parent scope:
			// var "base" var.pos=31150 var.line_nr=1238
			// var "index" var.pos=31678 var.line_nr=1262
			// af parent scope:
			// var "p" var.pos=29475 var.line_nr=1182
			// var "pos" var.pos=29523 var.line_nr=1183
			// var "unknown_addressing_mode" var.pos=29564 var.line_nr=1185
			// str literal
			// af parent scope:
			// af parent scope:
			return _t2572;
		}
		v__ast__AsmArg base = v__parser__Parser_reg_or_alias(p);
		v__parser__Parser_check(p, v__token__Kind_plus);
		if (p->peek_tok.kind == v__token__Kind_rsbr) {
			if (p->tok.kind == v__token__Kind_number) {
				v__ast__AsmArg _t2574;
				v__ast__AsmArg _t2573;
				v__ast__AsmArg displacement = (p->tok.kind == v__token__Kind_name ? (					_t2573 = string_to_sumtype_v__ast__AsmArg(ADDR(string, (p->tok.lit))),v__parser__Parser_check(p, v__token__Kind_name),_t2573) : (					_t2574 = string_to_sumtype_v__ast__AsmArg(ADDR(string, (p->tok.lit))),v__parser__Parser_check(p, v__token__Kind_name),_t2574));
				v__parser__Parser_check(p, v__token__Kind_rsbr);
				 v__ast__AsmAddressing _t2575 = (v__ast__AsmAddressing){.scale = -1,.mode = v__ast__AddressingMode_base_plus_displacement,.pos = v__token__Position_extend(pos, v__token__Token_position(&p->prev_tok)),.displacement = displacement,.base = base,.index = {0},};
				// autofree_scope_vars(pos=31458 line_nr=1252 scope.pos=31252 scope.end_pos=31621)
				// var "displacement" var.pos=31258 var.line_nr=1242
				// af parent scope:
				// af parent scope:
				// var "base" var.pos=31150 var.line_nr=1238
				// var "index" var.pos=31678 var.line_nr=1262
				// af parent scope:
				// var "p" var.pos=29475 var.line_nr=1182
				// var "pos" var.pos=29523 var.line_nr=1183
				// var "unknown_addressing_mode" var.pos=29564 var.line_nr=1185
				// str literal
				// af parent scope:
				// af parent scope:
				return _t2575;
			} else {
				v__parser__Parser_error(p, unknown_addressing_mode);
			}
		}
		v__ast__AsmArg index = v__parser__Parser_reg_or_alias(p);
		if (p->tok.kind == v__token__Kind_mul) {
			v__parser__Parser_check(p, v__token__Kind_mul);
			int scale = string_int(p->tok.lit);
			v__parser__Parser_check(p, v__token__Kind_number);
			v__parser__Parser_check(p, v__token__Kind_plus);
			v__ast__AsmArg _t2577;
			v__ast__AsmArg _t2576;
			v__ast__AsmArg displacement = (p->tok.kind == v__token__Kind_name ? (				_t2576 = string_to_sumtype_v__ast__AsmArg(ADDR(string, (p->tok.lit))),v__parser__Parser_check(p, v__token__Kind_name),_t2576) : (				_t2577 = string_to_sumtype_v__ast__AsmArg(ADDR(string, (p->tok.lit))),v__parser__Parser_check(p, v__token__Kind_number),_t2577));
			v__parser__Parser_check(p, v__token__Kind_rsbr);
			 v__ast__AsmAddressing _t2578 = (v__ast__AsmAddressing){
				.scale = scale,
				.mode = v__ast__AddressingMode_base_plus_index_times_scale_plus_displacement,
				.pos = v__token__Position_extend(pos, v__token__Token_position(&p->prev_tok)),
				.displacement = displacement,
				.base = base,
				.index = index,
			};
			// autofree_scope_vars(pos=32008 line_nr=1278 scope.pos=31728 scope.end_pos=32222)
			// var "scale" var.pos=31750 var.line_nr=1265
			// var "displacement" var.pos=31816 var.line_nr=1268
			// af parent scope:
			// var "base" var.pos=31150 var.line_nr=1238
			// var "index" var.pos=31678 var.line_nr=1262
			// af parent scope:
			// var "p" var.pos=29475 var.line_nr=1182
			// var "pos" var.pos=29523 var.line_nr=1183
			// var "unknown_addressing_mode" var.pos=29564 var.line_nr=1185
			// str literal
			// af parent scope:
			// af parent scope:
			return _t2578;
		} else if (p->tok.kind == v__token__Kind_plus) {
			v__parser__Parser_check(p, v__token__Kind_plus);
			v__ast__AsmArg _t2580;
			v__ast__AsmArg _t2579;
			v__ast__AsmArg displacement = (p->tok.kind == v__token__Kind_name ? (				_t2579 = string_to_sumtype_v__ast__AsmArg(ADDR(string, (p->tok.lit))),v__parser__Parser_check(p, v__token__Kind_name),_t2579) : (				_t2580 = string_to_sumtype_v__ast__AsmArg(ADDR(string, (p->tok.lit))),v__parser__Parser_check(p, v__token__Kind_number),_t2580));
			v__parser__Parser_check(p, v__token__Kind_rsbr);
			 v__ast__AsmAddressing _t2581 = (v__ast__AsmAddressing){.scale = -1,.mode = v__ast__AddressingMode_base_plus_index_plus_displacement,.pos = v__token__Position_extend(pos, v__token__Token_position(&p->prev_tok)),.displacement = displacement,.base = base,.index = index,};
			// autofree_scope_vars(pos=32467 line_nr=1298 scope.pos=32252 scope.end_pos=32652)
			// var "displacement" var.pos=32275 var.line_nr=1288
			// af parent scope:
			// var "base" var.pos=31150 var.line_nr=1238
			// var "index" var.pos=31678 var.line_nr=1262
			// af parent scope:
			// var "p" var.pos=29475 var.line_nr=1182
			// var "pos" var.pos=29523 var.line_nr=1183
			// var "unknown_addressing_mode" var.pos=29564 var.line_nr=1185
			// str literal
			// af parent scope:
			// af parent scope:
			return _t2581;
		}
	}
	if (p->peek_tok.kind == v__token__Kind_mul) {
		v__ast__AsmArg index = v__parser__Parser_reg_or_alias(p);
		v__parser__Parser_check(p, v__token__Kind_mul);
		int scale = string_int(p->tok.lit);
		v__parser__Parser_check(p, v__token__Kind_number);
		v__parser__Parser_check(p, v__token__Kind_plus);
		v__ast__AsmArg _t2583;
		v__ast__AsmArg _t2582;
		v__ast__AsmArg displacement = (p->tok.kind == v__token__Kind_name ? (			_t2582 = string_to_sumtype_v__ast__AsmArg(ADDR(string, (p->tok.lit))),v__parser__Parser_check(p, v__token__Kind_name),_t2582) : (			_t2583 = string_to_sumtype_v__ast__AsmArg(ADDR(string, (p->tok.lit))),v__parser__Parser_check(p, v__token__Kind_number),_t2583));
		v__parser__Parser_check(p, v__token__Kind_rsbr);
		 v__ast__AsmAddressing _t2584 = (v__ast__AsmAddressing){.scale = scale,.mode = v__ast__AddressingMode_index_times_scale_plus_displacement,.pos = v__token__Position_extend(pos, v__token__Token_position(&p->prev_tok)),.displacement = displacement,.base = {0},.index = index,};
		// autofree_scope_vars(pos=33014 line_nr=1323 scope.pos=32685 scope.end_pos=33196)
		// var "index" var.pos=32725 var.line_nr=1308
		// var "scale" var.pos=32769 var.line_nr=1310
		// var "displacement" var.pos=32832 var.line_nr=1313
		// af parent scope:
		// var "p" var.pos=29475 var.line_nr=1182
		// var "pos" var.pos=29523 var.line_nr=1183
		// var "unknown_addressing_mode" var.pos=29564 var.line_nr=1185
		// str literal
		// af parent scope:
		// af parent scope:
		return _t2584;
	}
	v__parser__Parser_error(p, unknown_addressing_mode);
	 v__ast__AsmAddressing _t2585 = (v__ast__AsmAddressing){.scale = -1,.mode = 0,.pos = {0},.displacement = {0},.base = {0},.index = {0},};
	// autofree_scope_vars(pos=33232 line_nr=1332 scope.pos=29470 scope.end_pos=33260)
	// var "p" var.pos=29475 var.line_nr=1182
	// var "pos" var.pos=29523 var.line_nr=1183
	// var "unknown_addressing_mode" var.pos=29564 var.line_nr=1185
	// str literal
	// af parent scope:
	// af parent scope:
	return _t2585;
}

VV_LOCAL_SYMBOL Array_v__ast__AsmIO v__parser__Parser_asm_ios(v__parser__Parser* p, bool output) {
	Array_v__ast__AsmIO res = __new_array_with_default(0, 0, sizeof(v__ast__AsmIO), 0);
	v__parser__Parser_check(p, v__token__Kind_semicolon);
	if ((p->tok.kind == v__token__Kind_rcbr || p->tok.kind == v__token__Kind_semicolon)) {
		 Array_v__ast__AsmIO _t2586 = __new_array_with_default(0, 0, sizeof(v__ast__AsmIO), 0);
		// autofree_scope_vars(pos=33404 line_nr=1339 scope.pos=33401 scope.end_pos=33416)
		// af parent scope:
		// var "p" var.pos=33271 var.line_nr=1335
		// var "output" var.pos=33289 var.line_nr=1335
		// var "res" var.pos=33321 var.line_nr=1336
		// af parent scope:
		// af parent scope:
		return _t2586;
	}
	for (;;) {
		v__token__Position pos = v__token__Token_position(&p->tok);
		string constraint = _SLIT("");
		if (p->tok.kind == v__token__Kind_lpar) {
			constraint = (output ? (_SLIT("+r")) : (_SLIT("r")));
		} else {
			constraint = /*f*/string_add(constraint, ((p->tok.kind == (v__token__Kind_assign)) ? (_SLIT("=")) : (p->tok.kind == (v__token__Kind_plus)) ? (_SLIT("+")) : (p->tok.kind == (v__token__Kind_mod)) ? (_SLIT("%")) : (p->tok.kind == (v__token__Kind_amp)) ? (_SLIT("&")) : (_SLIT(""))));
			if ((constraint).len != 0) {
				v__parser__Parser_next(p);
			}
			if (p->tok.kind == v__token__Kind_assign) {
				constraint = /*f*/string_add(constraint, _SLIT("="));
				v__parser__Parser_check(p, v__token__Kind_assign);
			} else if (p->tok.kind == v__token__Kind_plus) {
				constraint = /*f*/string_add(constraint, _SLIT("+"));
				v__parser__Parser_check(p, v__token__Kind_plus);
			}
			constraint = /*f*/string_add(constraint, p->tok.lit);
			v__parser__Parser_check(p, v__token__Kind_name);
		}
		v__ast__Expr expr = v__parser__Parser_expr(p, 0);
		if ((expr)._typ == 268 /* v.ast.ParExpr */) {
			expr = (*expr._v__ast__ParExpr).expr;
		} else {
			v__parser__Parser_error(p, _STR("asm in/output must be incolsed in brackets %.*s", 1, tos3( /* v.ast.Expr */ v_typeof_sumtype_v__ast__Expr( (expr)._typ ))));
		}
		string alias = _SLIT("");
		if (p->tok.kind == v__token__Kind_key_as) {
			v__parser__Parser_check(p, v__token__Kind_key_as);
			alias = p->tok.lit;
			v__parser__Parser_check(p, v__token__Kind_name);
		} else if ((expr)._typ == 254 /* v.ast.Ident */) {
			alias = (*expr._v__ast__Ident).name;
		}
		Array_v__ast__Comment comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
		for (;;) {
			if (!(p->tok.kind == v__token__Kind_comment)) break;
			array_push(&comments, _MOV((v__ast__Comment[]){ v__parser__Parser_comment(p) }));
		}
		array_push(&res, _MOV((v__ast__AsmIO[]){ (v__ast__AsmIO){.alias = alias,.constraint = constraint,.expr = expr,.comments = comments,.typ = 0,.pos = v__token__Position_extend(pos, v__token__Token_position(&p->prev_tok)),} }));
		p->n_asm++;
		if ((p->tok.kind == v__token__Kind_semicolon || p->tok.kind == v__token__Kind_rcbr)) {
			break;
		}
	}
	// autofree_scope_vars(pos=34721 line_nr=1410 scope.pos=33266 scope.end_pos=34733)
	// var "p" var.pos=33271 var.line_nr=1335
	// var "output" var.pos=33289 var.line_nr=1335
	// var "res" var.pos=33321 var.line_nr=1336
	// af parent scope:
	// af parent scope:
	return res;
}

VV_LOCAL_SYMBOL multi_return_Array_v__ast__Expr_Array_v__ast__Comment v__parser__Parser_expr_list(v__parser__Parser* p) {
	Array_v__ast__Expr exprs = __new_array_with_default(0, 0, sizeof(v__ast__Expr), 0);
	Array_v__ast__Comment comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	for (;;) {
		v__ast__Expr expr = v__parser__Parser_expr(p, 0);
		if ((expr)._typ == 245 /* v.ast.Comment */) {
			array_push(&comments, _MOV((v__ast__Comment[]){ (*expr._v__ast__Comment) }));
		} else {
			array_push(&exprs, _MOV((v__ast__Expr[]){ expr }));
			if (p->tok.kind != v__token__Kind_comma) {
				break;
			}
			v__parser__Parser_next(p);
		}
	}
	return (multi_return_Array_v__ast__Expr_Array_v__ast__Comment){.arg0=exprs, .arg1=comments};
}

VV_LOCAL_SYMBOL void v__parser__Parser_attributes(v__parser__Parser* p) {
	v__parser__Parser_check(p, v__token__Kind_lsbr);
	bool has_ctdefine = false;
	for (;;) {
		if (!(p->tok.kind != v__token__Kind_rsbr)) break;
		v__token__Position start_pos = v__token__Token_position(&p->tok);
		v__ast__Attr attr = v__parser__Parser_parse_attr(p);
		if (Array_v__ast__Attr_contains(p->attrs, attr.name)) {
			v__parser__Parser_error_with_pos(p, _STR("duplicate attribute `%.*s\000`", 2, attr.name), v__token__Position_extend(start_pos, v__token__Token_position(&p->prev_tok)));
			return;
		}
		if (attr.is_comptime_define) {
			if (has_ctdefine) {
				v__parser__Parser_error_with_pos(p, _STR("only one `[if flag]` may be applied at a time `%.*s\000`", 2, attr.name), v__token__Position_extend(start_pos, v__token__Token_position(&p->prev_tok)));
				return;
			} else {
				has_ctdefine = true;
			}
		}
		array_push(&p->attrs, _MOV((v__ast__Attr[]){ attr }));
		if (p->tok.kind != v__token__Kind_semicolon) {
			if (p->tok.kind == v__token__Kind_rsbr) {
				v__parser__Parser_next(p);
				break;
			}
			v__parser__Parser_error(p, _STR("unexpected %.*s\000, expecting `;`", 2, v__token__Token_str(p->tok)));
			return;
		}
		v__parser__Parser_next(p);
	}
	if (p->attrs.len == 0) {
		v__parser__Parser_error_with_pos(p, _SLIT("attributes cannot be empty"), v__token__Position_extend(v__token__Token_position(&p->prev_tok), v__token__Token_position(&p->tok)));
		return;
	}
}

VV_LOCAL_SYMBOL v__ast__Attr v__parser__Parser_parse_attr(v__parser__Parser* p) {
	v__token__Position apos = v__token__Token_position(&p->prev_tok);
	if (p->tok.kind == v__token__Kind_key_unsafe) {
		v__parser__Parser_next(p);
		 v__ast__Attr _t2592 = (v__ast__Attr){.name = _SLIT("unsafe"),.is_string = 0,.is_comptime_define = 0,.arg = (string){.str=(byteptr)"", .is_lit=1},.is_string_arg = 0,.pos = v__token__Position_extend(apos, v__token__Token_position(&p->tok)),};
		// autofree_scope_vars(pos=36079 line_nr=1472 scope.pos=36065 scope.end_pos=36158)
		// af parent scope:
		// var "p" var.pos=35970 var.line_nr=1468
		// var "apos" var.pos=36005 var.line_nr=1469
		// var "is_comptime_define" var.pos=36161 var.line_nr=1477
		// var "name" var.pos=36249 var.line_nr=1481
		// var "arg" var.pos=36265 var.line_nr=1482
		// var "is_string" var.pos=36276 var.line_nr=1483
		// var "is_string_arg" var.pos=36316 var.line_nr=1484
		// af parent scope:
		// af parent scope:
		return _t2592;
	}
	bool is_comptime_define = p->tok.kind == v__token__Kind_key_if;
	if (is_comptime_define) {
		v__parser__Parser_next(p);
	}
	string name = _SLIT("");
	string arg = _SLIT("");
	bool is_string = p->tok.kind == v__token__Kind_string;
	bool is_string_arg = false;
	if (is_string) {
		name = p->tok.lit;
		v__parser__Parser_next(p);
	} else {
		name = v__parser__Parser_check_name(p);
		if (string_eq(name, _SLIT("unsafe_fn"))) {
			v__parser__Parser_error_with_pos(p, _SLIT("[unsafe_fn] is obsolete, use `[unsafe]` instead"), v__token__Position_extend(apos, v__token__Token_position(&p->tok)));
			 v__ast__Attr _t2593 = (v__ast__Attr){.name = (string){.str=(byteptr)"", .is_lit=1},.is_string = 0,.is_comptime_define = 0,.arg = (string){.str=(byteptr)"", .is_lit=1},.is_string_arg = 0,.pos = {0},};
			// autofree_scope_vars(pos=36550 line_nr=1492 scope.pos=36444 scope.end_pos=36571)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=35970 var.line_nr=1468
			// var "apos" var.pos=36005 var.line_nr=1469
			// var "is_comptime_define" var.pos=36161 var.line_nr=1477
			// var "name" var.pos=36249 var.line_nr=1481
			// str literal
			// var "arg" var.pos=36265 var.line_nr=1482
			// str literal
			// var "is_string" var.pos=36276 var.line_nr=1483
			// var "is_string_arg" var.pos=36316 var.line_nr=1484
			// af parent scope:
			// af parent scope:
			return _t2593;
		} else if (string_eq(name, _SLIT("trusted_fn"))) {
			v__parser__Parser_error_with_pos(p, _SLIT("[trusted_fn] is obsolete, use `[trusted]` instead"), v__token__Position_extend(apos, v__token__Token_position(&p->tok)));
			 v__ast__Attr _t2594 = (v__ast__Attr){.name = (string){.str=(byteptr)"", .is_lit=1},.is_string = 0,.is_comptime_define = 0,.arg = (string){.str=(byteptr)"", .is_lit=1},.is_string_arg = 0,.pos = {0},};
			// autofree_scope_vars(pos=36710 line_nr=1495 scope.pos=36602 scope.end_pos=36731)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=35970 var.line_nr=1468
			// var "apos" var.pos=36005 var.line_nr=1469
			// var "is_comptime_define" var.pos=36161 var.line_nr=1477
			// var "name" var.pos=36249 var.line_nr=1481
			// str literal
			// var "arg" var.pos=36265 var.line_nr=1482
			// str literal
			// var "is_string" var.pos=36276 var.line_nr=1483
			// var "is_string_arg" var.pos=36316 var.line_nr=1484
			// af parent scope:
			// af parent scope:
			return _t2594;
		} else if (string_eq(name, _SLIT("ref_only"))) {
			v__parser__Parser_warn_with_pos(p, _SLIT("[ref_only] is deprecated, use [heap] instead"), v__token__Position_extend(apos, v__token__Token_position(&p->tok)));
			name = _SLIT("heap");
		}
		if (p->tok.kind == v__token__Kind_colon) {
			v__parser__Parser_next(p);
			if (p->tok.kind == v__token__Kind_name) {
				arg = v__parser__Parser_check_name(p);
			} else if (p->tok.kind == v__token__Kind_string) {
				arg = p->tok.lit;
				is_string_arg = true;
				v__parser__Parser_next(p);
			}
		}
	}
	 v__ast__Attr _t2595 = (v__ast__Attr){
		.name = name,
		.is_string = is_string,
		.is_comptime_define = is_comptime_define,
		.arg = arg,
		.is_string_arg = is_string_arg,
		.pos = v__token__Position_extend(apos, v__token__Token_position(&p->tok)),
	};
	// autofree_scope_vars(pos=37116 line_nr=1512 scope.pos=35965 scope.end_pos=37293)
	// var "p" var.pos=35970 var.line_nr=1468
	// var "apos" var.pos=36005 var.line_nr=1469
	// var "is_comptime_define" var.pos=36161 var.line_nr=1477
	// var "name" var.pos=36249 var.line_nr=1481
	// str literal
	// var "arg" var.pos=36265 var.line_nr=1482
	// str literal
	// var "is_string" var.pos=36276 var.line_nr=1483
	// var "is_string_arg" var.pos=36316 var.line_nr=1484
	// af parent scope:
	// af parent scope:
	return _t2595;
}

void v__parser__Parser_check_for_impure_v(v__parser__Parser* p, v__ast__Language language, v__token__Position pos) {
	if (language == v__ast__Language_v) {
		return;
	}
	if (!p->pref->warn_impure_v) {
		return;
	}
	if (p->file_backend_mode != language) {
		string upcase_language = string_to_upper(v__ast__Language_str(language));
		if (p->file_backend_mode == v__ast__Language_v) {
			v__parser__Parser_warn_with_pos(p, _STR("%.*s\000 code will not be allowed in pure .v files, please move it to a .%.*s\000.v file instead", 3, upcase_language, v__ast__Language_str(language)), pos);
			return;
		} else {
			v__parser__Parser_warn_with_pos(p, _STR("%.*s\000 code is not allowed in .%.*s\000.v files, please move it to a .%.*s\000.v file", 4, upcase_language, v__ast__Language_str(p->file_backend_mode), v__ast__Language_str(language)), pos);
			return;
		}
	}
}

v__ast__NodeError v__parser__Parser_error(v__parser__Parser* p, string s) {
	 v__ast__NodeError _t2596 = v__parser__Parser_error_with_pos(p, s, v__token__Token_position(&p->tok));
	// autofree_scope_vars(pos=38062 line_nr=1546 scope.pos=38015 scope.end_pos=38108)
	// var "p" var.pos=38020 var.line_nr=1545
	// var "s" var.pos=38036 var.line_nr=1545
	// af parent scope:
	// af parent scope:
	return _t2596;
}

void v__parser__Parser_warn(v__parser__Parser* p, string s) {
	v__parser__Parser_warn_with_pos(p, s, v__token__Token_position(&p->tok));
}

void v__parser__Parser_note(v__parser__Parser* p, string s) {
	v__parser__Parser_note_with_pos(p, s, v__token__Token_position(&p->tok));
}

v__ast__NodeError v__parser__Parser_error_with_pos(v__parser__Parser* p, string s, v__token__Position pos) {
	if (p->pref->fatal_errors) {
		v_exit(1);
	}
	string kind = _SLIT("error:");
	if (p->pref->output_mode == v__pref__OutputMode_stdout) {
		if (p->pref->is_verbose) {
			print_backtrace();
			kind = _SLIT("parser error:");
		}
		string ferror = v__util__formatted_error(kind, s, p->file_name, pos);
		eprintln(ferror);
		v_exit(1);
	} else {
		array_push(&p->errors, _MOV((v__errors__Error[]){ (v__errors__Error){.message = s,.details = (string){.str=(byteptr)"", .is_lit=1},.file_path = p->file_name,.pos = pos,.backtrace = (string){.str=(byteptr)"", .is_lit=1},.reporter = v__errors__Reporter_parser,} }));
	}
	if (p->pref->output_mode == v__pref__OutputMode_silent) {
		v__parser__Parser_next(p);
	}
	 v__ast__NodeError _t2598 = (v__ast__NodeError){.idx = p->errors.len - 1,.pos = pos,};
	// autofree_scope_vars(pos=39174 line_nr=1585 scope.pos=38278 scope.end_pos=39235)
	// var "p" var.pos=38283 var.line_nr=1557
	// var "s" var.pos=38308 var.line_nr=1557
	// var "pos" var.pos=38318 var.line_nr=1557
	// var "kind" var.pos=38398 var.line_nr=1561
	// str literal
	// af parent scope:
	// af parent scope:
	return _t2598;
}

void v__parser__Parser_error_with_error(v__parser__Parser* p, v__errors__Error v_error) {
	if (p->pref->fatal_errors) {
		v_exit(1);
	}
	string kind = _SLIT("error:");
	if (p->pref->output_mode == v__pref__OutputMode_stdout) {
		if (p->pref->is_verbose) {
			print_backtrace();
			kind = _SLIT("parser error:");
		}
		string ferror = v__util__formatted_error(kind, v_error.message, v_error.file_path, v_error.pos);
		eprintln(ferror);
		v_exit(1);
	} else {
		array_push(&p->errors, _MOV((v__errors__Error[]){ v_error }));
	}
	if (p->pref->output_mode == v__pref__OutputMode_silent) {
		v__parser__Parser_next(p);
	}
}

void v__parser__Parser_warn_with_pos(v__parser__Parser* p, string s, v__token__Position pos) {
	if (p->pref->warns_are_errors) {
		v__parser__Parser_error_with_pos(p, s, pos);
		return;
	}
	if (p->pref->skip_warnings) {
		return;
	}
	if (p->pref->output_mode == v__pref__OutputMode_stdout) {
		string ferror = v__util__formatted_error(_SLIT("warning:"), s, p->file_name, pos);
		eprintln(ferror);
	} else {
		array_push(&p->warnings, _MOV((v__errors__Warning[]){ (v__errors__Warning){.message = s,.details = (string){.str=(byteptr)"", .is_lit=1},.file_path = p->file_name,.pos = pos,.reporter = v__errors__Reporter_parser,} }));
	}
}

void v__parser__Parser_note_with_pos(v__parser__Parser* p, string s, v__token__Position pos) {
	if (p->pref->skip_warnings) {
		return;
	}
	if (p->pref->output_mode == v__pref__OutputMode_stdout) {
		string ferror = v__util__formatted_error(_SLIT("notice:"), s, p->file_name, pos);
		eprintln(ferror);
	} else {
		array_push(&p->notices, _MOV((v__errors__Notice[]){ (v__errors__Notice){.message = s,.details = (string){.str=(byteptr)"", .is_lit=1},.file_path = p->file_name,.pos = pos,.reporter = v__errors__Reporter_parser,} }));
	}
}

void v__parser__Parser_vet_error(v__parser__Parser* p, string msg, int line, v__vet__FixKind fix, v__vet__ErrorType typ) {
	v__token__Position pos = (v__token__Position){.len = 0,.line_nr = line + 1,.pos = 0,.col = 0,.last_line = 0,};
	array_push(&p->vet_errors, _MOV((v__vet__Error[]){ (v__vet__Error){
		.kind = v__vet__ErrorKind_error,
		.message = msg,
		.details = (string){.str=(byteptr)"", .is_lit=1},
		.file_path = p->scanner->file_path,
		.pos = pos,
		.fix = fix,
		.typ = typ,
	} }));
}

VV_LOCAL_SYMBOL v__ast__Stmt v__parser__Parser_parse_multi_expr(v__parser__Parser* p, bool is_top_level) {
	v__token__Token tok = p->tok;
	v__token__Position pos = v__token__Token_position(&tok);
	multi_return_Array_v__ast__Expr_Array_v__ast__Comment mr_41402 = v__parser__Parser_expr_list(p);
	Array_v__ast__Expr left = mr_41402.arg0;
	Array_v__ast__Comment left_comments = mr_41402.arg1;
	v__ast__Expr left0 = (*(v__ast__Expr*)/*ee elem_typ */array_get(left, 0));
	if (tok.kind == v__token__Kind_key_mut && p->tok.kind != v__token__Kind_decl_assign) {
		 v__ast__Stmt _t2603 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error(p, _SLIT("expecting `:=` (e.g. `mut x :=`)")))));
		// autofree_scope_vars(pos=41495 line_nr=1678 scope.pos=41492 scope.end_pos=41548)
		// af parent scope:
		// var "p" var.pos=41108 var.line_nr=1668
		// var "is_top_level" var.pos=41135 var.line_nr=1668
		// var "tok" var.pos=41341 var.line_nr=1673
		// var "pos" var.pos=41359 var.line_nr=1674
		// var "left" var.pos=41382 var.line_nr=1675
		// var "left_comments" var.pos=41388 var.line_nr=1675
		// var "left0" var.pos=41420 var.line_nr=1676
		// af parent scope:
		// af parent scope:
		return _t2603;
	}
	if ((p->tok.kind == v__token__Kind_assign || p->tok.kind == v__token__Kind_decl_assign) || v__token__Kind_is_assign(p->tok.kind)) {
		 v__ast__Stmt _t2604 = v__parser__Parser_partial_assign_stmt(p, left, left_comments);
		// autofree_scope_vars(pos=41648 line_nr=1682 scope.pos=41645 scope.end_pos=41700)
		// af parent scope:
		// var "p" var.pos=41108 var.line_nr=1668
		// var "is_top_level" var.pos=41135 var.line_nr=1668
		// var "tok" var.pos=41341 var.line_nr=1673
		// var "pos" var.pos=41359 var.line_nr=1674
		// var "left" var.pos=41382 var.line_nr=1675
		// var "left_comments" var.pos=41388 var.line_nr=1675
		// var "left0" var.pos=41420 var.line_nr=1676
		// af parent scope:
		// af parent scope:
		return _t2604;
	} else if (!p->pref->translated && !(tok.kind == v__token__Kind_key_if || tok.kind == v__token__Kind_key_match || tok.kind == v__token__Kind_key_lock || tok.kind == v__token__Kind_key_rlock || tok.kind == v__token__Kind_key_select)) {
		// FOR IN array
		for (int _t2605 = 0; _t2605 < left.len; ++_t2605) {
			v__ast__Expr node = ((v__ast__Expr*)left.data)[_t2605];
			if ((node)._typ != 241 /* v.ast.CallExpr */ && (is_top_level || p->tok.kind != v__token__Kind_rcbr) && (node)._typ != 269 /* v.ast.PostfixExpr */ && !((node)._typ == 258 /* v.ast.InfixExpr */ && ((/* as */ *(v__ast__InfixExpr*)__as_cast((node)._v__ast__InfixExpr,(node)._typ, 258) /*expected idx: 258, name: v.ast.InfixExpr */ ).op == v__token__Kind_left_shift || (/* as */ *(v__ast__InfixExpr*)__as_cast((node)._v__ast__InfixExpr,(node)._typ, 258) /*expected idx: 258, name: v.ast.InfixExpr */ ).op == v__token__Kind_arrow)) && (node)._typ != 246 /* v.ast.ComptimeCall */ && (node)._typ != 273 /* v.ast.SelectorExpr */ && (node)._typ != 249 /* v.ast.DumpExpr */) {
				 v__ast__Stmt _t2606 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _SLIT("expression evaluated but not used"), v__ast__Expr_position(node)))));
				// autofree_scope_vars(pos=42108 line_nr=1690 scope.pos=42103 scope.end_pos=42190)
				// af parent scope:
				// var "node" var.pos=41813 var.line_nr=1685
				// skipping tmp var "node"
				// af parent scope:
				// af parent scope:
				// var "p" var.pos=41108 var.line_nr=1668
				// var "is_top_level" var.pos=41135 var.line_nr=1668
				// var "tok" var.pos=41341 var.line_nr=1673
				// var "pos" var.pos=41359 var.line_nr=1674
				// var "left" var.pos=41382 var.line_nr=1675
				// var "left_comments" var.pos=41388 var.line_nr=1675
				// var "left0" var.pos=41420 var.line_nr=1676
				// af parent scope:
				// af parent scope:
				return _t2606;
			}
		}
	}
	v__token__Position_update_last_line(&pos, p->prev_tok.line_nr);
	if (left.len == 1) {
		 v__ast__Stmt _t2607 = v__ast__ExprStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__ExprStmt, ((v__ast__ExprStmt){.expr = left0,.pos = v__ast__Expr_position(left0),.comments = left_comments,.is_expr = p->inside_for,.typ = 0,})));
		// autofree_scope_vars(pos=42262 line_nr=1696 scope.pos=42259 scope.end_pos=42381)
		// af parent scope:
		// var "p" var.pos=41108 var.line_nr=1668
		// var "is_top_level" var.pos=41135 var.line_nr=1668
		// var "tok" var.pos=41341 var.line_nr=1673
		// var "pos" var.pos=41359 var.line_nr=1674
		// var "left" var.pos=41382 var.line_nr=1675
		// var "left_comments" var.pos=41388 var.line_nr=1675
		// var "left0" var.pos=41420 var.line_nr=1676
		// af parent scope:
		// af parent scope:
		return _t2607;
	}
	 v__ast__Stmt _t2608 = v__ast__ExprStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__ExprStmt, ((v__ast__ExprStmt){.expr = v__ast__ConcatExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__ConcatExpr, ((v__ast__ConcatExpr){.vals = left,.pos = v__token__Token_position(&tok),.return_type = 0,}))),.pos = pos,.comments = left_comments,.is_expr = 0,.typ = 0,})));
	// autofree_scope_vars(pos=42383 line_nr=1703 scope.pos=41103 scope.end_pos=42510)
	// var "p" var.pos=41108 var.line_nr=1668
	// var "is_top_level" var.pos=41135 var.line_nr=1668
	// var "tok" var.pos=41341 var.line_nr=1673
	// var "pos" var.pos=41359 var.line_nr=1674
	// var "left" var.pos=41382 var.line_nr=1675
	// var "left_comments" var.pos=41388 var.line_nr=1675
	// var "left0" var.pos=41420 var.line_nr=1676
	// af parent scope:
	// af parent scope:
	return _t2608;
}

v__ast__Ident v__parser__Parser_parse_ident(v__parser__Parser* p, v__ast__Language language) {
	bool is_shared = p->tok.kind == v__token__Kind_key_shared;
	bool is_atomic = p->tok.kind == v__token__Kind_key_atomic;
	if (is_shared) {
		v__parser__Parser_register_auto_import(p, _SLIT("sync"));
	}
	v__token__Position mut_pos = v__token__Token_position(&p->tok);
	bool is_mut = p->tok.kind == v__token__Kind_key_mut || is_shared || is_atomic;
	if (is_mut) {
		v__parser__Parser_next(p);
	}
	bool is_static = p->tok.kind == v__token__Kind_key_static;
	if (is_static) {
		v__parser__Parser_next(p);
	}
	if (p->tok.kind == v__token__Kind_name) {
		v__token__Position pos = v__token__Token_position(&p->tok);
		string name = v__parser__Parser_check_name(p);
		if (string_eq(name, _SLIT("_"))) {
			 v__ast__Ident _t2609 = (v__ast__Ident){
				.language = 0,
				.tok_kind = p->tok.kind,
				.pos = pos,
				.mut_pos = {0},
				.scope = p->scope,
				.obj = {0},
				.mod = (string){.str=(byteptr)"", .is_lit=1},
				.name = _SLIT("_"),
				.kind = v__ast__IdentKind_blank_ident,
				.info = v__ast__IdentVar_to_sumtype_v__ast__IdentInfo(ADDR(v__ast__IdentVar, ((v__ast__IdentVar){.typ = 0,.is_mut = false,.is_static = false,.is_optional = 0,.share = 0,}))),
				.is_mut = 0,
			};
			// autofree_scope_vars(pos=43022 line_nr=1733 scope.pos=43018 scope.end_pos=43213)
			// af parent scope:
			// var "pos" var.pos=42948 var.line_nr=1730
			// var "name" var.pos=42978 var.line_nr=1731
			// af parent scope:
			// var "p" var.pos=42525 var.line_nr=1713
			// var "language" var.pos=42547 var.line_nr=1713
			// var "is_shared" var.pos=42603 var.line_nr=1715
			// var "is_atomic" var.pos=42643 var.line_nr=1716
			// var "mut_pos" var.pos=42735 var.line_nr=1720
			// var "is_mut" var.pos=42764 var.line_nr=1721
			// var "is_static" var.pos=42851 var.line_nr=1725
			// af parent scope:
			// af parent scope:
			return _t2609;
		}
		if (p->inside_match_body && string_eq(name, _SLIT("it"))) {
		}
		if (p->expr_mod.len > 0) {
			name = _STR("%.*s\000.%.*s", 2, p->expr_mod, name);
		}
		 v__ast__Ident _t2610 = (v__ast__Ident){
			.language = language,
			.tok_kind = p->tok.kind,
			.pos = pos,
			.mut_pos = mut_pos,
			.scope = p->scope,
			.obj = {0},
			.mod = p->mod,
			.name = name,
			.kind = v__ast__IdentKind_unresolved,
			.info = v__ast__IdentVar_to_sumtype_v__ast__IdentInfo(ADDR(v__ast__IdentVar, ((v__ast__IdentVar){.typ = 0,.is_mut = is_mut,.is_static = is_static,.is_optional = 0,.share = v__ast__sharetype_from_flags(is_shared, is_atomic),}))),
			.is_mut = is_mut,
		};
		// autofree_scope_vars(pos=43344 line_nr=1751 scope.pos=42944 scope.end_pos=43661)
		// var "pos" var.pos=42948 var.line_nr=1730
		// var "name" var.pos=42978 var.line_nr=1731
		// af parent scope:
		// var "p" var.pos=42525 var.line_nr=1713
		// var "language" var.pos=42547 var.line_nr=1713
		// var "is_shared" var.pos=42603 var.line_nr=1715
		// var "is_atomic" var.pos=42643 var.line_nr=1716
		// var "mut_pos" var.pos=42735 var.line_nr=1720
		// var "is_mut" var.pos=42764 var.line_nr=1721
		// var "is_static" var.pos=42851 var.line_nr=1725
		// af parent scope:
		// af parent scope:
		return _t2610;
	}
	v__parser__Parser_error(p, _STR("unexpected token `%.*s\000`", 2, p->tok.lit));
	 v__ast__Ident _t2611 = (v__ast__Ident){.language = 0,.tok_kind = 0,.pos = {0},.mut_pos = {0},.scope = p->scope,.obj = {0},.mod = (string){.str=(byteptr)"", .is_lit=1},.name = (string){.str=(byteptr)"", .is_lit=1},.kind = 0,.info = {0},.is_mut = 0,};
	// autofree_scope_vars(pos=43705 line_nr=1769 scope.pos=42520 scope.end_pos=43744)
	// var "p" var.pos=42525 var.line_nr=1713
	// var "language" var.pos=42547 var.line_nr=1713
	// var "is_shared" var.pos=42603 var.line_nr=1715
	// var "is_atomic" var.pos=42643 var.line_nr=1716
	// var "mut_pos" var.pos=42735 var.line_nr=1720
	// var "is_mut" var.pos=42764 var.line_nr=1721
	// var "is_static" var.pos=42851 var.line_nr=1725
	// af parent scope:
	// af parent scope:
	return _t2611;
}

VV_LOCAL_SYMBOL bool v__parser__Parser_is_typename(v__parser__Parser* p, v__token__Token t) {
	 bool _t2612 = t.kind == v__token__Kind_name && (byte_is_capital(string_at(t.lit, 0)) || v__ast__Table_known_type(p->table, t.lit));
	// autofree_scope_vars(pos=43796 line_nr=1775 scope.pos=43750 scope.end_pos=43876)
	// var "p" var.pos=43751 var.line_nr=1774
	// var "t" var.pos=43774 var.line_nr=1774
	// af parent scope:
	// af parent scope:
	return _t2612;
}

VV_LOCAL_SYMBOL bool v__parser__Parser_is_generic_call(v__parser__Parser* p) {
	bool lit0_is_capital = (p->tok.kind != v__token__Kind_eof && p->tok.lit.len > 0 ? (byte_is_capital(string_at(p->tok.lit, 0))) : (false));
	if (lit0_is_capital || p->peek_tok.kind != v__token__Kind_lt) {
		 bool _t2613 = false;
		// autofree_scope_vars(pos=44679 line_nr=1795 scope.pos=44676 scope.end_pos=44694)
		// af parent scope:
		// var "p" var.pos=44480 var.line_nr=1788
		// var "lit0_is_capital" var.pos=44517 var.line_nr=1789
		// var "tok2" var.pos=44697 var.line_nr=1797
		// var "tok3" var.pos=44722 var.line_nr=1798
		// var "tok4" var.pos=44747 var.line_nr=1799
		// var "tok5" var.pos=44772 var.line_nr=1800
		// var "kind2" var.pos=44797 var.line_nr=1801
		// var "kind3" var.pos=44804 var.line_nr=1801
		// var "kind4" var.pos=44811 var.line_nr=1801
		// var "kind5" var.pos=44818 var.line_nr=1801
		// af parent scope:
		// af parent scope:
		return _t2613;
	}
	v__token__Token tok2 = v__parser__Parser_peek_token(p, 2);
	v__token__Token tok3 = v__parser__Parser_peek_token(p, 3);
	v__token__Token tok4 = v__parser__Parser_peek_token(p, 4);
	v__token__Token tok5 = v__parser__Parser_peek_token(p, 5);
	v__token__Kind kind2 = tok2.kind;
	v__token__Kind kind3 = tok3.kind;
	v__token__Kind kind4 = tok4.kind;
	v__token__Kind kind5 = tok5.kind;
	if (kind2 == v__token__Kind_lsbr) {
		 bool _t2614 = tok3.kind == v__token__Kind_rsbr;
		// autofree_scope_vars(pos=44905 line_nr=1805 scope.pos=44890 scope.end_pos=44933)
		// af parent scope:
		// var "p" var.pos=44480 var.line_nr=1788
		// var "lit0_is_capital" var.pos=44517 var.line_nr=1789
		// var "tok2" var.pos=44697 var.line_nr=1797
		// var "tok3" var.pos=44722 var.line_nr=1798
		// var "tok4" var.pos=44747 var.line_nr=1799
		// var "tok5" var.pos=44772 var.line_nr=1800
		// var "kind2" var.pos=44797 var.line_nr=1801
		// var "kind3" var.pos=44804 var.line_nr=1801
		// var "kind4" var.pos=44811 var.line_nr=1801
		// var "kind5" var.pos=44818 var.line_nr=1801
		// af parent scope:
		// af parent scope:
		return _t2614;
	}
	if (kind2 == v__token__Kind_name) {
		if (string_eq(tok2.lit, _SLIT("map")) && kind3 == v__token__Kind_lsbr) {
			 bool _t2615 = true;
			// autofree_scope_vars(pos=45015 line_nr=1811 scope.pos=44998 scope.end_pos=45030)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=44480 var.line_nr=1788
			// var "lit0_is_capital" var.pos=44517 var.line_nr=1789
			// var "tok2" var.pos=44697 var.line_nr=1797
			// var "tok3" var.pos=44722 var.line_nr=1798
			// var "tok4" var.pos=44747 var.line_nr=1799
			// var "tok5" var.pos=44772 var.line_nr=1800
			// var "kind2" var.pos=44797 var.line_nr=1801
			// var "kind3" var.pos=44804 var.line_nr=1801
			// var "kind4" var.pos=44811 var.line_nr=1801
			// var "kind5" var.pos=44818 var.line_nr=1801
			// af parent scope:
			// af parent scope:
			return _t2615;
		}
		bool _t2617;
		
		if (kind3 == (v__token__Kind_gt) || kind3 == (v__token__Kind_lt)) {
			_t2617 = true;
		}
		else if (kind3 == (v__token__Kind_comma)) {
			_t2617 = v__parser__Parser_is_typename(p, tok2);
		}
		else if (kind3 == (v__token__Kind_dot)) {
			_t2617 = kind4 == v__token__Kind_name && (kind5 == v__token__Kind_gt || (kind5 == v__token__Kind_comma && v__parser__Parser_is_typename(p, tok4)));
		}
		else {
			_t2617 = false;
		}		 bool _t2616 = _t2617;
		// autofree_scope_vars(pos=45033 line_nr=1813 scope.pos=44955 scope.end_pos=45261)
		// af parent scope:
		// var "p" var.pos=44480 var.line_nr=1788
		// var "lit0_is_capital" var.pos=44517 var.line_nr=1789
		// var "tok2" var.pos=44697 var.line_nr=1797
		// var "tok3" var.pos=44722 var.line_nr=1798
		// var "tok4" var.pos=44747 var.line_nr=1799
		// var "tok5" var.pos=44772 var.line_nr=1800
		// var "kind2" var.pos=44797 var.line_nr=1801
		// var "kind3" var.pos=44804 var.line_nr=1801
		// var "kind4" var.pos=44811 var.line_nr=1801
		// var "kind5" var.pos=44818 var.line_nr=1801
		// af parent scope:
		// af parent scope:
		return _t2616;
	}
	 bool _t2618 = false;
	// autofree_scope_vars(pos=45263 line_nr=1821 scope.pos=44479 scope.end_pos=45277)
	// var "p" var.pos=44480 var.line_nr=1788
	// var "lit0_is_capital" var.pos=44517 var.line_nr=1789
	// var "tok2" var.pos=44697 var.line_nr=1797
	// var "tok3" var.pos=44722 var.line_nr=1798
	// var "tok4" var.pos=44747 var.line_nr=1799
	// var "tok5" var.pos=44772 var.line_nr=1800
	// var "kind2" var.pos=44797 var.line_nr=1801
	// var "kind3" var.pos=44804 var.line_nr=1801
	// var "kind4" var.pos=44811 var.line_nr=1801
	// var "kind5" var.pos=44818 var.line_nr=1801
	// af parent scope:
	// af parent scope:
	return _t2618;
}

v__ast__Expr v__parser__Parser_name_expr(v__parser__Parser* p) {
	v__token__Kind prev_tok_kind = p->prev_tok.kind;
	v__ast__Expr node = v__ast__empty_expr();
	if (p->expecting_type) {
		p->expecting_type = false;
		v__token__Position type_pos = v__token__Token_position(&p->tok);
		v__ast__Type typ = v__parser__Parser_parse_type(p);
		 v__ast__Expr _t2619 = v__ast__TypeNode_to_sumtype_v__ast__Expr(ADDR(v__ast__TypeNode, ((v__ast__TypeNode){.typ = typ,.pos = type_pos,})));
		// autofree_scope_vars(pos=45540 line_nr=1832 scope.pos=45410 scope.end_pos=45596)
		// var "type_pos" var.pos=45486 var.line_nr=1830
		// var "typ" var.pos=45517 var.line_nr=1831
		// af parent scope:
		// var "p" var.pos=45292 var.line_nr=1824
		// var "prev_tok_kind" var.pos=45326 var.line_nr=1825
		// var "node" var.pos=45364 var.line_nr=1826
		// var "language" var.pos=45603 var.line_nr=1837
		// var "mod" var.pos=45851 var.line_nr=1845
		// var "known_var" var.pos=47722 var.line_nr=1914
		// var "is_mod_cast" var.pos=47770 var.line_nr=1915
		// var "lit0_is_capital" var.pos=48696 var.line_nr=1944
		// var "is_optional" var.pos=48810 var.line_nr=1949
		// var "same_line" var.pos=48904 var.line_nr=1951
		// af parent scope:
		// af parent scope:
		return _t2619;
	}
	v__ast__Language language = v__ast__Language_v;
	if (string_eq(p->tok.lit, _SLIT("C"))) {
		language = v__ast__Language_c;
		v__parser__Parser_check_for_impure_v(p, language, v__token__Token_position(&p->tok));
	} else if (string_eq(p->tok.lit, _SLIT("JS"))) {
		language = v__ast__Language_js;
		v__parser__Parser_check_for_impure_v(p, language, v__token__Token_position(&p->tok));
	}
	string mod = _SLIT("");
	p->expr_mod = _SLIT("");
	if (string_eq(p->tok.lit, _SLIT("map")) && p->peek_tok.kind == v__token__Kind_lsbr) {
		v__ast__Type map_type = v__parser__Parser_parse_map_type(p);
		if (p->tok.kind == v__token__Kind_lcbr) {
			v__parser__Parser_next(p);
			if (p->tok.kind == v__token__Kind_rcbr) {
				v__parser__Parser_next(p);
			} else {
				v__parser__Parser_error(p, _SLIT("`}` expected; explicit `map` initialization does not support parameters"));
			}
		}
		 v__ast__Expr _t2620 = v__ast__MapInit_to_sumtype_v__ast__Expr(ADDR(v__ast__MapInit, ((v__ast__MapInit){.pos = v__token__Token_position(&p->prev_tok),.keys = __new_array(0, 1, sizeof(v__ast__Expr)),.vals = __new_array(0, 1, sizeof(v__ast__Expr)),.comments = __new_array(0, 1, sizeof(Array_v__ast__Comment)),.pre_cmnts = __new_array(0, 1, sizeof(v__ast__Comment)),.typ = map_type,.key_type = 0,.value_type = 0,})));
		// autofree_scope_vars(pos=46213 line_nr=1859 scope.pos=45989 scope.end_pos=46286)
		// var "map_type" var.pos=45993 var.line_nr=1850
		// af parent scope:
		// var "p" var.pos=45292 var.line_nr=1824
		// var "prev_tok_kind" var.pos=45326 var.line_nr=1825
		// var "node" var.pos=45364 var.line_nr=1826
		// var "language" var.pos=45603 var.line_nr=1837
		// var "mod" var.pos=45851 var.line_nr=1845
		// str literal
		// var "known_var" var.pos=47722 var.line_nr=1914
		// var "is_mod_cast" var.pos=47770 var.line_nr=1915
		// var "lit0_is_capital" var.pos=48696 var.line_nr=1944
		// var "is_optional" var.pos=48810 var.line_nr=1949
		// var "same_line" var.pos=48904 var.line_nr=1951
		// af parent scope:
		// af parent scope:
		return _t2620;
	}
	if (string_eq(p->tok.lit, _SLIT("chan"))) {
		v__token__Position first_pos = v__token__Token_position(&p->tok);
		v__token__Position last_pos = first_pos;
		v__ast__Type chan_type = v__parser__Parser_parse_chan_type(p);
		bool has_cap = false;
		v__ast__Expr cap_expr = v__ast__empty_expr();
		v__parser__Parser_check(p, v__token__Kind_lcbr);
		if (p->tok.kind == v__token__Kind_rcbr) {
			last_pos = v__token__Token_position(&p->tok);
			v__parser__Parser_next(p);
		} else {
			string key = v__parser__Parser_check_name(p);
			v__parser__Parser_check(p, v__token__Kind_colon);

			if (string_eq(key, _SLIT("cap"))) {
				has_cap = true;
				cap_expr = v__parser__Parser_expr(p, 0);
			}
			else if (string_eq(key, _SLIT("len")) || string_eq(key, _SLIT("init"))) {
				 v__ast__Expr _t2621 = v__ast__NodeError_to_sumtype_v__ast__Expr(ADDR(v__ast__NodeError, (v__parser__Parser_error(p, _STR("`%.*s\000` cannot be initialized for `chan`. Did you mean `cap`?", 2, key)))));
				// autofree_scope_vars(pos=46732 line_nr=1884 scope.pos=46712 scope.end_pos=46816)
				// af parent scope:
				// var "key" var.pos=46588 var.line_nr=1876
				// af parent scope:
				// var "first_pos" var.pos=46336 var.line_nr=1866
				// var "last_pos" var.pos=46372 var.line_nr=1867
				// var "chan_type" var.pos=46396 var.line_nr=1868
				// var "has_cap" var.pos=46435 var.line_nr=1869
				// var "cap_expr" var.pos=46458 var.line_nr=1870
				// af parent scope:
				// var "p" var.pos=45292 var.line_nr=1824
				// var "prev_tok_kind" var.pos=45326 var.line_nr=1825
				// var "node" var.pos=45364 var.line_nr=1826
				// var "language" var.pos=45603 var.line_nr=1837
				// var "mod" var.pos=45851 var.line_nr=1845
				// str literal
				// var "known_var" var.pos=47722 var.line_nr=1914
				// var "is_mod_cast" var.pos=47770 var.line_nr=1915
				// var "lit0_is_capital" var.pos=48696 var.line_nr=1944
				// var "is_optional" var.pos=48810 var.line_nr=1949
				// var "same_line" var.pos=48904 var.line_nr=1951
				// af parent scope:
				// af parent scope:
				return _t2621;
			}
			else {
				 v__ast__Expr _t2622 = v__ast__NodeError_to_sumtype_v__ast__Expr(ADDR(v__ast__NodeError, (v__parser__Parser_error(p, _STR("wrong field `%.*s\000`, expecting `cap`", 2, key)))));
				// autofree_scope_vars(pos=46833 line_nr=1887 scope.pos=46822 scope.end_pos=46892)
				// af parent scope:
				// var "key" var.pos=46588 var.line_nr=1876
				// af parent scope:
				// var "first_pos" var.pos=46336 var.line_nr=1866
				// var "last_pos" var.pos=46372 var.line_nr=1867
				// var "chan_type" var.pos=46396 var.line_nr=1868
				// var "has_cap" var.pos=46435 var.line_nr=1869
				// var "cap_expr" var.pos=46458 var.line_nr=1870
				// af parent scope:
				// var "p" var.pos=45292 var.line_nr=1824
				// var "prev_tok_kind" var.pos=45326 var.line_nr=1825
				// var "node" var.pos=45364 var.line_nr=1826
				// var "language" var.pos=45603 var.line_nr=1837
				// var "mod" var.pos=45851 var.line_nr=1845
				// str literal
				// var "known_var" var.pos=47722 var.line_nr=1914
				// var "is_mod_cast" var.pos=47770 var.line_nr=1915
				// var "lit0_is_capital" var.pos=48696 var.line_nr=1944
				// var "is_optional" var.pos=48810 var.line_nr=1949
				// var "same_line" var.pos=48904 var.line_nr=1951
				// af parent scope:
				// af parent scope:
				return _t2622;
			};
			last_pos = v__token__Token_position(&p->tok);
			v__parser__Parser_check(p, v__token__Kind_rcbr);
		}
		 v__ast__Expr _t2623 = v__ast__ChanInit_to_sumtype_v__ast__Expr(ADDR(v__ast__ChanInit, ((v__ast__ChanInit){.pos = v__token__Position_extend(first_pos, last_pos),.cap_expr = cap_expr,.has_cap = has_cap,.typ = chan_type,.elem_type = 0,})));
		// autofree_scope_vars(pos=46953 line_nr=1893 scope.pos=46332 scope.end_pos=47075)
		// var "first_pos" var.pos=46336 var.line_nr=1866
		// var "last_pos" var.pos=46372 var.line_nr=1867
		// var "chan_type" var.pos=46396 var.line_nr=1868
		// var "has_cap" var.pos=46435 var.line_nr=1869
		// var "cap_expr" var.pos=46458 var.line_nr=1870
		// af parent scope:
		// var "p" var.pos=45292 var.line_nr=1824
		// var "prev_tok_kind" var.pos=45326 var.line_nr=1825
		// var "node" var.pos=45364 var.line_nr=1826
		// var "language" var.pos=45603 var.line_nr=1837
		// var "mod" var.pos=45851 var.line_nr=1845
		// str literal
		// var "known_var" var.pos=47722 var.line_nr=1914
		// var "is_mod_cast" var.pos=47770 var.line_nr=1915
		// var "lit0_is_capital" var.pos=48696 var.line_nr=1944
		// var "is_optional" var.pos=48810 var.line_nr=1949
		// var "same_line" var.pos=48904 var.line_nr=1951
		// af parent scope:
		// af parent scope:
		return _t2623;
	}
	if (p->peek_tok.kind == v__token__Kind_string && !p->inside_str_interp && v__parser__Parser_peek_token(p, 2).kind != v__token__Kind_colon) {
		if ((string_eq(p->tok.lit, _SLIT("r")) || string_eq(p->tok.lit, _SLIT("c")) || string_eq(p->tok.lit, _SLIT("js"))) && p->tok.kind == v__token__Kind_name) {
			 v__ast__Expr _t2624 = v__parser__Parser_string_expr(p);
			// autofree_scope_vars(pos=47266 line_nr=1903 scope.pos=47262 scope.end_pos=47292)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=45292 var.line_nr=1824
			// var "prev_tok_kind" var.pos=45326 var.line_nr=1825
			// var "node" var.pos=45364 var.line_nr=1826
			// var "language" var.pos=45603 var.line_nr=1837
			// var "mod" var.pos=45851 var.line_nr=1845
			// str literal
			// var "known_var" var.pos=47722 var.line_nr=1914
			// var "is_mod_cast" var.pos=47770 var.line_nr=1915
			// var "lit0_is_capital" var.pos=48696 var.line_nr=1944
			// var "is_optional" var.pos=48810 var.line_nr=1949
			// var "same_line" var.pos=48904 var.line_nr=1951
			// af parent scope:
			// af parent scope:
			return _t2624;
		} else {
			 v__ast__Expr _t2625 = v__ast__NodeError_to_sumtype_v__ast__Expr(ADDR(v__ast__NodeError, (v__parser__Parser_error(p, _STR("only `c`, `r`, `js` are recognized string prefixes, but you tried to use `%.*s\000`", 2, p->tok.lit)))));
			// autofree_scope_vars(pos=47370 line_nr=1906 scope.pos=47299 scope.end_pos=47477)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=45292 var.line_nr=1824
			// var "prev_tok_kind" var.pos=45326 var.line_nr=1825
			// var "node" var.pos=45364 var.line_nr=1826
			// var "language" var.pos=45603 var.line_nr=1837
			// var "mod" var.pos=45851 var.line_nr=1845
			// str literal
			// var "known_var" var.pos=47722 var.line_nr=1914
			// var "is_mod_cast" var.pos=47770 var.line_nr=1915
			// var "lit0_is_capital" var.pos=48696 var.line_nr=1944
			// var "is_optional" var.pos=48810 var.line_nr=1949
			// var "same_line" var.pos=48904 var.line_nr=1951
			// af parent scope:
			// af parent scope:
			return _t2625;
		}
	}
	if ((string_eq(p->tok.lit, _SLIT("r")) || string_eq(p->tok.lit, _SLIT("c"))) && p->peek_tok.kind == v__token__Kind_chartoken) {
		string opt = (string_eq(p->tok.lit, _SLIT("r")) ? (_SLIT("`r` (raw string)")) : (_SLIT("`c` (c string)")));
		 v__ast__Expr _t2626 = v__ast__NodeError_to_sumtype_v__ast__Expr(ADDR(v__ast__NodeError, (v__parser__Parser_error(p, _STR("cannot use %.*s\000 with `byte` and `rune`", 2, opt)))));
		// autofree_scope_vars(pos=47660 line_nr=1912 scope.pos=47579 scope.end_pos=47719)
		// var "opt" var.pos=47583 var.line_nr=1911
		// af parent scope:
		// var "p" var.pos=45292 var.line_nr=1824
		// var "prev_tok_kind" var.pos=45326 var.line_nr=1825
		// var "node" var.pos=45364 var.line_nr=1826
		// var "language" var.pos=45603 var.line_nr=1837
		// var "mod" var.pos=45851 var.line_nr=1845
		// str literal
		// var "known_var" var.pos=47722 var.line_nr=1914
		// var "is_mod_cast" var.pos=47770 var.line_nr=1915
		// var "lit0_is_capital" var.pos=48696 var.line_nr=1944
		// var "is_optional" var.pos=48810 var.line_nr=1949
		// var "same_line" var.pos=48904 var.line_nr=1951
		// af parent scope:
		// af parent scope:
		return _t2626;
	}
	bool known_var = v__parser__Parser_mark_var_as_used(p, p->tok.lit);
	bool is_mod_cast = false;
	if (p->peek_tok.kind == v__token__Kind_dot && !known_var && (language != v__ast__Language_v || v__parser__Parser_known_import(p, p->tok.lit) || string_eq(string_all_after_last(p->mod, _SLIT(".")), p->tok.lit))) {
		if (language == v__ast__Language_c) {
			mod = _SLIT("C");
		} else if (language == v__ast__Language_js) {
			mod = _SLIT("JS");
		} else {
			if (_IN_MAP(ADDR(string, p->tok.lit), ADDR(map, p->imports))) {
				v__parser__Parser_register_used_import(p, p->tok.lit);
				if (p->peek_tok.kind == v__token__Kind_dot && v__parser__Parser_peek_token(p, 2).kind != v__token__Kind_eof && v__parser__Parser_peek_token(p, 2).lit.len > 0 && byte_is_capital(string_at(v__parser__Parser_peek_token(p, 2).lit, 0))) {
					is_mod_cast = true;
				} else if (p->peek_tok.kind == v__token__Kind_dot && v__parser__Parser_peek_token(p, 2).kind != v__token__Kind_eof && v__parser__Parser_peek_token(p, 2).lit.len == 0) {
					node = v__ast__Ident_to_sumtype_v__ast__Expr(ADDR(v__ast__Ident, (v__parser__Parser_parse_ident(p, language))));
					// autofree_scope_vars(pos=48558 line_nr=1934 scope.pos=48445 scope.end_pos=48575)
					// af parent scope:
					// af parent scope:
					// af parent scope:
					// af parent scope:
					// var "p" var.pos=45292 var.line_nr=1824
					// var "prev_tok_kind" var.pos=45326 var.line_nr=1825
					// var "node" var.pos=45364 var.line_nr=1826
					// var "language" var.pos=45603 var.line_nr=1837
					// var "mod" var.pos=45851 var.line_nr=1845
					// str literal
					// var "known_var" var.pos=47722 var.line_nr=1914
					// var "is_mod_cast" var.pos=47770 var.line_nr=1915
					// var "lit0_is_capital" var.pos=48696 var.line_nr=1944
					// var "is_optional" var.pos=48810 var.line_nr=1949
					// var "same_line" var.pos=48904 var.line_nr=1951
					// af parent scope:
					// af parent scope:
					return node;
				}
			}
			mod = (*(string*)map_get(ADDR(map, p->imports), &(string[]){p->tok.lit}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} }));
		}
		v__parser__Parser_next(p);
		v__parser__Parser_check(p, v__token__Kind_dot);
		p->expr_mod = mod;
	}
	bool lit0_is_capital = (p->tok.kind != v__token__Kind_eof && p->tok.lit.len > 0 ? (byte_is_capital(string_at(p->tok.lit, 0))) : (false));
	bool is_optional = p->tok.kind == v__token__Kind_question;
	bool same_line = p->tok.line_nr == p->peek_tok.line_nr;
	if (!same_line && p->peek_tok.kind == v__token__Kind_lpar) {
		node = v__ast__Ident_to_sumtype_v__ast__Expr(ADDR(v__ast__Ident, (v__parser__Parser_parse_ident(p, language))));
	} else if (p->peek_tok.kind == v__token__Kind_lpar || (is_optional && v__parser__Parser_peek_token(p, 2).kind == v__token__Kind_lpar) || v__parser__Parser_is_generic_call(p)) {
		string name = (is_optional ? (p->peek_tok.lit) : (p->tok.lit));
		if (mod.len > 0) {
			name = _STR("%.*s\000.%.*s", 2, mod, name);
		}
		string name_w_mod = v__parser__Parser_prepend_mod(p, name);
		if ((!known_var && (_IN_MAP(ADDR(string, name), ADDR(map, p->table->type_idxs)) || _IN_MAP(ADDR(string, name_w_mod), ADDR(map, p->table->type_idxs))) && !(string_eq(name, _SLIT("C.stat")) || string_eq(name, _SLIT("C.sigaction")))) || is_mod_cast || (language == v__ast__Language_v && byte_is_capital(string_at(name, 0)))) {
			v__token__Position start_pos = v__token__Token_position(&p->tok);
			v__ast__Type to_typ = v__parser__Parser_parse_type(p);
			if (p->is_amp) {
				to_typ = v__ast__Type_to_ptr(to_typ);
			}
			p->is_amp = false;
			v__parser__Parser_check(p, v__token__Kind_lpar);
			v__ast__Expr expr = v__ast__empty_expr();
			v__ast__Expr arg = v__ast__empty_expr();
			bool has_arg = false;
			expr = v__parser__Parser_expr(p, 0);
			if (p->tok.kind == v__token__Kind_comma && v__ast__Type_idx(to_typ) == _const_v__ast__string_type_idx) {
				v__parser__Parser_next(p);
				arg = v__parser__Parser_expr(p, 0);
				has_arg = true;
			}
			v__token__Position end_pos = v__token__Token_position(&p->tok);
			v__parser__Parser_check(p, v__token__Kind_rpar);
			node = v__ast__CastExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__CastExpr, ((v__ast__CastExpr){.expr = expr,.arg = arg,.typ = to_typ,.pos = v__token__Position_extend(start_pos, end_pos),.typname = (string){.str=(byteptr)"", .is_lit=1},.expr_type = 0,.has_arg = has_arg,.in_prexpr = 0,})));
			p->expr_mod = _SLIT("");
			// autofree_scope_vars(pos=50539 line_nr=2001 scope.pos=49658 scope.end_pos=50554)
			// var "start_pos" var.pos=49756 var.line_nr=1970
			// var "to_typ" var.pos=49793 var.line_nr=1971
			// var "expr" var.pos=50081 var.line_nr=1981
			// var "arg" var.pos=50113 var.line_nr=1982
			// var "has_arg" var.pos=50144 var.line_nr=1983
			// var "end_pos" var.pos=50343 var.line_nr=1991
			// af parent scope:
			// var "name" var.pos=49256 var.line_nr=1958
			// var "name_w_mod" var.pos=49367 var.line_nr=1962
			// af parent scope:
			// var "p" var.pos=45292 var.line_nr=1824
			// var "prev_tok_kind" var.pos=45326 var.line_nr=1825
			// var "node" var.pos=45364 var.line_nr=1826
			// var "language" var.pos=45603 var.line_nr=1837
			// var "mod" var.pos=45851 var.line_nr=1845
			// str literal
			// var "known_var" var.pos=47722 var.line_nr=1914
			// var "is_mod_cast" var.pos=47770 var.line_nr=1915
			// var "lit0_is_capital" var.pos=48696 var.line_nr=1944
			// var "is_optional" var.pos=48810 var.line_nr=1949
			// var "same_line" var.pos=48904 var.line_nr=1951
			// af parent scope:
			// af parent scope:
			return node;
		} else {
			if (is_optional) {
				v__parser__Parser_error_with_pos(p, _STR("unexpected %.*s", 1, v__token__Token_str(p->prev_tok)), v__token__Token_position(&p->prev_tok));
			}
			node = v__ast__CallExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__CallExpr, (v__parser__Parser_call_expr(p, language, mod))));
		}
	} else if ((p->peek_tok.kind == v__token__Kind_lcbr || (p->peek_tok.kind == v__token__Kind_lt && lit0_is_capital)) && (!p->inside_match || (p->inside_select && prev_tok_kind == v__token__Kind_arrow && lit0_is_capital)) && !p->inside_match_case && (!p->inside_if || p->inside_select) && (!p->inside_for || p->inside_select)) {
		if (p->peek_tok.kind == v__token__Kind_lcbr && !(p->builtin_mod && string_eq(p->file_base, _SLIT("map.v"))) && string_eq(p->tok.lit, _SLIT("map"))) {
			v__parser__Parser_check(p, v__token__Kind_name);
			v__parser__Parser_check(p, v__token__Kind_lcbr);
			v__ast__MapInit map_init = v__parser__Parser_map_init(p);
			v__parser__Parser_check(p, v__token__Kind_rcbr);
			// autofree_scope_vars(pos=51347 line_nr=2022 scope.pos=51231 scope.end_pos=51366)
			// var "map_init" var.pos=51302 var.line_nr=2020
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=45292 var.line_nr=1824
			// var "prev_tok_kind" var.pos=45326 var.line_nr=1825
			// var "node" var.pos=45364 var.line_nr=1826
			// var "language" var.pos=45603 var.line_nr=1837
			// var "mod" var.pos=45851 var.line_nr=1845
			// str literal
			// var "known_var" var.pos=47722 var.line_nr=1914
			// var "is_mod_cast" var.pos=47770 var.line_nr=1915
			// var "lit0_is_capital" var.pos=48696 var.line_nr=1944
			// var "is_optional" var.pos=48810 var.line_nr=1949
			// var "same_line" var.pos=48904 var.line_nr=1951
			// af parent scope:
			// af parent scope:
			return v__ast__MapInit_to_sumtype_v__ast__Expr(ADDR(v__ast__MapInit, (map_init)));
		}
		 v__ast__Expr _t2627 = v__ast__StructInit_to_sumtype_v__ast__Expr(ADDR(v__ast__StructInit, (v__parser__Parser_struct_init(p, false))));
		// autofree_scope_vars(pos=51369 line_nr=2024 scope.pos=51027 scope.end_pos=51422)
		// af parent scope:
		// var "p" var.pos=45292 var.line_nr=1824
		// var "prev_tok_kind" var.pos=45326 var.line_nr=1825
		// var "node" var.pos=45364 var.line_nr=1826
		// var "language" var.pos=45603 var.line_nr=1837
		// var "mod" var.pos=45851 var.line_nr=1845
		// str literal
		// var "known_var" var.pos=47722 var.line_nr=1914
		// var "is_mod_cast" var.pos=47770 var.line_nr=1915
		// var "lit0_is_capital" var.pos=48696 var.line_nr=1944
		// var "is_optional" var.pos=48810 var.line_nr=1949
		// var "same_line" var.pos=48904 var.line_nr=1951
		// af parent scope:
		// af parent scope:
		return _t2627;
	} else if (p->peek_tok.kind == v__token__Kind_dot && (lit0_is_capital && !known_var && language == v__ast__Language_v)) {
		if (v__parser__Parser_is_generic_name(/*rec*/*p)) {
			v__token__Position pos = v__token__Token_position(&p->tok);
			string name = v__parser__Parser_check_name(p);
			v__parser__Parser_check(p, v__token__Kind_dot);
			string field = v__parser__Parser_check_name(p);
			v__token__Position_extend(pos, v__token__Token_position(&p->tok));
			 v__ast__Expr _t2628 = v__ast__SelectorExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__SelectorExpr, ((v__ast__SelectorExpr){.pos = pos,.field_name = field,.is_mut = 0,.mut_pos = {0},.next_token = 0,.expr = v__ast__Ident_to_sumtype_v__ast__Expr(ADDR(v__ast__Ident, ((v__ast__Ident){.language = 0,.tok_kind = 0,.pos = {0},.mut_pos = {0},.scope = p->scope,.obj = {0},.mod = (string){.str=(byteptr)"", .is_lit=1},.name = name,.kind = 0,.info = {0},.is_mut = 0,}))),.expr_type = 0,.typ = 0,.name_type = 0,.scope = p->scope,.from_embed_type = 0,})));
			// autofree_scope_vars(pos=51681 line_nr=2033 scope.pos=51548 scope.end_pos=51831)
			// var "pos" var.pos=51553 var.line_nr=2028
			// var "name" var.pos=51580 var.line_nr=2029
			// var "field" var.pos=51623 var.line_nr=2031
			// af parent scope:
			// var "enum_name" var.pos=51858 var.line_nr=2044
			// var "enum_name_pos" var.pos=51888 var.line_nr=2045
			// var "val" var.pos=52170 var.line_nr=2053
			// af parent scope:
			// var "p" var.pos=45292 var.line_nr=1824
			// var "prev_tok_kind" var.pos=45326 var.line_nr=1825
			// var "node" var.pos=45364 var.line_nr=1826
			// var "language" var.pos=45603 var.line_nr=1837
			// var "mod" var.pos=45851 var.line_nr=1845
			// str literal
			// var "known_var" var.pos=47722 var.line_nr=1914
			// var "is_mod_cast" var.pos=47770 var.line_nr=1915
			// var "lit0_is_capital" var.pos=48696 var.line_nr=1944
			// var "is_optional" var.pos=48810 var.line_nr=1949
			// var "same_line" var.pos=48904 var.line_nr=1951
			// af parent scope:
			// af parent scope:
			return _t2628;
		}
		string enum_name = v__parser__Parser_check_name(p);
		v__token__Position enum_name_pos = v__token__Token_position(&p->prev_tok);
		if ((mod).len != 0) {
			enum_name = string_add(string_add(mod, _SLIT(".")), enum_name);
		} else {
			string* _t2630 = (string*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, p->imported_symbols), &(string[]){enum_name}));
			Option_string _t2629 = {0};
			if (_t2630) {
				*((string*)&_t2629.data) = *((string*)_t2630);
			} else {
				_t2629.state = 2; _t2629.err = v_error(_SLIT("array index out of range"));
			}
			;
			if (_t2629.state != 0) { /*or block*/ 
				IError err = _t2629.err;
				*(string*) _t2629.data = v__parser__Parser_prepend_mod(p, enum_name);
			}
			enum_name = *(string*)_t2629.data;
		}
		v__parser__Parser_check(p, v__token__Kind_dot);
		string val = v__parser__Parser_check_name(p);
		p->expr_mod = _SLIT("");
		 v__ast__Expr _t2631 = v__ast__EnumVal_to_sumtype_v__ast__Expr(ADDR(v__ast__EnumVal, ((v__ast__EnumVal){.enum_name = enum_name,.val = val,.mod = mod,.pos = v__token__Position_extend(enum_name_pos, v__token__Token_position(&p->prev_tok)),.typ = 0,})));
		// autofree_scope_vars(pos=52254 line_nr=2056 scope.pos=51509 scope.end_pos=52380)
		// var "enum_name" var.pos=51858 var.line_nr=2044
		// var "enum_name_pos" var.pos=51888 var.line_nr=2045
		// var "val" var.pos=52170 var.line_nr=2053
		// af parent scope:
		// var "p" var.pos=45292 var.line_nr=1824
		// var "prev_tok_kind" var.pos=45326 var.line_nr=1825
		// var "node" var.pos=45364 var.line_nr=1826
		// var "language" var.pos=45603 var.line_nr=1837
		// var "mod" var.pos=45851 var.line_nr=1845
		// str literal
		// var "known_var" var.pos=47722 var.line_nr=1914
		// var "is_mod_cast" var.pos=47770 var.line_nr=1915
		// var "lit0_is_capital" var.pos=48696 var.line_nr=1944
		// var "is_optional" var.pos=48810 var.line_nr=1949
		// var "same_line" var.pos=48904 var.line_nr=1951
		// af parent scope:
		// af parent scope:
		return _t2631;
	} else if (language == v__ast__Language_js && p->peek_tok.kind == v__token__Kind_dot && v__parser__Parser_peek_token(p, 2).kind == v__token__Kind_name) {
		node = v__ast__CallExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__CallExpr, (v__parser__Parser_call_expr(p, language, mod))));
	} else {
		node = v__ast__Ident_to_sumtype_v__ast__Expr(ADDR(v__ast__Ident, (v__parser__Parser_parse_ident(p, language))));
	}
	p->expr_mod = _SLIT("");
	// autofree_scope_vars(pos=52611 line_nr=2069 scope.pos=45287 scope.end_pos=52624)
	// var "p" var.pos=45292 var.line_nr=1824
	// var "prev_tok_kind" var.pos=45326 var.line_nr=1825
	// var "node" var.pos=45364 var.line_nr=1826
	// var "language" var.pos=45603 var.line_nr=1837
	// var "mod" var.pos=45851 var.line_nr=1845
	// str literal
	// var "known_var" var.pos=47722 var.line_nr=1914
	// var "is_mod_cast" var.pos=47770 var.line_nr=1915
	// var "lit0_is_capital" var.pos=48696 var.line_nr=1944
	// var "is_optional" var.pos=48810 var.line_nr=1949
	// var "same_line" var.pos=48904 var.line_nr=1951
	// af parent scope:
	// af parent scope:
	return node;
}

VV_LOCAL_SYMBOL v__ast__IndexExpr v__parser__Parser_index_expr(v__parser__Parser* p, v__ast__Expr left) {
	v__token__Position start_pos = v__token__Token_position(&p->tok);
	v__parser__Parser_next(p);
	bool has_low = true;
	if (p->tok.kind == v__token__Kind_dotdot) {
		has_low = false;
		v__parser__Parser_next(p);
		v__ast__Expr high = v__parser__Parser_expr(p, 0);
		v__token__Position pos = v__token__Position_extend(start_pos, v__token__Token_position(&p->tok));
		v__parser__Parser_check(p, v__token__Kind_rsbr);
		 v__ast__IndexExpr _t2632 = (v__ast__IndexExpr){.pos = pos,.index = v__ast__RangeExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__RangeExpr, ((v__ast__RangeExpr){.low = v__ast__empty_expr(),.high = high,.has_high = true,.has_low = 0,.pos = pos,}))),.or_expr = (v__ast__OrExpr){.stmts = __new_array(0, 1, sizeof(v__ast__Stmt)),},.left = left,.left_type = 0,.is_setter = 0,.is_map = 0,.is_array = 0,.is_farray = 0,.is_option = 0,};
		// autofree_scope_vars(pos=52932 line_nr=2084 scope.pos=52806 scope.end_pos=53089)
		// var "high" var.pos=52852 var.line_nr=2081
		// var "pos" var.pos=52872 var.line_nr=2082
		// af parent scope:
		// var "p" var.pos=52635 var.line_nr=2072
		// var "left" var.pos=52656 var.line_nr=2072
		// var "start_pos" var.pos=52714 var.line_nr=2074
		// var "has_low" var.pos=52764 var.line_nr=2076
		// var "expr" var.pos=53092 var.line_nr=2095
		// var "has_high" var.pos=53141 var.line_nr=2096
		// var "pos" var.pos=53576 var.line_nr=2120
		// var "or_kind" var.pos=53639 var.line_nr=2122
		// var "or_stmts" var.pos=53673 var.line_nr=2123
		// var "or_pos" var.pos=53703 var.line_nr=2124
		// af parent scope:
		// af parent scope:
		return _t2632;
	}
	v__ast__Expr expr = v__parser__Parser_expr(p, 0);
	bool has_high = false;
	if (p->tok.kind == v__token__Kind_dotdot) {
		v__parser__Parser_next(p);
		v__ast__Expr high = v__ast__empty_expr();
		if (p->tok.kind != v__token__Kind_rsbr) {
			has_high = true;
			high = v__parser__Parser_expr(p, 0);
		}
		v__token__Position pos = v__token__Position_extend(start_pos, v__token__Token_position(&p->tok));
		v__parser__Parser_check(p, v__token__Kind_rsbr);
		 v__ast__IndexExpr _t2633 = (v__ast__IndexExpr){.pos = pos,.index = v__ast__RangeExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__RangeExpr, ((v__ast__RangeExpr){.low = expr,.high = high,.has_high = has_high,.has_low = has_low,.pos = pos,}))),.or_expr = (v__ast__OrExpr){.stmts = __new_array(0, 1, sizeof(v__ast__Stmt)),},.left = left,.left_type = 0,.is_setter = 0,.is_map = 0,.is_array = 0,.is_farray = 0,.is_option = 0,};
		// autofree_scope_vars(pos=53392 line_nr=2107 scope.pos=53185 scope.end_pos=53562)
		// var "high" var.pos=53235 var.line_nr=2100
		// var "pos" var.pos=53332 var.line_nr=2105
		// af parent scope:
		// var "p" var.pos=52635 var.line_nr=2072
		// var "left" var.pos=52656 var.line_nr=2072
		// var "start_pos" var.pos=52714 var.line_nr=2074
		// var "has_low" var.pos=52764 var.line_nr=2076
		// var "expr" var.pos=53092 var.line_nr=2095
		// var "has_high" var.pos=53141 var.line_nr=2096
		// var "pos" var.pos=53576 var.line_nr=2120
		// var "or_kind" var.pos=53639 var.line_nr=2122
		// var "or_stmts" var.pos=53673 var.line_nr=2123
		// var "or_pos" var.pos=53703 var.line_nr=2124
		// af parent scope:
		// af parent scope:
		return _t2633;
	}
	v__token__Position pos = v__token__Position_extend(start_pos, v__token__Token_position(&p->tok));
	v__parser__Parser_check(p, v__token__Kind_rsbr);
	v__ast__OrKind or_kind = v__ast__OrKind_absent;
	Array_v__ast__Stmt or_stmts = __new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
	v__token__Position or_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,};
	if (!p->or_is_handled) {
		if (p->tok.kind == v__token__Kind_key_orelse) {
			bool was_inside_or_expr = p->inside_or_expr;
			or_pos = v__token__Token_position(&p->tok);
			v__parser__Parser_next(p);
			v__parser__Parser_open_scope(p);
			or_stmts = v__parser__Parser_parse_block_no_scope(p, false);
			or_pos = v__token__Position_extend(or_pos, v__token__Token_position(&p->prev_tok));
			v__parser__Parser_close_scope(p);
			p->inside_or_expr = was_inside_or_expr;
			 v__ast__IndexExpr _t2634 = (v__ast__IndexExpr){.pos = pos,.index = expr,.or_expr = (v__ast__OrExpr){.stmts = or_stmts,.kind = v__ast__OrKind_block,.pos = or_pos,},.left = left,.left_type = 0,.is_setter = 0,.is_map = 0,.is_array = 0,.is_farray = 0,.is_option = 0,};
			// autofree_scope_vars(pos=54063 line_nr=2136 scope.pos=53805 scope.end_pos=54224)
			// var "was_inside_or_expr" var.pos=53810 var.line_nr=2128
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=52635 var.line_nr=2072
			// var "left" var.pos=52656 var.line_nr=2072
			// var "start_pos" var.pos=52714 var.line_nr=2074
			// var "has_low" var.pos=52764 var.line_nr=2076
			// var "expr" var.pos=53092 var.line_nr=2095
			// var "has_high" var.pos=53141 var.line_nr=2096
			// var "pos" var.pos=53576 var.line_nr=2120
			// var "or_kind" var.pos=53639 var.line_nr=2122
			// var "or_stmts" var.pos=53673 var.line_nr=2123
			// var "or_pos" var.pos=53703 var.line_nr=2124
			// af parent scope:
			// af parent scope:
			return _t2634;
		}
		if (p->tok.kind == v__token__Kind_question) {
			or_pos = v__token__Token_position(&p->tok);
			or_kind = v__ast__OrKind_propagate;
			v__parser__Parser_next(p);
		}
	}
	 v__ast__IndexExpr _t2635 = (v__ast__IndexExpr){.pos = pos,.index = expr,.or_expr = (v__ast__OrExpr){.stmts = or_stmts,.kind = or_kind,.pos = or_pos,},.left = left,.left_type = 0,.is_setter = 0,.is_map = 0,.is_array = 0,.is_farray = 0,.is_option = 0,};
	// autofree_scope_vars(pos=54343 line_nr=2154 scope.pos=52630 scope.end_pos=54485)
	// var "p" var.pos=52635 var.line_nr=2072
	// var "left" var.pos=52656 var.line_nr=2072
	// var "start_pos" var.pos=52714 var.line_nr=2074
	// var "has_low" var.pos=52764 var.line_nr=2076
	// var "expr" var.pos=53092 var.line_nr=2095
	// var "has_high" var.pos=53141 var.line_nr=2096
	// var "pos" var.pos=53576 var.line_nr=2120
	// var "or_kind" var.pos=53639 var.line_nr=2122
	// var "or_stmts" var.pos=53673 var.line_nr=2123
	// var "or_pos" var.pos=53703 var.line_nr=2124
	// af parent scope:
	// af parent scope:
	return _t2635;
}

VV_LOCAL_SYMBOL void v__parser__Parser_scope_register_it(v__parser__Parser* p) {
	v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){.name = _SLIT("it"),.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.is_auto_deref = 0,.typ = 0,.orig_type = 0,.smartcasts = __new_array(0, 1, sizeof(v__ast__Type)),.pos = v__token__Token_position(&p->tok),.is_used = true,.is_changed = 0,.is_or = 0,.is_tmp = 0,}))));
}

VV_LOCAL_SYMBOL void v__parser__Parser_scope_register_ab(v__parser__Parser* p) {
	v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){.name = _SLIT("a"),.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.is_auto_deref = 0,.typ = 0,.orig_type = 0,.smartcasts = __new_array(0, 1, sizeof(v__ast__Type)),.pos = v__token__Token_position(&p->tok),.is_used = true,.is_changed = 0,.is_or = 0,.is_tmp = 0,}))));
	v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){.name = _SLIT("b"),.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.is_auto_deref = 0,.typ = 0,.orig_type = 0,.smartcasts = __new_array(0, 1, sizeof(v__ast__Type)),.pos = v__token__Token_position(&p->tok),.is_used = true,.is_changed = 0,.is_or = 0,.is_tmp = 0,}))));
}

VV_LOCAL_SYMBOL v__ast__Expr v__parser__Parser_dot_expr(v__parser__Parser* p, v__ast__Expr left) {
	v__parser__Parser_next(p);
	if (p->tok.kind == v__token__Kind_dollar) {
		 v__ast__Expr _t2636 = v__parser__Parser_comptime_selector(p, left);
		// autofree_scope_vars(pos=54916 line_nr=2190 scope.pos=54913 scope.end_pos=54951)
		// af parent scope:
		// var "p" var.pos=54832 var.line_nr=2187
		// var "left" var.pos=54851 var.line_nr=2187
		// var "is_generic_call" var.pos=54954 var.line_nr=2192
		// var "name_pos" var.pos=54994 var.line_nr=2193
		// var "field_name" var.pos=55028 var.line_nr=2194
		// var "is_filter" var.pos=55245 var.line_nr=2201
		// var "generic_types" var.pos=55511 var.line_nr=2211
		// var "generic_list_pos" var.pos=55546 var.line_nr=2212
		// var "is_mut" var.pos=57142 var.line_nr=2277
		// var "mut_pos" var.pos=57163 var.line_nr=2278
		// var "pos" var.pos=57356 var.line_nr=2288
		// var "sel_expr" var.pos=57435 var.line_nr=2289
		// af parent scope:
		// af parent scope:
		return _t2636;
	}
	bool is_generic_call = v__parser__Parser_is_generic_call(p);
	v__token__Position name_pos = v__token__Token_position(&p->tok);
	string field_name = _SLIT("");
	if ((v__token__Token_position(&p->prev_tok).line_nr == name_pos.line_nr) || p->tok.kind != v__token__Kind_name) {
		field_name = v__parser__Parser_check_name(p);
	} else {
		p->name_error = true;
	}
	bool is_filter = (string_eq(field_name, _SLIT("filter")) || string_eq(field_name, _SLIT("map")) || string_eq(field_name, _SLIT("any")) || string_eq(field_name, _SLIT("all")));
	if (is_filter || string_eq(field_name, _SLIT("sort"))) {
		v__parser__Parser_open_scope(p);
	}
	if (p->tok.kind == v__token__Kind_not && p->peek_tok.kind == v__token__Kind_lpar) {
		v__parser__Parser_next(p);
	}
	Array_v__ast__Type generic_types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
	v__token__Position generic_list_pos = v__token__Token_position(&p->tok);
	if (is_generic_call) {
		generic_types = v__parser__Parser_parse_generic_type_list(p);
		generic_list_pos = v__token__Position_extend(generic_list_pos, v__token__Token_position(&p->prev_tok));
		Array_v__ast__Type _t2637_orig = generic_types;
		int _t2637_len = _t2637_orig.len;
		Array_v__ast__Type _t2637 = __new_array(0, _t2637_len, sizeof(v__ast__Type));

		for (int _t2638 = 0; _t2638 < _t2637_len; ++_t2638) {
			v__ast__Type it = ((v__ast__Type*) _t2637_orig.data)[_t2638];
			if (v__ast__Type_has_flag(it, v__ast__TypeFlag_generic)) {
				array_push(&_t2637, &it); 
		}
		}
		
		bool has_generic_generic = _t2637.len > 0;
		if (!has_generic_generic) {
			v__ast__Table_register_fn_gen_type(p->table, field_name, generic_types);
		}
	}
	if (p->tok.kind == v__token__Kind_lpar) {
		v__parser__Parser_next(p);
		Array_v__ast__CallArg args = v__parser__Parser_call_args(p);
		v__parser__Parser_check(p, v__token__Kind_rpar);
		Array_v__ast__Stmt or_stmts = __new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
		v__ast__OrKind or_kind = v__ast__OrKind_absent;
		v__token__Position or_pos = v__token__Token_position(&p->tok);
		if (p->tok.kind == v__token__Kind_key_orelse) {
			v__parser__Parser_next(p);
			v__parser__Parser_open_scope(p);
			v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){.name = _SLIT("err"),.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.is_auto_deref = 0,.typ = _const_v__ast__error_type,.orig_type = 0,.smartcasts = __new_array(0, 1, sizeof(v__ast__Type)),.pos = v__token__Token_position(&p->tok),.is_used = true,.is_changed = 0,.is_or = 0,.is_tmp = 0,}))));
			or_kind = v__ast__OrKind_block;
			or_stmts = v__parser__Parser_parse_block_no_scope(p, false);
			or_pos = v__token__Position_extend(or_pos, v__token__Token_position(&p->prev_tok));
			v__parser__Parser_close_scope(p);
		}
		if (p->tok.kind == v__token__Kind_question) {
			v__parser__Parser_next(p);
			or_kind = v__ast__OrKind_propagate;
		}
		v__token__Position end_pos = v__token__Token_position(&p->prev_tok);
		v__token__Position pos = v__token__Position_extend(name_pos, end_pos);
		Array_v__ast__Comment comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = true,.follow_up = 0,});
		v__ast__CallExpr mcall_expr = (v__ast__CallExpr){
			.pos = pos,
			.name_pos = name_pos,
			.mod = (string){.str=(byteptr)"", .is_lit=1},
			.name = field_name,
			.is_method = true,
			.is_field = 0,
			.is_keep_alive = 0,
			.args = args,
			.expected_arg_types = __new_array(0, 1, sizeof(v__ast__Type)),
			.language = 0,
			.or_block = (v__ast__OrExpr){.stmts = or_stmts,.kind = or_kind,.pos = or_pos,},
			.left = left,
			.left_type = 0,
			.receiver_type = 0,
			.return_type = 0,
			.should_be_skipped = 0,
			.generic_types = generic_types,
			.generic_list_pos = generic_list_pos,
			.free_receiver = 0,
			.scope = p->scope,
			.from_embed_type = 0,
			.comments = comments,
		};
		if (is_filter || string_eq(field_name, _SLIT("sort"))) {
			v__parser__Parser_close_scope(p);
		}
		// autofree_scope_vars(pos=57115 line_nr=2275 scope.pos=56045 scope.end_pos=57135)
		// var "args" var.pos=56060 var.line_nr=2227
		// var "or_stmts" var.pos=56105 var.line_nr=2229
		// var "or_kind" var.pos=56136 var.line_nr=2230
		// var "or_pos" var.pos=56171 var.line_nr=2231
		// var "end_pos" var.pos=56608 var.line_nr=2252
		// var "pos" var.pos=56643 var.line_nr=2253
		// var "comments" var.pos=56677 var.line_nr=2254
		// var "mcall_expr" var.pos=56723 var.line_nr=2255
		// af parent scope:
		// var "p" var.pos=54832 var.line_nr=2187
		// var "left" var.pos=54851 var.line_nr=2187
		// var "is_generic_call" var.pos=54954 var.line_nr=2192
		// var "name_pos" var.pos=54994 var.line_nr=2193
		// var "field_name" var.pos=55028 var.line_nr=2194
		// str literal
		// var "is_filter" var.pos=55245 var.line_nr=2201
		// var "generic_types" var.pos=55511 var.line_nr=2211
		// var "generic_list_pos" var.pos=55546 var.line_nr=2212
		// var "is_mut" var.pos=57142 var.line_nr=2277
		// var "mut_pos" var.pos=57163 var.line_nr=2278
		// var "pos" var.pos=57356 var.line_nr=2288
		// var "sel_expr" var.pos=57435 var.line_nr=2289
		// af parent scope:
		// af parent scope:
		return v__ast__CallExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__CallExpr, (mcall_expr)));
	}
	bool is_mut = false;
	v__token__Position mut_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,};
	if (p->inside_match || p->inside_if_expr) {
		if (left._typ == 254 /* v.ast.Ident */) {
			is_mut = (*left._v__ast__Ident).is_mut;
			mut_pos = (*left._v__ast__Ident).mut_pos;
		}
		else if (left._typ == 273 /* v.ast.SelectorExpr */) {
			is_mut = (*left._v__ast__SelectorExpr).is_mut;
			mut_pos = (*left._v__ast__SelectorExpr).mut_pos;
		}
		else {
		};
	}
	v__token__Position pos = (p->name_error ? (v__token__Position_extend(v__ast__Expr_position(left), name_pos)) : (name_pos));
	v__ast__SelectorExpr sel_expr = (v__ast__SelectorExpr){
		.pos = pos,
		.field_name = field_name,
		.is_mut = is_mut,
		.mut_pos = mut_pos,
		.next_token = p->tok.kind,
		.expr = left,
		.expr_type = 0,
		.typ = 0,
		.name_type = 0,
		.scope = p->scope,
		.from_embed_type = 0,
	};
	if (is_filter) {
		v__parser__Parser_close_scope(p);
	}
	// autofree_scope_vars(pos=57632 line_nr=2301 scope.pos=54827 scope.end_pos=57649)
	// var "p" var.pos=54832 var.line_nr=2187
	// var "left" var.pos=54851 var.line_nr=2187
	// var "is_generic_call" var.pos=54954 var.line_nr=2192
	// var "name_pos" var.pos=54994 var.line_nr=2193
	// var "field_name" var.pos=55028 var.line_nr=2194
	// str literal
	// var "is_filter" var.pos=55245 var.line_nr=2201
	// var "generic_types" var.pos=55511 var.line_nr=2211
	// var "generic_list_pos" var.pos=55546 var.line_nr=2212
	// var "is_mut" var.pos=57142 var.line_nr=2277
	// var "mut_pos" var.pos=57163 var.line_nr=2278
	// var "pos" var.pos=57356 var.line_nr=2288
	// var "sel_expr" var.pos=57435 var.line_nr=2289
	// af parent scope:
	// af parent scope:
	return v__ast__SelectorExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__SelectorExpr, (sel_expr)));
}

VV_LOCAL_SYMBOL Array_v__ast__Type v__parser__Parser_parse_generic_type_list(v__parser__Parser* p) {
	Array_v__ast__Type types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
	if (p->tok.kind != v__token__Kind_lt) {
		// autofree_scope_vars(pos=57761 line_nr=2307 scope.pos=57758 scope.end_pos=57776)
		// af parent scope:
		// var "p" var.pos=57660 var.line_nr=2304
		// var "types" var.pos=57714 var.line_nr=2305
		// var "first_done" var.pos=57800 var.line_nr=2310
		// af parent scope:
		// af parent scope:
		return types;
	}
	v__parser__Parser_next(p);
	bool first_done = false;
	for (;;) {
		if (!(!(p->tok.kind == v__token__Kind_eof || p->tok.kind == v__token__Kind_gt))) break;
		if (first_done) {
			v__parser__Parser_check(p, v__token__Kind_comma);
		}
		array_push(&types, _MOV((v__ast__Type[]){ v__parser__Parser_parse_type(p) }));
		first_done = true;
	}
	v__parser__Parser_check(p, v__token__Kind_gt);
	// autofree_scope_vars(pos=57965 line_nr=2319 scope.pos=57655 scope.end_pos=57979)
	// var "p" var.pos=57660 var.line_nr=2304
	// var "types" var.pos=57714 var.line_nr=2305
	// var "first_done" var.pos=57800 var.line_nr=2310
	// af parent scope:
	// af parent scope:
	return types;
}

VV_LOCAL_SYMBOL v__ast__EnumVal v__parser__Parser_enum_val(v__parser__Parser* p) {
	v__token__Position start_pos = v__token__Token_position(&p->tok);
	v__parser__Parser_check(p, v__token__Kind_dot);
	string val = v__parser__Parser_check_name(p);
	 v__ast__EnumVal _t2640 = (v__ast__EnumVal){.enum_name = (string){.str=(byteptr)"", .is_lit=1},.val = val,.mod = (string){.str=(byteptr)"", .is_lit=1},.pos = v__token__Position_extend(start_pos, v__token__Token_position(&p->prev_tok)),.typ = 0,};
	// autofree_scope_vars(pos=58139 line_nr=2328 scope.pos=58030 scope.end_pos=58221)
	// var "p" var.pos=58035 var.line_nr=2324
	// var "start_pos" var.pos=58071 var.line_nr=2325
	// var "val" var.pos=58117 var.line_nr=2327
	// af parent scope:
	// af parent scope:
	return _t2640;
}

VV_LOCAL_SYMBOL v__ast__Expr v__parser__Parser_string_expr(v__parser__Parser* p) {
	bool is_raw = p->tok.kind == v__token__Kind_name && string_eq(p->tok.lit, _SLIT("r"));
	bool is_cstr = p->tok.kind == v__token__Kind_name && string_eq(p->tok.lit, _SLIT("c"));
	if (is_raw || is_cstr) {
		v__parser__Parser_next(p);
	}
	v__ast__Expr node = v__ast__empty_expr();
	string val = p->tok.lit;
	v__token__Position pos = v__token__Token_position(&p->tok);
	pos.last_line = pos.line_nr + string_count(val, _SLIT("\n"));
	if (p->peek_tok.kind != v__token__Kind_str_dollar) {
		v__parser__Parser_next(p);
		if (p->vet_errors.len > 0) {
			Array_v__vet__Error _t2641_orig = p->vet_errors;
			int _t2641_len = _t2641_orig.len;
			Array_v__vet__Error _t2641 = __new_array(0, _t2641_len, sizeof(v__vet__Error));

			for (int _t2642 = 0; _t2642 < _t2641_len; ++_t2642) {
				v__vet__Error it = ((v__vet__Error*) _t2641_orig.data)[_t2642];
				if ((it.typ == v__vet__ErrorType_trailing_space && it.pos.line_nr - 1 >= pos.last_line) || (it.typ != v__vet__ErrorType_trailing_space && it.pos.line_nr - 1 > pos.last_line) || (it.typ == v__vet__ErrorType_space_indent && it.pos.line_nr - 1 <= pos.line_nr) || (it.typ != v__vet__ErrorType_space_indent && it.pos.line_nr - 1 < pos.line_nr)) {
					array_push(&_t2641, &it); 
		}
			}
			
			p->vet_errors = _t2641;
		}
		node = v__ast__StringLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__StringLiteral, ((v__ast__StringLiteral){.val = val,.is_raw = is_raw,.language = (is_cstr ? (v__ast__Language_c) : (v__ast__Language_v)),.pos = pos,})));
		// autofree_scope_vars(pos=59134 line_nr=2360 scope.pos=58567 scope.end_pos=59148)
		// af parent scope:
		// var "p" var.pos=58232 var.line_nr=2334
		// var "is_raw" var.pos=58268 var.line_nr=2335
		// var "is_cstr" var.pos=58319 var.line_nr=2336
		// var "node" var.pos=58413 var.line_nr=2340
		// var "val" var.pos=58439 var.line_nr=2341
		// var "pos" var.pos=58461 var.line_nr=2342
		// var "exprs" var.pos=59155 var.line_nr=2362
		// var "vals" var.pos=59182 var.line_nr=2363
		// var "has_fmts" var.pos=59206 var.line_nr=2364
		// var "fwidths" var.pos=59232 var.line_nr=2365
		// var "precisions" var.pos=59256 var.line_nr=2366
		// var "visible_pluss" var.pos=59283 var.line_nr=2367
		// var "fills" var.pos=59314 var.line_nr=2368
		// var "fmts" var.pos=59337 var.line_nr=2369
		// var "fposs" var.pos=59359 var.line_nr=2370
		// af parent scope:
		// af parent scope:
		return node;
	}
	Array_v__ast__Expr exprs = __new_array_with_default(0, 0, sizeof(v__ast__Expr), 0);
	Array_string vals = __new_array_with_default(0, 0, sizeof(string), 0);
	Array_bool has_fmts = __new_array_with_default(0, 0, sizeof(bool), 0);
	Array_int fwidths = __new_array_with_default(0, 0, sizeof(int), 0);
	Array_int precisions = __new_array_with_default(0, 0, sizeof(int), 0);
	Array_bool visible_pluss = __new_array_with_default(0, 0, sizeof(bool), 0);
	Array_bool fills = __new_array_with_default(0, 0, sizeof(bool), 0);
	Array_byte fmts = __new_array_with_default(0, 0, sizeof(byte), 0);
	Array_v__token__Position fposs = __new_array_with_default(0, 0, sizeof(v__token__Position), 0);
	p->inside_str_interp = true;
	for (;;) {
		if (!(p->tok.kind == v__token__Kind_string)) break;
		array_push(&vals, _MOV((string[]){ string_clone(p->tok.lit) }));
		v__parser__Parser_next(p);
		if (p->tok.kind != v__token__Kind_str_dollar) {
			break;
		}
		v__parser__Parser_next(p);
		array_push(&exprs, _MOV((v__ast__Expr[]){ v__parser__Parser_expr(p, 0) }));
		bool has_fmt = false;
		int fwidth = 0;
		bool fwidthneg = false;
		int precision = 987698;
		bool visible_plus = false;
		bool fill = false;
		rune fmt = L'_';
		if (p->tok.kind == v__token__Kind_colon) {
			v__parser__Parser_next(p);
			if (p->tok.kind == v__token__Kind_minus) {
				fwidthneg = true;
				v__parser__Parser_next(p);
			} else if (p->tok.kind == v__token__Kind_plus) {
				visible_plus = true;
				v__parser__Parser_next(p);
			}
			if (p->tok.kind == v__token__Kind_number) {
				Array_string fields = string_split(p->tok.lit, _SLIT("."));
				if ((*(string*)/*ee elem_typ */array_get(fields, 0)).len > 0 && string_at((*(string*)/*ee elem_typ */array_get(fields, 0)), 0) == L'0') {
					fill = true;
				}
				fwidth = string_int((*(string*)/*ee elem_typ */array_get(fields, 0)));
				if (fwidthneg) {
					fwidth = -fwidth;
				}
				if (fields.len > 1) {
					precision = string_int((*(string*)/*ee elem_typ */array_get(fields, 1)));
				}
				v__parser__Parser_next(p);
			}
			if (p->tok.kind == v__token__Kind_name) {
				if (p->tok.lit.len == 1) {
					fmt = string_at(p->tok.lit, 0);
					has_fmt = true;
					v__parser__Parser_next(p);
				} else {
					 v__ast__Expr _t2645 = v__ast__NodeError_to_sumtype_v__ast__Expr(ADDR(v__ast__NodeError, (v__parser__Parser_error(p, _SLIT("format specifier may only be one letter")))));
					// autofree_scope_vars(pos=60492 line_nr=2420 scope.pos=60486 scope.end_pos=60555)
					// af parent scope:
					// af parent scope:
					// af parent scope:
					// var "has_fmt" var.pos=59586 var.line_nr=2381
					// var "fwidth" var.pos=59609 var.line_nr=2382
					// var "fwidthneg" var.pos=59627 var.line_nr=2383
					// var "precision" var.pos=59753 var.line_nr=2385
					// var "visible_plus" var.pos=59779 var.line_nr=2386
					// var "fill" var.pos=59807 var.line_nr=2387
					// var "fmt" var.pos=59827 var.line_nr=2388
					// af parent scope:
					// af parent scope:
					// var "p" var.pos=58232 var.line_nr=2334
					// var "is_raw" var.pos=58268 var.line_nr=2335
					// var "is_cstr" var.pos=58319 var.line_nr=2336
					// var "node" var.pos=58413 var.line_nr=2340
					// var "val" var.pos=58439 var.line_nr=2341
					// var "pos" var.pos=58461 var.line_nr=2342
					// var "exprs" var.pos=59155 var.line_nr=2362
					// var "vals" var.pos=59182 var.line_nr=2363
					// var "has_fmts" var.pos=59206 var.line_nr=2364
					// var "fwidths" var.pos=59232 var.line_nr=2365
					// var "precisions" var.pos=59256 var.line_nr=2366
					// var "visible_pluss" var.pos=59283 var.line_nr=2367
					// var "fills" var.pos=59314 var.line_nr=2368
					// var "fmts" var.pos=59337 var.line_nr=2369
					// var "fposs" var.pos=59359 var.line_nr=2370
					// af parent scope:
					// af parent scope:
					return _t2645;
				}
			}
		}
		array_push(&fwidths, _MOV((int[]){ fwidth }));
		array_push(&has_fmts, _MOV((bool[]){ has_fmt }));
		array_push(&precisions, _MOV((int[]){ precision }));
		array_push(&visible_pluss, _MOV((bool[]){ visible_plus }));
		array_push(&fmts, _MOV((byte[]){ fmt }));
		array_push(&fills, _MOV((bool[]){ fill }));
		array_push(&fposs, _MOV((v__token__Position[]){ v__token__Token_position(&p->prev_tok) }));
	}
	node = v__ast__StringInterLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__StringInterLiteral, ((v__ast__StringInterLiteral){
		.vals = vals,
		.exprs = exprs,
		.fwidths = fwidths,
		.precisions = precisions,
		.pluss = visible_pluss,
		.fills = fills,
		.fmt_poss = fposs,
		.pos = v__token__Position_extend(pos, v__token__Token_position(&p->prev_tok)),
		.expr_types = __new_array(0, 1, sizeof(v__ast__Type)),
		.fmts = fmts,
		.need_fmts = has_fmts,
	})));
	p->inside_str_interp = false;
	// autofree_scope_vars(pos=61068 line_nr=2446 scope.pos=58227 scope.end_pos=61081)
	// var "p" var.pos=58232 var.line_nr=2334
	// var "is_raw" var.pos=58268 var.line_nr=2335
	// var "is_cstr" var.pos=58319 var.line_nr=2336
	// var "node" var.pos=58413 var.line_nr=2340
	// var "val" var.pos=58439 var.line_nr=2341
	// var "pos" var.pos=58461 var.line_nr=2342
	// var "exprs" var.pos=59155 var.line_nr=2362
	// var "vals" var.pos=59182 var.line_nr=2363
	// var "has_fmts" var.pos=59206 var.line_nr=2364
	// var "fwidths" var.pos=59232 var.line_nr=2365
	// var "precisions" var.pos=59256 var.line_nr=2366
	// var "visible_pluss" var.pos=59283 var.line_nr=2367
	// var "fills" var.pos=59314 var.line_nr=2368
	// var "fmts" var.pos=59337 var.line_nr=2369
	// var "fposs" var.pos=59359 var.line_nr=2370
	// af parent scope:
	// af parent scope:
	return node;
}

VV_LOCAL_SYMBOL v__ast__Expr v__parser__Parser_parse_number_literal(v__parser__Parser* p) {
	v__token__Position pos = v__token__Token_position(&p->tok);
	bool is_neg = p->tok.kind == v__token__Kind_minus;
	if (is_neg) {
		v__parser__Parser_next(p);
		pos = v__token__Position_extend(pos, v__token__Token_position(&p->tok));
	}
	string lit = p->tok.lit;
	string full_lit = (is_neg ? (string_add(_SLIT("-"), lit)) : (lit));
	v__ast__Expr node = v__ast__empty_expr();
	if (string_index_any(lit, _SLIT(".eE")) >= 0 && !(string_eq(string_substr(lit, 0, 2), _SLIT("0x")) || string_eq(string_substr(lit, 0, 2), _SLIT("0X")) || string_eq(string_substr(lit, 0, 2), _SLIT("0o")) || string_eq(string_substr(lit, 0, 2), _SLIT("0O")) || string_eq(string_substr(lit, 0, 2), _SLIT("0b")) || string_eq(string_substr(lit, 0, 2), _SLIT("0B")))) {
		node = v__ast__FloatLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__FloatLiteral, ((v__ast__FloatLiteral){.val = full_lit,.pos = pos,})));
	} else {
		node = v__ast__IntegerLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__IntegerLiteral, ((v__ast__IntegerLiteral){.val = full_lit,.pos = pos,})));
	}
	v__parser__Parser_next(p);
	// autofree_scope_vars(pos=61589 line_nr=2471 scope.pos=61087 scope.end_pos=61602)
	// var "p" var.pos=61092 var.line_nr=2449
	// var "pos" var.pos=61141 var.line_nr=2450
	// var "is_neg" var.pos=61166 var.line_nr=2451
	// var "lit" var.pos=61262 var.line_nr=2456
	// var "full_lit" var.pos=61280 var.line_nr=2457
	// var "node" var.pos=61334 var.line_nr=2458
	// af parent scope:
	// af parent scope:
	return node;
}

VV_LOCAL_SYMBOL v__ast__Module v__parser__Parser_module_decl(v__parser__Parser* p) {
	Array_v__ast__Attr module_attrs = __new_array_with_default(0, 0, sizeof(v__ast__Attr), 0);
	v__token__Position attrs_pos = v__token__Token_position(&p->tok);
	if (p->tok.kind == v__token__Kind_lsbr) {
		v__parser__Parser_attributes(p);
		module_attrs = p->attrs;
	}
	string name = _SLIT("main");
	bool is_skipped = p->tok.kind != v__token__Kind_key_module;
	v__token__Position module_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,};
	v__token__Position name_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,};
	v__ast__Module mod_node = (v__ast__Module){.name = (string){.str=(byteptr)"", .is_lit=1},.short_name = (string){.str=(byteptr)"", .is_lit=1},.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.pos = {0},.name_pos = {0},.is_skipped = 0,};
	if (!is_skipped) {
		p->attrs = __new_array_with_default(0, 0, sizeof(v__ast__Attr), 0);
		module_pos = v__token__Token_position(&p->tok);
		v__parser__Parser_next(p);
		name_pos = v__token__Token_position(&p->tok);
		name = v__parser__Parser_check_name(p);
		mod_node = (v__ast__Module){.name = (string){.str=(byteptr)"", .is_lit=1},.short_name = (string){.str=(byteptr)"", .is_lit=1},.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.pos = module_pos,.name_pos = {0},.is_skipped = 0,};
		if (module_pos.line_nr != name_pos.line_nr) {
			v__parser__Parser_error_with_pos(p, _STR("`module` and `%.*s\000` must be at same line", 2, name), name_pos);
			// autofree_scope_vars(pos=62252 line_nr=2497 scope.pos=62173 scope.end_pos=62271)
			// af parent scope:
			// var "n_pos" var.pos=62396 var.line_nr=2502
			// af parent scope:
			// var "p" var.pos=61613 var.line_nr=2474
			// var "module_attrs" var.pos=61655 var.line_nr=2475
			// var "attrs_pos" var.pos=61689 var.line_nr=2476
			// var "name" var.pos=61795 var.line_nr=2481
			// str literal
			// var "is_skipped" var.pos=61811 var.line_nr=2482
			// var "module_pos" var.pos=61856 var.line_nr=2483
			// var "name_pos" var.pos=61892 var.line_nr=2484
			// var "mod_node" var.pos=61926 var.line_nr=2485
			// var "full_name" var.pos=62852 var.line_nr=2516
			// af parent scope:
			// af parent scope:
			return mod_node;
		}
		v__token__Position n_pos = v__token__Token_position(&p->tok);
		if (module_pos.line_nr == n_pos.line_nr && p->tok.kind != v__token__Kind_comment && p->tok.kind != v__token__Kind_eof) {
			if (p->tok.kind == v__token__Kind_name) {
				v__parser__Parser_error_with_pos(p, _STR("`module %.*s\000`, you can only declare one module, unexpected `%.*s\000`", 3, name, p->tok.lit), n_pos);
				// autofree_scope_vars(pos=62653 line_nr=2507 scope.pos=62539 scope.end_pos=62673)
				// af parent scope:
				// af parent scope:
				// var "n_pos" var.pos=62396 var.line_nr=2502
				// af parent scope:
				// var "p" var.pos=61613 var.line_nr=2474
				// var "module_attrs" var.pos=61655 var.line_nr=2475
				// var "attrs_pos" var.pos=61689 var.line_nr=2476
				// var "name" var.pos=61795 var.line_nr=2481
				// str literal
				// var "is_skipped" var.pos=61811 var.line_nr=2482
				// var "module_pos" var.pos=61856 var.line_nr=2483
				// var "name_pos" var.pos=61892 var.line_nr=2484
				// var "mod_node" var.pos=61926 var.line_nr=2485
				// var "full_name" var.pos=62852 var.line_nr=2516
				// af parent scope:
				// af parent scope:
				return mod_node;
			} else {
				v__parser__Parser_error_with_pos(p, _STR("`module %.*s\000`, unexpected `%.*s\000` after module name", 3, name, v__token__Kind_str(p->tok.kind)), n_pos);
				// autofree_scope_vars(pos=62780 line_nr=2511 scope.pos=62680 scope.end_pos=62800)
				// af parent scope:
				// af parent scope:
				// var "n_pos" var.pos=62396 var.line_nr=2502
				// af parent scope:
				// var "p" var.pos=61613 var.line_nr=2474
				// var "module_attrs" var.pos=61655 var.line_nr=2475
				// var "attrs_pos" var.pos=61689 var.line_nr=2476
				// var "name" var.pos=61795 var.line_nr=2481
				// str literal
				// var "is_skipped" var.pos=61811 var.line_nr=2482
				// var "module_pos" var.pos=61856 var.line_nr=2483
				// var "name_pos" var.pos=61892 var.line_nr=2484
				// var "mod_node" var.pos=61926 var.line_nr=2485
				// var "full_name" var.pos=62852 var.line_nr=2516
				// af parent scope:
				// af parent scope:
				return mod_node;
			}
		}
		module_pos = v__token__Position_extend(attrs_pos, name_pos);
	}
	string full_name = v__util__qualify_module(name, p->file_name);
	p->mod = full_name;
	p->builtin_mod = string_eq(p->mod, _SLIT("builtin"));
	mod_node = (v__ast__Module){
		.name = full_name,
		.short_name = name,
		.attrs = module_attrs,
		.pos = module_pos,
		.name_pos = name_pos,
		.is_skipped = is_skipped,
	};
	if (!is_skipped) {
		// FOR IN array
		for (int _t2653 = 0; _t2653 < module_attrs.len; ++_t2653) {
			v__ast__Attr ma = ((v__ast__Attr*)module_attrs.data)[_t2653];

			if (string_eq(ma.name, _SLIT("manualfree"))) {
				p->is_manualfree = true;
			}
			else {
				v__parser__Parser_error_with_pos(p, _STR("unknown module attribute `[%.*s\000]`", 2, ma.name), ma.pos);
				// autofree_scope_vars(pos=63312 line_nr=2535 scope.pos=63230 scope.end_pos=63333)
				// af parent scope:
				// var "ma" var.pos=63133 var.line_nr=2528
				// skipping tmp var "ma"
				// af parent scope:
				// af parent scope:
				// var "p" var.pos=61613 var.line_nr=2474
				// var "module_attrs" var.pos=61655 var.line_nr=2475
				// var "attrs_pos" var.pos=61689 var.line_nr=2476
				// var "name" var.pos=61795 var.line_nr=2481
				// str literal
				// var "is_skipped" var.pos=61811 var.line_nr=2482
				// var "module_pos" var.pos=61856 var.line_nr=2483
				// var "name_pos" var.pos=61892 var.line_nr=2484
				// var "mod_node" var.pos=61926 var.line_nr=2485
				// var "full_name" var.pos=62852 var.line_nr=2516
				// af parent scope:
				// af parent scope:
				return mod_node;
			};
		}
	}
	// autofree_scope_vars(pos=63347 line_nr=2540 scope.pos=61608 scope.end_pos=63364)
	// var "p" var.pos=61613 var.line_nr=2474
	// var "module_attrs" var.pos=61655 var.line_nr=2475
	// var "attrs_pos" var.pos=61689 var.line_nr=2476
	// var "name" var.pos=61795 var.line_nr=2481
	// str literal
	// var "is_skipped" var.pos=61811 var.line_nr=2482
	// var "module_pos" var.pos=61856 var.line_nr=2483
	// var "name_pos" var.pos=61892 var.line_nr=2484
	// var "mod_node" var.pos=61926 var.line_nr=2485
	// var "full_name" var.pos=62852 var.line_nr=2516
	// af parent scope:
	// af parent scope:
	return mod_node;
}

VV_LOCAL_SYMBOL v__ast__Import v__parser__Parser_import_stmt(v__parser__Parser* p) {
	v__token__Position import_pos = v__token__Token_position(&p->tok);
	v__parser__Parser_check(p, v__token__Kind_key_import);
	v__token__Position pos = v__token__Token_position(&p->tok);
	v__ast__Import import_node = (v__ast__Import){.mod = (string){.str=(byteptr)"", .is_lit=1},.alias = (string){.str=(byteptr)"", .is_lit=1},.pos = v__token__Position_extend(import_pos, pos),.mod_pos = {0},.alias_pos = {0},.syms_pos = {0},.syms = __new_array(0, 1, sizeof(v__ast__ImportSymbol)),.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.next_comments = __new_array(0, 1, sizeof(v__ast__Comment)),};
	if (p->tok.kind == v__token__Kind_lpar) {
		v__parser__Parser_error_with_pos(p, _SLIT("`import()` has been deprecated, use `import x` instead"), pos);
		// autofree_scope_vars(pos=63669 line_nr=2552 scope.pos=63584 scope.end_pos=63690)
		// af parent scope:
		// var "p" var.pos=63375 var.line_nr=2543
		// var "import_pos" var.pos=63413 var.line_nr=2544
		// var "pos" var.pos=63471 var.line_nr=2546
		// var "import_node" var.pos=63500 var.line_nr=2547
		// var "mod_name_arr" var.pos=63697 var.line_nr=2554
		// var "mod_alias" var.pos=63894 var.line_nr=2560
		// var "mod_name" var.pos=64929 var.line_nr=2598
		// var "pos_t" var.pos=65808 var.line_nr=2626
		// af parent scope:
		// af parent scope:
		return import_node;
	}
	Array_string mod_name_arr = __new_array_with_default(0, 0, sizeof(string), 0);
	array_push(&mod_name_arr, _MOV((string[]){ string_clone(v__parser__Parser_check_name(p)) }));
	if (import_pos.line_nr != pos.line_nr) {
		v__parser__Parser_error_with_pos(p, _SLIT("`import` statements must be a single line"), pos);
		// autofree_scope_vars(pos=63866 line_nr=2558 scope.pos=63794 scope.end_pos=63887)
		// af parent scope:
		// var "p" var.pos=63375 var.line_nr=2543
		// var "import_pos" var.pos=63413 var.line_nr=2544
		// var "pos" var.pos=63471 var.line_nr=2546
		// var "import_node" var.pos=63500 var.line_nr=2547
		// var "mod_name_arr" var.pos=63697 var.line_nr=2554
		// var "mod_alias" var.pos=63894 var.line_nr=2560
		// var "mod_name" var.pos=64929 var.line_nr=2598
		// var "pos_t" var.pos=65808 var.line_nr=2626
		// af parent scope:
		// af parent scope:
		return import_node;
	}
	string mod_alias = (*(string*)/*ee elem_typ */array_get(mod_name_arr, 0));
	import_node = (v__ast__Import){.mod = (string){.str=(byteptr)"", .is_lit=1},.alias = (string){.str=(byteptr)"", .is_lit=1},.pos = v__token__Position_extend(import_pos, pos),.mod_pos = pos,.alias_pos = pos,.syms_pos = {0},.syms = __new_array(0, 1, sizeof(v__ast__ImportSymbol)),.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.next_comments = __new_array(0, 1, sizeof(v__ast__Comment)),};
	for (;;) {
		if (!(p->tok.kind == v__token__Kind_dot)) break;
		v__parser__Parser_next(p);
		v__token__Position submod_pos = v__token__Token_position(&p->tok);
		if (p->tok.kind != v__token__Kind_name) {
			v__parser__Parser_error_with_pos(p, _SLIT("module syntax error, please use `x.y.z`"), submod_pos);
			// autofree_scope_vars(pos=64189 line_nr=2571 scope.pos=64110 scope.end_pos=64211)
			// af parent scope:
			// var "submod_pos" var.pos=64054 var.line_nr=2568
			// var "submod_name" var.pos=64370 var.line_nr=2577
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=63375 var.line_nr=2543
			// var "import_pos" var.pos=63413 var.line_nr=2544
			// var "pos" var.pos=63471 var.line_nr=2546
			// var "import_node" var.pos=63500 var.line_nr=2547
			// var "mod_name_arr" var.pos=63697 var.line_nr=2554
			// var "mod_alias" var.pos=63894 var.line_nr=2560
			// var "mod_name" var.pos=64929 var.line_nr=2598
			// var "pos_t" var.pos=65808 var.line_nr=2626
			// af parent scope:
			// af parent scope:
			return import_node;
		}
		if (import_pos.line_nr != submod_pos.line_nr) {
			v__parser__Parser_error_with_pos(p, _SLIT("`import` and `submodule` must be at same line"), submod_pos);
			// autofree_scope_vars(pos=64344 line_nr=2575 scope.pos=64259 scope.end_pos=64366)
			// af parent scope:
			// var "submod_pos" var.pos=64054 var.line_nr=2568
			// var "submod_name" var.pos=64370 var.line_nr=2577
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=63375 var.line_nr=2543
			// var "import_pos" var.pos=63413 var.line_nr=2544
			// var "pos" var.pos=63471 var.line_nr=2546
			// var "import_node" var.pos=63500 var.line_nr=2547
			// var "mod_name_arr" var.pos=63697 var.line_nr=2554
			// var "mod_alias" var.pos=63894 var.line_nr=2560
			// var "mod_name" var.pos=64929 var.line_nr=2598
			// var "pos_t" var.pos=65808 var.line_nr=2626
			// af parent scope:
			// af parent scope:
			return import_node;
		}
		string submod_name = v__parser__Parser_check_name(p);
		array_push(&mod_name_arr, _MOV((string[]){ string_clone(submod_name) }));
		mod_alias = submod_name;
		pos = v__token__Position_extend(pos, submod_pos);
		import_node = (v__ast__Import){.mod = v__util__qualify_import(p->pref, Array_string_join(mod_name_arr, _SLIT(".")), p->file_name),.alias = mod_alias,.pos = v__token__Position_extend(import_pos, pos),.mod_pos = pos,.alias_pos = submod_pos,.syms_pos = {0},.syms = __new_array(0, 1, sizeof(v__ast__ImportSymbol)),.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.next_comments = __new_array(0, 1, sizeof(v__ast__Comment)),};
	}
	if (mod_name_arr.len == 1) {
		import_node = (v__ast__Import){.mod = v__util__qualify_import(p->pref, (*(string*)/*ee elem_typ */array_get(mod_name_arr, 0)), p->file_name),.alias = mod_alias,.pos = import_node.pos,.mod_pos = import_node.mod_pos,.alias_pos = import_node.alias_pos,.syms_pos = {0},.syms = __new_array(0, 1, sizeof(v__ast__ImportSymbol)),.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.next_comments = __new_array(0, 1, sizeof(v__ast__Comment)),};
	}
	string mod_name = import_node.mod;
	if (p->tok.kind == v__token__Kind_key_as) {
		v__parser__Parser_next(p);
		v__token__Position alias_pos = v__token__Token_position(&p->tok);
		mod_alias = v__parser__Parser_check_name(p);
		if (string_eq(mod_alias, (*(string*)array_last(mod_name_arr)))) {
			v__parser__Parser_error_with_pos(p, _STR("import alias `%.*s\000 as %.*s\000` is redundant", 3, mod_name, mod_alias), v__token__Token_position(&p->prev_tok));
			// autofree_scope_vars(pos=65197 line_nr=2605 scope.pos=65095 scope.end_pos=65219)
			// af parent scope:
			// var "alias_pos" var.pos=64998 var.line_nr=2601
			// af parent scope:
			// var "p" var.pos=63375 var.line_nr=2543
			// var "import_pos" var.pos=63413 var.line_nr=2544
			// var "pos" var.pos=63471 var.line_nr=2546
			// var "import_node" var.pos=63500 var.line_nr=2547
			// var "mod_name_arr" var.pos=63697 var.line_nr=2554
			// var "mod_alias" var.pos=63894 var.line_nr=2560
			// var "mod_name" var.pos=64929 var.line_nr=2598
			// var "pos_t" var.pos=65808 var.line_nr=2626
			// af parent scope:
			// af parent scope:
			return import_node;
		}
		import_node = (v__ast__Import){.mod = import_node.mod,.alias = mod_alias,.pos = v__token__Position_extend(import_node.pos, alias_pos),.mod_pos = import_node.mod_pos,.alias_pos = alias_pos,.syms_pos = {0},.syms = __new_array(0, 1, sizeof(v__ast__ImportSymbol)),.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.next_comments = __new_array(0, 1, sizeof(v__ast__Comment)),};
	}
	if (p->tok.kind == v__token__Kind_lcbr) {
		v__token__Position initial_syms_pos = v__token__Token_position(&p->tok);
		v__parser__Parser_import_syms(p, (voidptr)&/*qq*/import_node);
		initial_syms_pos = v__token__Position_extend(initial_syms_pos, v__token__Token_position(&p->tok));
		import_node = (v__ast__Import){import_node.mod,import_node.alias,.pos = v__token__Position_extend(import_node.pos, initial_syms_pos),import_node.mod_pos,import_node.alias_pos,.syms_pos = initial_syms_pos,import_node.syms,import_node.comments,import_node.next_comments,};
		v__parser__Parser_register_used_import(p, mod_alias);
	}
	v__token__Position pos_t = v__token__Token_position(&p->tok);
	if (import_pos.line_nr == pos_t.line_nr) {
		if (!(p->tok.kind == v__token__Kind_lcbr || p->tok.kind == v__token__Kind_eof || p->tok.kind == v__token__Kind_comment)) {
			v__parser__Parser_error_with_pos(p, _SLIT("cannot import multiple modules at a time"), pos_t);
			// autofree_scope_vars(pos=65995 line_nr=2630 scope.pos=65920 scope.end_pos=66017)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=63375 var.line_nr=2543
			// var "import_pos" var.pos=63413 var.line_nr=2544
			// var "pos" var.pos=63471 var.line_nr=2546
			// var "import_node" var.pos=63500 var.line_nr=2547
			// var "mod_name_arr" var.pos=63697 var.line_nr=2554
			// var "mod_alias" var.pos=63894 var.line_nr=2560
			// var "mod_name" var.pos=64929 var.line_nr=2598
			// var "pos_t" var.pos=65808 var.line_nr=2626
			// af parent scope:
			// af parent scope:
			return import_node;
		}
	}
	import_node.comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = true,.follow_up = 0,});
	import_node.next_comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = true,});
	map_set(&p->imports, &(string[]){mod_alias}, &(string[]) { mod_name });
	array_push(&p->table->imports, _MOV((string[]){ string_clone(mod_name) }));
	array_push(&p->ast_imports, _MOV((v__ast__Import[]){ import_node }));
	// autofree_scope_vars(pos=66275 line_nr=2640 scope.pos=63370 scope.end_pos=66295)
	// var "p" var.pos=63375 var.line_nr=2543
	// var "import_pos" var.pos=63413 var.line_nr=2544
	// var "pos" var.pos=63471 var.line_nr=2546
	// var "import_node" var.pos=63500 var.line_nr=2547
	// var "mod_name_arr" var.pos=63697 var.line_nr=2554
	// var "mod_alias" var.pos=63894 var.line_nr=2560
	// var "mod_name" var.pos=64929 var.line_nr=2598
	// var "pos_t" var.pos=65808 var.line_nr=2626
	// af parent scope:
	// af parent scope:
	return import_node;
}

VV_LOCAL_SYMBOL void v__parser__Parser_import_syms(v__parser__Parser* p, v__ast__Import* parent) {
	v__parser__Parser_next(p);
	v__token__Position pos_t = v__token__Token_position(&p->tok);
	if (p->tok.kind == v__token__Kind_rcbr) {
		v__parser__Parser_error_with_pos(p, _STR("empty `%.*s\000` import set, remove `{}`", 2, parent->mod), pos_t);
		return;
	}
	if (p->tok.kind != v__token__Kind_name) {
		v__parser__Parser_error_with_pos(p, _SLIT("import syntax error, please specify a valid fn or type name"), pos_t);
		return;
	}
	for (;;) {
		if (!(p->tok.kind == v__token__Kind_name)) break;
		v__token__Position pos = v__token__Token_position(&p->tok);
		string alias = v__parser__Parser_check_name(p);
		map_set(&p->imported_symbols, &(string[]){alias}, &(string[]) { string_add(string_add(parent->mod, _SLIT(".")), alias) });
		array_push(&parent->syms, _MOV((v__ast__ImportSymbol[]){ (v__ast__ImportSymbol){.pos = pos,.name = alias,} }));
		if (p->tok.kind == v__token__Kind_comma) {
			v__parser__Parser_next(p);
			continue;
		}
		if (p->tok.kind == v__token__Kind_rcbr) {
			break;
		}
	}
	if (p->tok.kind != v__token__Kind_rcbr) {
		v__parser__Parser_error_with_pos(p, _SLIT("import syntax error, no closing `}`"), v__token__Token_position(&p->tok));
		return;
	}
	v__parser__Parser_next(p);
}

VV_LOCAL_SYMBOL v__ast__ConstDecl v__parser__Parser_const_decl(v__parser__Parser* p) {
	v__parser__Parser_top_level_statement_start(p);
	v__token__Position start_pos = v__token__Token_position(&p->tok);
	bool is_pub = p->tok.kind == v__token__Kind_key_pub;
	if (is_pub) {
		v__parser__Parser_next(p);
	}
	v__token__Position end_pos = v__token__Token_position(&p->tok);
	v__token__Position const_pos = v__token__Token_position(&p->tok);
	v__parser__Parser_check(p, v__token__Kind_key_const);
	bool is_block = p->tok.kind == v__token__Kind_lpar;
	if (is_block) {
		v__parser__Parser_next(p);
	}
	Array_v__ast__ConstField fields = __new_array_with_default(0, 0, sizeof(v__ast__ConstField), 0);
	Array_v__ast__Comment comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	for (;;) {
		if (p->tok.kind == v__token__Kind_eof) {
			v__parser__Parser_error_with_pos(p, _SLIT("const declaration is missing closing `)`"), const_pos);
			 v__ast__ConstDecl _t2659 = (v__ast__ConstDecl){.is_pub = 0,.pos = {0},.fields = __new_array(0, 1, sizeof(v__ast__ConstField)),.end_comments = __new_array(0, 1, sizeof(v__ast__Comment)),.is_block = 0,};
			// autofree_scope_vars(pos=67782 line_nr=2699 scope.pos=67703 scope.end_pos=67808)
			// af parent scope:
			// var "pos" var.pos=67884 var.line_nr=2705
			// var "name" var.pos=67910 var.line_nr=2706
			// var "full_name" var.pos=68074 var.line_nr=2711
			// var "expr" var.pos=68248 var.line_nr=2717
			// var "field" var.pos=68268 var.line_nr=2718
			// af parent scope:
			// var "p" var.pos=67295 var.line_nr=2680
			// var "start_pos" var.pos=67366 var.line_nr=2682
			// var "is_pub" var.pos=67397 var.line_nr=2683
			// var "end_pos" var.pos=67458 var.line_nr=2687
			// var "const_pos" var.pos=67487 var.line_nr=2688
			// var "is_block" var.pos=67539 var.line_nr=2690
			// var "fields" var.pos=67610 var.line_nr=2694
			// var "comments" var.pos=67644 var.line_nr=2695
			// af parent scope:
			// af parent scope:
			return _t2659;
		}
		comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,});
		if (p->tok.kind == v__token__Kind_rpar) {
			break;
		}
		v__token__Position pos = v__token__Token_position(&p->tok);
		string name = v__parser__Parser_check_name(p);
		if (v__util__contains_capital(name)) {
			v__parser__Parser_warn_with_pos(p, _SLIT("const names cannot contain uppercase letters, use snake_case instead"), pos);
		}
		string full_name = v__parser__Parser_prepend_mod(p, name);
		v__parser__Parser_check(p, v__token__Kind_assign);
		if (p->tok.kind == v__token__Kind_key_fn) {
			v__parser__Parser_error(p, _SLIT("const initializer fn literal is not a constant"));
			 v__ast__ConstDecl _t2660 = (v__ast__ConstDecl){.is_pub = 0,.pos = {0},.fields = __new_array(0, 1, sizeof(v__ast__ConstField)),.end_comments = __new_array(0, 1, sizeof(v__ast__Comment)),.is_block = 0,};
			// autofree_scope_vars(pos=68218 line_nr=2715 scope.pos=68153 scope.end_pos=68244)
			// af parent scope:
			// var "pos" var.pos=67884 var.line_nr=2705
			// var "name" var.pos=67910 var.line_nr=2706
			// var "full_name" var.pos=68074 var.line_nr=2711
			// var "expr" var.pos=68248 var.line_nr=2717
			// var "field" var.pos=68268 var.line_nr=2718
			// af parent scope:
			// var "p" var.pos=67295 var.line_nr=2680
			// var "start_pos" var.pos=67366 var.line_nr=2682
			// var "is_pub" var.pos=67397 var.line_nr=2683
			// var "end_pos" var.pos=67458 var.line_nr=2687
			// var "const_pos" var.pos=67487 var.line_nr=2688
			// var "is_block" var.pos=67539 var.line_nr=2690
			// var "fields" var.pos=67610 var.line_nr=2694
			// var "comments" var.pos=67644 var.line_nr=2695
			// af parent scope:
			// af parent scope:
			return _t2660;
		}
		v__ast__Expr expr = v__parser__Parser_expr(p, 0);
		v__ast__ConstField field = (v__ast__ConstField){
			.mod = p->mod,
			.name = full_name,
			.expr = expr,
			.is_pub = is_pub,
			.pos = v__token__Position_extend(pos, v__ast__Expr_position(expr)),
			.typ = 0,
			.comments = comments,
		};
		array_push(&fields, _MOV((v__ast__ConstField[]){ field }));
		v__ast__Scope_register(p->global_scope, v__ast__ConstField_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__ConstField, (field))));
		comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
		if (!is_block) {
			break;
		}
	}
	v__parser__Parser_top_level_statement_end(p);
	if (is_block) {
		v__parser__Parser_check(p, v__token__Kind_rpar);
	}
	 v__ast__ConstDecl _t2662 = (v__ast__ConstDecl){.is_pub = is_pub,.pos = v__token__Position_extend_with_last_line(start_pos, end_pos, p->prev_tok.line_nr),.fields = fields,.end_comments = comments,.is_block = is_block,};
	// autofree_scope_vars(pos=68584 line_nr=2737 scope.pos=67290 scope.end_pos=68758)
	// var "p" var.pos=67295 var.line_nr=2680
	// var "start_pos" var.pos=67366 var.line_nr=2682
	// var "is_pub" var.pos=67397 var.line_nr=2683
	// var "end_pos" var.pos=67458 var.line_nr=2687
	// var "const_pos" var.pos=67487 var.line_nr=2688
	// var "is_block" var.pos=67539 var.line_nr=2690
	// var "fields" var.pos=67610 var.line_nr=2694
	// var "comments" var.pos=67644 var.line_nr=2695
	// af parent scope:
	// af parent scope:
	return _t2662;
}

VV_LOCAL_SYMBOL v__ast__Return v__parser__Parser_return_stmt(v__parser__Parser* p) {
	v__token__Position first_pos = v__token__Token_position(&p->tok);
	v__parser__Parser_next(p);
	Array_v__ast__Comment comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,});
	if (p->tok.kind == v__token__Kind_rcbr) {
		 v__ast__Return _t2663 = (v__ast__Return){.pos = first_pos,.exprs = __new_array(0, 1, sizeof(v__ast__Expr)),.comments = comments,.types = __new_array(0, 1, sizeof(v__ast__Type)),};
		// autofree_scope_vars(pos=68924 line_nr=2752 scope.pos=68921 scope.end_pos=68989)
		// af parent scope:
		// var "p" var.pos=68769 var.line_nr=2746
		// var "first_pos" var.pos=68807 var.line_nr=2747
		// var "comments" var.pos=68866 var.line_nr=2750
		// var "exprs" var.pos=69009 var.line_nr=2758
		// var "comments2" var.pos=69016 var.line_nr=2758
		// var "end_pos" var.pos=69067 var.line_nr=2760
		// af parent scope:
		// af parent scope:
		return _t2663;
	}
	multi_return_Array_v__ast__Expr_Array_v__ast__Comment mr_69026 = v__parser__Parser_expr_list(p);
	Array_v__ast__Expr exprs = mr_69026.arg0;
	Array_v__ast__Comment comments2 = mr_69026.arg1;
	_PUSH_MANY(&comments, (comments2), _t2664, Array_v__ast__Comment);
	v__token__Position end_pos = v__ast__Expr_position((*(v__ast__Expr*)array_last(exprs)));
	 v__ast__Return _t2665 = (v__ast__Return){.pos = v__token__Position_extend(first_pos, end_pos),.exprs = exprs,.comments = comments,.types = __new_array(0, 1, sizeof(v__ast__Type)),};
	// autofree_scope_vars(pos=69102 line_nr=2761 scope.pos=68764 scope.end_pos=69194)
	// var "p" var.pos=68769 var.line_nr=2746
	// var "first_pos" var.pos=68807 var.line_nr=2747
	// var "comments" var.pos=68866 var.line_nr=2750
	// var "exprs" var.pos=69009 var.line_nr=2758
	// var "comments2" var.pos=69016 var.line_nr=2758
	// var "end_pos" var.pos=69067 var.line_nr=2760
	// af parent scope:
	// af parent scope:
	return _t2665;
}

VV_LOCAL_SYMBOL v__ast__GlobalDecl v__parser__Parser_global_decl(v__parser__Parser* p) {
	if (!p->pref->translated && !p->pref->is_livemain && !p->builtin_mod && !p->pref->building_v && string_ne(p->mod, _SLIT("ui")) && string_ne(p->mod, _SLIT("gg2")) && string_ne(p->mod, _SLIT("uiold")) && !p->pref->enable_globals && !p->pref->is_fmt && !(Array_string_contains(_const_v__parser__global_enabled_mods, p->mod))) {
		v__parser__Parser_error(p, _SLIT("use `v --enable-globals ...` to enable globals"));
		 v__ast__GlobalDecl _t2666 = (v__ast__GlobalDecl){.pos = {0},.fields = __new_array(0, 1, sizeof(v__ast__GlobalField)),.end_comments = __new_array(0, 1, sizeof(v__ast__Comment)),};
		// autofree_scope_vars(pos=69691 line_nr=2779 scope.pos=69628 scope.end_pos=69717)
		// af parent scope:
		// var "p" var.pos=69358 var.line_nr=2774
		// var "start_pos" var.pos=69720 var.line_nr=2781
		// var "end_pos" var.pos=69751 var.line_nr=2782
		// var "fields" var.pos=69945 var.line_nr=2789
		// var "comments" var.pos=69980 var.line_nr=2790
		// af parent scope:
		// af parent scope:
		return _t2666;
	}
	v__token__Position start_pos = v__token__Token_position(&p->tok);
	v__token__Position end_pos = v__token__Token_position(&p->tok);
	v__parser__Parser_check(p, v__token__Kind_key_global);
	if (p->tok.kind != v__token__Kind_lpar) {
		v__parser__Parser_error(p, _SLIT("globals must be grouped, e.g. `__global ( a = int(1) )`"));
		 v__ast__GlobalDecl _t2667 = (v__ast__GlobalDecl){.pos = {0},.fields = __new_array(0, 1, sizeof(v__ast__GlobalField)),.end_comments = __new_array(0, 1, sizeof(v__ast__Comment)),};
		// autofree_scope_vars(pos=69897 line_nr=2786 scope.pos=69825 scope.end_pos=69923)
		// af parent scope:
		// var "p" var.pos=69358 var.line_nr=2774
		// var "start_pos" var.pos=69720 var.line_nr=2781
		// var "end_pos" var.pos=69751 var.line_nr=2782
		// var "fields" var.pos=69945 var.line_nr=2789
		// var "comments" var.pos=69980 var.line_nr=2790
		// af parent scope:
		// af parent scope:
		return _t2667;
	}
	v__parser__Parser_next(p);
	Array_v__ast__GlobalField fields = __new_array_with_default(0, 0, sizeof(v__ast__GlobalField), 0);
	Array_v__ast__Comment comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	for (;;) {
		comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,});
		if (p->tok.kind == v__token__Kind_rpar) {
			break;
		}
		v__token__Position pos = v__token__Token_position(&p->tok);
		string name = v__parser__Parser_check_name(p);
		bool has_expr = p->tok.kind == v__token__Kind_assign;
		if (has_expr) {
			v__parser__Parser_next(p);
		}
		v__ast__Type typ = v__parser__Parser_parse_type(p);
		if (p->tok.kind == v__token__Kind_assign) {
			v__parser__Parser_error(p, _SLIT("global assign must have the type around the value, use `__global ( name = type(value) )`"));
			 v__ast__GlobalDecl _t2668 = (v__ast__GlobalDecl){.pos = {0},.fields = __new_array(0, 1, sizeof(v__ast__GlobalField)),.end_comments = __new_array(0, 1, sizeof(v__ast__Comment)),};
			// autofree_scope_vars(pos=70369 line_nr=2805 scope.pos=70262 scope.end_pos=70396)
			// af parent scope:
			// var "pos" var.pos=70089 var.line_nr=2796
			// var "name" var.pos=70115 var.line_nr=2797
			// var "has_expr" var.pos=70140 var.line_nr=2798
			// var "typ" var.pos=70213 var.line_nr=2802
			// var "expr" var.pos=70404 var.line_nr=2807
			// var "field" var.pos=70690 var.line_nr=2817
			// af parent scope:
			// var "p" var.pos=69358 var.line_nr=2774
			// var "start_pos" var.pos=69720 var.line_nr=2781
			// var "end_pos" var.pos=69751 var.line_nr=2782
			// var "fields" var.pos=69945 var.line_nr=2789
			// var "comments" var.pos=69980 var.line_nr=2790
			// af parent scope:
			// af parent scope:
			return _t2668;
		}
		v__ast__Expr expr = v__ast__empty_expr();
		if (has_expr) {
			if (p->tok.kind != v__token__Kind_lpar) {
				v__parser__Parser_error(p, _SLIT("global assign must have a type and value, use `__global ( name = type(value) )` or `__global ( name type )`"));
				 v__ast__GlobalDecl _t2669 = (v__ast__GlobalDecl){.pos = {0},.fields = __new_array(0, 1, sizeof(v__ast__GlobalField)),.end_comments = __new_array(0, 1, sizeof(v__ast__Comment)),};
				// autofree_scope_vars(pos=70599 line_nr=2811 scope.pos=70471 scope.end_pos=70627)
				// af parent scope:
				// af parent scope:
				// var "pos" var.pos=70089 var.line_nr=2796
				// var "name" var.pos=70115 var.line_nr=2797
				// var "has_expr" var.pos=70140 var.line_nr=2798
				// var "typ" var.pos=70213 var.line_nr=2802
				// var "expr" var.pos=70404 var.line_nr=2807
				// var "field" var.pos=70690 var.line_nr=2817
				// af parent scope:
				// var "p" var.pos=69358 var.line_nr=2774
				// var "start_pos" var.pos=69720 var.line_nr=2781
				// var "end_pos" var.pos=69751 var.line_nr=2782
				// var "fields" var.pos=69945 var.line_nr=2789
				// var "comments" var.pos=69980 var.line_nr=2790
				// af parent scope:
				// af parent scope:
				return _t2669;
			}
			v__parser__Parser_next(p);
			expr = v__parser__Parser_expr(p, 0);
			v__parser__Parser_check(p, v__token__Kind_rpar);
		}
		v__ast__GlobalField field = (v__ast__GlobalField){
			.name = name,
			.expr = expr,
			.has_expr = has_expr,
			.pos = pos,
			.typ = typ,
			.comments = comments,
		};
		array_push(&fields, _MOV((v__ast__GlobalField[]){ field }));
		v__ast__Scope_register(p->global_scope, v__ast__GlobalField_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__GlobalField, (field))));
		comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	}
	v__parser__Parser_check(p, v__token__Kind_rpar);
	 v__ast__GlobalDecl _t2671 = (v__ast__GlobalDecl){.pos = v__token__Position_extend(start_pos, end_pos),.fields = fields,.end_comments = comments,};
	// autofree_scope_vars(pos=70902 line_nr=2830 scope.pos=69353 scope.end_pos=71004)
	// var "p" var.pos=69358 var.line_nr=2774
	// var "start_pos" var.pos=69720 var.line_nr=2781
	// var "end_pos" var.pos=69751 var.line_nr=2782
	// var "fields" var.pos=69945 var.line_nr=2789
	// var "comments" var.pos=69980 var.line_nr=2790
	// af parent scope:
	// af parent scope:
	return _t2671;
}

VV_LOCAL_SYMBOL v__ast__EnumDecl v__parser__Parser_enum_decl(v__parser__Parser* p) {
	v__parser__Parser_top_level_statement_start(p);
	bool is_pub = p->tok.kind == v__token__Kind_key_pub;
	v__token__Position start_pos = v__token__Token_position(&p->tok);
	if (is_pub) {
		v__parser__Parser_next(p);
	}
	v__parser__Parser_check(p, v__token__Kind_key_enum);
	v__token__Position end_pos = v__token__Token_position(&p->tok);
	string enum_name = v__parser__Parser_check_name(p);
	if (enum_name.len == 1) {
		v__parser__Parser_error_with_pos(p, _SLIT("single letter capital names are reserved for generic template types."), end_pos);
		 v__ast__EnumDecl _t2672 = (v__ast__EnumDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.is_pub = 0,.is_flag = 0,.is_multi_allowed = 0,.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.fields = __new_array(0, 1, sizeof(v__ast__EnumField)),.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.pos = {0},};
		// autofree_scope_vars(pos=71382 line_nr=2850 scope.pos=71276 scope.end_pos=71406)
		// af parent scope:
		// var "p" var.pos=71015 var.line_nr=2837
		// var "is_pub" var.pos=71084 var.line_nr=2839
		// var "start_pos" var.pos=71118 var.line_nr=2840
		// var "end_pos" var.pos=71196 var.line_nr=2845
		// var "enum_name" var.pos=71225 var.line_nr=2846
		// var "name" var.pos=71409 var.line_nr=2852
		// var "enum_decl_comments" var.pos=71459 var.line_nr=2854
		// var "vals" var.pos=71505 var.line_nr=2855
		// var "fields" var.pos=71567 var.line_nr=2857
		// var "is_flag" var.pos=72099 var.line_nr=2881
		// var "is_multi_allowed" var.pos=72136 var.line_nr=2882
		// var "idx" var.pos=73163 var.line_nr=2906
		// af parent scope:
		// af parent scope:
		return _t2672;
	}
	string name = v__parser__Parser_prepend_mod(p, enum_name);
	v__parser__Parser_check(p, v__token__Kind_lcbr);
	Array_v__ast__Comment enum_decl_comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,});
	Array_string vals = __new_array_with_default(0, 0, sizeof(string), 0);
	Array_v__ast__EnumField fields = __new_array_with_default(0, 0, sizeof(v__ast__EnumField), 0);
	for (;;) {
		if (!(p->tok.kind != v__token__Kind_eof && p->tok.kind != v__token__Kind_rcbr)) break;
		v__token__Position pos = v__token__Token_position(&p->tok);
		string val = v__parser__Parser_check_name(p);
		array_push(&vals, _MOV((string[]){ string_clone(val) }));
		v__ast__Expr expr = v__ast__empty_expr();
		bool has_expr = false;
		if (p->tok.kind == v__token__Kind_assign) {
			v__parser__Parser_next(p);
			expr = v__parser__Parser_expr(p, 0);
			has_expr = true;
		}
		array_push(&fields, _MOV((v__ast__EnumField[]){ (v__ast__EnumField){
			.name = val,
			.pos = pos,
			.comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = true,.follow_up = 0,}),
			.next_comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}),
			.expr = expr,
			.has_expr = has_expr,
		} }));
	}
	v__parser__Parser_top_level_statement_end(p);
	v__parser__Parser_check(p, v__token__Kind_rcbr);
	bool is_flag = Array_v__ast__Attr_contains(p->attrs, _SLIT("flag"));
	bool is_multi_allowed = Array_v__ast__Attr_contains(p->attrs, _SLIT("_allow_multiple_values"));
	if (is_flag) {
		if (fields.len > 32) {
			v__parser__Parser_error(p, _SLIT("when an enum is used as bit field, it must have a max of 32 fields"));
			 v__ast__EnumDecl _t2675 = (v__ast__EnumDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.is_pub = 0,.is_flag = 0,.is_multi_allowed = 0,.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.fields = __new_array(0, 1, sizeof(v__ast__EnumField)),.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.pos = {0},};
			// autofree_scope_vars(pos=72319 line_nr=2886 scope.pos=72234 scope.end_pos=72344)
			// af parent scope:
			// var "pubfn" var.pos=72528 var.line_nr=2895
			// af parent scope:
			// var "p" var.pos=71015 var.line_nr=2837
			// var "is_pub" var.pos=71084 var.line_nr=2839
			// var "start_pos" var.pos=71118 var.line_nr=2840
			// var "end_pos" var.pos=71196 var.line_nr=2845
			// var "enum_name" var.pos=71225 var.line_nr=2846
			// var "name" var.pos=71409 var.line_nr=2852
			// var "enum_decl_comments" var.pos=71459 var.line_nr=2854
			// var "vals" var.pos=71505 var.line_nr=2855
			// var "fields" var.pos=71567 var.line_nr=2857
			// var "is_flag" var.pos=72099 var.line_nr=2881
			// var "is_multi_allowed" var.pos=72136 var.line_nr=2882
			// var "idx" var.pos=73163 var.line_nr=2906
			// af parent scope:
			// af parent scope:
			return _t2675;
		}
		// FOR IN array
		for (int _t2676 = 0; _t2676 < fields.len; ++_t2676) {
			v__ast__EnumField f = ((v__ast__EnumField*)fields.data)[_t2676];
			if (f.has_expr) {
				v__parser__Parser_error_with_pos(p, _SLIT("when an enum is used as a bit field, you can not assign custom values"), f.pos);
				 v__ast__EnumDecl _t2677 = (v__ast__EnumDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.is_pub = 0,.is_flag = 0,.is_multi_allowed = 0,.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.fields = __new_array(0, 1, sizeof(v__ast__EnumField)),.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.pos = {0},};
				// autofree_scope_vars(pos=72494 line_nr=2892 scope.pos=72383 scope.end_pos=72520)
				// af parent scope:
				// var "f" var.pos=72352 var.line_nr=2888
				// skipping tmp var "f"
				// af parent scope:
				// var "pubfn" var.pos=72528 var.line_nr=2895
				// af parent scope:
				// var "p" var.pos=71015 var.line_nr=2837
				// var "is_pub" var.pos=71084 var.line_nr=2839
				// var "start_pos" var.pos=71118 var.line_nr=2840
				// var "end_pos" var.pos=71196 var.line_nr=2845
				// var "enum_name" var.pos=71225 var.line_nr=2846
				// var "name" var.pos=71409 var.line_nr=2852
				// var "enum_decl_comments" var.pos=71459 var.line_nr=2854
				// var "vals" var.pos=71505 var.line_nr=2855
				// var "fields" var.pos=71567 var.line_nr=2857
				// var "is_flag" var.pos=72099 var.line_nr=2881
				// var "is_multi_allowed" var.pos=72136 var.line_nr=2882
				// var "idx" var.pos=73163 var.line_nr=2906
				// af parent scope:
				// af parent scope:
				return _t2677;
			}
		}
		string pubfn = (string_eq(p->mod, _SLIT("main")) ? (_SLIT("fn")) : (_SLIT("pub fn")));
		v__scanner__Scanner_codegen(p->scanner, _STR("\n//\n[inline] %.*s\000 (    e &%.*s\000) is_empty() bool           { return  int(*e) == 0 }\n[inline] %.*s\000 (    e &%.*s\000) has(flag %.*s\000) bool { return  (int(*e) &  (int(flag))) != 0 }\n[inline] %.*s\000 (mut e  %.*s\000) set(flag %.*s\000)      { unsafe{ *e = %.*s\000(int(*e) |  (int(flag))) } }\n[inline] %.*s\000 (mut e  %.*s\000) clear(flag %.*s\000)    { unsafe{ *e = %.*s\000(int(*e) & ~(int(flag))) } }\n[inline] %.*s\000 (mut e  %.*s\000) toggle(flag %.*s\000)   { unsafe{ *e = %.*s\000(int(*e) ^  (int(flag))) } }\n//\n", 18, pubfn, enum_name, pubfn, enum_name, enum_name, pubfn, enum_name, enum_name, enum_name, pubfn, enum_name, enum_name, enum_name, pubfn, enum_name, enum_name, enum_name));
	}
	int idx = v__ast__Table_register_type_symbol(p->table, (v__ast__TypeSymbol){
		.parent_idx = 0,
		.info = v__ast__Enum_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__Enum, ((v__ast__Enum){.vals = vals,.is_flag = is_flag,.is_multi_allowed = is_multi_allowed,}))),
		.kind = v__ast__Kind_enum_,
		.name = name,
		.cname = v__util__no_dots(name),
		.methods = __new_array(0, 1, sizeof(v__ast__Fn)),
		.mod = p->mod,
		.is_public = is_pub,
		.language = 0,
	});
	if (idx == -1) {
		v__parser__Parser_error_with_pos(p, _STR("cannot register enum `%.*s\000`, another type with this name exists", 2, name), end_pos);
	}
	 v__ast__EnumDecl _t2678 = (v__ast__EnumDecl){
		.name = name,
		.is_pub = is_pub,
		.is_flag = is_flag,
		.is_multi_allowed = is_multi_allowed,
		.comments = enum_decl_comments,
		.fields = fields,
		.attrs = p->attrs,
		.pos = v__token__Position_extend_with_last_line(start_pos, end_pos, p->prev_tok.line_nr),
	};
	// autofree_scope_vars(pos=73520 line_nr=2922 scope.pos=71010 scope.end_pos=73764)
	// var "p" var.pos=71015 var.line_nr=2837
	// var "is_pub" var.pos=71084 var.line_nr=2839
	// var "start_pos" var.pos=71118 var.line_nr=2840
	// var "end_pos" var.pos=71196 var.line_nr=2845
	// var "enum_name" var.pos=71225 var.line_nr=2846
	// var "name" var.pos=71409 var.line_nr=2852
	// var "enum_decl_comments" var.pos=71459 var.line_nr=2854
	// var "vals" var.pos=71505 var.line_nr=2855
	// var "fields" var.pos=71567 var.line_nr=2857
	// var "is_flag" var.pos=72099 var.line_nr=2881
	// var "is_multi_allowed" var.pos=72136 var.line_nr=2882
	// var "idx" var.pos=73163 var.line_nr=2906
	// af parent scope:
	// af parent scope:
	return _t2678;
}

VV_LOCAL_SYMBOL v__ast__TypeDecl v__parser__Parser_type_decl(v__parser__Parser* p) {
	v__token__Position start_pos = v__token__Token_position(&p->tok);
	bool is_pub = p->tok.kind == v__token__Kind_key_pub;
	if (is_pub) {
		v__parser__Parser_next(p);
	}
	v__parser__Parser_check(p, v__token__Kind_key_type);
	v__token__Position end_pos = v__token__Token_position(&p->tok);
	v__token__Position decl_pos = v__token__Position_extend(start_pos, end_pos);
	string name = v__parser__Parser_check_name(p);
	if (name.len == 1 && byte_is_capital(string_at(name, 0))) {
		v__parser__Parser_error_with_pos(p, _SLIT("single letter capital names are reserved for generic template types."), decl_pos);
		 v__ast__TypeDecl _t2679 = v__ast__FnTypeDecl_to_sumtype_v__ast__TypeDecl(ADDR(v__ast__FnTypeDecl, ((v__ast__FnTypeDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.is_pub = 0,.typ = 0,.pos = {0},.type_pos = {0},.comments = __new_array(0, 1, sizeof(v__ast__Comment)),})));
		// autofree_scope_vars(pos=74165 line_nr=2947 scope.pos=74058 scope.end_pos=74191)
		// af parent scope:
		// var "p" var.pos=73775 var.line_nr=2934
		// var "start_pos" var.pos=73813 var.line_nr=2935
		// var "is_pub" var.pos=73844 var.line_nr=2936
		// var "end_pos" var.pos=73925 var.line_nr=2941
		// var "decl_pos" var.pos=73954 var.line_nr=2942
		// var "name" var.pos=73993 var.line_nr=2943
		// var "sum_variants" var.pos=74198 var.line_nr=2949
		// var "type_pos" var.pos=74260 var.line_nr=2951
		// var "comments" var.pos=74294 var.line_nr=2952
		// var "first_type" var.pos=74714 var.line_nr=2968
		// var "type_alias_pos" var.pos=74821 var.line_nr=2969
		// var "parent_type" var.pos=76037 var.line_nr=3018
		// var "parent_sym" var.pos=76064 var.line_nr=3019
		// var "pidx" var.pos=76116 var.line_nr=3020
		// var "prepend_mod_name" var.pos=76196 var.line_nr=3022
		// var "idx" var.pos=76237 var.line_nr=3023
		// af parent scope:
		// af parent scope:
		return _t2679;
	}
	Array_v__ast__SumTypeVariant sum_variants = __new_array_with_default(0, 0, sizeof(v__ast__SumTypeVariant), 0);
	v__parser__Parser_check(p, v__token__Kind_assign);
	v__token__Position type_pos = v__token__Token_position(&p->tok);
	Array_v__ast__Comment comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	if (p->tok.kind == v__token__Kind_key_fn) {
		string fn_name = v__parser__Parser_prepend_mod(p, name);
		v__ast__Type fn_type = v__parser__Parser_parse_fn_type(p, fn_name);
		type_pos = v__token__Position_extend(type_pos, v__token__Token_position(&p->tok));
		comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = true,.follow_up = 0,});
		 v__ast__TypeDecl _t2680 = v__ast__FnTypeDecl_to_sumtype_v__ast__TypeDecl(ADDR(v__ast__FnTypeDecl, ((v__ast__FnTypeDecl){
			.name = fn_name,
			.is_pub = is_pub,
			.typ = fn_type,
			.pos = decl_pos,
			.type_pos = type_pos,
			.comments = comments,
		})));
		// autofree_scope_vars(pos=74570 line_nr=2959 scope.pos=74348 scope.end_pos=74711)
		// var "fn_name" var.pos=74408 var.line_nr=2955
		// var "fn_type" var.pos=74441 var.line_nr=2956
		// af parent scope:
		// var "p" var.pos=73775 var.line_nr=2934
		// var "start_pos" var.pos=73813 var.line_nr=2935
		// var "is_pub" var.pos=73844 var.line_nr=2936
		// var "end_pos" var.pos=73925 var.line_nr=2941
		// var "decl_pos" var.pos=73954 var.line_nr=2942
		// var "name" var.pos=73993 var.line_nr=2943
		// var "sum_variants" var.pos=74198 var.line_nr=2949
		// var "type_pos" var.pos=74260 var.line_nr=2951
		// var "comments" var.pos=74294 var.line_nr=2952
		// var "first_type" var.pos=74714 var.line_nr=2968
		// var "type_alias_pos" var.pos=74821 var.line_nr=2969
		// var "parent_type" var.pos=76037 var.line_nr=3018
		// var "parent_sym" var.pos=76064 var.line_nr=3019
		// var "pidx" var.pos=76116 var.line_nr=3020
		// var "prepend_mod_name" var.pos=76196 var.line_nr=3022
		// var "idx" var.pos=76237 var.line_nr=3023
		// af parent scope:
		// af parent scope:
		return _t2680;
	}
	v__ast__Type first_type = v__parser__Parser_parse_type(p);
	v__token__Position type_alias_pos = v__token__Token_position(&p->tok);
	if (p->tok.kind == v__token__Kind_pipe) {
		v__token__Position type_end_pos = v__token__Token_position(&p->prev_tok);
		type_pos = v__token__Position_extend(type_pos, type_end_pos);
		v__parser__Parser_next(p);
		array_push(&sum_variants, _MOV((v__ast__SumTypeVariant[]){ (v__ast__SumTypeVariant){.typ = first_type,.pos = type_pos,} }));
		for (;;) {
			type_pos = v__token__Token_position(&p->tok);
			v__ast__Type variant_type = v__parser__Parser_parse_type(p);
			v__token__Token prev_tok = p->prev_tok;
			type_end_pos = v__token__Token_position(&prev_tok);
			type_pos = v__token__Position_extend(type_pos, type_end_pos);
			array_push(&sum_variants, _MOV((v__ast__SumTypeVariant[]){ (v__ast__SumTypeVariant){.typ = variant_type,.pos = type_pos,} }));
			if (p->tok.kind != v__token__Kind_pipe) {
				break;
			}
			v__parser__Parser_check(p, v__token__Kind_pipe);
		}
		Array_v__ast__SumTypeVariant _t2683_orig = sum_variants;
		int _t2683_len = _t2683_orig.len;
		Array_v__ast__Type _t2683 = __new_array(0, _t2683_len, sizeof(v__ast__Type));

		for (int _t2684 = 0; _t2684 < _t2683_len; ++_t2684) {
			v__ast__SumTypeVariant it = ((v__ast__SumTypeVariant*) _t2683_orig.data)[_t2684];
			v__ast__Type ti = it.typ;
			array_push(&_t2683, &ti);
		}
		
		Array_v__ast__Type variant_types = _t2683;
		string prepend_mod_name = v__parser__Parser_prepend_mod(p, name);
		int typ = v__ast__Table_register_type_symbol(p->table, (v__ast__TypeSymbol){
			.parent_idx = 0,
			.info = v__ast__SumType_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__SumType, ((v__ast__SumType){.variants = variant_types,.fields = __new_array(0, 1, sizeof(v__ast__StructField)),.found_fields = 0,}))),
			.kind = v__ast__Kind_sum_type,
			.name = prepend_mod_name,
			.cname = v__util__no_dots(prepend_mod_name),
			.methods = __new_array(0, 1, sizeof(v__ast__Fn)),
			.mod = p->mod,
			.is_public = is_pub,
			.language = 0,
		});
		comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = true,.follow_up = 0,});
		 v__ast__TypeDecl _t2685 = v__ast__SumTypeDecl_to_sumtype_v__ast__TypeDecl(ADDR(v__ast__SumTypeDecl, ((v__ast__SumTypeDecl){
			.name = name,
			.is_pub = is_pub,
			.pos = decl_pos,
			.comments = comments,
			.typ = typ,
			.variants = sum_variants,
		})));
		// autofree_scope_vars(pos=75873 line_nr=3008 scope.pos=74880 scope.end_pos=76012)
		// var "type_end_pos" var.pos=74888 var.line_nr=2971
		// var "variant_types" var.pos=75508 var.line_nr=2995
		// var "prepend_mod_name" var.pos=75552 var.line_nr=2996
		// var "typ" var.pos=75594 var.line_nr=2997
		// af parent scope:
		// var "p" var.pos=73775 var.line_nr=2934
		// var "start_pos" var.pos=73813 var.line_nr=2935
		// var "is_pub" var.pos=73844 var.line_nr=2936
		// var "end_pos" var.pos=73925 var.line_nr=2941
		// var "decl_pos" var.pos=73954 var.line_nr=2942
		// var "name" var.pos=73993 var.line_nr=2943
		// var "sum_variants" var.pos=74198 var.line_nr=2949
		// var "type_pos" var.pos=74260 var.line_nr=2951
		// var "comments" var.pos=74294 var.line_nr=2952
		// var "first_type" var.pos=74714 var.line_nr=2968
		// var "type_alias_pos" var.pos=74821 var.line_nr=2969
		// var "parent_type" var.pos=76037 var.line_nr=3018
		// var "parent_sym" var.pos=76064 var.line_nr=3019
		// var "pidx" var.pos=76116 var.line_nr=3020
		// var "prepend_mod_name" var.pos=76196 var.line_nr=3022
		// var "idx" var.pos=76237 var.line_nr=3023
		// af parent scope:
		// af parent scope:
		return _t2685;
	}
	v__ast__Type parent_type = first_type;
	v__ast__TypeSymbol* parent_sym = v__ast__Table_get_type_symbol(p->table, parent_type);
	int pidx = v__ast__Type_idx(parent_type);
	v__parser__Parser_check_for_impure_v(p, parent_sym->language, decl_pos);
	string prepend_mod_name = v__parser__Parser_prepend_mod(p, name);
	int idx = v__ast__Table_register_type_symbol(p->table, (v__ast__TypeSymbol){
		.parent_idx = pidx,
		.info = v__ast__Alias_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__Alias, ((v__ast__Alias){.parent_type = parent_type,.language = parent_sym->language,.is_import = 0,}))),
		.kind = v__ast__Kind_alias,
		.name = prepend_mod_name,
		.cname = v__util__no_dots(prepend_mod_name),
		.methods = __new_array(0, 1, sizeof(v__ast__Fn)),
		.mod = p->mod,
		.is_public = is_pub,
		.language = 0,
	});
	if (idx == -1) {
		v__parser__Parser_error_with_pos(p, _STR("cannot register alias `%.*s\000`, another type with this name exists", 2, name), v__token__Position_extend(decl_pos, type_alias_pos));
		 v__ast__TypeDecl _t2686 = v__ast__AliasTypeDecl_to_sumtype_v__ast__TypeDecl(ADDR(v__ast__AliasTypeDecl, ((v__ast__AliasTypeDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.is_pub = 0,.parent_type = 0,.pos = {0},.type_pos = {0},.comments = __new_array(0, 1, sizeof(v__ast__Comment)),})));
		// autofree_scope_vars(pos=76650 line_nr=3038 scope.pos=76523 scope.end_pos=76679)
		// af parent scope:
		// var "p" var.pos=73775 var.line_nr=2934
		// var "start_pos" var.pos=73813 var.line_nr=2935
		// var "is_pub" var.pos=73844 var.line_nr=2936
		// var "end_pos" var.pos=73925 var.line_nr=2941
		// var "decl_pos" var.pos=73954 var.line_nr=2942
		// var "name" var.pos=73993 var.line_nr=2943
		// var "sum_variants" var.pos=74198 var.line_nr=2949
		// var "type_pos" var.pos=74260 var.line_nr=2951
		// var "comments" var.pos=74294 var.line_nr=2952
		// var "first_type" var.pos=74714 var.line_nr=2968
		// var "type_alias_pos" var.pos=74821 var.line_nr=2969
		// var "parent_type" var.pos=76037 var.line_nr=3018
		// var "parent_sym" var.pos=76064 var.line_nr=3019
		// var "pidx" var.pos=76116 var.line_nr=3020
		// var "prepend_mod_name" var.pos=76196 var.line_nr=3022
		// var "idx" var.pos=76237 var.line_nr=3023
		// af parent scope:
		// af parent scope:
		return _t2686;
	}
	if (idx == pidx) {
		v__parser__Parser_error_with_pos(p, _STR("a type alias can not refer to itself: %.*s", 1, name), v__token__Position_extend(decl_pos, type_alias_pos));
		 v__ast__TypeDecl _t2687 = v__ast__AliasTypeDecl_to_sumtype_v__ast__TypeDecl(ADDR(v__ast__AliasTypeDecl, ((v__ast__AliasTypeDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.is_pub = 0,.parent_type = 0,.pos = {0},.type_pos = {0},.comments = __new_array(0, 1, sizeof(v__ast__Comment)),})));
		// autofree_scope_vars(pos=76799 line_nr=3042 scope.pos=76697 scope.end_pos=76828)
		// af parent scope:
		// var "p" var.pos=73775 var.line_nr=2934
		// var "start_pos" var.pos=73813 var.line_nr=2935
		// var "is_pub" var.pos=73844 var.line_nr=2936
		// var "end_pos" var.pos=73925 var.line_nr=2941
		// var "decl_pos" var.pos=73954 var.line_nr=2942
		// var "name" var.pos=73993 var.line_nr=2943
		// var "sum_variants" var.pos=74198 var.line_nr=2949
		// var "type_pos" var.pos=74260 var.line_nr=2951
		// var "comments" var.pos=74294 var.line_nr=2952
		// var "first_type" var.pos=74714 var.line_nr=2968
		// var "type_alias_pos" var.pos=74821 var.line_nr=2969
		// var "parent_type" var.pos=76037 var.line_nr=3018
		// var "parent_sym" var.pos=76064 var.line_nr=3019
		// var "pidx" var.pos=76116 var.line_nr=3020
		// var "prepend_mod_name" var.pos=76196 var.line_nr=3022
		// var "idx" var.pos=76237 var.line_nr=3023
		// af parent scope:
		// af parent scope:
		return _t2687;
	}
	comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = true,.follow_up = 0,});
	 v__ast__TypeDecl _t2688 = v__ast__AliasTypeDecl_to_sumtype_v__ast__TypeDecl(ADDR(v__ast__AliasTypeDecl, ((v__ast__AliasTypeDecl){
		.name = name,
		.is_pub = is_pub,
		.parent_type = parent_type,
		.pos = decl_pos,
		.type_pos = type_pos,
		.comments = comments,
	})));
	// autofree_scope_vars(pos=76874 line_nr=3045 scope.pos=73770 scope.end_pos=77019)
	// var "p" var.pos=73775 var.line_nr=2934
	// var "start_pos" var.pos=73813 var.line_nr=2935
	// var "is_pub" var.pos=73844 var.line_nr=2936
	// var "end_pos" var.pos=73925 var.line_nr=2941
	// var "decl_pos" var.pos=73954 var.line_nr=2942
	// var "name" var.pos=73993 var.line_nr=2943
	// var "sum_variants" var.pos=74198 var.line_nr=2949
	// var "type_pos" var.pos=74260 var.line_nr=2951
	// var "comments" var.pos=74294 var.line_nr=2952
	// var "first_type" var.pos=74714 var.line_nr=2968
	// var "type_alias_pos" var.pos=74821 var.line_nr=2969
	// var "parent_type" var.pos=76037 var.line_nr=3018
	// var "parent_sym" var.pos=76064 var.line_nr=3019
	// var "pidx" var.pos=76116 var.line_nr=3020
	// var "prepend_mod_name" var.pos=76196 var.line_nr=3022
	// var "idx" var.pos=76237 var.line_nr=3023
	// af parent scope:
	// af parent scope:
	return _t2688;
}

VV_LOCAL_SYMBOL v__ast__Assoc v__parser__Parser_assoc(v__parser__Parser* p) {
	string var_name = v__parser__Parser_check_name(p);
	v__token__Position pos = v__token__Token_position(&p->tok);
	Option_v__ast__Var_ptr _t2689 = v__ast__Scope_find_var(p->scope, var_name);
	if (_t2689.state != 0) { /*or block*/ 
		IError err = _t2689.err;
		v__parser__Parser_error(p, _STR("unknown variable `%.*s\000`", 2, var_name));
		 v__ast__Assoc _t2690 = (v__ast__Assoc){.var_name = (string){.str=(byteptr)"", .is_lit=1},.fields = __new_array(0, 1, sizeof(string)),.exprs = __new_array(0, 1, sizeof(v__ast__Expr)),.pos = {0},.typ = 0,.scope = 0,};
		// autofree_scope_vars(pos=77198 line_nr=3060 scope.pos=77153 scope.end_pos=77234)
		// var "err" var.pos=77153 var.line_nr=3058
		// af parent scope:
		// var "p" var.pos=77030 var.line_nr=3055
		// var "var_name" var.pos=77061 var.line_nr=3056
		// var "pos" var.pos=77089 var.line_nr=3057
		// var "v" var.pos=77118 var.line_nr=3058
		// var "fields" var.pos=77303 var.line_nr=3066
		// var "vals" var.pos=77329 var.line_nr=3067
		// af parent scope:
		// af parent scope:
		return _t2690;
	}
 	v__ast__Var* v =  *(v__ast__Var**)_t2689.data;
	v->is_used = true;
	Array_string fields = __new_array_with_default(0, 0, sizeof(string), 0);
	Array_v__ast__Expr vals = __new_array_with_default(0, 0, sizeof(v__ast__Expr), 0);
	v__parser__Parser_check(p, v__token__Kind_pipe);
	for (;;) {
		if (!(p->tok.kind != v__token__Kind_eof)) break;
		array_push(&fields, _MOV((string[]){ string_clone(v__parser__Parser_check_name(p)) }));
		v__parser__Parser_check(p, v__token__Kind_colon);
		v__ast__Expr expr = v__parser__Parser_expr(p, 0);
		array_push(&vals, _MOV((v__ast__Expr[]){ expr }));
		if (p->tok.kind == v__token__Kind_comma) {
			v__parser__Parser_next(p);
		}
		if (p->tok.kind == v__token__Kind_rcbr) {
			break;
		}
	}
	 v__ast__Assoc _t2693 = (v__ast__Assoc){.var_name = var_name,.fields = fields,.exprs = vals,.pos = pos,.typ = 0,.scope = p->scope,};
	// autofree_scope_vars(pos=77559 line_nr=3081 scope.pos=77025 scope.end_pos=77661)
	// var "p" var.pos=77030 var.line_nr=3055
	// var "var_name" var.pos=77061 var.line_nr=3056
	// var "pos" var.pos=77089 var.line_nr=3057
	// var "v" var.pos=77118 var.line_nr=3058
	// var "fields" var.pos=77303 var.line_nr=3066
	// var "vals" var.pos=77329 var.line_nr=3067
	// af parent scope:
	// af parent scope:
	return _t2693;
}

VV_LOCAL_SYMBOL v__ast__Expr v__parser__Parser_new_true_expr(v__parser__Parser* p) {
	 v__ast__Expr _t2694 = v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, ((v__ast__BoolLiteral){.val = true,.pos = v__token__Token_position(&p->tok),})));
	// autofree_scope_vars(pos=77706 line_nr=3091 scope.pos=77667 scope.end_pos=77770)
	// var "p" var.pos=77668 var.line_nr=3090
	// af parent scope:
	// af parent scope:
	return _t2694;
}

VV_LOCAL_SYMBOL void v__parser__verror(string s) {
	v__util__verror(_SLIT("parser error"), s);
}

VV_LOCAL_SYMBOL void v__parser__Parser_top_level_statement_start(v__parser__Parser* p) {
	if (p->comments_mode == v__scanner__CommentsMode_toplevel_comments) {
		v__scanner__Scanner_set_is_inside_toplevel_statement(p->scanner, true);
		v__parser__Parser_rewind_scanner_to_current_token_in_new_mode(p);
	}
}

VV_LOCAL_SYMBOL void v__parser__Parser_top_level_statement_end(v__parser__Parser* p) {
	if (p->comments_mode == v__scanner__CommentsMode_toplevel_comments) {
		v__scanner__Scanner_set_is_inside_toplevel_statement(p->scanner, false);
		v__parser__Parser_rewind_scanner_to_current_token_in_new_mode(p);
	}
}

VV_LOCAL_SYMBOL void v__parser__Parser_rewind_scanner_to_current_token_in_new_mode(v__parser__Parser* p) {
	int tidx = p->tok.tidx;
	v__scanner__Scanner_set_current_tidx(p->scanner, tidx - 5);
	v__token__Token no_token = (v__token__Token){.kind = 0,.lit = (string){.str=(byteptr)"", .is_lit=1},.line_nr = 0,.col = 0,.pos = 0,.len = 0,.tidx = 0,};
	p->prev_tok = no_token;
	p->tok = no_token;
	p->peek_tok = no_token;
	for (;;) {
		v__parser__Parser_next(p);
		if (tidx == p->tok.tidx) {
			break;
		}
	}
}

bool v__parser__Parser_mark_var_as_used(v__parser__Parser* p, string varname) {
	Option_v__ast__ScopeObject _t2695;
	if (_t2695 = v__ast__Scope_find(p->scope, varname), _t2695.state == 0) {
		v__ast__ScopeObject obj = *(v__ast__ScopeObject*)_t2695.data;
		if (obj._typ == 312 /* v.ast.Var */) {
			(*obj._v__ast__Var).is_used = true;
			 bool _t2696 = true;
			// autofree_scope_vars(pos=79452 line_nr=3147 scope.pos=79416 scope.end_pos=79468)
			// var "obj" var.pos=79407 var.line_nr=3144
			// af parent scope:
			// af parent scope:
			// var "obj" var.pos=79364 var.line_nr=3143
			// af parent scope:
			// var "p" var.pos=79310 var.line_nr=3142
			// var "varname" var.pos=79337 var.line_nr=3142
			// af parent scope:
			// af parent scope:
			return _t2696;
		}
		else {
		};
	}
	 bool _t2697 = false;
	// autofree_scope_vars(pos=79488 line_nr=3152 scope.pos=79305 scope.end_pos=79502)
	// var "p" var.pos=79310 var.line_nr=3142
	// var "varname" var.pos=79337 var.line_nr=3142
	// af parent scope:
	// af parent scope:
	return _t2697;
}

VV_LOCAL_SYMBOL v__ast__Stmt v__parser__Parser_unsafe_stmt(v__parser__Parser* p) {
bool v__parser__Parser_unsafe_stmt_defer_0 = false;
	v__token__Position pos = v__token__Token_position(&p->tok);
	v__parser__Parser_next(p);
	if (p->tok.kind != v__token__Kind_lcbr) {
		 v__ast__Stmt _t2698 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _SLIT("please use `unsafe {`"), v__token__Token_position(&p->tok)))));
		// autofree_scope_vars(pos=79614 line_nr=3159 scope.pos=79611 scope.end_pos=79683)
		// af parent scope:
		// var "p" var.pos=79513 var.line_nr=3155
		// var "pos" var.pos=79553 var.line_nr=3156
		// var "stmt" var.pos=80068 var.line_nr=3180
		// var "stmts" var.pos=80509 var.line_nr=3201
		// af parent scope:
		// af parent scope:
		return _t2698;
	}
	v__parser__Parser_next(p);
	if (p->inside_unsafe) {
		 v__ast__Stmt _t2699 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _SLIT("already inside `unsafe` block"), pos))));
		// autofree_scope_vars(pos=79718 line_nr=3163 scope.pos=79715 scope.end_pos=79782)
		// af parent scope:
		// var "p" var.pos=79513 var.line_nr=3155
		// var "pos" var.pos=79553 var.line_nr=3156
		// var "stmt" var.pos=80068 var.line_nr=3180
		// var "stmts" var.pos=80509 var.line_nr=3201
		// af parent scope:
		// af parent scope:
		return _t2699;
	}
	if (p->tok.kind == v__token__Kind_rcbr) {
		v__token__Position_update_last_line(&pos, p->tok.line_nr);
		v__parser__Parser_next(p);
		 v__ast__Stmt _t2700 = v__ast__Block_to_sumtype_v__ast__Stmt(ADDR(v__ast__Block, ((v__ast__Block){.stmts = __new_array(0, 1, sizeof(v__ast__Stmt)),.is_unsafe = true,.pos = pos,})));
		// autofree_scope_vars(pos=79877 line_nr=3169 scope.pos=79808 scope.end_pos=79932)
		// af parent scope:
		// var "p" var.pos=79513 var.line_nr=3155
		// var "pos" var.pos=79553 var.line_nr=3156
		// var "stmt" var.pos=80068 var.line_nr=3180
		// var "stmts" var.pos=80509 var.line_nr=3201
		// af parent scope:
		// af parent scope:
		return _t2700;
	}
	p->inside_unsafe = true;
	v__parser__Parser_open_scope(p);
	v__parser__Parser_unsafe_stmt_defer_0 = true;
	v__ast__Stmt stmt = v__parser__Parser_stmt(p, false);
	if (p->tok.kind == v__token__Kind_rcbr) {
		if ((stmt)._typ == 293 /* v.ast.ExprStmt */) {
			if (v__ast__Expr_is_expr((*stmt._v__ast__ExprStmt).expr)) {
				v__parser__Parser_next(p);
				v__token__Position_update_last_line(&pos, p->prev_tok.line_nr);
				v__ast__UnsafeExpr ue = (v__ast__UnsafeExpr){.expr = (*stmt._v__ast__ExprStmt).expr,.pos = pos,};
				v__ast__Expr expr = v__parser__Parser_expr_with_left(p, v__ast__UnsafeExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__UnsafeExpr, (ue))), 0, p->is_stmt_ident);
				// Defer begin
				if (v__parser__Parser_unsafe_stmt_defer_0 == true) {
					p->inside_unsafe = false;
					v__parser__Parser_close_scope(p);
				}
				// Defer end
				 v__ast__Stmt _t2701 = v__ast__ExprStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__ExprStmt, ((v__ast__ExprStmt){.expr = expr,.pos = pos,.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.is_expr = 0,.typ = 0,})));
				// autofree_scope_vars(pos=80415 line_nr=3193 scope.pos=80192 scope.end_pos=80476)
				// var "ue" var.pos=80256 var.line_nr=3187
				// var "expr" var.pos=80363 var.line_nr=3192
				// af parent scope:
				// var "stmt" var.pos=80121 var.line_nr=3182
				// af parent scope:
				// af parent scope:
				// var "p" var.pos=79513 var.line_nr=3155
				// var "pos" var.pos=79553 var.line_nr=3156
				// var "stmt" var.pos=80068 var.line_nr=3180
				// var "stmts" var.pos=80509 var.line_nr=3201
				// af parent scope:
				// af parent scope:
				return _t2701;
			}
		}
	}
	Array_v__ast__Stmt stmts = new_array_from_c_array(1, 1, sizeof(v__ast__Stmt), _MOV((v__ast__Stmt[1]){stmt}));
	for (;;) {
		if (!(p->tok.kind != v__token__Kind_rcbr)) break;
		array_push(&stmts, _MOV((v__ast__Stmt[]){ v__parser__Parser_stmt(p, false) }));
	}
	v__parser__Parser_next(p);
	v__token__Position_update_last_line(&pos, p->tok.line_nr);
	// Defer begin
	if (v__parser__Parser_unsafe_stmt_defer_0 == true) {
		p->inside_unsafe = false;
		v__parser__Parser_close_scope(p);
	}
	// Defer end
	 v__ast__Stmt _t2703 = v__ast__Block_to_sumtype_v__ast__Stmt(ADDR(v__ast__Block, ((v__ast__Block){.stmts = stmts,.is_unsafe = true,.pos = pos,})));
	// autofree_scope_vars(pos=80627 line_nr=3207 scope.pos=79508 scope.end_pos=80693)
	// var "p" var.pos=79513 var.line_nr=3155
	// var "pos" var.pos=79553 var.line_nr=3156
	// var "stmt" var.pos=80068 var.line_nr=3180
	// var "stmts" var.pos=80509 var.line_nr=3201
	// af parent scope:
	// af parent scope:
	return _t2703;
}

VV_LOCAL_SYMBOL void v__parser__Parser_trace(v__parser__Parser* p, string fbase, string message) {
	if (string_eq(p->file_base, fbase)) {
		println(_STR("> p.trace | %*.*s\000 | %.*s", 2, fbase, -10, message));
	}
}

v__ast__Expr v__parser__Parser_expr(v__parser__Parser* p, int precedence) {
	v__ast__Expr node = v__ast__empty_expr();
	bool is_stmt_ident = p->is_stmt_ident;
	p->is_stmt_ident = false;
	if (!p->pref->is_fmt) {
		v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,});
	}

	if (p->tok.kind == (v__token__Kind_key_mut) || p->tok.kind == (v__token__Kind_key_shared) || p->tok.kind == (v__token__Kind_key_atomic) || p->tok.kind == (v__token__Kind_key_static)) {
		node = v__ast__Ident_to_sumtype_v__ast__Expr(ADDR(v__ast__Ident, (v__parser__Parser_parse_ident(p, v__ast__Language_v))));
		p->is_stmt_ident = is_stmt_ident;
	}
	else if (p->tok.kind == (v__token__Kind_name) || p->tok.kind == (v__token__Kind_question)) {
		if (string_eq(p->tok.lit, _SLIT("sql")) && p->peek_tok.kind == v__token__Kind_name) {
			p->inside_match = true;
			node = v__parser__Parser_sql_expr(p);
			p->inside_match = false;
		} else if (string_eq(p->tok.lit, _SLIT("map")) && p->peek_tok.kind == v__token__Kind_lcbr && !(p->builtin_mod && string_eq(p->file_base, _SLIT("map.v")))) {
			v__parser__Parser_next(p);
			v__parser__Parser_next(p);
			node = v__ast__MapInit_to_sumtype_v__ast__Expr(ADDR(v__ast__MapInit, (v__parser__Parser_map_init(p))));
			v__parser__Parser_check(p, v__token__Kind_rcbr);
		} else {
			if (p->inside_if && v__parser__Parser_is_generic_name(/*rec*/*p)) {
				p->expecting_type = true;
			}
			node = v__parser__Parser_name_expr(p);
			p->is_stmt_ident = is_stmt_ident;
		}
	}
	else if (p->tok.kind == (v__token__Kind_string)) {
		node = v__parser__Parser_string_expr(p);
	}
	else if (p->tok.kind == (v__token__Kind_comment)) {
		node = v__ast__Comment_to_sumtype_v__ast__Expr(ADDR(v__ast__Comment, (v__parser__Parser_comment(p))));
		// autofree_scope_vars(pos=1511 line_nr=52 scope.pos=1476 scope.end_pos=1526)
		// af parent scope:
		// var "p" var.pos=239 var.line_nr=9
		// var "precedence" var.pos=254 var.line_nr=9
		// var "node" var.pos=531 var.line_nr=15
		// var "is_stmt_ident" var.pos=557 var.line_nr=16
		// af parent scope:
		// af parent scope:
		return node;
	}
	else if (p->tok.kind == (v__token__Kind_dot)) {
		node = v__ast__EnumVal_to_sumtype_v__ast__Expr(ADDR(v__ast__EnumVal, (v__parser__Parser_enum_val(p))));
	}
	else if (p->tok.kind == (v__token__Kind_at)) {
		node = v__ast__AtExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__AtExpr, (v__parser__Parser_at(p))));
	}
	else if (p->tok.kind == (v__token__Kind_dollar)) {

		if (p->peek_tok.kind == (v__token__Kind_name)) {
			 v__ast__Expr _t2704 = v__ast__ComptimeCall_to_sumtype_v__ast__Expr(ADDR(v__ast__ComptimeCall, (v__parser__Parser_comp_call(p))));
			// autofree_scope_vars(pos=1664 line_nr=64 scope.pos=1652 scope.end_pos=1690)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=239 var.line_nr=9
			// var "precedence" var.pos=254 var.line_nr=9
			// var "node" var.pos=531 var.line_nr=15
			// var "is_stmt_ident" var.pos=557 var.line_nr=16
			// af parent scope:
			// af parent scope:
			return _t2704;
		}
		else if (p->peek_tok.kind == (v__token__Kind_key_if)) {
			 v__ast__Expr _t2705 = v__ast__IfExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__IfExpr, (v__parser__Parser_if_expr(p, true))));
			// autofree_scope_vars(pos=1710 line_nr=67 scope.pos=1696 scope.end_pos=1738)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=239 var.line_nr=9
			// var "precedence" var.pos=254 var.line_nr=9
			// var "node" var.pos=531 var.line_nr=15
			// var "is_stmt_ident" var.pos=557 var.line_nr=16
			// af parent scope:
			// af parent scope:
			return _t2705;
		}
		else {
			 v__ast__Expr _t2706 = v__ast__NodeError_to_sumtype_v__ast__Expr(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _SLIT("unexpected `$`"), v__token__Token_position(&p->peek_tok)))));
			// autofree_scope_vars(pos=1755 line_nr=70 scope.pos=1744 scope.end_pos=1825)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=239 var.line_nr=9
			// var "precedence" var.pos=254 var.line_nr=9
			// var "node" var.pos=531 var.line_nr=15
			// var "is_stmt_ident" var.pos=557 var.line_nr=16
			// af parent scope:
			// af parent scope:
			return _t2706;
		};
	}
	else if (p->tok.kind == (v__token__Kind_chartoken)) {
		node = v__ast__CharLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__CharLiteral, ((v__ast__CharLiteral){.val = p->tok.lit,.pos = v__token__Token_position(&p->tok),})));
		v__parser__Parser_next(p);
	}
	else if (p->tok.kind == (v__token__Kind_amp) || p->tok.kind == (v__token__Kind_mul) || p->tok.kind == (v__token__Kind_not) || p->tok.kind == (v__token__Kind_bit_not) || p->tok.kind == (v__token__Kind_arrow)) {
		node = v__ast__PrefixExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__PrefixExpr, (v__parser__Parser_prefix_expr(p))));
	}
	else if (p->tok.kind == (v__token__Kind_minus)) {
		if (p->peek_tok.kind == v__token__Kind_number) {
			node = v__parser__Parser_parse_number_literal(p);
		} else {
			node = v__ast__PrefixExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__PrefixExpr, (v__parser__Parser_prefix_expr(p))));
		}
	}
	else if (p->tok.kind == (v__token__Kind_key_go)) {
		v__ast__Stmt stmt = v__parser__Parser_stmt(p, false);
		v__ast__GoStmt go_stmt = /* as */ *(v__ast__GoStmt*)__as_cast((stmt)._v__ast__GoStmt,(stmt)._typ, 298) /*expected idx: 298, name: v.ast.GoStmt */ ;
		node = v__ast__GoExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__GoExpr, ((v__ast__GoExpr){.pos = go_stmt.pos,.go_stmt = go_stmt,.return_type = 0,})));
	}
	else if (p->tok.kind == (v__token__Kind_key_true) || p->tok.kind == (v__token__Kind_key_false)) {
		node = v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, ((v__ast__BoolLiteral){.val = p->tok.kind == v__token__Kind_key_true,.pos = v__token__Token_position(&p->tok),})));
		v__parser__Parser_next(p);
	}
	else if (p->tok.kind == (v__token__Kind_key_match)) {
		node = v__ast__MatchExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__MatchExpr, (v__parser__Parser_match_expr(p))));
	}
	else if (p->tok.kind == (v__token__Kind_key_select)) {
		node = v__ast__SelectExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__SelectExpr, (v__parser__Parser_select_expr(p))));
	}
	else if (p->tok.kind == (v__token__Kind_number)) {
		node = v__parser__Parser_parse_number_literal(p);
	}
	else if (p->tok.kind == (v__token__Kind_lpar)) {
		v__token__Position pos = v__token__Token_position(&p->tok);
		v__parser__Parser_check(p, v__token__Kind_lpar);
		node = v__parser__Parser_expr(p, 0);
		v__parser__Parser_check(p, v__token__Kind_rpar);
		node = v__ast__ParExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__ParExpr, ((v__ast__ParExpr){.expr = node,.pos = v__token__Position_extend(pos, v__token__Token_position(&p->prev_tok)),})));
	}
	else if (p->tok.kind == (v__token__Kind_key_if)) {
		node = v__ast__IfExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__IfExpr, (v__parser__Parser_if_expr(p, false))));
	}
	else if (p->tok.kind == (v__token__Kind_key_unsafe)) {
		v__token__Position pos = v__token__Token_position(&p->tok);
		v__parser__Parser_next(p);
		if (p->inside_unsafe) {
			 v__ast__Expr _t2707 = v__ast__NodeError_to_sumtype_v__ast__Expr(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _SLIT("already inside `unsafe` block"), pos))));
			// autofree_scope_vars(pos=2930 line_nr=135 scope.pos=2925 scope.end_pos=2996)
			// af parent scope:
			// var "pos" var.pos=2867 var.line_nr=132
			// var "e" var.pos=3045 var.line_nr=139
			// af parent scope:
			// var "p" var.pos=239 var.line_nr=9
			// var "precedence" var.pos=254 var.line_nr=9
			// var "node" var.pos=531 var.line_nr=15
			// var "is_stmt_ident" var.pos=557 var.line_nr=16
			// af parent scope:
			// af parent scope:
			return _t2707;
		}
		p->inside_unsafe = true;
		v__parser__Parser_check(p, v__token__Kind_lcbr);
		v__ast__Expr e = v__parser__Parser_expr(p, 0);
		v__parser__Parser_check(p, v__token__Kind_rcbr);
		v__token__Position_update_last_line(&pos, p->prev_tok.line_nr);
		node = v__ast__UnsafeExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__UnsafeExpr, ((v__ast__UnsafeExpr){.expr = e,.pos = pos,})));
		p->inside_unsafe = false;
	}
	else if (p->tok.kind == (v__token__Kind_key_lock) || p->tok.kind == (v__token__Kind_key_rlock)) {
		node = v__ast__LockExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__LockExpr, (v__parser__Parser_lock_expr(p))));
	}
	else if (p->tok.kind == (v__token__Kind_lsbr)) {
		if (p->expecting_type) {
			node = v__parser__Parser_name_expr(p);
		} else if (p->is_amp && p->peek_tok.kind == v__token__Kind_rsbr && v__parser__Parser_peek_token(p, 3).kind != v__token__Kind_lcbr) {
			v__token__Position pos = v__token__Token_position(&p->tok);
			v__ast__Type typ = v__ast__Type_to_ptr(v__parser__Parser_parse_type(p));
			v__parser__Parser_check(p, v__token__Kind_lpar);
			v__ast__Expr expr = v__parser__Parser_expr(p, 0);
			v__parser__Parser_check(p, v__token__Kind_rpar);
			node = v__ast__CastExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__CastExpr, ((v__ast__CastExpr){.expr = expr,.arg = {0},.typ = typ,.pos = pos,.typname = (string){.str=(byteptr)"", .is_lit=1},.expr_type = 0,.has_arg = 0,.in_prexpr = 0,})));
		} else {
			node = v__ast__ArrayInit_to_sumtype_v__ast__Expr(ADDR(v__ast__ArrayInit, (v__parser__Parser_array_init(p))));
		}
	}
	else if (p->tok.kind == (v__token__Kind_key_none)) {
		v__token__Position pos = v__token__Token_position(&p->tok);
		v__parser__Parser_next(p);
		node = v__ast__None_to_sumtype_v__ast__Expr(ADDR(v__ast__None, ((v__ast__None){.pos = pos,})));
	}
	else if (p->tok.kind == (v__token__Kind_key_sizeof)) {
		v__parser__Parser_next(p);
		v__parser__Parser_check(p, v__token__Kind_lpar);
		v__token__Position pos = v__token__Token_position(&p->tok);
		bool is_known_var = v__parser__Parser_mark_var_as_used(p, p->tok.lit);
		if (is_known_var || !(v__parser__Parser_known_import(p, p->tok.lit) || v__token__Kind_is_start_of_type(p->tok.kind))) {
			v__ast__Expr expr = v__parser__Parser_expr(p, 0);
			node = v__ast__SizeOf_to_sumtype_v__ast__Expr(ADDR(v__ast__SizeOf, ((v__ast__SizeOf){.is_type = false,.expr = expr,.pos = pos,.typ = 0,})));
		} else {
			if (p->tok.kind == v__token__Kind_name) {
				v__parser__Parser_register_used_import(p, p->tok.lit);
			}
			string save_expr_mod = p->expr_mod;
			p->expr_mod = _SLIT("");
			v__ast__Type sizeof_type = v__parser__Parser_parse_type(p);
			p->expr_mod = save_expr_mod;
			node = v__ast__SizeOf_to_sumtype_v__ast__Expr(ADDR(v__ast__SizeOf, ((v__ast__SizeOf){.is_type = true,.expr = {0},.pos = pos,.typ = sizeof_type,})));
		}
		v__parser__Parser_check(p, v__token__Kind_rpar);
	}
	else if (p->tok.kind == (v__token__Kind_key_typeof)) {
		v__token__Position spos = v__token__Token_position(&p->tok);
		v__parser__Parser_next(p);
		v__parser__Parser_check(p, v__token__Kind_lpar);
		v__ast__Expr expr = v__parser__Parser_expr(p, 0);
		v__parser__Parser_check(p, v__token__Kind_rpar);
		if (p->tok.kind != v__token__Kind_dot && p->tok.line_nr == p->prev_tok.line_nr) {
			v__parser__Parser_warn_with_pos(p, _SLIT("use e.g. `typeof(expr).name` or `sum_type_instance.type_name()` instead"), spos);
		}
		node = v__ast__TypeOf_to_sumtype_v__ast__Expr(ADDR(v__ast__TypeOf, ((v__ast__TypeOf){.expr = expr,.pos = v__token__Position_extend(spos, v__token__Token_position(&p->tok)),.expr_type = 0,})));
	}
	else if (p->tok.kind == (v__token__Kind_key_dump)) {
		v__token__Position spos = v__token__Token_position(&p->tok);
		v__parser__Parser_next(p);
		v__parser__Parser_check(p, v__token__Kind_lpar);
		v__ast__Expr expr = v__parser__Parser_expr(p, 0);
		v__parser__Parser_check(p, v__token__Kind_rpar);
		node = v__ast__DumpExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__DumpExpr, ((v__ast__DumpExpr){.expr = expr,.pos = v__token__Position_extend(spos, v__token__Token_position(&p->tok)),.expr_type = 0,.cname = (string){.str=(byteptr)"", .is_lit=1},})));
	}
	else if (p->tok.kind == (v__token__Kind_key_offsetof)) {
		v__token__Position pos = v__token__Token_position(&p->tok);
		v__parser__Parser_next(p);
		v__parser__Parser_check(p, v__token__Kind_lpar);
		v__ast__Type st = v__parser__Parser_parse_type(p);
		v__parser__Parser_check(p, v__token__Kind_comma);
		if (p->tok.kind != v__token__Kind_name) {
			 v__ast__Expr _t2708 = v__ast__NodeError_to_sumtype_v__ast__Expr(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _STR("unexpected `%.*s\000`, expecting struct field", 2, p->tok.lit), v__token__Token_position(&p->tok)))));
			// autofree_scope_vars(pos=5215 line_nr=239 scope.pos=5210 scope.end_pos=5317)
			// af parent scope:
			// var "pos" var.pos=5073 var.line_nr=233
			// var "st" var.pos=5144 var.line_nr=236
			// var "field" var.pos=5322 var.line_nr=242
			// af parent scope:
			// var "p" var.pos=239 var.line_nr=9
			// var "precedence" var.pos=254 var.line_nr=9
			// var "node" var.pos=531 var.line_nr=15
			// var "is_stmt_ident" var.pos=557 var.line_nr=16
			// af parent scope:
			// af parent scope:
			return _t2708;
		}
		string field = p->tok.lit;
		v__parser__Parser_next(p);
		v__parser__Parser_check(p, v__token__Kind_rpar);
		node = v__ast__OffsetOf_to_sumtype_v__ast__Expr(ADDR(v__ast__OffsetOf, ((v__ast__OffsetOf){.struct_type = st,.field = field,.pos = pos,})));
	}
	else if (p->tok.kind == (v__token__Kind_key_likely) || p->tok.kind == (v__token__Kind_key_unlikely)) {
		bool is_likely = p->tok.kind == v__token__Kind_key_likely;
		v__parser__Parser_next(p);
		v__parser__Parser_check(p, v__token__Kind_lpar);
		v__token__Position lpos = v__token__Token_position(&p->tok);
		v__ast__Expr expr = v__parser__Parser_expr(p, 0);
		v__parser__Parser_check(p, v__token__Kind_rpar);
		node = v__ast__Likely_to_sumtype_v__ast__Expr(ADDR(v__ast__Likely, ((v__ast__Likely){.expr = expr,.pos = lpos,.is_likely = is_likely,})));
	}
	else if (p->tok.kind == (v__token__Kind_lcbr)) {
		v__parser__Parser_next(p);
		if ((p->tok.kind == v__token__Kind_chartoken || p->tok.kind == v__token__Kind_number || p->tok.kind == v__token__Kind_string)) {
			node = v__ast__MapInit_to_sumtype_v__ast__Expr(ADDR(v__ast__MapInit, (v__parser__Parser_map_init(p))));
		} else {
			if (p->tok.kind == v__token__Kind_name && p->peek_tok.kind == v__token__Kind_pipe) {
				v__parser__Parser_warn_with_pos(p, _SLIT("use e.g. `...struct_var` instead"), v__token__Token_position(&p->peek_tok));
				node = v__ast__Assoc_to_sumtype_v__ast__Expr(ADDR(v__ast__Assoc, (v__parser__Parser_assoc(p))));
			} else if ((p->tok.kind == v__token__Kind_name && p->peek_tok.kind == v__token__Kind_colon) || (p->tok.kind == v__token__Kind_rcbr || p->tok.kind == v__token__Kind_comment || p->tok.kind == v__token__Kind_ellipsis)) {
				node = v__ast__StructInit_to_sumtype_v__ast__Expr(ADDR(v__ast__StructInit, (v__parser__Parser_struct_init(p, true))));
			} else if (p->tok.kind == v__token__Kind_name) {
				v__parser__Parser_next(p);
				 v__ast__Expr _t2709 = v__ast__NodeError_to_sumtype_v__ast__Expr(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _STR("unexpected %.*s\000, expecting `:` after struct field name", 2, v__token__Token_str(p->tok)), v__token__Token_position(&p->tok)))));
				// autofree_scope_vars(pos=6307 line_nr=280 scope.pos=6287 scope.end_pos=6420)
				// af parent scope:
				// af parent scope:
				// af parent scope:
				// var "p" var.pos=239 var.line_nr=9
				// var "precedence" var.pos=254 var.line_nr=9
				// var "node" var.pos=531 var.line_nr=15
				// var "is_stmt_ident" var.pos=557 var.line_nr=16
				// af parent scope:
				// af parent scope:
				return _t2709;
			} else {
				 v__ast__Expr _t2710 = v__ast__NodeError_to_sumtype_v__ast__Expr(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _STR("unexpected %.*s\000, expecting struct field name", 2, v__token__Token_str(p->tok)), v__token__Token_position(&p->tok)))));
				// autofree_scope_vars(pos=6433 line_nr=283 scope.pos=6427 scope.end_pos=6536)
				// af parent scope:
				// af parent scope:
				// af parent scope:
				// var "p" var.pos=239 var.line_nr=9
				// var "precedence" var.pos=254 var.line_nr=9
				// var "node" var.pos=531 var.line_nr=15
				// var "is_stmt_ident" var.pos=557 var.line_nr=16
				// af parent scope:
				// af parent scope:
				return _t2710;
			}
		}
		v__parser__Parser_check(p, v__token__Kind_rcbr);
	}
	else if (p->tok.kind == (v__token__Kind_key_fn)) {
		if (p->expecting_type) {
			v__token__Position start_pos = v__token__Token_position(&p->tok);
			 v__ast__Expr _t2711 = v__ast__TypeNode_to_sumtype_v__ast__Expr(ADDR(v__ast__TypeNode, ((v__ast__TypeNode){.typ = v__parser__Parser_parse_type(p),.pos = v__token__Position_extend(start_pos, v__token__Token_position(&p->prev_tok)),})));
			// autofree_scope_vars(pos=6670 line_nr=293 scope.pos=6600 scope.end_pos=6776)
			// var "start_pos" var.pos=6637 var.line_nr=292
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=239 var.line_nr=9
			// var "precedence" var.pos=254 var.line_nr=9
			// var "node" var.pos=531 var.line_nr=15
			// var "is_stmt_ident" var.pos=557 var.line_nr=16
			// af parent scope:
			// af parent scope:
			return _t2711;
		} else {
			node = v__ast__AnonFn_to_sumtype_v__ast__Expr(ADDR(v__ast__AnonFn, (v__parser__Parser_anon_fn(p))));
			if (p->tok.kind == v__token__Kind_lpar) {
				v__parser__Parser_next(p);
				v__token__Position pos = v__token__Token_position(&p->tok);
				Array_v__ast__CallArg args = v__parser__Parser_call_args(p);
				v__parser__Parser_check(p, v__token__Kind_rpar);
				node = v__ast__CallExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__CallExpr, ((v__ast__CallExpr){.pos = pos,.name_pos = {0},.mod = (string){.str=(byteptr)"", .is_lit=1},.name = _SLIT("anon"),.is_method = 0,.is_field = 0,.is_keep_alive = 0,.args = args,.expected_arg_types = __new_array(0, 1, sizeof(v__ast__Type)),.language = 0,.or_block = (v__ast__OrExpr){.stmts = __new_array(0, 1, sizeof(v__ast__Stmt)),},.left = node,.left_type = 0,.receiver_type = 0,.return_type = 0,.should_be_skipped = 0,.generic_types = __new_array(0, 1, sizeof(v__ast__Type)),.generic_list_pos = {0},.free_receiver = 0,.scope = p->scope,.from_embed_type = 0,.comments = __new_array(0, 1, sizeof(v__ast__Comment)),})));
			}
			// autofree_scope_vars(pos=7287 line_nr=317 scope.pos=6783 scope.end_pos=7303)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=239 var.line_nr=9
			// var "precedence" var.pos=254 var.line_nr=9
			// var "node" var.pos=531 var.line_nr=15
			// var "is_stmt_ident" var.pos=557 var.line_nr=16
			// af parent scope:
			// af parent scope:
			return node;
		}
	}
	else {
		if (p->tok.kind != v__token__Kind_eof && !(p->tok.kind == v__token__Kind_rsbr && p->inside_asm)) {
			 v__ast__Expr _t2712 = v__ast__NodeError_to_sumtype_v__ast__Expr(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _STR("invalid expression: unexpected %.*s", 1, v__token__Token_str(p->tok)), v__token__Token_position(&p->tok)))));
			// autofree_scope_vars(pos=7436 line_nr=323 scope.pos=7385 scope.end_pos=7523)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=239 var.line_nr=9
			// var "precedence" var.pos=254 var.line_nr=9
			// var "node" var.pos=531 var.line_nr=15
			// var "is_stmt_ident" var.pos=557 var.line_nr=16
			// af parent scope:
			// af parent scope:
			return _t2712;
		}
	};
	 v__ast__Expr _t2713 = v__parser__Parser_expr_with_left(p, node, precedence, is_stmt_ident);
	// autofree_scope_vars(pos=7532 line_nr=327 scope.pos=234 scope.end_pos=7590)
	// var "p" var.pos=239 var.line_nr=9
	// var "precedence" var.pos=254 var.line_nr=9
	// var "node" var.pos=531 var.line_nr=15
	// var "is_stmt_ident" var.pos=557 var.line_nr=16
	// af parent scope:
	// af parent scope:
	return _t2713;
}

v__ast__Expr v__parser__Parser_expr_with_left(v__parser__Parser* p, v__ast__Expr left, int precedence, bool is_stmt_ident) {
	v__ast__Expr node = left;
	for (;;) {
		if (!(precedence < v__token__Token_precedence(p->tok))) break;
		if (p->tok.kind == v__token__Kind_dot) {
			node = v__parser__Parser_dot_expr(p, node);
			if (p->name_error) {
				// autofree_scope_vars(pos=7836 line_nr=337 scope.pos=7831 scope.end_pos=7852)
				// af parent scope:
				// af parent scope:
				// af parent scope:
				// af parent scope:
				// var "p" var.pos=7605 var.line_nr=330
				// var "left" var.pos=7630 var.line_nr=330
				// var "precedence" var.pos=7645 var.line_nr=330
				// var "is_stmt_ident" var.pos=7661 var.line_nr=330
				// var "node" var.pos=7697 var.line_nr=331
				// af parent scope:
				// af parent scope:
				return node;
			}
			p->is_stmt_ident = is_stmt_ident;
		} else if (p->tok.kind == v__token__Kind_lsbr && (p->inside_fn || p->tok.line_nr == p->prev_tok.line_nr)) {
			node = v__ast__IndexExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__IndexExpr, (v__parser__Parser_index_expr(p, node))));
			p->is_stmt_ident = is_stmt_ident;
			if (p->tok.kind == v__token__Kind_lpar && p->tok.line_nr == p->prev_tok.line_nr && (node)._typ == 257 /* v.ast.IndexExpr */) {
				v__parser__Parser_next(p);
				v__token__Position pos = v__token__Token_position(&p->tok);
				Array_v__ast__CallArg args = v__parser__Parser_call_args(p);
				v__parser__Parser_check(p, v__token__Kind_rpar);
				node = v__ast__CallExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__CallExpr, ((v__ast__CallExpr){.pos = pos,.name_pos = {0},.mod = (string){.str=(byteptr)"", .is_lit=1},.name = (string){.str=(byteptr)"", .is_lit=1},.is_method = 0,.is_field = 0,.is_keep_alive = 0,.args = args,.expected_arg_types = __new_array(0, 1, sizeof(v__ast__Type)),.language = 0,.or_block = (v__ast__OrExpr){.stmts = __new_array(0, 1, sizeof(v__ast__Stmt)),},.left = node,.left_type = 0,.receiver_type = 0,.return_type = 0,.should_be_skipped = 0,.generic_types = __new_array(0, 1, sizeof(v__ast__Type)),.generic_list_pos = {0},.free_receiver = 0,.scope = p->scope,.from_embed_type = 0,.comments = __new_array(0, 1, sizeof(v__ast__Comment)),})));
				p->is_stmt_ident = is_stmt_ident;
			}
		} else if (p->tok.kind == v__token__Kind_key_as) {
			if (!p->inside_asm) {
				v__token__Position pos = v__token__Token_position(&p->tok);
				v__parser__Parser_next(p);
				v__ast__Type typ = v__parser__Parser_parse_type(p);
				node = v__ast__AsCast_to_sumtype_v__ast__Expr(ADDR(v__ast__AsCast, ((v__ast__AsCast){.expr = node,.typ = typ,.pos = pos,.expr_type = 0,})));
			} else {
				// autofree_scope_vars(pos=8621 line_nr=368 scope.pos=8616 scope.end_pos=8637)
				// af parent scope:
				// af parent scope:
				// af parent scope:
				// af parent scope:
				// var "p" var.pos=7605 var.line_nr=330
				// var "left" var.pos=7630 var.line_nr=330
				// var "precedence" var.pos=7645 var.line_nr=330
				// var "is_stmt_ident" var.pos=7661 var.line_nr=330
				// var "node" var.pos=7697 var.line_nr=331
				// af parent scope:
				// af parent scope:
				return node;
			}
		} else if (p->tok.kind == v__token__Kind_left_shift && p->is_stmt_ident) {
			v__token__Token tok = p->tok;
			v__token__Position pos = v__token__Token_position(&tok);
			v__parser__Parser_next(p);
			v__ast__Expr right = v__parser__Parser_expr(p, precedence - 1);
			v__token__Position_update_last_line(&pos, p->prev_tok.line_nr);
			if ((node)._typ == 257 /* v.ast.IndexExpr */) {
				v__ast__IndexExpr_recursive_mapset_is_setter(&(*node._v__ast__IndexExpr), true);
			}
			node = v__ast__InfixExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__InfixExpr, ((v__ast__InfixExpr){.op = tok.kind,.pos = pos,.is_stmt = true,.left = node,.right = right,.left_type = 0,.right_type = 0,.auto_locked = (string){.str=(byteptr)"", .is_lit=1},.or_block = (v__ast__OrExpr){.stmts = __new_array(0, 1, sizeof(v__ast__Stmt)),},})));
		} else if (v__token__Kind_is_infix(p->tok.kind)) {
			if (v__token__Kind_is_prefix(p->tok.kind) && p->tok.line_nr != p->prev_tok.line_nr) {
				if (p->tok.kind == v__token__Kind_mul && v__parser__Parser_peek_token(p, 2).kind == v__token__Kind_assign) {
					// autofree_scope_vars(pos=9282 line_nr=391 scope.pos=9276 scope.end_pos=9299)
					// af parent scope:
					// af parent scope:
					// af parent scope:
					// af parent scope:
					// af parent scope:
					// var "p" var.pos=7605 var.line_nr=330
					// var "left" var.pos=7630 var.line_nr=330
					// var "precedence" var.pos=7645 var.line_nr=330
					// var "is_stmt_ident" var.pos=7661 var.line_nr=330
					// var "node" var.pos=7697 var.line_nr=331
					// af parent scope:
					// af parent scope:
					return node;
				}
				v__parser__Parser_warn_with_pos(p, _STR("move infix `%.*s\000` operator before new line (if infix intended) or use brackets for a prefix expression", 2, v__token__Kind_str(p->tok.kind)), v__token__Token_position(&p->tok));
			}
			node = v__parser__Parser_infix_expr(p, node);
			if (p->tok.kind == v__token__Kind_key_as && p->inside_if) {
				// autofree_scope_vars(pos=9684 line_nr=401 scope.pos=9679 scope.end_pos=9700)
				// af parent scope:
				// af parent scope:
				// af parent scope:
				// af parent scope:
				// var "p" var.pos=7605 var.line_nr=330
				// var "left" var.pos=7630 var.line_nr=330
				// var "precedence" var.pos=7645 var.line_nr=330
				// var "is_stmt_ident" var.pos=7661 var.line_nr=330
				// var "node" var.pos=7697 var.line_nr=331
				// af parent scope:
				// af parent scope:
				return node;
			}
		} else if ((p->tok.kind == v__token__Kind_inc || p->tok.kind == v__token__Kind_dec) || (p->tok.kind == v__token__Kind_question && p->inside_ct_if_expr)) {
			if ((p->peek_tok.kind == v__token__Kind_rpar || p->peek_tok.kind == v__token__Kind_rsbr) && !(string_eq(p->mod, _SLIT("builtin")) || string_eq(p->mod, _SLIT("regex")) || string_eq(p->mod, _SLIT("strconv")))) {
				v__parser__Parser_warn_with_pos(p, _STR("`%.*s\000` operator can only be used as a statement", 2, v__token__Kind_str(p->tok.kind)), v__token__Token_position(&p->peek_tok));
			}
			if ((p->tok.kind == v__token__Kind_inc || p->tok.kind == v__token__Kind_dec) && p->prev_tok.line_nr != p->tok.line_nr) {
				v__parser__Parser_error_with_pos(p, _STR("%.*s\000 must be on the same line as the previous token", 2, v__token__Token_str(p->tok)), v__token__Token_position(&p->tok));
			}
			if ((node)._typ == 257 /* v.ast.IndexExpr */) {
				v__ast__IndexExpr_recursive_mapset_is_setter(&(*node._v__ast__IndexExpr), true);
			}
			node = v__ast__PostfixExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__PostfixExpr, ((v__ast__PostfixExpr){.op = p->tok.kind,.expr = node,.pos = v__token__Token_position(&p->tok),.auto_locked = (string){.str=(byteptr)"", .is_lit=1},})));
			v__parser__Parser_next(p);
		} else {
			// autofree_scope_vars(pos=10508 line_nr=425 scope.pos=10504 scope.end_pos=10523)
			// af parent scope:
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=7605 var.line_nr=330
			// var "left" var.pos=7630 var.line_nr=330
			// var "precedence" var.pos=7645 var.line_nr=330
			// var "is_stmt_ident" var.pos=7661 var.line_nr=330
			// var "node" var.pos=7697 var.line_nr=331
			// af parent scope:
			// af parent scope:
			return node;
		}
	}
	// autofree_scope_vars(pos=10528 line_nr=428 scope.pos=7600 scope.end_pos=10541)
	// var "p" var.pos=7605 var.line_nr=330
	// var "left" var.pos=7630 var.line_nr=330
	// var "precedence" var.pos=7645 var.line_nr=330
	// var "is_stmt_ident" var.pos=7661 var.line_nr=330
	// var "node" var.pos=7697 var.line_nr=331
	// af parent scope:
	// af parent scope:
	return node;
}

VV_LOCAL_SYMBOL v__ast__Expr v__parser__Parser_infix_expr(v__parser__Parser* p, v__ast__Expr left) {
	v__token__Kind op = p->tok.kind;
	if (op == v__token__Kind_arrow) {
		p->or_is_handled = true;
		v__parser__Parser_register_auto_import(p, _SLIT("sync"));
	}
	int precedence = v__token__Token_precedence(p->tok);
	v__token__Position pos = v__token__Token_position(&p->tok);
	v__parser__Parser_next(p);
	v__ast__Expr right = v__ast__empty_expr();
	bool prev_expecting_type = p->expecting_type;
	if ((op == v__token__Kind_key_is || op == v__token__Kind_not_is)) {
		p->expecting_type = true;
	}
	right = v__parser__Parser_expr(p, precedence);
	p->expecting_type = prev_expecting_type;
	if (p->pref->is_vet && (op == v__token__Kind_key_in || op == v__token__Kind_not_in) && (right)._typ == 235 /* v.ast.ArrayInit */ && (/* as */ *(v__ast__ArrayInit*)__as_cast((right)._v__ast__ArrayInit,(right)._typ, 235) /*expected idx: 235, name: v.ast.ArrayInit */ ).exprs.len == 1) {
		v__parser__Parser_vet_error(p, _SLIT("Use `var == value` instead of `var in [value]`"), pos.line_nr, v__vet__FixKind_vfmt, v__vet__ErrorType_default);
	}
	Array_v__ast__Stmt or_stmts = __new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
	v__ast__OrKind or_kind = v__ast__OrKind_absent;
	v__token__Position or_pos = v__token__Token_position(&p->tok);
	if (op == v__token__Kind_arrow) {
		if (p->tok.kind == v__token__Kind_key_orelse) {
			v__parser__Parser_next(p);
			v__parser__Parser_open_scope(p);
			v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){.name = _SLIT("err"),.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.is_auto_deref = 0,.typ = _const_v__ast__error_type,.orig_type = 0,.smartcasts = __new_array(0, 1, sizeof(v__ast__Type)),.pos = v__token__Token_position(&p->tok),.is_used = true,.is_changed = 0,.is_or = 0,.is_tmp = 0,}))));
			or_kind = v__ast__OrKind_block;
			or_stmts = v__parser__Parser_parse_block_no_scope(p, false);
			or_pos = v__token__Position_extend(or_pos, v__token__Token_position(&p->prev_tok));
			v__parser__Parser_close_scope(p);
		}
		if (p->tok.kind == v__token__Kind_question) {
			v__parser__Parser_next(p);
			or_kind = v__ast__OrKind_propagate;
		}
		p->or_is_handled = false;
	}
	v__token__Position_update_last_line(&pos, p->prev_tok.line_nr);
	 v__ast__Expr _t2714 = v__ast__InfixExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__InfixExpr, ((v__ast__InfixExpr){
		.op = op,
		.pos = pos,
		.is_stmt = p->is_stmt_ident,
		.left = left,
		.right = right,
		.left_type = 0,
		.right_type = 0,
		.auto_locked = (string){.str=(byteptr)"", .is_lit=1},
		.or_block = (v__ast__OrExpr){.stmts = or_stmts,.kind = or_kind,.pos = or_pos,},
	})));
	// autofree_scope_vars(pos=11831 line_nr=478 scope.pos=10547 scope.end_pos=12011)
	// var "p" var.pos=10552 var.line_nr=431
	// var "left" var.pos=10573 var.line_nr=431
	// var "op" var.pos=10600 var.line_nr=432
	// var "precedence" var.pos=10698 var.line_nr=437
	// var "pos" var.pos=10736 var.line_nr=438
	// var "right" var.pos=10775 var.line_nr=440
	// var "prev_expecting_type" var.pos=10802 var.line_nr=441
	// var "or_stmts" var.pos=11205 var.line_nr=452
	// var "or_kind" var.pos=11235 var.line_nr=453
	// var "or_pos" var.pos=11269 var.line_nr=454
	// af parent scope:
	// af parent scope:
	return _t2714;
}

VV_LOCAL_SYMBOL bool v__parser__Parser_fileis(v__parser__Parser* p, string s) {
	 bool _t2715 = string_contains(p->file_name, s);
	// autofree_scope_vars(pos=12053 line_nr=493 scope.pos=12017 scope.end_pos=12085)
	// var "p" var.pos=12018 var.line_nr=492
	// var "s" var.pos=12036 var.line_nr=492
	// af parent scope:
	// af parent scope:
	return _t2715;
}

VV_LOCAL_SYMBOL v__ast__PrefixExpr v__parser__Parser_prefix_expr(v__parser__Parser* p) {
	v__token__Position pos = v__token__Token_position(&p->tok);
	v__token__Kind op = p->tok.kind;
	if (op == v__token__Kind_amp) {
		p->is_amp = true;
	}
	if (op == v__token__Kind_arrow) {
		p->or_is_handled = true;
		v__parser__Parser_register_auto_import(p, _SLIT("sync"));
	}
	v__parser__Parser_next(p);
	v__ast__Expr right = v__parser__Parser_expr(p, ((int)(v__token__Precedence_prefix)));
	p->is_amp = false;
	if ((right)._typ == 242 /* v.ast.CastExpr */) {
		(*right._v__ast__CastExpr).in_prexpr = true;
	}
	Array_v__ast__Stmt or_stmts = __new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
	v__ast__OrKind or_kind = v__ast__OrKind_absent;
	v__token__Position or_pos = v__token__Token_position(&p->tok);
	if (op == v__token__Kind_arrow) {
		if (p->tok.kind == v__token__Kind_key_orelse) {
			v__parser__Parser_next(p);
			v__parser__Parser_open_scope(p);
			v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){.name = _SLIT("err"),.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.is_auto_deref = 0,.typ = _const_v__ast__error_type,.orig_type = 0,.smartcasts = __new_array(0, 1, sizeof(v__ast__Type)),.pos = v__token__Token_position(&p->tok),.is_used = true,.is_changed = 0,.is_or = 0,.is_tmp = 0,}))));
			or_kind = v__ast__OrKind_block;
			or_stmts = v__parser__Parser_parse_block_no_scope(p, false);
			or_pos = v__token__Position_extend(or_pos, v__token__Token_position(&p->prev_tok));
			v__parser__Parser_close_scope(p);
		}
		if (p->tok.kind == v__token__Kind_question) {
			v__parser__Parser_next(p);
			or_kind = v__ast__OrKind_propagate;
		}
		p->or_is_handled = false;
	}
	v__token__Position_update_last_line(&pos, p->prev_tok.line_nr);
	 v__ast__PrefixExpr _t2716 = (v__ast__PrefixExpr){.op = op,.pos = pos,.right_type = 0,.right = right,.or_block = (v__ast__OrExpr){.stmts = or_stmts,.kind = or_kind,.pos = or_pos,},.is_option = 0,};
	// autofree_scope_vars(pos=13139 line_nr=541 scope.pos=12091 scope.end_pos=13280)
	// var "p" var.pos=12096 var.line_nr=496
	// var "pos" var.pos=12142 var.line_nr=497
	// var "op" var.pos=12167 var.line_nr=498
	// var "right" var.pos=12384 var.line_nr=510
	// var "or_stmts" var.pos=12513 var.line_nr=515
	// var "or_kind" var.pos=12543 var.line_nr=516
	// var "or_pos" var.pos=12577 var.line_nr=517
	// af parent scope:
	// af parent scope:
	return _t2716;
}

VV_LOCAL_SYMBOL v__ast__Expr v__parser__Parser_sql_expr(v__parser__Parser* p) {
	v__token__Position pos = v__token__Token_position(&p->tok);
	v__parser__Parser_check_name(p);
	v__ast__Expr db_expr = v__parser__Parser_expr(p, 0);
	v__parser__Parser_check(p, v__token__Kind_lcbr);
	v__parser__Parser_check(p, v__token__Kind_key_select);
	string n = v__parser__Parser_check_name(p);
	bool is_count = string_eq(n, _SLIT("count"));
	v__ast__Type typ = _const_v__ast__void_type;
	if (is_count) {
		v__parser__Parser_check_name(p);
		typ = _const_v__ast__int_type;
	}
	v__token__Position table_pos = v__token__Token_position(&p->tok);
	v__ast__Type table_type = v__parser__Parser_parse_type(p);
	v__ast__Expr where_expr = v__ast__empty_expr();
	bool has_where = p->tok.kind == v__token__Kind_name && string_eq(p->tok.lit, _SLIT("where"));
	bool query_one = false;
	if (has_where) {
		v__parser__Parser_next(p);
		where_expr = v__parser__Parser_expr(p, 0);
		if (!is_count && (where_expr)._typ == 258 /* v.ast.InfixExpr */) {
			v__ast__InfixExpr e = /* as */ *(v__ast__InfixExpr*)__as_cast((where_expr)._v__ast__InfixExpr,(where_expr)._typ, 258) /*expected idx: 258, name: v.ast.InfixExpr */ ;
			if (e.op == v__token__Kind_eq && (e.left)._typ == 254 /* v.ast.Ident */) {
				v__ast__Ident ident = /* as */ *(v__ast__Ident*)__as_cast((e.left)._v__ast__Ident,(e.left)._typ, 254) /*expected idx: 254, name: v.ast.Ident */ ;
				if (string_eq(ident.name, _SLIT("id"))) {
					query_one = true;
				}
			}
		}
	}
	bool has_limit = false;
	v__ast__Expr limit_expr = v__ast__empty_expr();
	bool has_offset = false;
	v__ast__Expr offset_expr = v__ast__empty_expr();
	bool has_order = false;
	v__ast__Expr order_expr = v__ast__empty_expr();
	bool has_desc = false;
	if (p->tok.kind == v__token__Kind_name && string_eq(p->tok.lit, _SLIT("order"))) {
		v__parser__Parser_check_name(p);
		v__token__Position order_pos = v__token__Token_position(&p->tok);
		if (p->tok.kind == v__token__Kind_name && string_eq(p->tok.lit, _SLIT("by"))) {
			v__parser__Parser_check_name(p);
		} else {
			 v__ast__Expr _t2717 = v__ast__NodeError_to_sumtype_v__ast__Expr(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _SLIT("use `order by` in ORM queries"), order_pos))));
			// autofree_scope_vars(pos=1457 line_nr=53 scope.pos=1453 scope.end_pos=1528)
			// af parent scope:
			// var "order_pos" var.pos=1340 var.line_nr=49
			// af parent scope:
			// var "p" var.pos=207 var.line_nr=7
			// var "pos" var.pos=255 var.line_nr=9
			// var "db_expr" var.pos=296 var.line_nr=11
			// var "n" var.pos=356 var.line_nr=14
			// var "is_count" var.pos=377 var.line_nr=15
			// var "typ" var.pos=407 var.line_nr=16
			// var "table_pos" var.pos=493 var.line_nr=21
			// var "table_type" var.pos=524 var.line_nr=22
			// var "where_expr" var.pos=568 var.line_nr=23
			// var "has_where" var.pos=600 var.line_nr=24
			// var "query_one" var.pos=662 var.line_nr=25
			// var "has_limit" var.pos=1060 var.line_nr=40
			// var "limit_expr" var.pos=1084 var.line_nr=41
			// var "has_offset" var.pos=1120 var.line_nr=42
			// var "offset_expr" var.pos=1145 var.line_nr=43
			// var "has_order" var.pos=1182 var.line_nr=44
			// var "order_expr" var.pos=1206 var.line_nr=45
			// var "has_desc" var.pos=1242 var.line_nr=46
			// af parent scope:
			// af parent scope:
			return _t2717;
		}
		has_order = true;
		order_expr = v__parser__Parser_expr(p, 0);
		if (p->tok.kind == v__token__Kind_name && string_eq(p->tok.lit, _SLIT("desc"))) {
			v__parser__Parser_check_name(p);
			has_desc = true;
		}
	}
	if (p->tok.kind == v__token__Kind_name && string_eq(p->tok.lit, _SLIT("limit"))) {
		v__parser__Parser_check_name(p);
		if (p->tok.kind == v__token__Kind_number && string_eq(p->tok.lit, _SLIT("1"))) {
			query_one = true;
		}
		has_limit = true;
		limit_expr = v__parser__Parser_expr(p, 0);
	}
	if (p->tok.kind == v__token__Kind_name && string_eq(p->tok.lit, _SLIT("offset"))) {
		v__parser__Parser_check_name(p);
		has_offset = true;
		offset_expr = v__parser__Parser_expr(p, 0);
	}
	if (!query_one && !is_count) {
		typ = v__ast__new_type(v__ast__Table_find_or_register_array(p->table, table_type));
	} else if (!is_count) {
		typ = table_type;
	}
	v__parser__Parser_check(p, v__token__Kind_rcbr);
	 v__ast__Expr _t2718 = v__ast__SqlExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__SqlExpr, ((v__ast__SqlExpr){
		.typ = typ,
		.is_count = is_count,
		.db_expr = db_expr,
		.has_where = has_where,
		.has_offset = has_offset,
		.offset_expr = offset_expr,
		.has_order = has_order,
		.order_expr = order_expr,
		.has_desc = has_desc,
		.is_array = !query_one,
		.pos = v__token__Position_extend(pos, v__token__Token_position(&p->prev_tok)),
		.has_limit = has_limit,
		.limit_expr = limit_expr,
		.where_expr = where_expr,
		.table_expr = (v__ast__TypeNode){.typ = table_type,.pos = table_pos,},
		.fields = __new_array(0, 1, sizeof(v__ast__StructField)),
		.sub_structs = new_map(sizeof(int), sizeof(v__ast__SqlExpr), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),
	})));
	// autofree_scope_vars(pos=2325 line_nr=86 scope.pos=202 scope.end_pos=2750)
	// var "p" var.pos=207 var.line_nr=7
	// var "pos" var.pos=255 var.line_nr=9
	// var "db_expr" var.pos=296 var.line_nr=11
	// var "n" var.pos=356 var.line_nr=14
	// var "is_count" var.pos=377 var.line_nr=15
	// var "typ" var.pos=407 var.line_nr=16
	// var "table_pos" var.pos=493 var.line_nr=21
	// var "table_type" var.pos=524 var.line_nr=22
	// var "where_expr" var.pos=568 var.line_nr=23
	// var "has_where" var.pos=600 var.line_nr=24
	// var "query_one" var.pos=662 var.line_nr=25
	// var "has_limit" var.pos=1060 var.line_nr=40
	// var "limit_expr" var.pos=1084 var.line_nr=41
	// var "has_offset" var.pos=1120 var.line_nr=42
	// var "offset_expr" var.pos=1145 var.line_nr=43
	// var "has_order" var.pos=1182 var.line_nr=44
	// var "order_expr" var.pos=1206 var.line_nr=45
	// var "has_desc" var.pos=1242 var.line_nr=46
	// af parent scope:
	// af parent scope:
	return _t2718;
}

VV_LOCAL_SYMBOL v__ast__SqlStmt v__parser__Parser_sql_stmt(v__parser__Parser* p) {
bool v__parser__Parser_sql_stmt_defer_0 = false;
	v__token__Position pos = v__token__Token_position(&p->tok);
	p->inside_match = true;
	v__parser__Parser_sql_stmt_defer_0 = true;
	v__parser__Parser_check_name(p);
	v__ast__Expr db_expr = v__parser__Parser_expr(p, 0);
	v__parser__Parser_check(p, v__token__Kind_lcbr);
	string n = v__parser__Parser_check_name(p);
	v__ast__SqlStmtKind kind = v__ast__SqlStmtKind_insert;
	if (string_eq(n, _SLIT("delete"))) {
		kind = v__ast__SqlStmtKind_delete;
	} else if (string_eq(n, _SLIT("update"))) {
		kind = v__ast__SqlStmtKind_update;
	} else if (string_eq(n, _SLIT("create"))) {
		kind = v__ast__SqlStmtKind_create;
		string table = v__parser__Parser_check_name(p);
		if (string_ne(table, _SLIT("table"))) {
			v__parser__Parser_error(p, _STR("expected `table` got `%.*s\000`", 2, table));
			// Defer begin
			if (v__parser__Parser_sql_stmt_defer_0 == true) {
				p->inside_match = false;
			}
			// Defer end
			 v__ast__SqlStmt _t2719 = (v__ast__SqlStmt){.kind = 0,.db_expr = {0},.object_var_name = (string){.str=(byteptr)"", .is_lit=1},.pos = {0},.where_expr = {0},.updated_columns = __new_array(0, 1, sizeof(string)),.update_exprs = __new_array(0, 1, sizeof(v__ast__Expr)),.table_expr = {0},.fields = __new_array(0, 1, sizeof(v__ast__StructField)),.sub_structs = new_map(sizeof(int), sizeof(v__ast__SqlStmt), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),};
			// autofree_scope_vars(pos=3400 line_nr=134 scope.pos=3352 scope.end_pos=3424)
			// af parent scope:
			// var "table" var.pos=3306 var.line_nr=131
			// var "typ" var.pos=3428 var.line_nr=136
			// var "typ_pos" var.pos=3452 var.line_nr=137
			// af parent scope:
			// var "p" var.pos=2846 var.line_nr=110
			// var "pos" var.pos=2886 var.line_nr=111
			// var "db_expr" var.pos=3002 var.line_nr=118
			// var "n" var.pos=3113 var.line_nr=123
			// var "kind" var.pos=3148 var.line_nr=124
			// var "inserted_var_name" var.pos=3671 var.line_nr=149
			// var "table_type" var.pos=3700 var.line_nr=150
			// var "updated_columns" var.pos=4036 var.line_nr=165
			// var "update_exprs" var.pos=4071 var.line_nr=166
			// var "table_pos" var.pos=4601 var.line_nr=191
			// var "where_expr" var.pos=4636 var.line_nr=192
			// af parent scope:
			// af parent scope:
			return _t2719;
		}
		v__ast__Type typ = v__parser__Parser_parse_type(p);
		v__token__Position typ_pos = v__token__Token_position(&p->tok);
		v__parser__Parser_check(p, v__token__Kind_rcbr);
		// Defer begin
		if (v__parser__Parser_sql_stmt_defer_0 == true) {
			p->inside_match = false;
		}
		// Defer end
		 v__ast__SqlStmt _t2720 = (v__ast__SqlStmt){.kind = kind,.db_expr = db_expr,.object_var_name = (string){.str=(byteptr)"", .is_lit=1},.pos = v__token__Position_extend(pos, v__token__Token_position(&p->prev_tok)),.where_expr = {0},.updated_columns = __new_array(0, 1, sizeof(string)),.update_exprs = __new_array(0, 1, sizeof(v__ast__Expr)),.table_expr = (v__ast__TypeNode){.typ = typ,.pos = typ_pos,},.fields = __new_array(0, 1, sizeof(v__ast__StructField)),.sub_structs = new_map(sizeof(int), sizeof(v__ast__SqlStmt), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),};
		// autofree_scope_vars(pos=3498 line_nr=139 scope.pos=3285 scope.end_pos=3664)
		// var "table" var.pos=3306 var.line_nr=131
		// var "typ" var.pos=3428 var.line_nr=136
		// var "typ_pos" var.pos=3452 var.line_nr=137
		// af parent scope:
		// var "p" var.pos=2846 var.line_nr=110
		// var "pos" var.pos=2886 var.line_nr=111
		// var "db_expr" var.pos=3002 var.line_nr=118
		// var "n" var.pos=3113 var.line_nr=123
		// var "kind" var.pos=3148 var.line_nr=124
		// var "inserted_var_name" var.pos=3671 var.line_nr=149
		// var "table_type" var.pos=3700 var.line_nr=150
		// var "updated_columns" var.pos=4036 var.line_nr=165
		// var "update_exprs" var.pos=4071 var.line_nr=166
		// var "table_pos" var.pos=4601 var.line_nr=191
		// var "where_expr" var.pos=4636 var.line_nr=192
		// af parent scope:
		// af parent scope:
		return _t2720;
	}
	string inserted_var_name = _SLIT("");
	v__ast__Type table_type = ((v__ast__Type)(0));
	if (kind != v__ast__SqlStmtKind_delete) {
		if (kind == v__ast__SqlStmtKind_update) {
			table_type = v__parser__Parser_parse_type(p);
		} else if (kind == v__ast__SqlStmtKind_insert) {
			v__ast__Expr expr = v__parser__Parser_expr(p, 0);
			if ((expr)._typ == 254 /* v.ast.Ident */) {
				inserted_var_name = (*expr._v__ast__Ident).name;
			} else {
				v__parser__Parser_error(p, _SLIT("can only insert variables"));
				// Defer begin
				if (v__parser__Parser_sql_stmt_defer_0 == true) {
					p->inside_match = false;
				}
				// Defer end
				 v__ast__SqlStmt _t2721 = (v__ast__SqlStmt){.kind = 0,.db_expr = {0},.object_var_name = (string){.str=(byteptr)"", .is_lit=1},.pos = {0},.where_expr = {0},.updated_columns = __new_array(0, 1, sizeof(string)),.update_exprs = __new_array(0, 1, sizeof(v__ast__Expr)),.table_expr = {0},.fields = __new_array(0, 1, sizeof(v__ast__StructField)),.sub_structs = new_map(sizeof(int), sizeof(v__ast__SqlStmt), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),};
				// autofree_scope_vars(pos=3969 line_nr=160 scope.pos=3923 scope.end_pos=3994)
				// af parent scope:
				// var "expr" var.pos=3835 var.line_nr=155
				// af parent scope:
				// af parent scope:
				// var "p" var.pos=2846 var.line_nr=110
				// var "pos" var.pos=2886 var.line_nr=111
				// var "db_expr" var.pos=3002 var.line_nr=118
				// var "n" var.pos=3113 var.line_nr=123
				// var "kind" var.pos=3148 var.line_nr=124
				// var "inserted_var_name" var.pos=3671 var.line_nr=149
				// str literal
				// var "table_type" var.pos=3700 var.line_nr=150
				// var "updated_columns" var.pos=4036 var.line_nr=165
				// var "update_exprs" var.pos=4071 var.line_nr=166
				// var "table_pos" var.pos=4601 var.line_nr=191
				// var "where_expr" var.pos=4636 var.line_nr=192
				// af parent scope:
				// af parent scope:
				return _t2721;
			}
		}
	}
	n = v__parser__Parser_check_name(p);
	Array_string updated_columns = __new_array_with_default(0, 0, sizeof(string), 0);
	Array_v__ast__Expr update_exprs = __new_array_with_default(0, 5, sizeof(v__ast__Expr), 0);
	if (kind == v__ast__SqlStmtKind_insert && string_ne(n, _SLIT("into"))) {
		v__parser__Parser_error(p, _SLIT("expecting `into`"));
		// Defer begin
		if (v__parser__Parser_sql_stmt_defer_0 == true) {
			p->inside_match = false;
		}
		// Defer end
		 v__ast__SqlStmt _t2722 = (v__ast__SqlStmt){.kind = 0,.db_expr = {0},.object_var_name = (string){.str=(byteptr)"", .is_lit=1},.pos = {0},.where_expr = {0},.updated_columns = __new_array(0, 1, sizeof(string)),.update_exprs = __new_array(0, 1, sizeof(v__ast__Expr)),.table_expr = {0},.fields = __new_array(0, 1, sizeof(v__ast__StructField)),.sub_structs = new_map(sizeof(int), sizeof(v__ast__SqlStmt), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),};
		// autofree_scope_vars(pos=4174 line_nr=169 scope.pos=4141 scope.end_pos=4197)
		// af parent scope:
		// var "p" var.pos=2846 var.line_nr=110
		// var "pos" var.pos=2886 var.line_nr=111
		// var "db_expr" var.pos=3002 var.line_nr=118
		// var "n" var.pos=3113 var.line_nr=123
		// var "kind" var.pos=3148 var.line_nr=124
		// var "inserted_var_name" var.pos=3671 var.line_nr=149
		// str literal
		// var "table_type" var.pos=3700 var.line_nr=150
		// var "updated_columns" var.pos=4036 var.line_nr=165
		// var "update_exprs" var.pos=4071 var.line_nr=166
		// var "table_pos" var.pos=4601 var.line_nr=191
		// var "where_expr" var.pos=4636 var.line_nr=192
		// af parent scope:
		// af parent scope:
		return _t2722;
	} else if (kind == v__ast__SqlStmtKind_update) {
		if (string_ne(n, _SLIT("set"))) {
			v__parser__Parser_error(p, _SLIT("expecting `set`"));
			// Defer begin
			if (v__parser__Parser_sql_stmt_defer_0 == true) {
				p->inside_match = false;
			}
			// Defer end
			 v__ast__SqlStmt _t2723 = (v__ast__SqlStmt){.kind = 0,.db_expr = {0},.object_var_name = (string){.str=(byteptr)"", .is_lit=1},.pos = {0},.where_expr = {0},.updated_columns = __new_array(0, 1, sizeof(string)),.update_exprs = __new_array(0, 1, sizeof(v__ast__Expr)),.table_expr = {0},.fields = __new_array(0, 1, sizeof(v__ast__StructField)),.sub_structs = new_map(sizeof(int), sizeof(v__ast__SqlStmt), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),};
			// autofree_scope_vars(pos=4275 line_nr=173 scope.pos=4241 scope.end_pos=4299)
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=2846 var.line_nr=110
			// var "pos" var.pos=2886 var.line_nr=111
			// var "db_expr" var.pos=3002 var.line_nr=118
			// var "n" var.pos=3113 var.line_nr=123
			// var "kind" var.pos=3148 var.line_nr=124
			// var "inserted_var_name" var.pos=3671 var.line_nr=149
			// str literal
			// var "table_type" var.pos=3700 var.line_nr=150
			// var "updated_columns" var.pos=4036 var.line_nr=165
			// var "update_exprs" var.pos=4071 var.line_nr=166
			// var "table_pos" var.pos=4601 var.line_nr=191
			// var "where_expr" var.pos=4636 var.line_nr=192
			// af parent scope:
			// af parent scope:
			return _t2723;
		}
		for (;;) {
			string column = v__parser__Parser_check_name(p);
			array_push(&updated_columns, _MOV((string[]){ string_clone(column) }));
			v__parser__Parser_check(p, v__token__Kind_assign);
			array_push(&update_exprs, _MOV((v__ast__Expr[]){ v__parser__Parser_expr(p, 0) }));
			if (p->tok.kind == v__token__Kind_comma) {
				v__parser__Parser_check(p, v__token__Kind_comma);
			} else {
				break;
			}
		}
	} else if (kind == v__ast__SqlStmtKind_delete && string_ne(n, _SLIT("from"))) {
		v__parser__Parser_error(p, _SLIT("expecting `from`"));
		// Defer begin
		if (v__parser__Parser_sql_stmt_defer_0 == true) {
			p->inside_match = false;
		}
		// Defer end
		 v__ast__SqlStmt _t2726 = (v__ast__SqlStmt){.kind = 0,.db_expr = {0},.object_var_name = (string){.str=(byteptr)"", .is_lit=1},.pos = {0},.where_expr = {0},.updated_columns = __new_array(0, 1, sizeof(string)),.update_exprs = __new_array(0, 1, sizeof(v__ast__Expr)),.table_expr = {0},.fields = __new_array(0, 1, sizeof(v__ast__StructField)),.sub_structs = new_map(sizeof(int), sizeof(v__ast__SqlStmt), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),};
		// autofree_scope_vars(pos=4570 line_nr=188 scope.pos=4537 scope.end_pos=4593)
		// af parent scope:
		// var "p" var.pos=2846 var.line_nr=110
		// var "pos" var.pos=2886 var.line_nr=111
		// var "db_expr" var.pos=3002 var.line_nr=118
		// var "n" var.pos=3113 var.line_nr=123
		// var "kind" var.pos=3148 var.line_nr=124
		// var "inserted_var_name" var.pos=3671 var.line_nr=149
		// str literal
		// var "table_type" var.pos=3700 var.line_nr=150
		// var "updated_columns" var.pos=4036 var.line_nr=165
		// var "update_exprs" var.pos=4071 var.line_nr=166
		// var "table_pos" var.pos=4601 var.line_nr=191
		// var "where_expr" var.pos=4636 var.line_nr=192
		// af parent scope:
		// af parent scope:
		return _t2726;
	}
	v__token__Position table_pos = v__token__Token_position(&p->tok);
	v__ast__Expr where_expr = v__ast__empty_expr();
	if (kind == v__ast__SqlStmtKind_insert) {
		table_pos = v__token__Token_position(&p->tok);
		table_type = v__parser__Parser_parse_type(p);
	} else if (kind == v__ast__SqlStmtKind_update) {
		Option_bool _t2727 = v__parser__Parser_check_sql_keyword(p, _SLIT("where"));
		if (_t2727.state != 0) { /*or block*/ 
			IError err = _t2727.err;
			// Defer begin
			if (v__parser__Parser_sql_stmt_defer_0 == true) {
				p->inside_match = false;
			}
			// Defer end
			 v__ast__SqlStmt _t2728 = (v__ast__SqlStmt){.kind = 0,.db_expr = {0},.object_var_name = (string){.str=(byteptr)"", .is_lit=1},.pos = {0},.where_expr = {0},.updated_columns = __new_array(0, 1, sizeof(string)),.update_exprs = __new_array(0, 1, sizeof(v__ast__Expr)),.table_expr = {0},.fields = __new_array(0, 1, sizeof(v__ast__StructField)),.sub_structs = new_map(sizeof(int), sizeof(v__ast__SqlStmt), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),};
			// autofree_scope_vars(pos=4814 line_nr=197 scope.pos=4813 scope.end_pos=4836)
			// var "err" var.pos=4813 var.line_nr=197
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=2846 var.line_nr=110
			// var "pos" var.pos=2886 var.line_nr=111
			// var "db_expr" var.pos=3002 var.line_nr=118
			// var "n" var.pos=3113 var.line_nr=123
			// var "kind" var.pos=3148 var.line_nr=124
			// var "inserted_var_name" var.pos=3671 var.line_nr=149
			// str literal
			// var "table_type" var.pos=3700 var.line_nr=150
			// var "updated_columns" var.pos=4036 var.line_nr=165
			// var "update_exprs" var.pos=4071 var.line_nr=166
			// var "table_pos" var.pos=4601 var.line_nr=191
			// var "where_expr" var.pos=4636 var.line_nr=192
			// af parent scope:
			// af parent scope:
			return _t2728;
		};
		where_expr = v__parser__Parser_expr(p, 0);
	} else if (kind == v__ast__SqlStmtKind_delete) {
		table_pos = v__token__Token_position(&p->tok);
		table_type = v__parser__Parser_parse_type(p);
		Option_bool _t2729 = v__parser__Parser_check_sql_keyword(p, _SLIT("where"));
		if (_t2729.state != 0) { /*or block*/ 
			IError err = _t2729.err;
			// Defer begin
			if (v__parser__Parser_sql_stmt_defer_0 == true) {
				p->inside_match = false;
			}
			// Defer end
			 v__ast__SqlStmt _t2730 = (v__ast__SqlStmt){.kind = 0,.db_expr = {0},.object_var_name = (string){.str=(byteptr)"", .is_lit=1},.pos = {0},.where_expr = {0},.updated_columns = __new_array(0, 1, sizeof(string)),.update_exprs = __new_array(0, 1, sizeof(v__ast__Expr)),.table_expr = {0},.fields = __new_array(0, 1, sizeof(v__ast__StructField)),.sub_structs = new_map(sizeof(int), sizeof(v__ast__SqlStmt), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),};
			// autofree_scope_vars(pos=4988 line_nr=202 scope.pos=4987 scope.end_pos=5010)
			// var "err" var.pos=4987 var.line_nr=202
			// af parent scope:
			// af parent scope:
			// var "p" var.pos=2846 var.line_nr=110
			// var "pos" var.pos=2886 var.line_nr=111
			// var "db_expr" var.pos=3002 var.line_nr=118
			// var "n" var.pos=3113 var.line_nr=123
			// var "kind" var.pos=3148 var.line_nr=124
			// var "inserted_var_name" var.pos=3671 var.line_nr=149
			// str literal
			// var "table_type" var.pos=3700 var.line_nr=150
			// var "updated_columns" var.pos=4036 var.line_nr=165
			// var "update_exprs" var.pos=4071 var.line_nr=166
			// var "table_pos" var.pos=4601 var.line_nr=191
			// var "where_expr" var.pos=4636 var.line_nr=192
			// af parent scope:
			// af parent scope:
			return _t2730;
		};
		where_expr = v__parser__Parser_expr(p, 0);
	}
	v__parser__Parser_check(p, v__token__Kind_rcbr);
	pos.last_line = p->prev_tok.line_nr;
	// Defer begin
	if (v__parser__Parser_sql_stmt_defer_0 == true) {
		p->inside_match = false;
	}
	// Defer end
	 v__ast__SqlStmt _t2731 = (v__ast__SqlStmt){
		.kind = kind,
		.db_expr = db_expr,
		.object_var_name = inserted_var_name,
		.pos = v__token__Position_extend(pos, v__token__Token_position(&p->prev_tok)),
		.where_expr = where_expr,
		.updated_columns = updated_columns,
		.update_exprs = update_exprs,
		.table_expr = (v__ast__TypeNode){.typ = table_type,.pos = table_pos,},
		.fields = __new_array(0, 1, sizeof(v__ast__StructField)),
		.sub_structs = new_map(sizeof(int), sizeof(v__ast__SqlStmt), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),
	};
	// autofree_scope_vars(pos=5092 line_nr=207 scope.pos=2841 scope.end_pos=5384)
	// var "p" var.pos=2846 var.line_nr=110
	// var "pos" var.pos=2886 var.line_nr=111
	// var "db_expr" var.pos=3002 var.line_nr=118
	// var "n" var.pos=3113 var.line_nr=123
	// var "kind" var.pos=3148 var.line_nr=124
	// var "inserted_var_name" var.pos=3671 var.line_nr=149
	// str literal
	// var "table_type" var.pos=3700 var.line_nr=150
	// var "updated_columns" var.pos=4036 var.line_nr=165
	// var "update_exprs" var.pos=4071 var.line_nr=166
	// var "table_pos" var.pos=4601 var.line_nr=191
	// var "where_expr" var.pos=4636 var.line_nr=192
	// af parent scope:
	// af parent scope:
	return _t2731;
}

VV_LOCAL_SYMBOL Option_bool v__parser__Parser_check_sql_keyword(v__parser__Parser* p, string name) {
	if (string_ne(v__parser__Parser_check_name(p), name)) {
		v__parser__Parser_error(p, _STR("orm: expecting `%.*s\000`", 2, name));
		return (Option_bool){ .state=2, .err=_const_none__ };
	}
	Option_bool _t2732;
	opt_ok(&(bool[]) { true }, (Option*)(&_t2732), sizeof(bool));
	// autofree_scope_vars(pos=5526 line_nr=227 scope.pos=5390 scope.end_pos=5539)
	// var "p" var.pos=5395 var.line_nr=222
	// var "name" var.pos=5423 var.line_nr=222
	// af parent scope:
	// af parent scope:
	return _t2732;
}

VV_LOCAL_SYMBOL v__ast__StructDecl v__parser__Parser_struct_decl(v__parser__Parser* p) {
	v__parser__Parser_top_level_statement_start(p);
	Array_v__ast__Attr attrs = p->attrs;
	p->attrs = __new_array_with_default(0, 0, sizeof(v__ast__Attr), 0);
	v__token__Position start_pos = v__token__Token_position(&p->tok);
	bool is_pub = p->tok.kind == v__token__Kind_key_pub;
	if (is_pub) {
		v__parser__Parser_next(p);
	}
	bool is_union = p->tok.kind == v__token__Kind_key_union;
	if (p->tok.kind == v__token__Kind_key_struct) {
		v__parser__Parser_next(p);
	} else {
		v__parser__Parser_check(p, v__token__Kind_key_union);
	}
	v__ast__Language language = (string_eq(p->tok.lit, _SLIT("C")) && p->peek_tok.kind == v__token__Kind_dot ? (v__ast__Language_c) : string_eq(p->tok.lit, _SLIT("JS")) && p->peek_tok.kind == v__token__Kind_dot ? (v__ast__Language_js) : (v__ast__Language_v));
	if (language != v__ast__Language_v) {
		v__parser__Parser_next(p);
		v__parser__Parser_next(p);
	}
	v__token__Position name_pos = v__token__Token_position(&p->tok);
	v__parser__Parser_check_for_impure_v(p, language, name_pos);
	string name = v__parser__Parser_check_name(p);
	if (name.len == 1 && byte_is_capital(string_at(name, 0))) {
		v__parser__Parser_error_with_pos(p, _SLIT("single letter capital names are reserved for generic template types."), name_pos);
		 v__ast__StructDecl _t2733 = (v__ast__StructDecl){.pos = {0},.name = (string){.str=(byteptr)"", .is_lit=1},.gen_types = __new_array(0, 1, sizeof(v__ast__Type)),.is_pub = 0,.mut_pos = 0,.pub_pos = 0,.pub_mut_pos = 0,.global_pos = 0,.module_pos = 0,.language = 0,.is_union = 0,.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.end_comments = __new_array(0, 1, sizeof(v__ast__Comment)),.embeds = __new_array(0, 1, sizeof(v__ast__Embed)),.fields = __new_array(0, 1, sizeof(v__ast__StructField)),};
		// autofree_scope_vars(pos=1196 line_nr=47 scope.pos=1089 scope.end_pos=1222)
		// af parent scope:
		// var "p" var.pos=236 var.line_nr=9
		// var "attrs" var.pos=367 var.line_nr=12
		// var "start_pos" var.pos=399 var.line_nr=14
		// var "is_pub" var.pos=430 var.line_nr=15
		// var "is_union" var.pos=491 var.line_nr=19
		// var "language" var.pos=607 var.line_nr=25
		// var "name_pos" var.pos=854 var.line_nr=36
		// var "name" var.pos=930 var.line_nr=38
		// var "generic_types" var.pos=1229 var.line_nr=49
		// var "no_body" var.pos=1416 var.line_nr=61
		// var "orig_name" var.pos=1894 var.line_nr=75
		// var "ast_fields" var.pos=2086 var.line_nr=85
		// var "fields" var.pos=2125 var.line_nr=86
		// var "embed_types" var.pos=2160 var.line_nr=87
		// var "embeds" var.pos=2193 var.line_nr=88
		// var "embed_field_names" var.pos=2222 var.line_nr=89
		// var "mut_pos" var.pos=2259 var.line_nr=90
		// var "pub_pos" var.pos=2278 var.line_nr=91
		// var "pub_mut_pos" var.pos=2297 var.line_nr=92
		// var "global_pos" var.pos=2320 var.line_nr=93
		// var "module_pos" var.pos=2342 var.line_nr=94
		// var "is_field_mut" var.pos=2364 var.line_nr=95
		// var "is_field_pub" var.pos=2391 var.line_nr=96
		// var "is_field_global" var.pos=2418 var.line_nr=97
		// var "last_line" var.pos=2448 var.line_nr=98
		// var "end_comments" var.pos=2469 var.line_nr=99
		// var "t" var.pos=7434 var.line_nr=289
		// var "ret" var.pos=7931 var.line_nr=310
		// af parent scope:
		// af parent scope:
		return _t2733;
	}
	Array_v__ast__Type generic_types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
	if (p->tok.kind == v__token__Kind_lt) {
		v__parser__Parser_next(p);
		for (;;) {
			array_push(&generic_types, _MOV((v__ast__Type[]){ v__parser__Parser_parse_type(p) }));
			if (p->tok.kind != v__token__Kind_comma) {
				break;
			}
			v__parser__Parser_next(p);
		}
		v__parser__Parser_check(p, v__token__Kind_gt);
	}
	bool no_body = p->tok.kind != v__token__Kind_lcbr;
	if (language == v__ast__Language_v && no_body) {
		v__parser__Parser_error(p, _STR("`%.*s\000` lacks body", 2, p->tok.lit));
		 v__ast__StructDecl _t2735 = (v__ast__StructDecl){.pos = {0},.name = (string){.str=(byteptr)"", .is_lit=1},.gen_types = __new_array(0, 1, sizeof(v__ast__Type)),.is_pub = 0,.mut_pos = 0,.pub_pos = 0,.pub_mut_pos = 0,.global_pos = 0,.module_pos = 0,.language = 0,.is_union = 0,.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.end_comments = __new_array(0, 1, sizeof(v__ast__Comment)),.embeds = __new_array(0, 1, sizeof(v__ast__Embed)),.fields = __new_array(0, 1, sizeof(v__ast__StructField)),};
		// autofree_scope_vars(pos=1517 line_nr=64 scope.pos=1477 scope.end_pos=1543)
		// af parent scope:
		// var "p" var.pos=236 var.line_nr=9
		// var "attrs" var.pos=367 var.line_nr=12
		// var "start_pos" var.pos=399 var.line_nr=14
		// var "is_pub" var.pos=430 var.line_nr=15
		// var "is_union" var.pos=491 var.line_nr=19
		// var "language" var.pos=607 var.line_nr=25
		// var "name_pos" var.pos=854 var.line_nr=36
		// var "name" var.pos=930 var.line_nr=38
		// var "generic_types" var.pos=1229 var.line_nr=49
		// var "no_body" var.pos=1416 var.line_nr=61
		// var "orig_name" var.pos=1894 var.line_nr=75
		// var "ast_fields" var.pos=2086 var.line_nr=85
		// var "fields" var.pos=2125 var.line_nr=86
		// var "embed_types" var.pos=2160 var.line_nr=87
		// var "embeds" var.pos=2193 var.line_nr=88
		// var "embed_field_names" var.pos=2222 var.line_nr=89
		// var "mut_pos" var.pos=2259 var.line_nr=90
		// var "pub_pos" var.pos=2278 var.line_nr=91
		// var "pub_mut_pos" var.pos=2297 var.line_nr=92
		// var "global_pos" var.pos=2320 var.line_nr=93
		// var "module_pos" var.pos=2342 var.line_nr=94
		// var "is_field_mut" var.pos=2364 var.line_nr=95
		// var "is_field_pub" var.pos=2391 var.line_nr=96
		// var "is_field_global" var.pos=2418 var.line_nr=97
		// var "last_line" var.pos=2448 var.line_nr=98
		// var "end_comments" var.pos=2469 var.line_nr=99
		// var "t" var.pos=7434 var.line_nr=289
		// var "ret" var.pos=7931 var.line_nr=310
		// af parent scope:
		// af parent scope:
		return _t2735;
	}
	if (language == v__ast__Language_v && !p->builtin_mod && name.len > 0 && !byte_is_capital(string_at(name, 0)) && !p->pref->translated) {
		v__parser__Parser_error_with_pos(p, _STR("struct name `%.*s\000` must begin with capital letter", 2, name), name_pos);
		 v__ast__StructDecl _t2736 = (v__ast__StructDecl){.pos = {0},.name = (string){.str=(byteptr)"", .is_lit=1},.gen_types = __new_array(0, 1, sizeof(v__ast__Type)),.is_pub = 0,.mut_pos = 0,.pub_pos = 0,.pub_mut_pos = 0,.global_pos = 0,.module_pos = 0,.language = 0,.is_union = 0,.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.end_comments = __new_array(0, 1, sizeof(v__ast__Comment)),.embeds = __new_array(0, 1, sizeof(v__ast__Embed)),.fields = __new_array(0, 1, sizeof(v__ast__StructField)),};
		// autofree_scope_vars(pos=1733 line_nr=69 scope.pos=1647 scope.end_pos=1759)
		// af parent scope:
		// var "p" var.pos=236 var.line_nr=9
		// var "attrs" var.pos=367 var.line_nr=12
		// var "start_pos" var.pos=399 var.line_nr=14
		// var "is_pub" var.pos=430 var.line_nr=15
		// var "is_union" var.pos=491 var.line_nr=19
		// var "language" var.pos=607 var.line_nr=25
		// var "name_pos" var.pos=854 var.line_nr=36
		// var "name" var.pos=930 var.line_nr=38
		// var "generic_types" var.pos=1229 var.line_nr=49
		// var "no_body" var.pos=1416 var.line_nr=61
		// var "orig_name" var.pos=1894 var.line_nr=75
		// var "ast_fields" var.pos=2086 var.line_nr=85
		// var "fields" var.pos=2125 var.line_nr=86
		// var "embed_types" var.pos=2160 var.line_nr=87
		// var "embeds" var.pos=2193 var.line_nr=88
		// var "embed_field_names" var.pos=2222 var.line_nr=89
		// var "mut_pos" var.pos=2259 var.line_nr=90
		// var "pub_pos" var.pos=2278 var.line_nr=91
		// var "pub_mut_pos" var.pos=2297 var.line_nr=92
		// var "global_pos" var.pos=2320 var.line_nr=93
		// var "module_pos" var.pos=2342 var.line_nr=94
		// var "is_field_mut" var.pos=2364 var.line_nr=95
		// var "is_field_pub" var.pos=2391 var.line_nr=96
		// var "is_field_global" var.pos=2418 var.line_nr=97
		// var "last_line" var.pos=2448 var.line_nr=98
		// var "end_comments" var.pos=2469 var.line_nr=99
		// var "t" var.pos=7434 var.line_nr=289
		// var "ret" var.pos=7931 var.line_nr=310
		// af parent scope:
		// af parent scope:
		return _t2736;
	}
	if (name.len == 1) {
		v__parser__Parser_error_with_pos(p, _SLIT("struct names must have more than one character"), name_pos);
		 v__ast__StructDecl _t2737 = (v__ast__StructDecl){.pos = {0},.name = (string){.str=(byteptr)"", .is_lit=1},.gen_types = __new_array(0, 1, sizeof(v__ast__Type)),.is_pub = 0,.mut_pos = 0,.pub_pos = 0,.pub_mut_pos = 0,.global_pos = 0,.module_pos = 0,.language = 0,.is_union = 0,.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.end_comments = __new_array(0, 1, sizeof(v__ast__Comment)),.embeds = __new_array(0, 1, sizeof(v__ast__Embed)),.fields = __new_array(0, 1, sizeof(v__ast__StructField)),};
		// autofree_scope_vars(pos=1861 line_nr=73 scope.pos=1779 scope.end_pos=1887)
		// af parent scope:
		// var "p" var.pos=236 var.line_nr=9
		// var "attrs" var.pos=367 var.line_nr=12
		// var "start_pos" var.pos=399 var.line_nr=14
		// var "is_pub" var.pos=430 var.line_nr=15
		// var "is_union" var.pos=491 var.line_nr=19
		// var "language" var.pos=607 var.line_nr=25
		// var "name_pos" var.pos=854 var.line_nr=36
		// var "name" var.pos=930 var.line_nr=38
		// var "generic_types" var.pos=1229 var.line_nr=49
		// var "no_body" var.pos=1416 var.line_nr=61
		// var "orig_name" var.pos=1894 var.line_nr=75
		// var "ast_fields" var.pos=2086 var.line_nr=85
		// var "fields" var.pos=2125 var.line_nr=86
		// var "embed_types" var.pos=2160 var.line_nr=87
		// var "embeds" var.pos=2193 var.line_nr=88
		// var "embed_field_names" var.pos=2222 var.line_nr=89
		// var "mut_pos" var.pos=2259 var.line_nr=90
		// var "pub_pos" var.pos=2278 var.line_nr=91
		// var "pub_mut_pos" var.pos=2297 var.line_nr=92
		// var "global_pos" var.pos=2320 var.line_nr=93
		// var "module_pos" var.pos=2342 var.line_nr=94
		// var "is_field_mut" var.pos=2364 var.line_nr=95
		// var "is_field_pub" var.pos=2391 var.line_nr=96
		// var "is_field_global" var.pos=2418 var.line_nr=97
		// var "last_line" var.pos=2448 var.line_nr=98
		// var "end_comments" var.pos=2469 var.line_nr=99
		// var "t" var.pos=7434 var.line_nr=289
		// var "ret" var.pos=7931 var.line_nr=310
		// af parent scope:
		// af parent scope:
		return _t2737;
	}
	string orig_name = name;
	if (language == v__ast__Language_c) {
		name = _STR("C.%.*s", 1, name);
		orig_name = name;
	} else if (language == v__ast__Language_js) {
		name = _STR("JS.%.*s", 1, name);
		orig_name = name;
	} else {
		name = v__parser__Parser_prepend_mod(p, name);
	}
	Array_v__ast__StructField ast_fields = __new_array_with_default(0, 0, sizeof(v__ast__StructField), 0);
	Array_v__ast__StructField fields = __new_array_with_default(0, 0, sizeof(v__ast__StructField), 0);
	Array_v__ast__Type embed_types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
	Array_v__ast__Embed embeds = __new_array_with_default(0, 0, sizeof(v__ast__Embed), 0);
	Array_string embed_field_names = __new_array_with_default(0, 0, sizeof(string), 0);
	int mut_pos = -1;
	int pub_pos = -1;
	int pub_mut_pos = -1;
	int global_pos = -1;
	int module_pos = -1;
	bool is_field_mut = false;
	bool is_field_pub = false;
	bool is_field_global = false;
	int last_line = -1;
	Array_v__ast__Comment end_comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	if (!no_body) {
		v__parser__Parser_check(p, v__token__Kind_lcbr);
		for (;;) {
			if (!(p->tok.kind != v__token__Kind_rcbr)) break;
			Array_v__ast__Comment comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
			for (;;) {
				if (!(p->tok.kind == v__token__Kind_comment)) break;
				array_push(&comments, _MOV((v__ast__Comment[]){ v__parser__Parser_comment(p) }));
				if (p->tok.kind == v__token__Kind_rcbr) {
					break;
				}
			}
			if (p->tok.kind == v__token__Kind_rcbr) {
				end_comments = array_clone(&comments);
				break;
			}
			if (p->tok.kind == v__token__Kind_key_pub) {
				v__parser__Parser_next(p);
				if (p->tok.kind == v__token__Kind_key_mut) {
					if (pub_mut_pos != -1) {
						v__parser__Parser_error(p, _SLIT("redefinition of `pub mut` section"));
						 v__ast__StructDecl _t2739 = (v__ast__StructDecl){.pos = {0},.name = (string){.str=(byteptr)"", .is_lit=1},.gen_types = __new_array(0, 1, sizeof(v__ast__Type)),.is_pub = 0,.mut_pos = 0,.pub_pos = 0,.pub_mut_pos = 0,.global_pos = 0,.module_pos = 0,.language = 0,.is_union = 0,.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.end_comments = __new_array(0, 1, sizeof(v__ast__Comment)),.embeds = __new_array(0, 1, sizeof(v__ast__Embed)),.fields = __new_array(0, 1, sizeof(v__ast__StructField)),};
						// autofree_scope_vars(pos=2946 line_nr=119 scope.pos=2888 scope.end_pos=2976)
						// af parent scope:
						// af parent scope:
						// af parent scope:
						// var "comments" var.pos=2568 var.line_nr=103
						// var "field_start_pos" var.pos=4333 var.line_nr=177
						// var "is_embed" var.pos=4372 var.line_nr=178
						// var "is_on_top" var.pos=4517 var.line_nr=180
						// var "field_name" var.pos=4611 var.line_nr=181
						// var "typ" var.pos=4635 var.line_nr=182
						// var "type_pos" var.pos=4661 var.line_nr=183
						// var "field_pos" var.pos=4697 var.line_nr=184
						// var "default_expr" var.pos=6197 var.line_nr=240
						// var "has_default_expr" var.pos=6237 var.line_nr=241
						// af parent scope:
						// af parent scope:
						// af parent scope:
						// var "p" var.pos=236 var.line_nr=9
						// var "attrs" var.pos=367 var.line_nr=12
						// var "start_pos" var.pos=399 var.line_nr=14
						// var "is_pub" var.pos=430 var.line_nr=15
						// var "is_union" var.pos=491 var.line_nr=19
						// var "language" var.pos=607 var.line_nr=25
						// var "name_pos" var.pos=854 var.line_nr=36
						// var "name" var.pos=930 var.line_nr=38
						// var "generic_types" var.pos=1229 var.line_nr=49
						// var "no_body" var.pos=1416 var.line_nr=61
						// var "orig_name" var.pos=1894 var.line_nr=75
						// var "ast_fields" var.pos=2086 var.line_nr=85
						// var "fields" var.pos=2125 var.line_nr=86
						// var "embed_types" var.pos=2160 var.line_nr=87
						// var "embeds" var.pos=2193 var.line_nr=88
						// var "embed_field_names" var.pos=2222 var.line_nr=89
						// var "mut_pos" var.pos=2259 var.line_nr=90
						// var "pub_pos" var.pos=2278 var.line_nr=91
						// var "pub_mut_pos" var.pos=2297 var.line_nr=92
						// var "global_pos" var.pos=2320 var.line_nr=93
						// var "module_pos" var.pos=2342 var.line_nr=94
						// var "is_field_mut" var.pos=2364 var.line_nr=95
						// var "is_field_pub" var.pos=2391 var.line_nr=96
						// var "is_field_global" var.pos=2418 var.line_nr=97
						// var "last_line" var.pos=2448 var.line_nr=98
						// var "end_comments" var.pos=2469 var.line_nr=99
						// var "t" var.pos=7434 var.line_nr=289
						// var "ret" var.pos=7931 var.line_nr=310
						// af parent scope:
						// af parent scope:
						return _t2739;
					}
					v__parser__Parser_next(p);
					pub_mut_pos = ast_fields.len;
					is_field_pub = true;
					is_field_mut = true;
					is_field_global = false;
				} else {
					if (pub_pos != -1) {
						v__parser__Parser_error(p, _SLIT("redefinition of `pub` section"));
						 v__ast__StructDecl _t2740 = (v__ast__StructDecl){.pos = {0},.name = (string){.str=(byteptr)"", .is_lit=1},.gen_types = __new_array(0, 1, sizeof(v__ast__Type)),.is_pub = 0,.mut_pos = 0,.pub_pos = 0,.pub_mut_pos = 0,.global_pos = 0,.module_pos = 0,.language = 0,.is_union = 0,.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.end_comments = __new_array(0, 1, sizeof(v__ast__Comment)),.embeds = __new_array(0, 1, sizeof(v__ast__Embed)),.fields = __new_array(0, 1, sizeof(v__ast__StructField)),};
						// autofree_scope_vars(pos=3194 line_nr=129 scope.pos=3140 scope.end_pos=3224)
						// af parent scope:
						// af parent scope:
						// af parent scope:
						// var "comments" var.pos=2568 var.line_nr=103
						// var "field_start_pos" var.pos=4333 var.line_nr=177
						// var "is_embed" var.pos=4372 var.line_nr=178
						// var "is_on_top" var.pos=4517 var.line_nr=180
						// var "field_name" var.pos=4611 var.line_nr=181
						// var "typ" var.pos=4635 var.line_nr=182
						// var "type_pos" var.pos=4661 var.line_nr=183
						// var "field_pos" var.pos=4697 var.line_nr=184
						// var "default_expr" var.pos=6197 var.line_nr=240
						// var "has_default_expr" var.pos=6237 var.line_nr=241
						// af parent scope:
						// af parent scope:
						// af parent scope:
						// var "p" var.pos=236 var.line_nr=9
						// var "attrs" var.pos=367 var.line_nr=12
						// var "start_pos" var.pos=399 var.line_nr=14
						// var "is_pub" var.pos=430 var.line_nr=15
						// var "is_union" var.pos=491 var.line_nr=19
						// var "language" var.pos=607 var.line_nr=25
						// var "name_pos" var.pos=854 var.line_nr=36
						// var "name" var.pos=930 var.line_nr=38
						// var "generic_types" var.pos=1229 var.line_nr=49
						// var "no_body" var.pos=1416 var.line_nr=61
						// var "orig_name" var.pos=1894 var.line_nr=75
						// var "ast_fields" var.pos=2086 var.line_nr=85
						// var "fields" var.pos=2125 var.line_nr=86
						// var "embed_types" var.pos=2160 var.line_nr=87
						// var "embeds" var.pos=2193 var.line_nr=88
						// var "embed_field_names" var.pos=2222 var.line_nr=89
						// var "mut_pos" var.pos=2259 var.line_nr=90
						// var "pub_pos" var.pos=2278 var.line_nr=91
						// var "pub_mut_pos" var.pos=2297 var.line_nr=92
						// var "global_pos" var.pos=2320 var.line_nr=93
						// var "module_pos" var.pos=2342 var.line_nr=94
						// var "is_field_mut" var.pos=2364 var.line_nr=95
						// var "is_field_pub" var.pos=2391 var.line_nr=96
						// var "is_field_global" var.pos=2418 var.line_nr=97
						// var "last_line" var.pos=2448 var.line_nr=98
						// var "end_comments" var.pos=2469 var.line_nr=99
						// var "t" var.pos=7434 var.line_nr=289
						// var "ret" var.pos=7931 var.line_nr=310
						// af parent scope:
						// af parent scope:
						return _t2740;
					}
					pub_pos = ast_fields.len;
					is_field_pub = true;
					is_field_mut = false;
					is_field_global = false;
				}
				v__parser__Parser_check(p, v__token__Kind_colon);
			} else if (p->tok.kind == v__token__Kind_key_mut) {
				if (mut_pos != -1) {
					v__parser__Parser_error(p, _SLIT("redefinition of `mut` section"));
					 v__ast__StructDecl _t2741 = (v__ast__StructDecl){.pos = {0},.name = (string){.str=(byteptr)"", .is_lit=1},.gen_types = __new_array(0, 1, sizeof(v__ast__Type)),.is_pub = 0,.mut_pos = 0,.pub_pos = 0,.pub_mut_pos = 0,.global_pos = 0,.module_pos = 0,.language = 0,.is_union = 0,.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.end_comments = __new_array(0, 1, sizeof(v__ast__Comment)),.embeds = __new_array(0, 1, sizeof(v__ast__Embed)),.fields = __new_array(0, 1, sizeof(v__ast__StructField)),};
					// autofree_scope_vars(pos=3473 line_nr=140 scope.pos=3421 scope.end_pos=3502)
					// af parent scope:
					// af parent scope:
					// var "comments" var.pos=2568 var.line_nr=103
					// var "field_start_pos" var.pos=4333 var.line_nr=177
					// var "is_embed" var.pos=4372 var.line_nr=178
					// var "is_on_top" var.pos=4517 var.line_nr=180
					// var "field_name" var.pos=4611 var.line_nr=181
					// var "typ" var.pos=4635 var.line_nr=182
					// var "type_pos" var.pos=4661 var.line_nr=183
					// var "field_pos" var.pos=4697 var.line_nr=184
					// var "default_expr" var.pos=6197 var.line_nr=240
					// var "has_default_expr" var.pos=6237 var.line_nr=241
					// af parent scope:
					// af parent scope:
					// af parent scope:
					// var "p" var.pos=236 var.line_nr=9
					// var "attrs" var.pos=367 var.line_nr=12
					// var "start_pos" var.pos=399 var.line_nr=14
					// var "is_pub" var.pos=430 var.line_nr=15
					// var "is_union" var.pos=491 var.line_nr=19
					// var "language" var.pos=607 var.line_nr=25
					// var "name_pos" var.pos=854 var.line_nr=36
					// var "name" var.pos=930 var.line_nr=38
					// var "generic_types" var.pos=1229 var.line_nr=49
					// var "no_body" var.pos=1416 var.line_nr=61
					// var "orig_name" var.pos=1894 var.line_nr=75
					// var "ast_fields" var.pos=2086 var.line_nr=85
					// var "fields" var.pos=2125 var.line_nr=86
					// var "embed_types" var.pos=2160 var.line_nr=87
					// var "embeds" var.pos=2193 var.line_nr=88
					// var "embed_field_names" var.pos=2222 var.line_nr=89
					// var "mut_pos" var.pos=2259 var.line_nr=90
					// var "pub_pos" var.pos=2278 var.line_nr=91
					// var "pub_mut_pos" var.pos=2297 var.line_nr=92
					// var "global_pos" var.pos=2320 var.line_nr=93
					// var "module_pos" var.pos=2342 var.line_nr=94
					// var "is_field_mut" var.pos=2364 var.line_nr=95
					// var "is_field_pub" var.pos=2391 var.line_nr=96
					// var "is_field_global" var.pos=2418 var.line_nr=97
					// var "last_line" var.pos=2448 var.line_nr=98
					// var "end_comments" var.pos=2469 var.line_nr=99
					// var "t" var.pos=7434 var.line_nr=289
					// var "ret" var.pos=7931 var.line_nr=310
					// af parent scope:
					// af parent scope:
					return _t2741;
				}
				v__parser__Parser_next(p);
				v__parser__Parser_check(p, v__token__Kind_colon);
				mut_pos = ast_fields.len;
				is_field_pub = false;
				is_field_mut = true;
				is_field_global = false;
			} else if (p->tok.kind == v__token__Kind_key_global) {
				if (global_pos != -1) {
					v__parser__Parser_error(p, _SLIT("redefinition of `global` section"));
					 v__ast__StructDecl _t2742 = (v__ast__StructDecl){.pos = {0},.name = (string){.str=(byteptr)"", .is_lit=1},.gen_types = __new_array(0, 1, sizeof(v__ast__Type)),.is_pub = 0,.mut_pos = 0,.pub_pos = 0,.pub_mut_pos = 0,.global_pos = 0,.module_pos = 0,.language = 0,.is_union = 0,.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.end_comments = __new_array(0, 1, sizeof(v__ast__Comment)),.embeds = __new_array(0, 1, sizeof(v__ast__Embed)),.fields = __new_array(0, 1, sizeof(v__ast__StructField)),};
					// autofree_scope_vars(pos=3763 line_nr=151 scope.pos=3708 scope.end_pos=3792)
					// af parent scope:
					// af parent scope:
					// var "comments" var.pos=2568 var.line_nr=103
					// var "field_start_pos" var.pos=4333 var.line_nr=177
					// var "is_embed" var.pos=4372 var.line_nr=178
					// var "is_on_top" var.pos=4517 var.line_nr=180
					// var "field_name" var.pos=4611 var.line_nr=181
					// var "typ" var.pos=4635 var.line_nr=182
					// var "type_pos" var.pos=4661 var.line_nr=183
					// var "field_pos" var.pos=4697 var.line_nr=184
					// var "default_expr" var.pos=6197 var.line_nr=240
					// var "has_default_expr" var.pos=6237 var.line_nr=241
					// af parent scope:
					// af parent scope:
					// af parent scope:
					// var "p" var.pos=236 var.line_nr=9
					// var "attrs" var.pos=367 var.line_nr=12
					// var "start_pos" var.pos=399 var.line_nr=14
					// var "is_pub" var.pos=430 var.line_nr=15
					// var "is_union" var.pos=491 var.line_nr=19
					// var "language" var.pos=607 var.line_nr=25
					// var "name_pos" var.pos=854 var.line_nr=36
					// var "name" var.pos=930 var.line_nr=38
					// var "generic_types" var.pos=1229 var.line_nr=49
					// var "no_body" var.pos=1416 var.line_nr=61
					// var "orig_name" var.pos=1894 var.line_nr=75
					// var "ast_fields" var.pos=2086 var.line_nr=85
					// var "fields" var.pos=2125 var.line_nr=86
					// var "embed_types" var.pos=2160 var.line_nr=87
					// var "embeds" var.pos=2193 var.line_nr=88
					// var "embed_field_names" var.pos=2222 var.line_nr=89
					// var "mut_pos" var.pos=2259 var.line_nr=90
					// var "pub_pos" var.pos=2278 var.line_nr=91
					// var "pub_mut_pos" var.pos=2297 var.line_nr=92
					// var "global_pos" var.pos=2320 var.line_nr=93
					// var "module_pos" var.pos=2342 var.line_nr=94
					// var "is_field_mut" var.pos=2364 var.line_nr=95
					// var "is_field_pub" var.pos=2391 var.line_nr=96
					// var "is_field_global" var.pos=2418 var.line_nr=97
					// var "last_line" var.pos=2448 var.line_nr=98
					// var "end_comments" var.pos=2469 var.line_nr=99
					// var "t" var.pos=7434 var.line_nr=289
					// var "ret" var.pos=7931 var.line_nr=310
					// af parent scope:
					// af parent scope:
					return _t2742;
				}
				v__parser__Parser_next(p);
				v__parser__Parser_check(p, v__token__Kind_colon);
				global_pos = ast_fields.len;
				is_field_pub = true;
				is_field_mut = true;
				is_field_global = true;
			} else if (p->tok.kind == v__token__Kind_key_module) {
				if (module_pos != -1) {
					v__parser__Parser_error(p, _SLIT("redefinition of `module` section"));
					 v__ast__StructDecl _t2743 = (v__ast__StructDecl){.pos = {0},.name = (string){.str=(byteptr)"", .is_lit=1},.gen_types = __new_array(0, 1, sizeof(v__ast__Type)),.is_pub = 0,.mut_pos = 0,.pub_pos = 0,.pub_mut_pos = 0,.global_pos = 0,.module_pos = 0,.language = 0,.is_union = 0,.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.end_comments = __new_array(0, 1, sizeof(v__ast__Comment)),.embeds = __new_array(0, 1, sizeof(v__ast__Embed)),.fields = __new_array(0, 1, sizeof(v__ast__StructField)),};
					// autofree_scope_vars(pos=4054 line_nr=162 scope.pos=3999 scope.end_pos=4069)
					// af parent scope:
					// af parent scope:
					// var "comments" var.pos=2568 var.line_nr=103
					// var "field_start_pos" var.pos=4333 var.line_nr=177
					// var "is_embed" var.pos=4372 var.line_nr=178
					// var "is_on_top" var.pos=4517 var.line_nr=180
					// var "field_name" var.pos=4611 var.line_nr=181
					// var "typ" var.pos=4635 var.line_nr=182
					// var "type_pos" var.pos=4661 var.line_nr=183
					// var "field_pos" var.pos=4697 var.line_nr=184
					// var "default_expr" var.pos=6197 var.line_nr=240
					// var "has_default_expr" var.pos=6237 var.line_nr=241
					// af parent scope:
					// af parent scope:
					// af parent scope:
					// var "p" var.pos=236 var.line_nr=9
					// var "attrs" var.pos=367 var.line_nr=12
					// var "start_pos" var.pos=399 var.line_nr=14
					// var "is_pub" var.pos=430 var.line_nr=15
					// var "is_union" var.pos=491 var.line_nr=19
					// var "language" var.pos=607 var.line_nr=25
					// var "name_pos" var.pos=854 var.line_nr=36
					// var "name" var.pos=930 var.line_nr=38
					// var "generic_types" var.pos=1229 var.line_nr=49
					// var "no_body" var.pos=1416 var.line_nr=61
					// var "orig_name" var.pos=1894 var.line_nr=75
					// var "ast_fields" var.pos=2086 var.line_nr=85
					// var "fields" var.pos=2125 var.line_nr=86
					// var "embed_types" var.pos=2160 var.line_nr=87
					// var "embeds" var.pos=2193 var.line_nr=88
					// var "embed_field_names" var.pos=2222 var.line_nr=89
					// var "mut_pos" var.pos=2259 var.line_nr=90
					// var "pub_pos" var.pos=2278 var.line_nr=91
					// var "pub_mut_pos" var.pos=2297 var.line_nr=92
					// var "global_pos" var.pos=2320 var.line_nr=93
					// var "module_pos" var.pos=2342 var.line_nr=94
					// var "is_field_mut" var.pos=2364 var.line_nr=95
					// var "is_field_pub" var.pos=2391 var.line_nr=96
					// var "is_field_global" var.pos=2418 var.line_nr=97
					// var "last_line" var.pos=2448 var.line_nr=98
					// var "end_comments" var.pos=2469 var.line_nr=99
					// var "t" var.pos=7434 var.line_nr=289
					// var "ret" var.pos=7931 var.line_nr=310
					// af parent scope:
					// af parent scope:
					return _t2743;
				}
				v__parser__Parser_next(p);
				v__parser__Parser_check(p, v__token__Kind_colon);
				module_pos = ast_fields.len;
				is_field_pub = false;
				is_field_mut = false;
				is_field_global = false;
			}
			for (;;) {
				if (!(p->tok.kind == v__token__Kind_comment)) break;
				array_push(&comments, _MOV((v__ast__Comment[]){ v__parser__Parser_comment(p) }));
				if (p->tok.kind == v__token__Kind_rcbr) {
					break;
				}
			}
			v__token__Position field_start_pos = v__token__Token_position(&p->tok);
			bool is_embed = ((p->tok.lit.len > 1 && byte_is_capital(string_at(p->tok.lit, 0))) || p->peek_tok.kind == v__token__Kind_dot) && language == v__ast__Language_v && p->peek_tok.kind != v__token__Kind_key_fn;
			bool is_on_top = ast_fields.len == 0 && !(is_field_mut || is_field_mut || is_field_global);
			string field_name = _SLIT("");
			v__ast__Type typ = ((v__ast__Type)(0));
			v__token__Position type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,};
			v__token__Position field_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,};
			if (is_embed) {
				type_pos = v__token__Token_position(&p->tok);
				typ = v__parser__Parser_parse_type(p);
				for (;;) {
					if (!(p->tok.kind == v__token__Kind_comment)) break;
					array_push(&comments, _MOV((v__ast__Comment[]){ v__parser__Parser_comment(p) }));
					if (p->tok.kind == v__token__Kind_rcbr) {
						break;
					}
				}
				type_pos = v__token__Position_extend(type_pos, v__token__Token_position(&p->prev_tok));
				if (!is_on_top) {
					v__parser__Parser_error_with_pos(p, _SLIT("struct embedding must be declared at the beginning of the struct body"), type_pos);
					 v__ast__StructDecl _t2746 = (v__ast__StructDecl){.pos = {0},.name = (string){.str=(byteptr)"", .is_lit=1},.gen_types = __new_array(0, 1, sizeof(v__ast__Type)),.is_pub = 0,.mut_pos = 0,.pub_pos = 0,.pub_mut_pos = 0,.global_pos = 0,.module_pos = 0,.language = 0,.is_union = 0,.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.end_comments = __new_array(0, 1, sizeof(v__ast__Comment)),.embeds = __new_array(0, 1, sizeof(v__ast__Embed)),.fields = __new_array(0, 1, sizeof(v__ast__StructField)),};
					// autofree_scope_vars(pos=5131 line_nr=199 scope.pos=5014 scope.end_pos=5160)
					// af parent scope:
					// var "sym" var.pos=5166 var.line_nr=201
					// af parent scope:
					// var "comments" var.pos=2568 var.line_nr=103
					// var "field_start_pos" var.pos=4333 var.line_nr=177
					// var "is_embed" var.pos=4372 var.line_nr=178
					// var "is_on_top" var.pos=4517 var.line_nr=180
					// var "field_name" var.pos=4611 var.line_nr=181
					// str literal
					// var "typ" var.pos=4635 var.line_nr=182
					// var "type_pos" var.pos=4661 var.line_nr=183
					// var "field_pos" var.pos=4697 var.line_nr=184
					// var "default_expr" var.pos=6197 var.line_nr=240
					// var "has_default_expr" var.pos=6237 var.line_nr=241
					// af parent scope:
					// af parent scope:
					// af parent scope:
					// var "p" var.pos=236 var.line_nr=9
					// var "attrs" var.pos=367 var.line_nr=12
					// var "start_pos" var.pos=399 var.line_nr=14
					// var "is_pub" var.pos=430 var.line_nr=15
					// var "is_union" var.pos=491 var.line_nr=19
					// var "language" var.pos=607 var.line_nr=25
					// var "name_pos" var.pos=854 var.line_nr=36
					// var "name" var.pos=930 var.line_nr=38
					// var "generic_types" var.pos=1229 var.line_nr=49
					// var "no_body" var.pos=1416 var.line_nr=61
					// var "orig_name" var.pos=1894 var.line_nr=75
					// var "ast_fields" var.pos=2086 var.line_nr=85
					// var "fields" var.pos=2125 var.line_nr=86
					// var "embed_types" var.pos=2160 var.line_nr=87
					// var "embeds" var.pos=2193 var.line_nr=88
					// var "embed_field_names" var.pos=2222 var.line_nr=89
					// var "mut_pos" var.pos=2259 var.line_nr=90
					// var "pub_pos" var.pos=2278 var.line_nr=91
					// var "pub_mut_pos" var.pos=2297 var.line_nr=92
					// var "global_pos" var.pos=2320 var.line_nr=93
					// var "module_pos" var.pos=2342 var.line_nr=94
					// var "is_field_mut" var.pos=2364 var.line_nr=95
					// var "is_field_pub" var.pos=2391 var.line_nr=96
					// var "is_field_global" var.pos=2418 var.line_nr=97
					// var "last_line" var.pos=2448 var.line_nr=98
					// var "end_comments" var.pos=2469 var.line_nr=99
					// var "t" var.pos=7434 var.line_nr=289
					// var "ret" var.pos=7931 var.line_nr=310
					// af parent scope:
					// af parent scope:
					return _t2746;
				}
				v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(p->table, typ);
				if ((Array_v__ast__Type_contains(embed_types, typ))) {
					v__parser__Parser_error_with_pos(p, _STR("cannot embed `%.*s\000` more than once", 2, sym->name), type_pos);
					 v__ast__StructDecl _t2747 = (v__ast__StructDecl){.pos = {0},.name = (string){.str=(byteptr)"", .is_lit=1},.gen_types = __new_array(0, 1, sizeof(v__ast__Type)),.is_pub = 0,.mut_pos = 0,.pub_pos = 0,.pub_mut_pos = 0,.global_pos = 0,.module_pos = 0,.language = 0,.is_union = 0,.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.end_comments = __new_array(0, 1, sizeof(v__ast__Comment)),.embeds = __new_array(0, 1, sizeof(v__ast__Embed)),.fields = __new_array(0, 1, sizeof(v__ast__StructField)),};
					// autofree_scope_vars(pos=5309 line_nr=204 scope.pos=5228 scope.end_pos=5338)
					// af parent scope:
					// var "sym" var.pos=5166 var.line_nr=201
					// af parent scope:
					// var "comments" var.pos=2568 var.line_nr=103
					// var "field_start_pos" var.pos=4333 var.line_nr=177
					// var "is_embed" var.pos=4372 var.line_nr=178
					// var "is_on_top" var.pos=4517 var.line_nr=180
					// var "field_name" var.pos=4611 var.line_nr=181
					// str literal
					// var "typ" var.pos=4635 var.line_nr=182
					// var "type_pos" var.pos=4661 var.line_nr=183
					// var "field_pos" var.pos=4697 var.line_nr=184
					// var "default_expr" var.pos=6197 var.line_nr=240
					// var "has_default_expr" var.pos=6237 var.line_nr=241
					// af parent scope:
					// af parent scope:
					// af parent scope:
					// var "p" var.pos=236 var.line_nr=9
					// var "attrs" var.pos=367 var.line_nr=12
					// var "start_pos" var.pos=399 var.line_nr=14
					// var "is_pub" var.pos=430 var.line_nr=15
					// var "is_union" var.pos=491 var.line_nr=19
					// var "language" var.pos=607 var.line_nr=25
					// var "name_pos" var.pos=854 var.line_nr=36
					// var "name" var.pos=930 var.line_nr=38
					// var "generic_types" var.pos=1229 var.line_nr=49
					// var "no_body" var.pos=1416 var.line_nr=61
					// var "orig_name" var.pos=1894 var.line_nr=75
					// var "ast_fields" var.pos=2086 var.line_nr=85
					// var "fields" var.pos=2125 var.line_nr=86
					// var "embed_types" var.pos=2160 var.line_nr=87
					// var "embeds" var.pos=2193 var.line_nr=88
					// var "embed_field_names" var.pos=2222 var.line_nr=89
					// var "mut_pos" var.pos=2259 var.line_nr=90
					// var "pub_pos" var.pos=2278 var.line_nr=91
					// var "pub_mut_pos" var.pos=2297 var.line_nr=92
					// var "global_pos" var.pos=2320 var.line_nr=93
					// var "module_pos" var.pos=2342 var.line_nr=94
					// var "is_field_mut" var.pos=2364 var.line_nr=95
					// var "is_field_pub" var.pos=2391 var.line_nr=96
					// var "is_field_global" var.pos=2418 var.line_nr=97
					// var "last_line" var.pos=2448 var.line_nr=98
					// var "end_comments" var.pos=2469 var.line_nr=99
					// var "t" var.pos=7434 var.line_nr=289
					// var "ret" var.pos=7931 var.line_nr=310
					// af parent scope:
					// af parent scope:
					return _t2747;
				}
				field_name = v__ast__TypeSymbol_embed_name(sym);
				if ((Array_string_contains(embed_field_names, field_name))) {
					v__parser__Parser_error_with_pos(p, _STR("duplicate field `%.*s\000`", 2, field_name), type_pos);
					 v__ast__StructDecl _t2748 = (v__ast__StructDecl){.pos = {0},.name = (string){.str=(byteptr)"", .is_lit=1},.gen_types = __new_array(0, 1, sizeof(v__ast__Type)),.is_pub = 0,.mut_pos = 0,.pub_pos = 0,.pub_mut_pos = 0,.global_pos = 0,.module_pos = 0,.language = 0,.is_union = 0,.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.end_comments = __new_array(0, 1, sizeof(v__ast__Comment)),.embeds = __new_array(0, 1, sizeof(v__ast__Embed)),.fields = __new_array(0, 1, sizeof(v__ast__StructField)),};
					// autofree_scope_vars(pos=5484 line_nr=209 scope.pos=5413 scope.end_pos=5513)
					// af parent scope:
					// var "sym" var.pos=5166 var.line_nr=201
					// af parent scope:
					// var "comments" var.pos=2568 var.line_nr=103
					// var "field_start_pos" var.pos=4333 var.line_nr=177
					// var "is_embed" var.pos=4372 var.line_nr=178
					// var "is_on_top" var.pos=4517 var.line_nr=180
					// var "field_name" var.pos=4611 var.line_nr=181
					// str literal
					// var "typ" var.pos=4635 var.line_nr=182
					// var "type_pos" var.pos=4661 var.line_nr=183
					// var "field_pos" var.pos=4697 var.line_nr=184
					// var "default_expr" var.pos=6197 var.line_nr=240
					// var "has_default_expr" var.pos=6237 var.line_nr=241
					// af parent scope:
					// af parent scope:
					// af parent scope:
					// var "p" var.pos=236 var.line_nr=9
					// var "attrs" var.pos=367 var.line_nr=12
					// var "start_pos" var.pos=399 var.line_nr=14
					// var "is_pub" var.pos=430 var.line_nr=15
					// var "is_union" var.pos=491 var.line_nr=19
					// var "language" var.pos=607 var.line_nr=25
					// var "name_pos" var.pos=854 var.line_nr=36
					// var "name" var.pos=930 var.line_nr=38
					// var "generic_types" var.pos=1229 var.line_nr=49
					// var "no_body" var.pos=1416 var.line_nr=61
					// var "orig_name" var.pos=1894 var.line_nr=75
					// var "ast_fields" var.pos=2086 var.line_nr=85
					// var "fields" var.pos=2125 var.line_nr=86
					// var "embed_types" var.pos=2160 var.line_nr=87
					// var "embeds" var.pos=2193 var.line_nr=88
					// var "embed_field_names" var.pos=2222 var.line_nr=89
					// var "mut_pos" var.pos=2259 var.line_nr=90
					// var "pub_pos" var.pos=2278 var.line_nr=91
					// var "pub_mut_pos" var.pos=2297 var.line_nr=92
					// var "global_pos" var.pos=2320 var.line_nr=93
					// var "module_pos" var.pos=2342 var.line_nr=94
					// var "is_field_mut" var.pos=2364 var.line_nr=95
					// var "is_field_pub" var.pos=2391 var.line_nr=96
					// var "is_field_global" var.pos=2418 var.line_nr=97
					// var "last_line" var.pos=2448 var.line_nr=98
					// var "end_comments" var.pos=2469 var.line_nr=99
					// var "t" var.pos=7434 var.line_nr=289
					// var "ret" var.pos=7931 var.line_nr=310
					// af parent scope:
					// af parent scope:
					return _t2748;
				}
				array_push(&embed_field_names, _MOV((string[]){ string_clone(field_name) }));
				array_push(&embed_types, _MOV((v__ast__Type[]){ typ }));
				array_push(&embeds, _MOV((v__ast__Embed[]){ (v__ast__Embed){.typ = typ,.pos = type_pos,} }));
			} else {
				field_name = v__parser__Parser_check_name(p);
				for (;;) {
					if (!(p->tok.kind == v__token__Kind_comment)) break;
					array_push(&comments, _MOV((v__ast__Comment[]){ v__parser__Parser_comment(p) }));
					if (p->tok.kind == v__token__Kind_rcbr) {
						break;
					}
				}
				typ = v__parser__Parser_parse_type(p);
				if (v__ast__Type_idx(typ) == 0) {
					 v__ast__StructDecl _t2753 = (v__ast__StructDecl){.pos = {0},.name = (string){.str=(byteptr)"", .is_lit=1},.gen_types = __new_array(0, 1, sizeof(v__ast__Type)),.is_pub = 0,.mut_pos = 0,.pub_pos = 0,.pub_mut_pos = 0,.global_pos = 0,.module_pos = 0,.language = 0,.is_union = 0,.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.end_comments = __new_array(0, 1, sizeof(v__ast__Comment)),.embeds = __new_array(0, 1, sizeof(v__ast__Embed)),.fields = __new_array(0, 1, sizeof(v__ast__StructField)),};
					// autofree_scope_vars(pos=5907 line_nr=229 scope.pos=5866 scope.end_pos=5936)
					// af parent scope:
					// af parent scope:
					// var "comments" var.pos=2568 var.line_nr=103
					// var "field_start_pos" var.pos=4333 var.line_nr=177
					// var "is_embed" var.pos=4372 var.line_nr=178
					// var "is_on_top" var.pos=4517 var.line_nr=180
					// var "field_name" var.pos=4611 var.line_nr=181
					// str literal
					// var "typ" var.pos=4635 var.line_nr=182
					// var "type_pos" var.pos=4661 var.line_nr=183
					// var "field_pos" var.pos=4697 var.line_nr=184
					// var "default_expr" var.pos=6197 var.line_nr=240
					// var "has_default_expr" var.pos=6237 var.line_nr=241
					// af parent scope:
					// af parent scope:
					// af parent scope:
					// var "p" var.pos=236 var.line_nr=9
					// var "attrs" var.pos=367 var.line_nr=12
					// var "start_pos" var.pos=399 var.line_nr=14
					// var "is_pub" var.pos=430 var.line_nr=15
					// var "is_union" var.pos=491 var.line_nr=19
					// var "language" var.pos=607 var.line_nr=25
					// var "name_pos" var.pos=854 var.line_nr=36
					// var "name" var.pos=930 var.line_nr=38
					// var "generic_types" var.pos=1229 var.line_nr=49
					// var "no_body" var.pos=1416 var.line_nr=61
					// var "orig_name" var.pos=1894 var.line_nr=75
					// var "ast_fields" var.pos=2086 var.line_nr=85
					// var "fields" var.pos=2125 var.line_nr=86
					// var "embed_types" var.pos=2160 var.line_nr=87
					// var "embeds" var.pos=2193 var.line_nr=88
					// var "embed_field_names" var.pos=2222 var.line_nr=89
					// var "mut_pos" var.pos=2259 var.line_nr=90
					// var "pub_pos" var.pos=2278 var.line_nr=91
					// var "pub_mut_pos" var.pos=2297 var.line_nr=92
					// var "global_pos" var.pos=2320 var.line_nr=93
					// var "module_pos" var.pos=2342 var.line_nr=94
					// var "is_field_mut" var.pos=2364 var.line_nr=95
					// var "is_field_pub" var.pos=2391 var.line_nr=96
					// var "is_field_global" var.pos=2418 var.line_nr=97
					// var "last_line" var.pos=2448 var.line_nr=98
					// var "end_comments" var.pos=2469 var.line_nr=99
					// var "t" var.pos=7434 var.line_nr=289
					// var "ret" var.pos=7931 var.line_nr=310
					// af parent scope:
					// af parent scope:
					return _t2753;
				}
				type_pos = v__token__Token_position(&p->prev_tok);
				field_pos = v__token__Position_extend(field_start_pos, type_pos);
			}
			_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,})), _t2754, Array_v__ast__Comment);
			if (p->tok.kind == v__token__Kind_lsbr) {
				v__parser__Parser_attributes(p);
			}
			v__ast__Expr default_expr = v__ast__empty_expr();
			bool has_default_expr = false;
			if (!is_embed) {
				if (p->tok.kind == v__token__Kind_assign) {
					v__parser__Parser_next(p);
					default_expr = v__parser__Parser_expr(p, 0);
					if (default_expr._typ == 251 /* v.ast.EnumVal */) {
						(*default_expr._v__ast__EnumVal).typ = typ;
					}
					else {
					};
					has_default_expr = true;
					_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,})), _t2755, Array_v__ast__Comment);
				}
				array_push(&ast_fields, _MOV((v__ast__StructField[]){ (v__ast__StructField){
					.pos = field_pos,
					.type_pos = type_pos,
					.comments = comments,
					.default_expr = default_expr,
					.has_default_expr = has_default_expr,
					.attrs = p->attrs,
					.is_pub = is_embed || is_field_pub,
					.default_val = (string){.str=(byteptr)"", .is_lit=1},
					.is_mut = is_embed || is_field_mut,
					.is_global = is_field_global,
					.default_expr_typ = 0,
					.name = field_name,
					.typ = typ,
				} }));
			}
			array_push(&fields, _MOV((v__ast__StructField[]){ (v__ast__StructField){
				.pos = field_pos,
				.type_pos = type_pos,
				.comments = comments,
				.default_expr = default_expr,
				.has_default_expr = has_default_expr,
				.attrs = p->attrs,
				.is_pub = is_embed || is_field_pub,
				.default_val = (string){.str=(byteptr)"", .is_lit=1},
				.is_mut = is_embed || is_field_mut,
				.is_global = is_field_global,
				.default_expr_typ = 0,
				.name = field_name,
				.typ = typ,
			} }));
			p->attrs = __new_array_with_default(0, 0, sizeof(v__ast__Attr), 0);
		}
		v__parser__Parser_top_level_statement_end(p);
		last_line = p->tok.line_nr;
		v__parser__Parser_check(p, v__token__Kind_rcbr);
	}
	v__ast__TypeSymbol t = (v__ast__TypeSymbol){
		.parent_idx = 0,
		.info = v__ast__Struct_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__Struct, ((v__ast__Struct){
			.attrs = attrs,
			.embeds = embed_types,
			.fields = fields,
			.is_typedef = Array_v__ast__Attr_contains(attrs, _SLIT("typedef")),
			.is_union = is_union,
			.is_heap = Array_v__ast__Attr_contains(attrs, _SLIT("heap")),
			.generic_types = generic_types,
			.concrete_types = __new_array(0, 1, sizeof(v__ast__Type)),
			.parent_type = 0,
		}))),
		.kind = v__ast__Kind_struct_,
		.name = name,
		.cname = v__util__no_dots(name),
		.methods = __new_array(0, 1, sizeof(v__ast__Fn)),
		.mod = p->mod,
		.is_public = is_pub,
		.language = language,
	};
	if (v__ast__Table_has_deep_child_no_ref(p->table, &t, name)) {
		v__parser__Parser_error_with_pos(p, _STR("invalid recursive struct `%.*s\000`", 2, orig_name), name_pos);
		 v__ast__StructDecl _t2758 = (v__ast__StructDecl){.pos = {0},.name = (string){.str=(byteptr)"", .is_lit=1},.gen_types = __new_array(0, 1, sizeof(v__ast__Type)),.is_pub = 0,.mut_pos = 0,.pub_pos = 0,.pub_mut_pos = 0,.global_pos = 0,.module_pos = 0,.language = 0,.is_union = 0,.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.end_comments = __new_array(0, 1, sizeof(v__ast__Comment)),.embeds = __new_array(0, 1, sizeof(v__ast__Embed)),.fields = __new_array(0, 1, sizeof(v__ast__StructField)),};
		// autofree_scope_vars(pos=7898 line_nr=308 scope.pos=7825 scope.end_pos=7924)
		// af parent scope:
		// var "p" var.pos=236 var.line_nr=9
		// var "attrs" var.pos=367 var.line_nr=12
		// var "start_pos" var.pos=399 var.line_nr=14
		// var "is_pub" var.pos=430 var.line_nr=15
		// var "is_union" var.pos=491 var.line_nr=19
		// var "language" var.pos=607 var.line_nr=25
		// var "name_pos" var.pos=854 var.line_nr=36
		// var "name" var.pos=930 var.line_nr=38
		// var "generic_types" var.pos=1229 var.line_nr=49
		// var "no_body" var.pos=1416 var.line_nr=61
		// var "orig_name" var.pos=1894 var.line_nr=75
		// var "ast_fields" var.pos=2086 var.line_nr=85
		// var "fields" var.pos=2125 var.line_nr=86
		// var "embed_types" var.pos=2160 var.line_nr=87
		// var "embeds" var.pos=2193 var.line_nr=88
		// var "embed_field_names" var.pos=2222 var.line_nr=89
		// var "mut_pos" var.pos=2259 var.line_nr=90
		// var "pub_pos" var.pos=2278 var.line_nr=91
		// var "pub_mut_pos" var.pos=2297 var.line_nr=92
		// var "global_pos" var.pos=2320 var.line_nr=93
		// var "module_pos" var.pos=2342 var.line_nr=94
		// var "is_field_mut" var.pos=2364 var.line_nr=95
		// var "is_field_pub" var.pos=2391 var.line_nr=96
		// var "is_field_global" var.pos=2418 var.line_nr=97
		// var "last_line" var.pos=2448 var.line_nr=98
		// var "end_comments" var.pos=2469 var.line_nr=99
		// var "t" var.pos=7434 var.line_nr=289
		// var "ret" var.pos=7931 var.line_nr=310
		// af parent scope:
		// af parent scope:
		return _t2758;
	}
	int ret = 0;
	ret = v__ast__Table_register_type_symbol(p->table, t);
	if (ret == -1 && language != v__ast__Language_c) {
		v__parser__Parser_error_with_pos(p, _STR("cannot register struct `%.*s\000`, another type with this name exists", 2, name), name_pos);
		 v__ast__StructDecl _t2759 = (v__ast__StructDecl){.pos = {0},.name = (string){.str=(byteptr)"", .is_lit=1},.gen_types = __new_array(0, 1, sizeof(v__ast__Type)),.is_pub = 0,.mut_pos = 0,.pub_pos = 0,.pub_mut_pos = 0,.global_pos = 0,.module_pos = 0,.language = 0,.is_union = 0,.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.end_comments = __new_array(0, 1, sizeof(v__ast__Comment)),.embeds = __new_array(0, 1, sizeof(v__ast__Embed)),.fields = __new_array(0, 1, sizeof(v__ast__StructField)),};
		// autofree_scope_vars(pos=8206 line_nr=317 scope.pos=8101 scope.end_pos=8232)
		// af parent scope:
		// var "p" var.pos=236 var.line_nr=9
		// var "attrs" var.pos=367 var.line_nr=12
		// var "start_pos" var.pos=399 var.line_nr=14
		// var "is_pub" var.pos=430 var.line_nr=15
		// var "is_union" var.pos=491 var.line_nr=19
		// var "language" var.pos=607 var.line_nr=25
		// var "name_pos" var.pos=854 var.line_nr=36
		// var "name" var.pos=930 var.line_nr=38
		// var "generic_types" var.pos=1229 var.line_nr=49
		// var "no_body" var.pos=1416 var.line_nr=61
		// var "orig_name" var.pos=1894 var.line_nr=75
		// var "ast_fields" var.pos=2086 var.line_nr=85
		// var "fields" var.pos=2125 var.line_nr=86
		// var "embed_types" var.pos=2160 var.line_nr=87
		// var "embeds" var.pos=2193 var.line_nr=88
		// var "embed_field_names" var.pos=2222 var.line_nr=89
		// var "mut_pos" var.pos=2259 var.line_nr=90
		// var "pub_pos" var.pos=2278 var.line_nr=91
		// var "pub_mut_pos" var.pos=2297 var.line_nr=92
		// var "global_pos" var.pos=2320 var.line_nr=93
		// var "module_pos" var.pos=2342 var.line_nr=94
		// var "is_field_mut" var.pos=2364 var.line_nr=95
		// var "is_field_pub" var.pos=2391 var.line_nr=96
		// var "is_field_global" var.pos=2418 var.line_nr=97
		// var "last_line" var.pos=2448 var.line_nr=98
		// var "end_comments" var.pos=2469 var.line_nr=99
		// var "t" var.pos=7434 var.line_nr=289
		// var "ret" var.pos=7931 var.line_nr=310
		// af parent scope:
		// af parent scope:
		return _t2759;
	}
	p->expr_mod = _SLIT("");
	 v__ast__StructDecl _t2760 = (v__ast__StructDecl){
		.pos = v__token__Position_extend_with_last_line(start_pos, name_pos, last_line),
		.name = name,
		.gen_types = generic_types,
		.is_pub = is_pub,
		.mut_pos = mut_pos,
		.pub_pos = pub_pos,
		.pub_mut_pos = pub_mut_pos,
		.global_pos = global_pos,
		.module_pos = module_pos,
		.language = language,
		.is_union = is_union,
		.attrs = attrs,
		.end_comments = end_comments,
		.embeds = embeds,
		.fields = ast_fields,
	};
	// autofree_scope_vars(pos=8251 line_nr=320 scope.pos=231 scope.end_pos=8634)
	// var "p" var.pos=236 var.line_nr=9
	// var "attrs" var.pos=367 var.line_nr=12
	// var "start_pos" var.pos=399 var.line_nr=14
	// var "is_pub" var.pos=430 var.line_nr=15
	// var "is_union" var.pos=491 var.line_nr=19
	// var "language" var.pos=607 var.line_nr=25
	// var "name_pos" var.pos=854 var.line_nr=36
	// var "name" var.pos=930 var.line_nr=38
	// var "generic_types" var.pos=1229 var.line_nr=49
	// var "no_body" var.pos=1416 var.line_nr=61
	// var "orig_name" var.pos=1894 var.line_nr=75
	// var "ast_fields" var.pos=2086 var.line_nr=85
	// var "fields" var.pos=2125 var.line_nr=86
	// var "embed_types" var.pos=2160 var.line_nr=87
	// var "embeds" var.pos=2193 var.line_nr=88
	// var "embed_field_names" var.pos=2222 var.line_nr=89
	// var "mut_pos" var.pos=2259 var.line_nr=90
	// var "pub_pos" var.pos=2278 var.line_nr=91
	// var "pub_mut_pos" var.pos=2297 var.line_nr=92
	// var "global_pos" var.pos=2320 var.line_nr=93
	// var "module_pos" var.pos=2342 var.line_nr=94
	// var "is_field_mut" var.pos=2364 var.line_nr=95
	// var "is_field_pub" var.pos=2391 var.line_nr=96
	// var "is_field_global" var.pos=2418 var.line_nr=97
	// var "last_line" var.pos=2448 var.line_nr=98
	// var "end_comments" var.pos=2469 var.line_nr=99
	// var "t" var.pos=7434 var.line_nr=289
	// var "ret" var.pos=7931 var.line_nr=310
	// af parent scope:
	// af parent scope:
	return _t2760;
}

VV_LOCAL_SYMBOL v__ast__StructInit v__parser__Parser_struct_init(v__parser__Parser* p, bool short_syntax) {
	v__token__Position first_pos = v__token__Token_position(&p->tok);
	v__ast__Type typ = (short_syntax ? (_const_v__ast__void_type) : (v__parser__Parser_parse_type(p)));
	p->expr_mod = _SLIT("");
	if (!short_syntax) {
		v__parser__Parser_check(p, v__token__Kind_lcbr);
	}
	Array_v__ast__Comment pre_comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,});
	Array_v__ast__StructInitField fields = __new_array_with_default(0, 0, sizeof(v__ast__StructInitField), 0);
	int i = 0;
	bool no_keys = p->peek_tok.kind != v__token__Kind_colon && p->tok.kind != v__token__Kind_rcbr && p->tok.kind != v__token__Kind_ellipsis;
	bool saved_is_amp = p->is_amp;
	p->is_amp = false;
	v__ast__Expr update_expr = v__ast__empty_expr();
	Array_v__ast__Comment update_expr_comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	bool has_update_expr = false;
	for (;;) {
		if (!(!(p->tok.kind == v__token__Kind_rcbr || p->tok.kind == v__token__Kind_rpar || p->tok.kind == v__token__Kind_eof))) break;
		string field_name = _SLIT("");
		v__ast__Expr expr = v__ast__empty_expr();
		v__token__Position field_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,};
		v__token__Position first_field_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,};
		Array_v__ast__Comment comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
		Array_v__ast__Comment nline_comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
		bool is_update_expr = fields.len == 0 && p->tok.kind == v__token__Kind_ellipsis;
		if (no_keys) {
			expr = v__parser__Parser_expr(p, 0);
			field_pos = v__ast__Expr_position(expr);
			first_field_pos = field_pos;
			comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = true,.follow_up = 0,});
		} else if (is_update_expr) {
			v__parser__Parser_check(p, v__token__Kind_ellipsis);
			update_expr = v__parser__Parser_expr(p, 0);
			_PUSH_MANY(&update_expr_comments, (v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = true,.follow_up = 0,})), _t2761, Array_v__ast__Comment);
			has_update_expr = true;
		} else {
			first_field_pos = v__token__Token_position(&p->tok);
			field_name = v__parser__Parser_check_name(p);
			v__parser__Parser_check(p, v__token__Kind_colon);
			expr = v__parser__Parser_expr(p, 0);
			comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = true,.follow_up = 0,});
			v__token__Position last_field_pos = v__ast__Expr_position(expr);
			int field_len = (last_field_pos.len > 0 ? (last_field_pos.pos - first_field_pos.pos + last_field_pos.len) : (first_field_pos.len + 1));
			field_pos = (v__token__Position){.len = field_len,.line_nr = first_field_pos.line_nr,.pos = first_field_pos.pos,.col = first_field_pos.col,.last_line = 0,};
		}
		i++;
		if (p->tok.kind == v__token__Kind_comma) {
			v__parser__Parser_next(p);
		}
		_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = true,.follow_up = 0,})), _t2762, Array_v__ast__Comment);
		_PUSH_MANY(&nline_comments, (v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,})), _t2763, Array_v__ast__Comment);
		if (!is_update_expr) {
			array_push(&fields, _MOV((v__ast__StructInitField[]){ (v__ast__StructInitField){
				.expr = expr,
				.pos = field_pos,
				.name_pos = first_field_pos,
				.comments = comments,
				.next_comments = nline_comments,
				.name = field_name,
				.typ = 0,
				.expected_type = 0,
				.parent_type = typ,
			} }));
		}
	}
	if (!short_syntax) {
		v__parser__Parser_check(p, v__token__Kind_rcbr);
	}
	p->is_amp = saved_is_amp;
	 v__ast__StructInit _t2765 = (v__ast__StructInit){
		.pos = v__token__Position_extend(first_pos, (short_syntax ? (v__token__Token_position(&p->tok)) : (v__token__Token_position(&p->prev_tok)))),
		.name_pos = first_pos,
		.is_short = no_keys,
		.unresolved = v__ast__Type_has_flag(typ, v__ast__TypeFlag_generic),
		.pre_comments = pre_comments,
		.typ = typ,
		.update_expr = update_expr,
		.update_expr_type = 0,
		.update_expr_comments = update_expr_comments,
		.has_update_expr = has_update_expr,
		.fields = fields,
		.embeds = __new_array(0, 1, sizeof(v__ast__StructInitEmbed)),
	};
	// autofree_scope_vars(pos=10978 line_nr=419 scope.pos=8640 scope.end_pos=11341)
	// var "p" var.pos=8645 var.line_nr=339
	// var "short_syntax" var.pos=8667 var.line_nr=339
	// var "first_pos" var.pos=8704 var.line_nr=340
	// var "typ" var.pos=8735 var.line_nr=341
	// var "pre_comments" var.pos=8938 var.line_nr=348
	// var "fields" var.pos=8978 var.line_nr=349
	// var "i" var.pos=9017 var.line_nr=350
	// var "no_keys" var.pos=9025 var.line_nr=351
	// var "saved_is_amp" var.pos=9162 var.line_nr=353
	// var "update_expr" var.pos=9210 var.line_nr=355
	// var "update_expr_comments" var.pos=9247 var.line_nr=356
	// var "has_update_expr" var.pos=9292 var.line_nr=357
	// af parent scope:
	// af parent scope:
	return _t2765;
}

VV_LOCAL_SYMBOL v__ast__InterfaceDecl v__parser__Parser_interface_decl(v__parser__Parser* p) {
	v__parser__Parser_top_level_statement_start(p);
	v__token__Position pos = v__token__Token_position(&p->tok);
	bool is_pub = p->tok.kind == v__token__Kind_key_pub;
	if (is_pub) {
		v__parser__Parser_next(p);
	}
	v__parser__Parser_next(p);
	v__token__Position name_pos = v__token__Token_position(&p->tok);
	string interface_name = string_clone(v__parser__Parser_prepend_mod(p, v__parser__Parser_check_name(p)));
	v__parser__Parser_check(p, v__token__Kind_lcbr);
	Array_v__ast__Comment pre_comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,});
	int reg_idx = v__ast__Table_register_type_symbol(p->table, (v__ast__TypeSymbol){
		.parent_idx = 0,
		.info = v__ast__Interface_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__Interface, ((v__ast__Interface){.types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0),.fields = __new_array(0, 1, sizeof(v__ast__StructField)),.methods = __new_array(0, 1, sizeof(v__ast__Fn)),}))),
		.kind = v__ast__Kind_interface_,
		.name = interface_name,
		.cname = v__util__no_dots(interface_name),
		.methods = __new_array(0, 1, sizeof(v__ast__Fn)),
		.mod = p->mod,
		.is_public = is_pub,
		.language = 0,
	});
	if (reg_idx == -1) {
		v__parser__Parser_error_with_pos(p, _STR("cannot register interface `%.*s\000`, another type with this name exists", 2, interface_name), name_pos);
		 v__ast__InterfaceDecl _t2766 = (v__ast__InterfaceDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.name_pos = {0},.field_names = __new_array(0, 1, sizeof(string)),.is_pub = 0,.methods = __new_array(0, 1, sizeof(v__ast__FnDecl)),.mut_pos = 0,.fields = __new_array(0, 1, sizeof(v__ast__StructField)),.pos = {0},.pre_comments = __new_array(0, 1, sizeof(v__ast__Comment)),};
		// autofree_scope_vars(pos=12086 line_nr=460 scope.pos=11968 scope.end_pos=12115)
		// af parent scope:
		// var "p" var.pos=11352 var.line_nr=433
		// var "pos" var.pos=11435 var.line_nr=435
		// var "is_pub" var.pos=11460 var.line_nr=436
		// var "name_pos" var.pos=11546 var.line_nr=441
		// var "interface_name" var.pos=11576 var.line_nr=442
		// var "pre_comments" var.pos=11695 var.line_nr=445
		// var "reg_idx" var.pos=11752 var.line_nr=447
		// var "typ" var.pos=12118 var.line_nr=462
		// var "ts" var.pos=12152 var.line_nr=463
		// var "info" var.pos=12192 var.line_nr=464
		// var "fields" var.pos=12354 var.line_nr=468
		// var "methods" var.pos=12396 var.line_nr=469
		// var "is_mut" var.pos=12434 var.line_nr=470
		// var "mut_pos" var.pos=12455 var.line_nr=471
		// af parent scope:
		// af parent scope:
		return _t2766;
	}
	v__ast__Type typ = v__ast__new_type(reg_idx);
	v__ast__TypeSymbol* ts = v__ast__Table_get_type_symbol(p->table, typ);
	v__ast__Interface info = /* as */ *(v__ast__Interface*)__as_cast((ts->info)._v__ast__Interface,(ts->info)._typ, 410) /*expected idx: 410, name: v.ast.Interface */ ;
	ts->methods = __new_array_with_default(0, 20, sizeof(v__ast__Fn), 0);
	Array_v__ast__StructField fields = __new_array_with_default(0, 20, sizeof(v__ast__StructField), 0);
	Array_v__ast__FnDecl methods = __new_array_with_default(0, 20, sizeof(v__ast__FnDecl), 0);
	bool is_mut = false;
	int mut_pos = -1;
	for (;;) {
		if (!(p->tok.kind != v__token__Kind_rcbr && p->tok.kind != v__token__Kind_eof)) break;
		if (p->tok.kind == v__token__Kind_key_mut) {
			if (is_mut) {
				v__parser__Parser_error_with_pos(p, _SLIT("redefinition of `mut` section"), v__token__Token_position(&p->tok));
				 v__ast__InterfaceDecl _t2767 = (v__ast__InterfaceDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.name_pos = {0},.field_names = __new_array(0, 1, sizeof(string)),.is_pub = 0,.methods = __new_array(0, 1, sizeof(v__ast__FnDecl)),.mut_pos = 0,.fields = __new_array(0, 1, sizeof(v__ast__StructField)),.pos = {0},.pre_comments = __new_array(0, 1, sizeof(v__ast__Comment)),};
				// autofree_scope_vars(pos=12638 line_nr=476 scope.pos=12561 scope.end_pos=12652)
				// af parent scope:
				// af parent scope:
				// af parent scope:
				// af parent scope:
				// var "p" var.pos=11352 var.line_nr=433
				// var "pos" var.pos=11435 var.line_nr=435
				// var "is_pub" var.pos=11460 var.line_nr=436
				// var "name_pos" var.pos=11546 var.line_nr=441
				// var "interface_name" var.pos=11576 var.line_nr=442
				// var "pre_comments" var.pos=11695 var.line_nr=445
				// var "reg_idx" var.pos=11752 var.line_nr=447
				// var "typ" var.pos=12118 var.line_nr=462
				// var "ts" var.pos=12152 var.line_nr=463
				// var "info" var.pos=12192 var.line_nr=464
				// var "fields" var.pos=12354 var.line_nr=468
				// var "methods" var.pos=12396 var.line_nr=469
				// var "is_mut" var.pos=12434 var.line_nr=470
				// var "mut_pos" var.pos=12455 var.line_nr=471
				// af parent scope:
				// af parent scope:
				return _t2767;
			}
			v__parser__Parser_next(p);
			v__parser__Parser_check(p, v__token__Kind_colon);
			is_mut = true;
			mut_pos = fields.len;
		}
		if (p->peek_tok.kind == v__token__Kind_lpar) {
			v__token__Position method_start_pos = v__token__Token_position(&p->tok);
			int line_nr = p->tok.line_nr;
			string name = v__parser__Parser_check_name(p);
			if (string_eq(name, _SLIT("type_name"))) {
				v__parser__Parser_error_with_pos(p, _SLIT("cannot override built-in method `type_name`"), method_start_pos);
				 v__ast__InterfaceDecl _t2768 = (v__ast__InterfaceDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.name_pos = {0},.field_names = __new_array(0, 1, sizeof(string)),.is_pub = 0,.methods = __new_array(0, 1, sizeof(v__ast__FnDecl)),.mut_pos = 0,.fields = __new_array(0, 1, sizeof(v__ast__StructField)),.pos = {0},.pre_comments = __new_array(0, 1, sizeof(v__ast__Comment)),};
				// autofree_scope_vars(pos=12973 line_nr=489 scope.pos=12882 scope.end_pos=13004)
				// af parent scope:
				// var "method_start_pos" var.pos=12765 var.line_nr=484
				// var "line_nr" var.pos=12805 var.line_nr=485
				// var "name" var.pos=12833 var.line_nr=486
				// var "args2" var.pos=13328 var.line_nr=500
				// var "is_variadic" var.pos=13338 var.line_nr=500
				// var "args" var.pos=13422 var.line_nr=501
				// var "method" var.pos=13538 var.line_nr=508
				// var "mcomments" var.pos=14082 var.line_nr=525
				// var "mnext_comments" var.pos=14130 var.line_nr=526
				// var "tmethod" var.pos=14302 var.line_nr=531
				// af parent scope:
				// af parent scope:
				// af parent scope:
				// var "p" var.pos=11352 var.line_nr=433
				// var "pos" var.pos=11435 var.line_nr=435
				// var "is_pub" var.pos=11460 var.line_nr=436
				// var "name_pos" var.pos=11546 var.line_nr=441
				// var "interface_name" var.pos=11576 var.line_nr=442
				// var "pre_comments" var.pos=11695 var.line_nr=445
				// var "reg_idx" var.pos=11752 var.line_nr=447
				// var "typ" var.pos=12118 var.line_nr=462
				// var "ts" var.pos=12152 var.line_nr=463
				// var "info" var.pos=12192 var.line_nr=464
				// var "fields" var.pos=12354 var.line_nr=468
				// var "methods" var.pos=12396 var.line_nr=469
				// var "is_mut" var.pos=12434 var.line_nr=470
				// var "mut_pos" var.pos=12455 var.line_nr=471
				// af parent scope:
				// af parent scope:
				return _t2768;
			}
			if (v__ast__TypeSymbol_has_method(ts, name)) {
				v__parser__Parser_error_with_pos(p, _STR("duplicate method `%.*s\000`", 2, name), method_start_pos);
				 v__ast__InterfaceDecl _t2769 = (v__ast__InterfaceDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.name_pos = {0},.field_names = __new_array(0, 1, sizeof(string)),.is_pub = 0,.methods = __new_array(0, 1, sizeof(v__ast__FnDecl)),.mut_pos = 0,.fields = __new_array(0, 1, sizeof(v__ast__StructField)),.pos = {0},.pre_comments = __new_array(0, 1, sizeof(v__ast__Comment)),};
				// autofree_scope_vars(pos=13104 line_nr=493 scope.pos=13032 scope.end_pos=13135)
				// af parent scope:
				// var "method_start_pos" var.pos=12765 var.line_nr=484
				// var "line_nr" var.pos=12805 var.line_nr=485
				// var "name" var.pos=12833 var.line_nr=486
				// var "args2" var.pos=13328 var.line_nr=500
				// var "is_variadic" var.pos=13338 var.line_nr=500
				// var "args" var.pos=13422 var.line_nr=501
				// var "method" var.pos=13538 var.line_nr=508
				// var "mcomments" var.pos=14082 var.line_nr=525
				// var "mnext_comments" var.pos=14130 var.line_nr=526
				// var "tmethod" var.pos=14302 var.line_nr=531
				// af parent scope:
				// af parent scope:
				// af parent scope:
				// var "p" var.pos=11352 var.line_nr=433
				// var "pos" var.pos=11435 var.line_nr=435
				// var "is_pub" var.pos=11460 var.line_nr=436
				// var "name_pos" var.pos=11546 var.line_nr=441
				// var "interface_name" var.pos=11576 var.line_nr=442
				// var "pre_comments" var.pos=11695 var.line_nr=445
				// var "reg_idx" var.pos=11752 var.line_nr=447
				// var "typ" var.pos=12118 var.line_nr=462
				// var "ts" var.pos=12152 var.line_nr=463
				// var "info" var.pos=12192 var.line_nr=464
				// var "fields" var.pos=12354 var.line_nr=468
				// var "methods" var.pos=12396 var.line_nr=469
				// var "is_mut" var.pos=12434 var.line_nr=470
				// var "mut_pos" var.pos=12455 var.line_nr=471
				// af parent scope:
				// af parent scope:
				return _t2769;
			}
			if (v__util__contains_capital(name)) {
				v__parser__Parser_error(p, _SLIT("interface methods cannot contain uppercase letters, use snake_case instead"));
				 v__ast__InterfaceDecl _t2770 = (v__ast__InterfaceDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.name_pos = {0},.field_names = __new_array(0, 1, sizeof(string)),.is_pub = 0,.methods = __new_array(0, 1, sizeof(v__ast__FnDecl)),.mut_pos = 0,.fields = __new_array(0, 1, sizeof(v__ast__StructField)),.pos = {0},.pre_comments = __new_array(0, 1, sizeof(v__ast__Comment)),};
				// autofree_scope_vars(pos=13266 line_nr=497 scope.pos=13171 scope.end_pos=13297)
				// af parent scope:
				// var "method_start_pos" var.pos=12765 var.line_nr=484
				// var "line_nr" var.pos=12805 var.line_nr=485
				// var "name" var.pos=12833 var.line_nr=486
				// var "args2" var.pos=13328 var.line_nr=500
				// var "is_variadic" var.pos=13338 var.line_nr=500
				// var "args" var.pos=13422 var.line_nr=501
				// var "method" var.pos=13538 var.line_nr=508
				// var "mcomments" var.pos=14082 var.line_nr=525
				// var "mnext_comments" var.pos=14130 var.line_nr=526
				// var "tmethod" var.pos=14302 var.line_nr=531
				// af parent scope:
				// af parent scope:
				// af parent scope:
				// var "p" var.pos=11352 var.line_nr=433
				// var "pos" var.pos=11435 var.line_nr=435
				// var "is_pub" var.pos=11460 var.line_nr=436
				// var "name_pos" var.pos=11546 var.line_nr=441
				// var "interface_name" var.pos=11576 var.line_nr=442
				// var "pre_comments" var.pos=11695 var.line_nr=445
				// var "reg_idx" var.pos=11752 var.line_nr=447
				// var "typ" var.pos=12118 var.line_nr=462
				// var "ts" var.pos=12152 var.line_nr=463
				// var "info" var.pos=12192 var.line_nr=464
				// var "fields" var.pos=12354 var.line_nr=468
				// var "methods" var.pos=12396 var.line_nr=469
				// var "is_mut" var.pos=12434 var.line_nr=470
				// var "mut_pos" var.pos=12455 var.line_nr=471
				// af parent scope:
				// af parent scope:
				return _t2770;
			}
			multi_return_Array_v__ast__Param_bool_bool mr_13350 = v__parser__Parser_fn_args(p);
			Array_v__ast__Param args2 = mr_13350.arg0;
			bool is_variadic = mr_13350.arg2;
			Array_v__ast__Param args = new_array_from_c_array(1, 1, sizeof(v__ast__Param), _MOV((v__ast__Param[1]){(v__ast__Param){.pos = {0},.name = _SLIT("x"),.is_mut = is_mut,.is_auto_rec = 0,.typ = typ,.type_pos = {0},.is_hidden = true,}}));
			_PUSH_MANY(&args, (args2), _t2771, Array_v__ast__Param);
			v__ast__FnDecl method = (v__ast__FnDecl){
				.name = name,
				.mod = p->mod,
				.params = args,
				.is_deprecated = 0,
				.is_pub = true,
				.is_variadic = is_variadic,
				.is_anon = 0,
				.is_manualfree = 0,
				.is_main = 0,
				.is_test = 0,
				.is_conditional = 0,
				.is_keep_alive = 0,
				.receiver = (v__ast__StructField){.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),},
				.receiver_pos = {0},
				.is_method = 0,
				.method_type_pos = {0},
				.method_idx = 0,
				.rec_mut = 0,
				.rec_share = 0,
				.language = 0,
				.no_body = 0,
				.is_builtin = 0,
				.body_pos = {0},
				.file = p->file_name,
				.generic_names = __new_array(0, 1, sizeof(string)),
				.is_direct_arr = 0,
				.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),
				.skip_gen = 0,
				.stmts = __new_array(0, 1, sizeof(v__ast__Stmt)),
				.defer_stmts = __new_array(0, 1, sizeof(v__ast__DeferStmt)),
				.return_type = _const_v__ast__void_type,
				.return_type_pos = {0},
				.has_return = 0,
				.comments = __new_array(0, 1, sizeof(v__ast__Comment)),
				.next_comments = __new_array(0, 1, sizeof(v__ast__Comment)),
				.source_file = 0,
				.scope = p->scope,
				.label_names = __new_array(0, 1, sizeof(string)),
				.pos = v__token__Position_extend(method_start_pos, v__token__Token_position(&p->prev_tok)),
			};
			if (v__token__Kind_is_start_of_type(p->tok.kind) && p->tok.line_nr == line_nr) {
				method.return_type_pos = v__token__Token_position(&p->tok);
				method.return_type = v__parser__Parser_parse_type(p);
				method.return_type_pos = v__token__Position_extend(method.return_type_pos, v__token__Token_position(&p->tok));
				method.pos = v__token__Position_extend(method.pos, method.return_type_pos);
			}
			Array_v__ast__Comment mcomments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = true,.follow_up = 0,});
			Array_v__ast__Comment mnext_comments = v__parser__Parser_eat_comments(p, (v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,});
			method.comments = mcomments;
			method.next_comments = mnext_comments;
			array_push(&methods, _MOV((v__ast__FnDecl[]){ method }));
			v__ast__Fn tmethod = (v__ast__Fn){.params = args,.return_type = method.return_type,.is_variadic = is_variadic,.language = 0,.generic_names = __new_array(0, 1, sizeof(string)),.is_pub = true,.is_deprecated = 0,.is_unsafe = 0,.is_placeholder = 0,.is_main = 0,.is_test = 0,.is_conditional = 0,.is_keep_alive = 0,.no_body = 0,.mod = (string){.str=(byteptr)"", .is_lit=1},.ctdefine = (string){.str=(byteptr)"", .is_lit=1},.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.name = name,.source_fn = 0,.usages = 0,};
			v__ast__TypeSymbol_register_method(ts, tmethod);
			array_push(&info.methods, _MOV((v__ast__Fn[]){ tmethod }));
		} else {
			v__token__Position field_pos = v__token__Token_position(&p->tok);
			string field_name = v__parser__Parser_check_name(p);
			v__token__Position type_pos = v__token__Token_position(&p->tok);
			v__ast__Type field_typ = v__parser__Parser_parse_type(p);
			type_pos = v__token__Position_extend(type_pos, v__token__Token_position(&p->prev_tok));
			Array_v__ast__Comment comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
			for (;;) {
				if (!(p->tok.kind == v__token__Kind_comment)) break;
				array_push(&comments, _MOV((v__ast__Comment[]){ v__parser__Parser_comment(p) }));
				if (p->tok.kind == v__token__Kind_rcbr) {
					break;
				}
			}
			array_push(&fields, _MOV((v__ast__StructField[]){ (v__ast__StructField){
				.pos = field_pos,
				.type_pos = type_pos,
				.comments = comments,
				.default_expr = {0},
				.has_default_expr = 0,
				.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),
				.is_pub = true,
				.default_val = (string){.str=(byteptr)"", .is_lit=1},
				.is_mut = 0,
				.is_global = 0,
				.default_expr_typ = 0,
				.name = field_name,
				.typ = field_typ,
			} }));
			array_push(&info.fields, _MOV((v__ast__StructField[]){ (v__ast__StructField){.pos = {0},.type_pos = {0},.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.default_expr = {0},.has_default_expr = 0,.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.is_pub = true,.default_val = (string){.str=(byteptr)"", .is_lit=1},.is_mut = is_mut,.is_global = 0,.default_expr_typ = 0,.name = field_name,.typ = field_typ,} }));
		}
	}
	ts->info = v__ast__Interface_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__Interface, (info)));
	v__parser__Parser_top_level_statement_end(p);
	v__parser__Parser_check(p, v__token__Kind_rcbr);
	pos = v__token__Position_extend_with_last_line(pos, v__token__Token_position(&p->prev_tok), p->prev_tok.line_nr);
	 v__ast__InterfaceDecl _t2777 = (v__ast__InterfaceDecl){
		.name = interface_name,
		.name_pos = name_pos,
		.field_names = __new_array(0, 1, sizeof(string)),
		.is_pub = is_pub,
		.methods = methods,
		.mut_pos = mut_pos,
		.fields = fields,
		.pos = pos,
		.pre_comments = pre_comments,
	};
	// autofree_scope_vars(pos=15280 line_nr=574 scope.pos=11347 scope.end_pos=15466)
	// var "p" var.pos=11352 var.line_nr=433
	// var "pos" var.pos=11435 var.line_nr=435
	// var "is_pub" var.pos=11460 var.line_nr=436
	// var "name_pos" var.pos=11546 var.line_nr=441
	// var "interface_name" var.pos=11576 var.line_nr=442
	// var "pre_comments" var.pos=11695 var.line_nr=445
	// var "reg_idx" var.pos=11752 var.line_nr=447
	// var "typ" var.pos=12118 var.line_nr=462
	// var "ts" var.pos=12152 var.line_nr=463
	// var "info" var.pos=12192 var.line_nr=464
	// var "fields" var.pos=12354 var.line_nr=468
	// var "methods" var.pos=12396 var.line_nr=469
	// var "is_mut" var.pos=12434 var.line_nr=470
	// var "mut_pos" var.pos=12455 var.line_nr=471
	// af parent scope:
	// af parent scope:
	return _t2777;
}

VV_LOCAL_SYMBOL bool v__parser__is_html_open_tag(string name, string s) {
	int len = s.len;
	if (len < name.len) {
		 bool _t2778 = false;
		// autofree_scope_vars(pos=520 line_nr=25 scope.pos=517 scope.end_pos=535)
		// af parent scope:
		// var "name" var.pos=450 var.line_nr=22
		// var "s" var.pos=463 var.line_nr=22
		// var "len" var.pos=485 var.line_nr=23
		// var "sub" var.pos=542 var.line_nr=27
		// af parent scope:
		// af parent scope:
		return _t2778;
	}
	string sub = string_substr(s, 0, 1);
	if (string_ne(sub, _SLIT("<"))) {
		 bool _t2779 = false;
		// autofree_scope_vars(pos=597 line_nr=29 scope.pos=572 scope.end_pos=612)
		// af parent scope:
		// var "name" var.pos=450 var.line_nr=22
		// var "s" var.pos=463 var.line_nr=22
		// var "len" var.pos=485 var.line_nr=23
		// var "sub" var.pos=542 var.line_nr=27
		// af parent scope:
		// af parent scope:
		return _t2779;
	}
	sub = string_substr(s, len - 1, len);
	if (string_ne(sub, _SLIT(">"))) {
		 bool _t2780 = false;
		// autofree_scope_vars(pos=675 line_nr=33 scope.pos=652 scope.end_pos=690)
		// af parent scope:
		// var "name" var.pos=450 var.line_nr=22
		// var "s" var.pos=463 var.line_nr=22
		// var "len" var.pos=485 var.line_nr=23
		// var "sub" var.pos=542 var.line_nr=27
		// af parent scope:
		// af parent scope:
		return _t2780;
	}
	sub = string_substr(s, len - 2, len - 1);
	if (string_eq(sub, _SLIT("/"))) {
		 bool _t2781 = false;
		// autofree_scope_vars(pos=753 line_nr=37 scope.pos=734 scope.end_pos=768)
		// af parent scope:
		// var "name" var.pos=450 var.line_nr=22
		// var "s" var.pos=463 var.line_nr=22
		// var "len" var.pos=485 var.line_nr=23
		// var "sub" var.pos=542 var.line_nr=27
		// af parent scope:
		// af parent scope:
		return _t2781;
	}
	sub = string_substr(s, 1, len - 1);
	if (string_contains_any(sub, _SLIT("<>"))) {
		 bool _t2782 = false;
		// autofree_scope_vars(pos=840 line_nr=41 scope.pos=818 scope.end_pos=855)
		// af parent scope:
		// var "name" var.pos=450 var.line_nr=22
		// var "s" var.pos=463 var.line_nr=22
		// var "len" var.pos=485 var.line_nr=23
		// var "sub" var.pos=542 var.line_nr=27
		// af parent scope:
		// af parent scope:
		return _t2782;
	}
	if (string_eq(sub, name)) {
		 bool _t2783 = true;
		// autofree_scope_vars(pos=888 line_nr=44 scope.pos=873 scope.end_pos=902)
		// af parent scope:
		// var "name" var.pos=450 var.line_nr=22
		// var "s" var.pos=463 var.line_nr=22
		// var "len" var.pos=485 var.line_nr=23
		// var "sub" var.pos=542 var.line_nr=27
		// af parent scope:
		// af parent scope:
		return _t2783;
	} else {
		len = name.len;
		if (sub.len <= len) {
			 bool _t2784 = false;
			// autofree_scope_vars(pos=975 line_nr=48 scope.pos=948 scope.end_pos=991)
			// af parent scope:
			// af parent scope:
			// var "name" var.pos=450 var.line_nr=22
			// var "s" var.pos=463 var.line_nr=22
			// var "len" var.pos=485 var.line_nr=23
			// var "sub" var.pos=542 var.line_nr=27
			// af parent scope:
			// af parent scope:
			return _t2784;
		}
		if (string_ne(string_substr(sub, 0, len + 1), _STR("%.*s\000 ", 2, name))) {
			 bool _t2785 = false;
			// autofree_scope_vars(pos=1049 line_nr=51 scope.pos=1025 scope.end_pos=1065)
			// af parent scope:
			// af parent scope:
			// var "name" var.pos=450 var.line_nr=22
			// var "s" var.pos=463 var.line_nr=22
			// var "len" var.pos=485 var.line_nr=23
			// var "sub" var.pos=542 var.line_nr=27
			// af parent scope:
			// af parent scope:
			return _t2785;
		}
		 bool _t2786 = true;
		// autofree_scope_vars(pos=1068 line_nr=53 scope.pos=909 scope.end_pos=1082)
		// af parent scope:
		// var "name" var.pos=450 var.line_nr=22
		// var "s" var.pos=463 var.line_nr=22
		// var "len" var.pos=485 var.line_nr=23
		// var "sub" var.pos=542 var.line_nr=27
		// af parent scope:
		// af parent scope:
		return _t2786;
	}
	return 0;
}

string v__parser__Parser_compile_template_file(v__parser__Parser* p, string template_file, string fn_name) {
	Option_Array_string _t2787 = os__read_lines(template_file);
	if (_t2787.state != 0) { /*or block*/ 
		IError err = _t2787.err;
		v__parser__Parser_error(p, _STR("reading from %.*s\000 failed", 2, template_file));
		 string _t2788 = _SLIT("");
		// autofree_scope_vars(pos=1354 line_nr=61 scope.pos=1303 scope.end_pos=1366)
		// var "err" var.pos=1303 var.line_nr=59
		// af parent scope:
		// var "p" var.pos=1178 var.line_nr=58
		// var "template_file" var.pos=1210 var.line_nr=58
		// var "fn_name" var.pos=1232 var.line_nr=58
		// var "lines" var.pos=1262 var.line_nr=59
		// var "basepath" var.pos=1369 var.line_nr=63
		// var "lstartlength" var.pos=1404 var.line_nr=64
		// var "source" var.pos=1440 var.line_nr=65
		// var "state" var.pos=1667 var.line_nr=74
		// var "in_span" var.pos=1692 var.line_nr=75
		// var "end_of_line_pos" var.pos=1714 var.line_nr=76
		// var "start_of_line_pos" var.pos=1740 var.line_nr=77
		// var "tline_number" var.pos=1768 var.line_nr=78
		// var "result" var.pos=7136 var.line_nr=227
		// af parent scope:
		// af parent scope:
		return _t2788;
	}
 	Array_string lines =  *(Array_string*)_t2787.data;
	string basepath = os__dir(template_file);
	int lstartlength = lines.len * 30;
	strings__Builder source = strings__new_builder(1000);
	strings__Builder_writeln(&source, _STR("\nimport strings\n// === vweb html template ===\nfn vweb_tmpl_%.*s\000() {\nmut sb := strings.new_builder(%"PRId32"\000)\n\n\n", 3, fn_name, lstartlength));
	strings__Builder_write_string(&source, _const_v__parser__tmpl_str_start);
	v__parser__State state = v__parser__State_html;
	bool in_span = false;
	int end_of_line_pos = 0;
	int start_of_line_pos = 0;
	int tline_number = -1;
	for (int i = 0; i < lines.len; i++) {
		string oline = (*(string*)/*ee elem_typ */array_get(lines, i));
		tline_number++;
		start_of_line_pos = end_of_line_pos;
		end_of_line_pos += oline.len + 1;
		string line = string_trim_space(oline);
		if (v__parser__is_html_open_tag(_SLIT("style"), line)) {
			state = v__parser__State_css;
		} else if (string_eq(line, _SLIT("</style>"))) {
			state = v__parser__State_html;
		} else if (v__parser__is_html_open_tag(_SLIT("script"), line)) {
			state = v__parser__State_js;
		} else if (string_eq(line, _SLIT("</script>"))) {
			state = v__parser__State_html;
		}
		if (string_contains(line, _SLIT("@header"))) {
			Option_int _t2789 = string_index(line, _SLIT("@header"));
			if (_t2789.state != 0) { /*or block*/ 
				IError err = _t2789.err;
				*(int*) _t2789.data = 0;
			}
 			int position =  *(int*)_t2789.data;
			v__parser__Parser_error_with_error(p, (v__errors__Error){.message = _SLIT("Please use @include 'header' instead of @header (deprecated)"),.details = (string){.str=(byteptr)"", .is_lit=1},.file_path = template_file,.pos = (v__token__Position){.len = _SLIT("@header").len,.line_nr = tline_number,.pos = start_of_line_pos + position,.col = 0,.last_line = lines.len,},.backtrace = (string){.str=(byteptr)"", .is_lit=1},.reporter = v__errors__Reporter_parser,});
		} else if (string_contains(line, _SLIT("@footer"))) {
			Option_int _t2790 = string_index(line, _SLIT("@footer"));
			if (_t2790.state != 0) { /*or block*/ 
				IError err = _t2790.err;
				*(int*) _t2790.data = 0;
			}
 			int position =  *(int*)_t2790.data;
			v__parser__Parser_error_with_error(p, (v__errors__Error){.message = _SLIT("Please use @include 'footer' instead of @footer (deprecated)"),.details = (string){.str=(byteptr)"", .is_lit=1},.file_path = template_file,.pos = (v__token__Position){.len = _SLIT("@footer").len,.line_nr = tline_number,.pos = start_of_line_pos + position,.col = 0,.last_line = lines.len,},.backtrace = (string){.str=(byteptr)"", .is_lit=1},.reporter = v__errors__Reporter_parser,});
		}
		if (string_contains(line, _SLIT("@include "))) {
			array_delete(&lines, i);
			string file_name = (*(string*)/*ee elem_typ */array_get(string_split(line, _SLIT("'")), 1));
			string file_ext = os__file_ext(file_name);
			if ((file_ext).len == 0) {
				file_ext = _SLIT(".html");
			}
			file_name = string_replace(file_name, file_ext, _SLIT(""));
			string templates_folder = os__real_path(basepath);
			if (string_contains(file_name, _SLIT("/")) && string_starts_with(file_name, _SLIT("/"))) {
				templates_folder = _SLIT("");
			}
			string file_path = os__real_path(os__join_path(templates_folder, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_STR("%.*s\000%.*s", 2, file_name, file_ext)}))));
			Option_string _t2791 = os__read_file(file_path);
			if (_t2791.state != 0) { /*or block*/ 
				IError err = _t2791.err;
				Option_int _t2792 = string_index(line, _SLIT("@include "));
				if (_t2792.state != 0) { /*or block*/ 
					err = _t2792.err;
					*(int*) _t2792.data = 0;
				}
 				int position =  *(int*)_t2792.data + _SLIT("@include ").len;
				v__parser__Parser_error_with_error(p, (v__errors__Error){.message = _STR("Reading file %.*s\000 from path: %.*s\000 failed", 3, file_name, file_path),.details = _STR("Failed to @include '%.*s\000'", 2, file_name),.file_path = template_file,.pos = (v__token__Position){.len = _SLIT("@include ").len + file_name.len,.line_nr = tline_number,.pos = start_of_line_pos + position,.col = 0,.last_line = lines.len,},.backtrace = (string){.str=(byteptr)"", .is_lit=1},.reporter = v__errors__Reporter_parser,});
				*(string*) _t2791.data = _SLIT("");
			}
 			string file_content =  *(string*)_t2791.data;
			Array_string file_splitted = array_reverse(string_split_into_lines(file_content));
			// FOR IN array
			for (int _t2793 = 0; _t2793 < file_splitted.len; ++_t2793) {
				string f = ((string*)file_splitted.data)[_t2793];
				tline_number--;
				array_insert(&lines, i, &(string[]){string_clone(f)});
			}
			i--;
		} else if (string_contains(line, _SLIT("@js "))) {
			Option_int _t2794 = string_index(line, _SLIT("@js"));
			if (_t2794.state != 0) { /*or block*/ 
				IError err = _t2794.err;
				continue;
			}
 			int pos =  *(int*)_t2794.data;
			strings__Builder_write_string(&source, _SLIT("<script src=\""));
			strings__Builder_write_string(&source, string_substr(line, pos + 5, line.len - 1));
			strings__Builder_writeln(&source, _SLIT("\"></script>"));
		} else if (string_contains(line, _SLIT("@css "))) {
			Option_int _t2795 = string_index(line, _SLIT("@css"));
			if (_t2795.state != 0) { /*or block*/ 
				IError err = _t2795.err;
				continue;
			}
 			int pos =  *(int*)_t2795.data;
			strings__Builder_write_string(&source, _SLIT("<link href=\""));
			strings__Builder_write_string(&source, string_substr(line, pos + 6, line.len - 1));
			strings__Builder_writeln(&source, _SLIT("\" rel=\"stylesheet\" type=\"text/css\">"));
		} else if (string_contains(line, _SLIT("@if "))) {
			strings__Builder_writeln(&source, _const_v__parser__tmpl_str_end);
			Option_int _t2796 = string_index(line, _SLIT("@if"));
			if (_t2796.state != 0) { /*or block*/ 
				IError err = _t2796.err;
				continue;
			}
 			int pos =  *(int*)_t2796.data;
			strings__Builder_writeln(&source, string_add(string_add(_SLIT("if "), string_substr(line, pos + 4, line.len)), _SLIT("{")));
			strings__Builder_writeln(&source, _const_v__parser__tmpl_str_start);
		} else if (string_contains(line, _SLIT("@end"))) {
			strings__Builder_go_back(&source, 1);
			strings__Builder_writeln(&source, _const_v__parser__tmpl_str_end);
			strings__Builder_writeln(&source, _SLIT("}"));
			strings__Builder_writeln(&source, _const_v__parser__tmpl_str_start);
		} else if (string_contains(line, _SLIT("@else"))) {
			strings__Builder_go_back(&source, 1);
			strings__Builder_writeln(&source, _const_v__parser__tmpl_str_end);
			strings__Builder_writeln(&source, _SLIT(" } else { "));
			strings__Builder_writeln(&source, _const_v__parser__tmpl_str_start);
		} else if (string_contains(line, _SLIT("@for"))) {
			strings__Builder_writeln(&source, _const_v__parser__tmpl_str_end);
			Option_int _t2797 = string_index(line, _SLIT("@for"));
			if (_t2797.state != 0) { /*or block*/ 
				IError err = _t2797.err;
				continue;
			}
 			int pos =  *(int*)_t2797.data;
			strings__Builder_writeln(&source, string_add(string_add(_SLIT("for "), string_substr(line, pos + 4, line.len)), _SLIT("{")));
			strings__Builder_writeln(&source, _const_v__parser__tmpl_str_start);
		} else if (state == v__parser__State_html && string_contains(line, _SLIT("span.")) && string_ends_with(line, _SLIT("{"))) {
			string v_class = string_trim_space(string_find_between(line, _SLIT("span."), _SLIT("{")));
			strings__Builder_writeln(&source, _STR("<span class=\"%.*s\000\">", 2, v_class));
			in_span = true;
		} else if (state == v__parser__State_html && string_contains(line, _SLIT(".")) && string_ends_with(line, _SLIT("{"))) {
			string v_class = string_trim_space(string_find_between(line, _SLIT("."), _SLIT("{")));
			strings__Builder_writeln(&source, _STR("<div class=\"%.*s\000\">", 2, v_class));
		} else if (state == v__parser__State_html && string_contains(line, _SLIT("#")) && string_ends_with(line, _SLIT("{"))) {
			string v_class = string_trim_space(string_find_between(line, _SLIT("#"), _SLIT("{")));
			strings__Builder_writeln(&source, _STR("<div id=\"%.*s\000\">", 2, v_class));
		} else if (state == v__parser__State_html && string_eq(line, _SLIT("}"))) {
			if (in_span) {
				strings__Builder_writeln(&source, _SLIT("</span>"));
				in_span = false;
			} else {
				strings__Builder_writeln(&source, _SLIT("</div>"));
			}
		} else {
			strings__Builder_writeln(&source, string_replace(string_replace(string_replace(string_replace(line, _SLIT("@"), _SLIT("$")), _SLIT("$$"), _SLIT("@")), _SLIT(".$"), _SLIT(".@")), _SLIT("'"), _SLIT("\\'")));
		}
	}
	strings__Builder_writeln(&source, _const_v__parser__tmpl_str_end);
	strings__Builder_writeln(&source, _STR("_tmpl_res_%.*s\000 := sb.str() ", 2, fn_name));
	strings__Builder_writeln(&source, _SLIT("}"));
	strings__Builder_writeln(&source, _SLIT("// === end of vweb html template ==="));
	string result = strings__Builder_str(&source);
	// autofree_scope_vars(pos=7159 line_nr=228 scope.pos=1173 scope.end_pos=7174)
	// var "p" var.pos=1178 var.line_nr=58
	// var "template_file" var.pos=1210 var.line_nr=58
	// var "fn_name" var.pos=1232 var.line_nr=58
	// var "lines" var.pos=1262 var.line_nr=59
	// var "basepath" var.pos=1369 var.line_nr=63
	// var "lstartlength" var.pos=1404 var.line_nr=64
	// var "source" var.pos=1440 var.line_nr=65
	// var "state" var.pos=1667 var.line_nr=74
	// var "in_span" var.pos=1692 var.line_nr=75
	// var "end_of_line_pos" var.pos=1714 var.line_nr=76
	// var "start_of_line_pos" var.pos=1740 var.line_nr=77
	// var "tline_number" var.pos=1768 var.line_nr=78
	// var "result" var.pos=7136 var.line_nr=227
	// af parent scope:
	// af parent scope:
	return result;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_array_init(v__gen__c__Gen* g, v__ast__ArrayInit node) {
	v__ast__TypeSymbol* type_sym = v__ast__Table_get_type_symbol(g->table, node.typ);
	string styp = v__gen__c__Gen_typ(g, node.typ);
	string shared_styp = _SLIT("");
	bool is_amp = g->is_amp;
	g->is_amp = false;
	if (is_amp) {
		strings__Builder_go_back(&g->out, 1);
	}
	if (g->is_shared) {
		v__ast__Type shared_typ = v__ast__Type_set_flag(node.typ, v__ast__TypeFlag_shared_f);
		shared_styp = v__gen__c__Gen_typ(g, shared_typ);
		v__gen__c__Gen_writeln(g, _STR("(%.*s\000*)__dup_shared_array(&(%.*s\000){.val = ", 3, shared_styp, shared_styp));
	} else if (is_amp) {
		v__gen__c__Gen_write(g, _STR("HEAP(%.*s\000, ", 2, styp));
	}
	if (type_sym->kind == v__ast__Kind_array_fixed) {
		v__gen__c__Gen_write(g, _SLIT("{"));
		if (node.has_val) {
			// FOR IN array
			for (int i = 0; i < node.exprs.len; ++i) {
				v__ast__Expr expr = ((v__ast__Expr*)node.exprs.data)[i];
				if (v__ast__Expr_is_auto_deref_var(expr)) {
					v__gen__c__Gen_write(g, _SLIT("*"));
				}
				v__gen__c__Gen_expr(g, expr);
				if (i != node.exprs.len - 1) {
					v__gen__c__Gen_write(g, _SLIT(", "));
				}
			}
		} else if (node.has_default) {
			v__gen__c__Gen_expr(g, node.default_expr);
			v__ast__ArrayFixed info = /* as */ *(v__ast__ArrayFixed*)__as_cast((type_sym->info)._v__ast__ArrayFixed,(type_sym->info)._typ, 416) /*expected idx: 416, name: v.ast.ArrayFixed */ ;
			for (int _t2798 = 1; _t2798 < info.size; ++_t2798) {
				v__gen__c__Gen_write(g, _SLIT(", "));
				v__gen__c__Gen_expr(g, node.default_expr);
			}
		} else {
			v__gen__c__Gen_write(g, _SLIT("0"));
		}
		v__gen__c__Gen_write(g, _SLIT("}"));
		return;
	}
	string elem_type_str = v__gen__c__Gen_typ(g, node.elem_type);
	if (node.exprs.len == 0) {
		v__ast__TypeSymbol* elem_sym = v__ast__Table_get_type_symbol(g->table, node.elem_type);
		bool is_default_array = elem_sym->kind == v__ast__Kind_array && node.has_default;
		if (is_default_array) {
			v__gen__c__Gen_write(g, _SLIT("__new_array_with_array_default("));
		} else {
			v__gen__c__Gen_write(g, _SLIT("__new_array_with_default("));
		}
		if (node.has_len) {
			v__gen__c__Gen_expr(g, node.len_expr);
			v__gen__c__Gen_write(g, _SLIT(", "));
		} else {
			v__gen__c__Gen_write(g, _SLIT("0, "));
		}
		if (node.has_cap) {
			v__gen__c__Gen_expr(g, node.cap_expr);
			v__gen__c__Gen_write(g, _SLIT(", "));
		} else {
			v__gen__c__Gen_write(g, _SLIT("0, "));
		}
		if (elem_sym->kind == v__ast__Kind_function) {
			v__gen__c__Gen_write(g, _SLIT("sizeof(voidptr), "));
		} else {
			v__gen__c__Gen_write(g, _STR("sizeof(%.*s\000), ", 2, elem_type_str));
		}
		if (is_default_array) {
			v__gen__c__Gen_write(g, _STR("(%.*s\000[]){", 2, elem_type_str));
			v__gen__c__Gen_expr(g, node.default_expr);
			v__gen__c__Gen_write(g, _SLIT("}[0])"));
		} else if (node.has_default) {
			v__gen__c__Gen_write(g, _STR("&(%.*s\000[]){", 2, elem_type_str));
			v__gen__c__Gen_expr(g, node.default_expr);
			v__gen__c__Gen_write(g, _SLIT("})"));
		} else if (node.has_len && v__ast__Type_alias_eq(node.elem_type, _const_v__ast__string_type)) {
			v__gen__c__Gen_write(g, _STR("&(%.*s\000[]){", 2, elem_type_str));
			v__gen__c__Gen_write(g, _SLIT("_SLIT(\"\")"));
			v__gen__c__Gen_write(g, _SLIT("})"));
		} else if (node.has_len && (elem_sym->kind == v__ast__Kind_array || elem_sym->kind == v__ast__Kind_map)) {
			v__gen__c__Gen_write(g, _STR("(voidptr)&(%.*s\000[]){", 2, elem_type_str));
			v__gen__c__Gen_write(g, v__gen__c__Gen_type_default(g, node.elem_type));
			v__gen__c__Gen_write(g, _SLIT("}[0])"));
		} else {
			v__gen__c__Gen_write(g, _SLIT("0)"));
		}
		if (g->is_shared) {
			v__gen__c__Gen_write(g, _STR("}, sizeof(%.*s\000))", 2, shared_styp));
		} else if (is_amp) {
			v__gen__c__Gen_write(g, _SLIT(")"));
		}
		return;
	}
	int len = node.exprs.len;
	v__ast__TypeSymbol* elem_sym = v__ast__Table_get_type_symbol(g->table, node.elem_type);
	if (elem_sym->kind == v__ast__Kind_function) {
		v__gen__c__Gen_write(g, _STR("new_array_from_c_array(%"PRId32"\000, %"PRId32"\000, sizeof(voidptr), _MOV((voidptr[%"PRId32"\000]){", 4, len, len, len));
	} else {
		v__gen__c__Gen_write(g, _STR("new_array_from_c_array(%"PRId32"\000, %"PRId32"\000, sizeof(%.*s\000), _MOV((%.*s\000[%"PRId32"\000]){", 6, len, len, elem_type_str, elem_type_str, len));
	}
	if (len > 8) {
		v__gen__c__Gen_writeln(g, _SLIT(""));
		v__gen__c__Gen_write(g, _SLIT("\t\t"));
	}
	// FOR IN array
	for (int i = 0; i < node.exprs.len; ++i) {
		v__ast__Expr expr = ((v__ast__Expr*)node.exprs.data)[i];
		v__gen__c__Gen_expr_with_cast(g, expr, (*(v__ast__Type*)/*ee elem_typ */array_get(node.expr_types, i)), node.elem_type);
		if (i != len - 1) {
			v__gen__c__Gen_write(g, _SLIT(", "));
		}
	}
	v__gen__c__Gen_write(g, _SLIT("}))"));
	if (g->is_shared) {
		v__gen__c__Gen_write(g, _STR("}, sizeof(%.*s\000))", 2, shared_styp));
	} else if (is_amp) {
		v__gen__c__Gen_write(g, _STR("), sizeof(%.*s\000))", 2, styp));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_array_map(v__gen__c__Gen* g, v__ast__CallExpr node) {
	g->inside_lambda = true;
	string tmp = v__gen__c__Gen_new_tmp_var(g);
	string s = v__gen__c__Gen_go_before_stmt(g, 0);
	string ret_typ = v__gen__c__Gen_typ(g, node.return_type);
	v__ast__TypeSymbol* ret_sym = v__ast__Table_get_type_symbol(g->table, node.return_type);
	v__ast__TypeSymbol* inp_sym = v__ast__Table_get_type_symbol(g->table, node.receiver_type);
	v__ast__Array ret_info = /* as */ *(v__ast__Array*)__as_cast((ret_sym->info)._v__ast__Array,(ret_sym->info)._typ, 395) /*expected idx: 395, name: v.ast.Array */ ;
	string ret_elem_type = v__gen__c__Gen_typ(g, ret_info.elem_type);
	v__ast__Array inp_info = /* as */ *(v__ast__Array*)__as_cast((inp_sym->info)._v__ast__Array,(inp_sym->info)._typ, 395) /*expected idx: 395, name: v.ast.Array */ ;
	string inp_elem_type = v__gen__c__Gen_typ(g, inp_info.elem_type);
	if (inp_sym->kind != v__ast__Kind_array) {
		v__gen__c__verror(_SLIT("map() requires an array"));
	}
	g->empty_line = true;
	v__gen__c__Gen_write(g, _STR("%.*s\000 %.*s\000_orig = ", 3, v__gen__c__Gen_typ(g, node.left_type), tmp));
	v__gen__c__Gen_expr(g, node.left);
	v__gen__c__Gen_writeln(g, _SLIT(";"));
	v__gen__c__Gen_writeln(g, _STR("int %.*s\000_len = %.*s\000_orig.len;", 3, tmp, tmp));
	v__gen__c__Gen_writeln(g, _STR("%.*s\000 %.*s\000 = __new_array(0, %.*s\000_len, sizeof(%.*s\000));\n", 5, ret_typ, tmp, tmp, ret_elem_type));
	string i = v__gen__c__Gen_new_tmp_var(g);
	v__gen__c__Gen_writeln(g, _STR("for (int %.*s\000 = 0; %.*s\000 < %.*s\000_len; ++%.*s\000) {", 5, i, i, tmp, i));
	v__gen__c__Gen_writeln(g, _STR("\t%.*s\000 it = ((%.*s\000*) %.*s\000_orig.data)[%.*s\000];", 5, inp_elem_type, inp_elem_type, tmp, i));
	bool is_embed_map_filter = false;
	v__ast__Expr expr = (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr;
	if (expr._typ == 233 /* v.ast.AnonFn */) {
		v__gen__c__Gen_write(g, _STR("\t%.*s\000 ti = ", 2, ret_elem_type));
		v__gen__c__Gen_gen_anon_fn_decl(g, (voidptr)&/*qq*/(*expr._v__ast__AnonFn));
		v__gen__c__Gen_write(g, _STR("%.*s\000(it)", 2, (*expr._v__ast__AnonFn).decl.name));
	}
	else if (expr._typ == 254 /* v.ast.Ident */) {
		v__gen__c__Gen_write(g, _STR("\t%.*s\000 ti = ", 2, ret_elem_type));
		if ((*expr._v__ast__Ident).kind == v__ast__IdentKind_function) {
			v__gen__c__Gen_write(g, _STR("%.*s\000(it)", 2, v__gen__c__c_name((*expr._v__ast__Ident).name)));
		} else if ((*expr._v__ast__Ident).kind == v__ast__IdentKind_variable) {
			v__ast__IdentVar var_info = v__ast__Ident_var_info(&(*expr._v__ast__Ident));
			v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, var_info.typ);
			if (sym->kind == v__ast__Kind_function) {
				v__gen__c__Gen_write(g, _STR("%.*s\000(it)", 2, v__gen__c__c_name((*expr._v__ast__Ident).name)));
			} else {
				v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
			}
		} else {
			v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
		}
	}
	else if (expr._typ == 241 /* v.ast.CallExpr */) {
		if ((string_eq((*expr._v__ast__CallExpr).name, _SLIT("map")) || string_eq((*expr._v__ast__CallExpr).name, _SLIT("filter")))) {
			is_embed_map_filter = true;
			array_push(&g->stmt_path_pos, _MOV((int[]){ g->out.len }));
		}
		v__gen__c__Gen_write(g, _STR("\t%.*s\000 ti = ", 2, ret_elem_type));
		v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
	}
	else {
		v__gen__c__Gen_write(g, _STR("\t%.*s\000 ti = ", 2, ret_elem_type));
		v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
	};
	v__gen__c__Gen_writeln(g, _SLIT(";"));
	v__gen__c__Gen_writeln(g, _STR("\tarray_push(&%.*s\000, &ti);", 2, tmp));
	v__gen__c__Gen_writeln(g, _SLIT("}"));
	if (!is_embed_map_filter) {
		array_push(&g->stmt_path_pos, _MOV((int[]){ g->out.len }));
	}
	v__gen__c__Gen_write(g, _SLIT("\n"));
	v__gen__c__Gen_write(g, s);
	v__gen__c__Gen_write(g, tmp);
	g->inside_lambda = false;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_array_sort(v__gen__c__Gen* g, v__ast__CallExpr node) {
	v__ast__TypeSymbol* rec_sym = v__ast__Table_get_type_symbol(g->table, node.receiver_type);
	if (rec_sym->kind != v__ast__Kind_array) {
		println(node.name);
		println(v__gen__c__Gen_typ(g, node.receiver_type));
		v__gen__c__verror(_SLIT(".sort() is an array method"));
	}
	v__ast__Array info = /* as */ *(v__ast__Array*)__as_cast((rec_sym->info)._v__ast__Array,(rec_sym->info)._typ, 395) /*expected idx: 395, name: v.ast.Array */ ;
	v__ast__Type typ = info.elem_type;
	bool is_default = false;
	bool is_reverse = false;
	string compare_fn = _SLIT("");
	if (node.args.len == 0) {
		is_default = true;
	} else {
		v__ast__InfixExpr infix_expr = /* as */ *(v__ast__InfixExpr*)__as_cast(((*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr)._v__ast__InfixExpr,((*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr)._typ, 258) /*expected idx: 258, name: v.ast.InfixExpr */ ;
		string left_name = _STR("%.*s", 1, v__ast__Expr_str(infix_expr.left));
		is_default = (string_eq(left_name, _SLIT("a")) || string_eq(left_name, _SLIT("b"))) && (string_eq(_STR("%.*s", 1, v__ast__Expr_str(infix_expr.right)), _SLIT("a")) || string_eq(_STR("%.*s", 1, v__ast__Expr_str(infix_expr.right)), _SLIT("b")));
		is_reverse = (string_starts_with(left_name, _SLIT("a")) && infix_expr.op == v__token__Kind_gt) || (string_starts_with(left_name, _SLIT("b")) && infix_expr.op == v__token__Kind_lt);
	}
	if (is_default) {
		compare_fn = ((typ == (_const_v__ast__int_type) || typ == (v__ast__Type_to_ptr(_const_v__ast__int_type))) ? (_SLIT("compare_ints")) : (typ == (_const_v__ast__string_type) || typ == (v__ast__Type_to_ptr(_const_v__ast__string_type))) ? (_SLIT("compare_strings")) : (_SLIT("")));
		if ((compare_fn).len != 0 && is_reverse) {
			compare_fn = /*f*/string_add(compare_fn, _SLIT("_reverse"));
		}
	}
	if ((compare_fn).len == 0) {
		string tmp_name = v__gen__c__Gen_new_tmp_var(g);
		string styp = string_trim(v__gen__c__Gen_typ(g, typ), _SLIT("*"));
		compare_fn = _STR("compare_%.*s\000_%.*s", 2, tmp_name, styp);
		if (is_reverse) {
			compare_fn = /*f*/string_add(compare_fn, _SLIT("_reverse"));
		}
		v__ast__Table_register_fn(g->table, (v__ast__Fn){.params = __new_array(0, 1, sizeof(v__ast__Param)),.return_type = _const_v__ast__int_type,.is_variadic = 0,.language = 0,.generic_names = __new_array(0, 1, sizeof(string)),.is_pub = 0,.is_deprecated = 0,.is_unsafe = 0,.is_placeholder = 0,.is_main = 0,.is_test = 0,.is_conditional = 0,.is_keep_alive = 0,.no_body = 0,.mod = (string){.str=(byteptr)"", .is_lit=1},.ctdefine = (string){.str=(byteptr)"", .is_lit=1},.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.name = compare_fn,.source_fn = 0,.usages = 0,});
		if (node.args.len == 0) {
			string styp_arg = v__gen__c__Gen_typ(g, typ);
			strings__Builder_writeln(&g->definitions, _STR("int %.*s\000 (%.*s\000* a, %.*s\000* b) {", 4, compare_fn, styp_arg, styp_arg));
			v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, typ);
			if (!is_reverse && v__ast__TypeSymbol_has_method(sym, _SLIT("<"))) {
				strings__Builder_writeln(&g->definitions, _STR("\tif (%.*s\000__lt(*a, *b)) { return -1; } else { return 1; }}", 2, styp));
			} else if (is_reverse && v__ast__TypeSymbol_has_method(sym, _SLIT("<"))) {
				strings__Builder_writeln(&g->definitions, _STR("\tif (%.*s\000__lt(*b, *a)) { return -1; } else { return 1; }}", 2, styp));
			} else {
				strings__Builder_writeln(&g->definitions, _SLIT("if (*a < *b) return -1;"));
				strings__Builder_writeln(&g->definitions, _SLIT("if (*a > *b) return 1; return 0; }\n"));
			}
		} else {
			v__ast__InfixExpr infix_expr = /* as */ *(v__ast__InfixExpr*)__as_cast(((*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr)._v__ast__InfixExpr,((*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr)._typ, 258) /*expected idx: 258, name: v.ast.InfixExpr */ ;
			string styp_arg = v__gen__c__Gen_typ(g, typ);
			strings__Builder_writeln(&g->definitions, _STR("int %.*s\000 (%.*s\000* a, %.*s\000* b) {", 4, compare_fn, styp_arg, styp_arg));
			v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, typ);
			if (!is_reverse && v__ast__TypeSymbol_has_method(sym, _SLIT("<")) && v__ast__Expr_str(infix_expr.left).len == 1) {
				strings__Builder_writeln(&g->definitions, _STR("\tif (%.*s\000__lt(*a, *b)) { return -1; } else { return 1; }}", 2, styp));
			} else if (is_reverse && v__ast__TypeSymbol_has_method(sym, _SLIT("<")) && v__ast__Expr_str(infix_expr.left).len == 1) {
				strings__Builder_writeln(&g->definitions, _STR("\tif (%.*s\000__lt(*b, *a)) { return -1; } else { return 1; }}", 2, styp));
			} else {
				string field_type = v__gen__c__Gen_typ(g, infix_expr.left_type);
				string left_expr_str = v__gen__c__Gen_write_expr_to_string(g, infix_expr.left);
				string right_expr_str = v__gen__c__Gen_write_expr_to_string(g, infix_expr.right);
				if (v__ast__Type_is_ptr(typ)) {
					left_expr_str = string_replace_once(left_expr_str, _SLIT("a"), _SLIT("(*a)"));
					right_expr_str = string_replace_once(right_expr_str, _SLIT("b"), _SLIT("(*b)"));
				}
				strings__Builder_writeln(&g->definitions, _STR("%.*s\000 a_ = %.*s\000;", 3, field_type, left_expr_str));
				strings__Builder_writeln(&g->definitions, _STR("%.*s\000 b_ = %.*s\000;", 3, field_type, right_expr_str));
				string op1 = _SLIT("");
				string op2 = _SLIT("");
				if (v__ast__Type_alias_eq(infix_expr.left_type, _const_v__ast__string_type)) {
					if (is_reverse) {
						op1 = _SLIT("string_gt(a_, b_)");
						op2 = _SLIT("string_lt(a_, b_)");
					} else {
						op1 = _SLIT("string_lt(a_, b_)");
						op2 = _SLIT("string_gt(a_, b_)");
					}
				} else {
					string deref_str = (v__ast__Type_is_ptr(infix_expr.left_type) ? (_SLIT("*")) : (_SLIT("")));
					if (is_reverse) {
						op1 = _STR("%.*s\000a_ > %.*s\000b_", 3, deref_str, deref_str);
						op2 = _STR("%.*s\000a_ < %.*s\000b_", 3, deref_str, deref_str);
					} else {
						op1 = _STR("%.*s\000a_ < %.*s\000b_", 3, deref_str, deref_str);
						op2 = _STR("%.*s\000a_ > %.*s\000b_", 3, deref_str, deref_str);
					}
				}
				strings__Builder_writeln(&g->definitions, _STR("if (%.*s\000) return -1;", 2, op1));
				strings__Builder_writeln(&g->definitions, _STR("if (%.*s\000) return 1; return 0; }\n", 2, op2));
			}
		}
	}
	if (is_reverse && !string_ends_with(compare_fn, _SLIT("_reverse"))) {
		compare_fn = /*f*/string_add(compare_fn, _SLIT("_reverse"));
	}
	string deref = (v__ast__Type_is_ptr(node.left_type) || v__ast__Type_is_pointer(node.left_type) ? (_SLIT("->")) : (_SLIT(".")));
	g->empty_line = true;
	v__gen__c__Gen_write(g, _SLIT("qsort("));
	v__gen__c__Gen_expr(g, node.left);
	v__gen__c__Gen_write(g, _STR("%.*s\000data, ", 2, deref));
	v__gen__c__Gen_expr(g, node.left);
	v__gen__c__Gen_write(g, _STR("%.*s\000len, ", 2, deref));
	v__gen__c__Gen_expr(g, node.left);
	v__gen__c__Gen_write(g, _STR("%.*s\000element_size, (int (*)(const void *, const void *))&%.*s\000)", 3, deref, compare_fn));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_array_filter(v__gen__c__Gen* g, v__ast__CallExpr node) {
	string tmp = v__gen__c__Gen_new_tmp_var(g);
	string s = v__gen__c__Gen_go_before_stmt(g, 0);
	v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, node.return_type);
	if (sym->kind != v__ast__Kind_array) {
		v__gen__c__verror(_SLIT("filter() requires an array"));
	}
	v__ast__Array info = /* as */ *(v__ast__Array*)__as_cast((sym->info)._v__ast__Array,(sym->info)._typ, 395) /*expected idx: 395, name: v.ast.Array */ ;
	string styp = v__gen__c__Gen_typ(g, node.return_type);
	string elem_type_str = v__gen__c__Gen_typ(g, info.elem_type);
	g->empty_line = true;
	v__gen__c__Gen_write(g, _STR("%.*s\000 %.*s\000_orig = ", 3, v__gen__c__Gen_typ(g, node.left_type), tmp));
	v__gen__c__Gen_expr(g, node.left);
	v__gen__c__Gen_writeln(g, _SLIT(";"));
	v__gen__c__Gen_writeln(g, _STR("int %.*s\000_len = %.*s\000_orig.len;", 3, tmp, tmp));
	v__gen__c__Gen_writeln(g, _STR("%.*s\000 %.*s\000 = __new_array(0, %.*s\000_len, sizeof(%.*s\000));\n", 5, styp, tmp, tmp, elem_type_str));
	string i = v__gen__c__Gen_new_tmp_var(g);
	v__gen__c__Gen_writeln(g, _STR("for (int %.*s\000 = 0; %.*s\000 < %.*s\000_len; ++%.*s\000) {", 5, i, i, tmp, i));
	v__gen__c__Gen_writeln(g, _STR("\t%.*s\000 it = ((%.*s\000*) %.*s\000_orig.data)[%.*s\000];", 5, elem_type_str, elem_type_str, tmp, i));
	bool is_embed_map_filter = false;
	v__ast__Expr expr = (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr;
	if (expr._typ == 233 /* v.ast.AnonFn */) {
		v__gen__c__Gen_write(g, _SLIT("\tif ("));
		v__gen__c__Gen_gen_anon_fn_decl(g, (voidptr)&/*qq*/(*expr._v__ast__AnonFn));
		v__gen__c__Gen_write(g, _STR("%.*s\000(it)", 2, (*expr._v__ast__AnonFn).decl.name));
	}
	else if (expr._typ == 254 /* v.ast.Ident */) {
		v__gen__c__Gen_write(g, _SLIT("\tif ("));
		if ((*expr._v__ast__Ident).kind == v__ast__IdentKind_function) {
			v__gen__c__Gen_write(g, _STR("%.*s\000(it)", 2, v__gen__c__c_name((*expr._v__ast__Ident).name)));
		} else if ((*expr._v__ast__Ident).kind == v__ast__IdentKind_variable) {
			v__ast__IdentVar var_info = v__ast__Ident_var_info(&(*expr._v__ast__Ident));
			v__ast__TypeSymbol* sym_t = v__ast__Table_get_type_symbol(g->table, var_info.typ);
			if (sym_t->kind == v__ast__Kind_function) {
				v__gen__c__Gen_write(g, _STR("%.*s\000(it)", 2, v__gen__c__c_name((*expr._v__ast__Ident).name)));
			} else {
				v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
			}
		} else {
			v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
		}
	}
	else if (expr._typ == 241 /* v.ast.CallExpr */) {
		if ((string_eq((*expr._v__ast__CallExpr).name, _SLIT("map")) || string_eq((*expr._v__ast__CallExpr).name, _SLIT("filter")))) {
			is_embed_map_filter = true;
			array_push(&g->stmt_path_pos, _MOV((int[]){ g->out.len }));
		}
		v__gen__c__Gen_write(g, _SLIT("\tif ("));
		v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
	}
	else {
		v__gen__c__Gen_write(g, _SLIT("\tif ("));
		v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
	};
	v__gen__c__Gen_writeln(g, _SLIT(") {"));
	v__gen__c__Gen_writeln(g, _STR("\t\tarray_push(&%.*s\000, &it); \n\t\t}", 2, tmp));
	v__gen__c__Gen_writeln(g, _SLIT("}"));
	if (!is_embed_map_filter) {
		array_push(&g->stmt_path_pos, _MOV((int[]){ g->out.len }));
	}
	v__gen__c__Gen_write(g, _SLIT("\n"));
	v__gen__c__Gen_write(g, s);
	v__gen__c__Gen_write(g, tmp);
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_array_insert(v__gen__c__Gen* g, v__ast__CallExpr node) {
	v__ast__TypeSymbol* left_sym = v__ast__Table_get_type_symbol(g->table, node.left_type);
	v__ast__Array left_info = /* as */ *(v__ast__Array*)__as_cast((left_sym->info)._v__ast__Array,(left_sym->info)._typ, 395) /*expected idx: 395, name: v.ast.Array */ ;
	string elem_type_str = v__gen__c__Gen_typ(g, left_info.elem_type);
	v__ast__TypeSymbol* arg2_sym = v__ast__Table_get_type_symbol(g->table, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 1)).typ);
	bool is_arg2_array = arg2_sym->kind == v__ast__Kind_array && v__ast__Type_alias_eq((*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 1)).typ, node.left_type);
	if (is_arg2_array) {
		v__gen__c__Gen_write(g, _SLIT("array_insert_many(&"));
	} else {
		v__gen__c__Gen_write(g, _SLIT("array_insert(&"));
	}
	v__gen__c__Gen_expr(g, node.left);
	v__gen__c__Gen_write(g, _SLIT(", "));
	v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
	if (is_arg2_array) {
		v__gen__c__Gen_write(g, _SLIT(", "));
		v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 1)).expr);
		v__gen__c__Gen_write(g, _SLIT(".data, "));
		v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 1)).expr);
		v__gen__c__Gen_write(g, _SLIT(".len)"));
	} else {
		v__gen__c__Gen_write(g, _STR(", &(%.*s\000[]){", 2, elem_type_str));
		if (v__ast__Type_alias_eq(left_info.elem_type, _const_v__ast__string_type)) {
			v__gen__c__Gen_write(g, _SLIT("string_clone("));
		}
		v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 1)).expr);
		if (v__ast__Type_alias_eq(left_info.elem_type, _const_v__ast__string_type)) {
			v__gen__c__Gen_write(g, _SLIT(")"));
		}
		v__gen__c__Gen_write(g, _SLIT("})"));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_array_prepend(v__gen__c__Gen* g, v__ast__CallExpr node) {
	v__ast__TypeSymbol* left_sym = v__ast__Table_get_type_symbol(g->table, node.left_type);
	v__ast__Array left_info = /* as */ *(v__ast__Array*)__as_cast((left_sym->info)._v__ast__Array,(left_sym->info)._typ, 395) /*expected idx: 395, name: v.ast.Array */ ;
	string elem_type_str = v__gen__c__Gen_typ(g, left_info.elem_type);
	v__ast__TypeSymbol* arg_sym = v__ast__Table_get_type_symbol(g->table, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).typ);
	bool is_arg_array = arg_sym->kind == v__ast__Kind_array && v__ast__Type_alias_eq((*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).typ, node.left_type);
	if (is_arg_array) {
		v__gen__c__Gen_write(g, _SLIT("array_prepend_many(&"));
	} else {
		v__gen__c__Gen_write(g, _SLIT("array_prepend(&"));
	}
	v__gen__c__Gen_expr(g, node.left);
	if (is_arg_array) {
		v__gen__c__Gen_write(g, _SLIT(", "));
		v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
		v__gen__c__Gen_write(g, _SLIT(".data, "));
		v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
		v__gen__c__Gen_write(g, _SLIT(".len)"));
	} else {
		v__gen__c__Gen_write(g, _STR(", &(%.*s\000[]){", 2, elem_type_str));
		v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
		v__gen__c__Gen_write(g, _SLIT("})"));
	}
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_gen_array_contains_method(v__gen__c__Gen* g, v__ast__Type left_type) {
	v__ast__TypeSymbol* left_sym = v__ast__Table_get_type_symbol(g->table, left_type);
	string left_type_str = string_replace(v__gen__c__Gen_typ(g, left_type), _SLIT("*"), _SLIT(""));
	string fn_name = _STR("%.*s\000_contains", 2, left_type_str);
	if (!v__ast__TypeSymbol_has_method(left_sym, _SLIT("contains"))) {
		v__ast__Array left_info = /* as */ *(v__ast__Array*)__as_cast((left_sym->info)._v__ast__Array,(left_sym->info)._typ, 395) /*expected idx: 395, name: v.ast.Array */ ;
		string elem_type_str = v__gen__c__Gen_typ(g, left_info.elem_type);
		v__ast__TypeSymbol* elem_sym = v__ast__Table_get_type_symbol(g->table, left_info.elem_type);
		if (elem_sym->kind == v__ast__Kind_function) {
			left_type_str = _SLIT("Array_voidptr");
			elem_type_str = _SLIT("voidptr");
		}
		strings__Builder_writeln(&g->type_definitions, _STR("static bool %.*s\000(%.*s\000 a, %.*s\000 v); // auto", 4, fn_name, left_type_str, elem_type_str));
		strings__Builder fn_builder = strings__new_builder(512);
		strings__Builder_writeln(&fn_builder, _STR("static bool %.*s\000(%.*s\000 a, %.*s\000 v) {", 4, fn_name, left_type_str, elem_type_str));
		strings__Builder_writeln(&fn_builder, _SLIT("\tfor (int i = 0; i < a.len; ++i) {"));
		if (elem_sym->kind == v__ast__Kind_string) {
			strings__Builder_writeln(&fn_builder, _SLIT("\t\tif (string_eq((*(string*)array_get(a, i)), v)) {"));
		} else if (elem_sym->kind == v__ast__Kind_array && v__ast__Type_nr_muls(left_info.elem_type) == 0) {
			string ptr_typ = v__gen__c__Gen_gen_array_equality_fn(g, left_info.elem_type);
			strings__Builder_writeln(&fn_builder, _STR("\t\tif (%.*s\000_arr_eq(*(%.*s\000*)array_get(a, i), v)) {", 3, ptr_typ, elem_type_str));
		} else if (elem_sym->kind == v__ast__Kind_function) {
			strings__Builder_writeln(&fn_builder, _SLIT("\t\tif ((*(voidptr*)array_get(a, i)) == v) {"));
		} else if (elem_sym->kind == v__ast__Kind_map && v__ast__Type_nr_muls(left_info.elem_type) == 0) {
			string ptr_typ = v__gen__c__Gen_gen_map_equality_fn(g, left_info.elem_type);
			strings__Builder_writeln(&fn_builder, _STR("\t\tif (%.*s\000_map_eq(*(%.*s\000*)array_get(a, i), v)) {", 3, ptr_typ, elem_type_str));
		} else if (elem_sym->kind == v__ast__Kind_struct_ && v__ast__Type_nr_muls(left_info.elem_type) == 0) {
			string ptr_typ = v__gen__c__Gen_gen_struct_equality_fn(g, left_info.elem_type);
			strings__Builder_writeln(&fn_builder, _STR("\t\tif (%.*s\000_struct_eq(*(%.*s\000*)array_get(a, i), v)) {", 3, ptr_typ, elem_type_str));
		} else {
			strings__Builder_writeln(&fn_builder, _STR("\t\tif ((*(%.*s\000*)array_get(a, i)) == v) {", 2, elem_type_str));
		}
		strings__Builder_writeln(&fn_builder, _SLIT("\t\t\treturn true;"));
		strings__Builder_writeln(&fn_builder, _SLIT("\t\t}"));
		strings__Builder_writeln(&fn_builder, _SLIT("\t}"));
		strings__Builder_writeln(&fn_builder, _SLIT("\treturn false;"));
		strings__Builder_writeln(&fn_builder, _SLIT("}"));
		array_push(&g->auto_fn_definitions, _MOV((string[]){ string_clone(strings__Builder_str(&fn_builder)) }));
		v__ast__TypeSymbol_register_method(left_sym, *(v__ast__Fn*)memdup(&(v__ast__Fn){.params = new_array_from_c_array(2, 2, sizeof(v__ast__Param), _MOV((v__ast__Param[2]){(v__ast__Param){.pos = {0},.name = (string){.str=(byteptr)"", .is_lit=1},.is_mut = 0,.is_auto_rec = 0,.typ = left_type,.type_pos = {0},.is_hidden = 0,}, (v__ast__Param){.pos = {0},.name = (string){.str=(byteptr)"", .is_lit=1},.is_mut = 0,.is_auto_rec = 0,.typ = left_info.elem_type,.type_pos = {0},.is_hidden = 0,}})),.return_type = 0,.is_variadic = 0,.language = 0,.generic_names = __new_array(0, 1, sizeof(string)),.is_pub = 0,.is_deprecated = 0,.is_unsafe = 0,.is_placeholder = 0,.is_main = 0,.is_test = 0,.is_conditional = 0,.is_keep_alive = 0,.no_body = 0,.mod = (string){.str=(byteptr)"", .is_lit=1},.ctdefine = (string){.str=(byteptr)"", .is_lit=1},.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.name = _SLIT("contains"),.source_fn = 0,.usages = 0,}, sizeof(v__ast__Fn)));
	}
	// autofree_scope_vars(pos=15388 line_nr=498 scope.pos=13226 scope.end_pos=15404)
	// var "g" var.pos=13231 var.line_nr=451
	// var "left_type" var.pos=13264 var.line_nr=451
	// var "left_sym" var.pos=13298 var.line_nr=452
	// var "left_type_str" var.pos=13350 var.line_nr=453
	// var "fn_name" var.pos=13402 var.line_nr=454
	// af parent scope:
	// af parent scope:
	return fn_name;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_array_contains(v__gen__c__Gen* g, v__ast__CallExpr node) {
	string fn_name = v__gen__c__Gen_gen_array_contains_method(g, node.left_type);
	v__gen__c__Gen_write(g, _STR("%.*s\000(", 2, fn_name));
	if (v__ast__Type_is_ptr(node.left_type)) {
		v__gen__c__Gen_write(g, _SLIT("*"));
	}
	v__gen__c__Gen_expr(g, node.left);
	v__gen__c__Gen_write(g, _SLIT(", "));
	v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
	v__gen__c__Gen_write(g, _SLIT(")"));
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_gen_array_index_method(v__gen__c__Gen* g, v__ast__Type left_type) {
	v__ast__TypeSymbol* left_sym = v__ast__Table_get_type_symbol(g->table, left_type);
	string left_type_str = string_trim(v__gen__c__Gen_typ(g, left_type), _SLIT("*"));
	string fn_name = _STR("%.*s\000_index", 2, left_type_str);
	if (!v__ast__TypeSymbol_has_method(left_sym, _SLIT("index"))) {
		v__ast__Array info = /* as */ *(v__ast__Array*)__as_cast((left_sym->info)._v__ast__Array,(left_sym->info)._typ, 395) /*expected idx: 395, name: v.ast.Array */ ;
		string elem_type_str = v__gen__c__Gen_typ(g, info.elem_type);
		v__ast__TypeSymbol* elem_sym = v__ast__Table_get_type_symbol(g->table, info.elem_type);
		if (elem_sym->kind == v__ast__Kind_function) {
			left_type_str = _SLIT("Array_voidptr");
			elem_type_str = _SLIT("voidptr");
		}
		strings__Builder_writeln(&g->type_definitions, _STR("static int %.*s\000(%.*s\000 a, %.*s\000 v); // auto", 4, fn_name, left_type_str, elem_type_str));
		strings__Builder fn_builder = strings__new_builder(512);
		strings__Builder_writeln(&fn_builder, _STR("static int %.*s\000(%.*s\000 a, %.*s\000 v) {", 4, fn_name, left_type_str, elem_type_str));
		strings__Builder_writeln(&fn_builder, _SLIT("\tfor (int i = 0; i < a.len; ++i) {"));
		if (elem_sym->kind == v__ast__Kind_string) {
			strings__Builder_writeln(&fn_builder, _SLIT("\t\tif (string_eq((*(string*)array_get(a, i)), v)) {"));
		} else if (elem_sym->kind == v__ast__Kind_array && !v__ast__Type_is_ptr(info.elem_type)) {
			string ptr_typ = v__gen__c__Gen_gen_array_equality_fn(g, info.elem_type);
			strings__Builder_writeln(&fn_builder, _STR("\t\tif (%.*s\000_arr_eq(*(%.*s\000*)array_get(a, i), v)) {", 3, ptr_typ, elem_type_str));
		} else if (elem_sym->kind == v__ast__Kind_function && !v__ast__Type_is_ptr(info.elem_type)) {
			strings__Builder_writeln(&fn_builder, _SLIT("\t\tif ((*(voidptr*)array_get(a, i)) == v) {"));
		} else if (elem_sym->kind == v__ast__Kind_map && !v__ast__Type_is_ptr(info.elem_type)) {
			string ptr_typ = v__gen__c__Gen_gen_map_equality_fn(g, info.elem_type);
			strings__Builder_writeln(&fn_builder, _STR("\t\tif (%.*s\000_map_eq(*(%.*s\000*)array_get(a, i), v)) {", 3, ptr_typ, elem_type_str));
		} else if (elem_sym->kind == v__ast__Kind_struct_ && !v__ast__Type_is_ptr(info.elem_type)) {
			string ptr_typ = v__gen__c__Gen_gen_struct_equality_fn(g, info.elem_type);
			strings__Builder_writeln(&fn_builder, _STR("\t\tif (%.*s\000_struct_eq(*(%.*s\000*)array_get(a, i), v)) {", 3, ptr_typ, elem_type_str));
		} else {
			strings__Builder_writeln(&fn_builder, _STR("\t\tif ((*(%.*s\000*)array_get(a, i)) == v) {", 2, elem_type_str));
		}
		strings__Builder_writeln(&fn_builder, _SLIT("\t\t\treturn i;"));
		strings__Builder_writeln(&fn_builder, _SLIT("\t\t}"));
		strings__Builder_writeln(&fn_builder, _SLIT("\t}"));
		strings__Builder_writeln(&fn_builder, _SLIT("\treturn -1;"));
		strings__Builder_writeln(&fn_builder, _SLIT("}"));
		array_push(&g->auto_fn_definitions, _MOV((string[]){ string_clone(strings__Builder_str(&fn_builder)) }));
		v__ast__TypeSymbol_register_method(left_sym, *(v__ast__Fn*)memdup(&(v__ast__Fn){.params = new_array_from_c_array(2, 2, sizeof(v__ast__Param), _MOV((v__ast__Param[2]){(v__ast__Param){.pos = {0},.name = (string){.str=(byteptr)"", .is_lit=1},.is_mut = 0,.is_auto_rec = 0,.typ = left_type,.type_pos = {0},.is_hidden = 0,}, (v__ast__Param){.pos = {0},.name = (string){.str=(byteptr)"", .is_lit=1},.is_mut = 0,.is_auto_rec = 0,.typ = info.elem_type,.type_pos = {0},.is_hidden = 0,}})),.return_type = 0,.is_variadic = 0,.language = 0,.generic_names = __new_array(0, 1, sizeof(string)),.is_pub = 0,.is_deprecated = 0,.is_unsafe = 0,.is_placeholder = 0,.is_main = 0,.is_test = 0,.is_conditional = 0,.is_keep_alive = 0,.no_body = 0,.mod = (string){.str=(byteptr)"", .is_lit=1},.ctdefine = (string){.str=(byteptr)"", .is_lit=1},.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.name = _SLIT("index"),.source_fn = 0,.usages = 0,}, sizeof(v__ast__Fn)));
	}
	// autofree_scope_vars(pos=17791 line_nr=561 scope.pos=15693 scope.end_pos=17807)
	// var "g" var.pos=15698 var.line_nr=514
	// var "left_type" var.pos=15728 var.line_nr=514
	// var "left_sym" var.pos=15762 var.line_nr=515
	// var "left_type_str" var.pos=15814 var.line_nr=516
	// var "fn_name" var.pos=15859 var.line_nr=517
	// af parent scope:
	// af parent scope:
	return fn_name;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_array_index(v__gen__c__Gen* g, v__ast__CallExpr node) {
	string fn_name = v__gen__c__Gen_gen_array_index_method(g, node.left_type);
	v__gen__c__Gen_write(g, _STR("%.*s\000(", 2, fn_name));
	if (v__ast__Type_is_ptr(node.left_type)) {
		v__gen__c__Gen_write(g, _SLIT("*"));
	}
	v__gen__c__Gen_expr(g, node.left);
	v__gen__c__Gen_write(g, _SLIT(", "));
	v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
	v__gen__c__Gen_write(g, _SLIT(")"));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_array_wait(v__gen__c__Gen* g, v__ast__CallExpr node) {
	v__ast__TypeSymbol* arr = v__ast__Table_get_type_symbol(g->table, node.receiver_type);
	v__ast__Type thread_type = v__ast__TypeSymbol_array_info(arr).elem_type;
	v__ast__TypeSymbol* thread_sym = v__ast__Table_get_type_symbol(g->table, thread_type);
	v__ast__Type thread_ret_type = v__ast__TypeSymbol_thread_info(thread_sym).return_type;
	string eltyp = v__ast__Table_get_type_symbol(g->table, thread_ret_type)->cname;
	string fn_name = v__gen__c__Gen_register_thread_array_wait_call(g, eltyp);
	v__gen__c__Gen_write(g, _STR("%.*s\000(", 2, fn_name));
	v__gen__c__Gen_expr(g, node.left);
	v__gen__c__Gen_write(g, _SLIT(")"));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_array_any(v__gen__c__Gen* g, v__ast__CallExpr node) {
	string tmp = v__gen__c__Gen_new_tmp_var(g);
	string s = v__gen__c__Gen_go_before_stmt(g, 0);
	v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, node.left_type);
	v__ast__Array info = /* as */ *(v__ast__Array*)__as_cast((sym->info)._v__ast__Array,(sym->info)._typ, 395) /*expected idx: 395, name: v.ast.Array */ ;
	string elem_type_str = v__gen__c__Gen_typ(g, info.elem_type);
	g->empty_line = true;
	v__gen__c__Gen_write(g, _STR("%.*s\000 %.*s\000_orig = ", 3, v__gen__c__Gen_typ(g, node.left_type), tmp));
	v__gen__c__Gen_expr(g, node.left);
	v__gen__c__Gen_writeln(g, _SLIT(";"));
	v__gen__c__Gen_writeln(g, _STR("int %.*s\000_len = %.*s\000_orig.len;", 3, tmp, tmp));
	v__gen__c__Gen_writeln(g, _STR("bool %.*s\000 = false;", 2, tmp));
	string i = v__gen__c__Gen_new_tmp_var(g);
	v__gen__c__Gen_writeln(g, _STR("for (int %.*s\000 = 0; %.*s\000 < %.*s\000_len; ++%.*s\000) {", 5, i, i, tmp, i));
	v__gen__c__Gen_writeln(g, _STR("\t%.*s\000 it = ((%.*s\000*) %.*s\000_orig.data)[%.*s\000];", 5, elem_type_str, elem_type_str, tmp, i));
	bool is_embed_map_filter = false;
	v__ast__Expr expr = (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr;
	if (expr._typ == 233 /* v.ast.AnonFn */) {
		v__gen__c__Gen_write(g, _SLIT("\tif ("));
		v__gen__c__Gen_gen_anon_fn_decl(g, (voidptr)&/*qq*/(*expr._v__ast__AnonFn));
		v__gen__c__Gen_write(g, _STR("%.*s\000(it)", 2, (*expr._v__ast__AnonFn).decl.name));
	}
	else if (expr._typ == 254 /* v.ast.Ident */) {
		v__gen__c__Gen_write(g, _SLIT("\tif ("));
		if ((*expr._v__ast__Ident).kind == v__ast__IdentKind_function) {
			v__gen__c__Gen_write(g, _STR("%.*s\000(it)", 2, v__gen__c__c_name((*expr._v__ast__Ident).name)));
		} else if ((*expr._v__ast__Ident).kind == v__ast__IdentKind_variable) {
			v__ast__IdentVar var_info = v__ast__Ident_var_info(&(*expr._v__ast__Ident));
			v__ast__TypeSymbol* sym_t = v__ast__Table_get_type_symbol(g->table, var_info.typ);
			if (sym_t->kind == v__ast__Kind_function) {
				v__gen__c__Gen_write(g, _STR("%.*s\000(it)", 2, v__gen__c__c_name((*expr._v__ast__Ident).name)));
			} else {
				v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
			}
		} else {
			v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
		}
	}
	else if (expr._typ == 241 /* v.ast.CallExpr */) {
		if ((string_eq((*expr._v__ast__CallExpr).name, _SLIT("map")) || string_eq((*expr._v__ast__CallExpr).name, _SLIT("filter")))) {
			is_embed_map_filter = true;
			array_push(&g->stmt_path_pos, _MOV((int[]){ g->out.len }));
		}
		v__gen__c__Gen_write(g, _SLIT("\tif ("));
		v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
	}
	else {
		v__gen__c__Gen_write(g, _SLIT("\tif ("));
		v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
	};
	v__gen__c__Gen_writeln(g, _SLIT(") {"));
	v__gen__c__Gen_writeln(g, _STR("\t\t%.*s\000 = true;\n\t\t\tbreak;\n\t\t}", 2, tmp));
	v__gen__c__Gen_writeln(g, _SLIT("}"));
	if (!is_embed_map_filter) {
		array_push(&g->stmt_path_pos, _MOV((int[]){ g->out.len }));
	}
	v__gen__c__Gen_write(g, _SLIT("\n"));
	v__gen__c__Gen_write(g, s);
	v__gen__c__Gen_write(g, tmp);
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_array_all(v__gen__c__Gen* g, v__ast__CallExpr node) {
	string tmp = v__gen__c__Gen_new_tmp_var(g);
	string s = v__gen__c__Gen_go_before_stmt(g, 0);
	v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, node.left_type);
	v__ast__Array info = /* as */ *(v__ast__Array*)__as_cast((sym->info)._v__ast__Array,(sym->info)._typ, 395) /*expected idx: 395, name: v.ast.Array */ ;
	string elem_type_str = v__gen__c__Gen_typ(g, info.elem_type);
	g->empty_line = true;
	v__gen__c__Gen_write(g, _STR("%.*s\000 %.*s\000_orig = ", 3, v__gen__c__Gen_typ(g, node.left_type), tmp));
	v__gen__c__Gen_expr(g, node.left);
	v__gen__c__Gen_writeln(g, _SLIT(";"));
	v__gen__c__Gen_writeln(g, _STR("int %.*s\000_len = %.*s\000_orig.len;", 3, tmp, tmp));
	v__gen__c__Gen_writeln(g, _STR("bool %.*s\000 = true;", 2, tmp));
	string i = v__gen__c__Gen_new_tmp_var(g);
	v__gen__c__Gen_writeln(g, _STR("for (int %.*s\000 = 0; %.*s\000 < %.*s\000_len; ++%.*s\000) {", 5, i, i, tmp, i));
	v__gen__c__Gen_writeln(g, _STR("\t%.*s\000 it = ((%.*s\000*) %.*s\000_orig.data)[%.*s\000];", 5, elem_type_str, elem_type_str, tmp, i));
	bool is_embed_map_filter = false;
	v__ast__Expr expr = (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr;
	if (expr._typ == 233 /* v.ast.AnonFn */) {
		v__gen__c__Gen_write(g, _SLIT("\tif (!("));
		v__gen__c__Gen_gen_anon_fn_decl(g, (voidptr)&/*qq*/(*expr._v__ast__AnonFn));
		v__gen__c__Gen_write(g, _STR("%.*s\000(it)", 2, (*expr._v__ast__AnonFn).decl.name));
	}
	else if (expr._typ == 254 /* v.ast.Ident */) {
		v__gen__c__Gen_write(g, _SLIT("\tif (!("));
		if ((*expr._v__ast__Ident).kind == v__ast__IdentKind_function) {
			v__gen__c__Gen_write(g, _STR("%.*s\000(it)", 2, v__gen__c__c_name((*expr._v__ast__Ident).name)));
		} else if ((*expr._v__ast__Ident).kind == v__ast__IdentKind_variable) {
			v__ast__IdentVar var_info = v__ast__Ident_var_info(&(*expr._v__ast__Ident));
			v__ast__TypeSymbol* sym_t = v__ast__Table_get_type_symbol(g->table, var_info.typ);
			if (sym_t->kind == v__ast__Kind_function) {
				v__gen__c__Gen_write(g, _STR("%.*s\000(it)", 2, v__gen__c__c_name((*expr._v__ast__Ident).name)));
			} else {
				v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
			}
		} else {
			v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
		}
	}
	else if (expr._typ == 241 /* v.ast.CallExpr */) {
		if ((string_eq((*expr._v__ast__CallExpr).name, _SLIT("map")) || string_eq((*expr._v__ast__CallExpr).name, _SLIT("filter")))) {
			is_embed_map_filter = true;
			array_push(&g->stmt_path_pos, _MOV((int[]){ g->out.len }));
		}
		v__gen__c__Gen_write(g, _SLIT("\tif (!("));
		v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
	}
	else {
		v__gen__c__Gen_write(g, _SLIT("\tif (!("));
		v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
	};
	v__gen__c__Gen_writeln(g, _SLIT(")) {"));
	v__gen__c__Gen_writeln(g, _STR("\t\t%.*s\000 = false;\n\t\t\tbreak;\n\t\t}", 2, tmp));
	v__gen__c__Gen_writeln(g, _SLIT("}"));
	if (!is_embed_map_filter) {
		array_push(&g->stmt_path_pos, _MOV((int[]){ g->out.len }));
	}
	v__gen__c__Gen_write(g, _SLIT("\n"));
	v__gen__c__Gen_write(g, s);
	v__gen__c__Gen_write(g, tmp);
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_assert_stmt(v__gen__c__Gen* g, v__ast__AssertStmt original_assert_statement) {
	v__ast__AssertStmt node = original_assert_statement;
	v__gen__c__Gen_writeln(g, _SLIT("// assert"));
	if ((node.expr)._typ == 258 /* v.ast.InfixExpr */) {
		if (((*node.expr._v__ast__InfixExpr).left)._typ == 241 /* v.ast.CallExpr */) {
			(*node.expr._v__ast__InfixExpr).left = v__ast__CTempVar_to_sumtype_v__ast__Expr(ADDR(v__ast__CTempVar, (v__gen__c__Gen_new_ctemp_var_then_gen(g, (*node.expr._v__ast__InfixExpr).left, (*node.expr._v__ast__InfixExpr).left_type))));
		}
		if (((*node.expr._v__ast__InfixExpr).right)._typ == 241 /* v.ast.CallExpr */) {
			(*node.expr._v__ast__InfixExpr).right = v__ast__CTempVar_to_sumtype_v__ast__Expr(ADDR(v__ast__CTempVar, (v__gen__c__Gen_new_ctemp_var_then_gen(g, (*node.expr._v__ast__InfixExpr).right, (*node.expr._v__ast__InfixExpr).right_type))));
		}
	}
	g->inside_ternary++;
	if (g->is_test) {
		v__gen__c__Gen_write(g, _SLIT("if ("));
		v__gen__c__Gen_expr(g, node.expr);
		v__gen__c__Gen_write(g, _SLIT(")"));
		v__gen__c__Gen_decrement_inside_ternary(g);
		v__gen__c__Gen_writeln(g, _SLIT(" {"));
		v__gen__c__Gen_writeln(g, _SLIT("\tg_test_oks++;"));
		string metaname_ok = v__gen__c__Gen_gen_assert_metainfo(g, node);
		v__gen__c__Gen_writeln(g, _STR("\tmain__cb_assertion_ok(&%.*s\000);", 2, metaname_ok));
		v__gen__c__Gen_writeln(g, _SLIT("} else {"));
		v__gen__c__Gen_writeln(g, _SLIT("\tg_test_fails++;"));
		string metaname_fail = v__gen__c__Gen_gen_assert_metainfo(g, node);
		v__gen__c__Gen_writeln(g, _STR("\tmain__cb_assertion_failed(&%.*s\000);", 2, metaname_fail));
		v__gen__c__Gen_writeln(g, _SLIT("\tlongjmp(g_jump_buffer, 1);"));
		v__gen__c__Gen_writeln(g, _SLIT("\t// TODO"));
		v__gen__c__Gen_writeln(g, _SLIT("\t// Maybe print all vars in a test function if it fails?"));
		v__gen__c__Gen_writeln(g, _SLIT("}"));
	} else {
		v__gen__c__Gen_write(g, _SLIT("if (!("));
		v__gen__c__Gen_expr(g, node.expr);
		v__gen__c__Gen_write(g, _SLIT("))"));
		v__gen__c__Gen_decrement_inside_ternary(g);
		v__gen__c__Gen_writeln(g, _SLIT(" {"));
		string metaname_panic = v__gen__c__Gen_gen_assert_metainfo(g, node);
		v__gen__c__Gen_writeln(g, _STR("\t__print_assert_failure(&%.*s\000);", 2, metaname_panic));
		v__gen__c__Gen_writeln(g, _SLIT("\tv_panic(_SLIT(\"Assertion failed...\"));"));
		v__gen__c__Gen_writeln(g, _SLIT("}"));
	}
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_gen_assert_metainfo(v__gen__c__Gen* g, v__ast__AssertStmt node) {
	string mod_path = v__gen__c__cestring(g->file.path);
	string fn_name = g->fn_decl->name;
	int line_nr = node.pos.line_nr;
	string src = v__gen__c__cestring(v__ast__Expr_str(node.expr));
	string metaname = _STR("v_assert_meta_info_%.*s", 1, v__gen__c__Gen_new_tmp_var(g));
	v__gen__c__Gen_writeln(g, _STR("\tVAssertMetaInfo %.*s\000 = {0};", 2, metaname));
	v__gen__c__Gen_writeln(g, _STR("\t%.*s\000.fpath = %.*s\000;", 3, metaname, v__gen__c__ctoslit(mod_path)));
	v__gen__c__Gen_writeln(g, _STR("\t%.*s\000.line_nr = %"PRId32"\000;", 3, metaname, line_nr));
	v__gen__c__Gen_writeln(g, _STR("\t%.*s\000.fn_name = %.*s\000;", 3, metaname, v__gen__c__ctoslit(fn_name)));
	string metasrc = v__gen__c__cnewlines(v__gen__c__ctoslit(src));
	v__gen__c__Gen_writeln(g, _STR("\t%.*s\000.src = %.*s\000;", 3, metaname, metasrc));
	if (node.expr._typ == 258 /* v.ast.InfixExpr */) {
		string expr_op_str = v__gen__c__ctoslit(v__token__Kind_str((*node.expr._v__ast__InfixExpr).op));
		string expr_left_str = v__gen__c__cnewlines(v__gen__c__ctoslit(v__ast__Expr_str((*node.expr._v__ast__InfixExpr).left)));
		string expr_right_str = v__gen__c__cnewlines(v__gen__c__ctoslit(v__ast__Expr_str((*node.expr._v__ast__InfixExpr).right)));
		v__gen__c__Gen_writeln(g, _STR("\t%.*s\000.op = %.*s\000;", 3, metaname, expr_op_str));
		v__gen__c__Gen_writeln(g, _STR("\t%.*s\000.llabel = %.*s\000;", 3, metaname, expr_left_str));
		v__gen__c__Gen_writeln(g, _STR("\t%.*s\000.rlabel = %.*s\000;", 3, metaname, expr_right_str));
		v__gen__c__Gen_write(g, _STR("\t%.*s\000.lvalue = ", 2, metaname));
		v__gen__c__Gen_gen_assert_single_expr(g, (*node.expr._v__ast__InfixExpr).left, (*node.expr._v__ast__InfixExpr).left_type);
		v__gen__c__Gen_writeln(g, _SLIT(";"));
		v__gen__c__Gen_write(g, _STR("\t%.*s\000.rvalue = ", 2, metaname));
		v__gen__c__Gen_gen_assert_single_expr(g, (*node.expr._v__ast__InfixExpr).right, (*node.expr._v__ast__InfixExpr).right_type);
		v__gen__c__Gen_writeln(g, _SLIT(";"));
	}
	else if (node.expr._typ == 241 /* v.ast.CallExpr */) {
		v__gen__c__Gen_writeln(g, _STR("\t%.*s\000.op = _SLIT(\"call\");", 2, metaname));
	}
	else {
	};
	// autofree_scope_vars(pos=2770 line_nr=82 scope.pos=1529 scope.end_pos=2787)
	// var "g" var.pos=1534 var.line_nr=49
	// var "node" var.pos=1561 var.line_nr=49
	// var "mod_path" var.pos=1592 var.line_nr=50
	// var "fn_name" var.pos=1627 var.line_nr=51
	// var "line_nr" var.pos=1654 var.line_nr=52
	// var "src" var.pos=1683 var.line_nr=53
	// var "metaname" var.pos=1717 var.line_nr=54
	// var "metasrc" var.pos=1982 var.line_nr=59
	// af parent scope:
	// af parent scope:
	return metaname;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_assert_single_expr(v__gen__c__Gen* g, v__ast__Expr expr, v__ast__Type typ) {
	string unknown_value = _SLIT("*unknown value*");
	if (expr._typ == 242 /* v.ast.CastExpr */) {
		v__gen__c__Gen_write(g, v__gen__c__ctoslit(unknown_value));
	}
	else if (expr._typ == 257 /* v.ast.IndexExpr */) {
		v__gen__c__Gen_write(g, v__gen__c__ctoslit(unknown_value));
	}
	else if (expr._typ == 263 /* v.ast.MatchExpr */) {
		v__gen__c__Gen_write(g, v__gen__c__ctoslit(unknown_value));
	}
	else if (expr._typ == 270 /* v.ast.PrefixExpr */) {
		if (((*expr._v__ast__PrefixExpr).right)._typ == 242 /* v.ast.CastExpr */) {
			v__gen__c__Gen_write(g, v__gen__c__ctoslit(unknown_value));
		} else {
			v__gen__c__Gen_gen_expr_to_string(g, expr, typ);
		}
	}
	else if (expr._typ == 279 /* v.ast.TypeNode */) {
		v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, typ);
		v__gen__c__Gen_write(g, v__gen__c__ctoslit(_STR("%.*s", 1, sym->name)));
	}
	else {
		v__gen__c__Gen_gen_expr_to_string(g, expr, typ);
	};
	v__gen__c__Gen_write(g, string_add(string_add(string_add(string_add(_SLIT(" /* typeof: "), tos3( /* v.ast.Expr */ v_typeof_sumtype_v__ast__Expr( (expr)._typ ))), _SLIT(" type: ")), int_str(typ)), _SLIT(" */ ")));
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_gen_sumtype_equality_fn(v__gen__c__Gen* g, v__ast__Type left) {
	string ptr_typ = string_trim(v__gen__c__Gen_typ(g, left), _SLIT("*"));
	if ((Array_string_contains(g->sumtype_fn_definitions, ptr_typ))) {
		// autofree_scope_vars(pos=346 line_nr=10 scope.pos=343 scope.end_pos=363)
		// af parent scope:
		// var "g" var.pos=214 var.line_nr=7
		// var "left" var.pos=245 var.line_nr=7
		// var "ptr_typ" var.pos=270 var.line_nr=8
		// var "left_sym" var.pos=403 var.line_nr=13
		// var "info" var.pos=446 var.line_nr=14
		// var "fn_builder" var.pos=581 var.line_nr=16
		// af parent scope:
		// af parent scope:
		return ptr_typ;
	}
	array_push(&g->sumtype_fn_definitions, _MOV((string[]){ string_clone(ptr_typ) }));
	v__ast__TypeSymbol* left_sym = v__ast__Table_get_type_symbol(g->table, left);
	v__ast__SumType info = v__ast__TypeSymbol_sumtype_info(left_sym);
	strings__Builder_writeln(&g->type_definitions, _STR("static bool %.*s\000_sumtype_eq(%.*s\000 a, %.*s\000 b); // auto", 4, ptr_typ, ptr_typ, ptr_typ));
	strings__Builder fn_builder = strings__new_builder(512);
	strings__Builder_writeln(&fn_builder, _STR("static bool %.*s\000_sumtype_eq(%.*s\000 a, %.*s\000 b) {", 4, ptr_typ, ptr_typ, ptr_typ));
	strings__Builder_writeln(&fn_builder, _SLIT("\tif (a._typ != b._typ) { return false; } "));
	// FOR IN array
	for (int _t2810 = 0; _t2810 < info.variants.len; ++_t2810) {
		v__ast__Type typ = ((v__ast__Type*)info.variants.data)[_t2810];
		v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, typ);
		strings__Builder_writeln(&fn_builder, _STR("\tif (a._typ == %"PRId32"\000) {", 2, typ));
		string name = _STR("_%.*s", 1, sym->cname);
		if (sym->kind == v__ast__Kind_string) {
			strings__Builder_writeln(&fn_builder, _STR("\t\tif (string_ne(*a.%.*s\000, *b.%.*s\000)) {", 3, name, name));
		} else if (sym->kind == v__ast__Kind_sum_type && !v__ast__Type_is_ptr(typ)) {
			string eq_fn = v__gen__c__Gen_gen_sumtype_equality_fn(g, typ);
			strings__Builder_writeln(&fn_builder, _STR("\t\tif (!%.*s\000_sumtype_eq(*a.%.*s\000, *b.%.*s\000)) {", 4, eq_fn, name, name));
		} else if (sym->kind == v__ast__Kind_struct_ && !v__ast__Type_is_ptr(typ)) {
			string eq_fn = v__gen__c__Gen_gen_struct_equality_fn(g, typ);
			strings__Builder_writeln(&fn_builder, _STR("\t\tif (!%.*s\000_struct_eq(*a.%.*s\000, *b.%.*s\000)) {", 4, eq_fn, name, name));
		} else if (sym->kind == v__ast__Kind_array && !v__ast__Type_is_ptr(typ)) {
			string eq_fn = v__gen__c__Gen_gen_array_equality_fn(g, typ);
			strings__Builder_writeln(&fn_builder, _STR("\t\tif (!%.*s\000_arr_eq(*a.%.*s\000, *b.%.*s\000)) {", 4, eq_fn, name, name));
		} else if (sym->kind == v__ast__Kind_array_fixed && !v__ast__Type_is_ptr(typ)) {
			string eq_fn = v__gen__c__Gen_gen_fixed_array_equality_fn(g, typ);
			strings__Builder_writeln(&fn_builder, _STR("\t\tif (!%.*s\000_arr_eq(*a.%.*s\000, *b.%.*s\000)) {", 4, eq_fn, name, name));
		} else if (sym->kind == v__ast__Kind_map && !v__ast__Type_is_ptr(typ)) {
			string eq_fn = v__gen__c__Gen_gen_map_equality_fn(g, typ);
			strings__Builder_writeln(&fn_builder, _STR("\t\tif (!%.*s\000_map_eq(*a.%.*s\000, *b.%.*s\000)) {", 4, eq_fn, name, name));
		} else if (sym->kind == v__ast__Kind_alias && !v__ast__Type_is_ptr(typ)) {
			string eq_fn = v__gen__c__Gen_gen_alias_equality_fn(g, typ);
			strings__Builder_writeln(&fn_builder, _STR("\t\tif (!%.*s\000_alias_eq(*a.%.*s\000, *b.%.*s\000)) {", 4, eq_fn, name, name));
		} else if (sym->kind == v__ast__Kind_function) {
			strings__Builder_writeln(&fn_builder, _STR("\t\tif (*((voidptr*)(*a.%.*s\000)) != *((voidptr*)(*b.%.*s\000))) {", 3, name, name));
		} else {
			strings__Builder_writeln(&fn_builder, _STR("\t\tif (*a.%.*s\000 != *b.%.*s\000) {", 3, name, name));
		}
		strings__Builder_writeln(&fn_builder, _SLIT("\t\t\treturn false;"));
		strings__Builder_writeln(&fn_builder, _SLIT("\t\t}"));
		strings__Builder_writeln(&fn_builder, _SLIT("\t\treturn true;"));
		strings__Builder_writeln(&fn_builder, _SLIT("\t}"));
	}
	strings__Builder_writeln(&fn_builder, _SLIT("\treturn false;"));
	strings__Builder_writeln(&fn_builder, _SLIT("}"));
	array_push(&g->auto_fn_definitions, _MOV((string[]){ string_clone(strings__Builder_str(&fn_builder)) }));
	// autofree_scope_vars(pos=2458 line_nr=57 scope.pos=209 scope.end_pos=2474)
	// var "g" var.pos=214 var.line_nr=7
	// var "left" var.pos=245 var.line_nr=7
	// var "ptr_typ" var.pos=270 var.line_nr=8
	// var "left_sym" var.pos=403 var.line_nr=13
	// var "info" var.pos=446 var.line_nr=14
	// var "fn_builder" var.pos=581 var.line_nr=16
	// af parent scope:
	// af parent scope:
	return ptr_typ;
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_gen_struct_equality_fn(v__gen__c__Gen* g, v__ast__Type left) {
bool v__gen__c__Gen_gen_struct_equality_fn_defer_0 = false;
	string ptr_typ = string_trim(v__gen__c__Gen_typ(g, left), _SLIT("*"));
	if ((Array_string_contains(g->struct_fn_definitions, ptr_typ))) {
		// autofree_scope_vars(pos=2615 line_nr=63 scope.pos=2612 scope.end_pos=2632)
		// af parent scope:
		// var "g" var.pos=2485 var.line_nr=60
		// var "left" var.pos=2515 var.line_nr=60
		// var "ptr_typ" var.pos=2540 var.line_nr=61
		// var "left_sym" var.pos=2671 var.line_nr=66
		// var "info" var.pos=2714 var.line_nr=67
		// var "fn_builder" var.pos=2847 var.line_nr=69
		// af parent scope:
		// af parent scope:
		return ptr_typ;
	}
	array_push(&g->struct_fn_definitions, _MOV((string[]){ string_clone(ptr_typ) }));
	v__ast__TypeSymbol* left_sym = v__ast__Table_get_type_symbol(g->table, left);
	v__ast__Struct info = v__ast__TypeSymbol_struct_info(left_sym);
	strings__Builder_writeln(&g->type_definitions, _STR("static bool %.*s\000_struct_eq(%.*s\000 a, %.*s\000 b); // auto", 4, ptr_typ, ptr_typ, ptr_typ));
	strings__Builder fn_builder = strings__new_builder(512);
	v__gen__c__Gen_gen_struct_equality_fn_defer_0 = true;
	strings__Builder_writeln(&fn_builder, _STR("static bool %.*s\000_struct_eq(%.*s\000 a, %.*s\000 b) {", 4, ptr_typ, ptr_typ, ptr_typ));
	if (v__ast__TypeSymbol_has_method(left_sym, _SLIT("=="))) {
		strings__Builder_writeln(&fn_builder, _STR("\treturn %.*s\000__eq(a, b);", 2, ptr_typ));
		strings__Builder_writeln(&fn_builder, _SLIT("}"));
		// Defer begin
		if (v__gen__c__Gen_gen_struct_equality_fn_defer_0 == true) {
			array_push(&g->auto_fn_definitions, _MOV((string[]){ string_clone(strings__Builder_str(&fn_builder)) }));
		}
		// Defer end
		// autofree_scope_vars(pos=3155 line_nr=79 scope.pos=3071 scope.end_pos=3172)
		// af parent scope:
		// var "g" var.pos=2485 var.line_nr=60
		// var "left" var.pos=2515 var.line_nr=60
		// var "ptr_typ" var.pos=2540 var.line_nr=61
		// var "left_sym" var.pos=2671 var.line_nr=66
		// var "info" var.pos=2714 var.line_nr=67
		// var "fn_builder" var.pos=2847 var.line_nr=69
		// af parent scope:
		// af parent scope:
		return ptr_typ;
	}
	// FOR IN array
	for (int _t2814 = 0; _t2814 < info.fields.len; ++_t2814) {
		v__ast__StructField field = ((v__ast__StructField*)info.fields.data)[_t2814];
		v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, field.typ);
		if (sym->kind == v__ast__Kind_string) {
			strings__Builder_writeln(&fn_builder, _STR("\tif (string_ne(a.%.*s\000, b.%.*s\000)) {", 3, field.name, field.name));
		} else if (sym->kind == v__ast__Kind_sum_type && !v__ast__Type_is_ptr(field.typ)) {
			string eq_fn = v__gen__c__Gen_gen_sumtype_equality_fn(g, field.typ);
			strings__Builder_writeln(&fn_builder, _STR("\tif (!%.*s\000_sumtype_eq(a.%.*s\000, b.%.*s\000)) {", 4, eq_fn, field.name, field.name));
		} else if (sym->kind == v__ast__Kind_struct_ && !v__ast__Type_is_ptr(field.typ)) {
			string eq_fn = v__gen__c__Gen_gen_struct_equality_fn(g, field.typ);
			strings__Builder_writeln(&fn_builder, _STR("\tif (!%.*s\000_struct_eq(a.%.*s\000, b.%.*s\000)) {", 4, eq_fn, field.name, field.name));
		} else if (sym->kind == v__ast__Kind_array && !v__ast__Type_is_ptr(field.typ)) {
			string eq_fn = v__gen__c__Gen_gen_array_equality_fn(g, field.typ);
			strings__Builder_writeln(&fn_builder, _STR("\tif (!%.*s\000_arr_eq(a.%.*s\000, b.%.*s\000)) {", 4, eq_fn, field.name, field.name));
		} else if (sym->kind == v__ast__Kind_array_fixed && !v__ast__Type_is_ptr(field.typ)) {
			string eq_fn = v__gen__c__Gen_gen_fixed_array_equality_fn(g, field.typ);
			strings__Builder_writeln(&fn_builder, _STR("\tif (!%.*s\000_arr_eq(a.%.*s\000, b.%.*s\000)) {", 4, eq_fn, field.name, field.name));
		} else if (sym->kind == v__ast__Kind_map && !v__ast__Type_is_ptr(field.typ)) {
			string eq_fn = v__gen__c__Gen_gen_map_equality_fn(g, field.typ);
			strings__Builder_writeln(&fn_builder, _STR("\tif (!%.*s\000_map_eq(a.%.*s\000, b.%.*s\000)) {", 4, eq_fn, field.name, field.name));
		} else if (sym->kind == v__ast__Kind_alias && !v__ast__Type_is_ptr(field.typ)) {
			string eq_fn = v__gen__c__Gen_gen_alias_equality_fn(g, field.typ);
			strings__Builder_writeln(&fn_builder, _STR("\tif (!%.*s\000_alias_eq(a.%.*s\000, b.%.*s\000)) {", 4, eq_fn, field.name, field.name));
		} else if (sym->kind == v__ast__Kind_function) {
			strings__Builder_writeln(&fn_builder, _STR("\tif (*((voidptr*)(a.%.*s\000)) != *((voidptr*)(b.%.*s\000))) {", 3, field.name, field.name));
		} else {
			strings__Builder_writeln(&fn_builder, _STR("\tif (a.%.*s\000 != b.%.*s\000) {", 3, field.name, field.name));
		}
		strings__Builder_writeln(&fn_builder, _SLIT("\t\treturn false;"));
		strings__Builder_writeln(&fn_builder, _SLIT("\t}"));
	}
	strings__Builder_writeln(&fn_builder, _SLIT("\treturn true;"));
	strings__Builder_writeln(&fn_builder, _SLIT("}"));
	// Defer begin
	if (v__gen__c__Gen_gen_struct_equality_fn_defer_0 == true) {
		array_push(&g->auto_fn_definitions, _MOV((string[]){ string_clone(strings__Builder_str(&fn_builder)) }));
	}
	// Defer end
	// autofree_scope_vars(pos=4824 line_nr=114 scope.pos=2480 scope.end_pos=4840)
	// var "g" var.pos=2485 var.line_nr=60
	// var "left" var.pos=2515 var.line_nr=60
	// var "ptr_typ" var.pos=2540 var.line_nr=61
	// var "left_sym" var.pos=2671 var.line_nr=66
	// var "info" var.pos=2714 var.line_nr=67
	// var "fn_builder" var.pos=2847 var.line_nr=69
	// af parent scope:
	// af parent scope:
	return ptr_typ;
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_gen_alias_equality_fn(v__gen__c__Gen* g, v__ast__Type left) {
	string ptr_typ = string_trim(v__gen__c__Gen_typ(g, left), _SLIT("*"));
	if ((Array_string_contains(g->alias_fn_definitions, ptr_typ))) {
		// autofree_scope_vars(pos=4979 line_nr=120 scope.pos=4976 scope.end_pos=4996)
		// af parent scope:
		// var "g" var.pos=4851 var.line_nr=117
		// var "left" var.pos=4880 var.line_nr=117
		// var "ptr_typ" var.pos=4905 var.line_nr=118
		// var "left_sym" var.pos=5034 var.line_nr=123
		// var "info" var.pos=5077 var.line_nr=124
		// var "fn_builder" var.pos=5213 var.line_nr=126
		// var "sym" var.pos=5334 var.line_nr=128
		// af parent scope:
		// af parent scope:
		return ptr_typ;
	}
	array_push(&g->alias_fn_definitions, _MOV((string[]){ string_clone(ptr_typ) }));
	v__ast__TypeSymbol* left_sym = v__ast__Table_get_type_symbol(g->table, left);
	v__ast__Alias info = /* as */ *(v__ast__Alias*)__as_cast((left_sym->info)._v__ast__Alias,(left_sym->info)._typ, 413) /*expected idx: 413, name: v.ast.Alias */ ;
	strings__Builder_writeln(&g->type_definitions, _STR("static bool %.*s\000_alias_eq(%.*s\000 a, %.*s\000 b); // auto", 4, ptr_typ, ptr_typ, ptr_typ));
	strings__Builder fn_builder = strings__new_builder(512);
	strings__Builder_writeln(&fn_builder, _STR("static bool %.*s\000_alias_eq(%.*s\000 a, %.*s\000 b) {", 4, ptr_typ, ptr_typ, ptr_typ));
	v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, info.parent_type);
	if (sym->kind == v__ast__Kind_string) {
		strings__Builder_writeln(&fn_builder, _SLIT("\tif (string_ne(a, b)) {"));
	} else if (sym->kind == v__ast__Kind_sum_type && !v__ast__Type_is_ptr(left)) {
		string eq_fn = v__gen__c__Gen_gen_sumtype_equality_fn(g, info.parent_type);
		strings__Builder_writeln(&fn_builder, _STR("\tif (!%.*s\000_sumtype_eq(a, b)) {", 2, eq_fn));
	} else if (sym->kind == v__ast__Kind_struct_ && !v__ast__Type_is_ptr(left)) {
		string eq_fn = v__gen__c__Gen_gen_struct_equality_fn(g, info.parent_type);
		strings__Builder_writeln(&fn_builder, _STR("\tif (!%.*s\000_struct_eq(a, b)) {", 2, eq_fn));
	} else if (sym->kind == v__ast__Kind_array && !v__ast__Type_is_ptr(left)) {
		string eq_fn = v__gen__c__Gen_gen_array_equality_fn(g, info.parent_type);
		strings__Builder_writeln(&fn_builder, _STR("\tif (!%.*s\000_arr_eq(a, b)) {", 2, eq_fn));
	} else if (sym->kind == v__ast__Kind_array_fixed && !v__ast__Type_is_ptr(left)) {
		string eq_fn = v__gen__c__Gen_gen_fixed_array_equality_fn(g, info.parent_type);
		strings__Builder_writeln(&fn_builder, _STR("\tif (!%.*s\000_arr_eq(a, b)) {", 2, eq_fn));
	} else if (sym->kind == v__ast__Kind_map && !v__ast__Type_is_ptr(left)) {
		string eq_fn = v__gen__c__Gen_gen_map_equality_fn(g, info.parent_type);
		strings__Builder_writeln(&fn_builder, _STR("\tif (!%.*s\000_map_eq(a, b)) {", 2, eq_fn));
	} else if (sym->kind == v__ast__Kind_function) {
		strings__Builder_writeln(&fn_builder, _SLIT("\tif (*((voidptr*)(a)) != *((voidptr*)(b))) {"));
	} else {
		strings__Builder_writeln(&fn_builder, _SLIT("\tif (a != b) {"));
	}
	strings__Builder_writeln(&fn_builder, _SLIT("\t\treturn false;"));
	strings__Builder_writeln(&fn_builder, _SLIT("\t}"));
	strings__Builder_writeln(&fn_builder, _SLIT("\treturn true;"));
	strings__Builder_writeln(&fn_builder, _SLIT("}"));
	array_push(&g->auto_fn_definitions, _MOV((string[]){ string_clone(strings__Builder_str(&fn_builder)) }));
	// autofree_scope_vars(pos=6608 line_nr=156 scope.pos=4846 scope.end_pos=6624)
	// var "g" var.pos=4851 var.line_nr=117
	// var "left" var.pos=4880 var.line_nr=117
	// var "ptr_typ" var.pos=4905 var.line_nr=118
	// var "left_sym" var.pos=5034 var.line_nr=123
	// var "info" var.pos=5077 var.line_nr=124
	// var "fn_builder" var.pos=5213 var.line_nr=126
	// var "sym" var.pos=5334 var.line_nr=128
	// af parent scope:
	// af parent scope:
	return ptr_typ;
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_gen_array_equality_fn(v__gen__c__Gen* g, v__ast__Type left) {
	string ptr_typ = string_trim(v__gen__c__Gen_typ(g, left), _SLIT("*"));
	if ((Array_string_contains(g->array_fn_definitions, ptr_typ))) {
		// autofree_scope_vars(pos=6763 line_nr=162 scope.pos=6760 scope.end_pos=6780)
		// af parent scope:
		// var "g" var.pos=6635 var.line_nr=159
		// var "left" var.pos=6664 var.line_nr=159
		// var "ptr_typ" var.pos=6689 var.line_nr=160
		// var "left_sym" var.pos=6818 var.line_nr=165
		// var "elem_typ" var.pos=6861 var.line_nr=166
		// var "ptr_elem_typ" var.pos=6906 var.line_nr=167
		// var "elem_sym" var.pos=6939 var.line_nr=168
		// var "fn_builder" var.pos=7084 var.line_nr=170
		// af parent scope:
		// af parent scope:
		return ptr_typ;
	}
	array_push(&g->array_fn_definitions, _MOV((string[]){ string_clone(ptr_typ) }));
	v__ast__TypeSymbol* left_sym = v__ast__Table_get_type_symbol(g->table, left);
	v__ast__Type elem_typ = v__ast__TypeSymbol_array_info(left_sym).elem_type;
	string ptr_elem_typ = v__gen__c__Gen_typ(g, elem_typ);
	v__ast__TypeSymbol* elem_sym = v__ast__Table_get_type_symbol(g->table, elem_typ);
	strings__Builder_writeln(&g->type_definitions, _STR("static bool %.*s\000_arr_eq(%.*s\000 a, %.*s\000 b); // auto", 4, ptr_typ, ptr_typ, ptr_typ));
	strings__Builder fn_builder = strings__new_builder(512);
	strings__Builder_writeln(&fn_builder, _STR("static bool %.*s\000_arr_eq(%.*s\000 a, %.*s\000 b) {", 4, ptr_typ, ptr_typ, ptr_typ));
	strings__Builder_writeln(&fn_builder, _SLIT("\tif (a.len != b.len) {"));
	strings__Builder_writeln(&fn_builder, _SLIT("\t\treturn false;"));
	strings__Builder_writeln(&fn_builder, _SLIT("\t}"));
	strings__Builder_writeln(&fn_builder, _SLIT("\tfor (int i = 0; i < a.len; ++i) {"));
	if (elem_sym->kind == v__ast__Kind_string) {
		strings__Builder_writeln(&fn_builder, _STR("\t\tif (string_ne(*((%.*s\000*)((byte*)a.data+(i*a.element_size))), *((%.*s\000*)((byte*)b.data+(i*b.element_size))))) {", 3, ptr_elem_typ, ptr_elem_typ));
	} else if (elem_sym->kind == v__ast__Kind_sum_type && !v__ast__Type_is_ptr(elem_typ)) {
		string eq_fn = v__gen__c__Gen_gen_sumtype_equality_fn(g, elem_typ);
		strings__Builder_writeln(&fn_builder, _STR("\t\tif (!%.*s\000_sumtype_eq(((%.*s\000*)a.data)[i], ((%.*s\000*)b.data)[i])) {", 4, eq_fn, ptr_elem_typ, ptr_elem_typ));
	} else if (elem_sym->kind == v__ast__Kind_struct_ && !v__ast__Type_is_ptr(elem_typ)) {
		string eq_fn = v__gen__c__Gen_gen_struct_equality_fn(g, elem_typ);
		strings__Builder_writeln(&fn_builder, _STR("\t\tif (!%.*s\000_struct_eq(((%.*s\000*)a.data)[i], ((%.*s\000*)b.data)[i])) {", 4, eq_fn, ptr_elem_typ, ptr_elem_typ));
	} else if (elem_sym->kind == v__ast__Kind_array && !v__ast__Type_is_ptr(elem_typ)) {
		string eq_fn = v__gen__c__Gen_gen_array_equality_fn(g, elem_typ);
		strings__Builder_writeln(&fn_builder, _STR("\t\tif (!%.*s\000_arr_eq(((%.*s\000*)a.data)[i], ((%.*s\000*)b.data)[i])) {", 4, eq_fn, ptr_elem_typ, ptr_elem_typ));
	} else if (elem_sym->kind == v__ast__Kind_array_fixed && !v__ast__Type_is_ptr(elem_typ)) {
		string eq_fn = v__gen__c__Gen_gen_fixed_array_equality_fn(g, elem_typ);
		strings__Builder_writeln(&fn_builder, _STR("\t\tif (!%.*s\000_arr_eq(((%.*s\000*)a.data)[i], ((%.*s\000*)b.data)[i])) {", 4, eq_fn, ptr_elem_typ, ptr_elem_typ));
	} else if (elem_sym->kind == v__ast__Kind_map && !v__ast__Type_is_ptr(elem_typ)) {
		string eq_fn = v__gen__c__Gen_gen_map_equality_fn(g, elem_typ);
		strings__Builder_writeln(&fn_builder, _STR("\t\tif (!%.*s\000_map_eq(((%.*s\000*)a.data)[i], ((%.*s\000*)b.data)[i])) {", 4, eq_fn, ptr_elem_typ, ptr_elem_typ));
	} else if (elem_sym->kind == v__ast__Kind_alias && !v__ast__Type_is_ptr(elem_typ)) {
		string eq_fn = v__gen__c__Gen_gen_alias_equality_fn(g, elem_typ);
		strings__Builder_writeln(&fn_builder, _STR("\t\tif (!%.*s\000_alias_eq(((%.*s\000*)a.data)[i], ((%.*s\000*)b.data)[i])) {", 4, eq_fn, ptr_elem_typ, ptr_elem_typ));
	} else if (elem_sym->kind == v__ast__Kind_function) {
		strings__Builder_writeln(&fn_builder, _SLIT("\t\tif (*((voidptr*)((byte*)a.data+(i*a.element_size))) != *((voidptr*)((byte*)b.data+(i*b.element_size)))) {"));
	} else {
		strings__Builder_writeln(&fn_builder, _STR("\t\tif (*((%.*s\000*)((byte*)a.data+(i*a.element_size))) != *((%.*s\000*)((byte*)b.data+(i*b.element_size)))) {", 3, ptr_elem_typ, ptr_elem_typ));
	}
	strings__Builder_writeln(&fn_builder, _SLIT("\t\t\treturn false;"));
	strings__Builder_writeln(&fn_builder, _SLIT("\t\t}"));
	strings__Builder_writeln(&fn_builder, _SLIT("\t}"));
	strings__Builder_writeln(&fn_builder, _SLIT("\treturn true;"));
	strings__Builder_writeln(&fn_builder, _SLIT("}"));
	array_push(&g->auto_fn_definitions, _MOV((string[]){ string_clone(strings__Builder_str(&fn_builder)) }));
	// autofree_scope_vars(pos=9462 line_nr=208 scope.pos=6630 scope.end_pos=9478)
	// var "g" var.pos=6635 var.line_nr=159
	// var "left" var.pos=6664 var.line_nr=159
	// var "ptr_typ" var.pos=6689 var.line_nr=160
	// var "left_sym" var.pos=6818 var.line_nr=165
	// var "elem_typ" var.pos=6861 var.line_nr=166
	// var "ptr_elem_typ" var.pos=6906 var.line_nr=167
	// var "elem_sym" var.pos=6939 var.line_nr=168
	// var "fn_builder" var.pos=7084 var.line_nr=170
	// af parent scope:
	// af parent scope:
	return ptr_typ;
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_gen_fixed_array_equality_fn(v__gen__c__Gen* g, v__ast__Type left) {
	string ptr_typ = string_trim(v__gen__c__Gen_typ(g, left), _SLIT("*"));
	if ((Array_string_contains(g->array_fn_definitions, ptr_typ))) {
		// autofree_scope_vars(pos=9623 line_nr=214 scope.pos=9620 scope.end_pos=9640)
		// af parent scope:
		// var "g" var.pos=9489 var.line_nr=211
		// var "left" var.pos=9524 var.line_nr=211
		// var "ptr_typ" var.pos=9549 var.line_nr=212
		// var "left_sym" var.pos=9678 var.line_nr=217
		// var "elem_info" var.pos=9721 var.line_nr=218
		// var "elem_typ" var.pos=9763 var.line_nr=219
		// var "size" var.pos=9796 var.line_nr=220
		// var "elem_sym" var.pos=9820 var.line_nr=221
		// var "fn_builder" var.pos=9965 var.line_nr=223
		// af parent scope:
		// af parent scope:
		return ptr_typ;
	}
	array_push(&g->array_fn_definitions, _MOV((string[]){ string_clone(ptr_typ) }));
	v__ast__TypeSymbol* left_sym = v__ast__Table_get_type_symbol(g->table, left);
	v__ast__ArrayFixed elem_info = v__ast__TypeSymbol_array_fixed_info(left_sym);
	v__ast__Type elem_typ = elem_info.elem_type;
	int size = elem_info.size;
	v__ast__TypeSymbol* elem_sym = v__ast__Table_get_type_symbol(g->table, elem_typ);
	strings__Builder_writeln(&g->type_definitions, _STR("static bool %.*s\000_arr_eq(%.*s\000 a, %.*s\000 b); // auto", 4, ptr_typ, ptr_typ, ptr_typ));
	strings__Builder fn_builder = strings__new_builder(512);
	strings__Builder_writeln(&fn_builder, _STR("static bool %.*s\000_arr_eq(%.*s\000 a, %.*s\000 b) {", 4, ptr_typ, ptr_typ, ptr_typ));
	strings__Builder_writeln(&fn_builder, _STR("\tfor (int i = 0; i < %"PRId32"\000; ++i) {", 2, size));
	if (elem_sym->kind == v__ast__Kind_string) {
		strings__Builder_writeln(&fn_builder, _SLIT("\t\tif (string_ne(a[i], b[i])) {"));
	} else if (elem_sym->kind == v__ast__Kind_sum_type && !v__ast__Type_is_ptr(elem_typ)) {
		string eq_fn = v__gen__c__Gen_gen_sumtype_equality_fn(g, elem_typ);
		strings__Builder_writeln(&fn_builder, _STR("\t\tif (!%.*s\000_sumtype_eq(a[i], b[i])) {", 2, eq_fn));
	} else if (elem_sym->kind == v__ast__Kind_struct_ && !v__ast__Type_is_ptr(elem_typ)) {
		string eq_fn = v__gen__c__Gen_gen_struct_equality_fn(g, elem_typ);
		strings__Builder_writeln(&fn_builder, _STR("\t\tif (!%.*s\000_struct_eq(a[i], b[i])) {", 2, eq_fn));
	} else if (elem_sym->kind == v__ast__Kind_array && !v__ast__Type_is_ptr(elem_typ)) {
		string eq_fn = v__gen__c__Gen_gen_array_equality_fn(g, elem_typ);
		strings__Builder_writeln(&fn_builder, _STR("\t\tif (!%.*s\000_arr_eq(a[i], b[i])) {", 2, eq_fn));
	} else if (elem_sym->kind == v__ast__Kind_array_fixed && !v__ast__Type_is_ptr(elem_typ)) {
		string eq_fn = v__gen__c__Gen_gen_fixed_array_equality_fn(g, elem_typ);
		strings__Builder_writeln(&fn_builder, _STR("\t\tif (!%.*s\000_arr_eq(a[i], b[i])) {", 2, eq_fn));
	} else if (elem_sym->kind == v__ast__Kind_map && !v__ast__Type_is_ptr(elem_typ)) {
		string eq_fn = v__gen__c__Gen_gen_map_equality_fn(g, elem_typ);
		strings__Builder_writeln(&fn_builder, _STR("\t\tif (!%.*s\000_map_eq(a[i], b[i])) {", 2, eq_fn));
	} else if (elem_sym->kind == v__ast__Kind_alias && !v__ast__Type_is_ptr(elem_typ)) {
		string eq_fn = v__gen__c__Gen_gen_alias_equality_fn(g, elem_typ);
		strings__Builder_writeln(&fn_builder, _STR("\t\tif (!%.*s\000_alias_eq(a[i], b[i])) {", 2, eq_fn));
	} else if (elem_sym->kind == v__ast__Kind_function) {
		strings__Builder_writeln(&fn_builder, _SLIT("\t\tif (a[i] != b[i]) {"));
	} else {
		strings__Builder_writeln(&fn_builder, _SLIT("\t\tif (a[i] != b[i]) {"));
	}
	strings__Builder_writeln(&fn_builder, _SLIT("\t\t\treturn false;"));
	strings__Builder_writeln(&fn_builder, _SLIT("\t\t}"));
	strings__Builder_writeln(&fn_builder, _SLIT("\t}"));
	strings__Builder_writeln(&fn_builder, _SLIT("\treturn true;"));
	strings__Builder_writeln(&fn_builder, _SLIT("}"));
	array_push(&g->auto_fn_definitions, _MOV((string[]){ string_clone(strings__Builder_str(&fn_builder)) }));
	// autofree_scope_vars(pos=11676 line_nr=258 scope.pos=9484 scope.end_pos=11692)
	// var "g" var.pos=9489 var.line_nr=211
	// var "left" var.pos=9524 var.line_nr=211
	// var "ptr_typ" var.pos=9549 var.line_nr=212
	// var "left_sym" var.pos=9678 var.line_nr=217
	// var "elem_info" var.pos=9721 var.line_nr=218
	// var "elem_typ" var.pos=9763 var.line_nr=219
	// var "size" var.pos=9796 var.line_nr=220
	// var "elem_sym" var.pos=9820 var.line_nr=221
	// var "fn_builder" var.pos=9965 var.line_nr=223
	// af parent scope:
	// af parent scope:
	return ptr_typ;
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_gen_map_equality_fn(v__gen__c__Gen* g, v__ast__Type left) {
	string ptr_typ = string_trim(v__gen__c__Gen_typ(g, left), _SLIT("*"));
	if ((Array_string_contains(g->map_fn_definitions, ptr_typ))) {
		// autofree_scope_vars(pos=11827 line_nr=264 scope.pos=11824 scope.end_pos=11844)
		// af parent scope:
		// var "g" var.pos=11703 var.line_nr=261
		// var "left" var.pos=11730 var.line_nr=261
		// var "ptr_typ" var.pos=11755 var.line_nr=262
		// var "left_sym" var.pos=11880 var.line_nr=267
		// var "value_typ" var.pos=11923 var.line_nr=268
		// var "ptr_value_typ" var.pos=11968 var.line_nr=269
		// var "fn_builder" var.pos=12101 var.line_nr=271
		// var "kind" var.pos=12625 var.line_nr=280
		// af parent scope:
		// af parent scope:
		return ptr_typ;
	}
	array_push(&g->map_fn_definitions, _MOV((string[]){ string_clone(ptr_typ) }));
	v__ast__TypeSymbol* left_sym = v__ast__Table_get_type_symbol(g->table, left);
	v__ast__Type value_typ = v__ast__TypeSymbol_map_info(left_sym).value_type;
	string ptr_value_typ = v__gen__c__Gen_typ(g, value_typ);
	strings__Builder_writeln(&g->type_definitions, _STR("static bool %.*s\000_map_eq(%.*s\000 a, %.*s\000 b); // auto", 4, ptr_typ, ptr_typ, ptr_typ));
	strings__Builder fn_builder = strings__new_builder(512);
	strings__Builder_writeln(&fn_builder, _STR("static bool %.*s\000_map_eq(%.*s\000 a, %.*s\000 b) {", 4, ptr_typ, ptr_typ, ptr_typ));
	strings__Builder_writeln(&fn_builder, _SLIT("\tif (a.len != b.len) {"));
	strings__Builder_writeln(&fn_builder, _SLIT("\t\treturn false;"));
	strings__Builder_writeln(&fn_builder, _SLIT("\t}"));
	strings__Builder_writeln(&fn_builder, _SLIT("\tfor (int i = 0; i < a.key_values.len; ++i) {"));
	strings__Builder_writeln(&fn_builder, _SLIT("\t\tif (!DenseArray_has_index(&a.key_values, i)) continue;"));
	strings__Builder_writeln(&fn_builder, _SLIT("\t\tvoidptr k = DenseArray_key(&a.key_values, i);"));
	strings__Builder_writeln(&fn_builder, _SLIT("\t\tif (!map_exists(&b, k)) return false;"));
	v__ast__Kind kind = v__ast__Table_type_kind(g->table, value_typ);
	if (kind == v__ast__Kind_function) {
		v__ast__TypeSymbol* value_sym = v__ast__Table_get_type_symbol(g->table, value_typ);
		v__ast__FnType func = /* as */ *(v__ast__FnType*)__as_cast((value_sym->info)._v__ast__FnType,(value_sym->info)._typ, 418) /*expected idx: 418, name: v.ast.FnType */ ;
		string ret_styp = v__gen__c__Gen_typ(g, func.func.return_type);
		strings__Builder_write_string(&fn_builder, _STR("\t\t%.*s\000 (*v) (", 2, ret_styp));
		int arg_len = func.func.params.len;
		// FOR IN array
		for (int j = 0; j < func.func.params.len; ++j) {
			v__ast__Param arg = ((v__ast__Param*)func.func.params.data)[j];
			string arg_styp = v__gen__c__Gen_typ(g, arg.typ);
			strings__Builder_write_string(&fn_builder, _STR("%.*s\000 %.*s", 2, arg_styp, arg.name));
			if (j < arg_len - 1) {
				strings__Builder_write_string(&fn_builder, _SLIT(", "));
			}
		}
		strings__Builder_writeln(&fn_builder, _SLIT(") = *(voidptr*)map_get(&a, k, &(voidptr[]){ 0 });"));
	} else {
		strings__Builder_writeln(&fn_builder, _STR("\t\t%.*s\000 v = *(%.*s\000*)map_get(&a, k, &(%.*s\000[]){ 0 });", 4, ptr_value_typ, ptr_value_typ, ptr_value_typ));
	}

	if (kind == (v__ast__Kind_string)) {
		strings__Builder_writeln(&fn_builder, _SLIT("\t\tif (!fast_string_eq(*(string*)map_get(&b, k, &(string[]){_SLIT(\"\")}), v)) {"));
	}
	else if (kind == (v__ast__Kind_sum_type)) {
		string eq_fn = v__gen__c__Gen_gen_sumtype_equality_fn(g, value_typ);
		strings__Builder_writeln(&fn_builder, _STR("\t\tif (!%.*s\000_sumtype_eq(*(%.*s\000*)map_get(&b, k, &(%.*s\000[]){ 0 }), v)) {", 4, eq_fn, ptr_value_typ, ptr_value_typ));
	}
	else if (kind == (v__ast__Kind_struct_)) {
		string eq_fn = v__gen__c__Gen_gen_struct_equality_fn(g, value_typ);
		strings__Builder_writeln(&fn_builder, _STR("\t\tif (!%.*s\000_struct_eq(*(%.*s\000*)map_get(&b, k, &(%.*s\000[]){ 0 }), v)) {", 4, eq_fn, ptr_value_typ, ptr_value_typ));
	}
	else if (kind == (v__ast__Kind_array)) {
		string eq_fn = v__gen__c__Gen_gen_array_equality_fn(g, value_typ);
		strings__Builder_writeln(&fn_builder, _STR("\t\tif (!%.*s\000_arr_eq(*(%.*s\000*)map_get(&b, k, &(%.*s\000[]){ 0 }), v)) {", 4, eq_fn, ptr_value_typ, ptr_value_typ));
	}
	else if (kind == (v__ast__Kind_array_fixed)) {
		string eq_fn = v__gen__c__Gen_gen_fixed_array_equality_fn(g, value_typ);
		strings__Builder_writeln(&fn_builder, _STR("\t\tif (!%.*s\000_arr_eq(*(%.*s\000*)map_get(&b, k, &(%.*s\000[]){ 0 }), v)) {", 4, eq_fn, ptr_value_typ, ptr_value_typ));
	}
	else if (kind == (v__ast__Kind_map)) {
		string eq_fn = v__gen__c__Gen_gen_map_equality_fn(g, value_typ);
		strings__Builder_writeln(&fn_builder, _STR("\t\tif (!%.*s\000_map_eq(*(%.*s\000*)map_get(&b, k, &(%.*s\000[]){ 0 }), v)) {", 4, eq_fn, ptr_value_typ, ptr_value_typ));
	}
	else if (kind == (v__ast__Kind_alias)) {
		string eq_fn = v__gen__c__Gen_gen_alias_equality_fn(g, value_typ);
		strings__Builder_writeln(&fn_builder, _STR("\t\tif (!%.*s\000_alias_eq(*(%.*s\000*)map_get(&b, k, &(%.*s\000[]){ 0 }), v)) {", 4, eq_fn, ptr_value_typ, ptr_value_typ));
	}
	else if (kind == (v__ast__Kind_function)) {
		strings__Builder_writeln(&fn_builder, _SLIT("\t\tif (*(voidptr*)map_get(&b, k, &(voidptr[]){ 0 }) != v) {"));
	}
	else {
		println(v__ast__Kind_str(kind));
		strings__Builder_writeln(&fn_builder, _STR("\t\tif (*(%.*s\000*)map_get(&b, k, &(%.*s\000[]){ 0 }) != v) {", 3, ptr_value_typ, ptr_value_typ));
	};
	strings__Builder_writeln(&fn_builder, _SLIT("\t\t\treturn false;"));
	strings__Builder_writeln(&fn_builder, _SLIT("\t\t}"));
	strings__Builder_writeln(&fn_builder, _SLIT("\t}"));
	strings__Builder_writeln(&fn_builder, _SLIT("\treturn true;"));
	strings__Builder_writeln(&fn_builder, _SLIT("}"));
	array_push(&g->auto_fn_definitions, _MOV((string[]){ string_clone(strings__Builder_str(&fn_builder)) }));
	// autofree_scope_vars(pos=14948 line_nr=340 scope.pos=11698 scope.end_pos=14964)
	// var "g" var.pos=11703 var.line_nr=261
	// var "left" var.pos=11730 var.line_nr=261
	// var "ptr_typ" var.pos=11755 var.line_nr=262
	// var "left_sym" var.pos=11880 var.line_nr=267
	// var "value_typ" var.pos=11923 var.line_nr=268
	// var "ptr_value_typ" var.pos=11968 var.line_nr=269
	// var "fn_builder" var.pos=12101 var.line_nr=271
	// var "kind" var.pos=12625 var.line_nr=280
	// af parent scope:
	// af parent scope:
	return ptr_typ;
}

VV_LOCAL_SYMBOL bool v__gen__c__should_use_indent_func(v__ast__Kind kind) {
	 bool _t2824 = (kind == v__ast__Kind_struct_ || kind == v__ast__Kind_alias || kind == v__ast__Kind_array || kind == v__ast__Kind_array_fixed || kind == v__ast__Kind_map || kind == v__ast__Kind_sum_type || kind == v__ast__Kind_interface_);
	// autofree_scope_vars(pos=253 line_nr=8 scope.pos=208 scope.end_pos=340)
	// var "kind" var.pos=231 var.line_nr=7
	// af parent scope:
	// af parent scope:
	return _t2824;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_default(v__gen__c__Gen* g, v__ast__TypeSymbol sym, string styp, string str_fn_name) {
	string convertor = _SLIT("");
	string typename_ = _SLIT("");
	if ((Array_int_contains(_const_v__ast__integer_type_idxs, sym.parent_idx))) {
		convertor = _SLIT("int");
		typename_ = _SLIT("int");
	} else if (sym.parent_idx == _const_v__ast__f32_type_idx) {
		convertor = _SLIT("float");
		typename_ = _SLIT("f32");
	} else if (sym.parent_idx == _const_v__ast__f64_type_idx) {
		convertor = _SLIT("double");
		typename_ = _SLIT("f64");
	} else if (sym.parent_idx == _const_v__ast__bool_type_idx) {
		convertor = _SLIT("bool");
		typename_ = _SLIT("bool");
	} else {
		v__gen__c__verror(_STR("could not generate string method for type '%.*s\000'", 2, styp));
	}
	strings__Builder_writeln(&g->type_definitions, _STR("string %.*s\000(%.*s\000 it); // auto", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("string %.*s\000(%.*s\000 it) {", 3, str_fn_name, styp));
	if (string_eq(convertor, _SLIT("bool"))) {
		strings__Builder_writeln(&g->auto_str_funcs, _STR("\tstring tmp1 = string_add(_SLIT(\"%.*s\000(\"), (%.*s\000)it ? _SLIT(\"true\") : _SLIT(\"false\"));", 3, styp, convertor));
	} else {
		strings__Builder_writeln(&g->auto_str_funcs, _STR("\tstring tmp1 = string_add(_SLIT(\"%.*s\000(\"), tos3(%.*s\000_str((%.*s\000)it).str));", 4, styp, typename_, convertor));
	}
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tstring tmp2 = string_add(tmp1, _SLIT(\")\"));"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tstring_free(&tmp1);"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\treturn tmp2;"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("}"));
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_type_to_fmt(v__gen__c__Gen* g, v__ast__Type typ) {
	v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, typ);
	if (v__ast__Type_is_ptr(typ) && (v__ast__Type_is_int_valptr(typ) || v__ast__Type_is_float_valptr(typ))) {
		 string _t2825 = _SLIT("%.*s\\000");
		// autofree_scope_vars(pos=1683 line_nr=45 scope.pos=1680 scope.end_pos=1704)
		// af parent scope:
		// var "g" var.pos=1533 var.line_nr=42
		// var "typ" var.pos=1553 var.line_nr=42
		// var "sym" var.pos=1577 var.line_nr=43
		// af parent scope:
		// af parent scope:
		return _t2825;
	} else if ((sym->kind == v__ast__Kind_struct_ || sym->kind == v__ast__Kind_array || sym->kind == v__ast__Kind_array_fixed || sym->kind == v__ast__Kind_map || sym->kind == v__ast__Kind_bool || sym->kind == v__ast__Kind_enum_ || sym->kind == v__ast__Kind_interface_ || sym->kind == v__ast__Kind_sum_type || sym->kind == v__ast__Kind_function || sym->kind == v__ast__Kind_alias)) {
		 string _t2826 = _SLIT("%.*s\\000");
		// autofree_scope_vars(pos=1828 line_nr=48 scope.pos=1825 scope.end_pos=1849)
		// af parent scope:
		// var "g" var.pos=1533 var.line_nr=42
		// var "typ" var.pos=1553 var.line_nr=42
		// var "sym" var.pos=1577 var.line_nr=43
		// af parent scope:
		// af parent scope:
		return _t2826;
	} else if (sym->kind == v__ast__Kind_string) {
		 string _t2827 = _SLIT("'%.*s\\000'");
		// autofree_scope_vars(pos=1882 line_nr=50 scope.pos=1879 scope.end_pos=1905)
		// af parent scope:
		// var "g" var.pos=1533 var.line_nr=42
		// var "typ" var.pos=1553 var.line_nr=42
		// var "sym" var.pos=1577 var.line_nr=43
		// af parent scope:
		// af parent scope:
		return _t2827;
	} else if ((sym->kind == v__ast__Kind_f32 || sym->kind == v__ast__Kind_f64)) {
		 string _t2828 = _SLIT("%g\\000");
		// autofree_scope_vars(pos=1943 line_nr=52 scope.pos=1940 scope.end_pos=2000)
		// af parent scope:
		// var "g" var.pos=1533 var.line_nr=42
		// var "typ" var.pos=1553 var.line_nr=42
		// var "sym" var.pos=1577 var.line_nr=43
		// af parent scope:
		// af parent scope:
		return _t2828;
	} else if (sym->kind == v__ast__Kind_u32) {
		 string _t2829 = _SLIT("%u\\000");
		// autofree_scope_vars(pos=2030 line_nr=54 scope.pos=2027 scope.end_pos=2049)
		// af parent scope:
		// var "g" var.pos=1533 var.line_nr=42
		// var "typ" var.pos=1553 var.line_nr=42
		// var "sym" var.pos=1577 var.line_nr=43
		// af parent scope:
		// af parent scope:
		return _t2829;
	} else if (sym->kind == v__ast__Kind_u64) {
		 string _t2830 = _SLIT("%llu\\000");
		// autofree_scope_vars(pos=2079 line_nr=56 scope.pos=2076 scope.end_pos=2100)
		// af parent scope:
		// var "g" var.pos=1533 var.line_nr=42
		// var "typ" var.pos=1553 var.line_nr=42
		// var "sym" var.pos=1577 var.line_nr=43
		// af parent scope:
		// af parent scope:
		return _t2830;
	} else if (sym->kind == v__ast__Kind_i64) {
		 string _t2831 = _SLIT("%lld\\000");
		// autofree_scope_vars(pos=2130 line_nr=58 scope.pos=2127 scope.end_pos=2151)
		// af parent scope:
		// var "g" var.pos=1533 var.line_nr=42
		// var "typ" var.pos=1553 var.line_nr=42
		// var "sym" var.pos=1577 var.line_nr=43
		// af parent scope:
		// af parent scope:
		return _t2831;
	}
	 string _t2832 = _SLIT("%d\\000");
	// autofree_scope_vars(pos=2153 line_nr=60 scope.pos=1532 scope.end_pos=2171)
	// var "g" var.pos=1533 var.line_nr=42
	// var "typ" var.pos=1553 var.line_nr=42
	// var "sym" var.pos=1577 var.line_nr=43
	// af parent scope:
	// af parent scope:
	return _t2832;
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_gen_str_for_type(v__gen__c__Gen* g, v__ast__Type typ) {
	string styp = string_replace(v__gen__c__Gen_typ(g, typ), _SLIT("*"), _SLIT(""));
	v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, v__gen__c__Gen_unwrap_generic(g, typ));
	string str_fn_name = v__gen__c__styp_to_str_fn_name(styp);
	if ((sym->info)._typ == 413 /* v.ast.Alias */) {
		if ((*sym->info._v__ast__Alias).is_import) {
			sym = v__ast__Table_get_type_symbol(g->table, (*sym->info._v__ast__Alias).parent_type);
			str_fn_name = v__gen__c__styp_to_str_fn_name(sym->name);
		}
	}
	multi_return_bool_bool_int mr_2595 = v__ast__TypeSymbol_str_method_info(sym);
	bool sym_has_str_method = mr_2595.arg0;
	bool str_method_expects_ptr = mr_2595.arg1;
	int str_nr_args = mr_2595.arg2;
	string already_generated_key = _STR("%.*s\000:%.*s", 2, styp, str_fn_name);
	if (!sym_has_str_method && !(Array_string_contains(g->str_types, already_generated_key)) && !v__ast__Type_has_flag(typ, v__ast__TypeFlag_optional)) {
		array_push(&g->str_types, _MOV((string[]){ string_clone(already_generated_key) }));
		if (sym->info._typ == 413 /* v.ast.Alias */) {
			if ((*sym->info._v__ast__Alias).is_import) {
				v__gen__c__Gen_gen_str_default(g, *sym, styp, str_fn_name);
			} else {
				v__gen__c__Gen_gen_str_for_alias(g, (*sym->info._v__ast__Alias), styp, str_fn_name);
			}
		}
		else if (sym->info._typ == 395 /* v.ast.Array */) {
			v__gen__c__Gen_gen_str_for_array(g, (*sym->info._v__ast__Array), styp, str_fn_name);
		}
		else if (sym->info._typ == 416 /* v.ast.ArrayFixed */) {
			v__gen__c__Gen_gen_str_for_array_fixed(g, (*sym->info._v__ast__ArrayFixed), styp, str_fn_name);
		}
		else if (sym->info._typ == 420 /* v.ast.Enum */) {
			v__gen__c__Gen_gen_str_for_enum(g, (*sym->info._v__ast__Enum), styp, str_fn_name);
		}
		else if (sym->info._typ == 418 /* v.ast.FnType */) {
			v__gen__c__Gen_gen_str_for_fn_type(g, (*sym->info._v__ast__FnType), styp, str_fn_name);
		}
		else if (sym->info._typ == 409 /* v.ast.Struct */) {
			v__gen__c__Gen_gen_str_for_struct(g, (*sym->info._v__ast__Struct), styp, str_fn_name);
		}
		else if (sym->info._typ == 396 /* v.ast.Map */) {
			v__gen__c__Gen_gen_str_for_map(g, (*sym->info._v__ast__Map), styp, str_fn_name);
		}
		else if (sym->info._typ == 417 /* v.ast.MultiReturn */) {
			v__gen__c__Gen_gen_str_for_multi_return(g, (*sym->info._v__ast__MultiReturn), styp, str_fn_name);
		}
		else if (sym->info._typ == 411 /* v.ast.SumType */) {
			v__gen__c__Gen_gen_str_for_union_sum_type(g, (*sym->info._v__ast__SumType), styp, str_fn_name);
		}
		else if (sym->info._typ == 410 /* v.ast.Interface */) {
			v__gen__c__Gen_gen_str_for_interface(g, (*sym->info._v__ast__Interface), styp, str_fn_name);
		}
		else {
			v__gen__c__verror(_STR("could not generate string method %.*s\000 for type '%.*s\000'", 3, str_fn_name, styp));
		};
	}
	if (v__ast__Type_has_flag(typ, v__ast__TypeFlag_optional)) {
		string option_already_generated_key = _STR("option_%.*s", 1, already_generated_key);
		if (!(Array_string_contains(g->str_types, option_already_generated_key))) {
			v__gen__c__Gen_gen_str_for_option(g, typ, styp, str_fn_name);
			array_push(&g->str_types, _MOV((string[]){ string_clone(option_already_generated_key) }));
		}
		// autofree_scope_vars(pos=4258 line_nr=126 scope.pos=4038 scope.end_pos=4279)
		// var "option_already_generated_key" var.pos=4042 var.line_nr=121
		// af parent scope:
		// var "g" var.pos=2182 var.line_nr=63
		// var "typ" var.pos=2206 var.line_nr=63
		// var "styp" var.pos=2230 var.line_nr=64
		// var "sym" var.pos=2271 var.line_nr=65
		// var "str_fn_name" var.pos=2330 var.line_nr=66
		// var "sym_has_str_method" var.pos=2539 var.line_nr=73
		// var "str_method_expects_ptr" var.pos=2559 var.line_nr=73
		// var "str_nr_args" var.pos=2583 var.line_nr=73
		// var "already_generated_key" var.pos=2621 var.line_nr=74
		// af parent scope:
		// af parent scope:
		return str_fn_name;
	}
	// autofree_scope_vars(pos=4281 line_nr=128 scope.pos=2177 scope.end_pos=4301)
	// var "g" var.pos=2182 var.line_nr=63
	// var "typ" var.pos=2206 var.line_nr=63
	// var "styp" var.pos=2230 var.line_nr=64
	// var "sym" var.pos=2271 var.line_nr=65
	// var "str_fn_name" var.pos=2330 var.line_nr=66
	// var "sym_has_str_method" var.pos=2539 var.line_nr=73
	// var "str_method_expects_ptr" var.pos=2559 var.line_nr=73
	// var "str_nr_args" var.pos=2583 var.line_nr=73
	// var "already_generated_key" var.pos=2621 var.line_nr=74
	// af parent scope:
	// af parent scope:
	return str_fn_name;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_option(v__gen__c__Gen* g, v__ast__Type typ, string styp, string str_fn_name) {
	v__ast__Type parent_type = v__ast__Type_clear_flag(typ, v__ast__TypeFlag_optional);
	v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, parent_type);
	multi_return_bool_bool_int mr_4500 = v__ast__TypeSymbol_str_method_info(sym);
	bool sym_has_str_method = mr_4500.arg0;
	string parent_str_fn_name = v__gen__c__styp_to_str_fn_name(sym->cname);
	if (!sym_has_str_method) {
		parent_str_fn_name = v__gen__c__Gen_gen_str_for_type(g, parent_type);
	}
	strings__Builder_writeln(&g->type_definitions, _STR("string %.*s\000(%.*s\000 it); // auto", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("string %.*s\000(%.*s\000 it) { return indent_%.*s\000(it, 0); }", 4, str_fn_name, styp, str_fn_name));
	strings__Builder_writeln(&g->type_definitions, _STR("string indent_%.*s\000(%.*s\000 it, int indent_count); // auto", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("string indent_%.*s\000(%.*s\000 it, int indent_count) {", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tstring res;"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tif (it.state == 0) {"));
	if (sym->kind == v__ast__Kind_string) {
		strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tres = _STR(\"\'%%.*s\\000\'\", 2, %.*s\000(*(%.*s\000*)it.data));", 3, parent_str_fn_name, sym->cname));
	} else if (v__gen__c__should_use_indent_func(sym->kind) && !sym_has_str_method) {
		strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tres = indent_%.*s\000(*(%.*s\000*)it.data, indent_count);", 3, parent_str_fn_name, sym->cname));
	} else {
		strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tres = %.*s\000(*(%.*s\000*)it.data);", 3, parent_str_fn_name, sym->cname));
	}
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t} else {"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t\tres = _STR(\"error: %.*s\\000\", 2, IError_str(it.err));"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t}"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\treturn _STR(\"Option(%.*s\\000)\", 2, res);"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("}"));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_alias(v__gen__c__Gen* g, v__ast__Alias info, string styp, string str_fn_name) {
	v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, info.parent_type);
	multi_return_bool_bool_int mr_5962 = v__ast__TypeSymbol_str_method_info(sym);
	bool sym_has_str_method = mr_5962.arg0;
	string parent_str_fn_name = v__gen__c__styp_to_str_fn_name(string_replace(sym->name, _SLIT("."), _SLIT("__")));
	if (!sym_has_str_method) {
		parent_str_fn_name = v__gen__c__Gen_gen_str_for_type(g, info.parent_type);
	}
	string clean_type_v_type_name = v__util__strip_main_name(string_replace(styp, _SLIT("__"), _SLIT(".")));
	strings__Builder_writeln(&g->type_definitions, _STR("static string %.*s\000(%.*s\000 it); // auto", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("static string %.*s\000(%.*s\000 it) { return indent_%.*s\000(it, 0); }", 4, str_fn_name, styp, str_fn_name));
	strings__Builder_writeln(&g->type_definitions, _STR("static string indent_%.*s\000(%.*s\000 it, int indent_count); // auto", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("static string indent_%.*s\000(%.*s\000 it, int indent_count) {", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tstring indents = _SLIT(\"\");"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tfor (int i = 0; i < indent_count; ++i) {"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t\tindents = string_add(indents, _SLIT(\"    \"));"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t}"));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("\treturn _STR(\"%%.*s\\000%.*s\000(%%.*s\\000)\", 3, indents, %.*s\000(it));", 3, clean_type_v_type_name, parent_str_fn_name));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("}"));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_array(v__gen__c__Gen* g, v__ast__Array info, string styp, string str_fn_name) {
	v__ast__Type typ = info.elem_type;
	v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, info.elem_type);
	if ((sym->info)._typ == 413 /* v.ast.Alias */) {
		typ = (*sym->info._v__ast__Alias).parent_type;
		sym = v__ast__Table_get_type_symbol(g->table, typ);
	}
	string field_styp = v__gen__c__Gen_typ(g, typ);
	bool is_elem_ptr = v__ast__Type_is_ptr(typ);
	multi_return_bool_bool_int mr_7391 = v__ast__TypeSymbol_str_method_info(sym);
	bool sym_has_str_method = mr_7391.arg0;
	bool str_method_expects_ptr = mr_7391.arg1;
	string elem_str_fn_name = _SLIT("");
	if (sym_has_str_method) {
		elem_str_fn_name = (is_elem_ptr ? (string_add(string_replace(field_styp, _SLIT("*"), _SLIT("")), _SLIT("_str"))) : (string_add(field_styp, _SLIT("_str"))));
		if (sym->kind == v__ast__Kind_byte) {
			elem_str_fn_name = string_add(elem_str_fn_name, _SLIT("_escaped"));
		}
	} else {
		elem_str_fn_name = v__gen__c__styp_to_str_fn_name(field_styp);
	}
	if (!sym_has_str_method) {
		v__gen__c__Gen_gen_str_for_type(g, typ);
	}
	strings__Builder_writeln(&g->type_definitions, _STR("static string %.*s\000(%.*s\000 a); // auto", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("static string %.*s\000(%.*s\000 a) { return indent_%.*s\000(a, 0);}", 4, str_fn_name, styp, str_fn_name));
	strings__Builder_writeln(&g->type_definitions, _STR("static string indent_%.*s\000(%.*s\000 a, int indent_count); // auto", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("static string indent_%.*s\000(%.*s\000 a, int indent_count) {", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tstrings__Builder sb = strings__new_builder(a.len * 10);"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tstrings__Builder_write_string(&sb, _SLIT(\"[\"));"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tfor (int i = 0; i < a.len; ++i) {"));
	if (sym->kind == v__ast__Kind_function) {
		strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tstring x = %.*s\000();", 2, elem_str_fn_name));
	} else {
		if (sym->kind == v__ast__Kind_array_fixed) {
			strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\t%.*s\000 it;", 2, field_styp));
			strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tmemcpy(*(%.*s\000*)it, (byte*)array_get(a, i), sizeof(%.*s\000));", 3, field_styp, field_styp));
		} else {
			strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\t%.*s\000 it = *(%.*s\000*)array_get(a, i);", 3, field_styp, field_styp));
		}
		if (v__gen__c__should_use_indent_func(sym->kind) && !sym_has_str_method) {
			if (is_elem_ptr) {
				strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tstring x = indent_%.*s\000(*it, indent_count);", 2, elem_str_fn_name));
			} else {
				strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tstring x = indent_%.*s\000(it, indent_count);", 2, elem_str_fn_name));
			}
		} else if ((sym->kind == v__ast__Kind_f32 || sym->kind == v__ast__Kind_f64)) {
			strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t\tstring x = _STR(\"%g\", 1, it);"));
		} else if (sym->kind == v__ast__Kind_rune) {
			strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tstring x = _STR(\"`%%.*s\\000`\", 2, %.*s\000(it));", 2, elem_str_fn_name));
		} else if (sym->kind == v__ast__Kind_string) {
			strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t\tstring x = _STR(\"\'%.*s\\000\'\", 2, it);"));
		} else {
			if ((str_method_expects_ptr && is_elem_ptr) || (!str_method_expects_ptr && !is_elem_ptr)) {
				strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tstring x = %.*s\000(it);", 2, elem_str_fn_name));
			} else if (str_method_expects_ptr && !is_elem_ptr) {
				strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tstring x = %.*s\000(&it);", 2, elem_str_fn_name));
			} else if (!str_method_expects_ptr && is_elem_ptr) {
				strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tstring x = %.*s\000(*it);", 2, elem_str_fn_name));
			}
		}
	}
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t\tstrings__Builder_write_string(&sb, x);"));
	if (g->is_autofree && !v__ast__Type_alias_eq(typ, _const_v__ast__bool_type)) {
		strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t\tstring_free(&x);"));
	}
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t\tif (i < a.len-1) {"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t\t\tstrings__Builder_write_string(&sb, _SLIT(\", \"));"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t\t}"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t}"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tstrings__Builder_write_string(&sb, _SLIT(\"]\"));"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tstring res = strings__Builder_str(&sb);"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tstrings__Builder_free(&sb);"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\treturn res;"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("}"));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_array_fixed(v__gen__c__Gen* g, v__ast__ArrayFixed info, string styp, string str_fn_name) {
	v__ast__Type typ = info.elem_type;
	v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, info.elem_type);
	if ((sym->info)._typ == 413 /* v.ast.Alias */) {
		typ = (*sym->info._v__ast__Alias).parent_type;
		sym = v__ast__Table_get_type_symbol(g->table, typ);
	}
	string field_styp = v__gen__c__Gen_typ(g, typ);
	bool is_elem_ptr = v__ast__Type_is_ptr(typ);
	multi_return_bool_bool_int mr_11135 = v__ast__TypeSymbol_str_method_info(sym);
	bool sym_has_str_method = mr_11135.arg0;
	bool str_method_expects_ptr = mr_11135.arg1;
	string elem_str_fn_name = _SLIT("");
	if (sym_has_str_method) {
		elem_str_fn_name = (is_elem_ptr ? (string_add(string_replace(field_styp, _SLIT("*"), _SLIT("")), _SLIT("_str"))) : (string_add(field_styp, _SLIT("_str"))));
	} else {
		elem_str_fn_name = v__gen__c__styp_to_str_fn_name(field_styp);
	}
	if (!v__ast__TypeSymbol_has_method(sym, _SLIT("str"))) {
		elem_str_fn_name = v__gen__c__Gen_gen_str_for_type(g, typ);
	}
	strings__Builder_writeln(&g->type_definitions, _STR("static string %.*s\000(%.*s\000 a); // auto", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("static string %.*s\000(%.*s\000 a) { return indent_%.*s\000(a, 0);}", 4, str_fn_name, styp, str_fn_name));
	strings__Builder_writeln(&g->type_definitions, _STR("static string indent_%.*s\000(%.*s\000 a, int indent_count); // auto", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("static string indent_%.*s\000(%.*s\000 a, int indent_count) {", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("\tstrings__Builder sb = strings__new_builder(%"PRId32"\000 * 10);", 2, info.size));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tstrings__Builder_write_string(&sb, _SLIT(\"[\"));"));
	if (sym->kind == v__ast__Kind_function) {
		strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tstring x = %.*s\000();", 2, elem_str_fn_name));
	} else {
		strings__Builder_writeln(&g->auto_str_funcs, _STR("\tfor (int i = 0; i < %"PRId32"\000; ++i) {", 2, info.size));
		if (v__gen__c__should_use_indent_func(sym->kind) && !sym_has_str_method) {
			strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tstrings__Builder_write_string(&sb, %.*s\000(a[i]));", 2, elem_str_fn_name));
		} else if ((sym->kind == v__ast__Kind_f32 || sym->kind == v__ast__Kind_f64)) {
			strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t\tstrings__Builder_write_string(&sb, _STR(\"%g\", 1, a[i]));"));
		} else if (sym->kind == v__ast__Kind_string) {
			strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t\tstrings__Builder_write_string(&sb, _STR(\"\'%.*s\\000\'\", 2, a[i]));"));
		} else if (sym->kind == v__ast__Kind_rune) {
			strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tstrings__Builder_write_string(&sb, _STR(\"`%%.*s\\000`\", 2, %.*s\000(a[i])));", 2, elem_str_fn_name));
		} else {
			if ((str_method_expects_ptr && is_elem_ptr) || (!str_method_expects_ptr && !is_elem_ptr)) {
				strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tstrings__Builder_write_string(&sb, %.*s\000(a[i]));", 2, elem_str_fn_name));
			} else if (str_method_expects_ptr && !is_elem_ptr) {
				strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tstrings__Builder_write_string(&sb, %.*s\000(&a[i]));", 2, elem_str_fn_name));
			} else if (!str_method_expects_ptr && is_elem_ptr) {
				strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tstrings__Builder_write_string(&sb, %.*s\000(*a[i]));", 2, elem_str_fn_name));
			}
		}
	}
	strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tif (i < %"PRId32"\000) {", 2, info.size - 1));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t\t\tstrings__Builder_write_string(&sb, _SLIT(\", \"));"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t\t}"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t}"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tstrings__Builder_write_string(&sb, _SLIT(\"]\"));"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tstring res = strings__Builder_str(&sb);"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tstrings__Builder_free(&sb);"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\treturn res;"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("}"));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_map(v__gen__c__Gen* g, v__ast__Map info, string styp, string str_fn_name) {
	v__ast__Type key_typ = info.key_type;
	v__ast__TypeSymbol* key_sym = v__ast__Table_get_type_symbol(g->table, key_typ);
	if ((key_sym->info)._typ == 413 /* v.ast.Alias */) {
		key_typ = (*key_sym->info._v__ast__Alias).parent_type;
		key_sym = v__ast__Table_get_type_symbol(g->table, key_typ);
	}
	string key_styp = v__gen__c__Gen_typ(g, key_typ);
	string key_str_fn_name = string_add(string_replace(key_styp, _SLIT("*"), _SLIT("")), _SLIT("_str"));
	if (!v__ast__TypeSymbol_has_method(key_sym, _SLIT("str"))) {
		v__gen__c__Gen_gen_str_for_type(g, key_typ);
	}
	v__ast__Type val_typ = info.value_type;
	v__ast__TypeSymbol* val_sym = v__ast__Table_get_type_symbol(g->table, val_typ);
	if ((val_sym->info)._typ == 413 /* v.ast.Alias */) {
		val_typ = (*val_sym->info._v__ast__Alias).parent_type;
		val_sym = v__ast__Table_get_type_symbol(g->table, val_typ);
	}
	string val_styp = v__gen__c__Gen_typ(g, val_typ);
	string elem_str_fn_name = string_add(string_replace(val_styp, _SLIT("*"), _SLIT("")), _SLIT("_str"));
	if (!v__ast__TypeSymbol_has_method(val_sym, _SLIT("str"))) {
		v__gen__c__Gen_gen_str_for_type(g, val_typ);
	}
	strings__Builder_writeln(&g->type_definitions, _STR("static string %.*s\000(%.*s\000 m); // auto", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("static string %.*s\000(%.*s\000 m) { return indent_%.*s\000(m, 0);}", 4, str_fn_name, styp, str_fn_name));
	strings__Builder_writeln(&g->type_definitions, _STR("static string indent_%.*s\000(%.*s\000 m, int indent_count); // auto", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("static string indent_%.*s\000(%.*s\000 m, int indent_count) { /* gen_str_for_map */", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tstrings__Builder sb = strings__new_builder(m.key_values.len*10);"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tstrings__Builder_write_string(&sb, _SLIT(\"{\"));"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tfor (int i = 0; i < m.key_values.len; ++i) {"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t\tif (!DenseArray_has_index(&m.key_values, i)) { continue; }"));
	if (key_sym->kind == v__ast__Kind_string) {
		strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t\tstring key = *(string*)DenseArray_key(&m.key_values, i);"));
	} else {
		strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\t%.*s\000 key = *(%.*s\000*)DenseArray_key(&m.key_values, i);", 3, key_styp, key_styp));
	}
	if (key_sym->kind == v__ast__Kind_string) {
		strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t\tstrings__Builder_write_string(&sb, _STR(\"\'%.*s\\000\'\", 2, key));"));
	} else if (key_sym->kind == v__ast__Kind_rune) {
		strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tstrings__Builder_write_string(&sb, _STR(\"`%%.*s\\000`\", 2, %.*s\000(key)));", 2, key_str_fn_name));
	} else {
		strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tstrings__Builder_write_string(&sb, %.*s\000(key));", 2, key_str_fn_name));
	}
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t\tstrings__Builder_write_string(&sb, _SLIT(\": \"));"));
	if (val_sym->kind == v__ast__Kind_function) {
		strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tstrings__Builder_write_string(&sb, %.*s\000());", 2, elem_str_fn_name));
	} else if (val_sym->kind == v__ast__Kind_string) {
		strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tstrings__Builder_write_string(&sb, _STR(\"\'%%.*s\\000\'\", 2, *(%.*s\000*)DenseArray_value(&m.key_values, i)));", 2, val_styp));
	} else if (v__gen__c__should_use_indent_func(val_sym->kind) && !v__ast__TypeSymbol_has_method(val_sym, _SLIT("str"))) {
		strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tstrings__Builder_write_string(&sb, indent_%.*s\000(*(%.*s\000*)DenseArray_value(&m.key_values, i), indent_count));", 3, elem_str_fn_name, val_styp));
	} else if ((val_sym->kind == v__ast__Kind_f32 || val_sym->kind == v__ast__Kind_f64)) {
		strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tstrings__Builder_write_string(&sb, _STR(\"%%g\", 1, *(%.*s\000*)DenseArray_value(&m.key_values, i)));", 2, val_styp));
	} else if (val_sym->kind == v__ast__Kind_rune) {
		strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tstrings__Builder_write_string(&sb, _STR(\"`%%.*s\\000`\", 2, %.*s\000(*(%.*s\000*)DenseArray_value(&m.key_values, i))));", 3, elem_str_fn_name, val_styp));
	} else {
		strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tstrings__Builder_write_string(&sb, %.*s\000(*(%.*s\000*)DenseArray_value(&m.key_values, i)));", 3, elem_str_fn_name, val_styp));
	}
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t\tif (i != m.key_values.len-1) {"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t\t\tstrings__Builder_write_string(&sb, _SLIT(\", \"));"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t\t}"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t}"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tstrings__Builder_write_string(&sb, _SLIT(\"}\"));"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tstring res = strings__Builder_str(&sb);"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tstrings__Builder_free(&sb);"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\treturn res;"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("}"));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_multi_return(v__gen__c__Gen* g, v__ast__MultiReturn info, string styp, string str_fn_name) {
	// FOR IN array
	for (int _t2835 = 0; _t2835 < info.types.len; ++_t2835) {
		v__ast__Type typ = ((v__ast__Type*)info.types.data)[_t2835];
		v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, typ);
		if (!v__ast__TypeSymbol_has_method(sym, _SLIT("str"))) {
			v__gen__c__Gen_gen_str_for_type(g, typ);
		}
	}
	strings__Builder_writeln(&g->type_definitions, _STR("static string %.*s\000(%.*s\000 a); // auto", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("static string %.*s\000(%.*s\000 a) {", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("\tstrings__Builder sb = strings__new_builder(%"PRId32"\000 * 10);", 2, info.types.len));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tstrings__Builder_write_string(&sb, _SLIT(\"(\"));"));
	// FOR IN array
	for (int i = 0; i < info.types.len; ++i) {
		v__ast__Type typ = ((v__ast__Type*)info.types.data)[i];
		v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, typ);
		string field_styp = v__gen__c__Gen_typ(g, typ);
		bool is_arg_ptr = v__ast__Type_is_ptr(typ);
		multi_return_bool_bool_int mr_18337 = v__ast__TypeSymbol_str_method_info(sym);
		bool sym_has_str_method = mr_18337.arg0;
		bool str_method_expects_ptr = mr_18337.arg1;
		string arg_str_fn_name = _SLIT("");
		if (sym_has_str_method) {
			arg_str_fn_name = (is_arg_ptr ? (string_add(string_replace(field_styp, _SLIT("*"), _SLIT("")), _SLIT("_str"))) : (string_add(field_styp, _SLIT("_str"))));
		} else {
			arg_str_fn_name = v__gen__c__styp_to_str_fn_name(field_styp);
		}
		if (v__gen__c__should_use_indent_func(sym->kind) && !sym_has_str_method) {
			strings__Builder_writeln(&g->auto_str_funcs, _STR("\tstrings__Builder_write_string(&sb, %.*s\000(a.arg%"PRId32"\000));", 3, arg_str_fn_name, i));
		} else if ((sym->kind == v__ast__Kind_f32 || sym->kind == v__ast__Kind_f64)) {
			strings__Builder_writeln(&g->auto_str_funcs, _STR("\tstrings__Builder_write_string(&sb, _STR(\"%%g\", 1, a.arg%"PRId32"\000));", 2, i));
		} else if (sym->kind == v__ast__Kind_string) {
			strings__Builder_writeln(&g->auto_str_funcs, _STR("\tstrings__Builder_write_string(&sb, _STR(\"\'%%.*s\\000\'\", 2, a.arg%"PRId32"\000));", 2, i));
		} else if (sym->kind == v__ast__Kind_function) {
			strings__Builder_writeln(&g->auto_str_funcs, _STR("\tstrings__Builder_write_string(&sb, %.*s\000());", 2, arg_str_fn_name));
		} else {
			if ((str_method_expects_ptr && is_arg_ptr) || (!str_method_expects_ptr && !is_arg_ptr)) {
				strings__Builder_writeln(&g->auto_str_funcs, _STR("\tstrings__Builder_write_string(&sb, %.*s\000(a.arg%"PRId32"\000));", 3, arg_str_fn_name, i));
			} else if (str_method_expects_ptr && !is_arg_ptr) {
				strings__Builder_writeln(&g->auto_str_funcs, _STR("\tstrings__Builder_write_string(&sb, %.*s\000(&a.arg%"PRId32"\000));", 3, arg_str_fn_name, i));
			} else if (!str_method_expects_ptr && is_arg_ptr) {
				strings__Builder_writeln(&g->auto_str_funcs, _STR("\tstrings__Builder_write_string(&sb, %.*s\000(*a.arg%"PRId32"\000));", 3, arg_str_fn_name, i));
			}
		}
		if (i != info.types.len - 1) {
			strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tstrings__Builder_write_string(&sb, _SLIT(\", \"));"));
		}
	}
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tstrings__Builder_write_string(&sb, _SLIT(\")\"));"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tstring res = strings__Builder_str(&sb);"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tstrings__Builder_free(&sb);"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\treturn res;"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("}"));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_struct(v__gen__c__Gen* g, v__ast__Struct info, string styp, string str_fn_name) {
	Map_string_string fnames2strfunc = new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 1, sizeof(string), sizeof(string), _MOV((string[1]){_SLIT(""), }), _MOV((string[1]){_SLIT(""), }));
	// FOR IN array
	for (int _t2836 = 0; _t2836 < info.fields.len; ++_t2836) {
		v__ast__StructField field = ((v__ast__StructField*)info.fields.data)[_t2836];
		v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, field.typ);
		if (!v__ast__TypeSymbol_has_method(sym, _SLIT("str"))) {
			v__ast__Type typ = field.typ;
			if (v__ast__Type_is_ptr(typ)) {
				typ = v__ast__Type_deref(typ);
			}
			string field_styp = v__gen__c__Gen_typ(g, typ);
			string field_fn_name = v__gen__c__Gen_gen_str_for_type(g, field.typ);
			map_set(&fnames2strfunc, &(string[]){field_styp}, &(string[]) { field_fn_name });
		}
	}
	strings__Builder_writeln(&g->type_definitions, _STR("static string %.*s\000(%.*s\000 it); // auto", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("static string %.*s\000(%.*s\000 it) { return indent_%.*s\000(it, 0);}", 4, str_fn_name, styp, str_fn_name));
	strings__Builder_writeln(&g->type_definitions, _STR("static string indent_%.*s\000(%.*s\000 it, int indent_count); // auto", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("static string indent_%.*s\000(%.*s\000 it, int indent_count) {", 3, str_fn_name, styp));
	string clean_struct_v_type_name = string_replace(styp, _SLIT("__"), _SLIT("."));
	if (string_contains(clean_struct_v_type_name, _SLIT("_T_"))) {
		clean_struct_v_type_name = string_add(string_replace(string_replace(string_replace(clean_struct_v_type_name, _SLIT("_Array"), _SLIT("_array")), _SLIT("_T_"), _SLIT("<")), _SLIT("_"), _SLIT(", ")), _SLIT(">"));
	}
	clean_struct_v_type_name = v__util__strip_main_name(clean_struct_v_type_name);
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tstring indents = _SLIT(\"\");"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tfor (int i = 0; i < indent_count; ++i) {"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t\tindents = string_add(indents, _SLIT(\"    \"));"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t}"));
	if (info.fields.len == 0) {
		strings__Builder_write_string(&g->auto_str_funcs, _STR("\treturn _SLIT(\"%.*s\000{}\");", 2, clean_struct_v_type_name));
	} else {
		strings__Builder_write_string(&g->auto_str_funcs, _STR("\treturn _STR(\"%.*s\000{\\n\"", 2, clean_struct_v_type_name));
		// FOR IN array
		for (int _t2837 = 0; _t2837 < info.fields.len; ++_t2837) {
			v__ast__StructField field = ((v__ast__StructField*)info.fields.data)[_t2837];
			string fmt = (v__ast__Type_is_ptr(field.typ) ? (_SLIT("&")) : (_SLIT("")));
			fmt = /*f*/string_add(fmt, v__gen__c__Gen_type_to_fmt(g, field.typ));
			strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\t\"%%.*s\\000    %.*s\000: %.*s\000\\n\"", 3, field.name, fmt));
		}
		strings__Builder_write_string(&g->auto_str_funcs, _STR("\t\t\"%%.*s\\000}\", %"PRId32"", 1, 2 * (info.fields.len + 1)));
		if (info.fields.len > 0) {
			strings__Builder_write_string(&g->auto_str_funcs, _SLIT(",\n\t\t"));
			// FOR IN array
			for (int i = 0; i < info.fields.len; ++i) {
				v__ast__StructField field = ((v__ast__StructField*)info.fields.data)[i];
				v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, field.typ);
				bool has_custom_str = v__ast__TypeSymbol_has_method(sym, _SLIT("str"));
				string field_styp = string_replace(v__gen__c__Gen_typ(g, field.typ), _SLIT("*"), _SLIT(""));
				string field_styp_fn_name = (has_custom_str ? (_STR("%.*s\000_str", 2, field_styp)) : ((*(string*)map_get(ADDR(map, fnames2strfunc), &(string[]){field_styp}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} }))));
				strings__Builder_write_string(&g->auto_str_funcs, _SLIT("indents, "));
				string func = v__gen__c__struct_auto_str_func(sym, field.typ, field_styp_fn_name, field.name);
				if (v__ast__Type_is_ptr(field.typ)) {
					strings__Builder_write_string(&g->auto_str_funcs, _STR("isnil(it.%.*s\000)", 2, v__gen__c__c_name(field.name)));
					strings__Builder_write_string(&g->auto_str_funcs, _SLIT(" ? _SLIT(\"nil\") : "));
					if (sym->kind != v__ast__Kind_struct_ && !v__ast__Type_is_int_valptr(field.typ) && !v__ast__Type_is_float_valptr(field.typ)) {
						strings__Builder_write_string(&g->auto_str_funcs, _SLIT("*"));
					}
				}
				if (string_eq(styp, field_styp)) {
					strings__Builder_write_string(&g->auto_str_funcs, _SLIT("_SLIT(\"<circular>\")"));
				} else {
					strings__Builder_write_string(&g->auto_str_funcs, func);
				}
				if (i < info.fields.len - 1) {
					strings__Builder_write_string(&g->auto_str_funcs, _SLIT(",\n\t\t"));
				}
			}
		}
		strings__Builder_writeln(&g->auto_str_funcs, _SLIT(","));
		strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t\tindents);"));
	}
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("}"));
}

VV_LOCAL_SYMBOL string v__gen__c__struct_auto_str_func(v__ast__TypeSymbol* sym, v__ast__Type field_type, string fn_name, string field_name) {
	multi_return_bool_bool_int mr_23736 = v__ast__TypeSymbol_str_method_info(sym);
	bool has_custom_str = mr_23736.arg0;
	bool expects_ptr = mr_23736.arg1;
	if (sym->kind == v__ast__Kind_enum_) {
		 string _t2838 = _STR("%.*s\000(it.%.*s\000)", 3, fn_name, v__gen__c__c_name(field_name));
		// autofree_scope_vars(pos=23787 line_nr=540 scope.pos=23784 scope.end_pos=23835)
		// af parent scope:
		// var "sym" var.pos=23618 var.line_nr=537
		// var "field_type" var.pos=23639 var.line_nr=537
		// var "fn_name" var.pos=23660 var.line_nr=537
		// var "field_name" var.pos=23676 var.line_nr=537
		// var "has_custom_str" var.pos=23705 var.line_nr=538
		// var "expects_ptr" var.pos=23721 var.line_nr=538
		// af parent scope:
		// af parent scope:
		return _t2838;
	} else if (v__gen__c__should_use_indent_func(sym->kind)) {
		string obj = _STR("it.%.*s", 1, v__gen__c__c_name(field_name));
		if (v__ast__Type_is_ptr(field_type) && !expects_ptr) {
			obj = _STR("*%.*s", 1, obj);
		}
		if (has_custom_str) {
			 string _t2839 = _STR("%.*s\000(%.*s\000)", 3, fn_name, obj);
			// autofree_scope_vars(pos=24008 line_nr=547 scope.pos=24004 scope.end_pos=24037)
			// af parent scope:
			// var "obj" var.pos=23886 var.line_nr=542
			// af parent scope:
			// var "sym" var.pos=23618 var.line_nr=537
			// var "field_type" var.pos=23639 var.line_nr=537
			// var "fn_name" var.pos=23660 var.line_nr=537
			// var "field_name" var.pos=23676 var.line_nr=537
			// var "has_custom_str" var.pos=23705 var.line_nr=538
			// var "expects_ptr" var.pos=23721 var.line_nr=538
			// af parent scope:
			// af parent scope:
			return _t2839;
		}
		 string _t2840 = _STR("indent_%.*s\000(%.*s\000, indent_count + 1)", 3, fn_name, obj);
		// autofree_scope_vars(pos=24040 line_nr=549 scope.pos=23878 scope.end_pos=24093)
		// var "obj" var.pos=23886 var.line_nr=542
		// af parent scope:
		// var "sym" var.pos=23618 var.line_nr=537
		// var "field_type" var.pos=23639 var.line_nr=537
		// var "fn_name" var.pos=23660 var.line_nr=537
		// var "field_name" var.pos=23676 var.line_nr=537
		// var "has_custom_str" var.pos=23705 var.line_nr=538
		// var "expects_ptr" var.pos=23721 var.line_nr=538
		// af parent scope:
		// af parent scope:
		return _t2840;
	} else if ((sym->kind == v__ast__Kind_array || sym->kind == v__ast__Kind_array_fixed || sym->kind == v__ast__Kind_map || sym->kind == v__ast__Kind_sum_type)) {
		if (has_custom_str) {
			 string _t2841 = _STR("%.*s\000(it.%.*s\000)", 3, fn_name, v__gen__c__c_name(field_name));
			// autofree_scope_vars(pos=24181 line_nr=552 scope.pos=24177 scope.end_pos=24230)
			// af parent scope:
			// af parent scope:
			// var "sym" var.pos=23618 var.line_nr=537
			// var "field_type" var.pos=23639 var.line_nr=537
			// var "fn_name" var.pos=23660 var.line_nr=537
			// var "field_name" var.pos=23676 var.line_nr=537
			// var "has_custom_str" var.pos=23705 var.line_nr=538
			// var "expects_ptr" var.pos=23721 var.line_nr=538
			// af parent scope:
			// af parent scope:
			return _t2841;
		}
		 string _t2842 = _STR("indent_%.*s\000(it.%.*s\000, indent_count + 1)", 3, fn_name, v__gen__c__c_name(field_name));
		// autofree_scope_vars(pos=24233 line_nr=554 scope.pos=24155 scope.end_pos=24306)
		// af parent scope:
		// var "sym" var.pos=23618 var.line_nr=537
		// var "field_type" var.pos=23639 var.line_nr=537
		// var "fn_name" var.pos=23660 var.line_nr=537
		// var "field_name" var.pos=23676 var.line_nr=537
		// var "has_custom_str" var.pos=23705 var.line_nr=538
		// var "expects_ptr" var.pos=23721 var.line_nr=538
		// af parent scope:
		// af parent scope:
		return _t2842;
	} else if (sym->kind == v__ast__Kind_function) {
		 string _t2843 = _STR("%.*s\000()", 2, fn_name);
		// autofree_scope_vars(pos=24341 line_nr=556 scope.pos=24338 scope.end_pos=24365)
		// af parent scope:
		// var "sym" var.pos=23618 var.line_nr=537
		// var "field_type" var.pos=23639 var.line_nr=537
		// var "fn_name" var.pos=23660 var.line_nr=537
		// var "field_name" var.pos=23676 var.line_nr=537
		// var "has_custom_str" var.pos=23705 var.line_nr=538
		// var "expects_ptr" var.pos=23721 var.line_nr=538
		// af parent scope:
		// af parent scope:
		return _t2843;
	} else {
		string method_str = _STR("it.%.*s", 1, v__gen__c__c_name(field_name));
		if (sym->kind == v__ast__Kind_bool) {
			method_str = /*f*/string_add(method_str, _SLIT(" ? _SLIT(\"true\") : _SLIT(\"false\")"));
		} else if ((v__ast__Type_is_int_valptr(field_type) || v__ast__Type_is_float_valptr(field_type)) && v__ast__Type_is_ptr(field_type) && !expects_ptr) {
			string fmt = ((sym->kind == v__ast__Kind_f32 || sym->kind == v__ast__Kind_f64) ? (_SLIT("%g\\000")) : sym->kind == v__ast__Kind_u64 ? (_SLIT("%lld\\000")) : (_SLIT("%d\\000")));
			method_str = _STR("_STR(\"%.*s\000\", 2, *%.*s\000)", 3, fmt, method_str);
		}
		// autofree_scope_vars(pos=24869 line_nr=573 scope.pos=24372 scope.end_pos=24889)
		// var "method_str" var.pos=24380 var.line_nr=558
		// af parent scope:
		// var "sym" var.pos=23618 var.line_nr=537
		// var "field_type" var.pos=23639 var.line_nr=537
		// var "fn_name" var.pos=23660 var.line_nr=537
		// var "field_name" var.pos=23676 var.line_nr=537
		// var "has_custom_str" var.pos=23705 var.line_nr=538
		// var "expects_ptr" var.pos=23721 var.line_nr=538
		// af parent scope:
		// af parent scope:
		return method_str;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_enum(v__gen__c__Gen* g, v__ast__Enum info, string styp, string str_fn_name) {
	string s = v__util__no_dots(styp);
	strings__Builder_writeln(&g->type_definitions, _STR("static string %.*s\000(%.*s\000 it); // auto", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("static string %.*s\000(%.*s\000 it) { /* gen_str_for_enum */", 3, str_fn_name, styp));
	if (info.is_flag) {
		string clean_name = v__util__strip_main_name(string_replace(styp, _SLIT("__"), _SLIT(".")));
		strings__Builder_writeln(&g->auto_str_funcs, _STR("\tstring ret = _SLIT(\"%.*s\000{\");", 2, clean_name));
		strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tint first = 1;"));
		// FOR IN array
		for (int i = 0; i < info.vals.len; ++i) {
			string val = ((string*)info.vals.data)[i];
			strings__Builder_writeln(&g->auto_str_funcs, _STR("\tif (it & (1 << %"PRId32"\000)) {if (!first) {ret = string_add(ret, _SLIT(\" | \"));} ret = string_add(ret, _SLIT(\".%.*s\000\")); first = 0;}", 3, i, val));
		}
		strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tret = string_add(ret, _SLIT(\"}\"));"));
		strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\treturn ret;"));
	} else {
		strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tswitch(it) {"));
		Array_string seen = __new_array_with_default(info.vals.len, 0, sizeof(string), &(string[]){_SLIT("")});
		// FOR IN array
		for (int _t2844 = 0; _t2844 < info.vals.len; ++_t2844) {
			string val = ((string*)info.vals.data)[_t2844];
			if (info.is_multi_allowed && (Array_string_contains(seen, val))) {
				continue;
			} else if (info.is_multi_allowed) {
				array_push(&seen, _MOV((string[]){ string_clone(val) }));
			}
			strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tcase %.*s\000_%.*s\000: return _SLIT(\"%.*s\000\");", 4, s, val, val));
		}
		strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t\tdefault: return _SLIT(\"unknown enum value\");"));
		strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t}"));
	}
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("}"));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_interface(v__gen__c__Gen* g, v__ast__Interface info, string styp, string str_fn_name) {
	Map_string_string gen_fn_names = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
	// FOR IN array
	for (int _t2846 = 0; _t2846 < info.types.len; ++_t2846) {
		v__ast__Type typ = ((v__ast__Type*)info.types.data)[_t2846];
		v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, typ);
		if (!v__ast__TypeSymbol_has_method(sym, _SLIT("str"))) {
			string field_styp = v__gen__c__Gen_typ(g, typ);
			string field_fn_name = v__gen__c__Gen_gen_str_for_type(g, typ);
			map_set(&gen_fn_names, &(string[]){field_styp}, &(string[]) { field_fn_name });
		}
	}
	string clean_interface_v_type_name = string_replace(styp, _SLIT("__"), _SLIT("."));
	if (string_ends_with(styp, _SLIT("*"))) {
		clean_interface_v_type_name = string_add(_SLIT("&"), string_replace(clean_interface_v_type_name, _SLIT("*"), _SLIT("")));
	}
	clean_interface_v_type_name = v__util__strip_main_name(clean_interface_v_type_name);
	strings__Builder_writeln(&g->type_definitions, _STR("static string %.*s\000(%.*s\000 x); // auto", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("static string %.*s\000(%.*s\000 x) { return indent_%.*s\000(x, 0); }", 4, str_fn_name, styp, str_fn_name));
	strings__Builder_writeln(&g->type_definitions, _STR("static string indent_%.*s\000(%.*s\000 x, int indent_count); // auto", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("static string indent_%.*s\000(%.*s\000 x, int indent_count) { /* gen_str_for_interface */", 3, str_fn_name, styp));
	// FOR IN array
	for (int _t2847 = 0; _t2847 < info.types.len; ++_t2847) {
		v__ast__Type typ = ((v__ast__Type*)info.types.data)[_t2847];
		string typ_str = v__gen__c__Gen_typ(g, typ);
		v__ast__TypeSymbol* subtype = v__ast__Table_get_type_symbol(g->table, typ);
		string func_name = (_IN_MAP(ADDR(string, typ_str), ADDR(map, gen_fn_names)) ? ((*(string*)map_get(ADDR(map, gen_fn_names), &(string[]){typ_str}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} }))) : (v__gen__c__Gen_gen_str_for_type(g, typ)));
		multi_return_bool_bool_int mr_27545 = v__ast__TypeSymbol_str_method_info(subtype);
		bool sym_has_str_method = mr_27545.arg0;
		bool str_method_expects_ptr = mr_27545.arg1;
		if (v__gen__c__should_use_indent_func(subtype->kind) && !sym_has_str_method) {
			func_name = _STR("indent_%.*s", 1, func_name);
		}
		string deref = (sym_has_str_method && str_method_expects_ptr ? (_SLIT(" ")) : (_SLIT("*")));
		string value_fmt = (v__ast__Type_alias_eq(typ, _const_v__ast__string_type) ? (_SLIT("'%.*s\\000'")) : (_SLIT("%.*s\\000")));
		strings__Builder_write_string(&g->auto_str_funcs, _STR("\tif (x._typ == _%.*s\000_%.*s\000_index)", 3, styp, subtype->cname));
		strings__Builder_write_string(&g->auto_str_funcs, _STR(" return _STR(\"%.*s\000(%.*s\000)\", 2, ", 3, clean_interface_v_type_name, value_fmt));
		strings__Builder_write_string(&g->auto_str_funcs, _STR("%.*s\000(%.*s\000(%.*s\000*)x._%.*s", 4, func_name, deref, subtype->cname, subtype->cname));
		if (v__gen__c__should_use_indent_func(subtype->kind) && !sym_has_str_method) {
			strings__Builder_write_string(&g->auto_str_funcs, _SLIT(", indent_count"));
		}
		strings__Builder_writeln(&g->auto_str_funcs, _SLIT("));"));
	}
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\treturn _SLIT(\"unknown interface value\");"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("}"));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_union_sum_type(v__gen__c__Gen* g, v__ast__SumType info, string styp, string str_fn_name) {
	Map_string_string gen_fn_names = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
	// FOR IN array
	for (int _t2848 = 0; _t2848 < info.variants.len; ++_t2848) {
		v__ast__Type typ = ((v__ast__Type*)info.variants.data)[_t2848];
		v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, typ);
		if (!v__ast__TypeSymbol_has_method(sym, _SLIT("str"))) {
			string field_styp = v__gen__c__Gen_typ(g, typ);
			string field_fn_name = v__gen__c__Gen_gen_str_for_type(g, typ);
			map_set(&gen_fn_names, &(string[]){field_styp}, &(string[]) { field_fn_name });
		}
	}
	strings__Builder_writeln(&g->type_definitions, _STR("static string %.*s\000(%.*s\000 x); // auto", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("static string %.*s\000(%.*s\000 x) { return indent_%.*s\000(x, 0); }", 4, str_fn_name, styp, str_fn_name));
	strings__Builder_writeln(&g->type_definitions, _STR("static string indent_%.*s\000(%.*s\000 x, int indent_count); // auto", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("static string indent_%.*s\000(%.*s\000 x, int indent_count) {", 3, str_fn_name, styp));
	string clean_sum_type_v_type_name = string_replace(styp, _SLIT("__"), _SLIT("."));
	if (string_ends_with(styp, _SLIT("*"))) {
		clean_sum_type_v_type_name = string_add(_SLIT("&"), string_replace(clean_sum_type_v_type_name, _SLIT("*"), _SLIT("")));
	}
	clean_sum_type_v_type_name = v__util__strip_main_name(clean_sum_type_v_type_name);
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\tswitch(x._typ) {"));
	// FOR IN array
	for (int _t2849 = 0; _t2849 < info.variants.len; ++_t2849) {
		v__ast__Type typ = ((v__ast__Type*)info.variants.data)[_t2849];
		string value_fmt = _SLIT("%.*s\\000");
		if (v__ast__Type_alias_eq(typ, _const_v__ast__string_type)) {
			value_fmt = _STR("'%.*s\000'", 2, value_fmt);
		}
		string typ_str = v__gen__c__Gen_typ(g, typ);
		string func_name = (_IN_MAP(ADDR(string, typ_str), ADDR(map, gen_fn_names)) ? ((*(string*)map_get(ADDR(map, gen_fn_names), &(string[]){typ_str}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} }))) : (v__gen__c__Gen_gen_str_for_type(g, typ)));
		v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, typ);
		multi_return_bool_bool_int mr_29839 = v__ast__TypeSymbol_str_method_info(sym);
		bool sym_has_str_method = mr_29839.arg0;
		bool str_method_expects_ptr = mr_29839.arg1;
		string deref = (sym_has_str_method && str_method_expects_ptr ? (_SLIT(" ")) : (_SLIT("*")));
		if (v__gen__c__should_use_indent_func(sym->kind) && !sym_has_str_method) {
			func_name = _STR("indent_%.*s", 1, func_name);
		}
		strings__Builder_write_string(&g->auto_str_funcs, _STR("\t\tcase %"PRId32"\000: return _STR(\"%.*s\000(%.*s\000)\", 2, %.*s\000(%.*s\000(%.*s\000*)x._%.*s", 7, typ, clean_sum_type_v_type_name, value_fmt, func_name, deref, typ_str, sym->cname));
		if (v__gen__c__should_use_indent_func(sym->kind) && !sym_has_str_method) {
			strings__Builder_write_string(&g->auto_str_funcs, _SLIT(", indent_count"));
		}
		strings__Builder_writeln(&g->auto_str_funcs, _SLIT("));"));
	}
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t\tdefault: return _SLIT(\"unknown sum type value\");"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("\t}"));
	strings__Builder_writeln(&g->auto_str_funcs, _SLIT("}"));
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_fn_decl_str(v__gen__c__Gen* g, v__ast__FnType info) {
	string fn_str = _SLIT("fn (");
	// FOR IN array
	for (int i = 0; i < info.func.params.len; ++i) {
		v__ast__Param arg = ((v__ast__Param*)info.func.params.data)[i];
		if (i > 0) {
			fn_str = /*f*/string_add(fn_str, _SLIT(", "));
		}
		fn_str = /*f*/string_add(fn_str, v__util__strip_main_name(v__ast__Table_get_type_name(g->table, arg.typ)));
	}
	fn_str = /*f*/string_add(fn_str, _SLIT(")"));
	if (!v__ast__Type_alias_eq(info.func.return_type, _const_v__ast__void_type)) {
		fn_str = /*f*/string_add(fn_str, _STR(" %.*s", 1, v__util__strip_main_name(v__ast__Table_get_type_name(g->table, info.func.return_type))));
	}
	// autofree_scope_vars(pos=30866 line_nr=719 scope.pos=30509 scope.end_pos=30881)
	// var "g" var.pos=30514 var.line_nr=707
	// var "info" var.pos=30533 var.line_nr=707
	// var "fn_str" var.pos=30564 var.line_nr=708
	// str literal
	// af parent scope:
	// af parent scope:
	return fn_str;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_str_for_fn_type(v__gen__c__Gen* g, v__ast__FnType info, string styp, string str_fn_name) {
	strings__Builder_writeln(&g->type_definitions, _STR("static string %.*s\000(); // auto", 2, str_fn_name));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("static string %.*s\000() { return _SLIT(\"%.*s\000\");}", 3, str_fn_name, v__gen__c__Gen_fn_decl_str(g, info)));
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL string v__gen__c__styp_to_str_fn_name(string styp) {
	 string _t2850 = string_add(string_replace_each(styp, new_array_from_c_array(6, 6, sizeof(string), _MOV((string[6]){_SLIT("*"), _SLIT(""), _SLIT("."), _SLIT("__"), _SLIT(" "), _SLIT("__")}))), _SLIT("_str"));
	// autofree_scope_vars(pos=31202 line_nr=729 scope.pos=31160 scope.end_pos=31270)
	// var "styp" var.pos=31180 var.line_nr=728
	// af parent scope:
	// af parent scope:
	return _t2850;
}

string v__gen__c__gen(Array_v__ast__File files, v__ast__Table* table, v__pref__Preferences* pref) {
	string module_built = _SLIT("");
	if (pref->build_mode == v__pref__BuildMode_build_module) {
		// FOR IN array
		for (int _t2851 = 0; _t2851 < files.len; ++_t2851) {
			v__ast__File file = ((v__ast__File*)files.data)[_t2851];
			if (string_contains(file.path, pref->path) && string_eq(file.mod.short_name, string_trim_right(string_all_after_last(pref->path, _const_os__path_separator), _const_os__path_separator))) {
				module_built = file.mod.name;
				break;
			}
		}
	}
	bool timers_should_print = false;
	v__gen__c__Gen g = (v__gen__c__Gen){
		.pref = pref,
		.module_built = module_built,
		.table = table,
		.out = strings__new_builder(512000),
		.cheaders = strings__new_builder(15000),
		.includes = strings__new_builder(100),
		.typedefs = strings__new_builder(100),
		.typedefs2 = strings__new_builder(100),
		.type_definitions = strings__new_builder(100),
		.definitions = strings__new_builder(100),
		.inits = new_map(sizeof(string), sizeof(strings__Builder), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.cleanups = new_map(sizeof(string), sizeof(strings__Builder), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.gowrappers = strings__new_builder(100),
		.stringliterals = strings__new_builder(100),
		.auto_str_funcs = strings__new_builder(100),
		.comptime_defines = strings__new_builder(100),
		.pcs_declarations = strings__new_builder(100),
		.hotcode_definitions = strings__new_builder(100),
		.embedded_data = strings__new_builder(1000),
		.shared_types = strings__new_builder(100),
		.shared_functions = strings__new_builder(100),
		.channel_definitions = strings__new_builder(100),
		.options_typedefs = strings__new_builder(100),
		.options = strings__new_builder(100),
		.json_forward_decls = strings__new_builder(100),
		.enum_typedefs = strings__new_builder(100),
		.sql_buf = strings__new_builder(100),
		.file = (v__ast__File){.stmts = __new_array(0, 1, sizeof(v__ast__Stmt)),.imports = __new_array(0, 1, sizeof(v__ast__Import)),.auto_imports = __new_array(0, 1, sizeof(string)),.embedded_files = __new_array(0, 1, sizeof(v__ast__EmbeddedFile)),.imported_symbols = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.errors = __new_array(0, 1, sizeof(v__errors__Error)),.warnings = __new_array(0, 1, sizeof(v__errors__Warning)),.notices = __new_array(0, 1, sizeof(v__errors__Notice)),.generic_fns = __new_array(0, 1, sizeof(v__ast__FnDecl*)),.global_labels = __new_array(0, 1, sizeof(string)),},
		.fn_decl = 0,
		.last_fn_c_name = (string){.str=(byteptr)"", .is_lit=1},
		.tmp_count = 0,
		.tmp_count2 = 0,
		.is_c_call = 0,
		.is_assign_lhs = 0,
		.discard_or_result = 0,
		.is_void_expr_stmt = 0,
		.is_arraymap_set = 0,
		.is_amp = 0,
		.is_sql = 0,
		.is_shared = 0,
		.is_vlines_enabled = 0,
		.arraymap_set_pos = 0,
		.vlines_path = (string){.str=(byteptr)"", .is_lit=1},
		.optionals = __new_array(0, 1, sizeof(string)),
		.chan_pop_optionals = __new_array(0, 1, sizeof(string)),
		.chan_push_optionals = __new_array(0, 1, sizeof(string)),
		.shareds = __new_array(0, 1, sizeof(int)),
		.inside_ternary = 0,
		.inside_map_postfix = 0,
		.inside_map_infix = 0,
		.inside_map_index = 0,
		.inside_opt_data = 0,
		.inside_if_optional = 0,
		.ternary_names = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.ternary_level_names = new_map(sizeof(string), sizeof(Array_string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.stmt_path_pos = __new_array(0, 1, sizeof(int)),
		.skip_stmt_pos = 0,
		.right_is_opt = 0,
		.is_autofree = true,
		.indent = -1,
		.empty_line = 0,
		.is_test = 0,
		.assign_op = 0,
		.defer_stmts = __new_array(0, 1, sizeof(v__ast__DeferStmt)),
		.defer_ifdef = (string){.str=(byteptr)"", .is_lit=1},
		.defer_profile_code = (string){.str=(byteptr)"", .is_lit=1},
		.str_types = __new_array(0, 1, sizeof(string)),
		.threaded_fns = __new_array(0, 1, sizeof(string)),
		.waiter_fns = __new_array(0, 1, sizeof(string)),
		.array_fn_definitions = __new_array(0, 1, sizeof(string)),
		.map_fn_definitions = __new_array(0, 1, sizeof(string)),
		.struct_fn_definitions = __new_array(0, 1, sizeof(string)),
		.sumtype_fn_definitions = __new_array(0, 1, sizeof(string)),
		.alias_fn_definitions = __new_array(0, 1, sizeof(string)),
		.auto_fn_definitions = __new_array(0, 1, sizeof(string)),
		.anon_fn_definitions = __new_array(0, 1, sizeof(string)),
		.sumtype_definitions = new_map(sizeof(int), sizeof(bool), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),
		.is_json_fn = 0,
		.json_types = __new_array(0, 1, sizeof(string)),
		.pcs = __new_array(0, 1, sizeof(v__gen__c__ProfileCounterMeta)),
		.is_builtin_mod = 0,
		.hotcode_fn_names = __new_array(0, 1, sizeof(string)),
		.embedded_files = __new_array(0, 1, sizeof(v__ast__EmbeddedFile)),
		.cur_fn = (v__ast__FnDecl){.params = __new_array(0, 1, sizeof(v__ast__Param)),.generic_names = __new_array(0, 1, sizeof(string)),.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.stmts = __new_array(0, 1, sizeof(v__ast__Stmt)),.defer_stmts = __new_array(0, 1, sizeof(v__ast__DeferStmt)),.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.next_comments = __new_array(0, 1, sizeof(v__ast__Comment)),.source_file = 0,.label_names = __new_array(0, 1, sizeof(string)),},
		.cur_generic_types = __new_array(0, 1, sizeof(v__ast__Type)),
		.sql_i = 0,
		.sql_stmt_name = (string){.str=(byteptr)"", .is_lit=1},
		.sql_bind_name = (string){.str=(byteptr)"", .is_lit=1},
		.sql_idents = __new_array(0, 1, sizeof(string)),
		.sql_idents_types = __new_array(0, 1, sizeof(v__ast__Type)),
		.sql_left_type = 0,
		.sql_table_name = (string){.str=(byteptr)"", .is_lit=1},
		.sql_side = 0,
		.inside_vweb_tmpl = 0,
		.inside_return = 0,
		.inside_or_block = 0,
		.strs_to_free0 = __new_array(0, 1, sizeof(string)),
		.inside_call = 0,
		.has_main = 0,
		.inside_const = 0,
		.comp_for_method = (string){.str=(byteptr)"", .is_lit=1},
		.comp_for_field_var = (string){.str=(byteptr)"", .is_lit=1},
		.comp_for_field_value = (v__ast__StructField){.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),},
		.comp_for_field_type = 0,
		.comptime_var_type_map = new_map(sizeof(string), sizeof(v__ast__Type), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.called_fn_name = (string){.str=(byteptr)"", .is_lit=1},
		.cur_mod = (v__ast__Module){.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),},
		.is_js_call = 0,
		.is_fn_index_call = 0,
		.inside_lambda = 0,
		.prevent_sum_type_unwrapping_once = 0,
		.aggregate_type_idx = 0,
		.returned_var_name = (string){.str=(byteptr)"", .is_lit=1},
		.branch_parent_pos = 0,
		.timers = v__util__new_timers(timers_should_print),
		.force_main_console = 0,
		.as_cast_type_names = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.obf_table = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
	};
	v__util__Timers_start(g.timers, _SLIT("cgen init"));
	// FOR IN array
	for (int _t2852 = 0; _t2852 < g.table->modules.len; ++_t2852) {
		string mod = ((string*)g.table->modules.data)[_t2852];
(*(strings__Builder*)map_get_and_set(&g.inits, &(string[]){mod}, &(strings__Builder[]){ (strings__Builder){.buf = __new_array(0, 1, sizeof(byte)),.initial_size = 1,} })) = strings__new_builder(100);
(*(strings__Builder*)map_get_and_set(&g.cleanups, &(string[]){mod}, &(strings__Builder[]){ (strings__Builder){.buf = __new_array(0, 1, sizeof(byte)),.initial_size = 1,} })) = strings__new_builder(100);
	}
	v__gen__c__Gen_init(&g);
	v__util__Timers_show(g.timers, _SLIT("cgen init"));
	bool tests_inited = false;
	bool autofree_used = false;
	// FOR IN array
	for (int _t2853 = 0; _t2853 < files.len; ++_t2853) {
		v__ast__File file = ((v__ast__File*)files.data)[_t2853];
		v__util__Timers_start(g.timers, _STR("cgen_file %.*s", 1, file.path));
		g.file = file;
		if (g.pref->is_vlines) {
			g.vlines_path = v__util__vlines_escape_path(file.path, g.pref->ccompiler);
		}
		g.is_test = g.pref->is_test;
		if ((g.file.path).len == 0 || !g.pref->autofree) {
			g.is_autofree = false;
		} else {
			g.is_autofree = true;
			autofree_used = true;
		}
		if (g.is_test && !tests_inited) {
			v__gen__c__Gen_write_tests_definitions(&g);
			tests_inited = true;
		}
		v__gen__c__Gen_stmts(&g, file.stmts);
		if (file.embedded_files.len > 0) {
			// FOR IN array
			for (int _t2854 = 0; _t2854 < file.embedded_files.len; ++_t2854) {
				v__ast__EmbeddedFile path = ((v__ast__EmbeddedFile*)file.embedded_files.data)[_t2854];
				if (!(Array_v__ast__EmbeddedFile_contains(g.embedded_files, path))) {
					array_push(&g.embedded_files, _MOV((v__ast__EmbeddedFile[]){ path }));
				}
			}
		}
		v__util__Timers_show(g.timers, _STR("cgen_file %.*s", 1, file.path));
	}
	v__util__Timers_start(g.timers, _SLIT("cgen common"));
	if (autofree_used) {
		g.is_autofree = true;
	}
	if (g.pref->build_mode == v__pref__BuildMode_build_module) {
		// FOR IN array
		for (int idx = 0; idx < g.table->type_symbols.len; ++idx) {
			v__ast__TypeSymbol typ = ((v__ast__TypeSymbol*)g.table->type_symbols.data)[idx];
			if (idx == 0) {
				continue;
			}
			strings__Builder_writeln(&g.definitions, _STR("int _v_type_idx_%.*s\000();", 2, typ.cname));
		}
	} else if (g.pref->use_cache) {
		// FOR IN array
		for (int idx = 0; idx < g.table->type_symbols.len; ++idx) {
			v__ast__TypeSymbol typ = ((v__ast__TypeSymbol*)g.table->type_symbols.data)[idx];
			if (idx == 0) {
				continue;
			}
			strings__Builder_writeln(&g.definitions, _STR("int _v_type_idx_%.*s\000() { return %"PRId32"\000; };", 3, typ.cname, idx));
		}
	}
	v__gen__c__Gen_dump_expr_definitions(&g);
	v__gen__c__Gen_gen_vlines_reset(&g);
	if (g.pref->build_mode != v__pref__BuildMode_build_module) {
		v__gen__c__Gen_write_init_function(&g);
	}
	v__gen__c__Gen_finish(&g);
	strings__Builder b = strings__new_builder(640000);
	strings__Builder_write_string(&b, v__gen__c__Gen_hashes(&g));
	strings__Builder_writeln(&b, _SLIT("\n// V comptime_defines:"));
	strings__Builder_write_string(&b, strings__Builder_str(&g.comptime_defines));
	strings__Builder_writeln(&b, _SLIT("\n// V typedefs:"));
	strings__Builder_write_string(&b, strings__Builder_str(&g.typedefs));
	strings__Builder_writeln(&b, _SLIT("\n// V typedefs2:"));
	strings__Builder_write_string(&b, strings__Builder_str(&g.typedefs2));
	strings__Builder_writeln(&b, _SLIT("\n// V cheaders:"));
	strings__Builder_write_string(&b, strings__Builder_str(&g.cheaders));
	if (g.pcs_declarations.len > 0) {
		strings__Builder_writeln(&b, _SLIT("\n// V profile counters:"));
		strings__Builder_write_string(&b, strings__Builder_str(&g.pcs_declarations));
	}
	strings__Builder_writeln(&b, _SLIT("\n// V includes:"));
	strings__Builder_write_string(&b, strings__Builder_str(&g.includes));
	strings__Builder_writeln(&b, _SLIT("\n// Enum definitions:"));
	strings__Builder_write_string(&b, strings__Builder_str(&g.enum_typedefs));
	strings__Builder_writeln(&b, _SLIT("\n// V type definitions:"));
	strings__Builder_write_string(&b, strings__Builder_str(&g.type_definitions));
	strings__Builder_writeln(&b, _SLIT("\n// V shared types:"));
	strings__Builder_write_string(&b, strings__Builder_str(&g.shared_types));
	strings__Builder_writeln(&b, _SLIT("\n// V Option_xxx definitions:"));
	strings__Builder_write_string(&b, strings__Builder_str(&g.options));
	strings__Builder_writeln(&b, _SLIT("\n// V json forward decls:"));
	strings__Builder_write_string(&b, strings__Builder_str(&g.json_forward_decls));
	strings__Builder_writeln(&b, _SLIT("\n// V definitions:"));
	strings__Builder_write_string(&b, strings__Builder_str(&g.definitions));
	string interface_table = v__gen__c__Gen_interface_table(&g);
	if (interface_table.len > 0) {
		strings__Builder_writeln(&b, _SLIT("\n// V interface table:"));
		strings__Builder_write_string(&b, interface_table);
	}
	if (g.gowrappers.len > 0) {
		strings__Builder_writeln(&b, _SLIT("\n// V gowrappers:"));
		strings__Builder_write_string(&b, strings__Builder_str(&g.gowrappers));
	}
	if (g.hotcode_definitions.len > 0) {
		strings__Builder_writeln(&b, _SLIT("\n// V hotcode definitions:"));
		strings__Builder_write_string(&b, strings__Builder_str(&g.hotcode_definitions));
	}
	if (g.embedded_data.len > 0) {
		strings__Builder_writeln(&b, _SLIT("\n// V embedded data:"));
		strings__Builder_write_string(&b, strings__Builder_str(&g.embedded_data));
	}
	if (g.options_typedefs.len > 0) {
		strings__Builder_writeln(&b, _SLIT("\n// V option typedefs:"));
		strings__Builder_write_string(&b, strings__Builder_str(&g.options_typedefs));
	}
	if (g.shared_functions.len > 0) {
		strings__Builder_writeln(&b, _SLIT("\n// V shared type functions:"));
		strings__Builder_write_string(&b, strings__Builder_str(&g.shared_functions));
		strings__Builder_write_string(&b, _const_v__gen__c__c_concurrency_helpers);
	}
	if (g.channel_definitions.len > 0) {
		strings__Builder_writeln(&b, _SLIT("\n// V channel code:"));
		strings__Builder_write_string(&b, strings__Builder_str(&g.channel_definitions));
	}
	if (g.stringliterals.len > 0) {
		strings__Builder_writeln(&b, _SLIT("\n// V stringliterals:"));
		strings__Builder_write_string(&b, strings__Builder_str(&g.stringliterals));
	}
	if (g.auto_str_funcs.len > 0) {
		strings__Builder_writeln(&b, _SLIT("\n// V auto str functions:"));
		strings__Builder_write_string(&b, strings__Builder_str(&g.auto_str_funcs));
	}
	if (g.auto_fn_definitions.len > 0) {
		// FOR IN array
		for (int _t2856 = 0; _t2856 < g.auto_fn_definitions.len; ++_t2856) {
			string fn_def = ((string*)g.auto_fn_definitions.data)[_t2856];
			strings__Builder_writeln(&b, fn_def);
		}
	}
	if (g.anon_fn_definitions.len > 0) {
		// FOR IN array
		for (int _t2857 = 0; _t2857 < g.anon_fn_definitions.len; ++_t2857) {
			string fn_def = ((string*)g.anon_fn_definitions.data)[_t2857];
			strings__Builder_writeln(&b, fn_def);
		}
	}
	strings__Builder_writeln(&b, _SLIT("\n// V out"));
	strings__Builder_write_string(&b, strings__Builder_str(&g.out));
	strings__Builder_writeln(&b, _SLIT("\n// THE END."));
	v__util__Timers_show(g.timers, _SLIT("cgen common"));
	 string _t2858 = strings__Builder_str(&b);
	// autofree_scope_vars(pos=15296 line_nr=366 scope.pos=9252 scope.end_pos=15312)
	// var "files" var.pos=9256 var.line_nr=163
	// var "table" var.pos=9274 var.line_nr=163
	// var "pref" var.pos=9292 var.line_nr=163
	// var "module_built" var.pos=9357 var.line_nr=165
	// str literal
	// var "timers_should_print" var.pos=9639 var.line_nr=175
	// var "g" var.pos=9727 var.line_nr=179
	// var "tests_inited" var.pos=10999 var.line_nr=217
	// var "autofree_used" var.pos=11026 var.line_nr=218
	// var "b" var.pos=12819 var.line_nr=284
	// var "interface_table" var.pos=13807 var.line_nr=312
	// af parent scope:
	// af parent scope:
	return _t2858;
}

string v__gen__c__Gen_hashes(v__gen__c__Gen* g) {
	string res = string_replace(_const_v__gen__c__c_commit_hash_default, _SLIT("@@@"), v__util__vhash());
	res = /*f*/string_add(res, string_replace(_const_v__gen__c__c_current_commit_hash_default, _SLIT("@@@"), v__util__githash(g->pref->building_v)));
	// autofree_scope_vars(pos=15498 line_nr=372 scope.pos=15322 scope.end_pos=15510)
	// var "g" var.pos=15323 var.line_nr=369
	// var "res" var.pos=15354 var.line_nr=370
	// af parent scope:
	// af parent scope:
	return res;
}

void v__gen__c__Gen_init(v__gen__c__Gen* g) {
	if ((g->pref->custom_prelude).len != 0) {
		strings__Builder_writeln(&g->cheaders, g->pref->custom_prelude);
	} else if (!g->pref->no_preludes) {
		strings__Builder_writeln(&g->cheaders, _SLIT("// Generated by the V compiler"));
		string tcc_undef_has_include = _SLIT("\n#if defined(__TINYC__) && defined(__has_include)\n// tcc does not support has_include properly yet, turn it off completely\n#undef __has_include\n#endif");
		strings__Builder_writeln(&g->cheaders, tcc_undef_has_include);
		strings__Builder_writeln(&g->includes, tcc_undef_has_include);
		strings__Builder_writeln(&g->cheaders, v__gen__c__get_guarded_include_text(_SLIT("<inttypes.h>"), _SLIT("The C compiler can not find <inttypes.h> . Please install build-essentials")));
		strings__Builder_writeln(&g->cheaders, _const_v__gen__c__c_builtin_types);
		if (g->pref->is_bare) {
			strings__Builder_writeln(&g->cheaders, _const_v__gen__c__bare_c_headers);
		} else {
			strings__Builder_writeln(&g->cheaders, _const_v__gen__c__c_headers);
		}
		strings__Builder_writeln(&g->definitions, _SLIT("void _STR_PRINT_ARG(const char*, char**, int*, int*, int, ...);"));
		strings__Builder_writeln(&g->definitions, _SLIT("string _STR(const char*, int, ...);"));
		strings__Builder_writeln(&g->definitions, _SLIT("string _STR_TMP(const char*, ...);"));
	}
	if (g->pref->os == v__pref__OS_ios) {
		strings__Builder_writeln(&g->cheaders, _SLIT("#define __TARGET_IOS__ 1"));
		strings__Builder_writeln(&g->cheaders, _SLIT("#include <spawn.h>"));
	}
	v__gen__c__Gen_write_builtin_types(g);
	v__gen__c__Gen_write_typedef_types(g);
	v__gen__c__Gen_write_typeof_functions(g);
	if (g->pref->build_mode != v__pref__BuildMode_build_module) {
		v__gen__c__Gen_write_str_fn_definitions(g);
	}
	v__gen__c__Gen_write_sorted_types(g);
	v__gen__c__Gen_write_multi_return_types(g);
	strings__Builder_writeln(&g->definitions, _SLIT("// end of definitions #endif"));
	strings__Builder_writeln(&g->stringliterals, _SLIT(""));
	strings__Builder_writeln(&g->stringliterals, _SLIT("// >> string literal consts"));
	if (g->pref->build_mode != v__pref__BuildMode_build_module) {
		strings__Builder_writeln(&g->stringliterals, _SLIT("void vinit_string_literals(){"));
	}
	if (g->pref->compile_defines_all.len > 0) {
		strings__Builder_writeln(&g->comptime_defines, _SLIT("// V compile time defines by -d or -define flags:"));
		strings__Builder_writeln(&g->comptime_defines, string_add(_SLIT("//     All custom defines      : "), Array_string_join(g->pref->compile_defines_all, _SLIT(","))));
		strings__Builder_writeln(&g->comptime_defines, string_add(_SLIT("//     Turned ON custom defines: "), Array_string_join(g->pref->compile_defines, _SLIT(","))));
		// FOR IN array
		for (int _t2859 = 0; _t2859 < g->pref->compile_defines.len; ++_t2859) {
			string cdefine = ((string*)g->pref->compile_defines.data)[_t2859];
			strings__Builder_writeln(&g->comptime_defines, _STR("#define CUSTOM_DEFINE_%.*s", 1, cdefine));
		}
		strings__Builder_writeln(&g->comptime_defines, _SLIT(""));
	}
	if ((g->pref->gc_mode == v__pref__GarbageCollectionMode_boehm_full || g->pref->gc_mode == v__pref__GarbageCollectionMode_boehm_incr || g->pref->gc_mode == v__pref__GarbageCollectionMode_boehm || g->pref->gc_mode == v__pref__GarbageCollectionMode_boehm_leak)) {
		strings__Builder_writeln(&g->comptime_defines, _SLIT("#define _VGCBOEHM (1)"));
	}
	if (g->pref->is_debug || (Array_string_contains(g->pref->compile_defines, _SLIT("debug")))) {
		strings__Builder_writeln(&g->comptime_defines, _SLIT("#define _VDEBUG (1)"));
	}
	if (g->pref->is_prod || (Array_string_contains(g->pref->compile_defines, _SLIT("prod")))) {
		strings__Builder_writeln(&g->comptime_defines, _SLIT("#define _VPROD (1)"));
	}
	if (g->pref->is_test || (Array_string_contains(g->pref->compile_defines, _SLIT("test")))) {
		strings__Builder_writeln(&g->comptime_defines, _SLIT("#define _VTEST (1)"));
	}
	if (g->pref->autofree) {
		strings__Builder_writeln(&g->comptime_defines, _SLIT("#define _VAUTOFREE (1)"));
	}
	if (g->pref->prealloc) {
		strings__Builder_writeln(&g->comptime_defines, _SLIT("#define _VPREALLOC (1)"));
	}
	if (g->pref->is_livemain || g->pref->is_liveshared) {
		v__gen__c__Gen_generate_hotcode_reloading_declarations(g);
	}
	if (g->pref->obfuscate) {
		int i = 0;
		// FOR IN map
		Map_string_v__ast__Fn _t2860 = g->table->fns;
		int _t2862 = _t2860.key_values.len;
		for (int _t2861 = 0; _t2861 < _t2862; ++_t2861 ) {
			int _t2863 = _t2860.key_values.len - _t2862;
			_t2862 = _t2860.key_values.len;
			if (_t2863 < 0) {
				_t2861 = -1;
				continue;
			}
			if (!DenseArray_has_index(&_t2860.key_values, _t2861)) {continue;}
			string key = /*key*/ *(string*)DenseArray_key(&_t2860.key_values, _t2861);
			key = string_clone(key);
			v__ast__Fn f = (*(v__ast__Fn*)DenseArray_value(&_t2860.key_values, _t2861));
			if (string_ne(f.mod, _SLIT("main")) && string_ne(key, _SLIT("main"))) {
				continue;
			}
			map_set(&g->obf_table, &(string[]){key}, &(string[]) { _STR("_f%"PRId32"", 1, i) });
			i++;
		}
		// FOR IN array
		for (int _t2864 = 0; _t2864 < g->table->type_symbols.len; ++_t2864) {
			v__ast__TypeSymbol type_sym = ((v__ast__TypeSymbol*)g->table->type_symbols.data)[_t2864];
			if (string_ne(type_sym.mod, _SLIT("main"))) {
				continue;
			}
			// FOR IN array
			for (int _t2865 = 0; _t2865 < type_sym.methods.len; ++_t2865) {
				v__ast__Fn method = ((v__ast__Fn*)type_sym.methods.data)[_t2865];
				map_set(&g->obf_table, &(string[]){string_add(string_add(type_sym.name, _SLIT(".")), method.name)}, &(string[]) { _STR("_f%"PRId32"", 1, i) });
				i++;
			}
		}
	}
}

void v__gen__c__Gen_finish(v__gen__c__Gen* g) {
	if (g->pref->build_mode != v__pref__BuildMode_build_module) {
		strings__Builder_writeln(&g->stringliterals, _SLIT("}"));
	}
	strings__Builder_writeln(&g->stringliterals, _SLIT("// << string literal consts"));
	strings__Builder_writeln(&g->stringliterals, _SLIT(""));
	if (g->pref->is_prof && g->pref->build_mode != v__pref__BuildMode_build_module) {
		v__gen__c__Gen_gen_vprint_profile_stats(g);
	}
	if (g->pref->is_livemain || g->pref->is_liveshared) {
		v__gen__c__Gen_generate_hotcode_reloader_code(g);
	}
	if (v__gen__c__Gen_embed_file_is_prod_mode(g) && g->embedded_files.len > 0) {
		v__gen__c__Gen_gen_embedded_data(g);
	}
	if (g->pref->is_test) {
		v__gen__c__Gen_gen_c_main_for_tests(g);
	} else {
		v__gen__c__Gen_gen_c_main(g);
	}
}

void v__gen__c__Gen_write_typeof_functions(v__gen__c__Gen* g) {
	v__gen__c__Gen_writeln(g, _SLIT(""));
	v__gen__c__Gen_writeln(g, _SLIT("// >> typeof() support for sum types / interfaces"));
	// FOR IN array
	for (int _t2866 = 0; _t2866 < g->table->type_symbols.len; ++_t2866) {
		v__ast__TypeSymbol typ = ((v__ast__TypeSymbol*)g->table->type_symbols.data)[_t2866];
		if (typ.kind == v__ast__Kind_sum_type) {
			v__ast__SumType sum_info = /* as */ *(v__ast__SumType*)__as_cast((typ.info)._v__ast__SumType,(typ.info)._typ, 411) /*expected idx: 411, name: v.ast.SumType */ ;
			v__gen__c__Gen_writeln(g, _STR("static char * v_typeof_sumtype_%.*s\000(int sidx) { /* %.*s\000 */ ", 3, typ.cname, typ.name));
			if (g->pref->build_mode == v__pref__BuildMode_build_module) {
				v__gen__c__Gen_writeln(g, _STR("\t\tif( sidx == _v_type_idx_%.*s\000() ) return \"%.*s\000\";", 3, typ.cname, v__util__strip_main_name(typ.name)));
				// FOR IN array
				for (int _t2867 = 0; _t2867 < sum_info.variants.len; ++_t2867) {
					v__ast__Type v = ((v__ast__Type*)sum_info.variants.data)[_t2867];
					v__ast__TypeSymbol* subtype = v__ast__Table_get_type_symbol(g->table, v);
					v__gen__c__Gen_writeln(g, _STR("\tif( sidx == _v_type_idx_%.*s\000() ) return \"%.*s\000\";", 3, subtype->cname, v__util__strip_main_name(subtype->name)));
				}
				v__gen__c__Gen_writeln(g, _STR("\treturn \"unknown %.*s\000\";", 2, v__util__strip_main_name(typ.name)));
			} else {
				int tidx = v__ast__Table_find_type_idx(g->table, typ.name);
				v__gen__c__Gen_writeln(g, _SLIT("\tswitch(sidx) {"));
				v__gen__c__Gen_writeln(g, _STR("\t\tcase %"PRId32"\000: return \"%.*s\000\";", 3, tidx, v__util__strip_main_name(typ.name)));
				// FOR IN array
				for (int _t2868 = 0; _t2868 < sum_info.variants.len; ++_t2868) {
					v__ast__Type v = ((v__ast__Type*)sum_info.variants.data)[_t2868];
					v__ast__TypeSymbol* subtype = v__ast__Table_get_type_symbol(g->table, v);
					v__gen__c__Gen_writeln(g, _STR("\t\tcase %"PRId32"\000: return \"%.*s\000\";", 3, v, v__util__strip_main_name(subtype->name)));
				}
				v__gen__c__Gen_writeln(g, _STR("\t\tdefault: return \"unknown %.*s\000\";", 2, v__util__strip_main_name(typ.name)));
				v__gen__c__Gen_writeln(g, _SLIT("\t}"));
			}
			v__gen__c__Gen_writeln(g, _SLIT("}"));
		} else if (typ.kind == v__ast__Kind_interface_) {
			v__ast__Interface inter_info = /* as */ *(v__ast__Interface*)__as_cast((typ.info)._v__ast__Interface,(typ.info)._typ, 410) /*expected idx: 410, name: v.ast.Interface */ ;
			v__gen__c__Gen_writeln(g, _STR("static char * v_typeof_interface_%.*s\000(int sidx) { /* %.*s\000 */ ", 3, typ.cname, typ.name));
			// FOR IN array
			for (int _t2869 = 0; _t2869 < inter_info.types.len; ++_t2869) {
				v__ast__Type t = ((v__ast__Type*)inter_info.types.data)[_t2869];
				v__ast__TypeSymbol* subtype = v__ast__Table_get_type_symbol(g->table, t);
				v__gen__c__Gen_writeln(g, _STR("\tif (sidx == _%.*s\000_%.*s\000_index) return \"%.*s\000\";", 4, typ.cname, subtype->cname, v__util__strip_main_name(subtype->name)));
			}
			v__gen__c__Gen_writeln(g, _STR("\treturn \"unknown %.*s\000\";", 2, v__util__strip_main_name(typ.name)));
			v__gen__c__Gen_writeln(g, _SLIT("}"));
		}
	}
	v__gen__c__Gen_writeln(g, _SLIT("// << typeof() support for sum types"));
	v__gen__c__Gen_writeln(g, _SLIT(""));
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_typ(v__gen__c__Gen* g, v__ast__Type t) {
	string styp = v__gen__c__Gen_base_type(g, t);
	if (v__ast__Type_has_flag(t, v__ast__TypeFlag_optional)) {
		 string _t2870 = v__gen__c__Gen_register_optional(g, t);
		// autofree_scope_vars(pos=21332 line_nr=544 scope.pos=21276 scope.end_pos=21364)
		// af parent scope:
		// var "g" var.pos=21194 var.line_nr=540
		// var "t" var.pos=21205 var.line_nr=540
		// var "styp" var.pos=21227 var.line_nr=541
		// af parent scope:
		// af parent scope:
		return _t2870;
	}
	// autofree_scope_vars(pos=21426 line_nr=551 scope.pos=21189 scope.end_pos=21439)
	// var "g" var.pos=21194 var.line_nr=540
	// var "t" var.pos=21205 var.line_nr=540
	// var "styp" var.pos=21227 var.line_nr=541
	// af parent scope:
	// af parent scope:
	return styp;
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_base_type(v__gen__c__Gen* g, v__ast__Type t) {
	v__ast__ShareType share = v__ast__Type_share(t);
	string styp = (share == v__ast__ShareType_atomic_t ? (v__ast__Type_atomic_typename(t)) : (v__gen__c__Gen_cc_type(g, t, true)));
	if (v__ast__Type_has_flag(t, v__ast__TypeFlag_shared_f)) {
		styp = v__gen__c__Gen_find_or_register_shared(g, t, styp);
	}
	int nr_muls = v__ast__Type_nr_muls(t);
	if (nr_muls > 0) {
		styp = /*f*/string_add(styp, strings__repeat(L'*', nr_muls));
	}
	// autofree_scope_vars(pos=21754 line_nr=564 scope.pos=21445 scope.end_pos=21767)
	// var "g" var.pos=21450 var.line_nr=554
	// var "t" var.pos=21467 var.line_nr=554
	// var "share" var.pos=21489 var.line_nr=555
	// var "styp" var.pos=21513 var.line_nr=556
	// var "nr_muls" var.pos=21671 var.line_nr=560
	// af parent scope:
	// af parent scope:
	return styp;
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_expr_string(v__gen__c__Gen* g, v__ast__Expr expr) {
	int pos = g->out.len;
	v__gen__c__Gen_expr(g, expr);
	string expr_str = strings__Builder_after(&g->out, pos);
	strings__Builder_go_back(&g->out, expr_str.len);
	 string _t2871 = string_trim_space(expr_str);
	// autofree_scope_vars(pos=21912 line_nr=572 scope.pos=21773 scope.end_pos=21942)
	// var "g" var.pos=21778 var.line_nr=567
	// var "expr" var.pos=21797 var.line_nr=567
	// var "pos" var.pos=21822 var.line_nr=568
	// var "expr_str" var.pos=21854 var.line_nr=570
	// af parent scope:
	// af parent scope:
	return _t2871;
}

VV_LOCAL_SYMBOL multi_return_string_string v__gen__c__Gen_optional_type_name(v__gen__c__Gen* g, v__ast__Type t) {
	string base = v__gen__c__Gen_base_type(g, t);
	string styp = _STR("Option_%.*s", 1, base);
	if (v__ast__Type_is_ptr(t)) {
		styp = string_replace(styp, _SLIT("*"), _SLIT("_ptr"));
	}
	return (multi_return_string_string){.arg0=styp, .arg1=base};
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_optional_type_text(v__gen__c__Gen* g, string styp, string base) {
	string size = (string_eq(base, _SLIT("void")) ? (_SLIT("byte")) : (base));
	string ret = _STR("struct %.*s\000 {\n	byte state;\n	IError err;\n	byte data[sizeof(%.*s\000)];\n}", 3, styp, size);
	// autofree_scope_vars(pos=22553 line_nr=596 scope.pos=22321 scope.end_pos=22565)
	// var "g" var.pos=22322 var.line_nr=588
	// var "styp" var.pos=22349 var.line_nr=588
	// var "base" var.pos=22362 var.line_nr=588
	// var "size" var.pos=22422 var.line_nr=590
	// var "ret" var.pos=22474 var.line_nr=591
	// af parent scope:
	// af parent scope:
	return ret;
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_register_optional(v__gen__c__Gen* g, v__ast__Type t) {
	multi_return_string_string mr_22634 = v__gen__c__Gen_optional_type_name(g, t);
	string styp = mr_22634.arg0;
	string base = mr_22634.arg1;
	if (!(Array_string_contains(g->optionals, styp))) {
		strings__Builder_writeln(&g->typedefs2, _STR("typedef struct %.*s\000 %.*s\000;", 3, styp, styp));
		strings__Builder_write_string(&g->options, v__gen__c__Gen_optional_type_text(g, styp, base));
		strings__Builder_writeln(&g->options, _SLIT(";\n"));
		array_push(&g->optionals, _MOV((string[]){ string_clone(string_clone(styp)) }));
	}
	// autofree_scope_vars(pos=22860 line_nr=607 scope.pos=22571 scope.end_pos=22873)
	// var "g" var.pos=22576 var.line_nr=599
	// var "t" var.pos=22601 var.line_nr=599
	// var "styp" var.pos=22623 var.line_nr=600
	// var "base" var.pos=22629 var.line_nr=600
	// af parent scope:
	// af parent scope:
	return styp;
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_find_or_register_shared(v__gen__c__Gen* g, v__ast__Type t, string base) {
	string sh_typ = _STR("__shared__%.*s", 1, base);
	int t_idx = v__ast__Type_idx(t);
	if ((Array_int_contains(g->shareds, t_idx))) {
		// autofree_scope_vars(pos=23022 line_nr=614 scope.pos=23019 scope.end_pos=23038)
		// af parent scope:
		// var "g" var.pos=22884 var.line_nr=610
		// var "t" var.pos=22915 var.line_nr=610
		// var "base" var.pos=22927 var.line_nr=610
		// var "sh_typ" var.pos=22950 var.line_nr=611
		// var "t_idx" var.pos=22979 var.line_nr=612
		// var "mtx_typ" var.pos=23041 var.line_nr=616
		// af parent scope:
		// af parent scope:
		return sh_typ;
	}
	string mtx_typ = _SLIT("sync__RwMutex");
	strings__Builder_writeln(&g->shared_types, _STR("struct %.*s\000 { %.*s\000 val; %.*s\000 mtx; };", 4, sh_typ, base, mtx_typ));
	strings__Builder_writeln(&g->shared_functions, _STR("static inline voidptr __dup%.*s\000(voidptr src, int sz) {", 2, sh_typ));
	strings__Builder_writeln(&g->shared_functions, _STR("\t%.*s\000* dest = memdup(src, sz);", 2, sh_typ));
	strings__Builder_writeln(&g->shared_functions, _SLIT("\tsync__RwMutex_init(&dest->mtx);"));
	strings__Builder_writeln(&g->shared_functions, _SLIT("\treturn dest;"));
	strings__Builder_writeln(&g->shared_functions, _SLIT("}"));
	strings__Builder_writeln(&g->typedefs2, _STR("typedef struct %.*s\000 %.*s\000;", 3, sh_typ, sh_typ));
	array_push(&g->shareds, _MOV((int[]){ t_idx }));
	// autofree_scope_vars(pos=23563 line_nr=626 scope.pos=22879 scope.end_pos=23578)
	// var "g" var.pos=22884 var.line_nr=610
	// var "t" var.pos=22915 var.line_nr=610
	// var "base" var.pos=22927 var.line_nr=610
	// var "sh_typ" var.pos=22950 var.line_nr=611
	// var "t_idx" var.pos=22979 var.line_nr=612
	// var "mtx_typ" var.pos=23041 var.line_nr=616
	// str literal
	// af parent scope:
	// af parent scope:
	return sh_typ;
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_register_thread_array_wait_call(v__gen__c__Gen* g, string eltyp) {
	bool is_void = string_eq(eltyp, _SLIT("void"));
	string thread_typ = (is_void ? (_SLIT("__v_thread")) : (_STR("__v_thread_%.*s", 1, eltyp)));
	string ret_typ = (is_void ? (_SLIT("void")) : (_STR("Array_%.*s", 1, eltyp)));
	string thread_arr_typ = _STR("Array_%.*s", 1, thread_typ);
	string fn_name = _STR("%.*s\000_wait", 2, thread_arr_typ);
	if (!(Array_string_contains(g->waiter_fns, fn_name))) {
		array_push(&g->waiter_fns, _MOV((string[]){ string_clone(fn_name) }));
		if (is_void) {
			strings__Builder_writeln(&g->gowrappers, _STR("\nvoid %.*s\000(%.*s\000 a) {\n	for (int i = 0; i < a.len; ++i) {\n		%.*s\000 t = ((%.*s\000*)a.data)[i];\n		__v_thread_wait(t);\n	}\n}", 5, fn_name, thread_arr_typ, thread_typ, thread_typ));
		} else {
			strings__Builder_writeln(&g->gowrappers, _STR("\n%.*s\000 %.*s\000(%.*s\000 a) {\n	%.*s\000 res = __new_array_with_default(a.len, a.len, sizeof(%.*s\000), 0);\n	for (int i = 0; i < a.len; ++i) {\n		%.*s\000 t = ((%.*s\000*)a.data)[i];\n		((%.*s\000*)res.data)[i] = __v_thread_%.*s\000_wait(t);\n	}\n	return res;\n}", 10, ret_typ, fn_name, thread_arr_typ, ret_typ, eltyp, thread_typ, thread_typ, eltyp, eltyp));
		}
	}
	// autofree_scope_vars(pos=24445 line_nr=657 scope.pos=23584 scope.end_pos=24461)
	// var "g" var.pos=23589 var.line_nr=629
	// var "eltyp" var.pos=23628 var.line_nr=629
	// var "is_void" var.pos=23652 var.line_nr=630
	// var "thread_typ" var.pos=23680 var.line_nr=631
	// var "ret_typ" var.pos=23752 var.line_nr=632
	// var "thread_arr_typ" var.pos=23810 var.line_nr=633
	// var "fn_name" var.pos=23849 var.line_nr=634
	// af parent scope:
	// af parent scope:
	return fn_name;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_register_chan_pop_optional_call(v__gen__c__Gen* g, string opt_el_type, string styp) {
	if (!(Array_string_contains(g->chan_pop_optionals, opt_el_type))) {
		array_push(&g->chan_pop_optionals, _MOV((string[]){ string_clone(opt_el_type) }));
		strings__Builder_writeln(&g->channel_definitions, _STR("\nstatic inline %.*s\000 __Option_%.*s\000_popval(%.*s\000 ch) {\n	%.*s\000 _tmp = {0};\n	if (sync__Channel_try_pop_priv(ch, _tmp.data, false)) {\n		return (%.*s\000){ .state = 2, .err = v_error(_SLIT(\"channel closed\")) };\n	}\n	return _tmp;\n}", 6, opt_el_type, styp, styp, opt_el_type, opt_el_type));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_register_chan_push_optional_call(v__gen__c__Gen* g, string el_type, string styp) {
	if (!(Array_string_contains(g->chan_push_optionals, styp))) {
		array_push(&g->chan_push_optionals, _MOV((string[]){ string_clone(styp) }));
		v__gen__c__Gen_register_optional(g, v__ast__Type_set_flag(_const_v__ast__void_type, v__ast__TypeFlag_optional));
		strings__Builder_writeln(&g->channel_definitions, _STR("\nstatic inline Option_void __Option_%.*s\000_pushval(%.*s\000 ch, %.*s\000 e) {\n	if (sync__Channel_try_push_priv(ch, &e, false)) {\n		return (Option_void){ .state = 2, .err = v_error(_SLIT(\"channel closed\")) };\n	}\n	return (Option_void){0};\n}", 4, styp, styp, el_type));
	}
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_cc_type(v__gen__c__Gen* g, v__ast__Type typ, bool is_prefix_struct) {
	v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, v__gen__c__Gen_unwrap_generic(g, typ));
	string styp = sym->cname;
	if ((sym->info)._typ == 409 /* v.ast.Struct */) {
		if ((*sym->info._v__ast__Struct).generic_types.len > 0) {
			string sgtyps = _SLIT("_T");
			// FOR IN array
			for (int _t2877 = 0; _t2877 < (*sym->info._v__ast__Struct).generic_types.len; ++_t2877) {
				v__ast__Type gt = ((v__ast__Type*)(*sym->info._v__ast__Struct).generic_types.data)[_t2877];
				v__ast__TypeSymbol* gts = v__ast__Table_get_type_symbol(g->table, (v__ast__Type_has_flag(gt, v__ast__TypeFlag_generic) ? (v__gen__c__Gen_unwrap_generic(g, gt)) : (gt)));
				sgtyps = /*f*/string_add(sgtyps, _STR("_%.*s", 1, gts->cname));
			}
			styp = /*f*/string_add(styp, sgtyps);
		}
	} else if ((sym->info)._typ == 417 /* v.ast.MultiReturn */) {
		string cname = _SLIT("multi_return");
		// FOR IN array
		for (int _t2878 = 0; _t2878 < (*sym->info._v__ast__MultiReturn).types.len; ++_t2878) {
			v__ast__Type mr_typ = ((v__ast__Type*)(*sym->info._v__ast__MultiReturn).types.data)[_t2878];
			v__ast__TypeSymbol* mr_type_sym = v__ast__Table_get_type_symbol(g->table, v__gen__c__Gen_unwrap_generic(g, mr_typ));
			cname = /*f*/string_add(cname, _STR("_%.*s", 1, mr_type_sym->cname));
		}
		// autofree_scope_vars(pos=26285 line_nr=713 scope.pos=26047 scope.end_pos=26300)
		// var "cname" var.pos=26121 var.line_nr=708
		// str literal
		// af parent scope:
		// var "g" var.pos=25473 var.line_nr=689
		// var "typ" var.pos=25488 var.line_nr=689
		// var "is_prefix_struct" var.pos=25502 var.line_nr=689
		// var "sym" var.pos=25535 var.line_nr=690
		// var "styp" var.pos=25594 var.line_nr=691
		// af parent scope:
		// af parent scope:
		return cname;
	}
	if (is_prefix_struct && string_starts_with(styp, _SLIT("C__"))) {
		styp = string_substr(styp, 3, styp.len);
		if (sym->kind == v__ast__Kind_struct_) {
			v__ast__Struct info = /* as */ *(v__ast__Struct*)__as_cast((sym->info)._v__ast__Struct,(sym->info)._typ, 409) /*expected idx: 409, name: v.ast.Struct */ ;
			if (!info.is_typedef) {
				styp = _STR("struct %.*s", 1, styp);
			}
		}
	}
	// autofree_scope_vars(pos=26496 line_nr=724 scope.pos=25468 scope.end_pos=26509)
	// var "g" var.pos=25473 var.line_nr=689
	// var "typ" var.pos=25488 var.line_nr=689
	// var "is_prefix_struct" var.pos=25502 var.line_nr=689
	// var "sym" var.pos=25535 var.line_nr=690
	// var "styp" var.pos=25594 var.line_nr=691
	// af parent scope:
	// af parent scope:
	return styp;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL string v__gen__c__Gen_type_sidx(v__gen__c__Gen* g, v__ast__Type t) {
	if (g->pref->build_mode == v__pref__BuildMode_build_module) {
		v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, t);
		 string _t2879 = _STR("_v_type_idx_%.*s\000()", 2, sym->cname);
		// autofree_scope_vars(pos=26642 line_nr=731 scope.pos=26603 scope.end_pos=26680)
		// var "sym" var.pos=26607 var.line_nr=730
		// af parent scope:
		// var "g" var.pos=26525 var.line_nr=728
		// var "t" var.pos=26543 var.line_nr=728
		// af parent scope:
		// af parent scope:
		return _t2879;
	}
	 string _t2880 = _STR("%"PRId32"", 1, v__ast__Type_idx(t));
	// autofree_scope_vars(pos=26682 line_nr=733 scope.pos=26524 scope.end_pos=26701)
	// var "g" var.pos=26525 var.line_nr=728
	// var "t" var.pos=26543 var.line_nr=728
	// af parent scope:
	// af parent scope:
	return _t2880;
}

void v__gen__c__Gen_write_typedef_types(v__gen__c__Gen* g) {
	// FOR IN array
	for (int _t2881 = 0; _t2881 < g->table->type_symbols.len; ++_t2881) {
		v__ast__TypeSymbol typ = ((v__ast__TypeSymbol*)g->table->type_symbols.data)[_t2881];
		if ((Array_string_contains(_const_v__gen__c__builtins, typ.name))) {
			continue;
		}

		if (typ.kind == (v__ast__Kind_alias)) {
			v__ast__TypeSymbol* parent = &(*(v__ast__TypeSymbol*)/*ee elem_typ */array_get(g->table->type_symbols, typ.parent_idx));
			bool is_c_parent = parent->name.len > 2 && string_at(parent->name, 0) == L'C' && string_at(parent->name, 1) == L'.';
			bool is_typedef = false;
			if ((parent->info)._typ == 409 /* v.ast.Struct */) {
				is_typedef = (*parent->info._v__ast__Struct).is_typedef;
			}
			string parent_styp = parent->cname;
			if (is_c_parent) {
				if (!is_typedef) {
					parent_styp = string_add(_SLIT("struct "), string_substr(parent->cname, 3, parent->cname.len));
				} else {
					parent_styp = string_substr(parent->cname, 3, parent->cname.len);
				}
			} else {
				if ((typ.info)._typ == 413 /* v.ast.Alias */) {
					parent_styp = v__gen__c__Gen_typ(g, (*typ.info._v__ast__Alias).parent_type);
				}
			}
			strings__Builder_writeln(&g->type_definitions, _STR("typedef %.*s\000 %.*s\000;", 3, parent_styp, typ.cname));
		}
		else if (typ.kind == (v__ast__Kind_array)) {
			strings__Builder_writeln(&g->type_definitions, _STR("typedef array %.*s\000;", 2, typ.cname));
		}
		else if (typ.kind == (v__ast__Kind_array_fixed)) {
			v__ast__ArrayFixed info = /* as */ *(v__ast__ArrayFixed*)__as_cast((typ.info)._v__ast__ArrayFixed,(typ.info)._typ, 416) /*expected idx: 416, name: v.ast.ArrayFixed */ ;
			v__ast__TypeSymbol* elem_sym = v__ast__Table_get_type_symbol(g->table, info.elem_type);
			if (v__ast__TypeSymbol_is_builtin(elem_sym)) {
				string styp = typ.cname;
				string fixed = string_substr(styp, 12, styp.len);
				string len = string_after(styp, _SLIT("_"));
				fixed = string_substr(fixed, 0, fixed.len - len.len - 1);
				if (string_starts_with(fixed, _SLIT("C__"))) {
					fixed = string_substr(fixed, 3, fixed.len);
				}
				if ((elem_sym->info)._typ == 418 /* v.ast.FnType */) {
					int pos = g->out.len;
					v__gen__c__Gen_write_fn_ptr_decl(g, &(*elem_sym->info._v__ast__FnType), _SLIT(""));
					fixed = strings__Builder_after(&g->out, pos);
					strings__Builder_go_back(&g->out, fixed.len);
					string def_str = _STR("typedef %.*s\000;", 2, fixed);
					def_str = string_replace_once(def_str, _SLIT("(*)"), _STR("(*%.*s\000[%.*s\000])", 3, styp, len));
					strings__Builder_writeln(&g->type_definitions, def_str);
				} else {
					strings__Builder_writeln(&g->type_definitions, _STR("typedef %.*s\000 %.*s\000 [%.*s\000];", 4, fixed, styp, len));
				}
			}
		}
		else if (typ.kind == (v__ast__Kind_interface_)) {
			v__gen__c__Gen_write_interface_typesymbol_declaration(g, typ);
		}
		else if (typ.kind == (v__ast__Kind_chan)) {
			if (string_ne(typ.name, _SLIT("chan"))) {
				strings__Builder_writeln(&g->type_definitions, _STR("typedef chan %.*s\000;", 2, typ.cname));
				v__ast__Chan chan_inf = v__ast__TypeSymbol_chan_info(&typ);
				v__ast__Type chan_elem_type = chan_inf.elem_type;
				if (!v__ast__Type_has_flag(chan_elem_type, v__ast__TypeFlag_generic)) {
					string el_stype = v__gen__c__Gen_typ(g, chan_elem_type);
					strings__Builder_writeln(&g->channel_definitions, _STR("\nstatic inline %.*s\000 __%.*s\000_popval(%.*s\000 ch) {\n	%.*s\000 val;\n	sync__Channel_try_pop_priv(ch, &val, false);\n	return val;\n}", 5, el_stype, typ.cname, typ.cname, el_stype));
					strings__Builder_writeln(&g->channel_definitions, _STR("\nstatic inline void __%.*s\000_pushval(%.*s\000 ch, %.*s\000 val) {\n	sync__Channel_try_push_priv(ch, &val, false);\n}", 4, typ.cname, typ.cname, el_stype));
				}
			}
		}
		else if (typ.kind == (v__ast__Kind_map)) {
			strings__Builder_writeln(&g->type_definitions, _STR("typedef map %.*s\000;", 2, typ.cname));
		}
		else if (typ.kind == (v__ast__Kind_function)) {
			v__gen__c__Gen_write_fn_typesymbol_declaration(g, typ);
		}
		else {
			continue;
		};
	}
}

void v__gen__c__Gen_write_interface_typesymbol_declaration(v__gen__c__Gen* g, v__ast__TypeSymbol sym) {
	v__ast__Interface info = /* as */ *(v__ast__Interface*)__as_cast((sym.info)._v__ast__Interface,(sym.info)._typ, 410) /*expected idx: 410, name: v.ast.Interface */ ;
	strings__Builder_writeln(&g->type_definitions, _SLIT("typedef struct {"));
	strings__Builder_writeln(&g->type_definitions, _SLIT("\tunion {"));
	strings__Builder_writeln(&g->type_definitions, _SLIT("\t\tvoid* _object;"));
	// FOR IN array
	for (int _t2882 = 0; _t2882 < info.types.len; ++_t2882) {
		v__ast__Type variant = ((v__ast__Type*)info.types.data)[_t2882];
		string vcname = v__ast__Table_get_type_symbol(g->table, variant)->cname;
		strings__Builder_writeln(&g->type_definitions, _STR("\t\t%.*s\000* _%.*s\000;", 3, vcname, vcname));
	}
	strings__Builder_writeln(&g->type_definitions, _SLIT("\t};"));
	strings__Builder_writeln(&g->type_definitions, _SLIT("\tint _typ;"));
	// FOR IN array
	for (int _t2883 = 0; _t2883 < info.fields.len; ++_t2883) {
		v__ast__StructField field = ((v__ast__StructField*)info.fields.data)[_t2883];
		string styp = v__gen__c__Gen_typ(g, field.typ);
		string cname = v__gen__c__c_name(field.name);
		strings__Builder_writeln(&g->type_definitions, _STR("\t%.*s\000* %.*s\000;", 3, styp, cname));
	}
	strings__Builder_writeln(&g->type_definitions, _STR("} %.*s\000;", 2, v__gen__c__c_name(sym.name)));
}

void v__gen__c__Gen_write_fn_typesymbol_declaration(v__gen__c__Gen* g, v__ast__TypeSymbol sym) {
	v__ast__FnType info = /* as */ *(v__ast__FnType*)__as_cast((sym.info)._v__ast__FnType,(sym.info)._typ, 418) /*expected idx: 418, name: v.ast.FnType */ ;
	v__ast__Fn func = info.func;
	bool is_fn_sig = (func.name).len == 0;
	bool not_anon = !info.is_anon;
	if (!info.has_decl && (not_anon || is_fn_sig) && !v__ast__Type_has_flag(func.return_type, v__ast__TypeFlag_generic)) {
		string fn_name = sym.cname;
		strings__Builder_write_string(&g->type_definitions, _STR("typedef %.*s\000 (*%.*s\000)(", 3, v__gen__c__Gen_typ(g, func.return_type), fn_name));
		// FOR IN array
		for (int i = 0; i < func.params.len; ++i) {
			v__ast__Param param = ((v__ast__Param*)func.params.data)[i];
			strings__Builder_write_string(&g->type_definitions, v__gen__c__Gen_typ(g, param.typ));
			if (i < func.params.len - 1) {
				strings__Builder_write_string(&g->type_definitions, _SLIT(","));
			}
		}
		strings__Builder_writeln(&g->type_definitions, _SLIT(");"));
	}
}

void v__gen__c__Gen_write_multi_return_types(v__gen__c__Gen* g) {
	strings__Builder_writeln(&g->typedefs, _SLIT("\n// BEGIN_multi_return_typedefs"));
	strings__Builder_writeln(&g->type_definitions, _SLIT("\n// BEGIN_multi_return_structs"));
	// FOR IN array
	for (int _t2884 = 0; _t2884 < g->table->type_symbols.len; ++_t2884) {
		v__ast__TypeSymbol sym = ((v__ast__TypeSymbol*)g->table->type_symbols.data)[_t2884];
		if (sym.kind != v__ast__Kind_multi_return) {
			continue;
		}
		v__ast__MultiReturn info = v__ast__TypeSymbol_mr_info(&sym);
		Array_v__ast__Type _t2885_orig = info.types;
		int _t2885_len = _t2885_orig.len;
		Array_v__ast__Type _t2885 = __new_array(0, _t2885_len, sizeof(v__ast__Type));

		for (int _t2886 = 0; _t2886 < _t2885_len; ++_t2886) {
			v__ast__Type it = ((v__ast__Type*) _t2885_orig.data)[_t2886];
			if (v__ast__Type_has_flag(it, v__ast__TypeFlag_generic)) {
				array_push(&_t2885, &it); 
		}
		}
		
		if (_t2885.len > 0) {
			continue;
		}
		strings__Builder_writeln(&g->typedefs, _STR("typedef struct %.*s\000 %.*s\000;", 3, sym.cname, sym.cname));
		strings__Builder_writeln(&g->type_definitions, _STR("struct %.*s\000 {", 2, sym.cname));
		// FOR IN array
		for (int i = 0; i < info.types.len; ++i) {
			v__ast__Type mr_typ = ((v__ast__Type*)info.types.data)[i];
			string type_name = v__gen__c__Gen_typ(g, mr_typ);
			strings__Builder_writeln(&g->type_definitions, _STR("\t%.*s\000 arg%"PRId32"\000;", 3, type_name, i));
		}
		strings__Builder_writeln(&g->type_definitions, _SLIT("};\n"));
	}
	strings__Builder_writeln(&g->typedefs, _SLIT("// END_multi_return_typedefs\n"));
	strings__Builder_writeln(&g->type_definitions, _SLIT("// END_multi_return_structs\n"));
}

void v__gen__c__Gen_write(v__gen__c__Gen* g, string s) {
	if (g->indent > 0 && g->empty_line) {
		strings__Builder_write_string(&g->out, v__util__tabs(g->indent));
	}
	strings__Builder_write_string(&g->out, s);
	g->empty_line = false;
}

void v__gen__c__Gen_writeln(v__gen__c__Gen* g, string s) {
	if (g->indent > 0 && g->empty_line) {
		strings__Builder_write_string(&g->out, v__util__tabs(g->indent));
	}
	strings__Builder_writeln(&g->out, s);
	g->empty_line = true;
}

string v__gen__c__Gen_new_tmp_var(v__gen__c__Gen* g) {
	g->tmp_count++;
	 string _t2887 = _STR("_t%"PRId32"", 1, g->tmp_count);
	// autofree_scope_vars(pos=31857 line_nr=913 scope.pos=31807 scope.end_pos=31882)
	// var "g" var.pos=31812 var.line_nr=911
	// af parent scope:
	// af parent scope:
	return _t2887;
}

string v__gen__c__Gen_current_tmp_var(v__gen__c__Gen* g) {
	 string _t2888 = _STR("_t%"PRId32"", 1, g->tmp_count);
	// autofree_scope_vars(pos=31931 line_nr=917 scope.pos=31892 scope.end_pos=31956)
	// var "g" var.pos=31897 var.line_nr=916
	// af parent scope:
	// af parent scope:
	return _t2888;
}

void v__gen__c__Gen_reset_tmp_count(v__gen__c__Gen* g) {
	g->tmp_count = 0;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_decrement_inside_ternary(v__gen__c__Gen* g) {
	string key = int_str(g->inside_ternary);
	// FOR IN array
	Array_string _t2889 = (*(Array_string*)map_get(ADDR(map, g->ternary_level_names), &(string[]){key}, &(Array_string[]){ __new_array(0, 1, sizeof(string)) }));
	for (int _t2890 = 0; _t2890 < _t2889.len; ++_t2890) {
		string name = ((string*)_t2889.data)[_t2890];
		map_delete(&g->ternary_names, &(string[]){name});
	}
	map_delete(&g->ternary_level_names, &(string[]){key});
	g->inside_ternary--;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_stmts(v__gen__c__Gen* g, Array_v__ast__Stmt stmts) {
	v__gen__c__Gen_stmts_with_tmp_var(g, stmts, _SLIT(""));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_stmts_with_tmp_var(v__gen__c__Gen* g, Array_v__ast__Stmt stmts, string tmp_var) {
	g->indent++;
	if (g->inside_ternary > 0) {
		v__gen__c__Gen_write(g, _SLIT("("));
	}
	// FOR IN array
	for (int i = 0; i < stmts.len; ++i) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)stmts.data)[i];
		if (i == stmts.len - 1 && (tmp_var).len != 0) {
			if (g->inside_if_optional) {
				array_push(&g->stmt_path_pos, _MOV((int[]){ g->out.len }));
				g->skip_stmt_pos = true;
				if ((stmt)._typ == 293 /* v.ast.ExprStmt */) {
					if ((*stmt._v__ast__ExprStmt).typ == _const_v__ast__error_type_idx || ((*stmt._v__ast__ExprStmt).expr)._typ == 265 /* v.ast.None */) {
						v__gen__c__Gen_writeln(g, _STR("%.*s\000.state = 2;", 2, tmp_var));
						v__gen__c__Gen_write(g, _STR("%.*s\000.err = ", 2, tmp_var));
						v__gen__c__Gen_expr(g, (*stmt._v__ast__ExprStmt).expr);
						v__gen__c__Gen_writeln(g, _SLIT(";"));
					} else {
						string styp = v__gen__c__Gen_base_type(g, (*stmt._v__ast__ExprStmt).typ);
						v__gen__c__Gen_write(g, _STR("opt_ok(&(%.*s\000[]) { ", 2, styp));
						v__gen__c__Gen_stmt(g, stmt);
						v__gen__c__Gen_writeln(g, _STR(" }, (Option*)(&%.*s\000), sizeof(%.*s\000));", 3, tmp_var, styp));
					}
				}
			} else {
				array_push(&g->stmt_path_pos, _MOV((int[]){ g->out.len }));
				g->skip_stmt_pos = true;
				v__gen__c__Gen_write(g, _STR("%.*s\000 = ", 2, tmp_var));
				v__gen__c__Gen_stmt(g, stmt);
			}
		} else {
			v__gen__c__Gen_stmt(g, stmt);
			if (g->inside_if_optional && (stmt)._typ == 293 /* v.ast.ExprStmt */) {
				v__gen__c__Gen_writeln(g, _SLIT(";"));
			}
		}
		g->skip_stmt_pos = false;
		if (g->inside_ternary > 0 && i < stmts.len - 1) {
			v__gen__c__Gen_write(g, _SLIT(","));
		}
	}
	g->indent--;
	if (g->inside_ternary > 0) {
		v__gen__c__Gen_write(g, _SLIT(""));
		v__gen__c__Gen_write(g, _SLIT(")"));
	}
	if (g->is_autofree && !g->inside_vweb_tmpl && stmts.len > 0) {
		v__ast__Stmt stmt = (*(v__ast__Stmt*)/*ee elem_typ */array_get(stmts, 0));
		if ((stmt)._typ != 175 /* v.ast.FnDecl */ && g->inside_ternary == 0) {
			v__token__Position stmt_pos = (*(stmt.pos));
			if (stmt_pos.pos == 0) {
				if ((stmt)._typ == 304 /* v.ast.Module */) {
					return;
				}
				if ((stmt)._typ == 293 /* v.ast.ExprStmt */) {
					stmt_pos = v__ast__Expr_position((*stmt._v__ast__ExprStmt).expr);
				}
				if (stmt_pos.pos == 0) {
					return;
				}
			}
			v__gen__c__Gen_autofree_scope_vars(g, stmt_pos.pos - 1, stmt_pos.line_nr, false);
		}
	}
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL void v__gen__c__Gen_write_v_source_line_info(v__gen__c__Gen* g, v__token__Position pos) {
	if (g->inside_ternary == 0 && g->pref->is_vlines && g->is_vlines_enabled) {
		int nline = pos.line_nr + 1;
		string lineinfo = _STR("\n#line %"PRId32"\000 \"%.*s\000\"", 3, nline, g->vlines_path);
		v__gen__c__Gen_writeln(g, lineinfo);
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_stmt(v__gen__c__Gen* g, v__ast__Stmt node) {
bool v__gen__c__Gen_stmt_defer_0 = false;
	if (!g->skip_stmt_pos) {
		array_push(&g->stmt_path_pos, _MOV((int[]){ g->out.len }));
	}
	v__gen__c__Gen_stmt_defer_0 = true;
	if (node._typ == 291 /* v.ast.EmptyStmt */) {
	}
	else if (node._typ == 283 /* v.ast.AsmStmt */) {
		v__gen__c__Gen_write_v_source_line_info(g, (*node._v__ast__AsmStmt).pos);
		v__gen__c__Gen_gen_asm_stmt(g, (*node._v__ast__AsmStmt));
	}
	else if (node._typ == 284 /* v.ast.AssertStmt */) {
		v__gen__c__Gen_write_v_source_line_info(g, (*node._v__ast__AssertStmt).pos);
		v__gen__c__Gen_gen_assert_stmt(g, (*node._v__ast__AssertStmt));
	}
	else if (node._typ == 285 /* v.ast.AssignStmt */) {
		v__gen__c__Gen_write_v_source_line_info(g, (*node._v__ast__AssignStmt).pos);
		v__gen__c__Gen_gen_assign_stmt(g, (*node._v__ast__AssignStmt));
	}
	else if (node._typ == 286 /* v.ast.Block */) {
		if ((*node._v__ast__Block).is_unsafe) {
			v__gen__c__Gen_writeln(g, _SLIT("{ // Unsafe block"));
		} else {
			v__gen__c__Gen_writeln(g, _SLIT("{"));
		}
		v__gen__c__Gen_stmts(g, (*node._v__ast__Block).stmts);
		v__gen__c__Gen_writeln(g, _SLIT("}"));
	}
	else if (node._typ == 287 /* v.ast.BranchStmt */) {
		v__gen__c__Gen_write_v_source_line_info(g, (*node._v__ast__BranchStmt).pos);
		if (((*node._v__ast__BranchStmt).label).len != 0) {
			if ((*node._v__ast__BranchStmt).kind == v__token__Kind_key_break) {
				v__gen__c__Gen_writeln(g, _STR("goto %.*s\000__break;", 2, (*node._v__ast__BranchStmt).label));
			} else {
				v__gen__c__Gen_writeln(g, _STR("goto %.*s\000__continue;", 2, (*node._v__ast__BranchStmt).label));
			}
		} else {
			if (g->is_autofree && !g->is_builtin_mod) {
				v__gen__c__Gen_writeln(g, _SLIT("// free before continue/break"));
				v__gen__c__Gen_autofree_scope_vars_stop(g, (*node._v__ast__BranchStmt).pos.pos - 1, (*node._v__ast__BranchStmt).pos.line_nr, true, g->branch_parent_pos);
			}
			v__gen__c__Gen_writeln(g, _STR("%.*s\000;", 2, v__token__Kind_str((*node._v__ast__BranchStmt).kind)));
		}
	}
	else if (node._typ == 289 /* v.ast.ConstDecl */) {
		v__gen__c__Gen_write_v_source_line_info(g, (*node._v__ast__ConstDecl).pos);
		v__gen__c__Gen_const_decl(g, (*node._v__ast__ConstDecl));
	}
	else if (node._typ == 288 /* v.ast.CompFor */) {
		v__gen__c__Gen_comp_for(g, (*node._v__ast__CompFor));
	}
	else if (node._typ == 290 /* v.ast.DeferStmt */) {
		v__ast__DeferStmt defer_stmt = (*node._v__ast__DeferStmt);
		defer_stmt.ifdef = g->defer_ifdef;
		v__gen__c__Gen_writeln(g, _STR("%.*s\000 = true;", 2, v__gen__c__Gen_defer_flag_var(g, (voidptr)&/*qq*/defer_stmt)));
		array_push(&g->defer_stmts, _MOV((v__ast__DeferStmt[]){ defer_stmt }));
	}
	else if (node._typ == 292 /* v.ast.EnumDecl */) {
		string enum_name = v__util__no_dots((*node._v__ast__EnumDecl).name);
		bool is_flag = (*node._v__ast__EnumDecl).is_flag;
		strings__Builder_writeln(&g->enum_typedefs, _SLIT("typedef enum {"));
		string cur_enum_expr = _SLIT("");
		int cur_enum_offset = 0;
		// FOR IN array
		for (int i = 0; i < (*node._v__ast__EnumDecl).fields.len; ++i) {
			v__ast__EnumField field = ((v__ast__EnumField*)(*node._v__ast__EnumDecl).fields.data)[i];
			strings__Builder_write_string(&g->enum_typedefs, _STR("\t%.*s\000_%.*s", 2, enum_name, field.name));
			if (field.has_expr) {
				strings__Builder_write_string(&g->enum_typedefs, _SLIT(" = "));
				string expr_str = v__gen__c__Gen_expr_string(g, field.expr);
				strings__Builder_write_string(&g->enum_typedefs, expr_str);
				cur_enum_expr = expr_str;
				cur_enum_offset = 0;
			} else if (is_flag) {
				strings__Builder_write_string(&g->enum_typedefs, _SLIT(" = "));
				cur_enum_expr = _STR("1 << %"PRId32"", 1, i);
				strings__Builder_write_string(&g->enum_typedefs, int_literal_str((1 << i)));
				cur_enum_offset = 0;
			}
			string cur_value = (cur_enum_offset > 0 ? (_STR("%.*s\000+%"PRId32"", 2, cur_enum_expr, cur_enum_offset)) : (cur_enum_expr));
			strings__Builder_writeln(&g->enum_typedefs, _STR(", // %.*s", 1, cur_value));
			cur_enum_offset++;
		}
		strings__Builder_writeln(&g->enum_typedefs, _STR("} %.*s\000;\n", 2, enum_name));
	}
	else if (node._typ == 293 /* v.ast.ExprStmt */) {
		v__gen__c__Gen_write_v_source_line_info(g, (*node._v__ast__ExprStmt).pos);
		bool old_is_void_expr_stmt = g->is_void_expr_stmt;
		g->is_void_expr_stmt = !(*node._v__ast__ExprStmt).is_expr;
		v__gen__c__Gen_expr(g, (*node._v__ast__ExprStmt).expr);
		g->is_void_expr_stmt = old_is_void_expr_stmt;
		if (g->inside_ternary == 0 && !g->inside_if_optional && !(*node._v__ast__ExprStmt).is_expr && ((*node._v__ast__ExprStmt).expr)._typ != 255 /* v.ast.IfExpr */) {
			v__gen__c__Gen_writeln(g, _SLIT(";"));
		}
	}
	else if (node._typ == 175 /* v.ast.FnDecl */) {
		v__gen__c__Gen_process_fn_decl(g, (*node._v__ast__FnDecl));
	}
	else if (node._typ == 294 /* v.ast.ForCStmt */) {
		int prev_branch_parent_pos = g->branch_parent_pos;
		g->branch_parent_pos = (*node._v__ast__ForCStmt).pos.pos;
		v__gen__c__Gen_write_v_source_line_info(g, (*node._v__ast__ForCStmt).pos);
		v__gen__c__Gen_for_c_stmt(g, (*node._v__ast__ForCStmt));
		g->branch_parent_pos = prev_branch_parent_pos;
	}
	else if (node._typ == 295 /* v.ast.ForInStmt */) {
		int prev_branch_parent_pos = g->branch_parent_pos;
		g->branch_parent_pos = (*node._v__ast__ForInStmt).pos.pos;
		v__gen__c__Gen_write_v_source_line_info(g, (*node._v__ast__ForInStmt).pos);
		v__gen__c__Gen_for_in_stmt(g, (*node._v__ast__ForInStmt));
		g->branch_parent_pos = prev_branch_parent_pos;
	}
	else if (node._typ == 296 /* v.ast.ForStmt */) {
		int prev_branch_parent_pos = g->branch_parent_pos;
		g->branch_parent_pos = (*node._v__ast__ForStmt).pos.pos;
		v__gen__c__Gen_write_v_source_line_info(g, (*node._v__ast__ForStmt).pos);
		v__gen__c__Gen_for_stmt(g, (*node._v__ast__ForStmt));
		g->branch_parent_pos = prev_branch_parent_pos;
	}
	else if (node._typ == 297 /* v.ast.GlobalDecl */) {
		v__gen__c__Gen_global_decl(g, (*node._v__ast__GlobalDecl));
	}
	else if (node._typ == 298 /* v.ast.GoStmt */) {
		v__gen__c__Gen_go_stmt(g, (*node._v__ast__GoStmt), false);
	}
	else if (node._typ == 299 /* v.ast.GotoLabel */) {
		v__gen__c__Gen_writeln(g, _STR("%.*s\000: {}", 2, (*node._v__ast__GotoLabel).name));
	}
	else if (node._typ == 300 /* v.ast.GotoStmt */) {
		v__gen__c__Gen_writeln(g, _STR("goto %.*s\000;", 2, (*node._v__ast__GotoStmt).name));
	}
	else if (node._typ == 301 /* v.ast.HashStmt */) {
		if (string_eq((*node._v__ast__HashStmt).kind, _SLIT("include"))) {
			string missing_message = _STR("Header file %.*s\000, needed for module `%.*s\000` was not found.", 3, (*node._v__ast__HashStmt).main, (*node._v__ast__HashStmt).mod);
			if (((*node._v__ast__HashStmt).msg).len != 0) {
				missing_message = /*f*/string_add(missing_message, _STR(" %.*s\000.", 2, (*node._v__ast__HashStmt).msg));
			} else {
				missing_message = /*f*/string_add(missing_message, _SLIT(" Please install the corresponding development headers."));
			}
			string guarded_include = v__gen__c__get_guarded_include_text((*node._v__ast__HashStmt).main, missing_message);
			if (string_eq((*node._v__ast__HashStmt).main, _SLIT("<errno.h>"))) {
				guarded_include = _STR("#include %.*s", 1, (*node._v__ast__HashStmt).main);
			}
			if (string_contains((*node._v__ast__HashStmt).main, _SLIT(".m"))) {
				strings__Builder_writeln(&g->definitions, _STR("// added by module `%.*s\000`:", 2, (*node._v__ast__HashStmt).mod));
				strings__Builder_writeln(&g->definitions, guarded_include);
			} else {
				strings__Builder_writeln(&g->includes, _STR("// added by module `%.*s\000`:", 2, (*node._v__ast__HashStmt).mod));
				strings__Builder_writeln(&g->includes, guarded_include);
			}
		} else if (string_eq((*node._v__ast__HashStmt).kind, _SLIT("define"))) {
			strings__Builder_writeln(&g->includes, _STR("// defined by module `%.*s\000` in file `%.*s\000`:", 3, (*node._v__ast__HashStmt).mod, (*node._v__ast__HashStmt).source_file));
			strings__Builder_writeln(&g->includes, _STR("#define %.*s", 1, (*node._v__ast__HashStmt).main));
		}
	}
	else if (node._typ == 302 /* v.ast.Import */) {
	}
	else if (node._typ == 303 /* v.ast.InterfaceDecl */) {
	}
	else if (node._typ == 304 /* v.ast.Module */) {
		g->is_builtin_mod = (string_eq((*node._v__ast__Module).name, _SLIT("builtin")) || string_eq((*node._v__ast__Module).name, _SLIT("os")) || string_eq((*node._v__ast__Module).name, _SLIT("strconv")) || string_eq((*node._v__ast__Module).name, _SLIT("strings")) || string_eq((*node._v__ast__Module).name, _SLIT("gg")));
		g->cur_mod = (*node._v__ast__Module);
	}
	else if (node._typ == 264 /* v.ast.NodeError */) {
	}
	else if (node._typ == 305 /* v.ast.Return */) {
		v__gen__c__Gen_write_defer_stmts_when_needed(g);
		v__gen__c__Gen_return_stmt(g, (*node._v__ast__Return));
	}
	else if (node._typ == 306 /* v.ast.SqlStmt */) {
		v__gen__c__Gen_sql_stmt(g, (*node._v__ast__SqlStmt));
	}
	else if (node._typ == 307 /* v.ast.StructDecl */) {
		string name = ((*node._v__ast__StructDecl).language == v__ast__Language_c ? (v__util__no_dots((*node._v__ast__StructDecl).name)) : (v__gen__c__c_name((*node._v__ast__StructDecl).name)));
		if ((*node._v__ast__StructDecl).language == v__ast__Language_c) {
			// Defer begin
			if (v__gen__c__Gen_stmt_defer_0 == true) {
			}
			// Defer end
			return;
		}
		if ((*node._v__ast__StructDecl).is_union) {
			strings__Builder_writeln(&g->typedefs, _STR("typedef union %.*s\000 %.*s\000;", 3, name, name));
		} else {
			strings__Builder_writeln(&g->typedefs, _STR("typedef struct %.*s\000 %.*s\000;", 3, name, name));
		}
	}
	else if (node._typ == 232 /* v.ast.TypeDecl */) {
		if (!g->pref->skip_unused) {
			v__gen__c__Gen_writeln(g, _SLIT("// TypeDecl"));
		}
	};
	if (!g->skip_stmt_pos) {
		array_delete_last(&g->stmt_path_pos);
	}
	if (g->is_autofree) {
		if ((node)._typ != 175 /* v.ast.FnDecl */) {
		}
	}
// Defer begin
if (v__gen__c__Gen_stmt_defer_0 == true) {
}
// Defer end
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_write_defer_stmts(v__gen__c__Gen* g) {
	for (int i = g->defer_stmts.len - 1; i >= 0; i--) {
		v__ast__DeferStmt defer_stmt = (*(v__ast__DeferStmt*)/*ee elem_typ */array_get(g->defer_stmts, i));
		v__gen__c__Gen_writeln(g, _SLIT("// Defer begin"));
		v__gen__c__Gen_writeln(g, _STR("if (%.*s\000 == true) {", 2, v__gen__c__Gen_defer_flag_var(g, (voidptr)&/*qq*/defer_stmt)));
		g->indent++;
		if (defer_stmt.ifdef.len > 0) {
			v__gen__c__Gen_writeln(g, defer_stmt.ifdef);
			v__gen__c__Gen_stmts(g, defer_stmt.stmts);
			v__gen__c__Gen_writeln(g, _SLIT(""));
			v__gen__c__Gen_writeln(g, _SLIT("#endif"));
		} else {
			g->indent--;
			v__gen__c__Gen_stmts(g, defer_stmt.stmts);
			g->indent++;
		}
		g->indent--;
		v__gen__c__Gen_writeln(g, _SLIT("}"));
		v__gen__c__Gen_writeln(g, _SLIT("// Defer end"));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_for_c_stmt(v__gen__c__Gen* g, v__ast__ForCStmt node) {
	if (node.is_multi) {
		g->is_vlines_enabled = false;
		if (node.label.len > 0) {
			v__gen__c__Gen_writeln(g, _STR("%.*s\000:", 2, node.label));
		}
		v__gen__c__Gen_writeln(g, _SLIT("{"));
		g->indent++;
		if (node.has_init) {
			v__gen__c__Gen_stmt(g, node.init);
		}
		v__gen__c__Gen_writeln(g, _SLIT("bool _is_first = true;"));
		v__gen__c__Gen_writeln(g, _SLIT("while (true) {"));
		v__gen__c__Gen_writeln(g, _SLIT("\tif (_is_first) {"));
		v__gen__c__Gen_writeln(g, _SLIT("\t\t_is_first = false;"));
		v__gen__c__Gen_writeln(g, _SLIT("\t} else {"));
		if (node.has_inc) {
			g->indent++;
			v__gen__c__Gen_stmt(g, node.inc);
			v__gen__c__Gen_writeln(g, _SLIT(";"));
			g->indent--;
		}
		v__gen__c__Gen_writeln(g, _SLIT("}"));
		if (node.has_cond) {
			v__gen__c__Gen_write(g, _SLIT("if (!("));
			v__gen__c__Gen_expr(g, node.cond);
			v__gen__c__Gen_writeln(g, _SLIT(")) break;"));
		}
		g->is_vlines_enabled = true;
		v__gen__c__Gen_stmts(g, node.stmts);
		if (node.label.len > 0) {
			v__gen__c__Gen_writeln(g, _STR("%.*s\000__continue: {}", 2, node.label));
		}
		v__gen__c__Gen_writeln(g, _SLIT("}"));
		g->indent--;
		v__gen__c__Gen_writeln(g, _SLIT("}"));
		if (node.label.len > 0) {
			v__gen__c__Gen_writeln(g, _STR("%.*s\000__break: {}", 2, node.label));
		}
	} else {
		g->is_vlines_enabled = false;
		if (node.label.len > 0) {
			v__gen__c__Gen_writeln(g, _STR("%.*s\000:", 2, node.label));
		}
		v__gen__c__Gen_write(g, _SLIT("for ("));
		if (!node.has_init) {
			v__gen__c__Gen_write(g, _SLIT("; "));
		} else {
			v__gen__c__Gen_stmt(g, node.init);
			if (string_eq(strings__Builder_last_n(&g->out, 1), _SLIT("\n"))) {
				strings__Builder_go_back(&g->out, 1);
				g->empty_line = false;
				v__gen__c__Gen_write(g, _SLIT(" "));
			}
		}
		if (node.has_cond) {
			v__gen__c__Gen_expr(g, node.cond);
		}
		v__gen__c__Gen_write(g, _SLIT("; "));
		if (node.has_inc) {
			v__gen__c__Gen_stmt(g, node.inc);
		}
		v__gen__c__Gen_writeln(g, _SLIT(") {"));
		g->is_vlines_enabled = true;
		v__gen__c__Gen_stmts(g, node.stmts);
		if (node.label.len > 0) {
			v__gen__c__Gen_writeln(g, _STR("%.*s\000__continue: {}", 2, node.label));
		}
		v__gen__c__Gen_writeln(g, _SLIT("}"));
		if (node.label.len > 0) {
			v__gen__c__Gen_writeln(g, _STR("%.*s\000__break: {}", 2, node.label));
		}
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_for_stmt(v__gen__c__Gen* g, v__ast__ForStmt node) {
	g->is_vlines_enabled = false;
	if (node.label.len > 0) {
		v__gen__c__Gen_writeln(g, _STR("%.*s\000:", 2, node.label));
	}
	v__gen__c__Gen_writeln(g, _SLIT("for (;;) {"));
	if (!node.is_inf) {
		g->indent++;
		array_push(&g->stmt_path_pos, _MOV((int[]){ g->out.len }));
		v__gen__c__Gen_write(g, _SLIT("if (!("));
		v__gen__c__Gen_expr(g, node.cond);
		v__gen__c__Gen_writeln(g, _SLIT(")) break;"));
		g->indent--;
	}
	g->is_vlines_enabled = true;
	v__gen__c__Gen_stmts(g, node.stmts);
	if (node.label.len > 0) {
		v__gen__c__Gen_writeln(g, _STR("\t%.*s\000__continue: {}", 2, node.label));
	}
	v__gen__c__Gen_writeln(g, _SLIT("}"));
	if (node.label.len > 0) {
		v__gen__c__Gen_writeln(g, _STR("%.*s\000__break: {}", 2, node.label));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_for_in_stmt(v__gen__c__Gen* g, v__ast__ForInStmt node) {
	if (node.label.len > 0) {
		v__gen__c__Gen_writeln(g, _STR("\t%.*s\000: {}", 2, node.label));
	}
	if (node.is_range) {
		string i = (string_eq(node.val_var, _SLIT("_")) ? (v__gen__c__Gen_new_tmp_var(g)) : (v__gen__c__c_name(node.val_var)));
		v__gen__c__Gen_write(g, _STR("for (int %.*s\000 = ", 2, i));
		v__gen__c__Gen_expr(g, node.cond);
		v__gen__c__Gen_write(g, _STR("; %.*s\000 < ", 2, i));
		v__gen__c__Gen_expr(g, node.high);
		v__gen__c__Gen_writeln(g, _STR("; ++%.*s\000) {", 2, i));
	} else if (node.kind == v__ast__Kind_array) {
		v__gen__c__Gen_writeln(g, _SLIT("// FOR IN array"));
		string styp = v__gen__c__Gen_typ(g, node.val_type);
		v__ast__TypeSymbol* val_sym = v__ast__Table_get_type_symbol(g->table, node.val_type);
		string cond_var = _SLIT("");
		if ((node.cond)._typ == 254 /* v.ast.Ident */ || (node.cond)._typ == 273 /* v.ast.SelectorExpr */) {
			cond_var = v__gen__c__Gen_expr_string(g, node.cond);
		} else {
			cond_var = v__gen__c__Gen_new_tmp_var(g);
			v__gen__c__Gen_write(g, v__gen__c__Gen_typ(g, node.cond_type));
			v__gen__c__Gen_write(g, _STR(" %.*s\000 = ", 2, cond_var));
			v__gen__c__Gen_expr(g, node.cond);
			v__gen__c__Gen_writeln(g, _SLIT(";"));
		}
		string i = ((string_eq(node.key_var, _SLIT("")) || string_eq(node.key_var, _SLIT("_"))) ? (v__gen__c__Gen_new_tmp_var(g)) : (node.key_var));
		string field_accessor = (v__ast__Type_is_ptr(node.cond_type) ? (_SLIT("->")) : (_SLIT(".")));
		string share_accessor = (v__ast__Type_share(node.cond_type) == v__ast__ShareType_shared_t ? (_SLIT("val.")) : (_SLIT("")));
		string op_field = string_add(field_accessor, share_accessor);
		g->empty_line = true;
		v__gen__c__Gen_writeln(g, _STR("for (int %.*s\000 = 0; %.*s\000 < %.*s\000%.*s\000len; ++%.*s\000) {", 6, i, i, cond_var, op_field, i));
		if (string_ne(node.val_var, _SLIT("_"))) {
			if (val_sym->kind == v__ast__Kind_function) {
				v__gen__c__Gen_write(g, _SLIT("\t"));
				v__gen__c__Gen_write_fn_ptr_decl(g, (voidptr)&/*qq*//* as */ *(v__ast__FnType*)__as_cast((val_sym->info)._v__ast__FnType,(val_sym->info)._typ, 418) /*expected idx: 418, name: v.ast.FnType */ , v__gen__c__c_name(node.val_var));
				v__gen__c__Gen_writeln(g, _STR(" = ((voidptr*)%.*s\000%.*s\000data)[%.*s\000];", 4, cond_var, op_field, i));
			} else if (val_sym->kind == v__ast__Kind_array_fixed && !node.val_is_mut) {
				string right = _STR("((%.*s\000*)%.*s\000%.*s\000data)[%.*s\000]", 5, styp, cond_var, op_field, i);
				v__gen__c__Gen_writeln(g, _STR("\t%.*s\000 %.*s\000;", 3, styp, v__gen__c__c_name(node.val_var)));
				v__gen__c__Gen_writeln(g, _STR("\tmemcpy(*(%.*s\000*)%.*s\000, (byte*)%.*s\000, sizeof(%.*s\000));", 5, styp, v__gen__c__c_name(node.val_var), right, styp));
			} else {
				string right = (node.val_is_mut ? (_STR("((%.*s\000)%.*s\000%.*s\000data) + %.*s", 4, styp, cond_var, op_field, i)) : (_STR("((%.*s\000*)%.*s\000%.*s\000data)[%.*s\000]", 5, styp, cond_var, op_field, i)));
				v__gen__c__Gen_writeln(g, _STR("\t%.*s\000 %.*s\000 = %.*s\000;", 4, styp, v__gen__c__c_name(node.val_var), right));
			}
		}
	} else if (node.kind == v__ast__Kind_array_fixed) {
		string cond_var = _SLIT("");
		bool cond_type_is_ptr = v__ast__Type_is_ptr(node.cond_type);
		bool cond_is_literal = (node.cond)._typ == 235 /* v.ast.ArrayInit */;
		if (cond_is_literal) {
			cond_var = v__gen__c__Gen_new_tmp_var(g);
			v__gen__c__Gen_write(g, v__gen__c__Gen_typ(g, node.cond_type));
			v__gen__c__Gen_write(g, _STR(" %.*s\000 = ", 2, cond_var));
			v__gen__c__Gen_expr(g, node.cond);
			v__gen__c__Gen_writeln(g, _SLIT(";"));
		} else if (cond_type_is_ptr) {
			cond_var = v__gen__c__Gen_new_tmp_var(g);
			string cond_var_type = string_trim(v__gen__c__Gen_typ(g, node.cond_type), _SLIT("*"));
			if (!v__ast__Expr_is_lvalue(node.cond)) {
				v__gen__c__Gen_write(g, _STR("%.*s\000 *%.*s\000 = ((%.*s\000)", 4, cond_var_type, cond_var, cond_var_type));
			} else {
				v__gen__c__Gen_write(g, _STR("%.*s\000 *%.*s\000 = (", 3, cond_var_type, cond_var));
			}
			v__gen__c__Gen_expr(g, node.cond);
			v__gen__c__Gen_writeln(g, _SLIT(");"));
		} else {
			cond_var = v__gen__c__Gen_expr_string(g, node.cond);
		}
		string idx = ((string_eq(node.key_var, _SLIT("")) || string_eq(node.key_var, _SLIT("_"))) ? (v__gen__c__Gen_new_tmp_var(g)) : (node.key_var));
		v__ast__TypeSymbol* cond_sym = v__ast__Table_get_type_symbol(g->table, node.cond_type);
		v__ast__ArrayFixed info = /* as */ *(v__ast__ArrayFixed*)__as_cast((cond_sym->info)._v__ast__ArrayFixed,(cond_sym->info)._typ, 416) /*expected idx: 416, name: v.ast.ArrayFixed */ ;
		v__gen__c__Gen_writeln(g, _STR("for (int %.*s\000 = 0; %.*s\000 != %"PRId32"\000; ++%.*s\000) {", 5, idx, idx, info.size, idx));
		if (string_ne(node.val_var, _SLIT("_"))) {
			v__ast__TypeSymbol* val_sym = v__ast__Table_get_type_symbol(g->table, node.val_type);
			bool is_fixed_array = val_sym->kind == v__ast__Kind_array_fixed && !node.val_is_mut;
			if (val_sym->kind == v__ast__Kind_function) {
				v__gen__c__Gen_write(g, _SLIT("\t"));
				v__gen__c__Gen_write_fn_ptr_decl(g, (voidptr)&/*qq*//* as */ *(v__ast__FnType*)__as_cast((val_sym->info)._v__ast__FnType,(val_sym->info)._typ, 418) /*expected idx: 418, name: v.ast.FnType */ , v__gen__c__c_name(node.val_var));
			} else if (is_fixed_array) {
				string styp = v__gen__c__Gen_typ(g, node.val_type);
				v__gen__c__Gen_writeln(g, _STR("\t%.*s\000 %.*s\000;", 3, styp, v__gen__c__c_name(node.val_var)));
				v__gen__c__Gen_writeln(g, _STR("\tmemcpy(*(%.*s\000*)%.*s\000, (byte*)%.*s\000[%.*s\000], sizeof(%.*s\000));", 6, styp, v__gen__c__c_name(node.val_var), cond_var, idx, styp));
			} else {
				string styp = v__gen__c__Gen_typ(g, node.val_type);
				v__gen__c__Gen_write(g, _STR("\t%.*s\000 %.*s", 2, styp, v__gen__c__c_name(node.val_var)));
			}
			if (!is_fixed_array) {
				string addr = (node.val_is_mut ? (_SLIT("&")) : (_SLIT("")));
				if (cond_type_is_ptr) {
					v__gen__c__Gen_writeln(g, _STR(" = %.*s\000(*%.*s\000)[%.*s\000];", 4, addr, cond_var, idx));
				} else if (cond_is_literal) {
					v__gen__c__Gen_writeln(g, _STR(" = %.*s\000%.*s\000[%.*s\000];", 4, addr, cond_var, idx));
				} else {
					v__gen__c__Gen_write(g, _STR(" = %.*s", 1, addr));
					v__gen__c__Gen_expr(g, node.cond);
					v__gen__c__Gen_writeln(g, _STR("[%.*s\000];", 2, idx));
				}
			}
		}
	} else if (node.kind == v__ast__Kind_map) {
		v__gen__c__Gen_writeln(g, _SLIT("// FOR IN map"));
		string cond_var = _SLIT("");
		if ((node.cond)._typ == 254 /* v.ast.Ident */) {
			cond_var = v__gen__c__Gen_expr_string(g, node.cond);
		} else {
			cond_var = v__gen__c__Gen_new_tmp_var(g);
			v__gen__c__Gen_write(g, v__gen__c__Gen_typ(g, node.cond_type));
			v__gen__c__Gen_write(g, _STR(" %.*s\000 = ", 2, cond_var));
			v__gen__c__Gen_expr(g, node.cond);
			v__gen__c__Gen_writeln(g, _SLIT(";"));
		}
		string arw_or_pt = (v__ast__Type_is_ptr(node.cond_type) ? (_SLIT("->")) : (_SLIT(".")));
		string idx = v__gen__c__Gen_new_tmp_var(g);
		string map_len = v__gen__c__Gen_new_tmp_var(g);
		g->empty_line = true;
		v__gen__c__Gen_writeln(g, _STR("int %.*s\000 = %.*s\000%.*s\000key_values.len;", 4, map_len, cond_var, arw_or_pt));
		v__gen__c__Gen_writeln(g, _STR("for (int %.*s\000 = 0; %.*s\000 < %.*s\000; ++%.*s\000 ) {", 5, idx, idx, map_len, idx));
		g->indent++;
		string diff = v__gen__c__Gen_new_tmp_var(g);
		v__gen__c__Gen_writeln(g, _STR("int %.*s\000 = %.*s\000%.*s\000key_values.len - %.*s\000;", 5, diff, cond_var, arw_or_pt, map_len));
		v__gen__c__Gen_writeln(g, _STR("%.*s\000 = %.*s\000%.*s\000key_values.len;", 4, map_len, cond_var, arw_or_pt));
		v__gen__c__Gen_writeln(g, _STR("if (%.*s\000 < 0) {", 2, diff));
		v__gen__c__Gen_writeln(g, _STR("\t%.*s\000 = -1;", 2, idx));
		v__gen__c__Gen_writeln(g, _SLIT("\tcontinue;"));
		v__gen__c__Gen_writeln(g, _SLIT("}"));
		v__gen__c__Gen_writeln(g, _STR("if (!DenseArray_has_index(&%.*s\000%.*s\000key_values, %.*s\000)) {continue;}", 4, cond_var, arw_or_pt, idx));
		if (string_ne(node.key_var, _SLIT("_"))) {
			string key_styp = v__gen__c__Gen_typ(g, node.key_type);
			string key = v__gen__c__c_name(node.key_var);
			v__gen__c__Gen_writeln(g, _STR("%.*s\000 %.*s\000 = /*key*/ *(%.*s\000*)DenseArray_key(&%.*s\000%.*s\000key_values, %.*s\000);", 7, key_styp, key, key_styp, cond_var, arw_or_pt, idx));
			if (v__ast__Type_alias_eq(node.key_type, _const_v__ast__string_type)) {
				v__gen__c__Gen_writeln(g, _STR("%.*s\000 = string_clone(%.*s\000);", 3, key, key));
			}
		}
		if (string_ne(node.val_var, _SLIT("_"))) {
			v__ast__TypeSymbol* val_sym = v__ast__Table_get_type_symbol(g->table, node.val_type);
			if (val_sym->kind == v__ast__Kind_function) {
				v__gen__c__Gen_write_fn_ptr_decl(g, (voidptr)&/*qq*//* as */ *(v__ast__FnType*)__as_cast((val_sym->info)._v__ast__FnType,(val_sym->info)._typ, 418) /*expected idx: 418, name: v.ast.FnType */ , v__gen__c__c_name(node.val_var));
				v__gen__c__Gen_write(g, _SLIT(" = (*(voidptr*)"));
				v__gen__c__Gen_writeln(g, _STR("DenseArray_value(&%.*s\000%.*s\000key_values, %.*s\000));", 4, cond_var, arw_or_pt, idx));
			} else if (val_sym->kind == v__ast__Kind_array_fixed && !node.val_is_mut) {
				string val_styp = v__gen__c__Gen_typ(g, node.val_type);
				v__gen__c__Gen_writeln(g, _STR("%.*s\000 %.*s\000;", 3, val_styp, v__gen__c__c_name(node.val_var)));
				v__gen__c__Gen_writeln(g, _STR("memcpy(*(%.*s\000*)%.*s\000, (byte*)DenseArray_value(&%.*s\000%.*s\000key_values, %.*s\000), sizeof(%.*s\000));", 7, val_styp, v__gen__c__c_name(node.val_var), cond_var, arw_or_pt, idx, val_styp));
			} else {
				string val_styp = v__gen__c__Gen_typ(g, node.val_type);
				if (v__ast__Type_is_ptr(node.val_type)) {
					v__gen__c__Gen_write(g, _STR("%.*s\000 %.*s\000 = &(*(%.*s\000)", 4, val_styp, v__gen__c__c_name(node.val_var), val_styp));
				} else {
					v__gen__c__Gen_write(g, _STR("%.*s\000 %.*s\000 = (*(%.*s\000*)", 4, val_styp, v__gen__c__c_name(node.val_var), val_styp));
				}
				v__gen__c__Gen_writeln(g, _STR("DenseArray_value(&%.*s\000%.*s\000key_values, %.*s\000));", 4, cond_var, arw_or_pt, idx));
			}
		}
		g->indent--;
	} else if (node.kind == v__ast__Kind_string) {
		v__ast__Expr cond = ((node.cond)._typ == 277 /* v.ast.StringLiteral */ || (node.cond)._typ == 276 /* v.ast.StringInterLiteral */ ? (v__ast__CTempVar_to_sumtype_v__ast__Expr(ADDR(v__ast__CTempVar, (v__gen__c__Gen_new_ctemp_var_then_gen(g, node.cond, _const_v__ast__string_type))))) : (node.cond));
		string i = ((string_eq(node.key_var, _SLIT("")) || string_eq(node.key_var, _SLIT("_"))) ? (v__gen__c__Gen_new_tmp_var(g)) : (node.key_var));
		v__gen__c__Gen_write(g, _STR("for (int %.*s\000 = 0; %.*s\000 < ", 3, i, i));
		v__gen__c__Gen_expr(g, cond);
		v__gen__c__Gen_writeln(g, _STR(".len; ++%.*s\000) {", 2, i));
		if (string_ne(node.val_var, _SLIT("_"))) {
			v__gen__c__Gen_write(g, _STR("\tbyte %.*s\000 = ", 2, v__gen__c__c_name(node.val_var)));
			v__gen__c__Gen_expr(g, cond);
			v__gen__c__Gen_writeln(g, _STR(".str[%.*s\000];", 2, i));
		}
	} else if (node.kind == v__ast__Kind_struct_) {
		v__ast__TypeSymbol* cond_type_sym = v__ast__Table_get_type_symbol(g->table, node.cond_type);
		Option_v__ast__Fn _t2896 = v__ast__TypeSymbol_find_method(cond_type_sym, _SLIT("next"));
		if (_t2896.state != 0) { /*or block*/ 
			IError err = _t2896.err;
			v__gen__c__verror(_SLIT("`next` method not found"));
			return;
		}
 		v__ast__Fn next_fn =  *(v__ast__Fn*)_t2896.data;
		v__ast__Type ret_typ = next_fn.return_type;
		string t_expr = v__gen__c__Gen_new_tmp_var(g);
		v__gen__c__Gen_write(g, _STR("%.*s\000 %.*s\000 = ", 3, v__gen__c__Gen_typ(g, node.cond_type), t_expr));
		v__gen__c__Gen_expr(g, node.cond);
		v__gen__c__Gen_writeln(g, _SLIT(";"));
		v__gen__c__Gen_writeln(g, _SLIT("while (1) {"));
		string t_var = v__gen__c__Gen_new_tmp_var(g);
		v__ast__Type receiver_typ = (*(v__ast__Param*)/*ee elem_typ */array_get(next_fn.params, 0)).typ;
		string receiver_styp = v__gen__c__Gen_typ(g, receiver_typ);
		string fn_name = string_add(string_replace_each(receiver_styp, new_array_from_c_array(4, 4, sizeof(string), _MOV((string[4]){_SLIT("*"), _SLIT(""), _SLIT("."), _SLIT("__")}))), _SLIT("_next"));
		v__gen__c__Gen_write(g, _STR("\t%.*s\000 %.*s\000 = %.*s\000(", 4, v__gen__c__Gen_typ(g, ret_typ), t_var, fn_name));
		if (!v__ast__Type_is_ptr(node.cond_type) && v__ast__Type_is_ptr(receiver_typ)) {
			v__gen__c__Gen_write(g, _SLIT("&"));
		}
		v__gen__c__Gen_writeln(g, _STR("%.*s\000);", 2, t_expr));
		v__gen__c__Gen_writeln(g, _STR("\tif (%.*s\000.state != 0) break;", 2, t_var));
		string val = ((string_eq(node.val_var, _SLIT("")) || string_eq(node.val_var, _SLIT("_"))) ? (v__gen__c__Gen_new_tmp_var(g)) : (node.val_var));
		string val_styp = v__gen__c__Gen_typ(g, node.val_type);
		v__gen__c__Gen_writeln(g, _STR("\t%.*s\000 %.*s\000 = *(%.*s\000*)%.*s\000.data;", 5, val_styp, val, val_styp, t_var));
	} else {
		string typ_str = v__ast__Table_type_to_str(g->table, node.cond_type);
		v__gen__c__Gen_error(g, _STR("for in: unhandled symbol `%.*s\000` of type `%.*s\000`", 3, v__ast__Expr_str(node.cond), typ_str), node.pos);
	}
	v__gen__c__Gen_stmts(g, node.stmts);
	if (node.label.len > 0) {
		v__gen__c__Gen_writeln(g, _STR("\t%.*s\000__continue: {}", 2, node.label));
	}
	if (node.kind == v__ast__Kind_map) {
	}
	v__gen__c__Gen_writeln(g, _SLIT("}"));
	if (node.label.len > 0) {
		v__gen__c__Gen_writeln(g, _STR("\t%.*s\000__break: {}", 2, node.label));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_write_sumtype_casting_fn(v__gen__c__Gen* g, v__ast__Type got_, v__ast__Type exp_) {
	int got = v__ast__Type_idx(got_);
	int exp = v__ast__Type_idx(exp_);
	int i = (got | (exp << 16));
	if (got == exp || (*(bool*)map_get(ADDR(map, g->sumtype_definitions), &(int[]){i}, &(bool[]){ 0 }))) {
		return;
	}
	map_set(&g->sumtype_definitions, &(int[]){i}, &(bool[]) { true });
	v__ast__TypeSymbol* got_sym = v__ast__Table_get_type_symbol(g->table, got);
	v__ast__TypeSymbol* exp_sym = v__ast__Table_get_type_symbol(g->table, exp);
	strings__Builder sb = strings__new_builder(128);
	string got_cname = got_sym->cname;
	string exp_cname = exp_sym->cname;
	strings__Builder_writeln(&sb, _STR("static inline %.*s\000 %.*s\000_to_sumtype_%.*s\000(%.*s\000* x) {", 5, exp_cname, got_cname, exp_cname, got_cname));
	strings__Builder_writeln(&sb, _STR("\t%.*s\000* ptr = memdup(x, sizeof(%.*s\000));", 3, got_cname, got_cname));
	strings__Builder_write_string(&sb, _STR("\treturn (%.*s\000){ ._%.*s\000 = ptr, ._typ = %.*s", 3, exp_cname, got_cname, v__gen__c__Gen_type_sidx(g, got)));
	// FOR IN array
	for (int _t2897 = 0; _t2897 < (/* as */ *(v__ast__SumType*)__as_cast((exp_sym->info)._v__ast__SumType,(exp_sym->info)._typ, 411) /*expected idx: 411, name: v.ast.SumType */ ).fields.len; ++_t2897) {
		v__ast__StructField field = ((v__ast__StructField*)(/* as */ *(v__ast__SumType*)__as_cast((exp_sym->info)._v__ast__SumType,(exp_sym->info)._typ, 411) /*expected idx: 411, name: v.ast.SumType */ ).fields.data)[_t2897];
		string field_styp = v__gen__c__Gen_typ(g, field.typ);
		if ((got_sym->kind == v__ast__Kind_sum_type || got_sym->kind == v__ast__Kind_interface_)) {
			strings__Builder_write_string(&sb, _STR(", .%.*s\000 = ptr->%.*s", 2, field.name, field.name));
		} else {
			strings__Builder_write_string(&sb, _STR(", .%.*s\000 = (%.*s\000*)((char*)ptr + __offsetof_ptr(ptr, %.*s\000, %.*s\000))", 5, field.name, field_styp, got_cname, field.name));
		}
	}
	strings__Builder_writeln(&sb, _SLIT("};\n}"));
	array_push(&g->auto_fn_definitions, _MOV((string[]){ string_clone(strings__Builder_str(&sb)) }));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_expr_with_cast(v__gen__c__Gen* g, v__ast__Expr expr, v__ast__Type got_type_raw, v__ast__Type expected_type) {
	v__ast__Type got_type = v__ast__Table_mktyp(g->table, got_type_raw);
	v__ast__TypeSymbol* exp_sym = v__ast__Table_get_type_symbol(g->table, expected_type);
	bool expected_is_ptr = v__ast__Type_is_ptr(expected_type);
	bool got_is_ptr = v__ast__Type_is_ptr(got_type);
	v__ast__TypeSymbol* got_sym = v__ast__Table_get_type_symbol(g->table, got_type);
	if (got_type == _const_v__ast__error_type_idx && expected_type == _const_v__ast__string_type_idx) {
		v__gen__c__Gen_write(g, _SLIT("(*("));
		v__gen__c__Gen_expr(g, expr);
		v__gen__c__Gen_write(g, _SLIT(".msg))"));
		return;
	}
	if (exp_sym->kind == v__ast__Kind_interface_ && v__ast__Type_idx(got_type_raw) != v__ast__Type_idx(expected_type) && !v__ast__Type_has_flag(expected_type, v__ast__TypeFlag_optional)) {
		string got_styp = v__gen__c__Gen_cc_type(g, got_type, true);
		string exp_styp = v__gen__c__Gen_cc_type(g, expected_type, true);
		if (expected_is_ptr) {
			v__gen__c__Gen_write(g, _STR("HEAP(%.*s\000, ", 2, exp_styp));
		}
		v__gen__c__Gen_write(g, _STR("I_%.*s\000_to_Interface_%.*s\000(", 3, got_styp, exp_styp));
		if (!got_is_ptr) {
			v__gen__c__Gen_write(g, _SLIT("&"));
		}
		v__gen__c__Gen_expr(g, expr);
		v__gen__c__Gen_write(g, _SLIT(")"));
		if (expected_is_ptr) {
			v__gen__c__Gen_write(g, _SLIT(")"));
		}
		return;
	}
	string exp_styp = v__gen__c__Gen_typ(g, expected_type);
	string got_styp = v__gen__c__Gen_typ(g, got_type);
	if (!v__ast__Type_alias_eq(expected_type, _const_v__ast__void_type)) {
		v__ast__Type expected_deref_type = (expected_is_ptr ? (v__ast__Type_deref(expected_type)) : (expected_type));
		v__ast__Type got_deref_type = (got_is_ptr ? (v__ast__Type_deref(got_type)) : (got_type));
		if (v__ast__Table_sumtype_has_variant(g->table, expected_deref_type, got_deref_type)) {
			bool is_already_sum_type = false;
			v__ast__Scope* scope = v__ast__Scope_innermost(g->file.scope, v__ast__Expr_position(expr).pos);
			if ((expr)._typ == 254 /* v.ast.Ident */) {
				Option_v__ast__Var_ptr _t2899;
				if (_t2899 = v__ast__Scope_find_var(scope, (*expr._v__ast__Ident).name), _t2899.state == 0) {
					v__ast__Var* v = *(v__ast__Var**)_t2899.data;
					if (v->smartcasts.len > 0) {
						is_already_sum_type = true;
					}
				}
			} else if ((expr)._typ == 273 /* v.ast.SelectorExpr */) {
				Option_v__ast__ScopeStructField _t2900;
				if (_t2900 = v__ast__Scope_find_struct_field(scope, (*expr._v__ast__SelectorExpr).expr_type, (*expr._v__ast__SelectorExpr).field_name), _t2900.state == 0) {
					is_already_sum_type = true;
				}
			}
			if (is_already_sum_type) {
				g->prevent_sum_type_unwrapping_once = true;
				v__gen__c__Gen_expr(g, expr);
			} else {
				v__gen__c__Gen_write_sumtype_casting_fn(g, got_type, expected_type);
				if (expected_is_ptr) {
					v__gen__c__Gen_write(g, _STR("HEAP(%.*s\000, ", 2, exp_sym->cname));
				}
				v__gen__c__Gen_write(g, _STR("%.*s\000_to_sumtype_%.*s\000(", 3, got_sym->cname, exp_sym->cname));
				if (!got_is_ptr) {
					v__gen__c__Gen_write(g, _STR("ADDR(%.*s\000, (", 2, got_styp));
					v__gen__c__Gen_expr(g, expr);
					v__gen__c__Gen_write(g, _SLIT(")))"));
				} else {
					v__gen__c__Gen_expr(g, expr);
					v__gen__c__Gen_write(g, _SLIT(")"));
				}
				if (expected_is_ptr) {
					v__gen__c__Gen_write(g, _SLIT(")"));
				}
			}
			return;
		}
	}
	bool neither_void = !(_const_v__ast__voidptr_type == got_type || _const_v__ast__voidptr_type == expected_type);
	bool to_shared = v__ast__Type_has_flag(expected_type, v__ast__TypeFlag_shared_f) && !v__ast__Type_has_flag(got_type_raw, v__ast__TypeFlag_shared_f) && !v__ast__Type_has_flag(expected_type, v__ast__TypeFlag_optional);
	if (to_shared) {
		string shared_styp = string_substr(exp_styp, 0, exp_styp.len - 1);
		if (v__ast__Type_is_ptr(got_type_raw)) {
			v__gen__c__Gen_error(g, _SLIT("cannot convert reference to `shared`"), v__ast__Expr_position(expr));
		}
		if (exp_sym->kind == v__ast__Kind_array) {
			v__gen__c__Gen_writeln(g, _STR("(%.*s\000*)__dup_shared_array(&(%.*s\000){.val = ", 3, shared_styp, shared_styp));
		} else if (exp_sym->kind == v__ast__Kind_map) {
			v__gen__c__Gen_writeln(g, _STR("(%.*s\000*)__dup_shared_map(&(%.*s\000){.val = ", 3, shared_styp, shared_styp));
		} else {
			v__gen__c__Gen_writeln(g, _STR("(%.*s\000*)__dup%.*s\000(&(%.*s\000){.val = ", 4, shared_styp, shared_styp, shared_styp));
		}
		v__gen__c__Gen_expr(g, expr);
		v__gen__c__Gen_writeln(g, _STR("}, sizeof(%.*s\000))", 2, shared_styp));
		return;
	}
	if (got_is_ptr && !expected_is_ptr && neither_void && !(exp_sym->kind == v__ast__Kind_interface_ || exp_sym->kind == v__ast__Kind_placeholder) && (expr)._typ != 258 /* v.ast.InfixExpr */) {
		v__ast__Type got_deref_type = v__ast__Type_deref(got_type);
		v__ast__TypeSymbol* deref_sym = v__ast__Table_get_type_symbol(g->table, got_deref_type);
		bool deref_will_match = (expected_type == got_type || expected_type == got_deref_type || expected_type == deref_sym->parent_idx);
		bool got_is_opt = v__ast__Type_has_flag(got_type, v__ast__TypeFlag_optional);
		if (deref_will_match || got_is_opt) {
			v__gen__c__Gen_write(g, _SLIT("*"));
		}
	}
	if (v__ast__Type_has_flag(expected_type, v__ast__TypeFlag_optional) && (expr)._typ == 265 /* v.ast.None */) {
		v__gen__c__Gen_gen_optional_error(g, expected_type, expr);
		return;
	}
	v__gen__c__Gen_expr(g, expr);
}

VV_LOCAL_SYMBOL string v__gen__c__cestring(string s) {
	 string _t2901 = string_replace(string_replace(s, _SLIT("\\"), _SLIT("\\\\")), _SLIT("\""), _SLIT("'"));
	// autofree_scope_vars(pos=58182 line_nr=1794 scope.pos=58154 scope.end_pos=58232)
	// var "s" var.pos=58163 var.line_nr=1793
	// af parent scope:
	// af parent scope:
	return _t2901;
}

VV_LOCAL_SYMBOL string v__gen__c__ctoslit(string s) {
	 string _t2902 = string_add(string_add(_SLIT("_SLIT(\""), v__gen__c__cestring(s)), _SLIT("\")"));
	// autofree_scope_vars(pos=58335 line_nr=1799 scope.pos=58308 scope.end_pos=58374)
	// var "s" var.pos=58316 var.line_nr=1798
	// af parent scope:
	// af parent scope:
	return _t2902;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_attrs(v__gen__c__Gen* g, Array_v__ast__Attr attrs) {
	if (g->pref->skip_unused) {
		return;
	}
	// FOR IN array
	for (int _t2903 = 0; _t2903 < attrs.len; ++_t2903) {
		v__ast__Attr attr = ((v__ast__Attr*)attrs.data)[_t2903];
		v__gen__c__Gen_writeln(g, _STR("// Attr: [%.*s\000]", 2, attr.name));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_asm_stmt(v__gen__c__Gen* g, v__ast__AsmStmt stmt) {
	v__gen__c__Gen_write(g, _SLIT("__asm__"));
	if (stmt.is_volatile) {
		v__gen__c__Gen_write(g, _SLIT(" volatile"));
	}
	if (stmt.is_goto) {
		v__gen__c__Gen_write(g, _SLIT(" goto"));
	}
	v__gen__c__Gen_writeln(g, _SLIT(" ("));
	g->indent++;
	// FOR IN array
	for (int _t2904 = 0; _t2904 < stmt.templates.len; ++_t2904) {
		v__ast__AsmTemplate* v_template = ((v__ast__AsmTemplate*)stmt.templates.data) + _t2904;
		v__gen__c__Gen_write(g, _SLIT("\""));
		if (v_template->is_directive) {
			v__gen__c__Gen_write(g, _SLIT("."));
		}
		v__gen__c__Gen_write(g, v_template->name);
		if (v_template->is_label) {
			v__gen__c__Gen_write(g, _SLIT(":"));
		} else {
			v__gen__c__Gen_write(g, _SLIT(" "));
		}
		if (v_template->args.len != 0) {
			array_prepend(&v_template->args, &(v__ast__AsmArg[]){(*(v__ast__AsmArg*)/*ee elem_typ */array_get(v_template->args, v_template->args.len - 1))});
			array_delete(&v_template->args, v_template->args.len - 1);
		}
		// FOR IN array
		for (int i = 0; i < v_template->args.len; ++i) {
			v__ast__AsmArg arg = ((v__ast__AsmArg*)v_template->args.data)[i];
			v__gen__c__Gen_asm_arg(g, arg, stmt);
			if (i + 1 < v_template->args.len) {
				v__gen__c__Gen_write(g, _SLIT(", "));
			}
		}
		if (!v_template->is_label) {
			v__gen__c__Gen_write(g, _SLIT(";"));
		}
		v__gen__c__Gen_writeln(g, _SLIT("\""));
	}
	if (!stmt.is_top_level) {
		v__gen__c__Gen_write(g, _SLIT(": "));
	}
	v__gen__c__Gen_gen_asm_ios(g, stmt.output);
	if (stmt.input.len != 0 || stmt.clobbered.len != 0 || stmt.is_goto) {
		v__gen__c__Gen_write(g, _SLIT(": "));
	}
	v__gen__c__Gen_gen_asm_ios(g, stmt.input);
	if (stmt.clobbered.len != 0 || stmt.is_goto) {
		v__gen__c__Gen_write(g, _SLIT(": "));
	}
	// FOR IN array
	for (int i = 0; i < stmt.clobbered.len; ++i) {
		v__ast__AsmClobbered clob = ((v__ast__AsmClobbered*)stmt.clobbered.data)[i];
		v__gen__c__Gen_write(g, _SLIT("\""));
		v__gen__c__Gen_write(g, clob.reg.name);
		v__gen__c__Gen_write(g, _SLIT("\""));
		if (i + 1 < stmt.clobbered.len) {
			v__gen__c__Gen_writeln(g, _SLIT(","));
		} else {
			v__gen__c__Gen_writeln(g, _SLIT(""));
		}
	}
	if (stmt.is_goto) {
		v__gen__c__Gen_write(g, _SLIT(": "));
	}
	// FOR IN array
	for (int i = 0; i < stmt.global_labels.len; ++i) {
		string label = ((string*)stmt.global_labels.data)[i];
		v__gen__c__Gen_write(g, label);
		if (i + 1 < stmt.clobbered.len) {
			v__gen__c__Gen_writeln(g, _SLIT(","));
		} else {
			v__gen__c__Gen_writeln(g, _SLIT(""));
		}
	}
	g->indent--;
	v__gen__c__Gen_writeln(g, _SLIT(");"));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_asm_arg(v__gen__c__Gen* g, v__ast__AsmArg arg, v__ast__AsmStmt stmt) {
	if (arg._typ == 384 /* v.ast.AsmAlias */) {
		string name = (*arg._v__ast__AsmAlias).name;
		if ((Array_string_contains(stmt.local_labels, name)) || (Array_string_contains(stmt.global_labels, name)) || (Array_string_contains(g->file.global_labels, name))) {
			string asm_formatted_name = ((Array_string_contains(stmt.global_labels, name)) ? (_STR("%%l[%.*s\000]", 2, name)) : (name));
			v__gen__c__Gen_write(g, asm_formatted_name);
		} else {
			v__gen__c__Gen_write(g, _STR("%%[%.*s\000]", 2, name));
		}
	}
	else if (arg._typ == 244 /* v.ast.CharLiteral */) {
		v__gen__c__Gen_write(g, _STR("'%.*s\000'", 2, (*arg._v__ast__CharLiteral).val));
	}
	else if (arg._typ == 259 /* v.ast.IntegerLiteral */) {
		v__gen__c__Gen_write(g, _STR("$%.*s", 1, (*arg._v__ast__IntegerLiteral).val));
	}
	else if (arg._typ == 252 /* v.ast.FloatLiteral */) {
		v__gen__c__Gen_write(g, _STR("$%.*s", 1, (*arg._v__ast__FloatLiteral).val));
	}
	else if (arg._typ == 239 /* v.ast.BoolLiteral */) {
		v__gen__c__Gen_write(g, _STR("$%.*s", 1, bool_str((*arg._v__ast__BoolLiteral).val)));
	}
	else if (arg._typ == 309 /* v.ast.AsmRegister */) {
		if (!stmt.is_top_level) {
			v__gen__c__Gen_write(g, _SLIT("%"));
		}
		v__gen__c__Gen_write(g, _STR("%%%.*s", 1, (*arg._v__ast__AsmRegister).name));
	}
	else if (arg._typ == 383 /* v.ast.AsmAddressing */) {
		v__ast__AsmArg base = (*arg._v__ast__AsmAddressing).base;
		v__ast__AsmArg index = (*arg._v__ast__AsmAddressing).index;
		v__ast__AsmArg displacement = (*arg._v__ast__AsmAddressing).displacement;
		int scale = (*arg._v__ast__AsmAddressing).scale;

		if ((*arg._v__ast__AsmAddressing).mode == (v__ast__AddressingMode_base)) {
			v__gen__c__Gen_write(g, _SLIT("("));
			v__gen__c__Gen_asm_arg(g, base, stmt);
			v__gen__c__Gen_write(g, _SLIT(")"));
		}
		else if ((*arg._v__ast__AsmAddressing).mode == (v__ast__AddressingMode_displacement)) {
			v__gen__c__Gen_asm_arg(g, displacement, stmt);
			v__gen__c__Gen_write(g, _SLIT("()"));
		}
		else if ((*arg._v__ast__AsmAddressing).mode == (v__ast__AddressingMode_base_plus_displacement)) {
			v__gen__c__Gen_asm_arg(g, displacement, stmt);
			v__gen__c__Gen_write(g, _SLIT("("));
			v__gen__c__Gen_asm_arg(g, base, stmt);
			v__gen__c__Gen_write(g, _SLIT(")"));
		}
		else if ((*arg._v__ast__AsmAddressing).mode == (v__ast__AddressingMode_index_times_scale_plus_displacement)) {
			v__gen__c__Gen_asm_arg(g, displacement, stmt);
			v__gen__c__Gen_write(g, _SLIT("("));
			v__gen__c__Gen_asm_arg(g, index, stmt);
			v__gen__c__Gen_write(g, _STR(",%"PRId32"\000)", 2, scale));
		}
		else if ((*arg._v__ast__AsmAddressing).mode == (v__ast__AddressingMode_base_plus_index_plus_displacement)) {
			v__gen__c__Gen_asm_arg(g, displacement, stmt);
			v__gen__c__Gen_write(g, _SLIT("("));
			v__gen__c__Gen_asm_arg(g, base, stmt);
			v__gen__c__Gen_write(g, _SLIT(","));
			v__gen__c__Gen_asm_arg(g, index, stmt);
			v__gen__c__Gen_write(g, _SLIT(",1)"));
		}
		else if ((*arg._v__ast__AsmAddressing).mode == (v__ast__AddressingMode_base_plus_index_times_scale_plus_displacement)) {
			v__gen__c__Gen_asm_arg(g, displacement, stmt);
			v__gen__c__Gen_write(g, _SLIT("("));
			v__gen__c__Gen_asm_arg(g, base, stmt);
			v__gen__c__Gen_write(g, _SLIT(","));
			v__gen__c__Gen_asm_arg(g, index, stmt);
			v__gen__c__Gen_write(g, _STR(",%"PRId32"\000)", 2, scale));
		}
		else if ((*arg._v__ast__AsmAddressing).mode == (v__ast__AddressingMode_rip_plus_displacement)) {
			v__gen__c__Gen_asm_arg(g, displacement, stmt);
			v__gen__c__Gen_write(g, _SLIT("("));
			v__gen__c__Gen_asm_arg(g, base, stmt);
			v__gen__c__Gen_write(g, _SLIT(")"));
		}
		else if ((*arg._v__ast__AsmAddressing).mode == (v__ast__AddressingMode_invalid)) {
			v__gen__c__Gen_error(g, _SLIT("invalid addressing mode"), (*arg._v__ast__AsmAddressing).pos);
		};
	}
	else if (arg._typ == 385 /* v.ast.AsmDisp */) {
		v__gen__c__Gen_write(g, (*arg._v__ast__AsmDisp).val);
	}
	else if (arg._typ == 18 /* string */) {
		v__gen__c__Gen_write(g, _STR("%.*s", 1, (*arg._string)));
	};
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_asm_ios(v__gen__c__Gen* g, Array_v__ast__AsmIO ios) {
	// FOR IN array
	for (int i = 0; i < ios.len; ++i) {
		v__ast__AsmIO io = ((v__ast__AsmIO*)ios.data)[i];
		if ((io.alias).len != 0) {
			v__gen__c__Gen_write(g, _STR("[%.*s\000] ", 2, io.alias));
		}
		v__gen__c__Gen_write(g, _STR("\"%.*s\000\" (", 2, io.constraint));
		v__gen__c__Gen_expr(g, io.expr);
		v__gen__c__Gen_write(g, _SLIT(")"));
		if (i + 1 < ios.len) {
			v__gen__c__Gen_writeln(g, _SLIT(","));
		} else {
			v__gen__c__Gen_writeln(g, _SLIT(""));
		}
	}
}

VV_LOCAL_SYMBOL string v__gen__c__cnewlines(string s) {
	 string _t2905 = string_replace(s, _SLIT("\n"), _SLIT("\\n"));
	// autofree_scope_vars(pos=62193 line_nr=1993 scope.pos=62164 scope.end_pos=62224)
	// var "s" var.pos=62174 var.line_nr=1992
	// af parent scope:
	// af parent scope:
	return _t2905;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_write_fn_ptr_decl(v__gen__c__Gen* g, v__ast__FnType* func, string ptr_name) {
	string ret_styp = v__gen__c__Gen_typ(g, func->func.return_type);
	v__gen__c__Gen_write(g, _STR("%.*s\000 (*%.*s\000) (", 3, ret_styp, ptr_name));
	int arg_len = func->func.params.len;
	// FOR IN array
	for (int i = 0; i < func->func.params.len; ++i) {
		v__ast__Param arg = ((v__ast__Param*)func->func.params.data)[i];
		string arg_styp = v__gen__c__Gen_typ(g, arg.typ);
		v__gen__c__Gen_write(g, _STR("%.*s\000 %.*s", 2, arg_styp, arg.name));
		if (i < arg_len - 1) {
			v__gen__c__Gen_write(g, _SLIT(", "));
		}
	}
	v__gen__c__Gen_write(g, _SLIT(")"));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_assign_stmt(v__gen__c__Gen* g, v__ast__AssignStmt assign_stmt) {
bool v__gen__c__Gen_gen_assign_stmt_defer_0 = false;
	if (assign_stmt.is_static) {
		v__gen__c__Gen_write(g, _SLIT("static "));
	}
	v__ast__Type return_type = _const_v__ast__void_type;
	bool is_decl = assign_stmt.op == v__token__Kind_decl_assign;
	v__token__Kind op = (is_decl ? (v__token__Kind_assign) : (assign_stmt.op));
	v__ast__Expr right_expr = (*(v__ast__Expr*)/*ee elem_typ */array_get(assign_stmt.right, 0));
	if (right_expr._typ == 241 /* v.ast.CallExpr */) {
		return_type = (*right_expr._v__ast__CallExpr).return_type;
	}
	else if (right_expr._typ == 261 /* v.ast.LockExpr */) {
		return_type = (*right_expr._v__ast__LockExpr).typ;
	}
	else if (right_expr._typ == 263 /* v.ast.MatchExpr */) {
		return_type = (*right_expr._v__ast__MatchExpr).return_type;
	}
	else if (right_expr._typ == 255 /* v.ast.IfExpr */) {
		return_type = (*right_expr._v__ast__IfExpr).typ;
	}
	else {
	};
	bool af = g->is_autofree && !g->is_builtin_mod && assign_stmt.op == v__token__Kind_assign && assign_stmt.left_types.len == 1 && (((*(v__ast__Expr*)/*ee elem_typ */array_get(assign_stmt.left, 0)))._typ == 254 /* v.ast.Ident */ || ((*(v__ast__Expr*)/*ee elem_typ */array_get(assign_stmt.left, 0)))._typ == 273 /* v.ast.SelectorExpr */);
	string sref_name = _SLIT("");
	string type_to_free = _SLIT("");
	if (af) {
		v__ast__Type first_left_type = (*(v__ast__Type*)/*ee elem_typ */array_get(assign_stmt.left_types, 0));
		v__ast__TypeSymbol* first_left_sym = v__ast__Table_get_type_symbol(g->table, (*(v__ast__Type*)/*ee elem_typ */array_get(assign_stmt.left_types, 0)));
		if (v__ast__Type_alias_eq(first_left_type, _const_v__ast__string_type) || first_left_sym->kind == v__ast__Kind_array) {
			type_to_free = (v__ast__Type_alias_eq(first_left_type, _const_v__ast__string_type) ? (_SLIT("string")) : (_SLIT("array")));
			bool ok = true;
			v__ast__Expr left0 = (*(v__ast__Expr*)/*ee elem_typ */array_get(assign_stmt.left, 0));
			if ((left0)._typ == 254 /* v.ast.Ident */) {
				if (string_eq((*left0._v__ast__Ident).name, _SLIT("_"))) {
					ok = false;
				}
			}
			if (ok) {
				sref_name = _STR("_sref%"PRId32"", 1, assign_stmt.pos.pos);
				v__gen__c__Gen_write(g, _STR("%.*s\000 %.*s\000 = (", 3, type_to_free, sref_name));
				v__gen__c__Gen_expr(g, left0);
				v__gen__c__Gen_writeln(g, _STR("); // free %.*s\000 on re-assignment2", 2, type_to_free));
				v__gen__c__Gen_gen_assign_stmt_defer_0 = true;
			} else {
				af = false;
			}
		} else {
			af = false;
		}
	}
	if (!v__ast__Type_alias_eq(return_type, _const_v__ast__void_type) && return_type != 0) {
		v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, return_type);
		if (sym->kind == v__ast__Kind_multi_return) {
			bool is_opt = v__ast__Type_has_flag(return_type, v__ast__TypeFlag_optional);
			string mr_var_name = _STR("mr_%"PRId32"", 1, assign_stmt.pos.pos);
			string mr_styp = v__gen__c__Gen_typ(g, return_type);
			v__gen__c__Gen_write(g, _STR("%.*s\000 %.*s\000 = ", 3, mr_styp, mr_var_name));
			v__gen__c__Gen_expr(g, (*(v__ast__Expr*)/*ee elem_typ */array_get(assign_stmt.right, 0)));
			v__gen__c__Gen_writeln(g, _SLIT(";"));
			// FOR IN array
			for (int i = 0; i < assign_stmt.left.len; ++i) {
				v__ast__Expr lx = ((v__ast__Expr*)assign_stmt.left.data)[i];
				if ((lx)._typ == 254 /* v.ast.Ident */) {
					if ((*lx._v__ast__Ident).kind == v__ast__IdentKind_blank_ident) {
						continue;
					}
				}
				string styp = v__gen__c__Gen_typ(g, (*(v__ast__Type*)/*ee elem_typ */array_get(assign_stmt.left_types, i)));
				if (assign_stmt.op == v__token__Kind_decl_assign) {
					v__gen__c__Gen_write(g, _STR("%.*s\000 ", 2, styp));
				}
				v__gen__c__Gen_expr(g, lx);
				if (is_opt) {
					string mr_base_styp = v__gen__c__Gen_base_type(g, return_type);
					v__gen__c__Gen_writeln(g, _STR(" = (*(%.*s\000*)%.*s\000.data).arg%"PRId32"\000;", 4, mr_base_styp, mr_var_name, i));
				} else {
					v__gen__c__Gen_writeln(g, _STR(" = %.*s\000.arg%"PRId32"\000;", 3, mr_var_name, i));
				}
			}
			// Defer begin
			if (v__gen__c__Gen_gen_assign_stmt_defer_0 == true) {
				if (af) {
					v__gen__c__Gen_writeln(g, _STR("%.*s\000_free(&%.*s\000);", 3, type_to_free, sref_name));
				}
			}
			// Defer end
			return;
		}
	}
	if (assign_stmt.has_cross_var) {
		// FOR IN array
		for (int i = 0; i < assign_stmt.left.len; ++i) {
			v__ast__Expr left = ((v__ast__Expr*)assign_stmt.left.data)[i];
			if (left._typ == 254 /* v.ast.Ident */) {
				v__ast__Type left_typ = (*(v__ast__Type*)/*ee elem_typ */array_get(assign_stmt.left_types, i));
				v__ast__TypeSymbol* left_sym = v__ast__Table_get_type_symbol(g->table, left_typ);
				if (left_sym->kind == v__ast__Kind_function) {
					v__gen__c__Gen_write_fn_ptr_decl(g, (voidptr)&/*qq*//* as */ *(v__ast__FnType*)__as_cast((left_sym->info)._v__ast__FnType,(left_sym->info)._typ, 418) /*expected idx: 418, name: v.ast.FnType */ , _STR("_var_%"PRId32"", 1, (*left._v__ast__Ident).pos.pos));
					v__gen__c__Gen_writeln(g, _STR(" = %.*s\000;", 2, (*left._v__ast__Ident).name));
				} else {
					string styp = v__gen__c__Gen_typ(g, left_typ);
					v__gen__c__Gen_writeln(g, _STR("%.*s\000 _var_%"PRId32"\000 = %.*s\000;", 4, styp, (*left._v__ast__Ident).pos.pos, (*left._v__ast__Ident).name));
				}
			}
			else if (left._typ == 257 /* v.ast.IndexExpr */) {
				v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, (*left._v__ast__IndexExpr).left_type);
				if (sym->kind == v__ast__Kind_array) {
					v__ast__Array info = /* as */ *(v__ast__Array*)__as_cast((sym->info)._v__ast__Array,(sym->info)._typ, 395) /*expected idx: 395, name: v.ast.Array */ ;
					v__ast__TypeSymbol* elem_typ = v__ast__Table_get_type_symbol(g->table, info.elem_type);
					if (elem_typ->kind == v__ast__Kind_function) {
						v__ast__Type left_typ = (*(v__ast__Type*)/*ee elem_typ */array_get(assign_stmt.left_types, i));
						v__ast__TypeSymbol* left_sym = v__ast__Table_get_type_symbol(g->table, left_typ);
						v__gen__c__Gen_write_fn_ptr_decl(g, (voidptr)&/*qq*//* as */ *(v__ast__FnType*)__as_cast((left_sym->info)._v__ast__FnType,(left_sym->info)._typ, 418) /*expected idx: 418, name: v.ast.FnType */ , _STR("_var_%"PRId32"", 1, (*left._v__ast__IndexExpr).pos.pos));
						v__gen__c__Gen_write(g, _SLIT(" = *(voidptr*)array_get("));
					} else {
						string styp = v__gen__c__Gen_typ(g, info.elem_type);
						v__gen__c__Gen_write(g, _STR("%.*s\000 _var_%"PRId32"\000 = *(%.*s\000*)array_get(", 4, styp, (*left._v__ast__IndexExpr).pos.pos, styp));
					}
					if (v__ast__Type_is_ptr((*left._v__ast__IndexExpr).left_type)) {
						v__gen__c__Gen_write(g, _SLIT("*"));
					}
					bool needs_clone = v__ast__Type_alias_eq(info.elem_type, _const_v__ast__string_type) && g->is_autofree;
					if (needs_clone) {
						v__gen__c__Gen_write(g, _SLIT("/*1*/string_clone("));
					}
					v__gen__c__Gen_expr(g, (*left._v__ast__IndexExpr).left);
					if (needs_clone) {
						v__gen__c__Gen_write(g, _SLIT(")"));
					}
					v__gen__c__Gen_write(g, _SLIT(", "));
					v__gen__c__Gen_expr(g, (*left._v__ast__IndexExpr).index);
					v__gen__c__Gen_writeln(g, _SLIT(");"));
				} else if (sym->kind == v__ast__Kind_map) {
					v__ast__Map info = /* as */ *(v__ast__Map*)__as_cast((sym->info)._v__ast__Map,(sym->info)._typ, 396) /*expected idx: 396, name: v.ast.Map */ ;
					string skeytyp = v__gen__c__Gen_typ(g, info.key_type);
					string styp = v__gen__c__Gen_typ(g, info.value_type);
					string zero = v__gen__c__Gen_type_default(g, info.value_type);
					v__ast__TypeSymbol* val_typ = v__ast__Table_get_type_symbol(g->table, info.value_type);
					if (val_typ->kind == v__ast__Kind_function) {
						v__ast__Type left_type = (*(v__ast__Type*)/*ee elem_typ */array_get(assign_stmt.left_types, i));
						v__ast__TypeSymbol* left_sym = v__ast__Table_get_type_symbol(g->table, left_type);
						v__gen__c__Gen_write_fn_ptr_decl(g, (voidptr)&/*qq*//* as */ *(v__ast__FnType*)__as_cast((left_sym->info)._v__ast__FnType,(left_sym->info)._typ, 418) /*expected idx: 418, name: v.ast.FnType */ , _STR("_var_%"PRId32"", 1, (*left._v__ast__IndexExpr).pos.pos));
						v__gen__c__Gen_write(g, _SLIT(" = *(voidptr*)map_get("));
					} else {
						v__gen__c__Gen_write(g, _STR("%.*s\000 _var_%"PRId32"\000 = *(%.*s\000*)map_get(", 4, styp, (*left._v__ast__IndexExpr).pos.pos, styp));
					}
					if (!v__ast__Type_is_ptr((*left._v__ast__IndexExpr).left_type)) {
						v__gen__c__Gen_write(g, _SLIT("ADDR(map, "));
						v__gen__c__Gen_expr(g, (*left._v__ast__IndexExpr).left);
						v__gen__c__Gen_write(g, _SLIT(")"));
					} else {
						v__gen__c__Gen_expr(g, (*left._v__ast__IndexExpr).left);
					}
					v__gen__c__Gen_write(g, _STR(", &(%.*s\000[]){", 2, skeytyp));
					v__gen__c__Gen_expr(g, (*left._v__ast__IndexExpr).index);
					v__gen__c__Gen_write(g, _SLIT("}"));
					if (val_typ->kind == v__ast__Kind_function) {
						v__gen__c__Gen_writeln(g, _STR(", &(voidptr[]){ %.*s\000 });", 2, zero));
					} else {
						v__gen__c__Gen_writeln(g, _STR(", &(%.*s\000[]){ %.*s\000 });", 3, styp, zero));
					}
				}
			}
			else if (left._typ == 273 /* v.ast.SelectorExpr */) {
				string styp = v__gen__c__Gen_typ(g, (*left._v__ast__SelectorExpr).typ);
				v__gen__c__Gen_write(g, _STR("%.*s\000 _var_%"PRId32"\000 = ", 3, styp, (*left._v__ast__SelectorExpr).pos.pos));
				v__gen__c__Gen_expr(g, (*left._v__ast__SelectorExpr).expr);
				if (v__ast__Type_is_ptr((*left._v__ast__SelectorExpr).expr_type)) {
					v__gen__c__Gen_write(g, _SLIT("/* left.expr_type */"));
					v__gen__c__Gen_writeln(g, _STR("->%.*s\000;", 2, (*left._v__ast__SelectorExpr).field_name));
				} else {
					v__gen__c__Gen_writeln(g, _STR(".%.*s\000;", 2, (*left._v__ast__SelectorExpr).field_name));
				}
			}
			else {
			};
		}
	}
	// FOR IN array
	for (int i = 0; i < assign_stmt.left.len; ++i) {
		v__ast__Expr left = ((v__ast__Expr*)assign_stmt.left.data)[i];
		v__ast__Type var_type = (*(v__ast__Type*)/*ee elem_typ */array_get(assign_stmt.left_types, i));
		v__ast__Type val_type = (*(v__ast__Type*)/*ee elem_typ */array_get(assign_stmt.right_types, i));
		v__ast__Expr val = (*(v__ast__Expr*)/*ee elem_typ */array_get(assign_stmt.right, i));
		bool is_call = false;
		bool blank_assign = false;
		v__ast__Ident ident = (v__ast__Ident){.language = 0,.tok_kind = 0,.pos = {0},.mut_pos = {0},.scope = 0,.obj = {0},.mod = (string){.str=(byteptr)"", .is_lit=1},.name = (string){.str=(byteptr)"", .is_lit=1},.kind = 0,.info = {0},.is_mut = 0,};
		v__ast__TypeSymbol* left_sym = v__ast__Table_get_type_symbol(g->table, var_type);
		if ((left)._typ == 254 /* v.ast.Ident */) {
			ident = (*left._v__ast__Ident);
			blank_assign = (*left._v__ast__Ident).kind == v__ast__IdentKind_blank_ident;
			v__ast__IdentInfo left_info = (*left._v__ast__Ident).info;
			if ((left_info)._typ == 363 /* v.ast.IdentVar */) {
				v__ast__ShareType share = (*left_info._v__ast__IdentVar).share;
				if (share == v__ast__ShareType_shared_t) {
					var_type = v__ast__Type_set_flag(var_type, v__ast__TypeFlag_shared_f);
				}
				if (share == v__ast__ShareType_atomic_t) {
					var_type = v__ast__Type_set_flag(var_type, v__ast__TypeFlag_atomic_f);
				}
			}
		}
		string styp = v__gen__c__Gen_typ(g, var_type);
		bool is_fixed_array_init = false;
		bool has_val = false;
		if (val._typ == 235 /* v.ast.ArrayInit */) {
			is_fixed_array_init = (*val._v__ast__ArrayInit).is_fixed;
			has_val = (*val._v__ast__ArrayInit).has_val;
		}
		else if (val._typ == 241 /* v.ast.CallExpr */) {
			is_call = true;
			return_type = (*val._v__ast__CallExpr).return_type;
		}
		else if (val._typ == 233 /* v.ast.AnonFn */) {
			if (blank_assign) {
				v__gen__c__Gen_write(g, _SLIT("{"));
			}
			if ((is_decl || blank_assign) && (left)._typ == 254 /* v.ast.Ident */) {
				string ret_styp = v__gen__c__Gen_typ(g, (*val._v__ast__AnonFn).decl.return_type);
				v__gen__c__Gen_write(g, _STR("%.*s\000 (*%.*s\000) (", 3, ret_styp, ident.name));
				int def_pos = g->definitions.len;
				v__gen__c__Gen_fn_args(g, (*val._v__ast__AnonFn).decl.params, (*val._v__ast__AnonFn).decl.is_variadic);
				strings__Builder_go_back(&g->definitions, g->definitions.len - def_pos);
				v__gen__c__Gen_write(g, _SLIT(") = "));
			} else {
				g->is_assign_lhs = true;
				g->assign_op = assign_stmt.op;
				v__gen__c__Gen_expr(g, left);
				g->is_assign_lhs = false;
				g->is_arraymap_set = false;
				if ((left)._typ == 257 /* v.ast.IndexExpr */) {
					v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, (*left._v__ast__IndexExpr).left_type);
					if ((sym->kind == v__ast__Kind_map || sym->kind == v__ast__Kind_array)) {
						v__gen__c__Gen_expr(g, val);
						v__gen__c__Gen_writeln(g, _SLIT("});"));
						continue;
					}
				}
				v__gen__c__Gen_write(g, _SLIT(" = "));
			}
			v__gen__c__Gen_expr(g, val);
			v__gen__c__Gen_writeln(g, _SLIT(";"));
			if (blank_assign) {
				v__gen__c__Gen_write(g, _SLIT("}"));
			}
			continue;
		}
		else {
		};
		v__ast__TypeSymbol* right_sym = v__ast__Table_get_type_symbol(g->table, val_type);
		bool is_fixed_array_copy = right_sym->kind == v__ast__Kind_array_fixed && (val)._typ == 254 /* v.ast.Ident */;
		g->is_assign_lhs = true;
		g->assign_op = assign_stmt.op;
		if (v__ast__Type_has_flag(val_type, v__ast__TypeFlag_optional)) {
			g->right_is_opt = true;
		}
		if (blank_assign) {
			if (is_call) {
				bool old_is_void_expr_stmt = g->is_void_expr_stmt;
				g->is_void_expr_stmt = true;
				v__gen__c__Gen_expr(g, val);
				g->is_void_expr_stmt = old_is_void_expr_stmt;
			} else {
				v__gen__c__Gen_write(g, _STR("{%.*s\000 _ = ", 2, styp));
				v__gen__c__Gen_expr(g, val);
				v__gen__c__Gen_writeln(g, _SLIT(";}"));
			}
		} else if (is_fixed_array_init && assign_stmt.op == v__token__Kind_assign) {
			v__ast__ArrayInit right = /* as */ *(v__ast__ArrayInit*)__as_cast((val)._v__ast__ArrayInit,(val)._typ, 235) /*expected idx: 235, name: v.ast.ArrayInit */ ;
			string v_var = v__gen__c__Gen_new_tmp_var(g);
			string arr_typ = string_trim(styp, _SLIT("*"));
			v__gen__c__Gen_write(g, _STR("%.*s\000 %.*s\000 = ", 3, arr_typ, v_var));
			v__gen__c__Gen_expr(g, v__ast__ArrayInit_to_sumtype_v__ast__Expr(ADDR(v__ast__ArrayInit, (right))));
			v__gen__c__Gen_writeln(g, _SLIT(";"));
			int pos = g->out.len;
			v__gen__c__Gen_expr(g, left);
			if (g->is_arraymap_set && g->arraymap_set_pos > 0) {
				strings__Builder_go_back_to(&g->out, g->arraymap_set_pos);
				v__gen__c__Gen_write(g, _STR(", &%.*s\000)", 2, v_var));
				g->is_arraymap_set = false;
				g->arraymap_set_pos = 0;
			} else {
				strings__Builder_go_back_to(&g->out, pos);
				bool is_var_mut = !is_decl && v__ast__Expr_is_auto_deref_var(left);
				string addr = (is_var_mut ? (_SLIT("")) : (_SLIT("&")));
				v__gen__c__Gen_writeln(g, _SLIT(""));
				v__gen__c__Gen_write(g, _STR("memcpy(%.*s", 1, addr));
				v__gen__c__Gen_expr(g, left);
				v__gen__c__Gen_writeln(g, _STR(", &%.*s\000, sizeof(%.*s\000));", 3, v_var, arr_typ));
			}
			g->is_assign_lhs = false;
		} else {
			bool is_inside_ternary = g->inside_ternary != 0;
			string cur_line = (is_inside_ternary && is_decl ? (v__gen__c__Gen_register_ternary_name(g, ident.name),g->empty_line = false,v__gen__c__Gen_go_before_ternary(g)) : (_SLIT("")));
			bool str_add = false;
			bool op_overloaded = false;
			if (var_type == _const_v__ast__string_type_idx && assign_stmt.op == v__token__Kind_plus_assign) {
				if ((left)._typ == 257 /* v.ast.IndexExpr */) {
					v__gen__c__Gen_expr(g, left);
					v__gen__c__Gen_write(g, _SLIT("string_add("));
				} else {
					v__gen__c__Gen_expr(g, left);
					v__gen__c__Gen_write(g, _SLIT(" = /*f*/string_add("));
				}
				g->is_assign_lhs = false;
				str_add = true;
			}
			if (((left_sym->kind == v__ast__Kind_struct_ && right_sym->kind == v__ast__Kind_struct_) || (left_sym->kind == v__ast__Kind_alias && right_sym->kind == v__ast__Kind_alias)) && (assign_stmt.op == v__token__Kind_plus_assign || assign_stmt.op == v__token__Kind_minus_assign || assign_stmt.op == v__token__Kind_div_assign || assign_stmt.op == v__token__Kind_mult_assign || assign_stmt.op == v__token__Kind_mod_assign)) {
				string extracted_op = ((assign_stmt.op == (v__token__Kind_plus_assign)) ? (_SLIT("+")) : (assign_stmt.op == (v__token__Kind_minus_assign)) ? (_SLIT("-")) : (assign_stmt.op == (v__token__Kind_div_assign)) ? (_SLIT("/")) : (assign_stmt.op == (v__token__Kind_mod_assign)) ? (_SLIT("%")) : (assign_stmt.op == (v__token__Kind_mult_assign)) ? (_SLIT("*")) : (_SLIT("unknown op")));
				v__gen__c__Gen_expr(g, left);
				v__gen__c__Gen_write(g, _STR(" = %.*s\000_%.*s\000(", 3, styp, v__util__replace_op(extracted_op)));
				op_overloaded = true;
			}
			if (right_sym->kind == v__ast__Kind_function && is_decl) {
				if (is_inside_ternary && is_decl) {
					strings__Builder_write_string(&g->out, v__util__tabs(g->indent - g->inside_ternary));
				}
				v__ast__FnType func = /* as */ *(v__ast__FnType*)__as_cast((right_sym->info)._v__ast__FnType,(right_sym->info)._typ, 418) /*expected idx: 418, name: v.ast.FnType */ ;
				string ret_styp = v__gen__c__Gen_typ(g, func.func.return_type);
				v__gen__c__Gen_write(g, _STR("%.*s\000 (*%.*s\000) (", 3, ret_styp, v__gen__c__Gen_get_ternary_name(g, ident.name)));
				int def_pos = g->definitions.len;
				v__gen__c__Gen_fn_args(g, func.func.params, func.func.is_variadic);
				strings__Builder_go_back(&g->definitions, g->definitions.len - def_pos);
				v__gen__c__Gen_write(g, _SLIT(")"));
			} else {
				if (is_decl) {
					if (is_inside_ternary) {
						strings__Builder_write_string(&g->out, v__util__tabs(g->indent - g->inside_ternary));
					}
					v__gen__c__Gen_write(g, _STR("%.*s\000 ", 2, styp));
				}
				if ((left)._typ == 254 /* v.ast.Ident */ || (left)._typ == 273 /* v.ast.SelectorExpr */) {
					g->prevent_sum_type_unwrapping_once = true;
				}
				if (!is_fixed_array_copy || is_decl) {
					if (!is_decl && v__ast__Expr_is_auto_deref_var(left)) {
						v__gen__c__Gen_write(g, _SLIT("*"));
					}
					v__gen__c__Gen_expr(g, left);
				}
			}
			if (is_inside_ternary && is_decl) {
				v__gen__c__Gen_write(g, _STR(";\n%.*s", 1, cur_line));
				strings__Builder_write_string(&g->out, v__util__tabs(g->indent));
				v__gen__c__Gen_expr(g, left);
			}
			g->is_assign_lhs = false;
			if (is_fixed_array_copy) {
				if (is_decl) {
					v__gen__c__Gen_writeln(g, _SLIT(";"));
				}
			} else if (!g->is_arraymap_set && !str_add && !op_overloaded) {
				v__gen__c__Gen_write(g, _STR(" %.*s\000 ", 2, v__token__Kind_str(op)));
			} else if (str_add || op_overloaded) {
				v__gen__c__Gen_write(g, _SLIT(", "));
			}
			bool cloned = false;
			if (g->is_autofree && (right_sym->kind == v__ast__Kind_array || right_sym->kind == v__ast__Kind_string)) {
				if (v__gen__c__Gen_gen_clone_assignment(g, val, *right_sym, false)) {
					cloned = true;
				}
			}
			bool unwrap_optional = !v__ast__Type_has_flag(var_type, v__ast__TypeFlag_optional) && v__ast__Type_has_flag(val_type, v__ast__TypeFlag_optional);
			if (unwrap_optional) {
			}
			g->is_shared = v__ast__Type_has_flag(var_type, v__ast__TypeFlag_shared_f);
			if (!cloned) {
				if (is_fixed_array_copy) {
					string typ_str = string_trim(v__gen__c__Gen_typ(g, val_type), _SLIT("*"));
					string ref_str = (v__ast__Type_is_ptr(val_type) ? (_SLIT("")) : (_SLIT("&")));
					v__gen__c__Gen_write(g, _STR("memcpy((%.*s\000*)", 2, typ_str));
					v__gen__c__Gen_expr(g, left);
					v__gen__c__Gen_write(g, _STR(", (byte*)%.*s", 1, ref_str));
					v__gen__c__Gen_expr(g, val);
					v__gen__c__Gen_write(g, _STR(", sizeof(%.*s\000))", 2, typ_str));
				} else if (is_decl) {
					if (is_fixed_array_init && !has_val) {
						if ((val)._typ == 235 /* v.ast.ArrayInit */) {
							if ((*val._v__ast__ArrayInit).has_default) {
								v__gen__c__Gen_write(g, _SLIT("{"));
								v__gen__c__Gen_expr(g, (*val._v__ast__ArrayInit).default_expr);
								v__ast__ArrayFixed info = /* as */ *(v__ast__ArrayFixed*)__as_cast((right_sym->info)._v__ast__ArrayFixed,(right_sym->info)._typ, 416) /*expected idx: 416, name: v.ast.ArrayFixed */ ;
								for (int _t2906 = 1; _t2906 < info.size; ++_t2906) {
									v__gen__c__Gen_write(g, _SLIT(", "));
									v__gen__c__Gen_expr(g, (*val._v__ast__ArrayInit).default_expr);
								}
								v__gen__c__Gen_write(g, _SLIT("}"));
							} else {
								v__gen__c__Gen_write(g, _SLIT("{0}"));
							}
						} else {
							v__gen__c__Gen_write(g, _SLIT("{0}"));
						}
					} else {
						if (v__ast__Expr_is_auto_deref_var(val)) {
							v__gen__c__Gen_write(g, _SLIT("*"));
						}
						v__gen__c__Gen_expr(g, val);
					}
				} else {
					if (assign_stmt.has_cross_var) {
						v__gen__c__Gen_gen_cross_tmp_variable(g, assign_stmt.left, val);
					} else {
						v__gen__c__Gen_expr_with_cast(g, val, val_type, var_type);
					}
				}
			}
			if (str_add || op_overloaded) {
				v__gen__c__Gen_write(g, _SLIT(")"));
			}
			if (g->is_arraymap_set) {
				v__gen__c__Gen_write(g, _SLIT(" })"));
				g->is_arraymap_set = false;
			}
			g->is_shared = false;
		}
		g->right_is_opt = false;
		if (g->inside_ternary == 0 && (assign_stmt.left.len > 1 || !assign_stmt.is_simple)) {
			v__gen__c__Gen_writeln(g, _SLIT(";"));
		}
	}
// Defer begin
if (v__gen__c__Gen_gen_assign_stmt_defer_0 == true) {
	if (af) {
		v__gen__c__Gen_writeln(g, _STR("%.*s\000_free(&%.*s\000);", 3, type_to_free, sref_name));
	}
}
// Defer end
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_cross_tmp_variable(v__gen__c__Gen* g, Array_v__ast__Expr left, v__ast__Expr val) {
	v__ast__Expr val_ = val;
	if (val._typ == 254 /* v.ast.Ident */) {
		bool has_var = false;
		// FOR IN array
		for (int _t2907 = 0; _t2907 < left.len; ++_t2907) {
			v__ast__Expr lx = ((v__ast__Expr*)left.data)[_t2907];
			if ((lx)._typ == 254 /* v.ast.Ident */) {
				if (string_eq((*val._v__ast__Ident).name, (*lx._v__ast__Ident).name)) {
					v__gen__c__Gen_write(g, _SLIT("_var_"));
					v__gen__c__Gen_write(g, int_str((*lx._v__ast__Ident).pos.pos));
					has_var = true;
					break;
				}
			}
		}
		if (!has_var) {
			v__gen__c__Gen_expr(g, val_);
		}
	}
	else if (val._typ == 257 /* v.ast.IndexExpr */) {
		bool has_var = false;
		// FOR IN array
		for (int _t2908 = 0; _t2908 < left.len; ++_t2908) {
			v__ast__Expr lx = ((v__ast__Expr*)left.data)[_t2908];
			if (string_eq(v__ast__Expr_str(val_), v__ast__Expr_str(lx))) {
				v__gen__c__Gen_write(g, _SLIT("_var_"));
				v__gen__c__Gen_write(g, int_str(v__ast__Expr_position(lx).pos));
				has_var = true;
				break;
			}
		}
		if (!has_var) {
			v__gen__c__Gen_expr(g, val_);
		}
	}
	else if (val._typ == 258 /* v.ast.InfixExpr */) {
		v__gen__c__Gen_gen_cross_tmp_variable(g, left, (*val._v__ast__InfixExpr).left);
		v__gen__c__Gen_write(g, v__token__Kind_str((*val._v__ast__InfixExpr).op));
		v__gen__c__Gen_gen_cross_tmp_variable(g, left, (*val._v__ast__InfixExpr).right);
	}
	else if (val._typ == 270 /* v.ast.PrefixExpr */) {
		v__gen__c__Gen_write(g, v__token__Kind_str((*val._v__ast__PrefixExpr).op));
		v__gen__c__Gen_gen_cross_tmp_variable(g, left, (*val._v__ast__PrefixExpr).right);
	}
	else if (val._typ == 269 /* v.ast.PostfixExpr */) {
		v__gen__c__Gen_gen_cross_tmp_variable(g, left, (*val._v__ast__PostfixExpr).expr);
		v__gen__c__Gen_write(g, v__token__Kind_str((*val._v__ast__PostfixExpr).op));
	}
	else if (val._typ == 273 /* v.ast.SelectorExpr */) {
		bool has_var = false;
		// FOR IN array
		for (int _t2909 = 0; _t2909 < left.len; ++_t2909) {
			v__ast__Expr lx = ((v__ast__Expr*)left.data)[_t2909];
			if (string_eq(v__ast__Expr_str(val_), v__ast__Expr_str(lx))) {
				v__gen__c__Gen_write(g, _SLIT("_var_"));
				v__gen__c__Gen_write(g, int_str(v__ast__Expr_position(lx).pos));
				has_var = true;
				break;
			}
		}
		if (!has_var) {
			v__gen__c__Gen_expr(g, val_);
		}
	}
	else {
		v__gen__c__Gen_expr(g, val_);
	};
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_register_ternary_name(v__gen__c__Gen* g, string name) {
	string level_key = int_str(g->inside_ternary);
	if (!_IN_MAP(ADDR(string, level_key), ADDR(map, g->ternary_level_names))) {
		map_set(&g->ternary_level_names, &(string[]){level_key}, &(Array_string[]) { __new_array_with_default(0, 0, sizeof(string), 0) });
	}
	string new_name = v__gen__c__Gen_new_tmp_var(g);
	map_set(&g->ternary_names, &(string[]){name}, &(string[]) { new_name });
	array_push(&(*(Array_string*)map_get_and_set(&g->ternary_level_names, &(string[]){level_key}, &(Array_string[]){ __new_array(0, 1, sizeof(string)) })), _MOV((string[]){ string_clone(name) }));
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_get_ternary_name(v__gen__c__Gen* g, string name) {
	if (g->inside_ternary == 0) {
		// autofree_scope_vars(pos=78826 line_nr=2590 scope.pos=78823 scope.end_pos=78840)
		// af parent scope:
		// var "g" var.pos=78751 var.line_nr=2588
		// var "name" var.pos=78775 var.line_nr=2588
		// af parent scope:
		// af parent scope:
		return name;
	}
	if (!_IN_MAP(ADDR(string, name), ADDR(map, g->ternary_names))) {
		// autofree_scope_vars(pos=78874 line_nr=2593 scope.pos=78871 scope.end_pos=78888)
		// af parent scope:
		// var "g" var.pos=78751 var.line_nr=2588
		// var "name" var.pos=78775 var.line_nr=2588
		// af parent scope:
		// af parent scope:
		return name;
	}
	 string _t2911 = (*(string*)map_get(ADDR(map, g->ternary_names), &(string[]){name}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} }));
	// autofree_scope_vars(pos=78890 line_nr=2595 scope.pos=78746 scope.end_pos=78920)
	// var "g" var.pos=78751 var.line_nr=2588
	// var "name" var.pos=78775 var.line_nr=2588
	// af parent scope:
	// af parent scope:
	return _t2911;
}

VV_LOCAL_SYMBOL bool v__gen__c__Gen_gen_clone_assignment(v__gen__c__Gen* g, v__ast__Expr val, v__ast__TypeSymbol right_sym, bool add_eq) {
	if ((val)._typ != 254 /* v.ast.Ident */ && (val)._typ != 273 /* v.ast.SelectorExpr */) {
		 bool _t2912 = false;
		// autofree_scope_vars(pos=79072 line_nr=2600 scope.pos=79069 scope.end_pos=79087)
		// af parent scope:
		// var "g" var.pos=78931 var.line_nr=2598
		// var "val" var.pos=78959 var.line_nr=2598
		// var "right_sym" var.pos=78973 var.line_nr=2598
		// var "add_eq" var.pos=78999 var.line_nr=2598
		// af parent scope:
		// af parent scope:
		return _t2912;
	}
	if (g->is_autofree && right_sym.kind == v__ast__Kind_array) {
		if (add_eq) {
			v__gen__c__Gen_write(g, _SLIT("="));
		}
		v__gen__c__Gen_write(g, _SLIT(" array_clone_static("));
		v__gen__c__Gen_expr(g, val);
		v__gen__c__Gen_write(g, _SLIT(")"));
	} else if (g->is_autofree && right_sym.kind == v__ast__Kind_string) {
		if (add_eq) {
			v__gen__c__Gen_write(g, _SLIT("="));
		}
		v__gen__c__Gen_write(g, _SLIT(" string_clone_static("));
		v__gen__c__Gen_expr(g, val);
		v__gen__c__Gen_write(g, _SLIT(")"));
	}
	 bool _t2913 = true;
	// autofree_scope_vars(pos=79479 line_nr=2619 scope.pos=78926 scope.end_pos=79492)
	// var "g" var.pos=78931 var.line_nr=2598
	// var "val" var.pos=78959 var.line_nr=2598
	// var "right_sym" var.pos=78973 var.line_nr=2598
	// var "add_eq" var.pos=78999 var.line_nr=2598
	// af parent scope:
	// af parent scope:
	return _t2913;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_autofree_scope_vars(v__gen__c__Gen* g, int pos, int line_nr, bool free_parent_scopes) {
	v__gen__c__Gen_autofree_scope_vars_stop(g, pos, line_nr, free_parent_scopes, -1);
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_autofree_scope_vars_stop(v__gen__c__Gen* g, int pos, int line_nr, bool free_parent_scopes, int stop_pos) {
	if (g->is_builtin_mod) {
		return;
	}
	if (pos == -1) {
		return;
	}
	v__ast__Scope* scope = v__ast__Scope_innermost(g->file.scope, pos);
	if (scope->start_pos == 0) {
		return;
	}
	v__gen__c__Gen_writeln(g, _STR("// autofree_scope_vars(pos=%"PRId32"\000 line_nr=%"PRId32"\000 scope.pos=%"PRId32"\000 scope.end_pos=%"PRId32"\000)", 5, pos, line_nr, scope->start_pos, scope->end_pos));
	v__gen__c__Gen_autofree_scope_vars2(g, scope, scope->start_pos, scope->end_pos, line_nr, free_parent_scopes, stop_pos);
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_autofree_scope_vars2(v__gen__c__Gen* g, v__ast__Scope* scope, int start_pos, int end_pos, int line_nr, bool free_parent_scopes, int stop_pos) {
	if (isnil(scope)) {
		return;
	}
	// FOR IN map
	Map_string_v__ast__ScopeObject _t2914 = scope->objects;
	int _t2916 = _t2914.key_values.len;
	for (int _t2915 = 0; _t2915 < _t2916; ++_t2915 ) {
		int _t2917 = _t2914.key_values.len - _t2916;
		_t2916 = _t2914.key_values.len;
		if (_t2917 < 0) {
			_t2915 = -1;
			continue;
		}
		if (!DenseArray_has_index(&_t2914.key_values, _t2915)) {continue;}
		v__ast__ScopeObject obj = (*(v__ast__ScopeObject*)DenseArray_value(&_t2914.key_values, _t2915));
		if (obj._typ == 312 /* v.ast.Var */) {
			v__gen__c__Gen_writeln(g, _STR("// var \"%.*s\000\" var.pos=%"PRId32"\000 var.line_nr=%"PRId32"", 3, (*obj._v__ast__Var).name, (*obj._v__ast__Var).pos.pos, (*obj._v__ast__Var).pos.line_nr));
			if (string_eq((*obj._v__ast__Var).name, g->returned_var_name)) {
				v__gen__c__Gen_writeln(g, _SLIT("// skipping returned var"));
				continue;
			}
			if ((*obj._v__ast__Var).is_or) {
				v__gen__c__Gen_writeln(g, _STR("// skipping `or{}` var \"%.*s\000\"", 2, (*obj._v__ast__Var).name));
				continue;
			}
			if ((*obj._v__ast__Var).is_tmp) {
				v__gen__c__Gen_writeln(g, _STR("// skipping tmp var \"%.*s\000\"", 2, (*obj._v__ast__Var).name));
				continue;
			}
			if ((*obj._v__ast__Var).pos.pos > end_pos || ((*obj._v__ast__Var).pos.pos < start_pos && (*obj._v__ast__Var).pos.line_nr == line_nr)) {
				continue;
			}
			bool is_optional = v__ast__Type_has_flag((*obj._v__ast__Var).typ, v__ast__TypeFlag_optional);
			if (is_optional) {
				continue;
			}
			v__gen__c__Gen_autofree_variable(g, (*obj._v__ast__Var));
		}
		else {
		};
	}
	if (free_parent_scopes && !isnil(scope->parent) && (stop_pos == -1 || scope->parent->start_pos >= stop_pos)) {
		v__gen__c__Gen_writeln(g, _SLIT("// af parent scope:"));
		v__gen__c__Gen_autofree_scope_vars2(g, scope->parent, start_pos, end_pos, line_nr, true, stop_pos);
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_autofree_variable(v__gen__c__Gen* g, v__ast__Var v) {
	v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, v.typ);
	if (sym->kind == v__ast__Kind_array) {
		if (v__ast__TypeSymbol_has_method(sym, _SLIT("free"))) {
			string free_method_name = string_add(v__gen__c__Gen_typ(g, v.typ), _SLIT("_free"));
			v__gen__c__Gen_autofree_var_call(g, free_method_name, v);
			return;
		}
		v__gen__c__Gen_autofree_var_call(g, _SLIT("array_free"), v);
		return;
	}
	if (sym->kind == v__ast__Kind_string) {
		if (v.expr._typ == 277 /* v.ast.StringLiteral */) {
			v__gen__c__Gen_writeln(g, _SLIT("// str literal"));
		}
		else {
		};
		v__gen__c__Gen_autofree_var_call(g, _SLIT("string_free"), v);
		return;
	}
	if (v__ast__TypeSymbol_has_method(sym, _SLIT("free"))) {
		v__gen__c__Gen_autofree_var_call(g, string_add(v__gen__c__c_name(sym->name), _SLIT("_free")), v);
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_autofree_var_call(v__gen__c__Gen* g, string free_fn_name, v__ast__Var v) {
	if (v.is_arg) {
		return;
	}
	if (v.is_used && v.is_autofree_tmp) {
		return;
	}
	if (g->is_builtin_mod) {
		return;
	}
	if (!g->is_autofree) {
		return;
	}
	if (string_contains(v.name, _SLIT("expr_write_string_1_"))) {
		return;
	}
	if (v__ast__Type_is_ptr(v.typ)) {
		v__gen__c__Gen_writeln(g, _STR("\t%.*s\000(%.*s\000); // autofreed ptr var", 3, free_fn_name, v__gen__c__c_name(v.name)));
	} else {
		if (v__ast__Type_alias_eq(v.typ, _const_v__ast__error_type) && !v.is_autofree_tmp) {
			return;
		}
		v__gen__c__Gen_writeln(g, _STR("\t%.*s\000(&%.*s\000); // autofreed var %.*s\000 %.*s", 4, free_fn_name, v__gen__c__c_name(v.name), g->cur_mod.name, g->is_builtin_mod ? _SLIT("true") : _SLIT("false")));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_anon_fn_decl(v__gen__c__Gen* g, v__ast__AnonFn* node) {
	if (!node->has_gen) {
		int pos = g->out.len;
		v__gen__c__Gen_stmt(g, v__ast__FnDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__FnDecl, (node->decl))));
		string fn_body = strings__Builder_after(&g->out, pos);
		strings__Builder_go_back(&g->out, fn_body.len);
		array_push(&g->anon_fn_definitions, _MOV((string[]){ string_clone(fn_body) }));
		node->has_gen = true;
	}
}

VV_LOCAL_SYMBOL multi_return_string_string_string_string v__gen__c__Gen_map_fn_ptrs(v__gen__c__Gen* g, v__ast__TypeSymbol key_typ) {
	string hash_fn = _SLIT("");
	string key_eq_fn = _SLIT("");
	string clone_fn = _SLIT("");
	string free_fn = _SLIT("&map_free_nop");

	if (key_typ.kind == (v__ast__Kind_byte) || key_typ.kind == (v__ast__Kind_i8) || key_typ.kind == (v__ast__Kind_char)) {
		hash_fn = _SLIT("&map_hash_int_1");
		key_eq_fn = _SLIT("&map_eq_int_1");
		clone_fn = _SLIT("&map_clone_int_1");
	}
	else if (key_typ.kind == (v__ast__Kind_i16) || key_typ.kind == (v__ast__Kind_u16)) {
		hash_fn = _SLIT("&map_hash_int_2");
		key_eq_fn = _SLIT("&map_eq_int_2");
		clone_fn = _SLIT("&map_clone_int_2");
	}
	else if (key_typ.kind == (v__ast__Kind_int) || key_typ.kind == (v__ast__Kind_u32) || key_typ.kind == (v__ast__Kind_rune) || key_typ.kind == (v__ast__Kind_f32) || key_typ.kind == (v__ast__Kind_enum_)) {
		hash_fn = _SLIT("&map_hash_int_4");
		key_eq_fn = _SLIT("&map_eq_int_4");
		clone_fn = _SLIT("&map_clone_int_4");
	}
	else if (key_typ.kind == (v__ast__Kind_voidptr)) {
		v__ast__TypeSymbol* ts = (g->pref->m64 ? (&(*(v__ast__TypeSymbol*)/*ee elem_typ */array_get(g->table->type_symbols, _const_v__ast__u64_type_idx))) : (&(*(v__ast__TypeSymbol*)/*ee elem_typ */array_get(g->table->type_symbols, _const_v__ast__u32_type_idx))));
		 multi_return_string_string_string_string _t2919 = v__gen__c__Gen_map_fn_ptrs(g, *ts);
		// autofree_scope_vars(pos=84708 line_nr=2818 scope.pos=84565 scope.end_pos=84736)
		// var "ts" var.pos=84579 var.line_nr=2813
		// af parent scope:
		// var "g" var.pos=84001 var.line_nr=2791
		// var "key_typ" var.pos=84020 var.line_nr=2791
		// var "hash_fn" var.pos=84084 var.line_nr=2792
		// str literal
		// var "key_eq_fn" var.pos=84103 var.line_nr=2793
		// str literal
		// var "clone_fn" var.pos=84124 var.line_nr=2794
		// str literal
		// var "free_fn" var.pos=84144 var.line_nr=2795
		// str literal
		// af parent scope:
		// af parent scope:
		return _t2919;
	}
	else if (key_typ.kind == (v__ast__Kind_u64) || key_typ.kind == (v__ast__Kind_i64) || key_typ.kind == (v__ast__Kind_f64)) {
		hash_fn = _SLIT("&map_hash_int_8");
		key_eq_fn = _SLIT("&map_eq_int_8");
		clone_fn = _SLIT("&map_clone_int_8");
	}
	else if (key_typ.kind == (v__ast__Kind_string)) {
		hash_fn = _SLIT("&map_hash_string");
		key_eq_fn = _SLIT("&map_eq_string");
		clone_fn = _SLIT("&map_clone_string");
		free_fn = _SLIT("&map_free_string");
	}
	else {
		v__gen__c__verror(_SLIT("map key type not supported"));
	};
	return (multi_return_string_string_string_string){.arg0=hash_fn, .arg1=key_eq_fn, .arg2=clone_fn, .arg3=free_fn};
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_expr(v__gen__c__Gen* g, v__ast__Expr node) {
	bool old_discard_or_result = g->discard_or_result;
	bool old_is_void_expr_stmt = g->is_void_expr_stmt;
	if (g->is_void_expr_stmt) {
		g->discard_or_result = true;
		g->is_void_expr_stmt = false;
	} else {
		g->discard_or_result = false;
	}
	if (node._typ == 250 /* v.ast.EmptyExpr */) {
		v__gen__c__Gen_error(g, _SLIT("g.expr(): unhandled EmptyExpr"), (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.last_line = 0,});
	}
	else if (node._typ == 233 /* v.ast.AnonFn */) {
		v__gen__c__Gen_gen_anon_fn_decl(g, (voidptr)&/*qq*/(*node._v__ast__AnonFn));
		v__ast__TypeSymbol* fsym = v__ast__Table_get_type_symbol(g->table, (*node._v__ast__AnonFn).typ);
		v__gen__c__Gen_write(g, fsym->name);
	}
	else if (node._typ == 234 /* v.ast.ArrayDecompose */) {
		v__gen__c__Gen_expr(g, (*node._v__ast__ArrayDecompose).expr);
	}
	else if (node._typ == 235 /* v.ast.ArrayInit */) {
		v__gen__c__Gen_array_init(g, (*node._v__ast__ArrayInit));
	}
	else if (node._typ == 236 /* v.ast.AsCast */) {
		v__gen__c__Gen_as_cast(g, (*node._v__ast__AsCast));
	}
	else if (node._typ == 237 /* v.ast.Assoc */) {
		v__gen__c__Gen_assoc(g, (*node._v__ast__Assoc));
	}
	else if (node._typ == 239 /* v.ast.BoolLiteral */) {
		v__gen__c__Gen_write(g, bool_str((*node._v__ast__BoolLiteral).val));
	}
	else if (node._typ == 241 /* v.ast.CallExpr */) {
		v__ast__Type ret_type = ((*node._v__ast__CallExpr).or_block.kind == v__ast__OrKind_absent ? ((*node._v__ast__CallExpr).return_type) : (v__ast__Type_clear_flag((*node._v__ast__CallExpr).return_type, v__ast__TypeFlag_optional)));
		string shared_styp = _SLIT("");
		if (g->is_shared && !v__ast__Type_has_flag(ret_type, v__ast__TypeFlag_shared_f)) {
			v__ast__TypeSymbol* ret_sym = v__ast__Table_get_type_symbol(g->table, ret_type);
			v__ast__Type shared_typ = v__ast__Type_set_flag(ret_type, v__ast__TypeFlag_shared_f);
			shared_styp = v__gen__c__Gen_typ(g, shared_typ);
			if (ret_sym->kind == v__ast__Kind_array) {
				v__gen__c__Gen_writeln(g, _STR("(%.*s\000*)__dup_shared_array(&(%.*s\000){.val = ", 3, shared_styp, shared_styp));
			} else if (ret_sym->kind == v__ast__Kind_map) {
				v__gen__c__Gen_writeln(g, _STR("(%.*s\000*)__dup_shared_map(&(%.*s\000){.val = ", 3, shared_styp, shared_styp));
			} else {
				v__gen__c__Gen_writeln(g, _STR("(%.*s\000*)__dup%.*s\000(&(%.*s\000){.val = ", 4, shared_styp, shared_styp, shared_styp));
			}
		}
		v__gen__c__Gen_call_expr(g, (*node._v__ast__CallExpr));
		if (g->is_autofree && !g->is_builtin_mod && !g->is_js_call && g->strs_to_free0.len == 0 && !g->inside_lambda) {
			v__gen__c__Gen_autofree_call_pregen(g, (*node._v__ast__CallExpr));
			if (g->strs_to_free0.len > 0) {
				v__gen__c__Gen_insert_before_stmt(g, string_add(Array_string_join(g->strs_to_free0, _SLIT("\n")), _SLIT("/* inserted before */")));
			}
			g->strs_to_free0 = __new_array_with_default(0, 0, sizeof(string), 0);
		}
		if (g->is_shared && !v__ast__Type_has_flag(ret_type, v__ast__TypeFlag_shared_f)) {
			v__gen__c__Gen_writeln(g, _STR("}, sizeof(%.*s\000))", 2, shared_styp));
		}
	}
	else if (node._typ == 242 /* v.ast.CastExpr */) {
		v__gen__c__Gen_cast_expr(g, (*node._v__ast__CastExpr));
	}
	else if (node._typ == 243 /* v.ast.ChanInit */) {
		string elem_typ_str = v__gen__c__Gen_typ(g, (*node._v__ast__ChanInit).elem_type);
		v__gen__c__Gen_write(g, _SLIT("sync__new_channel_st("));
		if ((*node._v__ast__ChanInit).has_cap) {
			v__gen__c__Gen_expr(g, (*node._v__ast__ChanInit).cap_expr);
		} else {
			v__gen__c__Gen_write(g, _SLIT("0"));
		}
		v__gen__c__Gen_write(g, _SLIT(", sizeof("));
		v__gen__c__Gen_write(g, elem_typ_str);
		v__gen__c__Gen_write(g, _SLIT("))"));
	}
	else if (node._typ == 244 /* v.ast.CharLiteral */) {
		if (string_eq((*node._v__ast__CharLiteral).val, _SLIT("\\`"))) {
			v__gen__c__Gen_write(g, _SLIT("'`'"));
		} else {
			v__gen__c__Gen_write(g, _STR("L'%.*s\000'", 2, (*node._v__ast__CharLiteral).val));
		}
	}
	else if (node._typ == 249 /* v.ast.DumpExpr */) {
		v__gen__c__Gen_dump_expr(g, (*node._v__ast__DumpExpr));
	}
	else if (node._typ == 238 /* v.ast.AtExpr */) {
		v__gen__c__Gen_comp_at(g, (*node._v__ast__AtExpr));
	}
	else if (node._typ == 246 /* v.ast.ComptimeCall */) {
		v__gen__c__Gen_comptime_call(g, (*node._v__ast__ComptimeCall));
	}
	else if (node._typ == 247 /* v.ast.ComptimeSelector */) {
		v__gen__c__Gen_comptime_selector(g, (*node._v__ast__ComptimeSelector));
	}
	else if (node._typ == 245 /* v.ast.Comment */) {
	}
	else if (node._typ == 248 /* v.ast.ConcatExpr */) {
		v__gen__c__Gen_concat_expr(g, (*node._v__ast__ConcatExpr));
	}
	else if (node._typ == 240 /* v.ast.CTempVar */) {
		v__gen__c__Gen_write(g, (*node._v__ast__CTempVar).name);
	}
	else if (node._typ == 251 /* v.ast.EnumVal */) {
		string styp = v__gen__c__Gen_typ(g, (*node._v__ast__EnumVal).typ);
		v__gen__c__Gen_write(g, _STR("%.*s\000_%.*s", 2, styp, (*node._v__ast__EnumVal).val));
	}
	else if (node._typ == 252 /* v.ast.FloatLiteral */) {
		v__gen__c__Gen_write(g, (*node._v__ast__FloatLiteral).val);
	}
	else if (node._typ == 253 /* v.ast.GoExpr */) {
		v__gen__c__Gen_go_expr(g, (*node._v__ast__GoExpr));
	}
	else if (node._typ == 254 /* v.ast.Ident */) {
		v__gen__c__Gen_ident(g, (*node._v__ast__Ident));
	}
	else if (node._typ == 255 /* v.ast.IfExpr */) {
		v__gen__c__Gen_if_expr(g, (*node._v__ast__IfExpr));
	}
	else if (node._typ == 256 /* v.ast.IfGuardExpr */) {
		v__gen__c__Gen_write(g, _SLIT("/* guard */"));
	}
	else if (node._typ == 257 /* v.ast.IndexExpr */) {
		v__gen__c__Gen_index_expr(g, (*node._v__ast__IndexExpr));
	}
	else if (node._typ == 258 /* v.ast.InfixExpr */) {
		if (((*node._v__ast__InfixExpr).op == v__token__Kind_left_shift || (*node._v__ast__InfixExpr).op == v__token__Kind_plus_assign || (*node._v__ast__InfixExpr).op == v__token__Kind_minus_assign)) {
			g->inside_map_infix = true;
			v__gen__c__Gen_infix_expr(g, (*node._v__ast__InfixExpr));
			g->inside_map_infix = false;
		} else {
			v__gen__c__Gen_infix_expr(g, (*node._v__ast__InfixExpr));
		}
	}
	else if (node._typ == 259 /* v.ast.IntegerLiteral */) {
		if (string_starts_with((*node._v__ast__IntegerLiteral).val, _SLIT("0o"))) {
			v__gen__c__Gen_write(g, _SLIT("0"));
			v__gen__c__Gen_write(g, string_substr((*node._v__ast__IntegerLiteral).val, 2, (*node._v__ast__IntegerLiteral).val.len));
		} else if (string_starts_with((*node._v__ast__IntegerLiteral).val, _SLIT("-0o"))) {
			v__gen__c__Gen_write(g, _SLIT("-0"));
			v__gen__c__Gen_write(g, string_substr((*node._v__ast__IntegerLiteral).val, 3, (*node._v__ast__IntegerLiteral).val.len));
		} else {
			v__gen__c__Gen_write(g, (*node._v__ast__IntegerLiteral).val);
		}
	}
	else if (node._typ == 261 /* v.ast.LockExpr */) {
		v__gen__c__Gen_lock_expr(g, (*node._v__ast__LockExpr));
	}
	else if (node._typ == 263 /* v.ast.MatchExpr */) {
		v__gen__c__Gen_match_expr(g, (*node._v__ast__MatchExpr));
	}
	else if (node._typ == 262 /* v.ast.MapInit */) {
		v__gen__c__Gen_map_init(g, (*node._v__ast__MapInit));
	}
	else if (node._typ == 264 /* v.ast.NodeError */) {
	}
	else if (node._typ == 265 /* v.ast.None */) {
		v__gen__c__Gen_write(g, _SLIT("_const_none__"));
	}
	else if (node._typ == 267 /* v.ast.OrExpr */) {
	}
	else if (node._typ == 268 /* v.ast.ParExpr */) {
		v__gen__c__Gen_write(g, _SLIT("("));
		v__gen__c__Gen_expr(g, (*node._v__ast__ParExpr).expr);
		v__gen__c__Gen_write(g, _SLIT(")"));
	}
	else if (node._typ == 269 /* v.ast.PostfixExpr */) {
		if (((*node._v__ast__PostfixExpr).auto_locked).len != 0) {
			v__gen__c__Gen_writeln(g, _STR("sync__RwMutex_lock(&%.*s\000->mtx);", 2, (*node._v__ast__PostfixExpr).auto_locked));
		}
		g->inside_map_postfix = true;
		if (v__ast__Expr_is_auto_deref_var((*node._v__ast__PostfixExpr).expr)) {
			v__gen__c__Gen_write(g, _SLIT("(*"));
			v__gen__c__Gen_expr(g, (*node._v__ast__PostfixExpr).expr);
			v__gen__c__Gen_write(g, _SLIT(")"));
		} else {
			v__gen__c__Gen_expr(g, (*node._v__ast__PostfixExpr).expr);
		}
		g->inside_map_postfix = false;
		v__gen__c__Gen_write(g, v__token__Kind_str((*node._v__ast__PostfixExpr).op));
		if (((*node._v__ast__PostfixExpr).auto_locked).len != 0) {
			v__gen__c__Gen_writeln(g, _SLIT(";"));
			v__gen__c__Gen_write(g, _STR("sync__RwMutex_unlock(&%.*s\000->mtx)", 2, (*node._v__ast__PostfixExpr).auto_locked));
		}
	}
	else if (node._typ == 270 /* v.ast.PrefixExpr */) {
		bool gen_or = (*node._v__ast__PrefixExpr).op == v__token__Kind_arrow && ((*node._v__ast__PrefixExpr).or_block.kind != v__ast__OrKind_absent || (*node._v__ast__PrefixExpr).is_option);
		if ((*node._v__ast__PrefixExpr).op == v__token__Kind_amp) {
			g->is_amp = true;
		}
		if ((*node._v__ast__PrefixExpr).op == v__token__Kind_arrow) {
			string styp = v__gen__c__Gen_typ(g, (*node._v__ast__PrefixExpr).right_type);
			v__ast__TypeSymbol* right_sym = v__ast__Table_get_type_symbol(g->table, (*node._v__ast__PrefixExpr).right_type);
			v__ast__Chan right_inf = /* as */ *(v__ast__Chan*)__as_cast((right_sym->info)._v__ast__Chan,(right_sym->info)._typ, 414) /*expected idx: 414, name: v.ast.Chan */ ;
			v__ast__Type elem_type = right_inf.elem_type;
			bool is_gen_or_and_assign_rhs = gen_or && !g->discard_or_result;
			string _t2920;
			string cur_line = (is_gen_or_and_assign_rhs ? (				_t2920 = v__gen__c__Gen_go_before_stmt(g, 0),strings__Builder_write_string(&g->out, v__util__tabs(g->indent)),_t2920) : (_SLIT("")));
			string tmp_opt = (gen_or ? (v__gen__c__Gen_new_tmp_var(g)) : (_SLIT("")));
			if (gen_or) {
				string opt_elem_type = v__gen__c__Gen_typ(g, v__ast__Type_set_flag(elem_type, v__ast__TypeFlag_optional));
				v__gen__c__Gen_register_chan_pop_optional_call(g, opt_elem_type, styp);
				v__gen__c__Gen_write(g, _STR("%.*s\000 %.*s\000 = __Option_%.*s\000_popval(", 4, opt_elem_type, tmp_opt, styp));
			} else {
				v__gen__c__Gen_write(g, _STR("__%.*s\000_popval(", 2, styp));
			}
			v__gen__c__Gen_expr(g, (*node._v__ast__PrefixExpr).right);
			v__gen__c__Gen_write(g, _SLIT(")"));
			if (gen_or) {
				if (!(*node._v__ast__PrefixExpr).is_option) {
					v__gen__c__Gen_or_block(g, tmp_opt, (*node._v__ast__PrefixExpr).or_block, elem_type);
				}
				if (is_gen_or_and_assign_rhs) {
					string elem_styp = v__gen__c__Gen_typ(g, elem_type);
					v__gen__c__Gen_write(g, _STR(";\n%.*s\000*(%.*s\000*)%.*s\000.data", 4, cur_line, elem_styp, tmp_opt));
				}
			}
		} else {
			v__gen__c__Gen_write(g, v__token__Kind_str((*node._v__ast__PrefixExpr).op));
			v__gen__c__Gen_expr(g, (*node._v__ast__PrefixExpr).right);
		}
		g->is_amp = false;
	}
	else if (node._typ == 271 /* v.ast.RangeExpr */) {
	}
	else if (node._typ == 272 /* v.ast.SelectExpr */) {
		v__gen__c__Gen_select_expr(g, (*node._v__ast__SelectExpr));
	}
	else if (node._typ == 274 /* v.ast.SizeOf */) {
		v__ast__Type node_typ = v__gen__c__Gen_unwrap_generic(g, (*node._v__ast__SizeOf).typ);
		v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, node_typ);
		if (sym->language == v__ast__Language_v && (sym->kind == v__ast__Kind_placeholder || sym->kind == v__ast__Kind_any)) {
			v__gen__c__Gen_error(g, _STR("unknown type `%.*s\000`", 2, sym->name), (*node._v__ast__SizeOf).pos);
		}
		string styp = v__gen__c__Gen_typ(g, node_typ);
		v__gen__c__Gen_write(g, _STR("/*SizeOf*/ sizeof(%.*s\000)", 2, v__util__no_dots(styp)));
	}
	else if (node._typ == 266 /* v.ast.OffsetOf */) {
		string styp = v__gen__c__Gen_typ(g, (*node._v__ast__OffsetOf).struct_type);
		v__gen__c__Gen_write(g, _STR("/*OffsetOf*/ (u32)(__offsetof(%.*s\000, %.*s\000))", 3, v__util__no_dots(styp), (*node._v__ast__OffsetOf).field));
	}
	else if (node._typ == 275 /* v.ast.SqlExpr */) {
		v__gen__c__Gen_sql_select_expr(g, (*node._v__ast__SqlExpr), false, _SLIT(""));
	}
	else if (node._typ == 277 /* v.ast.StringLiteral */) {
		v__gen__c__Gen_string_literal(g, (*node._v__ast__StringLiteral));
	}
	else if (node._typ == 276 /* v.ast.StringInterLiteral */) {
		v__gen__c__Gen_string_inter_literal(g, (*node._v__ast__StringInterLiteral));
	}
	else if (node._typ == 278 /* v.ast.StructInit */) {
		if ((*node._v__ast__StructInit).unresolved) {
			v__gen__c__Gen_expr(g, v__ast__resolve_init((*node._v__ast__StructInit), v__gen__c__Gen_unwrap_generic(g, (*node._v__ast__StructInit).typ), g->table));
		} else {
			v__gen__c__Gen_struct_init(g, (*node._v__ast__StructInit));
		}
	}
	else if (node._typ == 273 /* v.ast.SelectorExpr */) {
		v__gen__c__Gen_selector_expr(g, (*node._v__ast__SelectorExpr));
	}
	else if (node._typ == 279 /* v.ast.TypeNode */) {
		v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, (*node._v__ast__TypeNode).typ);
		string sidx = v__gen__c__Gen_type_sidx(g, (*node._v__ast__TypeNode).typ);
		v__gen__c__Gen_write(g, _STR("%.*s\000 /* %.*s\000 */", 3, sidx, sym->name));
	}
	else if (node._typ == 280 /* v.ast.TypeOf */) {
		v__gen__c__Gen_typeof_expr(g, (*node._v__ast__TypeOf));
	}
	else if (node._typ == 260 /* v.ast.Likely */) {
		if ((*node._v__ast__Likely).is_likely) {
			v__gen__c__Gen_write(g, _SLIT("_likely_"));
		} else {
			v__gen__c__Gen_write(g, _SLIT("_unlikely_"));
		}
		v__gen__c__Gen_write(g, _SLIT("("));
		v__gen__c__Gen_expr(g, (*node._v__ast__Likely).expr);
		v__gen__c__Gen_write(g, _SLIT(")"));
	}
	else if (node._typ == 281 /* v.ast.UnsafeExpr */) {
		v__gen__c__Gen_expr(g, (*node._v__ast__UnsafeExpr).expr);
	};
	g->discard_or_result = old_discard_or_result;
	g->is_void_expr_stmt = old_is_void_expr_stmt;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_type_name(v__gen__c__Gen* g, v__ast__Type type_) {
	v__ast__Type typ = type_;
	if (v__ast__Type_has_flag(typ, v__ast__TypeFlag_generic)) {
		typ = (*(v__ast__Type*)/*ee elem_typ */array_get(g->cur_generic_types, 0));
	}
	string s = v__ast__Table_type_to_str(g->table, typ);
	v__gen__c__Gen_write(g, _STR("_SLIT(\"%.*s\000\")", 2, v__util__strip_main_name(s)));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_typeof_expr(v__gen__c__Gen* g, v__ast__TypeOf node) {
	v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, node.expr_type);
	if (sym->kind == v__ast__Kind_sum_type) {
		v__gen__c__Gen_write(g, _STR("tos3( /* %.*s\000 */ v_typeof_sumtype_%.*s\000( (", 3, sym->name, sym->cname));
		v__gen__c__Gen_expr(g, node.expr);
		v__gen__c__Gen_write(g, _SLIT(")._typ ))"));
	} else if (sym->kind == v__ast__Kind_array_fixed) {
		v__ast__ArrayFixed fixed_info = /* as */ *(v__ast__ArrayFixed*)__as_cast((sym->info)._v__ast__ArrayFixed,(sym->info)._typ, 416) /*expected idx: 416, name: v.ast.ArrayFixed */ ;
		string typ_name = v__ast__Table_get_type_name(g->table, fixed_info.elem_type);
		v__gen__c__Gen_write(g, _STR("_SLIT(\"[%"PRId32"\000]%.*s\000\")", 3, fixed_info.size, v__util__strip_main_name(typ_name)));
	} else if (sym->kind == v__ast__Kind_function) {
		v__ast__FnType info = /* as */ *(v__ast__FnType*)__as_cast((sym->info)._v__ast__FnType,(sym->info)._typ, 418) /*expected idx: 418, name: v.ast.FnType */ ;
		v__gen__c__Gen_write(g, _STR("_SLIT(\"%.*s\000\")", 2, v__gen__c__Gen_fn_decl_str(g, info)));
	} else if (v__ast__Type_has_flag(node.expr_type, v__ast__TypeFlag_variadic)) {
		v__ast__TypeSymbol* varg_elem_type_sym = v__ast__Table_get_type_symbol(g->table, v__ast__Table_value_type(g->table, node.expr_type));
		v__gen__c__Gen_write(g, _STR("_SLIT(\"...%.*s\000\")", 2, v__util__strip_main_name(varg_elem_type_sym->name)));
	} else {
		string x = v__ast__Table_type_to_str(g->table, node.expr_type);
		string y = v__util__strip_main_name(x);
		v__gen__c__Gen_write(g, _STR("_SLIT(\"%.*s\000\")", 2, y));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_selector_expr(v__gen__c__Gen* g, v__ast__SelectorExpr node) {
	bool prevent_sum_type_unwrapping_once = g->prevent_sum_type_unwrapping_once;
	g->prevent_sum_type_unwrapping_once = false;
	if (node.name_type > 0) {
		v__gen__c__Gen_type_name(g, node.name_type);
		return;
	}
	if (node.expr_type == 0) {
		v__gen__c__Gen_checker_bug(g, _SLIT("unexpected SelectorExpr.expr_type = 0"), node.pos);
	}
	v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, v__gen__c__Gen_unwrap_generic(g, node.expr_type));
	bool is_optional = (node.expr)._typ == 254 /* v.ast.Ident */ && v__ast__Type_has_flag(node.expr_type, v__ast__TypeFlag_optional);
	if (is_optional) {
		string opt_base_typ = v__gen__c__Gen_base_type(g, node.expr_type);
		v__gen__c__Gen_writeln(g, _STR("(*(%.*s\000*)", 2, opt_base_typ));
	}
	if ((sym->kind == v__ast__Kind_interface_ || sym->kind == v__ast__Kind_sum_type)) {
		v__gen__c__Gen_write(g, _SLIT("(*("));
	}
	if (sym->kind == v__ast__Kind_array_fixed) {
		if (string_ne(node.field_name, _SLIT("len"))) {
			v__gen__c__Gen_error(g, _SLIT("field_name should be `len`"), node.pos);
		}
		v__ast__ArrayFixed info = /* as */ *(v__ast__ArrayFixed*)__as_cast((sym->info)._v__ast__ArrayFixed,(sym->info)._typ, 416) /*expected idx: 416, name: v.ast.ArrayFixed */ ;
		v__gen__c__Gen_write(g, _STR("%"PRId32"", 1, info.size));
		return;
	}
	if (sym->kind == v__ast__Kind_chan && (string_eq(node.field_name, _SLIT("len")) || string_eq(node.field_name, _SLIT("closed")))) {
		v__gen__c__Gen_write(g, _STR("sync__Channel_%.*s\000(", 2, node.field_name));
		v__gen__c__Gen_expr(g, node.expr);
		v__gen__c__Gen_write(g, _SLIT(")"));
		return;
	}
	string sum_type_deref_field = _SLIT("");
	string sum_type_dot = _SLIT(".");
	Option_v__ast__StructField _t2921;
	if (_t2921 = v__ast__Table_find_field(g->table, sym, node.field_name), _t2921.state == 0) {
		v__ast__StructField f = *(v__ast__StructField*)_t2921.data;
		v__ast__TypeSymbol* field_sym = v__ast__Table_get_type_symbol(g->table, f.typ);
		if ((field_sym->kind == v__ast__Kind_sum_type || field_sym->kind == v__ast__Kind_interface_)) {
			if (!prevent_sum_type_unwrapping_once) {
				v__ast__Scope* scope = v__ast__Scope_innermost(g->file.scope, node.pos.pos);
				Option_v__ast__ScopeStructField _t2922;
				if (_t2922 = v__ast__Scope_find_struct_field(scope, node.expr_type, node.field_name), _t2922.state == 0) {
					v__ast__ScopeStructField field = *(v__ast__ScopeStructField*)_t2922.data;
					if (v__ast__Type_is_ptr(field.orig_type)) {
						sum_type_dot = _SLIT("->");
					}
					// FOR IN array
					for (int i = 0; i < field.smartcasts.len; ++i) {
						v__ast__Type typ = ((v__ast__Type*)field.smartcasts.data)[i];
						v__gen__c__Gen_write(g, _SLIT("("));
						if (field_sym->kind == v__ast__Kind_sum_type) {
							v__gen__c__Gen_write(g, _SLIT("*"));
						}
						v__ast__TypeSymbol* cast_sym = v__ast__Table_get_type_symbol(g->table, typ);
						if (i != 0) {
							string dot = (v__ast__Type_is_ptr(field.typ) ? (_SLIT("->")) : (_SLIT(".")));
							sum_type_deref_field = /*f*/string_add(sum_type_deref_field, _STR(")%.*s", 1, dot));
						}
						if ((cast_sym->info)._typ == 408 /* v.ast.Aggregate */) {
							v__ast__TypeSymbol* agg_sym = v__ast__Table_get_type_symbol(g->table, (*(v__ast__Type*)/*ee elem_typ */array_get((*cast_sym->info._v__ast__Aggregate).types, g->aggregate_type_idx)));
							sum_type_deref_field = /*f*/string_add(sum_type_deref_field, _STR("_%.*s", 1, agg_sym->cname));
						} else {
							sum_type_deref_field = /*f*/string_add(sum_type_deref_field, _STR("_%.*s", 1, cast_sym->cname));
						}
					}
				}
			}
		}
	}
	v__gen__c__Gen_expr(g, node.expr);
	if (is_optional) {
		v__gen__c__Gen_write(g, _SLIT(".data)"));
	}
	if ((sym->info)._typ == 409 /* v.ast.Struct */) {
		if (node.from_embed_type != 0) {
			v__ast__TypeSymbol* embed_sym = v__ast__Table_get_type_symbol(g->table, node.from_embed_type);
			string embed_name = v__ast__TypeSymbol_embed_name(embed_sym);
			if (v__ast__Type_is_ptr(node.expr_type)) {
				v__gen__c__Gen_write(g, _SLIT("->"));
			} else {
				v__gen__c__Gen_write(g, _SLIT("."));
			}
			v__gen__c__Gen_write(g, embed_name);
		}
	}
	if ((v__ast__Type_is_ptr(node.expr_type) || sym->kind == v__ast__Kind_chan) && node.from_embed_type == 0) {
		v__gen__c__Gen_write(g, _SLIT("->"));
	} else {
		v__gen__c__Gen_write(g, _SLIT("."));
	}
	if (v__ast__Type_has_flag(node.expr_type, v__ast__TypeFlag_shared_f)) {
		v__gen__c__Gen_write(g, _SLIT("val."));
	}
	if (node.expr_type == 0) {
		v__gen__c__verror(_STR("cgen: SelectorExpr | expr_type: 0 | it.expr: `%.*s\000` | field: `%.*s\000` | file: %.*s\000 | line: %"PRId32"", 4, v__ast__Expr_str(node.expr), node.field_name, g->file.path, node.pos.line_nr));
	}
	v__gen__c__Gen_write(g, v__gen__c__c_name(node.field_name));
	if ((sum_type_deref_field).len != 0) {
		v__gen__c__Gen_write(g, _STR("%.*s\000%.*s\000)", 3, sum_type_dot, sum_type_deref_field));
	}
	if ((sym->kind == v__ast__Kind_interface_ || sym->kind == v__ast__Kind_sum_type)) {
		v__gen__c__Gen_write(g, _SLIT("))"));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_enum_expr(v__gen__c__Gen* g, v__ast__Expr node) {
	if (node._typ == 251 /* v.ast.EnumVal */) {
		v__gen__c__Gen_write(g, (*node._v__ast__EnumVal).val);
	}
	else {
		v__gen__c__Gen_expr(g, node);
	};
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_infix_gen_equality(v__gen__c__Gen* g, v__ast__InfixExpr node, v__ast__Type left_type, v__ast__TypeSymbol left_sym, v__ast__TypeSymbol right_sym) {
	if (left_sym.kind != right_sym.kind) {
		return;
	}

	if (left_sym.kind == (v__ast__Kind_array)) {
		string ptr_typ = v__gen__c__Gen_gen_array_equality_fn(g, v__ast__Type_clear_flag(left_type, v__ast__TypeFlag_shared_f));
		if (node.op == v__token__Kind_ne) {
			v__gen__c__Gen_write(g, _SLIT("!"));
		}
		v__gen__c__Gen_write(g, _STR("%.*s\000_arr_eq(", 2, ptr_typ));
		if (v__ast__Type_is_ptr(node.left_type) && !v__ast__Type_has_flag(node.left_type, v__ast__TypeFlag_shared_f)) {
			v__gen__c__Gen_write(g, _SLIT("*"));
		}
		v__gen__c__Gen_expr(g, node.left);
		if (v__ast__Type_has_flag(node.left_type, v__ast__TypeFlag_shared_f)) {
			if (v__ast__Type_is_ptr(node.left_type)) {
				v__gen__c__Gen_write(g, _SLIT("->val"));
			} else {
				v__gen__c__Gen_write(g, _SLIT(".val"));
			}
		}
		v__gen__c__Gen_write(g, _SLIT(", "));
		if (v__ast__Type_is_ptr(node.right_type) && !v__ast__Type_has_flag(node.right_type, v__ast__TypeFlag_shared_f)) {
			v__gen__c__Gen_write(g, _SLIT("*"));
		}
		v__gen__c__Gen_expr(g, node.right);
		if (v__ast__Type_has_flag(node.right_type, v__ast__TypeFlag_shared_f)) {
			if (v__ast__Type_is_ptr(node.right_type)) {
				v__gen__c__Gen_write(g, _SLIT("->val"));
			} else {
				v__gen__c__Gen_write(g, _SLIT(".val"));
			}
		}
		v__gen__c__Gen_write(g, _SLIT(")"));
	}
	else if (left_sym.kind == (v__ast__Kind_array_fixed)) {
		string ptr_typ = v__gen__c__Gen_gen_fixed_array_equality_fn(g, left_type);
		if (node.op == v__token__Kind_ne) {
			v__gen__c__Gen_write(g, _SLIT("!"));
		}
		v__gen__c__Gen_write(g, _STR("%.*s\000_arr_eq(", 2, ptr_typ));
		if (v__ast__Type_is_ptr(node.left_type)) {
			v__gen__c__Gen_write(g, _SLIT("*"));
		}
		if ((node.left)._typ == 235 /* v.ast.ArrayInit */) {
			string s = v__gen__c__Gen_typ(g, left_type);
			v__gen__c__Gen_write(g, _STR("(%.*s\000)", 2, s));
		}
		v__gen__c__Gen_expr(g, node.left);
		v__gen__c__Gen_write(g, _SLIT(", "));
		if ((node.right)._typ == 235 /* v.ast.ArrayInit */) {
			string s = v__gen__c__Gen_typ(g, left_type);
			v__gen__c__Gen_write(g, _STR("(%.*s\000)", 2, s));
		}
		v__gen__c__Gen_expr(g, node.right);
		v__gen__c__Gen_write(g, _SLIT(")"));
	}
	else if (left_sym.kind == (v__ast__Kind_alias)) {
		string ptr_typ = v__gen__c__Gen_gen_alias_equality_fn(g, left_type);
		if (node.op == v__token__Kind_eq) {
			v__gen__c__Gen_write(g, _STR("%.*s\000_alias_eq(", 2, ptr_typ));
		} else if (node.op == v__token__Kind_ne) {
			v__gen__c__Gen_write(g, _STR("!%.*s\000_alias_eq(", 2, ptr_typ));
		}
		if (v__ast__Type_is_ptr(node.left_type)) {
			v__gen__c__Gen_write(g, _SLIT("*"));
		}
		v__gen__c__Gen_expr(g, node.left);
		v__gen__c__Gen_write(g, _SLIT(", "));
		if (v__ast__Type_is_ptr(node.right_type)) {
			v__gen__c__Gen_write(g, _SLIT("*"));
		}
		v__gen__c__Gen_expr(g, node.right);
		v__gen__c__Gen_write(g, _SLIT(")"));
	}
	else if (left_sym.kind == (v__ast__Kind_map)) {
		string ptr_typ = v__gen__c__Gen_gen_map_equality_fn(g, left_type);
		if (node.op == v__token__Kind_eq) {
			v__gen__c__Gen_write(g, _STR("%.*s\000_map_eq(", 2, ptr_typ));
		} else if (node.op == v__token__Kind_ne) {
			v__gen__c__Gen_write(g, _STR("!%.*s\000_map_eq(", 2, ptr_typ));
		}
		if (v__ast__Type_is_ptr(node.left_type)) {
			v__gen__c__Gen_write(g, _SLIT("*"));
		}
		v__gen__c__Gen_expr(g, node.left);
		v__gen__c__Gen_write(g, _SLIT(", "));
		if (v__ast__Type_is_ptr(node.right_type)) {
			v__gen__c__Gen_write(g, _SLIT("*"));
		}
		v__gen__c__Gen_expr(g, node.right);
		v__gen__c__Gen_write(g, _SLIT(")"));
	}
	else if (left_sym.kind == (v__ast__Kind_struct_)) {
		string ptr_typ = v__gen__c__Gen_gen_struct_equality_fn(g, left_type);
		if (node.op == v__token__Kind_eq) {
			v__gen__c__Gen_write(g, _STR("%.*s\000_struct_eq(", 2, ptr_typ));
		} else if (node.op == v__token__Kind_ne) {
			v__gen__c__Gen_write(g, _STR("!%.*s\000_struct_eq(", 2, ptr_typ));
		}
		if (v__ast__Type_is_ptr(node.left_type)) {
			v__gen__c__Gen_write(g, _SLIT("*"));
		}
		v__gen__c__Gen_expr(g, node.left);
		v__gen__c__Gen_write(g, _SLIT(", "));
		if (v__ast__Type_is_ptr(node.right_type)) {
			v__gen__c__Gen_write(g, _SLIT("*"));
		}
		v__gen__c__Gen_expr(g, node.right);
		v__gen__c__Gen_write(g, _SLIT(")"));
	}
	else if (left_sym.kind == (v__ast__Kind_sum_type)) {
		string ptr_typ = v__gen__c__Gen_gen_sumtype_equality_fn(g, left_type);
		if (node.op == v__token__Kind_eq) {
			v__gen__c__Gen_write(g, _STR("%.*s\000_sumtype_eq(", 2, ptr_typ));
		} else if (node.op == v__token__Kind_ne) {
			v__gen__c__Gen_write(g, _STR("!%.*s\000_sumtype_eq(", 2, ptr_typ));
		}
		if (v__ast__Type_is_ptr(node.left_type)) {
			v__gen__c__Gen_write(g, _SLIT("*"));
		}
		v__gen__c__Gen_expr(g, node.left);
		v__gen__c__Gen_write(g, _SLIT(", "));
		if (v__ast__Type_is_ptr(node.right_type)) {
			v__gen__c__Gen_write(g, _SLIT("*"));
		}
		v__gen__c__Gen_expr(g, node.right);
		v__gen__c__Gen_write(g, _SLIT(")"));
	}
	else {
	};
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_infix_in_or_not_in(v__gen__c__Gen* g, v__ast__InfixExpr node, v__ast__TypeSymbol left_sym, v__ast__TypeSymbol right_sym) {
	if (node.op == v__token__Kind_not_in) {
		v__gen__c__Gen_write(g, _SLIT("!"));
	}
	if (right_sym.kind == v__ast__Kind_array) {
		if ((node.right)._typ == 235 /* v.ast.ArrayInit */) {
			if ((*node.right._v__ast__ArrayInit).exprs.len > 0) {
				v__gen__c__Gen_write(g, _SLIT("("));
				v__gen__c__Gen_in_optimization(g, node.left, (*node.right._v__ast__ArrayInit));
				v__gen__c__Gen_write(g, _SLIT(")"));
				return;
			}
		}
		string fn_name = v__gen__c__Gen_gen_array_contains_method(g, node.right_type);
		v__gen__c__Gen_write(g, _STR("(%.*s\000(", 2, fn_name));
		if (v__ast__Type_is_ptr(node.right_type)) {
			v__gen__c__Gen_write(g, _SLIT("*"));
		}
		v__gen__c__Gen_expr(g, node.right);
		v__gen__c__Gen_write(g, _SLIT(", "));
		v__gen__c__Gen_expr(g, node.left);
		v__gen__c__Gen_write(g, _SLIT("))"));
		return;
	} else if (right_sym.kind == v__ast__Kind_map) {
		v__gen__c__Gen_write(g, _SLIT("_IN_MAP("));
		if (!v__ast__Type_is_ptr(node.left_type)) {
			string left_type_str = v__ast__Table_type_to_str(g->table, node.left_type);
			v__gen__c__Gen_write(g, _STR("ADDR(%.*s\000, ", 2, left_type_str));
			v__gen__c__Gen_expr(g, node.left);
			v__gen__c__Gen_write(g, _SLIT(")"));
		} else {
			v__gen__c__Gen_expr(g, node.left);
		}
		v__gen__c__Gen_write(g, _SLIT(", "));
		if (!v__ast__Type_is_ptr(node.right_type)) {
			v__gen__c__Gen_write(g, _SLIT("ADDR(map, "));
			v__gen__c__Gen_expr(g, node.right);
			v__gen__c__Gen_write(g, _SLIT(")"));
		} else {
			v__gen__c__Gen_expr(g, node.right);
		}
		v__gen__c__Gen_write(g, _SLIT(")"));
	} else if (right_sym.kind == v__ast__Kind_string) {
		v__gen__c__Gen_write(g, _SLIT("string_contains("));
		v__gen__c__Gen_expr(g, node.right);
		v__gen__c__Gen_write(g, _SLIT(", "));
		v__gen__c__Gen_expr(g, node.left);
		v__gen__c__Gen_write(g, _SLIT(")"));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_infix_expr(v__gen__c__Gen* g, v__ast__InfixExpr node) {
	if ((node.auto_locked).len != 0) {
		v__gen__c__Gen_writeln(g, _STR("sync__RwMutex_lock(&%.*s\000->mtx);", 2, node.auto_locked));
	}
	if ((node.op == v__token__Kind_key_is || node.op == v__token__Kind_not_is)) {
		v__gen__c__Gen_is_expr(g, node);
		return;
	}
	v__ast__Type left_type = v__gen__c__Gen_unwrap_generic(g, node.left_type);
	v__ast__TypeSymbol* left_sym = v__ast__Table_get_type_symbol(g->table, left_type);
	v__ast__TypeSymbol* left_final_sym = v__ast__Table_get_final_type_symbol(g->table, left_type);
	v__ast__Type unaliased_left = (left_sym->kind == v__ast__Kind_alias ? ((/* as */ *(v__ast__Alias*)__as_cast((left_sym->info)._v__ast__Alias,(left_sym->info)._typ, 413) /*expected idx: 413, name: v.ast.Alias */ ).parent_type) : (left_type));
	bool op_is_key_in_or_not_in = (node.op == v__token__Kind_key_in || node.op == v__token__Kind_not_in);
	bool op_is_eq_or_ne = (node.op == v__token__Kind_eq || node.op == v__token__Kind_ne);
	v__ast__TypeSymbol* right_sym = v__ast__Table_get_type_symbol(g->table, node.right_type);
	v__ast__TypeSymbol* right_final_sym = v__ast__Table_get_final_type_symbol(g->table, node.right_type);
	v__ast__Type unaliased_right = ((right_sym->info)._typ == 413 /* v.ast.Alias */ ? ((*right_sym->info._v__ast__Alias).parent_type) : (node.right_type));
	if (unaliased_left == _const_v__ast__ustring_type_idx && !op_is_key_in_or_not_in) {
		string _t2923;
		
		if (node.op == (v__token__Kind_plus)) {
			_t2923 = _SLIT("ustring_add(");
		}
		else if (node.op == (v__token__Kind_eq)) {
			_t2923 = _SLIT("ustring_eq(");
		}
		else if (node.op == (v__token__Kind_ne)) {
			_t2923 = _SLIT("ustring_ne(");
		}
		else if (node.op == (v__token__Kind_lt)) {
			_t2923 = _SLIT("ustring_lt(");
		}
		else if (node.op == (v__token__Kind_le)) {
			_t2923 = _SLIT("ustring_le(");
		}
		else if (node.op == (v__token__Kind_gt)) {
			_t2923 = _SLIT("ustring_gt(");
		}
		else if (node.op == (v__token__Kind_ge)) {
			_t2923 = _SLIT("ustring_ge(");
		}
		else {
			v__gen__c__verror(_STR("op error for type `%.*s\000`", 2, left_sym->name));
			_t2923 = _SLIT("/*node error*/");
		}		string fn_name = _t2923;
		v__gen__c__Gen_write(g, fn_name);
		v__gen__c__Gen_expr(g, node.left);
		v__gen__c__Gen_write(g, _SLIT(", "));
		v__gen__c__Gen_expr(g, node.right);
		v__gen__c__Gen_write(g, _SLIT(")"));
	} else if (unaliased_left == _const_v__ast__string_type_idx && !op_is_key_in_or_not_in) {
		if ((node.op == v__token__Kind_eq || node.op == v__token__Kind_ne) && (node.right)._typ == 277 /* v.ast.StringLiteral */ && ((/* as */ *(v__ast__StringLiteral*)__as_cast((node.right)._v__ast__StringLiteral,(node.right)._typ, 277) /*expected idx: 277, name: v.ast.StringLiteral */ ).val).len == 0) {
			string arrow = (v__ast__Type_is_ptr(left_type) ? (_SLIT("->")) : (_SLIT(".")));
			v__gen__c__Gen_write(g, _SLIT("("));
			v__gen__c__Gen_expr(g, node.left);
			v__gen__c__Gen_write(g, _SLIT(")"));
			v__gen__c__Gen_write(g, _STR("%.*s\000len %.*s\000 0", 3, arrow, v__token__Kind_str(node.op)));
		} else {
			string _t2924;
			
			if (node.op == (v__token__Kind_plus)) {
				_t2924 = _SLIT("string_add(");
			}
			else if (node.op == (v__token__Kind_eq)) {
				_t2924 = _SLIT("string_eq(");
			}
			else if (node.op == (v__token__Kind_ne)) {
				_t2924 = _SLIT("string_ne(");
			}
			else if (node.op == (v__token__Kind_lt)) {
				_t2924 = _SLIT("string_lt(");
			}
			else if (node.op == (v__token__Kind_le)) {
				_t2924 = _SLIT("string_le(");
			}
			else if (node.op == (v__token__Kind_gt)) {
				_t2924 = _SLIT("string_gt(");
			}
			else if (node.op == (v__token__Kind_ge)) {
				_t2924 = _SLIT("string_ge(");
			}
			else {
				v__gen__c__verror(_STR("op error for type `%.*s\000`", 2, left_sym->name));
				_t2924 = _SLIT("/*node error*/");
			}			string fn_name = _t2924;
			v__gen__c__Gen_write(g, fn_name);
			v__gen__c__Gen_expr(g, node.left);
			v__gen__c__Gen_write(g, _SLIT(", "));
			v__gen__c__Gen_expr(g, node.right);
			v__gen__c__Gen_write(g, _SLIT(")"));
		}
	} else if (op_is_eq_or_ne && left_sym->kind == right_sym->kind && (left_sym->kind == v__ast__Kind_array || left_sym->kind == v__ast__Kind_array_fixed || left_sym->kind == v__ast__Kind_alias || left_sym->kind == v__ast__Kind_map || left_sym->kind == v__ast__Kind_struct_ || left_sym->kind == v__ast__Kind_sum_type)) {
		v__gen__c__Gen_infix_gen_equality(g, node, left_type, *left_sym, *right_sym);
	} else if (op_is_key_in_or_not_in) {
		v__gen__c__Gen_infix_in_or_not_in(g, node, *left_sym, *right_sym);
	} else if (node.op == v__token__Kind_left_shift && left_final_sym->kind == v__ast__Kind_array) {
		string tmp = v__gen__c__Gen_new_tmp_var(g);
		v__ast__Array info = /* as */ *(v__ast__Array*)__as_cast((left_final_sym->info)._v__ast__Array,(left_final_sym->info)._typ, 395) /*expected idx: 395, name: v.ast.Array */ ;
		if (right_final_sym->kind == v__ast__Kind_array && !v__ast__Type_alias_eq(info.elem_type, node.right_type)) {
			v__gen__c__Gen_write(g, _SLIT("_PUSH_MANY("));
			v__ast__Type expected_push_many_atype = left_type;
			if (!v__ast__Type_is_ptr(expected_push_many_atype)) {
				v__gen__c__Gen_write(g, _SLIT("&"));
			} else {
				expected_push_many_atype = v__ast__Type_deref(expected_push_many_atype);
			}
			v__gen__c__Gen_expr(g, node.left);
			v__gen__c__Gen_write(g, _SLIT(", ("));
			v__gen__c__Gen_expr_with_cast(g, node.right, node.right_type, left_type);
			string styp = v__gen__c__Gen_typ(g, expected_push_many_atype);
			v__gen__c__Gen_write(g, _STR("), %.*s\000, %.*s\000)", 3, tmp, styp));
		} else {
			string elem_type_str = v__gen__c__Gen_typ(g, info.elem_type);
			v__ast__TypeSymbol* elem_sym = v__ast__Table_get_type_symbol(g->table, info.elem_type);
			v__gen__c__Gen_write(g, _SLIT("array_push("));
			if (!v__ast__Type_is_ptr(left_type)) {
				v__gen__c__Gen_write(g, _SLIT("&"));
			}
			v__gen__c__Gen_expr(g, node.left);
			if (elem_sym->kind == v__ast__Kind_function) {
				v__gen__c__Gen_write(g, _SLIT(", _MOV((voidptr[]){ "));
			} else {
				v__gen__c__Gen_write(g, _STR(", _MOV((%.*s\000[]){ ", 2, elem_type_str));
			}
			bool needs_clone = v__ast__Type_alias_eq(info.elem_type, _const_v__ast__string_type) && !g->is_builtin_mod;
			if (needs_clone) {
				v__gen__c__Gen_write(g, _SLIT("string_clone("));
			}
			v__gen__c__Gen_expr_with_cast(g, node.right, node.right_type, info.elem_type);
			if (needs_clone) {
				v__gen__c__Gen_write(g, _SLIT(")"));
			}
			v__gen__c__Gen_write(g, _SLIT(" }))"));
		}
	} else if (node.op == v__token__Kind_arrow) {
		bool gen_or = node.or_block.kind != v__ast__OrKind_absent;
		string styp = left_sym->cname;
		v__ast__Chan left_inf = /* as */ *(v__ast__Chan*)__as_cast((left_sym->info)._v__ast__Chan,(left_sym->info)._typ, 414) /*expected idx: 414, name: v.ast.Chan */ ;
		v__ast__Type elem_type = left_inf.elem_type;
		string tmp_opt = (gen_or ? (v__gen__c__Gen_new_tmp_var(g)) : (_SLIT("")));
		if (gen_or) {
			string elem_styp = v__gen__c__Gen_typ(g, elem_type);
			v__gen__c__Gen_register_chan_push_optional_call(g, elem_styp, styp);
			v__gen__c__Gen_write(g, _STR("Option_void %.*s\000 = __Option_%.*s\000_pushval(", 3, tmp_opt, styp));
		} else {
			v__gen__c__Gen_write(g, _STR("__%.*s\000_pushval(", 2, styp));
		}
		v__gen__c__Gen_expr(g, node.left);
		v__gen__c__Gen_write(g, _SLIT(", "));
		v__gen__c__Gen_expr(g, node.right);
		v__gen__c__Gen_write(g, _SLIT(")"));
		if (gen_or) {
			v__gen__c__Gen_or_block(g, tmp_opt, node.or_block, _const_v__ast__void_type);
		}
	} else if ((v__ast__Type_idx(unaliased_left) == _const_v__ast__u32_type_idx || v__ast__Type_idx(unaliased_left) == _const_v__ast__u64_type_idx) && v__ast__Type_is_signed(unaliased_right) && (node.op == v__token__Kind_eq || node.op == v__token__Kind_ne || node.op == v__token__Kind_gt || node.op == v__token__Kind_lt || node.op == v__token__Kind_ge || node.op == v__token__Kind_le)) {
		int bitsize = (v__ast__Type_idx(unaliased_left) == _const_v__ast__u32_type_idx && v__ast__Type_idx(unaliased_right) != _const_v__ast__i64_type_idx ? (32) : (64));
		v__gen__c__Gen_write(g, _STR("_us%"PRId32"\000_%.*s\000(", 3, bitsize, (*(string*)/*ee elem_typ */array_get(_const_v__gen__c__cmp_str, ((int)(node.op)) - ((int)(v__token__Kind_eq))))));
		v__gen__c__Gen_expr(g, node.left);
		v__gen__c__Gen_write(g, _SLIT(","));
		v__gen__c__Gen_expr(g, node.right);
		v__gen__c__Gen_write(g, _SLIT(")"));
	} else if ((v__ast__Type_idx(unaliased_right) == _const_v__ast__u32_type_idx || v__ast__Type_idx(unaliased_right) == _const_v__ast__u64_type_idx) && v__ast__Type_is_signed(unaliased_left) && (node.op == v__token__Kind_eq || node.op == v__token__Kind_ne || node.op == v__token__Kind_gt || node.op == v__token__Kind_lt || node.op == v__token__Kind_ge || node.op == v__token__Kind_le)) {
		int bitsize = (v__ast__Type_idx(unaliased_right) == _const_v__ast__u32_type_idx && v__ast__Type_idx(unaliased_left) != _const_v__ast__i64_type_idx ? (32) : (64));
		v__gen__c__Gen_write(g, _STR("_us%"PRId32"\000_%.*s\000(", 3, bitsize, (*(string*)/*ee elem_typ */array_get(_const_v__gen__c__cmp_rev, ((int)(node.op)) - ((int)(v__token__Kind_eq))))));
		v__gen__c__Gen_expr(g, node.right);
		v__gen__c__Gen_write(g, _SLIT(","));
		v__gen__c__Gen_expr(g, node.left);
		v__gen__c__Gen_write(g, _SLIT(")"));
	} else {
		bool a = (byte_is_capital(string_at(left_sym->name, 0)) || string_contains(left_sym->name, _SLIT("."))) && !(left_sym->kind == v__ast__Kind_enum_ || left_sym->kind == v__ast__Kind_function || left_sym->kind == v__ast__Kind_interface_ || left_sym->kind == v__ast__Kind_sum_type) && left_sym->language != v__ast__Language_c;
		bool b = left_sym->kind != v__ast__Kind_alias;
		bool c = left_sym->kind == v__ast__Kind_alias && (/* as */ *(v__ast__Alias*)__as_cast((left_sym->info)._v__ast__Alias,(left_sym->info)._typ, 413) /*expected idx: 413, name: v.ast.Alias */ ).language == v__ast__Language_c;
		bool d = !b && byte_is_capital(string_at((*(string*)array_last(string_split(v__gen__c__Gen_typ(g, (/* as */ *(v__ast__Alias*)__as_cast((left_sym->info)._v__ast__Alias,(left_sym->info)._typ, 413) /*expected idx: 413, name: v.ast.Alias */ ).parent_type), _SLIT("__")))), 0));
		bool e = !(right_sym->kind == v__ast__Kind_voidptr || right_sym->kind == v__ast__Kind_int_literal || right_sym->kind == v__ast__Kind_int);
		if ((node.op == v__token__Kind_plus || node.op == v__token__Kind_minus || node.op == v__token__Kind_mul || node.op == v__token__Kind_div || node.op == v__token__Kind_mod || node.op == v__token__Kind_lt || node.op == v__token__Kind_eq) && ((a && b && e) || c || d)) {
			v__ast__Type the_left_type = (!d || (v__ast__Table_get_type_symbol(g->table, (/* as */ *(v__ast__Alias*)__as_cast((left_sym->info)._v__ast__Alias,(left_sym->info)._typ, 413) /*expected idx: 413, name: v.ast.Alias */ ).parent_type)->kind == v__ast__Kind_array || v__ast__Table_get_type_symbol(g->table, (/* as */ *(v__ast__Alias*)__as_cast((left_sym->info)._v__ast__Alias,(left_sym->info)._typ, 413) /*expected idx: 413, name: v.ast.Alias */ ).parent_type)->kind == v__ast__Kind_array_fixed || v__ast__Table_get_type_symbol(g->table, (/* as */ *(v__ast__Alias*)__as_cast((left_sym->info)._v__ast__Alias,(left_sym->info)._typ, 413) /*expected idx: 413, name: v.ast.Alias */ ).parent_type)->kind == v__ast__Kind_map) ? (left_type) : ((/* as */ *(v__ast__Alias*)__as_cast((left_sym->info)._v__ast__Alias,(left_sym->info)._typ, 413) /*expected idx: 413, name: v.ast.Alias */ ).parent_type));
			v__gen__c__Gen_write(g, v__gen__c__Gen_typ(g, the_left_type));
			v__gen__c__Gen_write(g, _SLIT("_"));
			v__gen__c__Gen_write(g, v__util__replace_op(v__token__Kind_str(node.op)));
			v__gen__c__Gen_write(g, _SLIT("("));
			v__gen__c__Gen_expr(g, node.left);
			v__gen__c__Gen_write(g, _SLIT(", "));
			v__gen__c__Gen_expr(g, node.right);
			v__gen__c__Gen_write(g, _SLIT(")"));
		} else if ((node.op == v__token__Kind_ne || node.op == v__token__Kind_gt || node.op == v__token__Kind_ge || node.op == v__token__Kind_le) && ((a && b && e) || c || d)) {
			v__ast__Type the_left_type = (!d ? (left_type) : ((/* as */ *(v__ast__Alias*)__as_cast((left_sym->info)._v__ast__Alias,(left_sym->info)._typ, 413) /*expected idx: 413, name: v.ast.Alias */ ).parent_type));
			string typ = v__gen__c__Gen_typ(g, the_left_type);
			if (node.op == v__token__Kind_gt) {
				v__gen__c__Gen_write(g, _STR("%.*s", 1, typ));
			} else {
				v__gen__c__Gen_write(g, _STR("!%.*s", 1, typ));
			}
			v__gen__c__Gen_write(g, _SLIT("_"));
			if (node.op == v__token__Kind_ne) {
				v__gen__c__Gen_write(g, _SLIT("_eq"));
			} else if ((node.op == v__token__Kind_ge || node.op == v__token__Kind_le || node.op == v__token__Kind_gt)) {
				v__gen__c__Gen_write(g, _SLIT("_lt"));
			}
			if ((node.op == v__token__Kind_le || node.op == v__token__Kind_gt)) {
				v__gen__c__Gen_write(g, _SLIT("("));
				v__gen__c__Gen_expr(g, node.right);
				v__gen__c__Gen_write(g, _SLIT(", "));
				v__gen__c__Gen_expr(g, node.left);
				v__gen__c__Gen_write(g, _SLIT(")"));
			} else {
				v__gen__c__Gen_write(g, _SLIT("("));
				v__gen__c__Gen_expr(g, node.left);
				v__gen__c__Gen_write(g, _SLIT(", "));
				v__gen__c__Gen_expr(g, node.right);
				v__gen__c__Gen_write(g, _SLIT(")"));
			}
		} else {
			bool need_par = (node.op == v__token__Kind_amp || node.op == v__token__Kind_pipe || node.op == v__token__Kind_xor);
			if (need_par) {
				v__gen__c__Gen_write(g, _SLIT("("));
			}
			if (v__ast__Type_is_ptr(node.left_type) && v__ast__Expr_is_auto_deref_var(node.left)) {
				v__gen__c__Gen_write(g, _SLIT("*"));
			}
			v__gen__c__Gen_expr(g, node.left);
			v__gen__c__Gen_write(g, _STR(" %.*s\000 ", 2, v__token__Kind_str(node.op)));
			if (v__ast__Type_is_ptr(node.right_type) && v__ast__Expr_is_auto_deref_var(node.right)) {
				v__gen__c__Gen_write(g, _SLIT("*"));
			}
			v__gen__c__Gen_expr(g, node.right);
			if (need_par) {
				v__gen__c__Gen_write(g, _SLIT(")"));
			}
		}
	}
	if ((node.auto_locked).len != 0) {
		v__gen__c__Gen_writeln(g, _SLIT(";"));
		v__gen__c__Gen_write(g, _STR("sync__RwMutex_unlock(&%.*s\000->mtx)", 2, node.auto_locked));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_lock_expr(v__gen__c__Gen* g, v__ast__LockExpr node) {
	string tmp_result = (node.is_expr ? (v__gen__c__Gen_new_tmp_var(g)) : (_SLIT("")));
	string cur_line = _SLIT("");
	if (node.is_expr) {
		string styp = v__gen__c__Gen_typ(g, node.typ);
		cur_line = v__gen__c__Gen_go_before_stmt(g, 0);
		v__gen__c__Gen_writeln(g, _STR("%.*s\000 %.*s\000;", 3, styp, tmp_result));
	}
	string mtxs = _SLIT("");
	if (node.lockeds.len == 0) {
	} else if (node.lockeds.len == 1) {
		v__ast__Ident id = (*(v__ast__Ident*)/*ee elem_typ */array_get(node.lockeds, 0));
		string name = id.name;
		string deref = (id.is_mut ? (_SLIT("->")) : (_SLIT(".")));
		string lock_prefix = ((*(bool*)/*ee elem_typ */array_get(node.is_rlock, 0)) ? (_SLIT("r")) : (_SLIT("")));
		v__gen__c__Gen_writeln(g, _STR("sync__RwMutex_%.*s\000lock(&%.*s\000%.*s\000mtx);", 4, lock_prefix, name, deref));
	} else {
		mtxs = v__gen__c__Gen_new_tmp_var(g);
		v__gen__c__Gen_writeln(g, _STR("uintptr_t _arr_%.*s\000[%"PRId32"\000];", 3, mtxs, node.lockeds.len));
		v__gen__c__Gen_writeln(g, _STR("bool _isrlck_%.*s\000[%"PRId32"\000];", 3, mtxs, node.lockeds.len));
		int j = 0;
		// FOR IN array
		for (int i = 0; i < node.lockeds.len; ++i) {
			v__ast__Ident id = ((v__ast__Ident*)node.lockeds.data)[i];
			if (!(*(bool*)/*ee elem_typ */array_get(node.is_rlock, i))) {
				string name = id.name;
				string deref = (id.is_mut ? (_SLIT("->")) : (_SLIT(".")));
				v__gen__c__Gen_writeln(g, _STR("_arr_%.*s\000[%"PRId32"\000] = &%.*s\000%.*s\000mtx;", 5, mtxs, j, name, deref));
				v__gen__c__Gen_writeln(g, _STR("_isrlck_%.*s\000[%"PRId32"\000] = false;", 3, mtxs, j));
				j++;
			}
		}
		// FOR IN array
		for (int i = 0; i < node.lockeds.len; ++i) {
			v__ast__Ident id = ((v__ast__Ident*)node.lockeds.data)[i];
			if ((*(bool*)/*ee elem_typ */array_get(node.is_rlock, i))) {
				string name = id.name;
				string deref = (id.is_mut ? (_SLIT("->")) : (_SLIT(".")));
				v__gen__c__Gen_writeln(g, _STR("_arr_%.*s\000[%"PRId32"\000] = &%.*s\000%.*s\000mtx;", 5, mtxs, j, name, deref));
				v__gen__c__Gen_writeln(g, _STR("_isrlck_%.*s\000[%"PRId32"\000] = true;", 3, mtxs, j));
				j++;
			}
		}
		v__gen__c__Gen_writeln(g, _STR("__sort_ptr(_arr_%.*s\000, _isrlck_%.*s\000, %"PRId32"\000);", 4, mtxs, mtxs, node.lockeds.len));
		v__gen__c__Gen_writeln(g, _STR("for (int %.*s\000=0; %.*s\000<%"PRId32"\000; %.*s\000++) {", 5, mtxs, mtxs, node.lockeds.len, mtxs));
		v__gen__c__Gen_writeln(g, _STR("\tif (%.*s\000 && _arr_%.*s\000[%.*s\000] == _arr_%.*s\000[%.*s\000-1]) continue;", 6, mtxs, mtxs, mtxs, mtxs, mtxs));
		v__gen__c__Gen_writeln(g, _STR("\tif (_isrlck_%.*s\000[%.*s\000])", 3, mtxs, mtxs));
		v__gen__c__Gen_writeln(g, _STR("\t\tsync__RwMutex_rlock((sync__RwMutex*)_arr_%.*s\000[%.*s\000]);", 3, mtxs, mtxs));
		v__gen__c__Gen_writeln(g, _SLIT("\telse"));
		v__gen__c__Gen_writeln(g, _STR("\t\tsync__RwMutex_lock((sync__RwMutex*)_arr_%.*s\000[%.*s\000]);", 3, mtxs, mtxs));
		v__gen__c__Gen_writeln(g, _SLIT("}"));
	}
	v__gen__c__Gen_writeln(g, _SLIT("/*lock*/ {"));
	v__gen__c__Gen_stmts_with_tmp_var(g, node.stmts, tmp_result);
	if (node.is_expr) {
		v__gen__c__Gen_writeln(g, _SLIT(";"));
	}
	v__gen__c__Gen_writeln(g, _SLIT("}"));
	if (node.lockeds.len == 0) {
	} else if (node.lockeds.len == 1) {
		v__ast__Ident id = (*(v__ast__Ident*)/*ee elem_typ */array_get(node.lockeds, 0));
		string name = id.name;
		string deref = (id.is_mut ? (_SLIT("->")) : (_SLIT(".")));
		string lock_prefix = ((*(bool*)/*ee elem_typ */array_get(node.is_rlock, 0)) ? (_SLIT("r")) : (_SLIT("")));
		v__gen__c__Gen_writeln(g, _STR("sync__RwMutex_%.*s\000unlock(&%.*s\000%.*s\000mtx);", 4, lock_prefix, name, deref));
	} else {
		v__gen__c__Gen_writeln(g, _STR("for (int %.*s\000=%"PRId32"\000; %.*s\000>=0; %.*s\000--) {", 5, mtxs, node.lockeds.len - 1, mtxs, mtxs));
		v__gen__c__Gen_writeln(g, _STR("\tif (%.*s\000 && _arr_%.*s\000[%.*s\000] == _arr_%.*s\000[%.*s\000-1]) continue;", 6, mtxs, mtxs, mtxs, mtxs, mtxs));
		v__gen__c__Gen_writeln(g, _STR("\tif (_isrlck_%.*s\000[%.*s\000])", 3, mtxs, mtxs));
		v__gen__c__Gen_writeln(g, _STR("\t\tsync__RwMutex_runlock((sync__RwMutex*)_arr_%.*s\000[%.*s\000]);", 3, mtxs, mtxs));
		v__gen__c__Gen_writeln(g, _SLIT("\telse"));
		v__gen__c__Gen_writeln(g, _STR("\t\tsync__RwMutex_unlock((sync__RwMutex*)_arr_%.*s\000[%.*s\000]);", 3, mtxs, mtxs));
		v__gen__c__Gen_write(g, _SLIT("}"));
	}
	if (node.is_expr) {
		v__gen__c__Gen_writeln(g, _SLIT(""));
		v__gen__c__Gen_write(g, cur_line);
		v__gen__c__Gen_write(g, _STR("%.*s", 1, tmp_result));
	}
}

VV_LOCAL_SYMBOL bool v__gen__c__Gen_need_tmp_var_in_match(v__gen__c__Gen* g, v__ast__MatchExpr node) {
	if (node.is_expr && !v__ast__Type_alias_eq(node.return_type, _const_v__ast__void_type) && node.return_type != 0) {
		v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, node.return_type);
		if (sym->kind == v__ast__Kind_multi_return) {
			 bool _t2925 = false;
			// autofree_scope_vars(pos=112462 line_nr=3867 scope.pos=112458 scope.end_pos=112478)
			// af parent scope:
			// var "sym" var.pos=112378 var.line_nr=3865
			// af parent scope:
			// var "g" var.pos=112239 var.line_nr=3863
			// var "node" var.pos=112268 var.line_nr=3863
			// af parent scope:
			// af parent scope:
			return _t2925;
		}
		// FOR IN array
		for (int _t2926 = 0; _t2926 < node.branches.len; ++_t2926) {
			v__ast__MatchBranch branch = ((v__ast__MatchBranch*)node.branches.data)[_t2926];
			if (branch.stmts.len > 1) {
				 bool _t2927 = true;
				// autofree_scope_vars(pos=112544 line_nr=3871 scope.pos=112539 scope.end_pos=112560)
				// af parent scope:
				// var "branch" var.pos=112486 var.line_nr=3869
				// skipping tmp var "branch"
				// af parent scope:
				// var "sym" var.pos=112378 var.line_nr=3865
				// af parent scope:
				// var "g" var.pos=112239 var.line_nr=3863
				// var "node" var.pos=112268 var.line_nr=3863
				// af parent scope:
				// af parent scope:
				return _t2927;
			}
			if (branch.stmts.len == 1) {
				if (((*(v__ast__Stmt*)/*ee elem_typ */array_get(branch.stmts, 0)))._typ == 293 /* v.ast.ExprStmt */) {
					v__ast__ExprStmt stmt = /* as */ *(v__ast__ExprStmt*)__as_cast(((*(v__ast__Stmt*)/*ee elem_typ */array_get(branch.stmts, 0)))._v__ast__ExprStmt,((*(v__ast__Stmt*)/*ee elem_typ */array_get(branch.stmts, 0)))._typ, 293) /*expected idx: 293, name: v.ast.ExprStmt */ ;
					if ((stmt.expr)._typ == 241 /* v.ast.CallExpr */ || (stmt.expr)._typ == 255 /* v.ast.IfExpr */ || (stmt.expr)._typ == 263 /* v.ast.MatchExpr */) {
						 bool _t2928 = true;
						// autofree_scope_vars(pos=112782 line_nr=3878 scope.pos=112775 scope.end_pos=112800)
						// af parent scope:
						// var "stmt" var.pos=112638 var.line_nr=3875
						// af parent scope:
						// af parent scope:
						// var "branch" var.pos=112486 var.line_nr=3869
						// skipping tmp var "branch"
						// af parent scope:
						// var "sym" var.pos=112378 var.line_nr=3865
						// af parent scope:
						// var "g" var.pos=112239 var.line_nr=3863
						// var "node" var.pos=112268 var.line_nr=3863
						// af parent scope:
						// af parent scope:
						return _t2928;
					}
				}
			}
		}
	}
	 bool _t2929 = false;
	// autofree_scope_vars(pos=112820 line_nr=3884 scope.pos=112234 scope.end_pos=112834)
	// var "g" var.pos=112239 var.line_nr=3863
	// var "node" var.pos=112268 var.line_nr=3863
	// af parent scope:
	// af parent scope:
	return _t2929;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_match_expr(v__gen__c__Gen* g, v__ast__MatchExpr node) {
	if (node.cond_type == 0) {
		v__gen__c__Gen_writeln(g, _SLIT("// match 0"));
		return;
	}
	bool need_tmp_var = v__gen__c__Gen_need_tmp_var_in_match(g, node);
	bool is_expr = (node.is_expr && !v__ast__Type_alias_eq(node.return_type, _const_v__ast__void_type)) || g->inside_ternary > 0;
	string cond_var = _SLIT("");
	string tmp_var = _SLIT("");
	string cur_line = _SLIT("");
	if (is_expr && !need_tmp_var) {
		g->inside_ternary++;
	}
	if ((node.cond)._typ == 254 /* v.ast.Ident */ || (node.cond)._typ == 273 /* v.ast.SelectorExpr */ || (node.cond)._typ == 259 /* v.ast.IntegerLiteral */ || (node.cond)._typ == 277 /* v.ast.StringLiteral */ || (node.cond)._typ == 252 /* v.ast.FloatLiteral */) {
		cond_var = v__gen__c__Gen_expr_string(g, node.cond);
	} else {
		string line = (is_expr ? (g->empty_line = true,v__gen__c__Gen_go_before_stmt(g, 0)) : (_SLIT("")));
		cond_var = v__gen__c__Gen_new_tmp_var(g);
		v__gen__c__Gen_write(g, _STR("%.*s\000 %.*s\000 = ", 3, v__gen__c__Gen_typ(g, node.cond_type), cond_var));
		v__gen__c__Gen_expr(g, node.cond);
		v__gen__c__Gen_writeln(g, _SLIT(";"));
		array_push(&g->stmt_path_pos, _MOV((int[]){ g->out.len }));
		v__gen__c__Gen_write(g, line);
	}
	if (need_tmp_var) {
		g->empty_line = true;
		cur_line = v__gen__c__Gen_go_before_stmt(g, 0);
		tmp_var = v__gen__c__Gen_new_tmp_var(g);
		v__gen__c__Gen_writeln(g, _STR("%.*s\000 %.*s\000;", 3, v__gen__c__Gen_typ(g, node.return_type), tmp_var));
	}
	if (is_expr && !need_tmp_var) {
		v__gen__c__Gen_write(g, _SLIT("("));
	}
	if (node.is_sum_type) {
		v__gen__c__Gen_match_expr_sumtype(g, node, is_expr, cond_var, tmp_var);
	} else {
		v__gen__c__Gen_match_expr_classic(g, node, is_expr, cond_var, tmp_var);
	}
	v__gen__c__Gen_write(g, cur_line);
	if (need_tmp_var) {
		v__gen__c__Gen_write(g, _STR("%.*s", 1, tmp_var));
	}
	if (is_expr && !need_tmp_var) {
		v__gen__c__Gen_write(g, _SLIT(")"));
		v__gen__c__Gen_decrement_inside_ternary(g);
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_match_expr_sumtype(v__gen__c__Gen* g, v__ast__MatchExpr node, bool is_expr, string cond_var, string tmp_var) {
	// FOR IN array
	for (int j = 0; j < node.branches.len; ++j) {
		v__ast__MatchBranch branch = ((v__ast__MatchBranch*)node.branches.data)[j];
		int sumtype_index = 0;
		for (;;) {
			g->aggregate_type_idx = sumtype_index;
			bool is_last = j == node.branches.len - 1;
			v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, node.cond_type);
			if (branch.is_else || (node.is_expr && is_last && tmp_var.len == 0)) {
				if (is_expr && tmp_var.len == 0) {
					v__gen__c__Gen_write(g, _SLIT(" : "));
				} else {
					v__gen__c__Gen_writeln(g, _SLIT(""));
					v__gen__c__Gen_write_v_source_line_info(g, branch.pos);
					v__gen__c__Gen_writeln(g, _SLIT("else {"));
				}
			} else {
				if (j > 0 || sumtype_index > 0) {
					if (is_expr && tmp_var.len == 0) {
						v__gen__c__Gen_write(g, _SLIT(" : "));
					} else {
						v__gen__c__Gen_writeln(g, _SLIT(""));
						v__gen__c__Gen_write_v_source_line_info(g, branch.pos);
						v__gen__c__Gen_write(g, _SLIT("else "));
					}
				}
				if (is_expr && tmp_var.len == 0) {
					v__gen__c__Gen_write(g, _SLIT("("));
				} else {
					if (j == 0 && sumtype_index == 0) {
						g->empty_line = true;
					}
					v__gen__c__Gen_write_v_source_line_info(g, branch.pos);
					v__gen__c__Gen_write(g, _SLIT("if ("));
				}
				v__gen__c__Gen_write(g, cond_var);
				string dot_or_ptr = (v__ast__Type_is_ptr(node.cond_type) ? (_SLIT("->")) : (_SLIT(".")));
				if (sym->kind == v__ast__Kind_sum_type) {
					v__gen__c__Gen_write(g, _STR("%.*s\000_typ == ", 2, dot_or_ptr));
					v__gen__c__Gen_expr(g, (*(v__ast__Expr*)/*ee elem_typ */array_get(branch.exprs, sumtype_index)));
				} else if (sym->kind == v__ast__Kind_interface_) {
					if (((*(v__ast__Expr*)/*ee elem_typ */array_get(branch.exprs, sumtype_index)))._typ == 279 /* v.ast.TypeNode */) {
						v__ast__TypeNode typ = /* as */ *(v__ast__TypeNode*)__as_cast(((*(v__ast__Expr*)/*ee elem_typ */array_get(branch.exprs, sumtype_index)))._v__ast__TypeNode,((*(v__ast__Expr*)/*ee elem_typ */array_get(branch.exprs, sumtype_index)))._typ, 279) /*expected idx: 279, name: v.ast.TypeNode */ ;
						v__ast__TypeSymbol* branch_sym = v__ast__Table_get_type_symbol(g->table, typ.typ);
						v__gen__c__Gen_write(g, _STR("%.*s\000_typ == _%.*s\000_%.*s\000_index", 4, dot_or_ptr, sym->cname, branch_sym->cname));
					} else if (((*(v__ast__Expr*)/*ee elem_typ */array_get(branch.exprs, sumtype_index)))._typ == 265 /* v.ast.None */ && string_eq(sym->name, _SLIT("IError"))) {
						v__gen__c__Gen_write(g, _STR("%.*s\000_typ == _IError_None___index", 2, dot_or_ptr));
					}
				}
				if (is_expr && tmp_var.len == 0) {
					v__gen__c__Gen_write(g, _SLIT(") ? "));
				} else {
					v__gen__c__Gen_writeln(g, _SLIT(") {"));
				}
			}
			v__gen__c__Gen_stmts_with_tmp_var(g, branch.stmts, tmp_var);
			if (g->inside_ternary == 0) {
				v__gen__c__Gen_write(g, _SLIT("}"));
			}
			sumtype_index++;
			if (branch.exprs.len == 0 || sumtype_index == branch.exprs.len) {
				break;
			}
		}
		g->aggregate_type_idx = 0;
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_match_expr_classic(v__gen__c__Gen* g, v__ast__MatchExpr node, bool is_expr, string cond_var, string tmp_var) {
	v__ast__TypeSymbol* type_sym = v__ast__Table_get_type_symbol(g->table, node.cond_type);
	// FOR IN array
	for (int j = 0; j < node.branches.len; ++j) {
		v__ast__MatchBranch branch = ((v__ast__MatchBranch*)node.branches.data)[j];
		bool is_last = j == node.branches.len - 1;
		if (branch.is_else || (node.is_expr && is_last && tmp_var.len == 0)) {
			if (node.branches.len > 1) {
				if (is_expr && tmp_var.len == 0) {
					v__gen__c__Gen_write(g, _SLIT(" : "));
				} else {
					v__gen__c__Gen_writeln(g, _SLIT(""));
					v__gen__c__Gen_write_v_source_line_info(g, branch.pos);
					v__gen__c__Gen_writeln(g, _SLIT("else {"));
				}
			}
		} else {
			if (j > 0) {
				if (is_expr && tmp_var.len == 0) {
					v__gen__c__Gen_write(g, _SLIT(" : "));
				} else {
					v__gen__c__Gen_writeln(g, _SLIT(""));
					v__gen__c__Gen_write_v_source_line_info(g, branch.pos);
					v__gen__c__Gen_write(g, _SLIT("else "));
				}
			}
			if (is_expr && tmp_var.len == 0) {
				v__gen__c__Gen_write(g, _SLIT("("));
			} else {
				if (j == 0) {
					v__gen__c__Gen_writeln(g, _SLIT(""));
				}
				v__gen__c__Gen_write_v_source_line_info(g, branch.pos);
				v__gen__c__Gen_write(g, _SLIT("if ("));
			}
			// FOR IN array
			for (int i = 0; i < branch.exprs.len; ++i) {
				v__ast__Expr expr = ((v__ast__Expr*)branch.exprs.data)[i];
				if (i > 0) {
					v__gen__c__Gen_write(g, _SLIT(" || "));
				}
				if (type_sym->kind == v__ast__Kind_string) {
					if ((expr)._typ == 277 /* v.ast.StringLiteral */ && ((/* as */ *(v__ast__StringLiteral*)__as_cast((expr)._v__ast__StringLiteral,(expr)._typ, 277) /*expected idx: 277, name: v.ast.StringLiteral */ ).val).len == 0) {
						v__gen__c__Gen_write(g, _STR("%.*s\000.len == 0", 2, cond_var));
					} else {
						v__gen__c__Gen_write(g, _SLIT("string_eq("));
						v__gen__c__Gen_write(g, cond_var);
						v__gen__c__Gen_write(g, _SLIT(", "));
						v__gen__c__Gen_expr(g, expr);
						v__gen__c__Gen_write(g, _SLIT(")"));
					}
				} else if ((expr)._typ == 271 /* v.ast.RangeExpr */) {
					bool skip_low = false;
					if (((*expr._v__ast__RangeExpr).low)._typ == 259 /* v.ast.IntegerLiteral */) {
						if ((node.cond_type == _const_v__ast__u16_type || node.cond_type == _const_v__ast__u32_type || node.cond_type == _const_v__ast__u64_type) && string_eq((*(*expr._v__ast__RangeExpr).low._v__ast__IntegerLiteral).val, _SLIT("0"))) {
							skip_low = true;
						}
					}
					v__gen__c__Gen_write(g, _SLIT("("));
					if (!skip_low) {
						v__gen__c__Gen_write(g, cond_var);
						v__gen__c__Gen_write(g, _SLIT(" >= "));
						v__gen__c__Gen_expr(g, (*expr._v__ast__RangeExpr).low);
						v__gen__c__Gen_write(g, _SLIT(" && "));
					}
					v__gen__c__Gen_write(g, cond_var);
					v__gen__c__Gen_write(g, _SLIT(" <= "));
					v__gen__c__Gen_expr(g, (*expr._v__ast__RangeExpr).high);
					v__gen__c__Gen_write(g, _SLIT(")"));
				} else {
					v__gen__c__Gen_write(g, cond_var);
					v__gen__c__Gen_write(g, _SLIT(" == "));
					v__gen__c__Gen_write(g, _SLIT("("));
					v__gen__c__Gen_expr(g, expr);
					v__gen__c__Gen_write(g, _SLIT(")"));
				}
			}
			if (is_expr && tmp_var.len == 0) {
				v__gen__c__Gen_write(g, _SLIT(") ? "));
			} else {
				v__gen__c__Gen_writeln(g, _SLIT(") {"));
			}
		}
		v__gen__c__Gen_stmts_with_tmp_var(g, branch.stmts, tmp_var);
		if (g->inside_ternary == 0 && node.branches.len >= 1) {
			v__gen__c__Gen_write(g, _SLIT("}"));
		}
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_map_init(v__gen__c__Gen* g, v__ast__MapInit node) {
	string key_typ_str = v__gen__c__Gen_typ(g, node.key_type);
	string value_typ_str = v__gen__c__Gen_typ(g, node.value_type);
	v__ast__TypeSymbol* value_typ = v__ast__Table_get_type_symbol(g->table, node.value_type);
	v__ast__TypeSymbol* key_typ = v__ast__Table_get_final_type_symbol(g->table, node.key_type);
	multi_return_string_string_string_string mr_118814 = v__gen__c__Gen_map_fn_ptrs(g, *key_typ);
	string hash_fn = mr_118814.arg0;
	string key_eq_fn = mr_118814.arg1;
	string clone_fn = mr_118814.arg2;
	string free_fn = mr_118814.arg3;
	int size = node.vals.len;
	string shared_styp = _SLIT("");
	string styp = _SLIT("");
	bool is_amp = g->is_amp;
	g->is_amp = false;
	if (is_amp) {
		strings__Builder_go_back(&g->out, 1);
	}
	if (g->is_shared) {
		v__ast__Type shared_typ = v__ast__Type_set_flag(node.typ, v__ast__TypeFlag_shared_f);
		shared_styp = v__gen__c__Gen_typ(g, shared_typ);
		v__gen__c__Gen_writeln(g, _STR("(%.*s\000*)__dup_shared_map(&(%.*s\000){.val = ", 3, shared_styp, shared_styp));
	} else if (is_amp) {
		styp = v__gen__c__Gen_typ(g, node.typ);
		v__gen__c__Gen_write(g, _STR("(%.*s\000*)memdup(ADDR(%.*s\000, ", 3, styp, styp));
	}
	if (size > 0) {
		if (value_typ->kind == v__ast__Kind_function) {
			v__gen__c__Gen_write(g, _STR("new_map_init(%.*s\000, %.*s\000, %.*s\000, %.*s\000, %"PRId32"\000, sizeof(%.*s\000), sizeof(voidptr), _MOV((%.*s\000[%"PRId32"\000]){", 9, hash_fn, key_eq_fn, clone_fn, free_fn, size, key_typ_str, key_typ_str, size));
		} else {
			v__gen__c__Gen_write(g, _STR("new_map_init(%.*s\000, %.*s\000, %.*s\000, %.*s\000, %"PRId32"\000, sizeof(%.*s\000), sizeof(%.*s\000), _MOV((%.*s\000[%"PRId32"\000]){", 10, hash_fn, key_eq_fn, clone_fn, free_fn, size, key_typ_str, value_typ_str, key_typ_str, size));
		}
		// FOR IN array
		for (int _t2931 = 0; _t2931 < node.keys.len; ++_t2931) {
			v__ast__Expr expr = ((v__ast__Expr*)node.keys.data)[_t2931];
			v__gen__c__Gen_expr(g, expr);
			v__gen__c__Gen_write(g, _SLIT(", "));
		}
		if (value_typ->kind == v__ast__Kind_function) {
			v__gen__c__Gen_write(g, _STR("}), _MOV((voidptr[%"PRId32"\000]){", 2, size));
		} else {
			v__gen__c__Gen_write(g, _STR("}), _MOV((%.*s\000[%"PRId32"\000]){", 3, value_typ_str, size));
		}
		// FOR IN array
		for (int _t2932 = 0; _t2932 < node.vals.len; ++_t2932) {
			v__ast__Expr expr = ((v__ast__Expr*)node.vals.data)[_t2932];
			if (v__ast__Expr_is_auto_deref_var(expr)) {
				v__gen__c__Gen_write(g, _SLIT("*"));
			}
			v__gen__c__Gen_expr(g, expr);
			v__gen__c__Gen_write(g, _SLIT(", "));
		}
		v__gen__c__Gen_write(g, _SLIT("}))"));
	} else {
		v__gen__c__Gen_write(g, _STR("new_map(sizeof(%.*s\000), sizeof(%.*s\000), %.*s\000, %.*s\000, %.*s\000, %.*s\000)", 7, key_typ_str, value_typ_str, hash_fn, key_eq_fn, clone_fn, free_fn));
	}
	if (g->is_shared) {
		v__gen__c__Gen_write(g, _STR("}, sizeof(%.*s\000))", 2, shared_styp));
	} else if (is_amp) {
		v__gen__c__Gen_write(g, _STR("), sizeof(%.*s\000))", 2, styp));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_select_expr(v__gen__c__Gen* g, v__ast__SelectExpr node) {
	bool is_expr = node.is_expr || g->inside_ternary > 0;
	string cur_line = (is_expr ? (g->empty_line = true,v__gen__c__Gen_go_before_stmt(g, 0)) : (_SLIT("")));
	int n_channels = (node.has_exception ? (node.branches.len - 1) : (node.branches.len));
	Array_v__ast__Expr channels = __new_array_with_default(0, n_channels, sizeof(v__ast__Expr), 0);
	Array_v__ast__Expr objs = __new_array_with_default(0, n_channels, sizeof(v__ast__Expr), 0);
	Array_string tmp_objs = __new_array_with_default(0, n_channels, sizeof(string), 0);
	Array_string elem_types = __new_array_with_default(0, n_channels, sizeof(string), 0);
	Array_bool is_push = __new_array_with_default(0, n_channels, sizeof(bool), 0);
	bool has_else = false;
	bool has_timeout = false;
	v__ast__Expr timeout_expr = v__ast__empty_expr();
	int exception_branch = -1;
	// FOR IN array
	for (int j = 0; j < node.branches.len; ++j) {
		v__ast__SelectBranch branch = ((v__ast__SelectBranch*)node.branches.data)[j];
		if (branch.is_else) {
			has_else = true;
			exception_branch = j;
		} else if (branch.is_timeout) {
			has_timeout = true;
			exception_branch = j;
			timeout_expr = (/* as */ *(v__ast__ExprStmt*)__as_cast((branch.stmt)._v__ast__ExprStmt,(branch.stmt)._typ, 293) /*expected idx: 293, name: v.ast.ExprStmt */ ).expr;
		} else {
			if (branch.stmt._typ == 293 /* v.ast.ExprStmt */) {
				v__ast__InfixExpr expr = /* as */ *(v__ast__InfixExpr*)__as_cast(((*branch.stmt._v__ast__ExprStmt).expr)._v__ast__InfixExpr,((*branch.stmt._v__ast__ExprStmt).expr)._typ, 258) /*expected idx: 258, name: v.ast.InfixExpr */ ;
				array_push(&channels, _MOV((v__ast__Expr[]){ expr.left }));
				if ((expr.right)._typ == 254 /* v.ast.Ident */ || (expr.right)._typ == 257 /* v.ast.IndexExpr */ || (expr.right)._typ == 273 /* v.ast.SelectorExpr */ || (expr.right)._typ == 278 /* v.ast.StructInit */) {
					array_push(&objs, _MOV((v__ast__Expr[]){ expr.right }));
					array_push(&tmp_objs, _MOV((string[]){ string_clone(_SLIT("")) }));
					array_push(&elem_types, _MOV((string[]){ string_clone(_SLIT("")) }));
				} else {
					array_push(&objs, _MOV((v__ast__Expr[]){ v__ast__empty_expr() }));
					string tmp_obj = v__gen__c__Gen_new_tmp_var(g);
					array_push(&tmp_objs, _MOV((string[]){ string_clone(tmp_obj) }));
					string el_stype = v__gen__c__Gen_typ(g, v__ast__Table_mktyp(g->table, expr.right_type));
					v__gen__c__Gen_writeln(g, _STR("%.*s\000 %.*s\000;", 3, el_stype, tmp_obj));
				}
				array_push(&is_push, _MOV((bool[]){ true }));
			}
			else if (branch.stmt._typ == 285 /* v.ast.AssignStmt */) {
				v__ast__PrefixExpr rec_expr = /* as */ *(v__ast__PrefixExpr*)__as_cast(((*(v__ast__Expr*)/*ee elem_typ */array_get((*branch.stmt._v__ast__AssignStmt).right, 0)))._v__ast__PrefixExpr,((*(v__ast__Expr*)/*ee elem_typ */array_get((*branch.stmt._v__ast__AssignStmt).right, 0)))._typ, 270) /*expected idx: 270, name: v.ast.PrefixExpr */ ;
				array_push(&channels, _MOV((v__ast__Expr[]){ rec_expr.right }));
				array_push(&is_push, _MOV((bool[]){ false }));
				if ((*branch.stmt._v__ast__AssignStmt).op == v__token__Kind_decl_assign || !v__ast__Type_alias_eq((*(v__ast__Type*)/*ee elem_typ */array_get((*branch.stmt._v__ast__AssignStmt).right_types, 0)), (*(v__ast__Type*)/*ee elem_typ */array_get((*branch.stmt._v__ast__AssignStmt).left_types, 0)))) {
					string tmp_obj = v__gen__c__Gen_new_tmp_var(g);
					array_push(&tmp_objs, _MOV((string[]){ string_clone(tmp_obj) }));
					string el_stype = v__gen__c__Gen_typ(g, (*(v__ast__Type*)/*ee elem_typ */array_get((*branch.stmt._v__ast__AssignStmt).right_types, 0)));
					array_push(&elem_types, _MOV((string[]){ string_clone(((*branch.stmt._v__ast__AssignStmt).op == v__token__Kind_decl_assign ? (string_add(el_stype, _SLIT(" "))) : (_SLIT("")))) }));
					v__gen__c__Gen_writeln(g, _STR("%.*s\000 %.*s\000;", 3, el_stype, tmp_obj));
				} else {
					array_push(&tmp_objs, _MOV((string[]){ string_clone(_SLIT("")) }));
					array_push(&elem_types, _MOV((string[]){ string_clone(_SLIT("")) }));
				}
				array_push(&objs, _MOV((v__ast__Expr[]){ (*(v__ast__Expr*)/*ee elem_typ */array_get((*branch.stmt._v__ast__AssignStmt).left, 0)) }));
			}
			else {
			};
		}
	}
	string chan_array = v__gen__c__Gen_new_tmp_var(g);
	v__gen__c__Gen_write(g, _STR("Array_sync__Channel_ptr %.*s\000 = new_array_from_c_array(%"PRId32"\000, %"PRId32"\000, sizeof(sync__Channel*), _MOV((sync__Channel*[%"PRId32"\000]){", 5, chan_array, n_channels, n_channels, n_channels));
	for (int i = 0; i < n_channels; ++i) {
		if (i > 0) {
			v__gen__c__Gen_write(g, _SLIT(", "));
		}
		v__gen__c__Gen_write(g, _SLIT("(sync__Channel*)("));
		v__gen__c__Gen_expr(g, (*(v__ast__Expr*)/*ee elem_typ */array_get(channels, i)));
		v__gen__c__Gen_write(g, _SLIT(")"));
	}
	v__gen__c__Gen_writeln(g, _SLIT("}));"));
	string directions_array = v__gen__c__Gen_new_tmp_var(g);
	v__gen__c__Gen_write(g, _STR("Array_sync__Direction %.*s\000 = new_array_from_c_array(%"PRId32"\000, %"PRId32"\000, sizeof(sync__Direction), _MOV((sync__Direction[%"PRId32"\000]){", 5, directions_array, n_channels, n_channels, n_channels));
	for (int i = 0; i < n_channels; ++i) {
		if (i > 0) {
			v__gen__c__Gen_write(g, _SLIT(", "));
		}
		if ((*(bool*)/*ee elem_typ */array_get(is_push, i))) {
			v__gen__c__Gen_write(g, _SLIT("sync__Direction_push"));
		} else {
			v__gen__c__Gen_write(g, _SLIT("sync__Direction_pop"));
		}
	}
	v__gen__c__Gen_writeln(g, _SLIT("}));"));
	string objs_array = v__gen__c__Gen_new_tmp_var(g);
	v__gen__c__Gen_write(g, _STR("Array_voidptr %.*s\000 = new_array_from_c_array(%"PRId32"\000, %"PRId32"\000, sizeof(voidptr), _MOV((voidptr[%"PRId32"\000]){", 5, objs_array, n_channels, n_channels, n_channels));
	for (int i = 0; i < n_channels; ++i) {
		if (i > 0) {
			v__gen__c__Gen_write(g, _SLIT(", &"));
		} else {
			v__gen__c__Gen_write(g, _SLIT("&"));
		}
		if (((*(string*)/*ee elem_typ */array_get(tmp_objs, i))).len == 0) {
			v__gen__c__Gen_expr(g, (*(v__ast__Expr*)/*ee elem_typ */array_get(objs, i)));
		} else {
			v__gen__c__Gen_write(g, (*(string*)/*ee elem_typ */array_get(tmp_objs, i)));
		}
	}
	v__gen__c__Gen_writeln(g, _SLIT("}));"));
	string select_result = v__gen__c__Gen_new_tmp_var(g);
	v__gen__c__Gen_write(g, _STR("int %.*s\000 = sync__channel_select(&/*arr*/%.*s\000, %.*s\000, &/*arr*/%.*s\000, ", 5, select_result, chan_array, directions_array, objs_array));
	if (has_timeout) {
		v__gen__c__Gen_expr(g, timeout_expr);
	} else if (has_else) {
		v__gen__c__Gen_write(g, _SLIT("0"));
	} else {
		v__gen__c__Gen_write(g, _SLIT("-1"));
	}
	v__gen__c__Gen_writeln(g, _SLIT(");"));
	v__gen__c__Gen_writeln(g, _STR("array_free(&%.*s\000);", 2, objs_array));
	v__gen__c__Gen_writeln(g, _STR("array_free(&%.*s\000);", 2, directions_array));
	v__gen__c__Gen_writeln(g, _STR("array_free(&%.*s\000);", 2, chan_array));
	int i = 0;
	for (int j = 0; j < node.branches.len; ++j) {
		if (j > 0) {
			v__gen__c__Gen_write(g, _SLIT("} else "));
		}
		v__gen__c__Gen_write(g, _STR("if (%.*s\000 == ", 2, select_result));
		if (j == exception_branch) {
			v__gen__c__Gen_writeln(g, _SLIT("-1) {"));
		} else {
			v__gen__c__Gen_writeln(g, _STR("%"PRId32"\000) {", 2, i));
			if (!(*(bool*)/*ee elem_typ */array_get(is_push, i)) && ((*(string*)/*ee elem_typ */array_get(tmp_objs, i))).len != 0) {
				v__gen__c__Gen_write(g, _STR("\t%.*s", 1, (*(string*)/*ee elem_typ */array_get(elem_types, i))));
				v__gen__c__Gen_expr(g, (*(v__ast__Expr*)/*ee elem_typ */array_get(objs, i)));
				v__gen__c__Gen_writeln(g, _STR(" = %.*s\000;", 2, (*(string*)/*ee elem_typ */array_get(tmp_objs, i))));
			}
			i++;
		}
		v__gen__c__Gen_stmts(g, (*(v__ast__SelectBranch*)/*ee elem_typ */array_get(node.branches, j)).stmts);
	}
	v__gen__c__Gen_writeln(g, _SLIT("}"));
	if (is_expr) {
		g->empty_line = false;
		v__gen__c__Gen_write(g, cur_line);
		v__gen__c__Gen_write(g, _STR("(%.*s\000 != -2)", 2, select_result));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_ident(v__gen__c__Gen* g, v__ast__Ident node) {
	bool prevent_sum_type_unwrapping_once = g->prevent_sum_type_unwrapping_once;
	g->prevent_sum_type_unwrapping_once = false;
	if (string_eq(node.name, _SLIT("lld"))) {
		return;
	}
	if (string_starts_with(node.name, _SLIT("C."))) {
		v__gen__c__Gen_write(g, v__util__no_dots(string_substr(node.name, 2, node.name.len)));
		return;
	}
	if (node.kind == v__ast__IdentKind_constant) {
		v__gen__c__Gen_write(g, _SLIT("_const_"));
	}
	string name = v__gen__c__c_name(node.name);
	v__ast__IdentInfo node_info = node.info;
	if ((node_info)._typ == 363 /* v.ast.IdentVar */) {
		if ((*node_info._v__ast__IdentVar).is_optional && !(g->is_assign_lhs && g->right_is_opt)) {
			v__gen__c__Gen_write(g, _SLIT("/*opt*/"));
			string styp = v__gen__c__Gen_base_type(g, (*node_info._v__ast__IdentVar).typ);
			v__gen__c__Gen_write(g, _STR("(*(%.*s\000*)%.*s\000.data)", 3, styp, name));
			return;
		}
		if (!g->is_assign_lhs && (*node_info._v__ast__IdentVar).share == v__ast__ShareType_shared_t) {
			v__gen__c__Gen_write(g, _STR("%.*s\000.val", 2, name));
			return;
		}
		v__ast__Scope* scope = v__ast__Scope_innermost(g->file.scope, node.pos.pos);
		Option_v__ast__Var_ptr _t2947;
		if (_t2947 = v__ast__Scope_find_var(scope, node.name), _t2947.state == 0) {
			v__ast__Var* v = *(v__ast__Var**)_t2947.data;
			if (v->smartcasts.len > 0) {
				v__ast__TypeSymbol* v_sym = v__ast__Table_get_type_symbol(g->table, v->typ);
				if (!prevent_sum_type_unwrapping_once) {
					// FOR IN array
					for (int _t2948 = 0; _t2948 < v->smartcasts.len; ++_t2948) {
						v__gen__c__Gen_write(g, _SLIT("("));
						if (v_sym->kind == v__ast__Kind_sum_type) {
							v__gen__c__Gen_write(g, _SLIT("*"));
						}
					}
					// FOR IN array
					for (int i = 0; i < v->smartcasts.len; ++i) {
						v__ast__Type typ = ((v__ast__Type*)v->smartcasts.data)[i];
						v__ast__TypeSymbol* cast_sym = v__ast__Table_get_type_symbol(g->table, typ);
						bool is_ptr = false;
						if (i == 0) {
							v__gen__c__Gen_write(g, name);
							if (v__ast__Type_is_ptr(v->orig_type)) {
								is_ptr = true;
							}
						}
						string dot = (is_ptr ? (_SLIT("->")) : (_SLIT(".")));
						if ((cast_sym->info)._typ == 408 /* v.ast.Aggregate */) {
							v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, (*(v__ast__Type*)/*ee elem_typ */array_get((*cast_sym->info._v__ast__Aggregate).types, g->aggregate_type_idx)));
							v__gen__c__Gen_write(g, _STR("%.*s\000_%.*s", 2, dot, sym->cname));
						} else {
							v__gen__c__Gen_write(g, _STR("%.*s\000_%.*s", 2, dot, cast_sym->cname));
						}
						v__gen__c__Gen_write(g, _SLIT(")"));
					}
					return;
				}
			}
		}
	} else if ((node_info)._typ == 362 /* v.ast.IdentFn */) {
		if (g->pref->obfuscate && string_eq(g->cur_mod.name, _SLIT("main")) && string_starts_with(name, _SLIT("main__"))) {
			string key = node.name;
			v__gen__c__Gen_write(g, _STR("/* obf identfn: %.*s\000 */", 2, key));
			string* _t2950 = (string*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, g->obf_table), &(string[]){key}));
			Option_string _t2949 = {0};
			if (_t2950) {
				*((string*)&_t2949.data) = *((string*)_t2950);
			} else {
				_t2949.state = 2; _t2949.err = v_error(_SLIT("array index out of range"));
			}
			;
			if (_t2949.state != 0) { /*or block*/ 
				IError err = _t2949.err;
				v_panic(_STR("cgen: obf name \"%.*s\000\" not found, this should never happen", 2, key));
			}
			name = *(string*)_t2949.data;
		}
	}
	v__gen__c__Gen_write(g, v__gen__c__Gen_get_ternary_name(g, name));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_cast_expr(v__gen__c__Gen* g, v__ast__CastExpr node) {
	if (g->is_amp) {
		strings__Builder_go_back(&g->out, 1);
	}
	g->is_amp = false;
	v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, node.typ);
	if (sym->kind == v__ast__Kind_string && !v__ast__Type_is_ptr(node.typ)) {
		if (node.has_arg) {
			v__gen__c__Gen_write(g, _SLIT("tos((byteptr)"));
		} else {
			v__gen__c__Gen_write(g, _SLIT("tos2((byteptr)"));
		}
		v__gen__c__Gen_expr(g, node.expr);
		v__ast__TypeSymbol* expr_sym = v__ast__Table_get_type_symbol(g->table, node.expr_type);
		if (expr_sym->kind == v__ast__Kind_array) {
			v__gen__c__Gen_write(g, _SLIT(".data"));
		}
		if (node.has_arg) {
			v__gen__c__Gen_write(g, _SLIT(", "));
			v__gen__c__Gen_expr(g, node.arg);
		}
		v__gen__c__Gen_write(g, _SLIT(")"));
	} else if ((sym->kind == v__ast__Kind_sum_type || sym->kind == v__ast__Kind_interface_)) {
		v__gen__c__Gen_expr_with_cast(g, node.expr, node.expr_type, node.typ);
	} else if (sym->kind == v__ast__Kind_struct_ && !v__ast__Type_is_ptr(node.typ) && !(/* as */ *(v__ast__Struct*)__as_cast((sym->info)._v__ast__Struct,(sym->info)._typ, 409) /*expected idx: 409, name: v.ast.Struct */ ).is_typedef) {
		string styp = v__gen__c__Gen_typ(g, node.typ);
		v__gen__c__Gen_write(g, _STR("*((%.*s\000 *)(&", 2, styp));
		v__gen__c__Gen_expr(g, node.expr);
		v__gen__c__Gen_write(g, _SLIT("))"));
	} else {
		string styp = v__gen__c__Gen_typ(g, node.typ);
		string cast_label = _SLIT("");
		if (sym->kind != v__ast__Kind_alias || !((/* as */ *(v__ast__Alias*)__as_cast((sym->info)._v__ast__Alias,(sym->info)._typ, 413) /*expected idx: 413, name: v.ast.Alias */ ).parent_type == node.expr_type || (/* as */ *(v__ast__Alias*)__as_cast((sym->info)._v__ast__Alias,(sym->info)._typ, 413) /*expected idx: 413, name: v.ast.Alias */ ).parent_type == _const_v__ast__string_type)) {
			cast_label = _STR("(%.*s\000)", 2, styp);
		}
		if (v__ast__Type_has_flag(node.typ, v__ast__TypeFlag_optional) && (node.expr)._typ == 265 /* v.ast.None */) {
			v__gen__c__Gen_gen_optional_error(g, node.typ, node.expr);
		} else {
			v__gen__c__Gen_write(g, _STR("(%.*s\000(", 2, cast_label));
			v__gen__c__Gen_expr(g, node.expr);
			if ((node.expr)._typ == 259 /* v.ast.IntegerLiteral */) {
				if ((node.typ == _const_v__ast__u64_type || node.typ == _const_v__ast__u32_type || node.typ == _const_v__ast__u16_type)) {
					if (!string_starts_with((*node.expr._v__ast__IntegerLiteral).val, _SLIT("-"))) {
						v__gen__c__Gen_write(g, _SLIT("U"));
					}
				}
			}
			v__gen__c__Gen_write(g, _SLIT("))"));
		}
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_concat_expr(v__gen__c__Gen* g, v__ast__ConcatExpr node) {
	string styp = v__gen__c__Gen_typ(g, node.return_type);
	v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, node.return_type);
	bool is_multi = sym->kind == v__ast__Kind_multi_return;
	if (!is_multi) {
		v__gen__c__Gen_expr(g, (*(v__ast__Expr*)/*ee elem_typ */array_get(node.vals, 0)));
	} else {
		v__gen__c__Gen_write(g, _STR("(%.*s\000){", 2, styp));
		// FOR IN array
		for (int i = 0; i < node.vals.len; ++i) {
			v__ast__Expr expr = ((v__ast__Expr*)node.vals.data)[i];
			v__gen__c__Gen_write(g, _STR(".arg%"PRId32"\000=", 2, i));
			v__gen__c__Gen_expr(g, expr);
			if (i < node.vals.len - 1) {
				v__gen__c__Gen_write(g, _SLIT(","));
			}
		}
		v__gen__c__Gen_write(g, _SLIT("}"));
	}
}

VV_LOCAL_SYMBOL bool v__gen__c__Gen_need_tmp_var_in_if(v__gen__c__Gen* g, v__ast__IfExpr node) {
	if (node.is_expr && g->inside_ternary == 0) {
		if (g->is_autofree || v__ast__Type_has_flag(node.typ, v__ast__TypeFlag_optional)) {
			 bool _t2951 = true;
			// autofree_scope_vars(pos=128882 line_nr=4472 scope.pos=128878 scope.end_pos=128897)
			// af parent scope:
			// af parent scope:
			// var "g" var.pos=128733 var.line_nr=4469
			// var "node" var.pos=128759 var.line_nr=4469
			// af parent scope:
			// af parent scope:
			return _t2951;
		}
		// FOR IN array
		for (int _t2952 = 0; _t2952 < node.branches.len; ++_t2952) {
			v__ast__IfBranch branch = ((v__ast__IfBranch*)node.branches.data)[_t2952];
			if ((branch.cond)._typ == 256 /* v.ast.IfGuardExpr */) {
				 bool _t2953 = true;
				// autofree_scope_vars(pos=128973 line_nr=4476 scope.pos=128968 scope.end_pos=128989)
				// af parent scope:
				// var "branch" var.pos=128905 var.line_nr=4474
				// skipping tmp var "branch"
				// af parent scope:
				// af parent scope:
				// var "g" var.pos=128733 var.line_nr=4469
				// var "node" var.pos=128759 var.line_nr=4469
				// af parent scope:
				// af parent scope:
				return _t2953;
			}
			if (branch.stmts.len == 1) {
				if (((*(v__ast__Stmt*)/*ee elem_typ */array_get(branch.stmts, 0)))._typ == 293 /* v.ast.ExprStmt */) {
					v__ast__ExprStmt stmt = /* as */ *(v__ast__ExprStmt*)__as_cast(((*(v__ast__Stmt*)/*ee elem_typ */array_get(branch.stmts, 0)))._v__ast__ExprStmt,((*(v__ast__Stmt*)/*ee elem_typ */array_get(branch.stmts, 0)))._typ, 293) /*expected idx: 293, name: v.ast.ExprStmt */ ;
					if ((stmt.expr)._typ == 241 /* v.ast.CallExpr */) {
						if ((*stmt.expr._v__ast__CallExpr).is_method) {
							v__ast__TypeSymbol* left_sym = v__ast__Table_get_type_symbol(g->table, (*stmt.expr._v__ast__CallExpr).receiver_type);
							if ((left_sym->kind == v__ast__Kind_array || left_sym->kind == v__ast__Kind_array_fixed || left_sym->kind == v__ast__Kind_map)) {
								 bool _t2954 = true;
								// autofree_scope_vars(pos=129307 line_nr=4485 scope.pos=129298 scope.end_pos=129327)
								// af parent scope:
								// var "left_sym" var.pos=129181 var.line_nr=4483
								// af parent scope:
								// af parent scope:
								// var "stmt" var.pos=129067 var.line_nr=4480
								// af parent scope:
								// af parent scope:
								// var "branch" var.pos=128905 var.line_nr=4474
								// skipping tmp var "branch"
								// af parent scope:
								// af parent scope:
								// var "g" var.pos=128733 var.line_nr=4469
								// var "node" var.pos=128759 var.line_nr=4469
								// af parent scope:
								// af parent scope:
								return _t2954;
							}
						}
					}
				}
			}
		}
	}
	 bool _t2955 = false;
	// autofree_scope_vars(pos=129362 line_nr=4493 scope.pos=128728 scope.end_pos=129376)
	// var "g" var.pos=128733 var.line_nr=4469
	// var "node" var.pos=128759 var.line_nr=4469
	// af parent scope:
	// af parent scope:
	return _t2955;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_if_expr(v__gen__c__Gen* g, v__ast__IfExpr node) {
	if (node.is_comptime) {
		v__gen__c__Gen_comp_if(g, node);
		return;
	}
	bool needs_tmp_var = v__gen__c__Gen_need_tmp_var_in_if(g, node);
	string tmp = (needs_tmp_var ? (v__gen__c__Gen_new_tmp_var(g)) : (_SLIT("")));
	string cur_line = _SLIT("");
	if (needs_tmp_var) {
		if (v__ast__Type_has_flag(node.typ, v__ast__TypeFlag_optional)) {
			g->inside_if_optional = true;
		}
		string styp = v__gen__c__Gen_typ(g, node.typ);
		cur_line = v__gen__c__Gen_go_before_stmt(g, 0);
		g->empty_line = true;
		v__gen__c__Gen_writeln(g, _STR("%.*s\000 %.*s\000; /* if prepend */", 3, styp, tmp));
	} else if (node.is_expr || g->inside_ternary != 0) {
		g->inside_ternary++;
		v__gen__c__Gen_write(g, _SLIT("("));
		// FOR IN array
		for (int i = 0; i < node.branches.len; ++i) {
			v__ast__IfBranch branch = ((v__ast__IfBranch*)node.branches.data)[i];
			if (i > 0) {
				v__gen__c__Gen_write(g, _SLIT(" : "));
			}
			if (i < node.branches.len - 1 || !node.has_else) {
				v__gen__c__Gen_expr(g, branch.cond);
				v__gen__c__Gen_write(g, _SLIT(" ? "));
			}
			v__gen__c__Gen_stmts(g, branch.stmts);
		}
		if (node.branches.len == 1) {
			v__gen__c__Gen_write(g, _SLIT(": 0"));
		}
		v__gen__c__Gen_write(g, _SLIT(")"));
		v__gen__c__Gen_decrement_inside_ternary(g);
		return;
	}
	bool is_guard = false;
	int guard_idx = 0;
	Array_string guard_vars = __new_array_with_default(0, 0, sizeof(string), 0);
	// FOR IN array
	for (int i = 0; i < node.branches.len; ++i) {
		v__ast__IfBranch branch = ((v__ast__IfBranch*)node.branches.data)[i];
		v__ast__Expr cond = branch.cond;
		if ((cond)._typ == 256 /* v.ast.IfGuardExpr */) {
			if (!is_guard) {
				is_guard = true;
				guard_idx = i;
				guard_vars = __new_array_with_default(node.branches.len, 0, sizeof(string), &(string[]){_SLIT("")});
			}
			if (((*cond._v__ast__IfGuardExpr).expr)._typ != 257 /* v.ast.IndexExpr */ && ((*cond._v__ast__IfGuardExpr).expr)._typ != 270 /* v.ast.PrefixExpr */) {
				string var_name = v__gen__c__Gen_new_tmp_var(g);
				array_set(&guard_vars, i, &(string[]) { var_name });
				v__gen__c__Gen_writeln(g, _STR("%.*s\000 %.*s\000;", 3, v__gen__c__Gen_typ(g, (*cond._v__ast__IfGuardExpr).expr_type), var_name));
			} else {
				array_set(&guard_vars, i, &(string[]) { _SLIT("") });
			}
		}
	}
	// FOR IN array
	for (int i = 0; i < node.branches.len; ++i) {
		v__ast__IfBranch branch = ((v__ast__IfBranch*)node.branches.data)[i];
		if (i > 0) {
			v__gen__c__Gen_write(g, _SLIT("} else "));
		}
		if (i == node.branches.len - 1 && node.has_else) {
			v__gen__c__Gen_writeln(g, _SLIT("{"));
			if (is_guard && guard_idx == i - 1) {
				string cvar_name = (*(string*)/*ee elem_typ */array_get(guard_vars, guard_idx));
				v__gen__c__Gen_writeln(g, _STR("\tIError err = %.*s\000.err;", 2, cvar_name));
			}
		} else {
			if (branch.cond._typ == 256 /* v.ast.IfGuardExpr */) {
				string var_name = (*(string*)/*ee elem_typ */array_get(guard_vars, i));
				bool short_opt = false;
				if ((var_name).len == 0) {
					short_opt = true;
					var_name = v__gen__c__Gen_new_tmp_var(g);
					array_set(&guard_vars, i, &(string[]) { var_name });
					g->tmp_count--;
					v__gen__c__Gen_writeln(g, _STR("if (%.*s\000.state == 0) {", 2, var_name));
				} else {
					v__gen__c__Gen_write(g, _STR("if (%.*s\000 = ", 2, var_name));
					v__gen__c__Gen_expr(g, (*branch.cond._v__ast__IfGuardExpr).expr);
					v__gen__c__Gen_writeln(g, _STR(", %.*s\000.state == 0) {", 2, var_name));
				}
				if (short_opt || string_ne((*branch.cond._v__ast__IfGuardExpr).var_name, _SLIT("_"))) {
					string base_type = v__gen__c__Gen_base_type(g, (*branch.cond._v__ast__IfGuardExpr).expr_type);
					if (short_opt) {
						string cond_var_name = (string_eq((*branch.cond._v__ast__IfGuardExpr).var_name, _SLIT("_")) ? (_STR("_dummy_%"PRId32"", 1, g->tmp_count + 1)) : ((*branch.cond._v__ast__IfGuardExpr).var_name));
						v__gen__c__Gen_write(g, _STR("\t%.*s\000 %.*s\000 = ", 3, base_type, cond_var_name));
						v__gen__c__Gen_expr(g, (*branch.cond._v__ast__IfGuardExpr).expr);
						v__gen__c__Gen_writeln(g, _SLIT(";"));
					} else {
						v__gen__c__Gen_writeln(g, _STR("\t%.*s\000 %.*s\000 = *(%.*s\000*)%.*s\000.data;", 5, base_type, (*branch.cond._v__ast__IfGuardExpr).var_name, base_type, var_name));
					}
				}
			}
			else {
				v__gen__c__Gen_write(g, _SLIT("if ("));
				v__gen__c__Gen_expr(g, branch.cond);
				v__gen__c__Gen_writeln(g, _SLIT(") {"));
			};
		}
		if (needs_tmp_var) {
			v__gen__c__Gen_stmts_with_tmp_var(g, branch.stmts, tmp);
		} else {
			v__gen__c__Gen_stmts(g, branch.stmts);
		}
	}
	v__gen__c__Gen_writeln(g, _SLIT("}"));
	if (needs_tmp_var) {
		g->empty_line = false;
		v__gen__c__Gen_write(g, _STR("%.*s\000 %.*s", 2, cur_line, tmp));
	}
	if (v__ast__Type_has_flag(node.typ, v__ast__TypeFlag_optional)) {
		g->inside_if_optional = false;
	}
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL bool v__gen__c__Gen_expr_is_multi_return_call(v__gen__c__Gen* g, v__ast__Expr expr) {
	if (expr._typ == 241 /* v.ast.CallExpr */) {
		 bool _t2956 = v__ast__Table_get_type_symbol(g->table, (*expr._v__ast__CallExpr).return_type)->kind == v__ast__Kind_multi_return;
		// autofree_scope_vars(pos=132959 line_nr=4628 scope.pos=132945 scope.end_pos=133031)
		// var "expr" var.pos=132936 var.line_nr=4627
		// af parent scope:
		// var "g" var.pos=132873 var.line_nr=4626
		// var "expr" var.pos=132907 var.line_nr=4626
		// af parent scope:
		// af parent scope:
		return _t2956;
	}
	else {
		 bool _t2957 = false;
		// autofree_scope_vars(pos=133041 line_nr=4629 scope.pos=133035 scope.end_pos=133055)
		// af parent scope:
		// var "g" var.pos=132873 var.line_nr=4626
		// var "expr" var.pos=132907 var.line_nr=4626
		// af parent scope:
		// af parent scope:
		return _t2957;
	};
	return 0;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_optional_error(v__gen__c__Gen* g, v__ast__Type target_type, v__ast__Expr expr) {
	string styp = v__gen__c__Gen_typ(g, target_type);
	v__gen__c__Gen_write(g, _STR("(%.*s\000){ .state=2, .err=", 2, styp));
	v__gen__c__Gen_expr(g, expr);
	v__gen__c__Gen_write(g, _SLIT(" }"));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_return_stmt(v__gen__c__Gen* g, v__ast__Return node) {
bool v__gen__c__Gen_return_stmt_defer_0 = false;
	v__gen__c__Gen_write_v_source_line_info(g, node.pos);
	if (node.exprs.len > 0) {
		if (((*(v__ast__Expr*)/*ee elem_typ */array_get(node.exprs, 0)))._typ == 246 /* v.ast.ComptimeCall */) {
			v__gen__c__Gen_expr(g, (*(v__ast__Expr*)/*ee elem_typ */array_get(node.exprs, 0)));
			v__gen__c__Gen_writeln(g, _SLIT(";"));
			return;
		}
	}
	g->inside_return = true;
	v__gen__c__Gen_return_stmt_defer_0 = true;
	v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, g->fn_decl->return_type);
	bool fn_return_is_multi = sym->kind == v__ast__Kind_multi_return;
	bool fn_return_is_optional = v__ast__Type_has_flag(g->fn_decl->return_type, v__ast__TypeFlag_optional);
	bool has_semicolon = false;
	if (node.exprs.len == 0) {
		if (fn_return_is_optional) {
			string styp = v__gen__c__Gen_typ(g, g->fn_decl->return_type);
			v__gen__c__Gen_writeln(g, _STR("return (%.*s\000){0};", 2, styp));
		} else {
			if (g->is_autofree) {
				v__gen__c__Gen_writeln(g, _SLIT("// free before return (no values returned)"));
				v__gen__c__Gen_autofree_scope_vars(g, node.pos.pos - 1, node.pos.line_nr, true);
			}
			v__gen__c__Gen_writeln(g, _SLIT("return;"));
		}
		// Defer begin
		if (v__gen__c__Gen_return_stmt_defer_0 == true) {
			g->inside_return = false;
		}
		// Defer end
		return;
	}
	if (fn_return_is_optional) {
		bool optional_none = ((*(v__ast__Expr*)/*ee elem_typ */array_get(node.exprs, 0)))._typ == 265 /* v.ast.None */;
		string ftyp = v__gen__c__Gen_typ(g, (*(v__ast__Type*)/*ee elem_typ */array_get(node.types, 0)));
		bool is_regular_option = (string_eq(ftyp, _SLIT("Option2")) || string_eq(ftyp, _SLIT("Option")));
		if (optional_none || is_regular_option || (*(v__ast__Type*)/*ee elem_typ */array_get(node.types, 0)) == _const_v__ast__error_type_idx) {
			v__gen__c__Gen_write(g, _SLIT("return "));
			v__gen__c__Gen_gen_optional_error(g, g->fn_decl->return_type, (*(v__ast__Expr*)/*ee elem_typ */array_get(node.exprs, 0)));
			v__gen__c__Gen_writeln(g, _SLIT(";"));
			// Defer begin
			if (v__gen__c__Gen_return_stmt_defer_0 == true) {
				g->inside_return = false;
			}
			// Defer end
			return;
		}
	}
	if (fn_return_is_multi && node.exprs.len > 0 && !v__gen__c__Gen_expr_is_multi_return_call(g, (*(v__ast__Expr*)/*ee elem_typ */array_get(node.exprs, 0)))) {
		string styp = _SLIT("");
		string opt_tmp = _SLIT("");
		string opt_type = _SLIT("");
		if (fn_return_is_optional) {
			opt_type = v__gen__c__Gen_typ(g, g->fn_decl->return_type);
			opt_tmp = v__gen__c__Gen_new_tmp_var(g);
			v__gen__c__Gen_writeln(g, _STR("%.*s\000 %.*s\000;", 3, opt_type, opt_tmp));
			styp = v__gen__c__Gen_base_type(g, g->fn_decl->return_type);
			v__gen__c__Gen_write(g, _STR("opt_ok(&(%.*s\000/*X*/[]) { ", 2, styp));
		} else {
			v__gen__c__Gen_write(g, _SLIT("return "));
			styp = v__gen__c__Gen_typ(g, g->fn_decl->return_type);
		}
		string multi_unpack = _SLIT("");
		v__gen__c__Gen_write(g, _STR("(%.*s\000){", 2, styp));
		int arg_idx = 0;
		// FOR IN array
		for (int i = 0; i < node.exprs.len; ++i) {
			v__ast__Expr expr = ((v__ast__Expr*)node.exprs.data)[i];
			if (v__gen__c__Gen_expr_is_multi_return_call(g, expr)) {
				v__ast__CallExpr c = /* as */ *(v__ast__CallExpr*)__as_cast((expr)._v__ast__CallExpr,(expr)._typ, 241) /*expected idx: 241, name: v.ast.CallExpr */ ;
				v__ast__TypeSymbol* expr_sym = v__ast__Table_get_type_symbol(g->table, c.return_type);
				string tmp = v__gen__c__Gen_new_tmp_var(g);
				if (!v__ast__Type_has_flag(c.return_type, v__ast__TypeFlag_optional)) {
					string s = v__gen__c__Gen_go_before_stmt(g, 0);
					string expr_styp = v__gen__c__Gen_typ(g, c.return_type);
					v__gen__c__Gen_write(g, _STR("%.*s\000 %.*s\000=", 3, expr_styp, tmp));
					v__gen__c__Gen_expr(g, expr);
					v__gen__c__Gen_writeln(g, _SLIT(";"));
					multi_unpack = /*f*/string_add(multi_unpack, v__gen__c__Gen_go_before_stmt(g, 0));
					v__gen__c__Gen_write(g, s);
				} else {
					string s = v__gen__c__Gen_go_before_stmt(g, 0);
					g->tmp_count--;
					v__gen__c__Gen_expr(g, expr);
					multi_unpack = /*f*/string_add(multi_unpack, v__gen__c__Gen_go_before_stmt(g, 0));
					v__gen__c__Gen_write(g, s);
					string expr_styp = v__gen__c__Gen_base_type(g, c.return_type);
					tmp = (_STR("/*opt*/(*(%.*s\000*)%.*s\000.data)", 3, expr_styp, tmp));
				}
				Array_v__ast__Type expr_types = v__ast__TypeSymbol_mr_info(expr_sym).types;
				// FOR IN array
				for (int j = 0; j < expr_types.len; ++j) {
					v__gen__c__Gen_write(g, _STR(".arg%"PRId32"\000=%.*s\000.arg%"PRId32"", 3, arg_idx, tmp, j));
					if (j < expr_types.len || i < node.exprs.len - 1) {
						v__gen__c__Gen_write(g, _SLIT(","));
					}
					arg_idx++;
				}
				continue;
			}
			v__gen__c__Gen_write(g, _STR(".arg%"PRId32"\000=", 2, arg_idx));
			v__gen__c__Gen_expr(g, expr);
			arg_idx++;
			if (i < node.exprs.len - 1) {
				v__gen__c__Gen_write(g, _SLIT(", "));
			}
		}
		v__gen__c__Gen_write(g, _SLIT("}"));
		if (fn_return_is_optional) {
			v__gen__c__Gen_writeln(g, _STR(" }, (Option*)(&%.*s\000), sizeof(%.*s\000));", 3, opt_tmp, styp));
			v__gen__c__Gen_write(g, _STR("return %.*s", 1, opt_tmp));
		}
		if (multi_unpack.len > 0) {
			v__gen__c__Gen_insert_before_stmt(g, multi_unpack);
		}
	} else if (node.exprs.len >= 1) {
		v__ast__TypeSymbol* return_sym = v__ast__Table_get_type_symbol(g->table, (*(v__ast__Type*)/*ee elem_typ */array_get(node.types, 0)));
		v__ast__Expr expr0 = (*(v__ast__Expr*)/*ee elem_typ */array_get(node.exprs, 0));
		bool _t2958;
		if (expr0._typ == 241 /* v.ast.CallExpr */) {
			_t2958 = v__ast__Type_has_flag((*expr0._v__ast__CallExpr).return_type, v__ast__TypeFlag_optional) && (*expr0._v__ast__CallExpr).or_block.kind == v__ast__OrKind_absent;
		}
		else {
			_t2958 = v__ast__Type_has_flag((*(v__ast__Type*)/*ee elem_typ */array_get(node.types, 0)), v__ast__TypeFlag_optional);
		}		bool expr_type_is_opt = _t2958;
		if (fn_return_is_optional && !expr_type_is_opt && !(string_eq(return_sym->name, _SLIT("Option2")) || string_eq(return_sym->name, _SLIT("Option")))) {
			string styp = v__gen__c__Gen_base_type(g, g->fn_decl->return_type);
			string opt_type = v__gen__c__Gen_typ(g, g->fn_decl->return_type);
			string opt_tmp = v__gen__c__Gen_new_tmp_var(g);
			v__gen__c__Gen_writeln(g, _STR("%.*s\000 %.*s\000;", 3, opt_type, opt_tmp));
			v__gen__c__Gen_write(g, _STR("opt_ok(&(%.*s\000[]) { ", 2, styp));
			if (!v__ast__Type_is_ptr(g->fn_decl->return_type) && v__ast__Type_is_ptr((*(v__ast__Type*)/*ee elem_typ */array_get(node.types, 0)))) {
				if (!(((*(v__ast__Expr*)/*ee elem_typ */array_get(node.exprs, 0)))._typ == 254 /* v.ast.Ident */ && !g->is_amp)) {
					v__gen__c__Gen_write(g, _SLIT("*"));
				}
			}
			// FOR IN array
			for (int i = 0; i < node.exprs.len; ++i) {
				v__ast__Expr expr = ((v__ast__Expr*)node.exprs.data)[i];
				v__gen__c__Gen_expr_with_cast(g, expr, (*(v__ast__Type*)/*ee elem_typ */array_get(node.types, i)), v__ast__Type_clear_flag(g->fn_decl->return_type, v__ast__TypeFlag_optional));
				if (i < node.exprs.len - 1) {
					v__gen__c__Gen_write(g, _SLIT(", "));
				}
			}
			v__gen__c__Gen_writeln(g, _STR(" }, (Option*)(&%.*s\000), sizeof(%.*s\000));", 3, opt_tmp, styp));
			v__gen__c__Gen_autofree_scope_vars(g, node.pos.pos - 1, node.pos.line_nr, true);
			v__gen__c__Gen_writeln(g, _STR("return %.*s\000;", 2, opt_tmp));
			// Defer begin
			if (v__gen__c__Gen_return_stmt_defer_0 == true) {
				g->inside_return = false;
			}
			// Defer end
			return;
		}
		if (g->is_autofree) {
			v__ast__Expr expr = (*(v__ast__Expr*)/*ee elem_typ */array_get(node.exprs, 0));
			if ((expr)._typ == 254 /* v.ast.Ident */) {
				g->returned_var_name = (*expr._v__ast__Ident).name;
			}
		}
		bool gen_tmp_var = !g->is_builtin_mod;
		string tmp = _SLIT("");
		if (gen_tmp_var) {
			if (((*(v__ast__Expr*)/*ee elem_typ */array_get(node.exprs, 0)))._typ != 254 /* v.ast.Ident */) {
				tmp = v__gen__c__Gen_new_tmp_var(g);
				v__gen__c__Gen_write(g, _SLIT(" "));
				v__gen__c__Gen_write(g, v__gen__c__Gen_typ(g, g->fn_decl->return_type));
				v__gen__c__Gen_write(g, _SLIT(" "));
				v__gen__c__Gen_write(g, tmp);
				v__gen__c__Gen_write(g, _SLIT(" = "));
			} else {
				gen_tmp_var = false;
				v__gen__c__Gen_autofree_scope_vars(g, node.pos.pos - 1, node.pos.line_nr, true);
				v__gen__c__Gen_write(g, _SLIT("return "));
			}
		} else {
			v__gen__c__Gen_autofree_scope_vars(g, node.pos.pos - 1, node.pos.line_nr, true);
			v__gen__c__Gen_write(g, _SLIT("return "));
		}
		if (v__ast__Expr_is_auto_deref_var(expr0)) {
			if (v__ast__Type_is_ptr(g->fn_decl->return_type)) {
				string var_str = v__gen__c__Gen_expr_string(g, expr0);
				v__gen__c__Gen_write(g, string_trim(var_str, _SLIT("&")));
			} else {
				v__gen__c__Gen_write(g, _SLIT("*"));
				v__gen__c__Gen_expr(g, expr0);
			}
		} else {
			v__gen__c__Gen_expr_with_cast(g, (*(v__ast__Expr*)/*ee elem_typ */array_get(node.exprs, 0)), (*(v__ast__Type*)/*ee elem_typ */array_get(node.types, 0)), g->fn_decl->return_type);
		}
		if (gen_tmp_var) {
			v__gen__c__Gen_writeln(g, _SLIT(";"));
			has_semicolon = true;
			if ((tmp).len != 0) {
				v__gen__c__Gen_autofree_scope_vars(g, node.pos.pos - 1, node.pos.line_nr, true);
				v__gen__c__Gen_write(g, _STR("return %.*s", 1, tmp));
				has_semicolon = false;
			}
		}
	} else {
		println(_SLIT("this should never happen"));
		v__gen__c__Gen_write(g, _SLIT("/*F*/return"));
	}
	if (!has_semicolon) {
		v__gen__c__Gen_writeln(g, _SLIT(";"));
	}
// Defer begin
if (v__gen__c__Gen_return_stmt_defer_0 == true) {
	g->inside_return = false;
}
// Defer end
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_const_decl(v__gen__c__Gen* g, v__ast__ConstDecl node) {
bool v__gen__c__Gen_const_decl_defer_0 = false;
	g->inside_const = true;
	v__gen__c__Gen_const_decl_defer_0 = true;
	// FOR IN array
	for (int _t2959 = 0; _t2959 < node.fields.len; ++_t2959) {
		v__ast__ConstField field = ((v__ast__ConstField*)node.fields.data)[_t2959];
		if (g->pref->skip_unused) {
			if (!_IN_MAP(ADDR(string, field.name), ADDR(map, g->table->used_consts))) {
				continue;
			}
		}
		string name = v__gen__c__c_name(field.name);
		int pos = g->out.len;
		v__gen__c__Gen_expr(g, field.expr);
		string val = strings__Builder_after(&g->out, pos);
		strings__Builder_go_back(&g->out, val.len);
		if (field.expr._typ == 244 /* v.ast.CharLiteral */) {
			v__gen__c__Gen_const_decl_simple_define(g, name, val);
		}
		else if (field.expr._typ == 252 /* v.ast.FloatLiteral */) {
			v__gen__c__Gen_const_decl_simple_define(g, name, val);
		}
		else if (field.expr._typ == 259 /* v.ast.IntegerLiteral */) {
			v__gen__c__Gen_const_decl_simple_define(g, name, val);
		}
		else if (field.expr._typ == 235 /* v.ast.ArrayInit */) {
			if ((*field.expr._v__ast__ArrayInit).is_fixed) {
				string styp = v__gen__c__Gen_typ(g, (*field.expr._v__ast__ArrayInit).typ);
				if (g->pref->build_mode != v__pref__BuildMode_build_module) {
					strings__Builder_writeln(&g->definitions, _STR("%.*s\000 _const_%.*s\000 = %.*s\000; // fixed array const", 4, styp, name, val));
				} else {
					strings__Builder_writeln(&g->definitions, _STR("%.*s\000 _const_%.*s\000; // fixed array const", 3, styp, name));
				}
			} else {
				v__gen__c__Gen_const_decl_init_later(g, field.mod, name, val, field.typ, false);
			}
		}
		else if (field.expr._typ == 277 /* v.ast.StringLiteral */) {
			strings__Builder_writeln(&g->definitions, _STR("string _const_%.*s\000; // a string literal, inited later", 2, name));
			if (g->pref->build_mode != v__pref__BuildMode_build_module) {
				strings__Builder_writeln(&g->stringliterals, _STR("\t_const_%.*s\000 = %.*s\000;", 3, name, val));
			}
		}
		else if (field.expr._typ == 241 /* v.ast.CallExpr */) {
			if (string_starts_with(val, _SLIT("Option_"))) {
				strings__Builder_writeln(&(*(strings__Builder*)map_get(ADDR(map, g->inits), &(string[]){field.mod}, &(strings__Builder[]){ (strings__Builder){.buf = __new_array(0, 1, sizeof(byte)),.initial_size = 1,} })), val);
				bool unwrap_option = (*field.expr._v__ast__CallExpr).or_block.kind != v__ast__OrKind_absent;
				v__gen__c__Gen_const_decl_init_later(g, field.mod, name, v__gen__c__Gen_current_tmp_var(g), field.typ, unwrap_option);
			} else {
				v__gen__c__Gen_const_decl_init_later(g, field.mod, name, val, field.typ, false);
			}
		}
		else {
			v__gen__c__Gen_const_decl_init_later(g, field.mod, name, val, field.typ, false);
		};
	}
// Defer begin
if (v__gen__c__Gen_const_decl_defer_0 == true) {
	g->inside_const = false;
}
// Defer end
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_const_decl_simple_define(v__gen__c__Gen* g, string name, string val) {
	strings__Builder_write_string(&g->definitions, _STR("#define _const_%.*s\000 ", 2, name));
	strings__Builder_writeln(&g->definitions, val);
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_const_decl_init_later(v__gen__c__Gen* g, string mod, string name, string val, v__ast__Type typ, bool unwrap_option) {
	string styp = v__gen__c__Gen_typ(g, typ);
	if (string_eq(styp, _SLIT("Option2"))) {
		styp = _SLIT("IError");
	}
	string cname = _STR("_const_%.*s", 1, name);
	strings__Builder_writeln(&g->definitions, _STR("%.*s\000 %.*s\000; // inited later", 3, styp, cname));
	if (string_eq(cname, _SLIT("_const_os__args"))) {
		if (g->pref->os == v__pref__OS_windows) {
			strings__Builder_writeln(&(*(strings__Builder*)map_get(ADDR(map, g->inits), &(string[]){mod}, &(strings__Builder[]){ (strings__Builder){.buf = __new_array(0, 1, sizeof(byte)),.initial_size = 1,} })), _SLIT("\t_const_os__args = os__init_os_args_wide(___argc, (byteptr*)___argv);"));
		} else {
			strings__Builder_writeln(&(*(strings__Builder*)map_get(ADDR(map, g->inits), &(string[]){mod}, &(strings__Builder[]){ (strings__Builder){.buf = __new_array(0, 1, sizeof(byte)),.initial_size = 1,} })), _SLIT("\t_const_os__args = os__init_os_args(___argc, (byte**)___argv);"));
		}
	} else {
		if (unwrap_option) {
			strings__Builder_writeln(&(*(strings__Builder*)map_get(ADDR(map, g->inits), &(string[]){mod}, &(strings__Builder[]){ (strings__Builder){.buf = __new_array(0, 1, sizeof(byte)),.initial_size = 1,} })), _STR("\t%.*s\000 = *(%.*s\000*)%.*s\000.data;", 4, cname, styp, val));
		} else {
			strings__Builder_writeln(&(*(strings__Builder*)map_get(ADDR(map, g->inits), &(string[]){mod}, &(strings__Builder[]){ (strings__Builder){.buf = __new_array(0, 1, sizeof(byte)),.initial_size = 1,} })), _STR("\t%.*s\000 = %.*s\000;", 3, cname, val));
		}
	}
	if (g->is_autofree) {
		v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, typ);
		if (string_starts_with(styp, _SLIT("Array_"))) {
			strings__Builder_writeln(&(*(strings__Builder*)map_get(ADDR(map, g->cleanups), &(string[]){mod}, &(strings__Builder[]){ (strings__Builder){.buf = __new_array(0, 1, sizeof(byte)),.initial_size = 1,} })), _STR("\tarray_free(&%.*s\000);", 2, cname));
		} else if (string_eq(styp, _SLIT("string"))) {
			strings__Builder_writeln(&(*(strings__Builder*)map_get(ADDR(map, g->cleanups), &(string[]){mod}, &(strings__Builder[]){ (strings__Builder){.buf = __new_array(0, 1, sizeof(byte)),.initial_size = 1,} })), _STR("\tstring_free(&%.*s\000);", 2, cname));
		} else if (sym->kind == v__ast__Kind_map) {
			strings__Builder_writeln(&(*(strings__Builder*)map_get(ADDR(map, g->cleanups), &(string[]){mod}, &(strings__Builder[]){ (strings__Builder){.buf = __new_array(0, 1, sizeof(byte)),.initial_size = 1,} })), _STR("\tmap_free(&%.*s\000);", 2, cname));
		} else if (string_eq(styp, _SLIT("IError"))) {
			strings__Builder_writeln(&(*(strings__Builder*)map_get(ADDR(map, g->cleanups), &(string[]){mod}, &(strings__Builder[]){ (strings__Builder){.buf = __new_array(0, 1, sizeof(byte)),.initial_size = 1,} })), _STR("\tIError_free(&%.*s\000);", 2, cname));
		}
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_global_decl(v__gen__c__Gen* g, v__ast__GlobalDecl node) {
	string mod = (g->pref->build_mode == v__pref__BuildMode_build_module && g->is_builtin_mod ? (_SLIT("static ")) : (_SLIT("")));
	// FOR IN array
	for (int _t2960 = 0; _t2960 < node.fields.len; ++_t2960) {
		v__ast__GlobalField field = ((v__ast__GlobalField*)node.fields.data)[_t2960];
		string styp = v__gen__c__Gen_typ(g, field.typ);
		if (field.has_expr) {
			strings__Builder_writeln(&g->definitions, _STR("%.*s\000%.*s\000 %.*s\000 = %.*s\000; // global", 5, mod, styp, field.name, v__ast__Expr_str(field.expr)));
		} else {
			strings__Builder_writeln(&g->definitions, _STR("%.*s\000%.*s\000 %.*s\000; // global", 4, mod, styp, field.name));
		}
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_go_back_out(v__gen__c__Gen* g, int n) {
	strings__Builder_go_back(&g->out, n);
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_struct_init(v__gen__c__Gen* g, v__ast__StructInit struct_init) {
	string styp = v__gen__c__Gen_typ(g, struct_init.typ);
	string shared_styp = _SLIT("");
	if ((Array_string_contains(_const_v__gen__c__skip_struct_init, styp))) {
		v__gen__c__Gen_go_back_out(g, 3);
		return;
	}
	v__ast__TypeSymbol* sym = v__ast__Table_get_final_type_symbol(g->table, v__gen__c__Gen_unwrap_generic(g, struct_init.typ));
	bool is_amp = g->is_amp;
	bool is_multiline = struct_init.fields.len > 5;
	g->is_amp = false;
	if (is_amp) {
		strings__Builder_go_back(&g->out, 1);
	}
	if (g->is_shared && !g->inside_opt_data && !g->is_arraymap_set) {
		v__ast__Type shared_typ = v__ast__Type_set_flag(struct_init.typ, v__ast__TypeFlag_shared_f);
		shared_styp = v__gen__c__Gen_typ(g, shared_typ);
		v__gen__c__Gen_writeln(g, _STR("(%.*s\000*)__dup%.*s\000(&(%.*s\000){.val = (%.*s\000){", 5, shared_styp, shared_styp, shared_styp, styp));
	} else if (is_amp) {
		v__gen__c__Gen_write(g, _STR("(%.*s\000*)memdup(&(%.*s\000){", 3, styp, styp));
	} else if (v__ast__Type_is_ptr(struct_init.typ)) {
		string basetyp = v__gen__c__Gen_typ(g, v__ast__Type_set_nr_muls(struct_init.typ, 0));
		if (is_multiline) {
			v__gen__c__Gen_writeln(g, _STR("&(%.*s\000){", 2, basetyp));
		} else {
			v__gen__c__Gen_write(g, _STR("&(%.*s\000){", 2, basetyp));
		}
	} else {
		if (is_multiline) {
			v__gen__c__Gen_writeln(g, _STR("(%.*s\000){", 2, styp));
		} else {
			v__gen__c__Gen_write(g, _STR("(%.*s\000){", 2, styp));
		}
	}
	Map_string_int inited_fields = new_map(sizeof(string), sizeof(int), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
	if (is_multiline) {
		g->indent++;
	}
	bool initialized = false;
	// FOR IN array
	for (int i = 0; i < struct_init.fields.len; ++i) {
		v__ast__StructInitField field = ((v__ast__StructInitField*)struct_init.fields.data)[i];
		map_set(&inited_fields, &(string[]){field.name}, &(int[]) { i });
		if (sym->kind != v__ast__Kind_struct_) {
			string field_name = v__gen__c__c_name(field.name);
			v__gen__c__Gen_write(g, _STR(".%.*s\000 = ", 2, field_name));
			if (field.typ == 0) {
				v__gen__c__Gen_checker_bug(g, _SLIT("struct init, field.typ is 0"), field.pos);
			}
			v__ast__TypeSymbol* field_type_sym = v__ast__Table_get_type_symbol(g->table, field.typ);
			bool cloned = false;
			if (g->is_autofree && !v__ast__Type_is_ptr(field.typ) && (field_type_sym->kind == v__ast__Kind_array || field_type_sym->kind == v__ast__Kind_string)) {
				v__gen__c__Gen_write(g, _SLIT("/*clone1*/"));
				if (v__gen__c__Gen_gen_clone_assignment(g, field.expr, *field_type_sym, false)) {
					cloned = true;
				}
			}
			if (!cloned) {
				if ((v__ast__Type_is_ptr(field.expected_type) && !v__ast__Type_has_flag(field.expected_type, v__ast__TypeFlag_shared_f)) && !(v__ast__Type_is_ptr(field.typ) || v__ast__Type_is_pointer(field.typ)) && !v__ast__Type_is_number(field.typ)) {
					v__gen__c__Gen_write(g, _SLIT("/* autoref */&"));
				}
				v__gen__c__Gen_expr_with_cast(g, field.expr, field.typ, field.expected_type);
			}
			if (i != struct_init.fields.len - 1) {
				if (is_multiline) {
					v__gen__c__Gen_writeln(g, _SLIT(","));
				} else {
					v__gen__c__Gen_write(g, _SLIT(", "));
				}
			}
			initialized = true;
		}
	}
	if (sym->kind == v__ast__Kind_struct_) {
		v__ast__Struct info = /* as */ *(v__ast__Struct*)__as_cast((sym->info)._v__ast__Struct,(sym->info)._typ, 409) /*expected idx: 409, name: v.ast.Struct */ ;
		if (info.is_union && struct_init.fields.len > 1) {
			v__gen__c__verror(_SLIT("union must not have more than 1 initializer"));
		}
		// FOR IN array
		for (int _t2961 = 0; _t2961 < info.embeds.len; ++_t2961) {
			v__ast__Type embed = ((v__ast__Type*)info.embeds.data)[_t2961];
			v__ast__TypeSymbol* embed_sym = v__ast__Table_get_type_symbol(g->table, embed);
			string embed_name = v__ast__TypeSymbol_embed_name(embed_sym);
			if (!_IN_MAP(ADDR(string, embed_name), ADDR(map, inited_fields))) {
				v__ast__StructInit default_init = (v__ast__StructInit){.pos = {0},.name_pos = {0},.is_short = 0,.unresolved = 0,.pre_comments = __new_array(0, 1, sizeof(v__ast__Comment)),.typ = embed,.update_expr = {0},.update_expr_type = 0,.update_expr_comments = __new_array(0, 1, sizeof(v__ast__Comment)),.has_update_expr = 0,.fields = __new_array(0, 1, sizeof(v__ast__StructInitField)),.embeds = __new_array(0, 1, sizeof(v__ast__StructInitEmbed)),};
				v__gen__c__Gen_write(g, _STR(".%.*s\000 = ", 2, embed_name));
				v__gen__c__Gen_struct_init(g, default_init);
				if (is_multiline) {
					v__gen__c__Gen_writeln(g, _SLIT(","));
				} else {
					v__gen__c__Gen_write(g, _SLIT(","));
				}
				initialized = true;
			}
		}
		// FOR IN array
		for (int _t2962 = 0; _t2962 < info.fields.len; ++_t2962) {
			v__ast__StructField field = ((v__ast__StructField*)info.fields.data)[_t2962];
			if ((sym->info)._typ == 409 /* v.ast.Struct */) {
				Array_v__ast__StructField _t2963_orig = (*sym->info._v__ast__Struct).fields;
				int _t2963_len = _t2963_orig.len;
				Array_v__ast__StructField _t2963 = __new_array(0, _t2963_len, sizeof(v__ast__StructField));

				for (int _t2964 = 0; _t2964 < _t2963_len; ++_t2964) {
					v__ast__StructField it = ((v__ast__StructField*) _t2963_orig.data)[_t2964];
					if (string_eq(it.name, field.name)) {
						array_push(&_t2963, &it); 
		}
				}
				
				Array_v__ast__StructField equal_fields = _t2963;
				if (equal_fields.len == 0) {
					continue;
				}
			}
			if (_IN_MAP(ADDR(string, field.name), ADDR(map, inited_fields))) {
				v__ast__StructInitField sfield = (*(v__ast__StructInitField*)/*ee elem_typ */array_get(struct_init.fields, (*(int*)map_get(ADDR(map, inited_fields), &(string[]){field.name}, &(int[]){ 0 }))));
				string field_name = v__gen__c__c_name(sfield.name);
				if (sfield.typ == 0) {
					continue;
				}
				v__gen__c__Gen_write(g, _STR(".%.*s\000 = ", 2, field_name));
				v__ast__TypeSymbol* field_type_sym = v__ast__Table_get_type_symbol(g->table, sfield.typ);
				bool cloned = false;
				if (g->is_autofree && !v__ast__Type_is_ptr(sfield.typ) && (field_type_sym->kind == v__ast__Kind_array || field_type_sym->kind == v__ast__Kind_string)) {
					v__gen__c__Gen_write(g, _SLIT("/*clone1*/"));
					if (v__gen__c__Gen_gen_clone_assignment(g, sfield.expr, *field_type_sym, false)) {
						cloned = true;
					}
				}
				if (!cloned) {
					if ((v__ast__Type_is_ptr(sfield.expected_type) && !v__ast__Type_has_flag(sfield.expected_type, v__ast__TypeFlag_shared_f)) && !(v__ast__Type_is_ptr(sfield.typ) || v__ast__Type_is_pointer(sfield.typ)) && !v__ast__Type_is_number(sfield.typ)) {
						v__gen__c__Gen_write(g, _SLIT("/* autoref */&"));
					}
					v__gen__c__Gen_expr_with_cast(g, sfield.expr, sfield.typ, sfield.expected_type);
				}
				if (is_multiline) {
					v__gen__c__Gen_writeln(g, _SLIT(","));
				} else {
					v__gen__c__Gen_write(g, _SLIT(","));
				}
				initialized = true;
				continue;
			}
			if (info.is_union) {
				continue;
			}
			if (v__ast__Type_has_flag(field.typ, v__ast__TypeFlag_optional)) {
				continue;
			}
			if ((Array_v__ast__Type_contains(info.embeds, field.typ))) {
				continue;
			}
			if (struct_init.has_update_expr) {
				v__gen__c__Gen_expr(g, struct_init.update_expr);
				if (v__ast__Type_is_ptr(struct_init.update_expr_type)) {
					v__gen__c__Gen_write(g, _SLIT("->"));
				} else {
					v__gen__c__Gen_write(g, _SLIT("."));
				}
				v__gen__c__Gen_write(g, field.name);
			} else {
				v__gen__c__Gen_zero_struct_field(g, field);
			}
			if (is_multiline) {
				v__gen__c__Gen_writeln(g, _SLIT(","));
			} else {
				v__gen__c__Gen_write(g, _SLIT(","));
			}
			initialized = true;
		}
	}
	if (is_multiline) {
		g->indent--;
	}
	if (!initialized) {
		v__gen__c__Gen_write(g, _SLIT("0"));
	}
	v__gen__c__Gen_write(g, _SLIT("}"));
	if (g->is_shared && !g->inside_opt_data && !g->is_arraymap_set) {
		v__gen__c__Gen_write(g, _STR("}, sizeof(%.*s\000))", 2, shared_styp));
	} else if (is_amp) {
		v__gen__c__Gen_write(g, _STR(", sizeof(%.*s\000))", 2, styp));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_zero_struct_field(v__gen__c__Gen* g, v__ast__StructField field) {
	string field_name = v__gen__c__c_name(field.name);
	v__gen__c__Gen_write(g, _STR(".%.*s\000 = ", 2, field_name));
	v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, field.typ);
	if (field.has_default_expr) {
		if ((sym->kind == v__ast__Kind_sum_type || sym->kind == v__ast__Kind_interface_)) {
			v__gen__c__Gen_expr_with_cast(g, field.default_expr, field.default_expr_typ, field.typ);
			return;
		}
		v__gen__c__Gen_expr(g, field.default_expr);
	} else {
		v__gen__c__Gen_write(g, v__gen__c__Gen_type_default(g, field.typ));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_assoc(v__gen__c__Gen* g, v__ast__Assoc node) {
	v__gen__c__Gen_writeln(g, _SLIT("// assoc"));
	if (node.typ == 0) {
		return;
	}
	string styp = v__gen__c__Gen_typ(g, node.typ);
	v__gen__c__Gen_writeln(g, _STR("(%.*s\000){", 2, styp));
	Map_string_int inited_fields = new_map(sizeof(string), sizeof(int), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
	// FOR IN array
	for (int i = 0; i < node.fields.len; ++i) {
		string field = ((string*)node.fields.data)[i];
		map_set(&inited_fields, &(string[]){field}, &(int[]) { i });
	}
	v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, node.typ);
	v__ast__Struct info = /* as */ *(v__ast__Struct*)__as_cast((sym->info)._v__ast__Struct,(sym->info)._typ, 409) /*expected idx: 409, name: v.ast.Struct */ ;
	// FOR IN array
	for (int _t2965 = 0; _t2965 < info.fields.len; ++_t2965) {
		v__ast__StructField field = ((v__ast__StructField*)info.fields.data)[_t2965];
		string field_name = v__gen__c__c_name(field.name);
		if (_IN_MAP(ADDR(string, field.name), ADDR(map, inited_fields))) {
			v__gen__c__Gen_write(g, _STR("\t.%.*s\000 = ", 2, field_name));
			v__gen__c__Gen_expr(g, (*(v__ast__Expr*)/*ee elem_typ */array_get(node.exprs, (*(int*)map_get(ADDR(map, inited_fields), &(string[]){field.name}, &(int[]){ 0 })))));
			v__gen__c__Gen_writeln(g, _SLIT(", "));
		} else {
			v__gen__c__Gen_writeln(g, _STR("\t.%.*s\000 = %.*s\000.%.*s\000,", 4, field_name, node.var_name, field_name));
		}
	}
	v__gen__c__Gen_write(g, _SLIT("}"));
	if (g->is_amp) {
		v__gen__c__Gen_write(g, _STR(", sizeof(%.*s\000))", 2, styp));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__verror(string s) {
	v__util__verror(_SLIT("cgen error"), s);
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_error(v__gen__c__Gen* g, string s, v__token__Position pos) {
	string ferror = v__util__formatted_error(_SLIT("cgen error:"), s, g->file.path, pos);
	eprintln(ferror);
	v_exit(1);
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_checker_bug(v__gen__c__Gen* g, string s, v__token__Position pos) {
	v__gen__c__Gen_error(g, _STR("checker bug; %.*s", 1, s), pos);
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_write_init_function(v__gen__c__Gen* g) {
	if (g->pref->is_liveshared) {
		return;
	}
	int fn_vinit_start_pos = g->out.len;
	v__gen__c__Gen_writeln(g, _SLIT("void _vinit(int ___argc, voidptr ___argv) {"));
	if (g->is_autofree) {
	}
	if (g->pref->prealloc) {
		v__gen__c__Gen_writeln(g, _SLIT("g_m2_buf = malloc(150 * 1000 * 1000);"));
		v__gen__c__Gen_writeln(g, _SLIT("g_m2_ptr = g_m2_buf;"));
	}
	v__gen__c__Gen_write(g, _SLIT("\tas_cast_type_indexes = "));
	v__gen__c__Gen_writeln(g, v__gen__c__Gen_as_cast_name_table(g));
	v__gen__c__Gen_writeln(g, _SLIT("\tbuiltin_init();"));
	v__gen__c__Gen_writeln(g, _SLIT("\tvinit_string_literals();"));
	// FOR IN array
	for (int _t2966 = 0; _t2966 < g->table->modules.len; ++_t2966) {
		string mod_name = ((string*)g->table->modules.data)[_t2966];
		v__gen__c__Gen_writeln(g, _STR("\t// Initializations for module %.*s\000 :", 2, mod_name));
		v__gen__c__Gen_write(g, strings__Builder_str(&(*(strings__Builder*)map_get(ADDR(map, g->inits), &(string[]){mod_name}, &(strings__Builder[]){ (strings__Builder){.buf = __new_array(0, 1, sizeof(byte)),.initial_size = 1,} }))));
		string init_fn_name = _STR("%.*s\000.init", 2, mod_name);
		Option_v__ast__Fn _t2967;
		if (_t2967 = v__ast__Table_find_fn(g->table, init_fn_name), _t2967.state == 0) {
			v__ast__Fn initfn = *(v__ast__Fn*)_t2967.data;
			if (v__ast__Type_alias_eq(initfn.return_type, _const_v__ast__void_type) && initfn.params.len == 0) {
				string mod_c_name = v__util__no_dots(mod_name);
				string init_fn_c_name = _STR("%.*s\000__init", 2, mod_c_name);
				v__gen__c__Gen_writeln(g, _STR("\t%.*s\000();", 2, init_fn_c_name));
			}
		}
	}
	v__gen__c__Gen_writeln(g, _SLIT("}"));
	if (g->pref->printfn_list.len > 0 && (Array_string_contains(g->pref->printfn_list, _SLIT("_vinit")))) {
		println(strings__Builder_after(&g->out, fn_vinit_start_pos));
	}
	int fn_vcleanup_start_pos = g->out.len;
	v__gen__c__Gen_writeln(g, _SLIT("void _vcleanup() {"));
	if (g->is_autofree) {
		Array_string reversed_table_modules = array_reverse(g->table->modules);
		// FOR IN array
		for (int _t2968 = 0; _t2968 < reversed_table_modules.len; ++_t2968) {
			string mod_name = ((string*)reversed_table_modules.data)[_t2968];
			v__gen__c__Gen_writeln(g, _STR("\t// Cleanups for module %.*s\000 :", 2, mod_name));
			v__gen__c__Gen_writeln(g, strings__Builder_str(&(*(strings__Builder*)map_get(ADDR(map, g->cleanups), &(string[]){mod_name}, &(strings__Builder[]){ (strings__Builder){.buf = __new_array(0, 1, sizeof(byte)),.initial_size = 1,} }))));
		}
		v__gen__c__Gen_writeln(g, _SLIT("\tarray_free(&as_cast_type_indexes);"));
	}
	v__gen__c__Gen_writeln(g, _SLIT("}"));
	if (g->pref->printfn_list.len > 0 && (Array_string_contains(g->pref->printfn_list, _SLIT("_vcleanup")))) {
		println(strings__Builder_after(&g->out, fn_vcleanup_start_pos));
	}
	bool needs_constructor = g->pref->is_shared && g->pref->os != v__pref__OS_windows;
	if (needs_constructor) {
		v__gen__c__Gen_writeln(g, _SLIT("__attribute__ ((constructor))"));
		v__gen__c__Gen_writeln(g, _SLIT("void _vinit_caller() {"));
		v__gen__c__Gen_writeln(g, _SLIT("\tstatic bool once = false; if (once) {return;} once = true;"));
		v__gen__c__Gen_writeln(g, _SLIT("\t_vinit(0,0);"));
		v__gen__c__Gen_writeln(g, _SLIT("}"));
		v__gen__c__Gen_writeln(g, _SLIT("__attribute__ ((destructor))"));
		v__gen__c__Gen_writeln(g, _SLIT("void _vcleanup_caller() {"));
		v__gen__c__Gen_writeln(g, _SLIT("\tstatic bool once = false; if (once) {return;} once = true;"));
		v__gen__c__Gen_writeln(g, _SLIT("\t_vcleanup();"));
		v__gen__c__Gen_writeln(g, _SLIT("}"));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_write_builtin_types(v__gen__c__Gen* g) {
	Array_v__ast__TypeSymbol builtin_types = __new_array_with_default(0, 0, sizeof(v__ast__TypeSymbol), 0);
	// FOR IN array
	for (int _t2969 = 0; _t2969 < _const_v__gen__c__builtins.len; ++_t2969) {
		string builtin_name = ((string*)_const_v__gen__c__builtins.data)[_t2969];
		v__ast__TypeSymbol sym = (*(v__ast__TypeSymbol*)/*ee elem_typ */array_get(g->table->type_symbols, (*(int*)map_get(ADDR(map, g->table->type_idxs), &(string[]){builtin_name}, &(int[]){ 0 }))));
		if (sym.kind == v__ast__Kind_interface_) {
			v__gen__c__Gen_write_interface_typesymbol_declaration(g, sym);
		} else {
			array_push(&builtin_types, _MOV((v__ast__TypeSymbol[]){ sym }));
		}
	}
	v__gen__c__Gen_write_types(g, builtin_types);
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_write_sorted_types(v__gen__c__Gen* g) {
	Array_v__ast__TypeSymbol types = __new_array_with_default(0, 0, sizeof(v__ast__TypeSymbol), 0);
	// FOR IN array
	for (int _t2971 = 0; _t2971 < g->table->type_symbols.len; ++_t2971) {
		v__ast__TypeSymbol typ = ((v__ast__TypeSymbol*)g->table->type_symbols.data)[_t2971];
		if (!(Array_string_contains(_const_v__gen__c__builtins, typ.name))) {
			array_push(&types, _MOV((v__ast__TypeSymbol[]){ typ }));
		}
	}
	Array_v__ast__TypeSymbol types_sorted = v__gen__c__Gen_sort_structs(g, types);
	strings__Builder_writeln(&g->type_definitions, _SLIT("// builtin types:"));
	strings__Builder_writeln(&g->type_definitions, _SLIT("//------------------ #endbuiltin"));
	v__gen__c__Gen_write_types(g, types_sorted);
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_write_types(v__gen__c__Gen* g, Array_v__ast__TypeSymbol types) {
	// FOR IN array
	for (int _t2973 = 0; _t2973 < types.len; ++_t2973) {
		v__ast__TypeSymbol typ = ((v__ast__TypeSymbol*)types.data)[_t2973];
		if (string_starts_with(typ.name, _SLIT("C."))) {
			continue;
		}
		string name = typ.cname;
		if (typ.info._typ == 409 /* v.ast.Struct */) {
			if ((*typ.info._v__ast__Struct).generic_types.len > 0) {
				continue;
			}
			if (string_contains(name, _SLIT("_T_"))) {
				strings__Builder_writeln(&g->typedefs, _STR("typedef struct %.*s\000 %.*s\000;", 3, name, name));
			}
			int start_pos = g->type_definitions.len;
			if ((*typ.info._v__ast__Struct).is_union) {
				strings__Builder_writeln(&g->type_definitions, _STR("union %.*s\000 {", 2, name));
			} else {
				strings__Builder_writeln(&g->type_definitions, _STR("struct %.*s\000 {", 2, name));
			}
			if ((*typ.info._v__ast__Struct).fields.len > 0 || (*typ.info._v__ast__Struct).embeds.len > 0) {
				// FOR IN array
				for (int _t2974 = 0; _t2974 < (*typ.info._v__ast__Struct).fields.len; ++_t2974) {
					v__ast__StructField field = ((v__ast__StructField*)(*typ.info._v__ast__Struct).fields.data)[_t2974];
					if (v__ast__Type_has_flag(field.typ, v__ast__TypeFlag_optional)) {
						multi_return_string_string mr_156108 = v__gen__c__Gen_optional_type_name(g, field.typ);
						string styp = mr_156108.arg0;
						string base = mr_156108.arg1;
						if (!(Array_string_contains(g->optionals, styp))) {
							string last_text = string_clone(strings__Builder_after(&g->type_definitions, start_pos));
							strings__Builder_go_back_to(&g->type_definitions, start_pos);
							array_push(&g->optionals, _MOV((string[]){ string_clone(styp) }));
							strings__Builder_writeln(&g->typedefs2, _STR("typedef struct %.*s\000 %.*s\000;", 3, styp, styp));
							strings__Builder_writeln(&g->type_definitions, _STR("%.*s\000;", 2, v__gen__c__Gen_optional_type_text(g, styp, base)));
							strings__Builder_write_string(&g->type_definitions, last_text);
						}
					}
					string type_name = v__gen__c__Gen_typ(g, field.typ);
					string field_name = v__gen__c__c_name(field.name);
					strings__Builder_writeln(&g->type_definitions, _STR("\t%.*s\000 %.*s\000;", 3, type_name, field_name));
				}
			} else {
				strings__Builder_writeln(&g->type_definitions, _SLIT("EMPTY_STRUCT_DECLARATION;"));
			}
			string attrs = (Array_v__ast__Attr_contains((*typ.info._v__ast__Struct).attrs, _SLIT("packed")) ? (_SLIT("__attribute__((__packed__))")) : (_SLIT("")));
			strings__Builder_writeln(&g->type_definitions, _STR("} %.*s\000;\n", 2, attrs));
		}
		else if (typ.info._typ == 413 /* v.ast.Alias */) {
		}
		else if (typ.info._typ == 415 /* v.ast.Thread */) {
			if (g->pref->os == v__pref__OS_windows) {
				if (string_eq(name, _SLIT("__v_thread"))) {
					strings__Builder_writeln(&g->type_definitions, _STR("typedef HANDLE %.*s\000;", 2, name));
				} else {
					strings__Builder_writeln(&g->type_definitions, _SLIT("typedef struct {"));
					strings__Builder_writeln(&g->type_definitions, _SLIT("\tvoid* ret_ptr;"));
					strings__Builder_writeln(&g->type_definitions, _SLIT("\tHANDLE handle;"));
					strings__Builder_writeln(&g->type_definitions, _STR("} %.*s\000;", 2, name));
				}
			} else {
				strings__Builder_writeln(&g->type_definitions, _STR("typedef pthread_t %.*s\000;", 2, name));
			}
		}
		else if (typ.info._typ == 411 /* v.ast.SumType */) {
			strings__Builder_writeln(&g->typedefs, _STR("typedef struct %.*s\000 %.*s\000;", 3, name, name));
			strings__Builder_writeln(&g->type_definitions, _SLIT(""));
			strings__Builder_writeln(&g->type_definitions, _STR("// Union sum type %.*s\000 = ", 2, name));
			// FOR IN array
			for (int _t2976 = 0; _t2976 < (*typ.info._v__ast__SumType).variants.len; ++_t2976) {
				v__ast__Type variant = ((v__ast__Type*)(*typ.info._v__ast__SumType).variants.data)[_t2976];
				strings__Builder_writeln(&g->type_definitions, _STR("//          | %4"PRId32"\000 = %*.*s", 2, variant, v__gen__c__Gen_typ(g, v__ast__Type_idx(variant)), -20));
			}
			strings__Builder_writeln(&g->type_definitions, _STR("struct %.*s\000 {", 2, name));
			strings__Builder_writeln(&g->type_definitions, _SLIT("\tunion {"));
			// FOR IN array
			for (int _t2977 = 0; _t2977 < (*typ.info._v__ast__SumType).variants.len; ++_t2977) {
				v__ast__Type variant = ((v__ast__Type*)(*typ.info._v__ast__SumType).variants.data)[_t2977];
				v__ast__TypeSymbol* variant_sym = v__ast__Table_get_type_symbol(g->table, variant);
				strings__Builder_writeln(&g->type_definitions, _STR("\t\t%.*s\000 _%.*s\000;", 3, v__gen__c__Gen_typ(g, v__ast__Type_to_ptr(variant)), variant_sym->cname));
			}
			strings__Builder_writeln(&g->type_definitions, _SLIT("\t};"));
			strings__Builder_writeln(&g->type_definitions, _SLIT("\tint _typ;"));
			if ((*typ.info._v__ast__SumType).fields.len > 0) {
				v__gen__c__Gen_writeln(g, _SLIT("\t// pointers to common sumtype fields"));
				// FOR IN array
				for (int _t2978 = 0; _t2978 < (*typ.info._v__ast__SumType).fields.len; ++_t2978) {
					v__ast__StructField field = ((v__ast__StructField*)(*typ.info._v__ast__SumType).fields.data)[_t2978];
					strings__Builder_writeln(&g->type_definitions, _STR("\t%.*s\000 %.*s\000;", 3, v__gen__c__Gen_typ(g, v__ast__Type_to_ptr(field.typ)), field.name));
				}
			}
			strings__Builder_writeln(&g->type_definitions, _SLIT("};"));
			strings__Builder_writeln(&g->type_definitions, _SLIT(""));
		}
		else if (typ.info._typ == 416 /* v.ast.ArrayFixed */) {
			v__ast__TypeSymbol* elem_sym = v__ast__Table_get_type_symbol(g->table, (*typ.info._v__ast__ArrayFixed).elem_type);
			if (!v__ast__TypeSymbol_is_builtin(elem_sym)) {
				string styp = typ.cname;
				string fixed = string_substr(styp, 12, styp.len);
				string len = string_after(styp, _SLIT("_"));
				fixed = string_substr(fixed, 0, fixed.len - len.len - 1);
				if (string_starts_with(fixed, _SLIT("C__"))) {
					fixed = string_substr(fixed, 3, fixed.len);
				}
				if ((elem_sym->info)._typ == 418 /* v.ast.FnType */) {
					int pos = g->out.len;
					v__gen__c__Gen_write_fn_ptr_decl(g, &(*elem_sym->info._v__ast__FnType), _SLIT(""));
					fixed = strings__Builder_after(&g->out, pos);
					strings__Builder_go_back(&g->out, fixed.len);
					string def_str = _STR("typedef %.*s\000;", 2, fixed);
					def_str = string_replace_once(def_str, _SLIT("(*)"), _STR("(*%.*s\000[%.*s\000])", 3, styp, len));
					strings__Builder_writeln(&g->type_definitions, def_str);
				} else {
					strings__Builder_writeln(&g->type_definitions, _STR("typedef %.*s\000 %.*s\000 [%.*s\000];", 4, fixed, styp, len));
				}
			}
		}
		else {
		};
	}
}

VV_LOCAL_SYMBOL Array_v__ast__TypeSymbol v__gen__c__Gen_sort_structs(v__gen__c__Gen* g, Array_v__ast__TypeSymbol typesa) {
	v__depgraph__DepGraph* dep_graph = v__depgraph__new_dep_graph();
	Array_string type_names = __new_array_with_default(0, 0, sizeof(string), 0);
	// FOR IN array
	for (int _t2979 = 0; _t2979 < typesa.len; ++_t2979) {
		v__ast__TypeSymbol typ = ((v__ast__TypeSymbol*)typesa.data)[_t2979];
		array_push(&type_names, _MOV((string[]){ string_clone(typ.name) }));
	}
	// FOR IN array
	for (int _t2981 = 0; _t2981 < typesa.len; ++_t2981) {
		v__ast__TypeSymbol t = ((v__ast__TypeSymbol*)typesa.data)[_t2981];
		if (t.kind == v__ast__Kind_interface_) {
			v__depgraph__DepGraph_add(dep_graph, t.name, __new_array_with_default(0, 0, sizeof(string), 0));
			continue;
		}
		Array_string field_deps = __new_array_with_default(0, 0, sizeof(string), 0);
		if (t.info._typ == 416 /* v.ast.ArrayFixed */) {
			string dep = v__ast__Table_get_type_symbol(g->table, (*t.info._v__ast__ArrayFixed).elem_type)->name;
			if ((Array_string_contains(type_names, dep))) {
				array_push(&field_deps, _MOV((string[]){ string_clone(dep) }));
			}
		}
		else if (t.info._typ == 409 /* v.ast.Struct */) {
			// FOR IN array
			for (int _t2983 = 0; _t2983 < (*t.info._v__ast__Struct).embeds.len; ++_t2983) {
				v__ast__Type embed = ((v__ast__Type*)(*t.info._v__ast__Struct).embeds.data)[_t2983];
				string dep = v__ast__Table_get_type_symbol(g->table, embed)->name;
				if (!(Array_string_contains(type_names, dep)) || (Array_string_contains(field_deps, dep))) {
					continue;
				}
				array_push(&field_deps, _MOV((string[]){ string_clone(dep) }));
			}
			// FOR IN array
			for (int _t2985 = 0; _t2985 < (*t.info._v__ast__Struct).fields.len; ++_t2985) {
				v__ast__StructField field = ((v__ast__StructField*)(*t.info._v__ast__Struct).fields.data)[_t2985];
				string dep = v__ast__Table_get_type_symbol(g->table, field.typ)->name;
				if (!(Array_string_contains(type_names, dep)) || (Array_string_contains(field_deps, dep)) || v__ast__Type_is_ptr(field.typ)) {
					continue;
				}
				array_push(&field_deps, _MOV((string[]){ string_clone(dep) }));
			}
		}
		else {
		};
		v__depgraph__DepGraph_add(dep_graph, t.name, field_deps);
	}
	v__depgraph__DepGraph* dep_graph_sorted = v__depgraph__DepGraph_resolve(dep_graph);
	if (!dep_graph_sorted->acyclic) {
		v__gen__c__verror(string_add(string_add(string_add(_SLIT("cgen.sort_structs(): the following structs form a dependency cycle:\n"), v__depgraph__DepGraph_display_cycles(dep_graph_sorted)), _SLIT("\nyou can solve this by making one or both of the dependant struct fields references, eg: field &MyStruct")), _SLIT("\nif you feel this is an error, please create a new issue here: https://github.com/vlang/v/issues and tag @joe-conigliaro")));
	}
	Array_v__ast__TypeSymbol types_sorted = __new_array_with_default(0, 0, sizeof(v__ast__TypeSymbol), 0);
	// FOR IN array
	for (int _t2987 = 0; _t2987 < dep_graph_sorted->nodes.len; ++_t2987) {
		v__depgraph__DepGraphNode node = ((v__depgraph__DepGraphNode*)dep_graph_sorted->nodes.data)[_t2987];
		array_push(&types_sorted, _MOV((v__ast__TypeSymbol[]){ (*(v__ast__TypeSymbol*)/*ee elem_typ */array_get(g->table->type_symbols, (*(int*)map_get(&g->table->type_idxs, &(string[]){node.name}, &(int[]){ 0 })))) }));
	}
	// autofree_scope_vars(pos=161300 line_nr=5573 scope.pos=159404 scope.end_pos=161321)
	// var "g" var.pos=159405 var.line_nr=5512
	// var "typesa" var.pos=159426 var.line_nr=5512
	// var "dep_graph" var.pos=159475 var.line_nr=5513
	// var "type_names" var.pos=159538 var.line_nr=5515
	// var "dep_graph_sorted" var.pos=160594 var.line_nr=5559
	// var "types_sorted" var.pos=161155 var.line_nr=5569
	// af parent scope:
	// af parent scope:
	return types_sorted;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL int v__gen__c__Gen_nth_stmt_pos(v__gen__c__Gen* g, int n) {
	 int _t2989 = (*(int*)/*ee elem_typ */array_get(g->stmt_path_pos, g->stmt_path_pos.len - (1 + n)));
	// autofree_scope_vars(pos=161371 line_nr=5578 scope.pos=161336 scope.end_pos=161426)
	// var "g" var.pos=161337 var.line_nr=5577
	// var "n" var.pos=161358 var.line_nr=5577
	// af parent scope:
	// af parent scope:
	return _t2989;
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_go_before_stmt(v__gen__c__Gen* g, int n) {
	int stmt_pos = v__gen__c__Gen_nth_stmt_pos(g, n);
	string cur_line = strings__Builder_after(&g->out, stmt_pos);
	strings__Builder_go_back(&g->out, cur_line.len);
	// autofree_scope_vars(pos=161570 line_nr=5585 scope.pos=161432 scope.end_pos=161587)
	// var "g" var.pos=161437 var.line_nr=5581
	// var "n" var.pos=161459 var.line_nr=5581
	// var "stmt_pos" var.pos=161476 var.line_nr=5582
	// var "cur_line" var.pos=161507 var.line_nr=5583
	// af parent scope:
	// af parent scope:
	return cur_line;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL string v__gen__c__Gen_go_before_ternary(v__gen__c__Gen* g) {
	 string _t2990 = v__gen__c__Gen_go_before_stmt(g, g->inside_ternary);
	// autofree_scope_vars(pos=161643 line_nr=5590 scope.pos=161602 scope.end_pos=161686)
	// var "g" var.pos=161607 var.line_nr=5589
	// af parent scope:
	// af parent scope:
	return _t2990;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_insert_before_stmt(v__gen__c__Gen* g, string s) {
	string cur_line = v__gen__c__Gen_go_before_stmt(g, 0);
	v__gen__c__Gen_writeln(g, s);
	v__gen__c__Gen_write(g, cur_line);
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_write_expr_to_string(v__gen__c__Gen* g, v__ast__Expr expr) {
	int pos = g->out.buf.len;
	v__gen__c__Gen_expr(g, expr);
	 string _t2991 = strings__Builder_cut_last(&g->out, g->out.buf.len - pos);
	// autofree_scope_vars(pos=161900 line_nr=5602 scope.pos=161807 scope.end_pos=161944)
	// var "g" var.pos=161812 var.line_nr=5599
	// var "expr" var.pos=161840 var.line_nr=5599
	// var "pos" var.pos=161865 var.line_nr=5600
	// af parent scope:
	// af parent scope:
	return _t2991;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_or_block(v__gen__c__Gen* g, string var_name, v__ast__OrExpr or_block, v__ast__Type return_type) {
bool v__gen__c__Gen_or_block_defer_0 = false;
	string cvar_name = v__gen__c__c_name(var_name);
	string mr_styp = v__gen__c__Gen_base_type(g, return_type);
	bool is_none_ok = string_eq(mr_styp, _SLIT("void"));
	v__gen__c__Gen_writeln(g, _SLIT(";"));
	if (is_none_ok) {
		v__gen__c__Gen_writeln(g, _STR("if (%.*s\000.state != 0 && %.*s\000.err._typ != _IError_None___index) {", 3, cvar_name, cvar_name));
	} else {
		v__gen__c__Gen_writeln(g, _STR("if (%.*s\000.state != 0) { /*or block*/ ", 2, cvar_name));
	}
	if (or_block.kind == v__ast__OrKind_block) {
		if (g->inside_or_block) {
			v__gen__c__Gen_writeln(g, _STR("\terr = %.*s\000.err;", 2, cvar_name));
		} else {
			v__gen__c__Gen_writeln(g, _STR("\tIError err = %.*s\000.err;", 2, cvar_name));
		}
		g->inside_or_block = true;
		v__gen__c__Gen_or_block_defer_0 = true;
		Array_v__ast__Stmt stmts = or_block.stmts;
		if (stmts.len > 0 && ((*(v__ast__Stmt*)/*ee elem_typ */array_get(stmts, or_block.stmts.len - 1)))._typ == 293 /* v.ast.ExprStmt */ && !v__ast__Type_alias_eq((/* as */ *(v__ast__ExprStmt*)__as_cast(((*(v__ast__Stmt*)/*ee elem_typ */array_get(stmts, stmts.len - 1)))._v__ast__ExprStmt,((*(v__ast__Stmt*)/*ee elem_typ */array_get(stmts, stmts.len - 1)))._typ, 293) /*expected idx: 293, name: v.ast.ExprStmt */ ).typ, _const_v__ast__void_type)) {
			g->indent++;
			// FOR IN array
			for (int i = 0; i < stmts.len; ++i) {
				v__ast__Stmt stmt = ((v__ast__Stmt*)stmts.data)[i];
				if (i == stmts.len - 1) {
					v__ast__ExprStmt expr_stmt = /* as */ *(v__ast__ExprStmt*)__as_cast((stmt)._v__ast__ExprStmt,(stmt)._typ, 293) /*expected idx: 293, name: v.ast.ExprStmt */ ;
					array_push(&g->stmt_path_pos, _MOV((int[]){ g->out.len }));
					v__gen__c__Gen_write(g, _STR("*(%.*s\000*) %.*s\000.data = ", 3, mr_styp, cvar_name));
					bool old_inside_opt_data = g->inside_opt_data;
					g->inside_opt_data = true;
					v__gen__c__Gen_expr_with_cast(g, expr_stmt.expr, expr_stmt.typ, v__ast__Type_clear_flag(return_type, v__ast__TypeFlag_optional));
					g->inside_opt_data = old_inside_opt_data;
					if (g->inside_ternary == 0 && !((expr_stmt.expr)._typ == 255 /* v.ast.IfExpr */)) {
						v__gen__c__Gen_writeln(g, _SLIT(";"));
					}
					array_delete_last(&g->stmt_path_pos);
				} else {
					v__gen__c__Gen_stmt(g, stmt);
				}
			}
			g->indent--;
		} else {
			v__gen__c__Gen_stmts(g, stmts);
		}
	} else if (or_block.kind == v__ast__OrKind_propagate) {
		if (string_eq(g->file.mod.name, _SLIT("main")) && (isnil(g->fn_decl) || g->fn_decl->is_main)) {
			if (g->pref->is_debug) {
				multi_return_int_string_string_string mr_163958 = v__gen__c__Gen_panic_debug_info(g, or_block.pos);
				int paline = mr_163958.arg0;
				string pafile = mr_163958.arg1;
				string pamod = mr_163958.arg2;
				string pafn = mr_163958.arg3;
				v__gen__c__Gen_writeln(g, _STR("panic_debug(%"PRId32"\000, tos3(\"%.*s\000\"), tos3(\"%.*s\000\"), tos3(\"%.*s\000\"), *%.*s\000.err.msg );", 6, paline, pafile, pamod, pafn, cvar_name));
			} else {
				v__gen__c__Gen_writeln(g, _STR("\tpanic_optional_not_set(*%.*s\000.err.msg);", 2, cvar_name));
			}
		} else if (!isnil(g->fn_decl) && g->fn_decl->is_test) {
			v__gen__c__Gen_gen_failing_error_propagation_for_test_fn(g, or_block, cvar_name);
		} else {
			v__gen__c__Gen_write_defer_stmts(g);
			if (v__ast__Type_alias_eq(g->fn_decl->return_type, _const_v__ast__void_type)) {
				v__gen__c__Gen_writeln(g, _SLIT("\treturn;"));
			} else {
				string styp = v__gen__c__Gen_typ(g, g->fn_decl->return_type);
				string err_obj = v__gen__c__Gen_new_tmp_var(g);
				v__gen__c__Gen_writeln(g, _STR("\t%.*s\000 %.*s\000;", 3, styp, err_obj));
				v__gen__c__Gen_writeln(g, _STR("\tmemcpy(&%.*s\000, &%.*s\000, sizeof(Option));", 3, err_obj, cvar_name));
				v__gen__c__Gen_writeln(g, _STR("\treturn %.*s\000;", 2, err_obj));
			}
		}
	}
	v__gen__c__Gen_write(g, _SLIT("}"));
// Defer begin
if (v__gen__c__Gen_or_block_defer_0 == true) {
	g->inside_or_block = false;
}
// Defer end
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_in_optimization(v__gen__c__Gen* g, v__ast__Expr left, v__ast__ArrayInit right) {
	bool is_str = v__ast__Type_alias_eq(right.elem_type, _const_v__ast__string_type);
	v__ast__TypeSymbol* elem_sym = v__ast__Table_get_type_symbol(g->table, right.elem_type);
	bool is_array = elem_sym->kind == v__ast__Kind_array;
	// FOR IN array
	for (int i = 0; i < right.exprs.len; ++i) {
		v__ast__Expr array_expr = ((v__ast__Expr*)right.exprs.data)[i];
		if (is_str) {
			v__gen__c__Gen_write(g, _SLIT("string_eq("));
		} else if (is_array) {
			string ptr_typ = v__gen__c__Gen_gen_array_equality_fn(g, right.elem_type);
			v__gen__c__Gen_write(g, _STR("%.*s\000_arr_eq(", 2, ptr_typ));
		}
		v__gen__c__Gen_expr(g, left);
		if (is_str || is_array) {
			v__gen__c__Gen_write(g, _SLIT(", "));
		} else {
			v__gen__c__Gen_write(g, _SLIT(" == "));
		}
		v__gen__c__Gen_expr(g, array_expr);
		if (is_str || is_array) {
			v__gen__c__Gen_write(g, _SLIT(")"));
		}
		if (i < right.exprs.len - 1) {
			v__gen__c__Gen_write(g, _SLIT(" || "));
		}
	}
}

VV_LOCAL_SYMBOL string v__gen__c__op_to_fn_name(string name) {
	 string _t2993 = ((string_eq(name, _SLIT("+"))) ? (_SLIT("_op_plus")) : (string_eq(name, _SLIT("-"))) ? (_SLIT("_op_minus")) : (string_eq(name, _SLIT("*"))) ? (_SLIT("_op_mul")) : (string_eq(name, _SLIT("/"))) ? (_SLIT("_op_div")) : (string_eq(name, _SLIT("%"))) ? (_SLIT("_op_mod")) : (string_eq(name, _SLIT("<"))) ? (_SLIT("_op_lt")) : (string_eq(name, _SLIT(">"))) ? (_SLIT("_op_gt")) : (_STR("bad op %.*s", 1, name)));
	// autofree_scope_vars(pos=165625 line_nr=5718 scope.pos=165589 scope.end_pos=165816)
	// var "name" var.pos=165603 var.line_nr=5717
	// af parent scope:
	// af parent scope:
	return _t2993;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL string v__gen__c__c_name(string name_) {
	string name = v__util__no_dots(name_);
	if ((Array_string_contains(_const_v__gen__c__c_reserved, name))) {
		 string _t2994 = _STR("v_%.*s", 1, name);
		// autofree_scope_vars(pos=165918 line_nr=5734 scope.pos=165915 scope.end_pos=165937)
		// af parent scope:
		// var "name_" var.pos=165838 var.line_nr=5731
		// var "name" var.pos=165862 var.line_nr=5732
		// af parent scope:
		// af parent scope:
		return _t2994;
	}
	// autofree_scope_vars(pos=165939 line_nr=5736 scope.pos=165831 scope.end_pos=165952)
	// var "name_" var.pos=165838 var.line_nr=5731
	// var "name" var.pos=165862 var.line_nr=5732
	// af parent scope:
	// af parent scope:
	return name;
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_type_default(v__gen__c__Gen* g, v__ast__Type typ_) {
	v__ast__Type typ = v__gen__c__Gen_unwrap_generic(g, typ_);
	if (v__ast__Type_has_flag(typ, v__ast__TypeFlag_optional)) {
		 string _t2995 = _SLIT("{0}");
		// autofree_scope_vars(pos=166069 line_nr=5742 scope.pos=166066 scope.end_pos=166084)
		// af parent scope:
		// var "g" var.pos=165963 var.line_nr=5739
		// var "typ_" var.pos=165983 var.line_nr=5739
		// var "typ" var.pos=166008 var.line_nr=5740
		// var "sym" var.pos=166179 var.line_nr=5748
		// var "idx" var.pos=168328 var.line_nr=5812
		// af parent scope:
		// af parent scope:
		return _t2995;
	}
	if (v__ast__Type_is_ptr(typ) && !v__ast__Type_has_flag(typ, v__ast__TypeFlag_shared_f)) {
		 string _t2996 = _SLIT("0");
		// autofree_scope_vars(pos=166163 line_nr=5746 scope.pos=166160 scope.end_pos=166176)
		// af parent scope:
		// var "g" var.pos=165963 var.line_nr=5739
		// var "typ_" var.pos=165983 var.line_nr=5739
		// var "typ" var.pos=166008 var.line_nr=5740
		// var "sym" var.pos=166179 var.line_nr=5748
		// var "idx" var.pos=168328 var.line_nr=5812
		// af parent scope:
		// af parent scope:
		return _t2996;
	}
	v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, typ);
	if (sym->kind == v__ast__Kind_array) {
		v__ast__Type elem_typ = v__ast__TypeSymbol_array_info(sym).elem_type;
		string elem_sym = v__gen__c__Gen_typ(g, elem_typ);
		string elem_type_str = v__util__no_dots(elem_sym);
		if (string_starts_with(elem_type_str, _SLIT("C__"))) {
			elem_type_str = string_substr(elem_type_str, 3, elem_type_str.len);
		}
		string init_str = _STR("__new_array(0, 1, sizeof(%.*s\000))", 2, elem_type_str);
		if (v__ast__Type_has_flag(typ, v__ast__TypeFlag_shared_f)) {
			string atyp = _STR("__shared__Array_%.*s", 1, v__ast__Table_get_type_symbol(g->table, elem_typ)->cname);
			 string _t2997 = _STR("(%.*s\000*)__dup_shared_array(&(%.*s\000){.val = %.*s\000}, sizeof(%.*s\000))", 5, atyp, atyp, init_str, atyp);
			// autofree_scope_vars(pos=166602 line_nr=5759 scope.pos=166526 scope.end_pos=166684)
			// var "atyp" var.pos=166531 var.line_nr=5758
			// af parent scope:
			// var "elem_typ" var.pos=166242 var.line_nr=5750
			// var "elem_sym" var.pos=166283 var.line_nr=5751
			// var "elem_type_str" var.pos=166317 var.line_nr=5752
			// var "init_str" var.pos=166441 var.line_nr=5756
			// af parent scope:
			// var "g" var.pos=165963 var.line_nr=5739
			// var "typ_" var.pos=165983 var.line_nr=5739
			// var "typ" var.pos=166008 var.line_nr=5740
			// var "sym" var.pos=166179 var.line_nr=5748
			// var "idx" var.pos=168328 var.line_nr=5812
			// af parent scope:
			// af parent scope:
			return _t2997;
		} else {
			// autofree_scope_vars(pos=166695 line_nr=5761 scope.pos=166691 scope.end_pos=166714)
			// af parent scope:
			// var "elem_typ" var.pos=166242 var.line_nr=5750
			// var "elem_sym" var.pos=166283 var.line_nr=5751
			// var "elem_type_str" var.pos=166317 var.line_nr=5752
			// var "init_str" var.pos=166441 var.line_nr=5756
			// af parent scope:
			// var "g" var.pos=165963 var.line_nr=5739
			// var "typ_" var.pos=165983 var.line_nr=5739
			// var "typ" var.pos=166008 var.line_nr=5740
			// var "sym" var.pos=166179 var.line_nr=5748
			// var "idx" var.pos=168328 var.line_nr=5812
			// af parent scope:
			// af parent scope:
			return init_str;
		}
	}
	if (sym->kind == v__ast__Kind_map) {
		v__ast__Map info = v__ast__TypeSymbol_map_info(sym);
		v__ast__TypeSymbol* key_typ = v__ast__Table_get_type_symbol(g->table, info.key_type);
		multi_return_string_string_string_string mr_166859 = v__gen__c__Gen_map_fn_ptrs(g, *key_typ);
		string hash_fn = mr_166859.arg0;
		string key_eq_fn = mr_166859.arg1;
		string clone_fn = mr_166859.arg2;
		string free_fn = mr_166859.arg3;
		string init_str = _STR("new_map(sizeof(%.*s\000), sizeof(%.*s\000), %.*s\000, %.*s\000, %.*s\000, %.*s\000)", 7, v__gen__c__Gen_typ(g, info.key_type), v__gen__c__Gen_typ(g, info.value_type), hash_fn, key_eq_fn, clone_fn, free_fn);
		if (v__ast__Type_has_flag(typ, v__ast__TypeFlag_shared_f)) {
			string mtyp = _STR("__shared__Map_%.*s\000_%.*s", 2, key_typ->cname, v__ast__Table_get_type_symbol(g->table, info.value_type)->cname);
			 string _t2998 = _STR("(%.*s\000*)__dup_shared_map(&(%.*s\000){.val = %.*s\000}, sizeof(%.*s\000))", 5, mtyp, mtyp, init_str, mtyp);
			// autofree_scope_vars(pos=167147 line_nr=5771 scope.pos=167049 scope.end_pos=167227)
			// var "mtyp" var.pos=167054 var.line_nr=5770
			// af parent scope:
			// var "info" var.pos=166744 var.line_nr=5765
			// var "key_typ" var.pos=166769 var.line_nr=5766
			// var "hash_fn" var.pos=166821 var.line_nr=5767
			// var "key_eq_fn" var.pos=166830 var.line_nr=5767
			// var "clone_fn" var.pos=166841 var.line_nr=5767
			// var "free_fn" var.pos=166851 var.line_nr=5767
			// var "init_str" var.pos=166887 var.line_nr=5768
			// af parent scope:
			// var "g" var.pos=165963 var.line_nr=5739
			// var "typ_" var.pos=165983 var.line_nr=5739
			// var "typ" var.pos=166008 var.line_nr=5740
			// var "sym" var.pos=166179 var.line_nr=5748
			// var "idx" var.pos=168328 var.line_nr=5812
			// af parent scope:
			// af parent scope:
			return _t2998;
		} else {
			// autofree_scope_vars(pos=167238 line_nr=5773 scope.pos=167234 scope.end_pos=167257)
			// af parent scope:
			// var "info" var.pos=166744 var.line_nr=5765
			// var "key_typ" var.pos=166769 var.line_nr=5766
			// var "hash_fn" var.pos=166821 var.line_nr=5767
			// var "key_eq_fn" var.pos=166830 var.line_nr=5767
			// var "clone_fn" var.pos=166841 var.line_nr=5767
			// var "free_fn" var.pos=166851 var.line_nr=5767
			// var "init_str" var.pos=166887 var.line_nr=5768
			// af parent scope:
			// var "g" var.pos=165963 var.line_nr=5739
			// var "typ_" var.pos=165983 var.line_nr=5739
			// var "typ" var.pos=166008 var.line_nr=5740
			// var "sym" var.pos=166179 var.line_nr=5748
			// var "idx" var.pos=168328 var.line_nr=5812
			// af parent scope:
			// af parent scope:
			return init_str;
		}
	}
	if (sym->kind == v__ast__Kind_struct_) {
		bool has_none_zero = false;
		string init_str = _SLIT("{");
		v__ast__Struct info = /* as */ *(v__ast__Struct*)__as_cast((sym->info)._v__ast__Struct,(sym->info)._typ, 409) /*expected idx: 409, name: v.ast.Struct */ ;
		// FOR IN array
		for (int _t2999 = 0; _t2999 < info.fields.len; ++_t2999) {
			v__ast__StructField field = ((v__ast__StructField*)info.fields.data)[_t2999];
			v__ast__TypeSymbol* field_sym = v__ast__Table_get_type_symbol(g->table, field.typ);
			if ((field_sym->kind == v__ast__Kind_array || field_sym->kind == v__ast__Kind_map) || field.has_default_expr) {
				if (field.has_default_expr) {
					string expr_str = v__gen__c__Gen_expr_string(g, field.default_expr);
					init_str = /*f*/string_add(init_str, _STR(".%.*s\000 = %.*s\000,", 3, field.name, expr_str));
				} else {
					init_str = /*f*/string_add(init_str, _STR(".%.*s\000 = %.*s\000,", 3, field.name, v__gen__c__Gen_type_default(g, field.typ)));
				}
				has_none_zero = true;
			}
		}
		if (has_none_zero) {
			init_str = /*f*/string_add(init_str, _SLIT("}"));
			string type_name = v__gen__c__Gen_typ(g, typ);
			init_str = string_add(_STR("(%.*s\000)", 2, type_name), init_str);
		} else {
			init_str = /*f*/string_add(init_str, _SLIT("0}"));
		}
		if (v__ast__Type_has_flag(typ, v__ast__TypeFlag_shared_f)) {
			string styp = _STR("__shared__%.*s", 1, v__ast__Table_get_type_symbol(g->table, typ)->cname);
			 string _t3000 = _STR("(%.*s\000*)__dup%.*s\000(&(%.*s\000){.val = %.*s\000}, sizeof(%.*s\000))", 6, styp, styp, styp, init_str, styp);
			// autofree_scope_vars(pos=168072 line_nr=5803 scope.pos=168007 scope.end_pos=168148)
			// var "styp" var.pos=168012 var.line_nr=5802
			// af parent scope:
			// var "has_none_zero" var.pos=167366 var.line_nr=5779
			// var "init_str" var.pos=167395 var.line_nr=5780
			// str literal
			// var "info" var.pos=167413 var.line_nr=5781
			// af parent scope:
			// var "g" var.pos=165963 var.line_nr=5739
			// var "typ_" var.pos=165983 var.line_nr=5739
			// var "typ" var.pos=166008 var.line_nr=5740
			// var "sym" var.pos=166179 var.line_nr=5748
			// var "idx" var.pos=168328 var.line_nr=5812
			// af parent scope:
			// af parent scope:
			return _t3000;
		} else {
			// autofree_scope_vars(pos=168159 line_nr=5805 scope.pos=168155 scope.end_pos=168178)
			// af parent scope:
			// var "has_none_zero" var.pos=167366 var.line_nr=5779
			// var "init_str" var.pos=167395 var.line_nr=5780
			// str literal
			// var "info" var.pos=167413 var.line_nr=5781
			// af parent scope:
			// var "g" var.pos=165963 var.line_nr=5739
			// var "typ_" var.pos=165983 var.line_nr=5739
			// var "typ" var.pos=166008 var.line_nr=5740
			// var "sym" var.pos=166179 var.line_nr=5748
			// var "idx" var.pos=168328 var.line_nr=5812
			// af parent scope:
			// af parent scope:
			return init_str;
		}
	}
	int idx = ((int)(typ));
	if (idx >= 1 && idx <= 17) {
		 string _t3001 = _SLIT("0");
		// autofree_scope_vars(pos=168373 line_nr=5814 scope.pos=168370 scope.end_pos=168386)
		// af parent scope:
		// var "g" var.pos=165963 var.line_nr=5739
		// var "typ_" var.pos=165983 var.line_nr=5739
		// var "typ" var.pos=166008 var.line_nr=5740
		// var "sym" var.pos=166179 var.line_nr=5748
		// var "idx" var.pos=168328 var.line_nr=5812
		// af parent scope:
		// af parent scope:
		return _t3001;
	}

	if (string_eq(sym->name, _SLIT("string"))) {
		 string _t3002 = _SLIT("(string){.str=(byteptr)\"\", .is_lit=1}");
		// autofree_scope_vars(pos=168492 line_nr=5825 scope.pos=168482 scope.end_pos=168540)
		// af parent scope:
		// var "g" var.pos=165963 var.line_nr=5739
		// var "typ_" var.pos=165983 var.line_nr=5739
		// var "typ" var.pos=166008 var.line_nr=5740
		// var "sym" var.pos=166179 var.line_nr=5748
		// var "idx" var.pos=168328 var.line_nr=5812
		// af parent scope:
		// af parent scope:
		return _t3002;
	}
	else if (string_eq(sym->name, _SLIT("rune"))) {
		 string _t3003 = _SLIT("0");
		// autofree_scope_vars(pos=168552 line_nr=5826 scope.pos=168544 scope.end_pos=168564)
		// af parent scope:
		// var "g" var.pos=165963 var.line_nr=5739
		// var "typ_" var.pos=165983 var.line_nr=5739
		// var "typ" var.pos=166008 var.line_nr=5740
		// var "sym" var.pos=166179 var.line_nr=5748
		// var "idx" var.pos=168328 var.line_nr=5812
		// af parent scope:
		// af parent scope:
		return _t3003;
	}
	else {
	};
	if (sym->kind == v__ast__Kind_chan) {
		string elemtypstr = v__gen__c__Gen_typ(g, v__ast__TypeSymbol_chan_info(sym).elem_type);
		 string _t3004 = _STR("sync__new_channel_st(0, sizeof(%.*s\000))", 2, elemtypstr);
		// autofree_scope_vars(pos=168653 line_nr=5831 scope.pos=168601 scope.end_pos=168709)
		// var "elemtypstr" var.pos=168605 var.line_nr=5830
		// af parent scope:
		// var "g" var.pos=165963 var.line_nr=5739
		// var "typ_" var.pos=165983 var.line_nr=5739
		// var "typ" var.pos=166008 var.line_nr=5740
		// var "sym" var.pos=166179 var.line_nr=5748
		// var "idx" var.pos=168328 var.line_nr=5812
		// af parent scope:
		// af parent scope:
		return _t3004;
	}
	string _t3006;
	
	if (sym->kind == (v__ast__Kind_interface_) || sym->kind == (v__ast__Kind_sum_type) || sym->kind == (v__ast__Kind_array_fixed) || sym->kind == (v__ast__Kind_multi_return)) {
		_t3006 = _SLIT("{0}");
	}
	else if (sym->kind == (v__ast__Kind_alias)) {
		_t3006 = v__gen__c__Gen_type_default(g, (/* as */ *(v__ast__Alias*)__as_cast((sym->info)._v__ast__Alias,(sym->info)._typ, 413) /*expected idx: 413, name: v.ast.Alias */ ).parent_type);
	}
	else {
		_t3006 = _SLIT("0");
	}	 string _t3005 = _t3006;
	// autofree_scope_vars(pos=168711 line_nr=5833 scope.pos=165958 scope.end_pos=169209)
	// var "g" var.pos=165963 var.line_nr=5739
	// var "typ_" var.pos=165983 var.line_nr=5739
	// var "typ" var.pos=166008 var.line_nr=5740
	// var "sym" var.pos=166179 var.line_nr=5748
	// var "idx" var.pos=168328 var.line_nr=5812
	// af parent scope:
	// af parent scope:
	return _t3005;
}

VV_LOCAL_SYMBOL Array_string v__gen__c__Gen_get_all_test_function_names(v__gen__c__Gen* g) {
	Array_string tfuncs = __new_array_with_default(0, 0, sizeof(string), 0);
	string tsuite_begin = _SLIT("");
	string tsuite_end = _SLIT("");
	// FOR IN map
	Map_string_v__ast__Fn _t3007 = g->table->fns;
	int _t3009 = _t3007.key_values.len;
	for (int _t3008 = 0; _t3008 < _t3009; ++_t3008 ) {
		int _t3010 = _t3007.key_values.len - _t3009;
		_t3009 = _t3007.key_values.len;
		if (_t3010 < 0) {
			_t3008 = -1;
			continue;
		}
		if (!DenseArray_has_index(&_t3007.key_values, _t3008)) {continue;}
		v__ast__Fn f = (*(v__ast__Fn*)DenseArray_value(&_t3007.key_values, _t3008));
		if (string_ends_with(f.name, _SLIT(".testsuite_begin"))) {
			tsuite_begin = f.name;
			continue;
		}
		if (string_contains(f.name, _SLIT(".test_"))) {
			array_push(&tfuncs, _MOV((string[]){ string_clone(f.name) }));
			continue;
		}
		if (string_ends_with(f.name, _SLIT(".testsuite_end"))) {
			tsuite_end = f.name;
			continue;
		}
	}
	Array_string all_tfuncs = __new_array_with_default(0, 0, sizeof(string), 0);
	if (tsuite_begin.len > 0) {
		array_push(&all_tfuncs, _MOV((string[]){ string_clone(tsuite_begin) }));
	}
	_PUSH_MANY(&all_tfuncs, (tfuncs), _t3013, Array_string);
	if (tsuite_end.len > 0) {
		array_push(&all_tfuncs, _MOV((string[]){ string_clone(tsuite_end) }));
	}
	// autofree_scope_vars(pos=169768 line_nr=5878 scope.pos=169215 scope.end_pos=169787)
	// var "g" var.pos=169216 var.line_nr=5852
	// var "tfuncs" var.pos=169270 var.line_nr=5853
	// var "tsuite_begin" var.pos=169296 var.line_nr=5854
	// str literal
	// var "tsuite_end" var.pos=169320 var.line_nr=5855
	// str literal
	// var "all_tfuncs" var.pos=169607 var.line_nr=5870
	// af parent scope:
	// af parent scope:
	return all_tfuncs;
}

VV_LOCAL_SYMBOL bool v__gen__c__Gen_is_importing_os(v__gen__c__Gen* g) {
	 bool _t3015 = (Array_string_contains(g->table->imports, _SLIT("os")));
	// autofree_scope_vars(pos=169827 line_nr=5882 scope.pos=169793 scope.end_pos=169859)
	// var "g" var.pos=169794 var.line_nr=5881
	// af parent scope:
	// af parent scope:
	return _t3015;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_go_expr(v__gen__c__Gen* g, v__ast__GoExpr node) {
	string line = v__gen__c__Gen_go_before_stmt(g, 0);
	string handle = v__gen__c__Gen_go_stmt(g, node.go_stmt, true);
	g->empty_line = false;
	v__gen__c__Gen_write(g, line);
	v__gen__c__Gen_write(g, handle);
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_go_stmt(v__gen__c__Gen* g, v__ast__GoStmt node, bool joinable) {
	string handle = _SLIT("");
	string tmp = v__gen__c__Gen_new_tmp_var(g);
	v__ast__CallExpr expr = node.call_expr;
	string name = expr.name;
	// FOR IN array
	for (int i = 0; i < expr.generic_types.len; ++i) {
		v__ast__Type generic_type = ((v__ast__Type*)expr.generic_types.data)[i];
		if (!v__ast__Type_alias_eq(generic_type, _const_v__ast__void_type) && generic_type != 0) {
			if (i == 0) {
				name = /*f*/string_add(name, _SLIT("_T"));
			}
			name = /*f*/string_add(name, string_add(_SLIT("_"), v__gen__c__Gen_typ(g, generic_type)));
		}
	}
	if (expr.is_method) {
		v__ast__TypeSymbol* receiver_sym = v__ast__Table_get_type_symbol(g->table, expr.receiver_type);
		name = string_add(string_add(receiver_sym->name, _SLIT("_")), name);
	} else if ((expr.left)._typ == 233 /* v.ast.AnonFn */) {
		v__gen__c__Gen_gen_anon_fn_decl(g, (voidptr)&/*qq*/(*expr.left._v__ast__AnonFn));
		v__ast__TypeSymbol* fsym = v__ast__Table_get_type_symbol(g->table, (*expr.left._v__ast__AnonFn).typ);
		name = fsym->name;
	}
	name = v__util__no_dots(name);
	if (g->pref->obfuscate && string_eq(g->cur_mod.name, _SLIT("main")) && string_starts_with(name, _SLIT("main__"))) {
		string key = expr.name;
		if (expr.is_method) {
			v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, expr.receiver_type);
			key = string_add(string_add(sym->name, _SLIT(".")), expr.name);
		}
		v__gen__c__Gen_write(g, _STR("/* obf go: %.*s\000 */", 2, key));
		string* _t3017 = (string*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, g->obf_table), &(string[]){key}));
		Option_string _t3016 = {0};
		if (_t3017) {
			*((string*)&_t3016.data) = *((string*)_t3017);
		} else {
			_t3016.state = 2; _t3016.err = v_error(_SLIT("array index out of range"));
		}
		;
		if (_t3016.state != 0) { /*or block*/ 
			IError err = _t3016.err;
			v_panic(_STR("cgen: obf name \"%.*s\000\" not found, this should never happen", 2, key));
		}
		name = *(string*)_t3016.data;
	}
	v__gen__c__Gen_writeln(g, _SLIT("// go"));
	string wrapper_struct_name = string_add(_SLIT("thread_arg_"), name);
	string wrapper_fn_name = string_add(name, _SLIT("_thread_wrapper"));
	string arg_tmp_var = string_add(_SLIT("arg_"), tmp);
	v__gen__c__Gen_writeln(g, _STR("%.*s\000 *%.*s\000 = malloc(sizeof(thread_arg_%.*s\000));", 4, wrapper_struct_name, arg_tmp_var, name));
	if (expr.is_method) {
		v__gen__c__Gen_write(g, _STR("%.*s\000->arg0 = ", 2, arg_tmp_var));
		v__gen__c__Gen_expr(g, expr.left);
		v__gen__c__Gen_writeln(g, _SLIT(";"));
	}
	// FOR IN array
	for (int i = 0; i < expr.args.len; ++i) {
		v__ast__CallArg arg = ((v__ast__CallArg*)expr.args.data)[i];
		v__gen__c__Gen_write(g, _STR("%.*s\000->arg%"PRId32"\000 = ", 3, arg_tmp_var, i + 1));
		v__gen__c__Gen_expr(g, arg.expr);
		v__gen__c__Gen_writeln(g, _SLIT(";"));
	}
	string s_ret_typ = v__gen__c__Gen_typ(g, node.call_expr.return_type);
	if (g->pref->os == v__pref__OS_windows && !v__ast__Type_alias_eq(node.call_expr.return_type, _const_v__ast__void_type)) {
		v__gen__c__Gen_writeln(g, _STR("%.*s\000->ret_ptr = malloc(sizeof(%.*s\000));", 3, arg_tmp_var, s_ret_typ));
	}
	bool is_opt = v__ast__Type_has_flag(node.call_expr.return_type, v__ast__TypeFlag_optional);
	string gohandle_name = _SLIT("");
	if (v__ast__Type_alias_eq(node.call_expr.return_type, _const_v__ast__void_type)) {
		gohandle_name = (is_opt ? (_SLIT("__v_thread_Option_void")) : (_SLIT("__v_thread")));
	} else {
		string opt = (is_opt ? (_SLIT("Option_")) : (_SLIT("")));
		gohandle_name = _STR("__v_thread_%.*s\000%.*s", 2, opt, v__ast__Table_get_type_symbol(g->table, v__gen__c__Gen_unwrap_generic(g, node.call_expr.return_type))->cname);
	}
	if (g->pref->os == v__pref__OS_windows) {
		string simple_handle = (joinable && !v__ast__Type_alias_eq(node.call_expr.return_type, _const_v__ast__void_type) ? (_STR("thread_handle_%.*s", 1, tmp)) : (_STR("thread_%.*s", 1, tmp)));
		v__gen__c__Gen_writeln(g, _STR("HANDLE %.*s\000 = CreateThread(0,0, (LPTHREAD_START_ROUTINE)%.*s\000, %.*s\000, 0,0);", 4, simple_handle, wrapper_fn_name, arg_tmp_var));
		if (joinable && !v__ast__Type_alias_eq(node.call_expr.return_type, _const_v__ast__void_type)) {
			v__gen__c__Gen_writeln(g, _STR("%.*s\000 thread_%.*s\000 = {", 3, gohandle_name, tmp));
			v__gen__c__Gen_writeln(g, _STR("\t.ret_ptr = %.*s\000->ret_ptr,", 2, arg_tmp_var));
			v__gen__c__Gen_writeln(g, _STR("\t.handle = thread_handle_%.*s", 1, tmp));
			v__gen__c__Gen_writeln(g, _SLIT("};"));
		}
		if (!joinable) {
			v__gen__c__Gen_writeln(g, _STR("CloseHandle(thread_%.*s\000);", 2, tmp));
		}
	} else {
		v__gen__c__Gen_writeln(g, _STR("pthread_t thread_%.*s\000;", 2, tmp));
		v__gen__c__Gen_writeln(g, _STR("pthread_create(&thread_%.*s\000, NULL, (void*)%.*s\000, %.*s\000);", 4, tmp, wrapper_fn_name, arg_tmp_var));
		if (!joinable) {
			v__gen__c__Gen_writeln(g, _STR("pthread_detach(thread_%.*s\000);", 2, tmp));
		}
	}
	v__gen__c__Gen_writeln(g, _SLIT("// endgo\n"));
	if (joinable) {
		handle = _STR("thread_%.*s", 1, tmp);
		string waiter_fn_name = string_add(gohandle_name, _SLIT("_wait"));
		if (!(Array_string_contains(g->waiter_fns, waiter_fn_name))) {
			strings__Builder_writeln(&g->gowrappers, _STR("\n%.*s\000 %.*s\000(%.*s\000 thread) {", 4, s_ret_typ, waiter_fn_name, gohandle_name));
			string c_ret_ptr_ptr = _SLIT("NULL");
			if (!v__ast__Type_alias_eq(node.call_expr.return_type, _const_v__ast__void_type)) {
				strings__Builder_writeln(&g->gowrappers, _STR("\t%.*s\000* ret_ptr;", 2, s_ret_typ));
				c_ret_ptr_ptr = _SLIT("&ret_ptr");
			}
			if (g->pref->os == v__pref__OS_windows) {
				if (v__ast__Type_alias_eq(node.call_expr.return_type, _const_v__ast__void_type)) {
					strings__Builder_writeln(&g->gowrappers, _SLIT("\tu32 stat = WaitForSingleObject(thread, INFINITE);"));
				} else {
					strings__Builder_writeln(&g->gowrappers, _SLIT("\tu32 stat = WaitForSingleObject(thread.handle, INFINITE);"));
					strings__Builder_writeln(&g->gowrappers, _SLIT("\tret_ptr = thread.ret_ptr;"));
				}
			} else {
				strings__Builder_writeln(&g->gowrappers, _STR("\tint stat = pthread_join(thread, (void **)%.*s\000);", 2, c_ret_ptr_ptr));
			}
			strings__Builder_writeln(&g->gowrappers, _SLIT("\tif (stat != 0) { v_panic(_SLIT(\"unable to join thread\")); }"));
			if (g->pref->os == v__pref__OS_windows) {
				if (v__ast__Type_alias_eq(node.call_expr.return_type, _const_v__ast__void_type)) {
					strings__Builder_writeln(&g->gowrappers, _SLIT("\tCloseHandle(thread);"));
				} else {
					strings__Builder_writeln(&g->gowrappers, _SLIT("\tCloseHandle(thread.handle);"));
				}
			}
			if (!v__ast__Type_alias_eq(node.call_expr.return_type, _const_v__ast__void_type)) {
				strings__Builder_writeln(&g->gowrappers, _STR("\t%.*s\000 ret = *ret_ptr;", 2, s_ret_typ));
				strings__Builder_writeln(&g->gowrappers, _SLIT("\tfree(ret_ptr);"));
				strings__Builder_writeln(&g->gowrappers, _SLIT("\treturn ret;"));
			} else {
				strings__Builder_writeln(&g->gowrappers, _SLIT("\treturn;"));
			}
			strings__Builder_writeln(&g->gowrappers, _SLIT("}"));
			array_push(&g->waiter_fns, _MOV((string[]){ string_clone(waiter_fn_name) }));
		}
	}
	if ((Array_string_contains(g->threaded_fns, name))) {
		// autofree_scope_vars(pos=174701 line_nr=6028 scope.pos=174698 scope.end_pos=174717)
		// af parent scope:
		// var "g" var.pos=170039 var.line_nr=5893
		// var "node" var.pos=170054 var.line_nr=5893
		// var "joinable" var.pos=170071 var.line_nr=5893
		// var "handle" var.pos=170100 var.line_nr=5894
		// str literal
		// var "tmp" var.pos=170114 var.line_nr=5895
		// var "expr" var.pos=170142 var.line_nr=5896
		// var "name" var.pos=170170 var.line_nr=5897
		// var "wrapper_struct_name" var.pos=171237 var.line_nr=5930
		// var "wrapper_fn_name" var.pos=171282 var.line_nr=5931
		// var "arg_tmp_var" var.pos=171327 var.line_nr=5932
		// var "s_ret_typ" var.pos=171744 var.line_nr=5950
		// var "is_opt" var.pos=171937 var.line_nr=5954
		// var "gohandle_name" var.pos=171999 var.line_nr=5955
		// str literal
		// var "need_return_ptr" var.pos=174897 var.line_nr=6035
		// var "thread_ret_type" var.pos=175343 var.line_nr=6048
		// af parent scope:
		// af parent scope:
		return handle;
	}
	strings__Builder_writeln(&g->type_definitions, _STR("\ntypedef struct %.*s\000 {", 2, wrapper_struct_name));
	if (expr.is_method) {
		string styp = v__gen__c__Gen_typ(g, expr.receiver_type);
		strings__Builder_writeln(&g->type_definitions, _STR("\t%.*s\000 arg0;", 2, styp));
	}
	bool need_return_ptr = g->pref->os == v__pref__OS_windows && !v__ast__Type_alias_eq(node.call_expr.return_type, _const_v__ast__void_type);
	if (expr.args.len == 0 && !need_return_ptr) {
		strings__Builder_writeln(&g->type_definitions, _SLIT("EMPTY_STRUCT_DECLARATION;"));
	} else {
		// FOR IN array
		for (int i = 0; i < expr.args.len; ++i) {
			v__ast__CallArg arg = ((v__ast__CallArg*)expr.args.data)[i];
			string styp = v__gen__c__Gen_typ(g, arg.typ);
			strings__Builder_writeln(&g->type_definitions, _STR("\t%.*s\000 arg%"PRId32"\000;", 3, styp, i + 1));
		}
	}
	if (need_return_ptr) {
		strings__Builder_writeln(&g->type_definitions, _SLIT("\tvoid* ret_ptr;"));
	}
	strings__Builder_writeln(&g->type_definitions, _STR("} %.*s\000;", 2, wrapper_struct_name));
	string thread_ret_type = (g->pref->os == v__pref__OS_windows ? (_SLIT("u32")) : (_SLIT("void*")));
	strings__Builder_writeln(&g->type_definitions, _STR("%.*s\000 %.*s\000(%.*s\000 *arg);", 4, thread_ret_type, wrapper_fn_name, wrapper_struct_name));
	strings__Builder_writeln(&g->gowrappers, _STR("%.*s\000 %.*s\000(%.*s\000 *arg) {", 4, thread_ret_type, wrapper_fn_name, wrapper_struct_name));
	if (!v__ast__Type_alias_eq(node.call_expr.return_type, _const_v__ast__void_type)) {
		if (g->pref->os == v__pref__OS_windows) {
			strings__Builder_write_string(&g->gowrappers, _STR("\t*((%.*s\000*)(arg->ret_ptr)) = ", 2, s_ret_typ));
		} else {
			strings__Builder_writeln(&g->gowrappers, _STR("\t%.*s\000* ret_ptr = malloc(sizeof(%.*s\000));", 3, s_ret_typ, s_ret_typ));
			strings__Builder_write_string(&g->gowrappers, _SLIT("\t*ret_ptr = "));
		}
	} else {
		strings__Builder_write_string(&g->gowrappers, _SLIT("\t"));
	}
	strings__Builder_write_string(&g->gowrappers, _STR("%.*s\000(", 2, name));
	if (expr.is_method) {
		strings__Builder_write_string(&g->gowrappers, _SLIT("arg->arg0"));
		if (expr.args.len > 0) {
			strings__Builder_write_string(&g->gowrappers, _SLIT(", "));
		}
	}
	for (int i = 0; i < expr.args.len; ++i) {
		strings__Builder_write_string(&g->gowrappers, _STR("arg->arg%"PRId32"", 1, i + 1));
		if (i < expr.args.len - 1) {
			strings__Builder_write_string(&g->gowrappers, _SLIT(", "));
		}
	}
	strings__Builder_writeln(&g->gowrappers, _SLIT(");"));
	strings__Builder_writeln(&g->gowrappers, _SLIT("\tfree(arg);"));
	if (g->pref->os != v__pref__OS_windows && !v__ast__Type_alias_eq(node.call_expr.return_type, _const_v__ast__void_type)) {
		strings__Builder_writeln(&g->gowrappers, _SLIT("\treturn ret_ptr;"));
	} else {
		strings__Builder_writeln(&g->gowrappers, _SLIT("\treturn 0;"));
	}
	strings__Builder_writeln(&g->gowrappers, _SLIT("}"));
	array_push(&g->threaded_fns, _MOV((string[]){ string_clone(name) }));
	// autofree_scope_vars(pos=176538 line_nr=6083 scope.pos=170034 scope.end_pos=176553)
	// var "g" var.pos=170039 var.line_nr=5893
	// var "node" var.pos=170054 var.line_nr=5893
	// var "joinable" var.pos=170071 var.line_nr=5893
	// var "handle" var.pos=170100 var.line_nr=5894
	// str literal
	// var "tmp" var.pos=170114 var.line_nr=5895
	// var "expr" var.pos=170142 var.line_nr=5896
	// var "name" var.pos=170170 var.line_nr=5897
	// var "wrapper_struct_name" var.pos=171237 var.line_nr=5930
	// var "wrapper_fn_name" var.pos=171282 var.line_nr=5931
	// var "arg_tmp_var" var.pos=171327 var.line_nr=5932
	// var "s_ret_typ" var.pos=171744 var.line_nr=5950
	// var "is_opt" var.pos=171937 var.line_nr=5954
	// var "gohandle_name" var.pos=171999 var.line_nr=5955
	// str literal
	// var "need_return_ptr" var.pos=174897 var.line_nr=6035
	// var "thread_ret_type" var.pos=175343 var.line_nr=6048
	// af parent scope:
	// af parent scope:
	return handle;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_as_cast(v__gen__c__Gen* g, v__ast__AsCast node) {
	string styp = v__gen__c__Gen_typ(g, node.typ);
	v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, node.typ);
	v__ast__TypeSymbol* expr_type_sym = v__ast__Table_get_type_symbol(g->table, node.expr_type);
	if ((expr_type_sym->info)._typ == 411 /* v.ast.SumType */) {
		string dot = (v__ast__Type_is_ptr(node.expr_type) ? (_SLIT("->")) : (_SLIT(".")));
		v__gen__c__Gen_write(g, _STR("/* as */ *(%.*s\000*)__as_cast(", 2, styp));
		v__gen__c__Gen_write(g, _SLIT("("));
		v__gen__c__Gen_expr(g, node.expr);
		v__gen__c__Gen_write(g, _SLIT(")"));
		v__gen__c__Gen_write(g, dot);
		v__gen__c__Gen_write(g, _STR("_%.*s\000,", 2, sym->cname));
		v__gen__c__Gen_write(g, _SLIT("("));
		v__gen__c__Gen_expr(g, node.expr);
		v__gen__c__Gen_write(g, _SLIT(")"));
		v__gen__c__Gen_write(g, dot);
		string sidx = v__gen__c__Gen_type_sidx(g, node.typ);
		v__ast__TypeSymbol* expected_sym = v__ast__Table_get_type_symbol(g->table, node.typ);
		v__gen__c__Gen_write(g, _STR("_typ, %.*s\000) /*expected idx: %.*s\000, name: %.*s\000 */ ", 4, sidx, sidx, expected_sym->name));
		// FOR IN array
		for (int _t3020 = 0; _t3020 < (*expr_type_sym->info._v__ast__SumType).variants.len; ++_t3020) {
			v__ast__Type variant = ((v__ast__Type*)(*expr_type_sym->info._v__ast__SumType).variants.data)[_t3020];
			string idx = int_str(variant);
			if (_IN_MAP(ADDR(string, idx), ADDR(map, g->as_cast_type_names))) {
				continue;
			}
			v__ast__TypeSymbol* variant_sym = v__ast__Table_get_type_symbol(g->table, variant);
			map_set(&g->as_cast_type_names, &(string[]){idx}, &(string[]) { variant_sym->name });
		}
	}
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_as_cast_name_table(v__gen__c__Gen* g) {
	if (g->as_cast_type_names.len == 0) {
		 string _t3021 = _SLIT("new_array_from_c_array(1, 1, sizeof(VCastTypeIndexName), _MOV((VCastTypeIndexName[1]){(VCastTypeIndexName){.tindex = 0,.tname = _SLIT(\"unknown\")}}));");
		// autofree_scope_vars(pos=177689 line_nr=6124 scope.pos=177686 scope.end_pos=177850)
		// af parent scope:
		// var "g" var.pos=177615 var.line_nr=6122
		// var "name_ast" var.pos=177857 var.line_nr=6126
		// var "casts_len" var.pos=177896 var.line_nr=6127
		// af parent scope:
		// af parent scope:
		return _t3021;
	}
	strings__Builder name_ast = strings__new_builder(1024);
	int casts_len = g->as_cast_type_names.len + 1;
	strings__Builder_writeln(&name_ast, _STR("new_array_from_c_array(%"PRId32"\000, %"PRId32"\000, sizeof(VCastTypeIndexName), _MOV((VCastTypeIndexName[%"PRId32"\000]){", 4, casts_len, casts_len, casts_len));
	strings__Builder_writeln(&name_ast, _SLIT("\t\t  (VCastTypeIndexName){.tindex = 0, .tname = _SLIT(\"unknown\")}"));
	// FOR IN map
	Map_string_string _t3022 = g->as_cast_type_names;
	int _t3024 = _t3022.key_values.len;
	for (int _t3023 = 0; _t3023 < _t3024; ++_t3023 ) {
		int _t3025 = _t3022.key_values.len - _t3024;
		_t3024 = _t3022.key_values.len;
		if (_t3025 < 0) {
			_t3023 = -1;
			continue;
		}
		if (!DenseArray_has_index(&_t3022.key_values, _t3023)) {continue;}
		string key = /*key*/ *(string*)DenseArray_key(&_t3022.key_values, _t3023);
		key = string_clone(key);
		string value = (*(string*)DenseArray_value(&_t3022.key_values, _t3023));
		strings__Builder_writeln(&name_ast, _STR("\t\t, (VCastTypeIndexName){.tindex = %.*s\000, .tname = _SLIT(\"%.*s\000\")}", 3, key, value));
	}
	strings__Builder_writeln(&name_ast, _SLIT("\t}));"));
	 string _t3026 = strings__Builder_str(&name_ast);
	// autofree_scope_vars(pos=178325 line_nr=6134 scope.pos=177614 scope.end_pos=178348)
	// var "g" var.pos=177615 var.line_nr=6122
	// var "name_ast" var.pos=177857 var.line_nr=6126
	// var "casts_len" var.pos=177896 var.line_nr=6127
	// af parent scope:
	// af parent scope:
	return _t3026;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_is_expr(v__gen__c__Gen* g, v__ast__InfixExpr node) {
	string eq = (node.op == v__token__Kind_key_is ? (_SLIT("==")) : (_SLIT("!=")));
	v__gen__c__Gen_write(g, _SLIT("("));
	v__gen__c__Gen_expr(g, node.left);
	v__gen__c__Gen_write(g, _SLIT(")"));
	if (v__ast__Type_is_ptr(node.left_type)) {
		v__gen__c__Gen_write(g, _SLIT("->"));
	} else {
		v__gen__c__Gen_write(g, _SLIT("."));
	}
	v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, node.left_type);
	if (sym->kind == v__ast__Kind_interface_) {
		v__gen__c__Gen_write(g, _STR("_typ %.*s\000 ", 2, eq));
		v__ast__Type sub_type = ((node.right._typ == 279 /* v.ast.TypeNode */) ? ((*node.right._v__ast__TypeNode).typ) : (node.right._typ == 265 /* v.ast.None */) ? ((*(int*)map_get(ADDR(map, g->table->type_idxs), &(string[]){_SLIT("None__")}, &(int[]){ 0 }))) : (((v__ast__Type)(0))));
		v__ast__TypeSymbol* sub_sym = v__ast__Table_get_type_symbol(g->table, sub_type);
		v__gen__c__Gen_write(g, _STR("_%.*s\000_%.*s\000_index", 3, v__gen__c__c_name(sym->name), v__gen__c__c_name(sub_sym->name)));
		return;
	} else if (sym->kind == v__ast__Kind_sum_type) {
		v__gen__c__Gen_write(g, _STR("_typ %.*s\000 ", 2, eq));
	}
	v__gen__c__Gen_expr(g, node.right);
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_interface_table(v__gen__c__Gen* g) {
	strings__Builder sb = strings__new_builder(100);
	// FOR IN array
	for (int _t3027 = 0; _t3027 < g->table->type_symbols.len; ++_t3027) {
		v__ast__TypeSymbol ityp = ((v__ast__TypeSymbol*)g->table->type_symbols.data)[_t3027];
		if (ityp.kind != v__ast__Kind_interface_) {
			continue;
		}
		v__ast__Interface inter_info = /* as */ *(v__ast__Interface*)__as_cast((ityp.info)._v__ast__Interface,(ityp.info)._typ, 410) /*expected idx: 410, name: v.ast.Interface */ ;
		string interface_name = ityp.cname;
		string methods_struct_name = _STR("struct _%.*s\000_interface_methods", 2, interface_name);
		strings__Builder methods_typ_def = strings__new_builder(100);
		strings__Builder methods_struct_def = strings__new_builder(100);
		strings__Builder_writeln(&methods_struct_def, _STR("%.*s\000 {", 2, methods_struct_name));
		Map_string_string imethods = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
		Map_string_int methodidx = new_map(sizeof(string), sizeof(int), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
		// FOR IN array
		for (int k = 0; k < inter_info.methods.len; ++k) {
			v__ast__Fn method = ((v__ast__Fn*)inter_info.methods.data)[k];
			map_set(&methodidx, &(string[]){method.name}, &(int[]) { k });
			string typ_name = _STR("_%.*s\000_%.*s\000_fn", 3, interface_name, method.name);
			string ret_styp = v__gen__c__Gen_typ(g, method.return_type);
			strings__Builder_write_string(&methods_typ_def, _STR("typedef %.*s\000 (*%.*s\000)(void* _", 3, ret_styp, typ_name));
			for (int i = 1; i < method.params.len; ++i) {
				v__ast__Param arg = (*(v__ast__Param*)/*ee elem_typ */array_get(method.params, i));
				strings__Builder_write_string(&methods_typ_def, _STR(", %.*s\000 %.*s", 2, v__gen__c__Gen_typ(g, arg.typ), arg.name));
			}
			strings__Builder_writeln(&methods_typ_def, _SLIT(");"));
			strings__Builder_writeln(&methods_struct_def, _STR("\t%.*s\000 _method_%.*s\000;", 3, typ_name, v__gen__c__c_name(method.name)));
			map_set(&imethods, &(string[]){method.name}, &(string[]) { typ_name });
		}
		strings__Builder_writeln(&methods_struct_def, _SLIT("};"));
		strings__Builder methods_struct = strings__new_builder(100);
		string staticprefix = _SLIT("static");
		int iname_table_length = inter_info.types.len;
		if (iname_table_length == 0) {
			strings__Builder_writeln(&methods_struct, _STR("%.*s\000 %.*s\000_name_table[1];", 3, methods_struct_name, interface_name));
		} else {
			if (g->pref->build_mode != v__pref__BuildMode_build_module) {
				strings__Builder_writeln(&methods_struct, _STR("%.*s\000 %.*s\000_name_table[%"PRId32"\000] = {", 4, methods_struct_name, interface_name, iname_table_length));
			} else {
				strings__Builder_writeln(&methods_struct, _STR("%.*s\000 %.*s\000_name_table[%"PRId32"\000];", 4, methods_struct_name, interface_name, iname_table_length));
			}
		}
		strings__Builder cast_functions = strings__new_builder(100);
		strings__Builder methods_wrapper = strings__new_builder(100);
		strings__Builder_writeln(&methods_wrapper, _STR("// Methods wrapper for interface \"%.*s\000\"", 2, interface_name));
		Map_string_int already_generated_mwrappers = new_map(sizeof(string), sizeof(int), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
		int iinidx_minimum_base = 1000;
		int current_iinidx = iinidx_minimum_base;
		// FOR IN array
		for (int _t3028 = 0; _t3028 < inter_info.types.len; ++_t3028) {
			v__ast__Type st = ((v__ast__Type*)inter_info.types.data)[_t3028];
			v__ast__TypeSymbol* st_sym = v__ast__Table_get_type_symbol(g->table, st);
			string cctype = v__gen__c__Gen_cc_type(g, st, true);
			string interface_index_name = _STR("_%.*s\000_%.*s\000_index", 3, interface_name, cctype);
			if ((*(int*)map_get(ADDR(map, already_generated_mwrappers), &(string[]){interface_index_name}, &(int[]){ 0 })) > 0) {
				continue;
			}
			map_set(&already_generated_mwrappers, &(string[]){interface_index_name}, &(int[]) { current_iinidx });
			current_iinidx++;
			strings__Builder_writeln(&sb, _STR("%.*s\000 %.*s\000 I_%.*s\000_to_Interface_%.*s\000(%.*s\000* x);", 6, staticprefix, interface_name, cctype, interface_name, cctype));
			strings__Builder cast_struct = strings__new_builder(100);
			strings__Builder_writeln(&cast_struct, _STR("(%.*s\000) {", 2, interface_name));
			strings__Builder_writeln(&cast_struct, _STR("\t\t._%.*s\000 = x,", 2, cctype));
			strings__Builder_writeln(&cast_struct, _STR("\t\t._typ = %.*s\000,", 2, interface_index_name));
			// FOR IN array
			for (int _t3029 = 0; _t3029 < inter_info.fields.len; ++_t3029) {
				v__ast__StructField field = ((v__ast__StructField*)inter_info.fields.data)[_t3029];
				string cname = v__gen__c__c_name(field.name);
				string field_styp = v__gen__c__Gen_typ(g, field.typ);
				Option_v__ast__StructField _t3030;
				if (_t3030 = v__ast__TypeSymbol_find_field(st_sym, field.name), _t3030.state == 0) {
					strings__Builder_writeln(&cast_struct, _STR("\t\t.%.*s\000 = (%.*s\000*)((char*)x + __offsetof_ptr(x, %.*s\000, %.*s\000)),", 5, cname, field_styp, cctype, cname));
				} else {
					IError err = _t3030.err;
					strings__Builder_write_string(&cast_struct, _STR("\t\t.%.*s\000 = (%.*s\000*)((char*)x", 3, cname, field_styp));
					// FOR IN array
					for (int _t3031 = 0; _t3031 < v__ast__TypeSymbol_struct_info(st_sym).embeds.len; ++_t3031) {
						v__ast__Type embed_type = ((v__ast__Type*)v__ast__TypeSymbol_struct_info(st_sym).embeds.data)[_t3031];
						v__ast__TypeSymbol* embed_sym = v__ast__Table_get_type_symbol(g->table, embed_type);
						Option_v__ast__StructField _t3032;
						if (_t3032 = v__ast__TypeSymbol_find_field(embed_sym, field.name), _t3032.state == 0) {
							strings__Builder_write_string(&cast_struct, _STR(" + __offsetof_ptr(x, %.*s\000, %.*s\000) + __offsetof_ptr(x, %.*s\000, %.*s\000)", 5, cctype, v__ast__TypeSymbol_embed_name(embed_sym), embed_sym->cname, cname));
							break;
						}
					}
					strings__Builder_writeln(&cast_struct, _SLIT("),"));
				}
			}
			strings__Builder_write_string(&cast_struct, _SLIT("\t}"));
			string cast_struct_str = strings__Builder_str(&cast_struct);
			strings__Builder_writeln(&cast_functions, _STR("\n// Casting functions for converting \"%.*s\000\" to interface \"%.*s\000\"\n%.*s\000 inline %.*s\000 I_%.*s\000_to_Interface_%.*s\000(%.*s\000* x) {\n	return %.*s\000;\n}", 9, cctype, interface_name, staticprefix, interface_name, cctype, interface_name, cctype, cast_struct_str));
			if (g->pref->build_mode != v__pref__BuildMode_build_module) {
				strings__Builder_writeln(&methods_struct, _SLIT("\t{"));
			}
			// FOR IN array
			for (int _t3033 = 0; _t3033 < st_sym->methods.len; ++_t3033) {
				v__ast__Fn method = ((v__ast__Fn*)st_sym->methods.data)[_t3033];
				if (!_IN_MAP(ADDR(string, method.name), ADDR(map, imethods))) {
					continue;
				}
				string method_call = _STR("%.*s\000_%.*s", 2, cctype, method.name);
				if (!v__ast__Type_is_ptr((*(v__ast__Param*)/*ee elem_typ */array_get(method.params, 0)).typ)) {
					strings__Builder_write_string(&methods_wrapper, _STR("static inline %.*s", 1, v__gen__c__Gen_typ(g, method.return_type)));
					strings__Builder_write_string(&methods_wrapper, _STR(" %.*s\000_method_wrapper(", 2, method_call));
					int params_start_pos = g->out.len;
					Array_v__ast__Param params = array_clone(&method.params);
					array_set(&params, 0, &(v__ast__Param[]) { (v__ast__Param){(*(v__ast__Param*)/*ee elem_typ */array_get(params, 0)).pos,(*(v__ast__Param*)/*ee elem_typ */array_get(params, 0)).name,(*(v__ast__Param*)/*ee elem_typ */array_get(params, 0)).is_mut,(*(v__ast__Param*)/*ee elem_typ */array_get(params, 0)).is_auto_rec,.typ = v__ast__Type_set_nr_muls((*(v__ast__Param*)/*ee elem_typ */array_get(params, 0)).typ, 1),(*(v__ast__Param*)/*ee elem_typ */array_get(params, 0)).type_pos,(*(v__ast__Param*)/*ee elem_typ */array_get(params, 0)).is_hidden,} });
					multi_return_Array_string_Array_string mr_184512 = v__gen__c__Gen_fn_args(g, params, false);
					Array_string fargs = mr_184512.arg0;
					strings__Builder_write_string(&methods_wrapper, strings__Builder_cut_last(&g->out, g->out.len - params_start_pos));
					strings__Builder_writeln(&methods_wrapper, _SLIT(") {"));
					strings__Builder_write_string(&methods_wrapper, _SLIT("\t"));
					if (!v__ast__Type_alias_eq(method.return_type, _const_v__ast__void_type)) {
						strings__Builder_write_string(&methods_wrapper, _SLIT("return "));
					}
					strings__Builder_writeln(&methods_wrapper, _STR("%.*s\000(*%.*s\000);", 3, method_call, Array_string_join(fargs, _SLIT(", "))));
					strings__Builder_writeln(&methods_wrapper, _SLIT("}"));
					method_call = /*f*/string_add(method_call, _SLIT("_method_wrapper"));
				}
				if (g->pref->build_mode != v__pref__BuildMode_build_module) {
					strings__Builder_writeln(&methods_struct, _STR("\t\t._method_%.*s\000 = (void*) %.*s\000,", 3, v__gen__c__c_name(method.name), method_call));
				}
			}
			if (g->pref->build_mode != v__pref__BuildMode_build_module) {
				strings__Builder_writeln(&methods_struct, _SLIT("\t},"));
			}
			int iin_idx = (*(int*)map_get(ADDR(map, already_generated_mwrappers), &(string[]){interface_index_name}, &(int[]){ 0 })) - iinidx_minimum_base;
			if (g->pref->build_mode != v__pref__BuildMode_build_module) {
				strings__Builder_writeln(&sb, _STR("int %.*s\000 = %"PRId32"\000;", 3, interface_index_name, iin_idx));
			} else {
				strings__Builder_writeln(&sb, _STR("int %.*s\000;", 2, interface_index_name));
			}
		}
		strings__Builder_writeln(&sb, _STR("// ^^^ number of types for interface %.*s\000: %"PRId32"", 2, interface_name, current_iinidx - iinidx_minimum_base));
		if (iname_table_length == 0) {
			strings__Builder_writeln(&methods_struct, _SLIT(""));
		} else {
			if (g->pref->build_mode != v__pref__BuildMode_build_module) {
				strings__Builder_writeln(&methods_struct, _SLIT("};"));
			}
		}
		strings__Builder_writeln(&sb, _SLIT(""));
		if (inter_info.methods.len > 0) {
			strings__Builder_writeln(&sb, strings__Builder_str(&methods_wrapper));
			strings__Builder_writeln(&sb, strings__Builder_str(&methods_typ_def));
			strings__Builder_writeln(&sb, strings__Builder_str(&methods_struct_def));
			strings__Builder_writeln(&sb, strings__Builder_str(&methods_struct));
		}
		strings__Builder_writeln(&sb, strings__Builder_str(&cast_functions));
	}
	 string _t3034 = strings__Builder_str(&sb);
	// autofree_scope_vars(pos=186068 line_nr=6336 scope.pos=179097 scope.end_pos=186085)
	// var "g" var.pos=179102 var.line_nr=6166
	// var "sb" var.pos=179141 var.line_nr=6167
	// af parent scope:
	// af parent scope:
	return _t3034;
}

VV_LOCAL_SYMBOL multi_return_int_string_string_string v__gen__c__Gen_panic_debug_info(v__gen__c__Gen* g, v__token__Position pos) {
	int paline = pos.line_nr + 1;
	if (isnil(g->fn_decl)) {
		return (multi_return_int_string_string_string){.arg0=paline, .arg1=_SLIT(""), .arg2=_SLIT("main"), .arg3=_SLIT("C._vinit")};
	}
	string pafile = string_replace(g->fn_decl->file, _SLIT("\\"), _SLIT("/"));
	string pafn = string_after(g->fn_decl->name, _SLIT("."));
	string pamod = v__ast__FnDecl_modname(g->fn_decl);
	return (multi_return_int_string_string_string){.arg0=paline, .arg1=pafile, .arg2=pamod, .arg3=pafn};
}

string v__gen__c__get_guarded_include_text(string iname, string imessage) {
	string res = string_strip_margin(_STR("\n	|#if defined(__has_include)\n	|\n	|#if __has_include(%.*s\000)\n	|#include %.*s\000\n	|#else\n	|#error VERROR_MESSAGE %.*s\000\n	|#endif\n	|\n	|#else\n	|#include %.*s\000\n	|#endif\n	", 5, iname, iname, imessage, iname));
	// autofree_scope_vars(pos=186681 line_nr=6361 scope.pos=186421 scope.end_pos=186693)
	// var "iname" var.pos=186446 var.line_nr=6350
	// var "imessage" var.pos=186460 var.line_nr=6350
	// var "res" var.pos=186487 var.line_nr=6351
	// af parent scope:
	// af parent scope:
	return res;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_trace(v__gen__c__Gen* g, string fbase, string message) {
	if (string_eq(g->file.path_base, fbase)) {
		println(_STR("> g.trace | %*.*s\000 | %.*s", 2, fbase, -10, message));
	}
}

void v__gen__c__Gen_gen_c_main(v__gen__c__Gen* g) {
	if (!g->has_main) {
		return;
	}
	if (g->pref->is_liveshared) {
		return;
	}
	strings__Builder_writeln(&g->out, _SLIT(""));
	int main_fn_start_pos = g->out.len;
	if ((g->pref->os == v__pref__OS_android && g->pref->is_apk) || g->pref->os == v__pref__OS_ios) {
		v__gen__c__Gen_gen_c_android_sokol_main(g);
	} else {
		v__gen__c__Gen_gen_c_main_header(g);
		v__gen__c__Gen_writeln(g, _SLIT("\tmain__main();"));
		v__gen__c__Gen_gen_c_main_footer(g);
		if (g->pref->printfn_list.len > 0 && (Array_string_contains(g->pref->printfn_list, _SLIT("main")))) {
			println(strings__Builder_after(&g->out, main_fn_start_pos));
		}
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_vlines_reset(v__gen__c__Gen* g) {
	if (g->pref->is_vlines) {
		int lines_so_far = 1000000;
		g->vlines_path = v__util__vlines_escape_path(g->pref->out_name_c, g->pref->ccompiler);
		v__gen__c__Gen_writeln(g, _SLIT(""));
		v__gen__c__Gen_writeln(g, _SLIT("\n// Reset the file/line numbers"));
		v__gen__c__Gen_writeln(g, _STR("\n#line %"PRId32"\000 \"%.*s\000\"", 3, lines_so_far, g->vlines_path));
		v__gen__c__Gen_writeln(g, _SLIT(""));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_c_main_function_header(v__gen__c__Gen* g) {
	if (g->pref->os == v__pref__OS_windows) {
		if (v__gen__c__Gen_is_gui_app(g)) {
			v__gen__c__Gen_writeln(g, _SLIT("int WINAPI wWinMain(HINSTANCE instance, HINSTANCE prev_instance, LPWSTR cmd_line, int show_cmd){"));
			v__gen__c__Gen_writeln(g, _SLIT("\tLPWSTR full_cmd_line = GetCommandLineW(); // NB: do not use cmd_line"));
			v__gen__c__Gen_writeln(g, _SLIT("\ttypedef LPWSTR*(WINAPI *cmd_line_to_argv)(LPCWSTR, int*);"));
			v__gen__c__Gen_writeln(g, _SLIT("\tHMODULE shell32_module = LoadLibrary(L\"shell32.dll\");"));
			v__gen__c__Gen_writeln(g, _SLIT("\tcmd_line_to_argv CommandLineToArgvW = (cmd_line_to_argv)GetProcAddress(shell32_module, \"CommandLineToArgvW\");"));
			v__gen__c__Gen_writeln(g, _SLIT("\tint ___argc;"));
			v__gen__c__Gen_writeln(g, _SLIT("\twchar_t** ___argv = CommandLineToArgvW(full_cmd_line, &___argc);"));
		} else {
			v__gen__c__Gen_writeln(g, _SLIT("int wmain(int ___argc, wchar_t* ___argv[], wchar_t* ___envp[]){"));
		}
	} else {
		v__gen__c__Gen_writeln(g, _SLIT("int main(int ___argc, char** ___argv){"));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_c_main_header(v__gen__c__Gen* g) {
	v__gen__c__Gen_gen_c_main_function_header(g);
	if ((g->pref->gc_mode == v__pref__GarbageCollectionMode_boehm_full || g->pref->gc_mode == v__pref__GarbageCollectionMode_boehm_incr || g->pref->gc_mode == v__pref__GarbageCollectionMode_boehm || g->pref->gc_mode == v__pref__GarbageCollectionMode_boehm_leak)) {
		v__gen__c__Gen_writeln(g, _SLIT("#if defined(_VGCBOEHM)"));
		if (g->pref->gc_mode == v__pref__GarbageCollectionMode_boehm_leak) {
			v__gen__c__Gen_writeln(g, _SLIT("\tGC_set_find_leak(1);"));
		}
		v__gen__c__Gen_writeln(g, _SLIT("\tGC_INIT();"));
		if (g->pref->gc_mode == v__pref__GarbageCollectionMode_boehm_incr) {
			v__gen__c__Gen_writeln(g, _SLIT("\tGC_enable_incremental();"));
		}
		v__gen__c__Gen_writeln(g, _SLIT("#endif"));
	}
	v__gen__c__Gen_writeln(g, _SLIT("\t_vinit(___argc, (voidptr)___argv);"));
	if (g->pref->is_prof) {
		v__gen__c__Gen_writeln(g, _SLIT(""));
		v__gen__c__Gen_writeln(g, _SLIT("\tatexit(vprint_profile_stats);"));
		v__gen__c__Gen_writeln(g, _SLIT(""));
	}
	if (g->pref->is_livemain) {
		v__gen__c__Gen_generate_hotcode_reloading_main_caller(g);
	}
}

void v__gen__c__Gen_gen_c_main_footer(v__gen__c__Gen* g) {
	v__gen__c__Gen_writeln(g, _SLIT("\t_vcleanup();"));
	v__gen__c__Gen_writeln(g, _SLIT("\treturn 0;"));
	v__gen__c__Gen_writeln(g, _SLIT("}"));
}

void v__gen__c__Gen_gen_c_android_sokol_main(v__gen__c__Gen* g) {
	if (g->is_autofree) {
		v__gen__c__Gen_writeln(g, _SLIT("// Wrapping cleanup/free callbacks for sokol to include _vcleanup()\nvoid (*_vsokol_user_cleanup_ptr)(void);\nvoid (*_vsokol_user_cleanup_cb_ptr)(void *);\n\nvoid (_vsokol_cleanup_cb)(void) {\n	if (_vsokol_user_cleanup_ptr) {\n		_vsokol_user_cleanup_ptr();\n	}\n	_vcleanup();\n}\n\nvoid (_vsokol_cleanup_userdata_cb)(void* user_data) {\n	if (_vsokol_user_cleanup_cb_ptr) {\n		_vsokol_user_cleanup_cb_ptr(g_desc.user_data);\n	}\n	_vcleanup();\n}\n"));
	}
	v__gen__c__Gen_writeln(g, _SLIT("// The sokol_main entry point on Android\nsapp_desc sokol_main(int argc, char* argv[]) {\n	(void)argc; (void)argv;\n\n	_vinit(argc, (voidptr)argv);\n	main__main();\n"));
	if (g->is_autofree) {
		v__gen__c__Gen_writeln(g, _SLIT("	// Wrap user provided cleanup/free functions for sokol to be able to call _vcleanup()\n	if (g_desc.cleanup_cb) {\n		_vsokol_user_cleanup_ptr = g_desc.cleanup_cb;\n		g_desc.cleanup_cb = _vsokol_cleanup_cb;\n	}\n	else if (g_desc.cleanup_userdata_cb) {\n		_vsokol_user_cleanup_cb_ptr = g_desc.cleanup_userdata_cb;\n		g_desc.cleanup_userdata_cb = _vsokol_cleanup_userdata_cb;\n	}\n"));
	}
	v__gen__c__Gen_writeln(g, _SLIT("	return g_desc;"));
	v__gen__c__Gen_writeln(g, _SLIT("}"));
}

void v__gen__c__Gen_write_tests_definitions(v__gen__c__Gen* g) {
	strings__Builder_writeln(&g->includes, _SLIT("#include <setjmp.h> // write_tests_main"));
	strings__Builder_writeln(&g->definitions, _SLIT("int g_test_oks = 0;"));
	strings__Builder_writeln(&g->definitions, _SLIT("int g_test_fails = 0;"));
	strings__Builder_writeln(&g->definitions, _SLIT("jmp_buf g_jump_buffer;"));
}

void v__gen__c__Gen_gen_failing_error_propagation_for_test_fn(v__gen__c__Gen* g, v__ast__OrExpr or_block, string cvar_name) {
	multi_return_int_string_string_string mr_4589 = v__gen__c__Gen_panic_debug_info(g, or_block.pos);
	int paline = mr_4589.arg0;
	string pafile = mr_4589.arg1;
	string pamod = mr_4589.arg2;
	string pafn = mr_4589.arg3;
	v__gen__c__Gen_writeln(g, _STR("\tmain__cb_propagate_test_error(%"PRId32"\000, tos3(\"%.*s\000\"), tos3(\"%.*s\000\"), tos3(\"%.*s\000\"), *(%.*s\000.err.msg) );", 6, paline, pafile, pamod, pafn, cvar_name));
	v__gen__c__Gen_writeln(g, _SLIT("\tg_test_fails++;"));
	v__gen__c__Gen_writeln(g, _SLIT("\tlongjmp(g_jump_buffer, 1);"));
}

void v__gen__c__Gen_gen_c_main_for_tests(v__gen__c__Gen* g) {
	int main_fn_start_pos = g->out.len;
	v__gen__c__Gen_writeln(g, _SLIT(""));
	v__gen__c__Gen_gen_c_main_function_header(g);
	if ((g->pref->gc_mode == v__pref__GarbageCollectionMode_boehm_full || g->pref->gc_mode == v__pref__GarbageCollectionMode_boehm_incr || g->pref->gc_mode == v__pref__GarbageCollectionMode_boehm || g->pref->gc_mode == v__pref__GarbageCollectionMode_boehm_leak)) {
		v__gen__c__Gen_writeln(g, _SLIT("#if defined(_VGCBOEHM)"));
		if (g->pref->gc_mode == v__pref__GarbageCollectionMode_boehm_leak) {
			v__gen__c__Gen_writeln(g, _SLIT("\tGC_set_find_leak(1);"));
		}
		v__gen__c__Gen_writeln(g, _SLIT("\tGC_INIT();"));
		if (g->pref->gc_mode == v__pref__GarbageCollectionMode_boehm_incr) {
			v__gen__c__Gen_writeln(g, _SLIT("\tGC_enable_incremental();"));
		}
		v__gen__c__Gen_writeln(g, _SLIT("#endif"));
	}
	v__gen__c__Gen_writeln(g, _SLIT("\t_vinit(___argc, (voidptr)___argv);"));
	Array_string all_tfuncs = v__gen__c__Gen_get_all_test_function_names(g);
	if (g->pref->is_stats) {
		v__gen__c__Gen_writeln(g, _STR("\tmain__BenchedTests bt = main__start_testing(%"PRId32"\000, _SLIT(\"%.*s\000\"));", 3, all_tfuncs.len, g->pref->path));
	}
	v__gen__c__Gen_writeln(g, _SLIT(""));
	// FOR IN array
	for (int _t3035 = 0; _t3035 < all_tfuncs.len; ++_t3035) {
		string tname = ((string*)all_tfuncs.data)[_t3035];
		string tcname = v__util__no_dots(tname);
		if (g->pref->is_stats) {
			v__gen__c__Gen_writeln(g, _STR("\tmain__BenchedTests_testing_step_start(&bt, _SLIT(\"%.*s\000\"));", 2, tcname));
		}
		v__gen__c__Gen_writeln(g, _STR("\tif (!setjmp(g_jump_buffer)) %.*s\000();", 2, tcname));
		if (g->pref->is_stats) {
			v__gen__c__Gen_writeln(g, _SLIT("\tmain__BenchedTests_testing_step_end(&bt);"));
		}
	}
	v__gen__c__Gen_writeln(g, _SLIT(""));
	if (g->pref->is_stats) {
		v__gen__c__Gen_writeln(g, _SLIT("\tmain__BenchedTests_end_testing(&bt);"));
	}
	v__gen__c__Gen_writeln(g, _SLIT("\t_vcleanup();"));
	v__gen__c__Gen_writeln(g, _SLIT("\treturn g_test_fails > 0;"));
	v__gen__c__Gen_writeln(g, _SLIT("}"));
	if (g->pref->printfn_list.len > 0 && (Array_string_contains(g->pref->printfn_list, _SLIT("main")))) {
		println(strings__Builder_after(&g->out, main_fn_start_pos));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_comptime_selector(v__gen__c__Gen* g, v__ast__ComptimeSelector node) {
	v__gen__c__Gen_expr(g, node.left);
	if (v__ast__Type_is_ptr(node.left_type)) {
		v__gen__c__Gen_write(g, _SLIT("->"));
	} else {
		v__gen__c__Gen_write(g, _SLIT("."));
	}
	if ((node.field_expr)._typ == 273 /* v.ast.SelectorExpr */) {
		if (((*node.field_expr._v__ast__SelectorExpr).expr)._typ == 254 /* v.ast.Ident */) {
			if (string_eq((*(*node.field_expr._v__ast__SelectorExpr).expr._v__ast__Ident).name, g->comp_for_field_var) && string_eq((*node.field_expr._v__ast__SelectorExpr).field_name, _SLIT("name"))) {
				v__gen__c__Gen_write(g, g->comp_for_field_value.name);
				return;
			}
		}
	}
	v__gen__c__Gen_expr(g, node.field_expr);
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_comptime_call(v__gen__c__Gen* g, v__ast__ComptimeCall node) {
	if (node.is_embed) {
		v__gen__c__Gen_gen_embed_file_init(g, node);
		return;
	}
	if (string_eq(node.method_name, _SLIT("env"))) {
		string val = v__util__cescaped_path(os__getenv(node.args_var));
		v__gen__c__Gen_write(g, _STR("_SLIT(\"%.*s\000\")", 2, val));
		return;
	}
	if (node.is_vweb) {
		bool is_html = string_eq(node.method_name, _SLIT("html"));
		// FOR IN array
		for (int _t3036 = 0; _t3036 < node.vweb_tmpl.stmts.len; ++_t3036) {
			v__ast__Stmt stmt = ((v__ast__Stmt*)node.vweb_tmpl.stmts.data)[_t3036];
			if ((stmt)._typ == 175 /* v.ast.FnDecl */) {
				if (string_starts_with((*stmt._v__ast__FnDecl).name, _SLIT("main.vweb_tmpl"))) {
					if (is_html) {
						g->inside_vweb_tmpl = true;
					}
					v__gen__c__Gen_stmts(g, (*stmt._v__ast__FnDecl).stmts);
					g->inside_vweb_tmpl = false;
					break;
				}
			}
		}
		if (is_html) {
			v__gen__c__Gen_writeln(g, _STR("vweb__Context_html(&app->Context, _tmpl_res_%.*s\000); strings__Builder_free(&sb); string_free(&_tmpl_res_%.*s\000);", 3, g->fn_decl->name, g->fn_decl->name));
		} else {
			string fn_name = string_replace(g->fn_decl->name, _SLIT("."), _SLIT("__"));
			v__gen__c__Gen_writeln(g, _STR("return _tmpl_res_%.*s\000;", 2, fn_name));
		}
		return;
	}
	v__gen__c__Gen_writeln(g, _STR("// $method call. sym=\"%.*s\000\"", 2, node.sym.name));
	if (string_eq(node.method_name, _SLIT("method"))) {
		Option_v__ast__Fn _t3037 = v__ast__TypeSymbol_find_method(&node.sym, g->comp_for_method);
		if (_t3037.state != 0) { /*or block*/ 
			IError err = _t3037.err;
			return;
		}
 		v__ast__Fn m =  *(v__ast__Fn*)_t3037.data;
		v__ast__Param _t3039;
		v__ast__CallArg _t3038;
		bool expand_strs = (node.args.len > 0 && m.params.len - 1 >= node.args.len ? (			_t3038 = (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, node.args.len - 1)),			_t3039 = (*(v__ast__Param*)/*ee elem_typ */array_get(m.params, node.args.len)),(_t3038.expr)._typ == 254 /* v.ast.Ident */ && string_eq(v__ast__Table_type_to_str(g->table, _t3038.typ), _SLIT("[]string")) && string_ne(v__ast__Table_type_to_str(g->table, _t3039.typ), _SLIT("[]string"))) : (false));
		if (m.params.len - 1 != node.args.len && !expand_strs) {
			v__gen__c__Gen_writeln(g, _STR("/* skipping %.*s\000.%.*s\000 due to mismatched arguments list */", 3, node.sym.name, m.name));
			return;
		}
		v__gen__c__Gen_write(g, _STR("%.*s\000_%.*s\000(", 3, v__util__no_dots(node.sym.name), g->comp_for_method));
		if ((node.left)._typ == 254 /* v.ast.Ident */) {
			v__ast__Scope* scope = v__ast__Scope_innermost(g->file.scope, node.pos.pos);
			Option_v__ast__Var_ptr _t3040;
			if (_t3040 = v__ast__Scope_find_var(scope, (*node.left._v__ast__Ident).name), _t3040.state == 0) {
				v__ast__Var* v = *(v__ast__Var**)_t3040.data;
				if (v__ast__Type_is_ptr((*(v__ast__Param*)/*ee elem_typ */array_get(m.params, 0)).typ) && !v__ast__Type_is_ptr(v->typ)) {
					v__gen__c__Gen_write(g, _SLIT("&"));
				}
			}
		}
		v__gen__c__Gen_expr(g, node.left);
		if (m.params.len > 1) {
			v__gen__c__Gen_write(g, _SLIT(", "));
		}
		for (int i = 1; i < m.params.len; ++i) {
			if ((node.left)._typ == 254 /* v.ast.Ident */) {
				if (string_eq((*(v__ast__Param*)/*ee elem_typ */array_get(m.params, i)).name, (*node.left._v__ast__Ident).name)) {
					continue;
				}
			}
			if (i - 1 < node.args.len - 1) {
				v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, i - 1)).expr);
				v__gen__c__Gen_write(g, _SLIT(", "));
			} else if (!expand_strs && i == node.args.len) {
				v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, i - 1)).expr);
				break;
			} else {
				int idx = i - node.args.len;
				if (v__ast__Type_is_int((*(v__ast__Param*)/*ee elem_typ */array_get(m.params, i)).typ) || v__ast__Type_idx((*(v__ast__Param*)/*ee elem_typ */array_get(m.params, i)).typ) == _const_v__ast__bool_type_idx) {
					string type_name = v__ast__TypeSymbol_str(&(*(v__ast__TypeSymbol*)/*ee elem_typ */array_get(g->table->type_symbols, ((int)((*(v__ast__Param*)/*ee elem_typ */array_get(m.params, i)).typ)))));
					v__gen__c__Gen_write(g, _STR("string_%.*s\000(((string*)%.*s\000.data) [%"PRId32"\000])", 4, type_name, v__ast__CallArg_str((*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, node.args.len - 1))), idx));
				} else {
					v__gen__c__Gen_write(g, _STR("((string*)%.*s\000.data) [%"PRId32"\000] ", 3, v__ast__CallArg_str((*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, node.args.len - 1))), idx));
				}
				if (i < m.params.len - 1) {
					v__gen__c__Gen_write(g, _SLIT(", "));
				}
			}
		}
		v__gen__c__Gen_write(g, _SLIT(" ); // vweb action call with args"));
		return;
	}
	int j = 0;
	// FOR IN array
	for (int _t3041 = 0; _t3041 < node.sym.methods.len; ++_t3041) {
		v__ast__Fn method = ((v__ast__Fn*)node.sym.methods.data)[_t3041];
		if (!v__ast__Type_alias_eq(method.return_type, node.result_type)) {
			continue;
		}
		if (method.params.len != 1) {
			continue;
		}
		string amp = _SLIT("");
		if (node.is_vweb) {
			if (j > 0) {
				v__gen__c__Gen_write(g, _SLIT(" else "));
			}
			v__gen__c__Gen_write(g, _STR("if (string_eq(%.*s\000, _SLIT(\"%.*s\000\"))) ", 3, node.method_name, method.name));
		}
		v__gen__c__Gen_write(g, _STR("%.*s\000_%.*s\000(%.*s\000 ", 4, v__util__no_dots(node.sym.name), method.name, amp));
		v__gen__c__Gen_expr(g, node.left);
		v__gen__c__Gen_writeln(g, _SLIT(");"));
		j++;
	}
}

VV_LOCAL_SYMBOL Array_string v__gen__c__cgen_attrs(Array_v__ast__Attr attrs) {
	Array_string res = __new_array_with_default(0, attrs.len, sizeof(string), 0);
	// FOR IN array
	for (int _t3042 = 0; _t3042 < attrs.len; ++_t3042) {
		v__ast__Attr attr = ((v__ast__Attr*)attrs.data)[_t3042];
		string s = attr.name;
		if (attr.arg.len > 0) {
			s = /*f*/string_add(s, _STR(": %.*s", 1, attr.arg));
		}
		array_push(&res, _MOV((string[]){ string_clone(_STR("_SLIT(\"%.*s\000\")", 2, s)) }));
	}
	// autofree_scope_vars(pos=4960 line_nr=177 scope.pos=4681 scope.end_pos=4972)
	// var "attrs" var.pos=4692 var.line_nr=167
	// var "res" var.pos=4726 var.line_nr=168
	// af parent scope:
	// af parent scope:
	return res;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_comp_at(v__gen__c__Gen* g, v__ast__AtExpr node) {
	if (node.kind == v__token__AtKind_vmod_file) {
		string val = v__gen__c__cnewlines(string_replace(node.val, _SLIT("\r"), _SLIT("")));
		v__gen__c__Gen_write(g, _STR("_SLIT(\"%.*s\000\")", 2, val));
	} else {
		string val = string_replace(node.val, _SLIT("\\"), _SLIT("\\\\"));
		v__gen__c__Gen_write(g, _STR("_SLIT(\"%.*s\000\")", 2, val));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_comp_if(v__gen__c__Gen* g, v__ast__IfExpr node) {
	if (!node.is_expr && !node.has_else && node.branches.len == 1) {
		if ((*(v__ast__IfBranch*)/*ee elem_typ */array_get(node.branches, 0)).stmts.len == 0) {
			return;
		}
		if (!g->pref->output_cross_c) {
			if (((*(v__ast__IfBranch*)/*ee elem_typ */array_get(node.branches, 0)).cond)._typ == 254 /* v.ast.Ident */) {
				Option_v__pref__OS _t3044 = v__pref__os_from_string((*(*(v__ast__IfBranch*)/*ee elem_typ */array_get(node.branches, 0)).cond._v__ast__Ident).name);
				if (_t3044.state != 0) { /*or block*/ 
					IError err = _t3044.err;
					*(v__pref__OS*) _t3044.data = v__pref__OS__auto;
				}
 				if (g->pref->os == ( *(v__pref__OS*)_t3044.data)) {
					g->indent--;
					v__gen__c__Gen_stmts(g, (*(v__ast__IfBranch*)/*ee elem_typ */array_get(node.branches, 0)).stmts);
					g->indent++;
					return;
				}
			}
		}
	}
	string _t3045;
	string line = (node.is_expr ? (		_t3045 = v__gen__c__Gen_go_before_stmt(g, 0),v__gen__c__Gen_write(g, v__util__tabs(g->indent)),string_trim_space(_t3045)) : (_SLIT("")));
	bool comp_if_stmts_skip = false;
	// FOR IN array
	for (int i = 0; i < node.branches.len; ++i) {
		v__ast__IfBranch branch = ((v__ast__IfBranch*)node.branches.data)[i];
		int start_pos = g->out.len;
		if (i == node.branches.len - 1 && node.has_else) {
			v__gen__c__Gen_writeln(g, _SLIT("#else"));
			comp_if_stmts_skip = false;
		} else {
			if (i == 0) {
				v__gen__c__Gen_write(g, _SLIT("#if "));
			} else {
				v__gen__c__Gen_write(g, _SLIT("#elif "));
			}
			comp_if_stmts_skip = !v__gen__c__Gen_comp_if_cond(g, branch.cond);
			v__gen__c__Gen_writeln(g, _SLIT(""));
		}
		string expr_str = string_trim_space(strings__Builder_last_n(&g->out, g->out.len - start_pos));
		g->defer_ifdef = expr_str;
		if (node.is_expr) {
			int len = branch.stmts.len;
			if (len > 0) {
				v__ast__ExprStmt last = /* as */ *(v__ast__ExprStmt*)__as_cast(((*(v__ast__Stmt*)/*ee elem_typ */array_get(branch.stmts, len - 1)))._v__ast__ExprStmt,((*(v__ast__Stmt*)/*ee elem_typ */array_get(branch.stmts, len - 1)))._typ, 293) /*expected idx: 293, name: v.ast.ExprStmt */ ;
				if (len > 1) {
					string tmp = v__gen__c__Gen_new_tmp_var(g);
					string styp = v__gen__c__Gen_typ(g, last.typ);
					g->indent++;
					v__gen__c__Gen_writeln(g, _STR("%.*s\000 %.*s\000;", 3, styp, tmp));
					v__gen__c__Gen_writeln(g, _SLIT("{"));
					v__gen__c__Gen_stmts(g, array_slice(branch.stmts, 0, len - 1));
					v__gen__c__Gen_write(g, _STR("\t%.*s\000 = ", 2, tmp));
					v__gen__c__Gen_stmt(g, v__ast__ExprStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__ExprStmt, (last))));
					v__gen__c__Gen_writeln(g, _SLIT("}"));
					g->indent--;
					v__gen__c__Gen_writeln(g, _STR("%.*s\000 %.*s\000;", 3, line, tmp));
				} else {
					v__gen__c__Gen_write(g, _STR("%.*s\000 ", 2, line));
					v__gen__c__Gen_stmt(g, v__ast__ExprStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__ExprStmt, (last))));
				}
			}
		} else {
			bool should_create_scope = g->fn_decl != 0;
			if (should_create_scope) {
				v__gen__c__Gen_writeln(g, _SLIT("{"));
			}
			if (!comp_if_stmts_skip) {
				v__gen__c__Gen_stmts(g, branch.stmts);
			}
			if (should_create_scope) {
				v__gen__c__Gen_writeln(g, _SLIT("}"));
			}
		}
		g->defer_ifdef = _SLIT("");
	}
	v__gen__c__Gen_writeln(g, _SLIT("#endif"));
}

VV_LOCAL_SYMBOL bool v__gen__c__Gen_comp_if_cond(v__gen__c__Gen* g, v__ast__Expr cond) {
	if (cond._typ == 239 /* v.ast.BoolLiteral */) {
		v__gen__c__Gen_expr(g, cond);
		 bool _t3046 = true;
		// autofree_scope_vars(pos=7348 line_nr=279 scope.pos=7312 scope.end_pos=7363)
		// var "cond" var.pos=7303 var.line_nr=276
		// af parent scope:
		// var "g" var.pos=7254 var.line_nr=275
		// var "cond" var.pos=7274 var.line_nr=275
		// af parent scope:
		// af parent scope:
		return _t3046;
	}
	else if (cond._typ == 268 /* v.ast.ParExpr */) {
		v__gen__c__Gen_write(g, _SLIT("("));
		bool is_cond_true = v__gen__c__Gen_comp_if_cond(g, (*cond._v__ast__ParExpr).expr);
		v__gen__c__Gen_write(g, _SLIT(")"));
		// autofree_scope_vars(pos=7460 line_nr=285 scope.pos=7367 scope.end_pos=7483)
		// var "is_cond_true" var.pos=7400 var.line_nr=283
		// var "cond" var.pos=7303 var.line_nr=276
		// af parent scope:
		// var "g" var.pos=7254 var.line_nr=275
		// var "cond" var.pos=7274 var.line_nr=275
		// af parent scope:
		// af parent scope:
		return is_cond_true;
	}
	else if (cond._typ == 270 /* v.ast.PrefixExpr */) {
		v__gen__c__Gen_write(g, v__token__Kind_str((*cond._v__ast__PrefixExpr).op));
		 bool _t3047 = v__gen__c__Gen_comp_if_cond(g, (*cond._v__ast__PrefixExpr).right);
		// autofree_scope_vars(pos=7532 line_nr=289 scope.pos=7487 scope.end_pos=7569)
		// var "cond" var.pos=7303 var.line_nr=276
		// af parent scope:
		// var "g" var.pos=7254 var.line_nr=275
		// var "cond" var.pos=7274 var.line_nr=275
		// af parent scope:
		// af parent scope:
		return _t3047;
	}
	else if (cond._typ == 269 /* v.ast.PostfixExpr */) {
		Option_string _t3048 = v__gen__c__Gen_comp_if_to_ifdef(g, (/* as */ *(v__ast__Ident*)__as_cast(((*cond._v__ast__PostfixExpr).expr)._v__ast__Ident,((*cond._v__ast__PostfixExpr).expr)._typ, 254) /*expected idx: 254, name: v.ast.Ident */ ).name, true);
		if (_t3048.state != 0) { /*or block*/ 
			IError err = _t3048.err;
			v__gen__c__verror((*(err.msg)));
			 bool _t3049 = false;
			// autofree_scope_vars(pos=7687 line_nr=294 scope.pos=7662 scope.end_pos=7704)
			// var "err" var.pos=7662 var.line_nr=292
			// af parent scope:
			// var "ifdef" var.pos=7594 var.line_nr=292
			// var "cond" var.pos=7303 var.line_nr=276
			// af parent scope:
			// var "g" var.pos=7254 var.line_nr=275
			// var "cond" var.pos=7274 var.line_nr=275
			// af parent scope:
			// af parent scope:
			return _t3049;
		}
 		string ifdef =  *(string*)_t3048.data;
		v__gen__c__Gen_write(g, _STR("defined(%.*s\000)", 2, ifdef));
		 bool _t3050 = true;
		// autofree_scope_vars(pos=7738 line_nr=297 scope.pos=7573 scope.end_pos=7753)
		// var "ifdef" var.pos=7594 var.line_nr=292
		// var "cond" var.pos=7303 var.line_nr=276
		// af parent scope:
		// var "g" var.pos=7254 var.line_nr=275
		// var "cond" var.pos=7274 var.line_nr=275
		// af parent scope:
		// af parent scope:
		return _t3050;
	}
	else if (cond._typ == 258 /* v.ast.InfixExpr */) {

		if ((*cond._v__ast__InfixExpr).op == (v__token__Kind_and) || (*cond._v__ast__InfixExpr).op == (v__token__Kind_logical_or)) {
			bool l = v__gen__c__Gen_comp_if_cond(g, (*cond._v__ast__InfixExpr).left);
			v__gen__c__Gen_write(g, _STR(" %.*s\000 ", 2, v__token__Kind_str((*cond._v__ast__InfixExpr).op)));
			bool r = v__gen__c__Gen_comp_if_cond(g, (*cond._v__ast__InfixExpr).right);
			 bool _t3051 = ((*cond._v__ast__InfixExpr).op == v__token__Kind_and ? (l && r) : (l || r));
			// autofree_scope_vars(pos=7920 line_nr=305 scope.pos=7796 scope.end_pos=7978)
			// var "l" var.pos=7821 var.line_nr=302
			// var "r" var.pos=7884 var.line_nr=304
			// af parent scope:
			// var "cond" var.pos=7303 var.line_nr=276
			// af parent scope:
			// var "g" var.pos=7254 var.line_nr=275
			// var "cond" var.pos=7274 var.line_nr=275
			// af parent scope:
			// af parent scope:
			return _t3051;
		}
		else if ((*cond._v__ast__InfixExpr).op == (v__token__Kind_key_is) || (*cond._v__ast__InfixExpr).op == (v__token__Kind_not_is)) {
			v__ast__Expr left = (*cond._v__ast__InfixExpr).left;
			string name = _SLIT("");
			v__ast__Type exp_type = ((v__ast__Type)(0));
			v__ast__Type got_type = (/* as */ *(v__ast__TypeNode*)__as_cast(((*cond._v__ast__InfixExpr).right)._v__ast__TypeNode,((*cond._v__ast__InfixExpr).right)._typ, 279) /*expected idx: 279, name: v.ast.TypeNode */ ).typ;
			if ((left)._typ == 273 /* v.ast.SelectorExpr */) {
				name = _STR("%.*s\000.%.*s", 2, v__ast__Expr_str((*left._v__ast__SelectorExpr).expr), (*left._v__ast__SelectorExpr).field_name);
				exp_type = (*(v__ast__Type*)map_get(ADDR(map, g->comptime_var_type_map), &(string[]){name}, &(v__ast__Type[]){ 0 }));
			} else if ((left)._typ == 279 /* v.ast.TypeNode */) {
				name = v__ast__TypeNode_str((*left._v__ast__TypeNode));
				exp_type = v__gen__c__Gen_unwrap_generic(g, (*left._v__ast__TypeNode).typ);
			}
			if ((*cond._v__ast__InfixExpr).op == v__token__Kind_key_is) {
				v__gen__c__Gen_write(g, _STR("%"PRId32"\000 == %"PRId32"", 2, exp_type, got_type));
				 bool _t3052 = v__ast__Type_alias_eq(exp_type, got_type);
				// autofree_scope_vars(pos=8527 line_nr=323 scope.pos=8480 scope.end_pos=8561)
				// af parent scope:
				// var "left" var.pos=8008 var.line_nr=308
				// var "name" var.pos=8035 var.line_nr=309
				// str literal
				// var "exp_type" var.pos=8055 var.line_nr=310
				// var "got_type" var.pos=8084 var.line_nr=311
				// af parent scope:
				// var "cond" var.pos=7303 var.line_nr=276
				// af parent scope:
				// var "g" var.pos=7254 var.line_nr=275
				// var "cond" var.pos=7274 var.line_nr=275
				// af parent scope:
				// af parent scope:
				return _t3052;
			} else {
				v__gen__c__Gen_write(g, _STR("%"PRId32"\000 !=%"PRId32"", 2, exp_type, got_type));
				 bool _t3053 = !v__ast__Type_alias_eq(exp_type, got_type);
				// autofree_scope_vars(pos=8614 line_nr=326 scope.pos=8568 scope.end_pos=8648)
				// af parent scope:
				// var "left" var.pos=8008 var.line_nr=308
				// var "name" var.pos=8035 var.line_nr=309
				// str literal
				// var "exp_type" var.pos=8055 var.line_nr=310
				// var "got_type" var.pos=8084 var.line_nr=311
				// af parent scope:
				// var "cond" var.pos=7303 var.line_nr=276
				// af parent scope:
				// var "g" var.pos=7254 var.line_nr=275
				// var "cond" var.pos=7274 var.line_nr=275
				// af parent scope:
				// af parent scope:
				return _t3053;
			}
		}
		else if ((*cond._v__ast__InfixExpr).op == (v__token__Kind_eq) || (*cond._v__ast__InfixExpr).op == (v__token__Kind_ne)) {
			v__gen__c__Gen_write(g, _SLIT("1"));
			 bool _t3054 = true;
			// autofree_scope_vars(pos=8743 line_nr=332 scope.pos=8660 scope.end_pos=8760)
			// af parent scope:
			// var "cond" var.pos=7303 var.line_nr=276
			// af parent scope:
			// var "g" var.pos=7254 var.line_nr=275
			// var "cond" var.pos=7274 var.line_nr=275
			// af parent scope:
			// af parent scope:
			return _t3054;
		}
		else {
			 bool _t3055 = true;
			// autofree_scope_vars(pos=8777 line_nr=335 scope.pos=8766 scope.end_pos=8794)
			// af parent scope:
			// var "cond" var.pos=7303 var.line_nr=276
			// af parent scope:
			// var "g" var.pos=7254 var.line_nr=275
			// var "cond" var.pos=7274 var.line_nr=275
			// af parent scope:
			// af parent scope:
			return _t3055;
		};
	}
	else if (cond._typ == 254 /* v.ast.Ident */) {
		Option_string _t3056 = v__gen__c__Gen_comp_if_to_ifdef(g, (*cond._v__ast__Ident).name, false);
		if (_t3056.state != 0) { /*or block*/ 
			IError err = _t3056.err;
			*(string*) _t3056.data = _SLIT("true");
		}
 		string ifdef =  *(string*)_t3056.data;
		v__gen__c__Gen_write(g, _STR("defined(%.*s\000)", 2, ifdef));
		 bool _t3057 = true;
		// autofree_scope_vars(pos=8936 line_nr=342 scope.pos=8807 scope.end_pos=8951)
		// var "ifdef" var.pos=8822 var.line_nr=340
		// var "cond" var.pos=7303 var.line_nr=276
		// af parent scope:
		// var "g" var.pos=7254 var.line_nr=275
		// var "cond" var.pos=7274 var.line_nr=275
		// af parent scope:
		// af parent scope:
		return _t3057;
	}
	else {
		v__gen__c__Gen_write(g, _SLIT("1"));
		 bool _t3058 = true;
		// autofree_scope_vars(pos=9026 line_nr=347 scope.pos=8955 scope.end_pos=9041)
		// af parent scope:
		// var "g" var.pos=7254 var.line_nr=275
		// var "cond" var.pos=7274 var.line_nr=275
		// af parent scope:
		// af parent scope:
		return _t3058;
	};
	return 0;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_comp_for(v__gen__c__Gen* g, v__ast__CompFor node) {
	v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, v__gen__c__Gen_unwrap_generic(g, node.typ));
	v__gen__c__Gen_writeln(g, _STR("/* $for %.*s\000 in %.*s\000(%.*s\000) */ {", 4, node.val_var, sym->name, v__ast__CompForKind_str(node.kind)));
	g->indent++;
	int i = 0;
	if (node.kind == v__ast__CompForKind_methods) {
		Array_v__ast__Fn _t3059_orig = sym->methods;
		int _t3059_len = _t3059_orig.len;
		Array_v__ast__Fn _t3059 = __new_array(0, _t3059_len, sizeof(v__ast__Fn));

		for (int _t3060 = 0; _t3060 < _t3059_len; ++_t3060) {
			v__ast__Fn it = ((v__ast__Fn*) _t3059_orig.data)[_t3060];
			if (it.attrs.len == 0) {
				array_push(&_t3059, &it); 
		}
		}
		
		Array_v__ast__Fn methods = _t3059;
		Array_v__ast__Fn _t3061_orig = sym->methods;
		int _t3061_len = _t3061_orig.len;
		Array_v__ast__Fn _t3061 = __new_array(0, _t3061_len, sizeof(v__ast__Fn));

		for (int _t3062 = 0; _t3062 < _t3061_len; ++_t3062) {
			v__ast__Fn it = ((v__ast__Fn*) _t3061_orig.data)[_t3062];
			if (it.attrs.len > 0) {
				array_push(&_t3061, &it); 
		}
		}
		
		Array_v__ast__Fn methods_with_attrs = _t3061;
		_PUSH_MANY(&methods, (methods_with_attrs), _t3063, Array_v__ast__Fn);
		if (methods.len > 0) {
			v__gen__c__Gen_writeln(g, _STR("FunctionData %.*s\000 = {0};", 2, node.val_var));
		}
		// FOR IN array
		for (int _t3064 = 0; _t3064 < methods.len; ++_t3064) {
			v__ast__Fn method = ((v__ast__Fn*)methods.data)[_t3064];
			g->comp_for_method = method.name;
			v__gen__c__Gen_writeln(g, _STR("/* method %"PRId32"\000 */ {", 2, i));
			v__gen__c__Gen_writeln(g, _STR("\t%.*s\000.name = _SLIT(\"%.*s\000\");", 3, node.val_var, method.name));
			if (method.attrs.len == 0) {
				v__gen__c__Gen_writeln(g, _STR("\t%.*s\000.attrs = __new_array_with_default(0, 0, sizeof(string), 0);", 2, node.val_var));
			} else {
				Array_string attrs = v__gen__c__cgen_attrs(method.attrs);
				v__gen__c__Gen_writeln(g, string_add(string_add(_STR("\t%.*s\000.attrs = new_array_from_c_array(%"PRId32"\000, %"PRId32"\000, sizeof(string), _MOV((string[%"PRId32"\000]){", 5, node.val_var, attrs.len, attrs.len, attrs.len), Array_string_join(attrs, _SLIT(", "))), _SLIT("}));")));
			}
			if (method.params.len < 2) {
				v__gen__c__Gen_writeln(g, _STR("\t%.*s\000.args = __new_array_with_default(0, 0, sizeof(MethodArgs), 0);", 2, node.val_var));
			} else {
				int len = method.params.len - 1;
				v__gen__c__Gen_write(g, _STR("\t%.*s\000.args = new_array_from_c_array(%"PRId32"\000, %"PRId32"\000, sizeof(MethodArgs), _MOV((MethodArgs[%"PRId32"\000]){", 5, node.val_var, len, len, len));
				// FOR IN array
				Array_v__ast__Param _t3065 = array_slice(method.params, 1, method.params.len);
				for (int j = 0; j < _t3065.len; ++j) {
					v__ast__Param arg = ((v__ast__Param*)_t3065.data)[j];
					int typ = v__ast__Type_idx(arg.typ);
					v__gen__c__Gen_write(g, _STR("{%.*s\000, _SLIT(\"%.*s\000\")}", 3, int_str(typ), arg.name));
					if (j < len - 1) {
						v__gen__c__Gen_write(g, _SLIT(", "));
					}
					map_set(&g->comptime_var_type_map, &(string[]){_STR("%.*s\000.args[%"PRId32"\000].typ", 3, node.val_var, j)}, &(v__ast__Type[]) { typ });
				}
				v__gen__c__Gen_writeln(g, _SLIT("}));"));
			}
			string sig = _SLIT("anon_fn_");
			// FOR IN array
			Array_v__ast__Param _t3066 = array_slice(method.params, 1, method.params.len);
			for (int j = 0; j < _t3066.len; ++j) {
				v__ast__Param arg = ((v__ast__Param*)_t3066.data)[j];
				v__ast__Type typ = v__ast__Type_set_nr_muls(arg.typ, 0);
				sig = /*f*/string_add(sig, _STR("%"PRId32"", 1, typ));
				if (j < method.params.len - 2) {
					sig = /*f*/string_add(sig, _SLIT("_"));
				}
			}
			sig = /*f*/string_add(sig, _STR("_%"PRId32"", 1, method.return_type));
			int styp = v__ast__Table_find_type_idx(g->table, sig);
			int ret_typ = v__ast__Type_idx(method.return_type);
			v__gen__c__Gen_writeln(g, _STR("\t%.*s\000.typ = %"PRId32"\000;", 3, node.val_var, styp));
			v__gen__c__Gen_writeln(g, _STR("\t%.*s\000.return_type = %"PRId32"\000;", 3, node.val_var, ret_typ));
			map_set(&g->comptime_var_type_map, &(string[]){_STR("%.*s\000.return_type", 2, node.val_var)}, &(v__ast__Type[]) { ret_typ });
			map_set(&g->comptime_var_type_map, &(string[]){_STR("%.*s\000.typ", 2, node.val_var)}, &(v__ast__Type[]) { styp });
			v__gen__c__Gen_stmts(g, node.stmts);
			i++;
			v__gen__c__Gen_writeln(g, _SLIT("}"));
			Array_string delete_keys = __new_array_with_default(0, 0, sizeof(string), 0);
			// FOR IN map
			Map_string_v__ast__Type _t3067 = g->comptime_var_type_map;
			int _t3069 = _t3067.key_values.len;
			for (int _t3068 = 0; _t3068 < _t3069; ++_t3068 ) {
				int _t3070 = _t3067.key_values.len - _t3069;
				_t3069 = _t3067.key_values.len;
				if (_t3070 < 0) {
					_t3068 = -1;
					continue;
				}
				if (!DenseArray_has_index(&_t3067.key_values, _t3068)) {continue;}
				string key = /*key*/ *(string*)DenseArray_key(&_t3067.key_values, _t3068);
				key = string_clone(key);
				if (string_starts_with(key, node.val_var)) {
					array_push(&delete_keys, _MOV((string[]){ string_clone(key) }));
				}
			}
			// FOR IN array
			for (int _t3072 = 0; _t3072 < delete_keys.len; ++_t3072) {
				string key = ((string*)delete_keys.data)[_t3072];
				map_delete(&g->comptime_var_type_map, &(string[]){key});
			}
		}
	} else if (node.kind == v__ast__CompForKind_fields) {
		if ((sym->info)._typ == 409 /* v.ast.Struct */) {
			Array_v__ast__StructField _t3073_orig = (*sym->info._v__ast__Struct).fields;
			int _t3073_len = _t3073_orig.len;
			Array_v__ast__StructField _t3073 = __new_array(0, _t3073_len, sizeof(v__ast__StructField));

			for (int _t3074 = 0; _t3074 < _t3073_len; ++_t3074) {
				v__ast__StructField it = ((v__ast__StructField*) _t3073_orig.data)[_t3074];
				if (it.attrs.len == 0) {
					array_push(&_t3073, &it); 
		}
			}
			
			Array_v__ast__StructField fields = _t3073;
			Array_v__ast__StructField _t3075_orig = (*sym->info._v__ast__Struct).fields;
			int _t3075_len = _t3075_orig.len;
			Array_v__ast__StructField _t3075 = __new_array(0, _t3075_len, sizeof(v__ast__StructField));

			for (int _t3076 = 0; _t3076 < _t3075_len; ++_t3076) {
				v__ast__StructField it = ((v__ast__StructField*) _t3075_orig.data)[_t3076];
				if (it.attrs.len > 0) {
					array_push(&_t3075, &it); 
		}
			}
			
			Array_v__ast__StructField fields_with_attrs = _t3075;
			_PUSH_MANY(&fields, (fields_with_attrs), _t3077, Array_v__ast__StructField);
			if (fields.len > 0) {
				v__gen__c__Gen_writeln(g, _STR("\tFieldData %.*s\000 = {0};", 2, node.val_var));
			}
			// FOR IN array
			for (int _t3078 = 0; _t3078 < fields.len; ++_t3078) {
				v__ast__StructField field = ((v__ast__StructField*)fields.data)[_t3078];
				g->comp_for_field_var = node.val_var;
				g->comp_for_field_value = field;
				v__gen__c__Gen_writeln(g, _STR("/* field %"PRId32"\000 */ {", 2, i));
				v__gen__c__Gen_writeln(g, _STR("\t%.*s\000.name = _SLIT(\"%.*s\000\");", 3, node.val_var, field.name));
				if (field.attrs.len == 0) {
					v__gen__c__Gen_writeln(g, _STR("\t%.*s\000.attrs = __new_array_with_default(0, 0, sizeof(string), 0);", 2, node.val_var));
				} else {
					Array_string attrs = v__gen__c__cgen_attrs(field.attrs);
					v__gen__c__Gen_writeln(g, string_add(string_add(_STR("\t%.*s\000.attrs = new_array_from_c_array(%"PRId32"\000, %"PRId32"\000, sizeof(string), _MOV((string[%"PRId32"\000]){", 5, node.val_var, attrs.len, attrs.len, attrs.len), Array_string_join(attrs, _SLIT(", "))), _SLIT("}));")));
				}
				v__ast__Type styp = field.typ;
				v__gen__c__Gen_writeln(g, _STR("\t%.*s\000.typ = %"PRId32"\000;", 3, node.val_var, styp));
				v__gen__c__Gen_writeln(g, _STR("\t%.*s\000.is_pub = %.*s\000;", 3, node.val_var, field.is_pub ? _SLIT("true") : _SLIT("false")));
				v__gen__c__Gen_writeln(g, _STR("\t%.*s\000.is_mut = %.*s\000;", 3, node.val_var, field.is_mut ? _SLIT("true") : _SLIT("false")));
				map_set(&g->comptime_var_type_map, &(string[]){_STR("%.*s\000.typ", 2, node.val_var)}, &(v__ast__Type[]) { styp });
				v__gen__c__Gen_stmts(g, node.stmts);
				i++;
				v__gen__c__Gen_writeln(g, _SLIT("}"));
			}
			map_delete(&g->comptime_var_type_map, &(string[]){node.val_var});
		}
	}
	g->indent--;
	v__gen__c__Gen_writeln(g, _SLIT("}// $for"));
}

VV_LOCAL_SYMBOL Option_string v__gen__c__Gen_comp_if_to_ifdef(v__gen__c__Gen* g, string name, bool is_comptime_optional) {

	if (string_eq(name, _SLIT("windows"))) {
		Option_string _t3079;
		opt_ok(&(string[]) { _SLIT("_WIN32") }, (Option*)(&_t3079), sizeof(string));
		// autofree_scope_vars(pos=13400 line_nr=479 scope.pos=13386 scope.end_pos=13419)
		// af parent scope:
		// var "g" var.pos=13274 var.line_nr=475
		// var "name" var.pos=13298 var.line_nr=475
		// var "is_comptime_optional" var.pos=13311 var.line_nr=475
		// af parent scope:
		// af parent scope:
		return _t3079;
	}
	else if (string_eq(name, _SLIT("ios"))) {
		Option_string _t3080;
		opt_ok(&(string[]) { _SLIT("__TARGET_IOS__") }, (Option*)(&_t3080), sizeof(string));
		// autofree_scope_vars(pos=13433 line_nr=482 scope.pos=13423 scope.end_pos=13460)
		// af parent scope:
		// var "g" var.pos=13274 var.line_nr=475
		// var "name" var.pos=13298 var.line_nr=475
		// var "is_comptime_optional" var.pos=13311 var.line_nr=475
		// af parent scope:
		// af parent scope:
		return _t3080;
	}
	else if (string_eq(name, _SLIT("macos"))) {
		Option_string _t3081;
		opt_ok(&(string[]) { _SLIT("__APPLE__") }, (Option*)(&_t3081), sizeof(string));
		// autofree_scope_vars(pos=13476 line_nr=485 scope.pos=13464 scope.end_pos=13498)
		// af parent scope:
		// var "g" var.pos=13274 var.line_nr=475
		// var "name" var.pos=13298 var.line_nr=475
		// var "is_comptime_optional" var.pos=13311 var.line_nr=475
		// af parent scope:
		// af parent scope:
		return _t3081;
	}
	else if (string_eq(name, _SLIT("mach"))) {
		Option_string _t3082;
		opt_ok(&(string[]) { _SLIT("__MACH__") }, (Option*)(&_t3082), sizeof(string));
		// autofree_scope_vars(pos=13513 line_nr=488 scope.pos=13502 scope.end_pos=13534)
		// af parent scope:
		// var "g" var.pos=13274 var.line_nr=475
		// var "name" var.pos=13298 var.line_nr=475
		// var "is_comptime_optional" var.pos=13311 var.line_nr=475
		// af parent scope:
		// af parent scope:
		return _t3082;
	}
	else if (string_eq(name, _SLIT("darwin"))) {
		Option_string _t3083;
		opt_ok(&(string[]) { _SLIT("__DARWIN__") }, (Option*)(&_t3083), sizeof(string));
		// autofree_scope_vars(pos=13551 line_nr=491 scope.pos=13538 scope.end_pos=13574)
		// af parent scope:
		// var "g" var.pos=13274 var.line_nr=475
		// var "name" var.pos=13298 var.line_nr=475
		// var "is_comptime_optional" var.pos=13311 var.line_nr=475
		// af parent scope:
		// af parent scope:
		return _t3083;
	}
	else if (string_eq(name, _SLIT("hpux"))) {
		Option_string _t3084;
		opt_ok(&(string[]) { _SLIT("__HPUX__") }, (Option*)(&_t3084), sizeof(string));
		// autofree_scope_vars(pos=13589 line_nr=494 scope.pos=13578 scope.end_pos=13610)
		// af parent scope:
		// var "g" var.pos=13274 var.line_nr=475
		// var "name" var.pos=13298 var.line_nr=475
		// var "is_comptime_optional" var.pos=13311 var.line_nr=475
		// af parent scope:
		// af parent scope:
		return _t3084;
	}
	else if (string_eq(name, _SLIT("gnu"))) {
		Option_string _t3085;
		opt_ok(&(string[]) { _SLIT("__GNU__") }, (Option*)(&_t3085), sizeof(string));
		// autofree_scope_vars(pos=13624 line_nr=497 scope.pos=13614 scope.end_pos=13644)
		// af parent scope:
		// var "g" var.pos=13274 var.line_nr=475
		// var "name" var.pos=13298 var.line_nr=475
		// var "is_comptime_optional" var.pos=13311 var.line_nr=475
		// af parent scope:
		// af parent scope:
		return _t3085;
	}
	else if (string_eq(name, _SLIT("qnx"))) {
		Option_string _t3086;
		opt_ok(&(string[]) { _SLIT("__QNX__") }, (Option*)(&_t3086), sizeof(string));
		// autofree_scope_vars(pos=13658 line_nr=500 scope.pos=13648 scope.end_pos=13678)
		// af parent scope:
		// var "g" var.pos=13274 var.line_nr=475
		// var "name" var.pos=13298 var.line_nr=475
		// var "is_comptime_optional" var.pos=13311 var.line_nr=475
		// af parent scope:
		// af parent scope:
		return _t3086;
	}
	else if (string_eq(name, _SLIT("linux"))) {
		Option_string _t3087;
		opt_ok(&(string[]) { _SLIT("__linux__") }, (Option*)(&_t3087), sizeof(string));
		// autofree_scope_vars(pos=13694 line_nr=503 scope.pos=13682 scope.end_pos=13716)
		// af parent scope:
		// var "g" var.pos=13274 var.line_nr=475
		// var "name" var.pos=13298 var.line_nr=475
		// var "is_comptime_optional" var.pos=13311 var.line_nr=475
		// af parent scope:
		// af parent scope:
		return _t3087;
	}
	else if (string_eq(name, _SLIT("freebsd"))) {
		Option_string _t3088;
		opt_ok(&(string[]) { _SLIT("__FreeBSD__") }, (Option*)(&_t3088), sizeof(string));
		// autofree_scope_vars(pos=13734 line_nr=506 scope.pos=13720 scope.end_pos=13758)
		// af parent scope:
		// var "g" var.pos=13274 var.line_nr=475
		// var "name" var.pos=13298 var.line_nr=475
		// var "is_comptime_optional" var.pos=13311 var.line_nr=475
		// af parent scope:
		// af parent scope:
		return _t3088;
	}
	else if (string_eq(name, _SLIT("openbsd"))) {
		Option_string _t3089;
		opt_ok(&(string[]) { _SLIT("__OpenBSD__") }, (Option*)(&_t3089), sizeof(string));
		// autofree_scope_vars(pos=13776 line_nr=509 scope.pos=13762 scope.end_pos=13800)
		// af parent scope:
		// var "g" var.pos=13274 var.line_nr=475
		// var "name" var.pos=13298 var.line_nr=475
		// var "is_comptime_optional" var.pos=13311 var.line_nr=475
		// af parent scope:
		// af parent scope:
		return _t3089;
	}
	else if (string_eq(name, _SLIT("netbsd"))) {
		Option_string _t3090;
		opt_ok(&(string[]) { _SLIT("__NetBSD__") }, (Option*)(&_t3090), sizeof(string));
		// autofree_scope_vars(pos=13817 line_nr=512 scope.pos=13804 scope.end_pos=13840)
		// af parent scope:
		// var "g" var.pos=13274 var.line_nr=475
		// var "name" var.pos=13298 var.line_nr=475
		// var "is_comptime_optional" var.pos=13311 var.line_nr=475
		// af parent scope:
		// af parent scope:
		return _t3090;
	}
	else if (string_eq(name, _SLIT("bsd"))) {
		Option_string _t3091;
		opt_ok(&(string[]) { _SLIT("__BSD__") }, (Option*)(&_t3091), sizeof(string));
		// autofree_scope_vars(pos=13854 line_nr=515 scope.pos=13844 scope.end_pos=13874)
		// af parent scope:
		// var "g" var.pos=13274 var.line_nr=475
		// var "name" var.pos=13298 var.line_nr=475
		// var "is_comptime_optional" var.pos=13311 var.line_nr=475
		// af parent scope:
		// af parent scope:
		return _t3091;
	}
	else if (string_eq(name, _SLIT("dragonfly"))) {
		Option_string _t3092;
		opt_ok(&(string[]) { _SLIT("__DragonFly__") }, (Option*)(&_t3092), sizeof(string));
		// autofree_scope_vars(pos=13894 line_nr=518 scope.pos=13878 scope.end_pos=13920)
		// af parent scope:
		// var "g" var.pos=13274 var.line_nr=475
		// var "name" var.pos=13298 var.line_nr=475
		// var "is_comptime_optional" var.pos=13311 var.line_nr=475
		// af parent scope:
		// af parent scope:
		return _t3092;
	}
	else if (string_eq(name, _SLIT("android"))) {
		Option_string _t3093;
		opt_ok(&(string[]) { _SLIT("__ANDROID__") }, (Option*)(&_t3093), sizeof(string));
		// autofree_scope_vars(pos=13938 line_nr=521 scope.pos=13924 scope.end_pos=13962)
		// af parent scope:
		// var "g" var.pos=13274 var.line_nr=475
		// var "name" var.pos=13298 var.line_nr=475
		// var "is_comptime_optional" var.pos=13311 var.line_nr=475
		// af parent scope:
		// af parent scope:
		return _t3093;
	}
	else if (string_eq(name, _SLIT("solaris"))) {
		Option_string _t3094;
		opt_ok(&(string[]) { _SLIT("__sun") }, (Option*)(&_t3094), sizeof(string));
		// autofree_scope_vars(pos=13980 line_nr=524 scope.pos=13966 scope.end_pos=13998)
		// af parent scope:
		// var "g" var.pos=13274 var.line_nr=475
		// var "name" var.pos=13298 var.line_nr=475
		// var "is_comptime_optional" var.pos=13311 var.line_nr=475
		// af parent scope:
		// af parent scope:
		return _t3094;
	}
	else if (string_eq(name, _SLIT("haiku"))) {
		Option_string _t3095;
		opt_ok(&(string[]) { _SLIT("__haiku__") }, (Option*)(&_t3095), sizeof(string));
		// autofree_scope_vars(pos=14014 line_nr=527 scope.pos=14002 scope.end_pos=14036)
		// af parent scope:
		// var "g" var.pos=13274 var.line_nr=475
		// var "name" var.pos=13298 var.line_nr=475
		// var "is_comptime_optional" var.pos=13311 var.line_nr=475
		// af parent scope:
		// af parent scope:
		return _t3095;
	}
	else if (string_eq(name, _SLIT("linux_or_macos"))) {
		Option_string _t3096;
		opt_ok(&(string[]) { _SLIT("") }, (Option*)(&_t3096), sizeof(string));
		// autofree_scope_vars(pos=14061 line_nr=530 scope.pos=14040 scope.end_pos=14074)
		// af parent scope:
		// var "g" var.pos=13274 var.line_nr=475
		// var "name" var.pos=13298 var.line_nr=475
		// var "is_comptime_optional" var.pos=13311 var.line_nr=475
		// af parent scope:
		// af parent scope:
		return _t3096;
	}
	else if (string_eq(name, _SLIT("js"))) {
		Option_string _t3097;
		opt_ok(&(string[]) { _SLIT("_VJS") }, (Option*)(&_t3097), sizeof(string));
		// autofree_scope_vars(pos=14092 line_nr=534 scope.pos=14083 scope.end_pos=14109)
		// af parent scope:
		// var "g" var.pos=13274 var.line_nr=475
		// var "name" var.pos=13298 var.line_nr=475
		// var "is_comptime_optional" var.pos=13311 var.line_nr=475
		// af parent scope:
		// af parent scope:
		return _t3097;
	}
	else if (string_eq(name, _SLIT("gcc"))) {
		Option_string _t3098;
		opt_ok(&(string[]) { _SLIT("__V_GCC__") }, (Option*)(&_t3098), sizeof(string));
		// autofree_scope_vars(pos=14139 line_nr=538 scope.pos=14129 scope.end_pos=14161)
		// af parent scope:
		// var "g" var.pos=13274 var.line_nr=475
		// var "name" var.pos=13298 var.line_nr=475
		// var "is_comptime_optional" var.pos=13311 var.line_nr=475
		// af parent scope:
		// af parent scope:
		return _t3098;
	}
	else if (string_eq(name, _SLIT("tinyc"))) {
		Option_string _t3099;
		opt_ok(&(string[]) { _SLIT("__TINYC__") }, (Option*)(&_t3099), sizeof(string));
		// autofree_scope_vars(pos=14177 line_nr=541 scope.pos=14165 scope.end_pos=14199)
		// af parent scope:
		// var "g" var.pos=13274 var.line_nr=475
		// var "name" var.pos=13298 var.line_nr=475
		// var "is_comptime_optional" var.pos=13311 var.line_nr=475
		// af parent scope:
		// af parent scope:
		return _t3099;
	}
	else if (string_eq(name, _SLIT("clang"))) {
		Option_string _t3100;
		opt_ok(&(string[]) { _SLIT("__clang__") }, (Option*)(&_t3100), sizeof(string));
		// autofree_scope_vars(pos=14215 line_nr=544 scope.pos=14203 scope.end_pos=14237)
		// af parent scope:
		// var "g" var.pos=13274 var.line_nr=475
		// var "name" var.pos=13298 var.line_nr=475
		// var "is_comptime_optional" var.pos=13311 var.line_nr=475
		// af parent scope:
		// af parent scope:
		return _t3100;
	}
	else if (string_eq(name, _SLIT("mingw"))) {
		Option_string _t3101;
		opt_ok(&(string[]) { _SLIT("__MINGW32__") }, (Option*)(&_t3101), sizeof(string));
		// autofree_scope_vars(pos=14253 line_nr=547 scope.pos=14241 scope.end_pos=14277)
		// af parent scope:
		// var "g" var.pos=13274 var.line_nr=475
		// var "name" var.pos=13298 var.line_nr=475
		// var "is_comptime_optional" var.pos=13311 var.line_nr=475
		// af parent scope:
		// af parent scope:
		return _t3101;
	}
	else if (string_eq(name, _SLIT("msvc"))) {
		Option_string _t3102;
		opt_ok(&(string[]) { _SLIT("_MSC_VER") }, (Option*)(&_t3102), sizeof(string));
		// autofree_scope_vars(pos=14292 line_nr=550 scope.pos=14281 scope.end_pos=14313)
		// af parent scope:
		// var "g" var.pos=13274 var.line_nr=475
		// var "name" var.pos=13298 var.line_nr=475
		// var "is_comptime_optional" var.pos=13311 var.line_nr=475
		// af parent scope:
		// af parent scope:
		return _t3102;
	}
	else if (string_eq(name, _SLIT("cplusplus"))) {
		Option_string _t3103;
		opt_ok(&(string[]) { _SLIT("__cplusplus") }, (Option*)(&_t3103), sizeof(string));
		// autofree_scope_vars(pos=14333 line_nr=553 scope.pos=14317 scope.end_pos=14357)
		// af parent scope:
		// var "g" var.pos=13274 var.line_nr=475
		// var "name" var.pos=13298 var.line_nr=475
		// var "is_comptime_optional" var.pos=13311 var.line_nr=475
		// af parent scope:
		// af parent scope:
		return _t3103;
	}
	else if (string_eq(name, _SLIT("gcboehm"))) {
		Option_string _t3104;
		opt_ok(&(string[]) { _SLIT("_VGCBOEHM") }, (Option*)(&_t3104), sizeof(string));
		// autofree_scope_vars(pos=14387 line_nr=557 scope.pos=14373 scope.end_pos=14409)
		// af parent scope:
		// var "g" var.pos=13274 var.line_nr=475
		// var "name" var.pos=13298 var.line_nr=475
		// var "is_comptime_optional" var.pos=13311 var.line_nr=475
		// af parent scope:
		// af parent scope:
		return _t3104;
	}
	else if (string_eq(name, _SLIT("debug"))) {
		Option_string _t3105;
		opt_ok(&(string[]) { _SLIT("_VDEBUG") }, (Option*)(&_t3105), sizeof(string));
		// autofree_scope_vars(pos=14425 line_nr=560 scope.pos=14413 scope.end_pos=14445)
		// af parent scope:
		// var "g" var.pos=13274 var.line_nr=475
		// var "name" var.pos=13298 var.line_nr=475
		// var "is_comptime_optional" var.pos=13311 var.line_nr=475
		// af parent scope:
		// af parent scope:
		return _t3105;
	}
	else if (string_eq(name, _SLIT("prod"))) {
		Option_string _t3106;
		opt_ok(&(string[]) { _SLIT("_VPROD") }, (Option*)(&_t3106), sizeof(string));
		// autofree_scope_vars(pos=14460 line_nr=563 scope.pos=14449 scope.end_pos=14479)
		// af parent scope:
		// var "g" var.pos=13274 var.line_nr=475
		// var "name" var.pos=13298 var.line_nr=475
		// var "is_comptime_optional" var.pos=13311 var.line_nr=475
		// af parent scope:
		// af parent scope:
		return _t3106;
	}
	else if (string_eq(name, _SLIT("test"))) {
		Option_string _t3107;
		opt_ok(&(string[]) { _SLIT("_VTEST") }, (Option*)(&_t3107), sizeof(string));
		// autofree_scope_vars(pos=14494 line_nr=566 scope.pos=14483 scope.end_pos=14513)
		// af parent scope:
		// var "g" var.pos=13274 var.line_nr=475
		// var "name" var.pos=13298 var.line_nr=475
		// var "is_comptime_optional" var.pos=13311 var.line_nr=475
		// af parent scope:
		// af parent scope:
		return _t3107;
	}
	else if (string_eq(name, _SLIT("glibc"))) {
		Option_string _t3108;
		opt_ok(&(string[]) { _SLIT("__GLIBC__") }, (Option*)(&_t3108), sizeof(string));
		// autofree_scope_vars(pos=14529 line_nr=569 scope.pos=14517 scope.end_pos=14551)
		// af parent scope:
		// var "g" var.pos=13274 var.line_nr=475
		// var "name" var.pos=13298 var.line_nr=475
		// var "is_comptime_optional" var.pos=13311 var.line_nr=475
		// af parent scope:
		// af parent scope:
		return _t3108;
	}
	else if (string_eq(name, _SLIT("prealloc"))) {
		Option_string _t3109;
		opt_ok(&(string[]) { _SLIT("_VPREALLOC") }, (Option*)(&_t3109), sizeof(string));
		// autofree_scope_vars(pos=14570 line_nr=572 scope.pos=14555 scope.end_pos=14593)
		// af parent scope:
		// var "g" var.pos=13274 var.line_nr=475
		// var "name" var.pos=13298 var.line_nr=475
		// var "is_comptime_optional" var.pos=13311 var.line_nr=475
		// af parent scope:
		// af parent scope:
		return _t3109;
	}
	else if (string_eq(name, _SLIT("no_bounds_checking"))) {
		Option_string _t3110;
		opt_ok(&(string[]) { _SLIT("CUSTOM_DEFINE_no_bounds_checking") }, (Option*)(&_t3110), sizeof(string));
		// autofree_scope_vars(pos=14622 line_nr=575 scope.pos=14597 scope.end_pos=14667)
		// af parent scope:
		// var "g" var.pos=13274 var.line_nr=475
		// var "name" var.pos=13298 var.line_nr=475
		// var "is_comptime_optional" var.pos=13311 var.line_nr=475
		// af parent scope:
		// af parent scope:
		return _t3110;
	}
	else if (string_eq(name, _SLIT("freestanding"))) {
		Option_string _t3111;
		opt_ok(&(string[]) { _SLIT("_VFREESTANDING") }, (Option*)(&_t3111), sizeof(string));
		// autofree_scope_vars(pos=14690 line_nr=578 scope.pos=14671 scope.end_pos=14717)
		// af parent scope:
		// var "g" var.pos=13274 var.line_nr=475
		// var "name" var.pos=13298 var.line_nr=475
		// var "is_comptime_optional" var.pos=13311 var.line_nr=475
		// af parent scope:
		// af parent scope:
		return _t3111;
	}
	else if (string_eq(name, _SLIT("amd64"))) {
		Option_string _t3112;
		opt_ok(&(string[]) { _SLIT("__V_amd64") }, (Option*)(&_t3112), sizeof(string));
		// autofree_scope_vars(pos=14753 line_nr=582 scope.pos=14741 scope.end_pos=14775)
		// af parent scope:
		// var "g" var.pos=13274 var.line_nr=475
		// var "name" var.pos=13298 var.line_nr=475
		// var "is_comptime_optional" var.pos=13311 var.line_nr=475
		// af parent scope:
		// af parent scope:
		return _t3112;
	}
	else if (string_eq(name, _SLIT("aarch64"))) {
		Option_string _t3113;
		opt_ok(&(string[]) { _SLIT("__V_aarch64") }, (Option*)(&_t3113), sizeof(string));
		// autofree_scope_vars(pos=14793 line_nr=585 scope.pos=14779 scope.end_pos=14817)
		// af parent scope:
		// var "g" var.pos=13274 var.line_nr=475
		// var "name" var.pos=13298 var.line_nr=475
		// var "is_comptime_optional" var.pos=13311 var.line_nr=475
		// af parent scope:
		// af parent scope:
		return _t3113;
	}
	else if (string_eq(name, _SLIT("x64"))) {
		Option_string _t3114;
		opt_ok(&(string[]) { _SLIT("TARGET_IS_64BIT") }, (Option*)(&_t3114), sizeof(string));
		// autofree_scope_vars(pos=14845 line_nr=589 scope.pos=14835 scope.end_pos=14873)
		// af parent scope:
		// var "g" var.pos=13274 var.line_nr=475
		// var "name" var.pos=13298 var.line_nr=475
		// var "is_comptime_optional" var.pos=13311 var.line_nr=475
		// af parent scope:
		// af parent scope:
		return _t3114;
	}
	else if (string_eq(name, _SLIT("x32"))) {
		Option_string _t3115;
		opt_ok(&(string[]) { _SLIT("TARGET_IS_32BIT") }, (Option*)(&_t3115), sizeof(string));
		// autofree_scope_vars(pos=14887 line_nr=592 scope.pos=14877 scope.end_pos=14915)
		// af parent scope:
		// var "g" var.pos=13274 var.line_nr=475
		// var "name" var.pos=13298 var.line_nr=475
		// var "is_comptime_optional" var.pos=13311 var.line_nr=475
		// af parent scope:
		// af parent scope:
		return _t3115;
	}
	else if (string_eq(name, _SLIT("little_endian"))) {
		Option_string _t3116;
		opt_ok(&(string[]) { _SLIT("TARGET_ORDER_IS_LITTLE") }, (Option*)(&_t3116), sizeof(string));
		// autofree_scope_vars(pos=14956 line_nr=596 scope.pos=14936 scope.end_pos=14991)
		// af parent scope:
		// var "g" var.pos=13274 var.line_nr=475
		// var "name" var.pos=13298 var.line_nr=475
		// var "is_comptime_optional" var.pos=13311 var.line_nr=475
		// af parent scope:
		// af parent scope:
		return _t3116;
	}
	else if (string_eq(name, _SLIT("big_endian"))) {
		Option_string _t3117;
		opt_ok(&(string[]) { _SLIT("TARGET_ORDER_IS_BIG") }, (Option*)(&_t3117), sizeof(string));
		// autofree_scope_vars(pos=15012 line_nr=599 scope.pos=14995 scope.end_pos=15044)
		// af parent scope:
		// var "g" var.pos=13274 var.line_nr=475
		// var "name" var.pos=13298 var.line_nr=475
		// var "is_comptime_optional" var.pos=13311 var.line_nr=475
		// af parent scope:
		// af parent scope:
		return _t3117;
	}
	else {
		if (is_comptime_optional || (g->pref->compile_defines_all.len > 0 && (Array_string_contains(g->pref->compile_defines_all, name)))) {
			Option_string _t3118;
			opt_ok(&(string[]) { _STR("CUSTOM_DEFINE_%.*s", 1, name) }, (Option*)(&_t3118), sizeof(string));
			// autofree_scope_vars(pos=15169 line_nr=604 scope.pos=15164 scope.end_pos=15202)
			// af parent scope:
			// af parent scope:
			// var "g" var.pos=13274 var.line_nr=475
			// var "name" var.pos=13298 var.line_nr=475
			// var "is_comptime_optional" var.pos=13311 var.line_nr=475
			// af parent scope:
			// af parent scope:
			return _t3118;
		}
		return (Option_string){ .state=2, .err=v_error(_STR("bad os ifdef name \"%.*s\000\"", 2, name)) };
	};
	return (Option_string){ .state=2, .err=_const_none__ };
}

VV_LOCAL_SYMBOL v__ast__CTempVar v__gen__c__Gen_new_ctemp_var(v__gen__c__Gen* g, v__ast__Expr expr, v__ast__Type expr_type) {
	 v__ast__CTempVar _t3119 = (v__ast__CTempVar){.name = v__gen__c__Gen_new_tmp_var(g),.orig = expr,.typ = expr_type,.is_ptr = v__ast__Type_is_ptr(expr_type),};
	// autofree_scope_vars(pos=103 line_nr=5 scope.pos=27 scope.end_pos=211)
	// var "g" var.pos=32 var.line_nr=4
	// var "expr" var.pos=53 var.line_nr=4
	// var "expr_type" var.pos=68 var.line_nr=4
	// af parent scope:
	// af parent scope:
	return _t3119;
}

VV_LOCAL_SYMBOL v__ast__CTempVar v__gen__c__Gen_new_ctemp_var_then_gen(v__gen__c__Gen* g, v__ast__Expr expr, v__ast__Type expr_type) {
	v__ast__CTempVar x = v__gen__c__Gen_new_ctemp_var(g, expr, expr_type);
	v__gen__c__Gen_gen_ctemp_var(g, x);
	// autofree_scope_vars(pos=361 line_nr=16 scope.pos=217 scope.end_pos=371)
	// var "g" var.pos=222 var.line_nr=13
	// var "expr" var.pos=252 var.line_nr=13
	// var "expr_type" var.pos=267 var.line_nr=13
	// var "x" var.pos=303 var.line_nr=14
	// af parent scope:
	// af parent scope:
	return x;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_ctemp_var(v__gen__c__Gen* g, v__ast__CTempVar tvar) {
	string styp = v__gen__c__Gen_typ(g, tvar.typ);
	v__gen__c__Gen_write(g, _STR("%.*s\000 %.*s\000 = ", 3, styp, tvar.name));
	v__gen__c__Gen_expr(g, tvar.orig);
	v__gen__c__Gen_writeln(g, _SLIT(";"));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_dump_expr(v__gen__c__Gen* g, v__ast__DumpExpr node) {
	string sexpr = v__gen__c__ctoslit(v__ast__Expr_str(node.expr));
	string fpath = v__gen__c__cestring(g->file.path);
	int line = node.pos.line_nr + 1;
	if ((Array_string_contains(g->pref->compile_defines, _SLIT("nop_dump")))) {
		v__gen__c__Gen_expr(g, node.expr);
		return;
	}
	string dump_fn_name = string_add(_STR("_v_dump_expr_%.*s", 1, node.cname), ((v__ast__Type_is_ptr(node.expr_type) ? (_SLIT("_ptr")) : (_SLIT("")))));
	v__gen__c__Gen_write(g, _STR(" %.*s\000(%.*s\000, %"PRId32"\000, %.*s\000, ", 5, dump_fn_name, v__gen__c__ctoslit(fpath), line, sexpr));
	v__gen__c__Gen_expr(g, node.expr);
	v__gen__c__Gen_write(g, _SLIT(" )"));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_dump_expr_definitions(v__gen__c__Gen* g) {
	if (g->pref->build_mode == v__pref__BuildMode_build_module) {
		// FOR IN map
		Map_int_string _t3120 = g->table->dumps;
		int _t3122 = _t3120.key_values.len;
		for (int _t3121 = 0; _t3121 < _t3122; ++_t3121 ) {
			int _t3123 = _t3120.key_values.len - _t3122;
			_t3122 = _t3120.key_values.len;
			if (_t3123 < 0) {
				_t3121 = -1;
				continue;
			}
			if (!DenseArray_has_index(&_t3120.key_values, _t3121)) {continue;}
			int dump_type = /*key*/ *(int*)DenseArray_key(&_t3120.key_values, _t3121);
			string cname = (*(string*)DenseArray_value(&_t3120.key_values, _t3121));
			bool is_ptr = v__ast__Type_is_ptr(((dump_type)));
			string ptr_suffix = (is_ptr ? (_SLIT("*")) : (_SLIT("")));
			string dump_fn_name = string_add(_STR("_v_dump_expr_%.*s", 1, cname), ((is_ptr ? (_SLIT("_ptr")) : (_SLIT("")))));
			strings__Builder_writeln(&g->definitions, _STR("%.*s\000%.*s\000 %.*s\000(string fpath, int line, string sexpr, %.*s\000%.*s\000 x) {", 6, cname, ptr_suffix, dump_fn_name, cname, ptr_suffix));
		}
	} else {
		// FOR IN map
		Map_int_string _t3124 = g->table->dumps;
		int _t3126 = _t3124.key_values.len;
		for (int _t3125 = 0; _t3125 < _t3126; ++_t3125 ) {
			int _t3127 = _t3124.key_values.len - _t3126;
			_t3126 = _t3124.key_values.len;
			if (_t3127 < 0) {
				_t3125 = -1;
				continue;
			}
			if (!DenseArray_has_index(&_t3124.key_values, _t3125)) {continue;}
			int dump_type = /*key*/ *(int*)DenseArray_key(&_t3124.key_values, _t3125);
			string cname = (*(string*)DenseArray_value(&_t3124.key_values, _t3125));
			string to_string_fn_name = v__gen__c__Gen_gen_str_for_type(g, dump_type);
			bool is_ptr = v__ast__Type_is_ptr(((dump_type)));
			string ptr_astarisk = (is_ptr ? (_SLIT("*")) : (_SLIT("")));
			string dump_fn_name = string_add(_STR("_v_dump_expr_%.*s", 1, cname), ((is_ptr ? (_SLIT("_ptr")) : (_SLIT("")))));
			strings__Builder_writeln(&g->definitions, _STR("%.*s\000%.*s\000 %.*s\000(string fpath, int line, string sexpr, %.*s\000%.*s\000 x) {", 6, cname, ptr_astarisk, dump_fn_name, cname, ptr_astarisk));
			strings__Builder_writeln(&g->definitions, _STR("\teprint(%.*s\000);", 2, v__gen__c__ctoslit(_SLIT("["))));
			strings__Builder_writeln(&g->definitions, _SLIT("\teprint(fpath);"));
			strings__Builder_writeln(&g->definitions, _STR("\teprint(%.*s\000);", 2, v__gen__c__ctoslit(_SLIT(":"))));
			strings__Builder_writeln(&g->definitions, _SLIT("\teprint(int_str(line));"));
			strings__Builder_writeln(&g->definitions, _STR("\teprint(%.*s\000);", 2, v__gen__c__ctoslit(_SLIT("] "))));
			strings__Builder_writeln(&g->definitions, _SLIT("\teprint(sexpr);"));
			strings__Builder_writeln(&g->definitions, _STR("\teprint(%.*s\000);", 2, v__gen__c__ctoslit(_SLIT(": "))));
			if (is_ptr) {
				strings__Builder_writeln(&g->definitions, _STR("\teprint(%.*s\000);", 2, v__gen__c__ctoslit(_SLIT("&"))));
			}
			strings__Builder_writeln(&g->definitions, _STR("\teprintln(%.*s\000(%.*s\000x));", 3, to_string_fn_name, ptr_astarisk));
			strings__Builder_writeln(&g->definitions, _SLIT("\treturn x;"));
			strings__Builder_writeln(&g->definitions, _SLIT("}"));
		}
	}
}

VV_LOCAL_SYMBOL bool v__gen__c__Gen_embed_file_is_prod_mode(v__gen__c__Gen* g) {
	if (g->pref->is_prod || (Array_string_contains(g->pref->compile_defines, _SLIT("debug_embed_file_in_prod")))) {
		 bool _t3128 = true;
		// autofree_scope_vars(pos=160 line_nr=7 scope.pos=157 scope.end_pos=174)
		// af parent scope:
		// var "g" var.pos=42 var.line_nr=5
		// af parent scope:
		// af parent scope:
		return _t3128;
	}
	 bool _t3129 = false;
	// autofree_scope_vars(pos=176 line_nr=9 scope.pos=37 scope.end_pos=190)
	// var "g" var.pos=42 var.line_nr=5
	// af parent scope:
	// af parent scope:
	return _t3129;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_embed_file_init(v__gen__c__Gen* g, v__ast__ComptimeCall node) {
	v__gen__c__Gen_writeln(g, _SLIT("(v__embed_file__EmbedFileData){"));
	v__gen__c__Gen_writeln(g, _STR("\t\t.path = %.*s\000,", 2, v__gen__c__ctoslit(node.embed_file.rpath)));
	v__gen__c__Gen_writeln(g, _STR("\t\t.apath = %.*s\000,", 2, v__gen__c__ctoslit(node.embed_file.apath)));
	u64 file_size = os__file_size(node.embed_file.apath);
	if (file_size > 5242880) {
		eprintln(_SLIT("Warning: embedding of files >= ~5MB is currently not supported"));
	}
	if (v__gen__c__Gen_embed_file_is_prod_mode(g)) {
		v__gen__c__Gen_writeln(g, _STR("\t\t.compressed = v__embed_file__find_index_entry_by_path((voidptr)_v_embed_file_index, %.*s\000)->data,", 2, v__gen__c__ctoslit(node.embed_file.rpath)));
	}
	v__gen__c__Gen_writeln(g, _SLIT("\t\t.uncompressed = NULL,"));
	v__gen__c__Gen_writeln(g, _SLIT("\t\t.free_compressed = 0,"));
	v__gen__c__Gen_writeln(g, _SLIT("\t\t.free_uncompressed = 0,"));
	v__gen__c__Gen_writeln(g, _STR("\t\t.len = %"PRIu64"", 1, file_size));
	v__gen__c__Gen_writeln(g, _STR("} // $embed_file(\"%.*s\000\")", 2, node.embed_file.apath));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_embedded_data(v__gen__c__Gen* g) {
	// FOR IN array
	for (int i = 0; i < g->embedded_files.len; ++i) {
		v__ast__EmbeddedFile emfile = ((v__ast__EmbeddedFile*)g->embedded_files.data)[i];
		Option_Array_byte _t3130 = os__read_bytes(emfile.apath);
		if (_t3130.state != 0) { /*or block*/ 
			IError err = _t3130.err;
			v_panic(_STR("Error while embedding file: %.*s", 1, IError_str(err)));
		}
 		Array_byte fbytes =  *(Array_byte*)_t3130.data;
		strings__Builder_write_string(&g->embedded_data, _STR("static const unsigned char _v_embed_blob_%"PRId32"\000[%"PRId32"\000] = {\n    ", 3, i, fbytes.len));
		for (int j = 0; j < fbytes.len; j++) {
			string b = byte_hex((*(byte*)/*ee elem_typ */array_get(fbytes, j)));
			if (j < fbytes.len - 1) {
				strings__Builder_write_string(&g->embedded_data, _STR("0x%.*s\000,", 2, b));
			} else {
				strings__Builder_write_string(&g->embedded_data, _STR("0x%.*s", 1, b));
			}
			if (0 == ((j + 1) % 16)) {
				strings__Builder_write_string(&g->embedded_data, _SLIT("\n    "));
			}
		}
		strings__Builder_writeln(&g->embedded_data, _SLIT("\n};"));
	}
	strings__Builder_writeln(&g->embedded_data, _SLIT(""));
	strings__Builder_writeln(&g->embedded_data, _SLIT("const v__embed_file__EmbedFileIndexEntry _v_embed_file_index[] = {"));
	// FOR IN array
	for (int i = 0; i < g->embedded_files.len; ++i) {
		v__ast__EmbeddedFile emfile = ((v__ast__EmbeddedFile*)g->embedded_files.data)[i];
		strings__Builder_writeln(&g->embedded_data, _STR("\t{%"PRId32"\000, %.*s\000, _v_embed_blob_%"PRId32"\000},", 4, i, v__gen__c__ctoslit(emfile.rpath), i));
	}
	strings__Builder_writeln(&g->embedded_data, _SLIT("\t{-1, _SLIT(\"\"), NULL}"));
	strings__Builder_writeln(&g->embedded_data, _SLIT("};"));
}

VV_LOCAL_SYMBOL bool v__gen__c__Gen_is_used_by_main(v__gen__c__Gen* g, v__ast__FnDecl node) {
	bool is_used_by_main = true;
	if (g->pref->skip_unused) {
		string fkey = (node.is_method ? (_STR("%"PRId32"\000.%.*s", 2, ((int)(node.receiver.typ)), node.name)) : (node.name));
		is_used_by_main = (*(bool*)map_get(ADDR(map, g->table->used_fns), &(string[]){fkey}, &(bool[]){ 0 }));
		if (!is_used_by_main) {
		}
	} else {
	}
	// autofree_scope_vars(pos=987 line_nr=27 scope.pos=211 scope.end_pos=1011)
	// var "g" var.pos=216 var.line_nr=8
	// var "node" var.pos=239 var.line_nr=8
	// var "is_used_by_main" var.pos=268 var.line_nr=9
	// af parent scope:
	// af parent scope:
	return is_used_by_main;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_process_fn_decl(v__gen__c__Gen* g, v__ast__FnDecl node) {
	if (!v__gen__c__Gen_is_used_by_main(g, node)) {
		return;
	}
	if (g->is_builtin_mod && g->pref->gc_mode == v__pref__GarbageCollectionMode_boehm_leak && string_eq(node.name, _SLIT("malloc"))) {
		strings__Builder_write_string(&g->definitions, _SLIT("#define v_malloc GC_MALLOC\n"));
		return;
	}
	v__gen__c__Gen_gen_attrs(g, node.attrs);
	bool skip = false;
	int pos = g->out.buf.len;
	bool should_bundle_module = v__util__should_bundle_module(node.mod);
	if (g->pref->build_mode == v__pref__BuildMode_build_module) {
		string mod = (g->is_builtin_mod ? (_SLIT("builtin")) : (string_all_before_last(node.name, _SLIT("."))));
		if ((string_ne(mod, g->module_built) && string_ne(node.mod, string_after(g->module_built, _SLIT("/")))) || should_bundle_module) {
			skip = true;
		}
		if (g->is_builtin_mod && string_eq(g->module_built, _SLIT("builtin")) && string_eq(node.mod, _SLIT("builtin"))) {
			skip = false;
		}
		if (!skip && g->pref->is_verbose) {
			println(_STR("build module `%.*s\000` fn `%.*s\000`", 3, g->module_built, node.name));
		}
	}
	if (g->pref->use_cache) {
		if (string_ne(node.mod, _SLIT("main")) && string_ne(node.mod, _SLIT("help")) && !should_bundle_module && !g->pref->is_test && node.generic_names.len == 0) {
			skip = true;
		}
	}
	v__ast__FnDecl* keep_fn_decl = g->fn_decl;
	g->fn_decl = &node;
	if (string_eq(node.name, _SLIT("main.main"))) {
		g->has_main = true;
	}
	if (string_eq(node.name, _SLIT("backtrace")) || string_eq(node.name, _SLIT("backtrace_symbols")) || string_eq(node.name, _SLIT("backtrace_symbols_fd"))) {
		v__gen__c__Gen_write(g, _SLIT("\n#ifndef __cplusplus\n"));
	}
	v__gen__c__Gen_gen_fn_decl(g, node, skip);
	if (string_eq(node.name, _SLIT("backtrace")) || string_eq(node.name, _SLIT("backtrace_symbols")) || string_eq(node.name, _SLIT("backtrace_symbols_fd"))) {
		v__gen__c__Gen_write(g, _SLIT("\n#endif\n"));
	}
	g->fn_decl = keep_fn_decl;
	if (skip) {
		strings__Builder_go_back_to(&g->out, pos);
	}
	if (!g->pref->skip_unused) {
		if (node.language != v__ast__Language_c) {
			v__gen__c__Gen_writeln(g, _SLIT(""));
		}
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_fn_decl(v__gen__c__Gen* g, v__ast__FnDecl node, bool skip) {
bool v__gen__c__Gen_gen_fn_decl_defer_0 = false;
bool v__gen__c__Gen_gen_fn_decl_defer_1 = false;
bool v__gen__c__Gen_gen_fn_decl_defer_2 = false;
	if (node.language == v__ast__Language_c) {
		return;
	}
	g->returned_var_name = _SLIT("");
	bool old_g_autofree = g->is_autofree;
	if (node.is_manualfree) {
		g->is_autofree = false;
	}
	v__gen__c__Gen_gen_fn_decl_defer_0 = true;
	if (node.generic_names.len > 0 && g->cur_generic_types.len == 0) {
		// FOR IN array
		Array_Array_v__ast__Type _t3131 = (*(Array_Array_v__ast__Type*)map_get(ADDR(map, g->table->fn_gen_types), &(string[]){node.name}, &(Array_Array_v__ast__Type[]){ __new_array(0, 1, sizeof(Array_v__ast__Type)) }));
		for (int _t3132 = 0; _t3132 < _t3131.len; ++_t3132) {
			Array_v__ast__Type gen_types = ((Array_v__ast__Type*)_t3131.data)[_t3132];
			if (g->pref->is_verbose) {
				Array_v__ast__Type _t3133_orig = gen_types;
				int _t3133_len = _t3133_orig.len;
				Array_v__ast__TypeSymbol_ptr _t3133 = __new_array(0, _t3133_len, sizeof(v__ast__TypeSymbol*));

				for (int _t3134 = 0; _t3134 < _t3133_len; ++_t3134) {
					v__ast__Type it = ((v__ast__Type*) _t3133_orig.data)[_t3134];
					v__ast__TypeSymbol* ti = v__ast__Table_get_type_symbol(g->table, it);
					array_push(&_t3133, &ti);
				}
				
				Array_v__ast__TypeSymbol_ptr syms = _t3133;
				Array_v__ast__TypeSymbol_ptr _t3135_orig = syms;
				int _t3135_len = _t3135_orig.len;
				Array_string _t3135 = __new_array(0, _t3135_len, sizeof(string));

				for (int _t3136 = 0; _t3136 < _t3135_len; ++_t3136) {
					v__ast__TypeSymbol* it = ((v__ast__TypeSymbol**) _t3135_orig.data)[_t3136];
					string ti = node.name;
					array_push(&_t3135, &ti);
				}
				
				string the_type = Array_string_join(_t3135, _SLIT(", "));
				println(_STR("gen fn `%.*s\000` for type `%.*s\000`", 3, node.name, the_type));
			}
			g->cur_generic_types = gen_types;
			v__gen__c__Gen_gen_fn_decl(g, node, skip);
		}
		g->cur_generic_types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
		// Defer begin
		if (v__gen__c__Gen_gen_fn_decl_defer_0 == true) {
			g->is_autofree = old_g_autofree;
		}
		// Defer end
		return;
	}
	v__ast__FnDecl cur_fn_save = g->cur_fn;
	v__gen__c__Gen_gen_fn_decl_defer_1 = true;
	g->cur_fn = node;
	int fn_start_pos = g->out.len;
	v__gen__c__Gen_write_v_source_line_info(g, node.pos);
	string msvc_attrs = v__gen__c__Gen_write_fn_attrs(g, node.attrs);
	bool is_livefn = Array_v__ast__Attr_contains(node.attrs, _SLIT("live"));
	bool is_livemain = g->pref->is_livemain && is_livefn;
	bool is_liveshared = g->pref->is_liveshared && is_livefn;
	bool is_livemode = g->pref->is_livemain || g->pref->is_liveshared;
	bool is_live_wrap = is_livefn && is_livemode;
	if (is_livefn && !is_livemode) {
		eprintln(_STR("INFO: compile with `v -live %.*s\000 `, if you want to use the [live] function %.*s\000 .", 3, g->pref->path, node.name));
	}
	string name = node.name;
	if ((string_eq(name, _SLIT("+")) || string_eq(name, _SLIT("-")) || string_eq(name, _SLIT("*")) || string_eq(name, _SLIT("/")) || string_eq(name, _SLIT("%")) || string_eq(name, _SLIT("<")) || string_eq(name, _SLIT("==")))) {
		name = v__util__replace_op(name);
	}
	if (node.is_method) {
		name = string_add(string_add(v__gen__c__Gen_cc_type(g, node.receiver.typ, false), _SLIT("_")), name);
	}
	if (node.language == v__ast__Language_c) {
		name = v__util__no_dots(name);
	} else {
		name = v__gen__c__c_name(name);
	}
	string type_name = v__gen__c__Gen_typ(g, node.return_type);
	if (g->cur_generic_types.len > 0) {
		name = /*f*/string_add(name, _SLIT("_T"));
		// FOR IN array
		for (int _t3137 = 0; _t3137 < g->cur_generic_types.len; ++_t3137) {
			v__ast__Type generic_type = ((v__ast__Type*)g->cur_generic_types.data)[_t3137];
			string gen_name = v__gen__c__Gen_typ(g, generic_type);
			name = /*f*/string_add(name, string_add(_SLIT("_"), gen_name));
		}
	}
	if (g->pref->obfuscate && string_eq(g->cur_mod.name, _SLIT("main")) && string_starts_with(name, _SLIT("main__")) && string_ne(name, _SLIT("main__main")) && string_ne(node.name, _SLIT("str"))) {
		string key = node.name;
		if (node.is_method) {
			v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, node.receiver.typ);
			key = string_add(string_add(sym->name, _SLIT(".")), node.name);
		}
		v__gen__c__Gen_writeln(g, _STR("/* obf: %.*s\000 */", 2, key));
		string* _t3139 = (string*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, g->obf_table), &(string[]){key}));
		Option_string _t3138 = {0};
		if (_t3139) {
			*((string*)&_t3138.data) = *((string*)_t3139);
		} else {
			_t3138.state = 2; _t3138.err = v_error(_SLIT("array index out of range"));
		}
		;
		if (_t3138.state != 0) { /*or block*/ 
			IError err = _t3138.err;
			v_panic(_STR("cgen: fn_decl: obf name \"%.*s\000\" not found, this should never happen", 2, key));
		}
		name = *(string*)_t3138.data;
	}
	if (is_livemain) {
		array_push(&g->hotcode_fn_names, _MOV((string[]){ string_clone(name) }));
	}
	string impl_fn_name = name;
	if (is_live_wrap) {
		impl_fn_name = _STR("impl_live_%.*s", 1, name);
	}
	string last_fn_c_name_save = g->last_fn_c_name;
	v__gen__c__Gen_gen_fn_decl_defer_2 = true;
	g->last_fn_c_name = impl_fn_name;
	if (is_live_wrap) {
		if (is_livemain) {
			strings__Builder_write_string(&g->definitions, _STR("%.*s\000 (* %.*s\000)(", 3, type_name, impl_fn_name));
			v__gen__c__Gen_write(g, _STR("%.*s\000 no_impl_%.*s\000(", 3, type_name, name));
		}
		if (is_liveshared) {
			strings__Builder_write_string(&g->definitions, _STR("%.*s\000 %.*s\000(", 3, type_name, impl_fn_name));
			v__gen__c__Gen_write(g, _STR("%.*s\000 %.*s\000(", 3, type_name, impl_fn_name));
		}
	} else {
		if (!(node.is_pub || g->pref->is_debug)) {
			if (g->pref->build_mode != v__pref__BuildMode_build_module && !g->pref->use_cache) {
				v__gen__c__Gen_write(g, _SLIT("VV_LOCAL_SYMBOL "));
				strings__Builder_write_string(&g->definitions, _SLIT("VV_LOCAL_SYMBOL "));
			}
		}
		string fn_header = (msvc_attrs.len > 0 ? (_STR("%.*s\000 %.*s\000 %.*s\000(", 4, type_name, msvc_attrs, name)) : (_STR("%.*s\000 %.*s\000(", 3, type_name, name)));
		strings__Builder_write_string(&g->definitions, fn_header);
		v__gen__c__Gen_write(g, fn_header);
	}
	int arg_start_pos = g->out.len;
	multi_return_Array_string_Array_string mr_7722 = v__gen__c__Gen_fn_args(g, node.params, node.is_variadic);
	Array_string fargs = mr_7722.arg0;
	Array_string fargtypes = mr_7722.arg1;
	string arg_str = strings__Builder_after(&g->out, arg_start_pos);
	if (node.no_body || ((g->pref->use_cache && g->pref->build_mode != v__pref__BuildMode_build_module) && node.is_builtin && !g->is_test) || skip) {
		strings__Builder_writeln(&g->definitions, _SLIT(");"));
		v__gen__c__Gen_writeln(g, _SLIT(");"));
		// Defer begin
		if (v__gen__c__Gen_gen_fn_decl_defer_2 == true) {
			g->last_fn_c_name = last_fn_c_name_save;
		}
		// Defer end
		// Defer begin
		if (v__gen__c__Gen_gen_fn_decl_defer_1 == true) {
			g->cur_fn = cur_fn_save;
		}
		// Defer end
		// Defer begin
		if (v__gen__c__Gen_gen_fn_decl_defer_0 == true) {
			g->is_autofree = old_g_autofree;
		}
		// Defer end
		return;
	}
	strings__Builder_writeln(&g->definitions, _SLIT(");"));
	v__gen__c__Gen_writeln(g, _SLIT(") {"));
	// FOR IN array
	for (int _t3141 = 0; _t3141 < node.defer_stmts.len; ++_t3141) {
		v__ast__DeferStmt defer_stmt = ((v__ast__DeferStmt*)node.defer_stmts.data)[_t3141];
		v__gen__c__Gen_writeln(g, _STR("bool %.*s\000 = false;", 2, v__gen__c__Gen_defer_flag_var(g, (voidptr)&/*qq*/defer_stmt)));
	}
	if (is_live_wrap) {
		Array_string fn_args_list = __new_array_with_default(0, 0, sizeof(string), 0);
		// FOR IN array
		for (int ia = 0; ia < fargs.len; ++ia) {
			string fa = ((string*)fargs.data)[ia];
			array_push(&fn_args_list, _MOV((string[]){ string_clone(_STR("%.*s\000 %.*s", 2, (*(string*)/*ee elem_typ */array_get(fargtypes, ia)), fa)) }));
		}
		string live_fncall = string_add(string_add(_STR("%.*s\000(", 2, impl_fn_name), Array_string_join(fargs, _SLIT(", "))), _SLIT(");"));
		string live_fnreturn = _SLIT("");
		if (string_ne(type_name, _SLIT("void"))) {
			live_fncall = _STR("%.*s\000 res = %.*s", 2, type_name, live_fncall);
			live_fnreturn = _SLIT("return res;");
		}
		strings__Builder_writeln(&g->definitions, string_add(string_add(_STR("%.*s\000 %.*s\000(", 3, type_name, name), Array_string_join(fn_args_list, _SLIT(", "))), _SLIT(");")));
		strings__Builder_writeln(&g->hotcode_definitions, string_add(string_add(_STR("%.*s\000 %.*s\000(", 3, type_name, name), Array_string_join(fn_args_list, _SLIT(", "))), _SLIT("){")));
		strings__Builder_writeln(&g->hotcode_definitions, _SLIT("  pthread_mutex_lock(&live_fn_mutex);"));
		strings__Builder_writeln(&g->hotcode_definitions, _STR("  %.*s", 1, live_fncall));
		strings__Builder_writeln(&g->hotcode_definitions, _SLIT("  pthread_mutex_unlock(&live_fn_mutex);"));
		strings__Builder_writeln(&g->hotcode_definitions, _STR("  %.*s", 1, live_fnreturn));
		strings__Builder_writeln(&g->hotcode_definitions, _SLIT("}"));
	}
	if (g->pref->is_prof && g->pref->build_mode != v__pref__BuildMode_build_module) {
		v__gen__c__Gen_profile_fn(g, node);
	}
	Array_v__ast__DeferStmt prev_defer_stmts = g->defer_stmts;
	g->defer_stmts = __new_array_with_default(0, 0, sizeof(v__ast__DeferStmt), 0);
	v__gen__c__Gen_stmts(g, node.stmts);
	if (!node.has_return) {
		v__gen__c__Gen_write_defer_stmts_when_needed(g);
	}
	if (node.is_anon) {
		g->defer_stmts = prev_defer_stmts;
	} else {
		g->defer_stmts = __new_array_with_default(0, 0, sizeof(v__ast__DeferStmt), 0);
	}
	if (!v__ast__Type_alias_eq(node.return_type, _const_v__ast__void_type) && node.stmts.len > 0 && ((*(v__ast__Stmt*)array_last(node.stmts)))._typ != 305 /* v.ast.Return */) {
		string default_expr = v__gen__c__Gen_type_default(g, node.return_type);
		if (string_eq(default_expr, _SLIT("{0}"))) {
			v__gen__c__Gen_writeln(g, _STR("\treturn (%.*s\000)%.*s\000;", 3, type_name, default_expr));
		} else {
			v__gen__c__Gen_writeln(g, _STR("\treturn %.*s\000;", 2, default_expr));
		}
	}
	v__gen__c__Gen_writeln(g, _SLIT("}"));
	if (g->pref->printfn_list.len > 0 && (Array_string_contains(g->pref->printfn_list, g->last_fn_c_name))) {
		println(strings__Builder_after(&g->out, fn_start_pos));
	}
	// FOR IN array
	for (int _t3143 = 0; _t3143 < node.attrs.len; ++_t3143) {
		v__ast__Attr attr = ((v__ast__Attr*)node.attrs.data)[_t3143];
		if (string_eq(attr.name, _SLIT("export"))) {
			v__gen__c__Gen_writeln(g, _STR("// export alias: %.*s\000 -> %.*s", 2, attr.arg, name));
			string export_alias = _STR("%.*s\000 %.*s\000(%.*s\000)", 4, type_name, attr.arg, arg_str);
			strings__Builder_writeln(&g->definitions, _STR("VV_EXPORTED_SYMBOL %.*s\000; // exported fn %.*s", 2, export_alias, node.name));
			v__gen__c__Gen_writeln(g, _STR("%.*s\000 {", 2, export_alias));
			v__gen__c__Gen_write(g, _STR("\treturn %.*s\000(", 2, name));
			v__gen__c__Gen_write(g, Array_string_join(fargs, _SLIT(", ")));
			v__gen__c__Gen_writeln(g, _SLIT(");"));
			v__gen__c__Gen_writeln(g, _SLIT("}"));
		}
	}
// Defer begin
if (v__gen__c__Gen_gen_fn_decl_defer_2 == true) {
	g->last_fn_c_name = last_fn_c_name_save;
}
// Defer end
// Defer begin
if (v__gen__c__Gen_gen_fn_decl_defer_1 == true) {
	g->cur_fn = cur_fn_save;
}
// Defer end
// Defer begin
if (v__gen__c__Gen_gen_fn_decl_defer_0 == true) {
	g->is_autofree = old_g_autofree;
}
// Defer end
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_defer_flag_var(v__gen__c__Gen* g, v__ast__DeferStmt* stmt) {
	 string _t3144 = _STR("%.*s\000_defer_%"PRId32"", 2, g->last_fn_c_name, stmt->idx_in_fn);
	// autofree_scope_vars(pos=11067 line_nr=340 scope.pos=11013 scope.end_pos=11119)
	// var "g" var.pos=11014 var.line_nr=339
	// var "stmt" var.pos=11037 var.line_nr=339
	// af parent scope:
	// af parent scope:
	return _t3144;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_write_defer_stmts_when_needed(v__gen__c__Gen* g) {
	if (g->defer_stmts.len > 0) {
		v__gen__c__Gen_write_defer_stmts(g);
	}
	if (g->defer_profile_code.len > 0) {
		v__gen__c__Gen_writeln(g, _SLIT(""));
		v__gen__c__Gen_writeln(g, _SLIT("\t// defer_profile_code"));
		v__gen__c__Gen_writeln(g, g->defer_profile_code);
		v__gen__c__Gen_writeln(g, _SLIT(""));
	}
}

VV_LOCAL_SYMBOL multi_return_Array_string_Array_string v__gen__c__Gen_fn_args(v__gen__c__Gen* g, Array_v__ast__Param args, bool is_variadic) {
	Array_string fargs = __new_array_with_default(0, 0, sizeof(string), 0);
	Array_string fargtypes = __new_array_with_default(0, 0, sizeof(string), 0);
	if (args.len == 0) {
		v__gen__c__Gen_write(g, _SLIT("void"));
	}
	// FOR IN array
	for (int i = 0; i < args.len; ++i) {
		v__ast__Param arg = ((v__ast__Param*)args.data)[i];
		string caname = (string_eq(arg.name, _SLIT("_")) ? (v__gen__c__Gen_new_tmp_var(g)) : (v__gen__c__c_name(arg.name)));
		v__ast__Type typ = v__gen__c__Gen_unwrap_generic(g, arg.typ);
		v__ast__TypeSymbol* arg_type_sym = v__ast__Table_get_type_symbol(g->table, typ);
		string arg_type_name = v__gen__c__Gen_typ(g, typ);
		if (arg_type_sym->kind == v__ast__Kind_function) {
			v__ast__FnType info = /* as */ *(v__ast__FnType*)__as_cast((arg_type_sym->info)._v__ast__FnType,(arg_type_sym->info)._typ, 418) /*expected idx: 418, name: v.ast.FnType */ ;
			v__ast__Fn func = info.func;
			if (!info.is_anon) {
				v__gen__c__Gen_write(g, string_add(string_add(arg_type_name, _SLIT(" ")), caname));
				strings__Builder_write_string(&g->definitions, string_add(string_add(arg_type_name, _SLIT(" ")), caname));
				array_push(&fargs, _MOV((string[]){ string_clone(caname) }));
				array_push(&fargtypes, _MOV((string[]){ string_clone(arg_type_name) }));
			} else {
				v__gen__c__Gen_write(g, _STR("%.*s\000 (*%.*s\000)(", 3, v__gen__c__Gen_typ(g, func.return_type), caname));
				strings__Builder_write_string(&g->definitions, _STR("%.*s\000 (*%.*s\000)(", 3, v__gen__c__Gen_typ(g, func.return_type), caname));
				v__gen__c__Gen_fn_args(g, func.params, func.is_variadic);
				v__gen__c__Gen_write(g, _SLIT(")"));
				strings__Builder_write_string(&g->definitions, _SLIT(")"));
			}
		} else {
			string s = _STR("%.*s\000 %.*s", 2, arg_type_name, caname);
			v__gen__c__Gen_write(g, s);
			strings__Builder_write_string(&g->definitions, s);
			array_push(&fargs, _MOV((string[]){ string_clone(caname) }));
			array_push(&fargtypes, _MOV((string[]){ string_clone(arg_type_name) }));
		}
		if (i < args.len - 1) {
			v__gen__c__Gen_write(g, _SLIT(", "));
			strings__Builder_write_string(&g->definitions, _SLIT(", "));
		}
	}
	return (multi_return_Array_string_Array_string){.arg0=fargs, .arg1=fargtypes};
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_call_expr(v__gen__c__Gen* g, v__ast__CallExpr node) {
bool v__gen__c__Gen_call_expr_defer_0 = false;
	if ((node.left)._typ == 233 /* v.ast.AnonFn */) {
		v__gen__c__Gen_expr(g, node.left);
	}
	if ((node.left)._typ == 257 /* v.ast.IndexExpr */ && (node.name).len == 0) {
		g->is_fn_index_call = true;
		v__gen__c__Gen_expr(g, node.left);
		g->is_fn_index_call = false;
	}
	if (node.should_be_skipped) {
		return;
	}
	g->inside_call = true;
	v__gen__c__Gen_call_expr_defer_0 = true;
	bool gen_keep_alive = node.is_keep_alive && !v__ast__Type_alias_eq(node.return_type, _const_v__ast__void_type) && (g->pref->gc_mode == v__pref__GarbageCollectionMode_boehm_full || g->pref->gc_mode == v__pref__GarbageCollectionMode_boehm_incr || g->pref->gc_mode == v__pref__GarbageCollectionMode_boehm);
	bool gen_or = node.or_block.kind != v__ast__OrKind_absent;
	bool is_gen_or_and_assign_rhs = gen_or && !g->discard_or_result;
	string _t3149;
	string cur_line = (is_gen_or_and_assign_rhs || gen_keep_alive ? (		_t3149 = v__gen__c__Gen_go_before_stmt(g, 0),strings__Builder_write_string(&g->out, v__util__tabs(g->indent)),_t3149) : (_SLIT("")));
	string tmp_opt = (gen_or || gen_keep_alive ? (v__gen__c__Gen_new_tmp_var(g)) : (_SLIT("")));
	if (gen_or || gen_keep_alive) {
		v__ast__Type ret_typ = node.return_type;
		if (gen_or) {
			ret_typ = v__ast__Type_set_flag(ret_typ, v__ast__TypeFlag_optional);
		}
		string styp = v__gen__c__Gen_typ(g, ret_typ);
		v__gen__c__Gen_write(g, _STR("%.*s\000 %.*s\000 = ", 3, styp, tmp_opt));
	}
	if (node.is_method && !node.is_field) {
		if (string_eq(node.name, _SLIT("writeln")) && g->pref->experimental && node.args.len > 0 && ((*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr)._typ == 276 /* v.ast.StringInterLiteral */ && string_eq(v__ast__Table_get_type_symbol(g->table, node.receiver_type)->name, _SLIT("strings.Builder"))) {
			v__gen__c__Gen_string_inter_literal_sb_optimized(g, node);
		} else {
			v__gen__c__Gen_method_call(g, node);
		}
	} else {
		v__gen__c__Gen_fn_call(g, node);
	}
	if (gen_or) {
		v__gen__c__Gen_or_block(g, tmp_opt, node.or_block, node.return_type);
		if (is_gen_or_and_assign_rhs) {
			v__ast__Type unwrapped_typ = v__ast__Type_clear_flag(node.return_type, v__ast__TypeFlag_optional);
			string unwrapped_styp = v__gen__c__Gen_typ(g, unwrapped_typ);
			if (v__ast__Type_alias_eq(unwrapped_typ, _const_v__ast__void_type)) {
				v__gen__c__Gen_write(g, _STR("\n %.*s", 1, cur_line));
			} else if (v__ast__Table_get_type_symbol(g->table, node.return_type)->kind == v__ast__Kind_multi_return) {
				v__gen__c__Gen_write(g, _STR("\n %.*s\000 %.*s\000 /*U*/", 3, cur_line, tmp_opt));
			} else {
				if (!g->inside_const) {
					v__gen__c__Gen_write(g, _STR("\n %.*s\000 *(%.*s\000*)%.*s\000.data", 4, cur_line, unwrapped_styp, tmp_opt));
				}
			}
		}
	} else if (gen_keep_alive) {
		if (v__ast__Type_alias_eq(node.return_type, _const_v__ast__void_type)) {
			v__gen__c__Gen_write(g, _STR("\n %.*s", 1, cur_line));
		} else {
			v__gen__c__Gen_write(g, _STR("\n %.*s\000 %.*s", 2, cur_line, tmp_opt));
		}
	}
// Defer begin
if (v__gen__c__Gen_call_expr_defer_0 == true) {
	g->inside_call = false;
}
// Defer end
}

v__ast__Type v__gen__c__Gen_unwrap_generic(v__gen__c__Gen* g, v__ast__Type typ) {
	if (v__ast__Type_has_flag(typ, v__ast__TypeFlag_generic)) {
		Option_v__ast__Type _t3150;
		if (_t3150 = v__ast__Table_resolve_generic_by_names(g->table, typ, g->cur_fn.generic_names, g->cur_generic_types), _t3150.state == 0) {
			v__ast__Type t_typ = *(v__ast__Type*)_t3150.data;
			// autofree_scope_vars(pos=15178 line_nr=480 scope.pos=15174 scope.end_pos=15194)
			// af parent scope:
			// var "t_typ" var.pos=15082 var.line_nr=479
			// af parent scope:
			// af parent scope:
			// var "g" var.pos=15001 var.line_nr=477
			// var "typ" var.pos=15023 var.line_nr=477
			// af parent scope:
			// af parent scope:
			return t_typ;
		}
	}
	// autofree_scope_vars(pos=15199 line_nr=483 scope.pos=14996 scope.end_pos=15211)
	// var "g" var.pos=15001 var.line_nr=477
	// var "typ" var.pos=15023 var.line_nr=477
	// af parent scope:
	// af parent scope:
	return typ;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_method_call(v__gen__c__Gen* g, v__ast__CallExpr node) {
	if (node.left_type == 0) {
		v__gen__c__Gen_checker_bug(g, _SLIT("CallExpr.left_type is 0 in method_call"), node.pos);
	}
	if (node.receiver_type == 0) {
		v__gen__c__Gen_checker_bug(g, _SLIT("CallExpr.receiver_type is 0 in method_call"), node.pos);
	}
	v__ast__Type unwrapped_rec_type = v__gen__c__Gen_unwrap_generic(g, node.receiver_type);
	v__ast__TypeSymbol* typ_sym = v__ast__Table_get_type_symbol(g->table, unwrapped_rec_type);
	string rec_cc_type = v__gen__c__Gen_cc_type(g, unwrapped_rec_type, false);
	string receiver_type_name = v__util__no_dots(rec_cc_type);
	if (typ_sym->kind == v__ast__Kind_interface_ && v__ast__Interface_defines_method((/* as */ *(v__ast__Interface*)__as_cast((typ_sym->info)._v__ast__Interface,(typ_sym->info)._typ, 410) /*expected idx: 410, name: v.ast.Interface */ ), node.name)) {
		v__gen__c__Gen_write(g, _STR("%.*s\000_name_table[", 2, v__gen__c__c_name(receiver_type_name)));
		v__gen__c__Gen_expr(g, node.left);
		string dot = (v__ast__Type_is_ptr(node.left_type) ? (_SLIT("->")) : (_SLIT(".")));
		string mname = v__gen__c__c_name(node.name);
		v__gen__c__Gen_write(g, _STR("%.*s\000_typ]._method_%.*s\000(", 3, dot, mname));
		v__gen__c__Gen_expr(g, node.left);
		v__gen__c__Gen_write(g, _STR("%.*s\000_object", 2, dot));
		if (node.args.len > 0) {
			v__gen__c__Gen_write(g, _SLIT(", "));
			v__gen__c__Gen_call_args(g, node);
		}
		v__gen__c__Gen_write(g, _SLIT(")"));
		return;
	}
	v__ast__TypeSymbol* left_sym = v__ast__Table_get_type_symbol(g->table, node.left_type);
	if (left_sym->kind == v__ast__Kind_array) {

		if (string_eq(node.name, _SLIT("filter"))) {
			v__gen__c__Gen_gen_array_filter(g, node);
			return;
		}
		else if (string_eq(node.name, _SLIT("sort"))) {
			v__gen__c__Gen_gen_array_sort(g, node);
			return;
		}
		else if (string_eq(node.name, _SLIT("insert"))) {
			v__gen__c__Gen_gen_array_insert(g, node);
			return;
		}
		else if (string_eq(node.name, _SLIT("map"))) {
			v__gen__c__Gen_gen_array_map(g, node);
			return;
		}
		else if (string_eq(node.name, _SLIT("prepend"))) {
			v__gen__c__Gen_gen_array_prepend(g, node);
			return;
		}
		else if (string_eq(node.name, _SLIT("contains"))) {
			v__gen__c__Gen_gen_array_contains(g, node);
			return;
		}
		else if (string_eq(node.name, _SLIT("index"))) {
			v__gen__c__Gen_gen_array_index(g, node);
			return;
		}
		else if (string_eq(node.name, _SLIT("wait"))) {
			v__gen__c__Gen_gen_array_wait(g, node);
			return;
		}
		else if (string_eq(node.name, _SLIT("any"))) {
			v__gen__c__Gen_gen_array_any(g, node);
			return;
		}
		else if (string_eq(node.name, _SLIT("all"))) {
			v__gen__c__Gen_gen_array_all(g, node);
			return;
		}
		else {
		};
	}
	if (left_sym->kind == v__ast__Kind_map && string_eq(node.name, _SLIT("delete"))) {
		v__ast__Map left_info = /* as */ *(v__ast__Map*)__as_cast((left_sym->info)._v__ast__Map,(left_sym->info)._typ, 396) /*expected idx: 396, name: v.ast.Map */ ;
		string elem_type_str = v__gen__c__Gen_typ(g, left_info.key_type);
		v__gen__c__Gen_write(g, _SLIT("map_delete("));
		if (v__ast__Type_is_ptr(node.left_type)) {
			v__gen__c__Gen_expr(g, node.left);
		} else {
			v__gen__c__Gen_write(g, _SLIT("&"));
			v__gen__c__Gen_expr(g, node.left);
		}
		v__gen__c__Gen_write(g, _STR(", &(%.*s\000[]){", 2, elem_type_str));
		v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
		v__gen__c__Gen_write(g, _SLIT("})"));
		return;
	}
	if (left_sym->kind == v__ast__Kind_sum_type && string_eq(node.name, _SLIT("type_name"))) {
		v__gen__c__Gen_write(g, _STR("tos3( /* %.*s\000 */ v_typeof_sumtype_%.*s\000( (", 3, left_sym->name, typ_sym->cname));
		v__gen__c__Gen_expr(g, node.left);
		string dot = (v__ast__Type_is_ptr(node.left_type) ? (_SLIT("->")) : (_SLIT(".")));
		v__gen__c__Gen_write(g, _STR(")%.*s\000_typ ))", 2, dot));
		return;
	}
	if (left_sym->kind == v__ast__Kind_interface_ && string_eq(node.name, _SLIT("type_name"))) {
		v__gen__c__Gen_write(g, _STR("tos3( /* %.*s\000 */ v_typeof_interface_%.*s\000( (", 3, left_sym->name, typ_sym->cname));
		v__gen__c__Gen_expr(g, node.left);
		string dot = (v__ast__Type_is_ptr(node.left_type) ? (_SLIT("->")) : (_SLIT(".")));
		v__gen__c__Gen_write(g, _STR(")%.*s\000_typ ))", 2, dot));
		return;
	}
	if (string_eq(node.name, _SLIT("str"))) {
		v__ast__Type rec_type = node.receiver_type;
		if (v__ast__Type_has_flag(rec_type, v__ast__TypeFlag_shared_f)) {
			rec_type = v__ast__Type_set_nr_muls(v__ast__Type_clear_flag(rec_type, v__ast__TypeFlag_shared_f), 0);
		}
		v__gen__c__Gen_gen_str_for_type(g, rec_type);
	}
	bool has_cast = false;
	if (left_sym->kind == v__ast__Kind_map && (string_eq(node.name, _SLIT("clone")) || string_eq(node.name, _SLIT("move")))) {
		receiver_type_name = _SLIT("map");
	}
	if (left_sym->kind == v__ast__Kind_array && (string_eq(node.name, _SLIT("repeat")) || string_eq(node.name, _SLIT("sort_with_compare")) || string_eq(node.name, _SLIT("free")) || string_eq(node.name, _SLIT("push_many")) || string_eq(node.name, _SLIT("trim")) || string_eq(node.name, _SLIT("first")) || string_eq(node.name, _SLIT("last")) || string_eq(node.name, _SLIT("pop")) || string_eq(node.name, _SLIT("clone")) || string_eq(node.name, _SLIT("reverse")) || string_eq(node.name, _SLIT("slice")))) {
		receiver_type_name = _SLIT("array");
		if (false && string_eq(node.name, _SLIT("free")) && v__ast__TypeSymbol_has_method(typ_sym, node.name)) {
			receiver_type_name = string_trim(v__gen__c__Gen_typ(g, unwrapped_rec_type), _SLIT("*"));
		}
		if ((string_eq(node.name, _SLIT("last")) || string_eq(node.name, _SLIT("first")) || string_eq(node.name, _SLIT("pop")))) {
			string return_type_str = v__gen__c__Gen_typ(g, node.return_type);
			has_cast = true;
			v__gen__c__Gen_write(g, _STR("(*(%.*s\000*)", 2, return_type_str));
		}
	}
	string name = v__util__no_dots(_STR("%.*s\000_%.*s", 2, receiver_type_name, node.name));
	if (left_sym->kind == v__ast__Kind_chan) {
		if ((string_eq(node.name, _SLIT("close")) || string_eq(node.name, _SLIT("try_pop")) || string_eq(node.name, _SLIT("try_push")))) {
			name = _STR("sync__Channel_%.*s", 1, node.name);
		}
	} else if (left_sym->kind == v__ast__Kind_map) {
		if (string_eq(node.name, _SLIT("keys"))) {
			name = _SLIT("map_keys");
		}
	}
	if (g->pref->obfuscate && string_eq(g->cur_mod.name, _SLIT("main")) && string_starts_with(name, _SLIT("main__")) && string_ne(node.name, _SLIT("str"))) {
		v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, node.receiver_type);
		string key = string_add(string_add(sym->name, _SLIT(".")), node.name);
		v__gen__c__Gen_write(g, _STR("/* obf method call: %.*s\000 */", 2, key));
		string* _t3152 = (string*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, g->obf_table), &(string[]){key}));
		Option_string _t3151 = {0};
		if (_t3152) {
			*((string*)&_t3151.data) = *((string*)_t3152);
		} else {
			_t3151.state = 2; _t3151.err = v_error(_SLIT("array index out of range"));
		}
		;
		if (_t3151.state != 0) { /*or block*/ 
			IError err = _t3151.err;
			v_panic(_STR("cgen: obf name \"%.*s\000\" not found, this should never happen", 2, key));
		}
		name = *(string*)_t3151.data;
	}
	bool is_range_slice = false;
	if (v__ast__Type_is_ptr(node.receiver_type) && !v__ast__Type_is_ptr(node.left_type)) {
		if ((node.left)._typ == 257 /* v.ast.IndexExpr */) {
			v__ast__Expr idx = (*node.left._v__ast__IndexExpr).index;
			if ((idx)._typ == 271 /* v.ast.RangeExpr */) {
				name = v__util__no_dots(_STR("%.*s\000_%.*s\000_static", 3, receiver_type_name, node.name));
				is_range_slice = true;
			}
		}
	}
	// FOR IN array
	for (int i = 0; i < node.generic_types.len; ++i) {
		v__ast__Type generic_type = ((v__ast__Type*)node.generic_types.data)[i];
		if (!v__ast__Type_alias_eq(generic_type, _const_v__ast__void_type) && generic_type != 0) {
			if (i == 0) {
				name = /*f*/string_add(name, _SLIT("_T"));
			}
			name = /*f*/string_add(name, string_add(_SLIT("_"), v__gen__c__Gen_typ(g, generic_type)));
		}
	}
	if (!v__ast__Type_is_ptr(node.receiver_type) && v__ast__Type_is_ptr(node.left_type) && string_eq(node.name, _SLIT("str"))) {
		v__gen__c__Gen_write(g, _SLIT("ptr_str("));
	} else {
		v__gen__c__Gen_write(g, _STR("%.*s\000(", 2, name));
	}
	if (v__ast__Type_is_ptr(node.receiver_type) && (!v__ast__Type_is_ptr(node.left_type) || node.from_embed_type != 0 || (v__ast__Type_has_flag(node.left_type, v__ast__TypeFlag_shared_f) && string_ne(node.name, _SLIT("str"))))) {
		if (!is_range_slice) {
			v__gen__c__Gen_write(g, _SLIT("&"));
		}
	} else if (!v__ast__Type_is_ptr(node.receiver_type) && v__ast__Type_is_ptr(node.left_type) && string_ne(node.name, _SLIT("str")) && node.from_embed_type == 0) {
		if (!v__ast__Type_has_flag(node.left_type, v__ast__TypeFlag_shared_f)) {
			v__gen__c__Gen_write(g, _SLIT("/*rec*/*"));
		}
	} else if (!is_range_slice && node.from_embed_type == 0 && string_ne(node.name, _SLIT("str"))) {
		int diff = v__ast__Type_nr_muls(node.left_type) - v__ast__Type_nr_muls(node.receiver_type);
		if (diff < 0) {
		} else if (diff > 0) {
			v__gen__c__Gen_write(g, _STR("/*diff=%"PRId32"\000*/", 2, diff));
			v__gen__c__Gen_write(g, Array_byte_bytestr(__new_array_with_default(diff, 0, sizeof(byte), &(byte[]){L'*'})));
		}
	}
	if (g->is_autofree && node.free_receiver && !g->inside_lambda && !g->is_builtin_mod) {
		string fn_name = string_replace(node.name, _SLIT("."), _SLIT("_"));
		string arg_name = _STR("_arg_expr_%.*s\000_0_%"PRId32"", 2, fn_name, node.pos.pos);
		v__gen__c__Gen_write(g, string_add(_SLIT("/*af receiver arg*/"), arg_name));
	} else {
		v__gen__c__Gen_expr(g, node.left);
		if (node.from_embed_type != 0) {
			string embed_name = v__ast__TypeSymbol_embed_name(typ_sym);
			if (v__ast__Type_is_ptr(node.left_type)) {
				v__gen__c__Gen_write(g, _SLIT("->"));
			} else {
				v__gen__c__Gen_write(g, _SLIT("."));
			}
			v__gen__c__Gen_write(g, embed_name);
		}
		if (v__ast__Type_has_flag(node.left_type, v__ast__TypeFlag_shared_f)) {
			v__gen__c__Gen_write(g, _SLIT("->val"));
		}
	}
	if (has_cast) {
		v__gen__c__Gen_write(g, _SLIT(")"));
	}
	bool is_variadic = node.expected_arg_types.len > 0 && v__ast__Type_has_flag((*(v__ast__Type*)/*ee elem_typ */array_get(node.expected_arg_types, node.expected_arg_types.len - 1)), v__ast__TypeFlag_variadic);
	if (node.args.len > 0 || is_variadic) {
		v__gen__c__Gen_write(g, _SLIT(", "));
	}
	v__gen__c__Gen_call_args(g, node);
	v__gen__c__Gen_write(g, _SLIT(")"));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_fn_call(v__gen__c__Gen* g, v__ast__CallExpr node) {
	if (node.left_type != 0) {
		v__gen__c__Gen_expr(g, node.left);
		if (v__ast__Type_is_ptr(node.left_type)) {
			v__gen__c__Gen_write(g, _SLIT("->"));
		} else {
			v__gen__c__Gen_write(g, _SLIT("."));
		}
	}
	string name = node.name;
	bool is_print = (string_eq(name, _SLIT("print")) || string_eq(name, _SLIT("println")) || string_eq(name, _SLIT("eprint")) || string_eq(name, _SLIT("eprintln")) || string_eq(name, _SLIT("panic")));
	string print_method = name;
	bool is_json_encode = string_eq(name, _SLIT("json.encode"));
	bool is_json_encode_pretty = string_eq(name, _SLIT("json.encode_pretty"));
	bool is_json_decode = string_eq(name, _SLIT("json.decode"));
	g->is_json_fn = is_json_encode || is_json_encode_pretty || is_json_decode;
	string json_type_str = _SLIT("");
	string json_obj = _SLIT("");
	if (g->is_json_fn) {
		json_obj = v__gen__c__Gen_new_tmp_var(g);
		string tmp2 = _SLIT("");
		string cur_line = v__gen__c__Gen_go_before_stmt(g, 0);
		if (is_json_encode || is_json_encode_pretty) {
			v__gen__c__Gen_gen_json_for_type(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).typ);
			json_type_str = v__gen__c__Gen_typ(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).typ);
			string encode_name = v__gen__c__js_enc_name(json_type_str);
			v__gen__c__Gen_writeln(g, _SLIT("// json.encode"));
			v__gen__c__Gen_write(g, _STR("cJSON* %.*s\000 = %.*s\000(", 3, json_obj, encode_name));
			if (v__ast__Type_is_ptr((*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).typ)) {
				v__gen__c__Gen_write(g, _SLIT("*"));
			}
			v__gen__c__Gen_call_args(g, node);
			v__gen__c__Gen_writeln(g, _SLIT(");"));
			tmp2 = v__gen__c__Gen_new_tmp_var(g);
			if (is_json_encode) {
				v__gen__c__Gen_writeln(g, _STR("string %.*s\000 = json__json_print(%.*s\000);", 3, tmp2, json_obj));
			} else {
				v__gen__c__Gen_writeln(g, _STR("string %.*s\000 = json__json_print_pretty(%.*s\000);", 3, tmp2, json_obj));
			}
		} else {
			v__ast__TypeNode ast_type = /* as */ *(v__ast__TypeNode*)__as_cast(((*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr)._v__ast__TypeNode,((*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr)._typ, 279) /*expected idx: 279, name: v.ast.TypeNode */ ;
			string typ = v__gen__c__c_name(v__gen__c__Gen_typ(g, ast_type.typ));
			string fn_name = string_add(string_add(v__gen__c__c_name(name), _SLIT("_")), typ);
			v__gen__c__Gen_gen_json_for_type(g, ast_type.typ);
			v__gen__c__Gen_writeln(g, _SLIT("// json.decode"));
			v__gen__c__Gen_write(g, _STR("cJSON* %.*s\000 = json__json_parse(", 2, json_obj));
			g->is_js_call = true;
			v__gen__c__Gen_call_args(g, node);
			g->is_js_call = false;
			v__gen__c__Gen_writeln(g, _SLIT(");"));
			tmp2 = v__gen__c__Gen_new_tmp_var(g);
			v__gen__c__Gen_writeln(g, _STR("Option_%.*s\000 %.*s\000 = %.*s\000 (%.*s\000);", 5, typ, tmp2, fn_name, json_obj));
		}
		if (!g->is_autofree) {
			v__gen__c__Gen_write(g, _STR("cJSON_Delete(%.*s\000); //del", 2, json_obj));
		}
		v__gen__c__Gen_write(g, _STR("\n%.*s", 1, cur_line));
		name = _SLIT("");
		json_obj = tmp2;
	}
	if (node.language == v__ast__Language_c) {
		g->is_c_call = true;
		name = v__util__no_dots(string_substr(name, 2, name.len));
	} else {
		name = v__gen__c__c_name(name);
	}
	if (g->pref->obfuscate && string_eq(g->cur_mod.name, _SLIT("main")) && string_starts_with(name, _SLIT("main__"))) {
		string key = node.name;
		v__gen__c__Gen_write(g, _STR("/* obf call: %.*s\000 */", 2, key));
		string* _t3154 = (string*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, g->obf_table), &(string[]){key}));
		Option_string _t3153 = {0};
		if (_t3154) {
			*((string*)&_t3153.data) = *((string*)_t3154);
		} else {
			_t3153.state = 2; _t3153.err = v_error(_SLIT("array index out of range"));
		}
		;
		if (_t3153.state != 0) { /*or block*/ 
			IError err = _t3153.err;
			v_panic(_STR("cgen: obf name \"%.*s\000\" not found, this should never happen", 2, key));
		}
		name = *(string*)_t3153.data;
	}
	// FOR IN array
	for (int i = 0; i < node.generic_types.len; ++i) {
		v__ast__Type generic_type = ((v__ast__Type*)node.generic_types.data)[i];
		if (i == 0) {
			name = /*f*/string_add(name, _SLIT("_T"));
		}
		name = /*f*/string_add(name, string_add(_SLIT("_"), v__gen__c__Gen_typ(g, generic_type)));
	}
	bool print_auto_str = false;
	if (is_print && !v__ast__Type_alias_eq((*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).typ, _const_v__ast__string_type)) {
		v__ast__Type typ = (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).typ;
		if (typ == 0) {
			v__gen__c__Gen_checker_bug(g, _SLIT("print arg.typ is 0"), node.pos);
		}
		v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, typ);
		if ((sym->info)._typ == 413 /* v.ast.Alias */) {
			typ = (*sym->info._v__ast__Alias).parent_type;
			sym = v__ast__Table_get_type_symbol(g->table, typ);
		}
		if (!v__ast__Type_alias_eq(typ, _const_v__ast__string_type)) {
			v__ast__Expr expr = (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr;
			if (g->is_autofree && !v__ast__Type_has_flag(typ, v__ast__TypeFlag_optional)) {
				string tmp = v__gen__c__Gen_new_tmp_var(g);
				v__gen__c__Gen_write(g, _STR("string %.*s\000 = ", 2, tmp));
				v__gen__c__Gen_gen_expr_to_string(g, expr, typ);
				v__gen__c__Gen_writeln(g, _STR("; %.*s\000(%.*s\000); string_free(&%.*s\000);", 4, v__gen__c__c_name(print_method), tmp, tmp));
			} else {
				v__gen__c__Gen_write(g, _STR("%.*s\000(", 2, v__gen__c__c_name(print_method)));
				v__gen__c__Gen_gen_expr_to_string(g, expr, typ);
				v__gen__c__Gen_write(g, _SLIT(")"));
			}
			print_auto_str = true;
		}
	}
	if (!print_auto_str) {
		if (g->pref->is_debug && string_eq(node.name, _SLIT("panic"))) {
			multi_return_int_string_string_string mr_26881 = v__gen__c__Gen_panic_debug_info(g, node.pos);
			int paline = mr_26881.arg0;
			string pafile = mr_26881.arg1;
			string pamod = mr_26881.arg2;
			string pafn = mr_26881.arg3;
			v__gen__c__Gen_write(g, _STR("panic_debug(%"PRId32"\000, tos3(\"%.*s\000\"), tos3(\"%.*s\000\"), tos3(\"%.*s\000\"),  ", 5, paline, pafile, pamod, pafn));
			v__gen__c__Gen_call_args(g, node);
			v__gen__c__Gen_write(g, _SLIT(")"));
		} else {
			int tmp_cnt_save = -1;
			v__gen__c__Gen_write(g, _STR("%.*s\000(", 2, v__gen__c__Gen_get_ternary_name(g, name)));
			if (g->is_json_fn) {
				v__gen__c__Gen_write(g, json_obj);
			} else {
				if (node.is_keep_alive && (g->pref->gc_mode == v__pref__GarbageCollectionMode_boehm_full || g->pref->gc_mode == v__pref__GarbageCollectionMode_boehm_incr || g->pref->gc_mode == v__pref__GarbageCollectionMode_boehm)) {
					string cur_line = v__gen__c__Gen_go_before_stmt(g, 0);
					tmp_cnt_save = v__gen__c__Gen_keep_alive_call_pregen(g, node);
					v__gen__c__Gen_write(g, cur_line);
					for (int i = 0; i < node.args.len; ++i) {
						if (i > 0) {
							v__gen__c__Gen_write(g, _SLIT(", "));
						}
						v__gen__c__Gen_write(g, _STR("__tmp_arg_%"PRId32"", 1, tmp_cnt_save + i));
					}
				} else {
					v__gen__c__Gen_call_args(g, node);
				}
			}
			v__gen__c__Gen_write(g, _SLIT(")"));
			if (tmp_cnt_save >= 0) {
				v__gen__c__Gen_writeln(g, _SLIT(";"));
				v__gen__c__Gen_keep_alive_call_postgen(g, node, tmp_cnt_save);
			}
		}
	}
	g->is_c_call = false;
	g->is_json_fn = false;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_autofree_call_pregen(v__gen__c__Gen* g, v__ast__CallExpr node) {
	bool free_tmp_arg_vars = g->is_autofree && !g->is_builtin_mod && node.args.len > 0 && !v__ast__Type_has_flag((*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).typ, v__ast__TypeFlag_optional);
	if (!free_tmp_arg_vars) {
		return;
	}
	if (g->is_js_call) {
		return;
	}
	if (g->inside_const) {
		return;
	}
	free_tmp_arg_vars = false;
	g->tmp_count2++;
	v__ast__Scope* scope = v__ast__Scope_innermost(g->file.scope, node.pos.pos);
	Array_v__ast__CallArg args = new_array_from_c_array(1, 1, sizeof(v__ast__CallArg), _MOV((v__ast__CallArg[1]){(v__ast__CallArg){.is_mut = 0,.share = 0,.expr = node.left,.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.typ = node.receiver_type,.is_tmp_autofree = node.free_receiver,.pos = {0},}}));
	_PUSH_MANY(&args, (node.args), _t3155, Array_v__ast__CallArg);
	// FOR IN array
	for (int i = 0; i < args.len; ++i) {
		v__ast__CallArg arg = ((v__ast__CallArg*)args.data)[i];
		if (!arg.is_tmp_autofree) {
			continue;
		}
		if ((arg.expr)._typ == 241 /* v.ast.CallExpr */) {
			v__gen__c__Gen_autofree_call_pregen(g, (*arg.expr._v__ast__CallExpr));
		}
		free_tmp_arg_vars = true;
		string fn_name = string_replace(node.name, _SLIT("."), _SLIT("_"));
		string t = _STR("_arg_expr_%.*s\000_%"PRId32"\000_%"PRId32"", 3, fn_name, i, node.pos.pos);
		bool used = false;
		string s = _STR("%.*s\000 = ", 2, t);
		if (used) {
			Option_v__ast__ScopeObject _t3156;
			if (_t3156 = v__ast__Scope_find(scope, t), _t3156.state == 0) {
				v__ast__ScopeObject x = *(v__ast__ScopeObject*)_t3156.data;
				if (x._typ == 312 /* v.ast.Var */) {
					(*x._v__ast__Var).is_used = false;
				}
				else {
				};
			}
			s = _STR("%.*s\000 = ", 2, t);
		} else {
			v__ast__Scope_register(scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, ((v__ast__Var){.name = t,.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = true,.is_arg = 0,.is_auto_deref = 0,.typ = _const_v__ast__string_type,.orig_type = 0,.smartcasts = __new_array(0, 1, sizeof(v__ast__Type)),.pos = node.pos,.is_used = 0,.is_changed = 0,.is_or = 0,.is_tmp = 0,}))));
			s = _STR("string %.*s\000 = ", 2, t);
		}
		s = /*f*/string_add(s, v__gen__c__Gen_write_expr_to_string(g, arg.expr));
		s = /*f*/string_add(s, _SLIT(";// new af2 pre"));
		array_push(&g->strs_to_free0, _MOV((string[]){ string_clone(s) }));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_autofree_call_postgen(v__gen__c__Gen* g, int node_pos) {
	if (g->inside_vweb_tmpl) {
		return;
	}
	v__ast__Scope* scope = v__ast__Scope_innermost(g->file.scope, node_pos);
	// FOR IN map
	Map_string_v__ast__ScopeObject _t3158 = scope->objects;
	int _t3160 = _t3158.key_values.len;
	for (int _t3159 = 0; _t3159 < _t3160; ++_t3159 ) {
		int _t3161 = _t3158.key_values.len - _t3160;
		_t3160 = _t3158.key_values.len;
		if (_t3161 < 0) {
			_t3159 = -1;
			continue;
		}
		if (!DenseArray_has_index(&_t3158.key_values, _t3159)) {continue;}
		v__ast__ScopeObject obj = (*(v__ast__ScopeObject*)DenseArray_value(&_t3158.key_values, _t3159));
		if (obj._typ == 312 /* v.ast.Var */) {
			bool is_optional = v__ast__Type_has_flag((*obj._v__ast__Var).typ, v__ast__TypeFlag_optional);
			if (is_optional) {
				continue;
			}
			if (!(*obj._v__ast__Var).is_autofree_tmp) {
				continue;
			}
			if ((*obj._v__ast__Var).is_used) {
				continue;
			}
			(*obj._v__ast__Var).is_used = true;
			v__gen__c__Gen_autofree_variable(g, (*obj._v__ast__Var));
		}
		else {
		};
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_call_args(v__gen__c__Gen* g, v__ast__CallExpr node) {
	Array_v__ast__CallArg args = (g->is_js_call ? (array_slice(node.args, 1, node.args.len)) : (node.args));
	Array_v__ast__Type expected_types = node.expected_arg_types;
	bool is_variadic = expected_types.len > 0 && v__ast__Type_has_flag((*(v__ast__Type*)array_last(expected_types)), v__ast__TypeFlag_variadic) && node.language == v__ast__Language_v;
	// FOR IN array
	for (int i = 0; i < args.len; ++i) {
		v__ast__CallArg arg = ((v__ast__CallArg*)args.data)[i];
		if (is_variadic && i == expected_types.len - 1) {
			break;
		}
		bool use_tmp_var_autofree = g->is_autofree && v__ast__Type_alias_eq(arg.typ, _const_v__ast__string_type) && arg.is_tmp_autofree && !g->inside_const && !g->is_builtin_mod;
		if (i < expected_types.len) {
			if (use_tmp_var_autofree) {
				if (arg.is_tmp_autofree) {
					string fn_name = string_replace(node.name, _SLIT("."), _SLIT("_"));
					string name = _STR("_arg_expr_%.*s\000_%"PRId32"\000_%"PRId32"", 3, fn_name, i + 1, node.pos.pos);
					v__gen__c__Gen_write(g, string_add(_SLIT("/*af arg*/"), name));
				}
			} else {
				if (node.generic_types.len > 0 && v__ast__Expr_is_auto_deref_var(arg.expr) && !arg.is_mut && !v__ast__Type_is_ptr((*(v__ast__Type*)/*ee elem_typ */array_get(expected_types, i)))) {
					v__gen__c__Gen_write(g, _SLIT("*"));
				}
				v__gen__c__Gen_ref_or_deref_arg(g, arg, (*(v__ast__Type*)/*ee elem_typ */array_get(expected_types, i)), node.language);
			}
		} else {
			if (use_tmp_var_autofree) {
				string fn_name = string_replace(node.name, _SLIT("."), _SLIT("_"));
				string name = _STR("_arg_expr_%.*s\000_%"PRId32"\000_%"PRId32"", 3, fn_name, i + 1, node.pos.pos);
				v__gen__c__Gen_write(g, string_add(_SLIT("/*af arg2*/"), name));
			} else {
				v__gen__c__Gen_expr(g, arg.expr);
			}
		}
		if (i < args.len - 1 || is_variadic) {
			v__gen__c__Gen_write(g, _SLIT(", "));
		}
	}
	int arg_nr = expected_types.len - 1;
	if (is_variadic) {
		v__ast__Type varg_type = (*(v__ast__Type*)array_last(expected_types));
		int variadic_count = args.len - arg_nr;
		v__ast__TypeSymbol* arr_sym = v__ast__Table_get_type_symbol(g->table, varg_type);
		v__ast__Array arr_info = /* as */ *(v__ast__Array*)__as_cast((arr_sym->info)._v__ast__Array,(arr_sym->info)._typ, 395) /*expected idx: 395, name: v.ast.Array */ ;
		if (v__ast__Type_has_flag(varg_type, v__ast__TypeFlag_generic)) {
			Option_v__ast__Fn _t3162;
			if (_t3162 = v__ast__Table_find_fn(g->table, node.name), _t3162.state == 0) {
				v__ast__Fn fn_def = *(v__ast__Fn*)_t3162.data;
				string varg_type_name = v__ast__Table_type_to_str(g->table, varg_type);
				// FOR IN array
				for (int i = 0; i < fn_def.generic_names.len; ++i) {
					string fn_gen_name = ((string*)fn_def.generic_names.data)[i];
					if (string_eq(fn_gen_name, varg_type_name)) {
						arr_info.elem_type = (*(v__ast__Type*)/*ee elem_typ */array_get(node.generic_types, i));
						break;
					}
				}
			} else {
				IError err = _t3162.err;
				v__gen__c__Gen_error(g, _STR("unable to find function %.*s", 1, node.name), node.pos);
			}
		}
		string elem_type = v__gen__c__Gen_typ(g, arr_info.elem_type);
		if (args.len > 0 && ((*(v__ast__CallArg*)/*ee elem_typ */array_get(args, args.len - 1)).expr)._typ == 234 /* v.ast.ArrayDecompose */) {
			v__gen__c__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(args, args.len - 1)).expr);
		} else {
			if (variadic_count > 0) {
				v__gen__c__Gen_write(g, _STR("new_array_from_c_array(%"PRId32"\000, %"PRId32"\000, sizeof(%.*s\000), _MOV((%.*s\000[%"PRId32"\000]){", 6, variadic_count, variadic_count, elem_type, elem_type, variadic_count));
				for (int j = arg_nr; j < args.len; ++j) {
					v__gen__c__Gen_ref_or_deref_arg(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(args, j)), arr_info.elem_type, node.language);
					if (j < args.len - 1) {
						v__gen__c__Gen_write(g, _SLIT(", "));
					}
				}
				v__gen__c__Gen_write(g, _SLIT("}))"));
			} else {
				v__gen__c__Gen_write(g, _STR("__new_array_with_default(0, 0, sizeof(%.*s\000), 0)", 2, elem_type));
			}
		}
	}
}

VV_LOCAL_SYMBOL int v__gen__c__Gen_keep_alive_call_pregen(v__gen__c__Gen* g, v__ast__CallExpr node) {
	g->empty_line = true;
	v__gen__c__Gen_writeln(g, _SLIT("// keep_alive_call_pregen()"));
	int tmp_cnt_save = g->tmp_count + 1;
	g->tmp_count += node.args.len;
	// FOR IN array
	for (int i = 0; i < node.args.len; ++i) {
		v__ast__CallArg arg = ((v__ast__CallArg*)node.args.data)[i];
		v__ast__Type expected_type = (*(v__ast__Type*)/*ee elem_typ */array_get(node.expected_arg_types, i));
		string typ = v__ast__Table_get_type_symbol(g->table, expected_type)->cname;
		v__gen__c__Gen_write(g, _STR("%.*s\000 __tmp_arg_%"PRId32"\000 = ", 3, typ, tmp_cnt_save + i));
		v__gen__c__Gen_ref_or_deref_arg(g, arg, expected_type, node.language);
		v__gen__c__Gen_writeln(g, _SLIT(";"));
	}
	g->empty_line = false;
	// autofree_scope_vars(pos=35291 line_nr=1151 scope.pos=34654 scope.end_pos=35312)
	// var "g" var.pos=34659 var.line_nr=1134
	// var "node" var.pos=34689 var.line_nr=1134
	// var "tmp_cnt_save" var.pos=34822 var.line_nr=1138
	// af parent scope:
	// af parent scope:
	return tmp_cnt_save;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_keep_alive_call_postgen(v__gen__c__Gen* g, v__ast__CallExpr node, int tmp_cnt_save) {
	v__gen__c__Gen_writeln(g, _SLIT("// keep_alive_call_postgen()"));
	// FOR IN array
	for (int i = 0; i < node.expected_arg_types.len; ++i) {
		v__ast__Type expected_type = ((v__ast__Type*)node.expected_arg_types.data)[i];
		if (v__ast__Type_is_ptr(expected_type) || v__ast__Type_is_pointer(expected_type)) {
			v__gen__c__Gen_writeln(g, _STR("GC_reachable_here(__tmp_arg_%"PRId32"\000);", 2, tmp_cnt_save + i));
		}
	}
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL void v__gen__c__Gen_ref_or_deref_arg(v__gen__c__Gen* g, v__ast__CallArg arg, v__ast__Type expected_type, v__ast__Language lang) {
	bool arg_is_ptr = v__ast__Type_is_ptr(expected_type) || (Array_int_contains(_const_v__ast__pointer_type_idxs, v__ast__Type_idx(expected_type)));
	bool expr_is_ptr = v__ast__Type_is_ptr(arg.typ) || (Array_int_contains(_const_v__ast__pointer_type_idxs, v__ast__Type_idx(arg.typ)));
	if (expected_type == 0) {
		v__gen__c__Gen_checker_bug(g, _SLIT("ref_or_deref_arg expected_type is 0"), arg.pos);
	}
	v__ast__TypeSymbol* exp_sym = v__ast__Table_get_type_symbol(g->table, expected_type);
	if (arg.is_mut && !arg_is_ptr) {
		v__gen__c__Gen_write(g, _SLIT("&/*mut*/"));
	} else if (arg_is_ptr && !expr_is_ptr) {
		if (arg.is_mut) {
			if (exp_sym->kind == v__ast__Kind_array) {
				if ((arg.expr)._typ == 254 /* v.ast.Ident */ && (/* as */ *(v__ast__Ident*)__as_cast((arg.expr)._v__ast__Ident,(arg.expr)._typ, 254) /*expected idx: 254, name: v.ast.Ident */ ).kind == v__ast__IdentKind_variable) {
					v__gen__c__Gen_write(g, _SLIT("&/*arr*/"));
					v__gen__c__Gen_expr(g, arg.expr);
				} else {
					v__gen__c__Gen_write(g, _SLIT("&/*111*/(array[]){"));
					v__gen__c__Gen_expr(g, arg.expr);
					v__gen__c__Gen_write(g, _SLIT("}[0]"));
				}
				return;
			}
		}
		if (!g->is_json_fn) {
			if (arg.typ == 0) {
				v__gen__c__Gen_checker_bug(g, _SLIT("ref_or_deref_arg arg.typ is 0"), arg.pos);
			}
			v__ast__TypeSymbol* arg_typ_sym = v__ast__Table_get_type_symbol(g->table, arg.typ);
			v__ast__Type expected_deref_type = (v__ast__Type_is_ptr(expected_type) ? (v__ast__Type_deref(expected_type)) : (expected_type));
			v__ast__TypeSymbol* deref_sym = v__ast__Table_get_type_symbol(g->table, expected_deref_type);
			if (!((arg_typ_sym->kind == v__ast__Kind_function) || (deref_sym->kind == v__ast__Kind_sum_type || deref_sym->kind == v__ast__Kind_interface_)) && lang != v__ast__Language_c) {
				v__gen__c__Gen_write(g, _SLIT("(voidptr)&/*qq*/"));
			}
		}
	} else if (v__ast__Type_has_flag(arg.typ, v__ast__TypeFlag_shared_f) && !v__ast__Type_has_flag(expected_type, v__ast__TypeFlag_shared_f)) {
		if (v__ast__Type_is_ptr(expected_type)) {
			v__gen__c__Gen_write(g, _SLIT("&"));
		}
		v__gen__c__Gen_expr(g, arg.expr);
		v__gen__c__Gen_write(g, _SLIT("->val"));
		return;
	}
	v__gen__c__Gen_expr_with_cast(g, arg.expr, arg.typ, expected_type);
}

VV_LOCAL_SYMBOL bool v__gen__c__Gen_is_gui_app(v__gen__c__Gen* g) {
	if (g->force_main_console) {
		 bool _t3163 = false;
		// autofree_scope_vars(pos=37330 line_nr=1219 scope.pos=37326 scope.end_pos=37346)
		// af parent scope:
		// af parent scope:
		// var "g" var.pos=37258 var.line_nr=1216
		// af parent scope:
		// af parent scope:
		return _t3163;
	}
	// FOR IN array
	for (int _t3164 = 0; _t3164 < g->table->cflags.len; ++_t3164) {
		v__cflag__CFlag cf = ((v__cflag__CFlag*)g->table->cflags.data)[_t3164];
		if (string_eq(cf.value, _SLIT("gdi32"))) {
			 bool _t3165 = true;
			// autofree_scope_vars(pos=37408 line_nr=1223 scope.pos=37403 scope.end_pos=37424)
			// af parent scope:
			// var "cf" var.pos=37354 var.line_nr=1221
			// skipping tmp var "cf"
			// af parent scope:
			// af parent scope:
			// var "g" var.pos=37258 var.line_nr=1216
			// af parent scope:
			// af parent scope:
			return _t3165;
		}
	}
	 bool _t3166 = false;
	// autofree_scope_vars(pos=37433 line_nr=1227 scope.pos=37253 scope.end_pos=37447)
	// var "g" var.pos=37258 var.line_nr=1216
	// af parent scope:
	// af parent scope:
	return _t3166;
}

VV_LOCAL_SYMBOL bool v__gen__c__Gen_fileis(v__gen__c__Gen* g, string s) {
	 bool _t3167 = string_contains(g->file.path, s);
	// autofree_scope_vars(pos=37486 line_nr=1231 scope.pos=37453 scope.end_pos=37518)
	// var "g" var.pos=37454 var.line_nr=1230
	// var "s" var.pos=37469 var.line_nr=1230
	// af parent scope:
	// af parent scope:
	return _t3167;
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_write_fn_attrs(v__gen__c__Gen* g, Array_v__ast__Attr attrs) {
	string msvc_attrs = _SLIT("");
	// FOR IN array
	for (int _t3168 = 0; _t3168 < attrs.len; ++_t3168) {
		v__ast__Attr attr = ((v__ast__Attr*)attrs.data)[_t3168];

		if (string_eq(attr.name, _SLIT("inline"))) {
			v__gen__c__Gen_write(g, _SLIT("inline "));
		}
		else if (string_eq(attr.name, _SLIT("no_inline"))) {
			v__gen__c__Gen_write(g, _SLIT("__NOINLINE "));
		}
		else if (string_eq(attr.name, _SLIT("irq_handler"))) {
			v__gen__c__Gen_write(g, _SLIT("__IRQHANDLER "));
		}
		else if (string_eq(attr.name, _SLIT("_cold"))) {
			v__gen__c__Gen_write(g, _SLIT("__attribute__((cold)) "));
		}
		else if (string_eq(attr.name, _SLIT("_constructor"))) {
			v__gen__c__Gen_write(g, _SLIT("__attribute__((constructor)) "));
		}
		else if (string_eq(attr.name, _SLIT("_destructor"))) {
			v__gen__c__Gen_write(g, _SLIT("__attribute__((destructor)) "));
		}
		else if (string_eq(attr.name, _SLIT("_flatten"))) {
			v__gen__c__Gen_write(g, _SLIT("__attribute__((flatten)) "));
		}
		else if (string_eq(attr.name, _SLIT("_hot"))) {
			v__gen__c__Gen_write(g, _SLIT("__attribute__((hot)) "));
		}
		else if (string_eq(attr.name, _SLIT("_malloc"))) {
			v__gen__c__Gen_write(g, _SLIT("__attribute__((malloc)) "));
		}
		else if (string_eq(attr.name, _SLIT("_pure"))) {
			v__gen__c__Gen_write(g, _SLIT("__attribute__((const)) "));
		}
		else if (string_eq(attr.name, _SLIT("windows_stdcall"))) {
			msvc_attrs = /*f*/string_add(msvc_attrs, _SLIT("__stdcall "));
		}
		else if (string_eq(attr.name, _SLIT("console"))) {
			g->force_main_console = true;
		}
		else {
		};
	}
	// autofree_scope_vars(pos=40512 line_nr=1305 scope.pos=37524 scope.end_pos=40531)
	// var "g" var.pos=37529 var.line_nr=1234
	// var "attrs" var.pos=37551 var.line_nr=1234
	// var "msvc_attrs" var.pos=37583 var.line_nr=1235
	// str literal
	// af parent scope:
	// af parent scope:
	return msvc_attrs;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_index_expr(v__gen__c__Gen* g, v__ast__IndexExpr node) {
	if ((node.index)._typ == 271 /* v.ast.RangeExpr */) {
		v__gen__c__Gen_range_expr(g, node, (*node.index._v__ast__RangeExpr));
	} else {
		v__ast__TypeSymbol* sym = v__ast__Table_get_final_type_symbol(g->table, node.left_type);
		if (sym->kind == v__ast__Kind_array) {
			v__gen__c__Gen_index_of_array(g, node, *sym);
		} else if (sym->kind == v__ast__Kind_array_fixed) {
			v__gen__c__Gen_index_of_fixed_array(g, node, *sym);
		} else if (sym->kind == v__ast__Kind_map) {
			v__gen__c__Gen_index_of_map(g, node, *sym);
		} else if (sym->kind == v__ast__Kind_string && !v__ast__Type_is_ptr(node.left_type)) {
			v__gen__c__Gen_write(g, _SLIT("string_at("));
			v__gen__c__Gen_expr(g, node.left);
			v__gen__c__Gen_write(g, _SLIT(", "));
			v__gen__c__Gen_expr(g, node.index);
			v__gen__c__Gen_write(g, _SLIT(")"));
		} else {
			v__gen__c__Gen_expr(g, node.left);
			v__gen__c__Gen_write(g, _SLIT("["));
			v__gen__c__Gen_expr(g, node.index);
			v__gen__c__Gen_write(g, _SLIT("]"));
		}
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_range_expr(v__gen__c__Gen* g, v__ast__IndexExpr node, v__ast__RangeExpr range) {
	v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, node.left_type);
	if (sym->kind == v__ast__Kind_string) {
		v__gen__c__Gen_write(g, _SLIT("string_substr("));
		v__gen__c__Gen_expr(g, node.left);
	} else if (sym->kind == v__ast__Kind_array) {
		v__gen__c__Gen_write(g, _SLIT("array_slice("));
		if (v__ast__Type_is_ptr(node.left_type)) {
			v__gen__c__Gen_write(g, _SLIT("*"));
		}
		v__gen__c__Gen_expr(g, node.left);
	} else if (sym->kind == v__ast__Kind_array_fixed) {
		v__ast__ArrayFixed info = /* as */ *(v__ast__ArrayFixed*)__as_cast((sym->info)._v__ast__ArrayFixed,(sym->info)._typ, 416) /*expected idx: 416, name: v.ast.ArrayFixed */ ;
		v__gen__c__Gen_write(g, _SLIT("array_slice(new_array_from_c_array("));
		v__gen__c__Gen_write(g, _STR("%"PRId32"", 1, info.size));
		v__gen__c__Gen_write(g, _STR(", %"PRId32"", 1, info.size));
		v__gen__c__Gen_write(g, _SLIT(", sizeof("));
		if (v__ast__Type_is_ptr(node.left_type)) {
			v__gen__c__Gen_write(g, _SLIT("(*"));
		}
		v__gen__c__Gen_expr(g, node.left);
		if (v__ast__Type_is_ptr(node.left_type)) {
			v__gen__c__Gen_write(g, _SLIT(")"));
		}
		v__gen__c__Gen_write(g, _SLIT("[0]), "));
		if (v__ast__Type_is_ptr(node.left_type)) {
			v__gen__c__Gen_write(g, _SLIT("*"));
		}
		v__gen__c__Gen_expr(g, node.left);
		v__gen__c__Gen_write(g, _SLIT(")"));
	} else {
		v__gen__c__Gen_expr(g, node.left);
	}
	v__gen__c__Gen_write(g, _SLIT(", "));
	if (range.has_low) {
		v__gen__c__Gen_expr(g, range.low);
	} else {
		v__gen__c__Gen_write(g, _SLIT("0"));
	}
	v__gen__c__Gen_write(g, _SLIT(", "));
	if (range.has_high) {
		v__gen__c__Gen_expr(g, range.high);
	} else if (sym->kind == v__ast__Kind_array_fixed) {
		v__ast__ArrayFixed info = /* as */ *(v__ast__ArrayFixed*)__as_cast((sym->info)._v__ast__ArrayFixed,(sym->info)._typ, 416) /*expected idx: 416, name: v.ast.ArrayFixed */ ;
		v__gen__c__Gen_write(g, _STR("%"PRId32"", 1, info.size));
	} else if (v__ast__Type_is_ptr(node.left_type)) {
		v__gen__c__Gen_write(g, _SLIT("("));
		v__gen__c__Gen_write(g, _SLIT("*"));
		v__gen__c__Gen_expr(g, node.left);
		v__gen__c__Gen_write(g, _SLIT(")"));
		v__gen__c__Gen_write(g, _SLIT(".len"));
	} else {
		v__gen__c__Gen_expr(g, node.left);
		v__gen__c__Gen_write(g, _SLIT(".len"));
	}
	v__gen__c__Gen_write(g, _SLIT(")"));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_index_of_array(v__gen__c__Gen* g, v__ast__IndexExpr node, v__ast__TypeSymbol sym) {
	bool gen_or = node.or_expr.kind != v__ast__OrKind_absent || node.is_option;
	bool left_is_ptr = v__ast__Type_is_ptr(node.left_type);
	v__ast__Array info = /* as */ *(v__ast__Array*)__as_cast((sym.info)._v__ast__Array,(sym.info)._typ, 395) /*expected idx: 395, name: v.ast.Array */ ;
	string elem_type_str = v__gen__c__Gen_typ(g, info.elem_type);
	v__ast__Type elem_type = info.elem_type;
	v__ast__TypeSymbol* elem_typ = v__ast__Table_get_type_symbol(g->table, elem_type);
	bool is_selector = (node.left)._typ == 273 /* v.ast.SelectorExpr */;
	if (g->is_assign_lhs && !is_selector && node.is_setter) {
		bool is_direct_array_access = g->fn_decl != 0 && g->fn_decl->is_direct_arr;
		bool is_op_assign = g->assign_op != v__token__Kind_assign && !v__ast__Type_alias_eq(info.elem_type, _const_v__ast__string_type);
		string array_ptr_type_str = ((elem_typ->kind == (v__ast__Kind_function)) ? (_SLIT("voidptr*")) : (_STR("%.*s\000*", 2, elem_type_str)));
		if (is_direct_array_access) {
			v__gen__c__Gen_write(g, _STR("((%.*s\000)", 2, array_ptr_type_str));
		} else if (is_op_assign) {
			v__gen__c__Gen_write(g, _STR("(*(%.*s\000)array_get(", 2, array_ptr_type_str));
			if (left_is_ptr && !v__ast__Type_has_flag(node.left_type, v__ast__TypeFlag_shared_f)) {
				v__gen__c__Gen_write(g, _SLIT("*"));
			}
		} else {
			g->is_arraymap_set = true;
			v__gen__c__Gen_write(g, _SLIT("array_set("));
			if (!left_is_ptr || v__ast__Type_has_flag(node.left_type, v__ast__TypeFlag_shared_f)) {
				v__gen__c__Gen_write(g, _SLIT("&"));
			}
		}
		v__gen__c__Gen_expr(g, node.left);
		if (v__ast__Type_has_flag(node.left_type, v__ast__TypeFlag_shared_f)) {
			if (left_is_ptr) {
				v__gen__c__Gen_write(g, _SLIT("->val"));
			} else {
				v__gen__c__Gen_write(g, _SLIT(".val"));
			}
		}
		if (is_direct_array_access) {
			if (left_is_ptr && !v__ast__Type_has_flag(node.left_type, v__ast__TypeFlag_shared_f)) {
				v__gen__c__Gen_write(g, _SLIT("->"));
			} else {
				v__gen__c__Gen_write(g, _SLIT("."));
			}
			v__gen__c__Gen_write(g, _SLIT("data)["));
			v__gen__c__Gen_expr(g, node.index);
			v__gen__c__Gen_write(g, _SLIT("]"));
		} else {
			v__gen__c__Gen_write(g, _SLIT(", "));
			v__gen__c__Gen_expr(g, node.index);
			if (!is_op_assign) {
				bool need_wrapper = true;
				if (need_wrapper) {
					if (elem_typ->kind == v__ast__Kind_function) {
						v__gen__c__Gen_write(g, _SLIT(", &(voidptr[]) { "));
					} else {
						v__gen__c__Gen_write(g, _STR(", &(%.*s\000[]) { ", 2, elem_type_str));
					}
				} else {
					v__gen__c__Gen_write(g, _SLIT(", &"));
				}
			} else {
				v__gen__c__Gen_write(g, _SLIT("))"));
			}
		}
	} else {
		bool is_direct_array_access = g->fn_decl != 0 && g->fn_decl->is_direct_arr;
		string array_ptr_type_str = ((elem_typ->kind == (v__ast__Kind_function)) ? (_SLIT("voidptr*")) : (_STR("%.*s\000*", 2, elem_type_str)));
		bool needs_clone = info.elem_type == _const_v__ast__string_type_idx && g->is_autofree && !(g->inside_return && v__ast__Type_has_flag(g->fn_decl->return_type, v__ast__TypeFlag_optional)) && !g->is_assign_lhs;
		bool is_gen_or_and_assign_rhs = gen_or && !g->discard_or_result;
		string _t3169;
		string cur_line = (is_gen_or_and_assign_rhs ? (			_t3169 = v__gen__c__Gen_go_before_stmt(g, 0),strings__Builder_write_string(&g->out, v__util__tabs(g->indent)),_t3169) : (_SLIT("")));
		string tmp_opt = (gen_or ? (v__gen__c__Gen_new_tmp_var(g)) : (_SLIT("")));
		string tmp_opt_ptr = (gen_or ? (v__gen__c__Gen_new_tmp_var(g)) : (_SLIT("")));
		if (gen_or) {
			v__gen__c__Gen_write(g, _STR("%.*s\000 %.*s\000 = (%.*s\000)/*ee elem_ptr_typ */(array_get_with_check(", 4, array_ptr_type_str, tmp_opt_ptr, array_ptr_type_str));
		} else {
			if (needs_clone) {
				v__gen__c__Gen_write(g, _SLIT("/*2*/string_clone("));
			}
			if (g->is_fn_index_call) {
				if ((elem_typ->info)._typ == 418 /* v.ast.FnType */) {
					v__gen__c__Gen_write(g, _SLIT("(("));
					v__gen__c__Gen_write_fn_ptr_decl(g, &(*elem_typ->info._v__ast__FnType), _SLIT(""));
					v__gen__c__Gen_write(g, _STR(")(*(%.*s\000)/*ee elem_typ */array_get(", 2, array_ptr_type_str));
				}
				if (left_is_ptr && !v__ast__Type_has_flag(node.left_type, v__ast__TypeFlag_shared_f)) {
					v__gen__c__Gen_write(g, _SLIT("*"));
				}
			} else if (is_direct_array_access) {
				v__gen__c__Gen_write(g, _STR("((%.*s\000)", 2, array_ptr_type_str));
			} else {
				v__gen__c__Gen_write(g, _STR("(*(%.*s\000)/*ee elem_typ */array_get(", 2, array_ptr_type_str));
				if (left_is_ptr && !v__ast__Type_has_flag(node.left_type, v__ast__TypeFlag_shared_f)) {
					v__gen__c__Gen_write(g, _SLIT("*"));
				}
			}
		}
		v__gen__c__Gen_expr(g, node.left);
		if (v__ast__Type_has_flag(node.left_type, v__ast__TypeFlag_shared_f)) {
			if (left_is_ptr) {
				v__gen__c__Gen_write(g, _SLIT("->val"));
			} else {
				v__gen__c__Gen_write(g, _SLIT(".val"));
			}
		}
		if (is_direct_array_access && !gen_or) {
			if (left_is_ptr && !v__ast__Type_has_flag(node.left_type, v__ast__TypeFlag_shared_f)) {
				v__gen__c__Gen_write(g, _SLIT("->"));
			} else {
				v__gen__c__Gen_write(g, _SLIT("."));
			}
			v__gen__c__Gen_write(g, _SLIT("data)["));
			v__gen__c__Gen_expr(g, node.index);
			v__gen__c__Gen_write(g, _SLIT("]"));
		} else {
			v__gen__c__Gen_write(g, _SLIT(", "));
			v__gen__c__Gen_expr(g, node.index);
			if (g->is_fn_index_call) {
				v__gen__c__Gen_write(g, _SLIT(")))"));
			} else {
				v__gen__c__Gen_write(g, _SLIT("))"));
			}
		}
		if (needs_clone) {
			v__gen__c__Gen_write(g, _SLIT(")"));
		}
		if (gen_or) {
			v__gen__c__Gen_writeln(g, _SLIT(";"));
			string opt_elem_type = v__gen__c__Gen_typ(g, v__ast__Type_set_flag(elem_type, v__ast__TypeFlag_optional));
			v__gen__c__Gen_writeln(g, _STR("%.*s\000 %.*s\000 = {0};", 3, opt_elem_type, tmp_opt));
			v__gen__c__Gen_writeln(g, _STR("if (%.*s\000) {", 2, tmp_opt_ptr));
			v__gen__c__Gen_writeln(g, _STR("\t*((%.*s\000*)&%.*s\000.data) = *((%.*s\000*)%.*s\000);", 5, elem_type_str, tmp_opt, elem_type_str, tmp_opt_ptr));
			v__gen__c__Gen_writeln(g, _SLIT("} else {"));
			v__gen__c__Gen_writeln(g, _STR("\t%.*s\000.state = 2; %.*s\000.err = v_error(_SLIT(\"array index out of range\"));", 3, tmp_opt, tmp_opt));
			v__gen__c__Gen_writeln(g, _SLIT("}"));
			if (!node.is_option) {
				v__gen__c__Gen_or_block(g, tmp_opt, node.or_expr, elem_type);
			}
			v__gen__c__Gen_write(g, _STR("\n%.*s\000*(%.*s\000*)%.*s\000.data", 4, cur_line, elem_type_str, tmp_opt));
		}
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_index_of_fixed_array(v__gen__c__Gen* g, v__ast__IndexExpr node, v__ast__TypeSymbol sym) {
	v__ast__ArrayFixed info = /* as */ *(v__ast__ArrayFixed*)__as_cast((sym.info)._v__ast__ArrayFixed,(sym.info)._typ, 416) /*expected idx: 416, name: v.ast.ArrayFixed */ ;
	v__ast__Type elem_type = info.elem_type;
	v__ast__TypeSymbol* elem_sym = v__ast__Table_get_type_symbol(g->table, elem_type);
	bool is_fn_index_call = g->is_fn_index_call && (elem_sym->info)._typ == 418 /* v.ast.FnType */;
	if (is_fn_index_call) {
		v__gen__c__Gen_write(g, _SLIT("(*"));
	}
	if (v__ast__Type_is_ptr(node.left_type)) {
		v__gen__c__Gen_write(g, _SLIT("(*"));
		v__gen__c__Gen_expr(g, node.left);
		v__gen__c__Gen_write(g, _SLIT(")"));
	} else {
		v__gen__c__Gen_expr(g, node.left);
	}
	v__gen__c__Gen_write(g, _SLIT("["));
	bool direct = g->fn_decl != 0 && g->fn_decl->is_direct_arr;
	if (direct || (node.index)._typ == 259 /* v.ast.IntegerLiteral */) {
		v__gen__c__Gen_expr(g, node.index);
	} else {
		v__gen__c__Gen_write(g, _SLIT("v_fixed_index("));
		v__gen__c__Gen_expr(g, node.index);
		v__gen__c__Gen_write(g, _STR(", %"PRId32"\000)", 2, info.size));
	}
	v__gen__c__Gen_write(g, _SLIT("]"));
	if (is_fn_index_call) {
		v__gen__c__Gen_write(g, _SLIT(")"));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_index_of_map(v__gen__c__Gen* g, v__ast__IndexExpr node, v__ast__TypeSymbol sym) {
	bool gen_or = node.or_expr.kind != v__ast__OrKind_absent || node.is_option;
	bool left_is_ptr = v__ast__Type_is_ptr(node.left_type);
	v__ast__Map info = /* as */ *(v__ast__Map*)__as_cast((sym.info)._v__ast__Map,(sym.info)._typ, 396) /*expected idx: 396, name: v.ast.Map */ ;
	string key_type_str = v__gen__c__Gen_typ(g, info.key_type);
	v__ast__Type elem_type = info.value_type;
	string elem_type_str = v__gen__c__Gen_typ(g, elem_type);
	v__ast__TypeSymbol* elem_typ = v__ast__Table_get_type_symbol(g->table, elem_type);
	bool get_and_set_types = (elem_typ->kind == v__ast__Kind_struct_ || elem_typ->kind == v__ast__Kind_map);
	if (g->is_assign_lhs && !g->is_arraymap_set && !get_and_set_types) {
		if (g->assign_op == v__token__Kind_assign || v__ast__Type_alias_eq(info.value_type, _const_v__ast__string_type)) {
			g->is_arraymap_set = true;
			v__gen__c__Gen_write(g, _SLIT("map_set("));
		} else {
			if (node.is_setter) {
				v__gen__c__Gen_write(g, _STR("(*((%.*s\000*)map_get_and_set(", 2, elem_type_str));
			} else {
				v__gen__c__Gen_write(g, _STR("(*((%.*s\000*)map_get(", 2, elem_type_str));
			}
		}
		if (!left_is_ptr || v__ast__Type_has_flag(node.left_type, v__ast__TypeFlag_shared_f)) {
			v__gen__c__Gen_write(g, _SLIT("&"));
		}
		if ((node.left)._typ == 257 /* v.ast.IndexExpr */) {
			g->inside_map_index = true;
			v__gen__c__Gen_expr(g, node.left);
			g->inside_map_index = false;
		} else {
			v__gen__c__Gen_expr(g, node.left);
		}
		if (v__ast__Type_has_flag(node.left_type, v__ast__TypeFlag_shared_f)) {
			if (left_is_ptr) {
				v__gen__c__Gen_write(g, _SLIT("->val"));
			} else {
				v__gen__c__Gen_write(g, _SLIT(".val"));
			}
		}
		v__gen__c__Gen_write(g, _STR(", &(%.*s\000[]){", 2, key_type_str));
		v__gen__c__Gen_expr(g, node.index);
		v__gen__c__Gen_write(g, _SLIT("}"));
		if (elem_typ->kind == v__ast__Kind_function) {
			v__gen__c__Gen_write(g, _SLIT(", &(voidptr[]) { "));
		} else {
			g->arraymap_set_pos = g->out.len;
			v__gen__c__Gen_write(g, _STR(", &(%.*s\000[]) { ", 2, elem_type_str));
		}
		if (g->assign_op != v__token__Kind_assign && !v__ast__Type_alias_eq(info.value_type, _const_v__ast__string_type)) {
			string zero = v__gen__c__Gen_type_default(g, info.value_type);
			v__gen__c__Gen_write(g, _STR("%.*s\000 })))", 2, zero));
		}
	} else if (g->inside_map_postfix || g->inside_map_infix || g->inside_map_index || (g->is_assign_lhs && !g->is_arraymap_set && get_and_set_types)) {
		string zero = v__gen__c__Gen_type_default(g, info.value_type);
		if (node.is_setter) {
			v__gen__c__Gen_write(g, _STR("(*(%.*s\000*)map_get_and_set(", 2, elem_type_str));
		} else {
			v__gen__c__Gen_write(g, _STR("(*(%.*s\000*)map_get(", 2, elem_type_str));
		}
		if (!left_is_ptr) {
			v__gen__c__Gen_write(g, _SLIT("&"));
		}
		v__gen__c__Gen_expr(g, node.left);
		v__gen__c__Gen_write(g, _STR(", &(%.*s\000[]){", 2, key_type_str));
		v__gen__c__Gen_expr(g, node.index);
		v__gen__c__Gen_write(g, _STR("}, &(%.*s\000[]){ %.*s\000 }))", 3, elem_type_str, zero));
	} else {
		string zero = v__gen__c__Gen_type_default(g, info.value_type);
		bool is_gen_or_and_assign_rhs = gen_or && !g->discard_or_result;
		string _t3170;
		string cur_line = (is_gen_or_and_assign_rhs ? (			_t3170 = v__gen__c__Gen_go_before_stmt(g, 0),strings__Builder_write_string(&g->out, v__util__tabs(g->indent)),_t3170) : (_SLIT("")));
		string tmp_opt = (gen_or ? (v__gen__c__Gen_new_tmp_var(g)) : (_SLIT("")));
		string tmp_opt_ptr = (gen_or ? (v__gen__c__Gen_new_tmp_var(g)) : (_SLIT("")));
		if (gen_or) {
			v__gen__c__Gen_write(g, _STR("%.*s\000* %.*s\000 = (%.*s\000*)/*ee elem_ptr_typ */(map_get_check(", 4, elem_type_str, tmp_opt_ptr, elem_type_str));
		} else {
			if (g->is_fn_index_call) {
				if ((elem_typ->info)._typ == 418 /* v.ast.FnType */) {
					v__gen__c__Gen_write(g, _SLIT("(("));
					v__gen__c__Gen_write_fn_ptr_decl(g, &(*elem_typ->info._v__ast__FnType), _SLIT(""));
					v__gen__c__Gen_write(g, _SLIT(")(*(voidptr*)map_get("));
				}
			} else if (elem_typ->kind == v__ast__Kind_function) {
				v__gen__c__Gen_write(g, _SLIT("(*(voidptr*)map_get("));
			} else {
				v__gen__c__Gen_write(g, _STR("(*(%.*s\000*)map_get(", 2, elem_type_str));
			}
		}
		if (!left_is_ptr || v__ast__Type_has_flag(node.left_type, v__ast__TypeFlag_shared_f)) {
			v__gen__c__Gen_write(g, _SLIT("ADDR(map, "));
			v__gen__c__Gen_expr(g, node.left);
		} else {
			v__gen__c__Gen_write(g, _SLIT("("));
			v__gen__c__Gen_expr(g, node.left);
		}
		if (v__ast__Type_has_flag(node.left_type, v__ast__TypeFlag_shared_f)) {
			if (left_is_ptr) {
				v__gen__c__Gen_write(g, _SLIT("->val"));
			} else {
				v__gen__c__Gen_write(g, _SLIT(".val"));
			}
		}
		v__gen__c__Gen_write(g, _STR("), &(%.*s\000[]){", 2, key_type_str));
		v__gen__c__Gen_expr(g, node.index);
		v__gen__c__Gen_write(g, _SLIT("}"));
		if (gen_or) {
			v__gen__c__Gen_write(g, _SLIT("))"));
		} else if (g->is_fn_index_call) {
			v__gen__c__Gen_write(g, _STR(", &(voidptr[]){ %.*s\000 })))", 2, zero));
		} else if (elem_typ->kind == v__ast__Kind_function) {
			v__gen__c__Gen_write(g, _STR(", &(voidptr[]){ %.*s\000 }))", 2, zero));
		} else {
			v__gen__c__Gen_write(g, _STR(", &(%.*s\000[]){ %.*s\000 }))", 3, elem_type_str, zero));
		}
		if (gen_or) {
			v__gen__c__Gen_writeln(g, _SLIT(";"));
			string opt_elem_type = v__gen__c__Gen_typ(g, v__ast__Type_set_flag(elem_type, v__ast__TypeFlag_optional));
			v__gen__c__Gen_writeln(g, _STR("%.*s\000 %.*s\000 = {0};", 3, opt_elem_type, tmp_opt));
			v__gen__c__Gen_writeln(g, _STR("if (%.*s\000) {", 2, tmp_opt_ptr));
			v__gen__c__Gen_writeln(g, _STR("\t*((%.*s\000*)&%.*s\000.data) = *((%.*s\000*)%.*s\000);", 5, elem_type_str, tmp_opt, elem_type_str, tmp_opt_ptr));
			v__gen__c__Gen_writeln(g, _SLIT("} else {"));
			v__gen__c__Gen_writeln(g, _STR("\t%.*s\000.state = 2; %.*s\000.err = v_error(_SLIT(\"array index out of range\"));", 3, tmp_opt, tmp_opt));
			v__gen__c__Gen_writeln(g, _SLIT("}"));
			if (!node.is_option) {
				v__gen__c__Gen_or_block(g, tmp_opt, node.or_expr, elem_type);
			}
			v__gen__c__Gen_write(g, _STR("\n%.*s\000*(%.*s\000*)%.*s\000.data", 4, cur_line, elem_type_str, tmp_opt));
		}
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_json_for_type(v__gen__c__Gen* g, v__ast__Type typ) {
	v__ast__Type utyp = v__gen__c__Gen_unwrap_generic(g, typ);
	strings__Builder dec = strings__new_builder(100);
	strings__Builder enc = strings__new_builder(100);
	v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, utyp);
	string styp = v__gen__c__Gen_typ(g, utyp);
	if (v__gen__c__is_js_prim(sym->name) || sym->kind == v__ast__Kind_enum_) {
		return;
	}
	if (sym->kind == v__ast__Kind_array) {
	}
	if ((Array_string_contains(g->json_types, sym->name))) {
		return;
	}
	array_push(&g->json_types, _MOV((string[]){ string_clone(sym->name) }));
	string dec_fn_name = v__gen__c__js_dec_name(styp);
	v__gen__c__Gen_register_optional(g, utyp);
	string dec_fn_dec = _STR("Option_%.*s\000 %.*s\000(cJSON* root)", 3, styp, dec_fn_name);
	strings__Builder_writeln(&dec, _STR("\n%.*s\000 {\n	%.*s\000 res;\n	if (!root) {\n		const char *error_ptr = cJSON_GetErrorPtr();\n		if (error_ptr != NULL)	{\n			// fprintf(stderr, \"Error in decode() for %.*s\000 error_ptr=: %%s\\n\", error_ptr);\n			// printf(\"\\nbad js=%%%%s\\n\", js.str);\n			return (Option_%.*s\000){.state = 2,.err = v_error(tos2((byteptr)error_ptr))};\n		}\n	}\n", 5, dec_fn_dec, styp, styp, styp));
	strings__Builder_writeln(&g->json_forward_decls, _STR("%.*s\000;", 2, dec_fn_dec));
	string enc_fn_name = v__gen__c__js_enc_name(styp);
	string enc_fn_dec = _STR("cJSON* %.*s\000(%.*s\000 val)", 3, enc_fn_name, styp);
	strings__Builder_writeln(&g->json_forward_decls, _STR("%.*s\000;\n", 2, enc_fn_dec));
	strings__Builder_writeln(&enc, _STR("\n%.*s\000 {\n\tcJSON *o;", 2, enc_fn_dec));
	if (sym->kind == v__ast__Kind_array) {
		v__ast__Type value_type = v__ast__Table_value_type(g->table, utyp);
		v__gen__c__Gen_gen_json_for_type(g, value_type);
		strings__Builder_writeln(&dec, v__gen__c__Gen_decode_array(g, value_type));
		strings__Builder_writeln(&enc, v__gen__c__Gen_encode_array(g, value_type));
	} else if (sym->kind == v__ast__Kind_map) {
		v__ast__Map m = /* as */ *(v__ast__Map*)__as_cast((sym->info)._v__ast__Map,(sym->info)._typ, 396) /*expected idx: 396, name: v.ast.Map */ ;
		v__gen__c__Gen_gen_json_for_type(g, m.key_type);
		v__gen__c__Gen_gen_json_for_type(g, m.value_type);
		strings__Builder_writeln(&dec, v__gen__c__Gen_decode_map(g, m.key_type, m.value_type));
		strings__Builder_writeln(&enc, v__gen__c__Gen_encode_map(g, m.key_type, m.value_type));
	} else if (sym->kind == v__ast__Kind_alias) {
		v__ast__Alias a = /* as */ *(v__ast__Alias*)__as_cast((sym->info)._v__ast__Alias,(sym->info)._typ, 413) /*expected idx: 413, name: v.ast.Alias */ ;
		v__ast__Type parent_typ = a.parent_type;
		v__ast__TypeSymbol* psym = v__ast__Table_get_type_symbol(g->table, parent_typ);
		if (v__gen__c__is_js_prim(v__gen__c__Gen_typ(g, parent_typ))) {
			v__gen__c__Gen_gen_json_for_type(g, parent_typ);
			return;
		}
		strings__Builder_writeln(&enc, _SLIT("\to = cJSON_CreateObject();"));
		if ((psym->info)._typ != 409 /* v.ast.Struct */) {
			v__gen__c__verror(_STR("json: %.*s\000 is not struct", 2, sym->name));
		}
		v__gen__c__Gen_gen_struct_enc_dec(g, psym->info, styp, (voidptr)&/*qq*/enc, (voidptr)&/*qq*/dec);
	} else {
		strings__Builder_writeln(&enc, _SLIT("\to = cJSON_CreateObject();"));
		if ((sym->info)._typ != 409 /* v.ast.Struct */) {
			v__gen__c__verror(_STR("json: %.*s\000 is not struct", 2, sym->name));
		}
		v__gen__c__Gen_gen_struct_enc_dec(g, sym->info, styp, (voidptr)&/*qq*/enc, (voidptr)&/*qq*/dec);
	}
	strings__Builder_writeln(&dec, _STR("\tOption_%.*s\000 ret;", 2, styp));
	strings__Builder_writeln(&dec, _SLIT("\topt_ok(&res, (Option*)&ret, sizeof(res));"));
	strings__Builder_writeln(&dec, _SLIT("\treturn ret;\n}"));
	strings__Builder_writeln(&enc, _SLIT("\treturn o;\n}"));
	strings__Builder_writeln(&g->definitions, strings__Builder_str(&dec));
	strings__Builder_writeln(&g->gowrappers, strings__Builder_str(&enc));
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_struct_enc_dec(v__gen__c__Gen* g, v__ast__TypeInfo type_info, string styp, strings__Builder* enc, strings__Builder* dec) {
	v__ast__Struct info = /* as */ *(v__ast__Struct*)__as_cast((type_info)._v__ast__Struct,(type_info)._typ, 409) /*expected idx: 409, name: v.ast.Struct */ ;
	// FOR IN array
	for (int _t3172 = 0; _t3172 < info.fields.len; ++_t3172) {
		v__ast__StructField field = ((v__ast__StructField*)info.fields.data)[_t3172];
		if (Array_v__ast__Attr_contains(field.attrs, _SLIT("skip"))) {
			continue;
		}
		string name = field.name;
		// FOR IN array
		for (int _t3173 = 0; _t3173 < field.attrs.len; ++_t3173) {
			v__ast__Attr attr = ((v__ast__Attr*)field.attrs.data)[_t3173];
			if (string_eq(attr.name, _SLIT("json"))) {
				name = attr.arg;
				break;
			}
		}
		string field_type = v__gen__c__Gen_typ(g, field.typ);
		v__ast__TypeSymbol* field_sym = v__ast__Table_get_type_symbol(g->table, field.typ);
		if (Array_v__ast__Attr_contains(field.attrs, _SLIT("raw"))) {
			strings__Builder_writeln(dec, string_add(_STR("\tres.%.*s\000 = tos4(cJSON_PrintUnformatted(", 2, v__gen__c__c_name(field.name)), _STR("js_get(root, \"%.*s\000\")));", 2, name)));
		} else {
			v__gen__c__Gen_gen_json_for_type(g, field.typ);
			string dec_name = v__gen__c__js_dec_name(field_type);
			if (v__gen__c__is_js_prim(field_type)) {
				strings__Builder_writeln(dec, _STR("\tres.%.*s\000 = %.*s\000 (js_get(root, \"%.*s\000\"));", 4, v__gen__c__c_name(field.name), dec_name, name));
			} else if (field_sym->kind == v__ast__Kind_enum_) {
				strings__Builder_writeln(dec, _STR("\tres.%.*s\000 = json__decode_u64(js_get(root, \"%.*s\000\"));", 3, v__gen__c__c_name(field.name), name));
			} else if (string_eq(field_sym->name, _SLIT("time.Time"))) {
				strings__Builder_writeln(dec, _STR("\tres.%.*s\000 = time__unix(json__decode_u64(js_get(root, \"%.*s\000\")));", 3, v__gen__c__c_name(field.name), name));
			} else if (field_sym->kind == v__ast__Kind_alias) {
				v__ast__Alias alias = /* as */ *(v__ast__Alias*)__as_cast((field_sym->info)._v__ast__Alias,(field_sym->info)._typ, 413) /*expected idx: 413, name: v.ast.Alias */ ;
				string parent_type = v__gen__c__Gen_typ(g, alias.parent_type);
				string parent_dec_name = v__gen__c__js_dec_name(parent_type);
				if (v__gen__c__is_js_prim(parent_type)) {
					strings__Builder_writeln(dec, _STR("\tres.%.*s\000 = %.*s\000 (js_get(root, \"%.*s\000\"));", 4, v__gen__c__c_name(field.name), parent_dec_name, name));
				} else {
					v__gen__c__Gen_gen_json_for_type(g, field.typ);
					string tmp = v__gen__c__Gen_new_tmp_var(g);
					strings__Builder_writeln(dec, _STR("\tOption_%.*s\000 %.*s\000 = %.*s\000 (js_get(root,\"%.*s\000\"));", 5, field_type, tmp, dec_name, name));
					strings__Builder_writeln(dec, _STR("\tif(%.*s\000.state != 0) {", 2, tmp));
					strings__Builder_writeln(dec, _STR("\t\treturn *(Option_%.*s\000*) &%.*s\000;", 3, styp, tmp));
					strings__Builder_writeln(dec, _SLIT("\t}"));
					strings__Builder_writeln(dec, _STR("\tres.%.*s\000 = *(%.*s\000*) %.*s\000.data;", 4, v__gen__c__c_name(field.name), field_type, tmp));
				}
			} else {
				string tmp = v__gen__c__Gen_new_tmp_var(g);
				strings__Builder_writeln(dec, _STR("\tOption_%.*s\000 %.*s\000 = %.*s\000 (js_get(root,\"%.*s\000\"));", 5, field_type, tmp, dec_name, name));
				strings__Builder_writeln(dec, _STR("\tif(%.*s\000.state != 0) {", 2, tmp));
				strings__Builder_writeln(dec, _STR("\t\treturn *(Option_%.*s\000*) &%.*s\000;", 3, styp, tmp));
				strings__Builder_writeln(dec, _SLIT("\t}"));
				strings__Builder_writeln(dec, _STR("\tres.%.*s\000 = *(%.*s\000*) %.*s\000.data;", 4, v__gen__c__c_name(field.name), field_type, tmp));
			}
		}
		string enc_name = v__gen__c__js_enc_name(field_type);
		if (!v__gen__c__is_js_prim(field_type)) {
			if (field_sym->kind == v__ast__Kind_alias) {
				v__ast__Alias ainfo = /* as */ *(v__ast__Alias*)__as_cast((field_sym->info)._v__ast__Alias,(field_sym->info)._typ, 413) /*expected idx: 413, name: v.ast.Alias */ ;
				enc_name = v__gen__c__js_enc_name(v__gen__c__Gen_typ(g, ainfo.parent_type));
			}
		}
		if (field_sym->kind == v__ast__Kind_enum_) {
			strings__Builder_writeln(enc, _STR("\tcJSON_AddItemToObject(o, \"%.*s\000\", json__encode_u64(val.%.*s\000));", 3, name, v__gen__c__c_name(field.name)));
		} else {
			if (string_eq(field_sym->name, _SLIT("time.Time"))) {
				strings__Builder_writeln(enc, _STR("\tcJSON_AddItemToObject(o, \"%.*s\000\", json__encode_u64(val.%.*s\000.v_unix));", 3, name, v__gen__c__c_name(field.name)));
			} else {
				strings__Builder_writeln(enc, _STR("\tcJSON_AddItemToObject(o, \"%.*s\000\", %.*s\000(val.%.*s\000));", 4, name, enc_name, v__gen__c__c_name(field.name)));
			}
		}
	}
}

VV_LOCAL_SYMBOL string v__gen__c__js_enc_name(string typ) {
	string suffix = (string_ends_with(typ, _SLIT("*")) ? (string_replace(typ, _SLIT("*"), _SLIT(""))) : (typ));
	string name = _STR("json__encode_%.*s", 1, suffix);
	 string _t3174 = v__util__no_dots(name);
	// autofree_scope_vars(pos=6710 line_nr=194 scope.pos=6574 scope.end_pos=6737)
	// var "typ" var.pos=6586 var.line_nr=191
	// var "suffix" var.pos=6608 var.line_nr=192
	// var "name" var.pos=6679 var.line_nr=193
	// af parent scope:
	// af parent scope:
	return _t3174;
}

VV_LOCAL_SYMBOL string v__gen__c__js_dec_name(string typ) {
	string name = _STR("json__decode_%.*s", 1, typ);
	 string _t3175 = v__util__no_dots(name);
	// autofree_scope_vars(pos=6805 line_nr=199 scope.pos=6743 scope.end_pos=6832)
	// var "typ" var.pos=6755 var.line_nr=197
	// var "name" var.pos=6777 var.line_nr=198
	// af parent scope:
	// af parent scope:
	return _t3175;
}

VV_LOCAL_SYMBOL bool v__gen__c__is_js_prim(string typ) {
	 bool _t3176 = (string_eq(typ, _SLIT("int")) || string_eq(typ, _SLIT("string")) || string_eq(typ, _SLIT("bool")) || string_eq(typ, _SLIT("f32")) || string_eq(typ, _SLIT("f64")) || string_eq(typ, _SLIT("i8")) || string_eq(typ, _SLIT("i16")) || string_eq(typ, _SLIT("i64")) || string_eq(typ, _SLIT("u16")) || string_eq(typ, _SLIT("u32")) || string_eq(typ, _SLIT("u64")) || string_eq(typ, _SLIT("byte")));
	// autofree_scope_vars(pos=6868 line_nr=203 scope.pos=6838 scope.end_pos=6977)
	// var "typ" var.pos=6849 var.line_nr=202
	// af parent scope:
	// af parent scope:
	return _t3176;
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_decode_array(v__gen__c__Gen* g, v__ast__Type value_type) {
	string styp = v__gen__c__Gen_typ(g, value_type);
	string fn_name = v__gen__c__js_dec_name(styp);
	string s = _SLIT("");
	if (v__gen__c__is_js_prim(styp)) {
		s = _STR("%.*s\000 val = %.*s\000((cJSON *)jsval); ", 3, styp, fn_name);
	} else {
		s = _STR("\n		Option_%.*s\000 val2 = %.*s\000 ((cJSON *)jsval);\n		if(val2.state != 0) {\n			array_free(&res);\n			return *(Option_Array_%.*s\000*)&val2;\n		}\n		%.*s\000 val = *(%.*s\000*)val2.data;\n", 6, styp, fn_name, styp, styp, styp);
	}
	 string _t3177 = _STR("\n	if(root && !cJSON_IsArray(root) && !cJSON_IsNull(root)) {\n		return (Option_Array_%.*s\000){.state = 2, .err = v_error(string_add(_SLIT(\"Json element is not an array: \"), tos2((byteptr)cJSON_PrintUnformatted(root))))};\n	}\n	res = __new_array(0, 0, sizeof(%.*s\000));\n	const cJSON *jsval = NULL;\n	cJSON_ArrayForEach(jsval, root)\n	{\n	%.*s\000\n		array_push(&res, &val);\n	}\n", 4, styp, styp, s);
	// autofree_scope_vars(pos=7374 line_nr=224 scope.pos=6983 scope.end_pos=7743)
	// var "g" var.pos=6988 var.line_nr=208
	// var "value_type" var.pos=7008 var.line_nr=208
	// var "styp" var.pos=7039 var.line_nr=209
	// var "fn_name" var.pos=7066 var.line_nr=210
	// var "s" var.pos=7100 var.line_nr=211
	// str literal
	// af parent scope:
	// af parent scope:
	return _t3177;
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_encode_array(v__gen__c__Gen* g, v__ast__Type value_type) {
	string styp = v__gen__c__Gen_typ(g, value_type);
	string fn_name = v__gen__c__js_enc_name(styp);
	 string _t3178 = _STR("\n	o = cJSON_CreateArray();\n	for (int i = 0; i < val.len; i++){\n		cJSON_AddItemToArray(o, %.*s\000 (  ((%.*s\000*)val.data)[i]  ));\n	}\n", 3, fn_name, styp);
	// autofree_scope_vars(pos=7861 line_nr=240 scope.pos=7749 scope.end_pos=8003)
	// var "g" var.pos=7754 var.line_nr=237
	// var "value_type" var.pos=7774 var.line_nr=237
	// var "styp" var.pos=7805 var.line_nr=238
	// var "fn_name" var.pos=7832 var.line_nr=239
	// af parent scope:
	// af parent scope:
	return _t3178;
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_decode_map(v__gen__c__Gen* g, v__ast__Type key_type, v__ast__Type value_type) {
	string styp = v__gen__c__Gen_typ(g, key_type);
	string styp_v = v__gen__c__Gen_typ(g, value_type);
	v__ast__TypeSymbol* key_type_symbol = v__ast__Table_get_type_symbol(g->table, key_type);
	multi_return_string_string_string_string mr_8228 = v__gen__c__Gen_map_fn_ptrs(g, *key_type_symbol);
	string hash_fn = mr_8228.arg0;
	string key_eq_fn = mr_8228.arg1;
	string clone_fn = mr_8228.arg2;
	string free_fn = mr_8228.arg3;
	string fn_name_v = v__gen__c__js_dec_name(styp_v);
	string s = _SLIT("");
	if (v__gen__c__is_js_prim(styp_v)) {
		s = _STR("%.*s\000 val = %.*s\000 (js_get(root, jsval->string));", 3, styp_v, fn_name_v);
	} else {
		s = _STR("\n		Option_%.*s\000 val2 = %.*s\000 (js_get(root, jsval->string));\n		if(val2.state != 0) {\n			map_free(&res);\n			return *(Option_Map_%.*s\000_%.*s\000*)&val2;\n		}\n		%.*s\000 val = *(%.*s\000*)val2.data;\n", 7, styp_v, fn_name_v, styp, styp_v, styp_v, styp_v);
	}
	 string _t3179 = _STR("\n	if(!cJSON_IsObject(root) && !cJSON_IsNull(root)) {\n		return (Option_Map_%.*s\000_%.*s\000){ .state = 2, .err = v_error( string_add(_SLIT(\"Json element is not an object: \"), tos2((byteptr)cJSON_PrintUnformatted(root))) )};\n	}\n	res = new_map(sizeof(%.*s\000), sizeof(%.*s\000), %.*s\000, %.*s\000, %.*s\000, %.*s\000);\n	cJSON *jsval = NULL;\n	cJSON_ArrayForEach(jsval, root)\n	{\n		%.*s\000\n		string key = tos2((byteptr)jsval->string);\n		map_set(&res, &key, &val);\n	}\n", 10, styp, styp_v, styp, styp_v, hash_fn, key_eq_fn, clone_fn, free_fn, s);
	// autofree_scope_vars(pos=8619 line_nr=267 scope.pos=8009 scope.end_pos=9086)
	// var "g" var.pos=8014 var.line_nr=248
	// var "key_type" var.pos=8032 var.line_nr=248
	// var "value_type" var.pos=8051 var.line_nr=248
	// var "styp" var.pos=8082 var.line_nr=249
	// var "styp_v" var.pos=8107 var.line_nr=250
	// var "key_type_symbol" var.pos=8136 var.line_nr=251
	// var "hash_fn" var.pos=8190 var.line_nr=252
	// var "key_eq_fn" var.pos=8199 var.line_nr=252
	// var "clone_fn" var.pos=8210 var.line_nr=252
	// var "free_fn" var.pos=8220 var.line_nr=252
	// var "fn_name_v" var.pos=8263 var.line_nr=253
	// var "s" var.pos=8301 var.line_nr=254
	// str literal
	// af parent scope:
	// af parent scope:
	return _t3179;
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_encode_map(v__gen__c__Gen* g, v__ast__Type key_type, v__ast__Type value_type) {
	string styp = v__gen__c__Gen_typ(g, key_type);
	string styp_v = v__gen__c__Gen_typ(g, value_type);
	string fn_name_v = v__gen__c__js_enc_name(styp_v);
	string zero = v__gen__c__Gen_type_default(g, value_type);
	string keys_tmp = v__gen__c__Gen_new_tmp_var(g);
	string key = _SLIT("string key = ");
	if (v__ast__Type_is_string(key_type)) {
		key = /*f*/string_add(key, _STR("((%.*s\000*)%.*s\000.data)[i];", 3, styp, keys_tmp));
	} else {
		v__gen__c__verror(_SLIT("json: encode only maps with string keys"));
	}
	 string _t3180 = _STR("\n	o = cJSON_CreateObject();\n	Array_%.*s\000 %.*s\000 = map_keys(&val);\n	for (int i = 0; i < %.*s\000.len; ++i) {\n		%.*s\000\n		cJSON_AddItemToObject(o, (char*) key.str, %.*s\000 ( *(%.*s\000*) map_get(&val, &key, &(%.*s\000[]) { %.*s\000 } ) ) );\n	}\n	array_free(&%.*s\000);\n", 10, styp, keys_tmp, keys_tmp, key, fn_name_v, styp_v, styp_v, zero, keys_tmp);
	// autofree_scope_vars(pos=9537 line_nr=294 scope.pos=9092 scope.end_pos=9816)
	// var "g" var.pos=9097 var.line_nr=281
	// var "key_type" var.pos=9115 var.line_nr=281
	// var "value_type" var.pos=9134 var.line_nr=281
	// var "styp" var.pos=9165 var.line_nr=282
	// var "styp_v" var.pos=9190 var.line_nr=283
	// var "fn_name_v" var.pos=9219 var.line_nr=284
	// var "zero" var.pos=9253 var.line_nr=285
	// var "keys_tmp" var.pos=9289 var.line_nr=286
	// var "key" var.pos=9322 var.line_nr=287
	// str literal
	// af parent scope:
	// af parent scope:
	return _t3180;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_generate_hotcode_reloading_declarations(v__gen__c__Gen* g) {
	if (g->pref->os == v__pref__OS_windows) {
		if (g->pref->is_livemain) {
			strings__Builder_writeln(&g->hotcode_definitions, _SLIT("HANDLE live_fn_mutex = 0;"));
		}
		if (g->pref->is_liveshared) {
			strings__Builder_writeln(&g->hotcode_definitions, _SLIT("HANDLE live_fn_mutex;"));
		}
		strings__Builder_writeln(&g->hotcode_definitions, _SLIT("\nvoid pthread_mutex_lock(HANDLE *m) {\n	WaitForSingleObject(*m, INFINITE);\n}\nvoid pthread_mutex_unlock(HANDLE *m) {\n	ReleaseMutex(*m);\n}\n"));
	} else {
		if (g->pref->is_livemain) {
			strings__Builder_writeln(&g->hotcode_definitions, _SLIT("pthread_mutex_t live_fn_mutex = PTHREAD_MUTEX_INITIALIZER;"));
		}
		if (g->pref->is_liveshared) {
			strings__Builder_writeln(&g->hotcode_definitions, _SLIT("pthread_mutex_t live_fn_mutex;"));
		}
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_generate_hotcode_reloader_code(v__gen__c__Gen* g) {
	if (g->pref->is_liveshared) {
		strings__Builder_writeln(&g->hotcode_definitions, _SLIT(""));
		return;
	}
	if (g->pref->is_livemain) {
		string phd = _SLIT("");
		Array_string load_code = __new_array_with_default(0, 0, sizeof(string), 0);
		if (g->pref->os != v__pref__OS_windows) {
			// FOR IN array
			for (int _t3181 = 0; _t3181 < g->hotcode_fn_names.len; ++_t3181) {
				string so_fn = ((string*)g->hotcode_fn_names.data)[_t3181];
				array_push(&load_code, _MOV((string[]){ string_clone(_STR("impl_live_%.*s\000 = dlsym(live_lib, \"impl_live_%.*s\000\");", 3, so_fn, so_fn)) }));
			}
			phd = _const_v__gen__c__posix_hotcode_definitions_1;
		} else {
			// FOR IN array
			for (int _t3183 = 0; _t3183 < g->hotcode_fn_names.len; ++_t3183) {
				string so_fn = ((string*)g->hotcode_fn_names.data)[_t3183];
				array_push(&load_code, _MOV((string[]){ string_clone(_STR("impl_live_%.*s\000 = (void *)GetProcAddress(live_lib, \"impl_live_%.*s\000\");  ", 3, so_fn, so_fn)) }));
			}
			phd = _const_v__gen__c__windows_hotcode_definitions_1;
		}
		strings__Builder_writeln(&g->hotcode_definitions, string_replace(phd, _SLIT("@LOAD_FNS@"), Array_string_join(load_code, _SLIT("\n"))));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_generate_hotcode_reloading_main_caller(v__gen__c__Gen* g) {
	if (!g->pref->is_livemain) {
		return;
	}
	v__gen__c__Gen_writeln(g, _SLIT(""));
	v__gen__c__Gen_writeln(g, _SLIT("\t// live code initialization section:"));
	v__gen__c__Gen_writeln(g, _SLIT("\t{"));
	v__gen__c__Gen_writeln(g, _SLIT("\t\t// initialization of live function pointers"));
	// FOR IN array
	for (int _t3185 = 0; _t3185 < g->hotcode_fn_names.len; ++_t3185) {
		string fname = ((string*)g->hotcode_fn_names.data)[_t3185];
		v__gen__c__Gen_writeln(g, _STR("\t\timpl_live_%.*s\000 = 0;", 2, fname));
	}
	string vexe = v__util__cescaped_path(v__pref__vexe_path());
	string file = v__util__cescaped_path(g->pref->path);
	string msvc = (string_eq(g->pref->ccompiler, _SLIT("msvc")) ? (_SLIT("-cc msvc")) : (_SLIT("")));
	string so_debug_flag = (g->pref->is_debug ? (_SLIT("-cg")) : (_SLIT("")));
	string vopts = _STR("%.*s\000 %.*s\000 -sharedlive -shared", 3, msvc, so_debug_flag);
	v__gen__c__Gen_writeln(g, _SLIT("\t\t// start background reloading thread"));
	if (g->pref->os == v__pref__OS_windows) {
		v__gen__c__Gen_writeln(g, _SLIT("\t\tlive_fn_mutex = CreateMutexA(0, 0, 0);"));
	}
	v__gen__c__Gen_writeln(g, _SLIT("\t\tv__live__LiveReloadInfo* live_info = v__live__executable__new_live_reload_info("));
	v__gen__c__Gen_writeln(g, _STR("\t\t\t\t\t tos2(\"%.*s\000\"),", 2, file));
	v__gen__c__Gen_writeln(g, _STR("\t\t\t\t\t tos2(\"%.*s\000\"),", 2, vexe));
	v__gen__c__Gen_writeln(g, _STR("\t\t\t\t\t tos2(\"%.*s\000\"),", 2, vopts));
	v__gen__c__Gen_writeln(g, _SLIT("\t\t\t\t\t &live_fn_mutex,"));
	v__gen__c__Gen_writeln(g, _SLIT("\t\t\t\t\t v_bind_live_symbols"));
	v__gen__c__Gen_writeln(g, _SLIT("\t\t);"));
	v__gen__c__Gen_writeln(g, _SLIT("\t\t   g_live_info = (void*)live_info;"));
	v__gen__c__Gen_writeln(g, _SLIT("\t\tv__live__executable__start_reloader(live_info);"));
	v__gen__c__Gen_writeln(g, _SLIT("\t}\t// end of live code initialization section"));
	v__gen__c__Gen_writeln(g, _SLIT(""));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_profile_fn(v__gen__c__Gen* g, v__ast__FnDecl fn_decl) {
	if (g->pref->profile_no_inline && Array_v__ast__Attr_contains(fn_decl.attrs, _SLIT("inline"))) {
		g->defer_profile_code = _SLIT("");
		return;
	}
	string fn_name = fn_decl.name;
	if (string_starts_with(fn_name, _SLIT("time.vpc_now"))) {
		g->defer_profile_code = _SLIT("");
	} else {
		string measure_fn_name = (g->pref->os == v__pref__OS_macos ? (_SLIT("time__vpc_now_darwin")) : (_SLIT("time__vpc_now")));
		string fn_profile_counter_name = _STR("vpc_%.*s", 1, g->last_fn_c_name);
		string fn_profile_counter_name_calls = _STR("%.*s\000_calls", 2, fn_profile_counter_name);
		v__gen__c__Gen_writeln(g, _SLIT(""));
		v__gen__c__Gen_writeln(g, _STR("\tdouble _PROF_FN_START = %.*s\000(); %.*s\000++; // %.*s", 3, measure_fn_name, fn_profile_counter_name_calls, fn_name));
		v__gen__c__Gen_writeln(g, _SLIT(""));
		g->defer_profile_code = _STR("\t%.*s\000 += %.*s\000() - _PROF_FN_START;", 3, fn_profile_counter_name, measure_fn_name);
		strings__Builder_writeln(&g->pcs_declarations, _STR("double %.*s\000 = 0.0; u64 %.*s\000 = 0;", 3, fn_profile_counter_name, fn_profile_counter_name_calls));
		array_push(&g->pcs, _MOV((v__gen__c__ProfileCounterMeta[]){ (v__gen__c__ProfileCounterMeta){.fn_name = g->last_fn_c_name,.vpc_name = fn_profile_counter_name,.vpc_calls = fn_profile_counter_name_calls,} }));
	}
}

void v__gen__c__Gen_gen_vprint_profile_stats(v__gen__c__Gen* g) {
	strings__Builder_writeln(&g->pcs_declarations, _SLIT("void vprint_profile_stats(){"));
	string fstring = _SLIT("\"%14llu %14.3fms %14.0fns %s \\n\"");
	if (string_eq(g->pref->profile_file, _SLIT("-"))) {
		// FOR IN array
		for (int _t3187 = 0; _t3187 < g->pcs.len; ++_t3187) {
			v__gen__c__ProfileCounterMeta pc_meta = ((v__gen__c__ProfileCounterMeta*)g->pcs.data)[_t3187];
			strings__Builder_writeln(&g->pcs_declarations, _STR("\tif (%.*s\000) printf(%.*s\000, %.*s\000, %.*s\000/1000000.0, %.*s\000/%.*s\000, \"%.*s\000\" );", 8, pc_meta.vpc_calls, fstring, pc_meta.vpc_calls, pc_meta.vpc_name, pc_meta.vpc_name, pc_meta.vpc_calls, pc_meta.fn_name));
		}
	} else {
		strings__Builder_writeln(&g->pcs_declarations, _SLIT("\tFILE * fp;"));
		strings__Builder_writeln(&g->pcs_declarations, _STR("\tfp = fopen (\"%.*s\000\", \"w+\");", 2, g->pref->profile_file));
		// FOR IN array
		for (int _t3188 = 0; _t3188 < g->pcs.len; ++_t3188) {
			v__gen__c__ProfileCounterMeta pc_meta = ((v__gen__c__ProfileCounterMeta*)g->pcs.data)[_t3188];
			strings__Builder_writeln(&g->pcs_declarations, _STR("\tif (%.*s\000) fprintf(fp, %.*s\000, %.*s\000, %.*s\000/1000000.0, %.*s\000/%.*s\000, \"%.*s\000\" );", 8, pc_meta.vpc_calls, fstring, pc_meta.vpc_calls, pc_meta.vpc_name, pc_meta.vpc_name, pc_meta.vpc_calls, pc_meta.fn_name));
		}
		strings__Builder_writeln(&g->pcs_declarations, _SLIT("\tfclose(fp);"));
	}
	strings__Builder_writeln(&g->pcs_declarations, _SLIT("}"));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_sql_stmt(v__gen__c__Gen* g, v__ast__SqlStmt node) {
	if (node.kind == v__ast__SqlStmtKind_create) {
		v__gen__c__Gen_sql_create_table(g, node);
		return;
	}
	g->sql_table_name = v__ast__Table_get_type_symbol(g->table, node.table_expr.typ)->name;
	v__gen__c__SqlType typ = v__gen__c__Gen_parse_db_type(g, node.db_expr);

	if (typ == (v__gen__c__SqlType_sqlite3)) {
		v__gen__c__Gen_sqlite3_stmt(g, node, typ);
	}
	else if (typ == (v__gen__c__SqlType_mysql)) {
		v__gen__c__Gen_mysql_stmt(g, node, typ);
	}
	else {
		v__gen__c__verror(_STR("This database type `%.*s\000` is not implemented yet in orm", 2, v__gen__c__SqlType_str(typ)));
	};
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_sql_create_table(v__gen__c__Gen* g, v__ast__SqlStmt node) {
	v__gen__c__SqlType typ = v__gen__c__Gen_parse_db_type(g, node.db_expr);

	if (typ == (v__gen__c__SqlType_sqlite3)) {
		v__gen__c__Gen_sqlite3_create_table(g, node, typ);
	}
	else if (typ == (v__gen__c__SqlType_mysql)) {
		v__gen__c__Gen_mysql_create_table(g, node, typ);
	}
	else {
		v__gen__c__verror(_STR("This database type `%.*s\000` is not implemented yet in orm", 2, v__gen__c__SqlType_str(typ)));
	};
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_sql_select_expr(v__gen__c__Gen* g, v__ast__SqlExpr node, bool sub, string line) {
	g->sql_table_name = v__ast__Table_get_type_symbol(g->table, node.table_expr.typ)->name;
	v__gen__c__SqlType typ = v__gen__c__Gen_parse_db_type(g, node.db_expr);

	if (typ == (v__gen__c__SqlType_sqlite3)) {
		v__gen__c__Gen_sqlite3_select_expr(g, node, sub, line, typ);
	}
	else if (typ == (v__gen__c__SqlType_mysql)) {
		v__gen__c__Gen_mysql_select_expr(g, node, sub, line, typ);
	}
	else {
		v__gen__c__verror(_STR("This database type `%.*s\000` is not implemented yet in orm", 2, v__gen__c__SqlType_str(typ)));
	};
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_sql_bind(v__gen__c__Gen* g, string val, string len, v__ast__Type real_type, v__gen__c__SqlType typ) {

	if (typ == (v__gen__c__SqlType_sqlite3)) {
		v__gen__c__Gen_sqlite3_bind(g, val, len, real_type);
	}
	else if (typ == (v__gen__c__SqlType_mysql)) {
		v__gen__c__Gen_mysql_bind(g, val, real_type);
	}
	else {
	};
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_sql_type_from_v(v__gen__c__Gen* g, v__gen__c__SqlType typ, v__ast__Type v_typ) {

	if (typ == (v__gen__c__SqlType_sqlite3)) {
		 string _t3189 = v__gen__c__Gen_sqlite3_type_from_v(g, v_typ);
		// autofree_scope_vars(pos=1846 line_nr=91 scope.pos=1833 scope.end_pos=1885)
		// af parent scope:
		// var "g" var.pos=1757 var.line_nr=88
		// var "typ" var.pos=1780 var.line_nr=88
		// var "v_typ" var.pos=1793 var.line_nr=88
		// af parent scope:
		// af parent scope:
		return _t3189;
	}
	else if (typ == (v__gen__c__SqlType_mysql)) {
		 string _t3190 = v__gen__c__Gen_mysql_get_table_type(g, v_typ);
		// autofree_scope_vars(pos=1900 line_nr=94 scope.pos=1889 scope.end_pos=1940)
		// af parent scope:
		// var "g" var.pos=1757 var.line_nr=88
		// var "typ" var.pos=1780 var.line_nr=88
		// var "v_typ" var.pos=1793 var.line_nr=88
		// af parent scope:
		// af parent scope:
		return _t3190;
	}
	else {
	};
	 string _t3191 = _SLIT("");
	// autofree_scope_vars(pos=1974 line_nr=100 scope.pos=1752 scope.end_pos=1985)
	// var "g" var.pos=1757 var.line_nr=88
	// var "typ" var.pos=1780 var.line_nr=88
	// var "v_typ" var.pos=1793 var.line_nr=88
	// af parent scope:
	// af parent scope:
	return _t3191;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_sqlite3_stmt(v__gen__c__Gen* g, v__ast__SqlStmt node, v__gen__c__SqlType typ) {
	g->sql_i = 0;
	v__gen__c__Gen_writeln(g, _SLIT("\n\t// sql insert"));
	string db_name = v__gen__c__Gen_new_tmp_var(g);
	g->sql_stmt_name = v__gen__c__Gen_new_tmp_var(g);
	v__gen__c__Gen_write(g, _STR("%.*s\000__DB %.*s\000 = ", 3, _const_v__gen__c__dbtype, db_name));
	v__gen__c__Gen_expr(g, node.db_expr);
	v__gen__c__Gen_writeln(g, _SLIT(";"));
	v__gen__c__Gen_write(g, _STR("sqlite3_stmt* %.*s\000 = %.*s\000__DB_init_stmt(%.*s\000, _SLIT(\"", 4, g->sql_stmt_name, _const_v__gen__c__dbtype, db_name));
	v__gen__c__Gen_sql_defaults(g, node, typ);
	v__gen__c__Gen_writeln(g, _SLIT(");"));
	if (node.kind == v__ast__SqlStmtKind_insert) {
		// FOR IN array
		for (int i = 0; i < node.fields.len; ++i) {
			v__ast__StructField field = ((v__ast__StructField*)node.fields.data)[i];
			if (string_eq(field.name, _SLIT("id"))) {
				continue;
			}
			string x = _STR("%.*s\000.%.*s", 2, node.object_var_name, field.name);
			if (v__ast__Type_alias_eq(field.typ, _const_v__ast__string_type)) {
				v__gen__c__Gen_writeln(g, _STR("sqlite3_bind_text(%.*s\000, %"PRId32"\000, %.*s\000.str, %.*s\000.len, 0);", 5, g->sql_stmt_name, i + 0, x, x));
			} else if ((*(v__ast__TypeSymbol*)/*ee elem_typ */array_get(g->table->type_symbols, ((int)(field.typ)))).kind == v__ast__Kind_struct_) {
				v__ast__SqlStmt expr = (*(v__ast__SqlStmt*)map_get(ADDR(map, node.sub_structs), &(int[]){((int)(field.typ))}, &(v__ast__SqlStmt[]){ (v__ast__SqlStmt){.updated_columns = __new_array(0, 1, sizeof(string)),.update_exprs = __new_array(0, 1, sizeof(v__ast__Expr)),.fields = __new_array(0, 1, sizeof(v__ast__StructField)),.sub_structs = new_map(sizeof(int), sizeof(v__ast__SqlStmt), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),} }));
				string tmp_sql_stmt_name = g->sql_stmt_name;
				string tmp_sql_table_name = g->sql_table_name;
				v__gen__c__Gen_sql_stmt(g, expr);
				g->sql_stmt_name = tmp_sql_stmt_name;
				g->sql_table_name = tmp_sql_table_name;
				v__gen__c__Gen_writeln(g, _STR("Array_sqlite__Row rows = sqlite__DB_exec(%.*s\000, _SLIT(\"SELECT last_insert_rowid()\")).arg0;", 2, db_name));
				string id_name = v__gen__c__Gen_new_tmp_var(g);
				v__gen__c__Gen_writeln(g, _STR("int %.*s\000 = string_int((*(string*)array_get((*(sqlite__Row*)array_get(rows, 0)).vals, 0)));", 2, id_name));
				v__gen__c__Gen_writeln(g, _STR("sqlite3_bind_int(%.*s\000, %"PRId32"\000 , %.*s\000); // id", 4, g->sql_stmt_name, i + 0, id_name));
			} else {
				v__gen__c__Gen_writeln(g, _STR("sqlite3_bind_int(%.*s\000, %"PRId32"\000 , %.*s\000); // stmt", 4, g->sql_stmt_name, i + 0, x));
			}
		}
	}
	string binds = strings__Builder_str(&g->sql_buf);
	g->sql_buf = strings__new_builder(100);
	v__gen__c__Gen_writeln(g, binds);
	string step_res = v__gen__c__Gen_new_tmp_var(g);
	v__gen__c__Gen_writeln(g, _STR("\tint %.*s\000 = sqlite3_step(%.*s\000);", 3, step_res, g->sql_stmt_name));
	v__gen__c__Gen_writeln(g, _STR("\tif( (%.*s\000 != SQLITE_OK) && (%.*s\000 != SQLITE_DONE)){ puts(sqlite3_errmsg(%.*s\000.conn)); }", 4, step_res, step_res, db_name));
	v__gen__c__Gen_writeln(g, _STR("\tsqlite3_finalize(%.*s\000);", 2, g->sql_stmt_name));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_sqlite3_select_expr(v__gen__c__Gen* g, v__ast__SqlExpr node, bool sub, string line, v__gen__c__SqlType sql_typ) {
	g->sql_i = 0;
	string cur_line = line;
	if (!sub) {
		cur_line = v__gen__c__Gen_go_before_stmt(g, 0);
	}
	g->sql_stmt_name = v__gen__c__Gen_new_tmp_var(g);
	string db_name = v__gen__c__Gen_new_tmp_var(g);
	v__gen__c__Gen_writeln(g, _SLIT("\n\t// sql select"));
	v__gen__c__Gen_write(g, _STR("%.*s\000__DB %.*s\000 = ", 3, _const_v__gen__c__dbtype, db_name));
	v__gen__c__Gen_expr(g, node.db_expr);
	v__gen__c__Gen_writeln(g, _SLIT(";"));
	string stmt_name = v__gen__c__Gen_new_tmp_var(g);
	v__gen__c__Gen_write(g, _STR("string %.*s\000 = _SLIT(\"", 2, stmt_name));
	v__gen__c__Gen_write(g, v__gen__c__Gen_get_base_sql_select_query(g, node));
	v__gen__c__Gen_sql_expr_defaults(g, node, sql_typ);
	v__gen__c__Gen_writeln(g, _SLIT("\");"));
	v__gen__c__Gen_write(g, _STR("sqlite3_stmt* %.*s\000 = %.*s\000__DB_init_stmt(%.*s\000, %.*s\000);", 5, g->sql_stmt_name, _const_v__gen__c__dbtype, db_name, stmt_name));
	string binds = strings__Builder_str(&g->sql_buf);
	g->sql_buf = strings__new_builder(100);
	v__gen__c__Gen_writeln(g, binds);
	string binding_res = v__gen__c__Gen_new_tmp_var(g);
	v__gen__c__Gen_writeln(g, _STR("int %.*s\000 = sqlite3_extended_errcode(%.*s\000.conn);", 3, binding_res, db_name));
	v__gen__c__Gen_writeln(g, _STR("if (%.*s\000 != SQLITE_OK) { puts(sqlite3_errmsg(%.*s\000.conn)); }", 3, binding_res, db_name));
	if (node.is_count) {
		v__gen__c__Gen_writeln(g, _STR("%.*s\000 %.*s\000__get_int_from_stmt(%.*s\000);", 4, cur_line, _const_v__gen__c__dbtype, g->sql_stmt_name));
	} else {
		string tmp = v__gen__c__Gen_new_tmp_var(g);
		string styp = v__gen__c__Gen_typ(g, node.typ);
		string elem_type_str = _SLIT("");
		if (node.is_array) {
			v__ast__TypeSymbol* array_sym = v__ast__Table_get_type_symbol(g->table, node.typ);
			v__ast__Array array_info = /* as */ *(v__ast__Array*)__as_cast((array_sym->info)._v__ast__Array,(array_sym->info)._typ, 395) /*expected idx: 395, name: v.ast.Array */ ;
			elem_type_str = v__gen__c__Gen_typ(g, array_info.elem_type);
			v__gen__c__Gen_writeln(g, _STR("%.*s\000 %.*s\000_array = __new_array(0, 10, sizeof(%.*s\000));", 4, styp, tmp, elem_type_str));
			v__gen__c__Gen_writeln(g, _SLIT("while (1) {"));
			v__gen__c__Gen_writeln(g, _STR("\t%.*s\000 %.*s\000 = (%.*s\000) {", 4, elem_type_str, tmp, elem_type_str));
			v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, array_info.elem_type);
			v__ast__Struct info = /* as */ *(v__ast__Struct*)__as_cast((sym->info)._v__ast__Struct,(sym->info)._typ, 409) /*expected idx: 409, name: v.ast.Struct */ ;
			// FOR IN array
			for (int i = 0; i < info.fields.len; ++i) {
				v__ast__StructField field = ((v__ast__StructField*)info.fields.data)[i];
				v__gen__c__Gen_zero_struct_field(g, field);
				if (i != info.fields.len - 1) {
					v__gen__c__Gen_write(g, _SLIT(", "));
				}
			}
			v__gen__c__Gen_writeln(g, _SLIT("};"));
		} else {
			v__gen__c__Gen_writeln(g, _STR("%.*s\000 %.*s\000 = (%.*s\000){", 4, styp, tmp, styp));
			v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, node.typ);
			v__ast__Struct info = /* as */ *(v__ast__Struct*)__as_cast((sym->info)._v__ast__Struct,(sym->info)._typ, 409) /*expected idx: 409, name: v.ast.Struct */ ;
			// FOR IN array
			for (int i = 0; i < info.fields.len; ++i) {
				v__ast__StructField field = ((v__ast__StructField*)info.fields.data)[i];
				v__gen__c__Gen_zero_struct_field(g, field);
				if (i != info.fields.len - 1) {
					v__gen__c__Gen_write(g, _SLIT(", "));
				}
			}
			v__gen__c__Gen_writeln(g, _SLIT("};"));
		}
		v__gen__c__Gen_writeln(g, _STR("int _step_res%.*s\000 = sqlite3_step(%.*s\000);", 3, tmp, g->sql_stmt_name));
		if (node.is_array) {
			v__gen__c__Gen_writeln(g, _STR("\tif (_step_res%.*s\000 == SQLITE_DONE) break;", 2, tmp));
			v__gen__c__Gen_writeln(g, _STR("\tif (_step_res%.*s\000 == SQLITE_ROW) ;", 2, tmp));
			v__gen__c__Gen_writeln(g, _STR("\telse if (_step_res%.*s\000 != SQLITE_OK) break;", 2, tmp));
		} else {
			v__gen__c__Gen_writeln(g, _STR("\tif (_step_res%.*s\000 == SQLITE_OK || _step_res%.*s\000 == SQLITE_ROW) {", 3, tmp, tmp));
		}
		// FOR IN array
		for (int i = 0; i < node.fields.len; ++i) {
			v__ast__StructField field = ((v__ast__StructField*)node.fields.data)[i];
			string func = _SLIT("sqlite3_column_int");
			if (v__ast__Type_alias_eq(field.typ, _const_v__ast__string_type)) {
				func = _SLIT("sqlite3_column_text");
				string string_data = v__gen__c__Gen_new_tmp_var(g);
				v__gen__c__Gen_writeln(g, _STR("byteptr %.*s\000 = %.*s\000(%.*s\000, %"PRId32"\000);", 5, string_data, func, g->sql_stmt_name, i));
				v__gen__c__Gen_writeln(g, _STR("if (%.*s\000 != NULL) {", 2, string_data));
				v__gen__c__Gen_writeln(g, _STR("\t%.*s\000.%.*s\000 = tos_clone(%.*s\000);", 4, tmp, field.name, string_data));
				v__gen__c__Gen_writeln(g, _SLIT("}"));
			} else if ((*(v__ast__TypeSymbol*)/*ee elem_typ */array_get(g->table->type_symbols, ((int)(field.typ)))).kind == v__ast__Kind_struct_) {
				string id_name = v__gen__c__Gen_new_tmp_var(g);
				v__gen__c__Gen_writeln(g, _SLIT("//parse struct start"));
				v__gen__c__Gen_writeln(g, _STR("int %.*s\000 = %.*s\000(%.*s\000, %"PRId32"\000);", 5, id_name, func, g->sql_stmt_name, i));
				v__ast__SqlExpr expr = (*(v__ast__SqlExpr*)map_get(ADDR(map, node.sub_structs), &(int[]){((int)(field.typ))}, &(v__ast__SqlExpr[]){ (v__ast__SqlExpr){.fields = __new_array(0, 1, sizeof(v__ast__StructField)),.sub_structs = new_map(sizeof(int), sizeof(v__ast__SqlExpr), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),} }));
				v__ast__InfixExpr where_expr = /* as */ *(v__ast__InfixExpr*)__as_cast((expr.where_expr)._v__ast__InfixExpr,(expr.where_expr)._typ, 258) /*expected idx: 258, name: v.ast.InfixExpr */ ;
				v__ast__Ident ident = /* as */ *(v__ast__Ident*)__as_cast((where_expr.right)._v__ast__Ident,(where_expr.right)._typ, 254) /*expected idx: 254, name: v.ast.Ident */ ;
				ident.name = id_name;
				where_expr.right = v__ast__Ident_to_sumtype_v__ast__Expr(ADDR(v__ast__Ident, (ident)));
				expr.where_expr = v__ast__InfixExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__InfixExpr, (where_expr)));
				int tmp_sql_i = g->sql_i;
				string tmp_sql_stmt_name = g->sql_stmt_name;
				strings__Builder tmp_sql_buf = g->sql_buf;
				string tmp_sql_table_name = g->sql_table_name;
				v__gen__c__Gen_sql_select_expr(g, expr, true, _STR("\t%.*s\000.%.*s\000 =", 3, tmp, field.name));
				v__gen__c__Gen_writeln(g, _SLIT("//parse struct end"));
				g->sql_stmt_name = tmp_sql_stmt_name;
				g->sql_buf = tmp_sql_buf;
				g->sql_i = tmp_sql_i;
				g->sql_table_name = tmp_sql_table_name;
			} else {
				v__gen__c__Gen_writeln(g, _STR("%.*s\000.%.*s\000 = %.*s\000(%.*s\000, %"PRId32"\000);", 6, tmp, field.name, func, g->sql_stmt_name, i));
			}
		}
		if (node.is_array) {
			v__gen__c__Gen_writeln(g, _STR("\t array_push(&%.*s\000_array, _MOV((%.*s\000[]){ %.*s\000 }));", 4, tmp, elem_type_str, tmp));
		}
		v__gen__c__Gen_writeln(g, _SLIT("}"));
		v__gen__c__Gen_writeln(g, _STR("sqlite3_finalize(%.*s\000);", 2, g->sql_stmt_name));
		if (node.is_array) {
			v__gen__c__Gen_writeln(g, _STR("%.*s\000 %.*s\000_array; ", 3, cur_line, tmp));
		} else {
			v__gen__c__Gen_writeln(g, _STR("%.*s\000 %.*s\000; ", 3, cur_line, tmp));
		}
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_sqlite3_create_table(v__gen__c__Gen* g, v__ast__SqlStmt node, v__gen__c__SqlType typ) {
	v__gen__c__Gen_writeln(g, _SLIT("// sqlite3 table creator"));
	string create_string = v__gen__c__Gen_table_gen(g, node, typ);
	v__gen__c__Gen_write(g, _SLIT("sqlite__DB_exec("));
	v__gen__c__Gen_expr(g, node.db_expr);
	v__gen__c__Gen_writeln(g, _STR(", _SLIT(\"%.*s\000\"));", 2, create_string));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_sqlite3_bind(v__gen__c__Gen* g, string val, string len, v__ast__Type typ) {
	string _t3192 = v__gen__c__Gen_sqlite3_type_from_v(g, typ);
	
	if (string_eq(_t3192, _SLIT("INTEGER"))) {
		v__gen__c__Gen_sqlite3_bind_int(g, val);
	}
	else if (string_eq(_t3192, _SLIT("TEXT"))) {
		v__gen__c__Gen_sqlite3_bind_string(g, val, len);
	}
	else {
		v__gen__c__verror(_STR("bad sql type=%"PRId32"\000 ident_name=%.*s", 2, typ, val));
	};
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_sqlite3_bind_int(v__gen__c__Gen* g, string val) {
	strings__Builder_writeln(&g->sql_buf, _STR("sqlite3_bind_int(%.*s\000, %"PRId32"\000, %.*s\000);", 4, g->sql_stmt_name, g->sql_i, val));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_sqlite3_bind_string(v__gen__c__Gen* g, string val, string len) {
	strings__Builder_writeln(&g->sql_buf, _STR("sqlite3_bind_text(%.*s\000, %"PRId32"\000, %.*s\000, %.*s\000, 0);", 5, g->sql_stmt_name, g->sql_i, val, len));
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_sqlite3_type_from_v(v__gen__c__Gen* g, v__ast__Type v_typ) {
	if (v__ast__Type_is_number(v_typ) || v__ast__Type_alias_eq(v_typ, _const_v__ast__bool_type) || v_typ == -1) {
		 string _t3193 = _SLIT("INTEGER");
		// autofree_scope_vars(pos=9715 line_nr=326 scope.pos=9712 scope.end_pos=9734)
		// af parent scope:
		// var "g" var.pos=9597 var.line_nr=324
		// var "v_typ" var.pos=9624 var.line_nr=324
		// af parent scope:
		// af parent scope:
		return _t3193;
	}
	if (v__ast__Type_is_string(v_typ)) {
		 string _t3194 = _SLIT("TEXT");
		// autofree_scope_vars(pos=9761 line_nr=329 scope.pos=9758 scope.end_pos=9777)
		// af parent scope:
		// var "g" var.pos=9597 var.line_nr=324
		// var "v_typ" var.pos=9624 var.line_nr=324
		// af parent scope:
		// af parent scope:
		return _t3194;
	}
	 string _t3195 = _SLIT("");
	// autofree_scope_vars(pos=9779 line_nr=331 scope.pos=9592 scope.end_pos=9790)
	// var "g" var.pos=9597 var.line_nr=324
	// var "v_typ" var.pos=9624 var.line_nr=324
	// af parent scope:
	// af parent scope:
	return _t3195;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_mysql_stmt(v__gen__c__Gen* g, v__ast__SqlStmt node, v__gen__c__SqlType typ) {
	g->sql_i = 0;
	v__gen__c__Gen_writeln(g, _SLIT("\n\t//mysql insert"));
	string db_name = v__gen__c__Gen_new_tmp_var(g);
	g->sql_stmt_name = v__gen__c__Gen_new_tmp_var(g);
	v__gen__c__Gen_write(g, _STR("mysql__Connection %.*s\000 = ", 2, db_name));
	v__gen__c__Gen_expr(g, node.db_expr);
	v__gen__c__Gen_writeln(g, _SLIT(";"));
	string stmt_name = v__gen__c__Gen_new_tmp_var(g);
	v__gen__c__Gen_write(g, _STR("string %.*s\000 = _SLIT(\"", 2, stmt_name));
	v__gen__c__Gen_sql_defaults(g, node, typ);
	v__gen__c__Gen_writeln(g, _SLIT(";"));
	v__gen__c__Gen_writeln(g, _STR("MYSQL_STMT* %.*s\000 = mysql_stmt_init(%.*s\000.conn);", 3, g->sql_stmt_name, db_name));
	v__gen__c__Gen_writeln(g, _STR("mysql_stmt_prepare(%.*s\000, %.*s\000.str, %.*s\000.len);", 4, g->sql_stmt_name, stmt_name, stmt_name));
	string bind = v__gen__c__Gen_new_tmp_var(g);
	v__gen__c__Gen_writeln(g, _STR("MYSQL_BIND %.*s\000[%"PRId32"\000];", 3, bind, g->sql_i));
	v__gen__c__Gen_writeln(g, _STR("memset(%.*s\000, 0, sizeof(MYSQL_BIND)*%"PRId32"\000);", 3, bind, g->sql_i));
	if (node.kind == v__ast__SqlStmtKind_insert) {
		// FOR IN array
		for (int i = 0; i < node.fields.len; ++i) {
			v__ast__StructField field = ((v__ast__StructField*)node.fields.data)[i];
			if (string_eq(field.name, _SLIT("id"))) {
				continue;
			}
			v__gen__c__Gen_writeln(g, _STR("//%.*s\000 (%"PRId32"\000)", 3, field.name, field.typ));
			string x = _STR("%.*s\000.%.*s", 2, node.object_var_name, field.name);
			if ((*(v__ast__TypeSymbol*)/*ee elem_typ */array_get(g->table->type_symbols, ((int)(field.typ)))).kind == v__ast__Kind_struct_) {
				v__ast__SqlStmt expr = (*(v__ast__SqlStmt*)map_get(ADDR(map, node.sub_structs), &(int[]){((int)(field.typ))}, &(v__ast__SqlStmt[]){ (v__ast__SqlStmt){.updated_columns = __new_array(0, 1, sizeof(string)),.update_exprs = __new_array(0, 1, sizeof(v__ast__Expr)),.fields = __new_array(0, 1, sizeof(v__ast__StructField)),.sub_structs = new_map(sizeof(int), sizeof(v__ast__SqlStmt), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),} }));
				string tmp_sql_stmt_name = g->sql_stmt_name;
				string tmp_sql_table_name = g->sql_table_name;
				v__gen__c__Gen_sql_stmt(g, expr);
				g->sql_stmt_name = tmp_sql_stmt_name;
				g->sql_table_name = tmp_sql_table_name;
				string res = v__gen__c__Gen_new_tmp_var(g);
				v__gen__c__Gen_writeln(g, _STR("int %.*s\000_err = mysql_real_query(%.*s\000.conn, \"SELECT LAST_INSERT_ID();\", 24);", 3, res, db_name));
				v__gen__c__Gen_writeln(g, _STR("if (%.*s\000_err != 0) { puts(mysql_error(%.*s\000.conn)); }", 3, res, db_name));
				v__gen__c__Gen_writeln(g, _STR("MYSQL_RES* %.*s\000 = mysql_store_result(%.*s\000.conn);", 3, res, db_name));
				v__gen__c__Gen_writeln(g, _STR("if (mysql_num_rows(%.*s\000) != 1) { puts(\"Something went wrong\"); }", 2, res));
				v__gen__c__Gen_writeln(g, _STR("MYSQL_ROW %.*s\000_row = mysql_fetch_row(%.*s\000);", 3, res, res));
				v__gen__c__Gen_writeln(g, _STR("%.*s\000.id = string_int(tos_clone(%.*s\000_row[0]));", 3, x, res));
				v__gen__c__Gen_writeln(g, _STR("mysql_free_result(%.*s\000);", 2, res));
				v__gen__c__Gen_writeln(g, _STR("%.*s\000[%"PRId32"\000].buffer_type = MYSQL_TYPE_LONG;", 3, bind, i - 1));
				v__gen__c__Gen_writeln(g, _STR("%.*s\000[%"PRId32"\000].buffer = &%.*s\000.id;", 4, bind, i - 1, x));
				v__gen__c__Gen_writeln(g, _STR("%.*s\000[%"PRId32"\000].is_null = 0;", 3, bind, i - 1));
				v__gen__c__Gen_writeln(g, _STR("%.*s\000[%"PRId32"\000].length = 0;", 3, bind, i - 1));
			} else {
				multi_return_string_string mr_11729 = v__gen__c__Gen_mysql_buffer_typ_from_field(g, field);
				string t = mr_11729.arg0;
				string sym = mr_11729.arg1;
				v__gen__c__Gen_writeln(g, _STR("%.*s\000[%"PRId32"\000].buffer_type = %.*s\000;", 4, bind, i - 1, t));
				if (string_eq(sym, _SLIT("char"))) {
					v__gen__c__Gen_writeln(g, _STR("%.*s\000[%"PRId32"\000].buffer = (%.*s\000*) %.*s\000.str;", 5, bind, i - 1, sym, x));
				} else {
					v__gen__c__Gen_writeln(g, _STR("%.*s\000[%"PRId32"\000].buffer = (%.*s\000*) &%.*s\000;", 5, bind, i - 1, sym, x));
				}
				if (string_eq(sym, _SLIT("char"))) {
					v__gen__c__Gen_writeln(g, _STR("%.*s\000[%"PRId32"\000].buffer_length = %.*s\000.len;", 4, bind, i - 1, x));
				}
				v__gen__c__Gen_writeln(g, _STR("%.*s\000[%"PRId32"\000].is_null = 0;", 3, bind, i - 1));
				v__gen__c__Gen_writeln(g, _STR("%.*s\000[%"PRId32"\000].length = 0;", 3, bind, i - 1));
			}
		}
	}
	string binds = strings__Builder_str(&g->sql_buf);
	g->sql_buf = strings__new_builder(100);
	v__gen__c__Gen_writeln(g, binds);
	string res = v__gen__c__Gen_new_tmp_var(g);
	v__gen__c__Gen_writeln(g, _STR("int %.*s\000 = mysql_stmt_bind_param(%.*s\000, %.*s\000);", 4, res, g->sql_stmt_name, bind));
	v__gen__c__Gen_writeln(g, _STR("if (%.*s\000 != 0) { puts(mysql_error(%.*s\000.conn)); }", 3, res, db_name));
	v__gen__c__Gen_writeln(g, _STR("%.*s\000 = mysql_stmt_execute(%.*s\000);", 3, res, g->sql_stmt_name));
	v__gen__c__Gen_writeln(g, _STR("if (%.*s\000 != 0) { puts(mysql_error(%.*s\000.conn)); puts(mysql_stmt_error(%.*s\000)); }", 4, res, db_name, g->sql_stmt_name));
	v__gen__c__Gen_writeln(g, _STR("mysql_stmt_close(%.*s\000);", 2, g->sql_stmt_name));
	v__gen__c__Gen_writeln(g, _STR("mysql_stmt_free_result(%.*s\000);", 2, g->sql_stmt_name));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_mysql_select_expr(v__gen__c__Gen* g, v__ast__SqlExpr node, bool sub, string line, v__gen__c__SqlType typ) {
	g->sql_i = 0;
	string cur_line = line;
	if (!sub) {
		cur_line = v__gen__c__Gen_go_before_stmt(g, 0);
	}
	g->sql_stmt_name = v__gen__c__Gen_new_tmp_var(g);
	g->sql_bind_name = v__gen__c__Gen_new_tmp_var(g);
	string db_name = v__gen__c__Gen_new_tmp_var(g);
	v__gen__c__Gen_writeln(g, _SLIT("\n\t// sql select"));
	v__gen__c__Gen_write(g, _STR("mysql__Connection %.*s\000 = ", 2, db_name));
	v__gen__c__Gen_expr(g, node.db_expr);
	v__gen__c__Gen_writeln(g, _SLIT(";"));
	string stmt_name = v__gen__c__Gen_new_tmp_var(g);
	g->sql_idents = __new_array_with_default(0, 0, sizeof(string), 0);
	g->sql_idents_types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
	v__gen__c__Gen_write(g, _STR("char* %.*s\000_raw = \"", 2, stmt_name));
	v__gen__c__Gen_write(g, v__gen__c__Gen_get_base_sql_select_query(g, node));
	v__gen__c__Gen_sql_expr_defaults(g, node, typ);
	v__gen__c__Gen_writeln(g, _SLIT("\";"));
	v__gen__c__Gen_writeln(g, _STR("string %.*s\000 = tos_clone(%.*s\000_raw);", 3, stmt_name, stmt_name));
	if (g->sql_idents.len > 0) {
		string vals = v__gen__c__Gen_new_tmp_var(g);
		v__gen__c__Gen_writeln(g, _STR("Array_string %.*s\000 = __new_array_with_default(0, 0, sizeof(string), 0);", 2, vals));
		// FOR IN array
		for (int i = 0; i < g->sql_idents.len; ++i) {
			string ident = ((string*)g->sql_idents.data)[i];
			v__gen__c__Gen_writeln(g, _STR("array_push(&%.*s\000, _MOV((string[]){string_clone(_SLIT(\"%%%"PRId32"\000\"))}));", 3, vals, i + 1));
			v__gen__c__Gen_write(g, _STR("array_push(&%.*s\000, _MOV((string[]){string_clone(", 2, vals));
			if (v__ast__Type_alias_eq((*(v__ast__Type*)/*ee elem_typ */array_get(g->sql_idents_types, i)), _const_v__ast__string_type)) {
				v__gen__c__Gen_write(g, _SLIT("_SLIT("));
			} else {
				string sym = v__ast__Table_get_type_name(g->table, (*(v__ast__Type*)/*ee elem_typ */array_get(g->sql_idents_types, i)));
				v__gen__c__Gen_write(g, _STR("%.*s\000_str(", 2, sym));
			}
			v__gen__c__Gen_writeln(g, _STR("%.*s\000))}));", 2, ident));
		}
		v__gen__c__Gen_writeln(g, _STR("%.*s\000 = string_replace_each(%.*s\000, %.*s\000);", 4, stmt_name, stmt_name, vals));
	}
	string query = v__gen__c__Gen_new_tmp_var(g);
	string res = v__gen__c__Gen_new_tmp_var(g);
	string fields = v__gen__c__Gen_new_tmp_var(g);
	v__gen__c__Gen_writeln(g, _STR("int %.*s\000 = mysql_real_query(%.*s\000.conn, %.*s\000.str, %.*s\000.len);", 5, query, db_name, stmt_name, stmt_name));
	v__gen__c__Gen_writeln(g, _STR("if (%.*s\000 != 0) { puts(mysql_error(%.*s\000.conn)); }", 3, query, db_name));
	v__gen__c__Gen_writeln(g, _STR("MYSQL_RES* %.*s\000 = mysql_store_result(%.*s\000.conn);", 3, res, db_name));
	v__gen__c__Gen_writeln(g, _STR("MYSQL_ROW %.*s\000 = mysql_fetch_row(%.*s\000);", 3, fields, res));
	if (node.is_count) {
		v__gen__c__Gen_writeln(g, _STR("%.*s\000 string_int(tos_clone(%.*s\000[0]));", 3, cur_line, fields));
	} else {
		string tmp = v__gen__c__Gen_new_tmp_var(g);
		string styp = v__gen__c__Gen_typ(g, node.typ);
		string tmp_i = v__gen__c__Gen_new_tmp_var(g);
		string elem_type_str = _SLIT("");
		v__gen__c__Gen_writeln(g, _STR("int %.*s\000 = 0;", 2, tmp_i));
		if (node.is_array) {
			v__ast__TypeSymbol* array_sym = v__ast__Table_get_type_symbol(g->table, node.typ);
			v__ast__Array array_info = /* as */ *(v__ast__Array*)__as_cast((array_sym->info)._v__ast__Array,(array_sym->info)._typ, 395) /*expected idx: 395, name: v.ast.Array */ ;
			elem_type_str = v__gen__c__Gen_typ(g, array_info.elem_type);
			v__gen__c__Gen_writeln(g, _STR("%.*s\000 %.*s\000_array = __new_array(0, 10, sizeof(%.*s\000));", 4, styp, tmp, elem_type_str));
			v__gen__c__Gen_writeln(g, _STR("for (%.*s\000 = 0; %.*s\000 < mysql_num_rows(%.*s\000); %.*s\000++) {", 5, tmp_i, tmp_i, res, tmp_i));
			v__gen__c__Gen_writeln(g, _STR("\t%.*s\000 %.*s\000 = (%.*s\000) {", 4, elem_type_str, tmp, elem_type_str));
			v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, array_info.elem_type);
			v__ast__Struct info = /* as */ *(v__ast__Struct*)__as_cast((sym->info)._v__ast__Struct,(sym->info)._typ, 409) /*expected idx: 409, name: v.ast.Struct */ ;
			// FOR IN array
			for (int i = 0; i < info.fields.len; ++i) {
				v__ast__StructField field = ((v__ast__StructField*)info.fields.data)[i];
				v__gen__c__Gen_zero_struct_field(g, field);
				if (i != info.fields.len - 1) {
					v__gen__c__Gen_write(g, _SLIT(", "));
				}
			}
			v__gen__c__Gen_writeln(g, _SLIT("};"));
		} else {
			v__gen__c__Gen_writeln(g, _STR("%.*s\000 %.*s\000 = (%.*s\000){", 4, styp, tmp, styp));
			v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, node.typ);
			v__ast__Struct info = /* as */ *(v__ast__Struct*)__as_cast((sym->info)._v__ast__Struct,(sym->info)._typ, 409) /*expected idx: 409, name: v.ast.Struct */ ;
			// FOR IN array
			for (int i = 0; i < info.fields.len; ++i) {
				v__ast__StructField field = ((v__ast__StructField*)info.fields.data)[i];
				v__gen__c__Gen_zero_struct_field(g, field);
				if (i != info.fields.len - 1) {
					v__gen__c__Gen_write(g, _SLIT(", "));
				}
			}
			v__gen__c__Gen_writeln(g, _SLIT("};"));
		}
		string char_ptr = v__gen__c__Gen_new_tmp_var(g);
		v__gen__c__Gen_writeln(g, _STR("char* %.*s\000 = \"\";", 2, char_ptr));
		// FOR IN array
		for (int i = 0; i < node.fields.len; ++i) {
			v__ast__StructField field = ((v__ast__StructField*)node.fields.data)[i];
			v__gen__c__Gen_writeln(g, _STR("%.*s\000 = %.*s\000[%"PRId32"\000];", 4, char_ptr, fields, i));
			v__gen__c__Gen_writeln(g, _STR("if (%.*s\000 == NULL) { %.*s\000 = \"\"; }", 3, char_ptr, char_ptr));
			string name = v__ast__Table_get_type_symbol(g->table, field.typ)->cname;
			if (v__ast__Table_get_type_symbol(g->table, field.typ)->kind == v__ast__Kind_struct_) {
			} else if (v__ast__Type_alias_eq(field.typ, _const_v__ast__string_type)) {
				v__gen__c__Gen_writeln(g, _STR("%.*s\000.%.*s\000 = tos_clone(%.*s\000);", 4, tmp, field.name, char_ptr));
			} else if (v__ast__Type_alias_eq(field.typ, _const_v__ast__byte_type)) {
				v__gen__c__Gen_writeln(g, _STR("%.*s\000.%.*s\000 = (byte) string_%.*s\000(tos_clone(%.*s\000));", 5, tmp, field.name, name, char_ptr));
			} else if (v__ast__Type_alias_eq(field.typ, _const_v__ast__i8_type)) {
				v__gen__c__Gen_writeln(g, _STR("%.*s\000.%.*s\000 = (i8) string_%.*s\000(tos_clone(%.*s\000));", 5, tmp, field.name, name, char_ptr));
			} else {
				v__gen__c__Gen_writeln(g, _STR("%.*s\000.%.*s\000 = string_%.*s\000(tos_clone(%.*s\000));", 5, tmp, field.name, name, char_ptr));
			}
		}
		if (node.is_array) {
			v__gen__c__Gen_writeln(g, _STR("\t array_push(&%.*s\000_array, _MOV((%.*s\000[]) { %.*s\000 }));", 4, tmp, elem_type_str, tmp));
			v__gen__c__Gen_writeln(g, _SLIT("}"));
		}
		v__gen__c__Gen_writeln(g, _STR("string_free(&%.*s\000);", 2, stmt_name));
		v__gen__c__Gen_writeln(g, _STR("mysql_free_result(%.*s\000);", 2, res));
		if (node.is_array) {
			v__gen__c__Gen_writeln(g, _STR("%.*s\000 %.*s\000_array; ", 3, cur_line, tmp));
		} else {
			v__gen__c__Gen_writeln(g, _STR("%.*s\000 %.*s\000; ", 3, cur_line, tmp));
		}
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_mysql_create_table(v__gen__c__Gen* g, v__ast__SqlStmt node, v__gen__c__SqlType typ) {
	v__gen__c__Gen_writeln(g, _SLIT("// mysql table creator"));
	string create_string = v__gen__c__Gen_table_gen(g, node, typ);
	string tmp = v__gen__c__Gen_new_tmp_var(g);
	v__gen__c__Gen_write(g, _STR("Option_mysql__Result %.*s\000 = mysql__Connection_query(&", 2, tmp));
	v__gen__c__Gen_expr(g, node.db_expr);
	v__gen__c__Gen_writeln(g, _STR(", _SLIT(\"%.*s\000\"));", 2, create_string));
	v__gen__c__Gen_writeln(g, _STR("if (%.*s\000.state != 0) { IError err = %.*s\000.err; _STR(\"Something went wrong\\000%%.*s\", 2, IError_str(err)); }", 3, tmp, tmp));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_mysql_bind(v__gen__c__Gen* g, string val, v__ast__Type _t3196) {
	v__gen__c__Gen_write(g, val);
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_mysql_get_table_type(v__gen__c__Gen* g, v__ast__Type typ) {
	string table_typ = _SLIT("");

	if (typ == (_const_v__ast__i8_type) || typ == (_const_v__ast__byte_type) || typ == (_const_v__ast__bool_type)) {
		table_typ = _SLIT("TINYINT");
	}
	else if (typ == (_const_v__ast__i16_type) || typ == (_const_v__ast__u16_type)) {
		table_typ = _SLIT("SMALLINT");
	}
	else if (typ == (_const_v__ast__int_type) || typ == (_const_v__ast__u32_type)) {
		table_typ = _SLIT("INT");
	}
	else if (typ == (_const_v__ast__i64_type) || typ == (_const_v__ast__u64_type)) {
		table_typ = _SLIT("BIGINT");
	}
	else if (typ == (_const_v__ast__f32_type)) {
		table_typ = _SLIT("BIGINT");
	}
	else if (typ == (_const_v__ast__f64_type)) {
		table_typ = _SLIT("BIGINT");
	}
	else if (typ == (_const_v__ast__string_type)) {
		table_typ = _SLIT("TEXT");
	}
	else if (typ == (-1)) {
		table_typ = _SLIT("SERIAL");
	}
	else {
	};
	// autofree_scope_vars(pos=20236 line_nr=635 scope.pos=19711 scope.end_pos=20254)
	// var "g" var.pos=19716 var.line_nr=606
	// var "typ" var.pos=19744 var.line_nr=606
	// var "table_typ" var.pos=19772 var.line_nr=607
	// str literal
	// af parent scope:
	// af parent scope:
	return table_typ;
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_mysql_buffer_typ_from_typ(v__gen__c__Gen* g, v__ast__Type typ) {
	string buf_typ = _SLIT("");

	if (typ == (_const_v__ast__i8_type) || typ == (_const_v__ast__byte_type) || typ == (_const_v__ast__bool_type)) {
		buf_typ = _SLIT("MYSQL_TYPE_TINY");
	}
	else if (typ == (_const_v__ast__i16_type) || typ == (_const_v__ast__u16_type)) {
		buf_typ = _SLIT("MYSQL_TYPE_SHORT");
	}
	else if (typ == (_const_v__ast__int_type) || typ == (_const_v__ast__u32_type)) {
		buf_typ = _SLIT("MYSQL_TYPE_LONG");
	}
	else if (typ == (_const_v__ast__i64_type) || typ == (_const_v__ast__u64_type)) {
		buf_typ = _SLIT("MYSQL_TYPE_LONGLONG");
	}
	else if (typ == (_const_v__ast__f32_type)) {
		buf_typ = _SLIT("MYSQL_TYPE_FLOAT");
	}
	else if (typ == (_const_v__ast__f64_type)) {
		buf_typ = _SLIT("MYSQL_TYPE_DOUBLE");
	}
	else if (typ == (_const_v__ast__string_type)) {
		buf_typ = _SLIT("MYSQL_TYPE_STRING");
	}
	else {
		buf_typ = _SLIT("MYSQL_TYPE_NULL");
	};
	// autofree_scope_vars(pos=20848 line_nr=666 scope.pos=20260 scope.end_pos=20864)
	// var "g" var.pos=20265 var.line_nr=638
	// var "typ" var.pos=20298 var.line_nr=638
	// var "buf_typ" var.pos=20326 var.line_nr=639
	// str literal
	// af parent scope:
	// af parent scope:
	return buf_typ;
}

VV_LOCAL_SYMBOL multi_return_string_string v__gen__c__Gen_mysql_buffer_typ_from_field(v__gen__c__Gen* g, v__ast__StructField field) {
	v__ast__Type typ = v__gen__c__Gen_get_sql_field_type(g, field);
	string sym = v__ast__Table_get_type_symbol(g->table, typ)->cname;
	string buf_typ = v__gen__c__Gen_mysql_buffer_typ_from_typ(g, typ);
	if (v__ast__Type_alias_eq(typ, _const_v__ast__string_type)) {
		sym = _SLIT("char");
	}
	return (multi_return_string_string){.arg0=buf_typ, .arg1=sym};
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_sql_expr_defaults(v__gen__c__Gen* g, v__ast__SqlExpr node, v__gen__c__SqlType sql_typ) {
	if (node.has_where && (node.where_expr)._typ == 258 /* v.ast.InfixExpr */) {
		v__gen__c__Gen_expr_to_sql(g, node.where_expr, sql_typ);
	}
	if (node.has_order) {
		v__gen__c__Gen_write(g, _SLIT(" ORDER BY "));
		g->sql_side = v__gen__c__SqlExprSide_left;
		v__gen__c__Gen_expr_to_sql(g, node.order_expr, sql_typ);
		if (node.has_desc) {
			v__gen__c__Gen_write(g, _SLIT(" DESC "));
		}
	} else {
		v__gen__c__Gen_write(g, _SLIT(" ORDER BY id "));
	}
	if (node.has_limit) {
		v__gen__c__Gen_write(g, _SLIT(" LIMIT "));
		g->sql_side = v__gen__c__SqlExprSide_right;
		v__gen__c__Gen_expr_to_sql(g, node.limit_expr, sql_typ);
	}
	if (node.has_offset) {
		v__gen__c__Gen_write(g, _SLIT(" OFFSET "));
		g->sql_side = v__gen__c__SqlExprSide_right;
		v__gen__c__Gen_expr_to_sql(g, node.offset_expr, sql_typ);
	}
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_get_base_sql_select_query(v__gen__c__Gen* g, v__ast__SqlExpr node) {
	string sql_query = _SLIT("SELECT ");
	string table_name = v__util__strip_mod_name(v__ast__Table_get_type_symbol(g->table, node.table_expr.typ)->name);
	if (node.is_count) {
		sql_query = /*f*/string_add(sql_query, _STR("COUNT(*) FROM `%.*s\000` ", 2, table_name));
	} else {
		// FOR IN array
		for (int i = 0; i < node.fields.len; ++i) {
			v__ast__StructField field = ((v__ast__StructField*)node.fields.data)[i];
			sql_query = /*f*/string_add(sql_query, _STR("`%.*s\000`", 2, field.name));
			if (i < node.fields.len - 1) {
				sql_query = /*f*/string_add(sql_query, _SLIT(", "));
			}
		}
		sql_query = /*f*/string_add(sql_query, _STR(" FROM `%.*s\000`", 2, table_name));
	}
	if (node.has_where) {
		sql_query = /*f*/string_add(sql_query, _SLIT(" WHERE "));
	}
	// autofree_scope_vars(pos=22306 line_nr=728 scope.pos=21760 scope.end_pos=22324)
	// var "g" var.pos=21765 var.line_nr=709
	// var "node" var.pos=21798 var.line_nr=709
	// var "sql_query" var.pos=21830 var.line_nr=710
	// str literal
	// var "table_name" var.pos=21854 var.line_nr=711
	// af parent scope:
	// af parent scope:
	return sql_query;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_sql_defaults(v__gen__c__Gen* g, v__ast__SqlStmt node, v__gen__c__SqlType typ) {
	string table_name = v__util__strip_mod_name(v__ast__Table_get_type_symbol(g->table, node.table_expr.typ)->name);
	if (node.kind == v__ast__SqlStmtKind_insert) {
		v__gen__c__Gen_write(g, _STR("INSERT INTO `%.*s\000` (", 2, table_name));
	} else if (node.kind == v__ast__SqlStmtKind_update) {
		v__gen__c__Gen_write(g, _STR("UPDATE `%.*s\000` SET ", 2, table_name));
	} else if (node.kind == v__ast__SqlStmtKind_delete) {
		v__gen__c__Gen_write(g, _STR("DELETE FROM `%.*s\000` ", 2, table_name));
	}
	if (node.kind == v__ast__SqlStmtKind_insert) {
		// FOR IN array
		for (int i = 0; i < node.fields.len; ++i) {
			v__ast__StructField field = ((v__ast__StructField*)node.fields.data)[i];
			if (string_eq(field.name, _SLIT("id"))) {
				continue;
			}
			v__gen__c__Gen_write(g, _STR("`%.*s\000`", 2, field.name));
			if (i < node.fields.len - 1) {
				v__gen__c__Gen_write(g, _SLIT(", "));
			}
		}
		v__gen__c__Gen_write(g, _SLIT(") values ("));
		// FOR IN array
		for (int i = 0; i < node.fields.len; ++i) {
			v__ast__StructField field = ((v__ast__StructField*)node.fields.data)[i];
			if (string_eq(field.name, _SLIT("id"))) {
				continue;
			}
			if (typ == v__gen__c__SqlType_sqlite3) {
				v__gen__c__Gen_write(g, _STR("?%"PRId32"", 1, i + 0));
			} else if (typ == v__gen__c__SqlType_mysql) {
				v__gen__c__Gen_write(g, _SLIT("?"));
			}
			if (i < node.fields.len - 1) {
				v__gen__c__Gen_write(g, _SLIT(", "));
			}
			g->sql_i++;
		}
		v__gen__c__Gen_write(g, _SLIT(")"));
	} else if (node.kind == v__ast__SqlStmtKind_update) {
		// FOR IN array
		for (int i = 0; i < node.updated_columns.len; ++i) {
			string col = ((string*)node.updated_columns.data)[i];
			v__gen__c__Gen_write(g, _STR(" %.*s\000 = ", 2, col));
			v__gen__c__Gen_expr_to_sql(g, (*(v__ast__Expr*)/*ee elem_typ */array_get(node.update_exprs, i)), typ);
			if (i < node.updated_columns.len - 1) {
				v__gen__c__Gen_write(g, _SLIT(", "));
			}
		}
		v__gen__c__Gen_write(g, _SLIT(" WHERE "));
	} else if (node.kind == v__ast__SqlStmtKind_delete) {
		v__gen__c__Gen_write(g, _SLIT(" WHERE "));
	}
	if (node.kind == v__ast__SqlStmtKind_update || node.kind == v__ast__SqlStmtKind_delete) {
		v__gen__c__Gen_expr_to_sql(g, node.where_expr, typ);
	}
	v__gen__c__Gen_write(g, _SLIT("\")"));
}

VV_LOCAL_SYMBOL string v__gen__c__Gen_table_gen(v__gen__c__Gen* g, v__ast__SqlStmt node, v__gen__c__SqlType typ) {
	v__ast__TypeSymbol* typ_sym = v__ast__Table_get_type_symbol(g->table, node.table_expr.typ);
	if ((typ_sym->info)._typ != 409 /* v.ast.Struct */) {
		v__gen__c__verror(_STR("Type `%.*s\000` has to be a struct", 2, typ_sym->name));
	}
	v__ast__Struct struct_data = /* as */ *(v__ast__Struct*)__as_cast((typ_sym->info)._v__ast__Struct,(typ_sym->info)._typ, 409) /*expected idx: 409, name: v.ast.Struct */ ;
	string table_name = (*(string*)array_last(string_split(typ_sym->name, _SLIT("."))));
	string create_string = _STR("CREATE TABLE IF NOT EXISTS `%.*s\000` (", 2, table_name);
	Array_string fields = __new_array_with_default(0, 0, sizeof(string), 0);
	string primary = _SLIT("");
	// FOR IN array
	for (int _t3197 = 0; _t3197 < struct_data.fields.len; ++_t3197) {
		v__ast__StructField field = ((v__ast__StructField*)struct_data.fields.data)[_t3197];
		bool is_primary = false;
		bool no_null = false;
		// FOR IN array
		for (int _t3198 = 0; _t3198 < field.attrs.len; ++_t3198) {
			v__ast__Attr attr = ((v__ast__Attr*)field.attrs.data)[_t3198];

			if (string_eq(attr.name, _SLIT("primary"))) {
				is_primary = true;
				primary = field.name;
			}
			else if (string_eq(attr.name, _SLIT("nonull"))) {
				no_null = true;
			}
			else {
			};
		}
		string stmt = _SLIT("");
		string converted_typ = v__gen__c__Gen_sql_type_from_v(g, typ, v__gen__c__Gen_get_sql_field_type(g, field));
		string name = field.name;
		if ((converted_typ).len == 0) {
			if (v__ast__Table_get_type_symbol(g->table, field.typ)->kind == v__ast__Kind_struct_) {
				converted_typ = v__gen__c__Gen_sql_type_from_v(g, typ, _const_v__ast__int_type);
				v__gen__c__Gen_sql_create_table(g, (v__ast__SqlStmt){.kind = node.kind,.db_expr = node.db_expr,.object_var_name = (string){.str=(byteptr)"", .is_lit=1},.pos = node.pos,.where_expr = {0},.updated_columns = __new_array(0, 1, sizeof(string)),.update_exprs = __new_array(0, 1, sizeof(v__ast__Expr)),.table_expr = (v__ast__TypeNode){.typ = field.typ,.pos = node.table_expr.pos,},.fields = __new_array(0, 1, sizeof(v__ast__StructField)),.sub_structs = new_map(sizeof(int), sizeof(v__ast__SqlStmt), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),});
			} else {
				eprintln(v__ast__Kind_str(v__ast__Table_get_type_symbol(g->table, field.typ)->kind));
				v__gen__c__verror(_STR("unknown type (%"PRId32"\000)", 2, field.typ));
				continue;
			}
		}
		stmt = _STR("`%.*s\000` %.*s", 2, name, converted_typ);
		if (field.has_default_expr && typ != v__gen__c__SqlType_mysql) {
			stmt = /*f*/string_add(stmt, _SLIT(" DEFAULT "));
			stmt = /*f*/string_add(stmt, v__ast__Expr_str(field.default_expr));
		}
		if (no_null) {
			stmt = /*f*/string_add(stmt, _SLIT(" NOT NULL"));
		}
		if (is_primary && typ == v__gen__c__SqlType_sqlite3) {
			stmt = /*f*/string_add(stmt, _SLIT(" PRIMARY KEY"));
		}
		array_push(&fields, _MOV((string[]){ string_clone(stmt) }));
	}
	if (typ == v__gen__c__SqlType_mysql) {
		array_push(&fields, _MOV((string[]){ string_clone(_STR("PRIMARY KEY(`%.*s\000`)", 2, primary)) }));
	}
	create_string = /*f*/string_add(create_string, Array_string_join(fields, _SLIT(", ")));
	create_string = /*f*/string_add(create_string, _SLIT(");"));
	// autofree_scope_vars(pos=25245 line_nr=852 scope.pos=23571 scope.end_pos=25267)
	// var "g" var.pos=23576 var.line_nr=784
	// var "node" var.pos=23593 var.line_nr=784
	// var "typ" var.pos=23611 var.line_nr=784
	// var "typ_sym" var.pos=23634 var.line_nr=785
	// var "struct_data" var.pos=23780 var.line_nr=789
	// var "table_name" var.pos=23823 var.line_nr=790
	// var "create_string" var.pos=23873 var.line_nr=791
	// var "fields" var.pos=23941 var.line_nr=793
	// var "primary" var.pos=23968 var.line_nr=795
	// str literal
	// af parent scope:
	// af parent scope:
	return create_string;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_expr_to_sql(v__gen__c__Gen* g, v__ast__Expr expr, v__gen__c__SqlType typ) {
	if (expr._typ == 258 /* v.ast.InfixExpr */) {
		g->sql_side = v__gen__c__SqlExprSide_left;
		v__gen__c__Gen_expr_to_sql(g, (*expr._v__ast__InfixExpr).left, typ);

		if ((*expr._v__ast__InfixExpr).op == (v__token__Kind_ne)) {
			v__gen__c__Gen_write(g, _SLIT(" != "));
		}
		else if ((*expr._v__ast__InfixExpr).op == (v__token__Kind_eq)) {
			v__gen__c__Gen_write(g, _SLIT(" = "));
		}
		else if ((*expr._v__ast__InfixExpr).op == (v__token__Kind_gt)) {
			v__gen__c__Gen_write(g, _SLIT(" > "));
		}
		else if ((*expr._v__ast__InfixExpr).op == (v__token__Kind_lt)) {
			v__gen__c__Gen_write(g, _SLIT(" < "));
		}
		else if ((*expr._v__ast__InfixExpr).op == (v__token__Kind_ge)) {
			v__gen__c__Gen_write(g, _SLIT(" >= "));
		}
		else if ((*expr._v__ast__InfixExpr).op == (v__token__Kind_le)) {
			v__gen__c__Gen_write(g, _SLIT(" <= "));
		}
		else if ((*expr._v__ast__InfixExpr).op == (v__token__Kind_and)) {
			v__gen__c__Gen_write(g, _SLIT(" and "));
		}
		else if ((*expr._v__ast__InfixExpr).op == (v__token__Kind_logical_or)) {
			v__gen__c__Gen_write(g, _SLIT(" or "));
		}
		else if ((*expr._v__ast__InfixExpr).op == (v__token__Kind_plus)) {
			v__gen__c__Gen_write(g, _SLIT(" + "));
		}
		else if ((*expr._v__ast__InfixExpr).op == (v__token__Kind_minus)) {
			v__gen__c__Gen_write(g, _SLIT(" - "));
		}
		else if ((*expr._v__ast__InfixExpr).op == (v__token__Kind_mul)) {
			v__gen__c__Gen_write(g, _SLIT(" * "));
		}
		else if ((*expr._v__ast__InfixExpr).op == (v__token__Kind_div)) {
			v__gen__c__Gen_write(g, _SLIT(" / "));
		}
		else {
		};
		g->sql_side = v__gen__c__SqlExprSide_right;
		v__gen__c__Gen_expr_to_sql(g, (*expr._v__ast__InfixExpr).right, typ);
	}
	else if (expr._typ == 277 /* v.ast.StringLiteral */) {
		v__gen__c__Gen_inc_sql_i(g, typ);
		v__gen__c__Gen_sql_bind(g, _STR("\"%.*s\000\"", 2, (*expr._v__ast__StringLiteral).val), int_str((*expr._v__ast__StringLiteral).val.len), v__gen__c__Gen_sql_get_real_type(g, _const_v__ast__string_type), typ);
	}
	else if (expr._typ == 259 /* v.ast.IntegerLiteral */) {
		v__gen__c__Gen_inc_sql_i(g, typ);
		v__gen__c__Gen_sql_bind(g, (*expr._v__ast__IntegerLiteral).val, _SLIT(""), v__gen__c__Gen_sql_get_real_type(g, _const_v__ast__int_type), typ);
	}
	else if (expr._typ == 239 /* v.ast.BoolLiteral */) {
		v__gen__c__Gen_inc_sql_i(g, typ);
		string eval = ((*expr._v__ast__BoolLiteral).val ? (_SLIT("1")) : (_SLIT("0")));
		v__gen__c__Gen_sql_bind(g, eval, _SLIT(""), v__gen__c__Gen_sql_get_real_type(g, _const_v__ast__byte_type), typ);
	}
	else if (expr._typ == 254 /* v.ast.Ident */) {
		if (g->sql_side == v__gen__c__SqlExprSide_left) {
			eprintln((*expr._v__ast__Ident).name);
			g->sql_left_type = v__gen__c__Gen_get_struct_field_typ(g, (*expr._v__ast__Ident).name);
			v__gen__c__Gen_write(g, (*expr._v__ast__Ident).name);
		} else {
			v__gen__c__Gen_inc_sql_i(g, typ);
			v__ast__IdentVar info = /* as */ *(v__ast__IdentVar*)__as_cast(((*expr._v__ast__Ident).info)._v__ast__IdentVar,((*expr._v__ast__Ident).info)._typ, 363) /*expected idx: 363, name: v.ast.IdentVar */ ;
			v__ast__Type ityp = info.typ;
			if (typ == v__gen__c__SqlType_sqlite3) {
				if (v__ast__Type_alias_eq(ityp, _const_v__ast__string_type)) {
					v__gen__c__Gen_sql_bind(g, _STR("%.*s\000.str", 2, (*expr._v__ast__Ident).name), _STR("%.*s\000.len", 2, (*expr._v__ast__Ident).name), v__gen__c__Gen_sql_get_real_type(g, ityp), typ);
				} else {
					v__gen__c__Gen_sql_bind(g, (*expr._v__ast__Ident).name, _SLIT(""), v__gen__c__Gen_sql_get_real_type(g, ityp), typ);
				}
			} else {
				v__gen__c__Gen_sql_bind(g, _STR("%%%.*s", 1, int_str(g->sql_i)), _SLIT(""), v__gen__c__Gen_sql_get_real_type(g, ityp), typ);
				array_push(&g->sql_idents, _MOV((string[]){ string_clone((*expr._v__ast__Ident).name) }));
				array_push(&g->sql_idents_types, _MOV((v__ast__Type[]){ v__gen__c__Gen_sql_get_real_type(g, ityp) }));
			}
		}
	}
	else if (expr._typ == 273 /* v.ast.SelectorExpr */) {
		v__gen__c__Gen_inc_sql_i(g, typ);
		if (((*expr._v__ast__SelectorExpr).expr)._typ != 254 /* v.ast.Ident */) {
			v__gen__c__verror(_SLIT("orm selector not ident"));
		}
		v__ast__Ident ident = /* as */ *(v__ast__Ident*)__as_cast(((*expr._v__ast__SelectorExpr).expr)._v__ast__Ident,((*expr._v__ast__SelectorExpr).expr)._typ, 254) /*expected idx: 254, name: v.ast.Ident */ ;
		v__gen__c__Gen_sql_bind(g, string_add(string_add(ident.name, _SLIT(".")), (*expr._v__ast__SelectorExpr).field_name), _SLIT(""), v__gen__c__Gen_sql_get_real_type(g, (*expr._v__ast__SelectorExpr).typ), typ);
	}
	else {
		v__gen__c__Gen_expr(g, expr);
	};
}

VV_LOCAL_SYMBOL v__ast__Type v__gen__c__Gen_get_struct_field_typ(v__gen__c__Gen* g, string f) {
	v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, (*(int*)map_get(ADDR(map, g->table->type_idxs), &(string[]){g->sql_table_name}, &(int[]){ 0 })));
	v__ast__Type typ = ((v__ast__Type)(-1));
	if (sym->kind != v__ast__Kind_struct_) {
		v__ast__Struct str = /* as */ *(v__ast__Struct*)__as_cast((sym->info)._v__ast__Struct,(sym->info)._typ, 409) /*expected idx: 409, name: v.ast.Struct */ ;
		// FOR IN array
		for (int _t3203 = 0; _t3203 < str.fields.len; ++_t3203) {
			v__ast__StructField field = ((v__ast__StructField*)str.fields.data)[_t3203];
			if (string_ne(field.name, f)) {
				continue;
			}
			typ = v__gen__c__Gen_get_sql_field_type(g, field);
			break;
		}
	}
	// autofree_scope_vars(pos=28269 line_nr=963 scope.pos=27936 scope.end_pos=28281)
	// var "g" var.pos=27941 var.line_nr=947
	// var "f" var.pos=27969 var.line_nr=947
	// var "sym" var.pos=27991 var.line_nr=948
	// var "typ" var.pos=28065 var.line_nr=950
	// af parent scope:
	// af parent scope:
	return typ;
}

VV_LOCAL_SYMBOL v__ast__Type v__gen__c__Gen_sql_get_real_type(v__gen__c__Gen* g, v__ast__Type typ) {
	if (!v__ast__Type_alias_eq(typ, g->sql_left_type) && g->sql_left_type >= 0) {
		 v__ast__Type _t3204 = g->sql_left_type;
		// autofree_scope_vars(pos=28396 line_nr=968 scope.pos=28393 scope.end_pos=28421)
		// af parent scope:
		// var "g" var.pos=28292 var.line_nr=966
		// var "typ" var.pos=28317 var.line_nr=966
		// af parent scope:
		// af parent scope:
		return _t3204;
	}
	// autofree_scope_vars(pos=28423 line_nr=970 scope.pos=28287 scope.end_pos=28435)
	// var "g" var.pos=28292 var.line_nr=966
	// var "typ" var.pos=28317 var.line_nr=966
	// af parent scope:
	// af parent scope:
	return typ;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_inc_sql_i(v__gen__c__Gen* g, v__gen__c__SqlType typ) {
	g->sql_i++;
	if (typ == v__gen__c__SqlType_sqlite3) {
		v__gen__c__Gen_write(g, _SLIT("?"));
		v__gen__c__Gen_write(g, _STR("%"PRId32"", 1, g->sql_i));
	}
}

VV_LOCAL_SYMBOL v__gen__c__SqlType v__gen__c__Gen_parse_db_type(v__gen__c__Gen* g, v__ast__Expr expr) {
	if (expr._typ == 254 /* v.ast.Ident */) {
		if (((*expr._v__ast__Ident).info)._typ == 363 /* v.ast.IdentVar */) {
			 v__gen__c__SqlType _t3205 = v__gen__c__Gen_parse_db_from_type_string(g, v__ast__Table_get_type_name(g->table, (*(*expr._v__ast__Ident).info._v__ast__IdentVar).typ));
			// autofree_scope_vars(pos=28673 line_nr=985 scope.pos=28668 scope.end_pos=28750)
			// af parent scope:
			// var "expr" var.pos=28615 var.line_nr=982
			// af parent scope:
			// var "g" var.pos=28562 var.line_nr=981
			// var "expr" var.pos=28583 var.line_nr=981
			// af parent scope:
			// af parent scope:
			return _t3205;
		}
	}
	else if (expr._typ == 273 /* v.ast.SelectorExpr */) {
		 v__gen__c__SqlType _t3206 = v__gen__c__Gen_parse_db_from_type_string(g, v__ast__Table_get_type_name(g->table, (*expr._v__ast__SelectorExpr).typ));
		// autofree_scope_vars(pos=28779 line_nr=989 scope.pos=28758 scope.end_pos=28850)
		// var "expr" var.pos=28615 var.line_nr=982
		// af parent scope:
		// var "g" var.pos=28562 var.line_nr=981
		// var "expr" var.pos=28583 var.line_nr=981
		// af parent scope:
		// af parent scope:
		return _t3206;
	}
	else {
		 v__gen__c__SqlType _t3207 = v__gen__c__SqlType_unknown;
		// autofree_scope_vars(pos=28863 line_nr=992 scope.pos=28854 scope.end_pos=28882)
		// af parent scope:
		// var "g" var.pos=28562 var.line_nr=981
		// var "expr" var.pos=28583 var.line_nr=981
		// af parent scope:
		// af parent scope:
		return _t3207;
	};
	 v__gen__c__SqlType _t3208 = v__gen__c__SqlType_unknown;
	// autofree_scope_vars(pos=28887 line_nr=995 scope.pos=28557 scope.end_pos=28904)
	// var "g" var.pos=28562 var.line_nr=981
	// var "expr" var.pos=28583 var.line_nr=981
	// af parent scope:
	// af parent scope:
	return _t3208;
}

VV_LOCAL_SYMBOL v__gen__c__SqlType v__gen__c__Gen_parse_db_from_type_string(v__gen__c__Gen* g, string name) {

	if (string_eq(name, _SLIT("sqlite.DB"))) {
		 v__gen__c__SqlType _t3209 = v__gen__c__SqlType_sqlite3;
		// autofree_scope_vars(pos=29003 line_nr=1001 scope.pos=28987 scope.end_pos=29022)
		// af parent scope:
		// var "g" var.pos=28915 var.line_nr=998
		// var "name" var.pos=28948 var.line_nr=998
		// af parent scope:
		// af parent scope:
		return _t3209;
	}
	else if (string_eq(name, _SLIT("mysql.Connection"))) {
		 v__gen__c__SqlType _t3210 = v__gen__c__SqlType_mysql;
		// autofree_scope_vars(pos=29049 line_nr=1004 scope.pos=29026 scope.end_pos=29066)
		// af parent scope:
		// var "g" var.pos=28915 var.line_nr=998
		// var "name" var.pos=28948 var.line_nr=998
		// af parent scope:
		// af parent scope:
		return _t3210;
	}
	else {
		 v__gen__c__SqlType _t3211 = v__gen__c__SqlType_unknown;
		// autofree_scope_vars(pos=29079 line_nr=1007 scope.pos=29070 scope.end_pos=29098)
		// af parent scope:
		// var "g" var.pos=28915 var.line_nr=998
		// var "name" var.pos=28948 var.line_nr=998
		// af parent scope:
		// af parent scope:
		return _t3211;
	};
	return 0;
}

VV_LOCAL_SYMBOL v__ast__Type v__gen__c__Gen_get_sql_field_type(v__gen__c__Gen* g, v__ast__StructField field) {
	v__ast__Type typ = field.typ;
	// FOR IN array
	for (int _t3212 = 0; _t3212 < field.attrs.len; ++_t3212) {
		v__ast__Attr attr = ((v__ast__Attr*)field.attrs.data)[_t3212];
		if (string_eq(attr.name, _SLIT("sql")) && (attr.arg).len != 0) {
			if (string_eq(string_to_lower(attr.arg), _SLIT("serial"))) {
				typ = ((v__ast__Type)(-1));
				break;
			}
			typ = (*(int*)map_get(ADDR(map, g->table->type_idxs), &(string[]){attr.arg}, &(int[]){ 0 }));
		}
	}
	// autofree_scope_vars(pos=29389 line_nr=1023 scope.pos=29109 scope.end_pos=29401)
	// var "g" var.pos=29114 var.line_nr=1012
	// var "field" var.pos=29140 var.line_nr=1012
	// var "typ" var.pos=29179 var.line_nr=1013
	// af parent scope:
	// af parent scope:
	return typ;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_write_str_fn_definitions(v__gen__c__Gen* g) {
	v__gen__c__Gen_writeln(g, _SLIT("\nvoid _STR_PRINT_ARG(const char *fmt, char** refbufp, int *nbytes, int *memsize, int guess, ...) {\n	va_list args;\n	va_start(args, guess);\n	// NB: (*memsize - *nbytes) === how much free space is left at the end of the current buffer refbufp\n	// *memsize === total length of the buffer refbufp\n	// *nbytes === already occupied bytes of buffer refbufp\n	// guess === how many bytes were taken during the current vsnprintf run\n	for(;;) {\n		if (guess < *memsize - *nbytes) {\n			guess = vsnprintf(*refbufp + *nbytes, *memsize - *nbytes, fmt, args);\n			if (guess < *memsize - *nbytes) { // result did fit into buffer\n				*nbytes += guess;\n				break;\n			}\n		}\n		// increase buffer (somewhat exponentially)\n		*memsize += (*memsize + *memsize) / 3 + guess;\n#ifdef _VGCBOEHM\n		*refbufp = (char*)GC_REALLOC((void*)*refbufp, *memsize);\n#else\n		*refbufp = (char*)realloc((void*)*refbufp, *memsize);\n#endif\n	}\n	va_end(args);\n}\n\nstring _STR(const char *fmt, int nfmts, ...) {\n	va_list argptr;\n	int memsize = 128;\n	int nbytes = 0;\n#ifdef _VGCBOEHM\n	char* buf = (char*)GC_MALLOC(memsize);\n#else\n	char* buf = (char*)malloc(memsize);\n#endif\n	va_start(argptr, nfmts);\n	for (int i=0; i<nfmts; ++i) {\n		int k = strlen(fmt);\n		bool is_fspec = false;\n		for (int j=0; j<k; ++j) {\n			if (fmt[j] == '%') {\n				j++;\n				if (fmt[j] != '%') {\n					is_fspec = true;\n					break;\n				}\n			}\n		}\n		if (is_fspec) {\n			char f = fmt[k-1];\n			char fup = f & 0xdf; // toupper\n			bool l = fmt[k-2] == 'l';\n			bool ll = l && fmt[k-3] == 'l';\n			if (f == 'u' || fup == 'X' || f == 'o' || f == 'd' || f == 'c') { // int...\n				if (ll) _STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+16, va_arg(argptr, long long));\n				else if (l) _STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+10, va_arg(argptr, long));\n				else _STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+8, va_arg(argptr, int));\n			} else if (fup >= 'E' && fup <= 'G') { // floating point\n				_STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+10, va_arg(argptr, double));\n			} else if (f == 'p') {\n				_STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+14, va_arg(argptr, void*));\n			} else if (f == 's') { // v string\n				string s = va_arg(argptr, string);\n				if (fmt[k-4] == '*') { // %*.*s\n					int fwidth = va_arg(argptr, int);\n					if (fwidth < 0)\n						fwidth -= (s.len - utf8_str_visible_length(s));\n					else\n						fwidth += (s.len - utf8_str_visible_length(s));\n					_STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+s.len-4, fwidth, s.len, s.str);\n				} else { // %.*s\n					_STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+s.len-4, s.len, s.str);\n				}\n			} else {\n				//v_panic(tos3('Invaid format specifier'));\n			}\n		} else {\n			_STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k);\n		}\n		fmt += k+1;\n	}\n	va_end(argptr);\n	buf[nbytes] = 0;\n\n#ifdef _VGCBOEHM\n	buf = (char*)GC_REALLOC((void*)buf, nbytes+1);\n#else\n	buf = (char*)realloc((void*)buf, nbytes+1);\n#endif\n\n#ifdef DEBUG_ALLOC\n	//puts('_STR:');\n	puts(buf);\n#endif\n\n#if _VAUTOFREE\n	//g_cur_str = (byteptr)buf;\n#endif\n	return tos2((byteptr)buf);\n}\n\nstring _STR_TMP(const char *fmt, ...) {\n	va_list argptr;\n	va_start(argptr, fmt);\n	size_t len = vsnprintf(0, 0, fmt, argptr) + 1;\n	va_end(argptr);\n	va_start(argptr, fmt);\n	vsprintf((char *)g_str_buf, fmt, argptr);\n	va_end(argptr);\n\n#ifdef DEBUG_ALLOC\n	//puts('_STR_TMP:');\n	//puts(g_str_buf);\n#endif\n	string res = tos(g_str_buf,  len);\n	res.is_lit = 1;\n	return res;\n\n} // endof _STR_TMP\n\n"));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_string_literal(v__gen__c__Gen* g, v__ast__StringLiteral node) {
	if (node.is_raw) {
		string escaped_val = v__util__smart_quote(node.val, true);
		v__gen__c__Gen_write(g, _STR("_SLIT(\"%.*s\000\")", 2, escaped_val));
		return;
	}
	string escaped_val = v__util__smart_quote(node.val, false);
	if (g->is_c_call || node.language == v__ast__Language_c) {
		v__gen__c__Gen_write(g, _STR("\"%.*s\000\"", 2, escaped_val));
	} else {
		v__gen__c__Gen_write(g, _STR("_SLIT(\"%.*s\000\")", 2, escaped_val));
	}
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_string_inter_literal_sb_optimized(v__gen__c__Gen* g, v__ast__CallExpr call_expr) {
	v__ast__StringInterLiteral node = /* as */ *(v__ast__StringInterLiteral*)__as_cast(((*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr.args, 0)).expr)._v__ast__StringInterLiteral,((*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr.args, 0)).expr)._typ, 276) /*expected idx: 276, name: v.ast.StringInterLiteral */ ;
	v__gen__c__Gen_writeln(g, _SLIT("// sb inter opt"));
	bool is_nl = string_eq(call_expr.name, _SLIT("writeln"));
	// FOR IN array
	for (int i = 0; i < node.vals.len; ++i) {
		string val = ((string*)node.vals.data)[i];
		string escaped_val = v__util__smart_quote(val, false);
		v__gen__c__Gen_write(g, _SLIT("strings__Builder_write_string(&"));
		v__gen__c__Gen_expr(g, call_expr.left);
		v__gen__c__Gen_write(g, _SLIT(", _SLIT(\""));
		v__gen__c__Gen_write(g, escaped_val);
		v__gen__c__Gen_writeln(g, _SLIT("\"));"));
		if (i >= node.exprs.len) {
			break;
		}
		if (is_nl && i == node.exprs.len - 1) {
			v__gen__c__Gen_write(g, _SLIT("strings__Builder_writeln(&"));
		} else {
			v__gen__c__Gen_write(g, _SLIT("strings__Builder_write_string(&"));
		}
		v__gen__c__Gen_expr(g, call_expr.left);
		v__gen__c__Gen_write(g, _SLIT(", "));
		v__ast__Type typ = (*(v__ast__Type*)/*ee elem_typ */array_get(node.expr_types, i));
		v__gen__c__Gen_write(g, v__gen__c__Gen_typ(g, typ));
		v__gen__c__Gen_write(g, _SLIT("_str("));
		v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, typ);
		if (sym->kind != v__ast__Kind_function) {
			v__gen__c__Gen_expr(g, (*(v__ast__Expr*)/*ee elem_typ */array_get(node.exprs, i)));
		}
		v__gen__c__Gen_writeln(g, _SLIT("));"));
	}
	v__gen__c__Gen_writeln(g, _SLIT(""));
	return;
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_string_inter_literal(v__gen__c__Gen* g, v__ast__StringInterLiteral node) {
	v__gen__c__Gen_write(g, _SLIT("_STR(\""));
	bool end_string = false;
	// FOR IN array
	for (int i = 0; i < node.vals.len; ++i) {
		string val = ((string*)node.vals.data)[i];
		string escaped_val = string_replace_each(val, new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT("%"), _SLIT("%%")})));
		escaped_val = v__util__smart_quote(escaped_val, false);
		if (i >= node.exprs.len) {
			if (escaped_val.len > 0) {
				end_string = true;
				v__gen__c__Gen_write(g, _SLIT("\\000"));
				v__gen__c__Gen_write(g, escaped_val);
			}
			break;
		}
		v__gen__c__Gen_write(g, escaped_val);
		v__ast__Type typ = v__gen__c__Gen_unwrap_generic(g, (*(v__ast__Type*)/*ee elem_typ */array_get(node.expr_types, i)));
		v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, typ);
		if (sym->kind == v__ast__Kind_alias) {
			typ = (/* as */ *(v__ast__Alias*)__as_cast((sym->info)._v__ast__Alias,(sym->info)._typ, 413) /*expected idx: 413, name: v.ast.Alias */ ).parent_type;
		}
		v__gen__c__Gen_write(g, _SLIT("%"));
		byte fspec = (*(byte*)/*ee elem_typ */array_get(node.fmts, i));
		string fmt = ((*(bool*)/*ee elem_typ */array_get(node.pluss, i)) ? (_SLIT("+")) : (_SLIT("")));
		if ((*(bool*)/*ee elem_typ */array_get(node.fills, i)) && (*(int*)/*ee elem_typ */array_get(node.fwidths, i)) >= 0) {
			fmt = _STR("%.*s\0000", 2, fmt);
		}
		if ((*(int*)/*ee elem_typ */array_get(node.fwidths, i)) != 0) {
			fmt = _STR("%.*s\000%"PRId32"", 2, fmt, (*(int*)/*ee elem_typ */array_get(node.fwidths, i)));
		}
		if ((*(int*)/*ee elem_typ */array_get(node.precisions, i)) != 987698) {
			fmt = _STR("%.*s\000.%"PRId32"", 2, fmt, (*(int*)/*ee elem_typ */array_get(node.precisions, i)));
		}
		if (fspec == L's') {
			if ((*(int*)/*ee elem_typ */array_get(node.fwidths, i)) == 0) {
				v__gen__c__Gen_write(g, _SLIT(".*s"));
			} else {
				v__gen__c__Gen_write(g, _SLIT("*.*s"));
			}
		} else if (v__ast__Type_is_float(typ)) {
			v__gen__c__Gen_write(g, _STR("%.*s\000%c", 2, fmt, fspec));
		} else if (v__ast__Type_is_pointer(typ)) {
			if (fspec == L'p') {
				v__gen__c__Gen_write(g, _STR("%.*s\000p", 2, fmt));
			} else {
				v__gen__c__Gen_write(g, _STR("%.*s\000\"PRI%c\000PTR\"", 3, fmt, fspec));
			}
		} else if (v__ast__Type_is_int(typ)) {
			if (fspec == L'c') {
				v__gen__c__Gen_write(g, _STR("%.*s\000c", 2, fmt));
			} else {
				v__gen__c__Gen_write(g, _STR("%.*s\000\"PRI%c", 2, fmt, fspec));
				if ((typ == _const_v__ast__i8_type || typ == _const_v__ast__byte_type)) {
					v__gen__c__Gen_write(g, _SLIT("8"));
				} else if ((typ == _const_v__ast__i16_type || typ == _const_v__ast__u16_type)) {
					v__gen__c__Gen_write(g, _SLIT("16"));
				} else if ((typ == _const_v__ast__i64_type || typ == _const_v__ast__u64_type)) {
					v__gen__c__Gen_write(g, _SLIT("64"));
				} else {
					v__gen__c__Gen_write(g, _SLIT("32"));
				}
				v__gen__c__Gen_write(g, _SLIT("\""));
			}
		} else {
			v__gen__c__Gen_write(g, _STR("%.*s\000\"PRId32\"", 2, fmt));
		}
		if (i < node.exprs.len - 1) {
			v__gen__c__Gen_write(g, _SLIT("\\000"));
		}
	}
	int num_string_parts = (end_string ? (node.exprs.len + 1) : (node.exprs.len));
	v__gen__c__Gen_write(g, _STR("\", %"PRId32"\000, ", 2, num_string_parts));
	// FOR IN array
	for (int i = 0; i < node.exprs.len; ++i) {
		v__ast__Expr expr = ((v__ast__Expr*)node.exprs.data)[i];
		v__ast__Type typ = v__gen__c__Gen_unwrap_generic(g, (*(v__ast__Type*)/*ee elem_typ */array_get(node.expr_types, i)));
		if (v__ast__Type_alias_eq(typ, _const_v__ast__string_type)) {
			if (g->inside_vweb_tmpl) {
				v__gen__c__Gen_write(g, _SLIT("vweb__filter("));
				if (v__ast__Expr_is_auto_deref_var(expr)) {
					v__gen__c__Gen_write(g, _SLIT("*"));
				}
				v__gen__c__Gen_expr(g, expr);
				v__gen__c__Gen_write(g, _SLIT(")"));
			} else {
				if (v__ast__Expr_is_auto_deref_var(expr)) {
					v__gen__c__Gen_write(g, _SLIT("*"));
				}
				v__gen__c__Gen_expr(g, expr);
			}
		} else if ((*(byte*)/*ee elem_typ */array_get(node.fmts, i)) == L's' || v__ast__Type_has_flag(typ, v__ast__TypeFlag_variadic)) {
			v__gen__c__Gen_gen_expr_to_string(g, expr, typ);
		} else if (v__ast__Type_is_number(typ) || v__ast__Type_is_pointer(typ) || (*(byte*)/*ee elem_typ */array_get(node.fmts, i)) == L'd') {
			if (v__ast__Type_is_signed(typ) && ((*(byte*)/*ee elem_typ */array_get(node.fmts, i)) == L'x' || (*(byte*)/*ee elem_typ */array_get(node.fmts, i)) == L'X' || (*(byte*)/*ee elem_typ */array_get(node.fmts, i)) == L'o')) {
				if (v__ast__Type_alias_eq(typ, _const_v__ast__i8_type)) {
					v__gen__c__Gen_write(g, _SLIT("(byte)("));
				} else if (v__ast__Type_alias_eq(typ, _const_v__ast__i16_type)) {
					v__gen__c__Gen_write(g, _SLIT("(u16)("));
				} else if (v__ast__Type_alias_eq(typ, _const_v__ast__int_type)) {
					v__gen__c__Gen_write(g, _SLIT("(u32)("));
				} else {
					v__gen__c__Gen_write(g, _SLIT("(u64)("));
				}
				if (v__ast__Expr_is_auto_deref_var(expr)) {
					v__gen__c__Gen_write(g, _SLIT("*"));
				}
				v__gen__c__Gen_expr(g, expr);
				v__gen__c__Gen_write(g, _SLIT(")"));
			} else {
				if (v__ast__Expr_is_auto_deref_var(expr)) {
					v__gen__c__Gen_write(g, _SLIT("*"));
				}
				v__gen__c__Gen_expr(g, expr);
			}
		} else {
			if (v__ast__Expr_is_auto_deref_var(expr)) {
				v__gen__c__Gen_write(g, _SLIT("*"));
			}
			v__gen__c__Gen_expr(g, expr);
		}
		if ((*(byte*)/*ee elem_typ */array_get(node.fmts, i)) == L's' && (*(int*)/*ee elem_typ */array_get(node.fwidths, i)) != 0) {
			v__gen__c__Gen_write(g, _STR(", %"PRId32"", 1, (*(int*)/*ee elem_typ */array_get(node.fwidths, i))));
		}
		if (i < node.exprs.len - 1) {
			v__gen__c__Gen_write(g, _SLIT(", "));
		}
	}
	v__gen__c__Gen_write(g, _SLIT(")"));
}

VV_LOCAL_SYMBOL void v__gen__c__Gen_gen_expr_to_string(v__gen__c__Gen* g, v__ast__Expr expr, v__ast__Type etype) {
	bool is_shared = v__ast__Type_has_flag(etype, v__ast__TypeFlag_shared_f);
	v__ast__Type typ = etype;
	if (is_shared) {
		typ = v__ast__Type_set_nr_muls(v__ast__Type_clear_flag(typ, v__ast__TypeFlag_shared_f), 0);
	}
	v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, typ);
	if ((sym->info)._typ == 413 /* v.ast.Alias */) {
		v__ast__TypeSymbol* parent_sym = v__ast__Table_get_type_symbol(g->table, (*sym->info._v__ast__Alias).parent_type);
		if (v__ast__TypeSymbol_has_method(parent_sym, _SLIT("str"))) {
			typ = (*sym->info._v__ast__Alias).parent_type;
			sym = parent_sym;
		}
	}
	multi_return_bool_bool_int mr_9382 = v__ast__TypeSymbol_str_method_info(sym);
	bool sym_has_str_method = mr_9382.arg0;
	bool str_method_expects_ptr = mr_9382.arg1;
	if (v__ast__Type_has_flag(typ, v__ast__TypeFlag_variadic)) {
		string str_fn_name = v__gen__c__Gen_gen_str_for_type(g, typ);
		v__gen__c__Gen_write(g, _STR("%.*s\000(", 2, str_fn_name));
		v__gen__c__Gen_expr(g, expr);
		v__gen__c__Gen_write(g, _SLIT(")"));
	} else if (v__ast__Type_alias_eq(typ, _const_v__ast__string_type)) {
		v__gen__c__Gen_expr(g, expr);
	} else if (v__ast__Type_alias_eq(typ, _const_v__ast__bool_type)) {
		v__gen__c__Gen_expr(g, expr);
		v__gen__c__Gen_write(g, _SLIT(" ? _SLIT(\"true\") : _SLIT(\"false\")"));
	} else if (sym->kind == v__ast__Kind_none_) {
		v__gen__c__Gen_write(g, _SLIT("_SLIT(\"<none>\")"));
	} else if (sym->kind == v__ast__Kind_enum_) {
		bool is_var = ((expr._typ == 273 /* v.ast.SelectorExpr */) ? (true) : (expr._typ == 254 /* v.ast.Ident */) ? (true) : (false));
		if (is_var) {
			string str_fn_name = v__gen__c__Gen_gen_str_for_type(g, typ);
			v__gen__c__Gen_write(g, _STR("%.*s\000(", 2, str_fn_name));
			v__gen__c__Gen_enum_expr(g, expr);
			v__gen__c__Gen_write(g, _SLIT(")"));
		} else {
			v__gen__c__Gen_write(g, _SLIT("_SLIT(\""));
			v__gen__c__Gen_enum_expr(g, expr);
			v__gen__c__Gen_write(g, _SLIT("\")"));
		}
	} else if (sym_has_str_method || (sym->kind == v__ast__Kind_array || sym->kind == v__ast__Kind_array_fixed || sym->kind == v__ast__Kind_map || sym->kind == v__ast__Kind_struct_ || sym->kind == v__ast__Kind_multi_return || sym->kind == v__ast__Kind_sum_type || sym->kind == v__ast__Kind_interface_)) {
		bool is_ptr = v__ast__Type_is_ptr(typ);
		bool is_var_mut = v__ast__Expr_is_auto_deref_var(expr);
		string str_fn_name = v__gen__c__Gen_gen_str_for_type(g, typ);
		if (is_ptr && !is_var_mut) {
			v__gen__c__Gen_write(g, _SLIT("_STR(\"&%.*s\\000\", 2, "));
		}
		v__gen__c__Gen_write(g, _STR("%.*s\000(", 2, str_fn_name));
		if (str_method_expects_ptr && !is_ptr) {
			v__gen__c__Gen_write(g, _SLIT("&"));
		} else if ((!str_method_expects_ptr && is_ptr && !is_shared) || is_var_mut) {
			v__gen__c__Gen_write(g, _SLIT("*"));
		}
		if ((expr)._typ == 235 /* v.ast.ArrayInit */) {
			if ((*expr._v__ast__ArrayInit).is_fixed) {
				string s = v__gen__c__Gen_typ(g, (*expr._v__ast__ArrayInit).typ);
				v__gen__c__Gen_write(g, _STR("(%.*s\000)", 2, s));
			}
		}
		v__gen__c__Gen_expr(g, expr);
		if (is_shared) {
			v__gen__c__Gen_write(g, _SLIT("->val"));
		}
		v__gen__c__Gen_write(g, _SLIT(")"));
		if (is_ptr && !is_var_mut) {
			v__gen__c__Gen_write(g, _SLIT(")"));
		}
	} else {
		string str_fn_name = v__gen__c__Gen_gen_str_for_type(g, typ);
		v__gen__c__Gen_write(g, _STR("%.*s\000(", 2, str_fn_name));
		if (sym->kind != v__ast__Kind_function) {
			v__gen__c__Gen_expr(g, expr);
		}
		v__gen__c__Gen_write(g, _SLIT(")"));
	}
}

void v__markused__mark_used(v__ast__Table* table, v__pref__Preferences* pref, Array_v__ast__File ast_files) {
bool v__markused__mark_used_defer_0 = false;
	multi_return_Map_string_v__ast__FnDecl_Map_string_v__ast__ConstField mr_420 = v__markused__all_fn_and_const(ast_files);
	Map_string_v__ast__FnDecl all_fns = mr_420.arg0;
	Map_string_v__ast__ConstField all_consts = mr_420.arg1;
	v__util__timing_start(_SLIT("mark_used"));
	v__markused__mark_used_defer_0 = true;
	Array_string all_fn_root_names = new_array_from_c_array(74, 74, sizeof(string), _MOV((string[74]){
			_SLIT("main.main"), _SLIT("__new_array"), _SLIT("__new_array_with_default"), _SLIT("__new_array_with_array_default"), _SLIT("new_array_from_c_array"), _SLIT("v_fixed_index"), _SLIT("memdup"), _SLIT("vstrlen"), _SLIT("__as_cast"), _SLIT("tos"), _SLIT("tos2"), _SLIT("tos3"), _SLIT("isnil"), _SLIT("opt_ok"), _SLIT("error"), _SLIT("utf8_str_visible_length"), _SLIT("compare_ints"), _SLIT("compare_u64s"), _SLIT("compare_strings"), _SLIT("compare_ints_reverse"), _SLIT("compare_u64s_reverse"), _SLIT("compare_strings_reverse"), _SLIT("builtin_init"), _SLIT("3.vstring"), _SLIT("3.vstring_with_len"), _SLIT("4.vstring"), _SLIT("4.vstring_with_len"), _SLIT("9.str_escaped"), _SLIT("18.add"), _SLIT("18.trim_space"), _SLIT("18.replace"), _SLIT("18.clone"), _SLIT("18.clone_static"), _SLIT("18.trim"), _SLIT("18.substr"), _SLIT("18.at"), _SLIT("18.index_kmp"), _SLIT("18.eq"), _SLIT("18.ne"), _SLIT("18.lt"), _SLIT("18.gt"), _SLIT("18.le"), _SLIT("18.ge"), _SLIT("19.eq"), _SLIT("19.ne"), _SLIT("19.lt"), _SLIT("19.gt"), _SLIT("19.le"), _SLIT("19.ge"), _SLIT("19.add"), _SLIT("21.get"), _SLIT("21.set"), _SLIT("21.get_unsafe"), _SLIT("21.set_unsafe"), _SLIT("21.clone_static"), _SLIT("21.first"), _SLIT("21.last"), _SLIT("21.reverse"), _SLIT("21.repeat"), _SLIT("21.slice"), _SLIT("21.slice2"), _SLIT("59.get"), _SLIT("59.set"), _SLIT("65557.last"), _SLIT("65557.pop"), _SLIT("65557.push"), _SLIT("65557.insert_many"), _SLIT("65557.prepend_many"), _SLIT("65557.reverse"), _SLIT("65557.set"), _SLIT("65557.set_unsafe"), _SLIT("os.getwd"), _SLIT("os.init_os_args"), _SLIT("os.init_os_args_wide")}));
	// FOR IN map
	int _t3214 = all_fns.key_values.len;
	for (int _t3213 = 0; _t3213 < _t3214; ++_t3213 ) {
		int _t3215 = all_fns.key_values.len - _t3214;
		_t3214 = all_fns.key_values.len;
		if (_t3215 < 0) {
			_t3213 = -1;
			continue;
		}
		if (!DenseArray_has_index(&all_fns.key_values, _t3213)) {continue;}
		string k = /*key*/ *(string*)DenseArray_key(&all_fns.key_values, _t3213);
		k = string_clone(k);
		v__ast__FnDecl* mfn = &(*(v__ast__FnDecl*)DenseArray_value(&all_fns.key_values, _t3213));
		string method_receiver_typename = _SLIT("");
		if (mfn->is_method) {
			method_receiver_typename = v__ast__Table_type_to_str(table, mfn->receiver.typ);
		}
		if (string_eq(method_receiver_typename, _SLIT("&wyrand.WyRandRNG"))) {
			array_push(&all_fn_root_names, _MOV((string[]){ string_clone(k) }));
			continue;
		}
		if (string_eq(method_receiver_typename, _SLIT("&strings.Builder"))) {
			array_push(&all_fn_root_names, _MOV((string[]){ string_clone(k) }));
			continue;
		}
		if (string_ends_with(k, _SLIT(".str"))) {
			array_push(&all_fn_root_names, _MOV((string[]){ string_clone(k) }));
			continue;
		}
		if (string_ends_with(k, _SLIT(".init"))) {
			array_push(&all_fn_root_names, _MOV((string[]){ string_clone(k) }));
			continue;
		}
		if (string_ends_with(k, _SLIT(".free"))) {
			array_push(&all_fn_root_names, _MOV((string[]){ string_clone(k) }));
			continue;
		}
		if (string_ends_with(k, _SLIT(".lock")) || string_ends_with(k, _SLIT(".unlock")) || string_ends_with(k, _SLIT(".rlock")) || string_ends_with(k, _SLIT(".runlock"))) {
			array_push(&all_fn_root_names, _MOV((string[]){ string_clone(k) }));
			continue;
		}
		if (pref->is_test) {
			if (string_starts_with(k, _SLIT("test_")) || string_contains(k, _SLIT(".test_"))) {
				array_push(&all_fn_root_names, _MOV((string[]){ string_clone(k) }));
				continue;
			}
			if (string_starts_with(k, _SLIT("testsuite_")) || string_contains(k, _SLIT(".testsuite_"))) {
				array_push(&all_fn_root_names, _MOV((string[]){ string_clone(k) }));
				continue;
			}
		}
	}
	if (pref->is_debug) {
		array_push(&all_fn_root_names, _MOV((string[]){ string_clone(_SLIT("panic_debug")) }));
	}
	array_push(&all_fn_root_names, _MOV((string[]){ string_clone(_SLIT("panic_optional_not_set")) }));
	if (pref->is_test) {
		array_push(&all_fn_root_names, _MOV((string[]){ string_clone(_SLIT("main.cb_assertion_ok")) }));
		array_push(&all_fn_root_names, _MOV((string[]){ string_clone(_SLIT("main.cb_assertion_failed")) }));
		Option_v__ast__TypeSymbol _t3228;
		if (_t3228 = v__ast__Table_find_type(table, _SLIT("main.BenchedTests")), _t3228.state == 0) {
			v__ast__TypeSymbol benched_tests_sym = *(v__ast__TypeSymbol*)_t3228.data;
			v__ast__Type bts_type = (*(v__ast__Param*)/*ee elem_typ */array_get((*(v__ast__Fn*)/*ee elem_typ */array_get(benched_tests_sym.methods, 0)).params, 0)).typ;
			array_push(&all_fn_root_names, _MOV((string[]){ string_clone(_STR("%"PRId32"\000.testing_step_start", 2, bts_type)) }));
			array_push(&all_fn_root_names, _MOV((string[]){ string_clone(_STR("%"PRId32"\000.testing_step_end", 2, bts_type)) }));
			array_push(&all_fn_root_names, _MOV((string[]){ string_clone(_STR("%"PRId32"\000.end_testing", 2, bts_type)) }));
			array_push(&all_fn_root_names, _MOV((string[]){ string_clone(_SLIT("main.start_testing")) }));
		}
	}
	v__markused__Walker walker = (v__markused__Walker){.table = table,.used_fns = new_map(sizeof(string), sizeof(bool), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.used_consts = new_map(sizeof(string), sizeof(bool), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.n_maps = 0,.n_asserts = 0,.files = ast_files,.all_fns = all_fns,.all_consts = all_consts,};
	v__markused__Walker_mark_root_fns(&walker, all_fn_root_names);
	if (walker.n_asserts > 0) {
		v__markused__Walker_fn_decl(&walker, (voidptr)&/*qq*/(*(v__ast__FnDecl*)map_get(ADDR(map, all_fns), &(string[]){_SLIT("__print_assert_failure")}, &(v__ast__FnDecl[]){ (v__ast__FnDecl){.params = __new_array(0, 1, sizeof(v__ast__Param)),.generic_names = __new_array(0, 1, sizeof(string)),.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.stmts = __new_array(0, 1, sizeof(v__ast__Stmt)),.defer_stmts = __new_array(0, 1, sizeof(v__ast__DeferStmt)),.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.next_comments = __new_array(0, 1, sizeof(v__ast__Comment)),.source_file = 0,.label_names = __new_array(0, 1, sizeof(string)),} })));
	}
	if (walker.n_maps > 0) {
		// FOR IN map
		int _t3234 = all_fns.key_values.len;
		for (int _t3233 = 0; _t3233 < _t3234; ++_t3233 ) {
			int _t3235 = all_fns.key_values.len - _t3234;
			_t3234 = all_fns.key_values.len;
			if (_t3235 < 0) {
				_t3233 = -1;
				continue;
			}
			if (!DenseArray_has_index(&all_fns.key_values, _t3233)) {continue;}
			string k = /*key*/ *(string*)DenseArray_key(&all_fns.key_values, _t3233);
			k = string_clone(k);
			v__ast__FnDecl* mfn = &(*(v__ast__FnDecl*)DenseArray_value(&all_fns.key_values, _t3233));
			string method_receiver_typename = _SLIT("");
			if (mfn->is_method) {
				method_receiver_typename = v__ast__Table_type_to_str(table, mfn->receiver.typ);
			}
			if ((string_eq(k, _SLIT("new_map")) || string_eq(k, _SLIT("new_map_init")) || string_eq(k, _SLIT("map_hash_string"))) || string_eq(method_receiver_typename, _SLIT("&map")) || string_eq(method_receiver_typename, _SLIT("&DenseArray")) || string_starts_with(k, _SLIT("map_"))) {
				v__markused__Walker_fn_decl(&walker, mfn);
			}
		}
	}
	table->used_fns = map_move(&walker.used_fns);
	table->used_consts = map_move(&walker.used_consts);
// Defer begin
if (v__markused__mark_used_defer_0 == true) {
	v__util__timing_measure(_SLIT("mark_used"));
}
// Defer end
}

VV_LOCAL_SYMBOL multi_return_Map_string_v__ast__FnDecl_Map_string_v__ast__ConstField v__markused__all_fn_and_const(Array_v__ast__File ast_files) {
bool v__markused__all_fn_and_const_defer_0 = false;
	v__util__timing_start(_SLIT("all_fn_and_const"));
	v__markused__all_fn_and_const_defer_0 = true;
	Map_string_v__ast__FnDecl all_fns = new_map(sizeof(string), sizeof(v__ast__FnDecl), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
	Map_string_v__ast__ConstField all_consts = new_map(sizeof(string), sizeof(v__ast__ConstField), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
	for (int i = 0; i < ast_files.len; ++i) {
		v__ast__File* file = &(*(v__ast__File*)/*ee elem_typ */array_get(ast_files, i));
		// FOR IN array
		for (int _t3236 = 0; _t3236 < file->stmts.len; ++_t3236) {
			v__ast__Stmt node = ((v__ast__Stmt*)file->stmts.data)[_t3236];
			if (node._typ == 175 /* v.ast.FnDecl */) {
				string fkey = ((*node._v__ast__FnDecl).is_method ? (_STR("%"PRId32"\000.%.*s", 2, ((int)((*node._v__ast__FnDecl).receiver.typ)), (*node._v__ast__FnDecl).name)) : ((*node._v__ast__FnDecl).name));
(*(v__ast__FnDecl*)map_get_and_set(&all_fns, &(string[]){fkey}, &(v__ast__FnDecl[]){ (v__ast__FnDecl){.params = __new_array(0, 1, sizeof(v__ast__Param)),.generic_names = __new_array(0, 1, sizeof(string)),.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.stmts = __new_array(0, 1, sizeof(v__ast__Stmt)),.defer_stmts = __new_array(0, 1, sizeof(v__ast__DeferStmt)),.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.next_comments = __new_array(0, 1, sizeof(v__ast__Comment)),.source_file = 0,.label_names = __new_array(0, 1, sizeof(string)),} })) = (*node._v__ast__FnDecl);
			}
			else if (node._typ == 289 /* v.ast.ConstDecl */) {
				// FOR IN array
				for (int _t3237 = 0; _t3237 < (*node._v__ast__ConstDecl).fields.len; ++_t3237) {
					v__ast__ConstField cfield = ((v__ast__ConstField*)(*node._v__ast__ConstDecl).fields.data)[_t3237];
					string ckey = cfield.name;
					(*(v__ast__ConstField*)map_get_and_set(&all_consts, &(string[]){ckey}, &(v__ast__ConstField[]){ (v__ast__ConstField){.comments = __new_array(0, 1, sizeof(v__ast__Comment)),} })) = cfield;
				}
			}
			else {
			};
		}
	}
	// Defer begin
	if (v__markused__all_fn_and_const_defer_0 == true) {
		v__util__timing_measure(_SLIT("all_fn_and_const"));
	}
	// Defer end
	return (multi_return_Map_string_v__ast__FnDecl_Map_string_v__ast__ConstField){.arg0=all_fns, .arg1=all_consts};
}

void v__markused__Walker_mark_fn_as_used(v__markused__Walker* w, string fkey) {
	map_set(&w->used_fns, &(string[]){fkey}, &(bool[]) { true });
}

void v__markused__Walker_mark_const_as_used(v__markused__Walker* w, string ckey) {
	map_set(&w->used_consts, &(string[]){ckey}, &(bool[]) { true });
	v__ast__ConstField* _t3239 = (v__ast__ConstField*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, w->all_consts), &(string[]){ckey}));
	Option_v__ast__ConstField _t3238 = {0};
	if (_t3239) {
		*((v__ast__ConstField*)&_t3238.data) = *((v__ast__ConstField*)_t3239);
	} else {
		_t3238.state = 2; _t3238.err = v_error(_SLIT("array index out of range"));
	}
	;
	if (_t3238.state != 0) { /*or block*/ 
		IError err = _t3238.err;
		return;
	}
	v__ast__ConstField cfield = *(v__ast__ConstField*)_t3238.data;
	v__markused__Walker_expr(w, cfield.expr);
}

void v__markused__Walker_mark_root_fns(v__markused__Walker* w, Array_string all_fn_root_names) {
	// FOR IN array
	for (int _t3240 = 0; _t3240 < all_fn_root_names.len; ++_t3240) {
		string fn_name = ((string*)all_fn_root_names.data)[_t3240];
		if (!_IN_MAP(ADDR(string, fn_name), ADDR(map, w->used_fns))) {
			v__markused__Walker_fn_decl(w, (voidptr)&/*qq*/(*(v__ast__FnDecl*)map_get(ADDR(map, w->all_fns), &(string[]){fn_name}, &(v__ast__FnDecl[]){ (v__ast__FnDecl){.params = __new_array(0, 1, sizeof(v__ast__Param)),.generic_names = __new_array(0, 1, sizeof(string)),.attrs = __new_array(0, 1, sizeof(v__ast__Attr)),.stmts = __new_array(0, 1, sizeof(v__ast__Stmt)),.defer_stmts = __new_array(0, 1, sizeof(v__ast__DeferStmt)),.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.next_comments = __new_array(0, 1, sizeof(v__ast__Comment)),.source_file = 0,.label_names = __new_array(0, 1, sizeof(string)),} })));
		}
	}
}

void v__markused__Walker_stmt(v__markused__Walker* w, v__ast__Stmt node) {
	if (node._typ == 291 /* v.ast.EmptyStmt */) {
	}
	else if (node._typ == 283 /* v.ast.AsmStmt */) {
		v__markused__Walker_asm_io(w, (*node._v__ast__AsmStmt).output);
		v__markused__Walker_asm_io(w, (*node._v__ast__AsmStmt).input);
	}
	else if (node._typ == 284 /* v.ast.AssertStmt */) {
		v__markused__Walker_expr(w, (*node._v__ast__AssertStmt).expr);
		w->n_asserts++;
	}
	else if (node._typ == 285 /* v.ast.AssignStmt */) {
		v__markused__Walker_exprs(w, (*node._v__ast__AssignStmt).left);
		v__markused__Walker_exprs(w, (*node._v__ast__AssignStmt).right);
	}
	else if (node._typ == 286 /* v.ast.Block */) {
		v__markused__Walker_stmts(w, (*node._v__ast__Block).stmts);
	}
	else if (node._typ == 288 /* v.ast.CompFor */) {
		v__markused__Walker_stmts(w, (*node._v__ast__CompFor).stmts);
	}
	else if (node._typ == 289 /* v.ast.ConstDecl */) {
		v__markused__Walker_const_fields(w, (*node._v__ast__ConstDecl).fields);
	}
	else if (node._typ == 293 /* v.ast.ExprStmt */) {
		v__markused__Walker_expr(w, (*node._v__ast__ExprStmt).expr);
	}
	else if (node._typ == 175 /* v.ast.FnDecl */) {
		v__markused__Walker_fn_decl(w, (voidptr)&/*qq*/(*node._v__ast__FnDecl));
	}
	else if (node._typ == 294 /* v.ast.ForCStmt */) {
		v__markused__Walker_expr(w, (*node._v__ast__ForCStmt).cond);
		v__markused__Walker_stmt(w, (*node._v__ast__ForCStmt).inc);
		v__markused__Walker_stmts(w, (*node._v__ast__ForCStmt).stmts);
	}
	else if (node._typ == 295 /* v.ast.ForInStmt */) {
		v__markused__Walker_expr(w, (*node._v__ast__ForInStmt).cond);
		v__markused__Walker_expr(w, (*node._v__ast__ForInStmt).high);
		v__markused__Walker_stmts(w, (*node._v__ast__ForInStmt).stmts);
	}
	else if (node._typ == 296 /* v.ast.ForStmt */) {
		v__markused__Walker_expr(w, (*node._v__ast__ForStmt).cond);
		v__markused__Walker_stmts(w, (*node._v__ast__ForStmt).stmts);
	}
	else if (node._typ == 298 /* v.ast.GoStmt */) {
		v__markused__Walker_expr(w, v__ast__CallExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__CallExpr, ((*node._v__ast__GoStmt).call_expr))));
	}
	else if (node._typ == 305 /* v.ast.Return */) {
		v__markused__Walker_exprs(w, (*node._v__ast__Return).exprs);
	}
	else if (node._typ == 306 /* v.ast.SqlStmt */) {
		v__markused__Walker_expr(w, (*node._v__ast__SqlStmt).db_expr);
		v__markused__Walker_expr(w, (*node._v__ast__SqlStmt).where_expr);
		v__markused__Walker_exprs(w, (*node._v__ast__SqlStmt).update_exprs);
	}
	else if (node._typ == 307 /* v.ast.StructDecl */) {
		v__markused__Walker_struct_fields(w, (*node._v__ast__StructDecl).fields);
	}
	else if (node._typ == 290 /* v.ast.DeferStmt */) {
		v__markused__Walker_stmts(w, (*node._v__ast__DeferStmt).stmts);
	}
	else if (node._typ == 297 /* v.ast.GlobalDecl */) {
		// FOR IN array
		for (int _t3241 = 0; _t3241 < (*node._v__ast__GlobalDecl).fields.len; ++_t3241) {
			v__ast__GlobalField gf = ((v__ast__GlobalField*)(*node._v__ast__GlobalDecl).fields.data)[_t3241];
			if (gf.has_expr) {
				v__markused__Walker_expr(w, gf.expr);
			}
		}
	}
	else if (node._typ == 287 /* v.ast.BranchStmt */) {
	}
	else if (node._typ == 292 /* v.ast.EnumDecl */) {
	}
	else if (node._typ == 299 /* v.ast.GotoLabel */) {
	}
	else if (node._typ == 300 /* v.ast.GotoStmt */) {
	}
	else if (node._typ == 301 /* v.ast.HashStmt */) {
	}
	else if (node._typ == 302 /* v.ast.Import */) {
	}
	else if (node._typ == 303 /* v.ast.InterfaceDecl */) {
	}
	else if (node._typ == 304 /* v.ast.Module */) {
	}
	else if (node._typ == 232 /* v.ast.TypeDecl */) {
	}
	else if (node._typ == 264 /* v.ast.NodeError */) {
	};
}

VV_LOCAL_SYMBOL void v__markused__Walker_asm_io(v__markused__Walker* w, Array_v__ast__AsmIO ios) {
	// FOR IN array
	for (int _t3242 = 0; _t3242 < ios.len; ++_t3242) {
		v__ast__AsmIO io = ((v__ast__AsmIO*)ios.data)[_t3242];
		v__markused__Walker_expr(w, io.expr);
	}
}

VV_LOCAL_SYMBOL void v__markused__Walker_defer_stmts(v__markused__Walker* w, Array_v__ast__DeferStmt stmts) {
	// FOR IN array
	for (int _t3243 = 0; _t3243 < stmts.len; ++_t3243) {
		v__ast__DeferStmt stmt = ((v__ast__DeferStmt*)stmts.data)[_t3243];
		v__markused__Walker_stmts(w, stmt.stmts);
	}
}

VV_LOCAL_SYMBOL void v__markused__Walker_stmts(v__markused__Walker* w, Array_v__ast__Stmt stmts) {
	// FOR IN array
	for (int _t3244 = 0; _t3244 < stmts.len; ++_t3244) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)stmts.data)[_t3244];
		v__markused__Walker_stmt(w, stmt);
	}
}

VV_LOCAL_SYMBOL void v__markused__Walker_exprs(v__markused__Walker* w, Array_v__ast__Expr exprs) {
	// FOR IN array
	for (int _t3245 = 0; _t3245 < exprs.len; ++_t3245) {
		v__ast__Expr expr = ((v__ast__Expr*)exprs.data)[_t3245];
		v__markused__Walker_expr(w, expr);
	}
}

VV_LOCAL_SYMBOL void v__markused__Walker_expr(v__markused__Walker* w, v__ast__Expr node) {
	if (node._typ == 250 /* v.ast.EmptyExpr */) {
	}
	else if (node._typ == 233 /* v.ast.AnonFn */) {
		v__markused__Walker_fn_decl(w, (voidptr)&/*qq*/(*node._v__ast__AnonFn).decl);
	}
	else if (node._typ == 235 /* v.ast.ArrayInit */) {
		v__markused__Walker_expr(w, (*node._v__ast__ArrayInit).len_expr);
		v__markused__Walker_expr(w, (*node._v__ast__ArrayInit).cap_expr);
		v__markused__Walker_expr(w, (*node._v__ast__ArrayInit).default_expr);
		v__markused__Walker_exprs(w, (*node._v__ast__ArrayInit).exprs);
	}
	else if (node._typ == 237 /* v.ast.Assoc */) {
		v__markused__Walker_exprs(w, (*node._v__ast__Assoc).exprs);
	}
	else if (node._typ == 234 /* v.ast.ArrayDecompose */) {
		v__markused__Walker_expr(w, (*node._v__ast__ArrayDecompose).expr);
	}
	else if (node._typ == 241 /* v.ast.CallExpr */) {
		v__markused__Walker_call_expr(w, (voidptr)&/*qq*/(*node._v__ast__CallExpr));
	}
	else if (node._typ == 242 /* v.ast.CastExpr */) {
		v__markused__Walker_expr(w, (*node._v__ast__CastExpr).expr);
		v__markused__Walker_expr(w, (*node._v__ast__CastExpr).arg);
	}
	else if (node._typ == 243 /* v.ast.ChanInit */) {
		v__markused__Walker_expr(w, (*node._v__ast__ChanInit).cap_expr);
	}
	else if (node._typ == 248 /* v.ast.ConcatExpr */) {
		v__markused__Walker_exprs(w, (*node._v__ast__ConcatExpr).vals);
	}
	else if (node._typ == 247 /* v.ast.ComptimeSelector */) {
		v__markused__Walker_expr(w, (*node._v__ast__ComptimeSelector).left);
		v__markused__Walker_expr(w, (*node._v__ast__ComptimeSelector).field_expr);
	}
	else if (node._typ == 246 /* v.ast.ComptimeCall */) {
		v__markused__Walker_expr(w, (*node._v__ast__ComptimeCall).left);
		if ((*node._v__ast__ComptimeCall).is_vweb) {
			v__markused__Walker_stmts(w, (*node._v__ast__ComptimeCall).vweb_tmpl.stmts);
		}
	}
	else if (node._typ == 249 /* v.ast.DumpExpr */) {
		v__markused__Walker_expr(w, (*node._v__ast__DumpExpr).expr);
		v__markused__Walker_fn_by_name(w, _SLIT("eprint"));
		v__markused__Walker_fn_by_name(w, _SLIT("eprintln"));
	}
	else if (node._typ == 253 /* v.ast.GoExpr */) {
		v__markused__Walker_expr(w, v__ast__CallExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__CallExpr, ((*node._v__ast__GoExpr).go_stmt.call_expr))));
	}
	else if (node._typ == 257 /* v.ast.IndexExpr */) {
		v__markused__Walker_expr(w, (*node._v__ast__IndexExpr).left);
		v__markused__Walker_expr(w, (*node._v__ast__IndexExpr).index);
		v__markused__Walker_or_block(w, (*node._v__ast__IndexExpr).or_expr);
	}
	else if (node._typ == 258 /* v.ast.InfixExpr */) {
		v__markused__Walker_expr(w, (*node._v__ast__InfixExpr).left);
		v__markused__Walker_expr(w, (*node._v__ast__InfixExpr).right);
		v__markused__Walker_or_block(w, (*node._v__ast__InfixExpr).or_block);
		if ((*node._v__ast__InfixExpr).left_type == 0) {
			return;
		}
		v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(w->table, (*node._v__ast__InfixExpr).left_type);
		if (sym->kind == v__ast__Kind_struct_) {
			Option_v__ast__Fn _t3246;
			if (_t3246 = v__ast__TypeSymbol_find_method(sym, v__token__Kind_str((*node._v__ast__InfixExpr).op)), _t3246.state == 0) {
				v__ast__Fn opmethod = *(v__ast__Fn*)_t3246.data;
				v__markused__Walker_fn_decl(w, ((v__ast__FnDecl*)(opmethod.source_fn)));
			}
		}
	}
	else if (node._typ == 256 /* v.ast.IfGuardExpr */) {
		v__markused__Walker_expr(w, (*node._v__ast__IfGuardExpr).expr);
	}
	else if (node._typ == 255 /* v.ast.IfExpr */) {
		v__markused__Walker_expr(w, (*node._v__ast__IfExpr).left);
		// FOR IN array
		for (int _t3247 = 0; _t3247 < (*node._v__ast__IfExpr).branches.len; ++_t3247) {
			v__ast__IfBranch b = ((v__ast__IfBranch*)(*node._v__ast__IfExpr).branches.data)[_t3247];
			v__markused__Walker_expr(w, b.cond);
			v__markused__Walker_stmts(w, b.stmts);
		}
	}
	else if (node._typ == 254 /* v.ast.Ident */) {

		if ((*node._v__ast__Ident).kind == (v__ast__IdentKind_constant)) {
			v__markused__Walker_mark_const_as_used(w, (*node._v__ast__Ident).name);
		}
		else if ((*node._v__ast__Ident).kind == (v__ast__IdentKind_function)) {
			v__markused__Walker_fn_by_name(w, (*node._v__ast__Ident).name);
		}
		else {
		};
	}
	else if (node._typ == 260 /* v.ast.Likely */) {
		v__markused__Walker_expr(w, (*node._v__ast__Likely).expr);
	}
	else if (node._typ == 262 /* v.ast.MapInit */) {
		v__markused__Walker_exprs(w, (*node._v__ast__MapInit).keys);
		v__markused__Walker_exprs(w, (*node._v__ast__MapInit).vals);
		w->n_maps++;
	}
	else if (node._typ == 263 /* v.ast.MatchExpr */) {
		v__markused__Walker_expr(w, (*node._v__ast__MatchExpr).cond);
		// FOR IN array
		for (int _t3248 = 0; _t3248 < (*node._v__ast__MatchExpr).branches.len; ++_t3248) {
			v__ast__MatchBranch b = ((v__ast__MatchBranch*)(*node._v__ast__MatchExpr).branches.data)[_t3248];
			v__markused__Walker_exprs(w, b.exprs);
			v__markused__Walker_stmts(w, b.stmts);
		}
	}
	else if (node._typ == 265 /* v.ast.None */) {
	}
	else if (node._typ == 268 /* v.ast.ParExpr */) {
		v__markused__Walker_expr(w, (*node._v__ast__ParExpr).expr);
	}
	else if (node._typ == 270 /* v.ast.PrefixExpr */) {
		v__markused__Walker_expr(w, (*node._v__ast__PrefixExpr).right);
	}
	else if (node._typ == 269 /* v.ast.PostfixExpr */) {
		v__markused__Walker_expr(w, (*node._v__ast__PostfixExpr).expr);
	}
	else if (node._typ == 271 /* v.ast.RangeExpr */) {
		if ((*node._v__ast__RangeExpr).has_low) {
			v__markused__Walker_expr(w, (*node._v__ast__RangeExpr).low);
		}
		if ((*node._v__ast__RangeExpr).has_high) {
			v__markused__Walker_expr(w, (*node._v__ast__RangeExpr).high);
		}
	}
	else if (node._typ == 274 /* v.ast.SizeOf */) {
		v__markused__Walker_expr(w, (*node._v__ast__SizeOf).expr);
	}
	else if (node._typ == 276 /* v.ast.StringInterLiteral */) {
		v__markused__Walker_exprs(w, (*node._v__ast__StringInterLiteral).exprs);
	}
	else if (node._typ == 273 /* v.ast.SelectorExpr */) {
		v__markused__Walker_expr(w, (*node._v__ast__SelectorExpr).expr);
	}
	else if (node._typ == 275 /* v.ast.SqlExpr */) {
		v__markused__Walker_expr(w, (*node._v__ast__SqlExpr).db_expr);
		v__markused__Walker_expr(w, (*node._v__ast__SqlExpr).offset_expr);
		v__markused__Walker_expr(w, (*node._v__ast__SqlExpr).order_expr);
		v__markused__Walker_expr(w, (*node._v__ast__SqlExpr).limit_expr);
		v__markused__Walker_expr(w, (*node._v__ast__SqlExpr).where_expr);
	}
	else if (node._typ == 278 /* v.ast.StructInit */) {
		v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(w->table, (*node._v__ast__StructInit).typ);
		if (sym->kind == v__ast__Kind_struct_) {
			v__ast__Struct info = /* as */ *(v__ast__Struct*)__as_cast((sym->info)._v__ast__Struct,(sym->info)._typ, 409) /*expected idx: 409, name: v.ast.Struct */ ;
			// FOR IN array
			for (int _t3249 = 0; _t3249 < info.fields.len; ++_t3249) {
				v__ast__StructField ifield = ((v__ast__StructField*)info.fields.data)[_t3249];
				if (ifield.has_default_expr) {
					v__markused__Walker_expr(w, ifield.default_expr);
				}
			}
		}
		if ((*node._v__ast__StructInit).has_update_expr) {
			v__markused__Walker_expr(w, (*node._v__ast__StructInit).update_expr);
		}
		// FOR IN array
		for (int _t3250 = 0; _t3250 < (*node._v__ast__StructInit).fields.len; ++_t3250) {
			v__ast__StructInitField sif = ((v__ast__StructInitField*)(*node._v__ast__StructInit).fields.data)[_t3250];
			v__markused__Walker_expr(w, sif.expr);
		}
		// FOR IN array
		for (int _t3251 = 0; _t3251 < (*node._v__ast__StructInit).embeds.len; ++_t3251) {
			v__ast__StructInitEmbed sie = ((v__ast__StructInitEmbed*)(*node._v__ast__StructInit).embeds.data)[_t3251];
			v__markused__Walker_expr(w, sie.expr);
		}
	}
	else if (node._typ == 280 /* v.ast.TypeOf */) {
		v__markused__Walker_expr(w, (*node._v__ast__TypeOf).expr);
	}
	else if (node._typ == 236 /* v.ast.AsCast */) {
		v__markused__Walker_expr(w, (*node._v__ast__AsCast).expr);
	}
	else if (node._typ == 238 /* v.ast.AtExpr */) {
	}
	else if (node._typ == 239 /* v.ast.BoolLiteral */) {
	}
	else if (node._typ == 252 /* v.ast.FloatLiteral */) {
	}
	else if (node._typ == 244 /* v.ast.CharLiteral */) {
	}
	else if (node._typ == 259 /* v.ast.IntegerLiteral */) {
	}
	else if (node._typ == 277 /* v.ast.StringLiteral */) {
	}
	else if (node._typ == 240 /* v.ast.CTempVar */) {
		v__markused__Walker_expr(w, (*node._v__ast__CTempVar).orig);
	}
	else if (node._typ == 245 /* v.ast.Comment */) {
	}
	else if (node._typ == 251 /* v.ast.EnumVal */) {
	}
	else if (node._typ == 261 /* v.ast.LockExpr */) {
		v__markused__Walker_stmts(w, (*node._v__ast__LockExpr).stmts);
	}
	else if (node._typ == 266 /* v.ast.OffsetOf */) {
	}
	else if (node._typ == 267 /* v.ast.OrExpr */) {
		v__markused__Walker_or_block(w, (*node._v__ast__OrExpr));
	}
	else if (node._typ == 272 /* v.ast.SelectExpr */) {
		// FOR IN array
		for (int _t3252 = 0; _t3252 < (*node._v__ast__SelectExpr).branches.len; ++_t3252) {
			v__ast__SelectBranch branch = ((v__ast__SelectBranch*)(*node._v__ast__SelectExpr).branches.data)[_t3252];
			v__markused__Walker_stmt(w, branch.stmt);
			v__markused__Walker_stmts(w, branch.stmts);
		}
	}
	else if (node._typ == 279 /* v.ast.TypeNode */) {
	}
	else if (node._typ == 281 /* v.ast.UnsafeExpr */) {
		v__markused__Walker_expr(w, (*node._v__ast__UnsafeExpr).expr);
	}
	else if (node._typ == 264 /* v.ast.NodeError */) {
	};
}

void v__markused__Walker_fn_decl(v__markused__Walker* w, v__ast__FnDecl* node) {
	if (node->language == v__ast__Language_c) {
		return;
	}
	string fkey = (node->is_method ? (_STR("%"PRId32"\000.%.*s", 2, ((int)(node->receiver.typ)), node->name)) : (node->name));
	if ((*(bool*)map_get(ADDR(map, w->used_fns), &(string[]){fkey}, &(bool[]){ 0 }))) {
		return;
	}
	v__markused__Walker_mark_fn_as_used(w, fkey);
	v__markused__Walker_stmts(w, node->stmts);
	v__markused__Walker_defer_stmts(w, node->defer_stmts);
}

void v__markused__Walker_call_expr(v__markused__Walker* w, v__ast__CallExpr* node) {
	// FOR IN array
	for (int _t3253 = 0; _t3253 < node->args.len; ++_t3253) {
		v__ast__CallArg arg = ((v__ast__CallArg*)node->args.data)[_t3253];
		v__markused__Walker_expr(w, arg.expr);
	}
	if (node->language == v__ast__Language_c) {
		return;
	}
	v__markused__Walker_expr(w, node->left);
	v__markused__Walker_or_block(w, node->or_block);
	string fn_name = (node->is_method ? (string_add(string_add(int_str(node->receiver_type), _SLIT(".")), node->name)) : (node->name));
	if ((*(bool*)map_get(ADDR(map, w->used_fns), &(string[]){fn_name}, &(bool[]){ 0 }))) {
		return;
	}
	v__markused__Walker_mark_fn_as_used(w, fn_name);
	v__ast__FnDecl* _t3255 = (v__ast__FnDecl*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, w->all_fns), &(string[]){fn_name}));
	Option_v__ast__FnDecl _t3254 = {0};
	if (_t3255) {
		*((v__ast__FnDecl*)&_t3254.data) = *((v__ast__FnDecl*)_t3255);
	} else {
		_t3254.state = 2; _t3254.err = v_error(_SLIT("array index out of range"));
	}
	;
	if (_t3254.state != 0) { /*or block*/ 
		IError err = _t3254.err;
		return;
	}
	v__ast__FnDecl stmt = *(v__ast__FnDecl*)_t3254.data;
	if (string_eq(stmt.name, node->name)) {
		if (!node->is_method || (v__ast__Type_alias_eq(node->receiver_type, stmt.receiver.typ))) {
			v__markused__Walker_stmts(w, stmt.stmts);
		}
	}
}

void v__markused__Walker_fn_by_name(v__markused__Walker* w, string fn_name) {
	if ((*(bool*)map_get(ADDR(map, w->used_fns), &(string[]){fn_name}, &(bool[]){ 0 }))) {
		return;
	}
	v__ast__FnDecl* _t3257 = (v__ast__FnDecl*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, w->all_fns), &(string[]){fn_name}));
	Option_v__ast__FnDecl _t3256 = {0};
	if (_t3257) {
		*((v__ast__FnDecl*)&_t3256.data) = *((v__ast__FnDecl*)_t3257);
	} else {
		_t3256.state = 2; _t3256.err = v_error(_SLIT("array index out of range"));
	}
	;
	if (_t3256.state != 0) { /*or block*/ 
		IError err = _t3256.err;
		return;
	}
	v__ast__FnDecl stmt = *(v__ast__FnDecl*)_t3256.data;
	v__markused__Walker_mark_fn_as_used(w, fn_name);
	v__markused__Walker_stmts(w, stmt.stmts);
}

void v__markused__Walker_struct_fields(v__markused__Walker* w, Array_v__ast__StructField sfields) {
	// FOR IN array
	for (int _t3258 = 0; _t3258 < sfields.len; ++_t3258) {
		v__ast__StructField sf = ((v__ast__StructField*)sfields.data)[_t3258];
		if (sf.has_default_expr) {
			v__markused__Walker_expr(w, sf.default_expr);
		}
	}
}

void v__markused__Walker_const_fields(v__markused__Walker* w, Array_v__ast__ConstField cfields) {
	// FOR IN array
	for (int _t3259 = 0; _t3259 < cfields.len; ++_t3259) {
		v__ast__ConstField cf = ((v__ast__ConstField*)cfields.data)[_t3259];
		v__markused__Walker_expr(w, cf.expr);
	}
}

void v__markused__Walker_or_block(v__markused__Walker* w, v__ast__OrExpr node) {
	if (node.kind == v__ast__OrKind_block) {
		v__markused__Walker_stmts(w, node.stmts);
	}
}

VV_LOCAL_SYMBOL string v__gen__js__JsGen_to_js_typ_def_val(v__gen__js__JsGen* g, string s) {
	string dval = _SLIT("");

	if (string_eq(s, _SLIT("JS.Number"))) {
		dval = _SLIT("0");
	}
	else if (string_eq(s, _SLIT("JS.String"))) {
		dval = _SLIT("\"\"");
	}
	else if (string_eq(s, _SLIT("JS.Boolean"))) {
		dval = _SLIT("false");
	}
	else if (string_eq(s, _SLIT("JS.Array")) || string_eq(s, _SLIT("JS.Map"))) {
		dval = _SLIT("");
	}
	else {
		dval = _SLIT("{}");
	};
	// autofree_scope_vars(pos=262 line_nr=13 scope.pos=28 scope.end_pos=275)
	// var "g" var.pos=33 var.line_nr=4
	// var "s" var.pos=60 var.line_nr=4
	// var "dval" var.pos=84 var.line_nr=5
	// str literal
	// af parent scope:
	// af parent scope:
	return dval;
}

VV_LOCAL_SYMBOL string v__gen__js__JsGen_to_js_typ_val(v__gen__js__JsGen* g, v__ast__Type t) {
	v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, t);
	string styp = _SLIT("");
	string prefix = (string_eq(g->file.mod.name, _SLIT("builtin")) ? (_SLIT("new ")) : (_SLIT("")));

	if (sym->kind == (v__ast__Kind_i8) || sym->kind == (v__ast__Kind_i16) || sym->kind == (v__ast__Kind_int) || sym->kind == (v__ast__Kind_i64) || sym->kind == (v__ast__Kind_byte) || sym->kind == (v__ast__Kind_u16) || sym->kind == (v__ast__Kind_u32) || sym->kind == (v__ast__Kind_u64) || sym->kind == (v__ast__Kind_f32) || sym->kind == (v__ast__Kind_f64) || sym->kind == (v__ast__Kind_int_literal) || sym->kind == (v__ast__Kind_float_literal) || sym->kind == (v__ast__Kind_size_t)) {
		styp = _STR("%.*s\000%.*s\000(0)", 3, prefix, v__gen__js__JsGen_sym_to_js_typ(g, *sym));
	}
	else if (sym->kind == (v__ast__Kind_bool)) {
		styp = _STR("%.*s\000%.*s\000(false)", 3, prefix, v__gen__js__JsGen_sym_to_js_typ(g, *sym));
	}
	else if (sym->kind == (v__ast__Kind_string)) {
		styp = _STR("%.*s\000%.*s\000(\"\")", 3, prefix, v__gen__js__JsGen_sym_to_js_typ(g, *sym));
	}
	else if (sym->kind == (v__ast__Kind_map)) {
		styp = _SLIT("new Map()");
	}
	else if (sym->kind == (v__ast__Kind_array)) {
		styp = _STR("%.*s\000%.*s\000()", 3, prefix, v__gen__js__JsGen_sym_to_js_typ(g, *sym));
	}
	else if (sym->kind == (v__ast__Kind_struct_)) {
		styp = _STR("new %.*s\000(%.*s\000)", 3, v__gen__js__JsGen_js_name(g, sym->name), v__gen__js__JsGen_to_js_typ_def_val(g, sym->name));
	}
	else {
		styp = _SLIT("undefined");
	};
	// autofree_scope_vars(pos=984 line_nr=45 scope.pos=281 scope.end_pos=997)
	// var "g" var.pos=286 var.line_nr=16
	// var "t" var.pos=309 var.line_nr=16
	// var "sym" var.pos=331 var.line_nr=17
	// var "styp" var.pos=370 var.line_nr=18
	// str literal
	// var "prefix" var.pos=386 var.line_nr=19
	// af parent scope:
	// af parent scope:
	return styp;
}

VV_LOCAL_SYMBOL string v__gen__js__JsGen_sym_to_js_typ(v__gen__js__JsGen* g, v__ast__TypeSymbol sym) {
	string styp = _SLIT("");

	if (sym.kind == (v__ast__Kind_i8)) {
		styp = _SLIT("i8");
	}
	else if (sym.kind == (v__ast__Kind_i16)) {
		styp = _SLIT("i16");
	}
	else if (sym.kind == (v__ast__Kind_int)) {
		styp = _SLIT("int");
	}
	else if (sym.kind == (v__ast__Kind_i64)) {
		styp = _SLIT("i64");
	}
	else if (sym.kind == (v__ast__Kind_byte)) {
		styp = _SLIT("byte");
	}
	else if (sym.kind == (v__ast__Kind_u16)) {
		styp = _SLIT("u16");
	}
	else if (sym.kind == (v__ast__Kind_u32)) {
		styp = _SLIT("u32");
	}
	else if (sym.kind == (v__ast__Kind_u64)) {
		styp = _SLIT("u64");
	}
	else if (sym.kind == (v__ast__Kind_f32)) {
		styp = _SLIT("f32");
	}
	else if (sym.kind == (v__ast__Kind_f64)) {
		styp = _SLIT("f64");
	}
	else if (sym.kind == (v__ast__Kind_int_literal)) {
		styp = _SLIT("int_literal");
	}
	else if (sym.kind == (v__ast__Kind_float_literal)) {
		styp = _SLIT("float_literal");
	}
	else if (sym.kind == (v__ast__Kind_size_t)) {
		styp = _SLIT("size_t");
	}
	else if (sym.kind == (v__ast__Kind_bool)) {
		styp = _SLIT("bool");
	}
	else if (sym.kind == (v__ast__Kind_string)) {
		styp = _SLIT("string");
	}
	else if (sym.kind == (v__ast__Kind_map)) {
		styp = _SLIT("map");
	}
	else if (sym.kind == (v__ast__Kind_array)) {
		styp = _SLIT("array");
	}
	else {
		styp = _SLIT("undefined");
	};
	// autofree_scope_vars(pos=1690 line_nr=107 scope.pos=1003 scope.end_pos=1703)
	// var "g" var.pos=1008 var.line_nr=48
	// var "sym" var.pos=1031 var.line_nr=48
	// var "styp" var.pos=1065 var.line_nr=49
	// str literal
	// af parent scope:
	// af parent scope:
	return styp;
}

string v__gen__js__JsGen_typ(v__gen__js__JsGen* g, v__ast__Type t) {
	v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, t);
	string styp = _SLIT("");

	if (sym->kind == (v__ast__Kind_placeholder)) {
		styp = _SLIT("any");
	}
	else if (sym->kind == (v__ast__Kind_void)) {
		styp = _SLIT("void");
	}
	else if (sym->kind == (v__ast__Kind_voidptr)) {
		styp = _SLIT("any");
	}
	else if (sym->kind == (v__ast__Kind_byteptr) || sym->kind == (v__ast__Kind_charptr)) {
		styp = _STR("%.*s", 1, v__gen__js__JsGen_sym_to_js_typ(g, *sym));
	}
	else if (sym->kind == (v__ast__Kind_i8) || sym->kind == (v__ast__Kind_i16) || sym->kind == (v__ast__Kind_int) || sym->kind == (v__ast__Kind_i64) || sym->kind == (v__ast__Kind_byte) || sym->kind == (v__ast__Kind_u16) || sym->kind == (v__ast__Kind_u32) || sym->kind == (v__ast__Kind_u64) || sym->kind == (v__ast__Kind_f32) || sym->kind == (v__ast__Kind_f64) || sym->kind == (v__ast__Kind_int_literal) || sym->kind == (v__ast__Kind_float_literal) || sym->kind == (v__ast__Kind_size_t)) {
		styp = _STR("%.*s", 1, v__gen__js__JsGen_sym_to_js_typ(g, *sym));
	}
	else if (sym->kind == (v__ast__Kind_bool)) {
		styp = _STR("%.*s", 1, v__gen__js__JsGen_sym_to_js_typ(g, *sym));
	}
	else if (sym->kind == (v__ast__Kind_none_)) {
		styp = _SLIT("undefined");
	}
	else if (sym->kind == (v__ast__Kind_string) || sym->kind == (v__ast__Kind_ustring) || sym->kind == (v__ast__Kind_char)) {
		styp = _STR("%.*s", 1, v__gen__js__JsGen_sym_to_js_typ(g, *sym));
	}
	else if (sym->kind == (v__ast__Kind_array)) {
		v__ast__Array info = /* as */ *(v__ast__Array*)__as_cast((sym->info)._v__ast__Array,(sym->info)._typ, 395) /*expected idx: 395, name: v.ast.Array */ ;
		styp = _STR("%.*s\000(%.*s\000)", 3, v__gen__js__JsGen_sym_to_js_typ(g, *sym), v__gen__js__JsGen_typ(g, info.elem_type));
	}
	else if (sym->kind == (v__ast__Kind_array_fixed)) {
		v__ast__ArrayFixed info = /* as */ *(v__ast__ArrayFixed*)__as_cast((sym->info)._v__ast__ArrayFixed,(sym->info)._typ, 416) /*expected idx: 416, name: v.ast.ArrayFixed */ ;
		styp = _STR("%.*s\000(%.*s\000)", 3, v__gen__js__JsGen_sym_to_js_typ(g, *sym), v__gen__js__JsGen_typ(g, info.elem_type));
	}
	else if (sym->kind == (v__ast__Kind_chan)) {
		styp = _SLIT("chan");
	}
	else if (sym->kind == (v__ast__Kind_map)) {
		v__ast__Map info = /* as */ *(v__ast__Map*)__as_cast((sym->info)._v__ast__Map,(sym->info)._typ, 396) /*expected idx: 396, name: v.ast.Map */ ;
		string key = v__gen__js__JsGen_typ(g, info.key_type);
		string val = v__gen__js__JsGen_typ(g, info.value_type);
		styp = _STR("Map<%.*s\000, %.*s\000>", 3, key, val);
	}
	else if (sym->kind == (v__ast__Kind_any)) {
		styp = _SLIT("any");
	}
	else if (sym->kind == (v__ast__Kind_struct_)) {
		styp = v__gen__js__JsGen_struct_typ(g, sym->name);
	}
	else if (sym->kind == (v__ast__Kind_generic_struct_inst)) {
	}
	else if (sym->kind == (v__ast__Kind_multi_return)) {
		v__ast__MultiReturn info = /* as */ *(v__ast__MultiReturn*)__as_cast((sym->info)._v__ast__MultiReturn,(sym->info)._typ, 417) /*expected idx: 417, name: v.ast.MultiReturn */ ;
		Array_v__ast__Type _t3260_orig = info.types;
		int _t3260_len = _t3260_orig.len;
		Array_string _t3260 = __new_array(0, _t3260_len, sizeof(string));

		for (int _t3261 = 0; _t3261 < _t3260_len; ++_t3261) {
			v__ast__Type it = ((v__ast__Type*) _t3260_orig.data)[_t3261];
			string ti = v__gen__js__JsGen_typ(g, it);
			array_push(&_t3260, &ti);
		}
		
		Array_string types = _t3260;
		string joined = Array_string_join(types, _SLIT(", "));
		styp = _STR("[%.*s\000]", 2, joined);
	}
	else if (sym->kind == (v__ast__Kind_sum_type)) {
		styp = _SLIT("union_sym_type");
	}
	else if (sym->kind == (v__ast__Kind_alias)) {
		styp = _SLIT("alias");
	}
	else if (sym->kind == (v__ast__Kind_enum_)) {
		styp = _SLIT("number");
	}
	else if (sym->kind == (v__ast__Kind_function)) {
		v__ast__FnType info = /* as */ *(v__ast__FnType*)__as_cast((sym->info)._v__ast__FnType,(sym->info)._typ, 418) /*expected idx: 418, name: v.ast.FnType */ ;
		styp = v__gen__js__JsGen_fn_typ(g, info.func.params, info.func.return_type);
	}
	else if (sym->kind == (v__ast__Kind_interface_)) {
		styp = v__gen__js__JsGen_js_name(g, sym->name);
	}
	else if (sym->kind == (v__ast__Kind_rune)) {
		styp = _SLIT("any");
	}
	else if (sym->kind == (v__ast__Kind_aggregate)) {
		v_panic(_SLIT("TODO: unhandled aggregate in JS"));
	}
	else if (sym->kind == (v__ast__Kind_thread)) {
		v_panic(_SLIT("TODO: unhandled thread in JS"));
	};
	if (string_starts_with(styp, _SLIT("JS."))) {
		 string _t3262 = string_substr(styp, 3, styp.len);
		// autofree_scope_vars(pos=4132 line_nr=215 scope.pos=4129 scope.end_pos=4151)
		// af parent scope:
		// var "g" var.pos=1739 var.line_nr=111
		// var "t" var.pos=1752 var.line_nr=111
		// var "sym" var.pos=1774 var.line_nr=112
		// var "styp" var.pos=1813 var.line_nr=113
		// str literal
		// af parent scope:
		// af parent scope:
		return _t3262;
	}
	// autofree_scope_vars(pos=4153 line_nr=217 scope.pos=1734 scope.end_pos=4166)
	// var "g" var.pos=1739 var.line_nr=111
	// var "t" var.pos=1752 var.line_nr=111
	// var "sym" var.pos=1774 var.line_nr=112
	// var "styp" var.pos=1813 var.line_nr=113
	// str literal
	// af parent scope:
	// af parent scope:
	return styp;
}

VV_LOCAL_SYMBOL string v__gen__js__JsGen_fn_typ(v__gen__js__JsGen* g, Array_v__ast__Param args, v__ast__Type return_type) {
	string res = _SLIT("(");
	// FOR IN array
	for (int i = 0; i < args.len; ++i) {
		v__ast__Param arg = ((v__ast__Param*)args.data)[i];
		res = /*f*/string_add(res, _STR("%.*s\000: %.*s", 2, arg.name, v__gen__js__JsGen_typ(g, arg.typ)));
		if (i < args.len - 1) {
			res = /*f*/string_add(res, _SLIT(", "));
		}
	}
	 string _t3263 = string_add(string_add(res, _SLIT(") => ")), v__gen__js__JsGen_typ(g, return_type));
	// autofree_scope_vars(pos=4366 line_nr=228 scope.pos=4172 scope.end_pos=4409)
	// var "g" var.pos=4177 var.line_nr=220
	// var "args" var.pos=4193 var.line_nr=220
	// var "return_type" var.pos=4211 var.line_nr=220
	// var "res" var.pos=4247 var.line_nr=221
	// str literal
	// af parent scope:
	// af parent scope:
	return _t3263;
}

VV_LOCAL_SYMBOL string v__gen__js__JsGen_struct_typ(v__gen__js__JsGen* g, string s) {
	string ns = v__gen__js__get_ns(s);
	if (string_eq(ns, _SLIT("JS"))) {
		 string _t3264 = string_substr(s, 3, s.len);
		// autofree_scope_vars(pos=4494 line_nr=234 scope.pos=4491 scope.end_pos=4510)
		// af parent scope:
		// var "g" var.pos=4420 var.line_nr=231
		// var "s" var.pos=4440 var.line_nr=231
		// var "ns" var.pos=4460 var.line_nr=232
		// var "name" var.pos=4517 var.line_nr=236
		// var "styp" var.pos=4597 var.line_nr=237
		// af parent scope:
		// af parent scope:
		return _t3264;
	}
	string _t3265; /* if prepend */
	if (string_eq(ns, g->ns->name)) {
		_t3265 = (*(string*)array_last(string_split(s, _SLIT("."))));
	} else {
		_t3265 = v__gen__js__JsGen_get_alias(g, s);
	}
	string name =  _t3265;
	string styp = _SLIT("");
	// FOR IN array
	Array_string _t3266 = string_split(name, _SLIT("."));
	for (int i = 0; i < _t3266.len; ++i) {
		string v = ((string*)_t3266.data)[i];
		if (i == 0) {
			styp = v;
		} else {
			styp = /*f*/string_add(styp, _STR("[\"%.*s\000\"]", 2, v));
		}
	}
	if ((string_eq(ns, _SLIT("")) || string_eq(ns, g->ns->name))) {
		// autofree_scope_vars(pos=4732 line_nr=246 scope.pos=4729 scope.end_pos=4746)
		// af parent scope:
		// var "g" var.pos=4420 var.line_nr=231
		// var "s" var.pos=4440 var.line_nr=231
		// var "ns" var.pos=4460 var.line_nr=232
		// var "name" var.pos=4517 var.line_nr=236
		// var "styp" var.pos=4597 var.line_nr=237
		// str literal
		// af parent scope:
		// af parent scope:
		return styp;
	}
	 string _t3267 = string_add(styp, _SLIT("[\"prototype\"]"));
	// autofree_scope_vars(pos=4748 line_nr=248 scope.pos=4415 scope.end_pos=4779)
	// var "g" var.pos=4420 var.line_nr=231
	// var "s" var.pos=4440 var.line_nr=231
	// var "ns" var.pos=4460 var.line_nr=232
	// var "name" var.pos=4517 var.line_nr=236
	// var "styp" var.pos=4597 var.line_nr=237
	// str literal
	// af parent scope:
	// af parent scope:
	return _t3267;
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_builtin_prototype(v__gen__js__JsGen* g, v__gen__js__BuiltinPrototypeConfig c) {
	v__gen__js__JsGen_writeln(g, _STR("function %.*s\000(%.*s\000 = %.*s\000) { %.*s\000 }", 5, c.typ_name, c.val_name, c.default_value, c.constructor));
	v__gen__js__JsGen_writeln(g, _STR("%.*s\000.prototype = {", 2, c.typ_name));
	v__gen__js__JsGen_inc_indent(g);
	v__gen__js__JsGen_writeln(g, _STR("%.*s\000: %.*s\000,", 3, c.val_name, c.default_value));
	if (c.extras.len > 0) {
		v__gen__js__JsGen_writeln(g, _STR("%.*s\000,", 2, c.extras));
	}
	// FOR IN array
	Array_v__ast__FnDecl _t3268 = (*(Array_v__ast__FnDecl*)map_get(ADDR(map, g->method_fn_decls), &(string[]){c.typ_name}, &(Array_v__ast__FnDecl[]){ __new_array(0, 1, sizeof(v__ast__FnDecl)) }));
	for (int _t3269 = 0; _t3269 < _t3268.len; ++_t3269) {
		v__ast__FnDecl method = ((v__ast__FnDecl*)_t3268.data)[_t3269];
		g->inside_def_typ_decl = true;
		v__gen__js__JsGen_gen_method_decl(g, method);
		g->inside_def_typ_decl = false;
		v__gen__js__JsGen_writeln(g, _SLIT(","));
	}
	v__gen__js__JsGen_writeln(g, _STR("valueOf() { return %.*s\000 },", 2, c.value_of));
	v__gen__js__JsGen_writeln(g, _STR("toString() { return %.*s\000 },", 2, c.to_string));
	v__gen__js__JsGen_writeln(g, _STR("eq(other) { return %.*s\000 },", 2, c.eq));
	if (c.has_strfn) {
		v__gen__js__JsGen_writeln(g, _SLIT("str() { return new string(this.toString()) }"));
	}
	v__gen__js__JsGen_dec_indent(g);
	v__gen__js__JsGen_writeln(g, _SLIT("};\n"));
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_builtin_type_defs(v__gen__js__JsGen* g) {
	v__gen__js__JsGen_inc_indent(g);
	// FOR IN array
	for (int _t3270 = 0; _t3270 < _const_v__gen__js__v_types.len; ++_t3270) {
		string typ_name = ((string*)_const_v__gen__js__v_types.data)[_t3270];

		if (string_eq(typ_name, _SLIT("i8")) || string_eq(typ_name, _SLIT("i16")) || string_eq(typ_name, _SLIT("int")) || string_eq(typ_name, _SLIT("i64")) || string_eq(typ_name, _SLIT("u16")) || string_eq(typ_name, _SLIT("u32")) || string_eq(typ_name, _SLIT("u64")) || string_eq(typ_name, _SLIT("int_literal")) || string_eq(typ_name, _SLIT("size_t"))) {
			v__gen__js__JsGen_gen_builtin_prototype(g, (v__gen__js__BuiltinPrototypeConfig){
				.typ_name = typ_name,
				.val_name = _SLIT("val"),
				.default_value = _SLIT("new Number(0)"),
				.constructor = _SLIT("this.val = val | 0"),
				.value_of = _SLIT("this.val | 0"),
				.to_string = _SLIT("this.valueOf().toString()"),
				.eq = _SLIT("this.valueOf() === other.valueOf()"),
				.extras = (string){.str=(byteptr)"", .is_lit=1},
				.has_strfn = 0,
			});
		}
		else if (string_eq(typ_name, _SLIT("byte"))) {
			v__gen__js__JsGen_gen_builtin_prototype(g, (v__gen__js__BuiltinPrototypeConfig){
				.typ_name = typ_name,
				.val_name = _SLIT("val"),
				.default_value = _SLIT("new Number(0)"),
				.constructor = _SLIT("this.val = typeof(val) == \"string\" ? val.charCodeAt() : (val | 0)"),
				.value_of = _SLIT("this.val | 0"),
				.to_string = _SLIT("String.fromCharCode(this.val)"),
				.eq = _SLIT("this.valueOf() === other.valueOf()"),
				.extras = (string){.str=(byteptr)"", .is_lit=1},
				.has_strfn = 0,
			});
		}
		else if (string_eq(typ_name, _SLIT("f32")) || string_eq(typ_name, _SLIT("f64")) || string_eq(typ_name, _SLIT("float_literal"))) {
			v__gen__js__JsGen_gen_builtin_prototype(g, (v__gen__js__BuiltinPrototypeConfig){.typ_name = typ_name,.val_name = _SLIT("val"),.default_value = _SLIT("new Number(0)"),.constructor = _SLIT("this.val = val"),.value_of = _SLIT("this.val"),.to_string = _SLIT("this.val.toString()"),.eq = _SLIT("this.val === other.val"),.extras = (string){.str=(byteptr)"", .is_lit=1},.has_strfn = 0,});
		}
		else if (string_eq(typ_name, _SLIT("bool"))) {
			v__gen__js__JsGen_gen_builtin_prototype(g, (v__gen__js__BuiltinPrototypeConfig){.typ_name = typ_name,.val_name = _SLIT("val"),.default_value = _SLIT("new Boolean(false)"),.constructor = _SLIT("this.val = val"),.value_of = _SLIT("this.val"),.to_string = _SLIT("this.val.toString()"),.eq = _SLIT("this.val === other.val"),.extras = (string){.str=(byteptr)"", .is_lit=1},.has_strfn = 0,});
		}
		else if (string_eq(typ_name, _SLIT("string"))) {
			v__gen__js__JsGen_gen_builtin_prototype(g, (v__gen__js__BuiltinPrototypeConfig){
				.typ_name = typ_name,
				.val_name = _SLIT("str"),
				.default_value = _SLIT("new String(\"\")"),
				.constructor = _SLIT("this.str = str.toString(); this.len = this.str.length"),
				.value_of = _SLIT("this.str"),
				.to_string = _SLIT("this.str"),
				.eq = _SLIT("this.str === other.str"),
				.extras = (string){.str=(byteptr)"", .is_lit=1},
				.has_strfn = false,
			});
		}
		else if (string_eq(typ_name, _SLIT("map"))) {
			v__gen__js__JsGen_gen_builtin_prototype(g, (v__gen__js__BuiltinPrototypeConfig){
				.typ_name = typ_name,
				.val_name = _SLIT("map"),
				.default_value = _SLIT("new Map()"),
				.constructor = _SLIT("this.map = map"),
				.value_of = _SLIT("this.map"),
				.to_string = _SLIT("this.map.toString()"),
				.eq = _SLIT("vEq(this, other)"),
				.extras = (string){.str=(byteptr)"", .is_lit=1},
				.has_strfn = 0,
			});
		}
		else if (string_eq(typ_name, _SLIT("array"))) {
			v__gen__js__JsGen_gen_builtin_prototype(g, (v__gen__js__BuiltinPrototypeConfig){
				.typ_name = typ_name,
				.val_name = _SLIT("arr"),
				.default_value = _SLIT("new Array()"),
				.constructor = _SLIT("this.arr = arr"),
				.value_of = _SLIT("this.arr"),
				.to_string = _SLIT("JSON.stringify(this.arr.map(it => it.valueOf()))"),
				.eq = _SLIT("vEq(this, other)"),
				.extras = (string){.str=(byteptr)"", .is_lit=1},
				.has_strfn = 0,
			});
		}
		else {
		};
	}
	v__gen__js__JsGen_dec_indent(g);
}

string v__gen__js__gen(Array_v__ast__File files, v__ast__Table* table, v__pref__Preferences* pref) {
	v__gen__js__JsGen* g = (v__gen__js__JsGen*)memdup(&(v__gen__js__JsGen){.table = table,
		.pref = pref,
		.definitions = strings__new_builder(100),
		.ns = 0,
		.namespaces = new_map(sizeof(string), sizeof(v__gen__js__Namespace*), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.doc = 0,
		.enable_doc = true,
		.file = (v__ast__File){.stmts = __new_array(0, 1, sizeof(v__ast__Stmt)),.imports = __new_array(0, 1, sizeof(v__ast__Import)),.auto_imports = __new_array(0, 1, sizeof(string)),.embedded_files = __new_array(0, 1, sizeof(v__ast__EmbeddedFile)),.imported_symbols = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.errors = __new_array(0, 1, sizeof(v__errors__Error)),.warnings = __new_array(0, 1, sizeof(v__errors__Warning)),.notices = __new_array(0, 1, sizeof(v__errors__Notice)),.generic_fns = __new_array(0, 1, sizeof(v__ast__FnDecl*)),.global_labels = __new_array(0, 1, sizeof(string)),},
		.tmp_count = 0,
		.inside_ternary = 0,
		.inside_loop = 0,
		.inside_map_set = 0,
		.inside_builtin = 0,
		.generated_builtin = 0,
		.inside_def_typ_decl = 0,
		.is_test = 0,
		.stmt_start_pos = 0,
		.defer_stmts = __new_array(0, 1, sizeof(v__ast__DeferStmt)),
		.fn_decl = 0,
		.str_types = __new_array(0, 1, sizeof(string)),
		.method_fn_decls = new_map(sizeof(string), sizeof(Array_v__ast__FnDecl), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.builtin_fns = __new_array(0, 1, sizeof(string)),
		.empty_line = true,
		.cast_stack = __new_array(0, 1, sizeof(v__ast__Type)),
		.call_stack = __new_array(0, 1, sizeof(v__ast__CallExpr)),
	}, sizeof(v__gen__js__JsGen));
	g->doc = v__gen__js__new_jsdoc(g);
	if (pref->is_prod) {
		g->enable_doc = false;
	}
	v__gen__js__JsGen_init(g);
	v__depgraph__DepGraph* graph = v__depgraph__new_dep_graph();
	// FOR IN array
	for (int _t3271 = 0; _t3271 < files.len; ++_t3271) {
		v__ast__File file = ((v__ast__File*)files.data)[_t3271];
		g->file = file;
		v__gen__js__JsGen_enter_namespace(g, g->file.mod.name);
		g->is_test = g->pref->is_test;
		v__gen__js__JsGen_find_class_methods(g, file.stmts);
		v__gen__js__JsGen_escape_namespace(g);
	}
	// FOR IN array
	for (int _t3272 = 0; _t3272 < files.len; ++_t3272) {
		v__ast__File file = ((v__ast__File*)files.data)[_t3272];
		g->file = file;
		v__gen__js__JsGen_enter_namespace(g, g->file.mod.name);
		g->is_test = g->pref->is_test;
		Array_string imports = __new_array_with_default(0, 0, sizeof(string), 0);
		// FOR IN array
		for (int _t3273 = 0; _t3273 < g->file.imports.len; ++_t3273) {
			v__ast__Import imp = ((v__ast__Import*)g->file.imports.data)[_t3273];
			array_push(&imports, _MOV((string[]){ string_clone(imp.mod) }));
		}
		v__depgraph__DepGraph_add(graph, g->file.mod.name, imports);
		if (string_eq(g->file.mod.name, _SLIT("builtin")) && !g->generated_builtin) {
			v__gen__js__JsGen_gen_builtin_type_defs(g);
			g->generated_builtin = true;
		}
		v__gen__js__JsGen_stmts(g, file.stmts);
		v__gen__js__JsGen_escape_namespace(g);
	}
	v__depgraph__DepGraph* deps_resolved = v__depgraph__DepGraph_resolve(graph);
	Array_v__depgraph__DepGraphNode nodes = deps_resolved->nodes;
	string out = string_add(v__gen__js__JsGen_hashes(g), strings__Builder_str(&g->definitions));
	out = /*f*/string_add(out, _const_v__gen__js__fast_deep_eq_fn);
	// FOR IN array
	for (int _t3275 = 0; _t3275 < nodes.len; ++_t3275) {
		v__depgraph__DepGraphNode node = ((v__depgraph__DepGraphNode*)nodes.data)[_t3275];
		string name = string_replace(v__gen__js__JsGen_js_name(g, node.name), _SLIT("."), _SLIT("_"));
		if (g->enable_doc) {
			out = /*f*/string_add(out, _STR("/** @namespace %.*s\000 */\n", 2, name));
		}
		out = /*f*/string_add(out, _STR("const %.*s\000 = (function (", 2, name));
		v__gen__js__Namespace* v_namespace = (*(v__gen__js__Namespace**)map_get(ADDR(map, g->namespaces), &(string[]){node.name}, &(v__gen__js__Namespace*[]){ 0 }));
		bool first = true;
		// FOR IN map
		Map_string_string _t3276 = v_namespace->imports;
		int _t3278 = _t3276.key_values.len;
		for (int _t3277 = 0; _t3277 < _t3278; ++_t3277 ) {
			int _t3279 = _t3276.key_values.len - _t3278;
			_t3278 = _t3276.key_values.len;
			if (_t3279 < 0) {
				_t3277 = -1;
				continue;
			}
			if (!DenseArray_has_index(&_t3276.key_values, _t3277)) {continue;}
			string val = (*(string*)DenseArray_value(&_t3276.key_values, _t3277));
			if (!first) {
				out = /*f*/string_add(out, _SLIT(", "));
			}
			first = false;
			out = /*f*/string_add(out, val);
		}
		out = /*f*/string_add(out, _SLIT(") {\n\t"));
		out = /*f*/string_add(out, string_trim_space(strings__Builder_str(&v_namespace->out)));
		out = /*f*/string_add(out, _SLIT("\n"));
		if (g->enable_doc) {
			out = /*f*/string_add(out, _SLIT("\n\t/* module exports */"));
		}
		out = /*f*/string_add(out, _SLIT("\n\treturn {"));
		if (string_eq(name, _SLIT("builtin"))) {
			// FOR IN array
			for (int _t3280 = 0; _t3280 < _const_v__gen__js__v_types.len; ++_t3280) {
				string typ = ((string*)_const_v__gen__js__v_types.data)[_t3280];
				out = /*f*/string_add(out, _STR("\n\t\t%.*s\000,", 2, typ));
			}
		}
		// FOR IN array
		for (int i = 0; i < v_namespace->pub_vars.len; ++i) {
			string pub_var = ((string*)v_namespace->pub_vars.data)[i];
			out = /*f*/string_add(out, _STR("\n\t\t%.*s", 1, pub_var));
			if (i < v_namespace->pub_vars.len - 1) {
				out = /*f*/string_add(out, _SLIT(","));
			}
		}
		if (v_namespace->pub_vars.len > 0) {
			out = /*f*/string_add(out, _SLIT("\n\t"));
		}
		out = /*f*/string_add(out, _SLIT("};"));
		out = /*f*/string_add(out, _SLIT("\n})("));
		first = true;
		// FOR IN map
		Map_string_string _t3281 = v_namespace->imports;
		int _t3283 = _t3281.key_values.len;
		for (int _t3282 = 0; _t3282 < _t3283; ++_t3282 ) {
			int _t3284 = _t3281.key_values.len - _t3283;
			_t3283 = _t3281.key_values.len;
			if (_t3284 < 0) {
				_t3282 = -1;
				continue;
			}
			if (!DenseArray_has_index(&_t3281.key_values, _t3282)) {continue;}
			string key = /*key*/ *(string*)DenseArray_key(&_t3281.key_values, _t3282);
			key = string_clone(key);
			if (!first) {
				out = /*f*/string_add(out, _SLIT(", "));
			}
			first = false;
			out = /*f*/string_add(out, string_replace(key, _SLIT("."), _SLIT("_")));
		}
		out = /*f*/string_add(out, _SLIT(");\n"));
		if (string_eq(name, _SLIT("builtin"))) {
			out = /*f*/string_add(out, _SLIT("// builtin type casts\n"));
			out = /*f*/string_add(out, _SLIT("const ["));
			// FOR IN array
			for (int i = 0; i < _const_v__gen__js__v_types.len; ++i) {
				string typ = ((string*)_const_v__gen__js__v_types.data)[i];
				if (i > 0) {
					out = /*f*/string_add(out, _SLIT(", "));
				}
				out = /*f*/string_add(out, _STR("%.*s", 1, typ));
			}
			out = /*f*/string_add(out, _SLIT("] = ["));
			// FOR IN array
			for (int i = 0; i < _const_v__gen__js__v_types.len; ++i) {
				string typ = ((string*)_const_v__gen__js__v_types.data)[i];
				if (i > 0) {
					out = /*f*/string_add(out, _SLIT(","));
				}
				out = /*f*/string_add(out, _STR("\n\tfunction(val) { return new builtin.%.*s\000(val) }", 2, typ));
			}
			out = /*f*/string_add(out, _SLIT("\n]\n"));
		}
	}
	if (pref->is_shared) {
		string v_export = (*(v__depgraph__DepGraphNode*)/*ee elem_typ */array_get(nodes, nodes.len - 1)).name;
		out = /*f*/string_add(out, _STR("if (typeof module === \"object\" && module.exports) module.exports = %.*s\000;\n", 2, v_export));
	}
	out = /*f*/string_add(out, _SLIT("\n"));
	// autofree_scope_vars(pos=5199 line_nr=195 scope.pos=2141 scope.end_pos=5211)
	// var "files" var.pos=2145 var.line_nr=63
	// var "table" var.pos=2163 var.line_nr=63
	// var "pref" var.pos=2181 var.line_nr=63
	// var "g" var.pos=2219 var.line_nr=64
	// var "graph" var.pos=2486 var.line_nr=80
	// var "deps_resolved" var.pos=3194 var.line_nr=109
	// var "nodes" var.pos=3228 var.line_nr=110
	// var "out" var.pos=3262 var.line_nr=111
	// af parent scope:
	// af parent scope:
	return out;
}

void v__gen__js__JsGen_enter_namespace(v__gen__js__JsGen* g, string name) {
	if ((*(v__gen__js__Namespace**)map_get(ADDR(map, g->namespaces), &(string[]){name}, &(v__gen__js__Namespace*[]){ 0 })) == 0) {
		v__gen__js__Namespace* ns = (v__gen__js__Namespace*)memdup(&(v__gen__js__Namespace){.name = name,.out = strings__new_builder(128),.pub_vars = __new_array(0, 1, sizeof(string)),.imports = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.indent = 0,.methods = new_map(sizeof(string), sizeof(Array_v__ast__FnDecl), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),}, sizeof(v__gen__js__Namespace));
		(*(v__gen__js__Namespace**)map_get_and_set(&g->namespaces, &(string[]){name}, &(v__gen__js__Namespace*[]){ 0 })) = ns;
		g->ns = ns;
	} else {
		g->ns = (*(v__gen__js__Namespace**)map_get(ADDR(map, g->namespaces), &(string[]){name}, &(v__gen__js__Namespace*[]){ 0 }));
	}
	g->inside_builtin = string_eq(name, _SLIT("builtin"));
}

void v__gen__js__JsGen_escape_namespace(v__gen__js__JsGen* g) {
	g->ns = ((v__gen__js__Namespace*)(0));
	g->inside_builtin = false;
}

void v__gen__js__JsGen_push_pub_var(v__gen__js__JsGen* g, string s) {
	array_push(&g->ns->pub_vars, _MOV((string[]){ string_clone(v__gen__js__JsGen_js_name(g, s)) }));
}

void v__gen__js__JsGen_find_class_methods(v__gen__js__JsGen* g, Array_v__ast__Stmt stmts) {
	// FOR IN array
	for (int _t3286 = 0; _t3286 < stmts.len; ++_t3286) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)stmts.data)[_t3286];
		if (stmt._typ == 175 /* v.ast.FnDecl */) {
			if ((*stmt._v__ast__FnDecl).is_method) {
				string class_name = v__ast__Table_get_type_name(g->table, (*stmt._v__ast__FnDecl).receiver.typ);
				Array_v__ast__FnDecl arr = (*(Array_v__ast__FnDecl*)map_get(ADDR(map, g->method_fn_decls), &(string[]){class_name}, &(Array_v__ast__FnDecl[]){ __new_array(0, 1, sizeof(v__ast__FnDecl)) }));
				array_push(&arr, _MOV((v__ast__FnDecl[]){ (*stmt._v__ast__FnDecl) }));
				map_set(&g->method_fn_decls, &(string[]){class_name}, &(Array_v__ast__FnDecl[]) { arr });
			}
		}
		else {
		};
	}
}

void v__gen__js__JsGen_init(v__gen__js__JsGen* g) {
	strings__Builder_writeln(&g->definitions, _SLIT("// Generated by the V compiler\n"));
	strings__Builder_writeln(&g->definitions, _SLIT("\"use strict\";"));
	strings__Builder_writeln(&g->definitions, _SLIT(""));
}

string v__gen__js__JsGen_hashes(v__gen__js__JsGen* g) {
	string res = _STR("// V_COMMIT_HASH %.*s\000\n", 2, v__util__vhash());
	res = /*f*/string_add(res, _STR("// V_CURRENT_COMMIT_HASH %.*s\000\n", 2, v__util__githash(g->pref->building_v)));
	// autofree_scope_vars(pos=6430 line_nr=248 scope.pos=6283 scope.end_pos=6442)
	// var "g" var.pos=6284 var.line_nr=245
	// var "res" var.pos=6316 var.line_nr=246
	// af parent scope:
	// af parent scope:
	return res;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL void v__gen__js__verror(string msg) {
	eprintln(_STR("jsgen error: %.*s", 1, msg));
	v_exit(1);
}

// Attr: [inline]
inline void v__gen__js__JsGen_gen_indent(v__gen__js__JsGen* g) {
	if (g->ns->indent > 0 && g->empty_line) {
		strings__Builder_write_string(&g->ns->out, v__util__tabs(g->ns->indent));
	}
	g->empty_line = false;
}

// Attr: [inline]
inline void v__gen__js__JsGen_inc_indent(v__gen__js__JsGen* g) {
	g->ns->indent++;
}

// Attr: [inline]
inline void v__gen__js__JsGen_dec_indent(v__gen__js__JsGen* g) {
	g->ns->indent--;
}

// Attr: [inline]
inline void v__gen__js__JsGen_write(v__gen__js__JsGen* g, string s) {
	if (g->ns == 0) {
		v__gen__js__verror(_SLIT("g.write: not in a namespace"));
	}
	v__gen__js__JsGen_gen_indent(g);
	strings__Builder_write_string(&g->ns->out, s);
}

// Attr: [inline]
inline void v__gen__js__JsGen_writeln(v__gen__js__JsGen* g, string s) {
	if (g->ns == 0) {
		v__gen__js__verror(_SLIT("g.writeln: not in a namespace"));
	}
	v__gen__js__JsGen_gen_indent(g);
	strings__Builder_writeln(&g->ns->out, s);
	g->empty_line = true;
}

// Attr: [inline]
inline string v__gen__js__JsGen_new_tmp_var(v__gen__js__JsGen* g) {
	g->tmp_count++;
	 string _t3288 = _STR("_tmp%"PRId32"", 1, g->tmp_count);
	// autofree_scope_vars(pos=7198 line_nr=297 scope.pos=7146 scope.end_pos=7225)
	// var "g" var.pos=7151 var.line_nr=295
	// af parent scope:
	// af parent scope:
	return _t3288;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL string v__gen__js__get_ns(string s) {
	Option_int _t3289 = string_last_index(s, _SLIT("."));
	if (_t3289.state != 0) { /*or block*/ 
		IError err = _t3289.err;
		 string _t3290 = _SLIT("");
		// autofree_scope_vars(pos=7343 line_nr=304 scope.pos=7342 scope.end_pos=7354)
		// var "err" var.pos=7342 var.line_nr=304
		// af parent scope:
		// var "s" var.pos=7294 var.line_nr=303
		// var "idx" var.pos=7314 var.line_nr=304
		// af parent scope:
		// af parent scope:
		return _t3290;
	}
 	int idx =  *(int*)_t3289.data;
	 string _t3291 = string_substr(s, 0, idx);
	// autofree_scope_vars(pos=7356 line_nr=305 scope.pos=7287 scope.end_pos=7381)
	// var "s" var.pos=7294 var.line_nr=303
	// var "idx" var.pos=7314 var.line_nr=304
	// af parent scope:
	// af parent scope:
	return _t3291;
}

VV_LOCAL_SYMBOL string v__gen__js__JsGen_get_alias(v__gen__js__JsGen* g, string name) {
	string ns = v__gen__js__get_ns(name);
	if ((ns).len == 0) {
		// autofree_scope_vars(pos=7469 line_nr=311 scope.pos=7466 scope.end_pos=7483)
		// af parent scope:
		// var "g" var.pos=7392 var.line_nr=308
		// var "name" var.pos=7411 var.line_nr=308
		// var "ns" var.pos=7434 var.line_nr=309
		// var "alias" var.pos=7486 var.line_nr=313
		// af parent scope:
		// af parent scope:
		return name;
	}
	string alias = (*(string*)map_get(ADDR(map, g->ns->imports), &(string[]){ns}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} }));
	if ((alias).len == 0) {
		// autofree_scope_vars(pos=7531 line_nr=315 scope.pos=7528 scope.end_pos=7545)
		// af parent scope:
		// var "g" var.pos=7392 var.line_nr=308
		// var "name" var.pos=7411 var.line_nr=308
		// var "ns" var.pos=7434 var.line_nr=309
		// var "alias" var.pos=7486 var.line_nr=313
		// af parent scope:
		// af parent scope:
		return name;
	}
	 string _t3292 = string_add(string_add(alias, _SLIT(".")), (*(string*)array_last(string_split(name, _SLIT(".")))));
	// autofree_scope_vars(pos=7547 line_nr=317 scope.pos=7387 scope.end_pos=7592)
	// var "g" var.pos=7392 var.line_nr=308
	// var "name" var.pos=7411 var.line_nr=308
	// var "ns" var.pos=7434 var.line_nr=309
	// var "alias" var.pos=7486 var.line_nr=313
	// af parent scope:
	// af parent scope:
	return _t3292;
}

VV_LOCAL_SYMBOL string v__gen__js__JsGen_js_name(v__gen__js__JsGen* g, string name_) {
	bool is_js = false;
	string name = name_;
	if (string_starts_with(name, _SLIT("JS."))) {
		name = string_substr(name, 3, name.len);
		is_js = true;
	}
	string ns = v__gen__js__get_ns(name);
	string _t3293; /* if prepend */
	if (g->ns == 0) {
		_t3293 = name;
	} else if (string_eq(ns, g->ns->name)) {
		_t3293 = (*(string*)array_last(string_split(name, _SLIT("."))));
	} else {
		_t3293 = v__gen__js__JsGen_get_alias(g, name);
	}
	name =  _t3293;
	Array_string parts = string_split(name, _SLIT("."));
	if (!is_js) {
		// FOR IN array
		for (int i = 0; i < parts.len; ++i) {
			string p = ((string*)parts.data)[i];
			if ((Array_string_contains(_const_v__gen__js__js_reserved, p))) {
				array_set(&parts, i, &(string[]) { _STR("v_%.*s", 1, p) });
			}
		}
	}
	 string _t3294 = Array_string_join(parts, _SLIT("."));
	// autofree_scope_vars(pos=8013 line_nr=343 scope.pos=7598 scope.end_pos=8037)
	// var "g" var.pos=7603 var.line_nr=320
	// var "name_" var.pos=7620 var.line_nr=320
	// var "is_js" var.pos=7648 var.line_nr=321
	// var "name" var.pos=7668 var.line_nr=322
	// var "ns" var.pos=7750 var.line_nr=327
	// var "parts" var.pos=7891 var.line_nr=335
	// af parent scope:
	// af parent scope:
	return _t3294;
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_stmts(v__gen__js__JsGen* g, Array_v__ast__Stmt stmts) {
	v__gen__js__JsGen_inc_indent(g);
	// FOR IN array
	for (int _t3295 = 0; _t3295 < stmts.len; ++_t3295) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)stmts.data)[_t3295];
		v__gen__js__JsGen_stmt(g, stmt);
	}
	v__gen__js__JsGen_dec_indent(g);
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_stmt(v__gen__js__JsGen* g, v__ast__Stmt node) {
	g->stmt_start_pos = g->ns->out.len;
	if (node._typ == 291 /* v.ast.EmptyStmt */) {
	}
	else if (node._typ == 283 /* v.ast.AsmStmt */) {
		v_panic(_SLIT("inline asm is not supported by js"));
	}
	else if (node._typ == 284 /* v.ast.AssertStmt */) {
		v__gen__js__JsGen_gen_assert_stmt(g, (*node._v__ast__AssertStmt));
	}
	else if (node._typ == 285 /* v.ast.AssignStmt */) {
		v__gen__js__JsGen_gen_assign_stmt(g, (*node._v__ast__AssignStmt));
	}
	else if (node._typ == 286 /* v.ast.Block */) {
		v__gen__js__JsGen_gen_block(g, (*node._v__ast__Block));
		v__gen__js__JsGen_writeln(g, _SLIT(""));
	}
	else if (node._typ == 287 /* v.ast.BranchStmt */) {
		v__gen__js__JsGen_gen_branch_stmt(g, (*node._v__ast__BranchStmt));
	}
	else if (node._typ == 288 /* v.ast.CompFor */) {
	}
	else if (node._typ == 289 /* v.ast.ConstDecl */) {
		v__gen__js__JsGen_gen_const_decl(g, (*node._v__ast__ConstDecl));
	}
	else if (node._typ == 290 /* v.ast.DeferStmt */) {
		array_push(&g->defer_stmts, _MOV((v__ast__DeferStmt[]){ (*node._v__ast__DeferStmt) }));
	}
	else if (node._typ == 292 /* v.ast.EnumDecl */) {
		v__gen__js__JsGen_gen_enum_decl(g, (*node._v__ast__EnumDecl));
		v__gen__js__JsGen_writeln(g, _SLIT(""));
	}
	else if (node._typ == 293 /* v.ast.ExprStmt */) {
		v__gen__js__JsGen_gen_expr_stmt(g, (*node._v__ast__ExprStmt));
	}
	else if (node._typ == 175 /* v.ast.FnDecl */) {
		g->fn_decl = &(*node._v__ast__FnDecl);
		v__gen__js__JsGen_gen_fn_decl(g, (*node._v__ast__FnDecl));
	}
	else if (node._typ == 294 /* v.ast.ForCStmt */) {
		v__gen__js__JsGen_gen_for_c_stmt(g, (*node._v__ast__ForCStmt));
		v__gen__js__JsGen_writeln(g, _SLIT(""));
	}
	else if (node._typ == 295 /* v.ast.ForInStmt */) {
		v__gen__js__JsGen_gen_for_in_stmt(g, (*node._v__ast__ForInStmt));
		v__gen__js__JsGen_writeln(g, _SLIT(""));
	}
	else if (node._typ == 296 /* v.ast.ForStmt */) {
		v__gen__js__JsGen_gen_for_stmt(g, (*node._v__ast__ForStmt));
		v__gen__js__JsGen_writeln(g, _SLIT(""));
	}
	else if (node._typ == 297 /* v.ast.GlobalDecl */) {
	}
	else if (node._typ == 298 /* v.ast.GoStmt */) {
		v__gen__js__JsGen_gen_go_stmt(g, (*node._v__ast__GoStmt));
		v__gen__js__JsGen_writeln(g, _SLIT(""));
	}
	else if (node._typ == 299 /* v.ast.GotoLabel */) {
		v__gen__js__JsGen_writeln(g, _STR("%.*s\000:", 2, v__gen__js__JsGen_js_name(g, (*node._v__ast__GotoLabel).name)));
	}
	else if (node._typ == 300 /* v.ast.GotoStmt */) {
	}
	else if (node._typ == 301 /* v.ast.HashStmt */) {
		v__gen__js__JsGen_gen_hash_stmt(g, (*node._v__ast__HashStmt));
	}
	else if (node._typ == 302 /* v.ast.Import */) {
		map_set(&g->ns->imports, &(string[]){(*node._v__ast__Import).mod}, &(string[]) { (*node._v__ast__Import).alias });
	}
	else if (node._typ == 303 /* v.ast.InterfaceDecl */) {
		v__gen__js__JsGen_gen_interface_decl(g, (*node._v__ast__InterfaceDecl));
	}
	else if (node._typ == 304 /* v.ast.Module */) {
	}
	else if (node._typ == 264 /* v.ast.NodeError */) {
	}
	else if (node._typ == 305 /* v.ast.Return */) {
		if (g->defer_stmts.len > 0) {
			v__gen__js__JsGen_gen_defer_stmts(g);
		}
		v__gen__js__JsGen_gen_return_stmt(g, (*node._v__ast__Return));
	}
	else if (node._typ == 306 /* v.ast.SqlStmt */) {
	}
	else if (node._typ == 307 /* v.ast.StructDecl */) {
		v__gen__js__JsGen_gen_struct_decl(g, (*node._v__ast__StructDecl));
	}
	else if (node._typ == 232 /* v.ast.TypeDecl */) {
	};
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_expr(v__gen__js__JsGen* g, v__ast__Expr node) {
	if (node._typ == 264 /* v.ast.NodeError */) {
	}
	else if (node._typ == 250 /* v.ast.EmptyExpr */) {
	}
	else if (node._typ == 240 /* v.ast.CTempVar */) {
		v__gen__js__JsGen_write(g, _SLIT("/* ast.CTempVar: node.name */"));
	}
	else if (node._typ == 249 /* v.ast.DumpExpr */) {
		v__gen__js__JsGen_write(g, _STR("/* ast.DumpExpr: %.*s\000 */", 2, v__ast__Expr_str((*node._v__ast__DumpExpr).expr)));
	}
	else if (node._typ == 233 /* v.ast.AnonFn */) {
		v__gen__js__JsGen_gen_fn_decl(g, (*node._v__ast__AnonFn).decl);
	}
	else if (node._typ == 235 /* v.ast.ArrayInit */) {
		v__gen__js__JsGen_gen_array_init_expr(g, (*node._v__ast__ArrayInit));
	}
	else if (node._typ == 236 /* v.ast.AsCast */) {
	}
	else if (node._typ == 237 /* v.ast.Assoc */) {
	}
	else if (node._typ == 239 /* v.ast.BoolLiteral */) {
		if ((*node._v__ast__BoolLiteral).val == true) {
			v__gen__js__JsGen_write(g, _SLIT("true"));
		} else {
			v__gen__js__JsGen_write(g, _SLIT("false"));
		}
	}
	else if (node._typ == 241 /* v.ast.CallExpr */) {
		v__gen__js__JsGen_gen_call_expr(g, (*node._v__ast__CallExpr));
	}
	else if (node._typ == 243 /* v.ast.ChanInit */) {
	}
	else if (node._typ == 242 /* v.ast.CastExpr */) {
		v__gen__js__JsGen_gen_type_cast_expr(g, (*node._v__ast__CastExpr));
	}
	else if (node._typ == 244 /* v.ast.CharLiteral */) {
		v__gen__js__JsGen_write(g, _STR("'%.*s\000'", 2, (*node._v__ast__CharLiteral).val));
	}
	else if (node._typ == 245 /* v.ast.Comment */) {
	}
	else if (node._typ == 248 /* v.ast.ConcatExpr */) {
	}
	else if (node._typ == 251 /* v.ast.EnumVal */) {
		v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, (*node._v__ast__EnumVal).typ);
		string styp = v__gen__js__JsGen_js_name(g, sym->name);
		v__gen__js__JsGen_write(g, _STR("%.*s\000.%.*s", 2, styp, (*node._v__ast__EnumVal).val));
	}
	else if (node._typ == 252 /* v.ast.FloatLiteral */) {
		v__gen__js__JsGen_gen_float_literal_expr(g, (*node._v__ast__FloatLiteral));
	}
	else if (node._typ == 253 /* v.ast.GoExpr */) {
	}
	else if (node._typ == 254 /* v.ast.Ident */) {
		v__gen__js__JsGen_gen_ident(g, (*node._v__ast__Ident));
	}
	else if (node._typ == 255 /* v.ast.IfExpr */) {
		v__gen__js__JsGen_gen_if_expr(g, (*node._v__ast__IfExpr));
	}
	else if (node._typ == 256 /* v.ast.IfGuardExpr */) {
	}
	else if (node._typ == 257 /* v.ast.IndexExpr */) {
		v__gen__js__JsGen_gen_index_expr(g, (*node._v__ast__IndexExpr));
	}
	else if (node._typ == 258 /* v.ast.InfixExpr */) {
		v__gen__js__JsGen_gen_infix_expr(g, (*node._v__ast__InfixExpr));
	}
	else if (node._typ == 259 /* v.ast.IntegerLiteral */) {
		v__gen__js__JsGen_gen_integer_literal_expr(g, (*node._v__ast__IntegerLiteral));
	}
	else if (node._typ == 261 /* v.ast.LockExpr */) {
		v__gen__js__JsGen_gen_lock_expr(g, (*node._v__ast__LockExpr));
	}
	else if (node._typ == 262 /* v.ast.MapInit */) {
		v__gen__js__JsGen_gen_map_init_expr(g, (*node._v__ast__MapInit));
	}
	else if (node._typ == 263 /* v.ast.MatchExpr */) {
	}
	else if (node._typ == 265 /* v.ast.None */) {
	}
	else if (node._typ == 267 /* v.ast.OrExpr */) {
	}
	else if (node._typ == 268 /* v.ast.ParExpr */) {
		v__gen__js__JsGen_write(g, _SLIT("("));
		v__gen__js__JsGen_expr(g, (*node._v__ast__ParExpr).expr);
		v__gen__js__JsGen_write(g, _SLIT(")"));
	}
	else if (node._typ == 269 /* v.ast.PostfixExpr */) {
		v__gen__js__JsGen_expr(g, (*node._v__ast__PostfixExpr).expr);
		v__gen__js__JsGen_write(g, v__token__Kind_str((*node._v__ast__PostfixExpr).op));
	}
	else if (node._typ == 270 /* v.ast.PrefixExpr */) {
		if (((*node._v__ast__PrefixExpr).op == v__token__Kind_amp || (*node._v__ast__PrefixExpr).op == v__token__Kind_mul)) {
		} else {
			v__gen__js__JsGen_write(g, v__token__Kind_str((*node._v__ast__PrefixExpr).op));
		}
		v__gen__js__JsGen_expr(g, (*node._v__ast__PrefixExpr).right);
	}
	else if (node._typ == 271 /* v.ast.RangeExpr */) {
	}
	else if (node._typ == 272 /* v.ast.SelectExpr */) {
	}
	else if (node._typ == 273 /* v.ast.SelectorExpr */) {
		v__gen__js__JsGen_gen_selector_expr(g, (*node._v__ast__SelectorExpr));
	}
	else if (node._typ == 274 /* v.ast.SizeOf */) {
	}
	else if (node._typ == 266 /* v.ast.OffsetOf */) {
	}
	else if (node._typ == 275 /* v.ast.SqlExpr */) {
	}
	else if (node._typ == 276 /* v.ast.StringInterLiteral */) {
		v__gen__js__JsGen_gen_string_inter_literal(g, (*node._v__ast__StringInterLiteral));
	}
	else if (node._typ == 277 /* v.ast.StringLiteral */) {
		v__gen__js__JsGen_gen_string_literal(g, (*node._v__ast__StringLiteral));
	}
	else if (node._typ == 278 /* v.ast.StructInit */) {
		v__gen__js__JsGen_gen_struct_init(g, (*node._v__ast__StructInit));
	}
	else if (node._typ == 279 /* v.ast.TypeNode */) {
	}
	else if (node._typ == 260 /* v.ast.Likely */) {
		v__gen__js__JsGen_write(g, _SLIT("("));
		v__gen__js__JsGen_expr(g, (*node._v__ast__Likely).expr);
		v__gen__js__JsGen_write(g, _SLIT(")"));
	}
	else if (node._typ == 280 /* v.ast.TypeOf */) {
		v__gen__js__JsGen_gen_typeof_expr(g, (*node._v__ast__TypeOf));
	}
	else if (node._typ == 238 /* v.ast.AtExpr */) {
		v__gen__js__JsGen_write(g, _STR("\"%.*s\000\"", 2, (*node._v__ast__AtExpr).val));
	}
	else if (node._typ == 246 /* v.ast.ComptimeCall */) {
	}
	else if (node._typ == 247 /* v.ast.ComptimeSelector */) {
	}
	else if (node._typ == 281 /* v.ast.UnsafeExpr */) {
		v__gen__js__JsGen_expr(g, (*node._v__ast__UnsafeExpr).expr);
	}
	else if (node._typ == 234 /* v.ast.ArrayDecompose */) {
	};
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_assert_stmt(v__gen__js__JsGen* g, v__ast__AssertStmt a) {
	v__gen__js__JsGen_writeln(g, _SLIT("// assert"));
	v__gen__js__JsGen_write(g, _SLIT("if( "));
	v__gen__js__JsGen_expr(g, a.expr);
	v__gen__js__JsGen_write(g, _SLIT(" ) {"));
	string s_assertion = string_replace(v__ast__Expr_str(a.expr), _SLIT("\""), _SLIT("'"));
	string mod_path = string_replace(g->file.path, _SLIT("\\"), _SLIT("\\\\"));
	if (g->is_test) {
		v__gen__js__JsGen_writeln(g, _SLIT("	g_test_oks++;"));
		v__gen__js__JsGen_writeln(g, _STR("	cb_assertion_ok(\"%.*s\000\", %"PRId32"\000, \"assert %.*s\000\", \"%.*s\000()\" );", 5, mod_path, a.pos.line_nr + 1, s_assertion, g->fn_decl->name));
		v__gen__js__JsGen_writeln(g, _SLIT("} else {"));
		v__gen__js__JsGen_writeln(g, _SLIT("	g_test_fails++;"));
		v__gen__js__JsGen_writeln(g, _STR("	cb_assertion_failed(\"%.*s\000\", %"PRId32"\000, \"assert %.*s\000\", \"%.*s\000()\" );", 5, mod_path, a.pos.line_nr + 1, s_assertion, g->fn_decl->name));
		v__gen__js__JsGen_writeln(g, _SLIT("	exit(1);"));
		v__gen__js__JsGen_writeln(g, _SLIT("}"));
		return;
	}
	v__gen__js__JsGen_writeln(g, _SLIT("} else {"));
	v__gen__js__JsGen_inc_indent(g);
	v__gen__js__JsGen_writeln(g, _STR("builtin.eprintln(\"%.*s\000:%"PRId32"\000: FAIL: fn %.*s\000(): assert %.*s\000\");", 5, mod_path, a.pos.line_nr + 1, g->fn_decl->name, s_assertion));
	v__gen__js__JsGen_writeln(g, _SLIT("builtin.exit(1);"));
	v__gen__js__JsGen_dec_indent(g);
	v__gen__js__JsGen_writeln(g, _SLIT("}"));
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_assign_stmt(v__gen__js__JsGen* g, v__ast__AssignStmt stmt) {
	if (stmt.left.len > stmt.right.len) {
		v__gen__js__JsGen_write(g, _SLIT("const ["));
		// FOR IN array
		for (int i = 0; i < stmt.left.len; ++i) {
			v__ast__Expr left = ((v__ast__Expr*)stmt.left.data)[i];
			if (!v__ast__Expr_is_blank_ident(left)) {
				v__gen__js__JsGen_expr(g, left);
			}
			if (i < stmt.left.len - 1) {
				v__gen__js__JsGen_write(g, _SLIT(", "));
			}
		}
		v__gen__js__JsGen_write(g, _SLIT("] = "));
		v__gen__js__JsGen_expr(g, (*(v__ast__Expr*)/*ee elem_typ */array_get(stmt.right, 0)));
		v__gen__js__JsGen_writeln(g, _SLIT(";"));
	} else {
		// FOR IN array
		for (int i = 0; i < stmt.left.len; ++i) {
			v__ast__Expr left = ((v__ast__Expr*)stmt.left.data)[i];
			v__token__Kind op = stmt.op;
			if (stmt.op == v__token__Kind_decl_assign) {
				op = v__token__Kind_assign;
			}
			v__ast__Expr val = (*(v__ast__Expr*)/*ee elem_typ */array_get(stmt.right, i));
			bool is_mut = false;
			if ((left)._typ == 254 /* v.ast.Ident */) {
				is_mut = (*left._v__ast__Ident).is_mut;
				if ((*left._v__ast__Ident).kind == v__ast__IdentKind_blank_ident || (string_eq((*left._v__ast__Ident).name, _SLIT("")) || string_eq((*left._v__ast__Ident).name, _SLIT("_")))) {
					string tmp_var = v__gen__js__JsGen_new_tmp_var(g);
					v__gen__js__JsGen_write(g, _STR("const %.*s\000 = ", 2, tmp_var));
					v__gen__js__JsGen_expr(g, val);
					v__gen__js__JsGen_writeln(g, _SLIT(";"));
					continue;
				}
			}
			string styp = v__gen__js__JsGen_typ(g, (*(v__ast__Type*)/*ee elem_typ */array_get(stmt.left_types, i)));
			if (!g->inside_loop && styp.len > 0) {
				v__gen__js__JsDoc_gen_typ(g->doc, styp);
			}
			if (stmt.op == v__token__Kind_decl_assign) {
				if (g->inside_loop || is_mut) {
					v__gen__js__JsGen_write(g, _SLIT("let "));
				} else {
					v__gen__js__JsGen_write(g, _SLIT("const "));
				}
			}
			v__gen__js__JsGen_expr(g, left);
			if (g->inside_map_set && op == v__token__Kind_assign) {
				g->inside_map_set = false;
				v__gen__js__JsGen_write(g, _SLIT(", "));
				v__gen__js__JsGen_expr(g, val);
				v__gen__js__JsGen_write(g, _SLIT(")"));
			} else {
				v__gen__js__JsGen_write(g, _STR(" %.*s\000 ", 2, v__token__Kind_str(op)));
				bool should_cast = ((Array_v__ast__Kind_contains(_const_v__gen__js__shallow_equatables, v__ast__Table_type_kind(g->table, (*(v__ast__Type*)array_first(stmt.left_types)))))) && (g->cast_stack.len <= 0 || !v__ast__Type_alias_eq((*(v__ast__Type*)array_first(stmt.left_types)), (*(v__ast__Type*)array_last(g->cast_stack))));
				if (should_cast) {
					array_push(&g->cast_stack, _MOV((v__ast__Type[]){ (*(v__ast__Type*)array_first(stmt.left_types)) }));
					if (string_eq(g->file.mod.name, _SLIT("builtin"))) {
						v__gen__js__JsGen_write(g, _SLIT("new "));
					}
					v__gen__js__JsGen_write(g, _STR("%.*s\000(", 2, v__gen__js__JsGen_typ(g, (*(v__ast__Type*)array_first(stmt.left_types)))));
				}
				v__gen__js__JsGen_expr(g, val);
				if (should_cast) {
					v__gen__js__JsGen_write(g, _SLIT(")"));
					array_delete_last(&g->cast_stack);
				}
			}
			if (g->inside_loop) {
				v__gen__js__JsGen_write(g, _SLIT("; "));
			} else {
				v__gen__js__JsGen_writeln(g, _SLIT(";"));
			}
		}
	}
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_attrs(v__gen__js__JsGen* g, Array_v__ast__Attr attrs) {
	// FOR IN array
	for (int _t3298 = 0; _t3298 < attrs.len; ++_t3298) {
		v__ast__Attr attr = ((v__ast__Attr*)attrs.data)[_t3298];
		v__gen__js__JsGen_writeln(g, _STR("/* [%.*s\000] */", 2, attr.name));
	}
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_block(v__gen__js__JsGen* g, v__ast__Block it) {
	v__gen__js__JsGen_writeln(g, _SLIT("{"));
	v__gen__js__JsGen_stmts(g, it.stmts);
	v__gen__js__JsGen_writeln(g, _SLIT("}"));
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_branch_stmt(v__gen__js__JsGen* g, v__ast__BranchStmt it) {
	v__gen__js__JsGen_write(g, v__token__Kind_str(it.kind));
	v__gen__js__JsGen_writeln(g, _SLIT(";"));
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_const_decl(v__gen__js__JsGen* g, v__ast__ConstDecl it) {
	// FOR IN array
	for (int _t3299 = 0; _t3299 < it.fields.len; ++_t3299) {
		v__ast__ConstField field = ((v__ast__ConstField*)it.fields.data)[_t3299];
		v__gen__js__JsDoc_gen_const(g->doc, v__gen__js__JsGen_typ(g, field.typ));
		if (field.is_pub) {
			v__gen__js__JsGen_push_pub_var(g, field.name);
		}
		v__gen__js__JsGen_write(g, _STR("const %.*s\000 = ", 2, v__gen__js__JsGen_js_name(g, field.name)));
		v__gen__js__JsGen_expr(g, field.expr);
		v__gen__js__JsGen_writeln(g, _SLIT(";"));
	}
	v__gen__js__JsGen_writeln(g, _SLIT(""));
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_defer_stmts(v__gen__js__JsGen* g) {
	v__gen__js__JsGen_writeln(g, _SLIT("(function defer() {"));
	// FOR IN array
	for (int _t3300 = 0; _t3300 < g->defer_stmts.len; ++_t3300) {
		v__ast__DeferStmt defer_stmt = ((v__ast__DeferStmt*)g->defer_stmts.data)[_t3300];
		v__gen__js__JsGen_stmts(g, defer_stmt.stmts);
	}
	g->defer_stmts = __new_array_with_default(0, 0, sizeof(v__ast__DeferStmt), 0);
	v__gen__js__JsGen_writeln(g, _SLIT("})();"));
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_enum_decl(v__gen__js__JsGen* g, v__ast__EnumDecl it) {
	v__gen__js__JsDoc_gen_enum(g->doc);
	v__gen__js__JsGen_writeln(g, _STR("const %.*s\000 = {", 2, v__gen__js__JsGen_js_name(g, it.name)));
	v__gen__js__JsGen_inc_indent(g);
	int i = 0;
	// FOR IN array
	for (int _t3301 = 0; _t3301 < it.fields.len; ++_t3301) {
		v__ast__EnumField field = ((v__ast__EnumField*)it.fields.data)[_t3301];
		v__gen__js__JsGen_write(g, _STR("%.*s\000: ", 2, field.name));
		if (field.has_expr && (field.expr)._typ == 259 /* v.ast.IntegerLiteral */) {
			v__ast__IntegerLiteral e = /* as */ *(v__ast__IntegerLiteral*)__as_cast((field.expr)._v__ast__IntegerLiteral,(field.expr)._typ, 259) /*expected idx: 259, name: v.ast.IntegerLiteral */ ;
			i = string_int(e.val);
		}
		v__gen__js__JsGen_writeln(g, _STR("%"PRId32"\000,", 2, i++));
	}
	v__gen__js__JsGen_dec_indent(g);
	v__gen__js__JsGen_writeln(g, _SLIT("};"));
	if (it.is_pub) {
		v__gen__js__JsGen_push_pub_var(g, it.name);
	}
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_expr_stmt(v__gen__js__JsGen* g, v__ast__ExprStmt it) {
	v__gen__js__JsGen_expr(g, it.expr);
	if (!it.is_expr && (it.expr)._typ != 255 /* v.ast.IfExpr */ && !g->inside_ternary) {
		v__gen__js__JsGen_writeln(g, _SLIT(";"));
	}
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_fn_decl(v__gen__js__JsGen* g, v__ast__FnDecl it) {
	if (it.no_body || it.is_method) {
		return;
	}
	if (g->inside_builtin) {
		array_push(&g->builtin_fns, _MOV((string[]){ string_clone(it.name) }));
	}
	v__gen__js__JsGen_gen_method_decl(g, it);
}

VV_LOCAL_SYMBOL bool v__gen__js__fn_has_go(v__ast__FnDecl it) {
	bool has_go = false;
	// FOR IN array
	for (int _t3303 = 0; _t3303 < it.stmts.len; ++_t3303) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)it.stmts.data)[_t3303];
		if ((stmt)._typ == 298 /* v.ast.GoStmt */) {
			has_go = true;
		}
	}
	// autofree_scope_vars(pos=17036 line_nr=809 scope.pos=16909 scope.end_pos=17051)
	// var "it" var.pos=16919 var.line_nr=802
	// var "has_go" var.pos=16946 var.line_nr=803
	// af parent scope:
	// af parent scope:
	return has_go;
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_method_decl(v__gen__js__JsGen* g, v__ast__FnDecl it) {
	g->fn_decl = &it;
	bool has_go = v__gen__js__fn_has_go(it);
	bool is_main = string_eq(it.name, _SLIT("main.main"));
	v__gen__js__JsGen_gen_attrs(g, it.attrs);
	if (is_main) {
		v__gen__js__JsGen_writeln(g, _SLIT("/* program entry point */"));
		v__gen__js__JsGen_write(g, _SLIT("("));
		if (has_go) {
			v__gen__js__JsGen_write(g, _SLIT("async "));
		}
		v__gen__js__JsGen_write(g, _SLIT("function("));
	} else if (it.is_anon) {
		v__gen__js__JsGen_write(g, _SLIT("function ("));
	} else {
		string name = v__gen__js__JsGen_js_name(g, it.name);
		byte c = string_at(name, 0);
		if ((c == L'+' || c == L'-' || c == L'*' || c == L'/')) {
			name = v__util__replace_op(name);
		}
		v__gen__js__JsDoc_gen_fn(g->doc, it);
		if (has_go) {
			v__gen__js__JsGen_write(g, _SLIT("async "));
		}
		if (!it.is_method) {
			v__gen__js__JsGen_write(g, _SLIT("function "));
		} else {
			if (Array_v__ast__Attr_contains(it.attrs, _SLIT("js_getter"))) {
				v__gen__js__JsGen_write(g, _SLIT("get "));
			} else if (Array_v__ast__Attr_contains(it.attrs, _SLIT("js_setter"))) {
				v__gen__js__JsGen_write(g, _SLIT("set "));
			}
		}
		v__gen__js__JsGen_write(g, _STR("%.*s\000(", 2, name));
		if (it.is_pub && !it.is_method) {
			v__gen__js__JsGen_push_pub_var(g, name);
		}
	}
	Array_v__ast__Param args = it.params;
	if (it.is_method) {
		args = array_slice(args, 1, args.len);
	}
	v__gen__js__JsGen_fn_args(g, args, it.is_variadic);
	if (it.is_method) {
		if (args.len > 0) {
			v__gen__js__JsGen_write(g, _SLIT(", "));
		}
		v__gen__js__JsGen_write(g, _STR("%.*s\000 = this", 2, (*(v__ast__Param*)/*ee elem_typ */array_get(it.params, 0)).name));
	}
	v__gen__js__JsGen_writeln(g, _SLIT(") {"));
	v__gen__js__JsGen_stmts(g, it.stmts);
	v__gen__js__JsGen_write(g, _SLIT("}"));
	if (is_main) {
		v__gen__js__JsGen_write(g, _SLIT(")();"));
	}
	if (!it.is_anon && !it.is_method) {
		v__gen__js__JsGen_writeln(g, _SLIT("\n"));
	}
	g->fn_decl = ((voidptr)(0));
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_fn_args(v__gen__js__JsGen* g, Array_v__ast__Param args, bool is_variadic) {
	// FOR IN array
	for (int i = 0; i < args.len; ++i) {
		v__ast__Param arg = ((v__ast__Param*)args.data)[i];
		string name = v__gen__js__JsGen_js_name(g, arg.name);
		bool is_varg = i == args.len - 1 && is_variadic;
		if (is_varg) {
			v__gen__js__JsGen_write(g, _STR("...%.*s", 1, name));
		} else {
			v__gen__js__JsGen_write(g, name);
		}
		if (i < args.len - 1) {
			v__gen__js__JsGen_write(g, _SLIT(", "));
		}
	}
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_for_c_stmt(v__gen__js__JsGen* g, v__ast__ForCStmt it) {
	g->inside_loop = true;
	v__gen__js__JsGen_write(g, _SLIT("for ("));
	if (it.has_init) {
		v__gen__js__JsGen_stmt(g, it.init);
	} else {
		v__gen__js__JsGen_write(g, _SLIT("; "));
	}
	if (it.has_cond) {
		v__gen__js__JsGen_expr(g, it.cond);
	}
	v__gen__js__JsGen_write(g, _SLIT("; "));
	if (it.has_inc) {
		v__gen__js__JsGen_stmt(g, it.inc);
	}
	v__gen__js__JsGen_writeln(g, _SLIT(") {"));
	v__gen__js__JsGen_stmts(g, it.stmts);
	v__gen__js__JsGen_writeln(g, _SLIT("}"));
	g->inside_loop = false;
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_for_in_stmt(v__gen__js__JsGen* g, v__ast__ForInStmt it) {
	if (it.is_range) {
		string i = it.val_var;
		if ((string_eq(i, _SLIT("")) || string_eq(i, _SLIT("_")))) {
			i = v__gen__js__JsGen_new_tmp_var(g);
		}
		g->inside_loop = true;
		v__gen__js__JsGen_write(g, _STR("for (let %.*s\000 = ", 2, i));
		v__gen__js__JsGen_expr(g, it.cond);
		v__gen__js__JsGen_write(g, _STR("; %.*s\000 < ", 2, i));
		v__gen__js__JsGen_expr(g, it.high);
		v__gen__js__JsGen_writeln(g, _STR("; ++%.*s\000) {", 2, i));
		g->inside_loop = false;
		v__gen__js__JsGen_stmts(g, it.stmts);
		v__gen__js__JsGen_writeln(g, _SLIT("}"));
	} else if ((it.kind == v__ast__Kind_array || it.kind == v__ast__Kind_string) || v__ast__Type_has_flag(it.cond_type, v__ast__TypeFlag_variadic)) {
		string val = ((string_eq(it.val_var, _SLIT("")) || string_eq(it.val_var, _SLIT("_"))) ? (_SLIT("_")) : (it.val_var));
		if (it.key_var.len > 0) {
			v__gen__js__JsGen_write(g, _STR("for (const [%.*s\000, %.*s\000] of ", 3, it.key_var, val));
			if (it.kind == v__ast__Kind_string) {
				v__gen__js__JsGen_write(g, _SLIT("Array.from("));
				v__gen__js__JsGen_expr(g, it.cond);
				v__gen__js__JsGen_write(g, _STR(".str.split(\'\').entries(), ([%.*s\000, %.*s\000]) => [%.*s\000, ", 4, it.key_var, val, it.key_var));
				if (string_eq(g->ns->name, _SLIT("builtin"))) {
					v__gen__js__JsGen_write(g, _SLIT("new "));
				}
				v__gen__js__JsGen_write(g, _STR("byte(%.*s\000)])", 2, val));
			} else {
				v__gen__js__JsGen_expr(g, it.cond);
				v__gen__js__JsGen_write(g, _SLIT(".entries()"));
			}
		} else {
			v__gen__js__JsGen_write(g, _STR("for (const %.*s\000 of ", 2, val));
			v__gen__js__JsGen_expr(g, it.cond);
			if (it.kind == v__ast__Kind_string) {
				v__gen__js__JsGen_write(g, _SLIT(".str.split('')"));
			}
			if (!(string_eq(val, _SLIT("")) || string_eq(val, _SLIT("_"))) && it.kind == v__ast__Kind_string) {
				v__gen__js__JsGen_write(g, _SLIT(".map(c => "));
				if (string_eq(g->ns->name, _SLIT("builtin"))) {
					v__gen__js__JsGen_write(g, _SLIT("new "));
				}
				v__gen__js__JsGen_write(g, _SLIT("byte(c))"));
			}
		}
		v__gen__js__JsGen_writeln(g, _SLIT(") {"));
		v__gen__js__JsGen_stmts(g, it.stmts);
		v__gen__js__JsGen_writeln(g, _SLIT("}"));
	} else if (it.kind == v__ast__Kind_map) {
		string key = ((string_eq(it.key_var, _SLIT("")) || string_eq(it.key_var, _SLIT("_"))) ? (_SLIT("")) : (it.key_var));
		string val = ((string_eq(it.val_var, _SLIT("")) || string_eq(it.val_var, _SLIT("_"))) ? (_SLIT("")) : (it.val_var));
		v__gen__js__JsGen_write(g, _STR("for (let [%.*s\000, %.*s\000] of ", 3, key, val));
		v__gen__js__JsGen_expr(g, it.cond);
		v__gen__js__JsGen_writeln(g, _SLIT(") {"));
		v__gen__js__JsGen_stmts(g, it.stmts);
		v__gen__js__JsGen_writeln(g, _SLIT("}"));
	}
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_for_stmt(v__gen__js__JsGen* g, v__ast__ForStmt it) {
	v__gen__js__JsGen_write(g, _SLIT("while ("));
	if (it.is_inf) {
		v__gen__js__JsGen_write(g, _SLIT("true"));
	} else {
		v__gen__js__JsGen_expr(g, it.cond);
	}
	v__gen__js__JsGen_writeln(g, _SLIT(") {"));
	v__gen__js__JsGen_stmts(g, it.stmts);
	v__gen__js__JsGen_writeln(g, _SLIT("}"));
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_go_stmt(v__gen__js__JsGen* g, v__ast__GoStmt node) {
	string name = node.call_expr.name;
	if (node.call_expr.is_method) {
		v__ast__TypeSymbol* receiver_sym = v__ast__Table_get_type_symbol(g->table, node.call_expr.receiver_type);
		name = string_add(string_add(receiver_sym->name, _SLIT(".")), name);
	}
	if (string_starts_with(name, _STR("%.*s\000.", 2, node.call_expr.mod))) {
		name = string_substr(name, node.call_expr.mod.len + 1, name.len);
	}
	v__gen__js__JsGen_writeln(g, _SLIT("await new Promise(function(resolve){"));
	v__gen__js__JsGen_inc_indent(g);
	v__gen__js__JsGen_write(g, _STR("%.*s\000(", 2, name));
	// FOR IN array
	for (int i = 0; i < node.call_expr.args.len; ++i) {
		v__ast__CallArg arg = ((v__ast__CallArg*)node.call_expr.args.data)[i];
		v__gen__js__JsGen_expr(g, arg.expr);
		if (i < node.call_expr.args.len - 1) {
			v__gen__js__JsGen_write(g, _SLIT(", "));
		}
	}
	v__gen__js__JsGen_writeln(g, _SLIT(");"));
	v__gen__js__JsGen_writeln(g, _SLIT("resolve();"));
	v__gen__js__JsGen_dec_indent(g);
	v__gen__js__JsGen_writeln(g, _SLIT("});"));
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_import_stmt(v__gen__js__JsGen* g, v__ast__Import it) {
	map_set(&g->ns->imports, &(string[]){it.mod}, &(string[]) { it.alias });
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_interface_decl(v__gen__js__JsGen* g, v__ast__InterfaceDecl it) {
	v__gen__js__JsDoc_gen_interface(g->doc, it);
	string name = v__gen__js__JsGen_js_name(g, it.name);
	v__gen__js__JsGen_push_pub_var(g, _STR("/** @type %.*s\000 */\n\t\t%.*s\000: undefined", 3, name, name));
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_return_stmt(v__gen__js__JsGen* g, v__ast__Return it) {
	if (it.exprs.len == 0) {
		v__gen__js__JsGen_writeln(g, _SLIT("return;"));
		return;
	}
	v__gen__js__JsGen_write(g, _SLIT("return "));
	if (it.exprs.len == 1) {
		v__gen__js__JsGen_expr(g, (*(v__ast__Expr*)/*ee elem_typ */array_get(it.exprs, 0)));
	} else {
		v__gen__js__JsGen_gen_array_init_values(g, it.exprs);
	}
	v__gen__js__JsGen_writeln(g, _SLIT(";"));
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_hash_stmt(v__gen__js__JsGen* g, v__ast__HashStmt it) {
	v__gen__js__JsGen_writeln(g, it.val);
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_struct_decl(v__gen__js__JsGen* g, v__ast__StructDecl node) {
	string name = node.name;
	if (string_starts_with(name, _SLIT("JS."))) {
		return;
	}
	if ((Array_string_contains(_const_v__gen__js__v_types, name)) && string_eq(g->ns->name, _SLIT("builtin"))) {
		return;
	}
	string js_name = v__gen__js__JsGen_js_name(g, name);
	v__gen__js__JsGen_gen_attrs(g, node.attrs);
	v__gen__js__JsDoc_gen_fac_fn(g->doc, node.fields);
	v__gen__js__JsGen_write(g, _STR("function %.*s\000({ ", 2, js_name));
	// FOR IN array
	for (int i = 0; i < node.fields.len; ++i) {
		v__ast__StructField field = ((v__ast__StructField*)node.fields.data)[i];
		v__gen__js__JsGen_write(g, _STR("%.*s\000 = ", 2, field.name));
		if (field.has_default_expr) {
			v__gen__js__JsGen_expr(g, field.default_expr);
		} else {
			v__gen__js__JsGen_write(g, _STR("%.*s", 1, v__gen__js__JsGen_to_js_typ_val(g, field.typ)));
		}
		if (i < node.fields.len - 1) {
			v__gen__js__JsGen_write(g, _SLIT(", "));
		}
	}
	v__gen__js__JsGen_writeln(g, _SLIT(" }) {"));
	v__gen__js__JsGen_inc_indent(g);
	// FOR IN array
	for (int _t3304 = 0; _t3304 < node.fields.len; ++_t3304) {
		v__ast__StructField field = ((v__ast__StructField*)node.fields.data)[_t3304];
		v__gen__js__JsGen_writeln(g, _STR("this.%.*s\000 = %.*s", 2, field.name, field.name));
	}
	v__gen__js__JsGen_dec_indent(g);
	v__gen__js__JsGen_writeln(g, _SLIT("};"));
	v__gen__js__JsGen_writeln(g, _STR("%.*s\000.prototype = {", 2, js_name));
	v__gen__js__JsGen_inc_indent(g);
	Array_v__ast__FnDecl fns = (*(Array_v__ast__FnDecl*)map_get(ADDR(map, g->method_fn_decls), &(string[]){name}, &(Array_v__ast__FnDecl[]){ __new_array(0, 1, sizeof(v__ast__FnDecl)) }));
	// FOR IN array
	for (int _t3305 = 0; _t3305 < node.fields.len; ++_t3305) {
		v__ast__StructField field = ((v__ast__StructField*)node.fields.data)[_t3305];
		string typ = v__gen__js__JsGen_typ(g, field.typ);
		v__gen__js__JsDoc_gen_typ(g->doc, typ);
		v__gen__js__JsGen_write(g, _STR("%.*s\000: %.*s", 2, field.name, v__gen__js__JsGen_to_js_typ_val(g, field.typ)));
		v__gen__js__JsGen_writeln(g, _SLIT(","));
	}
	// FOR IN array
	for (int _t3306 = 0; _t3306 < fns.len; ++_t3306) {
		v__ast__FnDecl cfn = ((v__ast__FnDecl*)fns.data)[_t3306];
		v__gen__js__JsGen_gen_method_decl(g, cfn);
		v__gen__js__JsGen_writeln(g, _SLIT(","));
	}
	Array_v__ast__FnDecl _t3307_orig = fns;
	int _t3307_len = _t3307_orig.len;
	Array_string _t3307 = __new_array(0, _t3307_len, sizeof(string));

	for (int _t3308 = 0; _t3308 < _t3307_len; ++_t3308) {
		v__ast__FnDecl it = ((v__ast__FnDecl*) _t3307_orig.data)[_t3308];
		string ti = it.name;
		array_push(&_t3307, &ti);
	}
	
	Array_string fn_names = _t3307;
	if (!(Array_string_contains(fn_names, _SLIT("toString")))) {
		v__gen__js__JsGen_writeln(g, _SLIT("toString() {"));
		v__gen__js__JsGen_inc_indent(g);
		v__gen__js__JsGen_write(g, _STR("return `%.*s\000 {", 2, js_name));
		// FOR IN array
		for (int i = 0; i < node.fields.len; ++i) {
			v__ast__StructField field = ((v__ast__StructField*)node.fields.data)[i];
			if (i == 0) {
				v__gen__js__JsGen_write(g, _SLIT(" "));
			} else {
				v__gen__js__JsGen_write(g, _SLIT(", "));
			}
			string _t3309 = (*(string*)array_last(string_split(v__gen__js__JsGen_typ(g, field.typ), _SLIT("."))));
			
			if (string_eq(_t3309, _SLIT("string"))) {
				v__gen__js__JsGen_write(g, _STR("%.*s\000: \"${this[\"%.*s\000\"].toString()}\"", 3, field.name, field.name));
			}
			else {
				v__gen__js__JsGen_write(g, _STR("%.*s\000: ${this[\"%.*s\000\"].toString()} ", 3, field.name, field.name));
			};
		}
		v__gen__js__JsGen_writeln(g, _SLIT("}`"));
		v__gen__js__JsGen_dec_indent(g);
		v__gen__js__JsGen_writeln(g, _SLIT("}"));
	}
	v__gen__js__JsGen_dec_indent(g);
	v__gen__js__JsGen_writeln(g, _SLIT("};\n"));
	if (node.is_pub) {
		v__gen__js__JsGen_push_pub_var(g, name);
	}
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_array_init_expr(v__gen__js__JsGen* g, v__ast__ArrayInit it) {
	if (it.has_len) {
		string t1 = v__gen__js__JsGen_new_tmp_var(g);
		string t2 = v__gen__js__JsGen_new_tmp_var(g);
		v__gen__js__JsGen_writeln(g, _SLIT("(function() {"));
		v__gen__js__JsGen_inc_indent(g);
		v__gen__js__JsGen_writeln(g, _STR("const %.*s\000 = [];", 2, t1));
		v__gen__js__JsGen_write(g, _STR("for (let %.*s\000 = 0; %.*s\000 < ", 3, t2, t2));
		v__gen__js__JsGen_expr(g, it.len_expr);
		v__gen__js__JsGen_writeln(g, _STR("; %.*s\000++) {", 2, t2));
		v__gen__js__JsGen_inc_indent(g);
		v__gen__js__JsGen_write(g, _STR("%.*s\000.push(", 2, t1));
		if (it.has_default) {
			v__gen__js__JsGen_expr(g, it.default_expr);
		} else {
			string t = v__gen__js__JsGen_to_js_typ_val(g, it.elem_type);
			v__gen__js__JsGen_write(g, t);
		}
		v__gen__js__JsGen_writeln(g, _SLIT(");"));
		v__gen__js__JsGen_dec_indent(g);
		v__gen__js__JsGen_writeln(g, _SLIT("};"));
		v__gen__js__JsGen_writeln(g, _STR("return %.*s\000;", 2, t1));
		v__gen__js__JsGen_dec_indent(g);
		v__gen__js__JsGen_write(g, _SLIT("})()"));
	} else {
		v__gen__js__JsGen_gen_array_init_values(g, it.exprs);
	}
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_array_init_values(v__gen__js__JsGen* g, Array_v__ast__Expr exprs) {
	v__gen__js__JsGen_write(g, _SLIT("["));
	// FOR IN array
	for (int i = 0; i < exprs.len; ++i) {
		v__ast__Expr expr = ((v__ast__Expr*)exprs.data)[i];
		v__gen__js__JsGen_expr(g, expr);
		if (i < exprs.len - 1) {
			v__gen__js__JsGen_write(g, _SLIT(", "));
		}
	}
	v__gen__js__JsGen_write(g, _SLIT("]"));
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_call_expr(v__gen__js__JsGen* g, v__ast__CallExpr it) {
	array_push(&g->call_stack, _MOV((v__ast__CallExpr[]){ it }));
	string name = v__gen__js__JsGen_js_name(g, it.name);
	bool call_return_is_optional = v__ast__Type_has_flag(it.return_type, v__ast__TypeFlag_optional);
	if (call_return_is_optional) {
		v__gen__js__JsGen_writeln(g, _SLIT("(function(){"));
		v__gen__js__JsGen_inc_indent(g);
		v__gen__js__JsGen_writeln(g, _SLIT("try {"));
		v__gen__js__JsGen_inc_indent(g);
		v__gen__js__JsGen_write(g, _SLIT("return builtin.unwrap("));
	}
	v__gen__js__JsGen_expr(g, it.left);
	if (it.is_method) {
		v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, it.receiver_type);
		v__gen__js__JsGen_write(g, _SLIT("."));
		if (sym->kind == v__ast__Kind_array && (string_eq(it.name, _SLIT("map")) || string_eq(it.name, _SLIT("filter")))) {
			v__ast__CallExpr node = it;
			v__gen__js__JsGen_write(g, it.name);
			v__gen__js__JsGen_write(g, _SLIT("("));
			v__ast__Expr expr = (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr;
			if (expr._typ == 233 /* v.ast.AnonFn */) {
				v__gen__js__JsGen_gen_fn_decl(g, (*expr._v__ast__AnonFn).decl);
				v__gen__js__JsGen_write(g, _SLIT(")"));
				return;
			}
			else if (expr._typ == 254 /* v.ast.Ident */) {
				if ((*expr._v__ast__Ident).kind == v__ast__IdentKind_function) {
					v__gen__js__JsGen_write(g, v__gen__js__JsGen_js_name(g, (*expr._v__ast__Ident).name));
					v__gen__js__JsGen_write(g, _SLIT(")"));
					return;
				} else if ((*expr._v__ast__Ident).kind == v__ast__IdentKind_variable) {
					v__ast__TypeSymbol* v_sym = v__ast__Table_get_type_symbol(g->table, v__ast__Ident_var_info(&(*expr._v__ast__Ident)).typ);
					if (v_sym->kind == v__ast__Kind_function) {
						v__gen__js__JsGen_write(g, v__gen__js__JsGen_js_name(g, (*expr._v__ast__Ident).name));
						v__gen__js__JsGen_write(g, _SLIT(")"));
						return;
					}
				}
			}
			else {
			};
			v__gen__js__JsGen_write(g, _SLIT("it => "));
			v__gen__js__JsGen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
			v__gen__js__JsGen_write(g, _SLIT(")"));
			return;
		}
	} else {
		if ((Array_string_contains(g->builtin_fns, name))) {
			v__gen__js__JsGen_write(g, _SLIT("builtin."));
		}
	}
	v__gen__js__JsGen_write(g, _STR("%.*s\000(", 2, name));
	// FOR IN array
	for (int i = 0; i < it.args.len; ++i) {
		v__ast__CallArg arg = ((v__ast__CallArg*)it.args.data)[i];
		v__gen__js__JsGen_expr(g, arg.expr);
		if (i != it.args.len - 1) {
			v__gen__js__JsGen_write(g, _SLIT(", "));
		}
	}
	v__gen__js__JsGen_write(g, _SLIT(")"));
	if (call_return_is_optional) {
		v__gen__js__JsGen_writeln(g, _SLIT(")"));
		v__gen__js__JsGen_dec_indent(g);
		v__gen__js__JsGen_writeln(g, _SLIT("} catch(err) {"));
		v__gen__js__JsGen_inc_indent(g);

		if (it.or_block.kind == (v__ast__OrKind_block)) {
			if (it.or_block.stmts.len > 1) {
				v__gen__js__JsGen_stmts(g, array_slice(it.or_block.stmts, 0, it.or_block.stmts.len - 1));
			}
			v__gen__js__JsGen_write(g, _SLIT("return "));
			v__gen__js__JsGen_stmt(g, (*(v__ast__Stmt*)array_last(it.or_block.stmts)));
		}
		else if (it.or_block.kind == (v__ast__OrKind_propagate)) {
			string panicstr = _SLIT("`optional not set (${err})`");
			if (string_eq(g->file.mod.name, _SLIT("main")) && string_eq(g->fn_decl->name, _SLIT("main.main"))) {
				v__gen__js__JsGen_writeln(g, _STR("return builtin.panic(%.*s\000)", 2, panicstr));
			} else {
				v__gen__js__JsGen_writeln(g, _SLIT("builtin.js_throw(err)"));
			}
		}
		else {
		};
		v__gen__js__JsGen_dec_indent(g);
		v__gen__js__JsGen_writeln(g, _SLIT("}"));
		v__gen__js__JsGen_dec_indent(g);
		v__gen__js__JsGen_write(g, _SLIT("})()"));
	}
	array_delete_last(&g->call_stack);
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_ident(v__gen__js__JsGen* g, v__ast__Ident node) {
	string name = v__gen__js__JsGen_js_name(g, node.name);
	if (node.kind == v__ast__IdentKind_blank_ident || (string_eq(name, _SLIT("")) || string_eq(name, _SLIT("_")))) {
		name = v__gen__js__JsGen_new_tmp_var(g);
	}
	v__gen__js__JsGen_write(g, name);
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_lock_expr(v__gen__js__JsGen* g, v__ast__LockExpr node) {
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_if_expr(v__gen__js__JsGen* g, v__ast__IfExpr node) {
	v__ast__TypeSymbol* type_sym = v__ast__Table_get_type_symbol(g->table, node.typ);
	if (node.is_expr && node.branches.len >= 2 && node.has_else && type_sym->kind != v__ast__Kind_void) {
		v__gen__js__JsGen_write(g, _SLIT("("));
		g->inside_ternary = true;
		// FOR IN array
		for (int i = 0; i < node.branches.len; ++i) {
			v__ast__IfBranch branch = ((v__ast__IfBranch*)node.branches.data)[i];
			if (i > 0) {
				v__gen__js__JsGen_write(g, _SLIT(" : "));
			}
			if (i < node.branches.len - 1 || !node.has_else) {
				v__gen__js__JsGen_expr(g, branch.cond);
				v__gen__js__JsGen_write(g, _SLIT(" ? "));
			}
			v__gen__js__JsGen_stmts(g, branch.stmts);
		}
		g->inside_ternary = false;
		v__gen__js__JsGen_write(g, _SLIT(")"));
	} else {
		// FOR IN array
		for (int i = 0; i < node.branches.len; ++i) {
			v__ast__IfBranch branch = ((v__ast__IfBranch*)node.branches.data)[i];
			if (i == 0) {
				if (branch.cond._typ == 256 /* v.ast.IfGuardExpr */) {
				}
				else {
					v__gen__js__JsGen_write(g, _SLIT("if ("));
					if (string_eq(_STR("%.*s", 1, v__ast__Expr_str(branch.cond)), _SLIT("js"))) {
						v__gen__js__JsGen_write(g, _SLIT("true"));
					} else {
						v__gen__js__JsGen_expr(g, branch.cond);
					}
					v__gen__js__JsGen_writeln(g, _SLIT(") {"));
				};
			} else if (i < node.branches.len - 1 || !node.has_else) {
				v__gen__js__JsGen_write(g, _SLIT("} else if ("));
				v__gen__js__JsGen_expr(g, branch.cond);
				v__gen__js__JsGen_writeln(g, _SLIT(") {"));
			} else if (i == node.branches.len - 1 && node.has_else) {
				v__gen__js__JsGen_writeln(g, _SLIT("} else {"));
			}
			v__gen__js__JsGen_stmts(g, branch.stmts);
		}
		v__gen__js__JsGen_writeln(g, _SLIT("}"));
		v__gen__js__JsGen_writeln(g, _SLIT(""));
	}
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_index_expr(v__gen__js__JsGen* g, v__ast__IndexExpr expr) {
	v__ast__TypeSymbol* left_typ = v__ast__Table_get_type_symbol(g->table, expr.left_type);
	if ((expr.index)._typ == 271 /* v.ast.RangeExpr */) {
		v__gen__js__JsGen_expr(g, expr.left);
		v__gen__js__JsGen_write(g, _SLIT(".slice("));
		if ((*expr.index._v__ast__RangeExpr).has_low) {
			v__gen__js__JsGen_expr(g, (*expr.index._v__ast__RangeExpr).low);
		} else {
			v__gen__js__JsGen_write(g, _SLIT("0"));
		}
		v__gen__js__JsGen_write(g, _SLIT(", "));
		if ((*expr.index._v__ast__RangeExpr).has_high) {
			v__gen__js__JsGen_expr(g, (*expr.index._v__ast__RangeExpr).high);
		} else {
			v__gen__js__JsGen_expr(g, expr.left);
			v__gen__js__JsGen_write(g, _SLIT(".length"));
		}
		v__gen__js__JsGen_write(g, _SLIT(")"));
	} else if (left_typ->kind == v__ast__Kind_map) {
		v__gen__js__JsGen_expr(g, expr.left);
		if (expr.is_setter) {
			g->inside_map_set = true;
			v__gen__js__JsGen_write(g, _SLIT(".set("));
		} else {
			v__gen__js__JsGen_write(g, _SLIT(".get("));
		}
		v__gen__js__JsGen_expr(g, expr.index);
		v__gen__js__JsGen_write(g, _SLIT(".toString()"));
		if (!expr.is_setter) {
			v__gen__js__JsGen_write(g, _SLIT(")"));
		}
	} else if (left_typ->kind == v__ast__Kind_string) {
		if (expr.is_setter) {
		} else {
			v__gen__js__JsGen_expr(g, expr.left);
			v__gen__js__JsGen_write(g, _SLIT(".str.charCodeAt("));
			v__gen__js__JsGen_expr(g, expr.index);
			v__gen__js__JsGen_write(g, _SLIT(")"));
		}
	} else {
		v__gen__js__JsGen_expr(g, expr.left);
		v__gen__js__JsGen_write(g, _SLIT("["));
		array_push(&g->cast_stack, _MOV((v__ast__Type[]){ _const_v__ast__int_type_idx }));
		v__gen__js__JsGen_expr(g, expr.index);
		array_delete_last(&g->cast_stack);
		v__gen__js__JsGen_write(g, _SLIT("]"));
	}
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_infix_expr(v__gen__js__JsGen* g, v__ast__InfixExpr it) {
	v__ast__TypeSymbol* l_sym = v__ast__Table_get_type_symbol(g->table, it.left_type);
	v__ast__TypeSymbol* r_sym = v__ast__Table_get_type_symbol(g->table, it.right_type);
	bool is_not = (it.op == v__token__Kind_not_in || it.op == v__token__Kind_not_is || it.op == v__token__Kind_ne);
	if (is_not) {
		v__gen__js__JsGen_write(g, _SLIT("!("));
	}
	if (it.op == v__token__Kind_eq || it.op == v__token__Kind_ne) {
		if ((Array_v__ast__Kind_contains(_const_v__gen__js__shallow_equatables, l_sym->kind)) && (Array_v__ast__Kind_contains(_const_v__gen__js__shallow_equatables, r_sym->kind))) {
			v__gen__js__JsGen_expr(g, it.left);
			v__gen__js__JsGen_write(g, _SLIT(".eq("));
			array_push(&g->cast_stack, _MOV((v__ast__Type[]){ ((int)(l_sym->kind)) }));
			v__gen__js__JsGen_expr(g, it.right);
			array_delete_last(&g->cast_stack);
			v__gen__js__JsGen_write(g, _SLIT(")"));
		} else {
			v__gen__js__JsGen_write(g, _SLIT("vEq("));
			v__gen__js__JsGen_expr(g, it.left);
			v__gen__js__JsGen_write(g, _SLIT(", "));
			v__gen__js__JsGen_expr(g, it.right);
			v__gen__js__JsGen_write(g, _SLIT(")"));
		}
	} else if (l_sym->kind == v__ast__Kind_array && it.op == v__token__Kind_left_shift) {
		v__gen__js__JsGen_expr(g, it.left);
		v__gen__js__JsGen_write(g, _SLIT(".push("));
		if (r_sym->kind == v__ast__Kind_array) {
			v__gen__js__JsGen_write(g, _SLIT("..."));
		}
		v__gen__js__JsGen_expr(g, it.right);
		v__gen__js__JsGen_write(g, _SLIT(")"));
	} else if ((r_sym->kind == v__ast__Kind_array || r_sym->kind == v__ast__Kind_map || r_sym->kind == v__ast__Kind_string) && (it.op == v__token__Kind_key_in || it.op == v__token__Kind_not_in)) {
		v__gen__js__JsGen_expr(g, it.right);
		if (r_sym->kind == v__ast__Kind_map) {
			v__gen__js__JsGen_write(g, _SLIT(".has("));
		} else if (r_sym->kind == v__ast__Kind_string) {
			v__gen__js__JsGen_write(g, _SLIT(".str.includes("));
		} else {
			v__gen__js__JsGen_write(g, _SLIT(".includes("));
		}
		v__gen__js__JsGen_expr(g, it.left);
		if (l_sym->kind == v__ast__Kind_string) {
			v__gen__js__JsGen_write(g, _SLIT(".str"));
		}
		v__gen__js__JsGen_write(g, _SLIT(")"));
	} else if ((it.op == v__token__Kind_key_is || it.op == v__token__Kind_not_is)) {
		v__gen__js__JsGen_expr(g, it.left);
		v__gen__js__JsGen_write(g, _SLIT(" instanceof "));
		v__gen__js__JsGen_write(g, v__gen__js__JsGen_typ(g, it.right_type));
	} else {
		bool is_arithmetic = (it.op == v__token__Kind_plus || it.op == v__token__Kind_minus || it.op == v__token__Kind_mul || it.op == v__token__Kind_div || it.op == v__token__Kind_mod);
		bool needs_cast = is_arithmetic && !v__ast__Type_alias_eq(it.left_type, it.right_type);
		int greater_typ = 0;
		if (needs_cast) {
			greater_typ = v__gen__js__JsGen_greater_typ(g, it.left_type, it.right_type);
			if (g->cast_stack.len > 0) {
				needs_cast = (*(v__ast__Type*)array_last(g->cast_stack)) != greater_typ;
			}
		}
		if (needs_cast) {
			if (string_eq(g->ns->name, _SLIT("builtin"))) {
				v__gen__js__JsGen_write(g, _SLIT("new "));
			}
			v__gen__js__JsGen_write(g, _STR("%.*s\000(", 2, v__gen__js__JsGen_typ(g, greater_typ)));
			array_push(&g->cast_stack, _MOV((v__ast__Type[]){ greater_typ }));
		}
		v__gen__js__JsGen_expr(g, it.left);
		v__gen__js__JsGen_write(g, _STR(" %.*s\000 ", 2, v__token__Kind_str(it.op)));
		v__gen__js__JsGen_expr(g, it.right);
		if (needs_cast) {
			array_delete_last(&g->cast_stack);
			v__gen__js__JsGen_write(g, _SLIT(")"));
		}
	}
	if (is_not) {
		v__gen__js__JsGen_write(g, _SLIT(")"));
	}
}

VV_LOCAL_SYMBOL v__ast__Type v__gen__js__JsGen_greater_typ(v__gen__js__JsGen* g, v__ast__Type left, v__ast__Type right) {
	int l = ((int)(left));
	int r = ((int)(right));
	Array_int lr = new_array_from_c_array(2, 2, sizeof(int), _MOV((int[2]){l, r}));
	if ((Array_int_contains(lr, _const_v__ast__string_type_idx))) {
		 v__ast__Type _t3314 = ((v__ast__Type)(_const_v__ast__string_type_idx));
		// autofree_scope_vars(pos=32313 line_nr=1486 scope.pos=32310 scope.end_pos=32352)
		// af parent scope:
		// var "g" var.pos=32170 var.line_nr=1481
		// var "left" var.pos=32191 var.line_nr=1481
		// var "right" var.pos=32206 var.line_nr=1481
		// var "l" var.pos=32234 var.line_nr=1482
		// var "r" var.pos=32250 var.line_nr=1483
		// var "lr" var.pos=32267 var.line_nr=1484
		// var "should_float" var.pos=32355 var.line_nr=1488
		// var "should_int" var.pos=32697 var.line_nr=1499
		// af parent scope:
		// af parent scope:
		return _t3314;
	}
	bool should_float = ((Array_int_contains(_const_v__ast__integer_type_idxs, l)) && (Array_int_contains(_const_v__ast__float_type_idxs, r))) || ((Array_int_contains(_const_v__ast__integer_type_idxs, r)) && (Array_int_contains(_const_v__ast__float_type_idxs, l)));
	if (should_float) {
		if ((Array_int_contains(lr, _const_v__ast__f64_type_idx))) {
			 v__ast__Type _t3315 = ((v__ast__Type)(_const_v__ast__f64_type_idx));
			// autofree_scope_vars(pos=32541 line_nr=1492 scope.pos=32537 scope.end_pos=32578)
			// af parent scope:
			// af parent scope:
			// var "g" var.pos=32170 var.line_nr=1481
			// var "left" var.pos=32191 var.line_nr=1481
			// var "right" var.pos=32206 var.line_nr=1481
			// var "l" var.pos=32234 var.line_nr=1482
			// var "r" var.pos=32250 var.line_nr=1483
			// var "lr" var.pos=32267 var.line_nr=1484
			// var "should_float" var.pos=32355 var.line_nr=1488
			// var "should_int" var.pos=32697 var.line_nr=1499
			// af parent scope:
			// af parent scope:
			return _t3315;
		}
		if ((Array_int_contains(lr, _const_v__ast__f32_type_idx))) {
			 v__ast__Type _t3316 = ((v__ast__Type)(_const_v__ast__f32_type_idx));
			// autofree_scope_vars(pos=32612 line_nr=1495 scope.pos=32608 scope.end_pos=32649)
			// af parent scope:
			// af parent scope:
			// var "g" var.pos=32170 var.line_nr=1481
			// var "left" var.pos=32191 var.line_nr=1481
			// var "right" var.pos=32206 var.line_nr=1481
			// var "l" var.pos=32234 var.line_nr=1482
			// var "r" var.pos=32250 var.line_nr=1483
			// var "lr" var.pos=32267 var.line_nr=1484
			// var "should_float" var.pos=32355 var.line_nr=1488
			// var "should_int" var.pos=32697 var.line_nr=1499
			// af parent scope:
			// af parent scope:
			return _t3316;
		}
		 v__ast__Type _t3317 = ((v__ast__Type)(_const_v__ast__float_literal_type));
		// autofree_scope_vars(pos=32652 line_nr=1497 scope.pos=32507 scope.end_pos=32694)
		// af parent scope:
		// var "g" var.pos=32170 var.line_nr=1481
		// var "left" var.pos=32191 var.line_nr=1481
		// var "right" var.pos=32206 var.line_nr=1481
		// var "l" var.pos=32234 var.line_nr=1482
		// var "r" var.pos=32250 var.line_nr=1483
		// var "lr" var.pos=32267 var.line_nr=1484
		// var "should_float" var.pos=32355 var.line_nr=1488
		// var "should_int" var.pos=32697 var.line_nr=1499
		// af parent scope:
		// af parent scope:
		return _t3317;
	}
	bool should_int = ((Array_int_contains(_const_v__ast__integer_type_idxs, l)) && (Array_int_contains(_const_v__ast__integer_type_idxs, r)));
	if (should_int) {
		if ((Array_int_contains(lr, _const_v__ast__i64_type_idx))) {
			 v__ast__Type _t3318 = ((v__ast__Type)(_const_v__ast__i64_type_idx));
			// autofree_scope_vars(pos=32938 line_nr=1504 scope.pos=32934 scope.end_pos=32975)
			// af parent scope:
			// af parent scope:
			// var "g" var.pos=32170 var.line_nr=1481
			// var "left" var.pos=32191 var.line_nr=1481
			// var "right" var.pos=32206 var.line_nr=1481
			// var "l" var.pos=32234 var.line_nr=1482
			// var "r" var.pos=32250 var.line_nr=1483
			// var "lr" var.pos=32267 var.line_nr=1484
			// var "should_float" var.pos=32355 var.line_nr=1488
			// var "should_int" var.pos=32697 var.line_nr=1499
			// af parent scope:
			// af parent scope:
			return _t3318;
		}
		if ((Array_int_contains(lr, _const_v__ast__u32_type_idx))) {
			 v__ast__Type _t3319 = ((v__ast__Type)(_const_v__ast__u32_type_idx));
			// autofree_scope_vars(pos=33009 line_nr=1507 scope.pos=33005 scope.end_pos=33046)
			// af parent scope:
			// af parent scope:
			// var "g" var.pos=32170 var.line_nr=1481
			// var "left" var.pos=32191 var.line_nr=1481
			// var "right" var.pos=32206 var.line_nr=1481
			// var "l" var.pos=32234 var.line_nr=1482
			// var "r" var.pos=32250 var.line_nr=1483
			// var "lr" var.pos=32267 var.line_nr=1484
			// var "should_float" var.pos=32355 var.line_nr=1488
			// var "should_int" var.pos=32697 var.line_nr=1499
			// af parent scope:
			// af parent scope:
			return _t3319;
		}
		if ((Array_int_contains(lr, _const_v__ast__int_type_idx))) {
			 v__ast__Type _t3320 = ((v__ast__Type)(_const_v__ast__int_type_idx));
			// autofree_scope_vars(pos=33080 line_nr=1510 scope.pos=33076 scope.end_pos=33117)
			// af parent scope:
			// af parent scope:
			// var "g" var.pos=32170 var.line_nr=1481
			// var "left" var.pos=32191 var.line_nr=1481
			// var "right" var.pos=32206 var.line_nr=1481
			// var "l" var.pos=32234 var.line_nr=1482
			// var "r" var.pos=32250 var.line_nr=1483
			// var "lr" var.pos=32267 var.line_nr=1484
			// var "should_float" var.pos=32355 var.line_nr=1488
			// var "should_int" var.pos=32697 var.line_nr=1499
			// af parent scope:
			// af parent scope:
			return _t3320;
		}
		if ((Array_int_contains(lr, _const_v__ast__u16_type_idx))) {
			 v__ast__Type _t3321 = ((v__ast__Type)(_const_v__ast__u16_type_idx));
			// autofree_scope_vars(pos=33151 line_nr=1513 scope.pos=33147 scope.end_pos=33188)
			// af parent scope:
			// af parent scope:
			// var "g" var.pos=32170 var.line_nr=1481
			// var "left" var.pos=32191 var.line_nr=1481
			// var "right" var.pos=32206 var.line_nr=1481
			// var "l" var.pos=32234 var.line_nr=1482
			// var "r" var.pos=32250 var.line_nr=1483
			// var "lr" var.pos=32267 var.line_nr=1484
			// var "should_float" var.pos=32355 var.line_nr=1488
			// var "should_int" var.pos=32697 var.line_nr=1499
			// af parent scope:
			// af parent scope:
			return _t3321;
		}
		if ((Array_int_contains(lr, _const_v__ast__i16_type_idx))) {
			 v__ast__Type _t3322 = ((v__ast__Type)(_const_v__ast__i16_type_idx));
			// autofree_scope_vars(pos=33222 line_nr=1516 scope.pos=33218 scope.end_pos=33259)
			// af parent scope:
			// af parent scope:
			// var "g" var.pos=32170 var.line_nr=1481
			// var "left" var.pos=32191 var.line_nr=1481
			// var "right" var.pos=32206 var.line_nr=1481
			// var "l" var.pos=32234 var.line_nr=1482
			// var "r" var.pos=32250 var.line_nr=1483
			// var "lr" var.pos=32267 var.line_nr=1484
			// var "should_float" var.pos=32355 var.line_nr=1488
			// var "should_int" var.pos=32697 var.line_nr=1499
			// af parent scope:
			// af parent scope:
			return _t3322;
		}
		if ((Array_int_contains(lr, _const_v__ast__byte_type_idx))) {
			 v__ast__Type _t3323 = ((v__ast__Type)(_const_v__ast__byte_type_idx));
			// autofree_scope_vars(pos=33294 line_nr=1519 scope.pos=33290 scope.end_pos=33332)
			// af parent scope:
			// af parent scope:
			// var "g" var.pos=32170 var.line_nr=1481
			// var "left" var.pos=32191 var.line_nr=1481
			// var "right" var.pos=32206 var.line_nr=1481
			// var "l" var.pos=32234 var.line_nr=1482
			// var "r" var.pos=32250 var.line_nr=1483
			// var "lr" var.pos=32267 var.line_nr=1484
			// var "should_float" var.pos=32355 var.line_nr=1488
			// var "should_int" var.pos=32697 var.line_nr=1499
			// af parent scope:
			// af parent scope:
			return _t3323;
		}
		if ((Array_int_contains(lr, _const_v__ast__i8_type_idx))) {
			 v__ast__Type _t3324 = ((v__ast__Type)(_const_v__ast__i8_type_idx));
			// autofree_scope_vars(pos=33365 line_nr=1522 scope.pos=33361 scope.end_pos=33401)
			// af parent scope:
			// af parent scope:
			// var "g" var.pos=32170 var.line_nr=1481
			// var "left" var.pos=32191 var.line_nr=1481
			// var "right" var.pos=32206 var.line_nr=1481
			// var "l" var.pos=32234 var.line_nr=1482
			// var "r" var.pos=32250 var.line_nr=1483
			// var "lr" var.pos=32267 var.line_nr=1484
			// var "should_float" var.pos=32355 var.line_nr=1488
			// var "should_int" var.pos=32697 var.line_nr=1499
			// af parent scope:
			// af parent scope:
			return _t3324;
		}
		 v__ast__Type _t3325 = ((v__ast__Type)(_const_v__ast__int_literal_type_idx));
		// autofree_scope_vars(pos=33404 line_nr=1524 scope.pos=32785 scope.end_pos=33448)
		// af parent scope:
		// var "g" var.pos=32170 var.line_nr=1481
		// var "left" var.pos=32191 var.line_nr=1481
		// var "right" var.pos=32206 var.line_nr=1481
		// var "l" var.pos=32234 var.line_nr=1482
		// var "r" var.pos=32250 var.line_nr=1483
		// var "lr" var.pos=32267 var.line_nr=1484
		// var "should_float" var.pos=32355 var.line_nr=1488
		// var "should_int" var.pos=32697 var.line_nr=1499
		// af parent scope:
		// af parent scope:
		return _t3325;
	}
	 v__ast__Type _t3326 = ((l));
	// autofree_scope_vars(pos=33450 line_nr=1526 scope.pos=32165 scope.end_pos=33470)
	// var "g" var.pos=32170 var.line_nr=1481
	// var "left" var.pos=32191 var.line_nr=1481
	// var "right" var.pos=32206 var.line_nr=1481
	// var "l" var.pos=32234 var.line_nr=1482
	// var "r" var.pos=32250 var.line_nr=1483
	// var "lr" var.pos=32267 var.line_nr=1484
	// var "should_float" var.pos=32355 var.line_nr=1488
	// var "should_int" var.pos=32697 var.line_nr=1499
	// af parent scope:
	// af parent scope:
	return _t3326;
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_map_init_expr(v__gen__js__JsGen* g, v__ast__MapInit it) {
	if (it.vals.len > 0) {
		v__gen__js__JsGen_writeln(g, _SLIT("new Map(["));
		v__gen__js__JsGen_inc_indent(g);
		// FOR IN array
		for (int i = 0; i < it.keys.len; ++i) {
			v__ast__Expr key = ((v__ast__Expr*)it.keys.data)[i];
			v__ast__Expr val = (*(v__ast__Expr*)/*ee elem_typ */array_get(it.vals, i));
			v__gen__js__JsGen_write(g, _SLIT("["));
			v__gen__js__JsGen_expr(g, key);
			v__gen__js__JsGen_write(g, _SLIT(", "));
			v__gen__js__JsGen_expr(g, val);
			v__gen__js__JsGen_write(g, _SLIT("]"));
			if (i < it.keys.len - 1) {
				v__gen__js__JsGen_write(g, _SLIT(","));
			}
			v__gen__js__JsGen_writeln(g, _SLIT(""));
		}
		v__gen__js__JsGen_dec_indent(g);
		v__gen__js__JsGen_write(g, _SLIT("])"));
	} else {
		v__gen__js__JsGen_write(g, _SLIT("new Map()"));
	}
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_selector_expr(v__gen__js__JsGen* g, v__ast__SelectorExpr it) {
	v__gen__js__JsGen_expr(g, it.expr);
	v__gen__js__JsGen_write(g, _STR(".%.*s", 1, it.field_name));
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_string_inter_literal(v__gen__js__JsGen* g, v__ast__StringInterLiteral it) {
	bool should_cast = !(g->cast_stack.len > 0 && (*(v__ast__Type*)array_last(g->cast_stack)) == _const_v__ast__string_type_idx);
	if (should_cast) {
		if (string_eq(g->file.mod.name, _SLIT("builtin"))) {
			v__gen__js__JsGen_write(g, _SLIT("new "));
		}
		v__gen__js__JsGen_write(g, _SLIT("string("));
	}
	v__gen__js__JsGen_write(g, _SLIT("`"));
	// FOR IN array
	for (int i = 0; i < it.vals.len; ++i) {
		string val = ((string*)it.vals.data)[i];
		string escaped_val = string_replace(val, _SLIT("`"), _SLIT("\\`"));
		v__gen__js__JsGen_write(g, escaped_val);
		if (i >= it.exprs.len) {
			continue;
		}
		v__ast__Expr expr = (*(v__ast__Expr*)/*ee elem_typ */array_get(it.exprs, i));
		byte fmt = (*(byte*)/*ee elem_typ */array_get(it.fmts, i));
		int fwidth = (*(int*)/*ee elem_typ */array_get(it.fwidths, i));
		int precision = (*(int*)/*ee elem_typ */array_get(it.precisions, i));
		v__gen__js__JsGen_write(g, _SLIT("${"));
		if (fmt != L'_' || fwidth != 0 || precision != 987698) {
			v__gen__js__JsGen_expr(g, expr);
		} else {
			v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, (*(v__ast__Type*)/*ee elem_typ */array_get(it.expr_types, i)));
			v__gen__js__JsGen_expr(g, expr);
			if (sym->kind == v__ast__Kind_struct_ && v__ast__TypeSymbol_has_method(sym, _SLIT("str"))) {
				v__gen__js__JsGen_write(g, _SLIT(".str()"));
			}
		}
		v__gen__js__JsGen_write(g, _SLIT("}"));
	}
	v__gen__js__JsGen_write(g, _SLIT("`"));
	if (should_cast) {
		v__gen__js__JsGen_write(g, _SLIT(")"));
	}
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_string_literal(v__gen__js__JsGen* g, v__ast__StringLiteral it) {
	string text = string_replace(it.val, _SLIT("'"), _SLIT("\\'"));
	bool should_cast = !(g->cast_stack.len > 0 && (*(v__ast__Type*)array_last(g->cast_stack)) == _const_v__ast__string_type_idx);
	if (should_cast) {
		if (string_eq(g->file.mod.name, _SLIT("builtin"))) {
			v__gen__js__JsGen_write(g, _SLIT("new "));
		}
		v__gen__js__JsGen_write(g, _SLIT("string("));
	}
	v__gen__js__JsGen_write(g, _STR("'%.*s\000'", 2, text));
	if (should_cast) {
		v__gen__js__JsGen_write(g, _SLIT(")"));
	}
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_struct_init(v__gen__js__JsGen* g, v__ast__StructInit it) {
	v__ast__TypeSymbol* type_sym = v__ast__Table_get_type_symbol(g->table, it.typ);
	string name = type_sym->name;
	if (it.fields.len == 0) {
		v__gen__js__JsGen_write(g, _STR("new %.*s\000({})", 2, v__gen__js__JsGen_js_name(g, name)));
	} else {
		v__gen__js__JsGen_writeln(g, _STR("new %.*s\000({", 2, v__gen__js__JsGen_js_name(g, name)));
		v__gen__js__JsGen_inc_indent(g);
		// FOR IN array
		for (int i = 0; i < it.fields.len; ++i) {
			v__ast__StructInitField field = ((v__ast__StructInitField*)it.fields.data)[i];
			v__gen__js__JsGen_write(g, _STR("%.*s\000: ", 2, field.name));
			v__gen__js__JsGen_expr(g, field.expr);
			if (i < it.fields.len - 1) {
				v__gen__js__JsGen_write(g, _SLIT(","));
			}
			v__gen__js__JsGen_writeln(g, _SLIT(""));
		}
		v__gen__js__JsGen_dec_indent(g);
		v__gen__js__JsGen_write(g, _SLIT("})"));
	}
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_typeof_expr(v__gen__js__JsGen* g, v__ast__TypeOf it) {
	v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, it.expr_type);
	if (sym->kind == v__ast__Kind_sum_type) {
	} else if (sym->kind == v__ast__Kind_array_fixed) {
		v__ast__ArrayFixed fixed_info = /* as */ *(v__ast__ArrayFixed*)__as_cast((sym->info)._v__ast__ArrayFixed,(sym->info)._typ, 416) /*expected idx: 416, name: v.ast.ArrayFixed */ ;
		string typ_name = v__ast__Table_get_type_name(g->table, fixed_info.elem_type);
		v__gen__js__JsGen_write(g, _STR("\"[%"PRId32"\000]%.*s\000\"", 3, fixed_info.size, typ_name));
	} else if (sym->kind == v__ast__Kind_function) {
		v__ast__FnType info = /* as */ *(v__ast__FnType*)__as_cast((sym->info)._v__ast__FnType,(sym->info)._typ, 418) /*expected idx: 418, name: v.ast.FnType */ ;
		v__ast__Fn fn_info = info.func;
		string repr = _SLIT("fn (");
		// FOR IN array
		for (int i = 0; i < fn_info.params.len; ++i) {
			v__ast__Param arg = ((v__ast__Param*)fn_info.params.data)[i];
			if (i > 0) {
				repr = /*f*/string_add(repr, _SLIT(", "));
			}
			repr = /*f*/string_add(repr, v__ast__Table_get_type_name(g->table, arg.typ));
		}
		repr = /*f*/string_add(repr, _SLIT(")"));
		if (!v__ast__Type_alias_eq(fn_info.return_type, _const_v__ast__void_type)) {
			repr = /*f*/string_add(repr, _STR(" %.*s", 1, v__ast__Table_get_type_name(g->table, fn_info.return_type)));
		}
		v__gen__js__JsGen_write(g, _STR("\"%.*s\000\"", 2, repr));
	} else {
		v__gen__js__JsGen_write(g, _STR("\"%.*s\000\"", 2, sym->name));
	}
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_type_cast_expr(v__gen__js__JsGen* g, v__ast__CastExpr it) {
	bool is_literal = (((it.expr)._typ == 259 /* v.ast.IntegerLiteral */ && (Array_int_contains(_const_v__ast__integer_type_idxs, it.typ))) || ((it.expr)._typ == 252 /* v.ast.FloatLiteral */ && (Array_int_contains(_const_v__ast__float_type_idxs, it.typ))));
	if (g->cast_stack.len > 0 && is_literal) {
		if (v__ast__Type_alias_eq(it.typ, (*(v__ast__Type*)/*ee elem_typ */array_get(g->cast_stack, g->cast_stack.len - 1)))) {
			return;
		}
	}
	array_push(&g->cast_stack, _MOV((v__ast__Type[]){ it.typ }));
	string typ = v__gen__js__JsGen_typ(g, it.typ);
	if (!is_literal) {
		if (!(Array_string_contains(_const_v__gen__js__v_types, typ)) || string_eq(g->ns->name, _SLIT("builtin"))) {
			v__gen__js__JsGen_write(g, _SLIT("new "));
		}
		v__gen__js__JsGen_write(g, _STR("%.*s\000(", 2, typ));
	}
	v__gen__js__JsGen_expr(g, it.expr);
	if (string_eq(typ, _SLIT("string")) && (it.expr)._typ != 277 /* v.ast.StringLiteral */) {
		v__gen__js__JsGen_write(g, _SLIT(".toString()"));
	}
	if (!is_literal) {
		v__gen__js__JsGen_write(g, _SLIT(")"));
	}
	array_delete_last(&g->cast_stack);
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_integer_literal_expr(v__gen__js__JsGen* g, v__ast__IntegerLiteral it) {
	v__ast__Type typ = ((v__ast__Type)(_const_v__ast__int_type));
	if (g->call_stack.len > 0) {
		v__ast__CallExpr call = (*(v__ast__CallExpr*)/*ee elem_typ */array_get(g->call_stack, g->call_stack.len - 1));
		// FOR IN array
		for (int _t3328 = 0; _t3328 < call.args.len; ++_t3328) {
			v__ast__CallArg t = ((v__ast__CallArg*)call.args.data)[_t3328];
			if ((t.expr)._typ == 259 /* v.ast.IntegerLiteral */) {
				if (v__ast__IntegerLiteral_struct_eq((*t.expr._v__ast__IntegerLiteral), it)) {
					v__gen__js__JsGen_write(g, it.val);
					return;
				}
			}
		}
	}
	if (g->cast_stack.len > 0) {
		if ((Array_int_contains(_const_v__ast__integer_type_idxs, (*(v__ast__Type*)/*ee elem_typ */array_get(g->cast_stack, g->cast_stack.len - 1))))) {
			v__gen__js__JsGen_write(g, _STR("%.*s", 1, it.val));
			return;
		}
	}
	if (string_eq(g->ns->name, _SLIT("builtin"))) {
		v__gen__js__JsGen_write(g, _SLIT("new "));
	}
	v__gen__js__JsGen_write(g, _STR("%.*s\000(%.*s\000)", 3, v__gen__js__JsGen_typ(g, typ), it.val));
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_float_literal_expr(v__gen__js__JsGen* g, v__ast__FloatLiteral it) {
	v__ast__Type typ = ((v__ast__Type)(_const_v__ast__f32_type));
	if (g->call_stack.len > 0) {
		v__ast__CallExpr call = (*(v__ast__CallExpr*)/*ee elem_typ */array_get(g->call_stack, g->call_stack.len - 1));
		// FOR IN array
		for (int i = 0; i < call.args.len; ++i) {
			v__ast__CallArg t = ((v__ast__CallArg*)call.args.data)[i];
			if ((t.expr)._typ == 252 /* v.ast.FloatLiteral */) {
				if (v__ast__FloatLiteral_struct_eq((*t.expr._v__ast__FloatLiteral), it)) {
					if ((Array_int_contains(_const_v__ast__integer_type_idxs, (*(v__ast__Type*)/*ee elem_typ */array_get(call.expected_arg_types, i))))) {
						v__gen__js__JsGen_write(g, int_str(((int)(string_f64(it.val)))));
					} else {
						v__gen__js__JsGen_write(g, it.val);
					}
					return;
				}
			}
		}
	}
	if (g->cast_stack.len > 0) {
		if ((Array_int_contains(_const_v__ast__float_type_idxs, (*(v__ast__Type*)/*ee elem_typ */array_get(g->cast_stack, g->cast_stack.len - 1))))) {
			v__gen__js__JsGen_write(g, _STR("%.*s", 1, it.val));
			return;
		} else if ((Array_int_contains(_const_v__ast__integer_type_idxs, (*(v__ast__Type*)/*ee elem_typ */array_get(g->cast_stack, g->cast_stack.len - 1))))) {
			v__gen__js__JsGen_write(g, int_str(((int)(string_f64(it.val)))));
			return;
		}
	}
	if (string_eq(g->ns->name, _SLIT("builtin"))) {
		v__gen__js__JsGen_write(g, _SLIT("new "));
	}
	v__gen__js__JsGen_write(g, _STR("%.*s\000(%.*s\000)", 3, v__gen__js__JsGen_typ(g, typ), it.val));
}

VV_LOCAL_SYMBOL v__gen__js__JsDoc* v__gen__js__new_jsdoc(v__gen__js__JsGen* gen) {
	 v__gen__js__JsDoc* _t3329 = (v__gen__js__JsDoc*)memdup(&(v__gen__js__JsDoc){.gen = gen,}, sizeof(v__gen__js__JsDoc));
	// autofree_scope_vars(pos=94 line_nr=10 scope.pos=63 scope.end_pos=124)
	// var "gen" var.pos=73 var.line_nr=9
	// af parent scope:
	// af parent scope:
	return _t3329;
}

VV_LOCAL_SYMBOL void v__gen__js__JsDoc_write(v__gen__js__JsDoc* d, string s) {
	if (!d->gen->enable_doc) {
		return;
	}
	v__gen__js__JsGen_write(d->gen, s);
}

VV_LOCAL_SYMBOL void v__gen__js__JsDoc_writeln(v__gen__js__JsDoc* d, string s) {
	if (!d->gen->enable_doc) {
		return;
	}
	v__gen__js__JsGen_writeln(d->gen, s);
}

VV_LOCAL_SYMBOL void v__gen__js__JsDoc_gen_typ(v__gen__js__JsDoc* d, string typ) {
	v__gen__js__JsDoc_writeln(d, _STR("/** @type {%.*s\000} */", 2, typ));
}

VV_LOCAL_SYMBOL void v__gen__js__JsDoc_gen_const(v__gen__js__JsDoc* d, string typ) {
	v__gen__js__JsDoc_writeln(d, _STR("/** @constant {%.*s\000} */", 2, typ));
}

VV_LOCAL_SYMBOL void v__gen__js__JsDoc_gen_enum(v__gen__js__JsDoc* d) {
	string typ = _SLIT("number");
	v__gen__js__JsDoc_writeln(d, _STR("/** @enum {%.*s\000} */", 2, typ));
}

VV_LOCAL_SYMBOL void v__gen__js__JsDoc_gen_fac_fn(v__gen__js__JsDoc* d, Array_v__ast__StructField fields) {
	v__gen__js__JsDoc_writeln(d, _SLIT("/**"));
	v__gen__js__JsDoc_writeln(d, _SLIT(" * @constructor"));
	v__gen__js__JsDoc_write(d, _SLIT(" * @param {{"));
	// FOR IN array
	for (int i = 0; i < fields.len; ++i) {
		v__ast__StructField field = ((v__ast__StructField*)fields.data)[i];
		v__gen__js__JsDoc_write(d, _STR("%.*s\000?: %.*s", 2, field.name, v__gen__js__JsGen_typ(d->gen, field.typ)));
		if (i < fields.len - 1) {
			v__gen__js__JsDoc_write(d, _SLIT(", "));
		}
	}
	v__gen__js__JsDoc_writeln(d, _SLIT("}} init"));
	v__gen__js__JsDoc_writeln(d, _SLIT("*/"));
}

VV_LOCAL_SYMBOL void v__gen__js__JsDoc_gen_fn(v__gen__js__JsDoc* d, v__ast__FnDecl it) {
	string type_name = v__gen__js__JsGen_typ(d->gen, it.return_type);
	v__gen__js__JsDoc_writeln(d, _SLIT("/**"));
	v__gen__js__JsDoc_writeln(d, _SLIT(" * @function"));
	if (it.is_deprecated) {
		v__gen__js__JsDoc_writeln(d, _SLIT(" * @deprecated"));
	}
	// FOR IN array
	for (int i = 0; i < it.params.len; ++i) {
		v__ast__Param arg = ((v__ast__Param*)it.params.data)[i];
		if ((it.is_method || it.receiver.typ == 0) && i == 0) {
			continue;
		}
		string arg_type_name = v__gen__js__JsGen_typ(d->gen, arg.typ);
		bool is_varg = i == it.params.len - 1 && it.is_variadic;
		string name = v__gen__js__JsGen_js_name(d->gen, arg.name);
		if (is_varg) {
			v__gen__js__JsDoc_writeln(d, _STR(" * @param {...%.*s\000} %.*s", 2, arg_type_name, name));
		} else {
			v__gen__js__JsDoc_writeln(d, _STR(" * @param {%.*s\000} %.*s", 2, arg_type_name, name));
		}
	}
	v__gen__js__JsDoc_writeln(d, _STR(" * @returns {%.*s\000}", 2, type_name));
	v__gen__js__JsDoc_writeln(d, _SLIT("*/"));
}

VV_LOCAL_SYMBOL void v__gen__js__JsDoc_gen_interface(v__gen__js__JsDoc* d, v__ast__InterfaceDecl it) {
	string name = v__gen__js__JsGen_js_name(d->gen, it.name);
	v__gen__js__JsDoc_writeln(d, _SLIT("/**"));
	v__gen__js__JsDoc_writeln(d, _STR(" * @interface %.*s", 1, name));
	v__gen__js__JsDoc_writeln(d, _STR(" * @typedef %.*s", 1, name));
	// FOR IN array
	for (int _t3330 = 0; _t3330 < it.methods.len; ++_t3330) {
		v__ast__FnDecl method = ((v__ast__FnDecl*)it.methods.data)[_t3330];
		string typ = v__gen__js__JsGen_fn_typ(d->gen, array_slice(method.params, 1, method.params.len), method.return_type);
		string method_name = v__gen__js__JsGen_js_name(d->gen, method.name);
		v__gen__js__JsDoc_writeln(d, _STR(" * @property {%.*s\000} %.*s", 2, typ, method_name));
	}
	v__gen__js__JsDoc_writeln(d, _SLIT(" */\n"));
}

void v__gen__x64__Gen_generate_elf_header(v__gen__x64__Gen* g) {
	_PUSH_MANY(&g->buf, (new_array_from_c_array(4, 4, sizeof(byte), _MOV((byte[4]){((byte)(_const_v__gen__x64__mag0)), _const_v__gen__x64__mag1, _const_v__gen__x64__mag2, _const_v__gen__x64__mag3}))), _t3331, Array_byte);
	array_push(&g->buf, _MOV((byte[]){ _const_v__gen__x64__elfclass64 }));
	array_push(&g->buf, _MOV((byte[]){ _const_v__gen__x64__elfdata2lsb }));
	array_push(&g->buf, _MOV((byte[]){ _const_v__gen__x64__ev_current }));
	array_push(&g->buf, _MOV((byte[]){ 1 }));
	v__gen__x64__Gen_write64(g, 0);
	v__gen__x64__Gen_write16(g, 2);
	v__gen__x64__Gen_write16(g, _const_v__gen__x64__e_machine);
	v__gen__x64__Gen_write32(g, _const_v__gen__x64__ev_current);
	int eh_size = 0x40;
	int phent_size = 0x38;
	v__gen__x64__Gen_write64(g, _const_v__gen__x64__segment_start + eh_size + phent_size);
	v__gen__x64__Gen_write64(g, 0x40);
	v__gen__x64__Gen_write64(g, 0);
	v__gen__x64__Gen_write32(g, 0);
	v__gen__x64__Gen_write16(g, eh_size);
	v__gen__x64__Gen_write16(g, phent_size);
	v__gen__x64__Gen_write16(g, 1);
	v__gen__x64__Gen_write16(g, 0);
	v__gen__x64__Gen_write16(g, 0);
	v__gen__x64__Gen_write16(g, 0);
	v__gen__x64__Gen_write32(g, 1);
	v__gen__x64__Gen_write32(g, 5);
	v__gen__x64__Gen_write64(g, 0);
	v__gen__x64__Gen_write64(g, _const_v__gen__x64__segment_start);
	v__gen__x64__Gen_write64(g, _const_v__gen__x64__segment_start);
	g->file_size_pos = ((i64)(g->buf.len));
	v__gen__x64__Gen_write64(g, 0);
	v__gen__x64__Gen_write64(g, 0);
	v__gen__x64__Gen_write64(g, 0x1000);
	println(_STR("code_start_pos = %.*s", 1, int_hex(g->buf.len)));
	g->code_start_pos = ((i64)(g->buf.len));
	g->debug_pos = g->buf.len;
	v__gen__x64__Gen_call(g, _const_v__gen__x64__placeholder);
	v__gen__x64__Gen_println(g, _SLIT("call fn main"));
}

void v__gen__x64__Gen_generate_elf_footer(v__gen__x64__Gen* g) {
	// FOR IN array
	for (int i = 0; i < g->strings.len; ++i) {
		string s = ((string*)g->strings.data)[i];
		v__gen__x64__Gen_write64_at(g, _const_v__gen__x64__segment_start + g->buf.len, ((int)((*(i64*)/*ee elem_typ */array_get(g->str_pos, i)))));
		v__gen__x64__Gen_write_string(g, s);
		v__gen__x64__Gen_write8(g, 0);
	}
	int file_size = g->buf.len;
	v__gen__x64__Gen_write64_at(g, file_size, g->file_size_pos);
	v__gen__x64__Gen_write64_at(g, file_size, g->file_size_pos + 8);
	v__gen__x64__Gen_write32_at(g, g->code_start_pos + 1, ((int)(g->main_fn_addr - g->code_start_pos)) - 5);
	Option_os__File _t3336 = os__create(g->out_name);
	if (_t3336.state != 0) { /*or block*/ 
		IError err = _t3336.err;
		v_panic(IError_str(err));
	}
 	os__File f =  *(os__File*)_t3336.data;
	os__chmod(g->out_name, 0775);
	os__File_write_ptr(&f, g->buf.data, g->buf.len);
	os__File_close(&f);
	if (g->pref->is_verbose) {
		println(_SLIT("\nx64 elf binary has been successfully generated"));
	}
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_section_header(v__gen__x64__Gen* g, v__gen__x64__SectionConfig c) {
	v__gen__x64__Gen_write32(g, g->sect_header_name_pos);
	g->sect_header_name_pos += c.name.len + 1;
	v__gen__x64__Gen_write32(g, ((int)(c.typ)));
	v__gen__x64__Gen_write64(g, c.flags);
	v__gen__x64__Gen_write64(g, 0);
	v__gen__x64__Gen_write64(g, g->offset);
	g->offset += c.datalen + 1;
	v__gen__x64__Gen_write64(g, c.datalen);
	v__gen__x64__Gen_write32(g, c.v_link);
	v__gen__x64__Gen_write32(g, c.info);
	v__gen__x64__Gen_write64(g, c.align);
	v__gen__x64__Gen_write64(g, c.entsize);
}

VV_LOCAL_SYMBOL void v__gen__x64__genobj(void) {
}

multi_return_int_int v__gen__x64__gen(Array_v__ast__File files, v__ast__Table* table, string out_name, v__pref__Preferences* pref) {
	v__gen__x64__Gen g = (v__gen__x64__Gen){.out_name = out_name,.pref = pref,.table = table,.buf = __new_array(0, 1, sizeof(byte)),.sect_header_name_pos = 0,.offset = 0,.str_pos = __new_array(0, 1, sizeof(i64)),.strings = __new_array(0, 1, sizeof(string)),.file_size_pos = 0,.main_fn_addr = 0,.code_start_pos = 0,.fn_addr = new_map(sizeof(string), sizeof(i64), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.var_offset = new_map(sizeof(string), sizeof(int), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.stack_var_pos = 0,.debug_pos = 0,.errors = __new_array(0, 1, sizeof(v__errors__Error)),.warnings = __new_array(0, 1, sizeof(v__errors__Warning)),.syms = __new_array(0, 1, sizeof(v__gen__x64__Symbol)),.relocs = __new_array(0, 1, sizeof(v__gen__x64__Reloc)),.nlines = 0,};
	if (!pref->is_verbose) {
		println(_SLIT("use `v -x64 -v ...` to print resulting asembly/machine code"));
	}
	v__gen__x64__Gen_generate_elf_header(&g);
	// FOR IN array
	for (int _t3337 = 0; _t3337 < files.len; ++_t3337) {
		v__ast__File file = ((v__ast__File*)files.data)[_t3337];
		v__gen__x64__Gen_stmts(&g, file.stmts);
	}
	v__gen__x64__Gen_generate_elf_footer(&g);
	return (multi_return_int_int){.arg0=g.nlines, .arg1=g.buf.len};
}

void v__gen__x64__Gen_stmts(v__gen__x64__Gen* g, Array_v__ast__Stmt stmts) {
	// FOR IN array
	for (int _t3338 = 0; _t3338 < stmts.len; ++_t3338) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)stmts.data)[_t3338];
		v__gen__x64__Gen_stmt(g, stmt);
	}
}

i64 v__gen__x64__Gen_pos(v__gen__x64__Gen* g) {
	 i64 _t3339 = g->buf.len;
	// autofree_scope_vars(pos=2136 line_nr=118 scope.pos=2115 scope.end_pos=2154)
	// var "g" var.pos=2116 var.line_nr=117
	// af parent scope:
	// af parent scope:
	return _t3339;
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_write8(v__gen__x64__Gen* g, int n) {
	array_push(&g->buf, _MOV((byte[]){ ((byte)(n)) }));
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_write16(v__gen__x64__Gen* g, int n) {
	array_push(&g->buf, _MOV((byte[]){ ((byte)(n)) }));
	array_push(&g->buf, _MOV((byte[]){ ((byte)(n >> 8)) }));
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_write32(v__gen__x64__Gen* g, int n) {
	array_push(&g->buf, _MOV((byte[]){ ((byte)(n)) }));
	array_push(&g->buf, _MOV((byte[]){ ((byte)(n >> 8)) }));
	array_push(&g->buf, _MOV((byte[]){ ((byte)(n >> 16)) }));
	array_push(&g->buf, _MOV((byte[]){ ((byte)(n >> 24)) }));
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_write64(v__gen__x64__Gen* g, i64 n) {
	array_push(&g->buf, _MOV((byte[]){ ((byte)(n)) }));
	array_push(&g->buf, _MOV((byte[]){ ((byte)(n >> 8)) }));
	array_push(&g->buf, _MOV((byte[]){ ((byte)(n >> 16)) }));
	array_push(&g->buf, _MOV((byte[]){ ((byte)(n >> 24)) }));
	array_push(&g->buf, _MOV((byte[]){ ((byte)(n >> 32)) }));
	array_push(&g->buf, _MOV((byte[]){ ((byte)(n >> 40)) }));
	array_push(&g->buf, _MOV((byte[]){ ((byte)(n >> 48)) }));
	array_push(&g->buf, _MOV((byte[]){ ((byte)(n >> 56)) }));
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_write64_at(v__gen__x64__Gen* g, i64 n, i64 at) {
	(*(byte*)/*ee elem_typ */array_get(g->buf, at)) = ((byte)(n));
	(*(byte*)/*ee elem_typ */array_get(g->buf, at + 1)) = ((byte)(n >> 8));
	(*(byte*)/*ee elem_typ */array_get(g->buf, at + 2)) = ((byte)(n >> 16));
	(*(byte*)/*ee elem_typ */array_get(g->buf, at + 3)) = ((byte)(n >> 24));
	(*(byte*)/*ee elem_typ */array_get(g->buf, at + 4)) = ((byte)(n >> 32));
	(*(byte*)/*ee elem_typ */array_get(g->buf, at + 5)) = ((byte)(n >> 40));
	(*(byte*)/*ee elem_typ */array_get(g->buf, at + 6)) = ((byte)(n >> 48));
	(*(byte*)/*ee elem_typ */array_get(g->buf, at + 7)) = ((byte)(n >> 56));
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_write32_at(v__gen__x64__Gen* g, i64 at, int n) {
	(*(byte*)/*ee elem_typ */array_get(g->buf, at)) = ((byte)(n));
	(*(byte*)/*ee elem_typ */array_get(g->buf, at + 1)) = ((byte)(n >> 8));
	(*(byte*)/*ee elem_typ */array_get(g->buf, at + 2)) = ((byte)(n >> 16));
	(*(byte*)/*ee elem_typ */array_get(g->buf, at + 3)) = ((byte)(n >> 24));
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_write_string(v__gen__x64__Gen* g, string s) {
	for (int _t3355 = 0; _t3355 < s.len; ++_t3355) {
		byte c = s.str[_t3355];
		v__gen__x64__Gen_write8(g, ((int)(c)));
	}
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_write_string_with_padding(v__gen__x64__Gen* g, string s, int max) {
	for (int _t3356 = 0; _t3356 < s.len; ++_t3356) {
		byte c = s.str[_t3356];
		v__gen__x64__Gen_write8(g, ((int)(c)));
	}
	for (int _t3357 = 0; _t3357 < max - s.len; ++_t3357) {
		v__gen__x64__Gen_write8(g, 0);
	}
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_inc(v__gen__x64__Gen* g, v__gen__x64__Register reg) {
	v__gen__x64__Gen_write16(g, 0xff49);

	if (reg == (v__gen__x64__Register_r12)) {
		v__gen__x64__Gen_write8(g, 0xc4);
	}
	else {
		v_panic(_STR("unhandled inc %.*s", 1, v__gen__x64__Register_str(reg)));
	};
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_cmp(v__gen__x64__Gen* g, v__gen__x64__Register reg, v__gen__x64__Size size, i64 val) {
	v__gen__x64__Gen_write8(g, 0x49);

	if (size == (v__gen__x64__Size__8)) {
		v__gen__x64__Gen_write8(g, 0x83);
	}
	else if (size == (v__gen__x64__Size__32)) {
		v__gen__x64__Gen_write8(g, 0x81);
	}
	else {
		v_panic(_SLIT("unhandled cmp"));
	};

	if (reg == (v__gen__x64__Register_r12)) {
		v__gen__x64__Gen_write8(g, 0xfc);
	}
	else {
		v_panic(_SLIT("unhandled cmp"));
	};
	v__gen__x64__Gen_write8(g, ((int)(val)));
}

VV_LOCAL_SYMBOL int v__gen__x64__Gen_get_var_offset(v__gen__x64__Gen* g, string var_name) {
	int offset = (*(int*)map_get(ADDR(map, g->var_offset), &(string[]){var_name}, &(int[]){ 0 }));
	if (offset == 0) {
		v_panic(_STR("0 offset for var `%.*s\000`", 2, var_name));
	}
	// autofree_scope_vars(pos=4068 line_nr=216 scope.pos=3923 scope.end_pos=4083)
	// var "g" var.pos=3928 var.line_nr=211
	// var "var_name" var.pos=3950 var.line_nr=211
	// var "offset" var.pos=3974 var.line_nr=212
	// af parent scope:
	// af parent scope:
	return offset;
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_cmp_var(v__gen__x64__Gen* g, string var_name, int val) {
	v__gen__x64__Gen_write8(g, 0x81);
	v__gen__x64__Gen_write8(g, 0x7d);
	int offset = v__gen__x64__Gen_get_var_offset(g, var_name);
	v__gen__x64__Gen_write8(g, 0xff - offset + 1);
	v__gen__x64__Gen_write32(g, val);
	v__gen__x64__Gen_println(g, _STR("cmp var `%.*s\000` %"PRId32"", 2, var_name, val));
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_inc_var(v__gen__x64__Gen* g, string var_name) {
	v__gen__x64__Gen_write16(g, 0x4581);
	int offset = v__gen__x64__Gen_get_var_offset(g, var_name);
	v__gen__x64__Gen_write8(g, 0xff - offset + 1);
	v__gen__x64__Gen_write32(g, 1);
	v__gen__x64__Gen_println(g, _STR("inc_var `%.*s\000`", 2, var_name));
}

VV_LOCAL_SYMBOL int v__gen__x64__Gen_jne(v__gen__x64__Gen* g) {
	v__gen__x64__Gen_write16(g, 0x850f);
	i64 pos = v__gen__x64__Gen_pos(g);
	v__gen__x64__Gen_write32(g, _const_v__gen__x64__placeholder);
	v__gen__x64__Gen_println(g, _SLIT("jne"));
	 int _t3358 = ((int)(pos));
	// autofree_scope_vars(pos=4744 line_nr=245 scope.pos=4643 scope.end_pos=4761)
	// var "g" var.pos=4648 var.line_nr=240
	// var "pos" var.pos=4687 var.line_nr=242
	// af parent scope:
	// af parent scope:
	return _t3358;
}

VV_LOCAL_SYMBOL int v__gen__x64__Gen_jge(v__gen__x64__Gen* g) {
	v__gen__x64__Gen_write16(g, 0x8d0f);
	i64 pos = v__gen__x64__Gen_pos(g);
	v__gen__x64__Gen_write32(g, _const_v__gen__x64__placeholder);
	v__gen__x64__Gen_println(g, _SLIT("jne"));
	 int _t3359 = ((int)(pos));
	// autofree_scope_vars(pos=4868 line_nr=253 scope.pos=4767 scope.end_pos=4885)
	// var "g" var.pos=4772 var.line_nr=248
	// var "pos" var.pos=4811 var.line_nr=250
	// af parent scope:
	// af parent scope:
	return _t3359;
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_jmp(v__gen__x64__Gen* g, int addr) {
	v__gen__x64__Gen_write8(g, 0xe9);
	v__gen__x64__Gen_write32(g, addr);
	v__gen__x64__Gen_println(g, _SLIT("jmp"));
}

VV_LOCAL_SYMBOL i64 v__gen__x64__abs(i64 a) {
	 i64 _t3360 = (a < 0 ? (-a) : (a));
	// autofree_scope_vars(pos=5005 line_nr=263 scope.pos=4988 scope.end_pos=5040)
	// var "a" var.pos=4992 var.line_nr=262
	// af parent scope:
	// af parent scope:
	return _t3360;
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_jle(v__gen__x64__Gen* g, i64 addr) {
	int offset = 0xff - ((int)(v__gen__x64__abs(addr - g->buf.len))) - 1;
	v__gen__x64__Gen_write8(g, 0x7e);
	v__gen__x64__Gen_write8(g, offset);
	v__gen__x64__Gen_println(g, _SLIT("jle"));
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_println(v__gen__x64__Gen* g, string comment) {
	g->nlines++;
	if (!g->pref->is_verbose) {
		return;
	}
	string addr = int_hex(g->debug_pos);
	print(term__red(string_add(string_add(strings__repeat(L'0', 6 - addr.len), addr), _SLIT("  "))));
	for (int i = g->debug_pos; i < g->buf.len; i++) {
		string s = byte_hex((*(byte*)/*ee elem_typ */array_get(g->buf, i)));
		if (s.len == 1) {
			print(term__blue(_SLIT("0")));
		}
		string gbihex = byte_hex((*(byte*)/*ee elem_typ */array_get(g->buf, i)));
		string hexstr = string_add(term__blue(gbihex), _SLIT(" "));
		print(hexstr);
	}
	g->debug_pos = g->buf.len;
	print(string_add(_SLIT(" "), comment));
	println(_SLIT(""));
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_jl(v__gen__x64__Gen* g, i64 addr) {
	int offset = 0xff - ((int)(v__gen__x64__abs(addr - g->buf.len))) - 1;
	v__gen__x64__Gen_write8(g, 0x7c);
	v__gen__x64__Gen_write8(g, offset);
	v__gen__x64__Gen_println(g, _SLIT("jl"));
}

VV_LOCAL_SYMBOL int v__gen__x64__Gen_abs_to_rel_addr(v__gen__x64__Gen* g, i64 addr) {
	 int _t3361 = ((int)(v__gen__x64__abs(addr - g->buf.len))) - 1;
	// autofree_scope_vars(pos=5910 line_nr=305 scope.pos=5869 scope.end_pos=5949)
	// var "g" var.pos=5870 var.line_nr=304
	// var "addr" var.pos=5894 var.line_nr=304
	// af parent scope:
	// af parent scope:
	return _t3361;
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_mov64(v__gen__x64__Gen* g, v__gen__x64__Register reg, i64 val) {

	if (reg == (v__gen__x64__Register_rsi)) {
		v__gen__x64__Gen_write8(g, 0x48);
		v__gen__x64__Gen_write8(g, 0xbe);
	}
	else {
		println(_STR("unhandled mov %.*s", 1, v__gen__x64__Register_str(reg)));
	};
	v__gen__x64__Gen_write64(g, val);
	v__gen__x64__Gen_println(g, _STR("mov64 %.*s\000, %"PRId64"", 2, v__gen__x64__Register_str(reg), val));
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_mov_reg_to_rbp(v__gen__x64__Gen* g, int var_offset, v__gen__x64__Register reg) {
	v__gen__x64__Gen_write8(g, 0x89);

	if (reg == (v__gen__x64__Register_eax) || reg == (v__gen__x64__Register_rax)) {
		v__gen__x64__Gen_write8(g, 0x45);
	}
	else if (reg == (v__gen__x64__Register_edi) || reg == (v__gen__x64__Register_rdi)) {
		v__gen__x64__Gen_write8(g, 0x7d);
	}
	else if (reg == (v__gen__x64__Register_rsi)) {
		v__gen__x64__Gen_write8(g, 0x75);
	}
	else if (reg == (v__gen__x64__Register_rdx)) {
		v__gen__x64__Gen_write8(g, 0x55);
	}
	else if (reg == (v__gen__x64__Register_rcx)) {
		v__gen__x64__Gen_write8(g, 0x4d);
	}
	else {
		v__gen__x64__verror(_STR("mov_from_reg %.*s", 1, v__gen__x64__Register_str(reg)));
	};
	v__gen__x64__Gen_write8(g, 0xff - var_offset + 1);
	v__gen__x64__Gen_println(g, _STR("mov DWORD PTR[rbp-%.*s\000],%.*s", 2, int_hex2(var_offset), v__gen__x64__Register_str(reg)));
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_mov_var_to_reg(v__gen__x64__Gen* g, v__gen__x64__Register reg, int var_offset) {
	v__gen__x64__Gen_write8(g, 0x8b);

	if (reg == (v__gen__x64__Register_eax) || reg == (v__gen__x64__Register_rax)) {
		v__gen__x64__Gen_write8(g, 0x45);
	}
	else if (reg == (v__gen__x64__Register_edi) || reg == (v__gen__x64__Register_rdi)) {
		v__gen__x64__Gen_write8(g, 0x7d);
	}
	else if (reg == (v__gen__x64__Register_rsi)) {
		v__gen__x64__Gen_write8(g, 0x75);
	}
	else if (reg == (v__gen__x64__Register_rdx)) {
		v__gen__x64__Gen_write8(g, 0x55);
	}
	else if (reg == (v__gen__x64__Register_rcx)) {
		v__gen__x64__Gen_write8(g, 0x4d);
	}
	else {
		v__gen__x64__verror(_STR("mov_var_to_reg %.*s", 1, v__gen__x64__Register_str(reg)));
	};
	v__gen__x64__Gen_write8(g, 0xff - var_offset + 1);
	v__gen__x64__Gen_println(g, _STR("mov %.*s\000,DWORD PTR[rbp-%.*s\000]", 3, v__gen__x64__Register_str(reg), int_hex2(var_offset)));
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_call(v__gen__x64__Gen* g, int addr) {
	int rel = 0xffffffff - (g->buf.len + 5 - addr - 1);
	v__gen__x64__Gen_write8(g, 0xe8);
	v__gen__x64__Gen_write32(g, rel);
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_syscall(v__gen__x64__Gen* g) {
	v__gen__x64__Gen_write8(g, 0x0f);
	v__gen__x64__Gen_write8(g, 0x05);
	v__gen__x64__Gen_println(g, _SLIT("syscall"));
}

void v__gen__x64__Gen_ret(v__gen__x64__Gen* g) {
	v__gen__x64__Gen_write8(g, 0xc3);
	v__gen__x64__Gen_println(g, _SLIT("ret"));
}

void v__gen__x64__Gen_push(v__gen__x64__Gen* g, v__gen__x64__Register reg) {
	if (((int)(reg)) < ((int)(v__gen__x64__Register_r8))) {
		v__gen__x64__Gen_write8(g, 0x50 + ((int)(reg)));
	} else {
		v__gen__x64__Gen_write8(g, 0x41);
		v__gen__x64__Gen_write8(g, 0x50 + ((int)(reg)) - 8);
	}
	v__gen__x64__Gen_println(g, _STR("push %.*s", 1, v__gen__x64__Register_str(reg)));
}

void v__gen__x64__Gen_pop(v__gen__x64__Gen* g, v__gen__x64__Register reg) {
	v__gen__x64__Gen_write8(g, 0x58 + ((int)(reg)));
	v__gen__x64__Gen_println(g, _STR("pop %.*s", 1, v__gen__x64__Register_str(reg)));
}

void v__gen__x64__Gen_sub32(v__gen__x64__Gen* g, v__gen__x64__Register reg, int val) {
	v__gen__x64__Gen_write8(g, 0x48);
	v__gen__x64__Gen_write8(g, 0x81);
	v__gen__x64__Gen_write8(g, 0xe8 + ((int)(reg)));
	v__gen__x64__Gen_write32(g, val);
	v__gen__x64__Gen_println(g, _STR("sub32 %.*s\000,%.*s", 2, v__gen__x64__Register_str(reg), int_hex2(val)));
}

void v__gen__x64__Gen_sub8(v__gen__x64__Gen* g, v__gen__x64__Register reg, int val) {
	v__gen__x64__Gen_write8(g, 0x48);
	v__gen__x64__Gen_write8(g, 0x83);
	v__gen__x64__Gen_write8(g, 0xe8 + ((int)(reg)));
	v__gen__x64__Gen_write8(g, val);
	v__gen__x64__Gen_println(g, _STR("sub8 %.*s\000,%.*s", 2, v__gen__x64__Register_str(reg), int_hex2(val)));
}

void v__gen__x64__Gen_add(v__gen__x64__Gen* g, v__gen__x64__Register reg, int val) {
	v__gen__x64__Gen_write8(g, 0x48);
	v__gen__x64__Gen_write8(g, 0x81);
	v__gen__x64__Gen_write8(g, 0xe8 + ((int)(reg)));
	v__gen__x64__Gen_write32(g, val);
	v__gen__x64__Gen_println(g, _STR("add %.*s\000,%.*s", 2, v__gen__x64__Register_str(reg), int_hex2(val)));
}

void v__gen__x64__Gen_add8(v__gen__x64__Gen* g, v__gen__x64__Register reg, int val) {
	v__gen__x64__Gen_write8(g, 0x48);
	v__gen__x64__Gen_write8(g, 0x83);
	v__gen__x64__Gen_write8(g, 0xc4);
	v__gen__x64__Gen_write8(g, val);
	v__gen__x64__Gen_println(g, _STR("add8 %.*s\000,%.*s", 2, v__gen__x64__Register_str(reg), int_hex2(val)));
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_add8_var(v__gen__x64__Gen* g, v__gen__x64__Register reg, int var_offset) {
	v__gen__x64__Gen_write8(g, 0x03);

	if (reg == (v__gen__x64__Register_eax) || reg == (v__gen__x64__Register_rax)) {
		v__gen__x64__Gen_write8(g, 0x45);
	}
	else {
		v__gen__x64__verror(_SLIT("add8_var"));
	};
	v__gen__x64__Gen_write8(g, 0xff - var_offset + 1);
	v__gen__x64__Gen_println(g, _STR("add8 %.*s\000,DWORD PTR[rbp-%.*s\000]", 3, v__gen__x64__Register_str(reg), int_hex2(var_offset)));
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_sub8_var(v__gen__x64__Gen* g, v__gen__x64__Register reg, int var_offset) {
	v__gen__x64__Gen_write8(g, 0x2b);

	if (reg == (v__gen__x64__Register_eax) || reg == (v__gen__x64__Register_rax)) {
		v__gen__x64__Gen_write8(g, 0x45);
	}
	else {
		v__gen__x64__verror(_SLIT("sub8_var"));
	};
	v__gen__x64__Gen_write8(g, 0xff - var_offset + 1);
	v__gen__x64__Gen_println(g, _STR("sub8 %.*s\000,DWORD PTR[rbp-%.*s\000]", 3, v__gen__x64__Register_str(reg), int_hex2(var_offset)));
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_mul8_var(v__gen__x64__Gen* g, v__gen__x64__Register reg, int var_offset) {
	v__gen__x64__Gen_write8(g, 0x0f);
	v__gen__x64__Gen_write8(g, 0xaf);

	if (reg == (v__gen__x64__Register_eax) || reg == (v__gen__x64__Register_rax)) {
		v__gen__x64__Gen_write8(g, 0x45);
	}
	else {
		v__gen__x64__verror(_SLIT("mul8_var"));
	};
	v__gen__x64__Gen_write8(g, 0xff - var_offset + 1);
	v__gen__x64__Gen_println(g, _STR("mul8 %.*s\000,DWORD PTR[rbp-%.*s\000]", 3, v__gen__x64__Register_str(reg), int_hex2(var_offset)));
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_leave(v__gen__x64__Gen* g) {
	v__gen__x64__Gen_write8(g, 0xc9);
	v__gen__x64__Gen_println(g, _SLIT("leave"));
}

int v__gen__x64__Gen_gen_loop_start(v__gen__x64__Gen* g, int from) {
	v__gen__x64__Gen_mov(g, v__gen__x64__Register_r12, from);
	int label = g->buf.len;
	v__gen__x64__Gen_inc(g, v__gen__x64__Register_r12);
	// autofree_scope_vars(pos=9761 line_nr=479 scope.pos=9666 scope.end_pos=9775)
	// var "g" var.pos=9671 var.line_nr=475
	// var "from" var.pos=9693 var.line_nr=475
	// var "label" var.pos=9729 var.line_nr=477
	// af parent scope:
	// af parent scope:
	return label;
}

void v__gen__x64__Gen_gen_loop_end(v__gen__x64__Gen* g, int to, int label) {
	v__gen__x64__Gen_cmp(g, v__gen__x64__Register_r12, v__gen__x64__Size__8, to);
	v__gen__x64__Gen_jl(g, label);
}

void v__gen__x64__Gen_save_main_fn_addr(v__gen__x64__Gen* g) {
	g->main_fn_addr = ((i64)(g->buf.len));
}

void v__gen__x64__Gen_gen_print_from_expr(v__gen__x64__Gen* g, v__ast__Expr expr, bool newline) {
	if (expr._typ == 277 /* v.ast.StringLiteral */) {
		if (newline) {
			v__gen__x64__Gen_gen_print(g, string_add((*expr._v__ast__StringLiteral).val, _SLIT("\n")));
		} else {
			v__gen__x64__Gen_gen_print(g, (*expr._v__ast__StringLiteral).val);
		}
	}
	else {
	};
}

void v__gen__x64__Gen_gen_print(v__gen__x64__Gen* g, string s) {
	array_push(&g->strings, _MOV((string[]){ string_clone(s) }));
	v__gen__x64__Gen_mov(g, v__gen__x64__Register_eax, 1);
	v__gen__x64__Gen_mov(g, v__gen__x64__Register_edi, 1);
	int str_pos = g->buf.len + 2;
	array_push(&g->str_pos, _MOV((i64[]){ str_pos }));
	v__gen__x64__Gen_mov64(g, v__gen__x64__Register_rsi, 0);
	v__gen__x64__Gen_mov(g, v__gen__x64__Register_edx, s.len);
	v__gen__x64__Gen_syscall(g);
}

void v__gen__x64__Gen_gen_exit(v__gen__x64__Gen* g) {
	v__gen__x64__Gen_mov(g, v__gen__x64__Register_edi, 0);
	v__gen__x64__Gen_mov(g, v__gen__x64__Register_eax, 60);
	v__gen__x64__Gen_syscall(g);
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_mov(v__gen__x64__Gen* g, v__gen__x64__Register reg, int val) {
	if (val == 0) {

		if (reg == (v__gen__x64__Register_eax) || reg == (v__gen__x64__Register_rax)) {
			v__gen__x64__Gen_write8(g, 0x31);
			v__gen__x64__Gen_write8(g, 0xc0);
		}
		else if (reg == (v__gen__x64__Register_edi) || reg == (v__gen__x64__Register_rdi)) {
			v__gen__x64__Gen_write8(g, 0x31);
			v__gen__x64__Gen_write8(g, 0xff);
		}
		else if (reg == (v__gen__x64__Register_edx)) {
			v__gen__x64__Gen_write8(g, 0x31);
			v__gen__x64__Gen_write8(g, 0xd2);
		}
		else if (reg == (v__gen__x64__Register_rsi)) {
			v__gen__x64__Gen_write8(g, 0x48);
			v__gen__x64__Gen_write8(g, 0x31);
			v__gen__x64__Gen_write8(g, 0xf6);
		}
		else if (reg == (v__gen__x64__Register_r12)) {
			v__gen__x64__Gen_write8(g, 0x4d);
			v__gen__x64__Gen_write8(g, 0x31);
			v__gen__x64__Gen_write8(g, 0xe4);
		}
		else {
			v_panic(_STR("unhandled mov %.*s", 1, v__gen__x64__Register_str(reg)));
		};
		v__gen__x64__Gen_println(g, _STR("xor %.*s\000, %.*s", 2, v__gen__x64__Register_str(reg), v__gen__x64__Register_str(reg)));
	} else {

		if (reg == (v__gen__x64__Register_eax) || reg == (v__gen__x64__Register_rax)) {
			v__gen__x64__Gen_write8(g, 0xb8);
		}
		else if (reg == (v__gen__x64__Register_edi) || reg == (v__gen__x64__Register_rdi)) {
			v__gen__x64__Gen_write8(g, 0xbf);
		}
		else if (reg == (v__gen__x64__Register_edx)) {
			v__gen__x64__Gen_write8(g, 0xba);
		}
		else if (reg == (v__gen__x64__Register_rsi)) {
			v__gen__x64__Gen_write8(g, 0x48);
			v__gen__x64__Gen_write8(g, 0xbe);
		}
		else if (reg == (v__gen__x64__Register_r12)) {
			v__gen__x64__Gen_write8(g, 0x41);
			v__gen__x64__Gen_write8(g, 0xbc);
		}
		else {
			v_panic(_STR("unhandled mov %.*s", 1, v__gen__x64__Register_str(reg)));
		};
		v__gen__x64__Gen_write32(g, val);
		v__gen__x64__Gen_println(g, _STR("mov %.*s\000, %"PRId32"", 2, v__gen__x64__Register_str(reg), val));
	}
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_mov_reg(v__gen__x64__Gen* g, v__gen__x64__Register a, v__gen__x64__Register b) {

	if (a == (v__gen__x64__Register_rbp)) {
		v__gen__x64__Gen_write8(g, 0x48);
		v__gen__x64__Gen_write8(g, 0x89);
	}
	else {
	};
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_mov_rbp_rsp(v__gen__x64__Gen* g) {
	v__gen__x64__Gen_write8(g, 0x48);
	v__gen__x64__Gen_write8(g, 0x89);
	v__gen__x64__Gen_write8(g, 0xe5);
	v__gen__x64__Gen_println(g, _SLIT("mov rbp,rsp"));
}

void v__gen__x64__Gen_register_function_address(v__gen__x64__Gen* g, string name) {
	i64 addr = v__gen__x64__Gen_pos(g);
	map_set(&g->fn_addr, &(string[]){name}, &(i64[]) { addr });
}

void v__gen__x64__Gen_call_fn(v__gen__x64__Gen* g, v__ast__CallExpr node) {
	string name = node.name;
	i64 addr = (*(i64*)map_get(ADDR(map, g->fn_addr), &(string[]){name}, &(i64[]){ 0 }));
	if (addr == 0) {
		v__gen__x64__verror(_STR("fn addr of `%.*s\000` = 0", 2, name));
	}
	for (int i = 0; i < node.args.len; ++i) {
		v__ast__Expr expr = (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, i)).expr;
		if (expr._typ == 259 /* v.ast.IntegerLiteral */) {
			v__gen__x64__Gen_mov(g, (*(v__gen__x64__Register*)/*ee elem_typ */array_get(_const_v__gen__x64__fn_arg_registers, i)), string_int((*expr._v__ast__IntegerLiteral).val));
		}
		else if (expr._typ == 254 /* v.ast.Ident */) {
			int var_offset = v__gen__x64__Gen_get_var_offset(g, (*expr._v__ast__Ident).name);
			if (g->pref->is_verbose) {
				println(_STR("i=%"PRId32"\000 fn name= %.*s\000 offset=%"PRId32"", 3, i, name, var_offset));
				println(int_str(((int)((*(v__gen__x64__Register*)/*ee elem_typ */array_get(_const_v__gen__x64__fn_arg_registers, i))))));
			}
			v__gen__x64__Gen_mov_var_to_reg(g, (*(v__gen__x64__Register*)/*ee elem_typ */array_get(_const_v__gen__x64__fn_arg_registers, i)), var_offset);
		}
		else {
			v__gen__x64__verror(string_add(_STR("unhandled call_fn (name=%.*s\000) node: ", 2, name), tos3( /* v.ast.Expr */ v_typeof_sumtype_v__ast__Expr( (expr)._typ ))));
		};
	}
	if (node.args.len > 6) {
		v__gen__x64__verror(_SLIT("more than 6 args not allowed for now"));
	}
	v__gen__x64__Gen_call(g, ((int)(addr)));
	v__gen__x64__Gen_println(g, _STR("fn call `%.*s\000()`", 2, name));
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_stmt(v__gen__x64__Gen* g, v__ast__Stmt node) {
	if (node._typ == 285 /* v.ast.AssignStmt */) {
		v__gen__x64__Gen_assign_stmt(g, (*node._v__ast__AssignStmt));
	}
	else if (node._typ == 286 /* v.ast.Block */) {
		v__gen__x64__Gen_stmts(g, (*node._v__ast__Block).stmts);
	}
	else if (node._typ == 289 /* v.ast.ConstDecl */) {
	}
	else if (node._typ == 293 /* v.ast.ExprStmt */) {
		v__gen__x64__Gen_expr(g, (*node._v__ast__ExprStmt).expr);
	}
	else if (node._typ == 175 /* v.ast.FnDecl */) {
		v__gen__x64__Gen_fn_decl(g, (*node._v__ast__FnDecl));
	}
	else if (node._typ == 296 /* v.ast.ForStmt */) {
		v__gen__x64__Gen_for_stmt(g, (*node._v__ast__ForStmt));
	}
	else if (node._typ == 301 /* v.ast.HashStmt */) {
		Array_string words = string_split((*node._v__ast__HashStmt).val, _SLIT(" "));
		// FOR IN array
		for (int _t3364 = 0; _t3364 < words.len; ++_t3364) {
			string word = ((string*)words.data)[_t3364];
			if (word.len != 2) {
				v__gen__x64__verror(_SLIT("opcodes format: xx xx xx xx"));
			}
			int b = strtol(((char*)(word.str)), 0, 16);
			v__gen__x64__Gen_write8(g, b);
		}
	}
	else if (node._typ == 304 /* v.ast.Module */) {
	}
	else if (node._typ == 305 /* v.ast.Return */) {
		v__gen__x64__Gen_gen_exit(g);
		v__gen__x64__Gen_ret(g);
	}
	else if (node._typ == 307 /* v.ast.StructDecl */) {
	}
	else {
		println(string_add(_SLIT("x64.stmt(): bad node: "), tos3( /* v.ast.Stmt */ v_typeof_sumtype_v__ast__Stmt( (node)._typ ))));
	};
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_expr(v__gen__x64__Gen* g, v__ast__Expr node) {
	if (node._typ == 235 /* v.ast.ArrayInit */) {
	}
	else if (node._typ == 239 /* v.ast.BoolLiteral */) {
	}
	else if (node._typ == 241 /* v.ast.CallExpr */) {
		if ((string_eq((*node._v__ast__CallExpr).name, _SLIT("println")) || string_eq((*node._v__ast__CallExpr).name, _SLIT("print")) || string_eq((*node._v__ast__CallExpr).name, _SLIT("eprintln")) || string_eq((*node._v__ast__CallExpr).name, _SLIT("eprint")))) {
			v__ast__Expr expr = (*(v__ast__CallArg*)/*ee elem_typ */array_get((*node._v__ast__CallExpr).args, 0)).expr;
			v__gen__x64__Gen_gen_print_from_expr(g, expr, (string_eq((*node._v__ast__CallExpr).name, _SLIT("println")) || string_eq((*node._v__ast__CallExpr).name, _SLIT("eprintln"))));
			return;
		}
		v__gen__x64__Gen_call_fn(g, (*node._v__ast__CallExpr));
	}
	else if (node._typ == 252 /* v.ast.FloatLiteral */) {
	}
	else if (node._typ == 254 /* v.ast.Ident */) {
	}
	else if (node._typ == 255 /* v.ast.IfExpr */) {
		v__gen__x64__Gen_if_expr(g, (*node._v__ast__IfExpr));
	}
	else if (node._typ == 258 /* v.ast.InfixExpr */) {
	}
	else if (node._typ == 259 /* v.ast.IntegerLiteral */) {
	}
	else if (node._typ == 269 /* v.ast.PostfixExpr */) {
		v__gen__x64__Gen_postfix_expr(g, (*node._v__ast__PostfixExpr));
	}
	else if (node._typ == 277 /* v.ast.StringLiteral */) {
	}
	else if (node._typ == 278 /* v.ast.StructInit */) {
	}
	else {
		println(term__red(string_add(_SLIT("x64.expr(): unhandled node: "), tos3( /* v.ast.Expr */ v_typeof_sumtype_v__ast__Expr( (node)._typ )))));
	};
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_allocate_var(v__gen__x64__Gen* g, string name, int size, int initial_val) {

	if (size == (1)) {
		v__gen__x64__Gen_write8(g, 0xc6);
		v__gen__x64__Gen_write8(g, 0x45);
	}
	else if (size == (4)) {
		v__gen__x64__Gen_write8(g, 0xc7);
		v__gen__x64__Gen_write8(g, 0x45);
	}
	else if (size == (8)) {
		v__gen__x64__Gen_write8(g, 0x48);
		v__gen__x64__Gen_write8(g, 0xc7);
		v__gen__x64__Gen_write8(g, 0x45);
	}
	else {
		v__gen__x64__verror(_STR("allocate_var: bad size %"PRId32"", 1, size));
	};
	int n = g->stack_var_pos + size;
	v__gen__x64__Gen_write8(g, 0xff - n + 1);
	g->stack_var_pos += size;
	map_set(&g->var_offset, &(string[]){name}, &(int[]) { g->stack_var_pos });
	v__gen__x64__Gen_write32(g, initial_val);
	v__gen__x64__Gen_println(g, _STR("mov DWORD [rbp-%.*s\000],%"PRId32"\000 (Allocate var `%.*s\000`)", 4, int_hex2(n), initial_val, name));
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_assign_stmt(v__gen__x64__Gen* g, v__ast__AssignStmt node) {
	// FOR IN array
	for (int i = 0; i < node.left.len; ++i) {
		v__ast__Expr left = ((v__ast__Expr*)node.left.data)[i];
		v__ast__Expr right = (*(v__ast__Expr*)/*ee elem_typ */array_get(node.right, i));
		string name = v__ast__Expr_str(left);
		if (right._typ == 259 /* v.ast.IntegerLiteral */) {
			v__gen__x64__Gen_allocate_var(g, name, 4, string_int((*right._v__ast__IntegerLiteral).val));
		}
		else if (right._typ == 258 /* v.ast.InfixExpr */) {
			v__gen__x64__Gen_infix_expr(g, (*right._v__ast__InfixExpr));
			v__gen__x64__Gen_allocate_var(g, name, 4, 0);
			int offset = v__gen__x64__Gen_get_var_offset(g, name);
			println(_STR("infix assignment %.*s\000 offset=%.*s", 2, name, int_hex2(offset)));
			v__gen__x64__Gen_mov_reg_to_rbp(g, offset, v__gen__x64__Register_eax);
		}
		else if (right._typ == 278 /* v.ast.StructInit */) {
			v__ast__TypeSymbol* sym = v__ast__Table_get_type_symbol(g->table, (*right._v__ast__StructInit).typ);
			v__ast__Struct info = /* as */ *(v__ast__Struct*)__as_cast((sym->info)._v__ast__Struct,(sym->info)._typ, 409) /*expected idx: 409, name: v.ast.Struct */ ;
			// FOR IN array
			for (int _t3365 = 0; _t3365 < info.fields.len; ++_t3365) {
				v__ast__StructField field = ((v__ast__StructField*)info.fields.data)[_t3365];
				string field_name = string_add(string_add(name, _SLIT(".")), field.name);
				println(field_name);
				v__gen__x64__Gen_allocate_var(g, field_name, 4, 0);
			}
		}
		else {
			v__gen__x64__Gen_error_with_pos(g, string_add(_SLIT("x64 assign_stmt unhandled expr: "), tos3( /* v.ast.Expr */ v_typeof_sumtype_v__ast__Expr( (right)._typ ))), v__ast__Expr_position(right));
		};
	}
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_infix_expr(v__gen__x64__Gen* g, v__ast__InfixExpr node) {
	println(_STR("infix expr op=%.*s", 1, v__token__Kind_str(node.op)));
	if ((node.left)._typ == 258 /* v.ast.InfixExpr */) {
		v__gen__x64__verror(_SLIT("only simple expressions are supported right now (not more than 2 operands)"));
	}
	if (node.left._typ == 254 /* v.ast.Ident */) {
		v__gen__x64__Gen_mov_var_to_reg(g, v__gen__x64__Register_eax, v__gen__x64__Gen_get_var_offset(g, (*node.left._v__ast__Ident).name));
	}
	else {
	};
	if ((node.right)._typ == 254 /* v.ast.Ident */) {
		int var_offset = v__gen__x64__Gen_get_var_offset(g, (*node.right._v__ast__Ident).name);

		if (node.op == (v__token__Kind_plus)) {
			v__gen__x64__Gen_add8_var(g, v__gen__x64__Register_eax, var_offset);
		}
		else if (node.op == (v__token__Kind_mul)) {
			v__gen__x64__Gen_mul8_var(g, v__gen__x64__Register_eax, var_offset);
		}
		else if (node.op == (v__token__Kind_minus)) {
			v__gen__x64__Gen_sub8_var(g, v__gen__x64__Register_eax, var_offset);
		}
		else {
		};
	}
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_if_expr(v__gen__x64__Gen* g, v__ast__IfExpr node) {
	v__ast__IfBranch branch = (*(v__ast__IfBranch*)/*ee elem_typ */array_get(node.branches, 0));
	v__ast__InfixExpr infix_expr = /* as */ *(v__ast__InfixExpr*)__as_cast((branch.cond)._v__ast__InfixExpr,(branch.cond)._typ, 258) /*expected idx: 258, name: v.ast.InfixExpr */ ;
	int jne_addr = 0;
	if (infix_expr.left._typ == 254 /* v.ast.Ident */) {
		v__ast__IntegerLiteral lit = /* as */ *(v__ast__IntegerLiteral*)__as_cast((infix_expr.right)._v__ast__IntegerLiteral,(infix_expr.right)._typ, 259) /*expected idx: 259, name: v.ast.IntegerLiteral */ ;
		v__gen__x64__Gen_cmp_var(g, (*infix_expr.left._v__ast__Ident).name, string_int(lit.val));
		jne_addr = v__gen__x64__Gen_jne(g);
	}
	else {
		v__gen__x64__verror(_SLIT("unhandled infix.left"));
	};
	v__gen__x64__Gen_stmts(g, branch.stmts);
	v__gen__x64__Gen_write32_at(g, jne_addr, ((int)(v__gen__x64__Gen_pos(g) - jne_addr - 4)));
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_for_stmt(v__gen__x64__Gen* g, v__ast__ForStmt node) {
	v__ast__InfixExpr infix_expr = /* as */ *(v__ast__InfixExpr*)__as_cast((node.cond)._v__ast__InfixExpr,(node.cond)._typ, 258) /*expected idx: 258, name: v.ast.InfixExpr */ ;
	int jump_addr = 0;
	i64 start = v__gen__x64__Gen_pos(g);
	if (infix_expr.left._typ == 254 /* v.ast.Ident */) {
		v__ast__IntegerLiteral lit = /* as */ *(v__ast__IntegerLiteral*)__as_cast((infix_expr.right)._v__ast__IntegerLiteral,(infix_expr.right)._typ, 259) /*expected idx: 259, name: v.ast.IntegerLiteral */ ;
		v__gen__x64__Gen_cmp_var(g, (*infix_expr.left._v__ast__Ident).name, string_int(lit.val));
		jump_addr = v__gen__x64__Gen_jge(g);
	}
	else {
		v__gen__x64__verror(_SLIT("unhandled infix.left"));
	};
	v__gen__x64__Gen_stmts(g, node.stmts);
	v__gen__x64__Gen_jmp(g, ((int)(0xffffffff - (v__gen__x64__Gen_pos(g) + 5 - start) + 1)));
	v__gen__x64__Gen_write32_at(g, jump_addr, ((int)(v__gen__x64__Gen_pos(g) - jump_addr - 4)));
	v__gen__x64__Gen_println(g, _SLIT("jpm after for"));
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_fn_decl(v__gen__x64__Gen* g, v__ast__FnDecl node) {
	if (g->pref->is_verbose) {
		println(term__green(_STR("\n%.*s\000:", 2, node.name)));
	}
	g->stack_var_pos = 0;
	bool is_main = string_eq(node.name, _SLIT("main.main"));
	if (is_main) {
		v__gen__x64__Gen_save_main_fn_addr(g);
	} else {
		v__gen__x64__Gen_register_function_address(g, node.name);
	}
	v__gen__x64__Gen_push(g, v__gen__x64__Register_rbp);
	v__gen__x64__Gen_mov_rbp_rsp(g);
	v__gen__x64__Gen_sub8(g, v__gen__x64__Register_rsp, 0x10);
	if (node.params.len > 0) {
	}
	int offset = 0;
	for (int i = 0; i < node.params.len; ++i) {
		string name = (*(v__ast__Param*)/*ee elem_typ */array_get(node.params, i)).name;
		v__gen__x64__Gen_allocate_var(g, name, 4, 0);
		offset += 4;
		v__gen__x64__Gen_mov_reg_to_rbp(g, offset, (*(v__gen__x64__Register*)/*ee elem_typ */array_get(_const_v__gen__x64__fn_arg_registers, i)));
	}
	v__gen__x64__Gen_stmts(g, node.stmts);
	if (is_main) {
		v__gen__x64__Gen_gen_exit(g);
	}
	if (!is_main) {
		v__gen__x64__Gen_add8(g, v__gen__x64__Register_rsp, 0x10);
		v__gen__x64__Gen_pop(g, v__gen__x64__Register_rbp);
	}
	v__gen__x64__Gen_ret(g);
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_postfix_expr(v__gen__x64__Gen* g, v__ast__PostfixExpr node) {
	if ((node.expr)._typ != 254 /* v.ast.Ident */) {
		return;
	}
	v__ast__Ident ident = /* as */ *(v__ast__Ident*)__as_cast((node.expr)._v__ast__Ident,(node.expr)._typ, 254) /*expected idx: 254, name: v.ast.Ident */ ;
	string var_name = ident.name;
	if (node.op == v__token__Kind_inc) {
		v__gen__x64__Gen_inc_var(g, var_name);
	}
}

VV_LOCAL_SYMBOL void v__gen__x64__verror(string s) {
	v__util__verror(_SLIT("x64 gen error"), s);
}

void v__gen__x64__Gen_error_with_pos(v__gen__x64__Gen* g, string s, v__token__Position pos) {
	string kind = _SLIT("error:");
	if (g->pref->output_mode == v__pref__OutputMode_stdout) {
		string ferror = v__util__formatted_error(kind, s, g->pref->path, pos);
		eprintln(ferror);
		v_exit(1);
	} else {
		array_push(&g->errors, _MOV((v__errors__Error[]){ (v__errors__Error){.message = s,.details = (string){.str=(byteptr)"", .is_lit=1},.file_path = g->pref->path,.pos = pos,.backtrace = (string){.str=(byteptr)"", .is_lit=1},.reporter = v__errors__Reporter_gen,} }));
	}
}

void v__gen__x64__Gen_generate_macho_header(v__gen__x64__Gen* g) {
	v__gen__x64__Gen_write32(g, 0xfeedfacf);
	v__gen__x64__Gen_write32(g, 0x0100000c);
	v__gen__x64__Gen_write32(g, 0x00000000);
	v__gen__x64__Gen_write32(g, 0x00000001);
	v__gen__x64__Gen_write32(g, 0x00000004);
	v__gen__x64__Gen_write32(g, 0x118);
	v__gen__x64__Gen_write32(g, 0);
	v__gen__x64__Gen_write32(g, 0);
	v__gen__x64__Gen_write32(g, 0x19);
	v__gen__x64__Gen_write32(g, 0x98);
	v__gen__x64__Gen_zeroes(g, 16);
	v__gen__x64__Gen_write64(g, 0);
	v__gen__x64__Gen_write64(g, 0x25);
	v__gen__x64__Gen_write64(g, 0x138);
	v__gen__x64__Gen_write64(g, 0x25);
	v__gen__x64__Gen_write32(g, 0x7);
	v__gen__x64__Gen_write32(g, 0x7);
	v__gen__x64__Gen_write32(g, 0x1);
	v__gen__x64__Gen_write32(g, 0);
	v__gen__x64__Gen_write_string_with_padding(g, _SLIT("__text"), 16);
	v__gen__x64__Gen_write_string_with_padding(g, _SLIT("__TEXT"), 16);
	v__gen__x64__Gen_write64(g, 0);
	v__gen__x64__Gen_write64(g, 0x25);
	v__gen__x64__Gen_write32(g, 0x138);
	v__gen__x64__Gen_write32(g, 0x4);
	v__gen__x64__Gen_write32(g, 0x160);
	v__gen__x64__Gen_write32(g, 0x1);
	v__gen__x64__Gen_write32(g, (_const_v__gen__x64__s_attr_some_instructions | _const_v__gen__x64__s_attr_pure_instructions));
	v__gen__x64__Gen_write32(g, 0);
	v__gen__x64__Gen_write32(g, 0);
	v__gen__x64__Gen_write32(g, 0);
	v__gen__x64__Gen_write32(g, 0x32);
	v__gen__x64__Gen_write32(g, 0x18);
	v__gen__x64__Gen_write32(g, 0x01);
	v__gen__x64__Gen_write32(g, 0x000b0000);
	v__gen__x64__Gen_write32(g, 0);
	v__gen__x64__Gen_write32(g, 0);
	v__gen__x64__Gen_sym_table_command(g);
	v__gen__x64__Gen_write32(g, _const_v__gen__x64__lc_dymsymtab);
	v__gen__x64__Gen_write32(g, _const_v__gen__x64__macho_d_size);
	v__gen__x64__Gen_write32(g, 0);
	v__gen__x64__Gen_write32(g, 2);
	v__gen__x64__Gen_write32(g, 2);
	v__gen__x64__Gen_write32(g, 1);
	v__gen__x64__Gen_write32(g, 3);
	v__gen__x64__Gen_write32(g, 1);
	for (int _t3367 = 0; _t3367 < 12; ++_t3367) {
		v__gen__x64__Gen_write32(g, 0);
	}
	v__gen__x64__Gen_mov_arm(g, v__gen__x64__Register2_x0, 1);
	v__gen__x64__Gen_adr(g);
	v__gen__x64__Gen_bl(g);
	v__gen__x64__Gen_mov_arm(g, v__gen__x64__Register2_x0, 0);
	v__gen__x64__Gen_mov_arm(g, v__gen__x64__Register2_x16, 1);
	v__gen__x64__Gen_svc(g);
	v__gen__x64__Gen_write_string(g, _SLIT("Hello WorlD!\n"));
	v__gen__x64__Gen_write8(g, 0);
	v__gen__x64__Gen_write8(g, 0);
	v__gen__x64__Gen_write8(g, 0);
	v__gen__x64__Gen_write_relocs(g);
	v__gen__x64__Gen_sym_table(g);
	v__gen__x64__Gen_sym_string_table(g);
	v__gen__x64__Gen_write8(g, 0);
}

void v__gen__x64__Gen_generate_macho_footer(v__gen__x64__Gen* g) {
	Option_os__File _t3368 = os__create(g->out_name);
	if (_t3368.state != 0) { /*or block*/ 
		IError err = _t3368.err;
		v_panic(IError_str(err));
	}
 	os__File f =  *(os__File*)_t3368.data;
	os__chmod(g->out_name, 0775);
	os__File_write_ptr(&f, g->buf.data, g->buf.len);
	os__File_close(&f);
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_sym_table_command(v__gen__x64__Gen* g) {
	array_push(&g->syms, _MOV((v__gen__x64__Symbol[]){ (v__gen__x64__Symbol){
		.str_entry = 0x19,
		.symbol_typ = 0xe,
		.section = 1,
		.desc = 0,
		.val = 0,
		.name = _SLIT("_start"),
		.is_ext = true,
	} }));
	array_push(&g->syms, _MOV((v__gen__x64__Symbol[]){ (v__gen__x64__Symbol){
		.str_entry = 0x0e,
		.symbol_typ = 0xe,
		.section = 1,
		.desc = 0,
		.val = 0x18,
		.name = _SLIT("_puts"),
		.is_ext = false,
	} }));
	array_push(&g->syms, _MOV((v__gen__x64__Symbol[]){ (v__gen__x64__Symbol){
		.str_entry = 0x01,
		.symbol_typ = 0xf,
		.section = 1,
		.desc = 0,
		.val = 0,
		.name = _SLIT("helloworld"),
		.is_ext = false,
	} }));
	array_push(&g->syms, _MOV((v__gen__x64__Symbol[]){ (v__gen__x64__Symbol){
		.str_entry = 0x08,
		.symbol_typ = 0x1,
		.section = 0,
		.desc = 0,
		.val = 0,
		.name = _SLIT("ltmp1"),
		.is_ext = false,
	} }));
	v__gen__x64__Gen_write32(g, _const_v__gen__x64__lc_symtab);
	v__gen__x64__Gen_write32(g, _const_v__gen__x64__macho_symcmd_size);
	int sym_table_offset = 0x168;
	v__gen__x64__Gen_write32(g, sym_table_offset);
	int g_syms_len = 4;
	v__gen__x64__Gen_write32(g, g_syms_len);
	int str_offset = 0x1a8;
	v__gen__x64__Gen_write32(g, str_offset);
	int str_size = 0x20;
	v__gen__x64__Gen_write32(g, str_size);
}

void v__gen__x64__Gen_zeroes(v__gen__x64__Gen* g, int n) {
	for (int _t3373 = 0; _t3373 < n; ++_t3373) {
		array_push(&g->buf, _MOV((byte[]){ 0 }));
	}
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_mov_arm(v__gen__x64__Gen* g, v__gen__x64__Register2 reg, u64 val) {
	int r = ((int)(reg));
	if (r == 0 && val == 1) {
		v__gen__x64__Gen_write32(g, 0xd2800020);
	} else if (r == 0) {
		v__gen__x64__Gen_write32(g, 0xd2800000);
	} else if (r == 16) {
		v__gen__x64__Gen_write32(g, 0xd2800030);
	}
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_adr(v__gen__x64__Gen* g) {
	v__gen__x64__Gen_write32(g, 0x100000a0);
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_bl(v__gen__x64__Gen* g) {
	v__gen__x64__Gen_write32(g, 0x94000000);
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_svc(v__gen__x64__Gen* g) {
	v__gen__x64__Gen_write32(g, 0xd4001001);
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_write_relocs(v__gen__x64__Gen* g) {
	v__gen__x64__Gen_write32(g, 0x8);
	v__gen__x64__Gen_write32(g, 0x2d000003);
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_sym_table(v__gen__x64__Gen* g) {
	// FOR IN array
	for (int _t3375 = 0; _t3375 < g->syms.len; ++_t3375) {
		v__gen__x64__Symbol sym = ((v__gen__x64__Symbol*)g->syms.data)[_t3375];
		v__gen__x64__Gen_write_symbol(g, sym);
	}
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_write_symbol(v__gen__x64__Gen* g, v__gen__x64__Symbol s) {
	v__gen__x64__Gen_write32(g, s.str_entry);
	v__gen__x64__Gen_write8(g, s.symbol_typ);
	v__gen__x64__Gen_write8(g, s.section);
	v__gen__x64__Gen_write8(g, 0);
	v__gen__x64__Gen_write8(g, 0);
	v__gen__x64__Gen_write64(g, s.val);
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_sym_string_table(v__gen__x64__Gen* g) {
	v__gen__x64__Gen_zeroes(g, 1);
	// FOR IN array
	for (int _t3376 = 0; _t3376 < g->syms.len; ++_t3376) {
		v__gen__x64__Symbol sym = ((v__gen__x64__Symbol*)g->syms.data)[_t3376];
		v__gen__x64__Gen_write_string(g, sym.name);
		v__gen__x64__Gen_write8(g, 0);
	}
}

v__builder__Builder v__builder__new_builder(v__pref__Preferences* pref) {
	string rdir = os__real_path(pref->path);
	string compiled_dir = (os__is_dir(rdir) ? (rdir) : (os__dir(rdir)));
	v__ast__Table* table = v__ast__new_table();
	table->is_fmt = false;
	if (pref->use_color == v__pref__ColorOutput_always) {
		v__util__EManager_set_support_color(_const_v__util__emanager, true);
	}
	if (pref->use_color == v__pref__ColorOutput_never) {
		v__util__EManager_set_support_color(_const_v__util__emanager, false);
	}
	Option_v__builder__MsvcResult _t3377 = v__builder__find_msvc(pref->m64);
	if (_t3377.state != 0) { /*or block*/ 
		IError err = _t3377.err;
		if (string_eq(pref->ccompiler, _SLIT("msvc"))) {
		}
		*(v__builder__MsvcResult*) _t3377.data = (v__builder__MsvcResult){.full_cl_exe_path = (string){.str=(byteptr)"", .is_lit=1},.exe_path = (string){.str=(byteptr)"", .is_lit=1},.um_lib_path = (string){.str=(byteptr)"", .is_lit=1},.ucrt_lib_path = (string){.str=(byteptr)"", .is_lit=1},.vs_lib_path = (string){.str=(byteptr)"", .is_lit=1},.um_include_path = (string){.str=(byteptr)"", .is_lit=1},.ucrt_include_path = (string){.str=(byteptr)"", .is_lit=1},.vs_include_path = (string){.str=(byteptr)"", .is_lit=1},.shared_include_path = (string){.str=(byteptr)"", .is_lit=1},.valid = false,};
	}
 	v__builder__MsvcResult msvc =  *(v__builder__MsvcResult*)_t3377.data;
	v__util__timing_set_should_print(pref->show_timings || pref->is_verbose);
	 v__builder__Builder _t3378 = (v__builder__Builder){
		.compiled_dir = compiled_dir,
		.module_path = (string){.str=(byteptr)"", .is_lit=1},
		.pref = pref,
		.checker = v__checker__new_checker(table, pref),
		.global_scope = (v__ast__Scope*)memdup(&(v__ast__Scope){.objects = new_map(sizeof(string), sizeof(v__ast__ScopeObject), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.struct_fields = __new_array(0, 1, sizeof(v__ast__ScopeStructField)),.parent = 0,.detached_from_parent = 0,.children = __new_array(0, 1, sizeof(v__ast__Scope*)),.start_pos = 0,.end_pos = 0,}, sizeof(v__ast__Scope)),
		.out_name_c = (string){.str=(byteptr)"", .is_lit=1},
		.out_name_js = (string){.str=(byteptr)"", .is_lit=1},
		.max_nr_errors = (pref->error_limit > 0 ? (pref->error_limit) : (100)),
		.stats_lines = 0,
		.stats_bytes = 0,
		.module_search_paths = __new_array(0, 1, sizeof(string)),
		.parsed_files = __new_array(0, 1, sizeof(v__ast__File)),
		.cached_msvc = msvc,
		.table = table,
		.ccoptions = (v__builder__CcompilerOptions){.args = __new_array(0, 1, sizeof(string)),.wargs = __new_array(0, 1, sizeof(string)),.pre_args = __new_array(0, 1, sizeof(string)),.o_args = __new_array(0, 1, sizeof(string)),.source_args = __new_array(0, 1, sizeof(string)),.post_args = __new_array(0, 1, sizeof(string)),.linker_flags = __new_array(0, 1, sizeof(string)),},
	};
	// autofree_scope_vars(pos=1376 line_nr=53 scope.pos=809 scope.end_pos=1703)
	// var "pref" var.pos=821 var.line_nr=33
	// var "rdir" var.pos=856 var.line_nr=34
	// var "compiled_dir" var.pos=889 var.line_nr=35
	// var "table" var.pos=960 var.line_nr=36
	// var "msvc" var.pos=1158 var.line_nr=44
	// af parent scope:
	// af parent scope:
	return _t3378;
}

void v__builder__Builder_parse_imports(v__builder__Builder* b) {
	Array_string done_imports = __new_array_with_default(0, 0, sizeof(string), 0);
	if (b->pref->is_vsh) {
		array_push(&done_imports, _MOV((string[]){ string_clone(_SLIT("os")) }));
	}
	// FOR IN array
	for (int _t3380 = 0; _t3380 < b->parsed_files.len; ++_t3380) {
		v__ast__File file = ((v__ast__File*)b->parsed_files.data)[_t3380];
		if (string_ne(file.mod.name, _SLIT("main")) && !(Array_string_contains(done_imports, file.mod.name))) {
			array_push(&done_imports, _MOV((string[]){ string_clone(file.mod.name) }));
		}
	}
	for (int i = 0; i < b->parsed_files.len; i++) {
		v__ast__File ast_file = (*(v__ast__File*)/*ee elem_typ */array_get(b->parsed_files, i));
		// FOR IN array
		for (int _t3382 = 0; _t3382 < ast_file.imports.len; ++_t3382) {
			v__ast__Import imp = ((v__ast__Import*)ast_file.imports.data)[_t3382];
			string mod = imp.mod;
			if (string_eq(mod, _SLIT("builtin"))) {
				v__builder__error_with_pos(_SLIT("cannot import module \"builtin\""), ast_file.path, imp.pos);
				break;
			}
			if ((Array_string_contains(done_imports, mod))) {
				continue;
			}
			Option_string _t3383 = v__builder__Builder_find_module_path(b, mod, ast_file.path);
			if (_t3383.state != 0) { /*or block*/ 
				IError err = _t3383.err;
				v__builder__error_with_pos(_STR("cannot import module \"%.*s\000\" (not found)", 2, mod), ast_file.path, imp.pos);
				break;
			}
 			string import_path =  *(string*)_t3383.data;
			Array_string v_files = v__builder__Builder_v_files_from_dir(b, import_path);
			if (v_files.len == 0) {
				v__builder__error_with_pos(_STR("cannot import module \"%.*s\000\" (no .v files in \"%.*s\000\")", 3, mod, import_path), ast_file.path, imp.pos);
			}
			Array_v__ast__File parsed_files = v__parser__parse_files(v_files, b->table, b->pref, b->global_scope);
			// FOR IN array
			for (int _t3384 = 0; _t3384 < parsed_files.len; ++_t3384) {
				v__ast__File file = ((v__ast__File*)parsed_files.data)[_t3384];
				if (string_ne(file.mod.name, mod)) {
					v__builder__error_with_pos(_STR("bad module definition: %.*s\000 imports module \"%.*s\000\" but %.*s\000 is defined as module `%.*s\000`", 5, ast_file.path, mod, file.path, file.mod.name), ast_file.path, imp.pos);
				}
			}
			_PUSH_MANY(&b->parsed_files, (parsed_files), _t3385, Array_v__ast__File);
			array_push(&done_imports, _MOV((string[]){ string_clone(mod) }));
		}
	}
	v__builder__Builder_resolve_deps(b);
	if (b->pref->print_v_files) {
		// FOR IN array
		for (int _t3387 = 0; _t3387 < b->parsed_files.len; ++_t3387) {
			v__ast__File p = ((v__ast__File*)b->parsed_files.data)[_t3387];
			println(p.path);
		}
		v_exit(0);
	}
}

void v__builder__Builder_resolve_deps(v__builder__Builder* b) {
	v__depgraph__DepGraph* graph = v__builder__Builder_import_graph(b);
	v__depgraph__DepGraph* deps_resolved = v__depgraph__DepGraph_resolve(graph);
	string cycles = v__depgraph__DepGraph_display_cycles(deps_resolved);
	if (b->pref->is_verbose) {
		eprintln(_SLIT("------ resolved dependencies graph: ------"));
		eprintln(v__depgraph__DepGraph_display(deps_resolved));
		eprintln(_SLIT("------------------------------------------"));
	}
	if (cycles.len > 1) {
		v__builder__verror(string_add(_SLIT("error: import cycle detected between the following modules: \n"), cycles));
	}
	Array_string mods = __new_array_with_default(0, 0, sizeof(string), 0);
	// FOR IN array
	for (int _t3388 = 0; _t3388 < deps_resolved->nodes.len; ++_t3388) {
		v__depgraph__DepGraphNode node = ((v__depgraph__DepGraphNode*)deps_resolved->nodes.data)[_t3388];
		array_push(&mods, _MOV((string[]){ string_clone(node.name) }));
	}
	if (b->pref->is_verbose) {
		eprintln(_SLIT("------ imported modules: ------"));
		eprintln(Array_string_str(mods));
		eprintln(_SLIT("-------------------------------"));
	}
	Array_v__ast__File reordered_parsed_files = __new_array_with_default(0, 0, sizeof(v__ast__File), 0);
	// FOR IN array
	for (int _t3390 = 0; _t3390 < mods.len; ++_t3390) {
		string m = ((string*)mods.data)[_t3390];
		// FOR IN array
		for (int _t3391 = 0; _t3391 < b->parsed_files.len; ++_t3391) {
			v__ast__File pf = ((v__ast__File*)b->parsed_files.data)[_t3391];
			if (string_eq(m, pf.mod.name)) {
				array_push(&reordered_parsed_files, _MOV((v__ast__File[]){ pf }));
			}
		}
	}
	b->table->modules = mods;
	b->parsed_files = reordered_parsed_files;
}

v__depgraph__DepGraph* v__builder__Builder_import_graph(v__builder__Builder* b) {
	Array_string builtins = array_clone(&_const_v__util__builtin_module_parts);
	v__depgraph__DepGraph* graph = v__depgraph__new_dep_graph();
	// FOR IN array
	for (int _t3393 = 0; _t3393 < b->parsed_files.len; ++_t3393) {
		v__ast__File p = ((v__ast__File*)b->parsed_files.data)[_t3393];
		Array_string deps = __new_array_with_default(0, 0, sizeof(string), 0);
		if (!(Array_string_contains(builtins, p.mod.name))) {
			array_push(&deps, _MOV((string[]){ string_clone(_SLIT("builtin")) }));
			if (b->pref->backend == v__pref__Backend_c) {
				if (b->pref->is_vsh && string_ne(p.mod.name, _SLIT("os"))) {
					array_push(&deps, _MOV((string[]){ string_clone(_SLIT("os")) }));
				}
			}
		}
		// FOR IN array
		for (int _t3396 = 0; _t3396 < p.imports.len; ++_t3396) {
			v__ast__Import m = ((v__ast__Import*)p.imports.data)[_t3396];
			if (string_eq(m.mod, p.mod.name)) {
				continue;
			}
			array_push(&deps, _MOV((string[]){ string_clone(m.mod) }));
		}
		v__depgraph__DepGraph_add(graph, p.mod.name, deps);
	}
	// autofree_scope_vars(pos=5909 line_nr=195 scope.pos=5383 scope.end_pos=5923)
	// var "b" var.pos=5384 var.line_nr=173
	// var "builtins" var.pos=5433 var.line_nr=174
	// var "graph" var.pos=5484 var.line_nr=175
	// af parent scope:
	// af parent scope:
	return graph;
}

Array_string v__builder__Builder_v_files_from_dir(v__builder__Builder* b, string dir) {
	if (!os__exists(dir)) {
		if (string_eq(dir, _SLIT("compiler")) && os__is_dir(_SLIT("vlib"))) {
			println(_SLIT("looks like you are trying to build V with an old command"));
			println(_SLIT("use `v -o v cmd/v` instead of `v -o v compiler`"));
		}
		v__builder__verror(_STR("%.*s\000 doesn't exist", 2, dir));
	} else if (!os__is_dir(dir)) {
		v__builder__verror(_STR("%.*s\000 isn't a directory!", 2, dir));
	}
	Option_Array_string _t3398 = os__ls(dir);
	if (_t3398.state != 0) { /*or block*/ 
		IError err = _t3398.err;
		v_panic(IError_str(err));
	}
 	Array_string files =  *(Array_string*)_t3398.data;
	if (b->pref->is_verbose) {
		println(_STR("v_files_from_dir (\"%.*s\000\")", 2, dir));
	}
	 Array_string _t3399 = v__pref__Preferences_should_compile_filtered_files(b->pref, dir, files);
	// autofree_scope_vars(pos=6398 line_nr=212 scope.pos=5933 scope.end_pos=6455)
	// var "b" var.pos=5934 var.line_nr=198
	// var "dir" var.pos=5962 var.line_nr=198
	// var "files" var.pos=6294 var.line_nr=208
	// af parent scope:
	// af parent scope:
	return _t3399;
}

void v__builder__Builder_log(v__builder__Builder* b, string s) {
	if (b->pref->is_verbose) {
		println(s);
	}
}

void v__builder__Builder_info(v__builder__Builder* b, string s) {
	if (b->pref->is_verbose) {
		println(s);
	}
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL string v__builder__module_path(string mod) {
	 string _t3400 = string_replace(mod, _SLIT("."), _const_os__path_separator);
	// autofree_scope_vars(pos=6682 line_nr=230 scope.pos=6627 scope.end_pos=6726)
	// var "mod" var.pos=6639 var.line_nr=228
	// af parent scope:
	// af parent scope:
	return _t3400;
}

Option_string v__builder__Builder_find_module_path(v__builder__Builder* b, string mod, string fpath) {
	v__vmod__ModFileCacher* mcache = v__vmod__get_cache();
	v__vmod__ModFileAndFolder vmod_file_location = v__vmod__ModFileCacher_get_by_file(mcache, fpath);
	string mod_path = v__builder__module_path(mod);
	Array_string module_lookup_paths = __new_array_with_default(0, 0, sizeof(string), 0);
	if (vmod_file_location.vmod_file.len != 0 && !(Array_string_contains(b->module_search_paths, vmod_file_location.vmod_folder))) {
		array_push(&module_lookup_paths, _MOV((string[]){ string_clone(vmod_file_location.vmod_folder) }));
	}
	_PUSH_MANY(&module_lookup_paths, (b->module_search_paths), _t3402, Array_string);
	array_push(&module_lookup_paths, _MOV((string[]){ string_clone(os__getwd()) }));
	if (string_contains(fpath, string_add(string_add(_const_os__path_separator, _SLIT("modules")), _const_os__path_separator))) {
		Array_string parts = string_split(fpath, _const_os__path_separator);
		for (int i = parts.len - 2; i >= 0; i--) {
			if (string_eq((*(string*)/*ee elem_typ */array_get(parts, i)), _SLIT("modules"))) {
				array_push(&module_lookup_paths, _MOV((string[]){ string_clone(Array_string_join(array_slice(parts, 0, i + 1), _const_os__path_separator)) }));
				break;
			}
		}
	}
	// FOR IN array
	for (int _t3405 = 0; _t3405 < module_lookup_paths.len; ++_t3405) {
		string search_path = ((string*)module_lookup_paths.data)[_t3405];
		string try_path = os__join_path(search_path, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){mod_path})));
		if (b->pref->is_verbose) {
			println(_STR("  >> trying to find %.*s\000 in %.*s\000 ..", 3, mod, try_path));
		}
		if (os__is_dir(try_path)) {
			if (b->pref->is_verbose) {
				println(_STR("  << found %.*s\000 .", 2, try_path));
			}
			Option_string _t3406;
			opt_ok(&(string[]) { try_path }, (Option*)(&_t3406), sizeof(string));
			// autofree_scope_vars(pos=8054 line_nr=267 scope.pos=7981 scope.end_pos=8073)
			// af parent scope:
			// var "search_path" var.pos=7785 var.line_nr=258
			// skipping tmp var "search_path"
			// var "try_path" var.pos=7824 var.line_nr=259
			// af parent scope:
			// var "b" var.pos=6862 var.line_nr=235
			// var "mod" var.pos=6891 var.line_nr=235
			// var "fpath" var.pos=6903 var.line_nr=235
			// var "mcache" var.pos=6973 var.line_nr=237
			// var "vmod_file_location" var.pos=7001 var.line_nr=238
			// var "mod_path" var.pos=7050 var.line_nr=239
			// var "module_lookup_paths" var.pos=7084 var.line_nr=240
			// var "path_parts" var.pos=8107 var.line_nr=271
			// var "smodule_lookup_paths" var.pos=8423 var.line_nr=282
			// af parent scope:
			// af parent scope:
			return _t3406;
		}
	}
	Array_string path_parts = string_split(fpath, _const_os__path_separator);
	for (int i = path_parts.len - 2; i > 0; i--) {
		string p1 = Array_string_join(array_slice(path_parts, 0, i), _const_os__path_separator);
		string try_path = os__join_path(p1, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){mod_path})));
		if (b->pref->is_verbose) {
			println(_STR("  >> trying to find %.*s\000 in %.*s\000 ..", 3, mod, try_path));
		}
		if (os__is_dir(try_path)) {
			Option_string _t3407;
			opt_ok(&(string[]) { try_path }, (Option*)(&_t3407), sizeof(string));
			// autofree_scope_vars(pos=8398 line_nr=279 scope.pos=8394 scope.end_pos=8417)
			// af parent scope:
			// var "i" var.pos=8157 var.line_nr=272
			// var "p1" var.pos=8197 var.line_nr=273
			// var "try_path" var.pos=8246 var.line_nr=274
			// af parent scope:
			// var "b" var.pos=6862 var.line_nr=235
			// var "mod" var.pos=6891 var.line_nr=235
			// var "fpath" var.pos=6903 var.line_nr=235
			// var "mcache" var.pos=6973 var.line_nr=237
			// var "vmod_file_location" var.pos=7001 var.line_nr=238
			// var "mod_path" var.pos=7050 var.line_nr=239
			// var "module_lookup_paths" var.pos=7084 var.line_nr=240
			// var "path_parts" var.pos=8107 var.line_nr=271
			// var "smodule_lookup_paths" var.pos=8423 var.line_nr=282
			// af parent scope:
			// af parent scope:
			return _t3407;
		}
	}
	string smodule_lookup_paths = Array_string_join(module_lookup_paths, _SLIT(", "));
	return (Option_string){ .state=2, .err=v_error(_STR("module \"%.*s\000\" not found in:\n%.*s", 2, mod, smodule_lookup_paths)) };
}

VV_LOCAL_SYMBOL void v__builder__Builder_show_total_warns_and_errors_stats(v__builder__Builder* b) {
	if (b->checker.nr_errors == 0 && b->checker.nr_warnings == 0 && b->checker.nr_notices == 0) {
		return;
	}
	if (b->pref->is_stats) {
		string estring = v__util__bold(int_str(b->checker.nr_errors));
		string wstring = v__util__bold(int_str(b->checker.nr_warnings));
		string nstring = v__util__bold(int_str(b->checker.nr_notices));
		println(_STR("checker summary: %.*s\000 V errors, %.*s\000 V warnings, %.*s\000 V notices", 4, estring, wstring, nstring));
	}
}

VV_LOCAL_SYMBOL void v__builder__Builder_print_warnings_and_errors(v__builder__Builder* b) {
bool v__builder__Builder_print_warnings_and_errors_defer_0 = false;
	v__builder__Builder_print_warnings_and_errors_defer_0 = true;
	if (b->pref->output_mode == v__pref__OutputMode_silent) {
		if (b->checker.nr_errors > 0) {
			v_exit(1);
		}
		// Defer begin
		if (v__builder__Builder_print_warnings_and_errors_defer_0 == true) {
			v__builder__Builder_show_total_warns_and_errors_stats(b);
		}
		// Defer end
		return;
	}
	if (b->pref->is_verbose && b->checker.nr_warnings > 1) {
		println(_STR("%"PRId32"\000 warnings", 2, b->checker.nr_warnings));
	}
	if (b->pref->is_verbose && b->checker.nr_notices > 1) {
		println(_STR("%"PRId32"\000 notices", 2, b->checker.nr_notices));
	}
	if (b->checker.nr_notices > 0 && !b->pref->skip_warnings) {
		// FOR IN array
		for (int i = 0; i < b->checker.notices.len; ++i) {
			v__errors__Notice err = ((v__errors__Notice*)b->checker.notices.data)[i];
			string kind = (b->pref->is_verbose ? (_STR("%.*s\000 notice #%"PRId32"\000:", 3, v__errors__Reporter_str(err.reporter), b->checker.nr_notices)) : (_SLIT("notice:")));
			string ferror = v__util__formatted_error(kind, err.message, err.file_path, err.pos);
			eprintln(ferror);
			if (err.details.len > 0) {
				eprintln(_STR("Details: %.*s", 1, err.details));
			}
			if (i > b->max_nr_errors) {
				// Defer begin
				if (v__builder__Builder_print_warnings_and_errors_defer_0 == true) {
					v__builder__Builder_show_total_warns_and_errors_stats(b);
				}
				// Defer end
				return;
			}
		}
	}
	if (b->checker.nr_warnings > 0 && !b->pref->skip_warnings) {
		// FOR IN array
		for (int i = 0; i < b->checker.warnings.len; ++i) {
			v__errors__Warning err = ((v__errors__Warning*)b->checker.warnings.data)[i];
			string kind = (b->pref->is_verbose ? (_STR("%.*s\000 warning #%"PRId32"\000:", 3, v__errors__Reporter_str(err.reporter), b->checker.nr_warnings)) : (_SLIT("warning:")));
			string ferror = v__util__formatted_error(kind, err.message, err.file_path, err.pos);
			eprintln(ferror);
			if (err.details.len > 0) {
				eprintln(_STR("Details: %.*s", 1, err.details));
			}
			if (i > b->max_nr_errors) {
				// Defer begin
				if (v__builder__Builder_print_warnings_and_errors_defer_0 == true) {
					v__builder__Builder_show_total_warns_and_errors_stats(b);
				}
				// Defer end
				return;
			}
		}
	}
	if (b->pref->is_verbose && b->checker.nr_errors > 1) {
		println(_STR("%"PRId32"\000 errors", 2, b->checker.nr_errors));
	}
	if (b->checker.nr_errors > 0) {
		// FOR IN array
		for (int i = 0; i < b->checker.errors.len; ++i) {
			v__errors__Error err = ((v__errors__Error*)b->checker.errors.data)[i];
			string kind = (b->pref->is_verbose ? (_STR("%.*s\000 error #%"PRId32"\000:", 3, v__errors__Reporter_str(err.reporter), b->checker.nr_errors)) : (_SLIT("error:")));
			string ferror = v__util__formatted_error(kind, err.message, err.file_path, err.pos);
			eprintln(ferror);
			if (err.details.len > 0) {
				eprintln(_STR("Details: %.*s", 1, err.details));
			}
			if (i > b->max_nr_errors) {
				// Defer begin
				if (v__builder__Builder_print_warnings_and_errors_defer_0 == true) {
					v__builder__Builder_show_total_warns_and_errors_stats(b);
				}
				// Defer end
				return;
			}
		}
		v__builder__Builder_show_total_warns_and_errors_stats(b);
		v_exit(1);
	}
	if (b->table->redefined_fns.len > 0) {
		int total_conflicts = 0;
		// FOR IN array
		for (int _t3408 = 0; _t3408 < b->table->redefined_fns.len; ++_t3408) {
			string fn_name = ((string*)b->table->redefined_fns.data)[_t3408];
			Array_v__builder__FunctionRedefinition redefines = __new_array_with_default(0, 0, sizeof(v__builder__FunctionRedefinition), 0);
			Map_string_int redefine_conflicts = new_map(sizeof(string), sizeof(int), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
			// FOR IN array
			for (int _t3409 = 0; _t3409 < b->parsed_files.len; ++_t3409) {
				v__ast__File file = ((v__ast__File*)b->parsed_files.data)[_t3409];
				// FOR IN array
				for (int _t3410 = 0; _t3410 < file.stmts.len; ++_t3410) {
					v__ast__Stmt stmt = ((v__ast__Stmt*)file.stmts.data)[_t3410];
					if ((stmt)._typ == 175 /* v.ast.FnDecl */) {
						if (string_eq((*stmt._v__ast__FnDecl).name, fn_name)) {
							string fheader = v__ast__FnDecl_stringify(&(*stmt._v__ast__FnDecl), b->table, _SLIT("main"), new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string));
							array_push(&redefines, _MOV((v__builder__FunctionRedefinition[]){ (v__builder__FunctionRedefinition){.fpath = file.path,.fline = (*stmt._v__ast__FnDecl).pos.line_nr,.fheader = fheader,.f = (*stmt._v__ast__FnDecl),} }));
							(*(int*)map_get_and_set(&redefine_conflicts, &(string[]){fheader}, &(int[]){ 0 }))++;
						}
					}
				}
			}
			if (redefines.len > 0) {
				eprintln(_STR("redefinition of function `%.*s\000`", 2, fn_name));
				// FOR IN array
				for (int _t3412 = 0; _t3412 < redefines.len; ++_t3412) {
					v__builder__FunctionRedefinition redefine = ((v__builder__FunctionRedefinition*)redefines.data)[_t3412];
					eprintln(v__util__formatted_error(_SLIT("conflicting declaration:"), redefine.fheader, redefine.fpath, redefine.f.pos));
				}
				total_conflicts++;
			}
		}
		if (total_conflicts > 0) {
			v__builder__Builder_show_total_warns_and_errors_stats(b);
			v_exit(1);
		}
	}
// Defer begin
if (v__builder__Builder_print_warnings_and_errors_defer_0 == true) {
	v__builder__Builder_show_total_warns_and_errors_stats(b);
}
// Defer end
}

VV_LOCAL_SYMBOL void v__builder__error_with_pos(string s, string fpath, v__token__Position pos) {
	string ferror = v__util__formatted_error(_SLIT("builder error:"), s, fpath, pos);
	eprintln(ferror);
	v_exit(1);
}

VV_LOCAL_SYMBOL void v__builder__verror(string s) {
	v__util__verror(_SLIT("builder error"), s);
}

string v__builder__Builder_gen_c(v__builder__Builder* b, Array_string v_files) {
	v__util__timing_start(_SLIT("PARSE"));
	b->parsed_files = v__parser__parse_files(v_files, b->table, b->pref, b->global_scope);
	v__builder__Builder_parse_imports(b);
	v__util__Timers_show(v__util__get_timers(), _SLIT("SCAN"));
	v__util__Timers_show(v__util__get_timers(), _SLIT("PARSE"));
	v__util__Timers_show_if_exists(v__util__get_timers(), _SLIT("PARSE stmt"));
	if (b->pref->only_check_syntax) {
		 string _t3413 = _SLIT("");
		// autofree_scope_vars(pos=431 line_nr=17 scope.pos=428 scope.end_pos=443)
		// af parent scope:
		// var "b" var.pos=116 var.line_nr=9
		// var "v_files" var.pos=133 var.line_nr=9
		// var "res" var.pos=772 var.line_nr=32
		// af parent scope:
		// af parent scope:
		return _t3413;
	}
	v__util__timing_start(_SLIT("CHECK"));
	v__ast__Table_generic_struct_insts_to_concrete(b->table);
	v__checker__Checker_check_files(&b->checker, b->parsed_files);
	v__util__timing_measure(_SLIT("CHECK"));
	if (b->pref->skip_unused) {
		v__markused__mark_used(b->table, b->pref, b->parsed_files);
	}
	v__builder__Builder_print_warnings_and_errors(b);
	v__util__timing_start(_SLIT("C GEN"));
	string res = v__gen__c__gen(b->parsed_files, b->table, b->pref);
	v__util__timing_measure(_SLIT("C GEN"));
	// autofree_scope_vars(pos=890 line_nr=36 scope.pos=111 scope.end_pos=902)
	// var "b" var.pos=116 var.line_nr=9
	// var "v_files" var.pos=133 var.line_nr=9
	// var "res" var.pos=772 var.line_nr=32
	// af parent scope:
	// af parent scope:
	return res;
}

void v__builder__Builder_build_c(v__builder__Builder* b, Array_string v_files, string out_file) {
	b->out_name_c = out_file;
	b->pref->out_name_c = os__real_path(out_file);
	v__builder__Builder_info(b, _STR("build_c(%.*s\000)", 2, out_file));
	string output2 = v__builder__Builder_gen_c(b, v_files);
	Option_os__File _t3414 = os__create(out_file);
	if (_t3414.state != 0) { /*or block*/ 
		IError err = _t3414.err;
		v_panic(IError_str(err));
	}
 	os__File f =  *(os__File*)_t3414.data;
	Option_int _t3415 = os__File_writeln(&f, output2);
	if (_t3415.state != 0) { /*or block*/ 
		IError err = _t3415.err;
		v_panic(IError_str(err));
	};
	os__File_close(&f);
	if (b->pref->is_stats) {
		b->stats_lines = string_count(output2, _SLIT("\n")) + 1;
		b->stats_bytes = output2.len;
	}
}

void v__builder__Builder_compile_c(v__builder__Builder* b) {
	if (string_ne(os__user_os(), _SLIT("windows")) && string_eq(b->pref->ccompiler, _SLIT("msvc")) && !string_ends_with(b->pref->out_name, _SLIT(".c"))) {
		v__builder__verror(_STR("Cannot build with msvc on %.*s", 1, os__user_os()));
	}
	if (b->pref->is_verbose) {
		println(_SLIT("all .v files before:"));
	}
	Option_void _t3416 = v__builder__Builder_find_win_cc(b);
	if (_t3416.state != 0 && _t3416.err._typ != _IError_None___index) {
		IError err = _t3416.err;
		v__builder__verror(_const_v__builder__no_compiler_error);
	};
	Array_string files = v__builder__Builder_get_builtin_files(b);
	_PUSH_MANY(&files, (v__builder__Builder_get_user_files(b)), _t3417, Array_string);
	v__builder__Builder_set_module_lookup_paths(b);
	if (b->pref->is_verbose) {
		println(_SLIT("all .v files:"));
		println(Array_string_str(files));
	}
	string out_name_c = v__builder__Builder_get_vtmp_filename(b, b->pref->out_name, _SLIT(".tmp.c"));
	if (b->pref->is_shared) {
		out_name_c = v__builder__Builder_get_vtmp_filename(b, b->pref->out_name, _SLIT(".tmp.so.c"));
	}
	v__builder__Builder_build_c(b, files, out_name_c);
	v__builder__Builder_cc(b);
}

VV_LOCAL_SYMBOL Option_void v__builder__Builder_find_win_cc(v__builder__Builder* v) {
	os__Result ccompiler_version_res = os__execute(_STR("%.*s\000 -v", 2, v->pref->ccompiler));
	if (ccompiler_version_res.exit_code != 0) {
		if (v->pref->is_verbose) {
			println(_STR("%.*s\000 not found, looking for msvc...", 2, v->pref->ccompiler));
		}
		Option_v__builder__MsvcResult _t3418 = v__builder__find_msvc(v->pref->m64);
		if (_t3418.state != 0) { /*or block*/ 
			IError err = _t3418.err;
			if (v->pref->is_verbose) {
				println(_SLIT("msvc not found, looking for thirdparty/tcc..."));
			}
			string vpath = os__dir(v__pref__vexe_path());
			string thirdparty_tcc = os__join_path(vpath, new_array_from_c_array(3, 3, sizeof(string), _MOV((string[3]){_SLIT("thirdparty"), _SLIT("tcc"), _SLIT("tcc.exe")})));
			os__Result tcc_version_res = os__execute(_STR("%.*s\000 -v", 2, thirdparty_tcc));
			if (tcc_version_res.exit_code != 0) {
				if (v->pref->is_verbose) {
					println(_SLIT("tcc not found"));
				}
				return (Option_void){ .state=2, .err=_const_none__ };
			}
			v->pref->ccompiler = thirdparty_tcc;
			v->pref->ccompiler_type = v__pref__CompilerType_tinyc;
			return (Option_void){0};
		};
		v->pref->ccompiler = _SLIT("msvc");
		v->pref->ccompiler_type = v__pref__CompilerType_msvc;
		return (Option_void){0};
	}
	v->pref->ccompiler_type = v__pref__cc_from_string(v->pref->ccompiler);
	return (Option_void){0};
}

VV_LOCAL_SYMBOL void v__builder__Builder_show_c_compiler_output(v__builder__Builder* v, os__Result res) {
	println(_SLIT("======== C Compiler output ========"));
	println(res.output);
	println(_SLIT("================================="));
}

VV_LOCAL_SYMBOL void v__builder__Builder_post_process_c_compiler_output(v__builder__Builder* v, os__Result res) {
	if (res.exit_code == 0) {
		if (v->pref->reuse_tmpc) {
			return;
		}
		// FOR IN array
		for (int _t3419 = 0; _t3419 < v->pref->cleanup_files.len; ++_t3419) {
			string tmpfile = ((string*)v->pref->cleanup_files.data)[_t3419];
			if (os__is_file(tmpfile)) {
				if (v->pref->is_verbose) {
					eprintln(_STR(">> remove tmp file: %.*s", 1, tmpfile));
				}
				Option_void _t3420 = os__rm(tmpfile);
				if (_t3420.state != 0 && _t3420.err._typ != _IError_None___index) {
					IError err = _t3420.err;
					v_panic(IError_str(err));
				};
			}
		}
		return;
	}
	// FOR IN array
	Array_string _t3421 = new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_const_v__builder__c_verror_message_marker, _SLIT("error: include file ")}));
	for (int _t3422 = 0; _t3422 < _t3421.len; ++_t3422) {
		string emsg_marker = ((string*)_t3421.data)[_t3422];
		if (string_contains(res.output, emsg_marker)) {
			string emessage = string_trim_right(string_all_before(string_all_before(string_all_after(res.output, emsg_marker), _SLIT("\n")), _SLIT("\r")), _SLIT("\r\n"));
			v__builder__verror(emessage);
		}
	}
	if (v->pref->is_debug) {
		string eword = _SLIT("error:");
		string khighlight = (term__can_show_color_on_stdout() ? (term__red(eword)) : (eword));
		println(string_replace(string_trim_right(res.output, _SLIT("\r\n")), eword, khighlight));
	} else {
		if (res.output.len < 30) {
			println(res.output);
		} else {
			Array_string elines = v__builder__error_context_lines(res.output, _SLIT("error:"), 1, 12);
			println(_SLIT("=================="));
			// FOR IN array
			for (int _t3423 = 0; _t3423 < elines.len; ++_t3423) {
				string eline = ((string*)elines.data)[_t3423];
				println(eline);
			}
			println(_SLIT("..."));
			println(_SLIT("=================="));
			println(_SLIT("(Use `v -cg` to print the entire error message)\n"));
		}
	}
	v__builder__verror(_const_v__builder__c_error_info);
}

VV_LOCAL_SYMBOL string v__builder__Builder_rebuild_cached_module(v__builder__Builder* v, string vexe, string imp_path) {
	Option_string _t3424 = v__vcache__CacheManager_exists(&v->pref->cache_manager, _SLIT(".o"), imp_path);
	if (_t3424.state != 0) { /*or block*/ 
		IError err = _t3424.err;
		if (v->pref->is_verbose) {
			println(_STR("Cached %.*s\000 .o file not found... Building .o file for %.*s", 2, imp_path, imp_path));
		}
		string pwd = os__getwd();
		string vroot = os__dir(vexe);
		os__chdir(vroot);
		string boptions = Array_string_join(v->pref->build_options, _SLIT(" "));
		string rebuild_cmd = _STR("%.*s\000 %.*s\000 build-module %.*s", 3, vexe, boptions, imp_path);
		v__vcache__dlog(string_add(_SLIT("| Builder."), _SLIT("rebuild_cached_module")), _STR("vexe: %.*s\000 | imp_path: %.*s\000 | rebuild_cmd: %.*s", 3, vexe, imp_path, rebuild_cmd));
		os__system(rebuild_cmd);
		Option_string _t3425 = v__vcache__CacheManager_exists(&v->pref->cache_manager, _SLIT(".o"), imp_path);
		if (_t3425.state != 0) { /*or block*/ 
			err = _t3425.err;
			v_panic(_STR("could not rebuild cache module for %.*s\000, error: %.*s", 2, imp_path, (*(err.msg))));
		}
 		string rebuilded_o =  *(string*)_t3425.data;
		os__chdir(pwd);
		// autofree_scope_vars(pos=4202 line_nr=143 scope.pos=3558 scope.end_pos=4223)
		// var "err" var.pos=3558 var.line_nr=127
		// var "pwd" var.pos=3754 var.line_nr=132
		// var "vroot" var.pos=3774 var.line_nr=133
		// var "boptions" var.pos=3816 var.line_nr=135
		// var "rebuild_cmd" var.pos=3861 var.line_nr=136
		// var "rebuilded_o" var.pos=4043 var.line_nr=139
		// af parent scope:
		// var "v" var.pos=3431 var.line_nr=126
		// var "vexe" var.pos=3464 var.line_nr=126
		// var "imp_path" var.pos=3477 var.line_nr=126
		// var "res" var.pos=3504 var.line_nr=127
		// af parent scope:
		// af parent scope:
		return rebuilded_o;
	}
 	string res =  *(string*)_t3424.data;
	// autofree_scope_vars(pos=4225 line_nr=145 scope.pos=3426 scope.end_pos=4237)
	// var "v" var.pos=3431 var.line_nr=126
	// var "vexe" var.pos=3464 var.line_nr=126
	// var "imp_path" var.pos=3477 var.line_nr=126
	// var "res" var.pos=3504 var.line_nr=127
	// af parent scope:
	// af parent scope:
	return res;
}

VV_LOCAL_SYMBOL void v__builder__Builder_show_cc(v__builder__Builder* v, string cmd, string response_file, string response_file_content) {
	if (v->pref->is_verbose || v->pref->show_cc) {
		println(_SLIT(""));
		println(_SLIT("====================="));
		println(_STR("> C compiler cmd: %.*s", 1, cmd));
		if (v->pref->show_cc) {
			println(_STR("> C compiler response file %.*s\000:", 2, response_file));
			println(response_file_content);
		}
		println(_SLIT("====================="));
	}
}

VV_LOCAL_SYMBOL void v__builder__Builder_setup_ccompiler_options(v__builder__Builder* v, string ccompiler) {
	v__builder__CcompilerOptions ccoptions = (v__builder__CcompilerOptions){.guessed_compiler = (string){.str=(byteptr)"", .is_lit=1},.shared_postfix = (string){.str=(byteptr)"", .is_lit=1},.debug_mode = 0,.is_cc_tcc = 0,.is_cc_gcc = 0,.is_cc_msvc = 0,.is_cc_clang = 0,.env_cflags = (string){.str=(byteptr)"", .is_lit=1},.env_ldflags = (string){.str=(byteptr)"", .is_lit=1},.args = __new_array(0, 1, sizeof(string)),.wargs = __new_array(0, 1, sizeof(string)),.pre_args = __new_array(0, 1, sizeof(string)),.o_args = __new_array(0, 1, sizeof(string)),.source_args = __new_array(0, 1, sizeof(string)),.post_args = __new_array(0, 1, sizeof(string)),.linker_flags = __new_array(0, 1, sizeof(string)),};
	Array_string debug_options = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("-g")}));
	Array_string optimization_options = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("-O2")}));
	ccoptions.args = new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){v->pref->cflags, _SLIT("-std=gnu99")}));
	ccoptions.wargs = new_array_from_c_array(25, 25, sizeof(string), _MOV((string[25]){
			_SLIT("-Wall"), _SLIT("-Wextra"), _SLIT("-Wno-unused"), _SLIT("-Wno-missing-braces"), _SLIT("-Walloc-zero"), _SLIT("-Wcast-qual"), _SLIT("-Wdate-time"), _SLIT("-Wduplicated-branches"), _SLIT("-Wduplicated-cond"), _SLIT("-Wformat=2"), _SLIT("-Winit-self"), _SLIT("-Winvalid-pch"), _SLIT("-Wjump-misses-init"), _SLIT("-Wlogical-op"), _SLIT("-Wmultichar"), _SLIT("-Wnested-externs"), _SLIT("-Wnull-dereference"), _SLIT("-Wpacked"), _SLIT("-Wpointer-arith"), _SLIT("-Wshadow"), _SLIT("-Wswitch-default"), _SLIT("-Wswitch-enum"), _SLIT("-Wno-unused-parameter"), _SLIT("-Wno-unknown-warning-option"), _SLIT("-Wno-format-nonliteral")}));
	if (v->pref->os == v__pref__OS_ios) {
		array_push(&ccoptions.args, _MOV((string[]){ string_clone(_SLIT("-framework Foundation")) }));
		array_push(&ccoptions.args, _MOV((string[]){ string_clone(_SLIT("-framework UIKit")) }));
		array_push(&ccoptions.args, _MOV((string[]){ string_clone(_SLIT("-framework Metal")) }));
		array_push(&ccoptions.args, _MOV((string[]){ string_clone(_SLIT("-framework MetalKit")) }));
		array_push(&ccoptions.args, _MOV((string[]){ string_clone(_SLIT("-DSOKOL_METAL")) }));
		array_push(&ccoptions.args, _MOV((string[]){ string_clone(_SLIT("-fobjc-arc")) }));
	}
	ccoptions.debug_mode = v->pref->is_debug;
	ccoptions.guessed_compiler = v->pref->ccompiler;
	if (string_eq(ccoptions.guessed_compiler, _SLIT("cc")) && v->pref->is_prod) {
		os__Result ccversion = os__execute(_SLIT("cc --version"));
		if (ccversion.exit_code == 0) {
			if (string_contains(ccversion.output, _SLIT("This is free software;")) && string_contains(ccversion.output, _SLIT("Free Software Foundation, Inc."))) {
				ccoptions.guessed_compiler = _SLIT("gcc");
			}
			if (string_contains(ccversion.output, _SLIT("clang version "))) {
				ccoptions.guessed_compiler = _SLIT("clang");
			}
		}
	}
	ccoptions.is_cc_tcc = string_contains(ccompiler, _SLIT("tcc")) || string_eq(ccoptions.guessed_compiler, _SLIT("tcc"));
	ccoptions.is_cc_gcc = string_contains(ccompiler, _SLIT("gcc")) || string_eq(ccoptions.guessed_compiler, _SLIT("gcc"));
	ccoptions.is_cc_msvc = string_contains(ccompiler, _SLIT("msvc")) || string_eq(ccoptions.guessed_compiler, _SLIT("msvc"));
	ccoptions.is_cc_clang = string_contains(ccompiler, _SLIT("clang")) || string_eq(ccoptions.guessed_compiler, _SLIT("clang"));
	if (string_contains(ccoptions.guessed_compiler, _SLIT("++"))) {
		array_push(&ccoptions.args, _MOV((string[]){ string_clone(_SLIT("-fpermissive")) }));
		array_push(&ccoptions.args, _MOV((string[]){ string_clone(_SLIT("-w")) }));
	}
	if (ccoptions.is_cc_clang) {
		if (ccoptions.debug_mode) {
			debug_options = new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT("-g"), _SLIT("-O0")}));
		}
		optimization_options = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("-O3")}));
		bool have_flto = true;
		if (have_flto) {
			array_push(&optimization_options, _MOV((string[]){ string_clone(_SLIT("-flto")) }));
		}
	}
	if (ccoptions.is_cc_gcc) {
		if (ccoptions.debug_mode) {
			debug_options = new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT("-g"), _SLIT("-no-pie")}));
		}
		optimization_options = new_array_from_c_array(3, 3, sizeof(string), _MOV((string[3]){_SLIT("-O3"), _SLIT("-fno-strict-aliasing"), _SLIT("-flto")}));
	}
	if (ccoptions.debug_mode) {
		_PUSH_MANY(&ccoptions.args, (debug_options), _t3435, Array_string);
	}
	if (v->pref->is_prod) {
		if (ccoptions.is_cc_tcc && !(v->parsed_files.len > 0 && string_contains((*(v__ast__File*)array_last(v->parsed_files)).path, _SLIT("vlib")))) {
			eprintln(_SLIT("Note: tcc is not recommended for -prod builds"));
		}
		_PUSH_MANY(&ccoptions.args, (optimization_options), _t3436, Array_string);
	}
	if (v->pref->is_prod && !ccoptions.debug_mode) {
		array_push(&ccoptions.args, _MOV((string[]){ string_clone(_SLIT("-DNDEBUG")) }));
	}
	if (v->pref->sanitize) {
		array_push(&ccoptions.args, _MOV((string[]){ string_clone(_SLIT("-fsanitize=leak")) }));
	}
	ccoptions.shared_postfix = _SLIT(".so");
	#if defined(__APPLE__)
	{
	}
	#elif defined(_WIN32)
	{
		ccoptions.shared_postfix = _SLIT(".dll");
	}
	#endif
	if (v->pref->is_shared) {
		array_push(&ccoptions.linker_flags, _MOV((string[]){ string_clone(_SLIT("-shared")) }));
		array_push(&ccoptions.args, _MOV((string[]){ string_clone(_SLIT("-fPIC")) }));
	}
	if (v->pref->is_bare) {
		array_push(&ccoptions.args, _MOV((string[]){ string_clone(_SLIT("-fno-stack-protector")) }));
		array_push(&ccoptions.args, _MOV((string[]){ string_clone(_SLIT("-ffreestanding")) }));
		array_push(&ccoptions.linker_flags, _MOV((string[]){ string_clone(_SLIT("-static")) }));
		array_push(&ccoptions.linker_flags, _MOV((string[]){ string_clone(_SLIT("-nostdlib")) }));
	}
	if (ccoptions.debug_mode && string_ne(os__user_os(), _SLIT("windows")) && v->pref->build_mode != v__pref__BuildMode_build_module) {
		array_push(&ccoptions.linker_flags, _MOV((string[]){ string_clone(_SLIT("-rdynamic")) }));
	}
	if (string_ne(ccompiler, _SLIT("msvc")) && v->pref->os != v__pref__OS_freebsd) {
		array_push(&ccoptions.wargs, _MOV((string[]){ string_clone(_SLIT("-Werror=implicit-function-declaration")) }));
	}
	if (v->pref->is_liveshared || v->pref->is_livemain) {
		if ((v->pref->os == v__pref__OS_linux || string_eq(os__user_os(), _SLIT("linux"))) && v->pref->build_mode != v__pref__BuildMode_build_module) {
			array_push(&ccoptions.linker_flags, _MOV((string[]){ string_clone(_SLIT("-rdynamic")) }));
		}
		if (v->pref->os == v__pref__OS_macos || string_eq(os__user_os(), _SLIT("macos"))) {
			array_push(&ccoptions.args, _MOV((string[]){ string_clone(_SLIT("-flat_namespace")) }));
		}
	}
	if (v->pref->os == v__pref__OS_macos || v->pref->os == v__pref__OS_ios) {
		if (!ccoptions.is_cc_tcc) {
			array_push(&ccoptions.source_args, _MOV((string[]){ string_clone(_SLIT("-x objective-c")) }));
		}
	}
	array_push(&ccoptions.source_args, _MOV((string[]){ string_clone(_STR("\"%.*s\000\"", 2, v->out_name_c)) }));
	if (v->pref->os == v__pref__OS_macos) {
		array_push(&ccoptions.source_args, _MOV((string[]){ string_clone(_SLIT("-x none")) }));
	}
	if (v->pref->os == v__pref__OS_macos) {
		array_push(&ccoptions.post_args, _MOV((string[]){ string_clone(_SLIT("-mmacosx-version-min=10.7")) }));
	} else if (v->pref->os == v__pref__OS_ios) {
		array_push(&ccoptions.post_args, _MOV((string[]){ string_clone(_SLIT("-miphoneos-version-min=10.0")) }));
	} else if (v->pref->os == v__pref__OS_windows) {
		array_push(&ccoptions.post_args, _MOV((string[]){ string_clone(_SLIT("-municode")) }));
	}
	Array_v__cflag__CFlag cflags = v__builder__Builder_get_os_cflags(v);
	_PUSH_MANY(&ccoptions.o_args, (Array_v__cflag__CFlag_c_options_only_object_files(cflags)), _t3455, Array_string);
	multi_return_Array_string_Array_string_Array_string mr_10448 = Array_v__cflag__CFlag_defines_others_libs(cflags);
	Array_string defines = mr_10448.arg0;
	Array_string others = mr_10448.arg1;
	Array_string libs = mr_10448.arg2;
	_PUSH_MANY(&ccoptions.pre_args, (defines), _t3456, Array_string);
	_PUSH_MANY(&ccoptions.pre_args, (others), _t3457, Array_string);
	_PUSH_MANY(&ccoptions.linker_flags, (libs), _t3458, Array_string);
	if (v->pref->use_cache && v->pref->build_mode != v__pref__BuildMode_build_module) {
		if (!ccoptions.is_cc_tcc) {
		}
	}
	if (ccoptions.is_cc_tcc && !(Array_string_contains(v->pref->compile_defines, _SLIT("no_backtrace")))) {
		array_push(&ccoptions.post_args, _MOV((string[]){ string_clone(_SLIT("-bt25")) }));
	}
	if (!v->pref->is_bare && v->pref->build_mode != v__pref__BuildMode_build_module && (v->pref->os == v__pref__OS_linux || v->pref->os == v__pref__OS_freebsd || v->pref->os == v__pref__OS_openbsd || v->pref->os == v__pref__OS_netbsd || v->pref->os == v__pref__OS_dragonfly || v->pref->os == v__pref__OS_solaris || v->pref->os == v__pref__OS_haiku)) {
		array_push(&ccoptions.linker_flags, _MOV((string[]){ string_clone(_SLIT("-lm")) }));
		array_push(&ccoptions.linker_flags, _MOV((string[]){ string_clone(_SLIT("-lpthread")) }));
		if (v->pref->os == v__pref__OS_linux) {
			array_push(&ccoptions.linker_flags, _MOV((string[]){ string_clone(_SLIT("-ldl")) }));
		}
		if (v->pref->os == v__pref__OS_freebsd) {
			array_push(&ccoptions.linker_flags, _MOV((string[]){ string_clone(_SLIT("-lexecinfo")) }));
		}
	}
	if (!v->pref->is_bare && v->pref->os == v__pref__OS_js && string_eq(os__user_os(), _SLIT("linux"))) {
		array_push(&ccoptions.linker_flags, _MOV((string[]){ string_clone(_SLIT("-lm")) }));
	}
	ccoptions.env_cflags = os__getenv(_SLIT("CFLAGS"));
	ccoptions.env_ldflags = os__getenv(_SLIT("LDFLAGS"));
	v->ccoptions = ccoptions;
	v__vcache__CacheManager_set_temporary_options(&v->pref->cache_manager, v__builder__CcompilerOptions_thirdparty_object_args(&ccoptions, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){ccoptions.guessed_compiler}))));
}

VV_LOCAL_SYMBOL Array_string v__builder__CcompilerOptions_all_args(v__builder__CcompilerOptions* ccoptions) {
	Array_string all = __new_array_with_default(0, 0, sizeof(string), 0);
	array_push(&all, _MOV((string[]){ string_clone(ccoptions->env_cflags) }));
	_PUSH_MANY(&all, (ccoptions->args), _t3466, Array_string);
	_PUSH_MANY(&all, (ccoptions->o_args), _t3467, Array_string);
	_PUSH_MANY(&all, (ccoptions->pre_args), _t3468, Array_string);
	_PUSH_MANY(&all, (ccoptions->source_args), _t3469, Array_string);
	_PUSH_MANY(&all, (ccoptions->post_args), _t3470, Array_string);
	_PUSH_MANY(&all, (ccoptions->linker_flags), _t3471, Array_string);
	array_push(&all, _MOV((string[]){ string_clone(ccoptions->env_ldflags) }));
	// autofree_scope_vars(pos=12854 line_nr=400 scope.pos=12557 scope.end_pos=12866)
	// var "ccoptions" var.pos=12558 var.line_nr=390
	// var "all" var.pos=12613 var.line_nr=391
	// af parent scope:
	// af parent scope:
	return all;
}

VV_LOCAL_SYMBOL Array_string v__builder__CcompilerOptions_thirdparty_object_args(v__builder__CcompilerOptions* ccoptions, Array_string middle) {
	Array_string all = __new_array_with_default(0, 0, sizeof(string), 0);
	array_push(&all, _MOV((string[]){ string_clone(ccoptions->env_cflags) }));
	_PUSH_MANY(&all, (ccoptions->args), _t3474, Array_string);
	_PUSH_MANY(&all, (middle), _t3475, Array_string);
	array_push(&all, _MOV((string[]){ string_clone(ccoptions->env_ldflags) }));
	// autofree_scope_vars(pos=13072 line_nr=409 scope.pos=12872 scope.end_pos=13084)
	// var "ccoptions" var.pos=12873 var.line_nr=403
	// var "middle" var.pos=12924 var.line_nr=403
	// var "all" var.pos=12957 var.line_nr=404
	// af parent scope:
	// af parent scope:
	return all;
}

VV_LOCAL_SYMBOL void v__builder__Builder_setup_output_name(v__builder__Builder* v) {
	if (!v->pref->is_shared && v->pref->build_mode != v__pref__BuildMode_build_module && string_eq(os__user_os(), _SLIT("windows")) && !string_ends_with(v->pref->out_name, _SLIT(".exe"))) {
		v->pref->out_name = /*f*/string_add(v->pref->out_name, _SLIT(".exe"));
	}
	v__builder__Builder_log(v, _STR("cc() isprod=%.*s\000 outname=%.*s", 2, v->pref->is_prod ? _SLIT("true") : _SLIT("false"), v->pref->out_name));
	if (v->pref->is_shared) {
		if (!string_ends_with(v->pref->out_name, v->ccoptions.shared_postfix)) {
			v->pref->out_name = /*f*/string_add(v->pref->out_name, v->ccoptions.shared_postfix);
		}
	}
	if (v->pref->build_mode == v__pref__BuildMode_build_module) {
		v->pref->out_name = v__vcache__CacheManager_postfix_with_key2cpath(&v->pref->cache_manager, _SLIT(".o"), v->pref->path);
		if (v->pref->is_verbose) {
			println(_STR("Building %.*s\000 to %.*s\000 ...", 3, v->pref->path, v->pref->out_name));
		}
		Option_string _t3477 = v__vcache__CacheManager_save(&v->pref->cache_manager, _SLIT(".description.txt"), v->pref->path, _STR("%*.*s\000 @ %.*s\000\n", 3, v->pref->path, -30, v->pref->cache_manager.vopts));
		if (_t3477.state != 0) { /*or block*/ 
			IError err = _t3477.err;
			v_panic(IError_str(err));
		};
	}
	if (os__is_dir(v->pref->out_name)) {
		v__builder__verror(_STR("'%.*s\000' is a directory", 2, v->pref->out_name));
	}
	array_push(&v->ccoptions.o_args, _MOV((string[]){ string_clone(_STR("-o \"%.*s\000\"", 2, v->pref->out_name)) }));
}

VV_LOCAL_SYMBOL bool v__builder__Builder_vjs_cc(v__builder__Builder* v) {
	string vexe = v__pref__vexe_path();
	string vdir = os__dir(vexe);
	bool ends_with_c = string_ends_with(v->pref->out_name, _SLIT(".c"));
	bool ends_with_js = string_ends_with(v->pref->out_name, _SLIT(".js"));
	if (ends_with_c || ends_with_js) {
		v->pref->skip_running = true;
		#if !defined(_VJS)
		{
			if (ends_with_js) {
				string vjs_path = string_add(vexe, _SLIT("js"));
				if (!os__exists(vjs_path)) {
					println(_SLIT("V.js compiler not found, building..."));
					int ret = os__system(_STR("%.*s\000 -o %.*s\000 -os js %.*s\000/cmd/v", 4, vexe, vjs_path, vdir));
					if (ret == 0) {
						println(_SLIT("Done."));
					} else {
						println(_SLIT("Failed."));
						v_exit(1);
					}
				}
				int ret = os__system(_STR("%.*s\000 -o %.*s\000 %.*s", 3, vjs_path, v->pref->out_name, v->pref->path));
				if (ret == 0) {
					println(_STR("Done. Run it with `node %.*s\000`", 2, v->pref->out_name));
					println(_SLIT("JS backend is at a very early stage."));
				}
			}
		}
		#endif
		Option_void _t3479 = os__mv_by_cp(v->out_name_c, v->pref->out_name);
		if (_t3479.state != 0 && _t3479.err._typ != _IError_None___index) {
			IError err = _t3479.err;
			v_panic(IError_str(err));
		};
		 bool _t3480 = true;
		// autofree_scope_vars(pos=15317 line_nr=477 scope.pos=14375 scope.end_pos=15331)
		// af parent scope:
		// var "v" var.pos=14088 var.line_nr=441
		// var "vexe" var.pos=14116 var.line_nr=442
		// var "vdir" var.pos=14142 var.line_nr=443
		// var "ends_with_c" var.pos=14246 var.line_nr=446
		// var "ends_with_js" var.pos=14294 var.line_nr=447
		// af parent scope:
		// af parent scope:
		return _t3480;
	}
	 bool _t3481 = false;
	// autofree_scope_vars(pos=15333 line_nr=479 scope.pos=14083 scope.end_pos=15347)
	// var "v" var.pos=14088 var.line_nr=441
	// var "vexe" var.pos=14116 var.line_nr=442
	// var "vdir" var.pos=14142 var.line_nr=443
	// var "ends_with_c" var.pos=14246 var.line_nr=446
	// var "ends_with_js" var.pos=14294 var.line_nr=447
	// af parent scope:
	// af parent scope:
	return _t3481;
}

VV_LOCAL_SYMBOL void v__builder__Builder_dump_c_options(v__builder__Builder* v, Array_string all_args) {
	if ((v->pref->dump_c_flags).len != 0) {
		Array_string _t3482_orig = all_args;
		int _t3482_len = _t3482_orig.len;
		Array_string _t3482 = __new_array(0, _t3482_len, sizeof(string));

		for (int _t3483 = 0; _t3483 < _t3482_len; ++_t3483) {
			string it = ((string*) _t3482_orig.data)[_t3483];
			if ((it).len != 0) {
				array_push(&_t3482, &it); 
		}
		}
		
		string non_empty_args = string_add(Array_string_join(_t3482, _SLIT("\n")), _SLIT("\n"));
		if (string_eq(v->pref->dump_c_flags, _SLIT("-"))) {
			print(non_empty_args);
		} else {
			Option_void _t3484 = os__write_file(v->pref->dump_c_flags, non_empty_args);
			if (_t3484.state != 0 && _t3484.err._typ != _IError_None___index) {
				IError err = _t3484.err;
				v_panic(IError_str(err));
			};
		}
	}
}

VV_LOCAL_SYMBOL void v__builder__Builder_cc(v__builder__Builder* v) {
	if (string_contains(os__executable(), _SLIT("vfmt"))) {
		return;
	}
	if (v->pref->is_verbose) {
		println(_STR("builder.cc() pref.out_name=\"%.*s\000\"", 2, v->pref->out_name));
	}
	if (v->pref->only_check_syntax) {
		if (v->pref->is_verbose) {
			println(_SLIT("builder.cc returning early, since pref.only_check_syntax is true"));
		}
		return;
	}
	if (v__builder__Builder_vjs_cc(v)) {
		return;
	}
	if (v->pref->os == v__pref__OS_windows) {
	}
	if (v->pref->os == v__pref__OS_linux) {
		#if !defined(__linux__)
		{
			v__builder__Builder_cc_linux_cross(v);
			return;
		}
		#endif
	}
	string vexe = v__pref__vexe_path();
	string vdir = os__dir(vexe);
	Array_string tried_compilation_commands = __new_array_with_default(0, 0, sizeof(string), 0);
	os__Result tcc_output = (os__Result){.exit_code = 0,.output = (string){.str=(byteptr)"", .is_lit=1},};
	string original_pwd = os__getwd();
	for (;;) {
		string ccompiler = v->pref->ccompiler;
		if (v->pref->os == v__pref__OS_ios) {
			string ios_sdk = (v->pref->is_ios_simulator ? (_SLIT("iphonesimulator")) : (_SLIT("iphoneos")));
			os__Result ios_sdk_path_res = os__execute_or_panic(_STR("xcrun --sdk %.*s\000 --show-sdk-path", 2, ios_sdk));
			string isysroot = string_replace(ios_sdk_path_res.output, _SLIT("\n"), _SLIT(""));
			string arch = (v->pref->is_ios_simulator ? (_SLIT("-arch x86_64")) : (_SLIT("-arch armv7 -arch armv7s -arch arm64")));
			ccompiler = _STR("xcrun --sdk iphoneos clang -isysroot %.*s\000 %.*s", 2, isysroot, arch);
		}
		v__builder__Builder_setup_ccompiler_options(v, ccompiler);
		v__builder__Builder_build_thirdparty_obj_files(v);
		v__builder__Builder_setup_output_name(v);
		Array_string libs = __new_array_with_default(0, 0, sizeof(string), 0);
		if (v->pref->build_mode == v__pref__BuildMode_build_module) {
			array_push(&v->ccoptions.pre_args, _MOV((string[]){ string_clone(_SLIT("-c")) }));
		} else if (v->pref->use_cache) {
			Array_string built_modules = __new_array_with_default(0, 0, sizeof(string), 0);
			string builtin_obj_path = v__builder__Builder_rebuild_cached_module(v, vexe, _SLIT("vlib/builtin"));
			array_push(&libs, _MOV((string[]){ string_clone(builtin_obj_path) }));
			// FOR IN array
			for (int _t3487 = 0; _t3487 < v->parsed_files.len; ++_t3487) {
				v__ast__File ast_file = ((v__ast__File*)v->parsed_files.data)[_t3487];
				if (v->pref->is_test && string_ne(ast_file.mod.name, _SLIT("main"))) {
					Option_string _t3488 = v__builder__Builder_find_module_path(v, ast_file.mod.name, ast_file.path);
					if (_t3488.state != 0) { /*or block*/ 
						IError err = _t3488.err;
						v__builder__verror(_STR("cannot import module \"%.*s\000\" (not found)", 2, ast_file.mod.name));
						break;
					}
 					string imp_path =  *(string*)_t3488.data;
					string obj_path = v__builder__Builder_rebuild_cached_module(v, vexe, imp_path);
					array_push(&libs, _MOV((string[]){ string_clone(obj_path) }));
					array_push(&built_modules, _MOV((string[]){ string_clone(ast_file.mod.name) }));
				}
				// FOR IN array
				for (int _t3491 = 0; _t3491 < ast_file.imports.len; ++_t3491) {
					v__ast__Import imp_stmt = ((v__ast__Import*)ast_file.imports.data)[_t3491];
					string imp = imp_stmt.mod;
					if ((string_eq(imp, _SLIT("strconv")) || string_eq(imp, _SLIT("strings")))) {
						continue;
					}
					if ((Array_string_contains(built_modules, imp))) {
						continue;
					}
					if (v__util__should_bundle_module(imp)) {
						continue;
					}
					if (string_eq(imp, _SLIT("webview"))) {
						continue;
					}
					if (string_eq(imp, _SLIT("help"))) {
						continue;
					}
					Option_string _t3492 = v__builder__Builder_find_module_path(v, imp, ast_file.path);
					if (_t3492.state != 0) { /*or block*/ 
						IError err = _t3492.err;
						v__builder__verror(_STR("cannot import module \"%.*s\000\" (not found)", 2, imp));
						break;
					}
 					string imp_path =  *(string*)_t3492.data;
					string obj_path = v__builder__Builder_rebuild_cached_module(v, vexe, imp_path);
					array_push(&libs, _MOV((string[]){ string_clone(obj_path) }));
					if (string_ends_with(obj_path, _SLIT("vlib/ui.o"))) {
						array_push(&v->ccoptions.post_args, _MOV((string[]){ string_clone(_SLIT("-framework Cocoa")) }));
						array_push(&v->ccoptions.post_args, _MOV((string[]){ string_clone(_SLIT("-framework Carbon")) }));
					}
					array_push(&built_modules, _MOV((string[]){ string_clone(imp) }));
				}
			}
			_PUSH_MANY(&v->ccoptions.post_args, (libs), _t3497, Array_string);
		}
		if (string_eq(ccompiler, _SLIT("msvc"))) {
			v__builder__Builder_cc_msvc(v);
			return;
		}
		Array_string all_args = v__builder__CcompilerOptions_all_args(&v->ccoptions);
		v__builder__Builder_dump_c_options(v, all_args);
		string str_args = Array_string_join(all_args, _SLIT(" "));
		string response_file = _STR("%.*s\000.rsp", 2, v->out_name_c);
		string response_file_content = string_replace(str_args, _SLIT("\\"), _SLIT("\\\\"));
		Option_void _t3498 = os__write_file(response_file, response_file_content);
		if (_t3498.state != 0 && _t3498.err._typ != _IError_None___index) {
			IError err = _t3498.err;
			v__builder__verror(_STR("Unable to write response file \"%.*s\000\"", 2, response_file));
		};
		if (!v->ccoptions.debug_mode) {
			array_push(&v->pref->cleanup_files, _MOV((string[]){ string_clone(v->out_name_c) }));
			array_push(&v->pref->cleanup_files, _MOV((string[]){ string_clone(response_file) }));
		}
		if (v->ccoptions.is_cc_tcc) {
			string def_name = string_substr(v->pref->out_name, 0, v->pref->out_name.len - 4);
			array_push(&v->pref->cleanup_files, _MOV((string[]){ string_clone(_STR("%.*s\000.def", 2, def_name)) }));
		}
		os__chdir(vdir);
		string cmd = _STR("%.*s\000 \"@%.*s\000\"", 3, ccompiler, response_file);
		array_push(&tried_compilation_commands, _MOV((string[]){ string_clone(cmd) }));
		v__builder__Builder_show_cc(v, cmd, response_file, response_file_content);
		string ccompiler_label = _STR("C %*.*s", 1, os__file_name(ccompiler), 3);
		v__util__timing_start(ccompiler_label);
		os__Result res = os__execute(cmd);
		v__util__timing_measure(ccompiler_label);
		if (v->pref->show_c_output) {
			v__builder__Builder_show_c_compiler_output(v, res);
		}
		os__chdir(original_pwd);
		v__vcache__dlog(string_add(_SLIT("| Builder."), _SLIT("cc")), _STR(">       v.pref.use_cache: %.*s\000 | v.pref.retry_compilation: %.*s", 2, v->pref->use_cache ? _SLIT("true") : _SLIT("false"), v->pref->retry_compilation ? _SLIT("true") : _SLIT("false")));
		v__vcache__dlog(string_add(_SLIT("| Builder."), _SLIT("cc")), _STR(">      cmd res.exit_code: %"PRId32"\000 | cmd: %.*s", 2, res.exit_code, cmd));
		v__vcache__dlog(string_add(_SLIT("| Builder."), _SLIT("cc")), _STR(">  response_file_content:\n%.*s", 1, response_file_content));
		if (res.exit_code != 0) {
			if (string_contains(ccompiler, _SLIT("tcc.exe"))) {
				if (tried_compilation_commands.len > 1) {
					eprintln(_STR("Recompilation loop detected (ccompiler: %.*s\000):", 2, ccompiler));
					// FOR IN array
					for (int _t3503 = 0; _t3503 < tried_compilation_commands.len; ++_t3503) {
						string recompile_command = ((string*)tried_compilation_commands.data)[_t3503];
						eprintln(_STR("   %.*s", 1, recompile_command));
					}
					v_exit(101);
				}
				if (v->pref->retry_compilation) {
					tcc_output = res;
					v->pref->ccompiler = v__pref__default_c_compiler();
					if (v->pref->is_verbose) {
						eprintln(_STR("Compilation with tcc failed. Retrying with %.*s\000 ...", 2, v->pref->ccompiler));
					}
					continue;
				}
			}
			if (res.exit_code == 127) {
				v__builder__verror(string_add(string_add(string_add(string_add(string_add(string_add(_SLIT("C compiler error, while attempting to run: \n"), _SLIT("-----------------------------------------------------------\n")), _STR("%.*s\000\n", 2, cmd)), _SLIT("-----------------------------------------------------------\n")), _SLIT("Probably your C compiler is missing. \n")), _SLIT("Please reinstall it, or make it available in your PATH.\n\n")), v__builder__missing_compiler_info()));
			}
		}
		if (!v->pref->show_c_output) {
			if (res.exit_code != 0 && (tcc_output.output).len != 0) {
				v__builder__Builder_post_process_c_compiler_output(v, tcc_output);
			} else {
				v__builder__Builder_post_process_c_compiler_output(v, res);
			}
		}
		if (v->pref->is_verbose) {
			println(_STR("%.*s", 1, ccompiler));
			println(_SLIT("=========\n"));
		}
		break;
	}
	if (v->pref->compress) {
		println(_SLIT("-compress does not work on Windows for now"));
		return;
		int ret = os__system(_STR("strip %.*s", 1, v->pref->out_name));
		if (ret != 0) {
			println(_SLIT("strip failed"));
			return;
		}
		int ret2 = os__system(_STR("upx --lzma -qqq %.*s", 1, v->pref->out_name));
		if (ret2 != 0) {
			ret2 = os__system(_STR("upx -qqq %.*s", 1, v->pref->out_name));
		}
		if (ret2 != 0) {
			println(_SLIT("upx failed"));
		}
	}
}

VV_LOCAL_SYMBOL void v__builder__Builder_cc_linux_cross(v__builder__Builder* b) {
	v__builder__Builder_setup_ccompiler_options(b, b->pref->ccompiler);
	v__builder__Builder_build_thirdparty_obj_files(b);
	v__builder__Builder_setup_output_name(b);
	string parent_dir = os__vmodules_dir();
	if (!os__exists(parent_dir)) {
		Option_bool _t3504 = os__mkdir(parent_dir);
		if (_t3504.state != 0) { /*or block*/ 
			IError err = _t3504.err;
			v_panic(IError_str(err));
		};
	}
	string sysroot = os__join_path(os__vmodules_dir(), new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("linuxroot")})));
	if (!os__is_dir(sysroot)) {
		println(_SLIT("Downloading files for Linux cross compilation (~18 MB)..."));
		string zip_url = _SLIT("https://github.com/vlang/v/releases/download/0.1.27/linuxroot.zip");
		string zip_file = string_add(sysroot, _SLIT(".zip"));
		os__system(_STR("curl -L -o %.*s\000 %.*s", 2, zip_file, zip_url));
		if (!os__exists(zip_file)) {
			v__builder__verror(_STR("Failed to download `%.*s\000` as %.*s", 2, zip_url, zip_file));
		}
		os__system(_STR("tar -C %.*s\000 -xf %.*s", 2, parent_dir, zip_file));
		if (!os__is_dir(sysroot)) {
			v__builder__verror(_STR("Failed to unzip %.*s\000 to %.*s", 2, zip_file, parent_dir));
		}
	}
	string obj_file = string_add(b->out_name_c, _SLIT(".o"));
	Array_v__cflag__CFlag cflags = v__builder__Builder_get_os_cflags(b);
	multi_return_Array_string_Array_string_Array_string mr_24008 = Array_v__cflag__CFlag_defines_others_libs(cflags);
	Array_string defines = mr_24008.arg0;
	Array_string others = mr_24008.arg1;
	Array_string libs = mr_24008.arg2;
	Array_string cc_args = __new_array_with_default(0, 0, sizeof(string), 0);
	array_push(&cc_args, _MOV((string[]){ string_clone(_SLIT("-w")) }));
	array_push(&cc_args, _MOV((string[]){ string_clone(_SLIT("-fPIC")) }));
	array_push(&cc_args, _MOV((string[]){ string_clone(_SLIT("-c")) }));
	array_push(&cc_args, _MOV((string[]){ string_clone(_SLIT("-target x86_64-linux-gnu")) }));
	_PUSH_MANY(&cc_args, (defines), _t3509, Array_string);
	array_push(&cc_args, _MOV((string[]){ string_clone(_STR("-I %.*s\000/include ", 2, sysroot)) }));
	_PUSH_MANY(&cc_args, (others), _t3511, Array_string);
	array_push(&cc_args, _MOV((string[]){ string_clone(_STR("-o \"%.*s\000\"", 2, obj_file)) }));
	array_push(&cc_args, _MOV((string[]){ string_clone(_STR("-c \"%.*s\000\"", 2, b->out_name_c)) }));
	_PUSH_MANY(&cc_args, (libs), _t3514, Array_string);
	v__builder__Builder_dump_c_options(b, cc_args);
	string cc_cmd = string_add(_SLIT("cc "), Array_string_join(cc_args, _SLIT(" ")));
	if (b->pref->show_cc) {
		println(cc_cmd);
	}
	os__Result cc_res = os__execute(cc_cmd);
	if (cc_res.exit_code != 0) {
		println(_SLIT("Cross compilation for Linux failed (first step, cc). Make sure you have clang installed."));
		v__builder__verror(cc_res.output);
		return;
	}
	Array_string linker_args = new_array_from_c_array(12, 12, sizeof(string), _MOV((string[12]){
			_STR("-L %.*s\000/usr/lib/x86_64-linux-gnu/", 2, sysroot), _STR("--sysroot=%.*s", 1, sysroot), _SLIT("-v"), _STR("-o %.*s", 1, b->pref->out_name), _SLIT("-m elf_x86_64"), _SLIT("-dynamic-linker /lib/x86_64-linux-gnu/ld-linux-x86-64.so.2"), _STR("%.*s\000/crt1.o %.*s\000/crti.o %.*s", 3, sysroot, sysroot, obj_file), _SLIT("-lc"), _SLIT("-lcrypto"), _SLIT("-lssl"), _SLIT("-lpthread"), _STR("%.*s\000/crtn.o", 2, sysroot)}));
	_PUSH_MANY(&linker_args, (Array_v__cflag__CFlag_c_options_only_object_files(cflags)), _t3515, Array_string);
	v__builder__Builder_dump_c_options(b, linker_args);
	string linker_cmd = string_add(_STR("%.*s\000/ld.lld ", 2, sysroot), Array_string_join(linker_args, _SLIT(" ")));
	if (b->pref->show_cc) {
		println(linker_cmd);
	}
	os__Result res = os__execute(linker_cmd);
	if (res.exit_code != 0) {
		println(_SLIT("Cross compilation for Linux failed (second step, lld)."));
		v__builder__verror(res.output);
		return;
	}
	println(string_add(b->pref->out_name, _SLIT(" has been successfully compiled")));
}

VV_LOCAL_SYMBOL void v__builder__Builder_cc_windows_cross(v__builder__Builder* c) {
	println(_SLIT("Cross compiling for Windows..."));
	v__builder__Builder_setup_ccompiler_options(c, c->pref->ccompiler);
	v__builder__Builder_build_thirdparty_obj_files(c);
	v__builder__Builder_setup_output_name(c);
	if (!string_ends_with(c->pref->out_name, _SLIT(".exe"))) {
		c->pref->out_name = /*f*/string_add(c->pref->out_name, _SLIT(".exe"));
	}
	Array_string args = __new_array_with_default(0, 0, sizeof(string), 0);
	array_push(&args, _MOV((string[]){ string_clone(_STR("%.*s", 1, c->pref->cflags)) }));
	array_push(&args, _MOV((string[]){ string_clone(_STR("-o %.*s", 1, c->pref->out_name)) }));
	array_push(&args, _MOV((string[]){ string_clone(_SLIT("-w -L.")) }));
	Array_v__cflag__CFlag cflags = v__builder__Builder_get_os_cflags(c);
	if (string_eq(c->pref->ccompiler, _SLIT("msvc"))) {
		_PUSH_MANY(&args, (Array_v__cflag__CFlag_c_options_before_target_msvc(cflags)), _t3519, Array_string);
	} else {
		_PUSH_MANY(&args, (Array_v__cflag__CFlag_c_options_before_target(cflags)), _t3520, Array_string);
	}
	Array_string optimization_options = __new_array_with_default(0, 0, sizeof(string), 0);
	Array_string debug_options = __new_array_with_default(0, 0, sizeof(string), 0);
	if (c->pref->is_prod) {
		if (string_ne(c->pref->ccompiler, _SLIT("msvc"))) {
			optimization_options = new_array_from_c_array(3, 3, sizeof(string), _MOV((string[3]){_SLIT("-O3"), _SLIT("-fno-strict-aliasing"), _SLIT("-flto")}));
		}
	}
	if (c->pref->is_debug) {
		if (string_ne(c->pref->ccompiler, _SLIT("msvc"))) {
			debug_options = new_array_from_c_array(3, 3, sizeof(string), _MOV((string[3]){_SLIT("-O0"), _SLIT("-g"), _SLIT("-gdwarf-2")}));
		}
	}
	Array_string libs = __new_array_with_default(0, 0, sizeof(string), 0);
	if (false && c->pref->build_mode == v__pref__BuildMode_default_mode) {
		string builtin_o = _STR("\"%.*s\000/vlib/builtin.o\"", 2, _const_v__pref__default_module_path);
		array_push(&libs, _MOV((string[]){ string_clone(builtin_o) }));
		if (!os__exists(builtin_o)) {
			v__builder__verror(_STR("%.*s\000 not found", 2, builtin_o));
		}
		// FOR IN array
		for (int _t3522 = 0; _t3522 < c->table->imports.len; ++_t3522) {
			string imp = ((string*)c->table->imports.data)[_t3522];
			array_push(&libs, _MOV((string[]){ string_clone(_STR("\"%.*s\000/vlib/%.*s\000.o\"", 3, _const_v__pref__default_module_path, imp)) }));
		}
	}
	_PUSH_MANY(&args, (Array_v__cflag__CFlag_c_options_only_object_files(cflags)), _t3524, Array_string);
	array_push(&args, _MOV((string[]){ string_clone(c->out_name_c) }));
	if (string_eq(c->pref->ccompiler, _SLIT("msvc"))) {
		_PUSH_MANY(&args, (Array_v__cflag__CFlag_c_options_after_target_msvc(cflags)), _t3526, Array_string);
	} else {
		_PUSH_MANY(&args, (Array_v__cflag__CFlag_c_options_after_target(cflags)), _t3527, Array_string);
	}
	if (!(string_eq(os__user_os(), _SLIT("macos")) || string_eq(os__user_os(), _SLIT("linux")))) {
		println(os__user_os());
		v_panic(_SLIT("your platform is not supported yet"));
	}
	Array_string all_args = __new_array_with_default(0, 0, sizeof(string), 0);
	_PUSH_MANY(&all_args, (optimization_options), _t3528, Array_string);
	_PUSH_MANY(&all_args, (debug_options), _t3529, Array_string);
	array_push(&all_args, _MOV((string[]){ string_clone(_SLIT("-std=gnu11")) }));
	_PUSH_MANY(&all_args, (args), _t3531, Array_string);
	array_push(&all_args, _MOV((string[]){ string_clone(_SLIT("-municode")) }));
	v__builder__Builder_dump_c_options(c, all_args);
	string cmd = string_add(_STR("%.*s\000 ", 2, _const_v__builder__mingw_cc), Array_string_join(all_args, _SLIT(" ")));
	if (c->pref->is_verbose || c->pref->show_cc) {
		println(cmd);
	}
	if (os__system(cmd) != 0) {
		println(_SLIT("Cross compilation for Windows failed. Make sure you have mingw-w64 installed."));
		v_exit(1);
	}
	println(string_add(c->pref->out_name, _SLIT(" has been successfully compiled")));
}

VV_LOCAL_SYMBOL void v__builder__Builder_build_thirdparty_obj_files(v__builder__Builder* b) {
	v__builder__Builder_log(b, _STR("build_thirdparty_obj_files: v.ast.cflags: %.*s", 1, Array_v__cflag__CFlag_str(b->table->cflags)));
	// FOR IN array
	Array_v__cflag__CFlag _t3533 = v__builder__Builder_get_os_cflags(b);
	for (int _t3534 = 0; _t3534 < _t3533.len; ++_t3534) {
		v__cflag__CFlag flag = ((v__cflag__CFlag*)_t3533.data)[_t3534];
		if (string_ends_with(flag.value, _SLIT(".o"))) {
			Array_v__cflag__CFlag rest_of_module_flags = v__builder__Builder_get_rest_of_module_cflags(b, (voidptr)&/*qq*/flag);
			if (string_eq(b->pref->ccompiler, _SLIT("msvc"))) {
				v__builder__Builder_build_thirdparty_obj_file_with_msvc(b, flag.value, rest_of_module_flags);
			} else {
				v__builder__Builder_build_thirdparty_obj_file(b, flag.value, rest_of_module_flags);
			}
		}
	}
}

VV_LOCAL_SYMBOL void v__builder__Builder_build_thirdparty_obj_file(v__builder__Builder* v, string path, Array_v__cflag__CFlag moduleflags) {
	string obj_path = os__real_path(path);
	string cfile = _STR("%.*s\000.c", 2, string_substr(obj_path, 0, obj_path.len - 2));
	string opath = v__vcache__CacheManager_postfix_with_key2cpath(&v->pref->cache_manager, _SLIT(".o"), obj_path);
	string rebuild_reason_message = _STR("%.*s\000 not found, building it in %.*s\000 ...", 3, obj_path, opath);
	if (os__exists(opath)) {
		if (os__exists(cfile) && os__file_last_mod_unix(opath) < os__file_last_mod_unix(cfile)) {
			rebuild_reason_message = _STR("%.*s\000 is older than %.*s\000, rebuilding ...", 3, opath, cfile);
		} else {
			return;
		}
	}
	if (os__exists(obj_path)) {
		Option_void _t3535 = os__cp(obj_path, opath);
		if (_t3535.state != 0 && _t3535.err._typ != _IError_None___index) {
			IError err = _t3535.err;
			v_panic(IError_str(err));
		};
		return;
	}
	println(rebuild_reason_message);
	string current_folder = os__getwd();
	os__chdir(os__dir(v__pref__vexe_path()));
	Array_string all_options = __new_array_with_default(0, 0, sizeof(string), 0);
	array_push(&all_options, _MOV((string[]){ string_clone(v->pref->third_party_option) }));
	_PUSH_MANY(&all_options, (Array_v__cflag__CFlag_c_options_before_target(moduleflags)), _t3537, Array_string);
	array_push(&all_options, _MOV((string[]){ string_clone(_STR("-o \"%.*s\000\"", 2, opath)) }));
	array_push(&all_options, _MOV((string[]){ string_clone(_STR("-c \"%.*s\000\"", 2, cfile)) }));
	string cc_options = Array_string_join(v__builder__CcompilerOptions_thirdparty_object_args(&v->ccoptions, all_options), _SLIT(" "));
	string cmd = _STR("%.*s\000 %.*s", 2, v->pref->ccompiler, cc_options);
	os__Result res = os__execute(cmd);
	os__chdir(current_folder);
	if (res.exit_code != 0) {
		eprintln(_STR("failed thirdparty object build cmd:\n%.*s", 1, cmd));
		v__builder__verror(res.output);
		return;
	}
	Option_string _t3540 = v__vcache__CacheManager_save(&v->pref->cache_manager, _SLIT(".description.txt"), obj_path, _STR("%*.*s\000 @ %.*s\000\n", 3, obj_path, -30, cmd));
	if (_t3540.state != 0) { /*or block*/ 
		IError err = _t3540.err;
		v_panic(IError_str(err));
	};
	if ((res.output).len != 0) {
		println(res.output);
	}
}

VV_LOCAL_SYMBOL string v__builder__missing_compiler_info(void) {
	 string _t3541 = _SLIT("https://github.com/vlang/v/wiki/Installing-a-C-compiler-on-Windows");
	// autofree_scope_vars(pos=31035 line_nr=982 scope.pos=31032 scope.end_pos=31113)
	// af parent scope:
	// af parent scope:
	// af parent scope:
	return _t3541;
	 string _t3542 = _SLIT("");
	// autofree_scope_vars(pos=31289 line_nr=990 scope.pos=30986 scope.end_pos=31300)
	// af parent scope:
	// af parent scope:
	return _t3542;
}

VV_LOCAL_SYMBOL Array_string v__builder__error_context_lines(string text, string keyword, int before, int after) {
	string khighlight = (term__can_show_color_on_stdout() ? (term__red(keyword)) : (keyword));
	int eline_idx = 0;
	Array_string lines = string_split_into_lines(text);
	// FOR IN array
	for (int idx = 0; idx < lines.len; ++idx) {
		string eline = ((string*)lines.data)[idx];
		if (string_contains(eline, keyword)) {
			array_set(&lines, idx, &(string[]) { string_replace((*(string*)/*ee elem_typ */array_get(lines, idx)), keyword, khighlight) });
			if (eline_idx == 0) {
				eline_idx = idx;
			}
		}
	}
	int idx_s = (eline_idx - before >= 0 ? (eline_idx - before) : (0));
	int idx_e = (idx_s + after < lines.len ? (idx_s + after) : (lines.len));
	 Array_string _t3543 = array_slice(lines, idx_s, idx_e);
	// autofree_scope_vars(pos=31852 line_nr=1007 scope.pos=31306 scope.end_pos=31880)
	// var "text" var.pos=31326 var.line_nr=993
	// var "keyword" var.pos=31339 var.line_nr=993
	// var "before" var.pos=31355 var.line_nr=993
	// var "after" var.pos=31367 var.line_nr=993
	// var "khighlight" var.pos=31390 var.line_nr=994
	// var "eline_idx" var.pos=31483 var.line_nr=995
	// var "lines" var.pos=31503 var.line_nr=996
	// var "idx_s" var.pos=31706 var.line_nr=1005
	// var "idx_e" var.pos=31777 var.line_nr=1006
	// af parent scope:
	// af parent scope:
	return _t3543;
}

VV_LOCAL_SYMBOL Array_v__cflag__CFlag v__builder__Builder_get_os_cflags(v__builder__Builder* v) {
	Array_v__cflag__CFlag flags = __new_array_with_default(0, 0, sizeof(v__cflag__CFlag), 0);
	Array_string ctimedefines = __new_array_with_default(0, 0, sizeof(string), 0);
	if (v->pref->compile_defines.len > 0) {
		_PUSH_MANY(&ctimedefines, (v->pref->compile_defines), _t3544, Array_string);
	}
	// FOR IN array
	for (int _t3545 = 0; _t3545 < v->table->cflags.len; ++_t3545) {
		v__cflag__CFlag* flag = ((v__cflag__CFlag*)v->table->cflags.data) + _t3545;
		if (string_ends_with(flag->value, _SLIT(".o"))) {
			flag->cached = v__vcache__CacheManager_postfix_with_key2cpath(&v->pref->cache_manager, _SLIT(".o"), os__real_path(flag->value));
		}
		if ((flag->os).len == 0 || (string_eq(flag->os, _SLIT("linux")) && v->pref->os == v__pref__OS_linux) || (string_eq(flag->os, _SLIT("macos")) && v->pref->os == v__pref__OS_macos) || (string_eq(flag->os, _SLIT("darwin")) && v->pref->os == v__pref__OS_macos) || (string_eq(flag->os, _SLIT("freebsd")) && v->pref->os == v__pref__OS_freebsd) || (string_eq(flag->os, _SLIT("windows")) && v->pref->os == v__pref__OS_windows) || (string_eq(flag->os, _SLIT("mingw")) && v->pref->os == v__pref__OS_windows && string_ne(v->pref->ccompiler, _SLIT("msvc"))) || (string_eq(flag->os, _SLIT("solaris")) && v->pref->os == v__pref__OS_solaris)) {
			array_push(&flags, _MOV((v__cflag__CFlag[]){ *flag }));
		}
		if ((Array_string_contains(ctimedefines, flag->os))) {
			array_push(&flags, _MOV((v__cflag__CFlag[]){ *flag }));
		}
	}
	// autofree_scope_vars(pos=918 line_nr=29 scope.pos=73 scope.end_pos=932)
	// var "v" var.pos=78 var.line_nr=6
	// var "flags" var.pos=126 var.line_nr=7
	// var "ctimedefines" var.pos=156 var.line_nr=8
	// af parent scope:
	// af parent scope:
	return flags;
}

VV_LOCAL_SYMBOL Array_v__cflag__CFlag v__builder__Builder_get_rest_of_module_cflags(v__builder__Builder* v, v__cflag__CFlag* c) {
	Array_v__cflag__CFlag flags = __new_array_with_default(0, 0, sizeof(v__cflag__CFlag), 0);
	Array_v__cflag__CFlag cflags = v__builder__Builder_get_os_cflags(v);
	// FOR IN array
	for (int _t3548 = 0; _t3548 < cflags.len; ++_t3548) {
		v__cflag__CFlag flag = ((v__cflag__CFlag*)cflags.data)[_t3548];
		if (string_eq(c->mod, flag.mod)) {
			if (string_eq(c->name, flag.name) && string_eq(c->value, flag.value) && string_eq(c->os, flag.os)) {
				continue;
			}
			array_push(&flags, _MOV((v__cflag__CFlag[]){ flag }));
		}
	}
	// autofree_scope_vars(pos=1232 line_nr=43 scope.pos=938 scope.end_pos=1246)
	// var "v" var.pos=943 var.line_nr=32
	// var "c" var.pos=980 var.line_nr=32
	// var "flags" var.pos=1017 var.line_nr=33
	// var "cflags" var.pos=1043 var.line_nr=34
	// af parent scope:
	// af parent scope:
	return flags;
}

VV_LOCAL_SYMBOL string v__builder__Builder_get_vtmp_filename(v__builder__Builder* b, string base_file_name, string postfix) {
	string vtmp = v__util__get_vtmp_folder();
	string uniq = _SLIT("");
	if (!b->pref->reuse_tmpc) {
		uniq = _STR(".%"PRIu64"", 1, rand__u64());
	}
	string fname = string_add(os__file_name(os__real_path(base_file_name)), _STR("%.*s\000%.*s", 2, uniq, postfix));
	 string _t3550 = os__real_path(os__join_path(vtmp, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){fname}))));
	// autofree_scope_vars(pos=505 line_nr=18 scope.pos=252 scope.end_pos=553)
	// var "b" var.pos=257 var.line_nr=11
	// var "base_file_name" var.pos=286 var.line_nr=11
	// var "postfix" var.pos=309 var.line_nr=11
	// var "vtmp" var.pos=335 var.line_nr=12
	// var "uniq" var.pos=371 var.line_nr=13
	// str literal
	// var "fname" var.pos=435 var.line_nr=17
	// af parent scope:
	// af parent scope:
	return _t3550;
}

void v__builder__compile(string command, v__pref__Preferences* pref) {
	string odir = os__dir(pref->out_name);
	string output_folder = odir;
	if (odir.len == pref->out_name.len) {
		output_folder = os__getwd();
	}
	Option_bool _t3551 = os__is_writable_folder(output_folder);
	if (_t3551.state != 0) { /*or block*/ 
		IError err = _t3551.err;
		v__builder__verror((*(err.msg)));
		v_exit(1);
	};
	v__builder__Builder b = v__builder__new_builder(pref);
	if (pref->is_verbose) {
		println(_SLIT("builder.compile() pref:"));
	}
	time__StopWatch sw = time__new_stopwatch((time__StopWatchOptions){.auto_start = true,});

	if (pref->backend == (v__pref__Backend_c)) {
		v__builder__Builder_compile_c(&b);
	}
	else if (pref->backend == (v__pref__Backend_js)) {
		v__builder__Builder_compile_js(&b);
	}
	else if (pref->backend == (v__pref__Backend_x64)) {
		v__builder__Builder_compile_x64(&b);
	};
	if (pref->is_stats) {
		i64 compilation_time_micros = 1 + time__Duration_microseconds(time__StopWatch_elapsed(sw));
		string scompilation_time_ms = v__util__bold(_STR("%6.3f", 1, ((f64)(compilation_time_micros)) / 1000.0));
		int all_v_source_lines = 0;
		int all_v_source_bytes = 0;
		// FOR IN array
		for (int _t3552 = 0; _t3552 < b.parsed_files.len; ++_t3552) {
			v__ast__File* pf = ((v__ast__File*)b.parsed_files.data) + _t3552;
			all_v_source_lines += pf->lines;
			all_v_source_bytes += pf->bytes;
		}
		string sall_v_source_lines = int_str(all_v_source_lines);
		string sall_v_source_bytes = int_str(all_v_source_bytes);
		sall_v_source_lines = v__util__bold(_STR("%*.*s", 1, sall_v_source_lines, 10));
		sall_v_source_bytes = v__util__bold(_STR("%*.*s", 1, sall_v_source_bytes, 10));
		println(_STR("        V  source  code size: %.*s\000 lines, %.*s\000 bytes", 3, sall_v_source_lines, sall_v_source_bytes));
		string slines = int_str(b.stats_lines);
		string sbytes = int_str(b.stats_bytes);
		slines = v__util__bold(_STR("%*.*s", 1, slines, 10));
		sbytes = v__util__bold(_STR("%*.*s", 1, sbytes, 10));
		println(_STR("generated  target  code size: %.*s\000 lines, %.*s\000 bytes", 3, slines, sbytes));
		int vlines_per_second = ((int)(1000000.0 * ((f64)(all_v_source_lines)) / ((f64)(compilation_time_micros))));
		string svlines_per_second = v__util__bold(int_str(vlines_per_second));
		println(_STR("compilation took: %.*s\000 ms, compilation speed: %.*s\000 vlines/s", 3, scompilation_time_ms, svlines_per_second));
	}
	v__builder__Builder_exit_on_invalid_syntax(&b);
	v__builder__Builder_myfree(&b);
	if (pref->is_test || pref->is_run) {
		v__builder__Builder_run_compiled_executable_and_exit(&b);
	}
}

// Attr: [unsafe]
VV_LOCAL_SYMBOL void v__builder__Builder_myfree(v__builder__Builder* b) {
	array_free(&b->parsed_files);
}

VV_LOCAL_SYMBOL void v__builder__Builder_exit_on_invalid_syntax(v__builder__Builder* b) {
	if (b->pref->only_check_syntax) {
		// FOR IN array
		for (int _t3553 = 0; _t3553 < b->parsed_files.len; ++_t3553) {
			v__ast__File pf = ((v__ast__File*)b->parsed_files.data)[_t3553];
			if (pf.errors.len > 0) {
				v_exit(1);
			}
		}
		if (b->checker.nr_errors > 0) {
			v_exit(1);
		}
	}
}

VV_LOCAL_SYMBOL void v__builder__Builder_run_compiled_executable_and_exit(v__builder__Builder* b) {
	if (b->pref->skip_running) {
		return;
	}
	if (b->pref->only_check_syntax) {
		return;
	}
	if (b->pref->os == v__pref__OS_ios) {
		v_panic(_SLIT("Running iOS apps is not supported yet."));
	}
	if (b->pref->is_verbose) {
		println(_STR("============ running %.*s\000 ============", 2, b->pref->out_name));
	}
	string exefile = os__real_path(b->pref->out_name);
	string cmd = _STR("\"%.*s\000\"", 2, exefile);
	if (b->pref->backend == v__pref__Backend_js) {
		string jsfile = os__real_path(_STR("%.*s\000.js", 2, b->pref->out_name));
		cmd = _STR("node \"%.*s\000\"", 2, jsfile);
	}
	// FOR IN array
	for (int _t3554 = 0; _t3554 < b->pref->run_args.len; ++_t3554) {
		string arg = ((string*)b->pref->run_args.data)[_t3554];
		if (string_index_byte(arg, L' ') > 0) {
			cmd = /*f*/string_add(cmd, string_add(string_add(_SLIT(" \""), arg), _SLIT("\"")));
		} else {
			cmd = /*f*/string_add(cmd, string_add(_SLIT(" "), arg));
		}
	}
	if (b->pref->is_verbose) {
		println(_STR("command to run executable: %.*s", 1, cmd));
	}
	if (b->pref->is_test || b->pref->is_run) {
		int ret = os__system(cmd);
		v__builder__Builder_cleanup_run_executable_after_exit(b, exefile);
		v_exit(ret);
	}
	v_exit(0);
}

VV_LOCAL_SYMBOL void v__builder__Builder_cleanup_run_executable_after_exit(v__builder__Builder* v, string exefile) {
	if (v->pref->reuse_tmpc) {
		v__pref__Preferences_vrun_elog(v->pref, _STR("keeping executable: %.*s\000 , because -keepc was passed", 2, exefile));
		return;
	}
	if (os__is_executable(exefile)) {
		v__pref__Preferences_vrun_elog(v->pref, _STR("remove run executable: %.*s", 1, exefile));
		Option_void _t3555 = os__rm(exefile);
		if (_t3555.state != 0 && _t3555.err._typ != _IError_None___index) {
			IError err = _t3555.err;
			v_panic(IError_str(err));
		};
	}
}

VV_LOCAL_SYMBOL void v__builder__Builder_set_module_lookup_paths(v__builder__Builder* v) {
	v->module_search_paths = __new_array_with_default(0, 0, sizeof(string), 0);
	if (v->pref->is_test) {
		array_push(&v->module_search_paths, _MOV((string[]){ string_clone(os__dir(v->compiled_dir)) }));
	}
	array_push(&v->module_search_paths, _MOV((string[]){ string_clone(v->compiled_dir) }));
	string x = os__join_path(v->compiled_dir, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("modules")})));
	if (v->pref->is_verbose) {
		println(_STR("x: \"%.*s\000\"", 2, x));
	}
	array_push(&v->module_search_paths, _MOV((string[]){ string_clone(os__join_path(v->compiled_dir, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("modules")})))) }));
	_PUSH_MANY(&v->module_search_paths, (v->pref->lookup_path), _t3559, Array_string);
	if (v->pref->is_verbose) {
		v__builder__Builder_log(v, _SLIT("v.module_search_paths:"));
		println(Array_string_str(v->module_search_paths));
	}
}

Array_string v__builder__Builder_get_builtin_files(v__builder__Builder* v) {
	v__builder__Builder_log(v, _STR("v.pref.lookup_path: %.*s", 1, Array_string_str(v->pref->lookup_path)));
	// FOR IN array
	for (int _t3560 = 0; _t3560 < v->pref->lookup_path.len; ++_t3560) {
		string location = ((string*)v->pref->lookup_path.data)[_t3560];
		if (os__exists(os__join_path(location, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("builtin")}))))) {
			Array_string builtin_files = __new_array_with_default(0, 0, sizeof(string), 0);
			if (v->pref->backend == v__pref__Backend_js) {
				_PUSH_MANY(&builtin_files, (v__builder__Builder_v_files_from_dir(v, os__join_path(location, new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT("builtin"), _SLIT("js")}))))), _t3561, Array_string);
			} else {
				_PUSH_MANY(&builtin_files, (v__builder__Builder_v_files_from_dir(v, os__join_path(location, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("builtin")}))))), _t3562, Array_string);
			}
			if (v->pref->is_bare) {
				_PUSH_MANY(&builtin_files, (v__builder__Builder_v_files_from_dir(v, v->pref->bare_builtin_dir)), _t3563, Array_string);
			}
			if (v->pref->backend == v__pref__Backend_c) {
				if (v->pref->is_vsh && os__exists(os__join_path(location, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("os")}))))) {
					_PUSH_MANY(&builtin_files, (v__builder__Builder_v_files_from_dir(v, os__join_path(location, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("os")}))))), _t3564, Array_string);
				}
			}
			// autofree_scope_vars(pos=6927 line_nr=215 scope.pos=6353 scope.end_pos=6951)
			// var "builtin_files" var.pos=6362 var.line_nr=199
			// af parent scope:
			// var "location" var.pos=6270 var.line_nr=197
			// skipping tmp var "location"
			// af parent scope:
			// var "v" var.pos=5650 var.line_nr=183
			// af parent scope:
			// af parent scope:
			return builtin_files;
		}
	}
	v__builder__verror(_SLIT("`builtin/` not included on module lookup path.\nDid you forget to add vlib to the path? (Use @vlib for default vlib)"));
	v_panic(_SLIT("Unreachable code reached."));
	return __new_array(0, 1, sizeof(string));
}

Array_string v__builder__Builder_get_user_files(v__builder__Builder* v) {
	if ((string_eq(v->pref->path, _SLIT("vlib/builtin")) || string_eq(v->pref->path, _SLIT("vlib/strconv")) || string_eq(v->pref->path, _SLIT("vlib/strings")) || string_eq(v->pref->path, _SLIT("vlib/hash")))) {
		v__builder__Builder_log(v, _SLIT("Skipping user files."));
		 Array_string _t3565 = __new_array_with_default(0, 0, sizeof(string), 0);
		// autofree_scope_vars(pos=7542 line_nr=230 scope.pos=7291 scope.end_pos=7554)
		// af parent scope:
		// var "v" var.pos=7170 var.line_nr=224
		// var "dir" var.pos=7561 var.line_nr=232
		// var "user_files" var.pos=7749 var.line_nr=236
		// var "vroot" var.pos=7850 var.line_nr=238
		// var "preludes_path" var.pos=7885 var.line_nr=239
		// var "is_test" var.pos=8521 var.line_nr=258
		// var "is_internal_module_test" var.pos=8552 var.line_nr=259
		// var "does_exist" var.pos=9381 var.line_nr=289
		// var "is_real_file" var.pos=9473 var.line_nr=294
		// var "resolved_link" var.pos=9520 var.line_nr=295
		// af parent scope:
		// af parent scope:
		return _t3565;
	}
	string dir = v->pref->path;
	v__builder__Builder_log(v, _STR("get_v_files(%.*s\000)", 2, dir));
	Array_string user_files = __new_array_with_default(0, 0, sizeof(string), 0);
	string vroot = os__dir(v__pref__vexe_path());
	string preludes_path = os__join_path(vroot, new_array_from_c_array(3, 3, sizeof(string), _MOV((string[3]){_SLIT("vlib"), _SLIT("v"), _SLIT("preludes")})));
	if (v->pref->is_livemain || v->pref->is_liveshared) {
		array_push(&user_files, _MOV((string[]){ string_clone(os__join_path(preludes_path, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("live.v")})))) }));
	}
	if (v->pref->is_livemain) {
		array_push(&user_files, _MOV((string[]){ string_clone(os__join_path(preludes_path, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("live_main.v")})))) }));
	}
	if (v->pref->is_liveshared) {
		array_push(&user_files, _MOV((string[]){ string_clone(os__join_path(preludes_path, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("live_shared.v")})))) }));
	}
	if (v->pref->is_test) {
		array_push(&user_files, _MOV((string[]){ string_clone(os__join_path(preludes_path, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("tests_assertions.v")})))) }));
	}
	if (v->pref->is_test && v->pref->is_stats) {
		array_push(&user_files, _MOV((string[]){ string_clone(os__join_path(preludes_path, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("tests_with_stats.v")})))) }));
	}
	if (v->pref->is_prof) {
		array_push(&user_files, _MOV((string[]){ string_clone(os__join_path(preludes_path, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("profiled_program.v")})))) }));
	}
	bool is_test = v->pref->is_test;
	bool is_internal_module_test = false;
	if (is_test) {
		Option_string _t3572 = os__read_file(dir);
		if (_t3572.state != 0) { /*or block*/ 
			IError err = _t3572.err;
			v__builder__verror(_STR("%.*s\000 does not exist", 2, dir));
			v_exit(0);
		}
 		string tcontent =  *(string*)_t3572.data;
		Array_string slines = string_split_into_lines(string_trim_space(tcontent));
		// FOR IN array
		for (int _t3573 = 0; _t3573 < slines.len; ++_t3573) {
			string sline = ((string*)slines.data)[_t3573];
			string line = string_trim_space(sline);
			if (line.len > 2) {
				if (string_at(line, 0) == L'/' && string_at(line, 1) == L'/') {
					continue;
				}
				if (string_starts_with(line, _SLIT("module "))) {
					is_internal_module_test = true;
					break;
				}
			}
		}
	}
	if (is_internal_module_test) {
		string single_test_v_file = os__real_path(dir);
		if (v->pref->is_verbose) {
			v__builder__Builder_log(v, _STR("> Compiling an internal module _test.v file %.*s\000 .", 2, single_test_v_file));
			v__builder__Builder_log(v, _SLIT("> That brings in all other ordinary .v files in the same module too ."));
		}
		array_push(&user_files, _MOV((string[]){ string_clone(single_test_v_file) }));
		dir = os__dir(single_test_v_file);
	}
	bool does_exist = os__exists(dir);
	if (!does_exist) {
		v__builder__verror(_STR("%.*s\000 doesn't exist", 2, dir));
		v_exit(1);
	}
	bool is_real_file = does_exist && !os__is_dir(dir);
	string resolved_link = (is_real_file && os__is_link(dir) ? (os__real_path(dir)) : (dir));
	if (is_real_file && (string_ends_with(dir, _SLIT(".v")) || string_ends_with(resolved_link, _SLIT(".vsh")) || string_ends_with(dir, _SLIT(".vv")))) {
		string single_v_file = (string_ends_with(resolved_link, _SLIT(".vsh")) ? (resolved_link) : (dir));
		array_push(&user_files, _MOV((string[]){ string_clone(single_v_file) }));
		if (v->pref->is_verbose) {
			v__builder__Builder_log(v, _STR("> just compile one file: \"%.*s\000\"", 2, single_v_file));
		}
	} else if (os__is_dir(dir)) {
		if (v->pref->is_verbose) {
			v__builder__Builder_log(v, _STR("> add all .v files from directory \"%.*s\000\" ...", 2, dir));
		}
		_PUSH_MANY(&user_files, (v__builder__Builder_v_files_from_dir(v, dir)), _t3576, Array_string);
	} else {
		println(_SLIT("usage: `v file.v` or `v directory`"));
		string ext = os__file_ext(dir);
		println(_STR("unknown file extension `%.*s\000`", 2, ext));
		v_exit(1);
	}
	if (user_files.len == 0) {
		println(_SLIT("No input .v files"));
		v_exit(1);
	}
	if (v->pref->is_verbose) {
		v__builder__Builder_log(v, _STR("user_files: %.*s", 1, Array_string_str(user_files)));
	}
	// autofree_scope_vars(pos=10434 line_nr=323 scope.pos=7169 scope.end_pos=10453)
	// var "v" var.pos=7170 var.line_nr=224
	// var "dir" var.pos=7561 var.line_nr=232
	// var "user_files" var.pos=7749 var.line_nr=236
	// var "vroot" var.pos=7850 var.line_nr=238
	// var "preludes_path" var.pos=7885 var.line_nr=239
	// var "is_test" var.pos=8521 var.line_nr=258
	// var "is_internal_module_test" var.pos=8552 var.line_nr=259
	// var "does_exist" var.pos=9381 var.line_nr=289
	// var "is_real_file" var.pos=9473 var.line_nr=294
	// var "resolved_link" var.pos=9520 var.line_nr=295
	// af parent scope:
	// af parent scope:
	return user_files;
}

string v__builder__Builder_gen_js(v__builder__Builder* b, Array_string v_files) {
	v__util__timing_start(_SLIT("PARSE"));
	b->parsed_files = v__parser__parse_files(v_files, b->table, b->pref, b->global_scope);
	v__builder__Builder_parse_imports(b);
	v__util__Timers_show(v__util__get_timers(), _SLIT("SCAN"));
	v__util__Timers_show(v__util__get_timers(), _SLIT("PARSE"));
	v__util__Timers_show_if_exists(v__util__get_timers(), _SLIT("PARSE stmt"));
	v__util__timing_start(_SLIT("CHECK"));
	v__checker__Checker_check_files(&b->checker, b->parsed_files);
	v__util__timing_measure(_SLIT("CHECK"));
	if (b->pref->skip_unused) {
		v__markused__mark_used(b->table, b->pref, b->parsed_files);
	}
	v__builder__Builder_print_warnings_and_errors(b);
	v__util__timing_start(_SLIT("JS GEN"));
	string res = v__gen__js__gen(b->parsed_files, b->table, b->pref);
	v__util__timing_measure(_SLIT("JS GEN"));
	// autofree_scope_vars(pos=735 line_nr=29 scope.pos=112 scope.end_pos=747)
	// var "b" var.pos=117 var.line_nr=9
	// var "v_files" var.pos=135 var.line_nr=9
	// var "res" var.pos=657 var.line_nr=27
	// af parent scope:
	// af parent scope:
	return res;
}

void v__builder__Builder_build_js(v__builder__Builder* b, Array_string v_files, string out_file) {
	b->out_name_js = out_file;
	v__builder__Builder_info(b, _STR("build_js(%.*s\000)", 2, out_file));
	string output = v__builder__Builder_gen_js(b, v_files);
	Option_os__File _t3577 = os__create(out_file);
	if (_t3577.state != 0) { /*or block*/ 
		IError err = _t3577.err;
		v_panic(IError_str(err));
	}
 	os__File f =  *(os__File*)_t3577.data;
	Option_int _t3578 = os__File_writeln(&f, output);
	if (_t3578.state != 0) { /*or block*/ 
		IError err = _t3578.err;
		v_panic(IError_str(err));
	};
	if (b->pref->is_stats) {
		b->stats_lines = string_count(output, _SLIT("\n")) + 1;
		b->stats_bytes = output.len;
	}
	os__File_close(&f);
}

void v__builder__Builder_compile_js(v__builder__Builder* b) {
	Array_string files = v__builder__Builder_get_user_files(b);
	_PUSH_MANY(&files, (v__builder__Builder_get_builtin_files(b)), _t3579, Array_string);
	v__builder__Builder_set_module_lookup_paths(b);
	if (b->pref->is_verbose) {
		println(_SLIT("all .v files:"));
		println(Array_string_str(files));
	}
	string name = b->pref->out_name;
	if (!string_ends_with(name, _SLIT(".js"))) {
		name = /*f*/string_add(name, _SLIT(".js"));
	}
	v__builder__Builder_build_js(b, files, name);
}

VV_LOCAL_SYMBOL void v__builder__Builder_run_js(v__builder__Builder* b) {
	string cmd = string_add(string_add(_SLIT("node "), b->pref->out_name), _SLIT(".js"));
	os__Result res = os__execute(cmd);
	if (res.exit_code != 0) {
		eprintln(_SLIT("JS compilation failed:"));
		v__builder__verror(res.output);
		return;
	}
	println(res.output);
}

// TypeDecl
VV_LOCAL_SYMBOL Option_string v__builder__find_windows_kit_internal(v__builder__RegKey key, Array_string versions) {
	{ // Unsafe block
		// FOR IN array
		for (int _t3580 = 0; _t3580 < versions.len; ++_t3580) {
			string version = ((string*)versions.data)[_t3580];
			u32 required_bytes = ((u32)(0U));
			voidptr result = RegQueryValueEx(key, string_to_wide(version), 0, 0, 0, &required_bytes);
			u32 length = required_bytes / 2;
			if (result != 0) {
				continue;
			}
			u32 alloc_length = (required_bytes + 2);
			u16* value = ((u16*)(v_malloc(((int)(alloc_length)))));
			if (isnil(value)) {
				continue;
			} else {
			}
			voidptr result2 = RegQueryValueEx(key, string_to_wide(version), 0, 0, value, &alloc_length);
			if (result2 != 0) {
				continue;
			}
			if (value[length - 1] != ((u16)(0U))) {
				value[length] = ((u16)(0U));
			}
			string res = string_from_wide(value);
			Option_string _t3581;
			opt_ok(&(string[]) { res }, (Option*)(&_t3581), sizeof(string));
			// autofree_scope_vars(pos=1605 line_nr=65 scope.pos=894 scope.end_pos=1620)
			// var "version" var.pos=894 var.line_nr=40
			// skipping tmp var "version"
			// var "required_bytes" var.pos=920 var.line_nr=41
			// var "result" var.pos=961 var.line_nr=42
			// var "length" var.pos=1043 var.line_nr=43
			// var "alloc_length" var.pos=1117 var.line_nr=47
			// var "value" var.pos=1162 var.line_nr=48
			// var "result2" var.pos=1273 var.line_nr=55
			// var "res" var.pos=1571 var.line_nr=64
			// af parent scope:
			// af parent scope:
			// af parent scope:
			// var "key" var.pos=820 var.line_nr=37
			// var "versions" var.pos=832 var.line_nr=37
			// af parent scope:
			// af parent scope:
			return _t3581;
		}
	}
	return (Option_string){ .state=2, .err=v_error(_SLIT("windows kit not found")) };
}

VV_LOCAL_SYMBOL Option_v__builder__WindowsKit v__builder__find_windows_kit_root(string target_arch) {
	v__builder__RegKey root_key = ((v__builder__RegKey)(0));
	string path = _SLIT("SOFTWARE\\Microsoft\\Windows Kits\\Installed Roots");
	voidptr rc = RegOpenKeyEx(_const_v__builder__hkey_local_machine, string_to_wide(path), 0, ((_const_v__builder__key_query_value | _const_v__builder__key_wow64_32key) | _const_v__builder__key_enumerate_sub_keys), &root_key);
	if (rc != 0) {
		return (Option_v__builder__WindowsKit){ .state=2, .err=v_error(_SLIT("Unable to open root key")) };
	}
	Option_string _t3582 = v__builder__find_windows_kit_internal(root_key, new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT("KitsRoot10"), _SLIT("KitsRoot81")})));
	if (_t3582.state != 0) { /*or block*/ 
		IError err = _t3582.err;
		RegCloseKey(root_key);
		return (Option_v__builder__WindowsKit){ .state=2, .err=v_error(_SLIT("Unable to find a windows kit")) };
	}
 	string kit_root =  *(string*)_t3582.data;
	string kit_lib = string_add(kit_root, _SLIT("Lib"));
	Option_Array_string _t3583 = os__ls(kit_lib);
	if (_t3583.state != 0) { /*or block*/ 
		Option_v__builder__WindowsKit _t3584;
		memcpy(&_t3584, &_t3583, sizeof(Option));
		return _t3584;
	}
 	Array_string files =  *(Array_string*)_t3583.data;
	string highest_path = _SLIT("");
	int highest_int = 0;
	// FOR IN array
	for (int _t3585 = 0; _t3585 < files.len; ++_t3585) {
		string f = ((string*)files.data)[_t3585];
		string no_dot = string_replace(f, _SLIT("."), _SLIT(""));
		int v_int = string_int(no_dot);
		if (v_int > highest_int) {
			highest_int = v_int;
			highest_path = f;
		}
	}
	string kit_lib_highest = string_add(kit_lib, _STR("\\%.*s", 1, highest_path));
	string kit_include_highest = string_replace(kit_lib_highest, _SLIT("Lib"), _SLIT("Include"));
	RegCloseKey(root_key);
	Option_v__builder__WindowsKit _t3586;
	opt_ok(&(v__builder__WindowsKit[]) { (v__builder__WindowsKit){.um_lib_path = string_add(kit_lib_highest, _STR("\\um\\%.*s", 1, target_arch)),.ucrt_lib_path = string_add(kit_lib_highest, _STR("\\ucrt\\%.*s", 1, target_arch)),.um_include_path = string_add(kit_include_highest, _SLIT("\\um")),.ucrt_include_path = string_add(kit_include_highest, _SLIT("\\ucrt")),.shared_include_path = string_add(kit_include_highest, _SLIT("\\shared")),} }, (Option*)(&_t3586), sizeof(v__builder__WindowsKit));
	// autofree_scope_vars(pos=2961 line_nr=114 scope.pos=1962 scope.end_pos=3259)
	// var "root_key" var.pos=1966 var.line_nr=83
	// var "path" var.pos=1990 var.line_nr=84
	// str literal
	// var "rc" var.pos=2053 var.line_nr=85
	// var "kit_root" var.pos=2392 var.line_nr=95
	// var "kit_lib" var.pos=2556 var.line_nr=99
	// var "files" var.pos=2586 var.line_nr=100
	// var "highest_path" var.pos=2618 var.line_nr=101
	// str literal
	// var "highest_int" var.pos=2643 var.line_nr=102
	// var "kit_lib_highest" var.pos=2820 var.line_nr=111
	// var "kit_include_highest" var.pos=2869 var.line_nr=112
	// af parent scope:
	// var "target_arch" var.pos=1915 var.line_nr=81
	// af parent scope:
	// af parent scope:
	return _t3586;
	return (Option_v__builder__WindowsKit){ .state=2, .err=v_error(_SLIT("Host OS does not support finding a windows kit")) };
}

VV_LOCAL_SYMBOL Option_v__builder__VsInstallation v__builder__find_vs(string vswhere_dir, string host_arch, string target_arch) {
	os__Result res = os__execute(_STR("\"%.*s\000\\Microsoft Visual Studio\\Installer\\vswhere.exe\" -latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationPath", 2, vswhere_dir));
	if (res.exit_code != 0) {
		return (Option_v__builder__VsInstallation){ .state=2, .err=error_with_code(res.output, res.exit_code) };
	}
	string res_output = string_trim_right(res.output, _SLIT("\r\n"));
	Option_string _t3587 = os__read_file(_STR("%.*s\000\\VC\\Auxiliary\\Build\\Microsoft.VCToolsVersion.default.txt", 2, res_output));
	if (_t3587.state != 0) { /*or block*/ 
		IError err = _t3587.err;
		return (Option_v__builder__VsInstallation){ .state=2, .err=v_error(_SLIT("Unable to find vs installation")) };
	}
 	string version =  *(string*)_t3587.data;
	string version2 = version;
	string v = (string_ends_with(version, _SLIT("\n")) ? (string_substr(version2, 0, version.len - 2)) : (version2));
	string lib_path = _STR("%.*s\000\\VC\\Tools\\MSVC\\%.*s\000\\lib\\%.*s", 3, res.output, v, target_arch);
	string include_path = _STR("%.*s\000\\VC\\Tools\\MSVC\\%.*s\000\\include", 3, res.output, v);
	if (os__exists(_STR("%.*s\000\\vcruntime.lib", 2, lib_path))) {
		string p = _STR("%.*s\000\\VC\\Tools\\MSVC\\%.*s\000\\bin\\Host%.*s\000\\%.*s", 4, res.output, v, host_arch, target_arch);
		Option_v__builder__VsInstallation _t3588;
		opt_ok(&(v__builder__VsInstallation[]) { (v__builder__VsInstallation){.include_path = include_path,.lib_path = lib_path,.exe_path = p,} }, (Option*)(&_t3588), sizeof(v__builder__VsInstallation));
		// autofree_scope_vars(pos=4780 line_nr=157 scope.pos=4660 scope.end_pos=4876)
		// var "p" var.pos=4664 var.line_nr=155
		// af parent scope:
		// var "vswhere_dir" var.pos=3429 var.line_nr=131
		// var "host_arch" var.pos=3449 var.line_nr=131
		// var "target_arch" var.pos=3467 var.line_nr=131
		// var "res" var.pos=3768 var.line_nr=139
		// var "res_output" var.pos=4041 var.line_nr=143
		// var "version" var.pos=4113 var.line_nr=145
		// var "version2" var.pos=4314 var.line_nr=149
		// var "v" var.pos=4408 var.line_nr=151
		// var "lib_path" var.pos=4491 var.line_nr=152
		// var "include_path" var.pos=4558 var.line_nr=153
		// af parent scope:
		// af parent scope:
		return _t3588;
	}
	println(_STR("Unable to find vs installation (attempted to use lib path \"%.*s\000\")", 2, lib_path));
	return (Option_v__builder__VsInstallation){ .state=2, .err=v_error(_SLIT("Unable to find vs exe folder")) };
}

VV_LOCAL_SYMBOL Option_v__builder__MsvcResult v__builder__find_msvc(bool m64_target) {
	#if defined(_WIN32)
	{
		string processor_architecture = os__getenv(_SLIT("PROCESSOR_ARCHITECTURE"));
		string vswhere_dir = (string_eq(processor_architecture, _SLIT("x86")) ? (_SLIT("%ProgramFiles%")) : (_SLIT("%ProgramFiles(x86)%")));
		string host_arch = (string_eq(processor_architecture, _SLIT("x86")) ? (_SLIT("X86")) : (_SLIT("X64")));
		string target_arch = _SLIT("X64");
		if (string_eq(host_arch, _SLIT("X86"))) {
			if (!m64_target) {
				target_arch = _SLIT("X86");
			}
		} else if (string_eq(host_arch, _SLIT("X64"))) {
			if (!m64_target) {
				target_arch = _SLIT("X86");
			}
		}
		Option_v__builder__WindowsKit _t3589 = v__builder__find_windows_kit_root(target_arch);
		if (_t3589.state != 0) { /*or block*/ 
			IError err = _t3589.err;
			return (Option_v__builder__MsvcResult){ .state=2, .err=v_error(_SLIT("Unable to find windows sdk")) };
		}
 		v__builder__WindowsKit wk =  *(v__builder__WindowsKit*)_t3589.data;
		Option_v__builder__VsInstallation _t3590 = v__builder__find_vs(vswhere_dir, host_arch, target_arch);
		if (_t3590.state != 0) { /*or block*/ 
			IError err = _t3590.err;
			return (Option_v__builder__MsvcResult){ .state=2, .err=v_error(_SLIT("Unable to find visual studio")) };
		}
 		v__builder__VsInstallation vs =  *(v__builder__VsInstallation*)_t3590.data;
		Option_v__builder__MsvcResult _t3591;
		opt_ok(&(v__builder__MsvcResult[]) { (v__builder__MsvcResult){
			.full_cl_exe_path = os__real_path(string_add(string_add(vs.exe_path, _const_os__path_separator), _SLIT("cl.exe"))),
			.exe_path = vs.exe_path,
			.um_lib_path = wk.um_lib_path,
			.ucrt_lib_path = wk.ucrt_lib_path,
			.vs_lib_path = vs.lib_path,
			.um_include_path = wk.um_include_path,
			.ucrt_include_path = wk.ucrt_include_path,
			.vs_include_path = vs.include_path,
			.shared_include_path = wk.shared_include_path,
			.valid = true,
		} }, (Option*)(&_t3591), sizeof(v__builder__MsvcResult));
		// autofree_scope_vars(pos=5714 line_nr=190 scope.pos=5067 scope.end_pos=6116)
		// var "processor_architecture" var.pos=5071 var.line_nr=169
		// var "vswhere_dir" var.pos=5135 var.line_nr=170
		// var "host_arch" var.pos=5249 var.line_nr=175
		// var "target_arch" var.pos=5328 var.line_nr=176
		// str literal
		// var "wk" var.pos=5512 var.line_nr=186
		// var "vs" var.pos=5605 var.line_nr=187
		// af parent scope:
		// var "m64_target" var.pos=5023 var.line_nr=167
		// af parent scope:
		// af parent scope:
		return _t3591;
	}
	#else
	{
	}
	#endif
	return (Option_v__builder__MsvcResult){0};
}

void v__builder__Builder_cc_msvc(v__builder__Builder* v) {
	v__builder__MsvcResult r = v->cached_msvc;
	if (r.valid == false) {
		v__builder__verror(_SLIT("Cannot find MSVC on this OS"));
		return;
	}
	string out_name_obj = os__real_path(string_add(v->out_name_c, _SLIT(".obj")));
	string out_name_pdb = os__real_path(string_add(v->out_name_c, _SLIT(".pdb")));
	string out_name_cmd_line = os__real_path(string_add(v->out_name_c, _SLIT(".rsp")));
	Array_string a = new_array_from_c_array(4, 4, sizeof(string), _MOV((string[4]){_SLIT("-w"), _SLIT("/we4013"), _SLIT("/volatile:ms"), _STR("/Fo\"%.*s\000\"", 2, out_name_obj)}));
	if (v->pref->is_prod) {
		array_push(&a, _MOV((string[]){ string_clone(_SLIT("/O2")) }));
		array_push(&a, _MOV((string[]){ string_clone(_SLIT("/MD")) }));
		array_push(&a, _MOV((string[]){ string_clone(_SLIT("/DNDEBUG")) }));
	} else {
		array_push(&a, _MOV((string[]){ string_clone(_SLIT("/MDd")) }));
		array_push(&a, _MOV((string[]){ string_clone(_SLIT("/D_DEBUG")) }));
	}
	if (v->pref->is_debug) {
		_PUSH_MANY(&a, (new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT("/Zi"), _STR("/Fd\"%.*s\000\"", 2, out_name_pdb)}))), _t3597, Array_string);
	}
	if (v->pref->is_shared) {
		if (!string_ends_with(v->pref->out_name, _SLIT(".dll"))) {
			v->pref->out_name = /*f*/string_add(v->pref->out_name, _SLIT(".dll"));
		}
		array_push(&a, _MOV((string[]){ string_clone(_SLIT("/LD")) }));
	} else if (!string_ends_with(v->pref->out_name, _SLIT(".exe"))) {
		v->pref->out_name = /*f*/string_add(v->pref->out_name, _SLIT(".exe"));
	}
	v->pref->out_name = os__real_path(v->pref->out_name);
	if (v->pref->build_mode == v__pref__BuildMode_build_module) {
		array_push(&a, _MOV((string[]){ string_clone(_SLIT("/c")) }));
	} else if (v->pref->build_mode == v__pref__BuildMode_default_mode) {
	}
	if (v->pref->sanitize) {
		println(_SLIT("Sanitize not supported on msvc."));
	}
	array_push(&a, _MOV((string[]){ string_clone(string_add(string_add(_SLIT("\""), os__real_path(v->out_name_c)), _SLIT("\""))) }));
	Array_string real_libs = new_array_from_c_array(3, 3, sizeof(string), _MOV((string[3]){_SLIT("kernel32.lib"), _SLIT("user32.lib"), _SLIT("advapi32.lib")}));
	v__builder__MsvcStringFlags sflags = v__builder__msvc_string_flags(v__builder__Builder_get_os_cflags(v));
	_PUSH_MANY(&real_libs, (sflags.real_libs), _t3601, Array_string);
	Array_string inc_paths = sflags.inc_paths;
	Array_string lib_paths = sflags.lib_paths;
	Array_string defines = sflags.defines;
	Array_string other_flags = sflags.other_flags;
	array_push(&a, _MOV((string[]){ string_clone(_STR("-I \"%.*s\000\"", 2, r.ucrt_include_path)) }));
	array_push(&a, _MOV((string[]){ string_clone(_STR("-I \"%.*s\000\"", 2, r.vs_include_path)) }));
	array_push(&a, _MOV((string[]){ string_clone(_STR("-I \"%.*s\000\"", 2, r.um_include_path)) }));
	array_push(&a, _MOV((string[]){ string_clone(_STR("-I \"%.*s\000\"", 2, r.shared_include_path)) }));
	_PUSH_MANY(&a, (defines), _t3606, Array_string);
	_PUSH_MANY(&a, (inc_paths), _t3607, Array_string);
	_PUSH_MANY(&a, (other_flags), _t3608, Array_string);
	array_push(&a, _MOV((string[]){ string_clone(Array_string_join(real_libs, _SLIT(" "))) }));
	array_push(&a, _MOV((string[]){ string_clone(_SLIT("/link")) }));
	array_push(&a, _MOV((string[]){ string_clone(_SLIT("/NOLOGO")) }));
	array_push(&a, _MOV((string[]){ string_clone(_STR("/OUT:\"%.*s\000\"", 2, v->pref->out_name)) }));
	array_push(&a, _MOV((string[]){ string_clone(_STR("/LIBPATH:\"%.*s\000\"", 2, r.ucrt_lib_path)) }));
	array_push(&a, _MOV((string[]){ string_clone(_STR("/LIBPATH:\"%.*s\000\"", 2, r.um_lib_path)) }));
	array_push(&a, _MOV((string[]){ string_clone(_STR("/LIBPATH:\"%.*s\000\"", 2, r.vs_lib_path)) }));
	array_push(&a, _MOV((string[]){ string_clone(_SLIT("/DEBUG:FULL")) }));
	if (v->pref->is_prod) {
		array_push(&a, _MOV((string[]){ string_clone(_SLIT("/INCREMENTAL:NO")) }));
		array_push(&a, _MOV((string[]){ string_clone(_SLIT("/OPT:REF")) }));
		array_push(&a, _MOV((string[]){ string_clone(_SLIT("/OPT:ICF")) }));
	}
	_PUSH_MANY(&a, (lib_paths), _t3620, Array_string);
	string args = Array_string_join(a, _SLIT(" "));
	Option_void _t3621 = os__write_file(out_name_cmd_line, args);
	if (_t3621.state != 0 && _t3621.err._typ != _IError_None___index) {
		IError err = _t3621.err;
		v__builder__verror(_STR("Unable to write response file to \"%.*s\000\"", 2, out_name_cmd_line));
	};
	string cmd = _STR("\"%.*s\000\" \"@%.*s\000\"", 3, r.full_cl_exe_path, out_name_cmd_line);
	v__builder__Builder_show_cc(v, cmd, out_name_cmd_line, args);
	v__util__timing_start(_SLIT("C msvc"));
	os__Result res = os__execute(cmd);
	if (res.exit_code != 0) {
		eprintln(res.output);
		v__builder__verror(_SLIT("msvc error"));
		return;
	}
	v__util__timing_measure(_SLIT("C msvc"));
	if (v->pref->show_c_output) {
		v__builder__Builder_show_c_compiler_output(v, res);
	} else {
		v__builder__Builder_post_process_c_compiler_output(v, res);
	}
	Option_void _t3622 = os__rm(out_name_obj);
	if (_t3622.state != 0 && _t3622.err._typ != _IError_None___index) {
		IError err = _t3622.err;
		v_panic(IError_str(err));
	};
}

VV_LOCAL_SYMBOL void v__builder__Builder_build_thirdparty_obj_file_with_msvc(v__builder__Builder* v, string path, Array_v__cflag__CFlag moduleflags) {
	v__builder__MsvcResult msvc = v->cached_msvc;
	if (msvc.valid == false) {
		v__builder__verror(_SLIT("Cannot find MSVC on this OS"));
		return;
	}
	string obj_path = _STR("%.*s\000bj", 2, path);
	obj_path = os__real_path(obj_path);
	if (os__exists(obj_path)) {
		return;
	}
	println(_STR("%.*s\000 not found, building it (with msvc)...", 2, obj_path));
	string cfiles = _STR("%.*s\000.c", 2, string_substr(path, 0, path.len - 2));
	v__builder__MsvcStringFlags flags = v__builder__msvc_string_flags(moduleflags);
	string inc_dirs = Array_string_join(flags.inc_paths, _SLIT(" "));
	string defines = Array_string_join(flags.defines, _SLIT(" "));
	string include_string = _STR("-I \"%.*s\000\" -I \"%.*s\000\" -I \"%.*s\000\" -I \"%.*s\000\" %.*s", 5, msvc.ucrt_include_path, msvc.vs_include_path, msvc.um_include_path, msvc.shared_include_path, inc_dirs);
	Array_string oargs = __new_array_with_default(0, 0, sizeof(string), 0);
	if (v->pref->is_prod) {
		array_push(&oargs, _MOV((string[]){ string_clone(_SLIT("/O2")) }));
		array_push(&oargs, _MOV((string[]){ string_clone(_SLIT("/MD")) }));
		array_push(&oargs, _MOV((string[]){ string_clone(_SLIT("/DNDEBUG")) }));
	} else {
		array_push(&oargs, _MOV((string[]){ string_clone(_SLIT("/MDd")) }));
		array_push(&oargs, _MOV((string[]){ string_clone(_SLIT("/D_DEBUG")) }));
	}
	string str_oargs = Array_string_join(oargs, _SLIT(" "));
	string cmd = _STR("\"%.*s\000\" /volatile:ms %.*s\000 %.*s\000 %.*s\000 /c %.*s\000 /Fo\"%.*s\000\"", 7, msvc.full_cl_exe_path, str_oargs, defines, include_string, cfiles, obj_path);
	os__Result res = os__execute(cmd);
	if (res.exit_code != 0) {
		println(_STR("msvc: failed to build a thirdparty object; cmd: %.*s", 1, cmd));
		v__builder__verror(res.output);
		return;
	}
	println(res.output);
}

v__builder__MsvcStringFlags v__builder__msvc_string_flags(Array_v__cflag__CFlag cflags) {
	Array_string real_libs = __new_array_with_default(0, 0, sizeof(string), 0);
	Array_string inc_paths = __new_array_with_default(0, 0, sizeof(string), 0);
	Array_string lib_paths = __new_array_with_default(0, 0, sizeof(string), 0);
	Array_string defines = __new_array_with_default(0, 0, sizeof(string), 0);
	Array_string other_flags = __new_array_with_default(0, 0, sizeof(string), 0);
	// FOR IN array
	for (int _t3628 = 0; _t3628 < cflags.len; ++_t3628) {
		v__cflag__CFlag flag = ((v__cflag__CFlag*)cflags.data)[_t3628];
		if (string_eq(flag.name, _SLIT("-l"))) {
			if (string_ends_with(flag.value, _SLIT(".dll"))) {
				v__builder__verror(_STR("MSVC cannot link against a dll (`#flag -l %.*s\000`)", 2, flag.value));
			}
			string lib_lib = string_add(flag.value, _SLIT(".lib"));
			array_push(&real_libs, _MOV((string[]){ string_clone(lib_lib) }));
		} else if (string_eq(flag.name, _SLIT("-I"))) {
			array_push(&inc_paths, _MOV((string[]){ string_clone(v__cflag__CFlag_format(&flag)) }));
		} else if (string_eq(flag.name, _SLIT("-L"))) {
			array_push(&lib_paths, _MOV((string[]){ string_clone(flag.value) }));
			array_push(&lib_paths, _MOV((string[]){ string_clone(string_add(string_add(flag.value, _const_os__path_separator), _SLIT("msvc"))) }));
		} else if (string_ends_with(flag.value, _SLIT(".o"))) {
			array_push(&other_flags, _MOV((string[]){ string_clone(_STR("\"%.*s\000bj\"", 2, flag.value)) }));
		} else if (string_starts_with(flag.value, _SLIT("-D"))) {
			array_push(&defines, _MOV((string[]){ string_clone(_STR("/D%.*s", 1, string_substr(flag.value, 2, flag.value.len))) }));
		} else {
			array_push(&other_flags, _MOV((string[]){ string_clone(flag.value) }));
		}
	}
	Array_string lpaths = __new_array_with_default(0, 0, sizeof(string), 0);
	// FOR IN array
	for (int _t3636 = 0; _t3636 < lib_paths.len; ++_t3636) {
		string l = ((string*)lib_paths.data)[_t3636];
		array_push(&lpaths, _MOV((string[]){ string_clone(string_add(string_add(_SLIT("/LIBPATH:\""), os__real_path(l)), _SLIT("\""))) }));
	}
	 v__builder__MsvcStringFlags _t3638 = (v__builder__MsvcStringFlags){.real_libs = real_libs,.inc_paths = inc_paths,.lib_paths = lpaths,.defines = defines,.other_flags = other_flags,};
	// autofree_scope_vars(pos=13341 line_nr=434 scope.pos=11743 scope.end_pos=13481)
	// var "cflags" var.pos=11761 var.line_nr=392
	// var "real_libs" var.pos=11806 var.line_nr=393
	// var "inc_paths" var.pos=11835 var.line_nr=394
	// var "lib_paths" var.pos=11864 var.line_nr=395
	// var "defines" var.pos=11893 var.line_nr=396
	// var "other_flags" var.pos=11920 var.line_nr=397
	// var "lpaths" var.pos=13246 var.line_nr=430
	// af parent scope:
	// af parent scope:
	return _t3638;
}

void v__builder__Builder_build_x64(v__builder__Builder* b, Array_string v_files, string out_file) {
	#if !defined(__linux__)
	{
		println(_SLIT("v -x64 can only generate Linux binaries for now"));
		println(string_add(_SLIT("You are not on a Linux system, so you will not "), _SLIT("be able to run the resulting executable")));
	}
	#endif
	v__util__timing_start(_SLIT("PARSE"));
	b->parsed_files = v__parser__parse_files(v_files, b->table, b->pref, b->global_scope);
	v__builder__Builder_parse_imports(b);
	v__util__Timers_show(v__util__get_timers(), _SLIT("SCAN"));
	v__util__Timers_show(v__util__get_timers(), _SLIT("PARSE"));
	v__util__Timers_show_if_exists(v__util__get_timers(), _SLIT("PARSE stmt"));
	v__util__timing_start(_SLIT("CHECK"));
	v__checker__Checker_check_files(&b->checker, b->parsed_files);
	v__util__timing_measure(_SLIT("CHECK"));
	if (b->pref->skip_unused) {
		v__markused__mark_used(b->table, b->pref, b->parsed_files);
	}
	v__util__timing_start(_SLIT("x64 GEN"));
	multi_return_int_int mr_842 = v__gen__x64__gen(b->parsed_files, b->table, out_file, b->pref);
	b->stats_lines = mr_842.arg0;
	b->stats_bytes = mr_842.arg1;
	v__util__timing_measure(_SLIT("x64 GEN"));
}

void v__builder__Builder_compile_x64(v__builder__Builder* b) {
	Array_string files = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){b->pref->path}));
	v__builder__Builder_set_module_lookup_paths(b);
	v__builder__Builder_build_x64(b, files, b->pref->out_name);
}

VV_LOCAL_SYMBOL void main__main(void) {
bool main__main_defer_0 = false;
	bool timers_should_print = false;
	v__util__Timers* timers = v__util__new_timers(timers_should_print);
	v__util__Timers_start(timers, _SLIT("v total"));
	main__main_defer_0 = true;
	v__util__Timers_start(timers, _SLIT("v start"));
	v__util__Timers_show(timers, _SLIT("v start"));
	Array_string args = array_slice(_const_os__args, 1, _const_os__args.len);
	if (args.len == 0 || (string_eq((*(string*)/*ee elem_typ */array_get(args, 0)), _SLIT("-")) || string_eq((*(string*)/*ee elem_typ */array_get(args, 0)), _SLIT("repl")))) {
		if (args.len == 0) {
			if (is_atty(0) != 0) {
				println(_SLIT("Welcome to the V REPL (for help with V itself, type `exit`, then run `v help`)."));
			} else {
				Array_string args_and_flags = array_clone_static(array_slice(v__util__join_env_vflags_and_os_args(), 1, v__util__join_env_vflags_and_os_args().len));
				_PUSH_MANY(&args_and_flags, (new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT("run"), _SLIT("-")}))), _t3639, Array_string);
				v__pref__parse_args(_const_main__external_tools, args_and_flags);
			}
		}
		v__util__launch_tool(false, _SLIT("vrepl"), array_slice(_const_os__args, 1, _const_os__args.len));
		// Defer begin
		if (main__main_defer_0 == true) {
			v__util__Timers_show(timers, _SLIT("v total"));
		}
		// Defer end
		return;
	}
	Array_string args_and_flags = array_slice(v__util__join_env_vflags_and_os_args(), 1, v__util__join_env_vflags_and_os_args().len);
	multi_return_v__pref__Preferences_string mr_1775 = v__pref__parse_args(_const_main__external_tools, args_and_flags);
	v__pref__Preferences* prefs = mr_1775.arg0;
	string command = mr_1775.arg1;
	if (prefs->is_watch) {
		Array_string _t3640_orig = array_slice(_const_os__args, 1, _const_os__args.len);
		int _t3640_len = _t3640_orig.len;
		Array_string _t3640 = __new_array(0, _t3640_len, sizeof(string));

		for (int _t3641 = 0; _t3641 < _t3640_len; ++_t3641) {
			string it = ((string*) _t3640_orig.data)[_t3641];
			if (string_ne(it, _SLIT("-watch"))) {
				array_push(&_t3640, &it); 
		}
		}
		
		v__util__launch_tool(prefs->is_verbose, _SLIT("vwatch"), _t3640);
	}
	if (prefs->is_verbose) {
	}
	if (prefs->use_cache && string_eq(os__user_os(), _SLIT("windows"))) {
		eprintln(_SLIT("-usecache is currently disabled on windows"));
		v_exit(1);
	}
	if ((string_eq(command, _SLIT("test-fixed")) || string_eq(command, _SLIT("test-compiler-full")))) {
		eprintln(_SLIT("Please use `v test-self` instead."));
		v_exit(1);
	}
	if (string_eq(command, _SLIT("test-compiler"))) {
		eprintln(_SLIT("Please use either `v test-all`, `v test-self`, `v build-examples`, `v build-tools` or `v build-vbinaries` instead."));
		v_exit(1);
	}
	if (string_eq(command, _SLIT("test-vet"))) {
		eprintln(_SLIT("Please use `v test-cleancode` instead."));
		v_exit(1);
	}
	if ((Array_string_contains(_const_main__external_tools, command))) {
		v__util__launch_tool(prefs->is_verbose, string_add(_SLIT("v"), command), array_slice(_const_os__args, 1, _const_os__args.len));
		// Defer begin
		if (main__main_defer_0 == true) {
			v__util__Timers_show(timers, _SLIT("v total"));
		}
		// Defer end
		return;
	}

	if (string_eq(command, _SLIT("help"))) {
		main__invoke_help_and_exit(args);
	}
	else if (string_eq(command, _SLIT("new")) || string_eq(command, _SLIT("init"))) {
		v__util__launch_tool(prefs->is_verbose, _SLIT("vcreate"), array_slice(_const_os__args, 1, _const_os__args.len));
		// Defer begin
		if (main__main_defer_0 == true) {
			v__util__Timers_show(timers, _SLIT("v total"));
		}
		// Defer end
		return;
	}
	else if (string_eq(command, _SLIT("translate"))) {
		eprintln(_SLIT("Translating C to V will be available in V 0.3"));
		v_exit(1);
	}
	else if (string_eq(command, _SLIT("search")) || string_eq(command, _SLIT("install")) || string_eq(command, _SLIT("update")) || string_eq(command, _SLIT("upgrade")) || string_eq(command, _SLIT("outdated")) || string_eq(command, _SLIT("list")) || string_eq(command, _SLIT("remove"))) {
		v__util__launch_tool(prefs->is_verbose, _SLIT("vpm"), array_slice(_const_os__args, 1, _const_os__args.len));
		// Defer begin
		if (main__main_defer_0 == true) {
			v__util__Timers_show(timers, _SLIT("v total"));
		}
		// Defer end
		return;
	}
	else if (string_eq(command, _SLIT("vlib-docs"))) {
		v__util__launch_tool(prefs->is_verbose, _SLIT("vdoc"), new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT("doc"), _SLIT("vlib")})));
	}
	else if (string_eq(command, _SLIT("get"))) {
		eprintln(_SLIT("V Error: Use `v install` to install modules from vpm.vlang.io"));
		v_exit(1);
	}
	else if (string_eq(command, _SLIT("version"))) {
		println(v__util__full_v_version(prefs->is_verbose));
		// Defer begin
		if (main__main_defer_0 == true) {
			v__util__Timers_show(timers, _SLIT("v total"));
		}
		// Defer end
		return;
	}
	else {
	};
	if ((string_eq(command, _SLIT("run")) || string_eq(command, _SLIT("build")) || string_eq(command, _SLIT("build-module"))) || string_ends_with(command, _SLIT(".v")) || os__exists(command)) {
		v__builder__compile(command, prefs);
		// Defer begin
		if (main__main_defer_0 == true) {
			v__util__Timers_show(timers, _SLIT("v total"));
		}
		// Defer end
		return;
	}
	if (prefs->is_help) {
		main__invoke_help_and_exit(args);
	}
	eprintln(_STR("v %.*s\000: unknown command\nRun \"v help\" for usage.", 2, command));
	v_exit(1);
}

VV_LOCAL_SYMBOL void main__invoke_help_and_exit(Array_string remaining) {

	if (remaining.len == (0) || remaining.len == (1)) {
		help__print_and_exit(_SLIT("default"));
	}
	else if (remaining.len == (2)) {
		help__print_and_exit((*(string*)/*ee elem_typ */array_get(remaining, 1)));
	}
	else {
	};
	println(_SLIT("`v help`: provide only one help topic."));
	println(_SLIT("For usage information, use `v help`."));
	v_exit(1);
}

void _vinit(int ___argc, voidptr ___argv) {
	as_cast_type_indexes = new_array_from_c_array(101, 101, sizeof(VCastTypeIndexName), _MOV((VCastTypeIndexName[101]){
		  (VCastTypeIndexName){.tindex = 0, .tname = _SLIT("unknown")}
		, (VCastTypeIndexName){.tindex = 233, .tname = _SLIT("v.ast.AnonFn")}
		, (VCastTypeIndexName){.tindex = 234, .tname = _SLIT("v.ast.ArrayDecompose")}
		, (VCastTypeIndexName){.tindex = 235, .tname = _SLIT("v.ast.ArrayInit")}
		, (VCastTypeIndexName){.tindex = 236, .tname = _SLIT("v.ast.AsCast")}
		, (VCastTypeIndexName){.tindex = 237, .tname = _SLIT("v.ast.Assoc")}
		, (VCastTypeIndexName){.tindex = 238, .tname = _SLIT("v.ast.AtExpr")}
		, (VCastTypeIndexName){.tindex = 239, .tname = _SLIT("v.ast.BoolLiteral")}
		, (VCastTypeIndexName){.tindex = 240, .tname = _SLIT("v.ast.CTempVar")}
		, (VCastTypeIndexName){.tindex = 241, .tname = _SLIT("v.ast.CallExpr")}
		, (VCastTypeIndexName){.tindex = 242, .tname = _SLIT("v.ast.CastExpr")}
		, (VCastTypeIndexName){.tindex = 243, .tname = _SLIT("v.ast.ChanInit")}
		, (VCastTypeIndexName){.tindex = 244, .tname = _SLIT("v.ast.CharLiteral")}
		, (VCastTypeIndexName){.tindex = 245, .tname = _SLIT("v.ast.Comment")}
		, (VCastTypeIndexName){.tindex = 246, .tname = _SLIT("v.ast.ComptimeCall")}
		, (VCastTypeIndexName){.tindex = 247, .tname = _SLIT("v.ast.ComptimeSelector")}
		, (VCastTypeIndexName){.tindex = 248, .tname = _SLIT("v.ast.ConcatExpr")}
		, (VCastTypeIndexName){.tindex = 249, .tname = _SLIT("v.ast.DumpExpr")}
		, (VCastTypeIndexName){.tindex = 250, .tname = _SLIT("v.ast.EmptyExpr")}
		, (VCastTypeIndexName){.tindex = 251, .tname = _SLIT("v.ast.EnumVal")}
		, (VCastTypeIndexName){.tindex = 252, .tname = _SLIT("v.ast.FloatLiteral")}
		, (VCastTypeIndexName){.tindex = 253, .tname = _SLIT("v.ast.GoExpr")}
		, (VCastTypeIndexName){.tindex = 254, .tname = _SLIT("v.ast.Ident")}
		, (VCastTypeIndexName){.tindex = 255, .tname = _SLIT("v.ast.IfExpr")}
		, (VCastTypeIndexName){.tindex = 256, .tname = _SLIT("v.ast.IfGuardExpr")}
		, (VCastTypeIndexName){.tindex = 257, .tname = _SLIT("v.ast.IndexExpr")}
		, (VCastTypeIndexName){.tindex = 258, .tname = _SLIT("v.ast.InfixExpr")}
		, (VCastTypeIndexName){.tindex = 259, .tname = _SLIT("v.ast.IntegerLiteral")}
		, (VCastTypeIndexName){.tindex = 260, .tname = _SLIT("v.ast.Likely")}
		, (VCastTypeIndexName){.tindex = 261, .tname = _SLIT("v.ast.LockExpr")}
		, (VCastTypeIndexName){.tindex = 262, .tname = _SLIT("v.ast.MapInit")}
		, (VCastTypeIndexName){.tindex = 263, .tname = _SLIT("v.ast.MatchExpr")}
		, (VCastTypeIndexName){.tindex = 264, .tname = _SLIT("v.ast.NodeError")}
		, (VCastTypeIndexName){.tindex = 265, .tname = _SLIT("v.ast.None")}
		, (VCastTypeIndexName){.tindex = 266, .tname = _SLIT("v.ast.OffsetOf")}
		, (VCastTypeIndexName){.tindex = 267, .tname = _SLIT("v.ast.OrExpr")}
		, (VCastTypeIndexName){.tindex = 268, .tname = _SLIT("v.ast.ParExpr")}
		, (VCastTypeIndexName){.tindex = 269, .tname = _SLIT("v.ast.PostfixExpr")}
		, (VCastTypeIndexName){.tindex = 270, .tname = _SLIT("v.ast.PrefixExpr")}
		, (VCastTypeIndexName){.tindex = 271, .tname = _SLIT("v.ast.RangeExpr")}
		, (VCastTypeIndexName){.tindex = 272, .tname = _SLIT("v.ast.SelectExpr")}
		, (VCastTypeIndexName){.tindex = 273, .tname = _SLIT("v.ast.SelectorExpr")}
		, (VCastTypeIndexName){.tindex = 274, .tname = _SLIT("v.ast.SizeOf")}
		, (VCastTypeIndexName){.tindex = 275, .tname = _SLIT("v.ast.SqlExpr")}
		, (VCastTypeIndexName){.tindex = 276, .tname = _SLIT("v.ast.StringInterLiteral")}
		, (VCastTypeIndexName){.tindex = 277, .tname = _SLIT("v.ast.StringLiteral")}
		, (VCastTypeIndexName){.tindex = 278, .tname = _SLIT("v.ast.StructInit")}
		, (VCastTypeIndexName){.tindex = 279, .tname = _SLIT("v.ast.TypeNode")}
		, (VCastTypeIndexName){.tindex = 280, .tname = _SLIT("v.ast.TypeOf")}
		, (VCastTypeIndexName){.tindex = 281, .tname = _SLIT("v.ast.UnsafeExpr")}
		, (VCastTypeIndexName){.tindex = 408, .tname = _SLIT("v.ast.Aggregate")}
		, (VCastTypeIndexName){.tindex = 413, .tname = _SLIT("v.ast.Alias")}
		, (VCastTypeIndexName){.tindex = 395, .tname = _SLIT("v.ast.Array")}
		, (VCastTypeIndexName){.tindex = 416, .tname = _SLIT("v.ast.ArrayFixed")}
		, (VCastTypeIndexName){.tindex = 414, .tname = _SLIT("v.ast.Chan")}
		, (VCastTypeIndexName){.tindex = 420, .tname = _SLIT("v.ast.Enum")}
		, (VCastTypeIndexName){.tindex = 418, .tname = _SLIT("v.ast.FnType")}
		, (VCastTypeIndexName){.tindex = 419, .tname = _SLIT("v.ast.GenericStructInst")}
		, (VCastTypeIndexName){.tindex = 410, .tname = _SLIT("v.ast.Interface")}
		, (VCastTypeIndexName){.tindex = 396, .tname = _SLIT("v.ast.Map")}
		, (VCastTypeIndexName){.tindex = 417, .tname = _SLIT("v.ast.MultiReturn")}
		, (VCastTypeIndexName){.tindex = 409, .tname = _SLIT("v.ast.Struct")}
		, (VCastTypeIndexName){.tindex = 411, .tname = _SLIT("v.ast.SumType")}
		, (VCastTypeIndexName){.tindex = 415, .tname = _SLIT("v.ast.Thread")}
		, (VCastTypeIndexName){.tindex = 309, .tname = _SLIT("v.ast.AsmRegister")}
		, (VCastTypeIndexName){.tindex = 310, .tname = _SLIT("v.ast.ConstField")}
		, (VCastTypeIndexName){.tindex = 311, .tname = _SLIT("v.ast.GlobalField")}
		, (VCastTypeIndexName){.tindex = 312, .tname = _SLIT("v.ast.Var")}
		, (VCastTypeIndexName){.tindex = 362, .tname = _SLIT("v.ast.IdentFn")}
		, (VCastTypeIndexName){.tindex = 363, .tname = _SLIT("v.ast.IdentVar")}
		, (VCastTypeIndexName){.tindex = 283, .tname = _SLIT("v.ast.AsmStmt")}
		, (VCastTypeIndexName){.tindex = 284, .tname = _SLIT("v.ast.AssertStmt")}
		, (VCastTypeIndexName){.tindex = 285, .tname = _SLIT("v.ast.AssignStmt")}
		, (VCastTypeIndexName){.tindex = 286, .tname = _SLIT("v.ast.Block")}
		, (VCastTypeIndexName){.tindex = 287, .tname = _SLIT("v.ast.BranchStmt")}
		, (VCastTypeIndexName){.tindex = 288, .tname = _SLIT("v.ast.CompFor")}
		, (VCastTypeIndexName){.tindex = 289, .tname = _SLIT("v.ast.ConstDecl")}
		, (VCastTypeIndexName){.tindex = 290, .tname = _SLIT("v.ast.DeferStmt")}
		, (VCastTypeIndexName){.tindex = 291, .tname = _SLIT("v.ast.EmptyStmt")}
		, (VCastTypeIndexName){.tindex = 292, .tname = _SLIT("v.ast.EnumDecl")}
		, (VCastTypeIndexName){.tindex = 293, .tname = _SLIT("v.ast.ExprStmt")}
		, (VCastTypeIndexName){.tindex = 175, .tname = _SLIT("v.ast.FnDecl")}
		, (VCastTypeIndexName){.tindex = 294, .tname = _SLIT("v.ast.ForCStmt")}
		, (VCastTypeIndexName){.tindex = 295, .tname = _SLIT("v.ast.ForInStmt")}
		, (VCastTypeIndexName){.tindex = 296, .tname = _SLIT("v.ast.ForStmt")}
		, (VCastTypeIndexName){.tindex = 297, .tname = _SLIT("v.ast.GlobalDecl")}
		, (VCastTypeIndexName){.tindex = 298, .tname = _SLIT("v.ast.GoStmt")}
		, (VCastTypeIndexName){.tindex = 299, .tname = _SLIT("v.ast.GotoLabel")}
		, (VCastTypeIndexName){.tindex = 300, .tname = _SLIT("v.ast.GotoStmt")}
		, (VCastTypeIndexName){.tindex = 301, .tname = _SLIT("v.ast.HashStmt")}
		, (VCastTypeIndexName){.tindex = 302, .tname = _SLIT("v.ast.Import")}
		, (VCastTypeIndexName){.tindex = 303, .tname = _SLIT("v.ast.InterfaceDecl")}
		, (VCastTypeIndexName){.tindex = 304, .tname = _SLIT("v.ast.Module")}
		, (VCastTypeIndexName){.tindex = 305, .tname = _SLIT("v.ast.Return")}
		, (VCastTypeIndexName){.tindex = 306, .tname = _SLIT("v.ast.SqlStmt")}
		, (VCastTypeIndexName){.tindex = 307, .tname = _SLIT("v.ast.StructDecl")}
		, (VCastTypeIndexName){.tindex = 232, .tname = _SLIT("v.ast.TypeDecl")}
		, (VCastTypeIndexName){.tindex = 383, .tname = _SLIT("v.ast.AsmAddressing")}
		, (VCastTypeIndexName){.tindex = 384, .tname = _SLIT("v.ast.AsmAlias")}
		, (VCastTypeIndexName){.tindex = 385, .tname = _SLIT("v.ast.AsmDisp")}
		, (VCastTypeIndexName){.tindex = 18, .tname = _SLIT("string")}
	}));

	builtin_init();
	vinit_string_literals();
	// Initializations for module strings :
	// Initializations for module hash :
	_const_hash__wyp0 = ((u64)(0xa0761d6478bd642fU));
	_const_hash__wyp1 = ((u64)(0xe7037ed1a0b428dbU));
	_const_hash__wyp2 = ((u64)(0x8ebc6af09c88c6e3U));
	_const_hash__wyp3 = ((u64)(0x589965cc75374cc3U));
	_const_hash__wyp4 = ((u64)(0x1d8e4e27c47d124fU));
	// Initializations for module math.bits :
	_const_math__bits__de_bruijn32 = ((u32)(0x077CB531U));
	_const_math__bits__de_bruijn32tab = new_array_from_c_array(32, 32, sizeof(byte), _MOV((byte[32]){
		((byte)(0)), 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8, 31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9}));
	_const_math__bits__de_bruijn64 = ((u64)(0x03f79d71b4ca8b09U));
	_const_math__bits__de_bruijn64tab = new_array_from_c_array(64, 64, sizeof(byte), _MOV((byte[64]){
		((byte)(0)), 1, 56, 2, 57, 49, 28, 3, 61, 58, 42, 50, 38, 29, 17, 4, 62, 47, 59, 36, 45, 43, 51, 22, 53, 39, 33, 30, 24, 18, 12, 5, 63, 55, 48, 27, 60, 41, 37, 16, 46, 35, 44, 21, 52, 32, 23, 11, 54, 26, 40, 15, 34, 20, 31, 10, 25, 14, 19, 9, 13, 8, 7, 6}));
	_const_math__bits__m0 = ((u64)(0x5555555555555555U));
	_const_math__bits__m1 = ((u64)(0x3333333333333333U));
	_const_math__bits__m2 = ((u64)(0x0f0f0f0f0f0f0f0fU));
	_const_math__bits__m3 = ((u64)(0x00ff00ff00ff00ffU));
	_const_math__bits__m4 = ((u64)(0x0000ffff0000ffffU));
	_const_math__bits__max_u32 = ((u32)(4294967295U));
	_const_math__bits__max_u64 = ((u64)(18446744073709551615U));
	_const_math__bits__two32 = ((u64)(0x100000000U));
	_const_math__bits__mask32 = _const_math__bits__two32 - 1;
	_const_math__bits__ntz_8_tab = new_array_from_c_array(256, 256, sizeof(byte), _MOV((byte[256]){
		((byte)(0x08)), 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x05, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x06, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x05, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x07, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x05, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x06, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x05, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00}));
	_const_math__bits__pop_8_tab = new_array_from_c_array(256, 256, sizeof(byte), _MOV((byte[256]){
		((byte)(0x00)), 0x01, 0x01, 0x02, 0x01, 0x02, 0x02, 0x03, 0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 0x05, 0x06, 0x06, 0x07, 0x06, 0x07, 0x07, 0x08}));
	_const_math__bits__rev_8_tab = new_array_from_c_array(256, 256, sizeof(byte), _MOV((byte[256]){
		((byte)(0x00)), 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0, 0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0, 0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8, 0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8, 0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4, 0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4, 0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec, 0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc, 0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2, 0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2, 0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea, 0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa, 0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6, 0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6, 0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee, 0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe, 0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1, 0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1, 0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9, 0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9, 0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5, 0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5, 0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed, 0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd, 0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3, 0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3, 0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb, 0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb, 0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7, 0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7, 0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef, 0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff}));
	_const_math__bits__len_8_tab = new_array_from_c_array(256, 256, sizeof(byte), _MOV((byte[256]){
		((byte)(0x00)), 0x01, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08}));
	// Initializations for module strconv :
	_const_strconv__double_plus_zero = ((u64)(0x0000000000000000U));
	_const_strconv__double_minus_zero = ((u64)(0x8000000000000000U));
	_const_strconv__double_plus_infinity = ((u64)(0x7FF0000000000000U));
	_const_strconv__double_minus_infinity = ((u64)(0xFFF0000000000000U));
	_const_strconv__c_ten = ((u32)(10U));
	_const_strconv__pos_exp = new_array_from_c_array(309, 309, sizeof(u64), _MOV((u64[309]){
		((u64)(0x3ff0000000000000U)), ((u64)(0x4024000000000000U)), ((u64)(0x4059000000000000U)), ((u64)(0x408f400000000000U)), ((u64)(0x40c3880000000000U)), ((u64)(0x40f86a0000000000U)), ((u64)(0x412e848000000000U)), ((u64)(0x416312d000000000U)), ((u64)(0x4197d78400000000U)), ((u64)(0x41cdcd6500000000U)), ((u64)(0x4202a05f20000000U)), ((u64)(0x42374876e8000000U)), ((u64)(0x426d1a94a2000000U)), ((u64)(0x42a2309ce5400000U)), ((u64)(0x42d6bcc41e900000U)), ((u64)(0x430c6bf526340000U)), ((u64)(0x4341c37937e08000U)), ((u64)(0x4376345785d8a000U)), ((u64)(0x43abc16d674ec800U)), ((u64)(0x43e158e460913d00U)), ((u64)(0x4415af1d78b58c40U)), ((u64)(0x444b1ae4d6e2ef50U)), ((u64)(0x4480f0cf064dd592U)), ((u64)(0x44b52d02c7e14af6U)), ((u64)(0x44ea784379d99db4U)), ((u64)(0x45208b2a2c280291U)), ((u64)(0x4554adf4b7320335U)), ((u64)(0x4589d971e4fe8402U)), ((u64)(0x45c027e72f1f1281U)), ((u64)(0x45f431e0fae6d721U)), ((u64)(0x46293e5939a08ceaU)), ((u64)(0x465f8def8808b024U)), ((u64)(0x4693b8b5b5056e17U)), ((u64)(0x46c8a6e32246c99cU)), ((u64)(0x46fed09bead87c03U)), ((u64)(0x4733426172c74d82U)), ((u64)(0x476812f9cf7920e3U)), ((u64)(0x479e17b84357691bU)), ((u64)(0x47d2ced32a16a1b1U)), ((u64)(0x48078287f49c4a1dU)), ((u64)(0x483d6329f1c35ca5U)), ((u64)(0x48725dfa371a19e7U)), ((u64)(0x48a6f578c4e0a061U)), ((u64)(0x48dcb2d6f618c879U)), ((u64)(0x4911efc659cf7d4cU)), ((u64)(0x49466bb7f0435c9eU)), ((u64)(0x497c06a5ec5433c6U)), ((u64)(0x49b18427b3b4a05cU)), ((u64)(0x49e5e531a0a1c873U)), ((u64)(0x4a1b5e7e08ca3a8fU)), ((u64)(0x4a511b0ec57e649aU)), ((u64)(0x4a8561d276ddfdc0U)), ((u64)(0x4ababa4714957d30U)), ((u64)(0x4af0b46c6cdd6e3eU)), ((u64)(0x4b24e1878814c9ceU)), ((u64)(0x4b5a19e96a19fc41U)), ((u64)(0x4b905031e2503da9U)), ((u64)(0x4bc4643e5ae44d13U)), ((u64)(0x4bf97d4df19d6057U)), ((u64)(0x4c2fdca16e04b86dU)), ((u64)(0x4c63e9e4e4c2f344U)), ((u64)(0x4c98e45e1df3b015U)), ((u64)(0x4ccf1d75a5709c1bU)), ((u64)(0x4d03726987666191U)), ((u64)(0x4d384f03e93ff9f5U)), ((u64)(0x4d6e62c4e38ff872U)), ((u64)(0x4da2fdbb0e39fb47U)), ((u64)(0x4dd7bd29d1c87a19U)), ((u64)(0x4e0dac74463a989fU)), ((u64)(0x4e428bc8abe49f64U)), ((u64)(0x4e772ebad6ddc73dU)), ((u64)(0x4eacfa698c95390cU)), ((u64)(0x4ee21c81f7dd43a7U)), ((u64)(0x4f16a3a275d49491U)), ((u64)(0x4f4c4c8b1349b9b5U)), ((u64)(0x4f81afd6ec0e1411U)), ((u64)(0x4fb61bcca7119916U)), ((u64)(0x4feba2bfd0d5ff5bU)), ((u64)(0x502145b7e285bf99U)), ((u64)(0x50559725db272f7fU)), ((u64)(0x508afcef51f0fb5fU)), ((u64)(0x50c0de1593369d1bU)), ((u64)(0x50f5159af8044462U)), ((u64)(0x512a5b01b605557bU)), ((u64)(0x516078e111c3556dU)), ((u64)(0x5194971956342ac8U)), ((u64)(0x51c9bcdfabc1357aU)), ((u64)(0x5200160bcb58c16cU)), ((u64)(0x52341b8ebe2ef1c7U)), ((u64)(0x526922726dbaae39U)), ((u64)(0x529f6b0f092959c7U)), ((u64)(0x52d3a2e965b9d81dU)), ((u64)(0x53088ba3bf284e24U)), ((u64)(0x533eae8caef261adU)), ((u64)(0x53732d17ed577d0cU)), ((u64)(0x53a7f85de8ad5c4fU)), ((u64)(0x53ddf67562d8b363U)), ((u64)(0x5412ba095dc7701eU)), ((u64)(0x5447688bb5394c25U)), ((u64)(0x547d42aea2879f2eU)), ((u64)(0x54b249ad2594c37dU)), ((u64)(0x54e6dc186ef9f45cU)), ((u64)(0x551c931e8ab87173U)), ((u64)(0x5551dbf316b346e8U)), ((u64)(0x558652efdc6018a2U)), ((u64)(0x55bbe7abd3781ecaU)), ((u64)(0x55f170cb642b133fU)), ((u64)(0x5625ccfe3d35d80eU)), ((u64)(0x565b403dcc834e12U)), ((u64)(0x569108269fd210cbU)), ((u64)(0x56c54a3047c694feU)), ((u64)(0x56fa9cbc59b83a3dU)), ((u64)(0x5730a1f5b8132466U)), ((u64)(0x5764ca732617ed80U)), ((u64)(0x5799fd0fef9de8e0U)), ((u64)(0x57d03e29f5c2b18cU)), ((u64)(0x58044db473335defU)), ((u64)(0x583961219000356bU)), ((u64)(0x586fb969f40042c5U)), ((u64)(0x58a3d3e2388029bbU)), ((u64)(0x58d8c8dac6a0342aU)), ((u64)(0x590efb1178484135U)), ((u64)(0x59435ceaeb2d28c1U)), ((u64)(0x59783425a5f872f1U)), ((u64)(0x59ae412f0f768fadU)), ((u64)(0x59e2e8bd69aa19ccU)), ((u64)(0x5a17a2ecc414a03fU)), ((u64)(0x5a4d8ba7f519c84fU)), ((u64)(0x5a827748f9301d32U)), ((u64)(0x5ab7151b377c247eU)), ((u64)(0x5aecda62055b2d9eU)), ((u64)(0x5b22087d4358fc82U)), ((u64)(0x5b568a9c942f3ba3U)), ((u64)(0x5b8c2d43b93b0a8cU)), ((u64)(0x5bc19c4a53c4e697U)), ((u64)(0x5bf6035ce8b6203dU)), ((u64)(0x5c2b843422e3a84dU)), ((u64)(0x5c6132a095ce4930U)), ((u64)(0x5c957f48bb41db7cU)), ((u64)(0x5ccadf1aea12525bU)), ((u64)(0x5d00cb70d24b7379U)), ((u64)(0x5d34fe4d06de5057U)), ((u64)(0x5d6a3de04895e46dU)), ((u64)(0x5da066ac2d5daec4U)), ((u64)(0x5dd4805738b51a75U)), ((u64)(0x5e09a06d06e26112U)), ((u64)(0x5e400444244d7cabU)), ((u64)(0x5e7405552d60dbd6U)), ((u64)(0x5ea906aa78b912ccU)), ((u64)(0x5edf485516e7577fU)), ((u64)(0x5f138d352e5096afU)), ((u64)(0x5f48708279e4bc5bU)), ((u64)(0x5f7e8ca3185deb72U)), ((u64)(0x5fb317e5ef3ab327U)), ((u64)(0x5fe7dddf6b095ff1U)), ((u64)(0x601dd55745cbb7edU)), ((u64)(0x6052a5568b9f52f4U)), ((u64)(0x60874eac2e8727b1U)), ((u64)(0x60bd22573a28f19dU)), ((u64)(0x60f2357684599702U)), ((u64)(0x6126c2d4256ffcc3U)), ((u64)(0x615c73892ecbfbf4U)), ((u64)(0x6191c835bd3f7d78U)), ((u64)(0x61c63a432c8f5cd6U)), ((u64)(0x61fbc8d3f7b3340cU)), ((u64)(0x62315d847ad00087U)), ((u64)(0x6265b4e5998400a9U)), ((u64)(0x629b221effe500d4U)), ((u64)(0x62d0f5535fef2084U)), ((u64)(0x630532a837eae8a5U)), ((u64)(0x633a7f5245e5a2cfU)), ((u64)(0x63708f936baf85c1U)), ((u64)(0x63a4b378469b6732U)), ((u64)(0x63d9e056584240feU)), ((u64)(0x64102c35f729689fU)), ((u64)(0x6444374374f3c2c6U)), ((u64)(0x647945145230b378U)), ((u64)(0x64af965966bce056U)), ((u64)(0x64e3bdf7e0360c36U)), ((u64)(0x6518ad75d8438f43U)), ((u64)(0x654ed8d34e547314U)), ((u64)(0x6583478410f4c7ecU)), ((u64)(0x65b819651531f9e8U)), ((u64)(0x65ee1fbe5a7e7861U)), ((u64)(0x6622d3d6f88f0b3dU)), ((u64)(0x665788ccb6b2ce0cU)), ((u64)(0x668d6affe45f818fU)), ((u64)(0x66c262dfeebbb0f9U)), ((u64)(0x66f6fb97ea6a9d38U)), ((u64)(0x672cba7de5054486U)), ((u64)(0x6761f48eaf234ad4U)), ((u64)(0x679671b25aec1d89U)), ((u64)(0x67cc0e1ef1a724ebU)), ((u64)(0x680188d357087713U)), ((u64)(0x6835eb082cca94d7U)), ((u64)(0x686b65ca37fd3a0dU)), ((u64)(0x68a11f9e62fe4448U)), ((u64)(0x68d56785fbbdd55aU)), ((u64)(0x690ac1677aad4ab1U)), ((u64)(0x6940b8e0acac4eafU)), ((u64)(0x6974e718d7d7625aU)), ((u64)(0x69aa20df0dcd3af1U)), ((u64)(0x69e0548b68a044d6U)), ((u64)(0x6a1469ae42c8560cU)), ((u64)(0x6a498419d37a6b8fU)), ((u64)(0x6a7fe52048590673U)), ((u64)(0x6ab3ef342d37a408U)), ((u64)(0x6ae8eb0138858d0aU)), ((u64)(0x6b1f25c186a6f04cU)), ((u64)(0x6b537798f4285630U)), ((u64)(0x6b88557f31326bbbU)), ((u64)(0x6bbe6adefd7f06aaU)), ((u64)(0x6bf302cb5e6f642aU)), ((u64)(0x6c27c37e360b3d35U)), ((u64)(0x6c5db45dc38e0c82U)), ((u64)(0x6c9290ba9a38c7d1U)), ((u64)(0x6cc734e940c6f9c6U)), ((u64)(0x6cfd022390f8b837U)), ((u64)(0x6d3221563a9b7323U)), ((u64)(0x6d66a9abc9424febU)), ((u64)(0x6d9c5416bb92e3e6U)), ((u64)(0x6dd1b48e353bce70U)), ((u64)(0x6e0621b1c28ac20cU)), ((u64)(0x6e3baa1e332d728fU)), ((u64)(0x6e714a52dffc6799U)), ((u64)(0x6ea59ce797fb817fU)), ((u64)(0x6edb04217dfa61dfU)), ((u64)(0x6f10e294eebc7d2cU)), ((u64)(0x6f451b3a2a6b9c76U)), ((u64)(0x6f7a6208b5068394U)), ((u64)(0x6fb07d457124123dU)), ((u64)(0x6fe49c96cd6d16ccU)), ((u64)(0x7019c3bc80c85c7fU)), ((u64)(0x70501a55d07d39cfU)), ((u64)(0x708420eb449c8843U)), ((u64)(0x70b9292615c3aa54U)), ((u64)(0x70ef736f9b3494e9U)), ((u64)(0x7123a825c100dd11U)), ((u64)(0x7158922f31411456U)), ((u64)(0x718eb6bafd91596bU)), ((u64)(0x71c33234de7ad7e3U)), ((u64)(0x71f7fec216198ddcU)), ((u64)(0x722dfe729b9ff153U)), ((u64)(0x7262bf07a143f6d4U)), ((u64)(0x72976ec98994f489U)), ((u64)(0x72cd4a7bebfa31abU)), ((u64)(0x73024e8d737c5f0bU)), ((u64)(0x7336e230d05b76cdU)), ((u64)(0x736c9abd04725481U)), ((u64)(0x73a1e0b622c774d0U)), ((u64)(0x73d658e3ab795204U)), ((u64)(0x740bef1c9657a686U)), ((u64)(0x74417571ddf6c814U)), ((u64)(0x7475d2ce55747a18U)), ((u64)(0x74ab4781ead1989eU)), ((u64)(0x74e10cb132c2ff63U)), ((u64)(0x75154fdd7f73bf3cU)), ((u64)(0x754aa3d4df50af0bU)), ((u64)(0x7580a6650b926d67U)), ((u64)(0x75b4cffe4e7708c0U)), ((u64)(0x75ea03fde214caf1U)), ((u64)(0x7620427ead4cfed6U)), ((u64)(0x7654531e58a03e8cU)), ((u64)(0x768967e5eec84e2fU)), ((u64)(0x76bfc1df6a7a61bbU)), ((u64)(0x76f3d92ba28c7d15U)), ((u64)(0x7728cf768b2f9c5aU)), ((u64)(0x775f03542dfb8370U)), ((u64)(0x779362149cbd3226U)), ((u64)(0x77c83a99c3ec7eb0U)), ((u64)(0x77fe494034e79e5cU)), ((u64)(0x7832edc82110c2f9U)), ((u64)(0x7867a93a2954f3b8U)), ((u64)(0x789d9388b3aa30a5U)), ((u64)(0x78d27c35704a5e67U)), ((u64)(0x79071b42cc5cf601U)), ((u64)(0x793ce2137f743382U)), ((u64)(0x79720d4c2fa8a031U)), ((u64)(0x79a6909f3b92c83dU)), ((u64)(0x79dc34c70a777a4dU)), ((u64)(0x7a11a0fc668aac70U)), ((u64)(0x7a46093b802d578cU)), ((u64)(0x7a7b8b8a6038ad6fU)), ((u64)(0x7ab137367c236c65U)), ((u64)(0x7ae585041b2c477fU)), ((u64)(0x7b1ae64521f7595eU)), ((u64)(0x7b50cfeb353a97dbU)), ((u64)(0x7b8503e602893dd2U)), ((u64)(0x7bba44df832b8d46U)), ((u64)(0x7bf06b0bb1fb384cU)), ((u64)(0x7c2485ce9e7a065fU)), ((u64)(0x7c59a742461887f6U)), ((u64)(0x7c9008896bcf54faU)), ((u64)(0x7cc40aabc6c32a38U)), ((u64)(0x7cf90d56b873f4c7U)), ((u64)(0x7d2f50ac6690f1f8U)), ((u64)(0x7d63926bc01a973bU)), ((u64)(0x7d987706b0213d0aU)), ((u64)(0x7dce94c85c298c4cU)), ((u64)(0x7e031cfd3999f7b0U)), ((u64)(0x7e37e43c8800759cU)), ((u64)(0x7e6ddd4baa009303U)), ((u64)(0x7ea2aa4f4a405be2U)), ((u64)(0x7ed754e31cd072daU)), ((u64)(0x7f0d2a1be4048f90U)), ((u64)(0x7f423a516e82d9baU)), ((u64)(0x7f76c8e5ca239029U)), ((u64)(0x7fac7b1f3cac7433U)), ((u64)(0x7fe1ccf385ebc8a0U))}));
	_const_strconv__neg_exp = new_array_from_c_array(324, 324, sizeof(u64), _MOV((u64[324]){
		((u64)(0x3ff0000000000000U)), ((u64)(0x3fb999999999999aU)), ((u64)(0x3f847ae147ae147bU)), ((u64)(0x3f50624dd2f1a9fcU)), ((u64)(0x3f1a36e2eb1c432dU)), ((u64)(0x3ee4f8b588e368f1U)), ((u64)(0x3eb0c6f7a0b5ed8dU)), ((u64)(0x3e7ad7f29abcaf48U)), ((u64)(0x3e45798ee2308c3aU)), ((u64)(0x3e112e0be826d695U)), ((u64)(0x3ddb7cdfd9d7bdbbU)), ((u64)(0x3da5fd7fe1796495U)), ((u64)(0x3d719799812dea11U)), ((u64)(0x3d3c25c268497682U)), ((u64)(0x3d06849b86a12b9bU)), ((u64)(0x3cd203af9ee75616U)), ((u64)(0x3c9cd2b297d889bcU)), ((u64)(0x3c670ef54646d497U)), ((u64)(0x3c32725dd1d243acU)), ((u64)(0x3bfd83c94fb6d2acU)), ((u64)(0x3bc79ca10c924223U)), ((u64)(0x3b92e3b40a0e9b4fU)), ((u64)(0x3b5e392010175ee6U)), ((u64)(0x3b282db34012b251U)), ((u64)(0x3af357c299a88ea7U)), ((u64)(0x3abef2d0f5da7dd9U)), ((u64)(0x3a88c240c4aecb14U)), ((u64)(0x3a53ce9a36f23c10U)), ((u64)(0x3a1fb0f6be506019U)), ((u64)(0x39e95a5efea6b347U)), ((u64)(0x39b4484bfeebc2a0U)), ((u64)(0x398039d665896880U)), ((u64)(0x3949f623d5a8a733U)), ((u64)(0x3914c4e977ba1f5cU)), ((u64)(0x38e09d8792fb4c49U)), ((u64)(0x38aa95a5b7f87a0fU)), ((u64)(0x38754484932d2e72U)), ((u64)(0x3841039d428a8b8fU)), ((u64)(0x380b38fb9daa78e4U)), ((u64)(0x37d5c72fb1552d83U)), ((u64)(0x37a16c262777579cU)), ((u64)(0x376be03d0bf225c7U)), ((u64)(0x37364cfda3281e39U)), ((u64)(0x3701d7314f534b61U)), ((u64)(0x36cc8b8218854567U)), ((u64)(0x3696d601ad376ab9U)), ((u64)(0x366244ce242c5561U)), ((u64)(0x362d3ae36d13bbceU)), ((u64)(0x35f7624f8a762fd8U)), ((u64)(0x35c2b50c6ec4f313U)), ((u64)(0x358dee7a4ad4b81fU)), ((u64)(0x3557f1fb6f10934cU)), ((u64)(0x352327fc58da0f70U)), ((u64)(0x34eea6608e29b24dU)), ((u64)(0x34b8851a0b548ea4U)), ((u64)(0x34839dae6f76d883U)), ((u64)(0x344f62b0b257c0d2U)), ((u64)(0x34191bc08eac9a41U)), ((u64)(0x33e41633a556e1ceU)), ((u64)(0x33b011c2eaabe7d8U)), ((u64)(0x3379b604aaaca626U)), ((u64)(0x3344919d5556eb52U)), ((u64)(0x3310747ddddf22a8U)), ((u64)(0x32da53fc9631d10dU)), ((u64)(0x32a50ffd44f4a73dU)), ((u64)(0x3270d9976a5d5297U)), ((u64)(0x323af5bf109550f2U)), ((u64)(0x32059165a6ddda5bU)), ((u64)(0x31d1411e1f17e1e3U)), ((u64)(0x319b9b6364f30304U)), ((u64)(0x316615e91d8f359dU)), ((u64)(0x3131ab20e472914aU)), ((u64)(0x30fc45016d841baaU)), ((u64)(0x30c69d9abe034955U)), ((u64)(0x309217aefe690777U)), ((u64)(0x305cf2b1970e7258U)), ((u64)(0x3027288e1271f513U)), ((u64)(0x2ff286d80ec190dcU)), ((u64)(0x2fbda48ce468e7c7U)), ((u64)(0x2f87b6d71d20b96cU)), ((u64)(0x2f52f8ac174d6123U)), ((u64)(0x2f1e5aacf2156838U)), ((u64)(0x2ee8488a5b445360U)), ((u64)(0x2eb36d3b7c36a91aU)), ((u64)(0x2e7f152bf9f10e90U)), ((u64)(0x2e48ddbcc7f40ba6U)), ((u64)(0x2e13e497065cd61fU)), ((u64)(0x2ddfd424d6faf031U)), ((u64)(0x2da97683df2f268dU)), ((u64)(0x2d745ecfe5bf520bU)), ((u64)(0x2d404bd984990e6fU)), ((u64)(0x2d0a12f5a0f4e3e5U)), ((u64)(0x2cd4dbf7b3f71cb7U)), ((u64)(0x2ca0aff95cc5b092U)), ((u64)(0x2c6ab328946f80eaU)), ((u64)(0x2c355c2076bf9a55U)), ((u64)(0x2c0116805effaeaaU)), ((u64)(0x2bcb5733cb32b111U)), ((u64)(0x2b95df5ca28ef40dU)), ((u64)(0x2b617f7d4ed8c33eU)), ((u64)(0x2b2bff2ee48e0530U)), ((u64)(0x2af665bf1d3e6a8dU)), ((u64)(0x2ac1eaff4a98553dU)), ((u64)(0x2a8cab3210f3bb95U)), ((u64)(0x2a56ef5b40c2fc77U)), ((u64)(0x2a225915cd68c9f9U)), ((u64)(0x29ed5b561574765bU)), ((u64)(0x29b77c44ddf6c516U)), ((u64)(0x2982c9d0b1923745U)), ((u64)(0x294e0fb44f50586eU)), ((u64)(0x29180c903f7379f2U)), ((u64)(0x28e33d4032c2c7f5U)), ((u64)(0x28aec866b79e0cbaU)), ((u64)(0x2878a0522c7e7095U)), ((u64)(0x2843b374f06526deU)), ((u64)(0x280f8587e7083e30U)), ((u64)(0x27d9379fec069826U)), ((u64)(0x27a42c7ff0054685U)), ((u64)(0x277023998cd10537U)), ((u64)(0x2739d28f47b4d525U)), ((u64)(0x2704a8729fc3ddb7U)), ((u64)(0x26d086c219697e2cU)), ((u64)(0x269a71368f0f3047U)), ((u64)(0x2665275ed8d8f36cU)), ((u64)(0x2630ec4be0ad8f89U)), ((u64)(0x25fb13ac9aaf4c0fU)), ((u64)(0x25c5a956e225d672U)), ((u64)(0x2591544581b7dec2U)), ((u64)(0x255bba08cf8c979dU)), ((u64)(0x25262e6d72d6dfb0U)), ((u64)(0x24f1bebdf578b2f4U)), ((u64)(0x24bc6463225ab7ecU)), ((u64)(0x2486b6b5b5155ff0U)), ((u64)(0x24522bc490dde65aU)), ((u64)(0x241d12d41afca3c3U)), ((u64)(0x23e7424348ca1c9cU)), ((u64)(0x23b29b69070816e3U)), ((u64)(0x237dc574d80cf16bU)), ((u64)(0x2347d12a4670c123U)), ((u64)(0x23130dbb6b8d674fU)), ((u64)(0x22de7c5f127bd87eU)), ((u64)(0x22a8637f41fcad32U)), ((u64)(0x227382cc34ca2428U)), ((u64)(0x223f37ad21436d0cU)), ((u64)(0x2208f9574dcf8a70U)), ((u64)(0x21d3faac3e3fa1f3U)), ((u64)(0x219ff779fd329cb9U)), ((u64)(0x216992c7fdc216faU)), ((u64)(0x2134756ccb01abfbU)), ((u64)(0x21005df0a267bcc9U)), ((u64)(0x20ca2fe76a3f9475U)), ((u64)(0x2094f31f8832dd2aU)), ((u64)(0x2060c27fa028b0efU)), ((u64)(0x202ad0cc33744e4bU)), ((u64)(0x1ff573d68f903ea2U)), ((u64)(0x1fc1297872d9cbb5U)), ((u64)(0x1f8b758d848fac55U)), ((u64)(0x1f55f7a46a0c89ddU)), ((u64)(0x1f2192e9ee706e4bU)), ((u64)(0x1eec1e43171a4a11U)), ((u64)(0x1eb67e9c127b6e74U)), ((u64)(0x1e81fee341fc585dU)), ((u64)(0x1e4ccb0536608d61U)), ((u64)(0x1e1708d0f84d3de7U)), ((u64)(0x1de26d73f9d764b9U)), ((u64)(0x1dad7becc2f23ac2U)), ((u64)(0x1d779657025b6235U)), ((u64)(0x1d42deac01e2b4f7U)), ((u64)(0x1d0e3113363787f2U)), ((u64)(0x1cd8274291c6065bU)), ((u64)(0x1ca3529ba7d19eafU)), ((u64)(0x1c6eea92a61c3118U)), ((u64)(0x1c38bba884e35a7aU)), ((u64)(0x1c03c9539d82aec8U)), ((u64)(0x1bcfa885c8d117a6U)), ((u64)(0x1b99539e3a40dfb8U)), ((u64)(0x1b6442e4fb671960U)), ((u64)(0x1b303583fc527ab3U)), ((u64)(0x1af9ef3993b72ab8U)), ((u64)(0x1ac4bf6142f8eefaU)), ((u64)(0x1a90991a9bfa58c8U)), ((u64)(0x1a5a8e90f9908e0dU)), ((u64)(0x1a253eda614071a4U)), ((u64)(0x19f0ff151a99f483U)), ((u64)(0x19bb31bb5dc320d2U)), ((u64)(0x1985c162b168e70eU)), ((u64)(0x1951678227871f3eU)), ((u64)(0x191bd8d03f3e9864U)), ((u64)(0x18e6470cff6546b6U)), ((u64)(0x18b1d270cc51055fU)), ((u64)(0x187c83e7ad4e6efeU)), ((u64)(0x1846cfec8aa52598U)), ((u64)(0x18123ff06eea847aU)), ((u64)(0x17dd331a4b10d3f6U)), ((u64)(0x17a75c1508da432bU)), ((u64)(0x1772b010d3e1cf56U)), ((u64)(0x173de6815302e556U)), ((u64)(0x1707eb9aa8cf1ddeU)), ((u64)(0x16d322e220a5b17eU)), ((u64)(0x169e9e369aa2b597U)), ((u64)(0x16687e92154ef7acU)), ((u64)(0x16339874ddd8c623U)), ((u64)(0x15ff5a549627a36cU)), ((u64)(0x15c91510781fb5f0U)), ((u64)(0x159410d9f9b2f7f3U)), ((u64)(0x15600d7b2e28c65cU)), ((u64)(0x1529af2b7d0e0a2dU)), ((u64)(0x14f48c22ca71a1bdU)), ((u64)(0x14c0701bd527b498U)), ((u64)(0x148a4cf9550c5426U)), ((u64)(0x14550a6110d6a9b8U)), ((u64)(0x1420d51a73deee2dU)), ((u64)(0x13eaee90b964b047U)), ((u64)(0x13b58ba6fab6f36cU)), ((u64)(0x13813c85955f2923U)), ((u64)(0x134b9408eefea839U)), ((u64)(0x1316100725988694U)), ((u64)(0x12e1a66c1e139eddU)), ((u64)(0x12ac3d79c9b8fe2eU)), ((u64)(0x12769794a160cb58U)), ((u64)(0x124212dd4de70913U)), ((u64)(0x120ceafbafd80e85U)), ((u64)(0x11d72262f3133ed1U)), ((u64)(0x11a281e8c275cbdaU)), ((u64)(0x116d9ca79d89462aU)), ((u64)(0x1137b08617a104eeU)), ((u64)(0x1102f39e794d9d8bU)), ((u64)(0x10ce5297287c2f45U)), ((u64)(0x1098421286c9bf6bU)), ((u64)(0x1063680ed23aff89U)), ((u64)(0x102f0ce4839198dbU)), ((u64)(0x0ff8d71d360e13e2U)), ((u64)(0x0fc3df4a91a4dcb5U)), ((u64)(0x0f8fcbaa82a16121U)), ((u64)(0x0f596fbb9bb44db4U)), ((u64)(0x0f245962e2f6a490U)), ((u64)(0x0ef047824f2bb6daU)), ((u64)(0x0eba0c03b1df8af6U)), ((u64)(0x0e84d6695b193bf8U)), ((u64)(0x0e50ab877c142ffaU)), ((u64)(0x0e1aac0bf9b9e65cU)), ((u64)(0x0de5566ffafb1eb0U)), ((u64)(0x0db111f32f2f4bc0U)), ((u64)(0x0d7b4feb7eb212cdU)), ((u64)(0x0d45d98932280f0aU)), ((u64)(0x0d117ad428200c08U)), ((u64)(0x0cdbf7b9d9cce00dU)), ((u64)(0x0ca65fc7e170b33eU)), ((u64)(0x0c71e6398126f5cbU)), ((u64)(0x0c3ca38f350b22dfU)), ((u64)(0x0c06e93f5da2824cU)), ((u64)(0x0bd25432b14ecea3U)), ((u64)(0x0b9d53844ee47dd1U)), ((u64)(0x0b677603725064a8U)), ((u64)(0x0b32c4cf8ea6b6ecU)), ((u64)(0x0afe07b27dd78b14U)), ((u64)(0x0ac8062864ac6f43U)), ((u64)(0x0a9338205089f29cU)), ((u64)(0x0a5ec033b40fea93U)), ((u64)(0x0a2899c2f6732210U)), ((u64)(0x09f3ae3591f5b4d9U)), ((u64)(0x09bf7d228322baf5U)), ((u64)(0x098930e868e89591U)), ((u64)(0x0954272053ed4474U)), ((u64)(0x09201f4d0ff10390U)), ((u64)(0x08e9cbae7fe805b3U)), ((u64)(0x08b4a2f1ffecd15cU)), ((u64)(0x0880825b3323dab0U)), ((u64)(0x084a6a2b85062ab3U)), ((u64)(0x081521bc6a6b555cU)), ((u64)(0x07e0e7c9eebc444aU)), ((u64)(0x07ab0c764ac6d3a9U)), ((u64)(0x0775a391d56bdc87U)), ((u64)(0x07414fa7ddefe3a0U)), ((u64)(0x070bb2a62fe638ffU)), ((u64)(0x06d62884f31e93ffU)), ((u64)(0x06a1ba03f5b21000U)), ((u64)(0x066c5cd322b67fffU)), ((u64)(0x0636b0a8e891ffffU)), ((u64)(0x060226ed86db3333U)), ((u64)(0x05cd0b15a491eb84U)), ((u64)(0x05973c115074bc6aU)), ((u64)(0x05629674405d6388U)), ((u64)(0x052dbd86cd6238d9U)), ((u64)(0x04f7cad23de82d7bU)), ((u64)(0x04c308a831868ac9U)), ((u64)(0x048e74404f3daadbU)), ((u64)(0x04585d003f6488afU)), ((u64)(0x04237d99cc506d59U)), ((u64)(0x03ef2f5c7a1a488eU)), ((u64)(0x03b8f2b061aea072U)), ((u64)(0x0383f559e7bee6c1U)), ((u64)(0x034feef63f97d79cU)), ((u64)(0x03198bf832dfdfb0U)), ((u64)(0x02e46ff9c24cb2f3U)), ((u64)(0x02b059949b708f29U)), ((u64)(0x027a28edc580e50eU)), ((u64)(0x0244ed8b04671da5U)), ((u64)(0x0210be08d0527e1dU)), ((u64)(0x01dac9a7b3b7302fU)), ((u64)(0x01a56e1fc2f8f359U)), ((u64)(0x017124e63593f5e1U)), ((u64)(0x013b6e3d22865634U)), ((u64)(0x0105f1ca820511c3U)), ((u64)(0x00d18e3b9b374169U)), ((u64)(0x009c16c5c5253575U)), ((u64)(0x0066789e3750f791U)), ((u64)(0x0031fa182c40c60dU)), ((u64)(0x000730d67819e8d2U)), ((u64)(0x0000b8157268fdafU)), ((u64)(0x000012688b70e62bU)), ((u64)(0x000001d74124e3d1U)), ((u64)(0x0000002f201d49fbU)), ((u64)(0x00000004b6695433U)), ((u64)(0x0000000078a42205U)), ((u64)(0x000000000c1069cdU)), ((u64)(0x000000000134d761U)), ((u64)(0x00000000001ee257U)), ((u64)(0x00000000000316a2U)), ((u64)(0x0000000000004f10U)), ((u64)(0x00000000000007e8U)), ((u64)(0x00000000000000caU)), ((u64)(0x0000000000000014U)), ((u64)(0x0000000000000002U))}));
	_const_strconv__max_u64 = ((u64)(18446744073709551615U));
	_const_strconv__ten_pow_table_32 = new_array_from_c_array(12, 12, sizeof(u32), _MOV((u32[12]){
		((u32)(1U)), ((u32)(10U)), ((u32)(100U)), ((u32)(1000U)), ((u32)(10000U)), ((u32)(100000U)), ((u32)(1000000U)), ((u32)(10000000U)), ((u32)(100000000U)), ((u32)(1000000000U)), ((u32)(10000000000U)), ((u32)(100000000000U))}));
	_const_strconv__mantbits32 = ((u32)(23U));
	_const_strconv__expbits32 = ((u32)(8U));
	_const_strconv__ten_pow_table_64 = new_array_from_c_array(20, 20, sizeof(u64), _MOV((u64[20]){
		((u64)(1U)), ((u64)(10U)), ((u64)(100U)), ((u64)(1000U)), ((u64)(10000U)), ((u64)(100000U)), ((u64)(1000000U)), ((u64)(10000000U)), ((u64)(100000000U)), ((u64)(1000000000U)), ((u64)(10000000000U)), ((u64)(100000000000U)), ((u64)(1000000000000U)), ((u64)(10000000000000U)), ((u64)(100000000000000U)), ((u64)(1000000000000000U)), ((u64)(10000000000000000U)), ((u64)(100000000000000000U)), ((u64)(1000000000000000000U)), ((u64)(10000000000000000000U))}));
	_const_strconv__mantbits64 = ((u32)(52U));
	_const_strconv__expbits64 = ((u32)(11U));
	_const_strconv__dec_round = new_array_from_c_array(20, 20, sizeof(f64), _MOV((f64[20]){
		((f64)(0.44)), 0.044, 0.0044, 0.00044, 0.000044, 0.0000044, 0.00000044, 0.000000044, 0.0000000044, 0.00000000044, 0.000000000044, 0.0000000000044, 0.00000000000044, 0.000000000000044, 0.0000000000000044, 0.00000000000000044, 0.000000000000000044, 0.0000000000000000044, 0.00000000000000000044, 0.000000000000000000044}));
	_const_strconv__powers_of_10 = new_array_from_c_array(18, 18, sizeof(u64), _MOV((u64[18]){
		((u64)(1e0)), ((u64)(1e1)), ((u64)(1e2)), ((u64)(1e3)), ((u64)(1e4)), ((u64)(1e5)), ((u64)(1e6)), ((u64)(1e7)), ((u64)(1e8)), ((u64)(1e9)), ((u64)(1e10)), ((u64)(1e11)), ((u64)(1e12)), ((u64)(1e13)), ((u64)(1e14)), ((u64)(1e15)), ((u64)(1e16)), ((u64)(1e17))}));
	_const_strconv__pow5_split_32 = new_array_from_c_array(47, 47, sizeof(u64), _MOV((u64[47]){
		((u64)(1152921504606846976U)), ((u64)(1441151880758558720U)), ((u64)(1801439850948198400U)), ((u64)(2251799813685248000U)), ((u64)(1407374883553280000U)), ((u64)(1759218604441600000U)), ((u64)(2199023255552000000U)), ((u64)(1374389534720000000U)), ((u64)(1717986918400000000U)), ((u64)(2147483648000000000U)), ((u64)(1342177280000000000U)), ((u64)(1677721600000000000U)), ((u64)(2097152000000000000U)), ((u64)(1310720000000000000U)), ((u64)(1638400000000000000U)), ((u64)(2048000000000000000U)), ((u64)(1280000000000000000U)), ((u64)(1600000000000000000U)), ((u64)(2000000000000000000U)), ((u64)(1250000000000000000U)), ((u64)(1562500000000000000U)), ((u64)(1953125000000000000U)), ((u64)(1220703125000000000U)), ((u64)(1525878906250000000U)), ((u64)(1907348632812500000U)), ((u64)(1192092895507812500U)), ((u64)(1490116119384765625U)), ((u64)(1862645149230957031U)), ((u64)(1164153218269348144U)), ((u64)(1455191522836685180U)), ((u64)(1818989403545856475U)), ((u64)(2273736754432320594U)), ((u64)(1421085471520200371U)), ((u64)(1776356839400250464U)), ((u64)(2220446049250313080U)), ((u64)(1387778780781445675U)), ((u64)(1734723475976807094U)), ((u64)(2168404344971008868U)), ((u64)(1355252715606880542U)), ((u64)(1694065894508600678U)), ((u64)(2117582368135750847U)), ((u64)(1323488980084844279U)), ((u64)(1654361225106055349U)), ((u64)(2067951531382569187U)), ((u64)(1292469707114105741U)), ((u64)(1615587133892632177U)), ((u64)(2019483917365790221U))}));
	_const_strconv__pow5_inv_split_32 = new_array_from_c_array(31, 31, sizeof(u64), _MOV((u64[31]){
		((u64)(576460752303423489U)), ((u64)(461168601842738791U)), ((u64)(368934881474191033U)), ((u64)(295147905179352826U)), ((u64)(472236648286964522U)), ((u64)(377789318629571618U)), ((u64)(302231454903657294U)), ((u64)(483570327845851670U)), ((u64)(386856262276681336U)), ((u64)(309485009821345069U)), ((u64)(495176015714152110U)), ((u64)(396140812571321688U)), ((u64)(316912650057057351U)), ((u64)(507060240091291761U)), ((u64)(405648192073033409U)), ((u64)(324518553658426727U)), ((u64)(519229685853482763U)), ((u64)(415383748682786211U)), ((u64)(332306998946228969U)), ((u64)(531691198313966350U)), ((u64)(425352958651173080U)), ((u64)(340282366920938464U)), ((u64)(544451787073501542U)), ((u64)(435561429658801234U)), ((u64)(348449143727040987U)), ((u64)(557518629963265579U)), ((u64)(446014903970612463U)), ((u64)(356811923176489971U)), ((u64)(570899077082383953U)), ((u64)(456719261665907162U)), ((u64)(365375409332725730U))}));
	_const_strconv__pow5_split_64 = new_array_from_c_array(326, 326, sizeof(strconv__Uint128), _MOV((strconv__Uint128[326]){
		(strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x0100000000000000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x0140000000000000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x0190000000000000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x01f4000000000000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x0138800000000000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x0186a00000000000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x01e8480000000000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x01312d0000000000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x017d784000000000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x01dcd65000000000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x012a05f200000000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x0174876e80000000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x01d1a94a20000000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x012309ce54000000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x016bcc41e9000000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x01c6bf5263400000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x011c37937e080000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x016345785d8a0000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x01bc16d674ec8000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x01158e460913d000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x015af1d78b58c400U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x01b1ae4d6e2ef500U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x010f0cf064dd5920U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x0152d02c7e14af68U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x01a784379d99db42U)),}, (strconv__Uint128){.lo = ((u64)(0x4000000000000000U)),.hi = ((u64)(0x0108b2a2c2802909U)),}, (strconv__Uint128){.lo = ((u64)(0x9000000000000000U)),.hi = ((u64)(0x014adf4b7320334bU)),}, (strconv__Uint128){.lo = ((u64)(0x7400000000000000U)),.hi = ((u64)(0x019d971e4fe8401eU)),}, (strconv__Uint128){.lo = ((u64)(0x0880000000000000U)),.hi = ((u64)(0x01027e72f1f12813U)),}, (strconv__Uint128){.lo = ((u64)(0xcaa0000000000000U)),.hi = ((u64)(0x01431e0fae6d7217U)),}, (strconv__Uint128){.lo = ((u64)(0xbd48000000000000U)),.hi = ((u64)(0x0193e5939a08ce9dU)),}, (strconv__Uint128){.lo = ((u64)(0x2c9a000000000000U)),.hi = ((u64)(0x01f8def8808b0245U)),}, (strconv__Uint128){.lo = ((u64)(0x3be0400000000000U)),.hi = ((u64)(0x013b8b5b5056e16bU)),}, (strconv__Uint128){.lo = ((u64)(0x0ad8500000000000U)),.hi = ((u64)(0x018a6e32246c99c6U)),}, (strconv__Uint128){.lo = ((u64)(0x8d8e640000000000U)),.hi = ((u64)(0x01ed09bead87c037U)),}, (strconv__Uint128){.lo = ((u64)(0xb878fe8000000000U)),.hi = ((u64)(0x013426172c74d822U)),}, (strconv__Uint128){.lo = ((u64)(0x66973e2000000000U)),.hi = ((u64)(0x01812f9cf7920e2bU)),}, (strconv__Uint128){.lo = ((u64)(0x403d0da800000000U)),.hi = ((u64)(0x01e17b84357691b6U)),}, (strconv__Uint128){.lo = ((u64)(0xe826288900000000U)),.hi = ((u64)(0x012ced32a16a1b11U)),}, (strconv__Uint128){.lo = ((u64)(0x622fb2ab40000000U)),.hi = ((u64)(0x0178287f49c4a1d6U)),}, (strconv__Uint128){.lo = ((u64)(0xfabb9f5610000000U)),.hi = ((u64)(0x01d6329f1c35ca4bU)),}, (strconv__Uint128){.lo = ((u64)(0x7cb54395ca000000U)),.hi = ((u64)(0x0125dfa371a19e6fU)),}, (strconv__Uint128){.lo = ((u64)(0x5be2947b3c800000U)),.hi = ((u64)(0x016f578c4e0a060bU)),}, (strconv__Uint128){.lo = ((u64)(0x32db399a0ba00000U)),.hi = ((u64)(0x01cb2d6f618c878eU)),}, (strconv__Uint128){.lo = ((u64)(0xdfc9040047440000U)),.hi = ((u64)(0x011efc659cf7d4b8U)),}, (strconv__Uint128){.lo = ((u64)(0x17bb450059150000U)),.hi = ((u64)(0x0166bb7f0435c9e7U)),}, (strconv__Uint128){.lo = ((u64)(0xddaa16406f5a4000U)),.hi = ((u64)(0x01c06a5ec5433c60U)),}, (strconv__Uint128){.lo = ((u64)(0x8a8a4de845986800U)),.hi = ((u64)(0x0118427b3b4a05bcU)),}, (strconv__Uint128){.lo = ((u64)(0xad2ce16256fe8200U)),.hi = ((u64)(0x015e531a0a1c872bU)),}, (strconv__Uint128){.lo = ((u64)(0x987819baecbe2280U)),.hi = ((u64)(0x01b5e7e08ca3a8f6U)),}, (strconv__Uint128){.lo = ((u64)(0x1f4b1014d3f6d590U)),.hi = ((u64)(0x0111b0ec57e6499aU)),}, (strconv__Uint128){.lo = ((u64)(0xa71dd41a08f48af4U)),.hi = ((u64)(0x01561d276ddfdc00U)),}, (strconv__Uint128){.lo = ((u64)(0xd0e549208b31adb1U)),.hi = ((u64)(0x01aba4714957d300U)),}, (strconv__Uint128){.lo = ((u64)(0x828f4db456ff0c8eU)),.hi = ((u64)(0x010b46c6cdd6e3e0U)),}, (strconv__Uint128){.lo = ((u64)(0xa33321216cbecfb2U)),.hi = ((u64)(0x014e1878814c9cd8U)),}, (strconv__Uint128){.lo = ((u64)(0xcbffe969c7ee839eU)),.hi = ((u64)(0x01a19e96a19fc40eU)),}, (strconv__Uint128){.lo = ((u64)(0x3f7ff1e21cf51243U)),.hi = ((u64)(0x0105031e2503da89U)),}, (strconv__Uint128){.lo = ((u64)(0x8f5fee5aa43256d4U)),.hi = ((u64)(0x014643e5ae44d12bU)),}, (strconv__Uint128){.lo = ((u64)(0x7337e9f14d3eec89U)),.hi = ((u64)(0x0197d4df19d60576U)),}, (strconv__Uint128){.lo = ((u64)(0x1005e46da08ea7abU)),.hi = ((u64)(0x01fdca16e04b86d4U)),}, (strconv__Uint128){.lo = ((u64)(0x8a03aec4845928cbU)),.hi = ((u64)(0x013e9e4e4c2f3444U)),}, (strconv__Uint128){.lo = ((u64)(0xac849a75a56f72fdU)),.hi = ((u64)(0x018e45e1df3b0155U)),}, (strconv__Uint128){.lo = ((u64)(0x17a5c1130ecb4fbdU)),.hi = ((u64)(0x01f1d75a5709c1abU)),}, (strconv__Uint128){.lo = ((u64)(0xeec798abe93f11d6U)),.hi = ((u64)(0x013726987666190aU)),}, (strconv__Uint128){.lo = ((u64)(0xaa797ed6e38ed64bU)),.hi = ((u64)(0x0184f03e93ff9f4dU)),}, (strconv__Uint128){.lo = ((u64)(0x1517de8c9c728bdeU)),.hi = ((u64)(0x01e62c4e38ff8721U)),}, (strconv__Uint128){.lo = ((u64)(0xad2eeb17e1c7976bU)),.hi = ((u64)(0x012fdbb0e39fb474U)),}, (strconv__Uint128){.lo = ((u64)(0xd87aa5ddda397d46U)),.hi = ((u64)(0x017bd29d1c87a191U)),}, (strconv__Uint128){.lo = ((u64)(0x4e994f5550c7dc97U)),.hi = ((u64)(0x01dac74463a989f6U)),}, (strconv__Uint128){.lo = ((u64)(0xf11fd195527ce9deU)),.hi = ((u64)(0x0128bc8abe49f639U)),}, (strconv__Uint128){.lo = ((u64)(0x6d67c5faa71c2456U)),.hi = ((u64)(0x0172ebad6ddc73c8U)),}, (strconv__Uint128){.lo = ((u64)(0x88c1b77950e32d6cU)),.hi = ((u64)(0x01cfa698c95390baU)),}, (strconv__Uint128){.lo = ((u64)(0x957912abd28dfc63U)),.hi = ((u64)(0x0121c81f7dd43a74U)),}, (strconv__Uint128){.lo = ((u64)(0xbad75756c7317b7cU)),.hi = ((u64)(0x016a3a275d494911U)),}, (strconv__Uint128){.lo = ((u64)(0x298d2d2c78fdda5bU)),.hi = ((u64)(0x01c4c8b1349b9b56U)),}, (strconv__Uint128){.lo = ((u64)(0xd9f83c3bcb9ea879U)),.hi = ((u64)(0x011afd6ec0e14115U)),}, (strconv__Uint128){.lo = ((u64)(0x50764b4abe865297U)),.hi = ((u64)(0x0161bcca7119915bU)),}, (strconv__Uint128){.lo = ((u64)(0x2493de1d6e27e73dU)),.hi = ((u64)(0x01ba2bfd0d5ff5b2U)),}, (strconv__Uint128){.lo = ((u64)(0x56dc6ad264d8f086U)),.hi = ((u64)(0x01145b7e285bf98fU)),}, (strconv__Uint128){.lo = ((u64)(0x2c938586fe0f2ca8U)),.hi = ((u64)(0x0159725db272f7f3U)),}, (strconv__Uint128){.lo = ((u64)(0xf7b866e8bd92f7d2U)),.hi = ((u64)(0x01afcef51f0fb5efU)),}, (strconv__Uint128){.lo = ((u64)(0xfad34051767bdae3U)),.hi = ((u64)(0x010de1593369d1b5U)),}, (strconv__Uint128){.lo = ((u64)(0x79881065d41ad19cU)),.hi = ((u64)(0x015159af80444623U)),}, (strconv__Uint128){.lo = ((u64)(0x57ea147f49218603U)),.hi = ((u64)(0x01a5b01b605557acU)),}, (strconv__Uint128){.lo = ((u64)(0xb6f24ccf8db4f3c1U)),.hi = ((u64)(0x01078e111c3556cbU)),}, (strconv__Uint128){.lo = ((u64)(0xa4aee003712230b2U)),.hi = ((u64)(0x014971956342ac7eU)),}, (strconv__Uint128){.lo = ((u64)(0x4dda98044d6abcdfU)),.hi = ((u64)(0x019bcdfabc13579eU)),}, (strconv__Uint128){.lo = ((u64)(0xf0a89f02b062b60bU)),.hi = ((u64)(0x010160bcb58c16c2U)),}, (strconv__Uint128){.lo = ((u64)(0xacd2c6c35c7b638eU)),.hi = ((u64)(0x0141b8ebe2ef1c73U)),}, (strconv__Uint128){.lo = ((u64)(0x98077874339a3c71U)),.hi = ((u64)(0x01922726dbaae390U)),}, (strconv__Uint128){.lo = ((u64)(0xbe0956914080cb8eU)),.hi = ((u64)(0x01f6b0f092959c74U)),}, (strconv__Uint128){.lo = ((u64)(0xf6c5d61ac8507f38U)),.hi = ((u64)(0x013a2e965b9d81c8U)),}, (strconv__Uint128){.lo = ((u64)(0x34774ba17a649f07U)),.hi = ((u64)(0x0188ba3bf284e23bU)),}, (strconv__Uint128){.lo = ((u64)(0x01951e89d8fdc6c8U)),.hi = ((u64)(0x01eae8caef261acaU)),}, (strconv__Uint128){.lo = ((u64)(0x40fd3316279e9c3dU)),.hi = ((u64)(0x0132d17ed577d0beU)),}, (strconv__Uint128){.lo = ((u64)(0xd13c7fdbb186434cU)),.hi = ((u64)(0x017f85de8ad5c4edU)),}, (strconv__Uint128){.lo = ((u64)(0x458b9fd29de7d420U)),.hi = ((u64)(0x01df67562d8b3629U)),}, (strconv__Uint128){.lo = ((u64)(0xcb7743e3a2b0e494U)),.hi = ((u64)(0x012ba095dc7701d9U)),}, (strconv__Uint128){.lo = ((u64)(0x3e5514dc8b5d1db9U)),.hi = ((u64)(0x017688bb5394c250U)),}, (strconv__Uint128){.lo = ((u64)(0x4dea5a13ae346527U)),.hi = ((u64)(0x01d42aea2879f2e4U)),}, (strconv__Uint128){.lo = ((u64)(0xb0b2784c4ce0bf38U)),.hi = ((u64)(0x01249ad2594c37ceU)),}, (strconv__Uint128){.lo = ((u64)(0x5cdf165f6018ef06U)),.hi = ((u64)(0x016dc186ef9f45c2U)),}, (strconv__Uint128){.lo = ((u64)(0xf416dbf7381f2ac8U)),.hi = ((u64)(0x01c931e8ab871732U)),}, (strconv__Uint128){.lo = ((u64)(0xd88e497a83137abdU)),.hi = ((u64)(0x011dbf316b346e7fU)),}, (strconv__Uint128){.lo = ((u64)(0xceb1dbd923d8596cU)),.hi = ((u64)(0x01652efdc6018a1fU)),}, (strconv__Uint128){.lo = ((u64)(0xc25e52cf6cce6fc7U)),.hi = ((u64)(0x01be7abd3781eca7U)),}, (strconv__Uint128){.lo = ((u64)(0xd97af3c1a40105dcU)),.hi = ((u64)(0x01170cb642b133e8U)),}, (strconv__Uint128){.lo = ((u64)(0x0fd9b0b20d014754U)),.hi = ((u64)(0x015ccfe3d35d80e3U)),}, (strconv__Uint128){.lo = ((u64)(0xd3d01cde90419929U)),.hi = ((u64)(0x01b403dcc834e11bU)),}, (strconv__Uint128){.lo = ((u64)(0x6462120b1a28ffb9U)),.hi = ((u64)(0x01108269fd210cb1U)),}, (strconv__Uint128){.lo = ((u64)(0xbd7a968de0b33fa8U)),.hi = ((u64)(0x0154a3047c694fddU)),}, (strconv__Uint128){.lo = ((u64)(0x2cd93c3158e00f92U)),.hi = ((u64)(0x01a9cbc59b83a3d5U)),}, (strconv__Uint128){.lo = ((u64)(0x3c07c59ed78c09bbU)),.hi = ((u64)(0x010a1f5b81324665U)),}, (strconv__Uint128){.lo = ((u64)(0x8b09b7068d6f0c2aU)),.hi = ((u64)(0x014ca732617ed7feU)),}, (strconv__Uint128){.lo = ((u64)(0x2dcc24c830cacf34U)),.hi = ((u64)(0x019fd0fef9de8dfeU)),}, (strconv__Uint128){.lo = ((u64)(0xdc9f96fd1e7ec180U)),.hi = ((u64)(0x0103e29f5c2b18beU)),}, (strconv__Uint128){.lo = ((u64)(0x93c77cbc661e71e1U)),.hi = ((u64)(0x0144db473335deeeU)),}, (strconv__Uint128){.lo = ((u64)(0x38b95beb7fa60e59U)),.hi = ((u64)(0x01961219000356aaU)),}, (strconv__Uint128){.lo = ((u64)(0xc6e7b2e65f8f91efU)),.hi = ((u64)(0x01fb969f40042c54U)),}, (strconv__Uint128){.lo = ((u64)(0xfc50cfcffbb9bb35U)),.hi = ((u64)(0x013d3e2388029bb4U)),}, (strconv__Uint128){.lo = ((u64)(0x3b6503c3faa82a03U)),.hi = ((u64)(0x018c8dac6a0342a2U)),}, (strconv__Uint128){.lo = ((u64)(0xca3e44b4f9523484U)),.hi = ((u64)(0x01efb1178484134aU)),}, (strconv__Uint128){.lo = ((u64)(0xbe66eaf11bd360d2U)),.hi = ((u64)(0x0135ceaeb2d28c0eU)),}, (strconv__Uint128){.lo = ((u64)(0x6e00a5ad62c83907U)),.hi = ((u64)(0x0183425a5f872f12U)),}, (strconv__Uint128){.lo = ((u64)(0x0980cf18bb7a4749U)),.hi = ((u64)(0x01e412f0f768fad7U)),}, (strconv__Uint128){.lo = ((u64)(0x65f0816f752c6c8dU)),.hi = ((u64)(0x012e8bd69aa19cc6U)),}, (strconv__Uint128){.lo = ((u64)(0xff6ca1cb527787b1U)),.hi = ((u64)(0x017a2ecc414a03f7U)),}, (strconv__Uint128){.lo = ((u64)(0xff47ca3e2715699dU)),.hi = ((u64)(0x01d8ba7f519c84f5U)),}, (strconv__Uint128){.lo = ((u64)(0xbf8cde66d86d6202U)),.hi = ((u64)(0x0127748f9301d319U)),}, (strconv__Uint128){.lo = ((u64)(0x2f7016008e88ba83U)),.hi = ((u64)(0x017151b377c247e0U)),}, (strconv__Uint128){.lo = ((u64)(0x3b4c1b80b22ae923U)),.hi = ((u64)(0x01cda62055b2d9d8U)),}, (strconv__Uint128){.lo = ((u64)(0x250f91306f5ad1b6U)),.hi = ((u64)(0x012087d4358fc827U)),}, (strconv__Uint128){.lo = ((u64)(0xee53757c8b318623U)),.hi = ((u64)(0x0168a9c942f3ba30U)),}, (strconv__Uint128){.lo = ((u64)(0x29e852dbadfde7acU)),.hi = ((u64)(0x01c2d43b93b0a8bdU)),}, (strconv__Uint128){.lo = ((u64)(0x3a3133c94cbeb0ccU)),.hi = ((u64)(0x0119c4a53c4e6976U)),}, (strconv__Uint128){.lo = ((u64)(0xc8bd80bb9fee5cffU)),.hi = ((u64)(0x016035ce8b6203d3U)),}, (strconv__Uint128){.lo = ((u64)(0xbaece0ea87e9f43eU)),.hi = ((u64)(0x01b843422e3a84c8U)),}, (strconv__Uint128){.lo = ((u64)(0x74d40c9294f238a7U)),.hi = ((u64)(0x01132a095ce492fdU)),}, (strconv__Uint128){.lo = ((u64)(0xd2090fb73a2ec6d1U)),.hi = ((u64)(0x0157f48bb41db7bcU)),}, (strconv__Uint128){.lo = ((u64)(0x068b53a508ba7885U)),.hi = ((u64)(0x01adf1aea12525acU)),}, (strconv__Uint128){.lo = ((u64)(0x8417144725748b53U)),.hi = ((u64)(0x010cb70d24b7378bU)),}, (strconv__Uint128){.lo = ((u64)(0x651cd958eed1ae28U)),.hi = ((u64)(0x014fe4d06de5056eU)),}, (strconv__Uint128){.lo = ((u64)(0xfe640faf2a8619b2U)),.hi = ((u64)(0x01a3de04895e46c9U)),}, (strconv__Uint128){.lo = ((u64)(0x3efe89cd7a93d00fU)),.hi = ((u64)(0x01066ac2d5daec3eU)),}, (strconv__Uint128){.lo = ((u64)(0xcebe2c40d938c413U)),.hi = ((u64)(0x014805738b51a74dU)),}, (strconv__Uint128){.lo = ((u64)(0x426db7510f86f518U)),.hi = ((u64)(0x019a06d06e261121U)),}, (strconv__Uint128){.lo = ((u64)(0xc9849292a9b4592fU)),.hi = ((u64)(0x0100444244d7cab4U)),}, (strconv__Uint128){.lo = ((u64)(0xfbe5b73754216f7aU)),.hi = ((u64)(0x01405552d60dbd61U)),}, (strconv__Uint128){.lo = ((u64)(0x7adf25052929cb59U)),.hi = ((u64)(0x01906aa78b912cbaU)),}, (strconv__Uint128){.lo = ((u64)(0x1996ee4673743e2fU)),.hi = ((u64)(0x01f485516e7577e9U)),}, (strconv__Uint128){.lo = ((u64)(0xaffe54ec0828a6ddU)),.hi = ((u64)(0x0138d352e5096af1U)),}, (strconv__Uint128){.lo = ((u64)(0x1bfdea270a32d095U)),.hi = ((u64)(0x018708279e4bc5aeU)),}, (strconv__Uint128){.lo = ((u64)(0xa2fd64b0ccbf84baU)),.hi = ((u64)(0x01e8ca3185deb719U)),}, (strconv__Uint128){.lo = ((u64)(0x05de5eee7ff7b2f4U)),.hi = ((u64)(0x01317e5ef3ab3270U)),}, (strconv__Uint128){.lo = ((u64)(0x0755f6aa1ff59fb1U)),.hi = ((u64)(0x017dddf6b095ff0cU)),}, (strconv__Uint128){.lo = ((u64)(0x092b7454a7f3079eU)),.hi = ((u64)(0x01dd55745cbb7ecfU)),}, (strconv__Uint128){.lo = ((u64)(0x65bb28b4e8f7e4c3U)),.hi = ((u64)(0x012a5568b9f52f41U)),}, (strconv__Uint128){.lo = ((u64)(0xbf29f2e22335ddf3U)),.hi = ((u64)(0x0174eac2e8727b11U)),}, (strconv__Uint128){.lo = ((u64)(0x2ef46f9aac035570U)),.hi = ((u64)(0x01d22573a28f19d6U)),}, (strconv__Uint128){.lo = ((u64)(0xdd58c5c0ab821566U)),.hi = ((u64)(0x0123576845997025U)),}, (strconv__Uint128){.lo = ((u64)(0x54aef730d6629ac0U)),.hi = ((u64)(0x016c2d4256ffcc2fU)),}, (strconv__Uint128){.lo = ((u64)(0x29dab4fd0bfb4170U)),.hi = ((u64)(0x01c73892ecbfbf3bU)),}, (strconv__Uint128){.lo = ((u64)(0xfa28b11e277d08e6U)),.hi = ((u64)(0x011c835bd3f7d784U)),}, (strconv__Uint128){.lo = ((u64)(0x38b2dd65b15c4b1fU)),.hi = ((u64)(0x0163a432c8f5cd66U)),}, (strconv__Uint128){.lo = ((u64)(0xc6df94bf1db35de7U)),.hi = ((u64)(0x01bc8d3f7b3340bfU)),}, (strconv__Uint128){.lo = ((u64)(0xdc4bbcf772901ab0U)),.hi = ((u64)(0x0115d847ad000877U)),}, (strconv__Uint128){.lo = ((u64)(0xd35eac354f34215cU)),.hi = ((u64)(0x015b4e5998400a95U)),}, (strconv__Uint128){.lo = ((u64)(0x48365742a30129b4U)),.hi = ((u64)(0x01b221effe500d3bU)),}, (strconv__Uint128){.lo = ((u64)(0x0d21f689a5e0ba10U)),.hi = ((u64)(0x010f5535fef20845U)),}, (strconv__Uint128){.lo = ((u64)(0x506a742c0f58e894U)),.hi = ((u64)(0x01532a837eae8a56U)),}, (strconv__Uint128){.lo = ((u64)(0xe4851137132f22b9U)),.hi = ((u64)(0x01a7f5245e5a2cebU)),}, (strconv__Uint128){.lo = ((u64)(0x6ed32ac26bfd75b4U)),.hi = ((u64)(0x0108f936baf85c13U)),}, (strconv__Uint128){.lo = ((u64)(0x4a87f57306fcd321U)),.hi = ((u64)(0x014b378469b67318U)),}, (strconv__Uint128){.lo = ((u64)(0x5d29f2cfc8bc07e9U)),.hi = ((u64)(0x019e056584240fdeU)),}, (strconv__Uint128){.lo = ((u64)(0xfa3a37c1dd7584f1U)),.hi = ((u64)(0x0102c35f729689eaU)),}, (strconv__Uint128){.lo = ((u64)(0xb8c8c5b254d2e62eU)),.hi = ((u64)(0x014374374f3c2c65U)),}, (strconv__Uint128){.lo = ((u64)(0x26faf71eea079fb9U)),.hi = ((u64)(0x01945145230b377fU)),}, (strconv__Uint128){.lo = ((u64)(0xf0b9b4e6a48987a8U)),.hi = ((u64)(0x01f965966bce055eU)),}, (strconv__Uint128){.lo = ((u64)(0x5674111026d5f4c9U)),.hi = ((u64)(0x013bdf7e0360c35bU)),}, (strconv__Uint128){.lo = ((u64)(0x2c111554308b71fbU)),.hi = ((u64)(0x018ad75d8438f432U)),}, (strconv__Uint128){.lo = ((u64)(0xb7155aa93cae4e7aU)),.hi = ((u64)(0x01ed8d34e547313eU)),}, (strconv__Uint128){.lo = ((u64)(0x326d58a9c5ecf10cU)),.hi = ((u64)(0x013478410f4c7ec7U)),}, (strconv__Uint128){.lo = ((u64)(0xff08aed437682d4fU)),.hi = ((u64)(0x01819651531f9e78U)),}, (strconv__Uint128){.lo = ((u64)(0x3ecada89454238a3U)),.hi = ((u64)(0x01e1fbe5a7e78617U)),}, (strconv__Uint128){.lo = ((u64)(0x873ec895cb496366U)),.hi = ((u64)(0x012d3d6f88f0b3ceU)),}, (strconv__Uint128){.lo = ((u64)(0x290e7abb3e1bbc3fU)),.hi = ((u64)(0x01788ccb6b2ce0c2U)),}, (strconv__Uint128){.lo = ((u64)(0xb352196a0da2ab4fU)),.hi = ((u64)(0x01d6affe45f818f2U)),}, (strconv__Uint128){.lo = ((u64)(0xb0134fe24885ab11U)),.hi = ((u64)(0x01262dfeebbb0f97U)),}, (strconv__Uint128){.lo = ((u64)(0x9c1823dadaa715d6U)),.hi = ((u64)(0x016fb97ea6a9d37dU)),}, (strconv__Uint128){.lo = ((u64)(0x031e2cd19150db4bU)),.hi = ((u64)(0x01cba7de5054485dU)),}, (strconv__Uint128){.lo = ((u64)(0x21f2dc02fad2890fU)),.hi = ((u64)(0x011f48eaf234ad3aU)),}, (strconv__Uint128){.lo = ((u64)(0xaa6f9303b9872b53U)),.hi = ((u64)(0x01671b25aec1d888U)),}, (strconv__Uint128){.lo = ((u64)(0xd50b77c4a7e8f628U)),.hi = ((u64)(0x01c0e1ef1a724eaaU)),}, (strconv__Uint128){.lo = ((u64)(0xc5272adae8f199d9U)),.hi = ((u64)(0x01188d357087712aU)),}, (strconv__Uint128){.lo = ((u64)(0x7670f591a32e004fU)),.hi = ((u64)(0x015eb082cca94d75U)),}, (strconv__Uint128){.lo = ((u64)(0xd40d32f60bf98063U)),.hi = ((u64)(0x01b65ca37fd3a0d2U)),}, (strconv__Uint128){.lo = ((u64)(0xc4883fd9c77bf03eU)),.hi = ((u64)(0x0111f9e62fe44483U)),}, (strconv__Uint128){.lo = ((u64)(0xb5aa4fd0395aec4dU)),.hi = ((u64)(0x0156785fbbdd55a4U)),}, (strconv__Uint128){.lo = ((u64)(0xe314e3c447b1a760U)),.hi = ((u64)(0x01ac1677aad4ab0dU)),}, (strconv__Uint128){.lo = ((u64)(0xaded0e5aaccf089cU)),.hi = ((u64)(0x010b8e0acac4eae8U)),}, (strconv__Uint128){.lo = ((u64)(0xd96851f15802cac3U)),.hi = ((u64)(0x014e718d7d7625a2U)),}, (strconv__Uint128){.lo = ((u64)(0x8fc2666dae037d74U)),.hi = ((u64)(0x01a20df0dcd3af0bU)),}, (strconv__Uint128){.lo = ((u64)(0x39d980048cc22e68U)),.hi = ((u64)(0x010548b68a044d67U)),}, (strconv__Uint128){.lo = ((u64)(0x084fe005aff2ba03U)),.hi = ((u64)(0x01469ae42c8560c1U)),}, (strconv__Uint128){.lo = ((u64)(0x4a63d8071bef6883U)),.hi = ((u64)(0x0198419d37a6b8f1U)),}, (strconv__Uint128){.lo = ((u64)(0x9cfcce08e2eb42a4U)),.hi = ((u64)(0x01fe52048590672dU)),}, (strconv__Uint128){.lo = ((u64)(0x821e00c58dd309a7U)),.hi = ((u64)(0x013ef342d37a407cU)),}, (strconv__Uint128){.lo = ((u64)(0xa2a580f6f147cc10U)),.hi = ((u64)(0x018eb0138858d09bU)),}, (strconv__Uint128){.lo = ((u64)(0x8b4ee134ad99bf15U)),.hi = ((u64)(0x01f25c186a6f04c2U)),}, (strconv__Uint128){.lo = ((u64)(0x97114cc0ec80176dU)),.hi = ((u64)(0x0137798f428562f9U)),}, (strconv__Uint128){.lo = ((u64)(0xfcd59ff127a01d48U)),.hi = ((u64)(0x018557f31326bbb7U)),}, (strconv__Uint128){.lo = ((u64)(0xfc0b07ed7188249aU)),.hi = ((u64)(0x01e6adefd7f06aa5U)),}, (strconv__Uint128){.lo = ((u64)(0xbd86e4f466f516e0U)),.hi = ((u64)(0x01302cb5e6f642a7U)),}, (strconv__Uint128){.lo = ((u64)(0xace89e3180b25c98U)),.hi = ((u64)(0x017c37e360b3d351U)),}, (strconv__Uint128){.lo = ((u64)(0x1822c5bde0def3beU)),.hi = ((u64)(0x01db45dc38e0c826U)),}, (strconv__Uint128){.lo = ((u64)(0xcf15bb96ac8b5857U)),.hi = ((u64)(0x01290ba9a38c7d17U)),}, (strconv__Uint128){.lo = ((u64)(0xc2db2a7c57ae2e6dU)),.hi = ((u64)(0x01734e940c6f9c5dU)),}, (strconv__Uint128){.lo = ((u64)(0x3391f51b6d99ba08U)),.hi = ((u64)(0x01d022390f8b8375U)),}, (strconv__Uint128){.lo = ((u64)(0x403b393124801445U)),.hi = ((u64)(0x01221563a9b73229U)),}, (strconv__Uint128){.lo = ((u64)(0x904a077d6da01956U)),.hi = ((u64)(0x016a9abc9424feb3U)),}, (strconv__Uint128){.lo = ((u64)(0x745c895cc9081facU)),.hi = ((u64)(0x01c5416bb92e3e60U)),}, (strconv__Uint128){.lo = ((u64)(0x48b9d5d9fda513cbU)),.hi = ((u64)(0x011b48e353bce6fcU)),}, (strconv__Uint128){.lo = ((u64)(0x5ae84b507d0e58beU)),.hi = ((u64)(0x01621b1c28ac20bbU)),}, (strconv__Uint128){.lo = ((u64)(0x31a25e249c51eeeeU)),.hi = ((u64)(0x01baa1e332d728eaU)),}, (strconv__Uint128){.lo = ((u64)(0x5f057ad6e1b33554U)),.hi = ((u64)(0x0114a52dffc67992U)),}, (strconv__Uint128){.lo = ((u64)(0xf6c6d98c9a2002aaU)),.hi = ((u64)(0x0159ce797fb817f6U)),}, (strconv__Uint128){.lo = ((u64)(0xb4788fefc0a80354U)),.hi = ((u64)(0x01b04217dfa61df4U)),}, (strconv__Uint128){.lo = ((u64)(0xf0cb59f5d8690214U)),.hi = ((u64)(0x010e294eebc7d2b8U)),}, (strconv__Uint128){.lo = ((u64)(0x2cfe30734e83429aU)),.hi = ((u64)(0x0151b3a2a6b9c767U)),}, (strconv__Uint128){.lo = ((u64)(0xf83dbc9022241340U)),.hi = ((u64)(0x01a6208b50683940U)),}, (strconv__Uint128){.lo = ((u64)(0x9b2695da15568c08U)),.hi = ((u64)(0x0107d457124123c8U)),}, (strconv__Uint128){.lo = ((u64)(0xc1f03b509aac2f0aU)),.hi = ((u64)(0x0149c96cd6d16cbaU)),}, (strconv__Uint128){.lo = ((u64)(0x726c4a24c1573acdU)),.hi = ((u64)(0x019c3bc80c85c7e9U)),}, (strconv__Uint128){.lo = ((u64)(0xe783ae56f8d684c0U)),.hi = ((u64)(0x0101a55d07d39cf1U)),}, (strconv__Uint128){.lo = ((u64)(0x616499ecb70c25f0U)),.hi = ((u64)(0x01420eb449c8842eU)),}, (strconv__Uint128){.lo = ((u64)(0xf9bdc067e4cf2f6cU)),.hi = ((u64)(0x019292615c3aa539U)),}, (strconv__Uint128){.lo = ((u64)(0x782d3081de02fb47U)),.hi = ((u64)(0x01f736f9b3494e88U)),}, (strconv__Uint128){.lo = ((u64)(0x4b1c3e512ac1dd0cU)),.hi = ((u64)(0x013a825c100dd115U)),}, (strconv__Uint128){.lo = ((u64)(0x9de34de57572544fU)),.hi = ((u64)(0x018922f31411455aU)),}, (strconv__Uint128){.lo = ((u64)(0x455c215ed2cee963U)),.hi = ((u64)(0x01eb6bafd91596b1U)),}, (strconv__Uint128){.lo = ((u64)(0xcb5994db43c151deU)),.hi = ((u64)(0x0133234de7ad7e2eU)),}, (strconv__Uint128){.lo = ((u64)(0x7e2ffa1214b1a655U)),.hi = ((u64)(0x017fec216198ddbaU)),}, (strconv__Uint128){.lo = ((u64)(0x1dbbf89699de0febU)),.hi = ((u64)(0x01dfe729b9ff1529U)),}, (strconv__Uint128){.lo = ((u64)(0xb2957b5e202ac9f3U)),.hi = ((u64)(0x012bf07a143f6d39U)),}, (strconv__Uint128){.lo = ((u64)(0x1f3ada35a8357c6fU)),.hi = ((u64)(0x0176ec98994f4888U)),}, (strconv__Uint128){.lo = ((u64)(0x270990c31242db8bU)),.hi = ((u64)(0x01d4a7bebfa31aaaU)),}, (strconv__Uint128){.lo = ((u64)(0x5865fa79eb69c937U)),.hi = ((u64)(0x0124e8d737c5f0aaU)),}, (strconv__Uint128){.lo = ((u64)(0xee7f791866443b85U)),.hi = ((u64)(0x016e230d05b76cd4U)),}, (strconv__Uint128){.lo = ((u64)(0x2a1f575e7fd54a66U)),.hi = ((u64)(0x01c9abd04725480aU)),}, (strconv__Uint128){.lo = ((u64)(0x5a53969b0fe54e80U)),.hi = ((u64)(0x011e0b622c774d06U)),}, (strconv__Uint128){.lo = ((u64)(0xf0e87c41d3dea220U)),.hi = ((u64)(0x01658e3ab7952047U)),}, (strconv__Uint128){.lo = ((u64)(0xed229b5248d64aa8U)),.hi = ((u64)(0x01bef1c9657a6859U)),}, (strconv__Uint128){.lo = ((u64)(0x3435a1136d85eea9U)),.hi = ((u64)(0x0117571ddf6c8138U)),}, (strconv__Uint128){.lo = ((u64)(0x4143095848e76a53U)),.hi = ((u64)(0x015d2ce55747a186U)),}, (strconv__Uint128){.lo = ((u64)(0xd193cbae5b2144e8U)),.hi = ((u64)(0x01b4781ead1989e7U)),}, (strconv__Uint128){.lo = ((u64)(0xe2fc5f4cf8f4cb11U)),.hi = ((u64)(0x0110cb132c2ff630U)),}, (strconv__Uint128){.lo = ((u64)(0x1bbb77203731fdd5U)),.hi = ((u64)(0x0154fdd7f73bf3bdU)),}, (strconv__Uint128){.lo = ((u64)(0x62aa54e844fe7d4aU)),.hi = ((u64)(0x01aa3d4df50af0acU)),}, (strconv__Uint128){.lo = ((u64)(0xbdaa75112b1f0e4eU)),.hi = ((u64)(0x010a6650b926d66bU)),}, (strconv__Uint128){.lo = ((u64)(0xad15125575e6d1e2U)),.hi = ((u64)(0x014cffe4e7708c06U)),}, (strconv__Uint128){.lo = ((u64)(0x585a56ead360865bU)),.hi = ((u64)(0x01a03fde214caf08U)),}, (strconv__Uint128){.lo = ((u64)(0x37387652c41c53f8U)),.hi = ((u64)(0x010427ead4cfed65U)),}, (strconv__Uint128){.lo = ((u64)(0x850693e7752368f7U)),.hi = ((u64)(0x014531e58a03e8beU)),}, (strconv__Uint128){.lo = ((u64)(0x264838e1526c4334U)),.hi = ((u64)(0x01967e5eec84e2eeU)),}, (strconv__Uint128){.lo = ((u64)(0xafda4719a7075402U)),.hi = ((u64)(0x01fc1df6a7a61ba9U)),}, (strconv__Uint128){.lo = ((u64)(0x0de86c7008649481U)),.hi = ((u64)(0x013d92ba28c7d14aU)),}, (strconv__Uint128){.lo = ((u64)(0x9162878c0a7db9a1U)),.hi = ((u64)(0x018cf768b2f9c59cU)),}, (strconv__Uint128){.lo = ((u64)(0xb5bb296f0d1d280aU)),.hi = ((u64)(0x01f03542dfb83703U)),}, (strconv__Uint128){.lo = ((u64)(0x5194f9e568323906U)),.hi = ((u64)(0x01362149cbd32262U)),}, (strconv__Uint128){.lo = ((u64)(0xe5fa385ec23ec747U)),.hi = ((u64)(0x0183a99c3ec7eafaU)),}, (strconv__Uint128){.lo = ((u64)(0x9f78c67672ce7919U)),.hi = ((u64)(0x01e494034e79e5b9U)),}, (strconv__Uint128){.lo = ((u64)(0x03ab7c0a07c10bb0U)),.hi = ((u64)(0x012edc82110c2f94U)),}, (strconv__Uint128){.lo = ((u64)(0x04965b0c89b14e9cU)),.hi = ((u64)(0x017a93a2954f3b79U)),}, (strconv__Uint128){.lo = ((u64)(0x45bbf1cfac1da243U)),.hi = ((u64)(0x01d9388b3aa30a57U)),}, (strconv__Uint128){.lo = ((u64)(0x8b957721cb92856aU)),.hi = ((u64)(0x0127c35704a5e676U)),}, (strconv__Uint128){.lo = ((u64)(0x2e7ad4ea3e7726c4U)),.hi = ((u64)(0x0171b42cc5cf6014U)),}, (strconv__Uint128){.lo = ((u64)(0x3a198a24ce14f075U)),.hi = ((u64)(0x01ce2137f7433819U)),}, (strconv__Uint128){.lo = ((u64)(0xc44ff65700cd1649U)),.hi = ((u64)(0x0120d4c2fa8a030fU)),}, (strconv__Uint128){.lo = ((u64)(0xb563f3ecc1005bdbU)),.hi = ((u64)(0x016909f3b92c83d3U)),}, (strconv__Uint128){.lo = ((u64)(0xa2bcf0e7f14072d2U)),.hi = ((u64)(0x01c34c70a777a4c8U)),}, (strconv__Uint128){.lo = ((u64)(0x65b61690f6c847c3U)),.hi = ((u64)(0x011a0fc668aac6fdU)),}, (strconv__Uint128){.lo = ((u64)(0xbf239c35347a59b4U)),.hi = ((u64)(0x016093b802d578bcU)),}, (strconv__Uint128){.lo = ((u64)(0xeeec83428198f021U)),.hi = ((u64)(0x01b8b8a6038ad6ebU)),}, (strconv__Uint128){.lo = ((u64)(0x7553d20990ff9615U)),.hi = ((u64)(0x01137367c236c653U)),}, (strconv__Uint128){.lo = ((u64)(0x52a8c68bf53f7b9aU)),.hi = ((u64)(0x01585041b2c477e8U)),}, (strconv__Uint128){.lo = ((u64)(0x6752f82ef28f5a81U)),.hi = ((u64)(0x01ae64521f7595e2U)),}, (strconv__Uint128){.lo = ((u64)(0x8093db1d57999890U)),.hi = ((u64)(0x010cfeb353a97dadU)),}, (strconv__Uint128){.lo = ((u64)(0xe0b8d1e4ad7ffeb4U)),.hi = ((u64)(0x01503e602893dd18U)),}, (strconv__Uint128){.lo = ((u64)(0x18e7065dd8dffe62U)),.hi = ((u64)(0x01a44df832b8d45fU)),}, (strconv__Uint128){.lo = ((u64)(0x6f9063faa78bfefdU)),.hi = ((u64)(0x0106b0bb1fb384bbU)),}, (strconv__Uint128){.lo = ((u64)(0x4b747cf9516efebcU)),.hi = ((u64)(0x01485ce9e7a065eaU)),}, (strconv__Uint128){.lo = ((u64)(0xde519c37a5cabe6bU)),.hi = ((u64)(0x019a742461887f64U)),}, (strconv__Uint128){.lo = ((u64)(0x0af301a2c79eb703U)),.hi = ((u64)(0x01008896bcf54f9fU)),}, (strconv__Uint128){.lo = ((u64)(0xcdafc20b798664c4U)),.hi = ((u64)(0x0140aabc6c32a386U)),}, (strconv__Uint128){.lo = ((u64)(0x811bb28e57e7fdf5U)),.hi = ((u64)(0x0190d56b873f4c68U)),}, (strconv__Uint128){.lo = ((u64)(0xa1629f31ede1fd72U)),.hi = ((u64)(0x01f50ac6690f1f82U)),}, (strconv__Uint128){.lo = ((u64)(0xa4dda37f34ad3e67U)),.hi = ((u64)(0x013926bc01a973b1U)),}, (strconv__Uint128){.lo = ((u64)(0x0e150c5f01d88e01U)),.hi = ((u64)(0x0187706b0213d09eU)),}, (strconv__Uint128){.lo = ((u64)(0x919a4f76c24eb181U)),.hi = ((u64)(0x01e94c85c298c4c5U)),}, (strconv__Uint128){.lo = ((u64)(0x7b0071aa39712ef1U)),.hi = ((u64)(0x0131cfd3999f7afbU)),}, (strconv__Uint128){.lo = ((u64)(0x59c08e14c7cd7aadU)),.hi = ((u64)(0x017e43c8800759baU)),}, (strconv__Uint128){.lo = ((u64)(0xf030b199f9c0d958U)),.hi = ((u64)(0x01ddd4baa0093028U)),}, (strconv__Uint128){.lo = ((u64)(0x961e6f003c1887d7U)),.hi = ((u64)(0x012aa4f4a405be19U)),}, (strconv__Uint128){.lo = ((u64)(0xfba60ac04b1ea9cdU)),.hi = ((u64)(0x01754e31cd072d9fU)),}, (strconv__Uint128){.lo = ((u64)(0xfa8f8d705de65440U)),.hi = ((u64)(0x01d2a1be4048f907U)),}, (strconv__Uint128){.lo = ((u64)(0xfc99b8663aaff4a8U)),.hi = ((u64)(0x0123a516e82d9ba4U)),}, (strconv__Uint128){.lo = ((u64)(0x3bc0267fc95bf1d2U)),.hi = ((u64)(0x016c8e5ca239028eU)),}, (strconv__Uint128){.lo = ((u64)(0xcab0301fbbb2ee47U)),.hi = ((u64)(0x01c7b1f3cac74331U)),}, (strconv__Uint128){.lo = ((u64)(0x1eae1e13d54fd4ecU)),.hi = ((u64)(0x011ccf385ebc89ffU)),}, (strconv__Uint128){.lo = ((u64)(0xe659a598caa3ca27U)),.hi = ((u64)(0x01640306766bac7eU)),}, (strconv__Uint128){.lo = ((u64)(0x9ff00efefd4cbcb1U)),.hi = ((u64)(0x01bd03c81406979eU)),}, (strconv__Uint128){.lo = ((u64)(0x23f6095f5e4ff5efU)),.hi = ((u64)(0x0116225d0c841ec3U)),}, (strconv__Uint128){.lo = ((u64)(0xecf38bb735e3f36aU)),.hi = ((u64)(0x015baaf44fa52673U)),}, (strconv__Uint128){.lo = ((u64)(0xe8306ea5035cf045U)),.hi = ((u64)(0x01b295b1638e7010U)),}, (strconv__Uint128){.lo = ((u64)(0x911e4527221a162bU)),.hi = ((u64)(0x010f9d8ede39060aU)),}, (strconv__Uint128){.lo = ((u64)(0x3565d670eaa09bb6U)),.hi = ((u64)(0x015384f295c7478dU)),}, (strconv__Uint128){.lo = ((u64)(0x82bf4c0d2548c2a3U)),.hi = ((u64)(0x01a8662f3b391970U)),}, (strconv__Uint128){.lo = ((u64)(0x51b78f88374d79a6U)),.hi = ((u64)(0x01093fdd8503afe6U)),}, (strconv__Uint128){.lo = ((u64)(0xe625736a4520d810U)),.hi = ((u64)(0x014b8fd4e6449bdfU)),}, (strconv__Uint128){.lo = ((u64)(0xdfaed044d6690e14U)),.hi = ((u64)(0x019e73ca1fd5c2d7U)),}, (strconv__Uint128){.lo = ((u64)(0xebcd422b0601a8ccU)),.hi = ((u64)(0x0103085e53e599c6U)),}, (strconv__Uint128){.lo = ((u64)(0xa6c092b5c78212ffU)),.hi = ((u64)(0x0143ca75e8df0038U)),}, (strconv__Uint128){.lo = ((u64)(0xd070b763396297bfU)),.hi = ((u64)(0x0194bd136316c046U)),}, (strconv__Uint128){.lo = ((u64)(0x848ce53c07bb3dafU)),.hi = ((u64)(0x01f9ec583bdc7058U)),}, (strconv__Uint128){.lo = ((u64)(0x52d80f4584d5068dU)),.hi = ((u64)(0x013c33b72569c637U)),}, (strconv__Uint128){.lo = ((u64)(0x278e1316e60a4831U)),.hi = ((u64)(0x018b40a4eec437c5U)),}}));
	_const_strconv__pow5_inv_split_64 = new_array_from_c_array(292, 292, sizeof(strconv__Uint128), _MOV((strconv__Uint128[292]){
		(strconv__Uint128){.lo = ((u64)(0x0000000000000001U)),.hi = ((u64)(0x0400000000000000U)),}, (strconv__Uint128){.lo = ((u64)(0x3333333333333334U)),.hi = ((u64)(0x0333333333333333U)),}, (strconv__Uint128){.lo = ((u64)(0x28f5c28f5c28f5c3U)),.hi = ((u64)(0x028f5c28f5c28f5cU)),}, (strconv__Uint128){.lo = ((u64)(0xed916872b020c49cU)),.hi = ((u64)(0x020c49ba5e353f7cU)),}, (strconv__Uint128){.lo = ((u64)(0xaf4f0d844d013a93U)),.hi = ((u64)(0x0346dc5d63886594U)),}, (strconv__Uint128){.lo = ((u64)(0x8c3f3e0370cdc876U)),.hi = ((u64)(0x029f16b11c6d1e10U)),}, (strconv__Uint128){.lo = ((u64)(0xd698fe69270b06c5U)),.hi = ((u64)(0x0218def416bdb1a6U)),}, (strconv__Uint128){.lo = ((u64)(0xf0f4ca41d811a46eU)),.hi = ((u64)(0x035afe535795e90aU)),}, (strconv__Uint128){.lo = ((u64)(0xf3f70834acdae9f1U)),.hi = ((u64)(0x02af31dc4611873bU)),}, (strconv__Uint128){.lo = ((u64)(0x5cc5a02a23e254c1U)),.hi = ((u64)(0x0225c17d04dad296U)),}, (strconv__Uint128){.lo = ((u64)(0xfad5cd10396a2135U)),.hi = ((u64)(0x036f9bfb3af7b756U)),}, (strconv__Uint128){.lo = ((u64)(0xfbde3da69454e75eU)),.hi = ((u64)(0x02bfaffc2f2c92abU)),}, (strconv__Uint128){.lo = ((u64)(0x2fe4fe1edd10b918U)),.hi = ((u64)(0x0232f33025bd4223U)),}, (strconv__Uint128){.lo = ((u64)(0x4ca19697c81ac1bfU)),.hi = ((u64)(0x0384b84d092ed038U)),}, (strconv__Uint128){.lo = ((u64)(0x3d4e1213067bce33U)),.hi = ((u64)(0x02d09370d4257360U)),}, (strconv__Uint128){.lo = ((u64)(0x643e74dc052fd829U)),.hi = ((u64)(0x024075f3dceac2b3U)),}, (strconv__Uint128){.lo = ((u64)(0x6d30baf9a1e626a7U)),.hi = ((u64)(0x039a5652fb113785U)),}, (strconv__Uint128){.lo = ((u64)(0x2426fbfae7eb5220U)),.hi = ((u64)(0x02e1dea8c8da92d1U)),}, (strconv__Uint128){.lo = ((u64)(0x1cebfcc8b9890e80U)),.hi = ((u64)(0x024e4bba3a487574U)),}, (strconv__Uint128){.lo = ((u64)(0x94acc7a78f41b0ccU)),.hi = ((u64)(0x03b07929f6da5586U)),}, (strconv__Uint128){.lo = ((u64)(0xaa23d2ec729af3d7U)),.hi = ((u64)(0x02f394219248446bU)),}, (strconv__Uint128){.lo = ((u64)(0xbb4fdbf05baf2979U)),.hi = ((u64)(0x025c768141d369efU)),}, (strconv__Uint128){.lo = ((u64)(0xc54c931a2c4b758dU)),.hi = ((u64)(0x03c7240202ebdcb2U)),}, (strconv__Uint128){.lo = ((u64)(0x9dd6dc14f03c5e0bU)),.hi = ((u64)(0x0305b66802564a28U)),}, (strconv__Uint128){.lo = ((u64)(0x4b1249aa59c9e4d6U)),.hi = ((u64)(0x026af8533511d4edU)),}, (strconv__Uint128){.lo = ((u64)(0x44ea0f76f60fd489U)),.hi = ((u64)(0x03de5a1ebb4fbb15U)),}, (strconv__Uint128){.lo = ((u64)(0x6a54d92bf80caa07U)),.hi = ((u64)(0x0318481895d96277U)),}, (strconv__Uint128){.lo = ((u64)(0x21dd7a89933d54d2U)),.hi = ((u64)(0x0279d346de4781f9U)),}, (strconv__Uint128){.lo = ((u64)(0x362f2a75b8622150U)),.hi = ((u64)(0x03f61ed7ca0c0328U)),}, (strconv__Uint128){.lo = ((u64)(0xf825bb91604e810dU)),.hi = ((u64)(0x032b4bdfd4d668ecU)),}, (strconv__Uint128){.lo = ((u64)(0xc684960de6a5340bU)),.hi = ((u64)(0x0289097fdd7853f0U)),}, (strconv__Uint128){.lo = ((u64)(0xd203ab3e521dc33cU)),.hi = ((u64)(0x02073accb12d0ff3U)),}, (strconv__Uint128){.lo = ((u64)(0xe99f7863b696052cU)),.hi = ((u64)(0x033ec47ab514e652U)),}, (strconv__Uint128){.lo = ((u64)(0x87b2c6b62bab3757U)),.hi = ((u64)(0x02989d2ef743eb75U)),}, (strconv__Uint128){.lo = ((u64)(0xd2f56bc4efbc2c45U)),.hi = ((u64)(0x0213b0f25f69892aU)),}, (strconv__Uint128){.lo = ((u64)(0x1e55793b192d13a2U)),.hi = ((u64)(0x0352b4b6ff0f41deU)),}, (strconv__Uint128){.lo = ((u64)(0x4b77942f475742e8U)),.hi = ((u64)(0x02a8909265a5ce4bU)),}, (strconv__Uint128){.lo = ((u64)(0xd5f9435905df68baU)),.hi = ((u64)(0x022073a8515171d5U)),}, (strconv__Uint128){.lo = ((u64)(0x565b9ef4d6324129U)),.hi = ((u64)(0x03671f73b54f1c89U)),}, (strconv__Uint128){.lo = ((u64)(0xdeafb25d78283421U)),.hi = ((u64)(0x02b8e5f62aa5b06dU)),}, (strconv__Uint128){.lo = ((u64)(0x188c8eb12cecf681U)),.hi = ((u64)(0x022d84c4eeeaf38bU)),}, (strconv__Uint128){.lo = ((u64)(0x8dadb11b7b14bd9bU)),.hi = ((u64)(0x037c07a17e44b8deU)),}, (strconv__Uint128){.lo = ((u64)(0x7157c0e2c8dd647cU)),.hi = ((u64)(0x02c99fb46503c718U)),}, (strconv__Uint128){.lo = ((u64)(0x8ddfcd823a4ab6caU)),.hi = ((u64)(0x023ae629ea696c13U)),}, (strconv__Uint128){.lo = ((u64)(0x1632e269f6ddf142U)),.hi = ((u64)(0x0391704310a8acecU)),}, (strconv__Uint128){.lo = ((u64)(0x44f581ee5f17f435U)),.hi = ((u64)(0x02dac035a6ed5723U)),}, (strconv__Uint128){.lo = ((u64)(0x372ace584c1329c4U)),.hi = ((u64)(0x024899c4858aac1cU)),}, (strconv__Uint128){.lo = ((u64)(0xbeaae3c079b842d3U)),.hi = ((u64)(0x03a75c6da27779c6U)),}, (strconv__Uint128){.lo = ((u64)(0x6555830061603576U)),.hi = ((u64)(0x02ec49f14ec5fb05U)),}, (strconv__Uint128){.lo = ((u64)(0xb7779c004de6912bU)),.hi = ((u64)(0x0256a18dd89e626aU)),}, (strconv__Uint128){.lo = ((u64)(0xf258f99a163db512U)),.hi = ((u64)(0x03bdcf495a9703ddU)),}, (strconv__Uint128){.lo = ((u64)(0x5b7a614811caf741U)),.hi = ((u64)(0x02fe3f6de212697eU)),}, (strconv__Uint128){.lo = ((u64)(0xaf951aa00e3bf901U)),.hi = ((u64)(0x0264ff8b1b41edfeU)),}, (strconv__Uint128){.lo = ((u64)(0x7f54f7667d2cc19bU)),.hi = ((u64)(0x03d4cc11c5364997U)),}, (strconv__Uint128){.lo = ((u64)(0x32aa5f8530f09ae3U)),.hi = ((u64)(0x0310a3416a91d479U)),}, (strconv__Uint128){.lo = ((u64)(0xf55519375a5a1582U)),.hi = ((u64)(0x0273b5cdeedb1060U)),}, (strconv__Uint128){.lo = ((u64)(0xbbbb5b8bc3c3559dU)),.hi = ((u64)(0x03ec56164af81a34U)),}, (strconv__Uint128){.lo = ((u64)(0x2fc916096969114aU)),.hi = ((u64)(0x03237811d593482aU)),}, (strconv__Uint128){.lo = ((u64)(0x596dab3ababa743cU)),.hi = ((u64)(0x0282c674aadc39bbU)),}, (strconv__Uint128){.lo = ((u64)(0x478aef622efb9030U)),.hi = ((u64)(0x0202385d557cfafcU)),}, (strconv__Uint128){.lo = ((u64)(0xd8de4bd04b2c19e6U)),.hi = ((u64)(0x0336c0955594c4c6U)),}, (strconv__Uint128){.lo = ((u64)(0xad7ea30d08f014b8U)),.hi = ((u64)(0x029233aaaadd6a38U)),}, (strconv__Uint128){.lo = ((u64)(0x24654f3da0c01093U)),.hi = ((u64)(0x020e8fbbbbe454faU)),}, (strconv__Uint128){.lo = ((u64)(0x3a3bb1fc346680ebU)),.hi = ((u64)(0x034a7f92c63a2190U)),}, (strconv__Uint128){.lo = ((u64)(0x94fc8e635d1ecd89U)),.hi = ((u64)(0x02a1ffa89e94e7a6U)),}, (strconv__Uint128){.lo = ((u64)(0xaa63a51c4a7f0ad4U)),.hi = ((u64)(0x021b32ed4baa52ebU)),}, (strconv__Uint128){.lo = ((u64)(0xdd6c3b607731aaedU)),.hi = ((u64)(0x035eb7e212aa1e45U)),}, (strconv__Uint128){.lo = ((u64)(0x1789c919f8f488bdU)),.hi = ((u64)(0x02b22cb4dbbb4b6bU)),}, (strconv__Uint128){.lo = ((u64)(0xac6e3a7b2d906d64U)),.hi = ((u64)(0x022823c3e2fc3c55U)),}, (strconv__Uint128){.lo = ((u64)(0x13e390c515b3e23aU)),.hi = ((u64)(0x03736c6c9e606089U)),}, (strconv__Uint128){.lo = ((u64)(0xdcb60d6a77c31b62U)),.hi = ((u64)(0x02c2bd23b1e6b3a0U)),}, (strconv__Uint128){.lo = ((u64)(0x7d5e7121f968e2b5U)),.hi = ((u64)(0x0235641c8e52294dU)),}, (strconv__Uint128){.lo = ((u64)(0xc8971b698f0e3787U)),.hi = ((u64)(0x0388a02db0837548U)),}, (strconv__Uint128){.lo = ((u64)(0xa078e2bad8d82c6cU)),.hi = ((u64)(0x02d3b357c0692aa0U)),}, (strconv__Uint128){.lo = ((u64)(0xe6c71bc8ad79bd24U)),.hi = ((u64)(0x0242f5dfcd20eee6U)),}, (strconv__Uint128){.lo = ((u64)(0x0ad82c7448c2c839U)),.hi = ((u64)(0x039e5632e1ce4b0bU)),}, (strconv__Uint128){.lo = ((u64)(0x3be023903a356cfaU)),.hi = ((u64)(0x02e511c24e3ea26fU)),}, (strconv__Uint128){.lo = ((u64)(0x2fe682d9c82abd95U)),.hi = ((u64)(0x0250db01d8321b8cU)),}, (strconv__Uint128){.lo = ((u64)(0x4ca4048fa6aac8eeU)),.hi = ((u64)(0x03b4919c8d1cf8e0U)),}, (strconv__Uint128){.lo = ((u64)(0x3d5003a61eef0725U)),.hi = ((u64)(0x02f6dae3a4172d80U)),}, (strconv__Uint128){.lo = ((u64)(0x9773361e7f259f51U)),.hi = ((u64)(0x025f1582e9ac2466U)),}, (strconv__Uint128){.lo = ((u64)(0x8beb89ca6508fee8U)),.hi = ((u64)(0x03cb559e42ad070aU)),}, (strconv__Uint128){.lo = ((u64)(0x6fefa16eb73a6586U)),.hi = ((u64)(0x0309114b688a6c08U)),}, (strconv__Uint128){.lo = ((u64)(0xf3261abef8fb846bU)),.hi = ((u64)(0x026da76f86d52339U)),}, (strconv__Uint128){.lo = ((u64)(0x51d691318e5f3a45U)),.hi = ((u64)(0x03e2a57f3e21d1f6U)),}, (strconv__Uint128){.lo = ((u64)(0x0e4540f471e5c837U)),.hi = ((u64)(0x031bb798fe8174c5U)),}, (strconv__Uint128){.lo = ((u64)(0xd8376729f4b7d360U)),.hi = ((u64)(0x027c92e0cb9ac3d0U)),}, (strconv__Uint128){.lo = ((u64)(0xf38bd84321261effU)),.hi = ((u64)(0x03fa849adf5e061aU)),}, (strconv__Uint128){.lo = ((u64)(0x293cad0280eb4bffU)),.hi = ((u64)(0x032ed07be5e4d1afU)),}, (strconv__Uint128){.lo = ((u64)(0xedca240200bc3cccU)),.hi = ((u64)(0x028bd9fcb7ea4158U)),}, (strconv__Uint128){.lo = ((u64)(0xbe3b50019a3030a4U)),.hi = ((u64)(0x02097b309321cde0U)),}, (strconv__Uint128){.lo = ((u64)(0xc9f88002904d1a9fU)),.hi = ((u64)(0x03425eb41e9c7c9aU)),}, (strconv__Uint128){.lo = ((u64)(0x3b2d3335403daee6U)),.hi = ((u64)(0x029b7ef67ee396e2U)),}, (strconv__Uint128){.lo = ((u64)(0x95bdc291003158b8U)),.hi = ((u64)(0x0215ff2b98b6124eU)),}, (strconv__Uint128){.lo = ((u64)(0x892f9db4cd1bc126U)),.hi = ((u64)(0x035665128df01d4aU)),}, (strconv__Uint128){.lo = ((u64)(0x07594af70a7c9a85U)),.hi = ((u64)(0x02ab840ed7f34aa2U)),}, (strconv__Uint128){.lo = ((u64)(0x6c476f2c0863aed1U)),.hi = ((u64)(0x0222d00bdff5d54eU)),}, (strconv__Uint128){.lo = ((u64)(0x13a57eacda3917b4U)),.hi = ((u64)(0x036ae67966562217U)),}, (strconv__Uint128){.lo = ((u64)(0x0fb7988a482dac90U)),.hi = ((u64)(0x02bbeb9451de81acU)),}, (strconv__Uint128){.lo = ((u64)(0xd95fad3b6cf156daU)),.hi = ((u64)(0x022fefa9db1867bcU)),}, (strconv__Uint128){.lo = ((u64)(0xf565e1f8ae4ef15cU)),.hi = ((u64)(0x037fe5dc91c0a5faU)),}, (strconv__Uint128){.lo = ((u64)(0x911e4e608b725ab0U)),.hi = ((u64)(0x02ccb7e3a7cd5195U)),}, (strconv__Uint128){.lo = ((u64)(0xda7ea51a0928488dU)),.hi = ((u64)(0x023d5fe9530aa7aaU)),}, (strconv__Uint128){.lo = ((u64)(0xf7310829a8407415U)),.hi = ((u64)(0x039566421e7772aaU)),}, (strconv__Uint128){.lo = ((u64)(0x2c2739baed005cdeU)),.hi = ((u64)(0x02ddeb68185f8eefU)),}, (strconv__Uint128){.lo = ((u64)(0xbcec2e2f24004a4bU)),.hi = ((u64)(0x024b22b9ad193f25U)),}, (strconv__Uint128){.lo = ((u64)(0x94ad16b1d333aa11U)),.hi = ((u64)(0x03ab6ac2ae8ecb6fU)),}, (strconv__Uint128){.lo = ((u64)(0xaa241227dc2954dbU)),.hi = ((u64)(0x02ef889bbed8a2bfU)),}, (strconv__Uint128){.lo = ((u64)(0x54e9a81fe35443e2U)),.hi = ((u64)(0x02593a163246e899U)),}, (strconv__Uint128){.lo = ((u64)(0x2175d9cc9eed396aU)),.hi = ((u64)(0x03c1f689ea0b0dc2U)),}, (strconv__Uint128){.lo = ((u64)(0xe7917b0a18bdc788U)),.hi = ((u64)(0x03019207ee6f3e34U)),}, (strconv__Uint128){.lo = ((u64)(0xb9412f3b46fe393aU)),.hi = ((u64)(0x0267a8065858fe90U)),}, (strconv__Uint128){.lo = ((u64)(0xf535185ed7fd285cU)),.hi = ((u64)(0x03d90cd6f3c1974dU)),}, (strconv__Uint128){.lo = ((u64)(0xc42a79e57997537dU)),.hi = ((u64)(0x03140a458fce12a4U)),}, (strconv__Uint128){.lo = ((u64)(0x03552e512e12a931U)),.hi = ((u64)(0x02766e9e0ca4dbb7U)),}, (strconv__Uint128){.lo = ((u64)(0x9eeeb081e3510eb4U)),.hi = ((u64)(0x03f0b0fce107c5f1U)),}, (strconv__Uint128){.lo = ((u64)(0x4bf226ce4f740bc3U)),.hi = ((u64)(0x0326f3fd80d304c1U)),}, (strconv__Uint128){.lo = ((u64)(0xa3281f0b72c33c9cU)),.hi = ((u64)(0x02858ffe00a8d09aU)),}, (strconv__Uint128){.lo = ((u64)(0x1c2018d5f568fd4aU)),.hi = ((u64)(0x020473319a20a6e2U)),}, (strconv__Uint128){.lo = ((u64)(0xf9ccf48988a7fba9U)),.hi = ((u64)(0x033a51e8f69aa49cU)),}, (strconv__Uint128){.lo = ((u64)(0xfb0a5d3ad3b99621U)),.hi = ((u64)(0x02950e53f87bb6e3U)),}, (strconv__Uint128){.lo = ((u64)(0x2f3b7dc8a96144e7U)),.hi = ((u64)(0x0210d8432d2fc583U)),}, (strconv__Uint128){.lo = ((u64)(0xe52bfc7442353b0cU)),.hi = ((u64)(0x034e26d1e1e608d1U)),}, (strconv__Uint128){.lo = ((u64)(0xb756639034f76270U)),.hi = ((u64)(0x02a4ebdb1b1e6d74U)),}, (strconv__Uint128){.lo = ((u64)(0x2c451c735d92b526U)),.hi = ((u64)(0x021d897c15b1f12aU)),}, (strconv__Uint128){.lo = ((u64)(0x13a1c71efc1deea3U)),.hi = ((u64)(0x0362759355e981ddU)),}, (strconv__Uint128){.lo = ((u64)(0x761b05b2634b2550U)),.hi = ((u64)(0x02b52adc44bace4aU)),}, (strconv__Uint128){.lo = ((u64)(0x91af37c1e908eaa6U)),.hi = ((u64)(0x022a88b036fbd83bU)),}, (strconv__Uint128){.lo = ((u64)(0x82b1f2cfdb417770U)),.hi = ((u64)(0x03774119f192f392U)),}, (strconv__Uint128){.lo = ((u64)(0xcef4c23fe29ac5f3U)),.hi = ((u64)(0x02c5cdae5adbf60eU)),}, (strconv__Uint128){.lo = ((u64)(0x3f2a34ffe87bd190U)),.hi = ((u64)(0x0237d7beaf165e72U)),}, (strconv__Uint128){.lo = ((u64)(0x984387ffda5fb5b2U)),.hi = ((u64)(0x038c8c644b56fd83U)),}, (strconv__Uint128){.lo = ((u64)(0xe0360666484c915bU)),.hi = ((u64)(0x02d6d6b6a2abfe02U)),}, (strconv__Uint128){.lo = ((u64)(0x802b3851d3707449U)),.hi = ((u64)(0x024578921bbccb35U)),}, (strconv__Uint128){.lo = ((u64)(0x99dec082ebe72075U)),.hi = ((u64)(0x03a25a835f947855U)),}, (strconv__Uint128){.lo = ((u64)(0xae4bcd358985b391U)),.hi = ((u64)(0x02e8486919439377U)),}, (strconv__Uint128){.lo = ((u64)(0xbea30a913ad15c74U)),.hi = ((u64)(0x02536d20e102dc5fU)),}, (strconv__Uint128){.lo = ((u64)(0xfdd1aa81f7b560b9U)),.hi = ((u64)(0x03b8ae9b019e2d65U)),}, (strconv__Uint128){.lo = ((u64)(0x97daeece5fc44d61U)),.hi = ((u64)(0x02fa2548ce182451U)),}, (strconv__Uint128){.lo = ((u64)(0xdfe258a51969d781U)),.hi = ((u64)(0x0261b76d71ace9daU)),}, (strconv__Uint128){.lo = ((u64)(0x996a276e8f0fbf34U)),.hi = ((u64)(0x03cf8be24f7b0fc4U)),}, (strconv__Uint128){.lo = ((u64)(0xe121b9253f3fcc2aU)),.hi = ((u64)(0x030c6fe83f95a636U)),}, (strconv__Uint128){.lo = ((u64)(0xb41afa8432997022U)),.hi = ((u64)(0x02705986994484f8U)),}, (strconv__Uint128){.lo = ((u64)(0xecf7f739ea8f19cfU)),.hi = ((u64)(0x03e6f5a4286da18dU)),}, (strconv__Uint128){.lo = ((u64)(0x23f99294bba5ae40U)),.hi = ((u64)(0x031f2ae9b9f14e0bU)),}, (strconv__Uint128){.lo = ((u64)(0x4ffadbaa2fb7be99U)),.hi = ((u64)(0x027f5587c7f43e6fU)),}, (strconv__Uint128){.lo = ((u64)(0x7ff7c5dd1925fdc2U)),.hi = ((u64)(0x03feef3fa6539718U)),}, (strconv__Uint128){.lo = ((u64)(0xccc637e4141e649bU)),.hi = ((u64)(0x033258ffb842df46U)),}, (strconv__Uint128){.lo = ((u64)(0xd704f983434b83afU)),.hi = ((u64)(0x028ead9960357f6bU)),}, (strconv__Uint128){.lo = ((u64)(0x126a6135cf6f9c8cU)),.hi = ((u64)(0x020bbe144cf79923U)),}, (strconv__Uint128){.lo = ((u64)(0x83dd685618b29414U)),.hi = ((u64)(0x0345fced47f28e9eU)),}, (strconv__Uint128){.lo = ((u64)(0x9cb12044e08edcddU)),.hi = ((u64)(0x029e63f1065ba54bU)),}, (strconv__Uint128){.lo = ((u64)(0x16f419d0b3a57d7dU)),.hi = ((u64)(0x02184ff405161dd6U)),}, (strconv__Uint128){.lo = ((u64)(0x8b20294dec3bfbfbU)),.hi = ((u64)(0x035a19866e89c956U)),}, (strconv__Uint128){.lo = ((u64)(0x3c19baa4bcfcc996U)),.hi = ((u64)(0x02ae7ad1f207d445U)),}, (strconv__Uint128){.lo = ((u64)(0xc9ae2eea30ca3adfU)),.hi = ((u64)(0x02252f0e5b39769dU)),}, (strconv__Uint128){.lo = ((u64)(0x0f7d17dd1add2afdU)),.hi = ((u64)(0x036eb1b091f58a96U)),}, (strconv__Uint128){.lo = ((u64)(0x3f97464a7be42264U)),.hi = ((u64)(0x02bef48d41913babU)),}, (strconv__Uint128){.lo = ((u64)(0xcc790508631ce850U)),.hi = ((u64)(0x02325d3dce0dc955U)),}, (strconv__Uint128){.lo = ((u64)(0xe0c1a1a704fb0d4dU)),.hi = ((u64)(0x0383c862e3494222U)),}, (strconv__Uint128){.lo = ((u64)(0x4d67b4859d95a43eU)),.hi = ((u64)(0x02cfd3824f6dce82U)),}, (strconv__Uint128){.lo = ((u64)(0x711fc39e17aae9cbU)),.hi = ((u64)(0x023fdc683f8b0b9bU)),}, (strconv__Uint128){.lo = ((u64)(0xe832d2968c44a945U)),.hi = ((u64)(0x039960a6cc11ac2bU)),}, (strconv__Uint128){.lo = ((u64)(0xecf575453d03ba9eU)),.hi = ((u64)(0x02e11a1f09a7bcefU)),}, (strconv__Uint128){.lo = ((u64)(0x572ac4376402fbb1U)),.hi = ((u64)(0x024dae7f3aec9726U)),}, (strconv__Uint128){.lo = ((u64)(0x58446d256cd192b5U)),.hi = ((u64)(0x03af7d985e47583dU)),}, (strconv__Uint128){.lo = ((u64)(0x79d0575123dadbc4U)),.hi = ((u64)(0x02f2cae04b6c4697U)),}, (strconv__Uint128){.lo = ((u64)(0x94a6ac40e97be303U)),.hi = ((u64)(0x025bd5803c569edfU)),}, (strconv__Uint128){.lo = ((u64)(0x8771139b0f2c9e6cU)),.hi = ((u64)(0x03c62266c6f0fe32U)),}, (strconv__Uint128){.lo = ((u64)(0x9f8da948d8f07ebdU)),.hi = ((u64)(0x0304e85238c0cb5bU)),}, (strconv__Uint128){.lo = ((u64)(0xe60aedd3e0c06564U)),.hi = ((u64)(0x026a5374fa33d5e2U)),}, (strconv__Uint128){.lo = ((u64)(0xa344afb9679a3bd2U)),.hi = ((u64)(0x03dd5254c3862304U)),}, (strconv__Uint128){.lo = ((u64)(0xe903bfc78614fca8U)),.hi = ((u64)(0x031775109c6b4f36U)),}, (strconv__Uint128){.lo = ((u64)(0xba6966393810ca20U)),.hi = ((u64)(0x02792a73b055d8f8U)),}, (strconv__Uint128){.lo = ((u64)(0x2a423d2859b4769aU)),.hi = ((u64)(0x03f510b91a22f4c1U)),}, (strconv__Uint128){.lo = ((u64)(0xee9b642047c39215U)),.hi = ((u64)(0x032a73c7481bf700U)),}, (strconv__Uint128){.lo = ((u64)(0xbee2b680396941aaU)),.hi = ((u64)(0x02885c9f6ce32c00U)),}, (strconv__Uint128){.lo = ((u64)(0xff1bc53361210155U)),.hi = ((u64)(0x0206b07f8a4f5666U)),}, (strconv__Uint128){.lo = ((u64)(0x31c6085235019bbbU)),.hi = ((u64)(0x033de73276e5570bU)),}, (strconv__Uint128){.lo = ((u64)(0x27d1a041c4014963U)),.hi = ((u64)(0x0297ec285f1ddf3cU)),}, (strconv__Uint128){.lo = ((u64)(0xeca7b367d0010782U)),.hi = ((u64)(0x021323537f4b18fcU)),}, (strconv__Uint128){.lo = ((u64)(0xadd91f0c8001a59dU)),.hi = ((u64)(0x0351d21f3211c194U)),}, (strconv__Uint128){.lo = ((u64)(0xf17a7f3d3334847eU)),.hi = ((u64)(0x02a7db4c280e3476U)),}, (strconv__Uint128){.lo = ((u64)(0x279532975c2a0398U)),.hi = ((u64)(0x021fe2a3533e905fU)),}, (strconv__Uint128){.lo = ((u64)(0xd8eeb75893766c26U)),.hi = ((u64)(0x0366376bb8641a31U)),}, (strconv__Uint128){.lo = ((u64)(0x7a5892ad42c52352U)),.hi = ((u64)(0x02b82c562d1ce1c1U)),}, (strconv__Uint128){.lo = ((u64)(0xfb7a0ef102374f75U)),.hi = ((u64)(0x022cf044f0e3e7cdU)),}, (strconv__Uint128){.lo = ((u64)(0xc59017e8038bb254U)),.hi = ((u64)(0x037b1a07e7d30c7cU)),}, (strconv__Uint128){.lo = ((u64)(0x37a67986693c8eaaU)),.hi = ((u64)(0x02c8e19feca8d6caU)),}, (strconv__Uint128){.lo = ((u64)(0xf951fad1edca0bbbU)),.hi = ((u64)(0x023a4e198a20abd4U)),}, (strconv__Uint128){.lo = ((u64)(0x28832ae97c76792bU)),.hi = ((u64)(0x03907cf5a9cddfbbU)),}, (strconv__Uint128){.lo = ((u64)(0x2068ef21305ec756U)),.hi = ((u64)(0x02d9fd9154a4b2fcU)),}, (strconv__Uint128){.lo = ((u64)(0x19ed8c1a8d189f78U)),.hi = ((u64)(0x0247fe0ddd508f30U)),}, (strconv__Uint128){.lo = ((u64)(0x5caf4690e1c0ff26U)),.hi = ((u64)(0x03a66349621a7eb3U)),}, (strconv__Uint128){.lo = ((u64)(0x4a25d20d81673285U)),.hi = ((u64)(0x02eb82a11b48655cU)),}, (strconv__Uint128){.lo = ((u64)(0x3b5174d79ab8f537U)),.hi = ((u64)(0x0256021a7c39eab0U)),}, (strconv__Uint128){.lo = ((u64)(0x921bee25c45b21f1U)),.hi = ((u64)(0x03bcd02a605caab3U)),}, (strconv__Uint128){.lo = ((u64)(0xdb498b5169e2818eU)),.hi = ((u64)(0x02fd735519e3bbc2U)),}, (strconv__Uint128){.lo = ((u64)(0x15d46f7454b53472U)),.hi = ((u64)(0x02645c4414b62fcfU)),}, (strconv__Uint128){.lo = ((u64)(0xefba4bed545520b6U)),.hi = ((u64)(0x03d3c6d35456b2e4U)),}, (strconv__Uint128){.lo = ((u64)(0xf2fb6ff110441a2bU)),.hi = ((u64)(0x030fd242a9def583U)),}, (strconv__Uint128){.lo = ((u64)(0x8f2f8cc0d9d014efU)),.hi = ((u64)(0x02730e9bbb18c469U)),}, (strconv__Uint128){.lo = ((u64)(0xb1e5ae015c80217fU)),.hi = ((u64)(0x03eb4a92c4f46d75U)),}, (strconv__Uint128){.lo = ((u64)(0xc1848b344a001accU)),.hi = ((u64)(0x0322a20f03f6bdf7U)),}, (strconv__Uint128){.lo = ((u64)(0xce03a2903b3348a3U)),.hi = ((u64)(0x02821b3f365efe5fU)),}, (strconv__Uint128){.lo = ((u64)(0xd802e873628f6d4fU)),.hi = ((u64)(0x0201af65c518cb7fU)),}, (strconv__Uint128){.lo = ((u64)(0x599e40b89db2487fU)),.hi = ((u64)(0x0335e56fa1c14599U)),}, (strconv__Uint128){.lo = ((u64)(0xe14b66fa17c1d399U)),.hi = ((u64)(0x029184594e3437adU)),}, (strconv__Uint128){.lo = ((u64)(0x81091f2e7967dc7aU)),.hi = ((u64)(0x020e037aa4f692f1U)),}, (strconv__Uint128){.lo = ((u64)(0x9b41cb7d8f0c93f6U)),.hi = ((u64)(0x03499f2aa18a84b5U)),}, (strconv__Uint128){.lo = ((u64)(0xaf67d5fe0c0a0ff8U)),.hi = ((u64)(0x02a14c221ad536f7U)),}, (strconv__Uint128){.lo = ((u64)(0xf2b977fe70080cc7U)),.hi = ((u64)(0x021aa34e7bddc592U)),}, (strconv__Uint128){.lo = ((u64)(0x1df58cca4cd9ae0bU)),.hi = ((u64)(0x035dd2172c9608ebU)),}, (strconv__Uint128){.lo = ((u64)(0xe4c470a1d7148b3cU)),.hi = ((u64)(0x02b174df56de6d88U)),}, (strconv__Uint128){.lo = ((u64)(0x83d05a1b1276d5caU)),.hi = ((u64)(0x022790b2abe5246dU)),}, (strconv__Uint128){.lo = ((u64)(0x9fb3c35e83f1560fU)),.hi = ((u64)(0x0372811ddfd50715U)),}, (strconv__Uint128){.lo = ((u64)(0xb2f635e5365aab3fU)),.hi = ((u64)(0x02c200e4b310d277U)),}, (strconv__Uint128){.lo = ((u64)(0xf591c4b75eaeef66U)),.hi = ((u64)(0x0234cd83c273db92U)),}, (strconv__Uint128){.lo = ((u64)(0xef4fa125644b18a3U)),.hi = ((u64)(0x0387af39371fc5b7U)),}, (strconv__Uint128){.lo = ((u64)(0x8c3fb41de9d5ad4fU)),.hi = ((u64)(0x02d2f2942c196af9U)),}, (strconv__Uint128){.lo = ((u64)(0x3cffc34b2177bdd9U)),.hi = ((u64)(0x02425ba9bce12261U)),}, (strconv__Uint128){.lo = ((u64)(0x94cc6bab68bf9628U)),.hi = ((u64)(0x039d5f75fb01d09bU)),}, (strconv__Uint128){.lo = ((u64)(0x10a38955ed6611b9U)),.hi = ((u64)(0x02e44c5e6267da16U)),}, (strconv__Uint128){.lo = ((u64)(0xda1c6dde5784dafbU)),.hi = ((u64)(0x02503d184eb97b44U)),}, (strconv__Uint128){.lo = ((u64)(0xf693e2fd58d49191U)),.hi = ((u64)(0x03b394f3b128c53aU)),}, (strconv__Uint128){.lo = ((u64)(0xc5431bfde0aa0e0eU)),.hi = ((u64)(0x02f610c2f4209dc8U)),}, (strconv__Uint128){.lo = ((u64)(0x6a9c1664b3bb3e72U)),.hi = ((u64)(0x025e73cf29b3b16dU)),}, (strconv__Uint128){.lo = ((u64)(0x10f9bd6dec5eca4fU)),.hi = ((u64)(0x03ca52e50f85e8afU)),}, (strconv__Uint128){.lo = ((u64)(0xda616457f04bd50cU)),.hi = ((u64)(0x03084250d937ed58U)),}, (strconv__Uint128){.lo = ((u64)(0xe1e783798d09773dU)),.hi = ((u64)(0x026d01da475ff113U)),}, (strconv__Uint128){.lo = ((u64)(0x030c058f480f252eU)),.hi = ((u64)(0x03e19c9072331b53U)),}, (strconv__Uint128){.lo = ((u64)(0x68d66ad906728425U)),.hi = ((u64)(0x031ae3a6c1c27c42U)),}, (strconv__Uint128){.lo = ((u64)(0x8711ef14052869b7U)),.hi = ((u64)(0x027be952349b969bU)),}, (strconv__Uint128){.lo = ((u64)(0x0b4fe4ecd50d75f2U)),.hi = ((u64)(0x03f97550542c242cU)),}, (strconv__Uint128){.lo = ((u64)(0xa2a650bd773df7f5U)),.hi = ((u64)(0x032df7737689b689U)),}, (strconv__Uint128){.lo = ((u64)(0xb551da312c31932aU)),.hi = ((u64)(0x028b2c5c5ed49207U)),}, (strconv__Uint128){.lo = ((u64)(0x5ddb14f4235adc22U)),.hi = ((u64)(0x0208f049e576db39U)),}, (strconv__Uint128){.lo = ((u64)(0x2fc4ee536bc49369U)),.hi = ((u64)(0x034180763bf15ec2U)),}, (strconv__Uint128){.lo = ((u64)(0xbfd0bea92303a921U)),.hi = ((u64)(0x029acd2b63277f01U)),}, (strconv__Uint128){.lo = ((u64)(0x9973cbba8269541aU)),.hi = ((u64)(0x021570ef8285ff34U)),}, (strconv__Uint128){.lo = ((u64)(0x5bec792a6a42202aU)),.hi = ((u64)(0x0355817f373ccb87U)),}, (strconv__Uint128){.lo = ((u64)(0xe3239421ee9b4cefU)),.hi = ((u64)(0x02aacdff5f63d605U)),}, (strconv__Uint128){.lo = ((u64)(0xb5b6101b25490a59U)),.hi = ((u64)(0x02223e65e5e97804U)),}, (strconv__Uint128){.lo = ((u64)(0x22bce691d541aa27U)),.hi = ((u64)(0x0369fd6fd64259a1U)),}, (strconv__Uint128){.lo = ((u64)(0xb563eba7ddce21b9U)),.hi = ((u64)(0x02bb31264501e14dU)),}, (strconv__Uint128){.lo = ((u64)(0xf78322ecb171b494U)),.hi = ((u64)(0x022f5a850401810aU)),}, (strconv__Uint128){.lo = ((u64)(0x259e9e47824f8753U)),.hi = ((u64)(0x037ef73b399c01abU)),}, (strconv__Uint128){.lo = ((u64)(0x1e187e9f9b72d2a9U)),.hi = ((u64)(0x02cbf8fc2e1667bcU)),}, (strconv__Uint128){.lo = ((u64)(0x4b46cbb2e2c24221U)),.hi = ((u64)(0x023cc73024deb963U)),}, (strconv__Uint128){.lo = ((u64)(0x120adf849e039d01U)),.hi = ((u64)(0x039471e6a1645bd2U)),}, (strconv__Uint128){.lo = ((u64)(0xdb3be603b19c7d9aU)),.hi = ((u64)(0x02dd27ebb4504974U)),}, (strconv__Uint128){.lo = ((u64)(0x7c2feb3627b0647cU)),.hi = ((u64)(0x024a865629d9d45dU)),}, (strconv__Uint128){.lo = ((u64)(0x2d197856a5e7072cU)),.hi = ((u64)(0x03aa7089dc8fba2fU)),}, (strconv__Uint128){.lo = ((u64)(0x8a7ac6abb7ec05bdU)),.hi = ((u64)(0x02eec06e4a0c94f2U)),}, (strconv__Uint128){.lo = ((u64)(0xd52f05562cbcd164U)),.hi = ((u64)(0x025899f1d4d6dd8eU)),}, (strconv__Uint128){.lo = ((u64)(0x21e4d556adfae8a0U)),.hi = ((u64)(0x03c0f64fbaf1627eU)),}, (strconv__Uint128){.lo = ((u64)(0xe7ea444557fbed4dU)),.hi = ((u64)(0x0300c50c958de864U)),}, (strconv__Uint128){.lo = ((u64)(0xecbb69d1132ff10aU)),.hi = ((u64)(0x0267040a113e5383U)),}, (strconv__Uint128){.lo = ((u64)(0xadf8a94e851981aaU)),.hi = ((u64)(0x03d8067681fd526cU)),}, (strconv__Uint128){.lo = ((u64)(0x8b2d543ed0e13488U)),.hi = ((u64)(0x0313385ece6441f0U)),}, (strconv__Uint128){.lo = ((u64)(0xd5bddcff0d80f6d3U)),.hi = ((u64)(0x0275c6b23eb69b26U)),}, (strconv__Uint128){.lo = ((u64)(0x892fc7fe7c018aebU)),.hi = ((u64)(0x03efa45064575ea4U)),}, (strconv__Uint128){.lo = ((u64)(0x3a8c9ffec99ad589U)),.hi = ((u64)(0x03261d0d1d12b21dU)),}, (strconv__Uint128){.lo = ((u64)(0xc8707fff07af113bU)),.hi = ((u64)(0x0284e40a7da88e7dU)),}, (strconv__Uint128){.lo = ((u64)(0x39f39998d2f2742fU)),.hi = ((u64)(0x0203e9a1fe2071feU)),}, (strconv__Uint128){.lo = ((u64)(0x8fec28f484b7204bU)),.hi = ((u64)(0x033975cffd00b663U)),}, (strconv__Uint128){.lo = ((u64)(0xd989ba5d36f8e6a2U)),.hi = ((u64)(0x02945e3ffd9a2b82U)),}, (strconv__Uint128){.lo = ((u64)(0x47a161e42bfa521cU)),.hi = ((u64)(0x02104b66647b5602U)),}, (strconv__Uint128){.lo = ((u64)(0x0c35696d132a1cf9U)),.hi = ((u64)(0x034d4570a0c5566aU)),}, (strconv__Uint128){.lo = ((u64)(0x09c454574288172dU)),.hi = ((u64)(0x02a4378d4d6aab88U)),}, (strconv__Uint128){.lo = ((u64)(0xa169dd129ba0128bU)),.hi = ((u64)(0x021cf93dd7888939U)),}, (strconv__Uint128){.lo = ((u64)(0x0242fb50f9001dabU)),.hi = ((u64)(0x03618ec958da7529U)),}, (strconv__Uint128){.lo = ((u64)(0x9b68c90d940017bcU)),.hi = ((u64)(0x02b4723aad7b90edU)),}, (strconv__Uint128){.lo = ((u64)(0x4920a0d7a999ac96U)),.hi = ((u64)(0x0229f4fbbdfc73f1U)),}, (strconv__Uint128){.lo = ((u64)(0x750101590f5c4757U)),.hi = ((u64)(0x037654c5fcc71fe8U)),}, (strconv__Uint128){.lo = ((u64)(0x2a6734473f7d05dfU)),.hi = ((u64)(0x02c5109e63d27fedU)),}, (strconv__Uint128){.lo = ((u64)(0xeeb8f69f65fd9e4cU)),.hi = ((u64)(0x0237407eb641fff0U)),}, (strconv__Uint128){.lo = ((u64)(0xe45b24323cc8fd46U)),.hi = ((u64)(0x038b9a6456cfffe7U)),}, (strconv__Uint128){.lo = ((u64)(0xb6af502830a0ca9fU)),.hi = ((u64)(0x02d6151d123fffecU)),}, (strconv__Uint128){.lo = ((u64)(0xf88c402026e7087fU)),.hi = ((u64)(0x0244ddb0db666656U)),}, (strconv__Uint128){.lo = ((u64)(0x2746cd003e3e73feU)),.hi = ((u64)(0x03a162b4923d708bU)),}, (strconv__Uint128){.lo = ((u64)(0x1f6bd73364fec332U)),.hi = ((u64)(0x02e7822a0e978d3cU)),}, (strconv__Uint128){.lo = ((u64)(0xe5efdf5c50cbcf5bU)),.hi = ((u64)(0x0252ce880bac70fcU)),}, (strconv__Uint128){.lo = ((u64)(0x3cb2fefa1adfb22bU)),.hi = ((u64)(0x03b7b0d9ac471b2eU)),}, (strconv__Uint128){.lo = ((u64)(0x308f3261af195b56U)),.hi = ((u64)(0x02f95a47bd05af58U)),}, (strconv__Uint128){.lo = ((u64)(0x5a0c284e25ade2abU)),.hi = ((u64)(0x0261150630d15913U)),}, (strconv__Uint128){.lo = ((u64)(0x29ad0d49d5e30445U)),.hi = ((u64)(0x03ce8809e7b55b52U)),}, (strconv__Uint128){.lo = ((u64)(0x548a7107de4f369dU)),.hi = ((u64)(0x030ba007ec9115dbU)),}, (strconv__Uint128){.lo = ((u64)(0xdd3b8d9fe50c2bb1U)),.hi = ((u64)(0x026fb3398a0dab15U)),}, (strconv__Uint128){.lo = ((u64)(0x952c15cca1ad12b5U)),.hi = ((u64)(0x03e5eb8f434911bcU)),}, (strconv__Uint128){.lo = ((u64)(0x775677d6e7bda891U)),.hi = ((u64)(0x031e560c35d40e30U)),}, (strconv__Uint128){.lo = ((u64)(0xc5dec645863153a7U)),.hi = ((u64)(0x027eab3cf7dcd826U)),}}));
	// Initializations for module builtin :
	_const_init_capicity = 1 << _const_init_log_capicity;
	_const_init_even_index = _const_init_capicity - 2;
	_const_hash_mask = ((u32)(0x00FFFFFFU));
	_const_probe_inc = ((u32)(0x01000000U));
	_const_none__ = I_None___to_Interface_IError((None__*)memdup(&(None__){.msg = (string){.str=(byteptr)"", .is_lit=1},.code = 0,}, sizeof(None__)));
	_const_mid_index = _const_degree - 1;
	_const_max_len = 2 * _const_degree - 1;
	_const_children_bytes = /*SizeOf*/ sizeof(voidptr) * (_const_max_len + 1);
	// Initializations for module os :
	_const_os__file_invalid_file_id = (-1);
	_const_os__invalid_handle_value = ((voidptr)(-1));
	_const_os__hkey_local_machine = ((voidptr)(0x80000002));
	_const_os__hkey_current_user = ((voidptr)(0x80000001));
	_const_os__hwnd_broadcast = ((voidptr)(0xFFFF));
	_const_os__args = os__init_os_args_wide(___argc, (byteptr*)___argv);
	_const_os__wd_at_startup = os__getwd();
	_const_os__lang_neutral = (_const_os__sublang_neutral);
	// Initializations for module os.cmdline :
	// Initializations for module time :
	_const_time__err_invalid_8601 = v_error(_SLIT("Invalid 8601 Format"));
	_const_time__month_days = new_array_from_c_array(12, 12, sizeof(int), _MOV((int[12]){
		31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}));
	_const_time__absolute_zero_year = ((i64)(-292277022399));
	_const_time__seconds_per_hour = 60 * _const_time__seconds_per_minute;
	_const_time__seconds_per_day = 24 * _const_time__seconds_per_hour;
	_const_time__seconds_per_week = 7 * _const_time__seconds_per_day;
	_const_time__days_per_400_years = 365 * 400 + 97;
	_const_time__days_per_100_years = 365 * 100 + 24;
	_const_time__days_per_4_years = 365 * 4 + 1;
	_const_time__days_before = new_array_from_c_array(13, 13, sizeof(int), _MOV((int[13]){
		0, 31, 31 + 28, 31 + 28 + 31, 31 + 28 + 31 + 30, 31 + 28 + 31 + 30 + 31, 31 + 28 + 31 + 30 + 31 + 30, 31 + 28 + 31 + 30 + 31 + 30 + 31, 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31, 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30, 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31, 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30, 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31}));
	_const_time__long_days = new_array_from_c_array(7, 7, sizeof(string), _MOV((string[7]){_SLIT("Monday"), _SLIT("Tuesday"), _SLIT("Wednesday"), _SLIT("Thursday"), _SLIT("Friday"), _SLIT("Saturday"), _SLIT("Sunday")}));
	_const_time__nanosecond = ((time__Duration)(1));
	_const_time__microsecond = ((1000 * _const_time__nanosecond));
	_const_time__millisecond = ((1000 * _const_time__microsecond));
	_const_time__second = ((1000 * _const_time__millisecond));
	_const_time__minute = ((60 * _const_time__second));
	_const_time__hour = ((60 * _const_time__minute));
	_const_time__infinite = ((time__Duration)(-1));
	_const_time__start_time = time__init_win_time_start();
	_const_time__freq_time = time__init_win_time_freq();
	_const_time__start_local_time = time__local_as_unix_time();
	// Initializations for module math.mathutil :
	// Initializations for module v.token :
	_const_v__token__assign_tokens = new_array_from_c_array(11, 11, sizeof(v__token__Kind), _MOV((v__token__Kind[11]){
		v__token__Kind_assign, v__token__Kind_plus_assign, v__token__Kind_minus_assign, v__token__Kind_mult_assign, v__token__Kind_div_assign, v__token__Kind_xor_assign, v__token__Kind_mod_assign, v__token__Kind_or_assign, v__token__Kind_and_assign, v__token__Kind_right_shift_assign, v__token__Kind_left_shift_assign}));
	_const_v__token__nr_tokens = ((int)(v__token__Kind__end_));
	_const_v__token__valid_at_tokens = new_array_from_c_array(10, 10, sizeof(string), _MOV((string[10]){
		_SLIT("@FN"), _SLIT("@METHOD"), _SLIT("@MOD"), _SLIT("@STRUCT"), _SLIT("@VEXE"), _SLIT("@FILE"), _SLIT("@LINE"), _SLIT("@COLUMN"), _SLIT("@VHASH"), _SLIT("@VMOD_FILE")}));
	_const_v__token__token_str = v__token__build_token_str();
	_const_v__token__keywords = v__token__build_keys();
	_const_v__token__precedences = v__token__build_precedences();
	// Initializations for module v.depgraph :
	// Initializations for module rand.constants :
	_const_rand__constants__lower_mask = ((u64)(0x00000000FFFFFFFFU));
	_const_rand__constants__max_u32_as_f32 = ((f32)(_const_rand__constants__max_u32)) + 1;
	_const_rand__constants__max_u64_as_f64 = ((f64)(_const_rand__constants__max_u64)) + 1;
	_const_rand__constants__u31_mask = ((u32)(0x7FFFFFFFU));
	_const_rand__constants__u63_mask = ((u64)(0x7FFFFFFFFFFFFFFFU));
	// Initializations for module flag :
	// Initializations for module semver :
	_const_semver__versions = new_array_from_c_array(3, 3, sizeof(int), _MOV((int[3]){_const_semver__ver_major, _const_semver__ver_minor, _const_semver__ver_patch}));
	// Initializations for module v.vcache :
	_const_v__vcache__process_pid = os__getpid();
	// Initializations for module term :
	// Initializations for module v.vmod :
	_const_v__vmod__mod_file_stop_paths = new_array_from_c_array(4, 4, sizeof(string), _MOV((string[4]){_SLIT(".git"), _SLIT(".hg"), _SLIT(".svn"), _SLIT(".v.mod.stop")}));
	_const_v__vmod__private_file_cacher = v__vmod__new_mod_file_cacher();
	// Initializations for module v.util.recompilation :
	// Initializations for module v.cflag :
	// Initializations for module rand.seed :
	// Initializations for module v.errors :
	// Initializations for module v.pkgconfig :
	_const_v__pkgconfig__default_paths = new_array_from_c_array(9, 9, sizeof(string), _MOV((string[9]){
		_SLIT("/usr/local/lib/x86_64-linux-gnu/pkgconfig"), _SLIT("/usr/local/lib64/pkgconfig"), _SLIT("/usr/local/lib/pkgconfig"), _SLIT("/usr/local/share/pkgconfig"), _SLIT("/usr/lib/x86_64-linux-gnu/pkgconfig"), _SLIT("/usr/lib64/pkgconfig"), _SLIT("/usr/lib/pkgconfig"), _SLIT("/usr/share/pkgconfig"), _SLIT("/opt/homebrew/lib/pkgconfig")}));
	// Initializations for module v.vet :
	// Initializations for module rand.wyrand :
	_const_rand__wyrand__wyp0 = ((u64)(0xa0761d6478bd642fU));
	_const_rand__wyrand__wyp1 = ((u64)(0xe7037ed1a0b428dbU));
	// Initializations for module rand :
	rand__init();
	// Initializations for module v.pref :
	_const_v__pref__default_module_path = os__vmodules_dir();
	_const_v__pref__list_of_flags_with_param = new_array_from_c_array(12, 12, sizeof(string), _MOV((string[12]){
		_SLIT("o"), _SLIT("d"), _SLIT("define"), _SLIT("b"), _SLIT("backend"), _SLIT("cc"), _SLIT("os"), _SLIT("target-os"), _SLIT("cf"), _SLIT("cflags"), _SLIT("path"), _SLIT("arch")}));
	// Initializations for module help :
	// Initializations for module v.util :
	_const_v__util__emanager = v__util__new_error_manager();
	_const_v__util__invalid_escapes = new_array_from_c_array(5, 5, sizeof(string), _MOV((string[5]){_SLIT("("), _SLIT("{"), _SLIT("$"), _SLIT("`"), _SLIT(".")}));
	_const_v__util__timers = v__util__new_timers(false);
	_const_v__util__builtin_module_parts = new_array_from_c_array(6, 6, sizeof(string), _MOV((string[6]){_SLIT("math.bits"), _SLIT("strconv"), _SLIT("strconv.ftoa"), _SLIT("hash"), _SLIT("strings"), _SLIT("builtin")}));
	_const_v__util__bundle_modules = new_array_from_c_array(7, 7, sizeof(string), _MOV((string[7]){_SLIT("clipboard"), _SLIT("fontstash"), _SLIT("gg"), _SLIT("gx"), _SLIT("sokol"), _SLIT("szip"), _SLIT("ui")}));
	_const_v__util__external_module_dependencies_for_tool = new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 1, sizeof(string), sizeof(Array_string), _MOV((string[1]){_SLIT("vdoc"), }), _MOV((Array_string[1]){new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("markdown")})), }));
	_const_v__util__const_tabs = new_array_from_c_array(10, 10, sizeof(string), _MOV((string[10]){
		_SLIT(""), _SLIT("\t"), _SLIT("\t\t"), _SLIT("\t\t\t"), _SLIT("\t\t\t\t"), _SLIT("\t\t\t\t\t"), _SLIT("\t\t\t\t\t\t"), _SLIT("\t\t\t\t\t\t\t"), _SLIT("\t\t\t\t\t\t\t\t"), _SLIT("\t\t\t\t\t\t\t\t\t")}));
	// Initializations for module v.ast :
	_const_v__ast__x86_no_number_register_list = new_map_init(&map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop, 4, sizeof(int), sizeof(Array_string), _MOV((int[4]){8, 16, 32, 64, }), _MOV((Array_string[4]){new_array_from_c_array(12, 12, sizeof(string), _MOV((string[12]){
		_SLIT("al"), _SLIT("ah"), _SLIT("bl"), _SLIT("bh"), _SLIT("cl"), _SLIT("ch"), _SLIT("dl"), _SLIT("dh"), _SLIT("bpl"), _SLIT("sil"), _SLIT("dil"), _SLIT("spl")})), new_array_from_c_array(23, 23, sizeof(string), _MOV((string[23]){
		_SLIT("ax"), _SLIT("bx"), _SLIT("cx"), _SLIT("dx"), _SLIT("bp"), _SLIT("si"), _SLIT("di"), _SLIT("sp"), _SLIT("cs"), _SLIT("ss"), _SLIT("ds"), _SLIT("es"), _SLIT("fs"), _SLIT("gs"), _SLIT("flags"), _SLIT("ip"), _SLIT("gdtr"), _SLIT("idtr"), _SLIT("tr"), _SLIT("ldtr"), _SLIT("fp_cs"), _SLIT("fp_ds"), _SLIT("fp_opc")})), new_array_from_c_array(11, 11, sizeof(string), _MOV((string[11]){
		_SLIT("eax"), _SLIT("ebx"), _SLIT("ecx"), _SLIT("edx"), _SLIT("ebp"), _SLIT("esi"), _SLIT("edi"), _SLIT("esp"), _SLIT("eflags"), _SLIT("eip"), _SLIT("mxcsr")})), new_array_from_c_array(10, 10, sizeof(string), _MOV((string[10]){
		_SLIT("rax"), _SLIT("rbx"), _SLIT("rcx"), _SLIT("rdx"), _SLIT("rbp"), _SLIT("rsi"), _SLIT("rdi"), _SLIT("rsp"), _SLIT("rflags"), _SLIT("rip")})), }));
	_const_v__ast__x86_with_number_register_list = new_map_init(&map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop, 8, sizeof(int), sizeof(Map_string_int), _MOV((int[8]){8, 16, 32, 64, 80, 128, 256, 512, }), _MOV((Map_string_int[8]){new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 1, sizeof(string), sizeof(int), _MOV((string[1]){_SLIT("r#b"), }), _MOV((int[1]){16, })), new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 1, sizeof(string), sizeof(int), _MOV((string[1]){_SLIT("r#w"), }), _MOV((int[1]){16, })), new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 1, sizeof(string), sizeof(int), _MOV((string[1]){_SLIT("r#d"), }), _MOV((int[1]){16, })), new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 4, sizeof(string), sizeof(int), _MOV((string[4]){_SLIT("r#"), _SLIT("mm#"), _SLIT("cr#"), _SLIT("dr#"), }), _MOV((int[4]){16, 16, 16, 16, })), new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 1, sizeof(string), sizeof(int), _MOV((string[1]){_SLIT("st#"), }), _MOV((int[1]){16, })), new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 1, sizeof(string), sizeof(int), _MOV((string[1]){_SLIT("xmm#"), }), _MOV((int[1]){32, })), new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 1, sizeof(string), sizeof(int), _MOV((string[1]){_SLIT("ymm#"), }), _MOV((int[1]){32, })), new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 1, sizeof(string), sizeof(int), _MOV((string[1]){_SLIT("zmm#"), }), _MOV((int[1]){32, })), }));
	_const_v__ast__arm_no_number_register_list = new_array_from_c_array(5, 5, sizeof(string), _MOV((string[5]){_SLIT("fp"), _SLIT("ip"), _SLIT("sp"), _SLIT("lr"), _SLIT("pc")}));
	_const_v__ast__arm_with_number_register_list = new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 1, sizeof(string), sizeof(int), _MOV((string[1]){_SLIT("r#"), }), _MOV((int[1]){16, }));
	_const_v__ast__riscv_no_number_register_list = new_array_from_c_array(5, 5, sizeof(string), _MOV((string[5]){_SLIT("zero"), _SLIT("ra"), _SLIT("sp"), _SLIT("gp"), _SLIT("tp")}));
	_const_v__ast__riscv_with_number_register_list = new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 4, sizeof(string), sizeof(int), _MOV((string[4]){_SLIT("x#"), _SLIT("t#"), _SLIT("s#"), _SLIT("a#"), }), _MOV((int[4]){32, 3, 12, 8, }));
	_const_v__ast__integer_type_idxs = new_array_from_c_array(10, 10, sizeof(int), _MOV((int[10]){
		_const_v__ast__i8_type_idx, _const_v__ast__i16_type_idx, _const_v__ast__int_type_idx, _const_v__ast__i64_type_idx, _const_v__ast__byte_type_idx, _const_v__ast__u16_type_idx, _const_v__ast__u32_type_idx, _const_v__ast__u64_type_idx, _const_v__ast__int_literal_type_idx, _const_v__ast__rune_type_idx}));
	_const_v__ast__signed_integer_type_idxs = new_array_from_c_array(4, 4, sizeof(int), _MOV((int[4]){_const_v__ast__i8_type_idx, _const_v__ast__i16_type_idx, _const_v__ast__int_type_idx, _const_v__ast__i64_type_idx}));
	_const_v__ast__unsigned_integer_type_idxs = new_array_from_c_array(4, 4, sizeof(int), _MOV((int[4]){_const_v__ast__byte_type_idx, _const_v__ast__u16_type_idx, _const_v__ast__u32_type_idx, _const_v__ast__u64_type_idx}));
	_const_v__ast__float_type_idxs = new_array_from_c_array(3, 3, sizeof(int), _MOV((int[3]){_const_v__ast__f32_type_idx, _const_v__ast__f64_type_idx, _const_v__ast__float_literal_type_idx}));
	_const_v__ast__number_type_idxs = new_array_from_c_array(13, 13, sizeof(int), _MOV((int[13]){
		_const_v__ast__i8_type_idx, _const_v__ast__i16_type_idx, _const_v__ast__int_type_idx, _const_v__ast__i64_type_idx, _const_v__ast__byte_type_idx, _const_v__ast__u16_type_idx, _const_v__ast__u32_type_idx, _const_v__ast__u64_type_idx, _const_v__ast__f32_type_idx, _const_v__ast__f64_type_idx, _const_v__ast__int_literal_type_idx, _const_v__ast__float_literal_type_idx, _const_v__ast__rune_type_idx}));
	_const_v__ast__pointer_type_idxs = new_array_from_c_array(3, 3, sizeof(int), _MOV((int[3]){_const_v__ast__voidptr_type_idx, _const_v__ast__byteptr_type_idx, _const_v__ast__charptr_type_idx}));
	_const_v__ast__string_type_idxs = new_array_from_c_array(2, 2, sizeof(int), _MOV((int[2]){_const_v__ast__string_type_idx, _const_v__ast__ustring_type_idx}));
	_const_v__ast__void_type = v__ast__new_type(_const_v__ast__void_type_idx);
	_const_v__ast__ovoid_type = v__ast__Type_set_flag(v__ast__new_type(_const_v__ast__void_type_idx), v__ast__TypeFlag_optional);
	_const_v__ast__voidptr_type = v__ast__new_type(_const_v__ast__voidptr_type_idx);
	_const_v__ast__byteptr_type = v__ast__new_type(_const_v__ast__byteptr_type_idx);
	_const_v__ast__charptr_type = v__ast__new_type(_const_v__ast__charptr_type_idx);
	_const_v__ast__i8_type = v__ast__new_type(_const_v__ast__i8_type_idx);
	_const_v__ast__int_type = v__ast__new_type(_const_v__ast__int_type_idx);
	_const_v__ast__i16_type = v__ast__new_type(_const_v__ast__i16_type_idx);
	_const_v__ast__i64_type = v__ast__new_type(_const_v__ast__i64_type_idx);
	_const_v__ast__byte_type = v__ast__new_type(_const_v__ast__byte_type_idx);
	_const_v__ast__u16_type = v__ast__new_type(_const_v__ast__u16_type_idx);
	_const_v__ast__u32_type = v__ast__new_type(_const_v__ast__u32_type_idx);
	_const_v__ast__u64_type = v__ast__new_type(_const_v__ast__u64_type_idx);
	_const_v__ast__f32_type = v__ast__new_type(_const_v__ast__f32_type_idx);
	_const_v__ast__f64_type = v__ast__new_type(_const_v__ast__f64_type_idx);
	_const_v__ast__char_type = v__ast__new_type(_const_v__ast__char_type_idx);
	_const_v__ast__bool_type = v__ast__new_type(_const_v__ast__bool_type_idx);
	_const_v__ast__none_type = v__ast__new_type(_const_v__ast__none_type_idx);
	_const_v__ast__string_type = v__ast__new_type(_const_v__ast__string_type_idx);
	_const_v__ast__ustring_type = v__ast__new_type(_const_v__ast__ustring_type_idx);
	_const_v__ast__rune_type = v__ast__new_type(_const_v__ast__rune_type_idx);
	_const_v__ast__array_type = v__ast__new_type(_const_v__ast__array_type_idx);
	_const_v__ast__map_type = v__ast__new_type(_const_v__ast__map_type_idx);
	_const_v__ast__chan_type = v__ast__new_type(_const_v__ast__chan_type_idx);
	_const_v__ast__any_type = v__ast__new_type(_const_v__ast__any_type_idx);
	_const_v__ast__float_literal_type = v__ast__new_type(_const_v__ast__float_literal_type_idx);
	_const_v__ast__int_literal_type = v__ast__new_type(_const_v__ast__int_literal_type_idx);
	_const_v__ast__thread_type = v__ast__new_type(_const_v__ast__thread_type_idx);
	_const_v__ast__error_type = v__ast__new_type(_const_v__ast__error_type_idx);
	_const_v__ast__builtin_type_names = new_array_from_c_array(32, 32, sizeof(string), _MOV((string[32]){
		_SLIT("void"), _SLIT("voidptr"), _SLIT("charptr"), _SLIT("byteptr"), _SLIT("i8"), _SLIT("i16"), _SLIT("int"), _SLIT("i64"), _SLIT("u16"), _SLIT("u32"), _SLIT("u64"), _SLIT("int_literal"), _SLIT("f32"), _SLIT("f64"), _SLIT("float_literal"), _SLIT("string"), _SLIT("ustring"), _SLIT("char"), _SLIT("byte"), _SLIT("bool"), _SLIT("none"), _SLIT("array"), _SLIT("array_fixed"), _SLIT("map"), _SLIT("chan"), _SLIT("any"), _SLIT("struct"), _SLIT("mapnode"), _SLIT("size_t"), _SLIT("rune"), _SLIT("thread"), _SLIT("Error")}));
	// Initializations for module v.scanner :
	// Initializations for module v.checker :
	_const_v__checker__int_min = ((int)(0x80000000));
	_const_v__checker__int_max = ((int)(0x7FFFFFFF));
	_const_v__checker__valid_comp_if_os = new_array_from_c_array(18, 18, sizeof(string), _MOV((string[18]){
		_SLIT("windows"), _SLIT("ios"), _SLIT("macos"), _SLIT("mach"), _SLIT("darwin"), _SLIT("hpux"), _SLIT("gnu"), _SLIT("qnx"), _SLIT("linux"), _SLIT("freebsd"), _SLIT("openbsd"), _SLIT("netbsd"), _SLIT("bsd"), _SLIT("dragonfly"), _SLIT("android"), _SLIT("solaris"), _SLIT("haiku"), _SLIT("linux_or_macos")}));
	_const_v__checker__valid_comp_if_compilers = new_array_from_c_array(6, 6, sizeof(string), _MOV((string[6]){_SLIT("gcc"), _SLIT("tinyc"), _SLIT("clang"), _SLIT("mingw"), _SLIT("msvc"), _SLIT("cplusplus")}));
	_const_v__checker__valid_comp_if_platforms = new_array_from_c_array(6, 6, sizeof(string), _MOV((string[6]){_SLIT("amd64"), _SLIT("aarch64"), _SLIT("x64"), _SLIT("x32"), _SLIT("little_endian"), _SLIT("big_endian")}));
	_const_v__checker__valid_comp_if_other = new_array_from_c_array(8, 8, sizeof(string), _MOV((string[8]){_SLIT("js"), _SLIT("debug"), _SLIT("prod"), _SLIT("test"), _SLIT("glibc"), _SLIT("prealloc"), _SLIT("no_bounds_checking"), _SLIT("freestanding")}));
	_const_v__checker__array_builtin_methods = new_array_from_c_array(15, 15, sizeof(string), _MOV((string[15]){
		_SLIT("filter"), _SLIT("clone"), _SLIT("repeat"), _SLIT("reverse"), _SLIT("map"), _SLIT("slice"), _SLIT("sort"), _SLIT("contains"), _SLIT("index"), _SLIT("wait"), _SLIT("any"), _SLIT("all"), _SLIT("first"), _SLIT("last"), _SLIT("pop")}));
	// Initializations for module v.parser :
	_const_v__parser__supported_comptime_calls = new_array_from_c_array(4, 4, sizeof(string), _MOV((string[4]){_SLIT("html"), _SLIT("tmpl"), _SLIT("env"), _SLIT("embed_file")}));
	_const_v__parser__builtin_functions = new_array_from_c_array(7, 7, sizeof(string), _MOV((string[7]){_SLIT("print"), _SLIT("println"), _SLIT("eprint"), _SLIT("eprintln"), _SLIT("isnil"), _SLIT("panic"), _SLIT("exit")}));
	_const_v__parser__global_enabled_mods = new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT("rand"), _SLIT("sokol.sapp")}));
	// Initializations for module v.gen.c :
	_const_v__gen__c__c_reserved = new_array_from_c_array(49, 49, sizeof(string), _MOV((string[49]){
		_SLIT("auto"), _SLIT("break"), _SLIT("calloc"), _SLIT("case"), _SLIT("char"), _SLIT("class"), _SLIT("const"), _SLIT("continue"), _SLIT("default"), _SLIT("delete"), _SLIT("do"), _SLIT("double"), _SLIT("else"), _SLIT("enum"), _SLIT("error"), _SLIT("exit"), _SLIT("export"), _SLIT("extern"), _SLIT("float"), _SLIT("for"), _SLIT("free"), _SLIT("goto"), _SLIT("if"), _SLIT("inline"), _SLIT("int"), _SLIT("link"), _SLIT("long"), _SLIT("malloc"), _SLIT("namespace"), _SLIT("new"), _SLIT("panic"), _SLIT("register"), _SLIT("restrict"), _SLIT("return"), _SLIT("short"), _SLIT("signed"), _SLIT("sizeof"), _SLIT("static"), _SLIT("struct"), _SLIT("switch"), _SLIT("typedef"), _SLIT("typename"), _SLIT("union"), _SLIT("unix"), _SLIT("unsigned"), _SLIT("void"), _SLIT("volatile"), _SLIT("while"), _SLIT("template")}));
	_const_v__gen__c__cmp_str = new_array_from_c_array(6, 6, sizeof(string), _MOV((string[6]){_SLIT("eq"), _SLIT("ne"), _SLIT("gt"), _SLIT("lt"), _SLIT("ge"), _SLIT("le")}));
	_const_v__gen__c__cmp_rev = new_array_from_c_array(6, 6, sizeof(string), _MOV((string[6]){_SLIT("eq"), _SLIT("ne"), _SLIT("lt"), _SLIT("gt"), _SLIT("le"), _SLIT("ge")}));
	_const_v__gen__c__skip_struct_init = new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT("struct stat"), _SLIT("struct addrinfo")}));
	_const_v__gen__c__builtins = new_array_from_c_array(8, 8, sizeof(string), _MOV((string[8]){_SLIT("string"), _SLIT("array"), _SLIT("DenseArray"), _SLIT("map"), _SLIT("Error"), _SLIT("IError"), _SLIT("Option2"), _SLIT("Option")}));
	_const_v__gen__c__c_headers = _STR("\n// c_headers\ntypedef int (*qsort_callback_func)(const void*, const void*);\n#include <stdio.h>  // TODO remove all these includes, define all function signatures and types manually\n#include <stdlib.h>\n\n#if defined(_WIN32) || defined(__CYGWIN__)\n	#define VV_EXPORTED_SYMBOL extern __declspec(dllexport)\n	#define VV_LOCAL_SYMBOL static\n#else\n	// 4 < gcc < 5 is used by some older Ubuntu LTS and Centos versions,\n	// and does not support __has_attribute(visibility) ...\n	#ifndef __has_attribute\n		#define __has_attribute(x) 0  // Compatibility with non-clang compilers.\n	#endif\n	#if (defined(__GNUC__) && (__GNUC__ >= 4)) || (defined(__clang__) && __has_attribute(visibility))\n		#ifdef ARM\n			#define VV_EXPORTED_SYMBOL  extern __attribute__((externally_visible,visibility(\"default\")))\n		#else\n			#define VV_EXPORTED_SYMBOL  extern __attribute__((visibility(\"default\")))\n		#endif\n		#define VV_LOCAL_SYMBOL  __attribute__ ((visibility (\"hidden\")))\n	#else\n		#define VV_EXPORTED_SYMBOL extern\n		#define VV_LOCAL_SYMBOL static\n	#endif\n#endif\n\n#ifdef __cplusplus\n	#include <utility>\n	#define _MOV std::move\n#else\n	#define _MOV\n#endif\n\n#if defined(__TINYC__) && defined(__has_include)\n// tcc does not support has_include properly yet, turn it off completely\n#undef __has_include\n#endif\n\n#ifndef _WIN32\n	#if defined __has_include\n		#if __has_include (<execinfo.h>)\n			#include <execinfo.h>\n		#else\n			// Most probably musl OR __ANDROID__ ...\n			int backtrace (void **__array, int __size) { return 0; }\n			char **backtrace_symbols (void *const *__array, int __size){ return 0; }\n			void backtrace_symbols_fd (void *const *__array, int __size, int __fd){}\n		#endif\n	#endif\n#endif\n\n//#include \"fns.h\"\n#include <signal.h>\n#include <stdarg.h> // for va_list\n#include <string.h> // memcpy\n\n#if INTPTR_MAX == INT32_MAX\n	#define TARGET_IS_32BIT 1\n#elif INTPTR_MAX == INT64_MAX\n	#define TARGET_IS_64BIT 1\n#else\n	#error \"The environment is not 32 or 64-bit.\"\n#endif\n\n#if defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__ || defined(__BYTE_ORDER) && __BYTE_ORDER == __BIG_ENDIAN || defined(__BIG_ENDIAN__) || defined(__ARMEB__) || defined(__THUMBEB__) || defined(__AARCH64EB__) || defined(_MIBSEB) || defined(__MIBSEB) || defined(__MIBSEB__)\n	#define TARGET_ORDER_IS_BIG\n#elif defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__ || defined(__BYTE_ORDER) && __BYTE_ORDER == __LITTLE_ENDIAN || defined(__LITTLE_ENDIAN__) || defined(__ARMEL__) || defined(__THUMBEL__) || defined(__AARCH64EL__) || defined(_MIPSEL) || defined(__MIPSEL) || defined(__MIPSEL__) || defined(_M_AMD64) || defined(_M_X64) || defined(_M_IX86)\n	#define TARGET_ORDER_IS_LITTLE\n#else\n	#error \"Unknown architecture endianness\"\n#endif\n\n#ifndef _WIN32\n	#include <ctype.h>\n	#include <locale.h> // tolower\n	#include <sys/time.h>\n	#include <unistd.h> // sleep\n	extern char **environ;\n#endif\n\n#if defined(__CYGWIN__) && !defined(_WIN32)\n	#error Cygwin is not supported, please use MinGW or Visual Studio.\n#endif\n\n#ifdef __linux__\n	#include <sys/types.h>\n	#include <sys/wait.h> // os__wait uses wait on nix\n#endif\n\n#ifdef __FreeBSD__\n	#include <sys/types.h>\n	#include <sys/wait.h> // os__wait uses wait on nix\n#endif\n\n#ifdef __DragonFly__\n	#include <sys/types.h>\n	#include <sys/wait.h> // os__wait uses wait on nix\n#endif\n\n#ifdef __OpenBSD__\n	#include <sys/types.h>\n	#include <sys/resource.h>\n	#include <sys/wait.h> // os__wait uses wait on nix\n#endif\n\n#ifdef __NetBSD__\n	#include <sys/wait.h> // os__wait uses wait on nix\n#endif\n\n#ifdef __sun\n	#include <sys/types.h>\n	#include <sys/wait.h> // os__wait uses wait on nix\n#endif\n\n%.*s\000\n\n#ifdef _WIN32\n	#define WINVER 0x0600\n	#ifdef _WIN32_WINNT\n		#undef _WIN32_WINNT\n	#endif\n	#define _WIN32_WINNT 0x0600\n	#ifndef WIN32_FULL\n	#define WIN32_LEAN_AND_MEAN\n	#endif\n	#ifndef _UNICODE\n	#define _UNICODE\n	#endif\n	#ifndef UNICODE\n	#define UNICODE\n	#endif\n	#include <windows.h>\n\n	#include <io.h> // _waccess\n	#include <direct.h> // _wgetcwd\n\n	#ifdef _MSC_VER\n		// On MSVC these are the same (as long as /volatile:ms is passed)\n		#define _Atomic volatile\n\n		// MSVC cannot parse some things properly\n		#undef EMPTY_STRUCT_DECLARATION\n		#undef OPTION_CAST\n\n		#define EMPTY_STRUCT_DECLARATION int ____dummy_variable\n		#define OPTION_CAST(x)\n		#undef __NOINLINE\n		#undef __IRQHANDLER\n		#define __NOINLINE __declspec(noinline)\n		#define __IRQHANDLER __declspec(naked)\n\n		#include <dbghelp.h>\n		#pragma comment(lib, \"Dbghelp\")\n	#endif\n#else\n	#include <pthread.h>\n	#ifndef PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP\n		// musl does not have that\n		#define pthread_rwlockattr_setkind_np(a, b)\n	#endif\n#endif\n\n// g_live_info is used by live.info()\nstatic void* g_live_info = NULL;\n\n//============================== HELPER C MACROS =============================*/\n//#define tos4(s, slen) ((string){.str=(s), .len=(slen)})\n// `\"\" s` is used to enforce a string literal argument\n#define _SLIT(s) ((string){.str=(byteptr)(\"\" s), .len=(sizeof(s)-1), .is_lit=1})\n// take the address of an rvalue\n#define ADDR(type, expr) (&((type[]){expr}[0]))\n// copy something to the heap\n#define HEAP(type, expr) ((type*)memdup((void*)&((type[]){expr}[0]), sizeof(type)))\n#define _PUSH_MANY(arr, val, tmp, tmp_typ) {tmp_typ tmp = (val); array_push_many(arr, tmp.data, tmp.len);}\n#define _IN_MAP(val, m) map_exists(m, val)\n\n// unsigned/signed comparisons\nstatic inline bool _us32_gt(uint32_t a, int32_t b) { return a > INT32_MAX || (int32_t)a > b; }\nstatic inline bool _us32_ge(uint32_t a, int32_t b) { return a >= INT32_MAX || (int32_t)a >= b; }\nstatic inline bool _us32_eq(uint32_t a, int32_t b) { return a <= INT32_MAX && (int32_t)a == b; }\nstatic inline bool _us32_ne(uint32_t a, int32_t b) { return a > INT32_MAX || (int32_t)a != b; }\nstatic inline bool _us32_le(uint32_t a, int32_t b) { return a <= INT32_MAX && (int32_t)a <= b; }\nstatic inline bool _us32_lt(uint32_t a, int32_t b) { return a < INT32_MAX && (int32_t)a < b; }\nstatic inline bool _us64_gt(uint64_t a, int64_t b) { return a > INT64_MAX || (int64_t)a > b; }\nstatic inline bool _us64_ge(uint64_t a, int64_t b) { return a >= INT64_MAX || (int64_t)a >= b; }\nstatic inline bool _us64_eq(uint64_t a, int64_t b) { return a <= INT64_MAX && (int64_t)a == b; }\nstatic inline bool _us64_ne(uint64_t a, int64_t b) { return a > INT64_MAX || (int64_t)a != b; }\nstatic inline bool _us64_le(uint64_t a, int64_t b) { return a <= INT64_MAX && (int64_t)a <= b; }\nstatic inline bool _us64_lt(uint64_t a, int64_t b) { return a < INT64_MAX && (int64_t)a < b; }\n\n#if defined(__MINGW32__) || defined(__MINGW64__) || (defined(_WIN32) && defined(__TINYC__))\n	#undef PRId64\n	#undef PRIi64\n	#undef PRIo64\n	#undef PRIu64\n	#undef PRIx64\n	#undef PRIX64\n	#define PRId64 \"lld\"\n	#define PRIi64 \"lli\"\n	#define PRIo64 \"llo\"\n	#define PRIu64 \"llu\"\n	#define PRIx64 \"llx\"\n	#define PRIX64 \"llX\"\n#endif\n\n//================================== GLOBALS =================================*/\n//byte g_str_buf[1024];\nbyte* g_str_buf;\nint load_so(byteptr);\nvoid reload_so();\nvoid _vinit(int ___argc, voidptr ___argv);\nvoid _vcleanup();\n#define sigaction_size sizeof(sigaction);\n#define _ARR_LEN(a) ( (sizeof(a)) / (sizeof(a[0])) )\n\n// ============== wyhash ==============\n#ifndef wyhash_final_version_3\n#define wyhash_final_version_3\n\n#ifndef WYHASH_CONDOM\n//protections that produce different results:\n//1: normal valid behavior\n//2: extra protection against entropy loss (probability=2^-63), aka. \"blind multiplication\"\n#define WYHASH_CONDOM 1\n#endif\n\n#ifndef WYHASH_32BIT_MUM\n//0: normal version, slow on 32 bit systems\n//1: faster on 32 bit systems but produces different results, incompatible with wy2u0k function\n#define WYHASH_32BIT_MUM 0\n#endif\n\n//includes\n#include <stdint.h>\n#include <string.h>\n#if defined(_MSC_VER) && defined(_M_X64)\n	#include <intrin.h>\n	#pragma intrinsic(_umul128)\n#endif\n\n//likely and unlikely macros\n#if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)\n	#define _likely_(x)  __builtin_expect(x,1)\n	#define _unlikely_(x)  __builtin_expect(x,0)\n#else\n	#define _likely_(x) (x)\n	#define _unlikely_(x) (x)\n#endif\n\n//128bit multiply function\nstatic inline uint64_t _wyrot(uint64_t x) { return (x>>32)|(x<<32); }\nstatic inline void _wymum(uint64_t *A, uint64_t *B){\n#if(WYHASH_32BIT_MUM)\n	uint64_t hh=(*A>>32)*(*B>>32), hl=(*A>>32)*(uint32_t)*B, lh=(uint32_t)*A*(*B>>32), ll=(uint64_t)(uint32_t)*A*(uint32_t)*B;\n	#if(WYHASH_CONDOM>1)\n	*A^=_wyrot(hl)^hh; *B^=_wyrot(lh)^ll;\n	#else\n	*A=_wyrot(hl)^hh; *B=_wyrot(lh)^ll;\n	#endif\n#elif defined(__SIZEOF_INT128__)\n	__uint128_t r=*A; r*=*B;\n	#if(WYHASH_CONDOM>1)\n	*A^=(uint64_t)r; *B^=(uint64_t)(r>>64);\n	#else\n	*A=(uint64_t)r; *B=(uint64_t)(r>>64);\n	#endif\n#elif defined(_MSC_VER) && defined(_M_X64)\n	#if(WYHASH_CONDOM>1)\n	uint64_t  a,  b;\n	a=_umul128(*A,*B,&b);\n	*A^=a;  *B^=b;\n	#else\n	*A=_umul128(*A,*B,B);\n	#endif\n#else\n	uint64_t ha=*A>>32, hb=*B>>32, la=(uint32_t)*A, lb=(uint32_t)*B, hi, lo;\n	uint64_t rh=ha*hb, rm0=ha*lb, rm1=hb*la, rl=la*lb, t=rl+(rm0<<32), c=t<rl;\n	lo=t+(rm1<<32); c+=lo<t; hi=rh+(rm0>>32)+(rm1>>32)+c;\n	#if(WYHASH_CONDOM>1)\n	*A^=lo;  *B^=hi;\n	#else\n	*A=lo;  *B=hi;\n	#endif\n#endif\n}\n\n//multiply and xor mix function, aka MUM\nstatic inline uint64_t _wymix(uint64_t A, uint64_t B){ _wymum(&A,&B); return A^B; }\n\n//endian macros\n#ifndef WYHASH_LITTLE_ENDIAN\n	#if defined(_WIN32) || defined(__LITTLE_ENDIAN__) || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)\n		#define WYHASH_LITTLE_ENDIAN 1\n	#elif defined(__BIG_ENDIAN__) || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)\n		#define WYHASH_LITTLE_ENDIAN 0\n	#else\n		#warning could not determine endianness! Falling back to little endian.\n		#define WYHASH_LITTLE_ENDIAN 1\n	#endif\n#endif\n\n//read functions\n#if (WYHASH_LITTLE_ENDIAN)\nstatic inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return v;}\nstatic inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&v, p, 4); return v;}\n#elif defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)\nstatic inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return __builtin_bswap64(v);}\nstatic inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&v, p, 4); return __builtin_bswap32(v);}\n#elif defined(_MSC_VER)\nstatic inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return _byteswap_uint64(v);}\nstatic inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&v, p, 4); return _byteswap_ulong(v);}\n#else\nstatic inline uint64_t _wyr8(const uint8_t *p) {\n	uint64_t v; memcpy(&v, p, 8);\n	return (((v >> 56) & 0xff)| ((v >> 40) & 0xff00)| ((v >> 24) & 0xff0000)| ((v >>  8) & 0xff000000)| ((v <<  8) & 0xff00000000)| ((v << 24) & 0xff0000000000)| ((v << 40) & 0xff000000000000)| ((v << 56) & 0xff00000000000000));\n}\nstatic inline uint64_t _wyr4(const uint8_t *p) {\n	uint32_t v; memcpy(&v, p, 4);\n	return (((v >> 24) & 0xff)| ((v >>  8) & 0xff00)| ((v <<  8) & 0xff0000)| ((v << 24) & 0xff000000));\n}\n#endif\nstatic inline uint64_t _wyr3(const uint8_t *p, size_t k) { return (((uint64_t)p[0])<<16)|(((uint64_t)p[k>>1])<<8)|p[k-1];}\n\n//wyhash main function\nstatic inline uint64_t wyhash(const void *key, size_t len, uint64_t seed, const uint64_t *secret){\n	const uint8_t *p=(const uint8_t *)key; seed^=*secret;	uint64_t	a,	b;\n	if(_likely_(len<=16)){\n		if(_likely_(len>=4)){ a=(_wyr4(p)<<32)|_wyr4(p+((len>>3)<<2)); b=(_wyr4(p+len-4)<<32)|_wyr4(p+len-4-((len>>3)<<2)); }\n		else if(_likely_(len>0)){ a=_wyr3(p,len); b=0;}\n		else a=b=0;\n	}\n	else{\n		size_t i=len;\n		if(_unlikely_(i>48)){\n			uint64_t see1=seed, see2=seed;\n			do{\n				seed=_wymix(_wyr8(p)^secret[1],_wyr8(p+8)^seed);\n				see1=_wymix(_wyr8(p+16)^secret[2],_wyr8(p+24)^see1);\n				see2=_wymix(_wyr8(p+32)^secret[3],_wyr8(p+40)^see2);\n				p+=48; i-=48;\n			}while(_likely_(i>48));\n			seed^=see1^see2;\n		}\n		while(_unlikely_(i>16)){  seed=_wymix(_wyr8(p)^secret[1],_wyr8(p+8)^seed);  i-=16; p+=16;  }\n		a=_wyr8(p+i-16);  b=_wyr8(p+i-8);\n	}\n	return _wymix(secret[1]^len,_wymix(a^secret[1],b^seed));\n}\n//the default secret parameters\nstatic const uint64_t _wyp[4] = {0xa0761d6478bd642full, 0xe7037ed1a0b428dbull, 0x8ebc6af09c88c6e3ull, 0x589965cc75374cc3ull};\n\n//a useful 64bit-64bit mix function to produce deterministic pseudo random numbers that can pass BigCrush and PractRand\nstatic inline uint64_t wyhash64(uint64_t A, uint64_t B){ A^=_wyp[0]; B^=_wyp[1]; _wymum(&A,&B); return _wymix(A^_wyp[0],B^_wyp[1]);}\n\n//The wyrand PRNG that pass BigCrush and PractRand\nstatic inline uint64_t wyrand(uint64_t *seed){ *seed+=_wyp[0]; return _wymix(*seed,*seed^_wyp[1]);}\n\n//convert any 64 bit pseudo random numbers to uniform distribution [0,1). It can be combined with wyrand, wyhash64 or wyhash.\nstatic inline double wy2u01(uint64_t r){ const double _wynorm=1.0/(1ull<<52); return (r>>12)*_wynorm;}\n\n//convert any 64 bit pseudo random numbers to APPROXIMATE Gaussian distribution. It can be combined with wyrand, wyhash64 or wyhash.\nstatic inline double wy2gau(uint64_t r){ const double _wynorm=1.0/(1ull<<20); return ((r&0x1fffff)+((r>>21)&0x1fffff)+((r>>42)&0x1fffff))*_wynorm-3.0;}\n\n#if(!WYHASH_32BIT_MUM)\n//fast range integer random number generation on [0,k) credit to Daniel Lemire. May not work when WYHASH_32BIT_MUM=1. It can be combined with wyrand, wyhash64 or wyhash.\nstatic inline uint64_t wy2u0k(uint64_t r, uint64_t k){ _wymum(&r,&k); return k; }\n#endif\n\n//make your own secret\nstatic inline void make_secret(uint64_t seed, uint64_t *secret){\n	uint8_t c[] = {15, 23, 27, 29, 30, 39, 43, 45, 46, 51, 53, 54, 57, 58, 60, 71, 75, 77, 78, 83, 85, 86, 89, 90, 92, 99, 101, 102, 105, 106, 108, 113, 114, 116, 120, 135, 139, 141, 142, 147, 149, 150, 153, 154, 156, 163, 165, 166, 169, 170, 172, 177, 178, 180, 184, 195, 197, 198, 201, 202, 204, 209, 210, 212, 216, 225, 226, 228, 232, 240 };\n	for(size_t i=0;i<4;i++){\n		uint8_t ok;\n		do{\n			ok=1; secret[i]=0;\n			for(size_t j=0;j<64;j+=8) secret[i]|=((uint64_t)c[wyrand(&seed)%%sizeof(c)])<<j;\n			if(secret[i]%%2==0){ ok=0; continue; }\n			for(size_t j=0;j<i;j++) {\n#if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)\n				if(__builtin_popcountll(secret[j]^secret[i])!=32){ ok=0; break; }\n#elif defined(_MSC_VER) && defined(_M_X64)\n				if(_mm_popcnt_u64(secret[j]^secret[i])!=32){ ok=0; break; }\n#else\n				//manual popcount\n				uint64_t x = secret[j]^secret[i];\n				x -= (x >> 1) & 0x5555555555555555;\n				x = (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333);\n				x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0f;\n				x = (x * 0x0101010101010101) >> 56;\n				if(x!=32){ ok=0; break; }\n#endif\n			}\n				if(!ok)continue;\n				for(uint64_t j=3;j<0x100000000ull;j+=2) if(secret[i]%%j==0){ ok=0; break; }\n		}while(!ok);\n	}\n}\n#endif\n\nvoid v_free(voidptr ptr);\nvoidptr memdup(voidptr src, int sz);\nstatic voidptr memfreedup(voidptr ptr, voidptr src, int sz) {\n	v_free(ptr);\n	return memdup(src, sz);\n}\n", 2, _const_v__gen__c__c_common_macros);
	_const_v__gen__c__bare_c_headers = _STR("\n%.*s\000\n\n#ifndef exit\n#define exit(rc) sys_exit(rc)\nvoid sys_exit (int);\n#endif\n", 2, _const_v__gen__c__c_common_macros);
	// Initializations for module v.markused :
	// Initializations for module v.gen.js :
	_const_v__gen__js__js_reserved = new_array_from_c_array(48, 48, sizeof(string), _MOV((string[48]){
		_SLIT("await"), _SLIT("break"), _SLIT("case"), _SLIT("catch"), _SLIT("class"), _SLIT("const"), _SLIT("continue"), _SLIT("debugger"), _SLIT("default"), _SLIT("delete"), _SLIT("do"), _SLIT("else"), _SLIT("enum"), _SLIT("export"), _SLIT("extends"), _SLIT("finally"), _SLIT("for"), _SLIT("function"), _SLIT("if"), _SLIT("implements"), _SLIT("import"), _SLIT("in"), _SLIT("instanceof"), _SLIT("interface"), _SLIT("let"), _SLIT("new"), _SLIT("package"), _SLIT("private"), _SLIT("protected"), _SLIT("public"), _SLIT("return"), _SLIT("static"), _SLIT("super"), _SLIT("switch"), _SLIT("this"), _SLIT("throw"), _SLIT("try"), _SLIT("typeof"), _SLIT("var"), _SLIT("void"), _SLIT("while"), _SLIT("with"), _SLIT("yield"), _SLIT("Number"), _SLIT("String"), _SLIT("Boolean"), _SLIT("Array"), _SLIT("Map")}));
	_const_v__gen__js__v_types = new_array_from_c_array(17, 17, sizeof(string), _MOV((string[17]){
		_SLIT("i8"), _SLIT("i16"), _SLIT("int"), _SLIT("i64"), _SLIT("byte"), _SLIT("u16"), _SLIT("u32"), _SLIT("u64"), _SLIT("f32"), _SLIT("f64"), _SLIT("int_literal"), _SLIT("float_literal"), _SLIT("size_t"), _SLIT("bool"), _SLIT("string"), _SLIT("map"), _SLIT("array")}));
	_const_v__gen__js__shallow_equatables = new_array_from_c_array(15, 15, sizeof(v__ast__Kind), _MOV((v__ast__Kind[15]){
		v__ast__Kind_i8, v__ast__Kind_i16, v__ast__Kind_int, v__ast__Kind_i64, v__ast__Kind_byte, v__ast__Kind_u16, v__ast__Kind_u32, v__ast__Kind_u64, v__ast__Kind_f32, v__ast__Kind_f64, v__ast__Kind_int_literal, v__ast__Kind_float_literal, v__ast__Kind_size_t, v__ast__Kind_bool, v__ast__Kind_string}));
	// Initializations for module v.gen.x64 :
	_const_v__gen__x64__mag0 = ((byte)(0x7f));
	_const_v__gen__x64__fn_arg_registers = new_array_from_c_array(6, 6, sizeof(v__gen__x64__Register), _MOV((v__gen__x64__Register[6]){v__gen__x64__Register_rdi, v__gen__x64__Register_rsi, v__gen__x64__Register_rdx, v__gen__x64__Register_rcx, v__gen__x64__Register_r8, v__gen__x64__Register_r9}));
	// Initializations for module v.builder :
	_const_v__builder__hkey_local_machine = ((v__builder__RegKey)(0x80000002));
	_const_v__builder__key_query_value = (0x0001);
	_const_v__builder__key_wow64_32key = (0x0200);
	_const_v__builder__key_enumerate_sub_keys = (0x0008);
	// Initializations for module main :
	_const_main__external_tools = new_array_from_c_array(26, 26, sizeof(string), _MOV((string[26]){
		_SLIT("fmt"), _SLIT("up"), _SLIT("vet"), _SLIT("self"), _SLIT("tracev"), _SLIT("symlink"), _SLIT("bin2v"), _SLIT("test"), _SLIT("test-all"), _SLIT("test-fmt"), _SLIT("test-parser"), _SLIT("test-self"), _SLIT("test-fixed"), _SLIT("test-compiler"), _SLIT("test-compiler-full"), _SLIT("test-cleancode"), _SLIT("check-md"), _SLIT("repl"), _SLIT("complete"), _SLIT("build-tools"), _SLIT("build-examples"), _SLIT("build-vbinaries"), _SLIT("setup-freetype"), _SLIT("wipe-cache"), _SLIT("doc"), _SLIT("doctor")}));
	_const_main__list_of_flags_that_allow_duplicates = new_array_from_c_array(5, 5, sizeof(string), _MOV((string[5]){_SLIT("cc"), _SLIT("d"), _SLIT("define"), _SLIT("cf"), _SLIT("cflags")}));
}
void _vcleanup() {
}

int wmain(int ___argc, wchar_t* ___argv[], wchar_t* ___envp[]){
	_vinit(___argc, (voidptr)___argv);
	main__main();
	_vcleanup();
	return 0;
}

// THE END.

