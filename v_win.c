#define V_COMMIT_HASH "80c4b8a"

#ifndef V_COMMIT_HASH
	#define V_COMMIT_HASH "a6f1667"
#endif

#ifndef V_CURRENT_COMMIT_HASH
	#define V_CURRENT_COMMIT_HASH "80c4b8a"
#endif

// V comptime_defines:

// V typedefs:

typedef struct {
	void* _object;
	int _interface_idx;
} _Interface;

typedef struct v__ast__TypeDecl v__ast__TypeDecl;
typedef struct v__ast__Expr v__ast__Expr;
typedef struct v__ast__Stmt v__ast__Stmt;
typedef struct v__ast__ScopeObject v__ast__ScopeObject;
typedef struct v__ast__IdentInfo v__ast__IdentInfo;
typedef struct v__table__FExpr v__table__FExpr;
typedef struct v__table__TypeInfo v__table__TypeInfo;
typedef struct strings__Builder strings__Builder;
typedef struct strconv__BF_param strconv__BF_param;
typedef struct strconv__PrepNumber strconv__PrepNumber;
typedef struct strconv__Dec32 strconv__Dec32;
typedef struct strconv__Dec64 strconv__Dec64;
typedef struct strconv__Uint128 strconv__Uint128;
typedef union strconv__Uf32 strconv__Uf32;
typedef union strconv__Uf64 strconv__Uf64;
typedef union strconv__Float64u strconv__Float64u;
typedef struct array array;
typedef struct VAssertMetaInfo VAssertMetaInfo;
typedef struct MethodArgs MethodArgs;
typedef struct FunctionData FunctionData;
typedef struct FieldData FieldData;
typedef struct SymbolInfo SymbolInfo;
typedef struct SymbolInfoContainer SymbolInfoContainer;
typedef struct Line64 Line64;
typedef struct ExceptionRecord ExceptionRecord;
typedef struct ContextRecord ContextRecord;
typedef struct ExceptionPointers ExceptionPointers;
typedef struct DenseArray DenseArray;
typedef struct map map;
typedef struct OptionBase OptionBase;
typedef struct Option Option;
typedef struct SortedMap SortedMap;
typedef struct mapnode mapnode;
typedef struct string string;
typedef struct ustring ustring;
typedef struct RepIndex RepIndex;
typedef struct os__File os__File;
typedef struct os__FileInfo os__FileInfo;
typedef struct os__FilePermission os__FilePermission;
typedef struct os__FileMode os__FileMode;
typedef struct os__Result os__Result;
typedef struct os__Uname os__Uname;
typedef struct os__Filetime os__Filetime;
typedef struct os__Win32finddata os__Win32finddata;
typedef struct os__ProcessInformation os__ProcessInformation;
typedef struct os__StartupInfo os__StartupInfo;
typedef struct os__SecurityAttributes os__SecurityAttributes;
typedef struct os__ExceptionRecord os__ExceptionRecord;
typedef struct os__ContextRecord os__ContextRecord;
typedef struct os__ExceptionPointers os__ExceptionPointers;
typedef struct os__Process os__Process;
typedef struct time__StopWatchOptions time__StopWatchOptions;
typedef struct time__StopWatch time__StopWatch;
typedef struct time__Time time__Time;
typedef struct time__SystemTime time__SystemTime;
typedef struct v__token__Position v__token__Position;
typedef struct v__token__Token v__token__Token;
typedef struct v__depgraph__DepGraphNode v__depgraph__DepGraphNode;
typedef struct v__depgraph__DepGraph v__depgraph__DepGraph;
typedef struct v__depgraph__OrderedDepMap v__depgraph__OrderedDepMap;
typedef struct flag__Flag flag__Flag;
typedef struct flag__FlagParser flag__FlagParser;
typedef struct semver__RawVersion semver__RawVersion;
typedef struct semver__Comparator semver__Comparator;
typedef struct semver__ComparatorSet semver__ComparatorSet;
typedef struct semver__Range semver__Range;
typedef struct semver__Version semver__Version;
typedef struct v__vcache__CacheManager v__vcache__CacheManager;
typedef struct term__Coord term__Coord;
typedef struct term__Coord16 term__Coord16;
typedef struct term__SmallRect term__SmallRect;
typedef struct term__ConsoleScreenBufferInfo term__ConsoleScreenBufferInfo;
typedef struct v__vmod__Manifest v__vmod__Manifest;
typedef struct v__vmod__Scanner v__vmod__Scanner;
typedef struct v__vmod__Parser v__vmod__Parser;
typedef struct v__vmod__Token v__vmod__Token;
typedef struct v__vmod__ModFileAndFolder v__vmod__ModFileAndFolder;
typedef struct v__vmod__ModFileCacher v__vmod__ModFileCacher;
typedef struct v__cflag__CFlag v__cflag__CFlag;
typedef struct v__errors__Error v__errors__Error;
typedef struct v__errors__Warning v__errors__Warning;
typedef struct v__pkgconfig__Main v__pkgconfig__Main;
typedef struct v__pkgconfig__MainOptions v__pkgconfig__MainOptions;
typedef struct v__pkgconfig__Options v__pkgconfig__Options;
typedef struct v__pkgconfig__PkgConfig v__pkgconfig__PkgConfig;
typedef struct v__table__Attr v__table__Attr;
typedef struct v__table__Table v__table__Table;
typedef struct v__table__Fn v__table__Fn;
typedef struct v__table__Param v__table__Param;
typedef struct v__table__Var v__table__Var;
typedef struct v__table__TypeSymbol v__table__TypeSymbol;
typedef struct v__table__MultiReturn v__table__MultiReturn;
typedef struct v__table__FnType v__table__FnType;
typedef struct v__table__Struct v__table__Struct;
typedef struct v__table__GenericStructInst v__table__GenericStructInst;
typedef struct v__table__Interface v__table__Interface;
typedef struct v__table__Enum v__table__Enum;
typedef struct v__table__Alias v__table__Alias;
typedef struct v__table__Aggregate v__table__Aggregate;
typedef struct v__table__Field v__table__Field;
typedef struct v__table__Array v__table__Array;
typedef struct v__table__ArrayFixed v__table__ArrayFixed;
typedef struct v__table__Chan v__table__Chan;
typedef struct v__table__Map v__table__Map;
typedef struct v__table__SumType v__table__SumType;
typedef struct v__table__FnSignatureOpts v__table__FnSignatureOpts;
typedef struct rand__wyrand__WyRandRNG rand__wyrand__WyRandRNG;
typedef struct rand__PRNGConfigStruct rand__PRNGConfigStruct;
typedef struct v__pref__Preferences v__pref__Preferences;
typedef struct v__util__EManager v__util__EManager;
typedef struct v__util__Possibility v__util__Possibility;
typedef struct v__util__Suggestion v__util__Suggestion;
typedef struct v__ast__Type v__ast__Type;
typedef struct v__ast__Block v__ast__Block;
typedef struct v__ast__ExprStmt v__ast__ExprStmt;
typedef struct v__ast__IntegerLiteral v__ast__IntegerLiteral;
typedef struct v__ast__FloatLiteral v__ast__FloatLiteral;
typedef struct v__ast__StringLiteral v__ast__StringLiteral;
typedef struct v__ast__StringInterLiteral v__ast__StringInterLiteral;
typedef struct v__ast__CharLiteral v__ast__CharLiteral;
typedef struct v__ast__BoolLiteral v__ast__BoolLiteral;
typedef struct v__ast__SelectorExpr v__ast__SelectorExpr;
typedef struct v__ast__Module v__ast__Module;
typedef struct v__ast__StructField v__ast__StructField;
typedef struct v__ast__Field v__ast__Field;
typedef struct v__ast__ConstField v__ast__ConstField;
typedef struct v__ast__ConstDecl v__ast__ConstDecl;
typedef struct v__ast__StructDecl v__ast__StructDecl;
typedef struct v__ast__StructEmbedding v__ast__StructEmbedding;
typedef struct v__ast__InterfaceDecl v__ast__InterfaceDecl;
typedef struct v__ast__StructInitField v__ast__StructInitField;
typedef struct v__ast__StructInit v__ast__StructInit;
typedef struct v__ast__Import v__ast__Import;
typedef struct v__ast__ImportSymbol v__ast__ImportSymbol;
typedef struct v__ast__AnonFn v__ast__AnonFn;
typedef struct v__ast__FnDecl v__ast__FnDecl;
typedef struct v__ast__BranchStmt v__ast__BranchStmt;
typedef struct v__ast__CallExpr v__ast__CallExpr;
typedef struct v__ast__CallArg v__ast__CallArg;
typedef struct v__ast__Return v__ast__Return;
typedef struct v__ast__Var v__ast__Var;
typedef struct v__ast__ScopeStructField v__ast__ScopeStructField;
typedef struct v__ast__GlobalField v__ast__GlobalField;
typedef struct v__ast__GlobalDecl v__ast__GlobalDecl;
typedef struct v__ast__File v__ast__File;
typedef struct v__ast__IdentFn v__ast__IdentFn;
typedef struct v__ast__IdentVar v__ast__IdentVar;
typedef struct v__ast__Ident v__ast__Ident;
typedef struct v__ast__InfixExpr v__ast__InfixExpr;
typedef struct v__ast__PostfixExpr v__ast__PostfixExpr;
typedef struct v__ast__PrefixExpr v__ast__PrefixExpr;
typedef struct v__ast__IndexExpr v__ast__IndexExpr;
typedef struct v__ast__IfExpr v__ast__IfExpr;
typedef struct v__ast__IfBranch v__ast__IfBranch;
typedef struct v__ast__UnsafeExpr v__ast__UnsafeExpr;
typedef struct v__ast__LockExpr v__ast__LockExpr;
typedef struct v__ast__MatchExpr v__ast__MatchExpr;
typedef struct v__ast__MatchBranch v__ast__MatchBranch;
typedef struct v__ast__SelectExpr v__ast__SelectExpr;
typedef struct v__ast__SelectBranch v__ast__SelectBranch;
typedef struct v__ast__CompFor v__ast__CompFor;
typedef struct v__ast__ForStmt v__ast__ForStmt;
typedef struct v__ast__ForInStmt v__ast__ForInStmt;
typedef struct v__ast__ForCStmt v__ast__ForCStmt;
typedef struct v__ast__HashStmt v__ast__HashStmt;
typedef struct v__ast__AssignStmt v__ast__AssignStmt;
typedef struct v__ast__AsCast v__ast__AsCast;
typedef struct v__ast__EnumVal v__ast__EnumVal;
typedef struct v__ast__EnumField v__ast__EnumField;
typedef struct v__ast__EnumDecl v__ast__EnumDecl;
typedef struct v__ast__AliasTypeDecl v__ast__AliasTypeDecl;
typedef struct v__ast__SumTypeDecl v__ast__SumTypeDecl;
typedef struct v__ast__SumTypeVariant v__ast__SumTypeVariant;
typedef struct v__ast__FnTypeDecl v__ast__FnTypeDecl;
typedef struct v__ast__DeferStmt v__ast__DeferStmt;
typedef struct v__ast__ParExpr v__ast__ParExpr;
typedef struct v__ast__GoStmt v__ast__GoStmt;
typedef struct v__ast__GotoLabel v__ast__GotoLabel;
typedef struct v__ast__GotoStmt v__ast__GotoStmt;
typedef struct v__ast__ArrayInit v__ast__ArrayInit;
typedef struct v__ast__ChanInit v__ast__ChanInit;
typedef struct v__ast__MapInit v__ast__MapInit;
typedef struct v__ast__RangeExpr v__ast__RangeExpr;
typedef struct v__ast__CastExpr v__ast__CastExpr;
typedef struct v__ast__AssertStmt v__ast__AssertStmt;
typedef struct v__ast__IfGuardExpr v__ast__IfGuardExpr;
typedef struct v__ast__OrExpr v__ast__OrExpr;
typedef struct v__ast__Assoc v__ast__Assoc;
typedef struct v__ast__SizeOf v__ast__SizeOf;
typedef struct v__ast__Likely v__ast__Likely;
typedef struct v__ast__TypeOf v__ast__TypeOf;
typedef struct v__ast__Comment v__ast__Comment;
typedef struct v__ast__ConcatExpr v__ast__ConcatExpr;
typedef struct v__ast__AtExpr v__ast__AtExpr;
typedef struct v__ast__ComptimeCall v__ast__ComptimeCall;
typedef struct v__ast__None v__ast__None;
typedef struct v__ast__SqlStmt v__ast__SqlStmt;
typedef struct v__ast__SqlExpr v__ast__SqlExpr;
typedef struct v__ast__CTempVar v__ast__CTempVar;
typedef struct v__ast__Scope v__ast__Scope;
typedef struct v__scanner__Scanner v__scanner__Scanner;
typedef struct v__checker__Checker v__checker__Checker;
typedef struct v__parser__Parser v__parser__Parser;
typedef struct v__gen__Gen v__gen__Gen;
typedef struct v__gen__ProfileCounterMeta v__gen__ProfileCounterMeta;
typedef struct v__gen__js__JsGen v__gen__js__JsGen;
typedef struct v__gen__js__JsDoc v__gen__js__JsDoc;
typedef struct v__gen__x64__SectionConfig v__gen__x64__SectionConfig;
typedef struct v__gen__x64__Gen v__gen__x64__Gen;
typedef struct v__builder__Builder v__builder__Builder;
typedef struct v__builder__FunctionRedefinition v__builder__FunctionRedefinition;
typedef struct v__builder__MsvcResult v__builder__MsvcResult;
typedef struct v__builder__WindowsKit v__builder__WindowsKit;
typedef struct v__builder__VsInstallation v__builder__VsInstallation;
typedef struct v__builder__MsvcStringFlags v__builder__MsvcStringFlags;
typedef struct varg_voidptr varg_voidptr;
typedef struct varg_string varg_string;
typedef struct varg_int varg_int;

// V typedefs2:
typedef struct Option_int Option_int;
typedef struct Option_string Option_string;
typedef struct Option_void Option_void;
typedef struct Option_array_byte Option_array_byte;
typedef struct Option_FILE_ptr Option_FILE_ptr;
typedef struct Option_array_string Option_array_string;
typedef struct Option_bool Option_bool;
typedef struct Option_array_ustring Option_array_ustring;
typedef struct Option_os__File Option_os__File;
typedef struct Option_os__Result Option_os__Result;
typedef struct Option_time__Time Option_time__Time;
typedef struct Option_f64 Option_f64;
typedef struct Option_semver__Range Option_semver__Range;
typedef struct Option_semver__Version Option_semver__Version;
typedef struct Option_semver__ComparatorSet Option_semver__ComparatorSet;
typedef struct Option_semver__Comparator Option_semver__Comparator;
typedef struct Option_v__vmod__Manifest Option_v__vmod__Manifest;
typedef struct Option_multi_return_array_string_int Option_multi_return_array_string_int;
typedef struct Option_v__pkgconfig__PkgConfig_ptr Option_v__pkgconfig__PkgConfig_ptr;
typedef struct Option_v__pkgconfig__Main_ptr Option_v__pkgconfig__Main_ptr;
typedef struct Option_v__table__Fn Option_v__table__Fn;
typedef struct Option_v__table__Field Option_v__table__Field;
typedef struct Option_v__table__TypeSymbol Option_v__table__TypeSymbol;
typedef struct Option_v__pref__OS Option_v__pref__OS;
typedef struct Option_v__pref__Backend Option_v__pref__Backend;
typedef struct Option_multi_return_v__ast__ScopeObject_v__ast__Scope Option_multi_return_v__ast__ScopeObject_v__ast__Scope;
typedef struct Option_v__ast__ScopeObject Option_v__ast__ScopeObject;
typedef struct Option_v__ast__ScopeStructField Option_v__ast__ScopeStructField;
typedef struct Option_v__ast__Var_ptr Option_v__ast__Var_ptr;
typedef struct Option_v__ast__ConstField_ptr Option_v__ast__ConstField_ptr;
typedef struct Option_v__ast__IntegerLiteral Option_v__ast__IntegerLiteral;
typedef struct Option_v__builder__MsvcResult Option_v__builder__MsvcResult;
typedef struct Option_v__builder__WindowsKit Option_v__builder__WindowsKit;
typedef struct Option_v__builder__VsInstallation Option_v__builder__VsInstallation;

// V cheaders:
// Generated by the V compiler

#if defined(__has_include)

#if __has_include(<inttypes.h>)
#include <inttypes.h>
#else
#error VERROR_MESSAGE The C compiler can not find <inttypes.h> . Please install build-essentials
#endif

#else
#include <inttypes.h>
#endif


//================================== builtin types ================================*/
typedef int64_t i64;
typedef int16_t i16;
typedef int8_t i8;
typedef uint64_t u64;
typedef uint32_t u32;
typedef uint16_t u16;
typedef uint8_t byte;
typedef uint32_t rune;
typedef float f32;
typedef double f64;
typedef int64_t any_int;
typedef double any_float;
typedef unsigned char* byteptr;
typedef void* voidptr;
typedef char* charptr;
typedef byte array_fixed_byte_300 [300];

typedef struct sync__Channel* chan;

#ifndef __cplusplus
	#ifndef bool
		typedef int bool;
		#define true 1
		#define false 0
	#endif
#endif


// c_headers
typedef int (*qsort_callback_func)(const void*, const void*);
#include <stdio.h>  // TODO remove all these includes, define all function signatures and types manually
#include <stdlib.h>

#if defined(_WIN32) || defined(__CYGWIN__)
	#define VV_EXPORTED_SYMBOL extern __declspec(dllexport)
	#define VV_LOCAL_SYMBOL static
#else
	// 4 < gcc < 5 is used by some older Ubuntu LTS and Centos versions,
	// and does not support __has_attribute(visibility) ...
	#ifndef __has_attribute
		#define __has_attribute(x) 0  // Compatibility with non-clang compilers.
	#endif
	#if (defined(__GNUC__) && (__GNUC__ >= 4)) || (defined(__clang__) && __has_attribute(visibility))
		#define VV_EXPORTED_SYMBOL extern __attribute__ ((visibility ("default")))
		#define VV_LOCAL_SYMBOL  __attribute__ ((visibility ("hidden")))
	#else
		#define VV_EXPORTED_SYMBOL extern
		#define VV_LOCAL_SYMBOL static
	#endif
#endif

#ifdef __cplusplus
	#include <utility>
	#define _MOV std::move
#else
	#define _MOV
#endif

#ifndef _WIN32
	#if defined __has_include
		#if __has_include (<execinfo.h>)
			#include <execinfo.h>
		#else
			// Most probably musl OR __ANDROID__ ...
			int backtrace (void **__array, int __size) { return 0; }
			char **backtrace_symbols (void *const *__array, int __size){ return 0; }
			void backtrace_symbols_fd (void *const *__array, int __size, int __fd){}
		#endif
	#endif
#endif

//#include "fns.h"
#include <signal.h>
#include <stdarg.h> // for va_list
#include <string.h> // memcpy

#if INTPTR_MAX == INT32_MAX
	#define TARGET_IS_32BIT 1
#elif INTPTR_MAX == INT64_MAX
	#define TARGET_IS_64BIT 1
#else
	#error "The environment is not 32 or 64-bit."
#endif

#if defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__ || defined(__BYTE_ORDER) && __BYTE_ORDER == __BIG_ENDIAN || defined(__BIG_ENDIAN__) || defined(__ARMEB__) || defined(__THUMBEB__) || defined(__AARCH64EB__) || defined(_MIBSEB) || defined(__MIBSEB) || defined(__MIBSEB__)
	#define TARGET_ORDER_IS_BIG
#elif defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__ || defined(__BYTE_ORDER) && __BYTE_ORDER == __LITTLE_ENDIAN || defined(__LITTLE_ENDIAN__) || defined(__ARMEL__) || defined(__THUMBEL__) || defined(__AARCH64EL__) || defined(_MIPSEL) || defined(__MIPSEL) || defined(__MIPSEL__) || defined(_M_AMD64) || defined(_M_X64) || defined(_M_IX86)
	#define TARGET_ORDER_IS_LITTLE
#else
	#error "Unknown architecture endianness"
#endif

#ifndef _WIN32
	#include <ctype.h>
	#include <locale.h> // tolower
	#include <sys/time.h>
	#include <unistd.h> // sleep
	extern char **environ;
#endif

#if defined(__CYGWIN__) && !defined(_WIN32)
	#error Cygwin is not supported, please use MinGW or Visual Studio.
#endif

#ifdef __linux__
	#include <sys/types.h>
	#include <sys/wait.h> // os__wait uses wait on nix
#endif

#ifdef __FreeBSD__
	#include <sys/types.h>
	#include <sys/wait.h> // os__wait uses wait on nix
#endif

#ifdef __DragonFly__
	#include <sys/types.h>
	#include <sys/wait.h> // os__wait uses wait on nix
#endif

#ifdef __OpenBSD__
	#include <sys/types.h>
	#include <sys/resource.h>
	#include <sys/wait.h> // os__wait uses wait on nix
#endif

#ifdef __NetBSD__
	#include <sys/wait.h> // os__wait uses wait on nix
#endif

#ifdef __sun
	#include <sys/types.h>
	#include <sys/wait.h> // os__wait uses wait on nix
#endif


#define EMPTY_STRUCT_DECLARATION
#define EMPTY_STRUCT_INITIALIZATION 0
// Due to a tcc bug, the length of an array needs to be specified, but GCC crashes if it is...
#define EMPTY_ARRAY_OF_ELEMS(x,n) (x[])
#define TCCSKIP(x) x

#define __NOINLINE __attribute__((noinline))
#define __IRQHANDLER __attribute__((interrupt))

#if defined(__x86_64__)
#define __V_amd64  1
#endif
#if defined(__aarch64__) || defined(__arm64__)
#define __V_aarch64  1
#endif

// Using just __GNUC__ for detecting gcc, is not reliable because other compilers define it too:
#ifdef __GNUC__
	#define __V_GCC__
#endif
#ifdef __TINYC__
	#undef __V_GCC__
#endif
#ifdef __cplusplus
	#undef __V_GCC__
#endif
#ifdef __clang__
	#undef __V_GCC__
#endif
#ifdef _MSC_VER
	#undef __V_GCC__
#endif

#ifdef __TINYC__
	#undef EMPTY_STRUCT_DECLARATION
	#undef EMPTY_STRUCT_INITIALIZATION
	#define EMPTY_STRUCT_DECLARATION char _dummy
	#define EMPTY_STRUCT_INITIALIZATION 0
	#undef EMPTY_ARRAY_OF_ELEMS
	#define EMPTY_ARRAY_OF_ELEMS(x,n) (x[n])
	#undef __NOINLINE
	#undef __IRQHANDLER
	// tcc does not support inlining at all
	#define __NOINLINE
	#define __IRQHANDLER
	#undef TCCSKIP
	#define TCCSKIP(x)
	// #include <byteswap.h>
	#ifndef _WIN32
		#include <execinfo.h>
		int tcc_backtrace(const char *fmt, ...);
	#endif
#endif

// for __offset_of
#ifndef __offsetof
	#define __offsetof(s,memb) ((size_t)((char *)&((s *)0)->memb - (char *)0))
#endif

#define OPTION_CAST(x) (x)

#ifndef V64_PRINTFORMAT
	#ifdef PRIx64
		#define V64_PRINTFORMAT "0x%"PRIx64
	#elif defined(__WIN32__)
		#define V64_PRINTFORMAT "0x%I64x"
	#elif defined(__linux__) && defined(__LP64__)
		#define V64_PRINTFORMAT "0x%lx"
	#else
		#define V64_PRINTFORMAT "0x%llx"
	#endif
#endif


#ifdef _WIN32
	#define WINVER 0x0600
	#ifdef _WIN32_WINNT
		#undef _WIN32_WINNT
	#endif
	#define _WIN32_WINNT 0x0600
	#define WIN32_LEAN_AND_MEAN
	#ifndef _UNICODE
	#define _UNICODE
	#endif
	#ifndef UNICODE
	#define UNICODE
	#endif
	#include <windows.h>

	#include <io.h> // _waccess
	#include <direct.h> // _wgetcwd
	//#include <WinSock2.h>

	#ifdef _MSC_VER
		// On MSVC these are the same (as long as /volatile:ms is passed)
		#define _Atomic volatile

		// MSVC cannot parse some things properly
		#undef EMPTY_STRUCT_DECLARATION
		#undef OPTION_CAST

		#define EMPTY_STRUCT_DECLARATION int ____dummy_variable
		#define OPTION_CAST(x)
		#undef __NOINLINE
		#undef __IRQHANDLER
		#define __NOINLINE __declspec(noinline)
		#define __IRQHANDLER __declspec(naked)

		#include <dbghelp.h>
		#pragma comment(lib, "Dbghelp.lib")

		extern wchar_t **_wenviron;
	#elif !defined(SRWLOCK_INIT)
		// these seem to be missing on Windows tcc
		typedef struct SRWLOCK { void* SRWLOCK; } SRWLOCK;
		void InitializeSRWLock(void*);
		void AcquireSRWLockShared(void*);
		void AcquireSRWLockExclusive(void*);
		void ReleaseSRWLockShared(void*);
		void ReleaseSRWLockExclusive(void*);
	#endif
#else
	#include <pthread.h>
	#ifndef PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP
		// musl does not have that
		#define pthread_rwlockattr_setkind_np(a, b)
	#endif
#endif

// g_live_info is used by live.info()
void* g_live_info = NULL;

//============================== HELPER C MACROS =============================*/
//#define tos4(s, slen) ((string){.str=(s), .len=(slen)})
#define _SLIT(s) ((string){.str=(byteptr)(s), .len=(strlen(s))})
#define _PUSH_MANY(arr, val, tmp, tmp_typ) {tmp_typ tmp = (val); array_push_many(arr, tmp.data, tmp.len);}
#define _IN(typ, val, arr) array_##typ##_contains(arr, val)
#define _IN_MAP(val, m) map_exists(m, val)

// these macros have corresponding implementations in builtin/int.v with different signedness
#define array_i8_contains(a, b) array_byte_contains(a, (byte)(b))
#define array_i16_contains(a, b) array_u16_contains(a, (u16)(b))
#define array_u32_contains(a, b) array_int_contains(a, (int)(b))
#define array_i64_contains(a, b) array_u64_contains(a, (u64)(b))
#define array_rune_contains(a, b) array_int_contains(a, (int)(b))
#define array_f32_contains(a, b) array_int_contains(a, *(int*)&((f32[]){(b)}))
#define array_f64_contains(a, b) array_u64_contains(a, *(u64*)&((f64[]){(b)}))
#ifdef TARGET_IS_64BIT
#define array_voidptr_contains(a, b) array_u64_contains(a, (u64)(b))
#else
#define array_voidptr_contains(a, b) array_int_contains(a, (int)(b))
#endif

// unsigned/signed comparisons
static inline bool _us32_gt(uint32_t a, int32_t b) { return a > INT32_MAX || (int32_t)a > b; }
static inline bool _us32_ge(uint32_t a, int32_t b) { return a >= INT32_MAX || (int32_t)a >= b; }
static inline bool _us32_eq(uint32_t a, int32_t b) { return a <= INT32_MAX && (int32_t)a == b; }
static inline bool _us32_ne(uint32_t a, int32_t b) { return a > INT32_MAX || (int32_t)a != b; }
static inline bool _us32_le(uint32_t a, int32_t b) { return a <= INT32_MAX && (int32_t)a <= b; }
static inline bool _us32_lt(uint32_t a, int32_t b) { return a < INT32_MAX && (int32_t)a < b; }
static inline bool _us64_gt(uint64_t a, int64_t b) { return a > INT64_MAX || (int64_t)a > b; }
static inline bool _us64_ge(uint64_t a, int64_t b) { return a >= INT64_MAX || (int64_t)a >= b; }
static inline bool _us64_eq(uint64_t a, int64_t b) { return a <= INT64_MAX && (int64_t)a == b; }
static inline bool _us64_ne(uint64_t a, int64_t b) { return a > INT64_MAX || (int64_t)a != b; }
static inline bool _us64_le(uint64_t a, int64_t b) { return a <= INT64_MAX && (int64_t)a <= b; }
static inline bool _us64_lt(uint64_t a, int64_t b) { return a < INT64_MAX && (int64_t)a < b; }

#if defined(__MINGW32__) || defined(__MINGW64__) || (defined(_WIN32) && defined(__TINYC__))
	#undef PRId64
	#undef PRIi64
	#undef PRIo64
	#undef PRIu64
	#undef PRIx64
	#undef PRIX64
	#define PRId64 "lld"
	#define PRIi64 "lli"
	#define PRIo64 "llo"
	#define PRIu64 "llu"
	#define PRIx64 "llx"
	#define PRIX64 "llX"
#endif

//================================== GLOBALS =================================*/
//byte g_str_buf[1024];
byte* g_str_buf;
int load_so(byteptr);
void reload_so();
void _vinit();
void _vcleanup();
#define sigaction_size sizeof(sigaction);
#define _ARR_LEN(a) ( (sizeof(a)) / (sizeof(a[0])) )

// ============== wyhash ==============
//Author: Wang Yi
#ifndef wyhash_version_gamma
	#define wyhash_version_gamma
	#define WYHASH_CONDOM 0
	#include <stdint.h>
	#include <string.h>
	#if defined(_MSC_VER) && defined(_M_X64)
		#include <intrin.h>
		#pragma intrinsic(_umul128)
	#endif

	//const uint64_t _wyp0=0xa0761d6478bd642full, _wyp1=0xe7037ed1a0b428dbull;
	#define _wyp0 ((uint64_t)0xa0761d6478bd642full)
	#define _wyp1 ((uint64_t)0xe7037ed1a0b428dbull)

	#if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__) || defined(__TINYC__)
		#define _likely_(x) __builtin_expect(x, 1)
		#define _unlikely_(x) __builtin_expect((x), 0)
	#else
		#define _likely_(x) (x)
		#define _unlikely_(x) (x)
	#endif

	#if defined(TARGET_ORDER_IS_LITTLE)
		#define WYHASH_LITTLE_ENDIAN 1
	#elif defined(TARGET_ORDER_IS_BIG)
		#define WYHASH_LITTLE_ENDIAN 0
	#endif

	#if (WYHASH_LITTLE_ENDIAN)
		static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return v;}
		static inline uint64_t _wyr4(const uint8_t *p) { unsigned v; memcpy(&v, p, 4); return v;}
	#else
		#if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)
			static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return __builtin_bswap64(v);}
			static inline uint64_t _wyr4(const uint8_t *p) { unsigned v; memcpy(&v, p, 4); return __builtin_bswap32(v);}
		#elif defined(_MSC_VER)
			static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return _byteswap_uint64(v);}
			static inline uint64_t _wyr4(const uint8_t *p) { unsigned v; memcpy(&v, p, 4); return _byteswap_ulong(v);}
		#elif defined(__TINYC__)
			static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return bswap_64(v);}
			static inline uint64_t _wyr4(const uint8_t *p) { unsigned v; memcpy(&v, p, 4); return bswap_32(v);}
		#endif
	#endif

	static inline uint64_t _wyr3(const uint8_t *p, unsigned k) { return (((uint64_t)p[0]) << 16) | (((uint64_t)p[k >> 1]) << 8) | p[k - 1];}
	static inline uint64_t _wyrotr(uint64_t v, unsigned k) { return (v >> k) | (v << (64 - k));}
	static inline void _wymix128(uint64_t A, uint64_t B, uint64_t *C, uint64_t *D){
		A^=*C;	B^=*D;
	#ifdef UNOFFICIAL_WYHASH_32BIT
		uint64_t hh=(A>>32)*(B>>32), hl=(A>>32)*(unsigned)B, lh=(unsigned)A*(B>>32), ll=(uint64_t)(unsigned)A*(unsigned)B;
		*C=_wyrotr(hl,32)^hh; *D=_wyrotr(lh,32)^ll;
	#else
		#ifdef __SIZEOF_INT128__
			__uint128_t r=A; r*=B; *C=(uint64_t)r; *D=(uint64_t)(r>>64);
		#elif defined(_MSC_VER) && defined(_M_X64)
			A=_umul128(A,B,&B); *C=A; *D=B;
		#else
			uint64_t ha=A>>32, hb=B>>32, la=(uint32_t)A, lb=(uint32_t)B, hi, lo;
			uint64_t rh=ha*hb, rm0=ha*lb, rm1=hb*la, rl=la*lb, t=rl+(rm0<<32), c=t<rl;
			lo=t+(rm1<<32); c+=lo<t; hi=rh+(rm0>>32)+(rm1>>32)+c;
			*C=lo;	*D=hi;
		#endif
	#endif
	}
	static inline uint64_t wyhash(const void *key, uint64_t len, uint64_t seed){
		const uint8_t *p=(const uint8_t *)key;
		uint64_t i=len, see1=seed;
		start:
		if (_likely_(i<=16)) {
	#ifndef	WYHASH_CONDOM
			uint64_t shift = (i<8)*((8-i)<<3);
			//WARNING: intended reading outside buffer, trading for speed.
			_wymix128((_wyr8(p)<<shift)^_wyp0, (_wyr8(p+i-8)>>shift)^_wyp1, &seed, &see1);
	#else
			if (_likely_(i<=8)) {
				if (_likely_(i>=4)) _wymix128(_wyr4(p)^_wyp0,_wyr4(p+i-4)^_wyp1, &seed, &see1);
				else if (_likely_(i)) _wymix128(_wyr3(p,i)^_wyp0,_wyp1, &seed, &see1);
				else _wymix128(_wyp0,_wyp1, &seed, &see1);
			}
			else _wymix128(_wyr8(p)^_wyp0,_wyr8(p+i-8)^_wyp1, &seed, &see1);
	#endif
			_wymix128(len,_wyp0, &seed, &see1);
			return	seed^see1;
		}
		_wymix128(_wyr8(p)^_wyp0,_wyr8(p+8)^_wyp1, &seed, &see1);
		i-=16;	p+=16;	goto start;
	}
	static inline uint64_t wyhash64(uint64_t A, uint64_t B){
		_wymix128(_wyp0,_wyp1,&A,&B);
		_wymix128(0,0,&A,&B);
		return	A^B;
	}
	static inline uint64_t wyrand(uint64_t *seed){
		*seed+=_wyp0;
		uint64_t	a=0, b=0;
		_wymix128(*seed,*seed^_wyp1,&a,&b);
		return	a^b;
	}
	static inline double wy2u01(uint64_t r) {
		const double _wynorm=1.0/(1ull<<52);
		return (r>>12)*_wynorm;
	}
	static inline double wy2gau(uint64_t r) {
		const double _wynorm=1.0/(1ull<<20);
		return ((r&0x1fffff)+((r>>21)&0x1fffff)+((r>>42)&0x1fffff))*_wynorm-3.0;
	}
#endif

voidptr memdup(voidptr src, int sz);
voidptr memfreedup(voidptr ptr, voidptr src, int sz) {
	free(ptr);
	return memdup(src, sz);
}


// V includes:
// added by module `builtin`:

#if defined(__has_include)

#if __has_include(<float.h>)
#include <float.h>
#else
#error VERROR_MESSAGE Header file <float.h>, needed for module `builtin` was not found. Please install the corresponding development headers.
#endif

#else
#include <float.h>
#endif

// added by module `os`:

#if defined(__has_include)

#if __has_include(<sys/stat.h>)
#include <sys/stat.h>
#else
#error VERROR_MESSAGE Header file <sys/stat.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <sys/stat.h>
#endif

// added by module `os`:
#include <errno.h>
// added by module `os`:

#if defined(__has_include)

#if __has_include(<process.h>)
#include <process.h>
#else
#error VERROR_MESSAGE Header file <process.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <process.h>
#endif

// added by module `time`:

#if defined(__has_include)

#if __has_include(<time.h>)
#include <time.h>
#else
#error VERROR_MESSAGE Header file <time.h>, needed for module `time` was not found. Please install the corresponding development headers.
#endif

#else
#include <time.h>
#endif

// added by module `time`:

#if defined(__has_include)

#if __has_include(<time.h>)
#include <time.h>
#else
#error VERROR_MESSAGE Header file <time.h>, needed for module `time` was not found. Please install the corresponding development headers.
#endif

#else
#include <time.h>
#endif


// Enum definitions:
typedef enum {
	strconv__Char_parse_state_start, // 
	strconv__Char_parse_state_norm_char, // +1
	strconv__Char_parse_state_field_char, // +2
	strconv__Char_parse_state_pad_ch, // +3
	strconv__Char_parse_state_len_set_start, // +4
	strconv__Char_parse_state_len_set_in, // +5
	strconv__Char_parse_state_check_type, // +6
	strconv__Char_parse_state_check_float, // +7
	strconv__Char_parse_state_check_float_in, // +8
	strconv__Char_parse_state_reset_params, // +9
} strconv__Char_parse_state;

typedef enum {
	strconv__Align_text_right = 0, // 0
	strconv__Align_text_left, // 0+1
	strconv__Align_text_center, // 0+2
} strconv__Align_text;

typedef enum {
	ChanState_success, // 
	ChanState_not_ready, // +1
	ChanState_closed, // +2
} ChanState;

typedef enum {
	os__FileType_regular, // 
	os__FileType_directory, // +1
	os__FileType_character_device, // +2
	os__FileType_block_device, // +3
	os__FileType_fifo, // +4
	os__FileType_symbolic_link, // +5
	os__FileType_socket, // +6
} os__FileType;

typedef enum {
	os__ProcessState_not_started, // 
	os__ProcessState_running, // +1
	os__ProcessState_stopped, // +2
	os__ProcessState_exited, // +3
	os__ProcessState_aborted, // +4
} os__ProcessState;

typedef enum {
	time__FormatTime_hhmm12, // 
	time__FormatTime_hhmm24, // +1
	time__FormatTime_hhmmss12, // +2
	time__FormatTime_hhmmss24, // +3
	time__FormatTime_hhmmss24_milli, // +4
	time__FormatTime_hhmmss24_micro, // +5
	time__FormatTime_no_time, // +6
} time__FormatTime;

typedef enum {
	time__FormatDate_ddmmyy, // 
	time__FormatDate_ddmmyyyy, // +1
	time__FormatDate_mmddyy, // +2
	time__FormatDate_mmddyyyy, // +3
	time__FormatDate_mmmd, // +4
	time__FormatDate_mmmdd, // +5
	time__FormatDate_mmmddyyyy, // +6
	time__FormatDate_no_date, // +7
	time__FormatDate_yyyymmdd, // +8
} time__FormatDate;

typedef enum {
	time__FormatDelimiter_dot, // 
	time__FormatDelimiter_hyphen, // +1
	time__FormatDelimiter_slash, // +2
	time__FormatDelimiter_space, // +3
	time__FormatDelimiter_no_delimiter, // +4
} time__FormatDelimiter;

typedef enum {
	v__token__Kind_unknown, // 
	v__token__Kind_eof, // +1
	v__token__Kind_name, // +2
	v__token__Kind_number, // +3
	v__token__Kind_string, // +4
	v__token__Kind_str_inter, // +5
	v__token__Kind_chartoken, // +6
	v__token__Kind_plus, // +7
	v__token__Kind_minus, // +8
	v__token__Kind_mul, // +9
	v__token__Kind_div, // +10
	v__token__Kind_mod, // +11
	v__token__Kind_xor, // +12
	v__token__Kind_pipe, // +13
	v__token__Kind_inc, // +14
	v__token__Kind_dec, // +15
	v__token__Kind_and, // +16
	v__token__Kind_logical_or, // +17
	v__token__Kind_not, // +18
	v__token__Kind_bit_not, // +19
	v__token__Kind_question, // +20
	v__token__Kind_comma, // +21
	v__token__Kind_semicolon, // +22
	v__token__Kind_colon, // +23
	v__token__Kind_arrow, // +24
	v__token__Kind_amp, // +25
	v__token__Kind_hash, // +26
	v__token__Kind_dollar, // +27
	v__token__Kind_at, // +28
	v__token__Kind_str_dollar, // +29
	v__token__Kind_left_shift, // +30
	v__token__Kind_right_shift, // +31
	v__token__Kind_not_in, // +32
	v__token__Kind_not_is, // +33
	v__token__Kind_assign, // +34
	v__token__Kind_decl_assign, // +35
	v__token__Kind_plus_assign, // +36
	v__token__Kind_minus_assign, // +37
	v__token__Kind_div_assign, // +38
	v__token__Kind_mult_assign, // +39
	v__token__Kind_xor_assign, // +40
	v__token__Kind_mod_assign, // +41
	v__token__Kind_or_assign, // +42
	v__token__Kind_and_assign, // +43
	v__token__Kind_right_shift_assign, // +44
	v__token__Kind_left_shift_assign, // +45
	v__token__Kind_lcbr, // +46
	v__token__Kind_rcbr, // +47
	v__token__Kind_lpar, // +48
	v__token__Kind_rpar, // +49
	v__token__Kind_lsbr, // +50
	v__token__Kind_rsbr, // +51
	v__token__Kind_eq, // +52
	v__token__Kind_ne, // +53
	v__token__Kind_gt, // +54
	v__token__Kind_lt, // +55
	v__token__Kind_ge, // +56
	v__token__Kind_le, // +57
	v__token__Kind_comment, // +58
	v__token__Kind_nl, // +59
	v__token__Kind_dot, // +60
	v__token__Kind_dotdot, // +61
	v__token__Kind_ellipsis, // +62
	v__token__Kind_keyword_beg, // +63
	v__token__Kind_key_as, // +64
	v__token__Kind_key_asm, // +65
	v__token__Kind_key_assert, // +66
	v__token__Kind_key_atomic, // +67
	v__token__Kind_key_break, // +68
	v__token__Kind_key_const, // +69
	v__token__Kind_key_continue, // +70
	v__token__Kind_key_defer, // +71
	v__token__Kind_key_else, // +72
	v__token__Kind_key_embed, // +73
	v__token__Kind_key_enum, // +74
	v__token__Kind_key_false, // +75
	v__token__Kind_key_for, // +76
	v__token__Kind_key_fn, // +77
	v__token__Kind_key_global, // +78
	v__token__Kind_key_go, // +79
	v__token__Kind_key_goto, // +80
	v__token__Kind_key_if, // +81
	v__token__Kind_key_import, // +82
	v__token__Kind_key_in, // +83
	v__token__Kind_key_interface, // +84
	v__token__Kind_key_is, // +85
	v__token__Kind_key_match, // +86
	v__token__Kind_key_module, // +87
	v__token__Kind_key_mut, // +88
	v__token__Kind_key_shared, // +89
	v__token__Kind_key_lock, // +90
	v__token__Kind_key_rlock, // +91
	v__token__Kind_key_none, // +92
	v__token__Kind_key_return, // +93
	v__token__Kind_key_select, // +94
	v__token__Kind_key_sizeof, // +95
	v__token__Kind_key_likely, // +96
	v__token__Kind_key_unlikely, // +97
	v__token__Kind_key_offsetof, // +98
	v__token__Kind_key_struct, // +99
	v__token__Kind_key_true, // +100
	v__token__Kind_key_type, // +101
	v__token__Kind_key_typeof, // +102
	v__token__Kind_key_orelse, // +103
	v__token__Kind_key_union, // +104
	v__token__Kind_key_pub, // +105
	v__token__Kind_key_static, // +106
	v__token__Kind_key_unsafe, // +107
	v__token__Kind_keyword_end, // +108
	v__token__Kind__end_, // +109
} v__token__Kind;

typedef enum {
	v__token__AtKind_unknown, // 
	v__token__AtKind_fn_name, // +1
	v__token__AtKind_mod_name, // +2
	v__token__AtKind_struct_name, // +3
	v__token__AtKind_vexe_path, // +4
	v__token__AtKind_file_path, // +5
	v__token__AtKind_line_nr, // +6
	v__token__AtKind_column_nr, // +7
	v__token__AtKind_vhash, // +8
	v__token__AtKind_vmod_file, // +9
} v__token__AtKind;

typedef enum {
	v__token__Precedence_lowest, // 
	v__token__Precedence_cond, // +1
	v__token__Precedence_in_as, // +2
	v__token__Precedence_assign, // +3
	v__token__Precedence_eq, // +4
	v__token__Precedence_sum, // +5
	v__token__Precedence_product, // +6
	v__token__Precedence_prefix, // +7
	v__token__Precedence_postfix, // +8
	v__token__Precedence_call, // +9
	v__token__Precedence_index, // +10
} v__token__Precedence;

typedef enum {
	semver__Operator_gt, // 
	semver__Operator_lt, // +1
	semver__Operator_ge, // +2
	semver__Operator_le, // +3
	semver__Operator_eq, // +4
} semver__Operator;

typedef enum {
	semver__Increment_major, // 
	semver__Increment_minor, // +1
	semver__Increment_patch, // +2
} semver__Increment;

typedef enum {
	v__vmod__TokenKind_module_keyword, // 
	v__vmod__TokenKind_field_key, // +1
	v__vmod__TokenKind_lcbr, // +2
	v__vmod__TokenKind_rcbr, // +3
	v__vmod__TokenKind_labr, // +4
	v__vmod__TokenKind_rabr, // +5
	v__vmod__TokenKind_comma, // +6
	v__vmod__TokenKind_colon, // +7
	v__vmod__TokenKind_eof, // +8
	v__vmod__TokenKind_str, // +9
	v__vmod__TokenKind_ident, // +10
	v__vmod__TokenKind_unknown, // +11
} v__vmod__TokenKind;

typedef enum {
	v__errors__Reporter_scanner, // 
	v__errors__Reporter_parser, // +1
	v__errors__Reporter_checker, // +2
	v__errors__Reporter_gen, // +3
} v__errors__Reporter;

typedef enum {
	vweb__tmpl__State_html, // 
	vweb__tmpl__State_css, // +1
	vweb__tmpl__State_js, // +2
} vweb__tmpl__State;

typedef enum {
	v__table__Language_v, // 
	v__table__Language_c, // +1
	v__table__Language_js, // +2
} v__table__Language;

typedef enum {
	v__table__TypeFlag_optional, // 
	v__table__TypeFlag_variadic, // +1
	v__table__TypeFlag_generic, // +2
	v__table__TypeFlag_shared_f, // +3
	v__table__TypeFlag_atomic_f, // +4
} v__table__TypeFlag;

typedef enum {
	v__table__ShareType_mut_t, // 
	v__table__ShareType_shared_t, // +1
	v__table__ShareType_atomic_t, // +2
} v__table__ShareType;

typedef enum {
	v__table__Kind_placeholder, // 
	v__table__Kind_void, // +1
	v__table__Kind_voidptr, // +2
	v__table__Kind_byteptr, // +3
	v__table__Kind_charptr, // +4
	v__table__Kind_i8, // +5
	v__table__Kind_i16, // +6
	v__table__Kind_int, // +7
	v__table__Kind_i64, // +8
	v__table__Kind_byte, // +9
	v__table__Kind_u16, // +10
	v__table__Kind_u32, // +11
	v__table__Kind_u64, // +12
	v__table__Kind_f32, // +13
	v__table__Kind_f64, // +14
	v__table__Kind_char, // +15
	v__table__Kind_size_t, // +16
	v__table__Kind_rune, // +17
	v__table__Kind_bool, // +18
	v__table__Kind_none_, // +19
	v__table__Kind_string, // +20
	v__table__Kind_ustring, // +21
	v__table__Kind_array, // +22
	v__table__Kind_array_fixed, // +23
	v__table__Kind_map, // +24
	v__table__Kind_chan, // +25
	v__table__Kind_any, // +26
	v__table__Kind_struct_, // +27
	v__table__Kind_generic_struct_inst, // +28
	v__table__Kind_multi_return, // +29
	v__table__Kind_sum_type, // +30
	v__table__Kind_alias, // +31
	v__table__Kind_enum_, // +32
	v__table__Kind_function, // +33
	v__table__Kind_interface_, // +34
	v__table__Kind_any_float, // +35
	v__table__Kind_any_int, // +36
	v__table__Kind_aggregate, // +37
} v__table__Kind;

typedef enum {
	v__pref__OS__auto, // 
	v__pref__OS_ios, // +1
	v__pref__OS_macos, // +2
	v__pref__OS_linux, // +3
	v__pref__OS_windows, // +4
	v__pref__OS_freebsd, // +5
	v__pref__OS_openbsd, // +6
	v__pref__OS_netbsd, // +7
	v__pref__OS_dragonfly, // +8
	v__pref__OS_js, // +9
	v__pref__OS_android, // +10
	v__pref__OS_solaris, // +11
	v__pref__OS_haiku, // +12
} v__pref__OS;

typedef enum {
	v__pref__BuildMode_default_mode, // 
	v__pref__BuildMode_build_module, // +1
} v__pref__BuildMode;

typedef enum {
	v__pref__OutputMode_stdout, // 
	v__pref__OutputMode_silent, // +1
} v__pref__OutputMode;

typedef enum {
	v__pref__ColorOutput_auto, // 
	v__pref__ColorOutput_always, // +1
	v__pref__ColorOutput_never, // +2
} v__pref__ColorOutput;

typedef enum {
	v__pref__Backend_c, // 
	v__pref__Backend_js, // +1
	v__pref__Backend_x64, // +2
} v__pref__Backend;

typedef enum {
	v__pref__CompilerType_gcc, // 
	v__pref__CompilerType_tinyc, // +1
	v__pref__CompilerType_clang, // +2
	v__pref__CompilerType_mingw, // +3
	v__pref__CompilerType_msvc, // +4
	v__pref__CompilerType_cplusplus, // +5
} v__pref__CompilerType;

typedef enum {
	v__ast__ImportSymbolKind_fn_, // 
	v__ast__ImportSymbolKind_type_, // +1
} v__ast__ImportSymbolKind;

typedef enum {
	v__ast__IdentKind_unresolved, // 
	v__ast__IdentKind_blank_ident, // +1
	v__ast__IdentKind_variable, // +2
	v__ast__IdentKind_constant, // +3
	v__ast__IdentKind_global, // +4
	v__ast__IdentKind_function, // +5
} v__ast__IdentKind;

typedef enum {
	v__ast__CompForKind_methods, // 
	v__ast__CompForKind_fields, // +1
} v__ast__CompForKind;

typedef enum {
	v__ast__OrKind_absent, // 
	v__ast__OrKind_block, // +1
	v__ast__OrKind_propagate, // +2
} v__ast__OrKind;

typedef enum {
	v__ast__SqlStmtKind_insert, // 
	v__ast__SqlStmtKind_update, // +1
	v__ast__SqlStmtKind_delete, // +2
} v__ast__SqlStmtKind;

typedef enum {
	v__scanner__CommentsMode_skip_comments, // 
	v__scanner__CommentsMode_parse_comments, // +1
	v__scanner__CommentsMode_toplevel_comments, // +2
} v__scanner__CommentsMode;

typedef enum {
	v__gen__SqlExprSide_left, // 
	v__gen__SqlExprSide_right, // +1
} v__gen__SqlExprSide;

typedef enum {
	v__gen__x64__SectionType_null = 0, // 0
	v__gen__x64__SectionType_progbits = 1, // 1
	v__gen__x64__SectionType_symtab = 2, // 2
	v__gen__x64__SectionType_strtab = 3, // 3
	v__gen__x64__SectionType_rela = 4, // 4
} v__gen__x64__SectionType;

typedef enum {
	v__gen__x64__Register_rax, // 
	v__gen__x64__Register_rcx, // +1
	v__gen__x64__Register_rdx, // +2
	v__gen__x64__Register_rbx, // +3
	v__gen__x64__Register_rsp, // +4
	v__gen__x64__Register_rbp, // +5
	v__gen__x64__Register_rsi, // +6
	v__gen__x64__Register_rdi, // +7
	v__gen__x64__Register_eax, // +8
	v__gen__x64__Register_edi, // +9
	v__gen__x64__Register_edx, // +10
	v__gen__x64__Register_r8, // +11
	v__gen__x64__Register_r9, // +12
	v__gen__x64__Register_r10, // +13
	v__gen__x64__Register_r11, // +14
	v__gen__x64__Register_r12, // +15
	v__gen__x64__Register_r13, // +16
	v__gen__x64__Register_r14, // +17
	v__gen__x64__Register_r15, // +18
} v__gen__x64__Register;

typedef enum {
	v__gen__x64__Size__8, // 
	v__gen__x64__Size__16, // +1
	v__gen__x64__Size__32, // +2
	v__gen__x64__Size__64, // +3
} v__gen__x64__Size;


// V type definitions:
struct string {
	byteptr str;
	int len;
	int is_lit;
};

struct array {
	int element_size;
	voidptr data;
	int len;
	int cap;
};

struct DenseArray {
	int value_bytes;
	u32 cap;
	u32 len;
	u32 deletes;
	string* keys;
	byteptr values;
};

struct map {
	int value_bytes;
	u32 cap;
	byte cached_hashbits;
	byte shift;
	DenseArray key_values;
	u32* metas;
	u32 extra_metas;
	int len;
};

struct Option {
	bool ok;
	bool is_none;
	string v_error;
	int ecode;
};

typedef map map_string_string;
typedef map map_string_int;
typedef map_string_string map_string;
typedef map_string_int map_int;
typedef array array_string;
typedef array array_byte;
typedef array array_int;
typedef array array_rune;
typedef array array_char;
typedef int (*anon_fn_7_7_7)(int,int);
typedef array array_voidptr;
typedef void (*FnExitCb)();
typedef array array_MethodArgs;
typedef int (*VectoredExceptionHandler)(ExceptionPointers*);
typedef array array_u16;
typedef array array_u64;
typedef array array_RepIndex;
typedef _Interface hash__Hasher;
typedef _Interface hash__Hash32er;
typedef _Interface hash__Hash64er;
typedef array array_ustring;
typedef array array_T;
typedef void (*anon_fn_18_1)(string);
typedef voidptr os__HANDLE;
typedef u32 (*os__VectoredExceptionHandler)(ExceptionPointers*);
typedef array array_v__util__Possibility;
typedef array array_v__ast__File;
typedef array array_v__builder__FunctionRedefinition;
typedef array array_v__cflag__CFlag;
typedef voidptr v__builder__RegKey;
typedef array array_u32;
typedef i64 time__Duration;
typedef map map_string_v__token__Kind;
typedef array array_v__token__Kind;
typedef array array_v__token__Precedence;
typedef map map_string_array_string;
typedef array array_v__vmod__Token;
typedef map map_string_v__vmod__ModFileAndFolder;
typedef int v__table__Type;
typedef array array_v__ast__Stmt;
typedef array array_v__ast__Comment;
typedef array array_v__ast__Expr;
typedef array array_bool;
typedef array array_v__token__Position;
typedef array array_v__table__Type;
typedef array array_v__table__Attr;
typedef array array_v__ast__ConstField;
typedef array array_v__ast__StructField;
typedef array array_v__ast__FnDecl;
typedef array array_v__ast__StructInitField;
typedef array array_v__ast__ImportSymbol;
typedef array array_v__table__Param;
typedef array array_v__ast__CallArg;
typedef array array_v__ast__GlobalField;
typedef array array_v__ast__Import;
typedef array array_v__errors__Error;
typedef array array_v__errors__Warning;
typedef array array_v__ast__IfBranch;
typedef array array_v__ast__Ident;
typedef array array_v__ast__MatchBranch;
typedef array array_array_v__ast__Comment;
typedef array array_v__ast__SelectBranch;
typedef array array_v__ast__EnumField;
typedef array array_v__ast__SumTypeVariant;
typedef array array_v__table__Field;
typedef map map_string_v__ast__ScopeObject;
typedef array array_v__ast__ScopeStructField;
typedef array array_v__ast__Scope_ptr;
typedef array array_v__table__TypeSymbol;
typedef map map_string_v__table__Fn;
typedef map map_string_array_v__table__Type;
typedef array array_v__table__Fn;
typedef array array_v__table__Kind;
typedef array array_v__ast__FnDecl_ptr;
typedef array array_v__ast__File_ptr;
typedef array array_v__ast__Type;
typedef array array_v__depgraph__DepGraphNode;
typedef map map_string_v__depgraph__DepGraphNode;
typedef map map_string_strings__Builder;
typedef array array_v__ast__DeferStmt;
typedef array array_v__gen__ProfileCounterMeta;
typedef map map_string_v__table__Type;
typedef map map_string_map_string_string;
typedef map map_string_array_v__ast__FnDecl;
typedef array array_i64;
typedef map map_string_i64;
typedef array array_v__token__Token;
typedef array array_flag__Flag;
typedef array array_f64;
typedef array array_semver__Comparator;
typedef array array_semver__ComparatorSet;
typedef array array_strconv__Uint128;
typedef array array_os__ProcessState;
typedef array array_v__vmod__TokenKind;
typedef array array_v__ast__IdentKind;
typedef array array_v__gen__x64__Register;
typedef array array_v__pref__OS;
// builtin types:
//------------------ #endbuiltin
struct ContextRecord {
EMPTY_STRUCT_DECLARATION;
};

struct ExceptionPointers {
	ExceptionRecord* exception_record;
	ContextRecord* context_record;
};

typedef string array_fixed_string_11 [11];
struct os__Uname {
	string sysname;
	string nodename;
	string release;
	string version;
	string machine;
};

struct os__ContextRecord {
EMPTY_STRUCT_DECLARATION;
};

struct os__ExceptionPointers {
	ExceptionRecord* exception_record;
	ContextRecord* context_record;
};

struct v__cflag__CFlag {
	string mod;
	string os;
	string name;
	string value;
	string cached;
};

struct v__builder__WindowsKit {
	string um_lib_path;
	string ucrt_lib_path;
	string um_include_path;
	string ucrt_include_path;
	string shared_include_path;
};

struct v__builder__VsInstallation {
	string include_path;
	string lib_path;
	string exe_path;
};

struct v__vmod__ModFileAndFolder {
	string vmod_file;
	string vmod_folder;
};


// Union sum type v__ast__TypeDecl = 
//          |  204 = v__ast__AliasTypeDecl
//          |  205 = v__ast__FnTypeDecl  
//          |  206 = v__ast__SumTypeDecl 
struct v__ast__TypeDecl {
    union {
        v__ast__AliasTypeDecl* _204;
        v__ast__FnTypeDecl* _205;
        v__ast__SumTypeDecl* _206;
    };
    int typ;
};


// Union sum type v__ast__Expr = 
//          |  208 = v__ast__AnonFn      
//          |  209 = v__ast__ArrayInit   
//          |  210 = v__ast__AsCast      
//          |  211 = v__ast__Assoc       
//          |  212 = v__ast__AtExpr      
//          |  213 = v__ast__BoolLiteral 
//          |  214 = v__ast__CTempVar    
//          |  215 = v__ast__CallExpr    
//          |  216 = v__ast__CastExpr    
//          |  217 = v__ast__ChanInit    
//          |  218 = v__ast__CharLiteral 
//          |  219 = v__ast__Comment     
//          |  220 = v__ast__ComptimeCall
//          |  221 = v__ast__ConcatExpr  
//          |  222 = v__ast__EnumVal     
//          |  223 = v__ast__FloatLiteral
//          |  224 = v__ast__Ident       
//          |  225 = v__ast__IfExpr      
//          |  226 = v__ast__IfGuardExpr 
//          |  227 = v__ast__IndexExpr   
//          |  228 = v__ast__InfixExpr   
//          |  229 = v__ast__IntegerLiteral
//          |  230 = v__ast__Likely      
//          |  231 = v__ast__LockExpr    
//          |  232 = v__ast__MapInit     
//          |  233 = v__ast__MatchExpr   
//          |  234 = v__ast__None        
//          |  235 = v__ast__OrExpr      
//          |  236 = v__ast__ParExpr     
//          |  237 = v__ast__PostfixExpr 
//          |  238 = v__ast__PrefixExpr  
//          |  239 = v__ast__RangeExpr   
//          |  240 = v__ast__SelectExpr  
//          |  241 = v__ast__SelectorExpr
//          |  242 = v__ast__SizeOf      
//          |  243 = v__ast__SqlExpr     
//          |  244 = v__ast__StringInterLiteral
//          |  245 = v__ast__StringLiteral
//          |  246 = v__ast__StructInit  
//          |  247 = v__ast__Type        
//          |  248 = v__ast__TypeOf      
//          |  249 = v__ast__UnsafeExpr  
struct v__ast__Expr {
    union {
        v__ast__AnonFn* _208;
        v__ast__ArrayInit* _209;
        v__ast__AsCast* _210;
        v__ast__Assoc* _211;
        v__ast__AtExpr* _212;
        v__ast__BoolLiteral* _213;
        v__ast__CTempVar* _214;
        v__ast__CallExpr* _215;
        v__ast__CastExpr* _216;
        v__ast__ChanInit* _217;
        v__ast__CharLiteral* _218;
        v__ast__Comment* _219;
        v__ast__ComptimeCall* _220;
        v__ast__ConcatExpr* _221;
        v__ast__EnumVal* _222;
        v__ast__FloatLiteral* _223;
        v__ast__Ident* _224;
        v__ast__IfExpr* _225;
        v__ast__IfGuardExpr* _226;
        v__ast__IndexExpr* _227;
        v__ast__InfixExpr* _228;
        v__ast__IntegerLiteral* _229;
        v__ast__Likely* _230;
        v__ast__LockExpr* _231;
        v__ast__MapInit* _232;
        v__ast__MatchExpr* _233;
        v__ast__None* _234;
        v__ast__OrExpr* _235;
        v__ast__ParExpr* _236;
        v__ast__PostfixExpr* _237;
        v__ast__PrefixExpr* _238;
        v__ast__RangeExpr* _239;
        v__ast__SelectExpr* _240;
        v__ast__SelectorExpr* _241;
        v__ast__SizeOf* _242;
        v__ast__SqlExpr* _243;
        v__ast__StringInterLiteral* _244;
        v__ast__StringLiteral* _245;
        v__ast__StructInit* _246;
        v__ast__Type* _247;
        v__ast__TypeOf* _248;
        v__ast__UnsafeExpr* _249;
    };
    int typ;
};


// Union sum type v__ast__Stmt = 
//          |  251 = v__ast__AssertStmt  
//          |  252 = v__ast__AssignStmt  
//          |  253 = v__ast__Block       
//          |  254 = v__ast__BranchStmt  
//          |  255 = v__ast__CompFor     
//          |  256 = v__ast__ConstDecl   
//          |  257 = v__ast__DeferStmt   
//          |  258 = v__ast__EnumDecl    
//          |  259 = v__ast__ExprStmt    
//          |  151 = v__ast__FnDecl      
//          |  260 = v__ast__ForCStmt    
//          |  261 = v__ast__ForInStmt   
//          |  262 = v__ast__ForStmt     
//          |  263 = v__ast__GlobalDecl  
//          |  264 = v__ast__GoStmt      
//          |  265 = v__ast__GotoLabel   
//          |  266 = v__ast__GotoStmt    
//          |  267 = v__ast__HashStmt    
//          |  268 = v__ast__Import      
//          |  269 = v__ast__InterfaceDecl
//          |  270 = v__ast__Module      
//          |  271 = v__ast__Return      
//          |  272 = v__ast__SqlStmt     
//          |  273 = v__ast__StructDecl  
//          |  207 = v__ast__TypeDecl    
struct v__ast__Stmt {
    union {
        v__ast__AssertStmt* _251;
        v__ast__AssignStmt* _252;
        v__ast__Block* _253;
        v__ast__BranchStmt* _254;
        v__ast__CompFor* _255;
        v__ast__ConstDecl* _256;
        v__ast__DeferStmt* _257;
        v__ast__EnumDecl* _258;
        v__ast__ExprStmt* _259;
        v__ast__FnDecl* _151;
        v__ast__ForCStmt* _260;
        v__ast__ForInStmt* _261;
        v__ast__ForStmt* _262;
        v__ast__GlobalDecl* _263;
        v__ast__GoStmt* _264;
        v__ast__GotoLabel* _265;
        v__ast__GotoStmt* _266;
        v__ast__HashStmt* _267;
        v__ast__Import* _268;
        v__ast__InterfaceDecl* _269;
        v__ast__Module* _270;
        v__ast__Return* _271;
        v__ast__SqlStmt* _272;
        v__ast__StructDecl* _273;
        v__ast__TypeDecl* _207;
    };
    int typ;
};


// Union sum type v__ast__ScopeObject = 
//          |  275 = v__ast__ConstField  
//          |  276 = v__ast__GlobalField 
//          |  277 = v__ast__Var         
struct v__ast__ScopeObject {
    union {
        v__ast__ConstField* _275;
        v__ast__GlobalField* _276;
        v__ast__Var* _277;
    };
    int typ;
};


// Union sum type v__ast__IdentInfo = 
//          |  312 = v__ast__IdentFn     
//          |  313 = v__ast__IdentVar    
struct v__ast__IdentInfo {
    union {
        v__ast__IdentFn* _312;
        v__ast__IdentVar* _313;
    };
    int typ;
};


// Union sum type v__table__FExpr = 
//          |    3 = byteptr             
//          |    2 = voidptr             
struct v__table__FExpr {
    union {
        byteptr* _3;
        voidptr* _2;
    };
    int typ;
};


// Union sum type v__table__TypeInfo = 
//          |  346 = v__table__Aggregate 
//          |  347 = v__table__Alias     
//          |  350 = v__table__Array     
//          |  351 = v__table__ArrayFixed
//          |  348 = v__table__Chan      
//          |  355 = v__table__Enum      
//          |  353 = v__table__FnType    
//          |  154 = v__table__GenericStructInst
//          |  356 = v__table__Interface 
//          |  349 = v__table__Map       
//          |  352 = v__table__MultiReturn
//          |  155 = v__table__Struct    
//          |  354 = v__table__SumType   
struct v__table__TypeInfo {
    union {
        v__table__Aggregate* _346;
        v__table__Alias* _347;
        v__table__Array* _350;
        v__table__ArrayFixed* _351;
        v__table__Chan* _348;
        v__table__Enum* _355;
        v__table__FnType* _353;
        v__table__GenericStructInst* _154;
        v__table__Interface* _356;
        v__table__Map* _349;
        v__table__MultiReturn* _352;
        v__table__Struct* _155;
        v__table__SumType* _354;
    };
    int typ;
};

struct v__gen__ProfileCounterMeta {
	string fn_name;
	string vpc_name;
	string vpc_calls;
};

struct v__gen__js__JsDoc {
	v__gen__js__JsGen* gen;
};

struct ustring {
	string s;
	array_int runes;
	int len;
};

struct VAssertMetaInfo {
	string fpath;
	int line_nr;
	string fn_name;
	string src;
	string op;
	string llabel;
	string rlabel;
	string lvalue;
	string rvalue;
};

struct MethodArgs {
	int typ;
};

struct FunctionData {
	string name;
	array_string attrs;
	array_MethodArgs args;
	int return_type;
	int typ;
};

struct FieldData {
	string name;
	array_string attrs;
	bool is_pub;
	bool is_mut;
	int typ;
};

typedef u64 array_fixed_u64_2 [2];
typedef char array_fixed_char_254 [254];
struct Line64 {
	u32 f_size_of_struct;
	voidptr f_key;
	u32 f_line_number;
	byteptr f_file_name;
	u64 f_address;
};

struct ExceptionRecord {
	u32 code;
	u32 flags;
	ExceptionRecord* record;
	voidptr address;
	u32 param_count;
};

struct OptionBase {
	bool ok;
	bool is_none;
	string v_error;
	int ecode;
};

struct SortedMap {
	int value_bytes;
	mapnode* root;
	int len;
};

typedef voidptr array_fixed_voidptr_11 [11];
struct RepIndex {
	int idx;
	int val_idx;
};

struct strings__Builder {
	array_byte buf;
	int str_calls;
	int len;
	int initial_size;
};

struct strconv__PrepNumber {
	bool negative;
	int exponent;
	u64 mantissa;
};

union strconv__Float64u {
	f64 f;
	u64 u;
};

struct strconv__Dec32 {
	u32 m;
	int e;
};

union strconv__Uf32 {
	f32 f;
	u32 u;
};

struct strconv__Dec64 {
	u64 m;
	int e;
};

union strconv__Uf64 {
	f64 f;
	u64 u;
};

struct strconv__BF_param {
	byte pad_ch;
	int len0;
	int len1;
	bool positive;
	bool sign_flag;
	strconv__Align_text allign;
	bool rm_tail_zero;
};

struct strconv__Uint128 {
	u64 lo;
	u64 hi;
};

struct os__File {
	voidptr cfile;
	int fd;
	bool is_opened;
};

struct os__FileInfo {
	string name;
	int size;
};

struct os__FilePermission {
	bool read;
	bool write;
	bool execute;
};

struct os__Result {
	int exit_code;
	string output;
};

typedef char array_fixed_char_256 [256];
struct os__Filetime {
	u32 dw_low_date_time;
	u32 dw_high_date_time;
};

typedef u16 array_fixed_u16_260 [260];
typedef u16 array_fixed_u16_14 [14];
struct os__ProcessInformation {
	voidptr h_process;
	voidptr h_thread;
	u32 dw_process_id;
	u32 dw_thread_id;
};

struct os__StartupInfo {
	u32 cb;
	u16* lp_reserved;
	u16* lp_desktop;
	u16* lp_title;
	u32 dw_x;
	u32 dw_y;
	u32 dw_x_size;
	u32 dw_y_size;
	u32 dw_x_count_chars;
	u32 dw_y_count_chars;
	u32 dw_fill_attributes;
	u32 dw_flags;
	u16 w_show_window;
	u16 cb_reserved2;
	byteptr lp_reserved2;
	voidptr h_std_input;
	voidptr h_std_output;
	voidptr h_std_error;
};

struct os__SecurityAttributes {
	u32 n_length;
	voidptr lp_security_descriptor;
	bool b_inherit_handle;
};

struct os__ExceptionRecord {
	u32 code;
	u32 flags;
	ExceptionRecord* record;
	voidptr address;
	u32 param_count;
};

typedef int array_fixed_int_3 [3];
struct v__vcache__CacheManager {
	string basepath;
	string vopts;
	map_string_string k2cpath;
};

struct v__util__EManager {
	bool support_color;
};

struct v__token__Position {
	int len;
	int line_nr;
	int pos;
};

struct v__util__Possibility {
	string value;
	string svalue;
	f32 similarity;
};

struct v__util__Suggestion {
	array_v__util__Possibility known;
	string wanted;
	string swanted;
};

struct v__ast__Scope {
	map_string_v__ast__ScopeObject objects;
	array_v__ast__ScopeStructField struct_fields;
	v__ast__Scope* parent;
	array_v__ast__Scope_ptr children;
	int start_pos;
	int end_pos;
};

struct v__builder__MsvcResult {
	string full_cl_exe_path;
	string exe_path;
	string um_lib_path;
	string ucrt_lib_path;
	string vs_lib_path;
	string um_include_path;
	string ucrt_include_path;
	string vs_include_path;
	string shared_include_path;
	bool valid;
};

struct v__table__Table {
	array_v__table__TypeSymbol types;
	map_string_int type_idxs;
	map_string_v__table__Fn fns;
	array_string imports;
	array_string modules;
	array_v__cflag__CFlag cflags;
	array_string redefined_fns;
	map_string_array_v__table__Type fn_gen_types;
	string cmod_prefix;
	bool is_fmt;
};

struct v__depgraph__DepGraph {
	bool acyclic;
	array_v__depgraph__DepGraphNode nodes;
};

struct v__table__GenericStructInst {
	int parent_idx;
	array_v__table__Type generic_types;
};

struct v__table__Struct {
	array_v__table__Field fields;
	bool is_typedef;
	bool is_union;
	bool is_ref_only;
	array_v__table__Type generic_types;
};

struct v__builder__MsvcStringFlags {
	array_string real_libs;
	array_string inc_paths;
	array_string lib_paths;
	array_string defines;
	array_string other_flags;
};

struct rand__PRNGConfigStruct {
	array_u32 seed;
};

struct rand__wyrand__WyRandRNG {
	u64 state;
	bool has_extra;
	u32 extra;
};

struct time__Time {
	int year;
	int month;
	int day;
	int hour;
	int minute;
	int second;
	int microsecond;
	u64 v_unix;
};

struct time__StopWatchOptions {
	bool auto_start;
};

struct time__StopWatch {
	u64 elapsed;
	u64 start;
	u64 end;
};

struct time__SystemTime {
	u16 year;
	u16 month;
	u16 day_of_week;
	u16 day;
	u16 hour;
	u16 minute;
	u16 second;
	u16 millisecond;
};

struct term__Coord {
	int x;
	int y;
};

struct term__Coord16 {
	i16 x;
	i16 y;
};

struct term__SmallRect {
	i16 left;
	i16 top;
	i16 right;
	i16 bottom;
};

struct v__token__Token {
	v__token__Kind kind;
	string lit;
	int line_nr;
	int pos;
	int len;
	int tidx;
};

struct v__vmod__Manifest {
	string name;
	string version;
	string description;
	array_string dependencies;
	string license;
	string repo_url;
	string author;
	map_string_array_string unknown;
};

struct v__vmod__Token {
	v__vmod__TokenKind typ;
	string val;
};

struct v__vmod__Scanner {
	int pos;
	string text;
	bool inside_text;
	array_v__vmod__Token tokens;
};

struct v__vmod__ModFileCacher {
	map_string_v__vmod__ModFileAndFolder cache;
	map_string_array_string folder_files;
};

struct v__ast__CTempVar {
	string name;
	v__ast__Expr orig;
	v__table__Type typ;
	bool is_ptr;
};

struct v__table__Attr {
	string name;
	bool is_string;
	bool is_ctdefine;
	string arg;
	bool is_string_arg;
};

struct v__ast__IdentFn {
	v__table__Type typ;
};

struct v__ast__IdentVar {
	v__table__Type typ;
	bool is_mut;
	bool is_static;
	bool is_optional;
	v__table__ShareType share;
};

struct v__table__TypeSymbol {
	int parent_idx;
	v__table__TypeInfo info;
	v__table__Kind kind;
	string name;
	string source_name;
	array_v__table__Fn methods;
	string mod;
	bool is_public;
	bool is_written;
	v__table__Language language;
};

struct v__table__Field {
	string name;
	v__table__Type typ;
	v__table__FExpr default_expr;
	bool has_default_expr;
	string default_val;
	array_v__table__Attr attrs;
	bool is_pub;
	bool is_mut;
	bool is_global;
	bool is_embed;
	string embed_alias_for;
};

struct v__table__Fn {
	array_v__table__Param params;
	v__table__Type return_type;
	string return_type_source_name;
	bool is_variadic;
	v__table__Language language;
	bool is_generic;
	bool is_pub;
	bool is_deprecated;
	bool is_unsafe;
	bool is_placeholder;
	string mod;
	string ctdefine;
	array_v__table__Attr attrs;
	string name;
	voidptr source_fn;
};

struct v__table__Var {
	string name;
	bool is_mut;
	v__table__Type typ;
};

struct v__table__Aggregate {
	array_v__table__Field fields;
	array_v__table__Type types;
};

struct v__table__Alias {
	v__table__Type parent_type;
	v__table__Language language;
	bool is_import;
};

struct v__table__Chan {
	v__table__Type elem_type;
	bool is_mut;
};

struct v__table__Map {
	v__table__Type key_type;
	v__table__Type value_type;
};

struct v__table__Array {
	int nr_dims;
	v__table__Type elem_type;
};

struct v__table__ArrayFixed {
	int nr_dims;
	int size;
	v__table__Type elem_type;
};

struct v__table__MultiReturn {
	array_v__table__Type types;
};

struct v__table__SumType {
	array_v__table__Type variants;
};

struct v__table__Enum {
	array_string vals;
	bool is_flag;
	bool is_multi_allowed;
};

struct v__table__Interface {
	array_v__table__Type types;
};

struct v__table__FnSignatureOpts {
	bool skip_receiver;
	bool type_only;
};

struct v__scanner__Scanner {
	string file_path;
	string text;
	int pos;
	int line_nr;
	int last_nl_pos;
	bool is_inside_string;
	bool is_inter_start;
	bool is_inter_end;
	bool is_debug;
	string line_comment;
	bool is_started;
	bool is_print_line_on_error;
	bool is_print_colored_error;
	bool is_print_rel_paths_on_error;
	byte quote;
	array_int line_ends;
	int nr_lines;
	bool is_vh;
	bool is_fmt;
	v__scanner__CommentsMode comments_mode;
	bool is_inside_toplvl_statement;
	array_v__token__Token all_tokens;
	int tidx;
	int eofs;
	v__pref__Preferences* pref;
	array_string vet_errors;
	array_v__errors__Error errors;
	array_v__errors__Warning warnings;
};

struct v__depgraph__DepGraphNode {
	string name;
	array_string deps;
};

struct v__depgraph__OrderedDepMap {
	array_string keys;
	map_string_array_string data;
};

struct v__gen__x64__Gen {
	string out_name;
	v__pref__Preferences* pref;
	v__table__Table* table;
	array_byte buf;
	int sect_header_name_pos;
	i64 offset;
	array_i64 str_pos;
	array_string strings;
	i64 file_size_pos;
	i64 main_fn_addr;
	i64 code_start_pos;
	map_string_i64 fn_addr;
	map_string_int var_offset;
	int stack_var_pos;
	int debug_pos;
	array_v__errors__Error errors;
	array_v__errors__Warning warnings;
};

struct v__gen__x64__SectionConfig {
	string name;
	v__gen__x64__SectionType typ;
	i64 flags;
	voidptr data;
	bool is_saa;
	i64 datalen;
	int v_link;
	int info;
	i64 align;
	i64 entsize;
};

struct v__pkgconfig__MainOptions {
	bool modversion;
	bool description;
	bool help;
	bool debug;
	bool listall;
	bool exists;
	bool variables;
	bool requires;
	string atleast;
	string atleastpc;
	string exactversion;
	bool version;
	bool cflags;
	bool cflags_only_path;
	bool cflags_only_other;
	bool stat1c;
	bool libs;
	bool libs_only_link;
	bool libs_only_path;
	bool libs_only_other;
	array_string args;
};

struct v__pkgconfig__Main {
	v__pkgconfig__MainOptions* opt;
	string res;
	bool has_actions;
};

struct v__pkgconfig__Options {
	string path;
	bool debug;
	bool norecurse;
};

struct flag__FlagParser {
	array_string args;
	int max_free_args;
	array_flag__Flag flags;
	string application_name;
	string application_version;
	string application_description;
	int min_free_args;
	string args_description;
};

struct flag__Flag {
	string name;
	byte abbr;
	string usage;
	string val_desc;
};

struct semver__Version {
	int major;
	int minor;
	int patch;
	string prerelease;
	string metadata;
};

struct semver__RawVersion {
	string prerelease;
	string metadata;
	array_string raw_ints;
};

struct semver__ComparatorSet {
	array_semver__Comparator comparators;
};

struct semver__Range {
	array_semver__ComparatorSet comparator_sets;
};

typedef byte array_fixed_byte_26 [26];
typedef byte array_fixed_byte_256 [256];
typedef u16 array_fixed_u16_32768 [32768];
typedef byte array_fixed_byte_4096 [4096];
typedef byte array_fixed_byte_50 [50];
struct SymbolInfo {
	u32 f_size_of_struct;
	u32 f_type_index;
	array_fixed_u64_2 f_reserved;
	u32 f_index;
	u32 f_size;
	u64 f_mod_base;
	u32 f_flags;
	u64 f_value;
	u64 f_address;
	u32 f_register;
	u32 f_scope;
	u32 f_tag;
	u32 f_name_len;
	u32 f_max_name_len;
	byte f_name;
};

struct mapnode {
	voidptr* children;
	int len;
	array_fixed_string_11 keys;
	array_fixed_voidptr_11 values;
};

struct os__FileMode {
	os__FileType typ;
	os__FilePermission owner;
	os__FilePermission group;
	os__FilePermission others;
};

struct os__Win32finddata {
	u32 dw_file_attributes;
	os__Filetime ft_creation_time;
	os__Filetime ft_last_access_time;
	os__Filetime ft_last_write_time;
	u32 n_file_size_high;
	u32 n_file_size_low;
	u32 dw_reserved0;
	u32 dw_reserved1;
	array_fixed_u16_260 c_file_name;
	array_fixed_u16_14 c_alternate_file_name;
	u32 dw_file_type;
	u32 dw_creator_type;
	u16 w_finder_flags;
};

struct os__Process {
	string filename;
	int pid;
	int code;
	os__ProcessState status;
	string err;
	array_string args;
	bool env_is_custom;
	array_string env;
	bool use_stdio_ctl;
	array_fixed_int_3 stdio_fd;
};

struct v__pref__Preferences {
	v__pref__OS os;
	v__pref__Backend backend;
	v__pref__BuildMode build_mode;
	v__pref__OutputMode output_mode;
	bool is_verbose;
	bool is_test;
	bool is_script;
	bool is_vsh;
	bool is_livemain;
	bool is_liveshared;
	bool is_shared;
	bool is_prof;
	string profile_file;
	bool profile_no_inline;
	bool translated;
	bool is_prod;
	bool obfuscate;
	bool is_repl;
	bool is_run;
	bool sanitize;
	bool is_debug;
	bool is_vlines;
	bool show_cc;
	bool show_c_output;
	bool use_cache;
	bool is_stats;
	bool no_auto_free;
	string cflags;
	string ccompiler;
	v__pref__CompilerType ccompiler_type;
	string third_party_option;
	bool building_v;
	bool autofree;
	bool compress;
	bool fast;
	bool enable_globals;
	bool is_fmt;
	bool is_vet;
	bool is_bare;
	bool no_preludes;
	string custom_prelude;
	array_string lookup_path;
	bool output_cross_c;
	bool prealloc;
	string vroot;
	string out_name_c;
	string out_name;
	string display_name;
	string bundle_id;
	string path;
	array_string compile_defines;
	array_string compile_defines_all;
	array_string run_args;
	array_string printfn_list;
	bool print_v_files;
	bool skip_running;
	bool skip_warnings;
	bool warns_are_errors;
	bool reuse_tmpc;
	v__pref__ColorOutput use_color;
	bool is_parallel;
	int error_limit;
	bool is_vweb;
	bool only_check_syntax;
	bool experimental;
	bool show_timings;
	bool is_ios_simulator;
	bool is_apk;
	array_string cleanup_files;
	array_string build_options;
	v__vcache__CacheManager cache_manager;
};

struct v__checker__Checker {
	v__pref__Preferences* pref;
	v__table__Table* table;
	v__ast__File* file;
	int nr_errors;
	int nr_warnings;
	array_v__errors__Error errors;
	array_v__errors__Warning warnings;
	array_int error_lines;
	v__table__Type expected_type;
	v__ast__FnDecl* cur_fn;
	string const_decl;
	array_string const_deps;
	array_string const_names;
	array_string global_names;
	array_string locked_names;
	array_string rlocked_names;
	int in_for_count;
	bool returns;
	bool scope_returns;
	string mod;
	bool is_builtin_mod;
	bool inside_unsafe;
	bool inside_const;
	bool skip_flags;
	v__table__Type cur_generic_type;
	int expr_level;
	bool inside_sql;
	v__table__TypeSymbol cur_orm_ts;
	array_string error_details;
	array_v__ast__FnDecl_ptr generic_funcs;
	string vmod_file_content;
	array_v__table__Type vweb_gen_types;
	bool prevent_sum_type_unwrapping_once;
	string loop_label;
};

struct term__ConsoleScreenBufferInfo {
	term__Coord16 dw_size;
	term__Coord16 dw_cursor_position;
	u16 w_attributes;
	term__SmallRect sr_window;
	term__Coord16 dw_maximum_window_size;
};

struct v__vmod__Parser {
	string file_path;
	v__vmod__Scanner scanner;
};

struct v__ast__AliasTypeDecl {
	string name;
	bool is_pub;
	v__table__Type parent_type;
	v__token__Position pos;
	array_v__ast__Comment comments;
};

struct v__ast__FnTypeDecl {
	string name;
	bool is_pub;
	v__table__Type typ;
	v__token__Position pos;
	array_v__ast__Comment comments;
};

struct v__ast__SumTypeDecl {
	string name;
	bool is_pub;
	v__token__Position pos;
	array_v__ast__Comment comments;
	array_v__ast__SumTypeVariant variants;
};

struct v__ast__ArrayInit {
	v__token__Position pos;
	v__token__Position elem_type_pos;
	array_v__ast__Expr exprs;
	array_array_v__ast__Comment ecmnts;
	bool is_fixed;
	bool has_val;
	string mod;
	v__ast__Expr len_expr;
	v__ast__Expr cap_expr;
	v__ast__Expr default_expr;
	bool has_len;
	bool has_cap;
	bool has_default;
	bool is_interface;
	array_v__table__Type interface_types;
	v__table__Type interface_type;
	v__table__Type elem_type;
	v__table__Type typ;
};

struct v__ast__AsCast {
	v__ast__Expr expr;
	v__table__Type typ;
	v__token__Position pos;
	v__table__Type expr_type;
};

struct v__ast__Assoc {
	string var_name;
	array_string fields;
	array_v__ast__Expr exprs;
	v__token__Position pos;
	v__table__Type typ;
};

struct v__ast__AtExpr {
	string name;
	v__token__Position pos;
	v__token__AtKind kind;
	string val;
};

struct v__ast__BoolLiteral {
	bool val;
	v__token__Position pos;
};

struct v__ast__CastExpr {
	v__ast__Expr expr;
	v__ast__Expr arg;
	v__table__Type typ;
	v__token__Position pos;
	string typname;
	v__table__Type expr_type;
	bool has_arg;
	bool in_prexpr;
};

struct v__ast__ChanInit {
	v__token__Position pos;
	v__ast__Expr cap_expr;
	bool has_cap;
	v__table__Type typ;
	v__table__Type elem_type;
};

struct v__ast__CharLiteral {
	string val;
	v__token__Position pos;
};

struct v__ast__Comment {
	string text;
	bool is_multi;
	int line_nr;
	v__token__Position pos;
};

struct v__ast__ConcatExpr {
	array_v__ast__Expr vals;
	v__token__Position pos;
	v__table__Type return_type;
};

struct v__ast__EnumVal {
	string enum_name;
	string val;
	string mod;
	v__token__Position pos;
	v__table__Type typ;
};

struct v__ast__FloatLiteral {
	string val;
	v__token__Position pos;
};

struct v__ast__Ident {
	v__table__Language language;
	v__token__Kind tok_kind;
	v__token__Position pos;
	v__token__Position mut_pos;
	v__ast__ScopeObject obj;
	string mod;
	string name;
	v__ast__IdentKind kind;
	v__ast__IdentInfo info;
	bool is_mut;
};

struct v__ast__IfExpr {
	bool is_comptime;
	v__token__Kind tok_kind;
	v__ast__Expr left;
	v__token__Position pos;
	array_v__ast__Comment post_comments;
	array_v__ast__IfBranch branches;
	bool is_expr;
	v__table__Type typ;
	bool has_else;
};

struct v__ast__IfGuardExpr {
	string var_name;
	v__ast__Expr expr;
	v__token__Position pos;
	v__table__Type expr_type;
};

struct v__ast__IndexExpr {
	v__token__Position pos;
	v__ast__Expr left;
	v__ast__Expr index;
	v__table__Type left_type;
	bool is_setter;
};

struct v__ast__InfixExpr {
	v__token__Kind op;
	v__token__Position pos;
	v__ast__Expr left;
	v__ast__Expr right;
	v__table__Type left_type;
	v__table__Type right_type;
	string auto_locked;
};

struct v__ast__IntegerLiteral {
	string val;
	v__token__Position pos;
};

struct v__ast__Likely {
	v__ast__Expr expr;
	v__token__Position pos;
	bool is_likely;
};

struct v__ast__LockExpr {
	array_v__ast__Stmt stmts;
	bool is_rlock;
	v__token__Position pos;
	array_v__ast__Ident lockeds;
	bool is_expr;
	v__table__Type typ;
};

struct v__ast__MapInit {
	v__token__Position pos;
	array_v__ast__Expr keys;
	array_v__ast__Expr vals;
	v__table__Type typ;
	v__table__Type key_type;
	v__table__Type value_type;
};

struct v__ast__MatchExpr {
	v__token__Kind tok_kind;
	v__ast__Expr cond;
	array_v__ast__MatchBranch branches;
	v__token__Position pos;
	bool is_expr;
	v__table__Type return_type;
	v__table__Type cond_type;
	v__table__Type expected_type;
	bool is_sum_type;
};

struct v__ast__None {
	v__token__Position pos;
	int foo;
};

struct v__ast__OrExpr {
	array_v__ast__Stmt stmts;
	v__ast__OrKind kind;
	v__token__Position pos;
};

struct v__ast__ParExpr {
	v__ast__Expr expr;
	v__token__Position pos;
};

struct v__ast__PostfixExpr {
	v__token__Kind op;
	v__ast__Expr expr;
	v__token__Position pos;
	string auto_locked;
};

struct v__ast__RangeExpr {
	v__ast__Expr low;
	v__ast__Expr high;
	bool has_high;
	bool has_low;
	v__token__Position pos;
};

struct v__ast__SelectExpr {
	array_v__ast__SelectBranch branches;
	v__token__Position pos;
	bool has_exception;
	bool is_expr;
	v__table__Type expected_type;
};

struct v__ast__SelectorExpr {
	v__token__Position pos;
	v__ast__Expr expr;
	string field_name;
	bool is_mut;
	v__token__Position mut_pos;
	v__table__Type expr_type;
	v__table__Type typ;
	v__table__Type name_type;
};

struct v__ast__SizeOf {
	bool is_type;
	v__table__Type typ;
	string type_name;
	v__ast__Expr expr;
	v__token__Position pos;
};

struct v__ast__SqlExpr {
	v__table__Type typ;
	bool is_count;
	v__ast__Expr db_expr;
	v__ast__Expr where_expr;
	bool has_where;
	bool has_offset;
	v__ast__Expr offset_expr;
	bool has_order;
	v__ast__Expr order_expr;
	bool has_desc;
	bool is_array;
	v__table__Type table_type;
	v__token__Position pos;
	bool has_limit;
	v__ast__Expr limit_expr;
	string table_name;
	array_v__table__Field fields;
};

struct v__ast__StringInterLiteral {
	array_string vals;
	array_v__ast__Expr exprs;
	array_int fwidths;
	array_int precisions;
	array_bool pluss;
	array_bool fills;
	array_v__token__Position fmt_poss;
	v__token__Position pos;
	array_v__table__Type expr_types;
	array_byte fmts;
	array_bool need_fmts;
};

struct v__ast__StringLiteral {
	string val;
	bool is_raw;
	v__table__Language language;
	v__token__Position pos;
};

struct v__ast__StructInit {
	v__token__Position pos;
	bool is_short;
	array_v__ast__Comment pre_comments;
	v__table__Type typ;
	array_v__ast__StructInitField fields;
};

struct v__ast__Type {
	v__table__Type typ;
	v__token__Position pos;
};

struct v__ast__TypeOf {
	v__ast__Expr expr;
	v__token__Position pos;
	v__table__Type expr_type;
};

struct v__ast__UnsafeExpr {
	v__ast__Expr expr;
	v__token__Position pos;
};

struct v__ast__AssertStmt {
	v__token__Position pos;
	v__ast__Expr expr;
};

struct v__ast__AssignStmt {
	array_v__ast__Expr right;
	v__token__Kind op;
	v__token__Position pos;
	array_v__ast__Comment comments;
	array_v__ast__Expr left;
	array_v__table__Type left_types;
	array_v__table__Type right_types;
	bool is_static;
	bool is_simple;
	bool has_cross_var;
};

struct v__ast__Block {
	array_v__ast__Stmt stmts;
	bool is_unsafe;
	v__token__Position pos;
};

struct v__ast__BranchStmt {
	v__token__Kind kind;
	string label;
	v__token__Position pos;
};

struct v__ast__CompFor {
	string val_var;
	array_v__ast__Stmt stmts;
	v__ast__CompForKind kind;
	v__token__Position pos;
	v__table__Type typ;
};

struct v__ast__ConstDecl {
	bool is_pub;
	v__token__Position pos;
	array_v__ast__ConstField fields;
	array_v__ast__Comment end_comments;
};

struct v__ast__DeferStmt {
	array_v__ast__Stmt stmts;
	v__token__Position pos;
	string ifdef;
};

struct v__ast__EnumDecl {
	string name;
	bool is_pub;
	bool is_flag;
	bool is_multi_allowed;
	array_v__ast__Comment comments;
	array_v__ast__EnumField fields;
	array_v__table__Attr attrs;
	v__token__Position pos;
};

struct v__ast__ExprStmt {
	v__ast__Expr expr;
	v__token__Position pos;
	array_v__ast__Comment comments;
	bool is_expr;
	v__table__Type typ;
};

struct v__ast__ForCStmt {
	v__ast__Stmt init;
	bool has_init;
	v__ast__Expr cond;
	bool has_cond;
	v__ast__Stmt inc;
	bool has_inc;
	array_v__ast__Stmt stmts;
	v__token__Position pos;
	string label;
};

struct v__ast__ForInStmt {
	string key_var;
	string val_var;
	v__ast__Expr cond;
	bool is_range;
	v__ast__Expr high;
	array_v__ast__Stmt stmts;
	v__token__Position pos;
	bool val_is_mut;
	v__table__Type key_type;
	v__table__Type val_type;
	v__table__Type cond_type;
	v__table__Kind kind;
	string label;
};

struct v__ast__ForStmt {
	v__ast__Expr cond;
	array_v__ast__Stmt stmts;
	bool is_inf;
	v__token__Position pos;
	string label;
};

struct v__ast__GlobalDecl {
	v__token__Position pos;
	array_v__ast__GlobalField fields;
	array_v__ast__Comment end_comments;
};

struct v__ast__GoStmt {
	v__ast__Expr call_expr;
	v__token__Position pos;
};

struct v__ast__GotoLabel {
	string name;
	v__token__Position pos;
};

struct v__ast__GotoStmt {
	string name;
	v__token__Position pos;
};

struct v__ast__HashStmt {
	string mod;
	v__token__Position pos;
	string val;
	string kind;
	string main;
	string msg;
};

struct v__ast__Import {
	v__token__Position pos;
	string mod;
	string alias;
	array_v__ast__ImportSymbol syms;
};

struct v__ast__InterfaceDecl {
	string name;
	array_string field_names;
	bool is_pub;
	array_v__ast__FnDecl methods;
	v__token__Position pos;
	array_v__ast__Comment pre_comments;
};

struct v__ast__Module {
	string name;
	string path;
	v__ast__Expr expr;
	v__token__Position pos;
	bool is_skipped;
};

struct v__ast__Return {
	v__token__Position pos;
	array_v__ast__Expr exprs;
	array_v__ast__Comment comments;
	array_v__table__Type types;
};

struct v__ast__SqlStmt {
	v__ast__SqlStmtKind kind;
	v__ast__Expr db_expr;
	string object_var_name;
	v__table__Type table_type;
	v__token__Position pos;
	v__ast__Expr where_expr;
	array_string updated_columns;
	array_v__ast__Expr update_exprs;
	string table_name;
	array_v__table__Field fields;
};

struct v__ast__StructDecl {
	v__token__Position pos;
	string name;
	array_v__table__Type gen_types;
	bool is_pub;
	int mut_pos;
	int pub_pos;
	int pub_mut_pos;
	v__table__Language language;
	bool is_union;
	array_v__table__Attr attrs;
	array_v__ast__Comment end_comments;
	array_v__ast__StructField fields;
};

struct v__ast__ConstField {
	string mod;
	string name;
	v__ast__Expr expr;
	bool is_pub;
	v__token__Position pos;
	v__table__Type typ;
	array_v__ast__Comment comments;
};

struct v__ast__GlobalField {
	string name;
	v__ast__Expr expr;
	bool has_expr;
	v__token__Position pos;
	v__table__Type typ;
	array_v__ast__Comment comments;
};

struct v__ast__Var {
	string name;
	v__ast__Expr expr;
	v__table__ShareType share;
	bool is_mut;
	bool is_autofree_tmp;
	bool is_arg;
	v__table__Type typ;
	array_v__table__Type sum_type_casts;
	v__token__Position pos;
	bool is_used;
	bool is_changed;
};

struct v__ast__StructField {
	v__token__Position pos;
	v__token__Position type_pos;
	array_v__ast__Comment comments;
	v__ast__Expr default_expr;
	bool has_default_expr;
	array_v__table__Attr attrs;
	bool is_public;
	bool is_embed;
	string name;
	v__table__Type typ;
};

struct v__ast__Field {
	string name;
	v__token__Position pos;
	v__table__Type typ;
};

struct v__ast__StructEmbedding {
	string name;
	v__table__Type typ;
	v__token__Position pos;
};

struct v__ast__StructInitField {
	v__ast__Expr expr;
	v__token__Position pos;
	array_v__ast__Comment comments;
	string name;
	v__table__Type typ;
	v__table__Type expected_type;
};

struct v__ast__ImportSymbol {
	v__token__Position pos;
	string name;
	v__ast__ImportSymbolKind kind;
};

struct v__table__Param {
	v__token__Position pos;
	string name;
	bool is_mut;
	v__table__Type typ;
	string type_source_name;
	bool is_hidden;
};

struct v__ast__CallArg {
	bool is_mut;
	v__table__ShareType share;
	v__ast__Expr expr;
	array_v__ast__Comment comments;
	v__table__Type typ;
	bool is_tmp_autofree;
	v__token__Position pos;
};

struct v__ast__ScopeStructField {
	v__table__Type struct_type;
	string name;
	v__token__Position pos;
	v__table__Type typ;
	array_v__table__Type sum_type_casts;
};

struct v__errors__Error {
	string message;
	string details;
	string file_path;
	v__token__Position pos;
	string backtrace;
	v__errors__Reporter reporter;
};

struct v__errors__Warning {
	string message;
	string details;
	string file_path;
	v__token__Position pos;
	v__errors__Reporter reporter;
};

struct v__ast__IfBranch {
	v__ast__Expr cond;
	v__token__Position pos;
	v__token__Position body_pos;
	array_v__ast__Comment comments;
	array_v__ast__Stmt stmts;
	bool smartcast;
};

struct v__ast__MatchBranch {
	array_v__ast__Expr exprs;
	array_array_v__ast__Comment ecmnts;
	array_v__ast__Stmt stmts;
	v__token__Position pos;
	array_v__ast__Comment comments;
	bool is_else;
	array_v__ast__Comment post_comments;
};

struct v__ast__EnumField {
	string name;
	v__token__Position pos;
	array_v__ast__Comment comments;
	v__ast__Expr expr;
	bool has_expr;
};

struct v__ast__SumTypeVariant {
	v__table__Type typ;
	v__token__Position pos;
};

struct v__table__FnType {
	bool is_anon;
	bool has_decl;
	v__table__Fn func;
};

struct v__parser__Parser {
	string file_base;
	string file_name;
	string file_name_dir;
	v__pref__Preferences* pref;
	v__scanner__Scanner* scanner;
	v__scanner__CommentsMode comments_mode;
	v__token__Token tok;
	v__token__Token prev_tok;
	v__token__Token peek_tok;
	v__token__Token peek_tok2;
	v__token__Token peek_tok3;
	v__table__Table* table;
	v__table__Language language;
	bool inside_if;
	bool inside_if_expr;
	bool inside_ct_if_expr;
	bool inside_or_expr;
	bool inside_for;
	bool inside_fn;
	bool inside_str_interp;
	bool builtin_mod;
	string mod;
	array_v__table__Attr attrs;
	string expr_mod;
	v__ast__Scope* scope;
	v__ast__Scope* global_scope;
	map_string_string imports;
	array_v__ast__Import ast_imports;
	array_string used_imports;
	bool is_amp;
	bool returns;
	bool inside_match;
	bool inside_select;
	bool inside_match_case;
	bool inside_match_body;
	bool inside_unsafe;
	bool is_stmt_ident;
	bool expecting_type;
	array_v__errors__Error errors;
	array_v__errors__Warning warnings;
	array_string vet_errors;
	string cur_fn_name;
	bool in_generic_params;
};

struct v__pkgconfig__PkgConfig {
	v__pkgconfig__Options options;
	array_string libs;
	array_string libs_private;
	array_string cflags;
	array_string paths;
	map_string_string vars;
	array_string requires;
	string version;
	string description;
	string name;
	string modname;
};

struct semver__Comparator {
	semver__Version ver;
	semver__Operator op;
};

struct SymbolInfoContainer {
	SymbolInfo syminfo;
	array_fixed_char_254 f_name_rest;
};

struct v__ast__File {
	string path;
	v__ast__Module mod;
	v__ast__Scope* global_scope;
	v__ast__Scope* scope;
	array_v__ast__Stmt stmts;
	array_v__ast__Import imports;
	array_v__errors__Error errors;
	array_v__errors__Warning warnings;
};

struct v__builder__Builder {
	string compiled_dir;
	string module_path;
	v__pref__Preferences* pref;
	v__checker__Checker checker;
	v__ast__Scope* global_scope;
	string out_name_c;
	string out_name_js;
	int max_nr_errors;
	array_string module_search_paths;
	array_v__ast__File parsed_files;
	v__builder__MsvcResult cached_msvc;
	v__table__Table* table;
};

struct v__ast__FnDecl {
	string name;
	string mod;
	array_v__table__Param params;
	bool is_deprecated;
	bool is_pub;
	bool is_variadic;
	bool is_anon;
	v__ast__Field receiver;
	v__token__Position receiver_pos;
	bool is_method;
	int method_idx;
	bool rec_mut;
	v__table__ShareType rec_share;
	v__table__Language language;
	bool no_body;
	bool is_builtin;
	v__token__Position pos;
	v__token__Position body_pos;
	string file;
	bool is_generic;
	bool is_direct_arr;
	array_v__table__Attr attrs;
	array_v__ast__Stmt stmts;
	v__table__Type return_type;
	array_v__ast__Comment comments;
	v__ast__File* source_file;
};

struct v__ast__CallExpr {
	v__token__Position pos;
	v__ast__Expr left;
	string mod;
	string name;
	bool is_method;
	bool is_field;
	array_v__ast__CallArg args;
	array_v__table__Type expected_arg_types;
	v__table__Language language;
	v__ast__OrExpr or_block;
	v__table__Type left_type;
	v__table__Type receiver_type;
	v__table__Type return_type;
	bool should_be_skipped;
	v__table__Type generic_type;
	v__token__Position generic_list_pos;
	bool free_receiver;
};

struct v__ast__PrefixExpr {
	v__token__Kind op;
	v__ast__Expr right;
	v__token__Position pos;
	v__table__Type right_type;
	v__ast__OrExpr or_block;
};

struct v__ast__SelectBranch {
	v__ast__Stmt stmt;
	array_v__ast__Stmt stmts;
	v__token__Position pos;
	v__ast__Comment comment;
	bool is_else;
	bool is_timeout;
	array_v__ast__Comment post_comments;
};

struct v__builder__FunctionRedefinition {
	string fpath;
	int fline;
	string fheader;
	v__ast__FnDecl f;
};

struct v__ast__AnonFn {
	v__ast__FnDecl decl;
	v__table__Type typ;
};

struct v__ast__ComptimeCall {
	string method_name;
	v__ast__Expr left;
	bool is_vweb;
	v__ast__File vweb_tmpl;
	string args_var;
	v__table__TypeSymbol sym;
};

struct v__gen__Gen {
	v__pref__Preferences* pref;
	string module_built;
	v__table__Table* table;
	strings__Builder out;
	strings__Builder cheaders;
	strings__Builder includes;
	strings__Builder typedefs;
	strings__Builder typedefs2;
	strings__Builder type_definitions;
	strings__Builder definitions;
	map_string_strings__Builder inits;
	map_string_strings__Builder cleanups;
	strings__Builder gowrappers;
	strings__Builder stringliterals;
	strings__Builder auto_str_funcs;
	strings__Builder comptime_defines;
	strings__Builder pcs_declarations;
	strings__Builder hotcode_definitions;
	strings__Builder shared_types;
	strings__Builder channel_definitions;
	strings__Builder options_typedefs;
	strings__Builder options;
	strings__Builder json_forward_decls;
	strings__Builder enum_typedefs;
	strings__Builder sql_buf;
	v__ast__File file;
	v__ast__FnDecl* fn_decl;
	string last_fn_c_name;
	int tmp_count;
	int tmp_count2;
	map_string_int variadic_args;
	bool is_c_call;
	bool is_assign_lhs;
	bool is_assign_rhs;
	bool is_array_set;
	bool is_amp;
	bool is_sql;
	bool is_shared;
	bool is_vlines_enabled;
	string vlines_path;
	array_string optionals;
	array_string chan_pop_optionals;
	array_int shareds;
	int inside_ternary;
	bool inside_map_postfix;
	bool inside_map_infix;
	map_string_string ternary_names;
	map_string_array_string ternary_level_names;
	array_int stmt_path_pos;
	bool skip_stmt_pos;
	bool right_is_opt;
	bool autofree;
	int indent;
	bool empty_line;
	bool is_test;
	v__token__Kind assign_op;
	array_v__ast__DeferStmt defer_stmts;
	string defer_ifdef;
	string defer_profile_code;
	array_string str_types;
	array_string threaded_fns;
	array_string array_fn_definitions;
	array_string map_fn_definitions;
	bool is_json_fn;
	array_string json_types;
	array_v__gen__ProfileCounterMeta pcs;
	bool is_builtin_mod;
	array_string hotcode_fn_names;
	v__table__Type cur_generic_type;
	int sql_i;
	string sql_stmt_name;
	v__gen__SqlExprSide sql_side;
	bool inside_vweb_tmpl;
	bool inside_return;
	bool inside_or_block;
	array_string strs_to_free0;
	bool inside_call;
	bool has_main;
	bool inside_const;
	string comp_for_method;
	map_string_v__table__Type comptime_var_type_map;
	string called_fn_name;
	string cur_mod;
	bool is_js_call;
	bool inside_lambda;
	bool prevent_sum_type_unwrapping_once;
	int aggregate_type_idx;
};

struct v__gen__js__JsGen {
	v__table__Table* table;
	v__pref__Preferences* pref;
	strings__Builder definitions;
	strings__Builder out;
	map_string_strings__Builder namespaces;
	map_string_array_string namespaces_pub;
	map_string_map_string_string namespace_imports;
	string v_namespace;
	v__gen__js__JsDoc* doc;
	bool enable_doc;
	v__ast__File file;
	int tmp_count;
	bool inside_ternary;
	bool inside_loop;
	bool inside_map_set;
	bool is_test;
	map_string_int indents;
	int stmt_start_pos;
	array_v__ast__DeferStmt defer_stmts;
	v__ast__FnDecl* fn_decl;
	array_string str_types;
	map_string_array_v__ast__FnDecl method_fn_decls;
	array_string builtin_fns;
	bool empty_line;
};


// BEGIN_multi_return_structs
typedef struct {
	u32 arg0;
	u32 arg1;
} multi_return_u32_u32;

typedef struct {
	u32 arg0;
	u32 arg1;
	u32 arg2;
} multi_return_u32_u32_u32;

typedef struct {
	int arg0;
	strconv__PrepNumber arg1;
} multi_return_int_strconv__PrepNumber;

typedef struct {
	u64 arg0;
	int arg1;
} multi_return_u64_int;

typedef struct {
	strconv__Dec32 arg0;
	bool arg1;
} multi_return_strconv__Dec32_bool;

typedef struct {
	strconv__Dec64 arg0;
	bool arg1;
} multi_return_strconv__Dec64_bool;

typedef struct {
	string arg0;
	int arg1;
} multi_return_string_int;

typedef struct {
	int arg0;
	bool arg1;
} multi_return_int_bool;

typedef struct {
	v__pref__Preferences* arg0;
	string arg1;
} multi_return_v__pref__Preferences_string;

typedef struct {
	u64 arg0;
	u64 arg1;
} multi_return_u64_u64;

typedef struct {
	int arg0;
	int arg1;
	int arg2;
} multi_return_int_int_int;

typedef struct {
	int arg0;
	int arg1;
} multi_return_int_int;

typedef struct {
	array_string arg0;
	int arg1;
} multi_return_array_string_int;

typedef struct {
	array_string arg0;
	v__vmod__ModFileAndFolder arg1;
} multi_return_array_string_v__vmod__ModFileAndFolder;

typedef struct {
	v__ast__ScopeObject arg0;
	v__ast__Scope* arg1;
} multi_return_v__ast__ScopeObject_v__ast__Scope;

typedef struct {
	string arg0;
	bool arg1;
} multi_return_string_bool;

typedef struct {
	bool arg0;
	bool arg1;
	int arg2;
} multi_return_bool_bool_int;

typedef struct {
	string arg0;
	v__token__Position arg1;
} multi_return_string_v__token__Position;

typedef struct {
	bool arg0;
	int arg1;
	int arg2;
} multi_return_bool_int_int;

typedef struct {
	array_v__table__Param arg0;
	bool arg1;
	bool arg2;
} multi_return_array_v__table__Param_bool_bool;

typedef struct {
	v__ast__File arg0;
	array_string arg1;
} multi_return_v__ast__File_array_string;

typedef struct {
	array_v__ast__Expr arg0;
	array_v__ast__Comment arg1;
} multi_return_array_v__ast__Expr_array_v__ast__Comment;

typedef struct {
	string arg0;
	string arg1;
} multi_return_string_string;

typedef struct {
	int arg0;
	string arg1;
	string arg2;
	string arg3;
} multi_return_int_string_string_string;

typedef struct {
	array_string arg0;
	array_string arg1;
} multi_return_array_string_array_string;

// END_multi_return_structs

string strings__Builder_str_no_ptr(strings__Builder it); // auto no_ptr version
string time__FormatTime_str(time__FormatTime it); // auto
string time__FormatDate_str(time__FormatDate it); // auto
string v__table__Type_str(v__table__Type it); // auto
string indent_v__table__Type_str(v__table__Type it, int indent_count); // auto
string v__table__FExpr_str(v__table__FExpr x); // auto
string indent_v__table__FExpr_str(v__table__FExpr x, int indent_count); // auto
string array_v__table__Attr_str(array_v__table__Attr a); // auto
string indent_array_v__table__Attr_str(array_v__table__Attr a, int indent_count); // auto
string v__table__Field_str(v__table__Field x); // auto
string indent_v__table__Field_str(v__table__Field x, int indent_count); // auto
string array_v__table__Field_str(array_v__table__Field a); // auto
string indent_array_v__table__Field_str(array_v__table__Field a, int indent_count); // auto
string array_v__table__Type_str(array_v__table__Type a); // auto
string indent_array_v__table__Type_str(array_v__table__Type a, int indent_count); // auto
string v__table__Aggregate_str(v__table__Aggregate x); // auto
string indent_v__table__Aggregate_str(v__table__Aggregate x, int indent_count); // auto
string v__table__Language_str(v__table__Language it); // auto
string v__table__Alias_str(v__table__Alias x); // auto
string indent_v__table__Alias_str(v__table__Alias x, int indent_count); // auto
string v__table__Array_str(v__table__Array x); // auto
string indent_v__table__Array_str(v__table__Array x, int indent_count); // auto
string v__table__ArrayFixed_str(v__table__ArrayFixed x); // auto
string indent_v__table__ArrayFixed_str(v__table__ArrayFixed x, int indent_count); // auto
string v__table__Chan_str(v__table__Chan x); // auto
string indent_v__table__Chan_str(v__table__Chan x, int indent_count); // auto
string v__table__Enum_str(v__table__Enum x); // auto
string indent_v__table__Enum_str(v__table__Enum x, int indent_count); // auto
string v__table__Param_str(v__table__Param x); // auto
string indent_v__table__Param_str(v__table__Param x, int indent_count); // auto
string array_v__table__Param_str(array_v__table__Param a); // auto
string indent_array_v__table__Param_str(array_v__table__Param a, int indent_count); // auto
string v__table__Fn_str(v__table__Fn x); // auto
string indent_v__table__Fn_str(v__table__Fn x, int indent_count); // auto
string v__table__FnType_str(v__table__FnType x); // auto
string indent_v__table__FnType_str(v__table__FnType x, int indent_count); // auto
string v__table__GenericStructInst_str(v__table__GenericStructInst x); // auto
string indent_v__table__GenericStructInst_str(v__table__GenericStructInst x, int indent_count); // auto
string v__table__Interface_str(v__table__Interface x); // auto
string indent_v__table__Interface_str(v__table__Interface x, int indent_count); // auto
string v__table__Map_str(v__table__Map x); // auto
string indent_v__table__Map_str(v__table__Map x, int indent_count); // auto
string v__table__MultiReturn_str(v__table__MultiReturn x); // auto
string indent_v__table__MultiReturn_str(v__table__MultiReturn x, int indent_count); // auto
string v__table__Struct_str(v__table__Struct x); // auto
string indent_v__table__Struct_str(v__table__Struct x, int indent_count); // auto
string v__table__SumType_str(v__table__SumType x); // auto
string indent_v__table__SumType_str(v__table__SumType x, int indent_count); // auto
string v__table__TypeInfo_str(v__table__TypeInfo x); // auto
string indent_v__table__TypeInfo_str(v__table__TypeInfo x, int indent_count); // auto
string v__pref__Backend_str(v__pref__Backend it); // auto
string v__ast__BranchStmt_str_no_ptr(v__ast__BranchStmt it); // auto no_ptr version
string v__table__TypeSymbol_str_no_ptr(v__table__TypeSymbol it); // auto no_ptr version
string v__ast__IdentKind_str(v__ast__IdentKind it); // auto
string v__gen__x64__Register_str(v__gen__x64__Register it); // auto
string v__errors__Reporter_str(v__errors__Reporter it); // auto
string array_v__cflag__CFlag_str(array_v__cflag__CFlag a); // auto
string indent_array_v__cflag__CFlag_str(array_v__cflag__CFlag a, int indent_count); // auto

//BEGIN_variadic_structs
struct varg_voidptr {
	int len;
	voidptr args[0];
};

struct varg_string {
	int len;
	string args[4];
};

struct varg_int {
	int len;
	int args[1];
};

// END_variadic_structs


// V Option_xxx definitions:
struct Option_int {
	bool ok;
	bool is_none;
	string v_error;
	int ecode;
	byte data[sizeof(int)];
};

struct Option_string {
	bool ok;
	bool is_none;
	string v_error;
	int ecode;
	byte data[sizeof(string)];
};

struct Option_void {
	bool ok;
	bool is_none;
	string v_error;
	int ecode;
	byte data[sizeof(int)];
};

struct Option_array_byte {
	bool ok;
	bool is_none;
	string v_error;
	int ecode;
	byte data[sizeof(array_byte)];
};

struct Option_FILE_ptr {
	bool ok;
	bool is_none;
	string v_error;
	int ecode;
	byte data[sizeof(FILE*)];
};

struct Option_array_string {
	bool ok;
	bool is_none;
	string v_error;
	int ecode;
	byte data[sizeof(array_string)];
};

struct Option_bool {
	bool ok;
	bool is_none;
	string v_error;
	int ecode;
	byte data[sizeof(bool)];
};

struct Option_array_ustring {
	bool ok;
	bool is_none;
	string v_error;
	int ecode;
	byte data[sizeof(array_ustring)];
};

struct Option_os__File {
	bool ok;
	bool is_none;
	string v_error;
	int ecode;
	byte data[sizeof(os__File)];
};

struct Option_os__Result {
	bool ok;
	bool is_none;
	string v_error;
	int ecode;
	byte data[sizeof(os__Result)];
};

struct Option_time__Time {
	bool ok;
	bool is_none;
	string v_error;
	int ecode;
	byte data[sizeof(time__Time)];
};

struct Option_f64 {
	bool ok;
	bool is_none;
	string v_error;
	int ecode;
	byte data[sizeof(f64)];
};

struct Option_semver__Range {
	bool ok;
	bool is_none;
	string v_error;
	int ecode;
	byte data[sizeof(semver__Range)];
};

struct Option_semver__Version {
	bool ok;
	bool is_none;
	string v_error;
	int ecode;
	byte data[sizeof(semver__Version)];
};

struct Option_semver__ComparatorSet {
	bool ok;
	bool is_none;
	string v_error;
	int ecode;
	byte data[sizeof(semver__ComparatorSet)];
};

struct Option_semver__Comparator {
	bool ok;
	bool is_none;
	string v_error;
	int ecode;
	byte data[sizeof(semver__Comparator)];
};

struct Option_v__vmod__Manifest {
	bool ok;
	bool is_none;
	string v_error;
	int ecode;
	byte data[sizeof(v__vmod__Manifest)];
};

struct Option_multi_return_array_string_int {
	bool ok;
	bool is_none;
	string v_error;
	int ecode;
	byte data[sizeof(multi_return_array_string_int)];
};

struct Option_v__pkgconfig__PkgConfig_ptr {
	bool ok;
	bool is_none;
	string v_error;
	int ecode;
	byte data[sizeof(v__pkgconfig__PkgConfig*)];
};

struct Option_v__pkgconfig__Main_ptr {
	bool ok;
	bool is_none;
	string v_error;
	int ecode;
	byte data[sizeof(v__pkgconfig__Main*)];
};

struct Option_v__table__Fn {
	bool ok;
	bool is_none;
	string v_error;
	int ecode;
	byte data[sizeof(v__table__Fn)];
};

struct Option_v__table__Field {
	bool ok;
	bool is_none;
	string v_error;
	int ecode;
	byte data[sizeof(v__table__Field)];
};

struct Option_v__table__TypeSymbol {
	bool ok;
	bool is_none;
	string v_error;
	int ecode;
	byte data[sizeof(v__table__TypeSymbol)];
};

struct Option_v__pref__OS {
	bool ok;
	bool is_none;
	string v_error;
	int ecode;
	byte data[sizeof(v__pref__OS)];
};

struct Option_v__pref__Backend {
	bool ok;
	bool is_none;
	string v_error;
	int ecode;
	byte data[sizeof(v__pref__Backend)];
};

struct Option_multi_return_v__ast__ScopeObject_v__ast__Scope {
	bool ok;
	bool is_none;
	string v_error;
	int ecode;
	byte data[sizeof(multi_return_v__ast__ScopeObject_v__ast__Scope)];
};

struct Option_v__ast__ScopeObject {
	bool ok;
	bool is_none;
	string v_error;
	int ecode;
	byte data[sizeof(v__ast__ScopeObject)];
};

struct Option_v__ast__ScopeStructField {
	bool ok;
	bool is_none;
	string v_error;
	int ecode;
	byte data[sizeof(v__ast__ScopeStructField)];
};

struct Option_v__ast__Var_ptr {
	bool ok;
	bool is_none;
	string v_error;
	int ecode;
	byte data[sizeof(v__ast__Var*)];
};

struct Option_v__ast__ConstField_ptr {
	bool ok;
	bool is_none;
	string v_error;
	int ecode;
	byte data[sizeof(v__ast__ConstField*)];
};

struct Option_v__ast__IntegerLiteral {
	bool ok;
	bool is_none;
	string v_error;
	int ecode;
	byte data[sizeof(v__ast__IntegerLiteral)];
};

struct Option_v__builder__MsvcResult {
	bool ok;
	bool is_none;
	string v_error;
	int ecode;
	byte data[sizeof(v__builder__MsvcResult)];
};

struct Option_v__builder__WindowsKit {
	bool ok;
	bool is_none;
	string v_error;
	int ecode;
	byte data[sizeof(v__builder__WindowsKit)];
};

struct Option_v__builder__VsInstallation {
	bool ok;
	bool is_none;
	string v_error;
	int ecode;
	byte data[sizeof(v__builder__VsInstallation)];
};


// V json forward decls:

// V definitions:
void _STR_PRINT_ARG(const char*, char**, int*, int*, int, ...);
string _STR(const char*, int, ...);
string _STR_TMP(const char*, ...);
// end of definitions #endif
strings__Builder strings__new_builder(int initial_size);
void strings__Builder_write_bytes(strings__Builder* b, byteptr bytes, int howmany);
void strings__Builder_write_b(strings__Builder* b, byte data);
void strings__Builder_write(strings__Builder* b, string s);
void strings__Builder_go_back(strings__Builder* b, int n);
VV_LOCAL_SYMBOL string strings__bytes2string(array_byte b);
string strings__Builder_cut_last(strings__Builder* b, int n);
void strings__Builder_go_back_to(strings__Builder* b, int pos);
void strings__Builder_writeln(strings__Builder* b, string s);
string strings__Builder_last_n(strings__Builder* b, int n);
string strings__Builder_after(strings__Builder* b, int n);
string strings__Builder_str(strings__Builder* b);
void strings__Builder_free(strings__Builder* b);
int strings__levenshtein_distance(string a, string b);
f32 strings__levenshtein_distance_percentage(string a, string b);
f32 strings__dice_coefficient(string s1, string s2);
string strings__repeat(byte c, int n);
string strings__repeat_string(string s, int n);
u64 _const_hash__wyp0; // inited later
u64 _const_hash__wyp1; // inited later
u64 _const_hash__wyp2; // inited later
u64 _const_hash__wyp3; // inited later
u64 _const_hash__wyp4; // inited later
u64 hash__wyhash_c(byteptr key, u64 len, u64 seed);
u64 hash__sum64_string(string key, u64 seed);
u64 hash__sum64(array_byte key, u64 seed);
VV_LOCAL_SYMBOL u64 hash__wyhash64(byteptr key, u64 len, u64 seed_);
VV_LOCAL_SYMBOL u64 hash__wyrotr(u64 v, u32 k);
u64 hash__wymum(u64 a, u64 b);
VV_LOCAL_SYMBOL u64 hash__wyr3(byteptr p, u64 k);
VV_LOCAL_SYMBOL u64 hash__wyr4(byteptr p);
VV_LOCAL_SYMBOL u64 hash__wyr8(byteptr p);
u32 _const_math__bits__de_bruijn32; // inited later
array_byte _const_math__bits__de_bruijn32tab; // inited later
u64 _const_math__bits__de_bruijn64; // inited later
array_byte _const_math__bits__de_bruijn64tab; // inited later
u64 _const_math__bits__m0; // inited later
u64 _const_math__bits__m1; // inited later
u64 _const_math__bits__m2; // inited later
u64 _const_math__bits__m3; // inited later
u64 _const_math__bits__m4; // inited later
u32 _const_math__bits__max_u32; // inited later
u64 _const_math__bits__max_u64; // inited later
int math__bits__leading_zeros_8(byte x);
int math__bits__leading_zeros_16(u16 x);
int math__bits__leading_zeros_32(u32 x);
int math__bits__leading_zeros_64(u64 x);
int math__bits__trailing_zeros_8(byte x);
int math__bits__trailing_zeros_16(u16 x);
int math__bits__trailing_zeros_32(u32 x);
int math__bits__trailing_zeros_64(u64 x);
int math__bits__ones_count_8(byte x);
int math__bits__ones_count_16(u16 x);
int math__bits__ones_count_32(u32 x);
int math__bits__ones_count_64(u64 x);
byte math__bits__rotate_left_8(byte x, int k);
u16 math__bits__rotate_left_16(u16 x, int k);
u32 math__bits__rotate_left_32(u32 x, int k);
u64 math__bits__rotate_left_64(u64 x, int k);
byte math__bits__reverse_8(byte x);
u16 math__bits__reverse_16(u16 x);
u32 math__bits__reverse_32(u32 x);
u64 math__bits__reverse_64(u64 x);
u16 math__bits__reverse_bytes_16(u16 x);
u32 math__bits__reverse_bytes_32(u32 x);
u64 math__bits__reverse_bytes_64(u64 x);
int math__bits__len_8(byte x);
int math__bits__len_16(u16 x);
int math__bits__len_32(u32 x);
int math__bits__len_64(u64 x);
multi_return_u32_u32 math__bits__add_32(u32 x, u32 y, u32 carry);
multi_return_u64_u64 math__bits__add_64(u64 x, u64 y, u64 carry);
multi_return_u32_u32 math__bits__sub_32(u32 x, u32 y, u32 borrow);
multi_return_u64_u64 math__bits__sub_64(u64 x, u64 y, u64 borrow);
u64 _const_math__bits__two32; // inited later
u64 _const_math__bits__mask32; // inited later
string _const_math__bits__overflow_error; // a string literal, inited later
string _const_math__bits__divide_error; // a string literal, inited later
multi_return_u32_u32 math__bits__mul_32(u32 x, u32 y);
multi_return_u64_u64 math__bits__mul_64(u64 x, u64 y);
multi_return_u32_u32 math__bits__div_32(u32 hi, u32 lo, u32 y);
multi_return_u64_u64 math__bits__div_64(u64 hi, u64 lo, u64 y1);
u32 math__bits__rem_32(u32 hi, u32 lo, u32 y);
u64 math__bits__rem_64(u64 hi, u64 lo, u64 y);
array_byte _const_math__bits__ntz_8_tab; // inited later
array_byte _const_math__bits__pop_8_tab; // inited later
array_byte _const_math__bits__rev_8_tab; // inited later
array_byte _const_math__bits__len_8_tab; // inited later
VV_LOCAL_SYMBOL multi_return_u32_u32_u32 strconv__lsr96(u32 s2, u32 s1, u32 s0);
VV_LOCAL_SYMBOL multi_return_u32_u32_u32 strconv__lsl96(u32 s2, u32 s1, u32 s0);
VV_LOCAL_SYMBOL multi_return_u32_u32_u32 strconv__add96(u32 s2, u32 s1, u32 s0, u32 d2, u32 d1, u32 d0);
VV_LOCAL_SYMBOL multi_return_u32_u32_u32 strconv__sub96(u32 s2, u32 s1, u32 s0, u32 d2, u32 d1, u32 d0);
#define _const_strconv__digits 18
u64 _const_strconv__double_plus_zero; // inited later
u64 _const_strconv__double_minus_zero; // inited later
u64 _const_strconv__double_plus_infinity; // inited later
u64 _const_strconv__double_minus_infinity; // inited later
#define _const_strconv__fsm_a 0
#define _const_strconv__fsm_b 1
#define _const_strconv__fsm_c 2
#define _const_strconv__fsm_d 3
#define _const_strconv__fsm_e 4
#define _const_strconv__fsm_f 5
#define _const_strconv__fsm_g 6
#define _const_strconv__fsm_h 7
#define _const_strconv__fsm_i 8
#define _const_strconv__fsm_stop 9
#define _const_strconv__parser_ok 0
#define _const_strconv__parser_pzero 1
#define _const_strconv__parser_mzero 2
#define _const_strconv__parser_pinf 3
#define _const_strconv__parser_minf 4
#define _const_strconv__c_dpoint '.'
#define _const_strconv__c_plus '+'
#define _const_strconv__c_minus '-'
#define _const_strconv__c_zero '0'
#define _const_strconv__c_nine '9'
u32 _const_strconv__c_ten; // inited later
VV_LOCAL_SYMBOL bool strconv__is_digit(byte x);
VV_LOCAL_SYMBOL bool strconv__is_space(byte x);
VV_LOCAL_SYMBOL bool strconv__is_exp(byte x);
VV_LOCAL_SYMBOL multi_return_int_strconv__PrepNumber strconv__parser(string s);
VV_LOCAL_SYMBOL u64 strconv__converter(strconv__PrepNumber* pn);
f64 strconv__atof64(string s);
f64 strconv__atof_quick(string s);
array_u64 _const_strconv__pos_exp; // inited later
array_u64 _const_strconv__neg_exp; // inited later
#define _const_strconv__int_size 32
u64 _const_strconv__max_u64; // inited later
byte strconv__byte_to_lower(byte c);
u64 strconv__common_parse_uint(string s, int _base, int _bit_size, bool error_on_non_digit, bool error_on_high_digit);
multi_return_u64_int strconv__common_parse_uint2(string s, int _base, int _bit_size);
u64 strconv__parse_uint(string s, int _base, int _bit_size);
i64 strconv__common_parse_int(string _s, int base, int _bit_size, bool error_on_non_digit, bool error_on_high_digit);
i64 strconv__parse_int(string _s, int base, int _bit_size);
int strconv__atoi(string s);
VV_LOCAL_SYMBOL bool strconv__underscore_ok(string s);
array_u32 _const_strconv__ten_pow_table_32; // inited later
u32 _const_strconv__mantbits32; // inited later
u32 _const_strconv__expbits32; // inited later
#define _const_strconv__bias32 127
#define _const_strconv__maxexp32 255
string strconv__Dec32_get_string_32(strconv__Dec32 d, bool neg, int i_n_digit, int i_pad_digit);
VV_LOCAL_SYMBOL multi_return_strconv__Dec32_bool strconv__f32_to_decimal_exact_int(u32 i_mant, u32 exp);
strconv__Dec32 strconv__f32_to_decimal(u32 mant, u32 exp);
string strconv__f32_to_str(f32 f, int n_digit);
string strconv__f32_to_str_pad(f32 f, int n_digit);
array_u64 _const_strconv__ten_pow_table_64; // inited later
u32 _const_strconv__mantbits64; // inited later
u32 _const_strconv__expbits64; // inited later
#define _const_strconv__bias64 1023
#define _const_strconv__maxexp64 2047
VV_LOCAL_SYMBOL string strconv__Dec64_get_string_64(strconv__Dec64 d, bool neg, int i_n_digit, int i_pad_digit);
VV_LOCAL_SYMBOL multi_return_strconv__Dec64_bool strconv__f64_to_decimal_exact_int(u64 i_mant, u64 exp);
VV_LOCAL_SYMBOL strconv__Dec64 strconv__f64_to_decimal(u64 mant, u64 exp);
string strconv__f64_to_str(f64 f, int n_digit);
string strconv__f64_to_str_pad(f64 f, int n_digit);
array_f64 _const_strconv__dec_round; // inited later
string strconv__f64_to_str_lnd(f64 f, int dec_digit);
string strconv__format_str(string s, strconv__BF_param p);
string strconv__format_dec(u64 d, strconv__BF_param p);
string strconv__format_fl(f64 f, strconv__BF_param p);
string strconv__format_es(f64 f, strconv__BF_param p);
string strconv__remove_tail_zeros(string s);
void strconv__v_printf(string str, varg_voidptr pt);
string strconv__v_sprintf(string str, varg_voidptr pt);
VV_LOCAL_SYMBOL void strconv__v_sprintf_panic(int idx, int len);
VV_LOCAL_SYMBOL f64 strconv__fabs(f64 x);
string strconv__ftoa_64(f64 f);
string strconv__ftoa_long_64(f64 f);
string strconv__ftoa_32(f32 f);
string strconv__ftoa_long_32(f32 f);
#define _const_strconv__pow5_num_bits_32 61
#define _const_strconv__pow5_inv_num_bits_32 59
#define _const_strconv__pow5_num_bits_64 121
#define _const_strconv__pow5_inv_num_bits_64 122
array_u64 _const_strconv__powers_of_10; // inited later
array_u64 _const_strconv__pow5_split_32; // inited later
array_u64 _const_strconv__pow5_inv_split_32; // inited later
array_strconv__Uint128 _const_strconv__pow5_split_64; // inited later
array_strconv__Uint128 _const_strconv__pow5_inv_split_64; // inited later
VV_LOCAL_SYMBOL void strconv__assert1(bool t, string msg);
VV_LOCAL_SYMBOL int strconv__bool_to_int(bool b);
VV_LOCAL_SYMBOL u32 strconv__bool_to_u32(bool b);
VV_LOCAL_SYMBOL u64 strconv__bool_to_u64(bool b);
VV_LOCAL_SYMBOL string strconv__get_string_special(bool neg, bool expZero, bool mantZero);
VV_LOCAL_SYMBOL int strconv__decimal_len_32(u32 u);
VV_LOCAL_SYMBOL u32 strconv__mul_shift_32(u32 m, u64 mul, int ishift);
VV_LOCAL_SYMBOL u32 strconv__mul_pow5_invdiv_pow2(u32 m, u32 q, int j);
VV_LOCAL_SYMBOL u32 strconv__mul_pow5_div_pow2(u32 m, u32 i, int j);
VV_LOCAL_SYMBOL u32 strconv__pow5_factor_32(u32 i_v);
VV_LOCAL_SYMBOL bool strconv__multiple_of_power_of_five_32(u32 v, u32 p);
VV_LOCAL_SYMBOL bool strconv__multiple_of_power_of_two_32(u32 v, u32 p);
VV_LOCAL_SYMBOL u32 strconv__log10_pow2(int e);
VV_LOCAL_SYMBOL u32 strconv__log10_pow5(int e);
VV_LOCAL_SYMBOL int strconv__pow5_bits(int e);
VV_LOCAL_SYMBOL int strconv__decimal_len_64(u64 u);
VV_LOCAL_SYMBOL u64 strconv__shift_right_128(strconv__Uint128 v, int shift);
VV_LOCAL_SYMBOL u64 strconv__mul_shift_64(u64 m, strconv__Uint128 mul, int shift);
VV_LOCAL_SYMBOL u32 strconv__pow5_factor_64(u64 v_i);
VV_LOCAL_SYMBOL bool strconv__multiple_of_power_of_five_64(u64 v, u32 p);
VV_LOCAL_SYMBOL bool strconv__multiple_of_power_of_two_64(u64 v, u32 p);
string strconv__f32_to_str_l(f64 f);
string strconv__f64_to_str_l(f64 f);
VV_LOCAL_SYMBOL array __new_array(int mylen, int cap, int elm_size);
VV_LOCAL_SYMBOL array __new_array_with_default(int mylen, int cap, int elm_size, voidptr val);
VV_LOCAL_SYMBOL array __new_array_with_array_default(int mylen, int cap, int elm_size, array val);
VV_LOCAL_SYMBOL array new_array_from_c_array(int len, int cap, int elm_size, voidptr c_array);
VV_LOCAL_SYMBOL array new_array_from_c_array_no_alloc(int len, int cap, int elm_size, voidptr c_array);
VV_LOCAL_SYMBOL void array_ensure_cap(array* a, int required);
array array_repeat(array a, int count);
void array_sort_with_compare(array* a, voidptr compare);
void array_insert(array* a, int i, voidptr val);
void array_insert_many(array* a, int i, voidptr val, int size);
void array_prepend(array* a, voidptr val);
void array_prepend_many(array* a, voidptr val, int size);
void array_delete(array* a, int i);
void array_clear(array* a);
void array_trim(array* a, int index);
VV_LOCAL_SYMBOL voidptr array_get_unsafe(array a, int i);
VV_LOCAL_SYMBOL voidptr array_get(array a, int i);
voidptr array_first(array a);
voidptr array_last(array a);
voidptr array_pop(array* a);
void array_delete_last(array* a);
VV_LOCAL_SYMBOL array array_slice(array a, int start, int _end);
VV_LOCAL_SYMBOL array array_slice2(array a, int start, int _end, bool end_max);
VV_LOCAL_SYMBOL array array_clone_static(array a);
array array_clone(array* a);
VV_LOCAL_SYMBOL array array_slice_clone(array* a, int start, int _end);
VV_LOCAL_SYMBOL void array_set_unsafe(array* a, int i, voidptr val);
VV_LOCAL_SYMBOL void array_set(array* a, int i, voidptr val);
VV_LOCAL_SYMBOL void array_push(array* a, voidptr val);
void array_push_many(array* a3, voidptr val, int size);
void array_reverse_in_place(array* a);
array array_reverse(array a);
void array_free(array* a);
string array_string_str(array_string a);
string array_byte_hex(array_byte b);
int copy(array_byte dst, array_byte src);
VV_LOCAL_SYMBOL int compare_ints(int* a, int* b);
VV_LOCAL_SYMBOL int compare_ints_reverse(int* a, int* b);
VV_LOCAL_SYMBOL int compare_floats(f64* a, f64* b);
VV_LOCAL_SYMBOL int compare_floats_reverse(f64* a, f64* b);
void array_int_sort(array_int* a);
int array_string_index(array_string a, string v);
int array_int_index(array_int a, int v);
int array_byte_index(array_byte a, byte v);
int array_rune_index(array_rune a, rune v);
int array_char_index(array_char a, char v);
int array_int_reduce(array_int a, int (*iter)(int , int ), int accum_start);
void array_grow(array* a, int amount);
bool array_string_eq(array_string a1, array_string a2);
int compare_i64(i64* a, i64* b);
int compare_f64(f64* a, f64* b);
int compare_f32(f32* a, f32* b);
array_voidptr array_pointers(array a);
array_byte voidptr_vbytes(voidptr data, int len);
array_byte byteptr_vbytes(byteptr data, int len);
byteptr g_m2_buf; // global
byteptr g_m2_ptr; // global
void v_exit(int code);
bool isnil(voidptr v);
void print_backtrace();
VV_LOCAL_SYMBOL void panic_debug(int line_no, string file, string mod, string fn_name, string s);
void v_panic(string s);
void eprintln(string s);
void eprint(string s);
void print(string s);
string _const_new_line_character; // a string literal, inited later
void println(string s);
i64 total_m = 0; // global
int nr_mallocs = 0; // global
byteptr v_malloc(int n);
byteptr v_realloc(byteptr b, u32 n);
byteptr v_calloc(int n);
byteptr vcalloc(int n);
void v_free(voidptr ptr);
voidptr memdup(voidptr src, int sz);
VV_LOCAL_SYMBOL void v_ptr_free(voidptr ptr);
int is_atty(int fd);
VV_LOCAL_SYMBOL voidptr __as_cast(voidptr obj, int obj_type, int expected_type);
VV_LOCAL_SYMBOL void __print_assert_failure(VAssertMetaInfo* i);
#define _const_symopt_undname 0x00000002
#define _const_symopt_deferred_loads 0x00000004
#define _const_symopt_no_cpp 0x00000008
#define _const_symopt_load_lines 0x00000010
#define _const_symopt_include_32bit_modules 0x00002000
#define _const_symopt_allow_zero_address 0x01000000
#define _const_symopt_debug 0x80000000
u32 g_original_codepage = 0; // global
VV_LOCAL_SYMBOL void restore_codepage();
VV_LOCAL_SYMBOL void builtin_init();
VV_LOCAL_SYMBOL bool print_backtrace_skipping_top_frames(int skipframes);
VV_LOCAL_SYMBOL bool print_backtrace_skipping_top_frames_msvc(int skipframes);
VV_LOCAL_SYMBOL bool print_backtrace_skipping_top_frames_mingw(int skipframes);
VV_LOCAL_SYMBOL bool print_backtrace_skipping_top_frames_tcc(int skipframes);
VV_LOCAL_SYMBOL void add_vectored_exception_handler(VectoredExceptionHandler handler);
VV_LOCAL_SYMBOL int __stdcall  unhandled_exception_handler(ExceptionPointers* e);
VV_LOCAL_SYMBOL void add_unhandled_exception_handler();
VV_LOCAL_SYMBOL void break_if_debugger_attached();
int proc_pidpath(int , voidptr , int );
void chan_close(chan ch);
ChanState chan_try_pop(chan ch, voidptr obj);
ChanState chan_try_push(chan ch, voidptr obj);
string f64_str(f64 x);
string any_float_str(any_float d);
string f64_strsci(f64 x, int digit_num);
string f64_strlong(f64 x);
string f32_str(f32 x);
string f32_strsci(f32 x, int digit_num);
string f32_strlong(f32 x);
f32 f32_abs(f32 a);
VV_LOCAL_SYMBOL f64 f64_abs(f64 a);
f32 f32_max(f32 a, f32 b);
f32 f32_min(f32 a, f32 b);
f64 f64_max(f64 a, f64 b);
VV_LOCAL_SYMBOL f64 f64_min(f64 a, f64 b);
bool f32_eq_epsilon(f32 a, f32 b);
bool f64_eq_epsilon(f64 a, f64 b);
string ptr_str(voidptr ptr);
string _const_digit_pairs; // a string literal, inited later
string int_str_l(int nn, int max);
string i8_str(i8 n);
string i16_str(i16 n);
string u16_str(u16 n);
string int_str(int n);
string u32_str(u32 nn);
string any_int_str(any_int n);
string i64_str(i64 nn);
string u64_str(u64 nn);
string bool_str(bool b);
VV_LOCAL_SYMBOL string u64_to_hex(u64 nn, byte len);
VV_LOCAL_SYMBOL string u64_to_hex_no_leading_zeros(u64 nn, byte len);
string byte_hex(byte nn);
string i8_hex(i8 nn);
string u16_hex(u16 nn);
string i16_hex(i16 nn);
string u32_hex(u32 nn);
string int_hex(int nn);
string int_hex2(int n);
string u64_hex(u64 nn);
string i64_hex(i64 nn);
string any_int_hex(any_int nn);
string voidptr_str(voidptr nn);
string byteptr_str(byteptr nn);
string u64_hex_full(u64 nn);
string byte_str(byte b);
string byte_str_escaped(byte b);
bool array_byte_contains(array_byte a, byte val);
bool array_u16_contains(array_u16 a, u16 val);
VV_LOCAL_SYMBOL bool array_int_contains(array_int ar, int val);
bool array_u64_contains(array_u64 a, u64 val);
#define _const_hashbits 24
#define _const_max_cached_hashbits 16
#define _const_init_log_capicity 5
int _const_init_capicity; // inited later
#define _const_max_load_factor 0.8
int _const_init_cap; // inited later
#define _const_extra_metas_inc 4
u32 _const_hash_mask; // inited later
u32 _const_probe_inc; // inited later
VV_LOCAL_SYMBOL bool fast_string_eq(string a, string b);
VV_LOCAL_SYMBOL DenseArray new_dense_array(int value_bytes);
VV_LOCAL_SYMBOL u32 DenseArray_push(DenseArray* d, string key, voidptr value);
VV_LOCAL_SYMBOL voidptr DenseArray_get(DenseArray d, int i);
VV_LOCAL_SYMBOL void DenseArray_zeros_to_end(DenseArray* d);
VV_LOCAL_SYMBOL map new_map_1(int value_bytes);
VV_LOCAL_SYMBOL map new_map_init(int n, int value_bytes, string* keys, voidptr values);
VV_LOCAL_SYMBOL multi_return_u32_u32 map_key_to_index(map* m, string key);
VV_LOCAL_SYMBOL multi_return_u32_u32 map_meta_less(map* m, u32 _index, u32 _metas);
VV_LOCAL_SYMBOL void map_meta_greater(map* m, u32 _index, u32 _metas, u32 kvi);
VV_LOCAL_SYMBOL void map_ensure_extra_metas(map* m, u32 probe_count);
VV_LOCAL_SYMBOL void map_set(map* m, string k, voidptr value);
VV_LOCAL_SYMBOL void map_expand(map* m);
VV_LOCAL_SYMBOL void map_rehash(map* m);
VV_LOCAL_SYMBOL void map_cached_rehash(map* m, u32 old_cap);
VV_LOCAL_SYMBOL voidptr map_get_and_set(map* m, string key, voidptr zero);
VV_LOCAL_SYMBOL voidptr map_get(map m, string key, voidptr zero);
VV_LOCAL_SYMBOL bool map_exists(map m, string key);
void map_delete(map* m, string key);
array_string map_keys(map* m);
DenseArray DenseArray_clone(DenseArray d);
map map_clone(map m);
void map_free(map* m);
string OptionBase_str(OptionBase o);
VV_LOCAL_SYMBOL void opt_ok2(voidptr data, OptionBase* option, int size);
string Option_str(Option o);
VV_LOCAL_SYMBOL Option opt_none();
Option v_error(string s);
Option error_with_code(string s, int code);
string rune_str(rune c);
bool byte_is_capital(byte c);
array_byte array_byte_clone(array_byte b);
string array_byte_bytestr(array_byte b);
VV_LOCAL_SYMBOL string bytes2string(array_byte b);
#define _const_degree 6
int _const_mid_index; // inited later
int _const_max_len; // inited later
u32 _const_children_bytes; // inited later
VV_LOCAL_SYMBOL SortedMap new_sorted_map(int n, int value_bytes);
VV_LOCAL_SYMBOL SortedMap new_sorted_map_init(int n, int value_bytes, string* keys, voidptr values);
VV_LOCAL_SYMBOL mapnode* new_node();
VV_LOCAL_SYMBOL void SortedMap_set(SortedMap* m, string key, voidptr value);
VV_LOCAL_SYMBOL void mapnode_split_child(mapnode* n, int child_index, mapnode* y);
VV_LOCAL_SYMBOL bool SortedMap_get(SortedMap m, string key, voidptr out);
VV_LOCAL_SYMBOL bool SortedMap_exists(SortedMap m, string key);
VV_LOCAL_SYMBOL int mapnode_find_key(mapnode* n, string k);
VV_LOCAL_SYMBOL bool mapnode_remove_key(mapnode* n, string k);
VV_LOCAL_SYMBOL void mapnode_remove_from_leaf(mapnode* n, int idx);
VV_LOCAL_SYMBOL void mapnode_remove_from_non_leaf(mapnode* n, int idx);
VV_LOCAL_SYMBOL void mapnode_fill(mapnode* n, int idx);
VV_LOCAL_SYMBOL void mapnode_borrow_from_prev(mapnode* n, int idx);
VV_LOCAL_SYMBOL void mapnode_borrow_from_next(mapnode* n, int idx);
VV_LOCAL_SYMBOL void mapnode_merge(mapnode* n, int idx);
void SortedMap_delete(SortedMap* m, string key);
VV_LOCAL_SYMBOL int mapnode_subkeys(mapnode* n, array_string* keys, int at);
array_string SortedMap_keys(SortedMap* m);
VV_LOCAL_SYMBOL void mapnode_free(mapnode* n);
void SortedMap_free(SortedMap* m);
void SortedMap_print(SortedMap m);
int vstrlen(byteptr s);
string tos(byteptr s, int len);
string tos_clone(byteptr s);
string tos2(byteptr s);
string tos3(charptr s);
string tos_lit(charptr s);
string byteptr_vstring(byteptr bp);
string byteptr_vstring_with_len(byteptr bp, int len);
string charptr_vstring(charptr cp);
string charptr_vstring_with_len(charptr cp, int len);
VV_LOCAL_SYMBOL string string_clone_static(string a);
string string_clone(string a);
string cstring_to_vstring(byteptr cstr);
string string_replace_once(string s, string rep, string with);
string string_replace(string s, string rep, string with);
VV_LOCAL_SYMBOL int compare_rep_index(RepIndex* a, RepIndex* b);
VV_LOCAL_SYMBOL void array_RepIndex_sort2(array_RepIndex* a);
string string_replace_each(string s, array_string vals);
bool string_bool(string s);
int string_int(string s);
i64 string_i64(string s);
i8 string_i8(string s);
i16 string_i16(string s);
f32 string_f32(string s);
f64 string_f64(string s);
u16 string_u16(string s);
u32 string_u32(string s);
u64 string_u64(string s);
VV_LOCAL_SYMBOL bool string_eq(string s, string a);
VV_LOCAL_SYMBOL bool string_ne(string s, string a);
VV_LOCAL_SYMBOL bool string_lt(string s, string a);
VV_LOCAL_SYMBOL bool string_le(string s, string a);
VV_LOCAL_SYMBOL bool string_gt(string s, string a);
VV_LOCAL_SYMBOL bool string_ge(string s, string a);
VV_LOCAL_SYMBOL string string_add(string s, string a);
array_string string_split(string s, string delim);
array_string string_split_nth(string s, string delim, int nth);
array_string string_split_into_lines(string s);
VV_LOCAL_SYMBOL string string_left(string s, int n);
VV_LOCAL_SYMBOL string string_right(string s, int n);
VV_LOCAL_SYMBOL string string_substr2(string s, int start, int _end, bool end_max);
string string_substr(string s, int start, int end);
int string_index_old(string s, string p);
Option_int string_index(string s, string p);
VV_LOCAL_SYMBOL int string_index_kmp(string s, string p);
int string_index_any(string s, string chars);
Option_int string_last_index(string s, string p);
int string_index_after(string s, string p, int start);
int string_index_byte(string s, byte c);
int string_last_index_byte(string s, byte c);
int string_count(string s, string substr);
bool string_contains(string s, string substr);
bool string_contains_any(string s, string chars);
bool string_contains_any_substr(string s, array_string substrs);
bool string_starts_with(string s, string p);
bool string_ends_with(string s, string p);
string string_to_lower(string s);
bool string_is_lower(string s);
string string_to_upper(string s);
bool string_is_upper(string s);
string string_capitalize(string s);
bool string_is_capital(string s);
string string_title(string s);
bool string_is_title(string s);
string string_find_between(string s, string start, string end);
VV_LOCAL_SYMBOL bool array_string_contains(array_string ar, string val);
bool byte_is_space(byte c);
string string_trim_space(string s);
string string_trim(string s, string cutset);
string string_trim_left(string s, string cutset);
string string_trim_right(string s, string cutset);
string string_trim_prefix(string s, string str);
string string_trim_suffix(string s, string str);
int compare_strings(string* a, string* b);
VV_LOCAL_SYMBOL int compare_strings_reverse(string* a, string* b);
VV_LOCAL_SYMBOL int compare_strings_by_len(string* a, string* b);
VV_LOCAL_SYMBOL int compare_lower_strings(string* a, string* b);
void array_string_sort(array_string* s);
void array_string_sort_ignore_case(array_string* s);
void array_string_sort_by_len(array_string* s);
string string_str(string s);
string ustring_str(ustring s);
ustring string_ustring(string s);
array_int g_ustring_runes; // global
ustring string_ustring_tmp(string s);
VV_LOCAL_SYMBOL bool ustring_eq(ustring u, ustring a);
VV_LOCAL_SYMBOL bool ustring_ne(ustring u, ustring a);
VV_LOCAL_SYMBOL bool ustring_lt(ustring u, ustring a);
VV_LOCAL_SYMBOL bool ustring_le(ustring u, ustring a);
VV_LOCAL_SYMBOL bool ustring_gt(ustring u, ustring a);
VV_LOCAL_SYMBOL bool ustring_ge(ustring u, ustring a);
ustring ustring_add(ustring u, ustring a);
int ustring_index_after(ustring u, ustring p, int start);
int ustring_count(ustring u, ustring substr);
string ustring_substr(ustring u, int _start, int _end);
string ustring_left(ustring u, int pos);
string ustring_right(ustring u, int pos);
VV_LOCAL_SYMBOL byte string_at(string s, int idx);
string ustring_at(ustring u, int idx);
VV_LOCAL_SYMBOL void ustring_free(ustring* u);
bool byte_is_digit(byte c);
bool byte_is_hex_digit(byte c);
bool byte_is_oct_digit(byte c);
bool byte_is_bin_digit(byte c);
bool byte_is_letter(byte c);
void string_free(string* s);
string string_all_before(string s, string dot);
string string_all_before_last(string s, string dot);
string string_all_after(string s, string dot);
string string_all_after_last(string s, string dot);
string string_after(string s, string dot);
string string_after_char(string s, byte dot);
string array_string_join(array_string a, string del);
string array_string_join_lines(array_string s);
string string_reverse(string s);
string string_limit(string s, int max);
bool byte_is_white(byte c);
int string_hash(string s);
array_byte string_bytes(string s);
string string_repeat(string s, int count);
array_string string_fields(string s);
string string_strip_margin(string s);
string string_strip_margin_custom(string s, byte del);
int utf8_char_len(byte b);
string utf32_to_str(u32 code);
string utf32_to_str_no_malloc(u32 code, voidptr buf);
int string_utf32_code(string _rune);
#define _const_cp_utf8 65001
u16* string_to_wide(string _str);
string string_from_wide(u16* _wstr);
string string_from_wide2(u16* _wstr, int len);
VV_LOCAL_SYMBOL int utf8_len(byte c);
VV_LOCAL_SYMBOL int utf8_str_len(string s);
VV_LOCAL_SYMBOL int utf8_str_visible_length(string s);
int utf8_getchar();
#define _const_os__s_ifmt 0xF000
#define _const_os__s_ifdir 0x4000
#define _const_os__s_iflnk 0xa000
#define _const_os__s_ixusr 0100
#define _const_os__s_ixgrp 0010
#define _const_os__s_ixoth 0001
int _const_os__std_input_handle; // inited later
int _const_os__std_output_handle; // inited later
int _const_os__std_error_handle; // inited later
#define _const_os__success 0x0000
#define _const_os__error_insufficient_buffer 0x0082
#define _const_os__handle_generic_read 0x80000000
#define _const_os__handle_open_existing 0x00000003
#define _const_os__file_share_read 0x01
#define _const_os__file_share_write 0x02
#define _const_os__file_share_delete 0x04
#define _const_os__file_notify_change_file_name 0x01
#define _const_os__file_notify_change_dir_name 0x02
#define _const_os__file_notify_change_attributes 0x04
#define _const_os__file_notify_change_size 0x08
#define _const_os__file_notify_change_last_write 0x10
#define _const_os__file_notify_change_last_access 0x20
#define _const_os__file_notify_change_creation 0x40
#define _const_os__file_notify_change_security 0x80
#define _const_os__file_action_added 0x01
#define _const_os__file_action_removed 0x02
#define _const_os__file_action_modified 0x03
#define _const_os__file_action_renamed_old_name 0x04
#define _const_os__file_action_renamed_new_name 0x05
#define _const_os__file_attr_readonly 0x00000001
#define _const_os__file_attr_hidden 0x00000002
#define _const_os__file_attr_system 0x00000004
#define _const_os__file_attr_directory 0x00000010
#define _const_os__file_attr_archive 0x00000020
#define _const_os__file_attr_device 0x00000040
#define _const_os__file_attr_normal 0x00000080
#define _const_os__file_attr_temporary 0x00000100
#define _const_os__file_attr_sparse_file 0x00000200
#define _const_os__file_attr_reparse_point 0x00000400
#define _const_os__file_attr_compressed 0x00000800
#define _const_os__file_attr_offline 0x00001000
#define _const_os__file_attr_not_content_indexed 0x00002000
#define _const_os__file_attr_encrypted 0x00004000
#define _const_os__file_attr_integrity_stream 0x00008000
#define _const_os__file_attr_virtual 0x00010000
#define _const_os__file_attr_no_scrub_data 0x00020000
#define _const_os__file_type_unknown 0x00
#define _const_os__file_type_disk 0x01
#define _const_os__file_type_char 0x02
#define _const_os__file_type_pipe 0x03
int _const_os__file_invalid_file_id; // inited later
voidptr _const_os__invalid_handle_value; // inited later
#define _const_os__enable_echo_input 0x0004
#define _const_os__enable_extended_flags 0x0080
#define _const_os__enable_insert_mode 0x0020
#define _const_os__enable_line_input 0x0002
#define _const_os__enable_mouse_input 0x0010
#define _const_os__enable_processed_input 0x0001
#define _const_os__enable_quick_edit_mode 0x0040
#define _const_os__enable_window_input 0x0008
#define _const_os__enable_virtual_terminal_input 0x0200
#define _const_os__enable_processed_output 0x01
#define _const_os__enable_wrap_at_eol_output 0x02
#define _const_os__enable_virtual_terminal_processing 0x04
#define _const_os__disable_newline_auto_return 0x08
#define _const_os__enable_lvb_grid_worldwide 0x10
#define _const_os__o_rdonly 0x0000
#define _const_os__o_wronly 0x0001
#define _const_os__o_rdwr 0x0002
#define _const_os__o_append 0x0008
#define _const_os__o_create 0x0100
#define _const_os__o_binary 0x8000
#define _const_os__o_trunc 0x0200
#define _const_os__o_excl 0x0400
#define _const_os__o_sync 0x0000
#define _const_os__o_noctty 0x0000
#define _const_os__o_nonblock 0x0000
#define _const_os__status_access_violation 0xC0000005
#define _const_os__status_in_page_error 0xC0000006
#define _const_os__status_invalid_handle 0xC0000008
#define _const_os__status_invalid_parameter 0xC000000D
#define _const_os__status_no_memory 0xC0000017
#define _const_os__status_illegal_instruction 0xC000001D
#define _const_os__status_noncontinuable_exception 0xC0000025
#define _const_os__status_invalid_disposition 0xC0000026
#define _const_os__status_array_bounds_exceeded 0xC000008C
#define _const_os__status_float_denormal_operand 0xC000008D
#define _const_os__status_float_divide_by_zero 0xC000008E
#define _const_os__status_float_inexact_result 0xC000008F
#define _const_os__status_float_invalid_operation 0xC0000090
#define _const_os__status_float_overflow 0xC0000091
#define _const_os__status_float_stack_check 0xC0000092
#define _const_os__status_float_underflow 0xC0000093
#define _const_os__status_integer_divide_by_zero 0xC0000094
#define _const_os__status_integer_overflow 0xC0000095
#define _const_os__status_privileged_instruction 0xC0000096
#define _const_os__status_stack_overflow 0xC00000FD
#define _const_os__status_dll_not_found 0xC0000135
#define _const_os__status_ordinal_not_found 0xC0000138
#define _const_os__status_entrypoint_not_found 0xC0000139
#define _const_os__status_control_c_exit 0xC000013A
#define _const_os__status_dll_init_failed 0xC0000142
#define _const_os__status_float_multiple_faults 0xC00002B4
#define _const_os__status_float_multiple_traps 0xC00002B5
#define _const_os__status_reg_nat_consumption 0xC00002C9
#define _const_os__status_heap_corruption 0xC0000374
#define _const_os__status_stack_buffer_overrun 0xC0000409
#define _const_os__status_invalid_cruntime_parameter 0xC0000417
#define _const_os__status_assertion_failure 0xC0000420
voidptr _const_os__hkey_local_machine; // inited later
voidptr _const_os__hkey_current_user; // inited later
#define _const_os__key_query_value 0x0001
#define _const_os__key_set_value 0x0002
#define _const_os__key_enumerate_sub_keys 0x0008
#define _const_os__key_wow64_32key 0x0200
voidptr _const_os__hwnd_broadcast; // inited later
#define _const_os__wm_settingchange 0x001A
#define _const_os__smto_abortifhung 0x0002
string os__getenv(string key);
int os__setenv(string name, string value, bool overwrite);
int os__unsetenv(string name);
map_string_string os__environ();
int os__fd_close(int fd);
void os__fd_write(int fd, string s);
array_string os__fd_slurp(int fd);
multi_return_string_int os__fd_read(int fd, int maxbytes);
bool os__File_is_opened(os__File f);
Option_int os__File_write(os__File* f, array_byte buf);
Option_int os__File_writeln(os__File* f, string s);
Option_int os__File_write_to(os__File* f, int pos, array_byte buf);
int os__File_write_bytes(os__File* f, voidptr data, int size);
int os__File_write_bytes_at(os__File* f, voidptr data, int size, int pos);
array_byte os__File_read_bytes(os__File* f, int size);
array_byte os__File_read_bytes_at(os__File* f, int size, int pos);
Option_int os__File_read_bytes_into(os__File* f, int pos, array_byte* buf);
Option_int os__File_read(os__File* f, array_byte* buf);
Option_int os__File_read_at(os__File* f, int pos, array_byte* buf);
void os__File_flush(os__File* f);
os__File os__open_stdin();
Option_string os__File_get_line(os__File* f);
Option_void os__File_write_str(os__File* f, string s);
os__FileMode os__inode(string path);
array_string _const_os__args; // inited later
#define _const_os__max_path_len 4096
Option_array_byte os__read_bytes(string path);
Option_string os__read_file(string path);
int os__file_size(string path);
void os__mv(string src, string dst);
Option_void os__cp(string src, string dst);
Option_void os__cp_r(string osource_path, string odest_path, bool overwrite);
Option_void os__cp_all(string src, string dst, bool overwrite);
Option_void os__mv_by_cp(string source, string target);
Option_FILE_ptr os__vfopen(string path, string mode);
int os__fileno(voidptr cfile);
Option_array_string os__read_lines(string path);
VV_LOCAL_SYMBOL Option_array_ustring os__read_ulines(string path);
Option_os__File os__open_append(string path);
Option_os__File os__open_file(string path, string mode, varg_int options);
VV_LOCAL_SYMBOL voidptr os__vpopen(string path);
VV_LOCAL_SYMBOL multi_return_int_bool os__posix_wait4_to_exit_status(int waitret);
string os__posix_get_error_msg(int code);
VV_LOCAL_SYMBOL int os__vpclose(voidptr f);
int os__system(string cmd);
string os__sigint_to_signal_name(int si);
#define _const_os__f_ok 0
#define _const_os__x_ok 1
#define _const_os__w_ok 2
#define _const_os__r_ok 4
bool os__exists(string path);
bool os__is_executable(string path);
bool os__is_writable(string path);
bool os__is_readable(string path);
bool os__file_exists(string _path);
Option_void os__rm(string path);
Option_void os__rmdir(string path);
void os__rmdir_recursive(string path);
Option_void os__rmdir_all(string path);
bool os__is_dir_empty(string path);
VV_LOCAL_SYMBOL void os__print_c_errno();
string os__file_ext(string path);
string os__dir(string path);
string os__base(string path);
string os__file_name(string path);
string os__input(string prompt);
string os__get_line();
string os__get_raw_line();
array_byte os__get_raw_stdin();
array_string os__get_lines();
string os__get_lines_joined();
string os__user_os();
string os__home_dir();
Option_void os__write_file(string path, string text);
Option_void os__write_file_array(string path, array buffer);
void os__on_segfault(voidptr f);
string os__executable();
VV_LOCAL_SYMBOL string os__executable_fallback();
Option_string os__find_abs_path_of_executable(string exepath);
bool os__exists_in_system_path(string prog);
bool os__dir_exists(string path);
bool os__is_dir(string path);
bool os__is_file(string path);
bool os__is_link(string path);
void os__chdir(string path);
string os__getwd();
string os__real_path(string fpath);
VV_LOCAL_SYMBOL string os__normalize_drive_letter(string path);
bool os__is_abs_path(string path);
string os__join_path(string base, varg_string dirs);
array_string os__walk_ext(string path, string ext);
void os__walk(string path, void (*f)(string path));
void os__signal(int signum, voidptr handler);
int os__fork();
int os__wait();
int os__file_last_mod_unix(string path);
void os__log(string s);
void os__flush_stdout();
void os__flush();
Option_void os__mkdir_all(string path);
string os__cache_dir();
string os__temp_dir();
string os__vmodules_dir();
void os__chmod(string path, int mode);
string _const_os__wd_at_startup; // inited later
string os__resource_abs_path(string path);
Option_os__File os__open(string path);
Option_os__File os__create(string path);
string _const_os__path_separator; // a string literal, inited later
string _const_os__path_delimiter; // a string literal, inited later
VV_LOCAL_SYMBOL array_string os__init_os_args_wide(int argc, byteptr* argv);
Option_array_string os__ls(string path);
Option_bool os__mkdir(string path);
os__HANDLE os__get_file_handle(string path);
Option_string os__get_module_filename(os__HANDLE handle);
#define _const_os__format_message_allocate_buffer 0x00000100
#define _const_os__format_message_argument_array 0x00002000
#define _const_os__format_message_from_hmodule 0x00000800
#define _const_os__format_message_from_string 0x00000400
#define _const_os__format_message_from_system 0x00001000
#define _const_os__format_message_ignore_inserts 0x00000200
#define _const_os__sublang_neutral 0x00
#define _const_os__sublang_default 0x01
int _const_os__lang_neutral; // inited later
#define _const_os__max_error_code 15841
VV_LOCAL_SYMBOL voidptr os__ptr_win_get_error_msg(u32 code);
string os__get_error_msg(int code);
Option_os__Result os__exec(string cmd);
Option_bool os__symlink(string symlink_path, string target_path);
void os__File_close(os__File* f);
void os__add_vectored_exception_handler(bool first, VectoredExceptionHandler handler);
bool os__debugger_present();
os__Uname os__uname();
Option_bool os__is_writable_folder(string folder);
int os__getpid();
os__Process* os__new_process(string filename);
os__Process* os__Process_set_args(os__Process* p, array_string pargs);
os__Process* os__Process_set_environment(os__Process* p, map_string_string envs);
os__Process* os__Process_run(os__Process* p);
os__Process* os__Process_signal_kill(os__Process* p);
os__Process* os__Process_signal_stop(os__Process* p);
os__Process* os__Process_signal_continue(os__Process* p);
os__Process* os__Process_wait(os__Process* p);
VV_LOCAL_SYMBOL int os__Process__spawn(os__Process* p);
bool os__Process_is_alive(os__Process* p);
os__Process* os__Process_set_redirect_stdio(os__Process* p);
void os__Process_stdin_write(os__Process* p, string s);
string os__Process_stdout_slurp(os__Process* p);
string os__Process_stderr_slurp(os__Process* p);
string os__Process_stdout_read(os__Process* p);
string os__Process_stderr_read(os__Process* p);
VV_LOCAL_SYMBOL void os__Process__check_redirection_call(os__Process* p, string fn_name);
VV_LOCAL_SYMBOL void os__Process__signal_stop(os__Process* p);
VV_LOCAL_SYMBOL void os__Process__signal_continue(os__Process* p);
VV_LOCAL_SYMBOL void os__Process__signal_kill(os__Process* p);
VV_LOCAL_SYMBOL void os__Process__wait(os__Process* p);
VV_LOCAL_SYMBOL bool os__Process__is_alive(os__Process* p);
VV_LOCAL_SYMBOL int os__Process_win_spawn_process(os__Process* p);
VV_LOCAL_SYMBOL void os__Process_win_stop_process(os__Process* p);
VV_LOCAL_SYMBOL void os__Process_win_resume_process(os__Process* p);
VV_LOCAL_SYMBOL void os__Process_win_kill_process(os__Process* p);
VV_LOCAL_SYMBOL void os__Process_win_wait(os__Process* p);
VV_LOCAL_SYMBOL bool os__Process_win_is_alive(os__Process* p);
VV_LOCAL_SYMBOL int os__Process_unix_spawn_process(os__Process* p);
VV_LOCAL_SYMBOL void os__Process_unix_stop_process(os__Process* p);
VV_LOCAL_SYMBOL void os__Process_unix_resume_process(os__Process* p);
VV_LOCAL_SYMBOL void os__Process_unix_kill_process(os__Process* p);
VV_LOCAL_SYMBOL void os__Process_unix_wait(os__Process* p);
VV_LOCAL_SYMBOL bool os__Process_unix_is_alive(os__Process* p);
array_string os__cmdline__options(array_string args, string param);
string os__cmdline__option(array_string args, string param, string def);
array_string os__cmdline__options_before(array_string args, array_string what);
array_string os__cmdline__options_after(array_string args, array_string what);
array_string os__cmdline__only_non_options(array_string args);
array_string os__cmdline__only_options(array_string args);
string time__Time_format(time__Time t);
string time__Time_format_ss(time__Time t);
string time__Time_format_ss_milli(time__Time t);
string time__Time_format_ss_micro(time__Time t);
string time__Time_hhmm(time__Time t);
string time__Time_hhmmss(time__Time t);
string time__Time_hhmm12(time__Time t);
string time__Time_ymmdd(time__Time t);
string time__Time_ddmmy(time__Time t);
string time__Time_md(time__Time t);
string time__Time_clean(time__Time t);
string time__Time_clean12(time__Time t);
string time__Time_get_fmt_time_str(time__Time t, time__FormatTime fmt_time);
string time__Time_get_fmt_date_str(time__Time t, time__FormatDelimiter fmt_dlmtr, time__FormatDate fmt_date);
string time__Time_get_fmt_str(time__Time t, time__FormatDelimiter fmt_dlmtr, time__FormatTime fmt_time, time__FormatDate fmt_date);
string time__Time_utc_string(time__Time t);
bool time__Time_eq(time__Time t1, time__Time t2);
bool time__Time_ne(time__Time t1, time__Time t2);
bool time__Time_lt(time__Time t1, time__Time t2);
bool time__Time_le(time__Time t1, time__Time t2);
bool time__Time_gt(time__Time t1, time__Time t2);
bool time__Time_ge(time__Time t1, time__Time t2);
Option_time__Time time__parse(string s);
Option_time__Time time__parse_rfc2822(string s);
Option_time__Time time__parse_iso8601(string s);
time__StopWatch time__new_stopwatch(time__StopWatchOptions opts);
void time__StopWatch_start(time__StopWatch* t);
void time__StopWatch_restart(time__StopWatch* t);
void time__StopWatch_stop(time__StopWatch* t);
void time__StopWatch_pause(time__StopWatch* t);
time__Duration time__StopWatch_elapsed(time__StopWatch t);
string _const_time__days_string; // a string literal, inited later
array_int _const_time__month_days; // inited later
string _const_time__months_string; // a string literal, inited later
i64 _const_time__absolute_zero_year; // inited later
#define _const_time__seconds_per_minute 60
int _const_time__seconds_per_hour; // inited later
int _const_time__seconds_per_day; // inited later
int _const_time__seconds_per_week; // inited later
int _const_time__days_per_400_years; // inited later
int _const_time__days_per_100_years; // inited later
int _const_time__days_per_4_years; // inited later
array_int _const_time__days_before; // inited later
array_string _const_time__long_days; // inited later
time__Time time__now();
time__Time time__utc();
string time__Time_smonth(time__Time t);
time__Time time__new_time(time__Time t);
int time__Time_unix_time(time__Time t);
u64 time__Time_unix_time_milli(time__Time t);
time__Time time__Time_add_seconds(time__Time t, int seconds);
time__Time time__Time_add_days(time__Time t, int days);
VV_LOCAL_SYMBOL int time__since(time__Time t);
string time__Time_relative(time__Time t);
string time__Time_relative_short(time__Time t);
int time__day_of_week(int y, int m, int d);
int time__Time_day_of_week(time__Time t);
string time__Time_weekday_str(time__Time t);
string time__Time_long_weekday_str(time__Time t);
i64 time__ticks();
void time__sleep(int seconds);
void time__sleep_ms(int milliseconds);
void time__usleep(int microseconds);
bool time__is_leap_year(int year);
Option_int time__days_in_month(int month, int year);
string time__Time_str(time__Time t);
VV_LOCAL_SYMBOL time__Time time__convert_ctime(struct tm t, int microsecond);
time__Duration _const_time__nanosecond; // inited later
i64 _const_time__microsecond; // inited later
i64 _const_time__millisecond; // inited later
i64 _const_time__second; // inited later
i64 _const_time__minute; // inited later
i64 _const_time__hour; // inited later
time__Duration _const_time__infinite; // inited later
i64 time__Duration_nanoseconds(time__Duration d);
i64 time__Duration_microseconds(time__Duration d);
i64 time__Duration_milliseconds(time__Duration d);
f64 time__Duration_seconds(time__Duration d);
f64 time__Duration_minutes(time__Duration d);
f64 time__Duration_hours(time__Duration d);
u64 _const_time__start_time; // inited later
u64 _const_time__freq_time; // inited later
int _const_time__start_local_time; // inited later
VV_LOCAL_SYMBOL int time__make_unix_time(struct tm t);
VV_LOCAL_SYMBOL u64 time__init_win_time_freq();
VV_LOCAL_SYMBOL u64 time__init_win_time_start();
u64 time__sys_mono_now();
VV_LOCAL_SYMBOL u64 time__vpc_now();
VV_LOCAL_SYMBOL int time__local_as_unix_time();
VV_LOCAL_SYMBOL time__Time time__to_local_time(time__Time t);
VV_LOCAL_SYMBOL time__Time time__win_now();
VV_LOCAL_SYMBOL time__Time time__win_utc();
int time__SystemTime_unix_time(time__SystemTime st);
time__Time time__darwin_now();
time__Time time__linux_now();
time__Time time__solaris_now();
time__Time time__darwin_utc();
time__Time time__linux_utc();
time__Time time__solaris_utc();
time__Time time__unix(int abs);
time__Time time__unix2(int abs, int microsecond);
VV_LOCAL_SYMBOL multi_return_int_int_int time__calculate_date_from_offset(int day_offset_);
VV_LOCAL_SYMBOL multi_return_int_int_int time__calculate_time_from_offset(int second_offset_);
string v__token__Position_str(v__token__Position pos);
v__token__Position v__token__Position_extend(v__token__Position pos, v__token__Position end);
v__token__Position v__token__Token_position(v__token__Token* tok);
array_v__token__Kind _const_v__token__assign_tokens; // inited later
int _const_v__token__nr_tokens; // inited later
array_string _const_v__token__valid_at_tokens; // inited later
VV_LOCAL_SYMBOL map_string_v__token__Kind v__token__build_keys();
VV_LOCAL_SYMBOL array_string v__token__build_token_str();
array_string _const_v__token__token_str; // inited later
map_string_v__token__Kind _const_v__token__keywords; // inited later
v__token__Kind v__token__key_to_token(string key);
bool v__token__is_key(string key);
bool v__token__is_decl(v__token__Kind t);
bool v__token__Kind_is_assign(v__token__Kind t);
VV_LOCAL_SYMBOL bool array_v__token__Kind_contains(array_v__token__Kind t, v__token__Kind val);
string v__token__Kind_str(v__token__Kind t);
string v__token__Token_str(v__token__Token t);
array_v__token__Precedence v__token__build_precedences();
array_v__token__Precedence _const_v__token__precedences; // inited later
int v__token__Token_precedence(v__token__Token tok);
bool v__token__Token_is_scalar(v__token__Token tok);
bool v__token__Token_is_unary(v__token__Token tok);
bool v__token__Kind_is_relational(v__token__Kind tok);
bool v__token__Kind_is_start_of_type(v__token__Kind k);
bool v__token__Kind_is_prefix(v__token__Kind kind);
bool v__token__Kind_is_infix(v__token__Kind kind);
void v__depgraph__OrderedDepMap_set(v__depgraph__OrderedDepMap* o, string name, array_string deps);
void v__depgraph__OrderedDepMap_add(v__depgraph__OrderedDepMap* o, string name, array_string deps);
array_string v__depgraph__OrderedDepMap_get(v__depgraph__OrderedDepMap* o, string name);
void v__depgraph__OrderedDepMap_delete(v__depgraph__OrderedDepMap* o, string name);
void v__depgraph__OrderedDepMap_apply_diff(v__depgraph__OrderedDepMap* o, string name, array_string deps);
int v__depgraph__OrderedDepMap_size(v__depgraph__OrderedDepMap* o);
v__depgraph__DepGraph* v__depgraph__new_dep_graph();
void v__depgraph__DepGraph_add(v__depgraph__DepGraph* graph, string mod, array_string deps);
v__depgraph__DepGraph* v__depgraph__DepGraph_resolve(v__depgraph__DepGraph* graph);
v__depgraph__DepGraphNode v__depgraph__DepGraph_last_node(v__depgraph__DepGraph* graph);
string v__depgraph__DepGraph_display(v__depgraph__DepGraph* graph);
string v__depgraph__DepGraph_display_cycles(v__depgraph__DepGraph* graph);
string flag__Flag_str(flag__Flag f);
string array_flag__Flag_str(array_flag__Flag af);
string _const_flag__space; // a string literal, inited later
string _const_flag__underline; // a string literal, inited later
#define _const_flag__max_args_number 4048
flag__FlagParser* flag__new_flag_parser(array_string args);
void flag__FlagParser_application(flag__FlagParser* fs, string name);
void flag__FlagParser_version(flag__FlagParser* fs, string vers);
void flag__FlagParser_description(flag__FlagParser* fs, string desc);
void flag__FlagParser_skip_executable(flag__FlagParser* fs);
VV_LOCAL_SYMBOL void flag__FlagParser_add_flag(flag__FlagParser* fs, string name, byte abbr, string usage, string desc);
VV_LOCAL_SYMBOL array_string flag__FlagParser_parse_value(flag__FlagParser* fs, string longhand, byte shorthand);
VV_LOCAL_SYMBOL Option_string flag__FlagParser_parse_bool_value(flag__FlagParser* fs, string longhand, byte shorthand);
Option_bool flag__FlagParser_bool_opt(flag__FlagParser* fs, string name, byte abbr, string usage);
bool flag__FlagParser_bool(flag__FlagParser* fs, string name, byte abbr, bool bdefault, string usage);
array_int flag__FlagParser_int_multi(flag__FlagParser* fs, string name, byte abbr, string usage);
Option_int flag__FlagParser_int_opt(flag__FlagParser* fs, string name, byte abbr, string usage);
int flag__FlagParser_int(flag__FlagParser* fs, string name, byte abbr, int idefault, string usage);
array_f64 flag__FlagParser_float_multi(flag__FlagParser* fs, string name, byte abbr, string usage);
Option_f64 flag__FlagParser_float_opt(flag__FlagParser* fs, string name, byte abbr, string usage);
f64 flag__FlagParser_float(flag__FlagParser* fs, string name, byte abbr, f64 fdefault, string usage);
array_string flag__FlagParser_string_multi(flag__FlagParser* fs, string name, byte abbr, string usage);
Option_string flag__FlagParser_string_opt(flag__FlagParser* fs, string name, byte abbr, string usage);
string flag__FlagParser_string(flag__FlagParser* fs, string name, byte abbr, string sdefault, string usage);
void flag__FlagParser_limit_free_args_to_at_least(flag__FlagParser* fs, int n);
void flag__FlagParser_limit_free_args_to_exactly(flag__FlagParser* fs, int n);
void flag__FlagParser_limit_free_args(flag__FlagParser* fs, int min, int max);
void flag__FlagParser_arguments_description(flag__FlagParser* fs, string description);
string flag__FlagParser_usage(flag__FlagParser fs);
Option_array_string flag__FlagParser_finalize(flag__FlagParser fs);
VV_LOCAL_SYMBOL bool semver__version_satisfies(semver__Version ver, string input);
VV_LOCAL_SYMBOL bool semver__compare_eq(semver__Version v1, semver__Version v2);
VV_LOCAL_SYMBOL bool semver__compare_gt(semver__Version v1, semver__Version v2);
VV_LOCAL_SYMBOL bool semver__compare_lt(semver__Version v1, semver__Version v2);
VV_LOCAL_SYMBOL bool semver__compare_ge(semver__Version v1, semver__Version v2);
VV_LOCAL_SYMBOL bool semver__compare_le(semver__Version v1, semver__Version v2);
#define _const_semver__ver_major 0
#define _const_semver__ver_minor 1
#define _const_semver__ver_patch 2
array_int _const_semver__versions; // inited later
VV_LOCAL_SYMBOL semver__RawVersion semver__parse(string input);
VV_LOCAL_SYMBOL bool semver__RawVersion_is_valid(semver__RawVersion ver);
VV_LOCAL_SYMBOL bool semver__RawVersion_is_missing(semver__RawVersion ver, int typ);
VV_LOCAL_SYMBOL Option_semver__Version semver__RawVersion_coerce(semver__RawVersion raw_ver);
VV_LOCAL_SYMBOL semver__RawVersion semver__RawVersion_complete(semver__RawVersion raw_ver);
VV_LOCAL_SYMBOL Option_semver__Version semver__RawVersion_validate(semver__RawVersion raw_ver);
VV_LOCAL_SYMBOL semver__Version semver__RawVersion_to_version(semver__RawVersion raw_ver);
string _const_semver__comparator_sep; // a string literal, inited later
string _const_semver__comparator_set_sep; // a string literal, inited later
string _const_semver__hyphen_range_sep; // a string literal, inited later
string _const_semver__x_range_symbols; // a string literal, inited later
VV_LOCAL_SYMBOL bool semver__Range_satisfies(semver__Range r, semver__Version ver);
VV_LOCAL_SYMBOL bool semver__ComparatorSet_satisfies(semver__ComparatorSet set, semver__Version ver);
VV_LOCAL_SYMBOL bool semver__Comparator_satisfies(semver__Comparator c, semver__Version ver);
VV_LOCAL_SYMBOL Option_semver__Range semver__parse_range(string input);
VV_LOCAL_SYMBOL Option_semver__ComparatorSet semver__parse_comparator_set(string input);
VV_LOCAL_SYMBOL Option_semver__Comparator semver__parse_comparator(string input);
VV_LOCAL_SYMBOL Option_semver__Version semver__parse_xrange(string input);
VV_LOCAL_SYMBOL bool semver__can_expand(string input);
VV_LOCAL_SYMBOL Option_semver__ComparatorSet semver__expand_comparator_set(string input);
VV_LOCAL_SYMBOL Option_semver__ComparatorSet semver__expand_tilda(string raw_version);
VV_LOCAL_SYMBOL Option_semver__ComparatorSet semver__expand_caret(string raw_version);
VV_LOCAL_SYMBOL Option_semver__ComparatorSet semver__expand_hyphen(string raw_range);
VV_LOCAL_SYMBOL Option_semver__ComparatorSet semver__expand_xrange(string raw_range);
VV_LOCAL_SYMBOL semver__ComparatorSet semver__make_comparator_set_ge_lt(semver__Version min, semver__Version max);
VV_LOCAL_SYMBOL semver__ComparatorSet semver__make_comparator_set_ge_le(semver__Version min, semver__Version max);
Option_semver__Version semver__from(string input);
semver__Version semver__build(int major, int minor, int patch);
semver__Version semver__Version_increment(semver__Version ver, semver__Increment typ);
bool semver__Version_satisfies(semver__Version ver, string input);
bool semver__Version_eq(semver__Version v1, semver__Version v2);
bool semver__Version_gt(semver__Version v1, semver__Version v2);
bool semver__Version_lt(semver__Version v1, semver__Version v2);
bool semver__Version_ge(semver__Version v1, semver__Version v2);
bool semver__Version_le(semver__Version v1, semver__Version v2);
Option_semver__Version semver__coerce(string input);
bool semver__is_valid(string input);
VV_LOCAL_SYMBOL bool semver__is_version_valid(string input);
VV_LOCAL_SYMBOL Option_semver__Version semver__coerce_version(string input);
VV_LOCAL_SYMBOL semver__Version semver__increment_version(semver__Version ver, semver__Increment typ);
VV_LOCAL_SYMBOL bool semver__is_valid_string(string input);
VV_LOCAL_SYMBOL bool semver__is_valid_number(string input);
v__vcache__CacheManager v__vcache__new_cache_manager(array_string opts);
string v__vcache__CacheManager_key2cpath(v__vcache__CacheManager* cm, string key);
string v__vcache__CacheManager_postfix_with_key2cpath(v__vcache__CacheManager* cm, string postfix, string key);
Option_string v__vcache__CacheManager_exists(v__vcache__CacheManager* cm, string postfix, string key);
Option_string v__vcache__CacheManager_save(v__vcache__CacheManager* cm, string postfix, string key, string content);
Option_string v__vcache__CacheManager_load(v__vcache__CacheManager* cm, string postfix, string key);
string term__format(string msg, string open, string close);
string term__format_rgb(int r, int g, int b, string msg, string open, string close);
string term__rgb(int r, int g, int b, string msg);
string term__bg_rgb(int r, int g, int b, string msg);
string term__hex(int hex, string msg);
string term__bg_hex(int hex, string msg);
string term__bg_black(string msg);
string term__bright_bg_black(string msg);
string term__bg_blue(string msg);
string term__bright_bg_blue(string msg);
string term__bg_cyan(string msg);
string term__bright_bg_cyan(string msg);
string term__bg_green(string msg);
string term__bright_bg_green(string msg);
string term__bg_magenta(string msg);
string term__bright_bg_magenta(string msg);
string term__bg_red(string msg);
string term__bright_bg_red(string msg);
string term__bg_white(string msg);
string term__bright_bg_white(string msg);
string term__bg_yellow(string msg);
string term__bright_bg_yellow(string msg);
string term__black(string msg);
string term__bright_black(string msg);
string term__blue(string msg);
string term__bright_blue(string msg);
string term__bold(string msg);
string term__cyan(string msg);
string term__bright_cyan(string msg);
string term__dim(string msg);
string term__green(string msg);
string term__bright_green(string msg);
string term__gray(string msg);
string term__hidden(string msg);
string term__italic(string msg);
string term__inverse(string msg);
string term__magenta(string msg);
string term__bright_magenta(string msg);
string term__reset(string msg);
string term__red(string msg);
string term__bright_red(string msg);
string term__strikethrough(string msg);
string term__underline(string msg);
string term__white(string msg);
string term__bright_white(string msg);
string term__yellow(string msg);
string term__bright_yellow(string msg);
void term__set_cursor_position(term__Coord c);
void term__move(int n, string direction);
void term__cursor_up(int n);
void term__cursor_down(int n);
void term__cursor_forward(int n);
void term__cursor_back(int n);
void term__erase_display(string t);
void term__erase_toend();
void term__erase_tobeg();
void term__erase_clear();
void term__erase_del_clear();
void term__erase_line(string t);
void term__erase_line_toend();
void term__erase_line_tobeg();
void term__erase_line_clear();
void term__show_cursor();
void term__hide_cursor();
#define _const_term__default_columns_size 80
#define _const_term__default_rows_size 25
bool term__can_show_color_on_stdout();
bool term__can_show_color_on_stderr();
string term__ok_message(string s);
string term__fail_message(string s);
string term__warn_message(string s);
string term__h_divider(string divider);
string term__header(string text, string divider);
VV_LOCAL_SYMBOL int term__imax(int x, int y);
VV_LOCAL_SYMBOL bool term__supports_escape_sequences(int fd);
void term__clear();
multi_return_int_int term__get_terminal_size();
term__Coord term__get_cursor_position();
bool term__set_terminal_title(string title);
Option_v__vmod__Manifest v__vmod__from_file(string vmod_path);
Option_v__vmod__Manifest v__vmod__decode(string contents);
VV_LOCAL_SYMBOL void v__vmod__Scanner_tokenize(v__vmod__Scanner* s, v__vmod__TokenKind t_type, string val);
VV_LOCAL_SYMBOL void v__vmod__Scanner_skip_whitespace(v__vmod__Scanner* s);
VV_LOCAL_SYMBOL bool v__vmod__is_name_alpha(byte chr);
VV_LOCAL_SYMBOL string v__vmod__Scanner_create_string(v__vmod__Scanner* s, byte q);
VV_LOCAL_SYMBOL string v__vmod__Scanner_create_ident(v__vmod__Scanner* s);
VV_LOCAL_SYMBOL bool v__vmod__Scanner_peek_char(v__vmod__Scanner s, byte c);
VV_LOCAL_SYMBOL void v__vmod__Scanner_scan_all(v__vmod__Scanner* s);
VV_LOCAL_SYMBOL Option_multi_return_array_string_int v__vmod__get_array_content(array_v__vmod__Token tokens, int st_idx);
VV_LOCAL_SYMBOL Option_v__vmod__Manifest v__vmod__Parser_parse(v__vmod__Parser* p);
v__vmod__ModFileCacher* v__vmod__new_mod_file_cacher();
void v__vmod__ModFileCacher_dump(v__vmod__ModFileCacher* mcache);
v__vmod__ModFileAndFolder v__vmod__ModFileCacher_get_by_file(v__vmod__ModFileCacher* mcache, string vfile);
v__vmod__ModFileAndFolder v__vmod__ModFileCacher_get_by_folder(v__vmod__ModFileCacher* mcache, string vfolder);
VV_LOCAL_SYMBOL void v__vmod__ModFileCacher_add(v__vmod__ModFileCacher* cacher, string path, v__vmod__ModFileAndFolder result);
VV_LOCAL_SYMBOL multi_return_array_string_v__vmod__ModFileAndFolder v__vmod__ModFileCacher_traverse(v__vmod__ModFileCacher* mcache, string mfolder);
VV_LOCAL_SYMBOL void v__vmod__ModFileCacher_mark_folders_with_vmod(v__vmod__ModFileCacher* mcache, array_string folders_so_far, v__vmod__ModFileAndFolder vmod);
VV_LOCAL_SYMBOL void v__vmod__ModFileCacher_mark_folders_as_vmod_free(v__vmod__ModFileCacher* mcache, array_string folders_so_far);
array_string _const_v__vmod__mod_file_stop_paths; // inited later
VV_LOCAL_SYMBOL bool v__vmod__ModFileCacher_check_for_stop(v__vmod__ModFileCacher* mcache, string cfolder, array_string files);
VV_LOCAL_SYMBOL array_string v__vmod__ModFileCacher_get_files(v__vmod__ModFileCacher* mcache, string cfolder);
v__vmod__ModFileCacher* _const_v__vmod__private_file_cacher; // inited later
v__vmod__ModFileCacher* v__vmod__get_cache();
string v__cflag__CFlag_str(v__cflag__CFlag* c);
string v__cflag__CFlag_format(v__cflag__CFlag* cf);
string array_v__cflag__CFlag_c_options_before_target_msvc(array_v__cflag__CFlag cflags);
string array_v__cflag__CFlag_c_options_after_target_msvc(array_v__cflag__CFlag cflags);
string array_v__cflag__CFlag_c_options_before_target(array_v__cflag__CFlag cflags);
string array_v__cflag__CFlag_c_options_after_target(array_v__cflag__CFlag cflags);
string array_v__cflag__CFlag_c_options_without_object_files(array_v__cflag__CFlag cflags);
string array_v__cflag__CFlag_c_options_only_object_files(array_v__cflag__CFlag cflags);
u64 _const_rand__util__lower_mask; // inited later
#define _const_rand__util__max_u32 0xFFFFFFFF
#define _const_rand__util__max_u64 0xFFFFFFFFFFFFFFFF
f32 _const_rand__util__max_u32_as_f32; // inited later
f64 _const_rand__util__max_u64_as_f64; // inited later
u32 _const_rand__util__u31_mask; // inited later
u64 _const_rand__util__u63_mask; // inited later
VV_LOCAL_SYMBOL u32 rand__util__nr_next(u32 prev);
array_u32 rand__util__time_seed_array(int count);
u32 rand__util__time_seed_32();
u64 rand__util__time_seed_64();
VV_LOCAL_SYMBOL Option_string v__pkgconfig__desc(string mod);
Option_v__pkgconfig__Main_ptr v__pkgconfig__main(array_string args);
Option_string v__pkgconfig__Main_run(v__pkgconfig__Main* m);
VV_LOCAL_SYMBOL string v__pkgconfig__filter(array_string libs, string prefix, string prefix2);
VV_LOCAL_SYMBOL v__pkgconfig__MainOptions* v__pkgconfig__parse_options(flag__FlagParser* fp);
array_string _const_v__pkgconfig__default_paths; // inited later
string _const_v__pkgconfig__version; // a string literal, inited later
VV_LOCAL_SYMBOL array_string v__pkgconfig__PkgConfig_parse_list(v__pkgconfig__PkgConfig* pc, string s);
VV_LOCAL_SYMBOL string v__pkgconfig__PkgConfig_parse_line(v__pkgconfig__PkgConfig* pc, string s);
VV_LOCAL_SYMBOL void v__pkgconfig__PkgConfig_setvar(v__pkgconfig__PkgConfig* pc, string line);
VV_LOCAL_SYMBOL bool v__pkgconfig__PkgConfig_parse(v__pkgconfig__PkgConfig* pc, string file);
VV_LOCAL_SYMBOL Option_string v__pkgconfig__PkgConfig_resolve(v__pkgconfig__PkgConfig* pc, string pkgname);
bool v__pkgconfig__atleast(string v);
bool v__pkgconfig__PkgConfig_atleast(v__pkgconfig__PkgConfig* pc, string v);
Option_string v__pkgconfig__PkgConfig_extend(v__pkgconfig__PkgConfig* pc, v__pkgconfig__PkgConfig* pcdep);
VV_LOCAL_SYMBOL void v__pkgconfig__PkgConfig_load_requires(v__pkgconfig__PkgConfig* pc);
VV_LOCAL_SYMBOL void v__pkgconfig__PkgConfig_add_path(v__pkgconfig__PkgConfig* pc, string path);
VV_LOCAL_SYMBOL void v__pkgconfig__PkgConfig_load_paths(v__pkgconfig__PkgConfig* pc);
Option_v__pkgconfig__PkgConfig_ptr v__pkgconfig__load(string pkgname, v__pkgconfig__Options options);
array_string v__pkgconfig__list();
string _const_vweb__tmpl__str_start; // a string literal, inited later
string _const_vweb__tmpl__str_end; // a string literal, inited later
string vweb__tmpl__compile_file(string path, string fn_name);
string vweb__tmpl__compile_template(string html_, string fn_name);
int runtime__nr_jobs();
bool runtime__is_32bit();
bool runtime__is_64bit();
bool runtime__is_little_endian();
bool runtime__is_big_endian();
int runtime__nr_cpus();
string v__table__Attr_str(v__table__Attr attr);
bool array_v__table__Attr_contains(array_v__table__Attr attrs, string str);
VV_LOCAL_SYMBOL bool v__table__Table_has_cflag(v__table__Table* table, v__cflag__CFlag flag);
Option_bool v__table__Table_parse_cflag(v__table__Table* table, string cflg, string mod, array_string ctimedefines);
VV_LOCAL_SYMBOL bool v__table__Fn_method_equals(v__table__Fn* f, v__table__Fn* o);
VV_LOCAL_SYMBOL bool v__table__Param_equals(v__table__Param* p, v__table__Param* o);
VV_LOCAL_SYMBOL bool array_v__table__Param_equals(array_v__table__Param p, array_v__table__Param o);
v__table__Table* v__table__new_table();
string v__table__Fn_signature(v__table__Fn* f);
string v__table__Fn_source_signature(v__table__Fn* f);
bool v__table__Fn_is_same_method_as(v__table__Fn* f, v__table__Fn* func);
Option_v__table__Fn v__table__Table_find_fn(v__table__Table* t, string name);
bool v__table__Table_known_fn(v__table__Table* t, string name);
void v__table__Table_register_fn(v__table__Table* t, v__table__Fn new_fn);
int v__table__TypeSymbol_register_method(v__table__TypeSymbol* t, v__table__Fn new_fn);
Option_v__table__Fn v__table__Table_register_aggregate_method(v__table__Table* t, v__table__TypeSymbol* sym, string name);
bool v__table__Table_type_has_method(v__table__Table* t, v__table__TypeSymbol* s, string name);
Option_v__table__Fn v__table__Table_type_find_method(v__table__Table* t, v__table__TypeSymbol* s, string name);
VV_LOCAL_SYMBOL Option_v__table__Field v__table__Table_register_aggregate_field(v__table__Table* t, v__table__TypeSymbol* sym, string name);
bool v__table__Table_struct_has_field(v__table__Table* t, v__table__TypeSymbol* s, string name);
Option_v__table__Field v__table__Table_struct_find_field(v__table__Table* t, v__table__TypeSymbol* s, string name);
int v__table__Table_find_type_idx(v__table__Table* t, string name);
Option_v__table__TypeSymbol v__table__Table_find_type(v__table__Table* t, string name);
v__table__TypeSymbol* v__table__Table_get_type_symbol(v__table__Table* t, v__table__Type typ);
v__table__TypeSymbol* v__table__Table_get_final_type_symbol(v__table__Table* t, v__table__Type typ);
string v__table__Table_get_type_name(v__table__Table* t, v__table__Type typ);
v__table__Type v__table__Table_unalias_num_type(v__table__Table* t, v__table__Type typ);
int v__table__Table_register_builtin_type_symbol(v__table__Table* t, v__table__TypeSymbol typ);
int v__table__Table_register_type_symbol(v__table__Table* t, v__table__TypeSymbol typ);
bool v__table__Table_known_type(v__table__Table* t, string name);
string v__table__Table_array_name(v__table__Table* t, v__table__Type elem_type, int nr_dims);
string v__table__Table_array_source_name(v__table__Table* t, v__table__Type elem_type);
string v__table__Table_array_fixed_name(v__table__Table* t, v__table__Type elem_type, int size, int nr_dims);
string v__table__Table_array_fixed_source_name(v__table__Table* t, v__table__Type elem_type, int size);
string v__table__Table_chan_name(v__table__Table* t, v__table__Type elem_type, bool is_mut);
string v__table__Table_chan_source_name(v__table__Table* t, v__table__Type elem_type, bool is_mut);
string v__table__Table_map_name(v__table__Table* t, v__table__Type key_type, v__table__Type value_type);
string v__table__Table_map_source_name(v__table__Table* t, v__table__Type key_type, v__table__Type value_type);
int v__table__Table_find_or_register_chan(v__table__Table* t, v__table__Type elem_type, bool is_mut);
int v__table__Table_find_or_register_map(v__table__Table* t, v__table__Type key_type, v__table__Type value_type);
int v__table__Table_find_or_register_array(v__table__Table* t, v__table__Type elem_type, int nr_dims, string mod);
int v__table__Table_find_or_register_array_fixed(v__table__Table* t, v__table__Type elem_type, int size, int nr_dims);
int v__table__Table_find_or_register_multi_return(v__table__Table* t, array_v__table__Type mr_typs);
int v__table__Table_find_or_register_fn_type(v__table__Table* t, string mod, v__table__Fn f, bool is_anon, bool has_decl);
int v__table__Table_add_placeholder_type(v__table__Table* t, string name, v__table__Language language);
v__table__Type v__table__Table_value_type(v__table__Table* t, v__table__Type typ);
v__table__Type v__table__Table_mktyp(v__table__Table* t, v__table__Type typ);
string v__table__Table_qualify_module(v__table__Table* table, string mod, string file_path);
void v__table__Table_register_fn_gen_type(v__table__Table* table, string fn_name, v__table__Type typ);
bool v__table__Table_sumtype_has_variant(v__table__Table* table, v__table__Type parent, v__table__Type variant);
array_string v__table__Table_known_type_names(v__table__Table* table);
string v__table__ShareType_str(v__table__ShareType t);
string v__table__Type_atomic_typename(v__table__Type t);
v__table__ShareType v__table__sharetype_from_flags(bool is_shared, bool is_atomic);
v__table__ShareType v__table__Type_share(v__table__Type t);
bool array_v__table__Type_contains(array_v__table__Type types, v__table__Type typ);
int v__table__Type_idx(v__table__Type t);
bool v__table__Type_is_void(v__table__Type t);
bool v__table__Type_is_full(v__table__Type t);
int v__table__Type_nr_muls(v__table__Type t);
bool v__table__Type_is_ptr(v__table__Type t);
v__table__Type v__table__Type_set_nr_muls(v__table__Type t, int nr_muls);
v__table__Type v__table__Type_to_ptr(v__table__Type t);
v__table__Type v__table__Type_deref(v__table__Type t);
v__table__Type v__table__Type_set_flag(v__table__Type t, v__table__TypeFlag flag);
v__table__Type v__table__Type_clear_flag(v__table__Type t, v__table__TypeFlag flag);
v__table__Type v__table__Type_clear_flags(v__table__Type t);
bool v__table__Type_has_flag(v__table__Type t, v__table__TypeFlag flag);
array_string v__table__TypeSymbol_debug(v__table__TypeSymbol ts);
array_string v__table__Type_debug(v__table__Type t);
v__table__Type v__table__Type_derive(v__table__Type t, v__table__Type t_from);
v__table__Type v__table__new_type(int idx);
v__table__Type v__table__new_type_ptr(int idx, int nr_muls);
bool v__table__Type_is_pointer(v__table__Type typ);
bool v__table__Type_is_float(v__table__Type typ);
bool v__table__Type_is_int(v__table__Type typ);
bool v__table__Type_is_signed(v__table__Type typ);
bool v__table__Type_is_unsigned(v__table__Type typ);
bool v__table__Type_is_any_int(v__table__Type typ);
bool v__table__Type_is_number(v__table__Type typ);
bool v__table__Type_is_string(v__table__Type typ);
#define _const_v__table__void_type_idx 1
#define _const_v__table__voidptr_type_idx 2
#define _const_v__table__byteptr_type_idx 3
#define _const_v__table__charptr_type_idx 4
#define _const_v__table__i8_type_idx 5
#define _const_v__table__i16_type_idx 6
#define _const_v__table__int_type_idx 7
#define _const_v__table__i64_type_idx 8
#define _const_v__table__byte_type_idx 9
#define _const_v__table__u16_type_idx 10
#define _const_v__table__u32_type_idx 11
#define _const_v__table__u64_type_idx 12
#define _const_v__table__f32_type_idx 13
#define _const_v__table__f64_type_idx 14
#define _const_v__table__char_type_idx 15
#define _const_v__table__bool_type_idx 16
#define _const_v__table__none_type_idx 17
#define _const_v__table__string_type_idx 18
#define _const_v__table__ustring_type_idx 19
#define _const_v__table__array_type_idx 20
#define _const_v__table__map_type_idx 21
#define _const_v__table__chan_type_idx 22
#define _const_v__table__sizet_type_idx 23
#define _const_v__table__rune_type_idx 24
#define _const_v__table__any_type_idx 25
#define _const_v__table__any_flt_type_idx 26
#define _const_v__table__any_int_type_idx 27
array_int _const_v__table__integer_type_idxs; // inited later
array_int _const_v__table__signed_integer_type_idxs; // inited later
array_int _const_v__table__unsigned_integer_type_idxs; // inited later
array_int _const_v__table__float_type_idxs; // inited later
array_int _const_v__table__number_type_idxs; // inited later
array_int _const_v__table__pointer_type_idxs; // inited later
array_int _const_v__table__string_type_idxs; // inited later
v__table__Type _const_v__table__void_type; // inited later
v__table__Type _const_v__table__voidptr_type; // inited later
v__table__Type _const_v__table__byteptr_type; // inited later
v__table__Type _const_v__table__charptr_type; // inited later
v__table__Type _const_v__table__i8_type; // inited later
v__table__Type _const_v__table__int_type; // inited later
v__table__Type _const_v__table__i16_type; // inited later
v__table__Type _const_v__table__i64_type; // inited later
v__table__Type _const_v__table__byte_type; // inited later
v__table__Type _const_v__table__u16_type; // inited later
v__table__Type _const_v__table__u32_type; // inited later
v__table__Type _const_v__table__u64_type; // inited later
v__table__Type _const_v__table__f32_type; // inited later
v__table__Type _const_v__table__f64_type; // inited later
v__table__Type _const_v__table__char_type; // inited later
v__table__Type _const_v__table__bool_type; // inited later
v__table__Type _const_v__table__none_type; // inited later
v__table__Type _const_v__table__string_type; // inited later
v__table__Type _const_v__table__ustring_type; // inited later
v__table__Type _const_v__table__array_type; // inited later
v__table__Type _const_v__table__map_type; // inited later
v__table__Type _const_v__table__chan_type; // inited later
v__table__Type _const_v__table__rune_type; // inited later
v__table__Type _const_v__table__any_type; // inited later
v__table__Type _const_v__table__any_flt_type; // inited later
v__table__Type _const_v__table__any_int_type; // inited later
array_string _const_v__table__builtin_type_names; // inited later
v__table__Kind v__table__Table_type_kind(v__table__Table* table, v__table__Type typ);
string v__table__TypeSymbol_str(v__table__TypeSymbol* t);
v__table__Enum v__table__TypeSymbol_enum_info(v__table__TypeSymbol* t);
v__table__MultiReturn v__table__TypeSymbol_mr_info(v__table__TypeSymbol* t);
v__table__Array v__table__TypeSymbol_array_info(v__table__TypeSymbol* t);
v__table__ArrayFixed v__table__TypeSymbol_array_fixed_info(v__table__TypeSymbol* t);
v__table__Chan v__table__TypeSymbol_chan_info(v__table__TypeSymbol* t);
v__table__Map v__table__TypeSymbol_map_info(v__table__TypeSymbol* t);
v__table__Struct v__table__TypeSymbol_struct_info(v__table__TypeSymbol* t);
void v__table__Table_register_builtin_type_symbols(v__table__Table* t);
bool v__table__TypeSymbol_is_pointer(v__table__TypeSymbol* t);
bool v__table__TypeSymbol_is_int(v__table__TypeSymbol* t);
bool v__table__TypeSymbol_is_float(v__table__TypeSymbol* t);
bool v__table__TypeSymbol_is_number(v__table__TypeSymbol* t);
string v__table__Kind_str(v__table__Kind k);
string array_v__table__Kind_str(array_v__table__Kind kinds);
VV_LOCAL_SYMBOL bool v__table__Field_equals(v__table__Field* f, v__table__Field* o);
string v__table__Table_type_to_str(v__table__Table* table, v__table__Type t);
string v__table__Table_fn_signature(v__table__Table* t, v__table__Fn* func, v__table__FnSignatureOpts opts);
bool v__table__TypeSymbol_has_method(v__table__TypeSymbol* t, string name);
Option_v__table__Fn v__table__TypeSymbol_find_method(v__table__TypeSymbol* t, string name);
multi_return_bool_bool_int v__table__TypeSymbol_str_method_info(v__table__TypeSymbol* t);
VV_LOCAL_SYMBOL Option_v__table__Field v__table__Aggregate_find_field(v__table__Aggregate* a, string name);
Option_v__table__Field v__table__Struct_find_field(v__table__Struct s, string name);
v__table__Field v__table__Struct_get_field(v__table__Struct s, string name);
u64 _const_rand__wyrand__wyp0; // inited later
u64 _const_rand__wyrand__wyp1; // inited later
void rand__wyrand__WyRandRNG_seed(rand__wyrand__WyRandRNG* rng, array_u32 seed_data);
u32 rand__wyrand__WyRandRNG_u32(rand__wyrand__WyRandRNG* rng);
u64 rand__wyrand__WyRandRNG_u64(rand__wyrand__WyRandRNG* rng);
u32 rand__wyrand__WyRandRNG_u32n(rand__wyrand__WyRandRNG* rng, u32 max);
u64 rand__wyrand__WyRandRNG_u64n(rand__wyrand__WyRandRNG* rng, u64 max);
u32 rand__wyrand__WyRandRNG_u32_in_range(rand__wyrand__WyRandRNG* rng, u32 min, u32 max);
u64 rand__wyrand__WyRandRNG_u64_in_range(rand__wyrand__WyRandRNG* rng, u64 min, u64 max);
int rand__wyrand__WyRandRNG_int(rand__wyrand__WyRandRNG* rng);
i64 rand__wyrand__WyRandRNG_i64(rand__wyrand__WyRandRNG* rng);
int rand__wyrand__WyRandRNG_int31(rand__wyrand__WyRandRNG* rng);
i64 rand__wyrand__WyRandRNG_int63(rand__wyrand__WyRandRNG* rng);
int rand__wyrand__WyRandRNG_intn(rand__wyrand__WyRandRNG* rng, int max);
i64 rand__wyrand__WyRandRNG_i64n(rand__wyrand__WyRandRNG* rng, i64 max);
int rand__wyrand__WyRandRNG_int_in_range(rand__wyrand__WyRandRNG* rng, int min, int max);
i64 rand__wyrand__WyRandRNG_i64_in_range(rand__wyrand__WyRandRNG* rng, i64 min, i64 max);
f32 rand__wyrand__WyRandRNG_f32(rand__wyrand__WyRandRNG* rng);
f64 rand__wyrand__WyRandRNG_f64(rand__wyrand__WyRandRNG* rng);
f32 rand__wyrand__WyRandRNG_f32n(rand__wyrand__WyRandRNG* rng, f32 max);
f64 rand__wyrand__WyRandRNG_f64n(rand__wyrand__WyRandRNG* rng, f64 max);
f32 rand__wyrand__WyRandRNG_f32_in_range(rand__wyrand__WyRandRNG* rng, f32 min, f32 max);
f64 rand__wyrand__WyRandRNG_f64_in_range(rand__wyrand__WyRandRNG* rng, f64 min, f64 max);
rand__wyrand__WyRandRNG* default_rng; // global
VV_LOCAL_SYMBOL void rand__init();
rand__wyrand__WyRandRNG* rand__new_default(rand__PRNGConfigStruct config);
void rand__seed(array_u32 seed);
u32 rand__u32();
u64 rand__u64();
u32 rand__u32n(u32 max);
u64 rand__u64n(u64 max);
u32 rand__u32_in_range(u32 min, u32 max);
u64 rand__u64_in_range(u64 min, u64 max);
int rand__int();
int rand__intn(int max);
int rand__int_in_range(int min, int max);
int rand__int31();
i64 rand__i64();
i64 rand__i64n(i64 max);
i64 rand__i64_in_range(i64 min, i64 max);
i64 rand__int63();
f32 rand__f32();
f64 rand__f64();
f32 rand__f32n(f32 max);
f64 rand__f64n(f64 max);
f32 rand__f32_in_range(f32 min, f32 max);
f64 rand__f64_in_range(f64 min, f64 max);
string _const_rand__chars; // a string literal, inited later
string rand__string(int len);
string rand__uuid_v4();
string _const_rand__ulid_encoding; // a string literal, inited later
string rand__ulid();
string rand__ulid_at_millisecond(u64 unix_time_milli);
string _const_v__pref__default_module_path; // inited later
v__pref__Preferences v__pref__new_preferences();
void v__pref__Preferences_fill_with_defaults(v__pref__Preferences* p);
VV_LOCAL_SYMBOL string v__pref__default_c_compiler();
string v__pref__vexe_path();
Option_v__pref__OS v__pref__os_from_string(string os_str);
string v__pref__OS_str(v__pref__OS o);
v__pref__OS v__pref__get_host_os();
array_string _const_v__pref__list_of_flags_with_param; // inited later
multi_return_v__pref__Preferences_string v__pref__parse_args(array_string args);
VV_LOCAL_SYMBOL void v__pref__Preferences_vrun_elog(v__pref__Preferences* pref, string s);
VV_LOCAL_SYMBOL void v__pref__must_exist(string path);
Option_v__pref__Backend v__pref__backend_from_string(string s);
v__pref__CompilerType v__pref__cc_from_string(string cc_str);
VV_LOCAL_SYMBOL void v__pref__parse_define(v__pref__Preferences* prefs, string define);
array_string v__pref__Preferences_should_compile_filtered_files(v__pref__Preferences* prefs, string dir, array_string files_);
bool v__pref__Preferences_should_compile_c(v__pref__Preferences* prefs, string file);
bool v__pref__Preferences_should_compile_js(v__pref__Preferences* prefs, string file);
string _const_help__unknown_topic; // a string literal, inited later
void help__print_and_exit(string topic);
Option_string v__util__find_working_diff_command();
VV_LOCAL_SYMBOL bool v__util__opendiff_exists();
string v__util__color_compare_files(string diff_cmd, string file1, string file2);
string v__util__color_compare_strings(string diff_cmd, string expected, string found);
#define _const_v__util__error_context_before 2
#define _const_v__util__error_context_after 2
v__util__EManager* _const_v__util__emanager; // inited later
v__util__EManager* v__util__new_error_manager();
void v__util__EManager_set_support_color(v__util__EManager* e, bool b);
string v__util__bold(string msg);
VV_LOCAL_SYMBOL string v__util__color(string kind, string msg);
string v__util__formatted_error(string kind, string omsg, string filepath, v__token__Position pos);
multi_return_string_int v__util__filepath_pos_to_source_and_column(string filepath, v__token__Position pos);
array_string v__util__source_context(string kind, string source, int column, v__token__Position pos);
void v__util__verror(string kind, string s);
string v__util__vlines_escape_path(string path, string ccompiler);
array_string _const_v__util__invalid_escapes; // inited later
string v__util__smart_quote(string str, bool raw);
bool v__util__is_name_char(byte c);
bool v__util__is_func_char(byte c);
bool v__util__is_nl(byte c);
bool v__util__contains_capital(string s);
bool v__util__good_type_name(string s);
string v__util__cescaped_path(string s);
VV_LOCAL_SYMBOL int v__util__compare_by_similarity(v__util__Possibility* a, v__util__Possibility* b);
v__util__Suggestion v__util__new_suggestion(string wanted, array_string possibilities);
void v__util__Suggestion_add(v__util__Suggestion* s, string val);
void v__util__Suggestion_add_many(v__util__Suggestion* s, array_string many);
void v__util__Suggestion_sort(v__util__Suggestion* s);
string v__util__Suggestion_say(v__util__Suggestion s, string msg);
string v__util__short_module_name(string name);
string _const_v__util__v_version; // a string literal, inited later
array_string _const_v__util__builtin_module_parts; // inited later
map_string_array_string _const_v__util__external_module_dependencies_for_tool; // inited later
string v__util__vhash();
string v__util__full_hash();
string v__util__full_v_version(bool is_verbose);
string v__util__githash(bool should_get_from_filesystem);
void v__util__set_vroot_folder(string vroot_path);
Option_string v__util__resolve_vroot(string str, string dir);
void v__util__launch_tool(bool is_verbose, string tool_name, array_string args);
bool v__util__should_recompile_tool(string vexe, string tool_source);
string v__util__quote_path(string s);
string v__util__args_quote_paths(array_string args);
string v__util__path_of_executable(string path);
Option_string v__util__read_file(string file_path);
string v__util__skip_bom(string file_content);
int v__util__imin(int a, int b);
int v__util__imax(int a, int b);
string v__util__replace_op(string s);
array_string v__util__join_env_vflags_and_os_args();
VV_LOCAL_SYMBOL array_string v__util__non_empty(array_string arg);
Option_bool v__util__check_module_is_installed(string modulename, bool is_verbose);
void v__util__ensure_modules_for_all_tools_are_installed(bool is_verbose);
string v__util__strip_mod_name(string name);
string v__util__strip_main_name(string name);
string v__util__no_dots(string s);
string _const_v__util__map_prefix; // a string literal, inited later
string v__util__no_cur_mod(string v_typename, string cur_mod);
void v__util__prepare_tool_when_needed(string source_name);
void v__util__recompile_file(string vexe, string file);
v__ast__IdentVar v__ast__Ident_var_info(v__ast__Ident* i);
bool v__ast__Expr_is_blank_ident(v__ast__Expr expr);
v__token__Position v__ast__Expr_position(v__ast__Expr expr);
bool v__ast__Expr_is_lvalue(v__ast__Expr expr);
bool v__ast__Expr_is_expr(v__ast__Expr expr);
Option_void v__ast__Stmt_check_c_expr(v__ast__Stmt stmt);
v__token__Position v__ast__Stmt_position(v__ast__Stmt stmt);
v__ast__Expr v__ast__fe2ex(v__table__FExpr x);
v__table__FExpr v__ast__ex2fe(v__ast__Expr x);
v__ast__Scope* v__ast__new_scope(v__ast__Scope* parent, int start_pos);
Option_multi_return_v__ast__ScopeObject_v__ast__Scope v__ast__Scope_find_with_scope(v__ast__Scope* s, string name);
Option_v__ast__ScopeObject v__ast__Scope_find(v__ast__Scope* s, string name);
Option_v__ast__ScopeStructField v__ast__Scope_find_struct_field(v__ast__Scope* s, v__table__Type struct_type, string field_name);
bool v__ast__Scope_is_known(v__ast__Scope* s, string name);
Option_v__ast__Var_ptr v__ast__Scope_find_var(v__ast__Scope* s, string name);
Option_v__ast__ConstField_ptr v__ast__Scope_find_const(v__ast__Scope* s, string name);
bool v__ast__Scope_known_var(v__ast__Scope* s, string name);
void v__ast__Scope_update_var_type(v__ast__Scope* s, string name, v__table__Type typ);
void v__ast__Scope_register_struct_field(v__ast__Scope* s, v__ast__ScopeStructField field);
void v__ast__Scope_register(v__ast__Scope* s, string name, v__ast__ScopeObject obj);
v__ast__Scope* v__ast__Scope_outermost(v__ast__Scope* s);
v__ast__Scope* v__ast__Scope_innermost(v__ast__Scope* s, int pos);
VV_LOCAL_SYMBOL bool v__ast__Scope_contains(v__ast__Scope* s, int pos);
string v__ast__Scope_show(v__ast__Scope* sc, int depth, int max_depth);
string v__ast__Scope_str(v__ast__Scope* sc);
string v__ast__FnDecl_modname(v__ast__FnDecl* node);
string v__ast__FnDecl_stringify(v__ast__FnDecl* node, v__table__Table* t, string cur_mod);
string v__ast__InfixExpr_str(v__ast__InfixExpr* x);
multi_return_string_bool v__ast__StringInterLiteral_get_fspec_braces(v__ast__StringInterLiteral* lit, int i);
string v__ast__Expr_str(v__ast__Expr x);
string v__ast__CallArg_str(v__ast__CallArg a);
string v__ast__args2str(array_v__ast__CallArg args);
string v__ast__BranchStmt_str(v__ast__BranchStmt* node);
string v__ast__Stmt_str(v__ast__Stmt node);
string v__ast__CompForKind_str(v__ast__CompForKind e);
#define _const_v__scanner__single_quote '\''
#define _const_v__scanner__double_quote '"'
#define _const_v__scanner__num_sep '_'
v__scanner__Scanner* v__scanner__new_scanner_file(string file_path, v__scanner__CommentsMode comments_mode, v__pref__Preferences* pref);
v__scanner__Scanner* v__scanner__new_vet_scanner_file(string file_path, v__scanner__CommentsMode comments_mode, v__pref__Preferences* pref);
v__scanner__Scanner* v__scanner__new_scanner(string text, v__scanner__CommentsMode comments_mode, v__pref__Preferences* pref);
v__scanner__Scanner* v__scanner__new_vet_scanner(string text, v__scanner__CommentsMode comments_mode, v__pref__Preferences* pref);
VV_LOCAL_SYMBOL bool v__scanner__Scanner_should_parse_comment(v__scanner__Scanner* s);
void v__scanner__Scanner_set_is_inside_toplevel_statement(v__scanner__Scanner* s, bool newstate);
void v__scanner__Scanner_set_current_tidx(v__scanner__Scanner* s, int cidx);
VV_LOCAL_SYMBOL v__token__Token v__scanner__Scanner_new_token(v__scanner__Scanner* s, v__token__Kind tok_kind, string lit, int len);
VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_name(v__scanner__Scanner* s);
VV_LOCAL_SYMBOL string v__scanner__filter_num_sep(byteptr txt, int start, int end);
VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_bin_number(v__scanner__Scanner* s);
VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_hex_number(v__scanner__Scanner* s);
VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_oct_number(v__scanner__Scanner* s);
VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_dec_number(v__scanner__Scanner* s);
VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_number(v__scanner__Scanner* s);
VV_LOCAL_SYMBOL void v__scanner__Scanner_skip_whitespace(v__scanner__Scanner* s);
VV_LOCAL_SYMBOL v__token__Token v__scanner__Scanner_end_of_file(v__scanner__Scanner* s);
void v__scanner__Scanner_scan_all_tokens_in_buffer(v__scanner__Scanner* s);
v__token__Token v__scanner__Scanner_scan(v__scanner__Scanner* s);
v__token__Token v__scanner__Scanner_buffer_scan(v__scanner__Scanner* s);
VV_LOCAL_SYMBOL byte v__scanner__Scanner_look_ahead(v__scanner__Scanner s, int n);
VV_LOCAL_SYMBOL v__token__Token v__scanner__Scanner_text_scan(v__scanner__Scanner* s);
VV_LOCAL_SYMBOL int v__scanner__Scanner_current_column(v__scanner__Scanner* s);
VV_LOCAL_SYMBOL int v__scanner__Scanner_count_symbol_before(v__scanner__Scanner* s, int p, byte sym);
VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_string(v__scanner__Scanner* s);
VV_LOCAL_SYMBOL string v__scanner__trim_slash_line_break(string s);
VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_char(v__scanner__Scanner* s);
VV_LOCAL_SYMBOL bool v__scanner__Scanner_expect(v__scanner__Scanner* s, string want, int start_pos);
VV_LOCAL_SYMBOL void v__scanner__Scanner_debug_tokens(v__scanner__Scanner* s);
VV_LOCAL_SYMBOL void v__scanner__Scanner_ignore_line(v__scanner__Scanner* s);
VV_LOCAL_SYMBOL void v__scanner__Scanner_eat_to_end_of_line(v__scanner__Scanner* s);
VV_LOCAL_SYMBOL void v__scanner__Scanner_inc_line_number(v__scanner__Scanner* s);
void v__scanner__Scanner_warn(v__scanner__Scanner* s, string msg);
void v__scanner__Scanner_error(v__scanner__Scanner* s, string msg);
VV_LOCAL_SYMBOL void v__scanner__Scanner_vet_error(v__scanner__Scanner* s, string msg);
void v__scanner__verror(string s);
void v__scanner__Scanner_codegen(v__scanner__Scanner* s, string newtext);
bool v__checker__Checker_check_basic(v__checker__Checker* c, v__table__Type got, v__table__Type expected);
bool v__checker__Checker_check_matching_function_symbols(v__checker__Checker* c, v__table__TypeSymbol* got_type_sym, v__table__TypeSymbol* exp_type_sym);
VV_LOCAL_SYMBOL v__table__Type v__checker__Checker_check_shift(v__checker__Checker* c, v__table__Type left_type, v__table__Type right_type, v__token__Position left_pos, v__token__Position right_pos);
v__table__Type v__checker__Checker_promote(v__checker__Checker* c, v__table__Type left_type, v__table__Type right_type);
VV_LOCAL_SYMBOL v__table__Type v__checker__Checker_promote_num(v__checker__Checker* c, v__table__Type left_type, v__table__Type right_type);
bool v__checker__Checker_check_types(v__checker__Checker* c, v__table__Type got, v__table__Type expected);
Option_void v__checker__Checker_check_expected(v__checker__Checker* c, v__table__Type got, v__table__Type expected);
bool v__checker__Checker_symmetric_check(v__checker__Checker* c, v__table__Type left, v__table__Type right);
byte v__checker__Checker_get_default_fmt(v__checker__Checker* c, v__table__Type ftyp, v__table__Type typ);
v__table__Type v__checker__Checker_string_inter_lit(v__checker__Checker* c, v__ast__StringInterLiteral* node);
bool v__checker__Checker_check_sumtype_compatibility(v__checker__Checker* c, v__table__Type a, v__table__Type b);
void v__checker__Checker_infer_fn_types(v__checker__Checker* c, v__table__Fn f, v__ast__CallExpr* call_expr);
#define _const_v__checker__max_nr_errors 300
#define _const_v__checker__match_exhaustive_cutoff_limit 10
int _const_v__checker__int_min; // inited later
#define _const_v__checker__int_max 0x7FFFFFFF
array_string _const_v__checker__valid_comp_if_os; // inited later
array_string _const_v__checker__valid_comp_if_compilers; // inited later
array_string _const_v__checker__valid_comp_if_platforms; // inited later
array_string _const_v__checker__valid_comp_if_other; // inited later
v__checker__Checker v__checker__new_checker(v__table__Table* table, v__pref__Preferences* pref);
void v__checker__Checker_check(v__checker__Checker* c, v__ast__File* ast_file);
void v__checker__Checker_check_scope_vars(v__checker__Checker* c, v__ast__Scope* sc);
array_v__errors__Error v__checker__Checker_check2(v__checker__Checker* c, v__ast__File* ast_file);
void v__checker__Checker_check_files(v__checker__Checker* c, array_v__ast__File ast_files);
string _const_v__checker__no_pub_in_main_warning; // a string literal, inited later
VV_LOCAL_SYMBOL bool v__checker__Checker_check_file_in_main(v__checker__Checker* c, v__ast__File file);
VV_LOCAL_SYMBOL void v__checker__Checker_check_valid_snake_case(v__checker__Checker* c, string name, string identifier, v__token__Position pos);
VV_LOCAL_SYMBOL string v__checker__stripped_name(string name);
VV_LOCAL_SYMBOL void v__checker__Checker_check_valid_pascal_case(v__checker__Checker* c, string name, string identifier, v__token__Position pos);
void v__checker__Checker_type_decl(v__checker__Checker* c, v__ast__TypeDecl node);
void v__checker__Checker_interface_decl(v__checker__Checker* c, v__ast__InterfaceDecl decl);
void v__checker__Checker_struct_decl(v__checker__Checker* c, v__ast__StructDecl decl);
v__table__Type v__checker__Checker_struct_init(v__checker__Checker* c, v__ast__StructInit* struct_init);
v__table__Type v__checker__Checker_infix_expr(v__checker__Checker* c, v__ast__InfixExpr* infix_expr);
VV_LOCAL_SYMBOL multi_return_string_v__token__Position v__checker__Checker_fail_if_immutable(v__checker__Checker* c, v__ast__Expr expr);
v__table__Type v__checker__Checker_call_expr(v__checker__Checker* c, v__ast__CallExpr* call_expr);
VV_LOCAL_SYMBOL void v__checker__Checker_check_map_and_filter(v__checker__Checker* c, bool is_map, v__table__Type elem_typ, v__ast__CallExpr call_expr);
v__table__Type v__checker__Checker_call_method(v__checker__Checker* c, v__ast__CallExpr* call_expr);
v__table__Type v__checker__Checker_call_fn(v__checker__Checker* c, v__ast__CallExpr* call_expr);
VV_LOCAL_SYMBOL bool v__checker__Checker_type_implements(v__checker__Checker* c, v__table__Type typ, v__table__Type inter_typ, v__token__Position pos);
v__table__Type v__checker__Checker_check_expr_opt_call(v__checker__Checker* c, v__ast__Expr expr, v__table__Type ret_type);
void v__checker__Checker_check_or_expr(v__checker__Checker* c, v__ast__OrExpr or_expr, v__table__Type ret_type, v__table__Type expr_return_type);
VV_LOCAL_SYMBOL bool v__checker__is_expr_panic_or_exit(v__ast__Expr expr);
v__table__Type v__checker__Checker_selector_expr(v__checker__Checker* c, v__ast__SelectorExpr* selector_expr);
void v__checker__Checker_return_stmt(v__checker__Checker* c, v__ast__Return* return_stmt);
void v__checker__Checker_const_decl(v__checker__Checker* c, v__ast__ConstDecl* node);
void v__checker__Checker_enum_decl(v__checker__Checker* c, v__ast__EnumDecl decl);
void v__checker__Checker_assign_stmt(v__checker__Checker* c, v__ast__AssignStmt* assign_stmt);
VV_LOCAL_SYMBOL void v__checker__scope_register_it(v__ast__Scope* s, v__token__Position pos, v__table__Type typ);
VV_LOCAL_SYMBOL void v__checker__scope_register_ab(v__ast__Scope* s, v__token__Position pos, v__table__Type typ);
VV_LOCAL_SYMBOL void v__checker__Checker_check_array_init_para_type(v__checker__Checker* c, string para, v__ast__Expr expr, v__token__Position pos);
v__table__Type v__checker__Checker_array_init(v__checker__Checker* c, v__ast__ArrayInit* array_init);
VV_LOCAL_SYMBOL Option_int v__checker__const_int_value(v__ast__ConstField cfield);
VV_LOCAL_SYMBOL Option_v__ast__IntegerLiteral v__checker__is_const_integer(v__ast__ConstField cfield);
VV_LOCAL_SYMBOL void v__checker__Checker_check_loop_label(v__checker__Checker* c, string label, v__token__Position pos);
VV_LOCAL_SYMBOL void v__checker__Checker_stmt(v__checker__Checker* c, v__ast__Stmt node);
VV_LOCAL_SYMBOL void v__checker__Checker_hash_stmt(v__checker__Checker* c, v__ast__HashStmt* node);
VV_LOCAL_SYMBOL void v__checker__Checker_import_stmt(v__checker__Checker* c, v__ast__Import imp);
VV_LOCAL_SYMBOL void v__checker__Checker_stmts(v__checker__Checker* c, array_v__ast__Stmt stmts);
v__table__Type v__checker__Checker_unwrap_generic(v__checker__Checker* c, v__table__Type typ);
v__table__Type v__checker__Checker_expr(v__checker__Checker* c, v__ast__Expr node);
v__table__Type v__checker__Checker_cast_expr(v__checker__Checker* c, v__ast__CastExpr* node);
VV_LOCAL_SYMBOL v__table__Type v__checker__Checker_at_expr(v__checker__Checker* c, v__ast__AtExpr* node);
v__table__Type v__checker__Checker_ident(v__checker__Checker* c, v__ast__Ident* ident);
v__table__Type v__checker__Checker_concat_expr(v__checker__Checker* c, v__ast__ConcatExpr* concat_expr);
v__table__Type v__checker__Checker_match_expr(v__checker__Checker* c, v__ast__MatchExpr* node);
VV_LOCAL_SYMBOL void v__checker__Checker_match_exprs(v__checker__Checker* c, v__ast__MatchExpr* node, v__table__TypeSymbol type_sym);
v__table__Type v__checker__Checker_select_expr(v__checker__Checker* c, v__ast__SelectExpr* node);
v__table__Type v__checker__Checker_lock_expr(v__checker__Checker* c, v__ast__LockExpr* node);
v__table__Type v__checker__Checker_unsafe_expr(v__checker__Checker* c, v__ast__UnsafeExpr* node);
v__table__Type v__checker__Checker_if_expr(v__checker__Checker* c, v__ast__IfExpr* node);
VV_LOCAL_SYMBOL bool v__checker__Checker_comp_if_branch(v__checker__Checker* c, v__ast__Expr cond, v__token__Position pos);
VV_LOCAL_SYMBOL Option_bool v__checker__Checker_has_return(v__checker__Checker* c, array_v__ast__Stmt stmts);
v__table__Type v__checker__Checker_postfix_expr(v__checker__Checker* c, v__ast__PostfixExpr* node);
VV_LOCAL_SYMBOL void v__checker__Checker_check_index_type(v__checker__Checker* c, v__table__TypeSymbol* typ_sym, v__table__Type index_type, v__token__Position pos);
v__table__Type v__checker__Checker_index_expr(v__checker__Checker* c, v__ast__IndexExpr* node);
v__table__Type v__checker__Checker_enum_val(v__checker__Checker* c, v__ast__EnumVal* node);
v__table__Type v__checker__Checker_chan_init(v__checker__Checker* c, v__ast__ChanInit* node);
v__table__Type v__checker__Checker_map_init(v__checker__Checker* c, v__ast__MapInit* node);
void v__checker__Checker_add_error_detail(v__checker__Checker* c, string s);
void v__checker__Checker_warn(v__checker__Checker* c, string s, v__token__Position pos);
void v__checker__Checker_error(v__checker__Checker* c, string message, v__token__Position pos);
VV_LOCAL_SYMBOL bool v__checker__Checker_check_struct_signature(v__checker__Checker c, v__table__Struct from, v__table__Struct to);
VV_LOCAL_SYMBOL void v__checker__Checker_warn_or_error(v__checker__Checker* c, string message, v__token__Position pos, bool warn);
VV_LOCAL_SYMBOL bool v__checker__Checker_fileis(v__checker__Checker* c, string s);
VV_LOCAL_SYMBOL v__table__Type v__checker__Checker_sql_expr(v__checker__Checker* c, v__ast__SqlExpr* node);
VV_LOCAL_SYMBOL v__table__Type v__checker__Checker_sql_stmt(v__checker__Checker* c, v__ast__SqlStmt* node);
VV_LOCAL_SYMBOL array_v__table__Field v__checker__Checker_fetch_and_verify_orm_fields(v__checker__Checker* c, v__table__Struct info, v__token__Position pos, string table_name);
VV_LOCAL_SYMBOL void v__checker__Checker_post_process_generic_fns(v__checker__Checker* c);
VV_LOCAL_SYMBOL void v__checker__Checker_fn_decl(v__checker__Checker* c, v__ast__FnDecl* node);
VV_LOCAL_SYMBOL bool v__checker__has_top_return(array_v__ast__Stmt stmts);
VV_LOCAL_SYMBOL multi_return_bool_int_int v__checker__Checker_verify_vweb_params_for_method(v__checker__Checker* c, v__table__Fn m);
VV_LOCAL_SYMBOL void v__checker__Checker_verify_all_vweb_routes(v__checker__Checker* c);
VV_LOCAL_SYMBOL v__ast__Stmt v__parser__Parser_assign_stmt(v__parser__Parser* p);
VV_LOCAL_SYMBOL void v__parser__Parser_check_undefined_variables(v__parser__Parser* p, array_v__ast__Expr exprs, v__ast__Expr val);
VV_LOCAL_SYMBOL bool v__parser__Parser_check_cross_variables(v__parser__Parser* p, array_v__ast__Expr exprs, v__ast__Expr val);
VV_LOCAL_SYMBOL v__ast__Stmt v__parser__Parser_partial_assign_stmt(v__parser__Parser* p, array_v__ast__Expr left, array_v__ast__Comment left_comments);
array_string _const_v__parser__supported_platforms; // inited later
array_string _const_v__parser__supported_ccompilers; // inited later
VV_LOCAL_SYMBOL v__ast__HashStmt v__parser__Parser_hash(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__ComptimeCall v__parser__Parser_vweb(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__CompFor v__parser__Parser_comp_for(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__AtExpr v__parser__Parser_at(v__parser__Parser* p);
v__pref__OS _const_v__parser__todo_delete_me; // inited later
VV_LOCAL_SYMBOL v__pref__OS v__parser__os_from_string(string os);
VV_LOCAL_SYMBOL v__ast__ComptimeCall v__parser__Parser_comptime_method_call(v__parser__Parser* p, v__ast__Expr left);
VV_LOCAL_SYMBOL v__ast__ArrayInit v__parser__Parser_array_init(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__MapInit v__parser__Parser_map_init(v__parser__Parser* p);
v__ast__CallExpr v__parser__Parser_call_expr(v__parser__Parser* p, v__table__Language language, string mod);
array_v__ast__CallArg v__parser__Parser_call_args(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__FnDecl v__parser__Parser_fn_decl(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__AnonFn v__parser__Parser_anon_fn(v__parser__Parser* p);
VV_LOCAL_SYMBOL multi_return_array_v__table__Param_bool_bool v__parser__Parser_fn_args(v__parser__Parser* p);
VV_LOCAL_SYMBOL void v__parser__Parser_check_fn_mutable_arguments(v__parser__Parser* p, v__table__Type typ, v__token__Position pos);
VV_LOCAL_SYMBOL void v__parser__Parser_check_fn_shared_arguments(v__parser__Parser* p, v__table__Type typ, v__token__Position pos);
VV_LOCAL_SYMBOL void v__parser__Parser_check_fn_atomic_arguments(v__parser__Parser* p, v__table__Type typ, v__token__Position pos);
VV_LOCAL_SYMBOL void v__parser__Parser_fn_redefinition_error(v__parser__Parser* p, string name);
VV_LOCAL_SYMBOL bool v__parser__have_fn_main(array_v__ast__Stmt stmts);
VV_LOCAL_SYMBOL v__ast__Stmt v__parser__Parser_for_stmt(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__IfExpr v__parser__Parser_if_expr(v__parser__Parser* p, bool is_comptime);
VV_LOCAL_SYMBOL v__ast__MatchExpr v__parser__Parser_match_expr(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__SelectExpr v__parser__Parser_select_expr(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__LockExpr v__parser__Parser_lock_expr(v__parser__Parser* p);
bool v__parser__Parser_known_import(v__parser__Parser* p, string mod);
VV_LOCAL_SYMBOL string v__parser__Parser_prepend_mod(v__parser__Parser* p, string name);
VV_LOCAL_SYMBOL bool v__parser__Parser_is_used_import(v__parser__Parser* p, string alias);
VV_LOCAL_SYMBOL void v__parser__Parser_register_used_import(v__parser__Parser* p, string alias);
VV_LOCAL_SYMBOL void v__parser__Parser_register_auto_import(v__parser__Parser* p, string alias);
VV_LOCAL_SYMBOL void v__parser__Parser_check_unused_imports(v__parser__Parser* p);
v__table__Type v__parser__Parser_parse_array_type(v__parser__Parser* p);
v__table__Type v__parser__Parser_parse_map_type(v__parser__Parser* p);
v__table__Type v__parser__Parser_parse_chan_type(v__parser__Parser* p);
v__table__Type v__parser__Parser_parse_multi_return_type(v__parser__Parser* p);
v__table__Type v__parser__Parser_parse_fn_type(v__parser__Parser* p, string name);
v__table__Type v__parser__Parser_parse_type_with_mut(v__parser__Parser* p, bool is_mut);
v__table__Language v__parser__Parser_parse_language(v__parser__Parser* p);
v__table__Type v__parser__Parser_parse_type(v__parser__Parser* p);
v__table__Type v__parser__Parser_parse_any_type(v__parser__Parser* p, v__table__Language language, bool is_ptr, bool check_dot);
v__table__Type v__parser__Parser_parse_enum_or_struct_type(v__parser__Parser* p, string name, v__table__Language language);
v__table__Type v__parser__Parser_parse_generic_template_type(v__parser__Parser* p, string name);
v__table__Type v__parser__Parser_parse_generic_struct_inst_type(v__parser__Parser* p, string name);
v__ast__Stmt v__parser__parse_stmt(string text, v__table__Table* table, v__ast__Scope* scope);
v__ast__File v__parser__parse_text(string text, v__table__Table* b_table, v__pref__Preferences* pref, v__ast__Scope* scope, v__ast__Scope* global_scope);
v__ast__File v__parser__parse_file(string path, v__table__Table* b_table, v__scanner__CommentsMode comments_mode, v__pref__Preferences* pref, v__ast__Scope* global_scope);
multi_return_v__ast__File_array_string v__parser__parse_vet_file(string path, v__table__Table* table_, v__pref__Preferences* pref);
v__ast__File v__parser__Parser_parse(v__parser__Parser* p);
array_v__ast__File v__parser__parse_files(array_string paths, v__table__Table* table, v__pref__Preferences* pref, v__ast__Scope* global_scope);
void v__parser__Parser_init_parse_fns(v__parser__Parser* p);
void v__parser__Parser_read_first_token(v__parser__Parser* p);
void v__parser__Parser_open_scope(v__parser__Parser* p);
void v__parser__Parser_close_scope(v__parser__Parser* p);
array_v__ast__Stmt v__parser__Parser_parse_block(v__parser__Parser* p);
array_v__ast__Stmt v__parser__Parser_parse_block_no_scope(v__parser__Parser* p, bool is_top_level);
VV_LOCAL_SYMBOL void v__parser__Parser_next(v__parser__Parser* p);
VV_LOCAL_SYMBOL void v__parser__Parser_check(v__parser__Parser* p, v__token__Kind expected);
VV_LOCAL_SYMBOL string v__parser__Parser_check_js_name(v__parser__Parser* p);
VV_LOCAL_SYMBOL string v__parser__Parser_check_name(v__parser__Parser* p);
v__ast__Stmt v__parser__Parser_top_stmt(v__parser__Parser* p);
v__ast__Comment v__parser__Parser_check_comment(v__parser__Parser* p);
v__ast__Comment v__parser__Parser_comment(v__parser__Parser* p);
v__ast__ExprStmt v__parser__Parser_comment_stmt(v__parser__Parser* p);
array_v__ast__Comment v__parser__Parser_eat_comments(v__parser__Parser* p);
array_v__ast__Comment v__parser__Parser_eat_lineend_comments(v__parser__Parser* p);
v__ast__Stmt v__parser__Parser_stmt(v__parser__Parser* p, bool is_top_level);
VV_LOCAL_SYMBOL multi_return_array_v__ast__Expr_array_v__ast__Comment v__parser__Parser_expr_list(v__parser__Parser* p);
VV_LOCAL_SYMBOL void v__parser__Parser_attributes(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__table__Attr v__parser__Parser_parse_attr(v__parser__Parser* p);
void v__parser__Parser_error(v__parser__Parser* p, string s);
void v__parser__Parser_warn(v__parser__Parser* p, string s);
void v__parser__Parser_error_with_pos(v__parser__Parser* p, string s, v__token__Position pos);
void v__parser__Parser_warn_with_pos(v__parser__Parser* p, string s, v__token__Position pos);
void v__parser__Parser_vet_error(v__parser__Parser* p, string s, int line);
VV_LOCAL_SYMBOL v__ast__Stmt v__parser__Parser_parse_multi_expr(v__parser__Parser* p, bool is_top_level);
v__ast__Ident v__parser__Parser_parse_ident(v__parser__Parser* p, v__table__Language language);
v__ast__Expr v__parser__Parser_name_expr(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__IndexExpr v__parser__Parser_index_expr(v__parser__Parser* p, v__ast__Expr left);
VV_LOCAL_SYMBOL void v__parser__Parser_scope_register_it(v__parser__Parser* p);
VV_LOCAL_SYMBOL void v__parser__Parser_scope_register_ab(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__Expr v__parser__Parser_dot_expr(v__parser__Parser* p, v__ast__Expr left);
VV_LOCAL_SYMBOL v__ast__EnumVal v__parser__Parser_enum_val(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__Expr v__parser__Parser_string_expr(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__Expr v__parser__Parser_parse_number_literal(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__Module v__parser__Parser_module_decl(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__Import v__parser__Parser_import_stmt(v__parser__Parser* p);
VV_LOCAL_SYMBOL void v__parser__Parser_import_syms(v__parser__Parser* p, v__ast__Import* parent);
VV_LOCAL_SYMBOL v__ast__ConstDecl v__parser__Parser_const_decl(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__Return v__parser__Parser_return_stmt(v__parser__Parser* p);
array_string _const_v__parser__global_enabled_mods; // inited later
VV_LOCAL_SYMBOL v__ast__GlobalDecl v__parser__Parser_global_decl(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__EnumDecl v__parser__Parser_enum_decl(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__TypeDecl v__parser__Parser_type_decl(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__Assoc v__parser__Parser_assoc(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__Expr v__parser__Parser_new_true_expr(v__parser__Parser* p);
VV_LOCAL_SYMBOL void v__parser__verror(string s);
VV_LOCAL_SYMBOL void v__parser__Parser_top_level_statement_start(v__parser__Parser* p);
VV_LOCAL_SYMBOL void v__parser__Parser_top_level_statement_end(v__parser__Parser* p);
VV_LOCAL_SYMBOL void v__parser__Parser_rewind_scanner_to_current_token_in_new_mode(v__parser__Parser* p);
bool v__parser__Parser_mark_var_as_used(v__parser__Parser* p, string varname);
VV_LOCAL_SYMBOL v__ast__Stmt v__parser__Parser_unsafe_stmt(v__parser__Parser* p);
VV_LOCAL_SYMBOL void v__parser__Parser_trace(v__parser__Parser* p, string fbase, string message);
v__ast__Expr v__parser__Parser_expr(v__parser__Parser* p, int precedence);
v__ast__Expr v__parser__Parser_expr_with_left(v__parser__Parser* p, v__ast__Expr left, int precedence, bool is_stmt_ident);
VV_LOCAL_SYMBOL v__ast__Expr v__parser__Parser_infix_expr(v__parser__Parser* p, v__ast__Expr left);
VV_LOCAL_SYMBOL v__ast__PrefixExpr v__parser__Parser_prefix_expr(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__Expr v__parser__Parser_sql_expr(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__SqlStmt v__parser__Parser_sql_stmt(v__parser__Parser* p);
VV_LOCAL_SYMBOL void v__parser__Parser_check_sql_keyword(v__parser__Parser* p, string name);
VV_LOCAL_SYMBOL v__ast__StructDecl v__parser__Parser_struct_decl(v__parser__Parser* p);
VV_LOCAL_SYMBOL v__ast__StructInit v__parser__Parser_struct_init(v__parser__Parser* p, bool short_syntax);
VV_LOCAL_SYMBOL v__ast__InterfaceDecl v__parser__Parser_interface_decl(v__parser__Parser* p);
VV_LOCAL_SYMBOL string v__gen__Gen_gen_str_for_type_with_styp(v__gen__Gen* g, v__table__Type typ, string styp);
VV_LOCAL_SYMBOL void v__gen__Gen_gen_str_for_alias(v__gen__Gen* g, v__table__Alias info, string styp, string str_fn_name);
VV_LOCAL_SYMBOL void v__gen__Gen_gen_str_for_array(v__gen__Gen* g, v__table__Array info, string styp, string str_fn_name);
VV_LOCAL_SYMBOL void v__gen__Gen_gen_str_for_array_fixed(v__gen__Gen* g, v__table__ArrayFixed info, string styp, string str_fn_name);
VV_LOCAL_SYMBOL void v__gen__Gen_gen_str_for_map(v__gen__Gen* g, v__table__Map info, string styp, string str_fn_name);
VV_LOCAL_SYMBOL void v__gen__Gen_gen_str_for_varg(v__gen__Gen* g, string styp, string str_fn_name, bool has_str_method);
VV_LOCAL_SYMBOL void v__gen__Gen_gen_str_for_multi_return(v__gen__Gen* g, v__table__MultiReturn info, string styp, string str_fn_name);
VV_LOCAL_SYMBOL void v__gen__Gen_gen_str_for_struct(v__gen__Gen* g, v__table__Struct info, string styp, string str_fn_name);
VV_LOCAL_SYMBOL string v__gen__struct_auto_str_func(v__table__TypeSymbol sym, v__table__Type field_type, string fn_name, string field_name);
VV_LOCAL_SYMBOL void v__gen__Gen_gen_str_for_enum(v__gen__Gen* g, v__table__Enum info, string styp, string str_fn_name);
VV_LOCAL_SYMBOL void v__gen__Gen_gen_str_for_union_sum_type(v__gen__Gen* g, v__table__SumType info, string styp, string str_fn_name);
array_string _const_v__gen__c_reserved; // inited later
array_string _const_v__gen__cmp_str; // inited later
array_string _const_v__gen__cmp_rev; // inited later
array_string _const_v__gen__tabs; // inited later
string v__gen__cgen(array_v__ast__File files, v__table__Table* table, v__pref__Preferences* pref);
string v__gen__Gen_hashes(v__gen__Gen* g);
void v__gen__Gen_init(v__gen__Gen* g);
void v__gen__Gen_finish(v__gen__Gen* g);
void v__gen__Gen_write_typeof_functions(v__gen__Gen* g);
VV_LOCAL_SYMBOL string v__gen__Gen_typ(v__gen__Gen* g, v__table__Type t);
VV_LOCAL_SYMBOL string v__gen__Gen_base_type(v__gen__Gen* g, v__table__Type t);
VV_LOCAL_SYMBOL multi_return_string_string v__gen__Gen_optional_type_name(v__gen__Gen* g, v__table__Type t);
VV_LOCAL_SYMBOL string v__gen__Gen_optional_type_text(v__gen__Gen* g, string styp, string base);
VV_LOCAL_SYMBOL string v__gen__Gen_register_optional(v__gen__Gen* g, v__table__Type t);
VV_LOCAL_SYMBOL string v__gen__Gen_find_or_register_shared(v__gen__Gen* g, v__table__Type t, string base);
VV_LOCAL_SYMBOL void v__gen__Gen_register_chan_pop_optional_call(v__gen__Gen* g, string opt_el_type, string styp);
VV_LOCAL_SYMBOL string v__gen__Gen_cc_type2(v__gen__Gen* g, v__table__Type t);
VV_LOCAL_SYMBOL string v__gen__Gen_cc_type(v__gen__Gen* g, v__table__Type t);
void v__gen__Gen_write_typedef_types(v__gen__Gen* g);
void v__gen__Gen_write_fn_typesymbol_declaration(v__gen__Gen* g, v__table__TypeSymbol sym);
void v__gen__Gen_write_multi_return_type_declaration(v__gen__Gen* g, v__table__TypeSymbol* sym);
void v__gen__Gen_write_multi_return_types(v__gen__Gen* g);
void v__gen__Gen_write_variadic_types(v__gen__Gen* g);
void v__gen__Gen_write(v__gen__Gen* g, string s);
void v__gen__Gen_writeln(v__gen__Gen* g, string s);
string v__gen__Gen_new_tmp_var(v__gen__Gen* g);
void v__gen__Gen_reset_tmp_count(v__gen__Gen* g);
VV_LOCAL_SYMBOL void v__gen__Gen_decrement_inside_ternary(v__gen__Gen* g);
VV_LOCAL_SYMBOL void v__gen__Gen_stmts(v__gen__Gen* g, array_v__ast__Stmt stmts);
VV_LOCAL_SYMBOL void v__gen__Gen_stmts_with_tmp_var(v__gen__Gen* g, array_v__ast__Stmt stmts, string tmp_var);
VV_LOCAL_SYMBOL void v__gen__Gen_write_v_source_line_info(v__gen__Gen* g, v__token__Position pos);
VV_LOCAL_SYMBOL void v__gen__Gen_stmt(v__gen__Gen* g, v__ast__Stmt node);
VV_LOCAL_SYMBOL void v__gen__Gen_write_defer_stmts(v__gen__Gen* g);
VV_LOCAL_SYMBOL void v__gen__Gen_for_in(v__gen__Gen* g, v__ast__ForInStmt it);
VV_LOCAL_SYMBOL void v__gen__Gen_expr_with_cast(v__gen__Gen* g, v__ast__Expr expr, v__table__Type got_type, v__table__Type expected_type);
VV_LOCAL_SYMBOL string v__gen__cestring(string s);
VV_LOCAL_SYMBOL string v__gen__ctoslit(string s);
VV_LOCAL_SYMBOL void v__gen__Gen_gen_attrs(v__gen__Gen* g, array_v__table__Attr attrs);
VV_LOCAL_SYMBOL void v__gen__Gen_gen_assert_stmt(v__gen__Gen* g, v__ast__AssertStmt original_assert_statement);
VV_LOCAL_SYMBOL string v__gen__cnewlines(string s);
VV_LOCAL_SYMBOL string v__gen__Gen_gen_assert_metainfo(v__gen__Gen* g, v__ast__AssertStmt a);
VV_LOCAL_SYMBOL void v__gen__Gen_gen_assert_single_expr(v__gen__Gen* g, v__ast__Expr e, v__table__Type t);
VV_LOCAL_SYMBOL void v__gen__Gen_write_fn_ptr_decl(v__gen__Gen* g, v__table__FnType* func, string ptr_name);
VV_LOCAL_SYMBOL void v__gen__Gen_gen_assign_stmt(v__gen__Gen* g, v__ast__AssignStmt assign_stmt);
VV_LOCAL_SYMBOL void v__gen__Gen_gen_cross_tmp_variable(v__gen__Gen* g, array_v__ast__Expr left, v__ast__Expr val);
VV_LOCAL_SYMBOL void v__gen__Gen_register_ternary_name(v__gen__Gen* g, string name);
VV_LOCAL_SYMBOL string v__gen__Gen_get_ternary_name(v__gen__Gen* g, string name);
VV_LOCAL_SYMBOL bool v__gen__Gen_gen_clone_assignment(v__gen__Gen* g, v__ast__Expr val, v__table__TypeSymbol right_sym, bool add_eq);
VV_LOCAL_SYMBOL void v__gen__Gen_autofree_scope_vars(v__gen__Gen* g, int pos, int line_nr, bool free_parent_scopes);
VV_LOCAL_SYMBOL void v__gen__Gen_autofree_scope_vars2(v__gen__Gen* g, v__ast__Scope* scope, int start_pos, int end_pos, int line_nr, bool free_parent_scopes);
VV_LOCAL_SYMBOL void v__gen__Gen_autofree_variable(v__gen__Gen* g, v__ast__Var v);
VV_LOCAL_SYMBOL void v__gen__Gen_autofree_var_call(v__gen__Gen* g, string free_fn_name, v__ast__Var v);
VV_LOCAL_SYMBOL void v__gen__Gen_gen_anon_fn_decl(v__gen__Gen* g, v__ast__AnonFn it);
VV_LOCAL_SYMBOL void v__gen__Gen_expr(v__gen__Gen* g, v__ast__Expr node);
VV_LOCAL_SYMBOL void v__gen__Gen_type_name(v__gen__Gen* g, v__table__Type type_);
VV_LOCAL_SYMBOL void v__gen__Gen_typeof_expr(v__gen__Gen* g, v__ast__TypeOf node);
VV_LOCAL_SYMBOL void v__gen__Gen_enum_expr(v__gen__Gen* g, v__ast__Expr node);
VV_LOCAL_SYMBOL void v__gen__Gen_infix_expr(v__gen__Gen* g, v__ast__InfixExpr node);
VV_LOCAL_SYMBOL void v__gen__Gen_lock_expr(v__gen__Gen* g, v__ast__LockExpr node);
VV_LOCAL_SYMBOL void v__gen__Gen_match_expr(v__gen__Gen* g, v__ast__MatchExpr node);
VV_LOCAL_SYMBOL void v__gen__Gen_match_expr_sumtype(v__gen__Gen* g, v__ast__MatchExpr node, bool is_expr, string cond_var);
VV_LOCAL_SYMBOL void v__gen__Gen_match_expr_classic(v__gen__Gen* g, v__ast__MatchExpr node, bool is_expr, string cond_var);
VV_LOCAL_SYMBOL void v__gen__Gen_select_expr(v__gen__Gen* g, v__ast__SelectExpr node);
VV_LOCAL_SYMBOL void v__gen__Gen_ident(v__gen__Gen* g, v__ast__Ident node);
VV_LOCAL_SYMBOL void v__gen__Gen_concat_expr(v__gen__Gen* g, v__ast__ConcatExpr node);
VV_LOCAL_SYMBOL void v__gen__Gen_if_expr(v__gen__Gen* g, v__ast__IfExpr node);
VV_LOCAL_SYMBOL void v__gen__Gen_index_expr(v__gen__Gen* g, v__ast__IndexExpr node);
VV_LOCAL_SYMBOL bool v__gen__Gen_expr_is_multi_return_call(v__gen__Gen* g, v__ast__Expr expr);
VV_LOCAL_SYMBOL void v__gen__Gen_return_statement(v__gen__Gen* g, v__ast__Return node);
VV_LOCAL_SYMBOL void v__gen__Gen_const_decl(v__gen__Gen* g, v__ast__ConstDecl node);
VV_LOCAL_SYMBOL void v__gen__Gen_const_decl_simple_define(v__gen__Gen* g, string name, string val);
VV_LOCAL_SYMBOL void v__gen__Gen_const_decl_init_later(v__gen__Gen* g, string mod, string name, string val, v__table__Type typ);
VV_LOCAL_SYMBOL void v__gen__Gen_global_decl(v__gen__Gen* g, v__ast__GlobalDecl node);
VV_LOCAL_SYMBOL void v__gen__Gen_go_back_out(v__gen__Gen* g, int n);
array_string _const_v__gen__skip_struct_init; // inited later
VV_LOCAL_SYMBOL void v__gen__Gen_struct_init(v__gen__Gen* g, v__ast__StructInit struct_init);
VV_LOCAL_SYMBOL void v__gen__Gen_zero_struct_field(v__gen__Gen* g, v__table__Field field);
VV_LOCAL_SYMBOL void v__gen__Gen_assoc(v__gen__Gen* g, v__ast__Assoc node);
VV_LOCAL_SYMBOL string v__gen__Gen_gen_array_equality_fn(v__gen__Gen* g, v__table__Type left);
VV_LOCAL_SYMBOL string v__gen__Gen_gen_map_equality_fn(v__gen__Gen* g, v__table__Type left);
VV_LOCAL_SYMBOL void v__gen__verror(string s);
VV_LOCAL_SYMBOL void v__gen__Gen_error(v__gen__Gen* g, string s, v__token__Position pos);
VV_LOCAL_SYMBOL void v__gen__Gen_checker_bug(v__gen__Gen* g, string s, v__token__Position pos);
VV_LOCAL_SYMBOL void v__gen__Gen_write_init_function(v__gen__Gen* g);
array_string _const_v__gen__builtins; // inited later
VV_LOCAL_SYMBOL void v__gen__Gen_write_builtin_types(v__gen__Gen* g);
VV_LOCAL_SYMBOL void v__gen__Gen_write_sorted_types(v__gen__Gen* g);
VV_LOCAL_SYMBOL void v__gen__Gen_write_types(v__gen__Gen* g, array_v__table__TypeSymbol types);
VV_LOCAL_SYMBOL array_v__table__TypeSymbol v__gen__Gen_sort_structs(v__gen__Gen* g, array_v__table__TypeSymbol typesa);
VV_LOCAL_SYMBOL Option_bool v__gen__Gen_gen_expr_to_string(v__gen__Gen* g, v__ast__Expr expr, v__table__Type etype);
VV_LOCAL_SYMBOL void v__gen__Gen_gen_array_map(v__gen__Gen* g, v__ast__CallExpr node);
VV_LOCAL_SYMBOL void v__gen__Gen_gen_array_sort(v__gen__Gen* g, v__ast__CallExpr node);
VV_LOCAL_SYMBOL void v__gen__Gen_gen_array_filter(v__gen__Gen* g, v__ast__CallExpr node);
VV_LOCAL_SYMBOL void v__gen__Gen_gen_array_insert(v__gen__Gen* g, v__ast__CallExpr node);
VV_LOCAL_SYMBOL void v__gen__Gen_gen_array_prepend(v__gen__Gen* g, v__ast__CallExpr node);
VV_LOCAL_SYMBOL int v__gen__Gen_nth_stmt_pos(v__gen__Gen* g, int n);
VV_LOCAL_SYMBOL string v__gen__Gen_go_before_stmt(v__gen__Gen* g, int n);
VV_LOCAL_SYMBOL string v__gen__Gen_go_before_ternary(v__gen__Gen* g);
VV_LOCAL_SYMBOL void v__gen__Gen_insert_before_stmt(v__gen__Gen* g, string s);
VV_LOCAL_SYMBOL string v__gen__Gen_write_expr_to_string(v__gen__Gen* g, v__ast__Expr expr);
VV_LOCAL_SYMBOL void v__gen__Gen_or_block(v__gen__Gen* g, string var_name, v__ast__OrExpr or_block, v__table__Type return_type);
VV_LOCAL_SYMBOL string v__gen__Gen_type_of_call_expr(v__gen__Gen* g, v__ast__Expr node);
VV_LOCAL_SYMBOL void v__gen__Gen_in_optimization(v__gen__Gen* g, v__ast__Expr left, v__ast__ArrayInit right);
VV_LOCAL_SYMBOL string v__gen__op_to_fn_name(string name);
VV_LOCAL_SYMBOL string v__gen__Gen_comp_if_to_ifdef(v__gen__Gen* g, string name, bool is_comptime_optional);
VV_LOCAL_SYMBOL string v__gen__c_name(string name_);
VV_LOCAL_SYMBOL string v__gen__Gen_type_default(v__gen__Gen* g, v__table__Type typ_);
VV_LOCAL_SYMBOL array_string v__gen__Gen_get_all_test_function_names(v__gen__Gen* g);
VV_LOCAL_SYMBOL bool v__gen__Gen_is_importing_os(v__gen__Gen* g);
VV_LOCAL_SYMBOL void v__gen__Gen_go_stmt(v__gen__Gen* g, v__ast__GoStmt node);
VV_LOCAL_SYMBOL void v__gen__Gen_as_cast(v__gen__Gen* g, v__ast__AsCast node);
VV_LOCAL_SYMBOL void v__gen__Gen_is_expr(v__gen__Gen* g, v__ast__InfixExpr node);
VV_LOCAL_SYMBOL string v__gen__styp_to_str_fn_name(string styp);
VV_LOCAL_SYMBOL string v__gen__Gen_gen_str_for_type(v__gen__Gen* g, v__table__Type typ);
VV_LOCAL_SYMBOL void v__gen__Gen_gen_str_default(v__gen__Gen* g, v__table__TypeSymbol sym, string styp, string str_fn_name);
VV_LOCAL_SYMBOL string v__gen__Gen_type_to_fmt(v__gen__Gen* g, v__table__Type typ);
VV_LOCAL_SYMBOL string v__gen__Gen_interface_table(v__gen__Gen* g);
VV_LOCAL_SYMBOL void v__gen__Gen_array_init(v__gen__Gen* g, v__ast__ArrayInit it);
VV_LOCAL_SYMBOL void v__gen__Gen_interface_call(v__gen__Gen* g, v__table__Type typ, v__table__Type interface_type);
VV_LOCAL_SYMBOL multi_return_int_string_string_string v__gen__Gen_panic_debug_info(v__gen__Gen* g, v__token__Position pos);
string v__gen__get_guarded_include_text(string iname, string imessage);
string _const_v__gen__c_commit_hash_default; // a string literal, inited later
string _const_v__gen__c_current_commit_hash_default; // a string literal, inited later
string _const_v__gen__c_common_macros; // a string literal, inited later
string _const_v__gen__c_headers; // inited later
string _const_v__gen__c_builtin_types; // a string literal, inited later
string _const_v__gen__bare_c_headers; // inited later
void v__gen__Gen_gen_c_main(v__gen__Gen* g);
VV_LOCAL_SYMBOL void v__gen__Gen_gen_vlines_reset(v__gen__Gen* g);
VV_LOCAL_SYMBOL void v__gen__Gen_gen_c_main_header(v__gen__Gen* g);
void v__gen__Gen_gen_c_main_footer(v__gen__Gen* g);
void v__gen__Gen_gen_c_android_sokol_main(v__gen__Gen* g);
void v__gen__Gen_write_tests_main(v__gen__Gen* g);
VV_LOCAL_SYMBOL void v__gen__Gen_comptime_call(v__gen__Gen* g, v__ast__ComptimeCall node);
VV_LOCAL_SYMBOL array_string v__gen__cgen_attrs(array_v__table__Attr attrs);
VV_LOCAL_SYMBOL void v__gen__Gen_comp_at(v__gen__Gen* g, v__ast__AtExpr node);
VV_LOCAL_SYMBOL void v__gen__Gen_comp_if(v__gen__Gen* g, v__ast__IfExpr node);
VV_LOCAL_SYMBOL void v__gen__Gen_comp_if_expr(v__gen__Gen* g, v__ast__Expr cond);
VV_LOCAL_SYMBOL void v__gen__Gen_comp_for(v__gen__Gen* g, v__ast__CompFor node);
VV_LOCAL_SYMBOL v__ast__CTempVar v__gen__Gen_new_ctemp_var(v__gen__Gen* g, v__ast__Expr expr, v__table__Type expr_type);
VV_LOCAL_SYMBOL v__ast__CTempVar v__gen__Gen_new_ctemp_var_then_gen(v__gen__Gen* g, v__ast__Expr expr, v__table__Type expr_type);
VV_LOCAL_SYMBOL void v__gen__Gen_gen_ctemp_var(v__gen__Gen* g, v__ast__CTempVar tvar);
VV_LOCAL_SYMBOL void v__gen__Gen_gen_fn_decl(v__gen__Gen* g, v__ast__FnDecl it, bool skip);
VV_LOCAL_SYMBOL void v__gen__Gen_write_defer_stmts_when_needed(v__gen__Gen* g);
VV_LOCAL_SYMBOL multi_return_array_string_array_string v__gen__Gen_fn_args(v__gen__Gen* g, array_v__table__Param args, bool is_variadic);
VV_LOCAL_SYMBOL void v__gen__Gen_call_expr(v__gen__Gen* g, v__ast__CallExpr node);
v__table__Type v__gen__Gen_unwrap_generic(v__gen__Gen* g, v__table__Type typ);
VV_LOCAL_SYMBOL void v__gen__Gen_method_call(v__gen__Gen* g, v__ast__CallExpr node);
VV_LOCAL_SYMBOL void v__gen__Gen_fn_call(v__gen__Gen* g, v__ast__CallExpr node);
VV_LOCAL_SYMBOL void v__gen__Gen_autofree_call_pregen(v__gen__Gen* g, v__ast__CallExpr node);
VV_LOCAL_SYMBOL void v__gen__Gen_autofree_call_postgen(v__gen__Gen* g, int node_pos);
VV_LOCAL_SYMBOL void v__gen__Gen_call_args(v__gen__Gen* g, v__ast__CallExpr node);
VV_LOCAL_SYMBOL void v__gen__Gen_ref_or_deref_arg(v__gen__Gen* g, v__ast__CallArg arg, v__table__Type expected_type);
VV_LOCAL_SYMBOL bool v__gen__Gen_is_gui_app(v__gen__Gen* g);
VV_LOCAL_SYMBOL bool v__gen__Gen_fileis(v__gen__Gen* g, string s);
VV_LOCAL_SYMBOL string v__gen__Gen_write_fn_attrs(v__gen__Gen* g, array_v__table__Attr attrs);
VV_LOCAL_SYMBOL void v__gen__Gen_gen_json_for_type(v__gen__Gen* g, v__table__Type typ);
VV_LOCAL_SYMBOL string v__gen__js_enc_name(string typ);
VV_LOCAL_SYMBOL string v__gen__js_dec_name(string typ);
VV_LOCAL_SYMBOL bool v__gen__is_js_prim(string typ);
VV_LOCAL_SYMBOL string v__gen__Gen_decode_array(v__gen__Gen* g, v__table__Type value_type);
VV_LOCAL_SYMBOL string v__gen__Gen_encode_array(v__gen__Gen* g, v__table__Type value_type);
VV_LOCAL_SYMBOL string v__gen__Gen_decode_map(v__gen__Gen* g, v__table__Type key_type, v__table__Type value_type);
VV_LOCAL_SYMBOL string v__gen__Gen_encode_map(v__gen__Gen* g, v__table__Type key_type, v__table__Type value_type);
VV_LOCAL_SYMBOL void v__gen__Gen_generate_hotcode_reloading_declarations(v__gen__Gen* g);
VV_LOCAL_SYMBOL void v__gen__Gen_generate_hotcode_reloader_code(v__gen__Gen* g);
string _const_v__gen__posix_hotcode_definitions_1; // a string literal, inited later
string _const_v__gen__windows_hotcode_definitions_1; // a string literal, inited later
VV_LOCAL_SYMBOL void v__gen__Gen_generate_hotcode_reloading_main_caller(v__gen__Gen* g);
VV_LOCAL_SYMBOL void v__gen__Gen_profile_fn(v__gen__Gen* g, v__ast__FnDecl fn_decl);
void v__gen__Gen_gen_vprint_profile_stats(v__gen__Gen* g);
string _const_v__gen__dbtype; // a string literal, inited later
VV_LOCAL_SYMBOL void v__gen__Gen_sql_stmt(v__gen__Gen* g, v__ast__SqlStmt node);
VV_LOCAL_SYMBOL void v__gen__Gen_sql_select_expr(v__gen__Gen* g, v__ast__SqlExpr node);
VV_LOCAL_SYMBOL void v__gen__Gen_sql_bind_int(v__gen__Gen* g, string val);
VV_LOCAL_SYMBOL void v__gen__Gen_sql_bind_string(v__gen__Gen* g, string val, string len);
VV_LOCAL_SYMBOL void v__gen__Gen_expr_to_sql(v__gen__Gen* g, v__ast__Expr expr);
VV_LOCAL_SYMBOL void v__gen__Gen_inc_sql_i(v__gen__Gen* g);
VV_LOCAL_SYMBOL void v__gen__Gen_write_str_fn_definitions(v__gen__Gen* g);
VV_LOCAL_SYMBOL void v__gen__Gen_string_literal(v__gen__Gen* g, v__ast__StringLiteral node);
VV_LOCAL_SYMBOL void v__gen__Gen_string_inter_literal_sb_optimized(v__gen__Gen* g, v__ast__CallExpr call_expr);
VV_LOCAL_SYMBOL void v__gen__Gen_string_inter_literal(v__gen__Gen* g, v__ast__StringInterLiteral node);
array_string _const_v__gen__js__js_reserved; // inited later
array_string _const_v__gen__js__tabs; // inited later
string v__gen__js__gen(array_v__ast__File files, v__table__Table* table, v__pref__Preferences* pref);
void v__gen__js__JsGen_enter_namespace(v__gen__js__JsGen* g, string n);
void v__gen__js__JsGen_escape_namespace(v__gen__js__JsGen* g);
void v__gen__js__JsGen_push_pub_var(v__gen__js__JsGen* g, string s);
void v__gen__js__JsGen_find_class_methods(v__gen__js__JsGen* g, array_v__ast__Stmt stmts);
void v__gen__js__JsGen_init(v__gen__js__JsGen* g);
string v__gen__js__JsGen_hashes(v__gen__js__JsGen g);
string v__gen__js__JsGen_typ(v__gen__js__JsGen* g, v__table__Type t);
VV_LOCAL_SYMBOL string v__gen__js__JsGen_fn_typ(v__gen__js__JsGen* g, array_v__table__Param args, v__table__Type return_type);
VV_LOCAL_SYMBOL string v__gen__js__JsGen_struct_typ(v__gen__js__JsGen* g, string s);
VV_LOCAL_SYMBOL string v__gen__js__JsGen_to_js_typ_val(v__gen__js__JsGen* g, v__table__Type t);
void v__gen__js__JsGen_gen_indent(v__gen__js__JsGen* g);
void v__gen__js__JsGen_inc_indent(v__gen__js__JsGen* g);
void v__gen__js__JsGen_dec_indent(v__gen__js__JsGen* g);
void v__gen__js__JsGen_write(v__gen__js__JsGen* g, string s);
void v__gen__js__JsGen_writeln(v__gen__js__JsGen* g, string s);
string v__gen__js__JsGen_new_tmp_var(v__gen__js__JsGen* g);
VV_LOCAL_SYMBOL string v__gen__js__get_ns(string s);
VV_LOCAL_SYMBOL string v__gen__js__JsGen_get_alias(v__gen__js__JsGen* g, string name);
VV_LOCAL_SYMBOL string v__gen__js__JsGen_js_name(v__gen__js__JsGen* g, string name_);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_stmts(v__gen__js__JsGen* g, array_v__ast__Stmt stmts);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_stmt(v__gen__js__JsGen* g, v__ast__Stmt node);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_expr(v__gen__js__JsGen* g, v__ast__Expr node);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_assert_stmt(v__gen__js__JsGen* g, v__ast__AssertStmt a);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_assign_stmt(v__gen__js__JsGen* g, v__ast__AssignStmt stmt);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_attrs(v__gen__js__JsGen* g, array_v__table__Attr attrs);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_block(v__gen__js__JsGen* g, v__ast__Block it);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_branch_stmt(v__gen__js__JsGen* g, v__ast__BranchStmt it);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_const_decl(v__gen__js__JsGen* g, v__ast__ConstDecl it);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_defer_stmts(v__gen__js__JsGen* g);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_enum_decl(v__gen__js__JsGen* g, v__ast__EnumDecl it);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_expr_stmt(v__gen__js__JsGen* g, v__ast__ExprStmt it);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_fn_decl(v__gen__js__JsGen* g, v__ast__FnDecl it);
VV_LOCAL_SYMBOL bool v__gen__js__fn_has_go(v__ast__FnDecl it);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_method_decl(v__gen__js__JsGen* g, v__ast__FnDecl it);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_fn_args(v__gen__js__JsGen* g, array_v__table__Param args, bool is_variadic);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_for_c_stmt(v__gen__js__JsGen* g, v__ast__ForCStmt it);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_for_in_stmt(v__gen__js__JsGen* g, v__ast__ForInStmt it);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_for_stmt(v__gen__js__JsGen* g, v__ast__ForStmt it);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_go_stmt(v__gen__js__JsGen* g, v__ast__GoStmt node);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_import_stmt(v__gen__js__JsGen* g, v__ast__Import it);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_interface_decl(v__gen__js__JsGen* g, v__ast__InterfaceDecl it);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_return_stmt(v__gen__js__JsGen* g, v__ast__Return it);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_hash_stmt(v__gen__js__JsGen* g, v__ast__HashStmt it);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_struct_decl(v__gen__js__JsGen* g, v__ast__StructDecl node);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_array_init_expr(v__gen__js__JsGen* g, v__ast__ArrayInit it);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_array_init_values(v__gen__js__JsGen* g, array_v__ast__Expr exprs);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_call_expr(v__gen__js__JsGen* g, v__ast__CallExpr it);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_ident(v__gen__js__JsGen* g, v__ast__Ident node);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_lock_expr(v__gen__js__JsGen* g, v__ast__LockExpr node);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_if_expr(v__gen__js__JsGen* g, v__ast__IfExpr node);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_index_expr(v__gen__js__JsGen* g, v__ast__IndexExpr expr);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_infix_expr(v__gen__js__JsGen* g, v__ast__InfixExpr it);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_map_init_expr(v__gen__js__JsGen* g, v__ast__MapInit it);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_selector_expr(v__gen__js__JsGen* g, v__ast__SelectorExpr it);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_string_inter_literal(v__gen__js__JsGen* g, v__ast__StringInterLiteral it);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_struct_init(v__gen__js__JsGen* g, v__ast__StructInit it);
VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_typeof_expr(v__gen__js__JsGen* g, v__ast__TypeOf it);
VV_LOCAL_SYMBOL v__gen__js__JsDoc* v__gen__js__new_jsdoc(v__gen__js__JsGen* gen);
VV_LOCAL_SYMBOL void v__gen__js__JsDoc_write(v__gen__js__JsDoc* d, string s);
VV_LOCAL_SYMBOL void v__gen__js__JsDoc_writeln(v__gen__js__JsDoc* d, string s);
VV_LOCAL_SYMBOL void v__gen__js__JsDoc_gen_typ(v__gen__js__JsDoc* d, string typ);
VV_LOCAL_SYMBOL void v__gen__js__JsDoc_gen_const(v__gen__js__JsDoc* d, string typ);
VV_LOCAL_SYMBOL void v__gen__js__JsDoc_gen_enum(v__gen__js__JsDoc* d);
VV_LOCAL_SYMBOL void v__gen__js__JsDoc_gen_fac_fn(v__gen__js__JsDoc* d, array_v__ast__StructField fields);
VV_LOCAL_SYMBOL void v__gen__js__JsDoc_gen_fn(v__gen__js__JsDoc* d, v__ast__FnDecl it);
VV_LOCAL_SYMBOL void v__gen__js__JsDoc_gen_interface(v__gen__js__JsDoc* d, v__ast__InterfaceDecl it);
byte _const_v__gen__x64__mag0; // inited later
#define _const_v__gen__x64__mag1 'E'
#define _const_v__gen__x64__mag2 'L'
#define _const_v__gen__x64__mag3 'F'
#define _const_v__gen__x64__ei_class 4
#define _const_v__gen__x64__elfclass64 2
#define _const_v__gen__x64__elfdata2lsb 1
#define _const_v__gen__x64__ev_current 1
#define _const_v__gen__x64__elf_osabi 0
#define _const_v__gen__x64__et_rel 1
#define _const_v__gen__x64__et_exec 2
#define _const_v__gen__x64__et_dyn 3
#define _const_v__gen__x64__e_machine 0x3e
#define _const_v__gen__x64__shn_xindex 0xffff
#define _const_v__gen__x64__sht_null 0
#define _const_v__gen__x64__segment_start 0x400000
#define _const_v__gen__x64__placeholder 0
#define _const_v__gen__x64__sevens 0x77777777
void v__gen__x64__Gen_generate_elf_header(v__gen__x64__Gen* g);
void v__gen__x64__Gen_generate_elf_footer(v__gen__x64__Gen* g);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_section_header(v__gen__x64__Gen* g, v__gen__x64__SectionConfig c);
VV_LOCAL_SYMBOL void v__gen__x64__genobj();
array_v__gen__x64__Register _const_v__gen__x64__fn_arg_registers; // inited later
void v__gen__x64__gen(array_v__ast__File files, v__table__Table* table, string out_name, v__pref__Preferences* pref);
void v__gen__x64__Gen_stmts(v__gen__x64__Gen* g, array_v__ast__Stmt stmts);
i64 v__gen__x64__Gen_pos(v__gen__x64__Gen* g);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_write8(v__gen__x64__Gen* g, int n);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_write16(v__gen__x64__Gen* g, int n);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_write32(v__gen__x64__Gen* g, int n);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_write64(v__gen__x64__Gen* g, i64 n);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_write64_at(v__gen__x64__Gen* g, i64 n, i64 at);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_write32_at(v__gen__x64__Gen* g, i64 at, int n);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_write_string(v__gen__x64__Gen* g, string s);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_inc(v__gen__x64__Gen* g, v__gen__x64__Register reg);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_cmp(v__gen__x64__Gen* g, v__gen__x64__Register reg, v__gen__x64__Size size, i64 val);
VV_LOCAL_SYMBOL int v__gen__x64__Gen_get_var_offset(v__gen__x64__Gen* g, string var_name);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_cmp_var(v__gen__x64__Gen* g, string var_name, int val);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_inc_var(v__gen__x64__Gen* g, string var_name);
VV_LOCAL_SYMBOL int v__gen__x64__Gen_jne(v__gen__x64__Gen* g);
VV_LOCAL_SYMBOL int v__gen__x64__Gen_jge(v__gen__x64__Gen* g);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_jmp(v__gen__x64__Gen* g, int addr);
VV_LOCAL_SYMBOL i64 v__gen__x64__abs(i64 a);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_jle(v__gen__x64__Gen* g, i64 addr);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_println(v__gen__x64__Gen* g, string comment);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_jl(v__gen__x64__Gen* g, i64 addr);
VV_LOCAL_SYMBOL int v__gen__x64__Gen_abs_to_rel_addr(v__gen__x64__Gen* g, i64 addr);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_mov64(v__gen__x64__Gen* g, v__gen__x64__Register reg, i64 val);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_mov_reg_to_rbp(v__gen__x64__Gen* g, int var_offset, v__gen__x64__Register reg);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_mov_var_to_reg(v__gen__x64__Gen* g, v__gen__x64__Register reg, int var_offset);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_call(v__gen__x64__Gen* g, int addr);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_syscall(v__gen__x64__Gen* g);
void v__gen__x64__Gen_ret(v__gen__x64__Gen* g);
void v__gen__x64__Gen_push(v__gen__x64__Gen* g, v__gen__x64__Register reg);
void v__gen__x64__Gen_pop(v__gen__x64__Gen* g, v__gen__x64__Register reg);
void v__gen__x64__Gen_sub32(v__gen__x64__Gen* g, v__gen__x64__Register reg, int val);
void v__gen__x64__Gen_sub8(v__gen__x64__Gen* g, v__gen__x64__Register reg, int val);
void v__gen__x64__Gen_add(v__gen__x64__Gen* g, v__gen__x64__Register reg, int val);
void v__gen__x64__Gen_add8(v__gen__x64__Gen* g, v__gen__x64__Register reg, int val);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_add8_var(v__gen__x64__Gen* g, v__gen__x64__Register reg, int var_offset);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_sub8_var(v__gen__x64__Gen* g, v__gen__x64__Register reg, int var_offset);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_mul8_var(v__gen__x64__Gen* g, v__gen__x64__Register reg, int var_offset);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_leave(v__gen__x64__Gen* g);
int v__gen__x64__Gen_gen_loop_start(v__gen__x64__Gen* g, int from);
void v__gen__x64__Gen_gen_loop_end(v__gen__x64__Gen* g, int to, int label);
void v__gen__x64__Gen_save_main_fn_addr(v__gen__x64__Gen* g);
void v__gen__x64__Gen_gen_print_from_expr(v__gen__x64__Gen* g, v__ast__Expr expr, bool newline);
void v__gen__x64__Gen_gen_print(v__gen__x64__Gen* g, string s);
void v__gen__x64__Gen_gen_exit(v__gen__x64__Gen* g);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_mov(v__gen__x64__Gen* g, v__gen__x64__Register reg, int val);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_mov_reg(v__gen__x64__Gen* g, v__gen__x64__Register a, v__gen__x64__Register b);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_mov_rbp_rsp(v__gen__x64__Gen* g);
void v__gen__x64__Gen_register_function_address(v__gen__x64__Gen* g, string name);
void v__gen__x64__Gen_call_fn(v__gen__x64__Gen* g, v__ast__CallExpr node);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_stmt(v__gen__x64__Gen* g, v__ast__Stmt node);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_expr(v__gen__x64__Gen* g, v__ast__Expr node);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_allocate_var(v__gen__x64__Gen* g, string name, int size, int initial_val);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_assign_stmt(v__gen__x64__Gen* g, v__ast__AssignStmt node);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_infix_expr(v__gen__x64__Gen* g, v__ast__InfixExpr node);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_if_expr(v__gen__x64__Gen* g, v__ast__IfExpr node);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_for_stmt(v__gen__x64__Gen* g, v__ast__ForStmt node);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_fn_decl(v__gen__x64__Gen* g, v__ast__FnDecl node);
VV_LOCAL_SYMBOL void v__gen__x64__Gen_postfix_expr(v__gen__x64__Gen* g, v__ast__PostfixExpr node);
VV_LOCAL_SYMBOL void v__gen__x64__verror(string s);
void v__gen__x64__Gen_error_with_pos(v__gen__x64__Gen* g, string s, v__token__Position pos);
v__builder__Builder v__builder__new_builder(v__pref__Preferences* pref);
void v__builder__Builder_parse_imports(v__builder__Builder* b);
void v__builder__Builder_resolve_deps(v__builder__Builder* b);
v__depgraph__DepGraph* v__builder__Builder_import_graph(v__builder__Builder* b);
array_string v__builder__Builder_v_files_from_dir(v__builder__Builder b, string dir);
void v__builder__Builder_log(v__builder__Builder b, string s);
void v__builder__Builder_info(v__builder__Builder b, string s);
VV_LOCAL_SYMBOL string v__builder__module_path(string mod);
Option_string v__builder__Builder_find_module_path(v__builder__Builder* b, string mod, string fpath);
VV_LOCAL_SYMBOL void v__builder__Builder_show_total_warns_and_errors_stats(v__builder__Builder* b);
VV_LOCAL_SYMBOL void v__builder__Builder_print_warnings_and_errors(v__builder__Builder* b);
VV_LOCAL_SYMBOL void v__builder__verror(string s);
void v__builder__Builder_timing_message(v__builder__Builder* b, string msg, i64 ms);
string v__builder__Builder_gen_c(v__builder__Builder* b, array_string v_files);
void v__builder__Builder_build_c(v__builder__Builder* b, array_string v_files, string out_file);
void v__builder__Builder_compile_c(v__builder__Builder* b);
string _const_v__builder__c_verror_message_marker; // a string literal, inited later
string _const_v__builder__c_error_info; // a string literal, inited later
string _const_v__builder__no_compiler_error; // a string literal, inited later
string _const_v__builder__mingw_cc; // a string literal, inited later
VV_LOCAL_SYMBOL void v__builder__todo();
VV_LOCAL_SYMBOL Option_void v__builder__Builder_find_win_cc(v__builder__Builder* v);
VV_LOCAL_SYMBOL void v__builder__Builder_show_c_compiler_output(v__builder__Builder* v, os__Result res);
VV_LOCAL_SYMBOL void v__builder__Builder_post_process_c_compiler_output(v__builder__Builder* v, os__Result res);
VV_LOCAL_SYMBOL string v__builder__Builder_rebuild_cached_module(v__builder__Builder* v, string vexe, string imp_path);
VV_LOCAL_SYMBOL void v__builder__Builder_show_cc(v__builder__Builder* v, string cmd, string response_file, string response_file_content);
VV_LOCAL_SYMBOL void v__builder__Builder_cc(v__builder__Builder* v);
VV_LOCAL_SYMBOL void v__builder__Builder_cc_linux_cross(v__builder__Builder* b);
VV_LOCAL_SYMBOL void v__builder__Builder_cc_windows_cross(v__builder__Builder* c);
VV_LOCAL_SYMBOL void v__builder__Builder_build_thirdparty_obj_files(v__builder__Builder* v);
VV_LOCAL_SYMBOL void v__builder__Builder_build_thirdparty_obj_file(v__builder__Builder* v, string path, array_v__cflag__CFlag moduleflags);
VV_LOCAL_SYMBOL string v__builder__missing_compiler_info();
VV_LOCAL_SYMBOL array_string v__builder__error_context_lines(string text, string keyword, int before, int after);
VV_LOCAL_SYMBOL array_v__cflag__CFlag v__builder__Builder_get_os_cflags(v__builder__Builder* v);
VV_LOCAL_SYMBOL array_v__cflag__CFlag v__builder__Builder_get_rest_of_module_cflags(v__builder__Builder* v, v__cflag__CFlag* c);
VV_LOCAL_SYMBOL string v__builder__get_vtmp_folder();
VV_LOCAL_SYMBOL string v__builder__Builder_get_vtmp_filename(v__builder__Builder* b, string base_file_name, string postfix);
void v__builder__compile(string command, v__pref__Preferences* pref);
VV_LOCAL_SYMBOL void v__builder__Builder_myfree(v__builder__Builder* b);
VV_LOCAL_SYMBOL void v__builder__Builder_exit_on_invalid_syntax(v__builder__Builder* b);
VV_LOCAL_SYMBOL void v__builder__Builder_run_compiled_executable_and_exit(v__builder__Builder* b);
VV_LOCAL_SYMBOL void v__builder__Builder_set_module_lookup_paths(v__builder__Builder* v);
array_string v__builder__Builder_get_builtin_files(v__builder__Builder v);
array_string v__builder__Builder_get_user_files(v__builder__Builder* v);
void v__builder__Builder_generic_struct_insts_to_concrete(v__builder__Builder* b);
VV_LOCAL_SYMBOL string v__builder__make_ios_plist(string display_name, string bundle_id, string bundle_name, int bundle_version);
string v__builder__Builder_gen_js(v__builder__Builder* b, array_string v_files);
void v__builder__Builder_build_js(v__builder__Builder* b, array_string v_files, string out_file);
void v__builder__Builder_compile_js(v__builder__Builder* b);
VV_LOCAL_SYMBOL void v__builder__Builder_run_js(v__builder__Builder* b);
v__builder__RegKey _const_v__builder__hkey_local_machine; // inited later
int _const_v__builder__key_query_value; // inited later
int _const_v__builder__key_wow64_32key; // inited later
int _const_v__builder__key_enumerate_sub_keys; // inited later
VV_LOCAL_SYMBOL Option_string v__builder__find_windows_kit_internal(v__builder__RegKey key, array_string versions);
VV_LOCAL_SYMBOL Option_v__builder__WindowsKit v__builder__find_windows_kit_root(string host_arch);
VV_LOCAL_SYMBOL Option_v__builder__VsInstallation v__builder__find_vs(string vswhere_dir, string host_arch);
VV_LOCAL_SYMBOL Option_v__builder__MsvcResult v__builder__find_msvc();
void v__builder__Builder_cc_msvc(v__builder__Builder* v);
VV_LOCAL_SYMBOL void v__builder__Builder_build_thirdparty_obj_file_with_msvc(v__builder__Builder* v, string path, array_v__cflag__CFlag moduleflags);
v__builder__MsvcStringFlags v__builder__msvc_string_flags(array_v__cflag__CFlag cflags);
void v__builder__Builder_build_x64(v__builder__Builder* b, array_string v_files, string out_file);
void v__builder__Builder_compile_x64(v__builder__Builder* b);
array_string _const_main__simple_cmd; // inited later
array_string _const_main__list_of_flags_that_allow_duplicates; // inited later
VV_LOCAL_SYMBOL void main__main();
VV_LOCAL_SYMBOL void main__invoke_help_and_exit(array_string remaining);

// V option typedefs:
typedef struct {
			int  data;
			string error;
			int    ecode;
			bool   ok;
			bool   is_none;
		} Option2_int;
typedef struct {
			string  data;
			string error;
			int    ecode;
			bool   ok;
			bool   is_none;
		} Option2_string;
typedef struct {
			void*  data;
			string error;
			int    ecode;
			bool   ok;
			bool   is_none;
		} Option2_void;
typedef struct {
			array_byte  data;
			string error;
			int    ecode;
			bool   ok;
			bool   is_none;
		} Option2_array_byte;
typedef struct {
			FILE*  data;
			string error;
			int    ecode;
			bool   ok;
			bool   is_none;
		} Option2_FILE_ptr;
typedef struct {
			array_string  data;
			string error;
			int    ecode;
			bool   ok;
			bool   is_none;
		} Option2_array_string;
typedef struct {
			bool  data;
			string error;
			int    ecode;
			bool   ok;
			bool   is_none;
		} Option2_bool;
typedef struct {
			array_ustring  data;
			string error;
			int    ecode;
			bool   ok;
			bool   is_none;
		} Option2_array_ustring;
typedef struct {
			os__File  data;
			string error;
			int    ecode;
			bool   ok;
			bool   is_none;
		} Option2_os__File;
typedef struct {
			os__Result  data;
			string error;
			int    ecode;
			bool   ok;
			bool   is_none;
		} Option2_os__Result;
typedef struct {
			time__Time  data;
			string error;
			int    ecode;
			bool   ok;
			bool   is_none;
		} Option2_time__Time;
typedef struct {
			f64  data;
			string error;
			int    ecode;
			bool   ok;
			bool   is_none;
		} Option2_f64;
typedef struct {
			semver__Range  data;
			string error;
			int    ecode;
			bool   ok;
			bool   is_none;
		} Option2_semver__Range;
typedef struct {
			semver__Version  data;
			string error;
			int    ecode;
			bool   ok;
			bool   is_none;
		} Option2_semver__Version;
typedef struct {
			semver__ComparatorSet  data;
			string error;
			int    ecode;
			bool   ok;
			bool   is_none;
		} Option2_semver__ComparatorSet;
typedef struct {
			semver__Comparator  data;
			string error;
			int    ecode;
			bool   ok;
			bool   is_none;
		} Option2_semver__Comparator;
typedef struct {
			v__vmod__Manifest  data;
			string error;
			int    ecode;
			bool   ok;
			bool   is_none;
		} Option2_v__vmod__Manifest;
typedef struct {
			multi_return_array_string_int  data;
			string error;
			int    ecode;
			bool   ok;
			bool   is_none;
		} Option2_multi_return_array_string_int;
typedef struct {
			v__pkgconfig__PkgConfig*  data;
			string error;
			int    ecode;
			bool   ok;
			bool   is_none;
		} Option2_v__pkgconfig__PkgConfig_ptr;
typedef struct {
			v__pkgconfig__Main*  data;
			string error;
			int    ecode;
			bool   ok;
			bool   is_none;
		} Option2_v__pkgconfig__Main_ptr;
typedef struct {
			v__table__Fn  data;
			string error;
			int    ecode;
			bool   ok;
			bool   is_none;
		} Option2_v__table__Fn;
typedef struct {
			v__table__Field  data;
			string error;
			int    ecode;
			bool   ok;
			bool   is_none;
		} Option2_v__table__Field;
typedef struct {
			v__table__TypeSymbol  data;
			string error;
			int    ecode;
			bool   ok;
			bool   is_none;
		} Option2_v__table__TypeSymbol;
typedef struct {
			v__pref__OS  data;
			string error;
			int    ecode;
			bool   ok;
			bool   is_none;
		} Option2_v__pref__OS;
typedef struct {
			v__pref__Backend  data;
			string error;
			int    ecode;
			bool   ok;
			bool   is_none;
		} Option2_v__pref__Backend;
typedef struct {
			multi_return_v__ast__ScopeObject_v__ast__Scope  data;
			string error;
			int    ecode;
			bool   ok;
			bool   is_none;
		} Option2_multi_return_v__ast__ScopeObject_v__ast__Scope;
typedef struct {
			v__ast__ScopeObject  data;
			string error;
			int    ecode;
			bool   ok;
			bool   is_none;
		} Option2_v__ast__ScopeObject;
typedef struct {
			v__ast__ScopeStructField  data;
			string error;
			int    ecode;
			bool   ok;
			bool   is_none;
		} Option2_v__ast__ScopeStructField;
typedef struct {
			v__ast__Var*  data;
			string error;
			int    ecode;
			bool   ok;
			bool   is_none;
		} Option2_v__ast__Var_ptr;
typedef struct {
			v__ast__ConstField*  data;
			string error;
			int    ecode;
			bool   ok;
			bool   is_none;
		} Option2_v__ast__ConstField_ptr;
typedef struct {
			v__ast__IntegerLiteral  data;
			string error;
			int    ecode;
			bool   ok;
			bool   is_none;
		} Option2_v__ast__IntegerLiteral;
typedef struct {
			v__builder__MsvcResult  data;
			string error;
			int    ecode;
			bool   ok;
			bool   is_none;
		} Option2_v__builder__MsvcResult;
typedef struct {
			v__builder__WindowsKit  data;
			string error;
			int    ecode;
			bool   ok;
			bool   is_none;
		} Option2_v__builder__WindowsKit;
typedef struct {
			v__builder__VsInstallation  data;
			string error;
			int    ecode;
			bool   ok;
			bool   is_none;
		} Option2_v__builder__VsInstallation;

// V stringliterals:

// >> string literal consts
void vinit_string_literals(){
	_const_math__bits__overflow_error = tos_lit("Overflow Error");
	_const_math__bits__divide_error = tos_lit("Divide Error");
	_const_new_line_character = tos_lit("\n");
	_const_digit_pairs = tos_lit("00102030405060708090011121314151617181910212223242526272829203132333435363738393041424344454647484940515253545556575859506162636465666768696071727374757677787970818283848586878889809192939495969798999");
	_const_os__path_separator = tos_lit("\\");
	_const_os__path_delimiter = tos_lit(";");
	_const_time__days_string = tos_lit("MonTueWedThuFriSatSun");
	_const_time__months_string = tos_lit("JanFebMarAprMayJunJulAugSepOctNovDec");
	_const_flag__space = tos_lit("                            ");
	_const_flag__underline = tos_lit("-----------------------------------------------");
	_const_semver__comparator_sep = tos_lit(" ");
	_const_semver__comparator_set_sep = tos_lit(" || ");
	_const_semver__hyphen_range_sep = tos_lit(" - ");
	_const_semver__x_range_symbols = tos_lit("Xx*");
	_const_v__pkgconfig__version = tos_lit("0.2.0");
	_const_vweb__tmpl__str_start = tos_lit("sb.write(\'");
	_const_vweb__tmpl__str_end = tos_lit("\' ) ");
	_const_rand__chars = tos_lit("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
	_const_rand__ulid_encoding = tos_lit("0123456789ABCDEFGHJKMNPQRSTVWXYZ");
	_const_help__unknown_topic = tos_lit("V Error: Unknown help topic provided. Use `v help` for usage information.");
	_const_v__util__v_version = tos_lit("0.1.30");
	_const_v__util__map_prefix = tos_lit("map[string]");
	_const_v__checker__no_pub_in_main_warning = tos_lit("in module main cannot be declared public");
	_const_v__gen__c_commit_hash_default = tos_lit("\n#ifndef V_COMMIT_HASH\n	#define V_COMMIT_HASH \"@@@\"\n#endif\n");
	_const_v__gen__c_current_commit_hash_default = tos_lit("\n#ifndef V_CURRENT_COMMIT_HASH\n	#define V_CURRENT_COMMIT_HASH \"@@@\"\n#endif\n");
	_const_v__gen__c_common_macros = tos_lit("\n#define EMPTY_STRUCT_DECLARATION\n#define EMPTY_STRUCT_INITIALIZATION 0\n// Due to a tcc bug, the length of an array needs to be specified, but GCC crashes if it is...\n#define EMPTY_ARRAY_OF_ELEMS(x,n) (x[])\n#define TCCSKIP(x) x\n\n#define __NOINLINE __attribute__((noinline))\n#define __IRQHANDLER __attribute__((interrupt))\n\n#if defined(__x86_64__)\n#define __V_amd64  1\n#endif\n#if defined(__aarch64__) || defined(__arm64__)\n#define __V_aarch64  1\n#endif\n\n// Using just __GNUC__ for detecting gcc, is not reliable because other compilers define it too:\n#ifdef __GNUC__\n	#define __V_GCC__\n#endif\n#ifdef __TINYC__\n	#undef __V_GCC__\n#endif\n#ifdef __cplusplus\n	#undef __V_GCC__\n#endif\n#ifdef __clang__\n	#undef __V_GCC__\n#endif\n#ifdef _MSC_VER\n	#undef __V_GCC__\n#endif\n\n#ifdef __TINYC__\n	#undef EMPTY_STRUCT_DECLARATION\n	#undef EMPTY_STRUCT_INITIALIZATION\n	#define EMPTY_STRUCT_DECLARATION char _dummy\n	#define EMPTY_STRUCT_INITIALIZATION 0\n	#undef EMPTY_ARRAY_OF_ELEMS\n	#define EMPTY_ARRAY_OF_ELEMS(x,n) (x[n])\n	#undef __NOINLINE\n	#undef __IRQHANDLER\n	// tcc does not support inlining at all\n	#define __NOINLINE\n	#define __IRQHANDLER\n	#undef TCCSKIP\n	#define TCCSKIP(x)\n	// #include <byteswap.h>\n	#ifndef _WIN32\n		#include <execinfo.h>\n		int tcc_backtrace(const char *fmt, ...);\n	#endif\n#endif\n\n// for __offset_of\n#ifndef __offsetof\n	#define __offsetof(s,memb) ((size_t)((char *)&((s *)0)->memb - (char *)0))\n#endif\n\n#define OPTION_CAST(x) (x)\n\n#ifndef V64_PRINTFORMAT\n	#ifdef PRIx64\n		#define V64_PRINTFORMAT \"0x%\"PRIx64\n	#elif defined(__WIN32__)\n		#define V64_PRINTFORMAT \"0x%I64x\"\n	#elif defined(__linux__) && defined(__LP64__)\n		#define V64_PRINTFORMAT \"0x%lx\"\n	#else\n		#define V64_PRINTFORMAT \"0x%llx\"\n	#endif\n#endif\n");
	_const_v__gen__c_builtin_types = tos_lit("\n//================================== builtin types ================================*/\ntypedef int64_t i64;\ntypedef int16_t i16;\ntypedef int8_t i8;\ntypedef uint64_t u64;\ntypedef uint32_t u32;\ntypedef uint16_t u16;\ntypedef uint8_t byte;\ntypedef uint32_t rune;\ntypedef float f32;\ntypedef double f64;\ntypedef int64_t any_int;\ntypedef double any_float;\ntypedef unsigned char* byteptr;\ntypedef void* voidptr;\ntypedef char* charptr;\ntypedef byte array_fixed_byte_300 [300];\n\ntypedef struct sync__Channel* chan;\n\n#ifndef __cplusplus\n	#ifndef bool\n		typedef int bool;\n		#define true 1\n		#define false 0\n	#endif\n#endif\n");
	_const_v__gen__posix_hotcode_definitions_1 = tos_lit("\nvoid v_bind_live_symbols(void* live_lib){\n	@LOAD_FNS@\n}\n");
	_const_v__gen__windows_hotcode_definitions_1 = tos_lit("\nvoid v_bind_live_symbols(void* live_lib){\n	@LOAD_FNS@\n}\n");
	_const_v__gen__dbtype = tos_lit("sqlite");
	_const_v__builder__c_verror_message_marker = tos_lit("VERROR_MESSAGE ");
	_const_v__builder__c_error_info = tos_lit("\n==================\nC error. This should never happen.\n\nIf you were not working with C interop, please raise an issue on GitHub:\n\nhttps://github.com/vlang/v/issues/new/choose\n\nYou can also use #help on Discord: https://discord.gg/vlang\n");
	_const_v__builder__no_compiler_error = tos_lit("\n==================\nError: no C compiler detected.\n\nYou can find instructions on how to install one in the V wiki:\nhttps://github.com/vlang/v/wiki/Installing-a-C-compiler-on-Windows\n\nIf you think you have one installed, make sure it is in your PATH.\nIf you do have one in your PATH, please raise an issue on GitHub:\nhttps://github.com/vlang/v/issues/new/choose\n\nYou can also use `v doctor`, to see what V knows about your current environment.\n\nYou can also seek #help on Discord: https://discord.gg/vlang\n");
	_const_v__builder__mingw_cc = tos_lit("x86_64-w64-mingw32-gcc");
}
// << string literal consts


// V auto str functions:
string strings__Builder_str_no_ptr(strings__Builder it){ return strings__Builder_str(&it); }
string time__FormatTime_str(time__FormatTime it) { /* gen_str_for_enum */
	switch(it) {
		case time__FormatTime_hhmm12: return tos_lit("hhmm12");
		case time__FormatTime_hhmm24: return tos_lit("hhmm24");
		case time__FormatTime_hhmmss12: return tos_lit("hhmmss12");
		case time__FormatTime_hhmmss24: return tos_lit("hhmmss24");
		case time__FormatTime_hhmmss24_milli: return tos_lit("hhmmss24_milli");
		case time__FormatTime_hhmmss24_micro: return tos_lit("hhmmss24_micro");
		case time__FormatTime_no_time: return tos_lit("no_time");
		default: return tos_lit("unknown enum value");
	}
}
string time__FormatDate_str(time__FormatDate it) { /* gen_str_for_enum */
	switch(it) {
		case time__FormatDate_ddmmyy: return tos_lit("ddmmyy");
		case time__FormatDate_ddmmyyyy: return tos_lit("ddmmyyyy");
		case time__FormatDate_mmddyy: return tos_lit("mmddyy");
		case time__FormatDate_mmddyyyy: return tos_lit("mmddyyyy");
		case time__FormatDate_mmmd: return tos_lit("mmmd");
		case time__FormatDate_mmmdd: return tos_lit("mmmdd");
		case time__FormatDate_mmmddyyyy: return tos_lit("mmmddyyyy");
		case time__FormatDate_no_date: return tos_lit("no_date");
		case time__FormatDate_yyyymmdd: return tos_lit("yyyymmdd");
		default: return tos_lit("unknown enum value");
	}
}
string v__table__Type_str(v__table__Type it) { return indent_v__table__Type_str(it, 0); }
string indent_v__table__Type_str(v__table__Type it, int indent_count) {
	string indents = tos_lit("");
	for (int i = 0; i < indent_count; ++i) {
		indents = string_add(indents, tos_lit("    "));
	}
	return _STR("%.*s\000v.table.Type(%.*s\000)", 3, indents, int_str(it));
}
string v__table__FExpr_str(v__table__FExpr x) { return indent_v__table__FExpr_str(x, 0); }
string indent_v__table__FExpr_str(v__table__FExpr x, int indent_count) {
	switch(x.typ) {
		case 3: return _STR("v.table.FExpr(%.*s\000)", 2, byteptr_str(*(byteptr*)x._3));
		case 2: return _STR("v.table.FExpr(%.*s\000)", 2, voidptr_str(*(voidptr*)x._2));
		default: return tos_lit("unknown sum type value");
	}
}
string array_v__table__Attr_str(array_v__table__Attr a) { return indent_array_v__table__Attr_str(a, 0);}
string indent_array_v__table__Attr_str(array_v__table__Attr a, int indent_count) {
	strings__Builder sb = strings__new_builder(a.len * 10);
	strings__Builder_write(&sb, tos_lit("["));
	for (int i = 0; i < a.len; ++i) {
		v__table__Attr it = (*(v__table__Attr*)array_get(a, i));
		string x = v__table__Attr_str(it);
		strings__Builder_write(&sb, x);
		if (i < a.len-1) {
			strings__Builder_write(&sb, tos_lit(", "));
		}
	}
	strings__Builder_write(&sb, tos_lit("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
string v__table__Field_str(v__table__Field x) { return indent_v__table__Field_str(x, 0);}
string indent_v__table__Field_str(v__table__Field x, int indent_count) {
	v__table__Field *it = &x;
	string indents = tos_lit("");
	for (int i = 0; i < indent_count; ++i) {
		indents = string_add(indents, tos_lit("    "));
	}
	return _STR("v.table.Field{\n"		"%.*s\000    name: '%.*s\000'\n"
		"%.*s\000    typ: %d\000\n"
		"%.*s\000    default_expr: %.*s\000\n"
		"%.*s\000    has_default_expr: %.*s\000\n"
		"%.*s\000    default_val: '%.*s\000'\n"
		"%.*s\000    attrs: %.*s\000\n"
		"%.*s\000    is_pub: %.*s\000\n"
		"%.*s\000    is_mut: %.*s\000\n"
		"%.*s\000    is_global: %.*s\000\n"
		"%.*s\000    is_embed: %.*s\000\n"
		"%.*s\000    embed_alias_for: '%.*s\000'\n"
		"%.*s\000}", 24,
		indents, it->name,
		indents, it->typ,
		indents, indent_v__table__FExpr_str(it->default_expr, indent_count + 1),
		indents, it->has_default_expr ? _SLIT("true") : _SLIT("false"),
		indents, it->default_val,
		indents, indent_array_v__table__Attr_str(it->attrs, indent_count + 1),
		indents, it->is_pub ? _SLIT("true") : _SLIT("false"),
		indents, it->is_mut ? _SLIT("true") : _SLIT("false"),
		indents, it->is_global ? _SLIT("true") : _SLIT("false"),
		indents, it->is_embed ? _SLIT("true") : _SLIT("false"),
		indents, it->embed_alias_for,
		indents);
}
string array_v__table__Field_str(array_v__table__Field a) { return indent_array_v__table__Field_str(a, 0);}
string indent_array_v__table__Field_str(array_v__table__Field a, int indent_count) {
	strings__Builder sb = strings__new_builder(a.len * 10);
	strings__Builder_write(&sb, tos_lit("["));
	for (int i = 0; i < a.len; ++i) {
		v__table__Field it = (*(v__table__Field*)array_get(a, i));
		string x = indent_v__table__Field_str(it, indent_count);
		strings__Builder_write(&sb, x);
		if (i < a.len-1) {
			strings__Builder_write(&sb, tos_lit(", "));
		}
	}
	strings__Builder_write(&sb, tos_lit("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
string array_v__table__Type_str(array_v__table__Type a) { return indent_array_v__table__Type_str(a, 0);}
string indent_array_v__table__Type_str(array_v__table__Type a, int indent_count) {
	strings__Builder sb = strings__new_builder(a.len * 10);
	strings__Builder_write(&sb, tos_lit("["));
	for (int i = 0; i < a.len; ++i) {
		int it = (*(int*)array_get(a, i));
		string x = int_str(it);
		strings__Builder_write(&sb, x);
		if (i < a.len-1) {
			strings__Builder_write(&sb, tos_lit(", "));
		}
	}
	strings__Builder_write(&sb, tos_lit("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
string v__table__Aggregate_str(v__table__Aggregate x) { return indent_v__table__Aggregate_str(x, 0);}
string indent_v__table__Aggregate_str(v__table__Aggregate x, int indent_count) {
	v__table__Aggregate *it = &x;
	string indents = tos_lit("");
	for (int i = 0; i < indent_count; ++i) {
		indents = string_add(indents, tos_lit("    "));
	}
	return _STR("v.table.Aggregate{\n"		"%.*s\000    fields: %.*s\000\n"
		"%.*s\000    types: %.*s\000\n"
		"%.*s\000}", 6,
		indents, indent_array_v__table__Field_str(it->fields, indent_count + 1),
		indents, indent_array_v__table__Type_str(it->types, indent_count + 1),
		indents);
}
string v__table__Language_str(v__table__Language it) { /* gen_str_for_enum */
	switch(it) {
		case v__table__Language_v: return tos_lit("v");
		case v__table__Language_c: return tos_lit("c");
		case v__table__Language_js: return tos_lit("js");
		default: return tos_lit("unknown enum value");
	}
}
string v__table__Alias_str(v__table__Alias x) { return indent_v__table__Alias_str(x, 0);}
string indent_v__table__Alias_str(v__table__Alias x, int indent_count) {
	v__table__Alias *it = &x;
	string indents = tos_lit("");
	for (int i = 0; i < indent_count; ++i) {
		indents = string_add(indents, tos_lit("    "));
	}
	return _STR("v.table.Alias{\n"		"%.*s\000    parent_type: %d\000\n"
		"%.*s\000    language: %.*s\000\n"
		"%.*s\000    is_import: %.*s\000\n"
		"%.*s\000}", 8,
		indents, it->parent_type,
		indents, v__table__Language_str(it->language),
		indents, it->is_import ? _SLIT("true") : _SLIT("false"),
		indents);
}
string v__table__Array_str(v__table__Array x) { return indent_v__table__Array_str(x, 0);}
string indent_v__table__Array_str(v__table__Array x, int indent_count) {
	v__table__Array *it = &x;
	string indents = tos_lit("");
	for (int i = 0; i < indent_count; ++i) {
		indents = string_add(indents, tos_lit("    "));
	}
	return _STR("v.table.Array{\n"		"%.*s\000    nr_dims: %d\000\n"
		"%.*s\000    elem_type: %d\000\n"
		"%.*s\000}", 6,
		indents, it->nr_dims,
		indents, it->elem_type,
		indents);
}
string v__table__ArrayFixed_str(v__table__ArrayFixed x) { return indent_v__table__ArrayFixed_str(x, 0);}
string indent_v__table__ArrayFixed_str(v__table__ArrayFixed x, int indent_count) {
	v__table__ArrayFixed *it = &x;
	string indents = tos_lit("");
	for (int i = 0; i < indent_count; ++i) {
		indents = string_add(indents, tos_lit("    "));
	}
	return _STR("v.table.ArrayFixed{\n"		"%.*s\000    nr_dims: %d\000\n"
		"%.*s\000    size: %d\000\n"
		"%.*s\000    elem_type: %d\000\n"
		"%.*s\000}", 8,
		indents, it->nr_dims,
		indents, it->size,
		indents, it->elem_type,
		indents);
}
string v__table__Chan_str(v__table__Chan x) { return indent_v__table__Chan_str(x, 0);}
string indent_v__table__Chan_str(v__table__Chan x, int indent_count) {
	v__table__Chan *it = &x;
	string indents = tos_lit("");
	for (int i = 0; i < indent_count; ++i) {
		indents = string_add(indents, tos_lit("    "));
	}
	return _STR("v.table.Chan{\n"		"%.*s\000    elem_type: %d\000\n"
		"%.*s\000    is_mut: %.*s\000\n"
		"%.*s\000}", 6,
		indents, it->elem_type,
		indents, it->is_mut ? _SLIT("true") : _SLIT("false"),
		indents);
}
string v__table__Enum_str(v__table__Enum x) { return indent_v__table__Enum_str(x, 0);}
string indent_v__table__Enum_str(v__table__Enum x, int indent_count) {
	v__table__Enum *it = &x;
	string indents = tos_lit("");
	for (int i = 0; i < indent_count; ++i) {
		indents = string_add(indents, tos_lit("    "));
	}
	return _STR("v.table.Enum{\n"		"%.*s\000    vals: %.*s\000\n"
		"%.*s\000    is_flag: %.*s\000\n"
		"%.*s\000    is_multi_allowed: %.*s\000\n"
		"%.*s\000}", 8,
		indents, array_string_str(it->vals),
		indents, it->is_flag ? _SLIT("true") : _SLIT("false"),
		indents, it->is_multi_allowed ? _SLIT("true") : _SLIT("false"),
		indents);
}
string v__table__Param_str(v__table__Param x) { return indent_v__table__Param_str(x, 0);}
string indent_v__table__Param_str(v__table__Param x, int indent_count) {
	v__table__Param *it = &x;
	string indents = tos_lit("");
	for (int i = 0; i < indent_count; ++i) {
		indents = string_add(indents, tos_lit("    "));
	}
	return _STR("v.table.Param{\n"		"%.*s\000    pos: %.*s\000\n"
		"%.*s\000    name: '%.*s\000'\n"
		"%.*s\000    is_mut: %.*s\000\n"
		"%.*s\000    typ: %d\000\n"
		"%.*s\000    type_source_name: '%.*s\000'\n"
		"%.*s\000    is_hidden: %.*s\000\n"
		"%.*s\000}", 14,
		indents, v__token__Position_str(it->pos),
		indents, it->name,
		indents, it->is_mut ? _SLIT("true") : _SLIT("false"),
		indents, it->typ,
		indents, it->type_source_name,
		indents, it->is_hidden ? _SLIT("true") : _SLIT("false"),
		indents);
}
string array_v__table__Param_str(array_v__table__Param a) { return indent_array_v__table__Param_str(a, 0);}
string indent_array_v__table__Param_str(array_v__table__Param a, int indent_count) {
	strings__Builder sb = strings__new_builder(a.len * 10);
	strings__Builder_write(&sb, tos_lit("["));
	for (int i = 0; i < a.len; ++i) {
		v__table__Param it = (*(v__table__Param*)array_get(a, i));
		string x = indent_v__table__Param_str(it, indent_count);
		strings__Builder_write(&sb, x);
		if (i < a.len-1) {
			strings__Builder_write(&sb, tos_lit(", "));
		}
	}
	strings__Builder_write(&sb, tos_lit("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
string v__table__Fn_str(v__table__Fn x) { return indent_v__table__Fn_str(x, 0);}
string indent_v__table__Fn_str(v__table__Fn x, int indent_count) {
	v__table__Fn *it = &x;
	string indents = tos_lit("");
	for (int i = 0; i < indent_count; ++i) {
		indents = string_add(indents, tos_lit("    "));
	}
	return _STR("v.table.Fn{\n"		"%.*s\000    params: %.*s\000\n"
		"%.*s\000    return_type: %d\000\n"
		"%.*s\000    return_type_source_name: '%.*s\000'\n"
		"%.*s\000    is_variadic: %.*s\000\n"
		"%.*s\000    language: %.*s\000\n"
		"%.*s\000    is_generic: %.*s\000\n"
		"%.*s\000    is_pub: %.*s\000\n"
		"%.*s\000    is_deprecated: %.*s\000\n"
		"%.*s\000    is_unsafe: %.*s\000\n"
		"%.*s\000    is_placeholder: %.*s\000\n"
		"%.*s\000    mod: '%.*s\000'\n"
		"%.*s\000    ctdefine: '%.*s\000'\n"
		"%.*s\000    attrs: %.*s\000\n"
		"%.*s\000    name: '%.*s\000'\n"
		"%.*s\000    source_fn: %d\000\n"
		"%.*s\000}", 32,
		indents, indent_array_v__table__Param_str(it->params, indent_count + 1),
		indents, it->return_type,
		indents, it->return_type_source_name,
		indents, it->is_variadic ? _SLIT("true") : _SLIT("false"),
		indents, v__table__Language_str(it->language),
		indents, it->is_generic ? _SLIT("true") : _SLIT("false"),
		indents, it->is_pub ? _SLIT("true") : _SLIT("false"),
		indents, it->is_deprecated ? _SLIT("true") : _SLIT("false"),
		indents, it->is_unsafe ? _SLIT("true") : _SLIT("false"),
		indents, it->is_placeholder ? _SLIT("true") : _SLIT("false"),
		indents, it->mod,
		indents, it->ctdefine,
		indents, indent_array_v__table__Attr_str(it->attrs, indent_count + 1),
		indents, it->name,
		indents, it->source_fn,
		indents);
}
string v__table__FnType_str(v__table__FnType x) { return indent_v__table__FnType_str(x, 0);}
string indent_v__table__FnType_str(v__table__FnType x, int indent_count) {
	v__table__FnType *it = &x;
	string indents = tos_lit("");
	for (int i = 0; i < indent_count; ++i) {
		indents = string_add(indents, tos_lit("    "));
	}
	return _STR("v.table.FnType{\n"		"%.*s\000    is_anon: %.*s\000\n"
		"%.*s\000    has_decl: %.*s\000\n"
		"%.*s\000    func: %.*s\000\n"
		"%.*s\000}", 8,
		indents, it->is_anon ? _SLIT("true") : _SLIT("false"),
		indents, it->has_decl ? _SLIT("true") : _SLIT("false"),
		indents, indent_v__table__Fn_str(it->func, indent_count + 1),
		indents);
}
string v__table__GenericStructInst_str(v__table__GenericStructInst x) { return indent_v__table__GenericStructInst_str(x, 0);}
string indent_v__table__GenericStructInst_str(v__table__GenericStructInst x, int indent_count) {
	v__table__GenericStructInst *it = &x;
	string indents = tos_lit("");
	for (int i = 0; i < indent_count; ++i) {
		indents = string_add(indents, tos_lit("    "));
	}
	return _STR("v.table.GenericStructInst{\n"		"%.*s\000    parent_idx: %d\000\n"
		"%.*s\000    generic_types: %.*s\000\n"
		"%.*s\000}", 6,
		indents, it->parent_idx,
		indents, indent_array_v__table__Type_str(it->generic_types, indent_count + 1),
		indents);
}
string v__table__Interface_str(v__table__Interface x) { return indent_v__table__Interface_str(x, 0);}
string indent_v__table__Interface_str(v__table__Interface x, int indent_count) {
	v__table__Interface *it = &x;
	string indents = tos_lit("");
	for (int i = 0; i < indent_count; ++i) {
		indents = string_add(indents, tos_lit("    "));
	}
	return _STR("v.table.Interface{\n"		"%.*s\000    types: %.*s\000\n"
		"%.*s\000}", 4,
		indents, indent_array_v__table__Type_str(it->types, indent_count + 1),
		indents);
}
string v__table__Map_str(v__table__Map x) { return indent_v__table__Map_str(x, 0);}
string indent_v__table__Map_str(v__table__Map x, int indent_count) {
	v__table__Map *it = &x;
	string indents = tos_lit("");
	for (int i = 0; i < indent_count; ++i) {
		indents = string_add(indents, tos_lit("    "));
	}
	return _STR("v.table.Map{\n"		"%.*s\000    key_type: %d\000\n"
		"%.*s\000    value_type: %d\000\n"
		"%.*s\000}", 6,
		indents, it->key_type,
		indents, it->value_type,
		indents);
}
string v__table__MultiReturn_str(v__table__MultiReturn x) { return indent_v__table__MultiReturn_str(x, 0);}
string indent_v__table__MultiReturn_str(v__table__MultiReturn x, int indent_count) {
	v__table__MultiReturn *it = &x;
	string indents = tos_lit("");
	for (int i = 0; i < indent_count; ++i) {
		indents = string_add(indents, tos_lit("    "));
	}
	return _STR("v.table.MultiReturn{\n"		"%.*s\000    types: %.*s\000\n"
		"%.*s\000}", 4,
		indents, indent_array_v__table__Type_str(it->types, indent_count + 1),
		indents);
}
string v__table__Struct_str(v__table__Struct x) { return indent_v__table__Struct_str(x, 0);}
string indent_v__table__Struct_str(v__table__Struct x, int indent_count) {
	v__table__Struct *it = &x;
	string indents = tos_lit("");
	for (int i = 0; i < indent_count; ++i) {
		indents = string_add(indents, tos_lit("    "));
	}
	return _STR("v.table.Struct{\n"		"%.*s\000    fields: %.*s\000\n"
		"%.*s\000    is_typedef: %.*s\000\n"
		"%.*s\000    is_union: %.*s\000\n"
		"%.*s\000    is_ref_only: %.*s\000\n"
		"%.*s\000    generic_types: %.*s\000\n"
		"%.*s\000}", 12,
		indents, indent_array_v__table__Field_str(it->fields, indent_count + 1),
		indents, it->is_typedef ? _SLIT("true") : _SLIT("false"),
		indents, it->is_union ? _SLIT("true") : _SLIT("false"),
		indents, it->is_ref_only ? _SLIT("true") : _SLIT("false"),
		indents, indent_array_v__table__Type_str(it->generic_types, indent_count + 1),
		indents);
}
string v__table__SumType_str(v__table__SumType x) { return indent_v__table__SumType_str(x, 0);}
string indent_v__table__SumType_str(v__table__SumType x, int indent_count) {
	v__table__SumType *it = &x;
	string indents = tos_lit("");
	for (int i = 0; i < indent_count; ++i) {
		indents = string_add(indents, tos_lit("    "));
	}
	return _STR("v.table.SumType{\n"		"%.*s\000    variants: %.*s\000\n"
		"%.*s\000}", 4,
		indents, indent_array_v__table__Type_str(it->variants, indent_count + 1),
		indents);
}
string v__table__TypeInfo_str(v__table__TypeInfo x) { return indent_v__table__TypeInfo_str(x, 0); }
string indent_v__table__TypeInfo_str(v__table__TypeInfo x, int indent_count) {
	switch(x.typ) {
		case 346: return _STR("v.table.TypeInfo(%.*s\000)", 2, indent_v__table__Aggregate_str(*(v__table__Aggregate*)x._346, indent_count));
		case 347: return _STR("v.table.TypeInfo(%.*s\000)", 2, indent_v__table__Alias_str(*(v__table__Alias*)x._347, indent_count));
		case 350: return _STR("v.table.TypeInfo(%.*s\000)", 2, indent_v__table__Array_str(*(v__table__Array*)x._350, indent_count));
		case 351: return _STR("v.table.TypeInfo(%.*s\000)", 2, indent_v__table__ArrayFixed_str(*(v__table__ArrayFixed*)x._351, indent_count));
		case 348: return _STR("v.table.TypeInfo(%.*s\000)", 2, indent_v__table__Chan_str(*(v__table__Chan*)x._348, indent_count));
		case 355: return _STR("v.table.TypeInfo(%.*s\000)", 2, indent_v__table__Enum_str(*(v__table__Enum*)x._355, indent_count));
		case 353: return _STR("v.table.TypeInfo(%.*s\000)", 2, indent_v__table__FnType_str(*(v__table__FnType*)x._353, indent_count));
		case 154: return _STR("v.table.TypeInfo(%.*s\000)", 2, indent_v__table__GenericStructInst_str(*(v__table__GenericStructInst*)x._154, indent_count));
		case 356: return _STR("v.table.TypeInfo(%.*s\000)", 2, indent_v__table__Interface_str(*(v__table__Interface*)x._356, indent_count));
		case 349: return _STR("v.table.TypeInfo(%.*s\000)", 2, indent_v__table__Map_str(*(v__table__Map*)x._349, indent_count));
		case 352: return _STR("v.table.TypeInfo(%.*s\000)", 2, indent_v__table__MultiReturn_str(*(v__table__MultiReturn*)x._352, indent_count));
		case 155: return _STR("v.table.TypeInfo(%.*s\000)", 2, indent_v__table__Struct_str(*(v__table__Struct*)x._155, indent_count));
		case 354: return _STR("v.table.TypeInfo(%.*s\000)", 2, indent_v__table__SumType_str(*(v__table__SumType*)x._354, indent_count));
		default: return tos_lit("unknown sum type value");
	}
}
string v__pref__Backend_str(v__pref__Backend it) { /* gen_str_for_enum */
	switch(it) {
		case v__pref__Backend_c: return tos_lit("c");
		case v__pref__Backend_js: return tos_lit("js");
		case v__pref__Backend_x64: return tos_lit("x64");
		default: return tos_lit("unknown enum value");
	}
}
string v__ast__BranchStmt_str_no_ptr(v__ast__BranchStmt it){ return v__ast__BranchStmt_str(&it); }
string v__table__TypeSymbol_str_no_ptr(v__table__TypeSymbol it){ return v__table__TypeSymbol_str(&it); }
string v__ast__IdentKind_str(v__ast__IdentKind it) { /* gen_str_for_enum */
	switch(it) {
		case v__ast__IdentKind_unresolved: return tos_lit("unresolved");
		case v__ast__IdentKind_blank_ident: return tos_lit("blank_ident");
		case v__ast__IdentKind_variable: return tos_lit("variable");
		case v__ast__IdentKind_constant: return tos_lit("constant");
		case v__ast__IdentKind_global: return tos_lit("global");
		case v__ast__IdentKind_function: return tos_lit("function");
		default: return tos_lit("unknown enum value");
	}
}
string v__gen__x64__Register_str(v__gen__x64__Register it) { /* gen_str_for_enum */
	switch(it) {
		case v__gen__x64__Register_rax: return tos_lit("rax");
		case v__gen__x64__Register_rcx: return tos_lit("rcx");
		case v__gen__x64__Register_rdx: return tos_lit("rdx");
		case v__gen__x64__Register_rbx: return tos_lit("rbx");
		case v__gen__x64__Register_rsp: return tos_lit("rsp");
		case v__gen__x64__Register_rbp: return tos_lit("rbp");
		case v__gen__x64__Register_rsi: return tos_lit("rsi");
		case v__gen__x64__Register_rdi: return tos_lit("rdi");
		case v__gen__x64__Register_eax: return tos_lit("eax");
		case v__gen__x64__Register_edi: return tos_lit("edi");
		case v__gen__x64__Register_edx: return tos_lit("edx");
		case v__gen__x64__Register_r8: return tos_lit("r8");
		case v__gen__x64__Register_r9: return tos_lit("r9");
		case v__gen__x64__Register_r10: return tos_lit("r10");
		case v__gen__x64__Register_r11: return tos_lit("r11");
		case v__gen__x64__Register_r12: return tos_lit("r12");
		case v__gen__x64__Register_r13: return tos_lit("r13");
		case v__gen__x64__Register_r14: return tos_lit("r14");
		case v__gen__x64__Register_r15: return tos_lit("r15");
		default: return tos_lit("unknown enum value");
	}
}
string v__errors__Reporter_str(v__errors__Reporter it) { /* gen_str_for_enum */
	switch(it) {
		case v__errors__Reporter_scanner: return tos_lit("scanner");
		case v__errors__Reporter_parser: return tos_lit("parser");
		case v__errors__Reporter_checker: return tos_lit("checker");
		case v__errors__Reporter_gen: return tos_lit("gen");
		default: return tos_lit("unknown enum value");
	}
}
string array_v__cflag__CFlag_str(array_v__cflag__CFlag a) { return indent_array_v__cflag__CFlag_str(a, 0);}
string indent_array_v__cflag__CFlag_str(array_v__cflag__CFlag a, int indent_count) {
	strings__Builder sb = strings__new_builder(a.len * 10);
	strings__Builder_write(&sb, tos_lit("["));
	for (int i = 0; i < a.len; ++i) {
		v__cflag__CFlag it = (*(v__cflag__CFlag*)array_get(a, i));
		string x = v__cflag__CFlag_str(&it);
		strings__Builder_write(&sb, x);
		if (i < a.len-1) {
			strings__Builder_write(&sb, tos_lit(", "));
		}
	}
	strings__Builder_write(&sb, tos_lit("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}

// V out

// >> typeof() support for sum types
char * v_typeof_sumtype_207(int sidx) { /* v.ast.TypeDecl */ 
	switch(sidx) {
		case 207: return "v.ast.TypeDecl";
		case 204: return "v.ast.AliasTypeDecl";
		case 205: return "v.ast.FnTypeDecl";
		case 206: return "v.ast.SumTypeDecl";
		default: return "unknown v.ast.TypeDecl";
	}
}
char * v_typeof_sumtype_250(int sidx) { /* v.ast.Expr */ 
	switch(sidx) {
		case 250: return "v.ast.Expr";
		case 208: return "v.ast.AnonFn";
		case 209: return "v.ast.ArrayInit";
		case 210: return "v.ast.AsCast";
		case 211: return "v.ast.Assoc";
		case 212: return "v.ast.AtExpr";
		case 213: return "v.ast.BoolLiteral";
		case 214: return "v.ast.CTempVar";
		case 215: return "v.ast.CallExpr";
		case 216: return "v.ast.CastExpr";
		case 217: return "v.ast.ChanInit";
		case 218: return "v.ast.CharLiteral";
		case 219: return "v.ast.Comment";
		case 220: return "v.ast.ComptimeCall";
		case 221: return "v.ast.ConcatExpr";
		case 222: return "v.ast.EnumVal";
		case 223: return "v.ast.FloatLiteral";
		case 224: return "v.ast.Ident";
		case 225: return "v.ast.IfExpr";
		case 226: return "v.ast.IfGuardExpr";
		case 227: return "v.ast.IndexExpr";
		case 228: return "v.ast.InfixExpr";
		case 229: return "v.ast.IntegerLiteral";
		case 230: return "v.ast.Likely";
		case 231: return "v.ast.LockExpr";
		case 232: return "v.ast.MapInit";
		case 233: return "v.ast.MatchExpr";
		case 234: return "v.ast.None";
		case 235: return "v.ast.OrExpr";
		case 236: return "v.ast.ParExpr";
		case 237: return "v.ast.PostfixExpr";
		case 238: return "v.ast.PrefixExpr";
		case 239: return "v.ast.RangeExpr";
		case 240: return "v.ast.SelectExpr";
		case 241: return "v.ast.SelectorExpr";
		case 242: return "v.ast.SizeOf";
		case 243: return "v.ast.SqlExpr";
		case 244: return "v.ast.StringInterLiteral";
		case 245: return "v.ast.StringLiteral";
		case 246: return "v.ast.StructInit";
		case 247: return "v.ast.Type";
		case 248: return "v.ast.TypeOf";
		case 249: return "v.ast.UnsafeExpr";
		default: return "unknown v.ast.Expr";
	}
}
char * v_typeof_sumtype_274(int sidx) { /* v.ast.Stmt */ 
	switch(sidx) {
		case 274: return "v.ast.Stmt";
		case 251: return "v.ast.AssertStmt";
		case 252: return "v.ast.AssignStmt";
		case 253: return "v.ast.Block";
		case 254: return "v.ast.BranchStmt";
		case 255: return "v.ast.CompFor";
		case 256: return "v.ast.ConstDecl";
		case 257: return "v.ast.DeferStmt";
		case 258: return "v.ast.EnumDecl";
		case 259: return "v.ast.ExprStmt";
		case 151: return "v.ast.FnDecl";
		case 260: return "v.ast.ForCStmt";
		case 261: return "v.ast.ForInStmt";
		case 262: return "v.ast.ForStmt";
		case 263: return "v.ast.GlobalDecl";
		case 264: return "v.ast.GoStmt";
		case 265: return "v.ast.GotoLabel";
		case 266: return "v.ast.GotoStmt";
		case 267: return "v.ast.HashStmt";
		case 268: return "v.ast.Import";
		case 269: return "v.ast.InterfaceDecl";
		case 270: return "v.ast.Module";
		case 271: return "v.ast.Return";
		case 272: return "v.ast.SqlStmt";
		case 273: return "v.ast.StructDecl";
		case 207: return "v.ast.TypeDecl";
		default: return "unknown v.ast.Stmt";
	}
}
char * v_typeof_sumtype_278(int sidx) { /* v.ast.ScopeObject */ 
	switch(sidx) {
		case 278: return "v.ast.ScopeObject";
		case 275: return "v.ast.ConstField";
		case 276: return "v.ast.GlobalField";
		case 277: return "v.ast.Var";
		default: return "unknown v.ast.ScopeObject";
	}
}
char * v_typeof_sumtype_314(int sidx) { /* v.ast.IdentInfo */ 
	switch(sidx) {
		case 314: return "v.ast.IdentInfo";
		case 312: return "v.ast.IdentFn";
		case 313: return "v.ast.IdentVar";
		default: return "unknown v.ast.IdentInfo";
	}
}
char * v_typeof_sumtype_335(int sidx) { /* v.table.FExpr */ 
	switch(sidx) {
		case 335: return "v.table.FExpr";
		case 3: return "byteptr";
		case 2: return "voidptr";
		default: return "unknown v.table.FExpr";
	}
}
char * v_typeof_sumtype_357(int sidx) { /* v.table.TypeInfo */ 
	switch(sidx) {
		case 357: return "v.table.TypeInfo";
		case 346: return "v.table.Aggregate";
		case 347: return "v.table.Alias";
		case 350: return "v.table.Array";
		case 351: return "v.table.ArrayFixed";
		case 348: return "v.table.Chan";
		case 355: return "v.table.Enum";
		case 353: return "v.table.FnType";
		case 154: return "v.table.GenericStructInst";
		case 356: return "v.table.Interface";
		case 349: return "v.table.Map";
		case 352: return "v.table.MultiReturn";
		case 155: return "v.table.Struct";
		case 354: return "v.table.SumType";
		default: return "unknown v.table.TypeInfo";
	}
}
// << typeof() support for sum types


void _STR_PRINT_ARG(const char *fmt, char** refbufp, int *nbytes, int *memsize, int guess, ...) {
	va_list args;
	va_start(args, guess);
	// NB: (*memsize - *nbytes) === how much free space is left at the end of the current buffer refbufp
	// *memsize === total length of the buffer refbufp
	// *nbytes === already occupied bytes of buffer refbufp
	// guess === how many bytes were taken during the current vsnprintf run
	for(;;) {
		if (guess < *memsize - *nbytes) {
			guess = vsnprintf(*refbufp + *nbytes, *memsize - *nbytes, fmt, args);
			if (guess < *memsize - *nbytes) { // result did fit into buffer
				*nbytes += guess;
				break;
			}
		}
		// increase buffer (somewhat exponentially)
		*memsize += (*memsize + *memsize) / 3 + guess;
		*refbufp = (char*)realloc((void*)*refbufp, *memsize);
	}
	va_end(args);
}

string _STR(const char *fmt, int nfmts, ...) {
	va_list argptr;
	int memsize = 128;
	int nbytes = 0;
	char* buf = (char*)malloc(memsize);
	va_start(argptr, nfmts);
	for (int i=0; i<nfmts; ++i) {
		int k = strlen(fmt);
		bool is_fspec = false;
		for (int j=0; j<k; ++j) {
			if (fmt[j] == '%') {
				j++;
				if (fmt[j] != '%') {
					is_fspec = true;
					break;
				}
			}
		}
		if (is_fspec) {
			char f = fmt[k-1];
			char fup = f & 0xdf; // toupper
			bool l = fmt[k-2] == 'l';
			bool ll = l && fmt[k-3] == 'l';
			if (f == 'u' || fup == 'X' || f == 'o' || f == 'd' || f == 'c') { // int...
				if (ll) _STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+16, va_arg(argptr, long long));
				else if (l) _STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+10, va_arg(argptr, long));
				else _STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+8, va_arg(argptr, int));
			} else if (fup >= 'E' && fup <= 'G') { // floating point
				_STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+10, va_arg(argptr, double));
			} else if (f == 'p') {
				_STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+14, va_arg(argptr, void*));
			} else if (f == 's') { // v string
				string s = va_arg(argptr, string);
				if (fmt[k-4] == '*') { // %*.*s
					int fwidth = va_arg(argptr, int);
					if (fwidth < 0)
						fwidth -= (s.len - utf8_str_visible_length(s));
					else
						fwidth += (s.len - utf8_str_visible_length(s));
					_STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+s.len-4, fwidth, s.len, s.str);
				} else { // %.*s
					_STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+s.len-4, s.len, s.str);
				}
			} else {
				//v_panic(tos3('Invaid format specifier'));
			}
		} else {
			_STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k);
		}
		fmt += k+1;
	}
	va_end(argptr);
	buf[nbytes] = 0;
	buf = (char*)realloc((void*)buf, nbytes+1);
#ifdef DEBUG_ALLOC
	//puts('_STR:');
	puts(buf);
#endif
#if _VAUTOFREE
	//g_cur_str = (byteptr)buf;
#endif
	return tos2((byteptr)buf);
}

string _STR_TMP(const char *fmt, ...) {
	va_list argptr;
	va_start(argptr, fmt);
	size_t len = vsnprintf(0, 0, fmt, argptr) + 1;
	va_end(argptr);
	va_start(argptr, fmt);
	vsprintf((char *)g_str_buf, fmt, argptr);
	va_end(argptr);

#ifdef DEBUG_ALLOC
	//puts('_STR_TMP:');
	//puts(g_str_buf);
#endif
	string res = tos(g_str_buf,  len);
	res.is_lit = 1;
	return res;

} // endof _STR_TMP


strings__Builder strings__new_builder(int initial_size) {
	return (strings__Builder){.buf = __new_array_with_default(0, initial_size, sizeof(byte), 0),.str_calls = 0,.len = 0,.initial_size = initial_size,};
}

void strings__Builder_write_bytes(strings__Builder* b, byteptr bytes, int howmany) {
	array_push_many(&b->buf, bytes, howmany);
	b->len += howmany;
}

void strings__Builder_write_b(strings__Builder* b, byte data) {
	array_push(&b->buf, _MOV((byte[]){ data }));
	b->len++;
}

// Attr: [inline]
inline void strings__Builder_write(strings__Builder* b, string s) {
	if ((s).len == 0) {
		return;
	}
	array_push_many(&b->buf, s.str, s.len);
	b->len += s.len;
}

void strings__Builder_go_back(strings__Builder* b, int n) {
	array_trim(&b->buf, b->buf.len - n);
	b->len -= n;
}

VV_LOCAL_SYMBOL string strings__bytes2string(array_byte b) {
	array_byte copy = array_clone(&b);
	array_push(&copy, _MOV((byte[]){ ((byte)('\0')) }));
	string res = tos(copy.data, copy.len - 1);
	return res;
}

string strings__Builder_cut_last(strings__Builder* b, int n) {
	string res = strings__bytes2string(array_slice(b->buf, b->len - n, b->buf.len));
	array_trim(&b->buf, b->buf.len - n);
	b->len -= n;
	return res;
}

void strings__Builder_go_back_to(strings__Builder* b, int pos) {
	array_trim(&b->buf, pos);
	b->len = pos;
}

// Attr: [inline]
inline void strings__Builder_writeln(strings__Builder* b, string s) {
	array_push_many(&b->buf, s.str, s.len);
	array_push(&b->buf, _MOV((byte[]){ '\n' }));
	b->len += s.len + 1;
}

string strings__Builder_last_n(strings__Builder* b, int n) {
	if (n > b->len) {
		return tos_lit("");
	}
	return strings__bytes2string(array_slice(b->buf, b->len - n, b->buf.len));
}

string strings__Builder_after(strings__Builder* b, int n) {
	if (n >= b->len) {
		return tos_lit("");
	}
	return strings__bytes2string(array_slice(b->buf, n, b->buf.len));
}

string strings__Builder_str(strings__Builder* b) {
	b->str_calls++;
	if (b->str_calls > 1) {
		v_panic(string_add(tos_lit("builder.str() should be called just once.\n"), tos_lit("If you want to reuse a builder, call b.free() first.")));
	}
	array_push(&b->buf, _MOV((byte[]){ '\0' }));
	string s = tos(b->buf.data, b->len);
	int bis = b->initial_size;
	b->buf = __new_array_with_default(0, bis, sizeof(byte), 0);
	b->len = 0;
	return s;
}

void strings__Builder_free(strings__Builder* b) {
	v_free(b->buf.data);
	b->len = 0;
	b->str_calls = 0;
}

int strings__levenshtein_distance(string a, string b) {
	array_int f = array_repeat(new_array_from_c_array(1, 1, sizeof(int), _MOV((int[1]){0})), b.len + 1);
	for (int j = 0; j < f.len; ++j) {
		array_set(&f, j, &(int[]) { j });
	}
	for (int _t5 = 0; _t5 < a.len; ++_t5) {
		byte ca = a.str[_t5];
		int j = 1;
		int fj1 = (*(int*)/*ee elem_typ */array_get(f, 0));
		(*(int*)/*ee elem_typ */array_get(f, 0))++;
		for (int _t6 = 0; _t6 < b.len; ++_t6) {
			byte cb = b.str[_t6];
			int mn = ((*(int*)/*ee elem_typ */array_get(f, j)) + 1 <= (*(int*)/*ee elem_typ */array_get(f, j - 1)) + 1 ? ((*(int*)/*ee elem_typ */array_get(f, j)) + 1) : ((*(int*)/*ee elem_typ */array_get(f, j - 1)) + 1));
			if (cb != ca) {
				mn = (mn <= fj1 + 1 ? (mn) : (fj1 + 1));
			} else {
				mn = (mn <= fj1 ? (mn) : (fj1));
			}
			fj1 = (*(int*)/*ee elem_typ */array_get(f, j));
			array_set(&f, j, &(int[]) { mn });
			j++;
		}
	}
	return (*(int*)/*ee elem_typ */array_get(f, f.len - 1));
}

f32 strings__levenshtein_distance_percentage(string a, string b) {
	int d = strings__levenshtein_distance(a, b);
	int l = (a.len >= b.len ? (a.len) : (b.len));
	return (1.00 - ((f32)(d)) / ((f32)(l))) * 100.00;
}

f32 strings__dice_coefficient(string s1, string s2) {
	if (s1.len == 0 || s2.len == 0) {
		return 0.0;
	}
	if (string_eq(s1, s2)) {
		return 1.0;
	}
	if (s1.len < 2 || s2.len < 2) {
		return 0.0;
	}
	string a = (s1.len > s2.len ? (s1) : (s2));
	string b = (string_eq(a, s1) ? (s2) : (s1));
	map_string_int first_bigrams = new_map_1(sizeof(int));
	for (int i = 0; i < a.len - 1; ++i) {
		string bigram = string_substr(a, i, i + 2);
		int q = (_IN_MAP(bigram, first_bigrams) ? ((*(int*)map_get(first_bigrams, bigram, &(int[]){ 0 })) + 1) : (1));
		map_set(&first_bigrams, bigram, &(int[]) { q });
	}
	int intersection_size = 0;
	for (int i = 0; i < b.len - 1; ++i) {
		string bigram = string_substr(b, i, i + 2);
		int count = (_IN_MAP(bigram, first_bigrams) ? ((*(int*)map_get(first_bigrams, bigram, &(int[]){ 0 }))) : (0));
		if (count > 0) {
			map_set(&first_bigrams, bigram, &(int[]) { count - 1 });
			intersection_size++;
		}
	}
	return (2.0 * ((f32)(intersection_size))) / (((f32)(a.len)) + ((f32)(b.len)) - 2);
}

string strings__repeat(byte c, int n) {
	if (n <= 0) {
		return tos_lit("");
	}
	byteptr bytes = v_malloc(n + 1);
	{ // Unsafe block
		memset(bytes, c, n);
		bytes[n] = '0';
	}
	return byteptr_vstring_with_len(bytes, n);
}

string strings__repeat_string(string s, int n) {
	if (n <= 0 || s.len == 0) {
		return tos_lit("");
	}
	int slen = s.len;
	int blen = slen * n;
	byteptr bytes = v_malloc(blen + 1);
	for (int bi = 0; bi < n; ++bi) {
		int bislen = bi * slen;
		for (int si = 0; si < slen; ++si) {
			{ // Unsafe block
				bytes[bislen + si] = string_at(s, si);
			}
		}
	}
	{ // Unsafe block
		bytes[blen] = '0';
	}
	return byteptr_vstring_with_len(bytes, blen);
}

// Attr: [inline]
inline u64 hash__wyhash_c(byteptr key, u64 len, u64 seed) {
	return wyhash(key, len, seed);
}

// Attr: [inline]
inline u64 hash__sum64_string(string key, u64 seed) {
	return hash__wyhash64(key.str, ((u64)(key.len)), seed);
}

// Attr: [inline]
inline u64 hash__sum64(array_byte key, u64 seed) {
	return hash__wyhash64(((byteptr)(key.data)), ((u64)(key.len)), seed);
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL u64 hash__wyhash64(byteptr key, u64 len, u64 seed_) {
	if (len == 0) {
		return 0;
	}
	byteptr p = key;
	u64 seed = seed_;
	u64 i = (len & 63);
	u64 _t7 = i;
		seed = (((_t7 <= 3)) ? (hash__wymum(((hash__wyr3(p, i) ^ seed) ^ _const_hash__wyp0), (seed ^ _const_hash__wyp1))) : ((_t7 >= 4 && _t7 <= 8)) ? (hash__wymum(((hash__wyr4(p) ^ seed) ^ _const_hash__wyp0), ((hash__wyr4(p + i - 4) ^ seed) ^ _const_hash__wyp1))) : ((_t7 >= 9 && _t7 <= 16)) ? (hash__wymum(((hash__wyr8(p) ^ seed) ^ _const_hash__wyp0), ((hash__wyr8(p + i - 8) ^ seed) ^ _const_hash__wyp1))) : ((_t7 >= 17 && _t7 <= 24)) ? ((hash__wymum(((hash__wyr8(p) ^ seed) ^ _const_hash__wyp0), ((hash__wyr8(p + 8) ^ seed) ^ _const_hash__wyp1)) ^ hash__wymum(((hash__wyr8(p + i - 8) ^ seed) ^ _const_hash__wyp2), (seed ^ _const_hash__wyp3)))) : ((_t7 >= 25 && _t7 <= 32)) ? ((hash__wymum(((hash__wyr8(p) ^ seed) ^ _const_hash__wyp0), ((hash__wyr8(p + 8) ^ seed) ^ _const_hash__wyp1)) ^ hash__wymum(((hash__wyr8(p + 16) ^ seed) ^ _const_hash__wyp2), ((hash__wyr8(p + i - 8) ^ seed) ^ _const_hash__wyp3)))) : ((((hash__wymum(((hash__wyr8(p) ^ seed) ^ _const_hash__wyp0), ((hash__wyr8(p + 8) ^ seed) ^ _const_hash__wyp1)) ^ hash__wymum(((hash__wyr8(p + 16) ^ seed) ^ _const_hash__wyp2), ((hash__wyr8(p + 24) ^ seed) ^ _const_hash__wyp3))) ^ hash__wymum(((hash__wyr8(p + i - 32) ^ seed) ^ _const_hash__wyp1), ((hash__wyr8(p + i - 24) ^ seed) ^ _const_hash__wyp2))) ^ hash__wymum(((hash__wyr8(p + i - 16) ^ seed) ^ _const_hash__wyp3), ((hash__wyr8(p + i - 8) ^ seed) ^ _const_hash__wyp0)))));
	if (i == len) {
		return hash__wymum(seed, (len ^ _const_hash__wyp4));
	}
	u64 see1 = seed;
	u64 see2 = seed;
	u64 see3 = seed;
	{ // Unsafe block
		p = p + i;
		for (i = len - i; i >= 64; i -= 64) {
			seed = hash__wymum(((hash__wyr8(p) ^ seed) ^ _const_hash__wyp0), ((hash__wyr8(p + 8) ^ seed) ^ _const_hash__wyp1));
			see1 = hash__wymum(((hash__wyr8(p + 16) ^ see1) ^ _const_hash__wyp2), ((hash__wyr8(p + 24) ^ see1) ^ _const_hash__wyp3));
			see2 = hash__wymum(((hash__wyr8(p + 32) ^ see2) ^ _const_hash__wyp1), ((hash__wyr8(p + 40) ^ see2) ^ _const_hash__wyp2));
			see3 = hash__wymum(((hash__wyr8(p + 48) ^ see3) ^ _const_hash__wyp3), ((hash__wyr8(p + 56) ^ see3) ^ _const_hash__wyp0));
			p = p + 64;
		}
	}
	return hash__wymum(((seed ^ see1) ^ see2), ((see3 ^ len) ^ _const_hash__wyp4));
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL u64 hash__wyrotr(u64 v, u32 k) {
	return ((v >> k) | (v << (64 - k)));
}

// Attr: [inline]
inline u64 hash__wymum(u64 a, u64 b) {
	u32 mask32 = ((u32)(4294967295U));
	u64 x0 = (a & mask32);
	u64 x1 = a >> 32;
	u64 y0 = (b & mask32);
	u64 y1 = b >> 32;
	u64 w0 = x0 * y0;
	u64 t = x1 * y0 + (w0 >> 32);
	u64 w1 = (t & mask32);
	u64 w2 = t >> 32;
	w1 += x0 * y1;
	u64 hi = x1 * y1 + w2 + (w1 >> 32);
	u64 lo = a * b;
	return (hi ^ lo);
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL u64 hash__wyr3(byteptr p, u64 k) {
	{ // Unsafe block
		return (((((u64)(p[0])) << 16) | (((u64)(p[k >> 1])) << 8)) | ((u64)(p[k - 1])));
	}
	return 0;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL u64 hash__wyr4(byteptr p) {
	{ // Unsafe block
		return (((((u32)(p[0])) | (((u32)(p[1])) << ((u32)(8U)))) | (((u32)(p[2])) << ((u32)(16U)))) | (((u32)(p[3])) << ((u32)(24U))));
	}
	return 0;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL u64 hash__wyr8(byteptr p) {
	{ // Unsafe block
		return (((((((((u64)(p[0])) | (((u64)(p[1])) << 8)) | (((u64)(p[2])) << 16)) | (((u64)(p[3])) << 24)) | (((u64)(p[4])) << 32)) | (((u64)(p[5])) << 40)) | (((u64)(p[6])) << 48)) | (((u64)(p[7])) << 56));
	}
	return 0;
}

int math__bits__leading_zeros_8(byte x) {
	return 8 - math__bits__len_8(x);
}

int math__bits__leading_zeros_16(u16 x) {
	return 16 - math__bits__len_16(x);
}

int math__bits__leading_zeros_32(u32 x) {
	return 32 - math__bits__len_32(x);
}

int math__bits__leading_zeros_64(u64 x) {
	return 64 - math__bits__len_64(x);
}

int math__bits__trailing_zeros_8(byte x) {
	return ((int)((*(byte*)/*ee elem_typ */array_get(_const_math__bits__ntz_8_tab, x))));
}

int math__bits__trailing_zeros_16(u16 x) {
	if (x == 0) {
		return 16;
	}
	return ((int)((*(byte*)/*ee elem_typ */array_get(_const_math__bits__de_bruijn32tab, ((u32)((x & -x))) * _const_math__bits__de_bruijn32 >> (32 - 5)))));
}

int math__bits__trailing_zeros_32(u32 x) {
	if (x == 0) {
		return 32;
	}
	return ((int)((*(byte*)/*ee elem_typ */array_get(_const_math__bits__de_bruijn32tab, ((x & -x)) * _const_math__bits__de_bruijn32 >> (32 - 5)))));
}

int math__bits__trailing_zeros_64(u64 x) {
	if (x == 0) {
		return 64;
	}
	return ((int)((*(byte*)/*ee elem_typ */array_get(_const_math__bits__de_bruijn64tab, ((x & -x)) * _const_math__bits__de_bruijn64 >> (64 - 6)))));
}

int math__bits__ones_count_8(byte x) {
	return ((int)((*(byte*)/*ee elem_typ */array_get(_const_math__bits__pop_8_tab, x))));
}

int math__bits__ones_count_16(u16 x) {
	return ((int)((*(byte*)/*ee elem_typ */array_get(_const_math__bits__pop_8_tab, x >> 8)) + (*(byte*)/*ee elem_typ */array_get(_const_math__bits__pop_8_tab, (x & ((u16)(0xffU)))))));
}

int math__bits__ones_count_32(u32 x) {
	return ((int)((*(byte*)/*ee elem_typ */array_get(_const_math__bits__pop_8_tab, x >> 24)) + (*(byte*)/*ee elem_typ */array_get(_const_math__bits__pop_8_tab, (x >> 16 & 0xff))) + (*(byte*)/*ee elem_typ */array_get(_const_math__bits__pop_8_tab, (x >> 8 & 0xff))) + (*(byte*)/*ee elem_typ */array_get(_const_math__bits__pop_8_tab, (x & ((u32)(0xffU)))))));
}

int math__bits__ones_count_64(u64 x) {
	u64 y = ((x >> ((u64)(1U)) & ((_const_math__bits__m0 & _const_math__bits__max_u64)))) + ((x & ((_const_math__bits__m0 & _const_math__bits__max_u64))));
	y = ((y >> ((u64)(2U)) & ((_const_math__bits__m1 & _const_math__bits__max_u64)))) + ((y & ((_const_math__bits__m1 & _const_math__bits__max_u64))));
	y = (((y >> 4) + y) & ((_const_math__bits__m2 & _const_math__bits__max_u64)));
	y += y >> 8;
	y += y >> 16;
	y += y >> 32;
	return (((int)(y)) & ((1 << 7) - 1));
}

// Attr: [inline]
inline byte math__bits__rotate_left_8(byte x, int k) {
	byte n = ((byte)(8));
	byte s = (((byte)(k)) & (n - ((byte)(1))));
	return (((x << s) | (x >> (n - s))));
}

// Attr: [inline]
inline u16 math__bits__rotate_left_16(u16 x, int k) {
	u16 n = ((u16)(16U));
	u16 s = (((u16)(k)) & (n - ((u16)(1U))));
	return (((x << s) | (x >> (n - s))));
}

// Attr: [inline]
inline u32 math__bits__rotate_left_32(u32 x, int k) {
	u32 n = ((u32)(32U));
	u32 s = (((u32)(k)) & (n - ((u32)(1U))));
	return (((x << s) | (x >> (n - s))));
}

// Attr: [inline]
inline u64 math__bits__rotate_left_64(u64 x, int k) {
	u64 n = ((u64)(64U));
	u64 s = (((u64)(k)) & (n - ((u64)(1U))));
	return (((x << s) | (x >> (n - s))));
}

// Attr: [inline]
inline byte math__bits__reverse_8(byte x) {
	return (*(byte*)/*ee elem_typ */array_get(_const_math__bits__rev_8_tab, x));
}

// Attr: [inline]
inline u16 math__bits__reverse_16(u16 x) {
	return (((u16)((*(byte*)/*ee elem_typ */array_get(_const_math__bits__rev_8_tab, x >> 8)))) | (((u16)((*(byte*)/*ee elem_typ */array_get(_const_math__bits__rev_8_tab, (x & ((u16)(0xffU))))))) << 8));
}

// Attr: [inline]
inline u32 math__bits__reverse_32(u32 x) {
	u64 y = ((((x >> ((u32)(1U)) & ((_const_math__bits__m0 & _const_math__bits__max_u32)))) | (((x & ((_const_math__bits__m0 & _const_math__bits__max_u32)))) << 1)));
	y = ((((y >> ((u32)(2U)) & ((_const_math__bits__m1 & _const_math__bits__max_u32)))) | (((y & ((_const_math__bits__m1 & _const_math__bits__max_u32)))) << ((u32)(2U)))));
	y = ((((y >> ((u32)(4U)) & ((_const_math__bits__m2 & _const_math__bits__max_u32)))) | (((y & ((_const_math__bits__m2 & _const_math__bits__max_u32)))) << ((u32)(4U)))));
	return math__bits__reverse_bytes_32(((u32)(y)));
}

// Attr: [inline]
inline u64 math__bits__reverse_64(u64 x) {
	u64 y = ((((x >> ((u64)(1U)) & ((_const_math__bits__m0 & _const_math__bits__max_u64)))) | (((x & ((_const_math__bits__m0 & _const_math__bits__max_u64)))) << 1)));
	y = ((((y >> ((u64)(2U)) & ((_const_math__bits__m1 & _const_math__bits__max_u64)))) | (((y & ((_const_math__bits__m1 & _const_math__bits__max_u64)))) << 2)));
	y = ((((y >> ((u64)(4U)) & ((_const_math__bits__m2 & _const_math__bits__max_u64)))) | (((y & ((_const_math__bits__m2 & _const_math__bits__max_u64)))) << 4)));
	return math__bits__reverse_bytes_64(y);
}

// Attr: [inline]
inline u16 math__bits__reverse_bytes_16(u16 x) {
	return ((x >> 8) | (x << 8));
}

// Attr: [inline]
inline u32 math__bits__reverse_bytes_32(u32 x) {
	u64 y = ((((x >> ((u32)(8U)) & ((_const_math__bits__m3 & _const_math__bits__max_u32)))) | (((x & ((_const_math__bits__m3 & _const_math__bits__max_u32)))) << ((u32)(8U)))));
	return ((u32)(((y >> 16) | (y << 16))));
}

// Attr: [inline]
inline u64 math__bits__reverse_bytes_64(u64 x) {
	u64 y = ((((x >> ((u64)(8U)) & ((_const_math__bits__m3 & _const_math__bits__max_u64)))) | (((x & ((_const_math__bits__m3 & _const_math__bits__max_u64)))) << ((u64)(8U)))));
	y = ((((y >> ((u64)(16U)) & ((_const_math__bits__m4 & _const_math__bits__max_u64)))) | (((y & ((_const_math__bits__m4 & _const_math__bits__max_u64)))) << ((u64)(16U)))));
	return ((y >> 32) | (y << 32));
}

int math__bits__len_8(byte x) {
	return ((int)((*(byte*)/*ee elem_typ */array_get(_const_math__bits__len_8_tab, x))));
}

int math__bits__len_16(u16 x) {
	u16 y = x;
	int n = 0;
	if (y >= 1 << 8) {
		y >>= 8;
		n = 8;
	}
	return n + ((int)((*(byte*)/*ee elem_typ */array_get(_const_math__bits__len_8_tab, y))));
}

int math__bits__len_32(u32 x) {
	u32 y = x;
	int n = 0;
	if (y >= (1 << 16)) {
		y >>= 16;
		n = 16;
	}
	if (y >= (1 << 8)) {
		y >>= 8;
		n += 8;
	}
	return n + ((int)((*(byte*)/*ee elem_typ */array_get(_const_math__bits__len_8_tab, y))));
}

int math__bits__len_64(u64 x) {
	u64 y = x;
	int n = 0;
	if (y >= ((u64)(1U)) << ((u64)(32U))) {
		y >>= 32;
		n = 32;
	}
	if (y >= ((u64)(1U)) << ((u64)(16U))) {
		y >>= 16;
		n += 16;
	}
	if (y >= ((u64)(1U)) << ((u64)(8U))) {
		y >>= 8;
		n += 8;
	}
	return n + ((int)((*(byte*)/*ee elem_typ */array_get(_const_math__bits__len_8_tab, y))));
}

multi_return_u32_u32 math__bits__add_32(u32 x, u32 y, u32 carry) {
	u64 sum64 = ((u64)(x)) + ((u64)(y)) + ((u64)(carry));
	u32 sum = ((u32)(sum64));
	u32 carry_out = ((u32)(sum64 >> 32));
	return (multi_return_u32_u32){.arg0=sum, .arg1=carry_out};
}

multi_return_u64_u64 math__bits__add_64(u64 x, u64 y, u64 carry) {
	u64 sum = x + y + carry;
	u64 carry_out = ((((x & y)) | ((((x | y)) & ~sum)))) >> 63;
	return (multi_return_u64_u64){.arg0=sum, .arg1=carry_out};
}

multi_return_u32_u32 math__bits__sub_32(u32 x, u32 y, u32 borrow) {
	u32 diff = x - y - borrow;
	u32 borrow_out = ((((~x & y)) | ((~((x ^ y)) & diff)))) >> 31;
	return (multi_return_u32_u32){.arg0=diff, .arg1=borrow_out};
}

multi_return_u64_u64 math__bits__sub_64(u64 x, u64 y, u64 borrow) {
	u64 diff = x - y - borrow;
	u64 borrow_out = ((((~x & y)) | ((~((x ^ y)) & diff)))) >> 63;
	return (multi_return_u64_u64){.arg0=diff, .arg1=borrow_out};
}

multi_return_u32_u32 math__bits__mul_32(u32 x, u32 y) {
	u64 tmp = ((u64)(x)) * ((u64)(y));
	u32 hi = ((u32)(tmp >> 32));
	u32 lo = ((u32)(tmp));
	return (multi_return_u32_u32){.arg0=hi, .arg1=lo};
}

multi_return_u64_u64 math__bits__mul_64(u64 x, u64 y) {
	u64 x0 = (x & _const_math__bits__mask32);
	u64 x1 = x >> 32;
	u64 y0 = (y & _const_math__bits__mask32);
	u64 y1 = y >> 32;
	u64 w0 = x0 * y0;
	u64 t = x1 * y0 + (w0 >> 32);
	u64 w1 = (t & _const_math__bits__mask32);
	u64 w2 = t >> 32;
	w1 += x0 * y1;
	u64 hi = x1 * y1 + w2 + (w1 >> 32);
	u64 lo = x * y;
	return (multi_return_u64_u64){.arg0=hi, .arg1=lo};
}

multi_return_u32_u32 math__bits__div_32(u32 hi, u32 lo, u32 y) {
	if (y != 0 && y <= hi) {
		v_panic(_const_math__bits__overflow_error);
	}
	u64 z = ((((u64)(hi)) << 32) | ((u64)(lo)));
	u32 quo = ((u32)(z / ((u64)(y))));
	u32 rem = ((u32)(z % ((u64)(y))));
	return (multi_return_u32_u32){.arg0=quo, .arg1=rem};
}

multi_return_u64_u64 math__bits__div_64(u64 hi, u64 lo, u64 y1) {
	u64 y = y1;
	if (y == 0) {
		v_panic(_const_math__bits__overflow_error);
	}
	if (y <= hi) {
		v_panic(_const_math__bits__overflow_error);
	}
	u32 s = ((u32)(math__bits__leading_zeros_64(y)));
	y <<= s;
	u64 yn1 = y >> 32;
	u64 yn0 = (y & _const_math__bits__mask32);
	u64 un32 = ((hi << s) | (lo >> (64 - s)));
	u64 un10 = lo << s;
	u64 un1 = un10 >> 32;
	u64 un0 = (un10 & _const_math__bits__mask32);
	u64 q1 = un32 / yn1;
	u64 rhat = un32 - q1 * yn1;
	for (;;) {
		if (!(q1 >= _const_math__bits__two32 || q1 * yn0 > _const_math__bits__two32 * rhat + un1)) break;
		q1--;
		rhat += yn1;
		if (rhat >= _const_math__bits__two32) {
			break;
		}
	}
	u64 un21 = un32 * _const_math__bits__two32 + un1 - q1 * y;
	u64 q0 = un21 / yn1;
	rhat = un21 - q0 * yn1;
	for (;;) {
		if (!(q0 >= _const_math__bits__two32 || q0 * yn0 > _const_math__bits__two32 * rhat + un0)) break;
		q0--;
		rhat += yn1;
		if (rhat >= _const_math__bits__two32) {
			break;
		}
	}
	return (multi_return_u64_u64){.arg0=q1 * _const_math__bits__two32 + q0, .arg1=(un21 * _const_math__bits__two32 + un0 - q0 * y) >> s};
}

u32 math__bits__rem_32(u32 hi, u32 lo, u32 y) {
	return ((u32)((((((u64)(hi)) << 32) | ((u64)(lo)))) % ((u64)(y))));
}

u64 math__bits__rem_64(u64 hi, u64 lo, u64 y) {
	multi_return_u64_u64 mr_15272 = math__bits__div_64(hi % y, lo, y);
	u64 rem = mr_15272.arg1;
	return rem;
}

VV_LOCAL_SYMBOL multi_return_u32_u32_u32 strconv__lsr96(u32 s2, u32 s1, u32 s0) {
	u32 r0 = ((u32)(0U));
	u32 r1 = ((u32)(0U));
	u32 r2 = ((u32)(0U));
	r0 = ((s0 >> 1) | (((s1 & ((u32)(1U)))) << 31));
	r1 = ((s1 >> 1) | (((s2 & ((u32)(1U)))) << 31));
	r2 = s2 >> 1;
	return (multi_return_u32_u32_u32){.arg0=r2, .arg1=r1, .arg2=r0};
}

VV_LOCAL_SYMBOL multi_return_u32_u32_u32 strconv__lsl96(u32 s2, u32 s1, u32 s0) {
	u32 r0 = ((u32)(0U));
	u32 r1 = ((u32)(0U));
	u32 r2 = ((u32)(0U));
	r2 = ((s2 << 1) | (((s1 & (((u32)(1U)) << 31))) >> 31));
	r1 = ((s1 << 1) | (((s0 & (((u32)(1U)) << 31))) >> 31));
	r0 = s0 << 1;
	return (multi_return_u32_u32_u32){.arg0=r2, .arg1=r1, .arg2=r0};
}

VV_LOCAL_SYMBOL multi_return_u32_u32_u32 strconv__add96(u32 s2, u32 s1, u32 s0, u32 d2, u32 d1, u32 d0) {
	u64 w = ((u64)(0U));
	u32 r0 = ((u32)(0U));
	u32 r1 = ((u32)(0U));
	u32 r2 = ((u32)(0U));
	w = ((u64)(s0)) + ((u64)(d0));
	r0 = ((u32)(w));
	w >>= 32;
	w += ((u64)(s1)) + ((u64)(d1));
	r1 = ((u32)(w));
	w >>= 32;
	w += ((u64)(s2)) + ((u64)(d2));
	r2 = ((u32)(w));
	return (multi_return_u32_u32_u32){.arg0=r2, .arg1=r1, .arg2=r0};
}

VV_LOCAL_SYMBOL multi_return_u32_u32_u32 strconv__sub96(u32 s2, u32 s1, u32 s0, u32 d2, u32 d1, u32 d0) {
	u64 w = ((u64)(0U));
	u32 r0 = ((u32)(0U));
	u32 r1 = ((u32)(0U));
	u32 r2 = ((u32)(0U));
	w = ((u64)(s0)) - ((u64)(d0));
	r0 = ((u32)(w));
	w >>= 32;
	w += ((u64)(s1)) - ((u64)(d1));
	r1 = ((u32)(w));
	w >>= 32;
	w += ((u64)(s2)) - ((u64)(d2));
	r2 = ((u32)(w));
	return (multi_return_u32_u32_u32){.arg0=r2, .arg1=r1, .arg2=r0};
}

VV_LOCAL_SYMBOL bool strconv__is_digit(byte x) {
	return (x >= _const_strconv__c_zero && x <= _const_strconv__c_nine) == true;
}

VV_LOCAL_SYMBOL bool strconv__is_space(byte x) {
	return (x == '\t' || x == '\n' || x == '\v' || x == '\f' || x == '\r' || x == ' ');
}

VV_LOCAL_SYMBOL bool strconv__is_exp(byte x) {
	return (x == 'E' || x == 'e') == true;
}

VV_LOCAL_SYMBOL multi_return_int_strconv__PrepNumber strconv__parser(string s) {
	int state = _const_strconv__fsm_a;
	int digx = 0;
	byte c = ((byte)(' '));
	int result = _const_strconv__parser_ok;
	bool expneg = false;
	int expexp = 0;
	int i = 0;
	strconv__PrepNumber pn = (strconv__PrepNumber){.negative = 0,.exponent = 0,.mantissa = 0,};
	for (;;) {
		if (!(state != _const_strconv__fsm_stop)) break;
		int _t8 = state;
		if (_t8 == _const_strconv__fsm_a) {
			if (strconv__is_space(c) == true) {
				c = string_at(s, i);
				i++;
			} else {
				state = _const_strconv__fsm_b;
			}
		} else if (_t8 == _const_strconv__fsm_b) {
			state = _const_strconv__fsm_c;
			if (c == _const_strconv__c_plus) {
				c = string_at(s, i);
				i++;
			} else if (c == _const_strconv__c_minus) {
				pn.negative = true;
				c = string_at(s, i);
				i++;
			} else if (strconv__is_digit(c)) {
			} else if (c == _const_strconv__c_dpoint) {
			} else {
				state = _const_strconv__fsm_stop;
			}
		} else if (_t8 == _const_strconv__fsm_c) {
			if (c == _const_strconv__c_zero) {
				c = string_at(s, i++);
			} else if (c == _const_strconv__c_dpoint) {
				c = string_at(s, i++);
				state = _const_strconv__fsm_d;
			} else {
				state = _const_strconv__fsm_e;
			}
		} else if (_t8 == _const_strconv__fsm_d) {
			if (c == _const_strconv__c_zero) {
				c = string_at(s, i++);
				if (pn.exponent > -2147483647) {
					pn.exponent--;
				}
			} else {
				state = _const_strconv__fsm_f;
			}
		} else if (_t8 == _const_strconv__fsm_e) {
			if (strconv__is_digit(c)) {
				if (digx < _const_strconv__digits) {
					pn.mantissa *= 10;
					pn.mantissa += ((u64)(c - _const_strconv__c_zero));
					digx++;
				} else if (pn.exponent < 2147483647) {
					pn.exponent++;
				}
				c = string_at(s, i++);
			} else if (c == _const_strconv__c_dpoint) {
				c = string_at(s, i++);
				state = _const_strconv__fsm_f;
			} else {
				state = _const_strconv__fsm_f;
			}
		} else if (_t8 == _const_strconv__fsm_f) {
			if (strconv__is_digit(c)) {
				if (digx < _const_strconv__digits) {
					pn.mantissa *= 10;
					pn.mantissa += ((u64)(c - _const_strconv__c_zero));
					pn.exponent--;
					digx++;
				}
				c = string_at(s, i++);
			} else if (strconv__is_exp(c)) {
				c = string_at(s, i++);
				state = _const_strconv__fsm_g;
			} else {
				state = _const_strconv__fsm_g;
			}
		} else if (_t8 == _const_strconv__fsm_g) {
			if (c == _const_strconv__c_plus) {
				c = string_at(s, i++);
			} else if (c == _const_strconv__c_minus) {
				expneg = true;
				c = string_at(s, i++);
			}
			state = _const_strconv__fsm_h;
		} else if (_t8 == _const_strconv__fsm_h) {
			if (c == _const_strconv__c_zero) {
				c = string_at(s, i++);
			} else {
				state = _const_strconv__fsm_i;
			}
		} else if (_t8 == _const_strconv__fsm_i) {
			if (strconv__is_digit(c)) {
				if (expexp < 214748364) {
					expexp *= 10;
					expexp += ((int)(c - _const_strconv__c_zero));
				}
				c = string_at(s, i++);
			} else {
				state = _const_strconv__fsm_stop;
			}
		} else {
		};
		if (i >= s.len) {
			state = _const_strconv__fsm_stop;
		}
	}
	if (expneg) {
		expexp = -expexp;
	}
	pn.exponent += expexp;
	if (pn.mantissa == 0) {
		if (pn.negative) {
			result = _const_strconv__parser_mzero;
		} else {
			result = _const_strconv__parser_pzero;
		}
	} else if (pn.exponent > 309) {
		if (pn.negative) {
			result = _const_strconv__parser_minf;
		} else {
			result = _const_strconv__parser_pinf;
		}
	} else if (pn.exponent < -328) {
		if (pn.negative) {
			result = _const_strconv__parser_mzero;
		} else {
			result = _const_strconv__parser_pzero;
		}
	}
	return (multi_return_int_strconv__PrepNumber){.arg0=result, .arg1=pn};
}

VV_LOCAL_SYMBOL u64 strconv__converter(strconv__PrepNumber* pn) {
	int binexp = 92;
	u32 s2 = ((u32)(0U));
	u32 s1 = ((u32)(0U));
	u32 s0 = ((u32)(0U));
	u32 q2 = ((u32)(0U));
	u32 q1 = ((u32)(0U));
	u32 q0 = ((u32)(0U));
	u32 r2 = ((u32)(0U));
	u32 r1 = ((u32)(0U));
	u32 r0 = ((u32)(0U));
	u32 mask28 = ((u32)(0xF << 28));
	u64 result = ((u64)(0U));
	s0 = ((u32)((pn->mantissa & ((u64)(0x00000000FFFFFFFFU)))));
	s1 = ((u32)(pn->mantissa >> 32));
	s2 = ((u32)(0U));
	for (;;) {
		if (!(pn->exponent > 0)) break;
		multi_return_u32_u32_u32 mr_6682 = strconv__lsl96(s2, s1, s0);
		q2 = mr_6682.arg0;
		q1 = mr_6682.arg1;
		q0 = mr_6682.arg2;
		multi_return_u32_u32_u32 mr_6726 = strconv__lsl96(q2, q1, q0);
		r2 = mr_6726.arg0;
		r1 = mr_6726.arg1;
		r0 = mr_6726.arg2;
		multi_return_u32_u32_u32 mr_6780 = strconv__lsl96(r2, r1, r0);
		s2 = mr_6780.arg0;
		s1 = mr_6780.arg1;
		s0 = mr_6780.arg2;
		multi_return_u32_u32_u32 mr_6834 = strconv__add96(s2, s1, s0, q2, q1, q0);
		s2 = mr_6834.arg0;
		s1 = mr_6834.arg1;
		s0 = mr_6834.arg2;
		pn->exponent--;
		for (;;) {
			if (!(((s2 & mask28)) != 0)) break;
			multi_return_u32_u32_u32 mr_6955 = strconv__lsr96(s2, s1, s0);
			q2 = mr_6955.arg0;
			q1 = mr_6955.arg1;
			q0 = mr_6955.arg2;
			binexp++;
			s2 = q2;
			s1 = q1;
			s0 = q0;
		}
	}
	for (;;) {
		if (!(pn->exponent < 0)) break;
		for (;;) {
			if (!(!(((s2 & (((u32)(1U)) << 31))) != 0))) break;
			multi_return_u32_u32_u32 mr_7098 = strconv__lsl96(s2, s1, s0);
			q2 = mr_7098.arg0;
			q1 = mr_7098.arg1;
			q0 = mr_7098.arg2;
			binexp--;
			s2 = q2;
			s1 = q1;
			s0 = q0;
		}
		q2 = s2 / _const_strconv__c_ten;
		r1 = s2 % _const_strconv__c_ten;
		r2 = ((s1 >> 8) | (r1 << 24));
		q1 = r2 / _const_strconv__c_ten;
		r1 = r2 % _const_strconv__c_ten;
		r2 = (((((s1 & ((u32)(0xFFU)))) << 16) | (s0 >> 16)) | (r1 << 24));
		r0 = r2 / _const_strconv__c_ten;
		r1 = r2 % _const_strconv__c_ten;
		q1 = ((q1 << 8) | (((r0 & ((u32)(0x00FF0000U)))) >> 16));
		q0 = r0 << 16;
		r2 = (((s0 & ((u32)(0xFFFFU)))) | (r1 << 16));
		q0 |= r2 / _const_strconv__c_ten;
		s2 = q2;
		s1 = q1;
		s0 = q0;
		pn->exponent++;
	}
	if (s2 != 0 || s1 != 0 || s0 != 0) {
		for (;;) {
			if (!(((s2 & mask28)) == 0)) break;
			multi_return_u32_u32_u32 mr_7757 = strconv__lsl96(s2, s1, s0);
			q2 = mr_7757.arg0;
			q1 = mr_7757.arg1;
			q0 = mr_7757.arg2;
			binexp--;
			s2 = q2;
			s1 = q1;
			s0 = q0;
		}
	}
	int nbit = 7;
	u32 check_round_bit = ((u32)(1U)) << ((u32)(nbit));
	u32 check_round_mask = ((u32)(0xFFFFFFFFU)) << ((u32)(nbit));
	if (((s1 & check_round_bit)) != 0) {
		if (((s1 & ~check_round_mask)) != 0) {
			multi_return_u32_u32_u32 mr_8830 = strconv__add96(s2, s1, s0, 0, check_round_bit, 0);
			s2 = mr_8830.arg0;
			s1 = mr_8830.arg1;
			s0 = mr_8830.arg2;
		} else {
			if (((s1 & (check_round_bit << ((u32)(1U))))) != 0) {
				multi_return_u32_u32_u32 mr_9020 = strconv__add96(s2, s1, s0, 0, check_round_bit, 0);
				s2 = mr_9020.arg0;
				s1 = mr_9020.arg1;
				s0 = mr_9020.arg2;
			}
		}
		s1 = (s1 & check_round_mask);
		s0 = ((u32)(0U));
		if ((s2 & (mask28 << ((u32)(1U)))) != 0) {
			multi_return_u32_u32_u32 mr_9220 = strconv__lsr96(s2, s1, s0);
			q2 = mr_9220.arg0;
			q1 = mr_9220.arg1;
			q0 = mr_9220.arg2;
			binexp--;
			s2 = q2;
			s1 = q1;
			s0 = q0;
		}
	}
	binexp += 1023;
	if (binexp > 2046) {
		if (pn->negative) {
			result = _const_strconv__double_minus_infinity;
		} else {
			result = _const_strconv__double_plus_infinity;
		}
	} else if (binexp < 1) {
		if (pn->negative) {
			result = _const_strconv__double_minus_zero;
		} else {
			result = _const_strconv__double_plus_zero;
		}
	} else if (s2 != 0) {
		u64 q = ((u64)(0U));
		u64 binexs2 = ((u64)(binexp)) << 52;
		q = (((((u64)((s2 & ~mask28))) << 24) | ((((u64)(s1)) + ((u64)(128U))) >> 8)) | binexs2);
		if (pn->negative) {
			q |= (((u64)(1U)) << 63);
		}
		result = q;
	}
	return result;
}

f64 strconv__atof64(string s) {
	strconv__PrepNumber pn = (strconv__PrepNumber){.negative = 0,.exponent = 0,.mantissa = 0,};
	int res_parsing = 0;
	strconv__Float64u res = (strconv__Float64u){
#ifndef __cplusplus
0
#endif
};
	multi_return_int_strconv__PrepNumber mr_10225 = strconv__parser(string_add(s, tos_lit(" ")));
	res_parsing = mr_10225.arg0;
	pn = mr_10225.arg1;
	int _t9 = res_parsing;
	if (_t9 == _const_strconv__parser_ok) {
		res.u = strconv__converter((voidptr)&/*qq*/pn);
	} else if (_t9 == _const_strconv__parser_pzero) {
		res.u = _const_strconv__double_plus_zero;
	} else if (_t9 == _const_strconv__parser_mzero) {
		res.u = _const_strconv__double_minus_zero;
	} else if (_t9 == _const_strconv__parser_pinf) {
		res.u = _const_strconv__double_plus_infinity;
	} else if (_t9 == _const_strconv__parser_minf) {
		res.u = _const_strconv__double_minus_infinity;
	} else {
	};
	return res.f;
}

f64 strconv__atof_quick(string s) {
	strconv__Float64u f = (strconv__Float64u){
#ifndef __cplusplus
0
#endif
};
	f64 sign = ((f64)(1.0));
	int i = 0;
	for (;;) {
		if (!(i < s.len && string_at(s, i) == ' ')) break;
		i++;
	}
	if (i < s.len) {
		if (string_at(s, i) == '-') {
			sign = -1.0;
			i++;
		} else if (string_at(s, i) == '+') {
			i++;
		}
	}
	if (string_at(s, i) == 'i' && i + 2 < s.len && string_at(s, i + 1) == 'n' && string_at(s, i + 2) == 'f') {
		if (sign > 0.0) {
			f.u = _const_strconv__double_plus_infinity;
		} else {
			f.u = _const_strconv__double_minus_infinity;
		}
		return f.f;
	}
	for (;;) {
		if (!(i < s.len && string_at(s, i) == '0')) break;
		i++;
		if (i >= s.len) {
			if (sign > 0.0) {
				f.u = _const_strconv__double_plus_zero;
			} else {
				f.u = _const_strconv__double_minus_zero;
			}
			return f.f;
		}
	}
	for (;;) {
		if (!(i < s.len && (string_at(s, i) >= '0' && string_at(s, i) <= '9'))) break;
		f.f *= ((f64)(10.0));
		f.f += ((f64)(string_at(s, i) - '0'));
		i++;
	}
	if (i < s.len && string_at(s, i) == '.') {
		i++;
		f64 frac_mul = ((f64)(0.1));
		for (;;) {
			if (!(i < s.len && (string_at(s, i) >= '0' && string_at(s, i) <= '9'))) break;
			f.f += ((f64)(string_at(s, i) - '0')) * frac_mul;
			frac_mul *= ((f64)(0.1));
			i++;
		}
	}
	if (i < s.len && (string_at(s, i) == 'e' || string_at(s, i) == 'E')) {
		i++;
		int exp = 0;
		int exp_sign = 1;
		if (i < s.len) {
			if (string_at(s, i) == '-') {
				exp_sign = -1;
				i++;
			} else if (string_at(s, i) == '+') {
				i++;
			}
		}
		for (;;) {
			if (!(i < s.len && string_at(s, i) == '0')) break;
			i++;
		}
		for (;;) {
			if (!(i < s.len && (string_at(s, i) >= '0' && string_at(s, i) <= '9'))) break;
			exp *= 10;
			exp += ((int)(string_at(s, i) - '0'));
			i++;
		}
		if (exp_sign == 1) {
			if (exp > _const_strconv__pos_exp.len) {
				if (sign > 0) {
					f.u = _const_strconv__double_plus_infinity;
				} else {
					f.u = _const_strconv__double_minus_infinity;
				}
				return f.f;
			}
			strconv__Float64u tmp_mul = (strconv__Float64u){.u = (*(u64*)/*ee elem_typ */array_get(_const_strconv__pos_exp, exp)),};
			f.f = f.f * tmp_mul.f;
		} else {
			if (exp > _const_strconv__neg_exp.len) {
				if (sign > 0) {
					f.u = _const_strconv__double_plus_zero;
				} else {
					f.u = _const_strconv__double_minus_zero;
				}
				return f.f;
			}
			strconv__Float64u tmp_mul = (strconv__Float64u){.u = (*(u64*)/*ee elem_typ */array_get(_const_strconv__neg_exp, exp)),};
			f.f = f.f * tmp_mul.f;
		}
	}
	f.f = f.f * sign;
	return f.f;
}

byte strconv__byte_to_lower(byte c) {
	return (c | ('x' - 'X'));
}

u64 strconv__common_parse_uint(string s, int _base, int _bit_size, bool error_on_non_digit, bool error_on_high_digit) {
	multi_return_u64_int mr_816 = strconv__common_parse_uint2(s, _base, _bit_size);
	u64 result = mr_816.arg0;
	int v_error = mr_816.arg1;
	if (v_error != 0) {
		if (v_error > 0 && (error_on_non_digit || error_on_high_digit)) {
			return ((u64)(0U));
		}
	}
	return result;
}

multi_return_u64_int strconv__common_parse_uint2(string s, int _base, int _bit_size) {
	int bit_size = _bit_size;
	int base = _base;
	if (s.len < 1 || !strconv__underscore_ok(s)) {
		return (multi_return_u64_int){.arg0=((u64)(0U)), .arg1=1};
	}
	bool base0 = base == 0;
	int start_index = 0;
	if (2 <= base && base <= 36) {
	} else if (base == 0) {
		base = 10;
		if (string_at(s, 0) == '0') {
			if (s.len >= 3 && strconv__byte_to_lower(string_at(s, 1)) == 'b') {
				base = 2;
				start_index += 2;
			} else if (s.len >= 3 && strconv__byte_to_lower(string_at(s, 1)) == 'o') {
				base = 8;
				start_index += 2;
			} else if (s.len >= 3 && strconv__byte_to_lower(string_at(s, 1)) == 'x') {
				base = 16;
				start_index += 2;
			} else if (s.len >= 2 && (string_at(s, 1) >= '0' && string_at(s, 1) <= '9')) {
				base = 10;
				start_index++;
			} else {
				base = 8;
				start_index++;
			}
		}
	} else {
		return (multi_return_u64_int){.arg0=((u64)(0U)), .arg1=-1};
	}
	if (bit_size == 0) {
		bit_size = _const_strconv__int_size;
	} else if (bit_size < 0 || bit_size > 64) {
		return (multi_return_u64_int){.arg0=((u64)(0U)), .arg1=-2};
	}
	u64 cutoff = _const_strconv__max_u64 / ((u64)(base)) + ((u64)(1U));
	u64 max_val = (bit_size == 64 ? (_const_strconv__max_u64) : ((((u64)(1U)) << ((u64)(bit_size))) - ((u64)(1U))));
	u64 n = ((u64)(0U));
	for (int i = start_index; i < s.len; ++i) {
		byte c = string_at(s, i);
		byte cl = strconv__byte_to_lower(c);
		byte d = ((byte)(0));
		if (c == '_' && base0) {
			continue;
		} else if ('0' <= c && c <= '9') {
			d = c - '0';
		} else if ('a' <= cl && cl <= 'z') {
			d = cl - 'a' + 10;
		} else {
			return (multi_return_u64_int){.arg0=n, .arg1=i + 1};
		}
		if (d >= ((byte)(base))) {
			return (multi_return_u64_int){.arg0=n, .arg1=i + 1};
		}
		if (n >= cutoff) {
			return (multi_return_u64_int){.arg0=max_val, .arg1=-3};
		}
		n *= ((u64)(base));
		u64 n1 = n + ((u64)(d));
		if (n1 < n || n1 > max_val) {
			return (multi_return_u64_int){.arg0=max_val, .arg1=-3};
		}
		n = n1;
	}
	return (multi_return_u64_int){.arg0=n, .arg1=0};
}

u64 strconv__parse_uint(string s, int _base, int _bit_size) {
	return strconv__common_parse_uint(s, _base, _bit_size, true, true);
}

i64 strconv__common_parse_int(string _s, int base, int _bit_size, bool error_on_non_digit, bool error_on_high_digit) {
	string s = _s;
	int bit_size = _bit_size;
	if (s.len < 1) {
		return ((i64)(0));
	}
	bool neg = false;
	if (string_at(s, 0) == '+') {
		s = string_substr(s, 1, s.len);
	} else if (string_at(s, 0) == '-') {
		neg = true;
		s = string_substr(s, 1, s.len);
	}
	u64 un = strconv__common_parse_uint(s, base, bit_size, error_on_non_digit, error_on_high_digit);
	if (un == 0) {
		return ((i64)(0));
	}
	if (bit_size == 0) {
		bit_size = _const_strconv__int_size;
	}
	u64 cutoff = ((u64)(1U)) << ((u64)(bit_size - 1));
	if (!neg && un >= cutoff) {
		return ((i64)(cutoff - ((u64)(1U))));
	}
	if (neg && un > cutoff) {
		return -((i64)(cutoff));
	}
	return (neg ? (-((i64)(un))) : (((i64)(un))));
}

i64 strconv__parse_int(string _s, int base, int _bit_size) {
	return strconv__common_parse_int(_s, base, _bit_size, true, true);
}

int strconv__atoi(string s) {
	if ((_const_strconv__int_size == 32 && (0 < s.len && s.len < 10)) || (_const_strconv__int_size == 64 && (0 < s.len && s.len < 19))) {
		int start_idx = 0;
		if (string_at(s, 0) == '-' || string_at(s, 0) == '+') {
			start_idx++;
			if (s.len - start_idx < 1) {
				return 0;
			}
		}
		int n = 0;
		for (int i = start_idx; i < s.len; ++i) {
			rune ch = string_at(s, i) - '0';
			if (ch > 9) {
				return 0;
			}
			n = n * 10 + ((int)(ch));
		}
		return (string_at(s, 0) == '-' ? (-n) : (n));
	}
	i64 int64 = strconv__parse_int(s, 10, 0);
	return ((int)(int64));
}

VV_LOCAL_SYMBOL bool strconv__underscore_ok(string s) {
	rune saw = '^';
	int i = 0;
	if (s.len >= 1 && (string_at(s, 0) == '-' || string_at(s, 0) == '+')) {
		i++;
	}
	bool hex = false;
	if (s.len - i >= 2 && string_at(s, i) == '0' && (strconv__byte_to_lower(string_at(s, i + 1)) == 'b' || strconv__byte_to_lower(string_at(s, i + 1)) == 'o' || strconv__byte_to_lower(string_at(s, i + 1)) == 'x')) {
		saw = '0';
		hex = strconv__byte_to_lower(string_at(s, i + 1)) == 'x';
		i += 2;
	}
	for (; i < s.len; i++) {
		if (('0' <= string_at(s, i) && string_at(s, i) <= '9') || (hex && 'a' <= strconv__byte_to_lower(string_at(s, i)) && strconv__byte_to_lower(string_at(s, i)) <= 'f')) {
			saw = '0';
			continue;
		}
		if (string_at(s, i) == '_') {
			if (saw != '0') {
				return false;
			}
			saw = '_';
			continue;
		}
		if (saw == '_') {
			return false;
		}
		saw = '!';
	}
	return saw != '_';
}

string strconv__Dec32_get_string_32(strconv__Dec32 d, bool neg, int i_n_digit, int i_pad_digit) {
	int n_digit = i_n_digit + 1;
	int pad_digit = i_pad_digit + 1;
	u32 out = d.m;
	int out_len = strconv__decimal_len_32(out);
	int out_len_original = out_len;
	int fw_zeros = 0;
	if (pad_digit > out_len) {
		fw_zeros = pad_digit - out_len;
	}
	array_byte buf = __new_array_with_default(((int)(out_len + 5 + 1 + 1)), 0, sizeof(byte), 0);
	int i = 0;
	if (neg) {
		array_set(&buf, i, &(byte[]) { '-' });
		i++;
	}
	int disp = 0;
	if (out_len <= 1) {
		disp = 1;
	}
	if (n_digit < out_len) {
		out += (*(u32*)/*ee elem_typ */array_get(_const_strconv__ten_pow_table_32, out_len - n_digit - 1)) * 5;
		out /= (*(u32*)/*ee elem_typ */array_get(_const_strconv__ten_pow_table_32, out_len - n_digit));
		out_len = n_digit;
	}
	int y = i + out_len;
	int x = 0;
	for (;;) {
		if (!(x < (out_len - disp - 1))) break;
		array_set(&buf, y - x, &(byte[]) { '0' + ((byte)(out % 10)) });
		out /= 10;
		i++;
		x++;
	}
	if (out_len >= 1) {
		array_set(&buf, y - x, &(byte[]) { '.' });
		x++;
		i++;
	}
	if (y - x >= 0) {
		array_set(&buf, y - x, &(byte[]) { '0' + ((byte)(out % 10)) });
		i++;
	}
	for (;;) {
		if (!(fw_zeros > 0)) break;
		array_set(&buf, i++, &(byte[]) { '0' });
		fw_zeros--;
	}
	array_set(&buf, i, &(byte[]) { 'e' });
	i++;
	int exp = d.e + out_len_original - 1;
	if (exp < 0) {
		array_set(&buf, i, &(byte[]) { '-' });
		i++;
		exp = -exp;
	} else {
		array_set(&buf, i, &(byte[]) { '+' });
		i++;
	}
	int d1 = exp % 10;
	int d0 = exp / 10;
	array_set(&buf, i, &(byte[]) { '0' + ((byte)(d0)) });
	i++;
	array_set(&buf, i, &(byte[]) { '0' + ((byte)(d1)) });
	i++;
	array_set(&buf, i, &(byte[]) { 0 });
	return tos(((byteptr)(&(*(byte*)/*ee elem_typ */array_get(buf, 0)))), i);
}

VV_LOCAL_SYMBOL multi_return_strconv__Dec32_bool strconv__f32_to_decimal_exact_int(u32 i_mant, u32 exp) {
	strconv__Dec32 d = (strconv__Dec32){.m = 0,.e = 0,};
	u32 e = exp - _const_strconv__bias32;
	if (e > _const_strconv__mantbits32) {
		return (multi_return_strconv__Dec32_bool){.arg0=d, .arg1=false};
	}
	u32 shift = _const_strconv__mantbits32 - e;
	u32 mant = (i_mant | 0x00800000);
	d.m = mant >> shift;
	if ((d.m << shift) != mant) {
		return (multi_return_strconv__Dec32_bool){.arg0=d, .arg1=false};
	}
	for (;;) {
		if (!((d.m % 10) == 0)) break;
		d.m /= 10;
		d.e++;
	}
	return (multi_return_strconv__Dec32_bool){.arg0=d, .arg1=true};
}

strconv__Dec32 strconv__f32_to_decimal(u32 mant, u32 exp) {
	int e2 = 0;
	u32 m2 = ((u32)(0U));
	if (exp == 0) {
		e2 = 1 - _const_strconv__bias32 - ((int)(_const_strconv__mantbits32)) - 2;
		m2 = mant;
	} else {
		e2 = ((int)(exp)) - _const_strconv__bias32 - ((int)(_const_strconv__mantbits32)) - 2;
		m2 = ((((u32)(1U)) << _const_strconv__mantbits32) | mant);
	}
	bool even = ((m2 & 1)) == 0;
	bool accept_bounds = even;
	u32 mv = ((u32)(4 * m2));
	u32 mp = ((u32)(4 * m2 + 2));
	u32 mm_shift = strconv__bool_to_u32(mant != 0 || exp <= 1);
	u32 mm = ((u32)(4 * m2 - 1 - mm_shift));
	u32 vr = ((u32)(0U));
	u32 vp = ((u32)(0U));
	u32 vm = ((u32)(0U));
	int e10 = 0;
	bool vm_is_trailing_zeros = false;
	bool vr_is_trailing_zeros = false;
	byte last_removed_digit = ((byte)(0));
	if (e2 >= 0) {
		u32 q = strconv__log10_pow2(e2);
		e10 = ((int)(q));
		int k = _const_strconv__pow5_inv_num_bits_32 + strconv__pow5_bits(((int)(q))) - 1;
		int i = -e2 + ((int)(q)) + k;
		vr = strconv__mul_pow5_invdiv_pow2(mv, q, i);
		vp = strconv__mul_pow5_invdiv_pow2(mp, q, i);
		vm = strconv__mul_pow5_invdiv_pow2(mm, q, i);
		if (q != 0 && (vp - 1) / 10 <= vm / 10) {
			int l = _const_strconv__pow5_inv_num_bits_32 + strconv__pow5_bits(((int)(q - 1))) - 1;
			last_removed_digit = ((byte)(strconv__mul_pow5_invdiv_pow2(mv, q - 1, -e2 + ((int)(q - 1)) + l) % 10));
		}
		if (q <= 9) {
			if (mv % 5 == 0) {
				vr_is_trailing_zeros = strconv__multiple_of_power_of_five_32(mv, q);
			} else if (accept_bounds) {
				vm_is_trailing_zeros = strconv__multiple_of_power_of_five_32(mm, q);
			} else if (strconv__multiple_of_power_of_five_32(mp, q)) {
				vp--;
			}
		}
	} else {
		u32 q = strconv__log10_pow5(-e2);
		e10 = ((int)(q)) + e2;
		int i = -e2 - ((int)(q));
		int k = strconv__pow5_bits(i) - _const_strconv__pow5_num_bits_32;
		int j = ((int)(q)) - k;
		vr = strconv__mul_pow5_div_pow2(mv, ((u32)(i)), j);
		vp = strconv__mul_pow5_div_pow2(mp, ((u32)(i)), j);
		vm = strconv__mul_pow5_div_pow2(mm, ((u32)(i)), j);
		if (q != 0 && ((vp - 1) / 10) <= vm / 10) {
			j = ((int)(q)) - 1 - (strconv__pow5_bits(i + 1) - _const_strconv__pow5_num_bits_32);
			last_removed_digit = ((byte)(strconv__mul_pow5_div_pow2(mv, ((u32)(i + 1)), j) % 10));
		}
		if (q <= 1) {
			vr_is_trailing_zeros = true;
			if (accept_bounds) {
				vm_is_trailing_zeros = mm_shift == 1;
			} else {
				vp--;
			}
		} else if (q < 31) {
			vr_is_trailing_zeros = strconv__multiple_of_power_of_two_32(mv, q - 1);
		}
	}
	int removed = 0;
	u32 out = ((u32)(0U));
	if (vm_is_trailing_zeros || vr_is_trailing_zeros) {
		for (;;) {
			if (!(vp / 10 > vm / 10)) break;
			vm_is_trailing_zeros = vm_is_trailing_zeros && (vm % 10) == 0;
			vr_is_trailing_zeros = vr_is_trailing_zeros && (last_removed_digit == 0);
			last_removed_digit = ((byte)(vr % 10));
			vr /= 10;
			vp /= 10;
			vm /= 10;
			removed++;
		}
		if (vm_is_trailing_zeros) {
			for (;;) {
				if (!(vm % 10 == 0)) break;
				vr_is_trailing_zeros = vr_is_trailing_zeros && (last_removed_digit == 0);
				last_removed_digit = ((byte)(vr % 10));
				vr /= 10;
				vp /= 10;
				vm /= 10;
				removed++;
			}
		}
		if (vr_is_trailing_zeros && (last_removed_digit == 5) && (vr % 2) == 0) {
			last_removed_digit = 4;
		}
		out = vr;
		if ((vr == vm && (!accept_bounds || !vm_is_trailing_zeros)) || last_removed_digit >= 5) {
			out++;
		}
	} else {
		for (;;) {
			if (!(vp / 10 > vm / 10)) break;
			last_removed_digit = ((byte)(vr % 10));
			vr /= 10;
			vp /= 10;
			vm /= 10;
			removed++;
		}
		out = vr + strconv__bool_to_u32(vr == vm || last_removed_digit >= 5);
	}
	return (strconv__Dec32){.m = out,.e = e10 + removed,};
}

string strconv__f32_to_str(f32 f, int n_digit) {
	strconv__Uf32 u1 = (strconv__Uf32){
#ifndef __cplusplus
0
#endif
};
	u1.f = f;
	u32 u = u1.u;
	bool neg = (u >> (_const_strconv__mantbits32 + _const_strconv__expbits32)) != 0;
	u32 mant = (u & ((((u32)(1U)) << _const_strconv__mantbits32) - ((u32)(1U))));
	u32 exp = ((u >> _const_strconv__mantbits32) & ((((u32)(1U)) << _const_strconv__expbits32) - ((u32)(1U))));
	if ((exp == _const_strconv__maxexp32) || (exp == 0 && mant == 0)) {
		return strconv__get_string_special(neg, exp == 0, mant == 0);
	}
	multi_return_strconv__Dec32_bool mr_7979 = strconv__f32_to_decimal_exact_int(mant, exp);
	strconv__Dec32 d = mr_7979.arg0;
	bool ok = mr_7979.arg1;
	if (!ok) {
		d = strconv__f32_to_decimal(mant, exp);
	}
	return strconv__Dec32_get_string_32(d, neg, n_digit, 0);
}

string strconv__f32_to_str_pad(f32 f, int n_digit) {
	strconv__Uf32 u1 = (strconv__Uf32){
#ifndef __cplusplus
0
#endif
};
	u1.f = f;
	u32 u = u1.u;
	bool neg = (u >> (_const_strconv__mantbits32 + _const_strconv__expbits32)) != 0;
	u32 mant = (u & ((((u32)(1U)) << _const_strconv__mantbits32) - ((u32)(1U))));
	u32 exp = ((u >> _const_strconv__mantbits32) & ((((u32)(1U)) << _const_strconv__expbits32) - ((u32)(1U))));
	if ((exp == _const_strconv__maxexp32) || (exp == 0 && mant == 0)) {
		return strconv__get_string_special(neg, exp == 0, mant == 0);
	}
	multi_return_strconv__Dec32_bool mr_8687 = strconv__f32_to_decimal_exact_int(mant, exp);
	strconv__Dec32 d = mr_8687.arg0;
	bool ok = mr_8687.arg1;
	if (!ok) {
		d = strconv__f32_to_decimal(mant, exp);
	}
	return strconv__Dec32_get_string_32(d, neg, n_digit, n_digit);
}

VV_LOCAL_SYMBOL string strconv__Dec64_get_string_64(strconv__Dec64 d, bool neg, int i_n_digit, int i_pad_digit) {
	int n_digit = i_n_digit + 1;
	int pad_digit = i_pad_digit + 1;
	u64 out = d.m;
	int d_exp = d.e;
	int out_len = strconv__decimal_len_64(out);
	int out_len_original = out_len;
	int fw_zeros = 0;
	if (pad_digit > out_len) {
		fw_zeros = pad_digit - out_len;
	}
	array_byte buf = __new_array_with_default((out_len + 6 + 1 + 1 + fw_zeros), 0, sizeof(byte), 0);
	int i = 0;
	if (neg) {
		array_set(&buf, i, &(byte[]) { '-' });
		i++;
	}
	int disp = 0;
	if (out_len <= 1) {
		disp = 1;
	}
	if (n_digit < out_len) {
		out += (*(u64*)/*ee elem_typ */array_get(_const_strconv__ten_pow_table_64, out_len - n_digit - 1)) * 5;
		out /= (*(u64*)/*ee elem_typ */array_get(_const_strconv__ten_pow_table_64, out_len - n_digit));
		if (d.m / (*(u64*)/*ee elem_typ */array_get(_const_strconv__ten_pow_table_64, out_len - n_digit)) < out) {
			d_exp++;
			n_digit++;
		}
		out_len = n_digit;
	}
	int y = i + out_len;
	int x = 0;
	for (;;) {
		if (!(x < (out_len - disp - 1))) break;
		array_set(&buf, y - x, &(byte[]) { '0' + ((byte)(out % 10)) });
		out /= 10;
		i++;
		x++;
	}
	if (out_len >= 1) {
		array_set(&buf, y - x, &(byte[]) { '.' });
		x++;
		i++;
	}
	if (y - x >= 0) {
		array_set(&buf, y - x, &(byte[]) { '0' + ((byte)(out % 10)) });
		i++;
	}
	for (;;) {
		if (!(fw_zeros > 0)) break;
		array_set(&buf, i++, &(byte[]) { '0' });
		fw_zeros--;
	}
	array_set(&buf, i, &(byte[]) { 'e' });
	i++;
	int exp = d_exp + out_len_original - 1;
	if (exp < 0) {
		array_set(&buf, i, &(byte[]) { '-' });
		i++;
		exp = -exp;
	} else {
		array_set(&buf, i, &(byte[]) { '+' });
		i++;
	}
	int d2 = exp % 10;
	exp /= 10;
	int d1 = exp % 10;
	int d0 = exp / 10;
	if (d0 > 0) {
		array_set(&buf, i, &(byte[]) { '0' + ((byte)(d0)) });
		i++;
	}
	array_set(&buf, i, &(byte[]) { '0' + ((byte)(d1)) });
	i++;
	array_set(&buf, i, &(byte[]) { '0' + ((byte)(d2)) });
	i++;
	array_set(&buf, i, &(byte[]) { 0 });
	return tos(((byteptr)(&(*(byte*)/*ee elem_typ */array_get(buf, 0)))), i);
}

VV_LOCAL_SYMBOL multi_return_strconv__Dec64_bool strconv__f64_to_decimal_exact_int(u64 i_mant, u64 exp) {
	strconv__Dec64 d = (strconv__Dec64){.m = 0,.e = 0,};
	u64 e = exp - _const_strconv__bias64;
	if (e > _const_strconv__mantbits64) {
		return (multi_return_strconv__Dec64_bool){.arg0=d, .arg1=false};
	}
	u64 shift = _const_strconv__mantbits64 - e;
	u64 mant = (i_mant | ((u64)(0x0010000000000000U)));
	d.m = mant >> shift;
	if ((d.m << shift) != mant) {
		return (multi_return_strconv__Dec64_bool){.arg0=d, .arg1=false};
	}
	for (;;) {
		if (!((d.m % 10) == 0)) break;
		d.m /= 10;
		d.e++;
	}
	return (multi_return_strconv__Dec64_bool){.arg0=d, .arg1=true};
}

VV_LOCAL_SYMBOL strconv__Dec64 strconv__f64_to_decimal(u64 mant, u64 exp) {
	int e2 = 0;
	u64 m2 = ((u64)(0U));
	if (exp == 0) {
		e2 = 1 - _const_strconv__bias64 - ((int)(_const_strconv__mantbits64)) - 2;
		m2 = mant;
	} else {
		e2 = ((int)(exp)) - _const_strconv__bias64 - ((int)(_const_strconv__mantbits64)) - 2;
		m2 = ((((u64)(1U)) << _const_strconv__mantbits64) | mant);
	}
	bool even = ((m2 & 1)) == 0;
	bool accept_bounds = even;
	u64 mv = ((u64)(4 * m2));
	u64 mm_shift = strconv__bool_to_u64(mant != 0 || exp <= 1);
	u64 vr = ((u64)(0U));
	u64 vp = ((u64)(0U));
	u64 vm = ((u64)(0U));
	int e10 = 0;
	bool vm_is_trailing_zeros = false;
	bool vr_is_trailing_zeros = false;
	if (e2 >= 0) {
		u32 q = strconv__log10_pow2(e2) - strconv__bool_to_u32(e2 > 3);
		e10 = ((int)(q));
		int k = _const_strconv__pow5_inv_num_bits_64 + strconv__pow5_bits(((int)(q))) - 1;
		int i = -e2 + ((int)(q)) + k;
		strconv__Uint128 mul = (*(strconv__Uint128*)/*ee elem_typ */array_get(_const_strconv__pow5_inv_split_64, q));
		vr = strconv__mul_shift_64(((u64)(4U)) * m2, mul, i);
		vp = strconv__mul_shift_64(((u64)(4U)) * m2 + ((u64)(2U)), mul, i);
		vm = strconv__mul_shift_64(((u64)(4U)) * m2 - ((u64)(1U)) - mm_shift, mul, i);
		if (q <= 21) {
			if (mv % 5 == 0) {
				vr_is_trailing_zeros = strconv__multiple_of_power_of_five_64(mv, q);
			} else if (accept_bounds) {
				vm_is_trailing_zeros = strconv__multiple_of_power_of_five_64(mv - 1 - mm_shift, q);
			} else if (strconv__multiple_of_power_of_five_64(mv + 2, q)) {
				vp--;
			}
		}
	} else {
		u32 q = strconv__log10_pow5(-e2) - strconv__bool_to_u32(-e2 > 1);
		e10 = ((int)(q)) + e2;
		int i = -e2 - ((int)(q));
		int k = strconv__pow5_bits(i) - _const_strconv__pow5_num_bits_64;
		int j = ((int)(q)) - k;
		strconv__Uint128 mul = (*(strconv__Uint128*)/*ee elem_typ */array_get(_const_strconv__pow5_split_64, i));
		vr = strconv__mul_shift_64(((u64)(4U)) * m2, mul, j);
		vp = strconv__mul_shift_64(((u64)(4U)) * m2 + ((u64)(2U)), mul, j);
		vm = strconv__mul_shift_64(((u64)(4U)) * m2 - ((u64)(1U)) - mm_shift, mul, j);
		if (q <= 1) {
			vr_is_trailing_zeros = true;
			if (accept_bounds) {
				vm_is_trailing_zeros = (mm_shift == 1);
			} else {
				vp--;
			}
		} else if (q < 63) {
			vr_is_trailing_zeros = strconv__multiple_of_power_of_two_64(mv, q - 1);
		}
	}
	int removed = 0;
	byte last_removed_digit = ((byte)(0));
	u64 out = ((u64)(0U));
	if (vm_is_trailing_zeros || vr_is_trailing_zeros) {
		for (;;) {
			u64 vp_div_10 = vp / 10;
			u64 vm_div_10 = vm / 10;
			if (vp_div_10 <= vm_div_10) {
				break;
			}
			u64 vm_mod_10 = vm % 10;
			u64 vr_div_10 = vr / 10;
			u64 vr_mod_10 = vr % 10;
			vm_is_trailing_zeros = vm_is_trailing_zeros && vm_mod_10 == 0;
			vr_is_trailing_zeros = vr_is_trailing_zeros && (last_removed_digit == 0);
			last_removed_digit = ((byte)(vr_mod_10));
			vr = vr_div_10;
			vp = vp_div_10;
			vm = vm_div_10;
			removed++;
		}
		if (vm_is_trailing_zeros) {
			for (;;) {
				u64 vm_div_10 = vm / 10;
				u64 vm_mod_10 = vm % 10;
				if (vm_mod_10 != 0) {
					break;
				}
				u64 vp_div_10 = vp / 10;
				u64 vr_div_10 = vr / 10;
				u64 vr_mod_10 = vr % 10;
				vr_is_trailing_zeros = vr_is_trailing_zeros && (last_removed_digit == 0);
				last_removed_digit = ((byte)(vr_mod_10));
				vr = vr_div_10;
				vp = vp_div_10;
				vm = vm_div_10;
				removed++;
			}
		}
		if (vr_is_trailing_zeros && (last_removed_digit == 5) && (vr % 2) == 0) {
			last_removed_digit = 4;
		}
		out = vr;
		if ((vr == vm && (!accept_bounds || !vm_is_trailing_zeros)) || last_removed_digit >= 5) {
			out++;
		}
	} else {
		bool round_up = false;
		for (;;) {
			if (!(vp / 100 > vm / 100)) break;
			round_up = (vr % 100) >= 50;
			vr /= 100;
			vp /= 100;
			vm /= 100;
			removed += 2;
		}
		for (;;) {
			if (!(vp / 10 > vm / 10)) break;
			round_up = (vr % 10) >= 5;
			vr /= 10;
			vp /= 10;
			vm /= 10;
			removed++;
		}
		out = vr + strconv__bool_to_u64(vr == vm || round_up);
	}
	return (strconv__Dec64){.m = out,.e = e10 + removed,};
}

string strconv__f64_to_str(f64 f, int n_digit) {
	strconv__Uf64 u1 = (strconv__Uf64){
#ifndef __cplusplus
0
#endif
};
	u1.f = f;
	u64 u = u1.u;
	bool neg = (u >> (_const_strconv__mantbits64 + _const_strconv__expbits64)) != 0;
	u64 mant = (u & ((((u64)(1U)) << _const_strconv__mantbits64) - ((u64)(1U))));
	u64 exp = ((u >> _const_strconv__mantbits64) & ((((u64)(1U)) << _const_strconv__expbits64) - ((u64)(1U))));
	if ((exp == _const_strconv__maxexp64) || (exp == 0 && mant == 0)) {
		return strconv__get_string_special(neg, exp == 0, mant == 0);
	}
	multi_return_strconv__Dec64_bool mr_9686 = strconv__f64_to_decimal_exact_int(mant, exp);
	strconv__Dec64 d = mr_9686.arg0;
	bool ok = mr_9686.arg1;
	if (!ok) {
		d = strconv__f64_to_decimal(mant, exp);
	}
	return strconv__Dec64_get_string_64(d, neg, n_digit, 0);
}

string strconv__f64_to_str_pad(f64 f, int n_digit) {
	strconv__Uf64 u1 = (strconv__Uf64){
#ifndef __cplusplus
0
#endif
};
	u1.f = f;
	u64 u = u1.u;
	bool neg = (u >> (_const_strconv__mantbits64 + _const_strconv__expbits64)) != 0;
	u64 mant = (u & ((((u64)(1U)) << _const_strconv__mantbits64) - ((u64)(1U))));
	u64 exp = ((u >> _const_strconv__mantbits64) & ((((u64)(1U)) << _const_strconv__expbits64) - ((u64)(1U))));
	if ((exp == _const_strconv__maxexp64) || (exp == 0 && mant == 0)) {
		return strconv__get_string_special(neg, exp == 0, mant == 0);
	}
	multi_return_strconv__Dec64_bool mr_10422 = strconv__f64_to_decimal_exact_int(mant, exp);
	strconv__Dec64 d = mr_10422.arg0;
	bool ok = mr_10422.arg1;
	if (!ok) {
		d = strconv__f64_to_decimal(mant, exp);
	}
	return strconv__Dec64_get_string_64(d, neg, n_digit, n_digit);
}

string strconv__f64_to_str_lnd(f64 f, int dec_digit) {
	string s = strconv__f64_to_str(f + (*(f64*)/*ee elem_typ */array_get(_const_strconv__dec_round, dec_digit)), 18);
	if (s.len > 2 && (string_at(s, 0) == 'n' || string_at(s, 1) == 'i')) {
		return s;
	}
	bool m_sgn_flag = false;
	int sgn = 1;
	array_fixed_byte_26 b = {0};
	int d_pos = 1;
	int i = 0;
	int i1 = 0;
	int exp = 0;
	int exp_sgn = 1;
	int dot_res_sp = -1;
	for (int _t10 = 0; _t10 < s.len; ++_t10) {
		byte c = s.str[_t10];
		if (c == '-') {
			sgn = -1;
			i++;
		} else if (c == '+') {
			sgn = 1;
			i++;
		} else if (c >= '0' && c <= '9') {
			b[i1++] = c;
			i++;
		} else if (c == '.') {
			if (sgn > 0) {
				d_pos = i;
			} else {
				d_pos = i - 1;
			}
			i++;
		} else if (c == 'e') {
			i++;
			break;
		} else {
			return tos_lit("[Float conversion error!!]");
		}
	}
	b[i1] = 0;
	if (string_at(s, i) == '-') {
		exp_sgn = -1;
		i++;
	} else if (string_at(s, i) == '+') {
		exp_sgn = 1;
		i++;
	}
	for (int _t11 = 0; _t11 < string_substr(s, i, s.len).len; ++_t11) {
		byte c = string_substr(s, i, s.len).str[_t11];
		exp = exp * 10 + ((int)(c - '0'));
	}
	array_byte res = __new_array_with_default(exp + 32, 0, sizeof(byte), &(byte[]){0});
	int r_i = 0;
	if (sgn == 1) {
		if (m_sgn_flag) {
			array_set(&res, r_i++, &(byte[]) { '+' });
		}
	} else {
		array_set(&res, r_i++, &(byte[]) { '-' });
	}
	i = 0;
	if (exp_sgn >= 0) {
		for (;;) {
			if (!(b[i] != 0)) break;
			array_set(&res, r_i++, &(byte[]) { b[i] });
			i++;
			if (i >= d_pos && exp >= 0) {
				if (exp == 0) {
					dot_res_sp = r_i;
					array_set(&res, r_i++, &(byte[]) { '.' });
				}
				exp--;
			}
		}
		for (;;) {
			if (!(exp >= 0)) break;
			array_set(&res, r_i++, &(byte[]) { '0' });
			exp--;
		}
	} else {
		bool dot_p = true;
		for (;;) {
			if (!(exp > 0)) break;
			array_set(&res, r_i++, &(byte[]) { '0' });
			exp--;
			if (dot_p) {
				dot_res_sp = r_i;
				array_set(&res, r_i++, &(byte[]) { '.' });
				dot_p = false;
			}
		}
		for (;;) {
			if (!(b[i] != 0)) break;
			array_set(&res, r_i++, &(byte[]) { b[i] });
			i++;
		}
	}
	if (dot_res_sp >= 0) {
		if ((r_i - dot_res_sp) > dec_digit) {
			r_i = dot_res_sp + dec_digit + 1;
		}
		array_set(&res, r_i, &(byte[]) { 0 });
		return tos(res.data, r_i);
	} else {
		if (dec_digit > 0) {
			int c = 0;
			array_set(&res, r_i++, &(byte[]) { '.' });
			for (;;) {
				if (!(c < dec_digit)) break;
				array_set(&res, r_i++, &(byte[]) { '0' });
				c++;
			}
			array_set(&res, r_i, &(byte[]) { 0 });
		}
		return tos(res.data, r_i);
	}
	return (string){.str=(byteptr)""};
}

string strconv__format_str(string s, strconv__BF_param p) {
	int dif = p.len0 - s.len;
	if (dif <= 0) {
		return s;
	}
	strings__Builder res = strings__new_builder(s.len + dif);
	if (p.allign == strconv__Align_text_right) {
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_b(&res, p.pad_ch);
		}
	}
	strings__Builder_write(&res, s);
	if (p.allign == strconv__Align_text_left) {
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_b(&res, p.pad_ch);
		}
	}
	return strings__Builder_str(&res);
}

string strconv__format_dec(u64 d, strconv__BF_param p) {
	string s = tos_lit("");
	strings__Builder res = strings__new_builder(20);
	int sign_len_diff = 0;
	if (p.pad_ch == '0') {
		if (p.positive) {
			if (p.sign_flag) {
				strings__Builder_write_b(&res, '+');
				sign_len_diff = -1;
			}
		} else {
			strings__Builder_write_b(&res, '-');
			sign_len_diff = -1;
		}
		s = u64_str(d);
	} else {
		if (p.positive) {
			if (p.sign_flag) {
				s = string_add(tos_lit("+"), u64_str(d));
			} else {
				s = u64_str(d);
			}
		} else {
			s = string_add(tos_lit("-"), u64_str(d));
		}
	}
	int dif = p.len0 - s.len + sign_len_diff;
	if (p.allign == strconv__Align_text_right) {
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_b(&res, p.pad_ch);
		}
	}
	strings__Builder_write(&res, s);
	if (p.allign == strconv__Align_text_left) {
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_b(&res, p.pad_ch);
		}
	}
	return strings__Builder_str(&res);
}

string strconv__format_fl(f64 f, strconv__BF_param p) {
	string s = tos_lit("");
	string fs = strconv__f64_to_str_lnd((f >= 0.0 ? (f) : (-f)), p.len1);
	if (string_at(fs, 0) == '[') {
		return fs;
	}
	if (p.rm_tail_zero) {
		fs = strconv__remove_tail_zeros(fs);
	}
	strings__Builder res = strings__new_builder((p.len0 > fs.len ? (p.len0) : (fs.len)));
	int sign_len_diff = 0;
	if (p.pad_ch == '0') {
		if (p.positive) {
			if (p.sign_flag) {
				strings__Builder_write_b(&res, '+');
				sign_len_diff = -1;
			}
		} else {
			strings__Builder_write_b(&res, '-');
			sign_len_diff = -1;
		}
		s = fs;
	} else {
		if (p.positive) {
			if (p.sign_flag) {
				s = string_add(tos_lit("+"), fs);
			} else {
				s = fs;
			}
		} else {
			s = string_add(tos_lit("-"), fs);
		}
	}
	int dif = p.len0 - s.len + sign_len_diff;
	if (p.allign == strconv__Align_text_right) {
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_b(&res, p.pad_ch);
		}
	}
	strings__Builder_write(&res, s);
	if (p.allign == strconv__Align_text_left) {
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_b(&res, p.pad_ch);
		}
	}
	return strings__Builder_str(&res);
}

string strconv__format_es(f64 f, strconv__BF_param p) {
	string s = tos_lit("");
	string fs = strconv__f64_to_str_pad((f > 0 ? (f) : (-f)), p.len1);
	if (p.rm_tail_zero) {
		fs = strconv__remove_tail_zeros(fs);
	}
	strings__Builder res = strings__new_builder((p.len0 > fs.len ? (p.len0) : (fs.len)));
	int sign_len_diff = 0;
	if (p.pad_ch == '0') {
		if (p.positive) {
			if (p.sign_flag) {
				strings__Builder_write_b(&res, '+');
				sign_len_diff = -1;
			}
		} else {
			strings__Builder_write_b(&res, '-');
			sign_len_diff = -1;
		}
		s = fs;
	} else {
		if (p.positive) {
			if (p.sign_flag) {
				s = string_add(tos_lit("+"), fs);
			} else {
				s = fs;
			}
		} else {
			s = string_add(tos_lit("-"), fs);
		}
	}
	int dif = p.len0 - s.len + sign_len_diff;
	if (p.allign == strconv__Align_text_right) {
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_b(&res, p.pad_ch);
		}
	}
	strings__Builder_write(&res, s);
	if (p.allign == strconv__Align_text_left) {
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_b(&res, p.pad_ch);
		}
	}
	return strings__Builder_str(&res);
}

string strconv__remove_tail_zeros(string s) {
	int i = 0;
	int last_zero_start = -1;
	int dot_pos = -1;
	bool in_decimal = false;
	byte prev_ch = ((byte)(0));
	for (;;) {
		if (!(i < s.len)) break;
		byte ch = s.str[i];
		if (ch == '.') {
			in_decimal = true;
			dot_pos = i;
		} else if (in_decimal) {
			if (ch == '0' && prev_ch != '0') {
				last_zero_start = i;
			} else if (ch >= '1' && ch <= '9') {
				last_zero_start = -1;
			} else if (ch == 'e') {
				break;
			}
		}
		prev_ch = ch;
		i++;
	}
	string tmp = tos_lit("");
	if (last_zero_start > 0) {
		if (last_zero_start == dot_pos + 1) {
			tmp = string_add(string_substr(s, 0, dot_pos), string_substr(s, i, s.len));
		} else {
			tmp = string_add(string_substr(s, 0, last_zero_start), string_substr(s, i, s.len));
		}
	} else {
		tmp = s;
	}
	if (tmp.str[tmp.len - 1] == '.') {
		return string_substr(tmp, 0, tmp.len - 1);
	}
	return tmp;
}

void strconv__v_printf(string str, varg_voidptr pt) {
	print(strconv__v_sprintf(str, pt));
}

string strconv__v_sprintf(string str, varg_voidptr pt) {
	strings__Builder res = strings__new_builder(pt.len * 16);
	int i = 0;
	int p_index = 0;
	bool sign = false;
	strconv__Align_text allign = strconv__Align_text_right;
	int len0 = -1;
	int len1 = -1;
	int def_len1 = 6;
	byte pad_ch = ((byte)(' '));
	rune ch1 = '0';
	rune ch2 = '0';
	strconv__Char_parse_state status = strconv__Char_parse_state_norm_char;
	for (;;) {
		if (!(i < str.len)) break;
		if (status == strconv__Char_parse_state_reset_params) {
			sign = false;
			allign = strconv__Align_text_right;
			len0 = -1;
			len1 = -1;
			pad_ch = ' ';
			status = strconv__Char_parse_state_norm_char;
			ch1 = '0';
			ch2 = '0';
			continue;
		}
		byte ch = string_at(str, i);
		if (ch != '%' && status == strconv__Char_parse_state_norm_char) {
			strings__Builder_write_b(&res, ch);
			i++;
			continue;
		}
		if (ch == '%' && status == strconv__Char_parse_state_norm_char) {
			status = strconv__Char_parse_state_field_char;
			i++;
			continue;
		}
		if (ch == 'c' && status == strconv__Char_parse_state_field_char) {
			strconv__v_sprintf_panic(p_index, pt.len);
			byte d1 = *(((byte*)(pt.args[p_index])));
			strings__Builder_write_b(&res, d1);
			status = strconv__Char_parse_state_reset_params;
			p_index++;
			i++;
			continue;
		}
		if (ch == 'p' && status == strconv__Char_parse_state_field_char) {
			strconv__v_sprintf_panic(p_index, pt.len);
			strings__Builder_write(&res, tos_lit("0x"));
			strings__Builder_write(&res, ptr_str(pt.args[p_index]));
			status = strconv__Char_parse_state_reset_params;
			p_index++;
			i++;
			continue;
		}
		if (status == strconv__Char_parse_state_field_char) {
			rune fc_ch1 = '0';
			rune fc_ch2 = '0';
			if ((i + 1) < str.len) {
				fc_ch1 = string_at(str, i + 1);
				if ((i + 2) < str.len) {
					fc_ch2 = string_at(str, i + 2);
				}
			}
			if (ch == '+') {
				sign = true;
				i++;
				continue;
			} else if (ch == '-') {
				allign = strconv__Align_text_left;
				i++;
				continue;
			} else if ((ch == '0' || ch == ' ')) {
				if (allign == strconv__Align_text_right) {
					pad_ch = ch;
				}
				i++;
				continue;
			} else if (ch == '\'') {
				i++;
				continue;
			} else if (ch == '.' && fc_ch1 >= '1' && fc_ch1 <= '9') {
				status = strconv__Char_parse_state_check_float;
				i++;
				continue;
			} else if (ch == '.' && fc_ch1 == '*' && fc_ch2 == 's') {
				strconv__v_sprintf_panic(p_index, pt.len);
				int len = *(((int*)(pt.args[p_index])));
				p_index++;
				strconv__v_sprintf_panic(p_index, pt.len);
				string s = *(((string*)(pt.args[p_index])));
				s = string_substr(s, 0, len);
				p_index++;
				strings__Builder_write(&res, s);
				status = strconv__Char_parse_state_reset_params;
				i += 3;
				continue;
			}
			status = strconv__Char_parse_state_len_set_start;
			continue;
		}
		if (status == strconv__Char_parse_state_len_set_start) {
			if (ch >= '1' && ch <= '9') {
				len0 = ((int)(ch - '0'));
				status = strconv__Char_parse_state_len_set_in;
				i++;
				continue;
			}
			if (ch == '.') {
				status = strconv__Char_parse_state_check_float;
				i++;
				continue;
			}
			status = strconv__Char_parse_state_check_type;
			continue;
		}
		if (status == strconv__Char_parse_state_len_set_in) {
			if (ch >= '0' && ch <= '9') {
				len0 *= 10;
				len0 += ((int)(ch - '0'));
				i++;
				continue;
			}
			if (ch == '.') {
				status = strconv__Char_parse_state_check_float;
				i++;
				continue;
			}
			status = strconv__Char_parse_state_check_type;
			continue;
		}
		if (status == strconv__Char_parse_state_check_float) {
			if (ch >= '0' && ch <= '9') {
				len1 = ((int)(ch - '0'));
				status = strconv__Char_parse_state_check_float_in;
				i++;
				continue;
			}
			status = strconv__Char_parse_state_check_type;
			continue;
		}
		if (status == strconv__Char_parse_state_check_float_in) {
			if (ch >= '0' && ch <= '9') {
				len1 *= 10;
				len1 += ((int)(ch - '0'));
				i++;
				continue;
			}
			status = strconv__Char_parse_state_check_type;
			continue;
		}
		if (status == strconv__Char_parse_state_check_type) {
			if (ch == 'l') {
				if (ch1 == '0') {
					ch1 = 'l';
					i++;
					continue;
				} else {
					ch2 = 'l';
					i++;
					continue;
				}
			} else if (ch == 'h') {
				if (ch1 == '0') {
					ch1 = 'h';
					i++;
					continue;
				} else {
					ch2 = 'h';
					i++;
					continue;
				}
			} else if ((ch == 'd' || ch == 'i')) {
				u64 d1 = ((u64)(0U));
				bool positive = true;
				rune _t12 = ch1;
				if (_t12 == 'h') {
					if (ch2 == 'h') {
						strconv__v_sprintf_panic(p_index, pt.len);
						i8 x = *(((i8*)(pt.args[p_index])));
						positive = (x >= 0 ? (true) : (false));
						d1 = (positive ? (((u64)(x))) : (((u64)(-x))));
					} else {
						i16 x = *(((i16*)(pt.args[p_index])));
						positive = (x >= 0 ? (true) : (false));
						d1 = (positive ? (((u64)(x))) : (((u64)(-x))));
					}
				} else if (_t12 == 'l') {
					strconv__v_sprintf_panic(p_index, pt.len);
					i64 x = *(((i64*)(pt.args[p_index])));
					positive = (x >= 0 ? (true) : (false));
					d1 = (positive ? (((u64)(x))) : (((u64)(-x))));
				} else {
					strconv__v_sprintf_panic(p_index, pt.len);
					int x = *(((int*)(pt.args[p_index])));
					positive = (x >= 0 ? (true) : (false));
					d1 = (positive ? (((u64)(x))) : (((u64)(-x))));
				};
				strings__Builder_write(&res, strconv__format_dec(d1, (strconv__BF_param){
					.pad_ch = pad_ch,
					.len0 = len0,
					.len1 = 0,
					.positive = positive,
					.sign_flag = sign,
					.allign = allign,
					.rm_tail_zero = 0,
				}));
				status = strconv__Char_parse_state_reset_params;
				p_index++;
				i++;
				ch1 = '0';
				ch2 = '0';
				continue;
			} else if (ch == 'u') {
				u64 d1 = ((u64)(0U));
				bool positive = true;
				strconv__v_sprintf_panic(p_index, pt.len);
				rune _t13 = ch1;
				if (_t13 == 'h') {
					if (ch2 == 'h') {
						d1 = ((u64)(*(((byte*)(pt.args[p_index])))));
					} else {
						d1 = ((u64)(*(((u16*)(pt.args[p_index])))));
					}
				} else if (_t13 == 'l') {
					d1 = ((u64)(*(((u64*)(pt.args[p_index])))));
				} else {
					d1 = ((u64)(*(((u32*)(pt.args[p_index])))));
				};
				strings__Builder_write(&res, strconv__format_dec(d1, (strconv__BF_param){
					.pad_ch = pad_ch,
					.len0 = len0,
					.len1 = 0,
					.positive = positive,
					.sign_flag = sign,
					.allign = allign,
					.rm_tail_zero = 0,
				}));
				status = strconv__Char_parse_state_reset_params;
				p_index++;
				i++;
				continue;
			} else if ((ch == 'x' || ch == 'X')) {
				strconv__v_sprintf_panic(p_index, pt.len);
				string s = tos_lit("");
				rune _t14 = ch1;
				if (_t14 == 'h') {
					if (ch2 == 'h') {
						i8 x = *(((i8*)(pt.args[p_index])));
						s = i8_hex(x);
					} else {
						i16 x = *(((i16*)(pt.args[p_index])));
						s = i16_hex(x);
					}
				} else if (_t14 == 'l') {
					i64 x = *(((i64*)(pt.args[p_index])));
					s = i64_hex(x);
				} else {
					int x = *(((int*)(pt.args[p_index])));
					s = int_hex(x);
				};
				if (ch == 'X') {
					s = string_to_upper(s);
				}
				strings__Builder_write(&res, strconv__format_str(s, (strconv__BF_param){
					.pad_ch = pad_ch,
					.len0 = len0,
					.len1 = 0,
					.positive = true,
					.sign_flag = false,
					.allign = allign,
					.rm_tail_zero = 0,
				}));
				status = strconv__Char_parse_state_reset_params;
				p_index++;
				i++;
				continue;
			}
			if ((ch == 'f' || ch == 'F')) {
				strconv__v_sprintf_panic(p_index, pt.len);
				f64 x = *(((f64*)(pt.args[p_index])));
				bool positive = x >= ((f64)(0.0));
				len1 = (len1 >= 0 ? (len1) : (def_len1));
				string s = strconv__format_fl(((f64)(x)), (strconv__BF_param){
					.pad_ch = pad_ch,
					.len0 = len0,
					.len1 = len1,
					.positive = positive,
					.sign_flag = sign,
					.allign = allign,
					.rm_tail_zero = 0,
				});
				strings__Builder_write(&res, (ch == 'F' ? (string_to_upper(s)) : (s)));
				status = strconv__Char_parse_state_reset_params;
				p_index++;
				i++;
				continue;
			} else if ((ch == 'e' || ch == 'E')) {
				strconv__v_sprintf_panic(p_index, pt.len);
				f64 x = *(((f64*)(pt.args[p_index])));
				bool positive = x >= ((f64)(0.0));
				len1 = (len1 >= 0 ? (len1) : (def_len1));
				string s = strconv__format_es(((f64)(x)), (strconv__BF_param){
					.pad_ch = pad_ch,
					.len0 = len0,
					.len1 = len1,
					.positive = positive,
					.sign_flag = sign,
					.allign = allign,
					.rm_tail_zero = 0,
				});
				strings__Builder_write(&res, (ch == 'E' ? (string_to_upper(s)) : (s)));
				status = strconv__Char_parse_state_reset_params;
				p_index++;
				i++;
				continue;
			} else if ((ch == 'g' || ch == 'G')) {
				strconv__v_sprintf_panic(p_index, pt.len);
				f64 x = *(((f64*)(pt.args[p_index])));
				bool positive = x >= ((f64)(0.0));
				string s = tos_lit("");
				f64 tx = strconv__fabs(x);
				if (tx < 999999.0 && tx >= 0.00001) {
					len1 = (len1 >= 0 ? (len1 + 1) : (def_len1));
					s = strconv__format_fl(x, (strconv__BF_param){
						.pad_ch = pad_ch,
						.len0 = len0,
						.len1 = len1,
						.positive = positive,
						.sign_flag = sign,
						.allign = allign,
						.rm_tail_zero = true,
					});
				} else {
					len1 = (len1 >= 0 ? (len1 + 1) : (def_len1));
					s = strconv__format_es(x, (strconv__BF_param){
						.pad_ch = pad_ch,
						.len0 = len0,
						.len1 = len1,
						.positive = positive,
						.sign_flag = sign,
						.allign = allign,
						.rm_tail_zero = true,
					});
				}
				strings__Builder_write(&res, (ch == 'G' ? (string_to_upper(s)) : (s)));
				status = strconv__Char_parse_state_reset_params;
				p_index++;
				i++;
				continue;
			} else if (ch == 's') {
				strconv__v_sprintf_panic(p_index, pt.len);
				string s1 = *(((string*)(pt.args[p_index])));
				pad_ch = ' ';
				strings__Builder_write(&res, strconv__format_str(s1, (strconv__BF_param){
					.pad_ch = pad_ch,
					.len0 = len0,
					.len1 = 0,
					.positive = true,
					.sign_flag = false,
					.allign = allign,
					.rm_tail_zero = 0,
				}));
				status = strconv__Char_parse_state_reset_params;
				p_index++;
				i++;
				continue;
			}
		}
		status = strconv__Char_parse_state_reset_params;
		p_index++;
		i++;
	}
	if (p_index != pt.len) {
		v_panic(_STR("%"PRId32"\000 %% conversion specifiers, but given %"PRId32"\000 args", 3, p_index, pt.len));
	}
	return strings__Builder_str(&res);
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL void strconv__v_sprintf_panic(int idx, int len) {
	if (idx >= len) {
		v_panic(_STR("%"PRId32"\000 %% conversion specifiers, but given only %"PRId32"\000 args", 3, idx + 1, len));
	}
}

VV_LOCAL_SYMBOL f64 strconv__fabs(f64 x) {
	if (x < 0.0) {
		return -x;
	}
	return x;
}

// Attr: [inline]
inline string strconv__ftoa_64(f64 f) {
	return strconv__f64_to_str(f, 17);
}

// Attr: [inline]
inline string strconv__ftoa_long_64(f64 f) {
	return strconv__f64_to_str_l(f);
}

// Attr: [inline]
inline string strconv__ftoa_32(f32 f) {
	return strconv__f32_to_str(f, 8);
}

// Attr: [inline]
inline string strconv__ftoa_long_32(f32 f) {
	return strconv__f32_to_str_l(f);
}

VV_LOCAL_SYMBOL void strconv__assert1(bool t, string msg) {
	if (!t) {
		v_panic(msg);
	}
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL int strconv__bool_to_int(bool b) {
	if (b) {
		return 1;
	}
	return 0;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL u32 strconv__bool_to_u32(bool b) {
	if (b) {
		return ((u32)(1U));
	}
	return ((u32)(0U));
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL u64 strconv__bool_to_u64(bool b) {
	if (b) {
		return ((u64)(1U));
	}
	return ((u64)(0U));
}

VV_LOCAL_SYMBOL string strconv__get_string_special(bool neg, bool expZero, bool mantZero) {
	if (!mantZero) {
		return tos_lit("nan");
	}
	if (!expZero) {
		if (neg) {
			return tos_lit("-inf");
		} else {
			return tos_lit("+inf");
		}
	}
	if (neg) {
		return tos_lit("-0e+00");
	}
	return tos_lit("0e+00");
}

VV_LOCAL_SYMBOL int strconv__decimal_len_32(u32 u) {
	strconv__assert1(u < 1000000000, tos_lit("too big"));
	if (u >= 100000000) {
		return 9;
	} else if (u >= 10000000) {
		return 8;
	} else if (u >= 1000000) {
		return 7;
	} else if (u >= 100000) {
		return 6;
	} else if (u >= 10000) {
		return 5;
	} else if (u >= 1000) {
		return 4;
	} else if (u >= 100) {
		return 3;
	} else if (u >= 10) {
		return 2;
	}
	return 1;
}

VV_LOCAL_SYMBOL u32 strconv__mul_shift_32(u32 m, u64 mul, int ishift) {
	multi_return_u64_u64 mr_1855 = math__bits__mul_64(((u64)(m)), mul);
	u64 hi = mr_1855.arg0;
	u64 lo = mr_1855.arg1;
	u64 shifted_sum = (lo >> ((u64)(ishift))) + (hi << ((u64)(64 - ishift)));
	strconv__assert1(shifted_sum <= 2147483647, tos_lit("shiftedSum <= math.max_u32"));
	return ((u32)(shifted_sum));
}

VV_LOCAL_SYMBOL u32 strconv__mul_pow5_invdiv_pow2(u32 m, u32 q, int j) {
	return strconv__mul_shift_32(m, (*(u64*)/*ee elem_typ */array_get(_const_strconv__pow5_inv_split_32, q)), j);
}

VV_LOCAL_SYMBOL u32 strconv__mul_pow5_div_pow2(u32 m, u32 i, int j) {
	return strconv__mul_shift_32(m, (*(u64*)/*ee elem_typ */array_get(_const_strconv__pow5_split_32, i)), j);
}

VV_LOCAL_SYMBOL u32 strconv__pow5_factor_32(u32 i_v) {
	u32 v = i_v;
	for (u32 n = ((u32)(0U)); ; n++) {
		u32 q = v / 5;
		u32 r = v % 5;
		if (r != 0) {
			return n;
		}
		v = q;
	}
	return v;
}

VV_LOCAL_SYMBOL bool strconv__multiple_of_power_of_five_32(u32 v, u32 p) {
	return strconv__pow5_factor_32(v) >= p;
}

VV_LOCAL_SYMBOL bool strconv__multiple_of_power_of_two_32(u32 v, u32 p) {
	return ((u32)(math__bits__trailing_zeros_32(v))) >= p;
}

VV_LOCAL_SYMBOL u32 strconv__log10_pow2(int e) {
	strconv__assert1(e >= 0, tos_lit("e >= 0"));
	strconv__assert1(e <= 1650, tos_lit("e <= 1650"));
	return (((u32)(e)) * 78913) >> 18;
}

VV_LOCAL_SYMBOL u32 strconv__log10_pow5(int e) {
	strconv__assert1(e >= 0, tos_lit("e >= 0"));
	strconv__assert1(e <= 2620, tos_lit("e <= 2620"));
	return (((u32)(e)) * 732923) >> 20;
}

VV_LOCAL_SYMBOL int strconv__pow5_bits(int e) {
	strconv__assert1(e >= 0, tos_lit("e >= 0"));
	strconv__assert1(e <= 3528, tos_lit("e <= 3528"));
	return ((int)(((((u32)(e)) * 1217359) >> 19) + 1));
}

VV_LOCAL_SYMBOL int strconv__decimal_len_64(u64 u) {
	int log2 = 64 - math__bits__leading_zeros_64(u) - 1;
	int t = (log2 + 1) * 1233 >> 12;
	return t - strconv__bool_to_int(u < (*(u64*)/*ee elem_typ */array_get(_const_strconv__powers_of_10, t))) + 1;
}

VV_LOCAL_SYMBOL u64 strconv__shift_right_128(strconv__Uint128 v, int shift) {
	strconv__assert1(shift < 64, tos_lit("shift < 64"));
	return ((v.hi << ((u64)(64 - shift))) | (v.lo >> ((u32)(shift))));
}

VV_LOCAL_SYMBOL u64 strconv__mul_shift_64(u64 m, strconv__Uint128 mul, int shift) {
	multi_return_u64_u64 mr_4388 = math__bits__mul_64(m, mul.hi);
	u64 hihi = mr_4388.arg0;
	u64 hilo = mr_4388.arg1;
	multi_return_u64_u64 mr_4426 = math__bits__mul_64(m, mul.lo);
	u64 lohi = mr_4426.arg0;
	strconv__Uint128 sum = (strconv__Uint128){.lo = lohi + hilo,.hi = hihi,};
	if (sum.lo < lohi) {
		sum.hi++;
	}
	return strconv__shift_right_128(sum, shift - 64);
}

VV_LOCAL_SYMBOL u32 strconv__pow5_factor_64(u64 v_i) {
	u64 v = v_i;
	for (u32 n = ((u32)(0U)); ; n++) {
		u64 q = v / 5;
		u64 r = v % 5;
		if (r != 0) {
			return n;
		}
		v = q;
	}
	return ((u32)(0U));
}

VV_LOCAL_SYMBOL bool strconv__multiple_of_power_of_five_64(u64 v, u32 p) {
	return strconv__pow5_factor_64(v) >= p;
}

VV_LOCAL_SYMBOL bool strconv__multiple_of_power_of_two_64(u64 v, u32 p) {
	return ((u32)(math__bits__trailing_zeros_64(v))) >= p;
}

string strconv__f32_to_str_l(f64 f) {
	return strconv__f64_to_str_l(((f32)(f)));
}

string strconv__f64_to_str_l(f64 f) {
	string s = strconv__f64_to_str(f, 18);
	if (s.len > 2 && (string_at(s, 0) == 'n' || string_at(s, 1) == 'i')) {
		return s;
	}
	bool m_sgn_flag = false;
	int sgn = 1;
	array_fixed_byte_26 b = {0};
	int d_pos = 1;
	int i = 0;
	int i1 = 0;
	int exp = 0;
	int exp_sgn = 1;
	for (int _t15 = 0; _t15 < s.len; ++_t15) {
		byte c = s.str[_t15];
		if (c == '-') {
			sgn = -1;
			i++;
		} else if (c == '+') {
			sgn = 1;
			i++;
		} else if (c >= '0' && c <= '9') {
			b[i1++] = c;
			i++;
		} else if (c == '.') {
			if (sgn > 0) {
				d_pos = i;
			} else {
				d_pos = i - 1;
			}
			i++;
		} else if (c == 'e') {
			i++;
			break;
		} else {
			return tos_lit("Float conversion error!!");
		}
	}
	b[i1] = 0;
	if (string_at(s, i) == '-') {
		exp_sgn = -1;
		i++;
	} else if (string_at(s, i) == '+') {
		exp_sgn = 1;
		i++;
	}
	for (int _t16 = 0; _t16 < string_substr(s, i, s.len).len; ++_t16) {
		byte c = string_substr(s, i, s.len).str[_t16];
		exp = exp * 10 + ((int)(c - '0'));
	}
	array_byte res = __new_array_with_default(exp + 32, 0, sizeof(byte), &(byte[]){0});
	int r_i = 0;
	if (sgn == 1) {
		if (m_sgn_flag) {
			array_set(&res, r_i++, &(byte[]) { '+' });
		}
	} else {
		array_set(&res, r_i++, &(byte[]) { '-' });
	}
	i = 0;
	if (exp_sgn >= 0) {
		for (;;) {
			if (!(b[i] != 0)) break;
			array_set(&res, r_i++, &(byte[]) { b[i] });
			i++;
			if (i >= d_pos && exp >= 0) {
				if (exp == 0) {
					array_set(&res, r_i++, &(byte[]) { '.' });
				}
				exp--;
			}
		}
		for (;;) {
			if (!(exp >= 0)) break;
			array_set(&res, r_i++, &(byte[]) { '0' });
			exp--;
		}
	} else {
		bool dot_p = true;
		for (;;) {
			if (!(exp > 0)) break;
			array_set(&res, r_i++, &(byte[]) { '0' });
			exp--;
			if (dot_p) {
				array_set(&res, r_i++, &(byte[]) { '.' });
				dot_p = false;
			}
		}
		for (;;) {
			if (!(b[i] != 0)) break;
			array_set(&res, r_i++, &(byte[]) { b[i] });
			i++;
		}
	}
	array_set(&res, r_i, &(byte[]) { 0 });
	return tos(res.data, r_i);
}

VV_LOCAL_SYMBOL array __new_array(int mylen, int cap, int elm_size) {
	int cap_ = (cap < mylen ? (mylen) : (cap));
	array arr = (array){.element_size = elm_size,.data = vcalloc(cap_ * elm_size),.len = mylen,.cap = cap_,};
	return arr;
}

VV_LOCAL_SYMBOL array __new_array_with_default(int mylen, int cap, int elm_size, voidptr val) {
	int cap_ = (cap < mylen ? (mylen) : (cap));
	array arr = (array){.element_size = elm_size,.data = vcalloc(cap_ * elm_size),.len = mylen,.cap = cap_,};
	if (val != 0) {
		for (int i = 0; i < arr.len; ++i) {
			array_set_unsafe(&arr, i, val);
		}
	}
	return arr;
}

VV_LOCAL_SYMBOL array __new_array_with_array_default(int mylen, int cap, int elm_size, array val) {
	int cap_ = (cap < mylen ? (mylen) : (cap));
	array arr = (array){.element_size = elm_size,.data = vcalloc(cap_ * elm_size),.len = mylen,.cap = cap_,};
	for (int i = 0; i < arr.len; ++i) {
		array val_clone = array_clone(&val);
		array_set_unsafe(&arr, i, &val_clone);
	}
	return arr;
}

VV_LOCAL_SYMBOL array new_array_from_c_array(int len, int cap, int elm_size, voidptr c_array) {
	int cap_ = (cap < len ? (len) : (cap));
	array arr = (array){.element_size = elm_size,.data = vcalloc(cap_ * elm_size),.len = len,.cap = cap_,};
	memcpy(arr.data, c_array, len * elm_size);
	return arr;
}

VV_LOCAL_SYMBOL array new_array_from_c_array_no_alloc(int len, int cap, int elm_size, voidptr c_array) {
	array arr = (array){.element_size = elm_size,.data = c_array,.len = len,.cap = cap,};
	return arr;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL void array_ensure_cap(array* a, int required) {
	if (required <= a->cap) {
		return;
	}
	int cap = (a->cap == 0 ? (2) : (a->cap * 2));
	for (;;) {
		if (!(required > cap)) break;
		cap *= 2;
	}
	if (a->cap == 0) {
		a->data = vcalloc(cap * a->element_size);
	} else {
		a->data = v_realloc(a->data, ((u32)(cap * a->element_size)));
	}
	a->cap = cap;
}

array array_repeat(array a, int count) {
	if (count < 0) {
		v_panic(_STR("array.repeat: count is negative: %"PRId32"", 1, count));
	}
	int size = count * a.len * a.element_size;
	if (size == 0) {
		size = a.element_size;
	}
	array arr = (array){.element_size = a.element_size,.data = vcalloc(size),.len = count * a.len,.cap = count * a.len,};
	int size_of_array = ((int)(/*SizeOfType*/ sizeof(struct array)));
	for (int i = 0; i < count; ++i) {
		if (a.len > 0 && a.element_size == size_of_array) {
			array ary = (array){.element_size = 0,.data = 0,.len = 0,.cap = 0,};
			memcpy(&ary, a.data, size_of_array);
			array ary_clone = array_clone(&ary);
			memcpy(array_get_unsafe(arr, i * a.len), &ary_clone, a.len * a.element_size);
		} else {
			memcpy(array_get_unsafe(arr, i * a.len), ((byteptr)(a.data)), a.len * a.element_size);
		}
	}
	return arr;
}

void array_sort_with_compare(array* a, voidptr compare) {
	qsort(a->data, a->len, a->element_size, compare);
}

void array_insert(array* a, int i, voidptr val) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (i < 0 || i > a->len) {
			v_panic(_STR("array.insert: index out of range (i == %"PRId32"\000, a.len == %"PRId32"\000)", 3, i, a->len));
		}
	}
	#endif
	array_ensure_cap(a, a->len + 1);
	{ // Unsafe block
		memmove(array_get_unsafe(/*rec*/*a, i + 1), array_get_unsafe(/*rec*/*a, i), (a->len - i) * a->element_size);
		array_set_unsafe(a, i, val);
	}
	a->len++;
}

void array_insert_many(array* a, int i, voidptr val, int size) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (i < 0 || i > a->len) {
			v_panic(_STR("array.insert_many: index out of range (i == %"PRId32"\000, a.len == %"PRId32"\000)", 3, i, a->len));
		}
	}
	#endif
	array_ensure_cap(a, a->len + size);
	int elem_size = a->element_size;
	{ // Unsafe block
		voidptr iptr = array_get_unsafe(/*rec*/*a, i);
		memmove(array_get_unsafe(/*rec*/*a, i + size), iptr, (a->len - i) * elem_size);
		memcpy(iptr, val, size * elem_size);
	}
	a->len += size;
}

void array_prepend(array* a, voidptr val) {
	array_insert(a, 0, val);
}

void array_prepend_many(array* a, voidptr val, int size) {
	array_insert_many(a, 0, val, size);
}

void array_delete(array* a, int i) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (i < 0 || i >= a->len) {
			v_panic(_STR("array.delete: index out of range (i == %"PRId32"\000, a.len == %"PRId32"\000)", 3, i, a->len));
		}
	}
	#endif
	memmove(array_get_unsafe(/*rec*/*a, i), array_get_unsafe(/*rec*/*a, i + 1), (a->len - i - 1) * a->element_size);
	a->len--;
}

void array_clear(array* a) {
	a->len = 0;
}

void array_trim(array* a, int index) {
	if (index < a->len) {
		a->len = index;
	}
}

// Attr: [inline]
// Attr: [unsafe]
inline VV_LOCAL_SYMBOL voidptr array_get_unsafe(array a, int i) {
	{ // Unsafe block
		return ((byteptr)(a.data)) + i * a.element_size;
	}
	return 0;
}

VV_LOCAL_SYMBOL voidptr array_get(array a, int i) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (i < 0 || i >= a.len) {
			v_panic(_STR("array.get: index out of range (i == %"PRId32"\000, a.len == %"PRId32"\000)", 3, i, a.len));
		}
	}
	#endif
	{ // Unsafe block
		return ((byteptr)(a.data)) + i * a.element_size;
	}
	return 0;
}

voidptr array_first(array a) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (a.len == 0) {
			v_panic(tos_lit("array.first: array is empty"));
		}
	}
	#endif
	return a.data;
}

voidptr array_last(array a) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (a.len == 0) {
			v_panic(tos_lit("array.last: array is empty"));
		}
	}
	#endif
	{ // Unsafe block
		return ((byteptr)(a.data)) + (a.len - 1) * a.element_size;
	}
	return 0;
}

voidptr array_pop(array* a) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (a->len == 0) {
			v_panic(tos_lit("array.pop: array is empty"));
		}
	}
	#endif
	int new_len = a->len - 1;
	byteptr last_elem = ((byteptr)(a->data)) + (new_len) * a->element_size;
	a->len = new_len;
	return memdup(last_elem, a->element_size);
}

void array_delete_last(array* a) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (a->len == 0) {
			v_panic(tos_lit("array.pop: array is empty"));
		}
	}
	#endif
	a->len--;
}

VV_LOCAL_SYMBOL array array_slice(array a, int start, int _end) {
	int end = _end;
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (start > end) {
			v_panic(_STR("array.slice: invalid slice index (%"PRId32"\000 > %"PRId32"\000)", 3, start, end));
		}
		if (end > a.len) {
			v_panic(_STR("array.slice: slice bounds out of range (%"PRId32"\000 >= %"PRId32"\000)", 3, end, a.len));
		}
		if (start < 0) {
			v_panic(_STR("array.slice: slice bounds out of range (%"PRId32"\000 < 0)", 2, start));
		}
	}
	#endif
	byteptr data = ((byteptr)(0));
	{ // Unsafe block
		data = ((byteptr)(a.data)) + start * a.element_size;
	}
	int l = end - start;
	array res = (array){.element_size = a.element_size,.data = data,.len = l,.cap = l,};
	return res;
}

VV_LOCAL_SYMBOL array array_slice2(array a, int start, int _end, bool end_max) {
	int end = (end_max ? (a.len) : (_end));
	return array_slice(a, start, end);
}

VV_LOCAL_SYMBOL array array_clone_static(array a) {
	return array_clone(&a);
}

array array_clone(array* a) {
	int size = a->cap * a->element_size;
	if (size == 0) {
		size++;
	}
	array arr = (array){.element_size = a->element_size,.data = vcalloc(size),.len = a->len,.cap = a->cap,};
	int size_of_array = ((int)(/*SizeOfType*/ sizeof(struct array)));
	if (a->element_size == size_of_array) {
		for (int i = 0; i < a->len; ++i) {
			array ar = (array){.element_size = 0,.data = 0,.len = 0,.cap = 0,};
			memcpy(&ar, array_get_unsafe(/*rec*/*a, i), size_of_array);
			array ar_clone = array_clone(&ar);
			array_set_unsafe(&arr, i, &ar_clone);
		}
	} else {
		memcpy(((byteptr)(arr.data)), a->data, a->cap * a->element_size);
	}
	return arr;
}

VV_LOCAL_SYMBOL array array_slice_clone(array* a, int start, int _end) {
	int end = _end;
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (start > end) {
			v_panic(_STR("array.slice: invalid slice index (%"PRId32"\000 > %"PRId32"\000)", 3, start, end));
		}
		if (end > a->len) {
			v_panic(_STR("array.slice: slice bounds out of range (%"PRId32"\000 >= %"PRId32"\000)", 3, end, a->len));
		}
		if (start < 0) {
			v_panic(_STR("array.slice: slice bounds out of range (%"PRId32"\000 < 0)", 2, start));
		}
	}
	#endif
	byteptr data = ((byteptr)(0));
	{ // Unsafe block
		data = ((byteptr)(a->data)) + start * a->element_size;
	}
	int l = end - start;
	array res = (array){.element_size = a->element_size,.data = data,.len = l,.cap = l,};
	return array_clone(&res);
}

// Attr: [inline]
// Attr: [unsafe]
inline VV_LOCAL_SYMBOL void array_set_unsafe(array* a, int i, voidptr val) {
	memcpy(((byteptr)(a->data)) + a->element_size * i, val, a->element_size);
}

VV_LOCAL_SYMBOL void array_set(array* a, int i, voidptr val) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (i < 0 || i >= a->len) {
			v_panic(_STR("array.set: index out of range (i == %"PRId32"\000, a.len == %"PRId32"\000)", 3, i, a->len));
		}
	}
	#endif
	memcpy(((byteptr)(a->data)) + a->element_size * i, val, a->element_size);
}

VV_LOCAL_SYMBOL void array_push(array* a, voidptr val) {
	array_ensure_cap(a, a->len + 1);
	memmove(((byteptr)(a->data)) + a->element_size * a->len, val, a->element_size);
	a->len++;
}

void array_push_many(array* a3, voidptr val, int size) {
	if (a3->data == val) {
		array copy = array_clone(a3);
		array_ensure_cap(a3, a3->len + size);
		memcpy(array_get_unsafe(/*rec*/*a3, a3->len), copy.data, a3->element_size * size);
	} else {
		array_ensure_cap(a3, a3->len + size);
		memcpy(array_get_unsafe(/*rec*/*a3, a3->len), val, a3->element_size * size);
	}
	a3->len += size;
}

void array_reverse_in_place(array* a) {
	if (a->len < 2) {
		return;
	}
	{ // Unsafe block
		byteptr tmp_value = v_malloc(a->element_size);
		for (int i = 0; i < a->len / 2; ++i) {
			memcpy(tmp_value, ((byteptr)(a->data)) + i * a->element_size, a->element_size);
			memcpy(((byteptr)(a->data)) + i * a->element_size, ((byteptr)(a->data)) + (a->len - 1 - i) * a->element_size, a->element_size);
			memcpy(((byteptr)(a->data)) + (a->len - 1 - i) * a->element_size, tmp_value, a->element_size);
		}
		v_free(tmp_value);
	}
}

array array_reverse(array a) {
	if (a.len < 2) {
		return a;
	}
	array arr = (array){.element_size = a.element_size,.data = vcalloc(a.cap * a.element_size),.len = a.len,.cap = a.cap,};
	for (int i = 0; i < a.len; ++i) {
		array_set_unsafe(&arr, i, array_get_unsafe(a, a.len - 1 - i));
	}
	return arr;
}

// Attr: [unsafe]
void array_free(array* a) {
	#if defined(_VPREALLOC)
	{
	}
	#endif
	free(a->data);
}

string array_string_str(array_string a) {
	strings__Builder sb = strings__new_builder(a.len * 3);
	strings__Builder_write(&sb, tos_lit("["));
	for (int i = 0; i < a.len; ++i) {
		string val = (*(string*)/*ee elem_typ */array_get(a, i));
		strings__Builder_write(&sb, tos_lit("\'"));
		strings__Builder_write(&sb, val);
		strings__Builder_write(&sb, tos_lit("\'"));
		if (i < a.len - 1) {
			strings__Builder_write(&sb, tos_lit(", "));
		}
	}
	strings__Builder_write(&sb, tos_lit("]"));
	return strings__Builder_str(&sb);
}

string array_byte_hex(array_byte b) {
	byteptr hex = v_malloc(b.len * 2 + 1);
	int dst_i = 0;
	// FOR IN array
	array _t17 = b;
	for (int _t18 = 0; _t18 < _t17.len; ++_t18) {
		byte i = ((byte*)_t17.data)[_t18];
		byte n0 = i >> 4;
		{ // Unsafe block
			hex[dst_i++] = (n0 < 10 ? (n0 + '0') : (n0 + ((byte)(87))));
		}
		byte n1 = (i & 0xF);
		{ // Unsafe block
			hex[dst_i++] = (n1 < 10 ? (n1 + '0') : (n1 + ((byte)(87))));
		}
	}
	{ // Unsafe block
		hex[dst_i] = '\0';
		return tos(hex, dst_i);
	}
	return (string){.str=(byteptr)""};
}

int copy(array_byte dst, array_byte src) {
	if (dst.len > 0 && src.len > 0) {
		int min = 0;
		min = (dst.len < src.len ? (dst.len) : (src.len));
		memcpy(((byteptr)(dst.data)), array_slice(src, 0, min).data, dst.element_size * min);
		return min;
	}
	return 0;
}

VV_LOCAL_SYMBOL int compare_ints(int* a, int* b) {
	if (*a < *b) {
		return -1;
	}
	if (*a > *b) {
		return 1;
	}
	return 0;
}

VV_LOCAL_SYMBOL int compare_ints_reverse(int* a, int* b) {
	if (*a > *b) {
		return -1;
	}
	if (*a < *b) {
		return 1;
	}
	return 0;
}

VV_LOCAL_SYMBOL int compare_floats(f64* a, f64* b) {
	if (*a < *b) {
		return -1;
	}
	if (*a > *b) {
		return 1;
	}
	return 0;
}

VV_LOCAL_SYMBOL int compare_floats_reverse(f64* a, f64* b) {
	if (*a > *b) {
		return -1;
	}
	if (*a < *b) {
		return 1;
	}
	return 0;
}

void array_int_sort(array_int* a) {
	array_sort_with_compare(a, compare_ints);
}

int array_string_index(array_string a, string v) {
	for (int i = 0; i < a.len; ++i) {
		if (string_eq((*(string*)/*ee elem_typ */array_get(a, i)), v)) {
			return i;
		}
	}
	return -1;
}

int array_int_index(array_int a, int v) {
	for (int i = 0; i < a.len; ++i) {
		if ((*(int*)/*ee elem_typ */array_get(a, i)) == v) {
			return i;
		}
	}
	return -1;
}

int array_byte_index(array_byte a, byte v) {
	for (int i = 0; i < a.len; ++i) {
		if ((*(byte*)/*ee elem_typ */array_get(a, i)) == v) {
			return i;
		}
	}
	return -1;
}

int array_rune_index(array_rune a, rune v) {
	for (int i = 0; i < a.len; ++i) {
		if ((*(rune*)/*ee elem_typ */array_get(a, i)) == v) {
			return i;
		}
	}
	return -1;
}

int array_char_index(array_char a, char v) {
	for (int i = 0; i < a.len; ++i) {
		if ((*(char*)/*ee elem_typ */array_get(a, i)) == v) {
			return i;
		}
	}
	return -1;
}

int array_int_reduce(array_int a, int (*iter)(int , int ), int accum_start) {
	int accum_ = accum_start;
	// FOR IN array
	array _t19 = a;
	for (int _t20 = 0; _t20 < _t19.len; ++_t20) {
		int i = ((int*)_t19.data)[_t20];
		accum_ = iter(accum_, i);
	}
	return accum_;
}

void array_grow(array* a, int amount) {
	array_ensure_cap(a, a->len + amount);
}

bool array_string_eq(array_string a1, array_string a2) {
	if (a1.len != a2.len) {
		return false;
	}
	for (int i = 0; i < a1.len; ++i) {
		if (string_ne((*(string*)/*ee elem_typ */array_get(a1, i)), (*(string*)/*ee elem_typ */array_get(a2, i)))) {
			return false;
		}
	}
	return true;
}

int compare_i64(i64* a, i64* b) {
	if (*a < *b) {
		return -1;
	}
	if (*a > *b) {
		return 1;
	}
	return 0;
}

int compare_f64(f64* a, f64* b) {
	if (*a < *b) {
		return -1;
	}
	if (*a > *b) {
		return 1;
	}
	return 0;
}

int compare_f32(f32* a, f32* b) {
	if (*a < *b) {
		return -1;
	}
	if (*a > *b) {
		return 1;
	}
	return 0;
}

array_voidptr array_pointers(array a) {
	array_voidptr res = __new_array_with_default(0, 0, sizeof(voidptr), 0);
	for (int i = 0; i < a.len; ++i) {
		array_push(&res, _MOV((voidptr[]){ array_get_unsafe(a, i) }));
	}
	return res;
}

// Attr: [unsafe]
array_byte voidptr_vbytes(voidptr data, int len) {
	array res = (array){.element_size = 1,.data = data,.len = len,.cap = len,};
	return res;
}

// Attr: [unsafe]
array_byte byteptr_vbytes(byteptr data, int len) {
	return voidptr_vbytes(((voidptr)(data)), len);
}

// TypeDecl
void v_exit(int code) {
	exit(code);
}

bool isnil(voidptr v) {
	return v == 0;
}

void print_backtrace() {
	print_backtrace_skipping_top_frames(2);
}

VV_LOCAL_SYMBOL void panic_debug(int line_no, string file, string mod, string fn_name, string s) {
	eprintln(tos_lit("================ V panic ================"));
	eprintln(_STR("   module: %.*s", 1, mod));
	eprintln(_STR(" function: %.*s\000()", 2, fn_name));
	eprintln(_STR("  message: %.*s", 1, s));
	eprintln(_STR("     file: %.*s", 1, file));
	eprintln(string_add(tos_lit("     line: "), int_str(line_no)));
	eprintln(tos_lit("========================================="));
	#if !defined(__TINYC__)
	{
		print_backtrace_skipping_top_frames(1);
	}
	#endif
	break_if_debugger_attached();
	exit(1);
}

void v_panic(string s) {
	eprintln(_STR("V panic: %.*s", 1, s));
	#if !defined(__TINYC__)
	{
		print_backtrace();
	}
	#endif
	break_if_debugger_attached();
	exit(1);
}

void eprintln(string s) {
	if (s.str == 0) {
		eprintln(tos_lit("eprintln(NIL)"));
	}
	fflush(stdout);
	fflush(stderr);
	write(2, s.str, s.len);
	write(2, "\n", 1);
	fflush(stderr);
}

void eprint(string s) {
	if (s.str == 0) {
		eprintln(tos_lit("eprint(NIL)"));
	}
	fflush(stdout);
	fflush(stderr);
	write(2, s.str, s.len);
	fflush(stderr);
}

void print(string s) {
	write(1, s.str, s.len);
}

void println(string s) {
	#if defined(_WIN32)
	{
		print(s);
		print(_const_new_line_character);
	}
	#else
	{
	}
	#endif
}

// Attr: [unsafe]
byteptr v_malloc(int n) {
	if (n <= 0) {
		v_panic(tos_lit("malloc(<=0)"));
	}
	#if defined(_VPREALLOC)
	{
	}
	#else
	{
		byteptr ptr = malloc(n);
		if (ptr == 0) {
			v_panic(_STR("malloc(%"PRId32"\000) failed", 2, n));
		}
		return ptr;
	}
	#endif
	return 0;
}

// Attr: [unsafe]
byteptr v_realloc(byteptr b, u32 n) {
	#if defined(_VPREALLOC)
	{
	}
	#else
	{
		byteptr ptr = realloc(b, n);
		if (ptr == 0) {
			v_panic(_STR("realloc(%"PRIu32"\000) failed", 2, n));
		}
		return ptr;
	}
	#endif
	return 0;
}

// Attr: [unsafe]
byteptr v_calloc(int n) {
	return calloc(1, n);
}

// Attr: [unsafe]
byteptr vcalloc(int n) {
	if (n < 0) {
		v_panic(tos_lit("calloc(<=0)"));
	} else if (n == 0) {
		return ((byteptr)(0));
	}
	return calloc(1, n);
}

// Attr: [unsafe]
void v_free(voidptr ptr) {
	#if defined(_VPREALLOC)
	{
	}
	#endif
	free(ptr);
}

voidptr memdup(voidptr src, int sz) {
	if (sz == 0) {
		return vcalloc(1);
	}
	{ // Unsafe block
		byteptr mem = v_malloc(sz);
		return memcpy(mem, src, sz);
	}
	return 0;
}

VV_LOCAL_SYMBOL void v_ptr_free(voidptr ptr) {
	#if defined(_VPREALLOC)
	{
	}
	#endif
	free(ptr);
}

int is_atty(int fd) {
	#if defined(_WIN32)
	{
		u32 mode = ((u32)(0U));
		voidptr osfh = ((voidptr)(_get_osfhandle(fd)));
		GetConsoleMode(osfh, ((voidptr)(&mode)));
		return ((int)(mode));
	}
	#else
	{
	}
	#endif
	return 0;
}

VV_LOCAL_SYMBOL voidptr __as_cast(voidptr obj, int obj_type, int expected_type) {
	if (obj_type != expected_type) {
		v_panic(_STR("as cast: cannot cast %"PRId32"\000 to %"PRId32"", 2, obj_type, expected_type));
	}
	return obj;
}

VV_LOCAL_SYMBOL void __print_assert_failure(VAssertMetaInfo* i) {
	eprintln(_STR("%.*s\000:%"PRId32"\000: FAIL: fn %.*s\000: assert %.*s", 4, i->fpath, i->line_nr + 1, i->fn_name, i->src));
	if (i->op.len > 0 && string_ne(i->op, tos_lit("call"))) {
		eprintln(_STR("   left value: %.*s\000 = %.*s", 2, i->llabel, i->lvalue));
		if (string_eq(i->rlabel, i->rvalue)) {
			eprintln(_STR("  right value: %.*s", 1, i->rlabel));
		} else {
			eprintln(_STR("  right value: %.*s\000 = %.*s", 2, i->rlabel, i->rvalue));
		}
	}
}

VV_LOCAL_SYMBOL void restore_codepage() {
	SetConsoleOutputCP(g_original_codepage);
}

VV_LOCAL_SYMBOL void builtin_init() {
	g_original_codepage = GetConsoleOutputCP();
	SetConsoleOutputCP(CP_UTF8);
	atexit(restore_codepage);
	if (is_atty(1) > 0) {
		SetConsoleMode(GetStdHandle(STD_OUTPUT_HANDLE), (ENABLE_PROCESSED_OUTPUT | 0x0004));
		SetConsoleMode(GetStdHandle(STD_ERROR_HANDLE), (ENABLE_PROCESSED_OUTPUT | 0x0004));
		{ // Unsafe block
			setbuf(stdout, 0);
			setbuf(stderr, 0);
		}
	}
	add_unhandled_exception_handler();
}

VV_LOCAL_SYMBOL bool print_backtrace_skipping_top_frames(int skipframes) {
	#if defined(_MSC_VER)
	{
	}
	#endif
	#if defined(__TINYC__)
	{
	}
	#endif
	#if defined(__MINGW32__)
	{
	}
	#endif
	eprintln(tos_lit("print_backtrace_skipping_top_frames is not implemented"));
	return false;
}

VV_LOCAL_SYMBOL bool print_backtrace_skipping_top_frames_msvc(int skipframes) {
	#if defined(_MSC_VER)
	{
	}
	#else
	{
		eprintln(tos_lit("print_backtrace_skipping_top_frames_msvc must be called only when the compiler is msvc"));
		return false;
	}
	#endif
	return 0;
}

VV_LOCAL_SYMBOL bool print_backtrace_skipping_top_frames_mingw(int skipframes) {
	eprintln(tos_lit("print_backtrace_skipping_top_frames_mingw is not implemented"));
	return false;
}

VV_LOCAL_SYMBOL bool print_backtrace_skipping_top_frames_tcc(int skipframes) {
	#if defined(__TINYC__)
	{
	}
	#else
	{
		eprintln(tos_lit("print_backtrace_skipping_top_frames_tcc must be called only when the compiler is tcc"));
		return false;
	}
	#endif
	return 0;
}

// TypeDecl
VV_LOCAL_SYMBOL void add_vectored_exception_handler(VectoredExceptionHandler handler) {
	AddVectoredExceptionHandler(1, ((PVECTORED_EXCEPTION_HANDLER)(handler)));
}

// Attr: [windows_stdcall]
VV_LOCAL_SYMBOL int __stdcall  unhandled_exception_handler(ExceptionPointers* e) {
	u32 _t22 = e->exception_record->code;
	if (_t22 == 0x4001000A || _t22 == 0x40010006) {
		return 0;
	} else {
		println(_STR("Unhandled Exception 0x%"PRIX32"", 1, e->exception_record->code));
		print_backtrace_skipping_top_frames(5);
	};
	return 0;
}

VV_LOCAL_SYMBOL void add_unhandled_exception_handler() {
	add_vectored_exception_handler(((VectoredExceptionHandler)(((voidptr)(unhandled_exception_handler)))));
}

VV_LOCAL_SYMBOL void break_if_debugger_attached() {
	#if defined(__TINYC__)
	{
	}
	#else
	{
		if (IsDebuggerPresent()) {
			__debugbreak();
		}
	}
	#endif
}

int proc_pidpath(int , voidptr , int );

// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
void chan_close(chan ch) {
}

ChanState chan_try_pop(chan ch, voidptr obj) {
	return ChanState_success;
}

ChanState chan_try_push(chan ch, voidptr obj) {
	return ChanState_success;
}

// Attr: [inline]
inline string f64_str(f64 x) {
	f64 abs_x = f64_abs(x);
	if (abs_x >= 0.0001 && abs_x < 1.0e6) {
		return strconv__f64_to_str_l(x);
	} else {
		return strconv__ftoa_64(x);
	}
	return (string){.str=(byteptr)""};
}

// Attr: [inline]
inline string any_float_str(any_float d) {
	return f64_str(((f64)(d)));
}

// Attr: [inline]
inline string f64_strsci(f64 x, int digit_num) {
	int n_digit = digit_num;
	if (n_digit < 1) {
		n_digit = 1;
	} else if (n_digit > 17) {
		n_digit = 17;
	}
	return strconv__f64_to_str(x, n_digit);
}

// Attr: [inline]
inline string f64_strlong(f64 x) {
	return strconv__f64_to_str_l(x);
}

// Attr: [inline]
inline string f32_str(f32 x) {
	f32 abs_x = f32_abs(x);
	if (abs_x >= 0.0001 && abs_x < 1.0e6) {
		return strconv__f32_to_str_l(x);
	} else {
		return strconv__ftoa_32(x);
	}
	return (string){.str=(byteptr)""};
}

// Attr: [inline]
inline string f32_strsci(f32 x, int digit_num) {
	int n_digit = digit_num;
	if (n_digit < 1) {
		n_digit = 1;
	} else if (n_digit > 8) {
		n_digit = 8;
	}
	return strconv__f32_to_str(x, n_digit);
}

// Attr: [inline]
inline string f32_strlong(f32 x) {
	return strconv__f32_to_str_l(x);
}

// Attr: [inline]
inline f32 f32_abs(f32 a) {
	return (a < 0 ? (-a) : (a));
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL f64 f64_abs(f64 a) {
	return (a < 0 ? (-a) : (a));
}

// Attr: [inline]
inline f32 f32_max(f32 a, f32 b) {
	return (a > b ? (a) : (b));
}

// Attr: [inline]
inline f32 f32_min(f32 a, f32 b) {
	return (a < b ? (a) : (b));
}

// Attr: [inline]
inline f64 f64_max(f64 a, f64 b) {
	return (a > b ? (a) : (b));
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL f64 f64_min(f64 a, f64 b) {
	return (a < b ? (a) : (b));
}

// Attr: [inline]
inline bool f32_eq_epsilon(f32 a, f32 b) {
	f32 hi = f32_max(f32_abs(a), f32_abs(b));
	f32 delta = f32_abs(a - b);
	if (hi > ((f32)(1.0))) {
		return delta <= hi * (4 * ((f32)(FLT_EPSILON)));
	} else {
		return (1 / (4 * ((f32)(FLT_EPSILON)))) * delta <= hi;
	}
	return 0;
}

// Attr: [inline]
inline bool f64_eq_epsilon(f64 a, f64 b) {
	f64 hi = f64_max(f64_abs(a), f64_abs(b));
	f64 delta = f64_abs(a - b);
	if (hi > 1.0) {
		return delta <= hi * (4 * ((f64)(DBL_EPSILON)));
	} else {
		return (1 / (4 * ((f64)(DBL_EPSILON)))) * delta <= hi;
	}
	return 0;
}

string ptr_str(voidptr ptr) {
	string buf1 = u64_hex(((u64)(ptr)));
	return buf1;
}

// Attr: [inline]
inline string int_str_l(int nn, int max) {
	i64 n = ((i64)(nn));
	int d = 0;
	if (n == 0) {
		return tos_lit("0");
	}
	byteptr buf = v_malloc(max + 1);
	bool is_neg = false;
	if (n < 0) {
		n = -n;
		is_neg = true;
	}
	int index = max;
	{ // Unsafe block
		buf[index--] = '\0';
	}
	for (;;) {
		if (!(n > 0)) break;
		int n1 = ((int)(n / 100));
		d = ((((int)(n)) - (n1 * 100)) << 1);
		n = n1;
		{ // Unsafe block
			buf[index--] = _const_digit_pairs.str[d++];
			buf[index--] = _const_digit_pairs.str[d];
		}
	}
	index++;
	if (d < 20) {
		index++;
	}
	if (is_neg) {
		index--;
		{ // Unsafe block
			buf[index] = '-';
		}
	}
	{ // Unsafe block
		memmove(buf, buf + index, (max - index) + 1);
		return tos(buf, (max - index));
	}
	return (string){.str=(byteptr)""};
}

string i8_str(i8 n) {
	return int_str_l(((int)(n)), 5);
}

string i16_str(i16 n) {
	return int_str_l(((int)(n)), 7);
}

string u16_str(u16 n) {
	return int_str_l(((int)(n)), 7);
}

string int_str(int n) {
	return int_str_l(n, 12);
}

string u32_str(u32 nn) {
	u32 n = nn;
	u32 d = ((u32)(0U));
	if (n == 0) {
		return tos_lit("0");
	}
	int max = 12;
	byteptr buf = v_malloc(max + 1);
	int index = max;
	{ // Unsafe block
		buf[index--] = '\0';
	}
	for (;;) {
		if (!(n > 0)) break;
		u32 n1 = n / ((u32)(100U));
		d = ((n - (n1 * ((u32)(100U)))) << ((u32)(1U)));
		n = n1;
		{ // Unsafe block
			buf[index--] = string_at(_const_digit_pairs, d++);
			buf[index--] = string_at(_const_digit_pairs, d);
		}
	}
	index++;
	if (d < ((u32)(20U))) {
		index++;
	}
	{ // Unsafe block
		memmove(buf, buf + index, (max - index) + 1);
		return tos(buf, (max - index));
	}
	return (string){.str=(byteptr)""};
}

// Attr: [inline]
inline string any_int_str(any_int n) {
	return i64_str(((i64)(n)));
}

string i64_str(i64 nn) {
	i64 n = nn;
	i64 d = ((i64)(0));
	if (n == 0) {
		return tos_lit("0");
	}
	int max = 20;
	byteptr buf = vcalloc(max + 1);
	bool is_neg = false;
	if (n < 0) {
		n = -n;
		is_neg = true;
	}
	int index = max;
	{ // Unsafe block
		buf[index--] = '\0';
	}
	for (;;) {
		if (!(n > 0)) break;
		i64 n1 = n / ((i64)(100));
		d = ((n - (n1 * ((i64)(100)))) << ((i64)(1)));
		n = n1;
		{ // Unsafe block
			buf[index--] = string_at(_const_digit_pairs, d++);
			buf[index--] = string_at(_const_digit_pairs, d);
		}
	}
	index++;
	if (d < ((i64)(20))) {
		index++;
	}
	if (is_neg) {
		index--;
		{ // Unsafe block
			buf[index] = '-';
		}
	}
	{ // Unsafe block
		memmove(buf, buf + index, (max - index) + 1);
		return tos(buf, (max - index));
	}
	return (string){.str=(byteptr)""};
}

string u64_str(u64 nn) {
	u64 n = nn;
	u64 d = ((u64)(0U));
	if (n == 0) {
		return tos_lit("0");
	}
	int max = 20;
	byteptr buf = vcalloc(max + 1);
	int index = max;
	{ // Unsafe block
		buf[index--] = '\0';
	}
	for (;;) {
		if (!(n > 0)) break;
		u64 n1 = n / 100;
		d = ((n - (n1 * 100)) << 1);
		n = n1;
		{ // Unsafe block
			buf[index--] = string_at(_const_digit_pairs, d++);
			buf[index--] = string_at(_const_digit_pairs, d);
		}
	}
	index++;
	if (d < 20) {
		index++;
	}
	{ // Unsafe block
		memmove(buf, buf + index, (max - index) + 1);
		return tos(buf, (max - index));
	}
	return (string){.str=(byteptr)""};
}

string bool_str(bool b) {
	if (b) {
		return tos_lit("true");
	}
	return tos_lit("false");
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL string u64_to_hex(u64 nn, byte len) {
	u64 n = nn;
	array_fixed_byte_256 buf = {0};
	buf[len] = '\0';
	int i = 0;
	for (i = len - 1; i >= 0; i--) {
		byte d = ((byte)((n & 0xF)));
		rune x = (d < 10 ? (d + '0') : (d + 87));
		buf[i] = x;
		n = n >> 4;
	}
	return (string){.str = memdup((voidptr)&/*qq*/buf, len + 1), .len = len};
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL string u64_to_hex_no_leading_zeros(u64 nn, byte len) {
	u64 n = nn;
	array_fixed_byte_256 buf = {0};
	buf[len] = '\0';
	int i = 0;
	for (i = len - 1; i >= 0; i--) {
		byte d = ((byte)((n & 0xF)));
		rune x = (d < 10 ? (d + '0') : (d + 87));
		buf[i] = x;
		n = n >> 4;
		if (n == 0) {
			break;
		}
	}
	int res_len = len - i;
	return (string){.str = memdup(&buf[i], res_len + 1), .len = res_len};
}

string byte_hex(byte nn) {
	if (nn == 0) {
		return tos_lit("00");
	}
	return u64_to_hex(nn, 2);
}

string i8_hex(i8 nn) {
	return byte_hex(((byte)(nn)));
}

string u16_hex(u16 nn) {
	if (nn == 0) {
		return tos_lit("0");
	}
	return u64_to_hex_no_leading_zeros(nn, 4);
}

string i16_hex(i16 nn) {
	return u16_hex(((u16)(nn)));
}

string u32_hex(u32 nn) {
	if (nn == 0) {
		return tos_lit("0");
	}
	return u64_to_hex_no_leading_zeros(nn, 8);
}

string int_hex(int nn) {
	return u32_hex(((u32)(nn)));
}

string int_hex2(int n) {
	return string_add(tos_lit("0x"), int_hex(n));
}

string u64_hex(u64 nn) {
	if (nn == 0) {
		return tos_lit("0");
	}
	return u64_to_hex_no_leading_zeros(nn, 16);
}

string i64_hex(i64 nn) {
	return u64_hex(((u64)(nn)));
}

string any_int_hex(any_int nn) {
	return u64_hex(((u64)(nn)));
}

string voidptr_str(voidptr nn) {
	return u64_hex(((u64)(nn)));
}

string byteptr_str(byteptr nn) {
	return u64_hex(((u64)(nn)));
}

string u64_hex_full(u64 nn) {
	return u64_to_hex(nn, 16);
}

string byte_str(byte b) {
	string str = (string){.str = v_malloc(2), .len = 1};
	{ // Unsafe block
		str.str[0] = b;
		str.str[1] = '\0';
	}
	return str;
}

string byte_str_escaped(byte b) {
	byte _t23 = b;
		string str = ((_t23 == 0) ? (string_add(tos_lit("`\\"), tos_lit("0`"))) : (_t23 == 7) ? (tos_lit("`\\a`")) : (_t23 == 8) ? (tos_lit("`\\b`")) : (_t23 == 9) ? (tos_lit("`\\t`")) : (_t23 == 10) ? (tos_lit("`\\n`")) : (_t23 == 11) ? (tos_lit("`\\v`")) : (_t23 == 12) ? (tos_lit("`\\f`")) : (_t23 == 13) ? (tos_lit("`\\r`")) : ((_t23 >= 32 && _t23 <= 126)) ? (byte_str(b)) : (string_add(tos_lit("0x"), byte_hex(b))));
	return str;
}

bool array_byte_contains(array_byte a, byte val) {
	// FOR IN array
	array _t24 = a;
	for (int _t25 = 0; _t25 < _t24.len; ++_t25) {
		byte aa = ((byte*)_t24.data)[_t25];
		if (aa == val) {
			return true;
		}
	}
	return false;
}

bool array_u16_contains(array_u16 a, u16 val) {
	// FOR IN array
	array _t26 = a;
	for (int _t27 = 0; _t27 < _t26.len; ++_t27) {
		u16 aa = ((u16*)_t26.data)[_t27];
		if (aa == val) {
			return true;
		}
	}
	return false;
}

VV_LOCAL_SYMBOL bool array_int_contains(array_int ar, int val) {
	// FOR IN array
	array _t28 = ar;
	for (int _t29 = 0; _t29 < _t28.len; ++_t29) {
		int s = ((int*)_t28.data)[_t29];
		if (s == val) {
			return true;
		}
	}
	return false;
}

bool array_u64_contains(array_u64 a, u64 val) {
	// FOR IN array
	array _t30 = a;
	for (int _t31 = 0; _t31 < _t30.len; ++_t31) {
		u64 aa = ((u64*)_t30.data)[_t31];
		if (aa == val) {
			return true;
		}
	}
	return false;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL bool fast_string_eq(string a, string b) {
	if (a.len != b.len) {
		return false;
	}
	{ // Unsafe block
		return memcmp(a.str, b.str, b.len) == 0;
	}
	return 0;
}

// Attr: [inline]
// Attr: [unsafe]
inline VV_LOCAL_SYMBOL DenseArray new_dense_array(int value_bytes) {
	int s8size = ((int)(8 * /*SizeOfType*/ sizeof(string)));
	return (DenseArray){
		.value_bytes = value_bytes,
		.cap = 8,
		.len = 0,
		.deletes = 0,
		.keys = ((string*)(v_malloc(s8size))),
		.values = v_malloc(8 * value_bytes),
	};
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL u32 DenseArray_push(DenseArray* d, string key, voidptr value) {
	if (d->cap == d->len) {
		d->cap += d->cap >> 3;
		{ // Unsafe block
			byteptr x = v_realloc(((byteptr)(d->keys)), /*SizeOfType*/ sizeof(string) * d->cap);
			d->keys = ((string*)(x));
			d->values = v_realloc(((byteptr)(d->values)), ((u32)(d->value_bytes)) * d->cap);
		}
	}
	u32 push_index = d->len;
	{ // Unsafe block
		d->keys[push_index] = key;
		memcpy(d->values + push_index * ((u32)(d->value_bytes)), value, d->value_bytes);
	}
	d->len++;
	return push_index;
}

VV_LOCAL_SYMBOL voidptr DenseArray_get(DenseArray d, int i) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (i < 0 || i >= ((int)(d.len))) {
			v_panic(_STR("DenseArray.get: index out of range (i == %"PRId32"\000, d.len == %"PRIu32"\000)", 3, i, d.len));
		}
	}
	#endif
	{ // Unsafe block
		return ((byteptr)(d.keys)) + i * ((int)(/*SizeOfType*/ sizeof(string)));
	}
	return 0;
}

VV_LOCAL_SYMBOL void DenseArray_zeros_to_end(DenseArray* d) {
	byteptr tmp_value = v_malloc(d->value_bytes);
	u32 count = ((u32)(0U));
	for (int i = 0; i < ((int)(d->len)); ++i) {
		if (d->keys[i].str != 0) {
			{ // Unsafe block
				string tmp_key = d->keys[count];
				d->keys[count] = d->keys[i];
				d->keys[i] = tmp_key;
			}
			{ // Unsafe block
				memcpy(tmp_value, d->values + count * ((u32)(d->value_bytes)), d->value_bytes);
				memcpy(d->values + count * ((u32)(d->value_bytes)), d->values + i * d->value_bytes, d->value_bytes);
				memcpy(d->values + i * d->value_bytes, tmp_value, d->value_bytes);
			}
			count++;
		}
	}
	v_free(tmp_value);
	d->deletes = 0;
	d->len = count;
	d->cap = (count < 8 ? (((u32)(8U))) : (count));
	{ // Unsafe block
		byteptr x = v_realloc(((byteptr)(d->keys)), /*SizeOfType*/ sizeof(string) * d->cap);
		d->keys = ((string*)(x));
		d->values = v_realloc(((byteptr)(d->values)), ((u32)(d->value_bytes)) * d->cap);
	}
}

VV_LOCAL_SYMBOL map new_map_1(int value_bytes) {
	int metasize = ((int)(/*SizeOfType*/ sizeof(u32) * (_const_init_capicity + _const_extra_metas_inc)));
	return (map){
		.value_bytes = value_bytes,
		.cap = _const_init_cap,
		.cached_hashbits = _const_max_cached_hashbits,
		.shift = _const_init_log_capicity,
		.key_values = new_dense_array(value_bytes),
		.metas = ((u32*)(vcalloc(metasize))),
		.extra_metas = _const_extra_metas_inc,
		.len = 0,
	};
}

VV_LOCAL_SYMBOL map new_map_init(int n, int value_bytes, string* keys, voidptr values) {
	map out = new_map_1(value_bytes);
	for (int i = 0; i < n; ++i) {
		map_set(&out, keys[i], ((byteptr)(values)) + i * value_bytes);
	}
	return out;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL multi_return_u32_u32 map_key_to_index(map* m, string key) {
	u64 hash = hash__wyhash_c(key.str, ((u64)(key.len)), 0);
	u64 index = (hash & m->cap);
	u64 meta = ((((hash >> m->shift) & _const_hash_mask)) | _const_probe_inc);
	return (multi_return_u32_u32){.arg0=((u32)(index)), .arg1=((u32)(meta))};
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL multi_return_u32_u32 map_meta_less(map* m, u32 _index, u32 _metas) {
	u32 index = _index;
	u32 meta = _metas;
	for (;;) {
		if (!(meta < m->metas[index])) break;
		index += 2;
		meta += _const_probe_inc;
	}
	return (multi_return_u32_u32){.arg0=index, .arg1=meta};
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL void map_meta_greater(map* m, u32 _index, u32 _metas, u32 kvi) {
	u32 meta = _metas;
	u32 index = _index;
	u32 kv_index = kvi;
	for (;;) {
		if (!(m->metas[index] != 0)) break;
		if (meta > m->metas[index]) {
			{ // Unsafe block
				u32 tmp_meta = m->metas[index];
				m->metas[index] = meta;
				meta = tmp_meta;
			}
			u32 tmp_index = m->metas[index + 1];
			{ // Unsafe block
				m->metas[index + 1] = kv_index;
			}
			kv_index = tmp_index;
		}
		index += 2;
		meta += _const_probe_inc;
	}
	{ // Unsafe block
		m->metas[index] = meta;
		m->metas[index + 1] = kv_index;
	}
	u32 probe_count = (meta >> _const_hashbits) - 1;
	map_ensure_extra_metas(m, probe_count);
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL void map_ensure_extra_metas(map* m, u32 probe_count) {
	if ((probe_count << 1) == m->extra_metas) {
		m->extra_metas += _const_extra_metas_inc;
		u32 mem_size = (m->cap + 2 + m->extra_metas);
		{ // Unsafe block
			byteptr x = v_realloc(((byteptr)(m->metas)), /*SizeOfType*/ sizeof(u32) * mem_size);
			m->metas = ((u32*)(x));
			memset(m->metas + mem_size - _const_extra_metas_inc, 0, /*SizeOfType*/ sizeof(u32) * _const_extra_metas_inc);
		}
		if (probe_count == 252) {
			v_panic(tos_lit("Probe overflow"));
		}
	}
}

VV_LOCAL_SYMBOL void map_set(map* m, string k, voidptr value) {
	string key = string_clone(k);
	f32 load_factor = ((f32)(m->len << 1)) / ((f32)(m->cap));
	if (load_factor > _const_max_load_factor) {
		map_expand(m);
	}
	multi_return_u32_u32 mr_9362 = map_key_to_index(m, key);
	u32 index = mr_9362.arg0;
	u32 meta = mr_9362.arg1;
	multi_return_u32_u32 mr_9397 = map_meta_less(m, index, meta);
	index = mr_9397.arg0;
	meta = mr_9397.arg1;
	for (;;) {
		if (!(meta == m->metas[index])) break;
		u32 kv_index = m->metas[index + 1];
		if (fast_string_eq(key, m->key_values.keys[kv_index])) {
			memcpy(m->key_values.values + kv_index * ((u32)(m->value_bytes)), value, m->value_bytes);
			return;
		}
		index += 2;
		meta += _const_probe_inc;
	}
	u32 kv_index = DenseArray_push(&m->key_values, key, value);
	map_meta_greater(m, index, meta, kv_index);
	m->len++;
}

VV_LOCAL_SYMBOL void map_expand(map* m) {
	u32 old_cap = m->cap;
	m->cap = ((m->cap + 2) << 1) - 2;
	if (m->cached_hashbits == 0) {
		m->shift += _const_max_cached_hashbits;
		m->cached_hashbits = _const_max_cached_hashbits;
		map_rehash(m);
	} else {
		map_cached_rehash(m, old_cap);
		m->cached_hashbits--;
	}
}

VV_LOCAL_SYMBOL void map_rehash(map* m) {
	u32 meta_bytes = /*SizeOfType*/ sizeof(u32) * (m->cap + 2 + m->extra_metas);
	{ // Unsafe block
		byteptr x = v_realloc(((byteptr)(m->metas)), meta_bytes);
		m->metas = ((u32*)(x));
		memset(m->metas, 0, meta_bytes);
	}
	for (u32 i = ((u32)(0U)); i < m->key_values.len; i++) {
		if (m->key_values.keys[i].str == 0) {
			continue;
		}
		multi_return_u32_u32 mr_10794 = map_key_to_index(m, m->key_values.keys[i]);
		u32 index = mr_10794.arg0;
		u32 meta = mr_10794.arg1;
		multi_return_u32_u32 mr_10856 = map_meta_less(m, index, meta);
		index = mr_10856.arg0;
		meta = mr_10856.arg1;
		map_meta_greater(m, index, meta, i);
	}
}

VV_LOCAL_SYMBOL void map_cached_rehash(map* m, u32 old_cap) {
	u32* old_metas = m->metas;
	int metasize = ((int)(/*SizeOfType*/ sizeof(u32) * (m->cap + 2 + m->extra_metas)));
	m->metas = ((u32*)(vcalloc(metasize)));
	u32 old_extra_metas = m->extra_metas;
	for (u32 i = ((u32)(0U)); i <= old_cap + old_extra_metas; i += 2) {
		if (old_metas[i] == 0) {
			continue;
		}
		u32 old_meta = old_metas[i];
		u32 old_probe_count = ((old_meta >> _const_hashbits) - 1) << 1;
		u32 old_index = ((i - old_probe_count) & (m->cap >> 1));
		u32 index = (((old_index | (old_meta << m->shift))) & m->cap);
		u32 meta = (((old_meta & _const_hash_mask)) | _const_probe_inc);
		multi_return_u32_u32 mr_11613 = map_meta_less(m, index, meta);
		index = mr_11613.arg0;
		meta = mr_11613.arg1;
		u32 kv_index = old_metas[i + 1];
		map_meta_greater(m, index, meta, kv_index);
	}
	v_free(old_metas);
}

VV_LOCAL_SYMBOL voidptr map_get_and_set(map* m, string key, voidptr zero) {
	for (;;) {
		multi_return_u32_u32 mr_12059 = map_key_to_index(m, key);
		u32 index = mr_12059.arg0;
		u32 meta = mr_12059.arg1;
		for (;;) {
			if (meta == m->metas[index]) {
				u32 kv_index = m->metas[index + 1];
				if (fast_string_eq(key, m->key_values.keys[kv_index])) {
					{ // Unsafe block
						return ((voidptr)(m->key_values.values + kv_index * ((u32)(m->value_bytes))));
					}
				}
			}
			index += 2;
			meta += _const_probe_inc;
			if (meta > m->metas[index]) {
				break;
			}
		}
		map_set(m, key, zero);
	}
	// assert
	if (false) {} else {
		VAssertMetaInfo v_assert_meta_info__t32;
		memset(&v_assert_meta_info__t32, 0, sizeof(VAssertMetaInfo));
		v_assert_meta_info__t32.fpath = tos_lit("/tmp/gen_vc/v/vlib/builtin/map.v");
		v_assert_meta_info__t32.line_nr = 409;
		v_assert_meta_info__t32.fn_name = tos_lit("get_and_set");
		v_assert_meta_info__t32.src = tos_lit("false");
		__print_assert_failure(&v_assert_meta_info__t32);
		v_panic(tos_lit("Assertion failed..."));
		exit(1);
	}
	return ((voidptr)(0));
}

VV_LOCAL_SYMBOL voidptr map_get(map m, string key, voidptr zero) {
	multi_return_u32_u32 mr_12777 = map_key_to_index(&m, key);
	u32 index = mr_12777.arg0;
	u32 meta = mr_12777.arg1;
	for (;;) {
		if (meta == m.metas[index]) {
			u32 kv_index = m.metas[index + 1];
			if (fast_string_eq(key, m.key_values.keys[kv_index])) {
				{ // Unsafe block
					return ((voidptr)(m.key_values.values + kv_index * ((u32)(m.value_bytes))));
				}
			}
		}
		index += 2;
		meta += _const_probe_inc;
		if (meta > m.metas[index]) {
			break;
		}
	}
	return zero;
}

VV_LOCAL_SYMBOL bool map_exists(map m, string key) {
	multi_return_u32_u32 mr_13265 = map_key_to_index(&m, key);
	u32 index = mr_13265.arg0;
	u32 meta = mr_13265.arg1;
	for (;;) {
		if (meta == m.metas[index]) {
			u32 kv_index = m.metas[index + 1];
			if (fast_string_eq(key, m.key_values.keys[kv_index])) {
				return true;
			}
		}
		index += 2;
		meta += _const_probe_inc;
		if (meta > m.metas[index]) {
			break;
		}
	}
	return false;
}

void map_delete(map* m, string key) {
	multi_return_u32_u32 mr_13685 = map_key_to_index(m, key);
	u32 index = mr_13685.arg0;
	u32 meta = mr_13685.arg1;
	multi_return_u32_u32 mr_13720 = map_meta_less(m, index, meta);
	index = mr_13720.arg0;
	meta = mr_13720.arg1;
	for (;;) {
		if (!(meta == m->metas[index])) break;
		u32 kv_index = m->metas[index + 1];
		if (fast_string_eq(key, m->key_values.keys[kv_index])) {
			for (;;) {
				if (!((m->metas[index + 2] >> _const_hashbits) > 1)) break;
				{ // Unsafe block
					m->metas[index] = m->metas[index + 2] - _const_probe_inc;
					m->metas[index + 1] = m->metas[index + 3];
				}
				index += 2;
			}
			m->len--;
			{ // Unsafe block
				m->metas[index] = 0;
			}
			m->key_values.deletes++;
			{ // Unsafe block
				string_free(&m->key_values.keys[kv_index]);
				memset(&m->key_values.keys[kv_index], 0, /*SizeOfType*/ sizeof(string));
			}
			if (m->key_values.len <= 32) {
				return;
			}
			if (m->key_values.deletes >= (m->key_values.len >> 1)) {
				DenseArray_zeros_to_end(&m->key_values);
				map_rehash(m);
				m->key_values.deletes = 0;
			}
			return;
		}
		index += 2;
		meta += _const_probe_inc;
	}
}

array_string map_keys(map* m) {
	array_string keys = __new_array_with_default(m->len, 0, sizeof(string), &(string[]){tos_lit("")});
	int j = 0;
	for (u32 i = ((u32)(0U)); i < m->key_values.len; i++) {
		if (m->key_values.keys[i].str == 0) {
			continue;
		}
		array_set(&keys, j, &(string[]) { string_clone(m->key_values.keys[i]) });
		j++;
	}
	return keys;
}

// Attr: [unsafe]
DenseArray DenseArray_clone(DenseArray d) {
	int ksize = ((int)(d.cap * /*SizeOfType*/ sizeof(string)));
	int vsize = ((int)(d.cap * ((u32)(d.value_bytes))));
	DenseArray res = (DenseArray){
		.value_bytes = d.value_bytes,
		.cap = d.cap,
		.len = d.len,
		.deletes = d.deletes,
		.keys = ((string*)(v_malloc(ksize))),
		.values = ((byteptr)(v_malloc(vsize))),
	};
	{ // Unsafe block
		memcpy(res.keys, d.keys, ksize);
		memcpy(res.values, d.values, vsize);
	}
	return res;
}

// Attr: [unsafe]
map map_clone(map m) {
	int metasize = ((int)(/*SizeOfType*/ sizeof(u32) * (m.cap + 2 + m.extra_metas)));
	map res = (map){
		.value_bytes = m.value_bytes,
		.cap = m.cap,
		.cached_hashbits = m.cached_hashbits,
		.shift = m.shift,
		.key_values = DenseArray_clone(m.key_values),
		.metas = ((u32*)(v_malloc(metasize))),
		.extra_metas = m.extra_metas,
		.len = m.len,
	};
	memcpy(res.metas, m.metas, metasize);
	return res;
}

// Attr: [unsafe]
void map_free(map* m) {
	v_free(m->metas);
	for (u32 i = ((u32)(0U)); i < m->key_values.len; i++) {
		if (m->key_values.keys[i].str == 0) {
			continue;
		}
		string_free(&m->key_values.keys[i]);
	}
	{ // Unsafe block
		v_free(m->key_values.keys);
		v_free(m->key_values.values);
	}
}

string OptionBase_str(OptionBase o) {
	if (o.ok && !o.is_none) {
		return tos_lit("Option{ valid }");
	}
	if (o.is_none) {
		return tos_lit("Option{ none }");
	}
	return _STR("Option{ error: \"%.*s\000\" }", 2, o.v_error);
}

VV_LOCAL_SYMBOL void opt_ok2(voidptr data, OptionBase* option, int size) {
	{ // Unsafe block
		*option = (OptionBase){.ok = true,.is_none = 0,.v_error = (string){.str=(byteptr)""},.ecode = 0,};
		memcpy(((byteptr)(&option->ecode)) + /*SizeOfType*/ sizeof(int), data, size);
	}
}

string Option_str(Option o) {
	if (o.ok && !o.is_none) {
		return tos_lit("Option{ ok }");
	}
	if (o.is_none) {
		return tos_lit("Option{ none }");
	}
	return _STR("Option{ error: \"%.*s\000\" }", 2, o.v_error);
}

VV_LOCAL_SYMBOL Option opt_none() {
	return (Option){.ok = false,.is_none = true,.v_error = (string){.str=(byteptr)""},.ecode = 0,};
}

Option v_error(string s) {
	return (Option){.ok = false,.is_none = false,.v_error = s,.ecode = 0,};
}

Option error_with_code(string s, int code) {
	return (Option){.ok = false,.is_none = false,.v_error = s,.ecode = code,};
}

// TypeDecl
string rune_str(rune c) {
	return utf32_to_str(((u32)(c)));
}

bool byte_is_capital(byte c) {
	return c >= 'A' && c <= 'Z';
}

array_byte array_byte_clone(array_byte b) {
	array_byte res = __new_array_with_default(b.len, 0, sizeof(byte), 0);
	for (int i = 0; i < b.len; ++i) {
		array_set(&res, i, &(byte[]) { (*(byte*)/*ee elem_typ */array_get(b, i)) });
	}
	return res;
}

string array_byte_bytestr(array_byte b) {
	return bytes2string(b);
}

VV_LOCAL_SYMBOL string bytes2string(array_byte b) {
	array_byte copy = array_clone(&b);
	array_push(&copy, _MOV((byte[]){ '\0' }));
	string res = tos(copy.data, copy.len - 1);
	return res;
}

VV_LOCAL_SYMBOL SortedMap new_sorted_map(int n, int value_bytes) {
	return (SortedMap){.value_bytes = value_bytes,.root = new_node(),.len = 0,};
}

VV_LOCAL_SYMBOL SortedMap new_sorted_map_init(int n, int value_bytes, string* keys, voidptr values) {
	SortedMap out = new_sorted_map(n, value_bytes);
	for (int i = 0; i < n; ++i) {
		SortedMap_set(&out, keys[i], ((byteptr)(values)) + i * value_bytes);
	}
	return out;
}

VV_LOCAL_SYMBOL mapnode* new_node() {
	return (mapnode*)memdup(&(mapnode){.children = 0,.len = 0,.keys = {0},.values = {0},}, sizeof(mapnode));
}

VV_LOCAL_SYMBOL void SortedMap_set(SortedMap* m, string key, voidptr value) {
	mapnode* node = m->root;
	int child_index = 0;
	mapnode* parent = ((mapnode*)(0));
	for (;;) {
		if (node->len == _const_max_len) {
			if (isnil(parent)) {
				parent = new_node();
				m->root = parent;
			}
			mapnode_split_child(parent, child_index, node);
			if (string_eq(key, parent->keys[child_index])) {
				memcpy(parent->values[child_index], value, m->value_bytes);
				return;
			}
			if (string_lt(key, parent->keys[child_index])) {
				node = ((mapnode*)(parent->children[child_index]));
			} else {
				node = ((mapnode*)(parent->children[child_index + 1]));
			}
		}
		int i = 0;
		for (;;) {
			if (!(i < node->len && string_gt(key, node->keys[i]))) break;
			i++;
		}
		if (i != node->len && string_eq(key, node->keys[i])) {
			memcpy(node->values[i], value, m->value_bytes);
			return;
		}
		if (isnil(node->children)) {
			int j = node->len - 1;
			for (;;) {
				if (!(j >= 0 && string_lt(key, node->keys[j]))) break;
				node->keys[j + 1] = node->keys[j];
				node->values[j + 1] = node->values[j];
				j--;
			}
			node->keys[j + 1] = key;
			node->values[j + 1] = v_malloc(m->value_bytes);
			memcpy(node->values[j + 1], value, m->value_bytes);
			node->len++;
			m->len++;
			return;
		}
		parent = node;
		child_index = i;
		node = ((mapnode*)(node->children[child_index]));
	}
}

VV_LOCAL_SYMBOL void mapnode_split_child(mapnode* n, int child_index, mapnode* y) {
	mapnode* z = new_node();
	z->len = _const_mid_index;
	y->len = _const_mid_index;
	for (int j = _const_mid_index - 1; j >= 0; j--) {
		z->keys[j] = y->keys[j + _const_degree];
		z->values[j] = y->values[j + _const_degree];
	}
	if (!isnil(y->children)) {
		z->children = ((voidptr*)(v_malloc(((int)(_const_children_bytes)))));
		for (int jj = _const_degree - 1; jj >= 0; jj--) {
			{ // Unsafe block
				z->children[jj] = y->children[jj + _const_degree];
			}
		}
	}
	if (isnil(n->children)) {
		n->children = ((voidptr*)(v_malloc(((int)(_const_children_bytes)))));
	}
	{ // Unsafe block
		n->children[n->len + 1] = n->children[n->len];
	}
	for (int j = n->len; j > child_index; j--) {
		n->keys[j] = n->keys[j - 1];
		n->values[j] = n->values[j - 1];
		{ // Unsafe block
			n->children[j] = n->children[j - 1];
		}
	}
	n->keys[child_index] = y->keys[_const_mid_index];
	n->values[child_index] = y->values[_const_mid_index];
	{ // Unsafe block
		n->children[child_index] = ((voidptr)(y));
		n->children[child_index + 1] = ((voidptr)(z));
	}
	n->len++;
}

VV_LOCAL_SYMBOL bool SortedMap_get(SortedMap m, string key, voidptr out) {
	mapnode* node = m.root;
	for (;;) {
		int i = node->len - 1;
		for (;;) {
			if (!(i >= 0 && string_lt(key, node->keys[i]))) break;
			i--;
		}
		if (i != -1 && string_eq(key, node->keys[i])) {
			memcpy(out, node->values[i], m.value_bytes);
			return true;
		}
		if (isnil(node->children)) {
			break;
		}
		node = ((mapnode*)(node->children[i + 1]));
	}
	return false;
}

VV_LOCAL_SYMBOL bool SortedMap_exists(SortedMap m, string key) {
	if (isnil(m.root)) {
		return false;
	}
	mapnode* node = m.root;
	for (;;) {
		int i = node->len - 1;
		for (;;) {
			if (!(i >= 0 && string_lt(key, node->keys[i]))) break;
			i--;
		}
		if (i != -1 && string_eq(key, node->keys[i])) {
			return true;
		}
		if (isnil(node->children)) {
			break;
		}
		node = ((mapnode*)(node->children[i + 1]));
	}
	return false;
}

VV_LOCAL_SYMBOL int mapnode_find_key(mapnode* n, string k) {
	int idx = 0;
	for (;;) {
		if (!(idx < n->len && string_lt(n->keys[idx], k))) break;
		idx++;
	}
	return idx;
}

VV_LOCAL_SYMBOL bool mapnode_remove_key(mapnode* n, string k) {
	int idx = mapnode_find_key(n, k);
	if (idx < n->len && string_eq(n->keys[idx], k)) {
		if (isnil(n->children)) {
			mapnode_remove_from_leaf(n, idx);
		} else {
			mapnode_remove_from_non_leaf(n, idx);
		}
		return true;
	} else {
		if (isnil(n->children)) {
			return false;
		}
		bool flag = (idx == n->len ? (true) : (false));
		if (((mapnode*)(n->children[idx]))->len < _const_degree) {
			mapnode_fill(n, idx);
		}
		mapnode* node = ((mapnode*)(0));
		if (flag && idx > n->len) {
			node = ((mapnode*)(n->children[idx - 1]));
		} else {
			node = ((mapnode*)(n->children[idx]));
		}
		return mapnode_remove_key(node, k);
	}
	return 0;
}

VV_LOCAL_SYMBOL void mapnode_remove_from_leaf(mapnode* n, int idx) {
	for (int i = idx + 1; i < n->len; i++) {
		n->keys[i - 1] = n->keys[i];
		n->values[i - 1] = n->values[i];
	}
	n->len--;
}

VV_LOCAL_SYMBOL void mapnode_remove_from_non_leaf(mapnode* n, int idx) {
	string k = n->keys[idx];
	if (((mapnode*)(n->children[idx]))->len >= _const_degree) {
		mapnode* current = ((mapnode*)(n->children[idx]));
		for (;;) {
			if (!(!isnil(current->children))) break;
			current = ((mapnode*)(current->children[current->len]));
		}
		string predecessor = current->keys[current->len - 1];
		n->keys[idx] = predecessor;
		n->values[idx] = current->values[current->len - 1];
		mapnode* node = ((mapnode*)(n->children[idx]));
		mapnode_remove_key(node, predecessor);
	} else if (((mapnode*)(n->children[idx + 1]))->len >= _const_degree) {
		mapnode* current = ((mapnode*)(n->children[idx + 1]));
		for (;;) {
			if (!(!isnil(current->children))) break;
			current = ((mapnode*)(current->children[0]));
		}
		string successor = current->keys[0];
		n->keys[idx] = successor;
		n->values[idx] = current->values[0];
		mapnode* node = ((mapnode*)(n->children[idx + 1]));
		mapnode_remove_key(node, successor);
	} else {
		mapnode_merge(n, idx);
		mapnode* node = ((mapnode*)(n->children[idx]));
		mapnode_remove_key(node, k);
	}
}

VV_LOCAL_SYMBOL void mapnode_fill(mapnode* n, int idx) {
	if (idx != 0 && ((mapnode*)(n->children[idx - 1]))->len >= _const_degree) {
		mapnode_borrow_from_prev(n, idx);
	} else if (idx != n->len && ((mapnode*)(n->children[idx + 1]))->len >= _const_degree) {
		mapnode_borrow_from_next(n, idx);
	} else if (idx != n->len) {
		mapnode_merge(n, idx);
	} else {
		mapnode_merge(n, idx - 1);
	}
}

VV_LOCAL_SYMBOL void mapnode_borrow_from_prev(mapnode* n, int idx) {
	mapnode* child = ((mapnode*)(n->children[idx]));
	mapnode* sibling = ((mapnode*)(n->children[idx - 1]));
	for (int i = child->len - 1; i >= 0; i--) {
		child->keys[i + 1] = child->keys[i];
		child->values[i + 1] = child->values[i];
	}
	if (!isnil(child->children)) {
		for (int i = child->len; i >= 0; i--) {
			{ // Unsafe block
				child->children[i + 1] = child->children[i];
			}
		}
	}
	child->keys[0] = n->keys[idx - 1];
	child->values[0] = n->values[idx - 1];
	if (!isnil(child->children)) {
		{ // Unsafe block
			child->children[0] = sibling->children[sibling->len];
		}
	}
	n->keys[idx - 1] = sibling->keys[sibling->len - 1];
	n->values[idx - 1] = sibling->values[sibling->len - 1];
	child->len++;
	sibling->len--;
}

VV_LOCAL_SYMBOL void mapnode_borrow_from_next(mapnode* n, int idx) {
	mapnode* child = ((mapnode*)(n->children[idx]));
	mapnode* sibling = ((mapnode*)(n->children[idx + 1]));
	child->keys[child->len] = n->keys[idx];
	child->values[child->len] = n->values[idx];
	if (!isnil(child->children)) {
		{ // Unsafe block
			child->children[child->len + 1] = sibling->children[0];
		}
	}
	n->keys[idx] = sibling->keys[0];
	n->values[idx] = sibling->values[0];
	for (int i = 1; i < sibling->len; i++) {
		sibling->keys[i - 1] = sibling->keys[i];
		sibling->values[i - 1] = sibling->values[i];
	}
	if (!isnil(sibling->children)) {
		for (int i = 1; i <= sibling->len; i++) {
			{ // Unsafe block
				sibling->children[i - 1] = sibling->children[i];
			}
		}
	}
	child->len++;
	sibling->len--;
}

VV_LOCAL_SYMBOL void mapnode_merge(mapnode* n, int idx) {
	mapnode* child = ((mapnode*)(n->children[idx]));
	mapnode* sibling = ((mapnode*)(n->children[idx + 1]));
	child->keys[_const_mid_index] = n->keys[idx];
	child->values[_const_mid_index] = n->values[idx];
	for (int i = 0; i < sibling->len; ++i) {
		child->keys[i + _const_degree] = sibling->keys[i];
		child->values[i + _const_degree] = sibling->values[i];
	}
	if (!isnil(child->children)) {
		for (int i = 0; i <= sibling->len; i++) {
			{ // Unsafe block
				child->children[i + _const_degree] = sibling->children[i];
			}
		}
	}
	for (int i = idx + 1; i < n->len; i++) {
		n->keys[i - 1] = n->keys[i];
		n->values[i - 1] = n->values[i];
	}
	for (int i = idx + 2; i <= n->len; i++) {
		{ // Unsafe block
			n->children[i - 1] = n->children[i];
		}
	}
	child->len += sibling->len + 1;
	n->len--;
}

void SortedMap_delete(SortedMap* m, string key) {
	if (m->root->len == 0) {
		return;
	}
	bool removed = mapnode_remove_key(m->root, key);
	if (removed) {
		m->len--;
	}
	if (m->root->len == 0) {
		if (isnil(m->root->children)) {
			return;
		} else {
			m->root = ((mapnode*)(m->root->children[0]));
		}
	}
}

VV_LOCAL_SYMBOL int mapnode_subkeys(mapnode* n, array_string* keys, int at) {
	int position = at;
	if (!isnil(n->children)) {
		for (int i = 0; i < n->len; ++i) {
			mapnode* child = ((mapnode*)(n->children[i]));
			position += mapnode_subkeys(child, keys, position);
			array_set(keys, position, &(string[]) { n->keys[i] });
			position++;
		}
		mapnode* child = ((mapnode*)(n->children[n->len]));
		position += mapnode_subkeys(child, keys, position);
	} else {
		for (int i = 0; i < n->len; ++i) {
			array_set(keys, position + i, &(string[]) { n->keys[i] });
		}
		position += n->len;
	}
	return position - at;
}

array_string SortedMap_keys(SortedMap* m) {
	array_string keys = __new_array_with_default(m->len, 0, sizeof(string), &(string[]){tos_lit("")});
	if (isnil(m->root) || m->root->len == 0) {
		return keys;
	}
	mapnode_subkeys(m->root, &/*arr*/keys, 0);
	return keys;
}

VV_LOCAL_SYMBOL void mapnode_free(mapnode* n) {
	println(tos_lit("TODO"));
}

void SortedMap_free(SortedMap* m) {
	if (isnil(m->root)) {
		return;
	}
	mapnode_free(m->root);
}

void SortedMap_print(SortedMap m) {
	println(tos_lit("TODO"));
}

// Attr: [unsafe]
int vstrlen(byteptr s) {
	return strlen(((charptr)(s)));
}

// Attr: [unsafe]
string tos(byteptr s, int len) {
	if (s == 0) {
		v_panic(tos_lit("tos(): nil string"));
	}
	return (string){.str = s, .len = len};
}

string tos_clone(byteptr s) {
	return string_clone(tos2(s));
}

string tos2(byteptr s) {
	if (s == 0) {
		v_panic(tos_lit("tos2: nil string"));
	}
	return (string){.str = s, .len = vstrlen(s)};
}

string tos3(charptr s) {
	if (s == 0) {
		v_panic(tos_lit("tos3: nil string"));
	}
	return (string){.str = ((byteptr)(s)), .len = strlen(s)};
}

string tos_lit(charptr s) {
	return (string){.str = ((byteptr)(s)), .len = strlen(s), .is_lit = 1};
}

// Attr: [unsafe]
string byteptr_vstring(byteptr bp) {
	return (string){.str = bp, .len = strlen(((charptr)(bp)))};
}

// Attr: [unsafe]
string byteptr_vstring_with_len(byteptr bp, int len) {
	return (string){.str = bp, .len = len};
}

// Attr: [unsafe]
string charptr_vstring(charptr cp) {
	return (string){.str = ((byteptr)(cp)), .len = strlen(cp)};
}

// Attr: [unsafe]
string charptr_vstring_with_len(charptr cp, int len) {
	return (string){.str = ((byteptr)(cp)), .len = len};
}

VV_LOCAL_SYMBOL string string_clone_static(string a) {
	return string_clone(a);
}

string string_clone(string a) {
	string b = (string){.str = v_malloc(a.len + 1), .len = a.len};
	{ // Unsafe block
		memcpy(b.str, a.str, a.len);
		b.str[a.len] = '\0';
	}
	return b;
}

// Attr: [unsafe]
string cstring_to_vstring(byteptr cstr) {
	return tos_clone(cstr);
}

string string_replace_once(string s, string rep, string with) {
	Option_int _t34 = string_index(s, rep);
	if (!_t34.ok) {
		string err = _t34.v_error;
		int errcode = _t34.ecode;
		return string_clone(s);
	}
 	int index = *(int*) _t34.data;
	return string_add(string_add(string_substr(s, 0, index), with), string_substr(s, index + rep.len, s.len));
}

string string_replace(string s, string rep, string with) {
	if (s.len == 0 || rep.len == 0) {
		return string_clone(s);
	}
	array_int idxs = __new_array_with_default(0, 0, sizeof(int), 0);
	int idx = 0;
	for (;;) {
		idx = string_index_after(s, rep, idx);
		if (idx == -1) {
			break;
		}
		array_push(&idxs, _MOV((int[]){ idx }));
		idx += rep.len;
	}
	if (idxs.len == 0) {
		// Defer begin
		array_free(&idxs);
		// Defer end
		return string_clone(s);
	}
	int new_len = s.len + idxs.len * (with.len - rep.len);
	byteptr b = v_malloc(new_len + 1);
	int idx_pos = 0;
	int cur_idx = (*(int*)/*ee elem_typ */array_get(idxs, idx_pos));
	int b_i = 0;
	for (int i = 0; i < s.len; i++) {
		if (i == cur_idx) {
			for (int j = 0; j < with.len; ++j) {
				{ // Unsafe block
					b[b_i] = string_at(with, j);
				}
				b_i++;
			}
			i += rep.len - 1;
			idx_pos++;
			if (idx_pos < idxs.len) {
				cur_idx = (*(int*)/*ee elem_typ */array_get(idxs, idx_pos));
			}
		} else {
			{ // Unsafe block
				b[b_i] = string_at(s, i);
			}
			b_i++;
		}
	}
	{ // Unsafe block
		b[new_len] = '\0';
		// Defer begin
		array_free(&idxs);
		// Defer end
		return tos(b, new_len);
	}
	return (string){.str=(byteptr)""};
}

VV_LOCAL_SYMBOL int compare_rep_index(RepIndex* a, RepIndex* b) {
	if (a->idx < b->idx) {
		return -1;
	}
	if (a->idx > b->idx) {
		return 1;
	}
	return 0;
}

VV_LOCAL_SYMBOL void array_RepIndex_sort2(array_RepIndex* a) {
	array_sort_with_compare(a, compare_rep_index);
}

string string_replace_each(string s, array_string vals) {
	if (s.len == 0 || vals.len == 0) {
		return s;
	}
	if (vals.len % 2 != 0) {
		println(tos_lit("string.replace_each(): odd number of strings"));
		return s;
	}
	int new_len = s.len;
	array_RepIndex idxs = __new_array_with_default(0, 0, sizeof(RepIndex), 0);
	int idx = 0;
	for (int rep_i = 0; rep_i < vals.len; rep_i += 2) {
		string rep = (*(string*)/*ee elem_typ */array_get(vals, rep_i));
		string with = (*(string*)/*ee elem_typ */array_get(vals, rep_i + 1));
		for (;;) {
			idx = string_index_after(s, rep, idx);
			if (idx == -1) {
				break;
			}
			array_push(&idxs, _MOV((RepIndex[]){ (RepIndex){.idx = idx,.val_idx = rep_i,} }));
			idx += rep.len;
			new_len += with.len - rep.len;
		}
	}
	if (idxs.len == 0) {
		return s;
	}
	array_RepIndex_sort2(&idxs);
	byteptr b = v_malloc(new_len + 1);
	int idx_pos = 0;
	RepIndex cur_idx = (*(RepIndex*)/*ee elem_typ */array_get(idxs, idx_pos));
	int b_i = 0;
	for (int i = 0; i < s.len; i++) {
		if (i == cur_idx.idx) {
			string rep = (*(string*)/*ee elem_typ */array_get(vals, cur_idx.val_idx));
			string with = (*(string*)/*ee elem_typ */array_get(vals, cur_idx.val_idx + 1));
			for (int j = 0; j < with.len; ++j) {
				{ // Unsafe block
					b[b_i] = string_at(with, j);
				}
				b_i++;
			}
			i += rep.len - 1;
			idx_pos++;
			if (idx_pos < idxs.len) {
				cur_idx = (*(RepIndex*)/*ee elem_typ */array_get(idxs, idx_pos));
			}
		} else {
			{ // Unsafe block
				b[b_i] = s.str[i];
			}
			b_i++;
		}
	}
	{ // Unsafe block
		b[new_len] = '\0';
		return tos(b, new_len);
	}
	return (string){.str=(byteptr)""};
}

bool string_bool(string s) {
	return string_eq(s, tos_lit("true")) || string_eq(s, tos_lit("t"));
}

int string_int(string s) {
	return ((int)(strconv__common_parse_int(s, 0, 32, false, false)));
}

i64 string_i64(string s) {
	return strconv__common_parse_int(s, 0, 64, false, false);
}

i8 string_i8(string s) {
	return ((i8)(strconv__common_parse_int(s, 0, 8, false, false)));
}

i16 string_i16(string s) {
	return ((i16)(strconv__common_parse_int(s, 0, 16, false, false)));
}

f32 string_f32(string s) {
	return ((f32)(strconv__atof64(s)));
}

f64 string_f64(string s) {
	return strconv__atof64(s);
}

u16 string_u16(string s) {
	return ((u16)(strconv__common_parse_uint(s, 0, 16, false, false)));
}

u32 string_u32(string s) {
	return ((u32)(strconv__common_parse_uint(s, 0, 32, false, false)));
}

u64 string_u64(string s) {
	return strconv__common_parse_uint(s, 0, 64, false, false);
}

VV_LOCAL_SYMBOL bool string_eq(string s, string a) {
	if (s.str == 0) {
		v_panic(tos_lit("string.eq(): nil string"));
	}
	if (s.len != a.len) {
		return false;
	}
	{ // Unsafe block
		return memcmp(s.str, a.str, a.len) == 0;
	}
	return 0;
}

VV_LOCAL_SYMBOL bool string_ne(string s, string a) {
	return !string_eq(s, a);
}

VV_LOCAL_SYMBOL bool string_lt(string s, string a) {
	for (int i = 0; i < s.len; ++i) {
		if (i >= a.len || string_at(s, i) > string_at(a, i)) {
			return false;
		} else if (string_at(s, i) < string_at(a, i)) {
			return true;
		}
	}
	if (s.len < a.len) {
		return true;
	}
	return false;
}

VV_LOCAL_SYMBOL bool string_le(string s, string a) {
	return string_lt(s, a) || string_eq(s, a);
}

VV_LOCAL_SYMBOL bool string_gt(string s, string a) {
	return !string_le(s, a);
}

VV_LOCAL_SYMBOL bool string_ge(string s, string a) {
	return !string_lt(s, a);
}

VV_LOCAL_SYMBOL string string_add(string s, string a) {
	int new_len = a.len + s.len;
	string res = (string){.str = v_malloc(new_len + 1), .len = new_len};
	for (int j = 0; j < s.len; ++j) {
		{ // Unsafe block
			res.str[j] = s.str[j];
		}
	}
	for (int j = 0; j < a.len; ++j) {
		{ // Unsafe block
			res.str[s.len + j] = a.str[j];
		}
	}
	{ // Unsafe block
		res.str[new_len] = '\0';
	}
	return res;
}

array_string string_split(string s, string delim) {
	return string_split_nth(s, delim, 0);
}

array_string string_split_nth(string s, string delim, int nth) {
	array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	int i = 0;
	if (delim.len == 0) {
		i = 1;
		for (int _t37 = 0; _t37 < s.len; ++_t37) {
			byte ch = s.str[_t37];
			if (nth > 0 && i >= nth) {
				array_push(&res, _MOV((string[]){ string_substr(s, i, s.len) }));
				break;
			}
			array_push(&res, _MOV((string[]){ byte_str(ch) }));
			i++;
		}
		return res;
	}
	int start = 0;
	int nth_1 = nth - 1;
	for (;;) {
		if (!(i <= s.len)) break;
		bool is_delim = s.str[i] == delim.str[0];
		int j = 0;
		for (;;) {
			if (!(is_delim && j < delim.len)) break;
			is_delim = is_delim && s.str[i + j] == delim.str[j];
			j++;
		}
		bool last = i == s.len - 1;
		if (is_delim || last) {
			if (!is_delim && last) {
				i++;
			}
			string val = string_substr(s, start, i);
			if (string_starts_with(val, delim)) {
				val = string_right(val, delim.len);
			}
			bool was_last = nth > 0 && res.len == nth_1;
			if (was_last) {
				array_push(&res, _MOV((string[]){ string_right(s, start) }));
				break;
			}
			array_push(&res, _MOV((string[]){ val }));
			start = i + delim.len;
		}
		i++;
	}
	if (string_ends_with(s, delim) && (nth < 1 || res.len < nth)) {
		array_push(&res, _MOV((string[]){ tos_lit("") }));
	}
	return res;
}

array_string string_split_into_lines(string s) {
	array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	if (s.len == 0) {
		return res;
	}
	int start = 0;
	for (int i = 0; i < s.len; i++) {
		bool is_lf = s.str[i] == '\n';
		bool is_crlf = i != s.len - 1 && s.str[i] == '\r' && s.str[i + 1] == '\n';
		bool is_eol = is_lf || is_crlf;
		bool is_last = (is_crlf ? (i == s.len - 2) : (i == s.len - 1));
		if (is_eol || is_last) {
			if (is_last && !is_eol) {
				i++;
			}
			string line = string_substr(s, start, i);
			array_push(&res, _MOV((string[]){ line }));
			if (is_crlf) {
				i++;
			}
			start = i + 1;
		}
	}
	return res;
}

VV_LOCAL_SYMBOL string string_left(string s, int n) {
	if (n >= s.len) {
		return s;
	}
	return string_substr(s, 0, n);
}

VV_LOCAL_SYMBOL string string_right(string s, int n) {
	if (n >= s.len) {
		return tos_lit("");
	}
	return string_substr(s, n, s.len);
}

VV_LOCAL_SYMBOL string string_substr2(string s, int start, int _end, bool end_max) {
	int end = (end_max ? (s.len) : (_end));
	return string_substr(s, start, end);
}

string string_substr(string s, int start, int end) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (start > end || start > s.len || end > s.len || start < 0 || end < 0) {
			v_panic(_STR("substr(%"PRId32"\000, %"PRId32"\000) out of bounds (len=%"PRId32"\000)", 4, start, end, s.len));
		}
	}
	#endif
	int len = end - start;
	string res = (string){.str = v_malloc(len + 1), .len = len};
	for (int i = 0; i < len; ++i) {
		{ // Unsafe block
			res.str[i] = s.str[start + i];
		}
	}
	{ // Unsafe block
		res.str[len] = '\0';
	}
	return res;
}

int string_index_old(string s, string p) {
	if (p.len > s.len || p.len == 0) {
		return -1;
	}
	int i = 0;
	for (;;) {
		if (!(i < s.len)) break;
		int j = 0;
		for (;;) {
			if (!(j < p.len && s.str[i + j] == p.str[j])) break;
			j++;
		}
		if (j == p.len) {
			return i;
		}
		i++;
	}
	return -1;
}

Option_int string_index(string s, string p) {
	if (p.len > s.len || p.len == 0) {
		Option _t44 = opt_none();
		return *(Option_int*)&_t44;
	}
	int i = 0;
	for (;;) {
		if (!(i < s.len)) break;
		int j = 0;
		for (;;) {
			if (!(j < p.len && s.str[i + j] == p.str[j])) break;
			j++;
		}
		if (j == p.len) {
			Option_int _t45;
			opt_ok2(&(int[]) { i }, (OptionBase*)(&_t45), sizeof(int));
			return _t45;
		}
		i++;
	}
	Option _t46 = opt_none();
	return *(Option_int*)&_t46;
}

VV_LOCAL_SYMBOL int string_index_kmp(string s, string p) {
	if (p.len > s.len) {
		return -1;
	}
	array_int prefix = __new_array_with_default(p.len, 0, sizeof(int), 0);
	int j = 0;
	for (int i = 1; i < p.len; i++) {
		for (;;) {
			if (!(p.str[j] != p.str[i] && j > 0)) break;
			j = (*(int*)/*ee elem_typ */array_get(prefix, j - 1));
		}
		if (p.str[j] == p.str[i]) {
			j++;
		}
		array_set(&prefix, i, &(int[]) { j });
	}
	j = 0;
	for (int i = 0; i < s.len; ++i) {
		for (;;) {
			if (!(p.str[j] != s.str[i] && j > 0)) break;
			j = (*(int*)/*ee elem_typ */array_get(prefix, j - 1));
		}
		if (p.str[j] == s.str[i]) {
			j++;
		}
		if (j == p.len) {
			return i - p.len + 1;
		}
	}
	return -1;
}

int string_index_any(string s, string chars) {
	for (int _t47 = 0; _t47 < chars.len; ++_t47) {
		byte c = chars.str[_t47];
		Option_int _t48 = string_index(s, byte_str(c));
		if (!_t48.ok) {
			string err = _t48.v_error;
			int errcode = _t48.ecode;
			continue;
		}
 		int index = *(int*) _t48.data;
		return index;
	}
	return -1;
}

Option_int string_last_index(string s, string p) {
	if (p.len > s.len || p.len == 0) {
		Option _t49 = opt_none();
		return *(Option_int*)&_t49;
	}
	int i = s.len - p.len;
	for (;;) {
		if (!(i >= 0)) break;
		int j = 0;
		for (;;) {
			if (!(j < p.len && s.str[i + j] == p.str[j])) break;
			j++;
		}
		if (j == p.len) {
			Option_int _t50;
			opt_ok2(&(int[]) { i }, (OptionBase*)(&_t50), sizeof(int));
			return _t50;
		}
		i--;
	}
	Option _t51 = opt_none();
	return *(Option_int*)&_t51;
}

int string_index_after(string s, string p, int start) {
	if (p.len > s.len) {
		return -1;
	}
	int strt = start;
	if (start < 0) {
		strt = 0;
	}
	if (start >= s.len) {
		return -1;
	}
	int i = strt;
	for (;;) {
		if (!(i < s.len)) break;
		int j = 0;
		int ii = i;
		for (;;) {
			if (!(j < p.len && s.str[ii] == p.str[j])) break;
			j++;
			ii++;
		}
		if (j == p.len) {
			return i;
		}
		i++;
	}
	return -1;
}

int string_index_byte(string s, byte c) {
	for (int i = 0; i < s.len; ++i) {
		if (s.str[i] == c) {
			return i;
		}
	}
	return -1;
}

int string_last_index_byte(string s, byte c) {
	for (int i = s.len - 1; i >= 0; i--) {
		if (s.str[i] == c) {
			return i;
		}
	}
	return -1;
}

int string_count(string s, string substr) {
	if (s.len == 0 || substr.len == 0) {
		return 0;
	}
	if (substr.len > s.len) {
		return 0;
	}
	int n = 0;
	int i = 0;
	for (;;) {
		i = string_index_after(s, substr, i);
		if (i == -1) {
			return n;
		}
		i += substr.len;
		n++;
	}
	return 0;
}

bool string_contains(string s, string substr) {
	if (substr.len == 0) {
		return true;
	}
	Option_int _t52 = string_index(s, substr);
	if (!_t52.ok) {
		string err = _t52.v_error;
		int errcode = _t52.ecode;
		return false;
	};
	return true;
}

bool string_contains_any(string s, string chars) {
	for (int _t53 = 0; _t53 < chars.len; ++_t53) {
		byte c = chars.str[_t53];
		if (string_contains(s, byte_str(c))) {
			return true;
		}
	}
	return false;
}

bool string_contains_any_substr(string s, array_string substrs) {
	if (substrs.len == 0) {
		return true;
	}
	// FOR IN array
	array _t54 = substrs;
	for (int _t55 = 0; _t55 < _t54.len; ++_t55) {
		string sub = ((string*)_t54.data)[_t55];
		if (string_contains(s, sub)) {
			return true;
		}
	}
	return false;
}

bool string_starts_with(string s, string p) {
	if (p.len > s.len) {
		return false;
	}
	for (int i = 0; i < p.len; ++i) {
		if (s.str[i] != p.str[i]) {
			return false;
		}
	}
	return true;
}

bool string_ends_with(string s, string p) {
	if (p.len > s.len) {
		return false;
	}
	for (int i = 0; i < p.len; ++i) {
		if (string_at(p, i) != string_at(s, s.len - p.len + i)) {
			return false;
		}
	}
	return true;
}

string string_to_lower(string s) {
	{ // Unsafe block
		byteptr b = v_malloc(s.len + 1);
		for (int i = 0; i < s.len; ++i) {
			b[i] = ((byte)(tolower(s.str[i])));
		}
		return tos(b, s.len);
	}
	return (string){.str=(byteptr)""};
}

bool string_is_lower(string s) {
	for (int i = 0; i < s.len; ++i) {
		if (string_at(s, i) >= 'A' && string_at(s, i) <= 'Z') {
			return false;
		}
	}
	return true;
}

string string_to_upper(string s) {
	{ // Unsafe block
		byteptr b = v_malloc(s.len + 1);
		for (int i = 0; i < s.len; ++i) {
			b[i] = ((byte)(toupper(s.str[i])));
		}
		return tos(b, s.len);
	}
	return (string){.str=(byteptr)""};
}

bool string_is_upper(string s) {
	for (int i = 0; i < s.len; ++i) {
		if (string_at(s, i) >= 'a' && string_at(s, i) <= 'z') {
			return false;
		}
	}
	return true;
}

string string_capitalize(string s) {
	if (s.len == 0) {
		return tos_lit("");
	}
	return string_add(string_to_upper(byte_str(string_at(s, 0))), string_substr(s, 1, s.len));
}

bool string_is_capital(string s) {
	if (s.len == 0 || !(string_at(s, 0) >= 'A' && string_at(s, 0) <= 'Z')) {
		return false;
	}
	for (int i = 1; i < s.len; ++i) {
		if (string_at(s, i) >= 'A' && string_at(s, i) <= 'Z') {
			return false;
		}
	}
	return true;
}

string string_title(string s) {
	array_string words = string_split(s, tos_lit(" "));
	array_string tit = __new_array_with_default(0, 0, sizeof(string), 0);
	// FOR IN array
	array _t56 = words;
	for (int _t57 = 0; _t57 < _t56.len; ++_t57) {
		string word = ((string*)_t56.data)[_t57];
		array_push(&tit, _MOV((string[]){ string_capitalize(word) }));
	}
	string title = array_string_join(tit, tos_lit(" "));
	return title;
}

bool string_is_title(string s) {
	array_string words = string_split(s, tos_lit(" "));
	// FOR IN array
	array _t59 = words;
	for (int _t60 = 0; _t60 < _t59.len; ++_t60) {
		string word = ((string*)_t59.data)[_t60];
		if (!string_is_capital(word)) {
			return false;
		}
	}
	return true;
}

string string_find_between(string s, string start, string end) {
	Option_int _t61 = string_index(s, start);
	if (!_t61.ok) {
		string err = _t61.v_error;
		int errcode = _t61.ecode;
		return tos_lit("");
	}
 	int start_pos = *(int*) _t61.data;
	string val = string_right(s, start_pos + start.len);
	Option_int _t62 = string_index(val, end);
	if (!_t62.ok) {
		string err = _t62.v_error;
		int errcode = _t62.ecode;
		return val;
	}
 	int end_pos = *(int*) _t62.data;
	return string_left(val, end_pos);
}

VV_LOCAL_SYMBOL bool array_string_contains(array_string ar, string val) {
	// FOR IN array
	array _t63 = ar;
	for (int _t64 = 0; _t64 < _t63.len; ++_t64) {
		string s = ((string*)_t63.data)[_t64];
		if (string_eq(s, val)) {
			return true;
		}
	}
	return false;
}

bool byte_is_space(byte c) {
	return (c == ' ' || c == '\n' || c == '\t' || c == '\v' || c == '\f' || c == '\r' || c == 0x85 || c == 0xa0);
}

string string_trim_space(string s) {
	return string_trim(s, tos_lit(" \n\t\v\f\r"));
}

string string_trim(string s, string cutset) {
	if (s.len < 1 || cutset.len < 1) {
		return s;
	}
	array_byte cs_arr = string_bytes(cutset);
	int pos_left = 0;
	int pos_right = s.len - 1;
	bool cs_match = true;
	for (;;) {
		if (!(pos_left <= s.len && pos_right >= -1 && cs_match)) break;
		cs_match = false;
		if (_IN(byte, string_at(s, pos_left), cs_arr)) {
			pos_left++;
			cs_match = true;
		}
		if (_IN(byte, string_at(s, pos_right), cs_arr)) {
			pos_right--;
			cs_match = true;
		}
		if (pos_left > pos_right) {
			return tos_lit("");
		}
	}
	return string_substr(s, pos_left, pos_right + 1);
}

string string_trim_left(string s, string cutset) {
	if (s.len < 1 || cutset.len < 1) {
		return s;
	}
	array_byte cs_arr = string_bytes(cutset);
	int pos = 0;
	for (;;) {
		if (!(pos < s.len && _IN(byte, string_at(s, pos), cs_arr))) break;
		pos++;
	}
	return string_right(s, pos);
}

string string_trim_right(string s, string cutset) {
	if (s.len < 1 || cutset.len < 1) {
		return s;
	}
	array_byte cs_arr = string_bytes(cutset);
	int pos = s.len - 1;
	for (;;) {
		if (!(pos >= 0 && _IN(byte, string_at(s, pos), cs_arr))) break;
		pos--;
	}
	return (pos < 0 ? (tos_lit("")) : (string_left(s, pos + 1)));
}

string string_trim_prefix(string s, string str) {
	if (string_starts_with(s, str)) {
		return string_substr(s, str.len, s.len);
	}
	return s;
}

string string_trim_suffix(string s, string str) {
	if (string_ends_with(s, str)) {
		return string_substr(s, 0, s.len - str.len);
	}
	return s;
}

int compare_strings(string* a, string* b) {
	if (string_lt(/*rec*/*a, *b)) {
		return -1;
	}
	if (string_gt(/*rec*/*a, *b)) {
		return 1;
	}
	return 0;
}

VV_LOCAL_SYMBOL int compare_strings_reverse(string* a, string* b) {
	if (string_lt(/*rec*/*a, *b)) {
		return 1;
	}
	if (string_gt(/*rec*/*a, *b)) {
		return -1;
	}
	return 0;
}

VV_LOCAL_SYMBOL int compare_strings_by_len(string* a, string* b) {
	if (a->len < b->len) {
		return -1;
	}
	if (a->len > b->len) {
		return 1;
	}
	return 0;
}

VV_LOCAL_SYMBOL int compare_lower_strings(string* a, string* b) {
	string aa = string_to_lower(/*rec*/*a);
	string bb = string_to_lower(/*rec*/*b);
	return compare_strings((voidptr)&/*qq*/aa, (voidptr)&/*qq*/bb);
}

void array_string_sort(array_string* s) {
	array_sort_with_compare(s, compare_strings);
}

void array_string_sort_ignore_case(array_string* s) {
	array_sort_with_compare(s, compare_lower_strings);
}

void array_string_sort_by_len(array_string* s) {
	array_sort_with_compare(s, compare_strings_by_len);
}

string string_str(string s) {
	return s;
}

string ustring_str(ustring s) {
	return s.s;
}

ustring string_ustring(string s) {
	ustring res = (ustring){.s = s,.runes = __new_array(0, s.len, ((int)(/*SizeOfType*/ sizeof(int)))),.len = 0,};
	for (int i = 0; i < s.len; i++) {
		int char_len = utf8_char_len(s.str[i]);
		array_push(&res.runes, _MOV((int[]){ i }));
		i += char_len - 1;
		res.len++;
	}
	return res;
}

ustring string_ustring_tmp(string s) {
	if (g_ustring_runes.len == 0) {
		g_ustring_runes = __new_array(0, 128, ((int)(/*SizeOfType*/ sizeof(int))));
	}
	ustring res = (ustring){.s = s,.runes = __new_array(0, 1, sizeof(int)),.len = 0,};
	res.runes = g_ustring_runes;
	res.runes.len = s.len;
	int j = 0;
	for (int i = 0; i < s.len; i++) {
		int char_len = utf8_char_len(s.str[i]);
		(*(int*)/*ee elem_typ */array_get(res.runes, j)) = i;
		j++;
		i += char_len - 1;
		res.len++;
	}
	return res;
}

VV_LOCAL_SYMBOL bool ustring_eq(ustring u, ustring a) {
	if (u.len != a.len || string_ne(u.s, a.s)) {
		return false;
	}
	return true;
}

VV_LOCAL_SYMBOL bool ustring_ne(ustring u, ustring a) {
	return !ustring_eq(u, a);
}

VV_LOCAL_SYMBOL bool ustring_lt(ustring u, ustring a) {
	return string_lt(u.s, a.s);
}

VV_LOCAL_SYMBOL bool ustring_le(ustring u, ustring a) {
	return ustring_lt(u, a) || ustring_eq(u, a);
}

VV_LOCAL_SYMBOL bool ustring_gt(ustring u, ustring a) {
	return !ustring_le(u, a);
}

VV_LOCAL_SYMBOL bool ustring_ge(ustring u, ustring a) {
	return !ustring_lt(u, a);
}

ustring ustring_add(ustring u, ustring a) {
	ustring res = (ustring){.s = string_add(u.s, a.s),.runes = __new_array(0, u.s.len + a.s.len, ((int)(/*SizeOfType*/ sizeof(int)))),.len = 0,};
	int j = 0;
	for (int i = 0; i < u.s.len; i++) {
		int char_len = utf8_char_len(u.s.str[i]);
		array_push(&res.runes, _MOV((int[]){ j }));
		i += char_len - 1;
		j += char_len;
		res.len++;
	}
	for (int i = 0; i < a.s.len; i++) {
		int char_len = utf8_char_len(a.s.str[i]);
		array_push(&res.runes, _MOV((int[]){ j }));
		i += char_len - 1;
		j += char_len;
		res.len++;
	}
	return res;
}

int ustring_index_after(ustring u, ustring p, int start) {
	if (p.len > u.len) {
		return -1;
	}
	int strt = start;
	if (start < 0) {
		strt = 0;
	}
	if (start > u.len) {
		return -1;
	}
	int i = strt;
	for (;;) {
		if (!(i < u.len)) break;
		int j = 0;
		int ii = i;
		for (;;) {
			if (!(j < p.len && string_eq(ustring_at(u, ii), ustring_at(p, j)))) break;
			j++;
			ii++;
		}
		if (j == p.len) {
			return i;
		}
		i++;
	}
	return -1;
}

int ustring_count(ustring u, ustring substr) {
	if (u.len == 0 || substr.len == 0) {
		return 0;
	}
	if (substr.len > u.len) {
		return 0;
	}
	int n = 0;
	int i = 0;
	for (;;) {
		i = ustring_index_after(u, substr, i);
		if (i == -1) {
			return n;
		}
		i += substr.len;
		n++;
	}
	return 0;
}

string ustring_substr(ustring u, int _start, int _end) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (_start > _end || _start > u.len || _end > u.len || _start < 0 || _end < 0) {
			v_panic(_STR("substr(%"PRId32"\000, %"PRId32"\000) out of bounds (len=%"PRId32"\000)", 4, _start, _end, u.len));
		}
	}
	#endif
	int end = (_end >= u.len ? (u.s.len) : ((*(int*)/*ee elem_typ */array_get(u.runes, _end))));
	return string_substr(u.s, (*(int*)/*ee elem_typ */array_get(u.runes, _start)), end);
}

string ustring_left(ustring u, int pos) {
	if (pos >= u.len) {
		return u.s;
	}
	return ustring_substr(u, 0, pos);
}

string ustring_right(ustring u, int pos) {
	if (pos >= u.len) {
		return tos_lit("");
	}
	return ustring_substr(u, pos, u.len);
}

VV_LOCAL_SYMBOL byte string_at(string s, int idx) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (idx < 0 || idx >= s.len) {
			v_panic(_STR("string index out of range: %"PRId32"\000 / %"PRId32"", 2, idx, s.len));
		}
	}
	#endif
	{ // Unsafe block
		return s.str[idx];
	}
	return 0;
}

string ustring_at(ustring u, int idx) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (idx < 0 || idx >= u.len) {
			v_panic(_STR("string index out of range: %"PRId32"\000 / %"PRId32"", 2, idx, u.runes.len));
		}
	}
	#endif
	return ustring_substr(u, idx, idx + 1);
}

// Attr: [unsafe]
VV_LOCAL_SYMBOL void ustring_free(ustring* u) {
	#if defined(_VPREALLOC)
	{
	}
	#endif
	{ // Unsafe block
		array_free(&u->runes);
		string_free(&u->s);
	}
}

bool byte_is_digit(byte c) {
	return c >= '0' && c <= '9';
}

bool byte_is_hex_digit(byte c) {
	return byte_is_digit(c) || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
}

bool byte_is_oct_digit(byte c) {
	return c >= '0' && c <= '7';
}

bool byte_is_bin_digit(byte c) {
	return c == '0' || c == '1';
}

bool byte_is_letter(byte c) {
	return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
}

void string_free(string* s) {
	#if defined(_VPREALLOC)
	{
	}
	#endif
	if (s->is_lit == -98761234) {
		printf("double string.free() detected\n");
		return;
	}
	if (s->is_lit == 1 || s->len == 0) {
		return;
	}
	v_free(s->str);
	s->is_lit = -98761234;
}

string string_all_before(string s, string dot) {
	Option_int _t68 = string_index(s, dot);
	if (!_t68.ok) {
		string err = _t68.v_error;
		int errcode = _t68.ecode;
		return s;
	}
 	int pos = *(int*) _t68.data;
	return string_left(s, pos);
}

string string_all_before_last(string s, string dot) {
	Option_int _t69 = string_last_index(s, dot);
	if (!_t69.ok) {
		string err = _t69.v_error;
		int errcode = _t69.ecode;
		return s;
	}
 	int pos = *(int*) _t69.data;
	return string_left(s, pos);
}

string string_all_after(string s, string dot) {
	Option_int _t70 = string_index(s, dot);
	if (!_t70.ok) {
		string err = _t70.v_error;
		int errcode = _t70.ecode;
		return s;
	}
 	int pos = *(int*) _t70.data;
	return string_right(s, pos + dot.len);
}

string string_all_after_last(string s, string dot) {
	Option_int _t71 = string_last_index(s, dot);
	if (!_t71.ok) {
		string err = _t71.v_error;
		int errcode = _t71.ecode;
		return s;
	}
 	int pos = *(int*) _t71.data;
	return string_right(s, pos + dot.len);
}

string string_after(string s, string dot) {
	return string_all_after_last(s, dot);
}

string string_after_char(string s, byte dot) {
	int pos = 0;
	for (int i = 0; i < s.len; ++i) {
		byte c = s.str[i];
		if (c == dot) {
			pos = i;
			break;
		}
	}
	if (pos == 0) {
		return s;
	}
	return string_right(s, pos + 1);
}

string array_string_join(array_string a, string del) {
	if (a.len == 0) {
		return tos_lit("");
	}
	int len = 0;
	// FOR IN array
	array _t72 = a;
	for (int _t73 = 0; _t73 < _t72.len; ++_t73) {
		string val = ((string*)_t72.data)[_t73];
		len += val.len + del.len;
	}
	len -= del.len;
	string res = tos_lit("");
	res.len = len;
	res.str = v_malloc(res.len + 1);
	int idx = 0;
	// FOR IN array
	array _t74 = a;
	for (int i = 0; i < _t74.len; ++i) {
		string val = ((string*)_t74.data)[i];
		for (int j = 0; j < val.len; ++j) {
			{ // Unsafe block
				res.str[idx] = val.str[j];
			}
			idx++;
		}
		if (i != a.len - 1) {
			for (int k = 0; k < del.len; ++k) {
				{ // Unsafe block
					res.str[idx] = del.str[k];
				}
				idx++;
			}
		}
	}
	{ // Unsafe block
		res.str[res.len] = '\0';
	}
	return res;
}

string array_string_join_lines(array_string s) {
	return array_string_join(s, tos_lit("\n"));
}

string string_reverse(string s) {
	if (s.len == 0 || s.len == 1) {
		return s;
	}
	string res = (string){.str = v_malloc(s.len), .len = s.len};
	for (int i = s.len - 1; i >= 0; i--) {
		{ // Unsafe block
			res.str[s.len - i - 1] = string_at(s, i);
		}
	}
	return res;
}

string string_limit(string s, int max) {
	ustring u = string_ustring(s);
	if (u.len <= max) {
		return s;
	}
	return ustring_substr(u, 0, max);
}

// Attr: [deprecated]
bool byte_is_white(byte c) {
	eprintln(tos_lit("warning: `string.is_white` has been deprecated, use `string.is_space` instead"));
	return byte_is_space(c);
}

int string_hash(string s) {
	u32 h = ((u32)(0U));
	if (h == 0 && s.len > 0) {
		for (int _t75 = 0; _t75 < s.len; ++_t75) {
			byte c = s.str[_t75];
			h = h * 31 + ((u32)(c));
		}
	}
	return ((int)(h));
}

array_byte string_bytes(string s) {
	if (s.len == 0) {
		return __new_array_with_default(0, 0, sizeof(byte), 0);
	}
	array_byte buf = __new_array_with_default(s.len, 0, sizeof(byte), 0);
	memcpy(buf.data, s.str, s.len);
	return buf;
}

string string_repeat(string s, int count) {
	if (count < 0) {
		v_panic(_STR("string.repeat: count is negative: %"PRId32"", 1, count));
	} else if (count == 0) {
		return tos_lit("");
	} else if (count == 1) {
		return s;
	}
	byteptr ret = v_malloc(s.len * count + 1);
	for (int i = 0; i < count; ++i) {
		for (int j = 0; j < s.len; ++j) {
			{ // Unsafe block
				ret[i * s.len + j] = string_at(s, j);
			}
		}
	}
	{ // Unsafe block
		int new_len = s.len * count;
		ret[new_len] = 0;
		return byteptr_vstring_with_len(ret, new_len);
	}
	return (string){.str=(byteptr)""};
}

array_string string_fields(string s) {
	return string_split(string_replace(s, tos_lit("\t"), tos_lit(" ")), tos_lit(" "));
}

string string_strip_margin(string s) {
	return string_strip_margin_custom(s, '|');
}

string string_strip_margin_custom(string s, byte del) {
	byte sep = del;
	if (byte_is_space(sep)) {
		eprintln(tos_lit("Warning: `strip_margin` cannot use white-space as a delimiter"));
		eprintln(tos_lit("    Defaulting to `|`"));
		sep = '|';
	}
	byteptr ret = v_malloc(s.len + 1);
	int count = 0;
	for (int i = 0; i < s.len; i++) {
		if ((string_at(s, i) == '\n' || string_at(s, i) == '\r')) {
			{ // Unsafe block
				ret[count] = string_at(s, i);
			}
			count++;
			if (string_at(s, i) == '\r' && i < s.len - 1 && string_at(s, i + 1) == '\n') {
				{ // Unsafe block
					ret[count] = string_at(s, i + 1);
				}
				count++;
				i++;
			}
			for (;;) {
				if (!(string_at(s, i) != sep)) break;
				i++;
				if (i >= s.len) {
					break;
				}
			}
		} else {
			{ // Unsafe block
				ret[count] = string_at(s, i);
			}
			count++;
		}
	}
	{ // Unsafe block
		ret[count] = 0;
		return byteptr_vstring_with_len(ret, count);
	}
	return (string){.str=(byteptr)""};
}

int utf8_char_len(byte b) {
	return (((0xe5000000 >> (((b >> 3) & 0x1e))) & 3)) + 1;
}

string utf32_to_str(u32 code) {
	byteptr buffer = v_malloc(5);
	return utf32_to_str_no_malloc(code, buffer);
}

string utf32_to_str_no_malloc(u32 code, voidptr buf) {
	int icode = ((int)(code));
	string res = tos_lit("");
	{ // Unsafe block
		byteptr buffer = ((byteptr)(buf));
		if (icode <= 127) {
			buffer[0] = ((byte)(icode));
			res = tos(buffer, 1);
		} else if (icode <= 2047) {
			buffer[0] = (192 | ((byte)(icode >> 6)));
			buffer[1] = (128 | ((byte)((icode & 63))));
			res = tos(buffer, 2);
		} else if (icode <= 65535) {
			buffer[0] = (224 | ((byte)(icode >> 12)));
			buffer[1] = (128 | ((((byte)(icode >> 6)) & 63)));
			buffer[2] = (128 | ((byte)((icode & 63))));
			res = tos(buffer, 3);
		} else if (icode <= 1114111) {
			buffer[0] = (240 | ((byte)(icode >> 18)));
			buffer[1] = (128 | ((((byte)(icode >> 12)) & 63)));
			buffer[2] = (128 | ((((byte)(icode >> 6)) & 63)));
			buffer[3] = (128 | ((byte)((icode & 63))));
			res = tos(buffer, 4);
		}
	}
	res.is_lit = 1;
	return res;
}

int string_utf32_code(string _rune) {
	if (_rune.len == 0) {
		return 0;
	}
	if (_rune.len == 1) {
		return ((int)(string_at(_rune, 0)));
	}
	byte b = ((byte)(((int)(string_at(_rune, 0)))));
	b = b << _rune.len;
	int res = ((int)(b));
	int shift = 6 - _rune.len;
	for (int i = 1; i < _rune.len; i++) {
		int c = ((int)(string_at(_rune, i)));
		res = res << shift;
		res |= (c & 63);
		shift = 6;
	}
	return res;
}

u16* string_to_wide(string _str) {
	#if defined(_WIN32)
	{
		int num_chars = (MultiByteToWideChar(_const_cp_utf8, 0, ((charptr)(_str.str)), _str.len, 0, 0));
		u16* wstr = ((u16*)(v_malloc((num_chars + 1) * 2)));
		if (wstr != 0) {
			MultiByteToWideChar(_const_cp_utf8, 0, ((charptr)(_str.str)), _str.len, wstr, num_chars);
			memset(((byte*)(wstr)) + num_chars * 2, 0, 2);
		}
		return wstr;
	}
	#else
	{
	}
	#endif
	return 0;
}

string string_from_wide(u16* _wstr) {
	#if defined(_WIN32)
	{
		int wstr_len = wcslen(_wstr);
		return string_from_wide2(_wstr, wstr_len);
	}
	#else
	{
	}
	#endif
	return (string){.str=(byteptr)""};
}

string string_from_wide2(u16* _wstr, int len) {
	#if defined(_WIN32)
	{
		int num_chars = WideCharToMultiByte(_const_cp_utf8, 0, _wstr, len, 0, 0, 0, 0);
		byteptr str_to = v_malloc(num_chars + 1);
		if (str_to != 0) {
			WideCharToMultiByte(_const_cp_utf8, 0, _wstr, len, ((charptr)(str_to)), num_chars, 0, 0);
			memset(str_to + num_chars, 0, 1);
		}
		return tos2(str_to);
	}
	#else
	{
	}
	#endif
	return (string){.str=(byteptr)""};
}

VV_LOCAL_SYMBOL int utf8_len(byte c) {
	int b = 0;
	byte x = c;
	if (((x & 240)) != 0) {
		x >>= 4;
	} else {
		b += 4;
	}
	if (((x & 12)) != 0) {
		x >>= 2;
	} else {
		b += 2;
	}
	if (((x & 2)) == 0) {
		b++;
	}
	return b;
}

VV_LOCAL_SYMBOL int utf8_str_len(string s) {
	int l = 0;
	for (int i = 0; i < s.len; i++) {
		l++;
		byte c = s.str[i];
		if (((c & (1 << 7))) != 0) {
			for (byte t = ((byte)(1 << 6)); ((c & t)) != 0; t >>= 1) {
				i++;
			}
		}
	}
	return l;
}

VV_LOCAL_SYMBOL int utf8_str_visible_length(string s) {
	int l = 0;
	int ul = 1;
	for (int i = 0; i < s.len; i += ul) {
		ul = 1;
		byte c = s.str[i];
		if (((c & (1 << 7))) != 0) {
			for (byte t = ((byte)(1 << 6)); ((c & t)) != 0; t >>= 1) {
				ul++;
			}
		}
		if (i + ul > s.len) {
			return l;
		}
		l++;
		if (c == 0xcc || c == 0xcd) {
			u16 r = ((((u16)(c)) << 8) | s.str[i + 1]);
			if (r >= 0xcc80 && r < 0xcdb0) {
				l--;
			}
		} else if (c == 0xe1 || c == 0xe2 || c == 0xef) {
			u32 r = ((((u32)(c)) << 16) | ((((u32)(s.str[i + 1])) << 8) | s.str[i + 2]));
			if ((r >= 0xe1aab0 && r < 0xe1ac80) || (r >= 0xe1b780 && r < 0xe1b880) || (r >= 0xe28390 && r < 0xe28480) || (r >= 0xefb8a0 && r < 0xefb8b0)) {
				l--;
			}
		}
	}
	return l;
}

int utf8_getchar() {
	int c = getchar();
	int len = utf8_len(((byte)(~c)));
	if (c < 0) {
		return 0;
	} else if (len == 0) {
		return c;
	} else if (len == 1) {
		return -1;
	} else {
		int uc = (c & ((1 << (7 - len)) - 1));
		for (int i = 0; i + 1 < len; i++) {
			int c2 = getchar();
			if (c2 != -1 && (c2 >> 6) == 2) {
				uc <<= 6;
				uc |= ((c2 & 63));
			} else if (c2 == -1) {
				return 0;
			} else {
				return -1;
			}
		}
		return uc;
	}
	return 0;
}

string os__getenv(string key) {
	#if defined(_WIN32)
	{
		voidptr s = _wgetenv(string_to_wide(key));
		if (s == 0) {
			return tos_lit("");
		}
		return string_from_wide(s);
	}
	#else
	{
	}
	#endif
	return (string){.str=(byteptr)""};
}

int os__setenv(string name, string value, bool overwrite) {
	#if defined(_WIN32)
	{
		string format = _STR("%.*s\000=%.*s", 2, name, value);
		if (overwrite) {
			{ // Unsafe block
				return _putenv(format.str);
			}
		} else {
			if (os__getenv(name).len == 0) {
				{ // Unsafe block
					return _putenv(format.str);
				}
			}
		}
		return -1;
	}
	#else
	{
	}
	#endif
	return 0;
}

int os__unsetenv(string name) {
	#if defined(_WIN32)
	{
		string format = _STR("%.*s\000=", 2, name);
		return _putenv(format.str);
	}
	#else
	{
	}
	#endif
	return 0;
}

map_string_string os__environ() {
	map_string_string res = new_map_1(sizeof(string));
	#if defined(_WIN32)
	{
		u16* estrings = GetEnvironmentStringsW();
		string eline = tos_lit("");
		for (u16* c = estrings; *c != 0; ) {
			eline = string_from_wide(c);
			int eq_index = string_index_byte(eline, '=');
			if (eq_index > 0) {
				map_set(&res, string_substr(eline, 0, eq_index), &(string[]) { string_substr(eline, eq_index + 1, eline.len) });
			}
			{ // Unsafe block
				c = c + eline.len + 1;
			}
		}
		FreeEnvironmentStringsW(estrings);
	}
	#else
	{
	}
	#endif
	return res;
}

int os__fd_close(int fd) {
	return close(fd);
}

void os__fd_write(int fd, string s) {
	byteptr sp = s.str;
	int remaining = s.len;
	for (;;) {
		if (!(remaining > 0)) break;
		int written = write(fd, sp, remaining);
		if (written < 0) {
			return;
		}
		remaining = remaining - written;
		sp = sp + written;
	}
}

array_string os__fd_slurp(int fd) {
	array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	for (;;) {
		multi_return_string_int mr_413 = os__fd_read(fd, 4096);
		string s = mr_413.arg0;
		int b = mr_413.arg1;
		if (b <= 0) {
			break;
		}
		array_push(&res, _MOV((string[]){ s }));
	}
	return res;
}

multi_return_string_int os__fd_read(int fd, int maxbytes) {
	byteptr buf = v_malloc(maxbytes);
	int nbytes = read(fd, buf, maxbytes);
	if (nbytes < 0) {
		v_free(buf);
		return (multi_return_string_int){.arg0=tos_lit(""), .arg1=nbytes};
	}
	{ // Unsafe block
		buf[nbytes] = 0;
	}
	return (multi_return_string_int){.arg0=tos(buf, nbytes), .arg1=nbytes};
}

// Attr: [deprecated]
bool os__File_is_opened(os__File f) {
	eprintln(tos_lit("warning: `File.is_opened()` has been deprecated, use `File.is_opened` instead"));
	return f.is_opened;
}

Option_int os__File_write(os__File* f, array_byte buf) {
	if (!f->is_opened) {
		Option _t77 = v_error(tos_lit("file is not opened"));
		return *(Option_int*)&_t77;
	}
	int written = fwrite(buf.data, buf.len, 1, f->cfile);
	if (written == 0 && buf.len != 0) {
		Option _t78 = v_error(tos_lit("0 bytes written"));
		return *(Option_int*)&_t78;
	}
	Option_int _t79;
	opt_ok2(&(int[]) { written }, (OptionBase*)(&_t79), sizeof(int));
	return _t79;
}

Option_int os__File_writeln(os__File* f, string s) {
	if (!f->is_opened) {
		Option _t80 = v_error(tos_lit("file is not opened"));
		return *(Option_int*)&_t80;
	}
	int written = fwrite(s.str, s.len, 1, f->cfile);
	if (written == 0 && s.len != 0) {
		Option _t81 = v_error(tos_lit("0 bytes written"));
		return *(Option_int*)&_t81;
	}
	int x = fputs("\n", f->cfile);
	if (x < 0) {
		Option _t82 = v_error(tos_lit("could not add newline"));
		return *(Option_int*)&_t82;
	}
	Option_int _t83;
	opt_ok2(&(int[]) { (written + 1) }, (OptionBase*)(&_t83), sizeof(int));
	return _t83;
}

Option_int os__File_write_to(os__File* f, int pos, array_byte buf) {
	fseek(f->cfile, pos, SEEK_SET);
	int res = fwrite(buf.data, 1, buf.len, f->cfile);
	fseek(f->cfile, 0, SEEK_END);
	Option_int _t84;
	opt_ok2(&(int[]) { res }, (OptionBase*)(&_t84), sizeof(int));
	return _t84;
}

// Attr: [deprecated]
int os__File_write_bytes(os__File* f, voidptr data, int size) {
	eprintln(tos_lit("warning `File.write_bytes()` has been deprecated, use `File.write` instead"));
	return fwrite(data, 1, size, f->cfile);
}

// Attr: [deprecated]
int os__File_write_bytes_at(os__File* f, voidptr data, int size, int pos) {
	eprintln(tos_lit("warning `File.write_bytes_at()` has been deprecated, use `File.write_at` instead"));
	fseek(f->cfile, pos, SEEK_SET);
	int res = fwrite(data, 1, size, f->cfile);
	fseek(f->cfile, 0, SEEK_END);
	return res;
}

// Attr: [deprecated]
array_byte os__File_read_bytes(os__File* f, int size) {
	eprintln(tos_lit("warning `File.read_bytes()` has been deprecated, use `File.read` instead"));
	return os__File_read_bytes_at(f, size, 0);
}

// Attr: [deprecated]
array_byte os__File_read_bytes_at(os__File* f, int size, int pos) {
	eprintln(tos_lit("warning `File.read_bytes_at()` has been deprecated, use `File.read_at` instead"));
	array_byte arr = __new_array_with_default(size, 0, sizeof(byte), 0);
	Option_int _t85 = os__File_read_bytes_into(f, pos, &/*arr*/arr);
	if (!_t85.ok) {
		string err = _t85.v_error;
		int errcode = _t85.ecode;
		return __new_array_with_default(0, 0, sizeof(byte), 0);
	}
 	int nreadbytes = *(int*) _t85.data;
	return array_slice(arr, 0, nreadbytes);
}

// Attr: [deprecated]
Option_int os__File_read_bytes_into(os__File* f, int pos, array_byte* buf) {
	eprintln(tos_lit("warning `File.read_bytes_into()` has been deprecated, use `File.read_from_into` instead"));
	if (buf->len == 0) {
		v_panic(string_add(tos_lit("read_bytes_into"), tos_lit(": `buf.len` == 0")));
	}
	fseek(f->cfile, pos, SEEK_SET);
	errno = 0;
	int nbytes = fread(buf->data, 1, buf->len, f->cfile);
	if (errno != 0) {
		Option _t86 = v_error(os__posix_get_error_msg(errno));
		return *(Option_int*)&_t86;
	}
	#if defined(_VDEBUG)
	{
	}
	#endif
	Option_int _t87;
	opt_ok2(&(int[]) { nbytes }, (OptionBase*)(&_t87), sizeof(int));
	return _t87;
}

Option_int os__File_read(os__File* f, array_byte* buf) {
	if (buf->len == 0) {
		Option_int _t88;
		opt_ok2(&(int[]) { 0 }, (OptionBase*)(&_t88), sizeof(int));
		return _t88;
	}
	errno = 0;
	int nbytes = fread(buf->data, 1, buf->len, f->cfile);
	if (errno != 0) {
		Option _t89 = v_error(os__posix_get_error_msg(errno));
		return *(Option_int*)&_t89;
	}
	Option_int _t90;
	opt_ok2(&(int[]) { nbytes }, (OptionBase*)(&_t90), sizeof(int));
	return _t90;
}

Option_int os__File_read_at(os__File* f, int pos, array_byte* buf) {
	if (buf->len == 0) {
		Option_int _t91;
		opt_ok2(&(int[]) { 0 }, (OptionBase*)(&_t91), sizeof(int));
		return _t91;
	}
	fseek(f->cfile, pos, SEEK_SET);
	errno = 0;
	int nbytes = fread(buf->data, 1, buf->len, f->cfile);
	if (errno != 0) {
		Option _t92 = v_error(os__posix_get_error_msg(errno));
		return *(Option_int*)&_t92;
	}
	Option_int _t93;
	opt_ok2(&(int[]) { nbytes }, (OptionBase*)(&_t93), sizeof(int));
	return _t93;
}

void os__File_flush(os__File* f) {
	if (!f->is_opened) {
		return;
	}
	fflush(f->cfile);
}

os__File os__open_stdin() {
	return (os__File){.cfile = stdin,.fd = 0,.is_opened = true,};
}

// Attr: [deprecated]
Option_string os__File_get_line(os__File* f) {
	eprintln(tos_lit("File.get_line() is deprecated... Use a BufferedReader instead"));
	if (!f->is_opened) {
		Option _t94 = v_error(tos_lit("file is closed"));
		return *(Option_string*)&_t94;
	}
	Option _t95 = v_error(tos_lit("use io.new_buffered_reader"));
	return *(Option_string*)&_t95;
}

Option_void os__File_write_str(os__File* f, string s) {
	if (!f->is_opened) {
		Option _t96 = v_error(tos_lit("file is closed"));
		return *(Option_void*)&_t96;
	}
	Option_int _t97 = os__File_write(f, string_bytes(s));
	if (!_t97.ok) {
		return *(Option_void *)&_t97;
	};
	Option_void _t98 = {.ok = true};
	return _t98;
}

os__FileMode os__inode(string path) {
	struct stat attr;
	stat(((charptr)(path.str)), &attr);
	os__FileType typ = os__FileType_regular;
	if ((attr.st_mode & ((u32)(S_IFMT))) == ((u32)(S_IFDIR))) {
		typ = os__FileType_directory;
	}
	#if !defined(_WIN32)
	{
	}
	#endif
	#if defined(_WIN32)
	{
		return (os__FileMode){.typ = typ,.owner = (os__FilePermission){.read = ((attr.st_mode & ((u32)(S_IREAD)))) != 0,.write = ((attr.st_mode & ((u32)(S_IWRITE)))) != 0,.execute = ((attr.st_mode & ((u32)(S_IEXEC)))) != 0,},.group = (os__FilePermission){.read = ((attr.st_mode & ((u32)(S_IREAD)))) != 0,.write = ((attr.st_mode & ((u32)(S_IWRITE)))) != 0,.execute = ((attr.st_mode & ((u32)(S_IEXEC)))) != 0,},.others = (os__FilePermission){.read = ((attr.st_mode & ((u32)(S_IREAD)))) != 0,.write = ((attr.st_mode & ((u32)(S_IWRITE)))) != 0,.execute = ((attr.st_mode & ((u32)(S_IEXEC)))) != 0,},};
	}
	#else
	{
	}
	#endif
	return (os__FileMode){0};
}

Option_array_byte os__read_bytes(string path) {
	Option_FILE_ptr _t99 = os__vfopen(path, tos_lit("rb"));
	if (!_t99.ok) {
		return *(Option_array_byte *)&_t99;
	}
 	FILE* fp = *(FILE**) _t99.data;
	int cseek = fseek(fp, 0, SEEK_END);
	if (cseek != 0) {
		Option _t100 = v_error(tos_lit("fseek failed"));
		return *(Option_array_byte*)&_t100;
	}
	int fsize = ftell(fp);
	if (fsize < 0) {
		Option _t101 = v_error(tos_lit("ftell failed"));
		return *(Option_array_byte*)&_t101;
	}
	rewind(fp);
	array_byte res = __new_array_with_default(fsize, 0, sizeof(byte), 0);
	int nr_read_elements = fread(res.data, fsize, 1, fp);
	if (nr_read_elements == 0 && fsize > 0) {
		Option _t102 = v_error(tos_lit("fread failed"));
		return *(Option_array_byte*)&_t102;
	}
	fclose(fp);
	Option_array_byte _t103;
	opt_ok2(&(array_byte[]) { array_slice(res, 0, nr_read_elements * fsize) }, (OptionBase*)(&_t103), sizeof(array_byte));
	return _t103;
}

Option_string os__read_file(string path) {
	string mode = tos_lit("rb");
	Option_FILE_ptr _t104 = os__vfopen(path, mode);
	if (!_t104.ok) {
		return *(Option_string *)&_t104;
	}
 	FILE* fp = *(FILE**) _t104.data;
	int cseek = fseek(fp, 0, SEEK_END);
	if (cseek != 0) {
		// Defer begin
		fclose(fp);
		// Defer end
		Option _t105 = v_error(tos_lit("fseek failed"));
		return *(Option_string*)&_t105;
	}
	int fsize = ftell(fp);
	if (fsize < 0) {
		// Defer begin
		fclose(fp);
		// Defer end
		Option _t106 = v_error(tos_lit("ftell failed"));
		return *(Option_string*)&_t106;
	}
	rewind(fp);
	{ // Unsafe block
		byteptr str = v_malloc(fsize + 1);
		int nelements = fread(str, fsize, 1, fp);
		if (nelements == 0 && fsize > 0) {
			v_free(str);
			// Defer begin
			fclose(fp);
			// Defer end
			Option _t107 = v_error(tos_lit("fread failed"));
			return *(Option_string*)&_t107;
		}
		str[fsize] = 0;
		// Defer begin
		fclose(fp);
		// Defer end
		Option_string _t108;
		opt_ok2(&(string[]) { byteptr_vstring_with_len(str, fsize) }, (OptionBase*)(&_t108), sizeof(string));
		return _t108;
	}
	// Defer begin
	fclose(fp);
	// Defer end
	Option _t109 = opt_none();
	return *(Option_string*)&_t109;
}

int os__file_size(string path) {
	struct stat s;
	{ // Unsafe block
		#if defined(_WIN32)
		{
			#if defined(__TINYC__)
			{
			}
			#else
			{
				_wstat(string_to_wide(path), ((voidptr)(&s)));
			}
			#endif
		}
		#else
		{
		}
		#endif
	}
	return s.st_size;
}

void os__mv(string src, string dst) {
	string rdst = dst;
	if (os__is_dir(rdst)) {
		rdst = os__join_path(string_trim_right(rdst, _const_os__path_separator), (varg_string){.len=1,.args={os__file_name(string_trim_right(src, _const_os__path_separator))}});
	}
	#if defined(_WIN32)
	{
		string w_src = string_replace(src, tos_lit("/"), tos_lit("\\"));
		string w_dst = string_replace(rdst, tos_lit("/"), tos_lit("\\"));
		_wrename(string_to_wide(w_src), string_to_wide(w_dst));
	}
	#else
	{
	}
	#endif
}

Option_void os__cp(string src, string dst) {
	#if defined(_WIN32)
	{
		string w_src = string_replace(src, tos_lit("/"), tos_lit("\\"));
		string w_dst = string_replace(dst, tos_lit("/"), tos_lit("\\"));
		if (CopyFile(string_to_wide(w_src), string_to_wide(w_dst), false) == 0) {
			u32 result = GetLastError();
			Option _t110 = error_with_code(_STR("failed to copy %.*s\000 to %.*s", 2, src, dst), ((int)(result)));
			return *(Option_void*)&_t110;
		}
	}
	#else
	{
	}
	#endif
	Option_void _t111 = {.ok = true};
	return _t111;
}

// Attr: [deprecated]
Option_void os__cp_r(string osource_path, string odest_path, bool overwrite) {
	eprintln(tos_lit("warning: `os.cp_r` has been deprecated, use `os.cp_all` instead"));
	return os__cp_all(osource_path, odest_path, overwrite);
}

Option_void os__cp_all(string src, string dst, bool overwrite) {
	string source_path = os__real_path(src);
	string dest_path = os__real_path(dst);
	if (!os__exists(source_path)) {
		Option _t112 = v_error(tos_lit("Source path doesn\'t exist"));
		return *(Option_void*)&_t112;
	}
	if (!os__is_dir(source_path)) {
		string adjusted_path = (os__is_dir(dest_path) ? (os__join_path(dest_path, (varg_string){.len=1,.args={os__file_name(source_path)}})) : (dest_path));
		if (os__exists(adjusted_path)) {
			if (overwrite) {
				os__rm(adjusted_path);
			} else {
				Option _t113 = v_error(tos_lit("Destination file path already exist"));
				return *(Option_void*)&_t113;
			}
		}
		Option_void _t114 = os__cp(source_path, adjusted_path);
		if (!_t114.ok && !_t114.is_none) {
			return *(Option_void *)&_t114;
		};
		Option_void _t115 = {.ok = true};
		return _t115;
	}
	if (!os__is_dir(dest_path)) {
		Option _t116 = v_error(tos_lit("Destination path is not a valid directory"));
		return *(Option_void*)&_t116;
	}
	Option_array_string _t117 = os__ls(source_path);
	if (!_t117.ok) {
		return *(Option_void *)&_t117;
	}
 	array_string files = *(array_string*) _t117.data;
	// FOR IN array
	array _t118 = files;
	for (int _t119 = 0; _t119 < _t118.len; ++_t119) {
		string file = ((string*)_t118.data)[_t119];
		string sp = os__join_path(source_path, (varg_string){.len=1,.args={file}});
		string dp = os__join_path(dest_path, (varg_string){.len=1,.args={file}});
		if (os__is_dir(sp)) {
			Option_bool _t120 = os__mkdir(dp);
			if (!_t120.ok) {
				return *(Option_void *)&_t120;
			};
		}
		Option_void _t121 = os__cp_all(sp, dp, overwrite);
		if (!_t121.ok && !_t121.is_none) {
			string err = _t121.v_error;
			int errcode = _t121.ecode;
			os__rmdir(dp);
			Option _t122 = v_error(err);
			return *(Option_void*)&_t122;
		};
	}
	Option_void _t123 = {.ok = true};
	return _t123;
}

Option_void os__mv_by_cp(string source, string target) {
	Option_void _t124 = os__cp(source, target);
	if (!_t124.ok && !_t124.is_none) {
		return *(Option_void *)&_t124;
	};
	Option_void _t125 = os__rm(source);
	if (!_t125.ok && !_t125.is_none) {
		return *(Option_void *)&_t125;
	};
	Option_void _t126 = {.ok = true};
	return _t126;
}

Option_FILE_ptr os__vfopen(string path, string mode) {
	if (path.len == 0) {
		Option _t127 = v_error(tos_lit("vfopen called with \"\""));
		return *(Option_FILE_ptr*)&_t127;
	}
	voidptr fp = ((voidptr)(0));
	#if defined(_WIN32)
	{
		fp = _wfopen(string_to_wide(path), string_to_wide(mode));
	}
	#else
	{
	}
	#endif
	if (isnil(fp)) {
		Option _t128 = v_error(_STR("failed to open file \"%.*s\000\"", 2, path));
		return *(Option_FILE_ptr*)&_t128;
	} else {
		Option_FILE_ptr _t129;
		opt_ok2(&(FILE*[]) { fp }, (OptionBase*)(&_t129), sizeof(FILE*));
		return _t129;
	}
	Option _t130 = opt_none();
	return *(Option_FILE_ptr*)&_t130;
}

int os__fileno(voidptr cfile) {
	#if defined(_WIN32)
	{
		return _fileno(cfile);
	}
	#else
	{
	}
	#endif
	return 0;
}

Option_array_string os__read_lines(string path) {
	Option_string _t131 = os__read_file(path);
	if (!_t131.ok) {
		return *(Option_array_string *)&_t131;
	}
 	string buf = *(string*) _t131.data;
	Option_array_string _t132;
	opt_ok2(&(array_string[]) { string_split_into_lines(buf) }, (OptionBase*)(&_t132), sizeof(array_string));
	return _t132;
}

VV_LOCAL_SYMBOL Option_array_ustring os__read_ulines(string path) {
	Option_array_string _t133 = os__read_lines(path);
	if (!_t133.ok) {
		return *(Option_array_ustring *)&_t133;
	}
 	array_string lines = *(array_string*) _t133.data;
	array_ustring ulines = __new_array_with_default(0, 0, sizeof(ustring), 0);
	// FOR IN array
	array _t134 = lines;
	for (int _t135 = 0; _t135 < _t134.len; ++_t135) {
		string myline = ((string*)_t134.data)[_t135];
		array_push(&ulines, _MOV((ustring[]){ string_ustring(myline) }));
	}
	Option_array_ustring _t137;
	opt_ok2(&(array_ustring[]) { ulines }, (OptionBase*)(&_t137), sizeof(array_ustring));
	return _t137;
}

Option_os__File os__open_append(string path) {
	os__File file = (os__File){.cfile = 0,.fd = 0,.is_opened = 0,};
	#if defined(_WIN32)
	{
		u16* wpath = string_to_wide(string_replace(path, tos_lit("/"), tos_lit("\\")));
		string mode = tos_lit("ab");
		file = (os__File){.cfile = _wfopen(wpath, string_to_wide(mode)),.fd = 0,.is_opened = 0,};
	}
	#else
	{
	}
	#endif
	if (isnil(file.cfile)) {
		Option _t138 = v_error(_STR("failed to create(append) file \"%.*s\000\"", 2, path));
		return *(Option_os__File*)&_t138;
	}
	file.is_opened = true;
	Option_os__File _t139;
	opt_ok2(&(os__File[]) { file }, (OptionBase*)(&_t139), sizeof(os__File));
	return _t139;
}

Option_os__File os__open_file(string path, string mode, varg_int options) {
	int flags = 0;
	for (int _t140 = 0; _t140 < mode.len; ++_t140) {
		byte m = mode.str[_t140];
		byte _t141 = m;
		if (_t141 == 'r') {
			flags |= _const_os__o_rdonly;
		} else if (_t141 == 'w') {
			flags |= (_const_os__o_create | _const_os__o_trunc);
		} else if (_t141 == 'b') {
			flags |= _const_os__o_binary;
		} else if (_t141 == 'a') {
			flags |= (_const_os__o_create | _const_os__o_append);
		} else if (_t141 == 's') {
			flags |= _const_os__o_sync;
		} else if (_t141 == 'n') {
			flags |= _const_os__o_nonblock;
		} else if (_t141 == 'c') {
			flags |= _const_os__o_noctty;
		} else if (_t141 == '+') {
			flags |= _const_os__o_rdwr;
		} else {
		};
	}
	int permission = 0666;
	if (options.len > 0) {
		permission = options.args[0];
	}
	#if defined(_WIN32)
	{
		if (permission < 0600) {
			permission = 0x0100;
		} else {
			permission = (0x0100 | 0x0080);
		}
	}
	#endif
	string p = path;
	#if defined(_WIN32)
	{
		p = string_replace(path, tos_lit("/"), tos_lit("\\"));
	}
	#endif
	int fd = open(((charptr)(p.str)), flags, permission);
	if (fd == -1) {
		Option _t142 = v_error(os__posix_get_error_msg(errno));
		return *(Option_os__File*)&_t142;
	}
	voidptr cfile = fdopen(fd, ((charptr)(mode.str)));
	if (isnil(cfile)) {
		Option _t143 = v_error(_STR("Failed to open or create file \"%.*s\000\"", 2, path));
		return *(Option_os__File*)&_t143;
	}
	Option_os__File _t144;
	opt_ok2(&(os__File[]) { (os__File){.cfile = cfile,.fd = fd,.is_opened = true,} }, (OptionBase*)(&_t144), sizeof(os__File));
	return _t144;
}

VV_LOCAL_SYMBOL voidptr os__vpopen(string path) {
	#if defined(_WIN32)
	{
		string mode = tos_lit("rb");
		u16* wpath = string_to_wide(path);
		return _wpopen(wpath, string_to_wide(mode));
	}
	#else
	{
	}
	#endif
	return 0;
}

VV_LOCAL_SYMBOL multi_return_int_bool os__posix_wait4_to_exit_status(int waitret) {
	#if defined(_WIN32)
	{
		return (multi_return_int_bool){.arg0=waitret, .arg1=false};
	}
	#else
	{
	}
	#endif
	return (multi_return_int_bool){0};
}

string os__posix_get_error_msg(int code) {
	charptr ptr_text = strerror(code);
	if (ptr_text == 0) {
		return tos_lit("");
	}
	return tos3(ptr_text);
}

VV_LOCAL_SYMBOL int os__vpclose(voidptr f) {
	#if defined(_WIN32)
	{
		return _pclose(f);
	}
	#else
	{
	}
	#endif
	return 0;
}

int os__system(string cmd) {
	int ret = 0;
	#if defined(_WIN32)
	{
		string wcmd = (cmd.len > 1 && string_at(cmd, 0) == '"' && string_at(cmd, 1) != '"' ? (_STR("\"%.*s\000\"", 2, cmd)) : (cmd));
		{ // Unsafe block
			ret = _wsystem(string_to_wide(wcmd));
		}
	}
	#else
	{
	}
	#endif
	if (ret == -1) {
		os__print_c_errno();
	}
	#if !defined(_WIN32)
	{
	}
	#endif
	return ret;
}

string os__sigint_to_signal_name(int si) {
	int _t145 = si;
	if (_t145 == 1) {
		return tos_lit("SIGHUP");
	} else if (_t145 == 2) {
		return tos_lit("SIGINT");
	} else if (_t145 == 3) {
		return tos_lit("SIGQUIT");
	} else if (_t145 == 4) {
		return tos_lit("SIGILL");
	} else if (_t145 == 6) {
		return tos_lit("SIGABRT");
	} else if (_t145 == 8) {
		return tos_lit("SIGFPE");
	} else if (_t145 == 9) {
		return tos_lit("SIGKILL");
	} else if (_t145 == 11) {
		return tos_lit("SIGSEGV");
	} else if (_t145 == 13) {
		return tos_lit("SIGPIPE");
	} else if (_t145 == 14) {
		return tos_lit("SIGALRM");
	} else if (_t145 == 15) {
		return tos_lit("SIGTERM");
	} else {
	};
	#if defined(__linux__)
	{
	}
	#endif
	return tos_lit("unknown");
}

bool os__exists(string path) {
	#if defined(_WIN32)
	{
		string p = string_replace(path, tos_lit("/"), tos_lit("\\"));
		return _waccess(string_to_wide(p), _const_os__f_ok) != -1;
	}
	#else
	{
	}
	#endif
	return 0;
}

bool os__is_executable(string path) {
	#if defined(_WIN32)
	{
		string p = os__real_path(path);
		return (os__exists(p) && string_ends_with(p, tos_lit(".exe")));
	}
	#endif
	#if defined(__sun)
	{
	}
	#endif
	return access(((charptr)(path.str)), _const_os__x_ok) != -1;
}

bool os__is_writable(string path) {
	#if defined(_WIN32)
	{
		string p = string_replace(path, tos_lit("/"), tos_lit("\\"));
		return _waccess(string_to_wide(p), _const_os__w_ok) != -1;
	}
	#else
	{
	}
	#endif
	return 0;
}

bool os__is_readable(string path) {
	#if defined(_WIN32)
	{
		string p = string_replace(path, tos_lit("/"), tos_lit("\\"));
		return _waccess(string_to_wide(p), _const_os__r_ok) != -1;
	}
	#else
	{
	}
	#endif
	return 0;
}

// Attr: [deprecated]
bool os__file_exists(string _path) {
	eprintln(tos_lit("warning: `os.file_exists` has been deprecated, use `os.exists` instead"));
	return os__exists(_path);
}

Option_void os__rm(string path) {
	#if defined(_WIN32)
	{
		int rc = _wremove(string_to_wide(path));
		if (rc == -1) {
			Option _t146 = v_error(_STR("Failed to remove \"%.*s\000\"", 2, path));
			return *(Option_void*)&_t146;
		}
	}
	#else
	{
	}
	#endif
	Option_void _t147 = {.ok = true};
	return _t147;
}

Option_void os__rmdir(string path) {
	#if defined(_WIN32)
	{
		int rc = RemoveDirectory(string_to_wide(path));
		if (rc == 0) {
			Option _t148 = v_error(_STR("Failed to remove \"%.*s\000\"", 2, path));
			return *(Option_void*)&_t148;
		}
	}
	#else
	{
	}
	#endif
	Option_void _t149 = {.ok = true};
	return _t149;
}

// Attr: [deprecated]
void os__rmdir_recursive(string path) {
	eprintln(tos_lit("warning: `os.rmdir_recursive` has been deprecated, use `os.rmdir_all` instead"));
	os__rmdir_all(path);
}

Option_void os__rmdir_all(string path) {
	string ret_err = tos_lit("");
	Option_array_string _t150 = os__ls(path);
	if (!_t150.ok) {
		return *(Option_void *)&_t150;
	}
 	array_string items = *(array_string*) _t150.data;
	// FOR IN array
	array _t151 = items;
	for (int _t152 = 0; _t152 < _t151.len; ++_t152) {
		string item = ((string*)_t151.data)[_t152];
		if (os__is_dir(os__join_path(path, (varg_string){.len=1,.args={item}}))) {
			os__rmdir_all(os__join_path(path, (varg_string){.len=1,.args={item}}));
		}
		Option_void _t153 = os__rm(os__join_path(path, (varg_string){.len=1,.args={item}}));
		if (!_t153.ok && !_t153.is_none) {
			string err = _t153.v_error;
			int errcode = _t153.ecode;
			ret_err = err;
		};
	}
	Option_void _t154 = os__rmdir(path);
	if (!_t154.ok && !_t154.is_none) {
		string err = _t154.v_error;
		int errcode = _t154.ecode;
		ret_err = err;
	};
	if (ret_err.len > 0) {
		Option _t155 = v_error(ret_err);
		return *(Option_void*)&_t155;
	}
	Option_void _t156 = {.ok = true};
	return _t156;
}

bool os__is_dir_empty(string path) {
	Option_array_string _t157 = os__ls(path);
	if (!_t157.ok) {
		string err = _t157.v_error;
		int errcode = _t157.ecode;
		return true;
	}
 	array_string items = *(array_string*) _t157.data;
	return items.len == 0;
}

VV_LOCAL_SYMBOL void os__print_c_errno() {
	int e = errno;
	string se = tos_clone(((byteptr)(strerror(errno))));
	println(_STR("errno=%"PRId32"\000 err=%.*s", 2, e, se));
}

string os__file_ext(string path) {
	Option_int _t158 = string_last_index(path, tos_lit("."));
	if (!_t158.ok) {
		string err = _t158.v_error;
		int errcode = _t158.ecode;
		return tos_lit("");
	}
 	int pos = *(int*) _t158.data;
	return string_substr(path, pos, path.len);
}

string os__dir(string path) {
	if ((path).len == 0) {
		return tos_lit(".");
	}
	Option_int _t159 = string_last_index(path, _const_os__path_separator);
	if (!_t159.ok) {
		string err = _t159.v_error;
		int errcode = _t159.ecode;
		return tos_lit(".");
	}
 	int pos = *(int*) _t159.data;
	if (string_ends_with(path, _const_os__path_separator)) {
		pos--;
	}
	return string_substr(path, 0, pos);
}

string os__base(string path) {
	if ((path).len == 0) {
		return tos_lit(".");
	}
	if (string_eq(path, _const_os__path_separator)) {
		return _const_os__path_separator;
	}
	if (string_ends_with(path, _const_os__path_separator)) {
		string path2 = string_substr(path, 0, path.len - 1);
		Option_int _t160 = string_last_index(path2, _const_os__path_separator);
		if (!_t160.ok) {
			string err = _t160.v_error;
			int errcode = _t160.ecode;
			return string_clone(path2);
		}
 		int pos = *(int*) _t160.data;
		return string_substr(path2, pos + 1, path2.len);
	}
	Option_int _t161 = string_last_index(path, _const_os__path_separator);
	if (!_t161.ok) {
		string err = _t161.v_error;
		int errcode = _t161.ecode;
		return string_clone(path);
	}
 	int pos = *(int*) _t161.data;
	return string_substr(path, pos + 1, path.len);
}

string os__file_name(string path) {
	return string_all_after_last(path, _const_os__path_separator);
}

string os__input(string prompt) {
	print(prompt);
	os__flush();
	return os__get_line();
}

string os__get_line() {
	string str = os__get_raw_line();
	#if defined(_WIN32)
	{
		return string_trim_right(str, tos_lit("\r\n"));
	}
	#else
	{
	}
	#endif
	return (string){.str=(byteptr)""};
}

string os__get_raw_line() {
	#if defined(_WIN32)
	{
		{ // Unsafe block
			int max_line_chars = 256;
			byteptr buf = v_malloc(max_line_chars * 2);
			voidptr h_input = GetStdHandle(_const_os__std_input_handle);
			int bytes_read = 0;
			if (is_atty(0) > 0) {
				ReadConsole(h_input, buf, max_line_chars * 2, ((LPDWORD)(&bytes_read)), 0);
				return string_from_wide2(((u16*)(buf)), bytes_read);
			}
			int offset = 0;
			for (;;) {
				byteptr pos = buf + offset;
				bool res = ReadFile(h_input, pos, 1, ((LPDWORD)(&bytes_read)), 0);
				if (!res || bytes_read == 0) {
					break;
				}
				if (*pos == '\n' || *pos == '\r') {
					offset++;
					break;
				}
				offset++;
			}
			return byteptr_vstring_with_len(buf, offset);
		}
	}
	#else
	{
	}
	#endif
	return (string){.str=(byteptr)""};
}

array_byte os__get_raw_stdin() {
	#if defined(_WIN32)
	{
		{ // Unsafe block
			int block_bytes = 512;
			byteptr buf = v_malloc(block_bytes);
			voidptr h_input = GetStdHandle(_const_os__std_input_handle);
			int bytes_read = 0;
			int offset = 0;
			for (;;) {
				byteptr pos = buf + offset;
				bool res = ReadFile(h_input, pos, block_bytes, ((LPDWORD)(&bytes_read)), 0);
				offset += bytes_read;
				if (!res) {
					break;
				}
				buf = v_realloc(buf, ((u32)(offset + block_bytes + (block_bytes - bytes_read))));
			}
			CloseHandle(h_input);
			return (array){.element_size = 1,.data = ((voidptr)(buf)),.len = offset,.cap = offset,};
		}
	}
	#else
	{
	}
	#endif
	return __new_array(0, 1, sizeof(byte));
}

array_string os__get_lines() {
	string line = tos_lit("");
	array_string inputstr = __new_array_with_default(0, 0, sizeof(string), 0);
	for (;;) {
		line = os__get_line();
		if (line.len <= 0) {
			break;
		}
		line = string_trim_space(line);
		array_push(&inputstr, _MOV((string[]){ line }));
	}
	return inputstr;
}

string os__get_lines_joined() {
	string line = tos_lit("");
	string inputstr = tos_lit("");
	for (;;) {
		line = os__get_line();
		if (line.len <= 0) {
			break;
		}
		line = string_trim_space(line);
		inputstr = /*f*/string_add(inputstr, line);
	}
	return inputstr;
}

string os__user_os() {
	#if defined(__linux__)
	{
	}
	#endif
	#if defined(__APPLE__)
	{
	}
	#endif
	#if defined(_WIN32)
	{
		return tos_lit("windows");
	}
	#endif
	#if defined(__FreeBSD__)
	{
	}
	#endif
	#if defined(__OpenBSD__)
	{
	}
	#endif
	#if defined(__NetBSD__)
	{
	}
	#endif
	#if defined(__DragonFly__)
	{
	}
	#endif
	#if defined(__ANDROID__)
	{
	}
	#endif
	#if defined(__sun)
	{
	}
	#endif
	#if defined(__haiku__)
	{
	}
	#endif
	return tos_lit("unknown");
}

string os__home_dir() {
	#if defined(_WIN32)
	{
		return os__getenv(tos_lit("USERPROFILE"));
	}
	#else
	{
	}
	#endif
	return (string){.str=(byteptr)""};
}

Option_void os__write_file(string path, string text) {
	Option_os__File _t163 = os__create(path);
	if (!_t163.ok) {
		return *(Option_void *)&_t163;
	}
 	os__File f = *(os__File*) _t163.data;
	os__File_write(&f, string_bytes(text));
	os__File_close(&f);
	Option_void _t164 = {.ok = true};
	return _t164;
}

Option_void os__write_file_array(string path, array buffer) {
	Option_os__File _t165 = os__create(path);
	if (!_t165.ok) {
		return *(Option_void *)&_t165;
	}
 	os__File f = *(os__File*) _t165.data;
	os__File_write_bytes_at(&f, buffer.data, (buffer.len * buffer.element_size), 0);
	os__File_close(&f);
	Option_void _t166 = {.ok = true};
	return _t166;
}


void os__on_segfault(voidptr f) {
	#if defined(_WIN32)
	{
		return;
	}
	#endif
	#if defined(__APPLE__)
	{
	}
	#endif
}

string os__executable() {
	#if defined(__linux__)
	{
	}
	#endif
	#if defined(_WIN32)
	{
		int max = 512;
		int size = max * 2;
		u16* result = ((u16*)(vcalloc(size)));
		int len = GetModuleFileName(0, result, max);
		u32 attrs = GetFileAttributesW(result);
		u32 is_set = (attrs & 0x400);
		if (is_set != 0) {
			voidptr file = CreateFile(result, 0x80000000, 1, 0, 3, 0x80, 0);
			if (file != -1) {
				u16* final_path = ((u16*)(vcalloc(size)));
				int final_len = GetFinalPathNameByHandleW(file, final_path, size, 0);
				if (final_len < size) {
					string ret = string_from_wide2(final_path, final_len);
					return string_substr(ret, 4, ret.len);
				} else {
					eprintln(tos_lit("os.executable() saw that the executable file path was too long"));
				}
			}
			CloseHandle(file);
		}
		return string_from_wide2(result, len);
	}
	#endif
	#if defined(__APPLE__)
	{
	}
	#endif
	#if defined(__FreeBSD__)
	{
	}
	#endif
	#if defined(__OpenBSD__)
	{
	}
	#endif
	#if defined(__sun)
	{
	}
	#endif
	#if defined(__haiku__)
	{
	}
	#endif
	#if defined(__NetBSD__)
	{
	}
	#endif
	#if defined(__DragonFly__)
	{
	}
	#endif
	return os__executable_fallback();
}

VV_LOCAL_SYMBOL string os__executable_fallback() {
	if (_const_os__args.len == 0) {
		return tos_lit("");
	}
	string exepath = (*(string*)/*ee elem_typ */array_get(_const_os__args, 0));
	#if defined(_WIN32)
	{
		if (!string_contains(exepath, tos_lit(".exe"))) {
			exepath = /*f*/string_add(exepath, tos_lit(".exe"));
		}
	}
	#endif
	if (!os__is_abs_path(exepath)) {
		if (string_contains(exepath, _const_os__path_separator)) {
			exepath = os__join_path(_const_os__wd_at_startup, (varg_string){.len=1,.args={exepath}});
		} else {
			Option_string _t167 = os__find_abs_path_of_executable(exepath);
			if (!_t167.ok) {
				string err = _t167.v_error;
				int errcode = _t167.ecode;
				*(string*) _t167.data = tos_lit("");
			}
 			string foundpath = *(string*) _t167.data;
			if (foundpath.len > 0) {
				exepath = foundpath;
			}
		}
	}
	exepath = os__real_path(exepath);
	return exepath;
}

Option_string os__find_abs_path_of_executable(string exepath) {
	if (os__is_abs_path(exepath)) {
		Option_string _t168;
		opt_ok2(&(string[]) { os__real_path(exepath) }, (OptionBase*)(&_t168), sizeof(string));
		return _t168;
	}
	string res = tos_lit("");
	string env_path_delimiter = (string_eq(os__user_os(), tos_lit("windows")) ? (tos_lit(";")) : (tos_lit(":")));
	array_string paths = string_split(os__getenv(tos_lit("PATH")), env_path_delimiter);
	// FOR IN array
	array _t169 = paths;
	for (int _t170 = 0; _t170 < _t169.len; ++_t170) {
		string p = ((string*)_t169.data)[_t170];
		string found_abs_path = os__join_path(p, (varg_string){.len=1,.args={exepath}});
		if (os__exists(found_abs_path) && os__is_executable(found_abs_path)) {
			res = found_abs_path;
			break;
		}
	}
	if (res.len > 0) {
		Option_string _t171;
		opt_ok2(&(string[]) { os__real_path(res) }, (OptionBase*)(&_t171), sizeof(string));
		return _t171;
	}
	Option _t172 = v_error(tos_lit("failed to find executable"));
	return *(Option_string*)&_t172;
}

bool os__exists_in_system_path(string prog) {
	Option_string _t173 = os__find_abs_path_of_executable(prog);
	if (!_t173.ok) {
		string err = _t173.v_error;
		int errcode = _t173.ecode;
		return false;
	};
	return true;
}

// Attr: [deprecated]
bool os__dir_exists(string path) {
	eprintln(tos_lit("warning: `os.dir_exists` has been deprecated, use `os.is_dir` instead"));
	return os__is_dir(path);
}

bool os__is_dir(string path) {
	#if defined(_WIN32)
	{
		string w_path = string_replace(path, tos_lit("/"), tos_lit("\\"));
		u32 attr = GetFileAttributesW(string_to_wide(w_path));
		if (attr == ((u32)(INVALID_FILE_ATTRIBUTES))) {
			return false;
		}
		if ((((int)(attr)) & FILE_ATTRIBUTE_DIRECTORY) != 0) {
			return true;
		}
		return false;
	}
	#else
	{
	}
	#endif
	return 0;
}

bool os__is_file(string path) {
	return os__exists(path) && !os__is_dir(path);
}

bool os__is_link(string path) {
	#if defined(_WIN32)
	{
		return false;
	}
	#else
	{
	}
	#endif
	return 0;
}

void os__chdir(string path) {
	#if defined(_WIN32)
	{
		_wchdir(string_to_wide(path));
	}
	#else
	{
	}
	#endif
}

string os__getwd() {
	#if defined(_WIN32)
	{
		int max = 512;
		u16* buf = ((u16*)(vcalloc(max * 2)));
		if (_wgetcwd(buf, max) == 0) {
			return tos_lit("");
		}
		return string_from_wide(buf);
	}
	#else
	{
	}
	#endif
	return (string){.str=(byteptr)""};
}

string os__real_path(string fpath) {
	byteptr fullpath = vcalloc(_const_os__max_path_len);
	charptr ret = ((charptr)(0));
	#if defined(_WIN32)
	{
		ret = ((charptr)(_fullpath(fullpath, fpath.str, _const_os__max_path_len)));
		if (ret == 0) {
			return fpath;
		}
	}
	#else
	{
	}
	#endif
	string res = byteptr_vstring(fullpath);
	return os__normalize_drive_letter(res);
}

VV_LOCAL_SYMBOL string os__normalize_drive_letter(string path) {
	#if !defined(_WIN32)
	{
	}
	#endif
	if (path.len > 2 && string_at(path, 0) >= 'a' && string_at(path, 0) <= 'z' && string_at(path, 1) == ':' && string_at(path, 2) == string_at(_const_os__path_separator, 0)) {
		{ // Unsafe block
			byte* x = &path.str[0];
			(*x) = *x - 32;
		}
	}
	return path;
}

bool os__is_abs_path(string path) {
	#if defined(_WIN32)
	{
		return string_at(path, 0) == '/' || (byte_is_letter(string_at(path, 0)) && string_at(path, 1) == ':');
	}
	#endif
	return string_at(path, 0) == '/';
}

string os__join_path(string base, varg_string dirs) {
	array_string result = __new_array_with_default(0, 0, sizeof(string), 0);
	array_push(&result, _MOV((string[]){ string_trim_right(base, tos_lit("\\/")) }));
	// FOR IN cond_type/variadic
	for (int _t175 = 0; _t175 < dirs.len; ++_t175) {
		string d = dirs.args[_t175];
		array_push(&result, _MOV((string[]){ d }));
	}
	return array_string_join(result, _const_os__path_separator);
}

array_string os__walk_ext(string path, string ext) {
	if (!os__is_dir(path)) {
		return __new_array_with_default(0, 0, sizeof(string), 0);
	}
	Option_array_string _t177 = os__ls(path);
	if (!_t177.ok) {
		string err = _t177.v_error;
		int errcode = _t177.ecode;
		return __new_array_with_default(0, 0, sizeof(string), 0);
	}
 	array_string files = *(array_string*) _t177.data;
	array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	string separator = (string_ends_with(path, _const_os__path_separator) ? (tos_lit("")) : (_const_os__path_separator));
	// FOR IN array
	array _t178 = files;
	for (int _t179 = 0; _t179 < _t178.len; ++_t179) {
		string file = ((string*)_t178.data)[_t179];
		if (string_starts_with(file, tos_lit("."))) {
			continue;
		}
		string p = string_add(string_add(path, separator), file);
		if (os__is_dir(p) && !os__is_link(p)) {
			_PUSH_MANY(&res, (os__walk_ext(p, ext)), _t180, array_string);
		} else if (string_ends_with(file, ext)) {
			array_push(&res, _MOV((string[]){ p }));
		}
	}
	return res;
}

void os__walk(string path, void (*f)(string path)) {
	if (!os__is_dir(path)) {
		return;
	}
	Option_array_string _t182 = os__ls(path);
	if (!_t182.ok) {
		string err = _t182.v_error;
		int errcode = _t182.ecode;
		return;
	}
 	array_string files = *(array_string*) _t182.data;
	// FOR IN array
	array _t183 = files;
	for (int _t184 = 0; _t184 < _t183.len; ++_t184) {
		string file = ((string*)_t183.data)[_t184];
		string p = string_add(string_add(path, _const_os__path_separator), file);
		if (os__is_dir(p) && !os__is_link(p)) {
			os__walk(p, f);
		} else if (os__exists(p)) {
			f(p);
		}
	}
	return;
}

// Attr: [unsafe]
void os__signal(int signum, voidptr handler) {
	signal(signum, handler);
}

int os__fork() {
	int pid = -1;
	#if !defined(_WIN32)
	{
	}
	#endif
	#if defined(_WIN32)
	{
		v_panic(tos_lit("os.fork not supported in windows"));
	}
	#endif
	return pid;
}

int os__wait() {
	int pid = -1;
	#if !defined(_WIN32)
	{
	}
	#endif
	#if defined(_WIN32)
	{
		v_panic(tos_lit("os.wait not supported in windows"));
	}
	#endif
	return pid;
}

int os__file_last_mod_unix(string path) {
	struct stat attr;
	stat(((charptr)(path.str)), &attr);
	return attr.st_mtime;
}

void os__log(string s) {
	println(string_add(tos_lit("os.log: "), s));
}

// Attr: [deprecated]
void os__flush_stdout() {
	eprintln(tos_lit("warning: `os.flush_stdout` has been deprecated, use `os.flush` instead"));
	os__flush();
}

void os__flush() {
	fflush(stdout);
}

Option_void os__mkdir_all(string path) {
	string p = (string_starts_with(path, _const_os__path_separator) ? (_const_os__path_separator) : (tos_lit("")));
	array_string path_parts = string_split(string_trim_left(path, _const_os__path_separator), _const_os__path_separator);
	// FOR IN array
	array _t185 = path_parts;
	for (int _t186 = 0; _t186 < _t185.len; ++_t186) {
		string subdir = ((string*)_t185.data)[_t186];
		p = /*f*/string_add(p, string_add(subdir, _const_os__path_separator));
		if (os__exists(p) && os__is_dir(p)) {
			continue;
		}
		Option_bool _t187 = os__mkdir(p);
		if (!_t187.ok) {
			string err = _t187.v_error;
			int errcode = _t187.ecode;
			Option _t188 = v_error(_STR("folder: %.*s\000, error: %.*s", 2, p, err));
			return *(Option_void*)&_t188;
		};
	}
	Option_void _t189 = {.ok = true};
	return _t189;
}

string os__cache_dir() {
	#if !defined(_WIN32)
	{
	}
	#endif
	string cdir = os__join_path(os__home_dir(), (varg_string){.len=1,.args={tos_lit(".cache")}});
	if (!os__is_dir(cdir) && !os__is_link(cdir)) {
		Option_bool _t190 = os__mkdir(cdir);
		if (!_t190.ok) {
			string err = _t190.v_error;
			int errcode = _t190.ecode;
			v_panic(err);
		};
	}
	return cdir;
}

string os__temp_dir() {
	string path = os__getenv(tos_lit("TMPDIR"));
	#if defined(_WIN32)
	{
		if ((path).len == 0) {
			path = os__getenv(tos_lit("TEMP"));
			if ((path).len == 0) {
				path = os__getenv(tos_lit("TMP"));
			}
			if ((path).len == 0) {
				path = tos_lit("C:/tmp");
			}
		}
	}
	#endif
	#if defined(__ANDROID__)
	{
	}
	#endif
	if ((path).len == 0) {
		path = tos_lit("/tmp");
	}
	return path;
}

string os__vmodules_dir() {
	string path = os__getenv(tos_lit("VMODULES"));
	if ((path).len == 0) {
		path = os__join_path(os__home_dir(), (varg_string){.len=1,.args={tos_lit(".vmodules")}});
	}
	return path;
}

void os__chmod(string path, int mode) {
	chmod(((charptr)(path.str)), mode);
}

string os__resource_abs_path(string path) {
	string base_path = os__real_path(os__dir(os__executable()));
	string vresource = os__getenv(tos_lit("V_RESOURCE_PATH"));
	if (vresource.len != 0) {
		base_path = vresource;
	}
	return os__real_path(os__join_path(base_path, (varg_string){.len=1,.args={path}}));
}

Option_os__File os__open(string path) {
	Option_FILE_ptr _t191 = os__vfopen(path, tos_lit("rb"));
	if (!_t191.ok) {
		return *(Option_os__File *)&_t191;
	}
 	FILE* cfile = *(FILE**) _t191.data;
	int fd = os__fileno(cfile);
	Option_os__File _t192;
	opt_ok2(&(os__File[]) { (os__File){.cfile = cfile,.fd = fd,.is_opened = true,} }, (OptionBase*)(&_t192), sizeof(os__File));
	return _t192;
}

Option_os__File os__create(string path) {
	Option_FILE_ptr _t193 = os__vfopen(path, tos_lit("wb"));
	if (!_t193.ok) {
		return *(Option_os__File *)&_t193;
	}
 	FILE* cfile = *(FILE**) _t193.data;
	int fd = os__fileno(cfile);
	Option_os__File _t194;
	opt_ok2(&(os__File[]) { (os__File){.cfile = cfile,.fd = fd,.is_opened = true,} }, (OptionBase*)(&_t194), sizeof(os__File));
	return _t194;
}

// TypeDecl
VV_LOCAL_SYMBOL array_string os__init_os_args_wide(int argc, byteptr* argv) {
	array_string args = __new_array_with_default(0, 0, sizeof(string), 0);
	for (int i = 0; i < argc; ++i) {
		array_push(&args, _MOV((string[]){ string_from_wide(((u16*)(argv[i]))) }));
	}
	return args;
}

Option_array_string os__ls(string path) {
	os__Win32finddata find_file_data = (os__Win32finddata){.dw_file_attributes = 0,.ft_creation_time = {0},.ft_last_access_time = {0},.ft_last_write_time = {0},.n_file_size_high = 0,.n_file_size_low = 0,.dw_reserved0 = 0,.dw_reserved1 = 0,.c_file_name = {0},.c_alternate_file_name = {0},.dw_file_type = 0,.dw_creator_type = 0,.w_finder_flags = 0,};
	array_string dir_files = __new_array_with_default(0, 0, sizeof(string), 0);
	if (!os__is_dir(path)) {
		Option _t196 = v_error(_STR("ls() couldnt open dir \"%.*s\000\": directory does not exist", 2, path));
		return *(Option_array_string*)&_t196;
	}
	string path_files = _STR("%.*s\000\\*", 2, path);
	voidptr h_find_files = FindFirstFile(string_to_wide(path_files), ((voidptr)(&find_file_data)));
	string first_filename = string_from_wide(((u16*)(find_file_data.c_file_name)));
	if (string_ne(first_filename, tos_lit(".")) && string_ne(first_filename, tos_lit(".."))) {
		array_push(&dir_files, _MOV((string[]){ first_filename }));
	}
	for (;;) {
		if (!(FindNextFile(h_find_files, ((voidptr)(&find_file_data))) > 0)) break;
		string filename = string_from_wide(((u16*)(find_file_data.c_file_name)));
		if (string_ne(filename, tos_lit(".")) && string_ne(filename, tos_lit(".."))) {
			array_push(&dir_files, _MOV((string[]){ string_clone(filename) }));
		}
	}
	FindClose(h_find_files);
	Option_array_string _t199;
	opt_ok2(&(array_string[]) { dir_files }, (OptionBase*)(&_t199), sizeof(array_string));
	return _t199;
}

Option_bool os__mkdir(string path) {
	if (string_eq(path, tos_lit("."))) {
		Option_bool _t200;
		opt_ok2(&(bool[]) { true }, (OptionBase*)(&_t200), sizeof(bool));
		return _t200;
	}
	string apath = os__real_path(path);
	if (!CreateDirectory(string_to_wide(apath), 0)) {
		Option _t201 = v_error(string_add(_STR("mkdir failed for \"%.*s\000\", because CreateDirectory returned ", 2, apath), os__get_error_msg(((int)(GetLastError())))));
		return *(Option_bool*)&_t201;
	}
	Option_bool _t202;
	opt_ok2(&(bool[]) { true }, (OptionBase*)(&_t202), sizeof(bool));
	return _t202;
}

os__HANDLE os__get_file_handle(string path) {
	Option_FILE_ptr _t203 = os__vfopen(path, tos_lit("rb"));
	if (!_t203.ok) {
		string err = _t203.v_error;
		int errcode = _t203.ecode;
		return ((_const_os__invalid_handle_value));
	}
 	FILE* cfile = *(FILE**) _t203.data;
	os__HANDLE handle = ((os__HANDLE)(_get_osfhandle(os__fileno(cfile))));
	return handle;
}

Option_string os__get_module_filename(os__HANDLE handle) {
	{ // Unsafe block
		int sz = 4096;
		u16* buf = ((u16*)(v_malloc(4096)));
		for (;;) {
			int status = ((int)(GetModuleFileNameW(handle, ((voidptr)(&buf)), sz)));
			int _t204 = status;
			if (_t204 == _const_os__success) {
				Option_string _t205;
				opt_ok2(&(string[]) { string_from_wide2(buf, sz) }, (OptionBase*)(&_t205), sizeof(string));
				return _t205;
			} else {
				Option _t206 = v_error(tos_lit("Cannot get file name from handle"));
				return *(Option_string*)&_t206;
			};
		}
	}
	v_panic(tos_lit("this should be unreachable"));
	Option _t207 = opt_none();
	return *(Option_string*)&_t207;
}

VV_LOCAL_SYMBOL voidptr os__ptr_win_get_error_msg(u32 code) {
	voidptr buf = ((voidptr)(0));
	if (code > ((u32)(_const_os__max_error_code))) {
		return buf;
	}
	FormatMessage(((_const_os__format_message_allocate_buffer | _const_os__format_message_from_system) | _const_os__format_message_ignore_inserts), 0, code, MAKELANGID(_const_os__lang_neutral, _const_os__sublang_default), ((voidptr)(&buf)), 0, 0);
	return buf;
}

string os__get_error_msg(int code) {
	if (code < 0) {
		return tos_lit("");
	}
	voidptr ptr_text = os__ptr_win_get_error_msg(((u32)(code)));
	if (ptr_text == 0) {
		return tos_lit("");
	}
	return string_from_wide(ptr_text);
}

Option_os__Result os__exec(string cmd) {
	if (string_contains(cmd, tos_lit(";")) || string_contains(cmd, tos_lit("&&")) || string_contains(cmd, tos_lit("||")) || string_contains(cmd, tos_lit("\n"))) {
		Option _t208 = v_error(tos_lit(";, &&, || and \\n are not allowed in shell commands"));
		return *(Option_os__Result*)&_t208;
	}
	u32* child_stdin = ((u32*)(0));
	u32* child_stdout_read = ((u32*)(0));
	u32* child_stdout_write = ((u32*)(0));
	os__SecurityAttributes sa = (os__SecurityAttributes){.n_length = 0,.lp_security_descriptor = 0,.b_inherit_handle = 0,};
	sa.n_length = /*SizeOfType*/ sizeof(SECURITY_ATTRIBUTES);
	sa.b_inherit_handle = true;
	bool create_pipe_ok = CreatePipe(((voidptr)(&child_stdout_read)), ((voidptr)(&child_stdout_write)), ((voidptr)(&sa)), 0);
	if (!create_pipe_ok) {
		int error_num = ((int)(GetLastError()));
		string error_msg = os__get_error_msg(error_num);
		Option _t209 = error_with_code(_STR("exec failed (CreatePipe): %.*s", 1, error_msg), error_num);
		return *(Option_os__Result*)&_t209;
	}
	bool set_handle_info_ok = SetHandleInformation(child_stdout_read, HANDLE_FLAG_INHERIT, 0);
	if (!set_handle_info_ok) {
		int error_num = ((int)(GetLastError()));
		string error_msg = os__get_error_msg(error_num);
		Option _t210 = error_with_code(_STR("exec failed (SetHandleInformation): %.*s", 1, error_msg), error_num);
		return *(Option_os__Result*)&_t210;
	}
	os__ProcessInformation proc_info = (os__ProcessInformation){.h_process = 0,.h_thread = 0,.dw_process_id = 0,.dw_thread_id = 0,};
	os__StartupInfo start_info = (os__StartupInfo){
		.cb = /*SizeOfType*/ sizeof(PROCESS_INFORMATION),
		.lp_reserved = 0,
		.lp_desktop = 0,
		.lp_title = 0,
		.dw_x = 0,
		.dw_y = 0,
		.dw_x_size = 0,
		.dw_y_size = 0,
		.dw_x_count_chars = 0,
		.dw_y_count_chars = 0,
		.dw_fill_attributes = 0,
		.dw_flags = ((u32)(STARTF_USESTDHANDLES)),
		.w_show_window = 0,
		.cb_reserved2 = 0,
		.lp_reserved2 = 0,
		.h_std_input = child_stdin,
		.h_std_output = child_stdout_write,
		.h_std_error = child_stdout_write,
	};
	array_fixed_u16_32768 command_line = {0};
	ExpandEnvironmentStringsW(string_to_wide(cmd), ((voidptr)(&command_line)), 32768);
	bool create_process_ok = CreateProcessW(0, command_line, 0, 0, TRUE, 0, 0, 0, ((voidptr)(&start_info)), ((voidptr)(&proc_info)));
	if (!create_process_ok) {
		int error_num = ((int)(GetLastError()));
		string error_msg = os__get_error_msg(error_num);
		Option _t211 = error_with_code(_STR("exec failed (CreateProcess) with code %"PRId32"\000: %.*s\000 cmd: %.*s", 3, error_num, error_msg, cmd), error_num);
		return *(Option_os__Result*)&_t211;
	}
	CloseHandle(child_stdin);
	CloseHandle(child_stdout_write);
	array_fixed_byte_4096 buf = {0};
	u32 bytes_read = ((u32)(0U));
	strings__Builder read_data = strings__new_builder(1024);
	for (;;) {
		bool readfile_result = ReadFile(child_stdout_read, buf, 1000, ((voidptr)(&bytes_read)), 0);
		strings__Builder_write_bytes(&read_data, (voidptr)&/*qq*/buf, ((int)(bytes_read)));
		if (readfile_result == false || ((int)(bytes_read)) == 0) {
			break;
		}
	}
	string soutput = string_trim_space(strings__Builder_str(&read_data));
	strings__Builder_free(&read_data);
	u32 exit_code = ((u32)(0U));
	WaitForSingleObject(proc_info.h_process, INFINITE);
	GetExitCodeProcess(proc_info.h_process, ((voidptr)(&exit_code)));
	CloseHandle(proc_info.h_process);
	CloseHandle(proc_info.h_thread);
	Option_os__Result _t212;
	opt_ok2(&(os__Result[]) { (os__Result){.exit_code = ((int)(exit_code)),.output = soutput,} }, (OptionBase*)(&_t212), sizeof(os__Result));
	return _t212;
}

Option_bool os__symlink(string symlink_path, string target_path) {
	int flags = 0;
	if (os__is_dir(symlink_path)) {
		flags |= 1;
	}
	flags |= 2;
	int res = CreateSymbolicLinkW(string_to_wide(symlink_path), string_to_wide(target_path), flags);
	if (res == 0) {
		Option _t213 = v_error(os__get_error_msg(((int)(GetLastError()))));
		return *(Option_bool*)&_t213;
	}
	if (!os__exists(symlink_path)) {
		Option _t214 = v_error(tos_lit("C.CreateSymbolicLinkW reported success, but symlink still does not exist"));
		return *(Option_bool*)&_t214;
	}
	Option_bool _t215;
	opt_ok2(&(bool[]) { true }, (OptionBase*)(&_t215), sizeof(bool));
	return _t215;
}

void os__File_close(os__File* f) {
	if (!f->is_opened) {
		return;
	}
	f->is_opened = false;
	fflush(f->cfile);
	fclose(f->cfile);
}

// TypeDecl
void os__add_vectored_exception_handler(bool first, VectoredExceptionHandler handler) {
	AddVectoredExceptionHandler(((u32)(first)), ((PVECTORED_EXCEPTION_HANDLER)(handler)));
}

bool os__debugger_present() {
	return IsDebuggerPresent();
}

os__Uname os__uname() {
	string unknown = tos_lit("unknown");
	return (os__Uname){.sysname = unknown,.nodename = unknown,.release = unknown,.version = unknown,.machine = unknown,};
}

Option_bool os__is_writable_folder(string folder) {
	if (!os__exists(folder)) {
		Option _t216 = v_error(_STR("`%.*s\000` does not exist", 2, folder));
		return *(Option_bool*)&_t216;
	}
	if (!os__is_dir(folder)) {
		Option _t217 = v_error(tos_lit("`folder` is not a folder"));
		return *(Option_bool*)&_t217;
	}
	string tmp_perm_check = os__join_path(folder, (varg_string){.len=1,.args={string_add(tos_lit("tmp_perm_check_pid_"), int_str(os__getpid()))}});
	Option_os__File _t218 = os__open_file(tmp_perm_check, tos_lit("w+"), (varg_int){.len=1,.args={0700}});
	if (!_t218.ok) {
		string err = _t218.v_error;
		int errcode = _t218.ecode;
		Option _t219 = v_error(_STR("cannot write to folder %.*s\000: %.*s", 2, folder, err));
		return *(Option_bool*)&_t219;
	}
 	os__File f = *(os__File*) _t218.data;
	os__File_close(&f);
	os__rm(tmp_perm_check);
	Option_bool _t220;
	opt_ok2(&(bool[]) { true }, (OptionBase*)(&_t220), sizeof(bool));
	return _t220;
}

// Attr: [inline]
inline int os__getpid() {
	return _getpid();
}

os__Process* os__new_process(string filename) {
	return (os__Process*)memdup(&(os__Process){.filename = filename,.pid = 0,.code = -1,.status = os__ProcessState_not_started,.err = (string){.str=(byteptr)""},.args = __new_array(0, 1, sizeof(string)),.env_is_custom = 0,.env = __new_array(0, 1, sizeof(string)),.use_stdio_ctl = 0,.stdio_fd = {0},}, sizeof(os__Process));
}

os__Process* os__Process_set_args(os__Process* p, array_string pargs) {
	if (p->status != os__ProcessState_not_started) {
		return p;
	}
	p->args = pargs;
	return p;
}

os__Process* os__Process_set_environment(os__Process* p, map_string_string envs) {
	if (p->status != os__ProcessState_not_started) {
		return p;
	}
	p->env_is_custom = true;
	p->env = __new_array_with_default(0, 0, sizeof(string), 0);
	// FOR IN map
	map_string_string _t222 = envs;
	for (int _t221 = 0; _t221 < _t222.key_values.len; ++_t221) {
		if (_t222.key_values.keys[_t221].str == 0) {continue;}
		string k = /*key*/ string_clone(_t222.key_values.keys[_t221]);
		string v = (*(string*)(void*)(_t222.key_values.values + _t221 * (u32)(_t222.value_bytes)));
		array_push(&p->env, _MOV((string[]){ _STR("%.*s\000=%.*s", 2, k, v) }));
	}
	return p;
}

os__Process* os__Process_run(os__Process* p) {
	if (p->status != os__ProcessState_not_started) {
		return p;
	}
	os__Process__spawn(p);
	return p;
}

os__Process* os__Process_signal_kill(os__Process* p) {
	if (!(p->status == os__ProcessState_running || p->status == os__ProcessState_stopped)) {
		return p;
	}
	os__Process__signal_kill(p);
	p->status = os__ProcessState_aborted;
	return p;
}

os__Process* os__Process_signal_stop(os__Process* p) {
	if (p->status != os__ProcessState_running) {
		return p;
	}
	os__Process__signal_stop(p);
	p->status = os__ProcessState_stopped;
	return p;
}

os__Process* os__Process_signal_continue(os__Process* p) {
	if (p->status != os__ProcessState_stopped) {
		return p;
	}
	os__Process__signal_continue(p);
	p->status = os__ProcessState_running;
	return p;
}

os__Process* os__Process_wait(os__Process* p) {
	if (p->status == os__ProcessState_not_started) {
		os__Process__spawn(p);
	}
	if (!(p->status == os__ProcessState_running || p->status == os__ProcessState_stopped)) {
		return p;
	}
	os__Process__wait(p);
	return p;
}

VV_LOCAL_SYMBOL int os__Process__spawn(os__Process* p) {
	if (!p->env_is_custom) {
		p->env = __new_array_with_default(0, 0, sizeof(string), 0);
		map_string_string current_environment = os__environ();
		// FOR IN map
		map_string_string _t225 = current_environment;
		for (int _t224 = 0; _t224 < _t225.key_values.len; ++_t224) {
			if (_t225.key_values.keys[_t224].str == 0) {continue;}
			string k = /*key*/ string_clone(_t225.key_values.keys[_t224]);
			string v = (*(string*)(void*)(_t225.key_values.values + _t224 * (u32)(_t225.value_bytes)));
			array_push(&p->env, _MOV((string[]){ _STR("%.*s\000=%.*s", 2, k, v) }));
		}
	}
	int pid = 0;
	#if defined(_WIN32)
	{
		pid = os__Process_win_spawn_process(p);
	}
	#else
	{
	}
	#endif
	p->pid = pid;
	p->status = os__ProcessState_running;
	return 0;
}

bool os__Process_is_alive(os__Process* p) {
	if ((p->status == os__ProcessState_running || p->status == os__ProcessState_stopped)) {
		return os__Process__is_alive(p);
	}
	return false;
}

os__Process* os__Process_set_redirect_stdio(os__Process* p) {
	p->use_stdio_ctl = true;
	return p;
}

void os__Process_stdin_write(os__Process* p, string s) {
	os__Process__check_redirection_call(p, tos_lit("stdin_write"));
	os__fd_write(p->stdio_fd[0], s);
}

string os__Process_stdout_slurp(os__Process* p) {
	os__Process__check_redirection_call(p, tos_lit("stdout_slurp"));
	return array_string_join(os__fd_slurp(p->stdio_fd[1]), tos_lit(""));
}

string os__Process_stderr_slurp(os__Process* p) {
	os__Process__check_redirection_call(p, tos_lit("stderr_slurp"));
	return array_string_join(os__fd_slurp(p->stdio_fd[2]), tos_lit(""));
}

string os__Process_stdout_read(os__Process* p) {
	os__Process__check_redirection_call(p, tos_lit("stdout_read"));
	multi_return_string_int mr_4576 = os__fd_read(p->stdio_fd[1], 4096);
	string s = mr_4576.arg0;
	return s;
}

string os__Process_stderr_read(os__Process* p) {
	os__Process__check_redirection_call(p, tos_lit("stderr_read"));
	multi_return_string_int mr_4715 = os__fd_read(p->stdio_fd[2], 4096);
	string s = mr_4715.arg0;
	return s;
}

VV_LOCAL_SYMBOL void os__Process__check_redirection_call(os__Process* p, string fn_name) {
	if (!p->use_stdio_ctl) {
		v_panic(_STR("Call p.set_redirect_stdio() before calling p.%.*s", 1, fn_name));
	}
	if (p->status == os__ProcessState_not_started) {
		v_panic(_STR("Call p.%.*s\000() after you have called p.run()", 2, fn_name));
	}
}

VV_LOCAL_SYMBOL void os__Process__signal_stop(os__Process* p) {
	#if defined(_WIN32)
	{
		os__Process_win_stop_process(p);
	}
	#else
	{
	}
	#endif
}

VV_LOCAL_SYMBOL void os__Process__signal_continue(os__Process* p) {
	#if defined(_WIN32)
	{
		os__Process_win_resume_process(p);
	}
	#else
	{
	}
	#endif
}

VV_LOCAL_SYMBOL void os__Process__signal_kill(os__Process* p) {
	#if defined(_WIN32)
	{
		os__Process_win_kill_process(p);
	}
	#else
	{
	}
	#endif
}

VV_LOCAL_SYMBOL void os__Process__wait(os__Process* p) {
	#if defined(_WIN32)
	{
		os__Process_win_wait(p);
	}
	#else
	{
	}
	#endif
}

VV_LOCAL_SYMBOL bool os__Process__is_alive(os__Process* p) {
	#if defined(_WIN32)
	{
		return os__Process_win_is_alive(p);
	}
	#else
	{
	}
	#endif
	return 0;
}

VV_LOCAL_SYMBOL int os__Process_win_spawn_process(os__Process* p) {
	eprintln(tos_lit("TODO implement waiting for a process on windows"));
	return 12345;
}

VV_LOCAL_SYMBOL void os__Process_win_stop_process(os__Process* p) {
	eprintln(tos_lit("TODO implement stopping a process on windows"));
}

VV_LOCAL_SYMBOL void os__Process_win_resume_process(os__Process* p) {
	eprintln(tos_lit("TODO implement resuming a process on windows"));
}

VV_LOCAL_SYMBOL void os__Process_win_kill_process(os__Process* p) {
	eprintln(tos_lit("TODO implement killing a process on windows"));
}

VV_LOCAL_SYMBOL void os__Process_win_wait(os__Process* p) {
	eprintln(tos_lit("TODO implement waiting for a process on windows"));
	p->status = os__ProcessState_exited;
	p->code = 0;
}

VV_LOCAL_SYMBOL bool os__Process_win_is_alive(os__Process* p) {
	eprintln(tos_lit("TODO implement checking whether the process is still alive on windows"));
	return false;
}

VV_LOCAL_SYMBOL int os__Process_unix_spawn_process(os__Process* p) {
	return 0;
}

VV_LOCAL_SYMBOL void os__Process_unix_stop_process(os__Process* p) {
}

VV_LOCAL_SYMBOL void os__Process_unix_resume_process(os__Process* p) {
}

VV_LOCAL_SYMBOL void os__Process_unix_kill_process(os__Process* p) {
}

VV_LOCAL_SYMBOL void os__Process_unix_wait(os__Process* p) {
}

VV_LOCAL_SYMBOL bool os__Process_unix_is_alive(os__Process* p) {
	return false;
}

array_string os__cmdline__options(array_string args, string param) {
	array_string flags = __new_array_with_default(0, 0, sizeof(string), 0);
	// FOR IN array
	array _t227 = args;
	for (int i = 0; i < _t227.len; ++i) {
		string v = ((string*)_t227.data)[i];
		if (string_eq(v, param)) {
			if (i + 1 < args.len) {
				array_push(&flags, _MOV((string[]){ string_clone((*(string*)/*ee elem_typ */array_get(args, i + 1))) }));
			}
		}
	}
	return flags;
}

string os__cmdline__option(array_string args, string param, string def) {
	bool found = false;
	// FOR IN array
	array _t229 = args;
	for (int _t230 = 0; _t230 < _t229.len; ++_t230) {
		string arg = ((string*)_t229.data)[_t230];
		if (found) {
			return arg;
		} else if (string_eq(param, arg)) {
			found = true;
		}
	}
	return def;
}

array_string os__cmdline__options_before(array_string args, array_string what) {
	array_string args_before = __new_array_with_default(0, 0, sizeof(string), 0);
	// FOR IN array
	array _t231 = args;
	for (int _t232 = 0; _t232 < _t231.len; ++_t232) {
		string a = ((string*)_t231.data)[_t232];
		if (_IN(string, a, what)) {
			break;
		}
		array_push(&args_before, _MOV((string[]){ string_clone(a) }));
	}
	return args_before;
}

array_string os__cmdline__options_after(array_string args, array_string what) {
	bool found = false;
	array_string args_after = __new_array_with_default(0, 0, sizeof(string), 0);
	// FOR IN array
	array _t234 = args;
	for (int _t235 = 0; _t235 < _t234.len; ++_t235) {
		string a = ((string*)_t234.data)[_t235];
		if (_IN(string, a, what)) {
			found = true;
			continue;
		}
		if (found) {
			array_push(&args_after, _MOV((string[]){ string_clone(a) }));
		}
	}
	return args_after;
}

array_string os__cmdline__only_non_options(array_string args) {

int _t237_len = args.len;
	array_string _t237 = __new_array(0, _t237_len, sizeof(string));
	for (int i = 0; i < _t237_len; ++i) {
	  string it = ((string*) args.data)[i];
	if (!string_starts_with(it, tos_lit("-"))) array_push(&_t237, &it); 
 }
		return  _t237;
}

array_string os__cmdline__only_options(array_string args) {

int _t238_len = args.len;
	array_string _t238 = __new_array(0, _t238_len, sizeof(string));
	for (int i = 0; i < _t238_len; ++i) {
	  string it = ((string*) args.data)[i];
	if (string_starts_with(it, tos_lit("-"))) array_push(&_t238, &it); 
 }
		return  _t238;
}

string time__Time_format(time__Time t) {
	return time__Time_get_fmt_str(t, time__FormatDelimiter_hyphen, time__FormatTime_hhmm24, time__FormatDate_yyyymmdd);
}

string time__Time_format_ss(time__Time t) {
	return time__Time_get_fmt_str(t, time__FormatDelimiter_hyphen, time__FormatTime_hhmmss24, time__FormatDate_yyyymmdd);
}

string time__Time_format_ss_milli(time__Time t) {
	return time__Time_get_fmt_str(t, time__FormatDelimiter_hyphen, time__FormatTime_hhmmss24_milli, time__FormatDate_yyyymmdd);
}

string time__Time_format_ss_micro(time__Time t) {
	return time__Time_get_fmt_str(t, time__FormatDelimiter_hyphen, time__FormatTime_hhmmss24_micro, time__FormatDate_yyyymmdd);
}

string time__Time_hhmm(time__Time t) {
	return time__Time_get_fmt_time_str(t, time__FormatTime_hhmm24);
}

string time__Time_hhmmss(time__Time t) {
	return time__Time_get_fmt_time_str(t, time__FormatTime_hhmmss24);
}

string time__Time_hhmm12(time__Time t) {
	return time__Time_get_fmt_time_str(t, time__FormatTime_hhmm12);
}

string time__Time_ymmdd(time__Time t) {
	return time__Time_get_fmt_date_str(t, time__FormatDelimiter_hyphen, time__FormatDate_yyyymmdd);
}

string time__Time_ddmmy(time__Time t) {
	return time__Time_get_fmt_date_str(t, time__FormatDelimiter_dot, time__FormatDate_ddmmyyyy);
}

string time__Time_md(time__Time t) {
	return time__Time_get_fmt_date_str(t, time__FormatDelimiter_space, time__FormatDate_mmmd);
}

string time__Time_clean(time__Time t) {
	time__Time znow = time__now();
	if (t.month == znow.month && t.year == znow.year && t.day == znow.day) {
		return time__Time_get_fmt_time_str(t, time__FormatTime_hhmm24);
	}
	if (t.year == znow.year) {
		return time__Time_get_fmt_str(t, time__FormatDelimiter_space, time__FormatTime_hhmm24, time__FormatDate_mmmd);
	}
	return time__Time_format(t);
}

string time__Time_clean12(time__Time t) {
	time__Time znow = time__now();
	if (t.month == znow.month && t.year == znow.year && t.day == znow.day) {
		return time__Time_get_fmt_time_str(t, time__FormatTime_hhmm12);
	}
	if (t.year == znow.year) {
		return time__Time_get_fmt_str(t, time__FormatDelimiter_space, time__FormatTime_hhmm12, time__FormatDate_mmmd);
	}
	return time__Time_format(t);
}

string time__Time_get_fmt_time_str(time__Time t, time__FormatTime fmt_time) {
	if (fmt_time == time__FormatTime_no_time) {
		return tos_lit("");
	}
	string tp = (t.hour > 11 ? (tos_lit("p.m.")) : (tos_lit("a.m.")));
	int hour = (t.hour > 12 ? (t.hour - 12) : t.hour == 0 ? (12) : (t.hour));
	time__FormatTime _t239 = fmt_time;
		return ((_t239 == time__FormatTime_hhmm12) ? (_STR("%"PRId32"\000:%02"PRId32"\000 %.*s", 3, hour, t.minute, tp)) : (_t239 == time__FormatTime_hhmm24) ? (_STR("%02"PRId32"\000:%02"PRId32"", 2, t.hour, t.minute)) : (_t239 == time__FormatTime_hhmmss12) ? (_STR("%"PRId32"\000:%02"PRId32"\000:%02"PRId32"\000 %.*s", 4, hour, t.minute, t.second, tp)) : (_t239 == time__FormatTime_hhmmss24) ? (_STR("%02"PRId32"\000:%02"PRId32"\000:%02"PRId32"", 3, t.hour, t.minute, t.second)) : (_t239 == time__FormatTime_hhmmss24_milli) ? (_STR("%02"PRId32"\000:%02"PRId32"\000:%02"PRId32"\000.%03"PRId32"", 4, t.hour, t.minute, t.second, (t.microsecond / 1000))) : (_t239 == time__FormatTime_hhmmss24_micro) ? (_STR("%02"PRId32"\000:%02"PRId32"\000:%02"PRId32"\000.%06"PRId32"", 4, t.hour, t.minute, t.second, t.microsecond)) : (_STR("unknown enumeration %.*s", 1, time__FormatTime_str(fmt_time))));
}

string time__Time_get_fmt_date_str(time__Time t, time__FormatDelimiter fmt_dlmtr, time__FormatDate fmt_date) {
	if (fmt_date == time__FormatDate_no_date) {
		return tos_lit("");
	}
	string month = _STR("%.*s", 1, time__Time_smonth(t));
	string year = _STR("%02"PRId32"", 1, (t.year % 100));
	time__FormatDate _t240 = fmt_date;
		string res = ((_t240 == time__FormatDate_ddmmyy) ? (_STR("%02"PRId32"\000|%02"PRId32"\000|%.*s", 3, t.day, t.month, year)) : (_t240 == time__FormatDate_ddmmyyyy) ? (_STR("%02"PRId32"\000|%02"PRId32"\000|%04"PRId32"", 3, t.day, t.month, t.year)) : (_t240 == time__FormatDate_mmddyy) ? (_STR("%02"PRId32"\000|%02"PRId32"\000|%.*s", 3, t.month, t.day, year)) : (_t240 == time__FormatDate_mmddyyyy) ? (_STR("%02"PRId32"\000|%02"PRId32"\000|%04"PRId32"", 3, t.month, t.day, t.year)) : (_t240 == time__FormatDate_mmmd) ? (_STR("%.*s\000|%"PRId32"", 2, month, t.day)) : (_t240 == time__FormatDate_mmmdd) ? (_STR("%.*s\000|%02"PRId32"", 2, month, t.day)) : (_t240 == time__FormatDate_mmmddyyyy) ? (_STR("%.*s\000|%02"PRId32"\000|%04"PRId32"", 3, month, t.day, t.year)) : (_t240 == time__FormatDate_yyyymmdd) ? (_STR("%04"PRId32"\000|%02"PRId32"\000|%02"PRId32"", 3, t.year, t.month, t.day)) : (_STR("unknown enumeration %.*s", 1, time__FormatDate_str(fmt_date))));
	time__FormatDelimiter _t241 = fmt_dlmtr;
		string del = ((_t241 == time__FormatDelimiter_dot) ? (tos_lit(".")) : (_t241 == time__FormatDelimiter_hyphen) ? (tos_lit("-")) : (_t241 == time__FormatDelimiter_slash) ? (tos_lit("/")) : (_t241 == time__FormatDelimiter_space) ? (tos_lit(" ")) : (tos_lit("")));
	res = string_replace(res, tos_lit("|"), del);
	return res;
}

string time__Time_get_fmt_str(time__Time t, time__FormatDelimiter fmt_dlmtr, time__FormatTime fmt_time, time__FormatDate fmt_date) {
	if (fmt_date == time__FormatDate_no_date) {
		if (fmt_time == time__FormatTime_no_time) {
			return tos_lit("");
		} else {
			return time__Time_get_fmt_time_str(t, fmt_time);
		}
	} else {
		if (fmt_time != time__FormatTime_no_time) {
			return string_add(string_add(time__Time_get_fmt_date_str(t, fmt_dlmtr, fmt_date), tos_lit(" ")), time__Time_get_fmt_time_str(t, fmt_time));
		} else {
			return time__Time_get_fmt_date_str(t, fmt_dlmtr, fmt_date);
		}
	}
	return (string){.str=(byteptr)""};
}

string time__Time_utc_string(time__Time t) {
	string day_str = time__Time_weekday_str(t);
	string month_str = time__Time_smonth(t);
	string utc_string = _STR("%.*s\000, %"PRId32"\000 %.*s\000 %"PRId32"\000 %02"PRId32"\000:%02"PRId32"\000:%02"PRId32"\000 UTC", 8, day_str, t.day, month_str, t.year, t.hour, t.minute, t.second);
	return utc_string;
}

// Attr: [inline]
inline bool time__Time_eq(time__Time t1, time__Time t2) {
	if (t1.v_unix == t2.v_unix && t1.microsecond == t2.microsecond) {
		return true;
	}
	return false;
}

bool time__Time_ne(time__Time t1, time__Time t2) {
	return !time__Time_eq(t1, t2);
}

bool time__Time_lt(time__Time t1, time__Time t2) {
	if (t1.v_unix < t2.v_unix || (t1.v_unix == t2.v_unix && t1.microsecond < t2.microsecond)) {
		return true;
	}
	return false;
}

bool time__Time_le(time__Time t1, time__Time t2) {
	return time__Time_lt(t1, t2) || time__Time_eq(t1, t2);
}

bool time__Time_gt(time__Time t1, time__Time t2) {
	if (t1.v_unix > t2.v_unix || (t1.v_unix == t2.v_unix && t1.microsecond > t2.microsecond)) {
		return true;
	}
	return false;
}

bool time__Time_ge(time__Time t1, time__Time t2) {
	return time__Time_gt(t1, t2) || time__Time_eq(t1, t2);
}

Option_time__Time time__parse(string s) {
	Option_int _t242 = string_index(s, tos_lit(" "));
	if (!_t242.ok) {
		string err = _t242.v_error;
		int errcode = _t242.ecode;
		Option _t243 = v_error(_STR("Invalid time format: %.*s", 1, s));
		return *(Option_time__Time*)&_t243;
	}
 	int pos = *(int*) _t242.data;
	string symd = string_substr(s, 0, pos);
	array_string ymd = string_split(symd, tos_lit("-"));
	if (ymd.len != 3) {
		Option _t244 = v_error(_STR("Invalid time format: %.*s", 1, s));
		return *(Option_time__Time*)&_t244;
	}
	string shms = string_substr(s, pos, s.len);
	array_string hms = string_split(shms, tos_lit(":"));
	string hour = string_substr((*(string*)/*ee elem_typ */array_get(hms, 0)), 1, (*(string*)/*ee elem_typ */array_get(hms, 0)).len);
	string minute = (*(string*)/*ee elem_typ */array_get(hms, 1));
	string second = (*(string*)/*ee elem_typ */array_get(hms, 2));
	time__Time res = time__new_time((time__Time){
		.year = string_int((*(string*)/*ee elem_typ */array_get(ymd, 0))),
		.month = string_int((*(string*)/*ee elem_typ */array_get(ymd, 1))),
		.day = string_int((*(string*)/*ee elem_typ */array_get(ymd, 2))),
		.hour = string_int(hour),
		.minute = string_int(minute),
		.second = string_int(second),
		.microsecond = 0,
		.v_unix = 0,
	});
	Option_time__Time _t245;
	opt_ok2(&(time__Time[]) { res }, (OptionBase*)(&_t245), sizeof(time__Time));
	return _t245;
}

Option_time__Time time__parse_rfc2822(string s) {
	array_string fields = string_split(s, tos_lit(" "));
	if (fields.len < 5) {
		Option _t246 = v_error(_STR("Invalid time format: %.*s", 1, s));
		return *(Option_time__Time*)&_t246;
	}
	Option_int _t247 = string_index(_const_time__months_string, (*(string*)/*ee elem_typ */array_get(fields, 2)));
	if (!_t247.ok) {
		string err = _t247.v_error;
		int errcode = _t247.ecode;
		Option _t248 = v_error(_STR("Invalid time format: %.*s", 1, s));
		return *(Option_time__Time*)&_t248;
	}
 	int pos = *(int*) _t247.data;
	int mm = pos / 3 + 1;
	byteptr tmstr = ((byteptr)(0));
	{ // Unsafe block
		tmstr = v_malloc(s.len * 2);
	}
	int count = snprintf(((charptr)(tmstr)), (s.len * 2), "%s-%02d-%s %s", (*(string*)/*ee elem_typ */array_get(fields, 3)).str, mm, (*(string*)/*ee elem_typ */array_get(fields, 1)).str, (*(string*)/*ee elem_typ */array_get(fields, 4)).str);
	return time__parse(tos(tmstr, count));
}

Option_time__Time time__parse_iso8601(string s) {
	int year = 0;
	int month = 0;
	int day = 0;
	int hour = 0;
	int minute = 0;
	int second = 0;
	int mic_second = 0;
	rune time_char = 'a';
	rune plus_min = 'a';
	int offset_hour = 0;
	int offset_min = 0;
	int count = sscanf(((charptr)(s.str)), "%4d-%2d-%2d%c%2d:%2d:%2d.%6d%c%2d:%2d", &year, &month, &day, ((charptr)(&time_char)), &hour, &minute, &second, &mic_second, ((charptr)(&plus_min)), &offset_hour, &offset_min);
	if (count != 11) {
		Option _t249 = v_error(tos_lit("Invalid 8601 format"));
		return *(Option_time__Time*)&_t249;
	}
	if (time_char != 'T' && time_char != ' ') {
		Option _t250 = v_error(tos_lit("Invalid 8601 format, expected space or `T` as time separator"));
		return *(Option_time__Time*)&_t250;
	}
	if (plus_min != '+' && plus_min != '-') {
		Option _t251 = v_error(tos_lit("Invalid 8601 format, expected `+` or `-` as time separator"));
		return *(Option_time__Time*)&_t251;
	}
	time__Time t = time__new_time((time__Time){
		.year = year,
		.month = month,
		.day = day,
		.hour = hour,
		.minute = minute,
		.second = second,
		.microsecond = mic_second,
		.v_unix = 0,
	});
	u64 unix_time = t.v_unix;
	int unix_offset = ((int)(0));
	if (offset_hour > 0) {
		unix_offset += 3600 * offset_hour;
	}
	if (offset_min > 0) {
		unix_offset += 60 * offset_min;
	}
	if (unix_offset != 0) {
		if (plus_min == '+') {
			unix_time -= ((u64)(unix_offset));
		} else {
			unix_time += ((u64)(unix_offset));
		}
		t = time__unix2(((int)(unix_time)), t.microsecond);
	}
	Option_time__Time _t252;
	opt_ok2(&(time__Time[]) { time__to_local_time(t) }, (OptionBase*)(&_t252), sizeof(time__Time));
	return _t252;
}

time__StopWatch time__new_stopwatch(time__StopWatchOptions opts) {
	u64 initial = ((u64)(0U));
	if (opts.auto_start) {
		initial = time__sys_mono_now();
	}
	return (time__StopWatch){.elapsed = 0,.start = initial,.end = 0,};
}

void time__StopWatch_start(time__StopWatch* t) {
	t->start = time__sys_mono_now();
	t->end = 0;
}

void time__StopWatch_restart(time__StopWatch* t) {
	t->start = time__sys_mono_now();
	t->end = 0;
	t->elapsed = 0;
}

void time__StopWatch_stop(time__StopWatch* t) {
	t->end = time__sys_mono_now();
}

void time__StopWatch_pause(time__StopWatch* t) {
	if (t->start > 0) {
		if (t->end == 0) {
			t->elapsed += time__sys_mono_now() - t->start;
		} else {
			t->elapsed += t->end - t->start;
		}
	}
	t->start = 0;
}

time__Duration time__StopWatch_elapsed(time__StopWatch t) {
	if (t.start > 0) {
		if (t.end == 0) {
			return ((((i64)(time__sys_mono_now() - t.start + t.elapsed))));
		} else {
			return ((((i64)(t.end - t.start + t.elapsed))));
		}
	}
	return ((((i64)(t.elapsed))));
}

time__Time time__now() {
	#if defined(__APPLE__)
	{
	}
	#endif
	#if defined(_WIN32)
	{
		return time__win_now();
	}
	#endif
	#if defined(__sun)
	{
	}
	#endif
	#if defined(__linux__) || defined(__ANDROID__)
	{
	}
	#endif
	time_t t = time(0);
	struct tm* now = localtime(&t);
	return time__convert_ctime(*now, 0);
}

time__Time time__utc() {
	#if defined(__APPLE__)
	{
	}
	#endif
	#if defined(_WIN32)
	{
		return time__win_utc();
	}
	#endif
	#if defined(__sun)
	{
	}
	#endif
	#if defined(__linux__) || defined(__ANDROID__)
	{
	}
	#endif
	time_t t = time(0);
	time(&t);
	return time__unix2(((int)(t)), 0);
}

string time__Time_smonth(time__Time t) {
	if (t.month <= 0 || t.month > 12) {
		return tos_lit("---");
	}
	int i = t.month - 1;
	return string_substr(_const_time__months_string, i * 3, (i + 1) * 3);
}

time__Time time__new_time(time__Time t) {
	if (t.v_unix != 0) {
		return t;
	}
	struct tm tt = (struct tm){
		.tm_year = t.year - 1900,
		.tm_mon = t.month - 1,
		.tm_mday = t.day,
		.tm_hour = t.hour,
		.tm_min = t.minute,
		.tm_sec = t.second,
	};
	u64 utime = ((u64)(time__make_unix_time(tt)));
	return // assoc
	(time__Time){
		.year = t.year,
		.month = t.month,
		.day = t.day,
		.hour = t.hour,
		.minute = t.minute,
		.second = t.second,
		.microsecond = t.microsecond,
		.v_unix = utime, 
	};
}

// Attr: [inline]
inline int time__Time_unix_time(time__Time t) {
	return ((int)(t.v_unix));
}

// Attr: [inline]
inline u64 time__Time_unix_time_milli(time__Time t) {
	return t.v_unix * 1000 + ((u64)(t.microsecond / 1000));
}

time__Time time__Time_add_seconds(time__Time t, int seconds) {
	return time__unix(((int)(t.v_unix + ((u64)(seconds)))));
}

time__Time time__Time_add_days(time__Time t, int days) {
	return time__unix(((int)(t.v_unix + ((u64)(((i64)(days)) * 3600 * 24)))));
}

VV_LOCAL_SYMBOL int time__since(time__Time t) {
	return 0;
}

string time__Time_relative(time__Time t) {
	time__Time znow = time__now();
	u64 secs = znow.v_unix - t.v_unix;
	if (secs <= 30) {
		return tos_lit("now");
	}
	if (secs < 60) {
		return tos_lit("1m");
	}
	if (secs < 3600) {
		u64 m = secs / 60;
		if (m == 1) {
			return tos_lit("1 minute ago");
		}
		return _STR("%"PRIu64"\000 minutes ago", 2, m);
	}
	if (secs < 3600 * 24) {
		u64 h = secs / 3600;
		if (h == 1) {
			return tos_lit("1 hour ago");
		}
		return _STR("%"PRIu64"\000 hours ago", 2, h);
	}
	if (secs < 3600 * 24 * 5) {
		u64 d = secs / 3600 / 24;
		if (d == 1) {
			return tos_lit("1 day ago");
		}
		return _STR("%"PRIu64"\000 days ago", 2, d);
	}
	if (secs > 3600 * 24 * 10000) {
		return tos_lit("");
	}
	return time__Time_md(t);
}

string time__Time_relative_short(time__Time t) {
	time__Time znow = time__now();
	u64 secs = znow.v_unix - t.v_unix;
	if (secs <= 30) {
		return tos_lit("now");
	}
	if (secs < 60) {
		return tos_lit("1m");
	}
	if (secs < 3600) {
		return _STR("%"PRIu64"\000m", 2, secs / 60);
	}
	if (secs < 3600 * 24) {
		return _STR("%"PRIu64"\000h", 2, secs / 3600);
	}
	if (secs < 3600 * 24 * 5) {
		return _STR("%"PRIu64"\000d", 2, secs / 3600 / 24);
	}
	if (secs > 3600 * 24 * 10000) {
		return tos_lit("");
	}
	return time__Time_md(t);
}

int time__day_of_week(int y, int m, int d) {
	array_int t = new_array_from_c_array(12, 12, sizeof(int), _MOV((int[12]){
			0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4}));
	int sy = y;
	if (m < 3) {
		sy = sy - 1;
	}
	return (sy + sy / 4 - sy / 100 + sy / 400 + (*(int*)/*ee elem_typ */array_get(t, m - 1)) + d - 1) % 7 + 1;
}

int time__Time_day_of_week(time__Time t) {
	return time__day_of_week(t.year, t.month, t.day);
}

string time__Time_weekday_str(time__Time t) {
	int i = time__Time_day_of_week(t) - 1;
	return string_substr(_const_time__days_string, i * 3, (i + 1) * 3);
}

string time__Time_long_weekday_str(time__Time t) {
	int i = time__Time_day_of_week(t) - 1;
	return (*(string*)/*ee elem_typ */array_get(_const_time__long_days, i));
}

i64 time__ticks() {
	#if defined(_WIN32)
	{
		return GetTickCount();
	}
	#else
	{
	}
	#endif
	return 0;
}

void time__sleep(int seconds) {
	#if defined(_WIN32)
	{
		Sleep(seconds * 1000);
	}
	#else
	{
	}
	#endif
}

void time__sleep_ms(int milliseconds) {
	#if defined(_WIN32)
	{
		Sleep(milliseconds);
	}
	#else
	{
	}
	#endif
}

void time__usleep(int microseconds) {
	#if defined(_WIN32)
	{
		int milliseconds = microseconds / 1000;
		Sleep(milliseconds);
	}
	#else
	{
	}
	#endif
}

bool time__is_leap_year(int year) {
	return (year % 4 == 0) && (year % 100 != 0 || year % 400 == 0);
}

Option_int time__days_in_month(int month, int year) {
	if (month > 12 || month < 1) {
		Option _t253 = v_error(_STR("Invalid month: %"PRId32"", 1, month));
		return *(Option_int*)&_t253;
	}
	int extra = (month == 2 && time__is_leap_year(year) ? (1) : (0));
	int res = (*(int*)/*ee elem_typ */array_get(_const_time__month_days, month - 1)) + extra;
	Option_int _t254;
	opt_ok2(&(int[]) { res }, (OptionBase*)(&_t254), sizeof(int));
	return _t254;
}

string time__Time_str(time__Time t) {
	return time__Time_format_ss(t);
}

VV_LOCAL_SYMBOL time__Time time__convert_ctime(struct tm t, int microsecond) {
	return (time__Time){
		.year = t.tm_year + 1900,
		.month = t.tm_mon + 1,
		.day = t.tm_mday,
		.hour = t.tm_hour,
		.minute = t.tm_min,
		.second = t.tm_sec,
		.microsecond = microsecond,
		.v_unix = ((u64)(time__make_unix_time(t))),
	};
}

// TypeDecl
i64 time__Duration_nanoseconds(time__Duration d) {
	return ((i64)(d));
}

i64 time__Duration_microseconds(time__Duration d) {
	return ((i64)(d)) / 1000;
}

i64 time__Duration_milliseconds(time__Duration d) {
	return ((i64)(d)) / 1000000;
}

f64 time__Duration_seconds(time__Duration d) {
	i64 sec = d / _const_time__second;
	i64 nsec = d % _const_time__second;
	return ((f64)(sec)) + ((f64)(nsec)) / 1e9;
}

f64 time__Duration_minutes(time__Duration d) {
	i64 min = d / _const_time__minute;
	i64 nsec = d % _const_time__minute;
	return ((f64)(min)) + ((f64)(nsec)) / (60 * 1e9);
}

f64 time__Duration_hours(time__Duration d) {
	i64 hr = d / _const_time__hour;
	i64 nsec = d % _const_time__hour;
	return ((f64)(hr)) + ((f64)(nsec)) / (60 * 60 * 1e9);
}

VV_LOCAL_SYMBOL int time__make_unix_time(struct tm t) {
	return ((int)(_mkgmtime(&t)));
}

VV_LOCAL_SYMBOL u64 time__init_win_time_freq() {
	u64 f = ((u64)(0U));
	QueryPerformanceFrequency(&f);
	return f;
}

VV_LOCAL_SYMBOL u64 time__init_win_time_start() {
	u64 s = ((u64)(0U));
	QueryPerformanceCounter(&s);
	return s;
}

u64 time__sys_mono_now() {
	u64 tm = ((u64)(0U));
	QueryPerformanceCounter(&tm);
	return (tm - _const_time__start_time) * 1000000000 / _const_time__freq_time;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL u64 time__vpc_now() {
	u64 tm = ((u64)(0U));
	QueryPerformanceCounter(&tm);
	return tm;
}

VV_LOCAL_SYMBOL int time__local_as_unix_time() {
	time_t t = time(0);
	struct tm* tm = localtime(&t);
	return time__make_unix_time(*tm);
}

VV_LOCAL_SYMBOL time__Time time__to_local_time(time__Time t) {
	time__SystemTime st_utc = (time__SystemTime){
		.year = ((u16)(t.year)),
		.month = ((u16)(t.month)),
		.day_of_week = 0,
		.day = ((u16)(t.day)),
		.hour = ((u16)(t.hour)),
		.minute = ((u16)(t.minute)),
		.second = ((u16)(t.second)),
		.millisecond = 0,
	};
	time__SystemTime st_local = (time__SystemTime){.year = 0,.month = 0,.day_of_week = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.millisecond = 0,};
	SystemTimeToTzSpecificLocalTime(((voidptr)(0)), &st_utc, &st_local);
	time__Time t_local = (time__Time){
		.year = st_local.year,
		.month = st_local.month,
		.day = st_local.day,
		.hour = st_local.hour,
		.minute = st_local.minute,
		.second = st_local.second,
		.microsecond = t.microsecond,
		.v_unix = t.v_unix,
	};
	return t_local;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL time__Time time__win_now() {
	struct _FILETIME ft_utc = (struct _FILETIME){
#ifndef __cplusplus
0
#endif
};
	GetSystemTimeAsFileTime(&ft_utc);
	time__SystemTime st_utc = (time__SystemTime){.year = 0,.month = 0,.day_of_week = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.millisecond = 0,};
	FileTimeToSystemTime(&ft_utc, &st_utc);
	time__SystemTime st_local = (time__SystemTime){.year = 0,.month = 0,.day_of_week = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.millisecond = 0,};
	SystemTimeToTzSpecificLocalTime(((voidptr)(0)), &st_utc, &st_local);
	time__Time t = (time__Time){
		.year = st_local.year,
		.month = st_local.month,
		.day = st_local.day,
		.hour = st_local.hour,
		.minute = st_local.minute,
		.second = st_local.second,
		.microsecond = st_local.millisecond * 1000,
		.v_unix = ((u64)(time__SystemTime_unix_time(st_local))),
	};
	return t;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL time__Time time__win_utc() {
	struct _FILETIME ft_utc = (struct _FILETIME){
#ifndef __cplusplus
0
#endif
};
	GetSystemTimeAsFileTime(&ft_utc);
	time__SystemTime st_utc = (time__SystemTime){.year = 0,.month = 0,.day_of_week = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.millisecond = 0,};
	FileTimeToSystemTime(&ft_utc, &st_utc);
	time__Time t = (time__Time){
		.year = st_utc.year,
		.month = st_utc.month,
		.day = st_utc.day,
		.hour = st_utc.hour,
		.minute = st_utc.minute,
		.second = st_utc.second,
		.microsecond = st_utc.millisecond * 1000,
		.v_unix = ((u64)(time__SystemTime_unix_time(st_utc))),
	};
	return t;
}

int time__SystemTime_unix_time(time__SystemTime st) {
	struct tm tt = (struct tm){
		.tm_year = st.year - 1900,
		.tm_mon = st.month - 1,
		.tm_mday = st.day,
		.tm_hour = st.hour,
		.tm_min = st.minute,
		.tm_sec = st.second,
	};
	return time__make_unix_time(tt);
}

time__Time time__darwin_now() {
	return (time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.microsecond = 0,.v_unix = 0,};
}

time__Time time__linux_now() {
	return (time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.microsecond = 0,.v_unix = 0,};
}

time__Time time__solaris_now() {
	return (time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.microsecond = 0,.v_unix = 0,};
}

time__Time time__darwin_utc() {
	return (time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.microsecond = 0,.v_unix = 0,};
}

time__Time time__linux_utc() {
	return (time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.microsecond = 0,.v_unix = 0,};
}

time__Time time__solaris_utc() {
	return (time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.microsecond = 0,.v_unix = 0,};
}

time__Time time__unix(int abs) {
	int day_offset = abs / _const_time__seconds_per_day;
	if (abs % _const_time__seconds_per_day < 0) {
		day_offset--;
	}
	multi_return_int_int_int mr_470 = time__calculate_date_from_offset(day_offset);
	int year = mr_470.arg0;
	int month = mr_470.arg1;
	int day = mr_470.arg2;
	multi_return_int_int_int mr_524 = time__calculate_time_from_offset(abs % _const_time__seconds_per_day);
	int hr = mr_524.arg0;
	int min = mr_524.arg1;
	int sec = mr_524.arg2;
	return (time__Time){
		.year = year,
		.month = month,
		.day = day,
		.hour = hr,
		.minute = min,
		.second = sec,
		.microsecond = 0,
		.v_unix = ((u64)(abs)),
	};
}

time__Time time__unix2(int abs, int microsecond) {
	int day_offset = abs / _const_time__seconds_per_day;
	if (abs % _const_time__seconds_per_day < 0) {
		day_offset--;
	}
	multi_return_int_int_int mr_1019 = time__calculate_date_from_offset(day_offset);
	int year = mr_1019.arg0;
	int month = mr_1019.arg1;
	int day = mr_1019.arg2;
	multi_return_int_int_int mr_1073 = time__calculate_time_from_offset(abs % _const_time__seconds_per_day);
	int hr = mr_1073.arg0;
	int min = mr_1073.arg1;
	int sec = mr_1073.arg2;
	return (time__Time){
		.year = year,
		.month = month,
		.day = day,
		.hour = hr,
		.minute = min,
		.second = sec,
		.microsecond = microsecond,
		.v_unix = ((u64)(abs)),
	};
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL multi_return_int_int_int time__calculate_date_from_offset(int day_offset_) {
	int day_offset = day_offset_;
	int year = 2001;
	day_offset -= 31 * 365 + 8;
	year += (day_offset / _const_time__days_per_400_years) * 400;
	day_offset %= _const_time__days_per_400_years;
	if (day_offset == _const_time__days_per_100_years * 4) {
		year += 300;
		day_offset -= _const_time__days_per_100_years * 3;
	} else {
		year += (day_offset / _const_time__days_per_100_years) * 100;
		day_offset %= _const_time__days_per_100_years;
	}
	if (day_offset == _const_time__days_per_4_years * 25) {
		year += 96;
		day_offset -= _const_time__days_per_4_years * 24;
	} else {
		year += (day_offset / _const_time__days_per_4_years) * 4;
		day_offset %= _const_time__days_per_4_years;
	}
	if (day_offset == 365 * 4) {
		year += 3;
		day_offset -= 365 * 3;
	} else {
		year += (day_offset / 365);
		day_offset %= 365;
	}
	if (day_offset < 0) {
		year--;
		if (time__is_leap_year(year)) {
			day_offset += 366;
		} else {
			day_offset += 365;
		}
	}
	if (time__is_leap_year(year)) {
		if (day_offset > 31 + 29 - 1) {
			day_offset--;
		} else if (day_offset == 31 + 29 - 1) {
			return (multi_return_int_int_int){.arg0=year, .arg1=2, .arg2=29};
		}
	}
	int estimated_month = day_offset / 31;
	for (;;) {
		if (!(day_offset >= (*(int*)/*ee elem_typ */array_get(_const_time__days_before, estimated_month + 1)))) break;
		estimated_month++;
	}
	for (;;) {
		if (!(day_offset < (*(int*)/*ee elem_typ */array_get(_const_time__days_before, estimated_month)))) break;
		if (estimated_month == 0) {
			break;
		}
		estimated_month--;
	}
	day_offset -= (*(int*)/*ee elem_typ */array_get(_const_time__days_before, estimated_month));
	return (multi_return_int_int_int){.arg0=year, .arg1=estimated_month + 1, .arg2=day_offset + 1};
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL multi_return_int_int_int time__calculate_time_from_offset(int second_offset_) {
	int second_offset = second_offset_;
	if (second_offset < 0) {
		second_offset += _const_time__seconds_per_day;
	}
	int hour = second_offset / _const_time__seconds_per_hour;
	second_offset %= _const_time__seconds_per_hour;
	int min = second_offset / _const_time__seconds_per_minute;
	second_offset %= _const_time__seconds_per_minute;
	return (multi_return_int_int_int){.arg0=hour, .arg1=min, .arg2=second_offset};
}

string v__token__Position_str(v__token__Position pos) {
	return _STR("Position{ line_nr: %"PRId32"\000, pos: %"PRId32"\000, len: %"PRId32"\000 }", 4, pos.line_nr, pos.pos, pos.len);
}

v__token__Position v__token__Position_extend(v__token__Position pos, v__token__Position end) {
	return // assoc
	(v__token__Position){
		.len = end.pos - pos.pos + end.len, 
		.line_nr = pos.line_nr,
		.pos = pos.pos,
	};
}

// Attr: [inline]
inline v__token__Position v__token__Token_position(v__token__Token* tok) {
	return (v__token__Position){.len = tok->len,.line_nr = tok->line_nr - 1,.pos = tok->pos,};
}

VV_LOCAL_SYMBOL map_string_v__token__Kind v__token__build_keys() {
	map_string_v__token__Kind res = new_map_1(sizeof(v__token__Kind));
	for (int t = ((int)(v__token__Kind_keyword_beg)) + 1; t < ((int)(v__token__Kind_keyword_end)); ++t) {
		string key = (*(string*)/*ee elem_typ */array_get(_const_v__token__token_str, t));
		map_set(&res, key, &(v__token__Kind[]) { t });
	}
	return res;
}

VV_LOCAL_SYMBOL array_string v__token__build_token_str() {
	array_string s = __new_array_with_default((_const_v__token__nr_tokens), 0, sizeof(string), &(string[]){tos_lit("")});
	array_set(&s, v__token__Kind_unknown, &(string[]) { tos_lit("unknown") });
	array_set(&s, v__token__Kind_eof, &(string[]) { tos_lit("eof") });
	array_set(&s, v__token__Kind_name, &(string[]) { tos_lit("name") });
	array_set(&s, v__token__Kind_number, &(string[]) { tos_lit("number") });
	array_set(&s, v__token__Kind_string, &(string[]) { tos_lit("string") });
	array_set(&s, v__token__Kind_chartoken, &(string[]) { tos_lit("char") });
	array_set(&s, v__token__Kind_plus, &(string[]) { tos_lit("+") });
	array_set(&s, v__token__Kind_minus, &(string[]) { tos_lit("-") });
	array_set(&s, v__token__Kind_mul, &(string[]) { tos_lit("*") });
	array_set(&s, v__token__Kind_div, &(string[]) { tos_lit("/") });
	array_set(&s, v__token__Kind_mod, &(string[]) { tos_lit("%") });
	array_set(&s, v__token__Kind_xor, &(string[]) { tos_lit("^") });
	array_set(&s, v__token__Kind_bit_not, &(string[]) { tos_lit("~") });
	array_set(&s, v__token__Kind_pipe, &(string[]) { tos_lit("|") });
	array_set(&s, v__token__Kind_hash, &(string[]) { tos_lit("#") });
	array_set(&s, v__token__Kind_amp, &(string[]) { tos_lit("&") });
	array_set(&s, v__token__Kind_inc, &(string[]) { tos_lit("++") });
	array_set(&s, v__token__Kind_dec, &(string[]) { tos_lit("--") });
	array_set(&s, v__token__Kind_and, &(string[]) { tos_lit("&&") });
	array_set(&s, v__token__Kind_logical_or, &(string[]) { tos_lit("||") });
	array_set(&s, v__token__Kind_not, &(string[]) { tos_lit("!") });
	array_set(&s, v__token__Kind_dot, &(string[]) { tos_lit(".") });
	array_set(&s, v__token__Kind_dotdot, &(string[]) { tos_lit("..") });
	array_set(&s, v__token__Kind_ellipsis, &(string[]) { tos_lit("...") });
	array_set(&s, v__token__Kind_comma, &(string[]) { tos_lit(",") });
	array_set(&s, v__token__Kind_not_in, &(string[]) { tos_lit("!in") });
	array_set(&s, v__token__Kind_not_is, &(string[]) { tos_lit("!is") });
	array_set(&s, v__token__Kind_semicolon, &(string[]) { tos_lit(";") });
	array_set(&s, v__token__Kind_colon, &(string[]) { tos_lit(":") });
	array_set(&s, v__token__Kind_arrow, &(string[]) { tos_lit("<-") });
	array_set(&s, v__token__Kind_assign, &(string[]) { tos_lit("=") });
	array_set(&s, v__token__Kind_decl_assign, &(string[]) { tos_lit(":=") });
	array_set(&s, v__token__Kind_plus_assign, &(string[]) { tos_lit("+=") });
	array_set(&s, v__token__Kind_minus_assign, &(string[]) { tos_lit("-=") });
	array_set(&s, v__token__Kind_mult_assign, &(string[]) { tos_lit("*=") });
	array_set(&s, v__token__Kind_div_assign, &(string[]) { tos_lit("/=") });
	array_set(&s, v__token__Kind_xor_assign, &(string[]) { tos_lit("^=") });
	array_set(&s, v__token__Kind_mod_assign, &(string[]) { tos_lit("%=") });
	array_set(&s, v__token__Kind_or_assign, &(string[]) { tos_lit("|=") });
	array_set(&s, v__token__Kind_and_assign, &(string[]) { tos_lit("&=") });
	array_set(&s, v__token__Kind_right_shift_assign, &(string[]) { tos_lit(">>=") });
	array_set(&s, v__token__Kind_left_shift_assign, &(string[]) { tos_lit("<<=") });
	array_set(&s, v__token__Kind_lcbr, &(string[]) { tos_lit("{") });
	array_set(&s, v__token__Kind_rcbr, &(string[]) { tos_lit("}") });
	array_set(&s, v__token__Kind_lpar, &(string[]) { tos_lit("(") });
	array_set(&s, v__token__Kind_rpar, &(string[]) { tos_lit(")") });
	array_set(&s, v__token__Kind_lsbr, &(string[]) { tos_lit("[") });
	array_set(&s, v__token__Kind_rsbr, &(string[]) { tos_lit("]") });
	array_set(&s, v__token__Kind_eq, &(string[]) { tos_lit("==") });
	array_set(&s, v__token__Kind_ne, &(string[]) { tos_lit("!=") });
	array_set(&s, v__token__Kind_gt, &(string[]) { tos_lit(">") });
	array_set(&s, v__token__Kind_lt, &(string[]) { tos_lit("<") });
	array_set(&s, v__token__Kind_ge, &(string[]) { tos_lit(">=") });
	array_set(&s, v__token__Kind_le, &(string[]) { tos_lit("<=") });
	array_set(&s, v__token__Kind_question, &(string[]) { tos_lit("?") });
	array_set(&s, v__token__Kind_left_shift, &(string[]) { tos_lit("<<") });
	array_set(&s, v__token__Kind_right_shift, &(string[]) { tos_lit(">>") });
	array_set(&s, v__token__Kind_comment, &(string[]) { tos_lit("// comment") });
	array_set(&s, v__token__Kind_nl, &(string[]) { tos_lit("NLL") });
	array_set(&s, v__token__Kind_dollar, &(string[]) { tos_lit("$") });
	array_set(&s, v__token__Kind_at, &(string[]) { tos_lit("@") });
	array_set(&s, v__token__Kind_str_dollar, &(string[]) { tos_lit("$2") });
	array_set(&s, v__token__Kind_key_assert, &(string[]) { tos_lit("assert") });
	array_set(&s, v__token__Kind_key_struct, &(string[]) { tos_lit("struct") });
	array_set(&s, v__token__Kind_key_if, &(string[]) { tos_lit("if") });
	array_set(&s, v__token__Kind_key_else, &(string[]) { tos_lit("else") });
	array_set(&s, v__token__Kind_key_asm, &(string[]) { tos_lit("asm") });
	array_set(&s, v__token__Kind_key_return, &(string[]) { tos_lit("return") });
	array_set(&s, v__token__Kind_key_module, &(string[]) { tos_lit("module") });
	array_set(&s, v__token__Kind_key_sizeof, &(string[]) { tos_lit("sizeof") });
	array_set(&s, v__token__Kind_key_likely, &(string[]) { tos_lit("_likely_") });
	array_set(&s, v__token__Kind_key_unlikely, &(string[]) { tos_lit("_unlikely_") });
	array_set(&s, v__token__Kind_key_go, &(string[]) { tos_lit("go") });
	array_set(&s, v__token__Kind_key_goto, &(string[]) { tos_lit("goto") });
	array_set(&s, v__token__Kind_key_const, &(string[]) { tos_lit("const") });
	array_set(&s, v__token__Kind_key_mut, &(string[]) { tos_lit("mut") });
	array_set(&s, v__token__Kind_key_shared, &(string[]) { tos_lit("shared") });
	array_set(&s, v__token__Kind_key_lock, &(string[]) { tos_lit("lock") });
	array_set(&s, v__token__Kind_key_rlock, &(string[]) { tos_lit("rlock") });
	array_set(&s, v__token__Kind_key_type, &(string[]) { tos_lit("type") });
	array_set(&s, v__token__Kind_key_for, &(string[]) { tos_lit("for") });
	array_set(&s, v__token__Kind_key_fn, &(string[]) { tos_lit("fn") });
	array_set(&s, v__token__Kind_key_true, &(string[]) { tos_lit("true") });
	array_set(&s, v__token__Kind_key_false, &(string[]) { tos_lit("false") });
	array_set(&s, v__token__Kind_key_continue, &(string[]) { tos_lit("continue") });
	array_set(&s, v__token__Kind_key_break, &(string[]) { tos_lit("break") });
	array_set(&s, v__token__Kind_key_import, &(string[]) { tos_lit("import") });
	array_set(&s, v__token__Kind_key_embed, &(string[]) { tos_lit("embed") });
	array_set(&s, v__token__Kind_key_unsafe, &(string[]) { tos_lit("unsafe") });
	array_set(&s, v__token__Kind_key_typeof, &(string[]) { tos_lit("typeof") });
	array_set(&s, v__token__Kind_key_enum, &(string[]) { tos_lit("enum") });
	array_set(&s, v__token__Kind_key_interface, &(string[]) { tos_lit("interface") });
	array_set(&s, v__token__Kind_key_pub, &(string[]) { tos_lit("pub") });
	array_set(&s, v__token__Kind_key_in, &(string[]) { tos_lit("in") });
	array_set(&s, v__token__Kind_key_atomic, &(string[]) { tos_lit("atomic") });
	array_set(&s, v__token__Kind_key_orelse, &(string[]) { tos_lit("or") });
	array_set(&s, v__token__Kind_key_global, &(string[]) { tos_lit("__global") });
	array_set(&s, v__token__Kind_key_union, &(string[]) { tos_lit("union") });
	array_set(&s, v__token__Kind_key_static, &(string[]) { tos_lit("static") });
	array_set(&s, v__token__Kind_key_as, &(string[]) { tos_lit("as") });
	array_set(&s, v__token__Kind_key_defer, &(string[]) { tos_lit("defer") });
	array_set(&s, v__token__Kind_key_match, &(string[]) { tos_lit("match") });
	array_set(&s, v__token__Kind_key_select, &(string[]) { tos_lit("select") });
	array_set(&s, v__token__Kind_key_none, &(string[]) { tos_lit("none") });
	array_set(&s, v__token__Kind_key_offsetof, &(string[]) { tos_lit("__offsetof") });
	array_set(&s, v__token__Kind_key_is, &(string[]) { tos_lit("is") });
	return s;
}

v__token__Kind v__token__key_to_token(string key) {
	v__token__Kind a = ((v__token__Kind)((*(v__token__Kind*)map_get(_const_v__token__keywords, key, &(v__token__Kind[]){ 0 }))));
	return a;
}

bool v__token__is_key(string key) {
	return ((int)(v__token__key_to_token(key))) > 0;
}

bool v__token__is_decl(v__token__Kind t) {
	return (t == v__token__Kind_key_enum || t == v__token__Kind_key_interface || t == v__token__Kind_key_fn || t == v__token__Kind_key_struct || t == v__token__Kind_key_type || t == v__token__Kind_key_const || t == v__token__Kind_key_pub || t == v__token__Kind_eof);
}

bool v__token__Kind_is_assign(v__token__Kind t) {
	return _IN(v__token__Kind, t, _const_v__token__assign_tokens);
}

VV_LOCAL_SYMBOL bool array_v__token__Kind_contains(array_v__token__Kind t, v__token__Kind val) {
	// FOR IN array
	array _t255 = t;
	for (int _t256 = 0; _t256 < _t255.len; ++_t256) {
		v__token__Kind tt = ((v__token__Kind*)_t255.data)[_t256];
		if (tt == val) {
			return true;
		}
	}
	return false;
}

string v__token__Kind_str(v__token__Kind t) {
	return (*(string*)/*ee elem_typ */array_get(_const_v__token__token_str, ((int)(t))));
}

string v__token__Token_str(v__token__Token t) {
	return _STR("%.*s\000 \"%.*s\000\"", 3, v__token__Kind_str(t.kind), t.lit);
}

array_v__token__Precedence v__token__build_precedences() {
	array_v__token__Precedence p = __new_array_with_default(((int)(v__token__Kind__end_)), ((int)(v__token__Kind__end_)), sizeof(v__token__Precedence), 0);
	array_set(&p, v__token__Kind_lsbr, &(v__token__Precedence[]) { v__token__Precedence_index });
	array_set(&p, v__token__Kind_dot, &(v__token__Precedence[]) { v__token__Precedence_call });
	array_set(&p, v__token__Kind_inc, &(v__token__Precedence[]) { v__token__Precedence_postfix });
	array_set(&p, v__token__Kind_dec, &(v__token__Precedence[]) { v__token__Precedence_postfix });
	array_set(&p, v__token__Kind_question, &(v__token__Precedence[]) { v__token__Precedence_postfix });
	array_set(&p, v__token__Kind_mul, &(v__token__Precedence[]) { v__token__Precedence_product });
	array_set(&p, v__token__Kind_div, &(v__token__Precedence[]) { v__token__Precedence_product });
	array_set(&p, v__token__Kind_mod, &(v__token__Precedence[]) { v__token__Precedence_product });
	array_set(&p, v__token__Kind_left_shift, &(v__token__Precedence[]) { v__token__Precedence_product });
	array_set(&p, v__token__Kind_right_shift, &(v__token__Precedence[]) { v__token__Precedence_product });
	array_set(&p, v__token__Kind_amp, &(v__token__Precedence[]) { v__token__Precedence_product });
	array_set(&p, v__token__Kind_arrow, &(v__token__Precedence[]) { v__token__Precedence_product });
	array_set(&p, v__token__Kind_plus, &(v__token__Precedence[]) { v__token__Precedence_sum });
	array_set(&p, v__token__Kind_minus, &(v__token__Precedence[]) { v__token__Precedence_sum });
	array_set(&p, v__token__Kind_pipe, &(v__token__Precedence[]) { v__token__Precedence_sum });
	array_set(&p, v__token__Kind_xor, &(v__token__Precedence[]) { v__token__Precedence_sum });
	array_set(&p, v__token__Kind_eq, &(v__token__Precedence[]) { v__token__Precedence_eq });
	array_set(&p, v__token__Kind_ne, &(v__token__Precedence[]) { v__token__Precedence_eq });
	array_set(&p, v__token__Kind_lt, &(v__token__Precedence[]) { v__token__Precedence_eq });
	array_set(&p, v__token__Kind_le, &(v__token__Precedence[]) { v__token__Precedence_eq });
	array_set(&p, v__token__Kind_gt, &(v__token__Precedence[]) { v__token__Precedence_eq });
	array_set(&p, v__token__Kind_ge, &(v__token__Precedence[]) { v__token__Precedence_eq });
	array_set(&p, v__token__Kind_assign, &(v__token__Precedence[]) { v__token__Precedence_assign });
	array_set(&p, v__token__Kind_plus_assign, &(v__token__Precedence[]) { v__token__Precedence_assign });
	array_set(&p, v__token__Kind_minus_assign, &(v__token__Precedence[]) { v__token__Precedence_assign });
	array_set(&p, v__token__Kind_div_assign, &(v__token__Precedence[]) { v__token__Precedence_assign });
	array_set(&p, v__token__Kind_mod_assign, &(v__token__Precedence[]) { v__token__Precedence_assign });
	array_set(&p, v__token__Kind_or_assign, &(v__token__Precedence[]) { v__token__Precedence_assign });
	array_set(&p, v__token__Kind_and_assign, &(v__token__Precedence[]) { v__token__Precedence_assign });
	array_set(&p, v__token__Kind_left_shift_assign, &(v__token__Precedence[]) { v__token__Precedence_assign });
	array_set(&p, v__token__Kind_right_shift_assign, &(v__token__Precedence[]) { v__token__Precedence_assign });
	array_set(&p, v__token__Kind_mult_assign, &(v__token__Precedence[]) { v__token__Precedence_assign });
	array_set(&p, v__token__Kind_xor_assign, &(v__token__Precedence[]) { v__token__Precedence_assign });
	array_set(&p, v__token__Kind_key_in, &(v__token__Precedence[]) { v__token__Precedence_in_as });
	array_set(&p, v__token__Kind_not_in, &(v__token__Precedence[]) { v__token__Precedence_in_as });
	array_set(&p, v__token__Kind_key_as, &(v__token__Precedence[]) { v__token__Precedence_in_as });
	array_set(&p, v__token__Kind_key_is, &(v__token__Precedence[]) { v__token__Precedence_in_as });
	array_set(&p, v__token__Kind_not_is, &(v__token__Precedence[]) { v__token__Precedence_in_as });
	array_set(&p, v__token__Kind_logical_or, &(v__token__Precedence[]) { v__token__Precedence_cond });
	array_set(&p, v__token__Kind_and, &(v__token__Precedence[]) { v__token__Precedence_cond });
	return p;
}

int v__token__Token_precedence(v__token__Token tok) {
	return ((int)((*(v__token__Precedence*)/*ee elem_typ */array_get(_const_v__token__precedences, tok.kind))));
}

bool v__token__Token_is_scalar(v__token__Token tok) {
	return (tok.kind == v__token__Kind_number || tok.kind == v__token__Kind_string);
}

bool v__token__Token_is_unary(v__token__Token tok) {
	return (tok.kind == v__token__Kind_plus || tok.kind == v__token__Kind_minus || tok.kind == v__token__Kind_not || tok.kind == v__token__Kind_bit_not || tok.kind == v__token__Kind_mul || tok.kind == v__token__Kind_amp || tok.kind == v__token__Kind_arrow);
}

bool v__token__Kind_is_relational(v__token__Kind tok) {
	return (tok == v__token__Kind_lt || tok == v__token__Kind_le || tok == v__token__Kind_gt || tok == v__token__Kind_ge || tok == v__token__Kind_eq || tok == v__token__Kind_ne);
}

bool v__token__Kind_is_start_of_type(v__token__Kind k) {
	return (k == v__token__Kind_name || k == v__token__Kind_lpar || k == v__token__Kind_amp || k == v__token__Kind_lsbr || k == v__token__Kind_question);
}

bool v__token__Kind_is_prefix(v__token__Kind kind) {
	return (kind == v__token__Kind_minus || kind == v__token__Kind_amp || kind == v__token__Kind_mul || kind == v__token__Kind_not || kind == v__token__Kind_bit_not);
}

bool v__token__Kind_is_infix(v__token__Kind kind) {
	return (kind == v__token__Kind_plus || kind == v__token__Kind_minus || kind == v__token__Kind_mod || kind == v__token__Kind_mul || kind == v__token__Kind_div || kind == v__token__Kind_eq || kind == v__token__Kind_ne || kind == v__token__Kind_gt || kind == v__token__Kind_lt || kind == v__token__Kind_key_in || kind == v__token__Kind_key_as || kind == v__token__Kind_ge || kind == v__token__Kind_le || kind == v__token__Kind_logical_or || kind == v__token__Kind_xor || kind == v__token__Kind_not_in || kind == v__token__Kind_key_is || kind == v__token__Kind_not_is || kind == v__token__Kind_and || kind == v__token__Kind_dot || kind == v__token__Kind_pipe || kind == v__token__Kind_amp || kind == v__token__Kind_left_shift || kind == v__token__Kind_right_shift || kind == v__token__Kind_arrow);
}

void v__depgraph__OrderedDepMap_set(v__depgraph__OrderedDepMap* o, string name, array_string deps) {
	if (!_IN_MAP(name, o->data)) {
		array_push(&o->keys, _MOV((string[]){ string_clone(name) }));
	}
	map_set(&o->data, name, &(array_string[]) { deps });
}

void v__depgraph__OrderedDepMap_add(v__depgraph__OrderedDepMap* o, string name, array_string deps) {
	array_string d = (*(array_string*)map_get(o->data, name, &(array_string[]){ __new_array(0, 1, sizeof(string)) }));
	// FOR IN array
	array _t258 = deps;
	for (int _t259 = 0; _t259 < _t258.len; ++_t259) {
		string dep = ((string*)_t258.data)[_t259];
		if (!_IN(string, dep, d)) {
			array_push(&d, _MOV((string[]){ string_clone(dep) }));
		} else {
		}
	}
	v__depgraph__OrderedDepMap_set(o, name, d);
}

array_string v__depgraph__OrderedDepMap_get(v__depgraph__OrderedDepMap* o, string name) {
	return (*(array_string*)map_get(o->data, name, &(array_string[]){ __new_array(0, 1, sizeof(string)) }));
}

void v__depgraph__OrderedDepMap_delete(v__depgraph__OrderedDepMap* o, string name) {
	if (!_IN_MAP(name, o->data)) {
		v_panic(_STR("delete: no such key: %.*s", 1, name));
	}
	// FOR IN array
	array _t261 = o->keys;
	for (int i = 0; i < _t261.len; ++i) {
		if (string_eq((*(string*)/*ee elem_typ */array_get(o->keys, i)), name)) {
			array_delete(&o->keys, i);
			break;
		}
	}
	map_delete(&o->data, name);
}

void v__depgraph__OrderedDepMap_apply_diff(v__depgraph__OrderedDepMap* o, string name, array_string deps) {
	array_string diff = __new_array_with_default(0, 0, sizeof(string), 0);
	// FOR IN array
	array _t262 = (*(array_string*)map_get(o->data, name, &(array_string[]){ __new_array(0, 1, sizeof(string)) }));
	for (int _t263 = 0; _t263 < _t262.len; ++_t263) {
		string dep = ((string*)_t262.data)[_t263];
		if (!_IN(string, dep, deps)) {
			array_push(&diff, _MOV((string[]){ string_clone(dep) }));
		}
	}
	v__depgraph__OrderedDepMap_set(o, name, diff);
}

int v__depgraph__OrderedDepMap_size(v__depgraph__OrderedDepMap* o) {
	return o->data.len;
}

v__depgraph__DepGraph* v__depgraph__new_dep_graph() {
	return (v__depgraph__DepGraph*)memdup(&(v__depgraph__DepGraph){.acyclic = true,.nodes = __new_array(0, 1, sizeof(v__depgraph__DepGraphNode)),}, sizeof(v__depgraph__DepGraph));
}

void v__depgraph__DepGraph_add(v__depgraph__DepGraph* graph, string mod, array_string deps) {
	array_push(&graph->nodes, _MOV((v__depgraph__DepGraphNode[]){ (v__depgraph__DepGraphNode){.name = mod,.deps = array_clone(&deps),} }));
}

v__depgraph__DepGraph* v__depgraph__DepGraph_resolve(v__depgraph__DepGraph* graph) {
	v__depgraph__OrderedDepMap node_names = (v__depgraph__OrderedDepMap){.keys = __new_array(0, 1, sizeof(string)),.data = new_map_1(sizeof(array_string)),};
	v__depgraph__OrderedDepMap node_deps = (v__depgraph__OrderedDepMap){.keys = __new_array(0, 1, sizeof(string)),.data = new_map_1(sizeof(array_string)),};
	// FOR IN array
	array _t266 = graph->nodes;
	for (int _t267 = 0; _t267 < _t266.len; ++_t267) {
		v__depgraph__DepGraphNode node = ((v__depgraph__DepGraphNode*)_t266.data)[_t267];
		v__depgraph__OrderedDepMap_add(&node_names, node.name, node.deps);
		v__depgraph__OrderedDepMap_add(&node_deps, node.name, node.deps);
	}
	v__depgraph__DepGraph* resolved = v__depgraph__new_dep_graph();
	for (;;) {
		if (!(v__depgraph__OrderedDepMap_size(&node_deps) != 0)) break;
		array_string ready_set = __new_array_with_default(0, 0, sizeof(string), 0);
		// FOR IN array
		array _t268 = node_deps.keys;
		for (int _t269 = 0; _t269 < _t268.len; ++_t269) {
			string name = ((string*)_t268.data)[_t269];
			array_string deps = (*(array_string*)map_get(node_deps.data, name, &(array_string[]){ __new_array(0, 1, sizeof(string)) }));
			if (deps.len == 0) {
				array_push(&ready_set, _MOV((string[]){ string_clone(name) }));
			}
		}
		if (ready_set.len == 0) {
			v__depgraph__DepGraph* g = v__depgraph__new_dep_graph();
			g->acyclic = false;
			// FOR IN array
			array _t271 = node_deps.keys;
			for (int _t272 = 0; _t272 < _t271.len; ++_t272) {
				string name = ((string*)_t271.data)[_t272];
				v__depgraph__DepGraph_add(g, name, (*(array_string*)map_get(node_names.data, name, &(array_string[]){ __new_array(0, 1, sizeof(string)) })));
			}
			return g;
		}
		// FOR IN array
		array _t273 = ready_set;
		for (int _t274 = 0; _t274 < _t273.len; ++_t274) {
			string name = ((string*)_t273.data)[_t274];
			v__depgraph__OrderedDepMap_delete(&node_deps, name);
			v__depgraph__DepGraph_add(resolved, name, (*(array_string*)map_get(node_names.data, name, &(array_string[]){ __new_array(0, 1, sizeof(string)) })));
		}
		// FOR IN array
		array _t275 = node_deps.keys;
		for (int _t276 = 0; _t276 < _t275.len; ++_t276) {
			string name = ((string*)_t275.data)[_t276];
			v__depgraph__OrderedDepMap_apply_diff(&node_deps, name, ready_set);
		}
	}
	return resolved;
}

v__depgraph__DepGraphNode v__depgraph__DepGraph_last_node(v__depgraph__DepGraph* graph) {
	return (*(v__depgraph__DepGraphNode*)/*ee elem_typ */array_get(graph->nodes, graph->nodes.len - 1));
}

string v__depgraph__DepGraph_display(v__depgraph__DepGraph* graph) {
	string out = tos_lit("\n");
	// FOR IN array
	array _t277 = graph->nodes;
	for (int _t278 = 0; _t278 < _t277.len; ++_t278) {
		v__depgraph__DepGraphNode node = ((v__depgraph__DepGraphNode*)_t277.data)[_t278];
		// FOR IN array
		array _t279 = node.deps;
		for (int _t280 = 0; _t280 < _t279.len; ++_t280) {
			string dep = ((string*)_t279.data)[_t280];
			out = /*f*/string_add(out, _STR(" * %.*s\000 -> %.*s\000\n", 3, node.name, dep));
		}
	}
	return out;
}

string v__depgraph__DepGraph_display_cycles(v__depgraph__DepGraph* graph) {
	map_string_v__depgraph__DepGraphNode node_names = new_map_1(sizeof(v__depgraph__DepGraphNode));
	// FOR IN array
	array _t281 = graph->nodes;
	for (int _t282 = 0; _t282 < _t281.len; ++_t282) {
		v__depgraph__DepGraphNode node = ((v__depgraph__DepGraphNode*)_t281.data)[_t282];
		(*(v__depgraph__DepGraphNode*)map_get_and_set(&node_names, node.name, &(v__depgraph__DepGraphNode[]){ {0} })) = node;
	}
	string out = tos_lit("\n");
	// FOR IN array
	array _t283 = graph->nodes;
	for (int _t284 = 0; _t284 < _t283.len; ++_t284) {
		v__depgraph__DepGraphNode node = ((v__depgraph__DepGraphNode*)_t283.data)[_t284];
		// FOR IN array
		array _t285 = node.deps;
		for (int _t286 = 0; _t286 < _t285.len; ++_t286) {
			string dep = ((string*)_t285.data)[_t286];
			if (!_IN_MAP(dep, node_names)) {
				continue;
			}
			v__depgraph__DepGraphNode dn = (*(v__depgraph__DepGraphNode*)map_get(node_names, dep, &(v__depgraph__DepGraphNode[]){ {0} }));
			if (_IN(string, node.name, dn.deps)) {
				out = /*f*/string_add(out, _STR(" * %.*s\000 -> %.*s\000\n", 3, node.name, dep));
			}
		}
	}
	return out;
}

string flag__Flag_str(flag__Flag f) {
	return string_add(string_add(string_add(string_add(string_add(tos_lit(""), tos_lit("    flag:\n")), _STR("            name: %.*s\000\n", 2, f.name)), _STR("            abbr: %"PRIu8"\000\n", 2, f.abbr)), _STR("            usag: %.*s\000\n", 2, f.usage)), _STR("            desc: %.*s", 1, f.val_desc));
}

string array_flag__Flag_str(array_flag__Flag af) {
	array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	array_push(&res, _MOV((string[]){ string_clone(tos_lit("\n  []Flag = [")) }));
	// FOR IN array
	array _t288 = af;
	for (int _t289 = 0; _t289 < _t288.len; ++_t289) {
		flag__Flag f = ((flag__Flag*)_t288.data)[_t289];
		array_push(&res, _MOV((string[]){ string_clone(flag__Flag_str(f)) }));
	}
	array_push(&res, _MOV((string[]){ string_clone(tos_lit("  ]")) }));
	return array_string_join(res, tos_lit("\n"));
}

flag__FlagParser* flag__new_flag_parser(array_string args) {
	return (flag__FlagParser*)memdup(&(flag__FlagParser){.args = array_clone(&args),.max_free_args = _const_flag__max_args_number,.flags = __new_array(0, 1, sizeof(flag__Flag)),.application_name = (string){.str=(byteptr)""},.application_version = (string){.str=(byteptr)""},.application_description = (string){.str=(byteptr)""},.min_free_args = 0,.args_description = (string){.str=(byteptr)""},}, sizeof(flag__FlagParser));
}

void flag__FlagParser_application(flag__FlagParser* fs, string name) {
	fs->application_name = name;
}

void flag__FlagParser_version(flag__FlagParser* fs, string vers) {
	fs->application_version = vers;
}

void flag__FlagParser_description(flag__FlagParser* fs, string desc) {
	fs->application_description = desc;
}

void flag__FlagParser_skip_executable(flag__FlagParser* fs) {
	array_delete(&fs->args, 0);
}

VV_LOCAL_SYMBOL void flag__FlagParser_add_flag(flag__FlagParser* fs, string name, byte abbr, string usage, string desc) {
	array_push(&fs->flags, _MOV((flag__Flag[]){ (flag__Flag){.name = name,.abbr = abbr,.usage = usage,.val_desc = desc,} }));
}

VV_LOCAL_SYMBOL array_string flag__FlagParser_parse_value(flag__FlagParser* fs, string longhand, byte shorthand) {
	string full = _STR("--%.*s", 1, longhand);
	array_string found_entries = __new_array_with_default(0, 0, sizeof(string), 0);
	array_int to_delete = __new_array_with_default(0, 0, sizeof(int), 0);
	bool should_skip_one = false;
	// FOR IN array
	array _t293 = fs->args;
	for (int i = 0; i < _t293.len; ++i) {
		string arg = ((string*)_t293.data)[i];
		if (should_skip_one) {
			should_skip_one = false;
			continue;
		}
		if (string_eq(arg, tos_lit("--"))) {
			break;
		}
		if (string_at(arg, 0) != '-') {
			continue;
		}
		if ((arg.len == 2 && string_at(arg, 0) == '-' && string_at(arg, 1) == shorthand) || string_eq(arg, full)) {
			if (i + 1 >= fs->args.len) {
				return __new_array_with_default(0, 0, sizeof(string), 0);
			}
			string nextarg = (*(string*)/*ee elem_typ */array_get(fs->args, i + 1));
			if (nextarg.len > 2 && string_eq(string_substr(nextarg, 0, 2), tos_lit("--"))) {
				return __new_array_with_default(0, 0, sizeof(string), 0);
			}
			array_push(&found_entries, _MOV((string[]){ string_clone((*(string*)/*ee elem_typ */array_get(fs->args, i + 1))) }));
			array_push(&to_delete, _MOV((int[]){ i }));
			array_push(&to_delete, _MOV((int[]){ i + 1 }));
			should_skip_one = true;
			continue;
		}
		if (arg.len > full.len + 1 && string_eq(string_substr(arg, 0, full.len + 1), _STR("%.*s\000=", 2, full))) {
			array_push(&found_entries, _MOV((string[]){ string_clone(string_substr(arg, full.len + 1, arg.len)) }));
			array_push(&to_delete, _MOV((int[]){ i }));
			continue;
		}
	}
	// FOR IN array
	array _t299 = to_delete;
	for (int i = 0; i < _t299.len; ++i) {
		int del = ((int*)_t299.data)[i];
		array_delete(&fs->args, del - i);
	}
	return found_entries;
}

VV_LOCAL_SYMBOL Option_string flag__FlagParser_parse_bool_value(flag__FlagParser* fs, string longhand, byte shorthand) {
	string full = _STR("--%.*s", 1, longhand);
	// FOR IN array
	array _t300 = fs->args;
	for (int i = 0; i < _t300.len; ++i) {
		string arg = ((string*)_t300.data)[i];
		if (string_eq(arg, tos_lit("--"))) {
			break;
		}
		if (arg.len == 0) {
			continue;
		}
		if (string_at(arg, 0) != '-') {
			continue;
		}
		if ((arg.len == 2 && string_at(arg, 0) == '-' && string_at(arg, 1) == shorthand) || string_eq(arg, full)) {
			if (fs->args.len > i + 1 && ((string_eq((*(string*)/*ee elem_typ */array_get(fs->args, i + 1)), tos_lit("true")) || string_eq((*(string*)/*ee elem_typ */array_get(fs->args, i + 1)), tos_lit("false"))))) {
				string val = (*(string*)/*ee elem_typ */array_get(fs->args, i + 1));
				array_delete(&fs->args, i + 1);
				array_delete(&fs->args, i);
				Option_string _t301;
				opt_ok2(&(string[]) { val }, (OptionBase*)(&_t301), sizeof(string));
				return _t301;
			} else {
				array_delete(&fs->args, i);
				Option_string _t302;
				opt_ok2(&(string[]) { tos_lit("true") }, (OptionBase*)(&_t302), sizeof(string));
				return _t302;
			}
		}
		if (arg.len > full.len + 1 && string_eq(string_substr(arg, 0, full.len + 1), _STR("%.*s\000=", 2, full))) {
			string val = string_substr(arg, full.len + 1, arg.len);
			array_delete(&fs->args, i);
			Option_string _t303;
			opt_ok2(&(string[]) { val }, (OptionBase*)(&_t303), sizeof(string));
			return _t303;
		}
		if (arg.len > 1 && string_at(arg, 0) == '-' && string_at(arg, 1) != '-' && string_index_byte(arg, shorthand) != -1) {
			Option_string _t304;
			opt_ok2(&(string[]) { tos_lit("true") }, (OptionBase*)(&_t304), sizeof(string));
			return _t304;
		}
	}
	Option _t305 = v_error(_STR("parameter '%.*s\000' not found", 2, longhand));
	return *(Option_string*)&_t305;
}

Option_bool flag__FlagParser_bool_opt(flag__FlagParser* fs, string name, byte abbr, string usage) {
	flag__FlagParser_add_flag(fs, name, abbr, usage, tos_lit("<bool>"));
	Option_string _t306 = flag__FlagParser_parse_bool_value(fs, name, abbr);
	if (!_t306.ok) {
		string err = _t306.v_error;
		int errcode = _t306.ecode;
		Option _t307 = v_error(_STR("parameter '%.*s\000' not provided", 2, name));
		return *(Option_bool*)&_t307;
	}
 	string parsed = *(string*) _t306.data;
	Option_bool _t308;
	opt_ok2(&(bool[]) { string_eq(parsed, tos_lit("true")) }, (OptionBase*)(&_t308), sizeof(bool));
	return _t308;
}

bool flag__FlagParser_bool(flag__FlagParser* fs, string name, byte abbr, bool bdefault, string usage) {
	Option_bool _t309 = flag__FlagParser_bool_opt(fs, name, abbr, usage);
	if (!_t309.ok) {
		string err = _t309.v_error;
		int errcode = _t309.ecode;
		return bdefault;
	}
 	bool value = *(bool*) _t309.data;
	return value;
}

array_int flag__FlagParser_int_multi(flag__FlagParser* fs, string name, byte abbr, string usage) {
	flag__FlagParser_add_flag(fs, name, abbr, usage, tos_lit("<multiple ints>"));
	array_string parsed = flag__FlagParser_parse_value(fs, name, abbr);
	array_int value = __new_array_with_default(0, 0, sizeof(int), 0);
	// FOR IN array
	array _t310 = parsed;
	for (int _t311 = 0; _t311 < _t310.len; ++_t311) {
		string val = ((string*)_t310.data)[_t311];
		array_push(&value, _MOV((int[]){ string_int(val) }));
	}
	return value;
}

Option_int flag__FlagParser_int_opt(flag__FlagParser* fs, string name, byte abbr, string usage) {
	flag__FlagParser_add_flag(fs, name, abbr, usage, tos_lit("<int>"));
	array_string parsed = flag__FlagParser_parse_value(fs, name, abbr);
	if (parsed.len == 0) {
		Option _t313 = v_error(_STR("parameter '%.*s\000' not provided", 2, name));
		return *(Option_int*)&_t313;
	}
	Option_int _t314;
	opt_ok2(&(int[]) { string_int((*(string*)/*ee elem_typ */array_get(parsed, 0))) }, (OptionBase*)(&_t314), sizeof(int));
	return _t314;
}

int flag__FlagParser_int(flag__FlagParser* fs, string name, byte abbr, int idefault, string usage) {
	Option_int _t315 = flag__FlagParser_int_opt(fs, name, abbr, usage);
	if (!_t315.ok) {
		string err = _t315.v_error;
		int errcode = _t315.ecode;
		return idefault;
	}
 	int value = *(int*) _t315.data;
	return value;
}

array_f64 flag__FlagParser_float_multi(flag__FlagParser* fs, string name, byte abbr, string usage) {
	flag__FlagParser_add_flag(fs, name, abbr, usage, tos_lit("<multiple floats>"));
	array_string parsed = flag__FlagParser_parse_value(fs, name, abbr);
	array_f64 value = __new_array_with_default(0, 0, sizeof(f64), 0);
	// FOR IN array
	array _t316 = parsed;
	for (int _t317 = 0; _t317 < _t316.len; ++_t317) {
		string val = ((string*)_t316.data)[_t317];
		array_push(&value, _MOV((f64[]){ string_f64(val) }));
	}
	return value;
}

Option_f64 flag__FlagParser_float_opt(flag__FlagParser* fs, string name, byte abbr, string usage) {
	flag__FlagParser_add_flag(fs, name, abbr, usage, tos_lit("<float>"));
	array_string parsed = flag__FlagParser_parse_value(fs, name, abbr);
	if (parsed.len == 0) {
		Option _t319 = v_error(_STR("parameter '%.*s\000' not provided", 2, name));
		return *(Option_f64*)&_t319;
	}
	Option_f64 _t320;
	opt_ok2(&(f64[]) { string_f64((*(string*)/*ee elem_typ */array_get(parsed, 0))) }, (OptionBase*)(&_t320), sizeof(f64));
	return _t320;
}

f64 flag__FlagParser_float(flag__FlagParser* fs, string name, byte abbr, f64 fdefault, string usage) {
	Option_f64 _t321 = flag__FlagParser_float_opt(fs, name, abbr, usage);
	if (!_t321.ok) {
		string err = _t321.v_error;
		int errcode = _t321.ecode;
		return fdefault;
	}
 	f64 value = *(f64*) _t321.data;
	return value;
}

array_string flag__FlagParser_string_multi(flag__FlagParser* fs, string name, byte abbr, string usage) {
	flag__FlagParser_add_flag(fs, name, abbr, usage, tos_lit("<multiple strings>"));
	return flag__FlagParser_parse_value(fs, name, abbr);
}

Option_string flag__FlagParser_string_opt(flag__FlagParser* fs, string name, byte abbr, string usage) {
	flag__FlagParser_add_flag(fs, name, abbr, usage, tos_lit("<string>"));
	array_string parsed = flag__FlagParser_parse_value(fs, name, abbr);
	if (parsed.len == 0) {
		Option _t322 = v_error(_STR("parameter '%.*s\000' not provided", 2, name));
		return *(Option_string*)&_t322;
	}
	Option_string _t323;
	opt_ok2(&(string[]) { (*(string*)/*ee elem_typ */array_get(parsed, 0)) }, (OptionBase*)(&_t323), sizeof(string));
	return _t323;
}

string flag__FlagParser_string(flag__FlagParser* fs, string name, byte abbr, string sdefault, string usage) {
	Option_string _t324 = flag__FlagParser_string_opt(fs, name, abbr, usage);
	if (!_t324.ok) {
		string err = _t324.v_error;
		int errcode = _t324.ecode;
		return sdefault;
	}
 	string value = *(string*) _t324.data;
	return value;
}

void flag__FlagParser_limit_free_args_to_at_least(flag__FlagParser* fs, int n) {
	if (n > _const_flag__max_args_number) {
		v_panic(_STR("flag.limit_free_args_to_at_least expect n to be smaller than %"PRId32"", 1, _const_flag__max_args_number));
	}
	if (n <= 0) {
		v_panic(tos_lit("flag.limit_free_args_to_at_least expect n to be a positive number"));
	}
	fs->min_free_args = n;
}

void flag__FlagParser_limit_free_args_to_exactly(flag__FlagParser* fs, int n) {
	if (n > _const_flag__max_args_number) {
		v_panic(_STR("flag.limit_free_args_to_exactly expect n to be smaller than %"PRId32"", 1, _const_flag__max_args_number));
	}
	if (n < 0) {
		v_panic(tos_lit("flag.limit_free_args_to_exactly expect n to be a non negative number"));
	}
	fs->min_free_args = n;
	fs->max_free_args = n;
}

void flag__FlagParser_limit_free_args(flag__FlagParser* fs, int min, int max) {
	if (min > max) {
		v_panic(_STR("flag.limit_free_args expect min < max, got %"PRId32"\000 >= %"PRId32"", 2, min, max));
	}
	fs->min_free_args = min;
	fs->max_free_args = max;
}

void flag__FlagParser_arguments_description(flag__FlagParser* fs, string description) {
	fs->args_description = description;
}

string flag__FlagParser_usage(flag__FlagParser fs) {
	bool positive_min_arg = (fs.min_free_args > 0);
	bool positive_max_arg = (fs.max_free_args > 0 && fs.max_free_args != _const_flag__max_args_number);
	bool no_arguments = (fs.min_free_args == 0 && fs.max_free_args == 0);
	string adesc = (fs.args_description.len > 0 ? (fs.args_description) : (tos_lit("[ARGS]")));
	if (no_arguments) {
		adesc = tos_lit("");
	}
	string use = tos_lit("");
	if ((fs.application_version).len != 0) {
		use = /*f*/string_add(use, _STR("%.*s\000 %.*s\000\n", 3, fs.application_name, fs.application_version));
		use = /*f*/string_add(use, _STR("%.*s\000\n", 2, _const_flag__underline));
	}
	use = /*f*/string_add(use, _STR("Usage: %.*s\000 [options] %.*s\000\n", 3, fs.application_name, adesc));
	use = /*f*/string_add(use, tos_lit("\n"));
	if ((fs.application_description).len != 0) {
		use = /*f*/string_add(use, tos_lit("Description:\n"));
		use = /*f*/string_add(use, _STR("%.*s", 1, fs.application_description));
		use = /*f*/string_add(use, tos_lit("\n\n"));
	}
	if (positive_min_arg || positive_max_arg || no_arguments) {
		if (no_arguments) {
			use = /*f*/string_add(use, tos_lit("This application does not expect any arguments\n\n"));
			goto end_of_arguments_handling;
		}
		array_string s = __new_array_with_default(0, 0, sizeof(string), 0);
		if (positive_min_arg) {
			array_push(&s, _MOV((string[]){ string_clone(_STR("at least %"PRId32"", 1, fs.min_free_args)) }));
		}
		if (positive_max_arg) {
			array_push(&s, _MOV((string[]){ string_clone(_STR("at most %"PRId32"", 1, fs.max_free_args)) }));
		}
		if (positive_min_arg && positive_max_arg && fs.min_free_args == fs.max_free_args) {
			s = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_STR("exactly %"PRId32"", 1, fs.min_free_args)}));
		}
		string sargs = array_string_join(s, tos_lit(" and "));
		use = /*f*/string_add(use, _STR("The arguments should be %.*s\000 in number.\n\n", 2, sargs));
	}
	end_of_arguments_handling: {}
	if (fs.flags.len > 0) {
		use = /*f*/string_add(use, tos_lit("Options:\n"));
		// FOR IN array
		array _t327 = fs.flags;
		for (int _t328 = 0; _t328 < _t327.len; ++_t328) {
			flag__Flag f = ((flag__Flag*)_t327.data)[_t328];
			array_string onames = __new_array_with_default(0, 0, sizeof(string), 0);
			if (f.abbr != 0) {
				array_push(&onames, _MOV((string[]){ string_clone(_STR("-%.*s", 1, byte_str(f.abbr))) }));
			}
			if ((f.name).len != 0) {
				if (!string_contains(f.val_desc, tos_lit("<bool>"))) {
					array_push(&onames, _MOV((string[]){ string_clone(_STR("--%.*s\000 %.*s", 2, f.name, f.val_desc)) }));
				} else {
					array_push(&onames, _MOV((string[]){ string_clone(_STR("--%.*s", 1, f.name)) }));
				}
			}
			string option_names = string_add(tos_lit("  "), array_string_join(onames, tos_lit(", ")));
			string xspace = tos_lit("");
			if (option_names.len > _const_flag__space.len - 2) {
				xspace = _STR("\n%.*s", 1, _const_flag__space);
			} else {
				xspace = string_substr(_const_flag__space, option_names.len, _const_flag__space.len);
			}
			use = /*f*/string_add(use, _STR("%.*s\000%.*s\000%.*s\000\n", 4, option_names, xspace, f.usage));
		}
	}
	return use;
}

Option_array_string flag__FlagParser_finalize(flag__FlagParser fs) {
	// FOR IN array
	array _t332 = fs.args;
	for (int _t333 = 0; _t333 < _t332.len; ++_t333) {
		string a = ((string*)_t332.data)[_t333];
		if (a.len >= 2 && string_eq(string_substr(a, 0, 2), tos_lit("--"))) {
			Option _t334 = v_error(_STR("Unknown argument \'%.*s\000\'", 2, string_substr(a, 2, a.len)));
			return *(Option_array_string*)&_t334;
		}
	}
	if (fs.args.len < fs.min_free_args && fs.min_free_args > 0) {
		Option _t335 = v_error(_STR("Expected at least %"PRId32"\000 arguments, but given %"PRId32"", 2, fs.min_free_args, fs.args.len));
		return *(Option_array_string*)&_t335;
	}
	if (fs.args.len > fs.max_free_args && fs.max_free_args > 0) {
		Option _t336 = v_error(_STR("Expected at most %"PRId32"\000 arguments, but given %"PRId32"", 2, fs.max_free_args, fs.args.len));
		return *(Option_array_string*)&_t336;
	}
	if (fs.args.len > 0 && fs.max_free_args == 0 && fs.min_free_args == 0) {
		Option _t337 = v_error(_STR("Expected no arguments, but given %"PRId32"", 1, fs.args.len));
		return *(Option_array_string*)&_t337;
	}
	Option_array_string _t338;
	opt_ok2(&(array_string[]) { fs.args }, (OptionBase*)(&_t338), sizeof(array_string));
	return _t338;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL bool semver__version_satisfies(semver__Version ver, string input) {
	Option_semver__Range _t339 = semver__parse_range(input);
	if (!_t339.ok) {
		string err = _t339.v_error;
		int errcode = _t339.ecode;
		return false;
	}
 	semver__Range range = *(semver__Range*) _t339.data;
	return semver__Range_satisfies(range, ver);
}

VV_LOCAL_SYMBOL bool semver__compare_eq(semver__Version v1, semver__Version v2) {
	return v1.major == v2.major && v1.minor == v2.minor && v1.patch == v2.patch && string_eq(v1.prerelease, v2.prerelease);
}

VV_LOCAL_SYMBOL bool semver__compare_gt(semver__Version v1, semver__Version v2) {
	if (v1.major < v2.major) {
		return false;
	}
	if (v1.major > v2.major) {
		return true;
	}
	if (v1.minor < v2.minor) {
		return false;
	}
	if (v1.minor > v2.minor) {
		return true;
	}
	return v1.patch > v2.patch;
}

VV_LOCAL_SYMBOL bool semver__compare_lt(semver__Version v1, semver__Version v2) {
	if (v1.major > v2.major) {
		return false;
	}
	if (v1.major < v2.major) {
		return true;
	}
	if (v1.minor > v2.minor) {
		return false;
	}
	if (v1.minor < v2.minor) {
		return true;
	}
	return v1.patch < v2.patch;
}

VV_LOCAL_SYMBOL bool semver__compare_ge(semver__Version v1, semver__Version v2) {
	if (semver__compare_eq(v1, v2)) {
		return true;
	}
	return semver__compare_gt(v1, v2);
}

VV_LOCAL_SYMBOL bool semver__compare_le(semver__Version v1, semver__Version v2) {
	if (semver__compare_eq(v1, v2)) {
		return true;
	}
	return semver__compare_lt(v1, v2);
}

VV_LOCAL_SYMBOL semver__RawVersion semver__parse(string input) {
	string raw_version = input;
	string prerelease = tos_lit("");
	string metadata = tos_lit("");
	Option_int _t340 = string_last_index(raw_version, tos_lit("+"));
	if (!_t340.ok) {
		string err = _t340.v_error;
		int errcode = _t340.ecode;
		*(int*) _t340.data = -1;
	}
 	int plus_idx = *(int*) _t340.data;
	if (plus_idx > 0) {
		metadata = string_substr(raw_version, (plus_idx + 1), raw_version.len);
		raw_version = string_substr(raw_version, 0, plus_idx);
	}
	Option_int _t341 = string_index(raw_version, tos_lit("-"));
	if (!_t341.ok) {
		string err = _t341.v_error;
		int errcode = _t341.ecode;
		*(int*) _t341.data = -1;
	}
 	int hyphen_idx = *(int*) _t341.data;
	if (hyphen_idx > 0) {
		prerelease = string_substr(raw_version, (hyphen_idx + 1), raw_version.len);
		raw_version = string_substr(raw_version, 0, hyphen_idx);
	}
	array_string raw_ints = string_split(raw_version, tos_lit("."));
	return (semver__RawVersion){.prerelease = prerelease,.metadata = metadata,.raw_ints = raw_ints,};
}

VV_LOCAL_SYMBOL bool semver__RawVersion_is_valid(semver__RawVersion ver) {
	if (ver.raw_ints.len != 3) {
		return false;
	}
	return semver__is_valid_number((*(string*)/*ee elem_typ */array_get(ver.raw_ints, _const_semver__ver_major))) && semver__is_valid_number((*(string*)/*ee elem_typ */array_get(ver.raw_ints, _const_semver__ver_minor))) && semver__is_valid_number((*(string*)/*ee elem_typ */array_get(ver.raw_ints, _const_semver__ver_patch))) && semver__is_valid_string(ver.prerelease) && semver__is_valid_string(ver.metadata);
}

VV_LOCAL_SYMBOL bool semver__RawVersion_is_missing(semver__RawVersion ver, int typ) {
	return typ >= ver.raw_ints.len - 1;
}

VV_LOCAL_SYMBOL Option_semver__Version semver__RawVersion_coerce(semver__RawVersion raw_ver) {
	semver__RawVersion ver = semver__RawVersion_complete(raw_ver);
	if (!semver__is_valid_number((*(string*)/*ee elem_typ */array_get(ver.raw_ints, _const_semver__ver_major)))) {
		Option _t342 = v_error(_STR("Invalid major version: %.*s\000[ver_major]", 2, array_string_str(ver.raw_ints)));
		return *(Option_semver__Version*)&_t342;
	}
	Option_semver__Version _t343;
	opt_ok2(&(semver__Version[]) { semver__RawVersion_to_version(ver) }, (OptionBase*)(&_t343), sizeof(semver__Version));
	return _t343;
}

VV_LOCAL_SYMBOL semver__RawVersion semver__RawVersion_complete(semver__RawVersion raw_ver) {
	array_string raw_ints = raw_ver.raw_ints;
	for (;;) {
		if (!(raw_ints.len < 3)) break;
		array_push(&raw_ints, _MOV((string[]){ string_clone(tos_lit("0")) }));
	}
	return (semver__RawVersion){.prerelease = raw_ver.prerelease,.metadata = raw_ver.metadata,.raw_ints = raw_ints,};
}

VV_LOCAL_SYMBOL Option_semver__Version semver__RawVersion_validate(semver__RawVersion raw_ver) {
	if (!semver__RawVersion_is_valid(raw_ver)) {
		Option _t345 = opt_none();
		return *(Option_semver__Version*)&_t345;
	}
	Option_semver__Version _t346;
	opt_ok2(&(semver__Version[]) { semver__RawVersion_to_version(raw_ver) }, (OptionBase*)(&_t346), sizeof(semver__Version));
	return _t346;
}

VV_LOCAL_SYMBOL semver__Version semver__RawVersion_to_version(semver__RawVersion raw_ver) {
	return (semver__Version){.major = string_int((*(string*)/*ee elem_typ */array_get(raw_ver.raw_ints, _const_semver__ver_major))),.minor = string_int((*(string*)/*ee elem_typ */array_get(raw_ver.raw_ints, _const_semver__ver_minor))),.patch = string_int((*(string*)/*ee elem_typ */array_get(raw_ver.raw_ints, _const_semver__ver_patch))),.prerelease = raw_ver.prerelease,.metadata = raw_ver.metadata,};
}

VV_LOCAL_SYMBOL bool semver__Range_satisfies(semver__Range r, semver__Version ver) {
	bool final_result = false;
	// FOR IN array
	array _t347 = r.comparator_sets;
	for (int _t348 = 0; _t348 < _t347.len; ++_t348) {
		semver__ComparatorSet set = ((semver__ComparatorSet*)_t347.data)[_t348];
		final_result = final_result || semver__ComparatorSet_satisfies(set, ver);
	}
	return final_result;
}

VV_LOCAL_SYMBOL bool semver__ComparatorSet_satisfies(semver__ComparatorSet set, semver__Version ver) {
	// FOR IN array
	array _t349 = set.comparators;
	for (int _t350 = 0; _t350 < _t349.len; ++_t350) {
		semver__Comparator comp = ((semver__Comparator*)_t349.data)[_t350];
		if (!semver__Comparator_satisfies(comp, ver)) {
			return false;
		}
	}
	return true;
}

VV_LOCAL_SYMBOL bool semver__Comparator_satisfies(semver__Comparator c, semver__Version ver) {
	semver__Operator _t351 = c.op;
		return ((_t351 == semver__Operator_gt) ? (semver__Version_gt(ver, c.ver)) : (_t351 == semver__Operator_lt) ? (semver__Version_lt(ver, c.ver)) : (_t351 == semver__Operator_ge) ? (semver__Version_ge(ver, c.ver)) : (_t351 == semver__Operator_le) ? (semver__Version_le(ver, c.ver)) : (semver__Version_eq(ver, c.ver)));
}

VV_LOCAL_SYMBOL Option_semver__Range semver__parse_range(string input) {
	array_string raw_comparator_sets = string_split(input, _const_semver__comparator_set_sep);
	array_semver__ComparatorSet comparator_sets = __new_array_with_default(0, 0, sizeof(semver__ComparatorSet), 0);
	// FOR IN array
	array _t352 = raw_comparator_sets;
	for (int _t353 = 0; _t353 < _t352.len; ++_t353) {
		string raw_comp_set = ((string*)_t352.data)[_t353];
		if (semver__can_expand(raw_comp_set)) {
			Option_semver__ComparatorSet _t354 = semver__expand_comparator_set(raw_comp_set);
			if (!_t354.ok) {
				string err = _t354.v_error;
				int errcode = _t354.ecode;
				Option _t355 = v_error(err);
				return *(Option_semver__Range*)&_t355;
			}
 			semver__ComparatorSet s = *(semver__ComparatorSet*) _t354.data;
			array_push(&comparator_sets, _MOV((semver__ComparatorSet[]){ s }));
		} else {
			Option_semver__ComparatorSet _t357 = semver__parse_comparator_set(raw_comp_set);
			if (!_t357.ok) {
				string err = _t357.v_error;
				int errcode = _t357.ecode;
				Option _t358 = v_error(err);
				return *(Option_semver__Range*)&_t358;
			}
 			semver__ComparatorSet s = *(semver__ComparatorSet*) _t357.data;
			array_push(&comparator_sets, _MOV((semver__ComparatorSet[]){ s }));
		}
	}
	Option_semver__Range _t360;
	opt_ok2(&(semver__Range[]) { (semver__Range){.comparator_sets = comparator_sets,} }, (OptionBase*)(&_t360), sizeof(semver__Range));
	return _t360;
}

VV_LOCAL_SYMBOL Option_semver__ComparatorSet semver__parse_comparator_set(string input) {
	array_string raw_comparators = string_split(input, _const_semver__comparator_sep);
	if (raw_comparators.len > 2) {
		Option _t361 = v_error(tos_lit("Invalid format of comparator set"));
		return *(Option_semver__ComparatorSet*)&_t361;
	}
	array_semver__Comparator comparators = __new_array_with_default(0, 0, sizeof(semver__Comparator), 0);
	// FOR IN array
	array _t362 = raw_comparators;
	for (int _t363 = 0; _t363 < _t362.len; ++_t363) {
		string raw_comp = ((string*)_t362.data)[_t363];
		Option_semver__Comparator _t364 = semver__parse_comparator(raw_comp);
		if (!_t364.ok) {
			string err = _t364.v_error;
			int errcode = _t364.ecode;
			Option _t365 = v_error(_STR("Invalid comparator: %.*s", 1, raw_comp));
			return *(Option_semver__ComparatorSet*)&_t365;
		}
 		semver__Comparator c = *(semver__Comparator*) _t364.data;
		array_push(&comparators, _MOV((semver__Comparator[]){ c }));
	}
	Option_semver__ComparatorSet _t367;
	opt_ok2(&(semver__ComparatorSet[]) { (semver__ComparatorSet){.comparators = comparators,} }, (OptionBase*)(&_t367), sizeof(semver__ComparatorSet));
	return _t367;
}

VV_LOCAL_SYMBOL Option_semver__Comparator semver__parse_comparator(string input) {
	semver__Operator op = semver__Operator_eq;
	string raw_version = tos_lit("");
	if (string_starts_with(input, tos_lit(">="))) {
		op = semver__Operator_ge;
		raw_version = string_substr(input, 2, input.len);
	} else if (string_starts_with(input, tos_lit("<="))) {
		op = semver__Operator_le;
		raw_version = string_substr(input, 2, input.len);
	} else if (string_starts_with(input, tos_lit(">"))) {
		op = semver__Operator_gt;
		raw_version = string_substr(input, 1, input.len);
	} else if (string_starts_with(input, tos_lit("<"))) {
		op = semver__Operator_lt;
		raw_version = string_substr(input, 1, input.len);
	} else if (string_starts_with(input, tos_lit("="))) {
		raw_version = string_substr(input, 1, input.len);
	} else {
		raw_version = input;
	}
	Option_semver__Version _t368 = semver__coerce_version(raw_version);
	if (!_t368.ok) {
		string err = _t368.v_error;
		int errcode = _t368.ecode;
		Option _t369 = opt_none();
		return *(Option_semver__Comparator*)&_t369;
	}
 	semver__Version version = *(semver__Version*) _t368.data;
	Option_semver__Comparator _t370;
	opt_ok2(&(semver__Comparator[]) { (semver__Comparator){.ver = version,.op = op,} }, (OptionBase*)(&_t370), sizeof(semver__Comparator));
	return _t370;
}

VV_LOCAL_SYMBOL Option_semver__Version semver__parse_xrange(string input) {
	semver__RawVersion raw_ver = semver__RawVersion_complete(semver__parse(input));
	// FOR IN array
	array _t371 = _const_semver__versions;
	for (int _t372 = 0; _t372 < _t371.len; ++_t372) {
		int typ = ((int*)_t371.data)[_t372];
		if (string_index_any((*(string*)/*ee elem_typ */array_get(raw_ver.raw_ints, typ)), _const_semver__x_range_symbols) == -1) {
			continue;
		}
		int _t373 = typ;
		if (_t373 == _const_semver__ver_major) {
			(*(string*)/*ee elem_typ */array_get(raw_ver.raw_ints, _const_semver__ver_major)) = tos_lit("0");
			(*(string*)/*ee elem_typ */array_get(raw_ver.raw_ints, _const_semver__ver_minor)) = tos_lit("0");
			(*(string*)/*ee elem_typ */array_get(raw_ver.raw_ints, _const_semver__ver_patch)) = tos_lit("0");
		} else if (_t373 == _const_semver__ver_minor) {
			(*(string*)/*ee elem_typ */array_get(raw_ver.raw_ints, _const_semver__ver_minor)) = tos_lit("0");
			(*(string*)/*ee elem_typ */array_get(raw_ver.raw_ints, _const_semver__ver_patch)) = tos_lit("0");
		} else if (_t373 == _const_semver__ver_patch) {
			(*(string*)/*ee elem_typ */array_get(raw_ver.raw_ints, _const_semver__ver_patch)) = tos_lit("0");
		} else {
		};
	}
	if (!semver__RawVersion_is_valid(raw_ver)) {
		Option _t374 = opt_none();
		return *(Option_semver__Version*)&_t374;
	}
	Option_semver__Version _t375;
	opt_ok2(&(semver__Version[]) { semver__RawVersion_to_version(raw_ver) }, (OptionBase*)(&_t375), sizeof(semver__Version));
	return _t375;
}

VV_LOCAL_SYMBOL bool semver__can_expand(string input) {
	return string_at(input, 0) == '~' || string_at(input, 0) == '^' || string_contains(input, _const_semver__hyphen_range_sep) || string_index_any(input, _const_semver__x_range_symbols) > -1;
}

VV_LOCAL_SYMBOL Option_semver__ComparatorSet semver__expand_comparator_set(string input) {
	byte _t376 = string_at(input, 0);
	if (_t376 == '~') {
		return semver__expand_tilda(string_substr(input, 1, input.len));
	} else if (_t376 == '^') {
		return semver__expand_caret(string_substr(input, 1, input.len));
	} else {
	};
	if (string_contains(input, _const_semver__hyphen_range_sep)) {
		return semver__expand_hyphen(input);
	}
	return semver__expand_xrange(input);
}

VV_LOCAL_SYMBOL Option_semver__ComparatorSet semver__expand_tilda(string raw_version) {
	Option_semver__Version _t377 = semver__coerce_version(raw_version);
	if (!_t377.ok) {
		string err = _t377.v_error;
		int errcode = _t377.ecode;
		Option _t378 = opt_none();
		return *(Option_semver__ComparatorSet*)&_t378;
	}
 	semver__Version min_ver = *(semver__Version*) _t377.data;
	semver__Version max_ver = min_ver;
	if (min_ver.minor == 0 && min_ver.patch == 0) {
		max_ver = semver__Version_increment(min_ver, semver__Increment_major);
	} else {
		max_ver = semver__Version_increment(min_ver, semver__Increment_minor);
	}
	Option_semver__ComparatorSet _t379;
	opt_ok2(&(semver__ComparatorSet[]) { semver__make_comparator_set_ge_lt(min_ver, max_ver) }, (OptionBase*)(&_t379), sizeof(semver__ComparatorSet));
	return _t379;
}

VV_LOCAL_SYMBOL Option_semver__ComparatorSet semver__expand_caret(string raw_version) {
	Option_semver__Version _t380 = semver__coerce_version(raw_version);
	if (!_t380.ok) {
		string err = _t380.v_error;
		int errcode = _t380.ecode;
		Option _t381 = opt_none();
		return *(Option_semver__ComparatorSet*)&_t381;
	}
 	semver__Version min_ver = *(semver__Version*) _t380.data;
	semver__Version max_ver = min_ver;
	if (min_ver.major == 0) {
		max_ver = semver__Version_increment(min_ver, semver__Increment_minor);
	} else {
		max_ver = semver__Version_increment(min_ver, semver__Increment_major);
	}
	Option_semver__ComparatorSet _t382;
	opt_ok2(&(semver__ComparatorSet[]) { semver__make_comparator_set_ge_lt(min_ver, max_ver) }, (OptionBase*)(&_t382), sizeof(semver__ComparatorSet));
	return _t382;
}

VV_LOCAL_SYMBOL Option_semver__ComparatorSet semver__expand_hyphen(string raw_range) {
	array_string raw_versions = string_split(raw_range, _const_semver__hyphen_range_sep);
	if (raw_versions.len != 2) {
		Option _t383 = opt_none();
		return *(Option_semver__ComparatorSet*)&_t383;
	}
	Option_semver__Version _t384 = semver__coerce_version((*(string*)/*ee elem_typ */array_get(raw_versions, 0)));
	if (!_t384.ok) {
		string err = _t384.v_error;
		int errcode = _t384.ecode;
		Option _t385 = opt_none();
		return *(Option_semver__ComparatorSet*)&_t385;
	}
 	semver__Version min_ver = *(semver__Version*) _t384.data;
	semver__RawVersion raw_max_ver = semver__parse((*(string*)/*ee elem_typ */array_get(raw_versions, 1)));
	if (semver__RawVersion_is_missing(raw_max_ver, _const_semver__ver_major)) {
		Option _t386 = opt_none();
		return *(Option_semver__ComparatorSet*)&_t386;
	}
	Option_semver__Version _t387 = semver__RawVersion_coerce(raw_max_ver);
	if (!_t387.ok) {
		string err = _t387.v_error;
		int errcode = _t387.ecode;
		Option _t388 = opt_none();
		return *(Option_semver__ComparatorSet*)&_t388;
	}
 	semver__Version max_ver = *(semver__Version*) _t387.data;
	if (semver__RawVersion_is_missing(raw_max_ver, _const_semver__ver_minor)) {
		max_ver = semver__Version_increment(max_ver, semver__Increment_minor);
		Option_semver__ComparatorSet _t389;
		opt_ok2(&(semver__ComparatorSet[]) { semver__make_comparator_set_ge_lt(min_ver, max_ver) }, (OptionBase*)(&_t389), sizeof(semver__ComparatorSet));
		return _t389;
	}
	Option_semver__ComparatorSet _t390;
	opt_ok2(&(semver__ComparatorSet[]) { semver__make_comparator_set_ge_le(min_ver, max_ver) }, (OptionBase*)(&_t390), sizeof(semver__ComparatorSet));
	return _t390;
}

VV_LOCAL_SYMBOL Option_semver__ComparatorSet semver__expand_xrange(string raw_range) {
	Option_semver__Version _t391 = semver__parse_xrange(raw_range);
	if (!_t391.ok) {
		string err = _t391.v_error;
		int errcode = _t391.ecode;
		Option _t392 = opt_none();
		return *(Option_semver__ComparatorSet*)&_t392;
	}
 	semver__Version min_ver = *(semver__Version*) _t391.data;
	if (min_ver.major == 0) {
		array_semver__Comparator comparators = new_array_from_c_array(1, 1, sizeof(semver__Comparator), _MOV((semver__Comparator[1]){(semver__Comparator){.ver = min_ver,.op = semver__Operator_ge,}}));
		Option_semver__ComparatorSet _t393;
		opt_ok2(&(semver__ComparatorSet[]) { (semver__ComparatorSet){.comparators = comparators,} }, (OptionBase*)(&_t393), sizeof(semver__ComparatorSet));
		return _t393;
	}
	semver__Version max_ver = min_ver;
	if (min_ver.minor == 0) {
		max_ver = semver__Version_increment(min_ver, semver__Increment_major);
	} else {
		max_ver = semver__Version_increment(min_ver, semver__Increment_minor);
	}
	Option_semver__ComparatorSet _t394;
	opt_ok2(&(semver__ComparatorSet[]) { semver__make_comparator_set_ge_lt(min_ver, max_ver) }, (OptionBase*)(&_t394), sizeof(semver__ComparatorSet));
	return _t394;
}

VV_LOCAL_SYMBOL semver__ComparatorSet semver__make_comparator_set_ge_lt(semver__Version min, semver__Version max) {
	array_semver__Comparator comparators = new_array_from_c_array(2, 2, sizeof(semver__Comparator), _MOV((semver__Comparator[2]){(semver__Comparator){.ver = min,.op = semver__Operator_ge,}, (semver__Comparator){.ver = max,.op = semver__Operator_lt,}}));
	return (semver__ComparatorSet){.comparators = comparators,};
}

VV_LOCAL_SYMBOL semver__ComparatorSet semver__make_comparator_set_ge_le(semver__Version min, semver__Version max) {
	array_semver__Comparator comparators = new_array_from_c_array(2, 2, sizeof(semver__Comparator), _MOV((semver__Comparator[2]){(semver__Comparator){.ver = min,.op = semver__Operator_ge,}, (semver__Comparator){.ver = max,.op = semver__Operator_le,}}));
	return (semver__ComparatorSet){.comparators = comparators,};
}

Option_semver__Version semver__from(string input) {
	if (input.len == 0) {
		Option _t395 = v_error(tos_lit("Empty input"));
		return *(Option_semver__Version*)&_t395;
	}
	semver__RawVersion raw_version = semver__parse(input);
	Option_semver__Version _t396 = semver__RawVersion_validate(raw_version);
	if (!_t396.ok) {
		string err = _t396.v_error;
		int errcode = _t396.ecode;
		Option _t397 = v_error(tos_lit("Invalid version format"));
		return *(Option_semver__Version*)&_t397;
	}
 	semver__Version version = *(semver__Version*) _t396.data;
	Option_semver__Version _t398;
	opt_ok2(&(semver__Version[]) { version }, (OptionBase*)(&_t398), sizeof(semver__Version));
	return _t398;
}

semver__Version semver__build(int major, int minor, int patch) {
	return (semver__Version){.major = major,.minor = minor,.patch = patch,.prerelease = tos_lit(""),.metadata = tos_lit(""),};
}

semver__Version semver__Version_increment(semver__Version ver, semver__Increment typ) {
	return semver__increment_version(ver, typ);
}

bool semver__Version_satisfies(semver__Version ver, string input) {
	return semver__version_satisfies(ver, input);
}

bool semver__Version_eq(semver__Version v1, semver__Version v2) {
	return semver__compare_eq(v1, v2);
}

bool semver__Version_gt(semver__Version v1, semver__Version v2) {
	return semver__compare_gt(v1, v2);
}

bool semver__Version_lt(semver__Version v1, semver__Version v2) {
	return semver__compare_lt(v1, v2);
}

bool semver__Version_ge(semver__Version v1, semver__Version v2) {
	return semver__compare_ge(v1, v2);
}

bool semver__Version_le(semver__Version v1, semver__Version v2) {
	return semver__compare_le(v1, v2);
}

Option_semver__Version semver__coerce(string input) {
	Option_semver__Version _t399 = semver__coerce_version(input);
	if (!_t399.ok) {
		string err = _t399.v_error;
		int errcode = _t399.ecode;
		Option _t400 = v_error(_STR("Invalid version: %.*s", 1, input));
		return *(Option_semver__Version*)&_t400;
	}
 	semver__Version ver = *(semver__Version*) _t399.data;
	Option_semver__Version _t401;
	opt_ok2(&(semver__Version[]) { ver }, (OptionBase*)(&_t401), sizeof(semver__Version));
	return _t401;
}

bool semver__is_valid(string input) {
	return semver__is_version_valid(input);
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL bool semver__is_version_valid(string input) {
	semver__RawVersion raw_ver = semver__parse(input);
	return semver__RawVersion_is_valid(raw_ver);
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL Option_semver__Version semver__coerce_version(string input) {
	semver__RawVersion raw_ver = semver__parse(input);
	Option_semver__Version _t402 = semver__RawVersion_coerce(raw_ver);
	if (!_t402.ok) {
		string err = _t402.v_error;
		int errcode = _t402.ecode;
		Option _t403 = v_error(_STR("Invalid version: %.*s", 1, input));
		return *(Option_semver__Version*)&_t403;
	}
 	semver__Version ver = *(semver__Version*) _t402.data;
	Option_semver__Version _t404;
	opt_ok2(&(semver__Version[]) { ver }, (OptionBase*)(&_t404), sizeof(semver__Version));
	return _t404;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL semver__Version semver__increment_version(semver__Version ver, semver__Increment typ) {
	int major = ver.major;
	int minor = ver.minor;
	int patch = ver.patch;
	semver__Increment _t405 = typ;
	if (_t405 == semver__Increment_major) {
		major++;
		minor = 0;
		patch = 0;
	} else if (_t405 == semver__Increment_minor) {
		minor++;
		patch = 0;
	} else if (_t405 == semver__Increment_patch) {
		patch++;
	};
	return (semver__Version){.major = major,.minor = minor,.patch = patch,.prerelease = ver.prerelease,.metadata = ver.metadata,};
}

VV_LOCAL_SYMBOL bool semver__is_valid_string(string input) {
	for (int _t406 = 0; _t406 < input.len; ++_t406) {
		byte c = input.str[_t406];
		if (!(byte_is_letter(c) || byte_is_digit(c) || c == '.' || c == '-')) {
			return false;
		}
	}
	return true;
}

VV_LOCAL_SYMBOL bool semver__is_valid_number(string input) {
	for (int _t407 = 0; _t407 < input.len; ++_t407) {
		byte c = input.str[_t407];
		if (!byte_is_digit(c)) {
			return false;
		}
	}
	return true;
}

v__vcache__CacheManager v__vcache__new_cache_manager(array_string opts) {
	string vcache_basepath = os__getenv(tos_lit("VCACHE"));
	if ((vcache_basepath).len == 0) {
		vcache_basepath = os__join_path(os__vmodules_dir(), (varg_string){.len=1,.args={tos_lit("cache")}});
	}
	if (!os__is_dir(vcache_basepath)) {
		os__mkdir_all(vcache_basepath);
		string readme_content = string_strip_margin(tos_lit("This folder contains cached build artifacts from the V build system.\n		|You can safely delete it, if it is getting too large.\n		|It will be recreated the next time you compile something with V.\n		|You can change its location with the VCACHE environment variable.\n		"));
		os__write_file(os__join_path(vcache_basepath, (varg_string){.len=1,.args={tos_lit("README.md")}}), readme_content);
	}
	return (v__vcache__CacheManager){.basepath = vcache_basepath,.vopts = array_string_join(opts, tos_lit("|")),.k2cpath = new_map_1(sizeof(string)),};
}

string v__vcache__CacheManager_key2cpath(v__vcache__CacheManager* cm, string key) {
	string cpath = (*(string*)map_get(cm->k2cpath, key, &(string[]){ (string){.str=(byteptr)""} }));
	if ((cpath).len == 0) {
		string hk = string_add(cm->vopts, key);
		string a = u64_hex_full(hash__sum64_string(hk, 5));
		string b = u64_hex_full(hash__sum64_string(hk, 7));
		string khash = string_add(a, b);
		string prefix = string_substr(khash, 0, 2);
		string cprefix_folder = os__join_path(cm->basepath, (varg_string){.len=1,.args={prefix}});
		cpath = os__join_path(cprefix_folder, (varg_string){.len=1,.args={khash}});
		if (!os__is_dir(cprefix_folder)) {
			os__mkdir_all(cprefix_folder);
			os__chmod(cprefix_folder, 0777);
		}
		map_set(&cm->k2cpath, key, &(string[]) { cpath });
	}
	return cpath;
}

string v__vcache__CacheManager_postfix_with_key2cpath(v__vcache__CacheManager* cm, string postfix, string key) {
	return string_add(v__vcache__CacheManager_key2cpath(cm, key), postfix);
}

Option_string v__vcache__CacheManager_exists(v__vcache__CacheManager* cm, string postfix, string key) {
	string fpath = v__vcache__CacheManager_postfix_with_key2cpath(cm, postfix, key);
	if (!os__exists(fpath)) {
		Option _t408 = v_error(tos_lit("does not exist yet"));
		return *(Option_string*)&_t408;
	}
	Option_string _t409;
	opt_ok2(&(string[]) { fpath }, (OptionBase*)(&_t409), sizeof(string));
	return _t409;
}

Option_string v__vcache__CacheManager_save(v__vcache__CacheManager* cm, string postfix, string key, string content) {
	string fpath = v__vcache__CacheManager_postfix_with_key2cpath(cm, postfix, key);
	Option_void _t410 = os__write_file(fpath, content);
	if (!_t410.ok && !_t410.is_none) {
		return *(Option_string *)&_t410;
	};
	Option_string _t411;
	opt_ok2(&(string[]) { fpath }, (OptionBase*)(&_t411), sizeof(string));
	return _t411;
}

Option_string v__vcache__CacheManager_load(v__vcache__CacheManager* cm, string postfix, string key) {
	Option_string _t412 = v__vcache__CacheManager_exists(cm, postfix, key);
	if (!_t412.ok) {
		return *(Option_string *)&_t412;
	}
 	string fpath = *(string*) _t412.data;
	Option_string _t413 = os__read_file(fpath);
	if (!_t413.ok) {
		return *(Option_string *)&_t413;
	}
 	string content = *(string*) _t413.data;
	Option_string _t414;
	opt_ok2(&(string[]) { content }, (OptionBase*)(&_t414), sizeof(string));
	return _t414;
}

string term__format(string msg, string open, string close) {
	return string_add(string_add(string_add(string_add(string_add(string_add(tos_lit("\x1b["), open), tos_lit("m")), msg), tos_lit("\x1b[")), close), tos_lit("m"));
}

string term__format_rgb(int r, int g, int b, string msg, string open, string close) {
	return string_add(string_add(string_add(string_add(string_add(string_add(string_add(string_add(string_add(string_add(string_add(string_add(tos_lit("\x1b["), open), tos_lit(";2;")), int_str(r)), tos_lit(";")), int_str(g)), tos_lit(";")), int_str(b)), tos_lit("m")), msg), tos_lit("\x1b[")), close), tos_lit("m"));
}

string term__rgb(int r, int g, int b, string msg) {
	return term__format_rgb(r, g, b, msg, tos_lit("38"), tos_lit("39"));
}

string term__bg_rgb(int r, int g, int b, string msg) {
	return term__format_rgb(r, g, b, msg, tos_lit("48"), tos_lit("49"));
}

string term__hex(int hex, string msg) {
	return term__format_rgb(hex >> 16, (hex >> 8 & 0xFF), (hex & 0xFF), msg, tos_lit("38"), tos_lit("39"));
}

string term__bg_hex(int hex, string msg) {
	return term__format_rgb(hex >> 16, (hex >> 8 & 0xFF), (hex & 0xFF), msg, tos_lit("48"), tos_lit("49"));
}

string term__bg_black(string msg) {
	return term__format(msg, tos_lit("40"), tos_lit("49"));
}

string term__bright_bg_black(string msg) {
	return term__format(msg, tos_lit("100"), tos_lit("49"));
}

string term__bg_blue(string msg) {
	return term__format(msg, tos_lit("44"), tos_lit("49"));
}

string term__bright_bg_blue(string msg) {
	return term__format(msg, tos_lit("104"), tos_lit("49"));
}

string term__bg_cyan(string msg) {
	return term__format(msg, tos_lit("46"), tos_lit("49"));
}

string term__bright_bg_cyan(string msg) {
	return term__format(msg, tos_lit("106"), tos_lit("49"));
}

string term__bg_green(string msg) {
	return term__format(msg, tos_lit("42"), tos_lit("49"));
}

string term__bright_bg_green(string msg) {
	return term__format(msg, tos_lit("102"), tos_lit("49"));
}

string term__bg_magenta(string msg) {
	return term__format(msg, tos_lit("45"), tos_lit("49"));
}

string term__bright_bg_magenta(string msg) {
	return term__format(msg, tos_lit("105"), tos_lit("49"));
}

string term__bg_red(string msg) {
	return term__format(msg, tos_lit("41"), tos_lit("49"));
}

string term__bright_bg_red(string msg) {
	return term__format(msg, tos_lit("101"), tos_lit("49"));
}

string term__bg_white(string msg) {
	return term__format(msg, tos_lit("47"), tos_lit("49"));
}

string term__bright_bg_white(string msg) {
	return term__format(msg, tos_lit("107"), tos_lit("49"));
}

string term__bg_yellow(string msg) {
	return term__format(msg, tos_lit("43"), tos_lit("49"));
}

string term__bright_bg_yellow(string msg) {
	return term__format(msg, tos_lit("103"), tos_lit("49"));
}

string term__black(string msg) {
	return term__format(msg, tos_lit("30"), tos_lit("39"));
}

string term__bright_black(string msg) {
	return term__format(msg, tos_lit("90"), tos_lit("39"));
}

string term__blue(string msg) {
	return term__format(msg, tos_lit("34"), tos_lit("39"));
}

string term__bright_blue(string msg) {
	return term__format(msg, tos_lit("94"), tos_lit("39"));
}

string term__bold(string msg) {
	return term__format(msg, tos_lit("1"), tos_lit("22"));
}

string term__cyan(string msg) {
	return term__format(msg, tos_lit("36"), tos_lit("39"));
}

string term__bright_cyan(string msg) {
	return term__format(msg, tos_lit("96"), tos_lit("39"));
}

string term__dim(string msg) {
	return term__format(msg, tos_lit("2"), tos_lit("22"));
}

string term__green(string msg) {
	return term__format(msg, tos_lit("32"), tos_lit("39"));
}

string term__bright_green(string msg) {
	return term__format(msg, tos_lit("92"), tos_lit("39"));
}

string term__gray(string msg) {
	return term__bright_black(msg);
}

string term__hidden(string msg) {
	return term__format(msg, tos_lit("8"), tos_lit("28"));
}

string term__italic(string msg) {
	return term__format(msg, tos_lit("3"), tos_lit("23"));
}

string term__inverse(string msg) {
	return term__format(msg, tos_lit("7"), tos_lit("27"));
}

string term__magenta(string msg) {
	return term__format(msg, tos_lit("35"), tos_lit("39"));
}

string term__bright_magenta(string msg) {
	return term__format(msg, tos_lit("95"), tos_lit("39"));
}

string term__reset(string msg) {
	return term__format(msg, tos_lit("0"), tos_lit("0"));
}

string term__red(string msg) {
	return term__format(msg, tos_lit("31"), tos_lit("39"));
}

string term__bright_red(string msg) {
	return term__format(msg, tos_lit("91"), tos_lit("39"));
}

string term__strikethrough(string msg) {
	return term__format(msg, tos_lit("9"), tos_lit("29"));
}

string term__underline(string msg) {
	return term__format(msg, tos_lit("4"), tos_lit("24"));
}

string term__white(string msg) {
	return term__format(msg, tos_lit("37"), tos_lit("39"));
}

string term__bright_white(string msg) {
	return term__format(msg, tos_lit("97"), tos_lit("39"));
}

string term__yellow(string msg) {
	return term__format(msg, tos_lit("33"), tos_lit("39"));
}

string term__bright_yellow(string msg) {
	return term__format(msg, tos_lit("93"), tos_lit("39"));
}

void term__set_cursor_position(term__Coord c) {
	print(string_add(_STR("\x1b[%"PRId32"\000;%"PRId32"", 2, c.y, c.x), tos_lit("H")));
}

void term__move(int n, string direction) {
	print(_STR("\x1b[%"PRId32"\000%.*s", 2, n, direction));
}

void term__cursor_up(int n) {
	term__move(n, tos_lit("A"));
}

void term__cursor_down(int n) {
	term__move(n, tos_lit("B"));
}

void term__cursor_forward(int n) {
	term__move(n, tos_lit("C"));
}

void term__cursor_back(int n) {
	term__move(n, tos_lit("D"));
}

void term__erase_display(string t) {
	print(string_add(string_add(tos_lit("\x1b["), t), tos_lit("J")));
}

void term__erase_toend() {
	term__erase_display(tos_lit("0"));
}

void term__erase_tobeg() {
	term__erase_display(tos_lit("1"));
}

void term__erase_clear() {
	term__erase_display(tos_lit("2"));
}

void term__erase_del_clear() {
	term__erase_display(tos_lit("3"));
}

void term__erase_line(string t) {
	print(string_add(string_add(tos_lit("\x1b["), t), tos_lit("K")));
}

void term__erase_line_toend() {
	term__erase_line(tos_lit("0"));
}

void term__erase_line_tobeg() {
	term__erase_line(tos_lit("1"));
}

void term__erase_line_clear() {
	term__erase_line(tos_lit("2"));
}

void term__show_cursor() {
	print(tos_lit("\x1b[?25h"));
}

void term__hide_cursor() {
	print(tos_lit("\x1b[?25l"));
}

bool term__can_show_color_on_stdout() {
	return term__supports_escape_sequences(1);
}

bool term__can_show_color_on_stderr() {
	return term__supports_escape_sequences(2);
}

string term__ok_message(string s) {
	return (term__can_show_color_on_stdout() ? (term__green(s)) : (s));
}

string term__fail_message(string s) {
	return (term__can_show_color_on_stdout() ? (term__bold(term__bg_red(term__white(s)))) : (s));
}

string term__warn_message(string s) {
	return (term__can_show_color_on_stdout() ? (term__bright_yellow(s)) : (s));
}

string term__h_divider(string divider) {
	multi_return_int_int mr_1504 = term__get_terminal_size();
	int cols = mr_1504.arg0;
	string result = (divider.len > 0 ? (string_repeat(divider, 1 + (cols / divider.len))) : (string_repeat(tos_lit(" "), 1 + cols)));
	return string_substr(result, 0, cols);
}

string term__header(string text, string divider) {
	if (text.len == 0) {
		return term__h_divider(divider);
	}
	multi_return_int_int mr_1928 = term__get_terminal_size();
	int xcols = mr_1928.arg0;
	int cols = term__imax(1, xcols);
	int tlimit = term__imax(1, (cols > text.len + 2 + 2 * divider.len ? (text.len) : (cols - 3 - 2 * divider.len)));
	int tlimit_alligned = ((tlimit % 2) != (cols % 2) ? (tlimit + 1) : (tlimit));
	int tstart = term__imax(0, (cols - tlimit_alligned) / 2);
	string ln = (divider.len > 0 ? (string_substr(string_repeat(divider, 1 + cols / divider.len), 0, cols)) : (string_repeat(tos_lit(" "), 1 + cols)));
	if (ln.len == 1) {
		return string_add(string_add(string_add(string_add(ln, tos_lit(" ")), string_substr(text, 0, tlimit)), tos_lit(" ")), ln);
	}
	return string_add(string_add(string_add(string_add(string_substr(ln, 0, tstart), tos_lit(" ")), string_substr(text, 0, tlimit)), tos_lit(" ")), string_substr(ln, tstart + tlimit + 2, cols));
}

VV_LOCAL_SYMBOL int term__imax(int x, int y) {
	return (x > y ? (x) : (y));
}

VV_LOCAL_SYMBOL bool term__supports_escape_sequences(int fd) {
	string vcolors_override = os__getenv(tos_lit("VCOLORS"));
	if (string_eq(vcolors_override, tos_lit("always"))) {
		return true;
	}
	if (string_eq(vcolors_override, tos_lit("never"))) {
		return false;
	}
	if (string_eq(os__getenv(tos_lit("TERM")), tos_lit("dumb"))) {
		return false;
	}
	#if defined(_WIN32)
	{
		return ((is_atty(fd) & 0x0004)) > 0;
	}
	#else
	{
	}
	#endif
	return 0;
}

void term__clear() {
	#if !defined(_WIN32)
	{
	}
	#endif
}

multi_return_int_int term__get_terminal_size() {
	if (is_atty(1) > 0 && string_ne(os__getenv(tos_lit("TERM")), tos_lit("dumb"))) {
		term__ConsoleScreenBufferInfo info = (term__ConsoleScreenBufferInfo){.dw_size = {0},.dw_cursor_position = {0},.w_attributes = 0,.sr_window = {0},.dw_maximum_window_size = {0},};
		if (GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &info)) {
			int columns = ((int)(info.sr_window.right - info.sr_window.left + 1));
			int rows = ((int)(info.sr_window.bottom - info.sr_window.top + 1));
			return (multi_return_int_int){.arg0=columns, .arg1=rows};
		}
	}
	return (multi_return_int_int){.arg0=_const_term__default_columns_size, .arg1=_const_term__default_rows_size};
}

term__Coord term__get_cursor_position() {
	term__Coord res = (term__Coord){.x = 0,.y = 0,};
	if (is_atty(1) > 0 && string_ne(os__getenv(tos_lit("TERM")), tos_lit("dumb"))) {
		term__ConsoleScreenBufferInfo info = (term__ConsoleScreenBufferInfo){.dw_size = {0},.dw_cursor_position = {0},.w_attributes = 0,.sr_window = {0},.dw_maximum_window_size = {0},};
		if (GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &info)) {
			res.x = info.dw_cursor_position.x;
			res.y = info.dw_cursor_position.y;
		}
	}
	return res;
}

bool term__set_terminal_title(string title) {
	bool title_change = SetConsoleTitle(string_to_wide(title));
	return title_change;
}

Option_v__vmod__Manifest v__vmod__from_file(string vmod_path) {
	if (!os__exists(vmod_path)) {
		Option _t415 = v_error(tos_lit("v.mod: v.mod file not found."));
		return *(Option_v__vmod__Manifest*)&_t415;
	}
	Option_string _t416 = os__read_file(vmod_path);
	if (!_t416.ok) {
		string err = _t416.v_error;
		int errcode = _t416.ecode;
		v_panic(tos_lit("v.mod: cannot parse v.mod"));
	}
 	string contents = *(string*) _t416.data;
	return v__vmod__decode(contents);
}

Option_v__vmod__Manifest v__vmod__decode(string contents) {
	v__vmod__Parser parser = (v__vmod__Parser){.file_path = (string){.str=(byteptr)""},.scanner = (v__vmod__Scanner){.pos = 0,.text = contents,.inside_text = 0,.tokens = __new_array(0, 1, sizeof(v__vmod__Token)),},};
	return v__vmod__Parser_parse(&parser);
}

VV_LOCAL_SYMBOL void v__vmod__Scanner_tokenize(v__vmod__Scanner* s, v__vmod__TokenKind t_type, string val) {
	array_push(&s->tokens, _MOV((v__vmod__Token[]){ (v__vmod__Token){.typ = t_type,.val = val,} }));
}

VV_LOCAL_SYMBOL void v__vmod__Scanner_skip_whitespace(v__vmod__Scanner* s) {
	for (;;) {
		if (!(s->pos < s->text.len && byte_is_space(string_at(s->text, s->pos)))) break;
		s->pos++;
	}
}

VV_LOCAL_SYMBOL bool v__vmod__is_name_alpha(byte chr) {
	return byte_is_letter(chr) || chr == '_';
}

VV_LOCAL_SYMBOL string v__vmod__Scanner_create_string(v__vmod__Scanner* s, byte q) {
	string str = tos_lit("");
	for (;;) {
		if (!(string_at(s->text, s->pos) != q)) break;
		if (string_at(s->text, s->pos) == '\\' && string_at(s->text, s->pos + 1) == q) {
			str = /*f*/string_add(str, string_substr(s->text, s->pos, s->pos + 1));
			s->pos += 2;
		} else {
			str = /*f*/string_add(str, byte_str(string_at(s->text, s->pos)));
			s->pos++;
		}
	}
	return str;
}

VV_LOCAL_SYMBOL string v__vmod__Scanner_create_ident(v__vmod__Scanner* s) {
	string text = tos_lit("");
	for (;;) {
		if (!(v__vmod__is_name_alpha(string_at(s->text, s->pos)))) break;
		text = /*f*/string_add(text, byte_str(string_at(s->text, s->pos)));
		s->pos++;
	}
	return text;
}

VV_LOCAL_SYMBOL bool v__vmod__Scanner_peek_char(v__vmod__Scanner s, byte c) {
	return s.pos - 1 < s.text.len && string_at(s.text, s.pos - 1) == c;
}

VV_LOCAL_SYMBOL void v__vmod__Scanner_scan_all(v__vmod__Scanner* s) {
	for (;;) {
		if (!(s->pos < s->text.len)) break;
		byte c = string_at(s->text, s->pos);
		if (byte_is_space(c) || c == '\\') {
			s->pos++;
			continue;
		}
		if (v__vmod__is_name_alpha(c)) {
			string name = v__vmod__Scanner_create_ident(s);
			if (string_eq(name, tos_lit("Module"))) {
				v__vmod__Scanner_tokenize(s, v__vmod__TokenKind_module_keyword, name);
				s->pos++;
				continue;
			} else if (string_at(s->text, s->pos) == ':') {
				v__vmod__Scanner_tokenize(s, v__vmod__TokenKind_field_key, string_add(name, tos_lit(":")));
				s->pos += 2;
				continue;
			} else {
				v__vmod__Scanner_tokenize(s, v__vmod__TokenKind_ident, name);
				s->pos++;
				continue;
			}
		}
		if ((c == '\'' || c == '\"') && !v__vmod__Scanner_peek_char(/*rec*/*s, '\\')) {
			s->pos++;
			string str = v__vmod__Scanner_create_string(s, c);
			v__vmod__Scanner_tokenize(s, v__vmod__TokenKind_str, str);
			s->pos++;
			continue;
		}
		byte _t418 = c;
		if (_t418 == '{') {
			v__vmod__Scanner_tokenize(s, v__vmod__TokenKind_lcbr, byte_str(c));
		} else if (_t418 == '}') {
			v__vmod__Scanner_tokenize(s, v__vmod__TokenKind_rcbr, byte_str(c));
		} else if (_t418 == '[') {
			v__vmod__Scanner_tokenize(s, v__vmod__TokenKind_labr, byte_str(c));
		} else if (_t418 == ']') {
			v__vmod__Scanner_tokenize(s, v__vmod__TokenKind_rabr, byte_str(c));
		} else if (_t418 == ':') {
			v__vmod__Scanner_tokenize(s, v__vmod__TokenKind_colon, byte_str(c));
		} else if (_t418 == ',') {
			v__vmod__Scanner_tokenize(s, v__vmod__TokenKind_comma, byte_str(c));
		} else {
			v__vmod__Scanner_tokenize(s, v__vmod__TokenKind_unknown, byte_str(c));
		};
		s->pos++;
	}
	v__vmod__Scanner_tokenize(s, v__vmod__TokenKind_eof, tos_lit("eof"));
}

VV_LOCAL_SYMBOL Option_multi_return_array_string_int v__vmod__get_array_content(array_v__vmod__Token tokens, int st_idx) {
	array_string vals = __new_array_with_default(0, 0, sizeof(string), 0);
	int idx = st_idx;
	if ((*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, idx)).typ != v__vmod__TokenKind_labr) {
		Option _t419 = v_error(tos_lit("vmod: not a valid array"));
		return *(Option_multi_return_array_string_int*)&_t419;
	}
	idx++;
	for (;;) {
		v__vmod__Token tok = (*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, idx));
		v__vmod__TokenKind _t420 = tok.typ;
		if (_t420 == v__vmod__TokenKind_str) {
			array_push(&vals, _MOV((string[]){ string_clone(tok.val) }));
			if (!((*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, idx + 1)).typ == v__vmod__TokenKind_comma || (*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, idx + 1)).typ == v__vmod__TokenKind_rabr)) {
				Option _t422 = v_error(_STR("vmod: invalid separator \"%.*s\000\"", 2, (*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, idx + 1)).val));
				return *(Option_multi_return_array_string_int*)&_t422;
			}
			idx += ((*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, idx + 1)).typ == v__vmod__TokenKind_comma ? (2) : (1));
		} else if (_t420 == v__vmod__TokenKind_rabr) {
			idx++;
			break;
		} else {
			Option _t423 = v_error(_STR("vmod: invalid token \"%.*s\000\"", 2, tok.val));
			return *(Option_multi_return_array_string_int*)&_t423;
		};
	}
	Option_multi_return_array_string_int _t424;
	opt_ok2(&(multi_return_array_string_int/*X*/[]) { (multi_return_array_string_int){.arg0=vals, .arg1=idx} }, (OptionBase*)(&_t424), sizeof(multi_return_array_string_int));
	return _t424;
}

VV_LOCAL_SYMBOL Option_v__vmod__Manifest v__vmod__Parser_parse(v__vmod__Parser* p) {
	string err_label = tos_lit("vmod:");
	if (p->scanner.text.len == 0) {
		Option _t425 = v_error(_STR("%.*s\000 no content.", 2, err_label));
		return *(Option_v__vmod__Manifest*)&_t425;
	}
	v__vmod__Scanner_scan_all(&p->scanner);
	array_v__vmod__Token tokens = p->scanner.tokens;
	v__vmod__Manifest mn = (v__vmod__Manifest){.name = (string){.str=(byteptr)""},.version = (string){.str=(byteptr)""},.description = (string){.str=(byteptr)""},.dependencies = __new_array(0, 1, sizeof(string)),.license = (string){.str=(byteptr)""},.repo_url = (string){.str=(byteptr)""},.author = (string){.str=(byteptr)""},.unknown = new_map_1(sizeof(array_string)),};
	if ((*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, 0)).typ != v__vmod__TokenKind_module_keyword) {
		v_panic(tos_lit("not a valid v.mod"));
	}
	int i = 1;
	for (;;) {
		if (!(i < tokens.len)) break;
		v__vmod__Token tok = (*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, i));
		v__vmod__TokenKind _t426 = tok.typ;
		if (_t426 == v__vmod__TokenKind_lcbr) {
			if (!((*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, i + 1)).typ == v__vmod__TokenKind_field_key || (*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, i + 1)).typ == v__vmod__TokenKind_rcbr)) {
				Option _t427 = v_error(_STR("%.*s\000 invalid content after opening brace", 2, err_label));
				return *(Option_v__vmod__Manifest*)&_t427;
			}
			i++;
			continue;
		} else if (_t426 == v__vmod__TokenKind_rcbr) {
			break;
		} else if (_t426 == v__vmod__TokenKind_field_key) {
			string field_name = string_trim_right(tok.val, tos_lit(":"));
			if (!((*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, i + 1)).typ == v__vmod__TokenKind_str || (*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, i + 1)).typ == v__vmod__TokenKind_labr)) {
				Option _t428 = v_error(_STR("%.*s\000 value of field \"%.*s\000\" must be either string or an array of strings", 3, err_label, field_name));
				return *(Option_v__vmod__Manifest*)&_t428;
			}
			string field_value = (*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, i + 1)).val;
			string _t429 = field_name;
			if (string_eq(_t429, tos_lit("name"))) {
				mn.name = field_value;
			} else if (string_eq(_t429, tos_lit("version"))) {
				mn.version = field_value;
			} else if (string_eq(_t429, tos_lit("license"))) {
				mn.license = field_value;
			} else if (string_eq(_t429, tos_lit("repo_url"))) {
				mn.repo_url = field_value;
			} else if (string_eq(_t429, tos_lit("description"))) {
				mn.description = field_value;
			} else if (string_eq(_t429, tos_lit("author"))) {
				mn.author = field_value;
			} else if (string_eq(_t429, tos_lit("dependencies"))) {
				Option_multi_return_array_string_int _t430 = v__vmod__get_array_content(tokens, i + 1);
				if (!_t430.ok) {
					return *(Option_v__vmod__Manifest *)&_t430;
				}
 				Option_multi_return_array_string_int mr_4440 =  _t430;
				array_string deps = (*(multi_return_array_string_int*)mr_4440.data).arg0;
				int idx = (*(multi_return_array_string_int*)mr_4440.data).arg1;
				mn.dependencies = deps;
				i = idx;
				continue;
			} else {
				if ((*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, i + 1)).typ == v__vmod__TokenKind_labr) {
					Option_multi_return_array_string_int _t431 = v__vmod__get_array_content(tokens, i + 1);
					if (!_t431.ok) {
						return *(Option_v__vmod__Manifest *)&_t431;
					}
 					Option_multi_return_array_string_int mr_4610 =  _t431;
					array_string vals = (*(multi_return_array_string_int*)mr_4610.data).arg0;
					int idx = (*(multi_return_array_string_int*)mr_4610.data).arg1;
					map_set(&mn.unknown, field_name, &(array_string[]) { vals });
					i = idx;
					continue;
				}
				map_set(&mn.unknown, field_name, &(array_string[]) { new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){field_value})) });
			};
			i += 2;
			continue;
		} else if (_t426 == v__vmod__TokenKind_comma) {
			if (!((*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, i - 1)).typ == v__vmod__TokenKind_str || (*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, i - 1)).typ == v__vmod__TokenKind_rabr) || (*(v__vmod__Token*)/*ee elem_typ */array_get(tokens, i + 1)).typ != v__vmod__TokenKind_field_key) {
				Option _t432 = v_error(_STR("%.*s\000 invalid comma placement", 2, err_label));
				return *(Option_v__vmod__Manifest*)&_t432;
			}
			i++;
			continue;
		} else {
			Option _t433 = v_error(_STR("%.*s\000 invalid token \"%.*s\000\"", 3, err_label, tok.val));
			return *(Option_v__vmod__Manifest*)&_t433;
		};
	}
	Option_v__vmod__Manifest _t434;
	opt_ok2(&(v__vmod__Manifest[]) { mn }, (OptionBase*)(&_t434), sizeof(v__vmod__Manifest));
	return _t434;
}

v__vmod__ModFileCacher* v__vmod__new_mod_file_cacher() {
	return (v__vmod__ModFileCacher*)memdup(&(v__vmod__ModFileCacher){.cache = new_map_1(sizeof(v__vmod__ModFileAndFolder)),.folder_files = new_map_1(sizeof(array_string)),}, sizeof(v__vmod__ModFileCacher));
}

void v__vmod__ModFileCacher_dump(v__vmod__ModFileCacher* mcache) {
	#if defined(_VDEBUG)
	{
	}
	#endif
}

v__vmod__ModFileAndFolder v__vmod__ModFileCacher_get_by_file(v__vmod__ModFileCacher* mcache, string vfile) {
	return v__vmod__ModFileCacher_get_by_folder(mcache, os__dir(vfile));
}

v__vmod__ModFileAndFolder v__vmod__ModFileCacher_get_by_folder(v__vmod__ModFileCacher* mcache, string vfolder) {
	string mfolder = os__real_path(vfolder);
	if (_IN_MAP(mfolder, mcache->cache)) {
		return (*(v__vmod__ModFileAndFolder*)map_get(mcache->cache, mfolder, &(v__vmod__ModFileAndFolder[]){ {0} }));
	}
	multi_return_array_string_v__vmod__ModFileAndFolder mr_2139 = v__vmod__ModFileCacher_traverse(mcache, mfolder);
	array_string traversed_folders = mr_2139.arg0;
	v__vmod__ModFileAndFolder res = mr_2139.arg1;
	// FOR IN array
	array _t435 = traversed_folders;
	for (int _t436 = 0; _t436 < _t435.len; ++_t436) {
		string tfolder = ((string*)_t435.data)[_t436];
		v__vmod__ModFileCacher_add(mcache, tfolder, res);
	}
	return res;
}

VV_LOCAL_SYMBOL void v__vmod__ModFileCacher_add(v__vmod__ModFileCacher* cacher, string path, v__vmod__ModFileAndFolder result) {
	(*(v__vmod__ModFileAndFolder*)map_get_and_set(&cacher->cache, path, &(v__vmod__ModFileAndFolder[]){ {0} })) = result;
}

VV_LOCAL_SYMBOL multi_return_array_string_v__vmod__ModFileAndFolder v__vmod__ModFileCacher_traverse(v__vmod__ModFileCacher* mcache, string mfolder) {
	string cfolder = mfolder;
	array_string folders_so_far = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){cfolder}));
	int levels = 0;
	for (;;) {
		if (levels > 255) {
			break;
		}
		if (string_eq(cfolder, tos_lit("/")) || (cfolder).len == 0) {
			break;
		}
		if (_IN_MAP(cfolder, mcache->cache)) {
			v__vmod__ModFileAndFolder res = (*(v__vmod__ModFileAndFolder*)map_get(mcache->cache, cfolder, &(v__vmod__ModFileAndFolder[]){ {0} }));
			if (res.vmod_file.len == 0) {
				v__vmod__ModFileCacher_mark_folders_as_vmod_free(mcache, folders_so_far);
			} else {
				v__vmod__ModFileCacher_mark_folders_with_vmod(mcache, folders_so_far, res);
			}
			return (multi_return_array_string_v__vmod__ModFileAndFolder){.arg0=__new_array_with_default(0, 0, sizeof(string), 0), .arg1=res};
		}
		array_string files = v__vmod__ModFileCacher_get_files(mcache, cfolder);
		if (_IN(string, tos_lit("v.mod"), files)) {
			v__vmod__ModFileAndFolder res = (v__vmod__ModFileAndFolder){.vmod_file = os__join_path(cfolder, (varg_string){.len=1,.args={tos_lit("v.mod")}}),.vmod_folder = cfolder,};
			return (multi_return_array_string_v__vmod__ModFileAndFolder){.arg0=folders_so_far, .arg1=res};
		}
		if (v__vmod__ModFileCacher_check_for_stop(mcache, cfolder, files)) {
			break;
		}
		cfolder = os__dir(cfolder);
		array_push(&folders_so_far, _MOV((string[]){ string_clone(cfolder) }));
		levels++;
	}
	v__vmod__ModFileCacher_mark_folders_as_vmod_free(mcache, folders_so_far);
	return (multi_return_array_string_v__vmod__ModFileAndFolder){.arg0=new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){mfolder})), .arg1=(v__vmod__ModFileAndFolder){.vmod_file = tos_lit(""),.vmod_folder = mfolder,}};
}

VV_LOCAL_SYMBOL void v__vmod__ModFileCacher_mark_folders_with_vmod(v__vmod__ModFileCacher* mcache, array_string folders_so_far, v__vmod__ModFileAndFolder vmod) {
	// FOR IN array
	array _t438 = folders_so_far;
	for (int _t439 = 0; _t439 < _t438.len; ++_t439) {
		string f = ((string*)_t438.data)[_t439];
		v__vmod__ModFileCacher_add(mcache, f, vmod);
	}
}

VV_LOCAL_SYMBOL void v__vmod__ModFileCacher_mark_folders_as_vmod_free(v__vmod__ModFileCacher* mcache, array_string folders_so_far) {
	// FOR IN array
	array _t440 = folders_so_far;
	for (int _t441 = 0; _t441 < _t440.len; ++_t441) {
		string f = ((string*)_t440.data)[_t441];
		v__vmod__ModFileCacher_add(mcache, f, (v__vmod__ModFileAndFolder){.vmod_file = tos_lit(""),.vmod_folder = f,});
	}
}

VV_LOCAL_SYMBOL bool v__vmod__ModFileCacher_check_for_stop(v__vmod__ModFileCacher* mcache, string cfolder, array_string files) {
	// FOR IN array
	array _t442 = _const_v__vmod__mod_file_stop_paths;
	for (int _t443 = 0; _t443 < _t442.len; ++_t443) {
		string i = ((string*)_t442.data)[_t443];
		if (_IN(string, i, files)) {
			return true;
		}
	}
	return false;
}

VV_LOCAL_SYMBOL array_string v__vmod__ModFileCacher_get_files(v__vmod__ModFileCacher* mcache, string cfolder) {
	if (_IN_MAP(cfolder, mcache->folder_files)) {
		return (*(array_string*)map_get(mcache->folder_files, cfolder, &(array_string[]){ __new_array(0, 1, sizeof(string)) }));
	}
	array_string files = __new_array_with_default(0, 0, sizeof(string), 0);
	if (os__exists(cfolder) && os__is_dir(cfolder)) {
		{ /* if guard */ 
		Option_array_string _t444;
		if (_t444 = os__ls(cfolder), _t444.ok) {
			array_string listing = *(array_string*)_t444.data;
			files = listing;
		}}
	}
	map_set(&mcache->folder_files, cfolder, &(array_string[]) { files });
	return files;
}

v__vmod__ModFileCacher* v__vmod__get_cache() {
	return _const_v__vmod__private_file_cacher;
}

string v__cflag__CFlag_str(v__cflag__CFlag* c) {
	return _STR("CFlag{ name: \"%.*s\000\" value: \"%.*s\000\" mod: \"%.*s\000\" os: \"%.*s\000\" cached: \"%.*s\000\" }", 6, c->name, c->value, c->mod, c->os, c->cached);
}

string v__cflag__CFlag_format(v__cflag__CFlag* cf) {
	string value = cf->value;
	if ((cf->cached).len != 0) {
		value = cf->cached;
	}
	if ((string_eq(cf->name, tos_lit("-l")) || string_eq(cf->name, tos_lit("-Wa")) || string_eq(cf->name, tos_lit("-Wl")) || string_eq(cf->name, tos_lit("-Wp"))) && value.len > 0) {
		return string_trim_space(_STR("%.*s\000%.*s", 2, cf->name, value));
	}
	if (string_eq(cf->name, tos_lit("-I")) || string_eq(cf->name, tos_lit("-L")) || string_ends_with(value, tos_lit(".o"))) {
		value = string_add(string_add(tos_lit("\""), os__real_path(value)), tos_lit("\""));
	}
	return string_trim_space(_STR("%.*s\000 %.*s", 2, cf->name, value));
}

string array_v__cflag__CFlag_c_options_before_target_msvc(array_v__cflag__CFlag cflags) {
	return tos_lit("");
}

string array_v__cflag__CFlag_c_options_after_target_msvc(array_v__cflag__CFlag cflags) {
	return tos_lit("");
}

string array_v__cflag__CFlag_c_options_before_target(array_v__cflag__CFlag cflags) {
	array_string args = __new_array_with_default(0, 0, sizeof(string), 0);
	// FOR IN array
	array _t445 = cflags;
	for (int _t446 = 0; _t446 < _t445.len; ++_t446) {
		v__cflag__CFlag flag = ((v__cflag__CFlag*)_t445.data)[_t446];
		if (string_ne(flag.name, tos_lit("-l")) && !string_ends_with(flag.value, tos_lit(".o"))) {
			array_push(&args, _MOV((string[]){ string_clone(v__cflag__CFlag_format(&flag)) }));
		}
	}
	return array_string_join(args, tos_lit(" "));
}

string array_v__cflag__CFlag_c_options_after_target(array_v__cflag__CFlag cflags) {
	array_string args = __new_array_with_default(0, 0, sizeof(string), 0);
	// FOR IN array
	array _t448 = cflags;
	for (int _t449 = 0; _t449 < _t448.len; ++_t449) {
		v__cflag__CFlag flag = ((v__cflag__CFlag*)_t448.data)[_t449];
		if (string_eq(flag.name, tos_lit("-l"))) {
			array_push(&args, _MOV((string[]){ string_clone(v__cflag__CFlag_format(&flag)) }));
		}
	}
	return array_string_join(args, tos_lit(" "));
}

string array_v__cflag__CFlag_c_options_without_object_files(array_v__cflag__CFlag cflags) {
	array_string args = __new_array_with_default(0, 0, sizeof(string), 0);
	// FOR IN array
	array _t451 = cflags;
	for (int _t452 = 0; _t452 < _t451.len; ++_t452) {
		v__cflag__CFlag flag = ((v__cflag__CFlag*)_t451.data)[_t452];
		if (string_ends_with(flag.value, tos_lit(".o")) || string_ends_with(flag.value, tos_lit(".obj"))) {
			continue;
		}
		array_push(&args, _MOV((string[]){ string_clone(v__cflag__CFlag_format(&flag)) }));
	}
	return array_string_join(args, tos_lit(" "));
}

string array_v__cflag__CFlag_c_options_only_object_files(array_v__cflag__CFlag cflags) {
	array_string args = __new_array_with_default(0, 0, sizeof(string), 0);
	// FOR IN array
	array _t454 = cflags;
	for (int _t455 = 0; _t455 < _t454.len; ++_t455) {
		v__cflag__CFlag flag = ((v__cflag__CFlag*)_t454.data)[_t455];
		if (string_ends_with(flag.value, tos_lit(".o")) || string_ends_with(flag.value, tos_lit(".obj"))) {
			array_push(&args, _MOV((string[]){ string_clone(v__cflag__CFlag_format(&flag)) }));
		}
	}
	return array_string_join(args, tos_lit(" "));
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL u32 rand__util__nr_next(u32 prev) {
	return prev * 1664525 + 1013904223;
}

// Attr: [inline]
inline array_u32 rand__util__time_seed_array(int count) {
	time__Time ctime = time__now();
	u32 seed = ((u32)((time__Time_unix_time(ctime) ^ ctime.microsecond)));
	array_u32 seed_data = __new_array_with_default(0, count, sizeof(u32), 0);
	for (int _t457 = 0; _t457 < count; ++_t457) {
		seed = rand__util__nr_next(seed);
		array_push(&seed_data, _MOV((u32[]){ rand__util__nr_next(seed) }));
	}
	return seed_data;
}

// Attr: [inline]
inline u32 rand__util__time_seed_32() {
	return (*(u32*)/*ee elem_typ */array_get(rand__util__time_seed_array(1), 0));
}

// Attr: [inline]
inline u64 rand__util__time_seed_64() {
	array_u32 seed_data = rand__util__time_seed_array(2);
	u64 lower = ((u64)((*(u32*)/*ee elem_typ */array_get(seed_data, 0))));
	u64 upper = ((u64)((*(u32*)/*ee elem_typ */array_get(seed_data, 1))));
	return (lower | (upper << 32));
}

VV_LOCAL_SYMBOL Option_string v__pkgconfig__desc(string mod) {
	v__pkgconfig__Options options = (v__pkgconfig__Options){.path = (string){.str=(byteptr)""},.debug = 0,.norecurse = true,};
	Option_v__pkgconfig__PkgConfig_ptr _t459 = v__pkgconfig__load(mod, options);
	if (!_t459.ok) {
		string err = _t459.v_error;
		int errcode = _t459.ecode;
		Option _t460 = v_error(tos_lit("cannot parse"));
		return *(Option_string*)&_t460;
	}
 	v__pkgconfig__PkgConfig* pc = *(v__pkgconfig__PkgConfig**) _t459.data;
	Option_string _t461;
	opt_ok2(&(string[]) { pc->description }, (OptionBase*)(&_t461), sizeof(string));
	return _t461;
}

Option_v__pkgconfig__Main_ptr v__pkgconfig__main(array_string args) {
	flag__FlagParser* fp = flag__new_flag_parser(args);
	flag__FlagParser_application(fp, tos_lit("pkgconfig"));
	flag__FlagParser_version(fp, _const_v__pkgconfig__version);
	v__pkgconfig__Main* m = (v__pkgconfig__Main*)memdup(&(v__pkgconfig__Main){.opt = v__pkgconfig__parse_options(fp),.res = (string){.str=(byteptr)""},.has_actions = 0,}, sizeof(v__pkgconfig__Main));
	v__pkgconfig__MainOptions* opt = m->opt;
	if (opt->help) {
		m->res = string_replace(flag__FlagParser_usage(/*rec*/*fp), tos_lit("- ,"), tos_lit("   "));
	} else if (opt->version) {
		m->res = _const_v__pkgconfig__version;
	} else if (opt->listall) {
		array_string modules = v__pkgconfig__list();
		qsort(modules.data, modules.len, modules.element_size, (int (*)(const void *, const void *))&compare_strings);
		;
		if (opt->description) {
			// FOR IN array
			array _t462 = modules;
			for (int _t463 = 0; _t463 < _t462.len; ++_t463) {
				string mod = ((string*)_t462.data)[_t463];
				Option_string _t464 = v__pkgconfig__desc(mod);
				if (!_t464.ok) {
					string err = _t464.v_error;
					int errcode = _t464.ecode;
					continue;
				}
 				string d = *(string*) _t464.data;
				string pad = strings__repeat(' ', 20 - mod.len);
				m->res = /*f*/string_add(m->res, _STR("%.*s\000 %.*s\000 %.*s\000\n", 4, mod, pad, d));
			}
		} else {
			m->res = array_string_join(modules, tos_lit("\n"));
		}
	} else if (opt->args.len == 0) {
		Option _t465 = v_error(tos_lit("No packages given"));
		return *(Option_v__pkgconfig__Main_ptr*)&_t465;
	}
	Option_v__pkgconfig__Main_ptr _t466;
	opt_ok2(&(v__pkgconfig__Main*[]) { m }, (OptionBase*)(&_t466), sizeof(v__pkgconfig__Main*));
	return _t466;
}

Option_string v__pkgconfig__Main_run(v__pkgconfig__Main* m) {
	v__pkgconfig__Options options = (v__pkgconfig__Options){.path = (string){.str=(byteptr)""},.debug = m->opt->debug,.norecurse = 0,};
	v__pkgconfig__MainOptions* opt = m->opt;
	v__pkgconfig__PkgConfig* pc = ((v__pkgconfig__PkgConfig*)(0));
	string res = m->res;
	// FOR IN array
	array _t467 = opt->args;
	for (int _t468 = 0; _t468 < _t467.len; ++_t468) {
		string arg = ((string*)_t467.data)[_t468];
		Option_v__pkgconfig__PkgConfig_ptr _t469 = v__pkgconfig__load(arg, options);
		if (!_t469.ok) {
			string err = _t469.v_error;
			int errcode = _t469.ecode;
			if (!opt->exists) {
				Option _t470 = v_error(err);
				return *(Option_string*)&_t470;
			}
			continue;
		}
 		v__pkgconfig__PkgConfig* pcdep = *(v__pkgconfig__PkgConfig**) _t469.data;
		if (opt->description) {
			if ((res).len != 0) {
				res = /*f*/string_add(res, tos_lit("\n"));
			}
			res = /*f*/string_add(res, pcdep->description);
		}
		if (pc != 0) {
			v__pkgconfig__PkgConfig_extend(pc, pcdep);
		} else {
			pc = pcdep;
		}
	}
	if (opt->exists) {
		Option_string _t471;
		opt_ok2(&(string[]) { res }, (OptionBase*)(&_t471), sizeof(string));
		return _t471;
	}
	if ((opt->exactversion).len != 0) {
		if (string_ne(pc->version, opt->exactversion)) {
			Option _t472 = v_error(tos_lit("version mismatch"));
			return *(Option_string*)&_t472;
		}
		Option_string _t473;
		opt_ok2(&(string[]) { res }, (OptionBase*)(&_t473), sizeof(string));
		return _t473;
	}
	if ((opt->atleast).len != 0) {
		if (v__pkgconfig__PkgConfig_atleast(pc, opt->atleast)) {
			Option _t474 = v_error(tos_lit("version mismatch"));
			return *(Option_string*)&_t474;
		}
		Option_string _t475;
		opt_ok2(&(string[]) { res }, (OptionBase*)(&_t475), sizeof(string));
		return _t475;
	}
	if ((opt->atleastpc).len != 0) {
		if (v__pkgconfig__atleast(opt->atleastpc)) {
			Option _t476 = v_error(tos_lit("version mismatch"));
			return *(Option_string*)&_t476;
		}
		Option_string _t477;
		opt_ok2(&(string[]) { res }, (OptionBase*)(&_t477), sizeof(string));
		return _t477;
	}
	if (opt->variables) {
		// FOR IN map
		map_string_string _t479 = pc->vars;
		for (int _t478 = 0; _t478 < _t479.key_values.len; ++_t478) {
			if (_t479.key_values.keys[_t478].str == 0) {continue;}
			string k = /*key*/ string_clone(_t479.key_values.keys[_t478]);
			res = /*f*/string_add(res, _STR("%.*s\000\n", 2, k));
		}
	}
	if (opt->requires) {
		res = /*f*/string_add(res, array_string_join(pc->requires, tos_lit("\n")));
	}
	array_string r = __new_array_with_default(0, 0, sizeof(string), 0);
	if (opt->cflags_only_path) {
		array_push(&r, _MOV((string[]){ string_clone(v__pkgconfig__filter(pc->cflags, tos_lit("-I"), tos_lit(""))) }));
	}
	if (opt->cflags_only_other) {
		array_push(&r, _MOV((string[]){ string_clone(v__pkgconfig__filter(pc->cflags, tos_lit("-I"), tos_lit("-I"))) }));
	}
	if (opt->cflags) {
		array_push(&r, _MOV((string[]){ string_clone(array_string_join(pc->cflags, tos_lit(" "))) }));
	}
	if (opt->libs_only_link) {
		array_push(&r, _MOV((string[]){ string_clone(v__pkgconfig__filter(pc->libs, tos_lit("-l"), tos_lit(""))) }));
	}
	if (opt->libs_only_path) {
		array_push(&r, _MOV((string[]){ string_clone(v__pkgconfig__filter(pc->libs, tos_lit("-L"), tos_lit(""))) }));
	}
	if (opt->libs_only_other) {
		array_push(&r, _MOV((string[]){ string_clone(v__pkgconfig__filter(pc->libs, tos_lit("-l"), tos_lit("-L"))) }));
	}
	if (opt->libs) {
		if (opt->stat1c) {
			array_push(&r, _MOV((string[]){ string_clone(array_string_join(pc->libs_private, tos_lit(" "))) }));
		} else {
			array_push(&r, _MOV((string[]){ string_clone(array_string_join(pc->libs, tos_lit(" "))) }));
		}
	}
	if (opt->modversion) {
		array_push(&r, _MOV((string[]){ string_clone(pc->version) }));
	}
	Option_string _t489;
	opt_ok2(&(string[]) { string_add(res, array_string_join(r, tos_lit(" "))) }, (OptionBase*)(&_t489), sizeof(string));
	return _t489;
}

VV_LOCAL_SYMBOL string v__pkgconfig__filter(array_string libs, string prefix, string prefix2) {
	string res = tos_lit("");
	if ((prefix2).len != 0) {
		// FOR IN array
		array _t490 = libs;
		for (int _t491 = 0; _t491 < _t490.len; ++_t491) {
			string lib = ((string*)_t490.data)[_t491];
			if (!string_starts_with(lib, prefix) && !string_starts_with(lib, prefix2)) {
				res = /*f*/string_add(res, _STR(" %.*s", 1, lib));
			}
		}
	} else {
		// FOR IN array
		array _t492 = libs;
		for (int _t493 = 0; _t493 < _t492.len; ++_t493) {
			string lib = ((string*)_t492.data)[_t493];
			if (string_starts_with(lib, prefix)) {
				res = /*f*/string_add(res, _STR(" %.*s", 1, lib));
			}
		}
	}
	return res;
}

VV_LOCAL_SYMBOL v__pkgconfig__MainOptions* v__pkgconfig__parse_options(flag__FlagParser* fp) {
	return (v__pkgconfig__MainOptions*)memdup(&(v__pkgconfig__MainOptions){.modversion = flag__FlagParser_bool(fp, tos_lit("modversion"), 'V', false, tos_lit("show version of module")),
		.description = flag__FlagParser_bool(fp, tos_lit("description"), 'd', false, tos_lit("show pkg module description")),
		.help = flag__FlagParser_bool(fp, tos_lit("help"), 'h', false, tos_lit("show this help message")),
		.debug = flag__FlagParser_bool(fp, tos_lit("debug"), 'D', false, tos_lit("show debug information")),
		.listall = flag__FlagParser_bool(fp, tos_lit("list-all"), 'l', false, tos_lit("list all pkgmodules")),
		.exists = flag__FlagParser_bool(fp, tos_lit("exists"), 'e', false, tos_lit("return 0 if pkg exists")),
		.variables = flag__FlagParser_bool(fp, tos_lit("print-variables"), 'V', false, tos_lit("display variable names")),
		.requires = flag__FlagParser_bool(fp, tos_lit("print-requires"), 'r', false, tos_lit("display requires of the module")),
		.atleast = flag__FlagParser_string(fp, tos_lit("atleast-version"), 'a', tos_lit(""), tos_lit("return 0 if pkg version is at least the given one")),
		.atleastpc = flag__FlagParser_string(fp, tos_lit("atleast-pkgconfig-version"), 'A', tos_lit(""), tos_lit("return 0 if pkgconfig version is at least the given one")),
		.exactversion = flag__FlagParser_string(fp, tos_lit("exact-version"), ' ', tos_lit(""), tos_lit("return 0 if pkg version is at least the given one")),
		.version = flag__FlagParser_bool(fp, tos_lit("version"), 'v', false, tos_lit("show version of this tool")),
		.cflags = flag__FlagParser_bool(fp, tos_lit("cflags"), 'c', false, tos_lit("output all pre-processor and compiler flags")),
		.cflags_only_path = flag__FlagParser_bool(fp, tos_lit("cflags-only-I"), 'I', false, tos_lit("show only -I flags from CFLAGS")),
		.cflags_only_other = flag__FlagParser_bool(fp, tos_lit("cflags-only-other"), ' ', false, tos_lit("show cflags without -I")),
		.stat1c = flag__FlagParser_bool(fp, tos_lit("static"), 's', false, tos_lit("show --libs for static linking")),
		.libs = flag__FlagParser_bool(fp, tos_lit("libs"), 'l', false, tos_lit("output all linker flags")),
		.libs_only_link = flag__FlagParser_bool(fp, tos_lit("libs-only-l"), ' ', false, tos_lit("show only -l from ldflags")),
		.libs_only_path = flag__FlagParser_bool(fp, tos_lit("libs-only-L"), 'L', false, tos_lit("show only -L from ldflags")),
		.libs_only_other = flag__FlagParser_bool(fp, tos_lit("libs-only-other"), ' ', false, tos_lit("show flags not containing -l or -L")),
		.args = fp->args,
	}, sizeof(v__pkgconfig__MainOptions));
}

VV_LOCAL_SYMBOL array_string v__pkgconfig__PkgConfig_parse_list(v__pkgconfig__PkgConfig* pc, string s) {
	array_string operators = new_array_from_c_array(5, 5, sizeof(string), _MOV((string[5]){tos_lit("="), tos_lit("<"), tos_lit(">"), tos_lit(">="), tos_lit("<=")}));
	array_string r = string_split(v__pkgconfig__PkgConfig_parse_line(pc, string_replace(s, tos_lit(","), tos_lit(""))), tos_lit(" "));
	array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	bool skip = false;
	// FOR IN array
	array _t494 = r;
	for (int _t495 = 0; _t495 < _t494.len; ++_t495) {
		string a = ((string*)_t494.data)[_t495];
		string b = string_trim_space(a);
		if (skip) {
			skip = false;
		} else if (_IN(string, b, operators)) {
			skip = true;
		} else if ((b).len != 0) {
			array_push(&res, _MOV((string[]){ string_clone(b) }));
		}
	}
	return res;
}

VV_LOCAL_SYMBOL string v__pkgconfig__PkgConfig_parse_line(v__pkgconfig__PkgConfig* pc, string s) {
	string r = string_trim_space(s);
	for (;;) {
		if (!(string_contains(r, tos_lit("${")))) break;
		Option_int _t497 = string_index(r, tos_lit("${"));
		if (!_t497.ok) {
			string err = _t497.v_error;
			int errcode = _t497.ecode;
			break;
		}
 		int tok0 = *(int*) _t497.data;
		Option_int _t498 = string_index(string_substr(r, tok0, r.len), tos_lit("}"));
		if (!_t498.ok) {
			string err = _t498.v_error;
			int errcode = _t498.ecode;
			break;
		}
 		int tok1 = *(int*) _t498.data;
		tok1 += tok0;
		string v = string_substr(r, tok0 + 2, tok1);
		r = string_replace(r, _STR("${%.*s\000}", 2, v), (*(string*)map_get(pc->vars, v, &(string[]){ (string){.str=(byteptr)""} })));
	}
	return string_trim_space(r);
}

VV_LOCAL_SYMBOL void v__pkgconfig__PkgConfig_setvar(v__pkgconfig__PkgConfig* pc, string line) {
	array_string kv = string_split(string_trim_space(line), tos_lit("="));
	if (kv.len == 2) {
		string k = (*(string*)/*ee elem_typ */array_get(kv, 0));
		string v = v__pkgconfig__PkgConfig_parse_line(pc, (*(string*)/*ee elem_typ */array_get(kv, 1)));
		map_set(&pc->vars, k, &(string[]) { v__pkgconfig__PkgConfig_parse_line(pc, v) });
	}
}

VV_LOCAL_SYMBOL bool v__pkgconfig__PkgConfig_parse(v__pkgconfig__PkgConfig* pc, string file) {
	Option_string _t499 = os__read_file(file);
	if (!_t499.ok) {
		string err = _t499.v_error;
		int errcode = _t499.ecode;
		return false;
	}
 	string data = *(string*) _t499.data;
	if (pc->options.debug) {
		eprintln(data);
	}
	array_string lines = string_split(data, tos_lit("\n"));
	if (pc->options.norecurse) {
		// FOR IN array
		array _t500 = lines;
		for (int _t501 = 0; _t501 < _t500.len; ++_t501) {
			string line = ((string*)_t500.data)[_t501];
			if (string_starts_with(line, tos_lit("Description: "))) {
				pc->description = v__pkgconfig__PkgConfig_parse_line(pc, string_substr(line, 13, line.len));
			}
		}
	} else {
		// FOR IN array
		array _t502 = lines;
		for (int _t503 = 0; _t503 < _t502.len; ++_t503) {
			string line = ((string*)_t502.data)[_t503];
			if (string_starts_with(line, tos_lit("#"))) {
				continue;
			}
			if (string_contains(line, tos_lit("=")) && !string_contains(line, tos_lit(" "))) {
				v__pkgconfig__PkgConfig_setvar(pc, line);
				continue;
			}
			if (string_starts_with(line, tos_lit("Description:"))) {
				pc->description = v__pkgconfig__PkgConfig_parse_line(pc, string_substr(line, 12, line.len));
			} else if (string_starts_with(line, tos_lit("Name:"))) {
				pc->name = v__pkgconfig__PkgConfig_parse_line(pc, string_substr(line, 5, line.len));
			} else if (string_starts_with(line, tos_lit("Version:"))) {
				pc->version = v__pkgconfig__PkgConfig_parse_line(pc, string_substr(line, 8, line.len));
			} else if (string_starts_with(line, tos_lit("Requires:"))) {
				pc->requires = v__pkgconfig__PkgConfig_parse_list(pc, string_substr(line, 9, line.len));
			} else if (string_starts_with(line, tos_lit("Cflags:"))) {
				pc->cflags = v__pkgconfig__PkgConfig_parse_list(pc, string_substr(line, 7, line.len));
			} else if (string_starts_with(line, tos_lit("Libs:"))) {
				pc->libs = v__pkgconfig__PkgConfig_parse_list(pc, string_substr(line, 5, line.len));
			} else if (string_starts_with(line, tos_lit("Libs.private:"))) {
				pc->libs_private = v__pkgconfig__PkgConfig_parse_list(pc, string_substr(line, 13, line.len));
			}
		}
	}
	return true;
}

VV_LOCAL_SYMBOL Option_string v__pkgconfig__PkgConfig_resolve(v__pkgconfig__PkgConfig* pc, string pkgname) {
	if (pc->paths.len == 0) {
		array_push(&pc->paths, _MOV((string[]){ string_clone(tos_lit(".")) }));
	}
	// FOR IN array
	array _t505 = pc->paths;
	for (int _t506 = 0; _t506 < _t505.len; ++_t506) {
		string path = ((string*)_t505.data)[_t506];
		string file = _STR("%.*s\000/%.*s\000.pc", 3, path, pkgname);
		if (os__exists(file)) {
			Option_string _t507;
			opt_ok2(&(string[]) { file }, (OptionBase*)(&_t507), sizeof(string));
			return _t507;
		}
	}
	Option _t508 = v_error(_STR("Cannot find \"%.*s\000\" pkgconfig file", 2, pkgname));
	return *(Option_string*)&_t508;
}

bool v__pkgconfig__atleast(string v) {
	Option_semver__Version _t509 = semver__from(_const_v__pkgconfig__version);
	if (!_t509.ok) {
		string err = _t509.v_error;
		int errcode = _t509.ecode;
		return false;
	}
 	semver__Version v0 = *(semver__Version*) _t509.data;
	Option_semver__Version _t510 = semver__from(v);
	if (!_t510.ok) {
		string err = _t510.v_error;
		int errcode = _t510.ecode;
		return false;
	}
 	semver__Version v1 = *(semver__Version*) _t510.data;
	return semver__Version_gt(v0, v1);
}

bool v__pkgconfig__PkgConfig_atleast(v__pkgconfig__PkgConfig* pc, string v) {
	Option_semver__Version _t511 = semver__from(pc->version);
	if (!_t511.ok) {
		string err = _t511.v_error;
		int errcode = _t511.ecode;
		return false;
	}
 	semver__Version v0 = *(semver__Version*) _t511.data;
	Option_semver__Version _t512 = semver__from(v);
	if (!_t512.ok) {
		string err = _t512.v_error;
		int errcode = _t512.ecode;
		return false;
	}
 	semver__Version v1 = *(semver__Version*) _t512.data;
	return semver__Version_gt(v0, v1);
}

Option_string v__pkgconfig__PkgConfig_extend(v__pkgconfig__PkgConfig* pc, v__pkgconfig__PkgConfig* pcdep) {
	// FOR IN array
	array _t513 = pcdep->cflags;
	for (int _t514 = 0; _t514 < _t513.len; ++_t514) {
		string flag = ((string*)_t513.data)[_t514];
		if (array_string_index(pc->cflags, flag) == -1) {
			array_push(&pc->cflags, _MOV((string[]){ string_clone(flag) }));
		}
	}
	// FOR IN array
	array _t516 = pcdep->libs;
	for (int _t517 = 0; _t517 < _t516.len; ++_t517) {
		string lib = ((string*)_t516.data)[_t517];
		if (array_string_index(pc->libs, lib) == -1) {
			array_push(&pc->libs, _MOV((string[]){ string_clone(lib) }));
		}
	}
	// FOR IN array
	array _t519 = pcdep->libs_private;
	for (int _t520 = 0; _t520 < _t519.len; ++_t520) {
		string lib = ((string*)_t519.data)[_t520];
		if (array_string_index(pc->libs_private, lib) == -1) {
			array_push(&pc->libs_private, _MOV((string[]){ string_clone(lib) }));
		}
	}
	Option _t522 = opt_none();
	return *(Option_string*)&_t522;
}

VV_LOCAL_SYMBOL void v__pkgconfig__PkgConfig_load_requires(v__pkgconfig__PkgConfig* pc) {
	// FOR IN array
	array _t523 = pc->requires;
	for (int _t524 = 0; _t524 < _t523.len; ++_t524) {
		string dep = ((string*)_t523.data)[_t524];
		v__pkgconfig__PkgConfig pcdep = (v__pkgconfig__PkgConfig){.options = {0},.libs = __new_array(0, 1, sizeof(string)),.libs_private = __new_array(0, 1, sizeof(string)),.cflags = __new_array(0, 1, sizeof(string)),.paths = pc->paths,.vars = new_map_1(sizeof(string)),.requires = __new_array(0, 1, sizeof(string)),.version = (string){.str=(byteptr)""},.description = (string){.str=(byteptr)""},.name = (string){.str=(byteptr)""},.modname = (string){.str=(byteptr)""},};
		Option_string _t525 = v__pkgconfig__PkgConfig_resolve(&pcdep, dep);
		if (!_t525.ok) {
			string err = _t525.v_error;
			int errcode = _t525.ecode;
			break;
		}
 		string depfile = *(string*) _t525.data;
		v__pkgconfig__PkgConfig_parse(&pcdep, depfile);
		v__pkgconfig__PkgConfig_load_requires(&pcdep);
		v__pkgconfig__PkgConfig_extend(pc, (voidptr)&/*qq*/pcdep);
	}
}

VV_LOCAL_SYMBOL void v__pkgconfig__PkgConfig_add_path(v__pkgconfig__PkgConfig* pc, string path) {
	string p = (string_ends_with(path, tos_lit("/")) ? (string_substr(path, 0, path.len - 1)) : (path));
	if (array_string_index(pc->paths, p) == -1) {
		array_push(&pc->paths, _MOV((string[]){ string_clone(p) }));
	}
}

VV_LOCAL_SYMBOL void v__pkgconfig__PkgConfig_load_paths(v__pkgconfig__PkgConfig* pc) {
	// FOR IN array
	array _t527 = _const_v__pkgconfig__default_paths;
	for (int _t528 = 0; _t528 < _t527.len; ++_t528) {
		string path = ((string*)_t527.data)[_t528];
		v__pkgconfig__PkgConfig_add_path(pc, path);
	}
	// FOR IN array
	array _t529 = string_split(pc->options.path, tos_lit(":"));
	for (int _t530 = 0; _t530 < _t529.len; ++_t530) {
		string path = ((string*)_t529.data)[_t530];
		v__pkgconfig__PkgConfig_add_path(pc, path);
	}
	string env_var = os__getenv(tos_lit("PKG_CONFIG_PATH"));
	if ((env_var).len != 0) {
		array_string env_paths = string_split(string_trim_space(env_var), tos_lit(":"));
		// FOR IN array
		array _t531 = env_paths;
		for (int _t532 = 0; _t532 < _t531.len; ++_t532) {
			string path = ((string*)_t531.data)[_t532];
			v__pkgconfig__PkgConfig_add_path(pc, path);
		}
	}
}

Option_v__pkgconfig__PkgConfig_ptr v__pkgconfig__load(string pkgname, v__pkgconfig__Options options) {
	v__pkgconfig__PkgConfig* pc = (v__pkgconfig__PkgConfig*)memdup(&(v__pkgconfig__PkgConfig){.options = options,.libs = __new_array(0, 1, sizeof(string)),.libs_private = __new_array(0, 1, sizeof(string)),.cflags = __new_array(0, 1, sizeof(string)),.paths = __new_array(0, 1, sizeof(string)),.vars = new_map_1(sizeof(string)),.requires = __new_array(0, 1, sizeof(string)),.version = (string){.str=(byteptr)""},.description = (string){.str=(byteptr)""},.name = (string){.str=(byteptr)""},.modname = pkgname,}, sizeof(v__pkgconfig__PkgConfig));
	v__pkgconfig__PkgConfig_load_paths(pc);
	Option_string _t533 = v__pkgconfig__PkgConfig_resolve(pc, pkgname);
	if (!_t533.ok) {
		string err = _t533.v_error;
		int errcode = _t533.ecode;
		Option _t534 = v_error(err);
		return *(Option_v__pkgconfig__PkgConfig_ptr*)&_t534;
	}
 	string file = *(string*) _t533.data;
	v__pkgconfig__PkgConfig_parse(pc, file);
	if (!options.norecurse) {
		v__pkgconfig__PkgConfig_load_requires(pc);
	}
	Option_v__pkgconfig__PkgConfig_ptr _t535;
	opt_ok2(&(v__pkgconfig__PkgConfig*[]) { pc }, (OptionBase*)(&_t535), sizeof(v__pkgconfig__PkgConfig*));
	return _t535;
}

array_string v__pkgconfig__list() {
	v__pkgconfig__PkgConfig* pc = (v__pkgconfig__PkgConfig*)memdup(&(v__pkgconfig__PkgConfig){.options = (v__pkgconfig__Options){.path = (string){.str=(byteptr)""},.debug = 0,.norecurse = 0,},.libs = __new_array(0, 1, sizeof(string)),.libs_private = __new_array(0, 1, sizeof(string)),.cflags = __new_array(0, 1, sizeof(string)),.paths = __new_array(0, 1, sizeof(string)),.vars = new_map_1(sizeof(string)),.requires = __new_array(0, 1, sizeof(string)),.version = (string){.str=(byteptr)""},.description = (string){.str=(byteptr)""},.name = (string){.str=(byteptr)""},.modname = (string){.str=(byteptr)""},}, sizeof(v__pkgconfig__PkgConfig));
	v__pkgconfig__PkgConfig_load_paths(pc);
	array_string modules = __new_array_with_default(0, 0, sizeof(string), 0);
	// FOR IN array
	array _t536 = pc->paths;
	for (int _t537 = 0; _t537 < _t536.len; ++_t537) {
		string path = ((string*)_t536.data)[_t537];
		Option_array_string _t538 = os__ls(path);
		if (!_t538.ok) {
			string err = _t538.v_error;
			int errcode = _t538.ecode;
			continue;
		}
 		array_string files = *(array_string*) _t538.data;
		// FOR IN array
		array _t539 = files;
		for (int _t540 = 0; _t540 < _t539.len; ++_t540) {
			string file = ((string*)_t539.data)[_t540];
			if (string_ends_with(file, tos_lit(".pc"))) {
				string name = string_replace(file, tos_lit(".pc"), tos_lit(""));
				if (array_string_index(modules, name) == -1) {
					array_push(&modules, _MOV((string[]){ string_clone(name) }));
				}
			}
		}
	}
	return modules;
}

string vweb__tmpl__compile_file(string path, string fn_name) {
	Option_string _t542 = os__read_file(path);
	if (!_t542.ok) {
		string err = _t542.v_error;
		int errcode = _t542.ecode;
		v_panic(tos_lit("html failed"));
	}
 	string html = *(string*) _t542.data;
	return vweb__tmpl__compile_template(html, fn_name);
}

string vweb__tmpl__compile_template(string html_, string fn_name) {
	string html = string_trim_space(html_);
	string header = tos_lit("");
	string footer = tos_lit("");
	if (os__exists(tos_lit("templates/header.html")) && string_contains(html, tos_lit("@header"))) {
		Option_string _t543 = os__read_file(tos_lit("templates/header.html"));
		if (!_t543.ok) {
			string err = _t543.v_error;
			int errcode = _t543.ecode;
			v_panic(tos_lit("reading file templates/header.html failed"));
		}
 		string h = *(string*) _t543.data;
		header = string_replace(string_trim_space(h), tos_lit("\'"), tos_lit("\""));
		html = string_add(header, html);
	}
	if (os__exists(tos_lit("templates/footer.html")) && string_contains(html, tos_lit("@footer"))) {
		Option_string _t544 = os__read_file(tos_lit("templates/footer.html"));
		if (!_t544.ok) {
			string err = _t544.v_error;
			int errcode = _t544.ecode;
			v_panic(tos_lit("reading file templates/footer.html failed"));
		}
 		string f = *(string*) _t544.data;
		footer = string_replace(string_trim_space(f), tos_lit("\'"), tos_lit("\""));
		html = /*f*/string_add(html, footer);
	}
	array_string lines = string_split_into_lines(html);
	strings__Builder s = strings__new_builder(1000);
	strings__Builder_writeln(&s, _STR("\nimport strings\n// === vweb html template ===\nfn vweb_tmpl_%.*s\000() {\nmut sb := strings.new_builder(%"PRId32"\000)\n\nheader := \' \' // TODO remove\n_ = header\nfooter := \' \' // TODO remove\n_ = footer\n\n", 3, fn_name, lines.len * 30));
	strings__Builder_write(&s, _const_vweb__tmpl__str_start);
	vweb__tmpl__State state = vweb__tmpl__State_html;
	bool in_span = false;
	for (int i = 0; i < lines.len; i++) {
		string line = string_trim_space((*(string*)/*ee elem_typ */array_get(lines, i)));
		if (string_eq(line, tos_lit("<style>"))) {
			state = vweb__tmpl__State_css;
		} else if (string_eq(line, tos_lit("</style>"))) {
			state = vweb__tmpl__State_html;
		} else if (string_eq(line, tos_lit("<script>"))) {
			state = vweb__tmpl__State_js;
		} else if (string_eq(line, tos_lit("</script>"))) {
			state = vweb__tmpl__State_html;
		}
		if (string_contains(line, tos_lit("@include ")) && false) {
			Option_int _t545 = string_index(line, tos_lit("@include "));
			if (!_t545.ok) {
				string err = _t545.v_error;
				int errcode = _t545.ecode;
				continue;
			}
 			int pos = *(int*) _t545.data;
			string file_name = string_substr(line, pos + 9, line.len);
			string file_path = os__join_path(tos_lit("templates"), (varg_string){.len=1,.args={_STR("%.*s\000.html", 2, file_name)}});
			Option_string _t546 = os__read_file(file_path);
			if (!_t546.ok) {
				string err = _t546.v_error;
				int errcode = _t546.ecode;
				v_panic(_STR("reading file %.*s\000 failed", 2, file_name));
			}
 			string file_content = *(string*) _t546.data;
			file_content = string_replace(file_content, tos_lit("\'"), tos_lit("\""));
			array_string lines2 = string_split_into_lines(file_content);
			// FOR IN array
			array _t547 = lines2;
			for (int _t548 = 0; _t548 < _t547.len; ++_t548) {
				string l = ((string*)_t547.data)[_t548];
				array_insert(&lines, i + 1, &(string[]){string_clone(l)});
			}
			continue;
		} else if (string_contains(line, tos_lit("@js "))) {
			Option_int _t549 = string_index(line, tos_lit("@js"));
			if (!_t549.ok) {
				string err = _t549.v_error;
				int errcode = _t549.ecode;
				continue;
			}
 			int pos = *(int*) _t549.data;
			strings__Builder_write(&s, tos_lit("<script src=\""));
			strings__Builder_write(&s, string_substr(line, pos + 5, line.len - 1));
			strings__Builder_writeln(&s, tos_lit("\"></script>"));
		} else if (string_contains(line, tos_lit("@css "))) {
			Option_int _t550 = string_index(line, tos_lit("@css"));
			if (!_t550.ok) {
				string err = _t550.v_error;
				int errcode = _t550.ecode;
				continue;
			}
 			int pos = *(int*) _t550.data;
			strings__Builder_write(&s, tos_lit("<link href=\""));
			strings__Builder_write(&s, string_substr(line, pos + 6, line.len - 1));
			strings__Builder_writeln(&s, tos_lit("\" rel=\"stylesheet\" type=\"text/css\">"));
		} else if (string_contains(line, tos_lit("@if "))) {
			strings__Builder_writeln(&s, _const_vweb__tmpl__str_end);
			Option_int _t551 = string_index(line, tos_lit("@if"));
			if (!_t551.ok) {
				string err = _t551.v_error;
				int errcode = _t551.ecode;
				continue;
			}
 			int pos = *(int*) _t551.data;
			strings__Builder_writeln(&s, string_add(string_add(tos_lit("if "), string_substr(line, pos + 4, line.len)), tos_lit("{")));
			strings__Builder_writeln(&s, _const_vweb__tmpl__str_start);
		} else if (string_contains(line, tos_lit("@end"))) {
			strings__Builder_writeln(&s, _const_vweb__tmpl__str_end);
			strings__Builder_writeln(&s, tos_lit("}"));
			strings__Builder_writeln(&s, _const_vweb__tmpl__str_start);
		} else if (string_contains(line, tos_lit("@else"))) {
			strings__Builder_writeln(&s, _const_vweb__tmpl__str_end);
			strings__Builder_writeln(&s, tos_lit(" } else { "));
			strings__Builder_writeln(&s, _const_vweb__tmpl__str_start);
		} else if (string_contains(line, tos_lit("@for"))) {
			strings__Builder_writeln(&s, _const_vweb__tmpl__str_end);
			Option_int _t552 = string_index(line, tos_lit("@for"));
			if (!_t552.ok) {
				string err = _t552.v_error;
				int errcode = _t552.ecode;
				continue;
			}
 			int pos = *(int*) _t552.data;
			strings__Builder_writeln(&s, string_add(string_add(tos_lit("for "), string_substr(line, pos + 4, line.len)), tos_lit("{")));
			strings__Builder_writeln(&s, _const_vweb__tmpl__str_start);
		} else if (state == vweb__tmpl__State_html && string_contains(line, tos_lit("span.")) && string_ends_with(line, tos_lit("{"))) {
			string v_class = string_trim_space(string_find_between(line, tos_lit("span."), tos_lit("{")));
			strings__Builder_writeln(&s, _STR("<span class=\"%.*s\000\">", 2, v_class));
			in_span = true;
		} else if (state == vweb__tmpl__State_html && string_contains(line, tos_lit(".")) && string_ends_with(line, tos_lit("{"))) {
			string v_class = string_trim_space(string_find_between(line, tos_lit("."), tos_lit("{")));
			strings__Builder_writeln(&s, _STR("<div class=\"%.*s\000\">", 2, v_class));
		} else if (state == vweb__tmpl__State_html && string_contains(line, tos_lit("#")) && string_ends_with(line, tos_lit("{"))) {
			string v_class = string_trim_space(string_find_between(line, tos_lit("#"), tos_lit("{")));
			strings__Builder_writeln(&s, _STR("<div id=\"%.*s\000\">", 2, v_class));
		} else if (state == vweb__tmpl__State_html && string_eq(line, tos_lit("}"))) {
			if (in_span) {
				strings__Builder_writeln(&s, tos_lit("</span>"));
				in_span = false;
			} else {
				strings__Builder_writeln(&s, tos_lit("</div>"));
			}
		} else {
			strings__Builder_writeln(&s, string_replace(string_replace(line, tos_lit("@"), tos_lit("$")), tos_lit("'"), tos_lit("\"")));
		}
	}
	strings__Builder_writeln(&s, _const_vweb__tmpl__str_end);
	strings__Builder_writeln(&s, _STR("_tmpl_res_%.*s\000 := sb.str() ", 2, fn_name));
	strings__Builder_writeln(&s, tos_lit("}"));
	strings__Builder_writeln(&s, tos_lit("// === end of vweb html template ==="));
	return strings__Builder_str(&s);
}

int runtime__nr_jobs() {
	int cpus = runtime__nr_cpus();
	int vjobs = string_int(os__getenv(tos_lit("VJOBS")));
	if (vjobs > 0) {
		cpus = vjobs;
	}
	return cpus;
}

bool runtime__is_32bit() {
	#if defined(TARGET_IS_32BIT)
	{
		return true;
	}
	#endif
	return false;
}

bool runtime__is_64bit() {
	#if defined(TARGET_IS_64BIT)
	{
		return true;
	}
	#endif
	return false;
}

bool runtime__is_little_endian() {
	#if defined(TARGET_ORDER_IS_LITTLE)
	{
		return true;
	}
	#endif
	return false;
}

bool runtime__is_big_endian() {
	#if defined(TARGET_ORDER_IS_BIG)
	{
		return true;
	}
	#endif
	return false;
}

int runtime__nr_cpus() {
	SYSTEM_INFO sinfo = (SYSTEM_INFO){.dwNumberOfProcessors = 0,};
	GetSystemInfo(&sinfo);
	int nr = ((int)(sinfo.dwNumberOfProcessors));
	if (nr == 0) {
		nr = string_int(os__getenv(tos_lit("NUMBER_OF_PROCESSORS")));
	}
	return nr;
}

string v__table__Attr_str(v__table__Attr attr) {
	string s = tos_lit("");
	if (attr.is_ctdefine) {
		s = /*f*/string_add(s, tos_lit("if "));
	}
	if (attr.is_string) {
		s = /*f*/string_add(s, _STR("'%.*s\000'", 2, attr.name));
	} else {
		s = /*f*/string_add(s, attr.name);
		if (attr.arg.len > 0) {
			s = /*f*/string_add(s, tos_lit(": "));
			if (attr.is_string_arg) {
				string a = string_replace(attr.arg, tos_lit("\\"), tos_lit("\\\\"));
				a = string_replace(a, tos_lit("'"), tos_lit("\\'"));
				s = /*f*/string_add(s, _STR("'%.*s\000'", 2, a));
			} else {
				s = /*f*/string_add(s, attr.arg);
			}
		}
	}
	return s;
}

bool array_v__table__Attr_contains(array_v__table__Attr attrs, string str) {
	// FOR IN array
	array _t553 = attrs;
	for (int _t554 = 0; _t554 < _t553.len; ++_t554) {
		v__table__Attr a = ((v__table__Attr*)_t553.data)[_t554];
		if (string_eq(a.name, str)) {
			return true;
		}
	}
	return false;
}

VV_LOCAL_SYMBOL bool v__table__Table_has_cflag(v__table__Table* table, v__cflag__CFlag flag) {
	// FOR IN array
	array _t555 = table->cflags;
	for (int _t556 = 0; _t556 < _t555.len; ++_t556) {
		v__cflag__CFlag cf = ((v__cflag__CFlag*)_t555.data)[_t556];
		if (string_eq(cf.os, flag.os) && string_eq(cf.name, flag.name) && string_eq(cf.value, flag.value)) {
			return true;
		}
	}
	return false;
}

Option_bool v__table__Table_parse_cflag(v__table__Table* table, string cflg, string mod, array_string ctimedefines) {
	array_string allowed_flags = new_array_from_c_array(8, 8, sizeof(string), _MOV((string[8]){tos_lit("framework"), tos_lit("library"), tos_lit("Wa"), tos_lit("Wl"), tos_lit("Wp"), tos_lit("I"), tos_lit("l"), tos_lit("L")}));
	string flag_orig = string_trim_space(cflg);
	string flag = flag_orig;
	if ((flag).len == 0) {
		Option _t557 = opt_none();
		return *(Option_bool*)&_t557;
	}
	string fos = tos_lit("");
	array_string allowed_os_overrides = new_array_from_c_array(6, 6, sizeof(string), _MOV((string[6]){tos_lit("linux"), tos_lit("darwin"), tos_lit("freebsd"), tos_lit("windows"), tos_lit("mingw"), tos_lit("solaris")}));
	_PUSH_MANY(&allowed_os_overrides, (ctimedefines), _t558, array_string);
	// FOR IN array
	array _t559 = allowed_os_overrides;
	for (int _t560 = 0; _t560 < _t559.len; ++_t560) {
		string os_override = ((string*)_t559.data)[_t560];
		if (!string_starts_with(flag, os_override)) {
			continue;
		}
		Option_int _t561 = string_index(flag, tos_lit(" "));
		if (!_t561.ok) {
			string err = _t561.v_error;
			int errcode = _t561.ecode;
			Option _t562 = opt_none();
			return *(Option_bool*)&_t562;
		}
 		int pos = *(int*) _t561.data;
		fos = string_trim_space(string_substr(flag, 0, pos));
		flag = string_trim_space(string_substr(flag, pos, flag.len));
	}
	for (;;) {
		string name = tos_lit("");
		string value = tos_lit("");
		if (string_at(flag, 0) == '-') {
			// FOR IN array
			array _t563 = allowed_flags;
			for (int _t564 = 0; _t564 < _t563.len; ++_t564) {
				string f = ((string*)_t563.data)[_t564];
				int i = 1 + f.len;
				if (i <= flag.len && string_eq(f, string_substr(flag, 1, i))) {
					name = string_trim_space(string_substr(flag, 0, i));
					flag = string_trim_space(string_substr(flag, i, flag.len));
					break;
				}
			}
		}
		Option_int _t565 = string_index(flag, tos_lit(" -"));
		if (!_t565.ok) {
			string err = _t565.v_error;
			int errcode = _t565.ecode;
			*(int*) _t565.data = -1;
		}
 		int index = *(int*) _t565.data;
		for (;;) {
			if (!(index > -1)) break;
			bool has_next = false;
			// FOR IN array
			array _t566 = allowed_flags;
			for (int _t567 = 0; _t567 < _t566.len; ++_t567) {
				string f = ((string*)_t566.data)[_t567];
				int i = index + 2 + f.len;
				if (i <= flag.len && string_eq(f, string_substr(flag, index + 2, i))) {
					value = string_trim_space(string_substr(flag, 0, index + 1));
					flag = string_trim_space(string_substr(flag, index + 1, flag.len));
					has_next = true;
					break;
				}
			}
			if (has_next) {
				break;
			}
			index = string_index_after(flag, tos_lit(" -"), index + 1);
		}
		if (index == -1) {
			value = string_trim_space(flag);
		}
		if (((string_eq(name, tos_lit("-I")) || string_eq(name, tos_lit("-l")) || string_eq(name, tos_lit("-L")))) && (value).len == 0) {
			string hint = (string_eq(name, tos_lit("-l")) ? (tos_lit("library name")) : (tos_lit("path")));
			Option _t568 = v_error(_STR("bad #flag `%.*s\000`: missing %.*s\000 after `%.*s\000`", 4, flag_orig, hint, name));
			return *(Option_bool*)&_t568;
		}
		v__cflag__CFlag cf = (v__cflag__CFlag){.mod = mod,.os = fos,.name = name,.value = value,.cached = (string){.str=(byteptr)""},};
		if (!v__table__Table_has_cflag(table, cf)) {
			array_push(&table->cflags, _MOV((v__cflag__CFlag[]){ cf }));
		}
		if (index == -1) {
			break;
		}
	}
	Option_bool _t570;
	opt_ok2(&(bool[]) { true }, (OptionBase*)(&_t570), sizeof(bool));
	return _t570;
}

VV_LOCAL_SYMBOL bool v__table__Fn_method_equals(v__table__Fn* f, v__table__Fn* o) {
	return array_v__table__Param_equals(array_slice(f->params, 1, f->params.len), array_slice(o->params, 1, o->params.len)) && f->return_type == o->return_type && string_eq(f->return_type_source_name, o->return_type_source_name) && f->is_variadic == o->is_variadic && f->language == o->language && f->is_generic == o->is_generic && f->is_pub == o->is_pub && string_eq(f->mod, o->mod) && string_eq(f->name, o->name);
}

VV_LOCAL_SYMBOL bool v__table__Param_equals(v__table__Param* p, v__table__Param* o) {
	return string_eq(p->name, o->name) && p->is_mut == o->is_mut && p->typ == o->typ && string_eq(p->type_source_name, o->type_source_name) && p->is_hidden == o->is_hidden;
}

VV_LOCAL_SYMBOL bool array_v__table__Param_equals(array_v__table__Param p, array_v__table__Param o) {
	if (p.len != o.len) {
		return false;
	}
	for (int i = 0; i < p.len; ++i) {
		if (!v__table__Param_equals(&(*(v__table__Param*)/*ee elem_typ */array_get(p, i)), (voidptr)&/*qq*/(*(v__table__Param*)/*ee elem_typ */array_get(o, i)))) {
			return false;
		}
	}
	return true;
}

v__table__Table* v__table__new_table() {
	v__table__Table* t = (v__table__Table*)memdup(&(v__table__Table){.types = __new_array(0, 1, sizeof(v__table__TypeSymbol)),.type_idxs = new_map_1(sizeof(int)),.fns = new_map_1(sizeof(v__table__Fn)),.imports = __new_array(0, 1, sizeof(string)),.modules = __new_array(0, 1, sizeof(string)),.cflags = __new_array(0, 1, sizeof(v__cflag__CFlag)),.redefined_fns = __new_array(0, 1, sizeof(string)),.fn_gen_types = new_map_1(sizeof(array_v__table__Type)),.cmod_prefix = (string){.str=(byteptr)""},.is_fmt = 0,}, sizeof(v__table__Table));
	v__table__Table_register_builtin_type_symbols(t);
	t->is_fmt = true;
	return t;
}

string v__table__Fn_signature(v__table__Fn* f) {
	string sig = tos_lit("");
	// FOR IN array
	array _t571 = f->params;
	for (int i = 0; i < _t571.len; ++i) {
		v__table__Param arg = ((v__table__Param*)_t571.data)[i];
		v__table__Type typ = v__table__Type_set_nr_muls(arg.typ, 0);
		sig = /*f*/string_add(sig, _STR("%"PRId32"", 1, typ));
		if (i < f->params.len - 1) {
			sig = /*f*/string_add(sig, tos_lit("_"));
		}
	}
	sig = /*f*/string_add(sig, _STR("_%"PRId32"", 1, f->return_type));
	return sig;
}

string v__table__Fn_source_signature(v__table__Fn* f) {
	string sig = tos_lit("(");
	// FOR IN array
	array _t572 = f->params;
	for (int i = 0; i < _t572.len; ++i) {
		v__table__Param arg = ((v__table__Param*)_t572.data)[i];
		if (arg.is_mut) {
			sig = /*f*/string_add(sig, tos_lit("mut "));
		}
		sig = /*f*/string_add(sig, _STR("%.*s", 1, arg.type_source_name));
		if (i < f->params.len - 1) {
			sig = /*f*/string_add(sig, tos_lit(", "));
		}
	}
	sig = /*f*/string_add(sig, tos_lit(")"));
	if (f->return_type != _const_v__table__void_type) {
		sig = /*f*/string_add(sig, _STR(" %.*s", 1, f->return_type_source_name));
	}
	return sig;
}

bool v__table__Fn_is_same_method_as(v__table__Fn* f, v__table__Fn* func) {
	if (f->return_type != func->return_type) {
		return false;
	}
	if (f->params.len != func->params.len) {
		return false;
	}
	for (int i = 1; i < f->params.len; ++i) {
		if ((*(v__table__Param*)/*ee elem_typ */array_get(f->params, i)).typ != (*(v__table__Param*)/*ee elem_typ */array_get(func->params, i)).typ) {
			return false;
		}
	}
	return true;
}

Option_v__table__Fn v__table__Table_find_fn(v__table__Table* t, string name) {
	v__table__Fn f = (*(v__table__Fn*)map_get(t->fns, name, &(v__table__Fn[]){ {0} }));
	if (f.name.str != 0) {
		Option_v__table__Fn _t573;
		opt_ok2(&(v__table__Fn[]) { f }, (OptionBase*)(&_t573), sizeof(v__table__Fn));
		return _t573;
	}
	Option _t574 = opt_none();
	return *(Option_v__table__Fn*)&_t574;
}

bool v__table__Table_known_fn(v__table__Table* t, string name) {
	Option_v__table__Fn _t575 = v__table__Table_find_fn(t, name);
	if (!_t575.ok) {
		string err = _t575.v_error;
		int errcode = _t575.ecode;
		return false;
	};
	return true;
}

void v__table__Table_register_fn(v__table__Table* t, v__table__Fn new_fn) {
	(*(v__table__Fn*)map_get_and_set(&t->fns, new_fn.name, &(v__table__Fn[]){ {0} })) = new_fn;
}

int v__table__TypeSymbol_register_method(v__table__TypeSymbol* t, v__table__Fn new_fn) {
	array_push(&t->methods, _MOV((v__table__Fn[]){ new_fn }));
	return t->methods.len - 1;
}

Option_v__table__Fn v__table__Table_register_aggregate_method(v__table__Table* t, v__table__TypeSymbol* sym, string name) {
	if (sym->kind != v__table__Kind_aggregate) {
		v_panic(_STR("Unexpected type symbol: %.*s", 1, v__table__Kind_str(sym->kind)));
	}
	v__table__Aggregate agg_info = /* as */ *(v__table__Aggregate*)__as_cast((sym->info)._346, (sym->info).typ, /*expected:*/346);
	bool found_once = false;
	v__table__Fn new_fn = (v__table__Fn){.params = __new_array(0, 1, sizeof(v__table__Param)),.return_type = 0,.return_type_source_name = (string){.str=(byteptr)""},.is_variadic = 0,.language = 0,.is_generic = 0,.is_pub = 0,.is_deprecated = 0,.is_unsafe = 0,.is_placeholder = 0,.mod = (string){.str=(byteptr)""},.ctdefine = (string){.str=(byteptr)""},.attrs = __new_array(0, 1, sizeof(v__table__Attr)),.name = (string){.str=(byteptr)""},.source_fn = 0,};
	// FOR IN array
	array _t577 = agg_info.types;
	for (int _t578 = 0; _t578 < _t577.len; ++_t578) {
		v__table__Type typ = ((v__table__Type*)_t577.data)[_t578];
		v__table__TypeSymbol* ts = v__table__Table_get_type_symbol(t, typ);
		{ /* if guard */ 
		Option_v__table__Fn _t579;
		if (_t579 = v__table__TypeSymbol_find_method(ts, name), _t579.ok) {
			v__table__Fn type_method = *(v__table__Fn*)_t579.data;
			if (!found_once) {
				found_once = true;
				new_fn = type_method;
			} else if (!v__table__Fn_method_equals(&new_fn, (voidptr)&/*qq*/type_method)) {
				Option _t580 = v_error(_STR("method `%.*s\000.%.*s\000` signature is different", 3, v__table__Table_type_to_str(t, typ), name));
				return *(Option_v__table__Fn*)&_t580;
			}
		} else {
			string err = _t579.v_error;
			int errcode = _t579.ecode;
			Option _t581 = v_error(_STR("unknown method: `%.*s\000.%.*s\000`", 3, v__table__Table_type_to_str(t, typ), name));
			return *(Option_v__table__Fn*)&_t581;
		}}
	}
	v__table__TypeSymbol_register_method(sym, new_fn);
	Option_v__table__Fn _t582;
	opt_ok2(&(v__table__Fn[]) { new_fn }, (OptionBase*)(&_t582), sizeof(v__table__Fn));
	return _t582;
}

bool v__table__Table_type_has_method(v__table__Table* t, v__table__TypeSymbol* s, string name) {
	{ /* if guard */ 
	Option_v__table__Fn _t583;
	if (_t583 = v__table__Table_type_find_method(t, s, name), _t583.ok) {
		return true;
	}}
	return false;
}

Option_v__table__Fn v__table__Table_type_find_method(v__table__Table* t, v__table__TypeSymbol* s, string name) {
	v__table__TypeSymbol* ts = s;
	for (;;) {
		{ /* if guard */ 
		Option_v__table__Fn _t584;
		if (_t584 = v__table__TypeSymbol_find_method(ts, name), _t584.ok) {
			v__table__Fn method = *(v__table__Fn*)_t584.data;
			Option_v__table__Fn _t585;
			opt_ok2(&(v__table__Fn[]) { method }, (OptionBase*)(&_t585), sizeof(v__table__Fn));
			return _t585;
		}}
		if (ts->kind == v__table__Kind_aggregate) {
			Option_v__table__Fn _t586 = v__table__Table_register_aggregate_method(t, ts, name);
			if (!_t586.ok) {
				return *(Option_v__table__Fn *)&_t586;
			}
 			v__table__Fn method = *(v__table__Fn*) _t586.data;
			Option_v__table__Fn _t587;
			opt_ok2(&(v__table__Fn[]) { method }, (OptionBase*)(&_t587), sizeof(v__table__Fn));
			return _t587;
		}
		if (ts->parent_idx == 0) {
			break;
		}
		ts = &(*(v__table__TypeSymbol*)/*ee elem_typ */array_get(t->types, ts->parent_idx));
	}
	Option _t588 = opt_none();
	return *(Option_v__table__Fn*)&_t588;
}

VV_LOCAL_SYMBOL Option_v__table__Field v__table__Table_register_aggregate_field(v__table__Table* t, v__table__TypeSymbol* sym, string name) {
	if (sym->kind != v__table__Kind_aggregate) {
		v_panic(_STR("Unexpected type symbol: %.*s", 1, v__table__Kind_str(sym->kind)));
	}
	v__table__Aggregate agg_info = /* as */ *(v__table__Aggregate*)__as_cast((sym->info)._346, (sym->info).typ, /*expected:*/346);
	bool found_once = false;
	v__table__Field new_field = (v__table__Field){.name = (string){.str=(byteptr)""},.typ = 0,.default_expr = {0},.has_default_expr = 0,.default_val = (string){.str=(byteptr)""},.attrs = __new_array(0, 1, sizeof(v__table__Attr)),.is_pub = 0,.is_mut = 0,.is_global = 0,.is_embed = 0,.embed_alias_for = (string){.str=(byteptr)""},};
	// FOR IN array
	array _t589 = agg_info.types;
	for (int _t590 = 0; _t590 < _t589.len; ++_t590) {
		v__table__Type typ = ((v__table__Type*)_t589.data)[_t590];
		v__table__TypeSymbol* ts = v__table__Table_get_type_symbol(t, typ);
		{ /* if guard */ 
		Option_v__table__Field _t591;
		if (_t591 = v__table__Table_struct_find_field(t, ts, name), _t591.ok) {
			v__table__Field type_field = *(v__table__Field*)_t591.data;
			if (!found_once) {
				found_once = true;
				new_field = type_field;
			} else if (!v__table__Field_equals(&new_field, (voidptr)&/*qq*/type_field)) {
				Option _t592 = v_error(_STR("field `%.*s\000.%.*s\000` type is different", 3, v__table__Table_type_to_str(t, typ), name));
				return *(Option_v__table__Field*)&_t592;
			}
		} else {
			string err = _t591.v_error;
			int errcode = _t591.ecode;
			Option _t593 = v_error(_STR("type `%.*s\000` has no field or method `%.*s\000`", 3, v__table__Table_type_to_str(t, typ), name));
			return *(Option_v__table__Field*)&_t593;
		}}
	}
	array_push(&agg_info.fields, _MOV((v__table__Field[]){ new_field }));
	Option_v__table__Field _t595;
	opt_ok2(&(v__table__Field[]) { new_field }, (OptionBase*)(&_t595), sizeof(v__table__Field));
	return _t595;
}

bool v__table__Table_struct_has_field(v__table__Table* t, v__table__TypeSymbol* s, string name) {
	{ /* if guard */ 
	Option_v__table__Field _t596;
	if (_t596 = v__table__Table_struct_find_field(t, s, name), _t596.ok) {
		return true;
	}}
	return false;
}

Option_v__table__Field v__table__Table_struct_find_field(v__table__Table* t, v__table__TypeSymbol* s, string name) {
	v__table__TypeSymbol* ts = s;
	for (;;) {
		if ((ts->info).typ == 155 /* v.table.Struct */) {
			{ /* if guard */ 
			Option_v__table__Field _t597;
			if (_t597 = v__table__Struct_find_field((*ts->info._155), name), _t597.ok) {
				v__table__Field field = *(v__table__Field*)_t597.data;
				Option_v__table__Field _t598;
				opt_ok2(&(v__table__Field[]) { field }, (OptionBase*)(&_t598), sizeof(v__table__Field));
				return _t598;
			}}
		} else if ((ts->info).typ == 346 /* v.table.Aggregate */) {
			{ /* if guard */ 
			Option_v__table__Field _t599;
			if (_t599 = v__table__Aggregate_find_field(&(*ts->info._346), name), _t599.ok) {
				v__table__Field field = *(v__table__Field*)_t599.data;
				Option_v__table__Field _t600;
				opt_ok2(&(v__table__Field[]) { field }, (OptionBase*)(&_t600), sizeof(v__table__Field));
				return _t600;
			}}
			Option_v__table__Field _t601 = v__table__Table_register_aggregate_field(t, ts, name);
			if (!_t601.ok) {
				string err = _t601.v_error;
				int errcode = _t601.ecode;
				Option _t602 = v_error(err);
				return *(Option_v__table__Field*)&_t602;
			}
 			v__table__Field field = *(v__table__Field*) _t601.data;
			Option_v__table__Field _t603;
			opt_ok2(&(v__table__Field[]) { field }, (OptionBase*)(&_t603), sizeof(v__table__Field));
			return _t603;
		}
		if (ts->parent_idx == 0) {
			break;
		}
		ts = &(*(v__table__TypeSymbol*)/*ee elem_typ */array_get(t->types, ts->parent_idx));
	}
	Option _t604 = opt_none();
	return *(Option_v__table__Field*)&_t604;
}

// Attr: [inline]
inline int v__table__Table_find_type_idx(v__table__Table* t, string name) {
	return (*(int*)map_get(t->type_idxs, name, &(int[]){ 0 }));
}

// Attr: [inline]
inline Option_v__table__TypeSymbol v__table__Table_find_type(v__table__Table* t, string name) {
	int idx = (*(int*)map_get(t->type_idxs, name, &(int[]){ 0 }));
	if (idx > 0) {
		Option_v__table__TypeSymbol _t605;
		opt_ok2(&(v__table__TypeSymbol[]) { (*(v__table__TypeSymbol*)/*ee elem_typ */array_get(t->types, idx)) }, (OptionBase*)(&_t605), sizeof(v__table__TypeSymbol));
		return _t605;
	}
	Option _t606 = opt_none();
	return *(Option_v__table__TypeSymbol*)&_t606;
}

// Attr: [inline]
inline v__table__TypeSymbol* v__table__Table_get_type_symbol(v__table__Table* t, v__table__Type typ) {
	int idx = v__table__Type_idx(typ);
	if (idx > 0) {
		return &(*(v__table__TypeSymbol*)/*ee elem_typ */array_get(t->types, idx));
	}
	v_panic(_STR("get_type_symbol: invalid type (typ=%"PRId32"\000 idx=%"PRId32"\000). Compiler bug. This should never happen. Please create a GitHub issue.\n", 3, typ, idx));
	return 0;
}

// Attr: [inline]
inline v__table__TypeSymbol* v__table__Table_get_final_type_symbol(v__table__Table* t, v__table__Type typ) {
	int idx = v__table__Type_idx(typ);
	if (idx > 0) {
		v__table__TypeSymbol current_type = (*(v__table__TypeSymbol*)/*ee elem_typ */array_get(t->types, idx));
		if (current_type.kind == v__table__Kind_alias) {
			v__table__Alias alias_info = /* as */ *(v__table__Alias*)__as_cast((current_type.info)._347, (current_type.info).typ, /*expected:*/347);
			return v__table__Table_get_final_type_symbol(t, alias_info.parent_type);
		}
		return &(*(v__table__TypeSymbol*)/*ee elem_typ */array_get(t->types, idx));
	}
	v_panic(_STR("get_final_type_symbol: invalid type (typ=%"PRId32"\000 idx=%"PRId32"\000). Compiler bug. This should never happen. Please create a GitHub issue.", 3, typ, idx));
	return 0;
}

// Attr: [inline]
inline string v__table__Table_get_type_name(v__table__Table* t, v__table__Type typ) {
	v__table__TypeSymbol* typ_sym = v__table__Table_get_type_symbol(t, typ);
	return typ_sym->name;
}

// Attr: [inline]
inline v__table__Type v__table__Table_unalias_num_type(v__table__Table* t, v__table__Type typ) {
	v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(t, typ);
	if (sym->kind == v__table__Kind_alias) {
		v__table__Type pt = (/* as */ *(v__table__Alias*)__as_cast((sym->info)._347, (sym->info).typ, /*expected:*/347)).parent_type;
		if (pt <= _const_v__table__f64_type && pt >= _const_v__table__void_type) {
			return pt;
		}
	}
	return typ;
}

// Attr: [inline]
inline int v__table__Table_register_builtin_type_symbol(v__table__Table* t, v__table__TypeSymbol typ) {
	int existing_idx = (*(int*)map_get(t->type_idxs, typ.name, &(int[]){ 0 }));
	if (existing_idx > 0) {
		if (existing_idx >= _const_v__table__string_type_idx) {
			if (existing_idx == _const_v__table__string_type_idx) {
				v__table__TypeSymbol existing_type = (*(v__table__TypeSymbol*)/*ee elem_typ */array_get(t->types, existing_idx));
				(*(v__table__TypeSymbol*)/*ee elem_typ */array_get(t->types, existing_idx)) = // assoc
				(v__table__TypeSymbol){
					.parent_idx = typ.parent_idx,
					.info = typ.info,
					.kind = existing_type.kind, 
					.name = typ.name,
					.source_name = typ.source_name,
					.methods = typ.methods,
					.mod = typ.mod,
					.is_public = typ.is_public,
					.is_written = typ.is_written,
					.language = typ.language,
				};
			} else {
				(*(v__table__TypeSymbol*)/*ee elem_typ */array_get(t->types, existing_idx)) = typ;
			}
		}
		return existing_idx;
	}
	return v__table__Table_register_type_symbol(t, typ);
}

// Attr: [inline]
inline int v__table__Table_register_type_symbol(v__table__Table* t, v__table__TypeSymbol typ) {
	int existing_idx = (*(int*)map_get(t->type_idxs, typ.name, &(int[]){ 0 }));
	if (existing_idx > 0) {
		v__table__TypeSymbol ex_type = (*(v__table__TypeSymbol*)/*ee elem_typ */array_get(t->types, existing_idx));
		v__table__Kind _t607 = ex_type.kind;
		if (_t607 == v__table__Kind_placeholder) {
			(*(v__table__TypeSymbol*)/*ee elem_typ */array_get(t->types, existing_idx)) = // assoc
			(v__table__TypeSymbol){
				.parent_idx = typ.parent_idx,
				.info = typ.info,
				.kind = typ.kind,
				.name = typ.name,
				.source_name = typ.source_name,
				.methods = ex_type.methods, 
				.mod = typ.mod,
				.is_public = typ.is_public,
				.is_written = typ.is_written,
				.language = typ.language,
			};
			return existing_idx;
		} else {
			if (ex_type.kind == typ.kind) {
				return existing_idx;
			}
			return -1;
		};
	}
	int typ_idx = t->types.len;
	array_push(&t->types, _MOV((v__table__TypeSymbol[]){ typ }));
	map_set(&t->type_idxs, typ.name, &(int[]) { typ_idx });
	return typ_idx;
}

bool v__table__Table_known_type(v__table__Table* t, string name) {
	Option_v__table__TypeSymbol _t609 = v__table__Table_find_type(t, name);
	if (!_t609.ok) {
		string err = _t609.v_error;
		int errcode = _t609.ecode;
		return false;
	};
	return true;
}

// Attr: [inline]
inline string v__table__Table_array_name(v__table__Table* t, v__table__Type elem_type, int nr_dims) {
	v__table__TypeSymbol* elem_type_sym = v__table__Table_get_type_symbol(t, elem_type);
	string res = tos_lit("");
	if (v__table__Type_is_ptr(elem_type)) {
		res = string_repeat(tos_lit("_ptr"), v__table__Type_nr_muls(elem_type));
	}
	if (nr_dims > 1) {
		res = /*f*/string_add(res, _STR("_%"PRId32"\000d", 2, nr_dims));
	}
	return string_add(_STR("array_%.*s", 1, elem_type_sym->name), res);
}

// Attr: [inline]
inline string v__table__Table_array_source_name(v__table__Table* t, v__table__Type elem_type) {
	v__table__TypeSymbol* elem_type_sym = v__table__Table_get_type_symbol(t, elem_type);
	string ptr = (v__table__Type_is_ptr(elem_type) ? (tos_lit("&")) : (tos_lit("")));
	return _STR("[]%.*s\000%.*s", 2, ptr, elem_type_sym->source_name);
}

// Attr: [inline]
inline string v__table__Table_array_fixed_name(v__table__Table* t, v__table__Type elem_type, int size, int nr_dims) {
	v__table__TypeSymbol* elem_type_sym = v__table__Table_get_type_symbol(t, elem_type);
	string res = tos_lit("");
	if (v__table__Type_is_ptr(elem_type)) {
		res = tos_lit("_ptr");
	}
	if (nr_dims > 1) {
		res = /*f*/string_add(res, _STR("_%"PRId32"\000d", 2, nr_dims));
	}
	return string_add(_STR("array_fixed_%.*s\000_%"PRId32"", 2, elem_type_sym->name, size), res);
}

// Attr: [inline]
inline string v__table__Table_array_fixed_source_name(v__table__Table* t, v__table__Type elem_type, int size) {
	v__table__TypeSymbol* elem_type_sym = v__table__Table_get_type_symbol(t, elem_type);
	string ptr = (v__table__Type_is_ptr(elem_type) ? (tos_lit("&")) : (tos_lit("")));
	return _STR("[%"PRId32"\000]%.*s\000%.*s", 3, size, ptr, elem_type_sym->source_name);
}

// Attr: [inline]
inline string v__table__Table_chan_name(v__table__Table* t, v__table__Type elem_type, bool is_mut) {
	v__table__TypeSymbol* elem_type_sym = v__table__Table_get_type_symbol(t, elem_type);
	string suffix = tos_lit("");
	if (is_mut) {
		suffix = tos_lit("_mut");
	} else if (v__table__Type_is_ptr(elem_type)) {
		suffix = tos_lit("_ptr");
	}
	return string_add(_STR("chan_%.*s", 1, elem_type_sym->name), suffix);
}

// Attr: [inline]
inline string v__table__Table_chan_source_name(v__table__Table* t, v__table__Type elem_type, bool is_mut) {
	v__table__TypeSymbol* elem_type_sym = v__table__Table_get_type_symbol(t, elem_type);
	string ptr = tos_lit("");
	if (is_mut) {
		ptr = tos_lit("mut ");
	} else if (v__table__Type_is_ptr(elem_type)) {
		ptr = tos_lit("&");
	}
	return _STR("chan %.*s\000%.*s", 2, ptr, elem_type_sym->source_name);
}

// Attr: [inline]
inline string v__table__Table_map_name(v__table__Table* t, v__table__Type key_type, v__table__Type value_type) {
	v__table__TypeSymbol* key_type_sym = v__table__Table_get_type_symbol(t, key_type);
	v__table__TypeSymbol* value_type_sym = v__table__Table_get_type_symbol(t, value_type);
	string suffix = (v__table__Type_is_ptr(value_type) ? (tos_lit("_ptr")) : (tos_lit("")));
	return string_add(_STR("map_%.*s\000_%.*s", 2, key_type_sym->name, value_type_sym->name), suffix);
}

// Attr: [inline]
inline string v__table__Table_map_source_name(v__table__Table* t, v__table__Type key_type, v__table__Type value_type) {
	v__table__TypeSymbol* key_type_sym = v__table__Table_get_type_symbol(t, key_type);
	v__table__TypeSymbol* value_type_sym = v__table__Table_get_type_symbol(t, value_type);
	string ptr = (v__table__Type_is_ptr(value_type) ? (tos_lit("&")) : (tos_lit("")));
	return _STR("map[%.*s\000]%.*s\000%.*s", 3, key_type_sym->source_name, ptr, value_type_sym->source_name);
}

int v__table__Table_find_or_register_chan(v__table__Table* t, v__table__Type elem_type, bool is_mut) {
	string name = v__table__Table_chan_name(t, elem_type, is_mut);
	string source_name = v__table__Table_chan_source_name(t, elem_type, is_mut);
	int existing_idx = (*(int*)map_get(t->type_idxs, name, &(int[]){ 0 }));
	if (existing_idx > 0) {
		return existing_idx;
	}
	v__table__TypeSymbol chan_typ = (v__table__TypeSymbol){.parent_idx = _const_v__table__chan_type_idx,.info = /* sum type cast 4 */ (v__table__TypeInfo){._348 = memdup(&(v__table__Chan[]){(v__table__Chan){.elem_type = elem_type,.is_mut = is_mut,}}, sizeof(v__table__Chan)), .typ = 348 /* v.table.Chan */},.kind = v__table__Kind_chan,.name = name,.source_name = source_name,.methods = __new_array(0, 1, sizeof(v__table__Fn)),.mod = (string){.str=(byteptr)""},.is_public = 0,.is_written = 0,.language = 0,};
	return v__table__Table_register_type_symbol(t, chan_typ);
}

int v__table__Table_find_or_register_map(v__table__Table* t, v__table__Type key_type, v__table__Type value_type) {
	string name = v__table__Table_map_name(t, key_type, value_type);
	string source_name = v__table__Table_map_source_name(t, key_type, value_type);
	int existing_idx = (*(int*)map_get(t->type_idxs, name, &(int[]){ 0 }));
	if (existing_idx > 0) {
		return existing_idx;
	}
	v__table__TypeSymbol map_typ = (v__table__TypeSymbol){.parent_idx = _const_v__table__map_type_idx,.info = /* sum type cast 4 */ (v__table__TypeInfo){._349 = memdup(&(v__table__Map[]){(v__table__Map){.key_type = key_type,.value_type = value_type,}}, sizeof(v__table__Map)), .typ = 349 /* v.table.Map */},.kind = v__table__Kind_map,.name = name,.source_name = source_name,.methods = __new_array(0, 1, sizeof(v__table__Fn)),.mod = (string){.str=(byteptr)""},.is_public = 0,.is_written = 0,.language = 0,};
	return v__table__Table_register_type_symbol(t, map_typ);
}

int v__table__Table_find_or_register_array(v__table__Table* t, v__table__Type elem_type, int nr_dims, string mod) {
	string name = v__table__Table_array_name(t, elem_type, nr_dims);
	string source_name = v__table__Table_array_source_name(t, elem_type);
	int existing_idx = (*(int*)map_get(t->type_idxs, name, &(int[]){ 0 }));
	if (existing_idx > 0) {
		return existing_idx;
	}
	v__table__TypeSymbol array_type = (v__table__TypeSymbol){
		.parent_idx = _const_v__table__array_type_idx,
		.info = /* sum type cast 4 */ (v__table__TypeInfo){._350 = memdup(&(v__table__Array[]){(v__table__Array){.nr_dims = nr_dims,.elem_type = elem_type,}}, sizeof(v__table__Array)), .typ = 350 /* v.table.Array */},
		.kind = v__table__Kind_array,
		.name = name,
		.source_name = source_name,
		.methods = __new_array(0, 1, sizeof(v__table__Fn)),
		.mod = mod,
		.is_public = 0,
		.is_written = 0,
		.language = 0,
	};
	return v__table__Table_register_type_symbol(t, array_type);
}

int v__table__Table_find_or_register_array_fixed(v__table__Table* t, v__table__Type elem_type, int size, int nr_dims) {
	string name = v__table__Table_array_fixed_name(t, elem_type, size, nr_dims);
	string source_name = v__table__Table_array_fixed_source_name(t, elem_type, size);
	int existing_idx = (*(int*)map_get(t->type_idxs, name, &(int[]){ 0 }));
	if (existing_idx > 0) {
		return existing_idx;
	}
	v__table__TypeSymbol array_fixed_type = (v__table__TypeSymbol){.parent_idx = 0,.info = /* sum type cast 4 */ (v__table__TypeInfo){._351 = memdup(&(v__table__ArrayFixed[]){(v__table__ArrayFixed){.nr_dims = nr_dims,.size = size,.elem_type = elem_type,}}, sizeof(v__table__ArrayFixed)), .typ = 351 /* v.table.ArrayFixed */},.kind = v__table__Kind_array_fixed,.name = name,.source_name = source_name,.methods = __new_array(0, 1, sizeof(v__table__Fn)),.mod = (string){.str=(byteptr)""},.is_public = 0,.is_written = 0,.language = 0,};
	return v__table__Table_register_type_symbol(t, array_fixed_type);
}

int v__table__Table_find_or_register_multi_return(v__table__Table* t, array_v__table__Type mr_typs) {
	string name = tos_lit("multi_return");
	string source_name = tos_lit("(");
	// FOR IN array
	array _t610 = mr_typs;
	for (int i = 0; i < _t610.len; ++i) {
		v__table__Type mr_typ = ((v__table__Type*)_t610.data)[i];
		v__table__TypeSymbol* mr_type_sym = v__table__Table_get_type_symbol(t, mr_typ);
		name = /*f*/string_add(name, _STR("_%.*s", 1, mr_type_sym->name));
		source_name = /*f*/string_add(source_name, mr_type_sym->source_name);
		if (i < mr_typs.len - 1) {
			source_name = /*f*/string_add(source_name, tos_lit(", "));
		}
	}
	source_name = /*f*/string_add(source_name, tos_lit(")"));
	int existing_idx = (*(int*)map_get(t->type_idxs, name, &(int[]){ 0 }));
	if (existing_idx > 0) {
		return existing_idx;
	}
	v__table__TypeSymbol mr_type = (v__table__TypeSymbol){.parent_idx = 0,.info = /* sum type cast 4 */ (v__table__TypeInfo){._352 = memdup(&(v__table__MultiReturn[]){(v__table__MultiReturn){.types = mr_typs,}}, sizeof(v__table__MultiReturn)), .typ = 352 /* v.table.MultiReturn */},.kind = v__table__Kind_multi_return,.name = name,.source_name = source_name,.methods = __new_array(0, 1, sizeof(v__table__Fn)),.mod = (string){.str=(byteptr)""},.is_public = 0,.is_written = 0,.language = 0,};
	return v__table__Table_register_type_symbol(t, mr_type);
}

int v__table__Table_find_or_register_fn_type(v__table__Table* t, string mod, v__table__Fn f, bool is_anon, bool has_decl) {
	string name = (f.name.len == 0 ? (_STR("anon_fn_%.*s", 1, v__table__Fn_signature(&f))) : (string_clone(f.name)));
	string source_name = (f.name.len == 0 ? (_STR("fn %.*s", 1, v__table__Fn_source_signature(&f))) : (string_clone(f.name)));
	bool anon = f.name.len == 0 || is_anon;
	return v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){.parent_idx = 0,.info = /* sum type cast 4 */ (v__table__TypeInfo){._353 = memdup(&(v__table__FnType[]){(v__table__FnType){.is_anon = anon,.has_decl = has_decl,.func = f,}}, sizeof(v__table__FnType)), .typ = 353 /* v.table.FnType */},.kind = v__table__Kind_function,.name = name,.source_name = source_name,.methods = __new_array(0, 1, sizeof(v__table__Fn)),.mod = mod,.is_public = 0,.is_written = 0,.language = 0,});
}

int v__table__Table_add_placeholder_type(v__table__Table* t, string name, v__table__Language language) {
	string modname = tos_lit("");
	if (string_contains(name, tos_lit("."))) {
		modname = string_all_before_last(name, tos_lit("."));
	}
	v__table__TypeSymbol ph_type = (v__table__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__table__Kind_placeholder,.name = name,.source_name = name,.methods = __new_array(0, 1, sizeof(v__table__Fn)),.mod = modname,.is_public = 0,.is_written = 0,.language = language,};
	return v__table__Table_register_type_symbol(t, ph_type);
}

// Attr: [inline]
inline v__table__Type v__table__Table_value_type(v__table__Table* t, v__table__Type typ) {
	v__table__TypeSymbol* typ_sym = v__table__Table_get_type_symbol(t, typ);
	if (v__table__Type_has_flag(typ, v__table__TypeFlag_variadic)) {
		return v__table__Type_clear_flag(typ, v__table__TypeFlag_variadic);
	}
	if (typ_sym->kind == v__table__Kind_array) {
		v__table__Array info = /* as */ *(v__table__Array*)__as_cast((typ_sym->info)._350, (typ_sym->info).typ, /*expected:*/350);
		return info.elem_type;
	}
	if (typ_sym->kind == v__table__Kind_array_fixed) {
		v__table__ArrayFixed info = /* as */ *(v__table__ArrayFixed*)__as_cast((typ_sym->info)._351, (typ_sym->info).typ, /*expected:*/351);
		return info.elem_type;
	}
	if (typ_sym->kind == v__table__Kind_map) {
		v__table__Map info = /* as */ *(v__table__Map*)__as_cast((typ_sym->info)._349, (typ_sym->info).typ, /*expected:*/349);
		return info.value_type;
	}
	if (typ_sym->kind == v__table__Kind_string && v__table__Type_is_ptr(typ)) {
		return _const_v__table__string_type;
	}
	if ((typ_sym->kind == v__table__Kind_byteptr || typ_sym->kind == v__table__Kind_string)) {
		return _const_v__table__byte_type;
	}
	if (v__table__Type_is_ptr(typ)) {
		return v__table__Type_deref(typ);
	}
	if (string_eq(typ_sym->name, tos_lit("map_string"))) {
		return _const_v__table__string_type;
	}
	return _const_v__table__void_type;
}

// Attr: [inline]
inline v__table__Type v__table__Table_mktyp(v__table__Table* t, v__table__Type typ) {
	v__table__Type _t611 = typ;
	if (_t611 == _const_v__table__any_flt_type) {
		return _const_v__table__f64_type;
	} else if (_t611 == _const_v__table__any_int_type) {
		return _const_v__table__int_type;
	} else {
		return typ;
	};
	return 0;
}

string v__table__Table_qualify_module(v__table__Table* table, string mod, string file_path) {
	// FOR IN array
	array _t612 = table->imports;
	for (int _t613 = 0; _t613 < _t612.len; ++_t613) {
		string m = ((string*)_t612.data)[_t613];
		if (string_contains(m, tos_lit(".")) && string_contains(m, mod)) {
			array_string m_parts = string_split(m, tos_lit("."));
			string m_path = array_string_join(m_parts, _const_os__path_separator);
			if (string_eq(mod, (*(string*)/*ee elem_typ */array_get(m_parts, m_parts.len - 1))) && string_contains(file_path, m_path)) {
				return m;
			}
		}
	}
	return mod;
}

void v__table__Table_register_fn_gen_type(v__table__Table* table, string fn_name, v__table__Type typ) {
	array_v__table__Type a = (*(array_v__table__Type*)map_get(table->fn_gen_types, fn_name, &(array_v__table__Type[]){ __new_array(0, 1, sizeof(v__table__Type)) }));
	if (_IN(v__table__Type, typ, a)) {
		return;
	}
	array_push(&a, _MOV((v__table__Type[]){ typ }));
	map_set(&table->fn_gen_types, fn_name, &(array_v__table__Type[]) { a });
}

bool v__table__Table_sumtype_has_variant(v__table__Table* table, v__table__Type parent, v__table__Type variant) {
	v__table__TypeSymbol* parent_sym = v__table__Table_get_type_symbol(table, parent);
	if (parent_sym->kind == v__table__Kind_sum_type) {
		v__table__SumType parent_info = /* as */ *(v__table__SumType*)__as_cast((parent_sym->info)._354, (parent_sym->info).typ, /*expected:*/354);
		// FOR IN array
		array _t615 = parent_info.variants;
		for (int _t616 = 0; _t616 < _t615.len; ++_t616) {
			v__table__Type v = ((v__table__Type*)_t615.data)[_t616];
			if (v__table__Type_idx(v) == v__table__Type_idx(variant)) {
				return true;
			}
		}
	}
	return false;
}

array_string v__table__Table_known_type_names(v__table__Table* table) {
	array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	// FOR IN map
	map_string_int _t618 = table->type_idxs;
	for (int _t617 = 0; _t617 < _t618.key_values.len; ++_t617) {
		if (_t618.key_values.keys[_t617].str == 0) {continue;}
		int idx = (*(int*)(void*)(_t618.key_values.values + _t617 * (u32)(_t618.value_bytes)));
		if (idx == 0) {
			continue;
		}
		array_push(&res, _MOV((string[]){ string_clone(v__table__Table_type_to_str(table, idx)) }));
	}
	return res;
}

// TypeDecl
// TypeDecl
string v__table__ShareType_str(v__table__ShareType t) {
	v__table__ShareType _t620 = t;
	if (_t620 == v__table__ShareType_mut_t) {
		return tos_lit("mut");
	} else if (_t620 == v__table__ShareType_shared_t) {
		return tos_lit("shared");
	} else if (_t620 == v__table__ShareType_atomic_t) {
		return tos_lit("atomic");
	};
	return (string){.str=(byteptr)""};
}

string v__table__Type_atomic_typename(v__table__Type t) {
	int idx = v__table__Type_idx(t);
	int _t621 = idx;
	if (_t621 == _const_v__table__u32_type_idx) {
		return tos_lit("atomic_uint");
	} else if (_t621 == _const_v__table__int_type_idx) {
		return tos_lit("atomic_int");
	} else if (_t621 == _const_v__table__u64_type_idx) {
		return tos_lit("atomic_ullong");
	} else if (_t621 == _const_v__table__i64_type_idx) {
		return tos_lit("atomic_llong");
	} else {
		return tos_lit("unknown_atomic");
	};
	return (string){.str=(byteptr)""};
}

v__table__ShareType v__table__sharetype_from_flags(bool is_shared, bool is_atomic) {
	return ((v__table__ShareType)(((((int)(is_atomic)) << 1) | ((int)(is_shared)))));
}

v__table__ShareType v__table__Type_share(v__table__Type t) {
	return v__table__sharetype_from_flags(v__table__Type_has_flag(t, v__table__TypeFlag_shared_f), v__table__Type_has_flag(t, v__table__TypeFlag_atomic_f));
}

bool array_v__table__Type_contains(array_v__table__Type types, v__table__Type typ) {
	// FOR IN array
	array _t622 = types;
	for (int _t623 = 0; _t623 < _t622.len; ++_t623) {
		v__table__Type t = ((v__table__Type*)_t622.data)[_t623];
		if (((int)(typ)) == ((int)(t))) {
			return true;
		}
	}
	return false;
}

// Attr: [inline]
inline int v__table__Type_idx(v__table__Type t) {
	return (((u16)(t)) & 0xffff);
}

// Attr: [inline]
inline bool v__table__Type_is_void(v__table__Type t) {
	return t == _const_v__table__void_type;
}

// Attr: [inline]
inline bool v__table__Type_is_full(v__table__Type t) {
	return t != 0 && t != _const_v__table__void_type;
}

// Attr: [inline]
inline int v__table__Type_nr_muls(v__table__Type t) {
	return ((((int)(t)) >> 16) & 0xff);
}

// Attr: [inline]
inline bool v__table__Type_is_ptr(v__table__Type t) {
	return ((((int)(t)) >> 16) & 0xff) > 0;
}

// Attr: [inline]
inline v__table__Type v__table__Type_set_nr_muls(v__table__Type t, int nr_muls) {
	if (nr_muls < 0 || nr_muls > 255) {
		v_panic(tos_lit("set_nr_muls: nr_muls must be between 0 & 255"));
	}
	return ((((int)(t)) & 0xff00ffff) | (nr_muls << 16));
}

// Attr: [inline]
inline v__table__Type v__table__Type_to_ptr(v__table__Type t) {
	int nr_muls = ((((int)(t)) >> 16) & 0xff);
	if (nr_muls == 255) {
		v_panic(tos_lit("to_ptr: nr_muls is already at max of 255"));
	}
	return ((((int)(t)) & 0xff00ffff) | ((nr_muls + 1) << 16));
}

// Attr: [inline]
inline v__table__Type v__table__Type_deref(v__table__Type t) {
	int nr_muls = ((((int)(t)) >> 16) & 0xff);
	if (nr_muls == 0) {
		v_panic(_STR("deref: type `%"PRId32"\000` is not a pointer", 2, t));
	}
	return ((((int)(t)) & 0xff00ffff) | ((nr_muls - 1) << 16));
}

// Attr: [inline]
inline v__table__Type v__table__Type_set_flag(v__table__Type t, v__table__TypeFlag flag) {
	return (((int)(t)) | (1 << (((int)(flag)) + 24)));
}

// Attr: [inline]
inline v__table__Type v__table__Type_clear_flag(v__table__Type t, v__table__TypeFlag flag) {
	return (((int)(t)) & ~(1 << (((int)(flag)) + 24)));
}

// Attr: [inline]
inline v__table__Type v__table__Type_clear_flags(v__table__Type t) {
	return (((int)(t)) & 0xffffff);
}

// Attr: [inline]
inline bool v__table__Type_has_flag(v__table__Type t, v__table__TypeFlag flag) {
	return (((int)(t)) & (1 << (((int)(flag)) + 24))) > 0;
}

array_string v__table__TypeSymbol_debug(v__table__TypeSymbol ts) {
	array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	array_push(&res, _MOV((string[]){ string_clone(_STR("parent_idx: %"PRId32"", 1, ts.parent_idx)) }));
	array_push(&res, _MOV((string[]){ string_clone(_STR("mod: %.*s", 1, ts.mod)) }));
	array_push(&res, _MOV((string[]){ string_clone(_STR("name: %.*s", 1, ts.name)) }));
	array_push(&res, _MOV((string[]){ string_clone(_STR("source_name: %.*s", 1, ts.source_name)) }));
	array_push(&res, _MOV((string[]){ string_clone(_STR("info: %.*s", 1, v__table__TypeInfo_str(ts.info))) }));
	array_push(&res, _MOV((string[]){ string_clone(_STR("kind: %.*s", 1, v__table__Kind_str(ts.kind))) }));
	array_push(&res, _MOV((string[]){ string_clone(_STR("is_public: %.*s", 1, ts.is_public ? _SLIT("true") : _SLIT("false"))) }));
	array_push(&res, _MOV((string[]){ string_clone(_STR("is_written: %.*s", 1, ts.is_written ? _SLIT("true") : _SLIT("false"))) }));
	array_push(&res, _MOV((string[]){ string_clone(_STR("language: %.*s", 1, v__table__Language_str(ts.language))) }));

	int _t634_len = ts.methods.len;
	array_string _t634 = __new_array(0, _t634_len, sizeof(string));
	for (int _t635 = 0; _t635 < _t634_len; ++_t635) {
		v__table__Fn it = ((v__table__Fn*) ts.methods.data)[_t635];
		string ti = v__table__Fn_str(it);
		array_push(&_t634, &ti);
	}
		array_push(&res, _MOV((string[]){ string_clone(string_add(_STR("methods (%"PRId32"\000): ", 2, ts.methods.len), array_string_join(_t634, tos_lit(", ")))) }));
	return res;
}

array_string v__table__Type_debug(v__table__Type t) {
	array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	array_push(&res, _MOV((string[]){ string_clone(_STR("idx: %5"PRId32"", 1, v__table__Type_idx(t))) }));
	array_push(&res, _MOV((string[]){ string_clone(_STR("type: %10"PRId32"", 1, t)) }));
	array_push(&res, _MOV((string[]){ string_clone(_STR("nr_muls: %"PRId32"", 1, v__table__Type_nr_muls(t))) }));
	if (v__table__Type_has_flag(t, v__table__TypeFlag_optional)) {
		array_push(&res, _MOV((string[]){ string_clone(tos_lit("optional")) }));
	}
	if (v__table__Type_has_flag(t, v__table__TypeFlag_variadic)) {
		array_push(&res, _MOV((string[]){ string_clone(tos_lit("variadic")) }));
	}
	if (v__table__Type_has_flag(t, v__table__TypeFlag_generic)) {
		array_push(&res, _MOV((string[]){ string_clone(tos_lit("generic")) }));
	}
	if (v__table__Type_has_flag(t, v__table__TypeFlag_shared_f)) {
		array_push(&res, _MOV((string[]){ string_clone(tos_lit("shared_f")) }));
	}
	if (v__table__Type_has_flag(t, v__table__TypeFlag_atomic_f)) {
		array_push(&res, _MOV((string[]){ string_clone(tos_lit("atomic_f")) }));
	}
	return res;
}

// Attr: [inline]
inline v__table__Type v__table__Type_derive(v__table__Type t, v__table__Type t_from) {
	return (((0xffff0000 & t_from)) | ((u16)(t)));
}

// Attr: [inline]
inline v__table__Type v__table__new_type(int idx) {
	if (idx < 1 || idx > 65535) {
		v_panic(tos_lit("new_type: idx must be between 1 & 65535"));
	}
	return idx;
}

// Attr: [inline]
inline v__table__Type v__table__new_type_ptr(int idx, int nr_muls) {
	if (idx < 1 || idx > 65535) {
		v_panic(tos_lit("new_type_ptr: idx must be between 1 & 65535"));
	}
	if (nr_muls < 0 || nr_muls > 255) {
		v_panic(tos_lit("new_type_ptr: nr_muls must be between 0 & 255"));
	}
	return ((nr_muls << 16) | ((u16)(idx)));
}

// Attr: [inline]
inline bool v__table__Type_is_pointer(v__table__Type typ) {
	return _IN(int, v__table__Type_idx(typ), _const_v__table__pointer_type_idxs);
}

// Attr: [inline]
inline bool v__table__Type_is_float(v__table__Type typ) {
	return _IN(int, v__table__Type_idx(typ), _const_v__table__float_type_idxs);
}

// Attr: [inline]
inline bool v__table__Type_is_int(v__table__Type typ) {
	return _IN(int, v__table__Type_idx(typ), _const_v__table__integer_type_idxs);
}

// Attr: [inline]
inline bool v__table__Type_is_signed(v__table__Type typ) {
	return _IN(int, v__table__Type_idx(typ), _const_v__table__signed_integer_type_idxs);
}

// Attr: [inline]
inline bool v__table__Type_is_unsigned(v__table__Type typ) {
	return _IN(int, v__table__Type_idx(typ), _const_v__table__unsigned_integer_type_idxs);
}

// Attr: [inline]
inline bool v__table__Type_is_any_int(v__table__Type typ) {
	return v__table__Type_idx(typ) == _const_v__table__any_int_type_idx;
}

// Attr: [inline]
inline bool v__table__Type_is_number(v__table__Type typ) {
	return _IN(int, v__table__Type_idx(typ), _const_v__table__number_type_idxs);
}

// Attr: [inline]
inline bool v__table__Type_is_string(v__table__Type typ) {
	return _IN(int, v__table__Type_idx(typ), _const_v__table__string_type_idxs);
}

v__table__Kind v__table__Table_type_kind(v__table__Table* table, v__table__Type typ) {
	if (v__table__Type_nr_muls(typ) > 0 || v__table__Type_has_flag(typ, v__table__TypeFlag_optional)) {
		return v__table__Kind_placeholder;
	}
	return v__table__Table_get_type_symbol(table, typ)->kind;
}

string v__table__TypeSymbol_str(v__table__TypeSymbol* t) {
	return string_replace(t->name, tos_lit("array_"), tos_lit("[]"));
}

// Attr: [inline]
inline v__table__Enum v__table__TypeSymbol_enum_info(v__table__TypeSymbol* t) {
	v__table__TypeInfo _t644 = t->info;
	if (_t644.typ == 355 /* v.table.Enum */) {
		return (*t->info._355);
	} else {
		v_panic(_STR("TypeSymbol.enum_info(): no enum info for type: %.*s", 1, t->name));
	};
	return (v__table__Enum){0};
}

// Attr: [inline]
inline v__table__MultiReturn v__table__TypeSymbol_mr_info(v__table__TypeSymbol* t) {
	v__table__TypeInfo _t645 = t->info;
	if (_t645.typ == 352 /* v.table.MultiReturn */) {
		return (*t->info._352);
	} else {
		v_panic(_STR("TypeSymbol.mr_info(): no multi return info for type: %.*s", 1, t->name));
	};
	return (v__table__MultiReturn){0};
}

// Attr: [inline]
inline v__table__Array v__table__TypeSymbol_array_info(v__table__TypeSymbol* t) {
	v__table__TypeInfo _t646 = t->info;
	if (_t646.typ == 350 /* v.table.Array */) {
		return (*t->info._350);
	} else {
		v_panic(_STR("TypeSymbol.array_info(): no array info for type: %.*s", 1, t->name));
	};
	return (v__table__Array){0};
}

// Attr: [inline]
inline v__table__ArrayFixed v__table__TypeSymbol_array_fixed_info(v__table__TypeSymbol* t) {
	v__table__TypeInfo _t647 = t->info;
	if (_t647.typ == 351 /* v.table.ArrayFixed */) {
		return (*t->info._351);
	} else {
		v_panic(_STR("TypeSymbol.array_fixed(): no array fixed info for type: %.*s", 1, t->name));
	};
	return (v__table__ArrayFixed){0};
}

// Attr: [inline]
inline v__table__Chan v__table__TypeSymbol_chan_info(v__table__TypeSymbol* t) {
	v__table__TypeInfo _t648 = t->info;
	if (_t648.typ == 348 /* v.table.Chan */) {
		return (*t->info._348);
	} else {
		v_panic(_STR("TypeSymbol.chan_info(): no chan info for type: %.*s", 1, t->name));
	};
	return (v__table__Chan){0};
}

// Attr: [inline]
inline v__table__Map v__table__TypeSymbol_map_info(v__table__TypeSymbol* t) {
	v__table__TypeInfo _t649 = t->info;
	if (_t649.typ == 349 /* v.table.Map */) {
		return (*t->info._349);
	} else {
		v_panic(_STR("TypeSymbol.map_info(): no map info for type: %.*s", 1, t->name));
	};
	return (v__table__Map){0};
}

// Attr: [inline]
inline v__table__Struct v__table__TypeSymbol_struct_info(v__table__TypeSymbol* t) {
	v__table__TypeInfo _t650 = t->info;
	if (_t650.typ == 155 /* v.table.Struct */) {
		return (*t->info._155);
	} else {
		v_panic(_STR("TypeSymbol.struct_info(): no struct info for type: %.*s", 1, t->name));
	};
	return (v__table__Struct){0};
}

void v__table__Table_register_builtin_type_symbols(v__table__Table* t) {
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__table__Kind_placeholder,.name = tos_lit("reserved_0"),.source_name = (string){.str=(byteptr)""},.methods = __new_array(0, 1, sizeof(v__table__Fn)),.mod = (string){.str=(byteptr)""},.is_public = 0,.is_written = 0,.language = 0,});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__table__Kind_void,.name = tos_lit("void"),.source_name = tos_lit("void"),.methods = __new_array(0, 1, sizeof(v__table__Fn)),.mod = tos_lit("builtin"),.is_public = 0,.is_written = 0,.language = 0,});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__table__Kind_voidptr,.name = tos_lit("voidptr"),.source_name = tos_lit("voidptr"),.methods = __new_array(0, 1, sizeof(v__table__Fn)),.mod = tos_lit("builtin"),.is_public = 0,.is_written = 0,.language = 0,});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__table__Kind_byteptr,.name = tos_lit("byteptr"),.source_name = tos_lit("byteptr"),.methods = __new_array(0, 1, sizeof(v__table__Fn)),.mod = tos_lit("builtin"),.is_public = 0,.is_written = 0,.language = 0,});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__table__Kind_charptr,.name = tos_lit("charptr"),.source_name = tos_lit("charptr"),.methods = __new_array(0, 1, sizeof(v__table__Fn)),.mod = tos_lit("builtin"),.is_public = 0,.is_written = 0,.language = 0,});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__table__Kind_i8,.name = tos_lit("i8"),.source_name = tos_lit("i8"),.methods = __new_array(0, 1, sizeof(v__table__Fn)),.mod = tos_lit("builtin"),.is_public = 0,.is_written = 0,.language = 0,});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__table__Kind_i16,.name = tos_lit("i16"),.source_name = tos_lit("i16"),.methods = __new_array(0, 1, sizeof(v__table__Fn)),.mod = tos_lit("builtin"),.is_public = 0,.is_written = 0,.language = 0,});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__table__Kind_int,.name = tos_lit("int"),.source_name = tos_lit("int"),.methods = __new_array(0, 1, sizeof(v__table__Fn)),.mod = tos_lit("builtin"),.is_public = 0,.is_written = 0,.language = 0,});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__table__Kind_i64,.name = tos_lit("i64"),.source_name = tos_lit("i64"),.methods = __new_array(0, 1, sizeof(v__table__Fn)),.mod = tos_lit("builtin"),.is_public = 0,.is_written = 0,.language = 0,});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__table__Kind_byte,.name = tos_lit("byte"),.source_name = tos_lit("byte"),.methods = __new_array(0, 1, sizeof(v__table__Fn)),.mod = tos_lit("builtin"),.is_public = 0,.is_written = 0,.language = 0,});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__table__Kind_u16,.name = tos_lit("u16"),.source_name = tos_lit("u16"),.methods = __new_array(0, 1, sizeof(v__table__Fn)),.mod = tos_lit("builtin"),.is_public = 0,.is_written = 0,.language = 0,});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__table__Kind_u32,.name = tos_lit("u32"),.source_name = tos_lit("u32"),.methods = __new_array(0, 1, sizeof(v__table__Fn)),.mod = tos_lit("builtin"),.is_public = 0,.is_written = 0,.language = 0,});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__table__Kind_u64,.name = tos_lit("u64"),.source_name = tos_lit("u64"),.methods = __new_array(0, 1, sizeof(v__table__Fn)),.mod = tos_lit("builtin"),.is_public = 0,.is_written = 0,.language = 0,});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__table__Kind_f32,.name = tos_lit("f32"),.source_name = tos_lit("f32"),.methods = __new_array(0, 1, sizeof(v__table__Fn)),.mod = tos_lit("builtin"),.is_public = 0,.is_written = 0,.language = 0,});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__table__Kind_f64,.name = tos_lit("f64"),.source_name = tos_lit("f64"),.methods = __new_array(0, 1, sizeof(v__table__Fn)),.mod = tos_lit("builtin"),.is_public = 0,.is_written = 0,.language = 0,});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__table__Kind_char,.name = tos_lit("char"),.source_name = tos_lit("char"),.methods = __new_array(0, 1, sizeof(v__table__Fn)),.mod = tos_lit("builtin"),.is_public = 0,.is_written = 0,.language = 0,});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__table__Kind_bool,.name = tos_lit("bool"),.source_name = tos_lit("bool"),.methods = __new_array(0, 1, sizeof(v__table__Fn)),.mod = tos_lit("builtin"),.is_public = 0,.is_written = 0,.language = 0,});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__table__Kind_none_,.name = tos_lit("none"),.source_name = tos_lit("none"),.methods = __new_array(0, 1, sizeof(v__table__Fn)),.mod = tos_lit("builtin"),.is_public = 0,.is_written = 0,.language = 0,});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__table__Kind_string,.name = tos_lit("string"),.source_name = tos_lit("string"),.methods = __new_array(0, 1, sizeof(v__table__Fn)),.mod = tos_lit("builtin"),.is_public = 0,.is_written = 0,.language = 0,});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__table__Kind_ustring,.name = tos_lit("ustring"),.source_name = tos_lit("ustring"),.methods = __new_array(0, 1, sizeof(v__table__Fn)),.mod = tos_lit("builtin"),.is_public = 0,.is_written = 0,.language = 0,});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__table__Kind_array,.name = tos_lit("array"),.source_name = tos_lit("array"),.methods = __new_array(0, 1, sizeof(v__table__Fn)),.mod = tos_lit("builtin"),.is_public = 0,.is_written = 0,.language = 0,});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__table__Kind_map,.name = tos_lit("map"),.source_name = tos_lit("map"),.methods = __new_array(0, 1, sizeof(v__table__Fn)),.mod = tos_lit("builtin"),.is_public = 0,.is_written = 0,.language = 0,});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__table__Kind_chan,.name = tos_lit("chan"),.source_name = tos_lit("chan"),.methods = __new_array(0, 1, sizeof(v__table__Fn)),.mod = tos_lit("builtin"),.is_public = 0,.is_written = 0,.language = 0,});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__table__Kind_size_t,.name = tos_lit("size_t"),.source_name = tos_lit("size_t"),.methods = __new_array(0, 1, sizeof(v__table__Fn)),.mod = tos_lit("builtin"),.is_public = 0,.is_written = 0,.language = 0,});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__table__Kind_rune,.name = tos_lit("rune"),.source_name = tos_lit("rune"),.methods = __new_array(0, 1, sizeof(v__table__Fn)),.mod = tos_lit("builtin"),.is_public = 0,.is_written = 0,.language = 0,});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__table__Kind_any,.name = tos_lit("any"),.source_name = tos_lit("any"),.methods = __new_array(0, 1, sizeof(v__table__Fn)),.mod = tos_lit("builtin"),.is_public = 0,.is_written = 0,.language = 0,});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__table__Kind_any_float,.name = tos_lit("any_float"),.source_name = tos_lit("any_float"),.methods = __new_array(0, 1, sizeof(v__table__Fn)),.mod = tos_lit("builtin"),.is_public = 0,.is_written = 0,.language = 0,});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__table__Kind_any_int,.name = tos_lit("any_int"),.source_name = tos_lit("any_int"),.methods = __new_array(0, 1, sizeof(v__table__Fn)),.mod = tos_lit("builtin"),.is_public = 0,.is_written = 0,.language = 0,});
	int map_string_string_idx = v__table__Table_find_or_register_map(t, _const_v__table__string_type, _const_v__table__string_type);
	int map_string_int_idx = v__table__Table_find_or_register_map(t, _const_v__table__string_type, _const_v__table__int_type);
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){.parent_idx = map_string_string_idx,.info = {0},.kind = v__table__Kind_alias,.name = tos_lit("map_string"),.source_name = tos_lit("map_string"),.methods = __new_array(0, 1, sizeof(v__table__Fn)),.mod = tos_lit("builtin"),.is_public = 0,.is_written = 0,.language = 0,});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){.parent_idx = map_string_int_idx,.info = {0},.kind = v__table__Kind_alias,.name = tos_lit("map_int"),.source_name = tos_lit("map_int"),.methods = __new_array(0, 1, sizeof(v__table__Fn)),.mod = tos_lit("builtin"),.is_public = 0,.is_written = 0,.language = 0,});
}

// Attr: [inline]
inline bool v__table__TypeSymbol_is_pointer(v__table__TypeSymbol* t) {
	return (t->kind == v__table__Kind_byteptr || t->kind == v__table__Kind_charptr || t->kind == v__table__Kind_voidptr);
}

// Attr: [inline]
inline bool v__table__TypeSymbol_is_int(v__table__TypeSymbol* t) {
	return (t->kind == v__table__Kind_i8 || t->kind == v__table__Kind_i16 || t->kind == v__table__Kind_int || t->kind == v__table__Kind_i64 || t->kind == v__table__Kind_byte || t->kind == v__table__Kind_u16 || t->kind == v__table__Kind_u32 || t->kind == v__table__Kind_u64 || t->kind == v__table__Kind_any_int);
}

// Attr: [inline]
inline bool v__table__TypeSymbol_is_float(v__table__TypeSymbol* t) {
	return (t->kind == v__table__Kind_f32 || t->kind == v__table__Kind_f64 || t->kind == v__table__Kind_any_float);
}

// Attr: [inline]
inline bool v__table__TypeSymbol_is_number(v__table__TypeSymbol* t) {
	return v__table__TypeSymbol_is_int(t) || v__table__TypeSymbol_is_float(t);
}

string v__table__Kind_str(v__table__Kind k) {
	v__table__Kind _t651 = k;
		string k_str = ((_t651 == v__table__Kind_placeholder) ? (tos_lit("placeholder")) : (_t651 == v__table__Kind_void) ? (tos_lit("void")) : (_t651 == v__table__Kind_voidptr) ? (tos_lit("voidptr")) : (_t651 == v__table__Kind_charptr) ? (tos_lit("charptr")) : (_t651 == v__table__Kind_byteptr) ? (tos_lit("byteptr")) : (_t651 == v__table__Kind_struct_) ? (tos_lit("struct")) : (_t651 == v__table__Kind_int) ? (tos_lit("int")) : (_t651 == v__table__Kind_i8) ? (tos_lit("i8")) : (_t651 == v__table__Kind_i16) ? (tos_lit("i16")) : (_t651 == v__table__Kind_i64) ? (tos_lit("i64")) : (_t651 == v__table__Kind_byte) ? (tos_lit("byte")) : (_t651 == v__table__Kind_u16) ? (tos_lit("u16")) : (_t651 == v__table__Kind_u32) ? (tos_lit("u32")) : (_t651 == v__table__Kind_u64) ? (tos_lit("u64")) : (_t651 == v__table__Kind_any_int) ? (tos_lit("any_int")) : (_t651 == v__table__Kind_f32) ? (tos_lit("f32")) : (_t651 == v__table__Kind_f64) ? (tos_lit("f64")) : (_t651 == v__table__Kind_any_float) ? (tos_lit("any_float")) : (_t651 == v__table__Kind_string) ? (tos_lit("string")) : (_t651 == v__table__Kind_char) ? (tos_lit("char")) : (_t651 == v__table__Kind_bool) ? (tos_lit("bool")) : (_t651 == v__table__Kind_size_t) ? (tos_lit("size_t")) : (_t651 == v__table__Kind_none_) ? (tos_lit("none")) : (_t651 == v__table__Kind_array) ? (tos_lit("array")) : (_t651 == v__table__Kind_array_fixed) ? (tos_lit("array_fixed")) : (_t651 == v__table__Kind_map) ? (tos_lit("map")) : (_t651 == v__table__Kind_chan) ? (tos_lit("chan")) : (_t651 == v__table__Kind_multi_return) ? (tos_lit("multi_return")) : (_t651 == v__table__Kind_sum_type) ? (tos_lit("sum_type")) : (_t651 == v__table__Kind_alias) ? (tos_lit("alias")) : (_t651 == v__table__Kind_enum_) ? (tos_lit("enum")) : (_t651 == v__table__Kind_any) ? (tos_lit("any")) : (_t651 == v__table__Kind_function) ? (tos_lit("function")) : (_t651 == v__table__Kind_interface_) ? (tos_lit("interface")) : (_t651 == v__table__Kind_ustring) ? (tos_lit("ustring")) : (_t651 == v__table__Kind_generic_struct_inst) ? (tos_lit("generic_struct_inst")) : (_t651 == v__table__Kind_rune) ? (tos_lit("rune")) : (tos_lit("aggregate")));
	return k_str;
}

string array_v__table__Kind_str(array_v__table__Kind kinds) {
	string kinds_str = tos_lit("");
	// FOR IN array
	array _t652 = kinds;
	for (int i = 0; i < _t652.len; ++i) {
		v__table__Kind k = ((v__table__Kind*)_t652.data)[i];
		kinds_str = /*f*/string_add(kinds_str, v__table__Kind_str(k));
		if (i < kinds.len - 1) {
			kinds_str = /*f*/string_add(kinds_str, tos_lit("_"));
		}
	}
	return kinds_str;
}

// TypeDecl
VV_LOCAL_SYMBOL bool v__table__Field_equals(v__table__Field* f, v__table__Field* o) {
	return string_eq(f->name, o->name) && f->typ == o->typ && f->is_pub == o->is_pub && f->is_global == o->is_global;
}

string v__table__Table_type_to_str(v__table__Table* table, v__table__Type t) {
	v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(table, t);
	string res = sym->source_name;
	v__table__Kind _t653 = sym->kind;
	if (_t653 == v__table__Kind_any_int || _t653 == v__table__Kind_i8 || _t653 == v__table__Kind_i16 || _t653 == v__table__Kind_int || _t653 == v__table__Kind_i64 || _t653 == v__table__Kind_byte || _t653 == v__table__Kind_u16 || _t653 == v__table__Kind_u32 || _t653 == v__table__Kind_u64 || _t653 == v__table__Kind_any_float || _t653 == v__table__Kind_f32 || _t653 == v__table__Kind_f64 || _t653 == v__table__Kind_char || _t653 == v__table__Kind_rune || _t653 == v__table__Kind_string || _t653 == v__table__Kind_bool || _t653 == v__table__Kind_none_ || _t653 == v__table__Kind_byteptr || _t653 == v__table__Kind_voidptr || _t653 == v__table__Kind_charptr) {
		res = v__table__Kind_str(sym->kind);
	} else if (_t653 == v__table__Kind_array) {
		if (t == _const_v__table__array_type) {
			return tos_lit("array");
		}
		v__table__Array info = /* as */ *(v__table__Array*)__as_cast((sym->info)._350, (sym->info).typ, /*expected:*/350);
		string elem_str = v__table__Table_type_to_str(table, info.elem_type);
		res = _STR("[]%.*s", 1, elem_str);
	} else if (_t653 == v__table__Kind_array_fixed) {
		v__table__ArrayFixed info = /* as */ *(v__table__ArrayFixed*)__as_cast((sym->info)._351, (sym->info).typ, /*expected:*/351);
		string elem_str = v__table__Table_type_to_str(table, info.elem_type);
		res = _STR("[%"PRId32"\000]%.*s", 2, info.size, elem_str);
	} else if (_t653 == v__table__Kind_chan) {
		if (string_ne(sym->mod, tos_lit("builtin")) && string_ne(sym->name, tos_lit("chan"))) {
			v__table__Chan info = /* as */ *(v__table__Chan*)__as_cast((sym->info)._348, (sym->info).typ, /*expected:*/348);
			v__table__Type elem_type = info.elem_type;
			string mut_str = tos_lit("");
			if (info.is_mut) {
				mut_str = tos_lit("mut ");
				elem_type = v__table__Type_set_nr_muls(elem_type, v__table__Type_nr_muls(elem_type) - 1);
			}
			string elem_str = v__table__Table_type_to_str(table, elem_type);
			res = _STR("chan %.*s\000%.*s", 2, mut_str, elem_str);
		}
	} else if (_t653 == v__table__Kind_function) {
		if (!table->is_fmt) {
			v__table__FnType info = /* as */ *(v__table__FnType*)__as_cast((sym->info)._353, (sym->info).typ, /*expected:*/353);
			res = v__table__Table_fn_signature(table, (voidptr)&/*qq*/info.func, (v__table__FnSignatureOpts){.skip_receiver = 0,.type_only = true,});
		}
	} else if (_t653 == v__table__Kind_map) {
		if (((int)(t)) == _const_v__table__map_type_idx) {
			return tos_lit("map");
		}
		v__table__Map info = /* as */ *(v__table__Map*)__as_cast((sym->info)._349, (sym->info).typ, /*expected:*/349);
		string key_str = v__table__Table_type_to_str(table, info.key_type);
		string val_str = v__table__Table_type_to_str(table, info.value_type);
		res = _STR("map[%.*s\000]%.*s", 2, key_str, val_str);
	} else if (_t653 == v__table__Kind_multi_return) {
		res = tos_lit("(");
		v__table__MultiReturn info = /* as */ *(v__table__MultiReturn*)__as_cast((sym->info)._352, (sym->info).typ, /*expected:*/352);
		// FOR IN array
		array _t654 = info.types;
		for (int i = 0; i < _t654.len; ++i) {
			v__table__Type typ = ((v__table__Type*)_t654.data)[i];
			if (i > 0) {
				res = /*f*/string_add(res, tos_lit(", "));
			}
			res = /*f*/string_add(res, v__table__Table_type_to_str(table, typ));
		}
		res = /*f*/string_add(res, tos_lit(")"));
	} else if (_t653 == v__table__Kind_void) {
		if (v__table__Type_has_flag(t, v__table__TypeFlag_optional)) {
			return tos_lit("?");
		}
		return tos_lit("void");
	} else {
		array_string parts = string_split(res, tos_lit("."));
		res = (parts.len > 1 ? (array_string_join(array_slice(parts, parts.len - 2, parts.len), tos_lit("."))) : ((*(string*)/*ee elem_typ */array_get(parts, 0))));
		if (string_starts_with(res, table->cmod_prefix)) {
			res = string_replace_once(res, table->cmod_prefix, tos_lit(""));
		}
	};
	int nr_muls = v__table__Type_nr_muls(t);
	if (nr_muls > 0) {
		res = string_add(strings__repeat('&', nr_muls), res);
	}
	if (v__table__Type_has_flag(t, v__table__TypeFlag_optional)) {
		res = string_add(tos_lit("?"), res);
	}
	return res;
}

string v__table__Table_fn_signature(v__table__Table* t, v__table__Fn* func, v__table__FnSignatureOpts opts) {
	strings__Builder sb = strings__new_builder(20);
	if (!opts.skip_receiver) {
		strings__Builder_write(&sb, tos_lit("fn "));
	}
	if (!opts.type_only) {
		strings__Builder_write(&sb, _STR("%.*s", 1, func->name));
	}
	strings__Builder_write(&sb, tos_lit("("));
	int start = ((int)(opts.skip_receiver));
	for (int i = start; i < func->params.len; ++i) {
		if (i != start) {
			strings__Builder_write(&sb, tos_lit(", "));
		}
		v__table__Param param = (*(v__table__Param*)/*ee elem_typ */array_get(func->params, i));
		v__table__Type typ = param.typ;
		if (param.is_mut) {
			typ = v__table__Type_deref(typ);
			strings__Builder_write(&sb, tos_lit("mut "));
		}
		if (!opts.type_only) {
			strings__Builder_write(&sb, _STR("%.*s\000 ", 2, param.name));
		}
		string styp = v__table__Table_type_to_str(t, typ);
		strings__Builder_write(&sb, _STR("%.*s", 1, styp));
	}
	strings__Builder_write(&sb, tos_lit(")"));
	if (func->return_type != _const_v__table__void_type) {
		strings__Builder_write(&sb, _STR(" %.*s", 1, v__table__Table_type_to_str(t, func->return_type)));
	}
	return strings__Builder_str(&sb);
}

bool v__table__TypeSymbol_has_method(v__table__TypeSymbol* t, string name) {
	Option_v__table__Fn _t655 = v__table__TypeSymbol_find_method(t, name);
	if (!_t655.ok) {
		string err = _t655.v_error;
		int errcode = _t655.ecode;
		return false;
	};
	return true;
}

Option_v__table__Fn v__table__TypeSymbol_find_method(v__table__TypeSymbol* t, string name) {
	// FOR IN array
	array _t656 = t->methods;
	for (int _t657 = 0; _t657 < _t656.len; ++_t657) {
		v__table__Fn method = ((v__table__Fn*)_t656.data)[_t657];
		if (string_eq(method.name, name)) {
			Option_v__table__Fn _t658;
			opt_ok2(&(v__table__Fn[]) { method }, (OptionBase*)(&_t658), sizeof(v__table__Fn));
			return _t658;
		}
	}
	Option _t659 = opt_none();
	return *(Option_v__table__Fn*)&_t659;
}

multi_return_bool_bool_int v__table__TypeSymbol_str_method_info(v__table__TypeSymbol* t) {
	bool has_str_method = false;
	bool expects_ptr = false;
	int nr_args = 0;
	{ /* if guard */ 
	Option_v__table__Fn _t660;
	if (_t660 = v__table__TypeSymbol_find_method(t, tos_lit("str")), _t660.ok) {
		v__table__Fn sym_str_method = *(v__table__Fn*)_t660.data;
		has_str_method = true;
		nr_args = sym_str_method.params.len;
		if (nr_args > 0) {
			expects_ptr = v__table__Type_is_ptr((*(v__table__Param*)/*ee elem_typ */array_get(sym_str_method.params, 0)).typ);
		}
	}}
	return (multi_return_bool_bool_int){.arg0=has_str_method, .arg1=expects_ptr, .arg2=nr_args};
}

VV_LOCAL_SYMBOL Option_v__table__Field v__table__Aggregate_find_field(v__table__Aggregate* a, string name) {
	// FOR IN array
	array _t661 = a->fields;
	for (int _t662 = 0; _t662 < _t661.len; ++_t662) {
		v__table__Field field = ((v__table__Field*)_t661.data)[_t662];
		if (string_eq(field.name, name)) {
			Option_v__table__Field _t663;
			opt_ok2(&(v__table__Field[]) { field }, (OptionBase*)(&_t663), sizeof(v__table__Field));
			return _t663;
		}
	}
	Option _t664 = opt_none();
	return *(Option_v__table__Field*)&_t664;
}

Option_v__table__Field v__table__Struct_find_field(v__table__Struct s, string name) {
	// FOR IN array
	array _t665 = s.fields;
	for (int _t666 = 0; _t666 < _t665.len; ++_t666) {
		v__table__Field field = ((v__table__Field*)_t665.data)[_t666];
		if (string_eq(field.name, name)) {
			Option_v__table__Field _t667;
			opt_ok2(&(v__table__Field[]) { field }, (OptionBase*)(&_t667), sizeof(v__table__Field));
			return _t667;
		}
	}
	Option _t668 = opt_none();
	return *(Option_v__table__Field*)&_t668;
}

v__table__Field v__table__Struct_get_field(v__table__Struct s, string name) {
	{ /* if guard */ 
	Option_v__table__Field _t669;
	if (_t669 = v__table__Struct_find_field(s, name), _t669.ok) {
		v__table__Field field = *(v__table__Field*)_t669.data;
		return field;
	}}
	v_panic(_STR("unknown field `%.*s\000`", 2, name));
	return (v__table__Field){0};
}

void rand__wyrand__WyRandRNG_seed(rand__wyrand__WyRandRNG* rng, array_u32 seed_data) {
	if (seed_data.len != 2) {
		eprintln(tos_lit("WyRandRNG needs 2 32-bit unsigned integers as the seed."));
		v_exit(1);
	}
	rng->state = ((*(u32*)/*ee elem_typ */array_get(seed_data, 0)) | (((u64)((*(u32*)/*ee elem_typ */array_get(seed_data, 1)))) << 32));
	rng->has_extra = false;
}

// Attr: [inline]
inline u32 rand__wyrand__WyRandRNG_u32(rand__wyrand__WyRandRNG* rng) {
	if (rng->has_extra) {
		rng->has_extra = false;
		return rng->extra;
	}
	u64 full_value = rand__wyrand__WyRandRNG_u64(rng);
	u32 lower = ((u32)((full_value & _const_rand__util__lower_mask)));
	u32 upper = ((u32)(full_value >> 32));
	rng->extra = upper;
	rng->has_extra = true;
	return lower;
}

// Attr: [inline]
inline u64 rand__wyrand__WyRandRNG_u64(rand__wyrand__WyRandRNG* rng) {
	{ // Unsafe block
		u64 seed1 = rng->state;
		seed1 += _const_rand__wyrand__wyp0;
		rng->state = seed1;
		return hash__wymum((seed1 ^ _const_rand__wyrand__wyp1), seed1);
	}
	return 0;
}

// Attr: [inline]
inline u32 rand__wyrand__WyRandRNG_u32n(rand__wyrand__WyRandRNG* rng, u32 max) {
	if (max == 0) {
		eprintln(tos_lit("max must be positive integer"));
		v_exit(1);
	}
	int bit_len = math__bits__len_32(max);
	if (bit_len == 32) {
		for (;;) {
			u32 value = rand__wyrand__WyRandRNG_u32(rng);
			if (value < max) {
				return value;
			}
		}
	} else {
		u32 mask = (((u32)(1U)) << (bit_len + 1)) - 1;
		for (;;) {
			u32 value = (rand__wyrand__WyRandRNG_u32(rng) & mask);
			if (value < max) {
				return value;
			}
		}
	}
	return ((u32)(0U));
}

// Attr: [inline]
inline u64 rand__wyrand__WyRandRNG_u64n(rand__wyrand__WyRandRNG* rng, u64 max) {
	if (max == 0) {
		eprintln(tos_lit("max must be positive integer"));
		v_exit(1);
	}
	int bit_len = math__bits__len_64(max);
	if (bit_len == 64) {
		for (;;) {
			u64 value = rand__wyrand__WyRandRNG_u64(rng);
			if (value < max) {
				return value;
			}
		}
	} else {
		u64 mask = (((u64)(1U)) << (bit_len + 1)) - 1;
		for (;;) {
			u64 value = (rand__wyrand__WyRandRNG_u64(rng) & mask);
			if (value < max) {
				return value;
			}
		}
	}
	return ((u64)(0U));
}

// Attr: [inline]
inline u32 rand__wyrand__WyRandRNG_u32_in_range(rand__wyrand__WyRandRNG* rng, u32 min, u32 max) {
	if (max <= min) {
		eprintln(tos_lit("max must be greater than min"));
		v_exit(1);
	}
	return min + rand__wyrand__WyRandRNG_u32n(rng, max - min);
}

// Attr: [inline]
inline u64 rand__wyrand__WyRandRNG_u64_in_range(rand__wyrand__WyRandRNG* rng, u64 min, u64 max) {
	if (max <= min) {
		eprintln(tos_lit("max must be greater than min"));
		v_exit(1);
	}
	return min + rand__wyrand__WyRandRNG_u64n(rng, max - min);
}

// Attr: [inline]
inline int rand__wyrand__WyRandRNG_int(rand__wyrand__WyRandRNG* rng) {
	return ((int)(rand__wyrand__WyRandRNG_u32(rng)));
}

// Attr: [inline]
inline i64 rand__wyrand__WyRandRNG_i64(rand__wyrand__WyRandRNG* rng) {
	return ((i64)(rand__wyrand__WyRandRNG_u64(rng)));
}

// Attr: [inline]
inline int rand__wyrand__WyRandRNG_int31(rand__wyrand__WyRandRNG* rng) {
	return ((int)((rand__wyrand__WyRandRNG_u32(rng) & _const_rand__util__u31_mask)));
}

// Attr: [inline]
inline i64 rand__wyrand__WyRandRNG_int63(rand__wyrand__WyRandRNG* rng) {
	return ((i64)((rand__wyrand__WyRandRNG_u64(rng) & _const_rand__util__u63_mask)));
}

// Attr: [inline]
inline int rand__wyrand__WyRandRNG_intn(rand__wyrand__WyRandRNG* rng, int max) {
	if (max <= 0) {
		eprintln(tos_lit("max has to be positive."));
		v_exit(1);
	}
	return ((int)(rand__wyrand__WyRandRNG_u32n(rng, ((u32)(max)))));
}

// Attr: [inline]
inline i64 rand__wyrand__WyRandRNG_i64n(rand__wyrand__WyRandRNG* rng, i64 max) {
	if (max <= 0) {
		eprintln(tos_lit("max has to be positive."));
		v_exit(1);
	}
	return ((i64)(rand__wyrand__WyRandRNG_u64n(rng, ((u64)(max)))));
}

// Attr: [inline]
inline int rand__wyrand__WyRandRNG_int_in_range(rand__wyrand__WyRandRNG* rng, int min, int max) {
	if (max <= min) {
		eprintln(tos_lit("max must be greater than min"));
		v_exit(1);
	}
	return min + rand__wyrand__WyRandRNG_intn(rng, max - min);
}

// Attr: [inline]
inline i64 rand__wyrand__WyRandRNG_i64_in_range(rand__wyrand__WyRandRNG* rng, i64 min, i64 max) {
	if (max <= min) {
		eprintln(tos_lit("max must be greater than min"));
		v_exit(1);
	}
	return min + rand__wyrand__WyRandRNG_i64n(rng, max - min);
}

// Attr: [inline]
inline f32 rand__wyrand__WyRandRNG_f32(rand__wyrand__WyRandRNG* rng) {
	return ((f32)(rand__wyrand__WyRandRNG_u32(rng))) / _const_rand__util__max_u32_as_f32;
}

// Attr: [inline]
inline f64 rand__wyrand__WyRandRNG_f64(rand__wyrand__WyRandRNG* rng) {
	return ((f64)(rand__wyrand__WyRandRNG_u64(rng))) / _const_rand__util__max_u64_as_f64;
}

// Attr: [inline]
inline f32 rand__wyrand__WyRandRNG_f32n(rand__wyrand__WyRandRNG* rng, f32 max) {
	if (max <= 0) {
		eprintln(tos_lit("max has to be positive."));
		v_exit(1);
	}
	return rand__wyrand__WyRandRNG_f32(rng) * max;
}

// Attr: [inline]
inline f64 rand__wyrand__WyRandRNG_f64n(rand__wyrand__WyRandRNG* rng, f64 max) {
	if (max <= 0) {
		eprintln(tos_lit("max has to be positive."));
		v_exit(1);
	}
	return rand__wyrand__WyRandRNG_f64(rng) * max;
}

// Attr: [inline]
inline f32 rand__wyrand__WyRandRNG_f32_in_range(rand__wyrand__WyRandRNG* rng, f32 min, f32 max) {
	if (max <= min) {
		eprintln(tos_lit("max must be greater than min"));
		v_exit(1);
	}
	return min + rand__wyrand__WyRandRNG_f32n(rng, max - min);
}

// Attr: [inline]
inline f64 rand__wyrand__WyRandRNG_f64_in_range(rand__wyrand__WyRandRNG* rng, f64 min, f64 max) {
	if (max <= min) {
		eprintln(tos_lit("max must be greater than min"));
		v_exit(1);
	}
	return min + rand__wyrand__WyRandRNG_f64n(rng, max - min);
}

VV_LOCAL_SYMBOL void rand__init() {
	default_rng = rand__new_default((rand__PRNGConfigStruct){.seed = rand__util__time_seed_array(2),});
}

rand__wyrand__WyRandRNG* rand__new_default(rand__PRNGConfigStruct config) {
	rand__wyrand__WyRandRNG* rng = (rand__wyrand__WyRandRNG*)memdup(&(rand__wyrand__WyRandRNG){.state = rand__util__time_seed_64(),.has_extra = 0,.extra = 0,}, sizeof(rand__wyrand__WyRandRNG));
	rand__wyrand__WyRandRNG_seed(rng, config.seed);
	return rng;
}

void rand__seed(array_u32 seed) {
	rand__wyrand__WyRandRNG_seed(default_rng, seed);
}

u32 rand__u32() {
	return rand__wyrand__WyRandRNG_u32(default_rng);
}

u64 rand__u64() {
	return rand__wyrand__WyRandRNG_u64(default_rng);
}

u32 rand__u32n(u32 max) {
	return rand__wyrand__WyRandRNG_u32n(default_rng, max);
}

u64 rand__u64n(u64 max) {
	return rand__wyrand__WyRandRNG_u64n(default_rng, max);
}

u32 rand__u32_in_range(u32 min, u32 max) {
	return rand__wyrand__WyRandRNG_u32_in_range(default_rng, min, max);
}

u64 rand__u64_in_range(u64 min, u64 max) {
	return rand__wyrand__WyRandRNG_u64_in_range(default_rng, min, max);
}

int rand__int() {
	return rand__wyrand__WyRandRNG_int(default_rng);
}

int rand__intn(int max) {
	return rand__wyrand__WyRandRNG_intn(default_rng, max);
}

int rand__int_in_range(int min, int max) {
	return rand__wyrand__WyRandRNG_int_in_range(default_rng, min, max);
}

int rand__int31() {
	return rand__wyrand__WyRandRNG_int31(default_rng);
}

i64 rand__i64() {
	return rand__wyrand__WyRandRNG_i64(default_rng);
}

i64 rand__i64n(i64 max) {
	return rand__wyrand__WyRandRNG_i64n(default_rng, max);
}

i64 rand__i64_in_range(i64 min, i64 max) {
	return rand__wyrand__WyRandRNG_i64_in_range(default_rng, min, max);
}

i64 rand__int63() {
	return rand__wyrand__WyRandRNG_int63(default_rng);
}

f32 rand__f32() {
	return rand__wyrand__WyRandRNG_f32(default_rng);
}

f64 rand__f64() {
	return rand__wyrand__WyRandRNG_f64(default_rng);
}

f32 rand__f32n(f32 max) {
	return rand__wyrand__WyRandRNG_f32n(default_rng, max);
}

f64 rand__f64n(f64 max) {
	return rand__wyrand__WyRandRNG_f64n(default_rng, max);
}

f32 rand__f32_in_range(f32 min, f32 max) {
	return rand__wyrand__WyRandRNG_f32_in_range(default_rng, min, max);
}

f64 rand__f64_in_range(f64 min, f64 max) {
	return rand__wyrand__WyRandRNG_f64_in_range(default_rng, min, max);
}

string rand__string(int len) {
	byteptr buf = v_malloc(len);
	for (int i = 0; i < len; ++i) {
		{ // Unsafe block
			buf[i] = string_at(_const_rand__chars, rand__intn(_const_rand__chars.len));
		}
	}
	return byteptr_vstring_with_len(buf, len);
}

string rand__uuid_v4() {
	int buflen = 36;
	byteptr buf = v_malloc(37);
	int i_buf = 0;
	u64 x = ((u64)(0U));
	byte d = ((byte)(0));
	for (;;) {
		if (!(i_buf < buflen)) break;
		int c = 0;
		x = rand__wyrand__WyRandRNG_u64(default_rng);
		x &= 0x0F0F0F0F0F0F0F0F;
		x += 0x3030303030303030;
		for (;;) {
			if (!(c < 8 && i_buf < buflen)) break;
			d = ((byte)(x));
			{ // Unsafe block
				buf[i_buf] = (d > 0x39 ? (d + 0x27) : (d));
			}
			i_buf++;
			c++;
			x = x >> 8;
		}
	}
	x = x >> 8;
	d = ((byte)(x));
	{ // Unsafe block
		buf[19] = (d > 0x39 ? (d + 0x27) : (d));
		buf[8] = '-';
		buf[13] = '-';
		buf[18] = '-';
		buf[23] = '-';
		buf[14] = '4';
		buf[buflen] = 0;
	}
	return byteptr_vstring_with_len(buf, buflen);
}

string rand__ulid() {
	return rand__ulid_at_millisecond(time__Time_unix_time_milli(time__utc()));
}

string rand__ulid_at_millisecond(u64 unix_time_milli) {
	int buflen = 26;
	byteptr buf = v_malloc(27);
	u64 t = unix_time_milli;
	int i = 9;
	for (;;) {
		if (!(i >= 0)) break;
		{ // Unsafe block
			buf[i] = string_at(_const_rand__ulid_encoding, (t & 0x1F));
		}
		t = t >> 5;
		i--;
	}
	u64 x = rand__wyrand__WyRandRNG_u64(default_rng);
	i = 10;
	for (;;) {
		if (!(i < 19)) break;
		{ // Unsafe block
			buf[i] = string_at(_const_rand__ulid_encoding, (x & 0x1F));
		}
		x = x >> 5;
		i++;
	}
	x = rand__wyrand__WyRandRNG_u64(default_rng);
	for (;;) {
		if (!(i < 26)) break;
		{ // Unsafe block
			buf[i] = string_at(_const_rand__ulid_encoding, (x & 0x1F));
		}
		x = x >> 5;
		i++;
	}
	{ // Unsafe block
		buf[26] = 0;
	}
	return byteptr_vstring_with_len(buf, buflen);
}

v__pref__Preferences v__pref__new_preferences() {
	v__pref__Preferences p = (v__pref__Preferences){.os = 0,.backend = 0,.build_mode = 0,.output_mode = v__pref__OutputMode_stdout,.is_verbose = 0,.is_test = 0,.is_script = 0,.is_vsh = 0,.is_livemain = 0,.is_liveshared = 0,.is_shared = 0,.is_prof = 0,.profile_file = (string){.str=(byteptr)""},.profile_no_inline = 0,.translated = 0,.is_prod = 0,.obfuscate = 0,.is_repl = 0,.is_run = 0,.sanitize = 0,.is_debug = 0,.is_vlines = 0,.show_cc = 0,.show_c_output = 0,.use_cache = 0,.is_stats = 0,.no_auto_free = 0,.cflags = (string){.str=(byteptr)""},.ccompiler = (string){.str=(byteptr)""},.ccompiler_type = 0,.third_party_option = (string){.str=(byteptr)""},.building_v = 0,.autofree = 0,.compress = 0,.fast = 0,.enable_globals = 0,.is_fmt = 0,.is_vet = 0,.is_bare = 0,.no_preludes = 0,.custom_prelude = (string){.str=(byteptr)""},.lookup_path = __new_array(0, 1, sizeof(string)),.output_cross_c = 0,.prealloc = 0,.vroot = (string){.str=(byteptr)""},.out_name_c = (string){.str=(byteptr)""},.out_name = (string){.str=(byteptr)""},.display_name = (string){.str=(byteptr)""},.bundle_id = (string){.str=(byteptr)""},.path = (string){.str=(byteptr)""},.compile_defines = __new_array(0, 1, sizeof(string)),.compile_defines_all = __new_array(0, 1, sizeof(string)),.run_args = __new_array(0, 1, sizeof(string)),.printfn_list = __new_array(0, 1, sizeof(string)),.print_v_files = 0,.skip_running = 0,.skip_warnings = 0,.warns_are_errors = 0,.reuse_tmpc = 0,.use_color = 0,.is_parallel = 0,.error_limit = 0,.is_vweb = 0,.only_check_syntax = 0,.experimental = 0,.show_timings = 0,.is_ios_simulator = 0,.is_apk = 0,.cleanup_files = __new_array(0, 1, sizeof(string)),.build_options = __new_array(0, 1, sizeof(string)),.cache_manager = {0},};
	v__pref__Preferences_fill_with_defaults(&p);
	return p;
}

void v__pref__Preferences_fill_with_defaults(v__pref__Preferences* p) {
	if ((p->vroot).len == 0) {
		p->vroot = os__dir(v__pref__vexe_path());
	}
	string vlib_path = os__join_path(p->vroot, (varg_string){.len=1,.args={tos_lit("vlib")}});
	if (p->lookup_path.len == 0) {
		p->lookup_path = new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){tos_lit("@vlib"), tos_lit("@vmodules")}));
	}
	// FOR IN array
	array _t670 = p->lookup_path;
	for (int i = 0; i < _t670.len; ++i) {
		string path = ((string*)_t670.data)[i];
		(*(string*)/*ee elem_typ */array_get(p->lookup_path, i)) = string_replace(string_replace(path, tos_lit("@vlib"), vlib_path), tos_lit("@vmodules"), _const_v__pref__default_module_path);
	}
	string rpath = os__real_path(p->path);
	if ((p->out_name).len == 0) {
		string filename = string_trim_space(os__file_name(rpath));
		string base = string_all_before_last(filename, tos_lit("."));
		if ((base).len == 0) {
			base = filename;
		}
		string target_dir = (os__is_dir(rpath) ? (rpath) : (os__dir(rpath)));
		p->out_name = os__join_path(target_dir, (varg_string){.len=1,.args={base}});
		if (string_eq(rpath, _STR("%.*s\000/cmd/v", 2, p->vroot)) && os__is_dir(tos_lit("vlib/compiler"))) {
			println(tos_lit("Saving the resulting V executable in `./v2`"));
			println(string_add(tos_lit("Use `v -o v cmd/v` if you want to replace current "), tos_lit("V executable.")));
			p->out_name = tos_lit("v2");
		}
	}
	string rpath_name = os__file_name(rpath);
	p->building_v = !p->is_repl && (string_eq(rpath_name, tos_lit("v")) || string_eq(rpath_name, tos_lit("vfmt.v")));
	if (p->os == v__pref__OS__auto) {
		p->os = v__pref__get_host_os();
	}
	if ((p->ccompiler).len == 0) {
		p->ccompiler = v__pref__default_c_compiler();
	}
	p->ccompiler_type = v__pref__cc_from_string(p->ccompiler);
	p->is_test = string_ends_with(p->path, tos_lit("_test.v"));
	p->is_vsh = string_ends_with(p->path, tos_lit(".vsh"));
	p->is_script = p->is_vsh || string_ends_with(p->path, tos_lit(".v")) || string_ends_with(p->path, tos_lit(".vv"));
	if ((p->third_party_option).len == 0) {
		p->third_party_option = p->cflags;
		#if !defined(_WIN32)
		{
		}
		#endif
	}
	p->cache_manager = v__vcache__new_cache_manager(new_array_from_c_array(7, 7, sizeof(string), _MOV((string[7]){tos_lit("a6f1667"), _STR("%.*s\000 | %.*s\000 | %.*s", 3, v__pref__Backend_str(p->backend), v__pref__OS_str(p->os), p->ccompiler), string_trim_space(p->cflags), string_trim_space(p->third_party_option), _STR("%.*s", 1, array_string_str(p->compile_defines_all)), _STR("%.*s", 1, array_string_str(p->compile_defines)), _STR("%.*s", 1, array_string_str(p->lookup_path))})));
}

VV_LOCAL_SYMBOL string v__pref__default_c_compiler() {
	#if defined(_WIN32)
	{
		return tos_lit("gcc");
	}
	#endif
	return tos_lit("cc");
}

string v__pref__vexe_path() {
	string vexe = os__getenv(tos_lit("VEXE"));
	if ((vexe).len != 0) {
		return vexe;
	}
	string real_vexe_path = os__real_path(os__executable());
	os__setenv(tos_lit("VEXE"), real_vexe_path, true);
	return real_vexe_path;
}

Option_v__pref__OS v__pref__os_from_string(string os_str) {
	string _t671 = os_str;
	if (string_eq(_t671, tos_lit("linux"))) {
		Option_v__pref__OS _t672;
		opt_ok2(&(v__pref__OS[]) { v__pref__OS_linux }, (OptionBase*)(&_t672), sizeof(v__pref__OS));
		return _t672;
	} else if (string_eq(_t671, tos_lit("windows"))) {
		Option_v__pref__OS _t673;
		opt_ok2(&(v__pref__OS[]) { v__pref__OS_windows }, (OptionBase*)(&_t673), sizeof(v__pref__OS));
		return _t673;
	} else if (string_eq(_t671, tos_lit("ios"))) {
		Option_v__pref__OS _t674;
		opt_ok2(&(v__pref__OS[]) { v__pref__OS_ios }, (OptionBase*)(&_t674), sizeof(v__pref__OS));
		return _t674;
	} else if (string_eq(_t671, tos_lit("macos"))) {
		Option_v__pref__OS _t675;
		opt_ok2(&(v__pref__OS[]) { v__pref__OS_macos }, (OptionBase*)(&_t675), sizeof(v__pref__OS));
		return _t675;
	} else if (string_eq(_t671, tos_lit("freebsd"))) {
		Option_v__pref__OS _t676;
		opt_ok2(&(v__pref__OS[]) { v__pref__OS_freebsd }, (OptionBase*)(&_t676), sizeof(v__pref__OS));
		return _t676;
	} else if (string_eq(_t671, tos_lit("openbsd"))) {
		Option_v__pref__OS _t677;
		opt_ok2(&(v__pref__OS[]) { v__pref__OS_openbsd }, (OptionBase*)(&_t677), sizeof(v__pref__OS));
		return _t677;
	} else if (string_eq(_t671, tos_lit("netbsd"))) {
		Option_v__pref__OS _t678;
		opt_ok2(&(v__pref__OS[]) { v__pref__OS_netbsd }, (OptionBase*)(&_t678), sizeof(v__pref__OS));
		return _t678;
	} else if (string_eq(_t671, tos_lit("dragonfly"))) {
		Option_v__pref__OS _t679;
		opt_ok2(&(v__pref__OS[]) { v__pref__OS_dragonfly }, (OptionBase*)(&_t679), sizeof(v__pref__OS));
		return _t679;
	} else if (string_eq(_t671, tos_lit("js"))) {
		Option_v__pref__OS _t680;
		opt_ok2(&(v__pref__OS[]) { v__pref__OS_js }, (OptionBase*)(&_t680), sizeof(v__pref__OS));
		return _t680;
	} else if (string_eq(_t671, tos_lit("solaris"))) {
		Option_v__pref__OS _t681;
		opt_ok2(&(v__pref__OS[]) { v__pref__OS_solaris }, (OptionBase*)(&_t681), sizeof(v__pref__OS));
		return _t681;
	} else if (string_eq(_t671, tos_lit("android"))) {
		Option_v__pref__OS _t682;
		opt_ok2(&(v__pref__OS[]) { v__pref__OS_android }, (OptionBase*)(&_t682), sizeof(v__pref__OS));
		return _t682;
	} else if (string_eq(_t671, tos_lit("haiku"))) {
		Option_v__pref__OS _t683;
		opt_ok2(&(v__pref__OS[]) { v__pref__OS_haiku }, (OptionBase*)(&_t683), sizeof(v__pref__OS));
		return _t683;
	} else if (string_eq(_t671, tos_lit("linux_or_macos"))) {
		Option_v__pref__OS _t684;
		opt_ok2(&(v__pref__OS[]) { v__pref__OS_linux }, (OptionBase*)(&_t684), sizeof(v__pref__OS));
		return _t684;
	} else if (_t671.len == 0) {
		Option_v__pref__OS _t685;
		opt_ok2(&(v__pref__OS[]) { v__pref__OS__auto }, (OptionBase*)(&_t685), sizeof(v__pref__OS));
		return _t685;
	} else {
		Option _t686 = v_error(_STR("bad OS %.*s", 1, os_str));
		return *(Option_v__pref__OS*)&_t686;
	};
	Option _t687 = opt_none();
	return *(Option_v__pref__OS*)&_t687;
}

string v__pref__OS_str(v__pref__OS o) {
	v__pref__OS _t688 = o;
	if (_t688 == v__pref__OS__auto) {
		return tos_lit("RESERVED: AUTO");
	} else if (_t688 == v__pref__OS_ios) {
		return tos_lit("iOS");
	} else if (_t688 == v__pref__OS_macos) {
		return tos_lit("MacOS");
	} else if (_t688 == v__pref__OS_linux) {
		return tos_lit("Linux");
	} else if (_t688 == v__pref__OS_windows) {
		return tos_lit("Windows");
	} else if (_t688 == v__pref__OS_freebsd) {
		return tos_lit("FreeBSD");
	} else if (_t688 == v__pref__OS_openbsd) {
		return tos_lit("OpenBSD");
	} else if (_t688 == v__pref__OS_netbsd) {
		return tos_lit("NetBSD");
	} else if (_t688 == v__pref__OS_dragonfly) {
		return tos_lit("Dragonfly");
	} else if (_t688 == v__pref__OS_js) {
		return tos_lit("JavaScript");
	} else if (_t688 == v__pref__OS_android) {
		return tos_lit("Android");
	} else if (_t688 == v__pref__OS_solaris) {
		return tos_lit("Solaris");
	} else if (_t688 == v__pref__OS_haiku) {
		return tos_lit("Haiku");
	};
	return (string){.str=(byteptr)""};
}

v__pref__OS v__pref__get_host_os() {
	#if defined(__linux__)
	{
	}
	#endif
	#if defined(__TARGET_IOS__)
	{
	}
	#endif
	#if defined(__APPLE__)
	{
	}
	#endif
	#if defined(_WIN32)
	{
		return v__pref__OS_windows;
	}
	#endif
	#if defined(__FreeBSD__)
	{
	}
	#endif
	#if defined(__OpenBSD__)
	{
	}
	#endif
	#if defined(__NetBSD__)
	{
	}
	#endif
	#if defined(__DragonFly__)
	{
	}
	#endif
	#if defined(__sun)
	{
	}
	#endif
	#if defined(__haiku__)
	{
	}
	#endif
	v_panic(tos_lit("unknown host OS"));
	return 0;
}

multi_return_v__pref__Preferences_string v__pref__parse_args(array_string args) {
	v__pref__Preferences* res = (v__pref__Preferences*)memdup(&(v__pref__Preferences){.os = 0,.backend = 0,.build_mode = 0,.output_mode = v__pref__OutputMode_stdout,.is_verbose = 0,.is_test = 0,.is_script = 0,.is_vsh = 0,.is_livemain = 0,.is_liveshared = 0,.is_shared = 0,.is_prof = 0,.profile_file = (string){.str=(byteptr)""},.profile_no_inline = 0,.translated = 0,.is_prod = 0,.obfuscate = 0,.is_repl = 0,.is_run = 0,.sanitize = 0,.is_debug = 0,.is_vlines = 0,.show_cc = 0,.show_c_output = 0,.use_cache = 0,.is_stats = 0,.no_auto_free = 0,.cflags = (string){.str=(byteptr)""},.ccompiler = (string){.str=(byteptr)""},.ccompiler_type = 0,.third_party_option = (string){.str=(byteptr)""},.building_v = 0,.autofree = 0,.compress = 0,.fast = 0,.enable_globals = 0,.is_fmt = 0,.is_vet = 0,.is_bare = 0,.no_preludes = 0,.custom_prelude = (string){.str=(byteptr)""},.lookup_path = __new_array(0, 1, sizeof(string)),.output_cross_c = 0,.prealloc = 0,.vroot = (string){.str=(byteptr)""},.out_name_c = (string){.str=(byteptr)""},.out_name = (string){.str=(byteptr)""},.display_name = (string){.str=(byteptr)""},.bundle_id = (string){.str=(byteptr)""},.path = (string){.str=(byteptr)""},.compile_defines = __new_array(0, 1, sizeof(string)),.compile_defines_all = __new_array(0, 1, sizeof(string)),.run_args = __new_array(0, 1, sizeof(string)),.printfn_list = __new_array(0, 1, sizeof(string)),.print_v_files = 0,.skip_running = 0,.skip_warnings = 0,.warns_are_errors = 0,.reuse_tmpc = 0,.use_color = 0,.is_parallel = 0,.error_limit = 0,.is_vweb = 0,.only_check_syntax = 0,.experimental = 0,.show_timings = 0,.is_ios_simulator = 0,.is_apk = 0,.cleanup_files = __new_array(0, 1, sizeof(string)),.build_options = __new_array(0, 1, sizeof(string)),.cache_manager = {0},}, sizeof(v__pref__Preferences));
	string command = tos_lit("");
	int command_pos = 0;
	for (int i = 0; i < args.len; i++) {
		string arg = (*(string*)/*ee elem_typ */array_get(args, i));
		array_string current_args = array_slice(args, i, args.len);
		string _t689 = arg;
		if (string_eq(_t689, tos_lit("-apk"))) {
			res->is_apk = true;
			array_push(&res->build_options, _MOV((string[]){ string_clone(arg) }));
		} else if (string_eq(_t689, tos_lit("-show-timings"))) {
			res->show_timings = true;
		} else if (string_eq(_t689, tos_lit("-check-syntax"))) {
			res->only_check_syntax = true;
		} else if (string_eq(_t689, tos_lit("-v"))) {
			if (args.len > 1) {
				res->is_verbose = true;
			} else {
				command = tos_lit("version");
				command_pos = i;
			}
		} else if (string_eq(_t689, tos_lit("-progress"))) {
		} else if (string_eq(_t689, tos_lit("-silent"))) {
			res->output_mode = v__pref__OutputMode_silent;
		} else if (string_eq(_t689, tos_lit("-g"))) {
			res->is_debug = true;
			res->is_vlines = true;
			array_push(&res->build_options, _MOV((string[]){ string_clone(arg) }));
		} else if (string_eq(_t689, tos_lit("-cg"))) {
			res->is_debug = true;
			res->is_vlines = false;
			array_push(&res->build_options, _MOV((string[]){ string_clone(arg) }));
		} else if (string_eq(_t689, tos_lit("-repl"))) {
			res->is_repl = true;
		} else if (string_eq(_t689, tos_lit("-live"))) {
			res->is_livemain = true;
		} else if (string_eq(_t689, tos_lit("-sharedlive"))) {
			res->is_liveshared = true;
			res->is_shared = true;
		} else if (string_eq(_t689, tos_lit("-shared"))) {
			res->is_shared = true;
		} else if (string_eq(_t689, tos_lit("--enable-globals")) || string_eq(_t689, tos_lit("-enable-globals"))) {
			res->enable_globals = true;
		} else if (string_eq(_t689, tos_lit("-autofree"))) {
			res->autofree = true;
			array_push(&res->build_options, _MOV((string[]){ string_clone(arg) }));
		} else if (string_eq(_t689, tos_lit("-compress"))) {
			res->compress = true;
		} else if (string_eq(_t689, tos_lit("-freestanding"))) {
			res->is_bare = true;
			array_push(&res->build_options, _MOV((string[]){ string_clone(arg) }));
		} else if (string_eq(_t689, tos_lit("-no-preludes"))) {
			res->no_preludes = true;
			array_push(&res->build_options, _MOV((string[]){ string_clone(arg) }));
		} else if (string_eq(_t689, tos_lit("-prof")) || string_eq(_t689, tos_lit("-profile"))) {
			res->profile_file = os__cmdline__option(current_args, tos_lit("-profile"), tos_lit("-"));
			res->is_prof = true;
			array_push(&res->build_options, _MOV((string[]){ string_clone(_STR("%.*s\000 %.*s", 2, arg, res->profile_file)) }));
			i++;
		} else if (string_eq(_t689, tos_lit("-profile-no-inline"))) {
			res->profile_no_inline = true;
		} else if (string_eq(_t689, tos_lit("-prod"))) {
			res->is_prod = true;
			array_push(&res->build_options, _MOV((string[]){ string_clone(arg) }));
		} else if (string_eq(_t689, tos_lit("-simulator"))) {
			res->is_ios_simulator = true;
		} else if (string_eq(_t689, tos_lit("-stats"))) {
			res->is_stats = true;
		} else if (string_eq(_t689, tos_lit("-obfuscate"))) {
			res->obfuscate = true;
		} else if (string_eq(_t689, tos_lit("-translated"))) {
			res->translated = true;
		} else if (string_eq(_t689, tos_lit("-color"))) {
			res->use_color = v__pref__ColorOutput_always;
		} else if (string_eq(_t689, tos_lit("-nocolor"))) {
			res->use_color = v__pref__ColorOutput_never;
		} else if (string_eq(_t689, tos_lit("-showcc"))) {
			res->show_cc = true;
		} else if (string_eq(_t689, tos_lit("-show-c-output"))) {
			res->show_c_output = true;
		} else if (string_eq(_t689, tos_lit("-experimental"))) {
			res->experimental = true;
		} else if (string_eq(_t689, tos_lit("-usecache"))) {
			res->use_cache = true;
		} else if (string_eq(_t689, tos_lit("-prealloc"))) {
			res->prealloc = true;
			array_push(&res->build_options, _MOV((string[]){ string_clone(arg) }));
		} else if (string_eq(_t689, tos_lit("-parallel"))) {
			res->is_parallel = true;
		} else if (string_eq(_t689, tos_lit("-x64"))) {
			res->backend = v__pref__Backend_x64;
			array_push(&res->build_options, _MOV((string[]){ string_clone(arg) }));
		} else if (string_eq(_t689, tos_lit("-W"))) {
			res->warns_are_errors = true;
		} else if (string_eq(_t689, tos_lit("-keepc"))) {
			res->reuse_tmpc = true;
		} else if (string_eq(_t689, tos_lit("-w"))) {
			res->skip_warnings = true;
		} else if (string_eq(_t689, tos_lit("-print_v_files"))) {
			res->print_v_files = true;
		} else if (string_eq(_t689, tos_lit("-error-limit"))) {
			res->error_limit = string_int(os__cmdline__option(current_args, tos_lit("-error-limit"), tos_lit("0")));
		} else if (string_eq(_t689, tos_lit("-os"))) {
			string target_os = os__cmdline__option(current_args, tos_lit("-os"), tos_lit(""));
			i++;
			Option_v__pref__OS _t700 = v__pref__os_from_string(target_os);
			if (!_t700.ok) {
				string err = _t700.v_error;
				int errcode = _t700.ecode;
				if (string_eq(target_os, tos_lit("cross"))) {
					res->output_cross_c = true;
					continue;
				}
				eprintln(_STR("unknown operating system target `%.*s\000`", 2, target_os));
				v_exit(1);
			}
 			v__pref__OS target_os_kind = *(v__pref__OS*) _t700.data;
			res->os = target_os_kind;
			array_push(&res->build_options, _MOV((string[]){ string_clone(_STR("%.*s\000 %.*s", 2, arg, target_os)) }));
		} else if (string_eq(_t689, tos_lit("-printfn"))) {
			array_push(&res->printfn_list, _MOV((string[]){ string_clone(os__cmdline__option(current_args, tos_lit("-printfn"), tos_lit(""))) }));
			i++;
		} else if (string_eq(_t689, tos_lit("-cflags"))) {
			res->cflags = /*f*/string_add(res->cflags, string_add(tos_lit(" "), os__cmdline__option(current_args, tos_lit("-cflags"), tos_lit(""))));
			array_push(&res->build_options, _MOV((string[]){ string_clone(_STR("%.*s\000 \"%.*s\000\"", 3, arg, string_trim_space(res->cflags))) }));
			i++;
		} else if (string_eq(_t689, tos_lit("-define")) || string_eq(_t689, tos_lit("-d"))) {
			if (current_args.len > 1) {
				string define = (*(string*)/*ee elem_typ */array_get(current_args, 1));
				v__pref__parse_define(res, define);
			}
			i++;
		} else if (string_eq(_t689, tos_lit("-cc"))) {
			res->ccompiler = os__cmdline__option(current_args, tos_lit("-cc"), tos_lit("cc"));
			array_push(&res->build_options, _MOV((string[]){ string_clone(_STR("%.*s\000 \"%.*s\000\"", 3, arg, res->ccompiler)) }));
			i++;
		} else if (string_eq(_t689, tos_lit("-o"))) {
			res->out_name = os__cmdline__option(current_args, tos_lit("-o"), tos_lit(""));
			if (string_ends_with(res->out_name, tos_lit(".js"))) {
				res->backend = v__pref__Backend_js;
			}
			i++;
		} else if (string_eq(_t689, tos_lit("-b"))) {
			string sbackend = os__cmdline__option(current_args, tos_lit("-b"), tos_lit("c"));
			array_push(&res->build_options, _MOV((string[]){ string_clone(_STR("%.*s\000 %.*s", 2, arg, sbackend)) }));
			Option_v__pref__Backend _t706 = v__pref__backend_from_string(sbackend);
			if (!_t706.ok) {
				string err = _t706.v_error;
				int errcode = _t706.ecode;
				continue;
			}
 			v__pref__Backend b = *(v__pref__Backend*) _t706.data;
			res->backend = b;
			i++;
		} else if (string_eq(_t689, tos_lit("-path"))) {
			string path = os__cmdline__option(current_args, tos_lit("-path"), tos_lit(""));
			array_push(&res->build_options, _MOV((string[]){ string_clone(_STR("%.*s\000 \"%.*s\000\"", 3, arg, path)) }));
			res->lookup_path = string_split(string_replace(path, tos_lit("|"), _const_os__path_delimiter), _const_os__path_delimiter);
			i++;
		} else if (string_eq(_t689, tos_lit("-custom-prelude"))) {
			string path = os__cmdline__option(current_args, tos_lit("-custom-prelude"), tos_lit(""));
			array_push(&res->build_options, _MOV((string[]){ string_clone(_STR("%.*s\000 %.*s", 2, arg, path)) }));
			Option_string _t709 = os__read_file(path);
			if (!_t709.ok) {
				string err = _t709.v_error;
				int errcode = _t709.ecode;
				eprintln(_STR("cannot open custom prelude file: %.*s", 1, err));
				v_exit(1);
			}
 			string prelude = *(string*) _t709.data;
			res->custom_prelude = prelude;
			i++;
		} else if (string_eq(_t689, tos_lit("-name"))) {
			res->display_name = os__cmdline__option(current_args, tos_lit("-name"), tos_lit(""));
			i++;
		} else if (string_eq(_t689, tos_lit("-bundle"))) {
			res->bundle_id = os__cmdline__option(current_args, tos_lit("-bundle"), tos_lit(""));
			i++;
		} else {
			if (string_at(arg, 0) == '-') {
				if (_IN(string, string_substr(arg, 1, arg.len), _const_v__pref__list_of_flags_with_param)) {
					i++;
					continue;
				}
			} else {
				if ((command).len == 0) {
					command = arg;
					command_pos = i;
				}
				continue;
			}
			if ((string_eq(arg, tos_lit("-V")) || string_eq(arg, tos_lit("-version")) || string_eq(arg, tos_lit("--version")))) {
				command = tos_lit("version");
				command_pos = i;
				continue;
			}
			if (!(string_eq(command, tos_lit("")) || string_eq(command, tos_lit("build")) || string_eq(command, tos_lit("build-module")))) {
				continue;
			}
			eprint(_STR("Unknown argument `%.*s\000`", 2, arg));
			eprintln((command.len == 0 ? (tos_lit("")) : (_STR(" for command `%.*s\000`", 2, command))));
			v_exit(1);
		};
	}
	if (string_ne(command, tos_lit("doc")) && string_ends_with(res->out_name, tos_lit(".v"))) {
		eprintln(tos_lit("Cannot save output binary in a .v file."));
		v_exit(1);
	}
	if (string_ends_with(command, tos_lit(".v")) || os__exists(command)) {
		res->path = command;
	} else if (string_eq(command, tos_lit("build"))) {
		if (command_pos + 2 != args.len) {
			eprintln(tos_lit("`v build` requires exactly one argument - either a single .v file, or a single folder/ containing several .v files"));
			v_exit(1);
		}
		res->path = (*(string*)/*ee elem_typ */array_get(args, command_pos + 1));
		v__pref__must_exist(res->path);
	} else if (string_eq(command, tos_lit("run"))) {
		res->is_run = true;
		if (command_pos + 2 > args.len) {
			eprintln(tos_lit("v run: no v files listed"));
			v_exit(1);
		}
		res->path = (*(string*)/*ee elem_typ */array_get(args, command_pos + 1));
		res->run_args = array_slice(args, command_pos + 2, args.len);
		if (string_eq(res->path, tos_lit("-"))) {
			string tmp_file_path = rand__ulid();
			string tmp_exe_file_path = res->out_name;
			string output_option = tos_lit("");
			if ((tmp_exe_file_path).len == 0) {
				tmp_exe_file_path = _STR("%.*s\000.exe", 2, tmp_file_path);
				output_option = _STR("-o \"%.*s\000\"", 2, tmp_exe_file_path);
			}
			string tmp_v_file_path = _STR("%.*s\000.v", 2, tmp_file_path);
			array_string lines = __new_array_with_default(0, 0, sizeof(string), 0);
			for (;;) {
				string iline = os__get_raw_line();
				if (iline.len == 0) {
					break;
				}
				array_push(&lines, _MOV((string[]){ string_clone(iline) }));
			}
			string contents = array_string_join(lines, tos_lit(""));
			Option_void _t711 = os__write_file(tmp_v_file_path, contents);
			if (!_t711.ok && !_t711.is_none) {
				string err = _t711.v_error;
				int errcode = _t711.ecode;
				v_panic(_STR("Failed to create temporary file %.*s", 1, tmp_v_file_path));
			};
			string run_options = array_string_join(os__cmdline__options_before(args, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){tos_lit("run")}))), tos_lit(" "));
			string command_options = array_string_join(array_slice(os__cmdline__options_after(args, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){tos_lit("run")}))), 1, os__cmdline__options_after(args, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){tos_lit("run")}))).len), tos_lit(" "));
			string vexe = v__pref__vexe_path();
			string tmp_cmd = _STR("\"%.*s\000\" %.*s\000 %.*s\000 run \"%.*s\000\" %.*s", 5, vexe, output_option, run_options, tmp_v_file_path, command_options);
			v__pref__Preferences_vrun_elog(res, _STR("tmp_cmd: %.*s", 1, tmp_cmd));
			int tmp_result = os__system(tmp_cmd);
			v__pref__Preferences_vrun_elog(res, _STR("exit code: %"PRId32"", 1, tmp_result));
			if (output_option.len != 0) {
				v__pref__Preferences_vrun_elog(res, _STR("remove tmp exe file: %.*s", 1, tmp_exe_file_path));
				os__rm(tmp_exe_file_path);
			}
			v__pref__Preferences_vrun_elog(res, _STR("remove tmp v file: %.*s", 1, tmp_v_file_path));
			os__rm(tmp_v_file_path);
			v_exit(tmp_result);
		}
		v__pref__must_exist(res->path);
		if (!string_ends_with(res->path, tos_lit(".v")) && os__is_executable(res->path) && os__is_file(res->path) && os__is_file(string_add(res->path, tos_lit(".v")))) {
			eprintln(_STR("It looks like you wanted to run \"%.*s\000.v\", so we went ahead and did that since \"%.*s\000\" is an executable.", 3, res->path, res->path));
			res->path = /*f*/string_add(res->path, tos_lit(".v"));
		}
	}
	if (string_eq(command, tos_lit("build-module"))) {
		res->build_mode = v__pref__BuildMode_build_module;
		res->path = (*(string*)/*ee elem_typ */array_get(args, command_pos + 1));
	}
	map_string_string m = new_map_1(sizeof(string));
	// FOR IN array
	array _t712 = res->build_options;
	for (int _t713 = 0; _t713 < _t712.len; ++_t713) {
		string x = ((string*)_t712.data)[_t713];
		map_set(&m, x, &(string[]) { tos_lit("") });
	}
	res->build_options = map_keys(&m);
	v__pref__Preferences_fill_with_defaults(res);
	return (multi_return_v__pref__Preferences_string){.arg0=res, .arg1=command};
}

VV_LOCAL_SYMBOL void v__pref__Preferences_vrun_elog(v__pref__Preferences* pref, string s) {
	if (pref->is_verbose) {
		eprintln(_STR("> v run -, %.*s", 1, s));
	}
}

VV_LOCAL_SYMBOL void v__pref__must_exist(string path) {
	if (!os__exists(path)) {
		eprintln(_STR("v expects that `%.*s\000` exists, but it does not", 2, path));
		v_exit(1);
	}
}

Option_v__pref__Backend v__pref__backend_from_string(string s) {
	string _t714 = s;
	if (string_eq(_t714, tos_lit("c"))) {
		Option_v__pref__Backend _t715;
		opt_ok2(&(v__pref__Backend[]) { v__pref__Backend_c }, (OptionBase*)(&_t715), sizeof(v__pref__Backend));
		return _t715;
	} else if (string_eq(_t714, tos_lit("js"))) {
		Option_v__pref__Backend _t716;
		opt_ok2(&(v__pref__Backend[]) { v__pref__Backend_js }, (OptionBase*)(&_t716), sizeof(v__pref__Backend));
		return _t716;
	} else if (string_eq(_t714, tos_lit("x64"))) {
		Option_v__pref__Backend _t717;
		opt_ok2(&(v__pref__Backend[]) { v__pref__Backend_x64 }, (OptionBase*)(&_t717), sizeof(v__pref__Backend));
		return _t717;
	} else {
		Option _t718 = v_error(_STR("Unknown backend type %.*s", 1, s));
		return *(Option_v__pref__Backend*)&_t718;
	};
	Option _t719 = opt_none();
	return *(Option_v__pref__Backend*)&_t719;
}

v__pref__CompilerType v__pref__cc_from_string(string cc_str) {
	if (cc_str.len == 0) {
		return v__pref__CompilerType_gcc;
	}
	string cc = string_all_before(*(string*)array_last(string_split(string_replace(cc_str, tos_lit("\\"), tos_lit("/")), tos_lit("/"))), tos_lit("."));
	if (string_contains(cc, tos_lit("++"))) {
		return v__pref__CompilerType_cplusplus;
	}
	if (string_contains(cc, tos_lit("tcc"))) {
		return v__pref__CompilerType_tinyc;
	}
	if (string_contains(cc, tos_lit("tinyc"))) {
		return v__pref__CompilerType_tinyc;
	}
	if (string_contains(cc, tos_lit("clang"))) {
		return v__pref__CompilerType_clang;
	}
	if (string_contains(cc, tos_lit("mingw"))) {
		return v__pref__CompilerType_mingw;
	}
	if (string_contains(cc, tos_lit("msvc"))) {
		return v__pref__CompilerType_msvc;
	}
	return v__pref__CompilerType_gcc;
}

VV_LOCAL_SYMBOL void v__pref__parse_define(v__pref__Preferences* prefs, string define) {
	array_string define_parts = string_split(define, tos_lit("="));
	if (define_parts.len == 1) {
		array_push(&prefs->compile_defines, _MOV((string[]){ string_clone(define) }));
		array_push(&prefs->compile_defines_all, _MOV((string[]){ string_clone(define) }));
		return;
	}
	if (define_parts.len == 2) {
		array_push(&prefs->compile_defines_all, _MOV((string[]){ string_clone((*(string*)/*ee elem_typ */array_get(define_parts, 0))) }));
		string _t723 = (*(string*)/*ee elem_typ */array_get(define_parts, 1));
		if (string_eq(_t723, tos_lit("0"))) {
		} else if (string_eq(_t723, tos_lit("1"))) {
			array_push(&prefs->compile_defines, _MOV((string[]){ string_clone((*(string*)/*ee elem_typ */array_get(define_parts, 0))) }));
		} else {
			println(string_add(_STR("V error: Unknown define argument value `%.*s\000` for %.*s\000.", 3, (*(string*)/*ee elem_typ */array_get(define_parts, 1)), (*(string*)/*ee elem_typ */array_get(define_parts, 0))), tos_lit(" Expected `0` or `1`.")));
			v_exit(1);
		};
		return;
	}
	println(_STR("V error: Unknown define argument: %.*s\000. Expected at most one `=`.", 2, define));
	v_exit(1);
}

array_string v__pref__Preferences_should_compile_filtered_files(v__pref__Preferences* prefs, string dir, array_string files_) {
	array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	array_string files = array_clone(&files_);
	qsort(files.data, files.len, files.element_size, (int (*)(const void *, const void *))&compare_strings);
	;
	// FOR IN array
	array _t725 = files;
	for (int _t726 = 0; _t726 < _t725.len; ++_t726) {
		string file = ((string*)_t725.data)[_t726];
		if (!string_ends_with(file, tos_lit(".v")) && !string_ends_with(file, tos_lit(".vh"))) {
			continue;
		}
		if (string_ends_with(file, tos_lit("_test.v"))) {
			continue;
		}
		if (prefs->backend == v__pref__Backend_c && !v__pref__Preferences_should_compile_c(prefs, file)) {
			continue;
		}
		if (prefs->backend == v__pref__Backend_js && !v__pref__Preferences_should_compile_js(prefs, file)) {
			continue;
		}
		if (prefs->compile_defines_all.len > 0 && string_contains(file, tos_lit("_d_"))) {
			bool allowed = false;
			// FOR IN array
			array _t727 = prefs->compile_defines;
			for (int _t728 = 0; _t728 < _t727.len; ++_t728) {
				string cdefine = ((string*)_t727.data)[_t728];
				string file_postfix = _STR("_d_%.*s\000.v", 2, cdefine);
				if (string_ends_with(file, file_postfix)) {
					allowed = true;
					break;
				}
			}
			if (!allowed) {
				continue;
			}
		}
		array_push(&res, _MOV((string[]){ string_clone(os__join_path(dir, (varg_string){.len=1,.args={file}})) }));
	}
	return res;
}

bool v__pref__Preferences_should_compile_c(v__pref__Preferences* prefs, string file) {
	if (!string_ends_with(file, tos_lit(".c.v")) && string_split(file, tos_lit(".")).len > 2) {
		return false;
	}
	if ((string_ends_with(file, tos_lit("_windows.c.v")) || string_ends_with(file, tos_lit("_windows.v"))) && prefs->os != v__pref__OS_windows) {
		return false;
	}
	if ((string_ends_with(file, tos_lit("_linux.c.v")) || string_ends_with(file, tos_lit("_linux.v"))) && prefs->os != v__pref__OS_linux) {
		return false;
	}
	if ((string_ends_with(file, tos_lit("_darwin.c.v")) || string_ends_with(file, tos_lit("_darwin.v"))) && prefs->os != v__pref__OS_macos) {
		return false;
	}
	if ((string_ends_with(file, tos_lit("_macos.c.v")) || string_ends_with(file, tos_lit("_macos.v"))) && prefs->os != v__pref__OS_macos) {
		return false;
	}
	if (string_ends_with(file, tos_lit("_nix.c.v")) && prefs->os == v__pref__OS_windows) {
		return false;
	}
	if (string_ends_with(file, tos_lit("_android.c.v")) && prefs->os != v__pref__OS_android) {
		return false;
	}
	if (string_ends_with(file, tos_lit("_freebsd.c.v")) && prefs->os != v__pref__OS_freebsd) {
		return false;
	}
	if (string_ends_with(file, tos_lit("_openbsd.c.v")) && prefs->os != v__pref__OS_openbsd) {
		return false;
	}
	if (string_ends_with(file, tos_lit("_netbsd.c.v")) && prefs->os != v__pref__OS_netbsd) {
		return false;
	}
	if (string_ends_with(file, tos_lit("_dragonfly.c.v")) && prefs->os != v__pref__OS_dragonfly) {
		return false;
	}
	if (string_ends_with(file, tos_lit("_solaris.c.v")) && prefs->os != v__pref__OS_solaris) {
		return false;
	}
	if (string_ends_with(file, tos_lit("_x64.v")) && prefs->backend != v__pref__Backend_x64) {
		return false;
	}
	return true;
}

bool v__pref__Preferences_should_compile_js(v__pref__Preferences* prefs, string file) {
	if (!string_ends_with(file, tos_lit(".js.v")) && string_split(file, tos_lit(".")).len > 2) {
		return false;
	}
	return true;
}

void help__print_and_exit(string topic) {
	string vexe = v__pref__vexe_path();
	string vroot = os__dir(vexe);
	for (int _t730 = 0; _t730 < topic.len; ++_t730) {
		byte b = topic.str[_t730];
		if ((b >= 'a' && b <= 'z') || b == '-' || (b >= '0' && b <= '9')) {
			continue;
		}
		eprintln(_const_help__unknown_topic);
		v_exit(1);
	}
	string target_topic = os__join_path(vroot, (varg_string){.len=4,.args={tos_lit("cmd"), tos_lit("v"), tos_lit("help"), _STR("%.*s\000.txt", 2, topic)}});
	Option_string _t731 = os__read_file(target_topic);
	if (!_t731.ok) {
		string err = _t731.v_error;
		int errcode = _t731.ecode;
		eprintln(_const_help__unknown_topic);
		v_exit(1);
	}
 	string content = *(string*) _t731.data;
	println(content);
	v_exit(0);
}

Option_string v__util__find_working_diff_command() {
	string env_difftool = os__getenv(tos_lit("VDIFF_TOOL"));
	string env_diffopts = os__getenv(tos_lit("VDIFF_OPTIONS"));
	array_string known_diff_tools = __new_array_with_default(0, 0, sizeof(string), 0);
	if (env_difftool.len > 0) {
		array_push(&known_diff_tools, _MOV((string[]){ string_clone(env_difftool) }));
	}
	_PUSH_MANY(&known_diff_tools, (new_array_from_c_array(8, 8, sizeof(string), _MOV((string[8]){tos_lit("colordiff"), tos_lit("gdiff"), tos_lit("diff"), tos_lit("colordiff.exe"), tos_lit("diff.exe"), tos_lit("opendiff"), tos_lit("code"), tos_lit("code.cmd")}))), _t733, array_string);
	// FOR IN array
	array _t734 = known_diff_tools;
	for (int _t735 = 0; _t735 < _t734.len; ++_t735) {
		string diffcmd = ((string*)_t734.data)[_t735];
		if (string_eq(diffcmd, tos_lit("opendiff"))) {
			if (v__util__opendiff_exists()) {
				Option_string _t736;
				opt_ok2(&(string[]) { diffcmd }, (OptionBase*)(&_t736), sizeof(string));
				return _t736;
			}
			continue;
		}
		Option_os__Result _t737 = os__exec(_STR("%.*s\000 --version", 2, diffcmd));
		if (!_t737.ok) {
			string err = _t737.v_error;
			int errcode = _t737.ecode;
			continue;
		}
 		os__Result p = *(os__Result*) _t737.data;
		if (p.exit_code == 127 && string_eq(diffcmd, env_difftool)) {
			Option _t738 = v_error(_STR("could not find specified VDIFF_TOOL %.*s", 1, diffcmd));
			return *(Option_string*)&_t738;
		}
		if (p.exit_code == 0) {
			if ((string_eq(diffcmd, tos_lit("code")) || string_eq(diffcmd, tos_lit("code.cmd")))) {
				Option_string _t739;
				opt_ok2(&(string[]) { _STR("%.*s\000 %.*s\000 -d", 3, diffcmd, env_diffopts) }, (OptionBase*)(&_t739), sizeof(string));
				return _t739;
			}
			Option_string _t740;
			opt_ok2(&(string[]) { _STR("%.*s\000 %.*s", 2, diffcmd, env_diffopts) }, (OptionBase*)(&_t740), sizeof(string));
			return _t740;
		}
	}
	Option _t741 = v_error(tos_lit("No working \"diff\" command found"));
	return *(Option_string*)&_t741;
}

VV_LOCAL_SYMBOL bool v__util__opendiff_exists() {
	Option_os__Result _t742 = os__exec(tos_lit("opendiff"));
	if (!_t742.ok) {
		string err = _t742.v_error;
		int errcode = _t742.ecode;
		return false;
	}
 	os__Result o = *(os__Result*) _t742.data;
	if (o.exit_code == 1) {
		if (string_contains(o.output, tos_lit("too few arguments"))) {
			return true;
		}
	}
	return false;
}

string v__util__color_compare_files(string diff_cmd, string file1, string file2) {
	if ((diff_cmd).len != 0) {
		string full_cmd = _STR("%.*s\000 --minimal --text --unified=2  --show-function-line=\"fn \" \"%.*s\000\" \"%.*s\000\" ", 4, diff_cmd, file1, file2);
		Option_os__Result _t743 = os__exec(full_cmd);
		if (!_t743.ok) {
			string err = _t743.v_error;
			int errcode = _t743.ecode;
			return _STR("comparison command: `%.*s\000` failed", 2, full_cmd);
		}
 		os__Result x = *(os__Result*) _t743.data;
		return string_trim_right(x.output, tos_lit("\r\n"));
	}
	return tos_lit("");
}

string v__util__color_compare_strings(string diff_cmd, string expected, string found) {
	string cdir = os__cache_dir();
	u64 ctime = time__sys_mono_now();
	string e_file = os__join_path(cdir, (varg_string){.len=1,.args={_STR("%"PRIu64"\000.expected.txt", 2, ctime)}});
	string f_file = os__join_path(cdir, (varg_string){.len=1,.args={_STR("%"PRIu64"\000.found.txt", 2, ctime)}});
	os__write_file(e_file, expected);
	os__write_file(f_file, found);
	string res = v__util__color_compare_files(diff_cmd, e_file, f_file);
	os__rm(e_file);
	os__rm(f_file);
	return res;
}

v__util__EManager* v__util__new_error_manager() {
	return (v__util__EManager*)memdup(&(v__util__EManager){.support_color = term__can_show_color_on_stderr() && term__can_show_color_on_stdout(),}, sizeof(v__util__EManager));
}

void v__util__EManager_set_support_color(v__util__EManager* e, bool b) {
	{ // Unsafe block
		v__util__EManager* me = e;
		me->support_color = b;
	}
}

string v__util__bold(string msg) {
	if (!_const_v__util__emanager->support_color) {
		return msg;
	}
	return term__bold(msg);
}

VV_LOCAL_SYMBOL string v__util__color(string kind, string msg) {
	if (!_const_v__util__emanager->support_color) {
		return msg;
	}
	if (string_contains(kind, tos_lit("error"))) {
		return term__red(msg);
	} else {
		return term__magenta(msg);
	}
	return (string){.str=(byteptr)""};
}

string v__util__formatted_error(string kind, string omsg, string filepath, v__token__Position pos) {
	string emsg = string_replace(omsg, tos_lit("main."), tos_lit(""));
	string path = filepath;
	string verror_paths_override = os__getenv(tos_lit("VERROR_PATHS"));
	if (string_eq(verror_paths_override, tos_lit("absolute"))) {
		path = os__real_path(path);
	} else {
		string workdir = string_add(os__getwd(), _const_os__path_separator);
		if (string_starts_with(path, workdir)) {
			path = string_replace(path, workdir, tos_lit(""));
		}
	}
	multi_return_string_int mr_2188 = v__util__filepath_pos_to_source_and_column(filepath, pos);
	string source = mr_2188.arg0;
	int column = mr_2188.arg1;
	string position = _STR("%.*s\000:%"PRId32"\000:%"PRId32"\000:", 4, path, pos.line_nr + 1, v__util__imax(1, column + 1));
	string scontext = array_string_join(v__util__source_context(kind, source, column, pos), tos_lit("\n"));
	string final_position = v__util__bold(position);
	string final_kind = v__util__bold(v__util__color(kind, kind));
	string final_msg = emsg;
	string final_context = (scontext.len > 0 ? (_STR("\n%.*s", 1, scontext)) : (tos_lit("")));
	return string_trim_space(_STR("%.*s\000 %.*s\000 %.*s\000%.*s", 4, final_position, final_kind, final_msg, final_context));
}

multi_return_string_int v__util__filepath_pos_to_source_and_column(string filepath, v__token__Position pos) {
	Option_string _t744 = v__util__read_file(filepath);
	if (!_t744.ok) {
		string err = _t744.v_error;
		int errcode = _t744.ecode;
		*(string*) _t744.data = tos_lit("");
	}
 	string source = *(string*) _t744.data;
	int p = v__util__imax(0, v__util__imin(source.len - 1, pos.pos));
	if (source.len > 0) {
		for (; p >= 0; p--) {
			if (string_at(source, p) == '\n' || string_at(source, p) == '\r') {
				break;
			}
		}
	}
	int column = v__util__imax(0, pos.pos - p - 1);
	return (multi_return_string_int){.arg0=source, .arg1=column};
}

array_string v__util__source_context(string kind, string source, int column, v__token__Position pos) {
	array_string clines = __new_array_with_default(0, 0, sizeof(string), 0);
	if (source.len == 0) {
		return clines;
	}
	array_string source_lines = string_split_into_lines(source);
	int bline = v__util__imax(0, pos.line_nr - _const_v__util__error_context_before);
	int aline = v__util__imax(0, v__util__imin(source_lines.len - 1, pos.line_nr + _const_v__util__error_context_after));
	string tab_spaces = tos_lit("    ");
	for (int iline = bline; iline <= aline; iline++) {
		string sline = (*(string*)/*ee elem_typ */array_get(source_lines, iline));
		int start_column = v__util__imax(0, v__util__imin(column, sline.len));
		int end_column = v__util__imax(0, v__util__imin(column + v__util__imax(0, pos.len), sline.len));
		string cline = (iline == pos.line_nr ? (string_add(string_add(string_substr(sline, 0, start_column), v__util__color(kind, string_substr(sline, start_column, end_column))), string_substr(sline, end_column, sline.len))) : (sline));
		array_push(&clines, _MOV((string[]){ string_clone(string_add(_STR("%5"PRId32"\000 | ", 2, iline + 1), string_replace(cline, tos_lit("\t"), tab_spaces))) }));
		if (iline == pos.line_nr) {
			string pointerline = tos_lit("");
			for (int _t746 = 0; _t746 < string_substr(sline, 0, start_column).len; ++_t746) {
				byte bchar = string_substr(sline, 0, start_column).str[_t746];
				byte x = (byte_is_space(bchar) ? (bchar) : (' '));
				pointerline = /*f*/string_add(pointerline, byte_str(x));
			}
			string underline = (pos.len > 1 ? (string_repeat(tos_lit("~"), end_column - start_column)) : (tos_lit("^")));
			pointerline = /*f*/string_add(pointerline, v__util__bold(v__util__color(kind, underline)));
			array_push(&clines, _MOV((string[]){ string_clone(string_add(tos_lit("      | "), string_replace(pointerline, tos_lit("\t"), tab_spaces))) }));
		}
	}
	return clines;
}

void v__util__verror(string kind, string s) {
	string final_kind = v__util__bold(v__util__color(kind, kind));
	eprintln(_STR("%.*s\000: %.*s", 2, final_kind, s));
	v_exit(1);
}

string v__util__vlines_escape_path(string path, string ccompiler) {
	bool is_cc_tcc = string_contains(ccompiler, tos_lit("tcc"));
	if (is_cc_tcc) {
		return string_add(tos_lit("../../../../../.."), v__util__cescaped_path(os__real_path(path)));
	}
	return v__util__cescaped_path(os__real_path(path));
}

string v__util__smart_quote(string str, bool raw) {
	int len = str.len;
	if (len == 0) {
		return str;
	}
	strings__Builder result = strings__new_builder(0);
	int pos = -1;
	string last = tos_lit("");
	string next = tos_lit("");
	bool skip_next = false;
	for (;;) {
		pos = pos + 1;
		if (skip_next) {
			skip_next = false;
			pos = pos + 1;
		}
		if (pos >= len) {
			break;
		}
		if (pos + 1 < len) {
			{ // Unsafe block
				next = byte_str(str.str[pos + 1]);
			}
		}
		string current = str;
		string toadd = str;
		if (len > 1) {
			{ // Unsafe block
				current = byte_str(str.str[pos]);
			}
			toadd = current;
		}
		if (string_eq(current, tos_lit("\""))) {
			toadd = tos_lit("\\\"");
			current = tos_lit("");
		}
		if (string_eq(current, tos_lit("\\"))) {
			if (raw) {
				toadd = tos_lit("\\\\");
			} else {
				if (string_eq(next, tos_lit("\\"))) {
					toadd = tos_lit("\\\\");
					skip_next = true;
				} else if ((next).len != 0) {
					if (raw) {
						toadd = string_add(tos_lit("\\\\"), next);
						skip_next = true;
					} else if (!_IN(string, next, _const_v__util__invalid_escapes)) {
						toadd = string_add(tos_lit("\\"), next);
						skip_next = true;
					} else {
						toadd = next;
						skip_next = true;
					}
				}
			}
		}
		if (string_eq(current, tos_lit("\n"))) {
			toadd = tos_lit("\\n");
			current = tos_lit("");
		} else if (string_eq(current, tos_lit("\r")) && string_eq(next, tos_lit("\n"))) {
			toadd = tos_lit("\r\n");
			current = tos_lit("");
			skip_next = true;
		}
		if (!raw && string_eq(current, tos_lit("$"))) {
			if (string_eq(last, tos_lit("\\"))) {
				toadd = tos_lit("\\$");
			}
		}
		if (!raw && string_eq(current, tos_lit("\r"))) {
			if (string_eq(next, tos_lit("\n"))) {
				skip_next = true;
				toadd = tos_lit("\\n");
			}
		}
		strings__Builder_write(&result, toadd);
		last = current;
	}
	return strings__Builder_str(&result);
}

// Attr: [inline]
inline bool v__util__is_name_char(byte c) {
	return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_';
}

// Attr: [inline]
inline bool v__util__is_func_char(byte c) {
	return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_' || byte_is_digit(c);
}

// Attr: [inline]
inline bool v__util__is_nl(byte c) {
	return c == '\r' || c == '\n';
}

bool v__util__contains_capital(string s) {
	for (int _t748 = 0; _t748 < s.len; ++_t748) {
		byte c = s.str[_t748];
		if (c >= 'A' && c <= 'Z') {
			return true;
		}
	}
	return false;
}

bool v__util__good_type_name(string s) {
	if (s.len < 4) {
		return true;
	}
	for (int i = 2; i < s.len; ++i) {
		if (byte_is_capital(string_at(s, i)) && byte_is_capital(string_at(s, i - 1)) && byte_is_capital(string_at(s, i - 2))) {
			return false;
		}
	}
	return true;
}

string v__util__cescaped_path(string s) {
	return string_replace(s, tos_lit("\\"), tos_lit("\\\\"));
}

VV_LOCAL_SYMBOL int v__util__compare_by_similarity(v__util__Possibility* a, v__util__Possibility* b) {
	if (a->similarity < b->similarity) {
		return -1;
	}
	if (a->similarity > b->similarity) {
		return 1;
	}
	return 0;
}

v__util__Suggestion v__util__new_suggestion(string wanted, array_string possibilities) {
	v__util__Suggestion s = (v__util__Suggestion){.known = __new_array(0, 1, sizeof(v__util__Possibility)),.wanted = wanted,.swanted = v__util__short_module_name(wanted),};
	v__util__Suggestion_add_many(&s, possibilities);
	v__util__Suggestion_sort(&s);
	return s;
}

void v__util__Suggestion_add(v__util__Suggestion* s, string val) {
	if ((string_eq(val, s->wanted) || string_eq(val, s->swanted))) {
		return;
	}
	string sval = v__util__short_module_name(val);
	if ((string_eq(sval, s->wanted) || string_eq(sval, s->swanted))) {
		return;
	}
	array_push(&s->known, _MOV((v__util__Possibility[]){ (v__util__Possibility){.value = val,.svalue = sval,.similarity = strings__dice_coefficient(s->swanted, sval),} }));
}

void v__util__Suggestion_add_many(v__util__Suggestion* s, array_string many) {
	// FOR IN array
	array _t750 = many;
	for (int _t751 = 0; _t751 < _t750.len; ++_t751) {
		string x = ((string*)_t750.data)[_t751];
		v__util__Suggestion_add(s, x);
	}
}

void v__util__Suggestion_sort(v__util__Suggestion* s) {
	array_sort_with_compare(&s->known, v__util__compare_by_similarity);
}

string v__util__Suggestion_say(v__util__Suggestion s, string msg) {
	string res = msg;
	bool found = false;
	if (s.known.len > 0) {
		v__util__Possibility top_posibility = *(v__util__Possibility*)array_last(s.known);
		if (top_posibility.similarity > 0.10) {
			string val = top_posibility.value;
			if (!string_starts_with(val, tos_lit("[]"))) {
				res = /*f*/string_add(res, _STR(".\nDid you mean `%.*s\000`?", 2, val));
				found = true;
			}
		}
	}
	if (!found) {
		if (s.known.len > 0) {

			int _t752_len = s.known.len;
			array_string _t752 = __new_array(0, _t752_len, sizeof(string));
			for (int _t753 = 0; _t753 < _t752_len; ++_t753) {
				v__util__Possibility it = ((v__util__Possibility*) s.known.data)[_t753];
				string ti = _STR("`%.*s\000`", 2, it.svalue);
				array_push(&_t752, &ti);
			}
						array_string values = _t752;
			qsort(values.data, values.len, values.element_size, (int (*)(const void *, const void *))&compare_strings);
			;
			if (values.len == 1) {
				res = /*f*/string_add(res, _STR(".\n1 possibility: %.*s\000.", 2, (*(string*)/*ee elem_typ */array_get(values, 0))));
			} else if (values.len < 25) {
				res = /*f*/string_add(res, string_add(string_add(_STR(".\n%"PRId32"\000 possibilities: ", 2, values.len), array_string_join(values, tos_lit(", "))), tos_lit(".")));
			}
		}
	}
	return res;
}

string v__util__short_module_name(string name) {
	if (!string_contains(name, tos_lit("."))) {
		return name;
	}
	array_string vals = string_split(name, tos_lit("."));
	if (vals.len < 2) {
		return name;
	}
	string mname = (*(string*)/*ee elem_typ */array_get(vals, vals.len - 2));
	string symname = (*(string*)/*ee elem_typ */array_get(vals, vals.len - 1));
	return _STR("%.*s\000.%.*s", 2, mname, symname);
}

string v__util__vhash() {
	array_fixed_byte_50 buf = {0};
	buf[0] = 0;
	snprintf(((charptr)(buf)), 50, "%s", V_COMMIT_HASH);
	return tos_clone((voidptr)&/*qq*/buf);
}

string v__util__full_hash() {
	string build_hash = v__util__vhash();
	string current_hash = v__util__githash(false);
	if (string_eq(build_hash, current_hash)) {
		return build_hash;
	}
	return _STR("%.*s\000.%.*s", 2, build_hash, current_hash);
}

string v__util__full_v_version(bool is_verbose) {
	if (is_verbose) {
		return _STR("V %.*s\000 %.*s", 2, _const_v__util__v_version, v__util__full_hash());
	}
	string hash = v__util__githash(false);
	return _STR("V %.*s\000 %.*s", 2, _const_v__util__v_version, hash);
}

string v__util__githash(bool should_get_from_filesystem) {
	for (;;) {
		if (should_get_from_filesystem) {
			string vexe = os__getenv(tos_lit("VEXE"));
			string vroot = os__dir(vexe);
			string git_head_file = os__join_path(vroot, (varg_string){.len=2,.args={tos_lit(".git"), tos_lit("HEAD")}});
			if (!os__exists(git_head_file)) {
				break;
			}
			Option_string _t754 = os__read_file(git_head_file);
			if (!_t754.ok) {
				string err = _t754.v_error;
				int errcode = _t754.ecode;
				break;
			}
 			string head_content = *(string*) _t754.data;
			string current_branch_hash = head_content;
			if (string_starts_with(head_content, tos_lit("ref: "))) {
				string gcbranch_rel_path = string_trim_space(string_replace(head_content, tos_lit("ref: "), tos_lit("")));
				string gcbranch_file = os__join_path(vroot, (varg_string){.len=2,.args={tos_lit(".git"), gcbranch_rel_path}});
				if (!os__exists(gcbranch_file)) {
					break;
				}
				Option_string _t755 = os__read_file(gcbranch_file);
				if (!_t755.ok) {
					string err = _t755.v_error;
					int errcode = _t755.ecode;
					break;
				}
 				string branch_hash = *(string*) _t755.data;
				current_branch_hash = branch_hash;
			}
			int desired_hash_length = 7;
			if (current_branch_hash.len > desired_hash_length) {
				return string_substr(current_branch_hash, 0, desired_hash_length);
			}
		}
		break;
	}
	array_fixed_byte_50 buf = {0};
	buf[0] = 0;
	snprintf(((charptr)(buf)), 50, "%s", V_CURRENT_COMMIT_HASH);
	return tos_clone((voidptr)&/*qq*/buf);
}

void v__util__set_vroot_folder(string vroot_path) {
	string vname = (string_eq(os__user_os(), tos_lit("windows")) ? (tos_lit("v.exe")) : (tos_lit("v")));
	os__setenv(tos_lit("VEXE"), os__real_path(os__join_path(vroot_path, (varg_string){.len=1,.args={vname}})), true);
	os__setenv(tos_lit("VCHILD"), tos_lit("true"), true);
}

Option_string v__util__resolve_vroot(string str, string dir) {
	v__vmod__ModFileCacher* mcache = v__vmod__get_cache();
	v__vmod__ModFileAndFolder vmod_file_location = v__vmod__ModFileCacher_get_by_folder(mcache, dir);
	if (vmod_file_location.vmod_file.len == 0) {
		Option _t756 = v_error(_STR("To use @VROOT, you need to have a \"v.mod\" file in %.*s\000, or in one of its parent folders.", 2, dir));
		return *(Option_string*)&_t756;
	}
	string vmod_path = vmod_file_location.vmod_folder;
	Option_string _t757;
	opt_ok2(&(string[]) { string_replace(str, tos_lit("@VROOT"), os__real_path(vmod_path)) }, (OptionBase*)(&_t757), sizeof(string));
	return _t757;
}

void v__util__launch_tool(bool is_verbose, string tool_name, array_string args) {
	string vexe = v__pref__vexe_path();
	string vroot = os__dir(vexe);
	v__util__set_vroot_folder(vroot);
	string tool_args = v__util__args_quote_paths(args);
	string tool_basename = os__real_path(os__join_path(vroot, (varg_string){.len=3,.args={tos_lit("cmd"), tos_lit("tools"), tool_name}}));
	string tool_exe = v__util__path_of_executable(tool_basename);
	string tool_source = string_add(tool_basename, tos_lit(".v"));
	string tool_command = _STR("\"%.*s\000\" %.*s", 2, tool_exe, tool_args);
	if (is_verbose) {
		println(_STR("launch_tool vexe        : %.*s", 1, vroot));
		println(_STR("launch_tool vroot       : %.*s", 1, vroot));
		println(_STR("launch_tool tool_args   : %.*s", 1, tool_args));
		println(_STR("launch_tool tool_command: %.*s", 1, tool_command));
	}
	bool should_compile = v__util__should_recompile_tool(vexe, tool_source);
	if (is_verbose) {
		println(_STR("launch_tool should_compile: %.*s", 1, should_compile ? _SLIT("true") : _SLIT("false")));
	}
	if (should_compile) {
		array_string emodules = (*(array_string*)map_get(_const_v__util__external_module_dependencies_for_tool, tool_name, &(array_string[]){ __new_array(0, 1, sizeof(string)) }));
		// FOR IN array
		array _t758 = emodules;
		for (int _t759 = 0; _t759 < _t758.len; ++_t759) {
			string emodule = ((string*)_t758.data)[_t759];
			Option_bool _t760 = v__util__check_module_is_installed(emodule, is_verbose);
			if (!_t760.ok) {
				string err = _t760.v_error;
				int errcode = _t760.ecode;
				v_panic(err);
			};
		}
		string compilation_command = _STR("\"%.*s\000\" ", 2, vexe);
		compilation_command = /*f*/string_add(compilation_command, _STR("\"%.*s\000\"", 2, tool_source));
		if (is_verbose) {
			println(_STR("Compiling %.*s\000 with: \"%.*s\000\"", 3, tool_name, compilation_command));
		}
		Option_os__Result _t761 = os__exec(compilation_command);
		if (!_t761.ok) {
			string err = _t761.v_error;
			int errcode = _t761.ecode;
			v_panic(err);
		}
 		os__Result tool_compilation = *(os__Result*) _t761.data;
		if (tool_compilation.exit_code != 0) {
			eprintln(_STR("cannot compile `%.*s\000`: \n%.*s", 2, tool_source, tool_compilation.output));
			v_exit(1);
		}
	}
	if (is_verbose) {
		println(_STR("launch_tool running tool command: %.*s\000 ...", 2, tool_command));
	}
	v_exit(os__system(tool_command));
}

bool v__util__should_recompile_tool(string vexe, string tool_source) {
	string sfolder = os__dir(tool_source);
	string tool_name = string_replace(os__base(tool_source), tos_lit(".v"), tos_lit(""));
	string tool_exe = os__join_path(sfolder, (varg_string){.len=1,.args={v__util__path_of_executable(tool_name)}});
	bool should_compile = false;
	if (!os__exists(tool_exe)) {
		should_compile = true;
	} else {
		if (os__file_last_mod_unix(tool_exe) <= os__file_last_mod_unix(vexe)) {
			should_compile = true;
			if (string_eq(tool_name, tos_lit("vself")) || string_eq(tool_name, tos_lit("vup"))) {
				should_compile = false;
			}
		}
		if (os__file_last_mod_unix(tool_exe) <= os__file_last_mod_unix(tool_source)) {
			should_compile = true;
		}
	}
	return should_compile;
}

string v__util__quote_path(string s) {
	string qs = s;
	if (string_contains(qs, tos_lit("&"))) {
		qs = string_replace(qs, tos_lit("&"), tos_lit("\\&"));
	}
	if (string_contains(qs, tos_lit(" "))) {
		return _STR("\"%.*s\000\"", 2, qs);
	}
	return qs;
}

string v__util__args_quote_paths(array_string args) {
	array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	// FOR IN array
	array _t762 = args;
	for (int _t763 = 0; _t763 < _t762.len; ++_t763) {
		string a = ((string*)_t762.data)[_t763];
		array_push(&res, _MOV((string[]){ string_clone(v__util__quote_path(a)) }));
	}
	return array_string_join(res, tos_lit(" "));
}

string v__util__path_of_executable(string path) {
	#if defined(_WIN32)
	{
		return string_add(path, tos_lit(".exe"));
	}
	#endif
	return path;
}

Option_string v__util__read_file(string file_path) {
	Option_string _t765 = os__read_file(file_path);
	if (!_t765.ok) {
		string err = _t765.v_error;
		int errcode = _t765.ecode;
		Option _t766 = v_error(_STR("failed to open %.*s", 1, file_path));
		return *(Option_string*)&_t766;
	}
 	string raw_text = *(string*) _t765.data;
	Option_string _t767;
	opt_ok2(&(string[]) { v__util__skip_bom(raw_text) }, (OptionBase*)(&_t767), sizeof(string));
	return _t767;
}

string v__util__skip_bom(string file_content) {
	string raw_text = file_content;
	if (raw_text.len >= 3) {
		{ // Unsafe block
			byteptr c_text = raw_text.str;
			if (c_text[0] == 0xEF && c_text[1] == 0xBB && c_text[2] == 0xBF) {
				int offset_from_begin = 3;
				raw_text = tos((voidptr)&/*qq*/c_text[offset_from_begin], vstrlen(c_text) - offset_from_begin);
			}
		}
	}
	return raw_text;
}

// Attr: [inline]
inline int v__util__imin(int a, int b) {
	return (a < b ? (a) : (b));
}

// Attr: [inline]
inline int v__util__imax(int a, int b) {
	return (a > b ? (a) : (b));
}

string v__util__replace_op(string s) {
	byte last_char = string_at(s, s.len - 1);
	byte _t768 = last_char;
		string suffix = ((_t768 == '+') ? (tos_lit("_plus")) : (_t768 == '-') ? (tos_lit("_minus")) : (_t768 == '*') ? (tos_lit("_mult")) : (_t768 == '/') ? (tos_lit("_div")) : (_t768 == '%') ? (tos_lit("_mod")) : (tos_lit("")));
	return string_add(string_substr(s, 0, s.len - 1), suffix);
}

array_string v__util__join_env_vflags_and_os_args() {
	string vosargs = os__getenv(tos_lit("VOSARGS"));
	if ((vosargs).len != 0) {
		return v__util__non_empty(string_split(vosargs, tos_lit(" ")));
	}
	array_string args = __new_array_with_default(0, 0, sizeof(string), 0);
	string vflags = os__getenv(tos_lit("VFLAGS"));
	if ((vflags).len != 0) {
		array_push(&args, _MOV((string[]){ string_clone((*(string*)/*ee elem_typ */array_get(_const_os__args, 0))) }));
		_PUSH_MANY(&args, (string_split(vflags, tos_lit(" "))), _t770, array_string);
		if (_const_os__args.len > 1) {
			_PUSH_MANY(&args, (array_slice(_const_os__args, 1, _const_os__args.len)), _t771, array_string);
		}
		return v__util__non_empty(args);
	}
	return v__util__non_empty(_const_os__args);
}

VV_LOCAL_SYMBOL array_string v__util__non_empty(array_string arg) {

int _t772_len = arg.len;
	array_string _t772 = __new_array(0, _t772_len, sizeof(string));
	for (int i = 0; i < _t772_len; ++i) {
	  string it = ((string*) arg.data)[i];
	if ((it).len != 0) array_push(&_t772, &it); 
 }
		return  _t772;
}

Option_bool v__util__check_module_is_installed(string modulename, bool is_verbose) {
	string mpath = os__join_path(os__vmodules_dir(), (varg_string){.len=1,.args={modulename}});
	string mod_v_file = os__join_path(mpath, (varg_string){.len=1,.args={tos_lit("v.mod")}});
	string murl = _STR("https://github.com/vlang/%.*s", 1, modulename);
	if (is_verbose) {
		eprintln(_STR("check_module_is_installed: mpath: %.*s", 1, mpath));
		eprintln(_STR("check_module_is_installed: mod_v_file: %.*s", 1, mod_v_file));
		eprintln(_STR("check_module_is_installed: murl: %.*s", 1, murl));
	}
	if (os__exists(mod_v_file)) {
		string vexe = v__pref__vexe_path();
		string update_cmd = _STR("\"%.*s\000\" update \"%.*s\000\"", 3, vexe, modulename);
		if (is_verbose) {
			eprintln(_STR("check_module_is_installed: updating with %.*s\000 ...", 2, update_cmd));
		}
		Option_os__Result _t773 = os__exec(update_cmd);
		if (!_t773.ok) {
			string err = _t773.v_error;
			int errcode = _t773.ecode;
			Option _t774 = v_error(_STR("can not start %.*s\000, error: %.*s", 2, update_cmd, err));
			return *(Option_bool*)&_t774;
		}
 		os__Result update_res = *(os__Result*) _t773.data;
		if (update_res.exit_code != 0) {
			eprintln(_STR("Warning: `%.*s\000` exists, but is not updated.\nV will continue, since updates can fail due to temporary network problems,\nand the existing module `%.*s\000` may still work.", 3, modulename, modulename));
			if (is_verbose) {
				eprintln(tos_lit("Details:"));
				eprintln(update_res.output);
			}
			eprintln(string_repeat(tos_lit("-"), 50));
		}
		Option_bool _t775;
		opt_ok2(&(bool[]) { true }, (OptionBase*)(&_t775), sizeof(bool));
		return _t775;
	}
	if (is_verbose) {
		eprintln(_STR("check_module_is_installed: cloning from %.*s\000 ...", 2, murl));
	}
	Option_os__Result _t776 = os__exec(_STR("git clone %.*s\000 %.*s", 2, murl, mpath));
	if (!_t776.ok) {
		string err = _t776.v_error;
		int errcode = _t776.ecode;
		Option _t777 = v_error(_STR("git is not installed, error: %.*s", 1, err));
		return *(Option_bool*)&_t777;
	}
 	os__Result cloning_res = *(os__Result*) _t776.data;
	if (cloning_res.exit_code != 0) {
		Option _t778 = v_error(_STR("cloning failed, details: %.*s", 1, cloning_res.output));
		return *(Option_bool*)&_t778;
	}
	if (!os__exists(mod_v_file)) {
		Option _t779 = v_error(_STR("even after cloning, %.*s\000 is still missing", 2, mod_v_file));
		return *(Option_bool*)&_t779;
	}
	if (is_verbose) {
		eprintln(tos_lit("check_module_is_installed: done"));
	}
	Option_bool _t780;
	opt_ok2(&(bool[]) { true }, (OptionBase*)(&_t780), sizeof(bool));
	return _t780;
}

void v__util__ensure_modules_for_all_tools_are_installed(bool is_verbose) {
	// FOR IN map
	map_string_array_string _t782 = _const_v__util__external_module_dependencies_for_tool;
	for (int _t781 = 0; _t781 < _t782.key_values.len; ++_t781) {
		if (_t782.key_values.keys[_t781].str == 0) {continue;}
		string tool_name = /*key*/ string_clone(_t782.key_values.keys[_t781]);
		array_string tool_modules = (*(array_string*)(void*)(_t782.key_values.values + _t781 * (u32)(_t782.value_bytes)));
		if (is_verbose) {
			eprintln(_STR("Installing modules for tool: %.*s\000 ...", 2, tool_name));
		}
		// FOR IN array
		array _t783 = tool_modules;
		for (int _t784 = 0; _t784 < _t783.len; ++_t784) {
			string emodule = ((string*)_t783.data)[_t784];
			Option_bool _t785 = v__util__check_module_is_installed(emodule, is_verbose);
			if (!_t785.ok) {
				string err = _t785.v_error;
				int errcode = _t785.ecode;
				v_panic(err);
			};
		}
	}
}

string v__util__strip_mod_name(string name) {
	return string_all_after_last(name, tos_lit("."));
}

string v__util__strip_main_name(string name) {
	return string_replace(name, tos_lit("main."), tos_lit(""));
}

string v__util__no_dots(string s) {
	return string_replace(s, tos_lit("."), tos_lit("__"));
}

string v__util__no_cur_mod(string v_typename, string cur_mod) {
	string res = v_typename;
	string mod_prefix = string_add(cur_mod, tos_lit("."));
	bool has_map_prefix = string_starts_with(res, _const_v__util__map_prefix);
	if (has_map_prefix) {
		res = string_replace_once(res, _const_v__util__map_prefix, tos_lit(""));
	}
	string no_symbols = string_trim_left(res, tos_lit("&[]"));
	bool should_shorten = string_starts_with(no_symbols, mod_prefix);
	if (should_shorten) {
		res = string_replace_once(res, mod_prefix, tos_lit(""));
	}
	if (has_map_prefix) {
		res = string_add(_const_v__util__map_prefix, res);
	}
	return res;
}

void v__util__prepare_tool_when_needed(string source_name) {
	string vexe = os__getenv(tos_lit("VEXE"));
	string vroot = os__dir(vexe);
	string stool = os__join_path(vroot, (varg_string){.len=3,.args={tos_lit("cmd"), tos_lit("tools"), source_name}});
	if (v__util__should_recompile_tool(vexe, stool)) {
		time__sleep_ms(1001);
		v__util__recompile_file(vexe, stool);
	}
}

void v__util__recompile_file(string vexe, string file) {
	string cmd = _STR("%.*s\000 %.*s", 2, vexe, file);
	println(_STR("recompilation command: %.*s", 1, cmd));
	int recompile_result = os__system(cmd);
	if (recompile_result != 0) {
		eprintln(_STR("could not recompile %.*s", 1, file));
		v_exit(2);
	}
}

// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
v__ast__IdentVar v__ast__Ident_var_info(v__ast__Ident* i) {
	v__ast__IdentInfo _t786 = i->info;
	if (_t786.typ == 313 /* v.ast.IdentVar */) {
		return (*i->info._313);
	} else {
		v_panic(tos_lit("Ident.var_info(): info is not IdentVar variant"));
	};
	return (v__ast__IdentVar){0};
}

// Attr: [inline]
inline bool v__ast__Expr_is_blank_ident(v__ast__Expr expr) {
	v__ast__Expr _t787 = expr;
	if (_t787.typ == 224 /* v.ast.Ident */) {
		return (*expr._224).kind == v__ast__IdentKind_blank_ident;
	} else {
		return false;
	};
	return 0;
}

v__token__Position v__ast__Expr_position(v__ast__Expr expr) {
	v__ast__Expr _t788 = expr;
	if (_t788.typ == 208 /* v.ast.AnonFn */) {
		return (*expr._208).decl.pos;
	} else if (_t788.typ == 209 /* v.ast.ArrayInit */) {
		return (*expr._209).pos;
	} else if (_t788.typ == 210 /* v.ast.AsCast */) {
		return (*expr._210).pos;
	} else if (_t788.typ == 211 /* v.ast.Assoc */) {
		return (*expr._211).pos;
	} else if (_t788.typ == 212 /* v.ast.AtExpr */) {
		return (*expr._212).pos;
	} else if (_t788.typ == 213 /* v.ast.BoolLiteral */) {
		return (*expr._213).pos;
	} else if (_t788.typ == 215 /* v.ast.CallExpr */) {
		return (*expr._215).pos;
	} else if (_t788.typ == 216 /* v.ast.CastExpr */) {
		return (*expr._216).pos;
	} else if (_t788.typ == 217 /* v.ast.ChanInit */) {
		return (*expr._217).pos;
	} else if (_t788.typ == 218 /* v.ast.CharLiteral */) {
		return (*expr._218).pos;
	} else if (_t788.typ == 221 /* v.ast.ConcatExpr */) {
		return (*expr._221).pos;
	} else if (_t788.typ == 219 /* v.ast.Comment */) {
		return (*expr._219).pos;
	} else if (_t788.typ == 222 /* v.ast.EnumVal */) {
		return (*expr._222).pos;
	} else if (_t788.typ == 223 /* v.ast.FloatLiteral */) {
		return (*expr._223).pos;
	} else if (_t788.typ == 224 /* v.ast.Ident */) {
		return (*expr._224).pos;
	} else if (_t788.typ == 225 /* v.ast.IfExpr */) {
		return (*expr._225).pos;
	} else if (_t788.typ == 227 /* v.ast.IndexExpr */) {
		return (*expr._227).pos;
	} else if (_t788.typ == 229 /* v.ast.IntegerLiteral */) {
		return (*expr._229).pos;
	} else if (_t788.typ == 230 /* v.ast.Likely */) {
		return (*expr._230).pos;
	} else if (_t788.typ == 231 /* v.ast.LockExpr */) {
		return (*expr._231).pos;
	} else if (_t788.typ == 232 /* v.ast.MapInit */) {
		return (*expr._232).pos;
	} else if (_t788.typ == 233 /* v.ast.MatchExpr */) {
		return (*expr._233).pos;
	} else if (_t788.typ == 234 /* v.ast.None */) {
		return (*expr._234).pos;
	} else if (_t788.typ == 235 /* v.ast.OrExpr */) {
		return (*expr._235).pos;
	} else if (_t788.typ == 236 /* v.ast.ParExpr */) {
		return (*expr._236).pos;
	} else if (_t788.typ == 237 /* v.ast.PostfixExpr */) {
		return (*expr._237).pos;
	} else if (_t788.typ == 238 /* v.ast.PrefixExpr */) {
		return (*expr._238).pos;
	} else if (_t788.typ == 239 /* v.ast.RangeExpr */) {
		return (*expr._239).pos;
	} else if (_t788.typ == 240 /* v.ast.SelectExpr */) {
		return (*expr._240).pos;
	} else if (_t788.typ == 241 /* v.ast.SelectorExpr */) {
		return (*expr._241).pos;
	} else if (_t788.typ == 242 /* v.ast.SizeOf */) {
		return (*expr._242).pos;
	} else if (_t788.typ == 243 /* v.ast.SqlExpr */) {
		return (*expr._243).pos;
	} else if (_t788.typ == 244 /* v.ast.StringInterLiteral */) {
		return (*expr._244).pos;
	} else if (_t788.typ == 245 /* v.ast.StringLiteral */) {
		return (*expr._245).pos;
	} else if (_t788.typ == 246 /* v.ast.StructInit */) {
		return (*expr._246).pos;
	} else if (_t788.typ == 247 /* v.ast.Type */) {
		return (*expr._247).pos;
	} else if (_t788.typ == 248 /* v.ast.TypeOf */) {
		return (*expr._248).pos;
	} else if (_t788.typ == 249 /* v.ast.UnsafeExpr */) {
		return (*expr._249).pos;
	} else if (_t788.typ == 226 /* v.ast.IfGuardExpr */) {
		return v__ast__Expr_position((*expr._226).expr);
	} else if (_t788.typ == 220 /* v.ast.ComptimeCall */) {
		return v__ast__Expr_position((*expr._220).left);
	} else if (_t788.typ == 228 /* v.ast.InfixExpr */) {
		v__token__Position left_pos = v__ast__Expr_position((*expr._228).left);
		v__token__Position right_pos = v__ast__Expr_position((*expr._228).right);
		return (v__token__Position){.len = right_pos.pos - left_pos.pos + right_pos.len,.line_nr = (*expr._228).pos.line_nr,.pos = left_pos.pos,};
	} else if (_t788.typ == 214 /* v.ast.CTempVar */) {
		return (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,};
	};
	return (v__token__Position){0};
}

bool v__ast__Expr_is_lvalue(v__ast__Expr expr) {
	v__ast__Expr _t789 = expr;
	if (_t789.typ == 224 /* v.ast.Ident */) {
		return true;
	} else if (_t789.typ == 214 /* v.ast.CTempVar */) {
		return true;
	} else if (_t789.typ == 227 /* v.ast.IndexExpr */) {
		return v__ast__Expr_is_lvalue((*expr._227).left);
	} else if (_t789.typ == 241 /* v.ast.SelectorExpr */) {
		return v__ast__Expr_is_lvalue((*expr._241).expr);
	} else {
	};
	return false;
}

bool v__ast__Expr_is_expr(v__ast__Expr expr) {
	v__ast__Expr _t790 = expr;
	if (_t790.typ == 225 /* v.ast.IfExpr */) {
		return (*expr._225).is_expr;
	} else if (_t790.typ == 233 /* v.ast.MatchExpr */) {
		return (*expr._233).is_expr;
	} else {
	};
	return true;
}

Option_void v__ast__Stmt_check_c_expr(v__ast__Stmt stmt) {
	v__ast__Stmt _t791 = stmt;
	if (_t791.typ == 252 /* v.ast.AssignStmt */) {
		Option_void _t792 = {.ok = true};
		return _t792;
	} else if (_t791.typ == 259 /* v.ast.ExprStmt */) {
		if (v__ast__Expr_is_expr((*stmt._259).expr)) {
			Option_void _t793 = {.ok = true};
			return _t793;
		}
		Option _t794 = v_error(_STR("unsupported statement (`%.*s\000`)", 2, tos3( /* v.ast.Expr */ v_typeof_sumtype_250( ((*stmt._259).expr).typ ))));
		return *(Option_void*)&_t794;
	} else {
	};
	Option _t795 = v_error(_STR("unsupported statement (`%.*s\000`)", 2, tos3( /* v.ast.Stmt */ v_typeof_sumtype_274( (stmt).typ ))));
	return *(Option_void*)&_t795;
}

v__token__Position v__ast__Stmt_position(v__ast__Stmt stmt) {
	v__ast__Stmt _t796 = stmt;
	if (_t796.typ == 251 /* v.ast.AssertStmt */) {
		return (*stmt._251).pos;
	} else if (_t796.typ == 252 /* v.ast.AssignStmt */) {
		return (*stmt._252).pos;
	} else if (_t796.typ == 253 /* v.ast.Block */) {
		return (*stmt._253).pos;
	} else if (_t796.typ == 254 /* v.ast.BranchStmt */) {
		return (*stmt._254).pos;
	} else if (_t796.typ == 255 /* v.ast.CompFor */) {
		return (*stmt._255).pos;
	} else if (_t796.typ == 256 /* v.ast.ConstDecl */) {
		return (*stmt._256).pos;
	} else if (_t796.typ == 257 /* v.ast.DeferStmt */) {
		return (*stmt._257).pos;
	} else if (_t796.typ == 258 /* v.ast.EnumDecl */) {
		return (*stmt._258).pos;
	} else if (_t796.typ == 259 /* v.ast.ExprStmt */) {
		return (*stmt._259).pos;
	} else if (_t796.typ == 151 /* v.ast.FnDecl */) {
		return (*stmt._151).pos;
	} else if (_t796.typ == 260 /* v.ast.ForCStmt */) {
		return (*stmt._260).pos;
	} else if (_t796.typ == 261 /* v.ast.ForInStmt */) {
		return (*stmt._261).pos;
	} else if (_t796.typ == 262 /* v.ast.ForStmt */) {
		return (*stmt._262).pos;
	} else if (_t796.typ == 265 /* v.ast.GotoLabel */) {
		return (*stmt._265).pos;
	} else if (_t796.typ == 266 /* v.ast.GotoStmt */) {
		return (*stmt._266).pos;
	} else if (_t796.typ == 268 /* v.ast.Import */) {
		return (*stmt._268).pos;
	} else if (_t796.typ == 271 /* v.ast.Return */) {
		return (*stmt._271).pos;
	} else if (_t796.typ == 273 /* v.ast.StructDecl */) {
		return (*stmt._273).pos;
	} else if (_t796.typ == 263 /* v.ast.GlobalDecl */) {
		return (*stmt._263).pos;
	} else if (_t796.typ == 267 /* v.ast.HashStmt */) {
		return (*stmt._267).pos;
	} else if (_t796.typ == 269 /* v.ast.InterfaceDecl */) {
		return (*stmt._269).pos;
	} else if (_t796.typ == 270 /* v.ast.Module */) {
		return (*stmt._270).pos;
	} else if (_t796.typ == 272 /* v.ast.SqlStmt */) {
		return (*stmt._272).pos;
	} else if (_t796.typ == 264 /* v.ast.GoStmt */) {
		return v__ast__Expr_position((*stmt._264).call_expr);
	} else if (_t796.typ == 207 /* v.ast.TypeDecl */) {
		v__ast__TypeDecl _t797 = (*stmt._207);
		if (_t797.typ == 204 /* v.ast.AliasTypeDecl */) {
			return (*(*stmt._207)._204).pos;
		} else if (_t797.typ == 205 /* v.ast.FnTypeDecl */) {
			return (*(*stmt._207)._205).pos;
		} else if (_t797.typ == 206 /* v.ast.SumTypeDecl */) {
			return (*(*stmt._207)._206).pos;
		};
	};
	return (v__token__Position){0};
}

v__ast__Expr v__ast__fe2ex(v__table__FExpr x) {
	v__ast__Expr res = (v__ast__Expr){
#ifndef __cplusplus
0
#endif
};
	memcpy(&res, &x, /*SizeOfType*/ sizeof(v__ast__Expr));
	return res;
}

v__table__FExpr v__ast__ex2fe(v__ast__Expr x) {
	v__table__FExpr res = (v__table__FExpr){
#ifndef __cplusplus
0
#endif
};
	memcpy(&res, &x, /*SizeOfType*/ sizeof(v__table__FExpr));
	return res;
}

v__ast__Scope* v__ast__new_scope(v__ast__Scope* parent, int start_pos) {
	return (v__ast__Scope*)memdup(&(v__ast__Scope){.objects = new_map_1(sizeof(v__ast__ScopeObject)),.struct_fields = __new_array(0, 1, sizeof(v__ast__ScopeStructField)),.parent = parent,.children = __new_array(0, 1, sizeof(v__ast__Scope*)),.start_pos = start_pos,.end_pos = 0,}, sizeof(v__ast__Scope));
}

Option_multi_return_v__ast__ScopeObject_v__ast__Scope v__ast__Scope_find_with_scope(v__ast__Scope* s, string name) {
	v__ast__Scope* sc = s;
	for (;;) {
		if (_IN_MAP(name, sc->objects)) {
			Option_multi_return_v__ast__ScopeObject_v__ast__Scope _t798;
			opt_ok2(&(multi_return_v__ast__ScopeObject_v__ast__Scope/*X*/[]) { (multi_return_v__ast__ScopeObject_v__ast__Scope){.arg0=(*(v__ast__ScopeObject*)map_get(sc->objects, name, &(v__ast__ScopeObject[]){ {0} })), .arg1=sc} }, (OptionBase*)(&_t798), sizeof(multi_return_v__ast__ScopeObject_v__ast__Scope));
			return _t798;
		}
		if (isnil(sc->parent)) {
			break;
		}
		sc = sc->parent;
	}
	Option _t799 = opt_none();
	return *(Option_multi_return_v__ast__ScopeObject_v__ast__Scope*)&_t799;
}

Option_v__ast__ScopeObject v__ast__Scope_find(v__ast__Scope* s, string name) {
	for (v__ast__Scope* sc = s; true; sc = sc->parent) {
		if (_IN_MAP(name, sc->objects)) {
			Option_v__ast__ScopeObject _t800;
			opt_ok2(&(v__ast__ScopeObject[]) { (*(v__ast__ScopeObject*)map_get(sc->objects, name, &(v__ast__ScopeObject[]){ {0} })) }, (OptionBase*)(&_t800), sizeof(v__ast__ScopeObject));
			return _t800;
		}
		if (isnil(sc->parent)) {
			break;
		}
	}
	Option _t801 = opt_none();
	return *(Option_v__ast__ScopeObject*)&_t801;
}

Option_v__ast__ScopeStructField v__ast__Scope_find_struct_field(v__ast__Scope* s, v__table__Type struct_type, string field_name) {
	for (v__ast__Scope* sc = s; true; sc = sc->parent) {
		// FOR IN array
		array _t802 = sc->struct_fields;
		for (int _t803 = 0; _t803 < _t802.len; ++_t803) {
			v__ast__ScopeStructField field = ((v__ast__ScopeStructField*)_t802.data)[_t803];
			if (field.struct_type == struct_type && string_eq(field.name, field_name)) {
				Option_v__ast__ScopeStructField _t804;
				opt_ok2(&(v__ast__ScopeStructField[]) { field }, (OptionBase*)(&_t804), sizeof(v__ast__ScopeStructField));
				return _t804;
			}
		}
		if (isnil(sc->parent)) {
			break;
		}
	}
	Option _t805 = opt_none();
	return *(Option_v__ast__ScopeStructField*)&_t805;
}

bool v__ast__Scope_is_known(v__ast__Scope* s, string name) {
	{ /* if guard */ 
	Option_v__ast__ScopeObject _t806;
	if (_t806 = v__ast__Scope_find(s, name), _t806.ok) {
		return true;
	} else {
		string err = _t806.v_error;
		int errcode = _t806.ecode;
	}}
	return false;
}

Option_v__ast__Var_ptr v__ast__Scope_find_var(v__ast__Scope* s, string name) {
	{ /* if guard */ 
	Option_v__ast__ScopeObject _t807;
	if (_t807 = v__ast__Scope_find(s, name), _t807.ok) {
		v__ast__ScopeObject obj = *(v__ast__ScopeObject*)_t807.data;
		v__ast__ScopeObject _t808 = obj;
		if (_t808.typ == 277 /* v.ast.Var */) {
			Option_v__ast__Var_ptr _t809;
			opt_ok2(&(v__ast__Var*[]) { &(*obj._277) }, (OptionBase*)(&_t809), sizeof(v__ast__Var*));
			return _t809;
		} else {
		};
	}}
	Option _t810 = opt_none();
	return *(Option_v__ast__Var_ptr*)&_t810;
}

Option_v__ast__ConstField_ptr v__ast__Scope_find_const(v__ast__Scope* s, string name) {
	{ /* if guard */ 
	Option_v__ast__ScopeObject _t811;
	if (_t811 = v__ast__Scope_find(s, name), _t811.ok) {
		v__ast__ScopeObject obj = *(v__ast__ScopeObject*)_t811.data;
		v__ast__ScopeObject _t812 = obj;
		if (_t812.typ == 275 /* v.ast.ConstField */) {
			Option_v__ast__ConstField_ptr _t813;
			opt_ok2(&(v__ast__ConstField*[]) { &(*obj._275) }, (OptionBase*)(&_t813), sizeof(v__ast__ConstField*));
			return _t813;
		} else {
		};
	}}
	Option _t814 = opt_none();
	return *(Option_v__ast__ConstField_ptr*)&_t814;
}

bool v__ast__Scope_known_var(v__ast__Scope* s, string name) {
	{ /* if guard */ 
	Option_v__ast__Var_ptr _t815;
	if (_t815 = v__ast__Scope_find_var(s, name), _t815.ok) {
		return true;
	}}
	return false;
}

void v__ast__Scope_update_var_type(v__ast__Scope* s, string name, v__table__Type typ) {
	s->end_pos = s->end_pos;
	v__ast__ScopeObject obj = (*(v__ast__ScopeObject*)map_get(s->objects, name, &(v__ast__ScopeObject[]){ {0} }));
	v__ast__ScopeObject _t816 = obj;
	if (_t816.typ == 277 /* v.ast.Var */) {
		if ((*obj._277).typ == typ) {
			return;
		}
		(*obj._277).typ = typ;
	} else {
	};
}

void v__ast__Scope_register_struct_field(v__ast__Scope* s, v__ast__ScopeStructField field) {
	// FOR IN array
	array _t817 = s->struct_fields;
	for (int _t818 = 0; _t818 < _t817.len; ++_t818) {
		v__ast__ScopeStructField f = ((v__ast__ScopeStructField*)_t817.data)[_t818];
		if (f.struct_type == field.struct_type && string_eq(f.name, field.name)) {
			return;
		}
	}
	array_push(&s->struct_fields, _MOV((v__ast__ScopeStructField[]){ field }));
}

void v__ast__Scope_register(v__ast__Scope* s, string name, v__ast__ScopeObject obj) {
	if (string_eq(name, tos_lit("_"))) {
		return;
	}
	if (_IN_MAP(name, s->objects)) {
		return;
	}
	map_set(&s->objects, name, &(v__ast__ScopeObject[]) { obj });
}

v__ast__Scope* v__ast__Scope_outermost(v__ast__Scope* s) {
	v__ast__Scope* sc = s;
	for (;;) {
		if (!(!isnil(sc->parent))) break;
		sc = sc->parent;
	}
	return sc;
}

v__ast__Scope* v__ast__Scope_innermost(v__ast__Scope* s, int pos) {
	if (v__ast__Scope_contains(s, pos)) {
		int first = 0;
		int last = s->children.len - 1;
		int middle = last / 2;
		for (;;) {
			if (!(first <= last)) break;
			v__ast__Scope* s1 = (*(v__ast__Scope**)/*ee elem_typ */array_get(s->children, middle));
			if (s1->end_pos < pos) {
				first = middle + 1;
			} else if (v__ast__Scope_contains(s1, pos)) {
				return v__ast__Scope_innermost(s1, pos);
			} else {
				last = middle - 1;
			}
			middle = (first + last) / 2;
			if (first > last) {
				break;
			}
		}
		return s;
	}
	return s;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL bool v__ast__Scope_contains(v__ast__Scope* s, int pos) {
	return pos >= s->start_pos && pos <= s->end_pos;
}

string v__ast__Scope_show(v__ast__Scope* sc, int depth, int max_depth) {
	string out = tos_lit("");
	string indent = tos_lit("");
	for (int _t820 = 0; _t820 < depth * 4; ++_t820) {
		indent = /*f*/string_add(indent, tos_lit(" "));
	}
	out = /*f*/string_add(out, _STR("%.*s\000# %"PRId32"\000 - %"PRId32"\000\n", 4, indent, sc->start_pos, sc->end_pos));
	// FOR IN map
	map_string_v__ast__ScopeObject _t822 = sc->objects;
	for (int _t821 = 0; _t821 < _t822.key_values.len; ++_t821) {
		if (_t822.key_values.keys[_t821].str == 0) {continue;}
		v__ast__ScopeObject obj = (*(v__ast__ScopeObject*)(void*)(_t822.key_values.values + _t821 * (u32)(_t822.value_bytes)));
		v__ast__ScopeObject _t823 = obj;
		if (_t823.typ == 275 /* v.ast.ConstField */) {
			out = /*f*/string_add(out, _STR("%.*s\000  * const: %.*s\000 - %"PRId32"\000\n", 4, indent, (*obj._275).name, (*obj._275).typ));
		} else if (_t823.typ == 277 /* v.ast.Var */) {
			out = /*f*/string_add(out, _STR("%.*s\000  * var: %.*s\000 - %"PRId32"\000\n", 4, indent, (*obj._277).name, (*obj._277).typ));
		} else {
		};
	}
	// FOR IN array
	array _t824 = sc->struct_fields;
	for (int _t825 = 0; _t825 < _t824.len; ++_t825) {
		v__ast__ScopeStructField field = ((v__ast__ScopeStructField*)_t824.data)[_t825];
		out = /*f*/string_add(out, _STR("%.*s\000  * struct_field: %"PRId32"\000 %.*s\000 - %"PRId32"\000\n", 5, indent, field.struct_type, field.name, field.typ));
	}
	if (max_depth == 0 || depth < max_depth - 1) {
		// FOR IN array
		array _t826 = sc->children;
		for (int i = 0; i < _t826.len; ++i) {
			out = /*f*/string_add(out, v__ast__Scope_show((*(v__ast__Scope**)/*ee elem_typ */array_get(sc->children, i)), depth + 1, max_depth));
		}
	}
	return out;
}

string v__ast__Scope_str(v__ast__Scope* sc) {
	return v__ast__Scope_show(sc, 0, 0);
}

string v__ast__FnDecl_modname(v__ast__FnDecl* node) {
	if ((node->mod).len != 0) {
		return node->mod;
	}
	string pamod = string_all_before_last(node->name, tos_lit("."));
	if (string_eq(pamod, string_after(node->name, tos_lit(".")))) {
		pamod = (node->is_builtin ? (tos_lit("builtin")) : (tos_lit("main")));
	}
	return pamod;
}

string v__ast__FnDecl_stringify(v__ast__FnDecl* node, v__table__Table* t, string cur_mod) {
	strings__Builder f = strings__new_builder(30);
	if (node->is_pub) {
		strings__Builder_write(&f, tos_lit("pub "));
	}
	string receiver = tos_lit("");
	if (node->is_method) {
		string styp = v__util__no_cur_mod(v__table__Table_type_to_str(t, node->receiver.typ), cur_mod);
		string m = (node->rec_mut ? (string_add(v__table__ShareType_str(v__table__Type_share(node->receiver.typ)), tos_lit(" "))) : (tos_lit("")));
		if (node->rec_mut) {
			styp = string_substr(styp, 1, styp.len);
		}
		styp = v__util__no_cur_mod(styp, cur_mod);
		receiver = _STR("(%.*s\000%.*s\000 %.*s\000) ", 4, m, node->receiver.name, styp);
	}
	string name = (node->is_anon ? (tos_lit("")) : (string_after(node->name, tos_lit("."))));
	if (node->language == v__table__Language_c) {
		name = _STR("C.%.*s", 1, name);
	} else if (node->language == v__table__Language_js) {
		name = _STR("JS.%.*s", 1, name);
	}
	strings__Builder_write(&f, _STR("fn %.*s\000%.*s", 2, receiver, name));
	if (node->is_generic) {
		strings__Builder_write(&f, tos_lit("<T>"));
	}
	strings__Builder_write(&f, tos_lit("("));
	// FOR IN array
	array _t827 = node->params;
	for (int i = 0; i < _t827.len; ++i) {
		v__table__Param arg = ((v__table__Param*)_t827.data)[i];
		if (node->is_method && i == 0) {
			continue;
		}
		if (arg.is_hidden) {
			continue;
		}
		bool is_last_arg = i == node->params.len - 1;
		bool is_type_only = (arg.name).len == 0;
		bool should_add_type = true;
		if (arg.is_mut) {
			strings__Builder_write(&f, string_add(v__table__ShareType_str(v__table__Type_share(arg.typ)), tos_lit(" ")));
		}
		strings__Builder_write(&f, arg.name);
		string s = v__table__Table_type_to_str(t, arg.typ);
		if (arg.is_mut) {
			if (string_starts_with(s, tos_lit("&"))) {
				s = string_substr(s, 1, s.len);
			}
		}
		s = v__util__no_cur_mod(s, cur_mod);
		if (should_add_type) {
			if (!is_type_only) {
				strings__Builder_write(&f, tos_lit(" "));
			}
			if (node->is_variadic && is_last_arg) {
				strings__Builder_write(&f, tos_lit("..."));
			}
			strings__Builder_write(&f, s);
		}
		if (!is_last_arg) {
			strings__Builder_write(&f, tos_lit(", "));
		}
	}
	strings__Builder_write(&f, tos_lit(")"));
	if (node->return_type != _const_v__table__void_type) {
		strings__Builder_write(&f, string_add(tos_lit(" "), v__util__no_cur_mod(v__table__Table_type_to_str(t, node->return_type), cur_mod)));
	}
	return strings__Builder_str(&f);
}

string v__ast__InfixExpr_str(v__ast__InfixExpr* x) {
	return _STR("%.*s\000 %.*s\000 %.*s", 3, v__ast__Expr_str(x->left), v__token__Kind_str(x->op), v__ast__Expr_str(x->right));
}

multi_return_string_bool v__ast__StringInterLiteral_get_fspec_braces(v__ast__StringInterLiteral* lit, int i) {
	array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	bool needs_fspec = (*(bool*)/*ee elem_typ */array_get(lit->need_fmts, i)) || (*(bool*)/*ee elem_typ */array_get(lit->pluss, i)) || ((*(bool*)/*ee elem_typ */array_get(lit->fills, i)) && (*(int*)/*ee elem_typ */array_get(lit->fwidths, i)) >= 0) || (*(int*)/*ee elem_typ */array_get(lit->fwidths, i)) != 0 || (*(int*)/*ee elem_typ */array_get(lit->precisions, i)) != 987698;
	bool needs_braces = needs_fspec;
	if (!needs_braces) {
		if (i + 1 < lit->vals.len && (*(string*)/*ee elem_typ */array_get(lit->vals, i + 1)).len > 0) {
			byte next_char = string_at((*(string*)/*ee elem_typ */array_get(lit->vals, i + 1)), 0);
			if (v__util__is_func_char(next_char) || next_char == '.' || next_char == '(') {
				needs_braces = true;
			}
		}
	}
	if (!needs_braces) {
		v__ast__Expr sub_expr = (*(v__ast__Expr*)/*ee elem_typ */array_get(lit->exprs, i));
		for (;;) {
			v__ast__Expr _t828 = sub_expr;
			if (_t828.typ == 224 /* v.ast.Ident */) {
				if (string_at((*sub_expr._224).name, 0) == '@') {
					needs_braces = true;
				}
				break;
			} else if (_t828.typ == 215 /* v.ast.CallExpr */) {
				if ((*sub_expr._215).args.len != 0) {
					needs_braces = true;
				}
				break;
			} else if (_t828.typ == 241 /* v.ast.SelectorExpr */) {
				sub_expr = (*sub_expr._241).expr;
				continue;
			} else {
				needs_braces = true;
				break;
			};
		}
	}
	if (needs_fspec) {
		array_push(&res, _MOV((string[]){ string_clone(tos_lit(":")) }));
		if ((*(bool*)/*ee elem_typ */array_get(lit->pluss, i))) {
			array_push(&res, _MOV((string[]){ string_clone(tos_lit("+")) }));
		}
		if ((*(bool*)/*ee elem_typ */array_get(lit->fills, i)) && (*(int*)/*ee elem_typ */array_get(lit->fwidths, i)) >= 0) {
			array_push(&res, _MOV((string[]){ string_clone(tos_lit("0")) }));
		}
		if ((*(int*)/*ee elem_typ */array_get(lit->fwidths, i)) != 0) {
			array_push(&res, _MOV((string[]){ string_clone(_STR("%"PRId32"", 1, (*(int*)/*ee elem_typ */array_get(lit->fwidths, i)))) }));
		}
		if ((*(int*)/*ee elem_typ */array_get(lit->precisions, i)) != 987698) {
			array_push(&res, _MOV((string[]){ string_clone(_STR(".%"PRId32"", 1, (*(int*)/*ee elem_typ */array_get(lit->precisions, i)))) }));
		}
		if ((*(bool*)/*ee elem_typ */array_get(lit->need_fmts, i))) {
			array_push(&res, _MOV((string[]){ string_clone(_STR("%c", 1, (*(byte*)/*ee elem_typ */array_get(lit->fmts, i)))) }));
		}
	}
	return (multi_return_string_bool){.arg0=array_string_join(res, tos_lit("")), .arg1=needs_braces};
}

string v__ast__Expr_str(v__ast__Expr x) {
	v__ast__Expr _t835 = x;
	if (_t835.typ == 214 /* v.ast.CTempVar */) {
		return v__ast__Expr_str((*x._214).orig);
	} else if (_t835.typ == 213 /* v.ast.BoolLiteral */) {
		return bool_str((*x._213).val);
	} else if (_t835.typ == 216 /* v.ast.CastExpr */) {
		return _STR("%.*s\000(%.*s\000)", 3, (*x._216).typname, v__ast__Expr_str((*x._216).expr));
	} else if (_t835.typ == 212 /* v.ast.AtExpr */) {
		return _STR("%.*s", 1, (*x._212).val);
	} else if (_t835.typ == 215 /* v.ast.CallExpr */) {
		string sargs = v__ast__args2str((*x._215).args);
		if ((*x._215).is_method) {
			return _STR("%.*s\000.%.*s\000(%.*s\000)", 4, v__ast__Expr_str((*x._215).left), (*x._215).name, sargs);
		}
		if (string_starts_with((*x._215).name, _STR("%.*s\000.", 2, (*x._215).mod))) {
			return v__util__strip_main_name(_STR("%.*s\000(%.*s\000)", 3, (*x._215).name, sargs));
		}
		return _STR("%.*s\000.%.*s\000(%.*s\000)", 4, (*x._215).mod, (*x._215).name, sargs);
	} else if (_t835.typ == 218 /* v.ast.CharLiteral */) {
		return _STR("`%.*s\000`", 2, (*x._218).val);
	} else if (_t835.typ == 222 /* v.ast.EnumVal */) {
		return _STR(".%.*s", 1, (*x._222).val);
	} else if (_t835.typ == 223 /* v.ast.FloatLiteral */) {
		return (*x._223).val;
	} else if (_t835.typ == 229 /* v.ast.IntegerLiteral */) {
		return (*x._229).val;
	} else if (_t835.typ == 224 /* v.ast.Ident */) {
		return (*x._224).name;
	} else if (_t835.typ == 227 /* v.ast.IndexExpr */) {
		return _STR("%.*s\000[%.*s\000]", 3, v__ast__Expr_str((*x._227).left), v__ast__Expr_str((*x._227).index));
	} else if (_t835.typ == 228 /* v.ast.InfixExpr */) {
		return _STR("%.*s\000 %.*s\000 %.*s", 3, v__ast__Expr_str((*x._228).left), v__token__Kind_str((*x._228).op), v__ast__Expr_str((*x._228).right));
	} else if (_t835.typ == 236 /* v.ast.ParExpr */) {
		return _STR("(%.*s\000)", 2, v__ast__Expr_str((*x._236).expr));
	} else if (_t835.typ == 238 /* v.ast.PrefixExpr */) {
		return string_add(v__token__Kind_str((*x._238).op), v__ast__Expr_str((*x._238).right));
	} else if (_t835.typ == 239 /* v.ast.RangeExpr */) {
		string s = tos_lit("..");
		if ((*x._239).has_low) {
			s = string_add(_STR("%.*s\000 ", 2, v__ast__Expr_str((*x._239).low)), s);
		}
		if ((*x._239).has_high) {
			s = string_add(s, _STR(" %.*s", 1, v__ast__Expr_str((*x._239).high)));
		}
		return s;
	} else if (_t835.typ == 241 /* v.ast.SelectorExpr */) {
		return _STR("%.*s\000.%.*s", 2, v__ast__Expr_str((*x._241).expr), (*x._241).field_name);
	} else if (_t835.typ == 242 /* v.ast.SizeOf */) {
		return _STR("sizeof(%.*s\000)", 2, v__ast__Expr_str((*x._242).expr));
	} else if (_t835.typ == 244 /* v.ast.StringInterLiteral */) {
		array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
		array_push(&res, _MOV((string[]){ string_clone(tos_lit("'")) }));
		// FOR IN array
		array _t837 = (*x._244).vals;
		for (int i = 0; i < _t837.len; ++i) {
			string val = ((string*)_t837.data)[i];
			array_push(&res, _MOV((string[]){ string_clone(val) }));
			if (i >= (*x._244).exprs.len) {
				break;
			}
			array_push(&res, _MOV((string[]){ string_clone(tos_lit("$")) }));
			multi_return_string_bool mr_5777 = v__ast__StringInterLiteral_get_fspec_braces(&(*x._244), i);
			string fspec_str = mr_5777.arg0;
			bool needs_braces = mr_5777.arg1;
			if (needs_braces) {
				array_push(&res, _MOV((string[]){ string_clone(tos_lit("{")) }));
				array_push(&res, _MOV((string[]){ string_clone(v__ast__Expr_str((*(v__ast__Expr*)/*ee elem_typ */array_get((*x._244).exprs, i)))) }));
				array_push(&res, _MOV((string[]){ string_clone(fspec_str) }));
				array_push(&res, _MOV((string[]){ string_clone(tos_lit("}")) }));
			} else {
				array_push(&res, _MOV((string[]){ string_clone(v__ast__Expr_str((*(v__ast__Expr*)/*ee elem_typ */array_get((*x._244).exprs, i)))) }));
			}
		}
		array_push(&res, _MOV((string[]){ string_clone(tos_lit("'")) }));
		return array_string_join(res, tos_lit(""));
	} else if (_t835.typ == 245 /* v.ast.StringLiteral */) {
		return _STR("\"%.*s\000\"", 2, (*x._245).val);
	} else if (_t835.typ == 248 /* v.ast.TypeOf */) {
		return _STR("typeof(%.*s\000)", 2, v__ast__Expr_str((*x._248).expr));
	} else if (_t835.typ == 230 /* v.ast.Likely */) {
		return _STR("_likely_(%.*s\000)", 2, v__ast__Expr_str((*x._230).expr));
	} else if (_t835.typ == 249 /* v.ast.UnsafeExpr */) {
		return _STR("unsafe { %.*s\000 }", 2, v__ast__Expr_str((*x._249).expr));
	} else {
	};
	return _STR("[unhandled expr type %.*s\000]", 2, tos3( /* v.ast.Expr */ v_typeof_sumtype_250( (x).typ )));
}

string v__ast__CallArg_str(v__ast__CallArg a) {
	if (a.is_mut) {
		return _STR("mut %.*s", 1, v__ast__Expr_str(a.expr));
	}
	return _STR("%.*s", 1, v__ast__Expr_str(a.expr));
}

string v__ast__args2str(array_v__ast__CallArg args) {
	array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	// FOR IN array
	array _t846 = args;
	for (int _t847 = 0; _t847 < _t846.len; ++_t847) {
		v__ast__CallArg a = ((v__ast__CallArg*)_t846.data)[_t847];
		array_push(&res, _MOV((string[]){ string_clone(v__ast__CallArg_str(a)) }));
	}
	return array_string_join(res, tos_lit(", "));
}

string v__ast__BranchStmt_str(v__ast__BranchStmt* node) {
	string s = _STR("%.*s", 1, v__token__Kind_str(node->kind));
	if (node->label.len > 0) {
		s = /*f*/string_add(s, _STR(" %.*s", 1, node->label));
	}
	return s;
}

string v__ast__Stmt_str(v__ast__Stmt node) {
	v__ast__Stmt _t849 = node;
	if (_t849.typ == 252 /* v.ast.AssignStmt */) {
		string out = tos_lit("");
		// FOR IN array
		array _t850 = (*node._252).left;
		for (int i = 0; i < _t850.len; ++i) {
			v__ast__Expr left = ((v__ast__Expr*)_t850.data)[i];
			if ((left).typ == 224 /* v.ast.Ident */) {
				v__ast__IdentVar var_info = v__ast__Ident_var_info(&(*left._224));
				if (var_info.is_mut) {
					out = /*f*/string_add(out, tos_lit("mut "));
				}
			}
			out = /*f*/string_add(out, v__ast__Expr_str(left));
			if (i < (*node._252).left.len - 1) {
				out = /*f*/string_add(out, tos_lit(","));
			}
		}
		out = /*f*/string_add(out, _STR(" %.*s\000 ", 2, v__token__Kind_str((*node._252).op)));
		// FOR IN array
		array _t851 = (*node._252).right;
		for (int i = 0; i < _t851.len; ++i) {
			v__ast__Expr val = ((v__ast__Expr*)_t851.data)[i];
			out = /*f*/string_add(out, v__ast__Expr_str(val));
			if (i < (*node._252).right.len - 1) {
				out = /*f*/string_add(out, tos_lit(","));
			}
		}
		return out;
	} else if (_t849.typ == 254 /* v.ast.BranchStmt */) {
		return v__ast__BranchStmt_str(&(*node._254));
	} else if (_t849.typ == 259 /* v.ast.ExprStmt */) {
		return v__ast__Expr_str((*node._259).expr);
	} else if (_t849.typ == 151 /* v.ast.FnDecl */) {
		return _STR("fn %.*s\000() { %"PRId32"\000 stmts }", 3, (*node._151).name, (*node._151).stmts.len);
	} else {
		return _STR("[unhandled stmt str type: %.*s\000 ]", 2, tos3( /* v.ast.Stmt */ v_typeof_sumtype_274( (node).typ )));
	};
	return (string){.str=(byteptr)""};
}

string v__ast__CompForKind_str(v__ast__CompForKind e) {
	v__ast__CompForKind _t852 = e;
	if (_t852 == v__ast__CompForKind_methods) {
		return tos_lit("methods");
	} else if (_t852 == v__ast__CompForKind_fields) {
		return tos_lit("fields");
	};
	return (string){.str=(byteptr)""};
}

v__scanner__Scanner* v__scanner__new_scanner_file(string file_path, v__scanner__CommentsMode comments_mode, v__pref__Preferences* pref) {
	return v__scanner__new_vet_scanner_file(file_path, comments_mode, pref);
}

v__scanner__Scanner* v__scanner__new_vet_scanner_file(string file_path, v__scanner__CommentsMode comments_mode, v__pref__Preferences* pref) {
	if (!os__exists(file_path)) {
		v__scanner__verror(_STR("%.*s\000 doesn't exist", 2, file_path));
	}
	Option_string _t853 = v__util__read_file(file_path);
	if (!_t853.ok) {
		string err = _t853.v_error;
		int errcode = _t853.ecode;
		v__scanner__verror(err);
		return ((voidptr)(0));
	}
 	string raw_text = *(string*) _t853.data;
	v__scanner__Scanner* s = v__scanner__new_vet_scanner(raw_text, comments_mode, pref);
	s->file_path = file_path;
	return s;
}

v__scanner__Scanner* v__scanner__new_scanner(string text, v__scanner__CommentsMode comments_mode, v__pref__Preferences* pref) {
	return v__scanner__new_vet_scanner(text, comments_mode, pref);
}

v__scanner__Scanner* v__scanner__new_vet_scanner(string text, v__scanner__CommentsMode comments_mode, v__pref__Preferences* pref) {
	bool is_fmt = pref->is_fmt;
	v__scanner__Scanner* s = (v__scanner__Scanner*)memdup(&(v__scanner__Scanner){.file_path = (string){.str=(byteptr)""},
		.text = text,
		.pos = 0,
		.line_nr = 0,
		.last_nl_pos = 0,
		.is_inside_string = 0,
		.is_inter_start = 0,
		.is_inter_end = 0,
		.is_debug = 0,
		.line_comment = (string){.str=(byteptr)""},
		.is_started = 0,
		.is_print_line_on_error = true,
		.is_print_colored_error = true,
		.is_print_rel_paths_on_error = true,
		.quote = 0,
		.line_ends = __new_array(0, 1, sizeof(int)),
		.nr_lines = 0,
		.is_vh = 0,
		.is_fmt = is_fmt,
		.comments_mode = comments_mode,
		.is_inside_toplvl_statement = 0,
		.all_tokens = __new_array(0, 1, sizeof(v__token__Token)),
		.tidx = 0,
		.eofs = 0,
		.pref = pref,
		.vet_errors = __new_array(0, 1, sizeof(string)),
		.errors = __new_array(0, 1, sizeof(v__errors__Error)),
		.warnings = __new_array(0, 1, sizeof(v__errors__Warning)),
	}, sizeof(v__scanner__Scanner));
	s->file_path = tos_lit("internal_memory");
	return s;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL bool v__scanner__Scanner_should_parse_comment(v__scanner__Scanner* s) {
	bool res = (s->comments_mode == v__scanner__CommentsMode_parse_comments) || (s->comments_mode == v__scanner__CommentsMode_toplevel_comments && !s->is_inside_toplvl_statement);
	return res;
}

void v__scanner__Scanner_set_is_inside_toplevel_statement(v__scanner__Scanner* s, bool newstate) {
	s->is_inside_toplvl_statement = newstate;
}

void v__scanner__Scanner_set_current_tidx(v__scanner__Scanner* s, int cidx) {
	int tidx = (cidx < 0 ? (0) : (cidx));
	tidx = (tidx > s->all_tokens.len ? (s->all_tokens.len) : (tidx));
	s->tidx = tidx;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL v__token__Token v__scanner__Scanner_new_token(v__scanner__Scanner* s, v__token__Kind tok_kind, string lit, int len) {
	int cidx = s->tidx;
	s->tidx++;
	return (v__token__Token){
		.kind = tok_kind,
		.lit = lit,
		.line_nr = s->line_nr + 1,
		.pos = s->pos - len + 1,
		.len = len,
		.tidx = cidx,
	};
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_name(v__scanner__Scanner* s) {
	int start = s->pos;
	s->pos++;
	for (;;) {
		if (!(s->pos < s->text.len && (v__util__is_name_char(string_at(s->text, s->pos)) || byte_is_digit(string_at(s->text, s->pos))))) break;
		s->pos++;
	}
	string name = string_substr(s->text, start, s->pos);
	s->pos--;
	return name;
}

VV_LOCAL_SYMBOL string v__scanner__filter_num_sep(byteptr txt, int start, int end) {
	{ // Unsafe block
		byteptr b = v_malloc(end - start + 1);
		int i1 = 0;
		for (int i = start; i < end; i++) {
			if (txt[i] != _const_v__scanner__num_sep) {
				b[i1] = txt[i];
				i1++;
			}
		}
		b[i1] = 0;
		return byteptr_vstring_with_len(b, i1);
	}
	return (string){.str=(byteptr)""};
}

VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_bin_number(v__scanner__Scanner* s) {
	bool has_wrong_digit = false;
	int first_wrong_digit_pos = 0;
	rune first_wrong_digit = '\0';
	int start_pos = s->pos;
	s->pos += 2;
	if (string_at(s->text, s->pos) == _const_v__scanner__num_sep) {
		v__scanner__Scanner_error(s, tos_lit("separator `_` is only valid between digits in a numeric literal"));
	}
	for (;;) {
		if (!(s->pos < s->text.len)) break;
		byte c = string_at(s->text, s->pos);
		if (c == _const_v__scanner__num_sep && string_at(s->text, s->pos + 1) == _const_v__scanner__num_sep) {
			v__scanner__Scanner_error(s, tos_lit("cannot use `_` consecutively"));
		}
		if (!byte_is_bin_digit(c) && c != _const_v__scanner__num_sep) {
			if ((!byte_is_digit(c) && !byte_is_letter(c)) || s->is_inside_string) {
				break;
			} else if (!has_wrong_digit) {
				has_wrong_digit = true;
				first_wrong_digit_pos = s->pos;
				first_wrong_digit = c;
			}
		}
		s->pos++;
	}
	if (string_at(s->text, s->pos - 1) == _const_v__scanner__num_sep) {
		v__scanner__Scanner_error(s, tos_lit("cannot use `_` at the end of a numeric literal"));
	} else if (start_pos + 2 == s->pos) {
		s->pos--;
		v__scanner__Scanner_error(s, tos_lit("number part of this binary is not provided"));
	} else if (has_wrong_digit) {
		s->pos = first_wrong_digit_pos;
		v__scanner__Scanner_error(s, _STR("this binary number has unsuitable digit `%.*s\000`", 2, rune_str(first_wrong_digit)));
	}
	string number = v__scanner__filter_num_sep(s->text.str, start_pos, s->pos);
	s->pos--;
	return number;
}

VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_hex_number(v__scanner__Scanner* s) {
	bool has_wrong_digit = false;
	int first_wrong_digit_pos = 0;
	rune first_wrong_digit = '\0';
	int start_pos = s->pos;
	s->pos += 2;
	if (string_at(s->text, s->pos) == _const_v__scanner__num_sep) {
		v__scanner__Scanner_error(s, tos_lit("separator `_` is only valid between digits in a numeric literal"));
	}
	for (;;) {
		if (!(s->pos < s->text.len)) break;
		byte c = string_at(s->text, s->pos);
		if (c == _const_v__scanner__num_sep && string_at(s->text, s->pos + 1) == _const_v__scanner__num_sep) {
			v__scanner__Scanner_error(s, tos_lit("cannot use `_` consecutively"));
		}
		if (!byte_is_hex_digit(c) && c != _const_v__scanner__num_sep) {
			if (!byte_is_letter(c) || s->is_inside_string) {
				break;
			} else if (!has_wrong_digit) {
				has_wrong_digit = true;
				first_wrong_digit_pos = s->pos;
				first_wrong_digit = c;
			}
		}
		s->pos++;
	}
	if (string_at(s->text, s->pos - 1) == _const_v__scanner__num_sep) {
		v__scanner__Scanner_error(s, tos_lit("cannot use `_` at the end of a numeric literal"));
	} else if (start_pos + 2 == s->pos) {
		s->pos--;
		v__scanner__Scanner_error(s, tos_lit("number part of this hexadecimal is not provided"));
	} else if (has_wrong_digit) {
		s->pos = first_wrong_digit_pos;
		v__scanner__Scanner_error(s, _STR("this hexadecimal number has unsuitable digit `%.*s\000`", 2, rune_str(first_wrong_digit)));
	}
	string number = v__scanner__filter_num_sep(s->text.str, start_pos, s->pos);
	s->pos--;
	return number;
}

VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_oct_number(v__scanner__Scanner* s) {
	bool has_wrong_digit = false;
	int first_wrong_digit_pos = 0;
	rune first_wrong_digit = '\0';
	int start_pos = s->pos;
	s->pos += 2;
	if (string_at(s->text, s->pos) == _const_v__scanner__num_sep) {
		v__scanner__Scanner_error(s, tos_lit("separator `_` is only valid between digits in a numeric literal"));
	}
	for (;;) {
		if (!(s->pos < s->text.len)) break;
		byte c = string_at(s->text, s->pos);
		if (c == _const_v__scanner__num_sep && string_at(s->text, s->pos + 1) == _const_v__scanner__num_sep) {
			v__scanner__Scanner_error(s, tos_lit("cannot use `_` consecutively"));
		}
		if (!byte_is_oct_digit(c) && c != _const_v__scanner__num_sep) {
			if ((!byte_is_digit(c) && !byte_is_letter(c)) || s->is_inside_string) {
				break;
			} else if (!has_wrong_digit) {
				has_wrong_digit = true;
				first_wrong_digit_pos = s->pos;
				first_wrong_digit = c;
			}
		}
		s->pos++;
	}
	if (string_at(s->text, s->pos - 1) == _const_v__scanner__num_sep) {
		v__scanner__Scanner_error(s, tos_lit("cannot use `_` at the end of a numeric literal"));
	} else if (start_pos + 2 == s->pos) {
		s->pos--;
		v__scanner__Scanner_error(s, tos_lit("number part of this octal is not provided"));
	} else if (has_wrong_digit) {
		s->pos = first_wrong_digit_pos;
		v__scanner__Scanner_error(s, _STR("this octal number has unsuitable digit `%.*s\000`", 2, rune_str(first_wrong_digit)));
	}
	string number = v__scanner__filter_num_sep(s->text.str, start_pos, s->pos);
	s->pos--;
	return number;
}

VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_dec_number(v__scanner__Scanner* s) {
	bool has_wrong_digit = false;
	int first_wrong_digit_pos = 0;
	rune first_wrong_digit = '\0';
	int start_pos = s->pos;
	for (;;) {
		if (!(s->pos < s->text.len)) break;
		byte c = string_at(s->text, s->pos);
		if (c == _const_v__scanner__num_sep && string_at(s->text, s->pos + 1) == _const_v__scanner__num_sep) {
			v__scanner__Scanner_error(s, tos_lit("cannot use `_` consecutively"));
		}
		if (!byte_is_digit(c) && c != _const_v__scanner__num_sep) {
			if (!byte_is_letter(c) || (c == 'e' || c == 'E') || s->is_inside_string) {
				break;
			} else if (!has_wrong_digit) {
				has_wrong_digit = true;
				first_wrong_digit_pos = s->pos;
				first_wrong_digit = c;
			}
		}
		s->pos++;
	}
	if (string_at(s->text, s->pos - 1) == _const_v__scanner__num_sep) {
		v__scanner__Scanner_error(s, tos_lit("cannot use `_` at the end of a numeric literal"));
	}
	bool call_method = false;
	bool is_range = false;
	if (s->pos < s->text.len && string_at(s->text, s->pos) == '.') {
		s->pos++;
		if (s->pos < s->text.len) {
			if (byte_is_digit(string_at(s->text, s->pos))) {
				for (;;) {
					if (!(s->pos < s->text.len)) break;
					byte c = string_at(s->text, s->pos);
					if (!byte_is_digit(c)) {
						if (!byte_is_letter(c) || (c == 'e' || c == 'E') || s->is_inside_string) {
							if (c == '.' && s->pos + 1 < s->text.len && byte_is_letter(string_at(s->text, s->pos + 1))) {
								call_method = true;
							}
							break;
						} else if (!has_wrong_digit) {
							has_wrong_digit = true;
							first_wrong_digit_pos = s->pos;
							first_wrong_digit = c;
						}
					}
					s->pos++;
				}
			} else if (string_at(s->text, s->pos) == '.') {
				is_range = true;
				s->pos--;
			} else if ((string_at(s->text, s->pos) == 'e' || string_at(s->text, s->pos) == 'E')) {
			} else if (byte_is_letter(string_at(s->text, s->pos))) {
				call_method = true;
				s->pos--;
			} else {
			}
		}
	}
	bool has_exp = false;
	if (s->pos < s->text.len && (string_at(s->text, s->pos) == 'e' || string_at(s->text, s->pos) == 'E')) {
		has_exp = true;
		s->pos++;
		if (s->pos < s->text.len && (string_at(s->text, s->pos) == '-' || string_at(s->text, s->pos) == '+')) {
			s->pos++;
		}
		for (;;) {
			if (!(s->pos < s->text.len)) break;
			byte c = string_at(s->text, s->pos);
			if (!byte_is_digit(c)) {
				if (!byte_is_letter(c) || s->is_inside_string) {
					if (c == '.' && s->pos + 1 < s->text.len && byte_is_letter(string_at(s->text, s->pos + 1))) {
						call_method = true;
					}
					break;
				} else if (!has_wrong_digit) {
					has_wrong_digit = true;
					first_wrong_digit_pos = s->pos;
					first_wrong_digit = c;
				}
			}
			s->pos++;
		}
	}
	if (has_wrong_digit) {
		s->pos = first_wrong_digit_pos;
		v__scanner__Scanner_error(s, _STR("this number has unsuitable digit `%.*s\000`", 2, rune_str(first_wrong_digit)));
	} else if ((string_at(s->text, s->pos - 1) == 'e' || string_at(s->text, s->pos - 1) == 'E')) {
		s->pos--;
		v__scanner__Scanner_error(s, tos_lit("exponent has no digits"));
	} else if (s->pos < s->text.len && string_at(s->text, s->pos) == '.' && !is_range && !call_method) {
		if (has_exp) {
			v__scanner__Scanner_error(s, tos_lit("exponential part should be integer"));
		} else {
			v__scanner__Scanner_error(s, tos_lit("too many decimal points in number"));
		}
	}
	string number = v__scanner__filter_num_sep(s->text.str, start_pos, s->pos);
	s->pos--;
	return number;
}

VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_number(v__scanner__Scanner* s) {
	if (v__scanner__Scanner_expect(s, tos_lit("0b"), s->pos)) {
		return v__scanner__Scanner_ident_bin_number(s);
	} else if (v__scanner__Scanner_expect(s, tos_lit("0x"), s->pos)) {
		return v__scanner__Scanner_ident_hex_number(s);
	} else if (v__scanner__Scanner_expect(s, tos_lit("0o"), s->pos)) {
		return v__scanner__Scanner_ident_oct_number(s);
	} else {
		return v__scanner__Scanner_ident_dec_number(s);
	}
	return (string){.str=(byteptr)""};
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL void v__scanner__Scanner_skip_whitespace(v__scanner__Scanner* s) {
	for (;;) {
		if (!(s->pos < s->text.len && byte_is_space(string_at(s->text, s->pos)))) break;
		if (v__util__is_nl(string_at(s->text, s->pos)) && s->is_vh) {
			return;
		}
		if (v__util__is_nl(string_at(s->text, s->pos)) && !v__scanner__Scanner_expect(s, tos_lit("\r\n"), s->pos - 1)) {
			v__scanner__Scanner_inc_line_number(s);
		}
		s->pos++;
	}
}

VV_LOCAL_SYMBOL v__token__Token v__scanner__Scanner_end_of_file(v__scanner__Scanner* s) {
	s->eofs++;
	if (s->eofs > 50) {
		s->line_nr--;
		v_panic(string_add(string_add(_STR("the end of file `%.*s\000` has been reached 50 times already, the v parser is probably stuck.\n", 2, s->file_path), tos_lit("This should not happen. Please report the bug here, and include the last 2-3 lines of your source code:\n")), tos_lit("https://github.com/vlang/v/issues/new?labels=Bug&template=bug_report.md")));
	}
	if (s->pos != s->text.len && s->eofs == 1) {
		v__scanner__Scanner_inc_line_number(s);
	}
	s->pos = s->text.len;
	return v__scanner__Scanner_new_token(s, v__token__Kind_eof, tos_lit(""), 1);
}

void v__scanner__Scanner_scan_all_tokens_in_buffer(v__scanner__Scanner* s) {
	v__scanner__CommentsMode cmode = s->comments_mode;
	s->comments_mode = v__scanner__CommentsMode_parse_comments;
	for (;;) {
		v__token__Token t = v__scanner__Scanner_text_scan(s);
		array_push(&s->all_tokens, _MOV((v__token__Token[]){ t }));
		if (t.kind == v__token__Kind_eof) {
			break;
		}
	}
	s->comments_mode = cmode;
	s->tidx = 0;
	#if defined(CUSTOM_DEFINE_debugscanner)
	{
	}
	#endif
}

v__token__Token v__scanner__Scanner_scan(v__scanner__Scanner* s) {
	if (s->comments_mode == v__scanner__CommentsMode_toplevel_comments) {
		return v__scanner__Scanner_buffer_scan(s);
	}
	return v__scanner__Scanner_text_scan(s);
}

v__token__Token v__scanner__Scanner_buffer_scan(v__scanner__Scanner* s) {
	for (;;) {
		int cidx = s->tidx;
		s->tidx++;
		if (cidx >= s->all_tokens.len) {
			return v__scanner__Scanner_end_of_file(s);
		}
		if ((*(v__token__Token*)/*ee elem_typ */array_get(s->all_tokens, cidx)).kind == v__token__Kind_comment) {
			if (!v__scanner__Scanner_should_parse_comment(s)) {
				continue;
			}
		}
		return (*(v__token__Token*)/*ee elem_typ */array_get(s->all_tokens, cidx));
	}
	return v__scanner__Scanner_new_token(s, v__token__Kind_eof, tos_lit(""), 1);
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL byte v__scanner__Scanner_look_ahead(v__scanner__Scanner s, int n) {
	if (s.pos + n < s.text.len) {
		return string_at(s.text, s.pos + n);
	} else {
		return '\0';
	}
	return 0;
}

VV_LOCAL_SYMBOL v__token__Token v__scanner__Scanner_text_scan(v__scanner__Scanner* s) {
	for (;;) {
		if (s->is_started) {
			s->pos++;
		}
		s->is_started = true;
		if (s->pos >= s->text.len) {
			return v__scanner__Scanner_end_of_file(s);
		}
		if (!s->is_inside_string) {
			v__scanner__Scanner_skip_whitespace(s);
		}
		if (s->is_inter_end) {
			if (string_at(s->text, s->pos) == s->quote) {
				s->is_inter_end = false;
				return v__scanner__Scanner_new_token(s, v__token__Kind_string, tos_lit(""), 1);
			}
			s->is_inter_end = false;
			string ident_string = v__scanner__Scanner_ident_string(s);
			return v__scanner__Scanner_new_token(s, v__token__Kind_string, ident_string, ident_string.len + 2);
		}
		v__scanner__Scanner_skip_whitespace(s);
		if (s->pos >= s->text.len) {
			return v__scanner__Scanner_end_of_file(s);
		}
		byte c = string_at(s->text, s->pos);
		byte nextc = v__scanner__Scanner_look_ahead(/*rec*/*s, 1);
		if (v__util__is_name_char(c)) {
			string name = v__scanner__Scanner_ident_name(s);
			byte next_char = v__scanner__Scanner_look_ahead(/*rec*/*s, 1);
			v__token__Kind kind = (*(v__token__Kind*)map_get(_const_v__token__keywords, name, &(v__token__Kind[]){ 0 }));
			if (kind != v__token__Kind_unknown) {
				return v__scanner__Scanner_new_token(s, kind, name, name.len);
			}
			if (s->is_inside_string) {
				if (next_char == s->quote) {
					s->is_inter_end = true;
					s->is_inter_start = false;
					s->is_inside_string = false;
				}
			}
			if (s->is_inter_start && next_char == '\\' && !(v__scanner__Scanner_look_ahead(/*rec*/*s, 2) == 'n' || v__scanner__Scanner_look_ahead(/*rec*/*s, 2) == 'r' || v__scanner__Scanner_look_ahead(/*rec*/*s, 2) == '\\' || v__scanner__Scanner_look_ahead(/*rec*/*s, 2) == 't')) {
				v__scanner__Scanner_warn(s, _STR("unknown escape sequence \\%"PRIu8"", 1, v__scanner__Scanner_look_ahead(/*rec*/*s, 2)));
			}
			if (s->is_inter_start && next_char == '(') {
				if (v__scanner__Scanner_look_ahead(/*rec*/*s, 2) != ')') {
					v__scanner__Scanner_warn(s, tos_lit("use `${f(expr)}` instead of `$f(expr)`"));
				}
			} else if (s->is_inter_start && next_char != '.') {
				s->is_inter_end = true;
				s->is_inter_start = false;
			}
			if (s->pos == 0 && next_char == ' ') {
				s->pos++;
			}
			return v__scanner__Scanner_new_token(s, v__token__Kind_name, name, name.len);
		} else if (byte_is_digit(c) || (c == '.' && byte_is_digit(nextc))) {
			if (!s->is_inside_string) {
				int start_pos = s->pos;
				for (;;) {
					if (!(start_pos < s->text.len && string_at(s->text, start_pos) == '0')) break;
					start_pos++;
				}
				int prefix_zero_num = start_pos - s->pos;
				if (start_pos == s->text.len || (c == '0' && !byte_is_digit(string_at(s->text, start_pos)))) {
					prefix_zero_num--;
				}
				s->pos += prefix_zero_num;
			}
			string num = v__scanner__Scanner_ident_number(s);
			return v__scanner__Scanner_new_token(s, v__token__Kind_number, num, num.len);
		}
		if (c == ')' && s->is_inter_start) {
			byte next_char = v__scanner__Scanner_look_ahead(/*rec*/*s, 1);
			if (next_char != '.') {
				s->is_inter_end = true;
				s->is_inter_start = false;
				if (next_char == s->quote) {
					s->is_inside_string = false;
				}
				return v__scanner__Scanner_new_token(s, v__token__Kind_rpar, tos_lit(""), 1);
			}
		}
		byte _t855 = c;
		if (_t855 == '+') {
			if (nextc == '+') {
				s->pos++;
				return v__scanner__Scanner_new_token(s, v__token__Kind_inc, tos_lit(""), 2);
			} else if (nextc == '=') {
				s->pos++;
				return v__scanner__Scanner_new_token(s, v__token__Kind_plus_assign, tos_lit(""), 2);
			}
			return v__scanner__Scanner_new_token(s, v__token__Kind_plus, tos_lit(""), 1);
		} else if (_t855 == '-') {
			if (nextc == '-') {
				s->pos++;
				return v__scanner__Scanner_new_token(s, v__token__Kind_dec, tos_lit(""), 2);
			} else if (nextc == '=') {
				s->pos++;
				return v__scanner__Scanner_new_token(s, v__token__Kind_minus_assign, tos_lit(""), 2);
			}
			return v__scanner__Scanner_new_token(s, v__token__Kind_minus, tos_lit(""), 1);
		} else if (_t855 == '*') {
			if (nextc == '=') {
				s->pos++;
				return v__scanner__Scanner_new_token(s, v__token__Kind_mult_assign, tos_lit(""), 2);
			}
			return v__scanner__Scanner_new_token(s, v__token__Kind_mul, tos_lit(""), 1);
		} else if (_t855 == '^') {
			if (nextc == '=') {
				s->pos++;
				return v__scanner__Scanner_new_token(s, v__token__Kind_xor_assign, tos_lit(""), 2);
			}
			return v__scanner__Scanner_new_token(s, v__token__Kind_xor, tos_lit(""), 1);
		} else if (_t855 == '%') {
			if (nextc == '=') {
				s->pos++;
				return v__scanner__Scanner_new_token(s, v__token__Kind_mod_assign, tos_lit(""), 2);
			}
			return v__scanner__Scanner_new_token(s, v__token__Kind_mod, tos_lit(""), 1);
		} else if (_t855 == '?') {
			return v__scanner__Scanner_new_token(s, v__token__Kind_question, tos_lit(""), 1);
		} else if (_t855 == _const_v__scanner__single_quote || _t855 == _const_v__scanner__double_quote) {
			string ident_string = v__scanner__Scanner_ident_string(s);
			return v__scanner__Scanner_new_token(s, v__token__Kind_string, ident_string, ident_string.len + 2);
		} else if (_t855 == '`') {
			string ident_char = v__scanner__Scanner_ident_char(s);
			return v__scanner__Scanner_new_token(s, v__token__Kind_chartoken, ident_char, ident_char.len + 2);
		} else if (_t855 == '(') {
			if (s->pref->is_vet && string_at(s->text, s->pos + 1) == ' ') {
				v__scanner__Scanner_vet_error(s, tos_lit("Looks like you are adding a space after `(`"));
			}
			return v__scanner__Scanner_new_token(s, v__token__Kind_lpar, tos_lit(""), 1);
		} else if (_t855 == ')') {
			if (s->pref->is_vet && string_at(s->text, s->pos - 1) == ' ') {
				v__scanner__Scanner_vet_error(s, tos_lit("Looks like you are adding a space before `)`"));
			}
			return v__scanner__Scanner_new_token(s, v__token__Kind_rpar, tos_lit(""), 1);
		} else if (_t855 == '[') {
			return v__scanner__Scanner_new_token(s, v__token__Kind_lsbr, tos_lit(""), 1);
		} else if (_t855 == ']') {
			return v__scanner__Scanner_new_token(s, v__token__Kind_rsbr, tos_lit(""), 1);
		} else if (_t855 == '{') {
			if (s->is_inside_string) {
				continue;
			}
			return v__scanner__Scanner_new_token(s, v__token__Kind_lcbr, tos_lit(""), 1);
		} else if (_t855 == '$') {
			if (s->is_inside_string) {
				return v__scanner__Scanner_new_token(s, v__token__Kind_str_dollar, tos_lit(""), 1);
			} else {
				return v__scanner__Scanner_new_token(s, v__token__Kind_dollar, tos_lit(""), 1);
			}
		} else if (_t855 == '}') {
			if (s->is_inside_string) {
				s->pos++;
				if (string_at(s->text, s->pos) == s->quote) {
					s->is_inside_string = false;
					return v__scanner__Scanner_new_token(s, v__token__Kind_string, tos_lit(""), 1);
				}
				string ident_string = v__scanner__Scanner_ident_string(s);
				return v__scanner__Scanner_new_token(s, v__token__Kind_string, ident_string, ident_string.len + 2);
			} else {
				return v__scanner__Scanner_new_token(s, v__token__Kind_rcbr, tos_lit(""), 1);
			}
		} else if (_t855 == '&') {
			if (nextc == '=') {
				s->pos++;
				return v__scanner__Scanner_new_token(s, v__token__Kind_and_assign, tos_lit(""), 2);
			}
			byte afternextc = v__scanner__Scanner_look_ahead(/*rec*/*s, 2);
			if (nextc == '&' && byte_is_space(afternextc)) {
				s->pos++;
				return v__scanner__Scanner_new_token(s, v__token__Kind_and, tos_lit(""), 2);
			}
			return v__scanner__Scanner_new_token(s, v__token__Kind_amp, tos_lit(""), 1);
		} else if (_t855 == '|') {
			if (nextc == '|') {
				s->pos++;
				return v__scanner__Scanner_new_token(s, v__token__Kind_logical_or, tos_lit(""), 2);
			}
			if (nextc == '=') {
				s->pos++;
				return v__scanner__Scanner_new_token(s, v__token__Kind_or_assign, tos_lit(""), 2);
			}
			return v__scanner__Scanner_new_token(s, v__token__Kind_pipe, tos_lit(""), 1);
		} else if (_t855 == ',') {
			return v__scanner__Scanner_new_token(s, v__token__Kind_comma, tos_lit(""), 1);
		} else if (_t855 == '@') {
			s->pos++;
			string name = v__scanner__Scanner_ident_name(s);
			if (s->is_fmt) {
				return v__scanner__Scanner_new_token(s, v__token__Kind_name, string_add(tos_lit("@"), name), name.len + 1);
			}
			if (_IN(string, string_add(tos_lit("@"), name), _const_v__token__valid_at_tokens)) {
				return v__scanner__Scanner_new_token(s, v__token__Kind_at, string_add(tos_lit("@"), name), name.len + 1);
			}
			if (!v__token__is_key(name)) {
				string at_error_msg = tos_lit("@ must be used before keywords or compile time variables (e.g. `@type string` or `@FN`)");
				if (string_is_upper(name)) {
					at_error_msg = /*f*/string_add(at_error_msg, _STR("\nAvailable compile time variables:\n%.*s", 1, array_string_str(_const_v__token__valid_at_tokens)));
				}
				v__scanner__Scanner_error(s, at_error_msg);
			}
			return v__scanner__Scanner_new_token(s, v__token__Kind_name, name, name.len);
		} else if (_t855 == '.') {
			if (nextc == '.') {
				s->pos++;
				if (string_at(s->text, s->pos + 1) == '.') {
					s->pos++;
					return v__scanner__Scanner_new_token(s, v__token__Kind_ellipsis, tos_lit(""), 3);
				}
				return v__scanner__Scanner_new_token(s, v__token__Kind_dotdot, tos_lit(""), 2);
			}
			return v__scanner__Scanner_new_token(s, v__token__Kind_dot, tos_lit(""), 1);
		} else if (_t855 == '#') {
			int start = s->pos + 1;
			v__scanner__Scanner_ignore_line(s);
			if (nextc == '!') {
				s->line_comment = string_trim_space(string_substr(s->text, start + 1, s->pos));
				continue;
			}
			string hash = string_trim_space(string_substr(s->text, start, s->pos));
			return v__scanner__Scanner_new_token(s, v__token__Kind_hash, hash, hash.len);
		} else if (_t855 == '>') {
			if (nextc == '=') {
				s->pos++;
				return v__scanner__Scanner_new_token(s, v__token__Kind_ge, tos_lit(""), 2);
			} else if (nextc == '>') {
				if (s->pos + 2 < s->text.len && string_at(s->text, s->pos + 2) == '=') {
					s->pos += 2;
					return v__scanner__Scanner_new_token(s, v__token__Kind_right_shift_assign, tos_lit(""), 3);
				}
				s->pos++;
				return v__scanner__Scanner_new_token(s, v__token__Kind_right_shift, tos_lit(""), 2);
			} else {
				return v__scanner__Scanner_new_token(s, v__token__Kind_gt, tos_lit(""), 1);
			}
		} else if (_t855 == 0xE2) {
			if (nextc == 0x89 && string_at(s->text, s->pos + 2) == 0xA0) {
				s->pos += 2;
				return v__scanner__Scanner_new_token(s, v__token__Kind_ne, tos_lit(""), 3);
			} else if (nextc == 0x89 && string_at(s->text, s->pos + 2) == 0xBD) {
				s->pos += 2;
				return v__scanner__Scanner_new_token(s, v__token__Kind_le, tos_lit(""), 3);
			} else if (nextc == 0xA9 && string_at(s->text, s->pos + 2) == 0xBE) {
				s->pos += 2;
				return v__scanner__Scanner_new_token(s, v__token__Kind_ge, tos_lit(""), 3);
			}
		} else if (_t855 == '<') {
			if (nextc == '=') {
				s->pos++;
				return v__scanner__Scanner_new_token(s, v__token__Kind_le, tos_lit(""), 2);
			} else if (nextc == '<') {
				if (s->pos + 2 < s->text.len && string_at(s->text, s->pos + 2) == '=') {
					s->pos += 2;
					return v__scanner__Scanner_new_token(s, v__token__Kind_left_shift_assign, tos_lit(""), 3);
				}
				s->pos++;
				return v__scanner__Scanner_new_token(s, v__token__Kind_left_shift, tos_lit(""), 2);
			} else if (nextc == '-') {
				s->pos++;
				return v__scanner__Scanner_new_token(s, v__token__Kind_arrow, tos_lit(""), 2);
			} else {
				return v__scanner__Scanner_new_token(s, v__token__Kind_lt, tos_lit(""), 1);
			}
		} else if (_t855 == '=') {
			if (nextc == '=') {
				s->pos++;
				return v__scanner__Scanner_new_token(s, v__token__Kind_eq, tos_lit(""), 2);
			} else {
				return v__scanner__Scanner_new_token(s, v__token__Kind_assign, tos_lit(""), 1);
			}
		} else if (_t855 == ':') {
			if (nextc == '=') {
				s->pos++;
				return v__scanner__Scanner_new_token(s, v__token__Kind_decl_assign, tos_lit(""), 2);
			} else {
				return v__scanner__Scanner_new_token(s, v__token__Kind_colon, tos_lit(""), 1);
			}
		} else if (_t855 == ';') {
			return v__scanner__Scanner_new_token(s, v__token__Kind_semicolon, tos_lit(""), 1);
		} else if (_t855 == '!') {
			if (nextc == '=') {
				s->pos++;
				return v__scanner__Scanner_new_token(s, v__token__Kind_ne, tos_lit(""), 2);
			} else if (nextc == 'i' && string_at(s->text, s->pos + 2) == 'n' && byte_is_space(string_at(s->text, s->pos + 3))) {
				s->pos += 2;
				return v__scanner__Scanner_new_token(s, v__token__Kind_not_in, tos_lit(""), 3);
			} else if (nextc == 'i' && string_at(s->text, s->pos + 2) == 's' && byte_is_space(string_at(s->text, s->pos + 3))) {
				s->pos += 2;
				return v__scanner__Scanner_new_token(s, v__token__Kind_not_is, tos_lit(""), 3);
			} else {
				return v__scanner__Scanner_new_token(s, v__token__Kind_not, tos_lit(""), 1);
			}
		} else if (_t855 == '~') {
			return v__scanner__Scanner_new_token(s, v__token__Kind_bit_not, tos_lit(""), 1);
		} else if (_t855 == '/') {
			if (nextc == '=') {
				s->pos++;
				return v__scanner__Scanner_new_token(s, v__token__Kind_div_assign, tos_lit(""), 2);
			}
			if (nextc == '/') {
				int start = s->pos + 1;
				v__scanner__Scanner_ignore_line(s);
				int comment_line_end = s->pos;
				if (string_at(s->text, s->pos - 1) == '\r') {
					comment_line_end--;
				} else {
					s->pos--;
					s->line_nr--;
				}
				if (v__scanner__Scanner_should_parse_comment(s)) {
					s->line_comment = string_substr(s->text, start + 1, comment_line_end);
					string comment = string_trim_space(s->line_comment);
					bool is_separate_line_comment = true;
					for (int j = start - 2; j >= 0 && string_at(s->text, j) != '\n'; j--) {
						if (!(string_at(s->text, j) == '\t' || string_at(s->text, j) == ' ')) {
							is_separate_line_comment = false;
						}
					}
					if (is_separate_line_comment) {
						comment = string_add(tos_lit("\x01"), comment);
					}
					return v__scanner__Scanner_new_token(s, v__token__Kind_comment, comment, comment.len + 2);
				}
				continue;
			}
			if (nextc == '*') {
				int start = s->pos + 2;
				int nest_count = 1;
				for (;;) {
					if (!(nest_count > 0)) break;
					s->pos++;
					if (s->pos >= s->text.len) {
						s->line_nr--;
						v__scanner__Scanner_error(s, tos_lit("comment not terminated"));
					}
					if (string_at(s->text, s->pos) == '\n') {
						v__scanner__Scanner_inc_line_number(s);
						continue;
					}
					if (v__scanner__Scanner_expect(s, tos_lit("/*"), s->pos)) {
						nest_count++;
						continue;
					}
					if (v__scanner__Scanner_expect(s, tos_lit("*/"), s->pos)) {
						nest_count--;
					}
				}
				s->pos++;
				if (v__scanner__Scanner_should_parse_comment(s)) {
					string comment = string_trim_space(string_substr(s->text, start, (s->pos - 1)));
					return v__scanner__Scanner_new_token(s, v__token__Kind_comment, comment, comment.len + 4);
				}
				continue;
			}
			return v__scanner__Scanner_new_token(s, v__token__Kind_div, tos_lit(""), 1);
		} else {
		};
		#if defined(_WIN32)
		{
			if (c == '\0') {
				return v__scanner__Scanner_end_of_file(s);
			}
		}
		#endif
		v__scanner__Scanner_error(s, _STR("invalid character `%.*s\000`", 2, byte_str(c)));
		break;
	}
	return v__scanner__Scanner_end_of_file(s);
}

VV_LOCAL_SYMBOL int v__scanner__Scanner_current_column(v__scanner__Scanner* s) {
	return s->pos - s->last_nl_pos;
}

VV_LOCAL_SYMBOL int v__scanner__Scanner_count_symbol_before(v__scanner__Scanner* s, int p, byte sym) {
	int count = 0;
	for (int i = p; i >= 0; i--) {
		if (string_at(s->text, i) != sym) {
			break;
		}
		count++;
	}
	return count;
}

VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_string(v__scanner__Scanner* s) {
	byte q = string_at(s->text, s->pos);
	bool is_quote = q == _const_v__scanner__single_quote || q == _const_v__scanner__double_quote;
	bool is_raw = is_quote && s->pos > 0 && string_at(s->text, s->pos - 1) == 'r';
	bool is_cstr = is_quote && s->pos > 0 && string_at(s->text, s->pos - 1) == 'c';
	if (is_quote && !s->is_inside_string) {
		s->quote = q;
	}
	int n_cr_chars = 0;
	int start = s->pos;
	s->is_inside_string = false;
	rune slash = '\\';
	for (;;) {
		s->pos++;
		if (s->pos >= s->text.len) {
			v__scanner__Scanner_error(s, tos_lit("unfinished string literal"));
		}
		byte c = string_at(s->text, s->pos);
		byte prevc = string_at(s->text, s->pos - 1);
		if (c == s->quote && (prevc != slash || (prevc == slash && string_at(s->text, s->pos - 2) == slash))) {
			break;
		}
		if (c == '\r') {
			n_cr_chars++;
		}
		if (c == '\n') {
			v__scanner__Scanner_inc_line_number(s);
		}
		if (c == '0' && s->pos > 2 && string_at(s->text, s->pos - 1) == slash) {
			if ((s->pos < s->text.len - 1 && byte_is_digit(string_at(s->text, s->pos + 1))) || v__scanner__Scanner_count_symbol_before(s, s->pos - 1, slash) % 2 == 0) {
			} else if (!is_cstr && !is_raw) {
				v__scanner__Scanner_error(s, tos_lit("cannot use `\\0` (NULL character) in the string literal"));
			}
		}
		if (c == '0' && s->pos > 5 && v__scanner__Scanner_expect(s, tos_lit("\\x0"), s->pos - 3)) {
			if (v__scanner__Scanner_count_symbol_before(s, s->pos - 3, slash) % 2 == 0) {
			} else if (!is_cstr && !is_raw) {
				v__scanner__Scanner_error(s, tos_lit("cannot use `\\x00` (NULL character) in the string literal"));
			}
		}
		if (prevc == slash && c == 'x' && v__scanner__Scanner_count_symbol_before(s, s->pos - 2, slash) % 2 == 0 && !is_raw && !is_cstr && (string_at(s->text, s->pos + 1) == s->quote || !byte_is_hex_digit(string_at(s->text, s->pos + 1)))) {
			v__scanner__Scanner_error(s, tos_lit("`\\x` used with no following hex digits"));
		}
		if (prevc == '$' && c == '{' && !is_raw && v__scanner__Scanner_count_symbol_before(s, s->pos - 2, slash) % 2 == 0) {
			s->is_inside_string = true;
			s->pos -= 2;
			break;
		}
		if (prevc == '$' && v__util__is_name_char(c) && !is_raw && v__scanner__Scanner_count_symbol_before(s, s->pos - 2, slash) % 2 == 0) {
			s->is_inside_string = true;
			s->is_inter_start = true;
			s->pos -= 2;
			break;
		}
	}
	string lit = tos_lit("");
	if (string_at(s->text, start) == s->quote) {
		start++;
	}
	int end = s->pos;
	if (s->is_inside_string) {
		end++;
	}
	if (start <= s->pos) {
		string string_so_far = string_substr(s->text, start, end);
		if (n_cr_chars > 0) {
			string_so_far = string_replace(string_so_far, tos_lit("\r"), tos_lit(""));
		}
		if (string_contains(string_so_far, tos_lit("\\\n"))) {
			lit = v__scanner__trim_slash_line_break(string_so_far);
		} else {
			lit = string_so_far;
		}
	}
	return lit;
}

VV_LOCAL_SYMBOL string v__scanner__trim_slash_line_break(string s) {
	int start = 0;
	string ret_str = s;
	for (;;) {
		int idx = string_index_after(ret_str, tos_lit("\\\n"), start);
		if (idx != -1) {
			ret_str = string_add(string_substr(ret_str, 0, idx), string_trim_left(string_substr(ret_str, idx + 2, ret_str.len), tos_lit(" \n\t\v\f\r")));
			start = idx;
		} else {
			break;
		}
	}
	return ret_str;
}

VV_LOCAL_SYMBOL string v__scanner__Scanner_ident_char(v__scanner__Scanner* s) {
	int start = s->pos;
	rune slash = '\\';
	int len = 0;
	for (;;) {
		s->pos++;
		if (s->pos >= s->text.len) {
			break;
		}
		if (string_at(s->text, s->pos) != slash) {
			len++;
		}
		bool double_slash = v__scanner__Scanner_expect(s, tos_lit("\\\\"), s->pos - 2);
		if (string_at(s->text, s->pos) == '`' && (string_at(s->text, s->pos - 1) != slash || double_slash)) {
			if (double_slash) {
				len++;
			}
			break;
		}
	}
	len--;
	string c = string_substr(s->text, start + 1, s->pos);
	if (len != 1) {
		ustring u = string_ustring(c);
		if (u.len != 1) {
			v__scanner__Scanner_error(s, string_add(tos_lit("invalid character literal (more than one character)\n"), tos_lit("use quotes for strings, backticks for characters")));
		}
	}
	return (string_eq(c, tos_lit("\'")) ? (string_add(tos_lit("\\"), c)) : (c));
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL bool v__scanner__Scanner_expect(v__scanner__Scanner* s, string want, int start_pos) {
	int end_pos = start_pos + want.len;
	if (start_pos < 0 || start_pos >= s->text.len) {
		return false;
	}
	if (end_pos < 0 || end_pos > s->text.len) {
		return false;
	}
	for (int pos = start_pos; pos < end_pos; ++pos) {
		if (string_at(s->text, pos) != string_at(want, pos - start_pos)) {
			return false;
		}
	}
	return true;
}

VV_LOCAL_SYMBOL void v__scanner__Scanner_debug_tokens(v__scanner__Scanner* s) {
	s->pos = 0;
	s->is_started = false;
	s->is_debug = true;
	string fname = string_all_after_last(s->file_path, _const_os__path_separator);
	println(_STR("\n===DEBUG TOKENS %.*s\000===", 2, fname));
	for (;;) {
		v__token__Token tok = v__scanner__Scanner_scan(s);
		v__token__Kind tok_kind = tok.kind;
		string lit = tok.lit;
		print(v__token__Kind_str(tok_kind));
		if ((lit).len != 0) {
			println(_STR(" `%.*s\000`", 2, lit));
		} else {
			println(tos_lit(""));
		}
		if (tok_kind == v__token__Kind_eof) {
			println(tos_lit("============ END OF DEBUG TOKENS =================="));
			break;
		}
	}
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL void v__scanner__Scanner_ignore_line(v__scanner__Scanner* s) {
	v__scanner__Scanner_eat_to_end_of_line(s);
	v__scanner__Scanner_inc_line_number(s);
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL void v__scanner__Scanner_eat_to_end_of_line(v__scanner__Scanner* s) {
	for (;;) {
		if (!(s->pos < s->text.len && string_at(s->text, s->pos) != '\n')) break;
		s->pos++;
	}
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL void v__scanner__Scanner_inc_line_number(v__scanner__Scanner* s) {
	s->last_nl_pos = s->pos;
	s->line_nr++;
	array_push(&s->line_ends, _MOV((int[]){ s->pos }));
	if (s->line_nr > s->nr_lines) {
		s->nr_lines = s->line_nr;
	}
}

void v__scanner__Scanner_warn(v__scanner__Scanner* s, string msg) {
	v__token__Position pos = (v__token__Position){.len = 0,.line_nr = s->line_nr,.pos = s->pos,};
	if (s->pref->output_mode == v__pref__OutputMode_stdout) {
		eprintln(v__util__formatted_error(tos_lit("warning:"), msg, s->file_path, pos));
	} else {
		array_push(&s->warnings, _MOV((v__errors__Warning[]){ (v__errors__Warning){.message = msg,.details = (string){.str=(byteptr)""},.file_path = s->file_path,.pos = pos,.reporter = v__errors__Reporter_scanner,} }));
	}
}

void v__scanner__Scanner_error(v__scanner__Scanner* s, string msg) {
	v__token__Position pos = (v__token__Position){.len = 0,.line_nr = s->line_nr,.pos = s->pos,};
	if (s->pref->output_mode == v__pref__OutputMode_stdout) {
		eprintln(v__util__formatted_error(tos_lit("error:"), msg, s->file_path, pos));
		v_exit(1);
	} else {
		array_push(&s->errors, _MOV((v__errors__Error[]){ (v__errors__Error){.message = msg,.details = (string){.str=(byteptr)""},.file_path = s->file_path,.pos = pos,.backtrace = (string){.str=(byteptr)""},.reporter = v__errors__Reporter_scanner,} }));
	}
}

VV_LOCAL_SYMBOL void v__scanner__Scanner_vet_error(v__scanner__Scanner* s, string msg) {
	string eline = _STR("%.*s\000:%"PRId32"\000: %.*s", 3, s->file_path, s->line_nr, msg);
	array_push(&s->vet_errors, _MOV((string[]){ string_clone(eline) }));
}

void v__scanner__verror(string s) {
	v__util__verror(tos_lit("scanner error"), s);
}

void v__scanner__Scanner_codegen(v__scanner__Scanner* s, string newtext) {
	if (s->comments_mode == v__scanner__CommentsMode_skip_comments) {
		s->text = /*f*/string_add(s->text, newtext);
		#if defined(CUSTOM_DEFINE_debug_codegen)
		{
		}
		#endif
	}
}

bool v__checker__Checker_check_basic(v__checker__Checker* c, v__table__Type got, v__table__Type expected) {
	if (got == expected) {
		return true;
	}
	v__table__Table* t = c->table;
	int got_idx = v__table__Type_idx(v__table__Table_unalias_num_type(t, got));
	int exp_idx = v__table__Type_idx(v__table__Table_unalias_num_type(t, expected));
	bool exp_is_ptr = v__table__Type_is_ptr(expected);
	if (got_idx == exp_idx) {
		return true;
	}
	if (got_idx == _const_v__table__none_type_idx && v__table__Type_has_flag(expected, v__table__TypeFlag_optional)) {
		return true;
	}
	if (exp_is_ptr && got_idx == _const_v__table__int_type_idx) {
		return true;
	}
	if (exp_idx == _const_v__table__voidptr_type_idx || got_idx == _const_v__table__voidptr_type_idx) {
		return true;
	}
	if (exp_idx == _const_v__table__any_type_idx || got_idx == _const_v__table__any_type_idx) {
		return true;
	}
	if ((_IN(int, exp_idx, _const_v__table__pointer_type_idxs) || _IN(int, exp_idx, _const_v__table__number_type_idxs)) && (_IN(int, got_idx, _const_v__table__pointer_type_idxs) || _IN(int, got_idx, _const_v__table__number_type_idxs))) {
		return true;
	}
	if ((got_idx == _const_v__table__byte_type_idx && exp_idx == _const_v__table__byteptr_type_idx) || (exp_idx == _const_v__table__byte_type_idx && got_idx == _const_v__table__byteptr_type_idx)) {
		return true;
	}
	if ((got_idx == _const_v__table__char_type_idx && exp_idx == _const_v__table__charptr_type_idx) || (exp_idx == _const_v__table__char_type_idx && got_idx == _const_v__table__charptr_type_idx)) {
		return true;
	}
	v__table__TypeSymbol* got_type_sym = v__table__Table_get_type_symbol(t, got);
	v__table__TypeSymbol* exp_type_sym = v__table__Table_get_type_symbol(t, expected);
	if (exp_type_sym->kind == v__table__Kind_function && got_type_sym->kind == v__table__Kind_int) {
		return true;
	}
	if ((v__table__TypeSymbol_is_int(got_type_sym) && exp_type_sym->kind == v__table__Kind_enum_) || (v__table__TypeSymbol_is_int(exp_type_sym) && got_type_sym->kind == v__table__Kind_enum_)) {
		return true;
	}
	if (got_type_sym->kind == v__table__Kind_array_fixed && exp_type_sym->kind == v__table__Kind_byteptr) {
		v__table__ArrayFixed info = /* as */ *(v__table__ArrayFixed*)__as_cast((got_type_sym->info)._351, (got_type_sym->info).typ, /*expected:*/351);
		if (v__table__Type_idx(info.elem_type) == _const_v__table__byte_type_idx) {
			return true;
		}
	}
	if (string_eq(exp_type_sym->name, tos_lit("array")) || string_eq(got_type_sym->name, tos_lit("array"))) {
		return true;
	}
	if (got_type_sym->kind == v__table__Kind_array && string_eq(got_type_sym->name, tos_lit("array_void")) && exp_type_sym->kind == v__table__Kind_array) {
		return true;
	}
	if ((got_type_sym->kind == v__table__Kind_alias && got_type_sym->parent_idx == exp_idx) || (exp_type_sym->kind == v__table__Kind_alias && exp_type_sym->parent_idx == got_idx)) {
		return true;
	}
	if (v__checker__Checker_check_sumtype_compatibility(c, got, expected)) {
		return true;
	}
	if (got_type_sym->kind == v__table__Kind_function && exp_type_sym->kind == v__table__Kind_function) {
		return v__checker__Checker_check_matching_function_symbols(c, got_type_sym, exp_type_sym);
	}
	return false;
}

bool v__checker__Checker_check_matching_function_symbols(v__checker__Checker* c, v__table__TypeSymbol* got_type_sym, v__table__TypeSymbol* exp_type_sym) {
	v__table__FnType got_info = /* as */ *(v__table__FnType*)__as_cast((got_type_sym->info)._353, (got_type_sym->info).typ, /*expected:*/353);
	v__table__FnType exp_info = /* as */ *(v__table__FnType*)__as_cast((exp_type_sym->info)._353, (exp_type_sym->info).typ, /*expected:*/353);
	v__table__Fn got_fn = got_info.func;
	v__table__Fn exp_fn = exp_info.func;
	if (got_fn.params.len != exp_fn.params.len) {
		return false;
	}
	if (!v__checker__Checker_check_basic(c, got_fn.return_type, exp_fn.return_type)) {
		return false;
	}
	// FOR IN array
	array _t860 = got_fn.params;
	for (int i = 0; i < _t860.len; ++i) {
		v__table__Param got_arg = ((v__table__Param*)_t860.data)[i];
		v__table__Param exp_arg = (*(v__table__Param*)/*ee elem_typ */array_get(exp_fn.params, i));
		bool exp_arg_is_ptr = v__table__Type_is_ptr(exp_arg.typ) || v__table__Type_is_pointer(exp_arg.typ);
		bool got_arg_is_ptr = v__table__Type_is_ptr(got_arg.typ) || v__table__Type_is_pointer(got_arg.typ);
		if (exp_arg_is_ptr != got_arg_is_ptr) {
			string exp_arg_pointedness = (exp_arg_is_ptr ? (tos_lit("a pointer")) : (tos_lit("NOT a pointer")));
			string got_arg_pointedness = (got_arg_is_ptr ? (tos_lit("a pointer")) : (tos_lit("NOT a pointer")));
			v__checker__Checker_add_error_detail(c, _STR("`%.*s\000`\'s expected fn argument: `%.*s\000` is %.*s\000, but the passed fn argument: `%.*s\000` is %.*s", 5, exp_fn.name, exp_arg.name, exp_arg_pointedness, got_arg.name, got_arg_pointedness));
			return false;
		}
		if (!v__checker__Checker_check_basic(c, got_arg.typ, exp_arg.typ)) {
			return false;
		}
	}
	return true;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL v__table__Type v__checker__Checker_check_shift(v__checker__Checker* c, v__table__Type left_type, v__table__Type right_type, v__token__Position left_pos, v__token__Position right_pos) {
	if (!v__table__Type_is_int(left_type)) {
		v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(c->table, left_type);
		if (sym->kind == v__table__Kind_alias && v__table__Type_is_int((/* as */ *(v__table__Alias*)__as_cast((sym->info)._347, (sym->info).typ, /*expected:*/347)).parent_type)) {
			return left_type;
		}
		if (c->pref->translated && left_type == _const_v__table__bool_type) {
			return _const_v__table__int_type;
		}
		v__checker__Checker_error(c, _STR("invalid operation: shift of type `%.*s\000`", 2, sym->name), left_pos);
		return _const_v__table__void_type;
	} else if (!v__table__Type_is_int(right_type)) {
		v__checker__Checker_error(c, _STR("cannot shift non-integer type %.*s\000 into type %.*s", 2, v__table__Table_get_type_symbol(c->table, right_type)->name, v__table__Table_get_type_symbol(c->table, left_type)->name), right_pos);
		return _const_v__table__void_type;
	}
	return left_type;
}

v__table__Type v__checker__Checker_promote(v__checker__Checker* c, v__table__Type left_type, v__table__Type right_type) {
	if (v__table__Type_is_ptr(left_type) || v__table__Type_is_pointer(left_type)) {
		if (v__table__Type_is_int(right_type)) {
			return left_type;
		} else {
			return _const_v__table__void_type;
		}
	} else if (v__table__Type_is_ptr(right_type) || v__table__Type_is_pointer(right_type)) {
		if (v__table__Type_is_int(left_type)) {
			return right_type;
		} else {
			return _const_v__table__void_type;
		}
	}
	if (left_type == right_type) {
		return left_type;
	}
	if (v__table__Type_is_number(right_type) && v__table__Type_is_number(left_type)) {
		return v__checker__Checker_promote_num(c, left_type, right_type);
	} else if (v__table__Type_has_flag(left_type, v__table__TypeFlag_optional) != v__table__Type_has_flag(right_type, v__table__TypeFlag_optional)) {
		return _const_v__table__void_type;
	} else {
		return left_type;
	}
	return 0;
}

VV_LOCAL_SYMBOL v__table__Type v__checker__Checker_promote_num(v__checker__Checker* c, v__table__Type left_type, v__table__Type right_type) {
	v__table__Type type_hi = left_type;
	v__table__Type type_lo = right_type;
	if (v__table__Type_idx(type_hi) < v__table__Type_idx(type_lo)) {
		v__table__Type _var_6492 = type_hi;
		v__table__Type _var_6501 = type_lo;
		type_hi = _var_6501;
		type_lo = _var_6492;
	}
	int idx_hi = v__table__Type_idx(type_hi);
	int idx_lo = v__table__Type_idx(type_lo);
	if (idx_hi == _const_v__table__any_int_type_idx) {
		return type_lo;
	} else if (idx_hi == _const_v__table__any_flt_type_idx) {
		if (_IN(int, idx_lo, _const_v__table__float_type_idxs)) {
			return type_lo;
		} else {
			return _const_v__table__void_type;
		}
	} else if (v__table__Type_is_float(type_hi)) {
		if (idx_hi == _const_v__table__f32_type_idx) {
			if ((idx_lo == _const_v__table__i64_type_idx || idx_lo == _const_v__table__u64_type_idx)) {
				return _const_v__table__void_type;
			} else {
				return type_hi;
			}
		} else {
			return type_hi;
		}
	} else if (idx_lo >= _const_v__table__byte_type_idx) {
		return type_hi;
	} else if (idx_lo >= _const_v__table__i8_type_idx && (idx_hi <= _const_v__table__i64_type_idx || idx_hi == _const_v__table__rune_type_idx)) {
		return (idx_lo == _const_v__table__i64_type_idx ? (type_lo) : (type_hi));
	} else if (idx_hi - idx_lo < (_const_v__table__byte_type_idx - _const_v__table__i8_type_idx)) {
		return type_lo;
	} else {
		return _const_v__table__void_type;
	}
	return 0;
}

bool v__checker__Checker_check_types(v__checker__Checker* c, v__table__Type got, v__table__Type expected) {
	if (got == expected) {
		return true;
	}
	int exp_idx = v__table__Type_idx(expected);
	int got_idx = v__table__Type_idx(got);
	if (exp_idx == got_idx) {
		return true;
	}
	if (exp_idx == _const_v__table__voidptr_type_idx || exp_idx == _const_v__table__byteptr_type_idx) {
		if (v__table__Type_is_ptr(got) || v__table__Type_is_pointer(got)) {
			return true;
		}
	}
	if (v__table__Type_is_ptr(expected) || v__table__Type_is_pointer(expected)) {
		if (got == _const_v__table__any_int_type) {
			return true;
		}
	}
	if (got_idx == _const_v__table__voidptr_type_idx || got_idx == _const_v__table__byteptr_type_idx) {
		if (v__table__Type_is_ptr(expected) || v__table__Type_is_pointer(expected)) {
			return true;
		}
	}
	if (!v__checker__Checker_check_basic(c, got, expected)) {
		return false;
	}
	if (v__table__Type_is_number(got) && v__table__Type_is_number(expected)) {
		if (got == _const_v__table__rune_type && expected == _const_v__table__byte_type) {
			return true;
		} else if (expected == _const_v__table__rune_type && got == _const_v__table__byte_type) {
			return true;
		}
		if (v__checker__Checker_promote_num(c, expected, got) != expected) {
			return false;
		}
	}
	return true;
}

Option_void v__checker__Checker_check_expected(v__checker__Checker* c, v__table__Type got, v__table__Type expected) {
	if (v__checker__Checker_check_types(c, got, expected)) {
		Option_void _t861 = {.ok = true};
		return _t861;
	}
	string exps = v__table__Table_type_to_str(c->table, expected);
	string gots = v__table__Table_type_to_str(c->table, got);
	Option _t862 = v_error(_STR("expected `%.*s\000`, not `%.*s\000`", 3, exps, gots));
	return *(Option_void*)&_t862;
}

bool v__checker__Checker_symmetric_check(v__checker__Checker* c, v__table__Type left, v__table__Type right) {
	if (v__table__Type_is_ptr(right) || v__table__Type_is_pointer(right)) {
		if (left == _const_v__table__any_int_type) {
			return true;
		}
	}
	if (v__table__Type_is_ptr(left) || v__table__Type_is_pointer(left)) {
		if (right == _const_v__table__any_int_type) {
			return true;
		}
	}
	return v__checker__Checker_check_basic(c, left, right);
}

byte v__checker__Checker_get_default_fmt(v__checker__Checker* c, v__table__Type ftyp, v__table__Type typ) {
	if (v__table__Type_is_float(typ)) {
		return 'g';
	} else if (v__table__Type_is_signed(typ) || v__table__Type_is_any_int(typ)) {
		return 'd';
	} else if (v__table__Type_is_unsigned(typ)) {
		return 'u';
	} else if (v__table__Type_is_pointer(typ)) {
		return 'p';
	} else {
		v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(c->table, v__checker__Checker_unwrap_generic(c, ftyp));
		if (sym->kind == v__table__Kind_alias) {
			v__table__Alias info = /* as */ *(v__table__Alias*)__as_cast((sym->info)._347, (sym->info).typ, /*expected:*/347);
			sym = v__table__Table_get_type_symbol(c->table, info.parent_type);
			if (info.parent_type == _const_v__table__string_type) {
				return 's';
			}
		}
		if ((ftyp == _const_v__table__string_type || ftyp == _const_v__table__bool_type) || (sym->kind == v__table__Kind_enum_ || sym->kind == v__table__Kind_array || sym->kind == v__table__Kind_array_fixed || sym->kind == v__table__Kind_struct_ || sym->kind == v__table__Kind_map || sym->kind == v__table__Kind_multi_return || sym->kind == v__table__Kind_sum_type) || v__table__Type_has_flag(ftyp, v__table__TypeFlag_optional) || v__table__TypeSymbol_has_method(sym, tos_lit("str"))) {
			return 's';
		} else {
			return '_';
		}
	}
	return 0;
}

v__table__Type v__checker__Checker_string_inter_lit(v__checker__Checker* c, v__ast__StringInterLiteral* node) {
	// FOR IN array
	array _t863 = node->exprs;
	for (int i = 0; i < _t863.len; ++i) {
		v__ast__Expr expr = ((v__ast__Expr*)_t863.data)[i];
		v__table__Type ftyp = v__checker__Checker_expr(c, expr);
		array_push(&node->expr_types, _MOV((v__table__Type[]){ ftyp }));
		v__table__Type typ = v__table__Table_unalias_num_type(c->table, ftyp);
		byte fmt = (*(byte*)/*ee elem_typ */array_get(node->fmts, i));
		if (!(fmt == 'E' || fmt == 'F' || fmt == 'G' || fmt == 'e' || fmt == 'f' || fmt == 'g' || fmt == 'd' || fmt == 'u' || fmt == 'x' || fmt == 'X' || fmt == 'o' || fmt == 'c' || fmt == 's' || fmt == 'p' || fmt == '_')) {
			v__checker__Checker_error(c, _STR("unknown format specifier `%c\000`", 2, fmt), (*(v__token__Position*)/*ee elem_typ */array_get(node->fmt_poss, i)));
		}
		if (fmt == '_') {
			fmt = v__checker__Checker_get_default_fmt(c, ftyp, typ);
			if (fmt == '_') {
				if (typ != _const_v__table__void_type) {
					v__checker__Checker_error(c, _STR("no known default format for type `%.*s\000`", 2, v__table__Table_get_type_name(c->table, ftyp)), (*(v__token__Position*)/*ee elem_typ */array_get(node->fmt_poss, i)));
				}
			} else {
				(*(byte*)/*ee elem_typ */array_get(node->fmts, i)) = fmt;
				(*(bool*)/*ee elem_typ */array_get(node->need_fmts, i)) = false;
			}
		} else {
			if ((*(int*)/*ee elem_typ */array_get(node->precisions, i)) != 987698 && !v__table__Type_is_float(typ)) {
				v__checker__Checker_error(c, tos_lit("precision specification only valid for float types"), (*(v__token__Position*)/*ee elem_typ */array_get(node->fmt_poss, i)));
			}
			if ((*(bool*)/*ee elem_typ */array_get(node->pluss, i)) && !v__table__Type_is_number(typ)) {
				v__checker__Checker_error(c, tos_lit("plus prefix only allowed for numbers"), (*(v__token__Position*)/*ee elem_typ */array_get(node->fmt_poss, i)));
			}
			if ((v__table__Type_is_unsigned(typ) && !(fmt == 'u' || fmt == 'x' || fmt == 'X' || fmt == 'o' || fmt == 'c')) || (v__table__Type_is_signed(typ) && !(fmt == 'd' || fmt == 'x' || fmt == 'X' || fmt == 'o' || fmt == 'c')) || (v__table__Type_is_any_int(typ) && !(fmt == 'd' || fmt == 'c' || fmt == 'x' || fmt == 'X' || fmt == 'o' || fmt == 'u' || fmt == 'x' || fmt == 'X' || fmt == 'o')) || (v__table__Type_is_float(typ) && !(fmt == 'E' || fmt == 'F' || fmt == 'G' || fmt == 'e' || fmt == 'f' || fmt == 'g')) || (v__table__Type_is_pointer(typ) && !(fmt == 'p' || fmt == 'x' || fmt == 'X')) || (v__table__Type_is_string(typ) && fmt != 's') || ((v__table__Type_idx(typ) == _const_v__table__i64_type_idx || v__table__Type_idx(typ) == _const_v__table__f64_type_idx) && fmt == 'c')) {
				v__checker__Checker_error(c, _STR("illegal format specifier `%c\000` for type `%.*s\000`", 3, fmt, v__table__Table_get_type_name(c->table, ftyp)), (*(v__token__Position*)/*ee elem_typ */array_get(node->fmt_poss, i)));
			}
			(*(bool*)/*ee elem_typ */array_get(node->need_fmts, i)) = fmt != v__checker__Checker_get_default_fmt(c, ftyp, typ);
		}
	}
	return _const_v__table__string_type;
}

bool v__checker__Checker_check_sumtype_compatibility(v__checker__Checker* c, v__table__Type a, v__table__Type b) {
	return v__table__Table_sumtype_has_variant(c->table, a, b) || v__table__Table_sumtype_has_variant(c->table, b, a);
}

void v__checker__Checker_infer_fn_types(v__checker__Checker* c, v__table__Fn f, v__ast__CallExpr* call_expr) {
	string gt_name = tos_lit("T");
	v__table__Type typ = _const_v__table__void_type;
	// FOR IN array
	array _t865 = f.params;
	for (int i = 0; i < _t865.len; ++i) {
		v__table__Param param = ((v__table__Param*)_t865.data)[i];
		v__ast__CallArg arg = (*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr->args, i));
		if (string_eq(param.type_source_name, gt_name)) {
			typ = arg.typ;
			break;
		}
		v__table__TypeSymbol* arg_sym = v__table__Table_get_type_symbol(c->table, arg.typ);
		if (arg_sym->kind == v__table__Kind_array && string_eq(param.type_source_name, _STR("[]%.*s", 1, gt_name))) {
			v__table__Array info = /* as */ *(v__table__Array*)__as_cast((arg_sym->info)._350, (arg_sym->info).typ, /*expected:*/350);
			typ = info.elem_type;
			break;
		}
	}
	if (typ == _const_v__table__void_type) {
		v__checker__Checker_error(c, _STR("could not infer generic type `%.*s\000` in call to `%.*s\000`", 3, gt_name, f.name), call_expr->pos);
	} else {
		if (c->pref->is_verbose) {
			string s = v__table__Table_type_to_str(c->table, typ);
			println(_STR("inferred `%.*s\000<%.*s\000>`", 3, f.name, s));
		}
		v__table__Table_register_fn_gen_type(c->table, f.name, typ);
		call_expr->generic_type = typ;
	}
}

v__checker__Checker v__checker__new_checker(v__table__Table* table, v__pref__Preferences* pref) {
	return (v__checker__Checker){.pref = pref,.table = table,.file = 0,.nr_errors = 0,.nr_warnings = 0,.errors = __new_array(0, 1, sizeof(v__errors__Error)),.warnings = __new_array(0, 1, sizeof(v__errors__Warning)),.error_lines = __new_array(0, 1, sizeof(int)),.expected_type = 0,.cur_fn = 0,.const_decl = (string){.str=(byteptr)""},.const_deps = __new_array(0, 1, sizeof(string)),.const_names = __new_array(0, 1, sizeof(string)),.global_names = __new_array(0, 1, sizeof(string)),.locked_names = __new_array(0, 1, sizeof(string)),.rlocked_names = __new_array(0, 1, sizeof(string)),.in_for_count = 0,.returns = 0,.scope_returns = 0,.mod = (string){.str=(byteptr)""},.is_builtin_mod = 0,.inside_unsafe = 0,.inside_const = 0,.skip_flags = 0,.cur_generic_type = 0,.expr_level = 0,.inside_sql = 0,.cur_orm_ts = {0},.error_details = __new_array(0, 1, sizeof(string)),.generic_funcs = __new_array(0, 1, sizeof(v__ast__FnDecl*)),.vmod_file_content = (string){.str=(byteptr)""},.vweb_gen_types = __new_array(0, 1, sizeof(v__table__Type)),.prevent_sum_type_unwrapping_once = 0,.loop_label = (string){.str=(byteptr)""},};
}

void v__checker__Checker_check(v__checker__Checker* c, v__ast__File* ast_file) {
	c->file = ast_file;
	// FOR IN array
	array _t866 = ast_file->imports;
	for (int i = 0; i < _t866.len; ++i) {
		v__ast__Import ast_import = ((v__ast__Import*)_t866.data)[i];
		for (int j = 0; j < i; ++j) {
			if (string_eq(ast_import.mod, (*(v__ast__Import*)/*ee elem_typ */array_get(ast_file->imports, j)).mod)) {
				v__checker__Checker_error(c, _STR("module name `%.*s\000` duplicate", 2, ast_import.mod), ast_import.pos);
			}
		}
	}
	// FOR IN array
	array _t867 = ast_file->stmts;
	for (int _t868 = 0; _t868 < _t867.len; ++_t868) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)_t867.data)[_t868];
		c->expr_level = 0;
		v__checker__Checker_stmt(c, stmt);
	}
	v__checker__Checker_check_scope_vars(c, c->file->scope);
	v__checker__Checker_post_process_generic_fns(c);
}

void v__checker__Checker_check_scope_vars(v__checker__Checker* c, v__ast__Scope* sc) {
	// FOR IN map
	map_string_v__ast__ScopeObject _t870 = sc->objects;
	for (int _t869 = 0; _t869 < _t870.key_values.len; ++_t869) {
		if (_t870.key_values.keys[_t869].str == 0) {continue;}
		v__ast__ScopeObject obj = (*(v__ast__ScopeObject*)(void*)(_t870.key_values.values + _t869 * (u32)(_t870.value_bytes)));
		v__ast__ScopeObject _t871 = obj;
		if (_t871.typ == 277 /* v.ast.Var */) {
			if (!c->pref->is_repl) {
				if (!(*obj._277).is_used && string_at((*obj._277).name, 0) != '_') {
					v__checker__Checker_warn(c, _STR("unused variable: `%.*s\000`", 2, (*obj._277).name), (*obj._277).pos);
				}
			}
			if ((*obj._277).is_mut && !(*obj._277).is_changed && !c->is_builtin_mod && string_ne((*obj._277).name, tos_lit("it"))) {
			}
		} else {
		};
	}
	// FOR IN array
	array _t872 = sc->children;
	for (int _t873 = 0; _t873 < _t872.len; ++_t873) {
		v__ast__Scope* child = ((v__ast__Scope**)_t872.data)[_t873];
		v__checker__Checker_check_scope_vars(c, child);
	}
}

array_v__errors__Error v__checker__Checker_check2(v__checker__Checker* c, v__ast__File* ast_file) {
	c->file = ast_file;
	// FOR IN array
	array _t874 = ast_file->stmts;
	for (int _t875 = 0; _t875 < _t874.len; ++_t875) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)_t874.data)[_t875];
		v__checker__Checker_stmt(c, stmt);
	}
	return c->errors;
}

void v__checker__Checker_check_files(v__checker__Checker* c, array_v__ast__File ast_files) {
	bool has_main_mod_file = false;
	bool has_main_fn = false;
	array_v__ast__File_ptr files_from_main_module = __new_array_with_default(0, 0, sizeof(v__ast__File*), 0);
	for (int i = 0; i < ast_files.len; ++i) {
		v__ast__File* file = &(*(v__ast__File*)/*ee elem_typ */array_get(ast_files, i));
		v__checker__Checker_check(c, file);
		if (string_eq(file->mod.name, tos_lit("main"))) {
			array_push(&files_from_main_module, _MOV((v__ast__File*[]){ file }));
			has_main_mod_file = true;
			if (v__checker__Checker_check_file_in_main(c, *file)) {
				has_main_fn = true;
			}
		}
	}
	if (has_main_mod_file && !has_main_fn && files_from_main_module.len > 0) {
		if (c->pref->is_script && !c->pref->is_test) {
			v__ast__File* first_main_file = (*(v__ast__File**)/*ee elem_typ */array_get(files_from_main_module, 0));
			array_push(&first_main_file->stmts, _MOV((v__ast__Stmt[]){ /* sum type cast 4 */ (v__ast__Stmt){._151 = memdup(&(v__ast__FnDecl[]){(v__ast__FnDecl){.name = tos_lit("main.main"),.mod = tos_lit("main"),.params = __new_array(0, 1, sizeof(v__table__Param)),.is_deprecated = 0,.is_pub = 0,.is_variadic = 0,.is_anon = 0,.receiver = {0},.receiver_pos = {0},.is_method = 0,.method_idx = 0,.rec_mut = 0,.rec_share = 0,.language = 0,.no_body = 0,.is_builtin = 0,.pos = {0},.body_pos = {0},.file = first_main_file->path,.is_generic = 0,.is_direct_arr = 0,.attrs = __new_array(0, 1, sizeof(v__table__Attr)),.stmts = __new_array(0, 1, sizeof(v__ast__Stmt)),.return_type = _const_v__table__void_type,.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.source_file = 0,}}, sizeof(v__ast__FnDecl)), .typ = 151 /* v.ast.FnDecl */} }));
			has_main_fn = true;
		}
	}
	v__checker__Checker_verify_all_vweb_routes(c);
	if (c->pref->build_mode == v__pref__BuildMode_build_module || c->pref->is_test) {
		return;
	}
	if (c->pref->is_shared) {
		return;
	}
	if (!has_main_mod_file) {
		v__checker__Checker_error(c, tos_lit("project must include a `main` module or be a shared library (compile with `v -shared`)"), (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,});
	} else if (!has_main_fn) {
		v__checker__Checker_error(c, tos_lit("function `main` must be declared in the main module"), (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,});
	}
}

VV_LOCAL_SYMBOL bool v__checker__Checker_check_file_in_main(v__checker__Checker* c, v__ast__File file) {
	bool has_main_fn = false;
	// FOR IN array
	array _t878 = file.stmts;
	for (int _t879 = 0; _t879 < _t878.len; ++_t879) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)_t878.data)[_t879];
		v__ast__Stmt _t880 = stmt;
		if (_t880.typ == 256 /* v.ast.ConstDecl */) {
			if ((*stmt._256).is_pub) {
				v__checker__Checker_warn(c, _STR("const %.*s", 1, _const_v__checker__no_pub_in_main_warning), (*stmt._256).pos);
			}
		} else if (_t880.typ == 258 /* v.ast.EnumDecl */) {
			if ((*stmt._258).is_pub) {
				v__checker__Checker_warn(c, _STR("enum `%.*s\000` %.*s", 2, (*stmt._258).name, _const_v__checker__no_pub_in_main_warning), (*stmt._258).pos);
			}
		} else if (_t880.typ == 151 /* v.ast.FnDecl */) {
			if (string_eq((*stmt._151).name, tos_lit("main.main"))) {
				if (has_main_fn) {
					v__checker__Checker_error(c, tos_lit("function `main` is already defined"), (*stmt._151).pos);
				}
				has_main_fn = true;
				if ((*stmt._151).is_pub) {
					v__checker__Checker_error(c, tos_lit("function `main` cannot be declared public"), (*stmt._151).pos);
				}
				if ((*stmt._151).params.len > 0) {
					v__checker__Checker_error(c, tos_lit("function `main` cannot have arguments"), (*stmt._151).pos);
				}
				if ((*stmt._151).return_type != _const_v__table__void_type) {
					v__checker__Checker_error(c, tos_lit("function `main` cannot return values"), (*stmt._151).pos);
				}
			} else {
				if ((*stmt._151).is_pub && !(*stmt._151).is_method) {
					v__checker__Checker_warn(c, _STR("function `%.*s\000` %.*s", 2, (*stmt._151).name, _const_v__checker__no_pub_in_main_warning), (*stmt._151).pos);
				}
			}
			if ((*stmt._151).return_type != _const_v__table__void_type) {
				// FOR IN array
				array _t881 = (*stmt._151).attrs;
				for (int _t882 = 0; _t882 < _t881.len; ++_t882) {
					v__table__Attr attr = ((v__table__Attr*)_t881.data)[_t882];
					if (attr.is_ctdefine) {
						v__checker__Checker_error(c, _STR("only functions that do NOT return values can have `[if %.*s\000]` tags", 2, attr.name), (*stmt._151).pos);
						break;
					}
				}
			}
		} else if (_t880.typ == 273 /* v.ast.StructDecl */) {
			if ((*stmt._273).is_pub) {
				v__checker__Checker_warn(c, _STR("struct `%.*s\000` %.*s", 2, (*stmt._273).name, _const_v__checker__no_pub_in_main_warning), (*stmt._273).pos);
			}
		} else if (_t880.typ == 207 /* v.ast.TypeDecl */) {
			if (((*stmt._207)).typ == 204 /* v.ast.AliasTypeDecl */) {
				if ((*(*stmt._207)._204).is_pub) {
					v__checker__Checker_warn(c, _STR("type alias `%.*s\000` %.*s", 2, (*(*stmt._207)._204).name, _const_v__checker__no_pub_in_main_warning), (*(*stmt._207)._204).pos);
				}
			} else if (((*stmt._207)).typ == 206 /* v.ast.SumTypeDecl */) {
				if ((*(*stmt._207)._206).is_pub) {
					v__checker__Checker_warn(c, _STR("sum type `%.*s\000` %.*s", 2, (*(*stmt._207)._206).name, _const_v__checker__no_pub_in_main_warning), (*(*stmt._207)._206).pos);
				}
			} else if (((*stmt._207)).typ == 205 /* v.ast.FnTypeDecl */) {
				if ((*(*stmt._207)._205).is_pub) {
					v__checker__Checker_warn(c, _STR("type alias `%.*s\000` %.*s", 2, (*(*stmt._207)._205).name, _const_v__checker__no_pub_in_main_warning), (*(*stmt._207)._205).pos);
				}
			}
		} else {
		};
	}
	return has_main_fn;
}

VV_LOCAL_SYMBOL void v__checker__Checker_check_valid_snake_case(v__checker__Checker* c, string name, string identifier, v__token__Position pos) {
	if (!c->pref->is_vweb && (string_at(name, 0) == '_' || string_contains(name, tos_lit("._")))) {
		v__checker__Checker_error(c, _STR("%.*s\000 `%.*s\000` cannot start with `_`", 3, identifier, name), pos);
	}
	if (!c->pref->experimental && !c->pref->translated && v__util__contains_capital(name)) {
		v__checker__Checker_error(c, _STR("%.*s\000 `%.*s\000` cannot contain uppercase letters, use snake_case instead", 3, identifier, name), pos);
	}
}

VV_LOCAL_SYMBOL string v__checker__stripped_name(string name) {
	Option_int _t883 = string_last_index(name, tos_lit("."));
	if (!_t883.ok) {
		string err = _t883.v_error;
		int errcode = _t883.ecode;
		*(int*) _t883.data = -1;
	}
 	int idx = *(int*) _t883.data;
	return string_substr(name, (idx + 1), name.len);
}

VV_LOCAL_SYMBOL void v__checker__Checker_check_valid_pascal_case(v__checker__Checker* c, string name, string identifier, v__token__Position pos) {
	string sname = v__checker__stripped_name(name);
	if (!byte_is_capital(string_at(sname, 0)) && !c->pref->translated) {
		v__checker__Checker_error(c, _STR("%.*s\000 `%.*s\000` must begin with capital letter", 3, identifier, name), pos);
	}
}

void v__checker__Checker_type_decl(v__checker__Checker* c, v__ast__TypeDecl node) {
	v__ast__TypeDecl _t884 = node;
	if (_t884.typ == 204 /* v.ast.AliasTypeDecl */) {
		if (string_ne(c->file->mod.name, tos_lit("time")) && string_ne(c->file->mod.name, tos_lit("builtin"))) {
			v__checker__Checker_check_valid_pascal_case(c, (*node._204).name, tos_lit("type alias"), (*node._204).pos);
		}
		v__table__TypeSymbol* typ_sym = v__table__Table_get_type_symbol(c->table, (*node._204).parent_type);
		if (typ_sym->kind == v__table__Kind_placeholder) {
			v__checker__Checker_error(c, _STR("type `%.*s\000` doesn't exist", 2, typ_sym->source_name), (*node._204).pos);
		} else if (typ_sym->kind == v__table__Kind_alias) {
			v__table__TypeSymbol* orig_sym = v__table__Table_get_type_symbol(c->table, (/* as */ *(v__table__Alias*)__as_cast((typ_sym->info)._347, (typ_sym->info).typ, /*expected:*/347)).parent_type);
			v__checker__Checker_error(c, _STR("type `%.*s\000` is an alias, use the original alias type `%.*s\000` instead", 3, v__table__TypeSymbol_str(typ_sym), orig_sym->source_name), (*node._204).pos);
		} else if (typ_sym->kind == v__table__Kind_chan) {
			v__checker__Checker_error(c, tos_lit("aliases of `chan` types are not allowed."), (*node._204).pos);
		}
	} else if (_t884.typ == 205 /* v.ast.FnTypeDecl */) {
		v__checker__Checker_check_valid_pascal_case(c, (*node._205).name, tos_lit("fn type"), (*node._205).pos);
		v__table__TypeSymbol* typ_sym = v__table__Table_get_type_symbol(c->table, (*node._205).typ);
		v__table__FnType fn_typ_info = /* as */ *(v__table__FnType*)__as_cast((typ_sym->info)._353, (typ_sym->info).typ, /*expected:*/353);
		v__table__Fn fn_info = fn_typ_info.func;
		v__table__TypeSymbol* ret_sym = v__table__Table_get_type_symbol(c->table, fn_info.return_type);
		if (ret_sym->kind == v__table__Kind_placeholder) {
			v__checker__Checker_error(c, _STR("type `%.*s\000` doesn't exist", 2, ret_sym->source_name), (*node._205).pos);
		}
		// FOR IN array
		array _t885 = fn_info.params;
		for (int _t886 = 0; _t886 < _t885.len; ++_t886) {
			v__table__Param arg = ((v__table__Param*)_t885.data)[_t886];
			v__table__TypeSymbol* arg_sym = v__table__Table_get_type_symbol(c->table, arg.typ);
			if (arg_sym->kind == v__table__Kind_placeholder) {
				v__checker__Checker_error(c, _STR("type `%.*s\000` doesn't exist", 2, arg_sym->source_name), (*node._205).pos);
			}
		}
	} else if (_t884.typ == 206 /* v.ast.SumTypeDecl */) {
		v__checker__Checker_check_valid_pascal_case(c, (*node._206).name, tos_lit("sum type"), (*node._206).pos);
		// FOR IN array
		array _t887 = (*node._206).variants;
		for (int _t888 = 0; _t888 < _t887.len; ++_t888) {
			v__ast__SumTypeVariant variant = ((v__ast__SumTypeVariant*)_t887.data)[_t888];
			if (v__table__Type_is_ptr(variant.typ)) {
				v__checker__Checker_error(c, tos_lit("sum type cannot hold a reference type"), variant.pos);
			}
			v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(c->table, variant.typ);
			if (sym->kind == v__table__Kind_placeholder) {
				v__checker__Checker_error(c, _STR("type `%.*s\000` doesn't exist", 2, sym->source_name), (*node._206).pos);
			} else if (sym->kind == v__table__Kind_interface_) {
				v__checker__Checker_error(c, tos_lit("sum type cannot hold an interface"), (*node._206).pos);
			}
		}
	};
}

void v__checker__Checker_interface_decl(v__checker__Checker* c, v__ast__InterfaceDecl decl) {
	v__checker__Checker_check_valid_pascal_case(c, decl.name, tos_lit("interface name"), decl.pos);
	// FOR IN array
	array _t889 = decl.methods;
	for (int _t890 = 0; _t890 < _t889.len; ++_t890) {
		v__ast__FnDecl method = ((v__ast__FnDecl*)_t889.data)[_t890];
		v__checker__Checker_check_valid_snake_case(c, method.name, tos_lit("method name"), method.pos);
	}
}

void v__checker__Checker_struct_decl(v__checker__Checker* c, v__ast__StructDecl decl) {
	if (decl.language == v__table__Language_v && !c->is_builtin_mod) {
		v__checker__Checker_check_valid_pascal_case(c, decl.name, tos_lit("struct name"), decl.pos);
	}
	Option_v__table__TypeSymbol _t891 = v__table__Table_find_type(c->table, decl.name);
	if (!_t891.ok) {
		string err = _t891.v_error;
		int errcode = _t891.ecode;
		*(v__table__TypeSymbol*) _t891.data = (v__table__TypeSymbol){.parent_idx = 0,.info = {0},.kind = 0,.name = (string){.str=(byteptr)""},.source_name = (string){.str=(byteptr)""},.methods = __new_array(0, 1, sizeof(v__table__Fn)),.mod = (string){.str=(byteptr)""},.is_public = 0,.is_written = 0,.language = 0,};
	}
 	v__table__TypeSymbol struct_sym = *(v__table__TypeSymbol*) _t891.data;
	if ((struct_sym.info).typ == 155 /* v.table.Struct */) {
		// FOR IN array
		array _t892 = decl.fields;
		for (int i = 0; i < _t892.len; ++i) {
			v__ast__StructField field = ((v__ast__StructField*)_t892.data)[i];
			if (decl.language == v__table__Language_v && !field.is_embed) {
				v__checker__Checker_check_valid_snake_case(c, field.name, tos_lit("field name"), field.pos);
			}
			v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(c->table, field.typ);
			if (field.is_embed) {
				if ((sym->info).typ == 155 /* v.table.Struct */) {
					// FOR IN array
					array _t893 = (*sym->info._155).fields;
					for (int _t894 = 0; _t894 < _t893.len; ++_t894) {
						v__table__Field embed_field = ((v__table__Field*)_t893.data)[_t894];

int _t895_len = (*struct_sym.info._155).fields.len;
						array_v__table__Field _t895 = __new_array(0, _t895_len, sizeof(v__table__Field));
						for (int i = 0; i < _t895_len; ++i) {
						  v__table__Field it = ((v__table__Field*) (*struct_sym.info._155).fields.data)[i];
						if (string_eq(it.name, embed_field.name)) array_push(&_t895, &it); 
 }
												bool already_exists =  _t895.len > 0;
						if (!already_exists) {
							array_push(&(*struct_sym.info._155).fields, _MOV((v__table__Field[]){ // assoc
							(v__table__Field){
								.name = embed_field.name,
								.typ = embed_field.typ,
								.default_expr = embed_field.default_expr,
								.has_default_expr = embed_field.has_default_expr,
								.default_val = embed_field.default_val,
								.attrs = embed_field.attrs,
								.is_pub = embed_field.is_pub,
								.is_mut = embed_field.is_mut,
								.is_global = embed_field.is_global,
								.is_embed = embed_field.is_embed,
								.embed_alias_for = field.name, 
							} }));
						}
					}
				} else {
					v__checker__Checker_error(c, _STR("`%.*s\000` is not a struct", 2, sym->name), field.pos);
				}
			}
			for (int j = 0; j < i; ++j) {
				if (string_eq(field.name, (*(v__ast__StructField*)/*ee elem_typ */array_get(decl.fields, j)).name)) {
					v__checker__Checker_error(c, _STR("field name `%.*s\000` duplicate", 2, field.name), field.pos);
				}
			}
			if (sym->kind == v__table__Kind_placeholder && decl.language != v__table__Language_c && !string_starts_with(sym->name, tos_lit("C."))) {
				v__checker__Checker_error(c, v__util__Suggestion_say(v__util__new_suggestion(sym->source_name, v__table__Table_known_type_names(c->table)), _STR("unknown type `%.*s\000`", 2, sym->source_name)), field.type_pos);
			}
			if (sym->kind == v__table__Kind_array) {
				v__table__Array array_info = v__table__TypeSymbol_array_info(sym);
				v__table__TypeSymbol* elem_sym = v__table__Table_get_type_symbol(c->table, array_info.elem_type);
				if (elem_sym->kind == v__table__Kind_placeholder) {
					v__checker__Checker_error(c, v__util__Suggestion_say(v__util__new_suggestion(elem_sym->source_name, v__table__Table_known_type_names(c->table)), _STR("unknown type `%.*s\000`", 2, elem_sym->source_name)), field.type_pos);
				}
			}
			if (sym->kind == v__table__Kind_struct_) {
				v__table__Struct info = /* as */ *(v__table__Struct*)__as_cast((sym->info)._155, (sym->info).typ, /*expected:*/155);
				if (info.is_ref_only && !v__table__Type_is_ptr(field.typ)) {
					v__checker__Checker_error(c, _STR("`%.*s\000` type can only be used as a reference: `&%.*s\000`", 3, sym->source_name, sym->source_name), field.type_pos);
				}
			}
			if (sym->kind == v__table__Kind_map) {
				v__table__Map info = v__table__TypeSymbol_map_info(sym);
				v__table__TypeSymbol* key_sym = v__table__Table_get_type_symbol(c->table, info.key_type);
				v__table__TypeSymbol* value_sym = v__table__Table_get_type_symbol(c->table, info.value_type);
				if (key_sym->kind == v__table__Kind_placeholder) {
					v__checker__Checker_error(c, _STR("unknown type `%.*s\000`", 2, key_sym->source_name), field.type_pos);
				}
				if (value_sym->kind == v__table__Kind_placeholder) {
					v__checker__Checker_error(c, _STR("unknown type `%.*s\000`", 2, value_sym->source_name), field.type_pos);
				}
			}
			if (field.has_default_expr) {
				c->expected_type = field.typ;
				v__table__Type field_expr_type = v__checker__Checker_expr(c, field.default_expr);
				Option_void _t897 = v__checker__Checker_check_expected(c, field_expr_type, field.typ);
				if (!_t897.ok && !_t897.is_none) {
					string err = _t897.v_error;
					int errcode = _t897.ecode;
					v__checker__Checker_error(c, _STR("incompatible initializer for field `%.*s\000`: %.*s", 2, field.name, err), v__ast__Expr_position(field.default_expr));
				};
				if (v__table__Type_is_ptr(field.typ)) {
					continue;
				}
				if ((field.default_expr).typ == 229 /* v.ast.IntegerLiteral */) {
					if (string_eq((*field.default_expr._229).val, tos_lit("0"))) {
						v__checker__Checker_warn(c, tos_lit("unnecessary default value of `0`: struct fields are zeroed by default"), (*field.default_expr._229).pos);
					}
				} else if ((field.default_expr).typ == 245 /* v.ast.StringLiteral */) {
					if (((*field.default_expr._245).val).len == 0) {
						v__checker__Checker_warn(c, tos_lit("unnecessary default value of '': struct fields are zeroed by default"), (*field.default_expr._245).pos);
					}
				} else if ((field.default_expr).typ == 213 /* v.ast.BoolLiteral */) {
					if ((*field.default_expr._213).val == false) {
						v__checker__Checker_warn(c, tos_lit("unnecessary default value `false`: struct fields are zeroed by default"), (*field.default_expr._213).pos);
					}
				}
			}
		}
	}
}

v__table__Type v__checker__Checker_struct_init(v__checker__Checker* c, v__ast__StructInit* struct_init) {
	if (struct_init->typ == _const_v__table__void_type) {
		if (c->expected_type == _const_v__table__void_type) {
			v__checker__Checker_error(c, tos_lit("unexpected short struct syntax"), struct_init->pos);
			return _const_v__table__void_type;
		}
		struct_init->typ = c->expected_type;
	}
	if (struct_init->typ == 0) {
		v__checker__Checker_error(c, tos_lit("unknown type"), struct_init->pos);
	}
	v__table__TypeSymbol* type_sym = v__table__Table_get_type_symbol(c->table, struct_init->typ);
	if (type_sym->kind == v__table__Kind_sum_type && struct_init->fields.len == 1) {
		string sexpr = v__ast__Expr_str((*(v__ast__StructInitField*)/*ee elem_typ */array_get(struct_init->fields, 0)).expr);
		v__checker__Checker_error(c, _STR("cast to sum type using `%.*s\000(%.*s\000)` not `%.*s\000{%.*s\000}`", 5, type_sym->source_name, sexpr, type_sym->source_name, sexpr), struct_init->pos);
	}
	if (type_sym->kind == v__table__Kind_interface_) {
		v__checker__Checker_error(c, _STR("cannot instantiate interface `%.*s\000`", 2, type_sym->source_name), struct_init->pos);
	}
	if (type_sym->kind == v__table__Kind_alias) {
		v__table__Alias info = /* as */ *(v__table__Alias*)__as_cast((type_sym->info)._347, (type_sym->info).typ, /*expected:*/347);
		if (v__table__Type_is_number(info.parent_type)) {
			v__checker__Checker_error(c, _STR("cannot instantiate number type alias `%.*s\000`", 2, type_sym->source_name), struct_init->pos);
			return _const_v__table__void_type;
		}
	}
	if (!type_sym->is_public && type_sym->kind != v__table__Kind_placeholder && string_ne(type_sym->mod, c->mod) && type_sym->language != v__table__Language_c) {
		v__checker__Checker_error(c, _STR("type `%.*s\000` is private", 2, type_sym->source_name), struct_init->pos);
	}
	v__table__Kind _t898 = type_sym->kind;
	if (_t898 == v__table__Kind_placeholder) {
		v__checker__Checker_error(c, _STR("unknown struct: %.*s", 1, type_sym->source_name), struct_init->pos);
	} else if (_t898 == v__table__Kind_struct_ || _t898 == v__table__Kind_string || _t898 == v__table__Kind_array || _t898 == v__table__Kind_alias) {
		v__table__Struct info = (v__table__Struct){.fields = __new_array(0, 1, sizeof(v__table__Field)),.is_typedef = 0,.is_union = 0,.is_ref_only = 0,.generic_types = __new_array(0, 1, sizeof(v__table__Type)),};
		if (type_sym->kind == v__table__Kind_alias) {
			v__table__Alias info_t = /* as */ *(v__table__Alias*)__as_cast((type_sym->info)._347, (type_sym->info).typ, /*expected:*/347);
			v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(c->table, info_t.parent_type);
			if (sym->kind == v__table__Kind_placeholder) {
				v__checker__Checker_error(c, _STR("unknown struct: %.*s", 1, type_sym->source_name), struct_init->pos);
				return _const_v__table__void_type;
			}
			if (sym->kind != v__table__Kind_struct_) {
				v__checker__Checker_error(c, _STR("alias type name: %.*s\000 is not struct type", 2, sym->source_name), struct_init->pos);
			}
			info = /* as */ *(v__table__Struct*)__as_cast((sym->info)._155, (sym->info).typ, /*expected:*/155);
		} else {
			info = /* as */ *(v__table__Struct*)__as_cast((type_sym->info)._155, (type_sym->info).typ, /*expected:*/155);
		}
		if (struct_init->is_short) {
			int exp_len = info.fields.len;
			int got_len = struct_init->fields.len;
			if (exp_len != got_len) {
				string amount = (exp_len < got_len ? (tos_lit("many")) : (tos_lit("few")));
				v__checker__Checker_error(c, _STR("too %.*s\000 fields in `%.*s\000` literal (expecting %"PRId32"\000, got %"PRId32"\000)", 5, amount, type_sym->source_name, exp_len, got_len), struct_init->pos);
			}
		}
		array_string inited_fields = __new_array_with_default(0, 0, sizeof(string), 0);
		// FOR IN array
		array _t899 = struct_init->fields;
		for (int i = 0; i < _t899.len; ++i) {
			v__ast__StructInitField field = ((v__ast__StructInitField*)_t899.data)[i];
			v__table__Field info_field = (v__table__Field){.name = (string){.str=(byteptr)""},.typ = 0,.default_expr = {0},.has_default_expr = 0,.default_val = (string){.str=(byteptr)""},.attrs = __new_array(0, 1, sizeof(v__table__Attr)),.is_pub = 0,.is_mut = 0,.is_global = 0,.is_embed = 0,.embed_alias_for = (string){.str=(byteptr)""},};
			string field_name = tos_lit("");
			if (struct_init->is_short) {
				if (i >= info.fields.len) {
					break;
				}
				info_field = (*(v__table__Field*)/*ee elem_typ */array_get(info.fields, i));
				field_name = info_field.name;
				(*(v__ast__StructInitField*)/*ee elem_typ */array_get(struct_init->fields, i)).name = field_name;
			} else {
				field_name = field.name;
				bool exists = false;
				// FOR IN array
				array _t900 = info.fields;
				for (int _t901 = 0; _t901 < _t900.len; ++_t901) {
					v__table__Field f = ((v__table__Field*)_t900.data)[_t901];
					if (string_eq(f.name, field_name)) {
						info_field = f;
						exists = true;
						break;
					}
				}
				if (!exists) {
					v__checker__Checker_error(c, _STR("unknown field `%.*s\000` in struct literal of type `%.*s\000`", 3, field.name, type_sym->source_name), field.pos);
					continue;
				}
				if (_IN(string, field_name, inited_fields)) {
					v__checker__Checker_error(c, _STR("duplicate field name in struct literal: `%.*s\000`", 2, field_name), field.pos);
					continue;
				}
			}
			array_push(&inited_fields, _MOV((string[]){ string_clone(field_name) }));
			c->expected_type = info_field.typ;
			v__table__Type expr_type = v__checker__Checker_expr(c, field.expr);
			v__table__TypeSymbol* expr_type_sym = v__table__Table_get_type_symbol(c->table, expr_type);
			if (expr_type != _const_v__table__void_type && expr_type_sym->kind != v__table__Kind_placeholder) {
				Option_void _t903 = v__checker__Checker_check_expected(c, expr_type, info_field.typ);
				if (!_t903.ok && !_t903.is_none) {
					string err = _t903.v_error;
					int errcode = _t903.ecode;
					v__checker__Checker_error(c, _STR("cannot assign to field `%.*s\000`: %.*s", 2, info_field.name, err), field.pos);
				};
			}
			if (v__table__Type_is_ptr(info_field.typ) && !v__table__Type_is_ptr(expr_type) && !v__table__Type_is_pointer(expr_type) && !v__table__Type_is_number(expr_type)) {
				v__checker__Checker_error(c, tos_lit("ref"), field.pos);
			}
			(*(v__ast__StructInitField*)/*ee elem_typ */array_get(struct_init->fields, i)).typ = expr_type;
			(*(v__ast__StructInitField*)/*ee elem_typ */array_get(struct_init->fields, i)).expected_type = info_field.typ;
		}
		// FOR IN array
		array _t904 = info.fields;
		for (int _t905 = 0; _t905 < _t904.len; ++_t905) {
			v__table__Field field = ((v__table__Field*)_t904.data)[_t905];
			if (field.has_default_expr || _IN(string, field.name, inited_fields) || (field.embed_alias_for).len != 0) {
				continue;
			}
			if (v__table__Type_is_ptr(field.typ) && !c->pref->translated) {
				v__checker__Checker_warn(c, _STR("reference field `%.*s\000.%.*s\000` must be initialized", 3, type_sym->source_name, field.name), struct_init->pos);
			}
			if (array_v__table__Attr_contains(field.attrs, tos_lit("required")) && !struct_init->is_short) {
				bool found = false;
				// FOR IN array
				array _t906 = struct_init->fields;
				for (int _t907 = 0; _t907 < _t906.len; ++_t907) {
					v__ast__StructInitField init_field = ((v__ast__StructInitField*)_t906.data)[_t907];
					if (string_eq(field.name, init_field.name)) {
						found = true;
						break;
					}
				}
				if (!found) {
					v__checker__Checker_error(c, _STR("field `%.*s\000.%.*s\000` must be initialized", 3, type_sym->source_name, field.name), struct_init->pos);
				}
			}
		}
	} else {
	};
	return struct_init->typ;
}

v__table__Type v__checker__Checker_infix_expr(v__checker__Checker* c, v__ast__InfixExpr* infix_expr) {
	v__table__Type former_expected_type = c->expected_type;
	c->expected_type = _const_v__table__void_type;
	v__table__Type left_type = v__checker__Checker_expr(c, infix_expr->left);
	infix_expr->left_type = left_type;
	c->expected_type = left_type;
	v__table__Type right_type = v__checker__Checker_expr(c, infix_expr->right);
	infix_expr->right_type = right_type;
	v__table__TypeSymbol* right = v__table__Table_get_type_symbol(c->table, right_type);
	v__table__TypeSymbol* left = v__table__Table_get_type_symbol(c->table, left_type);
	v__token__Position left_pos = v__ast__Expr_position(infix_expr->left);
	v__token__Position right_pos = v__ast__Expr_position(infix_expr->right);
	if ((v__table__Type_is_ptr(left_type) || v__table__TypeSymbol_is_pointer(left)) && (infix_expr->op == v__token__Kind_plus || infix_expr->op == v__token__Kind_minus) && !c->inside_unsafe) {
		v__checker__Checker_warn(c, tos_lit("pointer arithmetic is only allowed in `unsafe` blocks"), left_pos);
	}
	v__table__Type return_type = left_type;
	if (infix_expr->op != v__token__Kind_key_is) {
		v__ast__Expr _t908 = infix_expr->left;
		if (_t908.typ == 224 /* v.ast.Ident */) {
			if ((*infix_expr->left._224).is_mut) {
				v__checker__Checker_error(c, tos_lit("remove unnecessary `mut`"), (*infix_expr->left._224).mut_pos);
			}
		} else if (_t908.typ == 241 /* v.ast.SelectorExpr */) {
			if ((*infix_expr->left._241).is_mut) {
				v__checker__Checker_error(c, tos_lit("remove unnecessary `mut`"), (*infix_expr->left._241).mut_pos);
			}
		} else {
		};
	}
	v__token__Kind _t909 = infix_expr->op;
	if (_t909 == v__token__Kind_eq || _t909 == v__token__Kind_ne) {
		bool is_alias_eq_struct = left->kind == v__table__Kind_alias && right->kind == v__table__Kind_struct_;
		bool is_struct_eq_alias = left->kind == v__table__Kind_struct_ && right->kind == v__table__Kind_alias;
		if (is_alias_eq_struct || is_struct_eq_alias) {
			v__checker__Checker_error(c, _STR("possible type mismatch of compared values of `%.*s\000` operation", 2, v__token__Kind_str(infix_expr->op)), infix_expr->pos);
		}
	} else if (_t909 == v__token__Kind_key_in || _t909 == v__token__Kind_not_in) {
		v__table__Kind _t910 = right->kind;
		if (_t910 == v__table__Kind_array) {
			v__table__Type elem_type = v__table__TypeSymbol_array_info(right).elem_type;
			Option_void _t911 = v__checker__Checker_check_expected(c, left_type, elem_type);
			if (!_t911.ok && !_t911.is_none) {
				string err = _t911.v_error;
				int errcode = _t911.ecode;
				v__checker__Checker_error(c, _STR("left operand to `%.*s\000` does not match the array element type: %.*s", 2, v__token__Kind_str(infix_expr->op), err), infix_expr->pos);
			};
		} else if (_t910 == v__table__Kind_map) {
			v__table__Type elem_type = v__table__TypeSymbol_map_info(right).key_type;
			Option_void _t912 = v__checker__Checker_check_expected(c, left_type, elem_type);
			if (!_t912.ok && !_t912.is_none) {
				string err = _t912.v_error;
				int errcode = _t912.ecode;
				v__checker__Checker_error(c, _STR("left operand to `%.*s\000` does not match the map key type: %.*s", 2, v__token__Kind_str(infix_expr->op), err), infix_expr->pos);
			};
		} else if (_t910 == v__table__Kind_string) {
			Option_void _t913 = v__checker__Checker_check_expected(c, left_type, right_type);
			if (!_t913.ok && !_t913.is_none) {
				string err = _t913.v_error;
				int errcode = _t913.ecode;
				v__checker__Checker_error(c, _STR("left operand to `%.*s\000` does not match: %.*s", 2, v__token__Kind_str(infix_expr->op), err), infix_expr->pos);
			};
		} else {
			v__checker__Checker_error(c, _STR("`%.*s\000` can only be used with an array/map/string", 2, v__token__Kind_str(infix_expr->op)), infix_expr->pos);
		};
		// Defer begin
		c->expected_type = former_expected_type;
		// Defer end
		return _const_v__table__bool_type;
	} else if (_t909 == v__token__Kind_plus || _t909 == v__token__Kind_minus || _t909 == v__token__Kind_mul || _t909 == v__token__Kind_div || _t909 == v__token__Kind_mod || _t909 == v__token__Kind_xor || _t909 == v__token__Kind_amp || _t909 == v__token__Kind_pipe) {
		if ((right->info).typ == 347 /* v.table.Alias */ && (/* as */ *(v__table__Alias*)__as_cast((right->info)._347, (right->info).typ, /*expected:*/347)).language != v__table__Language_c && string_eq(c->mod, (*(string*)/*ee elem_typ */array_get(string_split(v__table__Table_type_to_str(c->table, right_type), tos_lit(".")), 0)))) {
			right = v__table__Table_get_type_symbol(c->table, (/* as */ *(v__table__Alias*)__as_cast((right->info)._347, (right->info).typ, /*expected:*/347)).parent_type);
		}
		if ((left->info).typ == 347 /* v.table.Alias */ && (/* as */ *(v__table__Alias*)__as_cast((left->info)._347, (left->info).typ, /*expected:*/347)).language != v__table__Language_c && string_eq(c->mod, (*(string*)/*ee elem_typ */array_get(string_split(v__table__Table_type_to_str(c->table, left_type), tos_lit(".")), 0)))) {
			left = v__table__Table_get_type_symbol(c->table, (/* as */ *(v__table__Alias*)__as_cast((left->info)._347, (left->info).typ, /*expected:*/347)).parent_type);
		}
		if ((left->kind == v__table__Kind_array || left->kind == v__table__Kind_array_fixed || left->kind == v__table__Kind_map || left->kind == v__table__Kind_struct_)) {
			if (v__table__TypeSymbol_has_method(left, v__token__Kind_str(infix_expr->op))) {
				{ /* if guard */ 
				Option_v__table__Fn _t914;
				if (_t914 = v__table__TypeSymbol_find_method(left, v__token__Kind_str(infix_expr->op)), _t914.ok) {
					v__table__Fn method = *(v__table__Fn*)_t914.data;
					return_type = method.return_type;
				} else {
					string err = _t914.v_error;
					int errcode = _t914.ecode;
					return_type = left_type;
				}}
			} else {
				string left_name = v__table__Table_type_to_str(c->table, left_type);
				string right_name = v__table__Table_type_to_str(c->table, right_type);
				if (string_eq(left_name, right_name)) {
					v__checker__Checker_error(c, _STR("operation `%.*s\000` %.*s\000 `%.*s\000` does not exist, please define it", 4, left_name, v__token__Kind_str(infix_expr->op), right_name), left_pos);
				} else {
					v__checker__Checker_error(c, _STR("mismatched types `%.*s\000` and `%.*s\000`", 3, left_name, right_name), left_pos);
				}
			}
		} else if ((right->kind == v__table__Kind_array || right->kind == v__table__Kind_array_fixed || right->kind == v__table__Kind_map || right->kind == v__table__Kind_struct_)) {
			if (v__table__TypeSymbol_has_method(right, v__token__Kind_str(infix_expr->op))) {
				{ /* if guard */ 
				Option_v__table__Fn _t915;
				if (_t915 = v__table__TypeSymbol_find_method(right, v__token__Kind_str(infix_expr->op)), _t915.ok) {
					v__table__Fn method = *(v__table__Fn*)_t915.data;
					return_type = method.return_type;
				} else {
					string err = _t915.v_error;
					int errcode = _t915.ecode;
					return_type = right_type;
				}}
			} else {
				string left_name = v__table__Table_type_to_str(c->table, left_type);
				string right_name = v__table__Table_type_to_str(c->table, right_type);
				if (string_eq(left_name, right_name)) {
					v__checker__Checker_error(c, _STR("operation `%.*s\000` %.*s\000 `%.*s\000` does not exist, please define it", 4, left_name, v__token__Kind_str(infix_expr->op), right_name), right_pos);
				} else {
					v__checker__Checker_error(c, _STR("mismatched types `%.*s\000` and `%.*s\000`", 3, left_name, right_name), right_pos);
				}
			}
		} else {
			v__table__Type promoted_type = v__checker__Checker_promote(c, v__table__Table_unalias_num_type(c->table, left_type), v__table__Table_unalias_num_type(c->table, right_type));
			if (v__table__Type_idx(promoted_type) == _const_v__table__void_type_idx) {
				string left_name = v__table__Table_type_to_str(c->table, left_type);
				string right_name = v__table__Table_type_to_str(c->table, right_type);
				v__checker__Checker_error(c, _STR("mismatched types `%.*s\000` and `%.*s\000`", 3, left_name, right_name), infix_expr->pos);
			} else if (v__table__Type_has_flag(promoted_type, v__table__TypeFlag_optional)) {
				string s = v__table__Table_type_to_str(c->table, promoted_type);
				v__checker__Checker_error(c, _STR("`%.*s\000` cannot be used with `%.*s\000`", 3, v__token__Kind_str(infix_expr->op), s), infix_expr->pos);
			} else if (v__table__Type_is_float(promoted_type)) {
				if ((infix_expr->op == v__token__Kind_mod || infix_expr->op == v__token__Kind_xor || infix_expr->op == v__token__Kind_amp || infix_expr->op == v__token__Kind_pipe)) {
					string side = (left_type == promoted_type ? (tos_lit("left")) : (tos_lit("right")));
					v__token__Position pos = (left_type == promoted_type ? (left_pos) : (right_pos));
					string name = (left_type == promoted_type ? (left->name) : (right->name));
					if (infix_expr->op == v__token__Kind_mod) {
						v__checker__Checker_error(c, tos_lit("float modulo not allowed, use math.fmod() instead"), pos);
					} else {
						v__checker__Checker_error(c, _STR("%.*s\000 type of `%.*s\000` cannot be non-integer type %.*s", 3, side, v__token__Kind_str(infix_expr->op), name), pos);
					}
				}
			}
			if ((infix_expr->op == v__token__Kind_div || infix_expr->op == v__token__Kind_mod)) {
				v__ast__Expr _t916 = infix_expr->right;
				if (_t916.typ == 223 /* v.ast.FloatLiteral */) {
					if (string_f64((*infix_expr->right._223).val) == 0.0) {
						string oper = (infix_expr->op == v__token__Kind_div ? (tos_lit("division")) : (tos_lit("modulo")));
						v__checker__Checker_error(c, _STR("%.*s\000 by zero", 2, oper), (*infix_expr->right._223).pos);
					}
				} else if (_t916.typ == 229 /* v.ast.IntegerLiteral */) {
					if (string_int((*infix_expr->right._229).val) == 0) {
						string oper = (infix_expr->op == v__token__Kind_div ? (tos_lit("division")) : (tos_lit("modulo")));
						v__checker__Checker_error(c, _STR("%.*s\000 by zero", 2, oper), (*infix_expr->right._229).pos);
					}
				} else {
				};
			}
			return_type = promoted_type;
		}
	} else if (_t909 == v__token__Kind_gt || _t909 == v__token__Kind_lt || _t909 == v__token__Kind_ge || _t909 == v__token__Kind_le) {
		if ((left->kind == v__table__Kind_array || left->kind == v__table__Kind_array_fixed) && (right->kind == v__table__Kind_array || right->kind == v__table__Kind_array_fixed)) {
			v__checker__Checker_error(c, tos_lit("only `==` and `!=` are defined on arrays"), infix_expr->pos);
		}
	} else if (_t909 == v__token__Kind_left_shift) {
		if (left->kind == v__table__Kind_array) {
			multi_return_string_v__token__Position mr_26097 = v__checker__Checker_fail_if_immutable(c, infix_expr->left);
			infix_expr->auto_locked = mr_26097.arg0;
			v__table__Type left_value_type = v__table__Table_value_type(c->table, left_type);
			v__table__TypeSymbol* left_value_sym = v__table__Table_get_type_symbol(c->table, left_value_type);
			if (left_value_sym->kind == v__table__Kind_interface_) {
				if (right->kind != v__table__Kind_array) {
					v__checker__Checker_type_implements(c, right_type, left_value_type, right_pos);
				} else {
					v__checker__Checker_type_implements(c, v__table__Table_value_type(c->table, right_type), left_value_type, right_pos);
				}
				// Defer begin
				c->expected_type = former_expected_type;
				// Defer end
				return _const_v__table__void_type;
			}
			if (v__checker__Checker_check_types(c, right_type, left_value_type)) {
				// Defer begin
				c->expected_type = former_expected_type;
				// Defer end
				return _const_v__table__void_type;
			}
			if (right->kind == v__table__Kind_array && v__checker__Checker_check_types(c, left_value_type, v__table__Table_value_type(c->table, right_type))) {
				// Defer begin
				c->expected_type = former_expected_type;
				// Defer end
				return _const_v__table__void_type;
			}
			v__checker__Checker_error(c, _STR("cannot append `%.*s\000` to `%.*s\000`", 3, right->source_name, left->source_name), right_pos);
			// Defer begin
			c->expected_type = former_expected_type;
			// Defer end
			return _const_v__table__void_type;
		} else {
			// Defer begin
			c->expected_type = former_expected_type;
			// Defer end
			return v__checker__Checker_check_shift(c, left_type, right_type, left_pos, right_pos);
		}
	} else if (_t909 == v__token__Kind_right_shift) {
		// Defer begin
		c->expected_type = former_expected_type;
		// Defer end
		return v__checker__Checker_check_shift(c, left_type, right_type, left_pos, right_pos);
	} else if (_t909 == v__token__Kind_key_is || _t909 == v__token__Kind_not_is) {
		v__ast__Type type_expr = /* as */ *(v__ast__Type*)__as_cast((infix_expr->right)._247, (infix_expr->right).typ, /*expected:*/247);
		v__table__TypeSymbol* typ_sym = v__table__Table_get_type_symbol(c->table, type_expr.typ);
		if (typ_sym->kind == v__table__Kind_placeholder) {
			v__checker__Checker_error(c, _STR("%.*s\000: type `%.*s\000` does not exist", 3, v__token__Kind_str(infix_expr->op), typ_sym->source_name), type_expr.pos);
		}
		if (!(left->kind == v__table__Kind_interface_ || left->kind == v__table__Kind_sum_type)) {
			v__checker__Checker_error(c, _STR("`%.*s\000` can only be used with interfaces and sum types", 2, v__token__Kind_str(infix_expr->op)), infix_expr->pos);
		} else if ((left->info).typ == 354 /* v.table.SumType */) {
			if (!_IN(v__table__Type, type_expr.typ, (*left->info._354).variants)) {
				v__checker__Checker_error(c, _STR("`%.*s\000` has no variant `%.*s\000`", 3, left->source_name, right->source_name), infix_expr->pos);
			}
		}
		// Defer begin
		c->expected_type = former_expected_type;
		// Defer end
		return _const_v__table__bool_type;
	} else if (_t909 == v__token__Kind_arrow) {
		if (left->kind == v__table__Kind_chan) {
			v__table__Chan chan_info = v__table__TypeSymbol_chan_info(left);
			v__table__Type elem_type = chan_info.elem_type;
			if (!v__checker__Checker_check_types(c, right_type, elem_type)) {
				v__checker__Checker_error(c, _STR("cannot push `%.*s\000` on `%.*s\000`", 3, right->name, left->name), right_pos);
			}
			if (chan_info.is_mut) {
				v__checker__Checker_fail_if_immutable(c, infix_expr->right);
			}
			if (v__table__Type_is_ptr(elem_type) && !v__table__Type_is_ptr(right_type)) {
				v__checker__Checker_error(c, _STR("cannot push non-reference `%.*s\000` on `%.*s\000`", 3, right->source_name, left->source_name), right_pos);
			}
		} else {
			v__checker__Checker_error(c, _STR("cannot push on non-channel `%.*s\000`", 2, left->name), left_pos);
		}
		// Defer begin
		c->expected_type = former_expected_type;
		// Defer end
		return _const_v__table__void_type;
	} else if (_t909 == v__token__Kind_and || _t909 == v__token__Kind_logical_or) {
		if (infix_expr->left_type != _const_v__table__bool_type_idx) {
			v__checker__Checker_error(c, _STR("left operand for `%.*s\000` is not a boolean", 2, v__token__Kind_str(infix_expr->op)), v__ast__Expr_position(infix_expr->left));
		}
		if (infix_expr->right_type != _const_v__table__bool_type_idx) {
			v__checker__Checker_error(c, _STR("right operand for `%.*s\000` is not a boolean", 2, v__token__Kind_str(infix_expr->op)), v__ast__Expr_position(infix_expr->right));
		}
		if ((infix_expr->left).typ == 228 /* v.ast.InfixExpr */) {
			if ((*infix_expr->left._228).op != infix_expr->op && ((*infix_expr->left._228).op == v__token__Kind_logical_or || (*infix_expr->left._228).op == v__token__Kind_and)) {
				v__checker__Checker_error(c, tos_lit("use `()` to make the boolean expression clear"), infix_expr->pos);
			}
		}
	} else {
	};
	if (left_type == _const_v__table__bool_type && !(infix_expr->op == v__token__Kind_eq || infix_expr->op == v__token__Kind_ne || infix_expr->op == v__token__Kind_logical_or || infix_expr->op == v__token__Kind_and)) {
		v__checker__Checker_error(c, tos_lit("bool types only have the following operators defined: `==`, `!=`, `||`, and `&&`"), infix_expr->pos);
	} else if (left_type == _const_v__table__string_type && !(infix_expr->op == v__token__Kind_plus || infix_expr->op == v__token__Kind_eq || infix_expr->op == v__token__Kind_ne || infix_expr->op == v__token__Kind_lt || infix_expr->op == v__token__Kind_gt || infix_expr->op == v__token__Kind_le || infix_expr->op == v__token__Kind_ge)) {
		v__checker__Checker_error(c, tos_lit("string types only have the following operators defined: `==`, `!=`, `<`, `>`, `<=`, `>=`, and `+`"), infix_expr->pos);
	}
	if (v__table__Table_type_kind(c->table, left_type) == v__table__Kind_sum_type) {
		v__checker__Checker_error(c, _STR("cannot use operator `%.*s\000` with `%.*s\000`", 3, v__token__Kind_str(infix_expr->op), left->name), infix_expr->pos);
	} else if (v__table__Table_type_kind(c->table, right_type) == v__table__Kind_sum_type) {
		v__checker__Checker_error(c, _STR("cannot use operator `%.*s\000` with `%.*s\000`", 3, v__token__Kind_str(infix_expr->op), right->name), infix_expr->pos);
	}
	if (!v__checker__Checker_symmetric_check(c, right_type, left_type) && !c->pref->translated) {
		if (left_type == _const_v__table__void_type || right_type == _const_v__table__void_type) {
			// Defer begin
			c->expected_type = former_expected_type;
			// Defer end
			return _const_v__table__void_type;
		}
		v__checker__Checker_error(c, _STR("infix expr: cannot use `%.*s\000` (right expression) as `%.*s\000`", 3, right->name, left->name), infix_expr->pos);
	}
	// Defer begin
	c->expected_type = former_expected_type;
	// Defer end
	return (v__token__Kind_is_relational(infix_expr->op) ? (_const_v__table__bool_type) : (return_type));
}

VV_LOCAL_SYMBOL multi_return_string_v__token__Position v__checker__Checker_fail_if_immutable(v__checker__Checker* c, v__ast__Expr expr) {
	string to_lock = tos_lit("");
	v__token__Position pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,};
	bool explicit_lock_needed = false;
	v__ast__Expr _t917 = expr;
	if (_t917.typ == 216 /* v.ast.CastExpr */) {
		return (multi_return_string_v__token__Position){.arg0=tos_lit(""), .arg1=pos};
	} else if (_t917.typ == 224 /* v.ast.Ident */) {
		if (((*expr._224).obj).typ == 277 /* v.ast.Var */) {
			v__ast__Var v = /* as */ *(v__ast__Var*)__as_cast(((*expr._224).obj)._277, ((*expr._224).obj).typ, /*expected:*/277);
			if (!v.is_mut && !c->pref->translated && !c->inside_unsafe) {
				v__checker__Checker_error(c, _STR("`%.*s\000` is immutable, declare it with `mut` to make it mutable", 2, (*expr._224).name), (*expr._224).pos);
			}
			v.is_changed = true;
			if (v__table__Type_share(v.typ) == v__table__ShareType_shared_t) {
				if (!_IN(string, (*expr._224).name, c->locked_names)) {
					to_lock = (*expr._224).name;
					pos = (*expr._224).pos;
				}
			}
		} else if (_IN(string, (*expr._224).name, c->const_names)) {
			v__checker__Checker_error(c, _STR("cannot modify constant `%.*s\000`", 2, (*expr._224).name), (*expr._224).pos);
		}
	} else if (_t917.typ == 227 /* v.ast.IndexExpr */) {
		multi_return_string_v__token__Position mr_31813 = v__checker__Checker_fail_if_immutable(c, (*expr._227).left);
		to_lock = mr_31813.arg0;
		pos = mr_31813.arg1;
	} else if (_t917.typ == 236 /* v.ast.ParExpr */) {
		multi_return_string_v__token__Position mr_31882 = v__checker__Checker_fail_if_immutable(c, (*expr._236).expr);
		to_lock = mr_31882.arg0;
		pos = mr_31882.arg1;
	} else if (_t917.typ == 238 /* v.ast.PrefixExpr */) {
		multi_return_string_v__token__Position mr_31954 = v__checker__Checker_fail_if_immutable(c, (*expr._238).right);
		to_lock = mr_31954.arg0;
		pos = mr_31954.arg1;
	} else if (_t917.typ == 241 /* v.ast.SelectorExpr */) {
		if ((*expr._241).expr_type == 0) {
			v__checker__Checker_error(c, tos_lit("0 type in SelectorExpr"), (*expr._241).pos);
			return (multi_return_string_v__token__Position){.arg0=tos_lit(""), .arg1=pos};
		}
		v__table__TypeSymbol* typ_sym = v__table__Table_get_type_symbol(c->table, v__checker__Checker_unwrap_generic(c, (*expr._241).expr_type));
		if ((typ_sym->info).typ == 347 /* v.table.Alias */) {
			typ_sym = v__table__Table_get_type_symbol(c->table, (*typ_sym->info._347).parent_type);
		}
		v__table__Kind _t918 = typ_sym->kind;
		if (_t918 == v__table__Kind_struct_) {
			v__table__Struct struct_info = /* as */ *(v__table__Struct*)__as_cast((typ_sym->info)._155, (typ_sym->info).typ, /*expected:*/155);
			Option_v__table__Field _t919 = v__table__Struct_find_field(struct_info, (*expr._241).field_name);
			if (!_t919.ok) {
				string err = _t919.v_error;
				int errcode = _t919.ecode;
				string type_str = v__table__Table_type_to_str(c->table, (*expr._241).expr_type);
				v__checker__Checker_error(c, _STR("unknown field `%.*s\000.%.*s\000`", 3, type_str, (*expr._241).field_name), (*expr._241).pos);
				return (multi_return_string_v__token__Position){.arg0=tos_lit(""), .arg1=pos};
			}
 			v__table__Field field_info = *(v__table__Field*) _t919.data;
			if (!field_info.is_mut && !c->pref->translated) {
				string type_str = v__table__Table_type_to_str(c->table, (*expr._241).expr_type);
				v__checker__Checker_error(c, _STR("field `%.*s\000` of struct `%.*s\000` is immutable", 3, (*expr._241).field_name, type_str), (*expr._241).pos);
			}
			multi_return_string_v__token__Position mr_32855 = v__checker__Checker_fail_if_immutable(c, (*expr._241).expr);
			to_lock = mr_32855.arg0;
			pos = mr_32855.arg1;
			if ((to_lock).len != 0) {
				explicit_lock_needed = true;
			}
		} else if (_t918 == v__table__Kind_array || _t918 == v__table__Kind_string) {
			if (!(string_eq(c->file->mod.name, tos_lit("builtin")) || string_eq(c->file->mod.name, tos_lit("crypto.rand")))) {
				v__checker__Checker_error(c, _STR("`%.*s\000` can not be modified", 2, v__table__Kind_str(typ_sym->kind)), (*expr._241).pos);
			}
		} else {
			v__checker__Checker_error(c, _STR("unexpected symbol `%.*s\000`", 2, v__table__Kind_str(typ_sym->kind)), (*expr._241).pos);
		};
	} else if (_t917.typ == 215 /* v.ast.CallExpr */) {
		if (string_eq((*expr._215).name, tos_lit("slice"))) {
			multi_return_string_v__token__Position mr_33557 = v__checker__Checker_fail_if_immutable(c, (*expr._215).left);
			to_lock = mr_33557.arg0;
			pos = mr_33557.arg1;
			if ((to_lock).len != 0) {
				explicit_lock_needed = true;
			}
		} else {
			v__checker__Checker_error(c, tos_lit("cannot use function call as mut"), (*expr._215).pos);
		}
	} else if (_t917.typ == 209 /* v.ast.ArrayInit */) {
		return (multi_return_string_v__token__Position){.arg0=tos_lit(""), .arg1=pos};
	} else {
		v__checker__Checker_error(c, _STR("unexpected expression `%.*s\000`", 2, tos3( /* v.ast.Expr */ v_typeof_sumtype_250( (expr).typ ))), v__ast__Expr_position(expr));
	};
	if (explicit_lock_needed) {
		v__checker__Checker_error(c, _STR("`%.*s\000` is `shared` and needs explicit lock for `%.*s\000`", 3, to_lock, tos3( /* v.ast.Expr */ v_typeof_sumtype_250( (expr).typ ))), pos);
		to_lock = tos_lit("");
	}
	return (multi_return_string_v__token__Position){.arg0=to_lock, .arg1=pos};
}

v__table__Type v__checker__Checker_call_expr(v__checker__Checker* c, v__ast__CallExpr* call_expr) {
	v__checker__Checker_stmts(c, call_expr->or_block.stmts);
	v__table__Type typ = (call_expr->is_method ? (v__checker__Checker_call_method(c, call_expr)) : (v__checker__Checker_call_fn(c, call_expr)));
	bool free_tmp_arg_vars = c->pref->autofree && !c->is_builtin_mod && call_expr->args.len > 0 && !v__table__Type_has_flag((*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr->args, 0)).typ, v__table__TypeFlag_optional);
	if (free_tmp_arg_vars && !c->inside_const) {
		// FOR IN array
		array _t920 = call_expr->args;
		for (int i = 0; i < _t920.len; ++i) {
			v__ast__CallArg arg = ((v__ast__CallArg*)_t920.data)[i];
			if (arg.typ != _const_v__table__string_type) {
				continue;
			}
			if ((arg.expr).typ == 224 /* v.ast.Ident */ || (arg.expr).typ == 245 /* v.ast.StringLiteral */ || (arg.expr).typ == 241 /* v.ast.SelectorExpr */) {
				continue;
			}
			(*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr->args, i)).is_tmp_autofree = true;
		}
		if (call_expr->receiver_type == _const_v__table__string_type && !((call_expr->left).typ == 224 /* v.ast.Ident */ || (call_expr->left).typ == 245 /* v.ast.StringLiteral */ || (call_expr->left).typ == 241 /* v.ast.SelectorExpr */)) {
			call_expr->free_receiver = true;
		}
	}
	return typ;
}

VV_LOCAL_SYMBOL void v__checker__Checker_check_map_and_filter(v__checker__Checker* c, bool is_map, v__table__Type elem_typ, v__ast__CallExpr call_expr) {
	v__table__TypeSymbol* elem_sym = v__table__Table_get_type_symbol(c->table, elem_typ);
	v__ast__Expr arg_expr = (*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr.args, 0)).expr;
	v__ast__Expr _t921 = arg_expr;
	if (_t921.typ == 208 /* v.ast.AnonFn */) {
		if ((*arg_expr._208).decl.params.len > 1) {
			v__checker__Checker_error(c, tos_lit("function needs exactly 1 argument"), (*arg_expr._208).decl.pos);
		} else if (is_map && ((*arg_expr._208).decl.return_type != elem_typ || (*(v__table__Param*)/*ee elem_typ */array_get((*arg_expr._208).decl.params, 0)).typ != elem_typ)) {
			v__checker__Checker_error(c, _STR("type mismatch, should use `fn(a %.*s\000) %.*s\000 {...}`", 3, elem_sym->source_name, elem_sym->source_name), (*arg_expr._208).decl.pos);
		} else if (!is_map && ((*arg_expr._208).decl.return_type != _const_v__table__bool_type || (*(v__table__Param*)/*ee elem_typ */array_get((*arg_expr._208).decl.params, 0)).typ != elem_typ)) {
			v__checker__Checker_error(c, _STR("type mismatch, should use `fn(a %.*s\000) bool {...}`", 2, elem_sym->source_name), (*arg_expr._208).decl.pos);
		}
	} else if (_t921.typ == 224 /* v.ast.Ident */) {
		if ((*arg_expr._224).kind == v__ast__IdentKind_function) {
			Option_v__table__Fn _t922 = v__table__Table_find_fn(c->table, (*arg_expr._224).name);
			if (!_t922.ok) {
				string err = _t922.v_error;
				int errcode = _t922.ecode;
				v__checker__Checker_error(c, _STR("%.*s\000 is not exist", 2, (*arg_expr._224).name), (*arg_expr._224).pos);
				return;
			}
 			v__table__Fn func = *(v__table__Fn*) _t922.data;
			if (func.params.len > 1) {
				v__checker__Checker_error(c, tos_lit("function needs exactly 1 argument"), call_expr.pos);
			} else if (is_map && (func.return_type != elem_typ || (*(v__table__Param*)/*ee elem_typ */array_get(func.params, 0)).typ != elem_typ)) {
				v__checker__Checker_error(c, _STR("type mismatch, should use `fn(a %.*s\000) %.*s\000 {...}`", 3, elem_sym->source_name, elem_sym->source_name), (*arg_expr._224).pos);
			} else if (!is_map && (func.return_type != _const_v__table__bool_type || (*(v__table__Param*)/*ee elem_typ */array_get(func.params, 0)).typ != elem_typ)) {
				v__checker__Checker_error(c, _STR("type mismatch, should use `fn(a %.*s\000) bool {...}`", 2, elem_sym->source_name), (*arg_expr._224).pos);
			}
		}
	} else {
	};
}

v__table__Type v__checker__Checker_call_method(v__checker__Checker* c, v__ast__CallExpr* call_expr) {
	v__table__Type left_type = v__checker__Checker_expr(c, call_expr->left);
	bool is_generic = v__table__Type_has_flag(left_type, v__table__TypeFlag_generic);
	call_expr->left_type = left_type;
	call_expr->return_type = left_type;
	call_expr->receiver_type = left_type;
	v__table__TypeSymbol* left_type_sym = v__table__Table_get_type_symbol(c->table, v__checker__Checker_unwrap_generic(c, left_type));
	string method_name = call_expr->name;
	string unknown_method_msg = _STR("unknown method: `%.*s\000.%.*s\000`", 3, left_type_sym->source_name, method_name);
	if (v__table__Type_has_flag(left_type, v__table__TypeFlag_optional)) {
		v__checker__Checker_error(c, tos_lit("optional type cannot be called directly"), v__ast__Expr_position(call_expr->left));
		return _const_v__table__void_type;
	}
	if (left_type_sym->kind == v__table__Kind_sum_type && string_eq(method_name, tos_lit("type_name"))) {
		return _const_v__table__string_type;
	}
	if (left_type_sym->kind == v__table__Kind_array && (string_eq(method_name, tos_lit("filter")) || string_eq(method_name, tos_lit("clone")) || string_eq(method_name, tos_lit("repeat")) || string_eq(method_name, tos_lit("reverse")) || string_eq(method_name, tos_lit("map")) || string_eq(method_name, tos_lit("slice")) || string_eq(method_name, tos_lit("sort")))) {
		v__table__Type elem_typ = _const_v__table__void_type;
		bool is_filter_map = (string_eq(method_name, tos_lit("filter")) || string_eq(method_name, tos_lit("map")));
		bool is_sort = string_eq(method_name, tos_lit("sort"));
		if (is_filter_map || is_sort) {
			v__table__Array array_info = /* as */ *(v__table__Array*)__as_cast((left_type_sym->info)._350, (left_type_sym->info).typ, /*expected:*/350);
			int args_pos = call_expr->pos.pos + call_expr->name.len;
			v__ast__Scope* scope = v__ast__Scope_innermost(c->file->scope, args_pos);
			if (is_filter_map) {
				v__checker__scope_register_it(scope, call_expr->pos, array_info.elem_type);
			} else if (is_sort) {
				v__checker__Checker_fail_if_immutable(c, call_expr->left);
				v__checker__scope_register_ab(scope, call_expr->pos, array_info.elem_type);
				if (call_expr->args.len > 0) {
					if (((*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr->args, 0)).expr).typ != 228 /* v.ast.InfixExpr */) {
						v__checker__Checker_error(c, string_add(tos_lit("`.sort()` requires a `<` or `>` comparison as the first and only argument"), tos_lit("\ne.g. `users.sort(a.id < b.id)`")), call_expr->pos);
					}
				}
			}
			elem_typ = array_info.elem_type;
		}
		v__table__Type arg_type = left_type;
		// FOR IN array
		array _t923 = call_expr->args;
		for (int _t924 = 0; _t924 < _t923.len; ++_t924) {
			v__ast__CallArg arg = ((v__ast__CallArg*)_t923.data)[_t924];
			arg_type = v__checker__Checker_expr(c, arg.expr);
		}
		if (string_eq(method_name, tos_lit("map"))) {
			v__checker__Checker_check_map_and_filter(c, true, elem_typ, *call_expr);
			v__table__TypeSymbol* arg_sym = v__table__Table_get_type_symbol(c->table, arg_type);
			int ret_type = 0;
			v__table__TypeInfo _t925 = arg_sym->info;
			if (_t925.typ == 353 /* v.table.FnType */) {
				ret_type = (*arg_sym->info._353).func.return_type;
			} else {
				ret_type = arg_type;
			};
			call_expr->return_type = v__table__Table_find_or_register_array(c->table, ret_type, 1, c->mod);
		} else if (string_eq(method_name, tos_lit("filter"))) {
			v__checker__Checker_check_map_and_filter(c, false, elem_typ, *call_expr);
		} else if (string_eq(method_name, tos_lit("clone"))) {
			call_expr->receiver_type = v__table__Type_to_ptr(left_type);
		} else if (string_eq(method_name, tos_lit("sort"))) {
			call_expr->return_type = _const_v__table__void_type;
		}
		return call_expr->return_type;
	} else if (left_type_sym->kind == v__table__Kind_map && string_eq(method_name, tos_lit("clone"))) {
		call_expr->return_type = left_type;
		call_expr->receiver_type = v__table__Type_to_ptr(left_type);
		return call_expr->return_type;
	} else if (left_type_sym->kind == v__table__Kind_array && (string_eq(method_name, tos_lit("first")) || string_eq(method_name, tos_lit("last")) || string_eq(method_name, tos_lit("pop")))) {
		v__table__Array info = /* as */ *(v__table__Array*)__as_cast((left_type_sym->info)._350, (left_type_sym->info).typ, /*expected:*/350);
		call_expr->return_type = info.elem_type;
		if (string_eq(method_name, tos_lit("pop"))) {
			call_expr->receiver_type = v__table__Type_to_ptr(left_type);
		} else {
			call_expr->receiver_type = left_type;
		}
		return call_expr->return_type;
	} else if (left_type_sym->kind == v__table__Kind_array && (string_eq(method_name, tos_lit("insert")) || string_eq(method_name, tos_lit("prepend")))) {
		v__table__Array array_info = /* as */ *(v__table__Array*)__as_cast((left_type_sym->info)._350, (left_type_sym->info).typ, /*expected:*/350);
		v__table__TypeSymbol* elem_sym = v__table__Table_get_type_symbol(c->table, array_info.elem_type);
		v__ast__Expr arg_expr = (string_eq(method_name, tos_lit("insert")) ? ((*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr->args, 1)).expr) : ((*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr->args, 0)).expr));
		v__table__TypeSymbol* arg_sym = v__table__Table_get_type_symbol(c->table, v__checker__Checker_expr(c, arg_expr));
		if (arg_sym->kind == v__table__Kind_array) {
			v__table__Array info = /* as */ *(v__table__Array*)__as_cast((arg_sym->info)._350, (arg_sym->info).typ, /*expected:*/350);
			v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(c->table, info.elem_type);
			if (sym->kind != elem_sym->kind && ((elem_sym->kind == v__table__Kind_int && sym->kind != v__table__Kind_any_int) || (elem_sym->kind == v__table__Kind_f64 && sym->kind != v__table__Kind_any_float))) {
				v__checker__Checker_error(c, _STR("type mismatch, should use `%.*s\000[]`", 2, elem_sym->source_name), v__ast__Expr_position(arg_expr));
			}
		} else {
			if (arg_sym->kind != elem_sym->kind && ((elem_sym->kind == v__table__Kind_int && arg_sym->kind != v__table__Kind_any_int) || (elem_sym->kind == v__table__Kind_f64 && arg_sym->kind != v__table__Kind_any_float))) {
				v__checker__Checker_error(c, _STR("type mismatch, should use `%.*s\000`", 2, elem_sym->source_name), v__ast__Expr_position(arg_expr));
			}
		}
	}
	{ /* if guard */ 
	Option_v__table__Fn _t926;
	if (_t926 = v__table__Table_type_find_method(c->table, left_type_sym, method_name), _t926.ok) {
		v__table__Fn method = *(v__table__Fn*)_t926.data;
		if (!method.is_pub && !c->is_builtin_mod && !c->pref->is_test && string_ne(left_type_sym->mod, c->mod) && (left_type_sym->mod).len != 0) {
			v__checker__Checker_error(c, _STR("method `%.*s\000.%.*s\000` is private", 3, left_type_sym->source_name, method_name), call_expr->pos);
		}
		if ((*(v__table__Param*)/*ee elem_typ */array_get(method.params, 0)).is_mut) {
			v__checker__Checker_fail_if_immutable(c, call_expr->left);
		}
		if (method.return_type == _const_v__table__void_type && method.ctdefine.len > 0 && !_IN(string, method.ctdefine, c->pref->compile_defines)) {
			call_expr->should_be_skipped = true;
		}
		int nr_args = (method.params.len == 0 ? (0) : (method.params.len - 1));
		int min_required_args = method.params.len - (method.is_variadic && method.params.len > 1 ? (2) : (1));
		if (call_expr->args.len < min_required_args) {
			v__checker__Checker_error(c, _STR("too few arguments in call to `%.*s\000.%.*s\000` (%"PRId32"\000 instead of %"PRId32"\000)", 5, left_type_sym->source_name, method_name, call_expr->args.len, min_required_args), call_expr->pos);
		} else if (!method.is_variadic && call_expr->args.len > nr_args) {
			v__checker__Checker_error(c, _STR("too many arguments in call to `%.*s\000.%.*s\000` (%"PRId32"\000 instead of %"PRId32"\000)", 5, left_type_sym->source_name, method_name, call_expr->args.len, nr_args), call_expr->pos);
			return method.return_type;
		}
		// FOR IN array
		array _t927 = call_expr->args;
		for (int i = 0; i < _t927.len; ++i) {
			v__ast__CallArg arg = ((v__ast__CallArg*)_t927.data)[i];
			v__table__Type exp_arg_typ = (method.is_variadic && i >= method.params.len - 1 ? ((*(v__table__Param*)/*ee elem_typ */array_get(method.params, method.params.len - 1)).typ) : ((*(v__table__Param*)/*ee elem_typ */array_get(method.params, i + 1)).typ));
			v__table__TypeSymbol* exp_arg_sym = v__table__Table_get_type_symbol(c->table, exp_arg_typ);
			c->expected_type = exp_arg_typ;
			v__table__Type got_arg_typ = v__checker__Checker_expr(c, arg.expr);
			(*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr->args, i)).typ = got_arg_typ;
			if (method.is_variadic && v__table__Type_has_flag(got_arg_typ, v__table__TypeFlag_variadic) && call_expr->args.len - 1 > i) {
				v__checker__Checker_error(c, tos_lit("when forwarding a varg variable, it must be the final argument"), call_expr->pos);
			}
			if (exp_arg_sym->kind == v__table__Kind_interface_) {
				v__checker__Checker_type_implements(c, got_arg_typ, exp_arg_typ, v__ast__Expr_position(arg.expr));
				continue;
			}
			if (!v__checker__Checker_check_types(c, got_arg_typ, exp_arg_typ)) {
				v__table__TypeSymbol* got_arg_sym = v__table__Table_get_type_symbol(c->table, got_arg_typ);
				if (exp_arg_sym->parent_idx == got_arg_sym->parent_idx) {
					if (got_arg_sym->parent_idx != 0) {
						continue;
					}
				}
				if (got_arg_typ != _const_v__table__void_type) {
					v__checker__Checker_error(c, _STR("cannot use type `%.*s\000` as type `%.*s\000` in argument %"PRId32"\000 to `%.*s\000.%.*s\000`", 6, got_arg_sym->source_name, exp_arg_sym->source_name, i + 1, left_type_sym->source_name, method_name), call_expr->pos);
				}
			}
			v__table__Param param = (method.is_variadic && i >= method.params.len - 1 ? ((*(v__table__Param*)/*ee elem_typ */array_get(method.params, method.params.len - 1))) : ((*(v__table__Param*)/*ee elem_typ */array_get(method.params, i + 1))));
			if (arg.is_mut) {
				v__checker__Checker_fail_if_immutable(c, arg.expr);
				if (!param.is_mut) {
					string tok = v__table__ShareType_str(arg.share);
					v__checker__Checker_error(c, _STR("`%.*s\000` parameter `%.*s\000` is not `%.*s\000`, `%.*s\000` is not needed`", 5, call_expr->name, param.name, tok, tok), v__ast__Expr_position(arg.expr));
				} else if (v__table__Type_share(param.typ) != arg.share) {
					v__checker__Checker_error(c, tos_lit("wrong shared type"), v__ast__Expr_position(arg.expr));
				}
			} else {
				if (param.is_mut && (!arg.is_mut || v__table__Type_share(param.typ) != arg.share)) {
					string tok = v__table__ShareType_str(arg.share);
					v__checker__Checker_error(c, _STR("`%.*s\000` parameter `%.*s\000` is `%.*s\000`, you need to provide `%.*s\000` e.g. `%.*s\000 arg%"PRId32"\000`", 7, call_expr->name, param.name, tok, tok, tok, i + 1), v__ast__Expr_position(arg.expr));
				}
			}
		}
		if (method.is_unsafe && !c->inside_unsafe) {
			v__checker__Checker_warn(c, _STR("method `%.*s\000.%.*s\000` must be called from an `unsafe` block", 3, left_type_sym->source_name, method_name), call_expr->pos);
		}
		if (call_expr->expected_arg_types.len == 0) {
			for (int i = 1; i < method.params.len; ++i) {
				array_push(&call_expr->expected_arg_types, _MOV((v__table__Type[]){ (*(v__table__Param*)/*ee elem_typ */array_get(method.params, i)).typ }));
			}
		}
		if (is_generic) {
			call_expr->receiver_type = v__table__Type_set_flag(v__table__Type_derive(left_type, (*(v__table__Param*)/*ee elem_typ */array_get(method.params, 0)).typ), v__table__TypeFlag_generic);
		} else {
			call_expr->receiver_type = (*(v__table__Param*)/*ee elem_typ */array_get(method.params, 0)).typ;
		}
		call_expr->return_type = method.return_type;
		return method.return_type;
	} else {
		string err = _t926.v_error;
		int errcode = _t926.ecode;
		if (left_type_sym->kind == v__table__Kind_aggregate) {
			unknown_method_msg = err;
		}
	}}
	if (string_eq(method_name, tos_lit("str"))) {
		if (left_type_sym->kind == v__table__Kind_interface_) {
			string iname = left_type_sym->source_name;
			v__checker__Checker_error(c, _STR("interface `%.*s\000` does not have a .str() method. Use typeof() instead", 2, iname), call_expr->pos);
		}
		call_expr->receiver_type = left_type;
		call_expr->return_type = _const_v__table__string_type;
		if (call_expr->args.len > 0) {
			v__checker__Checker_error(c, tos_lit(".str() method calls should have no arguments"), call_expr->pos);
		}
		return _const_v__table__string_type;
	}
	{ /* if guard */ 
	Option_v__table__Field _t929;
	if (_t929 = v__table__Table_struct_find_field(c->table, left_type_sym, method_name), _t929.ok) {
		v__table__Field field = *(v__table__Field*)_t929.data;
		v__table__TypeSymbol* field_type_sym = v__table__Table_get_type_symbol(c->table, field.typ);
		if (field_type_sym->kind == v__table__Kind_function) {
			call_expr->is_field = true;
			v__table__FnType info = /* as */ *(v__table__FnType*)__as_cast((field_type_sym->info)._353, (field_type_sym->info).typ, /*expected:*/353);
			call_expr->return_type = info.func.return_type;
			// FOR IN array
			array _t930 = call_expr->args;
			for (int _t931 = 0; _t931 < _t930.len; ++_t931) {
				v__ast__CallArg arg = ((v__ast__CallArg*)_t930.data)[_t931];
				v__checker__Checker_expr(c, arg.expr);
			}
			return info.func.return_type;
		}
	}}
	if (left_type != _const_v__table__void_type) {

		int _t932_len = left_type_sym->methods.len;
		array_string _t932 = __new_array(0, _t932_len, sizeof(string));
		for (int _t933 = 0; _t933 < _t932_len; ++_t933) {
			v__table__Fn it = ((v__table__Fn*) left_type_sym->methods.data)[_t933];
			string ti = it.name;
			array_push(&_t932, &ti);
		}
				v__util__Suggestion suggestion = v__util__new_suggestion(method_name, _t932);
		v__checker__Checker_error(c, v__util__Suggestion_say(suggestion, unknown_method_msg), call_expr->pos);
	}
	return _const_v__table__void_type;
}

v__table__Type v__checker__Checker_call_fn(v__checker__Checker* c, v__ast__CallExpr* call_expr) {
	string fn_name = call_expr->name;
	if (string_eq(fn_name, tos_lit("main"))) {
		v__checker__Checker_error(c, tos_lit("the `main` function cannot be called in the program"), call_expr->pos);
	}
	if (string_eq(fn_name, tos_lit("typeof"))) {
		return _const_v__table__string_type;
	}
	if (v__table__Type_has_flag(call_expr->generic_type, v__table__TypeFlag_generic)) {
		if ((c->mod).len != 0) {
			v__table__Table_register_fn_gen_type(c->table, string_add(string_add(c->mod, tos_lit(".")), fn_name), c->cur_generic_type);
		} else {
			v__table__Table_register_fn_gen_type(c->table, fn_name, c->cur_generic_type);
		}
	}
	if (string_eq(fn_name, tos_lit("json.encode"))) {
	} else if (string_eq(fn_name, tos_lit("json.decode"))) {
		v__ast__Expr expr = (*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr->args, 0)).expr;
		if ((expr).typ != 247 /* v.ast.Type */) {
			string typ = tos3( /* v.ast.Expr */ v_typeof_sumtype_250( (expr).typ ));
			v__checker__Checker_error(c, _STR("json.decode: first argument needs to be a type, got `%.*s\000`", 2, typ), call_expr->pos);
			return _const_v__table__void_type;
		}
		c->expected_type = _const_v__table__string_type;
		(*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr->args, 1)).typ = v__checker__Checker_expr(c, (*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr->args, 1)).expr);
		if ((*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr->args, 1)).typ != _const_v__table__string_type) {
			v__checker__Checker_error(c, tos_lit("json.decode: second argument needs to be a string"), call_expr->pos);
		}
		v__ast__Type typ = /* as */ *(v__ast__Type*)__as_cast((expr)._247, (expr).typ, /*expected:*/247);
		v__table__Type ret_type = v__table__Type_set_flag(typ.typ, v__table__TypeFlag_optional);
		call_expr->return_type = ret_type;
		return ret_type;
	}
	v__table__Fn f = (v__table__Fn){.params = __new_array(0, 1, sizeof(v__table__Param)),.return_type = 0,.return_type_source_name = (string){.str=(byteptr)""},.is_variadic = 0,.language = 0,.is_generic = 0,.is_pub = 0,.is_deprecated = 0,.is_unsafe = 0,.is_placeholder = 0,.mod = (string){.str=(byteptr)""},.ctdefine = (string){.str=(byteptr)""},.attrs = __new_array(0, 1, sizeof(v__table__Attr)),.name = (string){.str=(byteptr)""},.source_fn = 0,};
	bool found = false;
	bool found_in_args = false;
	if ((call_expr->left).typ == 208 /* v.ast.AnonFn */) {
		call_expr->name = tos_lit("");
		v__checker__Checker_expr(c, call_expr->left);
		v__table__TypeSymbol* anon_fn_sym = v__table__Table_get_type_symbol(c->table, (*call_expr->left._208).typ);
		f = (/* as */ *(v__table__FnType*)__as_cast((anon_fn_sym->info)._353, (anon_fn_sym->info).typ, /*expected:*/353)).func;
		found = true;
	}
	if (!found && !string_contains(fn_name, tos_lit(".")) && string_ne(call_expr->mod, tos_lit("builtin"))) {
		string name_prefixed = _STR("%.*s\000.%.*s", 2, call_expr->mod, fn_name);
		{ /* if guard */ 
		Option_v__table__Fn _t934;
		if (_t934 = v__table__Table_find_fn(c->table, name_prefixed), _t934.ok) {
			v__table__Fn f1 = *(v__table__Fn*)_t934.data;
			call_expr->name = name_prefixed;
			found = true;
			f = f1;
		}}
	}
	if (!found) {
		{ /* if guard */ 
		Option_v__table__Fn _t935;
		if (_t935 = v__table__Table_find_fn(c->table, fn_name), _t935.ok) {
			v__table__Fn f1 = *(v__table__Fn*)_t935.data;
			found = true;
			f = f1;
		}}
	}
	if (c->pref->is_script && !found) {
		string os_name = _STR("os.%.*s", 1, fn_name);
		{ /* if guard */ 
		Option_v__table__Fn _t936;
		if (_t936 = v__table__Table_find_fn(c->table, os_name), _t936.ok) {
			v__table__Fn f1 = *(v__table__Fn*)_t936.data;
			call_expr->name = os_name;
			found = true;
			f = f1;
		}}
	}
	if (!found) {
		v__ast__Scope* scope = v__ast__Scope_innermost(c->file->scope, call_expr->pos.pos);
		{ /* if guard */ 
		Option_v__ast__Var_ptr _t937;
		if (_t937 = v__ast__Scope_find_var(scope, fn_name), _t937.ok) {
			v__ast__Var* v = *(v__ast__Var**)_t937.data;
			if (v->typ != 0) {
				v__table__TypeSymbol* vts = v__table__Table_get_type_symbol(c->table, v->typ);
				if (vts->kind == v__table__Kind_function) {
					v__table__FnType info = /* as */ *(v__table__FnType*)__as_cast((vts->info)._353, (vts->info).typ, /*expected:*/353);
					f = info.func;
					found = true;
					found_in_args = true;
				}
			}
		}}
	}
	if (!found) {
		v__checker__Checker_error(c, _STR("unknown function: %.*s", 1, fn_name), call_expr->pos);
		return _const_v__table__void_type;
	}
	if (!found_in_args) {
		v__ast__Scope* scope = v__ast__Scope_innermost(c->file->scope, call_expr->pos.pos);
		{ /* if guard */ 
		Option_v__ast__Var_ptr _t938;
		if (_t938 = v__ast__Scope_find_var(scope, fn_name), _t938.ok) {
			v__checker__Checker_error(c, _STR("ambiguous call to: `%.*s\000`, may refer to fn `%.*s\000` or variable `%.*s\000`", 4, fn_name, fn_name, fn_name), call_expr->pos);
		}}
	}
	if (!f.is_pub && f.language == v__table__Language_v && f.name.len > 0 && f.mod.len > 0 && string_ne(f.mod, c->mod)) {
		v__checker__Checker_error(c, _STR("function `%.*s\000` is private. curmod=%.*s\000 fmod=%.*s", 3, f.name, c->mod, f.mod), call_expr->pos);
	}
	if (f.is_deprecated) {
		v__checker__Checker_warn(c, _STR("function `%.*s\000` has been deprecated", 2, f.name), call_expr->pos);
	}
	if (f.is_unsafe && !c->inside_unsafe && f.language == v__table__Language_c && (string_at(f.name, 2) == 'm' || string_at(f.name, 2) == 's') && string_eq(f.mod, tos_lit("builtin"))) {
		v__checker__Checker_warn(c, _STR("function `%.*s\000` must be called from an `unsafe` block", 2, f.name), call_expr->pos);
	}
	if (f.is_generic && v__table__Type_has_flag(f.return_type, v__table__TypeFlag_generic)) {
		v__table__TypeSymbol* rts = v__table__Table_get_type_symbol(c->table, f.return_type);
		if (rts->kind == v__table__Kind_struct_) {
			v__table__Struct rts_info = /* as */ *(v__table__Struct*)__as_cast((rts->info)._155, (rts->info).typ, /*expected:*/155);
			if (rts_info.generic_types.len > 0) {
				v__table__TypeSymbol* gts = v__table__Table_get_type_symbol(c->table, call_expr->generic_type);
				string nrt = _STR("%.*s\000<%.*s\000>", 3, rts->name, gts->name);
				int idx = (*(int*)map_get(c->table->type_idxs, nrt, &(int[]){ 0 }));
				if (idx == 0) {
					v__checker__Checker_error(c, _STR("unknown type: %.*s", 1, nrt), call_expr->pos);
				}
				call_expr->return_type = v__table__Type_derive(v__table__new_type(idx), f.return_type);
			}
		}
	} else {
		call_expr->return_type = f.return_type;
	}
	if (f.return_type == _const_v__table__void_type && f.ctdefine.len > 0 && !_IN(string, f.ctdefine, c->pref->compile_defines)) {
		call_expr->should_be_skipped = true;
	}
	if (f.language != v__table__Language_v || call_expr->language != v__table__Language_v) {
		// FOR IN array
		array _t939 = call_expr->args;
		for (int _t940 = 0; _t940 < _t939.len; ++_t940) {
			v__ast__CallArg arg = ((v__ast__CallArg*)_t939.data)[_t940];
			v__checker__Checker_expr(c, arg.expr);
		}
		return f.return_type;
	}
	int min_required_args = (f.is_variadic ? (f.params.len - 1) : (f.params.len));
	if (call_expr->args.len < min_required_args) {
		v__checker__Checker_error(c, _STR("too few arguments in call to `%.*s\000` (%"PRId32"\000 instead of %"PRId32"\000)", 4, fn_name, call_expr->args.len, min_required_args), call_expr->pos);
	} else if (!f.is_variadic && call_expr->args.len > f.params.len) {
		v__checker__Checker_error(c, _STR("too many arguments in call to `%.*s\000` (%"PRId32"\000 instead of %"PRId32"\000)", 4, fn_name, call_expr->args.len, f.params.len), call_expr->pos);
		return f.return_type;
	}
	if ((string_eq(fn_name, tos_lit("println")) || string_eq(fn_name, tos_lit("print"))) && call_expr->args.len > 0) {
		c->expected_type = _const_v__table__string_type;
		(*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr->args, 0)).typ = v__checker__Checker_expr(c, (*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr->args, 0)).expr);
		if (v__table__Type_has_flag((*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr->args, 0)).typ, v__table__TypeFlag_optional)) {
			v__checker__Checker_error(c, tos_lit("cannot print optional type"), v__ast__Expr_position((*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr->args, 0)).expr));
		}
		return f.return_type;
	}
	if (call_expr->expected_arg_types.len == 0) {
		// FOR IN array
		array _t941 = f.params;
		for (int _t942 = 0; _t942 < _t941.len; ++_t942) {
			v__table__Param param = ((v__table__Param*)_t941.data)[_t942];
			array_push(&call_expr->expected_arg_types, _MOV((v__table__Type[]){ param.typ }));
		}
	}
	// FOR IN array
	array _t944 = call_expr->args;
	for (int i = 0; i < _t944.len; ++i) {
		v__ast__CallArg call_arg = ((v__ast__CallArg*)_t944.data)[i];
		v__table__Param arg = (f.is_variadic && i >= f.params.len - 1 ? ((*(v__table__Param*)/*ee elem_typ */array_get(f.params, f.params.len - 1))) : ((*(v__table__Param*)/*ee elem_typ */array_get(f.params, i))));
		c->expected_type = arg.typ;
		v__table__Type typ = v__checker__Checker_expr(c, call_arg.expr);
		(*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr->args, i)).typ = typ;
		v__table__TypeSymbol* typ_sym = v__table__Table_get_type_symbol(c->table, typ);
		v__table__TypeSymbol* arg_typ_sym = v__table__Table_get_type_symbol(c->table, arg.typ);
		if (f.is_variadic && v__table__Type_has_flag(typ, v__table__TypeFlag_variadic) && call_expr->args.len - 1 > i) {
			v__checker__Checker_error(c, tos_lit("when forwarding a varg variable, it must be the final argument"), call_expr->pos);
		}
		if (call_arg.is_mut) {
			v__checker__Checker_fail_if_immutable(c, call_arg.expr);
			if (!arg.is_mut) {
				string tok = v__table__ShareType_str(call_arg.share);
				v__checker__Checker_error(c, _STR("`%.*s\000` parameter `%.*s\000` is not `%.*s\000`, `%.*s\000` is not needed`", 5, call_expr->name, arg.name, tok, tok), v__ast__Expr_position(call_arg.expr));
			} else if (v__table__Type_share(arg.typ) != call_arg.share) {
				v__checker__Checker_error(c, tos_lit("wrong shared type"), v__ast__Expr_position(call_arg.expr));
			}
		} else {
			if (arg.is_mut && (!call_arg.is_mut || v__table__Type_share(arg.typ) != call_arg.share)) {
				string tok = v__table__ShareType_str(call_arg.share);
				v__checker__Checker_error(c, _STR("`%.*s\000` parameter `%.*s\000` is `%.*s\000`, you need to provide `%.*s\000` e.g. `%.*s\000 arg%"PRId32"\000`", 7, call_expr->name, arg.name, tok, tok, tok, i + 1), v__ast__Expr_position(call_arg.expr));
			}
		}
		if (arg_typ_sym->kind == v__table__Kind_interface_) {
			v__checker__Checker_type_implements(c, typ, arg.typ, v__ast__Expr_position(call_arg.expr));
			continue;
		}
		Option_void _t945 = v__checker__Checker_check_expected(c, typ, arg.typ);
		if (!_t945.ok && !_t945.is_none) {
			string err = _t945.v_error;
			int errcode = _t945.ecode;
			if (typ_sym->kind == v__table__Kind_void && arg_typ_sym->kind == v__table__Kind_string) {
				continue;
			}
			if (f.is_generic) {
				continue;
			}
			v__checker__Checker_error(c, _STR("invalid argument %"PRId32"\000 to `%.*s\000`: %.*s", 3, i + 1, fn_name, err), call_arg.pos);
		};
	}
	if (f.is_generic && call_expr->generic_type == _const_v__table__void_type) {
		v__checker__Checker_infer_fn_types(c, f, call_expr);
	}
	if (call_expr->generic_type != _const_v__table__void_type && f.return_type != 0) {
		v__table__TypeSymbol* return_sym = v__table__Table_get_type_symbol(c->table, f.return_type);
		if (string_eq(return_sym->source_name, tos_lit("T"))) {
			v__table__Type typ = call_expr->generic_type;
			typ = v__table__Type_set_nr_muls(typ, v__table__Type_nr_muls(f.return_type));
			if (v__table__Type_has_flag(f.return_type, v__table__TypeFlag_optional)) {
				typ = v__table__Type_set_flag(typ, v__table__TypeFlag_optional);
			}
			call_expr->return_type = typ;
			return typ;
		} else if (return_sym->kind == v__table__Kind_array) {
			v__table__Array elem_info = /* as */ *(v__table__Array*)__as_cast((return_sym->info)._350, (return_sym->info).typ, /*expected:*/350);
			v__table__TypeSymbol* elem_sym = v__table__Table_get_type_symbol(c->table, elem_info.elem_type);
			if (string_eq(elem_sym->source_name, tos_lit("T"))) {
				int idx = v__table__Table_find_or_register_array(c->table, call_expr->generic_type, 1, return_sym->mod);
				return v__table__new_type(idx);
			}
		}
	}
	if (v__table__Type_is_full(call_expr->generic_type) && !f.is_generic) {
		v__checker__Checker_error(c, tos_lit("a non generic function called like a generic one"), call_expr->generic_list_pos);
	}
	if (f.is_generic) {
		return call_expr->return_type;
	}
	return f.return_type;
}

VV_LOCAL_SYMBOL bool v__checker__Checker_type_implements(v__checker__Checker* c, v__table__Type typ, v__table__Type inter_typ, v__token__Position pos) {
	v__table__TypeSymbol* typ_sym = v__table__Table_get_type_symbol(c->table, typ);
	v__table__TypeSymbol* inter_sym = v__table__Table_get_type_symbol(c->table, inter_typ);
	string styp = v__table__Table_type_to_str(c->table, typ);
	// FOR IN array
	array _t946 = inter_sym->methods;
	for (int _t947 = 0; _t947 < _t946.len; ++_t947) {
		v__table__Fn imethod = ((v__table__Fn*)_t946.data)[_t947];
		{ /* if guard */ 
		Option_v__table__Fn _t948;
		if (_t948 = v__table__TypeSymbol_find_method(typ_sym, imethod.name), _t948.ok) {
			v__table__Fn method = *(v__table__Fn*)_t948.data;
			if (!v__table__Fn_is_same_method_as(&imethod, (voidptr)&/*qq*/method)) {
				string sig = v__table__Table_fn_signature(c->table, (voidptr)&/*qq*/imethod, (v__table__FnSignatureOpts){.skip_receiver = true,.type_only = 0,});
				v__checker__Checker_error(c, _STR("`%.*s\000` incorrectly implements method `%.*s\000` of interface `%.*s\000`, expected `%.*s\000`", 5, styp, imethod.name, inter_sym->source_name, sig), pos);
				return false;
			}
			continue;
		}}
		v__checker__Checker_error(c, _STR("`%.*s\000` doesn't implement method `%.*s\000`", 3, styp, imethod.name), pos);
	}
	if ((inter_sym->info).typ == 356 /* v.table.Interface */) {
		if (!_IN(v__table__Type, typ, (*inter_sym->info._356).types) && typ_sym->kind != v__table__Kind_interface_) {
			array_push(&(*inter_sym->info._356).types, _MOV((v__table__Type[]){ typ }));
		}
	}
	return true;
}

v__table__Type v__checker__Checker_check_expr_opt_call(v__checker__Checker* c, v__ast__Expr expr, v__table__Type ret_type) {
	if ((expr).typ == 215 /* v.ast.CallExpr */) {
		if (v__table__Type_has_flag((*expr._215).return_type, v__table__TypeFlag_optional)) {
			if ((*expr._215).or_block.kind == v__ast__OrKind_absent) {
				if (ret_type != _const_v__table__void_type) {
					v__checker__Checker_error(c, _STR("%.*s\000() returns an option but is missing an `or {}` block", 2, (*expr._215).name), (*expr._215).pos);
				}
			} else {
				v__checker__Checker_check_or_expr(c, (*expr._215).or_block, ret_type, v__table__Type_clear_flag((*expr._215).return_type, v__table__TypeFlag_optional));
			}
			return ret_type;
		} else if ((*expr._215).or_block.kind == v__ast__OrKind_block) {
			v__checker__Checker_error(c, _STR("unexpected `or` block, the function `%.*s\000` does not return an optional", 2, (*expr._215).name), (*expr._215).or_block.pos);
		} else if ((*expr._215).or_block.kind == v__ast__OrKind_propagate) {
			v__checker__Checker_error(c, _STR("unexpected `?`, the function `%.*s\000` does not return an optional", 2, (*expr._215).name), (*expr._215).or_block.pos);
		}
	}
	return ret_type;
}

void v__checker__Checker_check_or_expr(v__checker__Checker* c, v__ast__OrExpr or_expr, v__table__Type ret_type, v__table__Type expr_return_type) {
	if (or_expr.kind == v__ast__OrKind_propagate) {
		if (!v__table__Type_has_flag(c->cur_fn->return_type, v__table__TypeFlag_optional) && string_ne(c->cur_fn->name, tos_lit("main.main"))) {
			v__checker__Checker_error(c, _STR("to propagate the optional call, `%.*s\000` must return an optional", 2, c->cur_fn->name), or_expr.pos);
		}
		return;
	}
	int stmts_len = or_expr.stmts.len;
	if (stmts_len == 0) {
		if (ret_type != _const_v__table__void_type) {
			v__checker__Checker_error(c, tos_lit("assignment requires a non empty `or {}` block"), or_expr.pos);
			return;
		}
		return;
	}
	v__ast__Stmt last_stmt = (*(v__ast__Stmt*)/*ee elem_typ */array_get(or_expr.stmts, stmts_len - 1));
	if (ret_type != _const_v__table__void_type) {
		v__ast__Stmt _t950 = last_stmt;
		if (_t950.typ == 259 /* v.ast.ExprStmt */) {
			v__table__Type last_stmt_typ = v__checker__Checker_expr(c, (*last_stmt._259).expr);
			bool type_fits = v__checker__Checker_check_types(c, last_stmt_typ, ret_type);
			bool is_panic_or_exit = v__checker__is_expr_panic_or_exit((*last_stmt._259).expr);
			if (type_fits || is_panic_or_exit) {
				return;
			}
			string expected_type_name = v__table__Table_type_to_str(c->table, v__table__Type_clear_flag(ret_type, v__table__TypeFlag_optional));
			if ((*last_stmt._259).typ == _const_v__table__void_type) {
				v__checker__Checker_error(c, _STR("`or` block must provide a default value of type `%.*s\000`, or return/exit/continue/break/panic", 2, expected_type_name), (*last_stmt._259).pos);
			} else {
				string type_name = v__table__Table_type_to_str(c->table, last_stmt_typ);
				v__checker__Checker_error(c, _STR("wrong return type `%.*s\000` in the `or {}` block, expected `%.*s\000`", 3, type_name, expected_type_name), (*last_stmt._259).pos);
			}
			return;
		} else if (_t950.typ == 254 /* v.ast.BranchStmt */) {
			if (!((*last_stmt._254).kind == v__token__Kind_key_continue || (*last_stmt._254).kind == v__token__Kind_key_break)) {
				v__checker__Checker_error(c, tos_lit("only break/continue is allowed as a branch statement in the end of an `or {}` block"), (*last_stmt._254).pos);
				return;
			}
		} else if (_t950.typ == 271 /* v.ast.Return */) {
		} else {
			string expected_type_name = v__table__Table_type_to_str(c->table, v__table__Type_clear_flag(ret_type, v__table__TypeFlag_optional));
			v__checker__Checker_error(c, _STR("last statement in the `or {}` block should be an expression of type `%.*s\000` or exit parent scope", 2, expected_type_name), or_expr.pos);
			return;
		};
	} else {
		v__ast__Stmt _t951 = last_stmt;
		if (_t951.typ == 259 /* v.ast.ExprStmt */) {
			if ((*last_stmt._259).typ == _const_v__table__void_type) {
				return;
			}
			if (v__checker__is_expr_panic_or_exit((*last_stmt._259).expr)) {
				return;
			}
			if (v__checker__Checker_check_types(c, (*last_stmt._259).typ, expr_return_type)) {
				return;
			}
			string type_name = v__table__Table_type_to_str(c->table, (*last_stmt._259).typ);
			string expr_return_type_name = v__table__Table_type_to_str(c->table, expr_return_type);
			v__checker__Checker_error(c, _STR("the default expression type in the `or` block should be `%.*s\000`, instead you gave a value of type `%.*s\000`", 3, expr_return_type_name, type_name), v__ast__Expr_position((*last_stmt._259).expr));
		} else {
		};
	}
}

VV_LOCAL_SYMBOL bool v__checker__is_expr_panic_or_exit(v__ast__Expr expr) {
	v__ast__Expr _t952 = expr;
	if (_t952.typ == 215 /* v.ast.CallExpr */) {
		return (string_eq((*expr._215).name, tos_lit("panic")) || string_eq((*expr._215).name, tos_lit("exit")));
	} else {
		return false;
	};
	return 0;
}

v__table__Type v__checker__Checker_selector_expr(v__checker__Checker* c, v__ast__SelectorExpr* selector_expr) {
	bool prevent_sum_type_unwrapping_once = c->prevent_sum_type_unwrapping_once;
	c->prevent_sum_type_unwrapping_once = false;
	int name_type = 0;
	v__ast__Expr _t953 = selector_expr->expr;
	if (_t953.typ == 224 /* v.ast.Ident */) {
		if (string_eq((*selector_expr->expr._224).name, tos_lit("T"))) {
			name_type = v__table__Type_set_flag(((v__table__Table_find_type_idx(c->table, tos_lit("T")))), v__table__TypeFlag_generic);
		}
	} else if (_t953.typ == 248 /* v.ast.TypeOf */) {
		name_type = v__checker__Checker_expr(c, (*selector_expr->expr._248).expr);
	} else {
	};
	if (name_type > 0) {
		if (string_ne(selector_expr->field_name, tos_lit("name"))) {
			v__checker__Checker_error(c, _STR("invalid field `.%.*s\000` for type `%.*s\000`", 3, selector_expr->field_name, v__ast__Expr_str(selector_expr->expr)), selector_expr->pos);
		}
		selector_expr->name_type = name_type;
		return _const_v__table__string_type;
	}
	v__table__Type typ = v__checker__Checker_expr(c, selector_expr->expr);
	if (typ == _const_v__table__void_type_idx) {
		v__checker__Checker_error(c, tos_lit("unknown selector expression"), selector_expr->pos);
		return _const_v__table__void_type;
	}
	selector_expr->expr_type = typ;
	string field_name = selector_expr->field_name;
	v__table__Type utyp = v__checker__Checker_unwrap_generic(c, typ);
	v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(c->table, utyp);
	if (v__table__Type_has_flag(typ, v__table__TypeFlag_variadic) || sym->kind == v__table__Kind_array_fixed || sym->kind == v__table__Kind_chan) {
		if (string_eq(field_name, tos_lit("len")) || (sym->kind == v__table__Kind_chan && string_eq(field_name, tos_lit("cap")))) {
			selector_expr->typ = _const_v__table__int_type;
			return _const_v__table__int_type;
		}
	}
	string unknown_field_msg = _STR("type `%.*s\000` has no field or method `%.*s\000`", 3, sym->source_name, field_name);
	{ /* if guard */ 
	Option_v__table__Field _t954;
	if (_t954 = v__table__Table_struct_find_field(c->table, sym, field_name), _t954.ok) {
		v__table__Field field = *(v__table__Field*)_t954.data;
		if (string_ne(sym->mod, c->mod) && !field.is_pub && sym->language != v__table__Language_c) {
			v__checker__Checker_error(c, _STR("field `%.*s\000.%.*s\000` is not public", 3, sym->source_name, field_name), selector_expr->pos);
		}
		v__table__TypeSymbol* field_sym = v__table__Table_get_type_symbol(c->table, field.typ);
		if (field_sym->kind == v__table__Kind_sum_type) {
			if (!prevent_sum_type_unwrapping_once) {
				v__ast__Scope* scope = v__ast__Scope_innermost(c->file->scope, selector_expr->pos.pos);
				{ /* if guard */ 
				Option_v__ast__ScopeStructField _t955;
				if (_t955 = v__ast__Scope_find_struct_field(scope, utyp, field_name), _t955.ok) {
					v__ast__ScopeStructField scope_field = *(v__ast__ScopeStructField*)_t955.data;
					return *(v__table__Type*)array_last(scope_field.sum_type_casts);
				}}
			}
		}
		selector_expr->typ = field.typ;
		return field.typ;
	} else {
		string err = _t954.v_error;
		int errcode = _t954.ecode;
		if (sym->kind == v__table__Kind_aggregate) {
			unknown_field_msg = err;
		}
	}}
	if (!(sym->kind == v__table__Kind_struct_ || sym->kind == v__table__Kind_aggregate)) {
		if (sym->kind != v__table__Kind_placeholder) {
			v__checker__Checker_error(c, _STR("`%.*s\000` is not a struct", 2, sym->source_name), selector_expr->pos);
		}
	} else {
		if (sym->kind == v__table__Kind_struct_) {
			v__table__Struct sss = /* as */ *(v__table__Struct*)__as_cast((sym->info)._155, (sym->info).typ, /*expected:*/155);

			int _t956_len = sss.fields.len;
			array_string _t956 = __new_array(0, _t956_len, sizeof(string));
			for (int _t957 = 0; _t957 < _t956_len; ++_t957) {
				v__table__Field it = ((v__table__Field*) sss.fields.data)[_t957];
				string ti = it.name;
				array_push(&_t956, &ti);
			}
						v__util__Suggestion suggestion = v__util__new_suggestion(field_name, _t956);
			v__checker__Checker_error(c, v__util__Suggestion_say(suggestion, unknown_field_msg), selector_expr->pos);
		}
		v__checker__Checker_error(c, unknown_field_msg, selector_expr->pos);
	}
	return _const_v__table__void_type;
}

void v__checker__Checker_return_stmt(v__checker__Checker* c, v__ast__Return* return_stmt) {
	c->expected_type = c->cur_fn->return_type;
	v__table__Type expected_type = v__checker__Checker_unwrap_generic(c, c->expected_type);
	v__table__TypeSymbol* expected_type_sym = v__table__Table_get_type_symbol(c->table, expected_type);
	if (return_stmt->exprs.len > 0 && c->cur_fn->return_type == _const_v__table__void_type) {
		v__checker__Checker_error(c, tos_lit("too many arguments to return, current function does not return anything"), return_stmt->pos);
		return;
	} else if (return_stmt->exprs.len == 0 && !(c->expected_type == _const_v__table__void_type || expected_type_sym->kind == v__table__Kind_void)) {
		v__checker__Checker_error(c, tos_lit("too few arguments to return"), return_stmt->pos);
		return;
	}
	if (return_stmt->exprs.len == 0) {
		return;
	}
	bool exp_is_optional = v__table__Type_has_flag(expected_type, v__table__TypeFlag_optional);
	array_v__table__Type expected_types = new_array_from_c_array(1, 1, sizeof(v__table__Type), _MOV((v__table__Type[1]){expected_type}));
	if (expected_type_sym->kind == v__table__Kind_multi_return) {
		v__table__MultiReturn mr_info = /* as */ *(v__table__MultiReturn*)__as_cast((expected_type_sym->info)._352, (expected_type_sym->info).typ, /*expected:*/352);
		expected_types = mr_info.types;
	}
	array_v__table__Type got_types = __new_array_with_default(0, 0, sizeof(v__table__Type), 0);
	// FOR IN array
	array _t958 = return_stmt->exprs;
	for (int _t959 = 0; _t959 < _t958.len; ++_t959) {
		v__ast__Expr expr = ((v__ast__Expr*)_t958.data)[_t959];
		v__table__Type typ = v__checker__Checker_expr(c, expr);
		v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(c->table, typ);
		if (sym->kind == v__table__Kind_multi_return) {
			// FOR IN array
			array _t960 = v__table__TypeSymbol_mr_info(sym).types;
			for (int _t961 = 0; _t961 < _t960.len; ++_t961) {
				v__table__Type t = ((v__table__Type*)_t960.data)[_t961];
				array_push(&got_types, _MOV((v__table__Type[]){ t }));
			}
		} else {
			array_push(&got_types, _MOV((v__table__Type[]){ typ }));
		}
	}
	return_stmt->types = got_types;
	if (exp_is_optional && (v__table__Type_idx((*(v__table__Type*)/*ee elem_typ */array_get(got_types, 0))) == _const_v__table__none_type_idx || v__table__Type_idx((*(v__table__Type*)/*ee elem_typ */array_get(got_types, 0))) == (*(int*)map_get(c->table->type_idxs, tos_lit("Option"), &(int[]){ 0 })))) {
		return;
	}
	if (expected_types.len > 0 && expected_types.len != got_types.len) {
		v__checker__Checker_error(c, tos_lit("wrong number of return arguments"), return_stmt->pos);
		return;
	}
	// FOR IN array
	array _t964 = expected_types;
	for (int i = 0; i < _t964.len; ++i) {
		v__table__Type exp_type = ((v__table__Type*)_t964.data)[i];
		v__table__Type got_typ = v__checker__Checker_unwrap_generic(c, (*(v__table__Type*)/*ee elem_typ */array_get(got_types, i)));
		if (v__table__Type_has_flag(got_typ, v__table__TypeFlag_optional) && (!v__table__Type_has_flag(exp_type, v__table__TypeFlag_optional) || string_ne(v__table__Table_type_to_str(c->table, got_typ), v__table__Table_type_to_str(c->table, exp_type)))) {
			v__token__Position pos = v__ast__Expr_position((*(v__ast__Expr*)/*ee elem_typ */array_get(return_stmt->exprs, i)));
			v__checker__Checker_error(c, _STR("cannot use `%.*s\000` as type `%.*s\000` in return argument", 3, v__table__Table_type_to_str(c->table, got_typ), v__table__Table_type_to_str(c->table, exp_type)), pos);
		}
		if (!v__checker__Checker_check_types(c, got_typ, exp_type)) {
			v__table__TypeSymbol* got_typ_sym = v__table__Table_get_type_symbol(c->table, got_typ);
			v__table__TypeSymbol* exp_typ_sym = v__table__Table_get_type_symbol(c->table, exp_type);
			v__token__Position pos = v__ast__Expr_position((*(v__ast__Expr*)/*ee elem_typ */array_get(return_stmt->exprs, i)));
			if (exp_typ_sym->kind == v__table__Kind_interface_) {
				v__checker__Checker_type_implements(c, got_typ, exp_type, return_stmt->pos);
				continue;
			}
			v__checker__Checker_error(c, _STR("cannot use `%.*s\000` as type `%.*s\000` in return argument", 3, got_typ_sym->source_name, exp_typ_sym->source_name), pos);
		}
		if (v__table__Type_is_ptr(got_typ) && !v__table__Type_is_ptr(exp_type)) {
			v__token__Position pos = v__ast__Expr_position((*(v__ast__Expr*)/*ee elem_typ */array_get(return_stmt->exprs, i)));
			v__checker__Checker_error(c, _STR("fn `%.*s\000` expects you to return a non reference type `%.*s\000`, but you are returning `%.*s\000` instead", 4, c->cur_fn->name, v__table__Table_type_to_str(c->table, exp_type), v__table__Table_type_to_str(c->table, got_typ)), pos);
		}
	}
}

void v__checker__Checker_const_decl(v__checker__Checker* c, v__ast__ConstDecl* node) {
	array_string field_names = __new_array_with_default(0, 0, sizeof(string), 0);
	array_int field_order = __new_array_with_default(0, 0, sizeof(int), 0);
	// FOR IN array
	array _t965 = node->fields;
	for (int i = 0; i < _t965.len; ++i) {
		v__ast__ConstField field = ((v__ast__ConstField*)_t965.data)[i];
		if (_IN(string, field.name, c->const_names)) {
			v__checker__Checker_error(c, _STR("duplicate const `%.*s\000`", 2, field.name), field.pos);
		}
		array_push(&c->const_names, _MOV((string[]){ string_clone(field.name) }));
		array_push(&field_names, _MOV((string[]){ string_clone(field.name) }));
		array_push(&field_order, _MOV((int[]){ i }));
	}
	bool needs_order = false;
	array_int done_fields = __new_array_with_default(0, 0, sizeof(int), 0);
	// FOR IN array
	array _t969 = node->fields;
	for (int i = 0; i < _t969.len; ++i) {
		v__ast__ConstField field = ((v__ast__ConstField*)_t969.data)[i];
		c->const_decl = field.name;
		array_push(&c->const_deps, _MOV((string[]){ string_clone(field.name) }));
		v__table__Type typ = v__checker__Checker_expr(c, field.expr);
		(*(v__ast__ConstField*)/*ee elem_typ */array_get(node->fields, i)).typ = v__table__Table_mktyp(c->table, typ);
		// FOR IN array
		array _t971 = c->const_deps;
		for (int _t972 = 0; _t972 < _t971.len; ++_t972) {
			string cd = ((string*)_t971.data)[_t972];
			// FOR IN array
			array _t973 = node->fields;
			for (int j = 0; j < _t973.len; ++j) {
				v__ast__ConstField f = ((v__ast__ConstField*)_t973.data)[j];
				if (j != i && _IN(string, cd, field_names) && string_eq(cd, f.name) && !_IN(int, j, done_fields)) {
					needs_order = true;
					int x = (*(int*)/*ee elem_typ */array_get(field_order, j));
					array_set(&field_order, j, &(int[]) { (*(int*)/*ee elem_typ */array_get(field_order, i)) });
					array_set(&field_order, i, &(int[]) { x });
					break;
				}
			}
		}
		array_push(&done_fields, _MOV((int[]){ i }));
		c->const_deps = __new_array_with_default(0, 0, sizeof(string), 0);
	}
	if (needs_order) {
		array_v__ast__ConstField ordered_fields = __new_array_with_default(0, 0, sizeof(v__ast__ConstField), 0);
		// FOR IN array
		array _t975 = field_order;
		for (int _t976 = 0; _t976 < _t975.len; ++_t976) {
			int order = ((int*)_t975.data)[_t976];
			array_push(&ordered_fields, _MOV((v__ast__ConstField[]){ (*(v__ast__ConstField*)/*ee elem_typ */array_get(node->fields, order)) }));
		}
		node->fields = ordered_fields;
	}
}

void v__checker__Checker_enum_decl(v__checker__Checker* c, v__ast__EnumDecl decl) {
	v__checker__Checker_check_valid_pascal_case(c, decl.name, tos_lit("enum name"), decl.pos);
	array_int seen = __new_array_with_default(0, 0, sizeof(int), 0);
	// FOR IN array
	array _t978 = decl.fields;
	for (int i = 0; i < _t978.len; ++i) {
		v__ast__EnumField field = ((v__ast__EnumField*)_t978.data)[i];
		if (!c->pref->experimental && v__util__contains_capital(field.name)) {
			v__checker__Checker_error(c, _STR("field name `%.*s\000` cannot contain uppercase letters, use snake_case instead", 2, field.name), field.pos);
		}
		for (int j = 0; j < i; ++j) {
			if (string_eq(field.name, (*(v__ast__EnumField*)/*ee elem_typ */array_get(decl.fields, j)).name)) {
				v__checker__Checker_error(c, _STR("field name `%.*s\000` duplicate", 2, field.name), field.pos);
			}
		}
		if (field.has_expr) {
			v__ast__Expr _t979 = field.expr;
			if (_t979.typ == 229 /* v.ast.IntegerLiteral */) {
				i64 val = string_i64((*field.expr._229).val);
				if (val < _const_v__checker__int_min || val > _const_v__checker__int_max) {
					v__checker__Checker_error(c, _STR("enum value `%"PRId64"\000` overflows int", 2, val), (*field.expr._229).pos);
				} else if (!decl.is_multi_allowed && _IN(int, ((int)(val)), seen)) {
					v__checker__Checker_error(c, _STR("enum value `%"PRId64"\000` already exists", 2, val), (*field.expr._229).pos);
				}
				array_push(&seen, _MOV((int[]){ ((int)(val)) }));
			} else if (_t979.typ == 238 /* v.ast.PrefixExpr */) {
			} else {
				if ((field.expr).typ == 224 /* v.ast.Ident */) {
					if ((*field.expr._224).language == v__table__Language_c) {
						continue;
					}
				}
				v__token__Position pos = v__ast__Expr_position(field.expr);
				if (pos.pos == 0) {
					pos = field.pos;
				}
				v__checker__Checker_error(c, tos_lit("default value for enum has to be an integer"), pos);
			};
		} else {
			if (seen.len > 0) {
				int last = (*(int*)/*ee elem_typ */array_get(seen, seen.len - 1));
				if (last == _const_v__checker__int_max) {
					v__checker__Checker_error(c, tos_lit("enum value overflows"), field.pos);
				}
				array_push(&seen, _MOV((int[]){ last + 1 }));
			} else {
				array_push(&seen, _MOV((int[]){ 0 }));
			}
		}
	}
}

void v__checker__Checker_assign_stmt(v__checker__Checker* c, v__ast__AssignStmt* assign_stmt) {
	c->expected_type = _const_v__table__none_type;
	v__ast__Expr right_first = (*(v__ast__Expr*)/*ee elem_typ */array_get(assign_stmt->right, 0));
	int right_len = assign_stmt->right.len;
	v__table__Type right_type0 = _const_v__table__void_type;
	if ((right_first).typ == 215 /* v.ast.CallExpr */ || (right_first).typ == 225 /* v.ast.IfExpr */ || (right_first).typ == 233 /* v.ast.MatchExpr */) {
		right_type0 = v__checker__Checker_expr(c, right_first);
		assign_stmt->right_types = new_array_from_c_array(1, 1, sizeof(v__table__Type), _MOV((v__table__Type[1]){v__checker__Checker_check_expr_opt_call(c, right_first, right_type0)}));
		v__table__TypeSymbol* right_type_sym0 = v__table__Table_get_type_symbol(c->table, right_type0);
		if (right_type_sym0->kind == v__table__Kind_multi_return) {
			assign_stmt->right_types = v__table__TypeSymbol_mr_info(right_type_sym0).types;
			right_len = assign_stmt->right_types.len;
		} else if (right_type0 == _const_v__table__void_type) {
			right_len = 0;
		}
	}
	if (assign_stmt->left.len != right_len) {
		if ((right_first).typ == 215 /* v.ast.CallExpr */) {
			v__checker__Checker_error(c, _STR("assignment mismatch: %"PRId32"\000 variable(s) but `%.*s\000()` returns %"PRId32"\000 value(s)", 4, assign_stmt->left.len, (*right_first._215).name, right_len), assign_stmt->pos);
		} else {
			v__checker__Checker_error(c, _STR("assignment mismatch: %"PRId32"\000 variable(s) %"PRId32"\000 value(s)", 3, assign_stmt->left.len, right_len), assign_stmt->pos);
		}
		// Defer begin
		c->expected_type = _const_v__table__void_type;
		// Defer end
		return;
	}
	if ((right_first).typ == 238 /* v.ast.PrefixExpr */) {
		v__ast__PrefixExpr node = (*right_first._238);
		v__ast__Expr left_first = (*(v__ast__Expr*)/*ee elem_typ */array_get(assign_stmt->left, 0));
		if ((left_first).typ == 224 /* v.ast.Ident */) {
			v__ast__Ident assigned_var = (*left_first._224);
			if ((node.right).typ == 224 /* v.ast.Ident */) {
				v__ast__Scope* scope = v__ast__Scope_innermost(c->file->scope, node.pos.pos);
				{ /* if guard */ 
				Option_v__ast__Var_ptr _t983;
				if (_t983 = v__ast__Scope_find_var(scope, (*node.right._224).name), _t983.ok) {
					v__ast__Var* v = *(v__ast__Var**)_t983.data;
					right_type0 = v->typ;
					if (node.op == v__token__Kind_amp) {
						if (!v->is_mut && assigned_var.is_mut && !c->inside_unsafe) {
							v__checker__Checker_error(c, _STR("`%.*s\000` is immutable, cannot have a mutable reference to it", 2, (*node.right._224).name), node.pos);
						}
					}
				}}
			}
			if (node.op == v__token__Kind_arrow) {
				if (assigned_var.is_mut) {
					v__table__TypeSymbol* right_sym = v__table__Table_get_type_symbol(c->table, right_type0);
					if (right_sym->kind == v__table__Kind_chan) {
						v__table__Chan chan_info = v__table__TypeSymbol_chan_info(right_sym);
						if (v__table__Type_is_ptr(chan_info.elem_type) && !chan_info.is_mut) {
							v__checker__Checker_error(c, _STR("cannot have a mutable reference to object from `%.*s\000`", 2, right_sym->source_name), node.pos);
						}
					}
				}
			}
		}
	}
	bool is_decl = assign_stmt->op == v__token__Kind_decl_assign;
	// FOR IN array
	array _t984 = assign_stmt->left;
	for (int i = 0; i < _t984.len; ++i) {
		v__ast__Expr left = ((v__ast__Expr*)_t984.data)[i];
		if ((left).typ == 215 /* v.ast.CallExpr */) {
			v__checker__Checker_error(c, _STR("cannot call function `%.*s\000()` on the left side of an assignment", 2, (*left._215).name), (*left._215).pos);
		}
		bool is_blank_ident = v__ast__Expr_is_blank_ident(left);
		v__table__Type left_type = _const_v__table__void_type;
		if (!is_decl && !is_blank_ident) {
			if ((left).typ == 224 /* v.ast.Ident */ || (left).typ == 241 /* v.ast.SelectorExpr */) {
				c->prevent_sum_type_unwrapping_once = true;
			}
			left_type = v__checker__Checker_expr(c, left);
			c->expected_type = v__checker__Checker_unwrap_generic(c, left_type);
		}
		if (assign_stmt->right_types.len < assign_stmt->left.len) {
			v__table__Type right_type = v__checker__Checker_expr(c, (*(v__ast__Expr*)/*ee elem_typ */array_get(assign_stmt->right, i)));
			if (assign_stmt->right_types.len == i) {
				array_push(&assign_stmt->right_types, _MOV((v__table__Type[]){ v__checker__Checker_check_expr_opt_call(c, (*(v__ast__Expr*)/*ee elem_typ */array_get(assign_stmt->right, i)), right_type) }));
			}
		}
		v__ast__Expr right = (i < assign_stmt->right.len ? ((*(v__ast__Expr*)/*ee elem_typ */array_get(assign_stmt->right, i))) : ((*(v__ast__Expr*)/*ee elem_typ */array_get(assign_stmt->right, 0))));
		v__table__Type right_type = (*(v__table__Type*)/*ee elem_typ */array_get(assign_stmt->right_types, i));
		if (is_decl) {
			left_type = v__table__Table_mktyp(c->table, right_type);
			if (left_type == _const_v__table__int_type) {
				v__ast__Expr expr = right;
				bool negative = false;
				if ((right).typ == 238 /* v.ast.PrefixExpr */) {
					expr = (*right._238).right;
					if ((*right._238).op == v__token__Kind_minus) {
						negative = true;
					}
				}
				if ((expr).typ == 229 /* v.ast.IntegerLiteral */) {
					bool is_large = false;
					if ((*expr._229).val.len > 8) {
						i64 val = string_i64((*expr._229).val);
						if ((!negative && val > _const_v__checker__int_max) || (negative && -val < _const_v__checker__int_min)) {
							is_large = true;
						}
					}
					if (is_large) {
						v__checker__Checker_error(c, tos_lit("overflow in implicit type `int`, use explicit type casting instead"), (*expr._229).pos);
					}
				}
			}
			if (v__table__Type_has_flag(left_type, v__table__TypeFlag_optional)) {
				left_type = v__table__Type_clear_flag(left_type, v__table__TypeFlag_optional);
			}
		} else {
			v__checker__Checker_fail_if_immutable(c, left);
		}
		array_push(&assign_stmt->left_types, _MOV((v__table__Type[]){ left_type }));
		v__ast__Expr _t987 = left;
		if (_t987.typ == 224 /* v.ast.Ident */) {
			if ((*left._224).kind == v__ast__IdentKind_blank_ident) {
				left_type = right_type;
				(*(v__table__Type*)/*ee elem_typ */array_get(assign_stmt->left_types, i)) = right_type;
				if (!(assign_stmt->op == v__token__Kind_assign || assign_stmt->op == v__token__Kind_decl_assign)) {
					v__checker__Checker_error(c, tos_lit("cannot modify blank `_` identifier"), (*left._224).pos);
				}
			} else if (((*left._224).info).typ != 313 /* v.ast.IdentVar */) {
				v__checker__Checker_error(c, _STR("cannot assign to %.*s\000 `%.*s\000`", 3, v__ast__IdentKind_str((*left._224).kind), (*left._224).name), (*left._224).pos);
			} else {
				if (is_decl) {
					v__checker__Checker_check_valid_snake_case(c, (*left._224).name, tos_lit("variable name"), (*left._224).pos);
				}
				v__ast__IdentVar ident_var_info = /* as */ *(v__ast__IdentVar*)__as_cast(((*left._224).info)._313, ((*left._224).info).typ, /*expected:*/313);
				if (ident_var_info.share == v__table__ShareType_shared_t) {
					left_type = v__table__Type_set_flag(left_type, v__table__TypeFlag_shared_f);
				}
				if (ident_var_info.share == v__table__ShareType_atomic_t) {
					left_type = v__table__Type_set_flag(left_type, v__table__TypeFlag_atomic_f);
				}
				(*(v__table__Type*)/*ee elem_typ */array_get(assign_stmt->left_types, i)) = left_type;
				ident_var_info.typ = left_type;
				(*left._224).info = /* sum type cast 4 */ (v__ast__IdentInfo){._313 = memdup(&(v__ast__IdentVar[]){ident_var_info}, sizeof(v__ast__IdentVar)), .typ = 313 /* v.ast.IdentVar */};
				if (left_type != 0) {
					v__ast__ScopeObject _t988 = (*left._224).obj;
					if (_t988.typ == 277 /* v.ast.Var */) {
						(*(*left._224).obj._277).typ = left_type;
					} else if (_t988.typ == 276 /* v.ast.GlobalField */) {
						(*(*left._224).obj._276).typ = left_type;
					} else {
					};
				}
			}
		} else if (_t987.typ == 238 /* v.ast.PrefixExpr */) {
			if ((*left._238).op == v__token__Kind_mul && !c->inside_unsafe) {
				v__checker__Checker_error(c, tos_lit("modifying variables via dereferencing can only be done in `unsafe` blocks"), assign_stmt->pos);
			}
			if (is_decl) {
				v__checker__Checker_error(c, tos_lit("non-name on the left side of `:=`"), (*left._238).pos);
			}
		} else {
			if (is_decl) {
				v__checker__Checker_error(c, _STR("non-name `%.*s\000` on left side of `:=`", 2, v__ast__Expr_str(left)), v__ast__Expr_position(left));
			}
		};
		v__table__Type left_type_unwrapped = v__checker__Checker_unwrap_generic(c, left_type);
		v__table__Type right_type_unwrapped = v__checker__Checker_unwrap_generic(c, right_type);
		if (right_type_unwrapped == 0) {
			continue;
		}
		v__table__TypeSymbol* left_sym = v__table__Table_get_type_symbol(c->table, left_type_unwrapped);
		v__table__TypeSymbol* right_sym = v__table__Table_get_type_symbol(c->table, right_type_unwrapped);
		bool left_is_ptr = v__table__Type_is_ptr(left_type) || v__table__TypeSymbol_is_pointer(left_sym);
		bool right_is_ptr = v__table__Type_is_ptr(right_type) || v__table__TypeSymbol_is_pointer(right_sym);
		if (left_is_ptr && !(assign_stmt->op == v__token__Kind_assign || assign_stmt->op == v__token__Kind_decl_assign) && !c->inside_unsafe) {
			v__checker__Checker_warn(c, tos_lit("pointer arithmetic is only allowed in `unsafe` blocks"), assign_stmt->pos);
		}
		if (c->pref->translated) {
			continue;
		}
		if (left_is_ptr && ((right).typ == 246 /* v.ast.StructInit */ || !right_is_ptr) && !v__table__TypeSymbol_is_number(right_sym)) {
			string left_name = v__table__Table_type_to_str(c->table, left_type_unwrapped);
			v__table__Type rtype = right_type_unwrapped;
			if (v__table__Type_is_ptr(rtype)) {
				rtype = v__table__Type_deref(rtype);
			}
			string right_name = v__table__Table_type_to_str(c->table, rtype);
			v__checker__Checker_error(c, _STR("mismatched types `%.*s\000` and `%.*s\000`", 3, left_name, right_name), assign_stmt->pos);
		}
		v__token__Kind _t989 = assign_stmt->op;
		if (_t989 == v__token__Kind_assign) {
		} else if (_t989 == v__token__Kind_plus_assign) {
			if (!v__table__TypeSymbol_is_number(left_sym) && left_type != _const_v__table__string_type && !v__table__TypeSymbol_is_pointer(left_sym)) {
				v__checker__Checker_error(c, _STR("operator += not defined on left operand type `%.*s\000`", 2, left_sym->source_name), v__ast__Expr_position(left));
			} else if (!v__table__TypeSymbol_is_number(right_sym) && right_type != _const_v__table__string_type && !v__table__TypeSymbol_is_pointer(right_sym)) {
				v__checker__Checker_error(c, _STR("operator += not defined on right operand type `%.*s\000`", 2, right_sym->source_name), v__ast__Expr_position(right));
			}
			if ((right).typ == 229 /* v.ast.IntegerLiteral */ && string_int(v__ast__Expr_str(right)) == 1) {
				v__checker__Checker_error(c, tos_lit("use `++` instead of `+= 1`"), assign_stmt->pos);
			}
		} else if (_t989 == v__token__Kind_minus_assign) {
			if (!v__table__TypeSymbol_is_number(left_sym) && !v__table__TypeSymbol_is_pointer(left_sym)) {
				v__checker__Checker_error(c, _STR("operator -= not defined on left operand type `%.*s\000`", 2, left_sym->source_name), v__ast__Expr_position(left));
			} else if (!v__table__TypeSymbol_is_number(right_sym) && !v__table__TypeSymbol_is_pointer(right_sym)) {
				v__checker__Checker_error(c, _STR("operator -= not defined on right operand type `%.*s\000`", 2, right_sym->source_name), v__ast__Expr_position(right));
			}
			if ((right).typ == 229 /* v.ast.IntegerLiteral */ && string_int(v__ast__Expr_str(right)) == 1) {
				v__checker__Checker_error(c, tos_lit("use `--` instead of `-= 1`"), assign_stmt->pos);
			}
		} else if (_t989 == v__token__Kind_mult_assign || _t989 == v__token__Kind_div_assign) {
			if (!v__table__TypeSymbol_is_number(left_sym) && !v__table__TypeSymbol_is_int(v__table__Table_get_final_type_symbol(c->table, left_type_unwrapped))) {
				v__checker__Checker_error(c, _STR("operator %.*s\000 not defined on left operand type `%.*s\000`", 3, v__token__Kind_str(assign_stmt->op), left_sym->source_name), v__ast__Expr_position(left));
			} else if (!v__table__TypeSymbol_is_number(right_sym) && !v__table__TypeSymbol_is_int(v__table__Table_get_final_type_symbol(c->table, left_type_unwrapped))) {
				v__checker__Checker_error(c, _STR("operator %.*s\000 not defined on right operand type `%.*s\000`", 3, v__token__Kind_str(assign_stmt->op), right_sym->source_name), v__ast__Expr_position(right));
			}
		} else if (_t989 == v__token__Kind_and_assign || _t989 == v__token__Kind_or_assign || _t989 == v__token__Kind_xor_assign || _t989 == v__token__Kind_mod_assign || _t989 == v__token__Kind_left_shift_assign || _t989 == v__token__Kind_right_shift_assign) {
			if (!v__table__TypeSymbol_is_int(left_sym) && !v__table__TypeSymbol_is_int(v__table__Table_get_final_type_symbol(c->table, left_type_unwrapped))) {
				v__checker__Checker_error(c, _STR("operator %.*s\000 not defined on left operand type `%.*s\000`", 3, v__token__Kind_str(assign_stmt->op), left_sym->source_name), v__ast__Expr_position(left));
			} else if (!v__table__TypeSymbol_is_int(right_sym) && !v__table__TypeSymbol_is_int(v__table__Table_get_final_type_symbol(c->table, right_type_unwrapped))) {
				v__checker__Checker_error(c, _STR("operator %.*s\000 not defined on right operand type `%.*s\000`", 3, v__token__Kind_str(assign_stmt->op), right_sym->source_name), v__ast__Expr_position(right));
			}
		} else {
		};
		if (!is_blank_ident && right_sym->kind != v__table__Kind_placeholder) {
			Option_void _t990 = v__checker__Checker_check_expected(c, right_type_unwrapped, left_type_unwrapped);
			if (!_t990.ok && !_t990.is_none) {
				string err = _t990.v_error;
				int errcode = _t990.ecode;
				v__checker__Checker_error(c, _STR("cannot assign to `%.*s\000`: %.*s", 2, v__ast__Expr_str(left), err), v__ast__Expr_position(right));
			};
		}
	}
// Defer begin
c->expected_type = _const_v__table__void_type;
// Defer end
}

VV_LOCAL_SYMBOL void v__checker__scope_register_it(v__ast__Scope* s, v__token__Position pos, v__table__Type typ) {
	v__ast__Scope_register(s, tos_lit("it"), /* sum type cast 4 */ (v__ast__ScopeObject){._277 = memdup(&(v__ast__Var[]){(v__ast__Var){.name = tos_lit("it"),.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.typ = typ,.sum_type_casts = __new_array(0, 1, sizeof(v__table__Type)),.pos = pos,.is_used = true,.is_changed = 0,}}, sizeof(v__ast__Var)), .typ = 277 /* v.ast.Var */});
}

VV_LOCAL_SYMBOL void v__checker__scope_register_ab(v__ast__Scope* s, v__token__Position pos, v__table__Type typ) {
	v__ast__Scope_register(s, tos_lit("a"), /* sum type cast 4 */ (v__ast__ScopeObject){._277 = memdup(&(v__ast__Var[]){(v__ast__Var){.name = tos_lit("a"),.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.typ = typ,.sum_type_casts = __new_array(0, 1, sizeof(v__table__Type)),.pos = pos,.is_used = true,.is_changed = 0,}}, sizeof(v__ast__Var)), .typ = 277 /* v.ast.Var */});
	v__ast__Scope_register(s, tos_lit("b"), /* sum type cast 4 */ (v__ast__ScopeObject){._277 = memdup(&(v__ast__Var[]){(v__ast__Var){.name = tos_lit("b"),.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.typ = typ,.sum_type_casts = __new_array(0, 1, sizeof(v__table__Type)),.pos = pos,.is_used = true,.is_changed = 0,}}, sizeof(v__ast__Var)), .typ = 277 /* v.ast.Var */});
}

VV_LOCAL_SYMBOL void v__checker__Checker_check_array_init_para_type(v__checker__Checker* c, string para, v__ast__Expr expr, v__token__Position pos) {
	v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(c->table, v__checker__Checker_expr(c, expr));
	if (!(sym->kind == v__table__Kind_int || sym->kind == v__table__Kind_any_int)) {
		v__checker__Checker_error(c, _STR("array %.*s\000 needs to be an int", 2, para), pos);
	}
}

v__table__Type v__checker__Checker_array_init(v__checker__Checker* c, v__ast__ArrayInit* array_init) {
	v__table__Type elem_type = _const_v__table__void_type;
	if (array_init->typ != _const_v__table__void_type) {
		if (array_init->exprs.len == 0) {
			if (array_init->has_cap) {
				v__checker__Checker_check_array_init_para_type(c, tos_lit("cap"), array_init->cap_expr, array_init->pos);
			}
			if (array_init->has_len) {
				v__checker__Checker_check_array_init_para_type(c, tos_lit("len"), array_init->len_expr, array_init->pos);
			}
		}
		v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(c->table, array_init->elem_type);
		if (array_init->has_default) {
			v__checker__Checker_expr(c, array_init->default_expr);
		}
		if (sym->kind == v__table__Kind_sum_type) {
			if (array_init->has_len && !array_init->has_default) {
				v__checker__Checker_error(c, tos_lit("cannot initalize sum type array without default value"), array_init->elem_type_pos);
			}
		}
		if (sym->kind == v__table__Kind_placeholder) {
			v__checker__Checker_error(c, _STR("unknown type `%.*s\000`", 2, sym->source_name), array_init->elem_type_pos);
		}
		return array_init->typ;
	}
	if (array_init->exprs.len == 0) {
		v__table__TypeSymbol* type_sym = v__table__Table_get_type_symbol(c->table, c->expected_type);
		if (type_sym->kind != v__table__Kind_array) {
			v__checker__Checker_error(c, tos_lit("array_init: no type specified (maybe: `[]Type{}` instead of `[]`)"), array_init->pos);
			return _const_v__table__void_type;
		}
		v__table__Array array_info = v__table__TypeSymbol_array_info(type_sym);
		array_init->elem_type = array_info.elem_type;
		return c->expected_type;
	}
	if (array_init->exprs.len > 0 && array_init->elem_type == _const_v__table__void_type) {
		v__table__Type expected_value_type = _const_v__table__void_type;
		bool expecting_interface_array = false;
		int cap = array_init->exprs.len;
		array_v__table__Type interface_types = __new_array_with_default(0, cap, sizeof(v__table__Type), 0);
		if (c->expected_type != 0) {
			expected_value_type = v__table__Table_value_type(c->table, c->expected_type);
			if (v__table__Table_get_type_symbol(c->table, expected_value_type)->kind == v__table__Kind_interface_) {
				expecting_interface_array = true;
				array_init->interface_type = expected_value_type;
				array_init->is_interface = true;
			}
		}
		// FOR IN array
		array _t991 = array_init->exprs;
		for (int i = 0; i < _t991.len; ++i) {
			v__ast__Expr expr = ((v__ast__Expr*)_t991.data)[i];
			v__table__Type typ = v__checker__Checker_expr(c, expr);
			if (expecting_interface_array) {
				if (i == 0) {
					elem_type = expected_value_type;
					c->expected_type = elem_type;
				}
				array_push(&interface_types, _MOV((v__table__Type[]){ typ }));
				continue;
			}
			if (i == 0) {
				elem_type = v__table__Table_mktyp(c->table, typ);
				c->expected_type = elem_type;
				continue;
			}
			Option_void _t993 = v__checker__Checker_check_expected(c, typ, elem_type);
			if (!_t993.ok && !_t993.is_none) {
				string err = _t993.v_error;
				int errcode = _t993.ecode;
				v__checker__Checker_error(c, _STR("invalid array element: %.*s", 1, err), v__ast__Expr_position(expr));
			};
		}
		if (expecting_interface_array) {
			array_init->interface_types = interface_types;
		}
		if (array_init->is_fixed) {
			int idx = v__table__Table_find_or_register_array_fixed(c->table, elem_type, array_init->exprs.len, 1);
			array_init->typ = v__table__new_type(idx);
		} else {
			v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(c->table, elem_type);
			int idx = v__table__Table_find_or_register_array(c->table, elem_type, 1, sym->mod);
			array_init->typ = v__table__new_type(idx);
		}
		array_init->elem_type = elem_type;
	} else if (array_init->is_fixed && array_init->exprs.len == 1 && array_init->elem_type != _const_v__table__void_type) {
		int fixed_size = 1;
		v__ast__Expr init_expr = (*(v__ast__Expr*)/*ee elem_typ */array_get(array_init->exprs, 0));
		v__ast__Expr _t994 = init_expr;
		if (_t994.typ == 229 /* v.ast.IntegerLiteral */) {
			fixed_size = string_int((*init_expr._229).val);
		} else if (_t994.typ == 224 /* v.ast.Ident */) {
			string full_const_name = string_add(string_add((*init_expr._224).mod, tos_lit(".")), (*init_expr._224).name);
			{ /* if guard */ 
			Option_v__ast__ConstField_ptr _t995;
			if (_t995 = v__ast__Scope_find_const(c->file->global_scope, full_const_name), _t995.ok) {
				v__ast__ConstField* obj = *(v__ast__ConstField**)_t995.data;
				{ /* if guard */ 
				Option_int _t996;
				if (_t996 = v__checker__const_int_value(*obj), _t996.ok) {
					int cint = *(int*)_t996.data;
					fixed_size = cint;
				}}
			} else {
				string err = _t995.v_error;
				int errcode = _t995.ecode;
				v__checker__Checker_error(c, _STR("non existent integer const %.*s\000 while initializing the size of a static array", 2, full_const_name), array_init->pos);
			}}
		} else {
			v__checker__Checker_error(c, tos_lit("expecting `int` for fixed size"), array_init->pos);
		};
		int idx = v__table__Table_find_or_register_array_fixed(c->table, array_init->elem_type, fixed_size, 1);
		v__table__Type array_type = v__table__new_type(idx);
		array_init->typ = array_type;
	}
	return array_init->typ;
}

VV_LOCAL_SYMBOL Option_int v__checker__const_int_value(v__ast__ConstField cfield) {
	{ /* if guard */ 
	Option_v__ast__IntegerLiteral _t997;
	if (_t997 = v__checker__is_const_integer(cfield), _t997.ok) {
		v__ast__IntegerLiteral cint = *(v__ast__IntegerLiteral*)_t997.data;
		Option_int _t998;
		opt_ok2(&(int[]) { string_int(cint.val) }, (OptionBase*)(&_t998), sizeof(int));
		return _t998;
	}}
	Option _t999 = opt_none();
	return *(Option_int*)&_t999;
}

VV_LOCAL_SYMBOL Option_v__ast__IntegerLiteral v__checker__is_const_integer(v__ast__ConstField cfield) {
	v__ast__Expr _t1000 = cfield.expr;
	if (_t1000.typ == 229 /* v.ast.IntegerLiteral */) {
		Option_v__ast__IntegerLiteral _t1001;
		opt_ok2(&(v__ast__IntegerLiteral[]) { (*cfield.expr._229) }, (OptionBase*)(&_t1001), sizeof(v__ast__IntegerLiteral));
		return _t1001;
	} else {
	};
	Option _t1002 = opt_none();
	return *(Option_v__ast__IntegerLiteral*)&_t1002;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL void v__checker__Checker_check_loop_label(v__checker__Checker* c, string label, v__token__Position pos) {
	if (label.len == 0) {
		return;
	}
	if (c->loop_label.len != 0) {
		v__checker__Checker_error(c, tos_lit("nesting of labelled `for` loops is not supported"), pos);
		return;
	}
	c->loop_label = label;
}

VV_LOCAL_SYMBOL void v__checker__Checker_stmt(v__checker__Checker* c, v__ast__Stmt node) {
	#if defined(CUSTOM_DEFINE_trace_checker)
	{
	}
	#endif
	v__ast__Stmt _t1003 = node;
	if (_t1003.typ == 251 /* v.ast.AssertStmt */) {
		v__table__Type cur_exp_typ = c->expected_type;
		v__table__Type assert_type = v__checker__Checker_expr(c, (*node._251).expr);
		if (assert_type != _const_v__table__bool_type_idx) {
			string atype_name = v__table__Table_get_type_symbol(c->table, assert_type)->name;
			v__checker__Checker_error(c, _STR("assert can be used only with `bool` expressions, but found `%.*s\000` instead", 2, atype_name), (*node._251).pos);
		}
		c->expected_type = cur_exp_typ;
	} else if (_t1003.typ == 252 /* v.ast.AssignStmt */) {
		v__checker__Checker_assign_stmt(c, (voidptr)&/*qq*/(*node._252));
	} else if (_t1003.typ == 253 /* v.ast.Block */) {
		if ((*node._253).is_unsafe) {
			// assert
			if (!c->inside_unsafe) {} else {
				VAssertMetaInfo v_assert_meta_info__t1004;
				memset(&v_assert_meta_info__t1004, 0, sizeof(VAssertMetaInfo));
				v_assert_meta_info__t1004.fpath = tos_lit("/tmp/gen_vc/v/vlib/v/checker/checker.v");
				v_assert_meta_info__t1004.line_nr = 2488;
				v_assert_meta_info__t1004.fn_name = tos_lit("stmt");
				v_assert_meta_info__t1004.src = tos_lit("!c.inside_unsafe");
				__print_assert_failure(&v_assert_meta_info__t1004);
				v_panic(tos_lit("Assertion failed..."));
				exit(1);
			}
			c->inside_unsafe = true;
			v__checker__Checker_stmts(c, (*node._253).stmts);
			c->inside_unsafe = false;
		} else {
			v__checker__Checker_stmts(c, (*node._253).stmts);
		}
	} else if (_t1003.typ == 254 /* v.ast.BranchStmt */) {
		if (c->in_for_count == 0) {
			v__checker__Checker_error(c, _STR("%.*s\000 statement not within a loop", 2, v__token__Kind_str((*node._254).kind)), (*node._254).pos);
		}
		if ((*node._254).label.len > 0) {
			if (string_ne((*node._254).label, c->loop_label)) {
				v__checker__Checker_error(c, _STR("invalid label name `%.*s\000`", 2, (*node._254).label), (*node._254).pos);
			}
		}
	} else if (_t1003.typ == 255 /* v.ast.CompFor */) {
		v__checker__Checker_stmts(c, (*node._255).stmts);
	} else if (_t1003.typ == 256 /* v.ast.ConstDecl */) {
		c->inside_const = true;
		v__checker__Checker_const_decl(c, (voidptr)&/*qq*/(*node._256));
		c->inside_const = false;
	} else if (_t1003.typ == 257 /* v.ast.DeferStmt */) {
		v__checker__Checker_stmts(c, (*node._257).stmts);
	} else if (_t1003.typ == 258 /* v.ast.EnumDecl */) {
		v__checker__Checker_enum_decl(c, (*node._258));
	} else if (_t1003.typ == 259 /* v.ast.ExprStmt */) {
		(*node._259).typ = v__checker__Checker_expr(c, (*node._259).expr);
		c->expected_type = _const_v__table__void_type;
		v__checker__Checker_check_expr_opt_call(c, (*node._259).expr, _const_v__table__void_type);
	} else if (_t1003.typ == 151 /* v.ast.FnDecl */) {
		v__checker__Checker_fn_decl(c, (voidptr)&/*qq*/(*node._151));
	} else if (_t1003.typ == 260 /* v.ast.ForCStmt */) {
		c->in_for_count++;
		v__checker__Checker_stmt(c, (*node._260).init);
		v__checker__Checker_expr(c, (*node._260).cond);
		v__checker__Checker_stmt(c, (*node._260).inc);
		v__checker__Checker_check_loop_label(c, (*node._260).label, (*node._260).pos);
		v__checker__Checker_stmts(c, (*node._260).stmts);
		c->loop_label = tos_lit("");
		c->in_for_count--;
	} else if (_t1003.typ == 261 /* v.ast.ForInStmt */) {
		c->in_for_count++;
		v__table__Type typ = v__checker__Checker_expr(c, (*node._261).cond);
		int typ_idx = v__table__Type_idx(typ);
		if ((*node._261).key_var.len > 0 && string_ne((*node._261).key_var, tos_lit("_"))) {
			v__checker__Checker_check_valid_snake_case(c, (*node._261).key_var, tos_lit("variable name"), (*node._261).pos);
		}
		if ((*node._261).val_var.len > 0 && string_ne((*node._261).val_var, tos_lit("_"))) {
			v__checker__Checker_check_valid_snake_case(c, (*node._261).val_var, tos_lit("variable name"), (*node._261).pos);
		}
		if ((*node._261).is_range) {
			v__table__Type high_type = v__checker__Checker_expr(c, (*node._261).high);
			int high_type_idx = v__table__Type_idx(high_type);
			if (_IN(int, typ_idx, _const_v__table__integer_type_idxs) && !_IN(int, high_type_idx, _const_v__table__integer_type_idxs)) {
				v__checker__Checker_error(c, tos_lit("range types do not match"), v__ast__Expr_position((*node._261).cond));
			} else if (_IN(int, typ_idx, _const_v__table__float_type_idxs) || _IN(int, high_type_idx, _const_v__table__float_type_idxs)) {
				v__checker__Checker_error(c, tos_lit("range type can not be float"), v__ast__Expr_position((*node._261).cond));
			} else if (typ_idx == _const_v__table__bool_type_idx || high_type_idx == _const_v__table__bool_type_idx) {
				v__checker__Checker_error(c, tos_lit("range type can not be bool"), v__ast__Expr_position((*node._261).cond));
			} else if (typ_idx == _const_v__table__string_type_idx || high_type_idx == _const_v__table__string_type_idx) {
				v__checker__Checker_error(c, tos_lit("range type can not be string"), v__ast__Expr_position((*node._261).cond));
			}
		} else {
			v__ast__Scope* scope = v__ast__Scope_innermost(c->file->scope, (*node._261).pos.pos);
			v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(c->table, typ);
			if (sym->kind == v__table__Kind_map && !((*node._261).key_var.len > 0 && (*node._261).val_var.len > 0)) {
				v__checker__Checker_error(c, string_add(tos_lit("declare a key and a value variable when ranging a map: `for key, val in map {`\n"), tos_lit("use `_` if you do not need the variable")), (*node._261).pos);
			}
			if ((*node._261).key_var.len > 0) {
				v__table__Kind _t1005 = sym->kind;
								v__table__Type key_type = ((_t1005 == v__table__Kind_map) ? (v__table__TypeSymbol_map_info(sym).key_type) : (_const_v__table__int_type));
				(*node._261).key_type = key_type;
				v__ast__Scope_update_var_type(scope, (*node._261).key_var, key_type);
			}
			v__table__Type value_type = v__table__Table_value_type(c->table, typ);
			if (value_type == _const_v__table__void_type || v__table__Type_has_flag(typ, v__table__TypeFlag_optional)) {
				if (typ != _const_v__table__void_type) {
					v__checker__Checker_error(c, _STR("for in: cannot index `%.*s\000`", 2, v__table__Table_type_to_str(c->table, typ)), v__ast__Expr_position((*node._261).cond));
				}
			}
			if ((*node._261).val_is_mut) {
				value_type = v__table__Type_to_ptr(value_type);
			}
			(*node._261).cond_type = typ;
			(*node._261).kind = sym->kind;
			(*node._261).val_type = value_type;
			v__ast__Scope_update_var_type(scope, (*node._261).val_var, value_type);
		}
		v__checker__Checker_check_loop_label(c, (*node._261).label, (*node._261).pos);
		v__checker__Checker_stmts(c, (*node._261).stmts);
		c->loop_label = tos_lit("");
		c->in_for_count--;
	} else if (_t1003.typ == 262 /* v.ast.ForStmt */) {
		c->in_for_count++;
		c->expected_type = _const_v__table__bool_type;
		v__table__Type typ = v__checker__Checker_expr(c, (*node._262).cond);
		if (!(*node._262).is_inf && v__table__Type_idx(typ) != _const_v__table__bool_type_idx && !c->pref->translated) {
			v__checker__Checker_error(c, tos_lit("non-bool used as for condition"), (*node._262).pos);
		}
		v__checker__Checker_check_loop_label(c, (*node._262).label, (*node._262).pos);
		v__checker__Checker_stmts(c, (*node._262).stmts);
		c->loop_label = tos_lit("");
		c->in_for_count--;
	} else if (_t1003.typ == 263 /* v.ast.GlobalDecl */) {
		// FOR IN array
		array _t1006 = (*node._263).fields;
		for (int _t1007 = 0; _t1007 < _t1006.len; ++_t1007) {
			v__ast__GlobalField field = ((v__ast__GlobalField*)_t1006.data)[_t1007];
			v__checker__Checker_check_valid_snake_case(c, field.name, tos_lit("global name"), field.pos);
			if (_IN(string, field.name, c->global_names)) {
				v__checker__Checker_error(c, _STR("duplicate global `%.*s\000`", 2, field.name), field.pos);
			}
			array_push(&c->global_names, _MOV((string[]){ string_clone(field.name) }));
		}
	} else if (_t1003.typ == 264 /* v.ast.GoStmt */) {
		if (((*node._264).call_expr).typ != 215 /* v.ast.CallExpr */) {
			v__checker__Checker_error(c, tos_lit("expression in `go` must be a function call"), v__ast__Expr_position((*node._264).call_expr));
		}
		v__checker__Checker_expr(c, (*node._264).call_expr);
		if (((*node._264).call_expr).typ == 215 /* v.ast.CallExpr */) {
			// FOR IN array
			array _t1009 = (*(*node._264).call_expr._215).args;
			for (int _t1010 = 0; _t1010 < _t1009.len; ++_t1010) {
				v__ast__CallArg arg = ((v__ast__CallArg*)_t1009.data)[_t1010];
				if (arg.is_mut && !v__table__Type_is_ptr(arg.typ)) {
					v__checker__Checker_error(c, tos_lit("function in `go` statement cannot contain mutable non-reference arguments"), v__ast__Expr_position(arg.expr));
				}
			}
			if ((*(*node._264).call_expr._215).is_method && v__table__Type_is_ptr((*(*node._264).call_expr._215).receiver_type) && !v__table__Type_is_ptr((*(*node._264).call_expr._215).left_type)) {
				v__checker__Checker_error(c, tos_lit("method in `go` statement cannot have non-reference mutable receiver"), v__ast__Expr_position((*(*node._264).call_expr._215).left));
			}
		}
	} else if (_t1003.typ == 265 /* v.ast.GotoLabel */) {
	} else if (_t1003.typ == 266 /* v.ast.GotoStmt */) {
	} else if (_t1003.typ == 267 /* v.ast.HashStmt */) {
		v__checker__Checker_hash_stmt(c, (voidptr)&/*qq*/(*node._267));
	} else if (_t1003.typ == 268 /* v.ast.Import */) {
		v__checker__Checker_import_stmt(c, (*node._268));
	} else if (_t1003.typ == 269 /* v.ast.InterfaceDecl */) {
		v__checker__Checker_interface_decl(c, (*node._269));
	} else if (_t1003.typ == 270 /* v.ast.Module */) {
		c->mod = (*node._270).name;
		c->is_builtin_mod = (string_eq((*node._270).name, tos_lit("builtin")) || string_eq((*node._270).name, tos_lit("os")) || string_eq((*node._270).name, tos_lit("strconv")));
		v__checker__Checker_check_valid_snake_case(c, (*node._270).name, tos_lit("module name"), (*node._270).pos);
	} else if (_t1003.typ == 271 /* v.ast.Return */) {
		v__checker__Checker_return_stmt(c, (voidptr)&/*qq*/(*node._271));
		c->scope_returns = true;
	} else if (_t1003.typ == 272 /* v.ast.SqlStmt */) {
		v__checker__Checker_sql_stmt(c, (voidptr)&/*qq*/(*node._272));
	} else if (_t1003.typ == 273 /* v.ast.StructDecl */) {
		v__checker__Checker_struct_decl(c, (*node._273));
	} else if (_t1003.typ == 207 /* v.ast.TypeDecl */) {
		v__checker__Checker_type_decl(c, (*node._207));
	};
}

VV_LOCAL_SYMBOL void v__checker__Checker_hash_stmt(v__checker__Checker* c, v__ast__HashStmt* node) {
	if (c->skip_flags) {
		return;
	}
	if (c->pref->backend == v__pref__Backend_js) {
		if (!string_ends_with(c->file->path, tos_lit(".js.v"))) {
			v__checker__Checker_error(c, tos_lit("Hash statements are only allowed in backend specific files such \"x.js.v\""), node->pos);
		}
		if (string_eq(c->mod, tos_lit("main"))) {
			v__checker__Checker_error(c, tos_lit("Hash statements are not allowed in the main module. Please place them in a separate module."), node->pos);
		}
		return;
	}
	if (string_eq(node->kind, tos_lit("include"))) {
		string flag = node->main;
		if (string_contains(flag, tos_lit("@VROOT"))) {
			Option_string _t1011 = v__util__resolve_vroot(flag, c->file->path);
			if (!_t1011.ok) {
				string err = _t1011.v_error;
				int errcode = _t1011.ecode;
				v__checker__Checker_error(c, err, node->pos);
				return;
			}
 			string vroot = *(string*) _t1011.data;
			node->val = _STR("include %.*s", 1, vroot);
			node->main = vroot;
		}
		string flag_no_comment = string_trim_space(string_all_before(flag, tos_lit("//")));
		if (!((string_starts_with(flag_no_comment, tos_lit("\"")) && string_ends_with(flag_no_comment, tos_lit("\""))) || (string_starts_with(flag_no_comment, tos_lit("<")) && string_ends_with(flag_no_comment, tos_lit(">"))))) {
			v__checker__Checker_error(c, tos_lit("including C files should use either `\"header_file.h\"` or `<header_file.h>` quoting"), node->pos);
		}
	} else if (string_eq(node->kind, tos_lit("pkgconfig"))) {
		array_string args = (string_contains(node->main, tos_lit("--")) ? (string_split(node->main, tos_lit(" "))) : (string_split(_STR("--cflags --libs %.*s", 1, node->main), tos_lit(" "))));
		Option_v__pkgconfig__Main_ptr _t1012 = v__pkgconfig__main(args);
		if (!_t1012.ok) {
			string err = _t1012.v_error;
			int errcode = _t1012.ecode;
			v__checker__Checker_error(c, err, node->pos);
			return;
		}
 		v__pkgconfig__Main* m = *(v__pkgconfig__Main**) _t1012.data;
		Option_string _t1013 = v__pkgconfig__Main_run(m);
		if (!_t1013.ok) {
			string err = _t1013.v_error;
			int errcode = _t1013.ecode;
			v__checker__Checker_error(c, err, node->pos);
			return;
		}
 		string cflags = *(string*) _t1013.data;
		Option_bool _t1014 = v__table__Table_parse_cflag(c->table, cflags, c->mod, c->pref->compile_defines_all);
		if (!_t1014.ok) {
			string err = _t1014.v_error;
			int errcode = _t1014.ecode;
			v__checker__Checker_error(c, err, node->pos);
			return;
		};
	} else if (string_eq(node->kind, tos_lit("flag"))) {
		string flag = node->main;
		if (string_contains(flag, tos_lit("@VROOT"))) {
			Option_string _t1015 = v__util__resolve_vroot(flag, c->file->path);
			if (!_t1015.ok) {
				string err = _t1015.v_error;
				int errcode = _t1015.ecode;
				v__checker__Checker_error(c, err, node->pos);
				return;
			}
 			flag = *(string*) _t1015.data;
		}
		// FOR IN array
		array _t1016 = new_array_from_c_array(4, 4, sizeof(string), _MOV((string[4]){tos_lit("@VMOD"), tos_lit("@VMODULE"), tos_lit("@VPATH"), tos_lit("@VLIB_PATH")}));
		for (int _t1017 = 0; _t1017 < _t1016.len; ++_t1017) {
			string deprecated = ((string*)_t1016.data)[_t1017];
			if (string_contains(flag, deprecated)) {
				v__checker__Checker_error(c, _STR("%.*s\000 had been deprecated, use @VROOT instead.", 2, deprecated), node->pos);
			}
		}
		Option_bool _t1018 = v__table__Table_parse_cflag(c->table, flag, c->mod, c->pref->compile_defines_all);
		if (!_t1018.ok) {
			string err = _t1018.v_error;
			int errcode = _t1018.ecode;
			v__checker__Checker_error(c, err, node->pos);
		};
	} else {
		if (string_ne(node->kind, tos_lit("define"))) {
			v__checker__Checker_error(c, _STR("expected `#define`, `#flag`, `#include` or `#pkgconfig` not %.*s", 1, node->val), node->pos);
		}
	}
}

VV_LOCAL_SYMBOL void v__checker__Checker_import_stmt(v__checker__Checker* c, v__ast__Import imp) {
	// FOR IN array
	array _t1019 = imp.syms;
	for (int _t1020 = 0; _t1020 < _t1019.len; ++_t1020) {
		v__ast__ImportSymbol sym = ((v__ast__ImportSymbol*)_t1019.data)[_t1020];
		string name = _STR("%.*s\000.%.*s", 2, imp.mod, sym.name);
		if (sym.kind == v__ast__ImportSymbolKind_fn_) {
			Option_v__table__Fn _t1021 = v__table__Table_find_fn(c->table, name);
			if (!_t1021.ok) {
				string err = _t1021.v_error;
				int errcode = _t1021.ecode;
				v__checker__Checker_error(c, _STR("module `%.*s\000` has no public fn named `%.*s\000()`", 3, imp.mod, sym.name), sym.pos);
			};
		}
		if (sym.kind == v__ast__ImportSymbolKind_type_) {
			{ /* if guard */ 
			Option_v__table__TypeSymbol _t1022;
			if (_t1022 = v__table__Table_find_type(c->table, name), _t1022.ok) {
				v__table__TypeSymbol type_sym = *(v__table__TypeSymbol*)_t1022.data;
				if (type_sym.kind == v__table__Kind_placeholder || !type_sym.is_public) {
					v__checker__Checker_error(c, _STR("module `%.*s\000` has no public type `%.*s\000{}`", 3, imp.mod, sym.name), sym.pos);
				}
			} else {
				string err = _t1022.v_error;
				int errcode = _t1022.ecode;
				v__checker__Checker_error(c, _STR("module `%.*s\000` has no public type `%.*s\000{}`", 3, imp.mod, sym.name), sym.pos);
			}}
		}
	}
}

VV_LOCAL_SYMBOL void v__checker__Checker_stmts(v__checker__Checker* c, array_v__ast__Stmt stmts) {
	v__token__Position unreachable = (v__token__Position){.len = 0,.line_nr = -1,.pos = 0,};
	c->expected_type = _const_v__table__void_type;
	// FOR IN array
	array _t1023 = stmts;
	for (int _t1024 = 0; _t1024 < _t1023.len; ++_t1024) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)_t1023.data)[_t1024];
		if (c->scope_returns) {
			if (unreachable.line_nr == -1) {
				unreachable = v__ast__Stmt_position(stmt);
			}
		}
		v__checker__Checker_stmt(c, stmt);
	}
	if (unreachable.line_nr >= 0) {
		v__checker__Checker_error(c, tos_lit("unreachable code"), unreachable);
	}
	c->scope_returns = false;
	c->expected_type = _const_v__table__void_type;
}

// Attr: [inline]
inline v__table__Type v__checker__Checker_unwrap_generic(v__checker__Checker* c, v__table__Type typ) {
	if (v__table__Type_has_flag(typ, v__table__TypeFlag_generic)) {
		return v__table__Type_clear_flag(v__table__Type_derive(c->cur_generic_type, typ), v__table__TypeFlag_generic);
	}
	return typ;
}

v__table__Type v__checker__Checker_expr(v__checker__Checker* c, v__ast__Expr node) {
	c->expr_level++;
	if (c->expr_level > 200) {
		v__checker__Checker_error(c, _STR("checker: too many expr levels: %"PRId32"\000 ", 2, c->expr_level), v__ast__Expr_position(node));
		// Defer begin
		c->expr_level--;
		// Defer end
		return _const_v__table__void_type;
	}
	v__ast__Expr _t1025 = node;
	if (_t1025.typ == 214 /* v.ast.CTempVar */) {
		// Defer begin
		c->expr_level--;
		// Defer end
		return (*node._214).typ;
	} else if (_t1025.typ == 208 /* v.ast.AnonFn */) {
		v__ast__FnDecl* keep_fn = c->cur_fn;
		c->cur_fn = &(*node._208).decl;
		v__checker__Checker_stmts(c, (*node._208).decl.stmts);
		c->cur_fn = keep_fn;
		// Defer begin
		c->expr_level--;
		// Defer end
		return (*node._208).typ;
	} else if (_t1025.typ == 209 /* v.ast.ArrayInit */) {
		// Defer begin
		c->expr_level--;
		// Defer end
		return v__checker__Checker_array_init(c, (voidptr)&/*qq*/(*node._209));
	} else if (_t1025.typ == 210 /* v.ast.AsCast */) {
		(*node._210).expr_type = v__checker__Checker_expr(c, (*node._210).expr);
		v__table__TypeSymbol* expr_type_sym = v__table__Table_get_type_symbol(c->table, (*node._210).expr_type);
		v__table__TypeSymbol* type_sym = v__table__Table_get_type_symbol(c->table, (*node._210).typ);
		if (expr_type_sym->kind == v__table__Kind_sum_type) {
			if (type_sym->kind == v__table__Kind_placeholder) {
				v__checker__Checker_error(c, _STR("unknown type `%.*s\000`", 2, type_sym->source_name), (*node._210).pos);
			}
			if (!v__table__Table_sumtype_has_variant(c->table, (*node._210).expr_type, (*node._210).typ)) {
				v__checker__Checker_error(c, _STR("cannot cast `%.*s\000` to `%.*s\000`", 3, expr_type_sym->source_name, type_sym->source_name), (*node._210).pos);
			}
		} else {
			string s = _STR("cannot cast non-sum type `%.*s\000` using `as`", 2, expr_type_sym->source_name);
			if (type_sym->kind == v__table__Kind_sum_type) {
				s = /*f*/string_add(s, _STR(" - use e.g. `%.*s\000(some_expr)` instead.", 2, type_sym->source_name));
			}
			v__checker__Checker_error(c, s, (*node._210).pos);
		}
		if (expr_type_sym->kind == v__table__Kind_sum_type) {
			// Defer begin
			c->expr_level--;
			// Defer end
			return (*node._210).typ;
		}
		// Defer begin
		c->expr_level--;
		// Defer end
		return v__table__Type_to_ptr((*node._210).typ);
	} else if (_t1025.typ == 211 /* v.ast.Assoc */) {
		v__ast__Scope* scope = v__ast__Scope_innermost(c->file->scope, (*node._211).pos.pos);
		Option_v__ast__Var_ptr _t1026 = v__ast__Scope_find_var(scope, (*node._211).var_name);
		if (!_t1026.ok) {
			string err = _t1026.v_error;
			int errcode = _t1026.ecode;
			v_panic(err);
		}
 		v__ast__Var* v = *(v__ast__Var**) _t1026.data;
		// FOR IN array
		array _t1027 = (*node._211).fields;
		for (int i = 0; i < _t1027.len; ++i) {
			v__checker__Checker_expr(c, (*(v__ast__Expr*)/*ee elem_typ */array_get((*node._211).exprs, i)));
		}
		(*node._211).typ = v->typ;
		// Defer begin
		c->expr_level--;
		// Defer end
		return v->typ;
	} else if (_t1025.typ == 213 /* v.ast.BoolLiteral */) {
		// Defer begin
		c->expr_level--;
		// Defer end
		return _const_v__table__bool_type;
	} else if (_t1025.typ == 216 /* v.ast.CastExpr */) {
		// Defer begin
		c->expr_level--;
		// Defer end
		return v__checker__Checker_cast_expr(c, (voidptr)&/*qq*/(*node._216));
	} else if (_t1025.typ == 215 /* v.ast.CallExpr */) {
		// Defer begin
		c->expr_level--;
		// Defer end
		return v__checker__Checker_call_expr(c, (voidptr)&/*qq*/(*node._215));
	} else if (_t1025.typ == 217 /* v.ast.ChanInit */) {
		// Defer begin
		c->expr_level--;
		// Defer end
		return v__checker__Checker_chan_init(c, (voidptr)&/*qq*/(*node._217));
	} else if (_t1025.typ == 218 /* v.ast.CharLiteral */) {
		// Defer begin
		c->expr_level--;
		// Defer end
		return _const_v__table__rune_type;
	} else if (_t1025.typ == 219 /* v.ast.Comment */) {
		// Defer begin
		c->expr_level--;
		// Defer end
		return _const_v__table__void_type;
	} else if (_t1025.typ == 212 /* v.ast.AtExpr */) {
		// Defer begin
		c->expr_level--;
		// Defer end
		return v__checker__Checker_at_expr(c, (voidptr)&/*qq*/(*node._212));
	} else if (_t1025.typ == 220 /* v.ast.ComptimeCall */) {
		(*node._220).sym = *v__table__Table_get_type_symbol(c->table, v__checker__Checker_unwrap_generic(c, v__checker__Checker_expr(c, (*node._220).left)));
		if ((*node._220).is_vweb) {
			v__pref__Preferences pref = *c->pref;
			v__pref__Preferences pref2 = // assoc
			(v__pref__Preferences){
				.os = pref.os,
				.backend = pref.backend,
				.build_mode = pref.build_mode,
				.output_mode = pref.output_mode,
				.is_verbose = pref.is_verbose,
				.is_test = pref.is_test,
				.is_script = pref.is_script,
				.is_vsh = pref.is_vsh,
				.is_livemain = pref.is_livemain,
				.is_liveshared = pref.is_liveshared,
				.is_shared = pref.is_shared,
				.is_prof = pref.is_prof,
				.profile_file = pref.profile_file,
				.profile_no_inline = pref.profile_no_inline,
				.translated = pref.translated,
				.is_prod = pref.is_prod,
				.obfuscate = pref.obfuscate,
				.is_repl = pref.is_repl,
				.is_run = pref.is_run,
				.sanitize = pref.sanitize,
				.is_debug = pref.is_debug,
				.is_vlines = pref.is_vlines,
				.show_cc = pref.show_cc,
				.show_c_output = pref.show_c_output,
				.use_cache = pref.use_cache,
				.is_stats = pref.is_stats,
				.no_auto_free = pref.no_auto_free,
				.cflags = pref.cflags,
				.ccompiler = pref.ccompiler,
				.ccompiler_type = pref.ccompiler_type,
				.third_party_option = pref.third_party_option,
				.building_v = pref.building_v,
				.autofree = pref.autofree,
				.compress = pref.compress,
				.fast = pref.fast,
				.enable_globals = pref.enable_globals,
				.is_fmt = pref.is_fmt,
				.is_vet = pref.is_vet,
				.is_bare = pref.is_bare,
				.no_preludes = pref.no_preludes,
				.custom_prelude = pref.custom_prelude,
				.lookup_path = pref.lookup_path,
				.output_cross_c = pref.output_cross_c,
				.prealloc = pref.prealloc,
				.vroot = pref.vroot,
				.out_name_c = pref.out_name_c,
				.out_name = pref.out_name,
				.display_name = pref.display_name,
				.bundle_id = pref.bundle_id,
				.path = pref.path,
				.compile_defines = pref.compile_defines,
				.compile_defines_all = pref.compile_defines_all,
				.run_args = pref.run_args,
				.printfn_list = pref.printfn_list,
				.print_v_files = pref.print_v_files,
				.skip_running = pref.skip_running,
				.skip_warnings = pref.skip_warnings,
				.warns_are_errors = pref.warns_are_errors,
				.reuse_tmpc = pref.reuse_tmpc,
				.use_color = pref.use_color,
				.is_parallel = pref.is_parallel,
				.error_limit = pref.error_limit,
				.is_vweb = true, 
				.only_check_syntax = pref.only_check_syntax,
				.experimental = pref.experimental,
				.show_timings = pref.show_timings,
				.is_ios_simulator = pref.is_ios_simulator,
				.is_apk = pref.is_apk,
				.cleanup_files = pref.cleanup_files,
				.build_options = pref.build_options,
				.cache_manager = pref.cache_manager,
			};
			v__checker__Checker c2 = v__checker__new_checker(c->table, (voidptr)&/*qq*/pref2);
			v__checker__Checker_check(&c2, (voidptr)&/*qq*/(*node._220).vweb_tmpl);
			_PUSH_MANY(&c->warnings, (c2.warnings), _t1028, array_v__errors__Warning);
			_PUSH_MANY(&c->errors, (c2.errors), _t1029, array_v__errors__Error);
			c->nr_warnings += c2.nr_warnings;
			c->nr_errors += c2.nr_errors;
		}
		if (string_eq((*node._220).method_name, tos_lit("html"))) {
			// Defer begin
			c->expr_level--;
			// Defer end
			return v__table__Table_find_type_idx(c->table, tos_lit("vweb.Result"));
		} else {
			// Defer begin
			c->expr_level--;
			// Defer end
			return _const_v__table__string_type;
		}
	} else if (_t1025.typ == 221 /* v.ast.ConcatExpr */) {
		// Defer begin
		c->expr_level--;
		// Defer end
		return v__checker__Checker_concat_expr(c, (voidptr)&/*qq*/(*node._221));
	} else if (_t1025.typ == 222 /* v.ast.EnumVal */) {
		// Defer begin
		c->expr_level--;
		// Defer end
		return v__checker__Checker_enum_val(c, (voidptr)&/*qq*/(*node._222));
	} else if (_t1025.typ == 223 /* v.ast.FloatLiteral */) {
		// Defer begin
		c->expr_level--;
		// Defer end
		return _const_v__table__any_flt_type;
	} else if (_t1025.typ == 224 /* v.ast.Ident */) {
		v__table__Type res = v__checker__Checker_ident(c, (voidptr)&/*qq*/(*node._224));
		// Defer begin
		c->expr_level--;
		// Defer end
		return res;
	} else if (_t1025.typ == 225 /* v.ast.IfExpr */) {
		// Defer begin
		c->expr_level--;
		// Defer end
		return v__checker__Checker_if_expr(c, (voidptr)&/*qq*/(*node._225));
	} else if (_t1025.typ == 226 /* v.ast.IfGuardExpr */) {
		(*node._226).expr_type = v__checker__Checker_expr(c, (*node._226).expr);
		if (!v__table__Type_has_flag((*node._226).expr_type, v__table__TypeFlag_optional)) {
			v__checker__Checker_error(c, tos_lit("expression should return an option"), v__ast__Expr_position((*node._226).expr));
		}
		// Defer begin
		c->expr_level--;
		// Defer end
		return _const_v__table__bool_type;
	} else if (_t1025.typ == 227 /* v.ast.IndexExpr */) {
		// Defer begin
		c->expr_level--;
		// Defer end
		return v__checker__Checker_index_expr(c, (voidptr)&/*qq*/(*node._227));
	} else if (_t1025.typ == 228 /* v.ast.InfixExpr */) {
		// Defer begin
		c->expr_level--;
		// Defer end
		return v__checker__Checker_infix_expr(c, (voidptr)&/*qq*/(*node._228));
	} else if (_t1025.typ == 229 /* v.ast.IntegerLiteral */) {
		// Defer begin
		c->expr_level--;
		// Defer end
		return _const_v__table__any_int_type;
	} else if (_t1025.typ == 231 /* v.ast.LockExpr */) {
		// Defer begin
		c->expr_level--;
		// Defer end
		return v__checker__Checker_lock_expr(c, (voidptr)&/*qq*/(*node._231));
	} else if (_t1025.typ == 232 /* v.ast.MapInit */) {
		// Defer begin
		c->expr_level--;
		// Defer end
		return v__checker__Checker_map_init(c, (voidptr)&/*qq*/(*node._232));
	} else if (_t1025.typ == 233 /* v.ast.MatchExpr */) {
		// Defer begin
		c->expr_level--;
		// Defer end
		return v__checker__Checker_match_expr(c, (voidptr)&/*qq*/(*node._233));
	} else if (_t1025.typ == 237 /* v.ast.PostfixExpr */) {
		// Defer begin
		c->expr_level--;
		// Defer end
		return v__checker__Checker_postfix_expr(c, (voidptr)&/*qq*/(*node._237));
	} else if (_t1025.typ == 238 /* v.ast.PrefixExpr */) {
		v__table__Type right_type = v__checker__Checker_expr(c, (*node._238).right);
		(*node._238).right_type = right_type;
		if ((*node._238).op == v__token__Kind_amp && !v__table__Type_is_ptr(right_type)) {
			if (((*node._238).right).typ == 229 /* v.ast.IntegerLiteral */) {
				v__checker__Checker_error(c, tos_lit("cannot take the address of an int"), (*node._238).pos);
			}
			if (((*node._238).right).typ == 245 /* v.ast.StringLiteral */ || ((*node._238).right).typ == 244 /* v.ast.StringInterLiteral */) {
				v__checker__Checker_error(c, tos_lit("cannot take the address of a string"), (*node._238).pos);
			}
			if (((*node._238).right).typ == 227 /* v.ast.IndexExpr */) {
				v__table__TypeSymbol* typ_sym = v__table__Table_get_type_symbol(c->table, (*(*node._238).right._227).left_type);
				bool is_mut = false;
				if (((*(*node._238).right._227).left).typ == 224 /* v.ast.Ident */) {
					v__ast__Ident ident = (*(*(*node._238).right._227).left._224);
					if ((ident.obj).typ == 277 /* v.ast.Var */) {
						v__ast__Var v = /* as */ *(v__ast__Var*)__as_cast((ident.obj)._277, (ident.obj).typ, /*expected:*/277);
						is_mut = v.is_mut;
					}
				}
				if (!c->inside_unsafe && is_mut) {
					if (typ_sym->kind == v__table__Kind_map) {
						v__checker__Checker_error(c, tos_lit("cannot take the address of mutable map values outside unsafe blocks"), (*(*node._238).right._227).pos);
					}
					if (typ_sym->kind == v__table__Kind_array) {
						v__checker__Checker_error(c, tos_lit("cannot take the address of mutable array elements outside unsafe blocks"), (*(*node._238).right._227).pos);
					}
				}
			}
			// Defer begin
			c->expr_level--;
			// Defer end
			return v__table__Type_to_ptr(right_type);
		} else if ((*node._238).op == v__token__Kind_amp && ((*node._238).right).typ != 216 /* v.ast.CastExpr */) {
			// Defer begin
			c->expr_level--;
			// Defer end
			return v__table__Type_to_ptr(right_type);
		}
		if ((*node._238).op == v__token__Kind_mul) {
			if (v__table__Type_is_ptr(right_type)) {
				// Defer begin
				c->expr_level--;
				// Defer end
				return v__table__Type_deref(right_type);
			}
			if (!v__table__Type_is_pointer(right_type)) {
				string s = v__table__Table_type_to_str(c->table, right_type);
				v__checker__Checker_error(c, _STR("invalid indirect of `%.*s\000`", 2, s), (*node._238).pos);
			}
		}
		if ((*node._238).op == v__token__Kind_bit_not && !v__table__Type_is_int(right_type) && !c->pref->translated) {
			v__checker__Checker_error(c, tos_lit("operator ~ only defined on int types"), (*node._238).pos);
		}
		if ((*node._238).op == v__token__Kind_not && right_type != _const_v__table__bool_type_idx && !c->pref->translated) {
			v__checker__Checker_error(c, tos_lit("! operator can only be used with bool types"), (*node._238).pos);
		}
		if ((*node._238).op == v__token__Kind_arrow) {
			v__table__TypeSymbol* right = v__table__Table_get_type_symbol(c->table, right_type);
			if (right->kind == v__table__Kind_chan) {
				v__checker__Checker_stmts(c, (*node._238).or_block.stmts);
				// Defer begin
				c->expr_level--;
				// Defer end
				return v__table__TypeSymbol_chan_info(right).elem_type;
			} else {
				v__checker__Checker_error(c, tos_lit("<- operator can only be used with `chan` types"), (*node._238).pos);
			}
		}
		// Defer begin
		c->expr_level--;
		// Defer end
		return right_type;
	} else if (_t1025.typ == 234 /* v.ast.None */) {
		// Defer begin
		c->expr_level--;
		// Defer end
		return _const_v__table__none_type;
	} else if (_t1025.typ == 235 /* v.ast.OrExpr */) {
		// Defer begin
		c->expr_level--;
		// Defer end
		return _const_v__table__void_type;
	} else if (_t1025.typ == 236 /* v.ast.ParExpr */) {
		// Defer begin
		c->expr_level--;
		// Defer end
		return v__checker__Checker_expr(c, (*node._236).expr);
	} else if (_t1025.typ == 239 /* v.ast.RangeExpr */) {
		// Defer begin
		c->expr_level--;
		// Defer end
		return _const_v__table__void_type;
	} else if (_t1025.typ == 240 /* v.ast.SelectExpr */) {
		// Defer begin
		c->expr_level--;
		// Defer end
		return v__checker__Checker_select_expr(c, (voidptr)&/*qq*/(*node._240));
	} else if (_t1025.typ == 241 /* v.ast.SelectorExpr */) {
		// Defer begin
		c->expr_level--;
		// Defer end
		return v__checker__Checker_selector_expr(c, (voidptr)&/*qq*/(*node._241));
	} else if (_t1025.typ == 242 /* v.ast.SizeOf */) {
		// Defer begin
		c->expr_level--;
		// Defer end
		return _const_v__table__u32_type;
	} else if (_t1025.typ == 243 /* v.ast.SqlExpr */) {
		// Defer begin
		c->expr_level--;
		// Defer end
		return v__checker__Checker_sql_expr(c, (voidptr)&/*qq*/(*node._243));
	} else if (_t1025.typ == 245 /* v.ast.StringLiteral */) {
		if ((*node._245).language == v__table__Language_c) {
			// Defer begin
			c->expr_level--;
			// Defer end
			return _const_v__table__byteptr_type;
		}
		// Defer begin
		c->expr_level--;
		// Defer end
		return _const_v__table__string_type;
	} else if (_t1025.typ == 244 /* v.ast.StringInterLiteral */) {
		// Defer begin
		c->expr_level--;
		// Defer end
		return v__checker__Checker_string_inter_lit(c, (voidptr)&/*qq*/(*node._244));
	} else if (_t1025.typ == 246 /* v.ast.StructInit */) {
		// Defer begin
		c->expr_level--;
		// Defer end
		return v__checker__Checker_struct_init(c, (voidptr)&/*qq*/(*node._246));
	} else if (_t1025.typ == 247 /* v.ast.Type */) {
		// Defer begin
		c->expr_level--;
		// Defer end
		return (*node._247).typ;
	} else if (_t1025.typ == 248 /* v.ast.TypeOf */) {
		(*node._248).expr_type = v__checker__Checker_expr(c, (*node._248).expr);
		// Defer begin
		c->expr_level--;
		// Defer end
		return _const_v__table__string_type;
	} else if (_t1025.typ == 249 /* v.ast.UnsafeExpr */) {
		// Defer begin
		c->expr_level--;
		// Defer end
		return v__checker__Checker_unsafe_expr(c, (voidptr)&/*qq*/(*node._249));
	} else if (_t1025.typ == 230 /* v.ast.Likely */) {
		v__table__Type ltype = v__checker__Checker_expr(c, (*node._230).expr);
		if (!v__checker__Checker_check_types(c, ltype, _const_v__table__bool_type)) {
			v__table__TypeSymbol* ltype_sym = v__table__Table_get_type_symbol(c->table, ltype);
			string lname = ((*node._230).is_likely ? (tos_lit("_likely_")) : (tos_lit("_unlikely_")));
			v__checker__Checker_error(c, _STR("`%.*s\000()` expects a boolean expression, instead it got `%.*s\000`", 3, lname, ltype_sym->source_name), (*node._230).pos);
		}
		// Defer begin
		c->expr_level--;
		// Defer end
		return _const_v__table__bool_type;
	};
	// Defer begin
	c->expr_level--;
	// Defer end
	return _const_v__table__void_type;
}

v__table__Type v__checker__Checker_cast_expr(v__checker__Checker* c, v__ast__CastExpr* node) {
	node->expr_type = v__checker__Checker_expr(c, node->expr);
	v__table__TypeSymbol* from_type_sym = v__table__Table_get_type_symbol(c->table, node->expr_type);
	v__table__TypeSymbol* to_type_sym = v__table__Table_get_type_symbol(c->table, node->typ);
	bool expr_is_ptr = v__table__Type_is_ptr(node->expr_type) || _IN(int, v__table__Type_idx(node->expr_type), _const_v__table__pointer_type_idxs);
	if (expr_is_ptr && to_type_sym->kind == v__table__Kind_string && !node->in_prexpr) {
		if (node->has_arg) {
			v__checker__Checker_warn(c, tos_lit("to convert a C string buffer pointer to a V string, please use x.vstring_with_len(len) instead of string(x,len)"), node->pos);
		} else {
			v__checker__Checker_warn(c, tos_lit("to convert a C string buffer pointer to a V string, please use x.vstring() instead of string(x)"), node->pos);
		}
	}
	if (node->expr_type == _const_v__table__byte_type && to_type_sym->kind == v__table__Kind_string) {
		v__checker__Checker_error(c, _STR("can not cast type `byte` to string, use `%.*s\000.str()` instead.", 2, v__ast__Expr_str(node->expr)), node->pos);
	}
	if (to_type_sym->kind == v__table__Kind_sum_type) {
		if ((node->expr_type == _const_v__table__any_int_type || node->expr_type == _const_v__table__any_flt_type)) {
			node->expr_type = v__checker__Checker_promote_num(c, node->expr_type, (node->expr_type == _const_v__table__any_int_type ? (_const_v__table__int_type) : (_const_v__table__f64_type)));
		}
		if (!v__table__Table_sumtype_has_variant(c->table, node->typ, node->expr_type)) {
			v__checker__Checker_error(c, _STR("cannot cast `%.*s\000` to `%.*s\000`", 3, from_type_sym->source_name, to_type_sym->source_name), node->pos);
		}
	} else if ((to_type_sym->info).typ == 347 /* v.table.Alias */) {
		if (!v__checker__Checker_check_types(c, node->expr_type, (*to_type_sym->info._347).parent_type)) {
			v__table__TypeSymbol* parent_type_sym = v__table__Table_get_type_symbol(c->table, (*to_type_sym->info._347).parent_type);
			v__checker__Checker_error(c, _STR("cannot convert type `%.*s\000` to `%.*s\000` (alias to `%.*s\000`)", 4, from_type_sym->source_name, to_type_sym->source_name, parent_type_sym->source_name), node->pos);
		}
	} else if (node->typ == _const_v__table__string_type && ((from_type_sym->kind == v__table__Kind_any_int || from_type_sym->kind == v__table__Kind_int || from_type_sym->kind == v__table__Kind_byte || from_type_sym->kind == v__table__Kind_byteptr || from_type_sym->kind == v__table__Kind_bool) || (from_type_sym->kind == v__table__Kind_array && string_eq(from_type_sym->name, tos_lit("array_byte"))))) {
		string type_name = v__table__Table_type_to_str(c->table, node->expr_type);
		v__checker__Checker_error(c, _STR("cannot cast type `%.*s\000` to string, use `x.str()` instead", 2, type_name), node->pos);
	} else if (node->expr_type == _const_v__table__string_type) {
		if (to_type_sym->kind != v__table__Kind_alias) {
			string error_msg = tos_lit("cannot cast a string");
			if ((node->expr).typ == 245 /* v.ast.StringLiteral */) {
				if ((*node->expr._245).val.len == 1) {
					error_msg = /*f*/string_add(error_msg, _STR(", for denoting characters use `%.*s\000` instead of '%.*s\000'", 3, (*node->expr._245).val, (*node->expr._245).val));
				}
			}
			v__checker__Checker_error(c, error_msg, node->pos);
		}
	} else if (to_type_sym->kind == v__table__Kind_byte && node->expr_type != _const_v__table__voidptr_type && from_type_sym->kind != v__table__Kind_enum_ && !v__table__Type_is_int(node->expr_type) && !v__table__Type_is_float(node->expr_type) && !v__table__Type_is_ptr(node->expr_type)) {
		string type_name = v__table__Table_type_to_str(c->table, node->expr_type);
		v__checker__Checker_error(c, _STR("cannot cast type `%.*s\000` to `byte`", 2, type_name), node->pos);
	} else if (to_type_sym->kind == v__table__Kind_struct_ && !v__table__Type_is_ptr(node->typ) && !(/* as */ *(v__table__Struct*)__as_cast((to_type_sym->info)._155, (to_type_sym->info).typ, /*expected:*/155)).is_typedef) {
		if (from_type_sym->kind == v__table__Kind_struct_ && !v__table__Type_is_ptr(node->expr_type)) {
			v__table__Struct from_type_info = /* as */ *(v__table__Struct*)__as_cast((from_type_sym->info)._155, (from_type_sym->info).typ, /*expected:*/155);
			v__table__Struct to_type_info = /* as */ *(v__table__Struct*)__as_cast((to_type_sym->info)._155, (to_type_sym->info).typ, /*expected:*/155);
			if (!v__checker__Checker_check_struct_signature(/*rec*/*c, from_type_info, to_type_info)) {
				v__checker__Checker_error(c, _STR("cannot convert struct `%.*s\000` to struct `%.*s\000`", 3, from_type_sym->source_name, to_type_sym->source_name), node->pos);
			}
		} else {
			string type_name = v__table__Table_type_to_str(c->table, node->expr_type);
			v__checker__Checker_error(c, _STR("cannot cast `%.*s\000` to struct", 2, type_name), node->pos);
		}
	} else if (node->typ == _const_v__table__bool_type) {
		v__checker__Checker_error(c, tos_lit("cannot cast to bool - use e.g. `some_int != 0` instead"), node->pos);
	} else if (node->expr_type == _const_v__table__none_type) {
		string type_name = v__table__Table_type_to_str(c->table, node->typ);
		v__checker__Checker_error(c, _STR("cannot cast `none` to `%.*s\000`", 2, type_name), node->pos);
	}
	if (node->has_arg) {
		v__checker__Checker_expr(c, node->arg);
	}
	node->typname = v__table__Table_get_type_symbol(c->table, node->typ)->name;
	return node->typ;
}

VV_LOCAL_SYMBOL v__table__Type v__checker__Checker_at_expr(v__checker__Checker* c, v__ast__AtExpr* node) {
	v__token__AtKind _t1030 = node->kind;
	if (_t1030 == v__token__AtKind_fn_name) {
		node->val = string_all_after_last(c->cur_fn->name, tos_lit("."));
	} else if (_t1030 == v__token__AtKind_mod_name) {
		node->val = c->cur_fn->mod;
	} else if (_t1030 == v__token__AtKind_struct_name) {
		if (c->cur_fn->is_method) {
			node->val = string_all_after_last(v__table__Table_type_to_str(c->table, c->cur_fn->receiver.typ), tos_lit("."));
		} else {
			node->val = tos_lit("");
		}
	} else if (_t1030 == v__token__AtKind_vexe_path) {
		node->val = v__pref__vexe_path();
	} else if (_t1030 == v__token__AtKind_file_path) {
		node->val = os__real_path(c->file->path);
	} else if (_t1030 == v__token__AtKind_line_nr) {
		node->val = int_str((node->pos.line_nr + 1));
	} else if (_t1030 == v__token__AtKind_column_nr) {
		multi_return_string_int mr_105348 = v__util__filepath_pos_to_source_and_column(c->file->path, node->pos);
		int column = mr_105348.arg1;
		node->val = int_str((column + 1));
	} else if (_t1030 == v__token__AtKind_vhash) {
		node->val = v__util__vhash();
	} else if (_t1030 == v__token__AtKind_vmod_file) {
		if (c->vmod_file_content.len == 0) {
			v__vmod__ModFileCacher* mcache = v__vmod__get_cache();
			v__vmod__ModFileAndFolder vmod_file_location = v__vmod__ModFileCacher_get_by_file(mcache, c->file->path);
			if (vmod_file_location.vmod_file.len == 0) {
				v__checker__Checker_error(c, tos_lit("@VMOD_FILE can be used only in projects, that have v.mod file"), node->pos);
			}
			Option_string _t1031 = os__read_file(vmod_file_location.vmod_file);
			if (!_t1031.ok) {
				string err = _t1031.v_error;
				int errcode = _t1031.ecode;
				*(string*) _t1031.data = tos_lit("");
			}
 			string vmod_content = *(string*) _t1031.data;
			#if defined(_WIN32)
			{
				c->vmod_file_content = string_replace(vmod_content, tos_lit("\r\n"), tos_lit("\n"));
			}
			#else
			{
			}
			#endif
		}
		node->val = c->vmod_file_content;
	} else if (_t1030 == v__token__AtKind_unknown) {
		v__checker__Checker_error(c, _STR("unknown @ identifier: %.*s\000. Available identifiers: %.*s", 2, node->name, array_string_str(_const_v__token__valid_at_tokens)), node->pos);
	};
	return _const_v__table__string_type;
}

v__table__Type v__checker__Checker_ident(v__checker__Checker* c, v__ast__Ident* ident) {
	if (c->const_deps.len > 0) {
		string name = ident->name;
		if (!string_contains(name, tos_lit(".")) && string_ne(ident->mod, tos_lit("builtin"))) {
			name = _STR("%.*s\000.%.*s", 2, ident->mod, ident->name);
		}
		if (string_eq(name, c->const_decl)) {
			v__checker__Checker_error(c, _STR("cycle in constant `%.*s\000`", 2, c->const_decl), ident->pos);
			return _const_v__table__void_type;
		}
		array_push(&c->const_deps, _MOV((string[]){ string_clone(name) }));
	}
	if (ident->kind == v__ast__IdentKind_blank_ident) {
		if (!(ident->tok_kind == v__token__Kind_assign || ident->tok_kind == v__token__Kind_decl_assign)) {
			v__checker__Checker_error(c, tos_lit("undefined ident: `_` (may only be used in assignments)"), ident->pos);
		}
		return _const_v__table__void_type;
	}
	if ((ident->kind == v__ast__IdentKind_constant || ident->kind == v__ast__IdentKind_global || ident->kind == v__ast__IdentKind_variable)) {
		v__ast__IdentVar info = /* as */ *(v__ast__IdentVar*)__as_cast((ident->info)._313, (ident->info).typ, /*expected:*/313);
		return info.typ;
	} else if (ident->kind == v__ast__IdentKind_function) {
		v__ast__IdentFn info = /* as */ *(v__ast__IdentFn*)__as_cast((ident->info)._312, (ident->info).typ, /*expected:*/312);
		return info.typ;
	} else if (ident->kind == v__ast__IdentKind_unresolved) {
		if (ident->tok_kind == v__token__Kind_assign && ident->is_mut) {
			v__checker__Checker_error(c, tos_lit("`mut` not allowed with `=` (use `:=` to declare a variable)"), ident->pos);
		}
		v__ast__Scope* start_scope = v__ast__Scope_innermost(c->file->scope, ident->pos.pos);
		{ /* if guard */ 
		Option_v__ast__ScopeObject _t1033;
		if (_t1033 = v__ast__Scope_find(start_scope, ident->name), _t1033.ok) {
			v__ast__ScopeObject obj = *(v__ast__ScopeObject*)_t1033.data;
			v__ast__ScopeObject _t1034 = obj;
			if (_t1034.typ == 276 /* v.ast.GlobalField */) {
				ident->kind = v__ast__IdentKind_global;
				ident->info = /* sum type cast 4 */ (v__ast__IdentInfo){._313 = memdup(&(v__ast__IdentVar[]){(v__ast__IdentVar){.typ = (*obj._276).typ,.is_mut = 0,.is_static = 0,.is_optional = 0,.share = 0,}}, sizeof(v__ast__IdentVar)), .typ = 313 /* v.ast.IdentVar */};
				ident->obj = obj;
				return (*obj._276).typ;
			} else if (_t1034.typ == 277 /* v.ast.Var */) {
				(*obj._277).is_used = true;
				if (ident->pos.pos < (*obj._277).pos.pos) {
					v__checker__Checker_error(c, _STR("undefined variable `%.*s\000` (used before declaration)", 2, ident->name), ident->pos);
				}
				bool is_sum_type_cast = (*obj._277).sum_type_casts.len != 0 && !c->prevent_sum_type_unwrapping_once;
				c->prevent_sum_type_unwrapping_once = false;
				v__table__Type typ = (is_sum_type_cast ? (*(v__table__Type*)array_last((*obj._277).sum_type_casts)) : ((*obj._277).typ));
				if (typ == 0) {
					if (((*obj._277).expr).typ == 224 /* v.ast.Ident */) {
						if ((*(*obj._277).expr._224).kind == v__ast__IdentKind_unresolved) {
							v__checker__Checker_error(c, _STR("unresolved variable: `%.*s\000`", 2, ident->name), ident->pos);
							return _const_v__table__void_type;
						}
					}
					if (((*obj._277).expr).typ == 226 /* v.ast.IfGuardExpr */) {
						v__table__Type if_guard_var_type = v__checker__Checker_expr(c, (*(*obj._277).expr._226).expr);
						typ = v__table__Type_clear_flag(if_guard_var_type, v__table__TypeFlag_optional);
					} else {
						typ = v__checker__Checker_expr(c, (*obj._277).expr);
					}
				}
				bool is_optional = v__table__Type_has_flag(typ, v__table__TypeFlag_optional);
				ident->kind = v__ast__IdentKind_variable;
				ident->info = /* sum type cast 4 */ (v__ast__IdentInfo){._313 = memdup(&(v__ast__IdentVar[]){(v__ast__IdentVar){.typ = typ,.is_mut = 0,.is_static = 0,.is_optional = is_optional,.share = 0,}}, sizeof(v__ast__IdentVar)), .typ = 313 /* v.ast.IdentVar */};
				if (!is_sum_type_cast) {
					(*obj._277).typ = typ;
				}
				ident->obj = obj;
				if (is_optional) {
					return v__table__Type_clear_flag(typ, v__table__TypeFlag_optional);
				}
				return typ;
			} else {
			};
		}}
		string name = ident->name;
		if (!string_contains(name, tos_lit(".")) && string_ne(ident->mod, tos_lit("builtin"))) {
			name = _STR("%.*s\000.%.*s", 2, ident->mod, ident->name);
		}
		{ /* if guard */ 
		Option_v__ast__ScopeObject _t1035;
		if (_t1035 = v__ast__Scope_find(c->file->global_scope, name), _t1035.ok) {
			v__ast__ScopeObject obj = *(v__ast__ScopeObject*)_t1035.data;
			v__ast__ScopeObject _t1036 = obj;
			if (_t1036.typ == 275 /* v.ast.ConstField */) {
				v__table__Type typ = (*obj._275).typ;
				if (typ == 0) {
					typ = v__checker__Checker_expr(c, (*obj._275).expr);
				}
				ident->name = name;
				ident->kind = v__ast__IdentKind_constant;
				ident->info = /* sum type cast 4 */ (v__ast__IdentInfo){._313 = memdup(&(v__ast__IdentVar[]){(v__ast__IdentVar){.typ = typ,.is_mut = 0,.is_static = 0,.is_optional = 0,.share = 0,}}, sizeof(v__ast__IdentVar)), .typ = 313 /* v.ast.IdentVar */};
				(*obj._275).typ = typ;
				ident->obj = obj;
				return typ;
			} else {
			};
		}}
		{ /* if guard */ 
		Option_v__table__Fn _t1037;
		if (_t1037 = v__table__Table_find_fn(c->table, name), _t1037.ok) {
			v__table__Fn func = *(v__table__Fn*)_t1037.data;
			v__table__Type fn_type = v__table__new_type(v__table__Table_find_or_register_fn_type(c->table, ident->mod, func, false, true));
			ident->name = name;
			ident->kind = v__ast__IdentKind_function;
			ident->info = /* sum type cast 4 */ (v__ast__IdentInfo){._312 = memdup(&(v__ast__IdentFn[]){(v__ast__IdentFn){.typ = fn_type,}}, sizeof(v__ast__IdentFn)), .typ = 312 /* v.ast.IdentFn */};
			return fn_type;
		}}
	}
	if (ident->language == v__table__Language_c) {
		return _const_v__table__int_type;
	}
	if (c->inside_sql) {
		{ /* if guard */ 
		Option_v__table__Field _t1038;
		if (_t1038 = v__table__Table_struct_find_field(c->table, (voidptr)&/*qq*/c->cur_orm_ts, ident->name), _t1038.ok) {
			v__table__Field field = *(v__table__Field*)_t1038.data;
			return field.typ;
		}}
	}
	if (ident->kind == v__ast__IdentKind_unresolved && string_ne(ident->mod, tos_lit("builtin"))) {
		string saved_mod = ident->mod;
		ident->mod = tos_lit("builtin");
		v__table__Type builtin_type = v__checker__Checker_ident(c, ident);
		if (builtin_type != _const_v__table__void_type) {
			return builtin_type;
		}
		ident->mod = saved_mod;
	}
	if (ident->tok_kind == v__token__Kind_assign) {
		v__checker__Checker_error(c, _STR("undefined ident: `%.*s\000` (use `:=` to declare a variable)", 2, ident->name), ident->pos);
	} else {
		v__checker__Checker_error(c, _STR("undefined ident: `%.*s\000`", 2, ident->name), ident->pos);
	}
	if (v__table__Table_known_type(c->table, ident->name)) {
		return _const_v__table__void_type;
	}
	return _const_v__table__void_type;
}

v__table__Type v__checker__Checker_concat_expr(v__checker__Checker* c, v__ast__ConcatExpr* concat_expr) {
	array_v__table__Type mr_types = __new_array_with_default(0, 0, sizeof(v__table__Type), 0);
	// FOR IN array
	array _t1039 = concat_expr->vals;
	for (int _t1040 = 0; _t1040 < _t1039.len; ++_t1040) {
		v__ast__Expr expr = ((v__ast__Expr*)_t1039.data)[_t1040];
		array_push(&mr_types, _MOV((v__table__Type[]){ v__checker__Checker_expr(c, expr) }));
	}
	if (concat_expr->vals.len == 1) {
		v__table__Type typ = (*(v__table__Type*)/*ee elem_typ */array_get(mr_types, 0));
		concat_expr->return_type = typ;
		return typ;
	} else {
		int typ = v__table__Table_find_or_register_multi_return(c->table, mr_types);
		v__table__new_type(typ);
		concat_expr->return_type = typ;
		return typ;
	}
	return 0;
}

v__table__Type v__checker__Checker_match_expr(v__checker__Checker* c, v__ast__MatchExpr* node) {
	node->is_expr = c->expected_type != _const_v__table__void_type;
	node->expected_type = c->expected_type;
	v__table__Type cond_type = v__checker__Checker_expr(c, node->cond);
	node->cond_type = cond_type;
	if (cond_type == 0) {
		v__checker__Checker_error(c, tos_lit("compiler bug: match 0 cond type"), node->pos);
	}
	v__table__TypeSymbol* cond_type_sym = v__table__Table_get_type_symbol(c->table, cond_type);
	if (!(cond_type_sym->kind == v__table__Kind_interface_ || cond_type_sym->kind == v__table__Kind_sum_type)) {
		node->is_sum_type = false;
	}
	v__checker__Checker_match_exprs(c, node, *cond_type_sym);
	c->expected_type = cond_type;
	v__table__Type ret_type = _const_v__table__void_type;
	int nbranches_with_return = 0;
	int nbranches_without_return = 0;
	// FOR IN array
	array _t1042 = node->branches;
	for (int _t1043 = 0; _t1043 < _t1042.len; ++_t1043) {
		v__ast__MatchBranch branch = ((v__ast__MatchBranch*)_t1042.data)[_t1043];
		v__checker__Checker_stmts(c, branch.stmts);
		if (node->is_expr && branch.stmts.len > 0) {
			// FOR IN array
			array _t1044 = array_slice(branch.stmts, 0, branch.stmts.len - 1);
			for (int _t1045 = 0; _t1045 < _t1044.len; ++_t1045) {
				v__ast__Stmt st = ((v__ast__Stmt*)_t1044.data)[_t1045];
				Option_void _t1046 = v__ast__Stmt_check_c_expr(st);
				if (!_t1046.ok && !_t1046.is_none) {
					string err = _t1046.v_error;
					int errcode = _t1046.ecode;
					v__checker__Checker_error(c, _STR("`match` expression branch has %.*s", 1, err), v__ast__Stmt_position(st));
				};
			}
		}
		if (branch.stmts.len > 0) {
			v__ast__Stmt stmt = (*(v__ast__Stmt*)/*ee elem_typ */array_get(branch.stmts, branch.stmts.len - 1));
			v__ast__Stmt _t1047 = stmt;
			if (_t1047.typ == 259 /* v.ast.ExprStmt */) {
				ret_type = v__checker__Checker_expr(c, (*stmt._259).expr);
				(*stmt._259).typ = ret_type;
			} else {
			};
		}
		{ /* if guard */ 
		Option_bool _t1048;
		if (_t1048 = v__checker__Checker_has_return(c, branch.stmts), _t1048.ok) {
			bool has_return = *(bool*)_t1048.data;
			if (has_return) {
				nbranches_with_return++;
			} else {
				nbranches_without_return++;
			}
		}}
	}
	if (nbranches_with_return > 0) {
		if (nbranches_with_return == node->branches.len) {
			c->returns = true;
		}
		if (nbranches_without_return > 0) {
			c->returns = false;
		}
	}
	node->return_type = ret_type;
	return ret_type;
}

VV_LOCAL_SYMBOL void v__checker__Checker_match_exprs(v__checker__Checker* c, v__ast__MatchExpr* node, v__table__TypeSymbol type_sym) {
	map_string_int branch_exprs = new_map_1(sizeof(int));
	v__table__TypeSymbol* cond_type_sym = v__table__Table_get_type_symbol(c->table, node->cond_type);
	// FOR IN array
	array _t1049 = node->branches;
	for (int _t1050 = 0; _t1050 < _t1049.len; ++_t1050) {
		v__ast__MatchBranch branch = ((v__ast__MatchBranch*)_t1049.data)[_t1050];
		array_v__ast__Type expr_types = __new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
		// FOR IN array
		array _t1051 = branch.exprs;
		for (int _t1052 = 0; _t1052 < _t1051.len; ++_t1052) {
			v__ast__Expr expr = ((v__ast__Expr*)_t1051.data)[_t1052];
			string key = tos_lit("");
			if ((expr).typ == 239 /* v.ast.RangeExpr */) {
				int low = 0;
				int high = 0;
				c->expected_type = node->expected_type;
				v__ast__Expr low_expr = (*expr._239).low;
				v__ast__Expr high_expr = (*expr._239).high;
				if ((low_expr).typ == 229 /* v.ast.IntegerLiteral */) {
					if ((high_expr).typ == 229 /* v.ast.IntegerLiteral */) {
						low = string_int((*low_expr._229).val);
						high = string_int((*high_expr._229).val);
					} else {
						v__checker__Checker_error(c, tos_lit("mismatched range types"), (*low_expr._229).pos);
					}
				} else if ((low_expr).typ == 218 /* v.ast.CharLiteral */) {
					if ((high_expr).typ == 218 /* v.ast.CharLiteral */) {
						low = string_at((*low_expr._218).val, 0);
						high = string_at((*high_expr._218).val, 0);
					} else {
						v__checker__Checker_error(c, tos_lit("mismatched range types"), (*low_expr._218).pos);
					}
				} else {
					string typ = v__table__Table_type_to_str(c->table, v__checker__Checker_expr(c, (*expr._239).low));
					v__checker__Checker_error(c, _STR("cannot use type `%.*s\000` in match range", 2, typ), branch.pos);
				}
				for (int i = low; i < high + 1; ++i) {
					key = int_str(i);
					int val = (_IN_MAP(key, branch_exprs) ? ((*(int*)map_get(branch_exprs, key, &(int[]){ 0 }))) : (0));
					if (val == 1) {
						v__checker__Checker_error(c, _STR("match case `%.*s\000` is handled more than once", 2, key), branch.pos);
					}
					map_set(&branch_exprs, key, &(int[]) { val + 1 });
				}
				continue;
			}
			v__ast__Expr _t1053 = expr;
			if (_t1053.typ == 247 /* v.ast.Type */) {
				key = v__table__Table_type_to_str(c->table, (*expr._247).typ);
				array_push(&expr_types, _MOV((v__ast__Type[]){ (*expr._247) }));
			} else if (_t1053.typ == 222 /* v.ast.EnumVal */) {
				key = (*expr._222).val;
			} else {
				key = v__ast__Expr_str(expr);
			};
			int val = (_IN_MAP(key, branch_exprs) ? ((*(int*)map_get(branch_exprs, key, &(int[]){ 0 }))) : (0));
			if (val == 1) {
				v__checker__Checker_error(c, _STR("match case `%.*s\000` is handled more than once", 2, key), branch.pos);
			}
			c->expected_type = node->cond_type;
			v__table__Type expr_type = v__checker__Checker_expr(c, expr);
			if (cond_type_sym->kind == v__table__Kind_interface_) {
				v__token__Position expr_pos = v__ast__Expr_position(expr);
				v__checker__Checker_type_implements(c, expr_type, c->expected_type, expr_pos);
			} else if ((cond_type_sym->info).typ == 354 /* v.table.SumType */) {
				if (!_IN(v__table__Type, expr_type, (*cond_type_sym->info._354).variants)) {
					string expr_str = v__table__Table_type_to_str(c->table, expr_type);
					string expect_str = v__table__Table_type_to_str(c->table, c->expected_type);
					v__checker__Checker_error(c, _STR("`%.*s\000` has no variant `%.*s\000`", 3, expect_str, expr_str), v__ast__Expr_position(expr));
				}
			} else if (!v__checker__Checker_check_types(c, expr_type, c->expected_type)) {
				string expr_str = v__table__Table_type_to_str(c->table, expr_type);
				string expect_str = v__table__Table_type_to_str(c->table, c->expected_type);
				v__checker__Checker_error(c, _STR("cannot match `%.*s\000` with `%.*s\000` condition", 3, expr_str, expect_str), v__ast__Expr_position(expr));
			}
			map_set(&branch_exprs, key, &(int[]) { val + 1 });
		}
		if (expr_types.len > 0) {
			if (cond_type_sym->kind == v__table__Kind_sum_type) {
				v__table__Type expr_type = ((v__table__Type)(0));
				if (expr_types.len > 1) {
					strings__Builder agg_name = strings__new_builder(20);
					strings__Builder_write(&agg_name, tos_lit("("));
					// FOR IN array
					array _t1055 = expr_types;
					for (int i = 0; i < _t1055.len; ++i) {
						v__ast__Type expr = ((v__ast__Type*)_t1055.data)[i];
						if (i > 0) {
							strings__Builder_write(&agg_name, tos_lit(" | "));
						}
						string type_str = v__table__Table_type_to_str(c->table, expr.typ);
						strings__Builder_write(&agg_name, (c->is_builtin_mod ? (type_str) : (_STR("%.*s\000.%.*s", 2, c->mod, type_str))));
					}
					strings__Builder_write(&agg_name, tos_lit(")"));
					string name = strings__Builder_str(&agg_name);

					int _t1056_len = expr_types.len;
					array_v__table__Type _t1056 = __new_array(0, _t1056_len, sizeof(v__table__Type));
					for (int _t1057 = 0; _t1057 < _t1056_len; ++_t1057) {
						v__ast__Type it = ((v__ast__Type*) expr_types.data)[_t1057];
						v__table__Type ti = it.typ;
						array_push(&_t1056, &ti);
					}
										expr_type = v__table__Table_register_type_symbol(c->table, (v__table__TypeSymbol){.parent_idx = 0,.info = /* sum type cast 4 */ (v__table__TypeInfo){._346 = memdup(&(v__table__Aggregate[]){(v__table__Aggregate){.fields = __new_array(0, 1, sizeof(v__table__Field)),.types = _t1056,}}, sizeof(v__table__Aggregate)), .typ = 346 /* v.table.Aggregate */},.kind = v__table__Kind_aggregate,.name = name,.source_name = name,.methods = __new_array(0, 1, sizeof(v__table__Fn)),.mod = c->mod,.is_public = 0,.is_written = 0,.language = 0,});
				} else {
					expr_type = (*(v__ast__Type*)/*ee elem_typ */array_get(expr_types, 0)).typ;
				}
				v__ast__Scope* scope = v__ast__Scope_innermost(c->file->scope, branch.pos.pos);
				v__ast__Expr _t1058 = node->cond;
				if (_t1058.typ == 241 /* v.ast.SelectorExpr */) {
					bool is_mut = false;
					array_v__table__Type sum_type_casts = __new_array_with_default(0, 0, sizeof(v__table__Type), 0);
					v__table__TypeSymbol* expr_sym = v__table__Table_get_type_symbol(c->table, (*node->cond._241).expr_type);
					{ /* if guard */ 
					Option_v__table__Field _t1059;
					if (_t1059 = v__table__Table_struct_find_field(c->table, expr_sym, (*node->cond._241).field_name), _t1059.ok) {
						v__table__Field field = *(v__table__Field*)_t1059.data;
						is_mut = field.is_mut;
					}}
					{ /* if guard */ 
					Option_v__ast__ScopeStructField _t1060;
					if (_t1060 = v__ast__Scope_find_struct_field(scope, (*node->cond._241).expr_type, (*node->cond._241).field_name), _t1060.ok) {
						v__ast__ScopeStructField field = *(v__ast__ScopeStructField*)_t1060.data;
						_PUSH_MANY(&sum_type_casts, (field.sum_type_casts), _t1061, array_v__table__Type);
					}}
					if (!is_mut || (*node->cond._241).is_mut) {
						array_push(&sum_type_casts, _MOV((v__table__Type[]){ expr_type }));
						v__ast__Scope_register_struct_field(scope, (v__ast__ScopeStructField){.struct_type = (*node->cond._241).expr_type,.name = (*node->cond._241).field_name,.pos = (*node->cond._241).pos,.typ = node->cond_type,.sum_type_casts = sum_type_casts,});
					}
				} else if (_t1058.typ == 224 /* v.ast.Ident */) {
					bool is_mut = false;
					array_v__table__Type sum_type_casts = __new_array_with_default(0, 0, sizeof(v__table__Type), 0);
					bool is_already_casted = false;
					{ /* if guard */ 
					Option_v__ast__Var_ptr _t1063;
					if (_t1063 = v__ast__Scope_find_var(scope, (*node->cond._224).name), _t1063.ok) {
						v__ast__Var* v = *(v__ast__Var**)_t1063.data;
						is_mut = v->is_mut;
						_PUSH_MANY(&sum_type_casts, (v->sum_type_casts), _t1064, array_v__table__Type);
						is_already_casted = v->pos.pos == (*node->cond._224).pos.pos;
					}}
					if ((!is_mut || (*node->cond._224).is_mut) && !is_already_casted) {
						array_push(&sum_type_casts, _MOV((v__table__Type[]){ expr_type }));
						v__ast__Scope_register(scope, (*node->cond._224).name, /* sum type cast 4 */ (v__ast__ScopeObject){._277 = memdup(&(v__ast__Var[]){(v__ast__Var){
							.name = (*node->cond._224).name,
							.expr = {0},
							.share = 0,
							.is_mut = (*node->cond._224).is_mut,
							.is_autofree_tmp = 0,
							.is_arg = 0,
							.typ = node->cond_type,
							.sum_type_casts = sum_type_casts,
							.pos = (*node->cond._224).pos,
							.is_used = true,
							.is_changed = 0,
						}}, sizeof(v__ast__Var)), .typ = 277 /* v.ast.Var */});
					}
				} else {
				};
			}
		}
	}
	bool is_exhaustive = true;
	array_string unhandled = __new_array_with_default(0, 0, sizeof(string), 0);
	v__table__TypeInfo _t1066 = type_sym.info;
	if (_t1066.typ == 354 /* v.table.SumType */) {
		// FOR IN array
		array _t1067 = (*type_sym.info._354).variants;
		for (int _t1068 = 0; _t1068 < _t1067.len; ++_t1068) {
			v__table__Type v = ((v__table__Type*)_t1067.data)[_t1068];
			string v_str = v__table__Table_type_to_str(c->table, v);
			if (!_IN_MAP(v_str, branch_exprs)) {
				is_exhaustive = false;
				array_push(&unhandled, _MOV((string[]){ string_clone(_STR("`%.*s\000`", 2, v_str)) }));
			}
		}
	} else if (_t1066.typ == 355 /* v.table.Enum */) {
		// FOR IN array
		array _t1070 = (*type_sym.info._355).vals;
		for (int _t1071 = 0; _t1071 < _t1070.len; ++_t1071) {
			string v = ((string*)_t1070.data)[_t1071];
			if (!_IN_MAP(v, branch_exprs)) {
				is_exhaustive = false;
				array_push(&unhandled, _MOV((string[]){ string_clone(_STR("`.%.*s\000`", 2, v)) }));
			}
		}
	} else {
		is_exhaustive = false;
	};
	v__ast__MatchBranch else_branch = (*(v__ast__MatchBranch*)/*ee elem_typ */array_get(node->branches, node->branches.len - 1));
	bool has_else = else_branch.is_else;
	if (!has_else) {
		// FOR IN array
		array _t1073 = node->branches;
		for (int i = 0; i < _t1073.len; ++i) {
			v__ast__MatchBranch branch = ((v__ast__MatchBranch*)_t1073.data)[i];
			if (branch.is_else && i != node->branches.len - 1) {
				v__checker__Checker_error(c, tos_lit("`else` must be the last branch of `match`"), branch.pos);
				else_branch = branch;
				has_else = true;
			}
		}
	}
	if (is_exhaustive) {
		if (has_else) {
			v__checker__Checker_error(c, tos_lit("match expression is exhaustive, `else` is unnecessary"), else_branch.pos);
		}
		return;
	}
	if (has_else) {
		return;
	}
	string err_details = tos_lit("match must be exhaustive");
	if (unhandled.len > 0) {
		err_details = /*f*/string_add(err_details, tos_lit(" (add match branches for: "));
		if (unhandled.len < _const_v__checker__match_exhaustive_cutoff_limit) {
			err_details = /*f*/string_add(err_details, array_string_join(unhandled, tos_lit(", ")));
		} else {
			int remaining = unhandled.len - _const_v__checker__match_exhaustive_cutoff_limit;
			err_details = /*f*/string_add(err_details, array_string_join(array_slice(unhandled, 0, _const_v__checker__match_exhaustive_cutoff_limit), tos_lit(", ")));
			err_details = /*f*/string_add(err_details, _STR(", and %"PRId32"\000 others ...", 2, remaining));
		}
		err_details = /*f*/string_add(err_details, tos_lit(" or `else {}` at the end)"));
	} else {
		err_details = /*f*/string_add(err_details, tos_lit(" (add `else {}` at the end)"));
	}
	v__checker__Checker_error(c, err_details, node->pos);
}

v__table__Type v__checker__Checker_select_expr(v__checker__Checker* c, v__ast__SelectExpr* node) {
	node->is_expr = c->expected_type != _const_v__table__void_type;
	node->expected_type = c->expected_type;
	// FOR IN array
	array _t1074 = node->branches;
	for (int _t1075 = 0; _t1075 < _t1074.len; ++_t1075) {
		v__ast__SelectBranch branch = ((v__ast__SelectBranch*)_t1074.data)[_t1075];
		v__checker__Checker_stmt(c, branch.stmt);
		v__ast__Stmt _t1076 = branch.stmt;
		if (_t1076.typ == 259 /* v.ast.ExprStmt */) {
			if (branch.is_timeout) {
				if (!v__table__Type_is_int((*branch.stmt._259).typ)) {
					v__table__TypeSymbol* tsym = v__table__Table_get_type_symbol(c->table, (*branch.stmt._259).typ);
					v__checker__Checker_error(c, _STR("invalid type `%.*s\000` for timeout - expected integer type aka `time.Duration`", 2, tsym->name), (*branch.stmt._259).pos);
				}
			} else {
				if (((*branch.stmt._259).expr).typ == 228 /* v.ast.InfixExpr */) {
					if (((*(*branch.stmt._259).expr._228).left).typ != 224 /* v.ast.Ident */ && ((*(*branch.stmt._259).expr._228).left).typ != 241 /* v.ast.SelectorExpr */ && ((*(*branch.stmt._259).expr._228).left).typ != 227 /* v.ast.IndexExpr */) {
						v__checker__Checker_error(c, tos_lit("channel in `select` key must be predefined"), v__ast__Expr_position((*(*branch.stmt._259).expr._228).left));
					}
				} else {
					v__checker__Checker_error(c, tos_lit("invalid expression for `select` key"), v__ast__Expr_position((*branch.stmt._259).expr));
				}
			}
		} else if (_t1076.typ == 252 /* v.ast.AssignStmt */) {
			v__ast__Expr expr = (*(v__ast__Expr*)/*ee elem_typ */array_get((*branch.stmt._252).right, 0));
			v__ast__Expr _t1077 = expr;
			if (_t1077.typ == 238 /* v.ast.PrefixExpr */) {
				if (((*expr._238).right).typ != 224 /* v.ast.Ident */ && ((*expr._238).right).typ != 241 /* v.ast.SelectorExpr */ && ((*expr._238).right).typ != 227 /* v.ast.IndexExpr */) {
					v__checker__Checker_error(c, tos_lit("channel in `select` key must be predefined"), v__ast__Expr_position((*expr._238).right));
				}
				if ((*expr._238).or_block.kind != v__ast__OrKind_absent) {
					string err_prefix = ((*expr._238).or_block.kind == v__ast__OrKind_block ? (tos_lit("or block")) : (tos_lit("error propagation")));
					v__checker__Checker_error(c, _STR("%.*s\000 not allowed in `select` key", 2, err_prefix), (*expr._238).or_block.pos);
				}
			} else {
				v__checker__Checker_error(c, tos_lit("`<-` receive expression expected"), v__ast__Expr_position((*(v__ast__Expr*)/*ee elem_typ */array_get((*branch.stmt._252).right, 0))));
			};
		} else {
			if (!branch.is_else) {
				v__checker__Checker_error(c, tos_lit("receive or send statement expected as `select` key"), v__ast__Stmt_position(branch.stmt));
			}
		};
		v__checker__Checker_stmts(c, branch.stmts);
	}
	return _const_v__table__bool_type;
}

v__table__Type v__checker__Checker_lock_expr(v__checker__Checker* c, v__ast__LockExpr* node) {
	for (int i = 0; i < node->lockeds.len; ++i) {
		v__checker__Checker_ident(c, (voidptr)&/*qq*/(*(v__ast__Ident*)/*ee elem_typ */array_get(node->lockeds, i)));
		v__ast__Ident id = (*(v__ast__Ident*)/*ee elem_typ */array_get(node->lockeds, i));
		if ((id.obj).typ == 277 /* v.ast.Var */) {
			if (v__table__Type_share((*id.obj._277).typ) != v__table__ShareType_shared_t) {
				v__checker__Checker_error(c, _STR("`%.*s\000` must be declared `shared` to be locked", 2, id.name), id.pos);
			}
		} else {
			v__checker__Checker_error(c, _STR("`%.*s\000` is not a variable and cannot be locked", 2, id.name), id.pos);
		}
		if (_IN(string, id.name, c->locked_names)) {
			v__checker__Checker_error(c, _STR("`%.*s\000` is already locked", 2, id.name), id.pos);
		} else if (_IN(string, id.name, c->rlocked_names)) {
			v__checker__Checker_error(c, _STR("`%.*s\000` is already read-locked", 2, id.name), id.pos);
		}
		if (node->is_rlock) {
			array_push(&c->rlocked_names, _MOV((string[]){ string_clone(id.name) }));
		} else {
			array_push(&c->locked_names, _MOV((string[]){ string_clone(id.name) }));
		}
	}
	v__checker__Checker_stmts(c, node->stmts);
	if (node->is_rlock) {
		c->rlocked_names = array_slice(c->rlocked_names, 0, c->rlocked_names.len - node->lockeds.len);
	} else {
		c->locked_names = array_slice(c->locked_names, 0, c->locked_names.len - node->lockeds.len);
	}
	return _const_v__table__void_type;
}

v__table__Type v__checker__Checker_unsafe_expr(v__checker__Checker* c, v__ast__UnsafeExpr* node) {
	// assert
	if (!c->inside_unsafe) {} else {
		VAssertMetaInfo v_assert_meta_info__t1080;
		memset(&v_assert_meta_info__t1080, 0, sizeof(VAssertMetaInfo));
		v_assert_meta_info__t1080.fpath = tos_lit("/tmp/gen_vc/v/vlib/v/checker/checker.v");
		v_assert_meta_info__t1080.line_nr = 3789;
		v_assert_meta_info__t1080.fn_name = tos_lit("unsafe_expr");
		v_assert_meta_info__t1080.src = tos_lit("!c.inside_unsafe");
		__print_assert_failure(&v_assert_meta_info__t1080);
		v_panic(tos_lit("Assertion failed..."));
		exit(1);
	}
	c->inside_unsafe = true;
	v__table__Type t = v__checker__Checker_expr(c, node->expr);
	c->inside_unsafe = false;
	return t;
}

v__table__Type v__checker__Checker_if_expr(v__checker__Checker* c, v__ast__IfExpr* node) {
	string if_kind = (node->is_comptime ? (tos_lit("$if")) : (tos_lit("if")));
	bool expr_required = c->expected_type != _const_v__table__void_type;
	v__table__Type former_expected_type = c->expected_type;
	node->typ = _const_v__table__void_type;
	int nbranches_with_return = 0;
	int nbranches_without_return = 0;
	bool should_skip = false;
	bool found_branch = false;
	for (int i = 0; i < node->branches.len; ++i) {
		v__ast__IfBranch branch = (*(v__ast__IfBranch*)/*ee elem_typ */array_get(node->branches, i));
		if ((branch.cond).typ == 236 /* v.ast.ParExpr */) {
			v__checker__Checker_error(c, _STR("unnecessary `()` in `%.*s\000` condition, use `%.*s\000 expr {` instead of `%.*s\000 (expr) {`.", 4, if_kind, if_kind, if_kind), branch.pos);
		}
		if (!node->has_else || i < node->branches.len - 1) {
			if (node->is_comptime) {
				should_skip = v__checker__Checker_comp_if_branch(c, branch.cond, branch.pos);
			} else {
				c->expected_type = _const_v__table__bool_type;
				v__table__Type cond_typ = v__checker__Checker_expr(c, branch.cond);
				if (!(v__table__Type_idx(cond_typ) == _const_v__table__bool_type_idx || v__table__Type_idx(cond_typ) == _const_v__table__void_type_idx) && !c->pref->translated) {
					v__table__TypeSymbol* typ_sym = v__table__Table_get_type_symbol(c->table, cond_typ);
					v__checker__Checker_error(c, _STR("non-bool type `%.*s\000` used as if condition", 2, typ_sym->source_name), branch.pos);
				}
			}
		}
		if (!node->is_comptime && (branch.cond).typ == 228 /* v.ast.InfixExpr */) {
			v__ast__InfixExpr infix = /* as */ *(v__ast__InfixExpr*)__as_cast((branch.cond)._228, (branch.cond).typ, /*expected:*/228);
			if (infix.op == v__token__Kind_key_is) {
				v__ast__Type right_expr = /* as */ *(v__ast__Type*)__as_cast((infix.right)._247, (infix.right).typ, /*expected:*/247);
				v__table__TypeSymbol* left_sym = v__table__Table_get_type_symbol(c->table, infix.left_type);
				v__table__Type expr_type = v__checker__Checker_expr(c, infix.left);
				if (left_sym->kind == v__table__Kind_interface_) {
					v__checker__Checker_type_implements(c, right_expr.typ, expr_type, branch.pos);
				} else if (!v__checker__Checker_check_types(c, expr_type, right_expr.typ)) {
					string expect_str = v__table__Table_type_to_str(c->table, right_expr.typ);
					string expr_str = v__table__Table_type_to_str(c->table, expr_type);
					v__checker__Checker_error(c, _STR("cannot use type `%.*s\000` as type `%.*s\000`", 3, expect_str, expr_str), branch.pos);
				}
				if (((infix.left).typ == 224 /* v.ast.Ident */ || (infix.left).typ == 241 /* v.ast.SelectorExpr */) && (infix.right).typ == 247 /* v.ast.Type */) {
					bool is_variable = ((infix.left).typ == 224 /* v.ast.Ident */ ? ((*infix.left._224).kind == v__ast__IdentKind_variable) : (true));
					if (is_variable) {
						if ((left_sym->kind == v__table__Kind_interface_ || left_sym->kind == v__table__Kind_sum_type)) {
							bool is_mut = false;
							v__ast__Scope* scope = v__ast__Scope_innermost(c->file->scope, branch.body_pos.pos);
							if ((infix.left).typ == 224 /* v.ast.Ident */) {
								array_v__table__Type sum_type_casts = __new_array_with_default(0, 0, sizeof(v__table__Type), 0);
								{ /* if guard */ 
								Option_v__ast__Var_ptr _t1081;
								if (_t1081 = v__ast__Scope_find_var(scope, (*infix.left._224).name), _t1081.ok) {
									v__ast__Var* v = *(v__ast__Var**)_t1081.data;
									is_mut = v->is_mut;
									_PUSH_MANY(&sum_type_casts, (v->sum_type_casts), _t1082, array_v__table__Type);
								}}
								if (left_sym->kind == v__table__Kind_sum_type) {
									if (!is_mut || (*infix.left._224).is_mut) {
										array_push(&sum_type_casts, _MOV((v__table__Type[]){ right_expr.typ }));
										v__ast__Scope_register(scope, (*infix.left._224).name, /* sum type cast 4 */ (v__ast__ScopeObject){._277 = memdup(&(v__ast__Var[]){(v__ast__Var){
											.name = (*infix.left._224).name,
											.expr = {0},
											.share = 0,
											.is_mut = is_mut,
											.is_autofree_tmp = 0,
											.is_arg = 0,
											.typ = infix.left_type,
											.sum_type_casts = sum_type_casts,
											.pos = (*infix.left._224).pos,
											.is_used = true,
											.is_changed = 0,
										}}, sizeof(v__ast__Var)), .typ = 277 /* v.ast.Var */});
									}
								} else if (left_sym->kind == v__table__Kind_interface_) {
									v__ast__Scope_register(scope, (*infix.left._224).name, /* sum type cast 4 */ (v__ast__ScopeObject){._277 = memdup(&(v__ast__Var[]){(v__ast__Var){
										.name = (*infix.left._224).name,
										.expr = {0},
										.share = 0,
										.is_mut = is_mut,
										.is_autofree_tmp = 0,
										.is_arg = 0,
										.typ = v__table__Type_to_ptr(right_expr.typ),
										.sum_type_casts = sum_type_casts,
										.pos = (*infix.left._224).pos,
										.is_used = true,
										.is_changed = 0,
									}}, sizeof(v__ast__Var)), .typ = 277 /* v.ast.Var */});
									(*(v__ast__IfBranch*)/*ee elem_typ */array_get(node->branches, i)).smartcast = true;
								}
							} else if ((infix.left).typ == 241 /* v.ast.SelectorExpr */) {
								array_v__table__Type sum_type_casts = __new_array_with_default(0, 0, sizeof(v__table__Type), 0);
								v__table__TypeSymbol* expr_sym = v__table__Table_get_type_symbol(c->table, (*infix.left._241).expr_type);
								{ /* if guard */ 
								Option_v__table__Field _t1084;
								if (_t1084 = v__table__Table_struct_find_field(c->table, expr_sym, (*infix.left._241).field_name), _t1084.ok) {
									v__table__Field field = *(v__table__Field*)_t1084.data;
									is_mut = field.is_mut;
								}}
								{ /* if guard */ 
								Option_v__ast__ScopeStructField _t1085;
								if (_t1085 = v__ast__Scope_find_struct_field(scope, (*infix.left._241).expr_type, (*infix.left._241).field_name), _t1085.ok) {
									v__ast__ScopeStructField field = *(v__ast__ScopeStructField*)_t1085.data;
									_PUSH_MANY(&sum_type_casts, (field.sum_type_casts), _t1086, array_v__table__Type);
								}}
								if ((!is_mut || (*infix.left._241).is_mut) && left_sym->kind == v__table__Kind_sum_type) {
									array_push(&sum_type_casts, _MOV((v__table__Type[]){ right_expr.typ }));
									v__ast__Scope_register_struct_field(scope, (v__ast__ScopeStructField){.struct_type = (*infix.left._241).expr_type,.name = (*infix.left._241).field_name,.pos = (*infix.left._241).pos,.typ = infix.left_type,.sum_type_casts = sum_type_casts,});
								}
							}
						}
					}
				}
			}
		}
		if (node->is_comptime) {
			bool cur_skip_flags = c->skip_flags;
			if (found_branch) {
				c->skip_flags = true;
			} else if (should_skip) {
				c->skip_flags = true;
				should_skip = false;
			} else {
				found_branch = true;
			}
			if (!c->skip_flags || c->pref->output_cross_c) {
				v__checker__Checker_stmts(c, branch.stmts);
			} else {
				(*(v__ast__IfBranch*)/*ee elem_typ */array_get(node->branches, i)).stmts = __new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
			}
			c->skip_flags = cur_skip_flags;
		} else {
			v__checker__Checker_stmts(c, branch.stmts);
		}
		if (expr_required) {
			if (branch.stmts.len > 0 && ((*(v__ast__Stmt*)/*ee elem_typ */array_get(branch.stmts, branch.stmts.len - 1))).typ == 259 /* v.ast.ExprStmt */) {
				v__ast__ExprStmt last_expr = /* as */ *(v__ast__ExprStmt*)__as_cast(((*(v__ast__Stmt*)/*ee elem_typ */array_get(branch.stmts, branch.stmts.len - 1)))._259, ((*(v__ast__Stmt*)/*ee elem_typ */array_get(branch.stmts, branch.stmts.len - 1))).typ, /*expected:*/259);
				c->expected_type = former_expected_type;
				last_expr.typ = v__checker__Checker_expr(c, last_expr.expr);
				if (!v__checker__Checker_check_types(c, last_expr.typ, node->typ)) {
					if (node->typ == _const_v__table__void_type) {
						node->is_expr = true;
						node->typ = last_expr.typ;
						continue;
					} else if ((node->typ == _const_v__table__any_flt_type || node->typ == _const_v__table__any_int_type)) {
						if (node->typ == _const_v__table__any_int_type) {
							if (v__table__Type_is_int(last_expr.typ) || v__table__Type_is_float(last_expr.typ)) {
								node->typ = last_expr.typ;
								continue;
							}
						} else {
							if (v__table__Type_is_float(last_expr.typ)) {
								node->typ = last_expr.typ;
								continue;
							}
						}
					}
					if ((last_expr.typ == _const_v__table__any_flt_type || last_expr.typ == _const_v__table__any_int_type)) {
						if (last_expr.typ == _const_v__table__any_int_type) {
							if (v__table__Type_is_int(node->typ) || v__table__Type_is_float(node->typ)) {
								continue;
							}
						} else {
							if (v__table__Type_is_float(node->typ)) {
								continue;
							}
						}
					}
					v__checker__Checker_error(c, _STR("mismatched types `%.*s\000` and `%.*s\000`", 3, v__table__Table_type_to_str(c->table, node->typ), v__table__Table_type_to_str(c->table, last_expr.typ)), node->pos);
				}
			} else {
				v__checker__Checker_error(c, _STR("`%.*s\000` expression requires an expression as the last statement of every branch", 2, if_kind), branch.pos);
			}
			// FOR IN array
			array _t1088 = branch.stmts;
			for (int _t1089 = 0; _t1089 < _t1088.len; ++_t1089) {
				v__ast__Stmt st = ((v__ast__Stmt*)_t1088.data)[_t1089];
				Option_void _t1090 = v__ast__Stmt_check_c_expr(st);
				if (!_t1090.ok && !_t1090.is_none) {
					string err = _t1090.v_error;
					int errcode = _t1090.ecode;
					v__checker__Checker_error(c, _STR("`if` expression branch has %.*s", 1, err), v__ast__Stmt_position(st));
				};
			}
		}
		{ /* if guard */ 
		Option_bool _t1091;
		if (_t1091 = v__checker__Checker_has_return(c, branch.stmts), _t1091.ok) {
			bool has_return = *(bool*)_t1091.data;
			if (has_return) {
				nbranches_with_return++;
			} else {
				nbranches_without_return++;
			}
		}}
	}
	if (nbranches_with_return > 0) {
		if (nbranches_with_return == node->branches.len) {
			c->returns = true;
		}
		if (!node->has_else) {
			c->returns = false;
		}
		if (nbranches_without_return > 0) {
			c->returns = false;
		}
	}
	if (node->typ == _const_v__table__any_int_type) {
		node->typ = _const_v__table__int_type;
	} else if (node->typ == _const_v__table__any_flt_type) {
		node->typ = _const_v__table__f64_type;
	}
	if (expr_required) {
		if (!node->has_else) {
			string d = (node->is_comptime ? (tos_lit("$")) : (tos_lit("")));
			v__checker__Checker_error(c, _STR("`%.*s\000` expression needs `%.*s\000else` clause", 3, if_kind, d), node->pos);
		}
		return node->typ;
	}
	return _const_v__table__bool_type;
}

VV_LOCAL_SYMBOL bool v__checker__Checker_comp_if_branch(v__checker__Checker* c, v__ast__Expr cond, v__token__Position pos) {
	v__ast__Expr _t1092 = cond;
	if (_t1092.typ == 236 /* v.ast.ParExpr */) {
		return v__checker__Checker_comp_if_branch(c, (*cond._236).expr, pos);
	} else if (_t1092.typ == 238 /* v.ast.PrefixExpr */) {
		if ((*cond._238).op != v__token__Kind_not) {
			v__checker__Checker_error(c, tos_lit("invalid `$if` condition"), (*cond._238).pos);
		}
		return !v__checker__Checker_comp_if_branch(c, (*cond._238).right, (*cond._238).pos);
	} else if (_t1092.typ == 237 /* v.ast.PostfixExpr */) {
		if ((*cond._237).op != v__token__Kind_question) {
			v__checker__Checker_error(c, tos_lit("invalid $if postfix operator"), (*cond._237).pos);
		} else if (((*cond._237).expr).typ == 224 /* v.ast.Ident */) {
			return !_IN(string, (*(*cond._237).expr._224).name, c->pref->compile_defines_all);
		} else {
			v__checker__Checker_error(c, tos_lit("invalid `$if` condition"), (*cond._237).pos);
		}
	} else if (_t1092.typ == 228 /* v.ast.InfixExpr */) {
		v__token__Kind _t1093 = (*cond._228).op;
		if (_t1093 == v__token__Kind_and) {
			bool l = v__checker__Checker_comp_if_branch(c, (*cond._228).left, (*cond._228).pos);
			bool r = v__checker__Checker_comp_if_branch(c, (*cond._228).right, (*cond._228).pos);
			return l || r;
		} else if (_t1093 == v__token__Kind_logical_or) {
			bool l = v__checker__Checker_comp_if_branch(c, (*cond._228).left, (*cond._228).pos);
			bool r = v__checker__Checker_comp_if_branch(c, (*cond._228).right, (*cond._228).pos);
			return l && r;
		} else if (_t1093 == v__token__Kind_key_is || _t1093 == v__token__Kind_not_is) {
			if (((*cond._228).left).typ != 241 /* v.ast.SelectorExpr */ || ((*cond._228).right).typ != 247 /* v.ast.Type */) {
				v__checker__Checker_error(c, tos_lit("invalid `$if` condition"), (*cond._228).pos);
			}
		} else if (_t1093 == v__token__Kind_eq || _t1093 == v__token__Kind_ne) {
			if (((*cond._228).left).typ != 241 /* v.ast.SelectorExpr */ || ((*cond._228).right).typ != 229 /* v.ast.IntegerLiteral */) {
				v__checker__Checker_error(c, tos_lit("invalid `$if` condition"), (*cond._228).pos);
			}
		} else {
			v__checker__Checker_error(c, tos_lit("invalid `$if` condition"), (*cond._228).pos);
		};
	} else if (_t1092.typ == 224 /* v.ast.Ident */) {
		if (_IN(string, (*cond._224).name, _const_v__checker__valid_comp_if_os)) {
			return string_ne((*cond._224).name, string_to_lower(v__pref__OS_str(c->pref->os)));
		} else if (_IN(string, (*cond._224).name, _const_v__checker__valid_comp_if_compilers)) {
			return v__pref__cc_from_string((*cond._224).name) != c->pref->ccompiler_type;
		} else if (_IN(string, (*cond._224).name, _const_v__checker__valid_comp_if_platforms)) {
			return false;
		} else if (_IN(string, (*cond._224).name, _const_v__checker__valid_comp_if_other)) {
			string _t1094 = (*cond._224).name;
			if (string_eq(_t1094, tos_lit("js"))) {
				return c->pref->backend != v__pref__Backend_js;
			} else if (string_eq(_t1094, tos_lit("debug"))) {
				return !c->pref->is_debug;
			} else if (string_eq(_t1094, tos_lit("test"))) {
				return !c->pref->is_test;
			} else if (string_eq(_t1094, tos_lit("glibc"))) {
				return false;
			} else if (string_eq(_t1094, tos_lit("prealloc"))) {
				return !c->pref->prealloc;
			} else if (string_eq(_t1094, tos_lit("no_bounds_checking"))) {
				return !_IN(string, (*cond._224).name, c->pref->compile_defines_all);
			} else {
				return false;
			};
		} else {
			if (!_IN(string, (*cond._224).name, c->pref->compile_defines_all)) {
				v__checker__Checker_error(c, tos_lit("unknown $if value"), pos);
			}
		}
	} else {
		v__checker__Checker_error(c, tos_lit("invalid `$if` condition"), pos);
	};
	return false;
}

VV_LOCAL_SYMBOL Option_bool v__checker__Checker_has_return(v__checker__Checker* c, array_v__ast__Stmt stmts) {
	bool has_complexity = false;
	// FOR IN array
	array _t1095 = stmts;
	for (int _t1096 = 0; _t1096 < _t1095.len; ++_t1096) {
		v__ast__Stmt s = ((v__ast__Stmt*)_t1095.data)[_t1096];
		if ((s).typ == 259 /* v.ast.ExprStmt */) {
			if (((*s._259).expr).typ == 225 /* v.ast.IfExpr */ || ((*s._259).expr).typ == 233 /* v.ast.MatchExpr */) {
				has_complexity = true;
				break;
			}
		}
	}
	if (!has_complexity || !c->returns) {
		Option_bool _t1097;
		opt_ok2(&(bool[]) { v__checker__has_top_return(stmts) }, (OptionBase*)(&_t1097), sizeof(bool));
		return _t1097;
	}
	Option _t1098 = opt_none();
	return *(Option_bool*)&_t1098;
}

v__table__Type v__checker__Checker_postfix_expr(v__checker__Checker* c, v__ast__PostfixExpr* node) {
	v__table__Type typ = v__checker__Checker_expr(c, node->expr);
	v__table__TypeSymbol* typ_sym = v__table__Table_get_type_symbol(c->table, typ);
	if (!v__table__TypeSymbol_is_number(typ_sym)) {
		v__checker__Checker_error(c, _STR("invalid operation: %.*s\000 (non-numeric type `%.*s\000`)", 3, v__token__Kind_str(node->op), typ_sym->source_name), node->pos);
	} else {
		multi_return_string_v__token__Position mr_134918 = v__checker__Checker_fail_if_immutable(c, node->expr);
		node->auto_locked = mr_134918.arg0;
	}
	if ((v__table__Type_is_ptr(typ) || v__table__TypeSymbol_is_pointer(typ_sym)) && !c->inside_unsafe) {
		v__checker__Checker_warn(c, tos_lit("pointer arithmetic is only allowed in `unsafe` blocks"), node->pos);
	}
	return typ;
}

VV_LOCAL_SYMBOL void v__checker__Checker_check_index_type(v__checker__Checker* c, v__table__TypeSymbol* typ_sym, v__table__Type index_type, v__token__Position pos) {
	v__table__TypeSymbol* index_type_sym = v__table__Table_get_type_symbol(c->table, index_type);
	if ((typ_sym->kind == v__table__Kind_array || typ_sym->kind == v__table__Kind_array_fixed || typ_sym->kind == v__table__Kind_string || typ_sym->kind == v__table__Kind_ustring)) {
		if (!(v__table__Type_is_number(index_type) || index_type_sym->kind == v__table__Kind_enum_)) {
			string type_str = ((typ_sym->kind == v__table__Kind_string || typ_sym->kind == v__table__Kind_ustring) ? (_STR("non-integer string index `%.*s\000`", 2, index_type_sym->source_name)) : (_STR("non-integer index `%.*s\000` (array type `%.*s\000`)", 3, index_type_sym->source_name, typ_sym->source_name)));
			v__checker__Checker_error(c, _STR("%.*s", 1, type_str), pos);
		}
		if (v__table__Type_has_flag(index_type, v__table__TypeFlag_optional)) {
			string type_str = ((typ_sym->kind == v__table__Kind_string || typ_sym->kind == v__table__Kind_ustring) ? (_STR("(type `%.*s\000`)", 2, typ_sym->source_name)) : (_STR("(array type `%.*s\000`)", 2, typ_sym->source_name)));
			v__checker__Checker_error(c, _STR("cannot use optional as index %.*s", 1, type_str), pos);
		}
	}
}

v__table__Type v__checker__Checker_index_expr(v__checker__Checker* c, v__ast__IndexExpr* node) {
	v__table__Type typ = v__checker__Checker_expr(c, node->left);
	node->left_type = typ;
	v__table__TypeSymbol* typ_sym = v__table__Table_get_type_symbol(c->table, typ);
	if (!(typ_sym->kind == v__table__Kind_array || typ_sym->kind == v__table__Kind_array_fixed || typ_sym->kind == v__table__Kind_string || typ_sym->kind == v__table__Kind_map) && !v__table__Type_is_ptr(typ) && !(!byte_is_capital(string_at(typ_sym->name, 0)) && string_ends_with(typ_sym->name, tos_lit("ptr"))) && !v__table__Type_has_flag(typ, v__table__TypeFlag_variadic)) {
		v__checker__Checker_error(c, _STR("type `%.*s\000` does not support indexing", 2, typ_sym->source_name), node->pos);
	}
	if (typ_sym->kind == v__table__Kind_string && !v__table__Type_is_ptr(typ) && node->is_setter) {
		v__checker__Checker_error(c, string_add(tos_lit("cannot assign to s[i] since V strings are immutable\n"), tos_lit("(note, that variables may be mutable but string values are always immutable, like in Go and Java)")), node->pos);
	}
	if (!c->inside_unsafe && (v__table__Type_is_ptr(typ) || v__table__Type_is_pointer(typ))) {
		bool is_ok = false;
		if ((node->left).typ == 224 /* v.ast.Ident */) {
			v__ast__Scope* scope = v__ast__Scope_innermost(c->file->scope, (*node->left._224).pos.pos);
			{ /* if guard */ 
			Option_v__ast__Var_ptr _t1099;
			if (_t1099 = v__ast__Scope_find_var(scope, (*node->left._224).name), _t1099.ok) {
				v__ast__Var* v = *(v__ast__Var**)_t1099.data;
				is_ok = v->is_mut && v->is_arg && !v__table__Type_is_ptr(v__table__Type_deref(typ));
			}}
		}
		if (!is_ok && !c->pref->translated) {
			v__checker__Checker_warn(c, tos_lit("pointer indexing is only allowed in `unsafe` blocks"), node->pos);
		}
	}
	if ((node->index).typ == 239 /* v.ast.RangeExpr */) {
		if ((*node->index._239).has_low) {
			v__table__Type index_type = v__checker__Checker_expr(c, (*node->index._239).low);
			v__checker__Checker_check_index_type(c, typ_sym, index_type, node->pos);
		}
		if ((*node->index._239).has_high) {
			v__table__Type index_type = v__checker__Checker_expr(c, (*node->index._239).high);
			v__checker__Checker_check_index_type(c, typ_sym, index_type, node->pos);
		}
		if (typ_sym->kind == v__table__Kind_array_fixed) {
			v__table__Type elem_type = v__table__Table_value_type(c->table, typ);
			int idx = v__table__Table_find_or_register_array(c->table, elem_type, 1, c->mod);
			return v__table__new_type(idx);
		}
		return v__table__Type_set_nr_muls(typ, 0);
	} else {
		v__table__Type index_type = v__checker__Checker_expr(c, node->index);
		v__checker__Checker_check_index_type(c, typ_sym, index_type, node->pos);
		if (typ_sym->kind == v__table__Kind_map && v__table__Type_idx(index_type) != _const_v__table__string_type_idx) {
			v__checker__Checker_error(c, _STR("non-string map index (map type `%.*s\000`)", 2, typ_sym->source_name), node->pos);
		}
		v__table__Type value_type = v__table__Table_value_type(c->table, typ);
		if (value_type != _const_v__table__void_type) {
			return value_type;
		}
	}
	return typ;
}

v__table__Type v__checker__Checker_enum_val(v__checker__Checker* c, v__ast__EnumVal* node) {
	int typ_idx = ((node->enum_name).len == 0 ? (v__table__Type_idx(c->expected_type)) : (v__table__Table_find_type_idx(c->table, node->enum_name)));
	if (typ_idx == 0) {
		v__checker__Checker_error(c, _STR("not an enum (name=%.*s\000) (type_idx=0)", 2, node->enum_name), node->pos);
		return _const_v__table__void_type;
	}
	v__table__Type typ = v__table__new_type(typ_idx);
	if (c->pref->translated) {
		node->typ = typ;
		return typ;
	}
	if (typ == _const_v__table__void_type) {
		v__checker__Checker_error(c, tos_lit("not an enum"), node->pos);
		return _const_v__table__void_type;
	}
	v__table__TypeSymbol* typ_sym = v__table__Table_get_type_symbol(c->table, typ);
	if (typ_sym->kind == v__table__Kind_array && node->enum_name.len == 0) {
		v__table__Array array_info = /* as */ *(v__table__Array*)__as_cast((typ_sym->info)._350, (typ_sym->info).typ, /*expected:*/350);
		typ = array_info.elem_type;
		typ_sym = v__table__Table_get_type_symbol(c->table, typ);
	}
	if (typ_sym->kind != v__table__Kind_enum_ && !c->pref->translated) {
		v__checker__Checker_error(c, _STR("expected type is not an enum (`%.*s\000`)", 2, typ_sym->source_name), node->pos);
		return _const_v__table__void_type;
	}
	if ((typ_sym->info).typ != 355 /* v.table.Enum */) {
		v__checker__Checker_error(c, tos_lit("not an enum"), node->pos);
		return _const_v__table__void_type;
	}
	v__table__Enum info = v__table__TypeSymbol_enum_info(typ_sym);
	if (!_IN(string, node->val, info.vals)) {
		v__checker__Checker_error(c, _STR("enum `%.*s\000` does not have a value `%.*s\000`", 3, typ_sym->source_name, node->val), node->pos);
	}
	node->typ = typ;
	return typ;
}

v__table__Type v__checker__Checker_chan_init(v__checker__Checker* c, v__ast__ChanInit* node) {
	if (node->typ != 0) {
		v__table__Chan info = v__table__TypeSymbol_chan_info(v__table__Table_get_type_symbol(c->table, node->typ));
		node->elem_type = info.elem_type;
		if (node->has_cap) {
			v__checker__Checker_check_array_init_para_type(c, tos_lit("cap"), node->cap_expr, node->pos);
		}
		return node->typ;
	} else {
		v__checker__Checker_error(c, tos_lit("`chan` of unknown type"), node->pos);
		return node->typ;
	}
	return 0;
}

v__table__Type v__checker__Checker_map_init(v__checker__Checker* c, v__ast__MapInit* node) {
	if (node->typ != 0) {
		v__table__Map info = v__table__TypeSymbol_map_info(v__table__Table_get_type_symbol(c->table, node->typ));
		v__table__TypeSymbol* key_sym = v__table__Table_get_type_symbol(c->table, info.key_type);
		v__table__TypeSymbol* value_sym = v__table__Table_get_type_symbol(c->table, info.value_type);
		if (key_sym->kind == v__table__Kind_placeholder) {
			v__checker__Checker_error(c, _STR("unknown type `%.*s\000`", 2, key_sym->source_name), node->pos);
		}
		if (value_sym->kind == v__table__Kind_placeholder) {
			v__checker__Checker_error(c, _STR("unknown type `%.*s\000`", 2, value_sym->source_name), node->pos);
		}
		node->key_type = info.key_type;
		node->value_type = info.value_type;
		return node->typ;
	}
	v__table__Type key0_type = v__table__Table_mktyp(c->table, v__checker__Checker_expr(c, (*(v__ast__Expr*)/*ee elem_typ */array_get(node->keys, 0))));
	v__table__Type val0_type = v__table__Table_mktyp(c->table, v__checker__Checker_expr(c, (*(v__ast__Expr*)/*ee elem_typ */array_get(node->vals, 0))));
	// FOR IN array
	array _t1100 = node->keys;
	for (int i = 0; i < _t1100.len; ++i) {
		v__ast__Expr key = ((v__ast__Expr*)_t1100.data)[i];
		v__ast__StringLiteral key_i = /* as */ *(v__ast__StringLiteral*)__as_cast((key)._245, (key).typ, /*expected:*/245);
		for (int j = 0; j < i; ++j) {
			v__ast__StringLiteral key_j = /* as */ *(v__ast__StringLiteral*)__as_cast(((*(v__ast__Expr*)/*ee elem_typ */array_get(node->keys, j)))._245, ((*(v__ast__Expr*)/*ee elem_typ */array_get(node->keys, j))).typ, /*expected:*/245);
			if (string_eq(key_i.val, key_j.val)) {
				v__checker__Checker_error(c, _STR("duplicate key \"%.*s\000\" in map literal", 2, key_i.val), v__ast__Expr_position(key));
			}
		}
		if (i == 0) {
			continue;
		}
		v__ast__Expr val = (*(v__ast__Expr*)/*ee elem_typ */array_get(node->vals, i));
		v__table__Type key_type = v__checker__Checker_expr(c, key);
		v__table__Type val_type = v__checker__Checker_expr(c, val);
		if (!v__checker__Checker_check_types(c, key_type, key0_type)) {
			v__table__TypeSymbol* key0_type_sym = v__table__Table_get_type_symbol(c->table, key0_type);
			v__table__TypeSymbol* key_type_sym = v__table__Table_get_type_symbol(c->table, key_type);
			v__checker__Checker_error(c, _STR("map init: cannot use `%.*s\000` as `%.*s\000` for map key", 3, key_type_sym->source_name, key0_type_sym->source_name), node->pos);
		}
		if (!v__checker__Checker_check_types(c, val_type, val0_type)) {
			v__table__TypeSymbol* val0_type_sym = v__table__Table_get_type_symbol(c->table, val0_type);
			v__table__TypeSymbol* val_type_sym = v__table__Table_get_type_symbol(c->table, val_type);
			v__checker__Checker_error(c, _STR("map init: cannot use `%.*s\000` as `%.*s\000` for map value", 3, val_type_sym->source_name, val0_type_sym->source_name), node->pos);
		}
	}
	v__table__Type map_type = v__table__new_type(v__table__Table_find_or_register_map(c->table, key0_type, val0_type));
	node->typ = map_type;
	node->key_type = key0_type;
	node->value_type = val0_type;
	return map_type;
}

void v__checker__Checker_add_error_detail(v__checker__Checker* c, string s) {
	array_push(&c->error_details, _MOV((string[]){ string_clone(s) }));
}

void v__checker__Checker_warn(v__checker__Checker* c, string s, v__token__Position pos) {
	bool allow_warnings = !(c->pref->is_prod || c->pref->warns_are_errors);
	v__checker__Checker_warn_or_error(c, s, pos, allow_warnings);
}

void v__checker__Checker_error(v__checker__Checker* c, string message, v__token__Position pos) {
	if (c->pref->translated && string_starts_with(message, tos_lit("mismatched types"))) {
		return;
	}
	if (c->pref->is_verbose) {
		print_backtrace();
	}
	string msg = string_replace(message, tos_lit("`array_"), tos_lit("`[]"));
	v__checker__Checker_warn_or_error(c, msg, pos, false);
}

VV_LOCAL_SYMBOL bool v__checker__Checker_check_struct_signature(v__checker__Checker c, v__table__Struct from, v__table__Struct to) {
	if (from.fields.len != to.fields.len) {
		return false;
	}
	// FOR IN array
	array _t1102 = from.fields;
	for (int _t1103 = 0; _t1103 < _t1102.len; ++_t1103) {
		v__table__Field field = ((v__table__Field*)_t1102.data)[_t1103];

int _t1104_len = to.fields.len;
		array_v__table__Field _t1104 = __new_array(0, _t1104_len, sizeof(v__table__Field));
		for (int i = 0; i < _t1104_len; ++i) {
		  v__table__Field it = ((v__table__Field*) to.fields.data)[i];
		if (string_eq(it.name, field.name)) array_push(&_t1104, &it); 
 }
				array_v__table__Field filtered =  _t1104;
		if (filtered.len != 1) {
			return false;
		}
		v__table__Field counterpart = (*(v__table__Field*)/*ee elem_typ */array_get(filtered, 0));
		if (field.typ != counterpart.typ) {
			return false;
		}
		if (field.is_pub != counterpart.is_pub) {
			return false;
		}
		if (field.is_mut != counterpart.is_mut) {
			return false;
		}
	}
	return true;
}

VV_LOCAL_SYMBOL void v__checker__Checker_warn_or_error(v__checker__Checker* c, string message, v__token__Position pos, bool warn) {
	string details = tos_lit("");
	if (c->error_details.len > 0) {
		details = array_string_join(c->error_details, tos_lit("\n"));
		c->error_details = __new_array_with_default(0, 0, sizeof(string), 0);
	}
	if (warn && !c->pref->skip_warnings) {
		c->nr_warnings++;
		v__errors__Warning wrn = (v__errors__Warning){.message = message,.details = details,.file_path = c->file->path,.pos = pos,.reporter = v__errors__Reporter_checker,};
		array_push(&c->file->warnings, _MOV((v__errors__Warning[]){ wrn }));
		array_push(&c->warnings, _MOV((v__errors__Warning[]){ wrn }));
		return;
	}
	if (!warn) {
		c->nr_errors++;
		if (!_IN(int, pos.line_nr, c->error_lines)) {
			v__errors__Error err = (v__errors__Error){.message = message,.details = details,.file_path = c->file->path,.pos = pos,.backtrace = (string){.str=(byteptr)""},.reporter = v__errors__Reporter_checker,};
			array_push(&c->file->errors, _MOV((v__errors__Error[]){ err }));
			array_push(&c->errors, _MOV((v__errors__Error[]){ err }));
			array_push(&c->error_lines, _MOV((int[]){ pos.line_nr }));
		}
	}
}

VV_LOCAL_SYMBOL bool v__checker__Checker_fileis(v__checker__Checker* c, string s) {
	return string_contains(c->file->path, s);
}

VV_LOCAL_SYMBOL v__table__Type v__checker__Checker_sql_expr(v__checker__Checker* c, v__ast__SqlExpr* node) {
	c->inside_sql = true;
	v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(c->table, node->table_type);
	if (sym->kind == v__table__Kind_placeholder) {
		v__checker__Checker_error(c, _STR("orm: unknown type `%.*s\000`", 2, sym->source_name), node->pos);
		// Defer begin
		c->inside_sql = false;
		// Defer end
		return _const_v__table__void_type;
	}
	c->cur_orm_ts = *sym;
	v__table__Struct info = /* as */ *(v__table__Struct*)__as_cast((sym->info)._155, (sym->info).typ, /*expected:*/155);
	array_v__table__Field fields = v__checker__Checker_fetch_and_verify_orm_fields(c, info, node->pos, node->table_name);
	node->fields = fields;
	node->table_name = sym->name;
	if (node->has_where) {
		v__checker__Checker_expr(c, node->where_expr);
	}
	if (node->has_offset) {
		v__checker__Checker_expr(c, node->offset_expr);
	}
	if (node->has_limit) {
		v__checker__Checker_expr(c, node->limit_expr);
	}
	if (node->has_order) {
		v__checker__Checker_expr(c, node->order_expr);
	}
	v__checker__Checker_expr(c, node->db_expr);
	// Defer begin
	c->inside_sql = false;
	// Defer end
	return node->typ;
}

VV_LOCAL_SYMBOL v__table__Type v__checker__Checker_sql_stmt(v__checker__Checker* c, v__ast__SqlStmt* node) {
	c->inside_sql = true;
	if (node->table_type == 0) {
		v__checker__Checker_error(c, _STR("orm: unknown type `%.*s\000`", 2, node->table_name), node->pos);
	}
	v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(c->table, node->table_type);
	if (sym->kind == v__table__Kind_placeholder) {
		v__checker__Checker_error(c, _STR("orm: unknown type `%.*s\000`", 2, sym->source_name), node->pos);
		// Defer begin
		c->inside_sql = false;
		// Defer end
		return _const_v__table__void_type;
	}
	c->cur_orm_ts = *sym;
	v__table__Struct info = /* as */ *(v__table__Struct*)__as_cast((sym->info)._155, (sym->info).typ, /*expected:*/155);
	array_v__table__Field fields = v__checker__Checker_fetch_and_verify_orm_fields(c, info, node->pos, node->table_name);
	node->fields = fields;
	v__checker__Checker_expr(c, node->db_expr);
	if (node->kind == v__ast__SqlStmtKind_update) {
		// FOR IN array
		array _t1110 = node->update_exprs;
		for (int _t1111 = 0; _t1111 < _t1110.len; ++_t1111) {
			v__ast__Expr expr = ((v__ast__Expr*)_t1110.data)[_t1111];
			v__checker__Checker_expr(c, expr);
		}
	}
	v__checker__Checker_expr(c, node->where_expr);
	// Defer begin
	c->inside_sql = false;
	// Defer end
	return _const_v__table__void_type;
}

VV_LOCAL_SYMBOL array_v__table__Field v__checker__Checker_fetch_and_verify_orm_fields(v__checker__Checker* c, v__table__Struct info, v__token__Position pos, string table_name) {

int _t1112_len = info.fields.len;
	array_v__table__Field _t1112 = __new_array(0, _t1112_len, sizeof(v__table__Field));
	for (int i = 0; i < _t1112_len; ++i) {
	  v__table__Field it = ((v__table__Field*) info.fields.data)[i];
	if ((it.typ == _const_v__table__string_type || it.typ == _const_v__table__int_type || it.typ == _const_v__table__bool_type) && !array_v__table__Attr_contains(it.attrs, tos_lit("skip"))) array_push(&_t1112, &it); 
 }
		array_v__table__Field fields =  _t1112;
	if (fields.len == 0) {
		v__checker__Checker_error(c, _STR("V orm: select: empty fields in `%.*s\000`", 2, table_name), pos);
	}
	if (string_ne((*(v__table__Field*)/*ee elem_typ */array_get(fields, 0)).name, tos_lit("id"))) {
		v__checker__Checker_error(c, _STR("V orm: `id int` must be the first field in `%.*s\000`", 2, table_name), pos);
	}
	return fields;
}

VV_LOCAL_SYMBOL void v__checker__Checker_post_process_generic_fns(v__checker__Checker* c) {
	for (int i = 0; i < c->generic_funcs.len; ++i) {
		if (c->table->fn_gen_types.len == 0) {
			continue;
		}
		v__ast__FnDecl* node = (*(v__ast__FnDecl**)/*ee elem_typ */array_get(c->generic_funcs, i));
		// FOR IN array
		array _t1113 = (*(array_v__table__Type*)map_get(c->table->fn_gen_types, node->name, &(array_v__table__Type[]){ __new_array(0, 1, sizeof(v__table__Type)) }));
		for (int _t1114 = 0; _t1114 < _t1113.len; ++_t1114) {
			v__table__Type gen_type = ((v__table__Type*)_t1113.data)[_t1114];
			c->cur_generic_type = gen_type;
			v__checker__Checker_fn_decl(c, node);
			if ((string_eq(node->name, tos_lit("vweb.run_app")) || string_eq(node->name, tos_lit("vweb.run")))) {
				array_push(&c->vweb_gen_types, _MOV((v__table__Type[]){ gen_type }));
			}
		}
		c->cur_generic_type = 0;
		(*(v__ast__FnDecl**)/*ee elem_typ */array_get(c->generic_funcs, i)) = 0;
	}
	c->generic_funcs = __new_array_with_default(0, 0, sizeof(v__ast__FnDecl*), 0);
}

VV_LOCAL_SYMBOL void v__checker__Checker_fn_decl(v__checker__Checker* c, v__ast__FnDecl* node) {
	c->returns = false;
	if (node->is_generic && c->cur_generic_type == 0) {
		array_push(&c->generic_funcs, _MOV((v__ast__FnDecl*[]){ node }));
		return;
	}
	if (node->language == v__table__Language_v && !c->is_builtin_mod) {
		v__checker__Checker_check_valid_snake_case(c, node->name, tos_lit("function name"), node->pos);
	}
	if (node->is_method) {
		v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(c->table, node->receiver.typ);
		if (sym->kind == v__table__Kind_interface_) {
			v__checker__Checker_error(c, tos_lit("interfaces cannot be used as method receiver"), node->receiver_pos);
		}
		if (sym->kind == v__table__Kind_sum_type && string_eq(node->name, tos_lit("type_name"))) {
			v__checker__Checker_error(c, tos_lit("method overrides built-in sum type method"), node->pos);
		}
		if (string_ne(sym->mod, c->mod) && !c->is_builtin_mod && (sym->mod).len != 0) {
			int idx = 0;
			// FOR IN array
			array _t1117 = sym->methods;
			for (int i = 0; i < _t1117.len; ++i) {
				v__table__Fn m = ((v__table__Fn*)_t1117.data)[i];
				if (string_eq(m.name, node->name)) {
					idx = i;
					break;
				}
			}
			array_delete(&sym->methods, idx);
			v__checker__Checker_error(c, string_add(_STR("cannot define new methods on non-local `%.*s\000` (", 2, sym->source_name), _STR("current module is `%.*s\000`, `%.*s\000` is from `%.*s\000`)", 4, c->mod, sym->source_name, sym->mod)), node->pos);
		}
		(*(v__table__Fn*)/*ee elem_typ */array_get(sym->methods, node->method_idx)).source_fn = ((voidptr)(node));
	}
	if (node->language == v__table__Language_v) {
		// FOR IN array
		array _t1118 = node->params;
		for (int _t1119 = 0; _t1119 < _t1118.len; ++_t1119) {
			v__table__Param arg = ((v__table__Param*)_t1118.data)[_t1119];
			v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(c->table, arg.typ);
			if (sym->kind == v__table__Kind_placeholder) {
				v__checker__Checker_error(c, _STR("unknown type `%.*s\000`", 2, sym->source_name), node->pos);
			}
		}
	}
	if (node->language == v__table__Language_v && node->is_method && string_eq(node->name, tos_lit("str"))) {
		if (node->return_type != _const_v__table__string_type) {
			v__checker__Checker_error(c, tos_lit(".str() methods should return `string`"), node->pos);
		}
		if (node->params.len != 1) {
			v__checker__Checker_error(c, tos_lit(".str() methods should have 0 arguments"), node->pos);
		}
	}
	if (node->language == v__table__Language_v && !node->is_method && node->params.len == 0 && string_starts_with(string_after(node->name, tos_lit(".")), tos_lit("test_"))) {
		if (!string_ends_with(c->file->path, tos_lit("_test.v"))) {
			// FOR IN array
			array _t1120 = node->stmts;
			for (int _t1121 = 0; _t1121 < _t1120.len; ++_t1121) {
				v__ast__Stmt st = ((v__ast__Stmt*)_t1120.data)[_t1121];
				if ((st).typ == 251 /* v.ast.AssertStmt */) {
					v__checker__Checker_warn(c, tos_lit("tests will not be run, because filename does not end with `_test.v`"), node->pos);
					break;
				}
			}
		}
		if (node->return_type != _const_v__table__void_type_idx) {
			v__checker__Checker_error(c, tos_lit("test functions should not return anything"), node->pos);
		}
	}
	c->expected_type = _const_v__table__void_type;
	c->cur_fn = node;
	if (node->return_type != _const_v__table__void_type && v__table__Type_has_flag(node->return_type, v__table__TypeFlag_optional) && (node->stmts.len == 0 || ((*(v__ast__Stmt*)/*ee elem_typ */array_get(node->stmts, node->stmts.len - 1))).typ != 271 /* v.ast.Return */)) {
		v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(c->table, node->return_type);
		if (sym->kind == v__table__Kind_void) {
			array_push(&node->stmts, _MOV((v__ast__Stmt[]){ /* sum type cast 4 */ (v__ast__Stmt){._271 = memdup(&(v__ast__Return[]){(v__ast__Return){.pos = node->pos,.exprs = __new_array(0, 1, sizeof(v__ast__Expr)),.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.types = __new_array(0, 1, sizeof(v__table__Type)),}}, sizeof(v__ast__Return)), .typ = 271 /* v.ast.Return */} }));
		} else {
			array_push(&node->stmts, _MOV((v__ast__Stmt[]){ /* sum type cast 4 */ (v__ast__Stmt){._271 = memdup(&(v__ast__Return[]){(v__ast__Return){.pos = node->pos,.exprs = new_array_from_c_array(1, 1, sizeof(v__ast__Expr), _MOV((v__ast__Expr[1]){/* sum type cast 4 */ (v__ast__Expr){._234 = memdup(&(v__ast__None[]){(v__ast__None){.pos = node->pos,.foo = 0,}}, sizeof(v__ast__None)), .typ = 234 /* v.ast.None */}})),.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.types = __new_array(0, 1, sizeof(v__table__Type)),}}, sizeof(v__ast__Return)), .typ = 271 /* v.ast.Return */} }));
		}
	}
	v__checker__Checker_stmts(c, node->stmts);
	bool returns = c->returns || v__checker__has_top_return(node->stmts);
	if (node->language == v__table__Language_v && !node->no_body && node->return_type != _const_v__table__void_type && !returns && !(string_eq(node->name, tos_lit("panic")) || string_eq(node->name, tos_lit("exit")))) {
		v__checker__Checker_error(c, _STR("missing return at end of function `%.*s\000`", 2, node->name), node->pos);
	}
	c->returns = false;
	node->source_file = c->file;
}

VV_LOCAL_SYMBOL bool v__checker__has_top_return(array_v__ast__Stmt stmts) {
	// FOR IN array
	array _t1124 = stmts;
	for (int _t1125 = 0; _t1125 < _t1124.len; ++_t1125) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)_t1124.data)[_t1125];
		if ((stmt).typ == 271 /* v.ast.Return */) {
			return true;
		} else if ((stmt).typ == 253 /* v.ast.Block */) {
			if (v__checker__has_top_return((*stmt._253).stmts)) {
				return true;
			}
		} else if ((stmt).typ == 259 /* v.ast.ExprStmt */) {
			if (((*stmt._259).expr).typ == 215 /* v.ast.CallExpr */) {
				if ((string_eq((*(*stmt._259).expr._215).name, tos_lit("panic")) || string_eq((*(*stmt._259).expr._215).name, tos_lit("exit")))) {
					return true;
				}
			}
		}
	}
	return false;
}

VV_LOCAL_SYMBOL multi_return_bool_int_int v__checker__Checker_verify_vweb_params_for_method(v__checker__Checker* c, v__table__Fn m) {
	int margs = m.params.len - 1;
	if (m.attrs.len == 0) {
		return (multi_return_bool_int_int){.arg0=true, .arg1=-1, .arg2=margs};
	}
	int route_attributes = 0;
	// FOR IN array
	array _t1126 = m.attrs;
	for (int _t1127 = 0; _t1127 < _t1126.len; ++_t1127) {
		v__table__Attr a = ((v__table__Attr*)_t1126.data)[_t1127];
		if (string_starts_with(a.name, tos_lit("/"))) {
			route_attributes += string_count(a.name, tos_lit(":"));
		}
	}
	return (multi_return_bool_int_int){.arg0=route_attributes == margs, .arg1=route_attributes, .arg2=margs};
}

VV_LOCAL_SYMBOL void v__checker__Checker_verify_all_vweb_routes(v__checker__Checker* c) {
	if (c->vweb_gen_types.len == 0) {
		return;
	}
	int typ_vweb_result = v__table__Table_find_type_idx(c->table, tos_lit("vweb.Result"));
	// FOR IN array
	array _t1128 = c->vweb_gen_types;
	for (int _t1129 = 0; _t1129 < _t1128.len; ++_t1129) {
		v__table__Type vgt = ((v__table__Type*)_t1128.data)[_t1129];
		v__table__TypeSymbol* sym_app = v__table__Table_get_type_symbol(c->table, vgt);
		// FOR IN array
		array _t1130 = sym_app->methods;
		for (int _t1131 = 0; _t1131 < _t1130.len; ++_t1131) {
			v__table__Fn m = ((v__table__Fn*)_t1130.data)[_t1131];
			if (string_eq(m.return_type_source_name, tos_lit("vweb.Result"))) {
				multi_return_bool_int_int mr_151543 = v__checker__Checker_verify_vweb_params_for_method(c, m);
				bool is_ok = mr_151543.arg0;
				int nroute_attributes = mr_151543.arg1;
				int nargs = mr_151543.arg2;
				if (!is_ok) {
					v__ast__FnDecl* f = ((v__ast__FnDecl*)(m.source_fn));
					if (isnil(f)) {
						continue;
					}
					if (f->return_type == typ_vweb_result && f->receiver.typ == (*(v__table__Param*)/*ee elem_typ */array_get(m.params, 0)).typ && string_eq(f->name, m.name)) {
						c->file = f->source_file;
						v__checker__Checker_warn(c, _STR("mismatched parameters count between vweb method `%.*s\000.%.*s\000` (%"PRId32"\000) and route attribute %.*s\000 (%"PRId32"\000)", 6, sym_app->name, m.name, nargs, array_v__table__Attr_str(m.attrs), nroute_attributes), f->pos);
					}
				}
			}
		}
	}
}

VV_LOCAL_SYMBOL v__ast__Stmt v__parser__Parser_assign_stmt(v__parser__Parser* p) {
	multi_return_array_v__ast__Expr_array_v__ast__Comment mr_274 = v__parser__Parser_expr_list(p);
	array_v__ast__Expr exprs = mr_274.arg0;
	array_v__ast__Comment comments = mr_274.arg1;
	return v__parser__Parser_partial_assign_stmt(p, exprs, comments);
}

VV_LOCAL_SYMBOL void v__parser__Parser_check_undefined_variables(v__parser__Parser* p, array_v__ast__Expr exprs, v__ast__Expr val) {
	v__ast__Expr _t1132 = val;
	if (_t1132.typ == 224 /* v.ast.Ident */) {
		// FOR IN array
		array _t1133 = exprs;
		for (int _t1134 = 0; _t1134 < _t1133.len; ++_t1134) {
			v__ast__Expr expr = ((v__ast__Expr*)_t1133.data)[_t1134];
			if ((expr).typ == 224 /* v.ast.Ident */) {
				if (string_eq((*expr._224).name, (*val._224).name)) {
					v__parser__Parser_error_with_pos(p, _STR("undefined variable: `%.*s\000`", 2, (*val._224).name), (*val._224).pos);
				}
			}
		}
	} else if (_t1132.typ == 228 /* v.ast.InfixExpr */) {
		v__parser__Parser_check_undefined_variables(p, exprs, (*val._228).left);
		v__parser__Parser_check_undefined_variables(p, exprs, (*val._228).right);
	} else if (_t1132.typ == 236 /* v.ast.ParExpr */) {
		v__parser__Parser_check_undefined_variables(p, exprs, (*val._236).expr);
	} else if (_t1132.typ == 237 /* v.ast.PostfixExpr */) {
		v__parser__Parser_check_undefined_variables(p, exprs, (*val._237).expr);
	} else if (_t1132.typ == 238 /* v.ast.PrefixExpr */) {
		v__parser__Parser_check_undefined_variables(p, exprs, (*val._238).right);
	} else if (_t1132.typ == 244 /* v.ast.StringInterLiteral */) {
		// FOR IN array
		array _t1135 = (*val._244).exprs;
		for (int _t1136 = 0; _t1136 < _t1135.len; ++_t1136) {
			v__ast__Expr expr_ = ((v__ast__Expr*)_t1135.data)[_t1136];
			v__parser__Parser_check_undefined_variables(p, exprs, expr_);
		}
	} else {
	};
}

VV_LOCAL_SYMBOL bool v__parser__Parser_check_cross_variables(v__parser__Parser* p, array_v__ast__Expr exprs, v__ast__Expr val) {
	v__ast__Expr val_ = val;
	v__ast__Expr _t1137 = val_;
	if (_t1137.typ == 224 /* v.ast.Ident */) {
		// FOR IN array
		array _t1138 = exprs;
		for (int _t1139 = 0; _t1139 < _t1138.len; ++_t1139) {
			v__ast__Expr expr = ((v__ast__Expr*)_t1138.data)[_t1139];
			if ((expr).typ == 224 /* v.ast.Ident */) {
				if (string_eq((*expr._224).name, (*val_._224).name)) {
					return true;
				}
			}
		}
	} else if (_t1137.typ == 227 /* v.ast.IndexExpr */) {
		// FOR IN array
		array _t1140 = exprs;
		for (int _t1141 = 0; _t1141 < _t1140.len; ++_t1141) {
			v__ast__Expr expr = ((v__ast__Expr*)_t1140.data)[_t1141];
			if (string_eq(v__ast__Expr_str(expr), v__ast__Expr_str(val))) {
				return true;
			}
		}
	} else if (_t1137.typ == 228 /* v.ast.InfixExpr */) {
		return v__parser__Parser_check_cross_variables(p, exprs, (*val_._228).left) || v__parser__Parser_check_cross_variables(p, exprs, (*val_._228).right);
	} else if (_t1137.typ == 238 /* v.ast.PrefixExpr */) {
		return v__parser__Parser_check_cross_variables(p, exprs, (*val_._238).right);
	} else if (_t1137.typ == 237 /* v.ast.PostfixExpr */) {
		return v__parser__Parser_check_cross_variables(p, exprs, (*val_._237).expr);
	} else if (_t1137.typ == 241 /* v.ast.SelectorExpr */) {
		// FOR IN array
		array _t1142 = exprs;
		for (int _t1143 = 0; _t1143 < _t1142.len; ++_t1143) {
			v__ast__Expr expr = ((v__ast__Expr*)_t1142.data)[_t1143];
			if (string_eq(v__ast__Expr_str(expr), v__ast__Expr_str(val))) {
				return true;
			}
		}
	} else {
	};
	return false;
}

VV_LOCAL_SYMBOL v__ast__Stmt v__parser__Parser_partial_assign_stmt(v__parser__Parser* p, array_v__ast__Expr left, array_v__ast__Comment left_comments) {
	p->is_stmt_ident = false;
	v__token__Kind op = p->tok.kind;
	v__token__Position pos = v__token__Token_position(&p->tok);
	v__parser__Parser_next(p);
	multi_return_array_v__ast__Expr_array_v__ast__Comment mr_2030 = v__parser__Parser_expr_list(p);
	array_v__ast__Expr right = mr_2030.arg0;
	array_v__ast__Comment right_comments = mr_2030.arg1;
	array_v__ast__Comment comments = __new_array_with_default(0, left_comments.len + right_comments.len, sizeof(v__ast__Comment), 0);
	_PUSH_MANY(&comments, (left_comments), _t1144, array_v__ast__Comment);
	_PUSH_MANY(&comments, (right_comments), _t1145, array_v__ast__Comment);
	bool has_cross_var = false;
	if (op == v__token__Kind_decl_assign) {
		// FOR IN array
		array _t1146 = right;
		for (int _t1147 = 0; _t1147 < _t1146.len; ++_t1147) {
			v__ast__Expr r = ((v__ast__Expr*)_t1146.data)[_t1147];
			v__parser__Parser_check_undefined_variables(p, left, r);
		}
	} else if (left.len > 1) {
		// FOR IN array
		array _t1148 = right;
		for (int _t1149 = 0; _t1149 < _t1148.len; ++_t1149) {
			v__ast__Expr r = ((v__ast__Expr*)_t1148.data)[_t1149];
			has_cross_var = v__parser__Parser_check_cross_variables(p, left, r);
			if (!(op == v__token__Kind_assign || op == v__token__Kind_decl_assign)) {
				v__parser__Parser_error(p, _STR("unexpected %.*s\000, expecting := or = or comma", 2, v__token__Kind_str(op)));
			}
			if (has_cross_var) {
				break;
			}
		}
	}
	bool is_static = false;
	// FOR IN array
	array _t1150 = left;
	for (int i = 0; i < _t1150.len; ++i) {
		v__ast__Expr lx = ((v__ast__Expr*)_t1150.data)[i];
		v__ast__Expr _t1151 = lx;
		if (_t1151.typ == 224 /* v.ast.Ident */) {
			if (op == v__token__Kind_decl_assign) {
				if (v__ast__Scope_known_var(p->scope, (*lx._224).name)) {
					v__parser__Parser_error_with_pos(p, _STR("redefinition of `%.*s\000`", 2, (*lx._224).name), (*lx._224).pos);
				}
				v__table__ShareType share = ((v__table__ShareType)(0));
				if (((*lx._224).info).typ == 313 /* v.ast.IdentVar */) {
					v__ast__IdentVar iv = /* as */ *(v__ast__IdentVar*)__as_cast(((*lx._224).info)._313, ((*lx._224).info).typ, /*expected:*/313);
					share = iv.share;
					if (iv.is_static) {
						if (!p->pref->translated) {
							v__parser__Parser_error_with_pos(p, tos_lit("static variables are supported only in -translated mode"), (*lx._224).pos);
						}
						is_static = true;
					}
				}
				v__ast__Var v = (v__ast__Var){.name = (*lx._224).name,.expr = (left.len == right.len ? ((*(v__ast__Expr*)/*ee elem_typ */array_get(right, i))) : ((v__ast__Expr){
#ifndef __cplusplus
0
#endif
})),.share = share,.is_mut = (*lx._224).is_mut || p->inside_for,.is_autofree_tmp = 0,.is_arg = 0,.typ = 0,.sum_type_casts = __new_array(0, 1, sizeof(v__table__Type)),.pos = (*lx._224).pos,.is_used = 0,.is_changed = 0,};
				v__ast__ScopeObject obj = /* sum type cast 4 */ (v__ast__ScopeObject){._277 = memdup(&(v__ast__Var[]){v}, sizeof(v__ast__Var)), .typ = 277 /* v.ast.Var */};
				(*lx._224).obj = obj;
				v__ast__Scope_register(p->scope, (*lx._224).name, obj);
			}
		} else if (_t1151.typ == 227 /* v.ast.IndexExpr */) {
			if (op == v__token__Kind_decl_assign) {
				v__parser__Parser_error_with_pos(p, _STR("non-name `%.*s\000[%.*s\000]` on left side of `:=`", 3, v__ast__Expr_str((*lx._227).left), v__ast__Expr_str((*lx._227).index)), (*lx._227).pos);
			}
			(*lx._227).is_setter = true;
		} else if (_t1151.typ == 236 /* v.ast.ParExpr */) {
		} else if (_t1151.typ == 238 /* v.ast.PrefixExpr */) {
		} else if (_t1151.typ == 241 /* v.ast.SelectorExpr */) {
			if (op == v__token__Kind_decl_assign) {
				v__parser__Parser_error_with_pos(p, tos_lit("struct fields can only be declared during the initialization"), (*lx._241).pos);
			}
		} else {
		};
	}
	return /* sum type cast 4 */ (v__ast__Stmt){._252 = memdup(&(v__ast__AssignStmt[]){(v__ast__AssignStmt){
		.right = right,
		.op = op,
		.pos = pos,
		.comments = comments,
		.left = left,
		.left_types = __new_array(0, 1, sizeof(v__table__Type)),
		.right_types = __new_array(0, 1, sizeof(v__table__Type)),
		.is_static = is_static,
		.is_simple = p->inside_for && p->tok.kind == v__token__Kind_lcbr,
		.has_cross_var = has_cross_var,
	}}, sizeof(v__ast__AssignStmt)), .typ = 252 /* v.ast.AssignStmt */};
}

VV_LOCAL_SYMBOL v__ast__HashStmt v__parser__Parser_hash(v__parser__Parser* p) {
	v__token__Position pos = v__token__Token_position(&p->prev_tok);
	string val = p->tok.lit;
	string kind = string_all_before(val, tos_lit(" "));
	v__parser__Parser_next(p);
	string main = tos_lit("");
	string msg = tos_lit("");
	string content = string_all_before(string_all_after(val, _STR("%.*s\000 ", 2, kind)), tos_lit("//"));
	if (string_contains(content, tos_lit(" #"))) {
		main = string_trim_space(string_all_before(content, tos_lit(" #")));
		msg = string_trim_space(string_all_after(content, tos_lit(" #")));
	} else {
		main = string_trim_space(content);
		msg = tos_lit("");
	}
	return (v__ast__HashStmt){
		.mod = p->mod,
		.pos = pos,
		.val = val,
		.kind = kind,
		.main = main,
		.msg = msg,
	};
}

VV_LOCAL_SYMBOL v__ast__ComptimeCall v__parser__Parser_vweb(v__parser__Parser* p) {
	v__parser__Parser_check(p, v__token__Kind_dollar);
	string error_msg = tos_lit("only `$tmpl()` and `$vweb.html()` comptime functions are supported right now");
	if (p->peek_tok.kind == v__token__Kind_dot) {
		string n = v__parser__Parser_check_name(p);
		if (string_ne(n, tos_lit("vweb"))) {
			v__parser__Parser_error(p, error_msg);
		}
		v__parser__Parser_check(p, v__token__Kind_dot);
	}
	string n = v__parser__Parser_check_name(p);
	if (string_ne(n, tos_lit("html")) && string_ne(n, tos_lit("tmpl"))) {
		v__parser__Parser_error(p, error_msg);
	}
	bool is_html = string_eq(n, tos_lit("html"));
	v__parser__Parser_check(p, v__token__Kind_lpar);
	string s = (is_html ? (tos_lit("")) : (p->tok.lit));
	if (!is_html) {
		v__parser__Parser_check(p, v__token__Kind_string);
	}
	v__parser__Parser_check(p, v__token__Kind_rpar);
	array_string fn_path = string_split(p->cur_fn_name, tos_lit("_"));
	string tmpl_path = (is_html ? (_STR("%.*s\000.html", 2, *(string*)array_last(fn_path))) : (s));
	string dir = os__dir(p->scanner->file_path);
	string path = os__join_path(dir, (varg_string){.len=1,.args={array_string_join(fn_path, tos_lit("/"))}});
	path = /*f*/string_add(path, tos_lit(".html"));
	if (!is_html) {
		path = tmpl_path;
	}
	if (!os__exists(path)) {
		if (is_html) {
			path = os__join_path(dir, (varg_string){.len=2,.args={tos_lit("templates"), array_string_join(fn_path, tos_lit("/"))}});
			path = /*f*/string_add(path, tos_lit(".html"));
		}
		if (!os__exists(path)) {
			if (is_html) {
				v__parser__Parser_error(p, _STR("vweb HTML template \"%.*s\000\" not found", 2, path));
			} else {
				v__parser__Parser_error(p, _STR("template file \"%.*s\000\" not found", 2, path));
			}
		}
	}
	if (p->pref->is_verbose) {
		println(_STR(">>> compiling comptime template file \"%.*s\000\"", 2, path));
	}
	string tmp_fn_name = string_replace(p->cur_fn_name, tos_lit("."), tos_lit("__"));
	string v_code = vweb__tmpl__compile_file(path, tmp_fn_name);
	#if defined(CUSTOM_DEFINE_print_vweb_template_expansions)
	{
	}
	#endif
	v__ast__Scope* scope = (v__ast__Scope*)memdup(&(v__ast__Scope){.objects = new_map_1(sizeof(v__ast__ScopeObject)),.struct_fields = __new_array(0, 1, sizeof(v__ast__ScopeStructField)),.parent = p->global_scope,.children = __new_array(0, 1, sizeof(v__ast__Scope*)),.start_pos = 0,.end_pos = 0,}, sizeof(v__ast__Scope));
	if (p->pref->is_verbose) {
		println(tos_lit("\n\n"));
		println(_STR(">>> vweb template for %.*s\000:", 2, path));
		println(v_code);
		println(tos_lit(">>> end of vweb template END"));
		println(tos_lit("\n\n"));
	}
	v__ast__File file = v__parser__parse_text(v_code, p->table, p->pref, scope, p->global_scope);
	file = // assoc
	(v__ast__File){
		.path = tmpl_path, 
		.mod = file.mod,
		.global_scope = file.global_scope,
		.scope = file.scope,
		.stmts = file.stmts,
		.imports = file.imports,
		.errors = file.errors,
		.warnings = file.warnings,
	};
	// FOR IN array
	array _t1152 = file.stmts;
	for (int _t1153 = 0; _t1153 < _t1152.len; ++_t1153) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)_t1152.data)[_t1153];
		if ((stmt).typ == 151 /* v.ast.FnDecl */) {
			if (string_eq((*stmt._151).name, _STR("main.vweb_tmpl_%.*s", 1, tmp_fn_name))) {
				v__ast__Scope* tmpl_scope = v__ast__Scope_innermost(file.scope, (*stmt._151).body_pos.pos);
				// FOR IN map
				map_string_v__ast__ScopeObject _t1155 = p->scope->objects;
				for (int _t1154 = 0; _t1154 < _t1155.key_values.len; ++_t1154) {
					if (_t1155.key_values.keys[_t1154].str == 0) {continue;}
					v__ast__ScopeObject obj = (*(v__ast__ScopeObject*)(void*)(_t1155.key_values.values + _t1154 * (u32)(_t1155.value_bytes)));
					if ((obj).typ == 277 /* v.ast.Var */) {
						v__ast__Var v = (*obj._277);
						v.pos = (*stmt._151).body_pos;
						v__ast__Scope_register(tmpl_scope, v.name, /* sum type cast 4 */ (v__ast__ScopeObject){._277 = memdup(&(v__ast__Var[]){v}, sizeof(v__ast__Var)), .typ = 277 /* v.ast.Var */});
						v.is_used = true;
					}
				}
				break;
			}
		}
	}
	return (v__ast__ComptimeCall){.method_name = n,.left = {0},.is_vweb = true,.vweb_tmpl = file,.args_var = s,.sym = {0},};
}

VV_LOCAL_SYMBOL v__ast__CompFor v__parser__Parser_comp_for(v__parser__Parser* p) {
	v__parser__Parser_next(p);
	v__parser__Parser_check(p, v__token__Kind_key_for);
	string val_var = v__parser__Parser_check_name(p);
	v__parser__Parser_check(p, v__token__Kind_key_in);
	v__table__Language lang = v__parser__Parser_parse_language(p);
	v__table__Type typ = v__parser__Parser_parse_any_type(p, lang, false, false);
	v__parser__Parser_check(p, v__token__Kind_dot);
	string for_val = v__parser__Parser_check_name(p);
	v__ast__CompForKind kind = v__ast__CompForKind_methods;
	if (string_eq(for_val, tos_lit("methods"))) {
		v__ast__Scope_register(p->scope, val_var, /* sum type cast 4 */ (v__ast__ScopeObject){._277 = memdup(&(v__ast__Var[]){(v__ast__Var){.name = val_var,.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.typ = v__table__Table_find_type_idx(p->table, tos_lit("FunctionData")),.sum_type_casts = __new_array(0, 1, sizeof(v__table__Type)),.pos = {0},.is_used = 0,.is_changed = 0,}}, sizeof(v__ast__Var)), .typ = 277 /* v.ast.Var */});
	} else if (string_eq(for_val, tos_lit("fields"))) {
		v__ast__Scope_register(p->scope, val_var, /* sum type cast 4 */ (v__ast__ScopeObject){._277 = memdup(&(v__ast__Var[]){(v__ast__Var){.name = val_var,.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.typ = v__table__Table_find_type_idx(p->table, tos_lit("FieldData")),.sum_type_casts = __new_array(0, 1, sizeof(v__table__Type)),.pos = {0},.is_used = 0,.is_changed = 0,}}, sizeof(v__ast__Var)), .typ = 277 /* v.ast.Var */});
		kind = v__ast__CompForKind_fields;
	} else {
		v__parser__Parser_error(p, _STR("unknown kind `%.*s\000`, available are: `methods` or `fields`", 2, for_val));
	}
	v__token__Position spos = v__token__Token_position(&p->tok);
	array_v__ast__Stmt stmts = v__parser__Parser_parse_block(p);
	return (v__ast__CompFor){.val_var = val_var,.stmts = stmts,.kind = kind,.pos = v__token__Position_extend(spos, v__token__Token_position(&p->tok)),.typ = typ,};
}

VV_LOCAL_SYMBOL v__ast__AtExpr v__parser__Parser_at(v__parser__Parser* p) {
	string name = p->tok.lit;
	string _t1156 = name;
		v__token__AtKind kind = ((string_eq(_t1156, tos_lit("@FN"))) ? (v__token__AtKind_fn_name) : (string_eq(_t1156, tos_lit("@MOD"))) ? (v__token__AtKind_mod_name) : (string_eq(_t1156, tos_lit("@STRUCT"))) ? (v__token__AtKind_struct_name) : (string_eq(_t1156, tos_lit("@VEXE"))) ? (v__token__AtKind_vexe_path) : (string_eq(_t1156, tos_lit("@FILE"))) ? (v__token__AtKind_file_path) : (string_eq(_t1156, tos_lit("@LINE"))) ? (v__token__AtKind_line_nr) : (string_eq(_t1156, tos_lit("@COLUMN"))) ? (v__token__AtKind_column_nr) : (string_eq(_t1156, tos_lit("@VHASH"))) ? (v__token__AtKind_vhash) : (string_eq(_t1156, tos_lit("@VMOD_FILE"))) ? (v__token__AtKind_vmod_file) : (v__token__AtKind_unknown));
	v__parser__Parser_next(p);
	return (v__ast__AtExpr){.name = name,.pos = v__token__Token_position(&p->tok),.kind = kind,.val = (string){.str=(byteptr)""},};
}

VV_LOCAL_SYMBOL v__pref__OS v__parser__os_from_string(string os) {
	string _t1157 = os;
	if (string_eq(_t1157, tos_lit("linux"))) {
		return v__pref__OS_linux;
	} else if (string_eq(_t1157, tos_lit("windows"))) {
		return v__pref__OS_windows;
	} else if (string_eq(_t1157, tos_lit("ios"))) {
		return v__pref__OS_ios;
	} else if (string_eq(_t1157, tos_lit("macos"))) {
		return v__pref__OS_macos;
	} else if (string_eq(_t1157, tos_lit("freebsd"))) {
		return v__pref__OS_freebsd;
	} else if (string_eq(_t1157, tos_lit("openbsd"))) {
		return v__pref__OS_openbsd;
	} else if (string_eq(_t1157, tos_lit("netbsd"))) {
		return v__pref__OS_netbsd;
	} else if (string_eq(_t1157, tos_lit("dragonfly"))) {
		return v__pref__OS_dragonfly;
	} else if (string_eq(_t1157, tos_lit("js"))) {
		return v__pref__OS_js;
	} else if (string_eq(_t1157, tos_lit("solaris"))) {
		return v__pref__OS_solaris;
	} else if (string_eq(_t1157, tos_lit("android"))) {
		return v__pref__OS_android;
	} else if (string_eq(_t1157, tos_lit("msvc"))) {
		v__parser__verror(tos_lit("use the flag `-cc msvc` to build using msvc"));
	} else if (string_eq(_t1157, tos_lit("haiku"))) {
		return v__pref__OS_haiku;
	} else if (string_eq(_t1157, tos_lit("linux_or_macos"))) {
		return v__pref__OS_linux;
	} else {
		v_panic(_STR("bad os %.*s", 1, os));
	};
	return v__pref__OS_linux;
}

VV_LOCAL_SYMBOL v__ast__ComptimeCall v__parser__Parser_comptime_method_call(v__parser__Parser* p, v__ast__Expr left) {
	v__parser__Parser_check(p, v__token__Kind_dollar);
	string method_name = v__parser__Parser_check_name(p);
	v__parser__Parser_check(p, v__token__Kind_lpar);
	string args_var = tos_lit("");
	if (p->tok.kind == v__token__Kind_name) {
		args_var = p->tok.lit;
		v__parser__Parser_next(p);
	}
	v__parser__Parser_check(p, v__token__Kind_rpar);
	if (p->tok.kind == v__token__Kind_key_orelse) {
		v__parser__Parser_check(p, v__token__Kind_key_orelse);
		v__parser__Parser_check(p, v__token__Kind_lcbr);
	}
	return (v__ast__ComptimeCall){.method_name = method_name,.left = left,.is_vweb = 0,.vweb_tmpl = {0},.args_var = args_var,.sym = {0},};
}

VV_LOCAL_SYMBOL v__ast__ArrayInit v__parser__Parser_array_init(v__parser__Parser* p) {
	v__token__Position first_pos = v__token__Token_position(&p->tok);
	v__token__Position last_pos = v__token__Token_position(&p->tok);
	v__parser__Parser_check(p, v__token__Kind_lsbr);
	v__table__Type array_type = _const_v__table__void_type;
	v__table__Type elem_type = _const_v__table__void_type;
	v__token__Position elem_type_pos = first_pos;
	array_v__ast__Expr exprs = __new_array_with_default(0, 0, sizeof(v__ast__Expr), 0);
	array_array_v__ast__Comment ecmnts = __new_array_with_default(0, 0, sizeof(array_v__ast__Comment), 0);
	bool is_fixed = false;
	bool has_val = false;
	bool has_type = false;
	bool has_default = false;
	v__ast__Expr default_expr = (v__ast__Expr){
#ifndef __cplusplus
0
#endif
};
	if (p->tok.kind == v__token__Kind_rsbr) {
		last_pos = v__token__Token_position(&p->tok);
		int line_nr = p->tok.line_nr;
		v__parser__Parser_next(p);
		if ((p->tok.kind == v__token__Kind_name || p->tok.kind == v__token__Kind_amp || p->tok.kind == v__token__Kind_lsbr) && p->tok.line_nr == line_nr) {
			elem_type_pos = v__token__Token_position(&p->tok);
			elem_type = v__parser__Parser_parse_type(p);
			v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(p->table, elem_type);
			int idx = v__table__Table_find_or_register_array(p->table, elem_type, 1, sym->mod);
			array_type = v__table__new_type(idx);
			has_type = true;
		}
	} else {
		for (int i = 0; p->tok.kind != v__token__Kind_rsbr; i++) {
			array_push(&exprs, _MOV((v__ast__Expr[]){ v__parser__Parser_expr(p, 0) }));
			array_push(&ecmnts, _MOV((array_v__ast__Comment[]){ v__parser__Parser_eat_comments(p) }));
			if (p->tok.kind == v__token__Kind_comma) {
				v__parser__Parser_next(p);
			}
		}
		int line_nr = p->tok.line_nr;
		#if defined(__TINYC__)
		{
		}
		#endif
		last_pos = v__token__Token_position(&p->tok);
		v__parser__Parser_check(p, v__token__Kind_rsbr);
		if (exprs.len == 1 && (p->tok.kind == v__token__Kind_name || p->tok.kind == v__token__Kind_amp) && p->tok.line_nr == line_nr) {
			elem_type = v__parser__Parser_parse_type(p);
			is_fixed = true;
			if (p->tok.kind == v__token__Kind_lcbr) {
				v__parser__Parser_next(p);
				if (p->tok.kind != v__token__Kind_rcbr) {
					v__token__Position pos = v__token__Token_position(&p->tok);
					string n = v__parser__Parser_check_name(p);
					if (string_ne(n, tos_lit("init"))) {
						v__parser__Parser_error_with_pos(p, _STR("expected `init:`, not `%.*s\000`", 2, n), pos);
					}
					v__parser__Parser_check(p, v__token__Kind_colon);
					has_default = true;
					default_expr = v__parser__Parser_expr(p, 0);
				}
				last_pos = v__token__Token_position(&p->tok);
				v__parser__Parser_check(p, v__token__Kind_rcbr);
			} else {
				v__parser__Parser_warn_with_pos(p, tos_lit("use e.g. `x := [1]Type{}` instead of `x := [1]Type`"), last_pos);
			}
		} else {
			if (p->tok.kind == v__token__Kind_not) {
				last_pos = v__token__Token_position(&p->tok);
				v__parser__Parser_next(p);
			}
			if (p->tok.kind == v__token__Kind_not) {
				last_pos = v__token__Token_position(&p->tok);
				v__parser__Parser_next(p);
				is_fixed = true;
				has_val = true;
			}
		}
	}
	if (exprs.len == 0 && p->tok.kind != v__token__Kind_lcbr && has_type) {
		v__parser__Parser_warn_with_pos(p, tos_lit("use `x := []Type{}` instead of `x := []Type`"), last_pos);
	}
	bool has_len = false;
	bool has_cap = false;
	v__ast__Expr len_expr = (v__ast__Expr){
#ifndef __cplusplus
0
#endif
};
	v__ast__Expr cap_expr = (v__ast__Expr){
#ifndef __cplusplus
0
#endif
};
	if (p->tok.kind == v__token__Kind_lcbr && exprs.len == 0) {
		v__parser__Parser_next(p);
		for (;;) {
			if (!(p->tok.kind != v__token__Kind_rcbr)) break;
			string key = v__parser__Parser_check_name(p);
			v__parser__Parser_check(p, v__token__Kind_colon);
			string _t1160 = key;
			if (string_eq(_t1160, tos_lit("len"))) {
				has_len = true;
				len_expr = v__parser__Parser_expr(p, 0);
			} else if (string_eq(_t1160, tos_lit("cap"))) {
				has_cap = true;
				cap_expr = v__parser__Parser_expr(p, 0);
			} else if (string_eq(_t1160, tos_lit("init"))) {
				has_default = true;
				default_expr = v__parser__Parser_expr(p, 0);
			} else {
				v__parser__Parser_error(p, _STR("wrong field `%.*s\000`, expecting `len`, `cap`, or `init`", 2, key));
			};
			if (p->tok.kind != v__token__Kind_rcbr) {
				v__parser__Parser_check(p, v__token__Kind_comma);
			}
		}
		v__parser__Parser_check(p, v__token__Kind_rcbr);
	}
	v__token__Position pos = v__token__Position_extend(first_pos, last_pos);
	return (v__ast__ArrayInit){
		.pos = pos,
		.elem_type_pos = elem_type_pos,
		.exprs = exprs,
		.ecmnts = ecmnts,
		.is_fixed = is_fixed,
		.has_val = has_val,
		.mod = p->mod,
		.len_expr = len_expr,
		.cap_expr = cap_expr,
		.default_expr = default_expr,
		.has_len = has_len,
		.has_cap = has_cap,
		.has_default = has_default,
		.is_interface = 0,
		.interface_types = __new_array(0, 1, sizeof(v__table__Type)),
		.interface_type = 0,
		.elem_type = elem_type,
		.typ = array_type,
	};
}

VV_LOCAL_SYMBOL v__ast__MapInit v__parser__Parser_map_init(v__parser__Parser* p) {
	v__token__Position pos = v__token__Token_position(&p->tok);
	array_v__ast__Expr keys = __new_array_with_default(0, 0, sizeof(v__ast__Expr), 0);
	array_v__ast__Expr vals = __new_array_with_default(0, 0, sizeof(v__ast__Expr), 0);
	for (;;) {
		if (!(p->tok.kind != v__token__Kind_rcbr && p->tok.kind != v__token__Kind_eof)) break;
		v__ast__Expr key = v__parser__Parser_expr(p, 0);
		array_push(&keys, _MOV((v__ast__Expr[]){ key }));
		v__parser__Parser_check(p, v__token__Kind_colon);
		v__ast__Expr val = v__parser__Parser_expr(p, 0);
		array_push(&vals, _MOV((v__ast__Expr[]){ val }));
		if (p->tok.kind == v__token__Kind_comma) {
			v__parser__Parser_next(p);
		}
	}
	return (v__ast__MapInit){.pos = pos,.keys = keys,.vals = vals,.typ = 0,.key_type = 0,.value_type = 0,};
}

v__ast__CallExpr v__parser__Parser_call_expr(v__parser__Parser* p, v__table__Language language, string mod) {
	v__token__Position first_pos = v__token__Token_position(&p->tok);
	string fn_name = (language == v__table__Language_c ? (_STR("C.%.*s", 1, v__parser__Parser_check_name(p))) : language == v__table__Language_js ? (_STR("JS.%.*s", 1, v__parser__Parser_check_js_name(p))) : mod.len > 0 ? (_STR("%.*s\000.%.*s", 2, mod, v__parser__Parser_check_name(p))) : (v__parser__Parser_check_name(p)));
	v__ast__OrKind or_kind = v__ast__OrKind_absent;
	if (string_eq(fn_name, tos_lit("json.decode"))) {
		p->expecting_type = true;
		p->expr_mod = tos_lit("");
		or_kind = v__ast__OrKind_block;
	}
	v__table__Type generic_type = _const_v__table__void_type;
	v__token__Position generic_list_pos = v__token__Token_position(&p->tok);
	if (p->tok.kind == v__token__Kind_lt) {
		v__parser__Parser_next(p);
		p->expr_mod = tos_lit("");
		generic_type = v__parser__Parser_parse_type(p);
		v__parser__Parser_check(p, v__token__Kind_gt);
		generic_list_pos = v__token__Position_extend(generic_list_pos, v__token__Token_position(&p->prev_tok));
		if (!v__table__Type_has_flag(generic_type, v__table__TypeFlag_generic)) {
			string full_generic_fn_name = (string_contains(fn_name, tos_lit(".")) ? (fn_name) : (v__parser__Parser_prepend_mod(p, fn_name)));
			v__table__Table_register_fn_gen_type(p->table, full_generic_fn_name, generic_type);
		}
	}
	v__parser__Parser_check(p, v__token__Kind_lpar);
	array_v__ast__CallArg args = v__parser__Parser_call_args(p);
	v__token__Position last_pos = v__token__Token_position(&p->tok);
	v__parser__Parser_check(p, v__token__Kind_rpar);
	if (p->tok.kind == v__token__Kind_not) {
		v__parser__Parser_next(p);
	}
	v__token__Position pos = (v__token__Position){.len = last_pos.pos - first_pos.pos + last_pos.len,.line_nr = first_pos.line_nr,.pos = first_pos.pos,};
	array_v__ast__Stmt or_stmts = __new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
	v__token__Position or_pos = v__token__Token_position(&p->tok);
	if (p->tok.kind == v__token__Kind_key_orelse) {
		bool was_inside_or_expr = p->inside_or_expr;
		p->inside_or_expr = true;
		v__parser__Parser_next(p);
		v__parser__Parser_open_scope(p);
		v__ast__Scope_register(p->scope, tos_lit("err"), /* sum type cast 4 */ (v__ast__ScopeObject){._277 = memdup(&(v__ast__Var[]){(v__ast__Var){.name = tos_lit("err"),.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.typ = _const_v__table__string_type,.sum_type_casts = __new_array(0, 1, sizeof(v__table__Type)),.pos = v__token__Token_position(&p->tok),.is_used = true,.is_changed = 0,}}, sizeof(v__ast__Var)), .typ = 277 /* v.ast.Var */});
		v__ast__Scope_register(p->scope, tos_lit("errcode"), /* sum type cast 4 */ (v__ast__ScopeObject){._277 = memdup(&(v__ast__Var[]){(v__ast__Var){.name = tos_lit("errcode"),.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.typ = _const_v__table__int_type,.sum_type_casts = __new_array(0, 1, sizeof(v__table__Type)),.pos = v__token__Token_position(&p->tok),.is_used = true,.is_changed = 0,}}, sizeof(v__ast__Var)), .typ = 277 /* v.ast.Var */});
		or_kind = v__ast__OrKind_block;
		or_stmts = v__parser__Parser_parse_block_no_scope(p, false);
		or_pos = v__token__Position_extend(or_pos, v__token__Token_position(&p->prev_tok));
		v__parser__Parser_close_scope(p);
		p->inside_or_expr = was_inside_or_expr;
	}
	if (p->tok.kind == v__token__Kind_question) {
		v__parser__Parser_next(p);
		or_kind = v__ast__OrKind_propagate;
	}
	string fn_mod = p->mod;
	{ /* if guard */ 
	Option_v__table__Fn _t1163;
	if (_t1163 = v__table__Table_find_fn(p->table, fn_name), _t1163.ok) {
		v__table__Fn registered = *(v__table__Fn*)_t1163.data;
		if (registered.is_placeholder) {
			fn_mod = registered.mod;
			fn_name = registered.name;
		}
	}}
	return (v__ast__CallExpr){
		.pos = pos,
		.left = {0},
		.mod = fn_mod,
		.name = fn_name,
		.is_method = 0,
		.is_field = 0,
		.args = args,
		.expected_arg_types = __new_array(0, 1, sizeof(v__table__Type)),
		.language = language,
		.or_block = (v__ast__OrExpr){.stmts = or_stmts,.kind = or_kind,.pos = or_pos,},
		.left_type = 0,
		.receiver_type = 0,
		.return_type = 0,
		.should_be_skipped = 0,
		.generic_type = generic_type,
		.generic_list_pos = generic_list_pos,
		.free_receiver = 0,
	};
}

array_v__ast__CallArg v__parser__Parser_call_args(v__parser__Parser* p) {
	array_v__ast__CallArg args = __new_array_with_default(0, 0, sizeof(v__ast__CallArg), 0);
	v__token__Position start_pos = v__token__Token_position(&p->tok);
	for (;;) {
		if (!(p->tok.kind != v__token__Kind_rpar)) break;
		if (p->tok.kind == v__token__Kind_eof) {
			v__parser__Parser_error_with_pos(p, tos_lit("unexpected eof reached, while parsing call argument"), start_pos);
			break;
		}
		bool is_shared = p->tok.kind == v__token__Kind_key_shared;
		bool is_atomic = p->tok.kind == v__token__Kind_key_atomic;
		bool is_mut = p->tok.kind == v__token__Kind_key_mut || is_shared || is_atomic;
		if (is_mut) {
			v__parser__Parser_next(p);
		}
		array_v__ast__Comment comments = v__parser__Parser_eat_comments(p);
		v__ast__Expr e = v__parser__Parser_expr(p, 0);
		_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p)), _t1164, array_v__ast__Comment);
		array_push(&args, _MOV((v__ast__CallArg[]){ (v__ast__CallArg){.is_mut = is_mut,.share = v__table__sharetype_from_flags(is_shared, is_atomic),.expr = e,.comments = comments,.typ = 0,.is_tmp_autofree = 0,.pos = v__token__Token_position(&p->tok),} }));
		if (p->tok.kind != v__token__Kind_rpar) {
			v__parser__Parser_check(p, v__token__Kind_comma);
		}
	}
	return args;
}

VV_LOCAL_SYMBOL v__ast__FnDecl v__parser__Parser_fn_decl(v__parser__Parser* p) {
	v__parser__Parser_top_level_statement_start(p);
	v__token__Position start_pos = v__token__Token_position(&p->tok);
	bool is_deprecated = array_v__table__Attr_contains(p->attrs, tos_lit("deprecated"));
	bool is_direct_arr = array_v__table__Attr_contains(p->attrs, tos_lit("direct_array_access"));
	bool is_unsafe = array_v__table__Attr_contains(p->attrs, tos_lit("unsafe"));
	bool is_pub = p->tok.kind == v__token__Kind_key_pub;
	if (is_pub) {
		v__parser__Parser_next(p);
	}
	v__parser__Parser_check(p, v__token__Kind_key_fn);
	v__parser__Parser_open_scope(p);
	v__table__Language language = v__table__Language_v;
	if (p->tok.kind == v__token__Kind_name && string_eq(p->tok.lit, tos_lit("C"))) {
		is_unsafe = !array_v__table__Attr_contains(p->attrs, tos_lit("trusted"));
		language = v__table__Language_c;
	} else if (p->tok.kind == v__token__Kind_name && string_eq(p->tok.lit, tos_lit("JS"))) {
		language = v__table__Language_js;
	}
	if (language != v__table__Language_v) {
		v__parser__Parser_next(p);
		v__parser__Parser_check(p, v__token__Kind_dot);
	}
	string rec_name = tos_lit("");
	bool is_method = false;
	v__token__Position receiver_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,};
	v__table__Type rec_type = _const_v__table__void_type;
	bool rec_mut = false;
	array_v__table__Param params = __new_array_with_default(0, 0, sizeof(v__table__Param), 0);
	if (p->tok.kind == v__token__Kind_lpar) {
		v__parser__Parser_next(p);
		is_method = true;
		bool is_shared = p->tok.kind == v__token__Kind_key_shared;
		bool is_atomic = p->tok.kind == v__token__Kind_key_atomic;
		rec_mut = p->tok.kind == v__token__Kind_key_mut || is_shared || is_atomic;
		if (rec_mut) {
			v__parser__Parser_next(p);
		}
		v__token__Position rec_start_pos = v__token__Token_position(&p->tok);
		rec_name = v__parser__Parser_check_name(p);
		if (!rec_mut) {
			rec_mut = p->tok.kind == v__token__Kind_key_mut;
			if (rec_mut) {
				v__parser__Parser_warn_with_pos(p, tos_lit("use `(mut f Foo)` instead of `(f mut Foo)`"), v__token__Token_position(&p->tok));
			}
		}
		receiver_pos = v__token__Position_extend(rec_start_pos, v__token__Token_position(&p->tok));
		bool is_amp = p->tok.kind == v__token__Kind_amp;
		if (p->tok.kind == v__token__Kind_name && string_eq(p->tok.lit, tos_lit("JS"))) {
			language = v__table__Language_js;
		}
		rec_type = v__parser__Parser_parse_type_with_mut(p, rec_mut);
		if (is_amp && rec_mut) {
			v__parser__Parser_error(p, tos_lit("use `(mut f Foo)` or `(f &Foo)` instead of `(mut f &Foo)`"));
		}
		if (is_shared) {
			rec_type = v__table__Type_set_flag(rec_type, v__table__TypeFlag_shared_f);
		}
		if (is_atomic) {
			rec_type = v__table__Type_set_flag(rec_type, v__table__TypeFlag_atomic_f);
		}
		v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(p->table, rec_type);
		array_push(&params, _MOV((v__table__Param[]){ (v__table__Param){.pos = rec_start_pos,.name = rec_name,.is_mut = rec_mut,.typ = rec_type,.type_source_name = sym->source_name,.is_hidden = 0,} }));
		v__parser__Parser_check(p, v__token__Kind_rpar);
	}
	string name = tos_lit("");
	if (p->tok.kind == v__token__Kind_name) {
		name = (language == v__table__Language_js ? (v__parser__Parser_check_js_name(p)) : (v__parser__Parser_check_name(p)));
		if (language == v__table__Language_v && !p->pref->translated && v__util__contains_capital(name)) {
			v__parser__Parser_error(p, tos_lit("function names cannot contain uppercase letters, use snake_case instead"));
		}
		v__table__TypeSymbol* type_sym = v__table__Table_get_type_symbol(p->table, rec_type);
		if (is_method && (v__table__TypeSymbol_has_method(type_sym, name) && type_sym->kind != v__table__Kind_interface_)) {
			v__parser__Parser_error(p, _STR("duplicate method `%.*s\000`", 2, name));
		}
	}
	if ((p->tok.kind == v__token__Kind_plus || p->tok.kind == v__token__Kind_minus || p->tok.kind == v__token__Kind_mul || p->tok.kind == v__token__Kind_div || p->tok.kind == v__token__Kind_mod)) {
		name = v__token__Kind_str(p->tok.kind);
		v__parser__Parser_next(p);
	}
	bool is_generic = p->tok.kind == v__token__Kind_lt;
	if (is_generic) {
		v__parser__Parser_next(p);
		v__parser__Parser_next(p);
		v__parser__Parser_check(p, v__token__Kind_gt);
	}
	multi_return_array_v__table__Param_bool_bool mr_6551 = v__parser__Parser_fn_args(p);
	array_v__table__Param args2 = mr_6551.arg0;
	bool are_args_type_only = mr_6551.arg1;
	bool is_variadic = mr_6551.arg2;
	_PUSH_MANY(&params, (args2), _t1167, array_v__table__Param);
	if (!are_args_type_only) {
		// FOR IN array
		array _t1168 = params;
		for (int _t1169 = 0; _t1169 < _t1168.len; ++_t1169) {
			v__table__Param param = ((v__table__Param*)_t1168.data)[_t1169];
			if (v__ast__Scope_known_var(p->scope, param.name)) {
				v__parser__Parser_error_with_pos(p, _STR("redefinition of parameter `%.*s\000`", 2, param.name), param.pos);
				break;
			}
			v__ast__Scope_register(p->scope, param.name, /* sum type cast 4 */ (v__ast__ScopeObject){._277 = memdup(&(v__ast__Var[]){(v__ast__Var){
				.name = param.name,
				.expr = {0},
				.share = 0,
				.is_mut = param.is_mut,
				.is_autofree_tmp = 0,
				.is_arg = true,
				.typ = param.typ,
				.sum_type_casts = __new_array(0, 1, sizeof(v__table__Type)),
				.pos = param.pos,
				.is_used = true,
				.is_changed = 0,
			}}, sizeof(v__ast__Var)), .typ = 277 /* v.ast.Var */});
		}
	}
	v__token__Position end_pos = v__token__Token_position(&p->prev_tok);
	v__table__Type return_type = _const_v__table__void_type;
	if (v__token__Kind_is_start_of_type(p->tok.kind) || (p->tok.kind == v__token__Kind_key_fn && p->tok.line_nr == p->prev_tok.line_nr)) {
		return_type = v__parser__Parser_parse_type(p);
	}
	int type_sym_method_idx = 0;
	if (is_method) {
		v__table__TypeSymbol* type_sym = v__table__Table_get_type_symbol(p->table, rec_type);
		v__table__TypeSymbol* ret_type_sym = v__table__Table_get_type_symbol(p->table, return_type);
		type_sym_method_idx = v__table__TypeSymbol_register_method(type_sym, (v__table__Fn){
			.params = params,
			.return_type = return_type,
			.return_type_source_name = ret_type_sym->source_name,
			.is_variadic = is_variadic,
			.language = 0,
			.is_generic = is_generic,
			.is_pub = is_pub,
			.is_deprecated = is_deprecated,
			.is_unsafe = is_unsafe,
			.is_placeholder = 0,
			.mod = p->mod,
			.ctdefine = (string){.str=(byteptr)""},
			.attrs = p->attrs,
			.name = name,
			.source_fn = 0,
		});
	} else {
		if (language == v__table__Language_c) {
			name = _STR("C.%.*s", 1, name);
		} else if (language == v__table__Language_js) {
			name = _STR("JS.%.*s", 1, name);
		} else {
			name = v__parser__Parser_prepend_mod(p, name);
		}
		{ /* if guard */ 
		Option_v__table__Fn _t1170;
		if (_t1170 = v__table__Table_find_fn(p->table, name), _t1170.ok) {
			v__parser__Parser_fn_redefinition_error(p, name);
		}}
		v__table__TypeSymbol* ret_type_sym = v__table__Table_get_type_symbol(p->table, return_type);
		v__table__Table_register_fn(p->table, (v__table__Fn){
			.params = params,
			.return_type = return_type,
			.return_type_source_name = ret_type_sym->source_name,
			.is_variadic = is_variadic,
			.language = language,
			.is_generic = is_generic,
			.is_pub = is_pub,
			.is_deprecated = is_deprecated,
			.is_unsafe = is_unsafe,
			.is_placeholder = 0,
			.mod = p->mod,
			.ctdefine = (string){.str=(byteptr)""},
			.attrs = p->attrs,
			.name = name,
			.source_fn = 0,
		});
	}
	end_pos = v__token__Token_position(&p->prev_tok);
	p->cur_fn_name = name;
	array_v__ast__Stmt stmts = __new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
	bool no_body = p->tok.kind != v__token__Kind_lcbr;
	v__token__Position body_start_pos = v__token__Token_position(&p->peek_tok);
	if (p->tok.kind == v__token__Kind_lcbr) {
		stmts = v__parser__Parser_parse_block_no_scope(p, true);
	}
	v__parser__Parser_close_scope(p);
	if (!no_body && are_args_type_only) {
		v__parser__Parser_error_with_pos(p, tos_lit("functions with type only args can not have bodies"), body_start_pos);
	}
	return (v__ast__FnDecl){
		.name = name,
		.mod = p->mod,
		.params = params,
		.is_deprecated = is_deprecated,
		.is_pub = is_pub,
		.is_variadic = is_variadic,
		.is_anon = 0,
		.receiver = (v__ast__Field){.name = rec_name,.pos = {0},.typ = rec_type,},
		.receiver_pos = receiver_pos,
		.is_method = is_method,
		.method_idx = type_sym_method_idx,
		.rec_mut = rec_mut,
		.rec_share = 0,
		.language = language,
		.no_body = no_body,
		.is_builtin = p->builtin_mod || _IN(string, p->mod, _const_v__util__builtin_module_parts),
		.pos = v__token__Position_extend(start_pos, end_pos),
		.body_pos = body_start_pos,
		.file = p->file_name,
		.is_generic = is_generic,
		.is_direct_arr = is_direct_arr,
		.attrs = p->attrs,
		.stmts = stmts,
		.return_type = return_type,
		.comments = __new_array(0, 1, sizeof(v__ast__Comment)),
		.source_file = 0,
	};
}

VV_LOCAL_SYMBOL v__ast__AnonFn v__parser__Parser_anon_fn(v__parser__Parser* p) {
	v__token__Position pos = v__token__Token_position(&p->tok);
	v__parser__Parser_check(p, v__token__Kind_key_fn);
	v__parser__Parser_open_scope(p);
	multi_return_array_v__table__Param_bool_bool mr_9490 = v__parser__Parser_fn_args(p);
	array_v__table__Param args = mr_9490.arg0;
	bool is_variadic = mr_9490.arg2;
	// FOR IN array
	array _t1171 = args;
	for (int _t1172 = 0; _t1172 < _t1171.len; ++_t1172) {
		v__table__Param arg = ((v__table__Param*)_t1171.data)[_t1172];
		v__ast__Scope_register(p->scope, arg.name, /* sum type cast 4 */ (v__ast__ScopeObject){._277 = memdup(&(v__ast__Var[]){(v__ast__Var){
			.name = arg.name,
			.expr = {0},
			.share = 0,
			.is_mut = arg.is_mut,
			.is_autofree_tmp = 0,
			.is_arg = true,
			.typ = arg.typ,
			.sum_type_casts = __new_array(0, 1, sizeof(v__table__Type)),
			.pos = arg.pos,
			.is_used = true,
			.is_changed = 0,
		}}, sizeof(v__ast__Var)), .typ = 277 /* v.ast.Var */});
	}
	v__table__Type return_type = _const_v__table__void_type;
	if (v__token__Kind_is_start_of_type(p->tok.kind)) {
		return_type = v__parser__Parser_parse_type(p);
	}
	array_v__ast__Stmt stmts = __new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
	bool no_body = p->tok.kind != v__token__Kind_lcbr;
	if (p->tok.kind == v__token__Kind_lcbr) {
		stmts = v__parser__Parser_parse_block_no_scope(p, false);
	}
	v__parser__Parser_close_scope(p);
	v__table__TypeSymbol* ret_type_sym = v__table__Table_get_type_symbol(p->table, return_type);
	v__table__Fn func = (v__table__Fn){.params = args,.return_type = return_type,.return_type_source_name = ret_type_sym->source_name,.is_variadic = is_variadic,.language = 0,.is_generic = 0,.is_pub = 0,.is_deprecated = 0,.is_unsafe = 0,.is_placeholder = 0,.mod = (string){.str=(byteptr)""},.ctdefine = (string){.str=(byteptr)""},.attrs = __new_array(0, 1, sizeof(v__table__Attr)),.name = (string){.str=(byteptr)""},.source_fn = 0,};
	string name = _STR("anon_%"PRId32"\000_%.*s", 2, p->tok.pos, v__table__Fn_signature(&func));
	func.name = name;
	int idx = v__table__Table_find_or_register_fn_type(p->table, p->mod, func, true, false);
	v__table__Type typ = v__table__new_type(idx);
	return (v__ast__AnonFn){.decl = (v__ast__FnDecl){
		.name = name,
		.mod = p->mod,
		.params = args,
		.is_deprecated = 0,
		.is_pub = 0,
		.is_variadic = is_variadic,
		.is_anon = true,
		.receiver = {0},
		.receiver_pos = {0},
		.is_method = false,
		.method_idx = 0,
		.rec_mut = 0,
		.rec_share = 0,
		.language = 0,
		.no_body = no_body,
		.is_builtin = 0,
		.pos = pos,
		.body_pos = {0},
		.file = p->file_name,
		.is_generic = 0,
		.is_direct_arr = 0,
		.attrs = __new_array(0, 1, sizeof(v__table__Attr)),
		.stmts = stmts,
		.return_type = return_type,
		.comments = __new_array(0, 1, sizeof(v__ast__Comment)),
		.source_file = 0,
	},.typ = typ,};
}

VV_LOCAL_SYMBOL multi_return_array_v__table__Param_bool_bool v__parser__Parser_fn_args(v__parser__Parser* p) {
	v__parser__Parser_check(p, v__token__Kind_lpar);
	array_v__table__Param args = __new_array_with_default(0, 0, sizeof(v__table__Param), 0);
	bool is_variadic = false;
	string argname = (p->tok.kind == v__token__Kind_name && p->tok.lit.len > 0 && byte_is_capital(string_at(p->tok.lit, 0)) ? (v__parser__Parser_prepend_mod(p, p->tok.lit)) : (p->tok.lit));
	bool types_only = (p->tok.kind == v__token__Kind_amp || p->tok.kind == v__token__Kind_ellipsis || p->tok.kind == v__token__Kind_key_fn) || (p->peek_tok.kind == v__token__Kind_comma && v__table__Table_known_type(p->table, argname)) || p->peek_tok.kind == v__token__Kind_rpar;
	if (types_only) {
		int arg_no = 1;
		for (;;) {
			if (!(p->tok.kind != v__token__Kind_rpar)) break;
			bool is_shared = p->tok.kind == v__token__Kind_key_shared;
			bool is_atomic = p->tok.kind == v__token__Kind_key_atomic;
			bool is_mut = p->tok.kind == v__token__Kind_key_mut || is_shared || is_atomic;
			if (is_mut) {
				v__parser__Parser_next(p);
			}
			if (p->tok.kind == v__token__Kind_ellipsis) {
				v__parser__Parser_next(p);
				is_variadic = true;
			}
			v__token__Position pos = v__token__Token_position(&p->tok);
			v__table__Type arg_type = v__parser__Parser_parse_type(p);
			if (is_mut) {
				if (!v__table__Type_has_flag(arg_type, v__table__TypeFlag_generic)) {
					if (is_shared) {
						v__parser__Parser_check_fn_shared_arguments(p, arg_type, pos);
					} else if (is_atomic) {
						v__parser__Parser_check_fn_atomic_arguments(p, arg_type, pos);
					} else {
						v__parser__Parser_check_fn_mutable_arguments(p, arg_type, pos);
					}
				} else if (is_shared || is_atomic) {
					v__parser__Parser_error_with_pos(p, tos_lit("generic object cannot be `atomic`or `shared`"), pos);
					break;
				}
				arg_type = v__table__Type_set_nr_muls(arg_type, 1);
				if (is_shared) {
					arg_type = v__table__Type_set_flag(arg_type, v__table__TypeFlag_shared_f);
				}
				if (is_atomic) {
					arg_type = v__table__Type_set_flag(arg_type, v__table__TypeFlag_atomic_f);
				}
			}
			if (is_variadic) {
				arg_type = v__table__Type_set_flag(arg_type, v__table__TypeFlag_variadic);
			}
			if (p->tok.kind == v__token__Kind_comma) {
				if (is_variadic) {
					v__parser__Parser_error_with_pos(p, _STR("cannot use ...(variadic) with non-final parameter no %"PRId32"", 1, arg_no), pos);
					break;
				}
				v__parser__Parser_next(p);
			}
			v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(p->table, arg_type);
			array_push(&args, _MOV((v__table__Param[]){ (v__table__Param){.pos = pos,.name = tos_lit(""),.is_mut = is_mut,.typ = arg_type,.type_source_name = sym->source_name,.is_hidden = 0,} }));
			arg_no++;
			if (arg_no > 1024) {
				v__parser__Parser_error_with_pos(p, tos_lit("too many args"), pos);
				break;
			}
		}
	} else {
		for (;;) {
			if (!(p->tok.kind != v__token__Kind_rpar)) break;
			bool is_shared = p->tok.kind == v__token__Kind_key_shared;
			bool is_atomic = p->tok.kind == v__token__Kind_key_atomic;
			bool is_mut = p->tok.kind == v__token__Kind_key_mut || is_shared || is_atomic;
			if (is_mut) {
				v__parser__Parser_next(p);
			}
			array_v__token__Position arg_pos = new_array_from_c_array(1, 1, sizeof(v__token__Position), _MOV((v__token__Position[1]){v__token__Token_position(&p->tok)}));
			array_string arg_names = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){v__parser__Parser_check_name(p)}));
			for (;;) {
				if (!(p->tok.kind == v__token__Kind_comma)) break;
				if (!p->pref->is_fmt) {
					v__parser__Parser_warn(p, string_add(tos_lit("`fn f(x, y Type)` syntax has been deprecated and will soon be removed. "), tos_lit("Use `fn f(x Type, y Type)` instead. You can run `v fmt -w file.v` to automatically fix your code.")));
				}
				v__parser__Parser_next(p);
				array_push(&arg_pos, _MOV((v__token__Position[]){ v__token__Token_position(&p->tok) }));
				array_push(&arg_names, _MOV((string[]){ string_clone(v__parser__Parser_check_name(p)) }));
			}
			if (p->tok.kind == v__token__Kind_key_mut) {
				v__parser__Parser_warn_with_pos(p, tos_lit("use `mut f Foo` instead of `f mut Foo`"), v__token__Token_position(&p->tok));
				is_mut = true;
			}
			if (p->tok.kind == v__token__Kind_ellipsis) {
				v__parser__Parser_next(p);
				is_variadic = true;
			}
			v__token__Position pos = v__token__Token_position(&p->tok);
			v__table__Type typ = v__parser__Parser_parse_type(p);
			if (is_mut) {
				if (!v__table__Type_has_flag(typ, v__table__TypeFlag_generic)) {
					if (is_shared) {
						v__parser__Parser_check_fn_shared_arguments(p, typ, pos);
					} else if (is_atomic) {
						v__parser__Parser_check_fn_atomic_arguments(p, typ, pos);
					} else {
						v__parser__Parser_check_fn_mutable_arguments(p, typ, pos);
					}
				} else if (is_shared || is_atomic) {
					v__parser__Parser_error_with_pos(p, tos_lit("generic object cannot be `atomic` or `shared`"), pos);
					break;
				}
				typ = v__table__Type_set_nr_muls(typ, 1);
				if (is_shared) {
					typ = v__table__Type_set_flag(typ, v__table__TypeFlag_shared_f);
				}
				if (is_atomic) {
					typ = v__table__Type_set_flag(typ, v__table__TypeFlag_atomic_f);
				}
			}
			if (is_variadic) {
				typ = v__table__Type_set_flag(typ, v__table__TypeFlag_variadic);
			}
			// FOR IN array
			array _t1176 = arg_names;
			for (int i = 0; i < _t1176.len; ++i) {
				string arg_name = ((string*)_t1176.data)[i];
				v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(p->table, typ);
				array_push(&args, _MOV((v__table__Param[]){ (v__table__Param){.pos = (*(v__token__Position*)/*ee elem_typ */array_get(arg_pos, i)),.name = arg_name,.is_mut = is_mut,.typ = typ,.type_source_name = sym->source_name,.is_hidden = 0,} }));
				if (is_variadic && p->tok.kind == v__token__Kind_comma) {
					v__parser__Parser_error_with_pos(p, _STR("cannot use ...(variadic) with non-final parameter %.*s", 1, arg_name), (*(v__token__Position*)/*ee elem_typ */array_get(arg_pos, i)));
					break;
				}
			}
			if (p->tok.kind != v__token__Kind_rpar) {
				v__parser__Parser_check(p, v__token__Kind_comma);
			}
		}
	}
	v__parser__Parser_check(p, v__token__Kind_rpar);
	return (multi_return_array_v__table__Param_bool_bool){.arg0=args, .arg1=types_only, .arg2=is_variadic};
}

VV_LOCAL_SYMBOL void v__parser__Parser_check_fn_mutable_arguments(v__parser__Parser* p, v__table__Type typ, v__token__Position pos) {
	v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(p->table, typ);
	if (!(sym->kind == v__table__Kind_array || sym->kind == v__table__Kind_struct_ || sym->kind == v__table__Kind_map || sym->kind == v__table__Kind_placeholder || sym->kind == v__table__Kind_sum_type) && !v__table__Type_is_ptr(typ)) {
		v__parser__Parser_error_with_pos(p, string_add(tos_lit("mutable arguments are only allowed for arrays, maps, and structs\n"), _STR("return values instead: `fn foo(mut n %.*s\000) {` => `fn foo(n %.*s\000) %.*s\000 {`", 4, sym->name, sym->name, sym->name)), pos);
	}
}

VV_LOCAL_SYMBOL void v__parser__Parser_check_fn_shared_arguments(v__parser__Parser* p, v__table__Type typ, v__token__Position pos) {
	v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(p->table, typ);
	if (!(sym->kind == v__table__Kind_array || sym->kind == v__table__Kind_struct_ || sym->kind == v__table__Kind_map || sym->kind == v__table__Kind_placeholder) && !v__table__Type_is_ptr(typ)) {
		v__parser__Parser_error_with_pos(p, tos_lit("shared arguments are only allowed for arrays, maps, and structs\n"), pos);
	}
}

VV_LOCAL_SYMBOL void v__parser__Parser_check_fn_atomic_arguments(v__parser__Parser* p, v__table__Type typ, v__token__Position pos) {
	v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(p->table, typ);
	if (!(sym->kind == v__table__Kind_u32 || sym->kind == v__table__Kind_int || sym->kind == v__table__Kind_u64)) {
		v__parser__Parser_error_with_pos(p, string_add(tos_lit("atomic arguments are only allowed for 32/64 bit integers\n"), _STR("use shared arguments instead: `fn foo(atomic n %.*s\000) {` => `fn foo(shared n %.*s\000) {`", 3, sym->name, sym->name)), pos);
	}
}

VV_LOCAL_SYMBOL void v__parser__Parser_fn_redefinition_error(v__parser__Parser* p, string name) {
	if (p->pref->translated) {
		return;
	}
	array_push(&p->table->redefined_fns, _MOV((string[]){ string_clone(name) }));
}

VV_LOCAL_SYMBOL bool v__parser__have_fn_main(array_v__ast__Stmt stmts) {
	// FOR IN array
	array _t1179 = stmts;
	for (int _t1180 = 0; _t1180 < _t1179.len; ++_t1180) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)_t1179.data)[_t1180];
		if ((stmt).typ == 151 /* v.ast.FnDecl */) {
			if (string_eq((*stmt._151).name, tos_lit("main.main")) && string_eq((*stmt._151).mod, tos_lit("main"))) {
				return true;
			}
		}
	}
	return false;
}

VV_LOCAL_SYMBOL v__ast__Stmt v__parser__Parser_for_stmt(v__parser__Parser* p) {
	v__parser__Parser_check(p, v__token__Kind_key_for);
	v__token__Position pos = v__token__Token_position(&p->tok);
	v__parser__Parser_open_scope(p);
	p->inside_for = true;
	if (p->tok.kind == v__token__Kind_key_match) {
		v__parser__Parser_error(p, tos_lit("cannot use `match` in `for` loop"));
	}
	if (p->tok.kind == v__token__Kind_lcbr) {
		p->inside_for = false;
		array_v__ast__Stmt stmts = v__parser__Parser_parse_block(p);
		v__parser__Parser_close_scope(p);
		return /* sum type cast 4 */ (v__ast__Stmt){._262 = memdup(&(v__ast__ForStmt[]){(v__ast__ForStmt){.cond = {0},.stmts = stmts,.is_inf = true,.pos = pos,.label = (string){.str=(byteptr)""},}}, sizeof(v__ast__ForStmt)), .typ = 262 /* v.ast.ForStmt */};
	} else if ((p->peek_tok.kind == v__token__Kind_decl_assign || p->peek_tok.kind == v__token__Kind_assign || p->peek_tok.kind == v__token__Kind_semicolon) || p->tok.kind == v__token__Kind_semicolon) {
		if (p->tok.kind == v__token__Kind_key_mut) {
			v__parser__Parser_error(p, tos_lit("`mut` is not needed in `for ;;` loops: use `for i := 0; i < n; i ++ {`"));
		}
		v__ast__Stmt init = (v__ast__Stmt){
#ifndef __cplusplus
0
#endif
};
		v__ast__Expr cond = v__parser__Parser_new_true_expr(p);
		v__ast__Stmt inc = (v__ast__Stmt){
#ifndef __cplusplus
0
#endif
};
		bool has_init = false;
		bool has_cond = false;
		bool has_inc = false;
		if ((p->peek_tok.kind == v__token__Kind_assign || p->peek_tok.kind == v__token__Kind_decl_assign)) {
			init = v__parser__Parser_assign_stmt(p);
			has_init = true;
		}
		v__parser__Parser_check(p, v__token__Kind_semicolon);
		if (p->tok.kind != v__token__Kind_semicolon) {
			if (p->tok.kind == v__token__Kind_name && (p->peek_tok.kind == v__token__Kind_inc || p->peek_tok.kind == v__token__Kind_dec)) {
				v__parser__Parser_error(p, _STR("cannot use %.*s\000%.*s\000 as value", 3, p->tok.lit, v__token__Kind_str(p->peek_tok.kind)));
			}
			cond = v__parser__Parser_expr(p, 0);
			has_cond = true;
		}
		v__parser__Parser_check(p, v__token__Kind_semicolon);
		if (p->tok.kind != v__token__Kind_lcbr) {
			inc = v__parser__Parser_stmt(p, false);
			has_inc = true;
		}
		p->inside_for = false;
		array_v__ast__Stmt stmts = v__parser__Parser_parse_block(p);
		v__parser__Parser_close_scope(p);
		return /* sum type cast 4 */ (v__ast__Stmt){._260 = memdup(&(v__ast__ForCStmt[]){(v__ast__ForCStmt){
			.init = init,
			.has_init = has_init,
			.cond = cond,
			.has_cond = has_cond,
			.inc = inc,
			.has_inc = has_inc,
			.stmts = stmts,
			.pos = pos,
			.label = (string){.str=(byteptr)""},
		}}, sizeof(v__ast__ForCStmt)), .typ = 260 /* v.ast.ForCStmt */};
	} else if ((p->peek_tok.kind == v__token__Kind_key_in || p->peek_tok.kind == v__token__Kind_comma) || (p->tok.kind == v__token__Kind_key_mut && (p->peek_tok2.kind == v__token__Kind_key_in || p->peek_tok2.kind == v__token__Kind_comma))) {
		bool val_is_mut = p->tok.kind == v__token__Kind_key_mut;
		if (val_is_mut) {
			v__parser__Parser_next(p);
		}
		v__token__Position key_var_pos = v__token__Token_position(&p->tok);
		v__token__Position val_var_pos = v__token__Token_position(&p->tok);
		string key_var_name = tos_lit("");
		string val_var_name = v__parser__Parser_check_name(p);
		if (p->tok.kind == v__token__Kind_comma) {
			v__parser__Parser_next(p);
			key_var_name = val_var_name;
			val_var_pos = v__token__Token_position(&p->tok);
			val_var_name = v__parser__Parser_check_name(p);
			if (string_eq(key_var_name, val_var_name) && string_ne(key_var_name, tos_lit("_"))) {
				v__parser__Parser_error_with_pos(p, tos_lit("key and value in a for loop cannot be the same"), val_var_pos);
			}
			if (v__ast__Scope_known_var(p->scope, key_var_name)) {
				v__parser__Parser_error(p, _STR("redefinition of key iteration variable `%.*s\000`", 2, key_var_name));
			}
			if (v__ast__Scope_known_var(p->scope, val_var_name)) {
				v__parser__Parser_error(p, _STR("redefinition of value iteration variable `%.*s\000`", 2, val_var_name));
			}
			v__ast__Scope_register(p->scope, key_var_name, /* sum type cast 4 */ (v__ast__ScopeObject){._277 = memdup(&(v__ast__Var[]){(v__ast__Var){.name = key_var_name,.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.typ = _const_v__table__int_type,.sum_type_casts = __new_array(0, 1, sizeof(v__table__Type)),.pos = key_var_pos,.is_used = 0,.is_changed = 0,}}, sizeof(v__ast__Var)), .typ = 277 /* v.ast.Var */});
		} else if (v__ast__Scope_known_var(p->scope, val_var_name)) {
			v__parser__Parser_error(p, _STR("redefinition of value iteration variable `%.*s\000`", 2, val_var_name));
		}
		v__parser__Parser_check(p, v__token__Kind_key_in);
		if (p->tok.kind == v__token__Kind_name && (string_eq(p->tok.lit, key_var_name) || string_eq(p->tok.lit, val_var_name))) {
			v__parser__Parser_error(p, _STR("in a `for x in array` loop, the key or value iteration variable `%.*s\000` can not be the same as the array variable", 2, p->tok.lit));
		}
		v__ast__Expr cond = v__parser__Parser_expr(p, 0);
		v__ast__Expr high_expr = (v__ast__Expr){
#ifndef __cplusplus
0
#endif
};
		bool is_range = false;
		if (p->tok.kind == v__token__Kind_dotdot) {
			is_range = true;
			v__parser__Parser_next(p);
			high_expr = v__parser__Parser_expr(p, 0);
			v__ast__Scope_register(p->scope, val_var_name, /* sum type cast 4 */ (v__ast__ScopeObject){._277 = memdup(&(v__ast__Var[]){(v__ast__Var){.name = val_var_name,.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.typ = _const_v__table__int_type,.sum_type_casts = __new_array(0, 1, sizeof(v__table__Type)),.pos = val_var_pos,.is_used = 0,.is_changed = 0,}}, sizeof(v__ast__Var)), .typ = 277 /* v.ast.Var */});
			if (key_var_name.len > 0) {
				v__parser__Parser_error_with_pos(p, tos_lit("cannot declare index variable with range `for`"), key_var_pos);
			}
		} else {
			v__ast__Scope_register(p->scope, val_var_name, /* sum type cast 4 */ (v__ast__ScopeObject){._277 = memdup(&(v__ast__Var[]){(v__ast__Var){.name = val_var_name,.expr = {0},.share = 0,.is_mut = val_is_mut,.is_autofree_tmp = 0,.is_arg = 0,.typ = 0,.sum_type_casts = __new_array(0, 1, sizeof(v__table__Type)),.pos = val_var_pos,.is_used = 0,.is_changed = 0,}}, sizeof(v__ast__Var)), .typ = 277 /* v.ast.Var */});
		}
		p->inside_for = false;
		array_v__ast__Stmt stmts = v__parser__Parser_parse_block(p);
		v__parser__Parser_close_scope(p);
		return /* sum type cast 4 */ (v__ast__Stmt){._261 = memdup(&(v__ast__ForInStmt[]){(v__ast__ForInStmt){
			.key_var = key_var_name,
			.val_var = val_var_name,
			.cond = cond,
			.is_range = is_range,
			.high = high_expr,
			.stmts = stmts,
			.pos = pos,
			.val_is_mut = val_is_mut,
			.key_type = 0,
			.val_type = 0,
			.cond_type = 0,
			.kind = 0,
			.label = (string){.str=(byteptr)""},
		}}, sizeof(v__ast__ForInStmt)), .typ = 261 /* v.ast.ForInStmt */};
	}
	v__ast__Expr cond = v__parser__Parser_expr(p, 0);
	p->inside_for = false;
	array_v__ast__Stmt stmts = v__parser__Parser_parse_block(p);
	v__parser__Parser_close_scope(p);
	return /* sum type cast 4 */ (v__ast__Stmt){._262 = memdup(&(v__ast__ForStmt[]){(v__ast__ForStmt){.cond = cond,.stmts = stmts,.is_inf = 0,.pos = pos,.label = (string){.str=(byteptr)""},}}, sizeof(v__ast__ForStmt)), .typ = 262 /* v.ast.ForStmt */};
}

VV_LOCAL_SYMBOL v__ast__IfExpr v__parser__Parser_if_expr(v__parser__Parser* p, bool is_comptime) {
	bool was_inside_if_expr = p->inside_if_expr;
	bool was_inside_ct_if_expr = p->inside_ct_if_expr;
	p->inside_if_expr = true;
	v__token__Position pos = (is_comptime ? (p->inside_ct_if_expr = true,v__parser__Parser_next(p),v__token__Position_extend(v__token__Token_position(&p->prev_tok), v__token__Token_position(&p->tok))) : (v__token__Token_position(&p->tok)));
	array_v__ast__IfBranch branches = __new_array_with_default(0, 0, sizeof(v__ast__IfBranch), 0);
	bool has_else = false;
	array_v__ast__Comment comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	bool prev_guard = false;
	for (;;) {
		if (!((p->tok.kind == v__token__Kind_key_if || p->tok.kind == v__token__Kind_key_else))) break;
		p->inside_if = true;
		v__token__Position start_pos = (is_comptime ? (v__token__Position_extend(v__token__Token_position(&p->prev_tok), v__token__Token_position(&p->tok))) : (v__token__Token_position(&p->tok)));
		if (p->tok.kind == v__token__Kind_key_else) {
			_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p)), _t1181, array_v__ast__Comment);
			v__parser__Parser_check(p, v__token__Kind_key_else);
			_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p)), _t1182, array_v__ast__Comment);
			if (p->tok.kind == v__token__Kind_key_match) {
				v__parser__Parser_error(p, tos_lit("cannot use `match` with `if` statements"));
			}
			if (p->tok.kind == v__token__Kind_lcbr) {
				has_else = true;
				p->inside_if = false;
				v__token__Position end_pos = v__token__Token_position(&p->prev_tok);
				v__token__Position body_pos = v__token__Token_position(&p->tok);
				if (prev_guard) {
					v__parser__Parser_open_scope(p);
					v__ast__Scope_register(p->scope, tos_lit("errcode"), /* sum type cast 4 */ (v__ast__ScopeObject){._277 = memdup(&(v__ast__Var[]){(v__ast__Var){.name = tos_lit("errcode"),.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.typ = _const_v__table__int_type,.sum_type_casts = __new_array(0, 1, sizeof(v__table__Type)),.pos = body_pos,.is_used = true,.is_changed = 0,}}, sizeof(v__ast__Var)), .typ = 277 /* v.ast.Var */});
					v__ast__Scope_register(p->scope, tos_lit("err"), /* sum type cast 4 */ (v__ast__ScopeObject){._277 = memdup(&(v__ast__Var[]){(v__ast__Var){.name = tos_lit("err"),.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.typ = _const_v__table__string_type,.sum_type_casts = __new_array(0, 1, sizeof(v__table__Type)),.pos = body_pos,.is_used = true,.is_changed = 0,}}, sizeof(v__ast__Var)), .typ = 277 /* v.ast.Var */});
				}
				array_push(&branches, _MOV((v__ast__IfBranch[]){ (v__ast__IfBranch){.cond = {0},.pos = v__token__Position_extend(start_pos, end_pos),.body_pos = v__token__Position_extend(body_pos, v__token__Token_position(&p->tok)),.comments = comments,.stmts = (prev_guard ? (v__parser__Parser_parse_block_no_scope(p, false)) : (v__parser__Parser_parse_block(p))),.smartcast = 0,} }));
				if (prev_guard) {
					v__parser__Parser_close_scope(p);
				}
				comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
				break;
			}
			if (is_comptime) {
				v__parser__Parser_check(p, v__token__Kind_dollar);
			}
		}
		v__parser__Parser_check(p, v__token__Kind_key_if);
		if (p->tok.kind == v__token__Kind_key_match) {
			v__parser__Parser_error(p, tos_lit("cannot use `match` with `if` statements"));
		}
		_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p)), _t1184, array_v__ast__Comment);
		v__ast__Expr cond = (v__ast__Expr){
#ifndef __cplusplus
0
#endif
};
		bool is_guard = false;
		if (!is_comptime && p->peek_tok.kind == v__token__Kind_decl_assign) {
			v__parser__Parser_open_scope(p);
			is_guard = true;
			v__token__Position var_pos = v__token__Token_position(&p->tok);
			string var_name = v__parser__Parser_check_name(p);
			_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p)), _t1185, array_v__ast__Comment);
			v__parser__Parser_check(p, v__token__Kind_decl_assign);
			_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p)), _t1186, array_v__ast__Comment);
			v__ast__Expr expr = v__parser__Parser_expr(p, 0);
			cond = /* sum type cast 4 */ (v__ast__Expr){._226 = memdup(&(v__ast__IfGuardExpr[]){(v__ast__IfGuardExpr){.var_name = var_name,.expr = expr,.pos = {0},.expr_type = 0,}}, sizeof(v__ast__IfGuardExpr)), .typ = 226 /* v.ast.IfGuardExpr */};
			v__ast__Scope_register(p->scope, var_name, /* sum type cast 4 */ (v__ast__ScopeObject){._277 = memdup(&(v__ast__Var[]){(v__ast__Var){.name = var_name,.expr = cond,.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.typ = 0,.sum_type_casts = __new_array(0, 1, sizeof(v__table__Type)),.pos = var_pos,.is_used = 0,.is_changed = 0,}}, sizeof(v__ast__Var)), .typ = 277 /* v.ast.Var */});
			prev_guard = true;
		} else {
			prev_guard = false;
			cond = v__parser__Parser_expr(p, 0);
		}
		_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p)), _t1187, array_v__ast__Comment);
		v__token__Position end_pos = v__token__Token_position(&p->prev_tok);
		v__token__Position body_pos = v__token__Token_position(&p->tok);
		p->inside_if = false;
		array_v__ast__Stmt stmts = v__parser__Parser_parse_block(p);
		if (is_guard) {
			v__parser__Parser_close_scope(p);
		}
		array_push(&branches, _MOV((v__ast__IfBranch[]){ (v__ast__IfBranch){.cond = cond,.pos = v__token__Position_extend(start_pos, end_pos),.body_pos = v__token__Position_extend(body_pos, v__token__Token_position(&p->prev_tok)),.comments = comments,.stmts = stmts,.smartcast = 0,} }));
		comments = v__parser__Parser_eat_comments(p);
		if (is_comptime) {
			if (p->tok.kind == v__token__Kind_key_else) {
				v__parser__Parser_error(p, tos_lit("use `$else` instead of `else` in compile-time `if` branches"));
			}
			if (p->peek_tok.kind == v__token__Kind_key_else) {
				v__parser__Parser_check(p, v__token__Kind_dollar);
			}
		}
		if (p->tok.kind != v__token__Kind_key_else) {
			break;
		}
	}
	// Defer begin
	p->inside_if_expr = was_inside_if_expr;
	p->inside_ct_if_expr = was_inside_ct_if_expr;
	// Defer end
	return (v__ast__IfExpr){.is_comptime = is_comptime,.tok_kind = 0,.left = {0},.pos = pos,.post_comments = comments,.branches = branches,.is_expr = 0,.typ = 0,.has_else = has_else,};
}

VV_LOCAL_SYMBOL v__ast__MatchExpr v__parser__Parser_match_expr(v__parser__Parser* p) {
	v__token__Position match_first_pos = v__token__Token_position(&p->tok);
	p->inside_match = true;
	v__parser__Parser_check(p, v__token__Kind_key_match);
	bool is_sum_type = false;
	v__ast__Expr cond = v__parser__Parser_expr(p, 0);
	p->inside_match = false;
	bool no_lcbr = p->tok.kind != v__token__Kind_lcbr;
	if (!no_lcbr) {
		v__parser__Parser_check(p, v__token__Kind_lcbr);
	}
	array_v__ast__MatchBranch branches = __new_array_with_default(0, 0, sizeof(v__ast__MatchBranch), 0);
	for (;;) {
		v__token__Position branch_first_pos = v__token__Token_position(&p->tok);
		array_v__ast__Comment comments = v__parser__Parser_eat_comments(p);
		array_v__ast__Expr exprs = __new_array_with_default(0, 0, sizeof(v__ast__Expr), 0);
		array_array_v__ast__Comment ecmnts = __new_array_with_default(0, 0, sizeof(array_v__ast__Comment), 0);
		v__parser__Parser_open_scope(p);
		bool is_else = false;
		if (p->tok.kind == v__token__Kind_key_else) {
			is_else = true;
			v__parser__Parser_next(p);
		} else if (p->tok.kind == v__token__Kind_name && !(string_eq(p->tok.lit, tos_lit("C")) && p->peek_tok.kind == v__token__Kind_dot) && (_IN(string, p->tok.lit, _const_v__table__builtin_type_names) || byte_is_capital(string_at(p->tok.lit, 0)) || (p->peek_tok.kind == v__token__Kind_dot && byte_is_capital(string_at(p->peek_tok2.lit, 0))))) {
			array_v__table__Type types = __new_array_with_default(0, 0, sizeof(v__table__Type), 0);
			for (;;) {
				v__table__Type parsed_type = v__parser__Parser_parse_type(p);
				array_push(&ecmnts, _MOV((array_v__ast__Comment[]){ v__parser__Parser_eat_comments(p) }));
				array_push(&types, _MOV((v__table__Type[]){ parsed_type }));
				array_push(&exprs, _MOV((v__ast__Expr[]){ /* sum type cast 4 */ (v__ast__Expr){._247 = memdup(&(v__ast__Type[]){(v__ast__Type){.typ = parsed_type,.pos = v__token__Token_position(&p->prev_tok),}}, sizeof(v__ast__Type)), .typ = 247 /* v.ast.Type */} }));
				if (p->tok.kind != v__token__Kind_comma) {
					break;
				}
				v__parser__Parser_check(p, v__token__Kind_comma);
			}
			is_sum_type = true;
		} else {
			for (;;) {
				p->inside_match_case = true;
				v__ast__Expr expr = v__parser__Parser_expr(p, 0);
				array_push(&ecmnts, _MOV((array_v__ast__Comment[]){ v__parser__Parser_eat_comments(p) }));
				p->inside_match_case = false;
				if (p->tok.kind == v__token__Kind_dotdot) {
					v__parser__Parser_error_with_pos(p, tos_lit("match only supports inclusive (`...`) ranges, not exclusive (`..`)"), v__token__Token_position(&p->tok));
				} else if (p->tok.kind == v__token__Kind_ellipsis) {
					v__parser__Parser_next(p);
					v__ast__Expr expr2 = v__parser__Parser_expr(p, 0);
					array_push(&exprs, _MOV((v__ast__Expr[]){ /* sum type cast 4 */ (v__ast__Expr){._239 = memdup(&(v__ast__RangeExpr[]){(v__ast__RangeExpr){.low = expr,.high = expr2,.has_high = true,.has_low = true,.pos = v__token__Token_position(&p->tok),}}, sizeof(v__ast__RangeExpr)), .typ = 239 /* v.ast.RangeExpr */} }));
				} else {
					array_push(&exprs, _MOV((v__ast__Expr[]){ expr }));
				}
				if (p->tok.kind != v__token__Kind_comma) {
					break;
				}
				v__parser__Parser_check(p, v__token__Kind_comma);
			}
		}
		v__token__Position branch_last_pos = v__token__Token_position(&p->tok);
		p->inside_match_body = true;
		array_v__ast__Stmt stmts = v__parser__Parser_parse_block_no_scope(p, false);
		v__parser__Parser_close_scope(p);
		p->inside_match_body = false;
		v__token__Position pos = (v__token__Position){.len = branch_last_pos.pos - branch_first_pos.pos + branch_last_pos.len,.line_nr = branch_first_pos.line_nr,.pos = branch_first_pos.pos,};
		array_v__ast__Comment post_comments = v__parser__Parser_eat_comments(p);
		array_push(&branches, _MOV((v__ast__MatchBranch[]){ (v__ast__MatchBranch){
			.exprs = exprs,
			.ecmnts = ecmnts,
			.stmts = stmts,
			.pos = pos,
			.comments = comments,
			.is_else = is_else,
			.post_comments = post_comments,
		} }));
		if (p->tok.kind == v__token__Kind_rcbr || (is_else && no_lcbr)) {
			break;
		}
	}
	v__token__Position match_last_pos = v__token__Token_position(&p->tok);
	v__token__Position pos = (v__token__Position){.len = match_last_pos.pos - match_first_pos.pos + match_last_pos.len,.line_nr = match_first_pos.line_nr,.pos = match_first_pos.pos,};
	if (p->tok.kind == v__token__Kind_rcbr) {
		v__parser__Parser_check(p, v__token__Kind_rcbr);
	}
	return (v__ast__MatchExpr){.tok_kind = 0,.cond = cond,.branches = branches,.pos = pos,.is_expr = 0,.return_type = 0,.cond_type = 0,.expected_type = 0,.is_sum_type = is_sum_type,};
}

VV_LOCAL_SYMBOL v__ast__SelectExpr v__parser__Parser_select_expr(v__parser__Parser* p) {
	v__token__Position match_first_pos = v__token__Token_position(&p->tok);
	v__parser__Parser_check(p, v__token__Kind_key_select);
	bool no_lcbr = p->tok.kind != v__token__Kind_lcbr;
	if (!no_lcbr) {
		v__parser__Parser_check(p, v__token__Kind_lcbr);
	}
	array_v__ast__SelectBranch branches = __new_array_with_default(0, 0, sizeof(v__ast__SelectBranch), 0);
	bool has_else = false;
	bool has_timeout = false;
	for (;;) {
		v__token__Position branch_first_pos = v__token__Token_position(&p->tok);
		v__ast__Comment comment = v__parser__Parser_check_comment(p);
		v__parser__Parser_open_scope(p);
		bool is_else = false;
		bool is_timeout = false;
		v__ast__Stmt stmt = (v__ast__Stmt){
#ifndef __cplusplus
0
#endif
};
		if (p->tok.kind == v__token__Kind_key_else) {
			if (has_timeout) {
				v__parser__Parser_error_with_pos(p, tos_lit("timeout `> t` and `else` are mutually exclusive `select` keys"), v__token__Token_position(&p->tok));
			}
			if (has_else) {
				v__parser__Parser_error_with_pos(p, tos_lit("at most one `else` branch allowed in `select` block"), v__token__Token_position(&p->tok));
			}
			is_else = true;
			has_else = true;
			v__parser__Parser_next(p);
		} else if (p->tok.kind == v__token__Kind_gt) {
			if (has_else) {
				v__parser__Parser_error_with_pos(p, tos_lit("`else` and timeout `> t` are mutually exclusive `select` keys"), v__token__Token_position(&p->tok));
			}
			if (has_timeout) {
				v__parser__Parser_error_with_pos(p, tos_lit("at most one timeout `> t` branch allowed in `select` block"), v__token__Token_position(&p->tok));
			}
			is_timeout = true;
			has_timeout = true;
			v__parser__Parser_next(p);
			p->inside_match = true;
			v__ast__Expr expr = v__parser__Parser_expr(p, 0);
			p->inside_match = false;
			stmt = /* sum type cast 4 */ (v__ast__Stmt){._259 = memdup(&(v__ast__ExprStmt[]){(v__ast__ExprStmt){.expr = expr,.pos = v__ast__Expr_position(expr),.comments = new_array_from_c_array(1, 1, sizeof(v__ast__Comment), _MOV((v__ast__Comment[1]){comment})),.is_expr = true,.typ = 0,}}, sizeof(v__ast__ExprStmt)), .typ = 259 /* v.ast.ExprStmt */};
		} else {
			p->inside_match = true;
			p->inside_select = true;
			multi_return_array_v__ast__Expr_array_v__ast__Comment mr_7746 = v__parser__Parser_expr_list(p);
			array_v__ast__Expr exprs = mr_7746.arg0;
			array_v__ast__Comment comments = mr_7746.arg1;
			if (exprs.len != 1) {
				v__parser__Parser_error(p, tos_lit("only one expression allowed as `select` key"));
			}
			if ((p->tok.kind == v__token__Kind_assign || p->tok.kind == v__token__Kind_decl_assign)) {
				stmt = v__parser__Parser_partial_assign_stmt(p, exprs, comments);
			} else {
				stmt = /* sum type cast 4 */ (v__ast__Stmt){._259 = memdup(&(v__ast__ExprStmt[]){(v__ast__ExprStmt){.expr = (*(v__ast__Expr*)/*ee elem_typ */array_get(exprs, 0)),.pos = v__ast__Expr_position((*(v__ast__Expr*)/*ee elem_typ */array_get(exprs, 0))),.comments = new_array_from_c_array(1, 1, sizeof(v__ast__Comment), _MOV((v__ast__Comment[1]){comment})),.is_expr = true,.typ = 0,}}, sizeof(v__ast__ExprStmt)), .typ = 259 /* v.ast.ExprStmt */};
			}
			p->inside_match = false;
			p->inside_select = false;
			v__ast__Stmt _t1196 = stmt;
			if (_t1196.typ == 259 /* v.ast.ExprStmt */) {
				if (!(*stmt._259).is_expr) {
					v__parser__Parser_error_with_pos(p, tos_lit("select: invalid expression"), (*stmt._259).pos);
				} else {
					v__ast__Expr _t1197 = (*stmt._259).expr;
					if (_t1197.typ == 228 /* v.ast.InfixExpr */) {
						if ((*(*stmt._259).expr._228).op != v__token__Kind_arrow) {
							v__parser__Parser_error_with_pos(p, tos_lit("select key: `<-` operator expected"), (*(*stmt._259).expr._228).pos);
						}
					} else {
						v__parser__Parser_error_with_pos(p, tos_lit("select key: send expression (`ch <- x`) expected"), (*stmt._259).pos);
					};
				}
			} else if (_t1196.typ == 252 /* v.ast.AssignStmt */) {
				v__ast__Expr expr = (*(v__ast__Expr*)/*ee elem_typ */array_get((*stmt._252).right, 0));
				v__ast__Expr _t1198 = expr;
				if (_t1198.typ == 238 /* v.ast.PrefixExpr */) {
					if ((*expr._238).op != v__token__Kind_arrow) {
						v__parser__Parser_error_with_pos(p, tos_lit("select key: `<-` operator expected"), (*expr._238).pos);
					}
				} else {
					v__parser__Parser_error_with_pos(p, tos_lit("select key: receive expression expected"), v__ast__Expr_position((*(v__ast__Expr*)/*ee elem_typ */array_get((*stmt._252).right, 0))));
				};
			} else {
				v__parser__Parser_error_with_pos(p, tos_lit("select: transmission statement expected"), v__ast__Stmt_position(stmt));
			};
		}
		v__token__Position branch_last_pos = v__token__Token_position(&p->tok);
		p->inside_match_body = true;
		array_v__ast__Stmt stmts = v__parser__Parser_parse_block_no_scope(p, false);
		v__parser__Parser_close_scope(p);
		p->inside_match_body = false;
		v__token__Position pos = (v__token__Position){.len = branch_last_pos.pos - branch_first_pos.pos + branch_last_pos.len,.line_nr = branch_first_pos.line_nr,.pos = branch_first_pos.pos,};
		array_v__ast__Comment post_comments = v__parser__Parser_eat_comments(p);
		array_push(&branches, _MOV((v__ast__SelectBranch[]){ (v__ast__SelectBranch){
			.stmt = stmt,
			.stmts = stmts,
			.pos = pos,
			.comment = comment,
			.is_else = is_else,
			.is_timeout = is_timeout,
			.post_comments = post_comments,
		} }));
		if (p->tok.kind == v__token__Kind_rcbr || ((is_else || is_timeout) && no_lcbr)) {
			break;
		}
	}
	v__token__Position match_last_pos = v__token__Token_position(&p->tok);
	v__token__Position pos = (v__token__Position){.len = match_last_pos.pos - match_first_pos.pos + match_last_pos.len,.line_nr = match_first_pos.line_nr,.pos = match_first_pos.pos,};
	if (p->tok.kind == v__token__Kind_rcbr) {
		v__parser__Parser_check(p, v__token__Kind_rcbr);
	}
	return (v__ast__SelectExpr){.branches = branches,.pos = pos,.has_exception = has_else || has_timeout,.is_expr = 0,.expected_type = 0,};
}

VV_LOCAL_SYMBOL v__ast__LockExpr v__parser__Parser_lock_expr(v__parser__Parser* p) {
	v__parser__Parser_register_auto_import(p, tos_lit("sync"));
	v__token__Position pos = v__token__Token_position(&p->tok);
	bool is_rlock = p->tok.kind == v__token__Kind_key_rlock;
	v__parser__Parser_next(p);
	array_v__ast__Ident lockeds = __new_array_with_default(0, 0, sizeof(v__ast__Ident), 0);
	for (;;) {
		if (!(p->tok.kind == v__token__Kind_name)) break;
		array_push(&lockeds, _MOV((v__ast__Ident[]){ (v__ast__Ident){
			.language = v__table__Language_v,
			.tok_kind = 0,
			.pos = v__token__Token_position(&p->tok),
			.mut_pos = {0},
			.obj = {0},
			.mod = p->mod,
			.name = p->tok.lit,
			.kind = 0,
			.info = /* sum type cast 4 */ (v__ast__IdentInfo){._313 = memdup(&(v__ast__IdentVar[]){(v__ast__IdentVar){.typ = 0,.is_mut = 0,.is_static = 0,.is_optional = 0,.share = 0,}}, sizeof(v__ast__IdentVar)), .typ = 313 /* v.ast.IdentVar */},
			.is_mut = true,
		} }));
		v__parser__Parser_next(p);
		if (p->tok.kind == v__token__Kind_lcbr) {
			break;
		}
		v__parser__Parser_check(p, v__token__Kind_comma);
	}
	array_v__ast__Stmt stmts = v__parser__Parser_parse_block(p);
	return (v__ast__LockExpr){.stmts = stmts,.is_rlock = is_rlock,.pos = pos,.lockeds = lockeds,.is_expr = 0,.typ = 0,};
}

bool v__parser__Parser_known_import(v__parser__Parser* p, string mod) {
	return _IN_MAP(mod, p->imports);
}

VV_LOCAL_SYMBOL string v__parser__Parser_prepend_mod(v__parser__Parser* p, string name) {
	if ((p->expr_mod).len != 0) {
		return string_add(string_add(p->expr_mod, tos_lit(".")), name);
	}
	if (p->builtin_mod) {
		return name;
	}
	return _STR("%.*s\000.%.*s", 2, p->mod, name);
}

VV_LOCAL_SYMBOL bool v__parser__Parser_is_used_import(v__parser__Parser* p, string alias) {
	return _IN(string, alias, p->used_imports);
}

VV_LOCAL_SYMBOL void v__parser__Parser_register_used_import(v__parser__Parser* p, string alias) {
	if (!v__parser__Parser_is_used_import(p, alias)) {
		array_push(&p->used_imports, _MOV((string[]){ string_clone(alias) }));
	}
}

VV_LOCAL_SYMBOL void v__parser__Parser_register_auto_import(v__parser__Parser* p, string alias) {
	if (!_IN_MAP(alias, p->imports)) {
		map_set(&p->imports, alias, &(string[]) { alias });
		array_push(&p->table->imports, _MOV((string[]){ string_clone(alias) }));
		v__ast__Import node = (v__ast__Import){.pos = v__token__Token_position(&p->tok),.mod = alias,.alias = alias,.syms = __new_array(0, 1, sizeof(v__ast__ImportSymbol)),};
		array_push(&p->ast_imports, _MOV((v__ast__Import[]){ node }));
	}
	v__parser__Parser_register_used_import(p, alias);
}

VV_LOCAL_SYMBOL void v__parser__Parser_check_unused_imports(v__parser__Parser* p) {
	if (p->pref->is_repl || p->pref->is_fmt) {
		return;
	}
	// FOR IN array
	array _t1204 = p->ast_imports;
	for (int _t1205 = 0; _t1205 < _t1204.len; ++_t1205) {
		v__ast__Import import_m = ((v__ast__Import*)_t1204.data)[_t1205];
		string alias = import_m.alias;
		string mod = import_m.mod;
		if (!v__parser__Parser_is_used_import(p, alias)) {
			string mod_alias = (string_eq(alias, mod) ? (alias) : (_STR("%.*s\000 (%.*s\000)", 3, alias, mod)));
			v__parser__Parser_warn_with_pos(p, _STR("module '%.*s\000' is imported but never used", 2, mod_alias), import_m.pos);
		}
	}
}

v__table__Type v__parser__Parser_parse_array_type(v__parser__Parser* p) {
	v__parser__Parser_check(p, v__token__Kind_lsbr);
	if (p->tok.kind == v__token__Kind_number) {
		int size = string_int(p->tok.lit);
		v__parser__Parser_next(p);
		v__parser__Parser_check(p, v__token__Kind_rsbr);
		v__table__Type elem_type = v__parser__Parser_parse_type(p);
		int idx = v__table__Table_find_or_register_array_fixed(p->table, elem_type, size, 1);
		return v__table__new_type(idx);
	}
	v__parser__Parser_check(p, v__token__Kind_rsbr);
	v__table__Type elem_type = v__parser__Parser_parse_type(p);
	int nr_dims = 1;
	bool not_attr = p->peek_tok.kind != v__token__Kind_name && !(p->peek_tok2.kind == v__token__Kind_semicolon || p->peek_tok2.kind == v__token__Kind_rsbr);
	for (;;) {
		if (!(p->tok.kind == v__token__Kind_lsbr && not_attr)) break;
		v__parser__Parser_next(p);
		v__parser__Parser_check(p, v__token__Kind_rsbr);
		nr_dims++;
	}
	v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(p->table, elem_type);
	int idx = v__table__Table_find_or_register_array(p->table, elem_type, nr_dims, sym->mod);
	return v__table__new_type(idx);
}

v__table__Type v__parser__Parser_parse_map_type(v__parser__Parser* p) {
	v__parser__Parser_next(p);
	if (p->tok.kind != v__token__Kind_lsbr) {
		return _const_v__table__map_type;
	}
	v__parser__Parser_check(p, v__token__Kind_lsbr);
	v__table__Type key_type = v__parser__Parser_parse_type(p);
	if (v__table__Type_idx(key_type) != _const_v__table__string_type_idx) {
		v__parser__Parser_error(p, tos_lit("maps can only have string keys for now"));
	}
	v__parser__Parser_check(p, v__token__Kind_rsbr);
	v__table__Type value_type = v__parser__Parser_parse_type(p);
	int idx = v__table__Table_find_or_register_map(p->table, key_type, value_type);
	return v__table__new_type(idx);
}

v__table__Type v__parser__Parser_parse_chan_type(v__parser__Parser* p) {
	if (p->peek_tok.kind != v__token__Kind_name && p->peek_tok.kind != v__token__Kind_key_mut && p->peek_tok.kind != v__token__Kind_amp) {
		v__parser__Parser_next(p);
		return _const_v__table__chan_type;
	}
	v__parser__Parser_register_auto_import(p, tos_lit("sync"));
	v__parser__Parser_next(p);
	bool is_mut = p->tok.kind == v__token__Kind_key_mut;
	v__table__Type elem_type = v__parser__Parser_parse_type(p);
	int idx = v__table__Table_find_or_register_chan(p->table, elem_type, is_mut);
	return v__table__new_type(idx);
}

v__table__Type v__parser__Parser_parse_multi_return_type(v__parser__Parser* p) {
	v__parser__Parser_check(p, v__token__Kind_lpar);
	array_v__table__Type mr_types = __new_array_with_default(0, 0, sizeof(v__table__Type), 0);
	for (;;) {
		v__table__Type mr_type = v__parser__Parser_parse_type(p);
		array_push(&mr_types, _MOV((v__table__Type[]){ mr_type }));
		if (p->tok.kind == v__token__Kind_comma) {
			v__parser__Parser_next(p);
		} else {
			break;
		}
	}
	v__parser__Parser_check(p, v__token__Kind_rpar);
	int idx = v__table__Table_find_or_register_multi_return(p->table, mr_types);
	return v__table__new_type(idx);
}

v__table__Type v__parser__Parser_parse_fn_type(v__parser__Parser* p, string name) {
	v__parser__Parser_check(p, v__token__Kind_key_fn);
	int line_nr = p->tok.line_nr;
	multi_return_array_v__table__Param_bool_bool mr_2342 = v__parser__Parser_fn_args(p);
	array_v__table__Param args = mr_2342.arg0;
	bool is_variadic = mr_2342.arg2;
	v__table__Type return_type = _const_v__table__void_type;
	if (p->tok.line_nr == line_nr && v__token__Kind_is_start_of_type(p->tok.kind)) {
		return_type = v__parser__Parser_parse_type(p);
	}
	v__table__TypeSymbol* ret_type_sym = v__table__Table_get_type_symbol(p->table, return_type);
	v__table__Fn func = (v__table__Fn){.params = args,.return_type = return_type,.return_type_source_name = ret_type_sym->source_name,.is_variadic = is_variadic,.language = 0,.is_generic = 0,.is_pub = 0,.is_deprecated = 0,.is_unsafe = 0,.is_placeholder = 0,.mod = (string){.str=(byteptr)""},.ctdefine = (string){.str=(byteptr)""},.attrs = __new_array(0, 1, sizeof(v__table__Attr)),.name = name,.source_fn = 0,};
	int idx = v__table__Table_find_or_register_fn_type(p->table, p->mod, func, false, false);
	return v__table__new_type(idx);
}

v__table__Type v__parser__Parser_parse_type_with_mut(v__parser__Parser* p, bool is_mut) {
	v__table__Type typ = v__parser__Parser_parse_type(p);
	if (is_mut) {
		return v__table__Type_set_nr_muls(typ, 1);
	}
	return typ;
}

v__table__Language v__parser__Parser_parse_language(v__parser__Parser* p) {
	v__table__Language language = (string_eq(p->tok.lit, tos_lit("C")) ? (v__table__Language_c) : string_eq(p->tok.lit, tos_lit("JS")) ? (v__table__Language_js) : (v__table__Language_v));
	if (language != v__table__Language_v) {
		v__parser__Parser_next(p);
		v__parser__Parser_check(p, v__token__Kind_dot);
	}
	return language;
}

v__table__Type v__parser__Parser_parse_type(v__parser__Parser* p) {
	bool is_optional = false;
	if (p->tok.kind == v__token__Kind_question) {
		int line_nr = p->tok.line_nr;
		v__parser__Parser_next(p);
		is_optional = true;
		if (p->tok.line_nr > line_nr) {
			v__table__Type typ = _const_v__table__void_type;
			if (is_optional) {
				typ = v__table__Type_set_flag(typ, v__table__TypeFlag_optional);
			}
			return typ;
		}
	}
	bool is_shared = p->tok.kind == v__token__Kind_key_shared;
	bool is_atomic = p->tok.kind == v__token__Kind_key_atomic;
	int nr_muls = 0;
	if (p->tok.kind == v__token__Kind_key_mut || is_shared || is_atomic) {
		nr_muls++;
		v__parser__Parser_next(p);
	}
	if (p->tok.kind == v__token__Kind_mul) {
		v__parser__Parser_error(p, tos_lit("use `&Type` instead of `*Type` when declaring references"));
	}
	int nr_amps = 0;
	for (;;) {
		if (!(p->tok.kind == v__token__Kind_amp)) break;
		nr_amps++;
		nr_muls++;
		v__parser__Parser_next(p);
	}
	v__table__Language language = v__parser__Parser_parse_language(p);
	v__table__Type typ = _const_v__table__void_type;
	bool is_array = p->tok.kind == v__token__Kind_lsbr;
	if (p->tok.kind != v__token__Kind_lcbr) {
		v__token__Position pos = v__token__Token_position(&p->tok);
		typ = v__parser__Parser_parse_any_type(p, language, nr_muls > 0, true);
		if (typ == _const_v__table__void_type) {
			v__parser__Parser_error_with_pos(p, tos_lit("use `?` instead of `?void`"), pos);
		}
	}
	if (is_optional) {
		typ = v__table__Type_set_flag(typ, v__table__TypeFlag_optional);
	}
	if (is_shared) {
		typ = v__table__Type_set_flag(typ, v__table__TypeFlag_shared_f);
	}
	if (is_atomic) {
		typ = v__table__Type_set_flag(typ, v__table__TypeFlag_atomic_f);
	}
	if (nr_muls > 0) {
		typ = v__table__Type_set_nr_muls(typ, nr_muls);
		if (is_array && nr_amps > 0) {
			v__parser__Parser_error(p, tos_lit("V arrays are already references behind the scenes,\nthere is no need to use a reference to an array (e.g. use `[]string` instead of `&[]string`).\nIf you need to modify an array in a function, use a mutable argument instead: `fn foo(mut s []string) {}`."));
		}
	}
	return typ;
}

v__table__Type v__parser__Parser_parse_any_type(v__parser__Parser* p, v__table__Language language, bool is_ptr, bool check_dot) {
	string name = p->tok.lit;
	if (language == v__table__Language_c) {
		name = _STR("C.%.*s", 1, name);
	} else if (language == v__table__Language_js) {
		name = _STR("JS.%.*s", 1, name);
	} else if (p->peek_tok.kind == v__token__Kind_dot && check_dot) {
		if (!v__parser__Parser_known_import(p, name)) {
			v__parser__Parser_error(p, _STR("unknown module `%.*s\000`", 2, p->tok.lit));
		}
		if (_IN_MAP(p->tok.lit, p->imports)) {
			v__parser__Parser_register_used_import(p, p->tok.lit);
		}
		v__parser__Parser_next(p);
		v__parser__Parser_check(p, v__token__Kind_dot);
		name = _STR("%.*s\000.%.*s", 2, (*(string*)map_get(p->imports, name, &(string[]){ (string){.str=(byteptr)""} })), p->tok.lit);
		if (!byte_is_capital(string_at(p->tok.lit, 0))) {
			v__parser__Parser_error(p, tos_lit("imported types must start with a capital letter"));
		}
	} else if ((p->expr_mod).len != 0 && !p->in_generic_params) {
		name = string_add(string_add(p->expr_mod, tos_lit(".")), name);
	} else if (string_ne(p->mod, tos_lit("builtin")) && name.len > 1 && !_IN_MAP(name, p->table->type_idxs)) {
		name = string_add(string_add(p->mod, tos_lit(".")), name);
	}
	v__token__Kind _t1207 = p->tok.kind;
	if (_t1207 == v__token__Kind_key_fn) {
		return v__parser__Parser_parse_fn_type(p, tos_lit(""));
	} else if (_t1207 == v__token__Kind_lsbr) {
		return v__parser__Parser_parse_array_type(p);
	} else if (_t1207 == v__token__Kind_lpar) {
		if (is_ptr) {
			v__parser__Parser_error(p, tos_lit("parse_type: unexpected `&` before multiple returns"));
		}
		return v__parser__Parser_parse_multi_return_type(p);
	} else {
		if (string_eq(name, tos_lit("map"))) {
			return v__parser__Parser_parse_map_type(p);
		}
		if (string_eq(name, tos_lit("chan"))) {
			return v__parser__Parser_parse_chan_type(p);
		}
		if ((name).len == 0) {
			v__parser__Parser_error(p, tos_lit("bad type syntax"));
		}
		string _t1208 = name;
		if (string_eq(_t1208, tos_lit("voidptr"))) {
			// Defer begin
			v__parser__Parser_next(p);
			// Defer end
			return _const_v__table__voidptr_type;
		} else if (string_eq(_t1208, tos_lit("byteptr"))) {
			// Defer begin
			v__parser__Parser_next(p);
			// Defer end
			return _const_v__table__byteptr_type;
		} else if (string_eq(_t1208, tos_lit("charptr"))) {
			// Defer begin
			v__parser__Parser_next(p);
			// Defer end
			return _const_v__table__charptr_type;
		} else if (string_eq(_t1208, tos_lit("i8"))) {
			// Defer begin
			v__parser__Parser_next(p);
			// Defer end
			return _const_v__table__i8_type;
		} else if (string_eq(_t1208, tos_lit("i16"))) {
			// Defer begin
			v__parser__Parser_next(p);
			// Defer end
			return _const_v__table__i16_type;
		} else if (string_eq(_t1208, tos_lit("int"))) {
			// Defer begin
			v__parser__Parser_next(p);
			// Defer end
			return _const_v__table__int_type;
		} else if (string_eq(_t1208, tos_lit("i64"))) {
			// Defer begin
			v__parser__Parser_next(p);
			// Defer end
			return _const_v__table__i64_type;
		} else if (string_eq(_t1208, tos_lit("byte"))) {
			// Defer begin
			v__parser__Parser_next(p);
			// Defer end
			return _const_v__table__byte_type;
		} else if (string_eq(_t1208, tos_lit("u16"))) {
			// Defer begin
			v__parser__Parser_next(p);
			// Defer end
			return _const_v__table__u16_type;
		} else if (string_eq(_t1208, tos_lit("u32"))) {
			// Defer begin
			v__parser__Parser_next(p);
			// Defer end
			return _const_v__table__u32_type;
		} else if (string_eq(_t1208, tos_lit("u64"))) {
			// Defer begin
			v__parser__Parser_next(p);
			// Defer end
			return _const_v__table__u64_type;
		} else if (string_eq(_t1208, tos_lit("f32"))) {
			// Defer begin
			v__parser__Parser_next(p);
			// Defer end
			return _const_v__table__f32_type;
		} else if (string_eq(_t1208, tos_lit("f64"))) {
			// Defer begin
			v__parser__Parser_next(p);
			// Defer end
			return _const_v__table__f64_type;
		} else if (string_eq(_t1208, tos_lit("string"))) {
			// Defer begin
			v__parser__Parser_next(p);
			// Defer end
			return _const_v__table__string_type;
		} else if (string_eq(_t1208, tos_lit("char"))) {
			// Defer begin
			v__parser__Parser_next(p);
			// Defer end
			return _const_v__table__char_type;
		} else if (string_eq(_t1208, tos_lit("bool"))) {
			// Defer begin
			v__parser__Parser_next(p);
			// Defer end
			return _const_v__table__bool_type;
		} else {
			if (name.len == 1 && byte_is_capital(string_at(name, 0))) {
				// Defer begin
				v__parser__Parser_next(p);
				// Defer end
				return v__parser__Parser_parse_generic_template_type(p, name);
			}
			if (p->peek_tok.kind == v__token__Kind_lt) {
				// Defer begin
				v__parser__Parser_next(p);
				// Defer end
				return v__parser__Parser_parse_generic_struct_inst_type(p, name);
			}
			// Defer begin
			v__parser__Parser_next(p);
			// Defer end
			return v__parser__Parser_parse_enum_or_struct_type(p, name, language);
		};
	};
	return 0;
}

v__table__Type v__parser__Parser_parse_enum_or_struct_type(v__parser__Parser* p, string name, v__table__Language language) {
	int idx = v__table__Table_find_type_idx(p->table, name);
	if (idx > 0) {
		return v__table__new_type(idx);
	}
	idx = v__table__Table_add_placeholder_type(p->table, name, language);
	return v__table__new_type(idx);
}

v__table__Type v__parser__Parser_parse_generic_template_type(v__parser__Parser* p, string name) {
	int idx = v__table__Table_find_type_idx(p->table, name);
	if (idx > 0) {
		return v__table__Type_set_flag(v__table__new_type(idx), v__table__TypeFlag_generic);
	}
	idx = v__table__Table_register_type_symbol(p->table, (v__table__TypeSymbol){.parent_idx = 0,.info = {0},.kind = v__table__Kind_any,.name = name,.source_name = name,.methods = __new_array(0, 1, sizeof(v__table__Fn)),.mod = p->mod,.is_public = true,.is_written = 0,.language = 0,});
	return v__table__Type_set_flag(v__table__new_type(idx), v__table__TypeFlag_generic);
}

v__table__Type v__parser__Parser_parse_generic_struct_inst_type(v__parser__Parser* p, string name) {
	string bs_name = name;
	v__parser__Parser_next(p);
	p->in_generic_params = true;
	bs_name = /*f*/string_add(bs_name, tos_lit("<"));
	array_v__table__Type generic_types = __new_array_with_default(0, 0, sizeof(v__table__Type), 0);
	bool is_instance = false;
	for (;;) {
		v__table__Type gt = v__parser__Parser_parse_type(p);
		if (!v__table__Type_has_flag(gt, v__table__TypeFlag_generic)) {
			is_instance = true;
		}
		v__table__TypeSymbol* gts = v__table__Table_get_type_symbol(p->table, gt);
		bs_name = /*f*/string_add(bs_name, gts->name);
		array_push(&generic_types, _MOV((v__table__Type[]){ gt }));
		if (p->tok.kind != v__token__Kind_comma) {
			break;
		}
		v__parser__Parser_next(p);
		bs_name = /*f*/string_add(bs_name, tos_lit(","));
	}
	v__parser__Parser_check(p, v__token__Kind_gt);
	p->in_generic_params = false;
	bs_name = /*f*/string_add(bs_name, tos_lit(">"));
	if (is_instance && generic_types.len > 0) {
		int gt_idx = v__table__Table_find_type_idx(p->table, bs_name);
		if (gt_idx > 0) {
			return v__table__new_type(gt_idx);
		}
		gt_idx = v__table__Table_add_placeholder_type(p->table, bs_name, v__table__Language_v);
		int parent_idx = (*(int*)map_get(p->table->type_idxs, name, &(int[]){ 0 }));
		if (parent_idx == 0) {
			parent_idx = v__table__Table_add_placeholder_type(p->table, name, v__table__Language_v);
		}
		int idx = v__table__Table_register_type_symbol(p->table, (v__table__TypeSymbol){.parent_idx = 0,.info = /* sum type cast 4 */ (v__table__TypeInfo){._154 = memdup(&(v__table__GenericStructInst[]){(v__table__GenericStructInst){.parent_idx = parent_idx,.generic_types = generic_types,}}, sizeof(v__table__GenericStructInst)), .typ = 154 /* v.table.GenericStructInst */},.kind = v__table__Kind_generic_struct_inst,.name = bs_name,.source_name = bs_name,.methods = __new_array(0, 1, sizeof(v__table__Fn)),.mod = p->mod,.is_public = 0,.is_written = 0,.language = 0,});
		return v__table__new_type(idx);
	}
	return v__parser__Parser_parse_enum_or_struct_type(p, name, v__table__Language_v);
}

v__ast__Stmt v__parser__parse_stmt(string text, v__table__Table* table, v__ast__Scope* scope) {
	v__pref__Preferences* pref = (v__pref__Preferences*)memdup(&(v__pref__Preferences){.os = 0,.backend = 0,.build_mode = 0,.output_mode = v__pref__OutputMode_stdout,.is_verbose = 0,.is_test = 0,.is_script = 0,.is_vsh = 0,.is_livemain = 0,.is_liveshared = 0,.is_shared = 0,.is_prof = 0,.profile_file = (string){.str=(byteptr)""},.profile_no_inline = 0,.translated = 0,.is_prod = 0,.obfuscate = 0,.is_repl = 0,.is_run = 0,.sanitize = 0,.is_debug = 0,.is_vlines = 0,.show_cc = 0,.show_c_output = 0,.use_cache = 0,.is_stats = 0,.no_auto_free = 0,.cflags = (string){.str=(byteptr)""},.ccompiler = (string){.str=(byteptr)""},.ccompiler_type = 0,.third_party_option = (string){.str=(byteptr)""},.building_v = 0,.autofree = 0,.compress = 0,.fast = 0,.enable_globals = 0,.is_fmt = 0,.is_vet = 0,.is_bare = 0,.no_preludes = 0,.custom_prelude = (string){.str=(byteptr)""},.lookup_path = __new_array(0, 1, sizeof(string)),.output_cross_c = 0,.prealloc = 0,.vroot = (string){.str=(byteptr)""},.out_name_c = (string){.str=(byteptr)""},.out_name = (string){.str=(byteptr)""},.display_name = (string){.str=(byteptr)""},.bundle_id = (string){.str=(byteptr)""},.path = (string){.str=(byteptr)""},.compile_defines = __new_array(0, 1, sizeof(string)),.compile_defines_all = __new_array(0, 1, sizeof(string)),.run_args = __new_array(0, 1, sizeof(string)),.printfn_list = __new_array(0, 1, sizeof(string)),.print_v_files = 0,.skip_running = 0,.skip_warnings = 0,.warns_are_errors = 0,.reuse_tmpc = 0,.use_color = 0,.is_parallel = 0,.error_limit = 0,.is_vweb = 0,.only_check_syntax = 0,.experimental = 0,.show_timings = 0,.is_ios_simulator = 0,.is_apk = 0,.cleanup_files = __new_array(0, 1, sizeof(string)),.build_options = __new_array(0, 1, sizeof(string)),.cache_manager = {0},}, sizeof(v__pref__Preferences));
	v__scanner__Scanner* s = v__scanner__new_scanner(text, v__scanner__CommentsMode_skip_comments, pref);
	v__parser__Parser p = (v__parser__Parser){.file_base = (string){.str=(byteptr)""},.file_name = (string){.str=(byteptr)""},.file_name_dir = (string){.str=(byteptr)""},.pref = pref,.scanner = s,.comments_mode = v__scanner__CommentsMode_skip_comments,.tok = {0},.prev_tok = {0},.peek_tok = {0},.peek_tok2 = {0},.peek_tok3 = {0},.table = table,.language = 0,.inside_if = 0,.inside_if_expr = 0,.inside_ct_if_expr = 0,.inside_or_expr = 0,.inside_for = 0,.inside_fn = 0,.inside_str_interp = 0,.builtin_mod = 0,.mod = (string){.str=(byteptr)""},.attrs = __new_array(0, 1, sizeof(v__table__Attr)),.expr_mod = (string){.str=(byteptr)""},.scope = scope,.global_scope = (v__ast__Scope*)memdup(&(v__ast__Scope){.objects = new_map_1(sizeof(v__ast__ScopeObject)),.struct_fields = __new_array(0, 1, sizeof(v__ast__ScopeStructField)),.parent = 0,.children = __new_array(0, 1, sizeof(v__ast__Scope*)),.start_pos = 0,.end_pos = 0,}, sizeof(v__ast__Scope)),.imports = new_map_1(sizeof(string)),.ast_imports = __new_array(0, 1, sizeof(v__ast__Import)),.used_imports = __new_array(0, 1, sizeof(string)),.is_amp = 0,.returns = 0,.inside_match = 0,.inside_select = 0,.inside_match_case = 0,.inside_match_body = 0,.inside_unsafe = 0,.is_stmt_ident = 0,.expecting_type = 0,.errors = __new_array(0, 1, sizeof(v__errors__Error)),.warnings = __new_array(0, 1, sizeof(v__errors__Warning)),.vet_errors = __new_array(0, 1, sizeof(string)),.cur_fn_name = (string){.str=(byteptr)""},.in_generic_params = 0,};
	v__parser__Parser_init_parse_fns(&p);
	v__parser__Parser_read_first_token(&p);
	return v__parser__Parser_stmt(&p, false);
}

v__ast__File v__parser__parse_text(string text, v__table__Table* b_table, v__pref__Preferences* pref, v__ast__Scope* scope, v__ast__Scope* global_scope) {
	v__scanner__Scanner* s = v__scanner__new_scanner(text, v__scanner__CommentsMode_skip_comments, pref);
	v__parser__Parser p = (v__parser__Parser){
		.file_base = (string){.str=(byteptr)""},
		.file_name = (string){.str=(byteptr)""},
		.file_name_dir = (string){.str=(byteptr)""},
		.pref = pref,
		.scanner = s,
		.comments_mode = v__scanner__CommentsMode_skip_comments,
		.tok = {0},
		.prev_tok = {0},
		.peek_tok = {0},
		.peek_tok2 = {0},
		.peek_tok3 = {0},
		.table = b_table,
		.language = 0,
		.inside_if = 0,
		.inside_if_expr = 0,
		.inside_ct_if_expr = 0,
		.inside_or_expr = 0,
		.inside_for = 0,
		.inside_fn = 0,
		.inside_str_interp = 0,
		.builtin_mod = 0,
		.mod = (string){.str=(byteptr)""},
		.attrs = __new_array(0, 1, sizeof(v__table__Attr)),
		.expr_mod = (string){.str=(byteptr)""},
		.scope = scope,
		.global_scope = global_scope,
		.imports = new_map_1(sizeof(string)),
		.ast_imports = __new_array(0, 1, sizeof(v__ast__Import)),
		.used_imports = __new_array(0, 1, sizeof(string)),
		.is_amp = 0,
		.returns = 0,
		.inside_match = 0,
		.inside_select = 0,
		.inside_match_case = 0,
		.inside_match_body = 0,
		.inside_unsafe = 0,
		.is_stmt_ident = 0,
		.expecting_type = 0,
		.errors = __new_array_with_default(0, 0, sizeof(v__errors__Error), 0),
		.warnings = __new_array_with_default(0, 0, sizeof(v__errors__Warning), 0),
		.vet_errors = __new_array(0, 1, sizeof(string)),
		.cur_fn_name = (string){.str=(byteptr)""},
		.in_generic_params = 0,
	};
	return v__parser__Parser_parse(&p);
}

v__ast__File v__parser__parse_file(string path, v__table__Table* b_table, v__scanner__CommentsMode comments_mode, v__pref__Preferences* pref, v__ast__Scope* global_scope) {
	v__parser__Parser p = (v__parser__Parser){
		.file_base = os__base(path),
		.file_name = path,
		.file_name_dir = os__dir(path),
		.pref = pref,
		.scanner = v__scanner__new_scanner_file(path, comments_mode, pref),
		.comments_mode = comments_mode,
		.tok = {0},
		.prev_tok = {0},
		.peek_tok = {0},
		.peek_tok2 = {0},
		.peek_tok3 = {0},
		.table = b_table,
		.language = 0,
		.inside_if = 0,
		.inside_if_expr = 0,
		.inside_ct_if_expr = 0,
		.inside_or_expr = 0,
		.inside_for = 0,
		.inside_fn = 0,
		.inside_str_interp = 0,
		.builtin_mod = 0,
		.mod = (string){.str=(byteptr)""},
		.attrs = __new_array(0, 1, sizeof(v__table__Attr)),
		.expr_mod = (string){.str=(byteptr)""},
		.scope = (v__ast__Scope*)memdup(&(v__ast__Scope){.objects = new_map_1(sizeof(v__ast__ScopeObject)),.struct_fields = __new_array(0, 1, sizeof(v__ast__ScopeStructField)),.parent = global_scope,.children = __new_array(0, 1, sizeof(v__ast__Scope*)),.start_pos = 0,.end_pos = 0,}, sizeof(v__ast__Scope)),
		.global_scope = global_scope,
		.imports = new_map_1(sizeof(string)),
		.ast_imports = __new_array(0, 1, sizeof(v__ast__Import)),
		.used_imports = __new_array(0, 1, sizeof(string)),
		.is_amp = 0,
		.returns = 0,
		.inside_match = 0,
		.inside_select = 0,
		.inside_match_case = 0,
		.inside_match_body = 0,
		.inside_unsafe = 0,
		.is_stmt_ident = 0,
		.expecting_type = 0,
		.errors = __new_array_with_default(0, 0, sizeof(v__errors__Error), 0),
		.warnings = __new_array_with_default(0, 0, sizeof(v__errors__Warning), 0),
		.vet_errors = __new_array(0, 1, sizeof(string)),
		.cur_fn_name = (string){.str=(byteptr)""},
		.in_generic_params = 0,
	};
	return v__parser__Parser_parse(&p);
}

multi_return_v__ast__File_array_string v__parser__parse_vet_file(string path, v__table__Table* table_, v__pref__Preferences* pref) {
	v__ast__Scope* global_scope = (v__ast__Scope*)memdup(&(v__ast__Scope){.objects = new_map_1(sizeof(v__ast__ScopeObject)),.struct_fields = __new_array(0, 1, sizeof(v__ast__ScopeStructField)),.parent = 0,.children = __new_array(0, 1, sizeof(v__ast__Scope*)),.start_pos = 0,.end_pos = 0,}, sizeof(v__ast__Scope));
	v__parser__Parser p = (v__parser__Parser){
		.file_base = os__base(path),
		.file_name = path,
		.file_name_dir = os__dir(path),
		.pref = pref,
		.scanner = v__scanner__new_vet_scanner_file(path, v__scanner__CommentsMode_parse_comments, pref),
		.comments_mode = v__scanner__CommentsMode_parse_comments,
		.tok = {0},
		.prev_tok = {0},
		.peek_tok = {0},
		.peek_tok2 = {0},
		.peek_tok3 = {0},
		.table = table_,
		.language = 0,
		.inside_if = 0,
		.inside_if_expr = 0,
		.inside_ct_if_expr = 0,
		.inside_or_expr = 0,
		.inside_for = 0,
		.inside_fn = 0,
		.inside_str_interp = 0,
		.builtin_mod = 0,
		.mod = (string){.str=(byteptr)""},
		.attrs = __new_array(0, 1, sizeof(v__table__Attr)),
		.expr_mod = (string){.str=(byteptr)""},
		.scope = (v__ast__Scope*)memdup(&(v__ast__Scope){.objects = new_map_1(sizeof(v__ast__ScopeObject)),.struct_fields = __new_array(0, 1, sizeof(v__ast__ScopeStructField)),.parent = global_scope,.children = __new_array(0, 1, sizeof(v__ast__Scope*)),.start_pos = 0,.end_pos = 0,}, sizeof(v__ast__Scope)),
		.global_scope = global_scope,
		.imports = new_map_1(sizeof(string)),
		.ast_imports = __new_array(0, 1, sizeof(v__ast__Import)),
		.used_imports = __new_array(0, 1, sizeof(string)),
		.is_amp = 0,
		.returns = 0,
		.inside_match = 0,
		.inside_select = 0,
		.inside_match_case = 0,
		.inside_match_body = 0,
		.inside_unsafe = 0,
		.is_stmt_ident = 0,
		.expecting_type = 0,
		.errors = __new_array_with_default(0, 0, sizeof(v__errors__Error), 0),
		.warnings = __new_array_with_default(0, 0, sizeof(v__errors__Warning), 0),
		.vet_errors = __new_array(0, 1, sizeof(string)),
		.cur_fn_name = (string){.str=(byteptr)""},
		.in_generic_params = 0,
	};
	if (string_contains(p.scanner->text, tos_lit("\n  "))) {
		Option_array_string _t1210 = os__read_lines(path);
		if (!_t1210.ok) {
			string err = _t1210.v_error;
			int errcode = _t1210.ecode;
			*(array_string*) _t1210.data = __new_array_with_default(0, 0, sizeof(string), 0);
		}
 		array_string source_lines = *(array_string*) _t1210.data;
		// FOR IN array
		array _t1211 = source_lines;
		for (int lnumber = 0; lnumber < _t1211.len; ++lnumber) {
			string line = ((string*)_t1211.data)[lnumber];
			if (string_starts_with(line, tos_lit("  "))) {
				v__parser__Parser_vet_error(&p, tos_lit("Looks like you are using spaces for indentation."), lnumber);
			}
		}
	}
	v__ast__File file = v__parser__Parser_parse(&p);
	_PUSH_MANY(&p.vet_errors, (p.scanner->vet_errors), _t1212, array_string);
	return (multi_return_v__ast__File_array_string){.arg0=file, .arg1=p.vet_errors};
}

v__ast__File v__parser__Parser_parse(v__parser__Parser* p) {
	v__parser__Parser_init_parse_fns(p);
	v__parser__Parser_read_first_token(p);
	array_v__ast__Stmt stmts = __new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
	for (;;) {
		if (!(p->tok.kind == v__token__Kind_comment)) break;
		array_push(&stmts, _MOV((v__ast__Stmt[]){ /* sum type cast 4 */ (v__ast__Stmt){._259 = memdup(&(v__ast__ExprStmt[]){v__parser__Parser_comment_stmt(p)}, sizeof(v__ast__ExprStmt)), .typ = 259 /* v.ast.ExprStmt */} }));
	}
	v__ast__Module module_decl = v__parser__Parser_module_decl(p);
	array_push(&stmts, _MOV((v__ast__Stmt[]){ /* sum type cast 4 */ (v__ast__Stmt){._270 = memdup(&(v__ast__Module[]){module_decl}, sizeof(v__ast__Module)), .typ = 270 /* v.ast.Module */} }));
	for (;;) {
		if (p->tok.kind == v__token__Kind_key_import) {
			array_push(&stmts, _MOV((v__ast__Stmt[]){ /* sum type cast 4 */ (v__ast__Stmt){._268 = memdup(&(v__ast__Import[]){v__parser__Parser_import_stmt(p)}, sizeof(v__ast__Import)), .typ = 268 /* v.ast.Import */} }));
			continue;
		}
		if (p->tok.kind == v__token__Kind_comment) {
			array_push(&stmts, _MOV((v__ast__Stmt[]){ /* sum type cast 4 */ (v__ast__Stmt){._259 = memdup(&(v__ast__ExprStmt[]){v__parser__Parser_comment_stmt(p)}, sizeof(v__ast__ExprStmt)), .typ = 259 /* v.ast.ExprStmt */} }));
			continue;
		}
		break;
	}
	for (;;) {
		if (p->tok.kind == v__token__Kind_eof) {
			v__parser__Parser_check_unused_imports(p);
			break;
		}
		array_push(&stmts, _MOV((v__ast__Stmt[]){ v__parser__Parser_top_stmt(p) }));
		p->attrs = __new_array_with_default(0, 0, sizeof(v__table__Attr), 0);
	}
	p->scope->end_pos = p->tok.pos;
	return (v__ast__File){
		.path = p->file_name,
		.mod = module_decl,
		.global_scope = p->global_scope,
		.scope = p->scope,
		.stmts = stmts,
		.imports = p->ast_imports,
		.errors = p->errors,
		.warnings = p->warnings,
	};
}

array_v__ast__File v__parser__parse_files(array_string paths, v__table__Table* table, v__pref__Preferences* pref, v__ast__Scope* global_scope) {
	#if defined(__APPLE__)
	{
	}
	#endif
	if (false) {
		time__sleep_ms(1);
		println(int_str(runtime__nr_cpus()));
	}
	array_v__ast__File files = __new_array_with_default(0, 0, sizeof(v__ast__File), 0);
	// FOR IN array
	array _t1218 = paths;
	for (int _t1219 = 0; _t1219 < _t1218.len; ++_t1219) {
		string path = ((string*)_t1218.data)[_t1219];
		array_push(&files, _MOV((v__ast__File[]){ v__parser__parse_file(path, table, v__scanner__CommentsMode_skip_comments, pref, global_scope) }));
	}
	return files;
}

void v__parser__Parser_init_parse_fns(v__parser__Parser* p) {
	if (p->comments_mode == v__scanner__CommentsMode_toplevel_comments) {
		v__scanner__Scanner_scan_all_tokens_in_buffer(p->scanner);
	}
}

void v__parser__Parser_read_first_token(v__parser__Parser* p) {
	v__parser__Parser_next(p);
	v__parser__Parser_next(p);
	v__parser__Parser_next(p);
	v__parser__Parser_next(p);
}

void v__parser__Parser_open_scope(v__parser__Parser* p) {
	p->scope = (v__ast__Scope*)memdup(&(v__ast__Scope){.objects = new_map_1(sizeof(v__ast__ScopeObject)),.struct_fields = __new_array(0, 1, sizeof(v__ast__ScopeStructField)),.parent = p->scope,.children = __new_array(0, 1, sizeof(v__ast__Scope*)),.start_pos = p->tok.pos,.end_pos = 0,}, sizeof(v__ast__Scope));
}

void v__parser__Parser_close_scope(v__parser__Parser* p) {
	p->scope->end_pos = p->prev_tok.pos;
	array_push(&p->scope->parent->children, _MOV((v__ast__Scope*[]){ p->scope }));
	p->scope = p->scope->parent;
}

array_v__ast__Stmt v__parser__Parser_parse_block(v__parser__Parser* p) {
	v__parser__Parser_open_scope(p);
	array_v__ast__Stmt stmts = v__parser__Parser_parse_block_no_scope(p, false);
	v__parser__Parser_close_scope(p);
	return stmts;
}

array_v__ast__Stmt v__parser__Parser_parse_block_no_scope(v__parser__Parser* p, bool is_top_level) {
	v__parser__Parser_check(p, v__token__Kind_lcbr);
	array_v__ast__Stmt stmts = __new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
	if (p->tok.kind != v__token__Kind_rcbr) {
		int c = 0;
		for (;;) {
			array_push(&stmts, _MOV((v__ast__Stmt[]){ v__parser__Parser_stmt(p, is_top_level) }));
			if ((p->tok.kind == v__token__Kind_eof || p->tok.kind == v__token__Kind_rcbr)) {
				break;
			}
			c++;
			if (c % 100000 == 0) {
				eprintln(_STR("parsed %"PRId32"\000 statements so far from fn %.*s\000 ...", 3, c, p->cur_fn_name));
			}
			if (c > 1000000) {
				v__parser__Parser_error_with_pos(p, _STR("parsed over %"PRId32"\000 statements from fn %.*s\000, the parser is probably stuck", 3, c, p->cur_fn_name), v__token__Token_position(&p->tok));
			}
		}
	}
	if (is_top_level) {
		v__parser__Parser_top_level_statement_end(p);
	}
	v__parser__Parser_check(p, v__token__Kind_rcbr);
	return stmts;
}

VV_LOCAL_SYMBOL void v__parser__Parser_next(v__parser__Parser* p) {
	p->prev_tok = p->tok;
	p->tok = p->peek_tok;
	p->peek_tok = p->peek_tok2;
	p->peek_tok2 = p->peek_tok3;
	p->peek_tok3 = v__scanner__Scanner_scan(p->scanner);
}

VV_LOCAL_SYMBOL void v__parser__Parser_check(v__parser__Parser* p, v__token__Kind expected) {
	if (p->tok.kind != expected) {
		if (p->tok.kind == v__token__Kind_name) {
			v__parser__Parser_error(p, _STR("unexpected name `%.*s\000`, expecting `%.*s\000`", 3, p->tok.lit, v__token__Kind_str(expected)));
		} else {
			v__parser__Parser_error(p, _STR("unexpected `%.*s\000`, expecting `%.*s\000`", 3, v__token__Kind_str(p->tok.kind), v__token__Kind_str(expected)));
		}
	}
	v__parser__Parser_next(p);
}

VV_LOCAL_SYMBOL string v__parser__Parser_check_js_name(v__parser__Parser* p) {
	string name = tos_lit("");
	for (;;) {
		if (!(p->peek_tok.kind == v__token__Kind_dot)) break;
		name = /*f*/string_add(name, _STR("%.*s\000.", 2, p->tok.lit));
		v__parser__Parser_next(p);
		v__parser__Parser_next(p);
	}
	name = /*f*/string_add(name, p->tok.lit);
	v__parser__Parser_next(p);
	return name;
}

VV_LOCAL_SYMBOL string v__parser__Parser_check_name(v__parser__Parser* p) {
	string name = p->tok.lit;
	if (p->peek_tok.kind == v__token__Kind_dot && _IN_MAP(name, p->imports)) {
		v__parser__Parser_register_used_import(p, name);
	}
	v__parser__Parser_check(p, v__token__Kind_name);
	return name;
}

v__ast__Stmt v__parser__Parser_top_stmt(v__parser__Parser* p) {
	#if defined(CUSTOM_DEFINE_trace_parser)
	{
	}
	#endif
	for (;;) {
		v__token__Kind _t1223 = p->tok.kind;
		if (_t1223 == v__token__Kind_key_pub) {
			v__token__Kind _t1224 = p->peek_tok.kind;
			if (_t1224 == v__token__Kind_key_const) {
				return /* sum type cast 4 */ (v__ast__Stmt){._256 = memdup(&(v__ast__ConstDecl[]){v__parser__Parser_const_decl(p)}, sizeof(v__ast__ConstDecl)), .typ = 256 /* v.ast.ConstDecl */};
			} else if (_t1224 == v__token__Kind_key_fn) {
				return /* sum type cast 4 */ (v__ast__Stmt){._151 = memdup(&(v__ast__FnDecl[]){v__parser__Parser_fn_decl(p)}, sizeof(v__ast__FnDecl)), .typ = 151 /* v.ast.FnDecl */};
			} else if (_t1224 == v__token__Kind_key_struct || _t1224 == v__token__Kind_key_union) {
				return /* sum type cast 4 */ (v__ast__Stmt){._273 = memdup(&(v__ast__StructDecl[]){v__parser__Parser_struct_decl(p)}, sizeof(v__ast__StructDecl)), .typ = 273 /* v.ast.StructDecl */};
			} else if (_t1224 == v__token__Kind_key_interface) {
				return /* sum type cast 4 */ (v__ast__Stmt){._269 = memdup(&(v__ast__InterfaceDecl[]){v__parser__Parser_interface_decl(p)}, sizeof(v__ast__InterfaceDecl)), .typ = 269 /* v.ast.InterfaceDecl */};
			} else if (_t1224 == v__token__Kind_key_enum) {
				return /* sum type cast 4 */ (v__ast__Stmt){._258 = memdup(&(v__ast__EnumDecl[]){v__parser__Parser_enum_decl(p)}, sizeof(v__ast__EnumDecl)), .typ = 258 /* v.ast.EnumDecl */};
			} else if (_t1224 == v__token__Kind_key_type) {
				return /* sum type cast 4 */ (v__ast__Stmt){._207 = memdup(&(v__ast__TypeDecl[]){v__parser__Parser_type_decl(p)}, sizeof(v__ast__TypeDecl)), .typ = 207 /* v.ast.TypeDecl */};
			} else {
				v__parser__Parser_error(p, tos_lit("wrong pub keyword usage"));
				return (v__ast__Stmt){
#ifndef __cplusplus
0
#endif
};
			};
		} else if (_t1223 == v__token__Kind_lsbr) {
			v__parser__Parser_attributes(p);
			continue;
		} else if (_t1223 == v__token__Kind_key_interface) {
			return /* sum type cast 4 */ (v__ast__Stmt){._269 = memdup(&(v__ast__InterfaceDecl[]){v__parser__Parser_interface_decl(p)}, sizeof(v__ast__InterfaceDecl)), .typ = 269 /* v.ast.InterfaceDecl */};
		} else if (_t1223 == v__token__Kind_key_import) {
			v__parser__Parser_error_with_pos(p, tos_lit("`import x` can only be declared at the beginning of the file"), v__token__Token_position(&p->tok));
			return /* sum type cast 4 */ (v__ast__Stmt){._268 = memdup(&(v__ast__Import[]){v__parser__Parser_import_stmt(p)}, sizeof(v__ast__Import)), .typ = 268 /* v.ast.Import */};
		} else if (_t1223 == v__token__Kind_key_global) {
			return /* sum type cast 4 */ (v__ast__Stmt){._263 = memdup(&(v__ast__GlobalDecl[]){v__parser__Parser_global_decl(p)}, sizeof(v__ast__GlobalDecl)), .typ = 263 /* v.ast.GlobalDecl */};
		} else if (_t1223 == v__token__Kind_key_const) {
			return /* sum type cast 4 */ (v__ast__Stmt){._256 = memdup(&(v__ast__ConstDecl[]){v__parser__Parser_const_decl(p)}, sizeof(v__ast__ConstDecl)), .typ = 256 /* v.ast.ConstDecl */};
		} else if (_t1223 == v__token__Kind_key_fn) {
			return /* sum type cast 4 */ (v__ast__Stmt){._151 = memdup(&(v__ast__FnDecl[]){v__parser__Parser_fn_decl(p)}, sizeof(v__ast__FnDecl)), .typ = 151 /* v.ast.FnDecl */};
		} else if (_t1223 == v__token__Kind_key_struct) {
			return /* sum type cast 4 */ (v__ast__Stmt){._273 = memdup(&(v__ast__StructDecl[]){v__parser__Parser_struct_decl(p)}, sizeof(v__ast__StructDecl)), .typ = 273 /* v.ast.StructDecl */};
		} else if (_t1223 == v__token__Kind_dollar) {
			return /* sum type cast 4 */ (v__ast__Stmt){._259 = memdup(&(v__ast__ExprStmt[]){(v__ast__ExprStmt){.expr = /* sum type cast 4 */ (v__ast__Expr){._225 = memdup(&(v__ast__IfExpr[]){v__parser__Parser_if_expr(p, true)}, sizeof(v__ast__IfExpr)), .typ = 225 /* v.ast.IfExpr */},.pos = {0},.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.is_expr = 0,.typ = 0,}}, sizeof(v__ast__ExprStmt)), .typ = 259 /* v.ast.ExprStmt */};
		} else if (_t1223 == v__token__Kind_hash) {
			return /* sum type cast 4 */ (v__ast__Stmt){._267 = memdup(&(v__ast__HashStmt[]){v__parser__Parser_hash(p)}, sizeof(v__ast__HashStmt)), .typ = 267 /* v.ast.HashStmt */};
		} else if (_t1223 == v__token__Kind_key_type) {
			return /* sum type cast 4 */ (v__ast__Stmt){._207 = memdup(&(v__ast__TypeDecl[]){v__parser__Parser_type_decl(p)}, sizeof(v__ast__TypeDecl)), .typ = 207 /* v.ast.TypeDecl */};
		} else if (_t1223 == v__token__Kind_key_enum) {
			return /* sum type cast 4 */ (v__ast__Stmt){._258 = memdup(&(v__ast__EnumDecl[]){v__parser__Parser_enum_decl(p)}, sizeof(v__ast__EnumDecl)), .typ = 258 /* v.ast.EnumDecl */};
		} else if (_t1223 == v__token__Kind_key_union) {
			return /* sum type cast 4 */ (v__ast__Stmt){._273 = memdup(&(v__ast__StructDecl[]){v__parser__Parser_struct_decl(p)}, sizeof(v__ast__StructDecl)), .typ = 273 /* v.ast.StructDecl */};
		} else if (_t1223 == v__token__Kind_comment) {
			return /* sum type cast 4 */ (v__ast__Stmt){._259 = memdup(&(v__ast__ExprStmt[]){v__parser__Parser_comment_stmt(p)}, sizeof(v__ast__ExprStmt)), .typ = 259 /* v.ast.ExprStmt */};
		} else {
			if (p->pref->is_script && !p->pref->is_test) {
				array_v__ast__Stmt stmts = __new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
				for (;;) {
					if (!(p->tok.kind != v__token__Kind_eof)) break;
					array_push(&stmts, _MOV((v__ast__Stmt[]){ v__parser__Parser_stmt(p, false) }));
				}
				return /* sum type cast 4 */ (v__ast__Stmt){._151 = memdup(&(v__ast__FnDecl[]){(v__ast__FnDecl){.name = tos_lit("main.main"),.mod = tos_lit("main"),.params = __new_array(0, 1, sizeof(v__table__Param)),.is_deprecated = 0,.is_pub = 0,.is_variadic = 0,.is_anon = 0,.receiver = {0},.receiver_pos = {0},.is_method = 0,.method_idx = 0,.rec_mut = 0,.rec_share = 0,.language = 0,.no_body = 0,.is_builtin = 0,.pos = {0},.body_pos = {0},.file = p->file_name,.is_generic = 0,.is_direct_arr = 0,.attrs = __new_array(0, 1, sizeof(v__table__Attr)),.stmts = stmts,.return_type = _const_v__table__void_type,.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.source_file = 0,}}, sizeof(v__ast__FnDecl)), .typ = 151 /* v.ast.FnDecl */};
			} else if (p->pref->is_fmt) {
				return v__parser__Parser_stmt(p, false);
			} else {
				v__parser__Parser_error(p, string_add(tos_lit("bad top level statement "), v__token__Token_str(p->tok)));
				return (v__ast__Stmt){
#ifndef __cplusplus
0
#endif
};
			}
		};
	}
	return (v__ast__Stmt){
#ifndef __cplusplus
0
#endif
};
}

v__ast__Comment v__parser__Parser_check_comment(v__parser__Parser* p) {
	if (p->tok.kind == v__token__Kind_comment) {
		return v__parser__Parser_comment(p);
	}
	return (v__ast__Comment){.text = (string){.str=(byteptr)""},.is_multi = 0,.line_nr = 0,.pos = {0},};
}

v__ast__Comment v__parser__Parser_comment(v__parser__Parser* p) {
	v__token__Position pos = v__token__Token_position(&p->tok);
	string text = p->tok.lit;
	v__parser__Parser_next(p);
	return (v__ast__Comment){.text = text,.is_multi = string_contains(text, tos_lit("\n")),.line_nr = 0,.pos = pos,};
}

v__ast__ExprStmt v__parser__Parser_comment_stmt(v__parser__Parser* p) {
	v__ast__Comment comment = v__parser__Parser_comment(p);
	return (v__ast__ExprStmt){.expr = /* sum type cast 4 */ (v__ast__Expr){._219 = memdup(&(v__ast__Comment[]){comment}, sizeof(v__ast__Comment)), .typ = 219 /* v.ast.Comment */},.pos = comment.pos,.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.is_expr = 0,.typ = 0,};
}

array_v__ast__Comment v__parser__Parser_eat_comments(v__parser__Parser* p) {
	array_v__ast__Comment comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	for (;;) {
		if (p->tok.kind != v__token__Kind_comment) {
			break;
		}
		array_push(&comments, _MOV((v__ast__Comment[]){ v__parser__Parser_comment(p) }));
	}
	return comments;
}

array_v__ast__Comment v__parser__Parser_eat_lineend_comments(v__parser__Parser* p) {
	array_v__ast__Comment comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	for (;;) {
		if (p->tok.kind != v__token__Kind_comment || p->tok.line_nr != p->prev_tok.line_nr) {
			break;
		}
		array_push(&comments, _MOV((v__ast__Comment[]){ v__parser__Parser_comment(p) }));
	}
	return comments;
}

v__ast__Stmt v__parser__Parser_stmt(v__parser__Parser* p, bool is_top_level) {
	#if defined(CUSTOM_DEFINE_trace_parser)
	{
	}
	#endif
	p->is_stmt_ident = p->tok.kind == v__token__Kind_name;
	v__token__Kind _t1228 = p->tok.kind;
	if (_t1228 == v__token__Kind_lcbr) {
		v__token__Position pos = v__token__Token_position(&p->tok);
		array_v__ast__Stmt stmts = v__parser__Parser_parse_block(p);
		return /* sum type cast 4 */ (v__ast__Stmt){._253 = memdup(&(v__ast__Block[]){(v__ast__Block){.stmts = stmts,.is_unsafe = 0,.pos = pos,}}, sizeof(v__ast__Block)), .typ = 253 /* v.ast.Block */};
	} else if (_t1228 == v__token__Kind_key_assert) {
		v__parser__Parser_next(p);
		v__token__Position assert_pos = v__token__Token_position(&p->tok);
		v__ast__Expr expr = v__parser__Parser_expr(p, 0);
		return /* sum type cast 4 */ (v__ast__Stmt){._251 = memdup(&(v__ast__AssertStmt[]){(v__ast__AssertStmt){.pos = assert_pos,.expr = expr,}}, sizeof(v__ast__AssertStmt)), .typ = 251 /* v.ast.AssertStmt */};
	} else if (_t1228 == v__token__Kind_key_for) {
		return v__parser__Parser_for_stmt(p);
	} else if (_t1228 == v__token__Kind_name || _t1228 == v__token__Kind_key_mut || _t1228 == v__token__Kind_key_shared || _t1228 == v__token__Kind_key_atomic || _t1228 == v__token__Kind_key_static || _t1228 == v__token__Kind_mul) {
		if (p->tok.kind == v__token__Kind_name) {
			if (string_eq(p->tok.lit, tos_lit("sql"))) {
				return /* sum type cast 4 */ (v__ast__Stmt){._272 = memdup(&(v__ast__SqlStmt[]){v__parser__Parser_sql_stmt(p)}, sizeof(v__ast__SqlStmt)), .typ = 272 /* v.ast.SqlStmt */};
			}
			if (p->peek_tok.kind == v__token__Kind_colon) {
				v__token__Position spos = v__token__Token_position(&p->tok);
				string name = v__parser__Parser_check_name(p);
				v__parser__Parser_next(p);
				if (p->tok.kind == v__token__Kind_key_for) {
					v__ast__Stmt stmt = v__parser__Parser_stmt(p, is_top_level);
					v__ast__Stmt _t1229 = stmt;
					if (_t1229.typ == 262 /* v.ast.ForStmt */) {
						(*stmt._262).label = name;
						return stmt;
					} else if (_t1229.typ == 261 /* v.ast.ForInStmt */) {
						(*stmt._261).label = name;
						return stmt;
					} else if (_t1229.typ == 260 /* v.ast.ForCStmt */) {
						(*stmt._260).label = name;
						return stmt;
					} else {
						// assert
						if (false) {} else {
							VAssertMetaInfo v_assert_meta_info__t1230;
							memset(&v_assert_meta_info__t1230, 0, sizeof(VAssertMetaInfo));
							v_assert_meta_info__t1230.fpath = tos_lit("/tmp/gen_vc/v/vlib/v/parser/parser.v");
							v_assert_meta_info__t1230.line_nr = 618;
							v_assert_meta_info__t1230.fn_name = tos_lit("stmt");
							v_assert_meta_info__t1230.src = tos_lit("false");
							__print_assert_failure(&v_assert_meta_info__t1230);
							v_panic(tos_lit("Assertion failed..."));
							exit(1);
						}
					};
				}
				return /* sum type cast 4 */ (v__ast__Stmt){._265 = memdup(&(v__ast__GotoLabel[]){(v__ast__GotoLabel){.name = name,.pos = v__token__Position_extend(spos, v__token__Token_position(&p->tok)),}}, sizeof(v__ast__GotoLabel)), .typ = 265 /* v.ast.GotoLabel */};
			} else if (p->peek_tok.kind == v__token__Kind_name) {
				v__parser__Parser_error_with_pos(p, _STR("unexpected name `%.*s\000`", 2, p->peek_tok.lit), v__token__Token_position(&p->peek_tok));
			} else if (!p->inside_if_expr && !p->inside_match_body && !p->inside_or_expr && (p->peek_tok.kind == v__token__Kind_rcbr || p->peek_tok.kind == v__token__Kind_eof)) {
				v__parser__Parser_error_with_pos(p, _STR("`%.*s\000` evaluated but not used", 2, p->tok.lit), v__token__Token_position(&p->tok));
			}
		}
		return v__parser__Parser_parse_multi_expr(p, is_top_level);
	} else if (_t1228 == v__token__Kind_comment) {
		return /* sum type cast 4 */ (v__ast__Stmt){._259 = memdup(&(v__ast__ExprStmt[]){v__parser__Parser_comment_stmt(p)}, sizeof(v__ast__ExprStmt)), .typ = 259 /* v.ast.ExprStmt */};
	} else if (_t1228 == v__token__Kind_key_return) {
		return /* sum type cast 4 */ (v__ast__Stmt){._271 = memdup(&(v__ast__Return[]){v__parser__Parser_return_stmt(p)}, sizeof(v__ast__Return)), .typ = 271 /* v.ast.Return */};
	} else if (_t1228 == v__token__Kind_dollar) {
		if (p->peek_tok.kind == v__token__Kind_key_if) {
			return /* sum type cast 4 */ (v__ast__Stmt){._259 = memdup(&(v__ast__ExprStmt[]){(v__ast__ExprStmt){.expr = /* sum type cast 4 */ (v__ast__Expr){._225 = memdup(&(v__ast__IfExpr[]){v__parser__Parser_if_expr(p, true)}, sizeof(v__ast__IfExpr)), .typ = 225 /* v.ast.IfExpr */},.pos = {0},.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.is_expr = 0,.typ = 0,}}, sizeof(v__ast__ExprStmt)), .typ = 259 /* v.ast.ExprStmt */};
		} else if (p->peek_tok.kind == v__token__Kind_key_for) {
			return /* sum type cast 4 */ (v__ast__Stmt){._255 = memdup(&(v__ast__CompFor[]){v__parser__Parser_comp_for(p)}, sizeof(v__ast__CompFor)), .typ = 255 /* v.ast.CompFor */};
		} else if (p->peek_tok.kind == v__token__Kind_name) {
			return /* sum type cast 4 */ (v__ast__Stmt){._259 = memdup(&(v__ast__ExprStmt[]){(v__ast__ExprStmt){.expr = /* sum type cast 4 */ (v__ast__Expr){._220 = memdup(&(v__ast__ComptimeCall[]){v__parser__Parser_vweb(p)}, sizeof(v__ast__ComptimeCall)), .typ = 220 /* v.ast.ComptimeCall */},.pos = {0},.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.is_expr = 0,.typ = 0,}}, sizeof(v__ast__ExprStmt)), .typ = 259 /* v.ast.ExprStmt */};
		}
		v__parser__Parser_error_with_pos(p, tos_lit("unexpected $"), v__token__Token_position(&p->tok));
		return (v__ast__Stmt){
#ifndef __cplusplus
0
#endif
};
	} else if (_t1228 == v__token__Kind_key_continue || _t1228 == v__token__Kind_key_break) {
		v__token__Token tok = p->tok;
		int line = p->tok.line_nr;
		v__parser__Parser_next(p);
		string label = tos_lit("");
		if (p->tok.line_nr == line && p->tok.kind == v__token__Kind_name) {
			label = v__parser__Parser_check_name(p);
		}
		return /* sum type cast 4 */ (v__ast__Stmt){._254 = memdup(&(v__ast__BranchStmt[]){(v__ast__BranchStmt){.kind = tok.kind,.label = label,.pos = v__token__Token_position(&tok),}}, sizeof(v__ast__BranchStmt)), .typ = 254 /* v.ast.BranchStmt */};
	} else if (_t1228 == v__token__Kind_key_unsafe) {
		return v__parser__Parser_unsafe_stmt(p);
	} else if (_t1228 == v__token__Kind_hash) {
		return /* sum type cast 4 */ (v__ast__Stmt){._267 = memdup(&(v__ast__HashStmt[]){v__parser__Parser_hash(p)}, sizeof(v__ast__HashStmt)), .typ = 267 /* v.ast.HashStmt */};
	} else if (_t1228 == v__token__Kind_key_defer) {
		v__parser__Parser_next(p);
		v__token__Position spos = v__token__Token_position(&p->tok);
		array_v__ast__Stmt stmts = v__parser__Parser_parse_block(p);
		return /* sum type cast 4 */ (v__ast__Stmt){._257 = memdup(&(v__ast__DeferStmt[]){(v__ast__DeferStmt){.stmts = stmts,.pos = v__token__Position_extend(spos, v__token__Token_position(&p->tok)),.ifdef = (string){.str=(byteptr)""},}}, sizeof(v__ast__DeferStmt)), .typ = 257 /* v.ast.DeferStmt */};
	} else if (_t1228 == v__token__Kind_key_go) {
		v__parser__Parser_next(p);
		v__token__Position spos = v__token__Token_position(&p->tok);
		v__ast__Expr expr = v__parser__Parser_expr(p, 0);
		return /* sum type cast 4 */ (v__ast__Stmt){._264 = memdup(&(v__ast__GoStmt[]){(v__ast__GoStmt){.call_expr = expr,.pos = v__token__Position_extend(spos, v__token__Token_position(&p->tok)),}}, sizeof(v__ast__GoStmt)), .typ = 264 /* v.ast.GoStmt */};
	} else if (_t1228 == v__token__Kind_key_goto) {
		v__parser__Parser_next(p);
		v__token__Position spos = v__token__Token_position(&p->tok);
		string name = v__parser__Parser_check_name(p);
		return /* sum type cast 4 */ (v__ast__Stmt){._266 = memdup(&(v__ast__GotoStmt[]){(v__ast__GotoStmt){.name = name,.pos = spos,}}, sizeof(v__ast__GotoStmt)), .typ = 266 /* v.ast.GotoStmt */};
	} else if (_t1228 == v__token__Kind_key_const) {
		v__parser__Parser_error_with_pos(p, tos_lit("const can only be defined at the top level (outside of functions)"), v__token__Token_position(&p->tok));
		return (v__ast__Stmt){
#ifndef __cplusplus
0
#endif
};
	} else {
		return v__parser__Parser_parse_multi_expr(p, is_top_level);
	};
	return (v__ast__Stmt){0};
}

VV_LOCAL_SYMBOL multi_return_array_v__ast__Expr_array_v__ast__Comment v__parser__Parser_expr_list(v__parser__Parser* p) {
	array_v__ast__Expr exprs = __new_array_with_default(0, 0, sizeof(v__ast__Expr), 0);
	array_v__ast__Comment comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	for (;;) {
		v__ast__Expr expr = v__parser__Parser_expr(p, 0);
		if ((expr).typ == 219 /* v.ast.Comment */) {
			array_push(&comments, _MOV((v__ast__Comment[]){ (*expr._219) }));
		} else {
			array_push(&exprs, _MOV((v__ast__Expr[]){ expr }));
			if (p->tok.kind != v__token__Kind_comma) {
				break;
			}
			v__parser__Parser_next(p);
		}
	}
	return (multi_return_array_v__ast__Expr_array_v__ast__Comment){.arg0=exprs, .arg1=comments};
}

VV_LOCAL_SYMBOL void v__parser__Parser_attributes(v__parser__Parser* p) {
	v__parser__Parser_check(p, v__token__Kind_lsbr);
	bool has_ctdefine = false;
	for (;;) {
		if (!(p->tok.kind != v__token__Kind_rsbr)) break;
		v__token__Position start_pos = v__token__Token_position(&p->tok);
		v__table__Attr attr = v__parser__Parser_parse_attr(p);
		if (array_v__table__Attr_contains(p->attrs, attr.name)) {
			v__parser__Parser_error_with_pos(p, _STR("duplicate attribute `%.*s\000`", 2, attr.name), v__token__Position_extend(start_pos, v__token__Token_position(&p->prev_tok)));
		}
		if (attr.is_ctdefine) {
			if (has_ctdefine) {
				v__parser__Parser_error_with_pos(p, _STR("only one `[if flag]` may be applied at a time `%.*s\000`", 2, attr.name), v__token__Position_extend(start_pos, v__token__Token_position(&p->prev_tok)));
			} else {
				has_ctdefine = true;
			}
		}
		array_push(&p->attrs, _MOV((v__table__Attr[]){ attr }));
		if (p->tok.kind != v__token__Kind_semicolon) {
			if (p->tok.kind == v__token__Kind_rsbr) {
				v__parser__Parser_next(p);
				break;
			}
			v__parser__Parser_error(p, _STR("unexpected `%.*s\000`, expecting `;`", 2, v__token__Kind_str(p->tok.kind)));
		}
		v__parser__Parser_next(p);
	}
	if (p->attrs.len == 0) {
		v__parser__Parser_error_with_pos(p, tos_lit("attributes cannot be empty"), v__token__Position_extend(v__token__Token_position(&p->prev_tok), v__token__Token_position(&p->tok)));
	}
}

VV_LOCAL_SYMBOL v__table__Attr v__parser__Parser_parse_attr(v__parser__Parser* p) {
	if (p->tok.kind == v__token__Kind_key_unsafe) {
		v__parser__Parser_next(p);
		return (v__table__Attr){.name = tos_lit("unsafe"),.is_string = 0,.is_ctdefine = 0,.arg = (string){.str=(byteptr)""},.is_string_arg = 0,};
	}
	bool is_ctdefine = false;
	if (p->tok.kind == v__token__Kind_key_if) {
		v__parser__Parser_next(p);
		is_ctdefine = true;
	}
	string name = tos_lit("");
	string arg = tos_lit("");
	bool is_string = p->tok.kind == v__token__Kind_string;
	bool is_string_arg = false;
	if (is_string) {
		name = p->tok.lit;
		v__parser__Parser_next(p);
	} else {
		name = v__parser__Parser_check_name(p);
		if (string_eq(name, tos_lit("unsafe_fn"))) {
			v__parser__Parser_error_with_pos(p, tos_lit("please use `[unsafe]` instead"), v__token__Token_position(&p->tok));
		} else if (string_eq(name, tos_lit("trusted_fn"))) {
			v__parser__Parser_error_with_pos(p, tos_lit("please use `[trusted]` instead"), v__token__Token_position(&p->tok));
		}
		if (p->tok.kind == v__token__Kind_colon) {
			v__parser__Parser_next(p);
			if (p->tok.kind == v__token__Kind_name) {
				arg = v__parser__Parser_check_name(p);
			} else if (p->tok.kind == v__token__Kind_string) {
				arg = p->tok.lit;
				is_string_arg = true;
				v__parser__Parser_next(p);
			}
		}
	}
	return (v__table__Attr){.name = name,.is_string = is_string,.is_ctdefine = is_ctdefine,.arg = arg,.is_string_arg = is_string_arg,};
}

void v__parser__Parser_error(v__parser__Parser* p, string s) {
	v__parser__Parser_error_with_pos(p, s, v__token__Token_position(&p->tok));
}

void v__parser__Parser_warn(v__parser__Parser* p, string s) {
	v__parser__Parser_warn_with_pos(p, s, v__token__Token_position(&p->tok));
}

void v__parser__Parser_error_with_pos(v__parser__Parser* p, string s, v__token__Position pos) {
	string kind = tos_lit("error:");
	if (p->pref->output_mode == v__pref__OutputMode_stdout) {
		if (p->pref->is_verbose) {
			print_backtrace();
			kind = tos_lit("parser error:");
		}
		string ferror = v__util__formatted_error(kind, s, p->file_name, pos);
		eprintln(ferror);
		v_exit(1);
	} else {
		array_push(&p->errors, _MOV((v__errors__Error[]){ (v__errors__Error){.message = s,.details = (string){.str=(byteptr)""},.file_path = p->file_name,.pos = pos,.backtrace = (string){.str=(byteptr)""},.reporter = v__errors__Reporter_parser,} }));
	}
	if (p->pref->output_mode == v__pref__OutputMode_silent) {
		v__parser__Parser_next(p);
	}
}

void v__parser__Parser_warn_with_pos(v__parser__Parser* p, string s, v__token__Position pos) {
	if (p->pref->warns_are_errors) {
		v__parser__Parser_error_with_pos(p, s, pos);
		return;
	}
	if (p->pref->skip_warnings) {
		return;
	}
	if (p->pref->output_mode == v__pref__OutputMode_stdout) {
		string ferror = v__util__formatted_error(tos_lit("warning:"), s, p->file_name, pos);
		eprintln(ferror);
	} else {
		array_push(&p->warnings, _MOV((v__errors__Warning[]){ (v__errors__Warning){.message = s,.details = (string){.str=(byteptr)""},.file_path = p->file_name,.pos = pos,.reporter = v__errors__Reporter_parser,} }));
	}
}

void v__parser__Parser_vet_error(v__parser__Parser* p, string s, int line) {
	array_push(&p->vet_errors, _MOV((string[]){ string_clone(_STR("%.*s\000:%"PRId32"\000: %.*s", 3, p->scanner->file_path, line + 1, s)) }));
}

VV_LOCAL_SYMBOL v__ast__Stmt v__parser__Parser_parse_multi_expr(v__parser__Parser* p, bool is_top_level) {
	v__token__Token tok = p->tok;
	multi_return_array_v__ast__Expr_array_v__ast__Comment mr_20772 = v__parser__Parser_expr_list(p);
	array_v__ast__Expr left = mr_20772.arg0;
	array_v__ast__Comment left_comments = mr_20772.arg1;
	v__ast__Expr left0 = (*(v__ast__Expr*)/*ee elem_typ */array_get(left, 0));
	if (tok.kind == v__token__Kind_key_mut && p->tok.kind != v__token__Kind_decl_assign) {
		v__parser__Parser_error(p, tos_lit("expecting `:=` (e.g. `mut x :=`)"));
	}
	if ((p->tok.kind == v__token__Kind_assign || p->tok.kind == v__token__Kind_decl_assign) || v__token__Kind_is_assign(p->tok.kind)) {
		return v__parser__Parser_partial_assign_stmt(p, left, left_comments);
	} else if (!(tok.kind == v__token__Kind_key_if || tok.kind == v__token__Kind_key_match || tok.kind == v__token__Kind_key_lock || tok.kind == v__token__Kind_key_rlock || tok.kind == v__token__Kind_key_select) && (left0).typ != 215 /* v.ast.CallExpr */ && (is_top_level || p->tok.kind != v__token__Kind_rcbr) && (left0).typ != 237 /* v.ast.PostfixExpr */ && !((left0).typ == 228 /* v.ast.InfixExpr */ && ((/* as */ *(v__ast__InfixExpr*)__as_cast((left0)._228, (left0).typ, /*expected:*/228)).op == v__token__Kind_left_shift || (/* as */ *(v__ast__InfixExpr*)__as_cast((left0)._228, (left0).typ, /*expected:*/228)).op == v__token__Kind_arrow)) && (left0).typ != 220 /* v.ast.ComptimeCall */) {
		v__parser__Parser_error_with_pos(p, tos_lit("expression evaluated but not used"), v__ast__Expr_position(left0));
	}
	if (left.len == 1) {
		return /* sum type cast 4 */ (v__ast__Stmt){._259 = memdup(&(v__ast__ExprStmt[]){(v__ast__ExprStmt){.expr = left0,.pos = v__token__Token_position(&tok),.comments = left_comments,.is_expr = p->inside_for,.typ = 0,}}, sizeof(v__ast__ExprStmt)), .typ = 259 /* v.ast.ExprStmt */};
	}
	return /* sum type cast 4 */ (v__ast__Stmt){._259 = memdup(&(v__ast__ExprStmt[]){(v__ast__ExprStmt){.expr = /* sum type cast 4 */ (v__ast__Expr){._221 = memdup(&(v__ast__ConcatExpr[]){(v__ast__ConcatExpr){.vals = left,.pos = v__token__Token_position(&tok),.return_type = 0,}}, sizeof(v__ast__ConcatExpr)), .typ = 221 /* v.ast.ConcatExpr */},.pos = v__token__Token_position(&tok),.comments = left_comments,.is_expr = 0,.typ = 0,}}, sizeof(v__ast__ExprStmt)), .typ = 259 /* v.ast.ExprStmt */};
}

v__ast__Ident v__parser__Parser_parse_ident(v__parser__Parser* p, v__table__Language language) {
	bool is_shared = p->tok.kind == v__token__Kind_key_shared;
	bool is_atomic = p->tok.kind == v__token__Kind_key_atomic;
	v__token__Position mut_pos = v__token__Token_position(&p->tok);
	bool is_mut = p->tok.kind == v__token__Kind_key_mut || is_shared || is_atomic;
	if (is_mut) {
		v__parser__Parser_next(p);
	}
	bool is_static = p->tok.kind == v__token__Kind_key_static;
	if (is_static) {
		v__parser__Parser_next(p);
	}
	if (p->tok.kind == v__token__Kind_name) {
		v__token__Position pos = v__token__Token_position(&p->tok);
		string name = v__parser__Parser_check_name(p);
		if (string_eq(name, tos_lit("_"))) {
			return (v__ast__Ident){.language = 0,.tok_kind = p->tok.kind,.pos = pos,.mut_pos = {0},.obj = {0},.mod = (string){.str=(byteptr)""},.name = tos_lit("_"),.kind = v__ast__IdentKind_blank_ident,.info = /* sum type cast 4 */ (v__ast__IdentInfo){._313 = memdup(&(v__ast__IdentVar[]){(v__ast__IdentVar){.typ = 0,.is_mut = false,.is_static = false,.is_optional = 0,.share = 0,}}, sizeof(v__ast__IdentVar)), .typ = 313 /* v.ast.IdentVar */},.is_mut = 0,};
		}
		if (p->inside_match_body && string_eq(name, tos_lit("it"))) {
		}
		if (p->expr_mod.len > 0) {
			name = _STR("%.*s\000.%.*s", 2, p->expr_mod, name);
		}
		return (v__ast__Ident){
			.language = language,
			.tok_kind = p->tok.kind,
			.pos = pos,
			.mut_pos = mut_pos,
			.obj = {0},
			.mod = p->mod,
			.name = name,
			.kind = v__ast__IdentKind_unresolved,
			.info = /* sum type cast 4 */ (v__ast__IdentInfo){._313 = memdup(&(v__ast__IdentVar[]){(v__ast__IdentVar){.typ = 0,.is_mut = is_mut,.is_static = is_static,.is_optional = 0,.share = v__table__sharetype_from_flags(is_shared, is_atomic),}}, sizeof(v__ast__IdentVar)), .typ = 313 /* v.ast.IdentVar */},
			.is_mut = is_mut,
		};
	} else {
		v__parser__Parser_error(p, _STR("unexpected token `%.*s\000`", 2, p->tok.lit));
	}
	return (v__ast__Ident){.language = 0,.tok_kind = 0,.pos = {0},.mut_pos = {0},.obj = {0},.mod = (string){.str=(byteptr)""},.name = (string){.str=(byteptr)""},.kind = 0,.info = {0},.is_mut = 0,};
}

v__ast__Expr v__parser__Parser_name_expr(v__parser__Parser* p) {
	v__token__Kind prev_tok_kind = p->prev_tok.kind;
	v__ast__Expr node = (v__ast__Expr){
#ifndef __cplusplus
0
#endif
};
	if (p->expecting_type) {
		p->expecting_type = false;
		v__token__Position type_pos = v__token__Token_position(&p->tok);
		v__table__Type typ = v__parser__Parser_parse_type(p);
		return /* sum type cast 4 */ (v__ast__Expr){._247 = memdup(&(v__ast__Type[]){(v__ast__Type){.typ = typ,.pos = type_pos,}}, sizeof(v__ast__Type)), .typ = 247 /* v.ast.Type */};
	}
	v__table__Language language = (string_eq(p->tok.lit, tos_lit("C")) ? (v__table__Language_c) : string_eq(p->tok.lit, tos_lit("JS")) ? (v__table__Language_js) : (v__table__Language_v));
	string mod = tos_lit("");
	p->expr_mod = tos_lit("");
	if (string_eq(p->tok.lit, tos_lit("map")) && p->peek_tok.kind == v__token__Kind_lsbr) {
		v__table__Type map_type = v__parser__Parser_parse_map_type(p);
		if (p->tok.kind == v__token__Kind_lcbr && p->peek_tok.kind == v__token__Kind_rcbr) {
			v__parser__Parser_next(p);
			v__parser__Parser_next(p);
		}
		return /* sum type cast 4 */ (v__ast__Expr){._232 = memdup(&(v__ast__MapInit[]){(v__ast__MapInit){.pos = v__token__Token_position(&p->tok),.keys = __new_array(0, 1, sizeof(v__ast__Expr)),.vals = __new_array(0, 1, sizeof(v__ast__Expr)),.typ = map_type,.key_type = 0,.value_type = 0,}}, sizeof(v__ast__MapInit)), .typ = 232 /* v.ast.MapInit */};
	}
	if (string_eq(p->tok.lit, tos_lit("chan"))) {
		v__token__Position first_pos = v__token__Token_position(&p->tok);
		v__token__Position last_pos = first_pos;
		v__table__Type chan_type = v__parser__Parser_parse_chan_type(p);
		bool has_cap = false;
		v__ast__Expr cap_expr = (v__ast__Expr){
#ifndef __cplusplus
0
#endif
};
		v__parser__Parser_check(p, v__token__Kind_lcbr);
		if (p->tok.kind == v__token__Kind_rcbr) {
			last_pos = v__token__Token_position(&p->tok);
			v__parser__Parser_next(p);
		} else {
			string key = v__parser__Parser_check_name(p);
			v__parser__Parser_check(p, v__token__Kind_colon);
			string _t1237 = key;
			if (string_eq(_t1237, tos_lit("cap"))) {
				has_cap = true;
				cap_expr = v__parser__Parser_expr(p, 0);
			} else if (string_eq(_t1237, tos_lit("len")) || string_eq(_t1237, tos_lit("init"))) {
				v__parser__Parser_error(p, _STR("`%.*s\000` cannot be initialized for `chan`. Did you mean `cap`?", 2, key));
			} else {
				v__parser__Parser_error(p, _STR("wrong field `%.*s\000`, expecting `cap`", 2, key));
			};
			last_pos = v__token__Token_position(&p->tok);
			v__parser__Parser_check(p, v__token__Kind_rcbr);
		}
		return /* sum type cast 4 */ (v__ast__Expr){._217 = memdup(&(v__ast__ChanInit[]){(v__ast__ChanInit){.pos = v__token__Position_extend(first_pos, last_pos),.cap_expr = cap_expr,.has_cap = has_cap,.typ = chan_type,.elem_type = 0,}}, sizeof(v__ast__ChanInit)), .typ = 217 /* v.ast.ChanInit */};
	}
	if ((string_eq(p->tok.lit, tos_lit("r")) || string_eq(p->tok.lit, tos_lit("c")) || string_eq(p->tok.lit, tos_lit("js"))) && p->peek_tok.kind == v__token__Kind_string && !p->inside_str_interp) {
		return v__parser__Parser_string_expr(p);
	}
	if ((string_eq(p->tok.lit, tos_lit("r")) || string_eq(p->tok.lit, tos_lit("c"))) && p->peek_tok.kind == v__token__Kind_chartoken) {
		string opt = (string_eq(p->tok.lit, tos_lit("r")) ? (tos_lit("`r` (raw string)")) : (tos_lit("`c` (c string)")));
		v__parser__Parser_error(p, _STR("cannot use %.*s\000 with `byte` and `rune`", 2, opt));
	}
	bool known_var = v__parser__Parser_mark_var_as_used(p, p->tok.lit);
	bool is_mod_cast = false;
	if (p->peek_tok.kind == v__token__Kind_dot && !known_var && (language != v__table__Language_v || v__parser__Parser_known_import(p, p->tok.lit) || string_eq(string_all_after_last(p->mod, tos_lit(".")), p->tok.lit))) {
		if (language == v__table__Language_c) {
			mod = tos_lit("C");
		} else if (language == v__table__Language_js) {
			mod = tos_lit("JS");
		} else {
			if (_IN_MAP(p->tok.lit, p->imports)) {
				v__parser__Parser_register_used_import(p, p->tok.lit);
				if (p->peek_tok.kind == v__token__Kind_dot && byte_is_capital(string_at(p->peek_tok2.lit, 0))) {
					is_mod_cast = true;
				}
			}
			mod = (*(string*)map_get(p->imports, p->tok.lit, &(string[]){ (string){.str=(byteptr)""} }));
		}
		v__parser__Parser_next(p);
		v__parser__Parser_check(p, v__token__Kind_dot);
		p->expr_mod = mod;
	}
	bool lit0_is_capital = byte_is_capital(string_at(p->tok.lit, 0));
	v__token__Kind _t1238 = p->peek_tok2.kind;
		bool is_generic_call = !lit0_is_capital && p->peek_tok.kind == v__token__Kind_lt && (((_t1238 == v__token__Kind_name) ? ((p->peek_tok2.kind == v__token__Kind_name && p->peek_tok3.kind == v__token__Kind_gt) || (string_eq(p->peek_tok2.lit, tos_lit("map")) && p->peek_tok3.kind == v__token__Kind_lsbr)) : (_t1238 == v__token__Kind_lsbr) ? (p->peek_tok3.kind == v__token__Kind_rsbr) : (false)));
	bool same_line = p->tok.line_nr == p->peek_tok.line_nr;
	if (!same_line && p->peek_tok.kind == v__token__Kind_lpar) {
		node = /* sum type cast 4 */ (v__ast__Expr){._224 = memdup(&(v__ast__Ident[]){v__parser__Parser_parse_ident(p, language)}, sizeof(v__ast__Ident)), .typ = 224 /* v.ast.Ident */};
	} else if (p->peek_tok.kind == v__token__Kind_lpar || is_generic_call) {
		string name = p->tok.lit;
		if (mod.len > 0) {
			name = _STR("%.*s\000.%.*s", 2, mod, name);
		}
		string name_w_mod = v__parser__Parser_prepend_mod(p, name);
		if ((!known_var && (_IN_MAP(name, p->table->type_idxs) || _IN_MAP(name_w_mod, p->table->type_idxs)) && !(string_eq(name, tos_lit("C.stat")) || string_eq(name, tos_lit("C.sigaction")))) || is_mod_cast || (language == v__table__Language_v && byte_is_capital(string_at(name, 0)))) {
			v__token__Position start_pos = v__token__Token_position(&p->tok);
			v__table__Type to_typ = v__parser__Parser_parse_type(p);
			if (p->is_amp) {
				to_typ = v__table__Type_to_ptr(to_typ);
			}
			p->is_amp = false;
			v__parser__Parser_check(p, v__token__Kind_lpar);
			v__ast__Expr expr = (v__ast__Expr){
#ifndef __cplusplus
0
#endif
};
			v__ast__Expr arg = (v__ast__Expr){
#ifndef __cplusplus
0
#endif
};
			bool has_arg = false;
			expr = v__parser__Parser_expr(p, 0);
			if (p->tok.kind == v__token__Kind_comma && v__table__Type_idx(to_typ) == _const_v__table__string_type_idx) {
				v__parser__Parser_next(p);
				arg = v__parser__Parser_expr(p, 0);
				has_arg = true;
			}
			v__token__Position end_pos = v__token__Token_position(&p->tok);
			v__parser__Parser_check(p, v__token__Kind_rpar);
			node = /* sum type cast 4 */ (v__ast__Expr){._216 = memdup(&(v__ast__CastExpr[]){(v__ast__CastExpr){.expr = expr,.arg = arg,.typ = to_typ,.pos = v__token__Position_extend(start_pos, end_pos),.typname = (string){.str=(byteptr)""},.expr_type = 0,.has_arg = has_arg,.in_prexpr = 0,}}, sizeof(v__ast__CastExpr)), .typ = 216 /* v.ast.CastExpr */};
			p->expr_mod = tos_lit("");
			return node;
		} else {
			node = /* sum type cast 4 */ (v__ast__Expr){._215 = memdup(&(v__ast__CallExpr[]){v__parser__Parser_call_expr(p, language, mod)}, sizeof(v__ast__CallExpr)), .typ = 215 /* v.ast.CallExpr */};
		}
	} else if ((p->peek_tok.kind == v__token__Kind_lcbr || (p->peek_tok.kind == v__token__Kind_lt && lit0_is_capital)) && (!p->inside_match || (p->inside_select && prev_tok_kind == v__token__Kind_arrow && lit0_is_capital)) && !p->inside_match_case && (!p->inside_if || p->inside_select) && (!p->inside_for || p->inside_select)) {
		return /* sum type cast 4 */ (v__ast__Expr){._246 = memdup(&(v__ast__StructInit[]){v__parser__Parser_struct_init(p, false)}, sizeof(v__ast__StructInit)), .typ = 246 /* v.ast.StructInit */};
	} else if (p->peek_tok.kind == v__token__Kind_dot && (lit0_is_capital && !known_var && language == v__table__Language_v)) {
		if (string_eq(p->tok.lit, tos_lit("T"))) {
			v__token__Position pos = v__token__Token_position(&p->tok);
			string name = v__parser__Parser_check_name(p);
			v__parser__Parser_check(p, v__token__Kind_dot);
			string field = v__parser__Parser_check_name(p);
			v__token__Position_extend(pos, v__token__Token_position(&p->tok));
			return /* sum type cast 4 */ (v__ast__Expr){._241 = memdup(&(v__ast__SelectorExpr[]){(v__ast__SelectorExpr){.pos = pos,.expr = /* sum type cast 4 */ (v__ast__Expr){._224 = memdup(&(v__ast__Ident[]){(v__ast__Ident){.language = 0,.tok_kind = 0,.pos = {0},.mut_pos = {0},.obj = {0},.mod = (string){.str=(byteptr)""},.name = name,.kind = 0,.info = {0},.is_mut = 0,}}, sizeof(v__ast__Ident)), .typ = 224 /* v.ast.Ident */},.field_name = field,.is_mut = 0,.mut_pos = {0},.expr_type = 0,.typ = 0,.name_type = 0,}}, sizeof(v__ast__SelectorExpr)), .typ = 241 /* v.ast.SelectorExpr */};
		}
		string enum_name = v__parser__Parser_check_name(p);
		if ((mod).len != 0) {
			enum_name = string_add(string_add(mod, tos_lit(".")), enum_name);
		} else {
			enum_name = v__parser__Parser_prepend_mod(p, enum_name);
		}
		v__parser__Parser_check(p, v__token__Kind_dot);
		string val = v__parser__Parser_check_name(p);
		p->expr_mod = tos_lit("");
		return /* sum type cast 4 */ (v__ast__Expr){._222 = memdup(&(v__ast__EnumVal[]){(v__ast__EnumVal){.enum_name = enum_name,.val = val,.mod = mod,.pos = v__token__Token_position(&p->tok),.typ = 0,}}, sizeof(v__ast__EnumVal)), .typ = 222 /* v.ast.EnumVal */};
	} else if (p->peek_tok.kind == v__token__Kind_colon && p->prev_tok.kind != v__token__Kind_str_dollar) {
		return /* sum type cast 4 */ (v__ast__Expr){._246 = memdup(&(v__ast__StructInit[]){v__parser__Parser_struct_init(p, true)}, sizeof(v__ast__StructInit)), .typ = 246 /* v.ast.StructInit */};
	} else if (language == v__table__Language_js && p->peek_tok.kind == v__token__Kind_dot && p->peek_tok2.kind == v__token__Kind_name) {
		node = /* sum type cast 4 */ (v__ast__Expr){._215 = memdup(&(v__ast__CallExpr[]){v__parser__Parser_call_expr(p, language, mod)}, sizeof(v__ast__CallExpr)), .typ = 215 /* v.ast.CallExpr */};
	} else {
		node = /* sum type cast 4 */ (v__ast__Expr){._224 = memdup(&(v__ast__Ident[]){v__parser__Parser_parse_ident(p, language)}, sizeof(v__ast__Ident)), .typ = 224 /* v.ast.Ident */};
	}
	p->expr_mod = tos_lit("");
	return node;
}

VV_LOCAL_SYMBOL v__ast__IndexExpr v__parser__Parser_index_expr(v__parser__Parser* p, v__ast__Expr left) {
	v__token__Position start_pos = v__token__Token_position(&p->tok);
	v__parser__Parser_next(p);
	bool has_low = true;
	if (p->tok.kind == v__token__Kind_dotdot) {
		has_low = false;
		v__parser__Parser_next(p);
		v__ast__Expr high = v__parser__Parser_expr(p, 0);
		v__token__Position pos = v__token__Position_extend(start_pos, v__token__Token_position(&p->tok));
		v__parser__Parser_check(p, v__token__Kind_rsbr);
		return (v__ast__IndexExpr){.pos = pos,.left = left,.index = /* sum type cast 4 */ (v__ast__Expr){._239 = memdup(&(v__ast__RangeExpr[]){(v__ast__RangeExpr){.low = (v__ast__Expr){
#ifndef __cplusplus
0
#endif
},.high = high,.has_high = true,.has_low = 0,.pos = pos,}}, sizeof(v__ast__RangeExpr)), .typ = 239 /* v.ast.RangeExpr */},.left_type = 0,.is_setter = 0,};
	}
	v__ast__Expr expr = v__parser__Parser_expr(p, 0);
	bool has_high = false;
	if (p->tok.kind == v__token__Kind_dotdot) {
		v__parser__Parser_next(p);
		v__ast__Expr high = (v__ast__Expr){
#ifndef __cplusplus
0
#endif
};
		if (p->tok.kind != v__token__Kind_rsbr) {
			has_high = true;
			high = v__parser__Parser_expr(p, 0);
		}
		v__token__Position pos = v__token__Position_extend(start_pos, v__token__Token_position(&p->tok));
		v__parser__Parser_check(p, v__token__Kind_rsbr);
		return (v__ast__IndexExpr){.pos = pos,.left = left,.index = /* sum type cast 4 */ (v__ast__Expr){._239 = memdup(&(v__ast__RangeExpr[]){(v__ast__RangeExpr){.low = expr,.high = high,.has_high = has_high,.has_low = has_low,.pos = pos,}}, sizeof(v__ast__RangeExpr)), .typ = 239 /* v.ast.RangeExpr */},.left_type = 0,.is_setter = 0,};
	}
	v__token__Position pos = v__token__Position_extend(start_pos, v__token__Token_position(&p->tok));
	v__parser__Parser_check(p, v__token__Kind_rsbr);
	return (v__ast__IndexExpr){.pos = pos,.left = left,.index = expr,.left_type = 0,.is_setter = 0,};
}

VV_LOCAL_SYMBOL void v__parser__Parser_scope_register_it(v__parser__Parser* p) {
	v__ast__Scope_register(p->scope, tos_lit("it"), /* sum type cast 4 */ (v__ast__ScopeObject){._277 = memdup(&(v__ast__Var[]){(v__ast__Var){.name = tos_lit("it"),.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.typ = 0,.sum_type_casts = __new_array(0, 1, sizeof(v__table__Type)),.pos = v__token__Token_position(&p->tok),.is_used = true,.is_changed = 0,}}, sizeof(v__ast__Var)), .typ = 277 /* v.ast.Var */});
}

VV_LOCAL_SYMBOL void v__parser__Parser_scope_register_ab(v__parser__Parser* p) {
	v__ast__Scope_register(p->scope, tos_lit("a"), /* sum type cast 4 */ (v__ast__ScopeObject){._277 = memdup(&(v__ast__Var[]){(v__ast__Var){.name = tos_lit("a"),.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.typ = 0,.sum_type_casts = __new_array(0, 1, sizeof(v__table__Type)),.pos = v__token__Token_position(&p->tok),.is_used = true,.is_changed = 0,}}, sizeof(v__ast__Var)), .typ = 277 /* v.ast.Var */});
	v__ast__Scope_register(p->scope, tos_lit("b"), /* sum type cast 4 */ (v__ast__ScopeObject){._277 = memdup(&(v__ast__Var[]){(v__ast__Var){.name = tos_lit("b"),.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.typ = 0,.sum_type_casts = __new_array(0, 1, sizeof(v__table__Type)),.pos = v__token__Token_position(&p->tok),.is_used = true,.is_changed = 0,}}, sizeof(v__ast__Var)), .typ = 277 /* v.ast.Var */});
}

VV_LOCAL_SYMBOL v__ast__Expr v__parser__Parser_dot_expr(v__parser__Parser* p, v__ast__Expr left) {
	v__parser__Parser_next(p);
	if (p->tok.kind == v__token__Kind_dollar) {
		return /* sum type cast 4 */ (v__ast__Expr){._220 = memdup(&(v__ast__ComptimeCall[]){v__parser__Parser_comptime_method_call(p, left)}, sizeof(v__ast__ComptimeCall)), .typ = 220 /* v.ast.ComptimeCall */};
	}
	v__token__Position name_pos = v__token__Token_position(&p->tok);
	string field_name = v__parser__Parser_check_name(p);
	bool is_filter = (string_eq(field_name, tos_lit("filter")) || string_eq(field_name, tos_lit("map")));
	if (is_filter) {
		v__parser__Parser_open_scope(p);
	} else if (string_eq(field_name, tos_lit("sort"))) {
		v__parser__Parser_open_scope(p);
	}
	if (p->tok.kind == v__token__Kind_not && p->peek_tok.kind == v__token__Kind_lpar) {
		v__parser__Parser_next(p);
	}
	if (p->tok.kind == v__token__Kind_lpar) {
		v__parser__Parser_next(p);
		array_v__ast__CallArg args = v__parser__Parser_call_args(p);
		if (is_filter && args.len != 1) {
			v__parser__Parser_error(p, tos_lit("needs exactly 1 argument"));
		}
		v__parser__Parser_check(p, v__token__Kind_rpar);
		array_v__ast__Stmt or_stmts = __new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
		v__ast__OrKind or_kind = v__ast__OrKind_absent;
		v__token__Position or_pos = v__token__Token_position(&p->tok);
		if (p->tok.kind == v__token__Kind_key_orelse) {
			v__parser__Parser_next(p);
			v__parser__Parser_open_scope(p);
			v__ast__Scope_register(p->scope, tos_lit("errcode"), /* sum type cast 4 */ (v__ast__ScopeObject){._277 = memdup(&(v__ast__Var[]){(v__ast__Var){.name = tos_lit("errcode"),.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.typ = _const_v__table__int_type,.sum_type_casts = __new_array(0, 1, sizeof(v__table__Type)),.pos = v__token__Token_position(&p->tok),.is_used = true,.is_changed = 0,}}, sizeof(v__ast__Var)), .typ = 277 /* v.ast.Var */});
			v__ast__Scope_register(p->scope, tos_lit("err"), /* sum type cast 4 */ (v__ast__ScopeObject){._277 = memdup(&(v__ast__Var[]){(v__ast__Var){.name = tos_lit("err"),.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.typ = _const_v__table__string_type,.sum_type_casts = __new_array(0, 1, sizeof(v__table__Type)),.pos = v__token__Token_position(&p->tok),.is_used = true,.is_changed = 0,}}, sizeof(v__ast__Var)), .typ = 277 /* v.ast.Var */});
			or_kind = v__ast__OrKind_block;
			or_stmts = v__parser__Parser_parse_block_no_scope(p, false);
			or_pos = v__token__Position_extend(or_pos, v__token__Token_position(&p->prev_tok));
			v__parser__Parser_close_scope(p);
		}
		if (p->tok.kind == v__token__Kind_question) {
			v__parser__Parser_next(p);
			or_kind = v__ast__OrKind_propagate;
		}
		v__token__Position end_pos = v__token__Token_position(&p->tok);
		v__token__Position pos = (v__token__Position){.len = end_pos.pos - name_pos.pos,.line_nr = name_pos.line_nr,.pos = name_pos.pos,};
		v__ast__CallExpr mcall_expr = (v__ast__CallExpr){
			.pos = pos,
			.left = left,
			.mod = (string){.str=(byteptr)""},
			.name = field_name,
			.is_method = true,
			.is_field = 0,
			.args = args,
			.expected_arg_types = __new_array(0, 1, sizeof(v__table__Type)),
			.language = 0,
			.or_block = (v__ast__OrExpr){.stmts = or_stmts,.kind = or_kind,.pos = or_pos,},
			.left_type = 0,
			.receiver_type = 0,
			.return_type = 0,
			.should_be_skipped = 0,
			.generic_type = 0,
			.generic_list_pos = {0},
			.free_receiver = 0,
		};
		if (is_filter || string_eq(field_name, tos_lit("sort"))) {
			v__parser__Parser_close_scope(p);
		}
		return /* sum type cast 4 */ (v__ast__Expr){._215 = memdup(&(v__ast__CallExpr[]){mcall_expr}, sizeof(v__ast__CallExpr)), .typ = 215 /* v.ast.CallExpr */};
	}
	bool is_mut = false;
	v__token__Position mut_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,};
	if (p->inside_match || p->inside_if_expr) {
		v__ast__Expr _t1239 = left;
		if (_t1239.typ == 224 /* v.ast.Ident */) {
			is_mut = (*left._224).is_mut;
			mut_pos = (*left._224).mut_pos;
		} else if (_t1239.typ == 241 /* v.ast.SelectorExpr */) {
			is_mut = (*left._241).is_mut;
			mut_pos = (*left._241).mut_pos;
		} else {
		};
	}
	v__ast__SelectorExpr sel_expr = (v__ast__SelectorExpr){.pos = name_pos,.expr = left,.field_name = field_name,.is_mut = is_mut,.mut_pos = {0},.expr_type = 0,.typ = 0,.name_type = 0,};
	v__ast__Expr node = (v__ast__Expr){
#ifndef __cplusplus
0
#endif
};
	node = /* sum type cast 4 */ (v__ast__Expr){._241 = memdup(&(v__ast__SelectorExpr[]){sel_expr}, sizeof(v__ast__SelectorExpr)), .typ = 241 /* v.ast.SelectorExpr */};
	if (is_filter) {
		v__parser__Parser_close_scope(p);
	}
	return node;
}

VV_LOCAL_SYMBOL v__ast__EnumVal v__parser__Parser_enum_val(v__parser__Parser* p) {
	v__parser__Parser_check(p, v__token__Kind_dot);
	string val = v__parser__Parser_check_name(p);
	return (v__ast__EnumVal){.enum_name = (string){.str=(byteptr)""},.val = val,.mod = (string){.str=(byteptr)""},.pos = v__token__Token_position(&p->tok),.typ = 0,};
}

VV_LOCAL_SYMBOL v__ast__Expr v__parser__Parser_string_expr(v__parser__Parser* p) {
	bool is_raw = p->tok.kind == v__token__Kind_name && string_eq(p->tok.lit, tos_lit("r"));
	bool is_cstr = p->tok.kind == v__token__Kind_name && string_eq(p->tok.lit, tos_lit("c"));
	if (is_raw || is_cstr) {
		v__parser__Parser_next(p);
	}
	v__ast__Expr node = (v__ast__Expr){
#ifndef __cplusplus
0
#endif
};
	string val = p->tok.lit;
	v__token__Position pos = v__token__Token_position(&p->tok);
	if (p->peek_tok.kind != v__token__Kind_str_dollar) {
		v__parser__Parser_next(p);
		node = /* sum type cast 4 */ (v__ast__Expr){._245 = memdup(&(v__ast__StringLiteral[]){(v__ast__StringLiteral){.val = val,.is_raw = is_raw,.language = (is_cstr ? (v__table__Language_c) : (v__table__Language_v)),.pos = pos,}}, sizeof(v__ast__StringLiteral)), .typ = 245 /* v.ast.StringLiteral */};
		return node;
	}
	array_v__ast__Expr exprs = __new_array_with_default(0, 0, sizeof(v__ast__Expr), 0);
	array_string vals = __new_array_with_default(0, 0, sizeof(string), 0);
	array_bool has_fmts = __new_array_with_default(0, 0, sizeof(bool), 0);
	array_int fwidths = __new_array_with_default(0, 0, sizeof(int), 0);
	array_int precisions = __new_array_with_default(0, 0, sizeof(int), 0);
	array_bool visible_pluss = __new_array_with_default(0, 0, sizeof(bool), 0);
	array_bool fills = __new_array_with_default(0, 0, sizeof(bool), 0);
	array_byte fmts = __new_array_with_default(0, 0, sizeof(byte), 0);
	array_v__token__Position fposs = __new_array_with_default(0, 0, sizeof(v__token__Position), 0);
	p->inside_str_interp = true;
	for (;;) {
		if (!(p->tok.kind == v__token__Kind_string)) break;
		array_push(&vals, _MOV((string[]){ string_clone(p->tok.lit) }));
		v__parser__Parser_next(p);
		if (p->tok.kind != v__token__Kind_str_dollar) {
			break;
		}
		v__parser__Parser_next(p);
		array_push(&exprs, _MOV((v__ast__Expr[]){ v__parser__Parser_expr(p, 0) }));
		bool has_fmt = false;
		int fwidth = 0;
		bool fwidthneg = false;
		int precision = 987698;
		bool visible_plus = false;
		bool fill = false;
		rune fmt = '_';
		if (p->tok.kind == v__token__Kind_colon) {
			v__parser__Parser_next(p);
			if (p->tok.kind == v__token__Kind_minus) {
				fwidthneg = true;
				v__parser__Parser_next(p);
			} else if (p->tok.kind == v__token__Kind_plus) {
				visible_plus = true;
				v__parser__Parser_next(p);
			}
			if (p->tok.kind == v__token__Kind_number) {
				array_string fields = string_split(p->tok.lit, tos_lit("."));
				if ((*(string*)/*ee elem_typ */array_get(fields, 0)).len > 0 && string_at((*(string*)/*ee elem_typ */array_get(fields, 0)), 0) == '0') {
					fill = true;
				}
				fwidth = string_int((*(string*)/*ee elem_typ */array_get(fields, 0)));
				if (fwidthneg) {
					fwidth = -fwidth;
				}
				if (fields.len > 1) {
					precision = string_int((*(string*)/*ee elem_typ */array_get(fields, 1)));
				}
				v__parser__Parser_next(p);
			}
			if (p->tok.kind == v__token__Kind_name) {
				if (p->tok.lit.len == 1) {
					fmt = string_at(p->tok.lit, 0);
					has_fmt = true;
					v__parser__Parser_next(p);
				} else {
					v__parser__Parser_error(p, tos_lit("format specifier may only be one letter"));
				}
			}
		}
		array_push(&fwidths, _MOV((int[]){ fwidth }));
		array_push(&has_fmts, _MOV((bool[]){ has_fmt }));
		array_push(&precisions, _MOV((int[]){ precision }));
		array_push(&visible_pluss, _MOV((bool[]){ visible_plus }));
		array_push(&fmts, _MOV((byte[]){ fmt }));
		array_push(&fills, _MOV((bool[]){ fill }));
		array_push(&fposs, _MOV((v__token__Position[]){ v__token__Token_position(&p->prev_tok) }));
	}
	node = /* sum type cast 4 */ (v__ast__Expr){._244 = memdup(&(v__ast__StringInterLiteral[]){(v__ast__StringInterLiteral){
		.vals = vals,
		.exprs = exprs,
		.fwidths = fwidths,
		.precisions = precisions,
		.pluss = visible_pluss,
		.fills = fills,
		.fmt_poss = fposs,
		.pos = pos,
		.expr_types = __new_array(0, 1, sizeof(v__table__Type)),
		.fmts = fmts,
		.need_fmts = has_fmts,
	}}, sizeof(v__ast__StringInterLiteral)), .typ = 244 /* v.ast.StringInterLiteral */};
	p->inside_str_interp = false;
	return node;
}

VV_LOCAL_SYMBOL v__ast__Expr v__parser__Parser_parse_number_literal(v__parser__Parser* p) {
	string lit = p->tok.lit;
	v__token__Position pos = v__token__Token_position(&p->tok);
	v__ast__Expr node = (v__ast__Expr){
#ifndef __cplusplus
0
#endif
};
	if (string_index_any(lit, tos_lit(".eE")) >= 0 && !(string_eq(string_substr(lit, 0, 2), tos_lit("0x")) || string_eq(string_substr(lit, 0, 2), tos_lit("0X")) || string_eq(string_substr(lit, 0, 2), tos_lit("0o")) || string_eq(string_substr(lit, 0, 2), tos_lit("0O")) || string_eq(string_substr(lit, 0, 2), tos_lit("0b")) || string_eq(string_substr(lit, 0, 2), tos_lit("0B")))) {
		node = /* sum type cast 4 */ (v__ast__Expr){._223 = memdup(&(v__ast__FloatLiteral[]){(v__ast__FloatLiteral){.val = lit,.pos = pos,}}, sizeof(v__ast__FloatLiteral)), .typ = 223 /* v.ast.FloatLiteral */};
	} else {
		node = /* sum type cast 4 */ (v__ast__Expr){._229 = memdup(&(v__ast__IntegerLiteral[]){(v__ast__IntegerLiteral){.val = lit,.pos = pos,}}, sizeof(v__ast__IntegerLiteral)), .typ = 229 /* v.ast.IntegerLiteral */};
	}
	v__parser__Parser_next(p);
	return node;
}

VV_LOCAL_SYMBOL v__ast__Module v__parser__Parser_module_decl(v__parser__Parser* p) {
	string name = tos_lit("main");
	bool is_skipped = p->tok.kind != v__token__Kind_key_module;
	v__token__Position module_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,};
	if (!is_skipped) {
		module_pos = v__token__Token_position(&p->tok);
		v__parser__Parser_next(p);
		v__token__Position pos = v__token__Token_position(&p->tok);
		name = v__parser__Parser_check_name(p);
		if (module_pos.line_nr != pos.line_nr) {
			v__parser__Parser_error_with_pos(p, _STR("`module` and `%.*s\000` must be at same line", 2, name), pos);
		}
		pos = v__token__Token_position(&p->tok);
		if (module_pos.line_nr == pos.line_nr && p->tok.kind != v__token__Kind_comment) {
			if (p->tok.kind != v__token__Kind_name) {
				v__parser__Parser_error_with_pos(p, tos_lit("`module x` syntax error"), pos);
			} else {
				v__parser__Parser_error_with_pos(p, tos_lit("`module x` can only declare one module"), pos);
			}
		}
		module_pos = v__token__Position_extend(module_pos, pos);
	}
	string full_mod = v__table__Table_qualify_module(p->table, name, p->file_name);
	if (p->pref->build_mode == v__pref__BuildMode_build_module && !string_contains(full_mod, tos_lit("."))) {
		string word = string_after(p->pref->path, tos_lit("/"));
		if (string_eq(full_mod, word)) {
			full_mod = string_replace(string_after(p->pref->path, tos_lit("vlib/")), tos_lit("/"), tos_lit("."));
		}
	}
	p->mod = full_mod;
	p->builtin_mod = string_eq(p->mod, tos_lit("builtin"));
	return (v__ast__Module){.name = full_mod,.path = (string){.str=(byteptr)""},.expr = {0},.pos = module_pos,.is_skipped = is_skipped,};
}

VV_LOCAL_SYMBOL v__ast__Import v__parser__Parser_import_stmt(v__parser__Parser* p) {
	v__token__Position import_pos = v__token__Token_position(&p->tok);
	v__parser__Parser_check(p, v__token__Kind_key_import);
	v__token__Position pos = v__token__Token_position(&p->tok);
	if (p->tok.kind == v__token__Kind_lpar) {
		v__parser__Parser_error_with_pos(p, tos_lit("`import()` has been deprecated, use `import x` instead"), pos);
	}
	string mod_name = v__parser__Parser_check_name(p);
	if (import_pos.line_nr != pos.line_nr) {
		v__parser__Parser_error_with_pos(p, tos_lit("`import` statements must be a single line"), pos);
	}
	string mod_alias = mod_name;
	for (;;) {
		if (!(p->tok.kind == v__token__Kind_dot)) break;
		v__parser__Parser_next(p);
		v__token__Position pos_t = v__token__Token_position(&p->tok);
		if (p->tok.kind != v__token__Kind_name) {
			v__parser__Parser_error_with_pos(p, tos_lit("module syntax error, please use `x.y.z`"), pos);
		}
		if (import_pos.line_nr != pos_t.line_nr) {
			v__parser__Parser_error_with_pos(p, tos_lit("`import` and `submodule` must be at same line"), pos);
		}
		string submod_name = v__parser__Parser_check_name(p);
		mod_name = /*f*/string_add(mod_name, string_add(tos_lit("."), submod_name));
		mod_alias = submod_name;
	}
	if (p->tok.kind == v__token__Kind_key_as) {
		v__parser__Parser_next(p);
		mod_alias = v__parser__Parser_check_name(p);
		if (string_eq(mod_alias, *(string*)array_last(string_split(mod_name, tos_lit("."))))) {
			v__parser__Parser_error_with_pos(p, _STR("import alias `%.*s\000 as %.*s\000` is redundant", 3, mod_name, mod_alias), v__token__Token_position(&p->prev_tok));
		}
	}
	v__ast__Import node = (v__ast__Import){.pos = pos,.mod = mod_name,.alias = mod_alias,.syms = __new_array(0, 1, sizeof(v__ast__ImportSymbol)),};
	if (p->tok.kind == v__token__Kind_lcbr) {
		v__parser__Parser_import_syms(p, (voidptr)&/*qq*/node);
		v__parser__Parser_register_used_import(p, mod_name);
	}
	v__token__Position pos_t = v__token__Token_position(&p->tok);
	if (import_pos.line_nr == pos_t.line_nr) {
		if (!(p->tok.kind == v__token__Kind_lcbr || p->tok.kind == v__token__Kind_eof)) {
			v__parser__Parser_error_with_pos(p, tos_lit("cannot import multiple modules at a time"), pos_t);
		}
	}
	map_set(&p->imports, mod_alias, &(string[]) { mod_name });
	array_push(&p->table->imports, _MOV((string[]){ string_clone(mod_name) }));
	array_push(&p->ast_imports, _MOV((v__ast__Import[]){ node }));
	return node;
}

VV_LOCAL_SYMBOL void v__parser__Parser_import_syms(v__parser__Parser* p, v__ast__Import* parent) {
	v__parser__Parser_next(p);
	v__token__Position pos_t = v__token__Token_position(&p->tok);
	if (p->tok.kind == v__token__Kind_rcbr) {
		v__parser__Parser_error_with_pos(p, _STR("empty `%.*s\000` import set, remove `{}`", 2, parent->mod), pos_t);
	}
	if (p->tok.kind != v__token__Kind_name) {
		v__parser__Parser_error_with_pos(p, tos_lit("import syntax error, please specify a valid fn or type name"), pos_t);
	}
	for (;;) {
		if (!(p->tok.kind == v__token__Kind_name)) break;
		v__token__Position pos = v__token__Token_position(&p->tok);
		string alias = v__parser__Parser_check_name(p);
		string name = _STR("%.*s\000.%.*s", 2, parent->mod, alias);
		if (byte_is_capital(string_at(alias, 0))) {
			int idx = v__table__Table_add_placeholder_type(p->table, name, v__table__Language_v);
			v__table__Type typ = v__table__new_type(idx);
			string prepend_mod_name = v__parser__Parser_prepend_mod(p, alias);
			v__table__Table_register_type_symbol(p->table, (v__table__TypeSymbol){
				.parent_idx = idx,
				.info = /* sum type cast 4 */ (v__table__TypeInfo){._347 = memdup(&(v__table__Alias[]){(v__table__Alias){.parent_type = typ,.language = v__table__Language_v,.is_import = true,}}, sizeof(v__table__Alias)), .typ = 347 /* v.table.Alias */},
				.kind = v__table__Kind_alias,
				.name = prepend_mod_name,
				.source_name = prepend_mod_name,
				.methods = __new_array(0, 1, sizeof(v__table__Fn)),
				.mod = p->mod,
				.is_public = false,
				.is_written = 0,
				.language = 0,
			});
			array_push(&parent->syms, _MOV((v__ast__ImportSymbol[]){ (v__ast__ImportSymbol){.pos = pos,.name = alias,.kind = v__ast__ImportSymbolKind_type_,} }));
		} else {
			if (!v__table__Table_known_fn(p->table, name)) {
				(*(v__table__Fn*)map_get_and_set(&p->table->fns, alias, &(v__table__Fn[]){ {0} })) = (v__table__Fn){.params = __new_array(0, 1, sizeof(v__table__Param)),.return_type = 0,.return_type_source_name = (string){.str=(byteptr)""},.is_variadic = 0,.language = 0,.is_generic = 0,.is_pub = 0,.is_deprecated = 0,.is_unsafe = 0,.is_placeholder = true,.mod = parent->mod,.ctdefine = (string){.str=(byteptr)""},.attrs = __new_array(0, 1, sizeof(v__table__Attr)),.name = name,.source_fn = 0,};
			}
			array_push(&parent->syms, _MOV((v__ast__ImportSymbol[]){ (v__ast__ImportSymbol){.pos = pos,.name = alias,.kind = v__ast__ImportSymbolKind_fn_,} }));
		}
		if (p->tok.kind == v__token__Kind_comma) {
			v__parser__Parser_next(p);
			continue;
		}
		if (p->tok.kind == v__token__Kind_rcbr) {
			break;
		}
	}
	if (p->tok.kind != v__token__Kind_rcbr) {
		v__parser__Parser_error_with_pos(p, tos_lit("import syntax error, no closing `}`"), v__token__Token_position(&p->tok));
	}
	v__parser__Parser_next(p);
}

VV_LOCAL_SYMBOL v__ast__ConstDecl v__parser__Parser_const_decl(v__parser__Parser* p) {
	v__parser__Parser_top_level_statement_start(p);
	v__token__Position start_pos = v__token__Token_position(&p->tok);
	bool is_pub = p->tok.kind == v__token__Kind_key_pub;
	if (is_pub) {
		v__parser__Parser_next(p);
	}
	v__token__Position end_pos = v__token__Token_position(&p->tok);
	v__parser__Parser_check(p, v__token__Kind_key_const);
	if (p->tok.kind != v__token__Kind_lpar) {
		v__parser__Parser_error(p, tos_lit("consts must be grouped, e.g.\nconst (\n\ta = 1\n)"));
	}
	v__parser__Parser_next(p);
	array_v__ast__ConstField fields = __new_array_with_default(0, 0, sizeof(v__ast__ConstField), 0);
	array_v__ast__Comment comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	for (;;) {
		comments = v__parser__Parser_eat_comments(p);
		if (p->tok.kind == v__token__Kind_rpar) {
			break;
		}
		v__token__Position pos = v__token__Token_position(&p->tok);
		string name = v__parser__Parser_check_name(p);
		if (v__util__contains_capital(name)) {
			v__parser__Parser_warn_with_pos(p, tos_lit("const names cannot contain uppercase letters, use snake_case instead"), pos);
		}
		string full_name = v__parser__Parser_prepend_mod(p, name);
		v__parser__Parser_check(p, v__token__Kind_assign);
		if (p->tok.kind == v__token__Kind_key_fn) {
			v__parser__Parser_error(p, tos_lit("const initializer fn literal is not a constant"));
		}
		v__ast__Expr expr = v__parser__Parser_expr(p, 0);
		v__ast__ConstField field = (v__ast__ConstField){.mod = p->mod,.name = full_name,.expr = expr,.is_pub = 0,.pos = pos,.typ = 0,.comments = comments,};
		array_push(&fields, _MOV((v__ast__ConstField[]){ field }));
		v__ast__Scope_register(p->global_scope, field.name, /* sum type cast 4 */ (v__ast__ScopeObject){._275 = memdup(&(v__ast__ConstField[]){field}, sizeof(v__ast__ConstField)), .typ = 275 /* v.ast.ConstField */});
		comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	}
	v__parser__Parser_top_level_statement_end(p);
	v__parser__Parser_check(p, v__token__Kind_rpar);
	return (v__ast__ConstDecl){.is_pub = is_pub,.pos = v__token__Position_extend(start_pos, end_pos),.fields = fields,.end_comments = comments,};
}

VV_LOCAL_SYMBOL v__ast__Return v__parser__Parser_return_stmt(v__parser__Parser* p) {
	v__token__Position first_pos = v__token__Token_position(&p->tok);
	v__parser__Parser_next(p);
	array_v__ast__Comment comments = v__parser__Parser_eat_comments(p);
	if (p->tok.kind == v__token__Kind_rcbr) {
		return (v__ast__Return){.pos = first_pos,.exprs = __new_array(0, 1, sizeof(v__ast__Expr)),.comments = comments,.types = __new_array(0, 1, sizeof(v__table__Type)),};
	}
	multi_return_array_v__ast__Expr_array_v__ast__Comment mr_41880 = v__parser__Parser_expr_list(p);
	array_v__ast__Expr exprs = mr_41880.arg0;
	array_v__ast__Comment comments2 = mr_41880.arg1;
	_PUSH_MANY(&comments, (comments2), _t1254, array_v__ast__Comment);
	v__token__Position end_pos = v__ast__Expr_position(*(v__ast__Expr*)array_last(exprs));
	return (v__ast__Return){.pos = v__token__Position_extend(first_pos, end_pos),.exprs = exprs,.comments = comments,.types = __new_array(0, 1, sizeof(v__table__Type)),};
}

VV_LOCAL_SYMBOL v__ast__GlobalDecl v__parser__Parser_global_decl(v__parser__Parser* p) {
	if (!p->pref->translated && !p->pref->is_livemain && !p->builtin_mod && !p->pref->building_v && string_ne(p->mod, tos_lit("ui")) && string_ne(p->mod, tos_lit("gg2")) && string_ne(p->mod, tos_lit("uiold")) && !p->pref->enable_globals && !p->pref->is_fmt && !_IN(string, p->mod, _const_v__parser__global_enabled_mods)) {
		v__parser__Parser_error(p, tos_lit("use `v --enable-globals ...` to enable globals"));
	}
	v__token__Position start_pos = v__token__Token_position(&p->tok);
	v__token__Position end_pos = v__token__Token_position(&p->tok);
	v__parser__Parser_check(p, v__token__Kind_key_global);
	if (p->tok.kind != v__token__Kind_lpar) {
		v__parser__Parser_error(p, tos_lit("globals must be grouped, e.g. `__global ( a = int(1) )`"));
	}
	v__parser__Parser_next(p);
	array_v__ast__GlobalField fields = __new_array_with_default(0, 0, sizeof(v__ast__GlobalField), 0);
	array_v__ast__Comment comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	for (;;) {
		comments = v__parser__Parser_eat_comments(p);
		if (p->tok.kind == v__token__Kind_rpar) {
			break;
		}
		v__token__Position pos = v__token__Token_position(&p->tok);
		string name = v__parser__Parser_check_name(p);
		bool has_expr = p->tok.kind == v__token__Kind_assign;
		if (has_expr) {
			v__parser__Parser_next(p);
		}
		v__table__Type typ = v__parser__Parser_parse_type(p);
		if (p->tok.kind == v__token__Kind_assign) {
			v__parser__Parser_error(p, tos_lit("global assign must have the type around the value, use `__global ( name = type(value) )`"));
		}
		v__ast__Expr expr = (v__ast__Expr){
#ifndef __cplusplus
0
#endif
};
		if (has_expr) {
			if (p->tok.kind != v__token__Kind_lpar) {
				v__parser__Parser_error(p, tos_lit("global assign must have a type and value, use `__global ( name = type(value) )` or `__global ( name type )`"));
			}
			v__parser__Parser_next(p);
			expr = v__parser__Parser_expr(p, 0);
			v__parser__Parser_check(p, v__token__Kind_rpar);
		}
		v__ast__GlobalField field = (v__ast__GlobalField){
			.name = name,
			.expr = expr,
			.has_expr = has_expr,
			.pos = pos,
			.typ = typ,
			.comments = comments,
		};
		array_push(&fields, _MOV((v__ast__GlobalField[]){ field }));
		v__ast__Scope_register(p->global_scope, field.name, /* sum type cast 4 */ (v__ast__ScopeObject){._276 = memdup(&(v__ast__GlobalField[]){field}, sizeof(v__ast__GlobalField)), .typ = 276 /* v.ast.GlobalField */});
		comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	}
	v__parser__Parser_check(p, v__token__Kind_rpar);
	return (v__ast__GlobalDecl){.pos = v__token__Position_extend(start_pos, end_pos),.fields = fields,.end_comments = comments,};
}

VV_LOCAL_SYMBOL v__ast__EnumDecl v__parser__Parser_enum_decl(v__parser__Parser* p) {
	v__parser__Parser_top_level_statement_start(p);
	bool is_pub = p->tok.kind == v__token__Kind_key_pub;
	v__token__Position start_pos = v__token__Token_position(&p->tok);
	if (is_pub) {
		v__parser__Parser_next(p);
	}
	v__parser__Parser_check(p, v__token__Kind_key_enum);
	v__token__Position end_pos = v__token__Token_position(&p->tok);
	string enum_name = v__parser__Parser_check_name(p);
	if (enum_name.len == 1) {
		v__parser__Parser_error_with_pos(p, tos_lit("single letter capital names are reserved for generic template types."), end_pos);
	}
	string name = v__parser__Parser_prepend_mod(p, enum_name);
	v__parser__Parser_check(p, v__token__Kind_lcbr);
	array_v__ast__Comment enum_decl_comments = v__parser__Parser_eat_comments(p);
	array_string vals = __new_array_with_default(0, 0, sizeof(string), 0);
	array_v__ast__EnumField fields = __new_array_with_default(0, 0, sizeof(v__ast__EnumField), 0);
	for (;;) {
		if (!(p->tok.kind != v__token__Kind_eof && p->tok.kind != v__token__Kind_rcbr)) break;
		v__token__Position pos = v__token__Token_position(&p->tok);
		string val = v__parser__Parser_check_name(p);
		array_push(&vals, _MOV((string[]){ string_clone(val) }));
		v__ast__Expr expr = (v__ast__Expr){
#ifndef __cplusplus
0
#endif
};
		bool has_expr = false;
		if (p->tok.kind == v__token__Kind_assign) {
			v__parser__Parser_next(p);
			expr = v__parser__Parser_expr(p, 0);
			has_expr = true;
		}
		array_push(&fields, _MOV((v__ast__EnumField[]){ (v__ast__EnumField){.name = val,.pos = pos,.comments = v__parser__Parser_eat_comments(p),.expr = expr,.has_expr = has_expr,} }));
	}
	v__parser__Parser_top_level_statement_end(p);
	v__parser__Parser_check(p, v__token__Kind_rcbr);
	bool is_flag = array_v__table__Attr_contains(p->attrs, tos_lit("flag"));
	bool is_multi_allowed = array_v__table__Attr_contains(p->attrs, tos_lit("_allow_multiple_values"));
	if (is_flag) {
		if (fields.len > 32) {
			v__parser__Parser_error(p, tos_lit("when an enum is used as bit field, it must have a max of 32 fields"));
		}
		// FOR IN array
		array _t1258 = fields;
		for (int _t1259 = 0; _t1259 < _t1258.len; ++_t1259) {
			v__ast__EnumField f = ((v__ast__EnumField*)_t1258.data)[_t1259];
			if (f.has_expr) {
				v__parser__Parser_error_with_pos(p, tos_lit("when an enum is used as a bit field, you can not assign custom values"), f.pos);
			}
		}
		string pubfn = (string_eq(p->mod, tos_lit("main")) ? (tos_lit("fn")) : (tos_lit("pub fn")));
		v__scanner__Scanner_codegen(p->scanner, _STR("\n//\n%.*s\000 (    e &%.*s\000) has(flag %.*s\000) bool { return      (int(*e) &  (int(flag))) != 0 }\n%.*s\000 (mut e  %.*s\000) set(flag %.*s\000)      { unsafe{ *e = int(*e) |  (int(flag)) } }\n%.*s\000 (mut e  %.*s\000) clear(flag %.*s\000)    { unsafe{ *e = int(*e) & ~(int(flag)) } }\n%.*s\000 (mut e  %.*s\000) toggle(flag %.*s\000)   { unsafe{ *e = int(*e) ^  (int(flag)) } }\n//\n", 13, pubfn, enum_name, enum_name, pubfn, enum_name, enum_name, pubfn, enum_name, enum_name, pubfn, enum_name, enum_name));
	}
	v__table__Table_register_type_symbol(p->table, (v__table__TypeSymbol){.parent_idx = 0,.info = /* sum type cast 4 */ (v__table__TypeInfo){._355 = memdup(&(v__table__Enum[]){(v__table__Enum){.vals = vals,.is_flag = is_flag,.is_multi_allowed = is_multi_allowed,}}, sizeof(v__table__Enum)), .typ = 355 /* v.table.Enum */},.kind = v__table__Kind_enum_,.name = name,.source_name = name,.methods = __new_array(0, 1, sizeof(v__table__Fn)),.mod = p->mod,.is_public = 0,.is_written = 0,.language = 0,});
	return (v__ast__EnumDecl){
		.name = name,
		.is_pub = is_pub,
		.is_flag = is_flag,
		.is_multi_allowed = is_multi_allowed,
		.comments = enum_decl_comments,
		.fields = fields,
		.attrs = p->attrs,
		.pos = v__token__Position_extend(start_pos, end_pos),
	};
}

VV_LOCAL_SYMBOL v__ast__TypeDecl v__parser__Parser_type_decl(v__parser__Parser* p) {
	v__token__Position start_pos = v__token__Token_position(&p->tok);
	bool is_pub = p->tok.kind == v__token__Kind_key_pub;
	if (is_pub) {
		v__parser__Parser_next(p);
	}
	v__parser__Parser_check(p, v__token__Kind_key_type);
	v__token__Position end_pos = v__token__Token_position(&p->tok);
	v__token__Position decl_pos = v__token__Position_extend(start_pos, end_pos);
	string name = v__parser__Parser_check_name(p);
	if (name.len == 1 && byte_is_capital(string_at(name, 0))) {
		v__parser__Parser_error_with_pos(p, tos_lit("single letter capital names are reserved for generic template types."), decl_pos);
	}
	array_v__ast__SumTypeVariant sum_variants = __new_array_with_default(0, 0, sizeof(v__ast__SumTypeVariant), 0);
	v__parser__Parser_check(p, v__token__Kind_assign);
	v__token__Position type_pos = v__token__Token_position(&p->tok);
	array_v__ast__Comment comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	if (p->tok.kind == v__token__Kind_key_fn) {
		string fn_name = v__parser__Parser_prepend_mod(p, name);
		v__table__Type fn_type = v__parser__Parser_parse_fn_type(p, fn_name);
		comments = v__parser__Parser_eat_lineend_comments(p);
		return /* sum type cast 4 */ (v__ast__TypeDecl){._205 = memdup(&(v__ast__FnTypeDecl[]){(v__ast__FnTypeDecl){.name = fn_name,.is_pub = is_pub,.typ = fn_type,.pos = decl_pos,.comments = comments,}}, sizeof(v__ast__FnTypeDecl)), .typ = 205 /* v.ast.FnTypeDecl */};
	}
	v__table__Type first_type = v__parser__Parser_parse_type(p);
	if (p->tok.kind == v__token__Kind_pipe) {
		v__token__Position type_end_pos = v__token__Token_position(&p->prev_tok);
		type_pos = v__token__Position_extend(type_pos, type_end_pos);
		v__parser__Parser_next(p);
		array_push(&sum_variants, _MOV((v__ast__SumTypeVariant[]){ (v__ast__SumTypeVariant){.typ = first_type,.pos = type_pos,} }));
		for (;;) {
			type_pos = v__token__Token_position(&p->tok);
			v__table__Type variant_type = v__parser__Parser_parse_type(p);
			v__token__Token prev_tok = p->prev_tok;
			type_end_pos = v__token__Token_position(&prev_tok);
			type_pos = v__token__Position_extend(type_pos, type_end_pos);
			array_push(&sum_variants, _MOV((v__ast__SumTypeVariant[]){ (v__ast__SumTypeVariant){.typ = variant_type,.pos = type_pos,} }));
			if (p->tok.kind != v__token__Kind_pipe) {
				break;
			}
			v__parser__Parser_check(p, v__token__Kind_pipe);
		}

		int _t1262_len = sum_variants.len;
		array_v__table__Type _t1262 = __new_array(0, _t1262_len, sizeof(v__table__Type));
		for (int _t1263 = 0; _t1263 < _t1262_len; ++_t1263) {
			v__ast__SumTypeVariant it = ((v__ast__SumTypeVariant*) sum_variants.data)[_t1263];
			v__table__Type ti = it.typ;
			array_push(&_t1262, &ti);
		}
				array_v__table__Type variant_types = _t1262;
		string prepend_mod_name = v__parser__Parser_prepend_mod(p, name);
		v__table__Table_register_type_symbol(p->table, (v__table__TypeSymbol){
			.parent_idx = 0,
			.info = /* sum type cast 4 */ (v__table__TypeInfo){._354 = memdup(&(v__table__SumType[]){(v__table__SumType){.variants = variant_types,}}, sizeof(v__table__SumType)), .typ = 354 /* v.table.SumType */},
			.kind = v__table__Kind_sum_type,
			.name = prepend_mod_name,
			.source_name = prepend_mod_name,
			.methods = __new_array(0, 1, sizeof(v__table__Fn)),
			.mod = p->mod,
			.is_public = is_pub,
			.is_written = 0,
			.language = 0,
		});
		comments = v__parser__Parser_eat_lineend_comments(p);
		return /* sum type cast 4 */ (v__ast__TypeDecl){._206 = memdup(&(v__ast__SumTypeDecl[]){(v__ast__SumTypeDecl){.name = name,.is_pub = is_pub,.pos = decl_pos,.comments = comments,.variants = sum_variants,}}, sizeof(v__ast__SumTypeDecl)), .typ = 206 /* v.ast.SumTypeDecl */};
	}
	v__table__Type parent_type = first_type;
	string parent_name = v__table__Table_get_type_symbol(p->table, parent_type)->name;
	int pid = v__table__Type_idx(parent_type);
	v__table__Language language = (parent_name.len > 2 && string_starts_with(parent_name, tos_lit("C.")) ? (v__table__Language_c) : parent_name.len > 2 && string_starts_with(parent_name, tos_lit("JS.")) ? (v__table__Language_js) : (v__table__Language_v));
	string prepend_mod_name = v__parser__Parser_prepend_mod(p, name);
	v__table__Table_register_type_symbol(p->table, (v__table__TypeSymbol){
		.parent_idx = pid,
		.info = /* sum type cast 4 */ (v__table__TypeInfo){._347 = memdup(&(v__table__Alias[]){(v__table__Alias){.parent_type = parent_type,.language = language,.is_import = 0,}}, sizeof(v__table__Alias)), .typ = 347 /* v.table.Alias */},
		.kind = v__table__Kind_alias,
		.name = prepend_mod_name,
		.source_name = prepend_mod_name,
		.methods = __new_array(0, 1, sizeof(v__table__Fn)),
		.mod = p->mod,
		.is_public = is_pub,
		.is_written = 0,
		.language = 0,
	});
	comments = v__parser__Parser_eat_lineend_comments(p);
	return /* sum type cast 4 */ (v__ast__TypeDecl){._204 = memdup(&(v__ast__AliasTypeDecl[]){(v__ast__AliasTypeDecl){.name = name,.is_pub = is_pub,.parent_type = parent_type,.pos = decl_pos,.comments = comments,}}, sizeof(v__ast__AliasTypeDecl)), .typ = 204 /* v.ast.AliasTypeDecl */};
}

VV_LOCAL_SYMBOL v__ast__Assoc v__parser__Parser_assoc(v__parser__Parser* p) {
	string var_name = v__parser__Parser_check_name(p);
	v__token__Position pos = v__token__Token_position(&p->tok);
	Option_v__ast__Var_ptr _t1264 = v__ast__Scope_find_var(p->scope, var_name);
	if (!_t1264.ok) {
		string err = _t1264.v_error;
		int errcode = _t1264.ecode;
		v__parser__Parser_error(p, _STR("unknown variable `%.*s\000`", 2, var_name));
		return (v__ast__Assoc){.var_name = (string){.str=(byteptr)""},.fields = __new_array(0, 1, sizeof(string)),.exprs = __new_array(0, 1, sizeof(v__ast__Expr)),.pos = {0},.typ = 0,};
	}
 	v__ast__Var* v = *(v__ast__Var**) _t1264.data;
	v->is_used = true;
	array_string fields = __new_array_with_default(0, 0, sizeof(string), 0);
	array_v__ast__Expr vals = __new_array_with_default(0, 0, sizeof(v__ast__Expr), 0);
	v__parser__Parser_check(p, v__token__Kind_pipe);
	for (;;) {
		array_push(&fields, _MOV((string[]){ string_clone(v__parser__Parser_check_name(p)) }));
		v__parser__Parser_check(p, v__token__Kind_colon);
		v__ast__Expr expr = v__parser__Parser_expr(p, 0);
		array_push(&vals, _MOV((v__ast__Expr[]){ expr }));
		if (p->tok.kind == v__token__Kind_comma) {
			v__parser__Parser_next(p);
		}
		if (p->tok.kind == v__token__Kind_rcbr) {
			break;
		}
	}
	return (v__ast__Assoc){.var_name = var_name,.fields = fields,.exprs = vals,.pos = pos,.typ = 0,};
}

VV_LOCAL_SYMBOL v__ast__Expr v__parser__Parser_new_true_expr(v__parser__Parser* p) {
	return /* sum type cast 4 */ (v__ast__Expr){._213 = memdup(&(v__ast__BoolLiteral[]){(v__ast__BoolLiteral){.val = true,.pos = v__token__Token_position(&p->tok),}}, sizeof(v__ast__BoolLiteral)), .typ = 213 /* v.ast.BoolLiteral */};
}

VV_LOCAL_SYMBOL void v__parser__verror(string s) {
	v__util__verror(tos_lit("parser error"), s);
}

VV_LOCAL_SYMBOL void v__parser__Parser_top_level_statement_start(v__parser__Parser* p) {
	if (p->comments_mode == v__scanner__CommentsMode_toplevel_comments) {
		v__scanner__Scanner_set_is_inside_toplevel_statement(p->scanner, true);
		v__parser__Parser_rewind_scanner_to_current_token_in_new_mode(p);
		#if defined(CUSTOM_DEFINE_debugscanner)
		{
		}
		#endif
	}
}

VV_LOCAL_SYMBOL void v__parser__Parser_top_level_statement_end(v__parser__Parser* p) {
	if (p->comments_mode == v__scanner__CommentsMode_toplevel_comments) {
		v__scanner__Scanner_set_is_inside_toplevel_statement(p->scanner, false);
		v__parser__Parser_rewind_scanner_to_current_token_in_new_mode(p);
		#if defined(CUSTOM_DEFINE_debugscanner)
		{
		}
		#endif
	}
}

VV_LOCAL_SYMBOL void v__parser__Parser_rewind_scanner_to_current_token_in_new_mode(v__parser__Parser* p) {
	int tidx = p->tok.tidx;
	v__scanner__Scanner_set_current_tidx(p->scanner, tidx - 5);
	v__token__Token no_token = (v__token__Token){.kind = 0,.lit = (string){.str=(byteptr)""},.line_nr = 0,.pos = 0,.len = 0,.tidx = 0,};
	p->prev_tok = no_token;
	p->tok = no_token;
	p->peek_tok = no_token;
	p->peek_tok2 = no_token;
	p->peek_tok3 = no_token;
	for (;;) {
		v__parser__Parser_next(p);
		if (tidx == p->tok.tidx) {
			break;
		}
	}
}

bool v__parser__Parser_mark_var_as_used(v__parser__Parser* p, string varname) {
	{ /* if guard */ 
	Option_v__ast__ScopeObject _t1267;
	if (_t1267 = v__ast__Scope_find(p->scope, varname), _t1267.ok) {
		v__ast__ScopeObject obj = *(v__ast__ScopeObject*)_t1267.data;
		v__ast__ScopeObject _t1268 = obj;
		if (_t1268.typ == 277 /* v.ast.Var */) {
			(*obj._277).is_used = true;
			return true;
		} else {
		};
	}}
	return false;
}

VV_LOCAL_SYMBOL v__ast__Stmt v__parser__Parser_unsafe_stmt(v__parser__Parser* p) {
	v__token__Position pos = v__token__Token_position(&p->tok);
	v__parser__Parser_next(p);
	if (p->tok.kind != v__token__Kind_lcbr) {
		v__parser__Parser_error_with_pos(p, tos_lit("please use `unsafe {`"), v__token__Token_position(&p->tok));
	}
	v__parser__Parser_next(p);
	if (p->inside_unsafe) {
		v__parser__Parser_error_with_pos(p, tos_lit("already inside `unsafe` block"), pos);
	}
	if (p->tok.kind == v__token__Kind_rcbr) {
		v__parser__Parser_next(p);
		return /* sum type cast 4 */ (v__ast__Stmt){._253 = memdup(&(v__ast__Block[]){(v__ast__Block){.stmts = __new_array(0, 1, sizeof(v__ast__Stmt)),.is_unsafe = true,.pos = pos,}}, sizeof(v__ast__Block)), .typ = 253 /* v.ast.Block */};
	}
	p->inside_unsafe = true;
	v__parser__Parser_open_scope(p);
	v__ast__Stmt stmt = v__parser__Parser_stmt(p, false);
	if (p->tok.kind == v__token__Kind_rcbr) {
		if ((stmt).typ == 259 /* v.ast.ExprStmt */) {
			if (v__ast__Expr_is_expr((*stmt._259).expr)) {
				v__parser__Parser_next(p);
				v__ast__UnsafeExpr ue = (v__ast__UnsafeExpr){.expr = (*stmt._259).expr,.pos = pos,};
				v__ast__Expr expr = v__parser__Parser_expr_with_left(p, /* sum type cast 4 */ (v__ast__Expr){._249 = memdup(&(v__ast__UnsafeExpr[]){ue}, sizeof(v__ast__UnsafeExpr)), .typ = 249 /* v.ast.UnsafeExpr */}, 0, p->is_stmt_ident);
				// Defer begin
				p->inside_unsafe = false;
				v__parser__Parser_close_scope(p);
				// Defer end
				return /* sum type cast 4 */ (v__ast__Stmt){._259 = memdup(&(v__ast__ExprStmt[]){(v__ast__ExprStmt){.expr = expr,.pos = pos,.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.is_expr = 0,.typ = 0,}}, sizeof(v__ast__ExprStmt)), .typ = 259 /* v.ast.ExprStmt */};
			}
		}
	}
	array_v__ast__Stmt stmts = new_array_from_c_array(1, 1, sizeof(v__ast__Stmt), _MOV((v__ast__Stmt[1]){stmt}));
	for (;;) {
		if (!(p->tok.kind != v__token__Kind_rcbr)) break;
		array_push(&stmts, _MOV((v__ast__Stmt[]){ v__parser__Parser_stmt(p, false) }));
	}
	v__parser__Parser_next(p);
	// Defer begin
	p->inside_unsafe = false;
	v__parser__Parser_close_scope(p);
	// Defer end
	return /* sum type cast 4 */ (v__ast__Stmt){._253 = memdup(&(v__ast__Block[]){(v__ast__Block){.stmts = stmts,.is_unsafe = true,.pos = pos,}}, sizeof(v__ast__Block)), .typ = 253 /* v.ast.Block */};
}

VV_LOCAL_SYMBOL void v__parser__Parser_trace(v__parser__Parser* p, string fbase, string message) {
	if (string_eq(p->file_base, fbase)) {
		println(_STR("> p.trace | %*.*s\000 | %.*s", 2, fbase, -10, message));
	}
}

v__ast__Expr v__parser__Parser_expr(v__parser__Parser* p, int precedence) {
	#if defined(CUSTOM_DEFINE_trace_parser)
	{
	}
	#endif
	v__ast__Expr node = (v__ast__Expr){
#ifndef __cplusplus
0
#endif
};
	bool is_stmt_ident = p->is_stmt_ident;
	p->is_stmt_ident = false;
	if (!p->pref->is_fmt) {
		v__parser__Parser_eat_comments(p);
	}
	v__token__Kind _t1270 = p->tok.kind;
	if (_t1270 == v__token__Kind_key_mut || _t1270 == v__token__Kind_key_shared || _t1270 == v__token__Kind_key_atomic || _t1270 == v__token__Kind_key_static) {
		node = v__parser__Parser_name_expr(p);
		p->is_stmt_ident = is_stmt_ident;
	} else if (_t1270 == v__token__Kind_name) {
		if (string_eq(p->tok.lit, tos_lit("sql")) && p->peek_tok.kind == v__token__Kind_name) {
			p->inside_match = true;
			node = v__parser__Parser_sql_expr(p);
			p->inside_match = false;
		} else {
			node = v__parser__Parser_name_expr(p);
			p->is_stmt_ident = is_stmt_ident;
		}
	} else if (_t1270 == v__token__Kind_string) {
		node = v__parser__Parser_string_expr(p);
	} else if (_t1270 == v__token__Kind_comment) {
		node = /* sum type cast 4 */ (v__ast__Expr){._219 = memdup(&(v__ast__Comment[]){v__parser__Parser_comment(p)}, sizeof(v__ast__Comment)), .typ = 219 /* v.ast.Comment */};
	} else if (_t1270 == v__token__Kind_dot) {
		node = /* sum type cast 4 */ (v__ast__Expr){._222 = memdup(&(v__ast__EnumVal[]){v__parser__Parser_enum_val(p)}, sizeof(v__ast__EnumVal)), .typ = 222 /* v.ast.EnumVal */};
	} else if (_t1270 == v__token__Kind_at) {
		node = /* sum type cast 4 */ (v__ast__Expr){._212 = memdup(&(v__ast__AtExpr[]){v__parser__Parser_at(p)}, sizeof(v__ast__AtExpr)), .typ = 212 /* v.ast.AtExpr */};
	} else if (_t1270 == v__token__Kind_dollar) {
		v__token__Kind _t1271 = p->peek_tok.kind;
		if (_t1271 == v__token__Kind_name) {
			return /* sum type cast 4 */ (v__ast__Expr){._220 = memdup(&(v__ast__ComptimeCall[]){v__parser__Parser_vweb(p)}, sizeof(v__ast__ComptimeCall)), .typ = 220 /* v.ast.ComptimeCall */};
		} else if (_t1271 == v__token__Kind_key_if) {
			return /* sum type cast 4 */ (v__ast__Expr){._225 = memdup(&(v__ast__IfExpr[]){v__parser__Parser_if_expr(p, true)}, sizeof(v__ast__IfExpr)), .typ = 225 /* v.ast.IfExpr */};
		} else {
			v__parser__Parser_error_with_pos(p, tos_lit("unexpected `$`"), v__token__Token_position(&p->peek_tok));
		};
	} else if (_t1270 == v__token__Kind_chartoken) {
		node = /* sum type cast 4 */ (v__ast__Expr){._218 = memdup(&(v__ast__CharLiteral[]){(v__ast__CharLiteral){.val = p->tok.lit,.pos = v__token__Token_position(&p->tok),}}, sizeof(v__ast__CharLiteral)), .typ = 218 /* v.ast.CharLiteral */};
		v__parser__Parser_next(p);
	} else if (_t1270 == v__token__Kind_minus || _t1270 == v__token__Kind_amp || _t1270 == v__token__Kind_mul || _t1270 == v__token__Kind_not || _t1270 == v__token__Kind_bit_not || _t1270 == v__token__Kind_arrow) {
		node = /* sum type cast 4 */ (v__ast__Expr){._238 = memdup(&(v__ast__PrefixExpr[]){v__parser__Parser_prefix_expr(p)}, sizeof(v__ast__PrefixExpr)), .typ = 238 /* v.ast.PrefixExpr */};
	} else if (_t1270 == v__token__Kind_key_true || _t1270 == v__token__Kind_key_false) {
		node = /* sum type cast 4 */ (v__ast__Expr){._213 = memdup(&(v__ast__BoolLiteral[]){(v__ast__BoolLiteral){.val = p->tok.kind == v__token__Kind_key_true,.pos = v__token__Token_position(&p->tok),}}, sizeof(v__ast__BoolLiteral)), .typ = 213 /* v.ast.BoolLiteral */};
		v__parser__Parser_next(p);
	} else if (_t1270 == v__token__Kind_key_match) {
		node = /* sum type cast 4 */ (v__ast__Expr){._233 = memdup(&(v__ast__MatchExpr[]){v__parser__Parser_match_expr(p)}, sizeof(v__ast__MatchExpr)), .typ = 233 /* v.ast.MatchExpr */};
	} else if (_t1270 == v__token__Kind_key_select) {
		node = /* sum type cast 4 */ (v__ast__Expr){._240 = memdup(&(v__ast__SelectExpr[]){v__parser__Parser_select_expr(p)}, sizeof(v__ast__SelectExpr)), .typ = 240 /* v.ast.SelectExpr */};
	} else if (_t1270 == v__token__Kind_number) {
		node = v__parser__Parser_parse_number_literal(p);
	} else if (_t1270 == v__token__Kind_lpar) {
		v__parser__Parser_check(p, v__token__Kind_lpar);
		node = v__parser__Parser_expr(p, 0);
		v__parser__Parser_check(p, v__token__Kind_rpar);
		node = /* sum type cast 4 */ (v__ast__Expr){._236 = memdup(&(v__ast__ParExpr[]){(v__ast__ParExpr){.expr = node,.pos = v__token__Token_position(&p->tok),}}, sizeof(v__ast__ParExpr)), .typ = 236 /* v.ast.ParExpr */};
	} else if (_t1270 == v__token__Kind_key_if) {
		node = /* sum type cast 4 */ (v__ast__Expr){._225 = memdup(&(v__ast__IfExpr[]){v__parser__Parser_if_expr(p, false)}, sizeof(v__ast__IfExpr)), .typ = 225 /* v.ast.IfExpr */};
	} else if (_t1270 == v__token__Kind_key_unsafe) {
		v__token__Position pos = v__token__Token_position(&p->tok);
		v__parser__Parser_next(p);
		if (p->inside_unsafe) {
			v__parser__Parser_error_with_pos(p, tos_lit("already inside `unsafe` block"), pos);
		}
		p->inside_unsafe = true;
		v__parser__Parser_check(p, v__token__Kind_lcbr);
		node = /* sum type cast 4 */ (v__ast__Expr){._249 = memdup(&(v__ast__UnsafeExpr[]){(v__ast__UnsafeExpr){.expr = v__parser__Parser_expr(p, 0),.pos = pos,}}, sizeof(v__ast__UnsafeExpr)), .typ = 249 /* v.ast.UnsafeExpr */};
		v__parser__Parser_check(p, v__token__Kind_rcbr);
		p->inside_unsafe = false;
	} else if (_t1270 == v__token__Kind_key_lock || _t1270 == v__token__Kind_key_rlock) {
		node = /* sum type cast 4 */ (v__ast__Expr){._231 = memdup(&(v__ast__LockExpr[]){v__parser__Parser_lock_expr(p)}, sizeof(v__ast__LockExpr)), .typ = 231 /* v.ast.LockExpr */};
	} else if (_t1270 == v__token__Kind_lsbr) {
		if (p->expecting_type) {
			node = v__parser__Parser_name_expr(p);
		} else {
			node = /* sum type cast 4 */ (v__ast__Expr){._209 = memdup(&(v__ast__ArrayInit[]){v__parser__Parser_array_init(p)}, sizeof(v__ast__ArrayInit)), .typ = 209 /* v.ast.ArrayInit */};
		}
	} else if (_t1270 == v__token__Kind_key_none) {
		v__token__Position pos = v__token__Token_position(&p->tok);
		v__parser__Parser_next(p);
		node = /* sum type cast 4 */ (v__ast__Expr){._234 = memdup(&(v__ast__None[]){(v__ast__None){.pos = pos,.foo = 0,}}, sizeof(v__ast__None)), .typ = 234 /* v.ast.None */};
	} else if (_t1270 == v__token__Kind_key_sizeof) {
		v__token__Position pos = v__token__Token_position(&p->tok);
		v__parser__Parser_next(p);
		v__parser__Parser_check(p, v__token__Kind_lpar);
		bool is_known_var = v__parser__Parser_mark_var_as_used(p, p->tok.lit);
		if (is_known_var) {
			v__ast__Ident expr = v__parser__Parser_parse_ident(p, v__table__Language_v);
			node = /* sum type cast 4 */ (v__ast__Expr){._242 = memdup(&(v__ast__SizeOf[]){(v__ast__SizeOf){.is_type = false,.typ = 0,.type_name = (string){.str=(byteptr)""},.expr = /* sum type cast 4 */ (v__ast__Expr){._224 = memdup(&(v__ast__Ident[]){expr}, sizeof(v__ast__Ident)), .typ = 224 /* v.ast.Ident */},.pos = pos,}}, sizeof(v__ast__SizeOf)), .typ = 242 /* v.ast.SizeOf */};
		} else {
			string save_expr_mod = p->expr_mod;
			p->expr_mod = tos_lit("");
			v__table__Type sizeof_type = v__parser__Parser_parse_type(p);
			p->expr_mod = save_expr_mod;
			node = /* sum type cast 4 */ (v__ast__Expr){._242 = memdup(&(v__ast__SizeOf[]){(v__ast__SizeOf){.is_type = true,.typ = sizeof_type,.type_name = v__table__Table_get_type_symbol(p->table, sizeof_type)->name,.expr = {0},.pos = pos,}}, sizeof(v__ast__SizeOf)), .typ = 242 /* v.ast.SizeOf */};
		}
		v__parser__Parser_check(p, v__token__Kind_rpar);
	} else if (_t1270 == v__token__Kind_key_typeof) {
		v__token__Position spos = v__token__Token_position(&p->tok);
		v__parser__Parser_next(p);
		v__parser__Parser_check(p, v__token__Kind_lpar);
		v__ast__Expr expr = v__parser__Parser_expr(p, 0);
		v__parser__Parser_check(p, v__token__Kind_rpar);
		node = /* sum type cast 4 */ (v__ast__Expr){._248 = memdup(&(v__ast__TypeOf[]){(v__ast__TypeOf){.expr = expr,.pos = v__token__Position_extend(spos, v__token__Token_position(&p->tok)),.expr_type = 0,}}, sizeof(v__ast__TypeOf)), .typ = 248 /* v.ast.TypeOf */};
	} else if (_t1270 == v__token__Kind_key_likely || _t1270 == v__token__Kind_key_unlikely) {
		bool is_likely = p->tok.kind == v__token__Kind_key_likely;
		v__parser__Parser_next(p);
		v__parser__Parser_check(p, v__token__Kind_lpar);
		v__token__Position lpos = v__token__Token_position(&p->tok);
		v__ast__Expr expr = v__parser__Parser_expr(p, 0);
		v__parser__Parser_check(p, v__token__Kind_rpar);
		node = /* sum type cast 4 */ (v__ast__Expr){._230 = memdup(&(v__ast__Likely[]){(v__ast__Likely){.expr = expr,.pos = lpos,.is_likely = is_likely,}}, sizeof(v__ast__Likely)), .typ = 230 /* v.ast.Likely */};
	} else if (_t1270 == v__token__Kind_lcbr) {
		v__parser__Parser_next(p);
		if (p->tok.kind == v__token__Kind_string) {
			node = /* sum type cast 4 */ (v__ast__Expr){._232 = memdup(&(v__ast__MapInit[]){v__parser__Parser_map_init(p)}, sizeof(v__ast__MapInit)), .typ = 232 /* v.ast.MapInit */};
		} else {
			if (p->peek_tok.kind == v__token__Kind_pipe) {
				node = /* sum type cast 4 */ (v__ast__Expr){._211 = memdup(&(v__ast__Assoc[]){v__parser__Parser_assoc(p)}, sizeof(v__ast__Assoc)), .typ = 211 /* v.ast.Assoc */};
			} else if (p->peek_tok.kind == v__token__Kind_colon || p->tok.kind == v__token__Kind_rcbr) {
				node = /* sum type cast 4 */ (v__ast__Expr){._246 = memdup(&(v__ast__StructInit[]){v__parser__Parser_struct_init(p, true)}, sizeof(v__ast__StructInit)), .typ = 246 /* v.ast.StructInit */};
			} else if (p->tok.kind == v__token__Kind_name) {
				v__parser__Parser_next(p);
				string s = ((p->tok.lit).len != 0 ? (_STR("`%.*s\000`", 2, p->tok.lit)) : (v__token__Kind_str(p->tok.kind)));
				v__parser__Parser_error_with_pos(p, _STR("unexpected %.*s\000, expecting `:`", 2, s), v__token__Token_position(&p->tok));
			} else {
				v__parser__Parser_error_with_pos(p, _STR("unexpected `%.*s\000`, expecting struct key", 2, p->tok.lit), v__token__Token_position(&p->tok));
			}
		}
		v__parser__Parser_check(p, v__token__Kind_rcbr);
	} else if (_t1270 == v__token__Kind_key_fn) {
		if (p->expecting_type) {
			v__token__Position start_pos = v__token__Token_position(&p->tok);
			return /* sum type cast 4 */ (v__ast__Expr){._247 = memdup(&(v__ast__Type[]){(v__ast__Type){.typ = v__parser__Parser_parse_type(p),.pos = v__token__Position_extend(start_pos, v__token__Token_position(&p->prev_tok)),}}, sizeof(v__ast__Type)), .typ = 247 /* v.ast.Type */};
		} else {
			node = /* sum type cast 4 */ (v__ast__Expr){._208 = memdup(&(v__ast__AnonFn[]){v__parser__Parser_anon_fn(p)}, sizeof(v__ast__AnonFn)), .typ = 208 /* v.ast.AnonFn */};
			if (p->tok.kind == v__token__Kind_lpar) {
				v__parser__Parser_next(p);
				v__token__Position pos = v__token__Token_position(&p->tok);
				array_v__ast__CallArg args = v__parser__Parser_call_args(p);
				v__parser__Parser_check(p, v__token__Kind_rpar);
				node = /* sum type cast 4 */ (v__ast__Expr){._215 = memdup(&(v__ast__CallExpr[]){(v__ast__CallExpr){.pos = pos,.left = node,.mod = (string){.str=(byteptr)""},.name = tos_lit("anon"),.is_method = 0,.is_field = 0,.args = args,.expected_arg_types = __new_array(0, 1, sizeof(v__table__Type)),.language = 0,.or_block = {0},.left_type = 0,.receiver_type = 0,.return_type = 0,.should_be_skipped = 0,.generic_type = 0,.generic_list_pos = {0},.free_receiver = 0,}}, sizeof(v__ast__CallExpr)), .typ = 215 /* v.ast.CallExpr */};
			}
			return node;
		}
	} else {
		v__parser__Parser_error_with_pos(p, _STR("invalid expression: unexpected %.*s\000 token", 2, v__token__Kind_str(p->tok.kind)), v__token__Token_position(&p->tok));
	};
	return v__parser__Parser_expr_with_left(p, node, precedence, is_stmt_ident);
}

v__ast__Expr v__parser__Parser_expr_with_left(v__parser__Parser* p, v__ast__Expr left, int precedence, bool is_stmt_ident) {
	v__ast__Expr node = left;
	for (;;) {
		if (!(precedence < v__token__Token_precedence(p->tok))) break;
		if (p->tok.kind == v__token__Kind_dot) {
			node = v__parser__Parser_dot_expr(p, node);
			p->is_stmt_ident = is_stmt_ident;
		} else if (p->tok.kind == v__token__Kind_lsbr) {
			node = /* sum type cast 4 */ (v__ast__Expr){._227 = memdup(&(v__ast__IndexExpr[]){v__parser__Parser_index_expr(p, node)}, sizeof(v__ast__IndexExpr)), .typ = 227 /* v.ast.IndexExpr */};
			p->is_stmt_ident = is_stmt_ident;
		} else if (p->tok.kind == v__token__Kind_key_as) {
			v__token__Position pos = v__token__Token_position(&p->tok);
			v__parser__Parser_next(p);
			v__table__Type typ = v__parser__Parser_parse_type(p);
			node = /* sum type cast 4 */ (v__ast__Expr){._210 = memdup(&(v__ast__AsCast[]){(v__ast__AsCast){.expr = node,.typ = typ,.pos = pos,.expr_type = 0,}}, sizeof(v__ast__AsCast)), .typ = 210 /* v.ast.AsCast */};
		} else if (p->tok.kind == v__token__Kind_left_shift && p->is_stmt_ident) {
			v__token__Token tok = p->tok;
			v__token__Position pos = v__token__Token_position(&tok);
			v__parser__Parser_next(p);
			v__ast__Expr right = v__parser__Parser_expr(p, precedence - 1);
			node = /* sum type cast 4 */ (v__ast__Expr){._228 = memdup(&(v__ast__InfixExpr[]){(v__ast__InfixExpr){.op = tok.kind,.pos = pos,.left = node,.right = right,.left_type = 0,.right_type = 0,.auto_locked = (string){.str=(byteptr)""},}}, sizeof(v__ast__InfixExpr)), .typ = 228 /* v.ast.InfixExpr */};
		} else if (v__token__Kind_is_infix(p->tok.kind)) {
			if (v__token__Kind_is_prefix(p->tok.kind) && p->tok.line_nr != p->prev_tok.line_nr) {
				if (p->tok.kind == v__token__Kind_mul && p->peek_tok2.kind == v__token__Kind_assign) {
					return node;
				}
				v__parser__Parser_warn_with_pos(p, _STR("move infix `%.*s\000` operator before new line (if infix intended) or use brackets for a prefix expression", 2, v__token__Kind_str(p->tok.kind)), v__token__Token_position(&p->tok));
			}
			node = v__parser__Parser_infix_expr(p, node);
			if (p->tok.kind == v__token__Kind_key_as && p->inside_if) {
				return node;
			}
		} else if ((p->tok.kind == v__token__Kind_inc || p->tok.kind == v__token__Kind_dec) || (p->tok.kind == v__token__Kind_question && p->inside_ct_if_expr)) {
			if ((p->peek_tok.kind == v__token__Kind_rpar || p->peek_tok.kind == v__token__Kind_rsbr) && !(string_eq(p->mod, tos_lit("builtin")) || string_eq(p->mod, tos_lit("regex")) || string_eq(p->mod, tos_lit("strconv")))) {
				v__parser__Parser_warn_with_pos(p, _STR("`%.*s\000` operator can only be used as a statement", 2, v__token__Kind_str(p->tok.kind)), v__token__Token_position(&p->peek_tok));
			}
			node = /* sum type cast 4 */ (v__ast__Expr){._237 = memdup(&(v__ast__PostfixExpr[]){(v__ast__PostfixExpr){.op = p->tok.kind,.expr = node,.pos = v__token__Token_position(&p->tok),.auto_locked = (string){.str=(byteptr)""},}}, sizeof(v__ast__PostfixExpr)), .typ = 237 /* v.ast.PostfixExpr */};
			v__parser__Parser_next(p);
		} else {
			return node;
		}
	}
	return node;
}

VV_LOCAL_SYMBOL v__ast__Expr v__parser__Parser_infix_expr(v__parser__Parser* p, v__ast__Expr left) {
	v__token__Kind op = p->tok.kind;
	if (op == v__token__Kind_arrow) {
		v__parser__Parser_register_auto_import(p, tos_lit("sync"));
	}
	int precedence = v__token__Token_precedence(p->tok);
	v__token__Position pos = v__token__Token_position(&p->tok);
	v__parser__Parser_next(p);
	v__ast__Expr right = (v__ast__Expr){
#ifndef __cplusplus
0
#endif
};
	bool prev_expecting_type = p->expecting_type;
	if ((op == v__token__Kind_key_is || op == v__token__Kind_not_is)) {
		p->expecting_type = true;
	}
	right = v__parser__Parser_expr(p, precedence);
	p->expecting_type = prev_expecting_type;
	if (p->pref->is_vet && (op == v__token__Kind_key_in || op == v__token__Kind_not_in) && (right).typ == 209 /* v.ast.ArrayInit */ && (/* as */ *(v__ast__ArrayInit*)__as_cast((right)._209, (right).typ, /*expected:*/209)).exprs.len == 1) {
		v__parser__Parser_vet_error(p, tos_lit("Use `var == value` instead of `var in [value]`"), pos.line_nr);
	}
	return /* sum type cast 4 */ (v__ast__Expr){._228 = memdup(&(v__ast__InfixExpr[]){(v__ast__InfixExpr){.op = op,.pos = pos,.left = left,.right = right,.left_type = 0,.right_type = 0,.auto_locked = (string){.str=(byteptr)""},}}, sizeof(v__ast__InfixExpr)), .typ = 228 /* v.ast.InfixExpr */};
}

VV_LOCAL_SYMBOL v__ast__PrefixExpr v__parser__Parser_prefix_expr(v__parser__Parser* p) {
	v__token__Position pos = v__token__Token_position(&p->tok);
	v__token__Kind op = p->tok.kind;
	if (op == v__token__Kind_amp) {
		p->is_amp = true;
	}
	if (op == v__token__Kind_arrow) {
		v__parser__Parser_register_auto_import(p, tos_lit("sync"));
	}
	v__parser__Parser_next(p);
	v__ast__Expr right = (op == v__token__Kind_minus ? (v__parser__Parser_expr(p, v__token__Precedence_call)) : (v__parser__Parser_expr(p, v__token__Precedence_prefix)));
	p->is_amp = false;
	if ((right).typ == 216 /* v.ast.CastExpr */) {
		(*right._216).in_prexpr = true;
	}
	array_v__ast__Stmt or_stmts = __new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
	v__ast__OrKind or_kind = v__ast__OrKind_absent;
	v__token__Position or_pos = v__token__Token_position(&p->tok);
	if (op == v__token__Kind_arrow) {
		if (p->tok.kind == v__token__Kind_key_orelse) {
			v__parser__Parser_next(p);
			v__parser__Parser_open_scope(p);
			v__ast__Scope_register(p->scope, tos_lit("errcode"), /* sum type cast 4 */ (v__ast__ScopeObject){._277 = memdup(&(v__ast__Var[]){(v__ast__Var){.name = tos_lit("errcode"),.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.typ = _const_v__table__int_type,.sum_type_casts = __new_array(0, 1, sizeof(v__table__Type)),.pos = v__token__Token_position(&p->tok),.is_used = true,.is_changed = 0,}}, sizeof(v__ast__Var)), .typ = 277 /* v.ast.Var */});
			v__ast__Scope_register(p->scope, tos_lit("err"), /* sum type cast 4 */ (v__ast__ScopeObject){._277 = memdup(&(v__ast__Var[]){(v__ast__Var){.name = tos_lit("err"),.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = 0,.is_arg = 0,.typ = _const_v__table__string_type,.sum_type_casts = __new_array(0, 1, sizeof(v__table__Type)),.pos = v__token__Token_position(&p->tok),.is_used = true,.is_changed = 0,}}, sizeof(v__ast__Var)), .typ = 277 /* v.ast.Var */});
			or_kind = v__ast__OrKind_block;
			or_stmts = v__parser__Parser_parse_block_no_scope(p, false);
			or_pos = v__token__Position_extend(or_pos, v__token__Token_position(&p->prev_tok));
			v__parser__Parser_close_scope(p);
		}
		if (p->tok.kind == v__token__Kind_question) {
			v__parser__Parser_next(p);
			or_kind = v__ast__OrKind_propagate;
		}
	}
	return (v__ast__PrefixExpr){.op = op,.right = right,.pos = pos,.right_type = 0,.or_block = (v__ast__OrExpr){.stmts = or_stmts,.kind = or_kind,.pos = or_pos,},};
}

VV_LOCAL_SYMBOL v__ast__Expr v__parser__Parser_sql_expr(v__parser__Parser* p) {
	v__token__Position pos = v__token__Token_position(&p->tok);
	v__parser__Parser_check_name(p);
	v__ast__Expr db_expr = v__parser__Parser_expr(p, 0);
	v__parser__Parser_check(p, v__token__Kind_lcbr);
	v__parser__Parser_check(p, v__token__Kind_key_select);
	string n = v__parser__Parser_check_name(p);
	bool is_count = string_eq(n, tos_lit("count"));
	v__table__Type typ = _const_v__table__void_type;
	if (is_count) {
		v__parser__Parser_check_name(p);
		typ = _const_v__table__int_type;
	}
	v__table__Type table_type = v__parser__Parser_parse_type(p);
	v__ast__Expr where_expr = (v__ast__Expr){
#ifndef __cplusplus
0
#endif
};
	bool has_where = p->tok.kind == v__token__Kind_name && string_eq(p->tok.lit, tos_lit("where"));
	bool query_one = false;
	if (has_where) {
		v__parser__Parser_next(p);
		where_expr = v__parser__Parser_expr(p, 0);
		if (!is_count && (where_expr).typ == 228 /* v.ast.InfixExpr */) {
			v__ast__InfixExpr e = /* as */ *(v__ast__InfixExpr*)__as_cast((where_expr)._228, (where_expr).typ, /*expected:*/228);
			if (e.op == v__token__Kind_eq && (e.left).typ == 224 /* v.ast.Ident */) {
				v__ast__Ident ident = /* as */ *(v__ast__Ident*)__as_cast((e.left)._224, (e.left).typ, /*expected:*/224);
				if (string_eq(ident.name, tos_lit("id"))) {
					query_one = true;
				}
			}
		}
	}
	bool has_limit = false;
	v__ast__Expr limit_expr = (v__ast__Expr){
#ifndef __cplusplus
0
#endif
};
	bool has_offset = false;
	v__ast__Expr offset_expr = (v__ast__Expr){
#ifndef __cplusplus
0
#endif
};
	bool has_order = false;
	v__ast__Expr order_expr = (v__ast__Expr){
#ifndef __cplusplus
0
#endif
};
	bool has_desc = false;
	if (p->tok.kind == v__token__Kind_name && string_eq(p->tok.lit, tos_lit("order"))) {
		v__parser__Parser_check_name(p);
		v__token__Position order_pos = v__token__Token_position(&p->tok);
		if (p->tok.kind == v__token__Kind_name && string_eq(p->tok.lit, tos_lit("by"))) {
			v__parser__Parser_check_name(p);
		} else {
			v__parser__Parser_error_with_pos(p, tos_lit("use `order by` in ORM queries"), order_pos);
		}
		has_order = true;
		order_expr = v__parser__Parser_expr(p, 0);
		if (p->tok.kind == v__token__Kind_name && string_eq(p->tok.lit, tos_lit("desc"))) {
			v__parser__Parser_check_name(p);
			has_desc = true;
		}
	}
	if (p->tok.kind == v__token__Kind_name && string_eq(p->tok.lit, tos_lit("limit"))) {
		v__parser__Parser_check_name(p);
		if (p->tok.kind == v__token__Kind_number && string_eq(p->tok.lit, tos_lit("1"))) {
			query_one = true;
		}
		has_limit = true;
		limit_expr = v__parser__Parser_expr(p, 0);
	}
	if (p->tok.kind == v__token__Kind_name && string_eq(p->tok.lit, tos_lit("offset"))) {
		v__parser__Parser_check_name(p);
		has_offset = true;
		offset_expr = v__parser__Parser_expr(p, 0);
	}
	if (!query_one && !is_count) {
		typ = v__table__new_type(v__table__Table_find_or_register_array(p->table, table_type, 1, p->mod));
	} else if (!is_count) {
		typ = table_type;
	}
	v__parser__Parser_check(p, v__token__Kind_rcbr);
	return /* sum type cast 4 */ (v__ast__Expr){._243 = memdup(&(v__ast__SqlExpr[]){(v__ast__SqlExpr){
		.typ = typ,
		.is_count = is_count,
		.db_expr = db_expr,
		.where_expr = where_expr,
		.has_where = has_where,
		.has_offset = has_offset,
		.offset_expr = offset_expr,
		.has_order = has_order,
		.order_expr = order_expr,
		.has_desc = has_desc,
		.is_array = !query_one,
		.table_type = table_type,
		.pos = pos,
		.has_limit = has_limit,
		.limit_expr = limit_expr,
		.table_name = (string){.str=(byteptr)""},
		.fields = __new_array(0, 1, sizeof(v__table__Field)),
	}}, sizeof(v__ast__SqlExpr)), .typ = 243 /* v.ast.SqlExpr */};
}

VV_LOCAL_SYMBOL v__ast__SqlStmt v__parser__Parser_sql_stmt(v__parser__Parser* p) {
	v__token__Position pos = v__token__Token_position(&p->tok);
	p->inside_match = true;
	v__parser__Parser_check_name(p);
	v__ast__Expr db_expr = v__parser__Parser_expr(p, 0);
	v__parser__Parser_check(p, v__token__Kind_lcbr);
	string n = v__parser__Parser_check_name(p);
	v__ast__SqlStmtKind kind = v__ast__SqlStmtKind_insert;
	if (string_eq(n, tos_lit("delete"))) {
		kind = v__ast__SqlStmtKind_delete;
	} else if (string_eq(n, tos_lit("update"))) {
		kind = v__ast__SqlStmtKind_update;
	}
	string inserted_var_name = tos_lit("");
	string table_name = tos_lit("");
	if (kind != v__ast__SqlStmtKind_delete) {
		v__ast__Expr expr = v__parser__Parser_expr(p, 0);
		v__ast__Expr _t1272 = expr;
		if (_t1272.typ == 224 /* v.ast.Ident */) {
			if (kind == v__ast__SqlStmtKind_insert) {
				inserted_var_name = (*expr._224).name;
			} else if (kind == v__ast__SqlStmtKind_update) {
				table_name = (*expr._224).name;
			}
		} else {
			v__parser__Parser_error(p, tos_lit("can only insert variables"));
		};
	}
	n = v__parser__Parser_check_name(p);
	array_string updated_columns = __new_array_with_default(0, 0, sizeof(string), 0);
	array_v__ast__Expr update_exprs = __new_array_with_default(0, 5, sizeof(v__ast__Expr), 0);
	if (kind == v__ast__SqlStmtKind_insert && string_ne(n, tos_lit("into"))) {
		v__parser__Parser_error(p, tos_lit("expecting `into`"));
	} else if (kind == v__ast__SqlStmtKind_update) {
		if (string_ne(n, tos_lit("set"))) {
			v__parser__Parser_error(p, tos_lit("expecting `set`"));
		}
		for (;;) {
			string column = v__parser__Parser_check_name(p);
			array_push(&updated_columns, _MOV((string[]){ string_clone(column) }));
			v__parser__Parser_check(p, v__token__Kind_assign);
			array_push(&update_exprs, _MOV((v__ast__Expr[]){ v__parser__Parser_expr(p, 0) }));
			if (p->tok.kind == v__token__Kind_comma) {
				v__parser__Parser_check(p, v__token__Kind_comma);
			} else {
				break;
			}
		}
	} else if (kind == v__ast__SqlStmtKind_delete && string_ne(n, tos_lit("from"))) {
		v__parser__Parser_error(p, tos_lit("expecting `from`"));
	}
	v__table__Type table_type = ((v__table__Type)(0));
	v__ast__Expr where_expr = (v__ast__Expr){
#ifndef __cplusplus
0
#endif
};
	if (kind == v__ast__SqlStmtKind_insert) {
		table_type = v__parser__Parser_parse_type(p);
		v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(p->table, table_type);
		table_name = sym->name;
	} else if (kind == v__ast__SqlStmtKind_update) {
		if (!p->pref->is_fmt) {
			int idx = v__table__Table_find_type_idx(p->table, v__parser__Parser_prepend_mod(p, table_name));
			table_type = v__table__new_type(idx);
		}
		v__parser__Parser_check_sql_keyword(p, tos_lit("where"));
		where_expr = v__parser__Parser_expr(p, 0);
	} else if (kind == v__ast__SqlStmtKind_delete) {
		table_type = v__parser__Parser_parse_type(p);
		v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(p->table, table_type);
		table_name = sym->name;
		v__parser__Parser_check_sql_keyword(p, tos_lit("where"));
		where_expr = v__parser__Parser_expr(p, 0);
	}
	v__parser__Parser_check(p, v__token__Kind_rcbr);
	// Defer begin
	p->inside_match = false;
	// Defer end
	return (v__ast__SqlStmt){
		.kind = kind,
		.db_expr = db_expr,
		.object_var_name = inserted_var_name,
		.table_type = table_type,
		.pos = pos,
		.where_expr = where_expr,
		.updated_columns = updated_columns,
		.update_exprs = update_exprs,
		.table_name = table_name,
		.fields = __new_array(0, 1, sizeof(v__table__Field)),
	};
}

VV_LOCAL_SYMBOL void v__parser__Parser_check_sql_keyword(v__parser__Parser* p, string name) {
	if (string_ne(v__parser__Parser_check_name(p), name)) {
		v__parser__Parser_error(p, _STR("orm: expecting `%.*s\000`", 2, name));
	}
}

VV_LOCAL_SYMBOL v__ast__StructDecl v__parser__Parser_struct_decl(v__parser__Parser* p) {
	v__parser__Parser_top_level_statement_start(p);
	array_v__table__Attr attrs = p->attrs;
	p->attrs = __new_array_with_default(0, 0, sizeof(v__table__Attr), 0);
	v__token__Position start_pos = v__token__Token_position(&p->tok);
	bool is_pub = p->tok.kind == v__token__Kind_key_pub;
	if (is_pub) {
		v__parser__Parser_next(p);
	}
	bool is_union = p->tok.kind == v__token__Kind_key_union;
	if (p->tok.kind == v__token__Kind_key_struct) {
		v__parser__Parser_next(p);
	} else {
		v__parser__Parser_check(p, v__token__Kind_key_union);
	}
	v__table__Language language = (string_eq(p->tok.lit, tos_lit("C")) && p->peek_tok.kind == v__token__Kind_dot ? (v__table__Language_c) : string_eq(p->tok.lit, tos_lit("JS")) && p->peek_tok.kind == v__token__Kind_dot ? (v__table__Language_js) : (v__table__Language_v));
	if (language != v__table__Language_v) {
		v__parser__Parser_next(p);
		v__parser__Parser_next(p);
	}
	v__token__Position name_pos = v__token__Token_position(&p->tok);
	string name = v__parser__Parser_check_name(p);
	if (name.len == 1 && byte_is_capital(string_at(name, 0))) {
		v__parser__Parser_error_with_pos(p, tos_lit("single letter capital names are reserved for generic template types."), name_pos);
	}
	array_v__table__Type generic_types = __new_array_with_default(0, 0, sizeof(v__table__Type), 0);
	if (p->tok.kind == v__token__Kind_lt) {
		v__parser__Parser_next(p);
		for (;;) {
			array_push(&generic_types, _MOV((v__table__Type[]){ v__parser__Parser_parse_type(p) }));
			if (p->tok.kind != v__token__Kind_comma) {
				break;
			}
			v__parser__Parser_next(p);
		}
		v__parser__Parser_check(p, v__token__Kind_gt);
	}
	bool no_body = p->tok.kind != v__token__Kind_lcbr;
	if (language == v__table__Language_v && no_body) {
		v__parser__Parser_error(p, _STR("`%.*s\000` lacks body", 2, p->tok.lit));
	}
	if (language == v__table__Language_v && string_ne(p->mod, tos_lit("builtin")) && name.len > 0 && !byte_is_capital(string_at(name, 0)) && !p->pref->translated) {
		v__parser__Parser_error_with_pos(p, _STR("struct name `%.*s\000` must begin with capital letter", 2, name), name_pos);
	}
	if (name.len == 1) {
		v__parser__Parser_error_with_pos(p, tos_lit("struct names must have more than one character"), name_pos);
	}
	array_v__ast__StructField ast_fields = __new_array_with_default(0, 0, sizeof(v__ast__StructField), 0);
	array_v__table__Field fields = __new_array_with_default(0, 0, sizeof(v__table__Field), 0);
	array_v__table__Type embedded_structs = __new_array_with_default(0, 0, sizeof(v__table__Type), 0);
	int mut_pos = -1;
	int pub_pos = -1;
	int pub_mut_pos = -1;
	int global_pos = -1;
	bool is_field_mut = false;
	bool is_field_pub = false;
	bool is_field_global = false;
	array_v__ast__Comment end_comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	if (!no_body) {
		v__parser__Parser_check(p, v__token__Kind_lcbr);
		for (;;) {
			if (!(p->tok.kind != v__token__Kind_rcbr)) break;
			array_v__ast__Comment comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
			for (;;) {
				if (!(p->tok.kind == v__token__Kind_comment)) break;
				array_push(&comments, _MOV((v__ast__Comment[]){ v__parser__Parser_comment(p) }));
				if (p->tok.kind == v__token__Kind_rcbr) {
					break;
				}
			}
			if (p->tok.kind == v__token__Kind_rcbr) {
				end_comments = comments;
				break;
			}
			if (p->tok.kind == v__token__Kind_key_pub) {
				v__parser__Parser_next(p);
				if (p->tok.kind == v__token__Kind_key_mut) {
					if (pub_mut_pos != -1) {
						v__parser__Parser_error(p, tos_lit("redefinition of `pub mut` section"));
					}
					v__parser__Parser_next(p);
					pub_mut_pos = fields.len;
					is_field_pub = true;
					is_field_mut = true;
					is_field_global = false;
				} else {
					if (pub_pos != -1) {
						v__parser__Parser_error(p, tos_lit("redefinition of `pub` section"));
					}
					pub_pos = fields.len;
					is_field_pub = true;
					is_field_mut = false;
					is_field_global = false;
				}
				v__parser__Parser_check(p, v__token__Kind_colon);
			} else if (p->tok.kind == v__token__Kind_key_mut) {
				if (mut_pos != -1) {
					v__parser__Parser_error(p, tos_lit("redefinition of `mut` section"));
				}
				v__parser__Parser_next(p);
				v__parser__Parser_check(p, v__token__Kind_colon);
				mut_pos = fields.len;
				is_field_pub = false;
				is_field_mut = true;
				is_field_global = false;
			} else if (p->tok.kind == v__token__Kind_key_global) {
				if (global_pos != -1) {
					v__parser__Parser_error(p, tos_lit("redefinition of `global` section"));
				}
				v__parser__Parser_next(p);
				v__parser__Parser_check(p, v__token__Kind_colon);
				global_pos = fields.len;
				is_field_pub = true;
				is_field_mut = true;
				is_field_global = true;
			}
			for (;;) {
				if (!(p->tok.kind == v__token__Kind_comment)) break;
				array_push(&comments, _MOV((v__ast__Comment[]){ v__parser__Parser_comment(p) }));
				if (p->tok.kind == v__token__Kind_rcbr) {
					break;
				}
			}
			v__token__Position field_start_pos = v__token__Token_position(&p->tok);
			bool is_embed = ((p->tok.lit.len > 1 && byte_is_capital(string_at(p->tok.lit, 0))) || p->peek_tok.kind == v__token__Kind_dot) && language == v__table__Language_v;
			string field_name = tos_lit("");
			v__table__Type typ = ((v__table__Type)(0));
			v__token__Position type_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,};
			v__token__Position field_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,};
			if (is_embed) {
				typ = v__parser__Parser_parse_type(p);
				v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(p->table, typ);
				string symbol_name = (*(string*)/*ee elem_typ */array_get(string_split(sym->name, tos_lit(".")), 1));
				if (string_contains(symbol_name, tos_lit("<"))) {
					symbol_name = (*(string*)/*ee elem_typ */array_get(string_split(symbol_name, tos_lit("<")), 0));
				}
				for (;;) {
					if (!(p->tok.kind == v__token__Kind_comment)) break;
					array_push(&comments, _MOV((v__ast__Comment[]){ v__parser__Parser_comment(p) }));
					if (p->tok.kind == v__token__Kind_rcbr) {
						break;
					}
				}
				type_pos = v__token__Token_position(&p->prev_tok);
				field_pos = v__token__Token_position(&p->prev_tok);
				field_name = symbol_name;
				if (_IN(v__table__Type, typ, embedded_structs)) {
					v__parser__Parser_error_with_pos(p, _STR("cannot embed `%.*s\000` more than once", 2, field_name), type_pos);
				}
				array_push(&embedded_structs, _MOV((v__table__Type[]){ typ }));
			} else {
				field_name = v__parser__Parser_check_name(p);
				for (;;) {
					if (!(p->tok.kind == v__token__Kind_comment)) break;
					array_push(&comments, _MOV((v__ast__Comment[]){ v__parser__Parser_comment(p) }));
					if (p->tok.kind == v__token__Kind_rcbr) {
						break;
					}
				}
				typ = v__parser__Parser_parse_type(p);
				type_pos = v__token__Token_position(&p->prev_tok);
				field_pos = v__token__Position_extend(field_start_pos, type_pos);
			}
			_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p)), _t1281, array_v__ast__Comment);
			if (p->tok.kind == v__token__Kind_lsbr) {
				v__parser__Parser_attributes(p);
			}
			v__ast__Expr default_expr = (v__ast__Expr){
#ifndef __cplusplus
0
#endif
};
			bool has_default_expr = false;
			if (!is_embed) {
				if (p->tok.kind == v__token__Kind_assign) {
					v__parser__Parser_next(p);
					default_expr = v__parser__Parser_expr(p, 0);
					v__ast__Expr _t1282 = default_expr;
					if (_t1282.typ == 222 /* v.ast.EnumVal */) {
						(*default_expr._222).typ = typ;
					} else {
					};
					has_default_expr = true;
				}
			}
			array_push(&ast_fields, _MOV((v__ast__StructField[]){ (v__ast__StructField){
				.pos = field_pos,
				.type_pos = type_pos,
				.comments = comments,
				.default_expr = default_expr,
				.has_default_expr = has_default_expr,
				.attrs = p->attrs,
				.is_public = is_field_pub,
				.is_embed = is_embed,
				.name = field_name,
				.typ = typ,
			} }));
			array_push(&fields, _MOV((v__table__Field[]){ (v__table__Field){
				.name = field_name,
				.typ = typ,
				.default_expr = v__ast__ex2fe(default_expr),
				.has_default_expr = has_default_expr,
				.default_val = (string){.str=(byteptr)""},
				.attrs = p->attrs,
				.is_pub = is_field_pub,
				.is_mut = is_field_mut,
				.is_global = is_field_global,
				.is_embed = is_embed,
				.embed_alias_for = (string){.str=(byteptr)""},
			} }));
			p->attrs = __new_array_with_default(0, 0, sizeof(v__table__Attr), 0);
		}
		v__parser__Parser_top_level_statement_end(p);
		v__parser__Parser_check(p, v__token__Kind_rcbr);
	}
	if (language == v__table__Language_c) {
		name = _STR("C.%.*s", 1, name);
	} else if (language == v__table__Language_js) {
		name = _STR("JS.%.*s", 1, name);
	} else {
		name = v__parser__Parser_prepend_mod(p, name);
	}
	v__table__TypeSymbol t = (v__table__TypeSymbol){
		.parent_idx = 0,
		.info = /* sum type cast 4 */ (v__table__TypeInfo){._155 = memdup(&(v__table__Struct[]){(v__table__Struct){.fields = fields,.is_typedef = array_v__table__Attr_contains(attrs, tos_lit("typedef")),.is_union = is_union,.is_ref_only = array_v__table__Attr_contains(attrs, tos_lit("ref_only")),.generic_types = generic_types,}}, sizeof(v__table__Struct)), .typ = 155 /* v.table.Struct */},
		.kind = v__table__Kind_struct_,
		.name = name,
		.source_name = name,
		.methods = __new_array(0, 1, sizeof(v__table__Fn)),
		.mod = p->mod,
		.is_public = is_pub,
		.is_written = 0,
		.language = language,
	};
	int ret = 0;
	if (p->builtin_mod && _IN(string, t.name, _const_v__table__builtin_type_names)) {
		ret = v__table__Table_register_builtin_type_symbol(p->table, t);
	} else {
		ret = v__table__Table_register_type_symbol(p->table, t);
	}
	if (ret == -1) {
		v__parser__Parser_error_with_pos(p, _STR("cannot register struct `%.*s\000`, another type with this name exists", 2, name), name_pos);
	}
	p->expr_mod = tos_lit("");
	return (v__ast__StructDecl){
		.pos = v__token__Position_extend(start_pos, name_pos),
		.name = name,
		.gen_types = generic_types,
		.is_pub = is_pub,
		.mut_pos = mut_pos,
		.pub_pos = pub_pos,
		.pub_mut_pos = pub_mut_pos,
		.language = language,
		.is_union = is_union,
		.attrs = attrs,
		.end_comments = end_comments,
		.fields = ast_fields,
	};
}

VV_LOCAL_SYMBOL v__ast__StructInit v__parser__Parser_struct_init(v__parser__Parser* p, bool short_syntax) {
	v__token__Position first_pos = v__token__Token_position(&p->tok);
	v__table__Type typ = (short_syntax ? (_const_v__table__void_type) : (v__parser__Parser_parse_type(p)));
	p->expr_mod = tos_lit("");
	if (!short_syntax) {
		v__parser__Parser_check(p, v__token__Kind_lcbr);
	}
	array_v__ast__Comment pre_comments = v__parser__Parser_eat_comments(p);
	array_v__ast__StructInitField fields = __new_array_with_default(0, 0, sizeof(v__ast__StructInitField), 0);
	int i = 0;
	bool no_keys = p->peek_tok.kind != v__token__Kind_colon && p->tok.kind != v__token__Kind_rcbr;
	bool saved_is_amp = p->is_amp;
	p->is_amp = false;
	for (;;) {
		if (!(p->tok.kind != v__token__Kind_rcbr && p->tok.kind != v__token__Kind_rpar)) break;
		string field_name = tos_lit("");
		v__ast__Expr expr = (v__ast__Expr){
#ifndef __cplusplus
0
#endif
};
		v__token__Position field_pos = (v__token__Position){.len = 0,.line_nr = 0,.pos = 0,};
		array_v__ast__Comment comments = __new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
		if (no_keys) {
			expr = v__parser__Parser_expr(p, 0);
			field_pos = v__ast__Expr_position(expr);
			comments = v__parser__Parser_eat_comments(p);
		} else {
			v__token__Position first_field_pos = v__token__Token_position(&p->tok);
			field_name = v__parser__Parser_check_name(p);
			v__parser__Parser_check(p, v__token__Kind_colon);
			expr = v__parser__Parser_expr(p, 0);
			comments = v__parser__Parser_eat_comments(p);
			v__token__Position last_field_pos = v__ast__Expr_position(expr);
			field_pos = (v__token__Position){.len = last_field_pos.pos - first_field_pos.pos + last_field_pos.len,.line_nr = first_field_pos.line_nr,.pos = first_field_pos.pos,};
		}
		i++;
		if (p->tok.kind == v__token__Kind_comma) {
			v__parser__Parser_next(p);
		}
		_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p)), _t1285, array_v__ast__Comment);
		array_push(&fields, _MOV((v__ast__StructInitField[]){ (v__ast__StructInitField){.expr = expr,.pos = field_pos,.comments = comments,.name = field_name,.typ = 0,.expected_type = 0,} }));
	}
	v__token__Position last_pos = v__token__Token_position(&p->tok);
	if (!short_syntax) {
		v__parser__Parser_check(p, v__token__Kind_rcbr);
	}
	p->is_amp = saved_is_amp;
	v__ast__StructInit node = (v__ast__StructInit){.pos = (v__token__Position){.len = last_pos.pos - first_pos.pos + last_pos.len,.line_nr = first_pos.line_nr,.pos = first_pos.pos,},.is_short = no_keys,.pre_comments = pre_comments,.typ = typ,.fields = fields,};
	return node;
}

VV_LOCAL_SYMBOL v__ast__InterfaceDecl v__parser__Parser_interface_decl(v__parser__Parser* p) {
	v__parser__Parser_top_level_statement_start(p);
	v__token__Position start_pos = v__token__Token_position(&p->tok);
	bool is_pub = p->tok.kind == v__token__Kind_key_pub;
	if (is_pub) {
		v__parser__Parser_next(p);
	}
	v__parser__Parser_next(p);
	v__token__Position name_pos = v__token__Token_position(&p->tok);
	string interface_name = v__parser__Parser_prepend_mod(p, v__parser__Parser_check_name(p));
	v__parser__Parser_check(p, v__token__Kind_lcbr);
	array_v__ast__Comment pre_comments = v__parser__Parser_eat_comments(p);
	int reg_idx = v__table__Table_register_type_symbol(p->table, (v__table__TypeSymbol){.parent_idx = 0,.info = /* sum type cast 4 */ (v__table__TypeInfo){._356 = memdup(&(v__table__Interface[]){(v__table__Interface){.types = __new_array_with_default(0, 0, sizeof(v__table__Type), 0),}}, sizeof(v__table__Interface)), .typ = 356 /* v.table.Interface */},.kind = v__table__Kind_interface_,.name = interface_name,.source_name = interface_name,.methods = __new_array(0, 1, sizeof(v__table__Fn)),.mod = p->mod,.is_public = 0,.is_written = 0,.language = 0,});
	if (reg_idx == -1) {
		v__parser__Parser_error_with_pos(p, _STR("cannot register interface `%.*s\000`, another type with this name exists", 2, interface_name), name_pos);
	}
	v__table__Type typ = v__table__new_type(reg_idx);
	v__table__TypeSymbol* ts = v__table__Table_get_type_symbol(p->table, typ);
	ts->methods = __new_array_with_default(0, 20, sizeof(v__table__Fn), 0);
	array_v__ast__FnDecl methods = __new_array_with_default(0, 20, sizeof(v__ast__FnDecl), 0);
	for (;;) {
		if (!(p->tok.kind != v__token__Kind_rcbr && p->tok.kind != v__token__Kind_eof)) break;
		v__token__Position method_start_pos = v__token__Token_position(&p->tok);
		int line_nr = p->tok.line_nr;
		string name = v__parser__Parser_check_name(p);
		if (v__table__TypeSymbol_has_method(ts, name)) {
			v__parser__Parser_error_with_pos(p, _STR("duplicate method `%.*s\000`", 2, name), method_start_pos);
		}
		if (v__util__contains_capital(name)) {
			v__parser__Parser_error(p, tos_lit("interface methods cannot contain uppercase letters, use snake_case instead"));
		}
		multi_return_array_v__table__Param_bool_bool mr_10327 = v__parser__Parser_fn_args(p);
		array_v__table__Param args2 = mr_10327.arg0;
		v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(p->table, typ);
		array_v__table__Param args = new_array_from_c_array(1, 1, sizeof(v__table__Param), _MOV((v__table__Param[1]){(v__table__Param){.pos = {0},.name = tos_lit("x"),.is_mut = 0,.typ = typ,.type_source_name = sym->source_name,.is_hidden = true,}}));
		_PUSH_MANY(&args, (args2), _t1287, array_v__table__Param);
		v__ast__FnDecl method = (v__ast__FnDecl){
			.name = name,
			.mod = p->mod,
			.params = args,
			.is_deprecated = 0,
			.is_pub = true,
			.is_variadic = 0,
			.is_anon = 0,
			.receiver = {0},
			.receiver_pos = {0},
			.is_method = 0,
			.method_idx = 0,
			.rec_mut = 0,
			.rec_share = 0,
			.language = 0,
			.no_body = 0,
			.is_builtin = 0,
			.pos = v__token__Position_extend(method_start_pos, v__token__Token_position(&p->prev_tok)),
			.body_pos = {0},
			.file = p->file_name,
			.is_generic = 0,
			.is_direct_arr = 0,
			.attrs = __new_array(0, 1, sizeof(v__table__Attr)),
			.stmts = __new_array(0, 1, sizeof(v__ast__Stmt)),
			.return_type = _const_v__table__void_type,
			.comments = __new_array(0, 1, sizeof(v__ast__Comment)),
			.source_file = 0,
		};
		if (v__token__Kind_is_start_of_type(p->tok.kind) && p->tok.line_nr == line_nr) {
			method.return_type = v__parser__Parser_parse_type(p);
		}
		array_v__ast__Comment mcomments = v__parser__Parser_eat_comments(p);
		method.comments = mcomments;
		array_push(&methods, _MOV((v__ast__FnDecl[]){ method }));
		v__table__TypeSymbol* return_type_sym = v__table__Table_get_type_symbol(p->table, method.return_type);
		v__table__TypeSymbol_register_method(ts, (v__table__Fn){.params = args,.return_type = method.return_type,.return_type_source_name = return_type_sym->source_name,.is_variadic = 0,.language = 0,.is_generic = 0,.is_pub = true,.is_deprecated = 0,.is_unsafe = 0,.is_placeholder = 0,.mod = (string){.str=(byteptr)""},.ctdefine = (string){.str=(byteptr)""},.attrs = __new_array(0, 1, sizeof(v__table__Attr)),.name = name,.source_fn = 0,});
	}
	v__parser__Parser_top_level_statement_end(p);
	v__parser__Parser_check(p, v__token__Kind_rcbr);
	return (v__ast__InterfaceDecl){.name = interface_name,.field_names = __new_array(0, 1, sizeof(string)),.is_pub = is_pub,.methods = methods,.pos = start_pos,.pre_comments = pre_comments,};
}

VV_LOCAL_SYMBOL string v__gen__Gen_gen_str_for_type_with_styp(v__gen__Gen* g, v__table__Type typ, string styp) {
	v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, v__gen__Gen_unwrap_generic(g, typ));
	string str_fn_name = v__gen__styp_to_str_fn_name(styp);
	if ((sym->info).typ == 347 /* v.table.Alias */) {
		if ((*sym->info._347).is_import) {
			sym = v__table__Table_get_type_symbol(g->table, (*sym->info._347).parent_type);
			str_fn_name = v__gen__styp_to_str_fn_name(string_replace(sym->name, tos_lit("."), tos_lit("__")));
		}
	}
	multi_return_bool_bool_int mr_689 = v__table__TypeSymbol_str_method_info(sym);
	bool sym_has_str_method = mr_689.arg0;
	bool str_method_expects_ptr = mr_689.arg1;
	int str_nr_args = mr_689.arg2;
	if (sym_has_str_method && str_method_expects_ptr && str_nr_args == 1) {
		string str_fn_name_no_ptr = _STR("%.*s\000_no_ptr", 2, str_fn_name);
		string already_generated_key_no_ptr = _STR("%.*s\000:%.*s", 2, styp, str_fn_name_no_ptr);
		if (!_IN(string, already_generated_key_no_ptr, g->str_types)) {
			array_push(&g->str_types, _MOV((string[]){ string_clone(already_generated_key_no_ptr) }));
			strings__Builder_writeln(&g->type_definitions, _STR("string %.*s\000(%.*s\000 it); // auto no_ptr version", 3, str_fn_name_no_ptr, styp));
			strings__Builder_writeln(&g->auto_str_funcs, _STR("string %.*s\000(%.*s\000 it){ return %.*s\000(&it); }", 4, str_fn_name_no_ptr, styp, str_fn_name));
		}
		return str_fn_name_no_ptr;
	}
	string already_generated_key = _STR("%.*s\000:%.*s", 2, styp, str_fn_name);
	if (!sym_has_str_method && !_IN(string, already_generated_key, g->str_types)) {
		#if defined(CUSTOM_DEFINE_debugautostr)
		{
		}
		#endif
		array_push(&g->str_types, _MOV((string[]){ string_clone(already_generated_key) }));
		v__table__TypeInfo _t1291 = sym->info;
		if (_t1291.typ == 347 /* v.table.Alias */) {
			if ((*sym->info._347).is_import) {
				v__gen__Gen_gen_str_default(g, *sym, styp, str_fn_name);
			} else {
				v__gen__Gen_gen_str_for_alias(g, (*sym->info._347), styp, str_fn_name);
			}
		} else if (_t1291.typ == 350 /* v.table.Array */) {
			v__gen__Gen_gen_str_for_array(g, (*sym->info._350), styp, str_fn_name);
		} else if (_t1291.typ == 351 /* v.table.ArrayFixed */) {
			v__gen__Gen_gen_str_for_array_fixed(g, (*sym->info._351), styp, str_fn_name);
		} else if (_t1291.typ == 355 /* v.table.Enum */) {
			v__gen__Gen_gen_str_for_enum(g, (*sym->info._355), styp, str_fn_name);
		} else if (_t1291.typ == 155 /* v.table.Struct */) {
			v__gen__Gen_gen_str_for_struct(g, (*sym->info._155), styp, str_fn_name);
		} else if (_t1291.typ == 349 /* v.table.Map */) {
			v__gen__Gen_gen_str_for_map(g, (*sym->info._349), styp, str_fn_name);
		} else if (_t1291.typ == 352 /* v.table.MultiReturn */) {
			v__gen__Gen_gen_str_for_multi_return(g, (*sym->info._352), styp, str_fn_name);
		} else if (_t1291.typ == 354 /* v.table.SumType */) {
			v__gen__Gen_gen_str_for_union_sum_type(g, (*sym->info._354), styp, str_fn_name);
		} else {
			v__gen__verror(_STR("could not generate string method %.*s\000 for type '%.*s\000'", 3, str_fn_name, styp));
		};
	}
	if (v__table__Type_has_flag(typ, v__table__TypeFlag_variadic)) {
		string varg_already_generated_key = _STR("varg_%.*s", 1, already_generated_key);
		if (!_IN(string, varg_already_generated_key, g->str_types)) {
			v__gen__Gen_gen_str_for_varg(g, styp, str_fn_name, sym_has_str_method);
			array_push(&g->str_types, _MOV((string[]){ string_clone(varg_already_generated_key) }));
		}
		return _STR("varg_%.*s", 1, str_fn_name);
	}
	return str_fn_name;
}

VV_LOCAL_SYMBOL void v__gen__Gen_gen_str_for_alias(v__gen__Gen* g, v__table__Alias info, string styp, string str_fn_name) {
	v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, info.parent_type);
	multi_return_bool_bool_int mr_3479 = v__table__TypeSymbol_str_method_info(sym);
	bool sym_has_str_method = mr_3479.arg0;
	string parent_str_fn_name = v__gen__styp_to_str_fn_name(string_replace(sym->name, tos_lit("."), tos_lit("__")));
	if (!sym_has_str_method) {
		string parent_styp = v__gen__Gen_typ(g, info.parent_type);
		parent_str_fn_name = v__gen__Gen_gen_str_for_type_with_styp(g, info.parent_type, parent_styp);
	}
	string clean_type_v_type_name = v__util__strip_main_name(string_replace(styp, tos_lit("__"), tos_lit(".")));
	strings__Builder_writeln(&g->type_definitions, _STR("string %.*s\000(%.*s\000 it); // auto", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("string %.*s\000(%.*s\000 it) { return indent_%.*s\000(it, 0); }", 4, str_fn_name, styp, str_fn_name));
	strings__Builder_writeln(&g->type_definitions, _STR("string indent_%.*s\000(%.*s\000 it, int indent_count); // auto", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("string indent_%.*s\000(%.*s\000 it, int indent_count) {", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\tstring indents = tos_lit(\"\");"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\tfor (int i = 0; i < indent_count; ++i) {"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\t\tindents = string_add(indents, tos_lit(\"    \"));"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\t}"));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("\treturn _STR(\"%%.*s\\000%.*s\000(%%.*s\\000)\", 3, indents, %.*s\000(it));", 3, clean_type_v_type_name, parent_str_fn_name));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("}"));
}

VV_LOCAL_SYMBOL void v__gen__Gen_gen_str_for_array(v__gen__Gen* g, v__table__Array info, string styp, string str_fn_name) {
	v__table__Type typ = info.elem_type;
	v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, info.elem_type);
	if ((sym->info).typ == 347 /* v.table.Alias */) {
		typ = (*sym->info._347).parent_type;
		sym = v__table__Table_get_type_symbol(g->table, typ);
	}
	string field_styp = v__gen__Gen_typ(g, typ);
	bool is_elem_ptr = v__table__Type_is_ptr(typ);
	multi_return_bool_bool_int mr_4952 = v__table__TypeSymbol_str_method_info(sym);
	bool sym_has_str_method = mr_4952.arg0;
	bool str_method_expects_ptr = mr_4952.arg1;
	string elem_str_fn_name = tos_lit("");
	if (sym_has_str_method) {
		elem_str_fn_name = (is_elem_ptr ? (string_add(string_replace(field_styp, tos_lit("*"), tos_lit("")), tos_lit("_str"))) : (string_add(field_styp, tos_lit("_str"))));
		if (sym->kind == v__table__Kind_byte) {
			elem_str_fn_name = string_add(elem_str_fn_name, tos_lit("_escaped"));
		}
	} else {
		elem_str_fn_name = v__gen__styp_to_str_fn_name(field_styp);
	}
	if (!sym_has_str_method) {
		v__gen__Gen_gen_str_for_type_with_styp(g, typ, field_styp);
	}
	strings__Builder_writeln(&g->type_definitions, _STR("string %.*s\000(%.*s\000 a); // auto", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("string %.*s\000(%.*s\000 a) { return indent_%.*s\000(a, 0);}", 4, str_fn_name, styp, str_fn_name));
	strings__Builder_writeln(&g->type_definitions, _STR("string indent_%.*s\000(%.*s\000 a, int indent_count); // auto", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("string indent_%.*s\000(%.*s\000 a, int indent_count) {", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\tstrings__Builder sb = strings__new_builder(a.len * 10);"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\tstrings__Builder_write(&sb, tos_lit(\"[\"));"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\tfor (int i = 0; i < a.len; ++i) {"));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\t%.*s\000 it = (*(%.*s\000*)array_get(a, i));", 3, field_styp, field_styp));
	if (sym->kind == v__table__Kind_struct_ && !sym_has_str_method) {
		if (is_elem_ptr) {
			strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tstring x = indent_%.*s\000(*it, indent_count);", 2, elem_str_fn_name));
		} else {
			strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tstring x = indent_%.*s\000(it, indent_count);", 2, elem_str_fn_name));
		}
	} else if ((sym->kind == v__table__Kind_f32 || sym->kind == v__table__Kind_f64)) {
		strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\t\tstring x = _STR(\"%g\", 1, it);"));
	} else {
		if ((str_method_expects_ptr && is_elem_ptr) || (!str_method_expects_ptr && !is_elem_ptr)) {
			strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tstring x = %.*s\000(it);", 2, elem_str_fn_name));
		} else if (str_method_expects_ptr && !is_elem_ptr) {
			strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tstring x = %.*s\000(&it);", 2, elem_str_fn_name));
		} else if (!str_method_expects_ptr && is_elem_ptr) {
			strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tstring x = %.*s\000(*it);", 2, elem_str_fn_name));
		}
	}
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\t\tstrings__Builder_write(&sb, x);"));
	if (g->pref->autofree && typ != _const_v__table__bool_type) {
		strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\t\tstring_free(&x);"));
	}
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\t\tif (i < a.len-1) {"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\t\t\tstrings__Builder_write(&sb, tos_lit(\", \"));"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\t\t}"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\t}"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\tstrings__Builder_write(&sb, tos_lit(\"]\"));"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\tstring res = strings__Builder_str(&sb);"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\tstrings__Builder_free(&sb);"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\treturn res;"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("}"));
}

VV_LOCAL_SYMBOL void v__gen__Gen_gen_str_for_array_fixed(v__gen__Gen* g, v__table__ArrayFixed info, string styp, string str_fn_name) {
	v__table__Type typ = info.elem_type;
	v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, info.elem_type);
	if ((sym->info).typ == 347 /* v.table.Alias */) {
		typ = (*sym->info._347).parent_type;
		sym = v__table__Table_get_type_symbol(g->table, typ);
	}
	string field_styp = v__gen__Gen_typ(g, typ);
	bool is_elem_ptr = v__table__Type_is_ptr(typ);
	multi_return_bool_bool_int mr_8155 = v__table__TypeSymbol_str_method_info(sym);
	bool sym_has_str_method = mr_8155.arg0;
	bool str_method_expects_ptr = mr_8155.arg1;
	string elem_str_fn_name = tos_lit("");
	if (sym_has_str_method) {
		elem_str_fn_name = (is_elem_ptr ? (string_add(string_replace(field_styp, tos_lit("*"), tos_lit("")), tos_lit("_str"))) : (string_add(field_styp, tos_lit("_str"))));
	} else {
		elem_str_fn_name = v__gen__styp_to_str_fn_name(field_styp);
	}
	if (!v__table__TypeSymbol_has_method(sym, tos_lit("str"))) {
		elem_str_fn_name = v__gen__Gen_gen_str_for_type_with_styp(g, typ, field_styp);
	}
	strings__Builder_writeln(&g->type_definitions, _STR("string %.*s\000(%.*s\000 a); // auto", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("string %.*s\000(%.*s\000 a) { return indent_%.*s\000(a, 0);}", 4, str_fn_name, styp, str_fn_name));
	strings__Builder_writeln(&g->type_definitions, _STR("string indent_%.*s\000(%.*s\000 a, int indent_count); // auto", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("string indent_%.*s\000(%.*s\000 a, int indent_count) {", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("\tstrings__Builder sb = strings__new_builder(%"PRId32"\000 * 10);", 2, info.size));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\tstrings__Builder_write(&sb, tos_lit(\"[\"));"));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("\tfor (int i = 0; i < %"PRId32"\000; ++i) {", 2, info.size));
	if (sym->kind == v__table__Kind_struct_ && !sym_has_str_method) {
		strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tstrings__Builder_write(&sb, %.*s\000(a[i], indent_count));", 2, elem_str_fn_name));
	} else if ((sym->kind == v__table__Kind_f32 || sym->kind == v__table__Kind_f64)) {
		strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\t\tstrings__Builder_write(&sb, _STR(\"%g\", 1, a[i]));"));
	} else if (sym->kind == v__table__Kind_string) {
		strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\t\tstrings__Builder_write(&sb, _STR(\"\'%.*s\\000\'\", 2, a[i]));"));
	} else {
		if ((str_method_expects_ptr && is_elem_ptr) || (!str_method_expects_ptr && !is_elem_ptr)) {
			strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tstrings__Builder_write(&sb, %.*s\000(a[i]));", 2, elem_str_fn_name));
		} else if (str_method_expects_ptr && !is_elem_ptr) {
			strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tstrings__Builder_write(&sb, %.*s\000(&a[i]));", 2, elem_str_fn_name));
		} else if (!str_method_expects_ptr && is_elem_ptr) {
			strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tstrings__Builder_write(&sb, %.*s\000(*a[i]));", 2, elem_str_fn_name));
		}
	}
	strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tif (i < %"PRId32"\000) {", 2, info.size - 1));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\t\t\tstrings__Builder_write(&sb, tos_lit(\", \"));"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\t\t}"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\t}"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\tstrings__Builder_write(&sb, tos_lit(\"]\"));"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\treturn strings__Builder_str(&sb);"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("}"));
}

VV_LOCAL_SYMBOL void v__gen__Gen_gen_str_for_map(v__gen__Gen* g, v__table__Map info, string styp, string str_fn_name) {
	v__table__TypeSymbol* key_sym = v__table__Table_get_type_symbol(g->table, info.key_type);
	string key_styp = v__gen__Gen_typ(g, info.key_type);
	if (!v__table__TypeSymbol_has_method(key_sym, tos_lit("str"))) {
		v__gen__Gen_gen_str_for_type_with_styp(g, info.key_type, key_styp);
	}
	v__table__TypeSymbol* val_sym = v__table__Table_get_type_symbol(g->table, info.value_type);
	string val_styp = v__gen__Gen_typ(g, info.value_type);
	string elem_str_fn_name = string_add(string_replace(val_styp, tos_lit("*"), tos_lit("")), tos_lit("_str"));
	if (!v__table__TypeSymbol_has_method(val_sym, tos_lit("str"))) {
		v__gen__Gen_gen_str_for_type_with_styp(g, info.value_type, val_styp);
	}
	string zero = v__gen__Gen_type_default(g, info.value_type);
	strings__Builder_writeln(&g->type_definitions, _STR("string %.*s\000(%.*s\000 m); // auto", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("string %.*s\000(%.*s\000 m) { return indent_%.*s\000(m, 0);}", 4, str_fn_name, styp, str_fn_name));
	strings__Builder_writeln(&g->type_definitions, _STR("string indent_%.*s\000(%.*s\000 m, int indent_count); // auto", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("string indent_%.*s\000(%.*s\000 m, int indent_count) { /* gen_str_for_map */", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\tstrings__Builder sb = strings__new_builder(m.key_values.len*10);"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\tstrings__Builder_write(&sb, tos_lit(\"{\"));"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\tfor (unsigned int i = 0; i < m.key_values.len; ++i) {"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\t\tif (m.key_values.keys[i].str == 0) { continue; }"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\t\tstring key = (*(string*)DenseArray_get(m.key_values, i));"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\t\tstrings__Builder_write(&sb, _STR(\"\'%.*s\\000\'\", 2, key));"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\t\tstrings__Builder_write(&sb, tos_lit(\": \"));"));
	strings__Builder_write(&g->auto_str_funcs, _STR("\t%.*s\000 it = (*(%.*s\000*)map_get(", 3, val_styp, val_styp));
	strings__Builder_write(&g->auto_str_funcs, tos_lit("m, (*(string*)DenseArray_get(m.key_values, i))"));
	strings__Builder_write(&g->auto_str_funcs, tos_lit(", "));
	strings__Builder_writeln(&g->auto_str_funcs, _STR(" &(%.*s\000[]) { %.*s\000 }));", 3, val_styp, zero));
	if (val_sym->kind == v__table__Kind_string) {
		strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\t\tstrings__Builder_write(&sb, _STR(\"\'%.*s\\000\'\", 2, it));"));
	} else if (val_sym->kind == v__table__Kind_struct_ && !v__table__TypeSymbol_has_method(val_sym, tos_lit("str"))) {
		strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tstrings__Builder_write(&sb, indent_%.*s\000(it, indent_count));", 2, elem_str_fn_name));
	} else if ((val_sym->kind == v__table__Kind_f32 || val_sym->kind == v__table__Kind_f64)) {
		strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\t\tstrings__Builder_write(&sb, _STR(\"%g\", 1, it));"));
	} else {
		strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tstrings__Builder_write(&sb, %.*s\000(it));", 2, elem_str_fn_name));
	}
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\t\tif (i != m.key_values.len-1) {"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\t\t\tstrings__Builder_write(&sb, tos_lit(\", \"));"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\t\t}"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\t}"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\tstrings__Builder_write(&sb, tos_lit(\"}\"));"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\treturn strings__Builder_str(&sb);"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("}"));
}

VV_LOCAL_SYMBOL void v__gen__Gen_gen_str_for_varg(v__gen__Gen* g, string styp, string str_fn_name, bool has_str_method) {
	strings__Builder_writeln(&g->definitions, _STR("string varg_%.*s\000(varg_%.*s\000 it); // auto", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("string varg_%.*s\000(varg_%.*s\000 it) {", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\tstrings__Builder sb = strings__new_builder(it.len);"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\tstrings__Builder_write(&sb, tos_lit(\"[\"));"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\tfor(int i=0; i<it.len; ++i) {"));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tstrings__Builder_write(&sb, %.*s\000(it.args[i]));", 2, str_fn_name));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\t\tif (i < it.len-1) {"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\t\t\tstrings__Builder_write(&sb, tos_lit(\", \"));"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\t\t}"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\t}"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\tstrings__Builder_write(&sb, tos_lit(\"]\"));"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\treturn strings__Builder_str(&sb);"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("}"));
}

VV_LOCAL_SYMBOL void v__gen__Gen_gen_str_for_multi_return(v__gen__Gen* g, v__table__MultiReturn info, string styp, string str_fn_name) {
	// FOR IN array
	array _t1293 = info.types;
	for (int _t1294 = 0; _t1294 < _t1293.len; ++_t1294) {
		v__table__Type typ = ((v__table__Type*)_t1293.data)[_t1294];
		v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, typ);
		if (!v__table__TypeSymbol_has_method(sym, tos_lit("str"))) {
			string field_styp = v__gen__Gen_typ(g, typ);
			v__gen__Gen_gen_str_for_type_with_styp(g, typ, field_styp);
		}
	}
	strings__Builder_writeln(&g->type_definitions, _STR("string %.*s\000(%.*s\000 a); // auto", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("string %.*s\000(%.*s\000 a) {", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("\tstrings__Builder sb = strings__new_builder(%"PRId32"\000 * 10);", 2, info.types.len));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\tstrings__Builder_write(&sb, tos_lit(\"(\"));"));
	// FOR IN array
	array _t1295 = info.types;
	for (int i = 0; i < _t1295.len; ++i) {
		v__table__Type typ = ((v__table__Type*)_t1295.data)[i];
		v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, typ);
		string field_styp = v__gen__Gen_typ(g, typ);
		bool is_arg_ptr = v__table__Type_is_ptr(typ);
		multi_return_bool_bool_int mr_14691 = v__table__TypeSymbol_str_method_info(sym);
		bool sym_has_str_method = mr_14691.arg0;
		bool str_method_expects_ptr = mr_14691.arg1;
		string arg_str_fn_name = tos_lit("");
		if (sym_has_str_method) {
			arg_str_fn_name = (is_arg_ptr ? (string_add(string_replace(field_styp, tos_lit("*"), tos_lit("")), tos_lit("_str"))) : (string_add(field_styp, tos_lit("_str"))));
		} else {
			arg_str_fn_name = v__gen__styp_to_str_fn_name(field_styp);
		}
		if (sym->kind == v__table__Kind_struct_ && !sym_has_str_method) {
			strings__Builder_writeln(&g->auto_str_funcs, _STR("\tstrings__Builder_write(&sb, %.*s\000(a.arg%"PRId32"\000));", 3, str_fn_name, i));
		} else if ((sym->kind == v__table__Kind_f32 || sym->kind == v__table__Kind_f64)) {
			strings__Builder_writeln(&g->auto_str_funcs, _STR("\tstrings__Builder_write(&sb, _STR(\"%%g\", 1, a.arg%"PRId32"\000));", 2, i));
		} else if (sym->kind == v__table__Kind_string) {
			strings__Builder_writeln(&g->auto_str_funcs, _STR("\tstrings__Builder_write(&sb, _STR(\"\'%%.*s\\000\'\", 2, a.arg%"PRId32"\000));", 2, i));
		} else {
			if ((str_method_expects_ptr && is_arg_ptr) || (!str_method_expects_ptr && !is_arg_ptr)) {
				strings__Builder_writeln(&g->auto_str_funcs, _STR("\tstrings__Builder_write(&sb, %.*s\000(a.arg%"PRId32"\000));", 3, arg_str_fn_name, i));
			} else if (str_method_expects_ptr && !is_arg_ptr) {
				strings__Builder_writeln(&g->auto_str_funcs, _STR("\tstrings__Builder_write(&sb, %.*s\000(&a.arg%"PRId32"\000));", 3, arg_str_fn_name, i));
			} else if (!str_method_expects_ptr && is_arg_ptr) {
				strings__Builder_writeln(&g->auto_str_funcs, _STR("\tstrings__Builder_write(&sb, %.*s\000(*a.arg%"PRId32"\000));", 3, arg_str_fn_name, i));
			}
		}
		if (i != info.types.len - 1) {
			strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\tstrings__Builder_write(&sb, tos_lit(\", \"));"));
		}
	}
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\tstrings__Builder_write(&sb, tos_lit(\")\"));"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\treturn strings__Builder_str(&sb);"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("}"));
}

VV_LOCAL_SYMBOL void v__gen__Gen_gen_str_for_struct(v__gen__Gen* g, v__table__Struct info, string styp, string str_fn_name) {
	map_string_string fnames2strfunc = new_map_init(1, sizeof(string), _MOV((string[1]){tos_lit(""), }), _MOV((string[1]){tos_lit(""), }));
	// FOR IN array
	array _t1296 = info.fields;
	for (int _t1297 = 0; _t1297 < _t1296.len; ++_t1297) {
		v__table__Field field = ((v__table__Field*)_t1296.data)[_t1297];
		v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, field.typ);
		if (!v__table__TypeSymbol_has_method(sym, tos_lit("str"))) {
			v__table__Type typ = field.typ;
			if (v__table__Type_is_ptr(typ)) {
				typ = v__table__Type_deref(typ);
			}
			string field_styp = v__gen__Gen_typ(g, typ);
			string field_fn_name = v__gen__Gen_gen_str_for_type_with_styp(g, field.typ, field_styp);
			map_set(&fnames2strfunc, field_styp, &(string[]) { field_fn_name });
		}
	}
	strings__Builder_writeln(&g->type_definitions, _STR("string %.*s\000(%.*s\000 x); // auto", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("string %.*s\000(%.*s\000 x) { return indent_%.*s\000(x, 0);}", 4, str_fn_name, styp, str_fn_name));
	strings__Builder_writeln(&g->type_definitions, _STR("string indent_%.*s\000(%.*s\000 x, int indent_count); // auto", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("string indent_%.*s\000(%.*s\000 x, int indent_count) {", 3, str_fn_name, styp));
	string clean_struct_v_type_name = string_replace(styp, tos_lit("__"), tos_lit("."));
	if (string_contains(clean_struct_v_type_name, tos_lit("_T_"))) {
		clean_struct_v_type_name = string_add(string_replace(string_replace(clean_struct_v_type_name, tos_lit("_T_"), tos_lit("<")), tos_lit("_"), tos_lit(", ")), tos_lit(">"));
	}
	if (string_ends_with(styp, tos_lit("*"))) {
		string deref_typ = string_replace(styp, tos_lit("*"), tos_lit(""));
		strings__Builder_writeln(&g->auto_str_funcs, _STR("\t%.*s\000 *it = x;", 2, deref_typ));
		clean_struct_v_type_name = string_add(tos_lit("&"), string_replace(clean_struct_v_type_name, tos_lit("*"), tos_lit("")));
	} else {
		string deref_typ = styp;
		strings__Builder_writeln(&g->auto_str_funcs, _STR("\t%.*s\000 *it = &x;", 2, deref_typ));
	}
	clean_struct_v_type_name = v__util__strip_main_name(clean_struct_v_type_name);
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\tstring indents = tos_lit(\"\");"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\tfor (int i = 0; i < indent_count; ++i) {"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\t\tindents = string_add(indents, tos_lit(\"    \"));"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\t}"));
	if (info.fields.len == 0) {
		strings__Builder_write(&g->auto_str_funcs, _STR("\treturn tos_lit(\"%.*s\000{}\");", 2, clean_struct_v_type_name));
	} else {
		strings__Builder_write(&g->auto_str_funcs, _STR("\treturn _STR(\"%.*s\000{\\n\"", 2, clean_struct_v_type_name));
		// FOR IN array
		array _t1298 = info.fields;
		for (int _t1299 = 0; _t1299 < _t1298.len; ++_t1299) {
			v__table__Field field = ((v__table__Field*)_t1298.data)[_t1299];
			string fmt = v__gen__Gen_type_to_fmt(g, field.typ);
			if (v__table__Type_is_ptr(field.typ)) {
				fmt = _STR("&%.*s", 1, fmt);
			}
			strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\t\"%%.*s\\000    %.*s\000: %.*s\000\\n\"", 3, field.name, fmt));
		}
		strings__Builder_write(&g->auto_str_funcs, _STR("\t\t\"%%.*s\\000}\", %"PRId32"", 1, 2 * (info.fields.len + 1)));
		if (info.fields.len > 0) {
			strings__Builder_write(&g->auto_str_funcs, tos_lit(",\n\t\t"));
			// FOR IN array
			array _t1300 = info.fields;
			for (int i = 0; i < _t1300.len; ++i) {
				v__table__Field field = ((v__table__Field*)_t1300.data)[i];
				v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, field.typ);
				bool has_custom_str = v__table__TypeSymbol_has_method(sym, tos_lit("str"));
				string field_styp = v__gen__Gen_typ(g, field.typ);
				if (string_ends_with(field_styp, tos_lit("*"))) {
					field_styp = string_replace(field_styp, tos_lit("*"), tos_lit(""));
				}
				string field_styp_fn_name = (has_custom_str ? (_STR("%.*s\000_str", 2, field_styp)) : ((*(string*)map_get(fnames2strfunc, field_styp, &(string[]){ (string){.str=(byteptr)""} }))));
				strings__Builder_write(&g->auto_str_funcs, tos_lit("indents, "));
				string func = v__gen__struct_auto_str_func(*sym, field.typ, field_styp_fn_name, field.name);
				if (v__table__Type_is_ptr(field.typ)) {
					strings__Builder_write(&g->auto_str_funcs, _STR("isnil(it->%.*s\000)", 2, v__gen__c_name(field.name)));
					strings__Builder_write(&g->auto_str_funcs, tos_lit(" ? tos_lit(\"nil\") : "));
					if (sym->kind != v__table__Kind_struct_ && !v__table__Type_is_int(field.typ) && !v__table__Type_is_float(field.typ)) {
						strings__Builder_write(&g->auto_str_funcs, tos_lit("*"));
					}
				}
				strings__Builder_write(&g->auto_str_funcs, func);
				if (i < info.fields.len - 1) {
					strings__Builder_write(&g->auto_str_funcs, tos_lit(",\n\t\t"));
				}
			}
		}
		strings__Builder_writeln(&g->auto_str_funcs, tos_lit(","));
		strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\t\tindents);"));
	}
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("}"));
}

VV_LOCAL_SYMBOL string v__gen__struct_auto_str_func(v__table__TypeSymbol sym, v__table__Type field_type, string fn_name, string field_name) {
	bool has_custom_str = v__table__TypeSymbol_has_method(&sym, tos_lit("str"));
	if (sym.kind == v__table__Kind_enum_) {
		return _STR("%.*s\000(it->%.*s\000)", 3, fn_name, v__gen__c_name(field_name));
	} else if (sym.kind == v__table__Kind_struct_) {
		string obj = _STR("it->%.*s", 1, v__gen__c_name(field_name));
		if (v__table__Type_is_ptr(field_type)) {
			obj = _STR("*%.*s", 1, obj);
		}
		if (has_custom_str) {
			return _STR("%.*s\000(%.*s\000)", 3, fn_name, obj);
		}
		return _STR("indent_%.*s\000(%.*s\000, indent_count + 1)", 3, fn_name, obj);
	} else if ((sym.kind == v__table__Kind_array || sym.kind == v__table__Kind_array_fixed || sym.kind == v__table__Kind_map || sym.kind == v__table__Kind_sum_type)) {
		if (has_custom_str) {
			return _STR("%.*s\000(it->%.*s\000)", 3, fn_name, v__gen__c_name(field_name));
		}
		return _STR("indent_%.*s\000(it->%.*s\000, indent_count + 1)", 3, fn_name, v__gen__c_name(field_name));
	} else {
		string method_str = _STR("it->%.*s", 1, v__gen__c_name(field_name));
		if (sym.kind == v__table__Kind_bool) {
			method_str = /*f*/string_add(method_str, tos_lit(" ? _SLIT(\"true\") : _SLIT(\"false\")"));
		} else if ((v__table__Type_is_int(field_type) || v__table__Type_is_float(field_type)) && v__table__Type_is_ptr(field_type)) {
			string fmt = ((sym.kind == v__table__Kind_f32 || sym.kind == v__table__Kind_f64) ? (tos_lit("%g\\000")) : sym.kind == v__table__Kind_u64 ? (tos_lit("%lld\\000")) : (tos_lit("%d\\000")));
			method_str = _STR("_STR(\"%.*s\000\", 2, *%.*s\000)", 3, fmt, method_str);
		}
		return method_str;
	}
	return (string){.str=(byteptr)""};
}

VV_LOCAL_SYMBOL void v__gen__Gen_gen_str_for_enum(v__gen__Gen* g, v__table__Enum info, string styp, string str_fn_name) {
	string s = v__util__no_dots(styp);
	strings__Builder_writeln(&g->type_definitions, _STR("string %.*s\000(%.*s\000 it); // auto", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("string %.*s\000(%.*s\000 it) { /* gen_str_for_enum */", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\tswitch(it) {"));
	array_string seen = __new_array_with_default(info.vals.len, 0, sizeof(string), &(string[]){tos_lit("")});
	// FOR IN array
	array _t1301 = info.vals;
	for (int _t1302 = 0; _t1302 < _t1301.len; ++_t1302) {
		string val = ((string*)_t1301.data)[_t1302];
		if (info.is_multi_allowed && _IN(string, val, seen)) {
			continue;
		} else if (info.is_multi_allowed) {
			array_push(&seen, _MOV((string[]){ string_clone(val) }));
		}
		strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tcase %.*s\000_%.*s\000: return tos_lit(\"%.*s\000\");", 4, s, val, val));
	}
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\t\tdefault: return tos_lit(\"unknown enum value\");"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\t}"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("}"));
}

VV_LOCAL_SYMBOL void v__gen__Gen_gen_str_for_union_sum_type(v__gen__Gen* g, v__table__SumType info, string styp, string str_fn_name) {
	map_string_string gen_fn_names = new_map_1(sizeof(string));
	// FOR IN array
	array _t1304 = info.variants;
	for (int _t1305 = 0; _t1305 < _t1304.len; ++_t1305) {
		v__table__Type typ = ((v__table__Type*)_t1304.data)[_t1305];
		v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, typ);
		if (!v__table__TypeSymbol_has_method(sym, tos_lit("str"))) {
			string field_styp = v__gen__Gen_typ(g, typ);
			string field_fn_name = v__gen__Gen_gen_str_for_type_with_styp(g, typ, field_styp);
			map_set(&gen_fn_names, field_styp, &(string[]) { field_fn_name });
		}
	}
	strings__Builder_writeln(&g->type_definitions, _STR("string %.*s\000(%.*s\000 x); // auto", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("string %.*s\000(%.*s\000 x) { return indent_%.*s\000(x, 0); }", 4, str_fn_name, styp, str_fn_name));
	strings__Builder_writeln(&g->type_definitions, _STR("string indent_%.*s\000(%.*s\000 x, int indent_count); // auto", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("string indent_%.*s\000(%.*s\000 x, int indent_count) {", 3, str_fn_name, styp));
	string clean_sum_type_v_type_name = string_replace(styp, tos_lit("__"), tos_lit("."));
	if (string_ends_with(styp, tos_lit("*"))) {
		clean_sum_type_v_type_name = string_add(tos_lit("&"), string_replace(clean_sum_type_v_type_name, tos_lit("*"), tos_lit("")));
	}
	clean_sum_type_v_type_name = v__util__strip_main_name(clean_sum_type_v_type_name);
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\tswitch(x.typ) {"));
	// FOR IN array
	array _t1306 = info.variants;
	for (int _t1307 = 0; _t1307 < _t1306.len; ++_t1307) {
		v__table__Type typ = ((v__table__Type*)_t1306.data)[_t1307];
		string value_fmt = tos_lit("%.*s\\000");
		if (typ == _const_v__table__string_type) {
			value_fmt = _STR("'%.*s\000'", 2, value_fmt);
		}
		string typ_str = v__gen__Gen_typ(g, typ);
		string func_name = (_IN_MAP(typ_str, gen_fn_names) ? ((*(string*)map_get(gen_fn_names, typ_str, &(string[]){ (string){.str=(byteptr)""} }))) : (v__gen__Gen_gen_str_for_type_with_styp(g, typ, typ_str)));
		v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, typ);
		if (sym->kind == v__table__Kind_struct_) {
			func_name = _STR("indent_%.*s", 1, func_name);
		}
		strings__Builder_write(&g->auto_str_funcs, _STR("\t\tcase %"PRId32"\000: return _STR(\"%.*s\000(%.*s\000)\", 2, %.*s\000(*(%.*s\000*)x._%"PRId32"", 6, typ, clean_sum_type_v_type_name, value_fmt, func_name, typ_str, v__table__Type_idx(typ)));
		if (sym->kind == v__table__Kind_struct_) {
			strings__Builder_write(&g->auto_str_funcs, tos_lit(", indent_count"));
		}
		strings__Builder_writeln(&g->auto_str_funcs, tos_lit("));"));
	}
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\t\tdefault: return tos_lit(\"unknown sum type value\");"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\t}"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("}"));
}

string v__gen__cgen(array_v__ast__File files, v__table__Table* table, v__pref__Preferences* pref) {
	v__gen__Gen g = (v__gen__Gen){
		.pref = pref,
		.module_built = string_replace(string_after(pref->path, tos_lit("vlib/")), tos_lit("/"), tos_lit(".")),
		.table = table,
		.out = strings__new_builder(1000),
		.cheaders = strings__new_builder(8192),
		.includes = strings__new_builder(100),
		.typedefs = strings__new_builder(100),
		.typedefs2 = strings__new_builder(100),
		.type_definitions = strings__new_builder(100),
		.definitions = strings__new_builder(100),
		.inits = new_map_1(sizeof(strings__Builder)),
		.cleanups = new_map_1(sizeof(strings__Builder)),
		.gowrappers = strings__new_builder(100),
		.stringliterals = strings__new_builder(100),
		.auto_str_funcs = strings__new_builder(100),
		.comptime_defines = strings__new_builder(100),
		.pcs_declarations = strings__new_builder(100),
		.hotcode_definitions = strings__new_builder(100),
		.shared_types = strings__new_builder(100),
		.channel_definitions = strings__new_builder(100),
		.options_typedefs = strings__new_builder(100),
		.options = strings__new_builder(100),
		.json_forward_decls = strings__new_builder(100),
		.enum_typedefs = strings__new_builder(100),
		.sql_buf = strings__new_builder(100),
		.file = {0},
		.fn_decl = 0,
		.last_fn_c_name = (string){.str=(byteptr)""},
		.tmp_count = 0,
		.tmp_count2 = 0,
		.variadic_args = new_map_1(sizeof(int)),
		.is_c_call = 0,
		.is_assign_lhs = 0,
		.is_assign_rhs = 0,
		.is_array_set = 0,
		.is_amp = 0,
		.is_sql = 0,
		.is_shared = 0,
		.is_vlines_enabled = 0,
		.vlines_path = (string){.str=(byteptr)""},
		.optionals = __new_array(0, 1, sizeof(string)),
		.chan_pop_optionals = __new_array(0, 1, sizeof(string)),
		.shareds = __new_array(0, 1, sizeof(int)),
		.inside_ternary = 0,
		.inside_map_postfix = 0,
		.inside_map_infix = 0,
		.ternary_names = new_map_1(sizeof(string)),
		.ternary_level_names = new_map_1(sizeof(array_string)),
		.stmt_path_pos = __new_array(0, 1, sizeof(int)),
		.skip_stmt_pos = 0,
		.right_is_opt = 0,
		.autofree = true,
		.indent = -1,
		.empty_line = 0,
		.is_test = 0,
		.assign_op = 0,
		.defer_stmts = __new_array(0, 1, sizeof(v__ast__DeferStmt)),
		.defer_ifdef = (string){.str=(byteptr)""},
		.defer_profile_code = (string){.str=(byteptr)""},
		.str_types = __new_array(0, 1, sizeof(string)),
		.threaded_fns = __new_array(0, 1, sizeof(string)),
		.array_fn_definitions = __new_array(0, 1, sizeof(string)),
		.map_fn_definitions = __new_array(0, 1, sizeof(string)),
		.is_json_fn = 0,
		.json_types = __new_array(0, 1, sizeof(string)),
		.pcs = __new_array(0, 1, sizeof(v__gen__ProfileCounterMeta)),
		.is_builtin_mod = 0,
		.hotcode_fn_names = __new_array(0, 1, sizeof(string)),
		.cur_generic_type = 0,
		.sql_i = 0,
		.sql_stmt_name = (string){.str=(byteptr)""},
		.sql_side = 0,
		.inside_vweb_tmpl = 0,
		.inside_return = 0,
		.inside_or_block = 0,
		.strs_to_free0 = __new_array(0, 1, sizeof(string)),
		.inside_call = 0,
		.has_main = 0,
		.inside_const = 0,
		.comp_for_method = (string){.str=(byteptr)""},
		.comptime_var_type_map = new_map_1(sizeof(v__table__Type)),
		.called_fn_name = (string){.str=(byteptr)""},
		.cur_mod = (string){.str=(byteptr)""},
		.is_js_call = 0,
		.inside_lambda = 0,
		.prevent_sum_type_unwrapping_once = 0,
		.aggregate_type_idx = 0,
	};
	// FOR IN array
	array _t1308 = g.table->modules;
	for (int _t1309 = 0; _t1309 < _t1308.len; ++_t1309) {
		string mod = ((string*)_t1308.data)[_t1309];
		(*(strings__Builder*)map_get_and_set(&g.inits, mod, &(strings__Builder[]){ {0} })) = strings__new_builder(100);
		(*(strings__Builder*)map_get_and_set(&g.cleanups, mod, &(strings__Builder[]){ {0} })) = strings__new_builder(100);
	}
	v__gen__Gen_init(&g);
	bool tests_inited = false;
	bool autofree_used = false;
	// FOR IN array
	array _t1310 = files;
	for (int _t1311 = 0; _t1311 < _t1310.len; ++_t1311) {
		v__ast__File file = ((v__ast__File*)_t1310.data)[_t1311];
		g.file = file;
		if (g.pref->is_vlines) {
			g.vlines_path = v__util__vlines_escape_path(file.path, g.pref->ccompiler);
		}
		bool is_test = string_ends_with(g.file.path, tos_lit(".vv")) || string_ends_with(g.file.path, tos_lit("_test.v"));
		if (string_ends_with(g.file.path, tos_lit("_test.v"))) {
			g.is_test = is_test;
		}
		if ((g.file.path).len == 0 || !g.pref->autofree) {
			g.autofree = false;
		} else {
			g.autofree = true;
			autofree_used = true;
		}
		if (g.is_test && !tests_inited) {
			v__gen__Gen_write_tests_main(&g);
			tests_inited = true;
		}
		v__gen__Gen_stmts(&g, file.stmts);
	}
	if (autofree_used) {
		g.autofree = true;
	}
	v__gen__Gen_write_variadic_types(&g);
	v__gen__Gen_gen_vlines_reset(&g);
	if (g.pref->build_mode != v__pref__BuildMode_build_module) {
		v__gen__Gen_write_init_function(&g);
	}
	v__gen__Gen_finish(&g);
	strings__Builder b = strings__new_builder(250000);
	strings__Builder_write(&b, v__gen__Gen_hashes(&g));
	strings__Builder_writeln(&b, tos_lit("\n// V comptime_defines:"));
	strings__Builder_write(&b, strings__Builder_str(&g.comptime_defines));
	strings__Builder_writeln(&b, tos_lit("\n// V typedefs:"));
	strings__Builder_write(&b, strings__Builder_str(&g.typedefs));
	strings__Builder_writeln(&b, tos_lit("\n// V typedefs2:"));
	strings__Builder_write(&b, strings__Builder_str(&g.typedefs2));
	strings__Builder_writeln(&b, tos_lit("\n// V cheaders:"));
	strings__Builder_write(&b, strings__Builder_str(&g.cheaders));
	strings__Builder_writeln(&b, tos_lit("\n// V includes:"));
	strings__Builder_write(&b, strings__Builder_str(&g.includes));
	strings__Builder_writeln(&b, tos_lit("\n// Enum definitions:"));
	strings__Builder_write(&b, strings__Builder_str(&g.enum_typedefs));
	strings__Builder_writeln(&b, tos_lit("\n// V type definitions:"));
	strings__Builder_write(&b, strings__Builder_str(&g.type_definitions));
	strings__Builder_writeln(&b, tos_lit("\n// V Option_xxx definitions:"));
	strings__Builder_write(&b, strings__Builder_str(&g.options));
	strings__Builder_writeln(&b, tos_lit("\n// V json forward decls:"));
	strings__Builder_write(&b, strings__Builder_str(&g.json_forward_decls));
	strings__Builder_writeln(&b, tos_lit("\n// V definitions:"));
	strings__Builder_write(&b, strings__Builder_str(&g.definitions));
	if (g.pcs_declarations.len > 0) {
		strings__Builder_writeln(&b, tos_lit("\n// V profile counters:"));
		strings__Builder_write(&b, strings__Builder_str(&g.pcs_declarations));
	}
	string interface_table = v__gen__Gen_interface_table(&g);
	if (interface_table.len > 0) {
		strings__Builder_writeln(&b, tos_lit("\n// V interface table:"));
		strings__Builder_write(&b, interface_table);
	}
	if (g.gowrappers.len > 0) {
		strings__Builder_writeln(&b, tos_lit("\n// V gowrappers:"));
		strings__Builder_write(&b, strings__Builder_str(&g.gowrappers));
	}
	if (g.hotcode_definitions.len > 0) {
		strings__Builder_writeln(&b, tos_lit("\n// V hotcode definitions:"));
		strings__Builder_write(&b, strings__Builder_str(&g.hotcode_definitions));
	}
	if (g.options_typedefs.len > 0) {
		strings__Builder_writeln(&b, tos_lit("\n// V option typedefs:"));
		strings__Builder_write(&b, strings__Builder_str(&g.options_typedefs));
	}
	if (g.shared_types.len > 0) {
		strings__Builder_writeln(&b, tos_lit("\n// V shared types:"));
		strings__Builder_write(&b, strings__Builder_str(&g.shared_types));
	}
	if (g.channel_definitions.len > 0) {
		strings__Builder_writeln(&b, tos_lit("\n// V channel code:"));
		strings__Builder_write(&b, strings__Builder_str(&g.channel_definitions));
	}
	if (g.stringliterals.len > 0) {
		strings__Builder_writeln(&b, tos_lit("\n// V stringliterals:"));
		strings__Builder_write(&b, strings__Builder_str(&g.stringliterals));
	}
	if (g.auto_str_funcs.len > 0) {
		if (g.pref->build_mode != v__pref__BuildMode_build_module) {
			strings__Builder_writeln(&b, tos_lit("\n// V auto str functions:"));
			strings__Builder_write(&b, strings__Builder_str(&g.auto_str_funcs));
		}
	}
	strings__Builder_writeln(&b, tos_lit("\n// V out"));
	strings__Builder_write(&b, strings__Builder_str(&g.out));
	strings__Builder_writeln(&b, tos_lit("\n// THE END."));
	return strings__Builder_str(&b);
}

string v__gen__Gen_hashes(v__gen__Gen* g) {
	string res = string_replace(_const_v__gen__c_commit_hash_default, tos_lit("@@@"), v__util__vhash());
	res = /*f*/string_add(res, string_replace(_const_v__gen__c_current_commit_hash_default, tos_lit("@@@"), v__util__githash(g->pref->building_v)));
	return res;
}

void v__gen__Gen_init(v__gen__Gen* g) {
	if ((g->pref->custom_prelude).len != 0) {
		strings__Builder_writeln(&g->cheaders, g->pref->custom_prelude);
	} else if (!g->pref->no_preludes) {
		strings__Builder_writeln(&g->cheaders, tos_lit("// Generated by the V compiler"));
		strings__Builder_writeln(&g->cheaders, v__gen__get_guarded_include_text(tos_lit("<inttypes.h>"), tos_lit("The C compiler can not find <inttypes.h> . Please install build-essentials")));
		strings__Builder_writeln(&g->cheaders, _const_v__gen__c_builtin_types);
		if (g->pref->is_bare) {
			strings__Builder_writeln(&g->cheaders, _const_v__gen__bare_c_headers);
		} else {
			strings__Builder_writeln(&g->cheaders, _const_v__gen__c_headers);
		}
		strings__Builder_writeln(&g->definitions, tos_lit("void _STR_PRINT_ARG(const char*, char**, int*, int*, int, ...);"));
		strings__Builder_writeln(&g->definitions, tos_lit("string _STR(const char*, int, ...);"));
		strings__Builder_writeln(&g->definitions, tos_lit("string _STR_TMP(const char*, ...);"));
	}
	if (g->pref->os == v__pref__OS_ios) {
		strings__Builder_writeln(&g->cheaders, tos_lit("#define __TARGET_IOS__ 1"));
		strings__Builder_writeln(&g->cheaders, tos_lit("#include <spawn.h>"));
	}
	v__gen__Gen_write_builtin_types(g);
	v__gen__Gen_write_typedef_types(g);
	v__gen__Gen_write_typeof_functions(g);
	if (g->pref->build_mode != v__pref__BuildMode_build_module) {
		v__gen__Gen_write_str_fn_definitions(g);
	}
	v__gen__Gen_write_sorted_types(g);
	v__gen__Gen_write_multi_return_types(g);
	strings__Builder_writeln(&g->definitions, tos_lit("// end of definitions #endif"));
	strings__Builder_writeln(&g->stringliterals, tos_lit(""));
	strings__Builder_writeln(&g->stringliterals, tos_lit("// >> string literal consts"));
	if (g->pref->build_mode != v__pref__BuildMode_build_module) {
		strings__Builder_writeln(&g->stringliterals, tos_lit("void vinit_string_literals(){"));
	}
	if (g->pref->compile_defines_all.len > 0) {
		strings__Builder_writeln(&g->comptime_defines, tos_lit("// V compile time defines by -d or -define flags:"));
		strings__Builder_writeln(&g->comptime_defines, string_add(tos_lit("//     All custom defines      : "), array_string_join(g->pref->compile_defines_all, tos_lit(","))));
		strings__Builder_writeln(&g->comptime_defines, string_add(tos_lit("//     Turned ON custom defines: "), array_string_join(g->pref->compile_defines, tos_lit(","))));
		// FOR IN array
		array _t1312 = g->pref->compile_defines;
		for (int _t1313 = 0; _t1313 < _t1312.len; ++_t1313) {
			string cdefine = ((string*)_t1312.data)[_t1313];
			strings__Builder_writeln(&g->comptime_defines, _STR("#define CUSTOM_DEFINE_%.*s", 1, cdefine));
		}
		strings__Builder_writeln(&g->comptime_defines, tos_lit(""));
	}
	if (g->pref->is_debug || _IN(string, tos_lit("debug"), g->pref->compile_defines)) {
		strings__Builder_writeln(&g->comptime_defines, tos_lit("#define _VDEBUG (1)"));
	}
	if (g->pref->is_test || _IN(string, tos_lit("test"), g->pref->compile_defines)) {
		strings__Builder_writeln(&g->comptime_defines, tos_lit("#define _VTEST (1)"));
	}
	if (g->pref->autofree) {
		strings__Builder_writeln(&g->comptime_defines, tos_lit("#define _VAUTOFREE (1)"));
	}
	if (g->pref->prealloc) {
		strings__Builder_writeln(&g->comptime_defines, tos_lit("#define _VPREALLOC (1)"));
	}
	if (g->pref->is_livemain || g->pref->is_liveshared) {
		v__gen__Gen_generate_hotcode_reloading_declarations(g);
	}
}

void v__gen__Gen_finish(v__gen__Gen* g) {
	if (g->pref->build_mode != v__pref__BuildMode_build_module) {
		strings__Builder_writeln(&g->stringliterals, tos_lit("}"));
	}
	strings__Builder_writeln(&g->stringliterals, tos_lit("// << string literal consts"));
	strings__Builder_writeln(&g->stringliterals, tos_lit(""));
	if (g->pref->is_prof) {
		v__gen__Gen_gen_vprint_profile_stats(g);
	}
	if (g->pref->is_livemain || g->pref->is_liveshared) {
		v__gen__Gen_generate_hotcode_reloader_code(g);
	}
	if (!g->pref->is_test) {
		v__gen__Gen_gen_c_main(g);
	}
}

void v__gen__Gen_write_typeof_functions(v__gen__Gen* g) {
	v__gen__Gen_writeln(g, tos_lit(""));
	v__gen__Gen_writeln(g, tos_lit("// >> typeof() support for sum types"));
	// FOR IN array
	array _t1314 = g->table->types;
	for (int _t1315 = 0; _t1315 < _t1314.len; ++_t1315) {
		v__table__TypeSymbol typ = ((v__table__TypeSymbol*)_t1314.data)[_t1315];
		if (typ.kind == v__table__Kind_sum_type) {
			v__table__SumType sum_info = /* as */ *(v__table__SumType*)__as_cast((typ.info)._354, (typ.info).typ, /*expected:*/354);
			int tidx = v__table__Table_find_type_idx(g->table, typ.name);
			v__gen__Gen_writeln(g, _STR("char * v_typeof_sumtype_%"PRId32"\000(int sidx) { /* %.*s\000 */ ", 3, tidx, typ.name));
			v__gen__Gen_writeln(g, tos_lit("	switch(sidx) {"));
			v__gen__Gen_writeln(g, _STR("		case %"PRId32"\000: return \"%.*s\000\";", 3, tidx, v__util__strip_main_name(typ.name)));
			// FOR IN array
			array _t1316 = sum_info.variants;
			for (int _t1317 = 0; _t1317 < _t1316.len; ++_t1317) {
				v__table__Type v = ((v__table__Type*)_t1316.data)[_t1317];
				v__table__TypeSymbol* subtype = v__table__Table_get_type_symbol(g->table, v);
				v__gen__Gen_writeln(g, _STR("		case %"PRId32"\000: return \"%.*s\000\";", 3, v, v__util__strip_main_name(subtype->name)));
			}
			v__gen__Gen_writeln(g, _STR("		default: return \"unknown %.*s\000\";", 2, v__util__strip_main_name(typ.name)));
			v__gen__Gen_writeln(g, tos_lit("	}"));
			v__gen__Gen_writeln(g, tos_lit("}"));
		}
	}
	v__gen__Gen_writeln(g, tos_lit("// << typeof() support for sum types"));
	v__gen__Gen_writeln(g, tos_lit(""));
}

VV_LOCAL_SYMBOL string v__gen__Gen_typ(v__gen__Gen* g, v__table__Type t) {
	string styp = v__gen__Gen_base_type(g, t);
	if (v__table__Type_has_flag(t, v__table__TypeFlag_optional)) {
		return v__gen__Gen_register_optional(g, t);
	}
	return styp;
}

VV_LOCAL_SYMBOL string v__gen__Gen_base_type(v__gen__Gen* g, v__table__Type t) {
	v__table__ShareType share = v__table__Type_share(t);
	string styp = (share == v__table__ShareType_atomic_t ? (v__table__Type_atomic_typename(t)) : (v__gen__Gen_cc_type(g, t)));
	if (v__table__Type_has_flag(t, v__table__TypeFlag_shared_f)) {
		styp = v__gen__Gen_find_or_register_shared(g, t, styp);
	}
	int nr_muls = v__table__Type_nr_muls(t);
	if (nr_muls > 0) {
		styp = /*f*/string_add(styp, strings__repeat('*', nr_muls));
	}
	return styp;
}

VV_LOCAL_SYMBOL multi_return_string_string v__gen__Gen_optional_type_name(v__gen__Gen* g, v__table__Type t) {
	string base = v__gen__Gen_base_type(g, t);
	string styp = _STR("Option_%.*s", 1, base);
	if (v__table__Type_is_ptr(t)) {
		styp = string_replace(styp, tos_lit("*"), tos_lit("_ptr"));
	}
	return (multi_return_string_string){.arg0=styp, .arg1=base};
}

VV_LOCAL_SYMBOL string v__gen__Gen_optional_type_text(v__gen__Gen* g, string styp, string base) {
	string x = styp;
	string size = (string_eq(base, tos_lit("void")) ? (tos_lit("int")) : (base));
	string ret = _STR("struct %.*s\000 {\n	bool ok;\n	bool is_none;\n	string v_error;\n	int ecode;\n	byte data[sizeof(%.*s\000)];\n}", 3, x, size);
	return ret;
}

VV_LOCAL_SYMBOL string v__gen__Gen_register_optional(v__gen__Gen* g, v__table__Type t) {
	multi_return_string_string mr_17362 = v__gen__Gen_optional_type_name(g, t);
	string styp = mr_17362.arg0;
	string base = mr_17362.arg1;
	if (!_IN(string, styp, g->optionals)) {
		string no_ptr = string_replace(base, tos_lit("*"), tos_lit("_ptr"));
		string typ = (string_eq(base, tos_lit("void")) ? (tos_lit("void*")) : (base));
		strings__Builder_writeln(&g->options_typedefs, _STR("typedef struct {\n			%.*s\000  data;\n			string error;\n			int    ecode;\n			bool   ok;\n			bool   is_none;\n		} Option2_%.*s\000;", 3, typ, no_ptr));
		strings__Builder_writeln(&g->typedefs2, _STR("typedef struct %.*s\000 %.*s\000;", 3, styp, styp));
		strings__Builder_write(&g->options, v__gen__Gen_optional_type_text(g, styp, base));
		strings__Builder_writeln(&g->options, tos_lit(";\n"));
		array_push(&g->optionals, _MOV((string[]){ string_clone(string_clone(styp)) }));
	}
	return styp;
}

VV_LOCAL_SYMBOL string v__gen__Gen_find_or_register_shared(v__gen__Gen* g, v__table__Type t, string base) {
	string sh_typ = _STR("__shared__%.*s", 1, base);
	int t_idx = v__table__Type_idx(t);
	if (_IN(int, t_idx, g->shareds)) {
		return sh_typ;
	}
	string mtx_typ = tos_lit("sync__RwMutex");
	strings__Builder_writeln(&g->shared_types, _STR("struct %.*s\000 { %.*s\000 val; %.*s\000* mtx; };", 4, sh_typ, base, mtx_typ));
	strings__Builder_writeln(&g->typedefs2, _STR("typedef struct %.*s\000 %.*s\000;", 3, sh_typ, sh_typ));
	array_push(&g->shareds, _MOV((int[]){ t_idx }));
	return sh_typ;
}

VV_LOCAL_SYMBOL void v__gen__Gen_register_chan_pop_optional_call(v__gen__Gen* g, string opt_el_type, string styp) {
	if (!_IN(string, opt_el_type, g->chan_pop_optionals)) {
		array_push(&g->chan_pop_optionals, _MOV((string[]){ string_clone(opt_el_type) }));
		strings__Builder_writeln(&g->channel_definitions, _STR("\nstatic inline %.*s\000 __Option_%.*s\000_popval(%.*s\000 ch) {\n	%.*s\000 _tmp;\n	if (sync__Channel_try_pop_priv(ch, _tmp.data, false)) {\n		Option _tmp2 = v_error(tos_lit(\"channel closed\"));\n		return *(%.*s\000*)&_tmp2;\n	}\n	_tmp.ok = true; _tmp.is_none = false; _tmp.v_error = (string){.str=(byteptr)\"\"}; _tmp.ecode = 0;\n	return _tmp;\n}", 6, opt_el_type, styp, styp, opt_el_type, opt_el_type));
	}
}

VV_LOCAL_SYMBOL string v__gen__Gen_cc_type2(v__gen__Gen* g, v__table__Type t) {
	v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, v__gen__Gen_unwrap_generic(g, t));
	string styp = v__util__no_dots(sym->name);
	if ((sym->info).typ == 155 /* v.table.Struct */) {
		if ((*sym->info._155).generic_types.len > 0) {
			string sgtyps = tos_lit("_T");
			// FOR IN array
			array _t1321 = (*sym->info._155).generic_types;
			for (int _t1322 = 0; _t1322 < _t1321.len; ++_t1322) {
				v__table__Type gt = ((v__table__Type*)_t1321.data)[_t1322];
				v__table__TypeSymbol* gts = v__table__Table_get_type_symbol(g->table, (v__table__Type_has_flag(gt, v__table__TypeFlag_generic) ? (v__gen__Gen_unwrap_generic(g, gt)) : (gt)));
				sgtyps = /*f*/string_add(sgtyps, _STR("_%.*s", 1, gts->name));
			}
			styp = /*f*/string_add(styp, sgtyps);
		} else if (string_contains(styp, tos_lit("<"))) {
			styp = string_replace_each(styp, new_array_from_c_array(6, 6, sizeof(string), _MOV((string[6]){tos_lit("<"), tos_lit("_T_"), tos_lit(">"), tos_lit(""), tos_lit(","), tos_lit("_")})));
		}
	}
	return styp;
}

VV_LOCAL_SYMBOL string v__gen__Gen_cc_type(v__gen__Gen* g, v__table__Type t) {
	v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, v__gen__Gen_unwrap_generic(g, t));
	string styp = v__gen__Gen_cc_type2(g, t);
	if (string_starts_with(styp, tos_lit("C__"))) {
		styp = string_substr(styp, 3, styp.len);
		if (sym->kind == v__table__Kind_struct_) {
			v__table__Struct info = /* as */ *(v__table__Struct*)__as_cast((sym->info)._155, (sym->info).typ, /*expected:*/155);
			if (!info.is_typedef) {
				styp = _STR("struct %.*s", 1, styp);
			}
		}
	}
	return styp;
}

void v__gen__Gen_write_typedef_types(v__gen__Gen* g) {
	strings__Builder_writeln(&g->typedefs, tos_lit("\ntypedef struct {\n	void* _object;\n	int _interface_idx;\n} _Interface;\n"));
	// FOR IN array
	array _t1323 = g->table->types;
	for (int _t1324 = 0; _t1324 < _t1323.len; ++_t1324) {
		v__table__TypeSymbol typ = ((v__table__TypeSymbol*)_t1323.data)[_t1324];
		v__table__Kind _t1325 = typ.kind;
		if (_t1325 == v__table__Kind_alias) {
			v__table__TypeSymbol* parent = &(*(v__table__TypeSymbol*)/*ee elem_typ */array_get(g->table->types, typ.parent_idx));
			string styp = v__util__no_dots(typ.name);
			bool is_c_parent = parent->name.len > 2 && string_at(parent->name, 0) == 'C' && string_at(parent->name, 1) == '.';
			string parent_styp = (is_c_parent ? (string_add(tos_lit("struct "), v__util__no_dots(string_substr(parent->name, 2, parent->name.len)))) : (v__util__no_dots(parent->name)));
			strings__Builder_writeln(&g->type_definitions, _STR("typedef %.*s\000 %.*s\000;", 3, parent_styp, styp));
		} else if (_t1325 == v__table__Kind_array) {
			string styp = v__util__no_dots(typ.name);
			strings__Builder_writeln(&g->type_definitions, _STR("typedef array %.*s\000;", 2, styp));
		} else if (_t1325 == v__table__Kind_interface_) {
			strings__Builder_writeln(&g->type_definitions, _STR("typedef _Interface %.*s\000;", 2, v__gen__c_name(typ.name)));
		} else if (_t1325 == v__table__Kind_chan) {
			if (string_ne(typ.name, tos_lit("chan"))) {
				string styp = v__util__no_dots(typ.name);
				strings__Builder_writeln(&g->type_definitions, _STR("typedef chan %.*s\000;", 2, styp));
				v__table__Chan chan_inf = v__table__TypeSymbol_chan_info(&typ);
				string el_stype = v__gen__Gen_typ(g, chan_inf.elem_type);
				strings__Builder_writeln(&g->channel_definitions, _STR("\nstatic inline %.*s\000 __%.*s\000_popval(%.*s\000 ch) {\n	%.*s\000 val;\n	sync__Channel_try_pop_priv(ch, &val, false);\n	return val;\n}", 5, el_stype, styp, styp, el_stype));
				strings__Builder_writeln(&g->channel_definitions, _STR("\nstatic inline void __%.*s\000_pushval(%.*s\000 ch, %.*s\000 val) {\n	sync__Channel_try_push_priv(ch, &val, false);\n}", 4, styp, styp, el_stype));
			}
		} else if (_t1325 == v__table__Kind_map) {
			string styp = v__util__no_dots(typ.name);
			strings__Builder_writeln(&g->type_definitions, _STR("typedef map %.*s\000;", 2, styp));
		} else if (_t1325 == v__table__Kind_function) {
			v__gen__Gen_write_fn_typesymbol_declaration(g, typ);
		} else {
			continue;
		};
	}
}

void v__gen__Gen_write_fn_typesymbol_declaration(v__gen__Gen* g, v__table__TypeSymbol sym) {
	v__table__FnType info = /* as */ *(v__table__FnType*)__as_cast((sym.info)._353, (sym.info).typ, /*expected:*/353);
	v__table__Fn func = info.func;
	v__table__TypeSymbol* retsym = v__table__Table_get_type_symbol(g->table, func.return_type);
	bool is_multi = retsym->kind == v__table__Kind_multi_return;
	bool is_fn_sig = (func.name).len == 0;
	bool not_anon = !info.is_anon;
	if (is_multi) {
		v__gen__Gen_write_multi_return_type_declaration(g, retsym);
	}
	if (!info.has_decl && (not_anon || is_fn_sig)) {
		string fn_name = (func.language == v__table__Language_c ? (v__util__no_dots(func.name)) : info.is_anon ? (sym.name) : (v__gen__c_name(func.name)));
		strings__Builder_write(&g->type_definitions, _STR("typedef %.*s\000 (*%.*s\000)(", 3, v__gen__Gen_typ(g, func.return_type), fn_name));
		// FOR IN array
		array _t1326 = func.params;
		for (int i = 0; i < _t1326.len; ++i) {
			v__table__Param param = ((v__table__Param*)_t1326.data)[i];
			strings__Builder_write(&g->type_definitions, v__gen__Gen_typ(g, param.typ));
			if (i < func.params.len - 1) {
				strings__Builder_write(&g->type_definitions, tos_lit(","));
			}
		}
		strings__Builder_writeln(&g->type_definitions, tos_lit(");"));
	}
}

void v__gen__Gen_write_multi_return_type_declaration(v__gen__Gen* g, v__table__TypeSymbol* sym) {
	if (sym->is_written) {
		return;
	}
	string name = v__util__no_dots(sym->name);
	v__table__MultiReturn info = /* as */ *(v__table__MultiReturn*)__as_cast((sym->info)._352, (sym->info).typ, /*expected:*/352);
	strings__Builder_writeln(&g->type_definitions, tos_lit("typedef struct {"));
	// FOR IN array
	array _t1327 = info.types;
	for (int i = 0; i < _t1327.len; ++i) {
		v__table__Type mr_typ = ((v__table__Type*)_t1327.data)[i];
		string type_name = v__gen__Gen_typ(g, mr_typ);
		strings__Builder_writeln(&g->type_definitions, _STR("\t%.*s\000 arg%"PRId32"\000;", 3, type_name, i));
	}
	strings__Builder_writeln(&g->type_definitions, _STR("} %.*s\000;\n", 2, name));
	sym->is_written = true;
}

void v__gen__Gen_write_multi_return_types(v__gen__Gen* g) {
	strings__Builder_writeln(&g->type_definitions, tos_lit("\n// BEGIN_multi_return_structs"));
	for (int idx = 0; idx < g->table->types.len; ++idx) {
		if ((*(v__table__TypeSymbol*)/*ee elem_typ */array_get(g->table->types, idx)).kind != v__table__Kind_multi_return) {
			continue;
		}
		v__gen__Gen_write_multi_return_type_declaration(g, (voidptr)&/*qq*/(*(v__table__TypeSymbol*)/*ee elem_typ */array_get(g->table->types, idx)));
	}
	strings__Builder_writeln(&g->type_definitions, tos_lit("// END_multi_return_structs\n"));
}

void v__gen__Gen_write_variadic_types(v__gen__Gen* g) {
	strings__Builder_writeln(&g->type_definitions, tos_lit("\n//BEGIN_variadic_structs"));
	// FOR IN map
	map_string_int _t1329 = g->variadic_args;
	for (int _t1328 = 0; _t1328 < _t1329.key_values.len; ++_t1328) {
		if (_t1329.key_values.keys[_t1328].str == 0) {continue;}
		string type_str = /*key*/ string_clone(_t1329.key_values.keys[_t1328]);
		int arg_len = (*(int*)(void*)(_t1329.key_values.values + _t1328 * (u32)(_t1329.value_bytes)));
		v__table__Type typ = ((string_int(type_str)));
		string type_name = v__gen__Gen_typ(g, typ);
		string struct_name = string_add(tos_lit("varg_"), string_replace(type_name, tos_lit("*"), tos_lit("_ptr")));
		strings__Builder_writeln(&g->type_definitions, _STR("struct %.*s\000 {", 2, struct_name));
		strings__Builder_writeln(&g->type_definitions, tos_lit("\tint len;"));
		strings__Builder_writeln(&g->type_definitions, _STR("\t%.*s\000 args[%"PRId32"\000];", 3, type_name, arg_len));
		strings__Builder_writeln(&g->type_definitions, tos_lit("};\n"));
		strings__Builder_writeln(&g->typedefs, _STR("typedef struct %.*s\000 %.*s\000;", 3, struct_name, struct_name));
	}
	strings__Builder_writeln(&g->type_definitions, tos_lit("// END_variadic_structs\n"));
}

void v__gen__Gen_write(v__gen__Gen* g, string s) {
	#if defined(CUSTOM_DEFINE_trace_gen)
	{
	}
	#endif
	if (g->indent > 0 && g->empty_line) {
		if (g->indent < _const_v__gen__tabs.len) {
			strings__Builder_write(&g->out, (*(string*)/*ee elem_typ */array_get(_const_v__gen__tabs, g->indent)));
		} else {
			for (int _t1330 = 0; _t1330 < g->indent; ++_t1330) {
				strings__Builder_write(&g->out, tos_lit("\t"));
			}
		}
	}
	strings__Builder_write(&g->out, s);
	g->empty_line = false;
}

void v__gen__Gen_writeln(v__gen__Gen* g, string s) {
	#if defined(CUSTOM_DEFINE_trace_gen)
	{
	}
	#endif
	if (g->indent > 0 && g->empty_line) {
		if (g->indent < _const_v__gen__tabs.len) {
			strings__Builder_write(&g->out, (*(string*)/*ee elem_typ */array_get(_const_v__gen__tabs, g->indent)));
		} else {
			for (int _t1331 = 0; _t1331 < g->indent; ++_t1331) {
				strings__Builder_write(&g->out, tos_lit("\t"));
			}
		}
	}
	strings__Builder_writeln(&g->out, s);
	g->empty_line = true;
}

string v__gen__Gen_new_tmp_var(v__gen__Gen* g) {
	g->tmp_count++;
	return _STR("_t%"PRId32"", 1, g->tmp_count);
}

void v__gen__Gen_reset_tmp_count(v__gen__Gen* g) {
	g->tmp_count = 0;
}

VV_LOCAL_SYMBOL void v__gen__Gen_decrement_inside_ternary(v__gen__Gen* g) {
	string key = int_str(g->inside_ternary);
	// FOR IN array
	array _t1332 = (*(array_string*)map_get(g->ternary_level_names, key, &(array_string[]){ __new_array(0, 1, sizeof(string)) }));
	for (int _t1333 = 0; _t1333 < _t1332.len; ++_t1333) {
		string name = ((string*)_t1332.data)[_t1333];
		map_delete(&g->ternary_names, name);
	}
	map_delete(&g->ternary_level_names, key);
	g->inside_ternary--;
}

VV_LOCAL_SYMBOL void v__gen__Gen_stmts(v__gen__Gen* g, array_v__ast__Stmt stmts) {
	v__gen__Gen_stmts_with_tmp_var(g, stmts, tos_lit(""));
}

VV_LOCAL_SYMBOL void v__gen__Gen_stmts_with_tmp_var(v__gen__Gen* g, array_v__ast__Stmt stmts, string tmp_var) {
	g->indent++;
	if (g->inside_ternary > 0) {
		v__gen__Gen_write(g, tos_lit("("));
	}
	// FOR IN array
	array _t1334 = stmts;
	for (int i = 0; i < _t1334.len; ++i) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)_t1334.data)[i];
		if (i == stmts.len - 1 && (tmp_var).len != 0) {
			array_push(&g->stmt_path_pos, _MOV((int[]){ g->out.len }));
			g->skip_stmt_pos = true;
			v__gen__Gen_writeln(g, _STR("%.*s\000 = /* if expr set */", 2, tmp_var));
		}
		v__gen__Gen_stmt(g, stmt);
		g->skip_stmt_pos = false;
		if (g->inside_ternary > 0 && i < stmts.len - 1) {
			v__gen__Gen_write(g, tos_lit(","));
		}
	}
	g->indent--;
	if (g->inside_ternary > 0) {
		v__gen__Gen_write(g, tos_lit(""));
		v__gen__Gen_write(g, tos_lit(")"));
	}
	if (g->pref->autofree && !g->inside_vweb_tmpl && stmts.len > 0) {
		v__ast__Stmt stmt = (*(v__ast__Stmt*)/*ee elem_typ */array_get(stmts, 0));
		if ((stmt).typ != 151 /* v.ast.FnDecl */ && g->inside_ternary == 0) {
			v__token__Position stmt_pos = v__ast__Stmt_position(stmt);
			v__gen__Gen_writeln(g, tos_lit("// af scope_vars"));
			v__gen__Gen_autofree_scope_vars(g, stmt_pos.pos - 1, stmt_pos.line_nr, false);
		}
	}
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL void v__gen__Gen_write_v_source_line_info(v__gen__Gen* g, v__token__Position pos) {
	if (g->inside_ternary == 0 && g->pref->is_vlines && g->is_vlines_enabled) {
		int nline = pos.line_nr + 1;
		string lineinfo = _STR("\n#line %"PRId32"\000 \"%.*s\000\"", 3, nline, g->vlines_path);
		v__gen__Gen_writeln(g, lineinfo);
	}
}

VV_LOCAL_SYMBOL void v__gen__Gen_stmt(v__gen__Gen* g, v__ast__Stmt node) {
	if (!g->skip_stmt_pos) {
		array_push(&g->stmt_path_pos, _MOV((int[]){ g->out.len }));
	}
	v__ast__Stmt _t1337 = node;
	if (_t1337.typ == 251 /* v.ast.AssertStmt */) {
		v__gen__Gen_write_v_source_line_info(g, (*node._251).pos);
		v__gen__Gen_gen_assert_stmt(g, (*node._251));
	} else if (_t1337.typ == 252 /* v.ast.AssignStmt */) {
		v__gen__Gen_write_v_source_line_info(g, (*node._252).pos);
		v__gen__Gen_gen_assign_stmt(g, (*node._252));
	} else if (_t1337.typ == 253 /* v.ast.Block */) {
		if ((*node._253).is_unsafe) {
			v__gen__Gen_writeln(g, tos_lit("{ // Unsafe block"));
		} else {
			v__gen__Gen_writeln(g, tos_lit("{"));
		}
		v__gen__Gen_stmts(g, (*node._253).stmts);
		v__gen__Gen_writeln(g, tos_lit("}"));
	} else if (_t1337.typ == 254 /* v.ast.BranchStmt */) {
		v__gen__Gen_write_v_source_line_info(g, (*node._254).pos);
		if ((*node._254).label.len > 0) {
			if ((*node._254).kind == v__token__Kind_key_break) {
				v__gen__Gen_writeln(g, _STR("goto %.*s\000__break;", 2, (*node._254).label));
			} else {
				v__gen__Gen_writeln(g, _STR("goto %.*s\000__continue;", 2, (*node._254).label));
			}
		} else {
			v__gen__Gen_writeln(g, _STR("%.*s\000;", 2, v__token__Kind_str((*node._254).kind)));
		}
	} else if (_t1337.typ == 256 /* v.ast.ConstDecl */) {
		v__gen__Gen_write_v_source_line_info(g, (*node._256).pos);
		v__gen__Gen_const_decl(g, (*node._256));
	} else if (_t1337.typ == 255 /* v.ast.CompFor */) {
		v__gen__Gen_comp_for(g, (*node._255));
	} else if (_t1337.typ == 257 /* v.ast.DeferStmt */) {
		v__ast__DeferStmt defer_stmt = (*node._257);
		defer_stmt.ifdef = g->defer_ifdef;
		array_push(&g->defer_stmts, _MOV((v__ast__DeferStmt[]){ defer_stmt }));
	} else if (_t1337.typ == 258 /* v.ast.EnumDecl */) {
		string enum_name = v__util__no_dots((*node._258).name);
		bool is_flag = (*node._258).is_flag;
		strings__Builder_writeln(&g->enum_typedefs, tos_lit("typedef enum {"));
		string cur_enum_expr = tos_lit("");
		int cur_enum_offset = 0;
		// FOR IN array
		array _t1339 = (*node._258).fields;
		for (int i = 0; i < _t1339.len; ++i) {
			v__ast__EnumField field = ((v__ast__EnumField*)_t1339.data)[i];
			strings__Builder_write(&g->enum_typedefs, _STR("\t%.*s\000_%.*s", 2, enum_name, field.name));
			if (field.has_expr) {
				strings__Builder_write(&g->enum_typedefs, tos_lit(" = "));
				int pos = g->out.len;
				v__gen__Gen_expr(g, field.expr);
				string expr_str = strings__Builder_after(&g->out, pos);
				strings__Builder_go_back(&g->out, expr_str.len);
				strings__Builder_write(&g->enum_typedefs, expr_str);
				cur_enum_expr = expr_str;
				cur_enum_offset = 0;
			} else if (is_flag) {
				strings__Builder_write(&g->enum_typedefs, tos_lit(" = "));
				cur_enum_expr = _STR("1 << %"PRId32"", 1, i);
				strings__Builder_write(&g->enum_typedefs, any_int_str((1 << i)));
				cur_enum_offset = 0;
			}
			string cur_value = (cur_enum_offset > 0 ? (_STR("%.*s\000+%"PRId32"", 2, cur_enum_expr, cur_enum_offset)) : (cur_enum_expr));
			strings__Builder_writeln(&g->enum_typedefs, _STR(", // %.*s", 1, cur_value));
			cur_enum_offset++;
		}
		strings__Builder_writeln(&g->enum_typedefs, _STR("} %.*s\000;\n", 2, enum_name));
	} else if (_t1337.typ == 259 /* v.ast.ExprStmt */) {
		v__gen__Gen_write_v_source_line_info(g, (*node._259).pos);
		v__gen__Gen_expr(g, (*node._259).expr);
		if (g->inside_ternary == 0 && !(*node._259).is_expr && !(((*node._259).expr).typ == 225 /* v.ast.IfExpr */)) {
			v__gen__Gen_writeln(g, tos_lit(";"));
		}
	} else if (_t1337.typ == 151 /* v.ast.FnDecl */) {
		v__gen__Gen_gen_attrs(g, (*node._151).attrs);
		bool skip = false;
		int pos = g->out.buf.len;
		if (g->pref->build_mode == v__pref__BuildMode_build_module) {
			if (!string_starts_with((*node._151).name, string_add(g->module_built, tos_lit("."))) && string_ne((*node._151).mod, string_after(g->module_built, tos_lit("/")))) {
				println(_STR("skip bm %.*s\000 mode=%.*s\000 module_built=%.*s", 3, (*node._151).name, (*node._151).mod, g->module_built));
				skip = true;
			}
			if (g->is_builtin_mod && string_eq(g->module_built, tos_lit("builtin"))) {
				skip = false;
			}
			if (!skip) {
				println(_STR("build module `%.*s\000` fn `%.*s\000`", 3, g->module_built, (*node._151).name));
			}
		}
		if (g->pref->use_cache) {
			if (string_ne((*node._151).mod, tos_lit("main")) && string_ne((*node._151).mod, tos_lit("help"))) {
				skip = true;
			}
		}
		v__ast__FnDecl* keep_fn_decl = g->fn_decl;
		g->fn_decl = &(*node._151);
		if (string_eq((*node._151).name, tos_lit("main.main"))) {
			g->has_main = true;
		}
		if (string_eq((*node._151).name, tos_lit("backtrace")) || string_eq((*node._151).name, tos_lit("backtrace_symbols")) || string_eq((*node._151).name, tos_lit("backtrace_symbols_fd"))) {
			v__gen__Gen_write(g, tos_lit("\n#ifndef __cplusplus\n"));
		}
		v__gen__Gen_gen_fn_decl(g, (*node._151), skip);
		if (string_eq((*node._151).name, tos_lit("backtrace")) || string_eq((*node._151).name, tos_lit("backtrace_symbols")) || string_eq((*node._151).name, tos_lit("backtrace_symbols_fd"))) {
			v__gen__Gen_write(g, tos_lit("\n#endif\n"));
		}
		g->fn_decl = keep_fn_decl;
		if (skip) {
			strings__Builder_go_back_to(&g->out, pos);
		}
		if ((*node._151).language != v__table__Language_c) {
			v__gen__Gen_writeln(g, tos_lit(""));
		}
	} else if (_t1337.typ == 260 /* v.ast.ForCStmt */) {
		v__gen__Gen_write_v_source_line_info(g, (*node._260).pos);
		g->is_vlines_enabled = false;
		if ((*node._260).label.len > 0) {
			v__gen__Gen_writeln(g, _STR("%.*s\000:", 2, (*node._260).label));
		}
		v__gen__Gen_write(g, tos_lit("for ("));
		if (!(*node._260).has_init) {
			v__gen__Gen_write(g, tos_lit("; "));
		} else {
			v__gen__Gen_stmt(g, (*node._260).init);
			if (string_eq(strings__Builder_last_n(&g->out, 1), tos_lit("\n"))) {
				strings__Builder_go_back(&g->out, 1);
				g->empty_line = false;
				v__gen__Gen_write(g, tos_lit(" "));
			}
		}
		if ((*node._260).has_cond) {
			v__gen__Gen_expr(g, (*node._260).cond);
		}
		v__gen__Gen_write(g, tos_lit("; "));
		if ((*node._260).has_inc) {
			v__gen__Gen_stmt(g, (*node._260).inc);
		}
		v__gen__Gen_writeln(g, tos_lit(") {"));
		g->is_vlines_enabled = true;
		v__gen__Gen_stmts(g, (*node._260).stmts);
		if ((*node._260).label.len > 0) {
			v__gen__Gen_writeln(g, _STR("%.*s\000__continue: {}", 2, (*node._260).label));
		}
		v__gen__Gen_writeln(g, tos_lit("}"));
		if ((*node._260).label.len > 0) {
			v__gen__Gen_writeln(g, _STR("%.*s\000__break: {}", 2, (*node._260).label));
		}
	} else if (_t1337.typ == 261 /* v.ast.ForInStmt */) {
		v__gen__Gen_write_v_source_line_info(g, (*node._261).pos);
		v__gen__Gen_for_in(g, (*node._261));
	} else if (_t1337.typ == 262 /* v.ast.ForStmt */) {
		v__gen__Gen_write_v_source_line_info(g, (*node._262).pos);
		g->is_vlines_enabled = false;
		if ((*node._262).label.len > 0) {
			v__gen__Gen_writeln(g, _STR("%.*s\000:", 2, (*node._262).label));
		}
		v__gen__Gen_writeln(g, tos_lit("for (;;) {"));
		if (!(*node._262).is_inf) {
			g->indent++;
			array_push(&g->stmt_path_pos, _MOV((int[]){ g->out.len }));
			v__gen__Gen_write(g, tos_lit("if (!("));
			v__gen__Gen_expr(g, (*node._262).cond);
			v__gen__Gen_writeln(g, tos_lit(")) break;"));
			g->indent--;
		}
		g->is_vlines_enabled = true;
		v__gen__Gen_stmts(g, (*node._262).stmts);
		if ((*node._262).label.len > 0) {
			v__gen__Gen_writeln(g, _STR("\t%.*s\000__continue: {}", 2, (*node._262).label));
		}
		v__gen__Gen_writeln(g, tos_lit("}"));
		if ((*node._262).label.len > 0) {
			v__gen__Gen_writeln(g, _STR("%.*s\000__break: {}", 2, (*node._262).label));
		}
	} else if (_t1337.typ == 263 /* v.ast.GlobalDecl */) {
		v__gen__Gen_global_decl(g, (*node._263));
	} else if (_t1337.typ == 264 /* v.ast.GoStmt */) {
		v__gen__Gen_go_stmt(g, (*node._264));
	} else if (_t1337.typ == 265 /* v.ast.GotoLabel */) {
		v__gen__Gen_writeln(g, _STR("%.*s\000: {}", 2, (*node._265).name));
	} else if (_t1337.typ == 266 /* v.ast.GotoStmt */) {
		v__gen__Gen_writeln(g, _STR("goto %.*s\000;", 2, (*node._266).name));
	} else if (_t1337.typ == 267 /* v.ast.HashStmt */) {
		if (string_eq((*node._267).kind, tos_lit("include"))) {
			string missing_message = _STR("Header file %.*s\000, needed for module `%.*s\000` was not found.", 3, (*node._267).main, (*node._267).mod);
			if (((*node._267).msg).len != 0) {
				missing_message = /*f*/string_add(missing_message, _STR(" %.*s\000.", 2, (*node._267).msg));
			} else {
				missing_message = /*f*/string_add(missing_message, tos_lit(" Please install the corresponding development headers."));
			}
			string guarded_include = v__gen__get_guarded_include_text((*node._267).main, missing_message);
			if (string_eq((*node._267).main, tos_lit("<errno.h>"))) {
				guarded_include = _STR("#include %.*s", 1, (*node._267).main);
			}
			if (string_contains((*node._267).main, tos_lit(".m"))) {
				strings__Builder_writeln(&g->definitions, _STR("// added by module `%.*s\000`:", 2, (*node._267).mod));
				strings__Builder_writeln(&g->definitions, guarded_include);
			} else {
				strings__Builder_writeln(&g->includes, _STR("// added by module `%.*s\000`:", 2, (*node._267).mod));
				strings__Builder_writeln(&g->includes, guarded_include);
			}
		} else if (string_eq((*node._267).kind, tos_lit("define"))) {
			strings__Builder_writeln(&g->includes, _STR("// defined by module `%.*s\000`:", 2, (*node._267).mod));
			strings__Builder_writeln(&g->includes, _STR("#define %.*s", 1, (*node._267).main));
		}
	} else if (_t1337.typ == 268 /* v.ast.Import */) {
	} else if (_t1337.typ == 269 /* v.ast.InterfaceDecl */) {
	} else if (_t1337.typ == 270 /* v.ast.Module */) {
		g->is_builtin_mod = (string_eq((*node._270).name, tos_lit("builtin")) || string_eq((*node._270).name, tos_lit("os")) || string_eq((*node._270).name, tos_lit("strconv")));
		g->cur_mod = (*node._270).name;
	} else if (_t1337.typ == 271 /* v.ast.Return */) {
		v__gen__Gen_write_defer_stmts_when_needed(g);
		bool af = g->pref->autofree && !g->is_builtin_mod;
		if (af) {
			v__gen__Gen_writeln(g, tos_lit("// ast.Return free"));
			v__gen__Gen_writeln(g, tos_lit("// ast.Return free_end"));
		}
		v__gen__Gen_return_statement(g, (*node._271));
	} else if (_t1337.typ == 272 /* v.ast.SqlStmt */) {
		v__gen__Gen_sql_stmt(g, (*node._272));
	} else if (_t1337.typ == 273 /* v.ast.StructDecl */) {
		string name = ((*node._273).language == v__table__Language_c ? (v__util__no_dots((*node._273).name)) : (v__gen__c_name((*node._273).name)));
		if ((*node._273).language == v__table__Language_c) {
			// Defer begin
			// Defer end
			return;
		}
		if ((*node._273).is_union) {
			strings__Builder_writeln(&g->typedefs, _STR("typedef union %.*s\000 %.*s\000;", 3, name, name));
		} else {
			strings__Builder_writeln(&g->typedefs, _STR("typedef struct %.*s\000 %.*s\000;", 3, name, name));
		}
	} else if (_t1337.typ == 207 /* v.ast.TypeDecl */) {
		v__gen__Gen_writeln(g, tos_lit("// TypeDecl"));
	};
	if (!g->skip_stmt_pos) {
		array_delete_last(&g->stmt_path_pos);
	}
	if (g->pref->autofree) {
		if ((node).typ != 151 /* v.ast.FnDecl */) {
		}
	}
// Defer begin
// Defer end
}

VV_LOCAL_SYMBOL void v__gen__Gen_write_defer_stmts(v__gen__Gen* g) {
	// FOR IN array
	array _t1341 = g->defer_stmts;
	for (int _t1342 = 0; _t1342 < _t1341.len; ++_t1342) {
		v__ast__DeferStmt defer_stmt = ((v__ast__DeferStmt*)_t1341.data)[_t1342];
		v__gen__Gen_writeln(g, tos_lit("// Defer begin"));
		if (defer_stmt.ifdef.len > 0) {
			v__gen__Gen_writeln(g, defer_stmt.ifdef);
			v__gen__Gen_stmts(g, defer_stmt.stmts);
			v__gen__Gen_writeln(g, tos_lit(""));
			v__gen__Gen_writeln(g, tos_lit("#endif"));
		} else {
			g->indent--;
			v__gen__Gen_stmts(g, defer_stmt.stmts);
			g->indent++;
		}
		v__gen__Gen_writeln(g, tos_lit("// Defer end"));
	}
}

VV_LOCAL_SYMBOL void v__gen__Gen_for_in(v__gen__Gen* g, v__ast__ForInStmt it) {
	if (it.label.len > 0) {
		v__gen__Gen_writeln(g, _STR("\t%.*s\000: {}", 2, it.label));
	}
	if (it.is_range) {
		string i = (string_eq(it.val_var, tos_lit("_")) ? (v__gen__Gen_new_tmp_var(g)) : (v__gen__c_name(it.val_var)));
		v__gen__Gen_write(g, _STR("for (int %.*s\000 = ", 2, i));
		v__gen__Gen_expr(g, it.cond);
		v__gen__Gen_write(g, _STR("; %.*s\000 < ", 2, i));
		v__gen__Gen_expr(g, it.high);
		v__gen__Gen_writeln(g, _STR("; ++%.*s\000) {", 2, i));
	} else if (it.kind == v__table__Kind_array) {
		v__gen__Gen_writeln(g, tos_lit("// FOR IN array"));
		string styp = v__gen__Gen_typ(g, it.val_type);
		v__table__TypeSymbol* val_sym = v__table__Table_get_type_symbol(g->table, it.val_type);
		bool cond_type_is_ptr = v__table__Type_is_ptr(it.cond_type);
		string tmp = v__gen__Gen_new_tmp_var(g);
		string tmp_type = (cond_type_is_ptr ? (tos_lit("array *")) : (tos_lit("array")));
		v__gen__Gen_write(g, _STR("%.*s\000 %.*s\000 = ", 3, tmp_type, tmp));
		v__gen__Gen_expr(g, it.cond);
		v__gen__Gen_writeln(g, tos_lit(";"));
		string i = ((string_eq(it.key_var, tos_lit("")) || string_eq(it.key_var, tos_lit("_"))) ? (v__gen__Gen_new_tmp_var(g)) : (it.key_var));
		string op_field = (cond_type_is_ptr ? (tos_lit("->")) : (tos_lit(".")));
		v__gen__Gen_writeln(g, _STR("for (int %.*s\000 = 0; %.*s\000 < %.*s\000%.*s\000len; ++%.*s\000) {", 6, i, i, tmp, op_field, i));
		if (string_ne(it.val_var, tos_lit("_"))) {
			if (val_sym->kind == v__table__Kind_function) {
				v__gen__Gen_write(g, tos_lit("\t"));
				v__gen__Gen_write_fn_ptr_decl(g, (voidptr)&/*qq*//* as */ *(v__table__FnType*)__as_cast((val_sym->info)._353, (val_sym->info).typ, /*expected:*/353), v__gen__c_name(it.val_var));
				v__gen__Gen_writeln(g, _STR(" = ((voidptr*)%.*s\000%.*s\000data)[%.*s\000];", 4, tmp, op_field, i));
			} else {
				string right = (it.val_is_mut ? (_STR("((%.*s\000)%.*s\000%.*s\000data) + %.*s", 4, styp, tmp, op_field, i)) : (_STR("((%.*s\000*)%.*s\000%.*s\000data)[%.*s\000]", 5, styp, tmp, op_field, i)));
				v__gen__Gen_writeln(g, _STR("\t%.*s\000 %.*s\000 = %.*s\000;", 4, styp, v__gen__c_name(it.val_var), right));
			}
		}
	} else if (it.kind == v__table__Kind_array_fixed) {
		string atmp = v__gen__Gen_new_tmp_var(g);
		string atmp_type = v__gen__Gen_typ(g, it.cond_type);
		if (!v__ast__Expr_is_lvalue(it.cond)) {
			v__gen__Gen_error(g, _STR("for in: unhandled condition `%.*s\000`", 2, v__ast__Expr_str(it.cond)), it.pos);
		}
		v__gen__Gen_write(g, _STR("%.*s\000 *%.*s\000 = &", 3, atmp_type, atmp));
		v__gen__Gen_expr(g, it.cond);
		v__gen__Gen_writeln(g, tos_lit(";"));
		string i = ((string_eq(it.key_var, tos_lit("")) || string_eq(it.key_var, tos_lit("_"))) ? (v__gen__Gen_new_tmp_var(g)) : (it.key_var));
		v__table__TypeSymbol* cond_sym = v__table__Table_get_type_symbol(g->table, it.cond_type);
		v__table__ArrayFixed info = /* as */ *(v__table__ArrayFixed*)__as_cast((cond_sym->info)._351, (cond_sym->info).typ, /*expected:*/351);
		v__gen__Gen_writeln(g, _STR("for (int %.*s\000 = 0; %.*s\000 != %"PRId32"\000; ++%.*s\000) {", 5, i, i, info.size, i));
		if (string_ne(it.val_var, tos_lit("_"))) {
			v__table__TypeSymbol* val_sym = v__table__Table_get_type_symbol(g->table, it.val_type);
			if (val_sym->kind == v__table__Kind_function) {
				v__gen__Gen_write(g, tos_lit("\t"));
				v__gen__Gen_write_fn_ptr_decl(g, (voidptr)&/*qq*//* as */ *(v__table__FnType*)__as_cast((val_sym->info)._353, (val_sym->info).typ, /*expected:*/353), v__gen__c_name(it.val_var));
			} else {
				string styp = v__gen__Gen_typ(g, it.val_type);
				v__gen__Gen_write(g, _STR("\t%.*s\000 %.*s", 2, styp, v__gen__c_name(it.val_var)));
			}
			v__gen__Gen_writeln(g, _STR(" = (*%.*s\000)[%.*s\000];", 3, atmp, i));
		}
	} else if (it.kind == v__table__Kind_map) {
		v__gen__Gen_writeln(g, tos_lit("// FOR IN map"));
		string idx = v__gen__Gen_new_tmp_var(g);
		string atmp = v__gen__Gen_new_tmp_var(g);
		string atmp_styp = v__gen__Gen_typ(g, it.cond_type);
		v__gen__Gen_write(g, _STR("%.*s\000 %.*s\000 = ", 3, atmp_styp, atmp));
		v__gen__Gen_expr(g, it.cond);
		v__gen__Gen_writeln(g, tos_lit(";"));
		v__gen__Gen_writeln(g, _STR("for (int %.*s\000 = 0; %.*s\000 < %.*s\000.key_values.len; ++%.*s\000) {", 5, idx, idx, atmp, idx));
		v__gen__Gen_writeln(g, _STR("\tif (%.*s\000.key_values.keys[%.*s\000].str == 0) {continue;}", 3, atmp, idx));
		if (string_ne(it.key_var, tos_lit("_"))) {
			string key_styp = v__gen__Gen_typ(g, it.key_type);
			string key = v__gen__c_name(it.key_var);
			if (it.key_type == _const_v__table__string_type) {
				v__gen__Gen_writeln(g, _STR("\t%.*s\000 %.*s\000 = /*key*/ string_clone(%.*s\000.key_values.keys[%.*s\000]);", 5, key_styp, key, atmp, idx));
			} else {
				v__gen__Gen_writeln(g, _STR("\t%.*s\000 %.*s\000 = /*key*/ %.*s\000.key_values.keys[%.*s\000];", 5, key_styp, key, atmp, idx));
			}
		}
		if (string_ne(it.val_var, tos_lit("_"))) {
			v__table__TypeSymbol* val_sym = v__table__Table_get_type_symbol(g->table, it.val_type);
			string valstr = _STR("(void*)(%.*s\000.key_values.values + %.*s\000 * (u32)(%.*s\000.value_bytes))", 4, atmp, idx, atmp);
			if (val_sym->kind == v__table__Kind_function) {
				v__gen__Gen_write(g, tos_lit("\t"));
				v__gen__Gen_write_fn_ptr_decl(g, (voidptr)&/*qq*//* as */ *(v__table__FnType*)__as_cast((val_sym->info)._353, (val_sym->info).typ, /*expected:*/353), v__gen__c_name(it.val_var));
				v__gen__Gen_writeln(g, _STR(" = (*(voidptr*)%.*s\000);", 2, valstr));
			} else {
				string val_styp = v__gen__Gen_typ(g, it.val_type);
				v__gen__Gen_writeln(g, _STR("\t%.*s\000 %.*s\000 = (*(%.*s\000*)%.*s\000);", 5, val_styp, v__gen__c_name(it.val_var), val_styp, valstr));
			}
		}
		v__gen__Gen_stmts(g, it.stmts);
		if (it.key_type == _const_v__table__string_type && !g->is_builtin_mod) {
		}
		if (it.label.len > 0) {
			v__gen__Gen_writeln(g, _STR("\t%.*s\000__continue: {}", 2, it.label));
		}
		v__gen__Gen_writeln(g, tos_lit("}"));
		if (it.label.len > 0) {
			v__gen__Gen_writeln(g, _STR("\t%.*s\000__break: {}", 2, it.label));
		}
		return;
	} else if (v__table__Type_has_flag(it.cond_type, v__table__TypeFlag_variadic)) {
		v__gen__Gen_writeln(g, tos_lit("// FOR IN cond_type/variadic"));
		string i = ((string_eq(it.key_var, tos_lit("")) || string_eq(it.key_var, tos_lit("_"))) ? (v__gen__Gen_new_tmp_var(g)) : (it.key_var));
		string styp = v__gen__Gen_typ(g, it.cond_type);
		v__gen__Gen_write(g, _STR("for (int %.*s\000 = 0; %.*s\000 < ", 3, i, i));
		v__gen__Gen_expr(g, it.cond);
		v__gen__Gen_writeln(g, _STR(".len; ++%.*s\000) {", 2, i));
		v__gen__Gen_write(g, _STR("\t%.*s\000 %.*s\000 = ", 3, styp, v__gen__c_name(it.val_var)));
		v__gen__Gen_expr(g, it.cond);
		v__gen__Gen_writeln(g, _STR(".args[%.*s\000];", 2, i));
	} else if (it.kind == v__table__Kind_string) {
		string i = ((string_eq(it.key_var, tos_lit("")) || string_eq(it.key_var, tos_lit("_"))) ? (v__gen__Gen_new_tmp_var(g)) : (it.key_var));
		v__gen__Gen_write(g, _STR("for (int %.*s\000 = 0; %.*s\000 < ", 3, i, i));
		v__gen__Gen_expr(g, it.cond);
		v__gen__Gen_writeln(g, _STR(".len; ++%.*s\000) {", 2, i));
		if (string_ne(it.val_var, tos_lit("_"))) {
			v__gen__Gen_write(g, _STR("\tbyte %.*s\000 = ", 2, v__gen__c_name(it.val_var)));
			v__gen__Gen_expr(g, it.cond);
			v__gen__Gen_writeln(g, _STR(".str[%.*s\000];", 2, i));
		}
	} else {
		string s = v__table__Table_type_to_str(g->table, it.cond_type);
		v__gen__Gen_error(g, _STR("for in: unhandled symbol `%.*s\000` of type `%.*s\000`", 3, v__ast__Expr_str(it.cond), s), it.pos);
	}
	v__gen__Gen_stmts(g, it.stmts);
	if (it.label.len > 0) {
		v__gen__Gen_writeln(g, _STR("\t%.*s\000__continue: {}", 2, it.label));
	}
	v__gen__Gen_writeln(g, tos_lit("}"));
	if (it.label.len > 0) {
		v__gen__Gen_writeln(g, _STR("\t%.*s\000__break: {}", 2, it.label));
	}
}

VV_LOCAL_SYMBOL void v__gen__Gen_expr_with_cast(v__gen__Gen* g, v__ast__Expr expr, v__table__Type got_type, v__table__Type expected_type) {
	if (expected_type != _const_v__table__void_type) {
		bool expected_is_ptr = v__table__Type_is_ptr(expected_type);
		v__table__Type expected_deref_type = (expected_is_ptr ? (v__table__Type_deref(expected_type)) : (expected_type));
		bool got_is_ptr = v__table__Type_is_ptr(got_type);
		v__table__Type got_deref_type = (got_is_ptr ? (v__table__Type_deref(got_type)) : (got_type));
		if (v__table__Table_sumtype_has_variant(g->table, expected_deref_type, got_deref_type)) {
			string exp_styp = v__gen__Gen_typ(g, expected_type);
			string got_styp = v__gen__Gen_typ(g, got_type);
			int got_idx = v__table__Type_idx(got_type);
			v__table__TypeSymbol* got_sym = v__table__Table_get_type_symbol(g->table, got_type);
			if (expected_is_ptr && got_is_ptr) {
				string exp_der_styp = v__gen__Gen_typ(g, expected_deref_type);
				v__gen__Gen_write(g, _STR("/* sum type cast 1 */ (%.*s\000) memdup(&(%.*s\000){._%"PRId32"\000 = ", 4, exp_styp, exp_der_styp, got_type));
				v__gen__Gen_expr(g, expr);
				v__gen__Gen_write(g, _STR(", .typ = %"PRId32"\000 /* %.*s\000 */}, sizeof(%.*s\000))", 4, got_type, got_sym->name, exp_der_styp));
			} else if (expected_is_ptr) {
				string exp_der_styp = v__gen__Gen_typ(g, expected_deref_type);
				v__gen__Gen_write(g, _STR("/* sum type cast 2 */ (%.*s\000) memdup(&(%.*s\000){._%"PRId32"\000 = memdup(&(%.*s\000[]){", 5, exp_styp, exp_der_styp, got_type, got_styp));
				v__gen__Gen_expr(g, expr);
				v__gen__Gen_write(g, _STR("}, sizeof(%.*s\000)), .typ = %"PRId32"\000 /* %.*s\000 */}, sizeof(%.*s\000))", 5, got_styp, got_type, got_sym->name, exp_der_styp));
			} else if (got_is_ptr) {
				v__gen__Gen_write(g, _STR("/* sum type cast 3 */ (%.*s\000){._%"PRId32"\000 = ", 3, exp_styp, got_idx));
				v__gen__Gen_expr(g, expr);
				v__gen__Gen_write(g, _STR(", .typ = %"PRId32"\000 /* %.*s\000 */}", 3, got_type, got_sym->name));
			} else {
				bool is_already_sum_type = false;
				v__ast__Scope* scope = v__ast__Scope_innermost(g->file.scope, v__ast__Expr_position(expr).pos);
				if ((expr).typ == 224 /* v.ast.Ident */) {
					{ /* if guard */ 
					Option_v__ast__Var_ptr _t1343;
					if (_t1343 = v__ast__Scope_find_var(scope, (*expr._224).name), _t1343.ok) {
						v__ast__Var* v = *(v__ast__Var**)_t1343.data;
						if (v->sum_type_casts.len > 0) {
							is_already_sum_type = true;
						}
					}}
				} else if ((expr).typ == 241 /* v.ast.SelectorExpr */) {
					{ /* if guard */ 
					Option_v__ast__ScopeStructField _t1344;
					if (_t1344 = v__ast__Scope_find_struct_field(scope, (*expr._241).expr_type, (*expr._241).field_name), _t1344.ok) {
						is_already_sum_type = true;
					}}
				}
				if (is_already_sum_type) {
					g->prevent_sum_type_unwrapping_once = true;
					v__gen__Gen_expr(g, expr);
				} else {
					v__gen__Gen_write(g, _STR("/* sum type cast 4 */ (%.*s\000){._%"PRId32"\000 = memdup(&(%.*s\000[]){", 4, exp_styp, got_type, got_styp));
					v__gen__Gen_expr(g, expr);
					v__gen__Gen_write(g, _STR("}, sizeof(%.*s\000)), .typ = %"PRId32"\000 /* %.*s\000 */}", 4, got_styp, got_type, got_sym->name));
				}
			}
			return;
		}
	}
	v__table__TypeSymbol* expected_sym = v__table__Table_get_type_symbol(g->table, expected_type);
	bool got_is_ptr = v__table__Type_is_ptr(got_type);
	bool expected_is_ptr = v__table__Type_is_ptr(expected_type);
	bool neither_void = !(_const_v__table__voidptr_type == got_type || _const_v__table__voidptr_type == expected_type);
	if (got_is_ptr && !expected_is_ptr && neither_void && !(expected_sym->kind == v__table__Kind_interface_ || expected_sym->kind == v__table__Kind_placeholder)) {
		v__table__Type got_deref_type = v__table__Type_deref(got_type);
		v__table__TypeSymbol* deref_sym = v__table__Table_get_type_symbol(g->table, got_deref_type);
		bool deref_will_match = (expected_type == got_type || expected_type == got_deref_type || expected_type == deref_sym->parent_idx);
		bool got_is_opt = v__table__Type_has_flag(got_type, v__table__TypeFlag_optional);
		if (deref_will_match || got_is_opt) {
			v__gen__Gen_write(g, tos_lit("*"));
		}
	}
	v__gen__Gen_expr(g, expr);
}

VV_LOCAL_SYMBOL string v__gen__cestring(string s) {
	return string_replace(string_replace(s, tos_lit("\\"), tos_lit("\\\\")), tos_lit("\""), tos_lit("\'"));
}

VV_LOCAL_SYMBOL string v__gen__ctoslit(string s) {
	return string_add(string_add(tos_lit("tos_lit(\""), v__gen__cestring(s)), tos_lit("\")"));
}

VV_LOCAL_SYMBOL void v__gen__Gen_gen_attrs(v__gen__Gen* g, array_v__table__Attr attrs) {
	// FOR IN array
	array _t1345 = attrs;
	for (int _t1346 = 0; _t1346 < _t1345.len; ++_t1346) {
		v__table__Attr attr = ((v__table__Attr*)_t1345.data)[_t1346];
		v__gen__Gen_writeln(g, _STR("// Attr: [%.*s\000]", 2, attr.name));
	}
}

VV_LOCAL_SYMBOL void v__gen__Gen_gen_assert_stmt(v__gen__Gen* g, v__ast__AssertStmt original_assert_statement) {
	v__ast__AssertStmt a = original_assert_statement;
	v__gen__Gen_writeln(g, tos_lit("// assert"));
	if ((a.expr).typ == 228 /* v.ast.InfixExpr */) {
		if (((*a.expr._228).left).typ == 215 /* v.ast.CallExpr */) {
			(*a.expr._228).left = /* sum type cast 4 */ (v__ast__Expr){._214 = memdup(&(v__ast__CTempVar[]){v__gen__Gen_new_ctemp_var_then_gen(g, (*a.expr._228).left, (*a.expr._228).left_type)}, sizeof(v__ast__CTempVar)), .typ = 214 /* v.ast.CTempVar */};
		}
		if (((*a.expr._228).right).typ == 215 /* v.ast.CallExpr */) {
			(*a.expr._228).right = /* sum type cast 4 */ (v__ast__Expr){._214 = memdup(&(v__ast__CTempVar[]){v__gen__Gen_new_ctemp_var_then_gen(g, (*a.expr._228).right, (*a.expr._228).right_type)}, sizeof(v__ast__CTempVar)), .typ = 214 /* v.ast.CTempVar */};
		}
	}
	g->inside_ternary++;
	v__gen__Gen_write(g, tos_lit("if ("));
	v__gen__Gen_expr(g, a.expr);
	v__gen__Gen_write(g, tos_lit(")"));
	v__gen__Gen_decrement_inside_ternary(g);
	if (g->is_test) {
		v__gen__Gen_writeln(g, tos_lit("{"));
		v__gen__Gen_writeln(g, tos_lit("\tg_test_oks++;"));
		string metaname_ok = v__gen__Gen_gen_assert_metainfo(g, a);
		v__gen__Gen_writeln(g, _STR("\tmain__cb_assertion_ok(&%.*s\000);", 2, metaname_ok));
		v__gen__Gen_writeln(g, tos_lit("} else {"));
		v__gen__Gen_writeln(g, tos_lit("\tg_test_fails++;"));
		string metaname_fail = v__gen__Gen_gen_assert_metainfo(g, a);
		v__gen__Gen_writeln(g, _STR("\tmain__cb_assertion_failed(&%.*s\000);", 2, metaname_fail));
		v__gen__Gen_writeln(g, tos_lit("\tlongjmp(g_jump_buffer, 1);"));
		v__gen__Gen_writeln(g, tos_lit("\t// TODO"));
		v__gen__Gen_writeln(g, tos_lit("\t// Maybe print all vars in a test function if it fails?"));
		v__gen__Gen_writeln(g, tos_lit("}"));
		return;
	}
	v__gen__Gen_writeln(g, tos_lit(" {} else {"));
	string metaname_panic = v__gen__Gen_gen_assert_metainfo(g, a);
	v__gen__Gen_writeln(g, _STR("\t__print_assert_failure(&%.*s\000);", 2, metaname_panic));
	v__gen__Gen_writeln(g, tos_lit("\tv_panic(tos_lit(\"Assertion failed...\"));"));
	v__gen__Gen_writeln(g, tos_lit("\texit(1);"));
	v__gen__Gen_writeln(g, tos_lit("}"));
}

VV_LOCAL_SYMBOL string v__gen__cnewlines(string s) {
	return string_replace(s, tos_lit("\n"), tos_lit("\\n"));
}

VV_LOCAL_SYMBOL string v__gen__Gen_gen_assert_metainfo(v__gen__Gen* g, v__ast__AssertStmt a) {
	string mod_path = v__gen__cestring(g->file.path);
	string fn_name = g->fn_decl->name;
	int line_nr = a.pos.line_nr;
	string src = v__gen__cestring(v__ast__Expr_str(a.expr));
	string metaname = _STR("v_assert_meta_info_%.*s", 1, v__gen__Gen_new_tmp_var(g));
	v__gen__Gen_writeln(g, _STR("\tVAssertMetaInfo %.*s\000;", 2, metaname));
	v__gen__Gen_writeln(g, _STR("\tmemset(&%.*s\000, 0, sizeof(VAssertMetaInfo));", 2, metaname));
	v__gen__Gen_writeln(g, _STR("\t%.*s\000.fpath = %.*s\000;", 3, metaname, v__gen__ctoslit(mod_path)));
	v__gen__Gen_writeln(g, _STR("\t%.*s\000.line_nr = %"PRId32"\000;", 3, metaname, line_nr));
	v__gen__Gen_writeln(g, _STR("\t%.*s\000.fn_name = %.*s\000;", 3, metaname, v__gen__ctoslit(fn_name)));
	v__gen__Gen_writeln(g, _STR("\t%.*s\000.src = %.*s\000;", 3, metaname, v__gen__cnewlines(v__gen__ctoslit(src))));
	v__ast__Expr _t1347 = a.expr;
	if (_t1347.typ == 228 /* v.ast.InfixExpr */) {
		v__gen__Gen_writeln(g, _STR("\t%.*s\000.op = %.*s\000;", 3, metaname, v__gen__ctoslit(v__token__Kind_str((*a.expr._228).op))));
		v__gen__Gen_writeln(g, _STR("\t%.*s\000.llabel = %.*s\000;", 3, metaname, v__gen__cnewlines(v__gen__ctoslit(v__ast__Expr_str((*a.expr._228).left)))));
		v__gen__Gen_writeln(g, _STR("\t%.*s\000.rlabel = %.*s\000;", 3, metaname, v__gen__cnewlines(v__gen__ctoslit(v__ast__Expr_str((*a.expr._228).right)))));
		v__gen__Gen_write(g, _STR("\t%.*s\000.lvalue = ", 2, metaname));
		v__gen__Gen_gen_assert_single_expr(g, (*a.expr._228).left, (*a.expr._228).left_type);
		v__gen__Gen_writeln(g, tos_lit(";"));
		v__gen__Gen_write(g, _STR("\t%.*s\000.rvalue = ", 2, metaname));
		v__gen__Gen_gen_assert_single_expr(g, (*a.expr._228).right, (*a.expr._228).right_type);
		v__gen__Gen_writeln(g, tos_lit(";"));
	} else if (_t1347.typ == 215 /* v.ast.CallExpr */) {
		v__gen__Gen_writeln(g, _STR("\t%.*s\000.op = tos_lit(\"call\");", 2, metaname));
	} else {
	};
	return metaname;
}

VV_LOCAL_SYMBOL void v__gen__Gen_gen_assert_single_expr(v__gen__Gen* g, v__ast__Expr e, v__table__Type t) {
	string unknown_value = tos_lit("*unknown value*");
	v__ast__Expr _t1348 = e;
	if (_t1348.typ == 216 /* v.ast.CastExpr */) {
		v__gen__Gen_write(g, v__gen__ctoslit(unknown_value));
	} else if (_t1348.typ == 227 /* v.ast.IndexExpr */) {
		v__gen__Gen_write(g, v__gen__ctoslit(unknown_value));
	} else if (_t1348.typ == 233 /* v.ast.MatchExpr */) {
		v__gen__Gen_write(g, v__gen__ctoslit(unknown_value));
	} else if (_t1348.typ == 238 /* v.ast.PrefixExpr */) {
		if (((*e._238).right).typ == 216 /* v.ast.CastExpr */) {
			v__gen__Gen_write(g, v__gen__ctoslit(unknown_value));
		} else {
			Option_bool _t1349 = v__gen__Gen_gen_expr_to_string(g, e, t);
			if (!_t1349.ok) {
				string err = _t1349.v_error;
				int errcode = _t1349.ecode;
				v__gen__Gen_write(g, v__gen__ctoslit(_STR("[%.*s\000]", 2, err)));
			};
		}
	} else if (_t1348.typ == 247 /* v.ast.Type */) {
		v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, t);
		v__gen__Gen_write(g, v__gen__ctoslit(_STR("%.*s", 1, sym->name)));
	} else {
		Option_bool _t1350 = v__gen__Gen_gen_expr_to_string(g, e, t);
		if (!_t1350.ok) {
			string err = _t1350.v_error;
			int errcode = _t1350.ecode;
			v__gen__Gen_write(g, v__gen__ctoslit(_STR("[%.*s\000]", 2, err)));
		};
	};
	v__gen__Gen_write(g, string_add(string_add(string_add(string_add(tos_lit(" /* typeof: "), tos3( /* v.ast.Expr */ v_typeof_sumtype_250( (e).typ ))), tos_lit(" type: ")), int_str(t)), tos_lit(" */ ")));
}

VV_LOCAL_SYMBOL void v__gen__Gen_write_fn_ptr_decl(v__gen__Gen* g, v__table__FnType* func, string ptr_name) {
	string ret_styp = v__gen__Gen_typ(g, func->func.return_type);
	v__gen__Gen_write(g, _STR("%.*s\000 (*%.*s\000) (", 3, ret_styp, ptr_name));
	int arg_len = func->func.params.len;
	// FOR IN array
	array _t1351 = func->func.params;
	for (int i = 0; i < _t1351.len; ++i) {
		v__table__Param arg = ((v__table__Param*)_t1351.data)[i];
		string arg_styp = v__gen__Gen_typ(g, arg.typ);
		v__gen__Gen_write(g, _STR("%.*s\000 %.*s", 2, arg_styp, arg.name));
		if (i < arg_len - 1) {
			v__gen__Gen_write(g, tos_lit(", "));
		}
	}
	v__gen__Gen_write(g, tos_lit(")"));
}

VV_LOCAL_SYMBOL void v__gen__Gen_gen_assign_stmt(v__gen__Gen* g, v__ast__AssignStmt assign_stmt) {
	if (assign_stmt.is_static) {
		v__gen__Gen_write(g, tos_lit("static "));
	}
	v__table__Type return_type = _const_v__table__void_type;
	bool is_decl = assign_stmt.op == v__token__Kind_decl_assign;
	v__token__Kind op = (is_decl ? (v__token__Kind_assign) : (assign_stmt.op));
	v__ast__Expr right_expr = (*(v__ast__Expr*)/*ee elem_typ */array_get(assign_stmt.right, 0));
	v__ast__Expr _t1352 = right_expr;
	if (_t1352.typ == 215 /* v.ast.CallExpr */) {
		return_type = (*right_expr._215).return_type;
	} else if (_t1352.typ == 233 /* v.ast.MatchExpr */) {
		return_type = (*right_expr._233).return_type;
	} else if (_t1352.typ == 225 /* v.ast.IfExpr */) {
		return_type = (*right_expr._225).typ;
	} else {
	};
	bool af = g->pref->autofree && !g->is_builtin_mod && assign_stmt.op == v__token__Kind_assign && assign_stmt.left_types.len == 1 && ((*(v__ast__Expr*)/*ee elem_typ */array_get(assign_stmt.left, 0))).typ == 224 /* v.ast.Ident */;
	string sref_name = tos_lit("");
	string type_to_free = tos_lit("");
	if (af) {
		v__table__Type first_left_type = (*(v__table__Type*)/*ee elem_typ */array_get(assign_stmt.left_types, 0));
		v__table__TypeSymbol* first_left_sym = v__table__Table_get_type_symbol(g->table, (*(v__table__Type*)/*ee elem_typ */array_get(assign_stmt.left_types, 0)));
		if (first_left_type == _const_v__table__string_type || first_left_sym->kind == v__table__Kind_array) {
			type_to_free = (first_left_type == _const_v__table__string_type ? (tos_lit("string")) : (tos_lit("array")));
			v__ast__Ident ident = /* as */ *(v__ast__Ident*)__as_cast(((*(v__ast__Expr*)/*ee elem_typ */array_get(assign_stmt.left, 0)))._224, ((*(v__ast__Expr*)/*ee elem_typ */array_get(assign_stmt.left, 0))).typ, /*expected:*/224);
			if (string_ne(ident.name, tos_lit("_"))) {
				sref_name = _STR("_sref%"PRId32"", 1, assign_stmt.pos.pos);
				v__gen__Gen_write(g, _STR("%.*s\000 %.*s\000 = (", 3, type_to_free, sref_name));
				v__gen__Gen_expr(g, (*(v__ast__Expr*)/*ee elem_typ */array_get(assign_stmt.left, 0)));
				v__gen__Gen_writeln(g, _STR("); // free %.*s\000 on re-assignment2", 2, type_to_free));
			} else {
				af = false;
			}
		} else {
			af = false;
		}
	}
	string tmp_opt = tos_lit("");
	bool is_optional = g->pref->autofree && ((assign_stmt.op == v__token__Kind_decl_assign || assign_stmt.op == v__token__Kind_assign)) && assign_stmt.left_types.len == 1 && ((*(v__ast__Expr*)/*ee elem_typ */array_get(assign_stmt.right, 0))).typ == 215 /* v.ast.CallExpr */;
	if (is_optional) {
		v__ast__CallExpr call_expr = /* as */ *(v__ast__CallExpr*)__as_cast(((*(v__ast__Expr*)/*ee elem_typ */array_get(assign_stmt.right, 0)))._215, ((*(v__ast__Expr*)/*ee elem_typ */array_get(assign_stmt.right, 0))).typ, /*expected:*/215);
		if (call_expr.or_block.kind != v__ast__OrKind_absent) {
			string styp = v__gen__Gen_typ(g, v__table__Type_set_flag(call_expr.return_type, v__table__TypeFlag_optional));
			tmp_opt = v__gen__Gen_new_tmp_var(g);
			v__gen__Gen_write(g, _STR("/*AF opt*/%.*s\000 %.*s\000 = ", 3, styp, tmp_opt));
			v__gen__Gen_expr(g, (*(v__ast__Expr*)/*ee elem_typ */array_get(assign_stmt.right, 0)));
			v__gen__Gen_or_block(g, tmp_opt, call_expr.or_block, call_expr.return_type);
			v__gen__Gen_writeln(g, tos_lit("/*=============ret*/"));
		}
	}
	if (return_type != _const_v__table__void_type && return_type != 0) {
		v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, return_type);
		if (sym->kind == v__table__Kind_multi_return) {
			bool is_opt = v__table__Type_has_flag(return_type, v__table__TypeFlag_optional);
			string mr_var_name = _STR("mr_%"PRId32"", 1, assign_stmt.pos.pos);
			string mr_styp = v__gen__Gen_typ(g, return_type);
			v__gen__Gen_write(g, _STR("%.*s\000 %.*s\000 = ", 3, mr_styp, mr_var_name));
			g->is_assign_rhs = true;
			v__gen__Gen_expr(g, (*(v__ast__Expr*)/*ee elem_typ */array_get(assign_stmt.right, 0)));
			g->is_assign_rhs = false;
			v__gen__Gen_writeln(g, tos_lit(";"));
			// FOR IN array
			array _t1353 = assign_stmt.left;
			for (int i = 0; i < _t1353.len; ++i) {
				v__ast__Expr lx = ((v__ast__Expr*)_t1353.data)[i];
				if ((lx).typ == 224 /* v.ast.Ident */) {
					if ((*lx._224).kind == v__ast__IdentKind_blank_ident) {
						continue;
					}
				}
				string styp = v__gen__Gen_typ(g, (*(v__table__Type*)/*ee elem_typ */array_get(assign_stmt.left_types, i)));
				if (assign_stmt.op == v__token__Kind_decl_assign) {
					v__gen__Gen_write(g, _STR("%.*s\000 ", 2, styp));
				}
				v__gen__Gen_expr(g, lx);
				if (is_opt) {
					string mr_base_styp = v__gen__Gen_base_type(g, return_type);
					v__gen__Gen_writeln(g, _STR(" = (*(%.*s\000*)%.*s\000.data).arg%"PRId32"\000;", 4, mr_base_styp, mr_var_name, i));
				} else {
					v__gen__Gen_writeln(g, _STR(" = %.*s\000.arg%"PRId32"\000;", 3, mr_var_name, i));
				}
			}
			// Defer begin
			if (af) {
				v__gen__Gen_writeln(g, _STR("%.*s\000_free(&%.*s\000);", 3, type_to_free, sref_name));
			}
			// Defer end
			return;
		}
	}
	if (assign_stmt.has_cross_var) {
		// FOR IN array
		array _t1354 = assign_stmt.left;
		for (int i = 0; i < _t1354.len; ++i) {
			v__ast__Expr left = ((v__ast__Expr*)_t1354.data)[i];
			v__ast__Expr _t1355 = left;
			if (_t1355.typ == 224 /* v.ast.Ident */) {
				v__table__Type left_typ = (*(v__table__Type*)/*ee elem_typ */array_get(assign_stmt.left_types, i));
				v__table__TypeSymbol* left_sym = v__table__Table_get_type_symbol(g->table, left_typ);
				if (left_sym->kind == v__table__Kind_function) {
					v__gen__Gen_write_fn_ptr_decl(g, (voidptr)&/*qq*//* as */ *(v__table__FnType*)__as_cast((left_sym->info)._353, (left_sym->info).typ, /*expected:*/353), _STR("_var_%"PRId32"", 1, (*left._224).pos.pos));
					v__gen__Gen_writeln(g, _STR(" = %.*s\000;", 2, (*left._224).name));
				} else {
					string styp = v__gen__Gen_typ(g, left_typ);
					v__gen__Gen_writeln(g, _STR("%.*s\000 _var_%"PRId32"\000 = %.*s\000;", 4, styp, (*left._224).pos.pos, (*left._224).name));
				}
			} else if (_t1355.typ == 227 /* v.ast.IndexExpr */) {
				v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, (*left._227).left_type);
				if (sym->kind == v__table__Kind_array) {
					v__table__Array info = /* as */ *(v__table__Array*)__as_cast((sym->info)._350, (sym->info).typ, /*expected:*/350);
					v__table__TypeSymbol* elem_typ = v__table__Table_get_type_symbol(g->table, info.elem_type);
					if (elem_typ->kind == v__table__Kind_function) {
						v__table__Type left_typ = (*(v__table__Type*)/*ee elem_typ */array_get(assign_stmt.left_types, i));
						v__table__TypeSymbol* left_sym = v__table__Table_get_type_symbol(g->table, left_typ);
						v__gen__Gen_write_fn_ptr_decl(g, (voidptr)&/*qq*//* as */ *(v__table__FnType*)__as_cast((left_sym->info)._353, (left_sym->info).typ, /*expected:*/353), _STR("_var_%"PRId32"", 1, (*left._227).pos.pos));
						v__gen__Gen_write(g, tos_lit(" = *(voidptr*)array_get("));
					} else {
						string styp = v__gen__Gen_typ(g, info.elem_type);
						v__gen__Gen_write(g, _STR("%.*s\000 _var_%"PRId32"\000 = *(%.*s\000*)array_get(", 4, styp, (*left._227).pos.pos, styp));
					}
					if (v__table__Type_is_ptr((*left._227).left_type)) {
						v__gen__Gen_write(g, tos_lit("*"));
					}
					bool needs_clone = info.elem_type == _const_v__table__string_type && g->pref->autofree;
					if (needs_clone) {
						v__gen__Gen_write(g, tos_lit("/*1*/string_clone("));
					}
					v__gen__Gen_expr(g, (*left._227).left);
					if (needs_clone) {
						v__gen__Gen_write(g, tos_lit(")"));
					}
					v__gen__Gen_write(g, tos_lit(", "));
					v__gen__Gen_expr(g, (*left._227).index);
					v__gen__Gen_writeln(g, tos_lit(");"));
				} else if (sym->kind == v__table__Kind_map) {
					v__table__Map info = /* as */ *(v__table__Map*)__as_cast((sym->info)._349, (sym->info).typ, /*expected:*/349);
					string styp = v__gen__Gen_typ(g, info.value_type);
					string zero = v__gen__Gen_type_default(g, info.value_type);
					v__table__TypeSymbol* val_typ = v__table__Table_get_type_symbol(g->table, info.value_type);
					if (val_typ->kind == v__table__Kind_function) {
						v__table__Type left_type = (*(v__table__Type*)/*ee elem_typ */array_get(assign_stmt.left_types, i));
						v__table__TypeSymbol* left_sym = v__table__Table_get_type_symbol(g->table, left_type);
						v__gen__Gen_write_fn_ptr_decl(g, (voidptr)&/*qq*//* as */ *(v__table__FnType*)__as_cast((left_sym->info)._353, (left_sym->info).typ, /*expected:*/353), _STR("_var_%"PRId32"", 1, (*left._227).pos.pos));
						v__gen__Gen_write(g, tos_lit(" = *(voidptr*)map_get("));
					} else {
						v__gen__Gen_write(g, _STR("%.*s\000 _var_%"PRId32"\000 = *(%.*s\000*)map_get(", 4, styp, (*left._227).pos.pos, styp));
					}
					if (v__table__Type_is_ptr((*left._227).left_type)) {
						v__gen__Gen_write(g, tos_lit("*"));
					}
					v__gen__Gen_expr(g, (*left._227).left);
					v__gen__Gen_write(g, tos_lit(", "));
					v__gen__Gen_expr(g, (*left._227).index);
					if (val_typ->kind == v__table__Kind_function) {
						v__gen__Gen_writeln(g, _STR(", &(voidptr[]){ %.*s\000 });", 2, zero));
					} else {
						v__gen__Gen_writeln(g, _STR(", &(%.*s\000[]){ %.*s\000 });", 3, styp, zero));
					}
				}
			} else if (_t1355.typ == 241 /* v.ast.SelectorExpr */) {
				string styp = v__gen__Gen_typ(g, (*left._241).typ);
				v__gen__Gen_write(g, _STR("%.*s\000 _var_%"PRId32"\000 = ", 3, styp, (*left._241).pos.pos));
				v__gen__Gen_expr(g, (*left._241).expr);
				if (v__table__Type_is_ptr((*left._241).expr_type)) {
					v__gen__Gen_write(g, tos_lit("/* left.expr_type */"));
					v__gen__Gen_writeln(g, _STR("->%.*s\000;", 2, (*left._241).field_name));
				} else {
					v__gen__Gen_writeln(g, _STR(".%.*s\000;", 2, (*left._241).field_name));
				}
			} else {
			};
		}
	}
	// FOR IN array
	array _t1356 = assign_stmt.left;
	for (int i = 0; i < _t1356.len; ++i) {
		v__ast__Expr left = ((v__ast__Expr*)_t1356.data)[i];
		v__table__Type var_type = (*(v__table__Type*)/*ee elem_typ */array_get(assign_stmt.left_types, i));
		v__table__Type val_type = (*(v__table__Type*)/*ee elem_typ */array_get(assign_stmt.right_types, i));
		v__ast__Expr val = (*(v__ast__Expr*)/*ee elem_typ */array_get(assign_stmt.right, i));
		bool is_call = false;
		bool blank_assign = false;
		v__ast__Ident ident = (v__ast__Ident){.language = 0,.tok_kind = 0,.pos = {0},.mut_pos = {0},.obj = {0},.mod = (string){.str=(byteptr)""},.name = (string){.str=(byteptr)""},.kind = 0,.info = {0},.is_mut = 0,};
		if ((left).typ == 224 /* v.ast.Ident */) {
			ident = (*left._224);
			blank_assign = (*left._224).kind == v__ast__IdentKind_blank_ident;
			if (((*left._224).info).typ == 313 /* v.ast.IdentVar */) {
				v__table__ShareType share = (/* as */ *(v__ast__IdentVar*)__as_cast(((*left._224).info)._313, ((*left._224).info).typ, /*expected:*/313)).share;
				if (share == v__table__ShareType_shared_t) {
					var_type = v__table__Type_set_flag(var_type, v__table__TypeFlag_shared_f);
				}
				if (share == v__table__ShareType_atomic_t) {
					var_type = v__table__Type_set_flag(var_type, v__table__TypeFlag_atomic_f);
				}
			}
		}
		string styp = v__gen__Gen_typ(g, var_type);
		bool is_fixed_array_init = false;
		bool has_val = false;
		v__ast__Expr _t1357 = val;
		if (_t1357.typ == 209 /* v.ast.ArrayInit */) {
			is_fixed_array_init = (*val._209).is_fixed;
			has_val = (*val._209).has_val;
		} else if (_t1357.typ == 215 /* v.ast.CallExpr */) {
			is_call = true;
			return_type = (*val._215).return_type;
		} else if (_t1357.typ == 208 /* v.ast.AnonFn */) {
			if (blank_assign) {
				v__gen__Gen_write(g, tos_lit("{"));
			}
			if ((is_decl || blank_assign) && (left).typ == 224 /* v.ast.Ident */) {
				string ret_styp = v__gen__Gen_typ(g, (*val._208).decl.return_type);
				v__gen__Gen_write(g, _STR("%.*s\000 (*%.*s\000) (", 3, ret_styp, ident.name));
				int def_pos = g->definitions.len;
				v__gen__Gen_fn_args(g, (*val._208).decl.params, (*val._208).decl.is_variadic);
				strings__Builder_go_back(&g->definitions, g->definitions.len - def_pos);
				v__gen__Gen_write(g, tos_lit(") = "));
			} else {
				v__gen__Gen_expr(g, left);
				v__gen__Gen_write(g, tos_lit(" = "));
			}
			v__gen__Gen_expr(g, val);
			v__gen__Gen_writeln(g, tos_lit(";"));
			if (blank_assign) {
				v__gen__Gen_write(g, tos_lit("}"));
			}
			continue;
		} else {
		};
		v__table__TypeSymbol* right_sym = v__table__Table_get_type_symbol(g->table, val_type);
		g->is_assign_lhs = true;
		if (v__table__Type_has_flag(val_type, v__table__TypeFlag_optional)) {
			g->right_is_opt = true;
		}
		if (blank_assign) {
			if (is_call) {
				v__gen__Gen_expr(g, val);
			} else {
				v__gen__Gen_write(g, _STR("{%.*s\000 _ = ", 2, styp));
				v__gen__Gen_expr(g, val);
				v__gen__Gen_writeln(g, tos_lit(";}"));
			}
		} else if (right_sym->kind == v__table__Kind_array_fixed && assign_stmt.op == v__token__Kind_assign) {
			v__ast__ArrayInit right = /* as */ *(v__ast__ArrayInit*)__as_cast((val)._209, (val).typ, /*expected:*/209);
			if (right.has_val) {
				// FOR IN array
				array _t1358 = right.exprs;
				for (int j = 0; j < _t1358.len; ++j) {
					v__ast__Expr expr = ((v__ast__Expr*)_t1358.data)[j];
					v__gen__Gen_expr(g, left);
					v__gen__Gen_write(g, _STR("[%"PRId32"\000] = ", 2, j));
					v__gen__Gen_expr(g, expr);
					v__gen__Gen_writeln(g, tos_lit(";"));
				}
			} else {
				v__table__ArrayFixed fixed_array = /* as */ *(v__table__ArrayFixed*)__as_cast((right_sym->info)._351, (right_sym->info).typ, /*expected:*/351);
				for (int j = 0; j < fixed_array.size; ++j) {
					v__gen__Gen_expr(g, left);
					v__gen__Gen_write(g, _STR("[%"PRId32"\000] = ", 2, j));
					if (right.has_default) {
						v__gen__Gen_expr(g, right.default_expr);
					} else {
						v__gen__Gen_write(g, v__gen__Gen_type_default(g, right.elem_type));
					}
					v__gen__Gen_writeln(g, tos_lit(";"));
				}
			}
		} else {
			g->assign_op = assign_stmt.op;
			bool is_inside_ternary = g->inside_ternary != 0;
			string cur_line = (is_inside_ternary && is_decl ? (v__gen__Gen_register_ternary_name(g, ident.name),g->empty_line = false,v__gen__Gen_go_before_ternary(g)) : (tos_lit("")));
			bool str_add = false;
			if (var_type == _const_v__table__string_type_idx && assign_stmt.op == v__token__Kind_plus_assign) {
				if ((left).typ == 227 /* v.ast.IndexExpr */) {
					v__gen__Gen_expr(g, left);
					v__gen__Gen_write(g, tos_lit("string_add("));
				} else {
					v__gen__Gen_expr(g, left);
					v__gen__Gen_write(g, tos_lit(" = /*f*/string_add("));
				}
				g->is_assign_lhs = false;
				g->is_assign_rhs = true;
				str_add = true;
			}
			if (right_sym->kind == v__table__Kind_function && is_decl) {
				if (is_inside_ternary && is_decl) {
					strings__Builder_write(&g->out, (*(string*)/*ee elem_typ */array_get(_const_v__gen__tabs, g->indent - g->inside_ternary)));
				}
				v__table__FnType func = /* as */ *(v__table__FnType*)__as_cast((right_sym->info)._353, (right_sym->info).typ, /*expected:*/353);
				string ret_styp = v__gen__Gen_typ(g, func.func.return_type);
				v__gen__Gen_write(g, _STR("%.*s\000 (*%.*s\000) (", 3, ret_styp, v__gen__Gen_get_ternary_name(g, ident.name)));
				int def_pos = g->definitions.len;
				v__gen__Gen_fn_args(g, func.func.params, func.func.is_variadic);
				strings__Builder_go_back(&g->definitions, g->definitions.len - def_pos);
				v__gen__Gen_write(g, tos_lit(")"));
			} else {
				if (is_decl) {
					if (is_inside_ternary) {
						strings__Builder_write(&g->out, (*(string*)/*ee elem_typ */array_get(_const_v__gen__tabs, g->indent - g->inside_ternary)));
					}
					v__gen__Gen_write(g, _STR("%.*s\000 ", 2, styp));
				}
				if ((left).typ == 224 /* v.ast.Ident */ || (left).typ == 241 /* v.ast.SelectorExpr */) {
					g->prevent_sum_type_unwrapping_once = true;
				}
				v__gen__Gen_expr(g, left);
			}
			if (is_inside_ternary && is_decl) {
				v__gen__Gen_write(g, _STR(";\n%.*s", 1, cur_line));
				strings__Builder_write(&g->out, (*(string*)/*ee elem_typ */array_get(_const_v__gen__tabs, g->indent)));
				v__gen__Gen_expr(g, left);
			}
			g->is_assign_lhs = false;
			g->is_assign_rhs = true;
			if (!g->is_array_set && !str_add) {
				v__gen__Gen_write(g, _STR(" %.*s\000 ", 2, v__token__Kind_str(op)));
			} else if (str_add) {
				v__gen__Gen_write(g, tos_lit(", "));
			}
			bool cloned = false;
			if (g->autofree && (right_sym->kind == v__table__Kind_array || right_sym->kind == v__table__Kind_string)) {
				if (v__gen__Gen_gen_clone_assignment(g, val, *right_sym, false)) {
					cloned = true;
				}
			}
			bool unwrap_optional = !v__table__Type_has_flag(var_type, v__table__TypeFlag_optional) && v__table__Type_has_flag(val_type, v__table__TypeFlag_optional);
			if (unwrap_optional) {
				v__gen__Gen_write(g, _STR("*(%.*s\000*)", 2, styp));
				if (g->pref->autofree) {
					v__gen__Gen_write(g, string_add(tmp_opt, tos_lit(".data/*FFz*/")));
					g->right_is_opt = false;
					g->is_assign_rhs = false;
					if (g->inside_ternary == 0 && !assign_stmt.is_simple) {
						v__gen__Gen_writeln(g, tos_lit(";"));
					}
					// Defer begin
					if (af) {
						v__gen__Gen_writeln(g, _STR("%.*s\000_free(&%.*s\000);", 3, type_to_free, sref_name));
					}
					// Defer end
					return;
				}
			}
			g->is_shared = v__table__Type_has_flag(var_type, v__table__TypeFlag_shared_f);
			if (!cloned) {
				if (is_decl) {
					if (is_fixed_array_init && !has_val) {
						if ((val).typ == 209 /* v.ast.ArrayInit */) {
							if ((*val._209).has_default) {
								v__gen__Gen_write(g, _STR("{%.*s", 1, v__ast__Expr_str((*val._209).default_expr)));
								v__table__ArrayFixed info = /* as */ *(v__table__ArrayFixed*)__as_cast((right_sym->info)._351, (right_sym->info).typ, /*expected:*/351);
								for (int _t1359 = 1; _t1359 < info.size; ++_t1359) {
									v__gen__Gen_write(g, _STR(", %.*s", 1, v__ast__Expr_str((*val._209).default_expr)));
								}
								v__gen__Gen_write(g, tos_lit("}"));
							} else {
								v__gen__Gen_write(g, tos_lit("{0}"));
							}
						} else {
							v__gen__Gen_write(g, tos_lit("{0}"));
						}
					} else {
						v__gen__Gen_expr(g, val);
					}
				} else {
					if (assign_stmt.has_cross_var) {
						v__gen__Gen_gen_cross_tmp_variable(g, assign_stmt.left, val);
					} else {
						v__gen__Gen_expr_with_cast(g, val, val_type, var_type);
					}
				}
			}
			if (unwrap_optional) {
				if (g->pref->autofree) {
				} else {
					v__gen__Gen_write(g, tos_lit(".data"));
				}
			}
			if (str_add) {
				v__gen__Gen_write(g, tos_lit(")"));
			}
			if (g->is_array_set) {
				v__gen__Gen_write(g, tos_lit(" })"));
				g->is_array_set = false;
			}
			g->is_shared = false;
		}
		g->right_is_opt = false;
		g->is_assign_rhs = false;
		if (g->inside_ternary == 0 && !assign_stmt.is_simple) {
			v__gen__Gen_writeln(g, tos_lit(";"));
		}
	}
// Defer begin
if (af) {
	v__gen__Gen_writeln(g, _STR("%.*s\000_free(&%.*s\000);", 3, type_to_free, sref_name));
}
// Defer end
}

VV_LOCAL_SYMBOL void v__gen__Gen_gen_cross_tmp_variable(v__gen__Gen* g, array_v__ast__Expr left, v__ast__Expr val) {
	v__ast__Expr val_ = val;
	v__ast__Expr _t1360 = val;
	if (_t1360.typ == 224 /* v.ast.Ident */) {
		bool has_var = false;
		// FOR IN array
		array _t1361 = left;
		for (int _t1362 = 0; _t1362 < _t1361.len; ++_t1362) {
			v__ast__Expr lx = ((v__ast__Expr*)_t1361.data)[_t1362];
			if ((lx).typ == 224 /* v.ast.Ident */) {
				if (string_eq((*val._224).name, (*lx._224).name)) {
					v__gen__Gen_write(g, tos_lit("_var_"));
					v__gen__Gen_write(g, int_str((*lx._224).pos.pos));
					has_var = true;
					break;
				}
			}
		}
		if (!has_var) {
			v__gen__Gen_expr(g, val_);
		}
	} else if (_t1360.typ == 227 /* v.ast.IndexExpr */) {
		bool has_var = false;
		// FOR IN array
		array _t1363 = left;
		for (int _t1364 = 0; _t1364 < _t1363.len; ++_t1364) {
			v__ast__Expr lx = ((v__ast__Expr*)_t1363.data)[_t1364];
			if (string_eq(v__ast__Expr_str(val_), v__ast__Expr_str(lx))) {
				v__gen__Gen_write(g, tos_lit("_var_"));
				v__gen__Gen_write(g, int_str(v__ast__Expr_position(lx).pos));
				has_var = true;
				break;
			}
		}
		if (!has_var) {
			v__gen__Gen_expr(g, val_);
		}
	} else if (_t1360.typ == 228 /* v.ast.InfixExpr */) {
		v__gen__Gen_gen_cross_tmp_variable(g, left, (*val._228).left);
		v__gen__Gen_write(g, v__token__Kind_str((*val._228).op));
		v__gen__Gen_gen_cross_tmp_variable(g, left, (*val._228).right);
	} else if (_t1360.typ == 238 /* v.ast.PrefixExpr */) {
		v__gen__Gen_write(g, v__token__Kind_str((*val._238).op));
		v__gen__Gen_gen_cross_tmp_variable(g, left, (*val._238).right);
	} else if (_t1360.typ == 237 /* v.ast.PostfixExpr */) {
		v__gen__Gen_gen_cross_tmp_variable(g, left, (*val._237).expr);
		v__gen__Gen_write(g, v__token__Kind_str((*val._237).op));
	} else if (_t1360.typ == 241 /* v.ast.SelectorExpr */) {
		bool has_var = false;
		// FOR IN array
		array _t1365 = left;
		for (int _t1366 = 0; _t1366 < _t1365.len; ++_t1366) {
			v__ast__Expr lx = ((v__ast__Expr*)_t1365.data)[_t1366];
			if (string_eq(v__ast__Expr_str(val_), v__ast__Expr_str(lx))) {
				v__gen__Gen_write(g, tos_lit("_var_"));
				v__gen__Gen_write(g, int_str(v__ast__Expr_position(lx).pos));
				has_var = true;
				break;
			}
		}
		if (!has_var) {
			v__gen__Gen_expr(g, val_);
		}
	} else {
		v__gen__Gen_expr(g, val_);
	};
}

VV_LOCAL_SYMBOL void v__gen__Gen_register_ternary_name(v__gen__Gen* g, string name) {
	string level_key = int_str(g->inside_ternary);
	if (!_IN_MAP(level_key, g->ternary_level_names)) {
		map_set(&g->ternary_level_names, level_key, &(array_string[]) { __new_array_with_default(0, 0, sizeof(string), 0) });
	}
	string new_name = v__gen__Gen_new_tmp_var(g);
	map_set(&g->ternary_names, name, &(string[]) { new_name });
	array_push(&(*(array_string*)map_get_and_set(&g->ternary_level_names, level_key, &(array_string[]){ __new_array(0, 1, sizeof(string)) })), _MOV((string[]){ string_clone(name) }));
}

VV_LOCAL_SYMBOL string v__gen__Gen_get_ternary_name(v__gen__Gen* g, string name) {
	if (g->inside_ternary == 0) {
		return name;
	}
	if (!_IN_MAP(name, g->ternary_names)) {
		return name;
	}
	return (*(string*)map_get(g->ternary_names, name, &(string[]){ (string){.str=(byteptr)""} }));
}

VV_LOCAL_SYMBOL bool v__gen__Gen_gen_clone_assignment(v__gen__Gen* g, v__ast__Expr val, v__table__TypeSymbol right_sym, bool add_eq) {
	if ((val).typ != 224 /* v.ast.Ident */ && (val).typ != 241 /* v.ast.SelectorExpr */) {
		return false;
	}
	if (g->autofree && right_sym.kind == v__table__Kind_array) {
		if (add_eq) {
			v__gen__Gen_write(g, tos_lit("="));
		}
		v__gen__Gen_write(g, tos_lit(" array_clone_static("));
		v__gen__Gen_expr(g, val);
		v__gen__Gen_write(g, tos_lit(")"));
	} else if (g->autofree && right_sym.kind == v__table__Kind_string) {
		if (add_eq) {
			v__gen__Gen_write(g, tos_lit("="));
		}
		v__gen__Gen_write(g, tos_lit(" string_clone_static("));
		v__gen__Gen_expr(g, val);
		v__gen__Gen_write(g, tos_lit(")"));
	}
	return true;
}

VV_LOCAL_SYMBOL void v__gen__Gen_autofree_scope_vars(v__gen__Gen* g, int pos, int line_nr, bool free_parent_scopes) {
	if (g->is_builtin_mod) {
		return;
	}
	if (pos == -1) {
		return;
	}
	v__ast__Scope* scope = v__ast__Scope_innermost(g->file.scope, pos);
	if (scope->start_pos == 0) {
		return;
	}
	v__gen__Gen_writeln(g, _STR("// autofree_scope_vars(pos=%"PRId32"\000 scope.pos=%"PRId32"\000 scope.end_pos=%"PRId32"\000)", 4, pos, scope->start_pos, scope->end_pos));
	v__gen__Gen_autofree_scope_vars2(g, scope, scope->start_pos, scope->end_pos, line_nr, free_parent_scopes);
}

VV_LOCAL_SYMBOL void v__gen__Gen_autofree_scope_vars2(v__gen__Gen* g, v__ast__Scope* scope, int start_pos, int end_pos, int line_nr, bool free_parent_scopes) {
	if (isnil(scope)) {
		return;
	}
	// FOR IN map
	map_string_v__ast__ScopeObject _t1369 = scope->objects;
	for (int _t1368 = 0; _t1368 < _t1369.key_values.len; ++_t1368) {
		if (_t1369.key_values.keys[_t1368].str == 0) {continue;}
		v__ast__ScopeObject obj = (*(v__ast__ScopeObject*)(void*)(_t1369.key_values.values + _t1368 * (u32)(_t1369.value_bytes)));
		v__ast__ScopeObject _t1370 = obj;
		if (_t1370.typ == 277 /* v.ast.Var */) {
			v__gen__Gen_writeln(g, _STR("// var %.*s\000 pos=%"PRId32"", 2, (*obj._277).name, (*obj._277).pos.pos));
			if ((*obj._277).pos.pos > end_pos || ((*obj._277).pos.pos < start_pos && (*obj._277).pos.line_nr == line_nr)) {
				continue;
			}
			bool is_optional = v__table__Type_has_flag((*obj._277).typ, v__table__TypeFlag_optional);
			if (is_optional) {
				continue;
			}
			v__gen__Gen_autofree_variable(g, (*obj._277));
		} else {
		};
	}
	if (free_parent_scopes && !isnil(scope->parent)) {
		v__gen__Gen_writeln(g, tos_lit("// af parent scope:"));
	}
}

VV_LOCAL_SYMBOL void v__gen__Gen_autofree_variable(v__gen__Gen* g, v__ast__Var v) {
	v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, v.typ);
	if (sym->kind == v__table__Kind_array) {
		v__gen__Gen_autofree_var_call(g, tos_lit("array_free"), v);
		return;
	}
	if (sym->kind == v__table__Kind_string) {
		v__ast__Expr _t1371 = v.expr;
		if (_t1371.typ == 245 /* v.ast.StringLiteral */) {
			v__gen__Gen_writeln(g, tos_lit("// str literal"));
		} else {
		};
		v__gen__Gen_autofree_var_call(g, tos_lit("string_free"), v);
		return;
	}
	if (v__table__TypeSymbol_has_method(sym, tos_lit("free"))) {
		v__gen__Gen_autofree_var_call(g, string_add(v__gen__c_name(sym->name), tos_lit("_free")), v);
	}
}

VV_LOCAL_SYMBOL void v__gen__Gen_autofree_var_call(v__gen__Gen* g, string free_fn_name, v__ast__Var v) {
	if (v.is_arg) {
		return;
	}
	if (v.is_used && v.is_autofree_tmp) {
		return;
	}
	if (string_contains(v.name, tos_lit("expr_write_1_"))) {
		return;
	}
	if (v__table__Type_is_ptr(v.typ)) {
		v__gen__Gen_writeln(g, _STR("\t%.*s\000(%.*s\000); // autofreed ptr var", 3, free_fn_name, v__gen__c_name(v.name)));
	} else {
		v__gen__Gen_writeln(g, _STR("\t%.*s\000(&%.*s\000); // autofreed var", 3, free_fn_name, v__gen__c_name(v.name)));
	}
}

VV_LOCAL_SYMBOL void v__gen__Gen_gen_anon_fn_decl(v__gen__Gen* g, v__ast__AnonFn it) {
	int pos = g->out.len;
	int def_pos = g->definitions.len;
	v__gen__Gen_stmt(g, /* sum type cast 4 */ (v__ast__Stmt){._151 = memdup(&(v__ast__FnDecl[]){it.decl}, sizeof(v__ast__FnDecl)), .typ = 151 /* v.ast.FnDecl */});
	string fn_body = strings__Builder_after(&g->out, pos);
	strings__Builder_go_back(&g->out, fn_body.len);
	strings__Builder_go_back(&g->definitions, g->definitions.len - def_pos);
	strings__Builder_write(&g->definitions, fn_body);
}

VV_LOCAL_SYMBOL void v__gen__Gen_expr(v__gen__Gen* g, v__ast__Expr node) {
	v__ast__Expr _t1372 = node;
	if (_t1372.typ == 208 /* v.ast.AnonFn */) {
		v__gen__Gen_gen_anon_fn_decl(g, (*node._208));
		v__table__TypeSymbol* fsym = v__table__Table_get_type_symbol(g->table, (*node._208).typ);
		v__gen__Gen_write(g, fsym->name);
	} else if (_t1372.typ == 209 /* v.ast.ArrayInit */) {
		v__gen__Gen_array_init(g, (*node._209));
	} else if (_t1372.typ == 210 /* v.ast.AsCast */) {
		v__gen__Gen_as_cast(g, (*node._210));
	} else if (_t1372.typ == 211 /* v.ast.Assoc */) {
		v__gen__Gen_assoc(g, (*node._211));
	} else if (_t1372.typ == 213 /* v.ast.BoolLiteral */) {
		v__gen__Gen_write(g, bool_str((*node._213).val));
	} else if (_t1372.typ == 215 /* v.ast.CallExpr */) {
		v__gen__Gen_call_expr(g, (*node._215));
		if (g->pref->autofree && !g->is_builtin_mod && !g->is_js_call && g->strs_to_free0.len == 0 && !g->inside_lambda) {
			v__gen__Gen_autofree_call_pregen(g, (*node._215));
			if (g->strs_to_free0.len > 0) {
				v__gen__Gen_insert_before_stmt(g, string_add(array_string_join(g->strs_to_free0, tos_lit("\n")), tos_lit("/* inserted before */")));
			}
			g->strs_to_free0 = __new_array_with_default(0, 0, sizeof(string), 0);
		}
	} else if (_t1372.typ == 216 /* v.ast.CastExpr */) {
		if (g->is_amp) {
			strings__Builder_go_back(&g->out, 1);
		}
		g->is_amp = false;
		v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, (*node._216).typ);
		if (sym->kind == v__table__Kind_string && !v__table__Type_is_ptr((*node._216).typ)) {
			if ((*node._216).has_arg) {
				v__gen__Gen_write(g, tos_lit("tos((byteptr)"));
			} else {
				v__gen__Gen_write(g, tos_lit("tos2((byteptr)"));
			}
			v__gen__Gen_expr(g, (*node._216).expr);
			v__table__TypeSymbol* expr_sym = v__table__Table_get_type_symbol(g->table, (*node._216).expr_type);
			if (expr_sym->kind == v__table__Kind_array) {
				v__gen__Gen_write(g, tos_lit(".data"));
			}
			if ((*node._216).has_arg) {
				v__gen__Gen_write(g, tos_lit(", "));
				v__gen__Gen_expr(g, (*node._216).arg);
			}
			v__gen__Gen_write(g, tos_lit(")"));
		} else if (sym->kind == v__table__Kind_sum_type) {
			v__gen__Gen_expr_with_cast(g, (*node._216).expr, (*node._216).expr_type, (*node._216).typ);
		} else if (sym->kind == v__table__Kind_struct_ && !v__table__Type_is_ptr((*node._216).typ) && !(/* as */ *(v__table__Struct*)__as_cast((sym->info)._155, (sym->info).typ, /*expected:*/155)).is_typedef) {
			string styp = v__gen__Gen_typ(g, (*node._216).typ);
			v__gen__Gen_write(g, _STR("*((%.*s\000 *)(&", 2, styp));
			v__gen__Gen_expr(g, (*node._216).expr);
			v__gen__Gen_write(g, tos_lit("))"));
		} else {
			string styp = v__gen__Gen_typ(g, (*node._216).typ);
			string cast_label = tos_lit("");
			if (sym->kind != v__table__Kind_alias || (/* as */ *(v__table__Alias*)__as_cast((sym->info)._347, (sym->info).typ, /*expected:*/347)).parent_type != (*node._216).expr_type) {
				cast_label = _STR("(%.*s\000)", 2, styp);
			}
			v__gen__Gen_write(g, _STR("(%.*s\000(", 2, cast_label));
			v__gen__Gen_expr(g, (*node._216).expr);
			if (((*node._216).expr).typ == 229 /* v.ast.IntegerLiteral */ && ((*node._216).typ == _const_v__table__u64_type || (*node._216).typ == _const_v__table__u32_type || (*node._216).typ == _const_v__table__u16_type)) {
				v__gen__Gen_write(g, tos_lit("U"));
			}
			v__gen__Gen_write(g, tos_lit("))"));
		}
	} else if (_t1372.typ == 217 /* v.ast.ChanInit */) {
		string elem_typ_str = v__gen__Gen_typ(g, (*node._217).elem_type);
		v__gen__Gen_write(g, tos_lit("sync__new_channel_st("));
		if ((*node._217).has_cap) {
			v__gen__Gen_expr(g, (*node._217).cap_expr);
		} else {
			v__gen__Gen_write(g, tos_lit("0"));
		}
		v__gen__Gen_write(g, tos_lit(", sizeof("));
		v__gen__Gen_write(g, elem_typ_str);
		v__gen__Gen_write(g, tos_lit("))"));
	} else if (_t1372.typ == 218 /* v.ast.CharLiteral */) {
		if (string_eq((*node._218).val, tos_lit("\\`"))) {
			v__gen__Gen_write(g, tos_lit("'`'"));
		} else {
			v__gen__Gen_write(g, _STR("'%.*s\000'", 2, (*node._218).val));
		}
	} else if (_t1372.typ == 212 /* v.ast.AtExpr */) {
		v__gen__Gen_comp_at(g, (*node._212));
	} else if (_t1372.typ == 220 /* v.ast.ComptimeCall */) {
		v__gen__Gen_comptime_call(g, (*node._220));
	} else if (_t1372.typ == 219 /* v.ast.Comment */) {
	} else if (_t1372.typ == 221 /* v.ast.ConcatExpr */) {
		v__gen__Gen_concat_expr(g, (*node._221));
	} else if (_t1372.typ == 214 /* v.ast.CTempVar */) {
		v__gen__Gen_write(g, (*node._214).name);
	} else if (_t1372.typ == 222 /* v.ast.EnumVal */) {
		string styp = v__gen__Gen_typ(g, (*node._222).typ);
		v__gen__Gen_write(g, _STR("%.*s\000_%.*s", 2, styp, (*node._222).val));
	} else if (_t1372.typ == 223 /* v.ast.FloatLiteral */) {
		v__gen__Gen_write(g, (*node._223).val);
	} else if (_t1372.typ == 224 /* v.ast.Ident */) {
		v__gen__Gen_ident(g, (*node._224));
	} else if (_t1372.typ == 225 /* v.ast.IfExpr */) {
		v__gen__Gen_if_expr(g, (*node._225));
	} else if (_t1372.typ == 226 /* v.ast.IfGuardExpr */) {
		v__gen__Gen_write(g, tos_lit("/* guard */"));
	} else if (_t1372.typ == 227 /* v.ast.IndexExpr */) {
		v__gen__Gen_index_expr(g, (*node._227));
	} else if (_t1372.typ == 228 /* v.ast.InfixExpr */) {
		if (((*node._228).op == v__token__Kind_left_shift || (*node._228).op == v__token__Kind_plus_assign || (*node._228).op == v__token__Kind_minus_assign)) {
			g->inside_map_infix = true;
			v__gen__Gen_infix_expr(g, (*node._228));
			g->inside_map_infix = false;
		} else {
			v__gen__Gen_infix_expr(g, (*node._228));
		}
	} else if (_t1372.typ == 229 /* v.ast.IntegerLiteral */) {
		if (string_starts_with((*node._229).val, tos_lit("0o"))) {
			v__gen__Gen_write(g, tos_lit("0"));
			v__gen__Gen_write(g, string_substr((*node._229).val, 2, (*node._229).val.len));
		} else {
			v__gen__Gen_write(g, (*node._229).val);
		}
	} else if (_t1372.typ == 231 /* v.ast.LockExpr */) {
		v__gen__Gen_lock_expr(g, (*node._231));
	} else if (_t1372.typ == 233 /* v.ast.MatchExpr */) {
		v__gen__Gen_match_expr(g, (*node._233));
	} else if (_t1372.typ == 232 /* v.ast.MapInit */) {
		string key_typ_str = v__gen__Gen_typ(g, (*node._232).key_type);
		string value_typ_str = v__gen__Gen_typ(g, (*node._232).value_type);
		v__table__TypeSymbol* value_typ = v__table__Table_get_type_symbol(g->table, (*node._232).value_type);
		int size = (*node._232).vals.len;
		if (size > 0) {
			if (value_typ->kind == v__table__Kind_function) {
				v__gen__Gen_write(g, _STR("new_map_init(%"PRId32"\000, sizeof(voidptr), _MOV((%.*s\000[%"PRId32"\000]){", 4, size, key_typ_str, size));
			} else {
				v__gen__Gen_write(g, _STR("new_map_init(%"PRId32"\000, sizeof(%.*s\000), _MOV((%.*s\000[%"PRId32"\000]){", 5, size, value_typ_str, key_typ_str, size));
			}
			// FOR IN array
			array _t1373 = (*node._232).keys;
			for (int _t1374 = 0; _t1374 < _t1373.len; ++_t1374) {
				v__ast__Expr expr = ((v__ast__Expr*)_t1373.data)[_t1374];
				v__gen__Gen_expr(g, expr);
				v__gen__Gen_write(g, tos_lit(", "));
			}
			if (value_typ->kind == v__table__Kind_function) {
				v__gen__Gen_write(g, _STR("}), _MOV((voidptr[%"PRId32"\000]){", 2, size));
			} else {
				v__gen__Gen_write(g, _STR("}), _MOV((%.*s\000[%"PRId32"\000]){", 3, value_typ_str, size));
			}
			// FOR IN array
			array _t1375 = (*node._232).vals;
			for (int _t1376 = 0; _t1376 < _t1375.len; ++_t1376) {
				v__ast__Expr expr = ((v__ast__Expr*)_t1375.data)[_t1376];
				v__gen__Gen_expr(g, expr);
				v__gen__Gen_write(g, tos_lit(", "));
			}
			v__gen__Gen_write(g, tos_lit("}))"));
		} else {
			v__gen__Gen_write(g, _STR("new_map_1(sizeof(%.*s\000))", 2, value_typ_str));
		}
	} else if (_t1372.typ == 234 /* v.ast.None */) {
		v__gen__Gen_write(g, tos_lit("opt_none()"));
	} else if (_t1372.typ == 235 /* v.ast.OrExpr */) {
	} else if (_t1372.typ == 236 /* v.ast.ParExpr */) {
		v__gen__Gen_write(g, tos_lit("("));
		v__gen__Gen_expr(g, (*node._236).expr);
		v__gen__Gen_write(g, tos_lit(")"));
	} else if (_t1372.typ == 237 /* v.ast.PostfixExpr */) {
		if (((*node._237).auto_locked).len != 0) {
			v__gen__Gen_writeln(g, _STR("sync__RwMutex_w_lock(%.*s\000->mtx);", 2, (*node._237).auto_locked));
		}
		g->inside_map_postfix = true;
		v__gen__Gen_expr(g, (*node._237).expr);
		g->inside_map_postfix = false;
		v__gen__Gen_write(g, v__token__Kind_str((*node._237).op));
		if (((*node._237).auto_locked).len != 0) {
			v__gen__Gen_writeln(g, tos_lit(";"));
			v__gen__Gen_write(g, _STR("sync__RwMutex_w_unlock(%.*s\000->mtx)", 2, (*node._237).auto_locked));
		}
	} else if (_t1372.typ == 238 /* v.ast.PrefixExpr */) {
		bool gen_or = (*node._238).op == v__token__Kind_arrow && (*node._238).or_block.kind != v__ast__OrKind_absent;
		if ((*node._238).op == v__token__Kind_amp) {
			g->is_amp = true;
		}
		if ((*node._238).op == v__token__Kind_arrow) {
			string styp = v__gen__Gen_typ(g, (*node._238).right_type);
			v__table__TypeSymbol* right_sym = v__table__Table_get_type_symbol(g->table, (*node._238).right_type);
			v__table__Chan right_inf = /* as */ *(v__table__Chan*)__as_cast((right_sym->info)._348, (right_sym->info).typ, /*expected:*/348);
			v__table__Type elem_type = right_inf.elem_type;
			bool is_gen_or_and_assign_rhs = gen_or && g->is_assign_rhs;
			string _t1377;
			string cur_line = (is_gen_or_and_assign_rhs ? (				_t1377 = v__gen__Gen_go_before_stmt(g, 0),strings__Builder_write(&g->out, (*(string*)/*ee elem_typ */array_get(_const_v__gen__tabs, g->indent))),_t1377) : (tos_lit("")));
			string tmp_opt = (gen_or ? (v__gen__Gen_new_tmp_var(g)) : (tos_lit("")));
			if (gen_or) {
				string opt_elem_type = v__gen__Gen_typ(g, v__table__Type_set_flag(elem_type, v__table__TypeFlag_optional));
				v__gen__Gen_register_chan_pop_optional_call(g, opt_elem_type, styp);
				v__gen__Gen_write(g, _STR("%.*s\000 %.*s\000 = __Option_%.*s\000_popval(", 4, opt_elem_type, tmp_opt, styp));
			} else {
				v__gen__Gen_write(g, _STR("__%.*s\000_popval(", 2, styp));
			}
			v__gen__Gen_expr(g, (*node._238).right);
			v__gen__Gen_write(g, tos_lit(")"));
			if (gen_or) {
				v__gen__Gen_or_block(g, tmp_opt, (*node._238).or_block, elem_type);
				if (is_gen_or_and_assign_rhs) {
					string elem_styp = v__gen__Gen_typ(g, elem_type);
					v__gen__Gen_write(g, _STR("\n%.*s\000*(%.*s\000*)%.*s\000.data", 4, cur_line, elem_styp, tmp_opt));
				}
			}
		} else {
			v__gen__Gen_write(g, v__token__Kind_str((*node._238).op));
			v__gen__Gen_expr(g, (*node._238).right);
		}
		g->is_amp = false;
	} else if (_t1372.typ == 239 /* v.ast.RangeExpr */) {
	} else if (_t1372.typ == 240 /* v.ast.SelectExpr */) {
		v__gen__Gen_select_expr(g, (*node._240));
	} else if (_t1372.typ == 242 /* v.ast.SizeOf */) {
		if ((*node._242).is_type) {
			v__table__Type node_typ = v__gen__Gen_unwrap_generic(g, (*node._242).typ);
			string styp = (*node._242).type_name;
			if (string_starts_with(styp, tos_lit("C."))) {
				styp = string_substr(styp, 2, styp.len);
			}
			if (((*node._242).type_name).len == 0 || v__table__Type_has_flag((*node._242).typ, v__table__TypeFlag_generic)) {
				styp = v__gen__Gen_typ(g, node_typ);
			} else {
				v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, node_typ);
				if (sym->kind == v__table__Kind_struct_) {
					v__table__Struct info = /* as */ *(v__table__Struct*)__as_cast((sym->info)._155, (sym->info).typ, /*expected:*/155);
					if (!info.is_typedef) {
						styp = string_add(tos_lit("struct "), styp);
					}
				}
			}
			v__gen__Gen_write(g, _STR("/*SizeOfType*/ sizeof(%.*s\000)", 2, v__util__no_dots(styp)));
		} else {
			v__gen__Gen_write(g, tos_lit("/*SizeOfVar*/ sizeof("));
			v__gen__Gen_expr(g, (*node._242).expr);
			v__gen__Gen_write(g, tos_lit(")"));
		}
	} else if (_t1372.typ == 243 /* v.ast.SqlExpr */) {
		v__gen__Gen_sql_select_expr(g, (*node._243));
	} else if (_t1372.typ == 245 /* v.ast.StringLiteral */) {
		v__gen__Gen_string_literal(g, (*node._245));
	} else if (_t1372.typ == 244 /* v.ast.StringInterLiteral */) {
		v__gen__Gen_string_inter_literal(g, (*node._244));
	} else if (_t1372.typ == 246 /* v.ast.StructInit */) {
		v__gen__Gen_struct_init(g, (*node._246));
	} else if (_t1372.typ == 241 /* v.ast.SelectorExpr */) {
		bool prevent_sum_type_unwrapping_once = g->prevent_sum_type_unwrapping_once;
		g->prevent_sum_type_unwrapping_once = false;
		if ((*node._241).name_type > 0) {
			v__gen__Gen_type_name(g, (*node._241).name_type);
			return;
		}
		if ((*node._241).expr_type == 0) {
			v__gen__Gen_checker_bug(g, tos_lit("unexpected SelectorExpr.expr_type = 0"), (*node._241).pos);
		}
		v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, (*node._241).expr_type);
		if (sym->kind == v__table__Kind_array_fixed) {
			// assert
			if (string_eq((*node._241).field_name, tos_lit("len"))) {} else {
				VAssertMetaInfo v_assert_meta_info__t1378;
				memset(&v_assert_meta_info__t1378, 0, sizeof(VAssertMetaInfo));
				v_assert_meta_info__t1378.fpath = tos_lit("/tmp/gen_vc/v/vlib/v/gen/cgen.v");
				v_assert_meta_info__t1378.line_nr = 2483;
				v_assert_meta_info__t1378.fn_name = tos_lit("expr");
				v_assert_meta_info__t1378.src = tos_lit("node.field_name == 'len'");
				v_assert_meta_info__t1378.op = tos_lit("==");
				v_assert_meta_info__t1378.llabel = tos_lit("node.field_name");
				v_assert_meta_info__t1378.rlabel = tos_lit("'len'");
				v_assert_meta_info__t1378.lvalue = (*node._241).field_name /* typeof: v.ast.SelectorExpr type: 18 */ ;
				v_assert_meta_info__t1378.rvalue = tos_lit("len") /* typeof: v.ast.StringLiteral type: 18 */ ;
				__print_assert_failure(&v_assert_meta_info__t1378);
				v_panic(tos_lit("Assertion failed..."));
				exit(1);
			}
			v__table__ArrayFixed info = /* as */ *(v__table__ArrayFixed*)__as_cast((sym->info)._351, (sym->info).typ, /*expected:*/351);
			v__gen__Gen_write(g, _STR("%"PRId32"", 1, info.size));
			return;
		}
		if (sym->kind == v__table__Kind_chan && string_eq((*node._241).field_name, tos_lit("len"))) {
			v__gen__Gen_write(g, tos_lit("sync__Channel_len("));
			v__gen__Gen_expr(g, (*node._241).expr);
			v__gen__Gen_write(g, tos_lit(")"));
			return;
		}
		string sum_type_deref_field = tos_lit("");
		{ /* if guard */ 
		Option_v__table__Field _t1379;
		if (_t1379 = v__table__Table_struct_find_field(g->table, sym, (*node._241).field_name), _t1379.ok) {
			v__table__Field field = *(v__table__Field*)_t1379.data;
			v__table__TypeSymbol* field_sym = v__table__Table_get_type_symbol(g->table, field.typ);
			if (field_sym->kind == v__table__Kind_sum_type) {
				if (!prevent_sum_type_unwrapping_once) {
					v__ast__Scope* scope = v__ast__Scope_innermost(g->file.scope, (*node._241).pos.pos);
					{ /* if guard */ 
					Option_v__ast__ScopeStructField _t1380;
					if (_t1380 = v__ast__Scope_find_struct_field(scope, (*node._241).expr_type, (*node._241).field_name), _t1380.ok) {
						v__ast__ScopeStructField field = *(v__ast__ScopeStructField*)_t1380.data;
						// FOR IN array
						array _t1381 = field.sum_type_casts;
						for (int i = 0; i < _t1381.len; ++i) {
							v__table__Type typ = ((v__table__Type*)_t1381.data)[i];
							v__gen__Gen_write(g, tos_lit("(*"));
							v__table__TypeSymbol* cast_sym = v__table__Table_get_type_symbol(g->table, typ);
							if (i != 0) {
								sum_type_deref_field = /*f*/string_add(sum_type_deref_field, tos_lit(")."));
							}
							if ((cast_sym->info).typ == 346 /* v.table.Aggregate */) {
								sum_type_deref_field = /*f*/string_add(sum_type_deref_field, _STR("_%"PRId32"", 1, (*(v__table__Type*)/*ee elem_typ */array_get((*cast_sym->info._346).types, g->aggregate_type_idx))));
							} else {
								sum_type_deref_field = /*f*/string_add(sum_type_deref_field, _STR("_%"PRId32"", 1, typ));
							}
						}
					}}
				}
			}
		}}
		v__gen__Gen_expr(g, (*node._241).expr);
		if (sym->kind == v__table__Kind_struct_) {
			v__table__Struct sym_info = /* as */ *(v__table__Struct*)__as_cast((sym->info)._155, (sym->info).typ, /*expected:*/155);

int _t1382_len = sym_info.fields.len;
			array_v__table__Field _t1382 = __new_array(0, _t1382_len, sizeof(v__table__Field));
			for (int i = 0; i < _t1382_len; ++i) {
			  v__table__Field it = ((v__table__Field*) sym_info.fields.data)[i];
			if (string_eq(it.name, (*node._241).field_name)) array_push(&_t1382, &it); 
 }
						array_v__table__Field x =  _t1382;
			if (x.len > 0) {
				v__table__Field field = (*(v__table__Field*)/*ee elem_typ */array_get(x, 0));
				if ((field.embed_alias_for).len != 0) {
					v__gen__Gen_write(g, _STR(".%.*s", 1, field.embed_alias_for));
				}
			}
		}
		if (v__table__Type_is_ptr((*node._241).expr_type) || sym->kind == v__table__Kind_chan) {
			v__gen__Gen_write(g, tos_lit("->"));
		} else {
			v__gen__Gen_write(g, tos_lit("."));
		}
		if (v__table__Type_has_flag((*node._241).expr_type, v__table__TypeFlag_shared_f)) {
			v__gen__Gen_write(g, tos_lit("val."));
		}
		if ((*node._241).expr_type == 0) {
			v__gen__verror(_STR("cgen: SelectorExpr | expr_type: 0 | it.expr: `%.*s\000` | field: `%.*s\000` | file: %.*s\000 | line: %"PRId32"", 4, v__ast__Expr_str((*node._241).expr), (*node._241).field_name, g->file.path, (*node._241).pos.line_nr));
		}
		v__gen__Gen_write(g, v__gen__c_name((*node._241).field_name));
		if ((sum_type_deref_field).len != 0) {
			v__gen__Gen_write(g, _STR(".%.*s\000)", 2, sum_type_deref_field));
		}
	} else if (_t1372.typ == 247 /* v.ast.Type */) {
		int type_idx = v__table__Type_idx((*node._247).typ);
		v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, (*node._247).typ);
		v__gen__Gen_write(g, _STR("%"PRId32"\000 /* %.*s\000 */", 3, type_idx, sym->name));
	} else if (_t1372.typ == 248 /* v.ast.TypeOf */) {
		v__gen__Gen_typeof_expr(g, (*node._248));
	} else if (_t1372.typ == 230 /* v.ast.Likely */) {
		if ((*node._230).is_likely) {
			v__gen__Gen_write(g, tos_lit("_likely_"));
		} else {
			v__gen__Gen_write(g, tos_lit("_unlikely_"));
		}
		v__gen__Gen_write(g, tos_lit("("));
		v__gen__Gen_expr(g, (*node._230).expr);
		v__gen__Gen_write(g, tos_lit(")"));
	} else if (_t1372.typ == 249 /* v.ast.UnsafeExpr */) {
		v__gen__Gen_expr(g, (*node._249).expr);
	};
}

VV_LOCAL_SYMBOL void v__gen__Gen_type_name(v__gen__Gen* g, v__table__Type type_) {
	v__table__Type typ = type_;
	if (v__table__Type_has_flag(typ, v__table__TypeFlag_generic)) {
		typ = g->cur_generic_type;
	}
	string s = v__table__Table_type_to_str(g->table, typ);
	v__gen__Gen_write(g, _STR("tos_lit(\"%.*s\000\")", 2, v__util__strip_main_name(s)));
}

VV_LOCAL_SYMBOL void v__gen__Gen_typeof_expr(v__gen__Gen* g, v__ast__TypeOf node) {
	v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, node.expr_type);
	if (sym->kind == v__table__Kind_sum_type) {
		int sum_type_idx = v__table__Type_idx(node.expr_type);
		v__gen__Gen_write(g, _STR("tos3( /* %.*s\000 */ v_typeof_sumtype_%"PRId32"\000( (", 3, sym->name, sum_type_idx));
		v__gen__Gen_expr(g, node.expr);
		v__gen__Gen_write(g, tos_lit(").typ ))"));
	} else if (sym->kind == v__table__Kind_array_fixed) {
		v__table__ArrayFixed fixed_info = /* as */ *(v__table__ArrayFixed*)__as_cast((sym->info)._351, (sym->info).typ, /*expected:*/351);
		string typ_name = v__table__Table_get_type_name(g->table, fixed_info.elem_type);
		v__gen__Gen_write(g, _STR("tos_lit(\"[%"PRId32"\000]%.*s\000\")", 3, fixed_info.size, v__util__strip_main_name(typ_name)));
	} else if (sym->kind == v__table__Kind_function) {
		v__table__FnType info = /* as */ *(v__table__FnType*)__as_cast((sym->info)._353, (sym->info).typ, /*expected:*/353);
		v__table__Fn fn_info = info.func;
		string repr = tos_lit("fn (");
		// FOR IN array
		array _t1383 = fn_info.params;
		for (int i = 0; i < _t1383.len; ++i) {
			v__table__Param arg = ((v__table__Param*)_t1383.data)[i];
			if (i > 0) {
				repr = /*f*/string_add(repr, tos_lit(", "));
			}
			repr = /*f*/string_add(repr, v__util__strip_main_name(v__table__Table_get_type_name(g->table, arg.typ)));
		}
		repr = /*f*/string_add(repr, tos_lit(")"));
		if (fn_info.return_type != _const_v__table__void_type) {
			repr = /*f*/string_add(repr, _STR(" %.*s", 1, v__util__strip_main_name(v__table__Table_get_type_name(g->table, fn_info.return_type))));
		}
		v__gen__Gen_write(g, _STR("tos_lit(\"%.*s\000\")", 2, repr));
	} else {
		v__gen__Gen_write(g, _STR("tos_lit(\"%.*s\000\")", 2, v__util__strip_main_name(sym->name)));
	}
}

VV_LOCAL_SYMBOL void v__gen__Gen_enum_expr(v__gen__Gen* g, v__ast__Expr node) {
	v__ast__Expr _t1384 = node;
	if (_t1384.typ == 222 /* v.ast.EnumVal */) {
		v__gen__Gen_write(g, (*node._222).val);
	} else {
		v__gen__Gen_expr(g, node);
	};
}

VV_LOCAL_SYMBOL void v__gen__Gen_infix_expr(v__gen__Gen* g, v__ast__InfixExpr node) {
	if ((node.auto_locked).len != 0) {
		v__gen__Gen_writeln(g, _STR("sync__RwMutex_w_lock(%.*s\000->mtx);", 2, node.auto_locked));
	}
	v__table__Type left_type = v__gen__Gen_unwrap_generic(g, node.left_type);
	v__table__TypeSymbol* left_sym = v__table__Table_get_type_symbol(g->table, left_type);
	v__table__Type unaliased_left = (left_sym->kind == v__table__Kind_alias ? ((/* as */ *(v__table__Alias*)__as_cast((left_sym->info)._347, (left_sym->info).typ, /*expected:*/347)).parent_type) : (left_type));
	if ((node.op == v__token__Kind_key_is || node.op == v__token__Kind_not_is)) {
		v__gen__Gen_is_expr(g, node);
		return;
	}
	v__table__TypeSymbol* right_sym = v__table__Table_get_type_symbol(g->table, node.right_type);
	v__table__Type unaliased_right = (right_sym->kind == v__table__Kind_alias ? ((/* as */ *(v__table__Alias*)__as_cast((right_sym->info)._347, (right_sym->info).typ, /*expected:*/347)).parent_type) : (node.right_type));
	if (left_type == _const_v__table__ustring_type_idx && node.op != v__token__Kind_key_in && node.op != v__token__Kind_not_in) {
		v__token__Kind _t1385 = node.op;
				string fn_name = ((_t1385 == v__token__Kind_plus) ? (tos_lit("ustring_add(")) : (_t1385 == v__token__Kind_eq) ? (tos_lit("ustring_eq(")) : (_t1385 == v__token__Kind_ne) ? (tos_lit("ustring_ne(")) : (_t1385 == v__token__Kind_lt) ? (tos_lit("ustring_lt(")) : (_t1385 == v__token__Kind_le) ? (tos_lit("ustring_le(")) : (_t1385 == v__token__Kind_gt) ? (tos_lit("ustring_gt(")) : (_t1385 == v__token__Kind_ge) ? (tos_lit("ustring_ge(")) : (v__gen__verror(_STR("op error for type `%.*s\000`", 2, left_sym->name)),tos_lit("/*node error*/")));
		v__gen__Gen_write(g, fn_name);
		v__gen__Gen_expr(g, node.left);
		v__gen__Gen_write(g, tos_lit(", "));
		v__gen__Gen_expr(g, node.right);
		v__gen__Gen_write(g, tos_lit(")"));
	} else if (left_type == _const_v__table__string_type_idx && !(node.op == v__token__Kind_key_in || node.op == v__token__Kind_not_in)) {
		if ((node.op == v__token__Kind_eq || node.op == v__token__Kind_ne) && (node.right).typ == 245 /* v.ast.StringLiteral */ && ((/* as */ *(v__ast__StringLiteral*)__as_cast((node.right)._245, (node.right).typ, /*expected:*/245)).val).len == 0) {
			string arrow = (v__table__Type_is_ptr(left_type) ? (tos_lit("->")) : (tos_lit(".")));
			v__gen__Gen_write(g, tos_lit("("));
			v__gen__Gen_expr(g, node.left);
			v__gen__Gen_write(g, tos_lit(")"));
			v__gen__Gen_write(g, _STR("%.*s\000len %.*s\000 0", 3, arrow, v__token__Kind_str(node.op)));
		} else {
			v__token__Kind _t1386 = node.op;
						string fn_name = ((_t1386 == v__token__Kind_plus) ? (tos_lit("string_add(")) : (_t1386 == v__token__Kind_eq) ? (tos_lit("string_eq(")) : (_t1386 == v__token__Kind_ne) ? (tos_lit("string_ne(")) : (_t1386 == v__token__Kind_lt) ? (tos_lit("string_lt(")) : (_t1386 == v__token__Kind_le) ? (tos_lit("string_le(")) : (_t1386 == v__token__Kind_gt) ? (tos_lit("string_gt(")) : (_t1386 == v__token__Kind_ge) ? (tos_lit("string_ge(")) : (v__gen__verror(_STR("op error for type `%.*s\000`", 2, left_sym->name)),tos_lit("/*node error*/")));
			v__gen__Gen_write(g, fn_name);
			v__gen__Gen_expr(g, node.left);
			v__gen__Gen_write(g, tos_lit(", "));
			v__gen__Gen_expr(g, node.right);
			v__gen__Gen_write(g, tos_lit(")"));
		}
	} else if ((node.op == v__token__Kind_eq || node.op == v__token__Kind_ne) && left_sym->kind == v__table__Kind_array && right_sym->kind == v__table__Kind_array) {
		string ptr_typ = v__gen__Gen_gen_array_equality_fn(g, left_type);
		if (node.op == v__token__Kind_eq) {
			v__gen__Gen_write(g, _STR("%.*s\000_arr_eq(", 2, ptr_typ));
		} else if (node.op == v__token__Kind_ne) {
			v__gen__Gen_write(g, _STR("!%.*s\000_arr_eq(", 2, ptr_typ));
		}
		if (v__table__Type_is_ptr(node.left_type)) {
			v__gen__Gen_write(g, tos_lit("*"));
		}
		v__gen__Gen_expr(g, node.left);
		v__gen__Gen_write(g, tos_lit(", "));
		if (v__table__Type_is_ptr(node.right_type)) {
			v__gen__Gen_write(g, tos_lit("*"));
		}
		v__gen__Gen_expr(g, node.right);
		v__gen__Gen_write(g, tos_lit(")"));
	} else if ((node.op == v__token__Kind_eq || node.op == v__token__Kind_ne) && left_sym->kind == v__table__Kind_array_fixed && right_sym->kind == v__table__Kind_array_fixed) {
		v__table__ArrayFixed info = /* as */ *(v__table__ArrayFixed*)__as_cast((left_sym->info)._351, (left_sym->info).typ, /*expected:*/351);
		v__table__Type et = info.elem_type;
		if (!v__table__Type_is_ptr(et) && !v__table__Type_is_pointer(et) && !v__table__Type_is_number(et) && !(v__table__Type_idx(et) == _const_v__table__bool_type_idx || v__table__Type_idx(et) == _const_v__table__char_type_idx)) {
			v__gen__verror(tos_lit("`==` on fixed array only supported with POD element types ATM"));
		}
		v__gen__Gen_write(g, tos_lit("(memcmp("));
		v__gen__Gen_expr(g, node.left);
		v__gen__Gen_write(g, tos_lit(", "));
		if ((node.right).typ == 209 /* v.ast.ArrayInit */) {
			string s = v__gen__Gen_typ(g, left_type);
			v__gen__Gen_write(g, _STR("(%.*s\000)", 2, s));
		}
		v__gen__Gen_expr(g, node.right);
		v__gen__Gen_write(g, tos_lit(", sizeof("));
		v__gen__Gen_expr(g, node.left);
		if (node.op == v__token__Kind_eq) {
			v__gen__Gen_write(g, tos_lit(")) == 0"));
		} else if (node.op == v__token__Kind_ne) {
			v__gen__Gen_write(g, tos_lit(")) != 0"));
		}
		v__gen__Gen_write(g, tos_lit(")"));
	} else if ((node.op == v__token__Kind_eq || node.op == v__token__Kind_ne) && left_sym->kind == v__table__Kind_map && right_sym->kind == v__table__Kind_map) {
		string ptr_typ = v__gen__Gen_gen_map_equality_fn(g, left_type);
		if (node.op == v__token__Kind_eq) {
			v__gen__Gen_write(g, _STR("%.*s\000_map_eq(", 2, ptr_typ));
		} else if (node.op == v__token__Kind_ne) {
			v__gen__Gen_write(g, _STR("!%.*s\000_map_eq(", 2, ptr_typ));
		}
		if (v__table__Type_is_ptr(node.left_type)) {
			v__gen__Gen_write(g, tos_lit("*"));
		}
		v__gen__Gen_expr(g, node.left);
		v__gen__Gen_write(g, tos_lit(", "));
		if (v__table__Type_is_ptr(node.right_type)) {
			v__gen__Gen_write(g, tos_lit("*"));
		}
		v__gen__Gen_expr(g, node.right);
		v__gen__Gen_write(g, tos_lit(")"));
	} else if ((node.op == v__token__Kind_key_in || node.op == v__token__Kind_not_in)) {
		if (node.op == v__token__Kind_not_in) {
			v__gen__Gen_write(g, tos_lit("!"));
		}
		if (right_sym->kind == v__table__Kind_array) {
			if ((node.right).typ == 209 /* v.ast.ArrayInit */) {
				if ((*node.right._209).exprs.len > 0) {
					v__gen__Gen_write(g, tos_lit("("));
					v__gen__Gen_in_optimization(g, node.left, (*node.right._209));
					v__gen__Gen_write(g, tos_lit(")"));
					return;
				}
			}
			if (left_sym->kind == v__table__Kind_function) {
				v__gen__Gen_write(g, tos_lit("_IN(voidptr, "));
			} else {
				v__table__Type elem_type = v__table__TypeSymbol_array_info(right_sym).elem_type;
				string styp = v__gen__Gen_typ(g, v__table__Table_mktyp(g->table, elem_type));
				v__gen__Gen_write(g, _STR("_IN(%.*s\000, ", 2, styp));
			}
			v__gen__Gen_expr(g, node.left);
			v__gen__Gen_write(g, tos_lit(", "));
			if (v__table__Type_is_ptr(node.right_type)) {
				v__gen__Gen_write(g, tos_lit("*"));
			}
			v__gen__Gen_expr(g, node.right);
			v__gen__Gen_write(g, tos_lit(")"));
		} else if (right_sym->kind == v__table__Kind_map) {
			v__gen__Gen_write(g, tos_lit("_IN_MAP("));
			v__gen__Gen_expr(g, node.left);
			v__gen__Gen_write(g, tos_lit(", "));
			if (v__table__Type_is_ptr(node.right_type)) {
				v__gen__Gen_write(g, tos_lit("*"));
			}
			v__gen__Gen_expr(g, node.right);
			v__gen__Gen_write(g, tos_lit(")"));
		} else if (right_sym->kind == v__table__Kind_string) {
			v__gen__Gen_write(g, tos_lit("string_contains("));
			v__gen__Gen_expr(g, node.right);
			v__gen__Gen_write(g, tos_lit(", "));
			v__gen__Gen_expr(g, node.left);
			v__gen__Gen_write(g, tos_lit(")"));
		}
	} else if (node.op == v__token__Kind_left_shift && left_sym->kind == v__table__Kind_array) {
		string tmp = v__gen__Gen_new_tmp_var(g);
		v__table__Array info = /* as */ *(v__table__Array*)__as_cast((left_sym->info)._350, (left_sym->info).typ, /*expected:*/350);
		if (right_sym->kind == v__table__Kind_array && info.elem_type != node.right_type) {
			v__gen__Gen_write(g, tos_lit("_PUSH_MANY(&"));
			v__gen__Gen_expr(g, node.left);
			v__gen__Gen_write(g, tos_lit(", ("));
			v__gen__Gen_expr_with_cast(g, node.right, node.right_type, left_type);
			string styp = v__gen__Gen_typ(g, left_type);
			v__gen__Gen_write(g, _STR("), %.*s\000, %.*s\000)", 3, tmp, styp));
		} else {
			string elem_type_str = v__gen__Gen_typ(g, info.elem_type);
			v__table__TypeSymbol* elem_sym = v__table__Table_get_type_symbol(g->table, info.elem_type);
			v__gen__Gen_write(g, tos_lit("array_push("));
			if (!v__table__Type_is_ptr(left_type)) {
				v__gen__Gen_write(g, tos_lit("&"));
			}
			v__gen__Gen_expr(g, node.left);
			if (elem_sym->kind == v__table__Kind_function) {
				v__gen__Gen_write(g, tos_lit(", _MOV((voidptr[]){ "));
			} else {
				v__gen__Gen_write(g, _STR(", _MOV((%.*s\000[]){ ", 2, elem_type_str));
			}
			bool is_interface = elem_sym->kind == v__table__Kind_interface_ && node.right_type != info.elem_type;
			if (elem_sym->kind == v__table__Kind_interface_ && node.right_type != info.elem_type) {
				v__gen__Gen_interface_call(g, node.right_type, info.elem_type);
			}
			bool needs_clone = info.elem_type == _const_v__table__string_type && !g->is_builtin_mod;
			if (needs_clone) {
				v__gen__Gen_write(g, tos_lit("string_clone("));
			}
			v__gen__Gen_expr_with_cast(g, node.right, node.right_type, info.elem_type);
			if (needs_clone) {
				v__gen__Gen_write(g, tos_lit(")"));
			}
			if (is_interface) {
				v__gen__Gen_write(g, tos_lit(")"));
			}
			v__gen__Gen_write(g, tos_lit(" }))"));
		}
	} else if (node.op == v__token__Kind_arrow) {
		string styp = v__util__no_dots(left_sym->name);
		v__gen__Gen_write(g, _STR("__%.*s\000_pushval(", 2, styp));
		v__gen__Gen_expr(g, node.left);
		v__gen__Gen_write(g, tos_lit(", "));
		v__gen__Gen_expr(g, node.right);
		v__gen__Gen_write(g, tos_lit(")"));
	} else if ((v__table__Type_idx(unaliased_left) == _const_v__table__u32_type_idx || v__table__Type_idx(unaliased_left) == _const_v__table__u64_type_idx) && v__table__Type_is_signed(unaliased_right) && (node.op == v__token__Kind_eq || node.op == v__token__Kind_ne || node.op == v__token__Kind_gt || node.op == v__token__Kind_lt || node.op == v__token__Kind_ge || node.op == v__token__Kind_le)) {
		int bitsize = (v__table__Type_idx(unaliased_left) == _const_v__table__u32_type_idx && v__table__Type_idx(unaliased_right) != _const_v__table__i64_type_idx ? (32) : (64));
		v__gen__Gen_write(g, _STR("_us%"PRId32"\000_%.*s\000(", 3, bitsize, (*(string*)/*ee elem_typ */array_get(_const_v__gen__cmp_str, ((int)(node.op)) - ((int)(v__token__Kind_eq))))));
		v__gen__Gen_expr(g, node.left);
		v__gen__Gen_write(g, tos_lit(","));
		v__gen__Gen_expr(g, node.right);
		v__gen__Gen_write(g, tos_lit(")"));
	} else if ((v__table__Type_idx(unaliased_right) == _const_v__table__u32_type_idx || v__table__Type_idx(unaliased_right) == _const_v__table__u64_type_idx) && v__table__Type_is_signed(unaliased_left) && (node.op == v__token__Kind_eq || node.op == v__token__Kind_ne || node.op == v__token__Kind_gt || node.op == v__token__Kind_lt || node.op == v__token__Kind_ge || node.op == v__token__Kind_le)) {
		int bitsize = (v__table__Type_idx(unaliased_right) == _const_v__table__u32_type_idx && v__table__Type_idx(unaliased_left) != _const_v__table__i64_type_idx ? (32) : (64));
		v__gen__Gen_write(g, _STR("_us%"PRId32"\000_%.*s\000(", 3, bitsize, (*(string*)/*ee elem_typ */array_get(_const_v__gen__cmp_rev, ((int)(node.op)) - ((int)(v__token__Kind_eq))))));
		v__gen__Gen_expr(g, node.right);
		v__gen__Gen_write(g, tos_lit(","));
		v__gen__Gen_expr(g, node.left);
		v__gen__Gen_write(g, tos_lit(")"));
	} else {
		bool a = byte_is_capital(string_at(left_sym->name, 0)) || string_contains(left_sym->name, tos_lit("."));
		bool b = left_sym->kind != v__table__Kind_alias;
		bool c = left_sym->kind == v__table__Kind_alias && (/* as */ *(v__table__Alias*)__as_cast((left_sym->info)._347, (left_sym->info).typ, /*expected:*/347)).language == v__table__Language_c;
		bool d = !b && byte_is_capital(string_at(*(string*)array_last(string_split(v__gen__Gen_typ(g, (/* as */ *(v__table__Alias*)__as_cast((left_sym->info)._347, (left_sym->info).typ, /*expected:*/347)).parent_type), tos_lit("__"))), 0));
		if ((node.op == v__token__Kind_plus || node.op == v__token__Kind_minus || node.op == v__token__Kind_mul || node.op == v__token__Kind_div || node.op == v__token__Kind_mod) && ((a && b) || c || d)) {
			v__gen__Gen_write(g, v__gen__Gen_typ(g, (!d ? (left_type) : ((/* as */ *(v__table__Alias*)__as_cast((left_sym->info)._347, (left_sym->info).typ, /*expected:*/347)).parent_type))));
			v__gen__Gen_write(g, tos_lit("_"));
			v__gen__Gen_write(g, v__util__replace_op(v__token__Kind_str(node.op)));
			v__gen__Gen_write(g, tos_lit("("));
			v__gen__Gen_expr(g, node.left);
			v__gen__Gen_write(g, tos_lit(", "));
			v__gen__Gen_expr(g, node.right);
			v__gen__Gen_write(g, tos_lit(")"));
		} else {
			bool need_par = (node.op == v__token__Kind_amp || node.op == v__token__Kind_pipe || node.op == v__token__Kind_xor);
			if (need_par) {
				v__gen__Gen_write(g, tos_lit("("));
			}
			v__gen__Gen_expr(g, node.left);
			v__gen__Gen_write(g, _STR(" %.*s\000 ", 2, v__token__Kind_str(node.op)));
			v__gen__Gen_expr(g, node.right);
			if (need_par) {
				v__gen__Gen_write(g, tos_lit(")"));
			}
		}
	}
	if ((node.auto_locked).len != 0) {
		v__gen__Gen_writeln(g, tos_lit(";"));
		v__gen__Gen_write(g, _STR("sync__RwMutex_w_unlock(%.*s\000->mtx)", 2, node.auto_locked));
	}
}

VV_LOCAL_SYMBOL void v__gen__Gen_lock_expr(v__gen__Gen* g, v__ast__LockExpr node) {
	array_byte lock_prefixes = __new_array_with_default(0, node.lockeds.len, sizeof(byte), 0);
	// FOR IN array
	array _t1387 = node.lockeds;
	for (int _t1388 = 0; _t1388 < _t1387.len; ++_t1388) {
		v__ast__Ident id = ((v__ast__Ident*)_t1387.data)[_t1388];
		string name = id.name;
		string deref = (id.is_mut ? (tos_lit("->")) : (tos_lit(".")));
		rune lock_prefix = (node.is_rlock ? ('r') : ('w'));
		array_push(&lock_prefixes, _MOV((byte[]){ lock_prefix }));
		v__gen__Gen_writeln(g, _STR("sync__RwMutex_%c\000_lock(%.*s\000%.*s\000mtx);", 4, lock_prefix, name, deref));
	}
	v__gen__Gen_stmts(g, node.stmts);
	for (int i = node.lockeds.len - 1; i >= 0; i--) {
		v__ast__Ident id = (*(v__ast__Ident*)/*ee elem_typ */array_get(node.lockeds, i));
		byte lock_prefix = (*(byte*)/*ee elem_typ */array_get(lock_prefixes, i));
		string name = id.name;
		string deref = (id.is_mut ? (tos_lit("->")) : (tos_lit(".")));
		v__gen__Gen_writeln(g, _STR("sync__RwMutex_%c\000_unlock(%.*s\000%.*s\000mtx);", 4, lock_prefix, name, deref));
	}
}

VV_LOCAL_SYMBOL void v__gen__Gen_match_expr(v__gen__Gen* g, v__ast__MatchExpr node) {
	if (node.cond_type == 0) {
		v__gen__Gen_writeln(g, tos_lit("// match 0"));
		return;
	}
	bool is_expr = (node.is_expr && node.return_type != _const_v__table__void_type) || g->inside_ternary > 0;
	if (is_expr) {
		g->inside_ternary++;
	}
	string cur_line = (is_expr ? (g->empty_line = true,v__gen__Gen_go_before_stmt(g, 0)) : (tos_lit("")));
	string cond_var = v__gen__Gen_new_tmp_var(g);
	v__gen__Gen_write(g, _STR("%.*s\000 %.*s\000 = ", 3, v__gen__Gen_typ(g, node.cond_type), cond_var));
	v__gen__Gen_expr(g, node.cond);
	v__gen__Gen_writeln(g, tos_lit(";"));
	v__gen__Gen_write(g, cur_line);
	if (is_expr) {
		v__gen__Gen_write(g, tos_lit("("));
	}
	if (node.is_sum_type) {
		v__gen__Gen_match_expr_sumtype(g, node, is_expr, cond_var);
	} else {
		v__gen__Gen_match_expr_classic(g, node, is_expr, cond_var);
	}
	if (is_expr) {
		v__gen__Gen_write(g, tos_lit(")"));
		v__gen__Gen_decrement_inside_ternary(g);
	}
}

VV_LOCAL_SYMBOL void v__gen__Gen_match_expr_sumtype(v__gen__Gen* g, v__ast__MatchExpr node, bool is_expr, string cond_var) {
	// FOR IN array
	array _t1390 = node.branches;
	for (int j = 0; j < _t1390.len; ++j) {
		v__ast__MatchBranch branch = ((v__ast__MatchBranch*)_t1390.data)[j];
		int sumtype_index = 0;
		for (;;) {
			g->aggregate_type_idx = sumtype_index;
			bool is_last = j == node.branches.len - 1;
			v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, node.cond_type);
			if (branch.is_else || (node.is_expr && is_last)) {
				if (is_expr) {
					v__gen__Gen_write(g, tos_lit(" : "));
				} else {
					v__gen__Gen_writeln(g, tos_lit(" else {"));
				}
			} else {
				if (j > 0 || sumtype_index > 0) {
					if (is_expr) {
						v__gen__Gen_write(g, tos_lit(" : "));
					} else {
						v__gen__Gen_write(g, tos_lit(" else "));
					}
				}
				if (is_expr) {
					v__gen__Gen_write(g, tos_lit("("));
				} else {
					v__gen__Gen_write(g, tos_lit("if ("));
				}
				v__gen__Gen_write(g, cond_var);
				if (sym->kind == v__table__Kind_sum_type) {
					string dot_or_ptr = (v__table__Type_is_ptr(node.cond_type) ? (tos_lit("->")) : (tos_lit(".")));
					v__gen__Gen_write(g, dot_or_ptr);
					v__gen__Gen_write(g, tos_lit("typ == "));
				} else if (sym->kind == v__table__Kind_interface_) {
					v__gen__Gen_write(g, tos_lit("._interface_idx == "));
				}
				v__gen__Gen_expr(g, (*(v__ast__Expr*)/*ee elem_typ */array_get(branch.exprs, sumtype_index)));
				if (is_expr) {
					v__gen__Gen_write(g, tos_lit(") ? "));
				} else {
					v__gen__Gen_writeln(g, tos_lit(") {"));
				}
			}
			v__gen__Gen_stmts(g, branch.stmts);
			if (g->inside_ternary == 0) {
				v__gen__Gen_write(g, tos_lit("}"));
			}
			sumtype_index++;
			if (branch.exprs.len == 0 || sumtype_index == branch.exprs.len) {
				break;
			}
		}
		g->aggregate_type_idx = 0;
	}
}

VV_LOCAL_SYMBOL void v__gen__Gen_match_expr_classic(v__gen__Gen* g, v__ast__MatchExpr node, bool is_expr, string cond_var) {
	v__table__TypeSymbol* type_sym = v__table__Table_get_type_symbol(g->table, node.cond_type);
	// FOR IN array
	array _t1391 = node.branches;
	for (int j = 0; j < _t1391.len; ++j) {
		v__ast__MatchBranch branch = ((v__ast__MatchBranch*)_t1391.data)[j];
		bool is_last = j == node.branches.len - 1;
		if (branch.is_else || (node.is_expr && is_last)) {
			if (node.branches.len > 1) {
				if (is_expr) {
					v__gen__Gen_write(g, tos_lit(" : "));
				} else {
					v__gen__Gen_writeln(g, tos_lit(" else {"));
				}
			}
		} else {
			if (j > 0) {
				if (is_expr) {
					v__gen__Gen_write(g, tos_lit(" : "));
				} else {
					v__gen__Gen_write(g, tos_lit(" else "));
				}
			}
			if (is_expr) {
				v__gen__Gen_write(g, tos_lit("("));
			} else {
				v__gen__Gen_write(g, tos_lit("if ("));
			}
			// FOR IN array
			array _t1392 = branch.exprs;
			for (int i = 0; i < _t1392.len; ++i) {
				v__ast__Expr expr = ((v__ast__Expr*)_t1392.data)[i];
				if (i > 0) {
					v__gen__Gen_write(g, tos_lit(" || "));
				}
				if (type_sym->kind == v__table__Kind_string) {
					if (((/* as */ *(v__ast__StringLiteral*)__as_cast((expr)._245, (expr).typ, /*expected:*/245)).val).len == 0) {
						v__gen__Gen_write(g, _STR("%.*s\000.len == 0", 2, cond_var));
					} else {
						v__gen__Gen_write(g, tos_lit("string_eq("));
						v__gen__Gen_write(g, cond_var);
						v__gen__Gen_write(g, tos_lit(", "));
						v__gen__Gen_expr(g, expr);
						v__gen__Gen_write(g, tos_lit(")"));
					}
				} else if ((expr).typ == 239 /* v.ast.RangeExpr */) {
					bool skip_low = false;
					if (((*expr._239).low).typ == 229 /* v.ast.IntegerLiteral */) {
						if ((node.cond_type == _const_v__table__u16_type || node.cond_type == _const_v__table__u32_type || node.cond_type == _const_v__table__u64_type) && string_eq((*(*expr._239).low._229).val, tos_lit("0"))) {
							skip_low = true;
						}
					}
					v__gen__Gen_write(g, tos_lit("("));
					if (!skip_low) {
						v__gen__Gen_write(g, cond_var);
						v__gen__Gen_write(g, tos_lit(" >= "));
						v__gen__Gen_expr(g, (*expr._239).low);
						v__gen__Gen_write(g, tos_lit(" && "));
					}
					v__gen__Gen_write(g, cond_var);
					v__gen__Gen_write(g, tos_lit(" <= "));
					v__gen__Gen_expr(g, (*expr._239).high);
					v__gen__Gen_write(g, tos_lit(")"));
				} else {
					v__gen__Gen_write(g, cond_var);
					v__gen__Gen_write(g, tos_lit(" == "));
					v__gen__Gen_expr(g, expr);
				}
			}
			if (is_expr) {
				v__gen__Gen_write(g, tos_lit(") ? "));
			} else {
				v__gen__Gen_writeln(g, tos_lit(") {"));
			}
		}
		v__gen__Gen_stmts(g, branch.stmts);
		if (g->inside_ternary == 0 && node.branches.len > 1) {
			v__gen__Gen_write(g, tos_lit("}"));
		}
	}
}

VV_LOCAL_SYMBOL void v__gen__Gen_select_expr(v__gen__Gen* g, v__ast__SelectExpr node) {
	bool is_expr = node.is_expr || g->inside_ternary > 0;
	string cur_line = (is_expr ? (g->empty_line = true,v__gen__Gen_go_before_stmt(g, 0)) : (tos_lit("")));
	int n_channels = (node.has_exception ? (node.branches.len - 1) : (node.branches.len));
	array_v__ast__Expr channels = __new_array_with_default(0, n_channels, sizeof(v__ast__Expr), 0);
	array_v__ast__Expr objs = __new_array_with_default(0, n_channels, sizeof(v__ast__Expr), 0);
	array_string tmp_objs = __new_array_with_default(0, n_channels, sizeof(string), 0);
	array_string elem_types = __new_array_with_default(0, n_channels, sizeof(string), 0);
	array_bool is_push = __new_array_with_default(0, n_channels, sizeof(bool), 0);
	bool has_else = false;
	bool has_timeout = false;
	v__ast__Expr timeout_expr = (v__ast__Expr){
#ifndef __cplusplus
0
#endif
};
	int exception_branch = -1;
	// FOR IN array
	array _t1393 = node.branches;
	for (int j = 0; j < _t1393.len; ++j) {
		v__ast__SelectBranch branch = ((v__ast__SelectBranch*)_t1393.data)[j];
		if (branch.is_else) {
			has_else = true;
			exception_branch = j;
		} else if (branch.is_timeout) {
			has_timeout = true;
			exception_branch = j;
			timeout_expr = (/* as */ *(v__ast__ExprStmt*)__as_cast((branch.stmt)._259, (branch.stmt).typ, /*expected:*/259)).expr;
		} else {
			v__ast__Stmt _t1394 = branch.stmt;
			if (_t1394.typ == 259 /* v.ast.ExprStmt */) {
				v__ast__InfixExpr expr = /* as */ *(v__ast__InfixExpr*)__as_cast(((*branch.stmt._259).expr)._228, ((*branch.stmt._259).expr).typ, /*expected:*/228);
				array_push(&channels, _MOV((v__ast__Expr[]){ expr.left }));
				if ((expr.right).typ == 224 /* v.ast.Ident */ || (expr.right).typ == 227 /* v.ast.IndexExpr */ || (expr.right).typ == 241 /* v.ast.SelectorExpr */ || (expr.right).typ == 246 /* v.ast.StructInit */) {
					array_push(&objs, _MOV((v__ast__Expr[]){ expr.right }));
					array_push(&tmp_objs, _MOV((string[]){ string_clone(tos_lit("")) }));
					array_push(&elem_types, _MOV((string[]){ string_clone(tos_lit("")) }));
				} else {
					array_push(&objs, _MOV((v__ast__Expr[]){ (v__ast__Expr){
#ifndef __cplusplus
0
#endif
} }));
					string tmp_obj = v__gen__Gen_new_tmp_var(g);
					array_push(&tmp_objs, _MOV((string[]){ string_clone(tmp_obj) }));
					string el_stype = v__gen__Gen_typ(g, v__table__Table_mktyp(g->table, expr.right_type));
					v__gen__Gen_writeln(g, _STR("%.*s\000 %.*s\000;", 3, el_stype, tmp_obj));
				}
				array_push(&is_push, _MOV((bool[]){ true }));
			} else if (_t1394.typ == 252 /* v.ast.AssignStmt */) {
				v__ast__PrefixExpr rec_expr = /* as */ *(v__ast__PrefixExpr*)__as_cast(((*(v__ast__Expr*)/*ee elem_typ */array_get((*branch.stmt._252).right, 0)))._238, ((*(v__ast__Expr*)/*ee elem_typ */array_get((*branch.stmt._252).right, 0))).typ, /*expected:*/238);
				array_push(&channels, _MOV((v__ast__Expr[]){ rec_expr.right }));
				array_push(&is_push, _MOV((bool[]){ false }));
				if ((*branch.stmt._252).op == v__token__Kind_decl_assign || (*(v__table__Type*)/*ee elem_typ */array_get((*branch.stmt._252).right_types, 0)) != (*(v__table__Type*)/*ee elem_typ */array_get((*branch.stmt._252).left_types, 0))) {
					string tmp_obj = v__gen__Gen_new_tmp_var(g);
					array_push(&tmp_objs, _MOV((string[]){ string_clone(tmp_obj) }));
					string el_stype = v__gen__Gen_typ(g, (*(v__table__Type*)/*ee elem_typ */array_get((*branch.stmt._252).right_types, 0)));
					array_push(&elem_types, _MOV((string[]){ string_clone(((*branch.stmt._252).op == v__token__Kind_decl_assign ? (string_add(el_stype, tos_lit(" "))) : (tos_lit("")))) }));
					v__gen__Gen_writeln(g, _STR("%.*s\000 %.*s\000;", 3, el_stype, tmp_obj));
				} else {
					array_push(&tmp_objs, _MOV((string[]){ string_clone(tos_lit("")) }));
					array_push(&elem_types, _MOV((string[]){ string_clone(tos_lit("")) }));
				}
				array_push(&objs, _MOV((v__ast__Expr[]){ (*(v__ast__Expr*)/*ee elem_typ */array_get((*branch.stmt._252).left, 0)) }));
			} else {
			};
		}
	}
	string chan_array = v__gen__Gen_new_tmp_var(g);
	v__gen__Gen_write(g, _STR("array_sync__Channel_ptr %.*s\000 = new_array_from_c_array(%"PRId32"\000, %"PRId32"\000, sizeof(sync__Channel*), _MOV((sync__Channel*[%"PRId32"\000]){", 5, chan_array, n_channels, n_channels, n_channels));
	for (int i = 0; i < n_channels; ++i) {
		if (i > 0) {
			v__gen__Gen_write(g, tos_lit(", "));
		}
		v__gen__Gen_write(g, tos_lit("(sync__Channel*)("));
		v__gen__Gen_expr(g, (*(v__ast__Expr*)/*ee elem_typ */array_get(channels, i)));
		v__gen__Gen_write(g, tos_lit(")"));
	}
	v__gen__Gen_writeln(g, tos_lit("}));"));
	string directions_array = v__gen__Gen_new_tmp_var(g);
	v__gen__Gen_write(g, _STR("array_sync__Direction %.*s\000 = new_array_from_c_array(%"PRId32"\000, %"PRId32"\000, sizeof(sync__Direction), _MOV((sync__Direction[%"PRId32"\000]){", 5, directions_array, n_channels, n_channels, n_channels));
	for (int i = 0; i < n_channels; ++i) {
		if (i > 0) {
			v__gen__Gen_write(g, tos_lit(", "));
		}
		if ((*(bool*)/*ee elem_typ */array_get(is_push, i))) {
			v__gen__Gen_write(g, tos_lit("sync__Direction_push"));
		} else {
			v__gen__Gen_write(g, tos_lit("sync__Direction_pop"));
		}
	}
	v__gen__Gen_writeln(g, tos_lit("}));"));
	string objs_array = v__gen__Gen_new_tmp_var(g);
	v__gen__Gen_write(g, _STR("array_voidptr %.*s\000 = new_array_from_c_array(%"PRId32"\000, %"PRId32"\000, sizeof(voidptr), _MOV((voidptr[%"PRId32"\000]){", 5, objs_array, n_channels, n_channels, n_channels));
	for (int i = 0; i < n_channels; ++i) {
		v__gen__Gen_write(g, (i > 0 ? (tos_lit(", &")) : (tos_lit("&"))));
		if (((*(string*)/*ee elem_typ */array_get(tmp_objs, i))).len == 0) {
			v__gen__Gen_expr(g, (*(v__ast__Expr*)/*ee elem_typ */array_get(objs, i)));
		} else {
			v__gen__Gen_write(g, (*(string*)/*ee elem_typ */array_get(tmp_objs, i)));
		}
	}
	v__gen__Gen_writeln(g, tos_lit("}));"));
	string select_result = v__gen__Gen_new_tmp_var(g);
	v__gen__Gen_write(g, _STR("int %.*s\000 = sync__channel_select(&/*arr*/%.*s\000, %.*s\000, &/*arr*/%.*s\000, ", 5, select_result, chan_array, directions_array, objs_array));
	if (has_timeout) {
		v__gen__Gen_expr(g, timeout_expr);
	} else if (has_else) {
		v__gen__Gen_write(g, tos_lit("0"));
	} else {
		v__gen__Gen_write(g, tos_lit("-1"));
	}
	v__gen__Gen_writeln(g, tos_lit(");"));
	int i = 0;
	for (int j = 0; j < node.branches.len; ++j) {
		if (j > 0) {
			v__gen__Gen_write(g, tos_lit("} else "));
		}
		v__gen__Gen_write(g, _STR("if (%.*s\000 == ", 2, select_result));
		if (j == exception_branch) {
			v__gen__Gen_writeln(g, tos_lit("-1) {"));
		} else {
			v__gen__Gen_writeln(g, _STR("%"PRId32"\000) {", 2, i));
			if (!(*(bool*)/*ee elem_typ */array_get(is_push, i)) && ((*(string*)/*ee elem_typ */array_get(tmp_objs, i))).len != 0) {
				v__gen__Gen_write(g, _STR("\t%.*s", 1, (*(string*)/*ee elem_typ */array_get(elem_types, i))));
				v__gen__Gen_expr(g, (*(v__ast__Expr*)/*ee elem_typ */array_get(objs, i)));
				v__gen__Gen_writeln(g, _STR(" = %.*s\000;", 2, (*(string*)/*ee elem_typ */array_get(tmp_objs, i))));
			}
			i++;
		}
		v__gen__Gen_stmts(g, (*(v__ast__SelectBranch*)/*ee elem_typ */array_get(node.branches, j)).stmts);
	}
	v__gen__Gen_writeln(g, tos_lit("}"));
	if (is_expr) {
		g->empty_line = false;
		v__gen__Gen_write(g, cur_line);
		v__gen__Gen_write(g, _STR("(%.*s\000 != -2)", 2, select_result));
	}
}

VV_LOCAL_SYMBOL void v__gen__Gen_ident(v__gen__Gen* g, v__ast__Ident node) {
	bool prevent_sum_type_unwrapping_once = g->prevent_sum_type_unwrapping_once;
	g->prevent_sum_type_unwrapping_once = false;
	if (string_eq(node.name, tos_lit("lld"))) {
		return;
	}
	if (string_starts_with(node.name, tos_lit("C."))) {
		v__gen__Gen_write(g, v__util__no_dots(string_substr(node.name, 2, node.name.len)));
		return;
	}
	if (node.kind == v__ast__IdentKind_constant) {
		v__gen__Gen_write(g, tos_lit("_const_"));
	}
	string name = v__gen__c_name(node.name);
	if ((node.info).typ == 313 /* v.ast.IdentVar */) {
		v__ast__IdentVar ident_var = /* as */ *(v__ast__IdentVar*)__as_cast((node.info)._313, (node.info).typ, /*expected:*/313);
		if (ident_var.is_optional && !(g->is_assign_lhs && g->right_is_opt)) {
			v__gen__Gen_write(g, tos_lit("/*opt*/"));
			string styp = v__gen__Gen_base_type(g, ident_var.typ);
			v__gen__Gen_write(g, _STR("(*(%.*s\000*)%.*s\000.data)", 3, styp, name));
			return;
		}
		if (!g->is_assign_lhs && ident_var.share == v__table__ShareType_shared_t) {
			v__gen__Gen_write(g, _STR("%.*s\000.val", 2, name));
			return;
		}
		v__ast__Scope* scope = v__ast__Scope_innermost(g->file.scope, node.pos.pos);
		{ /* if guard */ 
		Option_v__ast__Var_ptr _t1409;
		if (_t1409 = v__ast__Scope_find_var(scope, node.name), _t1409.ok) {
			v__ast__Var* v = *(v__ast__Var**)_t1409.data;
			if (v->sum_type_casts.len > 0) {
				if (!prevent_sum_type_unwrapping_once) {
					// FOR IN array
					array _t1410 = v->sum_type_casts;
					for (int _t1411 = 0; _t1411 < _t1410.len; ++_t1411) {
						v__gen__Gen_write(g, tos_lit("(*"));
					}
					// FOR IN array
					array _t1412 = v->sum_type_casts;
					for (int i = 0; i < _t1412.len; ++i) {
						v__table__Type typ = ((v__table__Type*)_t1412.data)[i];
						v__table__TypeSymbol* cast_sym = v__table__Table_get_type_symbol(g->table, typ);
						if (i == 0) {
							v__gen__Gen_write(g, name);
						}
						if ((cast_sym->info).typ == 346 /* v.table.Aggregate */) {
							v__gen__Gen_write(g, _STR("._%"PRId32"", 1, (*(v__table__Type*)/*ee elem_typ */array_get((*cast_sym->info._346).types, g->aggregate_type_idx))));
						} else {
							v__gen__Gen_write(g, _STR("._%"PRId32"", 1, typ));
						}
						v__gen__Gen_write(g, tos_lit(")"));
					}
					return;
				}
			}
		}}
	}
	v__gen__Gen_write(g, v__gen__Gen_get_ternary_name(g, name));
}

VV_LOCAL_SYMBOL void v__gen__Gen_concat_expr(v__gen__Gen* g, v__ast__ConcatExpr node) {
	string styp = v__gen__Gen_typ(g, node.return_type);
	v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, node.return_type);
	bool is_multi = sym->kind == v__table__Kind_multi_return;
	if (!is_multi) {
		v__gen__Gen_expr(g, (*(v__ast__Expr*)/*ee elem_typ */array_get(node.vals, 0)));
	} else {
		v__gen__Gen_write(g, _STR("(%.*s\000){", 2, styp));
		// FOR IN array
		array _t1413 = node.vals;
		for (int i = 0; i < _t1413.len; ++i) {
			v__ast__Expr expr = ((v__ast__Expr*)_t1413.data)[i];
			v__gen__Gen_write(g, _STR(".arg%"PRId32"\000=", 2, i));
			v__gen__Gen_expr(g, expr);
			if (i < node.vals.len - 1) {
				v__gen__Gen_write(g, tos_lit(","));
			}
		}
		v__gen__Gen_write(g, tos_lit("}"));
	}
}

VV_LOCAL_SYMBOL void v__gen__Gen_if_expr(v__gen__Gen* g, v__ast__IfExpr node) {
	if (node.is_comptime) {
		v__gen__Gen_comp_if(g, node);
		return;
	}
	v__ast__IfBranch first_branch = (*(v__ast__IfBranch*)/*ee elem_typ */array_get(node.branches, 0));
	bool needs_tmp_var = node.is_expr && (g->pref->autofree || (g->pref->experimental && (first_branch.stmts.len > 1 || (((*(v__ast__Stmt*)/*ee elem_typ */array_get(first_branch.stmts, 0))).typ == 259 /* v.ast.ExprStmt */ && ((/* as */ *(v__ast__ExprStmt*)__as_cast(((*(v__ast__Stmt*)/*ee elem_typ */array_get(first_branch.stmts, 0)))._259, ((*(v__ast__Stmt*)/*ee elem_typ */array_get(first_branch.stmts, 0))).typ, /*expected:*/259)).expr).typ == 225 /* v.ast.IfExpr */))));
	string tmp = (needs_tmp_var ? (v__gen__Gen_new_tmp_var(g)) : (tos_lit("")));
	string cur_line = tos_lit("");
	if (needs_tmp_var) {
		v__gen__Gen_write(g, tos_lit("/*experimental if expr*/"));
		string styp = v__gen__Gen_typ(g, node.typ);
		cur_line = v__gen__Gen_go_before_stmt(g, 0);
		v__gen__Gen_writeln(g, _STR("%.*s\000 %.*s\000; /* if prepend */", 3, styp, tmp));
	} else if (node.is_expr || g->inside_ternary != 0) {
		g->inside_ternary++;
		v__gen__Gen_write(g, tos_lit("("));
		// FOR IN array
		array _t1414 = node.branches;
		for (int i = 0; i < _t1414.len; ++i) {
			v__ast__IfBranch branch = ((v__ast__IfBranch*)_t1414.data)[i];
			if (i > 0) {
				v__gen__Gen_write(g, tos_lit(" : "));
			}
			if (i < node.branches.len - 1 || !node.has_else) {
				v__gen__Gen_expr(g, branch.cond);
				v__gen__Gen_write(g, tos_lit(" ? "));
			}
			v__gen__Gen_stmts(g, branch.stmts);
		}
		if (node.branches.len == 1) {
			v__gen__Gen_write(g, tos_lit(": 0"));
		}
		v__gen__Gen_write(g, tos_lit(")"));
		v__gen__Gen_decrement_inside_ternary(g);
		return;
	}
	bool is_guard = false;
	int guard_idx = 0;
	array_string guard_vars = __new_array_with_default(0, 0, sizeof(string), 0);
	// FOR IN array
	array _t1415 = node.branches;
	for (int i = 0; i < _t1415.len; ++i) {
		v__ast__IfBranch branch = ((v__ast__IfBranch*)_t1415.data)[i];
		v__ast__Expr cond = branch.cond;
		if ((cond).typ == 226 /* v.ast.IfGuardExpr */) {
			if (!is_guard) {
				is_guard = true;
				guard_idx = i;
				guard_vars = __new_array_with_default(node.branches.len, 0, sizeof(string), &(string[]){tos_lit("")});
				v__gen__Gen_writeln(g, tos_lit("{ /* if guard */ "));
			}
			string var_name = v__gen__Gen_new_tmp_var(g);
			array_set(&guard_vars, i, &(string[]) { var_name });
			v__gen__Gen_writeln(g, _STR("%.*s\000 %.*s\000;", 3, v__gen__Gen_typ(g, (*cond._226).expr_type), var_name));
		}
	}
	// FOR IN array
	array _t1416 = node.branches;
	for (int i = 0; i < _t1416.len; ++i) {
		v__ast__IfBranch branch = ((v__ast__IfBranch*)_t1416.data)[i];
		if (i > 0) {
			v__gen__Gen_write(g, tos_lit("} else "));
		}
		if (i == node.branches.len - 1 && node.has_else) {
			v__gen__Gen_writeln(g, tos_lit("{"));
			if (is_guard && guard_idx == i - 1) {
				string cvar_name = (*(string*)/*ee elem_typ */array_get(guard_vars, guard_idx));
				v__gen__Gen_writeln(g, _STR("\tstring err = %.*s\000.v_error;", 2, cvar_name));
				v__gen__Gen_writeln(g, _STR("\tint errcode = %.*s\000.ecode;", 2, cvar_name));
			}
		} else {
			v__ast__Expr _t1417 = branch.cond;
			if (_t1417.typ == 226 /* v.ast.IfGuardExpr */) {
				string var_name = (*(string*)/*ee elem_typ */array_get(guard_vars, i));
				v__gen__Gen_write(g, _STR("if (%.*s\000 = ", 2, var_name));
				v__gen__Gen_expr(g, (*branch.cond._226).expr);
				v__gen__Gen_writeln(g, _STR(", %.*s\000.ok) {", 2, var_name));
				if (string_ne((*branch.cond._226).var_name, tos_lit("_"))) {
					string base_type = v__gen__Gen_base_type(g, (*branch.cond._226).expr_type);
					v__gen__Gen_writeln(g, _STR("\t%.*s\000 %.*s\000 = *(%.*s\000*)%.*s\000.data;", 5, base_type, (*branch.cond._226).var_name, base_type, var_name));
				}
			} else {
				v__gen__Gen_write(g, tos_lit("if ("));
				v__gen__Gen_expr(g, branch.cond);
				v__gen__Gen_writeln(g, tos_lit(") {"));
			};
		}
		if (branch.smartcast && branch.stmts.len > 0) {
			v__ast__InfixExpr infix = /* as */ *(v__ast__InfixExpr*)__as_cast((branch.cond)._228, (branch.cond).typ, /*expected:*/228);
			if ((infix.left).typ == 224 /* v.ast.Ident */) {
				v__ast__Type right_type = /* as */ *(v__ast__Type*)__as_cast((infix.right)._247, (infix.right).typ, /*expected:*/247);
				v__table__Type left_type = infix.left_type;
				string it_type = v__gen__Gen_typ(g, right_type.typ);
				v__gen__Gen_write(g, _STR("\t%.*s\000* _sc_tmp_%"PRId32"\000 = (%.*s\000*)", 4, it_type, branch.pos.pos, it_type));
				v__gen__Gen_expr(g, infix.left);
				if (v__table__Type_is_ptr(left_type)) {
					v__gen__Gen_write(g, tos_lit("->"));
				} else {
					v__gen__Gen_write(g, tos_lit("."));
				}
				v__gen__Gen_writeln(g, tos_lit("_object;"));
				v__gen__Gen_writeln(g, _STR("\t%.*s\000* %.*s\000 = _sc_tmp_%"PRId32"\000;", 4, it_type, (*infix.left._224).name, branch.pos.pos));
			}
		}
		if (needs_tmp_var) {
			v__gen__Gen_stmts_with_tmp_var(g, branch.stmts, tmp);
		} else {
			v__gen__Gen_stmts(g, branch.stmts);
		}
	}
	if (is_guard) {
		v__gen__Gen_write(g, tos_lit("}"));
	}
	v__gen__Gen_writeln(g, tos_lit("}"));
	if (needs_tmp_var) {
		v__gen__Gen_write(g, _STR("%.*s\000 %.*s\000 /*Z*/", 3, cur_line, tmp));
	}
}

VV_LOCAL_SYMBOL void v__gen__Gen_index_expr(v__gen__Gen* g, v__ast__IndexExpr node) {
	v__ast__Expr _t1418 = node.index;
	if (_t1418.typ == 239 /* v.ast.RangeExpr */) {
		v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, node.left_type);
		if (sym->kind == v__table__Kind_string) {
			v__gen__Gen_write(g, tos_lit("string_substr("));
			v__gen__Gen_expr(g, node.left);
		} else if (sym->kind == v__table__Kind_array) {
			v__gen__Gen_write(g, tos_lit("array_slice("));
			if (v__table__Type_is_ptr(node.left_type)) {
				v__gen__Gen_write(g, tos_lit("*"));
			}
			v__gen__Gen_expr(g, node.left);
		} else if (sym->kind == v__table__Kind_array_fixed) {
			v__gen__Gen_write(g, tos_lit("array_slice(new_array_from_c_array(_ARR_LEN("));
			v__gen__Gen_expr(g, node.left);
			v__gen__Gen_write(g, tos_lit("), _ARR_LEN("));
			v__gen__Gen_expr(g, node.left);
			v__gen__Gen_write(g, tos_lit("), sizeof("));
			v__gen__Gen_expr(g, node.left);
			v__gen__Gen_write(g, tos_lit("[0]), "));
			v__gen__Gen_expr(g, node.left);
			v__gen__Gen_write(g, tos_lit(")"));
		} else {
			v__gen__Gen_expr(g, node.left);
		}
		v__gen__Gen_write(g, tos_lit(", "));
		if ((*node.index._239).has_low) {
			v__gen__Gen_expr(g, (*node.index._239).low);
		} else {
			v__gen__Gen_write(g, tos_lit("0"));
		}
		v__gen__Gen_write(g, tos_lit(", "));
		if ((*node.index._239).has_high) {
			v__gen__Gen_expr(g, (*node.index._239).high);
		} else {
			v__gen__Gen_expr(g, node.left);
			v__gen__Gen_write(g, tos_lit(".len"));
		}
		v__gen__Gen_write(g, tos_lit(")"));
	} else {
		v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, node.left_type);
		bool left_is_ptr = v__table__Type_is_ptr(node.left_type);
		if (v__table__Type_has_flag(node.left_type, v__table__TypeFlag_variadic)) {
			v__gen__Gen_expr(g, node.left);
			v__gen__Gen_write(g, tos_lit(".args"));
			v__gen__Gen_write(g, tos_lit("["));
			v__gen__Gen_expr(g, node.index);
			v__gen__Gen_write(g, tos_lit("]"));
		} else if (sym->kind == v__table__Kind_array) {
			v__table__Array info = /* as */ *(v__table__Array*)__as_cast((sym->info)._350, (sym->info).typ, /*expected:*/350);
			string elem_type_str = v__gen__Gen_typ(g, info.elem_type);
			v__table__TypeSymbol* elem_typ = v__table__Table_get_type_symbol(g->table, info.elem_type);
			bool is_selector = (node.left).typ == 241 /* v.ast.SelectorExpr */;
			if (g->is_assign_lhs && !is_selector && node.is_setter) {
				bool is_direct_array_access = g->fn_decl != 0 && g->fn_decl->is_direct_arr;
				v__table__Kind _t1419 = elem_typ->kind;
								string array_ptr_type_str = ((_t1419 == v__table__Kind_function) ? (tos_lit("voidptr*")) : (_STR("%.*s\000*", 2, elem_type_str)));
				if (is_direct_array_access) {
					v__gen__Gen_write(g, _STR("((%.*s\000)", 2, array_ptr_type_str));
				} else {
					g->is_array_set = true;
					v__gen__Gen_write(g, tos_lit("array_set("));
					if (!left_is_ptr || v__table__Type_has_flag(node.left_type, v__table__TypeFlag_shared_f)) {
						v__gen__Gen_write(g, tos_lit("&"));
					}
				}
				v__gen__Gen_expr(g, node.left);
				if (v__table__Type_has_flag(node.left_type, v__table__TypeFlag_shared_f)) {
					if (left_is_ptr) {
						v__gen__Gen_write(g, tos_lit("->val"));
					} else {
						v__gen__Gen_write(g, tos_lit(".val"));
					}
				}
				if (is_direct_array_access) {
					if (left_is_ptr && !v__table__Type_has_flag(node.left_type, v__table__TypeFlag_shared_f)) {
						v__gen__Gen_write(g, tos_lit("->"));
					} else {
						v__gen__Gen_write(g, tos_lit("."));
					}
					v__gen__Gen_write(g, tos_lit("data)["));
					v__gen__Gen_expr(g, node.index);
					v__gen__Gen_write(g, tos_lit("]"));
				} else {
					v__gen__Gen_write(g, tos_lit(", "));
					v__gen__Gen_expr(g, node.index);
					bool need_wrapper = true;
					if (need_wrapper) {
						if (elem_typ->kind == v__table__Kind_function) {
							v__gen__Gen_write(g, tos_lit(", &(voidptr[]) { "));
						} else {
							v__gen__Gen_write(g, _STR(", &(%.*s\000[]) { ", 2, elem_type_str));
						}
					} else {
						v__gen__Gen_write(g, tos_lit(", &"));
					}
					if (g->assign_op != v__token__Kind_assign && _IN(v__token__Kind, g->assign_op, _const_v__token__assign_tokens) && info.elem_type != _const_v__table__string_type) {
						v__gen__Gen_write(g, _STR("*(%.*s\000*)array_get(", 2, elem_type_str));
						if (left_is_ptr && !v__table__Type_has_flag(node.left_type, v__table__TypeFlag_shared_f)) {
							v__gen__Gen_write(g, tos_lit("*"));
						}
						v__gen__Gen_expr(g, node.left);
						if (v__table__Type_has_flag(node.left_type, v__table__TypeFlag_shared_f)) {
							if (left_is_ptr) {
								v__gen__Gen_write(g, tos_lit("->val"));
							} else {
								v__gen__Gen_write(g, tos_lit(".val"));
							}
						}
						v__gen__Gen_write(g, tos_lit(", "));
						v__gen__Gen_expr(g, node.index);
						v__gen__Gen_write(g, tos_lit(") "));
						v__token__Kind _t1420 = g->assign_op;
												string op = ((_t1420 == v__token__Kind_mult_assign) ? (tos_lit("*")) : (_t1420 == v__token__Kind_plus_assign) ? (tos_lit("+")) : (_t1420 == v__token__Kind_minus_assign) ? (tos_lit("-")) : (_t1420 == v__token__Kind_div_assign) ? (tos_lit("/")) : (_t1420 == v__token__Kind_xor_assign) ? (tos_lit("^")) : (_t1420 == v__token__Kind_mod_assign) ? (tos_lit("%")) : (_t1420 == v__token__Kind_or_assign) ? (tos_lit("|")) : (_t1420 == v__token__Kind_and_assign) ? (tos_lit("&")) : (_t1420 == v__token__Kind_left_shift_assign) ? (tos_lit("<<")) : (_t1420 == v__token__Kind_right_shift_assign) ? (tos_lit(">>")) : (tos_lit("")));
						v__gen__Gen_write(g, op);
					}
				}
			} else {
				bool is_direct_array_access = g->fn_decl != 0 && g->fn_decl->is_direct_arr;
				v__table__Kind _t1421 = elem_typ->kind;
								string array_ptr_type_str = ((_t1421 == v__table__Kind_function) ? (tos_lit("voidptr*")) : (_STR("%.*s\000*", 2, elem_type_str)));
				bool needs_clone = info.elem_type == _const_v__table__string_type_idx && g->pref->autofree && !g->is_assign_lhs;
				if (needs_clone) {
					v__gen__Gen_write(g, tos_lit("/*2*/string_clone("));
				}
				if (is_direct_array_access) {
					v__gen__Gen_write(g, _STR("((%.*s\000)", 2, array_ptr_type_str));
				} else {
					v__gen__Gen_write(g, _STR("(*(%.*s\000)/*ee elem_typ */array_get(", 2, array_ptr_type_str));
					if (left_is_ptr && !v__table__Type_has_flag(node.left_type, v__table__TypeFlag_shared_f)) {
						v__gen__Gen_write(g, tos_lit("*"));
					}
				}
				v__gen__Gen_expr(g, node.left);
				if (v__table__Type_has_flag(node.left_type, v__table__TypeFlag_shared_f)) {
					if (left_is_ptr) {
						v__gen__Gen_write(g, tos_lit("->val"));
					} else {
						v__gen__Gen_write(g, tos_lit(".val"));
					}
				}
				if (is_direct_array_access) {
					if (left_is_ptr && !v__table__Type_has_flag(node.left_type, v__table__TypeFlag_shared_f)) {
						v__gen__Gen_write(g, tos_lit("->"));
					} else {
						v__gen__Gen_write(g, tos_lit("."));
					}
					v__gen__Gen_write(g, tos_lit("data)["));
					v__gen__Gen_expr(g, node.index);
					v__gen__Gen_write(g, tos_lit("]"));
				} else {
					v__gen__Gen_write(g, tos_lit(", "));
					v__gen__Gen_expr(g, node.index);
					v__gen__Gen_write(g, tos_lit("))"));
				}
				if (needs_clone) {
					v__gen__Gen_write(g, tos_lit(")"));
				}
			}
		} else if (sym->kind == v__table__Kind_map) {
			v__table__Map info = /* as */ *(v__table__Map*)__as_cast((sym->info)._349, (sym->info).typ, /*expected:*/349);
			string elem_type_str = v__gen__Gen_typ(g, info.value_type);
			v__table__TypeSymbol* elem_typ = v__table__Table_get_type_symbol(g->table, info.value_type);
			bool get_and_set_types = (elem_typ->kind == v__table__Kind_struct_ || elem_typ->kind == v__table__Kind_map);
			if (g->is_assign_lhs && !g->is_array_set && !get_and_set_types) {
				g->is_array_set = true;
				v__gen__Gen_write(g, tos_lit("map_set("));
				if (!left_is_ptr) {
					v__gen__Gen_write(g, tos_lit("&"));
				}
				v__gen__Gen_expr(g, node.left);
				v__gen__Gen_write(g, tos_lit(", "));
				v__gen__Gen_expr(g, node.index);
				if (elem_typ->kind == v__table__Kind_function) {
					v__gen__Gen_write(g, tos_lit(", &(voidptr[]) { "));
				} else {
					v__gen__Gen_write(g, _STR(", &(%.*s\000[]) { ", 2, elem_type_str));
				}
			} else if ((g->inside_map_postfix || g->inside_map_infix) || (g->is_assign_lhs && !g->is_array_set && get_and_set_types)) {
				string zero = v__gen__Gen_type_default(g, info.value_type);
				v__gen__Gen_write(g, _STR("(*(%.*s\000*)map_get_and_set(", 2, elem_type_str));
				if (!left_is_ptr) {
					v__gen__Gen_write(g, tos_lit("&"));
				}
				v__gen__Gen_expr(g, node.left);
				v__gen__Gen_write(g, tos_lit(", "));
				v__gen__Gen_expr(g, node.index);
				v__gen__Gen_write(g, _STR(", &(%.*s\000[]){ %.*s\000 }))", 3, elem_type_str, zero));
			} else {
				string zero = v__gen__Gen_type_default(g, info.value_type);
				if (elem_typ->kind == v__table__Kind_function) {
					v__gen__Gen_write(g, tos_lit("(*(voidptr*)map_get("));
				} else {
					v__gen__Gen_write(g, _STR("(*(%.*s\000*)map_get(", 2, elem_type_str));
				}
				if (v__table__Type_is_ptr(node.left_type)) {
					v__gen__Gen_write(g, tos_lit("*"));
				}
				v__gen__Gen_expr(g, node.left);
				v__gen__Gen_write(g, tos_lit(", "));
				v__gen__Gen_expr(g, node.index);
				if (elem_typ->kind == v__table__Kind_function) {
					v__gen__Gen_write(g, _STR(", &(voidptr[]){ %.*s\000 }))", 2, zero));
				} else {
					v__gen__Gen_write(g, _STR(", &(%.*s\000[]){ %.*s\000 }))", 3, elem_type_str, zero));
				}
			}
		} else if (sym->kind == v__table__Kind_string && !v__table__Type_is_ptr(node.left_type)) {
			v__gen__Gen_write(g, tos_lit("string_at("));
			v__gen__Gen_expr(g, node.left);
			v__gen__Gen_write(g, tos_lit(", "));
			v__gen__Gen_expr(g, node.index);
			v__gen__Gen_write(g, tos_lit(")"));
		} else {
			v__gen__Gen_expr(g, node.left);
			v__gen__Gen_write(g, tos_lit("["));
			v__gen__Gen_expr(g, node.index);
			v__gen__Gen_write(g, tos_lit("]"));
		}
	};
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL bool v__gen__Gen_expr_is_multi_return_call(v__gen__Gen* g, v__ast__Expr expr) {
	v__ast__Expr _t1422 = expr;
	if (_t1422.typ == 215 /* v.ast.CallExpr */) {
		return v__table__Table_get_type_symbol(g->table, (*expr._215).return_type)->kind == v__table__Kind_multi_return;
	} else {
		return false;
	};
	return 0;
}

VV_LOCAL_SYMBOL void v__gen__Gen_return_statement(v__gen__Gen* g, v__ast__Return node) {
	v__gen__Gen_write_v_source_line_info(g, node.pos);
	if (node.exprs.len > 0) {
		if (((*(v__ast__Expr*)/*ee elem_typ */array_get(node.exprs, 0))).typ == 220 /* v.ast.ComptimeCall */) {
			v__gen__Gen_expr(g, (*(v__ast__Expr*)/*ee elem_typ */array_get(node.exprs, 0)));
			v__gen__Gen_writeln(g, tos_lit(";"));
			return;
		}
	}
	g->inside_return = true;
	v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, g->fn_decl->return_type);
	bool fn_return_is_multi = sym->kind == v__table__Kind_multi_return;
	bool fn_return_is_optional = v__table__Type_has_flag(g->fn_decl->return_type, v__table__TypeFlag_optional);
	if (node.exprs.len == 0) {
		if (fn_return_is_optional) {
			string tmp = v__gen__Gen_new_tmp_var(g);
			string styp = v__gen__Gen_typ(g, g->fn_decl->return_type);
			v__gen__Gen_writeln(g, _STR("%.*s\000 %.*s\000 = {.ok = true};", 3, styp, tmp));
			v__gen__Gen_writeln(g, _STR("return %.*s\000;", 2, tmp));
		} else {
			v__gen__Gen_writeln(g, tos_lit("return;"));
		}
		// Defer begin
		g->inside_return = false;
		// Defer end
		return;
	}
	if (fn_return_is_optional) {
		bool optional_none = ((*(v__ast__Expr*)/*ee elem_typ */array_get(node.exprs, 0))).typ == 234 /* v.ast.None */;
		bool is_regular_option = string_eq(v__gen__Gen_typ(g, (*(v__table__Type*)/*ee elem_typ */array_get(node.types, 0))), tos_lit("Option"));
		if (optional_none || is_regular_option) {
			string tmp = v__gen__Gen_new_tmp_var(g);
			v__gen__Gen_write(g, _STR("Option %.*s\000 = ", 2, tmp));
			v__gen__Gen_expr_with_cast(g, (*(v__ast__Expr*)/*ee elem_typ */array_get(node.exprs, 0)), (*(v__table__Type*)/*ee elem_typ */array_get(node.types, 0)), g->fn_decl->return_type);
			v__gen__Gen_writeln(g, tos_lit(";"));
			string styp = v__gen__Gen_typ(g, g->fn_decl->return_type);
			v__gen__Gen_writeln(g, _STR("return *(%.*s\000*)&%.*s\000;", 3, styp, tmp));
			// Defer begin
			g->inside_return = false;
			// Defer end
			return;
		}
	}
	if (fn_return_is_multi) {
		string styp = tos_lit("");
		string opt_tmp = tos_lit("");
		string opt_type = tos_lit("");
		if (fn_return_is_optional) {
			opt_type = v__gen__Gen_typ(g, g->fn_decl->return_type);
			opt_tmp = v__gen__Gen_new_tmp_var(g);
			v__gen__Gen_writeln(g, _STR("%.*s\000 %.*s\000;", 3, opt_type, opt_tmp));
			styp = v__gen__Gen_base_type(g, g->fn_decl->return_type);
			v__gen__Gen_write(g, _STR("opt_ok2(&(%.*s\000/*X*/[]) { ", 2, styp));
		} else {
			v__gen__Gen_write(g, tos_lit("return "));
			styp = v__gen__Gen_typ(g, g->fn_decl->return_type);
		}
		string multi_unpack = tos_lit("");
		v__gen__Gen_write(g, _STR("(%.*s\000){", 2, styp));
		int arg_idx = 0;
		// FOR IN array
		array _t1423 = node.exprs;
		for (int i = 0; i < _t1423.len; ++i) {
			v__ast__Expr expr = ((v__ast__Expr*)_t1423.data)[i];
			if (v__gen__Gen_expr_is_multi_return_call(g, expr)) {
				v__ast__CallExpr c = /* as */ *(v__ast__CallExpr*)__as_cast((expr)._215, (expr).typ, /*expected:*/215);
				v__table__TypeSymbol* expr_sym = v__table__Table_get_type_symbol(g->table, c.return_type);
				string tmp = v__gen__Gen_new_tmp_var(g);
				if (!v__table__Type_has_flag(c.return_type, v__table__TypeFlag_optional)) {
					string s = v__gen__Gen_go_before_stmt(g, 0);
					string expr_styp = v__gen__Gen_typ(g, c.return_type);
					v__gen__Gen_write(g, _STR("%.*s\000 %.*s\000=", 3, expr_styp, tmp));
					v__gen__Gen_expr(g, expr);
					v__gen__Gen_writeln(g, tos_lit(";"));
					multi_unpack = /*f*/string_add(multi_unpack, v__gen__Gen_go_before_stmt(g, 0));
					v__gen__Gen_write(g, s);
				} else {
					string s = v__gen__Gen_go_before_stmt(g, 0);
					g->tmp_count--;
					v__gen__Gen_expr(g, expr);
					multi_unpack = /*f*/string_add(multi_unpack, v__gen__Gen_go_before_stmt(g, 0));
					v__gen__Gen_write(g, s);
					string expr_styp = v__gen__Gen_base_type(g, c.return_type);
					tmp = (_STR("/*opt*/(*(%.*s\000*)%.*s\000.data)", 3, expr_styp, tmp));
				}
				array_v__table__Type expr_types = v__table__TypeSymbol_mr_info(expr_sym).types;
				// FOR IN array
				array _t1424 = expr_types;
				for (int j = 0; j < _t1424.len; ++j) {
					v__gen__Gen_write(g, _STR(".arg%"PRId32"\000=%.*s\000.arg%"PRId32"", 3, arg_idx, tmp, j));
					if (j < expr_types.len || i < node.exprs.len - 1) {
						v__gen__Gen_write(g, tos_lit(","));
					}
					arg_idx++;
				}
				continue;
			}
			v__gen__Gen_write(g, _STR(".arg%"PRId32"\000=", 2, arg_idx));
			v__gen__Gen_expr(g, expr);
			arg_idx++;
			if (i < node.exprs.len - 1) {
				v__gen__Gen_write(g, tos_lit(", "));
			}
		}
		v__gen__Gen_write(g, tos_lit("}"));
		if (fn_return_is_optional) {
			v__gen__Gen_writeln(g, _STR(" }, (OptionBase*)(&%.*s\000), sizeof(%.*s\000));", 3, opt_tmp, styp));
			v__gen__Gen_write(g, _STR("return %.*s", 1, opt_tmp));
		}
		if (multi_unpack.len > 0) {
			v__gen__Gen_insert_before_stmt(g, multi_unpack);
		}
	} else if (node.exprs.len >= 1) {
		v__table__TypeSymbol* return_sym = v__table__Table_get_type_symbol(g->table, (*(v__table__Type*)/*ee elem_typ */array_get(node.types, 0)));
		if (fn_return_is_optional && !v__table__Type_has_flag((*(v__table__Type*)/*ee elem_typ */array_get(node.types, 0)), v__table__TypeFlag_optional) && string_ne(return_sym->name, tos_lit("Option"))) {
			string styp = v__gen__Gen_base_type(g, g->fn_decl->return_type);
			string opt_type = v__gen__Gen_typ(g, g->fn_decl->return_type);
			string opt_tmp = v__gen__Gen_new_tmp_var(g);
			v__gen__Gen_writeln(g, _STR("%.*s\000 %.*s\000;", 3, opt_type, opt_tmp));
			v__gen__Gen_write(g, _STR("opt_ok2(&(%.*s\000[]) { ", 2, styp));
			if (!v__table__Type_is_ptr(g->fn_decl->return_type) && v__table__Type_is_ptr((*(v__table__Type*)/*ee elem_typ */array_get(node.types, 0)))) {
				v__gen__Gen_write(g, tos_lit("*"));
			}
			// FOR IN array
			array _t1425 = node.exprs;
			for (int i = 0; i < _t1425.len; ++i) {
				v__ast__Expr expr = ((v__ast__Expr*)_t1425.data)[i];
				v__gen__Gen_expr(g, expr);
				if (i < node.exprs.len - 1) {
					v__gen__Gen_write(g, tos_lit(", "));
				}
			}
			v__gen__Gen_writeln(g, _STR(" }, (OptionBase*)(&%.*s\000), sizeof(%.*s\000));", 3, opt_tmp, styp));
			v__gen__Gen_writeln(g, _STR("return %.*s\000;", 2, opt_tmp));
			// Defer begin
			g->inside_return = false;
			// Defer end
			return;
		}
		bool v_free = g->pref->autofree && ((*(v__ast__Expr*)/*ee elem_typ */array_get(node.exprs, 0))).typ == 215 /* v.ast.CallExpr */;
		string tmp = tos_lit("");
		if (v_free) {
			tmp = v__gen__Gen_new_tmp_var(g);
			v__gen__Gen_write(g, v__gen__Gen_typ(g, g->fn_decl->return_type));
			v__gen__Gen_write(g, tos_lit(" "));
			v__gen__Gen_write(g, tmp);
			v__gen__Gen_write(g, tos_lit(" = "));
		} else {
			v__gen__Gen_write(g, tos_lit("return "));
		}
		bool cast_interface = sym->kind == v__table__Kind_interface_ && (*(v__table__Type*)/*ee elem_typ */array_get(node.types, 0)) != g->fn_decl->return_type;
		if (cast_interface) {
			v__gen__Gen_interface_call(g, (*(v__table__Type*)/*ee elem_typ */array_get(node.types, 0)), g->fn_decl->return_type);
		}
		v__gen__Gen_expr_with_cast(g, (*(v__ast__Expr*)/*ee elem_typ */array_get(node.exprs, 0)), (*(v__table__Type*)/*ee elem_typ */array_get(node.types, 0)), g->fn_decl->return_type);
		if (cast_interface) {
			v__gen__Gen_write(g, tos_lit(")"));
		}
		if (v_free) {
			v__gen__Gen_writeln(g, tos_lit("; // free tmp exprs"));
			v__gen__Gen_autofree_scope_vars(g, node.pos.pos + 1, node.pos.line_nr, true);
			v__gen__Gen_write(g, _STR("return %.*s", 1, tmp));
		}
	} else {
		v__gen__Gen_write(g, tos_lit("return"));
	}
	v__gen__Gen_writeln(g, tos_lit(";"));
// Defer begin
g->inside_return = false;
// Defer end
}

VV_LOCAL_SYMBOL void v__gen__Gen_const_decl(v__gen__Gen* g, v__ast__ConstDecl node) {
	g->inside_const = true;
	// FOR IN array
	array _t1426 = node.fields;
	for (int _t1427 = 0; _t1427 < _t1426.len; ++_t1427) {
		v__ast__ConstField field = ((v__ast__ConstField*)_t1426.data)[_t1427];
		string name = v__gen__c_name(field.name);
		int pos = g->out.len;
		v__gen__Gen_expr(g, field.expr);
		string val = strings__Builder_after(&g->out, pos);
		strings__Builder_go_back(&g->out, val.len);
		v__ast__Expr _t1428 = field.expr;
		if (_t1428.typ == 218 /* v.ast.CharLiteral */) {
			v__gen__Gen_const_decl_simple_define(g, name, val);
		} else if (_t1428.typ == 223 /* v.ast.FloatLiteral */) {
			v__gen__Gen_const_decl_simple_define(g, name, val);
		} else if (_t1428.typ == 229 /* v.ast.IntegerLiteral */) {
			v__gen__Gen_const_decl_simple_define(g, name, val);
		} else if (_t1428.typ == 209 /* v.ast.ArrayInit */) {
			if ((*field.expr._209).is_fixed) {
				string styp = v__gen__Gen_typ(g, (*field.expr._209).typ);
				strings__Builder_writeln(&g->definitions, _STR("%.*s\000 _const_%.*s\000 = %.*s\000; // fixed array const", 4, styp, name, val));
			} else {
				v__gen__Gen_const_decl_init_later(g, field.mod, name, val, field.typ);
			}
		} else if (_t1428.typ == 245 /* v.ast.StringLiteral */) {
			strings__Builder_writeln(&g->definitions, _STR("string _const_%.*s\000; // a string literal, inited later", 2, name));
			if (g->pref->build_mode != v__pref__BuildMode_build_module) {
				strings__Builder_writeln(&g->stringliterals, _STR("\t_const_%.*s\000 = %.*s\000;", 3, name, val));
			}
		} else {
			v__gen__Gen_const_decl_init_later(g, field.mod, name, val, field.typ);
		};
	}
// Defer begin
g->inside_const = false;
// Defer end
}

VV_LOCAL_SYMBOL void v__gen__Gen_const_decl_simple_define(v__gen__Gen* g, string name, string val) {
	strings__Builder_write(&g->definitions, _STR("#define _const_%.*s\000 ", 2, name));
	strings__Builder_writeln(&g->definitions, val);
}

VV_LOCAL_SYMBOL void v__gen__Gen_const_decl_init_later(v__gen__Gen* g, string mod, string name, string val, v__table__Type typ) {
	string styp = v__gen__Gen_typ(g, typ);
	string cname = _STR("_const_%.*s", 1, name);
	strings__Builder_writeln(&g->definitions, _STR("%.*s\000 %.*s\000; // inited later", 3, styp, cname));
	strings__Builder_writeln(&(*(strings__Builder*)map_get(g->inits, mod, &(strings__Builder[]){ {0} })), _STR("\t%.*s\000 = %.*s\000;", 3, cname, val));
	if (g->pref->autofree) {
		if (string_starts_with(styp, tos_lit("array_"))) {
			strings__Builder_writeln(&(*(strings__Builder*)map_get(g->cleanups, mod, &(strings__Builder[]){ {0} })), _STR("\tarray_free(&%.*s\000);", 2, cname));
		}
		if (string_eq(styp, tos_lit("string"))) {
			strings__Builder_writeln(&(*(strings__Builder*)map_get(g->cleanups, mod, &(strings__Builder[]){ {0} })), _STR("\tstring_free(&%.*s\000);", 2, cname));
		}
	}
}

VV_LOCAL_SYMBOL void v__gen__Gen_global_decl(v__gen__Gen* g, v__ast__GlobalDecl node) {
	// FOR IN array
	array _t1429 = node.fields;
	for (int _t1430 = 0; _t1430 < _t1429.len; ++_t1430) {
		v__ast__GlobalField field = ((v__ast__GlobalField*)_t1429.data)[_t1430];
		string styp = v__gen__Gen_typ(g, field.typ);
		if (field.has_expr) {
			strings__Builder_writeln(&g->definitions, _STR("%.*s\000 %.*s\000 = %.*s\000; // global", 4, styp, field.name, v__ast__Expr_str(field.expr)));
		} else {
			strings__Builder_writeln(&g->definitions, _STR("%.*s\000 %.*s\000; // global", 3, styp, field.name));
		}
	}
}

VV_LOCAL_SYMBOL void v__gen__Gen_go_back_out(v__gen__Gen* g, int n) {
	strings__Builder_go_back(&g->out, n);
}

VV_LOCAL_SYMBOL void v__gen__Gen_struct_init(v__gen__Gen* g, v__ast__StructInit struct_init) {
	string styp = v__gen__Gen_typ(g, struct_init.typ);
	string shared_styp = tos_lit("");
	if (_IN(string, styp, _const_v__gen__skip_struct_init)) {
		v__gen__Gen_go_back_out(g, 3);
		return;
	}
	v__table__TypeSymbol* sym = v__table__Table_get_final_type_symbol(g->table, struct_init.typ);
	bool is_amp = g->is_amp;
	bool is_multiline = struct_init.fields.len > 5;
	g->is_amp = false;
	if (is_amp) {
		strings__Builder_go_back(&g->out, 1);
		if (g->is_shared) {
			v__table__Type shared_typ = v__table__Type_set_flag(struct_init.typ, v__table__TypeFlag_shared_f);
			shared_styp = v__gen__Gen_typ(g, shared_typ);
			v__gen__Gen_writeln(g, _STR("(%.*s\000*)memdup(&(%.*s\000){.val = (%.*s\000){", 4, shared_styp, shared_styp, styp));
		} else {
			v__gen__Gen_write(g, _STR("(%.*s\000*)memdup(&(%.*s\000){", 3, styp, styp));
		}
	} else {
		if (g->is_shared) {
			v__gen__Gen_writeln(g, tos_lit("{.val = {"));
		} else if (is_multiline) {
			v__gen__Gen_writeln(g, _STR("(%.*s\000){", 2, styp));
		} else {
			v__gen__Gen_write(g, _STR("(%.*s\000){", 2, styp));
		}
	}
	map_string_int inited_fields = new_map_1(sizeof(int));
	if (is_multiline) {
		g->indent++;
	}
	bool initialized = false;
	// FOR IN array
	array _t1431 = struct_init.fields;
	for (int i = 0; i < _t1431.len; ++i) {
		v__ast__StructInitField field = ((v__ast__StructInitField*)_t1431.data)[i];
		map_set(&inited_fields, field.name, &(int[]) { i });
		if ((sym->info).typ == 155 /* v.table.Struct */) {

int _t1432_len = (*sym->info._155).fields.len;
			array_v__table__Field _t1432 = __new_array(0, _t1432_len, sizeof(v__table__Field));
			for (int i = 0; i < _t1432_len; ++i) {
			  v__table__Field it = ((v__table__Field*) (*sym->info._155).fields.data)[i];
			if (string_eq(it.name, field.name)) array_push(&_t1432, &it); 
 }
						array_v__table__Field equal_fields =  _t1432;
			if (equal_fields.len == 0) {
				continue;
			}
			v__table__Field tfield = (*(v__table__Field*)/*ee elem_typ */array_get(equal_fields, 0));
			if (tfield.embed_alias_for.len != 0) {
				continue;
			}
		}
		if (sym->kind != v__table__Kind_struct_) {
			string field_name = v__gen__c_name(field.name);
			v__gen__Gen_write(g, _STR(".%.*s\000 = ", 2, field_name));
			if (field.typ == 0) {
				v__gen__Gen_checker_bug(g, tos_lit("struct init, field.typ is 0"), field.pos);
			}
			v__table__TypeSymbol* field_type_sym = v__table__Table_get_type_symbol(g->table, field.typ);
			bool cloned = false;
			if (g->autofree && !v__table__Type_is_ptr(field.typ) && (field_type_sym->kind == v__table__Kind_array || field_type_sym->kind == v__table__Kind_string)) {
				v__gen__Gen_write(g, tos_lit("/*clone1*/"));
				if (v__gen__Gen_gen_clone_assignment(g, field.expr, *field_type_sym, false)) {
					cloned = true;
				}
			}
			if (!cloned) {
				if (v__table__Type_is_ptr(field.expected_type) && !(v__table__Type_is_ptr(field.typ) || v__table__Type_is_pointer(field.typ)) && !v__table__Type_is_number(field.typ)) {
					v__gen__Gen_write(g, tos_lit("/* autoref */&"));
				}
				v__gen__Gen_expr_with_cast(g, field.expr, field.typ, field.expected_type);
			}
			if (i != struct_init.fields.len - 1) {
				if (is_multiline) {
					v__gen__Gen_writeln(g, tos_lit(","));
				} else {
					v__gen__Gen_write(g, tos_lit(", "));
				}
			}
			initialized = true;
		}
	}
	if (sym->kind == v__table__Kind_struct_) {
		v__table__Struct info = /* as */ *(v__table__Struct*)__as_cast((sym->info)._155, (sym->info).typ, /*expected:*/155);
		if (info.is_union && struct_init.fields.len > 1) {
			v__gen__verror(tos_lit("union must not have more than 1 initializer"));
		}
		// FOR IN array
		array _t1433 = info.fields;
		for (int _t1434 = 0; _t1434 < _t1433.len; ++_t1434) {
			v__table__Field field = ((v__table__Field*)_t1433.data)[_t1434];
			if ((sym->info).typ == 155 /* v.table.Struct */) {

int _t1435_len = (*sym->info._155).fields.len;
				array_v__table__Field _t1435 = __new_array(0, _t1435_len, sizeof(v__table__Field));
				for (int i = 0; i < _t1435_len; ++i) {
				  v__table__Field it = ((v__table__Field*) (*sym->info._155).fields.data)[i];
				if (string_eq(it.name, field.name)) array_push(&_t1435, &it); 
 }
								array_v__table__Field equal_fields =  _t1435;
				if (equal_fields.len == 0) {
					continue;
				}
				v__table__Field tfield = (*(v__table__Field*)/*ee elem_typ */array_get(equal_fields, 0));
				if (tfield.embed_alias_for.len != 0) {
					continue;
				}
			}
			if (_IN_MAP(field.name, inited_fields)) {
				v__ast__StructInitField sfield = (*(v__ast__StructInitField*)/*ee elem_typ */array_get(struct_init.fields, (*(int*)map_get(inited_fields, field.name, &(int[]){ 0 }))));
				string field_name = v__gen__c_name(sfield.name);
				v__gen__Gen_write(g, _STR(".%.*s\000 = ", 2, field_name));
				v__table__TypeSymbol* field_type_sym = v__table__Table_get_type_symbol(g->table, sfield.typ);
				bool cloned = false;
				if (g->autofree && !v__table__Type_is_ptr(sfield.typ) && (field_type_sym->kind == v__table__Kind_array || field_type_sym->kind == v__table__Kind_string)) {
					v__gen__Gen_write(g, tos_lit("/*clone1*/"));
					if (v__gen__Gen_gen_clone_assignment(g, sfield.expr, *field_type_sym, false)) {
						cloned = true;
					}
				}
				if (!cloned) {
					if (v__table__Type_is_ptr(sfield.expected_type) && !(v__table__Type_is_ptr(sfield.typ) || v__table__Type_is_pointer(sfield.typ)) && !v__table__Type_is_number(sfield.typ)) {
						v__gen__Gen_write(g, tos_lit("/* autoref */&"));
					}
					v__gen__Gen_expr_with_cast(g, sfield.expr, sfield.typ, sfield.expected_type);
				}
				if (is_multiline) {
					v__gen__Gen_writeln(g, tos_lit(","));
				} else {
					v__gen__Gen_write(g, tos_lit(","));
				}
				initialized = true;
				continue;
			}
			if (info.is_union) {
				continue;
			}
			if (v__table__Type_has_flag(field.typ, v__table__TypeFlag_optional)) {
				continue;
			}
			v__gen__Gen_zero_struct_field(g, field);
			if (is_multiline) {
				v__gen__Gen_writeln(g, tos_lit(","));
			} else {
				v__gen__Gen_write(g, tos_lit(","));
			}
			initialized = true;
		}
	}
	if (is_multiline) {
		g->indent--;
	}
	if (!initialized) {
		v__gen__Gen_write(g, tos_lit("\n#ifndef __cplusplus\n0\n#endif\n"));
	}
	v__gen__Gen_write(g, tos_lit("}"));
	if (g->is_shared) {
		v__gen__Gen_write(g, tos_lit(", .mtx = sync__new_rwmutex()}"));
		if (is_amp) {
			v__gen__Gen_write(g, _STR(", sizeof(%.*s\000))", 2, shared_styp));
		}
	} else if (is_amp) {
		v__gen__Gen_write(g, _STR(", sizeof(%.*s\000))", 2, styp));
	}
}

VV_LOCAL_SYMBOL void v__gen__Gen_zero_struct_field(v__gen__Gen* g, v__table__Field field) {
	string field_name = v__gen__c_name(field.name);
	v__gen__Gen_write(g, _STR(".%.*s\000 = ", 2, field_name));
	if (field.has_default_expr) {
		v__gen__Gen_expr(g, v__ast__fe2ex(field.default_expr));
	} else {
		v__gen__Gen_write(g, v__gen__Gen_type_default(g, field.typ));
	}
}

VV_LOCAL_SYMBOL void v__gen__Gen_assoc(v__gen__Gen* g, v__ast__Assoc node) {
	v__gen__Gen_writeln(g, tos_lit("// assoc"));
	if (node.typ == 0) {
		return;
	}
	string styp = v__gen__Gen_typ(g, node.typ);
	v__gen__Gen_writeln(g, _STR("(%.*s\000){", 2, styp));
	map_string_int inited_fields = new_map_1(sizeof(int));
	// FOR IN array
	array _t1436 = node.fields;
	for (int i = 0; i < _t1436.len; ++i) {
		string field = ((string*)_t1436.data)[i];
		map_set(&inited_fields, field, &(int[]) { i });
	}
	v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, node.typ);
	v__table__Struct info = /* as */ *(v__table__Struct*)__as_cast((sym->info)._155, (sym->info).typ, /*expected:*/155);
	// FOR IN array
	array _t1437 = info.fields;
	for (int _t1438 = 0; _t1438 < _t1437.len; ++_t1438) {
		v__table__Field field = ((v__table__Field*)_t1437.data)[_t1438];
		string field_name = v__gen__c_name(field.name);
		if (_IN_MAP(field.name, inited_fields)) {
			v__gen__Gen_write(g, _STR("\t.%.*s\000 = ", 2, field_name));
			v__gen__Gen_expr(g, (*(v__ast__Expr*)/*ee elem_typ */array_get(node.exprs, (*(int*)map_get(inited_fields, field.name, &(int[]){ 0 })))));
			v__gen__Gen_writeln(g, tos_lit(", "));
		} else {
			v__gen__Gen_writeln(g, _STR("\t.%.*s\000 = %.*s\000.%.*s\000,", 4, field_name, node.var_name, field_name));
		}
	}
	v__gen__Gen_write(g, tos_lit("}"));
	if (g->is_amp) {
		v__gen__Gen_write(g, _STR(", sizeof(%.*s\000))", 2, styp));
	}
}

VV_LOCAL_SYMBOL string v__gen__Gen_gen_array_equality_fn(v__gen__Gen* g, v__table__Type left) {
	v__table__TypeSymbol* left_sym = v__table__Table_get_type_symbol(g->table, left);
	string typ_name = v__gen__Gen_typ(g, left);
	string ptr_typ = string_trim(string_substr(typ_name, string_index_after(typ_name, tos_lit("_"), 0) + 1, typ_name.len), tos_lit("*"));
	v__table__TypeSymbol* elem_sym = v__table__Table_get_type_symbol(g->table, v__table__TypeSymbol_array_info(left_sym).elem_type);
	string elem_typ = v__gen__Gen_typ(g, v__table__TypeSymbol_array_info(left_sym).elem_type);
	string ptr_elem_typ = string_substr(elem_typ, string_index_after(elem_typ, tos_lit("_"), 0) + 1, elem_typ.len);
	if (elem_sym->kind == v__table__Kind_array) {
		v__gen__Gen_gen_array_equality_fn(g, v__table__TypeSymbol_array_info(left_sym).elem_type);
	}
	if (_IN(string, ptr_typ, g->array_fn_definitions)) {
		return ptr_typ;
	}
	array_push(&g->array_fn_definitions, _MOV((string[]){ string_clone(ptr_typ) }));
	strings__Builder_writeln(&g->definitions, _STR("bool %.*s\000_arr_eq(array_%.*s\000 a, array_%.*s\000 b) {", 4, ptr_typ, ptr_typ, ptr_typ));
	strings__Builder_writeln(&g->definitions, tos_lit("\tif (a.len != b.len) {"));
	strings__Builder_writeln(&g->definitions, tos_lit("\t\treturn false;"));
	strings__Builder_writeln(&g->definitions, tos_lit("\t}"));
	strings__Builder_writeln(&g->definitions, tos_lit("\tfor (int i = 0; i < a.len; ++i) {"));
	v__table__Kind _t1440 = elem_sym->kind;
	if (_t1440 == v__table__Kind_string) {
		strings__Builder_writeln(&g->definitions, _STR("\t\tif (string_ne(*((%.*s\000*)((byte*)a.data+(i*a.element_size))), *((%.*s\000*)((byte*)b.data+(i*b.element_size))))) {", 3, ptr_typ, ptr_typ));
	} else if (_t1440 == v__table__Kind_struct_) {
		strings__Builder_writeln(&g->definitions, tos_lit("\t\tif (memcmp((byte*)a.data+(i*a.element_size), (byte*)b.data+(i*b.element_size), a.element_size)) {"));
	} else if (_t1440 == v__table__Kind_array) {
		strings__Builder_writeln(&g->definitions, _STR("\t\tif (!%.*s\000_arr_eq(((%.*s\000*)a.data)[i], ((%.*s\000*)b.data)[i])) {", 4, ptr_elem_typ, elem_typ, elem_typ));
	} else if (_t1440 == v__table__Kind_function) {
		strings__Builder_writeln(&g->definitions, tos_lit("\t\tif (*((voidptr*)((byte*)a.data+(i*a.element_size))) != *((voidptr*)((byte*)b.data+(i*b.element_size)))) {"));
	} else {
		strings__Builder_writeln(&g->definitions, _STR("\t\tif (*((%.*s\000*)((byte*)a.data+(i*a.element_size))) != *((%.*s\000*)((byte*)b.data+(i*b.element_size)))) {", 3, ptr_typ, ptr_typ));
	};
	strings__Builder_writeln(&g->definitions, tos_lit("\t\t\treturn false;"));
	strings__Builder_writeln(&g->definitions, tos_lit("\t\t}"));
	strings__Builder_writeln(&g->definitions, tos_lit("\t}"));
	strings__Builder_writeln(&g->definitions, tos_lit("\treturn true;"));
	strings__Builder_writeln(&g->definitions, tos_lit("}"));
	return ptr_typ;
}

VV_LOCAL_SYMBOL string v__gen__Gen_gen_map_equality_fn(v__gen__Gen* g, v__table__Type left) {
	v__table__TypeSymbol* left_sym = v__table__Table_get_type_symbol(g->table, left);
	string typ_name = v__gen__Gen_typ(g, left);
	string ptr_typ = string_trim(string_substr(typ_name, string_index_after(typ_name, tos_lit("_"), 0) + 1, typ_name.len), tos_lit("*"));
	v__table__TypeSymbol* value_sym = v__table__Table_get_type_symbol(g->table, v__table__TypeSymbol_map_info(left_sym).value_type);
	string value_typ = v__gen__Gen_typ(g, v__table__TypeSymbol_map_info(left_sym).value_type);
	if (value_sym->kind == v__table__Kind_map) {
		v__gen__Gen_gen_map_equality_fn(g, v__table__TypeSymbol_map_info(left_sym).value_type);
	}
	if (_IN(string, ptr_typ, g->map_fn_definitions)) {
		return ptr_typ;
	}
	array_push(&g->map_fn_definitions, _MOV((string[]){ string_clone(ptr_typ) }));
	strings__Builder_writeln(&g->definitions, _STR("bool %.*s\000_map_eq(map_%.*s\000 a, map_%.*s\000 b) {", 4, ptr_typ, ptr_typ, ptr_typ));
	strings__Builder_writeln(&g->definitions, tos_lit("\tif (a.len != b.len) {"));
	strings__Builder_writeln(&g->definitions, tos_lit("\t\treturn false;"));
	strings__Builder_writeln(&g->definitions, tos_lit("\t}"));
	strings__Builder_writeln(&g->definitions, tos_lit("\tarray_string _keys = map_keys(&a);"));
	strings__Builder_writeln(&g->definitions, tos_lit("\tfor (int i = 0; i < _keys.len; ++i) {"));
	strings__Builder_writeln(&g->definitions, tos_lit("\t\tstring k = string_clone( ((string*)_keys.data)[i]);"));
	if (value_sym->kind == v__table__Kind_function) {
		v__table__FnType func = /* as */ *(v__table__FnType*)__as_cast((value_sym->info)._353, (value_sym->info).typ, /*expected:*/353);
		string ret_styp = v__gen__Gen_typ(g, func.func.return_type);
		strings__Builder_write(&g->definitions, _STR("\t\t%.*s\000 (*v) (", 2, ret_styp));
		int arg_len = func.func.params.len;
		// FOR IN array
		array _t1442 = func.func.params;
		for (int i = 0; i < _t1442.len; ++i) {
			v__table__Param arg = ((v__table__Param*)_t1442.data)[i];
			string arg_styp = v__gen__Gen_typ(g, arg.typ);
			strings__Builder_write(&g->definitions, _STR("%.*s\000 %.*s", 2, arg_styp, arg.name));
			if (i < arg_len - 1) {
				strings__Builder_write(&g->definitions, tos_lit(", "));
			}
		}
		strings__Builder_writeln(&g->definitions, tos_lit(") = (*(voidptr*)map_get(a, k, &(voidptr[]){ 0 }));"));
	} else {
		strings__Builder_writeln(&g->definitions, _STR("\t\t%.*s\000 v = (*(%.*s\000*)map_get(a, k, &(%.*s\000[]){ 0 }));", 4, value_typ, value_typ, value_typ));
	}
	v__table__Kind _t1443 = value_sym->kind;
	if (_t1443 == v__table__Kind_string) {
		strings__Builder_writeln(&g->definitions, _STR("\t\tif (!map_exists(b, k) || string_ne((*(%.*s\000*)map_get(b, k, &(%.*s\000[]){tos_lit(\"\")})), v)) {", 3, value_typ, value_typ));
	} else if (_t1443 == v__table__Kind_function) {
		strings__Builder_writeln(&g->definitions, tos_lit("\t\tif (!map_exists(b, k) || (*(voidptr*)map_get(b, k, &(voidptr[]){ 0 })) != v) {"));
	} else {
		strings__Builder_writeln(&g->definitions, _STR("\t\tif (!map_exists(b, k) || (*(%.*s\000*)map_get(b, k, &(%.*s\000[]){ 0 })) != v) {", 3, value_typ, value_typ));
	};
	strings__Builder_writeln(&g->definitions, tos_lit("\t\t\treturn false;"));
	strings__Builder_writeln(&g->definitions, tos_lit("\t\t}"));
	strings__Builder_writeln(&g->definitions, tos_lit("\t}"));
	strings__Builder_writeln(&g->definitions, tos_lit("\treturn true;"));
	strings__Builder_writeln(&g->definitions, tos_lit("}"));
	return ptr_typ;
}

VV_LOCAL_SYMBOL void v__gen__verror(string s) {
	v__util__verror(tos_lit("cgen error"), s);
}

VV_LOCAL_SYMBOL void v__gen__Gen_error(v__gen__Gen* g, string s, v__token__Position pos) {
	string ferror = v__util__formatted_error(tos_lit("cgen error:"), s, g->file.path, pos);
	eprintln(ferror);
	v_exit(1);
}

VV_LOCAL_SYMBOL void v__gen__Gen_checker_bug(v__gen__Gen* g, string s, v__token__Position pos) {
	v__gen__Gen_error(g, _STR("checker bug; %.*s", 1, s), pos);
}

VV_LOCAL_SYMBOL void v__gen__Gen_write_init_function(v__gen__Gen* g) {
	if (g->pref->is_liveshared) {
		return;
	}
	int fn_vinit_start_pos = g->out.len;
	bool needs_constructor = g->pref->is_shared && g->pref->os != v__pref__OS_windows;
	if (needs_constructor) {
		v__gen__Gen_writeln(g, tos_lit("__attribute__ ((constructor))"));
		v__gen__Gen_writeln(g, tos_lit("void _vinit() {"));
		v__gen__Gen_writeln(g, tos_lit("static bool once = false; if (once) {return;} once = true;"));
	} else {
		v__gen__Gen_writeln(g, tos_lit("void _vinit() {"));
	}
	if (g->pref->autofree) {
	}
	if (g->pref->prealloc) {
		v__gen__Gen_writeln(g, tos_lit("g_m2_buf = malloc(50 * 1000 * 1000);"));
		v__gen__Gen_writeln(g, tos_lit("g_m2_ptr = g_m2_buf;"));
	}
	v__gen__Gen_writeln(g, tos_lit("\tbuiltin_init();"));
	v__gen__Gen_writeln(g, tos_lit("\tvinit_string_literals();"));
	// FOR IN array
	array _t1444 = g->table->modules;
	for (int _t1445 = 0; _t1445 < _t1444.len; ++_t1445) {
		string mod_name = ((string*)_t1444.data)[_t1445];
		v__gen__Gen_writeln(g, _STR("\t// Initializations for module %.*s\000 :", 2, mod_name));
		v__gen__Gen_write(g, strings__Builder_str(&(*(strings__Builder*)map_get(g->inits, mod_name, &(strings__Builder[]){ {0} }))));
		string init_fn_name = _STR("%.*s\000.init", 2, mod_name);
		{ /* if guard */ 
		Option_v__table__Fn _t1446;
		if (_t1446 = v__table__Table_find_fn(g->table, init_fn_name), _t1446.ok) {
			v__table__Fn initfn = *(v__table__Fn*)_t1446.data;
			if (initfn.return_type == _const_v__table__void_type && initfn.params.len == 0) {
				string mod_c_name = v__util__no_dots(mod_name);
				string init_fn_c_name = _STR("%.*s\000__init", 2, mod_c_name);
				v__gen__Gen_writeln(g, _STR("\t%.*s\000();", 2, init_fn_c_name));
			}
		}}
	}
	v__gen__Gen_writeln(g, tos_lit("}"));
	if (g->pref->printfn_list.len > 0 && _IN(string, tos_lit("_vinit"), g->pref->printfn_list)) {
		println(strings__Builder_after(&g->out, fn_vinit_start_pos));
	}
	if (g->autofree) {
		int fn_vcleanup_start_pos = g->out.len;
		v__gen__Gen_writeln(g, tos_lit("void _vcleanup() {"));
		array_string reversed_table_modules = array_reverse(g->table->modules);
		// FOR IN array
		array _t1447 = reversed_table_modules;
		for (int _t1448 = 0; _t1448 < _t1447.len; ++_t1448) {
			string mod_name = ((string*)_t1447.data)[_t1448];
			v__gen__Gen_writeln(g, _STR("\t// Cleanups for module %.*s\000 :", 2, mod_name));
			v__gen__Gen_writeln(g, strings__Builder_str(&(*(strings__Builder*)map_get(g->cleanups, mod_name, &(strings__Builder[]){ {0} }))));
		}
		v__gen__Gen_writeln(g, tos_lit("}"));
		if (g->pref->printfn_list.len > 0 && _IN(string, tos_lit("_vcleanup"), g->pref->printfn_list)) {
			println(strings__Builder_after(&g->out, fn_vcleanup_start_pos));
		}
	}
}

VV_LOCAL_SYMBOL void v__gen__Gen_write_builtin_types(v__gen__Gen* g) {
	array_v__table__TypeSymbol builtin_types = __new_array_with_default(0, 0, sizeof(v__table__TypeSymbol), 0);
	// FOR IN array
	array _t1449 = _const_v__gen__builtins;
	for (int _t1450 = 0; _t1450 < _t1449.len; ++_t1450) {
		string builtin_name = ((string*)_t1449.data)[_t1450];
		array_push(&builtin_types, _MOV((v__table__TypeSymbol[]){ (*(v__table__TypeSymbol*)/*ee elem_typ */array_get(g->table->types, (*(int*)map_get_and_set(&g->table->type_idxs, builtin_name, &(int[]){ 0 })))) }));
	}
	v__gen__Gen_write_types(g, builtin_types);
}

VV_LOCAL_SYMBOL void v__gen__Gen_write_sorted_types(v__gen__Gen* g) {
	array_v__table__TypeSymbol types = __new_array_with_default(0, 0, sizeof(v__table__TypeSymbol), 0);
	// FOR IN array
	array _t1452 = g->table->types;
	for (int _t1453 = 0; _t1453 < _t1452.len; ++_t1453) {
		v__table__TypeSymbol typ = ((v__table__TypeSymbol*)_t1452.data)[_t1453];
		if (!_IN(string, typ.name, _const_v__gen__builtins)) {
			array_push(&types, _MOV((v__table__TypeSymbol[]){ typ }));
		}
	}
	array_v__table__TypeSymbol types_sorted = v__gen__Gen_sort_structs(g, types);
	strings__Builder_writeln(&g->type_definitions, tos_lit("// builtin types:"));
	strings__Builder_writeln(&g->type_definitions, tos_lit("//------------------ #endbuiltin"));
	v__gen__Gen_write_types(g, types_sorted);
}

VV_LOCAL_SYMBOL void v__gen__Gen_write_types(v__gen__Gen* g, array_v__table__TypeSymbol types) {
	// FOR IN array
	array _t1455 = types;
	for (int _t1456 = 0; _t1456 < _t1455.len; ++_t1456) {
		v__table__TypeSymbol typ = ((v__table__TypeSymbol*)_t1455.data)[_t1456];
		if (string_starts_with(typ.name, tos_lit("C."))) {
			continue;
		}
		string name = v__util__no_dots(typ.name);
		v__table__TypeInfo _t1457 = typ.info;
		if (_t1457.typ == 155 /* v.table.Struct */) {
			if ((*typ.info._155).generic_types.len > 0) {
				continue;
			}
			if (string_contains(name, tos_lit("<"))) {
				name = string_replace_each(name, new_array_from_c_array(6, 6, sizeof(string), _MOV((string[6]){tos_lit("<"), tos_lit("_T_"), tos_lit(">"), tos_lit(""), tos_lit(","), tos_lit("_")})));
				strings__Builder_writeln(&g->typedefs, _STR("typedef struct %.*s\000 %.*s\000;", 3, name, name));
			}
			int start_pos = g->type_definitions.len;
			if ((*typ.info._155).is_union) {
				strings__Builder_writeln(&g->type_definitions, _STR("union %.*s\000 {", 2, name));
			} else {
				strings__Builder_writeln(&g->type_definitions, _STR("struct %.*s\000 {", 2, name));
			}
			if ((*typ.info._155).fields.len > 0) {

int _t1459_len = (*typ.info._155).fields.len;
				array_v__table__Field _t1459 = __new_array(0, _t1459_len, sizeof(v__table__Field));
				for (int i = 0; i < _t1459_len; ++i) {
				  v__table__Field it = ((v__table__Field*) (*typ.info._155).fields.data)[i];
				if ((it.embed_alias_for).len == 0) array_push(&_t1459, &it); 
 }
								// FOR IN array
				array _t1458 =  _t1459;
				for (int _t1460 = 0; _t1460 < _t1458.len; ++_t1460) {
					v__table__Field field = ((v__table__Field*)_t1458.data)[_t1460];
					if (v__table__Type_has_flag(field.typ, v__table__TypeFlag_optional)) {
						string last_text = string_clone(strings__Builder_after(&g->type_definitions, start_pos));
						strings__Builder_go_back_to(&g->type_definitions, start_pos);
						multi_return_string_string mr_130981 = v__gen__Gen_optional_type_name(g, field.typ);
						string styp = mr_130981.arg0;
						string base = mr_130981.arg1;
						array_push(&g->optionals, _MOV((string[]){ string_clone(styp) }));
						strings__Builder_writeln(&g->typedefs2, _STR("typedef struct %.*s\000 %.*s\000;", 3, styp, styp));
						strings__Builder_writeln(&g->type_definitions, _STR("%.*s\000;", 2, v__gen__Gen_optional_type_text(g, styp, base)));
						strings__Builder_write(&g->type_definitions, last_text);
					}
					string type_name = v__gen__Gen_typ(g, field.typ);
					string field_name = v__gen__c_name(field.name);
					strings__Builder_writeln(&g->type_definitions, _STR("\t%.*s\000 %.*s\000;", 3, type_name, field_name));
				}
			} else {
				strings__Builder_writeln(&g->type_definitions, tos_lit("EMPTY_STRUCT_DECLARATION;"));
			}
			strings__Builder_writeln(&g->type_definitions, tos_lit("};\n"));
		} else if (_t1457.typ == 347 /* v.table.Alias */) {
		} else if (_t1457.typ == 354 /* v.table.SumType */) {
			strings__Builder_writeln(&g->typedefs, _STR("typedef struct %.*s\000 %.*s\000;", 3, name, name));
			strings__Builder_writeln(&g->type_definitions, tos_lit(""));
			strings__Builder_writeln(&g->type_definitions, _STR("// Union sum type %.*s\000 = ", 2, name));
			// FOR IN array
			array _t1462 = (*typ.info._354).variants;
			for (int _t1463 = 0; _t1463 < _t1462.len; ++_t1463) {
				v__table__Type variant = ((v__table__Type*)_t1462.data)[_t1463];
				strings__Builder_writeln(&g->type_definitions, _STR("//          | %4"PRId32"\000 = %*.*s", 2, variant, v__gen__Gen_typ(g, v__table__Type_idx(variant)), -20));
			}
			strings__Builder_writeln(&g->type_definitions, _STR("struct %.*s\000 {", 2, name));
			strings__Builder_writeln(&g->type_definitions, tos_lit("    union {"));
			// FOR IN array
			array _t1464 = (*typ.info._354).variants;
			for (int _t1465 = 0; _t1465 < _t1464.len; ++_t1465) {
				v__table__Type variant = ((v__table__Type*)_t1464.data)[_t1465];
				strings__Builder_writeln(&g->type_definitions, _STR("        %.*s\000 _%"PRId32"\000;", 3, v__gen__Gen_typ(g, v__table__Type_to_ptr(variant)), v__table__Type_idx(variant)));
			}
			strings__Builder_writeln(&g->type_definitions, tos_lit("    };"));
			strings__Builder_writeln(&g->type_definitions, tos_lit("    int typ;"));
			strings__Builder_writeln(&g->type_definitions, tos_lit("};"));
			strings__Builder_writeln(&g->type_definitions, tos_lit(""));
		} else if (_t1457.typ == 351 /* v.table.ArrayFixed */) {
			string styp = v__util__no_dots(typ.name);
			string fixed = string_substr(styp, 12, styp.len);
			string len = string_after(styp, tos_lit("_"));
			fixed = string_substr(fixed, 0, fixed.len - len.len - 1);
			if (string_starts_with(fixed, tos_lit("C__"))) {
				fixed = string_substr(fixed, 3, fixed.len);
			}
			strings__Builder_writeln(&g->type_definitions, _STR("typedef %.*s\000 %.*s\000 [%.*s\000];", 4, fixed, styp, len));
		} else {
		};
	}
}

VV_LOCAL_SYMBOL array_v__table__TypeSymbol v__gen__Gen_sort_structs(v__gen__Gen* g, array_v__table__TypeSymbol typesa) {
	v__depgraph__DepGraph* dep_graph = v__depgraph__new_dep_graph();
	array_string type_names = __new_array_with_default(0, 0, sizeof(string), 0);
	// FOR IN array
	array _t1466 = typesa;
	for (int _t1467 = 0; _t1467 < _t1466.len; ++_t1467) {
		v__table__TypeSymbol typ = ((v__table__TypeSymbol*)_t1466.data)[_t1467];
		array_push(&type_names, _MOV((string[]){ string_clone(typ.name) }));
	}
	// FOR IN array
	array _t1469 = typesa;
	for (int _t1470 = 0; _t1470 < _t1469.len; ++_t1470) {
		v__table__TypeSymbol t = ((v__table__TypeSymbol*)_t1469.data)[_t1470];
		if (t.kind == v__table__Kind_interface_) {
			v__depgraph__DepGraph_add(dep_graph, t.name, __new_array_with_default(0, 0, sizeof(string), 0));
			continue;
		}
		array_string field_deps = __new_array_with_default(0, 0, sizeof(string), 0);
		v__table__TypeInfo _t1471 = t.info;
		if (_t1471.typ == 351 /* v.table.ArrayFixed */) {
			string dep = v__table__Table_get_type_symbol(g->table, (*t.info._351).elem_type)->name;
			if (_IN(string, dep, type_names)) {
				array_push(&field_deps, _MOV((string[]){ string_clone(dep) }));
			}
		} else if (_t1471.typ == 155 /* v.table.Struct */) {
			// FOR IN array
			array _t1473 = (*t.info._155).fields;
			for (int _t1474 = 0; _t1474 < _t1473.len; ++_t1474) {
				v__table__Field field = ((v__table__Field*)_t1473.data)[_t1474];
				string dep = v__table__Table_get_type_symbol(g->table, field.typ)->name;
				if (!_IN(string, dep, type_names) || _IN(string, dep, field_deps) || v__table__Type_is_ptr(field.typ)) {
					continue;
				}
				array_push(&field_deps, _MOV((string[]){ string_clone(dep) }));
			}
		} else {
		};
		v__depgraph__DepGraph_add(dep_graph, t.name, field_deps);
	}
	v__depgraph__DepGraph* dep_graph_sorted = v__depgraph__DepGraph_resolve(dep_graph);
	if (!dep_graph_sorted->acyclic) {
		v__gen__verror(string_add(string_add(string_add(tos_lit("cgen.sort_structs(): the following structs form a dependency cycle:\n"), v__depgraph__DepGraph_display_cycles(dep_graph_sorted)), tos_lit("\nyou can solve this by making one or both of the dependant struct fields references, eg: field &MyStruct")), tos_lit("\nif you feel this is an error, please create a new issue here: https://github.com/vlang/v/issues and tag @joe-conigliaro")));
	}
	array_v__table__TypeSymbol types_sorted = __new_array_with_default(0, 0, sizeof(v__table__TypeSymbol), 0);
	// FOR IN array
	array _t1476 = dep_graph_sorted->nodes;
	for (int _t1477 = 0; _t1477 < _t1476.len; ++_t1477) {
		v__depgraph__DepGraphNode node = ((v__depgraph__DepGraphNode*)_t1476.data)[_t1477];
		array_push(&types_sorted, _MOV((v__table__TypeSymbol[]){ (*(v__table__TypeSymbol*)/*ee elem_typ */array_get(g->table->types, (*(int*)map_get_and_set(&g->table->type_idxs, node.name, &(int[]){ 0 })))) }));
	}
	return types_sorted;
}

VV_LOCAL_SYMBOL Option_bool v__gen__Gen_gen_expr_to_string(v__gen__Gen* g, v__ast__Expr expr, v__table__Type etype) {
	v__table__Type typ = etype;
	v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, typ);
	if ((sym->info).typ == 347 /* v.table.Alias */) {
		v__table__TypeSymbol* parent_sym = v__table__Table_get_type_symbol(g->table, (*sym->info._347).parent_type);
		if (v__table__TypeSymbol_has_method(parent_sym, tos_lit("str"))) {
			typ = (*sym->info._347).parent_type;
			sym = parent_sym;
		}
	}
	multi_return_bool_bool_int mr_134729 = v__table__TypeSymbol_str_method_info(sym);
	bool sym_has_str_method = mr_134729.arg0;
	bool str_method_expects_ptr = mr_134729.arg1;
	if (v__table__Type_has_flag(typ, v__table__TypeFlag_variadic)) {
		string str_fn_name = v__gen__Gen_gen_str_for_type(g, typ);
		v__gen__Gen_write(g, _STR("%.*s\000(", 2, str_fn_name));
		v__gen__Gen_expr(g, expr);
		v__gen__Gen_write(g, tos_lit(")"));
	} else if (typ == _const_v__table__string_type) {
		v__gen__Gen_expr(g, expr);
		Option_bool _t1479;
		opt_ok2(&(bool[]) { true }, (OptionBase*)(&_t1479), sizeof(bool));
		return _t1479;
	} else if (sym->kind == v__table__Kind_enum_) {
		v__ast__Expr _t1480 = expr;
				bool is_var = ((_t1480.typ == 241 /* v.ast.SelectorExpr */) ? (true) : (_t1480.typ == 224 /* v.ast.Ident */) ? (true) : (false));
		if (is_var) {
			string str_fn_name = v__gen__Gen_gen_str_for_type(g, typ);
			v__gen__Gen_write(g, _STR("%.*s\000(", 2, str_fn_name));
			v__gen__Gen_enum_expr(g, expr);
			v__gen__Gen_write(g, tos_lit(")"));
		} else {
			v__gen__Gen_write(g, tos_lit("tos_lit(\""));
			v__gen__Gen_enum_expr(g, expr);
			v__gen__Gen_write(g, tos_lit("\")"));
		}
	} else if (sym_has_str_method || (sym->kind == v__table__Kind_array || sym->kind == v__table__Kind_array_fixed || sym->kind == v__table__Kind_map || sym->kind == v__table__Kind_struct_ || sym->kind == v__table__Kind_multi_return || sym->kind == v__table__Kind_sum_type)) {
		bool is_p = v__table__Type_is_ptr(typ);
		v__table__Type val_type = (is_p ? (v__table__Type_deref(typ)) : (typ));
		string str_fn_name = v__gen__Gen_gen_str_for_type(g, val_type);
		if (is_p && str_method_expects_ptr) {
			v__gen__Gen_write(g, _STR("string_add(_SLIT(\"&\"), %.*s\000((", 2, str_fn_name));
		}
		if (is_p && !str_method_expects_ptr) {
			v__gen__Gen_write(g, _STR("string_add(_SLIT(\"&\"), %.*s\000(*(", 2, str_fn_name));
		}
		if (!is_p && !str_method_expects_ptr) {
			v__gen__Gen_write(g, _STR("%.*s\000(", 2, str_fn_name));
		}
		if (!is_p && str_method_expects_ptr) {
			v__gen__Gen_write(g, _STR("%.*s\000(&", 2, str_fn_name));
		}
		if ((expr).typ == 209 /* v.ast.ArrayInit */) {
			if ((*expr._209).is_fixed) {
				string s = v__gen__Gen_typ(g, (*expr._209).typ);
				v__gen__Gen_write(g, _STR("(%.*s\000)", 2, s));
			}
		}
		if ((expr).typ == 214 /* v.ast.CTempVar */) {
			if ((*expr._214).is_ptr) {
				v__gen__Gen_write(g, tos_lit("*"));
			}
		}
		v__gen__Gen_expr(g, expr);
		if (sym->kind == v__table__Kind_struct_ && !sym_has_str_method) {
			if (is_p) {
				v__gen__Gen_write(g, tos_lit(")))"));
			} else {
				v__gen__Gen_write(g, tos_lit(")"));
			}
		} else {
			if (is_p) {
				v__gen__Gen_write(g, tos_lit(")))"));
			} else {
				v__gen__Gen_write(g, tos_lit(")"));
			}
		}
	} else if (string_starts_with(v__gen__Gen_typ(g, typ), tos_lit("Option"))) {
		string str_fn_name = tos_lit("OptionBase_str");
		v__gen__Gen_write(g, _STR("%.*s\000(*(OptionBase*)&", 2, str_fn_name));
		v__gen__Gen_expr(g, expr);
		v__gen__Gen_write(g, tos_lit(")"));
	} else {
		string str_fn_name = v__gen__Gen_gen_str_for_type(g, typ);
		v__gen__Gen_write(g, _STR("%.*s\000(", 2, str_fn_name));
		v__gen__Gen_expr(g, expr);
		v__gen__Gen_write(g, tos_lit(")"));
	}
	Option_bool _t1481;
	opt_ok2(&(bool[]) { true }, (OptionBase*)(&_t1481), sizeof(bool));
	return _t1481;
}

VV_LOCAL_SYMBOL void v__gen__Gen_gen_array_map(v__gen__Gen* g, v__ast__CallExpr node) {
	g->inside_lambda = true;
	string tmp = v__gen__Gen_new_tmp_var(g);
	string s = v__gen__Gen_go_before_stmt(g, 0);
	string ret_typ = v__gen__Gen_typ(g, node.return_type);
	v__table__TypeSymbol* ret_sym = v__table__Table_get_type_symbol(g->table, node.return_type);
	v__table__TypeSymbol* inp_sym = v__table__Table_get_type_symbol(g->table, node.receiver_type);
	v__table__Array ret_info = /* as */ *(v__table__Array*)__as_cast((ret_sym->info)._350, (ret_sym->info).typ, /*expected:*/350);
	string ret_elem_type = v__gen__Gen_typ(g, ret_info.elem_type);
	v__table__Array inp_info = /* as */ *(v__table__Array*)__as_cast((inp_sym->info)._350, (inp_sym->info).typ, /*expected:*/350);
	string inp_elem_type = v__gen__Gen_typ(g, inp_info.elem_type);
	if (inp_sym->kind != v__table__Kind_array) {
		v__gen__verror(tos_lit("map() requires an array"));
	}
	v__gen__Gen_writeln(g, tos_lit(""));
	v__gen__Gen_write(g, _STR("int %.*s\000_len = ", 2, tmp));
	v__gen__Gen_expr(g, node.left);
	v__gen__Gen_writeln(g, tos_lit(".len;"));
	v__gen__Gen_writeln(g, _STR("%.*s\000 %.*s\000 = __new_array(0, %.*s\000_len, sizeof(%.*s\000));", 5, ret_typ, tmp, tmp, ret_elem_type));
	string i = v__gen__Gen_new_tmp_var(g);
	v__gen__Gen_writeln(g, _STR("for (int %.*s\000 = 0; %.*s\000 < %.*s\000_len; ++%.*s\000) {", 5, i, i, tmp, i));
	v__gen__Gen_write(g, _STR("\t%.*s\000 it = ((%.*s\000*) ", 3, inp_elem_type, inp_elem_type));
	v__gen__Gen_expr(g, node.left);
	v__gen__Gen_writeln(g, _STR(".data)[%.*s\000];", 2, i));
	v__gen__Gen_write(g, _STR("\t%.*s\000 ti = ", 2, ret_elem_type));
	v__ast__Expr expr = (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr;
	v__ast__Expr _t1482 = expr;
	if (_t1482.typ == 208 /* v.ast.AnonFn */) {
		v__gen__Gen_gen_anon_fn_decl(g, (*expr._208));
		v__gen__Gen_write(g, _STR("%.*s\000(it)", 2, (*expr._208).decl.name));
	} else if (_t1482.typ == 224 /* v.ast.Ident */) {
		if ((*expr._224).kind == v__ast__IdentKind_function) {
			v__gen__Gen_write(g, _STR("%.*s\000(it)", 2, v__gen__c_name((*expr._224).name)));
		} else if ((*expr._224).kind == v__ast__IdentKind_variable) {
			v__ast__IdentVar var_info = v__ast__Ident_var_info(&(*expr._224));
			v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, var_info.typ);
			if (sym->kind == v__table__Kind_function) {
				v__gen__Gen_write(g, _STR("%.*s\000(it)", 2, v__gen__c_name((*expr._224).name)));
			} else {
				v__gen__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
			}
		} else {
			v__gen__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
		}
	} else {
		v__gen__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
	};
	v__gen__Gen_writeln(g, tos_lit(";"));
	v__gen__Gen_writeln(g, _STR("\tarray_push(&%.*s\000, &ti);", 2, tmp));
	v__gen__Gen_writeln(g, tos_lit("}"));
	v__gen__Gen_write(g, s);
	v__gen__Gen_write(g, tmp);
	g->inside_lambda = false;
}

VV_LOCAL_SYMBOL void v__gen__Gen_gen_array_sort(v__gen__Gen* g, v__ast__CallExpr node) {
	v__table__TypeSymbol* rec_sym = v__table__Table_get_type_symbol(g->table, node.receiver_type);
	if (rec_sym->kind != v__table__Kind_array) {
		println(node.name);
		println(v__gen__Gen_typ(g, node.receiver_type));
		v__gen__verror(tos_lit(".sort() is an array method"));
	}
	v__table__Array info = /* as */ *(v__table__Array*)__as_cast((rec_sym->info)._350, (rec_sym->info).typ, /*expected:*/350);
	v__table__Type typ = info.elem_type;
	bool is_reverse = false;
	if (node.args.len > 0) {
		v__ast__InfixExpr infix_expr = /* as */ *(v__ast__InfixExpr*)__as_cast(((*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr)._228, ((*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr).typ, /*expected:*/228);
		is_reverse = infix_expr.op == v__token__Kind_gt;
	}
	string compare_fn = tos_lit("");
	v__table__Type _t1483 = typ;
	if (_t1483 == _const_v__table__int_type) {
		compare_fn = tos_lit("compare_ints");
	} else if (_t1483 == _const_v__table__string_type) {
		compare_fn = tos_lit("compare_strings");
	} else if (_t1483 == _const_v__table__f64_type) {
		compare_fn = tos_lit("compare_floats");
	} else {
		if (node.args.len == 0) {
			v__gen__verror(tos_lit("usage: .sort(a.field < b.field)"));
		}
		string tmp_name = v__gen__Gen_new_tmp_var(g);
		compare_fn = string_add(_STR("compare_%.*s\000_", 2, tmp_name), v__gen__Gen_typ(g, typ));
		if (is_reverse) {
			compare_fn = /*f*/string_add(compare_fn, tos_lit("_reverse"));
		}
		v__table__Table_register_fn(g->table, (v__table__Fn){.params = __new_array(0, 1, sizeof(v__table__Param)),.return_type = _const_v__table__int_type,.return_type_source_name = (string){.str=(byteptr)""},.is_variadic = 0,.language = 0,.is_generic = 0,.is_pub = 0,.is_deprecated = 0,.is_unsafe = 0,.is_placeholder = 0,.mod = (string){.str=(byteptr)""},.ctdefine = (string){.str=(byteptr)""},.attrs = __new_array(0, 1, sizeof(v__table__Attr)),.name = compare_fn,.source_fn = 0,});
		v__ast__InfixExpr infix_expr = /* as */ *(v__ast__InfixExpr*)__as_cast(((*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr)._228, ((*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr).typ, /*expected:*/228);
		string styp = v__gen__Gen_typ(g, typ);
		strings__Builder_writeln(&g->definitions, _STR("int %.*s\000 (%.*s\000* a, %.*s\000* b) {", 4, compare_fn, styp, styp));
		string field_type = v__gen__Gen_typ(g, infix_expr.left_type);
		string left_expr_str = string_replace_once(v__gen__Gen_write_expr_to_string(g, infix_expr.left), tos_lit("."), tos_lit("->"));
		string right_expr_str = string_replace_once(v__gen__Gen_write_expr_to_string(g, infix_expr.right), tos_lit("."), tos_lit("->"));
		strings__Builder_writeln(&g->definitions, _STR("%.*s\000 a_ = %.*s\000;", 3, field_type, left_expr_str));
		strings__Builder_writeln(&g->definitions, _STR("%.*s\000 b_ = %.*s\000;", 3, field_type, right_expr_str));
		string op1 = tos_lit("");
		string op2 = tos_lit("");
		if (infix_expr.left_type == _const_v__table__string_type) {
			if (is_reverse) {
				op1 = tos_lit("string_gt(a_, b_)");
				op2 = tos_lit("string_lt(a_, b_)");
			} else {
				op1 = tos_lit("string_lt(a_, b_)");
				op2 = tos_lit("string_gt(a_, b_)");
			}
		} else {
			if (is_reverse) {
				op1 = tos_lit("a_ > b_");
				op2 = tos_lit("a_ < b_");
			} else {
				op1 = tos_lit("a_ < b_");
				op2 = tos_lit("a_ > b_");
			}
		}
		strings__Builder_writeln(&g->definitions, _STR("if (%.*s\000) return -1;", 2, op1));
		strings__Builder_writeln(&g->definitions, _STR("if (%.*s\000) return 1; return 0; }\n", 2, op2));
	};
	if (is_reverse && !string_ends_with(compare_fn, tos_lit("_reverse"))) {
		compare_fn = /*f*/string_add(compare_fn, tos_lit("_reverse"));
	}
	string deref = (v__table__Type_is_ptr(node.left_type) || v__table__Type_is_pointer(node.left_type) ? (tos_lit("->")) : (tos_lit(".")));
	v__gen__Gen_write(g, tos_lit("qsort("));
	v__gen__Gen_expr(g, node.left);
	v__gen__Gen_write(g, _STR("%.*s\000data, ", 2, deref));
	v__gen__Gen_expr(g, node.left);
	v__gen__Gen_write(g, _STR("%.*s\000len, ", 2, deref));
	v__gen__Gen_expr(g, node.left);
	v__gen__Gen_writeln(g, _STR("%.*s\000element_size, (int (*)(const void *, const void *))&%.*s\000);", 3, deref, compare_fn));
}

VV_LOCAL_SYMBOL void v__gen__Gen_gen_array_filter(v__gen__Gen* g, v__ast__CallExpr node) {
	string tmp = v__gen__Gen_new_tmp_var(g);
	string s = v__gen__Gen_go_before_stmt(g, 0);
	v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, node.return_type);
	if (sym->kind != v__table__Kind_array) {
		v__gen__verror(tos_lit("filter() requires an array"));
	}
	v__table__Array info = /* as */ *(v__table__Array*)__as_cast((sym->info)._350, (sym->info).typ, /*expected:*/350);
	string styp = v__gen__Gen_typ(g, node.return_type);
	string elem_type_str = v__gen__Gen_typ(g, info.elem_type);
	v__gen__Gen_write(g, _STR("\nint %.*s\000_len = ", 2, tmp));
	v__gen__Gen_expr(g, node.left);
	v__gen__Gen_writeln(g, tos_lit(".len;"));
	v__gen__Gen_writeln(g, _STR("%.*s\000 %.*s\000 = __new_array(0, %.*s\000_len, sizeof(%.*s\000));", 5, styp, tmp, tmp, elem_type_str));
	v__gen__Gen_writeln(g, _STR("for (int i = 0; i < %.*s\000_len; ++i) {", 2, tmp));
	v__gen__Gen_write(g, _STR("  %.*s\000 it = ((%.*s\000*) ", 3, elem_type_str, elem_type_str));
	v__gen__Gen_expr(g, node.left);
	v__gen__Gen_writeln(g, tos_lit(".data)[i];"));
	v__gen__Gen_write(g, tos_lit("if ("));
	v__ast__Expr expr = (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr;
	v__ast__Expr _t1484 = expr;
	if (_t1484.typ == 208 /* v.ast.AnonFn */) {
		v__gen__Gen_gen_anon_fn_decl(g, (*expr._208));
		v__gen__Gen_write(g, _STR("%.*s\000(it)", 2, (*expr._208).decl.name));
	} else if (_t1484.typ == 224 /* v.ast.Ident */) {
		if ((*expr._224).kind == v__ast__IdentKind_function) {
			v__gen__Gen_write(g, _STR("%.*s\000(it)", 2, v__gen__c_name((*expr._224).name)));
		} else if ((*expr._224).kind == v__ast__IdentKind_variable) {
			v__ast__IdentVar var_info = v__ast__Ident_var_info(&(*expr._224));
			v__table__TypeSymbol* sym_t = v__table__Table_get_type_symbol(g->table, var_info.typ);
			if (sym_t->kind == v__table__Kind_function) {
				v__gen__Gen_write(g, _STR("%.*s\000(it)", 2, v__gen__c_name((*expr._224).name)));
			} else {
				v__gen__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
			}
		} else {
			v__gen__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
		}
	} else {
		v__gen__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
	};
	v__gen__Gen_writeln(g, _STR(") array_push(&%.*s\000, &it); \n }", 2, tmp));
	v__gen__Gen_write(g, s);
	v__gen__Gen_write(g, tos_lit(" "));
	v__gen__Gen_write(g, tmp);
}

VV_LOCAL_SYMBOL void v__gen__Gen_gen_array_insert(v__gen__Gen* g, v__ast__CallExpr node) {
	v__table__TypeSymbol* left_sym = v__table__Table_get_type_symbol(g->table, node.left_type);
	v__table__Array left_info = /* as */ *(v__table__Array*)__as_cast((left_sym->info)._350, (left_sym->info).typ, /*expected:*/350);
	string elem_type_str = v__gen__Gen_typ(g, left_info.elem_type);
	v__table__TypeSymbol* arg2_sym = v__table__Table_get_type_symbol(g->table, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 1)).typ);
	bool is_arg2_array = arg2_sym->kind == v__table__Kind_array;
	if (is_arg2_array) {
		v__gen__Gen_write(g, tos_lit("array_insert_many(&"));
	} else {
		v__gen__Gen_write(g, tos_lit("array_insert(&"));
	}
	v__gen__Gen_expr(g, node.left);
	v__gen__Gen_write(g, tos_lit(", "));
	v__gen__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
	if (is_arg2_array) {
		v__gen__Gen_write(g, tos_lit(", "));
		v__gen__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 1)).expr);
		v__gen__Gen_write(g, tos_lit(".data, "));
		v__gen__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 1)).expr);
		v__gen__Gen_write(g, tos_lit(".len)"));
	} else {
		v__gen__Gen_write(g, _STR(", &(%.*s\000[]){", 2, elem_type_str));
		if (left_info.elem_type == _const_v__table__string_type) {
			v__gen__Gen_write(g, tos_lit("string_clone("));
		}
		v__gen__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 1)).expr);
		if (left_info.elem_type == _const_v__table__string_type) {
			v__gen__Gen_write(g, tos_lit(")"));
		}
		v__gen__Gen_write(g, tos_lit("})"));
	}
}

VV_LOCAL_SYMBOL void v__gen__Gen_gen_array_prepend(v__gen__Gen* g, v__ast__CallExpr node) {
	v__table__TypeSymbol* left_sym = v__table__Table_get_type_symbol(g->table, node.left_type);
	v__table__Array left_info = /* as */ *(v__table__Array*)__as_cast((left_sym->info)._350, (left_sym->info).typ, /*expected:*/350);
	string elem_type_str = v__gen__Gen_typ(g, left_info.elem_type);
	v__table__TypeSymbol* arg_sym = v__table__Table_get_type_symbol(g->table, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).typ);
	bool is_arg_array = arg_sym->kind == v__table__Kind_array;
	if (is_arg_array) {
		v__gen__Gen_write(g, tos_lit("array_prepend_many(&"));
	} else {
		v__gen__Gen_write(g, tos_lit("array_prepend(&"));
	}
	v__gen__Gen_expr(g, node.left);
	if (is_arg_array) {
		v__gen__Gen_write(g, tos_lit(", "));
		v__gen__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
		v__gen__Gen_write(g, tos_lit(".data, "));
		v__gen__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
		v__gen__Gen_write(g, tos_lit(".len)"));
	} else {
		v__gen__Gen_write(g, _STR(", &(%.*s\000[]){", 2, elem_type_str));
		v__gen__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
		v__gen__Gen_write(g, tos_lit("})"));
	}
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL int v__gen__Gen_nth_stmt_pos(v__gen__Gen* g, int n) {
	return (*(int*)/*ee elem_typ */array_get(g->stmt_path_pos, g->stmt_path_pos.len - (1 + n)));
}

VV_LOCAL_SYMBOL string v__gen__Gen_go_before_stmt(v__gen__Gen* g, int n) {
	int stmt_pos = v__gen__Gen_nth_stmt_pos(g, n);
	string cur_line = strings__Builder_after(&g->out, stmt_pos);
	strings__Builder_go_back(&g->out, cur_line.len);
	return cur_line;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL string v__gen__Gen_go_before_ternary(v__gen__Gen* g) {
	return v__gen__Gen_go_before_stmt(g, g->inside_ternary);
}

VV_LOCAL_SYMBOL void v__gen__Gen_insert_before_stmt(v__gen__Gen* g, string s) {
	string cur_line = v__gen__Gen_go_before_stmt(g, 0);
	v__gen__Gen_writeln(g, s);
	v__gen__Gen_write(g, cur_line);
}

VV_LOCAL_SYMBOL string v__gen__Gen_write_expr_to_string(v__gen__Gen* g, v__ast__Expr expr) {
	int pos = g->out.buf.len;
	v__gen__Gen_expr(g, expr);
	return strings__Builder_cut_last(&g->out, g->out.buf.len - pos);
}

VV_LOCAL_SYMBOL void v__gen__Gen_or_block(v__gen__Gen* g, string var_name, v__ast__OrExpr or_block, v__table__Type return_type) {
	string cvar_name = v__gen__c_name(var_name);
	string mr_styp = v__gen__Gen_base_type(g, return_type);
	bool is_none_ok = string_eq(mr_styp, tos_lit("void"));
	g->inside_or_block = true;
	v__gen__Gen_writeln(g, tos_lit(";"));
	if (is_none_ok) {
		v__gen__Gen_writeln(g, _STR("if (!%.*s\000.ok && !%.*s\000.is_none) {", 3, cvar_name, cvar_name));
	} else {
		v__gen__Gen_writeln(g, _STR("if (!%.*s\000.ok) {", 2, cvar_name));
	}
	if (or_block.kind == v__ast__OrKind_block) {
		v__gen__Gen_writeln(g, _STR("\tstring err = %.*s\000.v_error;", 2, cvar_name));
		v__gen__Gen_writeln(g, _STR("\tint errcode = %.*s\000.ecode;", 2, cvar_name));
		array_v__ast__Stmt stmts = or_block.stmts;
		if (stmts.len > 0 && ((*(v__ast__Stmt*)/*ee elem_typ */array_get(stmts, or_block.stmts.len - 1))).typ == 259 /* v.ast.ExprStmt */ && (/* as */ *(v__ast__ExprStmt*)__as_cast(((*(v__ast__Stmt*)/*ee elem_typ */array_get(stmts, stmts.len - 1)))._259, ((*(v__ast__Stmt*)/*ee elem_typ */array_get(stmts, stmts.len - 1))).typ, /*expected:*/259)).typ != _const_v__table__void_type) {
			g->indent++;
			// FOR IN array
			array _t1485 = stmts;
			for (int i = 0; i < _t1485.len; ++i) {
				v__ast__Stmt stmt = ((v__ast__Stmt*)_t1485.data)[i];
				if (i == stmts.len - 1) {
					v__ast__ExprStmt expr_stmt = /* as */ *(v__ast__ExprStmt*)__as_cast((stmt)._259, (stmt).typ, /*expected:*/259);
					array_push(&g->stmt_path_pos, _MOV((int[]){ g->out.len }));
					v__gen__Gen_write(g, _STR("*(%.*s\000*) %.*s\000.data = ", 3, mr_styp, cvar_name));
					bool is_opt_call = (expr_stmt.expr).typ == 215 /* v.ast.CallExpr */ && v__table__Type_has_flag(expr_stmt.typ, v__table__TypeFlag_optional);
					if (is_opt_call) {
						v__gen__Gen_write(g, _STR("*(%.*s\000*) ", 2, mr_styp));
					}
					v__gen__Gen_expr(g, expr_stmt.expr);
					if (is_opt_call) {
						v__gen__Gen_write(g, tos_lit(".data"));
					}
					if (g->inside_ternary == 0 && !((expr_stmt.expr).typ == 225 /* v.ast.IfExpr */)) {
						v__gen__Gen_writeln(g, tos_lit(";"));
					}
					array_delete_last(&g->stmt_path_pos);
				} else {
					v__gen__Gen_stmt(g, stmt);
				}
			}
			g->indent--;
		} else {
			v__gen__Gen_stmts(g, stmts);
		}
	} else if (or_block.kind == v__ast__OrKind_propagate) {
		if (string_eq(g->file.mod.name, tos_lit("main")) && string_eq(g->fn_decl->name, tos_lit("main.main"))) {
			if (g->pref->is_debug) {
				multi_return_int_string_string_string mr_146763 = v__gen__Gen_panic_debug_info(g, or_block.pos);
				int paline = mr_146763.arg0;
				string pafile = mr_146763.arg1;
				string pamod = mr_146763.arg2;
				string pafn = mr_146763.arg3;
				v__gen__Gen_writeln(g, _STR("panic_debug(%"PRId32"\000, tos3(\"%.*s\000\"), tos3(\"%.*s\000\"), tos3(\"%.*s\000\"), %.*s\000.v_error );", 6, paline, pafile, pamod, pafn, cvar_name));
			} else {
				v__gen__Gen_writeln(g, _STR("\tv_panic(_STR(\"optional not set (%%.*s\\000)\", 2, %.*s\000.v_error));", 2, cvar_name));
			}
		} else {
			v__gen__Gen_write_defer_stmts(g);
			string styp = v__gen__Gen_typ(g, g->fn_decl->return_type);
			v__gen__Gen_writeln(g, _STR("\treturn *(%.*s\000 *)&%.*s\000;", 3, styp, cvar_name));
		}
	}
	v__gen__Gen_write(g, tos_lit("}"));
// Defer begin
g->inside_or_block = false;
// Defer end
}

VV_LOCAL_SYMBOL string v__gen__Gen_type_of_call_expr(v__gen__Gen* g, v__ast__Expr node) {
	v__ast__Expr _t1487 = node;
	if (_t1487.typ == 215 /* v.ast.CallExpr */) {
		return v__gen__Gen_typ(g, (*node._215).return_type);
	} else {
		return tos3( /* v.ast.Expr */ v_typeof_sumtype_250( (node).typ ));
	};
	return tos_lit("");
}

VV_LOCAL_SYMBOL void v__gen__Gen_in_optimization(v__gen__Gen* g, v__ast__Expr left, v__ast__ArrayInit right) {
	bool is_str = right.elem_type == _const_v__table__string_type;
	v__table__TypeSymbol* elem_sym = v__table__Table_get_type_symbol(g->table, right.elem_type);
	bool is_array = elem_sym->kind == v__table__Kind_array;
	// FOR IN array
	array _t1488 = right.exprs;
	for (int i = 0; i < _t1488.len; ++i) {
		v__ast__Expr array_expr = ((v__ast__Expr*)_t1488.data)[i];
		if (is_str) {
			v__gen__Gen_write(g, tos_lit("string_eq("));
		} else if (is_array) {
			string ptr_typ = v__gen__Gen_gen_array_equality_fn(g, right.elem_type);
			v__gen__Gen_write(g, _STR("%.*s\000_arr_eq(", 2, ptr_typ));
		}
		v__gen__Gen_expr(g, left);
		if (is_str || is_array) {
			v__gen__Gen_write(g, tos_lit(", "));
		} else {
			v__gen__Gen_write(g, tos_lit(" == "));
		}
		v__gen__Gen_expr(g, array_expr);
		if (is_str || is_array) {
			v__gen__Gen_write(g, tos_lit(")"));
		}
		if (i < right.exprs.len - 1) {
			v__gen__Gen_write(g, tos_lit(" || "));
		}
	}
}

VV_LOCAL_SYMBOL string v__gen__op_to_fn_name(string name) {
	string _t1489 = name;
		return ((string_eq(_t1489, tos_lit("+"))) ? (tos_lit("_op_plus")) : (string_eq(_t1489, tos_lit("-"))) ? (tos_lit("_op_minus")) : (string_eq(_t1489, tos_lit("*"))) ? (tos_lit("_op_mul")) : (string_eq(_t1489, tos_lit("/"))) ? (tos_lit("_op_div")) : (string_eq(_t1489, tos_lit("%"))) ? (tos_lit("_op_mod")) : (_STR("bad op %.*s", 1, name)));
}

VV_LOCAL_SYMBOL string v__gen__Gen_comp_if_to_ifdef(v__gen__Gen* g, string name, bool is_comptime_optional) {
	string _t1490 = name;
	if (string_eq(_t1490, tos_lit("windows"))) {
		return tos_lit("_WIN32");
	} else if (string_eq(_t1490, tos_lit("ios"))) {
		return tos_lit("__TARGET_IOS__");
	} else if (string_eq(_t1490, tos_lit("macos"))) {
		return tos_lit("__APPLE__");
	} else if (string_eq(_t1490, tos_lit("mach"))) {
		return tos_lit("__MACH__");
	} else if (string_eq(_t1490, tos_lit("darwin"))) {
		return tos_lit("__DARWIN__");
	} else if (string_eq(_t1490, tos_lit("hpux"))) {
		return tos_lit("__HPUX__");
	} else if (string_eq(_t1490, tos_lit("gnu"))) {
		return tos_lit("__GNU__");
	} else if (string_eq(_t1490, tos_lit("qnx"))) {
		return tos_lit("__QNX__");
	} else if (string_eq(_t1490, tos_lit("linux"))) {
		return tos_lit("__linux__");
	} else if (string_eq(_t1490, tos_lit("freebsd"))) {
		return tos_lit("__FreeBSD__");
	} else if (string_eq(_t1490, tos_lit("openbsd"))) {
		return tos_lit("__OpenBSD__");
	} else if (string_eq(_t1490, tos_lit("netbsd"))) {
		return tos_lit("__NetBSD__");
	} else if (string_eq(_t1490, tos_lit("bsd"))) {
		return tos_lit("__BSD__");
	} else if (string_eq(_t1490, tos_lit("dragonfly"))) {
		return tos_lit("__DragonFly__");
	} else if (string_eq(_t1490, tos_lit("android"))) {
		return tos_lit("__ANDROID__");
	} else if (string_eq(_t1490, tos_lit("solaris"))) {
		return tos_lit("__sun");
	} else if (string_eq(_t1490, tos_lit("haiku"))) {
		return tos_lit("__haiku__");
	} else if (string_eq(_t1490, tos_lit("linux_or_macos"))) {
		return tos_lit("");
	} else if (string_eq(_t1490, tos_lit("js"))) {
		return tos_lit("_VJS");
	} else if (string_eq(_t1490, tos_lit("gcc"))) {
		return tos_lit("__V_GCC__");
	} else if (string_eq(_t1490, tos_lit("tinyc"))) {
		return tos_lit("__TINYC__");
	} else if (string_eq(_t1490, tos_lit("clang"))) {
		return tos_lit("__clang__");
	} else if (string_eq(_t1490, tos_lit("mingw"))) {
		return tos_lit("__MINGW32__");
	} else if (string_eq(_t1490, tos_lit("msvc"))) {
		return tos_lit("_MSC_VER");
	} else if (string_eq(_t1490, tos_lit("cplusplus"))) {
		return tos_lit("__cplusplus");
	} else if (string_eq(_t1490, tos_lit("debug"))) {
		return tos_lit("_VDEBUG");
	} else if (string_eq(_t1490, tos_lit("test"))) {
		return tos_lit("_VTEST");
	} else if (string_eq(_t1490, tos_lit("glibc"))) {
		return tos_lit("__GLIBC__");
	} else if (string_eq(_t1490, tos_lit("prealloc"))) {
		return tos_lit("_VPREALLOC");
	} else if (string_eq(_t1490, tos_lit("no_bounds_checking"))) {
		return tos_lit("CUSTOM_DEFINE_no_bounds_checking");
	} else if (string_eq(_t1490, tos_lit("amd64"))) {
		return tos_lit("__V_amd64");
	} else if (string_eq(_t1490, tos_lit("aarch64"))) {
		return tos_lit("__V_aarch64");
	} else if (string_eq(_t1490, tos_lit("x64"))) {
		return tos_lit("TARGET_IS_64BIT");
	} else if (string_eq(_t1490, tos_lit("x32"))) {
		return tos_lit("TARGET_IS_32BIT");
	} else if (string_eq(_t1490, tos_lit("little_endian"))) {
		return tos_lit("TARGET_ORDER_IS_LITTLE");
	} else if (string_eq(_t1490, tos_lit("big_endian"))) {
		return tos_lit("TARGET_ORDER_IS_BIG");
	} else {
		if (is_comptime_optional || (g->pref->compile_defines_all.len > 0 && _IN(string, name, g->pref->compile_defines_all))) {
			return _STR("CUSTOM_DEFINE_%.*s", 1, name);
		}
		v__gen__verror(_STR("bad os ifdef name \"%.*s\000\"", 2, name));
	};
	return tos_lit("");
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL string v__gen__c_name(string name_) {
	string name = v__util__no_dots(name_);
	if (_IN(string, name, _const_v__gen__c_reserved)) {
		return _STR("v_%.*s", 1, name);
	}
	return name;
}

VV_LOCAL_SYMBOL string v__gen__Gen_type_default(v__gen__Gen* g, v__table__Type typ_) {
	v__table__Type typ = v__gen__Gen_unwrap_generic(g, typ_);
	if (v__table__Type_has_flag(typ, v__table__TypeFlag_optional)) {
		return tos_lit("{0}");
	}
	if (v__table__Type_is_ptr(typ)) {
		return tos_lit("0");
	}
	v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, typ);
	if (sym->kind == v__table__Kind_array) {
		string elem_sym = v__gen__Gen_typ(g, v__table__TypeSymbol_array_info(sym).elem_type);
		string elem_type_str = v__util__no_dots(elem_sym);
		if (string_starts_with(elem_type_str, tos_lit("C__"))) {
			elem_type_str = string_substr(elem_type_str, 3, elem_type_str.len);
		}
		return _STR("__new_array(0, 1, sizeof(%.*s\000))", 2, elem_type_str);
	}
	if (sym->kind == v__table__Kind_map) {
		string value_type_str = v__gen__Gen_typ(g, v__table__TypeSymbol_map_info(sym).value_type);
		return _STR("new_map_1(sizeof(%.*s\000))", 2, value_type_str);
	}
	if (sym->kind == v__table__Kind_struct_) {
		return tos_lit("{0}");
	}
	int idx = ((int)(typ));
	if (idx >= 1 && idx <= 17) {
		return tos_lit("0");
	}
	string _t1491 = sym->name;
	if (string_eq(_t1491, tos_lit("string"))) {
		return tos_lit("(string){.str=(byteptr)\"\"}");
	} else if (string_eq(_t1491, tos_lit("rune"))) {
		return tos_lit("0");
	} else {
	};
	v__table__Kind _t1492 = sym->kind;
		return ((_t1492 == v__table__Kind_interface_ || _t1492 == v__table__Kind_sum_type || _t1492 == v__table__Kind_array_fixed || _t1492 == v__table__Kind_multi_return) ? (tos_lit("{0}")) : (_t1492 == v__table__Kind_alias) ? (v__gen__Gen_type_default(g, (/* as */ *(v__table__Alias*)__as_cast((sym->info)._347, (sym->info).typ, /*expected:*/347)).parent_type)) : (tos_lit("0")));
}

VV_LOCAL_SYMBOL array_string v__gen__Gen_get_all_test_function_names(v__gen__Gen* g) {
	array_string tfuncs = __new_array_with_default(0, 0, sizeof(string), 0);
	string tsuite_begin = tos_lit("");
	string tsuite_end = tos_lit("");
	// FOR IN map
	map_string_v__table__Fn _t1494 = g->table->fns;
	for (int _t1493 = 0; _t1493 < _t1494.key_values.len; ++_t1493) {
		if (_t1494.key_values.keys[_t1493].str == 0) {continue;}
		v__table__Fn f = (*(v__table__Fn*)(void*)(_t1494.key_values.values + _t1493 * (u32)(_t1494.value_bytes)));
		if (string_eq(f.name, tos_lit("testsuite_begin"))) {
			tsuite_begin = f.name;
			continue;
		}
		if (string_eq(f.name, tos_lit("testsuite_end"))) {
			tsuite_end = f.name;
			continue;
		}
		if (string_starts_with(f.name, tos_lit("test_"))) {
			array_push(&tfuncs, _MOV((string[]){ string_clone(f.name) }));
			continue;
		}
		if (string_contains(f.name, tos_lit(".test_"))) {
			array_push(&tfuncs, _MOV((string[]){ string_clone(f.name) }));
			continue;
		}
		if (string_ends_with(f.name, tos_lit(".testsuite_begin"))) {
			tsuite_begin = f.name;
			continue;
		}
		if (string_ends_with(f.name, tos_lit(".testsuite_end"))) {
			tsuite_end = f.name;
			continue;
		}
	}
	array_string all_tfuncs = __new_array_with_default(0, 0, sizeof(string), 0);
	if (tsuite_begin.len > 0) {
		array_push(&all_tfuncs, _MOV((string[]){ string_clone(tsuite_begin) }));
	}
	_PUSH_MANY(&all_tfuncs, (tfuncs), _t1498, array_string);
	if (tsuite_end.len > 0) {
		array_push(&all_tfuncs, _MOV((string[]){ string_clone(tsuite_end) }));
	}
	array_string all_tfuncs_c = __new_array_with_default(0, 0, sizeof(string), 0);
	// FOR IN array
	array _t1500 = all_tfuncs;
	for (int _t1501 = 0; _t1501 < _t1500.len; ++_t1501) {
		string f = ((string*)_t1500.data)[_t1501];
		array_push(&all_tfuncs_c, _MOV((string[]){ string_clone(v__util__no_dots(f)) }));
	}
	return all_tfuncs_c;
}

VV_LOCAL_SYMBOL bool v__gen__Gen_is_importing_os(v__gen__Gen* g) {
	return _IN(string, tos_lit("os"), g->table->imports);
}

VV_LOCAL_SYMBOL void v__gen__Gen_go_stmt(v__gen__Gen* g, v__ast__GoStmt node) {
	string tmp = v__gen__Gen_new_tmp_var(g);
	v__ast__CallExpr expr = /* as */ *(v__ast__CallExpr*)__as_cast((node.call_expr)._215, (node.call_expr).typ, /*expected:*/215);
	string name = expr.name;
	if (expr.is_method) {
		v__table__TypeSymbol* receiver_sym = v__table__Table_get_type_symbol(g->table, expr.receiver_type);
		name = string_add(string_add(receiver_sym->name, tos_lit("_")), name);
	} else if ((expr.left).typ == 208 /* v.ast.AnonFn */) {
		v__gen__Gen_gen_anon_fn_decl(g, (*expr.left._208));
		v__table__TypeSymbol* fsym = v__table__Table_get_type_symbol(g->table, (*expr.left._208).typ);
		name = fsym->name;
	}
	name = v__util__no_dots(name);
	v__gen__Gen_writeln(g, tos_lit("// go"));
	string wrapper_struct_name = string_add(tos_lit("thread_arg_"), name);
	string wrapper_fn_name = string_add(name, tos_lit("_thread_wrapper"));
	string arg_tmp_var = string_add(tos_lit("arg_"), tmp);
	v__gen__Gen_writeln(g, _STR("%.*s\000 *%.*s\000 = malloc(sizeof(thread_arg_%.*s\000));", 4, wrapper_struct_name, arg_tmp_var, name));
	if (expr.is_method) {
		v__gen__Gen_write(g, _STR("%.*s\000->arg0 = ", 2, arg_tmp_var));
		v__gen__Gen_expr(g, expr.left);
		v__gen__Gen_writeln(g, tos_lit(";"));
	}
	// FOR IN array
	array _t1503 = expr.args;
	for (int i = 0; i < _t1503.len; ++i) {
		v__ast__CallArg arg = ((v__ast__CallArg*)_t1503.data)[i];
		v__gen__Gen_write(g, _STR("%.*s\000->arg%"PRId32"\000 = ", 3, arg_tmp_var, i + 1));
		v__gen__Gen_expr(g, arg.expr);
		v__gen__Gen_writeln(g, tos_lit(";"));
	}
	if (g->pref->os == v__pref__OS_windows) {
		v__gen__Gen_writeln(g, _STR("CreateThread(0,0, (LPTHREAD_START_ROUTINE)%.*s\000, %.*s\000, 0,0);", 3, wrapper_fn_name, arg_tmp_var));
	} else {
		v__gen__Gen_writeln(g, _STR("pthread_t thread_%.*s\000;", 2, tmp));
		v__gen__Gen_writeln(g, _STR("pthread_create(&thread_%.*s\000, NULL, (void*)%.*s\000, %.*s\000);", 4, tmp, wrapper_fn_name, arg_tmp_var));
	}
	v__gen__Gen_writeln(g, tos_lit("// endgo\n"));
	if (_IN(string, name, g->threaded_fns)) {
		return;
	}
	strings__Builder_writeln(&g->type_definitions, _STR("\ntypedef struct %.*s\000 {", 2, wrapper_struct_name));
	if (expr.is_method) {
		string styp = v__gen__Gen_typ(g, expr.receiver_type);
		strings__Builder_writeln(&g->type_definitions, _STR("\t%.*s\000 arg0;", 2, styp));
	}
	if (expr.args.len == 0) {
		strings__Builder_writeln(&g->type_definitions, tos_lit("EMPTY_STRUCT_DECLARATION;"));
	} else {
		// FOR IN array
		array _t1504 = expr.args;
		for (int i = 0; i < _t1504.len; ++i) {
			v__ast__CallArg arg = ((v__ast__CallArg*)_t1504.data)[i];
			string styp = v__gen__Gen_typ(g, arg.typ);
			strings__Builder_writeln(&g->type_definitions, _STR("\t%.*s\000 arg%"PRId32"\000;", 3, styp, i + 1));
		}
	}
	strings__Builder_writeln(&g->type_definitions, _STR("} %.*s\000;", 2, wrapper_struct_name));
	strings__Builder_writeln(&g->type_definitions, _STR("void* %.*s\000(%.*s\000 *arg);", 3, wrapper_fn_name, wrapper_struct_name));
	strings__Builder_writeln(&g->gowrappers, _STR("void* %.*s\000(%.*s\000 *arg) {", 3, wrapper_fn_name, wrapper_struct_name));
	strings__Builder_write(&g->gowrappers, _STR("\t%.*s\000(", 2, name));
	if (expr.is_method) {
		strings__Builder_write(&g->gowrappers, tos_lit("arg->arg0"));
		if (expr.args.len > 0) {
			strings__Builder_write(&g->gowrappers, tos_lit(", "));
		}
	}
	for (int i = 0; i < expr.args.len; ++i) {
		strings__Builder_write(&g->gowrappers, _STR("arg->arg%"PRId32"", 1, i + 1));
		if (i < expr.args.len - 1) {
			strings__Builder_write(&g->gowrappers, tos_lit(", "));
		}
	}
	strings__Builder_writeln(&g->gowrappers, tos_lit(");"));
	strings__Builder_writeln(&g->gowrappers, tos_lit("\treturn 0;"));
	strings__Builder_writeln(&g->gowrappers, tos_lit("}"));
	array_push(&g->threaded_fns, _MOV((string[]){ string_clone(name) }));
}

VV_LOCAL_SYMBOL void v__gen__Gen_as_cast(v__gen__Gen* g, v__ast__AsCast node) {
	string styp = v__gen__Gen_typ(g, node.typ);
	v__table__TypeSymbol* expr_type_sym = v__table__Table_get_type_symbol(g->table, node.expr_type);
	if (expr_type_sym->kind == v__table__Kind_sum_type) {
		string dot = (v__table__Type_is_ptr(node.expr_type) ? (tos_lit("->")) : (tos_lit(".")));
		v__gen__Gen_write(g, _STR("/* as */ *(%.*s\000*)__as_cast((", 2, styp));
		v__gen__Gen_expr(g, node.expr);
		v__gen__Gen_write(g, tos_lit(")"));
		v__gen__Gen_write(g, dot);
		v__gen__Gen_write(g, _STR("_%"PRId32"\000, (", 2, v__table__Type_idx(node.typ)));
		v__gen__Gen_expr(g, node.expr);
		v__gen__Gen_write(g, tos_lit(")"));
		v__gen__Gen_write(g, dot);
		v__gen__Gen_write(g, _STR("typ, /*expected:*/%"PRId32"\000)", 2, node.typ));
	}
}

VV_LOCAL_SYMBOL void v__gen__Gen_is_expr(v__gen__Gen* g, v__ast__InfixExpr node) {
	string eq = (node.op == v__token__Kind_key_is ? (tos_lit("==")) : (tos_lit("!=")));
	v__gen__Gen_write(g, tos_lit("("));
	v__gen__Gen_expr(g, node.left);
	v__gen__Gen_write(g, tos_lit(")"));
	if (v__table__Type_is_ptr(node.left_type)) {
		v__gen__Gen_write(g, tos_lit("->"));
	} else {
		v__gen__Gen_write(g, tos_lit("."));
	}
	v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, node.left_type);
	if (sym->kind == v__table__Kind_interface_) {
		v__gen__Gen_write(g, _STR("_interface_idx %.*s\000 ", 2, eq));
		v__ast__Type sub_type = /* as */ *(v__ast__Type*)__as_cast((node.right)._247, (node.right).typ, /*expected:*/247);
		v__table__TypeSymbol* sub_sym = v__table__Table_get_type_symbol(g->table, sub_type.typ);
		v__gen__Gen_write(g, _STR("_%.*s\000_%.*s\000_index", 3, v__gen__c_name(sym->name), v__gen__c_name(sub_sym->name)));
		return;
	} else if (sym->kind == v__table__Kind_sum_type) {
		v__gen__Gen_write(g, _STR("typ %.*s\000 ", 2, eq));
	}
	v__gen__Gen_expr(g, node.right);
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL string v__gen__styp_to_str_fn_name(string styp) {
	return string_add(string_replace(styp, tos_lit("*"), tos_lit("_ptr")), tos_lit("_str"));
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL string v__gen__Gen_gen_str_for_type(v__gen__Gen* g, v__table__Type typ) {
	if (g->pref->build_mode == v__pref__BuildMode_build_module) {
		return tos_lit("");
	}
	string styp = v__gen__Gen_typ(g, typ);
	return v__gen__Gen_gen_str_for_type_with_styp(g, typ, styp);
}

VV_LOCAL_SYMBOL void v__gen__Gen_gen_str_default(v__gen__Gen* g, v__table__TypeSymbol sym, string styp, string str_fn_name) {
	string convertor = tos_lit("");
	string typename_ = tos_lit("");
	if (_IN(int, sym.parent_idx, _const_v__table__integer_type_idxs)) {
		convertor = tos_lit("int");
		typename_ = tos_lit("int");
	} else if (sym.parent_idx == _const_v__table__f32_type_idx) {
		convertor = tos_lit("float");
		typename_ = tos_lit("f32");
	} else if (sym.parent_idx == _const_v__table__f64_type_idx) {
		convertor = tos_lit("double");
		typename_ = tos_lit("f64");
	} else if (sym.parent_idx == _const_v__table__bool_type_idx) {
		convertor = tos_lit("bool");
		typename_ = tos_lit("bool");
	} else {
		v__gen__verror(_STR("could not generate string method for type '%.*s\000'", 2, styp));
	}
	strings__Builder_writeln(&g->type_definitions, _STR("string %.*s\000(%.*s\000 it); // auto", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("string %.*s\000(%.*s\000 it) {", 3, str_fn_name, styp));
	if (string_eq(convertor, tos_lit("bool"))) {
		strings__Builder_writeln(&g->auto_str_funcs, _STR("\tstring tmp1 = string_add(tos_lit(\"%.*s\000(\"), (%.*s\000)it ? tos_lit(\"true\") : tos_lit(\"false\"));", 3, styp, convertor));
	} else {
		strings__Builder_writeln(&g->auto_str_funcs, _STR("\tstring tmp1 = string_add(tos_lit(\"%.*s\000(\"), tos3(%.*s\000_str((%.*s\000)it).str));", 4, styp, typename_, convertor));
	}
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\tstring tmp2 = string_add(tmp1, tos_lit(\")\"));"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\tstring_free(&tmp1);"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("\treturn tmp2;"));
	strings__Builder_writeln(&g->auto_str_funcs, tos_lit("}"));
}

VV_LOCAL_SYMBOL string v__gen__Gen_type_to_fmt(v__gen__Gen* g, v__table__Type typ) {
	v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, typ);
	if ((v__table__Type_is_int(typ) || v__table__Type_is_float(typ)) && v__table__Type_is_ptr(typ)) {
		return tos_lit("%.*s\\000");
	} else if ((sym->kind == v__table__Kind_struct_ || sym->kind == v__table__Kind_array || sym->kind == v__table__Kind_array_fixed || sym->kind == v__table__Kind_map)) {
		return tos_lit("%.*s\\000");
	} else if (sym->kind == v__table__Kind_string) {
		return tos_lit("\'%.*s\\000\'");
	} else if (sym->kind == v__table__Kind_bool) {
		return tos_lit("%.*s\\000");
	} else if (sym->kind == v__table__Kind_enum_) {
		return tos_lit("%.*s\\000");
	} else if ((sym->kind == v__table__Kind_f32 || sym->kind == v__table__Kind_f64)) {
		return tos_lit("%g\\000");
	} else if (sym->kind == v__table__Kind_u64) {
		return tos_lit("%lld\\000");
	} else if (sym->kind == v__table__Kind_sum_type) {
		return tos_lit("%.*s\\000");
	}
	return tos_lit("%d\\000");
}

VV_LOCAL_SYMBOL string v__gen__Gen_interface_table(v__gen__Gen* g) {
	strings__Builder sb = strings__new_builder(100);
	// FOR IN array
	array _t1506 = g->table->types;
	for (int _t1507 = 0; _t1507 < _t1506.len; ++_t1507) {
		v__table__TypeSymbol ityp = ((v__table__TypeSymbol*)_t1506.data)[_t1507];
		if (ityp.kind != v__table__Kind_interface_) {
			continue;
		}
		v__table__Interface inter_info = /* as */ *(v__table__Interface*)__as_cast((ityp.info)._356, (ityp.info).typ, /*expected:*/356);
		if (inter_info.types.len == 0) {
			continue;
		}
		string interface_name = v__gen__c_name(ityp.name);
		string methods_struct_name = _STR("struct _%.*s\000_interface_methods", 2, interface_name);
		strings__Builder methods_typ_def = strings__new_builder(100);
		strings__Builder methods_struct_def = strings__new_builder(100);
		strings__Builder_writeln(&methods_struct_def, _STR("%.*s\000 {", 2, methods_struct_name));
		map_string_string imethods = new_map_1(sizeof(string));
		map_string_int methodidx = new_map_1(sizeof(int));
		// FOR IN array
		array _t1508 = ityp.methods;
		for (int k = 0; k < _t1508.len; ++k) {
			v__table__Fn method = ((v__table__Fn*)_t1508.data)[k];
			map_set(&methodidx, method.name, &(int[]) { k });
			string typ_name = _STR("_%.*s\000_%.*s\000_fn", 3, interface_name, method.name);
			string ret_styp = v__gen__Gen_typ(g, method.return_type);
			strings__Builder_write(&methods_typ_def, _STR("typedef %.*s\000 (*%.*s\000)(void* _", 3, ret_styp, typ_name));
			for (int i = 1; i < method.params.len; ++i) {
				v__table__Param arg = (*(v__table__Param*)/*ee elem_typ */array_get(method.params, i));
				strings__Builder_write(&methods_typ_def, _STR(", %.*s\000 %.*s", 2, v__gen__Gen_typ(g, arg.typ), arg.name));
			}
			strings__Builder_writeln(&methods_typ_def, tos_lit(");"));
			strings__Builder_writeln(&methods_struct_def, _STR("\t%.*s\000 %.*s\000;", 3, typ_name, v__gen__c_name(method.name)));
			map_set(&imethods, method.name, &(string[]) { typ_name });
		}
		strings__Builder_writeln(&methods_struct_def, tos_lit("};"));
		strings__Builder methods_struct = strings__new_builder(100);
		strings__Builder_writeln(&methods_struct, _STR("%.*s\000 %.*s\000_name_table[%"PRId32"\000] = {", 4, methods_struct_name, interface_name, inter_info.types.len));
		strings__Builder cast_functions = strings__new_builder(100);
		strings__Builder_write(&cast_functions, _STR("// Casting functions for interface \"%.*s\000\"", 2, interface_name));
		strings__Builder methods_wrapper = strings__new_builder(100);
		strings__Builder_writeln(&methods_wrapper, _STR("// Methods wrapper for interface \"%.*s\000\"", 2, interface_name));
		map_string_int already_generated_mwrappers = new_map_1(sizeof(int));
		int iinidx_minimum_base = 1000;
		int current_iinidx = iinidx_minimum_base;
		// FOR IN array
		array _t1509 = inter_info.types;
		for (int _t1510 = 0; _t1510 < _t1509.len; ++_t1510) {
			v__table__Type st = ((v__table__Type*)_t1509.data)[_t1510];
			string cctype = v__gen__Gen_cc_type(g, st);
			string interface_index_name = _STR("_%.*s\000_%.*s\000_index", 3, interface_name, cctype);
			if ((*(int*)map_get(already_generated_mwrappers, interface_index_name, &(int[]){ 0 })) > 0) {
				continue;
			}
			map_set(&already_generated_mwrappers, interface_index_name, &(int[]) { current_iinidx });
			current_iinidx++;
			strings__Builder_writeln(&cast_functions, _STR("\n_Interface I_%.*s\000_to_Interface_%.*s\000(%.*s\000* x) {\n	return (_Interface) {\n		._object = (void*) (x),\n		._interface_idx = %.*s\000\n	};\n}\n\n_Interface* I_%.*s\000_to_Interface_%.*s\000_ptr(%.*s\000* x) {\n	// TODO Remove memdup\n	return (_Interface*) memdup(&(_Interface) {\n		._object = (void*) (x),\n		._interface_idx = %.*s\000\n	}, sizeof(_Interface));\n}", 9, cctype, interface_name, cctype, interface_index_name, cctype, interface_name, cctype, interface_index_name));
			strings__Builder_writeln(&methods_struct, tos_lit("\t{"));
			v__table__TypeSymbol* st_sym = v__table__Table_get_type_symbol(g->table, st);
			v__table__Fn method = (v__table__Fn){.params = __new_array(0, 1, sizeof(v__table__Param)),.return_type = 0,.return_type_source_name = (string){.str=(byteptr)""},.is_variadic = 0,.language = 0,.is_generic = 0,.is_pub = 0,.is_deprecated = 0,.is_unsafe = 0,.is_placeholder = 0,.mod = (string){.str=(byteptr)""},.ctdefine = (string){.str=(byteptr)""},.attrs = __new_array(0, 1, sizeof(v__table__Attr)),.name = (string){.str=(byteptr)""},.source_fn = 0,};
			// FOR IN array
			array _t1511 = ityp.methods;
			for (int _t1512 = 0; _t1512 < _t1511.len; ++_t1512) {
				v__table__Fn m = ((v__table__Fn*)_t1511.data)[_t1512];
				// FOR IN array
				array _t1513 = st_sym->methods;
				for (int _t1514 = 0; _t1514 < _t1513.len; ++_t1514) {
					v__table__Fn mm = ((v__table__Fn*)_t1513.data)[_t1514];
					if (string_eq(mm.name, m.name)) {
						method = mm;
						break;
					}
				}
				if (!_IN_MAP(method.name, imethods)) {
					continue;
				}
				string method_call = _STR("%.*s\000_%.*s", 2, cctype, method.name);
				if (!v__table__Type_is_ptr((*(v__table__Param*)/*ee elem_typ */array_get(method.params, 0)).typ)) {
					strings__Builder_write(&methods_wrapper, _STR("static inline %.*s", 1, v__gen__Gen_typ(g, method.return_type)));
					strings__Builder_write(&methods_wrapper, _STR(" %.*s\000_method_wrapper(", 2, method_call));
					strings__Builder_write(&methods_wrapper, _STR("%.*s\000* %.*s", 2, cctype, (*(v__table__Param*)/*ee elem_typ */array_get(method.params, 0)).name));
					for (int j = 1; j < method.params.len; ++j) {
						v__table__Param arg = (*(v__table__Param*)/*ee elem_typ */array_get(method.params, j));
						strings__Builder_write(&methods_wrapper, _STR(", %.*s\000 %.*s", 2, v__gen__Gen_typ(g, arg.typ), arg.name));
					}
					strings__Builder_writeln(&methods_wrapper, tos_lit(") {"));
					strings__Builder_write(&methods_wrapper, tos_lit("\t"));
					if (method.return_type != _const_v__table__void_type) {
						strings__Builder_write(&methods_wrapper, tos_lit("return "));
					}
					strings__Builder_write(&methods_wrapper, _STR("%.*s\000(*%.*s", 2, method_call, (*(v__table__Param*)/*ee elem_typ */array_get(method.params, 0)).name));
					for (int j = 1; j < method.params.len; ++j) {
						strings__Builder_write(&methods_wrapper, _STR(", %.*s", 1, (*(v__table__Param*)/*ee elem_typ */array_get(method.params, j)).name));
					}
					strings__Builder_writeln(&methods_wrapper, tos_lit(");"));
					strings__Builder_writeln(&methods_wrapper, tos_lit("}"));
					method_call = /*f*/string_add(method_call, tos_lit("_method_wrapper"));
				}
				strings__Builder_writeln(&methods_struct, _STR("\t\t.%.*s\000 = %.*s\000,", 3, v__gen__c_name(method.name), method_call));
			}
			strings__Builder_writeln(&methods_struct, tos_lit("\t},"));
			int iin_idx = (*(int*)map_get(already_generated_mwrappers, interface_index_name, &(int[]){ 0 })) - iinidx_minimum_base;
			strings__Builder_writeln(&sb, _STR("int %.*s\000 = %"PRId32"\000;", 3, interface_index_name, iin_idx));
		}
		strings__Builder_writeln(&sb, _STR("// ^^^ number of types for interface %.*s\000: %"PRId32"", 2, interface_name, current_iinidx - iinidx_minimum_base));
		strings__Builder_writeln(&methods_struct, tos_lit("};"));
		strings__Builder_writeln(&sb, tos_lit(""));
		strings__Builder_writeln(&sb, strings__Builder_str(&methods_wrapper));
		strings__Builder_writeln(&sb, strings__Builder_str(&methods_typ_def));
		strings__Builder_writeln(&sb, strings__Builder_str(&methods_struct_def));
		strings__Builder_writeln(&sb, strings__Builder_str(&methods_struct));
		strings__Builder_writeln(&sb, strings__Builder_str(&cast_functions));
	}
	return strings__Builder_str(&sb);
}

VV_LOCAL_SYMBOL void v__gen__Gen_array_init(v__gen__Gen* g, v__ast__ArrayInit it) {
	v__table__TypeSymbol* type_sym = v__table__Table_get_type_symbol(g->table, it.typ);
	string styp = v__gen__Gen_typ(g, it.typ);
	string shared_styp = tos_lit("");
	bool is_amp = g->is_amp;
	g->is_amp = false;
	if (is_amp) {
		strings__Builder_go_back(&g->out, 1);
		if (g->is_shared) {
			v__table__Type shared_typ = v__table__Type_set_flag(it.typ, v__table__TypeFlag_shared_f);
			shared_styp = v__gen__Gen_typ(g, shared_typ);
			v__gen__Gen_writeln(g, _STR("(%.*s\000*)memdup(&(%.*s\000){.val = ", 3, shared_styp, shared_styp));
		} else {
			v__gen__Gen_write(g, _STR("(%.*s\000*)memdup(&", 2, styp));
		}
	} else {
		if (g->is_shared) {
			v__gen__Gen_writeln(g, _STR("{.val = (%.*s\000*)", 2, styp));
		}
	}
	if (type_sym->kind == v__table__Kind_array_fixed) {
		v__gen__Gen_write(g, tos_lit("{"));
		if (it.has_val) {
			// FOR IN array
			array _t1515 = it.exprs;
			for (int i = 0; i < _t1515.len; ++i) {
				v__ast__Expr expr = ((v__ast__Expr*)_t1515.data)[i];
				v__gen__Gen_expr(g, expr);
				if (i != it.exprs.len - 1) {
					v__gen__Gen_write(g, tos_lit(", "));
				}
			}
		} else {
			v__gen__Gen_write(g, tos_lit("0"));
		}
		v__gen__Gen_write(g, tos_lit("}"));
		return;
	}
	string elem_type_str = v__gen__Gen_typ(g, it.elem_type);
	if (it.exprs.len == 0) {
		v__table__TypeSymbol* elem_sym = v__table__Table_get_type_symbol(g->table, it.elem_type);
		bool is_default_array = elem_sym->kind == v__table__Kind_array && it.has_default;
		if (is_default_array) {
			v__gen__Gen_write(g, tos_lit("__new_array_with_array_default("));
		} else {
			v__gen__Gen_write(g, tos_lit("__new_array_with_default("));
		}
		if (it.has_len) {
			v__gen__Gen_expr(g, it.len_expr);
			v__gen__Gen_write(g, tos_lit(", "));
		} else {
			v__gen__Gen_write(g, tos_lit("0, "));
		}
		if (it.has_cap) {
			v__gen__Gen_expr(g, it.cap_expr);
			v__gen__Gen_write(g, tos_lit(", "));
		} else {
			v__gen__Gen_write(g, tos_lit("0, "));
		}
		if (elem_sym->kind == v__table__Kind_function) {
			v__gen__Gen_write(g, tos_lit("sizeof(voidptr), "));
		} else {
			v__gen__Gen_write(g, _STR("sizeof(%.*s\000), ", 2, elem_type_str));
		}
		if (is_default_array) {
			v__gen__Gen_write(g, _STR("(%.*s\000[]){", 2, elem_type_str));
			v__gen__Gen_expr(g, it.default_expr);
			v__gen__Gen_write(g, tos_lit("}[0])"));
		} else if (it.has_default) {
			v__gen__Gen_write(g, _STR("&(%.*s\000[]){", 2, elem_type_str));
			v__gen__Gen_expr(g, it.default_expr);
			v__gen__Gen_write(g, tos_lit("})"));
		} else if (it.has_len && it.elem_type == _const_v__table__string_type) {
			v__gen__Gen_write(g, _STR("&(%.*s\000[]){", 2, elem_type_str));
			v__gen__Gen_write(g, tos_lit("tos_lit(\"\")"));
			v__gen__Gen_write(g, tos_lit("})"));
		} else {
			v__gen__Gen_write(g, tos_lit("0)"));
		}
		return;
	}
	int len = it.exprs.len;
	v__table__TypeSymbol* elem_sym = v__table__Table_get_type_symbol(g->table, it.elem_type);
	if (elem_sym->kind == v__table__Kind_function) {
		v__gen__Gen_write(g, _STR("new_array_from_c_array(%"PRId32"\000, %"PRId32"\000, sizeof(voidptr), _MOV((voidptr[%"PRId32"\000]){", 4, len, len, len));
	} else {
		v__gen__Gen_write(g, _STR("new_array_from_c_array(%"PRId32"\000, %"PRId32"\000, sizeof(%.*s\000), _MOV((%.*s\000[%"PRId32"\000]){", 6, len, len, elem_type_str, elem_type_str, len));
	}
	if (len > 8) {
		v__gen__Gen_writeln(g, tos_lit(""));
		v__gen__Gen_write(g, tos_lit("\t\t"));
	}
	// FOR IN array
	array _t1516 = it.exprs;
	for (int i = 0; i < _t1516.len; ++i) {
		v__ast__Expr expr = ((v__ast__Expr*)_t1516.data)[i];
		if (it.is_interface) {
			v__gen__Gen_interface_call(g, (*(v__table__Type*)/*ee elem_typ */array_get(it.interface_types, i)), it.interface_type);
		}
		v__gen__Gen_expr(g, expr);
		if (it.is_interface) {
			v__gen__Gen_write(g, tos_lit(")"));
		}
		if (i != len - 1) {
			v__gen__Gen_write(g, tos_lit(", "));
		}
	}
	v__gen__Gen_write(g, tos_lit("}))"));
	if (g->is_shared) {
		v__gen__Gen_write(g, tos_lit(", .mtx = sync__new_rwmutex()}"));
		if (is_amp) {
			v__gen__Gen_write(g, _STR(", sizeof(%.*s\000))", 2, shared_styp));
		}
	} else if (is_amp) {
		v__gen__Gen_write(g, _STR(", sizeof(%.*s\000))", 2, styp));
	}
}

VV_LOCAL_SYMBOL void v__gen__Gen_interface_call(v__gen__Gen* g, v__table__Type typ, v__table__Type interface_type) {
	string interface_styp = v__gen__Gen_cc_type(g, interface_type);
	string styp = v__gen__Gen_cc_type(g, typ);
	string cast_fn_name = _STR("I_%.*s\000_to_Interface_%.*s", 2, styp, interface_styp);
	if (v__table__Type_is_ptr(interface_type)) {
		cast_fn_name = /*f*/string_add(cast_fn_name, tos_lit("_ptr"));
	}
	v__gen__Gen_write(g, _STR("%.*s\000(", 2, cast_fn_name));
	if (!v__table__Type_is_ptr(typ)) {
		v__gen__Gen_write(g, tos_lit("&"));
	}
}

VV_LOCAL_SYMBOL multi_return_int_string_string_string v__gen__Gen_panic_debug_info(v__gen__Gen* g, v__token__Position pos) {
	int paline = pos.line_nr + 1;
	string pafile = string_replace(g->fn_decl->file, tos_lit("\\"), tos_lit("/"));
	string pafn = string_after(g->fn_decl->name, tos_lit("."));
	string pamod = v__ast__FnDecl_modname(g->fn_decl);
	return (multi_return_int_string_string_string){.arg0=paline, .arg1=pafile, .arg2=pamod, .arg3=pafn};
}

string v__gen__get_guarded_include_text(string iname, string imessage) {
	string res = string_strip_margin(_STR("\n	|#if defined(__has_include)\n	|\n	|#if __has_include(%.*s\000)\n	|#include %.*s\000\n	|#else\n	|#error VERROR_MESSAGE %.*s\000\n	|#endif\n	|\n	|#else\n	|#include %.*s\000\n	|#endif\n	", 5, iname, iname, imessage, iname));
	return res;
}

void v__gen__Gen_gen_c_main(v__gen__Gen* g) {
	if (!g->has_main) {
		return;
	}
	if (g->pref->is_liveshared) {
		return;
	}
	strings__Builder_writeln(&g->out, tos_lit(""));
	int main_fn_start_pos = g->out.len;
	if (g->pref->os == v__pref__OS_android && g->pref->is_apk) {
		v__gen__Gen_gen_c_android_sokol_main(g);
	} else {
		v__gen__Gen_gen_c_main_header(g);
		v__gen__Gen_writeln(g, tos_lit("\tmain__main();"));
		v__gen__Gen_gen_c_main_footer(g);
		if (g->pref->printfn_list.len > 0 && _IN(string, tos_lit("main"), g->pref->printfn_list)) {
			println(strings__Builder_after(&g->out, main_fn_start_pos));
		}
	}
}

VV_LOCAL_SYMBOL void v__gen__Gen_gen_vlines_reset(v__gen__Gen* g) {
	if (g->pref->is_vlines) {
		int lines_so_far = 1000000;
		g->vlines_path = v__util__vlines_escape_path(g->pref->out_name_c, g->pref->ccompiler);
		v__gen__Gen_writeln(g, tos_lit(""));
		v__gen__Gen_writeln(g, tos_lit("\n// Reset the file/line numbers"));
		v__gen__Gen_writeln(g, _STR("\n#line %"PRId32"\000 \"%.*s\000\"", 3, lines_so_far, g->vlines_path));
		v__gen__Gen_writeln(g, tos_lit(""));
	}
}

VV_LOCAL_SYMBOL void v__gen__Gen_gen_c_main_header(v__gen__Gen* g) {
	if (g->pref->os == v__pref__OS_windows) {
		if (v__gen__Gen_is_gui_app(g)) {
			v__gen__Gen_writeln(g, tos_lit("int WINAPI wWinMain(HINSTANCE instance, HINSTANCE prev_instance, LPWSTR cmd_line, int show_cmd){"));
		} else {
			v__gen__Gen_writeln(g, tos_lit("int wmain(int ___argc, wchar_t* ___argv[], wchar_t* ___envp[]){"));
		}
	} else {
		v__gen__Gen_writeln(g, tos_lit("int main(int ___argc, char** ___argv){"));
	}
	if (g->pref->os == v__pref__OS_windows && v__gen__Gen_is_gui_app(g)) {
		v__gen__Gen_writeln(g, tos_lit("\tLPWSTR full_cmd_line = GetCommandLineW(); // NB: do not use cmd_line"));
		v__gen__Gen_writeln(g, tos_lit("\ttypedef LPWSTR*(WINAPI *cmd_line_to_argv)(LPCWSTR, int*);"));
		v__gen__Gen_writeln(g, tos_lit("\tHMODULE shell32_module = LoadLibrary(L\"shell32.dll\");"));
		v__gen__Gen_writeln(g, tos_lit("\tcmd_line_to_argv CommandLineToArgvW = (cmd_line_to_argv)GetProcAddress(shell32_module, \"CommandLineToArgvW\");"));
		v__gen__Gen_writeln(g, tos_lit("\tint ___argc;"));
		v__gen__Gen_writeln(g, tos_lit("\twchar_t** ___argv = CommandLineToArgvW(full_cmd_line, &___argc);"));
	}
	v__gen__Gen_writeln(g, tos_lit("\t_vinit();"));
	if (g->pref->is_prof) {
		v__gen__Gen_writeln(g, tos_lit(""));
		v__gen__Gen_writeln(g, tos_lit("\tatexit(vprint_profile_stats);"));
		v__gen__Gen_writeln(g, tos_lit(""));
	}
	if (v__gen__Gen_is_importing_os(g)) {
		if (g->autofree) {
			v__gen__Gen_writeln(g, tos_lit("free(_const_os__args.data); // empty, inited in _vinit()"));
		}
		if (g->pref->os == v__pref__OS_windows) {
			v__gen__Gen_writeln(g, tos_lit("\t_const_os__args = os__init_os_args_wide(___argc, ___argv);"));
		} else {
			v__gen__Gen_writeln(g, tos_lit("\t_const_os__args = os__init_os_args(___argc, (byteptr*)___argv);"));
		}
	}
	if (g->pref->is_livemain) {
		v__gen__Gen_generate_hotcode_reloading_main_caller(g);
	}
}

void v__gen__Gen_gen_c_main_footer(v__gen__Gen* g) {
	if (g->autofree) {
		v__gen__Gen_writeln(g, tos_lit("\t_vcleanup();"));
	}
	v__gen__Gen_writeln(g, tos_lit("\treturn 0;"));
	v__gen__Gen_writeln(g, tos_lit("}"));
}

void v__gen__Gen_gen_c_android_sokol_main(v__gen__Gen* g) {
	if (g->autofree) {
		v__gen__Gen_writeln(g, tos_lit("// Wrapping cleanup/free callbacks for sokol to include _vcleanup()\nvoid (*_vsokol_user_cleanup_ptr)(void);\nvoid (*_vsokol_user_cleanup_cb_ptr)(void *);\n\nvoid (_vsokol_cleanup_cb)(void) {\n	if (_vsokol_user_cleanup_ptr) {\n		_vsokol_user_cleanup_ptr();\n	}\n	_vcleanup();\n}\n\nvoid (_vsokol_cleanup_userdata_cb)(void* user_data) {\n	if (_vsokol_user_cleanup_cb_ptr) {\n		_vsokol_user_cleanup_cb_ptr(g_desc.user_data);\n	}\n	_vcleanup();\n}\n"));
	}
	v__gen__Gen_writeln(g, tos_lit("// The sokol_main entry point on Android\nsapp_desc sokol_main(int argc, char* argv[]) {\n	(void)argc; (void)argv;\n\n	_vinit();\n	main__main();\n"));
	if (g->autofree) {
		v__gen__Gen_writeln(g, tos_lit("	// Wrap user provided cleanup/free functions for sokol to be able to call _vcleanup()\n	if (g_desc.cleanup_cb) {\n		_vsokol_user_cleanup_ptr = g_desc.cleanup_cb;\n		g_desc.cleanup_cb = _vsokol_cleanup_cb;\n	}\n	else if (g_desc.cleanup_userdata_cb) {\n		_vsokol_user_cleanup_cb_ptr = g_desc.cleanup_userdata_cb;\n		g_desc.cleanup_userdata_cb = _vsokol_cleanup_userdata_cb;\n	}\n"));
	}
	v__gen__Gen_writeln(g, tos_lit("	return g_desc;"));
	v__gen__Gen_writeln(g, tos_lit("}"));
}

void v__gen__Gen_write_tests_main(v__gen__Gen* g) {
	strings__Builder_writeln(&g->includes, tos_lit("#include <setjmp.h> // write_tests_main"));
	strings__Builder_writeln(&g->definitions, tos_lit("int g_test_oks = 0;"));
	strings__Builder_writeln(&g->definitions, tos_lit("int g_test_fails = 0;"));
	strings__Builder_writeln(&g->definitions, tos_lit("jmp_buf g_jump_buffer;"));
	int main_fn_start_pos = g->out.len;
	#if defined(_WIN32)
	{
		v__gen__Gen_writeln(g, tos_lit("int wmain() {"));
	}
	#else
	{
	}
	#endif
	v__gen__Gen_writeln(g, tos_lit("\t_vinit();"));
	v__gen__Gen_writeln(g, tos_lit(""));
	array_string all_tfuncs = v__gen__Gen_get_all_test_function_names(g);
	if (g->pref->is_stats) {
		v__gen__Gen_writeln(g, _STR("\tmain__BenchedTests bt = main__start_testing(%"PRId32"\000, tos_lit(\"%.*s\000\"));", 3, all_tfuncs.len, g->pref->path));
	}
	// FOR IN array
	array _t1517 = all_tfuncs;
	for (int _t1518 = 0; _t1518 < _t1517.len; ++_t1518) {
		string t = ((string*)_t1517.data)[_t1518];
		v__gen__Gen_writeln(g, tos_lit(""));
		if (g->pref->is_stats) {
			v__gen__Gen_writeln(g, _STR("\tmain__BenchedTests_testing_step_start(&bt, tos_lit(\"%.*s\000\"));", 2, t));
		}
		v__gen__Gen_writeln(g, _STR("\tif (!setjmp(g_jump_buffer)) %.*s\000();", 2, t));
		if (g->pref->is_stats) {
			v__gen__Gen_writeln(g, tos_lit("\tmain__BenchedTests_testing_step_end(&bt);"));
		}
	}
	v__gen__Gen_writeln(g, tos_lit(""));
	if (g->pref->is_stats) {
		v__gen__Gen_writeln(g, tos_lit("\tmain__BenchedTests_end_testing(&bt);"));
	}
	v__gen__Gen_writeln(g, tos_lit(""));
	if (g->autofree) {
		v__gen__Gen_writeln(g, tos_lit("\t_vcleanup();"));
	}
	v__gen__Gen_writeln(g, tos_lit("\treturn g_test_fails > 0;"));
	v__gen__Gen_writeln(g, tos_lit("}"));
	if (g->pref->printfn_list.len > 0 && _IN(string, tos_lit("main"), g->pref->printfn_list)) {
		println(strings__Builder_after(&g->out, main_fn_start_pos));
	}
}

VV_LOCAL_SYMBOL void v__gen__Gen_comptime_call(v__gen__Gen* g, v__ast__ComptimeCall node) {
	if (node.is_vweb) {
		bool is_html = string_eq(node.method_name, tos_lit("html"));
		// FOR IN array
		array _t1519 = node.vweb_tmpl.stmts;
		for (int _t1520 = 0; _t1520 < _t1519.len; ++_t1520) {
			v__ast__Stmt stmt = ((v__ast__Stmt*)_t1519.data)[_t1520];
			if ((stmt).typ == 151 /* v.ast.FnDecl */) {
				if (string_starts_with((*stmt._151).name, tos_lit("main.vweb_tmpl"))) {
					if (is_html) {
						g->inside_vweb_tmpl = true;
					}
					v__gen__Gen_stmts(g, (*stmt._151).stmts);
					g->inside_vweb_tmpl = false;
					break;
				}
			}
		}
		if (is_html) {
			v__gen__Gen_writeln(g, _STR("vweb__Context_html(&app->vweb, _tmpl_res_%.*s\000); strings__Builder_free(&sb); string_free(&_tmpl_res_%.*s\000);", 3, g->fn_decl->name, g->fn_decl->name));
		} else {
			string fn_name = string_replace(g->fn_decl->name, tos_lit("."), tos_lit("__"));
			v__gen__Gen_writeln(g, _STR("return _tmpl_res_%.*s\000;", 2, fn_name));
		}
		return;
	}
	v__gen__Gen_writeln(g, string_add(tos_lit("// $"), _STR("method call. sym=\"%.*s\000\"", 2, node.sym.name)));
	int j = 0;
	int result_type = v__table__Table_find_type_idx(g->table, tos_lit("vweb.Result"));
	if (string_eq(node.method_name, tos_lit("method"))) {
		Option_v__table__Fn _t1521 = v__table__TypeSymbol_find_method(&node.sym, g->comp_for_method);
		if (!_t1521.ok) {
			string err = _t1521.v_error;
			int errcode = _t1521.ecode;
			return;
		}
 		v__table__Fn m = *(v__table__Fn*) _t1521.data;
		v__gen__Gen_write(g, _STR("%.*s\000_%.*s\000(", 3, v__util__no_dots(node.sym.name), g->comp_for_method));
		v__gen__Gen_expr(g, node.left);
		if (m.params.len > 1) {
			v__gen__Gen_write(g, tos_lit(", "));
		}
		for (int i = 1; i < m.params.len; ++i) {
			if ((node.left).typ == 224 /* v.ast.Ident */) {
				if (string_eq((*(v__table__Param*)/*ee elem_typ */array_get(m.params, i)).name, (*node.left._224).name)) {
					continue;
				}
			}
			if (v__table__Type_is_int((*(v__table__Param*)/*ee elem_typ */array_get(m.params, i)).typ) || v__table__Type_idx((*(v__table__Param*)/*ee elem_typ */array_get(m.params, i)).typ) == _const_v__table__bool_type_idx) {
				string type_name = v__table__TypeSymbol_str(&(*(v__table__TypeSymbol*)/*ee elem_typ */array_get(g->table->types, ((int)((*(v__table__Param*)/*ee elem_typ */array_get(m.params, i)).typ)))));
				v__gen__Gen_write(g, _STR("string_%.*s\000(((string*)%.*s\000.data) [%"PRId32"\000])", 4, type_name, node.args_var, i - 1));
			} else {
				v__gen__Gen_write(g, _STR("((string*)%.*s\000.data) [%"PRId32"\000] ", 3, node.args_var, i - 1));
			}
			if (i < m.params.len - 1) {
				v__gen__Gen_write(g, tos_lit(", "));
			}
		}
		v__gen__Gen_write(g, tos_lit(" ); // vweb action call with args"));
		return;
	}
	// FOR IN array
	array _t1522 = node.sym.methods;
	for (int _t1523 = 0; _t1523 < _t1522.len; ++_t1523) {
		v__table__Fn method = ((v__table__Fn*)_t1522.data)[_t1523];
		if (method.return_type != result_type) {
			continue;
		}
		if (method.params.len != 1) {
			continue;
		}
		string amp = tos_lit("");
		if (j > 0) {
			v__gen__Gen_write(g, tos_lit(" else "));
		}
		v__gen__Gen_write(g, _STR("if (string_eq(%.*s\000, tos_lit(\"%.*s\000\"))) ", 3, node.method_name, method.name));
		v__gen__Gen_write(g, _STR("%.*s\000_%.*s\000(%.*s\000 ", 4, v__util__no_dots(node.sym.name), method.name, amp));
		v__gen__Gen_expr(g, node.left);
		v__gen__Gen_writeln(g, tos_lit(");"));
		j++;
	}
}

VV_LOCAL_SYMBOL array_string v__gen__cgen_attrs(array_v__table__Attr attrs) {
	array_string res = __new_array_with_default(0, attrs.len, sizeof(string), 0);
	// FOR IN array
	array _t1524 = attrs;
	for (int _t1525 = 0; _t1525 < _t1524.len; ++_t1525) {
		v__table__Attr attr = ((v__table__Attr*)_t1524.data)[_t1525];
		string s = attr.name;
		if (attr.arg.len > 0) {
			s = /*f*/string_add(s, _STR(": %.*s", 1, attr.arg));
		}
		array_push(&res, _MOV((string[]){ string_clone(_STR("tos_lit(\"%.*s\000\")", 2, s)) }));
	}
	return res;
}

VV_LOCAL_SYMBOL void v__gen__Gen_comp_at(v__gen__Gen* g, v__ast__AtExpr node) {
	if (node.kind == v__token__AtKind_vmod_file) {
		string val = string_replace(v__gen__cnewlines(string_replace(node.val, tos_lit("\r"), tos_lit(""))), tos_lit("\\"), tos_lit("\\\\"));
		v__gen__Gen_write(g, _STR("tos_lit(\"%.*s\000\")", 2, val));
	} else {
		string val = string_replace(node.val, tos_lit("\\"), tos_lit("\\\\"));
		v__gen__Gen_write(g, _STR("tos_lit(\"%.*s\000\")", 2, val));
	}
}

VV_LOCAL_SYMBOL void v__gen__Gen_comp_if(v__gen__Gen* g, v__ast__IfExpr node) {
	string _t1527;
	string line = (node.is_expr ? (		_t1527 = v__gen__Gen_go_before_stmt(g, 0),v__gen__Gen_write(g, (*(string*)/*ee elem_typ */array_get(_const_v__gen__tabs, g->indent))),string_trim_space(_t1527)) : (tos_lit("")));
	// FOR IN array
	array _t1528 = node.branches;
	for (int i = 0; i < _t1528.len; ++i) {
		v__ast__IfBranch branch = ((v__ast__IfBranch*)_t1528.data)[i];
		int start_pos = g->out.len;
		if (i == node.branches.len - 1 && node.has_else) {
			v__gen__Gen_writeln(g, tos_lit("#else"));
		} else {
			if (i == 0) {
				v__gen__Gen_write(g, tos_lit("#if "));
			} else {
				v__gen__Gen_write(g, tos_lit("#elif "));
			}
			v__gen__Gen_comp_if_expr(g, branch.cond);
			v__gen__Gen_writeln(g, tos_lit(""));
		}
		string expr_str = string_trim_space(strings__Builder_last_n(&g->out, g->out.len - start_pos));
		g->defer_ifdef = expr_str;
		if (node.is_expr) {
			int len = branch.stmts.len;
			if (len > 0) {
				v__ast__ExprStmt last = /* as */ *(v__ast__ExprStmt*)__as_cast(((*(v__ast__Stmt*)/*ee elem_typ */array_get(branch.stmts, len - 1)))._259, ((*(v__ast__Stmt*)/*ee elem_typ */array_get(branch.stmts, len - 1))).typ, /*expected:*/259);
				if (len > 1) {
					string tmp = v__gen__Gen_new_tmp_var(g);
					string styp = v__gen__Gen_typ(g, last.typ);
					g->indent++;
					v__gen__Gen_writeln(g, _STR("%.*s\000 %.*s\000;", 3, styp, tmp));
					v__gen__Gen_writeln(g, tos_lit("{"));
					v__gen__Gen_stmts(g, array_slice(branch.stmts, 0, len - 1));
					v__gen__Gen_write(g, _STR("\t%.*s\000 = ", 2, tmp));
					v__gen__Gen_stmt(g, /* sum type cast 4 */ (v__ast__Stmt){._259 = memdup(&(v__ast__ExprStmt[]){last}, sizeof(v__ast__ExprStmt)), .typ = 259 /* v.ast.ExprStmt */});
					v__gen__Gen_writeln(g, tos_lit("}"));
					g->indent--;
					v__gen__Gen_writeln(g, _STR("%.*s\000 %.*s\000;", 3, line, tmp));
				} else {
					v__gen__Gen_write(g, _STR("%.*s\000 ", 2, line));
					v__gen__Gen_stmt(g, /* sum type cast 4 */ (v__ast__Stmt){._259 = memdup(&(v__ast__ExprStmt[]){last}, sizeof(v__ast__ExprStmt)), .typ = 259 /* v.ast.ExprStmt */});
				}
			}
		} else {
			bool should_create_scope = g->fn_decl != 0;
			if (should_create_scope) {
				v__gen__Gen_writeln(g, tos_lit("{"));
			}
			v__gen__Gen_stmts(g, branch.stmts);
			if (should_create_scope) {
				v__gen__Gen_writeln(g, tos_lit("}"));
			}
		}
		g->defer_ifdef = tos_lit("");
	}
	if (node.is_expr) {
		v__gen__Gen_write(g, tos_lit("#endif"));
	} else {
		v__gen__Gen_writeln(g, tos_lit("#endif"));
	}
}

VV_LOCAL_SYMBOL void v__gen__Gen_comp_if_expr(v__gen__Gen* g, v__ast__Expr cond) {
	v__ast__Expr _t1529 = cond;
	if (_t1529.typ == 236 /* v.ast.ParExpr */) {
		v__gen__Gen_write(g, tos_lit("("));
		v__gen__Gen_comp_if_expr(g, (*cond._236).expr);
		v__gen__Gen_write(g, tos_lit(")"));
	} else if (_t1529.typ == 238 /* v.ast.PrefixExpr */) {
		v__gen__Gen_write(g, v__token__Kind_str((*cond._238).op));
		v__gen__Gen_comp_if_expr(g, (*cond._238).right);
	} else if (_t1529.typ == 237 /* v.ast.PostfixExpr */) {
		string ifdef = v__gen__Gen_comp_if_to_ifdef(g, (/* as */ *(v__ast__Ident*)__as_cast(((*cond._237).expr)._224, ((*cond._237).expr).typ, /*expected:*/224)).name, true);
		v__gen__Gen_write(g, _STR("defined(%.*s\000)", 2, ifdef));
	} else if (_t1529.typ == 228 /* v.ast.InfixExpr */) {
		v__token__Kind _t1530 = (*cond._228).op;
		if (_t1530 == v__token__Kind_and || _t1530 == v__token__Kind_logical_or) {
			v__gen__Gen_comp_if_expr(g, (*cond._228).left);
			v__gen__Gen_write(g, _STR(" %.*s\000 ", 2, v__token__Kind_str((*cond._228).op)));
			v__gen__Gen_comp_if_expr(g, (*cond._228).right);
		} else if (_t1530 == v__token__Kind_key_is || _t1530 == v__token__Kind_not_is) {
			v__ast__SelectorExpr se = /* as */ *(v__ast__SelectorExpr*)__as_cast(((*cond._228).left)._241, ((*cond._228).left).typ, /*expected:*/241);
			string name = _STR("%.*s\000.%.*s", 2, v__ast__Expr_str(se.expr), se.field_name);
			v__table__Type exp_type = (*(v__table__Type*)map_get(g->comptime_var_type_map, name, &(v__table__Type[]){ 0 }));
			v__table__Type got_type = (/* as */ *(v__ast__Type*)__as_cast(((*cond._228).right)._247, ((*cond._228).right).typ, /*expected:*/247)).typ;
			v__gen__Gen_write(g, _STR("%"PRId32"\000 == %"PRId32"", 2, exp_type, got_type));
		} else if (_t1530 == v__token__Kind_eq || _t1530 == v__token__Kind_ne) {
		} else {
		};
	} else if (_t1529.typ == 224 /* v.ast.Ident */) {
		string ifdef = v__gen__Gen_comp_if_to_ifdef(g, (*cond._224).name, false);
		v__gen__Gen_write(g, _STR("defined(%.*s\000)", 2, ifdef));
	} else {
	};
}

VV_LOCAL_SYMBOL void v__gen__Gen_comp_for(v__gen__Gen* g, v__ast__CompFor node) {
	v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, v__gen__Gen_unwrap_generic(g, node.typ));
	v__gen__Gen_writeln(g, _STR("{ // 2comptime: $for %.*s\000 in %.*s\000(%.*s\000) {", 4, node.val_var, sym->name, v__ast__CompForKind_str(node.kind)));
	int i = 0;
	if (node.kind == v__ast__CompForKind_methods) {

int _t1531_len = sym->methods.len;
		array_v__table__Fn _t1531 = __new_array(0, _t1531_len, sizeof(v__table__Fn));
		for (int i = 0; i < _t1531_len; ++i) {
		  v__table__Fn it = ((v__table__Fn*) sym->methods.data)[i];
		if (it.attrs.len == 0) array_push(&_t1531, &it); 
 }
				array_v__table__Fn methods =  _t1531;

int _t1532_len = sym->methods.len;
		array_v__table__Fn _t1532 = __new_array(0, _t1532_len, sizeof(v__table__Fn));
		for (int i = 0; i < _t1532_len; ++i) {
		  v__table__Fn it = ((v__table__Fn*) sym->methods.data)[i];
		if (it.attrs.len > 0) array_push(&_t1532, &it); 
 }
				array_v__table__Fn methods_with_attrs =  _t1532;
		_PUSH_MANY(&methods, (methods_with_attrs), _t1533, array_v__table__Fn);
		if (methods.len > 0) {
			v__gen__Gen_writeln(g, _STR("\tFunctionData %.*s\000;", 2, node.val_var));
			v__gen__Gen_writeln(g, _STR("\tmemset(&%.*s\000, 0, sizeof(FunctionData));", 2, node.val_var));
		}
		// FOR IN array
		array _t1534 = methods;
		for (int _t1535 = 0; _t1535 < _t1534.len; ++_t1535) {
			v__table__Fn method = ((v__table__Fn*)_t1534.data)[_t1535];
			g->comp_for_method = method.name;
			v__gen__Gen_writeln(g, _STR("\t// method %"PRId32"", 1, i));
			v__gen__Gen_writeln(g, _STR("\t%.*s\000.name = tos_lit(\"%.*s\000\");", 3, node.val_var, method.name));
			if (method.attrs.len == 0) {
				v__gen__Gen_writeln(g, _STR("\t%.*s\000.attrs = __new_array_with_default(0, 0, sizeof(string), 0);", 2, node.val_var));
			} else {
				array_string attrs = v__gen__cgen_attrs(method.attrs);
				v__gen__Gen_writeln(g, string_add(string_add(_STR("\t%.*s\000.attrs = new_array_from_c_array(%"PRId32"\000, %"PRId32"\000, sizeof(string), _MOV((string[%"PRId32"\000]){", 5, node.val_var, attrs.len, attrs.len, attrs.len), array_string_join(attrs, tos_lit(", "))), tos_lit("}));")));
			}
			if (method.params.len < 2) {
				v__gen__Gen_writeln(g, _STR("\t%.*s\000.args = __new_array_with_default(0, 0, sizeof(MethodArgs), 0);", 2, node.val_var));
			} else {
				int len = method.params.len - 1;
				v__gen__Gen_write(g, _STR("\t%.*s\000.args = new_array_from_c_array(%"PRId32"\000, %"PRId32"\000, sizeof(MethodArgs), _MOV((MethodArgs[%"PRId32"\000]){", 5, node.val_var, len, len, len));
				// FOR IN array
				array _t1536 = array_slice(method.params, 1, method.params.len);
				for (int j = 0; j < _t1536.len; ++j) {
					v__table__Param arg = ((v__table__Param*)_t1536.data)[j];
					int typ = v__table__Type_idx(arg.typ);
					v__gen__Gen_write(g, int_str(typ));
					if (j < len - 1) {
						v__gen__Gen_write(g, tos_lit(", "));
					}
					map_set(&g->comptime_var_type_map, _STR("%.*s\000.args[%"PRId32"\000].typ", 3, node.val_var, j), &(v__table__Type[]) { typ });
				}
				v__gen__Gen_writeln(g, tos_lit("}));"));
			}
			string sig = tos_lit("anon_fn_");
			// FOR IN array
			array _t1537 = array_slice(method.params, 1, method.params.len);
			for (int j = 0; j < _t1537.len; ++j) {
				v__table__Param arg = ((v__table__Param*)_t1537.data)[j];
				v__table__Type typ = v__table__Type_set_nr_muls(arg.typ, 0);
				sig = /*f*/string_add(sig, _STR("%"PRId32"", 1, typ));
				if (j < method.params.len - 2) {
					sig = /*f*/string_add(sig, tos_lit("_"));
				}
			}
			sig = /*f*/string_add(sig, _STR("_%"PRId32"", 1, method.return_type));
			int styp = v__table__Table_find_type_idx(g->table, sig);
			int ret_typ = v__table__Type_idx(method.return_type);
			v__gen__Gen_writeln(g, _STR("\t%.*s\000.typ = %"PRId32"\000;", 3, node.val_var, styp));
			v__gen__Gen_writeln(g, _STR("\t%.*s\000.return_type = %"PRId32"\000;", 3, node.val_var, ret_typ));
			map_set(&g->comptime_var_type_map, _STR("%.*s\000.return_type", 2, node.val_var), &(v__table__Type[]) { ret_typ });
			map_set(&g->comptime_var_type_map, _STR("%.*s\000.typ", 2, node.val_var), &(v__table__Type[]) { styp });
			v__gen__Gen_stmts(g, node.stmts);
			i++;
			v__gen__Gen_writeln(g, tos_lit(""));
			// FOR IN map
			map_string_v__table__Type _t1539 = g->comptime_var_type_map;
			for (int _t1538 = 0; _t1538 < _t1539.key_values.len; ++_t1538) {
				if (_t1539.key_values.keys[_t1538].str == 0) {continue;}
				string key = /*key*/ string_clone(_t1539.key_values.keys[_t1538]);
				if (string_starts_with(key, node.val_var)) {
					map_delete(&g->comptime_var_type_map, key);
				}
			}
		}
	} else if (node.kind == v__ast__CompForKind_fields) {
		if ((sym->info).typ == 155 /* v.table.Struct */) {
			v__table__Struct info = /* as */ *(v__table__Struct*)__as_cast((sym->info)._155, (sym->info).typ, /*expected:*/155);

int _t1540_len = info.fields.len;
			array_v__table__Field _t1540 = __new_array(0, _t1540_len, sizeof(v__table__Field));
			for (int i = 0; i < _t1540_len; ++i) {
			  v__table__Field it = ((v__table__Field*) info.fields.data)[i];
			if (it.attrs.len == 0) array_push(&_t1540, &it); 
 }
						array_v__table__Field fields =  _t1540;

int _t1541_len = info.fields.len;
			array_v__table__Field _t1541 = __new_array(0, _t1541_len, sizeof(v__table__Field));
			for (int i = 0; i < _t1541_len; ++i) {
			  v__table__Field it = ((v__table__Field*) info.fields.data)[i];
			if (it.attrs.len > 0) array_push(&_t1541, &it); 
 }
						array_v__table__Field fields_with_attrs =  _t1541;
			_PUSH_MANY(&fields, (fields_with_attrs), _t1542, array_v__table__Field);
			if (fields.len > 0) {
				v__gen__Gen_writeln(g, _STR("\tFieldData %.*s\000;", 2, node.val_var));
				v__gen__Gen_writeln(g, _STR("\tmemset(&%.*s\000, 0, sizeof(FieldData));", 2, node.val_var));
			}
			// FOR IN array
			array _t1543 = fields;
			for (int _t1544 = 0; _t1544 < _t1543.len; ++_t1544) {
				v__table__Field field = ((v__table__Field*)_t1543.data)[_t1544];
				v__gen__Gen_writeln(g, _STR("\t// field %"PRId32"", 1, i));
				v__gen__Gen_writeln(g, _STR("\t%.*s\000.name = tos_lit(\"%.*s\000\");", 3, node.val_var, field.name));
				if (field.attrs.len == 0) {
					v__gen__Gen_writeln(g, _STR("\t%.*s\000.attrs = __new_array_with_default(0, 0, sizeof(string), 0);", 2, node.val_var));
				} else {
					array_string attrs = v__gen__cgen_attrs(field.attrs);
					v__gen__Gen_writeln(g, string_add(string_add(_STR("\t%.*s\000.attrs = new_array_from_c_array(%"PRId32"\000, %"PRId32"\000, sizeof(string), _MOV((string[%"PRId32"\000]){", 5, node.val_var, attrs.len, attrs.len, attrs.len), array_string_join(attrs, tos_lit(", "))), tos_lit("}));")));
				}
				v__table__Type styp = field.typ;
				v__gen__Gen_writeln(g, _STR("\t%.*s\000.typ = %"PRId32"\000;", 3, node.val_var, styp));
				v__gen__Gen_writeln(g, _STR("\t%.*s\000.is_pub = %.*s\000;", 3, node.val_var, field.is_pub ? _SLIT("true") : _SLIT("false")));
				v__gen__Gen_writeln(g, _STR("\t%.*s\000.is_mut = %.*s\000;", 3, node.val_var, field.is_mut ? _SLIT("true") : _SLIT("false")));
				map_set(&g->comptime_var_type_map, _STR("%.*s\000.typ", 2, node.val_var), &(v__table__Type[]) { styp });
				v__gen__Gen_stmts(g, node.stmts);
				i++;
				v__gen__Gen_writeln(g, tos_lit(""));
			}
			map_delete(&g->comptime_var_type_map, node.val_var);
		}
	}
	v__gen__Gen_writeln(g, tos_lit("} // } comptime for"));
}

VV_LOCAL_SYMBOL v__ast__CTempVar v__gen__Gen_new_ctemp_var(v__gen__Gen* g, v__ast__Expr expr, v__table__Type expr_type) {
	return (v__ast__CTempVar){.name = v__gen__Gen_new_tmp_var(g),.orig = expr,.typ = expr_type,.is_ptr = v__table__Type_is_ptr(expr_type),};
}

VV_LOCAL_SYMBOL v__ast__CTempVar v__gen__Gen_new_ctemp_var_then_gen(v__gen__Gen* g, v__ast__Expr expr, v__table__Type expr_type) {
	v__ast__CTempVar x = v__gen__Gen_new_ctemp_var(g, expr, expr_type);
	v__gen__Gen_gen_ctemp_var(g, x);
	return x;
}

VV_LOCAL_SYMBOL void v__gen__Gen_gen_ctemp_var(v__gen__Gen* g, v__ast__CTempVar tvar) {
	string styp = v__gen__Gen_typ(g, tvar.typ);
	v__gen__Gen_write(g, _STR("%.*s\000 %.*s\000 = ", 3, styp, tvar.name));
	v__gen__Gen_expr(g, tvar.orig);
	v__gen__Gen_writeln(g, tos_lit(";"));
}

VV_LOCAL_SYMBOL void v__gen__Gen_gen_fn_decl(v__gen__Gen* g, v__ast__FnDecl it, bool skip) {
	if (it.language == v__table__Language_c) {
		return;
	}
	if (it.is_generic && g->cur_generic_type == 0) {
		// FOR IN array
		array _t1545 = (*(array_v__table__Type*)map_get(g->table->fn_gen_types, it.name, &(array_v__table__Type[]){ __new_array(0, 1, sizeof(v__table__Type)) }));
		for (int _t1546 = 0; _t1546 < _t1545.len; ++_t1546) {
			v__table__Type gen_type = ((v__table__Type*)_t1545.data)[_t1546];
			v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, gen_type);
			if (g->pref->is_verbose) {
				println(_STR("gen fn `%.*s\000` for type `%.*s\000`", 3, it.name, sym->name));
			}
			g->cur_generic_type = gen_type;
			v__gen__Gen_gen_fn_decl(g, it, skip);
		}
		g->cur_generic_type = 0;
		return;
	}
	int fn_start_pos = g->out.len;
	v__gen__Gen_write_v_source_line_info(g, it.pos);
	string msvc_attrs = v__gen__Gen_write_fn_attrs(g, it.attrs);
	bool is_livefn = array_v__table__Attr_contains(it.attrs, tos_lit("live"));
	bool is_livemain = g->pref->is_livemain && is_livefn;
	bool is_liveshared = g->pref->is_liveshared && is_livefn;
	bool is_livemode = g->pref->is_livemain || g->pref->is_liveshared;
	bool is_live_wrap = is_livefn && is_livemode;
	if (is_livefn && !is_livemode) {
		eprintln(_STR("INFO: compile with `v -live %.*s\000 `, if you want to use the [live] function %.*s\000 .", 3, g->pref->path, it.name));
	}
	string name = it.name;
	if ((string_at(name, 0) == '+' || string_at(name, 0) == '-' || string_at(name, 0) == '*' || string_at(name, 0) == '/' || string_at(name, 0) == '%')) {
		name = v__util__replace_op(name);
	}
	if (it.is_method) {
		name = string_add(string_add(v__gen__Gen_cc_type2(g, it.receiver.typ), tos_lit("_")), name);
	}
	if (it.language == v__table__Language_c) {
		name = v__util__no_dots(name);
	} else {
		name = v__gen__c_name(name);
	}
	string type_name = v__gen__Gen_typ(g, it.return_type);
	if (g->cur_generic_type != 0) {
		string gen_name = v__gen__Gen_typ(g, g->cur_generic_type);
		name = /*f*/string_add(name, string_add(tos_lit("_T_"), gen_name));
	}
	if (is_livemain) {
		array_push(&g->hotcode_fn_names, _MOV((string[]){ string_clone(name) }));
	}
	string impl_fn_name = name;
	if (is_live_wrap) {
		impl_fn_name = _STR("impl_live_%.*s", 1, name);
	}
	g->last_fn_c_name = impl_fn_name;
	if (is_live_wrap) {
		if (is_livemain) {
			strings__Builder_write(&g->definitions, _STR("%.*s\000 (* %.*s\000)(", 3, type_name, impl_fn_name));
			v__gen__Gen_write(g, _STR("%.*s\000 no_impl_%.*s\000(", 3, type_name, name));
		}
		if (is_liveshared) {
			strings__Builder_write(&g->definitions, _STR("%.*s\000 %.*s\000(", 3, type_name, impl_fn_name));
			v__gen__Gen_write(g, _STR("%.*s\000 %.*s\000(", 3, type_name, impl_fn_name));
		}
	} else {
		if (!(it.is_pub || g->pref->is_debug)) {
			if (g->pref->build_mode != v__pref__BuildMode_build_module) {
				v__gen__Gen_write(g, tos_lit("VV_LOCAL_SYMBOL "));
				strings__Builder_write(&g->definitions, tos_lit("VV_LOCAL_SYMBOL "));
			}
		}
		string fn_header = (msvc_attrs.len > 0 ? (_STR("%.*s\000 %.*s\000 %.*s\000(", 4, type_name, msvc_attrs, name)) : (_STR("%.*s\000 %.*s\000(", 3, type_name, name)));
		strings__Builder_write(&g->definitions, fn_header);
		v__gen__Gen_write(g, fn_header);
	}
	int arg_start_pos = g->out.len;
	multi_return_array_string_array_string mr_3739 = v__gen__Gen_fn_args(g, it.params, it.is_variadic);
	array_string fargs = mr_3739.arg0;
	array_string fargtypes = mr_3739.arg1;
	string arg_str = strings__Builder_after(&g->out, arg_start_pos);
	if (it.no_body || (g->pref->use_cache && it.is_builtin) || skip) {
		strings__Builder_writeln(&g->definitions, tos_lit(");"));
		v__gen__Gen_writeln(g, tos_lit(");"));
		return;
	}
	strings__Builder_writeln(&g->definitions, tos_lit(");"));
	v__gen__Gen_writeln(g, tos_lit(") {"));
	if (is_live_wrap) {
		array_string fn_args_list = __new_array_with_default(0, 0, sizeof(string), 0);
		// FOR IN array
		array _t1548 = fargs;
		for (int ia = 0; ia < _t1548.len; ++ia) {
			string fa = ((string*)_t1548.data)[ia];
			array_push(&fn_args_list, _MOV((string[]){ string_clone(_STR("%.*s\000 %.*s", 2, (*(string*)/*ee elem_typ */array_get(fargtypes, ia)), fa)) }));
		}
		string live_fncall = string_add(string_add(_STR("%.*s\000(", 2, impl_fn_name), array_string_join(fargs, tos_lit(", "))), tos_lit(");"));
		string live_fnreturn = tos_lit("");
		if (string_ne(type_name, tos_lit("void"))) {
			live_fncall = _STR("%.*s\000 res = %.*s", 2, type_name, live_fncall);
			live_fnreturn = tos_lit("return res;");
		}
		strings__Builder_writeln(&g->definitions, string_add(string_add(_STR("%.*s\000 %.*s\000(", 3, type_name, name), array_string_join(fn_args_list, tos_lit(", "))), tos_lit(");")));
		strings__Builder_writeln(&g->hotcode_definitions, string_add(string_add(_STR("%.*s\000 %.*s\000(", 3, type_name, name), array_string_join(fn_args_list, tos_lit(", "))), tos_lit("){")));
		strings__Builder_writeln(&g->hotcode_definitions, tos_lit("  pthread_mutex_lock(&live_fn_mutex);"));
		strings__Builder_writeln(&g->hotcode_definitions, _STR("  %.*s", 1, live_fncall));
		strings__Builder_writeln(&g->hotcode_definitions, tos_lit("  pthread_mutex_unlock(&live_fn_mutex);"));
		strings__Builder_writeln(&g->hotcode_definitions, _STR("  %.*s", 1, live_fnreturn));
		strings__Builder_writeln(&g->hotcode_definitions, tos_lit("}"));
	}
	if (g->pref->is_prof) {
		v__gen__Gen_profile_fn(g, it);
	}
	v__gen__Gen_stmts(g, it.stmts);
	if (it.return_type == _const_v__table__void_type) {
		v__gen__Gen_write_defer_stmts_when_needed(g);
	}
	if (it.return_type != _const_v__table__void_type && it.stmts.len > 0 && (*(v__ast__Stmt*)array_last(it.stmts)).typ != 271 /* v.ast.Return */) {
		string default_expr = v__gen__Gen_type_default(g, it.return_type);
		if (string_eq(default_expr, tos_lit("{0}"))) {
			v__gen__Gen_writeln(g, _STR("\treturn (%.*s\000)%.*s\000;", 3, type_name, default_expr));
		} else {
			v__gen__Gen_writeln(g, _STR("\treturn %.*s\000;", 2, default_expr));
		}
	}
	v__gen__Gen_writeln(g, tos_lit("}"));
	g->defer_stmts = __new_array_with_default(0, 0, sizeof(v__ast__DeferStmt), 0);
	if (g->pref->printfn_list.len > 0 && _IN(string, g->last_fn_c_name, g->pref->printfn_list)) {
		println(strings__Builder_after(&g->out, fn_start_pos));
	}
	// FOR IN array
	array _t1550 = it.attrs;
	for (int _t1551 = 0; _t1551 < _t1550.len; ++_t1551) {
		v__table__Attr attr = ((v__table__Attr*)_t1550.data)[_t1551];
		if (string_eq(attr.name, tos_lit("export"))) {
			v__gen__Gen_writeln(g, _STR("// export alias: %.*s\000 -> %.*s", 2, attr.arg, name));
			string export_alias = _STR("%.*s\000 %.*s\000(%.*s\000)", 4, type_name, attr.arg, arg_str);
			strings__Builder_writeln(&g->definitions, _STR("VV_EXPORTED_SYMBOL %.*s\000; // exported fn %.*s", 2, export_alias, it.name));
			v__gen__Gen_writeln(g, _STR("%.*s\000 {", 2, export_alias));
			v__gen__Gen_write(g, _STR("\treturn %.*s\000(", 2, name));
			v__gen__Gen_write(g, array_string_join(fargs, tos_lit(", ")));
			v__gen__Gen_writeln(g, tos_lit(");"));
			v__gen__Gen_writeln(g, tos_lit("}"));
		}
	}
}

VV_LOCAL_SYMBOL void v__gen__Gen_write_defer_stmts_when_needed(v__gen__Gen* g) {
	if (g->defer_stmts.len > 0) {
		v__gen__Gen_write_defer_stmts(g);
	}
	if (g->defer_profile_code.len > 0) {
		v__gen__Gen_writeln(g, tos_lit(""));
		v__gen__Gen_writeln(g, tos_lit("\t// defer_profile_code"));
		v__gen__Gen_writeln(g, g->defer_profile_code);
		v__gen__Gen_writeln(g, tos_lit(""));
	}
}

VV_LOCAL_SYMBOL multi_return_array_string_array_string v__gen__Gen_fn_args(v__gen__Gen* g, array_v__table__Param args, bool is_variadic) {
	array_string fargs = __new_array_with_default(0, 0, sizeof(string), 0);
	array_string fargtypes = __new_array_with_default(0, 0, sizeof(string), 0);
	// FOR IN array
	array _t1552 = args;
	for (int i = 0; i < _t1552.len; ++i) {
		v__table__Param arg = ((v__table__Param*)_t1552.data)[i];
		string caname = v__gen__c_name(arg.name);
		v__table__Type typ = v__gen__Gen_unwrap_generic(g, arg.typ);
		v__table__TypeSymbol* arg_type_sym = v__table__Table_get_type_symbol(g->table, typ);
		string arg_type_name = v__gen__Gen_typ(g, typ);
		bool is_varg = i == args.len - 1 && is_variadic;
		if (is_varg) {
			string varg_type_str = int_str(((int)(arg.typ)));
			if (!_IN_MAP(varg_type_str, g->variadic_args)) {
				map_set(&g->variadic_args, varg_type_str, &(int[]) { 0 });
			}
			arg_type_name = string_add(tos_lit("varg_"), string_replace(v__gen__Gen_typ(g, arg.typ), tos_lit("*"), tos_lit("_ptr")));
		}
		if (arg_type_sym->kind == v__table__Kind_function) {
			v__table__FnType info = /* as */ *(v__table__FnType*)__as_cast((arg_type_sym->info)._353, (arg_type_sym->info).typ, /*expected:*/353);
			v__table__Fn func = info.func;
			if (!info.is_anon) {
				v__gen__Gen_write(g, string_add(string_add(arg_type_name, tos_lit(" ")), caname));
				strings__Builder_write(&g->definitions, string_add(string_add(arg_type_name, tos_lit(" ")), caname));
				array_push(&fargs, _MOV((string[]){ string_clone(caname) }));
				array_push(&fargtypes, _MOV((string[]){ string_clone(arg_type_name) }));
			} else {
				v__gen__Gen_write(g, _STR("%.*s\000 (*%.*s\000)(", 3, v__gen__Gen_typ(g, func.return_type), caname));
				strings__Builder_write(&g->definitions, _STR("%.*s\000 (*%.*s\000)(", 3, v__gen__Gen_typ(g, func.return_type), caname));
				v__gen__Gen_fn_args(g, func.params, func.is_variadic);
				v__gen__Gen_write(g, tos_lit(")"));
				strings__Builder_write(&g->definitions, tos_lit(")"));
			}
		} else {
			string s = string_add(string_add(arg_type_name, tos_lit(" ")), caname);
			v__gen__Gen_write(g, s);
			strings__Builder_write(&g->definitions, s);
			array_push(&fargs, _MOV((string[]){ string_clone(caname) }));
			array_push(&fargtypes, _MOV((string[]){ string_clone(arg_type_name) }));
		}
		if (i < args.len - 1) {
			v__gen__Gen_write(g, tos_lit(", "));
			strings__Builder_write(&g->definitions, tos_lit(", "));
		}
	}
	return (multi_return_array_string_array_string){.arg0=fargs, .arg1=fargtypes};
}

VV_LOCAL_SYMBOL void v__gen__Gen_call_expr(v__gen__Gen* g, v__ast__CallExpr node) {
	if ((node.left).typ == 208 /* v.ast.AnonFn */) {
		v__gen__Gen_expr(g, node.left);
	}
	if (node.should_be_skipped) {
		return;
	}
	g->inside_call = true;
	bool gen_or = node.or_block.kind != v__ast__OrKind_absent && !g->pref->autofree;
	bool is_gen_or_and_assign_rhs = gen_or && g->is_assign_rhs;
	string _t1557;
	string cur_line = (is_gen_or_and_assign_rhs && !g->pref->autofree ? (		_t1557 = v__gen__Gen_go_before_stmt(g, 0),strings__Builder_write(&g->out, (*(string*)/*ee elem_typ */array_get(_const_v__gen__tabs, g->indent))),_t1557) : (tos_lit("")));
	string tmp_opt = (gen_or ? (v__gen__Gen_new_tmp_var(g)) : (tos_lit("")));
	if (gen_or) {
		string styp = v__gen__Gen_typ(g, v__table__Type_set_flag(node.return_type, v__table__TypeFlag_optional));
		v__gen__Gen_write(g, _STR("%.*s\000 %.*s\000 = ", 3, styp, tmp_opt));
	}
	if (node.is_method && !node.is_field) {
		if (string_eq(node.name, tos_lit("writeln")) && g->pref->experimental && node.args.len > 0 && ((*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr).typ == 244 /* v.ast.StringInterLiteral */ && string_eq(v__table__Table_get_type_symbol(g->table, node.receiver_type)->name, tos_lit("strings.Builder"))) {
			v__gen__Gen_string_inter_literal_sb_optimized(g, node);
		} else {
			v__gen__Gen_method_call(g, node);
		}
	} else {
		v__gen__Gen_fn_call(g, node);
	}
	if (gen_or) {
		if (!g->pref->autofree) {
			v__gen__Gen_or_block(g, tmp_opt, node.or_block, node.return_type);
		}
		if (is_gen_or_and_assign_rhs) {
			v__gen__Gen_write(g, _STR("\n %.*s\000 %.*s", 2, cur_line, tmp_opt));
		}
	}
// Defer begin
g->inside_call = false;
// Defer end
}

// Attr: [inline]
inline v__table__Type v__gen__Gen_unwrap_generic(v__gen__Gen* g, v__table__Type typ) {
	if (v__table__Type_has_flag(typ, v__table__TypeFlag_generic)) {
		return v__table__Type_clear_flag(v__table__Type_derive(g->cur_generic_type, typ), v__table__TypeFlag_generic);
	}
	return typ;
}

VV_LOCAL_SYMBOL void v__gen__Gen_method_call(v__gen__Gen* g, v__ast__CallExpr node) {
	if (node.left_type == 0) {
		v__gen__Gen_checker_bug(g, tos_lit("CallExpr.left_type is 0 in method_call"), node.pos);
	}
	if (node.receiver_type == 0) {
		v__gen__Gen_checker_bug(g, tos_lit("CallExpr.receiver_type is 0 in method_call"), node.pos);
	}
	v__table__TypeSymbol* typ_sym = v__table__Table_get_type_symbol(g->table, v__gen__Gen_unwrap_generic(g, node.receiver_type));
	string receiver_type_name = v__util__no_dots(v__gen__Gen_cc_type2(g, v__gen__Gen_unwrap_generic(g, node.receiver_type)));
	if (typ_sym->kind == v__table__Kind_interface_) {
		v__gen__Gen_write(g, _STR("%.*s\000_name_table[", 2, v__gen__c_name(receiver_type_name)));
		v__gen__Gen_expr(g, node.left);
		string dot = (v__table__Type_is_ptr(node.left_type) ? (tos_lit("->")) : (tos_lit(".")));
		v__gen__Gen_write(g, _STR("%.*s\000_interface_idx].%.*s\000(", 3, dot, node.name));
		v__gen__Gen_expr(g, node.left);
		v__gen__Gen_write(g, _STR("%.*s\000_object", 2, dot));
		if (node.args.len > 0) {
			v__gen__Gen_write(g, tos_lit(", "));
			v__gen__Gen_call_args(g, node);
		}
		v__gen__Gen_write(g, tos_lit(")"));
		return;
	}
	v__table__TypeSymbol* left_sym = v__table__Table_get_type_symbol(g->table, node.left_type);
	if (left_sym->kind == v__table__Kind_array) {
		string _t1558 = node.name;
		if (string_eq(_t1558, tos_lit("filter"))) {
			v__gen__Gen_gen_array_filter(g, node);
			return;
		} else if (string_eq(_t1558, tos_lit("sort"))) {
			v__gen__Gen_gen_array_sort(g, node);
			return;
		} else if (string_eq(_t1558, tos_lit("insert"))) {
			v__gen__Gen_gen_array_insert(g, node);
			return;
		} else if (string_eq(_t1558, tos_lit("map"))) {
			v__gen__Gen_gen_array_map(g, node);
			return;
		} else if (string_eq(_t1558, tos_lit("prepend"))) {
			v__gen__Gen_gen_array_prepend(g, node);
			return;
		} else {
		};
	}
	if (left_sym->kind == v__table__Kind_sum_type && string_eq(node.name, tos_lit("type_name"))) {
		v__gen__Gen_write(g, _STR("tos3( /* %.*s\000 */ v_typeof_sumtype_%"PRId32"\000( (", 3, left_sym->name, node.receiver_type));
		v__gen__Gen_expr(g, node.left);
		v__gen__Gen_write(g, tos_lit(").typ ))"));
		return;
	}
	if (string_eq(node.name, tos_lit("str"))) {
		string styp = v__gen__Gen_typ(g, node.receiver_type);
		if (v__table__Type_is_ptr(node.receiver_type)) {
			styp = string_replace(styp, tos_lit("*"), tos_lit(""));
		}
		v__gen__Gen_gen_str_for_type_with_styp(g, node.receiver_type, styp);
	}
	if (left_sym->kind == v__table__Kind_array && (string_eq(node.name, tos_lit("repeat")) || string_eq(node.name, tos_lit("sort_with_compare")) || string_eq(node.name, tos_lit("free")) || string_eq(node.name, tos_lit("push_many")) || string_eq(node.name, tos_lit("trim")) || string_eq(node.name, tos_lit("first")) || string_eq(node.name, tos_lit("last")) || string_eq(node.name, tos_lit("pop")) || string_eq(node.name, tos_lit("clone")) || string_eq(node.name, tos_lit("reverse")) || string_eq(node.name, tos_lit("slice")))) {
		receiver_type_name = tos_lit("array");
		if ((string_eq(node.name, tos_lit("last")) || string_eq(node.name, tos_lit("first")) || string_eq(node.name, tos_lit("pop")))) {
			string return_type_str = v__gen__Gen_typ(g, node.return_type);
			v__gen__Gen_write(g, _STR("*(%.*s\000*)", 2, return_type_str));
		}
	}
	string name = v__util__no_dots(_STR("%.*s\000_%.*s", 2, receiver_type_name, node.name));
	if (left_sym->kind == v__table__Kind_chan) {
		if ((string_eq(node.name, tos_lit("close")) || string_eq(node.name, tos_lit("try_pop")) || string_eq(node.name, tos_lit("try_push")))) {
			name = _STR("sync__Channel_%.*s", 1, node.name);
		}
	}
	bool is_range_slice = false;
	if (v__table__Type_is_ptr(node.receiver_type) && !v__table__Type_is_ptr(node.left_type)) {
		if ((node.left).typ == 227 /* v.ast.IndexExpr */) {
			v__ast__Expr idx = (*node.left._227).index;
			if ((idx).typ == 239 /* v.ast.RangeExpr */) {
				name = v__util__no_dots(_STR("%.*s\000_%.*s\000_static", 3, receiver_type_name, node.name));
				is_range_slice = true;
			}
		}
	}
	if (!v__table__Type_is_ptr(node.receiver_type) && v__table__Type_is_ptr(node.left_type) && string_eq(node.name, tos_lit("str"))) {
		v__gen__Gen_write(g, tos_lit("ptr_str("));
	} else {
		v__gen__Gen_write(g, _STR("%.*s\000(", 2, name));
	}
	if (v__table__Type_is_ptr(node.receiver_type) && !v__table__Type_is_ptr(node.left_type)) {
		if (!is_range_slice) {
			v__gen__Gen_write(g, tos_lit("&"));
		}
	} else if (!v__table__Type_is_ptr(node.receiver_type) && v__table__Type_is_ptr(node.left_type) && string_ne(node.name, tos_lit("str"))) {
		v__gen__Gen_write(g, tos_lit("/*rec*/*"));
	}
	if (node.free_receiver && !g->inside_lambda) {
		string fn_name = string_replace(node.name, tos_lit("."), tos_lit("_"));
		string arg_name = _STR("_arg_expr_%.*s\000_0_%"PRId32"", 2, fn_name, node.pos.pos);
		v__gen__Gen_write(g, string_add(tos_lit("/*af receiver arg*/"), arg_name));
	} else {
		v__gen__Gen_expr(g, node.left);
	}
	bool is_variadic = node.expected_arg_types.len > 0 && v__table__Type_has_flag((*(v__table__Type*)/*ee elem_typ */array_get(node.expected_arg_types, node.expected_arg_types.len - 1)), v__table__TypeFlag_variadic);
	if (node.args.len > 0 || is_variadic) {
		v__gen__Gen_write(g, tos_lit(", "));
	}
	v__gen__Gen_call_args(g, node);
	v__gen__Gen_write(g, tos_lit(")"));
}

VV_LOCAL_SYMBOL void v__gen__Gen_fn_call(v__gen__Gen* g, v__ast__CallExpr node) {
	if (node.left_type != 0) {
		v__gen__Gen_expr(g, node.left);
		if (v__table__Type_is_ptr(node.left_type)) {
			v__gen__Gen_write(g, tos_lit("->"));
		} else {
			v__gen__Gen_write(g, tos_lit("."));
		}
	}
	string name = node.name;
	bool is_print = string_eq(name, tos_lit("println")) || string_eq(name, tos_lit("print"));
	string print_method = (string_eq(name, tos_lit("println")) ? (tos_lit("println")) : (tos_lit("print")));
	bool is_json_encode = string_eq(name, tos_lit("json.encode"));
	bool is_json_decode = string_eq(name, tos_lit("json.decode"));
	g->is_json_fn = is_json_encode || is_json_decode;
	string json_type_str = tos_lit("");
	string json_obj = tos_lit("");
	if (g->is_json_fn) {
		json_obj = v__gen__Gen_new_tmp_var(g);
		string tmp2 = tos_lit("");
		string cur_line = v__gen__Gen_go_before_stmt(g, 0);
		if (is_json_encode) {
			v__gen__Gen_gen_json_for_type(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).typ);
			json_type_str = v__gen__Gen_typ(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).typ);
			string encode_name = string_add(string_add(v__gen__c_name(name), tos_lit("_")), v__util__no_dots(json_type_str));
			v__gen__Gen_writeln(g, tos_lit("// json.encode"));
			v__gen__Gen_write(g, _STR("cJSON* %.*s\000 = %.*s\000(", 3, json_obj, encode_name));
			v__gen__Gen_call_args(g, node);
			v__gen__Gen_writeln(g, tos_lit(");"));
			tmp2 = v__gen__Gen_new_tmp_var(g);
			v__gen__Gen_writeln(g, _STR("string %.*s\000 = json__json_print(%.*s\000);", 3, tmp2, json_obj));
		} else {
			v__ast__Type ast_type = /* as */ *(v__ast__Type*)__as_cast(((*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr)._247, ((*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr).typ, /*expected:*/247);
			string typ = v__gen__c_name(v__gen__Gen_typ(g, ast_type.typ));
			string fn_name = string_add(string_add(v__gen__c_name(name), tos_lit("_")), typ);
			v__gen__Gen_gen_json_for_type(g, ast_type.typ);
			v__gen__Gen_writeln(g, tos_lit("// json.decode"));
			v__gen__Gen_write(g, _STR("cJSON* %.*s\000 = json__json_parse(", 2, json_obj));
			g->is_js_call = true;
			v__gen__Gen_call_args(g, node);
			g->is_js_call = false;
			v__gen__Gen_writeln(g, tos_lit(");"));
			tmp2 = v__gen__Gen_new_tmp_var(g);
			v__gen__Gen_writeln(g, _STR("Option_%.*s\000 %.*s\000 = %.*s\000 (%.*s\000);", 5, typ, tmp2, fn_name, json_obj));
		}
		if (!g->pref->autofree) {
			v__gen__Gen_write(g, _STR("cJSON_Delete(%.*s\000); //del", 2, json_obj));
		}
		v__gen__Gen_write(g, _STR("\n%.*s", 1, cur_line));
		name = tos_lit("");
		json_obj = tmp2;
	}
	if (node.language == v__table__Language_c) {
		g->is_c_call = true;
		name = v__util__no_dots(string_substr(name, 2, name.len));
	} else {
		name = v__gen__c_name(name);
	}
	if (node.generic_type != _const_v__table__void_type && node.generic_type != 0) {
		name = /*f*/string_add(name, string_add(tos_lit("_T_"), v__gen__Gen_typ(g, node.generic_type)));
	}
	bool print_auto_str = false;
	if (is_print && (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).typ != _const_v__table__string_type) {
		v__table__Type typ = (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).typ;
		if (typ == 0) {
			v__gen__Gen_checker_bug(g, tos_lit("print arg.typ is 0"), node.pos);
		}
		v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, typ);
		if ((sym->info).typ == 347 /* v.table.Alias */) {
			typ = (*sym->info._347).parent_type;
			sym = v__table__Table_get_type_symbol(g->table, typ);
		}
		if (typ != _const_v__table__string_type) {
			string styp = v__gen__Gen_typ(g, typ);
			if (v__table__Type_is_ptr(typ)) {
				styp = string_replace(styp, tos_lit("*"), tos_lit(""));
			}
			string str_fn_name = v__gen__Gen_gen_str_for_type_with_styp(g, typ, styp);
			if (g->autofree && !v__table__Type_has_flag(typ, v__table__TypeFlag_optional)) {
				string tmp = v__gen__Gen_new_tmp_var(g);
				v__gen__Gen_write(g, _STR("string %.*s\000 = %.*s\000(", 3, tmp, str_fn_name));
				v__gen__Gen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
				v__gen__Gen_writeln(g, _STR("); %.*s\000(%.*s\000); string_free(&%.*s\000); //MEM2 %.*s", 4, print_method, tmp, tmp, styp));
			} else {
				v__ast__Expr expr = (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr;
				v__ast__Expr _t1559 = expr;
								bool is_var = ((_t1559.typ == 241 /* v.ast.SelectorExpr */) ? (true) : (_t1559.typ == 224 /* v.ast.Ident */) ? (true) : (false));
				if (v__table__Type_is_ptr(typ) && sym->kind != v__table__Kind_struct_) {
					styp = tos_lit("ptr");
					str_fn_name = tos_lit("ptr_str");
				}
				if (sym->kind == v__table__Kind_enum_) {
					if (is_var) {
						v__gen__Gen_write(g, _STR("%.*s\000(%.*s\000(", 3, print_method, str_fn_name));
					} else {
						v__gen__Gen_write(g, _STR("%.*s\000(tos3(\"", 2, print_method));
					}
					if (v__table__Type_is_ptr(typ)) {
						v__gen__Gen_write(g, tos_lit("*"));
					}
					v__gen__Gen_enum_expr(g, expr);
					if (!is_var) {
						v__gen__Gen_write(g, tos_lit("\""));
					}
				} else {
					v__gen__Gen_write(g, _STR("%.*s\000(%.*s\000(", 3, print_method, str_fn_name));
					if (v__table__Type_is_ptr(typ) && sym->kind == v__table__Kind_struct_) {
						v__gen__Gen_write(g, tos_lit("*"));
					}
					v__gen__Gen_expr(g, expr);
				}
				v__gen__Gen_write(g, tos_lit("))"));
			}
			print_auto_str = true;
		}
	}
	if (!print_auto_str) {
		if (g->pref->is_debug && string_eq(node.name, tos_lit("panic"))) {
			multi_return_int_string_string_string mr_18631 = v__gen__Gen_panic_debug_info(g, node.pos);
			int paline = mr_18631.arg0;
			string pafile = mr_18631.arg1;
			string pamod = mr_18631.arg2;
			string pafn = mr_18631.arg3;
			v__gen__Gen_write(g, _STR("panic_debug(%"PRId32"\000, tos3(\"%.*s\000\"), tos3(\"%.*s\000\"), tos3(\"%.*s\000\"),  ", 5, paline, pafile, pamod, pafn));
			v__gen__Gen_call_args(g, node);
			v__gen__Gen_write(g, tos_lit(")"));
		} else {
			v__gen__Gen_write(g, _STR("%.*s\000(", 2, v__gen__Gen_get_ternary_name(g, name)));
			if (g->is_json_fn) {
				v__gen__Gen_write(g, json_obj);
			} else {
				v__gen__Gen_call_args(g, node);
			}
			v__gen__Gen_write(g, tos_lit(")"));
		}
	}
	g->is_c_call = false;
	g->is_json_fn = false;
}

VV_LOCAL_SYMBOL void v__gen__Gen_autofree_call_pregen(v__gen__Gen* g, v__ast__CallExpr node) {
	bool free_tmp_arg_vars = g->autofree && !g->is_builtin_mod && node.args.len > 0 && !v__table__Type_has_flag((*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).typ, v__table__TypeFlag_optional);
	if (!free_tmp_arg_vars) {
		return;
	}
	if (g->is_js_call) {
		return;
	}
	if (g->inside_const) {
		return;
	}
	free_tmp_arg_vars = false;
	g->tmp_count2++;
	v__ast__Scope* scope = v__ast__Scope_innermost(g->file.scope, node.pos.pos);
	array_v__ast__CallArg args = new_array_from_c_array(1, 1, sizeof(v__ast__CallArg), _MOV((v__ast__CallArg[1]){(v__ast__CallArg){.is_mut = 0,.share = 0,.expr = node.left,.comments = __new_array(0, 1, sizeof(v__ast__Comment)),.typ = node.receiver_type,.is_tmp_autofree = node.free_receiver,.pos = {0},}}));
	_PUSH_MANY(&args, (node.args), _t1560, array_v__ast__CallArg);
	// FOR IN array
	array _t1561 = args;
	for (int i = 0; i < _t1561.len; ++i) {
		v__ast__CallArg arg = ((v__ast__CallArg*)_t1561.data)[i];
		if (!arg.is_tmp_autofree) {
			continue;
		}
		if ((arg.expr).typ == 215 /* v.ast.CallExpr */) {
			v__gen__Gen_autofree_call_pregen(g, (*arg.expr._215));
		}
		free_tmp_arg_vars = true;
		string fn_name = string_replace(node.name, tos_lit("."), tos_lit("_"));
		string t = _STR("_arg_expr_%.*s\000_%"PRId32"\000_%"PRId32"", 3, fn_name, i, node.pos.pos);
		bool used = false;
		string s = _STR("%.*s\000 = ", 2, t);
		if (used) {
			{ /* if guard */ 
			Option_v__ast__ScopeObject _t1562;
			if (_t1562 = v__ast__Scope_find(scope, t), _t1562.ok) {
				v__ast__ScopeObject x = *(v__ast__ScopeObject*)_t1562.data;
				v__ast__ScopeObject _t1563 = x;
				if (_t1563.typ == 277 /* v.ast.Var */) {
					(*x._277).is_used = false;
				} else {
				};
			}}
			s = _STR("%.*s\000 = ", 2, t);
		} else {
			v__ast__Scope_register(scope, t, /* sum type cast 4 */ (v__ast__ScopeObject){._277 = memdup(&(v__ast__Var[]){(v__ast__Var){.name = t,.expr = {0},.share = 0,.is_mut = 0,.is_autofree_tmp = true,.is_arg = 0,.typ = _const_v__table__string_type,.sum_type_casts = __new_array(0, 1, sizeof(v__table__Type)),.pos = {0},.is_used = 0,.is_changed = 0,}}, sizeof(v__ast__Var)), .typ = 277 /* v.ast.Var */});
			s = _STR("string %.*s\000 = ", 2, t);
		}
		s = /*f*/string_add(s, v__gen__Gen_write_expr_to_string(g, arg.expr));
		s = /*f*/string_add(s, tos_lit(";// new af2 pre"));
		array_push(&g->strs_to_free0, _MOV((string[]){ string_clone(s) }));
	}
}

VV_LOCAL_SYMBOL void v__gen__Gen_autofree_call_postgen(v__gen__Gen* g, int node_pos) {
	if (g->inside_vweb_tmpl) {
		return;
	}
	v__ast__Scope* scope = v__ast__Scope_innermost(g->file.scope, node_pos);
	// FOR IN map
	map_string_v__ast__ScopeObject _t1566 = scope->objects;
	for (int _t1565 = 0; _t1565 < _t1566.key_values.len; ++_t1565) {
		if (_t1566.key_values.keys[_t1565].str == 0) {continue;}
		v__ast__ScopeObject obj = (*(v__ast__ScopeObject*)(void*)(_t1566.key_values.values + _t1565 * (u32)(_t1566.value_bytes)));
		v__ast__ScopeObject _t1567 = obj;
		if (_t1567.typ == 277 /* v.ast.Var */) {
			bool is_optional = v__table__Type_has_flag((*obj._277).typ, v__table__TypeFlag_optional);
			if (is_optional) {
				continue;
			}
			if (!(*obj._277).is_autofree_tmp) {
				continue;
			}
			if ((*obj._277).is_used) {
				continue;
			}
			(*obj._277).is_used = true;
			v__gen__Gen_autofree_variable(g, (*obj._277));
		} else {
		};
	}
}

VV_LOCAL_SYMBOL void v__gen__Gen_call_args(v__gen__Gen* g, v__ast__CallExpr node) {
	array_v__ast__CallArg args = (g->is_js_call ? (array_slice(node.args, 1, node.args.len)) : (node.args));
	array_v__table__Type expected_types = node.expected_arg_types;
	bool is_variadic = expected_types.len > 0 && v__table__Type_has_flag((*(v__table__Type*)/*ee elem_typ */array_get(expected_types, expected_types.len - 1)), v__table__TypeFlag_variadic);
	bool is_forwarding_varg = args.len > 0 && v__table__Type_has_flag((*(v__ast__CallArg*)/*ee elem_typ */array_get(args, args.len - 1)).typ, v__table__TypeFlag_variadic);
	bool gen_vargs = is_variadic && !is_forwarding_varg;
	// FOR IN array
	array _t1568 = args;
	for (int i = 0; i < _t1568.len; ++i) {
		v__ast__CallArg arg = ((v__ast__CallArg*)_t1568.data)[i];
		if (gen_vargs && i == expected_types.len - 1) {
			break;
		}
		bool use_tmp_var_autofree = g->autofree && arg.typ == _const_v__table__string_type && arg.is_tmp_autofree && !g->inside_const;
		bool is_interface = false;
		if (i < expected_types.len) {
			if ((*(v__table__Type*)/*ee elem_typ */array_get(expected_types, i)) != 0) {
				v__table__TypeSymbol* exp_sym = v__table__Table_get_type_symbol(g->table, (*(v__table__Type*)/*ee elem_typ */array_get(expected_types, i)));
				if (exp_sym->kind == v__table__Kind_interface_) {
					v__gen__Gen_interface_call(g, arg.typ, (*(v__table__Type*)/*ee elem_typ */array_get(expected_types, i)));
					is_interface = true;
				}
			}
			if (is_interface) {
				v__gen__Gen_expr(g, arg.expr);
			} else if (use_tmp_var_autofree) {
				if (arg.is_tmp_autofree) {
					string fn_name = string_replace(node.name, tos_lit("."), tos_lit("_"));
					string name = _STR("_arg_expr_%.*s\000_%"PRId32"\000_%"PRId32"", 3, fn_name, i + 1, node.pos.pos);
					v__gen__Gen_write(g, string_add(tos_lit("/*af arg*/"), name));
				}
			} else {
				v__gen__Gen_ref_or_deref_arg(g, arg, (*(v__table__Type*)/*ee elem_typ */array_get(expected_types, i)));
			}
		} else {
			if (use_tmp_var_autofree) {
				string fn_name = string_replace(node.name, tos_lit("."), tos_lit("_"));
				string name = _STR("_arg_expr_%.*s\000_%"PRId32"\000_%"PRId32"", 3, fn_name, i + 1, node.pos.pos);
				v__gen__Gen_write(g, string_add(tos_lit("/*af arg2*/"), name));
			} else {
				v__gen__Gen_expr(g, arg.expr);
			}
		}
		if (is_interface) {
			v__gen__Gen_write(g, tos_lit(")"));
		}
		if (i < args.len - 1 || gen_vargs) {
			v__gen__Gen_write(g, tos_lit(", "));
		}
	}
	int arg_nr = expected_types.len - 1;
	if (gen_vargs) {
		v__table__Type varg_type = (*(v__table__Type*)/*ee elem_typ */array_get(expected_types, expected_types.len - 1));
		string struct_name = string_add(tos_lit("varg_"), string_replace(v__gen__Gen_typ(g, varg_type), tos_lit("*"), tos_lit("_ptr")));
		int variadic_count = args.len - arg_nr;
		string varg_type_str = int_str(((int)(varg_type)));
		if (variadic_count > (*(int*)map_get(g->variadic_args, varg_type_str, &(int[]){ 0 }))) {
			map_set(&g->variadic_args, varg_type_str, &(int[]) { variadic_count });
		}
		v__gen__Gen_write(g, _STR("(%.*s\000){.len=%"PRId32"\000,.args={", 3, struct_name, variadic_count));
		if (variadic_count > 0) {
			for (int j = arg_nr; j < args.len; ++j) {
				v__gen__Gen_ref_or_deref_arg(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(args, j)), varg_type);
				if (j < args.len - 1) {
					v__gen__Gen_write(g, tos_lit(", "));
				}
			}
		} else {
			v__gen__Gen_write(g, tos_lit("0"));
		}
		v__gen__Gen_write(g, tos_lit("}}"));
	}
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL void v__gen__Gen_ref_or_deref_arg(v__gen__Gen* g, v__ast__CallArg arg, v__table__Type expected_type) {
	bool arg_is_ptr = v__table__Type_is_ptr(expected_type) || _IN(int, v__table__Type_idx(expected_type), _const_v__table__pointer_type_idxs);
	bool expr_is_ptr = v__table__Type_is_ptr(arg.typ) || _IN(int, v__table__Type_idx(arg.typ), _const_v__table__pointer_type_idxs);
	if (expected_type == 0) {
		v__gen__Gen_checker_bug(g, tos_lit("ref_or_deref_arg expected_type is 0"), arg.pos);
	}
	v__table__TypeSymbol* exp_sym = v__table__Table_get_type_symbol(g->table, expected_type);
	if (arg.is_mut && !arg_is_ptr) {
		v__gen__Gen_write(g, tos_lit("&/*mut*/"));
	} else if (arg_is_ptr && !expr_is_ptr) {
		if (arg.is_mut) {
			if (exp_sym->kind == v__table__Kind_array) {
				if ((arg.expr).typ == 224 /* v.ast.Ident */ && (/* as */ *(v__ast__Ident*)__as_cast((arg.expr)._224, (arg.expr).typ, /*expected:*/224)).kind == v__ast__IdentKind_variable) {
					v__gen__Gen_write(g, tos_lit("&/*arr*/"));
					v__gen__Gen_expr(g, arg.expr);
				} else {
					v__gen__Gen_write(g, tos_lit("&/*111*/(array[]){"));
					v__gen__Gen_expr(g, arg.expr);
					v__gen__Gen_write(g, tos_lit("}[0]"));
				}
				return;
			}
		}
		if (!g->is_json_fn) {
			if (arg.typ == 0) {
				v__gen__Gen_checker_bug(g, tos_lit("ref_or_deref_arg arg.typ is 0"), arg.pos);
			}
			v__table__TypeSymbol* arg_typ_sym = v__table__Table_get_type_symbol(g->table, arg.typ);
			v__table__Type expected_deref_type = (v__table__Type_is_ptr(expected_type) ? (v__table__Type_deref(expected_type)) : (expected_type));
			bool is_sum_type = v__table__Table_get_type_symbol(g->table, expected_deref_type)->kind == v__table__Kind_sum_type;
			if (!((arg_typ_sym->kind == v__table__Kind_function) || is_sum_type)) {
				v__gen__Gen_write(g, tos_lit("(voidptr)&/*qq*/"));
			}
		}
	}
	v__gen__Gen_expr_with_cast(g, arg.expr, arg.typ, expected_type);
}

VV_LOCAL_SYMBOL bool v__gen__Gen_is_gui_app(v__gen__Gen* g) {
	#if defined(_WIN32)
	{
		// FOR IN array
		array _t1569 = g->table->cflags;
		for (int _t1570 = 0; _t1570 < _t1569.len; ++_t1570) {
			v__cflag__CFlag cf = ((v__cflag__CFlag*)_t1569.data)[_t1570];
			if (string_eq(cf.value, tos_lit("gdi32"))) {
				return true;
			}
		}
	}
	#endif
	return false;
}

VV_LOCAL_SYMBOL bool v__gen__Gen_fileis(v__gen__Gen* g, string s) {
	return string_contains(g->file.path, s);
}

VV_LOCAL_SYMBOL string v__gen__Gen_write_fn_attrs(v__gen__Gen* g, array_v__table__Attr attrs) {
	string msvc_attrs = tos_lit("");
	// FOR IN array
	array _t1571 = attrs;
	for (int _t1572 = 0; _t1572 < _t1571.len; ++_t1572) {
		v__table__Attr attr = ((v__table__Attr*)_t1571.data)[_t1572];
		string _t1573 = attr.name;
		if (string_eq(_t1573, tos_lit("inline"))) {
			v__gen__Gen_write(g, tos_lit("inline "));
		} else if (string_eq(_t1573, tos_lit("no_inline"))) {
			v__gen__Gen_write(g, tos_lit("__NOINLINE "));
		} else if (string_eq(_t1573, tos_lit("irq_handler"))) {
			v__gen__Gen_write(g, tos_lit("__IRQHANDLER "));
		} else if (string_eq(_t1573, tos_lit("_cold"))) {
			v__gen__Gen_write(g, tos_lit("__attribute__((cold)) "));
		} else if (string_eq(_t1573, tos_lit("_constructor"))) {
			v__gen__Gen_write(g, tos_lit("__attribute__((constructor)) "));
		} else if (string_eq(_t1573, tos_lit("_destructor"))) {
			v__gen__Gen_write(g, tos_lit("__attribute__((destructor)) "));
		} else if (string_eq(_t1573, tos_lit("_flatten"))) {
			v__gen__Gen_write(g, tos_lit("__attribute__((flatten)) "));
		} else if (string_eq(_t1573, tos_lit("_hot"))) {
			v__gen__Gen_write(g, tos_lit("__attribute__((hot)) "));
		} else if (string_eq(_t1573, tos_lit("_malloc"))) {
			v__gen__Gen_write(g, tos_lit("__attribute__((malloc)) "));
		} else if (string_eq(_t1573, tos_lit("_pure"))) {
			v__gen__Gen_write(g, tos_lit("__attribute__((const)) "));
		} else if (string_eq(_t1573, tos_lit("windows_stdcall"))) {
			msvc_attrs = /*f*/string_add(msvc_attrs, tos_lit("__stdcall "));
		} else {
		};
	}
	return msvc_attrs;
}

VV_LOCAL_SYMBOL void v__gen__Gen_gen_json_for_type(v__gen__Gen* g, v__table__Type typ) {
	v__table__Type utyp = v__gen__Gen_unwrap_generic(g, typ);
	strings__Builder dec = strings__new_builder(100);
	strings__Builder enc = strings__new_builder(100);
	v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, utyp);
	string styp = v__gen__Gen_typ(g, utyp);
	if (v__gen__is_js_prim(sym->name) || sym->kind == v__table__Kind_enum_) {
		return;
	}
	if (sym->kind == v__table__Kind_array) {
	}
	if (_IN(string, sym->name, g->json_types)) {
		return;
	}
	array_push(&g->json_types, _MOV((string[]){ string_clone(sym->name) }));
	string dec_fn_name = v__gen__js_dec_name(styp);
	v__gen__Gen_register_optional(g, utyp);
	string dec_fn_dec = _STR("Option_%.*s\000 %.*s\000(cJSON* root)", 3, styp, dec_fn_name);
	strings__Builder_writeln(&dec, _STR("\n//Option_%.*s\000 %.*s\000(cJSON* root, %.*s\000* res) {\n%.*s\000 {\n	%.*s\000 res;\n	if (!root) {\n		const char *error_ptr = cJSON_GetErrorPtr();\n		if (error_ptr != NULL)	{\n			// fprintf(stderr, \"Error in decode() for %.*s\000 error_ptr=: %%s\\n\", error_ptr);\n			// printf(\"\\nbad js=%%%%s\\n\", js.str);\n			Option err = v_error(tos2(error_ptr));\n			return *(Option_%.*s\000 *)&err;\n		}\n	}\n", 8, styp, dec_fn_name, styp, dec_fn_dec, styp, styp, styp));
	strings__Builder_writeln(&g->json_forward_decls, _STR("%.*s\000;", 2, dec_fn_dec));
	string enc_fn_name = v__gen__js_enc_name(styp);
	string enc_fn_dec = _STR("cJSON* %.*s\000(%.*s\000 val)", 3, enc_fn_name, styp);
	strings__Builder_writeln(&g->json_forward_decls, _STR("%.*s\000;\n", 2, enc_fn_dec));
	strings__Builder_writeln(&enc, _STR("\n%.*s\000 {\n\tcJSON *o;", 2, enc_fn_dec));
	if (sym->kind == v__table__Kind_array) {
		v__table__Type value_type = v__table__Table_value_type(g->table, utyp);
		v__gen__Gen_gen_json_for_type(g, value_type);
		strings__Builder_writeln(&dec, v__gen__Gen_decode_array(g, value_type));
		strings__Builder_writeln(&enc, v__gen__Gen_encode_array(g, value_type));
	} else if (sym->kind == v__table__Kind_map) {
		v__table__Map m = /* as */ *(v__table__Map*)__as_cast((sym->info)._349, (sym->info).typ, /*expected:*/349);
		v__gen__Gen_gen_json_for_type(g, m.key_type);
		v__gen__Gen_gen_json_for_type(g, m.value_type);
		strings__Builder_writeln(&dec, v__gen__Gen_decode_map(g, m.key_type, m.value_type));
		strings__Builder_writeln(&enc, v__gen__Gen_encode_map(g, m.key_type, m.value_type));
	} else {
		strings__Builder_writeln(&enc, tos_lit("\to = cJSON_CreateObject();"));
		if ((sym->info).typ != 155 /* v.table.Struct */) {
			v__gen__verror(_STR("json: %.*s\000 is not struct", 2, sym->name));
		}
		v__table__Struct info = /* as */ *(v__table__Struct*)__as_cast((sym->info)._155, (sym->info).typ, /*expected:*/155);
		// FOR IN array
		array _t1575 = info.fields;
		for (int _t1576 = 0; _t1576 < _t1575.len; ++_t1576) {
			v__table__Field field = ((v__table__Field*)_t1575.data)[_t1576];
			if (array_v__table__Attr_contains(field.attrs, tos_lit("skip"))) {
				continue;
			}
			string name = field.name;
			// FOR IN array
			array _t1577 = field.attrs;
			for (int _t1578 = 0; _t1578 < _t1577.len; ++_t1578) {
				v__table__Attr attr = ((v__table__Attr*)_t1577.data)[_t1578];
				if (string_eq(attr.name, tos_lit("json"))) {
					name = attr.arg;
					break;
				}
			}
			string field_type = v__gen__Gen_typ(g, field.typ);
			if (array_v__table__Attr_contains(field.attrs, tos_lit("raw"))) {
				strings__Builder_writeln(&dec, string_add(_STR("\tres.%.*s\000 = tos2(cJSON_PrintUnformatted(", 2, v__gen__c_name(field.name)), _STR("js_get(root, \"%.*s\000\")));", 2, name)));
			} else {
				v__gen__Gen_gen_json_for_type(g, field.typ);
				string dec_name = v__gen__js_dec_name(field_type);
				if (v__gen__is_js_prim(field_type)) {
					strings__Builder_writeln(&dec, _STR("\tres.%.*s\000 = %.*s\000 (js_get(root, \"%.*s\000\"));", 4, v__gen__c_name(field.name), dec_name, name));
				} else if (v__table__Table_get_type_symbol(g->table, field.typ)->kind == v__table__Kind_enum_) {
					strings__Builder_writeln(&dec, _STR("\tres.%.*s\000 = json__decode_u64(js_get(root, \"%.*s\000\"));", 3, v__gen__c_name(field.name), name));
				} else {
					string tmp = v__gen__Gen_new_tmp_var(g);
					strings__Builder_writeln(&dec, _STR("\tOption_%.*s\000 %.*s\000 = %.*s\000 (js_get(root,\"%.*s\000\"));", 5, field_type, tmp, dec_name, name));
					strings__Builder_writeln(&dec, _STR("\tif(!%.*s\000.ok) {", 2, tmp));
					strings__Builder_writeln(&dec, _STR("\t\treturn *(Option_%.*s\000*) &%.*s\000;", 3, styp, tmp));
					strings__Builder_writeln(&dec, tos_lit("\t}"));
					strings__Builder_writeln(&dec, _STR("\tres.%.*s\000 = *(%.*s\000*) %.*s\000.data;", 4, v__gen__c_name(field.name), field_type, tmp));
				}
			}
			string enc_name = v__gen__js_enc_name(field_type);
			if (v__table__Table_get_type_symbol(g->table, field.typ)->kind == v__table__Kind_enum_) {
				strings__Builder_writeln(&enc, _STR("\tcJSON_AddItemToObject(o, \"%.*s\000\", json__encode_u64(val.%.*s\000));", 3, name, v__gen__c_name(field.name)));
			} else {
				strings__Builder_writeln(&enc, _STR("\tcJSON_AddItemToObject(o, \"%.*s\000\", %.*s\000(val.%.*s\000));", 4, name, enc_name, v__gen__c_name(field.name)));
			}
		}
	}
	strings__Builder_writeln(&dec, _STR("\tOption_%.*s\000 ret;", 2, styp));
	strings__Builder_writeln(&dec, tos_lit("\topt_ok2(&res, (OptionBase*)&ret, sizeof(res));"));
	strings__Builder_writeln(&dec, tos_lit("\treturn ret;\n}"));
	strings__Builder_writeln(&enc, tos_lit("\treturn o;\n}"));
	strings__Builder_writeln(&g->definitions, strings__Builder_str(&dec));
	strings__Builder_writeln(&g->gowrappers, strings__Builder_str(&enc));
}

VV_LOCAL_SYMBOL string v__gen__js_enc_name(string typ) {
	string name = _STR("json__encode_%.*s", 1, typ);
	return v__util__no_dots(name);
}

VV_LOCAL_SYMBOL string v__gen__js_dec_name(string typ) {
	string name = _STR("json__decode_%.*s", 1, typ);
	return v__util__no_dots(name);
}

VV_LOCAL_SYMBOL bool v__gen__is_js_prim(string typ) {
	return string_eq(typ, tos_lit("int")) || string_eq(typ, tos_lit("string")) || string_eq(typ, tos_lit("bool")) || string_eq(typ, tos_lit("f32")) || string_eq(typ, tos_lit("f64")) || string_eq(typ, tos_lit("i8")) || string_eq(typ, tos_lit("i16")) || string_eq(typ, tos_lit("i64")) || string_eq(typ, tos_lit("u16")) || string_eq(typ, tos_lit("u32")) || string_eq(typ, tos_lit("u64")) || string_eq(typ, tos_lit("byte"));
}

VV_LOCAL_SYMBOL string v__gen__Gen_decode_array(v__gen__Gen* g, v__table__Type value_type) {
	string styp = v__gen__Gen_typ(g, value_type);
	string fn_name = v__gen__js_dec_name(styp);
	string s = tos_lit("");
	if (v__gen__is_js_prim(styp)) {
		s = _STR("%.*s\000 val = %.*s\000(jsval); ", 3, styp, fn_name);
	} else {
		s = _STR("\n		Option_%.*s\000 val2 = %.*s\000 (jsval);\n		if(!val2.ok) {\n			array_free(&res);\n			return *(Option_array_%.*s\000*)&val2;\n		}\n		%.*s\000 val = *(%.*s\000*)val2.data;\n", 6, styp, fn_name, styp, styp, styp);
	}
	return _STR("\n	if(!cJSON_IsArray(root)) {\n		Option err = v_error( string_add(tos_lit(\"Json element is not an array: \"), tos2(cJSON_PrintUnformatted(root))) );\n		return *(Option_array_%.*s\000 *)&err;\n	}\n	res = __new_array(0, 0, sizeof(%.*s\000));\n	const cJSON *jsval = NULL;\n	cJSON_ArrayForEach(jsval, root)\n	{\n	%.*s\000\n		array_push(&res, &val);\n	}\n", 4, styp, styp, s);
}

VV_LOCAL_SYMBOL string v__gen__Gen_encode_array(v__gen__Gen* g, v__table__Type value_type) {
	string styp = v__gen__Gen_typ(g, value_type);
	string fn_name = v__gen__js_enc_name(styp);
	return _STR("\n	o = cJSON_CreateArray();\n	for (int i = 0; i < val.len; i++){\n		cJSON_AddItemToArray(o, %.*s\000 (  ((%.*s\000*)val.data)[i]  ));\n	}\n", 3, fn_name, styp);
}

VV_LOCAL_SYMBOL string v__gen__Gen_decode_map(v__gen__Gen* g, v__table__Type key_type, v__table__Type value_type) {
	string styp = v__gen__Gen_typ(g, key_type);
	string styp_v = v__gen__Gen_typ(g, value_type);
	string fn_name_v = v__gen__js_dec_name(styp_v);
	string s = tos_lit("");
	if (v__gen__is_js_prim(styp_v)) {
		s = _STR("%.*s\000 val = %.*s\000 (js_get(root, jsval->string));", 3, styp_v, fn_name_v);
	} else {
		s = _STR("\n		Option_%.*s\000 val2 = %.*s\000 (js_get(root, jsval->string));\n		if(!val2.ok) {\n			map_free(&res);\n			return *(Option_map_%.*s\000_%.*s\000*)&val2;\n		}\n		%.*s\000 val = *(%.*s\000*)val2.data;\n", 7, styp_v, fn_name_v, styp, styp_v, styp_v, styp_v);
	}
	return _STR("\n	if(!cJSON_IsObject(root)) {\n		Option err = v_error( string_add(tos_lit(\"Json element is not an object: \"), tos2(cJSON_PrintUnformatted(root))) );\n		return *(Option_map_%.*s\000_%.*s\000 *)&err;\n	}\n	res = new_map_1(sizeof(%.*s\000));\n	cJSON *jsval = NULL;\n	cJSON_ArrayForEach(jsval, root)\n	{\n		%.*s\000\n		map_set(&res, tos2( (byteptr) jsval->string ) , &val );\n	}\n", 5, styp, styp_v, styp_v, s);
}

VV_LOCAL_SYMBOL string v__gen__Gen_encode_map(v__gen__Gen* g, v__table__Type key_type, v__table__Type value_type) {
	string styp = v__gen__Gen_typ(g, key_type);
	string styp_v = v__gen__Gen_typ(g, value_type);
	string fn_name_v = v__gen__js_enc_name(styp_v);
	string zero = v__gen__Gen_type_default(g, value_type);
	string keys_tmp = v__gen__Gen_new_tmp_var(g);
	string key = tos_lit("string key = ");
	if (v__table__Type_is_string(key_type)) {
		key = /*f*/string_add(key, _STR("((%.*s\000*)%.*s\000.data)[i];", 3, styp, keys_tmp));
	} else {
		v__gen__verror(tos_lit("json: encode only maps with string keys"));
	}
	return _STR("\n	o = cJSON_CreateObject();\n	array_%.*s\000 %.*s\000 = map_keys(&val);\n	for (int i = 0; i < %.*s\000.len; ++i) {\n		%.*s\000\n		cJSON_AddItemToObject(o, (char*) key.str, %.*s\000 ( *(%.*s\000*) map_get(val, key, &(%.*s\000[]) { %.*s\000 } ) ) );\n	}\n	array_free(&%.*s\000);\n", 10, styp, keys_tmp, keys_tmp, key, fn_name_v, styp_v, styp_v, zero, keys_tmp);
}

VV_LOCAL_SYMBOL void v__gen__Gen_generate_hotcode_reloading_declarations(v__gen__Gen* g) {
	if (g->pref->os == v__pref__OS_windows) {
		if (g->pref->is_livemain) {
			strings__Builder_writeln(&g->hotcode_definitions, tos_lit("HANDLE live_fn_mutex = 0;"));
		}
		if (g->pref->is_liveshared) {
			strings__Builder_writeln(&g->hotcode_definitions, tos_lit("HANDLE live_fn_mutex;"));
		}
		strings__Builder_writeln(&g->hotcode_definitions, tos_lit("\nvoid pthread_mutex_lock(HANDLE *m) {\n	WaitForSingleObject(*m, INFINITE);\n}\nvoid pthread_mutex_unlock(HANDLE *m) {\n	ReleaseMutex(*m);\n}\n"));
	} else {
		if (g->pref->is_livemain) {
			strings__Builder_writeln(&g->hotcode_definitions, tos_lit("pthread_mutex_t live_fn_mutex = PTHREAD_MUTEX_INITIALIZER;"));
		}
		if (g->pref->is_liveshared) {
			strings__Builder_writeln(&g->hotcode_definitions, tos_lit("pthread_mutex_t live_fn_mutex;"));
		}
	}
}

VV_LOCAL_SYMBOL void v__gen__Gen_generate_hotcode_reloader_code(v__gen__Gen* g) {
	if (g->pref->is_liveshared) {
		strings__Builder_writeln(&g->hotcode_definitions, tos_lit(""));
		return;
	}
	if (g->pref->is_livemain) {
		string phd = tos_lit("");
		array_string load_code = __new_array_with_default(0, 0, sizeof(string), 0);
		if (g->pref->os != v__pref__OS_windows) {
			// FOR IN array
			array _t1579 = g->hotcode_fn_names;
			for (int _t1580 = 0; _t1580 < _t1579.len; ++_t1580) {
				string so_fn = ((string*)_t1579.data)[_t1580];
				array_push(&load_code, _MOV((string[]){ string_clone(_STR("impl_live_%.*s\000 = dlsym(live_lib, \"impl_live_%.*s\000\");", 3, so_fn, so_fn)) }));
			}
			phd = _const_v__gen__posix_hotcode_definitions_1;
		} else {
			// FOR IN array
			array _t1582 = g->hotcode_fn_names;
			for (int _t1583 = 0; _t1583 < _t1582.len; ++_t1583) {
				string so_fn = ((string*)_t1582.data)[_t1583];
				array_push(&load_code, _MOV((string[]){ string_clone(_STR("impl_live_%.*s\000 = (void *)GetProcAddress(live_lib, \"impl_live_%.*s\000\");  ", 3, so_fn, so_fn)) }));
			}
			phd = _const_v__gen__windows_hotcode_definitions_1;
		}
		strings__Builder_writeln(&g->hotcode_definitions, string_replace(phd, tos_lit("@LOAD_FNS@"), array_string_join(load_code, tos_lit("\n"))));
	}
}

VV_LOCAL_SYMBOL void v__gen__Gen_generate_hotcode_reloading_main_caller(v__gen__Gen* g) {
	if (!g->pref->is_livemain) {
		return;
	}
	v__gen__Gen_writeln(g, tos_lit(""));
	v__gen__Gen_writeln(g, tos_lit("\t// live code initialization section:"));
	v__gen__Gen_writeln(g, tos_lit("\t{"));
	v__gen__Gen_writeln(g, tos_lit("\t\t// initialization of live function pointers"));
	// FOR IN array
	array _t1585 = g->hotcode_fn_names;
	for (int _t1586 = 0; _t1586 < _t1585.len; ++_t1586) {
		string fname = ((string*)_t1585.data)[_t1586];
		v__gen__Gen_writeln(g, _STR("\t\timpl_live_%.*s\000 = 0;", 2, fname));
	}
	string vexe = v__util__cescaped_path(v__pref__vexe_path());
	string file = v__util__cescaped_path(g->pref->path);
	string msvc = (string_eq(g->pref->ccompiler, tos_lit("msvc")) ? (tos_lit("-cc msvc")) : (tos_lit("")));
	string so_debug_flag = (g->pref->is_debug ? (tos_lit("-cg")) : (tos_lit("")));
	string vopts = _STR("%.*s\000 %.*s\000 -sharedlive -shared", 3, msvc, so_debug_flag);
	v__gen__Gen_writeln(g, tos_lit("\t\t// start background reloading thread"));
	if (g->pref->os == v__pref__OS_windows) {
		v__gen__Gen_writeln(g, tos_lit("\t\tlive_fn_mutex = CreateMutexA(0, 0, 0);"));
	}
	v__gen__Gen_writeln(g, tos_lit("\t\tlive__LiveReloadInfo* live_info = live__executable__new_live_reload_info("));
	v__gen__Gen_writeln(g, _STR("\t\t\t\t\t tos2(\"%.*s\000\"),", 2, file));
	v__gen__Gen_writeln(g, _STR("\t\t\t\t\t tos2(\"%.*s\000\"),", 2, vexe));
	v__gen__Gen_writeln(g, _STR("\t\t\t\t\t tos2(\"%.*s\000\"),", 2, vopts));
	v__gen__Gen_writeln(g, tos_lit("\t\t\t\t\t &live_fn_mutex,"));
	v__gen__Gen_writeln(g, tos_lit("\t\t\t\t\t v_bind_live_symbols"));
	v__gen__Gen_writeln(g, tos_lit("\t\t);"));
	v__gen__Gen_writeln(g, tos_lit("\t\t   g_live_info = (void*)live_info;"));
	v__gen__Gen_writeln(g, tos_lit("\t\tlive__executable__start_reloader(live_info);"));
	v__gen__Gen_writeln(g, tos_lit("\t}\t// end of live code initialization section"));
	v__gen__Gen_writeln(g, tos_lit(""));
}

VV_LOCAL_SYMBOL void v__gen__Gen_profile_fn(v__gen__Gen* g, v__ast__FnDecl fn_decl) {
	if (g->pref->profile_no_inline && array_v__table__Attr_contains(fn_decl.attrs, tos_lit("inline"))) {
		g->defer_profile_code = tos_lit("");
		return;
	}
	string fn_name = fn_decl.name;
	if (string_starts_with(fn_name, tos_lit("time.vpc_now"))) {
		g->defer_profile_code = tos_lit("");
	} else {
		string measure_fn_name = (g->pref->os == v__pref__OS_macos ? (tos_lit("time__vpc_now_darwin")) : (tos_lit("time__vpc_now")));
		string fn_profile_counter_name = _STR("vpc_%.*s", 1, g->last_fn_c_name);
		string fn_profile_counter_name_calls = _STR("%.*s\000_calls", 2, fn_profile_counter_name);
		v__gen__Gen_writeln(g, tos_lit(""));
		v__gen__Gen_writeln(g, _STR("\tdouble _PROF_FN_START = %.*s\000(); %.*s\000++; // %.*s", 3, measure_fn_name, fn_profile_counter_name_calls, fn_name));
		v__gen__Gen_writeln(g, tos_lit(""));
		g->defer_profile_code = _STR("\t%.*s\000 += %.*s\000() - _PROF_FN_START;", 3, fn_profile_counter_name, measure_fn_name);
		strings__Builder_writeln(&g->pcs_declarations, _STR("double %.*s\000 = 0.0; u64 %.*s\000 = 0;", 3, fn_profile_counter_name, fn_profile_counter_name_calls));
		array_push(&g->pcs, _MOV((v__gen__ProfileCounterMeta[]){ (v__gen__ProfileCounterMeta){.fn_name = g->last_fn_c_name,.vpc_name = fn_profile_counter_name,.vpc_calls = fn_profile_counter_name_calls,} }));
	}
}

void v__gen__Gen_gen_vprint_profile_stats(v__gen__Gen* g) {
	strings__Builder_writeln(&g->pcs_declarations, tos_lit("void vprint_profile_stats(){"));
	string fstring = tos_lit("\"%14lu %14.3fms %14.0fns %s \\n\"");
	if (string_eq(g->pref->profile_file, tos_lit("-"))) {
		// FOR IN array
		array _t1588 = g->pcs;
		for (int _t1589 = 0; _t1589 < _t1588.len; ++_t1589) {
			v__gen__ProfileCounterMeta pc_meta = ((v__gen__ProfileCounterMeta*)_t1588.data)[_t1589];
			strings__Builder_writeln(&g->pcs_declarations, _STR("\tif (%.*s\000) printf(%.*s\000, %.*s\000, %.*s\000/1000000.0, %.*s\000/%.*s\000, \"%.*s\000\" );", 8, pc_meta.vpc_calls, fstring, pc_meta.vpc_calls, pc_meta.vpc_name, pc_meta.vpc_name, pc_meta.vpc_calls, pc_meta.fn_name));
		}
	} else {
		strings__Builder_writeln(&g->pcs_declarations, tos_lit("\tFILE * fp;"));
		strings__Builder_writeln(&g->pcs_declarations, _STR("\tfp = fopen (\"%.*s\000\", \"w+\");", 2, g->pref->profile_file));
		// FOR IN array
		array _t1590 = g->pcs;
		for (int _t1591 = 0; _t1591 < _t1590.len; ++_t1591) {
			v__gen__ProfileCounterMeta pc_meta = ((v__gen__ProfileCounterMeta*)_t1590.data)[_t1591];
			strings__Builder_writeln(&g->pcs_declarations, _STR("\tif (%.*s\000) fprintf(fp, %.*s\000, %.*s\000, %.*s\000/1000000.0, %.*s\000/%.*s\000, \"%.*s\000\" );", 8, pc_meta.vpc_calls, fstring, pc_meta.vpc_calls, pc_meta.vpc_name, pc_meta.vpc_name, pc_meta.vpc_calls, pc_meta.fn_name));
		}
		strings__Builder_writeln(&g->pcs_declarations, tos_lit("\tfclose(fp);"));
	}
	strings__Builder_writeln(&g->pcs_declarations, tos_lit("}"));
}

VV_LOCAL_SYMBOL void v__gen__Gen_sql_stmt(v__gen__Gen* g, v__ast__SqlStmt node) {
	g->sql_i = 0;
	v__gen__Gen_writeln(g, tos_lit("\n\t// sql insert"));
	string db_name = v__gen__Gen_new_tmp_var(g);
	g->sql_stmt_name = v__gen__Gen_new_tmp_var(g);
	v__gen__Gen_write(g, _STR("%.*s\000__DB %.*s\000 = ", 3, _const_v__gen__dbtype, db_name));
	v__gen__Gen_expr(g, node.db_expr);
	v__gen__Gen_writeln(g, tos_lit(";"));
	v__gen__Gen_write(g, _STR("sqlite3_stmt* %.*s\000 = %.*s\000__DB_init_stmt(%.*s\000, tos_lit(\"", 4, g->sql_stmt_name, _const_v__gen__dbtype, db_name));
	if (node.kind == v__ast__SqlStmtKind_insert) {
		v__gen__Gen_write(g, _STR("INSERT INTO `%.*s\000` (", 2, v__util__strip_mod_name(node.table_name)));
	} else if (node.kind == v__ast__SqlStmtKind_update) {
		v__gen__Gen_write(g, _STR("UPDATE `%.*s\000` SET ", 2, v__util__strip_mod_name(node.table_name)));
	} else if (node.kind == v__ast__SqlStmtKind_delete) {
		v__gen__Gen_write(g, _STR("DELETE FROM `%.*s\000` ", 2, v__util__strip_mod_name(node.table_name)));
	}
	if (node.kind == v__ast__SqlStmtKind_insert) {
		// FOR IN array
		array _t1592 = node.fields;
		for (int i = 0; i < _t1592.len; ++i) {
			v__table__Field field = ((v__table__Field*)_t1592.data)[i];
			if (string_eq(field.name, tos_lit("id"))) {
				continue;
			}
			v__gen__Gen_write(g, _STR("`%.*s\000`", 2, field.name));
			if (i < node.fields.len - 1) {
				v__gen__Gen_write(g, tos_lit(", "));
			}
		}
		v__gen__Gen_write(g, tos_lit(") values ("));
		// FOR IN array
		array _t1593 = node.fields;
		for (int i = 0; i < _t1593.len; ++i) {
			v__table__Field field = ((v__table__Field*)_t1593.data)[i];
			if (string_eq(field.name, tos_lit("id"))) {
				continue;
			}
			v__gen__Gen_write(g, _STR("?%"PRId32"", 1, i + 0));
			if (i < node.fields.len - 1) {
				v__gen__Gen_write(g, tos_lit(", "));
			}
		}
		v__gen__Gen_write(g, tos_lit(")"));
	} else if (node.kind == v__ast__SqlStmtKind_update) {
		// FOR IN array
		array _t1594 = node.updated_columns;
		for (int i = 0; i < _t1594.len; ++i) {
			string col = ((string*)_t1594.data)[i];
			v__gen__Gen_write(g, _STR(" %.*s\000 = ", 2, col));
			v__gen__Gen_expr_to_sql(g, (*(v__ast__Expr*)/*ee elem_typ */array_get(node.update_exprs, i)));
			if (i < node.updated_columns.len - 1) {
				v__gen__Gen_write(g, tos_lit(", "));
			}
		}
		v__gen__Gen_write(g, tos_lit(" WHERE "));
	} else if (node.kind == v__ast__SqlStmtKind_delete) {
		v__gen__Gen_write(g, tos_lit(" WHERE "));
	}
	if (node.kind == v__ast__SqlStmtKind_update || node.kind == v__ast__SqlStmtKind_delete) {
		v__gen__Gen_expr_to_sql(g, node.where_expr);
	}
	v__gen__Gen_writeln(g, tos_lit("\"));"));
	if (node.kind == v__ast__SqlStmtKind_insert) {
		// FOR IN array
		array _t1595 = node.fields;
		for (int i = 0; i < _t1595.len; ++i) {
			v__table__Field field = ((v__table__Field*)_t1595.data)[i];
			if (string_eq(field.name, tos_lit("id"))) {
				continue;
			}
			string x = _STR("%.*s\000.%.*s", 2, node.object_var_name, field.name);
			if (field.typ == _const_v__table__string_type) {
				v__gen__Gen_writeln(g, _STR("sqlite3_bind_text(%.*s\000, %"PRId32"\000, %.*s\000.str, %.*s\000.len, 0);", 5, g->sql_stmt_name, i + 0, x, x));
			} else {
				v__gen__Gen_writeln(g, _STR("sqlite3_bind_int(%.*s\000, %"PRId32"\000, %.*s\000); // stmt", 4, g->sql_stmt_name, i + 0, x));
			}
		}
	}
	string binds = strings__Builder_str(&g->sql_buf);
	g->sql_buf = strings__new_builder(100);
	v__gen__Gen_writeln(g, binds);
	string step_res = v__gen__Gen_new_tmp_var(g);
	v__gen__Gen_writeln(g, _STR("\tint %.*s\000 = sqlite3_step(%.*s\000);", 3, step_res, g->sql_stmt_name));
	v__gen__Gen_writeln(g, _STR("\tif( (%.*s\000 != SQLITE_OK) && (%.*s\000 != SQLITE_DONE)){ puts(sqlite3_errmsg(%.*s\000.conn)); }", 4, step_res, step_res, db_name));
	v__gen__Gen_writeln(g, _STR("\tsqlite3_finalize(%.*s\000);", 2, g->sql_stmt_name));
}

VV_LOCAL_SYMBOL void v__gen__Gen_sql_select_expr(v__gen__Gen* g, v__ast__SqlExpr node) {
	g->sql_i = 0;
	string cur_line = v__gen__Gen_go_before_stmt(g, 0);
	string sql_query = tos_lit("SELECT ");
	if (node.is_count) {
		sql_query = /*f*/string_add(sql_query, _STR("COUNT(*) FROM `%.*s\000` ", 2, v__util__strip_mod_name(node.table_name)));
	} else {
		// FOR IN array
		array _t1596 = node.fields;
		for (int i = 0; i < _t1596.len; ++i) {
			v__table__Field field = ((v__table__Field*)_t1596.data)[i];
			sql_query = /*f*/string_add(sql_query, _STR("`%.*s\000`", 2, field.name));
			if (i < node.fields.len - 1) {
				sql_query = /*f*/string_add(sql_query, tos_lit(", "));
			}
		}
		sql_query = /*f*/string_add(sql_query, _STR(" FROM `%.*s\000`", 2, v__util__strip_mod_name(node.table_name)));
	}
	if (node.has_where) {
		sql_query = /*f*/string_add(sql_query, tos_lit(" WHERE "));
	}
	g->sql_stmt_name = v__gen__Gen_new_tmp_var(g);
	string db_name = v__gen__Gen_new_tmp_var(g);
	v__gen__Gen_writeln(g, tos_lit("\n\t// sql select"));
	v__gen__Gen_write(g, _STR("%.*s\000__DB %.*s\000 = ", 3, _const_v__gen__dbtype, db_name));
	v__gen__Gen_expr(g, node.db_expr);
	v__gen__Gen_writeln(g, tos_lit(";"));
	v__gen__Gen_write(g, _STR("sqlite3_stmt* %.*s\000 = %.*s\000__DB_init_stmt(%.*s\000, tos_lit(\"", 4, g->sql_stmt_name, _const_v__gen__dbtype, db_name));
	v__gen__Gen_write(g, sql_query);
	if (node.has_where && (node.where_expr).typ == 228 /* v.ast.InfixExpr */) {
		v__gen__Gen_expr_to_sql(g, node.where_expr);
	}
	if (node.has_order) {
		v__gen__Gen_write(g, tos_lit(" ORDER BY "));
		g->sql_side = v__gen__SqlExprSide_left;
		v__gen__Gen_expr_to_sql(g, node.order_expr);
		if (node.has_desc) {
			v__gen__Gen_write(g, tos_lit(" DESC "));
		}
	} else {
		v__gen__Gen_write(g, tos_lit(" ORDER BY id "));
	}
	if (node.has_limit) {
		v__gen__Gen_write(g, tos_lit(" LIMIT "));
		g->sql_side = v__gen__SqlExprSide_right;
		v__gen__Gen_expr_to_sql(g, node.limit_expr);
	}
	if (node.has_offset) {
		v__gen__Gen_write(g, tos_lit(" OFFSET "));
		g->sql_side = v__gen__SqlExprSide_right;
		v__gen__Gen_expr_to_sql(g, node.offset_expr);
	}
	v__gen__Gen_writeln(g, tos_lit("\"));"));
	string binds = strings__Builder_str(&g->sql_buf);
	g->sql_buf = strings__new_builder(100);
	v__gen__Gen_writeln(g, binds);
	string binding_res = v__gen__Gen_new_tmp_var(g);
	v__gen__Gen_writeln(g, _STR("int %.*s\000 = sqlite3_extended_errcode(%.*s\000.conn);", 3, binding_res, db_name));
	v__gen__Gen_writeln(g, _STR("if (%.*s\000 != SQLITE_OK) { puts(sqlite3_errmsg(%.*s\000.conn)); }", 3, binding_res, db_name));
	if (node.is_count) {
		v__gen__Gen_writeln(g, _STR("%.*s\000 %.*s\000__get_int_from_stmt(%.*s\000);", 4, cur_line, _const_v__gen__dbtype, g->sql_stmt_name));
	} else {
		string tmp = v__gen__Gen_new_tmp_var(g);
		string styp = v__gen__Gen_typ(g, node.typ);
		string elem_type_str = tos_lit("");
		if (node.is_array) {
			v__table__TypeSymbol* array_sym = v__table__Table_get_type_symbol(g->table, node.typ);
			v__table__Array array_info = /* as */ *(v__table__Array*)__as_cast((array_sym->info)._350, (array_sym->info).typ, /*expected:*/350);
			elem_type_str = v__gen__Gen_typ(g, array_info.elem_type);
			v__gen__Gen_writeln(g, _STR("%.*s\000 %.*s\000_array = __new_array(0, 10, sizeof(%.*s\000));", 4, styp, tmp, elem_type_str));
			v__gen__Gen_writeln(g, tos_lit("while (1) {"));
			v__gen__Gen_writeln(g, _STR("\t%.*s\000 %.*s\000 = (%.*s\000) {", 4, elem_type_str, tmp, elem_type_str));
			v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, array_info.elem_type);
			v__table__Struct info = /* as */ *(v__table__Struct*)__as_cast((sym->info)._155, (sym->info).typ, /*expected:*/155);
			// FOR IN array
			array _t1597 = info.fields;
			for (int i = 0; i < _t1597.len; ++i) {
				v__table__Field field = ((v__table__Field*)_t1597.data)[i];
				v__gen__Gen_zero_struct_field(g, field);
				if (i != info.fields.len - 1) {
					v__gen__Gen_write(g, tos_lit(", "));
				}
			}
			v__gen__Gen_writeln(g, tos_lit("};"));
		} else {
			v__gen__Gen_writeln(g, _STR("%.*s\000 %.*s\000 = (%.*s\000){", 4, styp, tmp, styp));
			v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, node.typ);
			v__table__Struct info = /* as */ *(v__table__Struct*)__as_cast((sym->info)._155, (sym->info).typ, /*expected:*/155);
			// FOR IN array
			array _t1598 = info.fields;
			for (int i = 0; i < _t1598.len; ++i) {
				v__table__Field field = ((v__table__Field*)_t1598.data)[i];
				v__gen__Gen_zero_struct_field(g, field);
				if (i != info.fields.len - 1) {
					v__gen__Gen_write(g, tos_lit(", "));
				}
			}
			v__gen__Gen_writeln(g, tos_lit("};"));
		}
		v__gen__Gen_writeln(g, _STR("int _step_res%.*s\000 = sqlite3_step(%.*s\000);", 3, tmp, g->sql_stmt_name));
		if (node.is_array) {
			v__gen__Gen_writeln(g, _STR("\tif (_step_res%.*s\000 == SQLITE_DONE) break;", 2, tmp));
			v__gen__Gen_writeln(g, _STR("\tif (_step_res%.*s\000 == SQLITE_ROW) ;", 2, tmp));
			v__gen__Gen_writeln(g, _STR("\telse if (_step_res%.*s\000 != SQLITE_OK) break;", 2, tmp));
		} else {
			v__gen__Gen_writeln(g, _STR("\tif (_step_res%.*s\000 == SQLITE_OK || _step_res%.*s\000 == SQLITE_ROW) {", 3, tmp, tmp));
		}
		// FOR IN array
		array _t1599 = node.fields;
		for (int i = 0; i < _t1599.len; ++i) {
			v__table__Field field = ((v__table__Field*)_t1599.data)[i];
			string func = tos_lit("sqlite3_column_int");
			if (field.typ == _const_v__table__string_type) {
				func = tos_lit("sqlite3_column_text");
				v__gen__Gen_writeln(g, _STR("%.*s\000.%.*s\000 = tos_clone(%.*s\000(%.*s\000, %"PRId32"\000));", 6, tmp, field.name, func, g->sql_stmt_name, i));
			} else {
				v__gen__Gen_writeln(g, _STR("%.*s\000.%.*s\000 = %.*s\000(%.*s\000, %"PRId32"\000);", 6, tmp, field.name, func, g->sql_stmt_name, i));
			}
		}
		if (node.is_array) {
			v__gen__Gen_writeln(g, _STR("\t array_push(&%.*s\000_array, _MOV((%.*s\000[]){ %.*s\000 }));", 4, tmp, elem_type_str, tmp));
		}
		v__gen__Gen_writeln(g, tos_lit("}"));
		v__gen__Gen_writeln(g, _STR("sqlite3_finalize(%.*s\000);", 2, g->sql_stmt_name));
		if (node.is_array) {
			v__gen__Gen_writeln(g, _STR("%.*s\000 %.*s\000_array; ", 3, cur_line, tmp));
		} else {
			v__gen__Gen_writeln(g, _STR("%.*s\000 %.*s\000; ", 3, cur_line, tmp));
		}
	}
}

VV_LOCAL_SYMBOL void v__gen__Gen_sql_bind_int(v__gen__Gen* g, string val) {
	strings__Builder_writeln(&g->sql_buf, _STR("sqlite3_bind_int(%.*s\000, %"PRId32"\000, %.*s\000);", 4, g->sql_stmt_name, g->sql_i, val));
}

VV_LOCAL_SYMBOL void v__gen__Gen_sql_bind_string(v__gen__Gen* g, string val, string len) {
	strings__Builder_writeln(&g->sql_buf, _STR("sqlite3_bind_text(%.*s\000, %"PRId32"\000, %.*s\000, %.*s\000, 0);", 5, g->sql_stmt_name, g->sql_i, val, len));
}

VV_LOCAL_SYMBOL void v__gen__Gen_expr_to_sql(v__gen__Gen* g, v__ast__Expr expr) {
	v__ast__Expr _t1600 = expr;
	if (_t1600.typ == 228 /* v.ast.InfixExpr */) {
		g->sql_side = v__gen__SqlExprSide_left;
		v__gen__Gen_expr_to_sql(g, (*expr._228).left);
		v__token__Kind _t1601 = (*expr._228).op;
		if (_t1601 == v__token__Kind_eq) {
			v__gen__Gen_write(g, tos_lit(" = "));
		} else if (_t1601 == v__token__Kind_gt) {
			v__gen__Gen_write(g, tos_lit(" > "));
		} else if (_t1601 == v__token__Kind_lt) {
			v__gen__Gen_write(g, tos_lit(" < "));
		} else if (_t1601 == v__token__Kind_ge) {
			v__gen__Gen_write(g, tos_lit(" >= "));
		} else if (_t1601 == v__token__Kind_le) {
			v__gen__Gen_write(g, tos_lit(" <= "));
		} else if (_t1601 == v__token__Kind_and) {
			v__gen__Gen_write(g, tos_lit(" and "));
		} else if (_t1601 == v__token__Kind_logical_or) {
			v__gen__Gen_write(g, tos_lit(" or "));
		} else if (_t1601 == v__token__Kind_plus) {
			v__gen__Gen_write(g, tos_lit(" + "));
		} else if (_t1601 == v__token__Kind_minus) {
			v__gen__Gen_write(g, tos_lit(" - "));
		} else if (_t1601 == v__token__Kind_mul) {
			v__gen__Gen_write(g, tos_lit(" * "));
		} else if (_t1601 == v__token__Kind_div) {
			v__gen__Gen_write(g, tos_lit(" / "));
		} else {
		};
		g->sql_side = v__gen__SqlExprSide_right;
		v__gen__Gen_expr_to_sql(g, (*expr._228).right);
	} else if (_t1600.typ == 245 /* v.ast.StringLiteral */) {
		v__gen__Gen_inc_sql_i(g);
		v__gen__Gen_sql_bind_string(g, _STR("\"%.*s\000\"", 2, (*expr._245).val), int_str((*expr._245).val.len));
	} else if (_t1600.typ == 229 /* v.ast.IntegerLiteral */) {
		v__gen__Gen_inc_sql_i(g);
		v__gen__Gen_sql_bind_int(g, (*expr._229).val);
	} else if (_t1600.typ == 213 /* v.ast.BoolLiteral */) {
		v__gen__Gen_inc_sql_i(g);
		v__gen__Gen_sql_bind_int(g, ((*expr._213).val ? (tos_lit("1")) : (tos_lit("0"))));
	} else if (_t1600.typ == 224 /* v.ast.Ident */) {
		if (g->sql_side == v__gen__SqlExprSide_left) {
			v__gen__Gen_write(g, (*expr._224).name);
		} else {
			v__gen__Gen_inc_sql_i(g);
			v__ast__IdentVar info = /* as */ *(v__ast__IdentVar*)__as_cast(((*expr._224).info)._313, ((*expr._224).info).typ, /*expected:*/313);
			v__table__Type typ = info.typ;
			if (typ == _const_v__table__string_type) {
				v__gen__Gen_sql_bind_string(g, _STR("%.*s\000.str", 2, (*expr._224).name), _STR("%.*s\000.len", 2, (*expr._224).name));
			} else if (typ == _const_v__table__int_type) {
				v__gen__Gen_sql_bind_int(g, (*expr._224).name);
			} else {
				v__gen__verror(_STR("bad sql type=%"PRId32"\000 ident_name=%.*s", 2, typ, (*expr._224).name));
			}
		}
	} else if (_t1600.typ == 241 /* v.ast.SelectorExpr */) {
		v__gen__Gen_inc_sql_i(g);
		if ((*expr._241).typ == _const_v__table__int_type) {
			if (((*expr._241).expr).typ != 224 /* v.ast.Ident */) {
				v__gen__verror(tos_lit("orm selector not ident"));
			}
			v__ast__Ident ident = /* as */ *(v__ast__Ident*)__as_cast(((*expr._241).expr)._224, ((*expr._241).expr).typ, /*expected:*/224);
			v__gen__Gen_sql_bind_int(g, string_add(string_add(ident.name, tos_lit(".")), (*expr._241).field_name));
		} else {
			v__gen__verror(_STR("bad sql type=%"PRId32"\000 selector expr=%.*s", 2, (*expr._241).typ, (*expr._241).field_name));
		}
	} else {
		v__gen__Gen_expr(g, expr);
	};
}

VV_LOCAL_SYMBOL void v__gen__Gen_inc_sql_i(v__gen__Gen* g) {
	g->sql_i++;
	v__gen__Gen_write(g, _STR("?%"PRId32"", 1, g->sql_i));
}

VV_LOCAL_SYMBOL void v__gen__Gen_write_str_fn_definitions(v__gen__Gen* g) {
	v__gen__Gen_writeln(g, tos_lit("\nvoid _STR_PRINT_ARG(const char *fmt, char** refbufp, int *nbytes, int *memsize, int guess, ...) {\n	va_list args;\n	va_start(args, guess);\n	// NB: (*memsize - *nbytes) === how much free space is left at the end of the current buffer refbufp\n	// *memsize === total length of the buffer refbufp\n	// *nbytes === already occupied bytes of buffer refbufp\n	// guess === how many bytes were taken during the current vsnprintf run\n	for(;;) {\n		if (guess < *memsize - *nbytes) {\n			guess = vsnprintf(*refbufp + *nbytes, *memsize - *nbytes, fmt, args);\n			if (guess < *memsize - *nbytes) { // result did fit into buffer\n				*nbytes += guess;\n				break;\n			}\n		}\n		// increase buffer (somewhat exponentially)\n		*memsize += (*memsize + *memsize) / 3 + guess;\n		*refbufp = (char*)realloc((void*)*refbufp, *memsize);\n	}\n	va_end(args);\n}\n\nstring _STR(const char *fmt, int nfmts, ...) {\n	va_list argptr;\n	int memsize = 128;\n	int nbytes = 0;\n	char* buf = (char*)malloc(memsize);\n	va_start(argptr, nfmts);\n	for (int i=0; i<nfmts; ++i) {\n		int k = strlen(fmt);\n		bool is_fspec = false;\n		for (int j=0; j<k; ++j) {\n			if (fmt[j] == '%') {\n				j++;\n				if (fmt[j] != '%') {\n					is_fspec = true;\n					break;\n				}\n			}\n		}\n		if (is_fspec) {\n			char f = fmt[k-1];\n			char fup = f & 0xdf; // toupper\n			bool l = fmt[k-2] == 'l';\n			bool ll = l && fmt[k-3] == 'l';\n			if (f == 'u' || fup == 'X' || f == 'o' || f == 'd' || f == 'c') { // int...\n				if (ll) _STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+16, va_arg(argptr, long long));\n				else if (l) _STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+10, va_arg(argptr, long));\n				else _STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+8, va_arg(argptr, int));\n			} else if (fup >= 'E' && fup <= 'G') { // floating point\n				_STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+10, va_arg(argptr, double));\n			} else if (f == 'p') {\n				_STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+14, va_arg(argptr, void*));\n			} else if (f == 's') { // v string\n				string s = va_arg(argptr, string);\n				if (fmt[k-4] == '*') { // %*.*s\n					int fwidth = va_arg(argptr, int);\n					if (fwidth < 0)\n						fwidth -= (s.len - utf8_str_visible_length(s));\n					else\n						fwidth += (s.len - utf8_str_visible_length(s));\n					_STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+s.len-4, fwidth, s.len, s.str);\n				} else { // %.*s\n					_STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+s.len-4, s.len, s.str);\n				}\n			} else {\n				//v_panic(tos3('Invaid format specifier'));\n			}\n		} else {\n			_STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k);\n		}\n		fmt += k+1;\n	}\n	va_end(argptr);\n	buf[nbytes] = 0;\n	buf = (char*)realloc((void*)buf, nbytes+1);\n#ifdef DEBUG_ALLOC\n	//puts('_STR:');\n	puts(buf);\n#endif\n#if _VAUTOFREE\n	//g_cur_str = (byteptr)buf;\n#endif\n	return tos2((byteptr)buf);\n}\n\nstring _STR_TMP(const char *fmt, ...) {\n	va_list argptr;\n	va_start(argptr, fmt);\n	size_t len = vsnprintf(0, 0, fmt, argptr) + 1;\n	va_end(argptr);\n	va_start(argptr, fmt);\n	vsprintf((char *)g_str_buf, fmt, argptr);\n	va_end(argptr);\n\n#ifdef DEBUG_ALLOC\n	//puts('_STR_TMP:');\n	//puts(g_str_buf);\n#endif\n	string res = tos(g_str_buf,  len);\n	res.is_lit = 1;\n	return res;\n\n} // endof _STR_TMP\n\n"));
}

VV_LOCAL_SYMBOL void v__gen__Gen_string_literal(v__gen__Gen* g, v__ast__StringLiteral node) {
	if (node.is_raw) {
		string escaped_val = v__util__smart_quote(node.val, true);
		v__gen__Gen_write(g, _STR("tos_lit(\"%.*s\000\")", 2, escaped_val));
		return;
	}
	string escaped_val = v__util__smart_quote(node.val, false);
	if (g->is_c_call || node.language == v__table__Language_c) {
		v__gen__Gen_write(g, _STR("\"%.*s\000\"", 2, escaped_val));
	} else {
		v__gen__Gen_write(g, _STR("tos_lit(\"%.*s\000\")", 2, escaped_val));
	}
}

VV_LOCAL_SYMBOL void v__gen__Gen_string_inter_literal_sb_optimized(v__gen__Gen* g, v__ast__CallExpr call_expr) {
	v__ast__StringInterLiteral node = /* as */ *(v__ast__StringInterLiteral*)__as_cast(((*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr.args, 0)).expr)._244, ((*(v__ast__CallArg*)/*ee elem_typ */array_get(call_expr.args, 0)).expr).typ, /*expected:*/244);
	v__gen__Gen_writeln(g, tos_lit("// sb inter opt"));
	bool is_nl = string_eq(call_expr.name, tos_lit("writeln"));
	// FOR IN array
	array _t1602 = node.vals;
	for (int i = 0; i < _t1602.len; ++i) {
		string val = ((string*)_t1602.data)[i];
		string escaped_val = v__util__smart_quote(val, false);
		v__gen__Gen_write(g, tos_lit("strings__Builder_write(&"));
		v__gen__Gen_expr(g, call_expr.left);
		v__gen__Gen_write(g, tos_lit(", tos_lit(\""));
		v__gen__Gen_write(g, escaped_val);
		v__gen__Gen_writeln(g, tos_lit("\"));"));
		if (i >= node.exprs.len) {
			break;
		}
		if (is_nl && i == node.exprs.len - 1) {
			v__gen__Gen_write(g, tos_lit("strings__Builder_writeln(&"));
		} else {
			v__gen__Gen_write(g, tos_lit("strings__Builder_write(&"));
		}
		v__gen__Gen_expr(g, call_expr.left);
		v__gen__Gen_write(g, tos_lit(", "));
		v__table__Type typ = (*(v__table__Type*)/*ee elem_typ */array_get(node.expr_types, i));
		v__gen__Gen_write(g, v__gen__Gen_typ(g, typ));
		v__gen__Gen_write(g, tos_lit("_str("));
		v__gen__Gen_expr(g, (*(v__ast__Expr*)/*ee elem_typ */array_get(node.exprs, i)));
		v__gen__Gen_writeln(g, tos_lit("));"));
	}
	v__gen__Gen_writeln(g, tos_lit(""));
	return;
}

VV_LOCAL_SYMBOL void v__gen__Gen_string_inter_literal(v__gen__Gen* g, v__ast__StringInterLiteral node) {
	v__gen__Gen_write(g, tos_lit("_STR(\""));
	bool end_string = false;
	// FOR IN array
	array _t1603 = node.vals;
	for (int i = 0; i < _t1603.len; ++i) {
		string val = ((string*)_t1603.data)[i];
		string escaped_val = string_replace_each(val, new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){tos_lit("%"), tos_lit("%%")})));
		escaped_val = v__util__smart_quote(escaped_val, false);
		if (i >= node.exprs.len) {
			if (escaped_val.len > 0) {
				end_string = true;
				v__gen__Gen_write(g, tos_lit("\\000"));
				v__gen__Gen_write(g, escaped_val);
			}
			break;
		}
		v__gen__Gen_write(g, escaped_val);
		v__gen__Gen_write(g, tos_lit("%"));
		byte fspec = (*(byte*)/*ee elem_typ */array_get(node.fmts, i));
		string fmt = ((*(bool*)/*ee elem_typ */array_get(node.pluss, i)) ? (tos_lit("+")) : (tos_lit("")));
		if ((*(bool*)/*ee elem_typ */array_get(node.fills, i)) && (*(int*)/*ee elem_typ */array_get(node.fwidths, i)) >= 0) {
			fmt = _STR("%.*s\0000", 2, fmt);
		}
		if ((*(int*)/*ee elem_typ */array_get(node.fwidths, i)) != 0) {
			fmt = _STR("%.*s\000%"PRId32"", 2, fmt, (*(int*)/*ee elem_typ */array_get(node.fwidths, i)));
		}
		if ((*(int*)/*ee elem_typ */array_get(node.precisions, i)) != 987698) {
			fmt = _STR("%.*s\000.%"PRId32"", 2, fmt, (*(int*)/*ee elem_typ */array_get(node.precisions, i)));
		}
		v__table__Type typ = v__gen__Gen_unwrap_generic(g, (*(v__table__Type*)/*ee elem_typ */array_get(node.expr_types, i)));
		if (fspec == 's') {
			if ((*(int*)/*ee elem_typ */array_get(node.fwidths, i)) == 0) {
				v__gen__Gen_write(g, tos_lit(".*s"));
			} else {
				v__gen__Gen_write(g, tos_lit("*.*s"));
			}
		} else if (v__table__Type_is_float(typ)) {
			v__gen__Gen_write(g, _STR("%.*s\000%c", 2, fmt, fspec));
		} else if (v__table__Type_is_pointer(typ)) {
			if (fspec == 'p') {
				v__gen__Gen_write(g, _STR("%.*s\000p", 2, fmt));
			} else {
				v__gen__Gen_write(g, _STR("%.*s\000\"PRI%c\000PTR\"", 3, fmt, fspec));
			}
		} else if (v__table__Type_is_int(typ)) {
			if (fspec == 'c') {
				v__gen__Gen_write(g, _STR("%.*s\000c", 2, fmt));
			} else {
				v__gen__Gen_write(g, _STR("%.*s\000\"PRI%c", 2, fmt, fspec));
				if ((typ == _const_v__table__i8_type || typ == _const_v__table__byte_type)) {
					v__gen__Gen_write(g, tos_lit("8"));
				} else if ((typ == _const_v__table__i16_type || typ == _const_v__table__u16_type)) {
					v__gen__Gen_write(g, tos_lit("16"));
				} else if ((typ == _const_v__table__i64_type || typ == _const_v__table__u64_type)) {
					v__gen__Gen_write(g, tos_lit("64"));
				} else {
					v__gen__Gen_write(g, tos_lit("32"));
				}
				v__gen__Gen_write(g, tos_lit("\""));
			}
		} else {
			v__gen__Gen_write(g, _STR("%.*s\000\"PRId32\"", 2, fmt));
		}
		if (i < node.exprs.len - 1) {
			v__gen__Gen_write(g, tos_lit("\\000"));
		}
	}
	int num_string_parts = (end_string ? (node.exprs.len + 1) : (node.exprs.len));
	v__gen__Gen_write(g, _STR("\", %"PRId32"\000, ", 2, num_string_parts));
	// FOR IN array
	array _t1604 = node.exprs;
	for (int i = 0; i < _t1604.len; ++i) {
		v__ast__Expr expr = ((v__ast__Expr*)_t1604.data)[i];
		v__table__Type typ = v__gen__Gen_unwrap_generic(g, (*(v__table__Type*)/*ee elem_typ */array_get(node.expr_types, i)));
		if (typ == _const_v__table__string_type) {
			if (g->inside_vweb_tmpl) {
				v__gen__Gen_write(g, tos_lit("vweb__filter("));
				v__gen__Gen_expr(g, expr);
				v__gen__Gen_write(g, tos_lit(")"));
			} else {
				v__gen__Gen_expr(g, expr);
			}
		} else if (typ == _const_v__table__bool_type) {
			v__gen__Gen_expr(g, expr);
			v__gen__Gen_write(g, tos_lit(" ? _SLIT(\"true\") : _SLIT(\"false\")"));
		} else if (v__table__Type_is_number(typ) || v__table__Type_is_pointer(typ) || (*(byte*)/*ee elem_typ */array_get(node.fmts, i)) == 'd') {
			if (v__table__Type_is_signed(typ) && ((*(byte*)/*ee elem_typ */array_get(node.fmts, i)) == 'x' || (*(byte*)/*ee elem_typ */array_get(node.fmts, i)) == 'X' || (*(byte*)/*ee elem_typ */array_get(node.fmts, i)) == 'o')) {
				if (typ == _const_v__table__i8_type) {
					v__gen__Gen_write(g, tos_lit("(byte)("));
				} else if (typ == _const_v__table__i16_type) {
					v__gen__Gen_write(g, tos_lit("(u16)("));
				} else if (typ == _const_v__table__int_type) {
					v__gen__Gen_write(g, tos_lit("(u32)("));
				} else {
					v__gen__Gen_write(g, tos_lit("(u64)("));
				}
				v__gen__Gen_expr(g, expr);
				v__gen__Gen_write(g, tos_lit(")"));
			} else {
				v__gen__Gen_expr(g, expr);
			}
		} else if ((*(byte*)/*ee elem_typ */array_get(node.fmts, i)) == 's') {
			v__gen__Gen_gen_expr_to_string(g, expr, typ);
		} else {
			v__gen__Gen_expr(g, expr);
		}
		if ((*(byte*)/*ee elem_typ */array_get(node.fmts, i)) == 's' && (*(int*)/*ee elem_typ */array_get(node.fwidths, i)) != 0) {
			v__gen__Gen_write(g, _STR(", %"PRId32"", 1, (*(int*)/*ee elem_typ */array_get(node.fwidths, i))));
		}
		if (i < node.exprs.len - 1) {
			v__gen__Gen_write(g, tos_lit(", "));
		}
	}
	v__gen__Gen_write(g, tos_lit(")"));
}

string v__gen__js__gen(array_v__ast__File files, v__table__Table* table, v__pref__Preferences* pref) {
	v__gen__js__JsGen* g = (v__gen__js__JsGen*)memdup(&(v__gen__js__JsGen){.table = table,
		.pref = pref,
		.definitions = strings__new_builder(100),
		.out = strings__new_builder(100),
		.namespaces = new_map_1(sizeof(strings__Builder)),
		.namespaces_pub = new_map_1(sizeof(array_string)),
		.namespace_imports = new_map_1(sizeof(map_string_string)),
		.v_namespace = (string){.str=(byteptr)""},
		.doc = 0,
		.enable_doc = true,
		.file = {0},
		.tmp_count = 0,
		.inside_ternary = 0,
		.inside_loop = 0,
		.inside_map_set = 0,
		.is_test = 0,
		.indents = new_map_1(sizeof(int)),
		.stmt_start_pos = 0,
		.defer_stmts = __new_array(0, 1, sizeof(v__ast__DeferStmt)),
		.fn_decl = 0,
		.str_types = __new_array(0, 1, sizeof(string)),
		.method_fn_decls = new_map_1(sizeof(array_v__ast__FnDecl)),
		.builtin_fns = __new_array(0, 1, sizeof(string)),
		.empty_line = true,
	}, sizeof(v__gen__js__JsGen));
	g->doc = v__gen__js__new_jsdoc(g);
	if (pref->is_prod) {
		g->enable_doc = false;
	}
	v__gen__js__JsGen_init(g);
	v__depgraph__DepGraph* graph = v__depgraph__new_dep_graph();
	// FOR IN array
	array _t1605 = files;
	for (int _t1606 = 0; _t1606 < _t1605.len; ++_t1606) {
		v__ast__File file = ((v__ast__File*)_t1605.data)[_t1606];
		g->file = file;
		v__gen__js__JsGen_enter_namespace(g, g->file.mod.name);
		g->is_test = string_ends_with(g->file.path, tos_lit("_test.v"));
		v__gen__js__JsGen_find_class_methods(g, file.stmts);
		v__gen__js__JsGen_escape_namespace(g);
	}
	// FOR IN array
	array _t1607 = files;
	for (int _t1608 = 0; _t1608 < _t1607.len; ++_t1608) {
		v__ast__File file = ((v__ast__File*)_t1607.data)[_t1608];
		g->file = file;
		v__gen__js__JsGen_enter_namespace(g, g->file.mod.name);
		g->is_test = string_ends_with(g->file.path, tos_lit("_test.v"));
		array_string imports = __new_array_with_default(0, 0, sizeof(string), 0);
		// FOR IN array
		array _t1609 = g->file.imports;
		for (int _t1610 = 0; _t1610 < _t1609.len; ++_t1610) {
			v__ast__Import imp = ((v__ast__Import*)_t1609.data)[_t1610];
			array_push(&imports, _MOV((string[]){ string_clone(imp.mod) }));
		}
		v__depgraph__DepGraph_add(graph, g->file.mod.name, imports);
		v__gen__js__JsGen_stmts(g, file.stmts);
		v__gen__js__JsGen_escape_namespace(g);
	}
	v__depgraph__DepGraph* deps_resolved = v__depgraph__DepGraph_resolve(graph);
	array_v__depgraph__DepGraphNode nodes = deps_resolved->nodes;
	string out = string_add(v__gen__js__JsGen_hashes(/*rec*/*g), strings__Builder_str(&g->definitions));
	// FOR IN array
	array _t1612 = nodes;
	for (int _t1613 = 0; _t1613 < _t1612.len; ++_t1613) {
		v__depgraph__DepGraphNode node = ((v__depgraph__DepGraphNode*)_t1612.data)[_t1613];
		string name = string_replace(v__gen__js__JsGen_js_name(g, node.name), tos_lit("."), tos_lit("_"));
		if (g->enable_doc) {
			out = /*f*/string_add(out, _STR("/** @namespace %.*s\000 */\n", 2, name));
		}
		out = /*f*/string_add(out, _STR("const %.*s\000 = (function (", 2, name));
		map_string_string imports = (*(map_string_string*)map_get(g->namespace_imports, node.name, &(map_string_string[]){ new_map_1(sizeof(string)) }));
		// FOR IN array
		array _t1614 = map_keys(&imports);
		for (int i = 0; i < _t1614.len; ++i) {
			string key = ((string*)_t1614.data)[i];
			if (i > 0) {
				out = /*f*/string_add(out, tos_lit(", "));
			}
			out = /*f*/string_add(out, (*(string*)map_get(imports, key, &(string[]){ (string){.str=(byteptr)""} })));
		}
		out = /*f*/string_add(out, tos_lit(") {\n\t"));
		out = /*f*/string_add(out, string_trim_space(strings__Builder_str(&(*(strings__Builder*)map_get(g->namespaces, node.name, &(strings__Builder[]){ {0} })))));
		out = /*f*/string_add(out, tos_lit("\n"));
		if (g->enable_doc) {
			out = /*f*/string_add(out, tos_lit("\n\t/* module exports */"));
		}
		out = /*f*/string_add(out, tos_lit("\n\treturn {"));
		// FOR IN array
		array _t1615 = (*(array_string*)map_get(g->namespaces_pub, node.name, &(array_string[]){ __new_array(0, 1, sizeof(string)) }));
		for (int i = 0; i < _t1615.len; ++i) {
			string pub_var = ((string*)_t1615.data)[i];
			out = /*f*/string_add(out, _STR("\n\t\t%.*s", 1, pub_var));
			if (i < (*(array_string*)map_get(g->namespaces_pub, node.name, &(array_string[]){ __new_array(0, 1, sizeof(string)) })).len - 1) {
				out = /*f*/string_add(out, tos_lit(","));
			}
		}
		if ((*(array_string*)map_get(g->namespaces_pub, node.name, &(array_string[]){ __new_array(0, 1, sizeof(string)) })).len > 0) {
			out = /*f*/string_add(out, tos_lit("\n\t"));
		}
		out = /*f*/string_add(out, tos_lit("};"));
		out = /*f*/string_add(out, tos_lit("\n})("));
		// FOR IN array
		array _t1616 = map_keys(&imports);
		for (int i = 0; i < _t1616.len; ++i) {
			string key = ((string*)_t1616.data)[i];
			if (i > 0) {
				out = /*f*/string_add(out, tos_lit(", "));
			}
			out = /*f*/string_add(out, string_replace(key, tos_lit("."), tos_lit("_")));
		}
		out = /*f*/string_add(out, tos_lit(");\n\n"));
	}
	if (pref->is_shared) {
		string v_export = (*(v__depgraph__DepGraphNode*)/*ee elem_typ */array_get(nodes, nodes.len - 1)).name;
		out = /*f*/string_add(out, _STR("if (typeof module === \"object\" && module.exports) module.exports = %.*s\000;", 2, v_export));
	}
	return out;
}

void v__gen__js__JsGen_enter_namespace(v__gen__js__JsGen* g, string n) {
	g->v_namespace = n;
	if ((*(strings__Builder*)map_get(g->namespaces, g->v_namespace, &(strings__Builder[]){ {0} })).len == 0) {
		g->out = strings__new_builder(100);
		map_set(&g->indents, g->v_namespace, &(int[]) { 0 });
	} else {
		g->out = (*(strings__Builder*)map_get(g->namespaces, g->v_namespace, &(strings__Builder[]){ {0} }));
	}
}

void v__gen__js__JsGen_escape_namespace(v__gen__js__JsGen* g) {
	(*(strings__Builder*)map_get_and_set(&g->namespaces, g->v_namespace, &(strings__Builder[]){ {0} })) = g->out;
	g->v_namespace = tos_lit("");
}

void v__gen__js__JsGen_push_pub_var(v__gen__js__JsGen* g, string s) {
	array_string arr = (*(array_string*)map_get(g->namespaces_pub, g->v_namespace, &(array_string[]){ __new_array(0, 1, sizeof(string)) }));
	array_push(&arr, _MOV((string[]){ string_clone(v__gen__js__JsGen_js_name(g, s)) }));
	map_set(&g->namespaces_pub, g->v_namespace, &(array_string[]) { arr });
}

void v__gen__js__JsGen_find_class_methods(v__gen__js__JsGen* g, array_v__ast__Stmt stmts) {
	// FOR IN array
	array _t1618 = stmts;
	for (int _t1619 = 0; _t1619 < _t1618.len; ++_t1619) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)_t1618.data)[_t1619];
		v__ast__Stmt _t1620 = stmt;
		if (_t1620.typ == 151 /* v.ast.FnDecl */) {
			if ((*stmt._151).is_method) {
				string class_name = v__table__Table_get_type_name(g->table, (*stmt._151).receiver.typ);
				array_v__ast__FnDecl arr = (*(array_v__ast__FnDecl*)map_get(g->method_fn_decls, class_name, &(array_v__ast__FnDecl[]){ __new_array(0, 1, sizeof(v__ast__FnDecl)) }));
				array_push(&arr, _MOV((v__ast__FnDecl[]){ (*stmt._151) }));
				map_set(&g->method_fn_decls, class_name, &(array_v__ast__FnDecl[]) { arr });
			}
		} else {
		};
	}
}

void v__gen__js__JsGen_init(v__gen__js__JsGen* g) {
	strings__Builder_writeln(&g->definitions, tos_lit("// Generated by the V compiler\n"));
	strings__Builder_writeln(&g->definitions, tos_lit("\"use strict\";"));
	strings__Builder_writeln(&g->definitions, tos_lit(""));
}

string v__gen__js__JsGen_hashes(v__gen__js__JsGen g) {
	string res = _STR("// V_COMMIT_HASH %.*s\000\n", 2, v__util__vhash());
	res = /*f*/string_add(res, _STR("// V_CURRENT_COMMIT_HASH %.*s\000\n", 2, v__util__githash(g.pref->building_v)));
	return res;
}

string v__gen__js__JsGen_typ(v__gen__js__JsGen* g, v__table__Type t) {
	v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, t);
	string styp = tos_lit("");
	v__table__Kind _t1622 = sym->kind;
	if (_t1622 == v__table__Kind_placeholder) {
		styp = tos_lit("any");
	} else if (_t1622 == v__table__Kind_void) {
		styp = tos_lit("void");
	} else if (_t1622 == v__table__Kind_voidptr) {
		styp = tos_lit("any");
	} else if (_t1622 == v__table__Kind_byteptr || _t1622 == v__table__Kind_charptr) {
		styp = tos_lit("string");
	} else if (_t1622 == v__table__Kind_i8 || _t1622 == v__table__Kind_i16 || _t1622 == v__table__Kind_int || _t1622 == v__table__Kind_i64 || _t1622 == v__table__Kind_byte || _t1622 == v__table__Kind_u16 || _t1622 == v__table__Kind_u32 || _t1622 == v__table__Kind_u64 || _t1622 == v__table__Kind_f32 || _t1622 == v__table__Kind_f64 || _t1622 == v__table__Kind_any_int || _t1622 == v__table__Kind_any_float || _t1622 == v__table__Kind_size_t) {
		styp = tos_lit("number");
	} else if (_t1622 == v__table__Kind_bool) {
		styp = tos_lit("boolean");
	} else if (_t1622 == v__table__Kind_none_) {
		styp = tos_lit("undefined");
	} else if (_t1622 == v__table__Kind_string || _t1622 == v__table__Kind_ustring || _t1622 == v__table__Kind_char) {
		styp = tos_lit("string");
	} else if (_t1622 == v__table__Kind_array) {
		v__table__Array info = /* as */ *(v__table__Array*)__as_cast((sym->info)._350, (sym->info).typ, /*expected:*/350);
		styp = string_add(v__gen__js__JsGen_typ(g, info.elem_type), tos_lit("[]"));
	} else if (_t1622 == v__table__Kind_array_fixed) {
		v__table__ArrayFixed info = /* as */ *(v__table__ArrayFixed*)__as_cast((sym->info)._351, (sym->info).typ, /*expected:*/351);
		styp = string_add(v__gen__js__JsGen_typ(g, info.elem_type), tos_lit("[]"));
	} else if (_t1622 == v__table__Kind_chan) {
		styp = tos_lit("chan");
	} else if (_t1622 == v__table__Kind_map) {
		v__table__Map info = /* as */ *(v__table__Map*)__as_cast((sym->info)._349, (sym->info).typ, /*expected:*/349);
		string key = v__gen__js__JsGen_typ(g, info.key_type);
		string val = v__gen__js__JsGen_typ(g, info.value_type);
		styp = _STR("Map<%.*s\000, %.*s\000>", 3, key, val);
	} else if (_t1622 == v__table__Kind_any) {
		styp = tos_lit("any");
	} else if (_t1622 == v__table__Kind_struct_) {
		styp = v__gen__js__JsGen_struct_typ(g, sym->name);
	} else if (_t1622 == v__table__Kind_generic_struct_inst) {
	} else if (_t1622 == v__table__Kind_multi_return) {
		v__table__MultiReturn info = /* as */ *(v__table__MultiReturn*)__as_cast((sym->info)._352, (sym->info).typ, /*expected:*/352);

		int _t1623_len = info.types.len;
		array_string _t1623 = __new_array(0, _t1623_len, sizeof(string));
		for (int _t1624 = 0; _t1624 < _t1623_len; ++_t1624) {
			v__table__Type it = ((v__table__Type*) info.types.data)[_t1624];
			string ti = v__gen__js__JsGen_typ(g, it);
			array_push(&_t1623, &ti);
		}
				array_string types = _t1623;
		string joined = array_string_join(types, tos_lit(", "));
		styp = _STR("[%.*s\000]", 2, joined);
	} else if (_t1622 == v__table__Kind_sum_type) {
		styp = tos_lit("union_sym_type");
	} else if (_t1622 == v__table__Kind_alias) {
		styp = tos_lit("alias");
	} else if (_t1622 == v__table__Kind_enum_) {
		styp = tos_lit("number");
	} else if (_t1622 == v__table__Kind_function) {
		v__table__FnType info = /* as */ *(v__table__FnType*)__as_cast((sym->info)._353, (sym->info).typ, /*expected:*/353);
		styp = v__gen__js__JsGen_fn_typ(g, info.func.params, info.func.return_type);
	} else if (_t1622 == v__table__Kind_interface_) {
		styp = v__gen__js__JsGen_js_name(g, sym->name);
	} else if (_t1622 == v__table__Kind_rune) {
		styp = tos_lit("any");
	} else if (_t1622 == v__table__Kind_aggregate) {
		v_panic(tos_lit("TODO: unhandled aggregate in JS"));
	};
	if (string_starts_with(styp, tos_lit("JS."))) {
		return string_substr(styp, 3, styp.len);
	}
	return styp;
}

VV_LOCAL_SYMBOL string v__gen__js__JsGen_fn_typ(v__gen__js__JsGen* g, array_v__table__Param args, v__table__Type return_type) {
	string res = tos_lit("(");
	// FOR IN array
	array _t1625 = args;
	for (int i = 0; i < _t1625.len; ++i) {
		v__table__Param arg = ((v__table__Param*)_t1625.data)[i];
		res = /*f*/string_add(res, _STR("%.*s\000: %.*s", 2, arg.name, v__gen__js__JsGen_typ(g, arg.typ)));
		if (i < args.len - 1) {
			res = /*f*/string_add(res, tos_lit(", "));
		}
	}
	return string_add(string_add(res, tos_lit(") => ")), v__gen__js__JsGen_typ(g, return_type));
}

VV_LOCAL_SYMBOL string v__gen__js__JsGen_struct_typ(v__gen__js__JsGen* g, string s) {
	string ns = v__gen__js__get_ns(s);
	string name = (string_eq(ns, g->v_namespace) ? (*(string*)array_last(string_split(s, tos_lit(".")))) : (v__gen__js__JsGen_get_alias(g, s)));
	string styp = tos_lit("");
	// FOR IN array
	array _t1626 = string_split(name, tos_lit("."));
	for (int i = 0; i < _t1626.len; ++i) {
		string v = ((string*)_t1626.data)[i];
		if (i == 0) {
			styp = v;
		} else {
			styp = /*f*/string_add(styp, _STR("[\"%.*s\000\"]", 2, v));
		}
	}
	if ((string_eq(ns, tos_lit("")) || string_eq(ns, g->v_namespace))) {
		return styp;
	}
	return string_add(styp, tos_lit("[\"prototype\"]"));
}

VV_LOCAL_SYMBOL string v__gen__js__JsGen_to_js_typ_val(v__gen__js__JsGen* g, v__table__Type t) {
	v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, t);
	string styp = tos_lit("");
	v__table__Kind _t1627 = sym->kind;
	if (_t1627 == v__table__Kind_i8 || _t1627 == v__table__Kind_i16 || _t1627 == v__table__Kind_int || _t1627 == v__table__Kind_i64 || _t1627 == v__table__Kind_byte || _t1627 == v__table__Kind_u16 || _t1627 == v__table__Kind_u32 || _t1627 == v__table__Kind_u64 || _t1627 == v__table__Kind_f32 || _t1627 == v__table__Kind_f64 || _t1627 == v__table__Kind_any_int || _t1627 == v__table__Kind_any_float || _t1627 == v__table__Kind_size_t) {
		styp = tos_lit("0");
	} else if (_t1627 == v__table__Kind_bool) {
		styp = tos_lit("false");
	} else if (_t1627 == v__table__Kind_string) {
		styp = tos_lit("\"\"");
	} else if (_t1627 == v__table__Kind_map) {
		styp = tos_lit("new Map()");
	} else if (_t1627 == v__table__Kind_array) {
		styp = tos_lit("[]");
	} else if (_t1627 == v__table__Kind_struct_) {
		styp = _STR("new %.*s\000({})", 2, v__gen__js__JsGen_js_name(g, sym->name));
	} else {
		styp = tos_lit("undefined");
	};
	return styp;
}

void v__gen__js__JsGen_gen_indent(v__gen__js__JsGen* g) {
	if ((*(int*)map_get(g->indents, g->v_namespace, &(int[]){ 0 })) > 0 && g->empty_line) {
		strings__Builder_write(&g->out, (*(string*)/*ee elem_typ */array_get(_const_v__gen__js__tabs, (*(int*)map_get(g->indents, g->v_namespace, &(int[]){ 0 })))));
	}
	g->empty_line = false;
}

void v__gen__js__JsGen_inc_indent(v__gen__js__JsGen* g) {
	(*(int*)map_get_and_set(&g->indents, g->v_namespace, &(int[]){ 0 }))++;
}

void v__gen__js__JsGen_dec_indent(v__gen__js__JsGen* g) {
	(*(int*)map_get_and_set(&g->indents, g->v_namespace, &(int[]){ 0 }))--;
}

void v__gen__js__JsGen_write(v__gen__js__JsGen* g, string s) {
	v__gen__js__JsGen_gen_indent(g);
	strings__Builder_write(&g->out, s);
}

void v__gen__js__JsGen_writeln(v__gen__js__JsGen* g, string s) {
	v__gen__js__JsGen_gen_indent(g);
	strings__Builder_writeln(&g->out, s);
	g->empty_line = true;
}

string v__gen__js__JsGen_new_tmp_var(v__gen__js__JsGen* g) {
	g->tmp_count++;
	return _STR("_tmp%"PRId32"", 1, g->tmp_count);
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL string v__gen__js__get_ns(string s) {
	Option_int _t1628 = string_last_index(s, tos_lit("."));
	if (!_t1628.ok) {
		string err = _t1628.v_error;
		int errcode = _t1628.ecode;
		return tos_lit("");
	}
 	int idx = *(int*) _t1628.data;
	return string_substr(s, 0, idx);
}

VV_LOCAL_SYMBOL string v__gen__js__JsGen_get_alias(v__gen__js__JsGen* g, string name) {
	string ns = v__gen__js__get_ns(name);
	if ((ns).len == 0) {
		return name;
	}
	map_string_string imports = (*(map_string_string*)map_get(g->namespace_imports, g->v_namespace, &(map_string_string[]){ new_map_1(sizeof(string)) }));
	string alias = (*(string*)map_get(imports, ns, &(string[]){ (string){.str=(byteptr)""} }));
	if ((alias).len == 0) {
		return name;
	}
	return string_add(string_add(alias, tos_lit(".")), *(string*)array_last(string_split(name, tos_lit("."))));
}

VV_LOCAL_SYMBOL string v__gen__js__JsGen_js_name(v__gen__js__JsGen* g, string name_) {
	string ns = v__gen__js__get_ns(name_);
	string name = (string_eq(ns, g->v_namespace) ? (*(string*)array_last(string_split(name_, tos_lit(".")))) : (v__gen__js__JsGen_get_alias(g, name_)));
	array_string parts = string_split(name, tos_lit("."));
	// FOR IN array
	array _t1629 = parts;
	for (int i = 0; i < _t1629.len; ++i) {
		string p = ((string*)_t1629.data)[i];
		if (_IN(string, p, _const_v__gen__js__js_reserved)) {
			array_set(&parts, i, &(string[]) { _STR("v_%.*s", 1, p) });
		}
	}
	return array_string_join(parts, tos_lit("."));
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_stmts(v__gen__js__JsGen* g, array_v__ast__Stmt stmts) {
	v__gen__js__JsGen_inc_indent(g);
	// FOR IN array
	array _t1630 = stmts;
	for (int _t1631 = 0; _t1631 < _t1630.len; ++_t1631) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)_t1630.data)[_t1631];
		v__gen__js__JsGen_stmt(g, stmt);
	}
	v__gen__js__JsGen_dec_indent(g);
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_stmt(v__gen__js__JsGen* g, v__ast__Stmt node) {
	g->stmt_start_pos = g->out.len;
	v__ast__Stmt _t1632 = node;
	if (_t1632.typ == 251 /* v.ast.AssertStmt */) {
		v__gen__js__JsGen_gen_assert_stmt(g, (*node._251));
	} else if (_t1632.typ == 252 /* v.ast.AssignStmt */) {
		v__gen__js__JsGen_gen_assign_stmt(g, (*node._252));
	} else if (_t1632.typ == 253 /* v.ast.Block */) {
		v__gen__js__JsGen_gen_block(g, (*node._253));
		v__gen__js__JsGen_writeln(g, tos_lit(""));
	} else if (_t1632.typ == 254 /* v.ast.BranchStmt */) {
		v__gen__js__JsGen_gen_branch_stmt(g, (*node._254));
	} else if (_t1632.typ == 255 /* v.ast.CompFor */) {
	} else if (_t1632.typ == 256 /* v.ast.ConstDecl */) {
		v__gen__js__JsGen_gen_const_decl(g, (*node._256));
	} else if (_t1632.typ == 257 /* v.ast.DeferStmt */) {
		array_push(&g->defer_stmts, _MOV((v__ast__DeferStmt[]){ (*node._257) }));
	} else if (_t1632.typ == 258 /* v.ast.EnumDecl */) {
		v__gen__js__JsGen_gen_enum_decl(g, (*node._258));
		v__gen__js__JsGen_writeln(g, tos_lit(""));
	} else if (_t1632.typ == 259 /* v.ast.ExprStmt */) {
		v__gen__js__JsGen_gen_expr_stmt(g, (*node._259));
	} else if (_t1632.typ == 151 /* v.ast.FnDecl */) {
		g->fn_decl = &(*node._151);
		v__gen__js__JsGen_gen_fn_decl(g, (*node._151));
	} else if (_t1632.typ == 260 /* v.ast.ForCStmt */) {
		v__gen__js__JsGen_gen_for_c_stmt(g, (*node._260));
		v__gen__js__JsGen_writeln(g, tos_lit(""));
	} else if (_t1632.typ == 261 /* v.ast.ForInStmt */) {
		v__gen__js__JsGen_gen_for_in_stmt(g, (*node._261));
		v__gen__js__JsGen_writeln(g, tos_lit(""));
	} else if (_t1632.typ == 262 /* v.ast.ForStmt */) {
		v__gen__js__JsGen_gen_for_stmt(g, (*node._262));
		v__gen__js__JsGen_writeln(g, tos_lit(""));
	} else if (_t1632.typ == 263 /* v.ast.GlobalDecl */) {
	} else if (_t1632.typ == 264 /* v.ast.GoStmt */) {
		v__gen__js__JsGen_gen_go_stmt(g, (*node._264));
		v__gen__js__JsGen_writeln(g, tos_lit(""));
	} else if (_t1632.typ == 265 /* v.ast.GotoLabel */) {
		v__gen__js__JsGen_writeln(g, _STR("%.*s\000:", 2, v__gen__js__JsGen_js_name(g, (*node._265).name)));
	} else if (_t1632.typ == 266 /* v.ast.GotoStmt */) {
	} else if (_t1632.typ == 267 /* v.ast.HashStmt */) {
		v__gen__js__JsGen_gen_hash_stmt(g, (*node._267));
	} else if (_t1632.typ == 268 /* v.ast.Import */) {
		v__gen__js__JsGen_gen_import_stmt(g, (*node._268));
	} else if (_t1632.typ == 269 /* v.ast.InterfaceDecl */) {
		v__gen__js__JsGen_gen_interface_decl(g, (*node._269));
	} else if (_t1632.typ == 270 /* v.ast.Module */) {
	} else if (_t1632.typ == 271 /* v.ast.Return */) {
		if (g->defer_stmts.len > 0) {
			v__gen__js__JsGen_gen_defer_stmts(g);
		}
		v__gen__js__JsGen_gen_return_stmt(g, (*node._271));
	} else if (_t1632.typ == 272 /* v.ast.SqlStmt */) {
	} else if (_t1632.typ == 273 /* v.ast.StructDecl */) {
		v__gen__js__JsGen_gen_struct_decl(g, (*node._273));
	} else if (_t1632.typ == 207 /* v.ast.TypeDecl */) {
	};
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_expr(v__gen__js__JsGen* g, v__ast__Expr node) {
	v__ast__Expr _t1634 = node;
	if (_t1634.typ == 214 /* v.ast.CTempVar */) {
		v__gen__js__JsGen_write(g, tos_lit("/* ast.CTempVar: node.name */"));
	} else if (_t1634.typ == 208 /* v.ast.AnonFn */) {
		v__gen__js__JsGen_gen_fn_decl(g, (*node._208).decl);
	} else if (_t1634.typ == 209 /* v.ast.ArrayInit */) {
		v__gen__js__JsGen_gen_array_init_expr(g, (*node._209));
	} else if (_t1634.typ == 210 /* v.ast.AsCast */) {
	} else if (_t1634.typ == 211 /* v.ast.Assoc */) {
	} else if (_t1634.typ == 213 /* v.ast.BoolLiteral */) {
		if ((*node._213).val == true) {
			v__gen__js__JsGen_write(g, tos_lit("true"));
		} else {
			v__gen__js__JsGen_write(g, tos_lit("false"));
		}
	} else if (_t1634.typ == 215 /* v.ast.CallExpr */) {
		v__gen__js__JsGen_gen_call_expr(g, (*node._215));
	} else if (_t1634.typ == 217 /* v.ast.ChanInit */) {
	} else if (_t1634.typ == 216 /* v.ast.CastExpr */) {
		v__gen__js__JsGen_expr(g, (*node._216).expr);
	} else if (_t1634.typ == 218 /* v.ast.CharLiteral */) {
		v__gen__js__JsGen_write(g, _STR("'%.*s\000'", 2, (*node._218).val));
	} else if (_t1634.typ == 219 /* v.ast.Comment */) {
	} else if (_t1634.typ == 221 /* v.ast.ConcatExpr */) {
	} else if (_t1634.typ == 222 /* v.ast.EnumVal */) {
		v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, (*node._222).typ);
		string styp = v__gen__js__JsGen_js_name(g, sym->name);
		v__gen__js__JsGen_write(g, _STR("%.*s\000.%.*s", 2, styp, (*node._222).val));
	} else if (_t1634.typ == 223 /* v.ast.FloatLiteral */) {
		v__gen__js__JsGen_write(g, (*node._223).val);
	} else if (_t1634.typ == 224 /* v.ast.Ident */) {
		v__gen__js__JsGen_gen_ident(g, (*node._224));
	} else if (_t1634.typ == 225 /* v.ast.IfExpr */) {
		v__gen__js__JsGen_gen_if_expr(g, (*node._225));
	} else if (_t1634.typ == 226 /* v.ast.IfGuardExpr */) {
	} else if (_t1634.typ == 227 /* v.ast.IndexExpr */) {
		v__gen__js__JsGen_gen_index_expr(g, (*node._227));
	} else if (_t1634.typ == 228 /* v.ast.InfixExpr */) {
		v__gen__js__JsGen_gen_infix_expr(g, (*node._228));
	} else if (_t1634.typ == 229 /* v.ast.IntegerLiteral */) {
		v__gen__js__JsGen_write(g, (*node._229).val);
	} else if (_t1634.typ == 231 /* v.ast.LockExpr */) {
		v__gen__js__JsGen_gen_lock_expr(g, (*node._231));
	} else if (_t1634.typ == 232 /* v.ast.MapInit */) {
		v__gen__js__JsGen_gen_map_init_expr(g, (*node._232));
	} else if (_t1634.typ == 233 /* v.ast.MatchExpr */) {
	} else if (_t1634.typ == 234 /* v.ast.None */) {
	} else if (_t1634.typ == 235 /* v.ast.OrExpr */) {
	} else if (_t1634.typ == 236 /* v.ast.ParExpr */) {
		v__gen__js__JsGen_write(g, tos_lit("("));
		v__gen__js__JsGen_expr(g, (*node._236).expr);
		v__gen__js__JsGen_write(g, tos_lit(")"));
	} else if (_t1634.typ == 237 /* v.ast.PostfixExpr */) {
		v__gen__js__JsGen_expr(g, (*node._237).expr);
		v__gen__js__JsGen_write(g, v__token__Kind_str((*node._237).op));
	} else if (_t1634.typ == 238 /* v.ast.PrefixExpr */) {
		if (((*node._238).op == v__token__Kind_amp || (*node._238).op == v__token__Kind_mul)) {
		} else {
			v__gen__js__JsGen_write(g, v__token__Kind_str((*node._238).op));
		}
		v__gen__js__JsGen_expr(g, (*node._238).right);
	} else if (_t1634.typ == 239 /* v.ast.RangeExpr */) {
	} else if (_t1634.typ == 240 /* v.ast.SelectExpr */) {
	} else if (_t1634.typ == 241 /* v.ast.SelectorExpr */) {
		v__gen__js__JsGen_gen_selector_expr(g, (*node._241));
	} else if (_t1634.typ == 242 /* v.ast.SizeOf */) {
	} else if (_t1634.typ == 243 /* v.ast.SqlExpr */) {
	} else if (_t1634.typ == 244 /* v.ast.StringInterLiteral */) {
		v__gen__js__JsGen_gen_string_inter_literal(g, (*node._244));
	} else if (_t1634.typ == 245 /* v.ast.StringLiteral */) {
		string text = string_replace((*node._245).val, tos_lit("`"), tos_lit("\\`"));
		v__gen__js__JsGen_write(g, _STR("`%.*s\000`", 2, text));
	} else if (_t1634.typ == 246 /* v.ast.StructInit */) {
		v__gen__js__JsGen_gen_struct_init(g, (*node._246));
	} else if (_t1634.typ == 247 /* v.ast.Type */) {
	} else if (_t1634.typ == 230 /* v.ast.Likely */) {
		v__gen__js__JsGen_write(g, tos_lit("("));
		v__gen__js__JsGen_expr(g, (*node._230).expr);
		v__gen__js__JsGen_write(g, tos_lit(")"));
	} else if (_t1634.typ == 248 /* v.ast.TypeOf */) {
		v__gen__js__JsGen_gen_typeof_expr(g, (*node._248));
	} else if (_t1634.typ == 212 /* v.ast.AtExpr */) {
		v__gen__js__JsGen_write(g, _STR("\"%.*s\000\"", 2, (*node._212).val));
	} else if (_t1634.typ == 220 /* v.ast.ComptimeCall */) {
	} else if (_t1634.typ == 249 /* v.ast.UnsafeExpr */) {
		v__gen__js__JsGen_expr(g, (*node._249).expr);
	};
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_assert_stmt(v__gen__js__JsGen* g, v__ast__AssertStmt a) {
	v__gen__js__JsGen_writeln(g, tos_lit("// assert"));
	v__gen__js__JsGen_write(g, tos_lit("if( "));
	v__gen__js__JsGen_expr(g, a.expr);
	v__gen__js__JsGen_write(g, tos_lit(" ) {"));
	string s_assertion = string_replace(v__ast__Expr_str(a.expr), tos_lit("\""), tos_lit("'"));
	string mod_path = string_replace(g->file.path, tos_lit("\\"), tos_lit("\\\\"));
	if (g->is_test) {
		v__gen__js__JsGen_writeln(g, tos_lit("	g_test_oks++;"));
		v__gen__js__JsGen_writeln(g, _STR("	cb_assertion_ok(\"%.*s\000\", %"PRId32"\000, \"assert %.*s\000\", \"%.*s\000()\" );", 5, mod_path, a.pos.line_nr + 1, s_assertion, g->fn_decl->name));
		v__gen__js__JsGen_writeln(g, tos_lit("} else {"));
		v__gen__js__JsGen_writeln(g, tos_lit("	g_test_fails++;"));
		v__gen__js__JsGen_writeln(g, _STR("	cb_assertion_failed(\"%.*s\000\", %"PRId32"\000, \"assert %.*s\000\", \"%.*s\000()\" );", 5, mod_path, a.pos.line_nr + 1, s_assertion, g->fn_decl->name));
		v__gen__js__JsGen_writeln(g, tos_lit("	exit(1);"));
		v__gen__js__JsGen_writeln(g, tos_lit("}"));
		return;
	}
	v__gen__js__JsGen_writeln(g, tos_lit("} else {"));
	v__gen__js__JsGen_inc_indent(g);
	v__gen__js__JsGen_writeln(g, _STR("builtin.eprintln(\"%.*s\000:%"PRId32"\000: FAIL: fn %.*s\000(): assert %.*s\000\");", 5, mod_path, a.pos.line_nr + 1, g->fn_decl->name, s_assertion));
	v__gen__js__JsGen_writeln(g, tos_lit("builtin.exit(1);"));
	v__gen__js__JsGen_dec_indent(g);
	v__gen__js__JsGen_writeln(g, tos_lit("}"));
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_assign_stmt(v__gen__js__JsGen* g, v__ast__AssignStmt stmt) {
	if (stmt.left.len > stmt.right.len) {
		v__gen__js__JsGen_write(g, tos_lit("const ["));
		// FOR IN array
		array _t1635 = stmt.left;
		for (int i = 0; i < _t1635.len; ++i) {
			v__ast__Expr left = ((v__ast__Expr*)_t1635.data)[i];
			if (!v__ast__Expr_is_blank_ident(left)) {
				v__gen__js__JsGen_expr(g, left);
			}
			if (i < stmt.left.len - 1) {
				v__gen__js__JsGen_write(g, tos_lit(", "));
			}
		}
		v__gen__js__JsGen_write(g, tos_lit("] = "));
		v__gen__js__JsGen_expr(g, (*(v__ast__Expr*)/*ee elem_typ */array_get(stmt.right, 0)));
		v__gen__js__JsGen_writeln(g, tos_lit(";"));
	} else {
		// FOR IN array
		array _t1636 = stmt.left;
		for (int i = 0; i < _t1636.len; ++i) {
			v__ast__Expr left = ((v__ast__Expr*)_t1636.data)[i];
			v__token__Kind op = stmt.op;
			if (stmt.op == v__token__Kind_decl_assign) {
				op = v__token__Kind_assign;
			}
			v__ast__Expr val = (*(v__ast__Expr*)/*ee elem_typ */array_get(stmt.right, i));
			bool is_mut = false;
			if ((left).typ == 224 /* v.ast.Ident */) {
				is_mut = (*left._224).is_mut;
				if ((*left._224).kind == v__ast__IdentKind_blank_ident || (string_eq((*left._224).name, tos_lit("")) || string_eq((*left._224).name, tos_lit("_")))) {
					string tmp_var = v__gen__js__JsGen_new_tmp_var(g);
					v__gen__js__JsGen_write(g, _STR("const %.*s\000 = ", 2, tmp_var));
					v__gen__js__JsGen_expr(g, val);
					v__gen__js__JsGen_writeln(g, tos_lit(";"));
					continue;
				}
			}
			string styp = v__gen__js__JsGen_typ(g, (*(v__table__Type*)/*ee elem_typ */array_get(stmt.left_types, i)));
			if (!g->inside_loop && styp.len > 0) {
				v__gen__js__JsDoc_gen_typ(g->doc, styp);
			}
			if (stmt.op == v__token__Kind_decl_assign) {
				if (g->inside_loop || is_mut) {
					v__gen__js__JsGen_write(g, tos_lit("let "));
				} else {
					v__gen__js__JsGen_write(g, tos_lit("const "));
				}
			}
			v__gen__js__JsGen_expr(g, left);
			if (g->inside_map_set && op == v__token__Kind_assign) {
				g->inside_map_set = false;
				v__gen__js__JsGen_write(g, tos_lit(", "));
				v__gen__js__JsGen_expr(g, val);
				v__gen__js__JsGen_write(g, tos_lit(")"));
			} else {
				v__gen__js__JsGen_write(g, _STR(" %.*s\000 ", 2, v__token__Kind_str(op)));
				v__gen__js__JsGen_expr(g, val);
			}
			if (g->inside_loop) {
				v__gen__js__JsGen_write(g, tos_lit("; "));
			} else {
				v__gen__js__JsGen_writeln(g, tos_lit(";"));
			}
		}
	}
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_attrs(v__gen__js__JsGen* g, array_v__table__Attr attrs) {
	// FOR IN array
	array _t1637 = attrs;
	for (int _t1638 = 0; _t1638 < _t1637.len; ++_t1638) {
		v__table__Attr attr = ((v__table__Attr*)_t1637.data)[_t1638];
		v__gen__js__JsGen_writeln(g, _STR("/* [%.*s\000] */", 2, attr.name));
	}
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_block(v__gen__js__JsGen* g, v__ast__Block it) {
	v__gen__js__JsGen_writeln(g, tos_lit("{"));
	v__gen__js__JsGen_stmts(g, it.stmts);
	v__gen__js__JsGen_writeln(g, tos_lit("}"));
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_branch_stmt(v__gen__js__JsGen* g, v__ast__BranchStmt it) {
	v__gen__js__JsGen_write(g, v__token__Kind_str(it.kind));
	v__gen__js__JsGen_writeln(g, tos_lit(";"));
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_const_decl(v__gen__js__JsGen* g, v__ast__ConstDecl it) {
	// FOR IN array
	array _t1639 = it.fields;
	for (int _t1640 = 0; _t1640 < _t1639.len; ++_t1640) {
		v__ast__ConstField field = ((v__ast__ConstField*)_t1639.data)[_t1640];
		v__gen__js__JsDoc_gen_const(g->doc, v__gen__js__JsGen_typ(g, field.typ));
		if (field.is_pub) {
			v__gen__js__JsGen_push_pub_var(g, field.name);
		}
		v__gen__js__JsGen_write(g, _STR("const %.*s\000 = ", 2, v__gen__js__JsGen_js_name(g, field.name)));
		v__gen__js__JsGen_expr(g, field.expr);
		v__gen__js__JsGen_writeln(g, tos_lit(";"));
	}
	v__gen__js__JsGen_writeln(g, tos_lit(""));
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_defer_stmts(v__gen__js__JsGen* g) {
	v__gen__js__JsGen_writeln(g, tos_lit("(function defer() {"));
	// FOR IN array
	array _t1641 = g->defer_stmts;
	for (int _t1642 = 0; _t1642 < _t1641.len; ++_t1642) {
		v__ast__DeferStmt defer_stmt = ((v__ast__DeferStmt*)_t1641.data)[_t1642];
		v__gen__js__JsGen_stmts(g, defer_stmt.stmts);
	}
	g->defer_stmts = __new_array_with_default(0, 0, sizeof(v__ast__DeferStmt), 0);
	v__gen__js__JsGen_writeln(g, tos_lit("})();"));
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_enum_decl(v__gen__js__JsGen* g, v__ast__EnumDecl it) {
	v__gen__js__JsDoc_gen_enum(g->doc);
	v__gen__js__JsGen_writeln(g, _STR("const %.*s\000 = {", 2, v__gen__js__JsGen_js_name(g, it.name)));
	v__gen__js__JsGen_inc_indent(g);
	int i = 0;
	// FOR IN array
	array _t1643 = it.fields;
	for (int _t1644 = 0; _t1644 < _t1643.len; ++_t1644) {
		v__ast__EnumField field = ((v__ast__EnumField*)_t1643.data)[_t1644];
		v__gen__js__JsGen_write(g, _STR("%.*s\000: ", 2, field.name));
		if (field.has_expr && (field.expr).typ == 229 /* v.ast.IntegerLiteral */) {
			v__ast__IntegerLiteral e = /* as */ *(v__ast__IntegerLiteral*)__as_cast((field.expr)._229, (field.expr).typ, /*expected:*/229);
			i = string_int(e.val);
		}
		v__gen__js__JsGen_writeln(g, _STR("%"PRId32"\000,", 2, i++));
	}
	v__gen__js__JsGen_dec_indent(g);
	v__gen__js__JsGen_writeln(g, tos_lit("};"));
	if (it.is_pub) {
		v__gen__js__JsGen_push_pub_var(g, it.name);
	}
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_expr_stmt(v__gen__js__JsGen* g, v__ast__ExprStmt it) {
	v__gen__js__JsGen_expr(g, it.expr);
	if (!it.is_expr && (it.expr).typ != 225 /* v.ast.IfExpr */ && !g->inside_ternary) {
		v__gen__js__JsGen_writeln(g, tos_lit(";"));
	}
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_fn_decl(v__gen__js__JsGen* g, v__ast__FnDecl it) {
	if (it.no_body || it.is_method) {
		return;
	}
	if (string_eq(g->v_namespace, tos_lit("builtin"))) {
		array_push(&g->builtin_fns, _MOV((string[]){ string_clone(it.name) }));
	}
	v__gen__js__JsGen_gen_method_decl(g, it);
}

VV_LOCAL_SYMBOL bool v__gen__js__fn_has_go(v__ast__FnDecl it) {
	bool has_go = false;
	// FOR IN array
	array _t1646 = it.stmts;
	for (int _t1647 = 0; _t1647 < _t1646.len; ++_t1647) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)_t1646.data)[_t1647];
		if ((stmt).typ == 264 /* v.ast.GoStmt */) {
			has_go = true;
		}
	}
	return has_go;
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_method_decl(v__gen__js__JsGen* g, v__ast__FnDecl it) {
	g->fn_decl = &it;
	bool has_go = v__gen__js__fn_has_go(it);
	bool is_main = string_eq(it.name, tos_lit("main.main"));
	v__gen__js__JsGen_gen_attrs(g, it.attrs);
	if (is_main) {
		v__gen__js__JsGen_writeln(g, tos_lit("/* program entry point */"));
		v__gen__js__JsGen_write(g, tos_lit("("));
		if (has_go) {
			v__gen__js__JsGen_write(g, tos_lit("async "));
		}
		v__gen__js__JsGen_write(g, tos_lit("function("));
	} else if (it.is_anon) {
		v__gen__js__JsGen_write(g, tos_lit("function ("));
	} else {
		string name = v__gen__js__JsGen_js_name(g, it.name);
		byte c = string_at(name, 0);
		if ((c == '+' || c == '-' || c == '*' || c == '/')) {
			name = v__util__replace_op(name);
		}
		v__gen__js__JsDoc_gen_fn(g->doc, it);
		if (has_go) {
			v__gen__js__JsGen_write(g, tos_lit("async "));
		}
		if (!it.is_method) {
			v__gen__js__JsGen_write(g, tos_lit("function "));
		}
		v__gen__js__JsGen_write(g, _STR("%.*s\000(", 2, name));
		if (it.is_pub && !it.is_method) {
			v__gen__js__JsGen_push_pub_var(g, name);
		}
	}
	array_v__table__Param args = it.params;
	if (it.is_method) {
		args = array_slice(args, 1, args.len);
	}
	v__gen__js__JsGen_fn_args(g, args, it.is_variadic);
	v__gen__js__JsGen_writeln(g, tos_lit(") {"));
	if (it.is_method) {
		v__gen__js__JsGen_inc_indent(g);
		v__gen__js__JsGen_writeln(g, _STR("const %.*s\000 = this;", 2, (*(v__table__Param*)/*ee elem_typ */array_get(it.params, 0)).name));
		v__gen__js__JsGen_dec_indent(g);
	}
	v__gen__js__JsGen_stmts(g, it.stmts);
	v__gen__js__JsGen_write(g, tos_lit("}"));
	if (is_main) {
		v__gen__js__JsGen_write(g, tos_lit(")();"));
	}
	if (!it.is_anon && !it.is_method) {
		v__gen__js__JsGen_writeln(g, tos_lit("\n"));
	}
	g->fn_decl = ((voidptr)(0));
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_fn_args(v__gen__js__JsGen* g, array_v__table__Param args, bool is_variadic) {
	// FOR IN array
	array _t1648 = args;
	for (int i = 0; i < _t1648.len; ++i) {
		v__table__Param arg = ((v__table__Param*)_t1648.data)[i];
		string name = v__gen__js__JsGen_js_name(g, arg.name);
		bool is_varg = i == args.len - 1 && is_variadic;
		if (is_varg) {
			v__gen__js__JsGen_write(g, _STR("...%.*s", 1, name));
		} else {
			v__gen__js__JsGen_write(g, name);
		}
		if (i < args.len - 1) {
			v__gen__js__JsGen_write(g, tos_lit(", "));
		}
	}
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_for_c_stmt(v__gen__js__JsGen* g, v__ast__ForCStmt it) {
	g->inside_loop = true;
	v__gen__js__JsGen_write(g, tos_lit("for ("));
	if (it.has_init) {
		v__gen__js__JsGen_stmt(g, it.init);
	} else {
		v__gen__js__JsGen_write(g, tos_lit("; "));
	}
	if (it.has_cond) {
		v__gen__js__JsGen_expr(g, it.cond);
	}
	v__gen__js__JsGen_write(g, tos_lit("; "));
	if (it.has_inc) {
		v__gen__js__JsGen_stmt(g, it.inc);
	}
	v__gen__js__JsGen_writeln(g, tos_lit(") {"));
	v__gen__js__JsGen_stmts(g, it.stmts);
	v__gen__js__JsGen_writeln(g, tos_lit("}"));
	g->inside_loop = false;
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_for_in_stmt(v__gen__js__JsGen* g, v__ast__ForInStmt it) {
	if (it.is_range) {
		string i = it.val_var;
		if ((string_eq(i, tos_lit("")) || string_eq(i, tos_lit("_")))) {
			i = v__gen__js__JsGen_new_tmp_var(g);
		}
		g->inside_loop = true;
		v__gen__js__JsGen_write(g, _STR("for (let %.*s\000 = ", 2, i));
		v__gen__js__JsGen_expr(g, it.cond);
		v__gen__js__JsGen_write(g, _STR("; %.*s\000 < ", 2, i));
		v__gen__js__JsGen_expr(g, it.high);
		v__gen__js__JsGen_writeln(g, _STR("; ++%.*s\000) {", 2, i));
		g->inside_loop = false;
		v__gen__js__JsGen_stmts(g, it.stmts);
		v__gen__js__JsGen_writeln(g, tos_lit("}"));
	} else if ((it.kind == v__table__Kind_array || it.kind == v__table__Kind_string) || v__table__Type_has_flag(it.cond_type, v__table__TypeFlag_variadic)) {
		string i = ((string_eq(it.key_var, tos_lit("")) || string_eq(it.key_var, tos_lit("_"))) ? (v__gen__js__JsGen_new_tmp_var(g)) : (it.key_var));
		string val = ((string_eq(it.val_var, tos_lit("")) || string_eq(it.val_var, tos_lit("_"))) ? (tos_lit("")) : (it.val_var));
		g->inside_loop = true;
		v__gen__js__JsGen_write(g, _STR("for (let %.*s\000 = 0; %.*s\000 < ", 3, i, i));
		v__gen__js__JsGen_expr(g, it.cond);
		v__gen__js__JsGen_writeln(g, _STR(".length; ++%.*s\000) {", 2, i));
		g->inside_loop = false;
		if (!(string_eq(val, tos_lit("")) || string_eq(val, tos_lit("_")))) {
			v__gen__js__JsGen_write(g, _STR("\tconst %.*s\000 = ", 2, val));
			v__gen__js__JsGen_expr(g, it.cond);
			v__gen__js__JsGen_writeln(g, _STR("[%.*s\000];", 2, i));
		}
		v__gen__js__JsGen_stmts(g, it.stmts);
		v__gen__js__JsGen_writeln(g, tos_lit("}"));
	} else if (it.kind == v__table__Kind_map) {
		string key = ((string_eq(it.key_var, tos_lit("")) || string_eq(it.key_var, tos_lit("_"))) ? (tos_lit("")) : (it.key_var));
		string val = ((string_eq(it.val_var, tos_lit("")) || string_eq(it.val_var, tos_lit("_"))) ? (tos_lit("")) : (it.val_var));
		v__gen__js__JsGen_write(g, _STR("for (let [%.*s\000, %.*s\000] of ", 3, key, val));
		v__gen__js__JsGen_expr(g, it.cond);
		v__gen__js__JsGen_writeln(g, tos_lit(") {"));
		v__gen__js__JsGen_stmts(g, it.stmts);
		v__gen__js__JsGen_writeln(g, tos_lit("}"));
	}
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_for_stmt(v__gen__js__JsGen* g, v__ast__ForStmt it) {
	v__gen__js__JsGen_write(g, tos_lit("while ("));
	if (it.is_inf) {
		v__gen__js__JsGen_write(g, tos_lit("true"));
	} else {
		v__gen__js__JsGen_expr(g, it.cond);
	}
	v__gen__js__JsGen_writeln(g, tos_lit(") {"));
	v__gen__js__JsGen_stmts(g, it.stmts);
	v__gen__js__JsGen_writeln(g, tos_lit("}"));
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_go_stmt(v__gen__js__JsGen* g, v__ast__GoStmt node) {
	v__ast__Expr _t1649 = node.call_expr;
	if (_t1649.typ == 215 /* v.ast.CallExpr */) {
		string name = (*node.call_expr._215).name;
		if ((*node.call_expr._215).is_method) {
			v__table__TypeSymbol* receiver_sym = v__table__Table_get_type_symbol(g->table, (*node.call_expr._215).receiver_type);
			name = string_add(string_add(receiver_sym->name, tos_lit(".")), name);
		}
		if (string_starts_with(name, _STR("%.*s\000.", 2, (*node.call_expr._215).mod))) {
			name = string_substr(name, (*node.call_expr._215).mod.len + 1, name.len);
		}
		v__gen__js__JsGen_writeln(g, tos_lit("await new Promise(function(resolve){"));
		v__gen__js__JsGen_inc_indent(g);
		v__gen__js__JsGen_write(g, _STR("%.*s\000(", 2, name));
		// FOR IN array
		array _t1650 = (*node.call_expr._215).args;
		for (int i = 0; i < _t1650.len; ++i) {
			v__ast__CallArg arg = ((v__ast__CallArg*)_t1650.data)[i];
			v__gen__js__JsGen_expr(g, arg.expr);
			if (i < (*node.call_expr._215).args.len - 1) {
				v__gen__js__JsGen_write(g, tos_lit(", "));
			}
		}
		v__gen__js__JsGen_writeln(g, tos_lit(");"));
		v__gen__js__JsGen_writeln(g, tos_lit("resolve();"));
		v__gen__js__JsGen_dec_indent(g);
		v__gen__js__JsGen_writeln(g, tos_lit("});"));
	} else {
	};
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_import_stmt(v__gen__js__JsGen* g, v__ast__Import it) {
	map_string_string imports = (*(map_string_string*)map_get(g->namespace_imports, g->v_namespace, &(map_string_string[]){ new_map_1(sizeof(string)) }));
	map_set(&imports, it.mod, &(string[]) { it.alias });
	(*(map_string_string*)map_get_and_set(&g->namespace_imports, g->v_namespace, &(map_string_string[]){ new_map_1(sizeof(string)) })) = imports;
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_interface_decl(v__gen__js__JsGen* g, v__ast__InterfaceDecl it) {
	v__gen__js__JsDoc_gen_interface(g->doc, it);
	string name = v__gen__js__JsGen_js_name(g, it.name);
	v__gen__js__JsGen_push_pub_var(g, _STR("/** @type %.*s\000 */\n\t\t%.*s\000: undefined", 3, name, name));
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_return_stmt(v__gen__js__JsGen* g, v__ast__Return it) {
	if (it.exprs.len == 0) {
		v__gen__js__JsGen_writeln(g, tos_lit("return;"));
		return;
	}
	v__gen__js__JsGen_write(g, tos_lit("return "));
	if (it.exprs.len == 1) {
		v__gen__js__JsGen_expr(g, (*(v__ast__Expr*)/*ee elem_typ */array_get(it.exprs, 0)));
	} else {
		v__gen__js__JsGen_gen_array_init_values(g, it.exprs);
	}
	v__gen__js__JsGen_writeln(g, tos_lit(";"));
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_hash_stmt(v__gen__js__JsGen* g, v__ast__HashStmt it) {
	v__gen__js__JsGen_writeln(g, it.val);
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_struct_decl(v__gen__js__JsGen* g, v__ast__StructDecl node) {
	if (string_starts_with(node.name, tos_lit("JS."))) {
		return;
	}
	v__gen__js__JsGen_gen_attrs(g, node.attrs);
	v__gen__js__JsDoc_gen_fac_fn(g->doc, node.fields);
	v__gen__js__JsGen_write(g, _STR("function %.*s\000({ ", 2, v__gen__js__JsGen_js_name(g, node.name)));
	// FOR IN array
	array _t1651 = node.fields;
	for (int i = 0; i < _t1651.len; ++i) {
		v__ast__StructField field = ((v__ast__StructField*)_t1651.data)[i];
		v__gen__js__JsGen_write(g, _STR("%.*s\000 = ", 2, field.name));
		if (field.has_default_expr) {
			v__gen__js__JsGen_expr(g, field.default_expr);
		} else {
			v__gen__js__JsGen_write(g, _STR("%.*s", 1, v__gen__js__JsGen_to_js_typ_val(g, field.typ)));
		}
		if (i < node.fields.len - 1) {
			v__gen__js__JsGen_write(g, tos_lit(", "));
		}
	}
	v__gen__js__JsGen_writeln(g, tos_lit(" }) {"));
	v__gen__js__JsGen_inc_indent(g);
	// FOR IN array
	array _t1652 = node.fields;
	for (int _t1653 = 0; _t1653 < _t1652.len; ++_t1653) {
		v__ast__StructField field = ((v__ast__StructField*)_t1652.data)[_t1653];
		v__gen__js__JsGen_writeln(g, _STR("this.%.*s\000 = %.*s", 2, field.name, field.name));
	}
	v__gen__js__JsGen_dec_indent(g);
	v__gen__js__JsGen_writeln(g, tos_lit("};"));
	v__gen__js__JsGen_writeln(g, _STR("%.*s\000.prototype = {", 2, v__gen__js__JsGen_js_name(g, node.name)));
	v__gen__js__JsGen_inc_indent(g);
	array_v__ast__FnDecl fns = (*(array_v__ast__FnDecl*)map_get(g->method_fn_decls, node.name, &(array_v__ast__FnDecl[]){ __new_array(0, 1, sizeof(v__ast__FnDecl)) }));
	// FOR IN array
	array _t1654 = node.fields;
	for (int i = 0; i < _t1654.len; ++i) {
		v__ast__StructField field = ((v__ast__StructField*)_t1654.data)[i];
		string typ = v__gen__js__JsGen_typ(g, field.typ);
		v__gen__js__JsDoc_gen_typ(g->doc, typ);
		v__gen__js__JsGen_write(g, _STR("%.*s\000: %.*s", 2, field.name, v__gen__js__JsGen_to_js_typ_val(g, field.typ)));
		if (i < node.fields.len - 1 || fns.len > 0) {
			v__gen__js__JsGen_writeln(g, tos_lit(","));
		} else {
			v__gen__js__JsGen_writeln(g, tos_lit(""));
		}
	}
	// FOR IN array
	array _t1655 = fns;
	for (int i = 0; i < _t1655.len; ++i) {
		v__ast__FnDecl cfn = ((v__ast__FnDecl*)_t1655.data)[i];
		v__gen__js__JsGen_gen_method_decl(g, cfn);
		if (i < fns.len - 1) {
			v__gen__js__JsGen_writeln(g, tos_lit(","));
		} else {
			v__gen__js__JsGen_writeln(g, tos_lit(""));
		}
	}
	v__gen__js__JsGen_dec_indent(g);
	v__gen__js__JsGen_writeln(g, tos_lit("};\n"));
	if (node.is_pub) {
		v__gen__js__JsGen_push_pub_var(g, node.name);
	}
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_array_init_expr(v__gen__js__JsGen* g, v__ast__ArrayInit it) {
	if (it.has_len) {
		string t1 = v__gen__js__JsGen_new_tmp_var(g);
		string t2 = v__gen__js__JsGen_new_tmp_var(g);
		v__gen__js__JsGen_writeln(g, tos_lit("(function() {"));
		v__gen__js__JsGen_inc_indent(g);
		v__gen__js__JsGen_writeln(g, _STR("const %.*s\000 = [];", 2, t1));
		v__gen__js__JsGen_write(g, _STR("for (let %.*s\000 = 0; %.*s\000 < ", 3, t2, t2));
		v__gen__js__JsGen_expr(g, it.len_expr);
		v__gen__js__JsGen_writeln(g, _STR("; %.*s\000++) {", 2, t2));
		v__gen__js__JsGen_inc_indent(g);
		v__gen__js__JsGen_write(g, _STR("%.*s\000.push(", 2, t1));
		if (it.has_default) {
			v__gen__js__JsGen_expr(g, it.default_expr);
		} else {
			string t = v__gen__js__JsGen_to_js_typ_val(g, it.elem_type);
			v__gen__js__JsGen_write(g, t);
		}
		v__gen__js__JsGen_writeln(g, tos_lit(");"));
		v__gen__js__JsGen_dec_indent(g);
		v__gen__js__JsGen_writeln(g, tos_lit("};"));
		v__gen__js__JsGen_writeln(g, _STR("return %.*s\000;", 2, t1));
		v__gen__js__JsGen_dec_indent(g);
		v__gen__js__JsGen_write(g, tos_lit("})()"));
	} else {
		v__gen__js__JsGen_gen_array_init_values(g, it.exprs);
	}
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_array_init_values(v__gen__js__JsGen* g, array_v__ast__Expr exprs) {
	v__gen__js__JsGen_write(g, tos_lit("["));
	// FOR IN array
	array _t1656 = exprs;
	for (int i = 0; i < _t1656.len; ++i) {
		v__ast__Expr expr = ((v__ast__Expr*)_t1656.data)[i];
		v__gen__js__JsGen_expr(g, expr);
		if (i < exprs.len - 1) {
			v__gen__js__JsGen_write(g, tos_lit(", "));
		}
	}
	v__gen__js__JsGen_write(g, tos_lit("]"));
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_call_expr(v__gen__js__JsGen* g, v__ast__CallExpr it) {
	string name = tos_lit("");
	if (string_starts_with(it.name, tos_lit("JS."))) {
		name = string_substr(it.name, 3, it.name.len);
	} else {
		name = v__gen__js__JsGen_js_name(g, it.name);
	}
	bool call_return_is_optional = v__table__Type_has_flag(it.return_type, v__table__TypeFlag_optional);
	if (call_return_is_optional) {
		v__gen__js__JsGen_writeln(g, tos_lit("(function(){"));
		v__gen__js__JsGen_inc_indent(g);
		v__gen__js__JsGen_writeln(g, tos_lit("try {"));
		v__gen__js__JsGen_inc_indent(g);
		v__gen__js__JsGen_write(g, tos_lit("return builtin.unwrap("));
	}
	v__gen__js__JsGen_expr(g, it.left);
	if (it.is_method) {
		v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, it.receiver_type);
		v__gen__js__JsGen_write(g, tos_lit("."));
		if (sym->kind == v__table__Kind_array && (string_eq(it.name, tos_lit("map")) || string_eq(it.name, tos_lit("filter")))) {
			v__ast__CallExpr node = it;
			v__gen__js__JsGen_write(g, it.name);
			v__gen__js__JsGen_write(g, tos_lit("("));
			v__ast__Expr expr = (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr;
			v__ast__Expr _t1657 = expr;
			if (_t1657.typ == 208 /* v.ast.AnonFn */) {
				v__gen__js__JsGen_gen_fn_decl(g, (*expr._208).decl);
				v__gen__js__JsGen_write(g, tos_lit(")"));
				return;
			} else if (_t1657.typ == 224 /* v.ast.Ident */) {
				if ((*expr._224).kind == v__ast__IdentKind_function) {
					v__gen__js__JsGen_write(g, v__gen__js__JsGen_js_name(g, (*expr._224).name));
					v__gen__js__JsGen_write(g, tos_lit(")"));
					return;
				} else if ((*expr._224).kind == v__ast__IdentKind_variable) {
					v__table__TypeSymbol* v_sym = v__table__Table_get_type_symbol(g->table, v__ast__Ident_var_info(&(*expr._224)).typ);
					if (v_sym->kind == v__table__Kind_function) {
						v__gen__js__JsGen_write(g, v__gen__js__JsGen_js_name(g, (*expr._224).name));
						v__gen__js__JsGen_write(g, tos_lit(")"));
						return;
					}
				}
			} else {
			};
			v__gen__js__JsGen_write(g, tos_lit("it => "));
			v__gen__js__JsGen_expr(g, (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, 0)).expr);
			v__gen__js__JsGen_write(g, tos_lit(")"));
			return;
		}
	} else {
		if (_IN(string, name, g->builtin_fns)) {
			v__gen__js__JsGen_write(g, tos_lit("builtin."));
		}
	}
	v__gen__js__JsGen_write(g, _STR("%.*s\000(", 2, v__gen__js__JsGen_js_name(g, name)));
	// FOR IN array
	array _t1658 = it.args;
	for (int i = 0; i < _t1658.len; ++i) {
		v__ast__CallArg arg = ((v__ast__CallArg*)_t1658.data)[i];
		v__gen__js__JsGen_expr(g, arg.expr);
		if (i != it.args.len - 1) {
			v__gen__js__JsGen_write(g, tos_lit(", "));
		}
	}
	v__gen__js__JsGen_write(g, tos_lit(")"));
	if (call_return_is_optional) {
		v__gen__js__JsGen_writeln(g, tos_lit(")"));
		v__gen__js__JsGen_dec_indent(g);
		v__gen__js__JsGen_writeln(g, tos_lit("} catch(err) {"));
		v__gen__js__JsGen_inc_indent(g);
		v__ast__OrKind _t1659 = it.or_block.kind;
		if (_t1659 == v__ast__OrKind_block) {
			if (it.or_block.stmts.len > 1) {
				v__gen__js__JsGen_stmts(g, array_slice(it.or_block.stmts, 0, it.or_block.stmts.len - 1));
			}
			v__gen__js__JsGen_write(g, tos_lit("return "));
			v__gen__js__JsGen_stmt(g, *(v__ast__Stmt*)array_last(it.or_block.stmts));
		} else if (_t1659 == v__ast__OrKind_propagate) {
			string panicstr = tos_lit("`optional not set (${err})`");
			if (string_eq(g->file.mod.name, tos_lit("main")) && string_eq(g->fn_decl->name, tos_lit("main.main"))) {
				v__gen__js__JsGen_writeln(g, _STR("return builtin.panic(%.*s\000)", 2, panicstr));
			} else {
				v__gen__js__JsGen_writeln(g, tos_lit("builtin.js_throw(err)"));
			}
		} else {
		};
		v__gen__js__JsGen_dec_indent(g);
		v__gen__js__JsGen_writeln(g, tos_lit("}"));
		v__gen__js__JsGen_dec_indent(g);
		v__gen__js__JsGen_write(g, tos_lit("})()"));
	}
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_ident(v__gen__js__JsGen* g, v__ast__Ident node) {
	string name = v__gen__js__JsGen_js_name(g, node.name);
	if (node.kind == v__ast__IdentKind_blank_ident || (string_eq(name, tos_lit("")) || string_eq(name, tos_lit("_")))) {
		name = v__gen__js__JsGen_new_tmp_var(g);
	}
	v__gen__js__JsGen_write(g, name);
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_lock_expr(v__gen__js__JsGen* g, v__ast__LockExpr node) {
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_if_expr(v__gen__js__JsGen* g, v__ast__IfExpr node) {
	v__table__TypeSymbol* type_sym = v__table__Table_get_type_symbol(g->table, node.typ);
	if (node.is_expr && node.branches.len >= 2 && node.has_else && type_sym->kind != v__table__Kind_void) {
		v__gen__js__JsGen_write(g, tos_lit("("));
		g->inside_ternary = true;
		// FOR IN array
		array _t1660 = node.branches;
		for (int i = 0; i < _t1660.len; ++i) {
			v__ast__IfBranch branch = ((v__ast__IfBranch*)_t1660.data)[i];
			if (i > 0) {
				v__gen__js__JsGen_write(g, tos_lit(" : "));
			}
			if (i < node.branches.len - 1 || !node.has_else) {
				v__gen__js__JsGen_expr(g, branch.cond);
				v__gen__js__JsGen_write(g, tos_lit(" ? "));
			}
			v__gen__js__JsGen_stmts(g, branch.stmts);
		}
		g->inside_ternary = false;
		v__gen__js__JsGen_write(g, tos_lit(")"));
	} else {
		// FOR IN array
		array _t1661 = node.branches;
		for (int i = 0; i < _t1661.len; ++i) {
			v__ast__IfBranch branch = ((v__ast__IfBranch*)_t1661.data)[i];
			if (i == 0) {
				v__ast__Expr _t1662 = branch.cond;
				if (_t1662.typ == 226 /* v.ast.IfGuardExpr */) {
				} else {
					v__gen__js__JsGen_write(g, tos_lit("if ("));
					if (string_eq(_STR("%.*s", 1, v__ast__Expr_str(branch.cond)), tos_lit("js"))) {
						v__gen__js__JsGen_write(g, tos_lit("true"));
					} else {
						v__gen__js__JsGen_expr(g, branch.cond);
					}
					v__gen__js__JsGen_writeln(g, tos_lit(") {"));
				};
			} else if (i < node.branches.len - 1 || !node.has_else) {
				v__gen__js__JsGen_write(g, tos_lit("} else if ("));
				v__gen__js__JsGen_expr(g, branch.cond);
				v__gen__js__JsGen_writeln(g, tos_lit(") {"));
			} else if (i == node.branches.len - 1 && node.has_else) {
				v__gen__js__JsGen_writeln(g, tos_lit("} else {"));
			}
			v__gen__js__JsGen_stmts(g, branch.stmts);
		}
		v__gen__js__JsGen_writeln(g, tos_lit("}"));
		v__gen__js__JsGen_writeln(g, tos_lit(""));
	}
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_index_expr(v__gen__js__JsGen* g, v__ast__IndexExpr expr) {
	v__table__TypeSymbol* left_typ = v__table__Table_get_type_symbol(g->table, expr.left_type);
	if ((expr.index).typ == 239 /* v.ast.RangeExpr */) {
		v__gen__js__JsGen_expr(g, expr.left);
		v__gen__js__JsGen_write(g, tos_lit(".slice("));
		if ((*expr.index._239).has_low) {
			v__gen__js__JsGen_expr(g, (*expr.index._239).low);
		} else {
			v__gen__js__JsGen_write(g, tos_lit("0"));
		}
		v__gen__js__JsGen_write(g, tos_lit(", "));
		if ((*expr.index._239).has_high) {
			v__gen__js__JsGen_expr(g, (*expr.index._239).high);
		} else {
			v__gen__js__JsGen_expr(g, expr.left);
			v__gen__js__JsGen_write(g, tos_lit(".length"));
		}
		v__gen__js__JsGen_write(g, tos_lit(")"));
	} else if (left_typ->kind == v__table__Kind_map) {
		v__gen__js__JsGen_expr(g, expr.left);
		if (expr.is_setter) {
			g->inside_map_set = true;
			v__gen__js__JsGen_write(g, tos_lit(".set("));
		} else {
			v__gen__js__JsGen_write(g, tos_lit(".get("));
		}
		v__gen__js__JsGen_expr(g, expr.index);
		if (!expr.is_setter) {
			v__gen__js__JsGen_write(g, tos_lit(")"));
		}
	} else if (left_typ->kind == v__table__Kind_string) {
		if (expr.is_setter) {
		} else {
			v__gen__js__JsGen_expr(g, expr.left);
			v__gen__js__JsGen_write(g, tos_lit(".charCodeAt("));
			v__gen__js__JsGen_expr(g, expr.index);
			v__gen__js__JsGen_write(g, tos_lit(")"));
		}
	} else {
		v__gen__js__JsGen_expr(g, expr.left);
		v__gen__js__JsGen_write(g, tos_lit("["));
		v__gen__js__JsGen_expr(g, expr.index);
		v__gen__js__JsGen_write(g, tos_lit("]"));
	}
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_infix_expr(v__gen__js__JsGen* g, v__ast__InfixExpr it) {
	v__table__TypeSymbol* l_sym = v__table__Table_get_type_symbol(g->table, it.left_type);
	v__table__TypeSymbol* r_sym = v__table__Table_get_type_symbol(g->table, it.right_type);
	if (l_sym->kind == v__table__Kind_array && it.op == v__token__Kind_left_shift) {
		v__gen__js__JsGen_expr(g, it.left);
		v__gen__js__JsGen_write(g, tos_lit(".push("));
		if (r_sym->kind == v__table__Kind_array) {
			v__gen__js__JsGen_write(g, tos_lit("..."));
		}
		v__gen__js__JsGen_expr(g, it.right);
		v__gen__js__JsGen_write(g, tos_lit(")"));
	} else if ((r_sym->kind == v__table__Kind_array || r_sym->kind == v__table__Kind_map || r_sym->kind == v__table__Kind_string) && (it.op == v__token__Kind_key_in || it.op == v__token__Kind_not_in)) {
		if (it.op == v__token__Kind_not_in) {
			v__gen__js__JsGen_write(g, tos_lit("!("));
		}
		v__gen__js__JsGen_expr(g, it.right);
		v__gen__js__JsGen_write(g, (r_sym->kind == v__table__Kind_map ? (tos_lit(".has(")) : (tos_lit(".includes("))));
		v__gen__js__JsGen_expr(g, it.left);
		v__gen__js__JsGen_write(g, tos_lit(")"));
		if (it.op == v__token__Kind_not_in) {
			v__gen__js__JsGen_write(g, tos_lit(")"));
		}
	} else if ((it.op == v__token__Kind_key_is || it.op == v__token__Kind_not_is)) {
		if (it.op == v__token__Kind_not_is) {
			v__gen__js__JsGen_write(g, tos_lit("!("));
		}
		v__gen__js__JsGen_expr(g, it.left);
		v__gen__js__JsGen_write(g, tos_lit(" instanceof "));
		v__gen__js__JsGen_write(g, v__gen__js__JsGen_typ(g, it.right_type));
		if (it.op == v__token__Kind_not_is) {
			v__gen__js__JsGen_write(g, tos_lit(")"));
		}
	} else {
		bool both_are_int = _IN(int, ((int)(it.left_type)), _const_v__table__integer_type_idxs) && _IN(int, ((int)(it.right_type)), _const_v__table__integer_type_idxs);
		if (it.op == v__token__Kind_div && both_are_int) {
			v__gen__js__JsGen_write(g, tos_lit("parseInt("));
		}
		v__gen__js__JsGen_expr(g, it.left);
		if (it.op == v__token__Kind_eq) {
			v__gen__js__JsGen_write(g, tos_lit(" === "));
		} else if (it.op == v__token__Kind_ne) {
			v__gen__js__JsGen_write(g, tos_lit(" !== "));
		} else {
			v__gen__js__JsGen_write(g, _STR(" %.*s\000 ", 2, v__token__Kind_str(it.op)));
		}
		v__gen__js__JsGen_expr(g, it.right);
		if (it.op == v__token__Kind_div && both_are_int) {
			v__gen__js__JsGen_write(g, tos_lit(",10)"));
		}
	}
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_map_init_expr(v__gen__js__JsGen* g, v__ast__MapInit it) {
	if (it.vals.len > 0) {
		v__gen__js__JsGen_writeln(g, tos_lit("new Map(["));
		v__gen__js__JsGen_inc_indent(g);
		// FOR IN array
		array _t1663 = it.keys;
		for (int i = 0; i < _t1663.len; ++i) {
			v__ast__Expr key = ((v__ast__Expr*)_t1663.data)[i];
			v__ast__Expr val = (*(v__ast__Expr*)/*ee elem_typ */array_get(it.vals, i));
			v__gen__js__JsGen_write(g, tos_lit("["));
			v__gen__js__JsGen_expr(g, key);
			v__gen__js__JsGen_write(g, tos_lit(", "));
			v__gen__js__JsGen_expr(g, val);
			v__gen__js__JsGen_write(g, tos_lit("]"));
			if (i < it.keys.len - 1) {
				v__gen__js__JsGen_write(g, tos_lit(","));
			}
			v__gen__js__JsGen_writeln(g, tos_lit(""));
		}
		v__gen__js__JsGen_dec_indent(g);
		v__gen__js__JsGen_write(g, tos_lit("])"));
	} else {
		v__gen__js__JsGen_write(g, tos_lit("new Map()"));
	}
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_selector_expr(v__gen__js__JsGen* g, v__ast__SelectorExpr it) {
	v__gen__js__JsGen_expr(g, it.expr);
	v__gen__js__JsGen_write(g, _STR(".%.*s", 1, it.field_name));
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_string_inter_literal(v__gen__js__JsGen* g, v__ast__StringInterLiteral it) {
	v__gen__js__JsGen_write(g, tos_lit("`"));
	// FOR IN array
	array _t1664 = it.vals;
	for (int i = 0; i < _t1664.len; ++i) {
		string val = ((string*)_t1664.data)[i];
		string escaped_val = string_replace(val, tos_lit("`"), tos_lit("\\`"));
		v__gen__js__JsGen_write(g, escaped_val);
		if (i >= it.exprs.len) {
			continue;
		}
		v__ast__Expr expr = (*(v__ast__Expr*)/*ee elem_typ */array_get(it.exprs, i));
		byte fmt = (*(byte*)/*ee elem_typ */array_get(it.fmts, i));
		int fwidth = (*(int*)/*ee elem_typ */array_get(it.fwidths, i));
		int precision = (*(int*)/*ee elem_typ */array_get(it.precisions, i));
		v__gen__js__JsGen_write(g, tos_lit("${"));
		if (fmt != '_' || fwidth != 0 || precision != 987698) {
			v__gen__js__JsGen_expr(g, expr);
		} else {
			v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, (*(v__table__Type*)/*ee elem_typ */array_get(it.expr_types, i)));
			v__gen__js__JsGen_expr(g, expr);
			if (sym->kind == v__table__Kind_struct_ && v__table__TypeSymbol_has_method(sym, tos_lit("str"))) {
				v__gen__js__JsGen_write(g, tos_lit(".str()"));
			}
		}
		v__gen__js__JsGen_write(g, tos_lit("}"));
	}
	v__gen__js__JsGen_write(g, tos_lit("`"));
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_struct_init(v__gen__js__JsGen* g, v__ast__StructInit it) {
	v__table__TypeSymbol* type_sym = v__table__Table_get_type_symbol(g->table, it.typ);
	string name = type_sym->name;
	if (it.fields.len == 0) {
		v__gen__js__JsGen_write(g, _STR("new %.*s\000({})", 2, v__gen__js__JsGen_js_name(g, name)));
	} else {
		v__gen__js__JsGen_writeln(g, _STR("new %.*s\000({", 2, v__gen__js__JsGen_js_name(g, name)));
		v__gen__js__JsGen_inc_indent(g);
		// FOR IN array
		array _t1665 = it.fields;
		for (int i = 0; i < _t1665.len; ++i) {
			v__ast__StructInitField field = ((v__ast__StructInitField*)_t1665.data)[i];
			v__gen__js__JsGen_write(g, _STR("%.*s\000: ", 2, field.name));
			v__gen__js__JsGen_expr(g, field.expr);
			if (i < it.fields.len - 1) {
				v__gen__js__JsGen_write(g, tos_lit(","));
			}
			v__gen__js__JsGen_writeln(g, tos_lit(""));
		}
		v__gen__js__JsGen_dec_indent(g);
		v__gen__js__JsGen_write(g, tos_lit("})"));
	}
}

VV_LOCAL_SYMBOL void v__gen__js__JsGen_gen_typeof_expr(v__gen__js__JsGen* g, v__ast__TypeOf it) {
	v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, it.expr_type);
	if (sym->kind == v__table__Kind_sum_type) {
	} else if (sym->kind == v__table__Kind_array_fixed) {
		v__table__ArrayFixed fixed_info = /* as */ *(v__table__ArrayFixed*)__as_cast((sym->info)._351, (sym->info).typ, /*expected:*/351);
		string typ_name = v__table__Table_get_type_name(g->table, fixed_info.elem_type);
		v__gen__js__JsGen_write(g, _STR("\"[%"PRId32"\000]%.*s\000\"", 3, fixed_info.size, typ_name));
	} else if (sym->kind == v__table__Kind_function) {
		v__table__FnType info = /* as */ *(v__table__FnType*)__as_cast((sym->info)._353, (sym->info).typ, /*expected:*/353);
		v__table__Fn fn_info = info.func;
		string repr = tos_lit("fn (");
		// FOR IN array
		array _t1666 = fn_info.params;
		for (int i = 0; i < _t1666.len; ++i) {
			v__table__Param arg = ((v__table__Param*)_t1666.data)[i];
			if (i > 0) {
				repr = /*f*/string_add(repr, tos_lit(", "));
			}
			repr = /*f*/string_add(repr, v__table__Table_get_type_name(g->table, arg.typ));
		}
		repr = /*f*/string_add(repr, tos_lit(")"));
		if (fn_info.return_type != _const_v__table__void_type) {
			repr = /*f*/string_add(repr, _STR(" %.*s", 1, v__table__Table_get_type_name(g->table, fn_info.return_type)));
		}
		v__gen__js__JsGen_write(g, _STR("\"%.*s\000\"", 2, repr));
	} else {
		v__gen__js__JsGen_write(g, _STR("\"%.*s\000\"", 2, sym->name));
	}
}

VV_LOCAL_SYMBOL v__gen__js__JsDoc* v__gen__js__new_jsdoc(v__gen__js__JsGen* gen) {
	return (v__gen__js__JsDoc*)memdup(&(v__gen__js__JsDoc){.gen = gen,}, sizeof(v__gen__js__JsDoc));
}

VV_LOCAL_SYMBOL void v__gen__js__JsDoc_write(v__gen__js__JsDoc* d, string s) {
	if (!d->gen->enable_doc) {
		return;
	}
	v__gen__js__JsGen_write(d->gen, s);
}

VV_LOCAL_SYMBOL void v__gen__js__JsDoc_writeln(v__gen__js__JsDoc* d, string s) {
	if (!d->gen->enable_doc) {
		return;
	}
	v__gen__js__JsGen_writeln(d->gen, s);
}

VV_LOCAL_SYMBOL void v__gen__js__JsDoc_gen_typ(v__gen__js__JsDoc* d, string typ) {
	v__gen__js__JsDoc_writeln(d, _STR("/** @type {%.*s\000} */", 2, typ));
}

VV_LOCAL_SYMBOL void v__gen__js__JsDoc_gen_const(v__gen__js__JsDoc* d, string typ) {
	v__gen__js__JsDoc_writeln(d, _STR("/** @constant {%.*s\000} */", 2, typ));
}

VV_LOCAL_SYMBOL void v__gen__js__JsDoc_gen_enum(v__gen__js__JsDoc* d) {
	string typ = tos_lit("number");
	v__gen__js__JsDoc_writeln(d, _STR("/** @enum {%.*s\000} */", 2, typ));
}

VV_LOCAL_SYMBOL void v__gen__js__JsDoc_gen_fac_fn(v__gen__js__JsDoc* d, array_v__ast__StructField fields) {
	v__gen__js__JsDoc_writeln(d, tos_lit("/**"));
	v__gen__js__JsDoc_writeln(d, tos_lit(" * @constructor"));
	v__gen__js__JsDoc_write(d, tos_lit(" * @param {{"));
	// FOR IN array
	array _t1667 = fields;
	for (int i = 0; i < _t1667.len; ++i) {
		v__ast__StructField field = ((v__ast__StructField*)_t1667.data)[i];
		v__gen__js__JsDoc_write(d, _STR("%.*s\000?: %.*s", 2, field.name, v__gen__js__JsGen_typ(d->gen, field.typ)));
		if (i < fields.len - 1) {
			v__gen__js__JsDoc_write(d, tos_lit(", "));
		}
	}
	v__gen__js__JsDoc_writeln(d, tos_lit("}} init"));
	v__gen__js__JsDoc_writeln(d, tos_lit("*/"));
}

VV_LOCAL_SYMBOL void v__gen__js__JsDoc_gen_fn(v__gen__js__JsDoc* d, v__ast__FnDecl it) {
	string type_name = v__gen__js__JsGen_typ(d->gen, it.return_type);
	v__gen__js__JsDoc_writeln(d, tos_lit("/**"));
	v__gen__js__JsDoc_writeln(d, tos_lit(" * @function"));
	if (it.is_deprecated) {
		v__gen__js__JsDoc_writeln(d, tos_lit(" * @deprecated"));
	}
	// FOR IN array
	array _t1668 = it.params;
	for (int i = 0; i < _t1668.len; ++i) {
		v__table__Param arg = ((v__table__Param*)_t1668.data)[i];
		if ((it.is_method || it.receiver.typ == 0) && i == 0) {
			continue;
		}
		string arg_type_name = v__gen__js__JsGen_typ(d->gen, arg.typ);
		bool is_varg = i == it.params.len - 1 && it.is_variadic;
		string name = v__gen__js__JsGen_js_name(d->gen, arg.name);
		if (is_varg) {
			v__gen__js__JsDoc_writeln(d, _STR(" * @param {...%.*s\000} %.*s", 2, arg_type_name, name));
		} else {
			v__gen__js__JsDoc_writeln(d, _STR(" * @param {%.*s\000} %.*s", 2, arg_type_name, name));
		}
	}
	v__gen__js__JsDoc_writeln(d, _STR(" * @returns {%.*s\000}", 2, type_name));
	v__gen__js__JsDoc_writeln(d, tos_lit("*/"));
}

VV_LOCAL_SYMBOL void v__gen__js__JsDoc_gen_interface(v__gen__js__JsDoc* d, v__ast__InterfaceDecl it) {
	string name = v__gen__js__JsGen_js_name(d->gen, it.name);
	v__gen__js__JsDoc_writeln(d, tos_lit("/**"));
	v__gen__js__JsDoc_writeln(d, _STR(" * @interface %.*s", 1, name));
	v__gen__js__JsDoc_writeln(d, _STR(" * @typedef %.*s", 1, name));
	// FOR IN array
	array _t1669 = it.methods;
	for (int _t1670 = 0; _t1670 < _t1669.len; ++_t1670) {
		v__ast__FnDecl method = ((v__ast__FnDecl*)_t1669.data)[_t1670];
		string typ = v__gen__js__JsGen_fn_typ(d->gen, array_slice(method.params, 1, method.params.len), method.return_type);
		string method_name = v__gen__js__JsGen_js_name(d->gen, method.name);
		v__gen__js__JsDoc_writeln(d, _STR(" * @property {%.*s\000} %.*s", 2, typ, method_name));
	}
	v__gen__js__JsDoc_writeln(d, tos_lit(" */\n"));
}

void v__gen__x64__Gen_generate_elf_header(v__gen__x64__Gen* g) {
	_PUSH_MANY(&g->buf, (new_array_from_c_array(4, 4, sizeof(byte), _MOV((byte[4]){((byte)(_const_v__gen__x64__mag0)), _const_v__gen__x64__mag1, _const_v__gen__x64__mag2, _const_v__gen__x64__mag3}))), _t1671, array_byte);
	array_push(&g->buf, _MOV((byte[]){ _const_v__gen__x64__elfclass64 }));
	array_push(&g->buf, _MOV((byte[]){ _const_v__gen__x64__elfdata2lsb }));
	array_push(&g->buf, _MOV((byte[]){ _const_v__gen__x64__ev_current }));
	array_push(&g->buf, _MOV((byte[]){ 1 }));
	v__gen__x64__Gen_write64(g, 0);
	v__gen__x64__Gen_write16(g, 2);
	v__gen__x64__Gen_write16(g, _const_v__gen__x64__e_machine);
	v__gen__x64__Gen_write32(g, _const_v__gen__x64__ev_current);
	int eh_size = 0x40;
	int phent_size = 0x38;
	v__gen__x64__Gen_write64(g, _const_v__gen__x64__segment_start + eh_size + phent_size);
	v__gen__x64__Gen_write64(g, 0x40);
	v__gen__x64__Gen_write64(g, 0);
	v__gen__x64__Gen_write32(g, 0);
	v__gen__x64__Gen_write16(g, eh_size);
	v__gen__x64__Gen_write16(g, phent_size);
	v__gen__x64__Gen_write16(g, 1);
	v__gen__x64__Gen_write16(g, 0);
	v__gen__x64__Gen_write16(g, 0);
	v__gen__x64__Gen_write16(g, 0);
	v__gen__x64__Gen_write32(g, 1);
	v__gen__x64__Gen_write32(g, 5);
	v__gen__x64__Gen_write64(g, 0);
	v__gen__x64__Gen_write64(g, _const_v__gen__x64__segment_start);
	v__gen__x64__Gen_write64(g, _const_v__gen__x64__segment_start);
	g->file_size_pos = ((i64)(g->buf.len));
	v__gen__x64__Gen_write64(g, 0);
	v__gen__x64__Gen_write64(g, 0);
	v__gen__x64__Gen_write64(g, 0x1000);
	println(_STR("code_start_pos = %.*s", 1, int_hex(g->buf.len)));
	g->code_start_pos = ((i64)(g->buf.len));
	g->debug_pos = g->buf.len;
	v__gen__x64__Gen_call(g, _const_v__gen__x64__placeholder);
	v__gen__x64__Gen_println(g, tos_lit("call fn main"));
}

void v__gen__x64__Gen_generate_elf_footer(v__gen__x64__Gen* g) {
	// FOR IN array
	array _t1676 = g->strings;
	for (int i = 0; i < _t1676.len; ++i) {
		string s = ((string*)_t1676.data)[i];
		v__gen__x64__Gen_write64_at(g, _const_v__gen__x64__segment_start + g->buf.len, ((int)((*(i64*)/*ee elem_typ */array_get(g->str_pos, i)))));
		v__gen__x64__Gen_write_string(g, s);
		v__gen__x64__Gen_write8(g, 0);
	}
	int file_size = g->buf.len;
	v__gen__x64__Gen_write64_at(g, file_size, g->file_size_pos);
	v__gen__x64__Gen_write64_at(g, file_size, g->file_size_pos + 8);
	v__gen__x64__Gen_write32_at(g, g->code_start_pos + 1, ((int)(g->main_fn_addr - g->code_start_pos)) - 5);
	Option_os__File _t1677 = os__create(g->out_name);
	if (!_t1677.ok) {
		string err = _t1677.v_error;
		int errcode = _t1677.ecode;
		v_panic(err);
	}
 	os__File f = *(os__File*) _t1677.data;
	os__chmod(g->out_name, 0775);
	os__File_write_bytes(&f, g->buf.data, g->buf.len);
	os__File_close(&f);
	println(tos_lit("\nx64 elf binary has been successfully generated"));
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_section_header(v__gen__x64__Gen* g, v__gen__x64__SectionConfig c) {
	v__gen__x64__Gen_write32(g, g->sect_header_name_pos);
	g->sect_header_name_pos += c.name.len + 1;
	v__gen__x64__Gen_write32(g, ((int)(c.typ)));
	v__gen__x64__Gen_write64(g, c.flags);
	v__gen__x64__Gen_write64(g, 0);
	v__gen__x64__Gen_write64(g, g->offset);
	g->offset += c.datalen + 1;
	v__gen__x64__Gen_write64(g, c.datalen);
	v__gen__x64__Gen_write32(g, c.v_link);
	v__gen__x64__Gen_write32(g, c.info);
	v__gen__x64__Gen_write64(g, c.align);
	v__gen__x64__Gen_write64(g, c.entsize);
}

VV_LOCAL_SYMBOL void v__gen__x64__genobj() {
}

void v__gen__x64__gen(array_v__ast__File files, v__table__Table* table, string out_name, v__pref__Preferences* pref) {
	v__gen__x64__Gen g = (v__gen__x64__Gen){.out_name = out_name,.pref = pref,.table = table,.buf = __new_array(0, 1, sizeof(byte)),.sect_header_name_pos = 0,.offset = 0,.str_pos = __new_array(0, 1, sizeof(i64)),.strings = __new_array(0, 1, sizeof(string)),.file_size_pos = 0,.main_fn_addr = 0,.code_start_pos = 0,.fn_addr = new_map_1(sizeof(i64)),.var_offset = new_map_1(sizeof(int)),.stack_var_pos = 0,.debug_pos = 0,.errors = __new_array(0, 1, sizeof(v__errors__Error)),.warnings = __new_array(0, 1, sizeof(v__errors__Warning)),};
	if (!pref->is_verbose) {
		println(tos_lit("use `v -x64 -v ...` to print resulting asembly/machine code"));
	}
	v__gen__x64__Gen_generate_elf_header(&g);
	// FOR IN array
	array _t1678 = files;
	for (int _t1679 = 0; _t1679 < _t1678.len; ++_t1679) {
		v__ast__File file = ((v__ast__File*)_t1678.data)[_t1679];
		v__gen__x64__Gen_stmts(&g, file.stmts);
	}
	v__gen__x64__Gen_generate_elf_footer(&g);
}

void v__gen__x64__Gen_stmts(v__gen__x64__Gen* g, array_v__ast__Stmt stmts) {
	// FOR IN array
	array _t1680 = stmts;
	for (int _t1681 = 0; _t1681 < _t1680.len; ++_t1681) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)_t1680.data)[_t1681];
		v__gen__x64__Gen_stmt(g, stmt);
	}
}

i64 v__gen__x64__Gen_pos(v__gen__x64__Gen* g) {
	return g->buf.len;
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_write8(v__gen__x64__Gen* g, int n) {
	array_push(&g->buf, _MOV((byte[]){ ((byte)(n)) }));
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_write16(v__gen__x64__Gen* g, int n) {
	array_push(&g->buf, _MOV((byte[]){ ((byte)(n)) }));
	array_push(&g->buf, _MOV((byte[]){ ((byte)(n >> 8)) }));
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_write32(v__gen__x64__Gen* g, int n) {
	array_push(&g->buf, _MOV((byte[]){ ((byte)(n)) }));
	array_push(&g->buf, _MOV((byte[]){ ((byte)(n >> 8)) }));
	array_push(&g->buf, _MOV((byte[]){ ((byte)(n >> 16)) }));
	array_push(&g->buf, _MOV((byte[]){ ((byte)(n >> 24)) }));
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_write64(v__gen__x64__Gen* g, i64 n) {
	array_push(&g->buf, _MOV((byte[]){ ((byte)(n)) }));
	array_push(&g->buf, _MOV((byte[]){ ((byte)(n >> 8)) }));
	array_push(&g->buf, _MOV((byte[]){ ((byte)(n >> 16)) }));
	array_push(&g->buf, _MOV((byte[]){ ((byte)(n >> 24)) }));
	array_push(&g->buf, _MOV((byte[]){ ((byte)(n >> 32)) }));
	array_push(&g->buf, _MOV((byte[]){ ((byte)(n >> 40)) }));
	array_push(&g->buf, _MOV((byte[]){ ((byte)(n >> 48)) }));
	array_push(&g->buf, _MOV((byte[]){ ((byte)(n >> 56)) }));
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_write64_at(v__gen__x64__Gen* g, i64 n, i64 at) {
	(*(byte*)/*ee elem_typ */array_get(g->buf, at)) = ((byte)(n));
	(*(byte*)/*ee elem_typ */array_get(g->buf, at + 1)) = ((byte)(n >> 8));
	(*(byte*)/*ee elem_typ */array_get(g->buf, at + 2)) = ((byte)(n >> 16));
	(*(byte*)/*ee elem_typ */array_get(g->buf, at + 3)) = ((byte)(n >> 24));
	(*(byte*)/*ee elem_typ */array_get(g->buf, at + 4)) = ((byte)(n >> 32));
	(*(byte*)/*ee elem_typ */array_get(g->buf, at + 5)) = ((byte)(n >> 40));
	(*(byte*)/*ee elem_typ */array_get(g->buf, at + 6)) = ((byte)(n >> 48));
	(*(byte*)/*ee elem_typ */array_get(g->buf, at + 7)) = ((byte)(n >> 56));
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_write32_at(v__gen__x64__Gen* g, i64 at, int n) {
	(*(byte*)/*ee elem_typ */array_get(g->buf, at)) = ((byte)(n));
	(*(byte*)/*ee elem_typ */array_get(g->buf, at + 1)) = ((byte)(n >> 8));
	(*(byte*)/*ee elem_typ */array_get(g->buf, at + 2)) = ((byte)(n >> 16));
	(*(byte*)/*ee elem_typ */array_get(g->buf, at + 3)) = ((byte)(n >> 24));
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_write_string(v__gen__x64__Gen* g, string s) {
	for (int _t1697 = 0; _t1697 < s.len; ++_t1697) {
		byte c = s.str[_t1697];
		v__gen__x64__Gen_write8(g, ((int)(c)));
	}
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_inc(v__gen__x64__Gen* g, v__gen__x64__Register reg) {
	v__gen__x64__Gen_write16(g, 0xff49);
	v__gen__x64__Register _t1698 = reg;
	if (_t1698 == v__gen__x64__Register_r12) {
		v__gen__x64__Gen_write8(g, 0xc4);
	} else {
		v_panic(_STR("unhandled inc %.*s", 1, v__gen__x64__Register_str(reg)));
	};
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_cmp(v__gen__x64__Gen* g, v__gen__x64__Register reg, v__gen__x64__Size size, i64 val) {
	v__gen__x64__Gen_write8(g, 0x49);
	v__gen__x64__Size _t1699 = size;
	if (_t1699 == v__gen__x64__Size__8) {
		v__gen__x64__Gen_write8(g, 0x83);
	} else if (_t1699 == v__gen__x64__Size__32) {
		v__gen__x64__Gen_write8(g, 0x81);
	} else {
		v_panic(tos_lit("unhandled cmp"));
	};
	v__gen__x64__Register _t1700 = reg;
	if (_t1700 == v__gen__x64__Register_r12) {
		v__gen__x64__Gen_write8(g, 0xfc);
	} else {
		v_panic(tos_lit("unhandled cmp"));
	};
	v__gen__x64__Gen_write8(g, ((int)(val)));
}

VV_LOCAL_SYMBOL int v__gen__x64__Gen_get_var_offset(v__gen__x64__Gen* g, string var_name) {
	int offset = (*(int*)map_get(g->var_offset, var_name, &(int[]){ 0 }));
	if (offset == 0) {
		v_panic(_STR("0 offset for var `%.*s\000`", 2, var_name));
	}
	return offset;
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_cmp_var(v__gen__x64__Gen* g, string var_name, int val) {
	v__gen__x64__Gen_write8(g, 0x81);
	v__gen__x64__Gen_write8(g, 0x7d);
	int offset = v__gen__x64__Gen_get_var_offset(g, var_name);
	v__gen__x64__Gen_write8(g, 0xff - offset + 1);
	v__gen__x64__Gen_write32(g, val);
	v__gen__x64__Gen_println(g, _STR("cmp var `%.*s\000` %"PRId32"", 2, var_name, val));
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_inc_var(v__gen__x64__Gen* g, string var_name) {
	v__gen__x64__Gen_write16(g, 0x4581);
	int offset = v__gen__x64__Gen_get_var_offset(g, var_name);
	v__gen__x64__Gen_write8(g, 0xff - offset + 1);
	v__gen__x64__Gen_write32(g, 1);
	v__gen__x64__Gen_println(g, _STR("inc_var `%.*s\000`", 2, var_name));
}

VV_LOCAL_SYMBOL int v__gen__x64__Gen_jne(v__gen__x64__Gen* g) {
	v__gen__x64__Gen_write16(g, 0x850f);
	i64 pos = v__gen__x64__Gen_pos(g);
	v__gen__x64__Gen_write32(g, _const_v__gen__x64__placeholder);
	v__gen__x64__Gen_println(g, tos_lit("jne"));
	return ((int)(pos));
}

VV_LOCAL_SYMBOL int v__gen__x64__Gen_jge(v__gen__x64__Gen* g) {
	v__gen__x64__Gen_write16(g, 0x8d0f);
	i64 pos = v__gen__x64__Gen_pos(g);
	v__gen__x64__Gen_write32(g, _const_v__gen__x64__placeholder);
	v__gen__x64__Gen_println(g, tos_lit("jne"));
	return ((int)(pos));
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_jmp(v__gen__x64__Gen* g, int addr) {
	v__gen__x64__Gen_write8(g, 0xe9);
	v__gen__x64__Gen_write32(g, addr);
	v__gen__x64__Gen_println(g, tos_lit("jmp"));
}

VV_LOCAL_SYMBOL i64 v__gen__x64__abs(i64 a) {
	return (a < 0 ? (-a) : (a));
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_jle(v__gen__x64__Gen* g, i64 addr) {
	int offset = 0xff - ((int)(v__gen__x64__abs(addr - g->buf.len))) - 1;
	v__gen__x64__Gen_write8(g, 0x7e);
	v__gen__x64__Gen_write8(g, offset);
	v__gen__x64__Gen_println(g, tos_lit("jle"));
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_println(v__gen__x64__Gen* g, string comment) {
	if (!g->pref->is_verbose) {
		return;
	}
	string addr = int_hex(g->debug_pos);
	print(term__red(string_add(string_add(strings__repeat('0', 6 - addr.len), addr), tos_lit("  "))));
	for (int i = g->debug_pos; i < g->buf.len; i++) {
		string s = byte_hex((*(byte*)/*ee elem_typ */array_get(g->buf, i)));
		if (s.len == 1) {
			print(term__blue(tos_lit("0")));
		}
		print(string_add(term__blue(byte_hex((*(byte*)/*ee elem_typ */array_get(g->buf, i)))), tos_lit(" ")));
	}
	g->debug_pos = g->buf.len;
	print(string_add(tos_lit(" "), comment));
	println(tos_lit(""));
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_jl(v__gen__x64__Gen* g, i64 addr) {
	int offset = 0xff - ((int)(v__gen__x64__abs(addr - g->buf.len))) - 1;
	v__gen__x64__Gen_write8(g, 0x7c);
	v__gen__x64__Gen_write8(g, offset);
	v__gen__x64__Gen_println(g, tos_lit("jl"));
}

VV_LOCAL_SYMBOL int v__gen__x64__Gen_abs_to_rel_addr(v__gen__x64__Gen* g, i64 addr) {
	return ((int)(v__gen__x64__abs(addr - g->buf.len))) - 1;
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_mov64(v__gen__x64__Gen* g, v__gen__x64__Register reg, i64 val) {
	v__gen__x64__Register _t1701 = reg;
	if (_t1701 == v__gen__x64__Register_rsi) {
		v__gen__x64__Gen_write8(g, 0x48);
		v__gen__x64__Gen_write8(g, 0xbe);
	} else {
		println(_STR("unhandled mov %.*s", 1, v__gen__x64__Register_str(reg)));
	};
	v__gen__x64__Gen_write64(g, val);
	v__gen__x64__Gen_println(g, _STR("mov64 %.*s\000, %"PRId64"", 2, v__gen__x64__Register_str(reg), val));
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_mov_reg_to_rbp(v__gen__x64__Gen* g, int var_offset, v__gen__x64__Register reg) {
	v__gen__x64__Gen_write8(g, 0x89);
	v__gen__x64__Register _t1702 = reg;
	if (_t1702 == v__gen__x64__Register_eax || _t1702 == v__gen__x64__Register_rax) {
		v__gen__x64__Gen_write8(g, 0x45);
	} else if (_t1702 == v__gen__x64__Register_edi || _t1702 == v__gen__x64__Register_rdi) {
		v__gen__x64__Gen_write8(g, 0x7d);
	} else if (_t1702 == v__gen__x64__Register_rsi) {
		v__gen__x64__Gen_write8(g, 0x75);
	} else if (_t1702 == v__gen__x64__Register_rdx) {
		v__gen__x64__Gen_write8(g, 0x55);
	} else if (_t1702 == v__gen__x64__Register_rcx) {
		v__gen__x64__Gen_write8(g, 0x4d);
	} else {
		v__gen__x64__verror(_STR("mov_from_reg %.*s", 1, v__gen__x64__Register_str(reg)));
	};
	v__gen__x64__Gen_write8(g, 0xff - var_offset + 1);
	v__gen__x64__Gen_println(g, _STR("mov DWORD PTR[rbp-%.*s\000],%.*s", 2, int_hex2(var_offset), v__gen__x64__Register_str(reg)));
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_mov_var_to_reg(v__gen__x64__Gen* g, v__gen__x64__Register reg, int var_offset) {
	v__gen__x64__Gen_write8(g, 0x8b);
	v__gen__x64__Register _t1703 = reg;
	if (_t1703 == v__gen__x64__Register_eax || _t1703 == v__gen__x64__Register_rax) {
		v__gen__x64__Gen_write8(g, 0x45);
	} else if (_t1703 == v__gen__x64__Register_edi || _t1703 == v__gen__x64__Register_rdi) {
		v__gen__x64__Gen_write8(g, 0x7d);
	} else if (_t1703 == v__gen__x64__Register_rsi) {
		v__gen__x64__Gen_write8(g, 0x75);
	} else if (_t1703 == v__gen__x64__Register_rdx) {
		v__gen__x64__Gen_write8(g, 0x55);
	} else if (_t1703 == v__gen__x64__Register_rcx) {
		v__gen__x64__Gen_write8(g, 0x4d);
	} else {
		v__gen__x64__verror(_STR("mov_var_to_reg %.*s", 1, v__gen__x64__Register_str(reg)));
	};
	v__gen__x64__Gen_write8(g, 0xff - var_offset + 1);
	v__gen__x64__Gen_println(g, _STR("mov %.*s\000,DWORD PTR[rbp-%.*s\000]", 3, v__gen__x64__Register_str(reg), int_hex2(var_offset)));
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_call(v__gen__x64__Gen* g, int addr) {
	int rel = 0xffffffff - (g->buf.len + 5 - addr - 1);
	v__gen__x64__Gen_write8(g, 0xe8);
	v__gen__x64__Gen_write32(g, rel);
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_syscall(v__gen__x64__Gen* g) {
	v__gen__x64__Gen_write8(g, 0x0f);
	v__gen__x64__Gen_write8(g, 0x05);
	v__gen__x64__Gen_println(g, tos_lit("syscall"));
}

void v__gen__x64__Gen_ret(v__gen__x64__Gen* g) {
	v__gen__x64__Gen_write8(g, 0xc3);
	v__gen__x64__Gen_println(g, tos_lit("ret"));
}

void v__gen__x64__Gen_push(v__gen__x64__Gen* g, v__gen__x64__Register reg) {
	if (reg < v__gen__x64__Register_r8) {
		v__gen__x64__Gen_write8(g, 0x50 + reg);
	} else {
		v__gen__x64__Gen_write8(g, 0x41);
		v__gen__x64__Gen_write8(g, 0x50 + reg - 8);
	}
	v__gen__x64__Gen_println(g, _STR("push %.*s", 1, v__gen__x64__Register_str(reg)));
}

void v__gen__x64__Gen_pop(v__gen__x64__Gen* g, v__gen__x64__Register reg) {
	v__gen__x64__Gen_write8(g, 0x58 + reg);
	v__gen__x64__Gen_println(g, _STR("pop %.*s", 1, v__gen__x64__Register_str(reg)));
}

void v__gen__x64__Gen_sub32(v__gen__x64__Gen* g, v__gen__x64__Register reg, int val) {
	v__gen__x64__Gen_write8(g, 0x48);
	v__gen__x64__Gen_write8(g, 0x81);
	v__gen__x64__Gen_write8(g, 0xe8 + reg);
	v__gen__x64__Gen_write32(g, val);
	v__gen__x64__Gen_println(g, _STR("sub32 %.*s\000,%.*s", 2, v__gen__x64__Register_str(reg), int_hex2(val)));
}

void v__gen__x64__Gen_sub8(v__gen__x64__Gen* g, v__gen__x64__Register reg, int val) {
	v__gen__x64__Gen_write8(g, 0x48);
	v__gen__x64__Gen_write8(g, 0x83);
	v__gen__x64__Gen_write8(g, 0xe8 + reg);
	v__gen__x64__Gen_write8(g, val);
	v__gen__x64__Gen_println(g, _STR("sub8 %.*s\000,%.*s", 2, v__gen__x64__Register_str(reg), int_hex2(val)));
}

void v__gen__x64__Gen_add(v__gen__x64__Gen* g, v__gen__x64__Register reg, int val) {
	v__gen__x64__Gen_write8(g, 0x48);
	v__gen__x64__Gen_write8(g, 0x81);
	v__gen__x64__Gen_write8(g, 0xe8 + reg);
	v__gen__x64__Gen_write32(g, val);
	v__gen__x64__Gen_println(g, _STR("add %.*s\000,%.*s", 2, v__gen__x64__Register_str(reg), int_hex2(val)));
}

void v__gen__x64__Gen_add8(v__gen__x64__Gen* g, v__gen__x64__Register reg, int val) {
	v__gen__x64__Gen_write8(g, 0x48);
	v__gen__x64__Gen_write8(g, 0x83);
	v__gen__x64__Gen_write8(g, 0xc4);
	v__gen__x64__Gen_write8(g, val);
	v__gen__x64__Gen_println(g, _STR("add8 %.*s\000,%.*s", 2, v__gen__x64__Register_str(reg), int_hex2(val)));
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_add8_var(v__gen__x64__Gen* g, v__gen__x64__Register reg, int var_offset) {
	v__gen__x64__Gen_write8(g, 0x03);
	v__gen__x64__Register _t1704 = reg;
	if (_t1704 == v__gen__x64__Register_eax || _t1704 == v__gen__x64__Register_rax) {
		v__gen__x64__Gen_write8(g, 0x45);
	} else {
		v__gen__x64__verror(tos_lit("add8_var"));
	};
	v__gen__x64__Gen_write8(g, 0xff - var_offset + 1);
	v__gen__x64__Gen_println(g, _STR("add8 %.*s\000,DWORD PTR[rbp-%.*s\000]", 3, v__gen__x64__Register_str(reg), int_hex2(var_offset)));
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_sub8_var(v__gen__x64__Gen* g, v__gen__x64__Register reg, int var_offset) {
	v__gen__x64__Gen_write8(g, 0x2b);
	v__gen__x64__Register _t1705 = reg;
	if (_t1705 == v__gen__x64__Register_eax || _t1705 == v__gen__x64__Register_rax) {
		v__gen__x64__Gen_write8(g, 0x45);
	} else {
		v__gen__x64__verror(tos_lit("sub8_var"));
	};
	v__gen__x64__Gen_write8(g, 0xff - var_offset + 1);
	v__gen__x64__Gen_println(g, _STR("sub8 %.*s\000,DWORD PTR[rbp-%.*s\000]", 3, v__gen__x64__Register_str(reg), int_hex2(var_offset)));
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_mul8_var(v__gen__x64__Gen* g, v__gen__x64__Register reg, int var_offset) {
	v__gen__x64__Gen_write8(g, 0x0f);
	v__gen__x64__Gen_write8(g, 0xaf);
	v__gen__x64__Register _t1706 = reg;
	if (_t1706 == v__gen__x64__Register_eax || _t1706 == v__gen__x64__Register_rax) {
		v__gen__x64__Gen_write8(g, 0x45);
	} else {
		v__gen__x64__verror(tos_lit("mul8_var"));
	};
	v__gen__x64__Gen_write8(g, 0xff - var_offset + 1);
	v__gen__x64__Gen_println(g, _STR("mul8 %.*s\000,DWORD PTR[rbp-%.*s\000]", 3, v__gen__x64__Register_str(reg), int_hex2(var_offset)));
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_leave(v__gen__x64__Gen* g) {
	v__gen__x64__Gen_write8(g, 0xc9);
	v__gen__x64__Gen_println(g, tos_lit("leave"));
}

int v__gen__x64__Gen_gen_loop_start(v__gen__x64__Gen* g, int from) {
	v__gen__x64__Gen_mov(g, v__gen__x64__Register_r12, from);
	int label = g->buf.len;
	v__gen__x64__Gen_inc(g, v__gen__x64__Register_r12);
	return label;
}

void v__gen__x64__Gen_gen_loop_end(v__gen__x64__Gen* g, int to, int label) {
	v__gen__x64__Gen_cmp(g, v__gen__x64__Register_r12, v__gen__x64__Size__8, to);
	v__gen__x64__Gen_jl(g, label);
}

void v__gen__x64__Gen_save_main_fn_addr(v__gen__x64__Gen* g) {
	g->main_fn_addr = ((i64)(g->buf.len));
}

void v__gen__x64__Gen_gen_print_from_expr(v__gen__x64__Gen* g, v__ast__Expr expr, bool newline) {
	v__ast__Expr _t1707 = expr;
	if (_t1707.typ == 245 /* v.ast.StringLiteral */) {
		if (newline) {
			v__gen__x64__Gen_gen_print(g, string_add((*expr._245).val, tos_lit("\n")));
		} else {
			v__gen__x64__Gen_gen_print(g, (*expr._245).val);
		}
	} else {
	};
}

void v__gen__x64__Gen_gen_print(v__gen__x64__Gen* g, string s) {
	array_push(&g->strings, _MOV((string[]){ string_clone(s) }));
	v__gen__x64__Gen_mov(g, v__gen__x64__Register_eax, 1);
	v__gen__x64__Gen_mov(g, v__gen__x64__Register_edi, 1);
	int str_pos = g->buf.len + 2;
	array_push(&g->str_pos, _MOV((i64[]){ str_pos }));
	v__gen__x64__Gen_mov64(g, v__gen__x64__Register_rsi, 0);
	v__gen__x64__Gen_mov(g, v__gen__x64__Register_edx, s.len);
	v__gen__x64__Gen_syscall(g);
}

void v__gen__x64__Gen_gen_exit(v__gen__x64__Gen* g) {
	v__gen__x64__Gen_mov(g, v__gen__x64__Register_edi, 0);
	v__gen__x64__Gen_mov(g, v__gen__x64__Register_eax, 60);
	v__gen__x64__Gen_syscall(g);
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_mov(v__gen__x64__Gen* g, v__gen__x64__Register reg, int val) {
	v__gen__x64__Register _t1710 = reg;
	if (_t1710 == v__gen__x64__Register_eax || _t1710 == v__gen__x64__Register_rax) {
		v__gen__x64__Gen_write8(g, 0xb8);
	} else if (_t1710 == v__gen__x64__Register_edi || _t1710 == v__gen__x64__Register_rdi) {
		v__gen__x64__Gen_write8(g, 0xbf);
	} else if (_t1710 == v__gen__x64__Register_edx) {
		v__gen__x64__Gen_write8(g, 0xba);
	} else if (_t1710 == v__gen__x64__Register_rsi) {
		v__gen__x64__Gen_write8(g, 0x48);
		v__gen__x64__Gen_write8(g, 0xbe);
	} else if (_t1710 == v__gen__x64__Register_r12) {
		v__gen__x64__Gen_write8(g, 0x41);
		v__gen__x64__Gen_write8(g, 0xbc);
	} else {
		v_panic(_STR("unhandled mov %.*s", 1, v__gen__x64__Register_str(reg)));
	};
	v__gen__x64__Gen_write32(g, val);
	v__gen__x64__Gen_println(g, _STR("mov %.*s\000, %"PRId32"", 2, v__gen__x64__Register_str(reg), val));
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_mov_reg(v__gen__x64__Gen* g, v__gen__x64__Register a, v__gen__x64__Register b) {
	v__gen__x64__Register _t1711 = a;
	if (_t1711 == v__gen__x64__Register_rbp) {
		v__gen__x64__Gen_write8(g, 0x48);
		v__gen__x64__Gen_write8(g, 0x89);
	} else {
	};
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_mov_rbp_rsp(v__gen__x64__Gen* g) {
	v__gen__x64__Gen_write8(g, 0x48);
	v__gen__x64__Gen_write8(g, 0x89);
	v__gen__x64__Gen_write8(g, 0xe5);
	v__gen__x64__Gen_println(g, tos_lit("mov rbp,rsp"));
}

void v__gen__x64__Gen_register_function_address(v__gen__x64__Gen* g, string name) {
	i64 addr = v__gen__x64__Gen_pos(g);
	map_set(&g->fn_addr, name, &(i64[]) { addr });
}

void v__gen__x64__Gen_call_fn(v__gen__x64__Gen* g, v__ast__CallExpr node) {
	string name = node.name;
	i64 addr = (*(i64*)map_get(g->fn_addr, name, &(i64[]){ 0 }));
	if (addr == 0) {
		v__gen__x64__verror(_STR("fn addr of `%.*s\000` = 0", 2, name));
	}
	for (int i = 0; i < node.args.len; ++i) {
		v__ast__Expr expr = (*(v__ast__CallArg*)/*ee elem_typ */array_get(node.args, i)).expr;
		v__ast__Expr _t1712 = expr;
		if (_t1712.typ == 229 /* v.ast.IntegerLiteral */) {
			v__gen__x64__Gen_mov(g, (*(v__gen__x64__Register*)/*ee elem_typ */array_get(_const_v__gen__x64__fn_arg_registers, i)), string_int((*expr._229).val));
		} else if (_t1712.typ == 224 /* v.ast.Ident */) {
			int var_offset = v__gen__x64__Gen_get_var_offset(g, (*expr._224).name);
			if (g->pref->is_verbose) {
				println(_STR("i=%"PRId32"\000 fn name= %.*s\000 offset=%"PRId32"", 3, i, name, var_offset));
				println(int_str(((int)((*(v__gen__x64__Register*)/*ee elem_typ */array_get(_const_v__gen__x64__fn_arg_registers, i))))));
			}
			v__gen__x64__Gen_mov_var_to_reg(g, (*(v__gen__x64__Register*)/*ee elem_typ */array_get(_const_v__gen__x64__fn_arg_registers, i)), var_offset);
		} else {
			v__gen__x64__verror(string_add(_STR("unhandled call_fn (name=%.*s\000) node: ", 2, name), tos3( /* v.ast.Expr */ v_typeof_sumtype_250( (expr).typ ))));
		};
	}
	if (node.args.len > 6) {
		v__gen__x64__verror(tos_lit("more than 6 args not allowed for now"));
	}
	v__gen__x64__Gen_call(g, ((int)(addr)));
	v__gen__x64__Gen_println(g, _STR("fn call `%.*s\000()`", 2, name));
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_stmt(v__gen__x64__Gen* g, v__ast__Stmt node) {
	v__ast__Stmt _t1713 = node;
	if (_t1713.typ == 252 /* v.ast.AssignStmt */) {
		v__gen__x64__Gen_assign_stmt(g, (*node._252));
	} else if (_t1713.typ == 253 /* v.ast.Block */) {
		v__gen__x64__Gen_stmts(g, (*node._253).stmts);
	} else if (_t1713.typ == 256 /* v.ast.ConstDecl */) {
	} else if (_t1713.typ == 259 /* v.ast.ExprStmt */) {
		v__gen__x64__Gen_expr(g, (*node._259).expr);
	} else if (_t1713.typ == 151 /* v.ast.FnDecl */) {
		v__gen__x64__Gen_fn_decl(g, (*node._151));
	} else if (_t1713.typ == 262 /* v.ast.ForStmt */) {
		v__gen__x64__Gen_for_stmt(g, (*node._262));
	} else if (_t1713.typ == 267 /* v.ast.HashStmt */) {
		array_string words = string_split((*node._267).val, tos_lit(" "));
		// FOR IN array
		array _t1714 = words;
		for (int _t1715 = 0; _t1715 < _t1714.len; ++_t1715) {
			string word = ((string*)_t1714.data)[_t1715];
			if (word.len != 2) {
				v__gen__x64__verror(tos_lit("opcodes format: xx xx xx xx"));
			}
			int b = strtol(((charptr)(word.str)), 0, 16);
			v__gen__x64__Gen_write8(g, b);
		}
	} else if (_t1713.typ == 270 /* v.ast.Module */) {
	} else if (_t1713.typ == 271 /* v.ast.Return */) {
		v__gen__x64__Gen_gen_exit(g);
		v__gen__x64__Gen_ret(g);
	} else if (_t1713.typ == 273 /* v.ast.StructDecl */) {
	} else {
		println(string_add(tos_lit("x64.stmt(): bad node: "), tos3( /* v.ast.Stmt */ v_typeof_sumtype_274( (node).typ ))));
	};
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_expr(v__gen__x64__Gen* g, v__ast__Expr node) {
	v__ast__Expr _t1716 = node;
	if (_t1716.typ == 209 /* v.ast.ArrayInit */) {
	} else if (_t1716.typ == 213 /* v.ast.BoolLiteral */) {
	} else if (_t1716.typ == 215 /* v.ast.CallExpr */) {
		if ((string_eq((*node._215).name, tos_lit("println")) || string_eq((*node._215).name, tos_lit("print")) || string_eq((*node._215).name, tos_lit("eprintln")) || string_eq((*node._215).name, tos_lit("eprint")))) {
			v__ast__Expr expr = (*(v__ast__CallArg*)/*ee elem_typ */array_get((*node._215).args, 0)).expr;
			v__gen__x64__Gen_gen_print_from_expr(g, expr, (string_eq((*node._215).name, tos_lit("println")) || string_eq((*node._215).name, tos_lit("eprintln"))));
			return;
		}
		v__gen__x64__Gen_call_fn(g, (*node._215));
	} else if (_t1716.typ == 223 /* v.ast.FloatLiteral */) {
	} else if (_t1716.typ == 224 /* v.ast.Ident */) {
	} else if (_t1716.typ == 225 /* v.ast.IfExpr */) {
		v__gen__x64__Gen_if_expr(g, (*node._225));
	} else if (_t1716.typ == 228 /* v.ast.InfixExpr */) {
	} else if (_t1716.typ == 229 /* v.ast.IntegerLiteral */) {
	} else if (_t1716.typ == 237 /* v.ast.PostfixExpr */) {
		v__gen__x64__Gen_postfix_expr(g, (*node._237));
	} else if (_t1716.typ == 245 /* v.ast.StringLiteral */) {
	} else if (_t1716.typ == 246 /* v.ast.StructInit */) {
	} else {
		println(term__red(string_add(tos_lit("x64.expr(): unhandled node: "), tos3( /* v.ast.Expr */ v_typeof_sumtype_250( (node).typ )))));
	};
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_allocate_var(v__gen__x64__Gen* g, string name, int size, int initial_val) {
	int _t1717 = size;
	if (_t1717 == 1) {
		v__gen__x64__Gen_write8(g, 0xc6);
		v__gen__x64__Gen_write8(g, 0x45);
	} else if (_t1717 == 4) {
		v__gen__x64__Gen_write8(g, 0xc7);
		v__gen__x64__Gen_write8(g, 0x45);
	} else if (_t1717 == 8) {
		v__gen__x64__Gen_write8(g, 0x48);
		v__gen__x64__Gen_write8(g, 0xc7);
		v__gen__x64__Gen_write8(g, 0x45);
	} else {
		v__gen__x64__verror(_STR("allocate_var: bad size %"PRId32"", 1, size));
	};
	int n = g->stack_var_pos + size;
	v__gen__x64__Gen_write8(g, 0xff - n + 1);
	g->stack_var_pos += size;
	map_set(&g->var_offset, name, &(int[]) { g->stack_var_pos });
	v__gen__x64__Gen_write32(g, initial_val);
	v__gen__x64__Gen_println(g, _STR("mov DWORD [rbp-%.*s\000],%"PRId32"\000 (Allocate var `%.*s\000`)", 4, int_hex2(n), initial_val, name));
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_assign_stmt(v__gen__x64__Gen* g, v__ast__AssignStmt node) {
	// FOR IN array
	array _t1718 = node.left;
	for (int i = 0; i < _t1718.len; ++i) {
		v__ast__Expr left = ((v__ast__Expr*)_t1718.data)[i];
		v__ast__Expr right = (*(v__ast__Expr*)/*ee elem_typ */array_get(node.right, i));
		string name = v__ast__Expr_str(left);
		v__ast__Expr _t1719 = right;
		if (_t1719.typ == 229 /* v.ast.IntegerLiteral */) {
			v__gen__x64__Gen_allocate_var(g, name, 4, string_int((*right._229).val));
		} else if (_t1719.typ == 228 /* v.ast.InfixExpr */) {
			v__gen__x64__Gen_infix_expr(g, (*right._228));
			v__gen__x64__Gen_allocate_var(g, name, 4, 0);
			int offset = v__gen__x64__Gen_get_var_offset(g, name);
			println(_STR("infix assignment %.*s\000 offset=%.*s", 2, name, int_hex2(offset)));
			v__gen__x64__Gen_mov_reg_to_rbp(g, offset, v__gen__x64__Register_eax);
		} else if (_t1719.typ == 246 /* v.ast.StructInit */) {
			v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, (*right._246).typ);
			v__table__Struct info = /* as */ *(v__table__Struct*)__as_cast((sym->info)._155, (sym->info).typ, /*expected:*/155);
			// FOR IN array
			array _t1720 = info.fields;
			for (int _t1721 = 0; _t1721 < _t1720.len; ++_t1721) {
				v__table__Field field = ((v__table__Field*)_t1720.data)[_t1721];
				string field_name = string_add(string_add(name, tos_lit(".")), field.name);
				println(field_name);
				v__gen__x64__Gen_allocate_var(g, field_name, 4, 0);
			}
		} else {
			v__gen__x64__Gen_error_with_pos(g, string_add(tos_lit("x64 assign_stmt unhandled expr: "), tos3( /* v.ast.Expr */ v_typeof_sumtype_250( (right).typ ))), v__ast__Expr_position(right));
		};
	}
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_infix_expr(v__gen__x64__Gen* g, v__ast__InfixExpr node) {
	println(_STR("infix expr op=%.*s", 1, v__token__Kind_str(node.op)));
	if ((node.left).typ == 228 /* v.ast.InfixExpr */) {
		v__gen__x64__verror(tos_lit("only simple expressions are supported right now (not more than 2 operands)"));
	}
	v__ast__Expr _t1722 = node.left;
	if (_t1722.typ == 224 /* v.ast.Ident */) {
		v__gen__x64__Gen_mov_var_to_reg(g, v__gen__x64__Register_eax, v__gen__x64__Gen_get_var_offset(g, (*node.left._224).name));
	} else {
	};
	if ((node.right).typ == 224 /* v.ast.Ident */) {
		int var_offset = v__gen__x64__Gen_get_var_offset(g, (*node.right._224).name);
		v__token__Kind _t1723 = node.op;
		if (_t1723 == v__token__Kind_plus) {
			v__gen__x64__Gen_add8_var(g, v__gen__x64__Register_eax, var_offset);
		} else if (_t1723 == v__token__Kind_mul) {
			v__gen__x64__Gen_mul8_var(g, v__gen__x64__Register_eax, var_offset);
		} else if (_t1723 == v__token__Kind_minus) {
			v__gen__x64__Gen_sub8_var(g, v__gen__x64__Register_eax, var_offset);
		} else {
		};
	}
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_if_expr(v__gen__x64__Gen* g, v__ast__IfExpr node) {
	v__ast__IfBranch branch = (*(v__ast__IfBranch*)/*ee elem_typ */array_get(node.branches, 0));
	v__ast__InfixExpr infix_expr = /* as */ *(v__ast__InfixExpr*)__as_cast((branch.cond)._228, (branch.cond).typ, /*expected:*/228);
	int jne_addr = 0;
	v__ast__Expr _t1724 = infix_expr.left;
	if (_t1724.typ == 224 /* v.ast.Ident */) {
		v__ast__IntegerLiteral lit = /* as */ *(v__ast__IntegerLiteral*)__as_cast((infix_expr.right)._229, (infix_expr.right).typ, /*expected:*/229);
		v__gen__x64__Gen_cmp_var(g, (*infix_expr.left._224).name, string_int(lit.val));
		jne_addr = v__gen__x64__Gen_jne(g);
	} else {
		v__gen__x64__verror(tos_lit("unhandled infix.left"));
	};
	v__gen__x64__Gen_stmts(g, branch.stmts);
	v__gen__x64__Gen_write32_at(g, jne_addr, ((int)(v__gen__x64__Gen_pos(g) - jne_addr - 4)));
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_for_stmt(v__gen__x64__Gen* g, v__ast__ForStmt node) {
	v__ast__InfixExpr infix_expr = /* as */ *(v__ast__InfixExpr*)__as_cast((node.cond)._228, (node.cond).typ, /*expected:*/228);
	int jump_addr = 0;
	i64 start = v__gen__x64__Gen_pos(g);
	v__ast__Expr _t1725 = infix_expr.left;
	if (_t1725.typ == 224 /* v.ast.Ident */) {
		v__ast__IntegerLiteral lit = /* as */ *(v__ast__IntegerLiteral*)__as_cast((infix_expr.right)._229, (infix_expr.right).typ, /*expected:*/229);
		v__gen__x64__Gen_cmp_var(g, (*infix_expr.left._224).name, string_int(lit.val));
		jump_addr = v__gen__x64__Gen_jge(g);
	} else {
		v__gen__x64__verror(tos_lit("unhandled infix.left"));
	};
	v__gen__x64__Gen_stmts(g, node.stmts);
	v__gen__x64__Gen_jmp(g, ((int)(0xffffffff - (v__gen__x64__Gen_pos(g) + 5 - start) + 1)));
	v__gen__x64__Gen_write32_at(g, jump_addr, ((int)(v__gen__x64__Gen_pos(g) - jump_addr - 4)));
	v__gen__x64__Gen_println(g, tos_lit("jpm after for"));
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_fn_decl(v__gen__x64__Gen* g, v__ast__FnDecl node) {
	if (g->pref->is_verbose) {
		println(term__green(_STR("\n%.*s\000:", 2, node.name)));
	}
	g->stack_var_pos = 0;
	bool is_main = string_eq(node.name, tos_lit("main.main"));
	if (is_main) {
		v__gen__x64__Gen_save_main_fn_addr(g);
	} else {
		v__gen__x64__Gen_register_function_address(g, node.name);
	}
	v__gen__x64__Gen_push(g, v__gen__x64__Register_rbp);
	v__gen__x64__Gen_mov_rbp_rsp(g);
	v__gen__x64__Gen_sub8(g, v__gen__x64__Register_rsp, 0x10);
	if (node.params.len > 0) {
	}
	int offset = 0;
	for (int i = 0; i < node.params.len; ++i) {
		string name = (*(v__table__Param*)/*ee elem_typ */array_get(node.params, i)).name;
		v__gen__x64__Gen_allocate_var(g, name, 4, 0);
		offset += 4;
		v__gen__x64__Gen_mov_reg_to_rbp(g, offset, (*(v__gen__x64__Register*)/*ee elem_typ */array_get(_const_v__gen__x64__fn_arg_registers, i)));
	}
	v__gen__x64__Gen_stmts(g, node.stmts);
	if (is_main) {
		v__gen__x64__Gen_gen_exit(g);
	}
	if (!is_main) {
		v__gen__x64__Gen_add8(g, v__gen__x64__Register_rsp, 0x10);
		v__gen__x64__Gen_pop(g, v__gen__x64__Register_rbp);
	}
	v__gen__x64__Gen_ret(g);
}

VV_LOCAL_SYMBOL void v__gen__x64__Gen_postfix_expr(v__gen__x64__Gen* g, v__ast__PostfixExpr node) {
	if ((node.expr).typ != 224 /* v.ast.Ident */) {
		return;
	}
	v__ast__Ident ident = /* as */ *(v__ast__Ident*)__as_cast((node.expr)._224, (node.expr).typ, /*expected:*/224);
	string var_name = ident.name;
	if (node.op == v__token__Kind_inc) {
		v__gen__x64__Gen_inc_var(g, var_name);
	}
}

VV_LOCAL_SYMBOL void v__gen__x64__verror(string s) {
	v__util__verror(tos_lit("x64 gen error"), s);
}

void v__gen__x64__Gen_error_with_pos(v__gen__x64__Gen* g, string s, v__token__Position pos) {
	string kind = tos_lit("error:");
	if (g->pref->output_mode == v__pref__OutputMode_stdout) {
		string ferror = v__util__formatted_error(kind, s, g->pref->path, pos);
		eprintln(ferror);
		v_exit(1);
	} else {
		array_push(&g->errors, _MOV((v__errors__Error[]){ (v__errors__Error){.message = s,.details = (string){.str=(byteptr)""},.file_path = g->pref->path,.pos = pos,.backtrace = (string){.str=(byteptr)""},.reporter = v__errors__Reporter_gen,} }));
	}
}

v__builder__Builder v__builder__new_builder(v__pref__Preferences* pref) {
	string rdir = os__real_path(pref->path);
	string compiled_dir = (os__is_dir(rdir) ? (rdir) : (os__dir(rdir)));
	v__table__Table* table = v__table__new_table();
	table->is_fmt = false;
	if (pref->use_color == v__pref__ColorOutput_always) {
		v__util__EManager_set_support_color(_const_v__util__emanager, true);
	}
	if (pref->use_color == v__pref__ColorOutput_never) {
		v__util__EManager_set_support_color(_const_v__util__emanager, false);
	}
	Option_v__builder__MsvcResult _t1727 = v__builder__find_msvc();
	if (!_t1727.ok) {
		string err = _t1727.v_error;
		int errcode = _t1727.ecode;
		if (string_eq(pref->ccompiler, tos_lit("msvc"))) {
			v__builder__verror(tos_lit("Cannot find MSVC on this OS"));
		}
		*(v__builder__MsvcResult*) _t1727.data = (v__builder__MsvcResult){.full_cl_exe_path = (string){.str=(byteptr)""},.exe_path = (string){.str=(byteptr)""},.um_lib_path = (string){.str=(byteptr)""},.ucrt_lib_path = (string){.str=(byteptr)""},.vs_lib_path = (string){.str=(byteptr)""},.um_include_path = (string){.str=(byteptr)""},.ucrt_include_path = (string){.str=(byteptr)""},.vs_include_path = (string){.str=(byteptr)""},.shared_include_path = (string){.str=(byteptr)""},.valid = false,};
	}
 	v__builder__MsvcResult msvc = *(v__builder__MsvcResult*) _t1727.data;
	return (v__builder__Builder){
		.compiled_dir = compiled_dir,
		.module_path = (string){.str=(byteptr)""},
		.pref = pref,
		.checker = v__checker__new_checker(table, pref),
		.global_scope = (v__ast__Scope*)memdup(&(v__ast__Scope){.objects = new_map_1(sizeof(v__ast__ScopeObject)),.struct_fields = __new_array(0, 1, sizeof(v__ast__ScopeStructField)),.parent = 0,.children = __new_array(0, 1, sizeof(v__ast__Scope*)),.start_pos = 0,.end_pos = 0,}, sizeof(v__ast__Scope)),
		.out_name_c = (string){.str=(byteptr)""},
		.out_name_js = (string){.str=(byteptr)""},
		.max_nr_errors = (pref->error_limit > 0 ? (pref->error_limit) : (100)),
		.module_search_paths = __new_array(0, 1, sizeof(string)),
		.parsed_files = __new_array(0, 1, sizeof(v__ast__File)),
		.cached_msvc = msvc,
		.table = table,
	};
}

void v__builder__Builder_parse_imports(v__builder__Builder* b) {
	array_string done_imports = __new_array_with_default(0, 0, sizeof(string), 0);
	if (b->pref->is_vsh) {
		array_push(&done_imports, _MOV((string[]){ string_clone(tos_lit("os")) }));
	}
	// FOR IN array
	array _t1729 = b->parsed_files;
	for (int _t1730 = 0; _t1730 < _t1729.len; ++_t1730) {
		v__ast__File file = ((v__ast__File*)_t1729.data)[_t1730];
		if (string_ne(file.mod.name, tos_lit("main")) && !_IN(string, file.mod.name, done_imports)) {
			array_push(&done_imports, _MOV((string[]){ string_clone(file.mod.name) }));
		}
	}
	for (int i = 0; i < b->parsed_files.len; i++) {
		v__ast__File ast_file = (*(v__ast__File*)/*ee elem_typ */array_get(b->parsed_files, i));
		// FOR IN array
		array _t1732 = ast_file.imports;
		for (int _t1733 = 0; _t1733 < _t1732.len; ++_t1733) {
			v__ast__Import imp = ((v__ast__Import*)_t1732.data)[_t1733];
			string mod = imp.mod;
			if (string_eq(mod, tos_lit("builtin"))) {
				v__builder__verror(tos_lit("cannot import module \"builtin\""));
				break;
			}
			if (_IN(string, mod, done_imports)) {
				continue;
			}
			Option_string _t1734 = v__builder__Builder_find_module_path(b, mod, ast_file.path);
			if (!_t1734.ok) {
				string err = _t1734.v_error;
				int errcode = _t1734.ecode;
				v__builder__verror(_STR("cannot import module \"%.*s\000\" (not found)", 2, mod));
				break;
			}
 			string import_path = *(string*) _t1734.data;
			array_string v_files = v__builder__Builder_v_files_from_dir(/*rec*/*b, import_path);
			if (v_files.len == 0) {
				v__builder__verror(_STR("cannot import module \"%.*s\000\" (no .v files in \"%.*s\000\")", 3, mod, import_path));
			}
			array_v__ast__File parsed_files = v__parser__parse_files(v_files, b->table, b->pref, b->global_scope);
			// FOR IN array
			array _t1735 = parsed_files;
			for (int _t1736 = 0; _t1736 < _t1735.len; ++_t1736) {
				v__ast__File file = ((v__ast__File*)_t1735.data)[_t1736];
				if (string_ne(file.mod.name, mod)) {
					v__builder__verror(_STR("bad module definition: %.*s\000 imports module \"%.*s\000\" but %.*s\000 is defined as module `%.*s\000`", 5, ast_file.path, mod, file.path, file.mod.name));
				}
			}
			_PUSH_MANY(&b->parsed_files, (parsed_files), _t1737, array_v__ast__File);
			array_push(&done_imports, _MOV((string[]){ string_clone(mod) }));
		}
	}
	v__builder__Builder_resolve_deps(b);
	if (b->pref->print_v_files) {
		// FOR IN array
		array _t1739 = b->parsed_files;
		for (int _t1740 = 0; _t1740 < _t1739.len; ++_t1740) {
			v__ast__File p = ((v__ast__File*)_t1739.data)[_t1740];
			println(p.path);
		}
		v_exit(0);
	}
}

void v__builder__Builder_resolve_deps(v__builder__Builder* b) {
	v__depgraph__DepGraph* graph = v__builder__Builder_import_graph(b);
	v__depgraph__DepGraph* deps_resolved = v__depgraph__DepGraph_resolve(graph);
	string cycles = v__depgraph__DepGraph_display_cycles(deps_resolved);
	if (b->pref->is_verbose) {
		eprintln(tos_lit("------ resolved dependencies graph: ------"));
		eprintln(v__depgraph__DepGraph_display(deps_resolved));
		eprintln(tos_lit("------------------------------------------"));
	}
	if (cycles.len > 1) {
		v__builder__verror(string_add(tos_lit("error: import cycle detected between the following modules: \n"), cycles));
	}
	array_string mods = __new_array_with_default(0, 0, sizeof(string), 0);
	// FOR IN array
	array _t1741 = deps_resolved->nodes;
	for (int _t1742 = 0; _t1742 < _t1741.len; ++_t1742) {
		v__depgraph__DepGraphNode node = ((v__depgraph__DepGraphNode*)_t1741.data)[_t1742];
		array_push(&mods, _MOV((string[]){ string_clone(node.name) }));
	}
	if (b->pref->is_verbose) {
		eprintln(tos_lit("------ imported modules: ------"));
		eprintln(array_string_str(mods));
		eprintln(tos_lit("-------------------------------"));
	}
	array_v__ast__File reordered_parsed_files = __new_array_with_default(0, 0, sizeof(v__ast__File), 0);
	// FOR IN array
	array _t1744 = mods;
	for (int _t1745 = 0; _t1745 < _t1744.len; ++_t1745) {
		string m = ((string*)_t1744.data)[_t1745];
		// FOR IN array
		array _t1746 = b->parsed_files;
		for (int _t1747 = 0; _t1747 < _t1746.len; ++_t1747) {
			v__ast__File pf = ((v__ast__File*)_t1746.data)[_t1747];
			if (string_eq(m, pf.mod.name)) {
				array_push(&reordered_parsed_files, _MOV((v__ast__File[]){ pf }));
			}
		}
	}
	b->table->modules = mods;
	b->parsed_files = reordered_parsed_files;
}

v__depgraph__DepGraph* v__builder__Builder_import_graph(v__builder__Builder* b) {
	array_string builtins = _const_v__util__builtin_module_parts;
	v__depgraph__DepGraph* graph = v__depgraph__new_dep_graph();
	// FOR IN array
	array _t1749 = b->parsed_files;
	for (int _t1750 = 0; _t1750 < _t1749.len; ++_t1750) {
		v__ast__File p = ((v__ast__File*)_t1749.data)[_t1750];
		array_string deps = __new_array_with_default(0, 0, sizeof(string), 0);
		if (!_IN(string, p.mod.name, builtins)) {
			array_push(&deps, _MOV((string[]){ string_clone(tos_lit("builtin")) }));
			if (b->pref->backend == v__pref__Backend_c) {
				if (b->pref->is_vsh && string_ne(p.mod.name, tos_lit("os"))) {
					array_push(&deps, _MOV((string[]){ string_clone(tos_lit("os")) }));
				}
			}
		}
		// FOR IN array
		array _t1753 = p.imports;
		for (int _t1754 = 0; _t1754 < _t1753.len; ++_t1754) {
			v__ast__Import m = ((v__ast__Import*)_t1753.data)[_t1754];
			array_push(&deps, _MOV((string[]){ string_clone(m.mod) }));
		}
		v__depgraph__DepGraph_add(graph, p.mod.name, deps);
	}
	return graph;
}

array_string v__builder__Builder_v_files_from_dir(v__builder__Builder b, string dir) {
	if (!os__exists(dir)) {
		if (string_eq(dir, tos_lit("compiler")) && os__is_dir(tos_lit("vlib"))) {
			println(tos_lit("looks like you are trying to build V with an old command"));
			println(tos_lit("use `v -o v cmd/v` instead of `v -o v compiler`"));
		}
		v__builder__verror(_STR("%.*s\000 doesn't exist", 2, dir));
	} else if (!os__is_dir(dir)) {
		v__builder__verror(_STR("%.*s\000 isn't a directory!", 2, dir));
	}
	Option_array_string _t1756 = os__ls(dir);
	if (!_t1756.ok) {
		string err = _t1756.v_error;
		int errcode = _t1756.ecode;
		v_panic(err);
	}
 	array_string files = *(array_string*) _t1756.data;
	if (b.pref->is_verbose) {
		println(_STR("v_files_from_dir (\"%.*s\000\")", 2, dir));
	}
	return v__pref__Preferences_should_compile_filtered_files(b.pref, dir, files);
}

void v__builder__Builder_log(v__builder__Builder b, string s) {
	if (b.pref->is_verbose) {
		println(s);
	}
}

void v__builder__Builder_info(v__builder__Builder b, string s) {
	if (b.pref->is_verbose) {
		println(s);
	}
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL string v__builder__module_path(string mod) {
	return string_replace(mod, tos_lit("."), _const_os__path_separator);
}

Option_string v__builder__Builder_find_module_path(v__builder__Builder* b, string mod, string fpath) {
	v__vmod__ModFileCacher* mcache = v__vmod__get_cache();
	v__vmod__ModFileAndFolder vmod_file_location = v__vmod__ModFileCacher_get_by_file(mcache, fpath);
	string mod_path = v__builder__module_path(mod);
	array_string module_lookup_paths = __new_array_with_default(0, 0, sizeof(string), 0);
	if (vmod_file_location.vmod_file.len != 0 && !_IN(string, vmod_file_location.vmod_folder, b->module_search_paths)) {
		array_push(&module_lookup_paths, _MOV((string[]){ string_clone(vmod_file_location.vmod_folder) }));
	}
	_PUSH_MANY(&module_lookup_paths, (b->module_search_paths), _t1758, array_string);
	// FOR IN array
	array _t1759 = module_lookup_paths;
	for (int _t1760 = 0; _t1760 < _t1759.len; ++_t1760) {
		string search_path = ((string*)_t1759.data)[_t1760];
		string try_path = os__join_path(search_path, (varg_string){.len=1,.args={mod_path}});
		if (b->pref->is_verbose) {
			println(_STR("  >> trying to find %.*s\000 in %.*s\000 ..", 3, mod, try_path));
		}
		if (os__is_dir(try_path)) {
			if (b->pref->is_verbose) {
				println(_STR("  << found %.*s\000 .", 2, try_path));
			}
			Option_string _t1761;
			opt_ok2(&(string[]) { try_path }, (OptionBase*)(&_t1761), sizeof(string));
			return _t1761;
		}
	}
	string smodule_lookup_paths = array_string_join(module_lookup_paths, tos_lit(", "));
	Option _t1762 = v_error(_STR("module \"%.*s\000\" not found in:\n%.*s", 2, mod, smodule_lookup_paths));
	return *(Option_string*)&_t1762;
}

VV_LOCAL_SYMBOL void v__builder__Builder_show_total_warns_and_errors_stats(v__builder__Builder* b) {
	if (b->pref->is_stats) {
		println(_STR("checker summary: %.*s\000 V errors, %.*s\000 V warnings", 3, v__util__bold(int_str(b->checker.nr_errors)), v__util__bold(int_str(b->checker.nr_warnings))));
	}
}

VV_LOCAL_SYMBOL void v__builder__Builder_print_warnings_and_errors(v__builder__Builder* b) {
	if (b->pref->output_mode == v__pref__OutputMode_silent) {
		if (b->checker.nr_errors > 0) {
			v_exit(1);
		}
		// Defer begin
		v__builder__Builder_show_total_warns_and_errors_stats(b);
		// Defer end
		return;
	}
	if (b->pref->is_verbose && b->checker.nr_warnings > 1) {
		println(_STR("%"PRId32"\000 warnings", 2, b->checker.nr_warnings));
	}
	if (b->checker.nr_warnings > 0 && !b->pref->skip_warnings) {
		// FOR IN array
		array _t1763 = b->checker.warnings;
		for (int i = 0; i < _t1763.len; ++i) {
			v__errors__Warning err = ((v__errors__Warning*)_t1763.data)[i];
			string kind = (b->pref->is_verbose ? (_STR("%.*s\000 warning #%"PRId32"\000:", 3, v__errors__Reporter_str(err.reporter), b->checker.nr_warnings)) : (tos_lit("warning:")));
			string ferror = v__util__formatted_error(kind, err.message, err.file_path, err.pos);
			eprintln(ferror);
			if (err.details.len > 0) {
				eprintln(_STR("details: %.*s", 1, err.details));
			}
			if (i > b->max_nr_errors) {
				// Defer begin
				v__builder__Builder_show_total_warns_and_errors_stats(b);
				// Defer end
				return;
			}
		}
	}
	if (b->pref->is_verbose && b->checker.nr_errors > 1) {
		println(_STR("%"PRId32"\000 errors", 2, b->checker.nr_errors));
	}
	if (b->checker.nr_errors > 0) {
		// FOR IN array
		array _t1764 = b->checker.errors;
		for (int i = 0; i < _t1764.len; ++i) {
			v__errors__Error err = ((v__errors__Error*)_t1764.data)[i];
			string kind = (b->pref->is_verbose ? (_STR("%.*s\000 error #%"PRId32"\000:", 3, v__errors__Reporter_str(err.reporter), b->checker.nr_errors)) : (tos_lit("error:")));
			string ferror = v__util__formatted_error(kind, err.message, err.file_path, err.pos);
			eprintln(ferror);
			if (err.details.len > 0) {
				eprintln(_STR("details: %.*s", 1, err.details));
			}
			if (i > b->max_nr_errors) {
				// Defer begin
				v__builder__Builder_show_total_warns_and_errors_stats(b);
				// Defer end
				return;
			}
		}
		v__builder__Builder_show_total_warns_and_errors_stats(b);
		v_exit(1);
	}
	if (b->table->redefined_fns.len > 0) {
		int total_conflicts = 0;
		// FOR IN array
		array _t1765 = b->table->redefined_fns;
		for (int _t1766 = 0; _t1766 < _t1765.len; ++_t1766) {
			string fn_name = ((string*)_t1765.data)[_t1766];
			array_v__builder__FunctionRedefinition redefines = __new_array_with_default(0, 0, sizeof(v__builder__FunctionRedefinition), 0);
			map_string_int redefine_conflicts = new_map_1(sizeof(int));
			// FOR IN array
			array _t1767 = b->parsed_files;
			for (int _t1768 = 0; _t1768 < _t1767.len; ++_t1768) {
				v__ast__File file = ((v__ast__File*)_t1767.data)[_t1768];
				// FOR IN array
				array _t1769 = file.stmts;
				for (int _t1770 = 0; _t1770 < _t1769.len; ++_t1770) {
					v__ast__Stmt stmt = ((v__ast__Stmt*)_t1769.data)[_t1770];
					if ((stmt).typ == 151 /* v.ast.FnDecl */) {
						if (string_eq((*stmt._151).name, fn_name)) {
							string fheader = v__ast__FnDecl_stringify(&(*stmt._151), b->table, tos_lit("main"));
							array_push(&redefines, _MOV((v__builder__FunctionRedefinition[]){ (v__builder__FunctionRedefinition){.fpath = file.path,.fline = (*stmt._151).pos.line_nr,.fheader = fheader,.f = (*stmt._151),} }));
							(*(int*)map_get_and_set(&redefine_conflicts, fheader, &(int[]){ 0 }))++;
						}
					}
				}
			}
			if (redefine_conflicts.len > 1) {
				eprintln(_STR("redefinition of function `%.*s\000`", 2, fn_name));
				// FOR IN array
				array _t1772 = redefines;
				for (int _t1773 = 0; _t1773 < _t1772.len; ++_t1773) {
					v__builder__FunctionRedefinition redefine = ((v__builder__FunctionRedefinition*)_t1772.data)[_t1773];
					eprintln(v__util__formatted_error(tos_lit("conflicting declaration:"), redefine.fheader, redefine.fpath, redefine.f.pos));
				}
				total_conflicts++;
			}
		}
		if (total_conflicts > 0) {
			v__builder__Builder_show_total_warns_and_errors_stats(b);
			v_exit(1);
		}
	}
// Defer begin
v__builder__Builder_show_total_warns_and_errors_stats(b);
// Defer end
}

VV_LOCAL_SYMBOL void v__builder__verror(string s) {
	v__util__verror(tos_lit("builder error"), s);
}

void v__builder__Builder_timing_message(v__builder__Builder* b, string msg, i64 ms) {
	string value = v__util__bold(_STR("%"PRId64"", 1, ms));
	string formatted_message = _STR("%.*s\000: %.*s\000 ms", 3, msg, value);
	if (b->pref->show_timings) {
		println(formatted_message);
	} else {
		v__builder__Builder_info(/*rec*/*b, formatted_message);
	}
}

string v__builder__Builder_gen_c(v__builder__Builder* b, array_string v_files) {
	i64 t0 = time__ticks();
	b->parsed_files = v__parser__parse_files(v_files, b->table, b->pref, b->global_scope);
	v__builder__Builder_parse_imports(b);
	i64 t1 = time__ticks();
	i64 parse_time = t1 - t0;
	v__builder__Builder_timing_message(b, tos_lit("PARSE"), parse_time);
	if (b->pref->only_check_syntax) {
		return tos_lit("");
	}
	v__builder__Builder_generic_struct_insts_to_concrete(b);
	v__checker__Checker_check_files(&b->checker, b->parsed_files);
	i64 t2 = time__ticks();
	i64 check_time = t2 - t1;
	v__builder__Builder_timing_message(b, tos_lit("CHECK"), check_time);
	v__builder__Builder_print_warnings_and_errors(b);
	string res = v__gen__cgen(b->parsed_files, b->table, b->pref);
	i64 t3 = time__ticks();
	i64 gen_time = t3 - t2;
	v__builder__Builder_timing_message(b, tos_lit("C GEN"), gen_time);
	return res;
}

void v__builder__Builder_build_c(v__builder__Builder* b, array_string v_files, string out_file) {
	b->out_name_c = out_file;
	b->pref->out_name_c = os__real_path(out_file);
	v__builder__Builder_info(/*rec*/*b, _STR("build_c(%.*s\000)", 2, out_file));
	string output2 = v__builder__Builder_gen_c(b, v_files);
	Option_os__File _t1774 = os__create(out_file);
	if (!_t1774.ok) {
		string err = _t1774.v_error;
		int errcode = _t1774.ecode;
		v_panic(err);
	}
 	os__File f = *(os__File*) _t1774.data;
	os__File_writeln(&f, output2);
	os__File_close(&f);
}

void v__builder__Builder_compile_c(v__builder__Builder* b) {
	if (string_ne(os__user_os(), tos_lit("windows")) && string_eq(b->pref->ccompiler, tos_lit("msvc"))) {
		v__builder__verror(_STR("Cannot build with msvc on %.*s", 1, os__user_os()));
	}
	if (b->pref->is_verbose) {
		println(tos_lit("all .v files before:"));
	}
	#if defined(_WIN32)
	{
		Option_void _t1775 = v__builder__Builder_find_win_cc(b);
		if (!_t1775.ok && !_t1775.is_none) {
			string err = _t1775.v_error;
			int errcode = _t1775.ecode;
			v__builder__verror(_const_v__builder__no_compiler_error);
		};
	}
	#endif
	array_string files = v__builder__Builder_get_builtin_files(/*rec*/*b);
	_PUSH_MANY(&files, (v__builder__Builder_get_user_files(b)), _t1776, array_string);
	v__builder__Builder_set_module_lookup_paths(b);
	if (b->pref->is_verbose) {
		println(tos_lit("all .v files:"));
		println(array_string_str(files));
	}
	string out_name_c = v__builder__Builder_get_vtmp_filename(b, b->pref->out_name, tos_lit(".tmp.c"));
	if (b->pref->is_shared) {
		out_name_c = v__builder__Builder_get_vtmp_filename(b, b->pref->out_name, tos_lit(".tmp.so.c"));
	}
	v__builder__Builder_build_c(b, files, out_name_c);
	if (b->pref->os == v__pref__OS_ios) {
		string bundle_name = *(string*)array_last(string_split(b->pref->out_name, tos_lit("/")));
		string bundle_id = ((b->pref->bundle_id).len != 0 ? (b->pref->bundle_id) : (_STR("app.vlang.%.*s", 1, bundle_name)));
		string display_name = ((b->pref->display_name).len != 0 ? (b->pref->display_name) : (bundle_name));
		os__mkdir(_STR("%.*s\000.app", 2, display_name));
		os__write_file(_STR("%.*s\000.app/Info.plist", 2, display_name), v__builder__make_ios_plist(display_name, bundle_id, bundle_name, 1));
	}
	v__builder__Builder_cc(b);
}

VV_LOCAL_SYMBOL void v__builder__todo() {
}

VV_LOCAL_SYMBOL Option_void v__builder__Builder_find_win_cc(v__builder__Builder* v) {
	#if !defined(_WIN32)
	{
	}
	#endif
	Option_os__Result _t1777 = os__exec(_STR("%.*s\000 -v", 2, v->pref->ccompiler));
	if (!_t1777.ok) {
		string err = _t1777.v_error;
		int errcode = _t1777.ecode;
		if (v->pref->is_verbose) {
			println(_STR("%.*s\000 not found, looking for msvc...", 2, v->pref->ccompiler));
		}
		Option_v__builder__MsvcResult _t1778 = v__builder__find_msvc();
		if (!_t1778.ok) {
			string err = _t1778.v_error;
			int errcode = _t1778.ecode;
			if (v->pref->is_verbose) {
				println(tos_lit("msvc not found, looking for thirdparty/tcc..."));
			}
			string vpath = os__dir(os__getenv(tos_lit("VEXE")));
			string thirdparty_tcc = os__join_path(vpath, (varg_string){.len=3,.args={tos_lit("thirdparty"), tos_lit("tcc"), tos_lit("tcc.exe")}});
			Option_os__Result _t1779 = os__exec(_STR("%.*s\000 -v", 2, thirdparty_tcc));
			if (!_t1779.ok) {
				string err = _t1779.v_error;
				int errcode = _t1779.ecode;
				if (v->pref->is_verbose) {
					println(tos_lit("tcc not found"));
				}
				Option _t1780 = opt_none();
				return *(Option_void*)&_t1780;
			};
			v->pref->ccompiler = thirdparty_tcc;
			v->pref->ccompiler_type = v__pref__CompilerType_tinyc;
			Option_void _t1781 = {.ok = true};
			return _t1781;
		};
		v->pref->ccompiler = tos_lit("msvc");
		v->pref->ccompiler_type = v__pref__CompilerType_msvc;
		Option_void _t1782 = {.ok = true};
		return _t1782;
	};
	v->pref->ccompiler_type = v__pref__cc_from_string(v->pref->ccompiler);
	Option_void _t1783 = {.ok = true};
	return _t1783;
}

VV_LOCAL_SYMBOL void v__builder__Builder_show_c_compiler_output(v__builder__Builder* v, os__Result res) {
	println(tos_lit("======== C Compiler output ========"));
	println(res.output);
	println(tos_lit("================================="));
}

VV_LOCAL_SYMBOL void v__builder__Builder_post_process_c_compiler_output(v__builder__Builder* v, os__Result res) {
	if (res.exit_code == 0) {
		if (v->pref->reuse_tmpc) {
			return;
		}
		// FOR IN array
		array _t1784 = v->pref->cleanup_files;
		for (int _t1785 = 0; _t1785 < _t1784.len; ++_t1785) {
			string tmpfile = ((string*)_t1784.data)[_t1785];
			if (os__is_file(tmpfile)) {
				if (v->pref->is_verbose) {
					eprintln(_STR(">> remove tmp file: %.*s", 1, tmpfile));
				}
				os__rm(tmpfile);
			}
		}
		return;
	}
	// FOR IN array
	array _t1786 = new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_const_v__builder__c_verror_message_marker, tos_lit("error: include file ")}));
	for (int _t1787 = 0; _t1787 < _t1786.len; ++_t1787) {
		string emsg_marker = ((string*)_t1786.data)[_t1787];
		if (string_contains(res.output, emsg_marker)) {
			string emessage = string_trim_right(string_all_before(string_all_before(string_all_after(res.output, emsg_marker), tos_lit("\n")), tos_lit("\r")), tos_lit("\r\n"));
			v__builder__verror(emessage);
		}
	}
	if (v->pref->is_debug) {
		string eword = tos_lit("error:");
		string khighlight = (term__can_show_color_on_stdout() ? (term__red(eword)) : (eword));
		println(string_replace(string_trim_right(res.output, tos_lit("\r\n")), eword, khighlight));
	} else {
		if (res.output.len < 30) {
			println(res.output);
		} else {
			array_string elines = v__builder__error_context_lines(res.output, tos_lit("error:"), 1, 12);
			println(tos_lit("=================="));
			// FOR IN array
			array _t1788 = elines;
			for (int _t1789 = 0; _t1789 < _t1788.len; ++_t1789) {
				string eline = ((string*)_t1788.data)[_t1789];
				println(eline);
			}
			println(tos_lit("..."));
			println(tos_lit("=================="));
			println(tos_lit("(Use `v -cg` to print the entire error message)\n"));
		}
	}
	v__builder__verror(_const_v__builder__c_error_info);
}

VV_LOCAL_SYMBOL string v__builder__Builder_rebuild_cached_module(v__builder__Builder* v, string vexe, string imp_path) {
	Option_string _t1790 = v__vcache__CacheManager_exists(&v->pref->cache_manager, tos_lit(".o"), imp_path);
	if (!_t1790.ok) {
		string err = _t1790.v_error;
		int errcode = _t1790.ecode;
		println(_STR("Cached %.*s\000 .o file not found... Building .o file for %.*s", 2, imp_path, imp_path));
		string pwd = os__getwd();
		string vroot = os__dir(vexe);
		os__chdir(vroot);
		string boptions = array_string_join(v->pref->build_options, tos_lit(" "));
		string rebuild_cmd = _STR("%.*s\000 %.*s\000 build-module %.*s", 3, vexe, boptions, imp_path);
		os__system(rebuild_cmd);
		Option_string _t1791 = v__vcache__CacheManager_exists(&v->pref->cache_manager, tos_lit(".o"), imp_path);
		if (!_t1791.ok) {
			string err = _t1791.v_error;
			int errcode = _t1791.ecode;
			v_panic(_STR("could not rebuild cache module for %.*s\000, error: %.*s", 2, imp_path, err));
		}
 		string rebuilded_o = *(string*) _t1791.data;
		os__chdir(pwd);
		return rebuilded_o;
	}
 	string res = *(string*) _t1790.data;
	return res;
}

VV_LOCAL_SYMBOL void v__builder__Builder_show_cc(v__builder__Builder* v, string cmd, string response_file, string response_file_content) {
	if (v->pref->is_verbose || v->pref->show_cc) {
		println(tos_lit(""));
		println(tos_lit("====================="));
		println(_STR("> C compiler cmd: %.*s", 1, cmd));
		if (v->pref->show_cc) {
			println(_STR("> C compiler response file %.*s\000:", 2, response_file));
			println(response_file_content);
		}
		println(tos_lit("====================="));
	}
}

VV_LOCAL_SYMBOL void v__builder__Builder_cc(v__builder__Builder* v) {
	if (string_contains(os__executable(), tos_lit("vfmt"))) {
		return;
	}
	if (v->pref->is_verbose) {
		println(_STR("builder.cc() pref.out_name=\"%.*s\000\"", 2, v->pref->out_name));
	}
	if (v->pref->only_check_syntax) {
		if (v->pref->is_verbose) {
			println(tos_lit("builder.cc returning early, since pref.only_check_syntax is true"));
		}
		return;
	}
	v__builder__Builder_build_thirdparty_obj_files(v);
	string vexe = v__pref__vexe_path();
	string vdir = os__dir(vexe);
	bool ends_with_c = string_ends_with(v->pref->out_name, tos_lit(".c"));
	bool ends_with_js = string_ends_with(v->pref->out_name, tos_lit(".js"));
	if (ends_with_c || ends_with_js) {
		v->pref->skip_running = true;
		#if !defined(_VJS)
		{
			if (ends_with_js) {
				string vjs_path = string_add(vexe, tos_lit("js"));
				if (!os__exists(vjs_path)) {
					println(tos_lit("V.js compiler not found, building..."));
					int ret = os__system(_STR("%.*s\000 -o %.*s\000 -os js %.*s\000/cmd/v", 4, vexe, vjs_path, vdir));
					if (ret == 0) {
						println(tos_lit("Done."));
					} else {
						println(tos_lit("Failed."));
						v_exit(1);
					}
				}
				int ret = os__system(_STR("%.*s\000 -o %.*s\000 %.*s", 3, vjs_path, v->pref->out_name, v->pref->path));
				if (ret == 0) {
					println(_STR("Done. Run it with `node %.*s\000`", 2, v->pref->out_name));
					println(tos_lit("JS backend is at a very early stage."));
				}
			}
		}
		#endif
		Option_void _t1792 = os__mv_by_cp(v->out_name_c, v->pref->out_name);
		if (!_t1792.ok && !_t1792.is_none) {
			string err = _t1792.v_error;
			int errcode = _t1792.ecode;
			v_panic(err);
		};
		return;
	}
	if (v->pref->os == v__pref__OS_windows) {
		#if !defined(_WIN32)
		{
		}
		#endif
	}
	string ccompiler = v->pref->ccompiler;
	#if defined(_WIN32)
	{
		if (string_eq(ccompiler, tos_lit("msvc"))) {
			v__builder__Builder_cc_msvc(v);
			return;
		}
	}
	#endif
	if (v->pref->os == v__pref__OS_ios) {
		string ios_sdk = (v->pref->is_ios_simulator ? (tos_lit("iphonesimulator")) : (tos_lit("iphoneos")));
		Option_os__Result _t1793 = os__exec(_STR("xcrun --sdk %.*s\000 --show-sdk-path", 2, ios_sdk));
		if (!_t1793.ok) {
			string err = _t1793.v_error;
			int errcode = _t1793.ecode;
			v_panic(tos_lit("Couldn\'t find iphonesimulator"));
		}
 		os__Result ios_sdk_path_res = *(os__Result*) _t1793.data;
		string isysroot = string_replace(ios_sdk_path_res.output, tos_lit("\n"), tos_lit(""));
		ccompiler = _STR("xcrun --sdk iphoneos clang -isysroot %.*s", 1, isysroot);
	}
	array_string args = new_array_from_c_array(10, 10, sizeof(string), _MOV((string[10]){
			v->pref->cflags, tos_lit("-std=gnu99"), tos_lit("-Wall"), tos_lit("-Wextra"), tos_lit("-Wno-unused-variable"), tos_lit("-Wno-unused-parameter"), tos_lit("-Wno-unused-result"), tos_lit("-Wno-unused-function"), tos_lit("-Wno-missing-braces"), tos_lit("-Wno-unused-label")}));
	if (v->pref->os == v__pref__OS_ios) {
		array_push(&args, _MOV((string[]){ string_clone(tos_lit("-framework Foundation")) }));
		array_push(&args, _MOV((string[]){ string_clone(tos_lit("-framework UIKit")) }));
		array_push(&args, _MOV((string[]){ string_clone(tos_lit("-framework Metal")) }));
		array_push(&args, _MOV((string[]){ string_clone(tos_lit("-framework MetalKit")) }));
		array_push(&args, _MOV((string[]){ string_clone(tos_lit("-DSOKOL_METAL")) }));
		array_push(&args, _MOV((string[]){ string_clone(tos_lit("-fobjc-arc")) }));
	}
	array_string linker_flags = __new_array_with_default(0, 0, sizeof(string), 0);
	if (v->pref->fast) {
		#if defined(__linux__)
		{
		}
		#else
		{
			v__builder__verror(tos_lit("-fast is only supported on Linux right now"));
		}
		#endif
	}
	if (!v->pref->is_shared && v->pref->build_mode != v__pref__BuildMode_build_module && string_eq(os__user_os(), tos_lit("windows")) && !string_ends_with(v->pref->out_name, tos_lit(".exe"))) {
		v->pref->out_name = /*f*/string_add(v->pref->out_name, tos_lit(".exe"));
	}
	v__builder__Builder_log(/*rec*/*v, _STR("cc() isprod=%.*s\000 outname=%.*s", 2, v->pref->is_prod ? _SLIT("true") : _SLIT("false"), v->pref->out_name));
	if (v->pref->is_shared) {
		array_push(&linker_flags, _MOV((string[]){ string_clone(tos_lit("-shared")) }));
		array_push(&args, _MOV((string[]){ string_clone(tos_lit("-fPIC")) }));
		#if defined(__APPLE__)
		{
		}
		#elif defined(_WIN32)
		{
			v->pref->out_name = /*f*/string_add(v->pref->out_name, tos_lit(".dll"));
		}
		#else
		{
		}
		#endif
	}
	if (v->pref->is_bare) {
		array_push(&args, _MOV((string[]){ string_clone(tos_lit("-fno-stack-protector")) }));
		array_push(&args, _MOV((string[]){ string_clone(tos_lit("-ffreestanding")) }));
		array_push(&linker_flags, _MOV((string[]){ string_clone(tos_lit("-static")) }));
		array_push(&linker_flags, _MOV((string[]){ string_clone(tos_lit("-nostdlib")) }));
	}
	if (v->pref->build_mode == v__pref__BuildMode_build_module) {
		v->pref->out_name = v__vcache__CacheManager_postfix_with_key2cpath(&v->pref->cache_manager, tos_lit(".o"), v->pref->path);
		println(_STR("Building %.*s\000 to %.*s\000 ...", 3, v->pref->path, v->pref->out_name));
		v__vcache__CacheManager_save(&v->pref->cache_manager, tos_lit(".description.txt"), v->pref->path, _STR("%*.*s\000 @ %.*s\000\n", 3, v->pref->path, -30, v->pref->cache_manager.vopts));
	}
	bool debug_mode = v->pref->is_debug;
	string debug_options = tos_lit("-g3");
	string optimization_options = tos_lit("-O2");
	string guessed_compiler = v->pref->ccompiler;
	if (string_eq(guessed_compiler, tos_lit("cc")) && v->pref->is_prod) {
		{ /* if guard */ 
		Option_os__Result _t1806;
		if (_t1806 = os__exec(tos_lit("cc --version")), _t1806.ok) {
			os__Result ccversion = *(os__Result*)_t1806.data;
			if (ccversion.exit_code == 0) {
				if (string_contains(ccversion.output, tos_lit("This is free software;")) && string_contains(ccversion.output, tos_lit("Free Software Foundation, Inc."))) {
					guessed_compiler = tos_lit("gcc");
				}
				if (string_contains(ccversion.output, tos_lit("clang version "))) {
					guessed_compiler = tos_lit("clang");
				}
			}
		}}
	}
	bool is_cc_tcc = string_contains(ccompiler, tos_lit("tcc")) || string_eq(guessed_compiler, tos_lit("tcc"));
	bool is_cc_clang = !is_cc_tcc && (string_contains(ccompiler, tos_lit("clang")) || string_eq(guessed_compiler, tos_lit("clang")));
	bool is_cc_gcc = !is_cc_tcc && !is_cc_clang && (string_contains(ccompiler, tos_lit("gcc")) || string_eq(guessed_compiler, tos_lit("gcc")));
	if (is_cc_clang) {
		if (debug_mode) {
			debug_options = tos_lit("-g3 -O0 -no-pie");
		}
		optimization_options = tos_lit("-O3");
		bool have_flto = true;
		#if defined(__OpenBSD__)
		{
		}
		#endif
		if (have_flto) {
			optimization_options = /*f*/string_add(optimization_options, tos_lit(" -flto"));
		}
	}
	if (is_cc_gcc) {
		if (debug_mode) {
			debug_options = tos_lit("-g3 -no-pie");
		}
		optimization_options = tos_lit("-O3 -fno-strict-aliasing -flto");
	}
	if (debug_mode) {
		array_push(&args, _MOV((string[]){ string_clone(debug_options) }));
		#if defined(__APPLE__)
		{
		}
		#endif
	}
	if (v->pref->is_prod) {
		array_push(&args, _MOV((string[]){ string_clone(optimization_options) }));
	}
	if (v->pref->is_prod && !debug_mode) {
		array_push(&args, _MOV((string[]){ string_clone(tos_lit("-DNDEBUG")) }));
	}
	if (debug_mode && string_ne(os__user_os(), tos_lit("windows"))) {
		array_push(&linker_flags, _MOV((string[]){ string_clone(tos_lit(" -rdynamic ")) }));
	}
	if (string_ne(ccompiler, tos_lit("msvc")) && v->pref->os != v__pref__OS_freebsd) {
		array_push(&args, _MOV((string[]){ string_clone(tos_lit("-Werror=implicit-function-declaration")) }));
	}
	if (v->pref->is_liveshared || v->pref->is_livemain) {
		if (v->pref->os == v__pref__OS_linux || string_eq(os__user_os(), tos_lit("linux"))) {
			array_push(&linker_flags, _MOV((string[]){ string_clone(tos_lit("-rdynamic")) }));
		}
		if (v->pref->os == v__pref__OS_macos || string_eq(os__user_os(), tos_lit("macos"))) {
			array_push(&args, _MOV((string[]){ string_clone(tos_lit("-flat_namespace")) }));
		}
	}
	string libs = tos_lit("");
	if (v->pref->build_mode == v__pref__BuildMode_build_module) {
		array_push(&args, _MOV((string[]){ string_clone(tos_lit("-c")) }));
	} else if (v->pref->use_cache) {
		array_string built_modules = __new_array_with_default(0, 0, sizeof(string), 0);
		string builtin_obj_path = v__builder__Builder_rebuild_cached_module(v, vexe, tos_lit("vlib/builtin"));
		libs = /*f*/string_add(libs, string_add(tos_lit(" "), builtin_obj_path));
		// FOR IN array
		array _t1815 = v->parsed_files;
		for (int _t1816 = 0; _t1816 < _t1815.len; ++_t1816) {
			v__ast__File ast_file = ((v__ast__File*)_t1815.data)[_t1816];
			// FOR IN array
			array _t1817 = ast_file.imports;
			for (int _t1818 = 0; _t1818 < _t1817.len; ++_t1818) {
				v__ast__Import imp_stmt = ((v__ast__Import*)_t1817.data)[_t1818];
				string imp = imp_stmt.mod;
				if (_IN(string, imp, built_modules)) {
					continue;
				}
				if (string_eq(imp, tos_lit("webview"))) {
					continue;
				}
				string mod_path = string_replace(imp, tos_lit("."), _const_os__path_separator);
				if (string_eq(imp, tos_lit("help"))) {
					continue;
				}
				string imp_path = os__join_path(tos_lit("vlib"), (varg_string){.len=1,.args={mod_path}});
				string obj_path = v__builder__Builder_rebuild_cached_module(v, vexe, imp_path);
				libs = /*f*/string_add(libs, string_add(tos_lit(" "), obj_path));
				if (string_ends_with(obj_path, tos_lit("vlib/ui.o"))) {
					array_push(&args, _MOV((string[]){ string_clone(tos_lit("-framework Cocoa -framework Carbon")) }));
				}
				array_push(&built_modules, _MOV((string[]){ string_clone(imp) }));
			}
		}
	}
	if (v->pref->sanitize) {
		array_push(&args, _MOV((string[]){ string_clone(tos_lit("-fsanitize=leak")) }));
	}
	if (v->pref->os == v__pref__OS_linux) {
		#if !defined(__linux__)
		{
			v__builder__Builder_cc_linux_cross(v);
			return;
		}
		#endif
	}
	if (v->pref->os == v__pref__OS_ios) {
		string bundle_name = *(string*)array_last(string_split(v->pref->out_name, tos_lit("/")));
		array_push(&args, _MOV((string[]){ string_clone(_STR("-o \"%.*s\000.app/%.*s\000\"", 3, v->pref->out_name, bundle_name)) }));
	} else {
		array_push(&args, _MOV((string[]){ string_clone(_STR("-o \"%.*s\000\"", 2, v->pref->out_name)) }));
	}
	if (os__is_dir(v->pref->out_name)) {
		v__builder__verror(_STR("'%.*s\000' is a directory", 2, v->pref->out_name));
	}
	if (v->pref->os == v__pref__OS_macos || v->pref->os == v__pref__OS_ios) {
		array_push(&args, _MOV((string[]){ string_clone(tos_lit("-x objective-c")) }));
	}
	array_push(&args, _MOV((string[]){ string_clone(_STR("\"%.*s\000\"", 2, v->out_name_c)) }));
	if (v->pref->os == v__pref__OS_macos) {
		array_push(&args, _MOV((string[]){ string_clone(tos_lit("-x none")) }));
	}
	if (v->pref->os == v__pref__OS_macos) {
		array_push(&args, _MOV((string[]){ string_clone(tos_lit("-mmacosx-version-min=10.7")) }));
	}
	if (v->pref->os == v__pref__OS_ios) {
		array_push(&args, _MOV((string[]){ string_clone(tos_lit("-miphoneos-version-min=10.0")) }));
	}
	if (v->pref->os == v__pref__OS_windows) {
		array_push(&args, _MOV((string[]){ string_clone(tos_lit("-municode")) }));
	}
	array_v__cflag__CFlag cflags = v__builder__Builder_get_os_cflags(v);
	array_push(&args, _MOV((string[]){ string_clone(array_v__cflag__CFlag_c_options_only_object_files(cflags)) }));
	array_push(&args, _MOV((string[]){ string_clone(array_v__cflag__CFlag_c_options_without_object_files(cflags)) }));
	array_push(&args, _MOV((string[]){ string_clone(libs) }));
	if (string_contains(guessed_compiler, tos_lit("++"))) {
		array_push(&args, _MOV((string[]){ string_clone(tos_lit("-fpermissive")) }));
		array_push(&args, _MOV((string[]){ string_clone(tos_lit("-w")) }));
	}
	if (v->pref->use_cache) {
		if (!is_cc_tcc) {
			#if defined(__linux__)
			{
			}
			#endif
		}
	}
	if (is_cc_tcc && !_IN(string, tos_lit("no_backtrace"), v->pref->compile_defines)) {
		array_push(&args, _MOV((string[]){ string_clone(tos_lit("-bt25")) }));
	}
	if (!v->pref->is_bare && v->pref->build_mode != v__pref__BuildMode_build_module && (v->pref->os == v__pref__OS_linux || v->pref->os == v__pref__OS_freebsd || v->pref->os == v__pref__OS_openbsd || v->pref->os == v__pref__OS_netbsd || v->pref->os == v__pref__OS_dragonfly || v->pref->os == v__pref__OS_solaris || v->pref->os == v__pref__OS_haiku)) {
		array_push(&linker_flags, _MOV((string[]){ string_clone(tos_lit("-lm")) }));
		array_push(&linker_flags, _MOV((string[]){ string_clone(tos_lit("-lpthread")) }));
		if (v->pref->os == v__pref__OS_linux) {
			array_push(&linker_flags, _MOV((string[]){ string_clone(tos_lit("-ldl")) }));
		}
		if (v->pref->os == v__pref__OS_freebsd) {
			array_push(&linker_flags, _MOV((string[]){ string_clone(tos_lit("-lexecinfo")) }));
		}
	}
	if (!v->pref->is_bare && v->pref->os == v__pref__OS_js && string_eq(os__user_os(), tos_lit("linux"))) {
		array_push(&linker_flags, _MOV((string[]){ string_clone(tos_lit("-lm")) }));
	}
	string env_cflags = os__getenv(tos_lit("CFLAGS"));
	string env_ldflags = os__getenv(tos_lit("LDFLAGS"));
	string str_args = string_add(string_add(string_add(string_add(string_add(string_add(env_cflags, tos_lit(" ")), array_string_join(args, tos_lit(" "))), tos_lit(" ")), array_string_join(linker_flags, tos_lit(" "))), tos_lit(" ")), env_ldflags);
	if (v->pref->is_verbose) {
		println(_STR("cc args=%.*s", 1, str_args));
		println(array_string_str(args));
	}
	string response_file = _STR("%.*s\000.rsp", 2, v->out_name_c);
	string response_file_content = string_replace(str_args, tos_lit("\\"), tos_lit("\\\\"));
	Option_void _t1841 = os__write_file(response_file, response_file_content);
	if (!_t1841.ok && !_t1841.is_none) {
		string err = _t1841.v_error;
		int errcode = _t1841.ecode;
		v__builder__verror(_STR("Unable to write response file \"%.*s\000\"", 2, response_file));
	};
	if (!debug_mode) {
		array_push(&v->pref->cleanup_files, _MOV((string[]){ string_clone(v->out_name_c) }));
		array_push(&v->pref->cleanup_files, _MOV((string[]){ string_clone(response_file) }));
	}
	start: {}
	v__builder__todo();
	string cmd = _STR("%.*s\000 @%.*s", 2, ccompiler, response_file);
	v__builder__Builder_show_cc(v, cmd, response_file, response_file_content);
	i64 ticks = time__ticks();
	Option_os__Result _t1844 = os__exec(cmd);
	if (!_t1844.ok) {
		string err = _t1844.v_error;
		int errcode = _t1844.ecode;
		println(tos_lit("C compilation failed."));
		v__builder__verror(err);
		return;
	}
 	os__Result res = *(os__Result*) _t1844.data;
	i64 diff = time__ticks() - ticks;
	v__builder__Builder_timing_message(v, _STR("C %*.*s", 1, ccompiler, 3), diff);
	if (v->pref->show_c_output) {
		v__builder__Builder_show_c_compiler_output(v, res);
	}
	if (res.exit_code == 127) {
		#if defined(__linux__)
		{
		}
		#endif
		v__builder__verror(string_add(string_add(string_add(string_add(string_add(string_add(tos_lit("C compiler error, while attempting to run: \n"), tos_lit("-----------------------------------------------------------\n")), _STR("%.*s\000\n", 2, cmd)), tos_lit("-----------------------------------------------------------\n")), tos_lit("Probably your C compiler is missing. \n")), tos_lit("Please reinstall it, or make it available in your PATH.\n\n")), v__builder__missing_compiler_info()));
	}
	if (!v->pref->show_c_output) {
		v__builder__Builder_post_process_c_compiler_output(v, res);
	}
	if (v->pref->is_verbose) {
		println(_STR("%.*s\000 took %"PRId64"\000 ms", 3, ccompiler, diff));
		println(tos_lit("=========\n"));
	}
	if (v->pref->compress) {
		#if defined(_WIN32)
		{
			println(tos_lit("-compress does not work on Windows for now"));
			return;
		}
		#endif
		int ret = os__system(_STR("strip %.*s", 1, v->pref->out_name));
		if (ret != 0) {
			println(tos_lit("strip failed"));
			return;
		}
		int ret2 = os__system(_STR("upx --lzma -qqq %.*s", 1, v->pref->out_name));
		if (ret2 != 0) {
			ret2 = os__system(_STR("upx -qqq %.*s", 1, v->pref->out_name));
		}
		if (ret2 != 0) {
			println(tos_lit("upx failed"));
			#if defined(__APPLE__)
			{
			}
			#endif
			#if defined(__linux__)
			{
			}
			#endif
			#if defined(_WIN32)
			{
			}
			#endif
		}
	}
}

VV_LOCAL_SYMBOL void v__builder__Builder_cc_linux_cross(v__builder__Builder* b) {
	string parent_dir = os__vmodules_dir();
	if (!os__exists(parent_dir)) {
		os__mkdir(parent_dir);
	}
	string sysroot = os__join_path(os__vmodules_dir(), (varg_string){.len=1,.args={tos_lit("linuxroot")}});
	if (!os__is_dir(sysroot)) {
		println(tos_lit("Downloading files for Linux cross compilation (~18 MB)..."));
		string zip_url = tos_lit("https://github.com/vlang/v/releases/download/0.1.27/linuxroot.zip");
		string zip_file = string_add(sysroot, tos_lit(".zip"));
		os__system(_STR("curl -L -o %.*s\000 %.*s", 2, zip_file, zip_url));
		if (!os__exists(zip_file)) {
			v__builder__verror(_STR("Failed to download `%.*s\000` as %.*s", 2, zip_url, zip_file));
		}
		os__system(_STR("tar -C %.*s\000 -xf %.*s", 2, parent_dir, zip_file));
		if (!os__is_dir(sysroot)) {
			v__builder__verror(_STR("Failed to unzip %.*s\000 to %.*s", 2, zip_file, parent_dir));
		}
	}
	string obj_file = string_add(b->out_name_c, tos_lit(".o"));
	string cc_args = _STR("-fPIC -w -c -target x86_64-linux-gnu -c -o %.*s\000 %.*s\000 -I %.*s\000/include ", 4, obj_file, b->out_name_c, sysroot);
	array_v__cflag__CFlag cflags = v__builder__Builder_get_os_cflags(b);
	cc_args = /*f*/string_add(cc_args, array_v__cflag__CFlag_c_options_without_object_files(cflags));
	string cc_cmd = _STR("cc %.*s", 1, cc_args);
	if (b->pref->show_cc) {
		println(cc_cmd);
	}
	Option_os__Result _t1845 = os__exec(cc_cmd);
	if (!_t1845.ok) {
		string err = _t1845.v_error;
		int errcode = _t1845.ecode;
		println(tos_lit("Cross compilation for Linux failed (first step, cc). Make sure you have clang installed."));
		v__builder__verror(err);
		return;
	}
 	os__Result cc_res = *(os__Result*) _t1845.data;
	if (cc_res.exit_code != 0) {
		println(tos_lit("Cross compilation for Linux failed (first step, cc). Make sure you have clang installed."));
		v__builder__verror(cc_res.output);
	}
	array_string linker_args = new_array_from_c_array(10, 10, sizeof(string), _MOV((string[10]){
			_STR("-L %.*s\000/usr/lib/x86_64-linux-gnu/", 2, sysroot), _STR("--sysroot=%.*s\000 -v -o %.*s\000 -m elf_x86_64", 3, sysroot, b->pref->out_name), tos_lit("-dynamic-linker /lib/x86_64-linux-gnu/ld-linux-x86-64.so.2"), _STR("%.*s\000/crt1.o %.*s\000/crti.o %.*s", 3, sysroot, sysroot, obj_file), tos_lit("-lc"), tos_lit("-lcrypto"), tos_lit("-lssl"), tos_lit("-lpthread"), _STR("%.*s\000/crtn.o", 2, sysroot), array_v__cflag__CFlag_c_options_only_object_files(cflags)}));
	string linker_args_str = array_string_join(linker_args, tos_lit(" "));
	string linker_cmd = _STR("%.*s\000/ld.lld %.*s", 2, sysroot, linker_args_str);
	if (b->pref->show_cc) {
		println(linker_cmd);
	}
	Option_os__Result _t1846 = os__exec(linker_cmd);
	if (!_t1846.ok) {
		string err = _t1846.v_error;
		int errcode = _t1846.ecode;
		println(tos_lit("Cross compilation for Linux failed (second step, lld)."));
		v__builder__verror(err);
		return;
	}
 	os__Result res = *(os__Result*) _t1846.data;
	if (res.exit_code != 0) {
		println(tos_lit("Cross compilation for Linux failed (second step, lld)."));
		v__builder__verror(res.output);
	}
	println(string_add(b->pref->out_name, tos_lit(" has been successfully compiled")));
}

VV_LOCAL_SYMBOL void v__builder__Builder_cc_windows_cross(v__builder__Builder* c) {
	println(tos_lit("Cross compiling for Windows..."));
	if (!string_ends_with(c->pref->out_name, tos_lit(".exe"))) {
		c->pref->out_name = /*f*/string_add(c->pref->out_name, tos_lit(".exe"));
	}
	string args = _STR("-o %.*s\000 -w -L. ", 2, c->pref->out_name);
	array_v__cflag__CFlag cflags = v__builder__Builder_get_os_cflags(c);
	args = /*f*/string_add(args, (string_eq(c->pref->ccompiler, tos_lit("msvc")) ? (array_v__cflag__CFlag_c_options_before_target_msvc(cflags)) : (array_v__cflag__CFlag_c_options_before_target(cflags))));
	string optimization_options = tos_lit("");
	string debug_options = tos_lit("");
	if (c->pref->is_prod) {
		optimization_options = (string_eq(c->pref->ccompiler, tos_lit("msvc")) ? (tos_lit("")) : (tos_lit(" -O3 -fno-strict-aliasing -flto ")));
	}
	if (c->pref->is_debug) {
		debug_options = (string_eq(c->pref->ccompiler, tos_lit("msvc")) ? (tos_lit("")) : (tos_lit(" -g3 -no-pie ")));
	}
	string libs = tos_lit("");
	if (false && c->pref->build_mode == v__pref__BuildMode_default_mode) {
		libs = _STR("\"%.*s\000/vlib/builtin.o\"", 2, _const_v__pref__default_module_path);
		if (!os__exists(libs)) {
			v__builder__verror(_STR("`%.*s\000` not found", 2, libs));
		}
		// FOR IN array
		array _t1847 = c->table->imports;
		for (int _t1848 = 0; _t1848 < _t1847.len; ++_t1848) {
			string imp = ((string*)_t1847.data)[_t1848];
			libs = /*f*/string_add(libs, _STR(" \"%.*s\000/vlib/%.*s\000.o\"", 3, _const_v__pref__default_module_path, imp));
		}
	}
	args = /*f*/string_add(args, _STR(" %.*s\000 ", 2, c->out_name_c));
	args = /*f*/string_add(args, (string_eq(c->pref->ccompiler, tos_lit("msvc")) ? (array_v__cflag__CFlag_c_options_after_target_msvc(cflags)) : (array_v__cflag__CFlag_c_options_after_target(cflags))));
	if (!(string_eq(os__user_os(), tos_lit("macos")) || string_eq(os__user_os(), tos_lit("linux")))) {
		println(os__user_os());
		v_panic(tos_lit("your platform is not supported yet"));
	}
	string cmd = _STR("%.*s\000 %.*s\000 %.*s\000 -std=gnu11 %.*s\000 -municode", 5, _const_v__builder__mingw_cc, optimization_options, debug_options, args);
	if (c->pref->is_verbose || c->pref->show_cc) {
		println(cmd);
	}
	if (os__system(cmd) != 0) {
		println(tos_lit("Cross compilation for Windows failed. Make sure you have mingw-w64 installed."));
		#if defined(__APPLE__)
		{
		}
		#endif
		#if defined(__linux__)
		{
		}
		#endif
		v_exit(1);
	}
	println(string_add(c->pref->out_name, tos_lit(" has been successfully compiled")));
}

VV_LOCAL_SYMBOL void v__builder__Builder_build_thirdparty_obj_files(v__builder__Builder* v) {
	v__builder__Builder_log(/*rec*/*v, _STR("build_thirdparty_obj_files: v.table.cflags: %.*s", 1, array_v__cflag__CFlag_str(v->table->cflags)));
	// FOR IN array
	array _t1849 = v__builder__Builder_get_os_cflags(v);
	for (int _t1850 = 0; _t1850 < _t1849.len; ++_t1850) {
		v__cflag__CFlag flag = ((v__cflag__CFlag*)_t1849.data)[_t1850];
		if (string_ends_with(flag.value, tos_lit(".o"))) {
			array_v__cflag__CFlag rest_of_module_flags = v__builder__Builder_get_rest_of_module_cflags(v, (voidptr)&/*qq*/flag);
			if (string_eq(v->pref->ccompiler, tos_lit("msvc"))) {
				v__builder__Builder_build_thirdparty_obj_file_with_msvc(v, flag.value, rest_of_module_flags);
			} else {
				v__builder__Builder_build_thirdparty_obj_file(v, flag.value, rest_of_module_flags);
			}
		}
	}
}

VV_LOCAL_SYMBOL void v__builder__Builder_build_thirdparty_obj_file(v__builder__Builder* v, string path, array_v__cflag__CFlag moduleflags) {
	string obj_path = os__real_path(path);
	if (v->pref->os == v__pref__OS_windows) {
		#if !defined(_WIN32)
		{
		}
		#endif
	}
	string opath = v__vcache__CacheManager_postfix_with_key2cpath(&v->pref->cache_manager, tos_lit(".o"), obj_path);
	if (os__exists(opath)) {
		return;
	}
	if (os__exists(obj_path)) {
		os__cp(obj_path, opath);
		return;
	}
	println(_STR("%.*s\000 not found, building it in %.*s\000 ...", 3, obj_path, opath));
	string cfile = _STR("%.*s\000.c", 2, string_substr(obj_path, 0, obj_path.len - 2));
	string btarget = array_v__cflag__CFlag_c_options_before_target(moduleflags);
	string atarget = array_v__cflag__CFlag_c_options_after_target(moduleflags);
	string cppoptions = (string_contains(v->pref->ccompiler, tos_lit("++")) ? (tos_lit(" -fpermissive -w ")) : (tos_lit("")));
	string cmd = _STR("%.*s\000 %.*s\000 %.*s\000 %.*s\000 -o \"%.*s\000\" -c \"%.*s\000\" %.*s", 7, v->pref->ccompiler, cppoptions, v->pref->third_party_option, btarget, opath, cfile, atarget);
	Option_os__Result _t1851 = os__exec(cmd);
	if (!_t1851.ok) {
		string err = _t1851.v_error;
		int errcode = _t1851.ecode;
		eprintln(_STR("exec failed for thirdparty object build cmd:\n%.*s", 1, cmd));
		v__builder__verror(err);
		return;
	}
 	os__Result res = *(os__Result*) _t1851.data;
	if (res.exit_code != 0) {
		eprintln(_STR("failed thirdparty object build cmd:\n%.*s", 1, cmd));
		v__builder__verror(res.output);
		return;
	}
	v__vcache__CacheManager_save(&v->pref->cache_manager, tos_lit(".description.txt"), obj_path, _STR("%*.*s\000 @ %.*s\000\n", 3, obj_path, -30, cmd));
	println(res.output);
}

VV_LOCAL_SYMBOL string v__builder__missing_compiler_info() {
	#if defined(_WIN32)
	{
		return tos_lit("https://github.com/vlang/v/wiki/Installing-a-C-compiler-on-Windows");
	}
	#endif
	#if defined(__linux__)
	{
	}
	#endif
	#if defined(__APPLE__)
	{
	}
	#endif
	return tos_lit("");
}

VV_LOCAL_SYMBOL array_string v__builder__error_context_lines(string text, string keyword, int before, int after) {
	string khighlight = (term__can_show_color_on_stdout() ? (term__red(keyword)) : (keyword));
	int eline_idx = 0;
	array_string lines = string_split_into_lines(text);
	// FOR IN array
	array _t1852 = lines;
	for (int idx = 0; idx < _t1852.len; ++idx) {
		string eline = ((string*)_t1852.data)[idx];
		if (string_contains(eline, keyword)) {
			array_set(&lines, idx, &(string[]) { string_replace((*(string*)/*ee elem_typ */array_get(lines, idx)), keyword, khighlight) });
			if (eline_idx == 0) {
				eline_idx = idx;
			}
		}
	}
	int idx_s = (eline_idx - before >= 0 ? (eline_idx - before) : (0));
	int idx_e = (idx_s + after < lines.len ? (idx_s + after) : (lines.len));
	return array_slice(lines, idx_s, idx_e);
}

VV_LOCAL_SYMBOL array_v__cflag__CFlag v__builder__Builder_get_os_cflags(v__builder__Builder* v) {
	array_v__cflag__CFlag flags = __new_array_with_default(0, 0, sizeof(v__cflag__CFlag), 0);
	array_string ctimedefines = __new_array_with_default(0, 0, sizeof(string), 0);
	if (v->pref->compile_defines.len > 0) {
		_PUSH_MANY(&ctimedefines, (v->pref->compile_defines), _t1853, array_string);
	}
	// FOR IN array
	array _t1854 = v->table->cflags;
	for (int _t1855 = 0; _t1855 < _t1854.len; ++_t1855) {
		v__cflag__CFlag* flag = ((v__cflag__CFlag*)_t1854.data) + _t1855;
		if (string_ends_with(flag->value, tos_lit(".o"))) {
			flag->cached = v__vcache__CacheManager_postfix_with_key2cpath(&v->pref->cache_manager, tos_lit(".o"), os__real_path(flag->value));
		}
		if ((flag->os).len == 0 || (string_eq(flag->os, tos_lit("linux")) && v->pref->os == v__pref__OS_linux) || (string_eq(flag->os, tos_lit("macos")) && v->pref->os == v__pref__OS_macos) || (string_eq(flag->os, tos_lit("darwin")) && v->pref->os == v__pref__OS_macos) || (string_eq(flag->os, tos_lit("freebsd")) && v->pref->os == v__pref__OS_freebsd) || (string_eq(flag->os, tos_lit("windows")) && v->pref->os == v__pref__OS_windows) || (string_eq(flag->os, tos_lit("mingw")) && v->pref->os == v__pref__OS_windows && string_ne(v->pref->ccompiler, tos_lit("msvc"))) || (string_eq(flag->os, tos_lit("solaris")) && v->pref->os == v__pref__OS_solaris)) {
			array_push(&flags, _MOV((v__cflag__CFlag[]){ *flag }));
		}
		if (_IN(string, flag->os, ctimedefines)) {
			array_push(&flags, _MOV((v__cflag__CFlag[]){ *flag }));
		}
	}
	return flags;
}

VV_LOCAL_SYMBOL array_v__cflag__CFlag v__builder__Builder_get_rest_of_module_cflags(v__builder__Builder* v, v__cflag__CFlag* c) {
	array_v__cflag__CFlag flags = __new_array_with_default(0, 0, sizeof(v__cflag__CFlag), 0);
	array_v__cflag__CFlag cflags = v__builder__Builder_get_os_cflags(v);
	// FOR IN array
	array _t1858 = cflags;
	for (int _t1859 = 0; _t1859 < _t1858.len; ++_t1859) {
		v__cflag__CFlag flag = ((v__cflag__CFlag*)_t1858.data)[_t1859];
		if (string_eq(c->mod, flag.mod)) {
			if (string_eq(c->name, flag.name) && string_eq(c->value, flag.value) && string_eq(c->os, flag.os)) {
				continue;
			}
			array_push(&flags, _MOV((v__cflag__CFlag[]){ flag }));
		}
	}
	return flags;
}

VV_LOCAL_SYMBOL string v__builder__get_vtmp_folder() {
	string vtmp = os__getenv(tos_lit("VTMP"));
	if (vtmp.len > 0) {
		return vtmp;
	}
	vtmp = os__join_path(os__temp_dir(), (varg_string){.len=1,.args={tos_lit("v")}});
	if (!os__exists(vtmp) || !os__is_dir(vtmp)) {
		os__mkdir_all(vtmp);
	}
	os__setenv(tos_lit("VTMP"), vtmp, true);
	return vtmp;
}

VV_LOCAL_SYMBOL string v__builder__Builder_get_vtmp_filename(v__builder__Builder* b, string base_file_name, string postfix) {
	string vtmp = v__builder__get_vtmp_folder();
	string uniq = tos_lit("");
	if (!b->pref->reuse_tmpc) {
		uniq = _STR(".%"PRIu64"", 1, rand__u64());
	}
	return os__real_path(os__join_path(vtmp, (varg_string){.len=1,.args={string_add(os__file_name(os__real_path(base_file_name)), _STR("%.*s\000%.*s", 2, uniq, postfix))}}));
}

void v__builder__compile(string command, v__pref__Preferences* pref) {
	string odir = os__dir(pref->out_name);
	string output_folder = odir;
	if (odir.len == pref->out_name.len) {
		output_folder = os__getwd();
	}
	Option_bool _t1861 = os__is_writable_folder(output_folder);
	if (!_t1861.ok) {
		string err = _t1861.v_error;
		int errcode = _t1861.ecode;
		v__builder__verror(err);
		v_exit(1);
	};
	v__builder__Builder b = v__builder__new_builder(pref);
	if (pref->is_verbose) {
		println(tos_lit("builder.compile() pref:"));
	}
	time__StopWatch sw = time__new_stopwatch((time__StopWatchOptions){.auto_start = true,});
	v__pref__Backend _t1862 = pref->backend;
	if (_t1862 == v__pref__Backend_c) {
		v__builder__Builder_compile_c(&b);
	} else if (_t1862 == v__pref__Backend_js) {
		v__builder__Builder_compile_js(&b);
	} else if (_t1862 == v__pref__Backend_x64) {
		v__builder__Builder_compile_x64(&b);
	};
	if (pref->is_stats) {
		println(_STR("compilation took: %.*s\000 ms", 2, v__util__bold(i64_str(time__Duration_milliseconds(time__StopWatch_elapsed(sw))))));
	}
	v__builder__Builder_exit_on_invalid_syntax(&b);
	v__builder__Builder_myfree(&b);
	if (pref->is_test || pref->is_run) {
		v__builder__Builder_run_compiled_executable_and_exit(&b);
	}
}

// Attr: [unsafe]
VV_LOCAL_SYMBOL void v__builder__Builder_myfree(v__builder__Builder* b) {
	array_free(&b->parsed_files);
}

VV_LOCAL_SYMBOL void v__builder__Builder_exit_on_invalid_syntax(v__builder__Builder* b) {
	if (b->pref->only_check_syntax) {
		// FOR IN array
		array _t1863 = b->parsed_files;
		for (int _t1864 = 0; _t1864 < _t1863.len; ++_t1864) {
			v__ast__File pf = ((v__ast__File*)_t1863.data)[_t1864];
			if (pf.errors.len > 0) {
				v_exit(1);
			}
		}
		if (b->checker.nr_errors > 0) {
			v_exit(1);
		}
	}
}

VV_LOCAL_SYMBOL void v__builder__Builder_run_compiled_executable_and_exit(v__builder__Builder* b) {
	if (b->pref->skip_running) {
		return;
	}
	if (b->pref->only_check_syntax) {
		return;
	}
	if (b->pref->os == v__pref__OS_ios && b->pref->is_ios_simulator == false) {
		v_panic(tos_lit("Running iOS apps on physical devices is not yet supported. Please run in the simulator using the -simulator flag."));
	}
	if (b->pref->is_verbose) {
		println(_STR("============ running %.*s\000 ============", 2, b->pref->out_name));
	}
	if (b->pref->os == v__pref__OS_ios) {
		string device = tos_lit("\"iPhone SE (2nd generation)\"");
		os__exec(_STR("xcrun simctl boot %.*s", 1, device));
		string bundle_name = *(string*)array_last(string_split(b->pref->out_name, tos_lit("/")));
		string display_name = ((b->pref->display_name).len != 0 ? (b->pref->display_name) : (bundle_name));
		os__exec(_STR("xcrun simctl install %.*s\000 %.*s\000.app", 3, device, display_name));
		string bundle_id = ((b->pref->bundle_id).len != 0 ? (b->pref->bundle_id) : (_STR("app.vlang.%.*s", 1, bundle_name)));
		os__exec(_STR("xcrun simctl launch %.*s\000 %.*s", 2, device, bundle_id));
	} else {
		string exefile = os__real_path(b->pref->out_name);
		string cmd = _STR("\"%.*s\000\"", 2, exefile);
		if (b->pref->backend == v__pref__Backend_js) {
			string jsfile = os__real_path(_STR("%.*s\000.js", 2, b->pref->out_name));
			cmd = _STR("node \"%.*s\000\"", 2, jsfile);
		}
		// FOR IN array
		array _t1865 = b->pref->run_args;
		for (int _t1866 = 0; _t1866 < _t1865.len; ++_t1866) {
			string arg = ((string*)_t1865.data)[_t1866];
			if (string_index_byte(arg, ' ') > 0) {
				cmd = /*f*/string_add(cmd, string_add(string_add(tos_lit(" \""), arg), tos_lit("\"")));
			} else {
				cmd = /*f*/string_add(cmd, string_add(tos_lit(" "), arg));
			}
		}
		if (b->pref->is_verbose) {
			println(_STR("command to run executable: %.*s", 1, cmd));
		}
		if (b->pref->is_test) {
			v_exit(os__system(cmd));
		}
		if (b->pref->is_run) {
			int ret = os__system(cmd);
			v_exit(ret);
		}
	}
	v_exit(0);
}

VV_LOCAL_SYMBOL void v__builder__Builder_set_module_lookup_paths(v__builder__Builder* v) {
	v->module_search_paths = __new_array_with_default(0, 0, sizeof(string), 0);
	if (v->pref->is_test) {
		array_push(&v->module_search_paths, _MOV((string[]){ string_clone(os__dir(v->compiled_dir)) }));
	}
	array_push(&v->module_search_paths, _MOV((string[]){ string_clone(v->compiled_dir) }));
	string x = os__join_path(v->compiled_dir, (varg_string){.len=1,.args={tos_lit("modules")}});
	if (v->pref->is_verbose) {
		println(_STR("x: \"%.*s\000\"", 2, x));
	}
	array_push(&v->module_search_paths, _MOV((string[]){ string_clone(os__join_path(v->compiled_dir, (varg_string){.len=1,.args={tos_lit("modules")}})) }));
	_PUSH_MANY(&v->module_search_paths, (v->pref->lookup_path), _t1870, array_string);
	if (v->pref->is_verbose) {
		v__builder__Builder_log(/*rec*/*v, tos_lit("v.module_search_paths:"));
		println(array_string_str(v->module_search_paths));
	}
}

array_string v__builder__Builder_get_builtin_files(v__builder__Builder v) {
	v__builder__Builder_log(v, _STR("v.pref.lookup_path: %.*s", 1, array_string_str(v.pref->lookup_path)));
	// FOR IN array
	array _t1871 = v.pref->lookup_path;
	for (int _t1872 = 0; _t1872 < _t1871.len; ++_t1872) {
		string location = ((string*)_t1871.data)[_t1872];
		if (os__exists(os__join_path(location, (varg_string){.len=1,.args={tos_lit("builtin")}}))) {
			array_string builtin_files = __new_array_with_default(0, 0, sizeof(string), 0);
			if (v.pref->is_bare) {
				_PUSH_MANY(&builtin_files, (v__builder__Builder_v_files_from_dir(v, os__join_path(location, (varg_string){.len=2,.args={tos_lit("builtin"), tos_lit("bare")}}))), _t1873, array_string);
			} else if (v.pref->backend == v__pref__Backend_js) {
				_PUSH_MANY(&builtin_files, (v__builder__Builder_v_files_from_dir(v, os__join_path(location, (varg_string){.len=2,.args={tos_lit("builtin"), tos_lit("js")}}))), _t1874, array_string);
			} else {
				_PUSH_MANY(&builtin_files, (v__builder__Builder_v_files_from_dir(v, os__join_path(location, (varg_string){.len=1,.args={tos_lit("builtin")}}))), _t1875, array_string);
			}
			if (v.pref->backend == v__pref__Backend_c) {
				if (v.pref->is_vsh && os__exists(os__join_path(location, (varg_string){.len=1,.args={tos_lit("os")}}))) {
					_PUSH_MANY(&builtin_files, (v__builder__Builder_v_files_from_dir(v, os__join_path(location, (varg_string){.len=1,.args={tos_lit("os")}}))), _t1876, array_string);
				}
			}
			return builtin_files;
		}
	}
	v__builder__verror(tos_lit("`builtin/` not included on module lookup path.\nDid you forget to add vlib to the path? (Use @vlib for default vlib)"));
	v_panic(tos_lit("Unreachable code reached."));
	return __new_array(0, 1, sizeof(string));
}

array_string v__builder__Builder_get_user_files(v__builder__Builder* v) {
	if ((string_eq(v->pref->path, tos_lit("vlib/builtin")) || string_eq(v->pref->path, tos_lit("vlib/strconv")) || string_eq(v->pref->path, tos_lit("vlib/strings")) || string_eq(v->pref->path, tos_lit("vlib/hash")))) {
		v__builder__Builder_log(/*rec*/*v, tos_lit("Skipping user files."));
		return __new_array_with_default(0, 0, sizeof(string), 0);
	}
	string dir = v->pref->path;
	v__builder__Builder_log(/*rec*/*v, _STR("get_v_files(%.*s\000)", 2, dir));
	array_string user_files = __new_array_with_default(0, 0, sizeof(string), 0);
	string vroot = os__dir(v__pref__vexe_path());
	string preludes_path = os__join_path(vroot, (varg_string){.len=3,.args={tos_lit("cmd"), tos_lit("tools"), tos_lit("preludes")}});
	if (v->pref->is_livemain || v->pref->is_liveshared) {
		array_push(&user_files, _MOV((string[]){ string_clone(os__join_path(preludes_path, (varg_string){.len=1,.args={tos_lit("live.v")}})) }));
	}
	if (v->pref->is_livemain) {
		array_push(&user_files, _MOV((string[]){ string_clone(os__join_path(preludes_path, (varg_string){.len=1,.args={tos_lit("live_main.v")}})) }));
	}
	if (v->pref->is_liveshared) {
		array_push(&user_files, _MOV((string[]){ string_clone(os__join_path(preludes_path, (varg_string){.len=1,.args={tos_lit("live_shared.v")}})) }));
	}
	if (v->pref->is_test) {
		array_push(&user_files, _MOV((string[]){ string_clone(os__join_path(preludes_path, (varg_string){.len=1,.args={tos_lit("tests_assertions.v")}})) }));
	}
	if (v->pref->is_test && v->pref->is_stats) {
		array_push(&user_files, _MOV((string[]){ string_clone(os__join_path(preludes_path, (varg_string){.len=1,.args={tos_lit("tests_with_stats.v")}})) }));
	}
	if (v->pref->is_prof) {
		array_push(&user_files, _MOV((string[]){ string_clone(os__join_path(preludes_path, (varg_string){.len=1,.args={tos_lit("profiled_program.v")}})) }));
	}
	bool is_test = string_ends_with(dir, tos_lit("_test.v"));
	bool is_internal_module_test = false;
	if (is_test) {
		Option_string _t1883 = os__read_file(dir);
		if (!_t1883.ok) {
			string err = _t1883.v_error;
			int errcode = _t1883.ecode;
			v__builder__verror(_STR("%.*s\000 does not exist", 2, dir));
			v_exit(0);
		}
 		string tcontent = *(string*) _t1883.data;
		array_string slines = string_split_into_lines(string_trim_space(tcontent));
		// FOR IN array
		array _t1884 = slines;
		for (int _t1885 = 0; _t1885 < _t1884.len; ++_t1885) {
			string sline = ((string*)_t1884.data)[_t1885];
			string line = string_trim_space(sline);
			if (line.len > 2) {
				if (string_at(line, 0) == '/' && string_at(line, 1) == '/') {
					continue;
				}
				if (string_starts_with(line, tos_lit("module "))) {
					is_internal_module_test = true;
					break;
				}
			}
		}
	}
	if (is_internal_module_test) {
		string single_test_v_file = os__real_path(dir);
		if (v->pref->is_verbose) {
			v__builder__Builder_log(/*rec*/*v, _STR("> Compiling an internal module _test.v file %.*s\000 .", 2, single_test_v_file));
			v__builder__Builder_log(/*rec*/*v, tos_lit("> That brings in all other ordinary .v files in the same module too ."));
		}
		array_push(&user_files, _MOV((string[]){ string_clone(single_test_v_file) }));
		dir = os__dir(single_test_v_file);
	}
	bool does_exist = os__exists(dir);
	if (!does_exist) {
		v__builder__verror(_STR("%.*s\000 doesn't exist", 2, dir));
		v_exit(1);
	}
	bool is_real_file = does_exist && !os__is_dir(dir);
	if (is_real_file && (string_ends_with(dir, tos_lit(".v")) || string_ends_with(dir, tos_lit(".vsh")) || string_ends_with(dir, tos_lit(".vv")))) {
		string single_v_file = dir;
		array_push(&user_files, _MOV((string[]){ string_clone(single_v_file) }));
		if (v->pref->is_verbose) {
			v__builder__Builder_log(/*rec*/*v, _STR("> just compile one file: \"%.*s\000\"", 2, single_v_file));
		}
	} else if (os__is_dir(dir)) {
		if (v->pref->is_verbose) {
			v__builder__Builder_log(/*rec*/*v, _STR("> add all .v files from directory \"%.*s\000\" ...", 2, dir));
		}
		_PUSH_MANY(&user_files, (v__builder__Builder_v_files_from_dir(/*rec*/*v, dir)), _t1888, array_string);
	} else {
		println(tos_lit("usage: `v file.v` or `v directory`"));
		string ext = os__file_ext(dir);
		println(_STR("unknown file extension `%.*s\000`", 2, ext));
		v_exit(1);
	}
	if (user_files.len == 0) {
		println(tos_lit("No input .v files"));
		v_exit(1);
	}
	if (v->pref->is_verbose) {
		v__builder__Builder_log(/*rec*/*v, _STR("user_files: %.*s", 1, array_string_str(user_files)));
	}
	return user_files;
}

void v__builder__Builder_generic_struct_insts_to_concrete(v__builder__Builder* b) {
	// FOR IN array
	array _t1889 = b->table->types;
	for (int idx = 0; idx < _t1889.len; ++idx) {
		v__table__TypeSymbol* typ = &(*(v__table__TypeSymbol*)/*ee elem_typ */array_get(b->table->types, idx));
		if (typ->kind == v__table__Kind_generic_struct_inst) {
			v__table__GenericStructInst info = /* as */ *(v__table__GenericStructInst*)__as_cast((typ->info)._154, (typ->info).typ, /*expected:*/154);
			v__table__TypeSymbol parent = (*(v__table__TypeSymbol*)/*ee elem_typ */array_get(b->table->types, info.parent_idx));
			v__table__Struct parent_info = /* as */ *(v__table__Struct*)__as_cast((parent.info)._155, (parent.info).typ, /*expected:*/155);
			array_v__table__Field fields = array_clone(&parent_info.fields);
			// FOR IN array
			array _t1890 = fields;
			for (int i = 0; i < _t1890.len; ++i) {
				v__table__Field field = (*(v__table__Field*)/*ee elem_typ */array_get(fields, i));
				if (v__table__Type_has_flag(field.typ, v__table__TypeFlag_generic)) {
					if (parent_info.generic_types.len != info.generic_types.len) {
						v_panic(tos_lit("generic template mismatch"));
					}
					// FOR IN array
					array _t1891 = parent_info.generic_types;
					for (int j = 0; j < _t1891.len; ++j) {
						v__table__Type gp = ((v__table__Type*)_t1891.data)[j];
						if (gp == field.typ) {
							field.typ = v__table__Type_clear_flag(v__table__Type_derive((*(v__table__Type*)/*ee elem_typ */array_get(info.generic_types, j)), field.typ), v__table__TypeFlag_generic);
							break;
						}
					}
				}
				array_set(&fields, i, &(v__table__Field[]) { field });
			}
			parent_info.generic_types = __new_array_with_default(0, 0, sizeof(v__table__Type), 0);
			parent_info.fields = fields;
			typ->is_public = true;
			typ->kind = v__table__Kind_struct_;
			typ->info = /* sum type cast 4 */ (v__table__TypeInfo){._155 = memdup(&(v__table__Struct[]){parent_info}, sizeof(v__table__Struct)), .typ = 155 /* v.table.Struct */};
		}
	}
}

VV_LOCAL_SYMBOL string v__builder__make_ios_plist(string display_name, string bundle_id, string bundle_name, int bundle_version) {
	return _STR("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n	<key>CFBundleDevelopmentRegion</key>\n	<string>en</string>\n	<key>CFBundleDisplayName</key>\n	<string>%.*s\000</string>\n	<key>CFBundleExecutable</key>\n	<string>%.*s\000</string>\n	<key>CFBundleIdentifier</key>\n	<string>%.*s\000</string>\n	<key>CFBundleInfoDictionaryVersion</key>\n	<string>6.0</string>\n	<key>CFBundleName</key>\n	<string>%.*s\000</string>\n	<key>CFBundlePackageType</key>\n	<string>APPL</string>\n	<key>CFBundleShortVersionString</key>\n	<string>1.0.0</string>\n	<key>CFBundleSignature</key>\n	<string>VIOS</string>\n	<key>CFBundleVersion</key>\n	<string>%"PRId32"\000</string>\n	<key>LSRequiresIPhoneOS</key>\n	<true/>\n	<key>UISupportedInterfaceOrientations</key>\n	<array>\n		<string>UIInterfaceOrientationPortrait</string>\n		<string>UIInterfaceOrientationPortraitUpsideDown</string>\n		<string>UIInterfaceOrientationLandscapeLeft</string>\n		<string>UIInterfaceOrientationLandscapeRight</string>\n	</array>\n</dict>\n</plist>", 6, display_name, bundle_name, bundle_id, bundle_name, bundle_version);
}

string v__builder__Builder_gen_js(v__builder__Builder* b, array_string v_files) {
	i64 t0 = time__ticks();
	b->parsed_files = v__parser__parse_files(v_files, b->table, b->pref, b->global_scope);
	v__builder__Builder_parse_imports(b);
	i64 t1 = time__ticks();
	i64 parse_time = t1 - t0;
	v__builder__Builder_timing_message(b, tos_lit("PARSE"), parse_time);
	v__checker__Checker_check_files(&b->checker, b->parsed_files);
	i64 t2 = time__ticks();
	i64 check_time = t2 - t1;
	v__builder__Builder_timing_message(b, tos_lit("CHECK"), check_time);
	v__builder__Builder_print_warnings_and_errors(b);
	string res = v__gen__js__gen(b->parsed_files, b->table, b->pref);
	i64 t3 = time__ticks();
	i64 gen_time = t3 - t2;
	v__builder__Builder_timing_message(b, tos_lit("JS GEN"), gen_time);
	return res;
}

void v__builder__Builder_build_js(v__builder__Builder* b, array_string v_files, string out_file) {
	b->out_name_js = out_file;
	v__builder__Builder_info(/*rec*/*b, _STR("build_js(%.*s\000)", 2, out_file));
	string output = v__builder__Builder_gen_js(b, v_files);
	Option_os__File _t1892 = os__create(out_file);
	if (!_t1892.ok) {
		string err = _t1892.v_error;
		int errcode = _t1892.ecode;
		v_panic(err);
	}
 	os__File f = *(os__File*) _t1892.data;
	os__File_writeln(&f, output);
	os__File_close(&f);
}

void v__builder__Builder_compile_js(v__builder__Builder* b) {
	array_string files = v__builder__Builder_get_user_files(b);
	_PUSH_MANY(&files, (v__builder__Builder_get_builtin_files(/*rec*/*b)), _t1893, array_string);
	v__builder__Builder_set_module_lookup_paths(b);
	if (b->pref->is_verbose) {
		println(tos_lit("all .v files:"));
		println(array_string_str(files));
	}
	string name = b->pref->out_name;
	if (!string_ends_with(name, tos_lit(".js"))) {
		name = /*f*/string_add(name, tos_lit(".js"));
	}
	v__builder__Builder_build_js(b, files, name);
}

VV_LOCAL_SYMBOL void v__builder__Builder_run_js(v__builder__Builder* b) {
	string cmd = string_add(string_add(tos_lit("node "), b->pref->out_name), tos_lit(".js"));
	Option_os__Result _t1894 = os__exec(cmd);
	if (!_t1894.ok) {
		string err = _t1894.v_error;
		int errcode = _t1894.ecode;
		println(tos_lit("JS compilation failed."));
		v__builder__verror(err);
		return;
	}
 	os__Result res = *(os__Result*) _t1894.data;
	println(res.output);
}

// TypeDecl
VV_LOCAL_SYMBOL Option_string v__builder__find_windows_kit_internal(v__builder__RegKey key, array_string versions) {
	#if defined(_WIN32)
	{
		{ // Unsafe block
			// FOR IN array
			array _t1895 = versions;
			for (int _t1896 = 0; _t1896 < _t1895.len; ++_t1896) {
				string version = ((string*)_t1895.data)[_t1896];
				int required_bytes = 0;
				voidptr result = RegQueryValueEx(key, string_to_wide(version), 0, 0, 0, &required_bytes);
				int length = required_bytes / 2;
				if (result != 0) {
					continue;
				}
				int alloc_length = (required_bytes + 2);
				u16* value = ((u16*)(v_malloc(alloc_length)));
				if (isnil(value)) {
					continue;
				} else {
				}
				voidptr result2 = RegQueryValueEx(key, string_to_wide(version), 0, 0, value, &alloc_length);
				if (result2 != 0) {
					continue;
				}
				if (value[length - 1] != ((u16)(0U))) {
					value[length] = ((u16)(0U));
				}
				string res = string_from_wide(value);
				Option_string _t1897;
				opt_ok2(&(string[]) { res }, (OptionBase*)(&_t1897), sizeof(string));
				return _t1897;
			}
		}
	}
	#endif
	Option _t1898 = v_error(tos_lit("windows kit not found"));
	return *(Option_string*)&_t1898;
}

VV_LOCAL_SYMBOL Option_v__builder__WindowsKit v__builder__find_windows_kit_root(string host_arch) {
	#if defined(_WIN32)
	{
		v__builder__RegKey root_key = ((v__builder__RegKey)(0));
		string path = tos_lit("SOFTWARE\\Microsoft\\Windows Kits\\Installed Roots");
		voidptr rc = RegOpenKeyEx(_const_v__builder__hkey_local_machine, string_to_wide(path), 0, ((_const_v__builder__key_query_value | _const_v__builder__key_wow64_32key) | _const_v__builder__key_enumerate_sub_keys), &root_key);
		if (rc != 0) {
			Option _t1899 = v_error(tos_lit("Unable to open root key"));
			return *(Option_v__builder__WindowsKit*)&_t1899;
		}
		Option_string _t1900 = v__builder__find_windows_kit_internal(root_key, new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){tos_lit("KitsRoot10"), tos_lit("KitsRoot81")})));
		if (!_t1900.ok) {
			string err = _t1900.v_error;
			int errcode = _t1900.ecode;
			RegCloseKey(root_key);
			Option _t1901 = v_error(tos_lit("Unable to find a windows kit"));
			return *(Option_v__builder__WindowsKit*)&_t1901;
		}
 		string kit_root = *(string*) _t1900.data;
		string kit_lib = string_add(kit_root, tos_lit("Lib"));
		Option_array_string _t1902 = os__ls(kit_lib);
		if (!_t1902.ok) {
			return *(Option_v__builder__WindowsKit *)&_t1902;
		}
 		array_string files = *(array_string*) _t1902.data;
		string highest_path = tos_lit("");
		int highest_int = 0;
		// FOR IN array
		array _t1903 = files;
		for (int _t1904 = 0; _t1904 < _t1903.len; ++_t1904) {
			string f = ((string*)_t1903.data)[_t1904];
			string no_dot = string_replace(f, tos_lit("."), tos_lit(""));
			int v_int = string_int(no_dot);
			if (v_int > highest_int) {
				highest_int = v_int;
				highest_path = f;
			}
		}
		string kit_lib_highest = string_add(kit_lib, _STR("\\%.*s", 1, highest_path));
		string kit_include_highest = string_replace(kit_lib_highest, tos_lit("Lib"), tos_lit("Include"));
		RegCloseKey(root_key);
		Option_v__builder__WindowsKit _t1905;
		opt_ok2(&(v__builder__WindowsKit[]) { (v__builder__WindowsKit){.um_lib_path = string_add(kit_lib_highest, _STR("\\um\\%.*s", 1, host_arch)),.ucrt_lib_path = string_add(kit_lib_highest, _STR("\\ucrt\\%.*s", 1, host_arch)),.um_include_path = string_add(kit_include_highest, tos_lit("\\um")),.ucrt_include_path = string_add(kit_include_highest, tos_lit("\\ucrt")),.shared_include_path = string_add(kit_include_highest, tos_lit("\\shared")),} }, (OptionBase*)(&_t1905), sizeof(v__builder__WindowsKit));
		return _t1905;
	}
	#endif
	Option _t1906 = v_error(tos_lit("Host OS does not support finding a windows kit"));
	return *(Option_v__builder__WindowsKit*)&_t1906;
}

VV_LOCAL_SYMBOL Option_v__builder__VsInstallation v__builder__find_vs(string vswhere_dir, string host_arch) {
	#if !defined(_WIN32)
	{
	}
	#endif
	Option_os__Result _t1907 = os__exec(_STR("\"%.*s\000\\Microsoft Visual Studio\\Installer\\vswhere.exe\" -latest -prerelease -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationPath", 2, vswhere_dir));
	if (!_t1907.ok) {
		return *(Option_v__builder__VsInstallation *)&_t1907;
	}
 	os__Result res = *(os__Result*) _t1907.data;
	string res_output = string_trim_right(res.output, tos_lit("\r\n"));
	Option_string _t1908 = os__read_file(_STR("%.*s\000\\VC\\Auxiliary\\Build\\Microsoft.VCToolsVersion.default.txt", 2, res_output));
	if (!_t1908.ok) {
		string err = _t1908.v_error;
		int errcode = _t1908.ecode;
		Option _t1909 = v_error(tos_lit("Unable to find vs installation"));
		return *(Option_v__builder__VsInstallation*)&_t1909;
	}
 	string version = *(string*) _t1908.data;
	string version2 = version;
	string v = (string_ends_with(version, tos_lit("\n")) ? (string_substr(version2, 0, version.len - 2)) : (version2));
	string lib_path = _STR("%.*s\000\\VC\\Tools\\MSVC\\%.*s\000\\lib\\%.*s", 3, res.output, v, host_arch);
	string include_path = _STR("%.*s\000\\VC\\Tools\\MSVC\\%.*s\000\\include", 3, res.output, v);
	if (os__exists(_STR("%.*s\000\\vcruntime.lib", 2, lib_path))) {
		string p = _STR("%.*s\000\\VC\\Tools\\MSVC\\%.*s\000\\bin\\Host%.*s\000\\%.*s", 4, res.output, v, host_arch, host_arch);
		Option_v__builder__VsInstallation _t1910;
		opt_ok2(&(v__builder__VsInstallation[]) { (v__builder__VsInstallation){.include_path = include_path,.lib_path = lib_path,.exe_path = p,} }, (OptionBase*)(&_t1910), sizeof(v__builder__VsInstallation));
		return _t1910;
	}
	println(_STR("Unable to find vs installation (attempted to use lib path \"%.*s\000\")", 2, lib_path));
	Option _t1911 = v_error(tos_lit("Unable to find vs exe folder"));
	return *(Option_v__builder__VsInstallation*)&_t1911;
}

VV_LOCAL_SYMBOL Option_v__builder__MsvcResult v__builder__find_msvc() {
	#if defined(_WIN32)
	{
		string processor_architecture = os__getenv(tos_lit("PROCESSOR_ARCHITECTURE"));
		string vswhere_dir = (string_eq(processor_architecture, tos_lit("x86")) ? (tos_lit("%ProgramFiles%")) : (tos_lit("%ProgramFiles(x86)%")));
		string host_arch = (string_eq(processor_architecture, tos_lit("x86")) ? (tos_lit("X86")) : (tos_lit("X64")));
		Option_v__builder__WindowsKit _t1912 = v__builder__find_windows_kit_root(host_arch);
		if (!_t1912.ok) {
			string err = _t1912.v_error;
			int errcode = _t1912.ecode;
			Option _t1913 = v_error(tos_lit("Unable to find windows sdk"));
			return *(Option_v__builder__MsvcResult*)&_t1913;
		}
 		v__builder__WindowsKit wk = *(v__builder__WindowsKit*) _t1912.data;
		Option_v__builder__VsInstallation _t1914 = v__builder__find_vs(vswhere_dir, host_arch);
		if (!_t1914.ok) {
			string err = _t1914.v_error;
			int errcode = _t1914.ecode;
			Option _t1915 = v_error(tos_lit("Unable to find visual studio"));
			return *(Option_v__builder__MsvcResult*)&_t1915;
		}
 		v__builder__VsInstallation vs = *(v__builder__VsInstallation*) _t1914.data;
		Option_v__builder__MsvcResult _t1916;
		opt_ok2(&(v__builder__MsvcResult[]) { (v__builder__MsvcResult){
			.full_cl_exe_path = os__real_path(string_add(string_add(vs.exe_path, _const_os__path_separator), tos_lit("cl.exe"))),
			.exe_path = vs.exe_path,
			.um_lib_path = wk.um_lib_path,
			.ucrt_lib_path = wk.ucrt_lib_path,
			.vs_lib_path = vs.lib_path,
			.um_include_path = wk.um_include_path,
			.ucrt_include_path = wk.ucrt_include_path,
			.vs_include_path = vs.include_path,
			.shared_include_path = wk.shared_include_path,
			.valid = true,
		} }, (OptionBase*)(&_t1916), sizeof(v__builder__MsvcResult));
		return _t1916;
	}
	#else
	{
	}
	#endif
	Option _t1917 = opt_none();
	return *(Option_v__builder__MsvcResult*)&_t1917;
}

void v__builder__Builder_cc_msvc(v__builder__Builder* v) {
	v__builder__MsvcResult r = v->cached_msvc;
	if (r.valid == false) {
		v__builder__verror(tos_lit("Cannot find MSVC on this OS"));
		return;
	}
	string out_name_obj = os__real_path(string_add(v->out_name_c, tos_lit(".obj")));
	string out_name_pdb = os__real_path(string_add(v->out_name_c, tos_lit(".pdb")));
	string out_name_cmd_line = os__real_path(string_add(v->out_name_c, tos_lit(".rsp")));
	array_string a = new_array_from_c_array(4, 4, sizeof(string), _MOV((string[4]){tos_lit("-w"), tos_lit("/we4013"), tos_lit("/volatile:ms"), _STR("/Fo\"%.*s\000\"", 2, out_name_obj)}));
	if (v->pref->is_prod) {
		array_push(&a, _MOV((string[]){ string_clone(tos_lit("/O2")) }));
		array_push(&a, _MOV((string[]){ string_clone(tos_lit("/MD")) }));
		array_push(&a, _MOV((string[]){ string_clone(tos_lit("/DNDEBUG")) }));
	} else {
		array_push(&a, _MOV((string[]){ string_clone(tos_lit("/MDd")) }));
	}
	if (v->pref->is_debug) {
		_PUSH_MANY(&a, (new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){tos_lit("/Zi"), _STR("/Fd\"%.*s\000\"", 2, out_name_pdb)}))), _t1922, array_string);
	}
	if (v->pref->is_shared) {
		if (!string_ends_with(v->pref->out_name, tos_lit(".dll"))) {
			v->pref->out_name = /*f*/string_add(v->pref->out_name, tos_lit(".dll"));
		}
		array_push(&a, _MOV((string[]){ string_clone(tos_lit("/LD")) }));
	} else if (!string_ends_with(v->pref->out_name, tos_lit(".exe"))) {
		v->pref->out_name = /*f*/string_add(v->pref->out_name, tos_lit(".exe"));
	}
	v->pref->out_name = os__real_path(v->pref->out_name);
	if (v->pref->build_mode == v__pref__BuildMode_build_module) {
		array_push(&a, _MOV((string[]){ string_clone(tos_lit("/c")) }));
	} else if (v->pref->build_mode == v__pref__BuildMode_default_mode) {
	}
	if (v->pref->sanitize) {
		println(tos_lit("Sanitize not supported on msvc."));
	}
	array_push(&a, _MOV((string[]){ string_clone(string_add(string_add(tos_lit("\""), os__real_path(v->out_name_c)), tos_lit("\""))) }));
	array_string real_libs = new_array_from_c_array(3, 3, sizeof(string), _MOV((string[3]){tos_lit("kernel32.lib"), tos_lit("user32.lib"), tos_lit("advapi32.lib")}));
	v__builder__MsvcStringFlags sflags = v__builder__msvc_string_flags(v__builder__Builder_get_os_cflags(v));
	_PUSH_MANY(&real_libs, (sflags.real_libs), _t1926, array_string);
	array_string inc_paths = sflags.inc_paths;
	array_string lib_paths = sflags.lib_paths;
	array_string defines = sflags.defines;
	array_string other_flags = sflags.other_flags;
	array_push(&a, _MOV((string[]){ string_clone(_STR("-I \"%.*s\000\"", 2, r.ucrt_include_path)) }));
	array_push(&a, _MOV((string[]){ string_clone(_STR("-I \"%.*s\000\"", 2, r.vs_include_path)) }));
	array_push(&a, _MOV((string[]){ string_clone(_STR("-I \"%.*s\000\"", 2, r.um_include_path)) }));
	array_push(&a, _MOV((string[]){ string_clone(_STR("-I \"%.*s\000\"", 2, r.shared_include_path)) }));
	_PUSH_MANY(&a, (defines), _t1931, array_string);
	_PUSH_MANY(&a, (inc_paths), _t1932, array_string);
	_PUSH_MANY(&a, (other_flags), _t1933, array_string);
	array_push(&a, _MOV((string[]){ string_clone(array_string_join(real_libs, tos_lit(" "))) }));
	array_push(&a, _MOV((string[]){ string_clone(tos_lit("/link")) }));
	array_push(&a, _MOV((string[]){ string_clone(tos_lit("/NOLOGO")) }));
	array_push(&a, _MOV((string[]){ string_clone(_STR("/OUT:\"%.*s\000\"", 2, v->pref->out_name)) }));
	array_push(&a, _MOV((string[]){ string_clone(_STR("/LIBPATH:\"%.*s\000\"", 2, r.ucrt_lib_path)) }));
	array_push(&a, _MOV((string[]){ string_clone(_STR("/LIBPATH:\"%.*s\000\"", 2, r.um_lib_path)) }));
	array_push(&a, _MOV((string[]){ string_clone(_STR("/LIBPATH:\"%.*s\000\"", 2, r.vs_lib_path)) }));
	array_push(&a, _MOV((string[]){ string_clone(tos_lit("/DEBUG:FULL")) }));
	if (v->pref->is_prod) {
		array_push(&a, _MOV((string[]){ string_clone(tos_lit("/INCREMENTAL:NO")) }));
		array_push(&a, _MOV((string[]){ string_clone(tos_lit("/OPT:REF")) }));
		array_push(&a, _MOV((string[]){ string_clone(tos_lit("/OPT:ICF")) }));
	}
	_PUSH_MANY(&a, (lib_paths), _t1945, array_string);
	string args = array_string_join(a, tos_lit(" "));
	Option_void _t1946 = os__write_file(out_name_cmd_line, args);
	if (!_t1946.ok && !_t1946.is_none) {
		string err = _t1946.v_error;
		int errcode = _t1946.ecode;
		v__builder__verror(_STR("Unable to write response file to \"%.*s\000\"", 2, out_name_cmd_line));
	};
	string cmd = _STR("\"%.*s\000\" @%.*s", 2, r.full_cl_exe_path, out_name_cmd_line);
	v__builder__Builder_show_cc(v, cmd, out_name_cmd_line, args);
	i64 ticks = time__ticks();
	Option_os__Result _t1947 = os__exec(cmd);
	if (!_t1947.ok) {
		string err = _t1947.v_error;
		int errcode = _t1947.ecode;
		println(err);
		v__builder__verror(tos_lit("msvc error"));
		return;
	}
 	os__Result res = *(os__Result*) _t1947.data;
	i64 diff = time__ticks() - ticks;
	v__builder__Builder_timing_message(v, tos_lit("C msvc"), diff);
	if (v->pref->show_c_output) {
		v__builder__Builder_show_c_compiler_output(v, res);
	} else {
		v__builder__Builder_post_process_c_compiler_output(v, res);
	}
	os__rm(out_name_obj);
}

VV_LOCAL_SYMBOL void v__builder__Builder_build_thirdparty_obj_file_with_msvc(v__builder__Builder* v, string path, array_v__cflag__CFlag moduleflags) {
	v__builder__MsvcResult msvc = v->cached_msvc;
	if (msvc.valid == false) {
		v__builder__verror(tos_lit("Cannot find MSVC on this OS"));
		return;
	}
	string obj_path = _STR("%.*s\000bj", 2, path);
	obj_path = os__real_path(obj_path);
	if (os__exists(obj_path)) {
		return;
	}
	println(_STR("%.*s\000 not found, building it (with msvc)...", 2, obj_path));
	string cfiles = _STR("%.*s\000.c", 2, string_substr(path, 0, path.len - 2));
	v__builder__MsvcStringFlags flags = v__builder__msvc_string_flags(moduleflags);
	string inc_dirs = array_string_join(flags.inc_paths, tos_lit(" "));
	string defines = array_string_join(flags.defines, tos_lit(" "));
	string include_string = _STR("-I \"%.*s\000\" -I \"%.*s\000\" -I \"%.*s\000\" -I \"%.*s\000\" %.*s", 5, msvc.ucrt_include_path, msvc.vs_include_path, msvc.um_include_path, msvc.shared_include_path, inc_dirs);
	string cmd = _STR("\"%.*s\000\" /volatile:ms /DNDEBUG %.*s\000 %.*s\000 /c %.*s\000 /Fo\"%.*s\000\"", 6, msvc.full_cl_exe_path, defines, include_string, cfiles, obj_path);
	Option_os__Result _t1948 = os__exec(cmd);
	if (!_t1948.ok) {
		string err = _t1948.v_error;
		int errcode = _t1948.ecode;
		println(_STR("msvc: failed thirdparty object build cmd: %.*s", 1, cmd));
		v__builder__verror(err);
		return;
	}
 	os__Result res = *(os__Result*) _t1948.data;
	if (res.exit_code != 0) {
		println(_STR("msvc: failed thirdparty object build cmd: %.*s", 1, cmd));
		v__builder__verror(res.output);
		return;
	}
	println(res.output);
}

v__builder__MsvcStringFlags v__builder__msvc_string_flags(array_v__cflag__CFlag cflags) {
	array_string real_libs = __new_array_with_default(0, 0, sizeof(string), 0);
	array_string inc_paths = __new_array_with_default(0, 0, sizeof(string), 0);
	array_string lib_paths = __new_array_with_default(0, 0, sizeof(string), 0);
	array_string defines = __new_array_with_default(0, 0, sizeof(string), 0);
	array_string other_flags = __new_array_with_default(0, 0, sizeof(string), 0);
	// FOR IN array
	array _t1949 = cflags;
	for (int _t1950 = 0; _t1950 < _t1949.len; ++_t1950) {
		v__cflag__CFlag flag = ((v__cflag__CFlag*)_t1949.data)[_t1950];
		if (string_eq(flag.name, tos_lit("-l"))) {
			if (string_ends_with(flag.value, tos_lit(".dll"))) {
				v__builder__verror(_STR("MSVC cannot link against a dll (`#flag -l %.*s\000`)", 2, flag.value));
			}
			string lib_lib = string_add(flag.value, tos_lit(".lib"));
			array_push(&real_libs, _MOV((string[]){ string_clone(lib_lib) }));
		} else if (string_eq(flag.name, tos_lit("-I"))) {
			array_push(&inc_paths, _MOV((string[]){ string_clone(v__cflag__CFlag_format(&flag)) }));
		} else if (string_eq(flag.name, tos_lit("-L"))) {
			array_push(&lib_paths, _MOV((string[]){ string_clone(flag.value) }));
			array_push(&lib_paths, _MOV((string[]){ string_clone(string_add(string_add(flag.value, _const_os__path_separator), tos_lit("msvc"))) }));
		} else if (string_ends_with(flag.value, tos_lit(".o"))) {
			array_push(&other_flags, _MOV((string[]){ string_clone(_STR("\"%.*s\000bj\"", 2, flag.value)) }));
		} else if (string_starts_with(flag.value, tos_lit("-D"))) {
			array_push(&defines, _MOV((string[]){ string_clone(_STR("/D%.*s", 1, string_substr(flag.value, 2, flag.value.len))) }));
		} else {
			array_push(&other_flags, _MOV((string[]){ string_clone(flag.value) }));
		}
	}
	array_string lpaths = __new_array_with_default(0, 0, sizeof(string), 0);
	// FOR IN array
	array _t1958 = lib_paths;
	for (int _t1959 = 0; _t1959 < _t1958.len; ++_t1959) {
		string l = ((string*)_t1958.data)[_t1959];
		array_push(&lpaths, _MOV((string[]){ string_clone(string_add(string_add(tos_lit("/LIBPATH:\""), os__real_path(l)), tos_lit("\""))) }));
	}
	return (v__builder__MsvcStringFlags){.real_libs = real_libs,.inc_paths = inc_paths,.lib_paths = lpaths,.defines = defines,.other_flags = other_flags,};
}

void v__builder__Builder_build_x64(v__builder__Builder* b, array_string v_files, string out_file) {
	#if !defined(__linux__)
	{
		println(tos_lit("v -x64 can only generate Linux binaries for now"));
		println(string_add(tos_lit("You are not on a Linux system, so you will not "), tos_lit("be able to run the resulting executable")));
	}
	#endif
	i64 t0 = time__ticks();
	b->parsed_files = v__parser__parse_files(v_files, b->table, b->pref, b->global_scope);
	v__builder__Builder_parse_imports(b);
	i64 t1 = time__ticks();
	i64 parse_time = t1 - t0;
	v__builder__Builder_timing_message(b, tos_lit("PARSE"), parse_time);
	v__checker__Checker_check_files(&b->checker, b->parsed_files);
	i64 t2 = time__ticks();
	i64 check_time = t2 - t1;
	v__builder__Builder_timing_message(b, tos_lit("CHECK"), check_time);
	v__gen__x64__gen(b->parsed_files, b->table, out_file, b->pref);
	i64 t3 = time__ticks();
	i64 gen_time = t3 - t2;
	v__builder__Builder_timing_message(b, tos_lit("x64 GEN"), gen_time);
}

void v__builder__Builder_compile_x64(v__builder__Builder* b) {
	array_string files = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){b->pref->path}));
	v__builder__Builder_set_module_lookup_paths(b);
	v__builder__Builder_build_x64(b, files, b->pref->out_name);
}

VV_LOCAL_SYMBOL void main__main() {
	array_string args = array_slice(_const_os__args, 1, _const_os__args.len);
	if (args.len == 0 || (string_eq((*(string*)/*ee elem_typ */array_get(args, 0)), tos_lit("-")) || string_eq((*(string*)/*ee elem_typ */array_get(args, 0)), tos_lit("repl")))) {
		if (args.len == 0) {
			if (is_atty(0) != 0) {
				println(tos_lit("Welcome to the V REPL (for help with V itself, type `exit`, then run `v help`)."));
			} else {
				array_string args_and_flags = array_clone_static(array_slice(v__util__join_env_vflags_and_os_args(), 1, v__util__join_env_vflags_and_os_args().len));
				_PUSH_MANY(&args_and_flags, (new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){tos_lit("run"), tos_lit("-")}))), _t1961, array_string);
				v__pref__parse_args(args_and_flags);
			}
		}
		v__util__launch_tool(false, tos_lit("vrepl"), array_slice(_const_os__args, 1, _const_os__args.len));
		return;
	}
	array_string args_and_flags = array_slice(v__util__join_env_vflags_and_os_args(), 1, v__util__join_env_vflags_and_os_args().len);
	multi_return_v__pref__Preferences_string mr_1242 = v__pref__parse_args(args_and_flags);
	v__pref__Preferences* prefs = mr_1242.arg0;
	string command = mr_1242.arg1;
	if (prefs->is_verbose) {
	}
	if (string_eq(command, tos_lit("test-vet"))) {
		println(tos_lit("Please use `v test-cleancode` instead."));
		return;
	}
	if (_IN(string, command, _const_main__simple_cmd)) {
		v__util__launch_tool(prefs->is_verbose, string_add(tos_lit("v"), command), array_slice(_const_os__args, 1, _const_os__args.len));
		return;
	}
	string _t1962 = command;
	if (string_eq(_t1962, tos_lit("help"))) {
		main__invoke_help_and_exit(args);
	} else if (string_eq(_t1962, tos_lit("new")) || string_eq(_t1962, tos_lit("init"))) {
		v__util__launch_tool(prefs->is_verbose, tos_lit("vcreate"), array_slice(_const_os__args, 1, _const_os__args.len));
		return;
	} else if (string_eq(_t1962, tos_lit("translate"))) {
		println(tos_lit("Translating C to V will be available in V 0.3"));
		return;
	} else if (string_eq(_t1962, tos_lit("search")) || string_eq(_t1962, tos_lit("install")) || string_eq(_t1962, tos_lit("update")) || string_eq(_t1962, tos_lit("upgrade")) || string_eq(_t1962, tos_lit("outdated")) || string_eq(_t1962, tos_lit("list")) || string_eq(_t1962, tos_lit("remove"))) {
		v__util__launch_tool(prefs->is_verbose, tos_lit("vpm"), array_slice(_const_os__args, 1, _const_os__args.len));
		return;
	} else if (string_eq(_t1962, tos_lit("vlib-docs"))) {
		v__util__launch_tool(prefs->is_verbose, tos_lit("vdoc"), new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){tos_lit("doc"), tos_lit("vlib")})));
	} else if (string_eq(_t1962, tos_lit("get"))) {
		println(tos_lit("V Error: Use `v install` to install modules from vpm.vlang.io"));
		v_exit(1);
	} else if (string_eq(_t1962, tos_lit("version"))) {
		println(v__util__full_v_version(prefs->is_verbose));
		return;
	} else {
	};
	if ((string_eq(command, tos_lit("run")) || string_eq(command, tos_lit("build")) || string_eq(command, tos_lit("build-module"))) || string_ends_with(command, tos_lit(".v")) || os__exists(command)) {
		v__builder__compile(command, prefs);
		return;
	}
	eprintln(_STR("v %.*s\000: unknown command\nRun \"v help\" for usage.", 2, command));
	v_exit(1);
}

VV_LOCAL_SYMBOL void main__invoke_help_and_exit(array_string remaining) {
	int _t1963 = remaining.len;
	if (_t1963 == 0 || _t1963 == 1) {
		help__print_and_exit(tos_lit("default"));
	} else if (_t1963 == 2) {
		help__print_and_exit((*(string*)/*ee elem_typ */array_get(remaining, 1)));
	} else {
	};
	println(tos_lit("V Error: Expected only one help topic to be provided."));
	println(tos_lit("For usage information, use `v help`."));
	v_exit(1);
}

void _vinit() {
	builtin_init();
	vinit_string_literals();
	// Initializations for module strings :
	// Initializations for module hash :
	_const_hash__wyp0 = ((u64)(0xa0761d6478bd642fU));
	_const_hash__wyp1 = ((u64)(0xe7037ed1a0b428dbU));
	_const_hash__wyp2 = ((u64)(0x8ebc6af09c88c6e3U));
	_const_hash__wyp3 = ((u64)(0x589965cc75374cc3U));
	_const_hash__wyp4 = ((u64)(0x1d8e4e27c47d124fU));
	// Initializations for module math.bits :
	_const_math__bits__de_bruijn32 = ((u32)(0x077CB531U));
	_const_math__bits__de_bruijn32tab = new_array_from_c_array(32, 32, sizeof(byte), _MOV((byte[32]){
		((byte)(0)), 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8, 31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9}));
	_const_math__bits__de_bruijn64 = ((u64)(0x03f79d71b4ca8b09U));
	_const_math__bits__de_bruijn64tab = new_array_from_c_array(64, 64, sizeof(byte), _MOV((byte[64]){
		((byte)(0)), 1, 56, 2, 57, 49, 28, 3, 61, 58, 42, 50, 38, 29, 17, 4, 62, 47, 59, 36, 45, 43, 51, 22, 53, 39, 33, 30, 24, 18, 12, 5, 63, 55, 48, 27, 60, 41, 37, 16, 46, 35, 44, 21, 52, 32, 23, 11, 54, 26, 40, 15, 34, 20, 31, 10, 25, 14, 19, 9, 13, 8, 7, 6}));
	_const_math__bits__m0 = ((u64)(0x5555555555555555U));
	_const_math__bits__m1 = ((u64)(0x3333333333333333U));
	_const_math__bits__m2 = ((u64)(0x0f0f0f0f0f0f0f0fU));
	_const_math__bits__m3 = ((u64)(0x00ff00ff00ff00ffU));
	_const_math__bits__m4 = ((u64)(0x0000ffff0000ffffU));
	_const_math__bits__max_u32 = ((u32)(4294967295U));
	_const_math__bits__max_u64 = ((u64)(18446744073709551615U));
	_const_math__bits__two32 = ((u64)(0x100000000U));
	_const_math__bits__mask32 = _const_math__bits__two32 - 1;
	_const_math__bits__ntz_8_tab = new_array_from_c_array(256, 256, sizeof(byte), _MOV((byte[256]){
		((byte)(0x08)), 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x05, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x06, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x05, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x07, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x05, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x06, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x05, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00}));
	_const_math__bits__pop_8_tab = new_array_from_c_array(256, 256, sizeof(byte), _MOV((byte[256]){
		((byte)(0x00)), 0x01, 0x01, 0x02, 0x01, 0x02, 0x02, 0x03, 0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 0x05, 0x06, 0x06, 0x07, 0x06, 0x07, 0x07, 0x08}));
	_const_math__bits__rev_8_tab = new_array_from_c_array(256, 256, sizeof(byte), _MOV((byte[256]){
		((byte)(0x00)), 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0, 0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0, 0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8, 0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8, 0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4, 0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4, 0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec, 0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc, 0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2, 0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2, 0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea, 0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa, 0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6, 0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6, 0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee, 0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe, 0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1, 0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1, 0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9, 0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9, 0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5, 0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5, 0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed, 0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd, 0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3, 0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3, 0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb, 0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb, 0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7, 0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7, 0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef, 0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff}));
	_const_math__bits__len_8_tab = new_array_from_c_array(256, 256, sizeof(byte), _MOV((byte[256]){
		((byte)(0x00)), 0x01, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08}));
	// Initializations for module strconv :
	_const_strconv__double_plus_zero = ((u64)(0x0000000000000000U));
	_const_strconv__double_minus_zero = ((u64)(0x8000000000000000U));
	_const_strconv__double_plus_infinity = ((u64)(0x7FF0000000000000U));
	_const_strconv__double_minus_infinity = ((u64)(0xFFF0000000000000U));
	_const_strconv__c_ten = ((u32)(10U));
	_const_strconv__pos_exp = new_array_from_c_array(309, 309, sizeof(u64), _MOV((u64[309]){
		((u64)(0x3ff0000000000000U)), ((u64)(0x4024000000000000U)), ((u64)(0x4059000000000000U)), ((u64)(0x408f400000000000U)), ((u64)(0x40c3880000000000U)), ((u64)(0x40f86a0000000000U)), ((u64)(0x412e848000000000U)), ((u64)(0x416312d000000000U)), ((u64)(0x4197d78400000000U)), ((u64)(0x41cdcd6500000000U)), ((u64)(0x4202a05f20000000U)), ((u64)(0x42374876e8000000U)), ((u64)(0x426d1a94a2000000U)), ((u64)(0x42a2309ce5400000U)), ((u64)(0x42d6bcc41e900000U)), ((u64)(0x430c6bf526340000U)), ((u64)(0x4341c37937e08000U)), ((u64)(0x4376345785d8a000U)), ((u64)(0x43abc16d674ec800U)), ((u64)(0x43e158e460913d00U)), ((u64)(0x4415af1d78b58c40U)), ((u64)(0x444b1ae4d6e2ef50U)), ((u64)(0x4480f0cf064dd592U)), ((u64)(0x44b52d02c7e14af6U)), ((u64)(0x44ea784379d99db4U)), ((u64)(0x45208b2a2c280291U)), ((u64)(0x4554adf4b7320335U)), ((u64)(0x4589d971e4fe8402U)), ((u64)(0x45c027e72f1f1281U)), ((u64)(0x45f431e0fae6d721U)), ((u64)(0x46293e5939a08ceaU)), ((u64)(0x465f8def8808b024U)), ((u64)(0x4693b8b5b5056e17U)), ((u64)(0x46c8a6e32246c99cU)), ((u64)(0x46fed09bead87c03U)), ((u64)(0x4733426172c74d82U)), ((u64)(0x476812f9cf7920e3U)), ((u64)(0x479e17b84357691bU)), ((u64)(0x47d2ced32a16a1b1U)), ((u64)(0x48078287f49c4a1dU)), ((u64)(0x483d6329f1c35ca5U)), ((u64)(0x48725dfa371a19e7U)), ((u64)(0x48a6f578c4e0a061U)), ((u64)(0x48dcb2d6f618c879U)), ((u64)(0x4911efc659cf7d4cU)), ((u64)(0x49466bb7f0435c9eU)), ((u64)(0x497c06a5ec5433c6U)), ((u64)(0x49b18427b3b4a05cU)), ((u64)(0x49e5e531a0a1c873U)), ((u64)(0x4a1b5e7e08ca3a8fU)), ((u64)(0x4a511b0ec57e649aU)), ((u64)(0x4a8561d276ddfdc0U)), ((u64)(0x4ababa4714957d30U)), ((u64)(0x4af0b46c6cdd6e3eU)), ((u64)(0x4b24e1878814c9ceU)), ((u64)(0x4b5a19e96a19fc41U)), ((u64)(0x4b905031e2503da9U)), ((u64)(0x4bc4643e5ae44d13U)), ((u64)(0x4bf97d4df19d6057U)), ((u64)(0x4c2fdca16e04b86dU)), ((u64)(0x4c63e9e4e4c2f344U)), ((u64)(0x4c98e45e1df3b015U)), ((u64)(0x4ccf1d75a5709c1bU)), ((u64)(0x4d03726987666191U)), ((u64)(0x4d384f03e93ff9f5U)), ((u64)(0x4d6e62c4e38ff872U)), ((u64)(0x4da2fdbb0e39fb47U)), ((u64)(0x4dd7bd29d1c87a19U)), ((u64)(0x4e0dac74463a989fU)), ((u64)(0x4e428bc8abe49f64U)), ((u64)(0x4e772ebad6ddc73dU)), ((u64)(0x4eacfa698c95390cU)), ((u64)(0x4ee21c81f7dd43a7U)), ((u64)(0x4f16a3a275d49491U)), ((u64)(0x4f4c4c8b1349b9b5U)), ((u64)(0x4f81afd6ec0e1411U)), ((u64)(0x4fb61bcca7119916U)), ((u64)(0x4feba2bfd0d5ff5bU)), ((u64)(0x502145b7e285bf99U)), ((u64)(0x50559725db272f7fU)), ((u64)(0x508afcef51f0fb5fU)), ((u64)(0x50c0de1593369d1bU)), ((u64)(0x50f5159af8044462U)), ((u64)(0x512a5b01b605557bU)), ((u64)(0x516078e111c3556dU)), ((u64)(0x5194971956342ac8U)), ((u64)(0x51c9bcdfabc1357aU)), ((u64)(0x5200160bcb58c16cU)), ((u64)(0x52341b8ebe2ef1c7U)), ((u64)(0x526922726dbaae39U)), ((u64)(0x529f6b0f092959c7U)), ((u64)(0x52d3a2e965b9d81dU)), ((u64)(0x53088ba3bf284e24U)), ((u64)(0x533eae8caef261adU)), ((u64)(0x53732d17ed577d0cU)), ((u64)(0x53a7f85de8ad5c4fU)), ((u64)(0x53ddf67562d8b363U)), ((u64)(0x5412ba095dc7701eU)), ((u64)(0x5447688bb5394c25U)), ((u64)(0x547d42aea2879f2eU)), ((u64)(0x54b249ad2594c37dU)), ((u64)(0x54e6dc186ef9f45cU)), ((u64)(0x551c931e8ab87173U)), ((u64)(0x5551dbf316b346e8U)), ((u64)(0x558652efdc6018a2U)), ((u64)(0x55bbe7abd3781ecaU)), ((u64)(0x55f170cb642b133fU)), ((u64)(0x5625ccfe3d35d80eU)), ((u64)(0x565b403dcc834e12U)), ((u64)(0x569108269fd210cbU)), ((u64)(0x56c54a3047c694feU)), ((u64)(0x56fa9cbc59b83a3dU)), ((u64)(0x5730a1f5b8132466U)), ((u64)(0x5764ca732617ed80U)), ((u64)(0x5799fd0fef9de8e0U)), ((u64)(0x57d03e29f5c2b18cU)), ((u64)(0x58044db473335defU)), ((u64)(0x583961219000356bU)), ((u64)(0x586fb969f40042c5U)), ((u64)(0x58a3d3e2388029bbU)), ((u64)(0x58d8c8dac6a0342aU)), ((u64)(0x590efb1178484135U)), ((u64)(0x59435ceaeb2d28c1U)), ((u64)(0x59783425a5f872f1U)), ((u64)(0x59ae412f0f768fadU)), ((u64)(0x59e2e8bd69aa19ccU)), ((u64)(0x5a17a2ecc414a03fU)), ((u64)(0x5a4d8ba7f519c84fU)), ((u64)(0x5a827748f9301d32U)), ((u64)(0x5ab7151b377c247eU)), ((u64)(0x5aecda62055b2d9eU)), ((u64)(0x5b22087d4358fc82U)), ((u64)(0x5b568a9c942f3ba3U)), ((u64)(0x5b8c2d43b93b0a8cU)), ((u64)(0x5bc19c4a53c4e697U)), ((u64)(0x5bf6035ce8b6203dU)), ((u64)(0x5c2b843422e3a84dU)), ((u64)(0x5c6132a095ce4930U)), ((u64)(0x5c957f48bb41db7cU)), ((u64)(0x5ccadf1aea12525bU)), ((u64)(0x5d00cb70d24b7379U)), ((u64)(0x5d34fe4d06de5057U)), ((u64)(0x5d6a3de04895e46dU)), ((u64)(0x5da066ac2d5daec4U)), ((u64)(0x5dd4805738b51a75U)), ((u64)(0x5e09a06d06e26112U)), ((u64)(0x5e400444244d7cabU)), ((u64)(0x5e7405552d60dbd6U)), ((u64)(0x5ea906aa78b912ccU)), ((u64)(0x5edf485516e7577fU)), ((u64)(0x5f138d352e5096afU)), ((u64)(0x5f48708279e4bc5bU)), ((u64)(0x5f7e8ca3185deb72U)), ((u64)(0x5fb317e5ef3ab327U)), ((u64)(0x5fe7dddf6b095ff1U)), ((u64)(0x601dd55745cbb7edU)), ((u64)(0x6052a5568b9f52f4U)), ((u64)(0x60874eac2e8727b1U)), ((u64)(0x60bd22573a28f19dU)), ((u64)(0x60f2357684599702U)), ((u64)(0x6126c2d4256ffcc3U)), ((u64)(0x615c73892ecbfbf4U)), ((u64)(0x6191c835bd3f7d78U)), ((u64)(0x61c63a432c8f5cd6U)), ((u64)(0x61fbc8d3f7b3340cU)), ((u64)(0x62315d847ad00087U)), ((u64)(0x6265b4e5998400a9U)), ((u64)(0x629b221effe500d4U)), ((u64)(0x62d0f5535fef2084U)), ((u64)(0x630532a837eae8a5U)), ((u64)(0x633a7f5245e5a2cfU)), ((u64)(0x63708f936baf85c1U)), ((u64)(0x63a4b378469b6732U)), ((u64)(0x63d9e056584240feU)), ((u64)(0x64102c35f729689fU)), ((u64)(0x6444374374f3c2c6U)), ((u64)(0x647945145230b378U)), ((u64)(0x64af965966bce056U)), ((u64)(0x64e3bdf7e0360c36U)), ((u64)(0x6518ad75d8438f43U)), ((u64)(0x654ed8d34e547314U)), ((u64)(0x6583478410f4c7ecU)), ((u64)(0x65b819651531f9e8U)), ((u64)(0x65ee1fbe5a7e7861U)), ((u64)(0x6622d3d6f88f0b3dU)), ((u64)(0x665788ccb6b2ce0cU)), ((u64)(0x668d6affe45f818fU)), ((u64)(0x66c262dfeebbb0f9U)), ((u64)(0x66f6fb97ea6a9d38U)), ((u64)(0x672cba7de5054486U)), ((u64)(0x6761f48eaf234ad4U)), ((u64)(0x679671b25aec1d89U)), ((u64)(0x67cc0e1ef1a724ebU)), ((u64)(0x680188d357087713U)), ((u64)(0x6835eb082cca94d7U)), ((u64)(0x686b65ca37fd3a0dU)), ((u64)(0x68a11f9e62fe4448U)), ((u64)(0x68d56785fbbdd55aU)), ((u64)(0x690ac1677aad4ab1U)), ((u64)(0x6940b8e0acac4eafU)), ((u64)(0x6974e718d7d7625aU)), ((u64)(0x69aa20df0dcd3af1U)), ((u64)(0x69e0548b68a044d6U)), ((u64)(0x6a1469ae42c8560cU)), ((u64)(0x6a498419d37a6b8fU)), ((u64)(0x6a7fe52048590673U)), ((u64)(0x6ab3ef342d37a408U)), ((u64)(0x6ae8eb0138858d0aU)), ((u64)(0x6b1f25c186a6f04cU)), ((u64)(0x6b537798f4285630U)), ((u64)(0x6b88557f31326bbbU)), ((u64)(0x6bbe6adefd7f06aaU)), ((u64)(0x6bf302cb5e6f642aU)), ((u64)(0x6c27c37e360b3d35U)), ((u64)(0x6c5db45dc38e0c82U)), ((u64)(0x6c9290ba9a38c7d1U)), ((u64)(0x6cc734e940c6f9c6U)), ((u64)(0x6cfd022390f8b837U)), ((u64)(0x6d3221563a9b7323U)), ((u64)(0x6d66a9abc9424febU)), ((u64)(0x6d9c5416bb92e3e6U)), ((u64)(0x6dd1b48e353bce70U)), ((u64)(0x6e0621b1c28ac20cU)), ((u64)(0x6e3baa1e332d728fU)), ((u64)(0x6e714a52dffc6799U)), ((u64)(0x6ea59ce797fb817fU)), ((u64)(0x6edb04217dfa61dfU)), ((u64)(0x6f10e294eebc7d2cU)), ((u64)(0x6f451b3a2a6b9c76U)), ((u64)(0x6f7a6208b5068394U)), ((u64)(0x6fb07d457124123dU)), ((u64)(0x6fe49c96cd6d16ccU)), ((u64)(0x7019c3bc80c85c7fU)), ((u64)(0x70501a55d07d39cfU)), ((u64)(0x708420eb449c8843U)), ((u64)(0x70b9292615c3aa54U)), ((u64)(0x70ef736f9b3494e9U)), ((u64)(0x7123a825c100dd11U)), ((u64)(0x7158922f31411456U)), ((u64)(0x718eb6bafd91596bU)), ((u64)(0x71c33234de7ad7e3U)), ((u64)(0x71f7fec216198ddcU)), ((u64)(0x722dfe729b9ff153U)), ((u64)(0x7262bf07a143f6d4U)), ((u64)(0x72976ec98994f489U)), ((u64)(0x72cd4a7bebfa31abU)), ((u64)(0x73024e8d737c5f0bU)), ((u64)(0x7336e230d05b76cdU)), ((u64)(0x736c9abd04725481U)), ((u64)(0x73a1e0b622c774d0U)), ((u64)(0x73d658e3ab795204U)), ((u64)(0x740bef1c9657a686U)), ((u64)(0x74417571ddf6c814U)), ((u64)(0x7475d2ce55747a18U)), ((u64)(0x74ab4781ead1989eU)), ((u64)(0x74e10cb132c2ff63U)), ((u64)(0x75154fdd7f73bf3cU)), ((u64)(0x754aa3d4df50af0bU)), ((u64)(0x7580a6650b926d67U)), ((u64)(0x75b4cffe4e7708c0U)), ((u64)(0x75ea03fde214caf1U)), ((u64)(0x7620427ead4cfed6U)), ((u64)(0x7654531e58a03e8cU)), ((u64)(0x768967e5eec84e2fU)), ((u64)(0x76bfc1df6a7a61bbU)), ((u64)(0x76f3d92ba28c7d15U)), ((u64)(0x7728cf768b2f9c5aU)), ((u64)(0x775f03542dfb8370U)), ((u64)(0x779362149cbd3226U)), ((u64)(0x77c83a99c3ec7eb0U)), ((u64)(0x77fe494034e79e5cU)), ((u64)(0x7832edc82110c2f9U)), ((u64)(0x7867a93a2954f3b8U)), ((u64)(0x789d9388b3aa30a5U)), ((u64)(0x78d27c35704a5e67U)), ((u64)(0x79071b42cc5cf601U)), ((u64)(0x793ce2137f743382U)), ((u64)(0x79720d4c2fa8a031U)), ((u64)(0x79a6909f3b92c83dU)), ((u64)(0x79dc34c70a777a4dU)), ((u64)(0x7a11a0fc668aac70U)), ((u64)(0x7a46093b802d578cU)), ((u64)(0x7a7b8b8a6038ad6fU)), ((u64)(0x7ab137367c236c65U)), ((u64)(0x7ae585041b2c477fU)), ((u64)(0x7b1ae64521f7595eU)), ((u64)(0x7b50cfeb353a97dbU)), ((u64)(0x7b8503e602893dd2U)), ((u64)(0x7bba44df832b8d46U)), ((u64)(0x7bf06b0bb1fb384cU)), ((u64)(0x7c2485ce9e7a065fU)), ((u64)(0x7c59a742461887f6U)), ((u64)(0x7c9008896bcf54faU)), ((u64)(0x7cc40aabc6c32a38U)), ((u64)(0x7cf90d56b873f4c7U)), ((u64)(0x7d2f50ac6690f1f8U)), ((u64)(0x7d63926bc01a973bU)), ((u64)(0x7d987706b0213d0aU)), ((u64)(0x7dce94c85c298c4cU)), ((u64)(0x7e031cfd3999f7b0U)), ((u64)(0x7e37e43c8800759cU)), ((u64)(0x7e6ddd4baa009303U)), ((u64)(0x7ea2aa4f4a405be2U)), ((u64)(0x7ed754e31cd072daU)), ((u64)(0x7f0d2a1be4048f90U)), ((u64)(0x7f423a516e82d9baU)), ((u64)(0x7f76c8e5ca239029U)), ((u64)(0x7fac7b1f3cac7433U)), ((u64)(0x7fe1ccf385ebc8a0U))}));
	_const_strconv__neg_exp = new_array_from_c_array(324, 324, sizeof(u64), _MOV((u64[324]){
		((u64)(0x3ff0000000000000U)), ((u64)(0x3fb999999999999aU)), ((u64)(0x3f847ae147ae147bU)), ((u64)(0x3f50624dd2f1a9fcU)), ((u64)(0x3f1a36e2eb1c432dU)), ((u64)(0x3ee4f8b588e368f1U)), ((u64)(0x3eb0c6f7a0b5ed8dU)), ((u64)(0x3e7ad7f29abcaf48U)), ((u64)(0x3e45798ee2308c3aU)), ((u64)(0x3e112e0be826d695U)), ((u64)(0x3ddb7cdfd9d7bdbbU)), ((u64)(0x3da5fd7fe1796495U)), ((u64)(0x3d719799812dea11U)), ((u64)(0x3d3c25c268497682U)), ((u64)(0x3d06849b86a12b9bU)), ((u64)(0x3cd203af9ee75616U)), ((u64)(0x3c9cd2b297d889bcU)), ((u64)(0x3c670ef54646d497U)), ((u64)(0x3c32725dd1d243acU)), ((u64)(0x3bfd83c94fb6d2acU)), ((u64)(0x3bc79ca10c924223U)), ((u64)(0x3b92e3b40a0e9b4fU)), ((u64)(0x3b5e392010175ee6U)), ((u64)(0x3b282db34012b251U)), ((u64)(0x3af357c299a88ea7U)), ((u64)(0x3abef2d0f5da7dd9U)), ((u64)(0x3a88c240c4aecb14U)), ((u64)(0x3a53ce9a36f23c10U)), ((u64)(0x3a1fb0f6be506019U)), ((u64)(0x39e95a5efea6b347U)), ((u64)(0x39b4484bfeebc2a0U)), ((u64)(0x398039d665896880U)), ((u64)(0x3949f623d5a8a733U)), ((u64)(0x3914c4e977ba1f5cU)), ((u64)(0x38e09d8792fb4c49U)), ((u64)(0x38aa95a5b7f87a0fU)), ((u64)(0x38754484932d2e72U)), ((u64)(0x3841039d428a8b8fU)), ((u64)(0x380b38fb9daa78e4U)), ((u64)(0x37d5c72fb1552d83U)), ((u64)(0x37a16c262777579cU)), ((u64)(0x376be03d0bf225c7U)), ((u64)(0x37364cfda3281e39U)), ((u64)(0x3701d7314f534b61U)), ((u64)(0x36cc8b8218854567U)), ((u64)(0x3696d601ad376ab9U)), ((u64)(0x366244ce242c5561U)), ((u64)(0x362d3ae36d13bbceU)), ((u64)(0x35f7624f8a762fd8U)), ((u64)(0x35c2b50c6ec4f313U)), ((u64)(0x358dee7a4ad4b81fU)), ((u64)(0x3557f1fb6f10934cU)), ((u64)(0x352327fc58da0f70U)), ((u64)(0x34eea6608e29b24dU)), ((u64)(0x34b8851a0b548ea4U)), ((u64)(0x34839dae6f76d883U)), ((u64)(0x344f62b0b257c0d2U)), ((u64)(0x34191bc08eac9a41U)), ((u64)(0x33e41633a556e1ceU)), ((u64)(0x33b011c2eaabe7d8U)), ((u64)(0x3379b604aaaca626U)), ((u64)(0x3344919d5556eb52U)), ((u64)(0x3310747ddddf22a8U)), ((u64)(0x32da53fc9631d10dU)), ((u64)(0x32a50ffd44f4a73dU)), ((u64)(0x3270d9976a5d5297U)), ((u64)(0x323af5bf109550f2U)), ((u64)(0x32059165a6ddda5bU)), ((u64)(0x31d1411e1f17e1e3U)), ((u64)(0x319b9b6364f30304U)), ((u64)(0x316615e91d8f359dU)), ((u64)(0x3131ab20e472914aU)), ((u64)(0x30fc45016d841baaU)), ((u64)(0x30c69d9abe034955U)), ((u64)(0x309217aefe690777U)), ((u64)(0x305cf2b1970e7258U)), ((u64)(0x3027288e1271f513U)), ((u64)(0x2ff286d80ec190dcU)), ((u64)(0x2fbda48ce468e7c7U)), ((u64)(0x2f87b6d71d20b96cU)), ((u64)(0x2f52f8ac174d6123U)), ((u64)(0x2f1e5aacf2156838U)), ((u64)(0x2ee8488a5b445360U)), ((u64)(0x2eb36d3b7c36a91aU)), ((u64)(0x2e7f152bf9f10e90U)), ((u64)(0x2e48ddbcc7f40ba6U)), ((u64)(0x2e13e497065cd61fU)), ((u64)(0x2ddfd424d6faf031U)), ((u64)(0x2da97683df2f268dU)), ((u64)(0x2d745ecfe5bf520bU)), ((u64)(0x2d404bd984990e6fU)), ((u64)(0x2d0a12f5a0f4e3e5U)), ((u64)(0x2cd4dbf7b3f71cb7U)), ((u64)(0x2ca0aff95cc5b092U)), ((u64)(0x2c6ab328946f80eaU)), ((u64)(0x2c355c2076bf9a55U)), ((u64)(0x2c0116805effaeaaU)), ((u64)(0x2bcb5733cb32b111U)), ((u64)(0x2b95df5ca28ef40dU)), ((u64)(0x2b617f7d4ed8c33eU)), ((u64)(0x2b2bff2ee48e0530U)), ((u64)(0x2af665bf1d3e6a8dU)), ((u64)(0x2ac1eaff4a98553dU)), ((u64)(0x2a8cab3210f3bb95U)), ((u64)(0x2a56ef5b40c2fc77U)), ((u64)(0x2a225915cd68c9f9U)), ((u64)(0x29ed5b561574765bU)), ((u64)(0x29b77c44ddf6c516U)), ((u64)(0x2982c9d0b1923745U)), ((u64)(0x294e0fb44f50586eU)), ((u64)(0x29180c903f7379f2U)), ((u64)(0x28e33d4032c2c7f5U)), ((u64)(0x28aec866b79e0cbaU)), ((u64)(0x2878a0522c7e7095U)), ((u64)(0x2843b374f06526deU)), ((u64)(0x280f8587e7083e30U)), ((u64)(0x27d9379fec069826U)), ((u64)(0x27a42c7ff0054685U)), ((u64)(0x277023998cd10537U)), ((u64)(0x2739d28f47b4d525U)), ((u64)(0x2704a8729fc3ddb7U)), ((u64)(0x26d086c219697e2cU)), ((u64)(0x269a71368f0f3047U)), ((u64)(0x2665275ed8d8f36cU)), ((u64)(0x2630ec4be0ad8f89U)), ((u64)(0x25fb13ac9aaf4c0fU)), ((u64)(0x25c5a956e225d672U)), ((u64)(0x2591544581b7dec2U)), ((u64)(0x255bba08cf8c979dU)), ((u64)(0x25262e6d72d6dfb0U)), ((u64)(0x24f1bebdf578b2f4U)), ((u64)(0x24bc6463225ab7ecU)), ((u64)(0x2486b6b5b5155ff0U)), ((u64)(0x24522bc490dde65aU)), ((u64)(0x241d12d41afca3c3U)), ((u64)(0x23e7424348ca1c9cU)), ((u64)(0x23b29b69070816e3U)), ((u64)(0x237dc574d80cf16bU)), ((u64)(0x2347d12a4670c123U)), ((u64)(0x23130dbb6b8d674fU)), ((u64)(0x22de7c5f127bd87eU)), ((u64)(0x22a8637f41fcad32U)), ((u64)(0x227382cc34ca2428U)), ((u64)(0x223f37ad21436d0cU)), ((u64)(0x2208f9574dcf8a70U)), ((u64)(0x21d3faac3e3fa1f3U)), ((u64)(0x219ff779fd329cb9U)), ((u64)(0x216992c7fdc216faU)), ((u64)(0x2134756ccb01abfbU)), ((u64)(0x21005df0a267bcc9U)), ((u64)(0x20ca2fe76a3f9475U)), ((u64)(0x2094f31f8832dd2aU)), ((u64)(0x2060c27fa028b0efU)), ((u64)(0x202ad0cc33744e4bU)), ((u64)(0x1ff573d68f903ea2U)), ((u64)(0x1fc1297872d9cbb5U)), ((u64)(0x1f8b758d848fac55U)), ((u64)(0x1f55f7a46a0c89ddU)), ((u64)(0x1f2192e9ee706e4bU)), ((u64)(0x1eec1e43171a4a11U)), ((u64)(0x1eb67e9c127b6e74U)), ((u64)(0x1e81fee341fc585dU)), ((u64)(0x1e4ccb0536608d61U)), ((u64)(0x1e1708d0f84d3de7U)), ((u64)(0x1de26d73f9d764b9U)), ((u64)(0x1dad7becc2f23ac2U)), ((u64)(0x1d779657025b6235U)), ((u64)(0x1d42deac01e2b4f7U)), ((u64)(0x1d0e3113363787f2U)), ((u64)(0x1cd8274291c6065bU)), ((u64)(0x1ca3529ba7d19eafU)), ((u64)(0x1c6eea92a61c3118U)), ((u64)(0x1c38bba884e35a7aU)), ((u64)(0x1c03c9539d82aec8U)), ((u64)(0x1bcfa885c8d117a6U)), ((u64)(0x1b99539e3a40dfb8U)), ((u64)(0x1b6442e4fb671960U)), ((u64)(0x1b303583fc527ab3U)), ((u64)(0x1af9ef3993b72ab8U)), ((u64)(0x1ac4bf6142f8eefaU)), ((u64)(0x1a90991a9bfa58c8U)), ((u64)(0x1a5a8e90f9908e0dU)), ((u64)(0x1a253eda614071a4U)), ((u64)(0x19f0ff151a99f483U)), ((u64)(0x19bb31bb5dc320d2U)), ((u64)(0x1985c162b168e70eU)), ((u64)(0x1951678227871f3eU)), ((u64)(0x191bd8d03f3e9864U)), ((u64)(0x18e6470cff6546b6U)), ((u64)(0x18b1d270cc51055fU)), ((u64)(0x187c83e7ad4e6efeU)), ((u64)(0x1846cfec8aa52598U)), ((u64)(0x18123ff06eea847aU)), ((u64)(0x17dd331a4b10d3f6U)), ((u64)(0x17a75c1508da432bU)), ((u64)(0x1772b010d3e1cf56U)), ((u64)(0x173de6815302e556U)), ((u64)(0x1707eb9aa8cf1ddeU)), ((u64)(0x16d322e220a5b17eU)), ((u64)(0x169e9e369aa2b597U)), ((u64)(0x16687e92154ef7acU)), ((u64)(0x16339874ddd8c623U)), ((u64)(0x15ff5a549627a36cU)), ((u64)(0x15c91510781fb5f0U)), ((u64)(0x159410d9f9b2f7f3U)), ((u64)(0x15600d7b2e28c65cU)), ((u64)(0x1529af2b7d0e0a2dU)), ((u64)(0x14f48c22ca71a1bdU)), ((u64)(0x14c0701bd527b498U)), ((u64)(0x148a4cf9550c5426U)), ((u64)(0x14550a6110d6a9b8U)), ((u64)(0x1420d51a73deee2dU)), ((u64)(0x13eaee90b964b047U)), ((u64)(0x13b58ba6fab6f36cU)), ((u64)(0x13813c85955f2923U)), ((u64)(0x134b9408eefea839U)), ((u64)(0x1316100725988694U)), ((u64)(0x12e1a66c1e139eddU)), ((u64)(0x12ac3d79c9b8fe2eU)), ((u64)(0x12769794a160cb58U)), ((u64)(0x124212dd4de70913U)), ((u64)(0x120ceafbafd80e85U)), ((u64)(0x11d72262f3133ed1U)), ((u64)(0x11a281e8c275cbdaU)), ((u64)(0x116d9ca79d89462aU)), ((u64)(0x1137b08617a104eeU)), ((u64)(0x1102f39e794d9d8bU)), ((u64)(0x10ce5297287c2f45U)), ((u64)(0x1098421286c9bf6bU)), ((u64)(0x1063680ed23aff89U)), ((u64)(0x102f0ce4839198dbU)), ((u64)(0x0ff8d71d360e13e2U)), ((u64)(0x0fc3df4a91a4dcb5U)), ((u64)(0x0f8fcbaa82a16121U)), ((u64)(0x0f596fbb9bb44db4U)), ((u64)(0x0f245962e2f6a490U)), ((u64)(0x0ef047824f2bb6daU)), ((u64)(0x0eba0c03b1df8af6U)), ((u64)(0x0e84d6695b193bf8U)), ((u64)(0x0e50ab877c142ffaU)), ((u64)(0x0e1aac0bf9b9e65cU)), ((u64)(0x0de5566ffafb1eb0U)), ((u64)(0x0db111f32f2f4bc0U)), ((u64)(0x0d7b4feb7eb212cdU)), ((u64)(0x0d45d98932280f0aU)), ((u64)(0x0d117ad428200c08U)), ((u64)(0x0cdbf7b9d9cce00dU)), ((u64)(0x0ca65fc7e170b33eU)), ((u64)(0x0c71e6398126f5cbU)), ((u64)(0x0c3ca38f350b22dfU)), ((u64)(0x0c06e93f5da2824cU)), ((u64)(0x0bd25432b14ecea3U)), ((u64)(0x0b9d53844ee47dd1U)), ((u64)(0x0b677603725064a8U)), ((u64)(0x0b32c4cf8ea6b6ecU)), ((u64)(0x0afe07b27dd78b14U)), ((u64)(0x0ac8062864ac6f43U)), ((u64)(0x0a9338205089f29cU)), ((u64)(0x0a5ec033b40fea93U)), ((u64)(0x0a2899c2f6732210U)), ((u64)(0x09f3ae3591f5b4d9U)), ((u64)(0x09bf7d228322baf5U)), ((u64)(0x098930e868e89591U)), ((u64)(0x0954272053ed4474U)), ((u64)(0x09201f4d0ff10390U)), ((u64)(0x08e9cbae7fe805b3U)), ((u64)(0x08b4a2f1ffecd15cU)), ((u64)(0x0880825b3323dab0U)), ((u64)(0x084a6a2b85062ab3U)), ((u64)(0x081521bc6a6b555cU)), ((u64)(0x07e0e7c9eebc444aU)), ((u64)(0x07ab0c764ac6d3a9U)), ((u64)(0x0775a391d56bdc87U)), ((u64)(0x07414fa7ddefe3a0U)), ((u64)(0x070bb2a62fe638ffU)), ((u64)(0x06d62884f31e93ffU)), ((u64)(0x06a1ba03f5b21000U)), ((u64)(0x066c5cd322b67fffU)), ((u64)(0x0636b0a8e891ffffU)), ((u64)(0x060226ed86db3333U)), ((u64)(0x05cd0b15a491eb84U)), ((u64)(0x05973c115074bc6aU)), ((u64)(0x05629674405d6388U)), ((u64)(0x052dbd86cd6238d9U)), ((u64)(0x04f7cad23de82d7bU)), ((u64)(0x04c308a831868ac9U)), ((u64)(0x048e74404f3daadbU)), ((u64)(0x04585d003f6488afU)), ((u64)(0x04237d99cc506d59U)), ((u64)(0x03ef2f5c7a1a488eU)), ((u64)(0x03b8f2b061aea072U)), ((u64)(0x0383f559e7bee6c1U)), ((u64)(0x034feef63f97d79cU)), ((u64)(0x03198bf832dfdfb0U)), ((u64)(0x02e46ff9c24cb2f3U)), ((u64)(0x02b059949b708f29U)), ((u64)(0x027a28edc580e50eU)), ((u64)(0x0244ed8b04671da5U)), ((u64)(0x0210be08d0527e1dU)), ((u64)(0x01dac9a7b3b7302fU)), ((u64)(0x01a56e1fc2f8f359U)), ((u64)(0x017124e63593f5e1U)), ((u64)(0x013b6e3d22865634U)), ((u64)(0x0105f1ca820511c3U)), ((u64)(0x00d18e3b9b374169U)), ((u64)(0x009c16c5c5253575U)), ((u64)(0x0066789e3750f791U)), ((u64)(0x0031fa182c40c60dU)), ((u64)(0x000730d67819e8d2U)), ((u64)(0x0000b8157268fdafU)), ((u64)(0x000012688b70e62bU)), ((u64)(0x000001d74124e3d1U)), ((u64)(0x0000002f201d49fbU)), ((u64)(0x00000004b6695433U)), ((u64)(0x0000000078a42205U)), ((u64)(0x000000000c1069cdU)), ((u64)(0x000000000134d761U)), ((u64)(0x00000000001ee257U)), ((u64)(0x00000000000316a2U)), ((u64)(0x0000000000004f10U)), ((u64)(0x00000000000007e8U)), ((u64)(0x00000000000000caU)), ((u64)(0x0000000000000014U)), ((u64)(0x0000000000000002U))}));
	_const_strconv__max_u64 = ((u64)(UINT64_MAX));
	_const_strconv__ten_pow_table_32 = new_array_from_c_array(12, 12, sizeof(u32), _MOV((u32[12]){
		((u32)(1U)), ((u32)(10U)), ((u32)(100U)), ((u32)(1000U)), ((u32)(10000U)), ((u32)(100000U)), ((u32)(1000000U)), ((u32)(10000000U)), ((u32)(100000000U)), ((u32)(1000000000U)), ((u32)(10000000000U)), ((u32)(100000000000U))}));
	_const_strconv__mantbits32 = ((u32)(23U));
	_const_strconv__expbits32 = ((u32)(8U));
	_const_strconv__ten_pow_table_64 = new_array_from_c_array(20, 20, sizeof(u64), _MOV((u64[20]){
		((u64)(1U)), ((u64)(10U)), ((u64)(100U)), ((u64)(1000U)), ((u64)(10000U)), ((u64)(100000U)), ((u64)(1000000U)), ((u64)(10000000U)), ((u64)(100000000U)), ((u64)(1000000000U)), ((u64)(10000000000U)), ((u64)(100000000000U)), ((u64)(1000000000000U)), ((u64)(10000000000000U)), ((u64)(100000000000000U)), ((u64)(1000000000000000U)), ((u64)(10000000000000000U)), ((u64)(100000000000000000U)), ((u64)(1000000000000000000U)), ((u64)(10000000000000000000U))}));
	_const_strconv__mantbits64 = ((u32)(52U));
	_const_strconv__expbits64 = ((u32)(11U));
	_const_strconv__dec_round = new_array_from_c_array(20, 20, sizeof(f64), _MOV((f64[20]){
		((f64)(0.44)), 0.044, 0.0044, 0.00044, 0.000044, 0.0000044, 0.00000044, 0.000000044, 0.0000000044, 0.00000000044, 0.000000000044, 0.0000000000044, 0.00000000000044, 0.000000000000044, 0.0000000000000044, 0.00000000000000044, 0.000000000000000044, 0.0000000000000000044, 0.00000000000000000044, 0.000000000000000000044}));
	_const_strconv__powers_of_10 = new_array_from_c_array(18, 18, sizeof(u64), _MOV((u64[18]){
		((u64)(1e0)), ((u64)(1e1)), ((u64)(1e2)), ((u64)(1e3)), ((u64)(1e4)), ((u64)(1e5)), ((u64)(1e6)), ((u64)(1e7)), ((u64)(1e8)), ((u64)(1e9)), ((u64)(1e10)), ((u64)(1e11)), ((u64)(1e12)), ((u64)(1e13)), ((u64)(1e14)), ((u64)(1e15)), ((u64)(1e16)), ((u64)(1e17))}));
	_const_strconv__pow5_split_32 = new_array_from_c_array(47, 47, sizeof(u64), _MOV((u64[47]){
		((u64)(1152921504606846976U)), ((u64)(1441151880758558720U)), ((u64)(1801439850948198400U)), ((u64)(2251799813685248000U)), ((u64)(1407374883553280000U)), ((u64)(1759218604441600000U)), ((u64)(2199023255552000000U)), ((u64)(1374389534720000000U)), ((u64)(1717986918400000000U)), ((u64)(2147483648000000000U)), ((u64)(1342177280000000000U)), ((u64)(1677721600000000000U)), ((u64)(2097152000000000000U)), ((u64)(1310720000000000000U)), ((u64)(1638400000000000000U)), ((u64)(2048000000000000000U)), ((u64)(1280000000000000000U)), ((u64)(1600000000000000000U)), ((u64)(2000000000000000000U)), ((u64)(1250000000000000000U)), ((u64)(1562500000000000000U)), ((u64)(1953125000000000000U)), ((u64)(1220703125000000000U)), ((u64)(1525878906250000000U)), ((u64)(1907348632812500000U)), ((u64)(1192092895507812500U)), ((u64)(1490116119384765625U)), ((u64)(1862645149230957031U)), ((u64)(1164153218269348144U)), ((u64)(1455191522836685180U)), ((u64)(1818989403545856475U)), ((u64)(2273736754432320594U)), ((u64)(1421085471520200371U)), ((u64)(1776356839400250464U)), ((u64)(2220446049250313080U)), ((u64)(1387778780781445675U)), ((u64)(1734723475976807094U)), ((u64)(2168404344971008868U)), ((u64)(1355252715606880542U)), ((u64)(1694065894508600678U)), ((u64)(2117582368135750847U)), ((u64)(1323488980084844279U)), ((u64)(1654361225106055349U)), ((u64)(2067951531382569187U)), ((u64)(1292469707114105741U)), ((u64)(1615587133892632177U)), ((u64)(2019483917365790221U))}));
	_const_strconv__pow5_inv_split_32 = new_array_from_c_array(31, 31, sizeof(u64), _MOV((u64[31]){
		((u64)(576460752303423489U)), ((u64)(461168601842738791U)), ((u64)(368934881474191033U)), ((u64)(295147905179352826U)), ((u64)(472236648286964522U)), ((u64)(377789318629571618U)), ((u64)(302231454903657294U)), ((u64)(483570327845851670U)), ((u64)(386856262276681336U)), ((u64)(309485009821345069U)), ((u64)(495176015714152110U)), ((u64)(396140812571321688U)), ((u64)(316912650057057351U)), ((u64)(507060240091291761U)), ((u64)(405648192073033409U)), ((u64)(324518553658426727U)), ((u64)(519229685853482763U)), ((u64)(415383748682786211U)), ((u64)(332306998946228969U)), ((u64)(531691198313966350U)), ((u64)(425352958651173080U)), ((u64)(340282366920938464U)), ((u64)(544451787073501542U)), ((u64)(435561429658801234U)), ((u64)(348449143727040987U)), ((u64)(557518629963265579U)), ((u64)(446014903970612463U)), ((u64)(356811923176489971U)), ((u64)(570899077082383953U)), ((u64)(456719261665907162U)), ((u64)(365375409332725730U))}));
	_const_strconv__pow5_split_64 = new_array_from_c_array(326, 326, sizeof(strconv__Uint128), _MOV((strconv__Uint128[326]){
		(strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x0100000000000000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x0140000000000000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x0190000000000000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x01f4000000000000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x0138800000000000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x0186a00000000000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x01e8480000000000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x01312d0000000000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x017d784000000000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x01dcd65000000000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x012a05f200000000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x0174876e80000000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x01d1a94a20000000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x012309ce54000000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x016bcc41e9000000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x01c6bf5263400000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x011c37937e080000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x016345785d8a0000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x01bc16d674ec8000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x01158e460913d000U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x015af1d78b58c400U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x01b1ae4d6e2ef500U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x010f0cf064dd5920U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x0152d02c7e14af68U)),}, (strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x01a784379d99db42U)),}, (strconv__Uint128){.lo = ((u64)(0x4000000000000000U)),.hi = ((u64)(0x0108b2a2c2802909U)),}, (strconv__Uint128){.lo = ((u64)(0x9000000000000000U)),.hi = ((u64)(0x014adf4b7320334bU)),}, (strconv__Uint128){.lo = ((u64)(0x7400000000000000U)),.hi = ((u64)(0x019d971e4fe8401eU)),}, (strconv__Uint128){.lo = ((u64)(0x0880000000000000U)),.hi = ((u64)(0x01027e72f1f12813U)),}, (strconv__Uint128){.lo = ((u64)(0xcaa0000000000000U)),.hi = ((u64)(0x01431e0fae6d7217U)),}, (strconv__Uint128){.lo = ((u64)(0xbd48000000000000U)),.hi = ((u64)(0x0193e5939a08ce9dU)),}, (strconv__Uint128){.lo = ((u64)(0x2c9a000000000000U)),.hi = ((u64)(0x01f8def8808b0245U)),}, (strconv__Uint128){.lo = ((u64)(0x3be0400000000000U)),.hi = ((u64)(0x013b8b5b5056e16bU)),}, (strconv__Uint128){.lo = ((u64)(0x0ad8500000000000U)),.hi = ((u64)(0x018a6e32246c99c6U)),}, (strconv__Uint128){.lo = ((u64)(0x8d8e640000000000U)),.hi = ((u64)(0x01ed09bead87c037U)),}, (strconv__Uint128){.lo = ((u64)(0xb878fe8000000000U)),.hi = ((u64)(0x013426172c74d822U)),}, (strconv__Uint128){.lo = ((u64)(0x66973e2000000000U)),.hi = ((u64)(0x01812f9cf7920e2bU)),}, (strconv__Uint128){.lo = ((u64)(0x403d0da800000000U)),.hi = ((u64)(0x01e17b84357691b6U)),}, (strconv__Uint128){.lo = ((u64)(0xe826288900000000U)),.hi = ((u64)(0x012ced32a16a1b11U)),}, (strconv__Uint128){.lo = ((u64)(0x622fb2ab40000000U)),.hi = ((u64)(0x0178287f49c4a1d6U)),}, (strconv__Uint128){.lo = ((u64)(0xfabb9f5610000000U)),.hi = ((u64)(0x01d6329f1c35ca4bU)),}, (strconv__Uint128){.lo = ((u64)(0x7cb54395ca000000U)),.hi = ((u64)(0x0125dfa371a19e6fU)),}, (strconv__Uint128){.lo = ((u64)(0x5be2947b3c800000U)),.hi = ((u64)(0x016f578c4e0a060bU)),}, (strconv__Uint128){.lo = ((u64)(0x32db399a0ba00000U)),.hi = ((u64)(0x01cb2d6f618c878eU)),}, (strconv__Uint128){.lo = ((u64)(0xdfc9040047440000U)),.hi = ((u64)(0x011efc659cf7d4b8U)),}, (strconv__Uint128){.lo = ((u64)(0x17bb450059150000U)),.hi = ((u64)(0x0166bb7f0435c9e7U)),}, (strconv__Uint128){.lo = ((u64)(0xddaa16406f5a4000U)),.hi = ((u64)(0x01c06a5ec5433c60U)),}, (strconv__Uint128){.lo = ((u64)(0x8a8a4de845986800U)),.hi = ((u64)(0x0118427b3b4a05bcU)),}, (strconv__Uint128){.lo = ((u64)(0xad2ce16256fe8200U)),.hi = ((u64)(0x015e531a0a1c872bU)),}, (strconv__Uint128){.lo = ((u64)(0x987819baecbe2280U)),.hi = ((u64)(0x01b5e7e08ca3a8f6U)),}, (strconv__Uint128){.lo = ((u64)(0x1f4b1014d3f6d590U)),.hi = ((u64)(0x0111b0ec57e6499aU)),}, (strconv__Uint128){.lo = ((u64)(0xa71dd41a08f48af4U)),.hi = ((u64)(0x01561d276ddfdc00U)),}, (strconv__Uint128){.lo = ((u64)(0xd0e549208b31adb1U)),.hi = ((u64)(0x01aba4714957d300U)),}, (strconv__Uint128){.lo = ((u64)(0x828f4db456ff0c8eU)),.hi = ((u64)(0x010b46c6cdd6e3e0U)),}, (strconv__Uint128){.lo = ((u64)(0xa33321216cbecfb2U)),.hi = ((u64)(0x014e1878814c9cd8U)),}, (strconv__Uint128){.lo = ((u64)(0xcbffe969c7ee839eU)),.hi = ((u64)(0x01a19e96a19fc40eU)),}, (strconv__Uint128){.lo = ((u64)(0x3f7ff1e21cf51243U)),.hi = ((u64)(0x0105031e2503da89U)),}, (strconv__Uint128){.lo = ((u64)(0x8f5fee5aa43256d4U)),.hi = ((u64)(0x014643e5ae44d12bU)),}, (strconv__Uint128){.lo = ((u64)(0x7337e9f14d3eec89U)),.hi = ((u64)(0x0197d4df19d60576U)),}, (strconv__Uint128){.lo = ((u64)(0x1005e46da08ea7abU)),.hi = ((u64)(0x01fdca16e04b86d4U)),}, (strconv__Uint128){.lo = ((u64)(0x8a03aec4845928cbU)),.hi = ((u64)(0x013e9e4e4c2f3444U)),}, (strconv__Uint128){.lo = ((u64)(0xac849a75a56f72fdU)),.hi = ((u64)(0x018e45e1df3b0155U)),}, (strconv__Uint128){.lo = ((u64)(0x17a5c1130ecb4fbdU)),.hi = ((u64)(0x01f1d75a5709c1abU)),}, (strconv__Uint128){.lo = ((u64)(0xeec798abe93f11d6U)),.hi = ((u64)(0x013726987666190aU)),}, (strconv__Uint128){.lo = ((u64)(0xaa797ed6e38ed64bU)),.hi = ((u64)(0x0184f03e93ff9f4dU)),}, (strconv__Uint128){.lo = ((u64)(0x1517de8c9c728bdeU)),.hi = ((u64)(0x01e62c4e38ff8721U)),}, (strconv__Uint128){.lo = ((u64)(0xad2eeb17e1c7976bU)),.hi = ((u64)(0x012fdbb0e39fb474U)),}, (strconv__Uint128){.lo = ((u64)(0xd87aa5ddda397d46U)),.hi = ((u64)(0x017bd29d1c87a191U)),}, (strconv__Uint128){.lo = ((u64)(0x4e994f5550c7dc97U)),.hi = ((u64)(0x01dac74463a989f6U)),}, (strconv__Uint128){.lo = ((u64)(0xf11fd195527ce9deU)),.hi = ((u64)(0x0128bc8abe49f639U)),}, (strconv__Uint128){.lo = ((u64)(0x6d67c5faa71c2456U)),.hi = ((u64)(0x0172ebad6ddc73c8U)),}, (strconv__Uint128){.lo = ((u64)(0x88c1b77950e32d6cU)),.hi = ((u64)(0x01cfa698c95390baU)),}, (strconv__Uint128){.lo = ((u64)(0x957912abd28dfc63U)),.hi = ((u64)(0x0121c81f7dd43a74U)),}, (strconv__Uint128){.lo = ((u64)(0xbad75756c7317b7cU)),.hi = ((u64)(0x016a3a275d494911U)),}, (strconv__Uint128){.lo = ((u64)(0x298d2d2c78fdda5bU)),.hi = ((u64)(0x01c4c8b1349b9b56U)),}, (strconv__Uint128){.lo = ((u64)(0xd9f83c3bcb9ea879U)),.hi = ((u64)(0x011afd6ec0e14115U)),}, (strconv__Uint128){.lo = ((u64)(0x50764b4abe865297U)),.hi = ((u64)(0x0161bcca7119915bU)),}, (strconv__Uint128){.lo = ((u64)(0x2493de1d6e27e73dU)),.hi = ((u64)(0x01ba2bfd0d5ff5b2U)),}, (strconv__Uint128){.lo = ((u64)(0x56dc6ad264d8f086U)),.hi = ((u64)(0x01145b7e285bf98fU)),}, (strconv__Uint128){.lo = ((u64)(0x2c938586fe0f2ca8U)),.hi = ((u64)(0x0159725db272f7f3U)),}, (strconv__Uint128){.lo = ((u64)(0xf7b866e8bd92f7d2U)),.hi = ((u64)(0x01afcef51f0fb5efU)),}, (strconv__Uint128){.lo = ((u64)(0xfad34051767bdae3U)),.hi = ((u64)(0x010de1593369d1b5U)),}, (strconv__Uint128){.lo = ((u64)(0x79881065d41ad19cU)),.hi = ((u64)(0x015159af80444623U)),}, (strconv__Uint128){.lo = ((u64)(0x57ea147f49218603U)),.hi = ((u64)(0x01a5b01b605557acU)),}, (strconv__Uint128){.lo = ((u64)(0xb6f24ccf8db4f3c1U)),.hi = ((u64)(0x01078e111c3556cbU)),}, (strconv__Uint128){.lo = ((u64)(0xa4aee003712230b2U)),.hi = ((u64)(0x014971956342ac7eU)),}, (strconv__Uint128){.lo = ((u64)(0x4dda98044d6abcdfU)),.hi = ((u64)(0x019bcdfabc13579eU)),}, (strconv__Uint128){.lo = ((u64)(0xf0a89f02b062b60bU)),.hi = ((u64)(0x010160bcb58c16c2U)),}, (strconv__Uint128){.lo = ((u64)(0xacd2c6c35c7b638eU)),.hi = ((u64)(0x0141b8ebe2ef1c73U)),}, (strconv__Uint128){.lo = ((u64)(0x98077874339a3c71U)),.hi = ((u64)(0x01922726dbaae390U)),}, (strconv__Uint128){.lo = ((u64)(0xbe0956914080cb8eU)),.hi = ((u64)(0x01f6b0f092959c74U)),}, (strconv__Uint128){.lo = ((u64)(0xf6c5d61ac8507f38U)),.hi = ((u64)(0x013a2e965b9d81c8U)),}, (strconv__Uint128){.lo = ((u64)(0x34774ba17a649f07U)),.hi = ((u64)(0x0188ba3bf284e23bU)),}, (strconv__Uint128){.lo = ((u64)(0x01951e89d8fdc6c8U)),.hi = ((u64)(0x01eae8caef261acaU)),}, (strconv__Uint128){.lo = ((u64)(0x40fd3316279e9c3dU)),.hi = ((u64)(0x0132d17ed577d0beU)),}, (strconv__Uint128){.lo = ((u64)(0xd13c7fdbb186434cU)),.hi = ((u64)(0x017f85de8ad5c4edU)),}, (strconv__Uint128){.lo = ((u64)(0x458b9fd29de7d420U)),.hi = ((u64)(0x01df67562d8b3629U)),}, (strconv__Uint128){.lo = ((u64)(0xcb7743e3a2b0e494U)),.hi = ((u64)(0x012ba095dc7701d9U)),}, (strconv__Uint128){.lo = ((u64)(0x3e5514dc8b5d1db9U)),.hi = ((u64)(0x017688bb5394c250U)),}, (strconv__Uint128){.lo = ((u64)(0x4dea5a13ae346527U)),.hi = ((u64)(0x01d42aea2879f2e4U)),}, (strconv__Uint128){.lo = ((u64)(0xb0b2784c4ce0bf38U)),.hi = ((u64)(0x01249ad2594c37ceU)),}, (strconv__Uint128){.lo = ((u64)(0x5cdf165f6018ef06U)),.hi = ((u64)(0x016dc186ef9f45c2U)),}, (strconv__Uint128){.lo = ((u64)(0xf416dbf7381f2ac8U)),.hi = ((u64)(0x01c931e8ab871732U)),}, (strconv__Uint128){.lo = ((u64)(0xd88e497a83137abdU)),.hi = ((u64)(0x011dbf316b346e7fU)),}, (strconv__Uint128){.lo = ((u64)(0xceb1dbd923d8596cU)),.hi = ((u64)(0x01652efdc6018a1fU)),}, (strconv__Uint128){.lo = ((u64)(0xc25e52cf6cce6fc7U)),.hi = ((u64)(0x01be7abd3781eca7U)),}, (strconv__Uint128){.lo = ((u64)(0xd97af3c1a40105dcU)),.hi = ((u64)(0x01170cb642b133e8U)),}, (strconv__Uint128){.lo = ((u64)(0x0fd9b0b20d014754U)),.hi = ((u64)(0x015ccfe3d35d80e3U)),}, (strconv__Uint128){.lo = ((u64)(0xd3d01cde90419929U)),.hi = ((u64)(0x01b403dcc834e11bU)),}, (strconv__Uint128){.lo = ((u64)(0x6462120b1a28ffb9U)),.hi = ((u64)(0x01108269fd210cb1U)),}, (strconv__Uint128){.lo = ((u64)(0xbd7a968de0b33fa8U)),.hi = ((u64)(0x0154a3047c694fddU)),}, (strconv__Uint128){.lo = ((u64)(0x2cd93c3158e00f92U)),.hi = ((u64)(0x01a9cbc59b83a3d5U)),}, (strconv__Uint128){.lo = ((u64)(0x3c07c59ed78c09bbU)),.hi = ((u64)(0x010a1f5b81324665U)),}, (strconv__Uint128){.lo = ((u64)(0x8b09b7068d6f0c2aU)),.hi = ((u64)(0x014ca732617ed7feU)),}, (strconv__Uint128){.lo = ((u64)(0x2dcc24c830cacf34U)),.hi = ((u64)(0x019fd0fef9de8dfeU)),}, (strconv__Uint128){.lo = ((u64)(0xdc9f96fd1e7ec180U)),.hi = ((u64)(0x0103e29f5c2b18beU)),}, (strconv__Uint128){.lo = ((u64)(0x93c77cbc661e71e1U)),.hi = ((u64)(0x0144db473335deeeU)),}, (strconv__Uint128){.lo = ((u64)(0x38b95beb7fa60e59U)),.hi = ((u64)(0x01961219000356aaU)),}, (strconv__Uint128){.lo = ((u64)(0xc6e7b2e65f8f91efU)),.hi = ((u64)(0x01fb969f40042c54U)),}, (strconv__Uint128){.lo = ((u64)(0xfc50cfcffbb9bb35U)),.hi = ((u64)(0x013d3e2388029bb4U)),}, (strconv__Uint128){.lo = ((u64)(0x3b6503c3faa82a03U)),.hi = ((u64)(0x018c8dac6a0342a2U)),}, (strconv__Uint128){.lo = ((u64)(0xca3e44b4f9523484U)),.hi = ((u64)(0x01efb1178484134aU)),}, (strconv__Uint128){.lo = ((u64)(0xbe66eaf11bd360d2U)),.hi = ((u64)(0x0135ceaeb2d28c0eU)),}, (strconv__Uint128){.lo = ((u64)(0x6e00a5ad62c83907U)),.hi = ((u64)(0x0183425a5f872f12U)),}, (strconv__Uint128){.lo = ((u64)(0x0980cf18bb7a4749U)),.hi = ((u64)(0x01e412f0f768fad7U)),}, (strconv__Uint128){.lo = ((u64)(0x65f0816f752c6c8dU)),.hi = ((u64)(0x012e8bd69aa19cc6U)),}, (strconv__Uint128){.lo = ((u64)(0xff6ca1cb527787b1U)),.hi = ((u64)(0x017a2ecc414a03f7U)),}, (strconv__Uint128){.lo = ((u64)(0xff47ca3e2715699dU)),.hi = ((u64)(0x01d8ba7f519c84f5U)),}, (strconv__Uint128){.lo = ((u64)(0xbf8cde66d86d6202U)),.hi = ((u64)(0x0127748f9301d319U)),}, (strconv__Uint128){.lo = ((u64)(0x2f7016008e88ba83U)),.hi = ((u64)(0x017151b377c247e0U)),}, (strconv__Uint128){.lo = ((u64)(0x3b4c1b80b22ae923U)),.hi = ((u64)(0x01cda62055b2d9d8U)),}, (strconv__Uint128){.lo = ((u64)(0x250f91306f5ad1b6U)),.hi = ((u64)(0x012087d4358fc827U)),}, (strconv__Uint128){.lo = ((u64)(0xee53757c8b318623U)),.hi = ((u64)(0x0168a9c942f3ba30U)),}, (strconv__Uint128){.lo = ((u64)(0x29e852dbadfde7acU)),.hi = ((u64)(0x01c2d43b93b0a8bdU)),}, (strconv__Uint128){.lo = ((u64)(0x3a3133c94cbeb0ccU)),.hi = ((u64)(0x0119c4a53c4e6976U)),}, (strconv__Uint128){.lo = ((u64)(0xc8bd80bb9fee5cffU)),.hi = ((u64)(0x016035ce8b6203d3U)),}, (strconv__Uint128){.lo = ((u64)(0xbaece0ea87e9f43eU)),.hi = ((u64)(0x01b843422e3a84c8U)),}, (strconv__Uint128){.lo = ((u64)(0x74d40c9294f238a7U)),.hi = ((u64)(0x01132a095ce492fdU)),}, (strconv__Uint128){.lo = ((u64)(0xd2090fb73a2ec6d1U)),.hi = ((u64)(0x0157f48bb41db7bcU)),}, (strconv__Uint128){.lo = ((u64)(0x068b53a508ba7885U)),.hi = ((u64)(0x01adf1aea12525acU)),}, (strconv__Uint128){.lo = ((u64)(0x8417144725748b53U)),.hi = ((u64)(0x010cb70d24b7378bU)),}, (strconv__Uint128){.lo = ((u64)(0x651cd958eed1ae28U)),.hi = ((u64)(0x014fe4d06de5056eU)),}, (strconv__Uint128){.lo = ((u64)(0xfe640faf2a8619b2U)),.hi = ((u64)(0x01a3de04895e46c9U)),}, (strconv__Uint128){.lo = ((u64)(0x3efe89cd7a93d00fU)),.hi = ((u64)(0x01066ac2d5daec3eU)),}, (strconv__Uint128){.lo = ((u64)(0xcebe2c40d938c413U)),.hi = ((u64)(0x014805738b51a74dU)),}, (strconv__Uint128){.lo = ((u64)(0x426db7510f86f518U)),.hi = ((u64)(0x019a06d06e261121U)),}, (strconv__Uint128){.lo = ((u64)(0xc9849292a9b4592fU)),.hi = ((u64)(0x0100444244d7cab4U)),}, (strconv__Uint128){.lo = ((u64)(0xfbe5b73754216f7aU)),.hi = ((u64)(0x01405552d60dbd61U)),}, (strconv__Uint128){.lo = ((u64)(0x7adf25052929cb59U)),.hi = ((u64)(0x01906aa78b912cbaU)),}, (strconv__Uint128){.lo = ((u64)(0x1996ee4673743e2fU)),.hi = ((u64)(0x01f485516e7577e9U)),}, (strconv__Uint128){.lo = ((u64)(0xaffe54ec0828a6ddU)),.hi = ((u64)(0x0138d352e5096af1U)),}, (strconv__Uint128){.lo = ((u64)(0x1bfdea270a32d095U)),.hi = ((u64)(0x018708279e4bc5aeU)),}, (strconv__Uint128){.lo = ((u64)(0xa2fd64b0ccbf84baU)),.hi = ((u64)(0x01e8ca3185deb719U)),}, (strconv__Uint128){.lo = ((u64)(0x05de5eee7ff7b2f4U)),.hi = ((u64)(0x01317e5ef3ab3270U)),}, (strconv__Uint128){.lo = ((u64)(0x0755f6aa1ff59fb1U)),.hi = ((u64)(0x017dddf6b095ff0cU)),}, (strconv__Uint128){.lo = ((u64)(0x092b7454a7f3079eU)),.hi = ((u64)(0x01dd55745cbb7ecfU)),}, (strconv__Uint128){.lo = ((u64)(0x65bb28b4e8f7e4c3U)),.hi = ((u64)(0x012a5568b9f52f41U)),}, (strconv__Uint128){.lo = ((u64)(0xbf29f2e22335ddf3U)),.hi = ((u64)(0x0174eac2e8727b11U)),}, (strconv__Uint128){.lo = ((u64)(0x2ef46f9aac035570U)),.hi = ((u64)(0x01d22573a28f19d6U)),}, (strconv__Uint128){.lo = ((u64)(0xdd58c5c0ab821566U)),.hi = ((u64)(0x0123576845997025U)),}, (strconv__Uint128){.lo = ((u64)(0x54aef730d6629ac0U)),.hi = ((u64)(0x016c2d4256ffcc2fU)),}, (strconv__Uint128){.lo = ((u64)(0x29dab4fd0bfb4170U)),.hi = ((u64)(0x01c73892ecbfbf3bU)),}, (strconv__Uint128){.lo = ((u64)(0xfa28b11e277d08e6U)),.hi = ((u64)(0x011c835bd3f7d784U)),}, (strconv__Uint128){.lo = ((u64)(0x38b2dd65b15c4b1fU)),.hi = ((u64)(0x0163a432c8f5cd66U)),}, (strconv__Uint128){.lo = ((u64)(0xc6df94bf1db35de7U)),.hi = ((u64)(0x01bc8d3f7b3340bfU)),}, (strconv__Uint128){.lo = ((u64)(0xdc4bbcf772901ab0U)),.hi = ((u64)(0x0115d847ad000877U)),}, (strconv__Uint128){.lo = ((u64)(0xd35eac354f34215cU)),.hi = ((u64)(0x015b4e5998400a95U)),}, (strconv__Uint128){.lo = ((u64)(0x48365742a30129b4U)),.hi = ((u64)(0x01b221effe500d3bU)),}, (strconv__Uint128){.lo = ((u64)(0x0d21f689a5e0ba10U)),.hi = ((u64)(0x010f5535fef20845U)),}, (strconv__Uint128){.lo = ((u64)(0x506a742c0f58e894U)),.hi = ((u64)(0x01532a837eae8a56U)),}, (strconv__Uint128){.lo = ((u64)(0xe4851137132f22b9U)),.hi = ((u64)(0x01a7f5245e5a2cebU)),}, (strconv__Uint128){.lo = ((u64)(0x6ed32ac26bfd75b4U)),.hi = ((u64)(0x0108f936baf85c13U)),}, (strconv__Uint128){.lo = ((u64)(0x4a87f57306fcd321U)),.hi = ((u64)(0x014b378469b67318U)),}, (strconv__Uint128){.lo = ((u64)(0x5d29f2cfc8bc07e9U)),.hi = ((u64)(0x019e056584240fdeU)),}, (strconv__Uint128){.lo = ((u64)(0xfa3a37c1dd7584f1U)),.hi = ((u64)(0x0102c35f729689eaU)),}, (strconv__Uint128){.lo = ((u64)(0xb8c8c5b254d2e62eU)),.hi = ((u64)(0x014374374f3c2c65U)),}, (strconv__Uint128){.lo = ((u64)(0x26faf71eea079fb9U)),.hi = ((u64)(0x01945145230b377fU)),}, (strconv__Uint128){.lo = ((u64)(0xf0b9b4e6a48987a8U)),.hi = ((u64)(0x01f965966bce055eU)),}, (strconv__Uint128){.lo = ((u64)(0x5674111026d5f4c9U)),.hi = ((u64)(0x013bdf7e0360c35bU)),}, (strconv__Uint128){.lo = ((u64)(0x2c111554308b71fbU)),.hi = ((u64)(0x018ad75d8438f432U)),}, (strconv__Uint128){.lo = ((u64)(0xb7155aa93cae4e7aU)),.hi = ((u64)(0x01ed8d34e547313eU)),}, (strconv__Uint128){.lo = ((u64)(0x326d58a9c5ecf10cU)),.hi = ((u64)(0x013478410f4c7ec7U)),}, (strconv__Uint128){.lo = ((u64)(0xff08aed437682d4fU)),.hi = ((u64)(0x01819651531f9e78U)),}, (strconv__Uint128){.lo = ((u64)(0x3ecada89454238a3U)),.hi = ((u64)(0x01e1fbe5a7e78617U)),}, (strconv__Uint128){.lo = ((u64)(0x873ec895cb496366U)),.hi = ((u64)(0x012d3d6f88f0b3ceU)),}, (strconv__Uint128){.lo = ((u64)(0x290e7abb3e1bbc3fU)),.hi = ((u64)(0x01788ccb6b2ce0c2U)),}, (strconv__Uint128){.lo = ((u64)(0xb352196a0da2ab4fU)),.hi = ((u64)(0x01d6affe45f818f2U)),}, (strconv__Uint128){.lo = ((u64)(0xb0134fe24885ab11U)),.hi = ((u64)(0x01262dfeebbb0f97U)),}, (strconv__Uint128){.lo = ((u64)(0x9c1823dadaa715d6U)),.hi = ((u64)(0x016fb97ea6a9d37dU)),}, (strconv__Uint128){.lo = ((u64)(0x031e2cd19150db4bU)),.hi = ((u64)(0x01cba7de5054485dU)),}, (strconv__Uint128){.lo = ((u64)(0x21f2dc02fad2890fU)),.hi = ((u64)(0x011f48eaf234ad3aU)),}, (strconv__Uint128){.lo = ((u64)(0xaa6f9303b9872b53U)),.hi = ((u64)(0x01671b25aec1d888U)),}, (strconv__Uint128){.lo = ((u64)(0xd50b77c4a7e8f628U)),.hi = ((u64)(0x01c0e1ef1a724eaaU)),}, (strconv__Uint128){.lo = ((u64)(0xc5272adae8f199d9U)),.hi = ((u64)(0x01188d357087712aU)),}, (strconv__Uint128){.lo = ((u64)(0x7670f591a32e004fU)),.hi = ((u64)(0x015eb082cca94d75U)),}, (strconv__Uint128){.lo = ((u64)(0xd40d32f60bf98063U)),.hi = ((u64)(0x01b65ca37fd3a0d2U)),}, (strconv__Uint128){.lo = ((u64)(0xc4883fd9c77bf03eU)),.hi = ((u64)(0x0111f9e62fe44483U)),}, (strconv__Uint128){.lo = ((u64)(0xb5aa4fd0395aec4dU)),.hi = ((u64)(0x0156785fbbdd55a4U)),}, (strconv__Uint128){.lo = ((u64)(0xe314e3c447b1a760U)),.hi = ((u64)(0x01ac1677aad4ab0dU)),}, (strconv__Uint128){.lo = ((u64)(0xaded0e5aaccf089cU)),.hi = ((u64)(0x010b8e0acac4eae8U)),}, (strconv__Uint128){.lo = ((u64)(0xd96851f15802cac3U)),.hi = ((u64)(0x014e718d7d7625a2U)),}, (strconv__Uint128){.lo = ((u64)(0x8fc2666dae037d74U)),.hi = ((u64)(0x01a20df0dcd3af0bU)),}, (strconv__Uint128){.lo = ((u64)(0x39d980048cc22e68U)),.hi = ((u64)(0x010548b68a044d67U)),}, (strconv__Uint128){.lo = ((u64)(0x084fe005aff2ba03U)),.hi = ((u64)(0x01469ae42c8560c1U)),}, (strconv__Uint128){.lo = ((u64)(0x4a63d8071bef6883U)),.hi = ((u64)(0x0198419d37a6b8f1U)),}, (strconv__Uint128){.lo = ((u64)(0x9cfcce08e2eb42a4U)),.hi = ((u64)(0x01fe52048590672dU)),}, (strconv__Uint128){.lo = ((u64)(0x821e00c58dd309a7U)),.hi = ((u64)(0x013ef342d37a407cU)),}, (strconv__Uint128){.lo = ((u64)(0xa2a580f6f147cc10U)),.hi = ((u64)(0x018eb0138858d09bU)),}, (strconv__Uint128){.lo = ((u64)(0x8b4ee134ad99bf15U)),.hi = ((u64)(0x01f25c186a6f04c2U)),}, (strconv__Uint128){.lo = ((u64)(0x97114cc0ec80176dU)),.hi = ((u64)(0x0137798f428562f9U)),}, (strconv__Uint128){.lo = ((u64)(0xfcd59ff127a01d48U)),.hi = ((u64)(0x018557f31326bbb7U)),}, (strconv__Uint128){.lo = ((u64)(0xfc0b07ed7188249aU)),.hi = ((u64)(0x01e6adefd7f06aa5U)),}, (strconv__Uint128){.lo = ((u64)(0xbd86e4f466f516e0U)),.hi = ((u64)(0x01302cb5e6f642a7U)),}, (strconv__Uint128){.lo = ((u64)(0xace89e3180b25c98U)),.hi = ((u64)(0x017c37e360b3d351U)),}, (strconv__Uint128){.lo = ((u64)(0x1822c5bde0def3beU)),.hi = ((u64)(0x01db45dc38e0c826U)),}, (strconv__Uint128){.lo = ((u64)(0xcf15bb96ac8b5857U)),.hi = ((u64)(0x01290ba9a38c7d17U)),}, (strconv__Uint128){.lo = ((u64)(0xc2db2a7c57ae2e6dU)),.hi = ((u64)(0x01734e940c6f9c5dU)),}, (strconv__Uint128){.lo = ((u64)(0x3391f51b6d99ba08U)),.hi = ((u64)(0x01d022390f8b8375U)),}, (strconv__Uint128){.lo = ((u64)(0x403b393124801445U)),.hi = ((u64)(0x01221563a9b73229U)),}, (strconv__Uint128){.lo = ((u64)(0x904a077d6da01956U)),.hi = ((u64)(0x016a9abc9424feb3U)),}, (strconv__Uint128){.lo = ((u64)(0x745c895cc9081facU)),.hi = ((u64)(0x01c5416bb92e3e60U)),}, (strconv__Uint128){.lo = ((u64)(0x48b9d5d9fda513cbU)),.hi = ((u64)(0x011b48e353bce6fcU)),}, (strconv__Uint128){.lo = ((u64)(0x5ae84b507d0e58beU)),.hi = ((u64)(0x01621b1c28ac20bbU)),}, (strconv__Uint128){.lo = ((u64)(0x31a25e249c51eeeeU)),.hi = ((u64)(0x01baa1e332d728eaU)),}, (strconv__Uint128){.lo = ((u64)(0x5f057ad6e1b33554U)),.hi = ((u64)(0x0114a52dffc67992U)),}, (strconv__Uint128){.lo = ((u64)(0xf6c6d98c9a2002aaU)),.hi = ((u64)(0x0159ce797fb817f6U)),}, (strconv__Uint128){.lo = ((u64)(0xb4788fefc0a80354U)),.hi = ((u64)(0x01b04217dfa61df4U)),}, (strconv__Uint128){.lo = ((u64)(0xf0cb59f5d8690214U)),.hi = ((u64)(0x010e294eebc7d2b8U)),}, (strconv__Uint128){.lo = ((u64)(0x2cfe30734e83429aU)),.hi = ((u64)(0x0151b3a2a6b9c767U)),}, (strconv__Uint128){.lo = ((u64)(0xf83dbc9022241340U)),.hi = ((u64)(0x01a6208b50683940U)),}, (strconv__Uint128){.lo = ((u64)(0x9b2695da15568c08U)),.hi = ((u64)(0x0107d457124123c8U)),}, (strconv__Uint128){.lo = ((u64)(0xc1f03b509aac2f0aU)),.hi = ((u64)(0x0149c96cd6d16cbaU)),}, (strconv__Uint128){.lo = ((u64)(0x726c4a24c1573acdU)),.hi = ((u64)(0x019c3bc80c85c7e9U)),}, (strconv__Uint128){.lo = ((u64)(0xe783ae56f8d684c0U)),.hi = ((u64)(0x0101a55d07d39cf1U)),}, (strconv__Uint128){.lo = ((u64)(0x616499ecb70c25f0U)),.hi = ((u64)(0x01420eb449c8842eU)),}, (strconv__Uint128){.lo = ((u64)(0xf9bdc067e4cf2f6cU)),.hi = ((u64)(0x019292615c3aa539U)),}, (strconv__Uint128){.lo = ((u64)(0x782d3081de02fb47U)),.hi = ((u64)(0x01f736f9b3494e88U)),}, (strconv__Uint128){.lo = ((u64)(0x4b1c3e512ac1dd0cU)),.hi = ((u64)(0x013a825c100dd115U)),}, (strconv__Uint128){.lo = ((u64)(0x9de34de57572544fU)),.hi = ((u64)(0x018922f31411455aU)),}, (strconv__Uint128){.lo = ((u64)(0x455c215ed2cee963U)),.hi = ((u64)(0x01eb6bafd91596b1U)),}, (strconv__Uint128){.lo = ((u64)(0xcb5994db43c151deU)),.hi = ((u64)(0x0133234de7ad7e2eU)),}, (strconv__Uint128){.lo = ((u64)(0x7e2ffa1214b1a655U)),.hi = ((u64)(0x017fec216198ddbaU)),}, (strconv__Uint128){.lo = ((u64)(0x1dbbf89699de0febU)),.hi = ((u64)(0x01dfe729b9ff1529U)),}, (strconv__Uint128){.lo = ((u64)(0xb2957b5e202ac9f3U)),.hi = ((u64)(0x012bf07a143f6d39U)),}, (strconv__Uint128){.lo = ((u64)(0x1f3ada35a8357c6fU)),.hi = ((u64)(0x0176ec98994f4888U)),}, (strconv__Uint128){.lo = ((u64)(0x270990c31242db8bU)),.hi = ((u64)(0x01d4a7bebfa31aaaU)),}, (strconv__Uint128){.lo = ((u64)(0x5865fa79eb69c937U)),.hi = ((u64)(0x0124e8d737c5f0aaU)),}, (strconv__Uint128){.lo = ((u64)(0xee7f791866443b85U)),.hi = ((u64)(0x016e230d05b76cd4U)),}, (strconv__Uint128){.lo = ((u64)(0x2a1f575e7fd54a66U)),.hi = ((u64)(0x01c9abd04725480aU)),}, (strconv__Uint128){.lo = ((u64)(0x5a53969b0fe54e80U)),.hi = ((u64)(0x011e0b622c774d06U)),}, (strconv__Uint128){.lo = ((u64)(0xf0e87c41d3dea220U)),.hi = ((u64)(0x01658e3ab7952047U)),}, (strconv__Uint128){.lo = ((u64)(0xed229b5248d64aa8U)),.hi = ((u64)(0x01bef1c9657a6859U)),}, (strconv__Uint128){.lo = ((u64)(0x3435a1136d85eea9U)),.hi = ((u64)(0x0117571ddf6c8138U)),}, (strconv__Uint128){.lo = ((u64)(0x4143095848e76a53U)),.hi = ((u64)(0x015d2ce55747a186U)),}, (strconv__Uint128){.lo = ((u64)(0xd193cbae5b2144e8U)),.hi = ((u64)(0x01b4781ead1989e7U)),}, (strconv__Uint128){.lo = ((u64)(0xe2fc5f4cf8f4cb11U)),.hi = ((u64)(0x0110cb132c2ff630U)),}, (strconv__Uint128){.lo = ((u64)(0x1bbb77203731fdd5U)),.hi = ((u64)(0x0154fdd7f73bf3bdU)),}, (strconv__Uint128){.lo = ((u64)(0x62aa54e844fe7d4aU)),.hi = ((u64)(0x01aa3d4df50af0acU)),}, (strconv__Uint128){.lo = ((u64)(0xbdaa75112b1f0e4eU)),.hi = ((u64)(0x010a6650b926d66bU)),}, (strconv__Uint128){.lo = ((u64)(0xad15125575e6d1e2U)),.hi = ((u64)(0x014cffe4e7708c06U)),}, (strconv__Uint128){.lo = ((u64)(0x585a56ead360865bU)),.hi = ((u64)(0x01a03fde214caf08U)),}, (strconv__Uint128){.lo = ((u64)(0x37387652c41c53f8U)),.hi = ((u64)(0x010427ead4cfed65U)),}, (strconv__Uint128){.lo = ((u64)(0x850693e7752368f7U)),.hi = ((u64)(0x014531e58a03e8beU)),}, (strconv__Uint128){.lo = ((u64)(0x264838e1526c4334U)),.hi = ((u64)(0x01967e5eec84e2eeU)),}, (strconv__Uint128){.lo = ((u64)(0xafda4719a7075402U)),.hi = ((u64)(0x01fc1df6a7a61ba9U)),}, (strconv__Uint128){.lo = ((u64)(0x0de86c7008649481U)),.hi = ((u64)(0x013d92ba28c7d14aU)),}, (strconv__Uint128){.lo = ((u64)(0x9162878c0a7db9a1U)),.hi = ((u64)(0x018cf768b2f9c59cU)),}, (strconv__Uint128){.lo = ((u64)(0xb5bb296f0d1d280aU)),.hi = ((u64)(0x01f03542dfb83703U)),}, (strconv__Uint128){.lo = ((u64)(0x5194f9e568323906U)),.hi = ((u64)(0x01362149cbd32262U)),}, (strconv__Uint128){.lo = ((u64)(0xe5fa385ec23ec747U)),.hi = ((u64)(0x0183a99c3ec7eafaU)),}, (strconv__Uint128){.lo = ((u64)(0x9f78c67672ce7919U)),.hi = ((u64)(0x01e494034e79e5b9U)),}, (strconv__Uint128){.lo = ((u64)(0x03ab7c0a07c10bb0U)),.hi = ((u64)(0x012edc82110c2f94U)),}, (strconv__Uint128){.lo = ((u64)(0x04965b0c89b14e9cU)),.hi = ((u64)(0x017a93a2954f3b79U)),}, (strconv__Uint128){.lo = ((u64)(0x45bbf1cfac1da243U)),.hi = ((u64)(0x01d9388b3aa30a57U)),}, (strconv__Uint128){.lo = ((u64)(0x8b957721cb92856aU)),.hi = ((u64)(0x0127c35704a5e676U)),}, (strconv__Uint128){.lo = ((u64)(0x2e7ad4ea3e7726c4U)),.hi = ((u64)(0x0171b42cc5cf6014U)),}, (strconv__Uint128){.lo = ((u64)(0x3a198a24ce14f075U)),.hi = ((u64)(0x01ce2137f7433819U)),}, (strconv__Uint128){.lo = ((u64)(0xc44ff65700cd1649U)),.hi = ((u64)(0x0120d4c2fa8a030fU)),}, (strconv__Uint128){.lo = ((u64)(0xb563f3ecc1005bdbU)),.hi = ((u64)(0x016909f3b92c83d3U)),}, (strconv__Uint128){.lo = ((u64)(0xa2bcf0e7f14072d2U)),.hi = ((u64)(0x01c34c70a777a4c8U)),}, (strconv__Uint128){.lo = ((u64)(0x65b61690f6c847c3U)),.hi = ((u64)(0x011a0fc668aac6fdU)),}, (strconv__Uint128){.lo = ((u64)(0xbf239c35347a59b4U)),.hi = ((u64)(0x016093b802d578bcU)),}, (strconv__Uint128){.lo = ((u64)(0xeeec83428198f021U)),.hi = ((u64)(0x01b8b8a6038ad6ebU)),}, (strconv__Uint128){.lo = ((u64)(0x7553d20990ff9615U)),.hi = ((u64)(0x01137367c236c653U)),}, (strconv__Uint128){.lo = ((u64)(0x52a8c68bf53f7b9aU)),.hi = ((u64)(0x01585041b2c477e8U)),}, (strconv__Uint128){.lo = ((u64)(0x6752f82ef28f5a81U)),.hi = ((u64)(0x01ae64521f7595e2U)),}, (strconv__Uint128){.lo = ((u64)(0x8093db1d57999890U)),.hi = ((u64)(0x010cfeb353a97dadU)),}, (strconv__Uint128){.lo = ((u64)(0xe0b8d1e4ad7ffeb4U)),.hi = ((u64)(0x01503e602893dd18U)),}, (strconv__Uint128){.lo = ((u64)(0x18e7065dd8dffe62U)),.hi = ((u64)(0x01a44df832b8d45fU)),}, (strconv__Uint128){.lo = ((u64)(0x6f9063faa78bfefdU)),.hi = ((u64)(0x0106b0bb1fb384bbU)),}, (strconv__Uint128){.lo = ((u64)(0x4b747cf9516efebcU)),.hi = ((u64)(0x01485ce9e7a065eaU)),}, (strconv__Uint128){.lo = ((u64)(0xde519c37a5cabe6bU)),.hi = ((u64)(0x019a742461887f64U)),}, (strconv__Uint128){.lo = ((u64)(0x0af301a2c79eb703U)),.hi = ((u64)(0x01008896bcf54f9fU)),}, (strconv__Uint128){.lo = ((u64)(0xcdafc20b798664c4U)),.hi = ((u64)(0x0140aabc6c32a386U)),}, (strconv__Uint128){.lo = ((u64)(0x811bb28e57e7fdf5U)),.hi = ((u64)(0x0190d56b873f4c68U)),}, (strconv__Uint128){.lo = ((u64)(0xa1629f31ede1fd72U)),.hi = ((u64)(0x01f50ac6690f1f82U)),}, (strconv__Uint128){.lo = ((u64)(0xa4dda37f34ad3e67U)),.hi = ((u64)(0x013926bc01a973b1U)),}, (strconv__Uint128){.lo = ((u64)(0x0e150c5f01d88e01U)),.hi = ((u64)(0x0187706b0213d09eU)),}, (strconv__Uint128){.lo = ((u64)(0x919a4f76c24eb181U)),.hi = ((u64)(0x01e94c85c298c4c5U)),}, (strconv__Uint128){.lo = ((u64)(0x7b0071aa39712ef1U)),.hi = ((u64)(0x0131cfd3999f7afbU)),}, (strconv__Uint128){.lo = ((u64)(0x59c08e14c7cd7aadU)),.hi = ((u64)(0x017e43c8800759baU)),}, (strconv__Uint128){.lo = ((u64)(0xf030b199f9c0d958U)),.hi = ((u64)(0x01ddd4baa0093028U)),}, (strconv__Uint128){.lo = ((u64)(0x961e6f003c1887d7U)),.hi = ((u64)(0x012aa4f4a405be19U)),}, (strconv__Uint128){.lo = ((u64)(0xfba60ac04b1ea9cdU)),.hi = ((u64)(0x01754e31cd072d9fU)),}, (strconv__Uint128){.lo = ((u64)(0xfa8f8d705de65440U)),.hi = ((u64)(0x01d2a1be4048f907U)),}, (strconv__Uint128){.lo = ((u64)(0xfc99b8663aaff4a8U)),.hi = ((u64)(0x0123a516e82d9ba4U)),}, (strconv__Uint128){.lo = ((u64)(0x3bc0267fc95bf1d2U)),.hi = ((u64)(0x016c8e5ca239028eU)),}, (strconv__Uint128){.lo = ((u64)(0xcab0301fbbb2ee47U)),.hi = ((u64)(0x01c7b1f3cac74331U)),}, (strconv__Uint128){.lo = ((u64)(0x1eae1e13d54fd4ecU)),.hi = ((u64)(0x011ccf385ebc89ffU)),}, (strconv__Uint128){.lo = ((u64)(0xe659a598caa3ca27U)),.hi = ((u64)(0x01640306766bac7eU)),}, (strconv__Uint128){.lo = ((u64)(0x9ff00efefd4cbcb1U)),.hi = ((u64)(0x01bd03c81406979eU)),}, (strconv__Uint128){.lo = ((u64)(0x23f6095f5e4ff5efU)),.hi = ((u64)(0x0116225d0c841ec3U)),}, (strconv__Uint128){.lo = ((u64)(0xecf38bb735e3f36aU)),.hi = ((u64)(0x015baaf44fa52673U)),}, (strconv__Uint128){.lo = ((u64)(0xe8306ea5035cf045U)),.hi = ((u64)(0x01b295b1638e7010U)),}, (strconv__Uint128){.lo = ((u64)(0x911e4527221a162bU)),.hi = ((u64)(0x010f9d8ede39060aU)),}, (strconv__Uint128){.lo = ((u64)(0x3565d670eaa09bb6U)),.hi = ((u64)(0x015384f295c7478dU)),}, (strconv__Uint128){.lo = ((u64)(0x82bf4c0d2548c2a3U)),.hi = ((u64)(0x01a8662f3b391970U)),}, (strconv__Uint128){.lo = ((u64)(0x51b78f88374d79a6U)),.hi = ((u64)(0x01093fdd8503afe6U)),}, (strconv__Uint128){.lo = ((u64)(0xe625736a4520d810U)),.hi = ((u64)(0x014b8fd4e6449bdfU)),}, (strconv__Uint128){.lo = ((u64)(0xdfaed044d6690e14U)),.hi = ((u64)(0x019e73ca1fd5c2d7U)),}, (strconv__Uint128){.lo = ((u64)(0xebcd422b0601a8ccU)),.hi = ((u64)(0x0103085e53e599c6U)),}, (strconv__Uint128){.lo = ((u64)(0xa6c092b5c78212ffU)),.hi = ((u64)(0x0143ca75e8df0038U)),}, (strconv__Uint128){.lo = ((u64)(0xd070b763396297bfU)),.hi = ((u64)(0x0194bd136316c046U)),}, (strconv__Uint128){.lo = ((u64)(0x848ce53c07bb3dafU)),.hi = ((u64)(0x01f9ec583bdc7058U)),}, (strconv__Uint128){.lo = ((u64)(0x52d80f4584d5068dU)),.hi = ((u64)(0x013c33b72569c637U)),}, (strconv__Uint128){.lo = ((u64)(0x278e1316e60a4831U)),.hi = ((u64)(0x018b40a4eec437c5U)),}}));
	_const_strconv__pow5_inv_split_64 = new_array_from_c_array(292, 292, sizeof(strconv__Uint128), _MOV((strconv__Uint128[292]){
		(strconv__Uint128){.lo = ((u64)(0x0000000000000001U)),.hi = ((u64)(0x0400000000000000U)),}, (strconv__Uint128){.lo = ((u64)(0x3333333333333334U)),.hi = ((u64)(0x0333333333333333U)),}, (strconv__Uint128){.lo = ((u64)(0x28f5c28f5c28f5c3U)),.hi = ((u64)(0x028f5c28f5c28f5cU)),}, (strconv__Uint128){.lo = ((u64)(0xed916872b020c49cU)),.hi = ((u64)(0x020c49ba5e353f7cU)),}, (strconv__Uint128){.lo = ((u64)(0xaf4f0d844d013a93U)),.hi = ((u64)(0x0346dc5d63886594U)),}, (strconv__Uint128){.lo = ((u64)(0x8c3f3e0370cdc876U)),.hi = ((u64)(0x029f16b11c6d1e10U)),}, (strconv__Uint128){.lo = ((u64)(0xd698fe69270b06c5U)),.hi = ((u64)(0x0218def416bdb1a6U)),}, (strconv__Uint128){.lo = ((u64)(0xf0f4ca41d811a46eU)),.hi = ((u64)(0x035afe535795e90aU)),}, (strconv__Uint128){.lo = ((u64)(0xf3f70834acdae9f1U)),.hi = ((u64)(0x02af31dc4611873bU)),}, (strconv__Uint128){.lo = ((u64)(0x5cc5a02a23e254c1U)),.hi = ((u64)(0x0225c17d04dad296U)),}, (strconv__Uint128){.lo = ((u64)(0xfad5cd10396a2135U)),.hi = ((u64)(0x036f9bfb3af7b756U)),}, (strconv__Uint128){.lo = ((u64)(0xfbde3da69454e75eU)),.hi = ((u64)(0x02bfaffc2f2c92abU)),}, (strconv__Uint128){.lo = ((u64)(0x2fe4fe1edd10b918U)),.hi = ((u64)(0x0232f33025bd4223U)),}, (strconv__Uint128){.lo = ((u64)(0x4ca19697c81ac1bfU)),.hi = ((u64)(0x0384b84d092ed038U)),}, (strconv__Uint128){.lo = ((u64)(0x3d4e1213067bce33U)),.hi = ((u64)(0x02d09370d4257360U)),}, (strconv__Uint128){.lo = ((u64)(0x643e74dc052fd829U)),.hi = ((u64)(0x024075f3dceac2b3U)),}, (strconv__Uint128){.lo = ((u64)(0x6d30baf9a1e626a7U)),.hi = ((u64)(0x039a5652fb113785U)),}, (strconv__Uint128){.lo = ((u64)(0x2426fbfae7eb5220U)),.hi = ((u64)(0x02e1dea8c8da92d1U)),}, (strconv__Uint128){.lo = ((u64)(0x1cebfcc8b9890e80U)),.hi = ((u64)(0x024e4bba3a487574U)),}, (strconv__Uint128){.lo = ((u64)(0x94acc7a78f41b0ccU)),.hi = ((u64)(0x03b07929f6da5586U)),}, (strconv__Uint128){.lo = ((u64)(0xaa23d2ec729af3d7U)),.hi = ((u64)(0x02f394219248446bU)),}, (strconv__Uint128){.lo = ((u64)(0xbb4fdbf05baf2979U)),.hi = ((u64)(0x025c768141d369efU)),}, (strconv__Uint128){.lo = ((u64)(0xc54c931a2c4b758dU)),.hi = ((u64)(0x03c7240202ebdcb2U)),}, (strconv__Uint128){.lo = ((u64)(0x9dd6dc14f03c5e0bU)),.hi = ((u64)(0x0305b66802564a28U)),}, (strconv__Uint128){.lo = ((u64)(0x4b1249aa59c9e4d6U)),.hi = ((u64)(0x026af8533511d4edU)),}, (strconv__Uint128){.lo = ((u64)(0x44ea0f76f60fd489U)),.hi = ((u64)(0x03de5a1ebb4fbb15U)),}, (strconv__Uint128){.lo = ((u64)(0x6a54d92bf80caa07U)),.hi = ((u64)(0x0318481895d96277U)),}, (strconv__Uint128){.lo = ((u64)(0x21dd7a89933d54d2U)),.hi = ((u64)(0x0279d346de4781f9U)),}, (strconv__Uint128){.lo = ((u64)(0x362f2a75b8622150U)),.hi = ((u64)(0x03f61ed7ca0c0328U)),}, (strconv__Uint128){.lo = ((u64)(0xf825bb91604e810dU)),.hi = ((u64)(0x032b4bdfd4d668ecU)),}, (strconv__Uint128){.lo = ((u64)(0xc684960de6a5340bU)),.hi = ((u64)(0x0289097fdd7853f0U)),}, (strconv__Uint128){.lo = ((u64)(0xd203ab3e521dc33cU)),.hi = ((u64)(0x02073accb12d0ff3U)),}, (strconv__Uint128){.lo = ((u64)(0xe99f7863b696052cU)),.hi = ((u64)(0x033ec47ab514e652U)),}, (strconv__Uint128){.lo = ((u64)(0x87b2c6b62bab3757U)),.hi = ((u64)(0x02989d2ef743eb75U)),}, (strconv__Uint128){.lo = ((u64)(0xd2f56bc4efbc2c45U)),.hi = ((u64)(0x0213b0f25f69892aU)),}, (strconv__Uint128){.lo = ((u64)(0x1e55793b192d13a2U)),.hi = ((u64)(0x0352b4b6ff0f41deU)),}, (strconv__Uint128){.lo = ((u64)(0x4b77942f475742e8U)),.hi = ((u64)(0x02a8909265a5ce4bU)),}, (strconv__Uint128){.lo = ((u64)(0xd5f9435905df68baU)),.hi = ((u64)(0x022073a8515171d5U)),}, (strconv__Uint128){.lo = ((u64)(0x565b9ef4d6324129U)),.hi = ((u64)(0x03671f73b54f1c89U)),}, (strconv__Uint128){.lo = ((u64)(0xdeafb25d78283421U)),.hi = ((u64)(0x02b8e5f62aa5b06dU)),}, (strconv__Uint128){.lo = ((u64)(0x188c8eb12cecf681U)),.hi = ((u64)(0x022d84c4eeeaf38bU)),}, (strconv__Uint128){.lo = ((u64)(0x8dadb11b7b14bd9bU)),.hi = ((u64)(0x037c07a17e44b8deU)),}, (strconv__Uint128){.lo = ((u64)(0x7157c0e2c8dd647cU)),.hi = ((u64)(0x02c99fb46503c718U)),}, (strconv__Uint128){.lo = ((u64)(0x8ddfcd823a4ab6caU)),.hi = ((u64)(0x023ae629ea696c13U)),}, (strconv__Uint128){.lo = ((u64)(0x1632e269f6ddf142U)),.hi = ((u64)(0x0391704310a8acecU)),}, (strconv__Uint128){.lo = ((u64)(0x44f581ee5f17f435U)),.hi = ((u64)(0x02dac035a6ed5723U)),}, (strconv__Uint128){.lo = ((u64)(0x372ace584c1329c4U)),.hi = ((u64)(0x024899c4858aac1cU)),}, (strconv__Uint128){.lo = ((u64)(0xbeaae3c079b842d3U)),.hi = ((u64)(0x03a75c6da27779c6U)),}, (strconv__Uint128){.lo = ((u64)(0x6555830061603576U)),.hi = ((u64)(0x02ec49f14ec5fb05U)),}, (strconv__Uint128){.lo = ((u64)(0xb7779c004de6912bU)),.hi = ((u64)(0x0256a18dd89e626aU)),}, (strconv__Uint128){.lo = ((u64)(0xf258f99a163db512U)),.hi = ((u64)(0x03bdcf495a9703ddU)),}, (strconv__Uint128){.lo = ((u64)(0x5b7a614811caf741U)),.hi = ((u64)(0x02fe3f6de212697eU)),}, (strconv__Uint128){.lo = ((u64)(0xaf951aa00e3bf901U)),.hi = ((u64)(0x0264ff8b1b41edfeU)),}, (strconv__Uint128){.lo = ((u64)(0x7f54f7667d2cc19bU)),.hi = ((u64)(0x03d4cc11c5364997U)),}, (strconv__Uint128){.lo = ((u64)(0x32aa5f8530f09ae3U)),.hi = ((u64)(0x0310a3416a91d479U)),}, (strconv__Uint128){.lo = ((u64)(0xf55519375a5a1582U)),.hi = ((u64)(0x0273b5cdeedb1060U)),}, (strconv__Uint128){.lo = ((u64)(0xbbbb5b8bc3c3559dU)),.hi = ((u64)(0x03ec56164af81a34U)),}, (strconv__Uint128){.lo = ((u64)(0x2fc916096969114aU)),.hi = ((u64)(0x03237811d593482aU)),}, (strconv__Uint128){.lo = ((u64)(0x596dab3ababa743cU)),.hi = ((u64)(0x0282c674aadc39bbU)),}, (strconv__Uint128){.lo = ((u64)(0x478aef622efb9030U)),.hi = ((u64)(0x0202385d557cfafcU)),}, (strconv__Uint128){.lo = ((u64)(0xd8de4bd04b2c19e6U)),.hi = ((u64)(0x0336c0955594c4c6U)),}, (strconv__Uint128){.lo = ((u64)(0xad7ea30d08f014b8U)),.hi = ((u64)(0x029233aaaadd6a38U)),}, (strconv__Uint128){.lo = ((u64)(0x24654f3da0c01093U)),.hi = ((u64)(0x020e8fbbbbe454faU)),}, (strconv__Uint128){.lo = ((u64)(0x3a3bb1fc346680ebU)),.hi = ((u64)(0x034a7f92c63a2190U)),}, (strconv__Uint128){.lo = ((u64)(0x94fc8e635d1ecd89U)),.hi = ((u64)(0x02a1ffa89e94e7a6U)),}, (strconv__Uint128){.lo = ((u64)(0xaa63a51c4a7f0ad4U)),.hi = ((u64)(0x021b32ed4baa52ebU)),}, (strconv__Uint128){.lo = ((u64)(0xdd6c3b607731aaedU)),.hi = ((u64)(0x035eb7e212aa1e45U)),}, (strconv__Uint128){.lo = ((u64)(0x1789c919f8f488bdU)),.hi = ((u64)(0x02b22cb4dbbb4b6bU)),}, (strconv__Uint128){.lo = ((u64)(0xac6e3a7b2d906d64U)),.hi = ((u64)(0x022823c3e2fc3c55U)),}, (strconv__Uint128){.lo = ((u64)(0x13e390c515b3e23aU)),.hi = ((u64)(0x03736c6c9e606089U)),}, (strconv__Uint128){.lo = ((u64)(0xdcb60d6a77c31b62U)),.hi = ((u64)(0x02c2bd23b1e6b3a0U)),}, (strconv__Uint128){.lo = ((u64)(0x7d5e7121f968e2b5U)),.hi = ((u64)(0x0235641c8e52294dU)),}, (strconv__Uint128){.lo = ((u64)(0xc8971b698f0e3787U)),.hi = ((u64)(0x0388a02db0837548U)),}, (strconv__Uint128){.lo = ((u64)(0xa078e2bad8d82c6cU)),.hi = ((u64)(0x02d3b357c0692aa0U)),}, (strconv__Uint128){.lo = ((u64)(0xe6c71bc8ad79bd24U)),.hi = ((u64)(0x0242f5dfcd20eee6U)),}, (strconv__Uint128){.lo = ((u64)(0x0ad82c7448c2c839U)),.hi = ((u64)(0x039e5632e1ce4b0bU)),}, (strconv__Uint128){.lo = ((u64)(0x3be023903a356cfaU)),.hi = ((u64)(0x02e511c24e3ea26fU)),}, (strconv__Uint128){.lo = ((u64)(0x2fe682d9c82abd95U)),.hi = ((u64)(0x0250db01d8321b8cU)),}, (strconv__Uint128){.lo = ((u64)(0x4ca4048fa6aac8eeU)),.hi = ((u64)(0x03b4919c8d1cf8e0U)),}, (strconv__Uint128){.lo = ((u64)(0x3d5003a61eef0725U)),.hi = ((u64)(0x02f6dae3a4172d80U)),}, (strconv__Uint128){.lo = ((u64)(0x9773361e7f259f51U)),.hi = ((u64)(0x025f1582e9ac2466U)),}, (strconv__Uint128){.lo = ((u64)(0x8beb89ca6508fee8U)),.hi = ((u64)(0x03cb559e42ad070aU)),}, (strconv__Uint128){.lo = ((u64)(0x6fefa16eb73a6586U)),.hi = ((u64)(0x0309114b688a6c08U)),}, (strconv__Uint128){.lo = ((u64)(0xf3261abef8fb846bU)),.hi = ((u64)(0x026da76f86d52339U)),}, (strconv__Uint128){.lo = ((u64)(0x51d691318e5f3a45U)),.hi = ((u64)(0x03e2a57f3e21d1f6U)),}, (strconv__Uint128){.lo = ((u64)(0x0e4540f471e5c837U)),.hi = ((u64)(0x031bb798fe8174c5U)),}, (strconv__Uint128){.lo = ((u64)(0xd8376729f4b7d360U)),.hi = ((u64)(0x027c92e0cb9ac3d0U)),}, (strconv__Uint128){.lo = ((u64)(0xf38bd84321261effU)),.hi = ((u64)(0x03fa849adf5e061aU)),}, (strconv__Uint128){.lo = ((u64)(0x293cad0280eb4bffU)),.hi = ((u64)(0x032ed07be5e4d1afU)),}, (strconv__Uint128){.lo = ((u64)(0xedca240200bc3cccU)),.hi = ((u64)(0x028bd9fcb7ea4158U)),}, (strconv__Uint128){.lo = ((u64)(0xbe3b50019a3030a4U)),.hi = ((u64)(0x02097b309321cde0U)),}, (strconv__Uint128){.lo = ((u64)(0xc9f88002904d1a9fU)),.hi = ((u64)(0x03425eb41e9c7c9aU)),}, (strconv__Uint128){.lo = ((u64)(0x3b2d3335403daee6U)),.hi = ((u64)(0x029b7ef67ee396e2U)),}, (strconv__Uint128){.lo = ((u64)(0x95bdc291003158b8U)),.hi = ((u64)(0x0215ff2b98b6124eU)),}, (strconv__Uint128){.lo = ((u64)(0x892f9db4cd1bc126U)),.hi = ((u64)(0x035665128df01d4aU)),}, (strconv__Uint128){.lo = ((u64)(0x07594af70a7c9a85U)),.hi = ((u64)(0x02ab840ed7f34aa2U)),}, (strconv__Uint128){.lo = ((u64)(0x6c476f2c0863aed1U)),.hi = ((u64)(0x0222d00bdff5d54eU)),}, (strconv__Uint128){.lo = ((u64)(0x13a57eacda3917b4U)),.hi = ((u64)(0x036ae67966562217U)),}, (strconv__Uint128){.lo = ((u64)(0x0fb7988a482dac90U)),.hi = ((u64)(0x02bbeb9451de81acU)),}, (strconv__Uint128){.lo = ((u64)(0xd95fad3b6cf156daU)),.hi = ((u64)(0x022fefa9db1867bcU)),}, (strconv__Uint128){.lo = ((u64)(0xf565e1f8ae4ef15cU)),.hi = ((u64)(0x037fe5dc91c0a5faU)),}, (strconv__Uint128){.lo = ((u64)(0x911e4e608b725ab0U)),.hi = ((u64)(0x02ccb7e3a7cd5195U)),}, (strconv__Uint128){.lo = ((u64)(0xda7ea51a0928488dU)),.hi = ((u64)(0x023d5fe9530aa7aaU)),}, (strconv__Uint128){.lo = ((u64)(0xf7310829a8407415U)),.hi = ((u64)(0x039566421e7772aaU)),}, (strconv__Uint128){.lo = ((u64)(0x2c2739baed005cdeU)),.hi = ((u64)(0x02ddeb68185f8eefU)),}, (strconv__Uint128){.lo = ((u64)(0xbcec2e2f24004a4bU)),.hi = ((u64)(0x024b22b9ad193f25U)),}, (strconv__Uint128){.lo = ((u64)(0x94ad16b1d333aa11U)),.hi = ((u64)(0x03ab6ac2ae8ecb6fU)),}, (strconv__Uint128){.lo = ((u64)(0xaa241227dc2954dbU)),.hi = ((u64)(0x02ef889bbed8a2bfU)),}, (strconv__Uint128){.lo = ((u64)(0x54e9a81fe35443e2U)),.hi = ((u64)(0x02593a163246e899U)),}, (strconv__Uint128){.lo = ((u64)(0x2175d9cc9eed396aU)),.hi = ((u64)(0x03c1f689ea0b0dc2U)),}, (strconv__Uint128){.lo = ((u64)(0xe7917b0a18bdc788U)),.hi = ((u64)(0x03019207ee6f3e34U)),}, (strconv__Uint128){.lo = ((u64)(0xb9412f3b46fe393aU)),.hi = ((u64)(0x0267a8065858fe90U)),}, (strconv__Uint128){.lo = ((u64)(0xf535185ed7fd285cU)),.hi = ((u64)(0x03d90cd6f3c1974dU)),}, (strconv__Uint128){.lo = ((u64)(0xc42a79e57997537dU)),.hi = ((u64)(0x03140a458fce12a4U)),}, (strconv__Uint128){.lo = ((u64)(0x03552e512e12a931U)),.hi = ((u64)(0x02766e9e0ca4dbb7U)),}, (strconv__Uint128){.lo = ((u64)(0x9eeeb081e3510eb4U)),.hi = ((u64)(0x03f0b0fce107c5f1U)),}, (strconv__Uint128){.lo = ((u64)(0x4bf226ce4f740bc3U)),.hi = ((u64)(0x0326f3fd80d304c1U)),}, (strconv__Uint128){.lo = ((u64)(0xa3281f0b72c33c9cU)),.hi = ((u64)(0x02858ffe00a8d09aU)),}, (strconv__Uint128){.lo = ((u64)(0x1c2018d5f568fd4aU)),.hi = ((u64)(0x020473319a20a6e2U)),}, (strconv__Uint128){.lo = ((u64)(0xf9ccf48988a7fba9U)),.hi = ((u64)(0x033a51e8f69aa49cU)),}, (strconv__Uint128){.lo = ((u64)(0xfb0a5d3ad3b99621U)),.hi = ((u64)(0x02950e53f87bb6e3U)),}, (strconv__Uint128){.lo = ((u64)(0x2f3b7dc8a96144e7U)),.hi = ((u64)(0x0210d8432d2fc583U)),}, (strconv__Uint128){.lo = ((u64)(0xe52bfc7442353b0cU)),.hi = ((u64)(0x034e26d1e1e608d1U)),}, (strconv__Uint128){.lo = ((u64)(0xb756639034f76270U)),.hi = ((u64)(0x02a4ebdb1b1e6d74U)),}, (strconv__Uint128){.lo = ((u64)(0x2c451c735d92b526U)),.hi = ((u64)(0x021d897c15b1f12aU)),}, (strconv__Uint128){.lo = ((u64)(0x13a1c71efc1deea3U)),.hi = ((u64)(0x0362759355e981ddU)),}, (strconv__Uint128){.lo = ((u64)(0x761b05b2634b2550U)),.hi = ((u64)(0x02b52adc44bace4aU)),}, (strconv__Uint128){.lo = ((u64)(0x91af37c1e908eaa6U)),.hi = ((u64)(0x022a88b036fbd83bU)),}, (strconv__Uint128){.lo = ((u64)(0x82b1f2cfdb417770U)),.hi = ((u64)(0x03774119f192f392U)),}, (strconv__Uint128){.lo = ((u64)(0xcef4c23fe29ac5f3U)),.hi = ((u64)(0x02c5cdae5adbf60eU)),}, (strconv__Uint128){.lo = ((u64)(0x3f2a34ffe87bd190U)),.hi = ((u64)(0x0237d7beaf165e72U)),}, (strconv__Uint128){.lo = ((u64)(0x984387ffda5fb5b2U)),.hi = ((u64)(0x038c8c644b56fd83U)),}, (strconv__Uint128){.lo = ((u64)(0xe0360666484c915bU)),.hi = ((u64)(0x02d6d6b6a2abfe02U)),}, (strconv__Uint128){.lo = ((u64)(0x802b3851d3707449U)),.hi = ((u64)(0x024578921bbccb35U)),}, (strconv__Uint128){.lo = ((u64)(0x99dec082ebe72075U)),.hi = ((u64)(0x03a25a835f947855U)),}, (strconv__Uint128){.lo = ((u64)(0xae4bcd358985b391U)),.hi = ((u64)(0x02e8486919439377U)),}, (strconv__Uint128){.lo = ((u64)(0xbea30a913ad15c74U)),.hi = ((u64)(0x02536d20e102dc5fU)),}, (strconv__Uint128){.lo = ((u64)(0xfdd1aa81f7b560b9U)),.hi = ((u64)(0x03b8ae9b019e2d65U)),}, (strconv__Uint128){.lo = ((u64)(0x97daeece5fc44d61U)),.hi = ((u64)(0x02fa2548ce182451U)),}, (strconv__Uint128){.lo = ((u64)(0xdfe258a51969d781U)),.hi = ((u64)(0x0261b76d71ace9daU)),}, (strconv__Uint128){.lo = ((u64)(0x996a276e8f0fbf34U)),.hi = ((u64)(0x03cf8be24f7b0fc4U)),}, (strconv__Uint128){.lo = ((u64)(0xe121b9253f3fcc2aU)),.hi = ((u64)(0x030c6fe83f95a636U)),}, (strconv__Uint128){.lo = ((u64)(0xb41afa8432997022U)),.hi = ((u64)(0x02705986994484f8U)),}, (strconv__Uint128){.lo = ((u64)(0xecf7f739ea8f19cfU)),.hi = ((u64)(0x03e6f5a4286da18dU)),}, (strconv__Uint128){.lo = ((u64)(0x23f99294bba5ae40U)),.hi = ((u64)(0x031f2ae9b9f14e0bU)),}, (strconv__Uint128){.lo = ((u64)(0x4ffadbaa2fb7be99U)),.hi = ((u64)(0x027f5587c7f43e6fU)),}, (strconv__Uint128){.lo = ((u64)(0x7ff7c5dd1925fdc2U)),.hi = ((u64)(0x03feef3fa6539718U)),}, (strconv__Uint128){.lo = ((u64)(0xccc637e4141e649bU)),.hi = ((u64)(0x033258ffb842df46U)),}, (strconv__Uint128){.lo = ((u64)(0xd704f983434b83afU)),.hi = ((u64)(0x028ead9960357f6bU)),}, (strconv__Uint128){.lo = ((u64)(0x126a6135cf6f9c8cU)),.hi = ((u64)(0x020bbe144cf79923U)),}, (strconv__Uint128){.lo = ((u64)(0x83dd685618b29414U)),.hi = ((u64)(0x0345fced47f28e9eU)),}, (strconv__Uint128){.lo = ((u64)(0x9cb12044e08edcddU)),.hi = ((u64)(0x029e63f1065ba54bU)),}, (strconv__Uint128){.lo = ((u64)(0x16f419d0b3a57d7dU)),.hi = ((u64)(0x02184ff405161dd6U)),}, (strconv__Uint128){.lo = ((u64)(0x8b20294dec3bfbfbU)),.hi = ((u64)(0x035a19866e89c956U)),}, (strconv__Uint128){.lo = ((u64)(0x3c19baa4bcfcc996U)),.hi = ((u64)(0x02ae7ad1f207d445U)),}, (strconv__Uint128){.lo = ((u64)(0xc9ae2eea30ca3adfU)),.hi = ((u64)(0x02252f0e5b39769dU)),}, (strconv__Uint128){.lo = ((u64)(0x0f7d17dd1add2afdU)),.hi = ((u64)(0x036eb1b091f58a96U)),}, (strconv__Uint128){.lo = ((u64)(0x3f97464a7be42264U)),.hi = ((u64)(0x02bef48d41913babU)),}, (strconv__Uint128){.lo = ((u64)(0xcc790508631ce850U)),.hi = ((u64)(0x02325d3dce0dc955U)),}, (strconv__Uint128){.lo = ((u64)(0xe0c1a1a704fb0d4dU)),.hi = ((u64)(0x0383c862e3494222U)),}, (strconv__Uint128){.lo = ((u64)(0x4d67b4859d95a43eU)),.hi = ((u64)(0x02cfd3824f6dce82U)),}, (strconv__Uint128){.lo = ((u64)(0x711fc39e17aae9cbU)),.hi = ((u64)(0x023fdc683f8b0b9bU)),}, (strconv__Uint128){.lo = ((u64)(0xe832d2968c44a945U)),.hi = ((u64)(0x039960a6cc11ac2bU)),}, (strconv__Uint128){.lo = ((u64)(0xecf575453d03ba9eU)),.hi = ((u64)(0x02e11a1f09a7bcefU)),}, (strconv__Uint128){.lo = ((u64)(0x572ac4376402fbb1U)),.hi = ((u64)(0x024dae7f3aec9726U)),}, (strconv__Uint128){.lo = ((u64)(0x58446d256cd192b5U)),.hi = ((u64)(0x03af7d985e47583dU)),}, (strconv__Uint128){.lo = ((u64)(0x79d0575123dadbc4U)),.hi = ((u64)(0x02f2cae04b6c4697U)),}, (strconv__Uint128){.lo = ((u64)(0x94a6ac40e97be303U)),.hi = ((u64)(0x025bd5803c569edfU)),}, (strconv__Uint128){.lo = ((u64)(0x8771139b0f2c9e6cU)),.hi = ((u64)(0x03c62266c6f0fe32U)),}, (strconv__Uint128){.lo = ((u64)(0x9f8da948d8f07ebdU)),.hi = ((u64)(0x0304e85238c0cb5bU)),}, (strconv__Uint128){.lo = ((u64)(0xe60aedd3e0c06564U)),.hi = ((u64)(0x026a5374fa33d5e2U)),}, (strconv__Uint128){.lo = ((u64)(0xa344afb9679a3bd2U)),.hi = ((u64)(0x03dd5254c3862304U)),}, (strconv__Uint128){.lo = ((u64)(0xe903bfc78614fca8U)),.hi = ((u64)(0x031775109c6b4f36U)),}, (strconv__Uint128){.lo = ((u64)(0xba6966393810ca20U)),.hi = ((u64)(0x02792a73b055d8f8U)),}, (strconv__Uint128){.lo = ((u64)(0x2a423d2859b4769aU)),.hi = ((u64)(0x03f510b91a22f4c1U)),}, (strconv__Uint128){.lo = ((u64)(0xee9b642047c39215U)),.hi = ((u64)(0x032a73c7481bf700U)),}, (strconv__Uint128){.lo = ((u64)(0xbee2b680396941aaU)),.hi = ((u64)(0x02885c9f6ce32c00U)),}, (strconv__Uint128){.lo = ((u64)(0xff1bc53361210155U)),.hi = ((u64)(0x0206b07f8a4f5666U)),}, (strconv__Uint128){.lo = ((u64)(0x31c6085235019bbbU)),.hi = ((u64)(0x033de73276e5570bU)),}, (strconv__Uint128){.lo = ((u64)(0x27d1a041c4014963U)),.hi = ((u64)(0x0297ec285f1ddf3cU)),}, (strconv__Uint128){.lo = ((u64)(0xeca7b367d0010782U)),.hi = ((u64)(0x021323537f4b18fcU)),}, (strconv__Uint128){.lo = ((u64)(0xadd91f0c8001a59dU)),.hi = ((u64)(0x0351d21f3211c194U)),}, (strconv__Uint128){.lo = ((u64)(0xf17a7f3d3334847eU)),.hi = ((u64)(0x02a7db4c280e3476U)),}, (strconv__Uint128){.lo = ((u64)(0x279532975c2a0398U)),.hi = ((u64)(0x021fe2a3533e905fU)),}, (strconv__Uint128){.lo = ((u64)(0xd8eeb75893766c26U)),.hi = ((u64)(0x0366376bb8641a31U)),}, (strconv__Uint128){.lo = ((u64)(0x7a5892ad42c52352U)),.hi = ((u64)(0x02b82c562d1ce1c1U)),}, (strconv__Uint128){.lo = ((u64)(0xfb7a0ef102374f75U)),.hi = ((u64)(0x022cf044f0e3e7cdU)),}, (strconv__Uint128){.lo = ((u64)(0xc59017e8038bb254U)),.hi = ((u64)(0x037b1a07e7d30c7cU)),}, (strconv__Uint128){.lo = ((u64)(0x37a67986693c8eaaU)),.hi = ((u64)(0x02c8e19feca8d6caU)),}, (strconv__Uint128){.lo = ((u64)(0xf951fad1edca0bbbU)),.hi = ((u64)(0x023a4e198a20abd4U)),}, (strconv__Uint128){.lo = ((u64)(0x28832ae97c76792bU)),.hi = ((u64)(0x03907cf5a9cddfbbU)),}, (strconv__Uint128){.lo = ((u64)(0x2068ef21305ec756U)),.hi = ((u64)(0x02d9fd9154a4b2fcU)),}, (strconv__Uint128){.lo = ((u64)(0x19ed8c1a8d189f78U)),.hi = ((u64)(0x0247fe0ddd508f30U)),}, (strconv__Uint128){.lo = ((u64)(0x5caf4690e1c0ff26U)),.hi = ((u64)(0x03a66349621a7eb3U)),}, (strconv__Uint128){.lo = ((u64)(0x4a25d20d81673285U)),.hi = ((u64)(0x02eb82a11b48655cU)),}, (strconv__Uint128){.lo = ((u64)(0x3b5174d79ab8f537U)),.hi = ((u64)(0x0256021a7c39eab0U)),}, (strconv__Uint128){.lo = ((u64)(0x921bee25c45b21f1U)),.hi = ((u64)(0x03bcd02a605caab3U)),}, (strconv__Uint128){.lo = ((u64)(0xdb498b5169e2818eU)),.hi = ((u64)(0x02fd735519e3bbc2U)),}, (strconv__Uint128){.lo = ((u64)(0x15d46f7454b53472U)),.hi = ((u64)(0x02645c4414b62fcfU)),}, (strconv__Uint128){.lo = ((u64)(0xefba4bed545520b6U)),.hi = ((u64)(0x03d3c6d35456b2e4U)),}, (strconv__Uint128){.lo = ((u64)(0xf2fb6ff110441a2bU)),.hi = ((u64)(0x030fd242a9def583U)),}, (strconv__Uint128){.lo = ((u64)(0x8f2f8cc0d9d014efU)),.hi = ((u64)(0x02730e9bbb18c469U)),}, (strconv__Uint128){.lo = ((u64)(0xb1e5ae015c80217fU)),.hi = ((u64)(0x03eb4a92c4f46d75U)),}, (strconv__Uint128){.lo = ((u64)(0xc1848b344a001accU)),.hi = ((u64)(0x0322a20f03f6bdf7U)),}, (strconv__Uint128){.lo = ((u64)(0xce03a2903b3348a3U)),.hi = ((u64)(0x02821b3f365efe5fU)),}, (strconv__Uint128){.lo = ((u64)(0xd802e873628f6d4fU)),.hi = ((u64)(0x0201af65c518cb7fU)),}, (strconv__Uint128){.lo = ((u64)(0x599e40b89db2487fU)),.hi = ((u64)(0x0335e56fa1c14599U)),}, (strconv__Uint128){.lo = ((u64)(0xe14b66fa17c1d399U)),.hi = ((u64)(0x029184594e3437adU)),}, (strconv__Uint128){.lo = ((u64)(0x81091f2e7967dc7aU)),.hi = ((u64)(0x020e037aa4f692f1U)),}, (strconv__Uint128){.lo = ((u64)(0x9b41cb7d8f0c93f6U)),.hi = ((u64)(0x03499f2aa18a84b5U)),}, (strconv__Uint128){.lo = ((u64)(0xaf67d5fe0c0a0ff8U)),.hi = ((u64)(0x02a14c221ad536f7U)),}, (strconv__Uint128){.lo = ((u64)(0xf2b977fe70080cc7U)),.hi = ((u64)(0x021aa34e7bddc592U)),}, (strconv__Uint128){.lo = ((u64)(0x1df58cca4cd9ae0bU)),.hi = ((u64)(0x035dd2172c9608ebU)),}, (strconv__Uint128){.lo = ((u64)(0xe4c470a1d7148b3cU)),.hi = ((u64)(0x02b174df56de6d88U)),}, (strconv__Uint128){.lo = ((u64)(0x83d05a1b1276d5caU)),.hi = ((u64)(0x022790b2abe5246dU)),}, (strconv__Uint128){.lo = ((u64)(0x9fb3c35e83f1560fU)),.hi = ((u64)(0x0372811ddfd50715U)),}, (strconv__Uint128){.lo = ((u64)(0xb2f635e5365aab3fU)),.hi = ((u64)(0x02c200e4b310d277U)),}, (strconv__Uint128){.lo = ((u64)(0xf591c4b75eaeef66U)),.hi = ((u64)(0x0234cd83c273db92U)),}, (strconv__Uint128){.lo = ((u64)(0xef4fa125644b18a3U)),.hi = ((u64)(0x0387af39371fc5b7U)),}, (strconv__Uint128){.lo = ((u64)(0x8c3fb41de9d5ad4fU)),.hi = ((u64)(0x02d2f2942c196af9U)),}, (strconv__Uint128){.lo = ((u64)(0x3cffc34b2177bdd9U)),.hi = ((u64)(0x02425ba9bce12261U)),}, (strconv__Uint128){.lo = ((u64)(0x94cc6bab68bf9628U)),.hi = ((u64)(0x039d5f75fb01d09bU)),}, (strconv__Uint128){.lo = ((u64)(0x10a38955ed6611b9U)),.hi = ((u64)(0x02e44c5e6267da16U)),}, (strconv__Uint128){.lo = ((u64)(0xda1c6dde5784dafbU)),.hi = ((u64)(0x02503d184eb97b44U)),}, (strconv__Uint128){.lo = ((u64)(0xf693e2fd58d49191U)),.hi = ((u64)(0x03b394f3b128c53aU)),}, (strconv__Uint128){.lo = ((u64)(0xc5431bfde0aa0e0eU)),.hi = ((u64)(0x02f610c2f4209dc8U)),}, (strconv__Uint128){.lo = ((u64)(0x6a9c1664b3bb3e72U)),.hi = ((u64)(0x025e73cf29b3b16dU)),}, (strconv__Uint128){.lo = ((u64)(0x10f9bd6dec5eca4fU)),.hi = ((u64)(0x03ca52e50f85e8afU)),}, (strconv__Uint128){.lo = ((u64)(0xda616457f04bd50cU)),.hi = ((u64)(0x03084250d937ed58U)),}, (strconv__Uint128){.lo = ((u64)(0xe1e783798d09773dU)),.hi = ((u64)(0x026d01da475ff113U)),}, (strconv__Uint128){.lo = ((u64)(0x030c058f480f252eU)),.hi = ((u64)(0x03e19c9072331b53U)),}, (strconv__Uint128){.lo = ((u64)(0x68d66ad906728425U)),.hi = ((u64)(0x031ae3a6c1c27c42U)),}, (strconv__Uint128){.lo = ((u64)(0x8711ef14052869b7U)),.hi = ((u64)(0x027be952349b969bU)),}, (strconv__Uint128){.lo = ((u64)(0x0b4fe4ecd50d75f2U)),.hi = ((u64)(0x03f97550542c242cU)),}, (strconv__Uint128){.lo = ((u64)(0xa2a650bd773df7f5U)),.hi = ((u64)(0x032df7737689b689U)),}, (strconv__Uint128){.lo = ((u64)(0xb551da312c31932aU)),.hi = ((u64)(0x028b2c5c5ed49207U)),}, (strconv__Uint128){.lo = ((u64)(0x5ddb14f4235adc22U)),.hi = ((u64)(0x0208f049e576db39U)),}, (strconv__Uint128){.lo = ((u64)(0x2fc4ee536bc49369U)),.hi = ((u64)(0x034180763bf15ec2U)),}, (strconv__Uint128){.lo = ((u64)(0xbfd0bea92303a921U)),.hi = ((u64)(0x029acd2b63277f01U)),}, (strconv__Uint128){.lo = ((u64)(0x9973cbba8269541aU)),.hi = ((u64)(0x021570ef8285ff34U)),}, (strconv__Uint128){.lo = ((u64)(0x5bec792a6a42202aU)),.hi = ((u64)(0x0355817f373ccb87U)),}, (strconv__Uint128){.lo = ((u64)(0xe3239421ee9b4cefU)),.hi = ((u64)(0x02aacdff5f63d605U)),}, (strconv__Uint128){.lo = ((u64)(0xb5b6101b25490a59U)),.hi = ((u64)(0x02223e65e5e97804U)),}, (strconv__Uint128){.lo = ((u64)(0x22bce691d541aa27U)),.hi = ((u64)(0x0369fd6fd64259a1U)),}, (strconv__Uint128){.lo = ((u64)(0xb563eba7ddce21b9U)),.hi = ((u64)(0x02bb31264501e14dU)),}, (strconv__Uint128){.lo = ((u64)(0xf78322ecb171b494U)),.hi = ((u64)(0x022f5a850401810aU)),}, (strconv__Uint128){.lo = ((u64)(0x259e9e47824f8753U)),.hi = ((u64)(0x037ef73b399c01abU)),}, (strconv__Uint128){.lo = ((u64)(0x1e187e9f9b72d2a9U)),.hi = ((u64)(0x02cbf8fc2e1667bcU)),}, (strconv__Uint128){.lo = ((u64)(0x4b46cbb2e2c24221U)),.hi = ((u64)(0x023cc73024deb963U)),}, (strconv__Uint128){.lo = ((u64)(0x120adf849e039d01U)),.hi = ((u64)(0x039471e6a1645bd2U)),}, (strconv__Uint128){.lo = ((u64)(0xdb3be603b19c7d9aU)),.hi = ((u64)(0x02dd27ebb4504974U)),}, (strconv__Uint128){.lo = ((u64)(0x7c2feb3627b0647cU)),.hi = ((u64)(0x024a865629d9d45dU)),}, (strconv__Uint128){.lo = ((u64)(0x2d197856a5e7072cU)),.hi = ((u64)(0x03aa7089dc8fba2fU)),}, (strconv__Uint128){.lo = ((u64)(0x8a7ac6abb7ec05bdU)),.hi = ((u64)(0x02eec06e4a0c94f2U)),}, (strconv__Uint128){.lo = ((u64)(0xd52f05562cbcd164U)),.hi = ((u64)(0x025899f1d4d6dd8eU)),}, (strconv__Uint128){.lo = ((u64)(0x21e4d556adfae8a0U)),.hi = ((u64)(0x03c0f64fbaf1627eU)),}, (strconv__Uint128){.lo = ((u64)(0xe7ea444557fbed4dU)),.hi = ((u64)(0x0300c50c958de864U)),}, (strconv__Uint128){.lo = ((u64)(0xecbb69d1132ff10aU)),.hi = ((u64)(0x0267040a113e5383U)),}, (strconv__Uint128){.lo = ((u64)(0xadf8a94e851981aaU)),.hi = ((u64)(0x03d8067681fd526cU)),}, (strconv__Uint128){.lo = ((u64)(0x8b2d543ed0e13488U)),.hi = ((u64)(0x0313385ece6441f0U)),}, (strconv__Uint128){.lo = ((u64)(0xd5bddcff0d80f6d3U)),.hi = ((u64)(0x0275c6b23eb69b26U)),}, (strconv__Uint128){.lo = ((u64)(0x892fc7fe7c018aebU)),.hi = ((u64)(0x03efa45064575ea4U)),}, (strconv__Uint128){.lo = ((u64)(0x3a8c9ffec99ad589U)),.hi = ((u64)(0x03261d0d1d12b21dU)),}, (strconv__Uint128){.lo = ((u64)(0xc8707fff07af113bU)),.hi = ((u64)(0x0284e40a7da88e7dU)),}, (strconv__Uint128){.lo = ((u64)(0x39f39998d2f2742fU)),.hi = ((u64)(0x0203e9a1fe2071feU)),}, (strconv__Uint128){.lo = ((u64)(0x8fec28f484b7204bU)),.hi = ((u64)(0x033975cffd00b663U)),}, (strconv__Uint128){.lo = ((u64)(0xd989ba5d36f8e6a2U)),.hi = ((u64)(0x02945e3ffd9a2b82U)),}, (strconv__Uint128){.lo = ((u64)(0x47a161e42bfa521cU)),.hi = ((u64)(0x02104b66647b5602U)),}, (strconv__Uint128){.lo = ((u64)(0x0c35696d132a1cf9U)),.hi = ((u64)(0x034d4570a0c5566aU)),}, (strconv__Uint128){.lo = ((u64)(0x09c454574288172dU)),.hi = ((u64)(0x02a4378d4d6aab88U)),}, (strconv__Uint128){.lo = ((u64)(0xa169dd129ba0128bU)),.hi = ((u64)(0x021cf93dd7888939U)),}, (strconv__Uint128){.lo = ((u64)(0x0242fb50f9001dabU)),.hi = ((u64)(0x03618ec958da7529U)),}, (strconv__Uint128){.lo = ((u64)(0x9b68c90d940017bcU)),.hi = ((u64)(0x02b4723aad7b90edU)),}, (strconv__Uint128){.lo = ((u64)(0x4920a0d7a999ac96U)),.hi = ((u64)(0x0229f4fbbdfc73f1U)),}, (strconv__Uint128){.lo = ((u64)(0x750101590f5c4757U)),.hi = ((u64)(0x037654c5fcc71fe8U)),}, (strconv__Uint128){.lo = ((u64)(0x2a6734473f7d05dfU)),.hi = ((u64)(0x02c5109e63d27fedU)),}, (strconv__Uint128){.lo = ((u64)(0xeeb8f69f65fd9e4cU)),.hi = ((u64)(0x0237407eb641fff0U)),}, (strconv__Uint128){.lo = ((u64)(0xe45b24323cc8fd46U)),.hi = ((u64)(0x038b9a6456cfffe7U)),}, (strconv__Uint128){.lo = ((u64)(0xb6af502830a0ca9fU)),.hi = ((u64)(0x02d6151d123fffecU)),}, (strconv__Uint128){.lo = ((u64)(0xf88c402026e7087fU)),.hi = ((u64)(0x0244ddb0db666656U)),}, (strconv__Uint128){.lo = ((u64)(0x2746cd003e3e73feU)),.hi = ((u64)(0x03a162b4923d708bU)),}, (strconv__Uint128){.lo = ((u64)(0x1f6bd73364fec332U)),.hi = ((u64)(0x02e7822a0e978d3cU)),}, (strconv__Uint128){.lo = ((u64)(0xe5efdf5c50cbcf5bU)),.hi = ((u64)(0x0252ce880bac70fcU)),}, (strconv__Uint128){.lo = ((u64)(0x3cb2fefa1adfb22bU)),.hi = ((u64)(0x03b7b0d9ac471b2eU)),}, (strconv__Uint128){.lo = ((u64)(0x308f3261af195b56U)),.hi = ((u64)(0x02f95a47bd05af58U)),}, (strconv__Uint128){.lo = ((u64)(0x5a0c284e25ade2abU)),.hi = ((u64)(0x0261150630d15913U)),}, (strconv__Uint128){.lo = ((u64)(0x29ad0d49d5e30445U)),.hi = ((u64)(0x03ce8809e7b55b52U)),}, (strconv__Uint128){.lo = ((u64)(0x548a7107de4f369dU)),.hi = ((u64)(0x030ba007ec9115dbU)),}, (strconv__Uint128){.lo = ((u64)(0xdd3b8d9fe50c2bb1U)),.hi = ((u64)(0x026fb3398a0dab15U)),}, (strconv__Uint128){.lo = ((u64)(0x952c15cca1ad12b5U)),.hi = ((u64)(0x03e5eb8f434911bcU)),}, (strconv__Uint128){.lo = ((u64)(0x775677d6e7bda891U)),.hi = ((u64)(0x031e560c35d40e30U)),}, (strconv__Uint128){.lo = ((u64)(0xc5dec645863153a7U)),.hi = ((u64)(0x027eab3cf7dcd826U)),}}));
	// Initializations for module builtin :
	_const_init_capicity = 1 << _const_init_log_capicity;
	_const_init_cap = _const_init_capicity - 2;
	_const_hash_mask = ((u32)(0x00FFFFFFU));
	_const_probe_inc = ((u32)(0x01000000U));
	_const_mid_index = _const_degree - 1;
	_const_max_len = 2 * _const_degree - 1;
	_const_children_bytes = /*SizeOfType*/ sizeof(voidptr) * (_const_max_len + 1);
	// Initializations for module os :
	_const_os__std_input_handle = -10;
	_const_os__std_output_handle = -11;
	_const_os__std_error_handle = -12;
	_const_os__file_invalid_file_id = (-1);
	_const_os__invalid_handle_value = ((voidptr)(-1));
	_const_os__hkey_local_machine = ((voidptr)(0x80000002));
	_const_os__hkey_current_user = ((voidptr)(0x80000001));
	_const_os__hwnd_broadcast = ((voidptr)(0xFFFF));
	_const_os__args = __new_array_with_default(0, 0, sizeof(string), 0);
	_const_os__wd_at_startup = os__getwd();
	_const_os__lang_neutral = (_const_os__sublang_neutral);
	// Initializations for module os.cmdline :
	// Initializations for module time :
	_const_time__month_days = new_array_from_c_array(12, 12, sizeof(int), _MOV((int[12]){
		31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}));
	_const_time__absolute_zero_year = ((i64)(-292277022399));
	_const_time__seconds_per_hour = 60 * _const_time__seconds_per_minute;
	_const_time__seconds_per_day = 24 * _const_time__seconds_per_hour;
	_const_time__seconds_per_week = 7 * _const_time__seconds_per_day;
	_const_time__days_per_400_years = 365 * 400 + 97;
	_const_time__days_per_100_years = 365 * 100 + 24;
	_const_time__days_per_4_years = 365 * 4 + 1;
	_const_time__days_before = new_array_from_c_array(13, 13, sizeof(int), _MOV((int[13]){
		0, 31, 31 + 28, 31 + 28 + 31, 31 + 28 + 31 + 30, 31 + 28 + 31 + 30 + 31, 31 + 28 + 31 + 30 + 31 + 30, 31 + 28 + 31 + 30 + 31 + 30 + 31, 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31, 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30, 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31, 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30, 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31}));
	_const_time__long_days = new_array_from_c_array(7, 7, sizeof(string), _MOV((string[7]){tos_lit("Monday"), tos_lit("Tuesday"), tos_lit("Wednesday"), tos_lit("Thusday"), tos_lit("Friday"), tos_lit("Saturday"), tos_lit("Sunday")}));
	_const_time__nanosecond = ((time__Duration)(1));
	_const_time__microsecond = ((time__Duration)(1000)) * _const_time__nanosecond;
	_const_time__millisecond = ((time__Duration)(1000)) * _const_time__microsecond;
	_const_time__second = ((time__Duration)(1000)) * _const_time__millisecond;
	_const_time__minute = ((time__Duration)(60)) * _const_time__second;
	_const_time__hour = ((time__Duration)(60)) * _const_time__minute;
	_const_time__infinite = ((time__Duration)(-1));
	_const_time__start_time = time__init_win_time_start();
	_const_time__freq_time = time__init_win_time_freq();
	_const_time__start_local_time = time__local_as_unix_time();
	// Initializations for module v.token :
	_const_v__token__assign_tokens = new_array_from_c_array(11, 11, sizeof(v__token__Kind), _MOV((v__token__Kind[11]){
		v__token__Kind_assign, v__token__Kind_plus_assign, v__token__Kind_minus_assign, v__token__Kind_mult_assign, v__token__Kind_div_assign, v__token__Kind_xor_assign, v__token__Kind_mod_assign, v__token__Kind_or_assign, v__token__Kind_and_assign, v__token__Kind_right_shift_assign, v__token__Kind_left_shift_assign}));
	_const_v__token__nr_tokens = ((int)(v__token__Kind__end_));
	_const_v__token__valid_at_tokens = new_array_from_c_array(9, 9, sizeof(string), _MOV((string[9]){
		tos_lit("@FN"), tos_lit("@MOD"), tos_lit("@STRUCT"), tos_lit("@VEXE"), tos_lit("@FILE"), tos_lit("@LINE"), tos_lit("@COLUMN"), tos_lit("@VHASH"), tos_lit("@VMOD_FILE")}));
	_const_v__token__token_str = v__token__build_token_str();
	_const_v__token__keywords = v__token__build_keys();
	_const_v__token__precedences = v__token__build_precedences();
	// Initializations for module v.depgraph :
	// Initializations for module flag :
	// Initializations for module semver :
	_const_semver__versions = new_array_from_c_array(3, 3, sizeof(int), _MOV((int[3]){_const_semver__ver_major, _const_semver__ver_minor, _const_semver__ver_patch}));
	// Initializations for module v.vcache :
	// Initializations for module term :
	// Initializations for module v.vmod :
	_const_v__vmod__mod_file_stop_paths = new_array_from_c_array(4, 4, sizeof(string), _MOV((string[4]){tos_lit(".git"), tos_lit(".hg"), tos_lit(".svn"), tos_lit(".v.mod.stop")}));
	_const_v__vmod__private_file_cacher = v__vmod__new_mod_file_cacher();
	// Initializations for module v.cflag :
	// Initializations for module rand.util :
	_const_rand__util__lower_mask = ((u64)(0x00000000FFFFFFFFU));
	_const_rand__util__max_u32_as_f32 = ((f32)(_const_rand__util__max_u32)) + 1;
	_const_rand__util__max_u64_as_f64 = ((f64)(_const_rand__util__max_u64)) + 1;
	_const_rand__util__u31_mask = ((u32)(0x7FFFFFFFU));
	_const_rand__util__u63_mask = ((u64)(0x7FFFFFFFFFFFFFFFU));
	// Initializations for module v.errors :
	// Initializations for module v.pkgconfig :
	_const_v__pkgconfig__default_paths = new_array_from_c_array(6, 6, sizeof(string), _MOV((string[6]){tos_lit("/usr/local/lib/x86_64-linux-gnu/pkgconfig"), tos_lit("/usr/local/lib/pkgconfig"), tos_lit("/usr/local/share/pkgconfig"), tos_lit("/usr/lib/x86_64-linux-gnu/pkgconfig"), tos_lit("/usr/lib/pkgconfig"), tos_lit("/usr/share/pkgconfig")}));
	// Initializations for module vweb.tmpl :
	// Initializations for module runtime :
	// Initializations for module v.table :
	_const_v__table__integer_type_idxs = new_array_from_c_array(10, 10, sizeof(int), _MOV((int[10]){
		_const_v__table__i8_type_idx, _const_v__table__i16_type_idx, _const_v__table__int_type_idx, _const_v__table__i64_type_idx, _const_v__table__byte_type_idx, _const_v__table__u16_type_idx, _const_v__table__u32_type_idx, _const_v__table__u64_type_idx, _const_v__table__any_int_type_idx, _const_v__table__rune_type_idx}));
	_const_v__table__signed_integer_type_idxs = new_array_from_c_array(4, 4, sizeof(int), _MOV((int[4]){_const_v__table__i8_type_idx, _const_v__table__i16_type_idx, _const_v__table__int_type_idx, _const_v__table__i64_type_idx}));
	_const_v__table__unsigned_integer_type_idxs = new_array_from_c_array(4, 4, sizeof(int), _MOV((int[4]){_const_v__table__byte_type_idx, _const_v__table__u16_type_idx, _const_v__table__u32_type_idx, _const_v__table__u64_type_idx}));
	_const_v__table__float_type_idxs = new_array_from_c_array(3, 3, sizeof(int), _MOV((int[3]){_const_v__table__f32_type_idx, _const_v__table__f64_type_idx, _const_v__table__any_flt_type_idx}));
	_const_v__table__number_type_idxs = new_array_from_c_array(13, 13, sizeof(int), _MOV((int[13]){
		_const_v__table__i8_type_idx, _const_v__table__i16_type_idx, _const_v__table__int_type_idx, _const_v__table__i64_type_idx, _const_v__table__byte_type_idx, _const_v__table__u16_type_idx, _const_v__table__u32_type_idx, _const_v__table__u64_type_idx, _const_v__table__f32_type_idx, _const_v__table__f64_type_idx, _const_v__table__any_int_type_idx, _const_v__table__any_flt_type_idx, _const_v__table__rune_type_idx}));
	_const_v__table__pointer_type_idxs = new_array_from_c_array(3, 3, sizeof(int), _MOV((int[3]){_const_v__table__voidptr_type_idx, _const_v__table__byteptr_type_idx, _const_v__table__charptr_type_idx}));
	_const_v__table__string_type_idxs = new_array_from_c_array(2, 2, sizeof(int), _MOV((int[2]){_const_v__table__string_type_idx, _const_v__table__ustring_type_idx}));
	_const_v__table__void_type = v__table__new_type(_const_v__table__void_type_idx);
	_const_v__table__voidptr_type = v__table__new_type(_const_v__table__voidptr_type_idx);
	_const_v__table__byteptr_type = v__table__new_type(_const_v__table__byteptr_type_idx);
	_const_v__table__charptr_type = v__table__new_type(_const_v__table__charptr_type_idx);
	_const_v__table__i8_type = v__table__new_type(_const_v__table__i8_type_idx);
	_const_v__table__int_type = v__table__new_type(_const_v__table__int_type_idx);
	_const_v__table__i16_type = v__table__new_type(_const_v__table__i16_type_idx);
	_const_v__table__i64_type = v__table__new_type(_const_v__table__i64_type_idx);
	_const_v__table__byte_type = v__table__new_type(_const_v__table__byte_type_idx);
	_const_v__table__u16_type = v__table__new_type(_const_v__table__u16_type_idx);
	_const_v__table__u32_type = v__table__new_type(_const_v__table__u32_type_idx);
	_const_v__table__u64_type = v__table__new_type(_const_v__table__u64_type_idx);
	_const_v__table__f32_type = v__table__new_type(_const_v__table__f32_type_idx);
	_const_v__table__f64_type = v__table__new_type(_const_v__table__f64_type_idx);
	_const_v__table__char_type = v__table__new_type(_const_v__table__char_type_idx);
	_const_v__table__bool_type = v__table__new_type(_const_v__table__bool_type_idx);
	_const_v__table__none_type = v__table__new_type(_const_v__table__none_type_idx);
	_const_v__table__string_type = v__table__new_type(_const_v__table__string_type_idx);
	_const_v__table__ustring_type = v__table__new_type(_const_v__table__ustring_type_idx);
	_const_v__table__array_type = v__table__new_type(_const_v__table__array_type_idx);
	_const_v__table__map_type = v__table__new_type(_const_v__table__map_type_idx);
	_const_v__table__chan_type = v__table__new_type(_const_v__table__chan_type_idx);
	_const_v__table__rune_type = v__table__new_type(_const_v__table__rune_type_idx);
	_const_v__table__any_type = v__table__new_type(_const_v__table__any_type_idx);
	_const_v__table__any_flt_type = v__table__new_type(_const_v__table__any_flt_type_idx);
	_const_v__table__any_int_type = v__table__new_type(_const_v__table__any_int_type_idx);
	_const_v__table__builtin_type_names = new_array_from_c_array(30, 30, sizeof(string), _MOV((string[30]){
		tos_lit("void"), tos_lit("voidptr"), tos_lit("charptr"), tos_lit("byteptr"), tos_lit("i8"), tos_lit("i16"), tos_lit("int"), tos_lit("i64"), tos_lit("u16"), tos_lit("u32"), tos_lit("u64"), tos_lit("any_int"), tos_lit("f32"), tos_lit("f64"), tos_lit("any_float"), tos_lit("string"), tos_lit("ustring"), tos_lit("char"), tos_lit("byte"), tos_lit("bool"), tos_lit("none"), tos_lit("array"), tos_lit("array_fixed"), tos_lit("map"), tos_lit("chan"), tos_lit("any"), tos_lit("struct"), tos_lit("mapnode"), tos_lit("size_t"), tos_lit("rune")}));
	// Initializations for module rand.wyrand :
	_const_rand__wyrand__wyp0 = ((u64)(0xa0761d6478bd642fU));
	_const_rand__wyrand__wyp1 = ((u64)(0xe7037ed1a0b428dbU));
	// Initializations for module rand :
	rand__init();
	// Initializations for module v.pref :
	_const_v__pref__default_module_path = os__vmodules_dir();
	_const_v__pref__list_of_flags_with_param = new_array_from_c_array(11, 11, sizeof(string), _MOV((string[11]){
		tos_lit("o"), tos_lit("d"), tos_lit("define"), tos_lit("b"), tos_lit("backend"), tos_lit("cc"), tos_lit("os"), tos_lit("target-os"), tos_lit("cf"), tos_lit("cflags"), tos_lit("path")}));
	// Initializations for module help :
	// Initializations for module v.util :
	_const_v__util__emanager = v__util__new_error_manager();
	_const_v__util__invalid_escapes = new_array_from_c_array(5, 5, sizeof(string), _MOV((string[5]){tos_lit("("), tos_lit("{"), tos_lit("$"), tos_lit("`"), tos_lit(".")}));
	_const_v__util__builtin_module_parts = new_array_from_c_array(6, 6, sizeof(string), _MOV((string[6]){tos_lit("math.bits"), tos_lit("strconv"), tos_lit("strconv.ftoa"), tos_lit("hash"), tos_lit("strings"), tos_lit("builtin")}));
	_const_v__util__external_module_dependencies_for_tool = new_map_init(1, sizeof(array_string), _MOV((string[1]){tos_lit("vdoc"), }), _MOV((array_string[1]){new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){tos_lit("markdown")})), }));
	// Initializations for module v.ast :
	// Initializations for module v.scanner :
	// Initializations for module v.checker :
	_const_v__checker__int_min = ((int)(0x80000000));
	_const_v__checker__valid_comp_if_os = new_array_from_c_array(18, 18, sizeof(string), _MOV((string[18]){
		tos_lit("windows"), tos_lit("ios"), tos_lit("macos"), tos_lit("mach"), tos_lit("darwin"), tos_lit("hpux"), tos_lit("gnu"), tos_lit("qnx"), tos_lit("linux"), tos_lit("freebsd"), tos_lit("openbsd"), tos_lit("netbsd"), tos_lit("bsd"), tos_lit("dragonfly"), tos_lit("android"), tos_lit("solaris"), tos_lit("haiku"), tos_lit("linux_or_macos")}));
	_const_v__checker__valid_comp_if_compilers = new_array_from_c_array(6, 6, sizeof(string), _MOV((string[6]){tos_lit("gcc"), tos_lit("tinyc"), tos_lit("clang"), tos_lit("mingw"), tos_lit("msvc"), tos_lit("cplusplus")}));
	_const_v__checker__valid_comp_if_platforms = new_array_from_c_array(6, 6, sizeof(string), _MOV((string[6]){tos_lit("amd64"), tos_lit("aarch64"), tos_lit("x64"), tos_lit("x32"), tos_lit("little_endian"), tos_lit("big_endian")}));
	_const_v__checker__valid_comp_if_other = new_array_from_c_array(6, 6, sizeof(string), _MOV((string[6]){tos_lit("js"), tos_lit("debug"), tos_lit("test"), tos_lit("glibc"), tos_lit("prealloc"), tos_lit("no_bounds_checking")}));
	// Initializations for module v.parser :
	_const_v__parser__supported_platforms = new_array_from_c_array(13, 13, sizeof(string), _MOV((string[13]){
		tos_lit("windows"), tos_lit("macos"), tos_lit("darwin"), tos_lit("linux"), tos_lit("freebsd"), tos_lit("openbsd"), tos_lit("netbsd"), tos_lit("dragonfly"), tos_lit("android"), tos_lit("js"), tos_lit("solaris"), tos_lit("haiku"), tos_lit("linux_or_macos")}));
	_const_v__parser__supported_ccompilers = new_array_from_c_array(5, 5, sizeof(string), _MOV((string[5]){tos_lit("tinyc"), tos_lit("clang"), tos_lit("mingw"), tos_lit("msvc"), tos_lit("gcc")}));
	_const_v__parser__todo_delete_me = v__pref__OS_linux;
	_const_v__parser__global_enabled_mods = new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){tos_lit("rand"), tos_lit("sokol.sapp")}));
	// Initializations for module v.gen :
	_const_v__gen__c_reserved = new_array_from_c_array(37, 37, sizeof(string), _MOV((string[37]){
		tos_lit("delete"), tos_lit("exit"), tos_lit("link"), tos_lit("unix"), tos_lit("error"), tos_lit("calloc"), tos_lit("malloc"), tos_lit("free"), tos_lit("panic"), tos_lit("auto"), tos_lit("char"), tos_lit("default"), tos_lit("do"), tos_lit("double"), tos_lit("extern"), tos_lit("float"), tos_lit("inline"), tos_lit("int"), tos_lit("long"), tos_lit("register"), tos_lit("restrict"), tos_lit("short"), tos_lit("signed"), tos_lit("sizeof"), tos_lit("static"), tos_lit("switch"), tos_lit("typedef"), tos_lit("union"), tos_lit("unsigned"), tos_lit("void"), tos_lit("volatile"), tos_lit("while"), tos_lit("new"), tos_lit("namespace"), tos_lit("class"), tos_lit("typename"), tos_lit("export")}));
	_const_v__gen__cmp_str = new_array_from_c_array(6, 6, sizeof(string), _MOV((string[6]){tos_lit("eq"), tos_lit("ne"), tos_lit("gt"), tos_lit("lt"), tos_lit("ge"), tos_lit("le")}));
	_const_v__gen__cmp_rev = new_array_from_c_array(6, 6, sizeof(string), _MOV((string[6]){tos_lit("eq"), tos_lit("ne"), tos_lit("le"), tos_lit("ge"), tos_lit("lt"), tos_lit("gt")}));
	_const_v__gen__tabs = new_array_from_c_array(9, 9, sizeof(string), _MOV((string[9]){
		tos_lit(""), tos_lit("\t"), tos_lit("\t\t"), tos_lit("\t\t\t"), tos_lit("\t\t\t\t"), tos_lit("\t\t\t\t\t"), tos_lit("\t\t\t\t\t\t"), tos_lit("\t\t\t\t\t\t\t"), tos_lit("\t\t\t\t\t\t\t\t")}));
	_const_v__gen__skip_struct_init = new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){tos_lit("struct stat"), tos_lit("struct addrinfo")}));
	_const_v__gen__builtins = new_array_from_c_array(6, 6, sizeof(string), _MOV((string[6]){tos_lit("string"), tos_lit("array"), tos_lit("KeyValue"), tos_lit("DenseArray"), tos_lit("map"), tos_lit("Option")}));
	_const_v__gen__c_headers = _STR("\n// c_headers\ntypedef int (*qsort_callback_func)(const void*, const void*);\n#include <stdio.h>  // TODO remove all these includes, define all function signatures and types manually\n#include <stdlib.h>\n\n#if defined(_WIN32) || defined(__CYGWIN__)\n	#define VV_EXPORTED_SYMBOL extern __declspec(dllexport)\n	#define VV_LOCAL_SYMBOL static\n#else\n	// 4 < gcc < 5 is used by some older Ubuntu LTS and Centos versions,\n	// and does not support __has_attribute(visibility) ...\n	#ifndef __has_attribute\n		#define __has_attribute(x) 0  // Compatibility with non-clang compilers.\n	#endif\n	#if (defined(__GNUC__) && (__GNUC__ >= 4)) || (defined(__clang__) && __has_attribute(visibility))\n		#define VV_EXPORTED_SYMBOL extern __attribute__ ((visibility (\"default\")))\n		#define VV_LOCAL_SYMBOL  __attribute__ ((visibility (\"hidden\")))\n	#else\n		#define VV_EXPORTED_SYMBOL extern\n		#define VV_LOCAL_SYMBOL static\n	#endif\n#endif\n\n#ifdef __cplusplus\n	#include <utility>\n	#define _MOV std::move\n#else\n	#define _MOV\n#endif\n\n#ifndef _WIN32\n	#if defined __has_include\n		#if __has_include (<execinfo.h>)\n			#include <execinfo.h>\n		#else\n			// Most probably musl OR __ANDROID__ ...\n			int backtrace (void **__array, int __size) { return 0; }\n			char **backtrace_symbols (void *const *__array, int __size){ return 0; }\n			void backtrace_symbols_fd (void *const *__array, int __size, int __fd){}\n		#endif\n	#endif\n#endif\n\n//#include \"fns.h\"\n#include <signal.h>\n#include <stdarg.h> // for va_list\n#include <string.h> // memcpy\n\n#if INTPTR_MAX == INT32_MAX\n	#define TARGET_IS_32BIT 1\n#elif INTPTR_MAX == INT64_MAX\n	#define TARGET_IS_64BIT 1\n#else\n	#error \"The environment is not 32 or 64-bit.\"\n#endif\n\n#if defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__ || defined(__BYTE_ORDER) && __BYTE_ORDER == __BIG_ENDIAN || defined(__BIG_ENDIAN__) || defined(__ARMEB__) || defined(__THUMBEB__) || defined(__AARCH64EB__) || defined(_MIBSEB) || defined(__MIBSEB) || defined(__MIBSEB__)\n	#define TARGET_ORDER_IS_BIG\n#elif defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__ || defined(__BYTE_ORDER) && __BYTE_ORDER == __LITTLE_ENDIAN || defined(__LITTLE_ENDIAN__) || defined(__ARMEL__) || defined(__THUMBEL__) || defined(__AARCH64EL__) || defined(_MIPSEL) || defined(__MIPSEL) || defined(__MIPSEL__) || defined(_M_AMD64) || defined(_M_X64) || defined(_M_IX86)\n	#define TARGET_ORDER_IS_LITTLE\n#else\n	#error \"Unknown architecture endianness\"\n#endif\n\n#ifndef _WIN32\n	#include <ctype.h>\n	#include <locale.h> // tolower\n	#include <sys/time.h>\n	#include <unistd.h> // sleep\n	extern char **environ;\n#endif\n\n#if defined(__CYGWIN__) && !defined(_WIN32)\n	#error Cygwin is not supported, please use MinGW or Visual Studio.\n#endif\n\n#ifdef __linux__\n	#include <sys/types.h>\n	#include <sys/wait.h> // os__wait uses wait on nix\n#endif\n\n#ifdef __FreeBSD__\n	#include <sys/types.h>\n	#include <sys/wait.h> // os__wait uses wait on nix\n#endif\n\n#ifdef __DragonFly__\n	#include <sys/types.h>\n	#include <sys/wait.h> // os__wait uses wait on nix\n#endif\n\n#ifdef __OpenBSD__\n	#include <sys/types.h>\n	#include <sys/resource.h>\n	#include <sys/wait.h> // os__wait uses wait on nix\n#endif\n\n#ifdef __NetBSD__\n	#include <sys/wait.h> // os__wait uses wait on nix\n#endif\n\n#ifdef __sun\n	#include <sys/types.h>\n	#include <sys/wait.h> // os__wait uses wait on nix\n#endif\n\n%.*s\000\n\n#ifdef _WIN32\n	#define WINVER 0x0600\n	#ifdef _WIN32_WINNT\n		#undef _WIN32_WINNT\n	#endif\n	#define _WIN32_WINNT 0x0600\n	#define WIN32_LEAN_AND_MEAN\n	#ifndef _UNICODE\n	#define _UNICODE\n	#endif\n	#ifndef UNICODE\n	#define UNICODE\n	#endif\n	#include <windows.h>\n\n	#include <io.h> // _waccess\n	#include <direct.h> // _wgetcwd\n	//#include <WinSock2.h>\n\n	#ifdef _MSC_VER\n		// On MSVC these are the same (as long as /volatile:ms is passed)\n		#define _Atomic volatile\n\n		// MSVC cannot parse some things properly\n		#undef EMPTY_STRUCT_DECLARATION\n		#undef OPTION_CAST\n\n		#define EMPTY_STRUCT_DECLARATION int ____dummy_variable\n		#define OPTION_CAST(x)\n		#undef __NOINLINE\n		#undef __IRQHANDLER\n		#define __NOINLINE __declspec(noinline)\n		#define __IRQHANDLER __declspec(naked)\n\n		#include <dbghelp.h>\n		#pragma comment(lib, \"Dbghelp.lib\")\n\n		extern wchar_t **_wenviron;\n	#elif !defined(SRWLOCK_INIT)\n		// these seem to be missing on Windows tcc\n		typedef struct SRWLOCK { void* SRWLOCK; } SRWLOCK;\n		void InitializeSRWLock(void*);\n		void AcquireSRWLockShared(void*);\n		void AcquireSRWLockExclusive(void*);\n		void ReleaseSRWLockShared(void*);\n		void ReleaseSRWLockExclusive(void*);\n	#endif\n#else\n	#include <pthread.h>\n	#ifndef PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP\n		// musl does not have that\n		#define pthread_rwlockattr_setkind_np(a, b)\n	#endif\n#endif\n\n// g_live_info is used by live.info()\nvoid* g_live_info = NULL;\n\n//============================== HELPER C MACROS =============================*/\n//#define tos4(s, slen) ((string){.str=(s), .len=(slen)})\n#define _SLIT(s) ((string){.str=(byteptr)(s), .len=(strlen(s))})\n#define _PUSH_MANY(arr, val, tmp, tmp_typ) {tmp_typ tmp = (val); array_push_many(arr, tmp.data, tmp.len);}\n#define _IN(typ, val, arr) array_##typ##_contains(arr, val)\n#define _IN_MAP(val, m) map_exists(m, val)\n\n// these macros have corresponding implementations in builtin/int.v with different signedness\n#define array_i8_contains(a, b) array_byte_contains(a, (byte)(b))\n#define array_i16_contains(a, b) array_u16_contains(a, (u16)(b))\n#define array_u32_contains(a, b) array_int_contains(a, (int)(b))\n#define array_i64_contains(a, b) array_u64_contains(a, (u64)(b))\n#define array_rune_contains(a, b) array_int_contains(a, (int)(b))\n#define array_f32_contains(a, b) array_int_contains(a, *(int*)&((f32[]){(b)}))\n#define array_f64_contains(a, b) array_u64_contains(a, *(u64*)&((f64[]){(b)}))\n#ifdef TARGET_IS_64BIT\n#define array_voidptr_contains(a, b) array_u64_contains(a, (u64)(b))\n#else\n#define array_voidptr_contains(a, b) array_int_contains(a, (int)(b))\n#endif\n\n// unsigned/signed comparisons\nstatic inline bool _us32_gt(uint32_t a, int32_t b) { return a > INT32_MAX || (int32_t)a > b; }\nstatic inline bool _us32_ge(uint32_t a, int32_t b) { return a >= INT32_MAX || (int32_t)a >= b; }\nstatic inline bool _us32_eq(uint32_t a, int32_t b) { return a <= INT32_MAX && (int32_t)a == b; }\nstatic inline bool _us32_ne(uint32_t a, int32_t b) { return a > INT32_MAX || (int32_t)a != b; }\nstatic inline bool _us32_le(uint32_t a, int32_t b) { return a <= INT32_MAX && (int32_t)a <= b; }\nstatic inline bool _us32_lt(uint32_t a, int32_t b) { return a < INT32_MAX && (int32_t)a < b; }\nstatic inline bool _us64_gt(uint64_t a, int64_t b) { return a > INT64_MAX || (int64_t)a > b; }\nstatic inline bool _us64_ge(uint64_t a, int64_t b) { return a >= INT64_MAX || (int64_t)a >= b; }\nstatic inline bool _us64_eq(uint64_t a, int64_t b) { return a <= INT64_MAX && (int64_t)a == b; }\nstatic inline bool _us64_ne(uint64_t a, int64_t b) { return a > INT64_MAX || (int64_t)a != b; }\nstatic inline bool _us64_le(uint64_t a, int64_t b) { return a <= INT64_MAX && (int64_t)a <= b; }\nstatic inline bool _us64_lt(uint64_t a, int64_t b) { return a < INT64_MAX && (int64_t)a < b; }\n\n#if defined(__MINGW32__) || defined(__MINGW64__) || (defined(_WIN32) && defined(__TINYC__))\n	#undef PRId64\n	#undef PRIi64\n	#undef PRIo64\n	#undef PRIu64\n	#undef PRIx64\n	#undef PRIX64\n	#define PRId64 \"lld\"\n	#define PRIi64 \"lli\"\n	#define PRIo64 \"llo\"\n	#define PRIu64 \"llu\"\n	#define PRIx64 \"llx\"\n	#define PRIX64 \"llX\"\n#endif\n\n//================================== GLOBALS =================================*/\n//byte g_str_buf[1024];\nbyte* g_str_buf;\nint load_so(byteptr);\nvoid reload_so();\nvoid _vinit();\nvoid _vcleanup();\n#define sigaction_size sizeof(sigaction);\n#define _ARR_LEN(a) ( (sizeof(a)) / (sizeof(a[0])) )\n\n// ============== wyhash ==============\n//Author: Wang Yi\n#ifndef wyhash_version_gamma\n	#define wyhash_version_gamma\n	#define WYHASH_CONDOM 0\n	#include <stdint.h>\n	#include <string.h>\n	#if defined(_MSC_VER) && defined(_M_X64)\n		#include <intrin.h>\n		#pragma intrinsic(_umul128)\n	#endif\n\n	//const uint64_t _wyp0=0xa0761d6478bd642full, _wyp1=0xe7037ed1a0b428dbull;\n	#define _wyp0 ((uint64_t)0xa0761d6478bd642full)\n	#define _wyp1 ((uint64_t)0xe7037ed1a0b428dbull)\n\n	#if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__) || defined(__TINYC__)\n		#define _likely_(x) __builtin_expect(x, 1)\n		#define _unlikely_(x) __builtin_expect((x), 0)\n	#else\n		#define _likely_(x) (x)\n		#define _unlikely_(x) (x)\n	#endif\n\n	#if defined(TARGET_ORDER_IS_LITTLE)\n		#define WYHASH_LITTLE_ENDIAN 1\n	#elif defined(TARGET_ORDER_IS_BIG)\n		#define WYHASH_LITTLE_ENDIAN 0\n	#endif\n\n	#if (WYHASH_LITTLE_ENDIAN)\n		static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return v;}\n		static inline uint64_t _wyr4(const uint8_t *p) { unsigned v; memcpy(&v, p, 4); return v;}\n	#else\n		#if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)\n			static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return __builtin_bswap64(v);}\n			static inline uint64_t _wyr4(const uint8_t *p) { unsigned v; memcpy(&v, p, 4); return __builtin_bswap32(v);}\n		#elif defined(_MSC_VER)\n			static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return _byteswap_uint64(v);}\n			static inline uint64_t _wyr4(const uint8_t *p) { unsigned v; memcpy(&v, p, 4); return _byteswap_ulong(v);}\n		#elif defined(__TINYC__)\n			static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return bswap_64(v);}\n			static inline uint64_t _wyr4(const uint8_t *p) { unsigned v; memcpy(&v, p, 4); return bswap_32(v);}\n		#endif\n	#endif\n\n	static inline uint64_t _wyr3(const uint8_t *p, unsigned k) { return (((uint64_t)p[0]) << 16) | (((uint64_t)p[k >> 1]) << 8) | p[k - 1];}\n	static inline uint64_t _wyrotr(uint64_t v, unsigned k) { return (v >> k) | (v << (64 - k));}\n	static inline void _wymix128(uint64_t A, uint64_t B, uint64_t *C, uint64_t *D){\n		A^=*C;	B^=*D;\n	#ifdef UNOFFICIAL_WYHASH_32BIT\n		uint64_t hh=(A>>32)*(B>>32), hl=(A>>32)*(unsigned)B, lh=(unsigned)A*(B>>32), ll=(uint64_t)(unsigned)A*(unsigned)B;\n		*C=_wyrotr(hl,32)^hh; *D=_wyrotr(lh,32)^ll;\n	#else\n		#ifdef __SIZEOF_INT128__\n			__uint128_t r=A; r*=B; *C=(uint64_t)r; *D=(uint64_t)(r>>64);\n		#elif defined(_MSC_VER) && defined(_M_X64)\n			A=_umul128(A,B,&B); *C=A; *D=B;\n		#else\n			uint64_t ha=A>>32, hb=B>>32, la=(uint32_t)A, lb=(uint32_t)B, hi, lo;\n			uint64_t rh=ha*hb, rm0=ha*lb, rm1=hb*la, rl=la*lb, t=rl+(rm0<<32), c=t<rl;\n			lo=t+(rm1<<32); c+=lo<t; hi=rh+(rm0>>32)+(rm1>>32)+c;\n			*C=lo;	*D=hi;\n		#endif\n	#endif\n	}\n	static inline uint64_t wyhash(const void *key, uint64_t len, uint64_t seed){\n		const uint8_t *p=(const uint8_t *)key;\n		uint64_t i=len, see1=seed;\n		start:\n		if (_likely_(i<=16)) {\n	#ifndef	WYHASH_CONDOM\n			uint64_t shift = (i<8)*((8-i)<<3);\n			//WARNING: intended reading outside buffer, trading for speed.\n			_wymix128((_wyr8(p)<<shift)^_wyp0, (_wyr8(p+i-8)>>shift)^_wyp1, &seed, &see1);\n	#else\n			if (_likely_(i<=8)) {\n				if (_likely_(i>=4)) _wymix128(_wyr4(p)^_wyp0,_wyr4(p+i-4)^_wyp1, &seed, &see1);\n				else if (_likely_(i)) _wymix128(_wyr3(p,i)^_wyp0,_wyp1, &seed, &see1);\n				else _wymix128(_wyp0,_wyp1, &seed, &see1);\n			}\n			else _wymix128(_wyr8(p)^_wyp0,_wyr8(p+i-8)^_wyp1, &seed, &see1);\n	#endif\n			_wymix128(len,_wyp0, &seed, &see1);\n			return	seed^see1;\n		}\n		_wymix128(_wyr8(p)^_wyp0,_wyr8(p+8)^_wyp1, &seed, &see1);\n		i-=16;	p+=16;	goto start;\n	}\n	static inline uint64_t wyhash64(uint64_t A, uint64_t B){\n		_wymix128(_wyp0,_wyp1,&A,&B);\n		_wymix128(0,0,&A,&B);\n		return	A^B;\n	}\n	static inline uint64_t wyrand(uint64_t *seed){\n		*seed+=_wyp0;\n		uint64_t	a=0, b=0;\n		_wymix128(*seed,*seed^_wyp1,&a,&b);\n		return	a^b;\n	}\n	static inline double wy2u01(uint64_t r) {\n		const double _wynorm=1.0/(1ull<<52);\n		return (r>>12)*_wynorm;\n	}\n	static inline double wy2gau(uint64_t r) {\n		const double _wynorm=1.0/(1ull<<20);\n		return ((r&0x1fffff)+((r>>21)&0x1fffff)+((r>>42)&0x1fffff))*_wynorm-3.0;\n	}\n#endif\n\nvoidptr memdup(voidptr src, int sz);\nvoidptr memfreedup(voidptr ptr, voidptr src, int sz) {\n	free(ptr);\n	return memdup(src, sz);\n}\n", 2, _const_v__gen__c_common_macros);
	_const_v__gen__bare_c_headers = _STR("\n%.*s\000\n\n#ifndef exit\n#define exit(rc) sys_exit(rc)\nvoid sys_exit (int);\n#endif\n", 2, _const_v__gen__c_common_macros);
	// Initializations for module v.gen.js :
	_const_v__gen__js__js_reserved = new_array_from_c_array(43, 43, sizeof(string), _MOV((string[43]){
		tos_lit("await"), tos_lit("break"), tos_lit("case"), tos_lit("catch"), tos_lit("class"), tos_lit("const"), tos_lit("continue"), tos_lit("debugger"), tos_lit("default"), tos_lit("delete"), tos_lit("do"), tos_lit("else"), tos_lit("enum"), tos_lit("export"), tos_lit("extends"), tos_lit("finally"), tos_lit("for"), tos_lit("function"), tos_lit("if"), tos_lit("implements"), tos_lit("import"), tos_lit("in"), tos_lit("instanceof"), tos_lit("interface"), tos_lit("let"), tos_lit("new"), tos_lit("package"), tos_lit("private"), tos_lit("protected"), tos_lit("public"), tos_lit("return"), tos_lit("static"), tos_lit("super"), tos_lit("switch"), tos_lit("this"), tos_lit("throw"), tos_lit("try"), tos_lit("typeof"), tos_lit("var"), tos_lit("void"), tos_lit("while"), tos_lit("with"), tos_lit("yield")}));
	_const_v__gen__js__tabs = new_array_from_c_array(12, 12, sizeof(string), _MOV((string[12]){
		tos_lit(""), tos_lit("\t"), tos_lit("\t\t"), tos_lit("\t\t\t"), tos_lit("\t\t\t\t"), tos_lit("\t\t\t\t\t"), tos_lit("\t\t\t\t\t\t"), tos_lit("\t\t\t\t\t\t\t"), tos_lit("\t\t\t\t\t\t\t\t"), tos_lit("\t\t\t\t\t\t\t\t\t"), tos_lit("\t\t\t\t\t\t\t\t\t"), tos_lit("\t\t\t\t\t\t\t\t\t")}));
	// Initializations for module v.gen.x64 :
	_const_v__gen__x64__mag0 = ((byte)(0x7f));
	_const_v__gen__x64__fn_arg_registers = new_array_from_c_array(6, 6, sizeof(v__gen__x64__Register), _MOV((v__gen__x64__Register[6]){v__gen__x64__Register_rdi, v__gen__x64__Register_rsi, v__gen__x64__Register_rdx, v__gen__x64__Register_rcx, v__gen__x64__Register_r8, v__gen__x64__Register_r9}));
	// Initializations for module v.builder :
	_const_v__builder__hkey_local_machine = ((v__builder__RegKey)(0x80000002));
	_const_v__builder__key_query_value = (0x0001);
	_const_v__builder__key_wow64_32key = (0x0200);
	_const_v__builder__key_enumerate_sub_keys = (0x0008);
	// Initializations for module main :
	_const_main__simple_cmd = new_array_from_c_array(20, 20, sizeof(string), _MOV((string[20]){
		tos_lit("fmt"), tos_lit("up"), tos_lit("vet"), tos_lit("self"), tos_lit("tracev"), tos_lit("symlink"), tos_lit("bin2v"), tos_lit("test"), tos_lit("test-fmt"), tos_lit("test-compiler"), tos_lit("test-fixed"), tos_lit("test-cleancode"), tos_lit("repl"), tos_lit("complete"), tos_lit("build-tools"), tos_lit("build-examples"), tos_lit("build-vbinaries"), tos_lit("setup-freetype"), tos_lit("doc"), tos_lit("doctor")}));
	_const_main__list_of_flags_that_allow_duplicates = new_array_from_c_array(5, 5, sizeof(string), _MOV((string[5]){tos_lit("cc"), tos_lit("d"), tos_lit("define"), tos_lit("cf"), tos_lit("cflags")}));
}

int wmain(int ___argc, wchar_t* ___argv[], wchar_t* ___envp[]){
	_vinit();
	_const_os__args = os__init_os_args_wide(___argc, ___argv);
	main__main();
	return 0;
}

// THE END.

